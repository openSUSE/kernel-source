#!/bin/sh

# Especially during feature development it can easily happen that a patch that
# was added to base branch as fix is added to derived branch as part of a
# feature by different developer under different name. Merging the base branch
# then becomes difficult.

# This script checks a few patch tags to match patch files across two
# kernel-source branches and moves patch files in the working tree to match
# filenames in the branch you specify.

# This then allows merging more easily: instead of duplicated patch files that
# git does not know how to detect you get conflicting added files under same
# filename which git does point out.

# Also if the reference branch contains duplicate files the rename is not
# stable. That is if you run renamefiles, commit the result, run it again, and
# there are changes again you have duplicate patches in the reference branch
# with which you are trying to aling patch names. This can be either false
# positive because mutiple patch tags are checked or an actual patch that
# applies indefinitely because it adds the same context it applies to which is
# applied multiple times.

if [ $# != 1 ] ; then
	echo Usage: $0 "<branch name>"
	echo Run in kernel-source to rename patches in the current branch to the same filename as they ahve in the given branch.
	exit 1
fi
branch=$1
trap 'rm -f "$temp"' EXIT
temp=$(mktemp)
git grep -iE '^(Git-commit:|No-fix:|\(cherry picked from commit)' $branch | grep -vF patches.kernel.org > $temp

grep -E "^[[:space:]]*patches\.[a-z]+\/" < series.conf | while read patch ; do
	commit="$([ -f $patch ] && { grep -iE "^(Git-commit|No-fix):" < $patch | awk '{ print $2}' ;
	 grep -i "^(cherry picked from commit" < $patch | awk '{ print $5}' ; } )"
	[ -n "$commit" ] && echo "$commit" | while read c ; do
	       grep -F $c < $temp | tr ':' ' ' | while read junk fn blah ; do
	            [ -n "$fn" ] && [ $fn != $patch ] && git mv $patch  $fn && sed -i -e "s,$patch,$fn," series.conf
       done
   done
done

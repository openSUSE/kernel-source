From: Nikolay Borisov <bp@alien8.de>
Date: Tue, 22 Aug 2023 13:53:41 +0200
Subject: kabi: Allow extra bugsints
Patch-mainline: Never, kabi fix
References: bsc#1213927

Allow adding more bugints by stashing them in an extra array added at the
end of cpuid_x86 thus ont breaking kABI. All extra bugints begin at
cpuid_x86::x86_ext_capability and also at the end ot cpu_caps_set array.


Signed-off-by: Nikolay Borisov  <nik.borisov@suse.com>
---
 arch/x86/include/asm/cpufeature.h  |   23 +++++++++++++++++++----
 arch/x86/include/asm/cpufeatures.h |    2 +-
 arch/x86/include/asm/processor.h   |    5 ++++-
 arch/x86/kernel/alternative.c      |    2 +-
 arch/x86/kernel/cpu/common.c       |    7 ++++++-
 arch/x86/kernel/cpu/mkcapflags.sh  |    2 +-
 arch/x86/kernel/cpu/proc.c         |    2 +-
 7 files changed, 33 insertions(+), 10 deletions(-)

--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@ -49,10 +49,14 @@ extern const char * const x86_power_flag
  * In order to save room, we index into this array by doing
  * X86_BUG_<name> - NCAPINTS*32.
  */
-extern const char * const x86_bug_flags[NBUGINTS*32];
+extern const char * const x86_bug_flags[(NBUGINTS+NEXTBUGINTS)*32];
+
+#define IS_EXT_BUGBIT(bit) ((bit>>5) >= (NCAPINTS+NBUGINTS))
 
 #define test_cpu_cap(c, bit)						\
-	 test_bit(bit, (unsigned long *)((c)->x86_capability))
+	 (IS_EXT_BUGBIT(bit) ? test_bit((bit) - ((NCAPINTS+NBUGINTS)*32), \
+				(unsigned long *)((c)->x86_ext_capability)) : \
+				test_bit(bit, (unsigned long *)((c)->x86_capability)))
 
 /*
  * There are 32 bits/features in each mask word.  The high bits
@@ -143,14 +147,25 @@ extern const char * const x86_bug_flags[
 
 #define boot_cpu_has(bit)	cpu_has(&boot_cpu_data, bit)
 
-#define set_cpu_cap(c, bit)	set_bit(bit, (unsigned long *)((c)->x86_capability))
+#define set_cpu_cap(c, bit)  do {						  \
+	if (IS_EXT_BUGBIT(bit))							  \
+		set_bit(bit - ((NCAPINTS+NBUGINTS))*32,				  \
+			(unsigned long *)((c)->x86_ext_capability)); \
+	else									  \
+		set_bit(bit, (unsigned long *)((c)->x86_capability));		  \
+} while (0)
+
 
 extern void setup_clear_cpu_cap(unsigned int bit);
 extern void clear_cpu_cap(struct cpuinfo_x86 *c, unsigned int bit);
 
 #define setup_force_cpu_cap(bit) do { \
 	set_cpu_cap(&boot_cpu_data, bit);	\
-	set_bit(bit, (unsigned long *)cpu_caps_set);	\
+	if (IS_EXT_BUGBIT(bit))    \
+		set_bit(bit - ((NCAPINTS+NBUGINTS))*32,				  \
+			(unsigned long *)&cpu_caps_set[NCAPINTS+NBUGINTS]);	  \
+	else \
+		set_bit(bit, (unsigned long *)cpu_caps_set);	\
 } while (0)
 
 #define setup_force_cpu_bug(bit) setup_force_cpu_cap(bit)
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@ -15,7 +15,7 @@
  */
 #define NCAPINTS			22	   /* N 32-bit words worth of info */
 #define NBUGINTS			1	   /* N 32-bit bug flags */
-
+#define NEXTBUGINTS			1	   /* N 32-bit extended bug flags */
 /*
  * Note: If the comment begins with a quoted string, that string is used
  * in /proc/cpuinfo instead of the macro name.  If the string is "",
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -140,6 +140,9 @@ struct cpuinfo_x86 {
 	/* Address space bits used by the cache internally */
 	u8			x86_cache_bits;
 	unsigned		initialized : 1;
+#ifndef __GENKSYMS__
+	__u32		x86_ext_capability[NEXTBUGINTS];
+#endif
 } __randomize_layout;
 
 struct cpuid_regs {
@@ -173,7 +176,7 @@ extern struct cpuinfo_x86	boot_cpu_data;
 extern struct cpuinfo_x86	new_cpu_data;
 
 extern __u32			cpu_caps_cleared[NCAPINTS + NBUGINTS];
-extern __u32			cpu_caps_set[NCAPINTS + NBUGINTS];
+extern __u32			cpu_caps_set[NCAPINTS + NBUGINTS + NEXTBUGINTS];
 
 #ifdef CONFIG_SMP
 DECLARE_PER_CPU_READ_MOSTLY(struct cpuinfo_x86, cpu_info);
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -367,7 +367,7 @@ void __init_or_module noinline apply_alt
 		instr = (u8 *)&a->instr_offset + a->instr_offset;
 		replacement = (u8 *)&a->repl_offset + a->repl_offset;
 		BUG_ON(a->instrlen > sizeof(insn_buff));
-		BUG_ON(feature >= (NCAPINTS + NBUGINTS) * 32);
+		BUG_ON(feature >= (NCAPINTS + NBUGINTS + NEXTBUGINTS) * 32);
 
 		/*
 		 * Patch if either:
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -601,7 +601,7 @@ static const char *table_lookup_model(st
 
 /* Aligned to unsigned long to avoid split lock in atomic bitmap ops */
 __u32 cpu_caps_cleared[NCAPINTS + NBUGINTS] __aligned(sizeof(unsigned long));
-__u32 cpu_caps_set[NCAPINTS + NBUGINTS] __aligned(sizeof(unsigned long));
+__u32 cpu_caps_set[NCAPINTS + NBUGINTS + NEXTBUGINTS] __aligned(sizeof(unsigned long));
 
 void load_percpu_segment(int cpu)
 {
@@ -863,6 +863,11 @@ static void apply_forced_caps(struct cpu
 		c->x86_capability[i] &= ~cpu_caps_cleared[i];
 		c->x86_capability[i] |= cpu_caps_set[i];
 	}
+
+	for (i = 0; i < NEXTBUGINTS; i++) {
+		c->x86_ext_capability[i] |= cpu_caps_set[NCAPINTS+NBUGINTS + i];
+	}
+
 }
 
 static void init_speculation_control(struct cpuinfo_x86 *c)
--- a/arch/x86/kernel/cpu/mkcapflags.sh
+++ b/arch/x86/kernel/cpu/mkcapflags.sh
@@ -60,7 +60,7 @@ trap 'rm "$OUT"' EXIT
 	dump_array "x86_cap_flags" "NCAPINTS*32" "X86_FEATURE_" "" $2
 	echo ""
 
-	dump_array "x86_bug_flags" "NBUGINTS*32" "X86_BUG_" "NCAPINTS*32" $2
+	dump_array "x86_bug_flags" "(NBUGINTS+NEXTBUGINTS)*32" "X86_BUG_" "NCAPINTS*32" $2
 	echo ""
 
 	echo "#ifdef CONFIG_X86_VMX_FEATURE_NAMES"
--- a/arch/x86/kernel/cpu/proc.c
+++ b/arch/x86/kernel/cpu/proc.c
@@ -118,7 +118,7 @@ static int show_cpuinfo(struct seq_file
 #endif
 
 	seq_puts(m, "\nbugs\t\t:");
-	for (i = 0; i < 32*NBUGINTS; i++) {
+	for (i = 0; i < 32*(NBUGINTS+NEXTBUGINTS); i++) {
 		unsigned int bug_bit = 32*NCAPINTS + i;
 
 		if (cpu_has_bug(c, bug_bit) && x86_bug_flags[i])

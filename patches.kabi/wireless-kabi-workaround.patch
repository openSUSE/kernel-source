From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for wireless updates
Patch-mainline: Never, kABI workaround
References: bsc#1227149

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/linux/ieee80211.h    |    2 
 include/linux/mhi.h          |    7 ++
 include/net/cfg80211.h       |  106 ++++++++++++++++++++++++++++++++++---------
 include/net/mac80211.h       |   75 +++++++++++++++++++++++++-----
 include/net/regulatory.h     |    2 
 include/uapi/linux/nl80211.h |   18 +++++++
 net/mac80211/Kconfig         |    2 
 net/mac80211/ieee80211_i.h   |    2 
 net/mac80211/iface.c         |   18 ++++++-
 net/mac80211/key.c           |   11 ++++
 net/mac80211/mlme.c          |   25 +++++++---
 net/mac80211/status.c        |    7 ++
 net/mac80211/tx.c            |    8 +++
 net/wireless/core.c          |    1 
 net/wireless/core.h          |    6 ++
 net/wireless/mlme.c          |   13 ++++-
 net/wireless/scan.c          |   13 +++++
 net/wireless/util.c          |    9 +++
 18 files changed, 276 insertions(+), 49 deletions(-)

--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -1371,6 +1371,7 @@ struct ieee80211_mgmt {
 					u8 max_tod_error;
 					u8 max_toa_error;
 				} __packed wnm_timing_msr;
+#ifndef __GENKSYMS__
 				struct {
 					u8 action_code;
 					u8 dialog_token;
@@ -1385,6 +1386,7 @@ struct ieee80211_mgmt {
 				struct {
 					u8 action_code;
 				} __packed ttlm_tear_down;
+#endif
 			} u;
 		} __packed action;
 		DECLARE_FLEX_ARRAY(u8, body); /* Generic frame body */
--- a/include/linux/mhi.h
+++ b/include/linux/mhi.h
@@ -388,8 +388,6 @@ struct mhi_controller {
 	dma_addr_t iova_start;
 	dma_addr_t iova_stop;
 	const char *fw_image;
-	const u8 *fw_data;
-	size_t fw_sz;
 	const char *edl_image;
 	size_t rddm_size;
 	size_t sbl_size;
@@ -458,6 +456,11 @@ struct mhi_controller {
 	bool wake_set;
 	unsigned long irq_flags;
 	u32 mru;
+
+#ifndef __GENKSYMS__
+	const u8 *fw_data;
+	size_t fw_sz;
+#endif
 };
 
 /**
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -198,7 +198,9 @@ struct ieee80211_channel {
 	enum nl80211_dfs_state dfs_state;
 	unsigned long dfs_state_entered;
 	unsigned int dfs_cac_ms;
+#ifndef __GENKSYMS__
 	s8 psd;
+#endif
 };
 
 /**
@@ -1391,9 +1393,13 @@ struct cfg80211_acl_data {
  *	frame headers.
  */
 struct cfg80211_fils_discovery {
-	bool update;
 	u32 min_interval;
+#ifdef __GENKSYMS__
 	u32 max_interval;
+#else
+	u32 max_interval:31;
+	u32 update:1;
+#endif
 	size_t tmpl_len;
 	const u8 *tmpl;
 };
@@ -1410,8 +1416,12 @@ struct cfg80211_fils_discovery {
  * @tmpl: Template data for probe response
  */
 struct cfg80211_unsol_bcast_probe_resp {
-	bool update;
+#ifdef __GENKSYMS__
 	u32 interval;
+#else
+	u32 interval:31;
+	u32 update:1;
+#endif
 	size_t tmpl_len;
 	const u8 *tmpl;
 };
@@ -2647,6 +2657,7 @@ struct cfg80211_scan_request {
 	struct cfg80211_ssid *ssids;
 	int n_ssids;
 	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	const u8 *ie;
 	size_t ie_len;
 	u16 duration;
@@ -2668,9 +2679,11 @@ struct cfg80211_scan_request {
 	bool notified;
 	bool no_cck;
 	bool scan_6ghz;
+#ifndef __GENKSYMS__
+	s8 tsf_report_link_id;
+#endif
 	u32 n_6ghz_params;
 	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
-	s8 tsf_report_link_id;
 
 	/* keep last */
 	struct ieee80211_channel *channels[];
@@ -2789,6 +2802,7 @@ struct cfg80211_sched_scan_request {
 	struct cfg80211_ssid *ssids;
 	int n_ssids;
 	u32 n_channels;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	const u8 *ie;
 	size_t ie_len;
 	u32 flags;
@@ -2862,6 +2876,7 @@ enum cfg80211_signal_type {
  */
 struct cfg80211_inform_bss {
 	struct ieee80211_channel *chan;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 	s32 signal;
 	u64 boottime_ns;
 	u64 parent_tsf;
@@ -2869,8 +2884,10 @@ struct cfg80211_inform_bss {
 	u8 chains;
 	s8 chain_signal[IEEE80211_MAX_CHAINS];
 
+#ifndef __GENKSYMS__
 	u8 restrict_use:1, use_for:7;
 	u8 cannot_use_reasons;
+#endif
 
 	void *drv_data;
 };
@@ -2934,6 +2951,7 @@ struct cfg80211_bss_ies {
  */
 struct cfg80211_bss {
 	struct ieee80211_channel *channel;
+	enum nl80211_bss_scan_width scan_width; // FIXME: kABI placeholder
 
 	const struct cfg80211_bss_ies __rcu *ies;
 	const struct cfg80211_bss_ies __rcu *beacon_ies;
@@ -2952,13 +2970,14 @@ struct cfg80211_bss {
 	u8 chains;
 	s8 chain_signal[IEEE80211_MAX_CHAINS];
 
-	u8 proberesp_ecsa_stuck:1;
-
 	u8 bssid_index;
 	u8 max_bssid_indicator;
 
+#ifndef __GENKSYMS__
+	u8 proberesp_ecsa_stuck:1;
 	u8 use_for;
 	u8 cannot_use_reasons;
+#endif
 
 	u8 priv[] __aligned(sizeof(void *));
 };
@@ -3045,7 +3064,9 @@ struct cfg80211_assoc_link {
 	const u8 *elems;
 	size_t elems_len;
 	bool disabled;
+#ifndef __GENKSYMS__
 	int error;
+#endif
 };
 
 /**
@@ -3605,8 +3626,10 @@ struct cfg80211_wowlan_wakeup {
 	bool disconnect, magic_pkt, gtk_rekey_failure,
 	     eap_identity_req, four_way_handshake,
 	     rfkill_release, packet_80211,
-	     tcp_match, tcp_connlost, tcp_nomoretokens,
-	     unprot_deauth_disassoc;
+	     tcp_match, tcp_connlost, tcp_nomoretokens;
+#ifndef __GENKSYMS__
+	bool unprot_deauth_disassoc;
+#endif
 	s32 pattern_idx;
 	u32 packet_present_len, packet_len;
 	const void *packet;
@@ -4604,8 +4627,13 @@ struct cfg80211_ops {
 
 	int	(*start_ap)(struct wiphy *wiphy, struct net_device *dev,
 			    struct cfg80211_ap_settings *settings);
+#ifdef __GENKSYMS__
+	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
+				 struct cfg80211_beacon_data *info);
+#else
 	int	(*change_beacon)(struct wiphy *wiphy, struct net_device *dev,
 				 struct cfg80211_ap_update *info);
+#endif
 	int	(*stop_ap)(struct wiphy *wiphy, struct net_device *dev,
 			   unsigned int link_id);
 
@@ -4915,8 +4943,10 @@ struct cfg80211_ops {
 				    struct link_station_del_parameters *params);
 	int	(*set_hw_timestamp)(struct wiphy *wiphy, struct net_device *dev,
 				    struct cfg80211_set_hw_timestamp *hwts);
+#ifndef __GENKSYMS__
 	int	(*set_ttlm)(struct wiphy *wiphy, struct net_device *dev,
 			    struct cfg80211_ttlm_params *params);
+#endif
 };
 
 /*
@@ -6145,6 +6175,8 @@ struct wireless_dev {
 	struct list_head mgmt_registrations;
 	u8 mgmt_registrations_need_update:1;
 
+	struct mutex mtx; // FIXME: kABI placeholder
+
 	bool use_4addr, is_running, registered, registering;
 
 	u8 address[ETH_ALEN] __aligned(sizeof(u16));
@@ -6439,7 +6471,9 @@ ieee80211_get_response_rate(struct ieee8
  * This function returns a bitmap of the mandatory rates for the given
  * band, bits are set according to the rate position in the bitrates array.
  */
-u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband);
+u32 _ieee80211_mandatory_rates(struct ieee80211_supported_band *sband);
+// FIXME: rename for kABI workaround
+#define ieee80211_mandatory_rates _ieee80211_mandatory_rates
 
 /*
  * Radiotap parsing functions -- for controlled injection support
@@ -7275,16 +7309,12 @@ struct cfg80211_bss *__cfg80211_get_bss(
  *
  * This version implies regular usage, %NL80211_BSS_USE_FOR_NORMAL.
  */
-static inline struct cfg80211_bss *
-cfg80211_get_bss(struct wiphy *wiphy, struct ieee80211_channel *channel,
-		 const u8 *bssid, const u8 *ssid, size_t ssid_len,
-		 enum ieee80211_bss_type bss_type,
-		 enum ieee80211_privacy privacy)
-{
-	return __cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len,
-				  bss_type, privacy,
-				  NL80211_BSS_USE_FOR_NORMAL);
-}
+struct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,
+				      struct ieee80211_channel *channel,
+				      const u8 *bssid,
+				      const u8 *ssid, size_t ssid_len,
+				      enum ieee80211_bss_type bss_type,
+				      enum ieee80211_privacy privacy);
 
 static inline struct cfg80211_bss *
 cfg80211_get_ibss(struct wiphy *wiphy,
@@ -7393,7 +7423,7 @@ void cfg80211_auth_timeout(struct net_de
  * @links.status: Set this (along with a BSS pointer) for links that
  *	were rejected by the AP.
  */
-struct cfg80211_rx_assoc_resp_data {
+struct cfg80211_rx_assoc_resp {
 	const u8 *buf;
 	size_t len;
 	const u8 *req_ies;
@@ -7407,6 +7437,9 @@ struct cfg80211_rx_assoc_resp_data {
 	} links[IEEE80211_MLD_MAX_NUM_LINKS];
 };
 
+// FIXME: rename for kABI workaround
+#define cfg80211_rx_assoc_resp_data cfg80211_rx_assoc_resp
+
 /**
  * cfg80211_rx_assoc_resp - notification of processed association response
  * @dev: network device
@@ -7417,8 +7450,10 @@ struct cfg80211_rx_assoc_resp_data {
  *
  * This function may sleep. The caller must hold the corresponding wdev's mutex.
  */
-void cfg80211_rx_assoc_resp(struct net_device *dev,
-			    const struct cfg80211_rx_assoc_resp_data *data);
+void _cfg80211_rx_assoc_resp(struct net_device *dev,
+			     const struct cfg80211_rx_assoc_resp_data *data);
+// FIXME: rename for kABI workaround
+#define cfg80211_rx_assoc_resp(dev, data) _cfg80211_rx_assoc_resp(dev, data)
 
 /**
  * struct cfg80211_assoc_failure - association failure data
@@ -9450,6 +9485,35 @@ ssize_t wiphy_locked_debugfs_write(struc
 						      size_t count,
 						      void *data),
 				   void *data);
+#else
+static inline ssize_t
+wiphy_locked_debugfs_read(struct wiphy *wiphy, struct file *file,
+			  char *buf, size_t bufsize,
+			  char __user *userbuf, size_t count,
+			  loff_t *ppos,
+			  ssize_t (*handler)(struct wiphy *wiphy,
+					     struct file *file,
+					     char *buf,
+					     size_t bufsize,
+					     void *data),
+			  void *data)
+{
+	return -ENOENT;
+}
+
+static inline ssize_t
+wiphy_locked_debugfs_write(struct wiphy *wiphy, struct file *file,
+			   char *buf, size_t bufsize,
+			   const char __user *userbuf, size_t count,
+			   ssize_t (*handler)(struct wiphy *wiphy,
+					      struct file *file,
+					      char *buf,
+					      size_t count,
+					      void *data),
+			   void *data)
+{
+	return -ENOENT;
+}
 #endif
 
 #endif /* __NET_CFG80211_H */
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1157,12 +1157,21 @@ ieee80211_rate_get_vht_nss(const struct
 struct ieee80211_tx_info {
 	/* common information */
 	u32 flags;
+
+#ifdef __GENKSYMS__
 	u32 band:3,
-	    status_data_idr:1,
-	    status_data:13,
+	    ack_frame_id:13,
 	    hw_queue:4,
 	    tx_time_est:10;
+	/* 2 free bits */
+#else
+	u32 band:3,
+	    status_data:13,
+	    hw_queue:4,
+	    tx_time_est:10,
+	    status_data_idr:1;
 	/* 1 free bit */
+#endif
 
 	union {
 		struct {
@@ -1177,8 +1186,10 @@ struct ieee80211_tx_info {
 					u8 short_preamble:1;
 					u8 skip_table:1;
 
+#ifndef __GENKSYMS__
 					/* for injection only (bitmap) */
 					u8 antennas:2;
+#endif
 
 					/* 14 bits free */
 				};
@@ -1939,13 +1950,17 @@ struct ieee80211_vif {
 	struct ieee80211_vif_cfg cfg;
 	struct ieee80211_bss_conf bss_conf;
 	struct ieee80211_bss_conf __rcu *link_conf[IEEE80211_MLD_MAX_NUM_LINKS];
-	u16 valid_links, active_links, dormant_links, suspended_links;
-	struct ieee80211_neg_ttlm neg_ttlm;
+	u16 valid_links, active_links, dormant_links;
+	// FIXME: neg_ttlm is moved out to ieee80211_ext_vif for kABI reason
 	u8 addr[ETH_ALEN] __aligned(2);
 	bool p2p;
 
 	u8 cab_queue;
 	u8 hw_queue[IEEE80211_NUM_ACS];
+#ifndef __GENKSYMS__
+	u16 suspended_links;
+	u16 vif_ext_ofs;	// offset of ieee80211_ext_vif
+#endif
 
 	struct ieee80211_txq *txq;
 
@@ -1966,6 +1981,14 @@ struct ieee80211_vif {
 	u8 drv_priv[] __aligned(sizeof(void *));
 };
 
+// FIXME: an extended struct for kABI compatibility
+struct ieee80211_ext_vif_data {
+	struct ieee80211_neg_ttlm neg_ttlm;
+};
+
+#define ieee80211_vif_neg_ttlm(v) \
+	((struct ieee80211_ext_vif_data *)((char *)(v) + (v)->vif_ext_ofs))->neg_ttlm
+
 /**
  * ieee80211_vif_usable_links - Return the usable links for the vif
  * @vif: the vif for which the usable links are requested
@@ -2409,8 +2432,10 @@ struct ieee80211_sta {
 	bool tdls_initiator;
 	bool mfp;
 	bool mlo;
-	bool spp_amsdu;
 	u8 max_amsdu_subframes;
+#ifndef __GENKSYMS__
+	bool spp_amsdu;
+#endif
 
 	struct ieee80211_sta_aggregates *cur;
 
@@ -2794,7 +2819,9 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,
 	IEEE80211_HW_DETECTS_COLOR_COLLISION,
 	IEEE80211_HW_MLO_MCAST_MULTI_LINK_TX,
+#ifndef __GENKSYMS__
 	IEEE80211_HW_DISALLOW_PUNCTURING,
+#endif
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
@@ -3698,7 +3725,9 @@ struct ieee80211_prep_tx_info {
 	u16 duration;
 	u16 subtype;
 	u8 success:1;
+#ifndef __GENKSYMS__
 	int link_id;
+#endif
 };
 
 /**
@@ -4431,8 +4460,6 @@ struct ieee80211_ops {
 	int (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			  struct ieee80211_sta *sta);
 #ifdef CONFIG_MAC80211_DEBUGFS
-	void (*vif_add_debugfs)(struct ieee80211_hw *hw,
-				struct ieee80211_vif *vif);
 	void (*link_add_debugfs)(struct ieee80211_hw *hw,
 				 struct ieee80211_vif *vif,
 				 struct ieee80211_bss_conf *link_conf,
@@ -4580,9 +4607,14 @@ struct ieee80211_ops {
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_prep_tx_info *info);
 
+#ifdef __GENKSYMS__
+	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
+					     struct ieee80211_vif *vif);
+#else
 	void	(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,
 					     struct ieee80211_vif *vif,
 					     unsigned int link_id);
+#endif
 
 	int (*add_chanctx)(struct ieee80211_hw *hw,
 			   struct ieee80211_chanctx_conf *ctx);
@@ -4619,9 +4651,14 @@ struct ieee80211_ops {
 				  struct ieee80211_vif *vif,
 				  struct ieee80211_channel_switch *ch_switch);
 
+#ifdef __GENKSYMS__
+	int (*post_channel_switch)(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif);
+#else
 	int (*post_channel_switch)(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_bss_conf *link_conf);
+#endif
 	void (*abort_channel_switch)(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif);
 	void (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,
@@ -4703,9 +4740,6 @@ struct ieee80211_ops {
 				     struct ieee80211_sta *sta,
 				     struct net_device_path_ctx *ctx,
 				     struct net_device_path *path);
-	bool (*can_activate_links)(struct ieee80211_hw *hw,
-				   struct ieee80211_vif *vif,
-				   u16 active_links);
 	int (*change_vif_links)(struct ieee80211_hw *hw,
 				struct ieee80211_vif *vif,
 				u16 old_links, u16 new_links,
@@ -4722,9 +4756,18 @@ struct ieee80211_ops {
 			    struct net_device *dev,
 			    enum tc_setup_type type,
 			    void *type_data);
+#ifndef __GENKSYMS__
+	bool (*can_activate_links)(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   u16 active_links);
+#ifdef CONFIG_MAC80211_DEBUGFS
+	void (*vif_add_debugfs)(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif);
+#endif
 	enum ieee80211_neg_ttlm_res
 	(*can_neg_ttlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			struct ieee80211_neg_ttlm *ttlm);
+#endif
 };
 
 /**
@@ -5517,8 +5560,10 @@ static inline struct sk_buff *ieee80211_
  *
  * Return: new countdown value
  */
-u8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif,
+u8 _ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif,
 				  unsigned int link_id);
+// FIXME: rename for kABI compatibility
+#define ieee80211_beacon_update_cntdwn _ieee80211_beacon_update_cntdwn
 
 /**
  * ieee80211_beacon_set_cntdwn - request mac80211 to set beacon countdown
@@ -5912,9 +5957,11 @@ void ieee80211_remove_key(struct ieee802
  * the key that's being replaced.
  */
 struct ieee80211_key_conf *
-ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+_ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
 			struct ieee80211_key_conf *keyconf,
 			int link_id);
+// FIXME: rename for kABI compatibility
+#define ieee80211_gtk_rekey_add _ieee80211_gtk_rekey_add
 
 /**
  * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying
@@ -6634,8 +6681,10 @@ void ieee80211_radar_detected(struct iee
  * Complete the channel switch post-process: set the new operational channel
  * and wake up the suspended queues.
  */
-void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success,
+void _ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success,
 			     unsigned int link_id);
+// FIXME: rename for kABI workaround
+#define ieee80211_chswitch_done _ieee80211_chswitch_done
 
 /**
  * ieee80211_channel_switch_disconnect - disconnect due to channel switch error
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -213,7 +213,9 @@ struct ieee80211_reg_rule {
 	u32 flags;
 	u32 dfs_cac_ms;
 	bool has_wmm;
+#ifndef __GENKSYMS__
 	s8 psd;
+#endif
 };
 
 struct ieee80211_regdomain {
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -1584,7 +1584,9 @@ enum nl80211_commands {
 
 	NL80211_CMD_LINKS_REMOVED,
 
+#ifndef __GENKSYMS__
 	NL80211_CMD_SET_TID_TO_LINK_MAPPING,
+#endif
 
 	/* add new commands above here */
 
@@ -3389,12 +3391,14 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_MLO_LINK_DISABLED,
 
+#ifndef __GENKSYMS__
 	NL80211_ATTR_BSS_DUMP_INCLUDE_USE_DATA,
 
 	NL80211_ATTR_MLO_TTLM_DLINK,
 	NL80211_ATTR_MLO_TTLM_ULINK,
 
 	NL80211_ATTR_ASSOC_SPP_AMSDU,
+#endif
 
 	/* add attributes here, update the policy in nl80211.c */
 
@@ -3549,7 +3553,9 @@ enum nl80211_sta_flags {
 	NL80211_STA_FLAG_AUTHENTICATED,
 	NL80211_STA_FLAG_TDLS_PEER,
 	NL80211_STA_FLAG_ASSOCIATED,
+#ifndef __GENKSYMS__
 	NL80211_STA_FLAG_SPP_AMSDU,
+#endif
 
 	/* keep last */
 	__NL80211_STA_FLAG_AFTER_LAST,
@@ -4306,10 +4312,12 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_16MHZ,
 	NL80211_FREQUENCY_ATTR_NO_320MHZ,
 	NL80211_FREQUENCY_ATTR_NO_EHT,
+#ifndef __GENKSYMS__
 	NL80211_FREQUENCY_ATTR_PSD,
 	NL80211_FREQUENCY_ATTR_DFS_CONCURRENT,
 	NL80211_FREQUENCY_ATTR_NO_6GHZ_VLP_CLIENT,
 	NL80211_FREQUENCY_ATTR_NO_6GHZ_AFC_CLIENT,
+#endif
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -4433,7 +4441,9 @@ enum nl80211_reg_rule_attr {
 
 	NL80211_ATTR_DFS_CAC_TIME,
 
+#ifndef __GENKSYMS__
 	NL80211_ATTR_POWER_RULE_PSD,
+#endif
 
 	/* keep last */
 	__NL80211_REG_RULE_ATTR_AFTER_LAST,
@@ -4545,10 +4555,12 @@ enum nl80211_reg_rule_flags {
 	NL80211_RRF_NO_HE		= 1<<17,
 	NL80211_RRF_NO_320MHZ		= 1<<18,
 	NL80211_RRF_NO_EHT		= 1<<19,
+#ifndef __GENKSYMS__
 	NL80211_RRF_PSD			= 1<<20,
 	NL80211_RRF_DFS_CONCURRENT	= 1<<21,
 	NL80211_RRF_NO_6GHZ_VLP_CLIENT	= 1<<22,
 	NL80211_RRF_NO_6GHZ_AFC_CLIENT	= 1<<23,
+#endif
 };
 
 #define NL80211_RRF_PASSIVE_SCAN	NL80211_RRF_NO_IR
@@ -5204,8 +5216,10 @@ enum nl80211_bss {
 	NL80211_BSS_FREQUENCY_OFFSET,
 	NL80211_BSS_MLO_LINK_ID,
 	NL80211_BSS_MLD_ADDR,
+#ifndef __GENKSYMS__
 	NL80211_BSS_USE_FOR,
 	NL80211_BSS_CANNOT_USE_REASONS,
+#endif
 
 	/* keep last */
 	__NL80211_BSS_AFTER_LAST,
@@ -5784,7 +5798,9 @@ enum nl80211_wowlan_triggers {
 	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS,
 	NL80211_WOWLAN_TRIG_NET_DETECT,
 	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS,
+#ifndef __GENKSYMS__
 	NL80211_WOWLAN_TRIG_UNPROTECTED_DEAUTH_DISASSOC,
+#endif
 
 	/* keep last */
 	NUM_NL80211_WOWLAN_TRIG,
@@ -6612,10 +6628,12 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_PUNCT,
 	NL80211_EXT_FEATURE_SECURE_NAN,
 	NL80211_EXT_FEATURE_AUTH_AND_DEAUTH_RANDOM_TA,
+#ifndef __GENKSYMS__
 	NL80211_EXT_FEATURE_OWE_OFFLOAD,
 	NL80211_EXT_FEATURE_OWE_OFFLOAD_AP,
 	NL80211_EXT_FEATURE_DFS_CONCURRENT,
 	NL80211_EXT_FEATURE_SPP_AMSDU_SUPPORT,
+#endif
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -77,7 +77,7 @@ config MAC80211_LEDS
 
 config MAC80211_DEBUGFS
 	bool "Export mac80211 internals in DebugFS"
-	depends on MAC80211 && CFG80211_DEBUGFS
+	depends on MAC80211 && DEBUG_FS
 	help
 	  Select this to see extensive information about
 	  the internal state of mac80211 in debugfs.
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1148,6 +1148,8 @@ struct ieee80211_sub_if_data {
 	} debugfs;
 #endif
 
+	struct ieee80211_ext_vif_data _ext_data; // FIXME: extended data for kABI
+
 	/* must be last, dynamically sized area in this! */
 	struct ieee80211_vif vif;
 };
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1128,15 +1128,20 @@ int ieee80211_add_virtual_monitor(struct
 	if (local->monitor_sdata)
 		return 0;
 
-	sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size, GFP_KERNEL);
+	// FIXME: extra size for kABI workaround
+	sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size +
+			sizeof(struct ieee80211_ext_vif_data), GFP_KERNEL);
 	if (!sdata)
 		return -ENOMEM;
 
 	/* set up data */
 	sdata->vif.type = NL80211_IFTYPE_MONITOR;
+	// FIXME: extra field for kABI
+	sdata->vif.vif_ext_ofs = sizeof(*sdata) + local->hw.vif_data_size;
 	snprintf(sdata->name, IFNAMSIZ, "%s-monitor",
 		 wiphy_name(local->hw.wiphy));
 	sdata->wdev.iftype = NL80211_IFTYPE_MONITOR;
+	mutex_init(&sdata->wdev.mtx); // FIXME: re-added for kABI compatibility
 	sdata->wdev.wiphy = local->hw.wiphy;
 
 	ieee80211_sdata_init(local, sdata);
@@ -2060,19 +2065,24 @@ int ieee80211_if_add(struct ieee80211_lo
 	if (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {
 		struct wireless_dev *wdev;
 
-		sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,
+		// FIXME: extra size for kABI workaround
+		sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size +
+				sizeof(struct ieee80211_ext_vif_data),
 				GFP_KERNEL);
 		if (!sdata)
 			return -ENOMEM;
 		wdev = &sdata->wdev;
 
+		// FIXME: extra field for kABI
+		sdata->vif.vif_ext_ofs = sizeof(*sdata) + local->hw.vif_data_size;
 		sdata->dev = NULL;
 		strscpy(sdata->name, name, IFNAMSIZ);
 		ieee80211_assign_perm_addr(local, wdev->address, type);
 		memcpy(sdata->vif.addr, wdev->address, ETH_ALEN);
 		ether_addr_copy(sdata->vif.bss_conf.addr, sdata->vif.addr);
 	} else {
-		int size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,
+		int size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size +
+				 sizeof(struct ieee80211_ext_vif_data),
 				 sizeof(void *));
 		int txq_size = 0;
 
@@ -2121,6 +2131,8 @@ int ieee80211_if_add(struct ieee80211_lo
 
 		/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */
 		sdata = netdev_priv(ndev);
+		// FIXME: extra field for kABI
+		sdata->vif.vif_ext_ofs = sizeof(*sdata) + local->hw.vif_data_size;
 		ndev->ieee80211_ptr = &sdata->wdev;
 		memcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);
 		ether_addr_copy(sdata->vif.bss_conf.addr, sdata->vif.addr);
--- a/net/mac80211/key.c
+++ b/net/mac80211/key.c
@@ -1493,3 +1493,14 @@ int ieee80211_key_switch_links(struct ie
 
 	return 0;
 }
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_gtk_rekey_add
+struct ieee80211_key_conf *
+ieee80211_gtk_rekey_add(struct ieee80211_vif *vif,
+			struct ieee80211_key_conf *keyconf)
+{
+	return _ieee80211_gtk_rekey_add(vif, keyconf, 0);
+}
+EXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_add);
+
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -3088,7 +3088,8 @@ static void ieee80211_set_disassoc(struc
 	       sizeof(sdata->u.mgd.ttlm_info));
 	wiphy_delayed_work_cancel(sdata->local->hw.wiphy, &ifmgd->ttlm_work);
 
-	memset(&sdata->vif.neg_ttlm, 0, sizeof(sdata->vif.neg_ttlm));
+	memset(&ieee80211_vif_neg_ttlm(&sdata->vif), 0,
+	       sizeof(ieee80211_vif_neg_ttlm(&sdata->vif)));
 
 	sdata->u.mgd.removed_links = 0;
 	wiphy_delayed_work_cancel(sdata->local->hw.wiphy,
@@ -5911,8 +5912,10 @@ static int ieee80211_ttlm_set_links(stru
 	/* If there is an active negotiated TTLM, it should be discarded by
 	 * the new negotiated/advertised TTLM.
 	 */
-	if (sdata->vif.neg_ttlm.valid) {
-		memset(&sdata->vif.neg_ttlm, 0, sizeof(sdata->vif.neg_ttlm));
+	if (sdata->vif.vif_ext_ofs &&
+	    ieee80211_vif_neg_ttlm(&sdata->vif).valid) {
+		memset(&ieee80211_vif_neg_ttlm(&sdata->vif), 0,
+		       sizeof(ieee80211_vif_neg_ttlm(&sdata->vif)));
 		sdata->vif.suspended_links = 0;
 		changed = BSS_CHANGED_MLD_TTLM;
 	}
@@ -6501,7 +6504,7 @@ static void ieee80211_apply_neg_ttlm(str
 		map |= neg_ttlm.downlink[i] | neg_ttlm.uplink[i];
 
 	/* If there is an active TTLM, unset previously suspended links */
-	if (sdata->vif.neg_ttlm.valid)
+	if (sdata->vif.vif_ext_ofs && ieee80211_vif_neg_ttlm(&sdata->vif).valid)
 		sdata->vif.dormant_links &= ~sdata->vif.suspended_links;
 
 	/* exclude links that are already disabled by advertised TTLM */
@@ -6514,8 +6517,10 @@ static void ieee80211_apply_neg_ttlm(str
 				     new_dormant_links, new_suspended_links))
 		return;
 
-	sdata->vif.neg_ttlm = neg_ttlm;
-	sdata->vif.neg_ttlm.valid = true;
+	if (sdata->vif.vif_ext_ofs) {
+		ieee80211_vif_neg_ttlm(&sdata->vif) = neg_ttlm;
+		ieee80211_vif_neg_ttlm(&sdata->vif).valid = true;
+	}
 }
 
 static void
@@ -8607,3 +8612,11 @@ void ieee80211_disable_rssi_reports(stru
 	_ieee80211_enable_rssi_reports(sdata, 0, 0);
 }
 EXPORT_SYMBOL(ieee80211_disable_rssi_reports);
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_chswitch_done
+void ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)
+{
+	_ieee80211_chswitch_done(vif, success, 0);
+}
+EXPORT_SYMBOL(ieee80211_chswitch_done);
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -1113,6 +1113,13 @@ void ieee80211_tx_status_skb(struct ieee
 }
 EXPORT_SYMBOL(ieee80211_tx_status_skb);
 
+// FIXME: for kABI compatibility
+void ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	ieee80211_tx_status_skb(hw, skb);
+}
+EXPORT_SYMBOL(ieee80211_tx_status);
+
 void ieee80211_tx_status_ext(struct ieee80211_hw *hw,
 			     struct ieee80211_tx_status *status)
 {
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -6258,3 +6258,11 @@ int ieee80211_probe_mesh_link(struct wip
 
 	return 0;
 }
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_beacon_update_cntdwn
+u8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif)
+{
+	return _ieee80211_beacon_update_cntdwn(vif, 0);
+}
+EXPORT_SYMBOL(ieee80211_beacon_update_cntdwn);
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1359,6 +1359,7 @@ EXPORT_SYMBOL(cfg80211_stop_iface);
 
 void cfg80211_init_wdev(struct wireless_dev *wdev)
 {
+	mutex_init(&wdev->mtx);
 	INIT_LIST_HEAD(&wdev->event_list);
 	spin_lock_init(&wdev->event_lock);
 	INIT_LIST_HEAD(&wdev->mgmt_registrations);
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -293,8 +293,12 @@ struct cfg80211_cqm_config {
 	u32 rssi_hyst;
 	s32 last_rssi_event_value;
 	enum nl80211_cqm_rssi_threshold_event last_rssi_event_type;
-	bool use_range_api;
+#ifdef __GENKSYMS__
 	int n_rssi_thresholds;
+#else
+	u32 n_rssi_thresholds:31;
+	u32 use_range_api:1;
+#endif
 	s32 rssi_thresholds[];
 };
 
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -21,7 +21,7 @@
 #include "rdev-ops.h"
 
 
-void cfg80211_rx_assoc_resp(struct net_device *dev,
+void _cfg80211_rx_assoc_resp(struct net_device *dev,
 			    const struct cfg80211_rx_assoc_resp_data *data)
 {
 	struct wireless_dev *wdev = dev->ieee80211_ptr;
@@ -95,7 +95,7 @@ void cfg80211_rx_assoc_resp(struct net_d
 	/* update current_bss etc., consumes the bss reference */
 	__cfg80211_connect_result(dev, &cr, cr.status == WLAN_STATUS_SUCCESS);
 }
-EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
+EXPORT_SYMBOL(_cfg80211_rx_assoc_resp);
 
 static void cfg80211_process_auth(struct wireless_dev *wdev,
 				  const u8 *buf, size_t len)
@@ -1183,3 +1183,12 @@ void cfg80211_stop_background_radar_dete
 					&rdev->background_radar_chandef,
 					NL80211_RADAR_CAC_ABORTED);
 }
+
+/* FIXME: kABI compatibility */
+#undef cfg80211_rx_assoc_resp
+void cfg80211_rx_assoc_resp(struct net_device *dev,
+			    struct cfg80211_rx_assoc_resp *data)
+{
+	_cfg80211_rx_assoc_resp(dev, data);
+}
+EXPORT_SYMBOL(cfg80211_rx_assoc_resp);
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -1602,6 +1602,19 @@ struct cfg80211_bss *__cfg80211_get_bss(
 }
 EXPORT_SYMBOL(__cfg80211_get_bss);
 
+// FIXME: exported here for kABI compatibility
+struct cfg80211_bss *
+cfg80211_get_bss(struct wiphy *wiphy, struct ieee80211_channel *channel,
+		 const u8 *bssid, const u8 *ssid, size_t ssid_len,
+		 enum ieee80211_bss_type bss_type,
+		 enum ieee80211_privacy privacy)
+{
+	return __cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len,
+				  bss_type, privacy,
+				  NL80211_BSS_USE_FOR_NORMAL);
+}
+EXPORT_SYMBOL(cfg80211_get_bss);
+
 static bool rb_insert_bss(struct cfg80211_registered_device *rdev,
 			  struct cfg80211_internal_bss *bss)
 {
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2762,3 +2762,12 @@ cfg80211_get_iftype_ext_capa(struct wiph
 	return NULL;
 }
 EXPORT_SYMBOL(cfg80211_get_iftype_ext_capa);
+
+/* FIXME: old symbol for kABI compatibility */
+#undef ieee80211_mandatory_rates
+u32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,
+			      enum nl80211_bss_scan_width scan_width)
+{
+	return _ieee80211_mandatory_rates(sband);
+}
+EXPORT_SYMBOL(ieee80211_mandatory_rates);

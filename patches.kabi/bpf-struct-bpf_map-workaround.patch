From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: struct bpf_map kABI workaround
Patch-mainline: never, kabi
References: CVE-2024-50063 bsc#1232435

Upstream commit 28ead3eaabc1 ("bpf: Prevent tail call between progs attached to
different hooks") changed struct bpf_map and thus breaks kABI.

Luckily we have kABI padding inplace right within struct bpf_map, hence all
that's needed is to move the newly added field to where the padding is located
and kABI will be preserved.

Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>

[hoyeon.lee: refreshed due to patches.suse/bpf-Enforce-expected_attach_type-for-tailcall-compat.patch]
Acked-by: Michal Koutn√Ω <mkoutny@suse.com>

---
 include/linux/bpf.h |    6 +++++-
 kernel/bpf/core.c   |    4 ++--
 2 files changed, 7 insertions(+), 3 deletions(-)

--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -289,7 +289,6 @@ struct bpf_map {
 	 * same prog type, JITed flag and xdp_has_frags flag.
 	 */
 	struct {
-		const struct btf_type *attach_func_proto;
 		spinlock_t lock;
 		enum bpf_prog_type type;
 		bool jited;
@@ -302,7 +301,12 @@ struct bpf_map {
 	bool free_after_rcu_gp;
 	atomic64_t sleepable_refcnt;
 	s64 __percpu *elem_count;
+#ifndef __GENKSYMS__
+	/* Synchornized with struct owner.lock */
+	const struct btf_type *owner_attach_func_proto;
+#else
 	void *suse_kabi_padding;
+#endif
 };
 
 static inline const char *btf_field_type_name(enum btf_field_type type)
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -2280,7 +2280,7 @@ bool bpf_prog_map_compatible(struct bpf_
 		map->owner.jited = fp->jited;
 		map->owner.xdp_has_frags = aux->xdp_has_frags;
 		map->owner.expected_attach_type = fp->expected_attach_type;
-		map->owner.attach_func_proto = aux->attach_func_proto;
+		map->owner_attach_func_proto = aux->attach_func_proto;
 		ret = true;
 	} else {
 		ret = map->owner.type  == prog_type &&
@@ -2291,7 +2291,7 @@ bool bpf_prog_map_compatible(struct bpf_
 		    map->owner.expected_attach_type != fp->expected_attach_type)
 			ret = false;
 		if (ret &&
-		    map->owner.attach_func_proto != aux->attach_func_proto) {
+		    map->owner_attach_func_proto != aux->attach_func_proto) {
 			switch (prog_type) {
 			case BPF_PROG_TYPE_TRACING:
 			case BPF_PROG_TYPE_LSM:

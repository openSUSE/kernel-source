From: Shung-Hsi Yu <shung-hsi.yu@suse.com>
Subject: kABI: bpf: map_fd_put_ptr() signature kABI workaround
Patch-mainline: never, kabi
References: bsc#1220251 CVE-2023-52447

Commit 876673364161 ("bpf: Defer the free of inner map when necessary")
modified the signature of map_fd_put_ptr() function in struct bpf_map_ops. To
preserve kABI, rename the upstream variant to map_fd_put_ptr_new() and have it
as the last field of struct bpf_map_ops (which isn't embedded). Then recreate
map_fd_put_ptr() with the original function signature that calls into
map_fd_put_ptr_new().

When calling map_fd_put_ptr_new() from map_fd_put_ptr(), *map can be NULL
since it is not used, and need_defer is set to false for the unaffected
program types. 

Signed-off-by: Shung-Hsi Yu <shung-hsi.yu@suse.com>
---
 include/linux/bpf.h     |   14 +++++++++-----
 kernel/bpf/arraymap.c   |   46 ++++++++++++++++++++++++++++++++++++++++------
 kernel/bpf/hashtab.c    |   20 +++++++++++++++-----
 kernel/bpf/map_in_map.c |    7 ++++++-
 kernel/bpf/map_in_map.h |    5 ++++-
 5 files changed, 74 insertions(+), 18 deletions(-)

--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -92,11 +92,7 @@ struct bpf_map_ops {
 	/* funcs called by prog_array and perf_event_array map */
 	void *(*map_fd_get_ptr)(struct bpf_map *map, struct file *map_file,
 				int fd);
-	/* If need_defer is true, the implementation should guarantee that
-	 * the to-be-put element is still alive before the bpf program, which
-	 * may manipulate it, exists.
-	 */
-	void (*map_fd_put_ptr)(struct bpf_map *map, void *ptr, bool need_defer);
+	void (*map_fd_put_ptr)(void *ptr);
 	int (*map_gen_lookup)(struct bpf_map *map, struct bpf_insn *insn_buf);
 	u32 (*map_fd_sys_lookup_elem)(void *ptr);
 	void (*map_seq_show_elem)(struct bpf_map *map, void *key,
@@ -156,6 +152,14 @@ struct bpf_map_ops {
 
 	/* bpf_iter info used to open a seq_file */
 	const struct bpf_iter_seq_info *iter_seq_info;
+
+#ifndef __GENKSYMS__
+	/* If need_defer is true, the implementation should guarantee that
+	 * the to-be-put element is still alive before the bpf program, which
+	 * may manipulate it, exists.
+	 */
+	void (*map_fd_put_ptr_new)(struct bpf_map *map, void *ptr, bool need_defer);
+#endif
 };
 
 struct bpf_map {
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -783,8 +783,12 @@ int bpf_fd_array_map_update_elem(struct
 		old_ptr = xchg(array->ptrs + index, new_ptr);
 	}
 
-	if (old_ptr)
-		map->ops->map_fd_put_ptr(map, old_ptr, true);
+	if (old_ptr) {
+#ifndef __GENKSYMS__
+		map->ops->map_fd_put_ptr_new(map, old_ptr, true);
+#endif
+	}
+
 	return 0;
 }
 
@@ -807,7 +811,9 @@ static int __fd_array_map_delete_elem(st
 	}
 
 	if (old_ptr) {
-		map->ops->map_fd_put_ptr(map, old_ptr, need_defer);
+#ifndef __GENKSYMS__
+		map->ops->map_fd_put_ptr_new(map, old_ptr, need_defer);
+#endif
 		return 0;
 	} else {
 		return -ENOENT;
@@ -836,12 +842,17 @@ static void *prog_fd_array_get_ptr(struc
 	return prog;
 }
 
-static void prog_fd_array_put_ptr(struct bpf_map *map, void *ptr, bool need_defer)
+static void prog_fd_array_put_ptr_new(struct bpf_map *map, void *ptr, bool need_defer)
 {
 	/* bpf_prog is freed after one RCU or tasks trace grace period */
 	bpf_prog_put(ptr);
 }
 
+static void prog_fd_array_put_ptr(void *ptr)
+{
+	prog_fd_array_put_ptr_new(NULL, ptr, false);
+}
+
 static u32 prog_fd_array_sys_lookup_elem(void *ptr)
 {
 	return ((struct bpf_prog *)ptr)->aux->id;
@@ -1108,6 +1119,9 @@ const struct bpf_map_ops prog_array_map_
 	.map_seq_show_elem = prog_array_map_seq_show_elem,
 	.map_btf_name = "bpf_array",
 	.map_btf_id = &prog_array_map_btf_id,
+#ifndef __GENKSYMS__
+	.map_fd_put_ptr_new = prog_fd_array_put_ptr_new,
+#endif
 };
 
 static struct bpf_event_entry *bpf_event_entry_gen(struct file *perf_file,
@@ -1165,12 +1179,17 @@ err_out:
 	return ee;
 }
 
-static void perf_event_fd_array_put_ptr(struct bpf_map *map, void *ptr, bool need_defer)
+static void perf_event_fd_array_put_ptr_new(struct bpf_map *map, void *ptr, bool need_defer)
 {
 	/* bpf_perf_event is freed after one RCU grace period */
 	bpf_event_entry_free_rcu(ptr);
 }
 
+static void perf_event_fd_array_put_ptr(void *ptr)
+{
+	perf_event_fd_array_put_ptr_new(NULL, ptr, false);
+}
+
 static void perf_event_fd_array_release(struct bpf_map *map,
 					struct file *map_file)
 {
@@ -1212,6 +1231,9 @@ const struct bpf_map_ops perf_event_arra
 	.map_check_btf = map_check_no_btf,
 	.map_btf_name = "bpf_array",
 	.map_btf_id = &perf_event_array_map_btf_id,
+#ifndef __GENKSYMS__
+	.map_fd_put_ptr_new = perf_event_fd_array_put_ptr_new,
+#endif
 };
 
 #ifdef CONFIG_CGROUPS
@@ -1222,12 +1244,18 @@ static void *cgroup_fd_array_get_ptr(str
 	return cgroup_get_from_fd(fd);
 }
 
-static void cgroup_fd_array_put_ptr(struct bpf_map *map, void *ptr, bool need_defer)
+static void cgroup_fd_array_put_ptr_new(struct bpf_map *map, void *ptr, bool need_defer)
 {
 	/* cgroup_put free cgrp after a rcu grace period */
 	cgroup_put(ptr);
 }
 
+
+static void cgroup_fd_array_put_ptr(void *ptr)
+{
+	cgroup_fd_array_put_ptr_new(NULL, ptr, false);
+}
+
 static void cgroup_fd_array_free(struct bpf_map *map)
 {
 	bpf_fd_array_map_clear(map, false);
@@ -1248,6 +1276,9 @@ const struct bpf_map_ops cgroup_array_ma
 	.map_check_btf = map_check_no_btf,
 	.map_btf_name = "bpf_array",
 	.map_btf_id = &cgroup_array_map_btf_id,
+#ifndef __GENKSYMS__
+	.map_fd_put_ptr_new = cgroup_fd_array_put_ptr_new,
+#endif
 };
 #endif
 
@@ -1336,4 +1367,7 @@ const struct bpf_map_ops array_of_maps_m
 	.map_check_btf = map_check_no_btf,
 	.map_btf_name = "bpf_array",
 	.map_btf_id = &array_of_maps_map_btf_id,
+#ifndef __GENKSYMS__
+	.map_fd_put_ptr_new = bpf_map_fd_put_ptr_new,
+#endif
 };
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@ -806,10 +806,12 @@ static void htab_put_fd_value(struct bpf
 	struct bpf_map *map = &htab->map;
 	void *ptr;
 
-	if (map->ops->map_fd_put_ptr) {
+#ifndef __GENKSYMS__
+	if (map->ops->map_fd_put_ptr_new) {
 		ptr = fd_htab_map_get_ptr(map, l);
-		map->ops->map_fd_put_ptr(map, ptr, true);
+		map->ops->map_fd_put_ptr_new(map, ptr, true);
 	}
+#endif
 }
 
 static void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)
@@ -2233,7 +2235,9 @@ static void fd_htab_map_free(struct bpf_
 		hlist_nulls_for_each_entry_safe(l, n, head, hash_node) {
 			void *ptr = fd_htab_map_get_ptr(map, l);
 
-			map->ops->map_fd_put_ptr(map, ptr, false);
+#ifndef __GENKSYMS__
+			map->ops->map_fd_put_ptr_new(map, ptr, false);
+#endif
 		}
 	}
 
@@ -2273,8 +2277,11 @@ int bpf_fd_htab_map_update_elem(struct b
 		return PTR_ERR(ptr);
 
 	ret = htab_map_update_elem(map, key, &ptr, map_flags);
-	if (ret)
-		map->ops->map_fd_put_ptr(map, ptr, false);
+	if (ret) {
+#ifndef __GENKSYMS__
+		map->ops->map_fd_put_ptr_new(map, ptr, false);
+#endif
+	}
 
 	return ret;
 }
@@ -2347,4 +2354,7 @@ const struct bpf_map_ops htab_of_maps_ma
 	.map_check_btf = map_check_no_btf,
 	.map_btf_name = "bpf_htab",
 	.map_btf_id = &htab_of_maps_map_btf_id,
+#ifndef __GENKSYMS__
+	.map_fd_put_ptr_new = bpf_map_fd_put_ptr_new,
+#endif
 };
--- a/kernel/bpf/map_in_map.c
+++ b/kernel/bpf/map_in_map.c
@@ -100,7 +100,7 @@ void *bpf_map_fd_get_ptr(struct bpf_map
 	return inner_map;
 }
 
-void bpf_map_fd_put_ptr(struct bpf_map *map, void *ptr, bool need_defer)
+void bpf_map_fd_put_ptr_new(struct bpf_map *map, void *ptr, bool need_defer)
 {
 	struct bpf_map *inner_map = ptr;
 
@@ -113,6 +113,11 @@ void bpf_map_fd_put_ptr(struct bpf_map *
 	bpf_map_put(inner_map);
 }
 
+
+void bpf_map_fd_put_ptr(void *ptr) {
+	bpf_map_fd_put_ptr_new(NULL, ptr, true);
+}
+
 u32 bpf_map_fd_sys_lookup_elem(void *ptr)
 {
 	return ((struct bpf_map *)ptr)->id;
--- a/kernel/bpf/map_in_map.h
+++ b/kernel/bpf/map_in_map.h
@@ -13,7 +13,10 @@ struct bpf_map *bpf_map_meta_alloc(int i
 void bpf_map_meta_free(struct bpf_map *map_meta);
 void *bpf_map_fd_get_ptr(struct bpf_map *map, struct file *map_file,
 			 int ufd);
-void bpf_map_fd_put_ptr(struct bpf_map *map, void *ptr, bool need_defer);
+void bpf_map_fd_put_ptr(void *ptr);
+#ifndef __GENKSYMS__
+void bpf_map_fd_put_ptr_new(struct bpf_map *map, void *ptr, bool need_defer);
+#endif
 u32 bpf_map_fd_sys_lookup_elem(void *ptr);
 
 #endif

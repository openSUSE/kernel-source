From a1f513a3529f6e676c84336489c59d6ee021f89d Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@kernel.org>
Date: Wed, 25 Sep 2024 09:28:59 +0200
Subject: [PATCH] kabi: add __nf_queue_get_refs() for kabi compliance

Commit c3873070247d9e3c7a6b0cf9bf9b45e8018427b1 changed the return
value from nf_queue_get_refs() from 'void' to 'bool', so change the
name to __nf_queue_get_refs() and re-introduce the original version
for kabi compliance.

References: bsc#1229633,CVE-2022-48911
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 include/net/netfilter/nf_queue.h |  3 ++-
 net/netfilter/nf_queue.c         | 25 +++++++++++++++++++++++--
 net/netfilter/nfnetlink_queue.c  |  2 +-
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h
index b1d43894296a6..1f7b1a6450eba 100644
--- a/include/net/netfilter/nf_queue.h
+++ b/include/net/netfilter/nf_queue.h
@@ -37,7 +37,8 @@ void nf_register_queue_handler(struct net *net, const struct nf_queue_handler *q
 void nf_unregister_queue_handler(struct net *net);
 void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict);
 
-bool nf_queue_entry_get_refs(struct nf_queue_entry *entry);
+void nf_queue_entry_get_refs(struct nf_queue_entry *entry);
+bool __nf_queue_entry_get_refs(struct nf_queue_entry *entry);
 void nf_queue_entry_free(struct nf_queue_entry *entry);
 
 static inline void init_hashrandom(u32 *jhash_initval)
diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
index 212d4b137d818..33e7e0d21402a 100644
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -91,7 +91,7 @@ static void __nf_queue_entry_init_physdevs(struct nf_queue_entry *entry)
 }
 
 /* Bump dev refs so they don't vanish while packet is out */
-bool nf_queue_entry_get_refs(struct nf_queue_entry *entry)
+bool __nf_queue_entry_get_refs(struct nf_queue_entry *entry)
 {
 	struct nf_hook_state *state = &entry->state;
 
@@ -111,6 +111,27 @@ bool nf_queue_entry_get_refs(struct nf_queue_entry *entry)
 #endif
 	return true;
 }
+EXPORT_SYMBOL_GPL(__nf_queue_entry_get_refs);
+
+/* Bump dev refs so they don't vanish while packet is out */
+void nf_queue_entry_get_refs(struct nf_queue_entry *entry)
+{
+	struct nf_hook_state *state = &entry->state;
+
+	if (state->in)
+		dev_hold(state->in);
+	if (state->out)
+		dev_hold(state->out);
+	if (state->sk)
+		sock_hold(state->sk);
+
+#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+	if (entry->physin)
+		dev_hold(entry->physin);
+	if (entry->physout)
+		dev_hold(entry->physout);
+#endif
+}
 EXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);
 
 void nf_queue_nf_hook_drop(struct net *net)
@@ -198,7 +219,7 @@ static int __nf_queue(struct sk_buff *skb, const struct nf_hook_state *state,
 
 	__nf_queue_entry_init_physdevs(entry);
 
-	if (!nf_queue_entry_get_refs(entry)) {
+	if (!__nf_queue_entry_get_refs(entry)) {
 		kfree(entry);
 		return -ENOTCONN;
 	}
diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c
index 630fe513f95c0..120b9ad2ac840 100644
--- a/net/netfilter/nfnetlink_queue.c
+++ b/net/netfilter/nfnetlink_queue.c
@@ -713,7 +713,7 @@ nf_queue_entry_dup(struct nf_queue_entry *e)
 	if (!entry)
 		return NULL;
 
-	if (nf_queue_entry_get_refs(entry))
+	if (__nf_queue_entry_get_refs(entry))
 		return entry;
 
 	kfree(entry);
-- 
2.35.3


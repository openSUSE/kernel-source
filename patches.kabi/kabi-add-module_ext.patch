Date: Mon, 14 Oct 2024 10:05:48 -0700
From: Nikolay Borisov <nik.borisov@suse.com>
Subject: kABI: Add module_ext
Patch-mainline: Never, kABI fix
References: bsc#1242006 CVE-2024-28956

Adjust the dynamic ITS code to use the existing kabi padding in struct module.

Signed-off-by: Nikolay Borisov <nik.borisov@suse.com>
Reviewed-by: Jan Kara <jack@suse.cz>
---
 arch/x86/kernel/alternative.c |   18 +++++++++---------
 include/linux/module.h        |   16 +++++++++++-----
 kernel/module.c               |   11 +++++++++--
 3 files changed, 29 insertions(+), 16 deletions(-)

--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -178,8 +178,8 @@ void its_fini_mod(struct module *mod)
 	its_page = NULL;
 	mutex_unlock(&text_mutex);
 
-	for (int i = 0; i < mod->its_num_pages; i++) {
-		void *page = mod->its_page_array[i];
+	for (int i = 0; i < mod->ext->its_num_pages; i++) {
+		void *page = mod->ext->its_page_array[i];
 		set_memory_ro((unsigned long)page, 1);
 		set_memory_x((unsigned long)page, 1);
 	}
@@ -190,11 +190,11 @@ void its_free_mod(struct module *mod)
 	if (!cpu_feature_enabled(X86_FEATURE_INDIRECT_THUNK_ITS))
 		return;
 
-	for (int i = 0; i < mod->its_num_pages; i++) {
-		void *page = mod->its_page_array[i];
+	for (int i = 0; i < mod->ext->its_num_pages; i++) {
+		void *page = mod->ext->its_page_array[i];
 		module_memfree(page);
 	}
-	kfree(mod->its_page_array);
+	kfree(mod->ext->its_page_array);
 }
 
 static void *its_alloc(void)
@@ -205,16 +205,16 @@ static void *its_alloc(void)
 		return NULL;
 
 	if (its_mod) {
-		void *tmp = krealloc(its_mod->its_page_array,
-				     (its_mod->its_num_pages+1) * sizeof(void *),
+		void *tmp = krealloc(its_mod->ext->its_page_array,
+				     (its_mod->ext->its_num_pages+1) * sizeof(void *),
 				     GFP_KERNEL);
 		if (!tmp) {
 			module_memfree(page);
 			return NULL;
 		}
 
-		its_mod->its_page_array = tmp;
-		its_mod->its_page_array[its_mod->its_num_pages++] = page;
+		its_mod->ext->its_page_array = tmp;
+		its_mod->ext->its_page_array[its_mod->ext->its_num_pages++] = page;
 	}
 
 	return page;
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -321,6 +321,13 @@ struct mod_tree_node {
 	struct latch_tree_node node;
 };
 
+struct module_ext {
+#ifdef CONFIG_MITIGATION_ITS
+	int its_num_pages;
+	void **its_page_array;
+#endif
+};
+
 struct module_layout {
 	/* The actual code + data. */
 	void *base;
@@ -534,12 +541,11 @@ struct module {
 	unsigned int num_ei_funcs;
 #endif
 
-#ifdef CONFIG_MITIGATION_ITS
-	int its_num_pages;
-	void **its_page_array;
-#endif
-
+#ifdef __GENKSYMS__
 	void *suse_kabi_padding;
+#else
+	struct module_ext *ext;
+#endif
 } ____cacheline_aligned __randomize_layout;
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2278,6 +2278,7 @@ static void free_module(struct module *m
 	module_memfree(mod->init_layout.base);
 	kfree(mod->args);
 	percpu_modfree(mod);
+	kfree(mod->ext);
 
 	/* Free lock-classes; relies on the preceding sync_rcu(). */
 	lockdep_free_key_range(mod->core_layout.base, mod->core_layout.size);
@@ -4138,17 +4139,21 @@ static int load_module(struct load_info
 
 	init_param_lock(mod);
 
+	mod->ext = kmalloc(sizeof(*mod->ext), GFP_KERNEL);
+	if (!mod->ext)
+		goto free_unload;
+
 	/*
 	 * Now we've got everything in the final locations, we can
 	 * find optional sections.
 	 */
 	err = find_module_sections(mod, info);
 	if (err)
-		goto free_unload;
+		goto free_modext;
 
 	err = check_module_license_and_versions(mod);
 	if (err)
-		goto free_unload;
+		goto free_modext;
 
 	/* Set up MODINFO_ATTR fields */
 	setup_modinfo(mod, info);
@@ -4249,6 +4254,8 @@ static int load_module(struct load_info
 	module_arch_cleanup(mod);
  free_modinfo:
 	free_modinfo(mod);
+ free_modext:
+	kfree(mod->ext);
  free_unload:
 	module_unload_free(mod);
  unlink_mod:

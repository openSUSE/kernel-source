Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>

  To fix the following compile error by changing names from
__{read,write}_trylock to ___raw_{read,write}_trylock in asm-powerpc/spinlock.h

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
include/asm-powerpc/spinlock.h
include/linux/spinlock_api_smp.h:49: error: conflicting types for '__read_trylock'
include/asm/spinlock.h:183: error: previous definition of '__read_trylock' was here
include/linux/spinlock_api_smp.h:50: error: conflicting types for '__write_trylock'
include/asm/spinlock.h:207: error: previous definition of '__write_trylock' was here
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Signed-off-by: Tsutomu Owa <tsutomu.owa@toshiba.co.jp>
-- owa

---
 arch/powerpc/include/asm/spinlock.h |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/arch/powerpc/include/asm/spinlock.h b/arch/powerpc/include/asm/spinlock.h
index 0f2eb8c..8fcda96 100644
--- a/arch/powerpc/include/asm/spinlock.h
+++ b/arch/powerpc/include/asm/spinlock.h
@@ -181,7 +181,7 @@ extern void __raw_spin_unlock_wait(__raw_spinlock_t *lock);
  * This returns the old value in the lock + 1,
  * so we got a read lock if the return value is > 0.
  */
-static inline long __read_trylock(__raw_rwlock_t *rw)
+static inline long ___raw_read_trylock(__raw_rwlock_t *rw)
 {
 	long tmp;
 
@@ -205,7 +205,7 @@ static inline long __read_trylock(__raw_rwlock_t *rw)
  * This returns the old value in the lock,
  * so we got the write lock if the return value is 0.
  */
-static inline long __write_trylock(__raw_rwlock_t *rw)
+static inline long ___raw_write_trylock(__raw_rwlock_t *rw)
 {
 	long tmp, token;
 
@@ -228,7 +228,7 @@ static inline long __write_trylock(__raw_rwlock_t *rw)
 static inline void __raw_read_lock(__raw_rwlock_t *rw)
 {
 	while (1) {
-		if (likely(__read_trylock(rw) > 0))
+		if (likely(___raw_read_trylock(rw) > 0))
 			break;
 		do {
 			HMT_low();
@@ -242,7 +242,7 @@ static inline void __raw_read_lock(__raw_rwlock_t *rw)
 static inline void __raw_write_lock(__raw_rwlock_t *rw)
 {
 	while (1) {
-		if (likely(__write_trylock(rw) == 0))
+		if (likely(___raw_write_trylock(rw) == 0))
 			break;
 		do {
 			HMT_low();
@@ -255,12 +255,12 @@ static inline void __raw_write_lock(__raw_rwlock_t *rw)
 
 static inline int __raw_read_trylock(__raw_rwlock_t *rw)
 {
-	return __read_trylock(rw) > 0;
+	return ___raw_read_trylock(rw) > 0;
 }
 
 static inline int __raw_write_trylock(__raw_rwlock_t *rw)
 {
-	return __write_trylock(rw) == 0;
+	return ___raw_write_trylock(rw) == 0;
 }
 
 static inline void __raw_read_unlock(__raw_rwlock_t *rw)

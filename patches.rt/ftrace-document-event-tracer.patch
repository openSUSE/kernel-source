Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>
---
 Documentation/ftrace.txt |  260 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 260 insertions(+)

Index: linux-2.6.26.3-rt6/Documentation/ftrace.txt
===================================================================
--- linux-2.6.26.3-rt6.orig/Documentation/ftrace.txt	2008-09-05 00:22:22.000000000 -0400
+++ linux-2.6.26.3-rt6/Documentation/ftrace.txt	2008-09-05 00:22:28.000000000 -0400
@@ -9,6 +9,7 @@ Reviewers:   Elias Oltmanns, Randy Dunla
 	     John Kacur, and David Teigland.
 
 Written for: 2.6.27-rc1
+  (RT patch edition)
 
 Introduction
 ------------
@@ -166,6 +167,8 @@ Here is the list of current tracers that
 		the highest priority task to get scheduled after
 		it has been woken up.
 
+  events - Traces various kernel events (interrupts, timers, system calls).
+
   none - This is not a tracer. To remove all tracers from tracing
 		simply echo "none" into current_tracer.
 
@@ -1000,6 +1003,263 @@ is the stack for the hard interrupt. Thi
 has been set. We do not see the 'N' until we switch back to the task's
 assigned stack.
 
+
+events
+------
+
+The events tracer records various events that happen in the kernel.
+Having this with function tracer produces more useful information
+than just having ftrace alone. But ftrace can be overflowing with
+information, and running events tracer without ftrace may be helpful
+enough.
+
+ # sysctl kernel.ftrace_enabled=0
+ # echo events > /debug/tracing/current_tracer
+ # echo 1 > /debug/tracing/tracing_enabled
+ # usleep 1
+ # echo 0 > /debug/tracing/tracing_enabled
+ # cat /debug/tracing/trace
+
+[ I trimmed this output to just show the various traces ]
+
+# tracer: events
+#
+#           TASK-PID   CPU#    TIMESTAMP  FUNCTION
+#              | |      |          |         |
+            bash-3270  [00]   326.468161: syscall_exit< (7)
+            bash-3270  [00]   326.468164: sysenter_enter sys_dup2 (a 1 1)
+            bash-3270  [00]   326.468166: syscall_exit< (1)
+            bash-3270  [00]   326.468167: sysenter_enter sys_fcntl64 (a 1 1)
+            bash-3270  [00]   326.468168: syscall_exit< (1)
+            bash-3270  [00]   326.468169: sysenter_enter sys_close (a 1 1)
+            bash-3270  [00]   326.468170: syscall_exit< (0)
+            bash-3270  [00]   326.468175: sysenter_enter sys_rt_sigprocmask (0 0 0)
+            bash-3270  [00]   326.468175: syscall_exit< (0)
+[...]
+            bash-3270  [00]   326.468302: sysenter_enter sys_write (1 b7fbb000 b7f1d000)
+            bash-3270  [00]   326.468306: activate_task sshd 3268 120 [1]
+            bash-3270  [00]   326.468307:      0:140:R   +  3268:120:S
+            bash-3270  [00]   326.468309: syscall_exit< (19)
+          <idle>-0     [01]   326.468309:      0:140:R ==>  3268:120:R
+            sshd-3268  [01]   326.468315: syscall_exit< (1)
+            sshd-3268  [01]   326.468316: sysenter_enter sys_rt_sigprocmask (0 bf9d95b8 bfa93678)
+            sshd-3268  [01]   326.468317: syscall_exit< (0)
+            sshd-3268  [01]   326.468318: sysenter_enter sys_rt_sigprocmask (2 bf9d9638 bfa936f8)
+            sshd-3268  [01]   326.468318: syscall_exit< (0)
+            sshd-3268  [01]   326.468319: sysenter_enter sys_read (b bf9d563c bfa8f6fc)
+            sshd-3268  [01]   326.468323: syscall_exit< (19)
+            bash-3270  [00]   326.468330: sysenter_enter sys_write (3 b7fbb000 b7f1d000)
+            bash-3270  [00]   326.468333: syscall_exit< (1)
+            sshd-3268  [01]   326.468336: sysenter_enter sys_select (d8 80074528 80073e88)
+            sshd-3268  [01]   326.468340: syscall_exit< (2)
+
+[...]
+
+            bash-3270  [01]   328.471447: smp_apic_timer_interrupt -1  (usermode)
+            bash-3270  [01]   328.471447: hrtimer_interrupt (286035251144)
+            bash-3270  [01]   328.471448: hrtimer_interrupt (286035250000) (cabd93a4)
+
+[...]
+
+            bash-3270  [01]   330.337906: sysenter_enter sys_pipe (80f29cc 0 0)
+            bash-3270  [01]   330.337910: syscall_exit< (0)
+            bash-3270  [01]   330.337911: sysenter_enter sys_clone (1200011 0 0)
+            bash-3270  [01]   330.337931: smp_apic_timer_interrupt -1  (rt_spin_unlock)
+            bash-3270  [01]   330.337932: hrtimer_interrupt (287904251119)
+            bash-3270  [01]   330.337933: hrtimer_interrupt (287904250000) (cabd93a4)
+            bash-3270  [01]   330.337936: activate_task sirq-timer/1 19 49 [1]
+          <idle>-0     [00]   330.337937: clockevents_program_event (288552039947) (647784092)
+          <idle>-0     [00]   330.337937: enqueue_hrtimer (287905000000) (cabd03a4)
+            bash-3270  [01]   330.337937:   3270:120:R   +    19: 49:S
+          <idle>-0     [00]   330.337938: clockevents_program_event (287905000000) (742994)
+            bash-3270  [01]   330.337940: activate_task sirq-rcu/1 26 49 [1]
+            bash-3270  [01]   330.337941:   3270:120:R   +    26: 49:S
+            bash-3270  [01]   330.337942: enqueue_hrtimer (287905250000) (cabd93a4)
+            bash-3270  [01]   330.337942: clockevents_program_event (287905250000) (988495)
+            bash-3270  [01]   330.337945:   3270:120:R ==>    19: 49:R
+    sirq-timer/1-19    [01]   330.337947: activate_task kondemand/1 2302 115 [1]
+    sirq-timer/1-19    [01]   330.337948:     19: 49:R   +  2302:115:S
+    sirq-timer/1-19    [01]   330.337952: deactivate_task sirq-timer/1 19 49 [1]
+    sirq-timer/1-19    [01]   330.337953:     19: 49:S ==>    26: 49:R
+      sirq-rcu/1-26    [01]   330.337955: deactivate_task sirq-rcu/1 26 49 [1]
+      sirq-rcu/1-26    [01]   330.337956:     26: 49:S ==>  2302:115:R
+     kondemand/1-2302  [01]   330.337959: deactivate_task kondemand/1 2302 115 [1]
+     kondemand/1-2302  [01]   330.337960:   2302:115:S ==>  3270:120:R
+            bash-3270  [01]   330.338007:   3270:120:R   +  3302:120:R
+            bash-3270  [01]   330.338009:   3270:120:R ==>  3302:120:R
+          usleep-3302  [01]   330.338011: do_page_fault 3  (__put_user_4) [b7fb3708]
+          usleep-3302  [01]   330.338019: syscall_exit< (-167586576)
+          usleep-3302  [01]   330.338020: do_page_fault 14  () [b7fc3410]
+
+[...]
+
+          usleep-3302  [01]   330.338081: do_page_fault 14  () [43807c30]
+          usleep-3302  [01]   330.338083: sysenter_enter sys_rt_sigprocmask (2 80fb380 80fb380)
+          usleep-3302  [01]   330.338084: syscall_exit< (0)
+          usleep-3302  [01]   330.338085: do_page_fault 7  () [80f8230]
+[...]
+
+          usleep-3302  [00]   330.348695: deactivate_task usleep 3302 120 [0]
+          usleep-3302  [00]   330.348696:   3302:120:T ==>     0:140:R
+          <idle>-0     [00]   330.348699: clockevents_program_event (288552039947) (637007252)
+          <idle>-0     [00]   330.348700: enqueue_hrtimer (288104000000) (cabd03a4)
+          <idle>-0     [00]   330.348700: clockevents_program_event (288104000000) (188966439)
+          <idle>-0     [00]   330.348851: do_IRQ 217  (mwait_idle_with_hints)
+          <idle>-0     [00]   330.348852: activate_task IRQ-217 476 49 [1]
+          <idle>-0     [00]   330.348854:      0:140:R   +   476: 49:S
+          <idle>-0     [01]   330.348855:      0:140:R ==>   476: 49:R
+          <idle>-0     [00]   330.348856: clockevents_program_event (288552039947) (636850255)
+          <idle>-0     [00]   330.348856: enqueue_hrtimer (288104000000) (cabd03a4)
+          <idle>-0     [00]   330.348857: clockevents_program_event (288104000000) (188809576)
+         IRQ-217-476   [01]   330.348860: activate_task sirq-block/1 22 49 [1]
+
+[...]
+
+          usleep-3302  [00]   330.349245: do_page_fault 14  () [43880800]
+          usleep-3302  [00]   330.349247: sysenter_enter sys_nanosleep (bf861910 0 0)
+          usleep-3302  [00]   330.349248: enqueue_hrtimer (287915583157) (f45f3f44)
+          usleep-3302  [00]   330.349249: clockevents_program_event (287915583157) (268)
+          usleep-3302  [00]   330.349250: deactivate_task usleep 3302 120 [0]
+          usleep-3302  [00]   330.349252:   3302:120:S ==>     0:140:R
+          <idle>-0     [00]   330.349253: smp_apic_timer_interrupt -1  (cpu_idle)
+          <idle>-0     [00]   330.349254: hrtimer_interrupt (287915587897)
+          <idle>-0     [00]   330.349254: hrtimer_interrupt (287915583157) (f45f3f44)
+          <idle>-0     [00]   330.349255: activate_task usleep 3302 120 [0]
+          <idle>-0     [00]   330.349256:      0:140:R   +  3302:120:S
+          <idle>-0     [00]   330.349257: clockevents_program_event (287916000000) (408972)
+          <idle>-0     [00]   330.349258:      0:140:R ==>  3302:120:R
+          usleep-3302  [00]   330.349259: syscall_exit< (0)
+          usleep-3302  [00]   330.349268: sysenter_enter sys_exit_group (0 4 4)
+[...]
+
+The "function" formats for the event entries are:
+
+  The wake up and schedule events are the same as the sched_switch
+  tracer.  They will not be repeated here.
+
+  interrupt:
+
+	<function> <IRQ#> (<kernel funciton interruption>|"usermode")
+
+	The above example contains:
+
+	  bash-3270  [01]   328.471447: smp_apic_timer_interrupt -1  (usermode)
+
+	Here the timer interrupt went off while bash was in usermode. The
+	timer interrupt handler is smp_apic_timer_interrupt. The
+	"-1" is that the timer interrupt event handler does not pass
+	in an IRQ number.
+
+          <idle>-0     [00]   330.348851: do_IRQ 217  (mwait_idle_with_hints)
+
+	Here, the interrupt "217" triggered while the idle thread was
+	in kernel mode running "mwait_idle_with_hints".
+
+
+  page faults:
+
+	<function> <fault-error#> (<kernel function>) [<fault address>]
+
+	Examples:
+
+          usleep-3302  [01]   330.338011: do_page_fault 3  (__put_user_4) [b7fb3708]
+
+	A page fault happened in the kernel function "__put_user_4".
+	This is normal when the kernel tries to write to user memory
+	and the memory is not allocated yet. The address was at
+	0xb7fb3708.
+
+
+          usleep-3302  [01]   330.338020: do_page_fault 14  () [b7fc3410]
+
+	This example shows a much more common case. This is simply
+	the usleep programm faulting in stack addresses.
+
+
+  timer set:
+
+	<function> (<expires>) (<timer>)
+
+	When a timer is queued, the expires time is recorded as well
+	as the pointer to the timer structure.  The pointer is just
+	a way to see which timer has been set, and can be used to
+	track other updates to it.
+
+	Example:
+
+          usleep-3302  [00]   330.349248: enqueue_hrtimer (287915583157) (f45f3f44)
+
+	The usleep program enqueued a timer to go off at the timestamp
+	287915583157 and the pointer used is 0xf45f3f44.
+
+
+  timer triggered:
+
+	<function> (<expired>) (<timer>)
+
+	Similar to the timer set, this is the format when the timer
+	is triggered.
+
+	Example:
+
+          <idle>-0     [00]   330.349254: hrtimer_interrupt (287915583157) (f45f3f44)
+
+	The hrtimer_interrupt handled the timer set by our usleep
+	program.
+
+  task activated:
+
+	<function> <comm> <pid> <priority> [<CPU>]
+
+	When a task is queued to run, the 8 character command line of
+	the task, the task PID, the task kernel priority (remmeber
+	this is the inverse of userland priority, where 0 is highest),
+	and the task CPU are all recorded in the trace entry.
+
+	Example:
+
+          <idle>-0     [00]   330.349255: activate_task usleep 3302 120 [0]
+
+	The timer interrupt woke up the usleep task. The activate_task
+	is a kenel function to queue the task.
+
+  task deactivate:
+
+	<function> <comm> <pid> <priority> [<CPU>]
+
+	This is the same format as the activate task. This gets called
+	when the task is removed from the run queue and goes to
+	sleep.
+
+	Example:
+
+          usleep-3302  [00]   330.348695: deactivate_task usleep 3302 120 [0]
+
+	After scheduling a timer interrupt to wake itself up, the
+	usleep program removed itself from the run queue to sleep.
+
+
+  system call:
+
+	 <function> <system_call> (<p1> <p2> <p3>)
+
+	 When a system call is made, the trace records the kernel
+	 function entry point (ususally in assembly), it looks
+	 up the system call in the system call table for the kernel
+	 function entry for the system call. It then records the
+	 first three parameters of the system call (p1, p2, p3).
+
+	 Example:
+
+          usleep-3302  [00]   330.349247: sysenter_enter sys_nanosleep (bf861910 0 0)
+
+	  The "sysenter_enter" is a label in the assembly of in the
+	  kernel that handles system call exceptions.
+
+	  The "sys_nanosleep" is the kernel function to handle the
+	  nanosleep system call. The bf861910 is the pointer to the
+	  timespec passed into the system call.
+
 ftrace
 ------
 

Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>
---
 kernel/rtmutex.c |   13 +++++++++++++
 1 file changed, 13 insertions(+)

Index: linux-2.6.26.3-rt6/kernel/rtmutex.c
===================================================================
--- linux-2.6.26.3-rt6.orig/kernel/rtmutex.c	2008-09-05 00:23:58.000000000 -0400
+++ linux-2.6.26.3-rt6/kernel/rtmutex.c	2008-09-05 00:23:58.000000000 -0400
@@ -1684,6 +1684,7 @@ rt_read_slowunlock(struct rw_mutex *rwm,
 {
 	struct rt_mutex *mutex = &rwm->mutex;
 	struct rt_mutex_waiter *waiter;
+	struct task_struct *pendowner;
 	struct reader_lock_struct *rls;
 	unsigned long flags;
 	unsigned int reader_count;
@@ -1792,6 +1793,7 @@ rt_read_slowunlock(struct rw_mutex *rwm,
 			rwm->owner = RT_RW_PENDING_READ;
 	}
 
+	pendowner = waiter->task;
 	wakeup_next_waiter(mutex, savestate);
 
 	/*
@@ -1807,6 +1809,17 @@ rt_read_slowunlock(struct rw_mutex *rwm,
 	if (rt_mutex_has_waiters(mutex)) {
 		waiter = rt_mutex_top_waiter(mutex);
 		rwm->prio = waiter->task->prio;
+		/*
+		 * If readers still own this lock, then we need
+		 * to update the pi_list too. Readers have a separate
+		 * path in the PI chain.
+		 */
+		if (reader_count) {
+			spin_lock(&pendowner->pi_lock);
+			plist_del(&waiter->pi_list_entry,
+				  &pendowner->pi_waiters);
+			spin_unlock(&pendowner->pi_lock);
+		}
 	} else
 		rwm->prio = MAX_PRIO;
 

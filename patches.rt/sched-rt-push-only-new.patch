Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
From ghaskins@novell.com Thu May 15 10:12:52 2008
Date: Thu, 17 Apr 2008 08:49:00 -0400
From: Gregory Haskins <ghaskins@novell.com>
To: suresh.b.siddha@intel.com
Cc: mingo@elte.hu, rostedt@goodmis.org, chinang.ma@intel.com,
     arjan@linux.intel.com, willy@linux.intel.com
Subject: [PATCH] sched: push rt tasks only if newly activated tasks have
    been

    [ The following text is in the "utf-8" character set. ]
    [ Your display is set for the "iso-8859-1" character set.  ]
    [ Some characters may be displayed incorrectly. ]

added

Hi Suresh,
  Please try this patch to see if it resolves your regression.  It applies to
  the newly minted v2.6.25 tag from Linus' tree.  I have verified that
  preempt-test still passes with this patch applied.

Hi Steven,
  Please review this patch carefully to see if you think I am introducing any
  new holes with this logic.

Regards,
-Greg

-----------------------
sched: push rt tasks only if newly activated tasks have been added

SCHED_RR can context-switch many times without having changed the run-queue.
Therefore trying to push on each context switch can just be wasted effort.
Instead, set a bit when we have pushed tasks away, and only clear it when the
runqueue adds new tasks.

Signed-off-by: Gregory Haskins <ghaskins@novell.com>
---

 kernel/sched.c    |    2 ++
 kernel/sched_rt.c |    6 +++++-
 2 files changed, 7 insertions(+), 1 deletion(-)

Index: linux-2.6.25.4-rt1/kernel/sched.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/sched.c	2008-05-16 22:15:42.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/sched.c	2008-05-16 22:15:44.000000000 -0400
@@ -377,6 +377,7 @@ struct rt_rq {
 #ifdef CONFIG_SMP
 	unsigned long rt_nr_migratory;
 	int overloaded;
+	int pushed;
 #endif
 	unsigned long rt_nr_uninterruptible;
 	int rt_throttled;
@@ -7574,6 +7575,7 @@ static void init_rt_rq(struct rt_rq *rt_
 #ifdef CONFIG_SMP
 	rt_rq->rt_nr_migratory = 0;
 	rt_rq->overloaded = 0;
+	rt_rq->pushed = 0;
 #endif
 
 	rt_rq->rt_time = 0;
Index: linux-2.6.25.4-rt1/kernel/sched_rt.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/sched_rt.c	2008-05-16 22:15:42.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/sched_rt.c	2008-05-16 22:15:44.000000000 -0400
@@ -463,6 +463,8 @@ static void enqueue_task_rt(struct rq *r
 	for_each_sched_rt_entity(rt_se)
 		enqueue_rt_entity(rt_se);
 
+	rq->rt.pushed = 0;
+
 	if (p->state == TASK_UNINTERRUPTIBLE)
 		decr_rt_nr_uninterruptible(p, rq);
 }
@@ -792,7 +794,7 @@ static int push_rt_task(struct rq *rq)
 	int ret = 0;
 	int paranoid = RT_MAX_TRIES;
 
-	if (!rq->rt.overloaded)
+	if (!rq->rt.overloaded || rq->rt.pushed)
 		return 0;
 
 	next_task = pick_next_highest_task_rt(rq, -1);
@@ -868,6 +870,8 @@ static void push_rt_tasks(struct rq *rq)
 	/* push_rt_task will return true if it moved an RT */
 	while (push_rt_task(rq))
 		;
+
+	rq->rt.pushed = 1;
 }
 
 static int pull_rt_task(struct rq *this_rq)

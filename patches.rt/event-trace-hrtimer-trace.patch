Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
From: Steven Rostedt <srostedt@redhat.com>
Subject: event-tracer: add clockevent trace

The old latency tracer recorded clockevent programming of the timer.
This patch adds that back in to the event tracer.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 include/linux/ftrace.h      |    4 ++++
 kernel/time/clockevents.c   |    3 +++
 kernel/trace/trace.c        |   26 ++++++++++++++++++++++++++
 kernel/trace/trace.h        |   13 +++++++++++++
 kernel/trace/trace_events.c |   38 ++++++++++++++++++++++++++++++++++++++
 5 files changed, 84 insertions(+)

--- linux-2.6.26-RT.orig/include/linux/ftrace.h
+++ linux-2.6.26-RT/include/linux/ftrace.h
@@ -194,4 +194,8 @@ DEFINE_TRACE(event_task_deactivate,
 	TPPROTO(struct task_struct *p, int cpu),
 	     TPARGS(p, cpu));
 
+DEFINE_TRACE(event_program_event,
+	TPPROTO(ktime_t *expires, int64_t *delta),
+	     TPARGS(expires, delta));
+
 #endif /* _LINUX_FTRACE_H */
--- linux-2.6.26-RT.orig/kernel/time/clockevents.c
+++ linux-2.6.26-RT/kernel/time/clockevents.c
@@ -18,6 +18,7 @@
 #include <linux/notifier.h>
 #include <linux/smp.h>
 #include <linux/sysdev.h>
+#include <linux/ftrace.h>
 
 /* The registered clock event devices */
 static LIST_HEAD(clockevent_devices);
@@ -100,6 +101,8 @@ int clockevents_program_event(struct clo
 
 	delta = ktime_to_ns(ktime_sub(expires, now));
 
+	trace_event_program_event(&expires, &delta);
+
 	if (delta <= 0)
 		return -ETIME;
 
--- linux-2.6.26-RT.orig/kernel/trace/trace.c
+++ linux-2.6.26-RT/kernel/trace/trace.c
@@ -1077,6 +1077,22 @@ void tracing_event_timer_set(struct trac
 	entry->timer.timer	= timer;
 }
 
+void tracing_event_program_event(struct trace_array *tr,
+				 struct trace_array_cpu *data,
+				 unsigned long flags,
+				 unsigned long ip,
+				 ktime_t *expires, int64_t *delta)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type		= TRACE_PROGRAM_EVENT;
+	entry->program.ip	= ip;
+	entry->program.expire	= *expires;
+	entry->program.delta	= *delta;
+}
+
 void tracing_event_timer_triggered(struct trace_array *tr,
 				   struct trace_array_cpu *data,
 				   unsigned long flags,
@@ -1762,6 +1778,11 @@ print_lat_fmt(struct trace_iterator *ite
 		trace_seq_printf(s, " (%Ld)\n",
 			   entry->timestamp.now.tv64);
 		break;
+	case TRACE_PROGRAM_EVENT:
+		seq_print_ip_sym(s, entry->program.ip, sym_flags);
+		trace_seq_printf(s, " (%Ld) (%Ld)\n",
+			   entry->program.expire, entry->program.delta);
+		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
 		comm = trace_find_cmdline(entry->task.pid);
@@ -1940,6 +1961,11 @@ static int print_trace_fmt(struct trace_
 		trace_seq_printf(s, " (%Ld)\n",
 			   entry->timestamp.now.tv64);
 		break;
+	case TRACE_PROGRAM_EVENT:
+		seq_print_ip_sym(s, entry->program.ip, sym_flags);
+		trace_seq_printf(s, " (%Ld) (%Ld)\n",
+			   entry->program.expire, entry->program.delta);
+		break;
 	case TRACE_TASK_ACT:
 		seq_print_ip_sym(s, entry->task.ip, sym_flags);
 		comm = trace_find_cmdline(entry->task.pid);
--- linux-2.6.26-RT.orig/kernel/trace/trace.h
+++ linux-2.6.26-RT/kernel/trace/trace.h
@@ -22,6 +22,7 @@ enum trace_type {
 	TRACE_TIMER_SET,
 	TRACE_TIMER_TRIG,
 	TRACE_TIMESTAMP,
+	TRACE_PROGRAM_EVENT,
 	TRACE_TASK_ACT,
 	TRACE_TASK_DEACT,
 	TRACE_SYSCALL,
@@ -79,6 +80,12 @@ struct timer_entry {
 	void			*timer;
 };
 
+struct program_entry {
+	unsigned long		ip;
+	ktime_t			expire;
+	int64_t			delta;
+};
+
 struct timestamp_entry {
 	unsigned long		ip;
 	ktime_t			now;
@@ -145,6 +152,7 @@ struct trace_entry {
 		struct fault_entry		fault;
 		struct timer_entry		timer;
 		struct timestamp_entry		timestamp;
+		struct program_entry		program;
 		struct task_entry		task;
 		struct wakeup_entry		wakeup;
 		struct syscall_entry		syscall;
@@ -331,6 +339,11 @@ void tracing_event_task_deactivate(struc
 				   unsigned long ip,
 				   struct task_struct *p,
 				   int cpu);
+void tracing_event_program_event(struct trace_array *tr,
+				 struct trace_array_cpu *data,
+				 unsigned long flags,
+				 unsigned long ip,
+				 ktime_t *expires, int64_t *delta);
 void tracing_event_wakeup(struct trace_array *tr,
 			  struct trace_array_cpu *data,
 			  unsigned long flags,
--- linux-2.6.26-RT.orig/kernel/trace/trace_events.c
+++ linux-2.6.26-RT/kernel/trace/trace_events.c
@@ -265,6 +265,34 @@ event_hrtimer_callback(ktime_t *time)
 }
 
 static void
+event_program_event_callback(ktime_t *expires, int64_t *delta)
+{
+	struct trace_array *tr = events_trace;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	long disable;
+	int cpu;
+
+	if (!tracer_enabled)
+		return;
+
+	/* interrupts should be off, we are in an interrupt */
+	cpu = smp_processor_id();
+	data = tr->data[cpu];
+
+	disable = atomic_inc_return(&data->disabled);
+	if (disable != 1)
+		goto out;
+
+	local_save_flags(flags);
+	tracing_event_program_event(tr, data, flags, CALLER_ADDR1, expires, delta);
+
+ out:
+	atomic_dec(&data->disabled);
+}
+
+
+static void
 event_task_activate_callback(struct task_struct *p, int rqcpu)
 {
 	struct trace_array *tr = events_trace;
@@ -453,8 +481,17 @@ static void event_tracer_register(struct
 		goto out9;
 	}
 
+	ret = register_trace_event_program_event(event_program_event_callback);
+	if (ret) {
+		pr_info("event trace: Couldn't activate tracepoint"
+			" probe to kernel_event_program_event\n");
+		goto out10;
+	}
+
 	return;
 
+ out10:
+	unregister_trace_event_program_event(event_program_event_callback);
  out9:
 	unregister_trace_sched_wakeup_new(event_wakeup_callback);
  out8:
@@ -477,6 +514,7 @@ static void event_tracer_register(struct
 
 static void event_tracer_unregister(struct trace_array *tr)
 {
+	unregister_trace_event_program_event(event_program_event_callback);
 	unregister_trace_sched_switch(event_ctx_callback);
 	unregister_trace_sched_wakeup_new(event_wakeup_callback);
 	unregister_trace_sched_wakeup(event_wakeup_callback);

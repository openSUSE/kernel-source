Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>
Subject: [patch] nmi-driven profiling for /proc/profile
From: Ingo Molnar <mingo@elte.hu>

nmi-driven profiling for /proc/profile

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 arch/x86/kernel/crash.c   |    8 ----
 arch/x86/kernel/irq_64.c  |    2 +
 arch/x86/kernel/nmi.c     |   81 ++++++++++++++++++++++++++++++++++++++++-----
 include/asm-x86/apic.h    |    2 +
 include/linux/profile.h   |    1 +
 include/linux/sched.h     |    1 +
 kernel/profile.c          |    9 +++--
 kernel/time/tick-common.c |    1 -
 kernel/time/tick-sched.c  |    2 -
 9 files changed, 84 insertions(+), 23 deletions(-)

diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c
index 2685538..800e402 100644
--- a/arch/x86/kernel/crash.c
+++ b/arch/x86/kernel/crash.c
@@ -75,14 +75,6 @@ static int crash_nmi_callback(struct notifier_block *self,
 	return 1;
 }
 
-static void smp_send_nmi_allbutself(void)
-{
-	cpumask_t mask = cpu_online_map;
-	cpu_clear(safe_smp_processor_id(), mask);
-	if (!cpus_empty(mask))
-		send_IPI_mask(mask, NMI_VECTOR);
-}
-
 static struct notifier_block crash_nmi_nb = {
 	.notifier_call = crash_nmi_callback,
 };
diff --git a/arch/x86/kernel/irq_64.c b/arch/x86/kernel/irq_64.c
index f985282..c796c84 100644
--- a/arch/x86/kernel/irq_64.c
+++ b/arch/x86/kernel/irq_64.c
@@ -194,6 +194,8 @@ asmlinkage unsigned int do_IRQ(struct pt_regs *regs)
 	unsigned vector = ~regs->orig_ax;
 	unsigned irq;
 
+	irq_show_regs_callback(smp_processor_id(), regs);
+
 	exit_idle();
 	irq_enter();
 	irq = __get_cpu_var(vector_irq)[vector];
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index abb78a2..365b8ae 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -33,7 +33,7 @@
 #include <asm/nmi.h>
 #include <asm/proto.h>
 #include <asm/timer.h>
-
+#include <asm/mach-default/mach_ipi.h>
 #include <asm/mce.h>
 
 #include <mach_traps.h>
@@ -57,7 +57,7 @@ EXPORT_SYMBOL(nmi_watchdog);
 
 static int panic_on_timeout;
 
-static unsigned int nmi_hz = HZ;
+static unsigned int nmi_hz = 1000;
 static DEFINE_PER_CPU(short, wd_enabled);
 static int endflag __initdata;
 
@@ -153,7 +153,7 @@ int __init check_nmi_watchdog(void)
 	for_each_possible_cpu(cpu)
 		prev_nmi_count[cpu] = get_nmi_count(cpu);
 	local_irq_enable();
-	mdelay((20 * 1000) / nmi_hz); /* wait 20 ticks */
+	mdelay((100 * 1000) / nmi_hz); /* wait 100 ticks */
 
 	for_each_online_cpu(cpu) {
 		if (!per_cpu(wd_enabled, cpu))
@@ -378,6 +378,46 @@ void touch_nmi_watchdog(void)
 }
 EXPORT_SYMBOL(touch_nmi_watchdog);
 
+int nmi_show_regs[NR_CPUS];
+
+void nmi_show_all_regs(void)
+{
+	int i;
+
+	if (system_state == SYSTEM_BOOTING)
+		return;
+
+	printk(KERN_WARNING "nmi_show_all_regs(): start on CPU#%d.\n",
+		raw_smp_processor_id());
+	dump_stack();
+
+	for_each_online_cpu(i)
+		nmi_show_regs[i] = 1;
+
+	smp_send_nmi_allbutself();
+
+	for_each_online_cpu(i) {
+		while (nmi_show_regs[i] == 1)
+			barrier();
+	}
+}
+
+static DEFINE_SPINLOCK(nmi_print_lock);
+
+void irq_show_regs_callback(int cpu, struct pt_regs *regs)
+{
+	if (!nmi_show_regs[cpu])
+		return;
+
+	nmi_show_regs[cpu] = 0;
+	spin_lock(&nmi_print_lock);
+	printk(KERN_WARNING "NMI show regs on CPU#%d:\n", cpu);
+	printk(KERN_WARNING "apic_timer_irqs: %d\n",
+		per_cpu(irq_stat, cpu).apic_timer_irqs);
+	show_regs(regs);
+	spin_unlock(&nmi_print_lock);
+}
+
 notrace __kprobes int
 nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 {
@@ -391,6 +431,9 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	int cpu = smp_processor_id();
 	int rc = 0;
 
+	irq_show_regs_callback(cpu, regs);
+	 __profile_tick(CPU_PROFILING, regs);
+
 	/* check for other users first */
 	if (notify_die(DIE_NMI, "nmi", regs, reason, 2, SIGINT)
 			== NOTIFY_STOP) {
@@ -419,6 +462,8 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	if (mce_in_progress())
 		touched = 1;
 
+	irq_show_regs_callback(cpu, regs);
+	/* if the apic timer isn't firing, this cpu isn't doing much */
 	/* if the none of the timers isn't firing, this cpu isn't doing much */
 	if (!touched && __get_cpu_var(last_irq_sum) == sum) {
 		/*
@@ -426,12 +471,20 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 		 * wait a few IRQs (5 seconds) before doing the oops ...
 		 */
 		local_inc(&__get_cpu_var(alert_counter));
-		if (local_read(&__get_cpu_var(alert_counter)) == 5 * nmi_hz)
-			/*
-			 * die_nmi will return ONLY if NOTIFY_STOP happens..
-			 */
-			die_nmi("BUG: NMI Watchdog detected LOCKUP",
-				regs, panic_on_timeout);
+		if (local_read(&__get_cpu_var(alert_counter)) == 5*nmi_hz) {
+			int i;
+
+			for_each_online_cpu(i) {
+				if (i == cpu)
+					continue;
+				nmi_show_regs[i] = 1;
+				while (nmi_show_regs[i] == 1)
+					cpu_relax();
+			}
+			die_nmi("NMI Watchdog detected LOCKUP on CPU %d\n", regs,
+				panic_on_timeout);
+		}
+
 	} else {
 		__get_cpu_var(last_irq_sum) = sum;
 		local_set(&__get_cpu_var(alert_counter), 0);
@@ -531,3 +584,13 @@ void __trigger_all_cpu_backtrace(void)
 		mdelay(1);
 	}
 }
+
+void smp_send_nmi_allbutself(void)
+{
+#ifdef CONFIG_SMP
+	cpumask_t mask = cpu_online_map;
+	cpu_clear(safe_smp_processor_id(), mask);
+	if (!cpus_empty(mask))
+		send_IPI_mask(mask, NMI_VECTOR);
+#endif
+}
diff --git a/include/asm-x86/apic.h b/include/asm-x86/apic.h
index 133c998..39eed9d 100644
--- a/include/asm-x86/apic.h
+++ b/include/asm-x86/apic.h
@@ -128,4 +128,6 @@ static inline void init_apic_mappings(void) { }
 
 #endif /* !CONFIG_X86_LOCAL_APIC */
 
+extern void smp_send_nmi_allbutself(void);
+
 #endif /* __ASM_APIC_H */
diff --git a/include/linux/profile.h b/include/linux/profile.h
index 7e70872..d165708 100644
--- a/include/linux/profile.h
+++ b/include/linux/profile.h
@@ -36,6 +36,7 @@ extern int prof_on __read_mostly;
 
 /* init basic kernel profiler */
 void __init profile_init(void);
+void __profile_tick(int type, struct pt_regs *regs);
 void profile_tick(int type);
 
 /*
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 1c5936c..e7cb295 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -271,6 +271,7 @@ static inline void show_state(void)
 }
 
 extern void show_regs(struct pt_regs *);
+extern void irq_show_regs_callback(int cpu, struct pt_regs *regs);
 
 /*
  * TASK is a pointer to the task whose backtrace we want to see (or NULL for current
diff --git a/kernel/profile.c b/kernel/profile.c
index cd26bed..1c6f983 100644
--- a/kernel/profile.c
+++ b/kernel/profile.c
@@ -403,16 +403,19 @@ void profile_hits(int type, void *__pc, unsigned int nr_hits)
 #endif /* !CONFIG_SMP */
 EXPORT_SYMBOL_GPL(profile_hits);
 
-void profile_tick(int type)
+void __profile_tick(int type, struct pt_regs *regs)
 {
-	struct pt_regs *regs = get_irq_regs();
-
 	if (type == CPU_PROFILING && timer_hook)
 		timer_hook(regs);
 	if (!user_mode(regs) && cpu_isset(smp_processor_id(), prof_cpu_mask))
 		profile_hit(type, (void *)profile_pc(regs));
 }
 
+void profile_tick(int type)
+{
+	return __profile_tick(type, get_irq_regs());
+}
+
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
 #include <asm/uaccess.h>
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index df12434..d494936 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -70,7 +70,6 @@ static void tick_periodic(int cpu)
 	}
 
 	update_process_times(user_mode(get_irq_regs()));
-	profile_tick(CPU_PROFILING);
 }
 
 /*
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 39019b3..cdbee57 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -492,7 +492,6 @@ static void tick_nohz_handler(struct clock_event_device *dev)
 	}
 
 	update_process_times(user_mode(regs));
-	profile_tick(CPU_PROFILING);
 
 	/* Do not restart, when we are in the idle loop */
 	if (ts->tick_stopped)
@@ -599,7 +598,6 @@ static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)
 			ts->idle_jiffies++;
 		}
 		update_process_times(user_mode(regs));
-		profile_tick(CPU_PROFILING);
 	}
 
 	/* Do not restart, when we are in the idle loop */

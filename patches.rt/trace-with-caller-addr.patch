Subject: Linux-RT 2.6.24-rt1
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
---
 arch/x86/lib/thunk_64.S |   18 ++++++++++++++++--
 kernel/latency_trace.c  |   22 ++++++++++++++++++++++
 kernel/lockdep.c        |   16 ++++++++++++----
 3 files changed, 50 insertions(+), 6 deletions(-)

Index: linux-2.6.24-rt1/arch/x86/lib/thunk_64.S
===================================================================
--- linux-2.6.24-rt1.orig/arch/x86/lib/thunk_64.S	2008-01-25 15:06:44.000000000 -0500
+++ linux-2.6.24-rt1/arch/x86/lib/thunk_64.S	2008-01-25 15:07:15.000000000 -0500
@@ -47,8 +47,22 @@
 	thunk __up_wakeup,__up
 
 #ifdef CONFIG_TRACE_IRQFLAGS
-	thunk trace_hardirqs_on_thunk,trace_hardirqs_on
-	thunk trace_hardirqs_off_thunk,trace_hardirqs_off
+	/* put return address in rdi (arg1) */
+	.macro thunk_ra name,func
+	.globl \name
+\name:
+	CFI_STARTPROC
+	SAVE_ARGS
+	/* SAVE_ARGS pushs 9 elements */
+	/* the next element would be the rip */
+	movq 9*8(%rsp), %rdi
+	call \func
+	jmp  restore
+	CFI_ENDPROC
+	.endm
+
+	thunk_ra trace_hardirqs_on_thunk,trace_hardirqs_on_caller
+	thunk_ra trace_hardirqs_off_thunk,trace_hardirqs_off_caller
 #endif
 
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
Index: linux-2.6.24-rt1/kernel/latency_trace.c
===================================================================
--- linux-2.6.24-rt1.orig/kernel/latency_trace.c	2008-01-25 15:07:15.000000000 -0500
+++ linux-2.6.24-rt1/kernel/latency_trace.c	2008-01-25 15:07:15.000000000 -0500
@@ -1998,6 +1998,28 @@ void notrace trace_hardirqs_off(void)
 
 EXPORT_SYMBOL(trace_hardirqs_off);
 
+/* used by x86_64 thunk.S */
+void notrace trace_hardirqs_on_caller(unsigned long caller_addr)
+{
+	unsigned long flags;
+
+	local_save_flags(flags);
+
+	if (!irqs_off_preempt_count() && irqs_disabled_flags(flags))
+		__stop_critical_timing(caller_addr, 0 /* CALLER_ADDR1 */);
+}
+
+void notrace trace_hardirqs_off_caller(unsigned long caller_addr)
+{
+	unsigned long flags;
+
+	local_save_flags(flags);
+
+	if (!irqs_off_preempt_count() && irqs_disabled_flags(flags))
+		__start_critical_timing(caller_addr, 0 /* CALLER_ADDR1 */,
+					INTERRUPT_LATENCY);
+}
+
 #endif /* !CONFIG_LOCKDEP */
 
 #endif /* CONFIG_CRITICAL_IRQSOFF_TIMING */
Index: linux-2.6.24-rt1/kernel/lockdep.c
===================================================================
--- linux-2.6.24-rt1.orig/kernel/lockdep.c	2008-01-25 15:07:12.000000000 -0500
+++ linux-2.6.24-rt1/kernel/lockdep.c	2008-01-25 15:07:15.000000000 -0500
@@ -2009,7 +2009,7 @@ void early_boot_irqs_on(void)
 /*
  * Hardirqs will be enabled:
  */
-notrace void trace_hardirqs_on(void)
+notrace void trace_hardirqs_on_caller(unsigned long a0)
 {
 	struct task_struct *curr = current;
 	unsigned long ip;
@@ -2051,16 +2051,20 @@ notrace void trace_hardirqs_on(void)
 	curr->hardirq_enable_event = ++curr->irq_events;
 	debug_atomic_inc(&hardirqs_on_events);
 #ifdef CONFIG_CRITICAL_IRQSOFF_TIMING
-	time_hardirqs_on(CALLER_ADDR0, 0 /* CALLER_ADDR1 */);
+	time_hardirqs_on(a0, 0 /* CALLER_ADDR1 */);
 #endif
 }
 
+void notrace trace_hardirqs_on(void) {
+	trace_hardirqs_on_caller(CALLER_ADDR0);
+}
+
 EXPORT_SYMBOL(trace_hardirqs_on);
 
 /*
  * Hardirqs were disabled:
  */
-notrace void trace_hardirqs_off(void)
+void notrace trace_hardirqs_off_caller(unsigned long a0)
 {
 	struct task_struct *curr = current;
 
@@ -2079,12 +2083,16 @@ notrace void trace_hardirqs_off(void)
 		curr->hardirq_disable_event = ++curr->irq_events;
 		debug_atomic_inc(&hardirqs_off_events);
 #ifdef CONFIG_CRITICAL_IRQSOFF_TIMING
-		time_hardirqs_off(CALLER_ADDR0, 0 /* CALLER_ADDR1 */);
+		time_hardirqs_off(a0, 0 /* CALLER_ADDR1 */);
 #endif
 	} else
 		debug_atomic_inc(&redundant_hardirqs_off);
 }
 
+void notrace trace_hardirqs_off(void) {
+	trace_hardirqs_off_caller(CALLER_ADDR0);
+}
+
 EXPORT_SYMBOL(trace_hardirqs_off);
 
 /*

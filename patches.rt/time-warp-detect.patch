 include/linux/hrtimer.h   |    1 +
 include/linux/time.h      |    1 +
 kernel/time.c             |    2 ++
 kernel/time/ntp.c         |    2 ++
 kernel/time/timekeeping.c |   36 ++++++++++++++++++++++++++++++++++++
 5 files changed, 42 insertions(+)

Index: linux-2.6.22/include/linux/hrtimer.h
===================================================================
--- linux-2.6.22.orig/include/linux/hrtimer.h	2007-07-24 08:57:09.000000000 +0200
+++ linux-2.6.22/include/linux/hrtimer.h	2007-07-24 08:57:10.000000000 +0200
@@ -234,6 +234,7 @@ static inline ktime_t hrtimer_cb_get_tim
  * clock_was_set() is a NOP for non- high-resolution systems. The
  * time-sorted order guarantees that a timer does not expire early and
  * is expired in the next softirq when the clock was advanced.
+ * (we still call the warp-check debugging code)
  */
 static inline void clock_was_set(void) { }
 
Index: linux-2.6.22/include/linux/time.h
===================================================================
--- linux-2.6.22.orig/include/linux/time.h	2007-07-24 08:57:10.000000000 +0200
+++ linux-2.6.22/include/linux/time.h	2007-07-24 08:57:10.000000000 +0200
@@ -126,6 +126,7 @@ s64 __get_nsec_offset(void);
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 extern int timekeeping_is_continuous(void);
 extern void update_wall_time(void);
+extern void warp_check_clock_was_changed(void);
 
 /**
  * timespec_to_ns - Convert timespec to nanoseconds
Index: linux-2.6.22/kernel/time.c
===================================================================
--- linux-2.6.22.orig/kernel/time.c	2007-07-24 08:56:50.000000000 +0200
+++ linux-2.6.22/kernel/time.c	2007-07-24 08:57:10.000000000 +0200
@@ -137,6 +137,7 @@ static inline void warp_clock(void)
 	wall_to_monotonic.tv_sec -= sys_tz.tz_minuteswest * 60;
 	xtime.tv_sec += sys_tz.tz_minuteswest * 60;
 	time_interpolator_reset();
+	warp_check_clock_was_changed();
 	write_sequnlock_irq(&xtime_lock);
 	clock_was_set();
 }
@@ -351,6 +352,7 @@ int do_settimeofday (struct timespec *tv
 		time_esterror = NTP_PHASE_LIMIT;
 		time_interpolator_reset();
 	}
+	warp_check_clock_was_changed();
 	write_sequnlock_irq(&xtime_lock);
 	clock_was_set();
 	return 0;
Index: linux-2.6.22/kernel/time/ntp.c
===================================================================
--- linux-2.6.22.orig/kernel/time/ntp.c	2007-07-24 08:56:53.000000000 +0200
+++ linux-2.6.22/kernel/time/ntp.c	2007-07-24 08:57:10.000000000 +0200
@@ -123,6 +123,7 @@ void second_overflow(void)
 			 */
 			time_interpolator_update(-NSEC_PER_SEC);
 			time_state = TIME_OOP;
+			warp_check_clock_was_changed();
 			printk(KERN_NOTICE "Clock: inserting leap second "
 					"23:59:60 UTC\n");
 		}
@@ -137,6 +138,7 @@ void second_overflow(void)
 			 */
 			time_interpolator_update(NSEC_PER_SEC);
 			time_state = TIME_WAIT;
+			warp_check_clock_was_changed();
 			printk(KERN_NOTICE "Clock: deleting leap second "
 					"23:59:59 UTC\n");
 		}
Index: linux-2.6.22/kernel/time/timekeeping.c
===================================================================
--- linux-2.6.22.orig/kernel/time/timekeeping.c	2007-07-24 08:57:10.000000000 +0200
+++ linux-2.6.22/kernel/time/timekeeping.c	2007-07-24 08:57:10.000000000 +0200
@@ -98,6 +98,16 @@ cycle_t notrace usecs_to_cycles(unsigned
 	return ns2cyc(clock, (u64)usecs * 1000);
 }
 
+static DEFINE_PER_CPU(ktime_t, timestamp);
+
+void warp_check_clock_was_changed(void)
+{
+	int cpu;
+
+	for_each_online_cpu(cpu)
+		per_cpu(timestamp, cpu).tv64 = 0;
+}
+
 /**
  * __get_realtime_clock_ts - Returns the time of day in a timespec
  * @ts:		pointer to the timespec to be set
@@ -109,7 +119,12 @@ static inline void __get_realtime_clock_
 {
 	unsigned long seq;
 	s64 nsecs;
+	unsigned long flags;
+	static int once = 1;
+	ktime_t prev, now;
+	int cpu;
 
+	local_irq_save(flags);
 	do {
 		seq = read_seqbegin(&xtime_lock);
 
@@ -119,6 +134,25 @@ static inline void __get_realtime_clock_
 	} while (read_seqretry(&xtime_lock, seq));
 
 	timespec_add_ns(ts, nsecs);
+
+	now = timespec_to_ktime(*ts);
+
+	cpu = raw_smp_processor_id();
+	prev = per_cpu(timestamp, cpu);
+	per_cpu(timestamp, cpu) = now;
+
+	if (once > 0 && prev.tv64 > now.tv64) {
+		once--;
+		stop_trace();
+		user_trace_stop();
+		local_irq_restore(flags);
+
+		printk("BUG: time warp detected!\n");
+		printk("prev > now, %016Lx > %016Lx:\n", prev.tv64, now.tv64);
+		printk("= %Ld delta, on CPU#%d\n", prev.tv64 - now.tv64, cpu);
+		dump_stack();
+	} else
+		local_irq_restore(flags);
 }
 
 /**
@@ -179,6 +213,7 @@ int do_settimeofday(struct timespec *tv)
 	ntp_clear();
 
 	update_vsyscall(&xtime, clock);
+	warp_check_clock_was_changed();
 
 	write_sequnlock_irqrestore(&xtime_lock, flags);
 
@@ -314,6 +349,7 @@ static int timekeeping_resume(struct sys
 	clock->cycle_last = clocksource_read(clock);
 	clock->error = 0;
 	timekeeping_suspended = 0;
+	warp_check_clock_was_changed();
 	write_sequnlock_irqrestore(&xtime_lock, flags);
 
 	touch_softlockup_watchdog();

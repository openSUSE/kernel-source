Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
---
 arch/Kconfig                               |    5 +++
 arch/x86/Kconfig.debug                     |    1 
 arch/x86/kernel/cpu/mtrr/generic.c         |    2 -
 arch/x86/kernel/head_32.S                  |    1 
 arch/x86/kernel/i8253.c                    |    2 -
 arch/x86/kernel/i8259_32.c                 |    2 -
 arch/x86/kernel/io_apic_32.c               |    4 +--
 arch/x86/kernel/irq_32.c                   |    4 ++-
 arch/x86/kernel/microcode.c                |    2 -
 arch/x86/kernel/nmi_32.c                   |    5 +++
 arch/x86/kernel/process_32.c               |   19 ++++++++++----
 arch/x86/kernel/signal_32.c                |   14 ++++++++++
 arch/x86/kernel/smp_32.c                   |   19 ++++++++++----
 arch/x86/kernel/traps_32.c                 |   18 +++++++++++--
 arch/x86/kernel/vm86_32.c                  |    1 
 arch/x86/mm/fault.c                        |    1 
 arch/x86/mm/highmem_32.c                   |   38 ++++++++++++++++++++++-------
 arch/x86/pci/common.c                      |    2 -
 arch/x86/pci/direct.c                      |   29 ++++++++++++++--------
 arch/x86/pci/pci.h                         |    2 -
 include/asm-x86/highmem.h                  |   27 ++++++++++++++++++++
 include/asm-x86/i8253.h                    |    2 -
 include/asm-x86/mach-default/irq_vectors.h |    2 -
 include/asm-x86/mc146818rtc.h              |    2 -
 include/asm-x86/tlbflush.h                 |   22 ++++++++++++++++
 include/asm-x86/xor_32.h                   |   21 +++++++++++++---
 26 files changed, 201 insertions(+), 46 deletions(-)

Index: linux-2.6.25.4-rt2/arch/x86/Kconfig.debug
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/Kconfig.debug	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/Kconfig.debug	2008-05-19 16:55:54.000000000 -0400
@@ -84,6 +84,7 @@ config 4KSTACKS
 	bool "Use 4Kb for kernel stacks instead of 8Kb"
 	depends on DEBUG_KERNEL
 	depends on X86_32
+	default y
 	help
 	  If you say Y here the kernel will use a 4Kb stacksize for the
 	  kernel stack attached to each process/thread. This facilitates
Index: linux-2.6.25.4-rt2/arch/x86/kernel/cpu/mtrr/generic.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/cpu/mtrr/generic.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/cpu/mtrr/generic.c	2008-05-19 16:55:54.000000000 -0400
@@ -329,7 +329,7 @@ static unsigned long set_mtrr_state(void
 
 
 static unsigned long cr4 = 0;
-static DEFINE_SPINLOCK(set_atomicity_lock);
+static DEFINE_RAW_SPINLOCK(set_atomicity_lock);
 
 /*
  * Since we are disabling the cache don't allow any interrupts - they
Index: linux-2.6.25.4-rt2/arch/x86/kernel/head_32.S
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/head_32.S	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/head_32.S	2008-05-19 16:55:54.000000000 -0400
@@ -585,6 +585,7 @@ ignore_int:
 	call printk
 #endif
 	addl $(5*4),%esp
+	call dump_stack
 	popl %ds
 	popl %es
 	popl %edx
Index: linux-2.6.25.4-rt2/arch/x86/kernel/i8253.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/i8253.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/i8253.c	2008-05-19 16:55:54.000000000 -0400
@@ -15,7 +15,7 @@
 #include <asm/io.h>
 #include <asm/hpet.h>
 
-DEFINE_SPINLOCK(i8253_lock);
+DEFINE_RAW_SPINLOCK(i8253_lock);
 EXPORT_SYMBOL(i8253_lock);
 
 #ifdef CONFIG_X86_32
Index: linux-2.6.25.4-rt2/arch/x86/kernel/i8259_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/i8259_32.c	2008-05-19 16:55:34.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/i8259_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -29,7 +29,7 @@
  */
 
 static int i8259A_auto_eoi;
-DEFINE_SPINLOCK(i8259A_lock);
+DEFINE_RAW_SPINLOCK(i8259A_lock);
 static void mask_and_ack_8259A(unsigned int);
 
 static struct irq_chip i8259A_chip = {
Index: linux-2.6.25.4-rt2/arch/x86/kernel/io_apic_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/io_apic_32.c	2008-05-19 16:55:34.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/io_apic_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -55,8 +55,8 @@ atomic_t irq_mis_count;
 /* Where if anywhere is the i8259 connect in external int mode */
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
 
-static DEFINE_SPINLOCK(ioapic_lock);
-static DEFINE_SPINLOCK(vector_lock);
+static DEFINE_RAW_SPINLOCK(ioapic_lock);
+static DEFINE_RAW_SPINLOCK(vector_lock);
 
 int timer_over_8254 __initdata = 1;
 
Index: linux-2.6.25.4-rt2/arch/x86/kernel/irq_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/irq_32.c	2008-05-19 16:55:19.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/irq_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -79,6 +79,8 @@ unsigned int do_IRQ(struct pt_regs *regs
 	u32 *isp;
 #endif
 
+	irq_show_regs_callback(smp_processor_id(), regs);
+
 	if (unlikely((unsigned)irq >= NR_IRQS)) {
 		printk(KERN_EMERG "%s: cannot handle IRQ %d\n",
 					__FUNCTION__, irq);
@@ -96,7 +98,7 @@ unsigned int do_IRQ(struct pt_regs *regs
 		__asm__ __volatile__("andl %%esp,%0" :
 					"=r" (sp) : "0" (THREAD_SIZE - 1));
 		if (unlikely(sp < (sizeof(struct thread_info) + STACK_WARN))) {
-			printk("do_IRQ: stack overflow: %ld\n",
+			printk("BUG: do_IRQ: stack overflow: %ld\n",
 				sp - sizeof(struct thread_info));
 			dump_stack();
 		}
Index: linux-2.6.25.4-rt2/arch/x86/kernel/microcode.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/microcode.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/microcode.c	2008-05-19 16:55:54.000000000 -0400
@@ -117,7 +117,7 @@ MODULE_LICENSE("GPL");
 #define exttable_size(et) ((et)->count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE)
 
 /* serialize access to the physical write to MSR 0x79 */
-static DEFINE_SPINLOCK(microcode_update_lock);
+static DEFINE_RAW_SPINLOCK(microcode_update_lock);
 
 /* no concurrent ->write()s are allowed on /dev/cpu/microcode */
 static DEFINE_MUTEX(microcode_mutex);
Index: linux-2.6.25.4-rt2/arch/x86/kernel/nmi_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/nmi_32.c	2008-05-19 16:55:29.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/nmi_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -56,7 +56,12 @@ static int endflag __initdata = 0;
  */
 static __init void nmi_cpu_busy(void *data)
 {
+	/*
+	 * avoid a warning, on PREEMPT_RT this wont run in hardirq context:
+	 */
+#ifndef CONFIG_PREEMPT_RT
 	local_irq_enable_in_hardirq();
+#endif
 	/* Intentionally don't use cpu_relax here. This is
 	   to make sure that the performance counter really ticks,
 	   even if there is a simulator or similar that catches the
Index: linux-2.6.25.4-rt2/arch/x86/kernel/process_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/process_32.c	2008-05-19 16:55:39.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/process_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -343,9 +343,10 @@ void __show_registers(struct pt_regs *re
 		regs->ax, regs->bx, regs->cx, regs->dx);
 	printk("ESI: %08lx EDI: %08lx EBP: %08lx ESP: %08lx\n",
 		regs->si, regs->di, regs->bp, sp);
-	printk(" DS: %04x ES: %04x FS: %04x GS: %04x SS: %04x\n",
+	printk(" DS: %04x ES: %04x FS: %04x GS: %04x SS: %04x"
+	       " preempt:%08x\n",
 	       regs->ds & 0xffff, regs->es & 0xffff,
-	       regs->fs & 0xffff, gs, ss);
+	       regs->fs & 0xffff, gs, ss, preempt_count());
 
 	if (!all)
 		return;
@@ -417,15 +418,23 @@ void exit_thread(void)
 	if (unlikely(test_thread_flag(TIF_IO_BITMAP))) {
 		struct task_struct *tsk = current;
 		struct thread_struct *t = &tsk->thread;
-		int cpu = get_cpu();
-		struct tss_struct *tss = &per_cpu(init_tss, cpu);
+		void *io_bitmap_ptr = t->io_bitmap_ptr;
+		int cpu;
+		struct tss_struct *tss;
 
-		kfree(t->io_bitmap_ptr);
+		/*
+		 * On PREEMPT_RT we must not call kfree() with
+		 * preemption disabled, so we first zap the pointer:
+		 */
 		t->io_bitmap_ptr = NULL;
+		kfree(io_bitmap_ptr);
+
 		clear_thread_flag(TIF_IO_BITMAP);
 		/*
 		 * Careful, clear this in the TSS too:
 		 */
+		cpu = get_cpu();
+		tss = &per_cpu(init_tss, cpu);
 		memset(tss->io_bitmap, 0xff, tss->io_bitmap_max);
 		t->io_bitmap_max = 0;
 		tss->io_bitmap_owner = NULL;
Index: linux-2.6.25.4-rt2/arch/x86/kernel/signal_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/signal_32.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/signal_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -547,6 +547,13 @@ handle_signal(unsigned long sig, siginfo
 		}
 	}
 
+#ifdef CONFIG_PREEMPT_RT
+	/*
+	 * Fully-preemptible kernel does not need interrupts disabled:
+	 */
+	local_irq_enable();
+	preempt_check_resched();
+#endif
 	/*
 	 * If TF is set due to a debugger (TIF_FORCED_TF), clear the TF
 	 * flag so that register information in the sigcontext is correct.
@@ -585,6 +592,13 @@ static void do_signal(struct pt_regs *re
 	struct k_sigaction ka;
 	sigset_t *oldset;
 
+#ifdef CONFIG_PREEMPT_RT
+	/*
+	 * Fully-preemptible kernel does not need interrupts disabled:
+	 */
+	local_irq_enable();
+	preempt_check_resched();
+#endif
 	/*
 	 * We want the common case to go fast, which
 	 * is why we may in certain cases get here from
Index: linux-2.6.25.4-rt2/arch/x86/kernel/smp_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/smp_32.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/smp_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -247,7 +247,7 @@ void send_IPI_mask_sequence(cpumask_t ma
 static cpumask_t flush_cpumask;
 static struct mm_struct * flush_mm;
 static unsigned long flush_va;
-static DEFINE_SPINLOCK(tlbstate_lock);
+static DEFINE_RAW_SPINLOCK(tlbstate_lock);
 
 /*
  * We cannot call mmdrop() because we are in interrupt context,
@@ -477,10 +477,20 @@ static void native_smp_send_reschedule(i
 }
 
 /*
+ * this function sends a 'reschedule' IPI to all other CPUs.
+ * This is used when RT tasks are starving and other CPUs
+ * might be able to run them:
+ */
+void smp_send_reschedule_allbutself(void)
+{
+	send_IPI_allbutself(RESCHEDULE_VECTOR);
+}
+
+/*
  * Structure and data for smp_call_function(). This is designed to minimise
  * static memory requirements. It also looks cleaner.
  */
-static DEFINE_SPINLOCK(call_lock);
+static DEFINE_RAW_SPINLOCK(call_lock);
 
 struct call_data_struct {
 	void (*func) (void *info);
@@ -635,9 +645,8 @@ static void native_smp_send_stop(void)
 }
 
 /*
- * Reschedule call back. Nothing to do,
- * all the work is done automatically when
- * we return from the interrupt.
+ * Reschedule call back. Trigger a reschedule pass so that
+ * RT-overload balancing can pass tasks around.
  */
 void smp_reschedule_interrupt(struct pt_regs *regs)
 {
Index: linux-2.6.25.4-rt2/arch/x86/kernel/traps_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/traps_32.c	2008-05-19 16:55:30.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/traps_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -321,6 +321,12 @@ void dump_stack(void)
 
 EXPORT_SYMBOL(dump_stack);
 
+#if defined(CONFIG_DEBUG_STACKOVERFLOW) && defined(CONFIG_EVENT_TRACE)
+extern unsigned long worst_stack_left;
+#else
+# define worst_stack_left -1L
+#endif
+
 void show_registers(struct pt_regs *regs)
 {
 	int i;
@@ -429,7 +435,7 @@ void die(const char * str, struct pt_reg
 		u32 lock_owner;
 		int lock_owner_depth;
 	} die = {
-		.lock =			__RAW_SPIN_LOCK_UNLOCKED,
+		.lock =			RAW_SPIN_LOCK_UNLOCKED(die.lock),
 		.lock_owner =		-1,
 		.lock_owner_depth =	0
 	};
@@ -440,7 +446,7 @@ void die(const char * str, struct pt_reg
 	if (die.lock_owner != raw_smp_processor_id()) {
 		console_verbose();
 		raw_local_irq_save(flags);
-		__raw_spin_lock(&die.lock);
+		spin_lock(&die.lock);
 		die.lock_owner = smp_processor_id();
 		die.lock_owner_depth = 0;
 		bust_spinlocks(1);
@@ -459,7 +465,7 @@ void die(const char * str, struct pt_reg
 	bust_spinlocks(0);
 	die.lock_owner = -1;
 	add_taint(TAINT_DIE);
-	__raw_spin_unlock(&die.lock);
+	spin_unlock(&die.lock);
 	raw_local_irq_restore(flags);
 
 	if (!regs)
@@ -499,6 +505,11 @@ static void __kprobes do_trap(int trapnr
 	if (!user_mode(regs))
 		goto kernel_trap;
 
+#ifdef CONFIG_PREEMPT_RT
+	local_irq_enable();
+	preempt_check_resched();
+#endif
+
 	trap_signal: {
 		/*
 		 * We want error_code and trap_no set for userspace faults and
@@ -759,6 +770,7 @@ void __kprobes die_nmi(struct pt_regs *r
 		crash_kexec(regs);
 	}
 
+	nmi_exit();
 	do_exit(SIGSEGV);
 }
 
Index: linux-2.6.25.4-rt2/arch/x86/kernel/vm86_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/kernel/vm86_32.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/kernel/vm86_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -134,6 +134,7 @@ struct pt_regs * save_v86_state(struct k
 	local_irq_enable();
 
 	if (!current->thread.vm86_info) {
+		local_irq_disable();
 		printk("no vm86_info: BAD\n");
 		do_exit(SIGSEGV);
 	}
Index: linux-2.6.25.4-rt2/arch/x86/mm/fault.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/mm/fault.c	2008-05-19 16:55:19.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/mm/fault.c	2008-05-19 16:55:54.000000000 -0400
@@ -364,6 +364,7 @@ static int is_f00f_bug(struct pt_regs *r
 		nr = (address - idt_descr.address) >> 3;
 
 		if (nr == 6) {
+			zap_rt_locks();
 			do_invalid_op(regs, 0);
 			return 1;
 		}
Index: linux-2.6.25.4-rt2/arch/x86/mm/highmem_32.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/mm/highmem_32.c	2008-05-19 16:55:25.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/mm/highmem_32.c	2008-05-19 16:55:54.000000000 -0400
@@ -18,6 +18,27 @@ void kunmap(struct page *page)
 	kunmap_high(page);
 }
 
+void kunmap_virt(void *ptr)
+{
+	struct page *page;
+
+	if ((unsigned long)ptr < PKMAP_ADDR(0))
+		return;
+	page = pte_page(pkmap_page_table[PKMAP_NR((unsigned long)ptr)]);
+	kunmap(page);
+}
+
+struct page *kmap_to_page(void *ptr)
+{
+	struct page *page;
+
+	if ((unsigned long)ptr < PKMAP_ADDR(0))
+		return virt_to_page(ptr);
+	page = pte_page(pkmap_page_table[PKMAP_NR((unsigned long)ptr)]);
+	return page;
+}
+EXPORT_SYMBOL_GPL(kmap_to_page); /* PREEMPT_RT converts some modules to use this */
+
 static void debug_kmap_atomic_prot(enum km_type type)
 {
 #ifdef CONFIG_DEBUG_HIGHMEM
@@ -69,7 +90,7 @@ static void debug_kmap_atomic_prot(enum 
  * However when holding an atomic kmap is is not legal to sleep, so atomic
  * kmaps are appropriate for short, tight code paths only.
  */
-void *kmap_atomic_prot(struct page *page, enum km_type type, pgprot_t prot)
+void *__kmap_atomic_prot(struct page *page, enum km_type type, pgprot_t prot)
 {
 	enum fixed_addresses idx;
 	unsigned long vaddr;
@@ -91,12 +112,12 @@ void *kmap_atomic_prot(struct page *page
 	return (void *)vaddr;
 }
 
-void *kmap_atomic(struct page *page, enum km_type type)
+void *__kmap_atomic(struct page *page, enum km_type type)
 {
 	return kmap_atomic_prot(page, type, kmap_prot);
 }
 
-void kunmap_atomic(void *kvaddr, enum km_type type)
+void __kunmap_atomic(void *kvaddr, enum km_type type)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	enum fixed_addresses idx = type + KM_TYPE_NR*smp_processor_id();
@@ -123,7 +144,7 @@ void kunmap_atomic(void *kvaddr, enum km
 /* This is the same as kmap_atomic() but can map memory that doesn't
  * have a struct page associated with it.
  */
-void *kmap_atomic_pfn(unsigned long pfn, enum km_type type)
+void *__kmap_atomic_pfn(unsigned long pfn, enum km_type type)
 {
 	enum fixed_addresses idx;
 	unsigned long vaddr;
@@ -138,7 +159,7 @@ void *kmap_atomic_pfn(unsigned long pfn,
 	return (void*) vaddr;
 }
 
-struct page *kmap_atomic_to_page(void *ptr)
+struct page *__kmap_atomic_to_page(void *ptr)
 {
 	unsigned long idx, vaddr = (unsigned long)ptr;
 	pte_t *pte;
@@ -153,6 +174,7 @@ struct page *kmap_atomic_to_page(void *p
 
 EXPORT_SYMBOL(kmap);
 EXPORT_SYMBOL(kunmap);
-EXPORT_SYMBOL(kmap_atomic);
-EXPORT_SYMBOL(kunmap_atomic);
-EXPORT_SYMBOL(kmap_atomic_to_page);
+EXPORT_SYMBOL(kunmap_virt);
+EXPORT_SYMBOL(__kmap_atomic);
+EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(__kmap_atomic_to_page);
Index: linux-2.6.25.4-rt2/arch/x86/pci/common.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/pci/common.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/pci/common.c	2008-05-19 16:55:54.000000000 -0400
@@ -75,7 +75,7 @@ int pcibios_scanned;
  * This interrupt-safe spinlock protects all accesses to PCI
  * configuration space.
  */
-DEFINE_SPINLOCK(pci_config_lock);
+DEFINE_RAW_SPINLOCK(pci_config_lock);
 
 /*
  * Several buggy motherboards address only 16 devices and mirror
Index: linux-2.6.25.4-rt2/arch/x86/pci/direct.c
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/pci/direct.c	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/pci/direct.c	2008-05-19 16:55:54.000000000 -0400
@@ -220,16 +220,23 @@ static int __init pci_check_type1(void)
 	unsigned int tmp;
 	int works = 0;
 
-	local_irq_save(flags);
+	spin_lock_irqsave(&pci_config_lock, flags);
 
 	outb(0x01, 0xCFB);
 	tmp = inl(0xCF8);
 	outl(0x80000000, 0xCF8);
-	if (inl(0xCF8) == 0x80000000 && pci_sanity_check(&pci_direct_conf1)) {
-		works = 1;
+
+	if (inl(0xCF8) == 0x80000000) {
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+
+		if (pci_sanity_check(&pci_direct_conf1))
+			works = 1;
+
+		spin_lock_irqsave(&pci_config_lock, flags);
 	}
 	outl(tmp, 0xCF8);
-	local_irq_restore(flags);
+
+	spin_unlock_irqrestore(&pci_config_lock, flags);
 
 	return works;
 }
@@ -239,17 +246,19 @@ static int __init pci_check_type2(void)
 	unsigned long flags;
 	int works = 0;
 
-	local_irq_save(flags);
+	spin_lock_irqsave(&pci_config_lock, flags);
 
 	outb(0x00, 0xCFB);
 	outb(0x00, 0xCF8);
 	outb(0x00, 0xCFA);
-	if (inb(0xCF8) == 0x00 && inb(0xCFA) == 0x00 &&
-	    pci_sanity_check(&pci_direct_conf2)) {
-		works = 1;
-	}
 
-	local_irq_restore(flags);
+	if (inb(0xCF8) == 0x00 && inb(0xCFA) == 0x00) {
+		spin_unlock_irqrestore(&pci_config_lock, flags);
+
+		if (pci_sanity_check(&pci_direct_conf2))
+			works = 1;
+	} else
+		spin_unlock_irqrestore(&pci_config_lock, flags);
 
 	return works;
 }
Index: linux-2.6.25.4-rt2/arch/x86/pci/pci.h
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/x86/pci/pci.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/x86/pci/pci.h	2008-05-19 16:55:54.000000000 -0400
@@ -82,7 +82,7 @@ struct irq_routing_table {
 extern unsigned int pcibios_irq_mask;
 
 extern int pcibios_scanned;
-extern spinlock_t pci_config_lock;
+extern raw_spinlock_t pci_config_lock;
 
 extern int (*pcibios_enable_irq)(struct pci_dev *dev);
 extern void (*pcibios_disable_irq)(struct pci_dev *dev);
Index: linux-2.6.25.4-rt2/include/asm-x86/highmem.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/highmem.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/highmem.h	2008-05-19 16:55:54.000000000 -0400
@@ -61,6 +61,16 @@ extern void *kmap_high(struct page *page
 extern void kunmap_high(struct page *page);
 
 void *kmap(struct page *page);
+extern void kunmap_virt(void *ptr);
+extern struct page *kmap_to_page(void *ptr);
+void kunmap(struct page *page);
+
+void *__kmap_atomic_prot(struct page *page, enum km_type type, pgprot_t prot);
+void *__kmap_atomic(struct page *page, enum km_type type);
+void __kunmap_atomic(void *kvaddr, enum km_type type);
+void *__kmap_atomic_pfn(unsigned long pfn, enum km_type type);
+struct page *__kmap_atomic_to_page(void *ptr);
+
 void kunmap(struct page *page);
 void *kmap_atomic_prot(struct page *page, enum km_type type, pgprot_t prot);
 void *kmap_atomic(struct page *page, enum km_type type);
@@ -74,6 +84,23 @@ struct page *kmap_atomic_to_page(void *p
 
 #define flush_cache_kmaps()	do { } while (0)
 
+/*
+ * on PREEMPT_RT kmap_atomic() is a wrapper that uses kmap():
+ */
+#ifdef CONFIG_PREEMPT_RT
+# define kmap_atomic_prot(page, type, prot)	kmap(page)
+# define kmap_atomic(page, type)	kmap(page)
+# define kmap_atomic_pfn(pfn, type)	kmap(pfn_to_page(pfn))
+# define kunmap_atomic(kvaddr, type)	kunmap_virt(kvaddr)
+# define kmap_atomic_to_page(kvaddr)	kmap_to_page(kvaddr)
+#else
+# define kmap_atomic_prot(page, type, prot)	__kmap_atomic_prot(page, type, prot)
+# define kmap_atomic(page, type)	__kmap_atomic(page, type)
+# define kmap_atomic_pfn(pfn, type)	__kmap_atomic_pfn(pfn, type)
+# define kunmap_atomic(kvaddr, type)	__kunmap_atomic(kvaddr, type)
+# define kmap_atomic_to_page(kvaddr)	__kmap_atomic_to_page(kvaddr)
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_HIGHMEM_H */
Index: linux-2.6.25.4-rt2/include/asm-x86/i8253.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/i8253.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/i8253.h	2008-05-19 16:55:54.000000000 -0400
@@ -6,7 +6,7 @@
 #define PIT_CH0			0x40
 #define PIT_CH2			0x42
 
-extern spinlock_t i8253_lock;
+extern raw_spinlock_t i8253_lock;
 
 extern struct clock_event_device *global_clock_event;
 
Index: linux-2.6.25.4-rt2/include/asm-x86/mach-default/irq_vectors.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/mach-default/irq_vectors.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/mach-default/irq_vectors.h	2008-05-19 16:55:54.000000000 -0400
@@ -63,7 +63,7 @@
  * levels. (0x80 is the syscall vector)
  */
 #define FIRST_DEVICE_VECTOR	0x31
-#define FIRST_SYSTEM_VECTOR	0xef
+#define FIRST_SYSTEM_VECTOR	0xee
 
 #define TIMER_IRQ 0
 
Index: linux-2.6.25.4-rt2/include/asm-x86/mc146818rtc.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/mc146818rtc.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/mc146818rtc.h	2008-05-19 16:55:54.000000000 -0400
@@ -72,7 +72,7 @@ static inline unsigned char current_lock
 		lock_cmos(reg)
 #define lock_cmos_suffix(reg) \
 		unlock_cmos();			\
-		local_irq_restore(cmos_flags);	\
+		local_irq_restore(cmos_flags); \
 	} while (0)
 #else
 #define lock_cmos_prefix(reg) do {} while (0)
Index: linux-2.6.25.4-rt2/include/asm-x86/tlbflush.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/tlbflush.h	2008-05-19 16:55:50.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/tlbflush.h	2008-05-19 16:55:54.000000000 -0400
@@ -7,6 +7,21 @@
 #include <asm/processor.h>
 #include <asm/system.h>
 
+/*
+ * TLB-flush needs to be nonpreemptible on PREEMPT_RT due to the
+ * following complex race scenario:
+ *
+ * if the current task is lazy-TLB and does a TLB flush and
+ * gets preempted after the movl %%r3, %0 but before the
+ * movl %0, %%cr3 then its ->active_mm might change and it will
+ * install the wrong cr3 when it switches back. This is not a
+ * problem for the lazy-TLB task itself, but if the next task it
+ * switches to has an ->mm that is also the lazy-TLB task's
+ * new ->active_mm, then the scheduler will assume that cr3 is
+ * the new one, while we overwrote it with the old one. The result
+ * is the wrong cr3 in the new (non-lazy-TLB) task, which typically
+ * causes an infinite pagefault upon the next userspace access.
+ */
 #ifdef CONFIG_PARAVIRT
 #include <asm/paravirt.h>
 #else
@@ -89,6 +104,13 @@ static inline void __flush_tlb_one(unsig
 
 static inline void flush_tlb_mm(struct mm_struct *mm)
 {
+	/*
+	 * This is safe on PREEMPT_RT because if we preempt
+	 * right after the check but before the __flush_tlb(),
+	 * and if ->active_mm changes, then we might miss a
+	 * TLB flush, but that TLB flush happened already when
+	 * ->active_mm was changed:
+	 */
 	if (mm == current->active_mm)
 		__flush_tlb();
 }
Index: linux-2.6.25.4-rt2/include/asm-x86/xor_32.h
===================================================================
--- linux-2.6.25.4-rt2.orig/include/asm-x86/xor_32.h	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/include/asm-x86/xor_32.h	2008-05-19 16:55:54.000000000 -0400
@@ -860,7 +860,21 @@ static struct xor_block_template xor_blo
 #include <asm-generic/xor.h>
 
 #undef XOR_TRY_TEMPLATES
-#define XOR_TRY_TEMPLATES				\
+/*
+ * MMX/SSE ops disable preemption for long periods of time,
+ * so on PREEMPT_RT use the register-based ops only:
+ */
+#ifdef CONFIG_PREEMPT_RT
+# define XOR_TRY_TEMPLATES				\
+	do {						\
+		xor_speed(&xor_block_8regs);		\
+		xor_speed(&xor_block_8regs_p);		\
+		xor_speed(&xor_block_32regs);		\
+		xor_speed(&xor_block_32regs_p);		\
+	} while (0)
+# define XOR_SELECT_TEMPLATE(FASTEST) (FASTEST)
+#else
+# define XOR_TRY_TEMPLATES				\
 	do {						\
 		xor_speed(&xor_block_8regs);		\
 		xor_speed(&xor_block_8regs_p);		\
@@ -873,9 +887,10 @@ static struct xor_block_template xor_blo
 	                xor_speed(&xor_block_p5_mmx);	\
 	        }					\
 	} while (0)
-
 /* We force the use of the SSE xor block because it can write around L2.
    We may also be able to load into the L1 only depending on how the cpu
    deals with a load to a line that is being prefetched.  */
-#define XOR_SELECT_TEMPLATE(FASTEST) \
+# define XOR_SELECT_TEMPLATE(FASTEST) \
 	(cpu_has_xmm ? &xor_block_pIII_sse : FASTEST)
+#endif
+
Index: linux-2.6.25.4-rt2/arch/Kconfig
===================================================================
--- linux-2.6.25.4-rt2.orig/arch/Kconfig	2008-05-19 16:55:00.000000000 -0400
+++ linux-2.6.25.4-rt2/arch/Kconfig	2008-05-19 16:55:54.000000000 -0400
@@ -16,6 +16,11 @@ config OPROFILE
 config HAVE_OPROFILE
 	def_bool n
 
+config PROFILE_NMI
+	bool
+	depends on OPROFILE
+	default y
+
 config KPROBES
 	bool "Kprobes"
 	depends on KALLSYMS && MODULES

Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Tony Jones <tonyj@suse.de>
hard IRQ thread: dont do start_irq_thread from init_hardirqs

There are two ways that start_irq_thread() can be called; either
as a part of setup_irq() for flags !IRQF_NODELAY, or as a blanket
walk over NR_IRQS for status !IRQ_NODELAY from init_hardirqs().
The printk timestamps will confirm that either may get there 1st.

The problem is that if the latter gets there 1st, the IRQF_NODELAY
may not have propagated from flags to an IRQ_NODELAY in status, and
you end up with an IRQ-0 thread for the timer IRQ, even though it
should be IRQF_NODELAY and have no IRQ-0 thread.  The threaded IRQ-0
eventually blows up when tick_periodic() does the following:

        update_process_times(user_mode(get_irq_regs()));

and this results in a trace that looks like the attached.  I've
simply stubbed out the seemingly needless init_hardirqs() to be
just a barrier so it checks on proper ordering and now the boot time
failures are gone.

[    0.062407] BUG: unable to handle kernel NULL pointer dereference at 00000030
[    0.062990] IP: [<c0230385>] tick_periodic+0x63/0x79
[    0.062990] *pde = 00000000
[    0.062990] Oops: 0000 [#1] PREEMPT
[    0.062990]
[    0.062990] Pid: 3, comm: IRQ-0 Not tainted (2.6.27-rc8-26rt9 #3)
[    0.062990] EIP: 0060:[<c0230385>] EFLAGS: 00010246 CPU: 0
[    0.062990] EIP is at tick_periodic+0x63/0x79
[    0.062990] Call Trace:
[    0.062990]  [<c02303b3>] ? tick_handle_periodic+0x18/0x5d
[    0.062990]  [<c0205525>] ? timer_interrupt+0x19/0x20
[    0.062990]  [<c0238b3d>] ? handle_IRQ_event+0x45/0xb6
[    0.062990]  [<c0239386>] ? do_irqd+0x0/0x270
[    0.062990]  [<c0238f6d>] ? thread_simple_irq+0x5a/0x93

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/irq/manage.c |   12 +++---------
 1 file changed, 3 insertions(+), 9 deletions(-)

Index: linux-2.6.27-RT/kernel/irq/manage.c
===================================================================
--- linux-2.6.27-RT.orig/kernel/irq/manage.c
+++ linux-2.6.27-RT/kernel/irq/manage.c
@@ -909,9 +909,11 @@ static int ok_to_create_irq_threads;
 
 static int start_irq_thread(int irq, struct irq_desc *desc)
 {
-	if (desc->thread || !ok_to_create_irq_threads)
+	if (desc->thread)
 		return 0;
 
+	BUG_ON(!ok_to_create_irq_threads);
+
 	desc->thread = kthread_create(do_irqd, desc, "IRQ-%d", irq);
 	if (!desc->thread) {
 		printk(KERN_ERR "irqd: could not create IRQ thread %d!\n", irq);
@@ -931,15 +933,7 @@ static int start_irq_thread(int irq, str
 
 void __init init_hardirqs(void)
 {
-	int i;
 	ok_to_create_irq_threads = 1;
-
-	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc_t *desc = irq_desc + i;
-
-		if (desc->action && !(desc->status & IRQ_NODELAY))
-			start_irq_thread(i, desc);
-	}
 }
 
 #else

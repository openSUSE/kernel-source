Subject: Linux-RT 2.6.27-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
From h-shimamoto@ct.jp.nec.com Thu May 15 10:14:48 2008
Date: Mon, 28 Apr 2008 11:16:31 -0700
From: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
To: Ingo Molnar <mingo@elte.hu>, Steven Rostedt <rostedt@goodmis.org>,
     Thomas Gleixner <tglx@linutronix.de>
Cc: linux-kernel@vger.kernel.org, linux-rt-users@vger.kernel.org
Subject: [PATCH -rt 2/4] x86: return true for NMI handled

From: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>

NMI for show_regs causes unknown NMI when nmi_watchdog is local APIC mode.
Because lapic_wd_event() will fail due to still running perfctr.
If NMI is for show_regs, nmi_watchdog_tick() should return 1.

On x86_32, call irq_show_regs_callback() is moved to top of the
nmi_watchdog_tick() same as x86_64.

Signed-off-by: Hiroshi Shimamoto <h-shimamoto@ct.jp.nec.com>
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index a7ce001..a1e5ae8 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -400,10 +400,10 @@ void nmi_show_all_regs(void)
 
 static DEFINE_RAW_SPINLOCK(nmi_print_lock);
 
-notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
+notrace int irq_show_regs_callback(int cpu, struct pt_regs *regs)
 {
 	if (!nmi_show_regs[cpu])
-		return;
+		return 0;
 
 	nmi_show_regs[cpu] = 0;
 	spin_lock(&nmi_print_lock);
@@ -412,6 +412,7 @@ notrace void irq_show_regs_callback(int cpu, struct pt_regs *regs)
 		per_cpu(irq_stat, cpu).apic_timer_irqs);
 	show_regs(regs);
 	spin_unlock(&nmi_print_lock);
+	return 1;
 }
 
 notrace __kprobes int
@@ -425,8 +426,9 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	unsigned int sum;
 	int touched = 0;
 	int cpu = smp_processor_id();
-	int rc = 0;
+	int rc;
 
+	rc = irq_show_regs_callback(cpu, regs);
 	irq_show_regs_callback(cpu, regs);
 	 __profile_tick(CPU_PROFILING, regs);
 
@@ -458,7 +460,6 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	if (mce_in_progress())
 		touched = 1;
 
-	irq_show_regs_callback(cpu, regs);
 	/* if the apic timer isn't firing, this cpu isn't doing much */
 	/* if the none of the timers isn't firing, this cpu isn't doing much */
 	if (!touched && __get_cpu_var(last_irq_sum) == sum) {
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5b4c284..eae9d64 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -319,7 +319,7 @@ static inline void show_state(void)
 }
 
 extern void show_regs(struct pt_regs *);
-extern void irq_show_regs_callback(int cpu, struct pt_regs *regs);
+extern int irq_show_regs_callback(int cpu, struct pt_regs *regs);
 
 /*
  * TASK is a pointer to the task whose backtrace we want to see (or NULL for current

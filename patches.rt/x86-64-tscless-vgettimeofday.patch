Subject: [patch] x86_64 GTOD: offer scalable vgettimeofday
From: Ingo Molnar <mingo@elte.hu>

offer scalable vgettimeofday independently of whether the TSC
is synchronous or not. Off by default.

this patch also fixes an SMP bug in sys_vtime(): we should read
__vsyscall_gtod_data.wall_time_tv.tv_sec only once.

Signed-off-by: Ingo Molnar <mingo@elte.hu>
---
 arch/x86_64/kernel/vsyscall.c |   21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

Index: linux-2.6.22/arch/x86_64/kernel/vsyscall.c
===================================================================
--- linux-2.6.22.orig/arch/x86_64/kernel/vsyscall.c	2007-07-24 08:57:20.000000000 +0200
+++ linux-2.6.22/arch/x86_64/kernel/vsyscall.c	2007-07-24 08:57:40.000000000 +0200
@@ -68,7 +68,7 @@ struct vsyscall_gtod_data_t {
 	struct timezone sys_tz;
 	struct { /* extract of a clocksource struct */
 		cycle_t (*vread)(void);
-		cycle_t	cycle_last;
+		cycle_t	cycle_last, cycle_accumulated;
 		cycle_t	mask;
 		u32	mult;
 		u32	shift;
@@ -132,6 +132,25 @@ static __always_inline void do_vgettimeo
 	unsigned seq;
 	unsigned long mult, shift, nsec;
 	cycle_t (*vread)(void);
+
+	if (likely(__vsyscall_gtod_data.sysctl_enabled == 2)) {
+		struct timeval tmp;
+
+		do {
+			barrier();
+			tv->tv_sec = __vsyscall_gtod_data.wall_time_sec;
+			tv->tv_usec = __vsyscall_gtod_data.wall_time_nsec;
+			barrier();
+			tmp.tv_sec = __vsyscall_gtod_data.wall_time_sec;
+			tmp.tv_usec = __vsyscall_gtod_data.wall_time_nsec;
+
+		} while (tmp.tv_usec != tv->tv_usec ||
+					tmp.tv_sec != tv->tv_sec);
+
+		tv->tv_usec /= NSEC_PER_USEC;
+		return;
+	}
+
 	do {
 		seq = read_seqbegin(&__vsyscall_gtod_data.lock);
 

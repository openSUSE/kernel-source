Subject: Linux-RT 2.6.25.4-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Add syscall tracing in event trace.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 include/asm-x86/unistd_32.h   |    2 
 kernel/trace/trace.c          |  104 ++++++++++++++++++++++++++++++++++++++++++
 kernel/trace/trace.h          |   40 +++++++++++++++-
 kernel/trace/trace_events.c   |   92 +++++++++++++++++++++++++++++++++++++
 kernel/trace/trace_selftest.c |    2 
 5 files changed, 238 insertions(+), 2 deletions(-)

Index: linux-2.6.25.4-rt1/kernel/trace/trace_events.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/trace/trace_events.c	2008-05-17 08:26:55.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/trace/trace_events.c	2008-05-17 08:26:56.000000000 -0400
@@ -101,6 +101,98 @@ void trace_event_wakeup(struct task_stru
 
 #define getarg(arg, ap) arg = va_arg(ap, typeof(arg));
 
+/* HACK */
+void notrace
+sys_call(unsigned long nr, unsigned long p1, unsigned long p2, unsigned long p3)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+
+	tracing_event_syscall(tr, data, flags, ip, nr, p1, p2, p3);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+void notrace
+sys_ia32_call(unsigned long nr, unsigned long p1, unsigned long p2,
+	      unsigned long p3)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+	tracing_event_syscall(tr, data, flags, ip, nr | 0x80000000, p1, p2, p3);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+#endif
+
+void notrace
+sys_ret(unsigned long ret)
+{
+	struct trace_array *tr;
+	struct trace_array_cpu *data;
+	unsigned long flags;
+	unsigned long ip;
+	int cpu;
+
+	if (!ftrace_events_enabled || !events_trace)
+		return;
+
+	tr = events_trace;
+	local_irq_save(flags);
+	cpu = raw_smp_processor_id();
+	data = tr->data[cpu];
+
+	atomic_inc(&data->disabled);
+	if (atomic_read(&data->disabled) != 1)
+		goto out;
+
+	ip = CALLER_ADDR0;
+	tracing_event_sysret(tr, data, flags, ip, ret);
+
+ out:
+	atomic_dec(&data->disabled);
+	local_irq_restore(flags);
+}
+
 void ftrace_record_event(enum ftrace_event_enum event, ...)
 {
 	struct trace_array *tr = events_trace;
Index: linux-2.6.25.4-rt1/kernel/trace/trace.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/trace/trace.c	2008-05-17 08:26:55.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/trace/trace.c	2008-05-17 08:26:56.000000000 -0400
@@ -31,6 +31,9 @@
 
 #include <linux/stacktrace.h>
 
+#include <asm/asm-offsets.h>
+#include <asm/unistd.h>
+
 #include "trace.h"
 
 unsigned long __read_mostly	tracing_max_latency = (cycle_t)ULONG_MAX;
@@ -1114,6 +1117,42 @@ void tracing_event_wakeup(struct trace_a
 	entry->wakeup.curr_prio	= curr_prio;
 }
 
+void tracing_event_syscall(struct trace_array *tr,
+			   struct trace_array_cpu *data,
+			   unsigned long flags,
+			   unsigned long ip,
+			   unsigned long nr,
+			   unsigned long p1,
+			   unsigned long p2,
+			   unsigned long p3)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type			= TRACE_SYSCALL;
+	entry->syscall.ip		= ip;
+	entry->syscall.nr		= nr;
+	entry->syscall.p1		= p1;
+	entry->syscall.p2		= p2;
+	entry->syscall.p3		= p3;
+}
+
+void tracing_event_sysret(struct trace_array *tr,
+			  struct trace_array_cpu *data,
+			  unsigned long flags,
+			  unsigned long ip,
+			  unsigned long ret)
+{
+	struct trace_entry *entry;
+
+	entry = tracing_get_trace_entry(tr, data);
+	tracing_generic_entry_update(entry, flags);
+	entry->type			= TRACE_SYSRET;
+	entry->sysret.ip		= ip;
+	entry->sysret.ret		= ret;
+}
+
 enum trace_file_type {
 	TRACE_FILE_LAT_FMT	= 1,
 };
@@ -1363,6 +1402,13 @@ seq_print_ip_sym(struct trace_seq *s, un
 	return ret;
 }
 
+extern unsigned long sys_call_table[NR_syscalls];
+
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+extern unsigned long ia32_sys_call_table[], ia32_syscall_end[];
+# define IA32_NR_syscalls (ia32_syscall_end - ia32_sys_call_table)
+#endif
+
 static void print_lat_help_header(struct seq_file *m)
 {
 	seq_puts(m, "#                _------=> CPU#            \n");
@@ -1517,6 +1563,7 @@ print_lat_fmt(struct trace_iterator *ite
 	unsigned long abs_usecs;
 	unsigned long rel_usecs;
 	char *comm;
+	unsigned long nr;
 	int S, T;
 	int i;
 	unsigned state;
@@ -1622,6 +1669,34 @@ print_lat_fmt(struct trace_iterator *ite
 			   comm, entry->wakeup.pid,
 			   entry->wakeup.prio, entry->wakeup.curr_prio);
 		break;
+	case TRACE_SYSCALL:
+		seq_print_ip_sym(s, entry->syscall.ip, sym_flags);
+		nr = entry->syscall.nr;
+		trace_seq_putc(s, ' ');
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+		if (nr & 0x80000000) {
+			nr &= ~0x80000000;
+			if (nr < IA32_NR_syscalls)
+				seq_print_ip_sym(s, ia32_sys_call_table[nr], 0);
+			else
+				trace_seq_printf(s, "<badsys(%lu)>", nr);
+		} else
+#endif
+			if (nr < NR_syscalls)
+				seq_print_ip_sym(s, sys_call_table[nr], 0);
+			else
+				trace_seq_printf(s, "<badsys(%lu)>", nr);
+
+		trace_seq_printf(s, " (%lx %lx %lx)\n",
+			   entry->syscall.p1,
+			   entry->syscall.p2,
+			   entry->syscall.p3);
+		break;
+	case TRACE_SYSRET:
+		seq_print_ip_sym(s, entry->sysret.ip, sym_flags);
+		trace_seq_printf(s, " < (%ld)\n",
+			   entry->sysret.ret);
+		break;
 	default:
 		trace_seq_printf(s, "Unknown type %d\n", entry->type);
 	}
@@ -1637,6 +1712,7 @@ static int print_trace_fmt(struct trace_
 	unsigned long long t;
 	unsigned long secs;
 	char *comm;
+	long nr;
 	int ret;
 	int S, T;
 	int i;
@@ -1763,6 +1839,34 @@ static int print_trace_fmt(struct trace_
 			   comm, entry->wakeup.pid,
 			   entry->wakeup.prio, entry->wakeup.curr_prio);
 		break;
+	case TRACE_SYSCALL:
+		seq_print_ip_sym(s, entry->syscall.ip, sym_flags);
+		nr = entry->syscall.nr;
+		trace_seq_putc(s, ' ');
+#if defined(CONFIG_COMPAT) && defined(CONFIG_X86)
+		if (nr & 0x80000000) {
+			nr &= ~0x80000000;
+			if (nr < IA32_NR_syscalls)
+				seq_print_ip_sym(s, ia32_sys_call_table[nr], 0);
+			else
+				trace_seq_printf(s, "<badsys(%lu)>", nr);
+		} else
+#endif
+			if (nr < NR_syscalls)
+				seq_print_ip_sym(s, sys_call_table[nr], 0);
+			else
+				trace_seq_printf(s, "<badsys(%lu)>", nr);
+
+		trace_seq_printf(s, " (%lx %lx %lx)\n",
+			   entry->syscall.p1,
+			   entry->syscall.p2,
+			   entry->syscall.p3);
+		break;
+	case TRACE_SYSRET:
+		seq_print_ip_sym(s, entry->sysret.ip, sym_flags);
+		trace_seq_printf(s, "< (%ld)\n",
+			   entry->sysret.ret);
+		break;
 	default:
 		trace_seq_printf(s, "Unknown type %d\n", entry->type);
 	}
Index: linux-2.6.25.4-rt1/kernel/trace/trace.h
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/trace/trace.h	2008-05-17 08:26:55.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/trace/trace.h	2008-05-17 08:26:56.000000000 -0400
@@ -23,6 +23,8 @@ enum trace_type {
 	TRACE_TIMESTAMP,
 	TRACE_TASK,
 	TRACE_WAKEUP,
+	TRACE_SYSCALL,
+	TRACE_SYSRET,
 
 	__TRACE_LAST_TYPE
 };
@@ -105,6 +107,19 @@ struct wakeup_entry {
 	unsigned		curr_prio;
 };
 
+struct syscall_entry {
+	unsigned long		ip;
+	unsigned long		nr;
+	unsigned long		p1;
+	unsigned long		p2;
+	unsigned long		p3;
+};
+
+struct sysret_entry {
+	unsigned long		ip;
+	unsigned long		ret;
+};
+
 /*
  * The trace entry - the most basic unit of tracing. This is what
  * is printed in the end as a single line in the trace output, such as:
@@ -131,6 +146,8 @@ struct trace_entry {
 		struct timestamp_entry		timestamp;
 		struct task_entry		task;
 		struct wakeup_entry		wakeup;
+		struct syscall_entry		syscall;
+		struct sysret_entry		sysret;
 	};
 };
 
@@ -307,12 +324,31 @@ void trace_function(struct trace_array *
 		    unsigned long ip,
 		    unsigned long parent_ip,
 		    unsigned long flags);
+void tracing_event_syscall(struct trace_array *tr,
+			   struct trace_array_cpu *data,
+			   unsigned long flags,
+			   unsigned long ip,
+			   unsigned long nr,
+			   unsigned long p1,
+			   unsigned long p2,
+			   unsigned long p3);
+void tracing_event_sysret(struct trace_array *tr,
+			  struct trace_array_cpu *data,
+			  unsigned long flags,
+			  unsigned long ip,
+			  unsigned long ret);
 
-void tracing_start_function_trace(void);
-void tracing_stop_function_trace(void);
 int register_tracer(struct tracer *type);
 void unregister_tracer(struct tracer *type);
 
+#ifdef CONFIG_FTRACE
+void tracing_start_function_trace(void);
+void tracing_stop_function_trace(void);
+#else
+# define tracing_start_function_trace()	do { } while (0)
+# define tracing_stop_function_trace()	do { } while (0)
+#endif
+
 extern unsigned long nsecs_to_usecs(unsigned long nsecs);
 
 extern unsigned long tracing_max_latency;
Index: linux-2.6.25.4-rt1/kernel/trace/trace_selftest.c
===================================================================
--- linux-2.6.25.4-rt1.orig/kernel/trace/trace_selftest.c	2008-05-17 08:26:55.000000000 -0400
+++ linux-2.6.25.4-rt1/kernel/trace/trace_selftest.c	2008-05-17 08:26:56.000000000 -0400
@@ -17,6 +17,8 @@ static inline int trace_valid_entry(stru
 	case TRACE_TIMESTAMP:
 	case TRACE_TASK:
 	case TRACE_WAKEUP:
+	case TRACE_SYSCALL:
+	case TRACE_SYSRET:
 		return 1;
 	}
 	return 0;
Index: linux-2.6.25.4-rt1/include/asm-x86/unistd_32.h
===================================================================
--- linux-2.6.25.4-rt1.orig/include/asm-x86/unistd_32.h	2008-05-17 08:26:44.000000000 -0400
+++ linux-2.6.25.4-rt1/include/asm-x86/unistd_32.h	2008-05-17 08:26:56.000000000 -0400
@@ -333,6 +333,8 @@
 #define __NR_timerfd_settime	325
 #define __NR_timerfd_gettime	326
 
+#define NR_syscalls 327
+
 #ifdef __KERNEL__
 
 #define __ARCH_WANT_IPC_PARSE_VERSION

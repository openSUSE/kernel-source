---
 net/ipv4/multipath_wrandom.c |    2 ++
 security/selinux/avc.c       |    9 +++++++++
 security/selinux/netif.c     |    2 ++
 3 files changed, 13 insertions(+)

Index: linux-2.6.22/net/ipv4/multipath_wrandom.c
===================================================================
--- linux-2.6.22.orig/net/ipv4/multipath_wrandom.c	2007-07-24 08:56:07.000000000 +0200
+++ linux-2.6.22/net/ipv4/multipath_wrandom.c	2007-07-24 08:57:35.000000000 +0200
@@ -289,6 +289,7 @@ static void wrandom_flush(void)
 	for (i = 0; i < MULTIPATH_STATE_SIZE; ++i) {
 		struct multipath_route *r;
 
+		rcu_read_lock();
 		spin_lock_bh(&state[i].lock);
 		list_for_each_entry_rcu(r, &state[i].head, list) {
 			struct multipath_dest *d;
@@ -303,6 +304,7 @@ static void wrandom_flush(void)
 		}
 
 		spin_unlock_bh(&state[i].lock);
+		rcu_read_unlock();
 	}
 }
 
Index: linux-2.6.22/security/selinux/avc.c
===================================================================
--- linux-2.6.22.orig/security/selinux/avc.c	2007-07-24 08:56:07.000000000 +0200
+++ linux-2.6.22/security/selinux/avc.c	2007-07-24 08:57:35.000000000 +0200
@@ -312,6 +312,7 @@ static inline int avc_reclaim_node(void)
 		if (!spin_trylock_irqsave(&avc_cache.slots_lock[hvalue], flags))
 			continue;
 
+		rcu_read_lock();
 		list_for_each_entry(node, &avc_cache.slots[hvalue], list) {
 			if (atomic_dec_and_test(&node->ae.used)) {
 				/* Recently Unused */
@@ -319,11 +320,13 @@ static inline int avc_reclaim_node(void)
 				avc_cache_stats_incr(reclaims);
 				ecx++;
 				if (ecx >= AVC_CACHE_RECLAIM) {
+					rcu_read_unlock();
 					spin_unlock_irqrestore(&avc_cache.slots_lock[hvalue], flags);
 					goto out;
 				}
 			}
 		}
+		rcu_read_unlock();
 		spin_unlock_irqrestore(&avc_cache.slots_lock[hvalue], flags);
 	}
 out:
@@ -806,8 +809,14 @@ int avc_ss_reset(u32 seqno)
 
 	for (i = 0; i < AVC_CACHE_SLOTS; i++) {
 		spin_lock_irqsave(&avc_cache.slots_lock[i], flag);
+		/*
+		 * On -rt the outer spinlock does not prevent RCU
+		 * from being performed:
+		 */
+		rcu_read_lock();
 		list_for_each_entry(node, &avc_cache.slots[i], list)
 			avc_node_delete(node);
+		rcu_read_unlock();
 		spin_unlock_irqrestore(&avc_cache.slots_lock[i], flag);
 	}
 
Index: linux-2.6.22/security/selinux/netif.c
===================================================================
--- linux-2.6.22.orig/security/selinux/netif.c	2007-07-24 08:56:07.000000000 +0200
+++ linux-2.6.22/security/selinux/netif.c	2007-07-24 08:57:35.000000000 +0200
@@ -209,6 +209,7 @@ static void sel_netif_flush(void)
 {
 	int idx;
 
+	rcu_read_lock();
 	spin_lock_bh(&sel_netif_lock);
 	for (idx = 0; idx < SEL_NETIF_HASH_SIZE; idx++) {
 		struct sel_netif *netif;
@@ -217,6 +218,7 @@ static void sel_netif_flush(void)
 			sel_netif_destroy(netif);
 	}
 	spin_unlock_bh(&sel_netif_lock);
+	rcu_read_unlock();
 }
 
 static int sel_netif_avc_callback(u32 event, u32 ssid, u32 tsid,

Subject: Linux-RT 2.6.26-RT
From: http://www.kernel.org/pub/linux/kernel/projects/rt/
Acked-by: Sven-Thorsten Dietrich <sdietrich@suse.de>
Track preempt disable nesting

This code was largly influenced by work from Ingo Molnar.

Signed-off-by: Steven Rostedt <srostedt@redhat.com>
---
 arch/arm/kernel/traps.c      |    1 +
 arch/x86/kernel/traps_32.c   |    1 +
 arch/x86/kernel/traps_64.c   |    1 +
 include/linux/preempt.h      |    3 ++-
 include/linux/sched.h        |   13 +++++++++++++
 kernel/sched.c               |   17 +++++++++++++++--
 kernel/trace/Kconfig         |    8 ++++++++
 kernel/trace/Makefile        |    2 ++
 kernel/trace/preempt-trace.c |   30 ++++++++++++++++++++++++++++++
 9 files changed, 73 insertions(+), 3 deletions(-)

Index: linux-2.6.26/arch/arm/kernel/traps.c
===================================================================
--- linux-2.6.26.orig/arch/arm/kernel/traps.c
+++ linux-2.6.26/arch/arm/kernel/traps.c
@@ -357,6 +357,7 @@ asmlinkage void do_unexp_fiq (struct pt_
 {
 	printk("Hmm.  Unexpected FIQ received, but trying to continue\n");
 	printk("You may have a hardware problem...\n");
+	print_preempt_trace(current);
 }
 
 /*
Index: linux-2.6.26/arch/x86/kernel/traps_32.c
===================================================================
--- linux-2.6.26.orig/arch/x86/kernel/traps_32.c
+++ linux-2.6.26/arch/x86/kernel/traps_32.c
@@ -261,6 +261,7 @@ show_trace_log_lvl(struct task_struct *t
 {
 	dump_trace(task, regs, stack, bp, &print_trace_ops, log_lvl);
 	printk("%s =======================\n", log_lvl);
+	print_preempt_trace(task);
 }
 
 void show_trace(struct task_struct *task, struct pt_regs *regs,
Index: linux-2.6.26/arch/x86/kernel/traps_64.c
===================================================================
--- linux-2.6.26.orig/arch/x86/kernel/traps_64.c
+++ linux-2.6.26/arch/x86/kernel/traps_64.c
@@ -389,6 +389,7 @@ show_trace(struct task_struct *tsk, stru
 	printk("\nCall Trace:\n");
 	dump_trace(tsk, regs, stack, bp, &print_trace_ops, NULL);
 	printk("\n");
+	print_preempt_trace(tsk);
 }
 
 static void
Index: linux-2.6.26/include/linux/preempt.h
===================================================================
--- linux-2.6.26.orig/include/linux/preempt.h
+++ linux-2.6.26/include/linux/preempt.h
@@ -10,7 +10,8 @@
 #include <linux/linkage.h>
 #include <linux/list.h>
 
-#if defined(CONFIG_DEBUG_PREEMPT) || defined(CONFIG_PREEMPT_TRACER)
+#if defined(CONFIG_DEBUG_PREEMPT) || defined(CONFIG_PREEMPT_TRACER) || \
+	defined(CONFIG_PREEMPT_TRACE)
   extern void add_preempt_count(int val);
   extern void sub_preempt_count(int val);
 #else
Index: linux-2.6.26/include/linux/sched.h
===================================================================
--- linux-2.6.26.orig/include/linux/sched.h
+++ linux-2.6.26/include/linux/sched.h
@@ -1261,6 +1261,13 @@ struct task_struct {
 	unsigned int lockdep_recursion;
 #endif
 
+#define MAX_PREEMPT_TRACE 25
+
+#ifdef CONFIG_PREEMPT_TRACE
+	unsigned long preempt_trace_eip[MAX_PREEMPT_TRACE];
+	unsigned long preempt_trace_parent_eip[MAX_PREEMPT_TRACE];
+#endif
+
 /* journalling filesystem info */
 	void *journal_info;
 
@@ -2241,6 +2248,12 @@ static inline void inc_syscw(struct task
 }
 #endif
 
+#ifdef CONFIG_PREEMPT_TRACE
+void print_preempt_trace(struct task_struct *tsk);
+#else
+# define print_preempt_trace(tsk) do { } while (0)
+#endif
+
 #ifdef CONFIG_SMP
 void migration_init(void);
 #else
Index: linux-2.6.26/kernel/sched.c
===================================================================
--- linux-2.6.26.orig/kernel/sched.c
+++ linux-2.6.26/kernel/sched.c
@@ -4064,7 +4064,8 @@ void scheduler_tick(void)
 }
 
 #if defined(CONFIG_PREEMPT) && (defined(CONFIG_DEBUG_PREEMPT) || \
-				defined(CONFIG_PREEMPT_TRACER))
+				defined(CONFIG_PREEMPT_TRACER) || \
+				defined(CONFIG_PREEMPT_TRACE))
 
 static inline unsigned long get_parent_ip(unsigned long addr)
 {
@@ -4078,6 +4079,9 @@ static inline unsigned long get_parent_i
 
 void __kprobes add_preempt_count(int val)
 {
+	unsigned long eip = CALLER_ADDR0;
+	unsigned long parent_eip = get_parent_ip(CALLER_ADDR1);
+
 #ifdef CONFIG_DEBUG_PREEMPT
 	/*
 	 * Underflow?
@@ -4086,6 +4090,15 @@ void __kprobes add_preempt_count(int val
 		return;
 #endif
 	preempt_count() += val;
+#ifdef CONFIG_PREEMPT_TRACE
+	if (val <= 10) {
+		unsigned int idx = preempt_count() & PREEMPT_MASK;
+		if (idx < MAX_PREEMPT_TRACE) {
+			current->preempt_trace_eip[idx] = eip;
+			current->preempt_trace_parent_eip[idx] = parent_eip;
+		}
+	}
+#endif
 #ifdef CONFIG_DEBUG_PREEMPT
 	/*
 	 * Spinlock count overflowing soon?
@@ -4094,7 +4107,7 @@ void __kprobes add_preempt_count(int val
 				PREEMPT_MASK - 10);
 #endif
 	if (preempt_count() == val)
-		trace_preempt_off(CALLER_ADDR0, get_parent_ip(CALLER_ADDR1));
+		trace_preempt_off(eip, parent_eip);
 }
 EXPORT_SYMBOL(add_preempt_count);
 
Index: linux-2.6.26/kernel/trace/Kconfig
===================================================================
--- linux-2.6.26.orig/kernel/trace/Kconfig
+++ linux-2.6.26/kernel/trace/Kconfig
@@ -155,3 +155,11 @@ config WAKEUP_LATENCY_HIST
 	help
 	  This option uses the infrastructure of the wakeup tracer
 	  to create a histogram of latencies.
+
+config PREEMPT_TRACE
+	bool "Keep a record of preempt disabled spots"
+	depends on DEBUG_KERNEL
+	depends on PREEMPT
+	select TRACING
+	help
+	  Keeps a record of the last 25 preempt disabled locations.
Index: linux-2.6.26/kernel/trace/Makefile
===================================================================
--- linux-2.6.26.orig/kernel/trace/Makefile
+++ linux-2.6.26/kernel/trace/Makefile
@@ -24,4 +24,6 @@ obj-$(CONFIG_INTERRUPT_OFF_HIST) += trac
 obj-$(CONFIG_PREEMPT_OFF_HIST) += trace_hist.o
 obj-$(CONFIG_WAKEUP_LATENCY_HIST) += trace_hist.o
 
+obj-$(CONFIG_PREEMPT_TRACE) += preempt-trace.o
+
 libftrace-y := ftrace.o
Index: linux-2.6.26/kernel/trace/preempt-trace.c
===================================================================
--- /dev/null
+++ linux-2.6.26/kernel/trace/preempt-trace.c
@@ -0,0 +1,30 @@
+#include <linux/sched.h>
+#include <linux/hardirq.h>
+#include <linux/kallsyms.h>
+
+void print_preempt_trace(struct task_struct *task)
+{
+	unsigned int count;
+	unsigned int i, lim;
+
+	if (!task)
+		task = current;
+
+	count = task_thread_info(task)->preempt_count;
+	lim = count & PREEMPT_MASK;
+
+	if (lim >= MAX_PREEMPT_TRACE)
+		lim = MAX_PREEMPT_TRACE-1;
+	printk("---------------------------\n");
+	printk("| preempt count: %08x ]\n", count);
+	printk("| %d-level deep critical section nesting:\n", lim);
+	printk("----------------------------------------\n");
+	for (i = 1; i <= lim; i++) {
+		printk(".. [<%08lx>] .... ", task->preempt_trace_eip[i]);
+		print_symbol("%s\n", task->preempt_trace_eip[i]);
+		printk(".....[<%08lx>] ..   ( <= ",
+				task->preempt_trace_parent_eip[i]);
+		print_symbol("%s)\n", task->preempt_trace_parent_eip[i]);
+	}
+	printk("\n");
+}

From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 3.8
Patch-mainline: 3.8

 This patch contains the differences between 3.7 and 3.8.

Automatically created from "patch-3.8" by xen-port-patches.py
Acked-by: jbeulich@suse.com

--- head.orig/Documentation/filesystems/proc.txt	2013-03-05 12:23:59.000000000 +0100
+++ head/Documentation/filesystems/proc.txt	2013-01-11 14:57:37.000000000 +0100
@@ -463,6 +463,7 @@ manner. The codes are the following:
     mm  - mixed map area
     hg  - huge page advise flag
     nh  - no-huge page advise flag
+    fo  - area has foreign pages
     mg  - mergable advise flag
 
 Note that there is no guarantee that every flag and associated mnemonic will
--- head.orig/arch/x86/Kconfig	2013-03-05 12:41:13.000000000 +0100
+++ head/arch/x86/Kconfig	2013-03-05 12:41:30.000000000 +0100
@@ -1743,7 +1743,7 @@ config HOTPLUG_CPU
 config BOOTPARAM_HOTPLUG_CPU0
 	bool "Set default setting of cpu0_hotpluggable"
 	default n
-	depends on HOTPLUG_CPU
+	depends on HOTPLUG_CPU && !XEN
 	---help---
 	  Set whether default state of cpu0_hotpluggable is on or off.
 
@@ -1772,7 +1772,7 @@ config BOOTPARAM_HOTPLUG_CPU0
 config DEBUG_HOTPLUG_CPU0
 	def_bool n
 	prompt "Debug CPU0 hotplug"
-	depends on HOTPLUG_CPU
+	depends on HOTPLUG_CPU && !XEN
 	---help---
 	  Enabling this option offlines CPU0 (if CPU0 can be offlined) as
 	  soon as possible and boots up userspace with CPU0 offlined. User
--- head.orig/arch/x86/ia32/ia32entry-xen.S	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/ia32/ia32entry-xen.S	2013-01-09 15:32:56.000000000 +0100
@@ -354,14 +354,18 @@ GLOBAL(\label)
 
 	PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi
 	PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi
-	PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx
 	PTREGSCALL stub32_execve, compat_sys_execve, %rcx
 	PTREGSCALL stub32_fork, sys_fork, %rdi
-	PTREGSCALL stub32_clone, sys32_clone, %rdx
 	PTREGSCALL stub32_vfork, sys_vfork, %rdi
 	PTREGSCALL stub32_iopl, sys_iopl, %rsi
 
 	ALIGN
+GLOBAL(stub32_clone)
+	leaq sys_clone(%rip),%rax
+	mov	%r8, %rcx
+	jmp  ia32_ptregs_common
+
+	ALIGN
 ia32_ptregs_common:
 	popq %r11
 	CFI_ENDPROC
--- head.orig/arch/x86/include/asm/ptrace.h	2013-01-08 12:01:03.000000000 +0100
+++ head/arch/x86/include/asm/ptrace.h	2013-01-11 17:10:17.000000000 +0100
@@ -142,6 +142,7 @@ static inline bool user_64bit_mode(struc
 #endif
 }
 
+#ifndef CONFIG_XEN
 #define current_user_stack_pointer()	this_cpu_read(old_rsp)
 /* ia32 vs. x32 difference */
 #define compat_user_stack_pointer()	\
@@ -149,6 +150,7 @@ static inline bool user_64bit_mode(struc
 	 ? current_pt_regs()->sp 	\
 	 : this_cpu_read(old_rsp))
 #endif
+#endif
 
 #ifdef CONFIG_X86_32
 extern unsigned long kernel_stack_pointer(struct pt_regs *regs);
--- head.orig/arch/x86/include/mach-xen/asm/fixmap.h	2012-02-09 12:32:50.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/fixmap.h	2013-01-09 15:32:33.000000000 +0100
@@ -19,6 +19,9 @@
 #include <asm/acpi.h>
 #include <asm/apicdef.h>
 #include <asm/page.h>
+#ifdef CONFIG_PARAVIRT_CLOCK
+#include <asm/pvclock.h>
+#endif
 #ifdef CONFIG_X86_32
 #include <linux/threads.h>
 #include <asm/kmap_types.h>
@@ -81,6 +84,10 @@ enum fixed_addresses {
 	VVAR_PAGE,
 	VSYSCALL_HPET,
 #endif
+#ifdef CONFIG_PARAVIRT_CLOCK
+	PVCLOCK_FIXMAP_BEGIN,
+	PVCLOCK_FIXMAP_END = PVCLOCK_FIXMAP_BEGIN+PVCLOCK_VSYSCALL_NR_PAGES-1,
+#endif
 	FIX_DBGP_BASE,
 	FIX_EARLYCON_MEM_BASE,
 #ifdef CONFIG_PROVIDE_OHCI1394_DMA_INIT
--- head.orig/arch/x86/include/mach-xen/asm/pci.h	2012-02-09 12:32:50.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/pci.h	2013-01-09 15:32:33.000000000 +0100
@@ -177,4 +177,16 @@ cpumask_of_pcibus(const struct pci_bus *
 }
 #endif
 
+struct pci_setup_rom {
+	struct setup_data data;
+	uint16_t vendor;
+	uint16_t devid;
+	uint64_t pcilen;
+	unsigned long segment;
+	unsigned long bus;
+	unsigned long device;
+	unsigned long function;
+	uint8_t romdata[0];
+};
+
 #endif /* _ASM_X86_PCI_H */
--- head.orig/arch/x86/include/mach-xen/asm/pgtable.h	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/pgtable.h	2013-02-20 11:39:48.000000000 +0100
@@ -138,6 +138,11 @@ static inline unsigned long pmd_pfn(pmd_
 	return (pmd_val(pmd) & PTE_PFN_MASK) >> PAGE_SHIFT;
 }
 
+static inline unsigned long pud_pfn(pud_t pud)
+{
+	return (pud_val(pud) & PTE_PFN_MASK) >> PAGE_SHIFT;
+}
+
 static inline int pmd_large(pmd_t pte)
 {
 	return pmd_flags(pte) & _PAGE_PSE;
@@ -402,7 +407,14 @@ static inline int pte_same(pte_t a, pte_
 
 static inline int pte_present(pte_t a)
 {
-	return pte_flags(a) & (_PAGE_PRESENT | _PAGE_PROTNONE);
+	return pte_flags(a) & (_PAGE_PRESENT | _PAGE_PROTNONE |
+			       _PAGE_NUMA);
+}
+
+#define pte_accessible pte_accessible
+static inline int pte_accessible(pte_t a)
+{
+	return pte_flags(a) & _PAGE_PRESENT;
 }
 
 static inline int pte_hidden(pte_t pte)
@@ -423,7 +435,8 @@ static inline int pmd_present(pmd_t pmd)
 	 * the _PAGE_PSE flag will remain set at all times while the
 	 * _PAGE_PRESENT bit is clear).
 	 */
-	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);
+	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE |
+				 _PAGE_NUMA);
 #endif
 }
 
@@ -483,6 +496,11 @@ static inline pte_t *pte_offset_kernel(p
 
 static inline int pmd_bad(pmd_t pmd)
 {
+#ifdef CONFIG_NUMA_BALANCING
+	/* pmd_numa check */
+	if ((pmd_flags(pmd) & (_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA)
+		return 0;
+#endif
 #if CONFIG_XEN_COMPAT <= 0x030002
 	return (pmd_flags(pmd) & ~_PAGE_USER & ~_PAGE_PRESENT)
 	       != (_KERNPG_TABLE & ~_PAGE_PRESENT);
--- head.orig/arch/x86/include/mach-xen/asm/pgtable_types.h	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/pgtable_types.h	2013-01-09 15:32:33.000000000 +0100
@@ -64,6 +64,26 @@
 #define _PAGE_FILE	(_AT(pteval_t, 1) << _PAGE_BIT_FILE)
 #define _PAGE_PROTNONE	(_AT(pteval_t, 1) << _PAGE_BIT_PROTNONE)
 
+/*
+ * _PAGE_NUMA indicates that this page will trigger a numa hinting
+ * minor page fault to gather numa placement statistics (see
+ * pte_numa()). The bit picked (8) is within the range between
+ * _PAGE_FILE (6) and _PAGE_PROTNONE (8) bits. Therefore, it doesn't
+ * require changes to the swp entry format because that bit is always
+ * zero when the pte is not present.
+ *
+ * The bit picked must be always zero when the pmd is present and not
+ * present, so that we don't lose information when we set it while
+ * atomically clearing the present bit.
+ *
+ * Because we shared the same bit (8) with _PAGE_PROTNONE this can be
+ * interpreted as _PAGE_NUMA only in places that _PAGE_PROTNONE
+ * couldn't reach, like handle_mm_fault() (see access_error in
+ * arch/x86/mm/fault.c, the vma protection must not be PROT_NONE for
+ * handle_mm_fault() to be invoked).
+ */
+#define _PAGE_NUMA	_PAGE_PROTNONE
+
 #ifndef __ASSEMBLY__
 #if defined(CONFIG_X86_64) && CONFIG_XEN_COMPAT <= 0x030002
 extern unsigned int __kernel_page_user;
--- head.orig/arch/x86/include/mach-xen/asm/processor.h	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/processor.h	2013-01-09 15:32:33.000000000 +0100
@@ -191,8 +191,6 @@ static inline int hlt_works(int cpu)
 
 extern void cpu_detect(struct cpuinfo_x86 *c);
 
-extern struct pt_regs *idle_regs(struct pt_regs *);
-
 extern void early_cpu_init(void);
 extern void identify_boot_cpu(void);
 extern void identify_secondary_cpu(struct cpuinfo_x86 *);
@@ -200,7 +198,7 @@ extern void print_cpu_info(struct cpuinf
 void print_cpu_msr(struct cpuinfo_x86 *);
 extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
 extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
-extern unsigned short num_cache_leaves;
+extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);
 
 extern void detect_extended_topology(struct cpuinfo_x86 *c);
 extern void detect_ht(struct cpuinfo_x86 *c);
@@ -673,18 +671,29 @@ static inline void sync_core(void)
 {
 	int tmp;
 
-#if defined(CONFIG_M386) || defined(CONFIG_M486)
-	if (boot_cpu_data.x86 < 5)
-		/* There is no speculative execution.
-		 * jmp is a barrier to prefetching. */
-		asm volatile("jmp 1f\n1:\n" ::: "memory");
-	else
-#endif
-		/* cpuid is a barrier to speculative execution.
-		 * Prefetched instructions are automatically
-		 * invalidated when modified. */
-		asm volatile("cpuid" : "=a" (tmp) : "0" (1)
-			     : "ebx", "ecx", "edx", "memory");
+#ifdef CONFIG_M486
+	/*
+	 * Do a CPUID if available, otherwise do a jump.  The jump
+	 * can conveniently enough be the jump around CPUID.
+	 */
+	asm volatile("cmpl %2,%1\n\t"
+		     "jl 1f\n\t"
+		     "cpuid\n"
+		     "1:"
+		     : "=a" (tmp)
+		     : "rm" (boot_cpu_data.cpuid_level), "ri" (0), "0" (1)
+		     : "ebx", "ecx", "edx", "memory");
+#else
+	/*
+	 * CPUID is a barrier to speculative execution.
+	 * Prefetched instructions are automatically
+	 * invalidated when modified.
+	 */
+	asm volatile("cpuid"
+		     : "=a" (tmp)
+		     : "0" (1)
+		     : "ebx", "ecx", "edx", "memory");
+#endif
 }
 
 static inline void __monitor(const void *eax, unsigned long ecx,
--- head.orig/arch/x86/include/mach-xen/asm/smp.h	2012-08-20 14:37:06.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/smp.h	2013-01-09 15:32:33.000000000 +0100
@@ -166,6 +166,7 @@ void wbinvd_on_cpu(int cpu);
 int wbinvd_on_all_cpus(void);
 void x86_idle_thread_init(unsigned int cpu, struct task_struct *idle);
 
+void smp_store_boot_cpu_info(void);
 void smp_store_cpu_info(int id);
 #define cpu_physical_id(cpu)	per_cpu(x86_cpu_to_apicid, cpu)
 
--- head.orig/arch/x86/kernel/apic/io_apic-xen.c	2012-10-31 11:57:31.000000000 +0100
+++ head/arch/x86/kernel/apic/io_apic-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -251,11 +251,11 @@ int __init arch_early_irq_init(void)
 		zalloc_cpumask_var_node(&cfg[i].old_domain, GFP_KERNEL, node);
 		/*
 		 * For legacy IRQ's, start with assigning irq0 to irq15 to
-		 * IRQ0_VECTOR to IRQ15_VECTOR on cpu 0.
+		 * IRQ0_VECTOR to IRQ15_VECTOR for all cpu's.
 		 */
 		if (i < legacy_pic->nr_legacy_irqs) {
 			cfg[i].vector = IRQ0_VECTOR + i;
-			cpumask_set_cpu(0, cfg[i].domain);
+			cpumask_setall(cfg[i].domain);
 		}
 	}
 
@@ -1196,7 +1196,8 @@ __assign_irq_vector(int irq, struct irq_
 			 * allocation for the members that are not used anymore.
 			 */
 			cpumask_andnot(cfg->old_domain, cfg->domain, tmp_mask);
-			cfg->move_in_progress = 1;
+			cfg->move_in_progress =
+			   cpumask_intersects(cfg->old_domain, cpu_online_mask);
 			cpumask_and(cfg->domain, cfg->domain, tmp_mask);
 			break;
 		}
@@ -1231,8 +1232,9 @@ next:
 		current_vector = vector;
 		current_offset = offset;
 		if (cfg->vector) {
-			cfg->move_in_progress = 1;
 			cpumask_copy(cfg->old_domain, cfg->domain);
+			cfg->move_in_progress =
+			   cpumask_intersects(cfg->old_domain, cpu_online_mask);
 		}
 		for_each_cpu_and(new_cpu, tmp_mask, cpu_online_mask)
 			per_cpu(vector_irq, new_cpu)[vector] = irq;
@@ -1300,12 +1302,6 @@ void __setup_vector_irq(int cpu)
 		cfg = irq_get_chip_data(irq);
 		if (!cfg)
 			continue;
-		/*
-		 * If it is a legacy IRQ handled by the legacy PIC, this cpu
-		 * will be part of the irq_cfg's domain.
-		 */
-		if (irq < legacy_pic->nr_legacy_irqs && !IO_APIC_IRQ(irq))
-			cpumask_set_cpu(cpu, cfg->domain);
 
 		if (!cpumask_test_cpu(cpu, cfg->domain))
 			continue;
@@ -1419,16 +1415,6 @@ static void setup_ioapic_irq(unsigned in
 	if (!IO_APIC_IRQ(irq))
 		return;
 
-	/*
-	 * For legacy irqs, cfg->domain starts with cpu 0. Now that IO-APIC
-	 * can handle this irq and the apic driver is finialized at this point,
-	 * update the cfg->domain.
-	 */
-	if (irq < legacy_pic->nr_legacy_irqs &&
-	    cpumask_equal(cfg->domain, cpumask_of(0)))
-		apic->vector_allocation_domain(0, cfg->domain,
-					       apic->target_cpus());
-
 	if (assign_irq_vector(irq, cfg, apic->target_cpus()))
 		return;
 
@@ -2278,9 +2264,11 @@ static int ioapic_retrigger_irq(struct i
 {
 	struct irq_cfg *cfg = data->chip_data;
 	unsigned long flags;
+	int cpu;
 
 	raw_spin_lock_irqsave(&vector_lock, flags);
-	apic->send_IPI_mask(cpumask_of(cpumask_first(cfg->domain)), cfg->vector);
+	cpu = cpumask_first_and(cfg->domain, cpu_online_mask);
+	apic->send_IPI_mask(cpumask_of(cpu), cfg->vector);
 	raw_spin_unlock_irqrestore(&vector_lock, flags);
 
 	return 1;
@@ -3419,8 +3407,9 @@ int arch_setup_hpet_msi(unsigned int irq
 	int ret;
 
 	if (irq_remapping_enabled) {
-		if (!setup_hpet_msi_remapped(irq, id))
-			return -1;
+		ret = setup_hpet_msi_remapped(irq, id);
+		if (ret)
+			return ret;
 	}
 
 	ret = msi_compose_msg(NULL, irq, &msg, id);
--- head.orig/arch/x86/kernel/cpu/common-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/cpu/common-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -1262,15 +1262,6 @@ DEFINE_PER_CPU(struct task_struct *, fpu
 DEFINE_PER_CPU_ALIGNED(struct stack_canary, stack_canary);
 #endif
 
-/* Make sure %fs and %gs are initialized properly in idle threads */
-struct pt_regs * __cpuinit idle_regs(struct pt_regs *regs)
-{
-	memset(regs, 0, sizeof(struct pt_regs));
-	regs->fs = __KERNEL_PERCPU;
-	regs->gs = __KERNEL_STACK_CANARY;
-
-	return regs;
-}
 #endif	/* CONFIG_X86_64 */
 
 /*
@@ -1333,7 +1324,7 @@ void __cpuinit cpu_init(void)
 #endif
 
 #ifdef CONFIG_NUMA
-	if (cpu != 0 && this_cpu_read(numa_node) == 0 &&
+	if (this_cpu_read(numa_node) == 0 &&
 	    early_cpu_to_node(cpu) != NUMA_NO_NODE)
 		set_numa_node(early_cpu_to_node(cpu));
 #endif
@@ -1368,8 +1359,7 @@ void __cpuinit cpu_init(void)
 
 	x86_configure_nx();
 #ifdef CONFIG_X86_LOCAL_APIC
-	if (cpu != 0)
-		enable_x2apic();
+	enable_x2apic();
 #endif
 
 #ifndef CONFIG_X86_NO_TSS
--- head.orig/arch/x86/kernel/entry_32-xen.S	2013-01-30 12:03:02.000000000 +0100
+++ head/arch/x86/kernel/entry_32-xen.S	2013-01-09 15:32:33.000000000 +0100
@@ -802,30 +802,11 @@ ENTRY(ptregs_##name) ; \
 ENDPROC(ptregs_##name)
 
 PTREGSCALL1(iopl)
-PTREGSCALL0(fork)
-PTREGSCALL0(vfork)
-PTREGSCALL2(sigaltstack)
 PTREGSCALL0(sigreturn)
 PTREGSCALL0(rt_sigreturn)
 PTREGSCALL2(vm86)
 PTREGSCALL1(vm86old)
 
-/* Clone is an oddball.  The 4th arg is in %edi */
-ENTRY(ptregs_clone)
-	CFI_STARTPROC
-	leal 4(%esp),%eax
-	pushl_cfi %eax
-	pushl_cfi PT_EDI(%eax)
-	movl PT_EDX(%eax),%ecx
-	movl PT_ECX(%eax),%edx
-	movl PT_EBX(%eax),%eax
-	call sys_clone
-	addl $8,%esp
-	CFI_ADJUST_CFA_OFFSET -8
-	ret
-	CFI_ENDPROC
-ENDPROC(ptregs_clone)
-
 #ifndef CONFIG_XEN
 .macro FIXUP_ESPFIX_STACK
 /*
--- head.orig/arch/x86/kernel/entry_64-xen.S	2012-10-30 14:02:02.000000000 +0100
+++ head/arch/x86/kernel/entry_64-xen.S	2013-01-09 15:32:33.000000000 +0100
@@ -59,7 +59,7 @@
 #include <asm/ftrace.h>
 #include <asm/percpu.h>
 #include <asm/asm.h>
-#include <asm/rcu.h>
+#include <asm/context_tracking.h>
 #include <asm/smap.h>
 #include <linux/err.h>
 #include <xen/interface/xen.h>
@@ -861,10 +861,25 @@ ENTRY(\label)
 END(\label)
 	.endm
 
-	PTREGSCALL stub_clone, sys_clone, %r8
-	PTREGSCALL stub_fork, sys_fork, %rdi
-	PTREGSCALL stub_vfork, sys_vfork, %rdi
-	PTREGSCALL stub_sigaltstack, sys_sigaltstack, %rdx
+	.macro FORK_LIKE func
+ENTRY(stub_\func)
+	CFI_STARTPROC
+	popq	%r11			/* save return address */
+	PARTIAL_FRAME 0
+	SAVE_REST
+	pushq	%r11			/* put it back on stack */
+	FIXUP_TOP_OF_STACK %r11, 8
+	DEFAULT_FRAME 0 8		/* offset 8: return address */
+	call sys_\func
+	RESTORE_TOP_OF_STACK %r11, 8
+	ret $REST_SKIP		/* pop extended registers */
+	CFI_ENDPROC
+END(stub_\func)
+	.endm
+
+	FORK_LIKE  clone
+	FORK_LIKE  fork
+	FORK_LIKE  vfork
 	PTREGSCALL stub_iopl, sys_iopl, %rsi
 
 ENTRY(ptregscall_common)
@@ -913,8 +928,6 @@ ENTRY(stub_rt_sigreturn)
 END(stub_rt_sigreturn)
 
 #ifdef CONFIG_X86_X32_ABI
-	PTREGSCALL stub_x32_sigaltstack, sys32_sigaltstack, %rdx
-
 ENTRY(stub_x32_rt_sigreturn)
 	CFI_STARTPROC
 	addq $8, %rsp
--- head.orig/arch/x86/kernel/pci-dma-xen.c	2012-08-20 14:37:06.000000000 +0200
+++ head/arch/x86/kernel/pci-dma-xen.c	2013-02-06 15:28:03.000000000 +0100
@@ -55,7 +55,7 @@ struct device x86_dma_fallback_dev = {
 EXPORT_SYMBOL(x86_dma_fallback_dev);
 
 /* Number of entries preallocated for DMA-API debugging */
-#define PREALLOC_DMA_DEBUG_ENTRIES       32768
+#define PREALLOC_DMA_DEBUG_ENTRIES       65536
 
 int dma_set_mask(struct device *dev, u64 mask)
 {
@@ -350,7 +350,7 @@ rootfs_initcall(pci_iommu_init);
 #ifdef CONFIG_PCI
 /* Many VIA bridges seem to corrupt data for DAC. Disable it here */
 
-static __devinit void via_no_dac(struct pci_dev *dev)
+static void via_no_dac(struct pci_dev *dev)
 {
 	if (forbid_dac == 0) {
 		dev_info(&dev->dev, "disabling DAC on VIA PCI bridge\n");
--- head.orig/arch/x86/kernel/process-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/process-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -251,36 +251,6 @@ void __switch_to_xtra(struct task_struct
 	propagate_user_return_notify(prev_p, next_p);
 }
 
-int sys_fork(struct pt_regs *regs)
-{
-	return do_fork(SIGCHLD, regs->sp, regs, 0, NULL, NULL);
-}
-
-/*
- * This is trivial, and on the face of it looks like it
- * could equally well be done in user mode.
- *
- * Not so, for quite unobvious reasons - register pressure.
- * In user mode vfork() cannot have a stack frame, and if
- * done by calling the "clone()" system call directly, you
- * do not have enough call-clobbered registers to hold all
- * the information you need.
- */
-int sys_vfork(struct pt_regs *regs)
-{
-	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->sp, regs, 0,
-		       NULL, NULL);
-}
-
-long
-sys_clone(unsigned long clone_flags, unsigned long newsp,
-	  void __user *parent_tid, void __user *child_tid, struct pt_regs *regs)
-{
-	if (!newsp)
-		newsp = regs->sp;
-	return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);
-}
-
 /*
  * Idle related variables and functions
  */
--- head.orig/arch/x86/kernel/process_32-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/process_32-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -131,8 +131,7 @@ void release_thread(struct task_struct *
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long sp,
-	unsigned long arg,
-	struct task_struct *p, struct pt_regs *regs)
+	unsigned long arg, struct task_struct *p)
 {
 	struct pt_regs *childregs = task_pt_regs(p);
 	struct task_struct *tsk;
@@ -141,7 +140,7 @@ int copy_thread(unsigned long clone_flag
 	p->thread.sp = (unsigned long) childregs;
 	p->thread.sp0 = (unsigned long) (childregs+1);
 
-	if (unlikely(!regs)) {
+	if (unlikely(p->flags & PF_KTHREAD)) {
 		/* kernel thread */
 		memset(childregs, 0, sizeof(struct pt_regs));
 		p->thread.ip = (unsigned long) ret_from_kernel_thread;
@@ -159,12 +158,13 @@ int copy_thread(unsigned long clone_flag
 		memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
 		return 0;
 	}
-	*childregs = *regs;
+	*childregs = *current_pt_regs();
 	childregs->ax = 0;
-	childregs->sp = sp;
+	if (sp)
+		childregs->sp = sp;
 
 	p->thread.ip = (unsigned long) ret_from_fork;
-	task_user_gs(p) = get_user_gs(regs);
+	task_user_gs(p) = get_user_gs(current_pt_regs());
 
 	p->fpu_counter = 0;
 	p->thread.io_bitmap_ptr = NULL;
--- head.orig/arch/x86/kernel/process_64-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/process_64-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -155,8 +155,7 @@ static inline u32 read_32bit_tls(struct 
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long sp,
-		unsigned long arg,
-	struct task_struct *p, struct pt_regs *regs)
+		unsigned long arg, struct task_struct *p)
 {
 	int err;
 	struct pt_regs *childregs;
@@ -177,7 +176,7 @@ int copy_thread(unsigned long clone_flag
 	savesegment(ds, p->thread.ds);
 	memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
 
-	if (unlikely(!regs)) {
+	if (unlikely(p->flags & PF_KTHREAD)) {
 		/* kernel thread */
 		memset(childregs, 0, sizeof(struct pt_regs));
 		childregs->sp = (unsigned long)childregs;
@@ -189,10 +188,11 @@ int copy_thread(unsigned long clone_flag
 		childregs->flags = X86_EFLAGS_IF | X86_EFLAGS_BIT1;
 		return 0;
 	}
-	*childregs = *regs;
+	*childregs = *current_pt_regs();
 
 	childregs->ax = 0;
-	childregs->sp = sp;
+	if (sp)
+		childregs->sp = sp;
 
 	err = -ENOMEM;
 	memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
--- head.orig/arch/x86/kernel/setup-xen.c	2012-10-31 11:57:31.000000000 +0100
+++ head/arch/x86/kernel/setup-xen.c	2013-02-06 15:28:03.000000000 +0100
@@ -173,12 +173,8 @@ int default_check_phys_apicid_present(in
 }
 #endif
 
-#ifndef CONFIG_DEBUG_BOOT_PARAMS
-struct boot_params __initdata boot_params;
-#else
 struct boot_params boot_params;
 #endif
-#endif
 
 /*
  * Machine setup..
@@ -684,6 +680,83 @@ static __init void reserve_ibft_region(v
 #ifndef CONFIG_XEN
 static unsigned reserve_low = CONFIG_X86_RESERVE_LOW << 10;
 
+static bool __init snb_gfx_workaround_needed(void)
+{
+#ifdef CONFIG_PCI
+	int i;
+	u16 vendor, devid;
+	static const __initconst u16 snb_ids[] = {
+		0x0102,
+		0x0112,
+		0x0122,
+		0x0106,
+		0x0116,
+		0x0126,
+		0x010a,
+	};
+
+	/* Assume no if something weird is going on with PCI */
+	if (!early_pci_allowed())
+		return false;
+
+	vendor = read_pci_config_16(0, 2, 0, PCI_VENDOR_ID);
+	if (vendor != 0x8086)
+		return false;
+
+	devid = read_pci_config_16(0, 2, 0, PCI_DEVICE_ID);
+	for (i = 0; i < ARRAY_SIZE(snb_ids); i++)
+		if (devid == snb_ids[i])
+			return true;
+#endif
+
+	return false;
+}
+
+/*
+ * Sandy Bridge graphics has trouble with certain ranges, exclude
+ * them from allocation.
+ */
+static void __init trim_snb_memory(void)
+{
+	static const __initconst unsigned long bad_pages[] = {
+		0x20050000,
+		0x20110000,
+		0x20130000,
+		0x20138000,
+		0x40004000,
+	};
+	int i;
+
+	if (!snb_gfx_workaround_needed())
+		return;
+
+	printk(KERN_DEBUG "reserving inaccessible SNB gfx pages\n");
+
+	/*
+	 * Reserve all memory below the 1 MB mark that has not
+	 * already been reserved.
+	 */
+	memblock_reserve(0, 1<<20);
+
+	for (i = 0; i < ARRAY_SIZE(bad_pages); i++) {
+		if (memblock_reserve(bad_pages[i], PAGE_SIZE))
+			printk(KERN_WARNING "failed to reserve 0x%08lx\n",
+			       bad_pages[i]);
+	}
+}
+
+/*
+ * Here we put platform-specific memory range workarounds, i.e.
+ * memory known to be corrupt or otherwise in need to be reserved on
+ * specific platforms.
+ *
+ * If this gets used more widely it could use a real dispatch mechanism.
+ */
+static void __init trim_platform_memory_ranges(void)
+{
+	trim_snb_memory();
+}
+
 static void __init trim_bios_range(void)
 {
 	/*
@@ -704,6 +777,7 @@ static void __init trim_bios_range(void)
 	 * take them out.
 	 */
 	e820_remove_range(BIOS_BEGIN, BIOS_END - BIOS_BEGIN, E820_RAM, 1);
+
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
 }
 
@@ -825,15 +899,15 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_EFI
 	if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
 		     "EL32", 4)) {
-		efi_enabled = 1;
-		efi_64bit = false;
+		set_bit(EFI_BOOT, &x86_efi_facility);
 	} else if (!strncmp((char *)&boot_params.efi_info.efi_loader_signature,
 		     "EL64", 4)) {
-		efi_enabled = 1;
-		efi_64bit = true;
+		set_bit(EFI_BOOT, &x86_efi_facility);
+		set_bit(EFI_64BIT, &x86_efi_facility);
 	}
-	if (efi_enabled && efi_memblock_x86_reserve_range())
-		efi_enabled = 0;
+
+	if (efi_enabled(EFI_BOOT))
+		efi_memblock_x86_reserve_range();
 #endif
 #else /* CONFIG_XEN */
 #ifdef CONFIG_X86_32
@@ -930,7 +1004,7 @@ void __init setup_arch(char **cmdline_p)
 
 	finish_e820_parsing();
 
-	if (efi_enabled)
+	if (efi_enabled(EFI_BOOT))
 		efi_init();
 
 	if (is_initial_xendomain())
@@ -1021,7 +1095,7 @@ void __init setup_arch(char **cmdline_p)
 	 * The EFI specification says that boot service code won't be called
 	 * after ExitBootServices(). This is, in fact, a lie.
 	 */
-	if (efi_enabled)
+	if (efi_enabled(EFI_MEMMAP))
 		efi_reserve_boot_services();
 
 	/* preallocate 4k for mptable mpc */
@@ -1036,6 +1110,8 @@ void __init setup_arch(char **cmdline_p)
 
 #ifndef CONFIG_XEN
 	setup_real_mode();
+
+	trim_platform_memory_ranges();
 #endif
 
 	init_gbpages();
@@ -1082,6 +1158,10 @@ void __init setup_arch(char **cmdline_p)
 
 	reserve_initrd();
 
+#if defined(CONFIG_ACPI) && defined(CONFIG_BLK_DEV_INITRD)
+	acpi_initrd_override((void *)initrd_start, initrd_end - initrd_start);
+#endif
+
 #ifndef CONFIG_XEN
 	reserve_crashkernel();
 
@@ -1264,7 +1344,7 @@ void __init setup_arch(char **cmdline_p)
 		;
 	else
 #endif
-	if (!efi_enabled || efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY)
+	if (!efi_enabled(EFI_BOOT) || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
 		conswitchp = &vga_con;
 #endif
 #endif
@@ -1279,14 +1359,14 @@ void __init setup_arch(char **cmdline_p)
 	register_refined_jiffies(CLOCK_TICK_RATE);
 
 #if defined(CONFIG_EFI) && !defined(CONFIG_XEN)
-	/* Once setup is done above, disable efi_enabled on mismatched
-	 * firmware/kernel archtectures since there is no support for
-	 * runtime services.
+	/* Once setup is done above, unmap the EFI memory map on
+	 * mismatched firmware/kernel archtectures since there is no
+	 * support for runtime services.
 	 */
-	if (efi_enabled && IS_ENABLED(CONFIG_X86_64) != efi_64bit) {
+	if (efi_enabled(EFI_BOOT) &&
+	    IS_ENABLED(CONFIG_X86_64) != efi_enabled(EFI_64BIT)) {
 		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
 		efi_unmap_memmap();
-		efi_enabled = 0;
 	}
 #endif
 }
--- head.orig/arch/x86/kernel/topology.c	2013-03-05 12:23:59.000000000 +0100
+++ head/arch/x86/kernel/topology.c	2013-01-11 16:04:30.000000000 +0100
@@ -37,7 +37,9 @@ static DEFINE_PER_CPU(struct x86_cpu, cp
 
 #ifdef CONFIG_HOTPLUG_CPU
 
-#ifdef CONFIG_BOOTPARAM_HOTPLUG_CPU0
+#if defined(CONFIG_XEN)
+#define cpu0_hotpluggable 0
+#elif defined(CONFIG_BOOTPARAM_HOTPLUG_CPU0)
 static int cpu0_hotpluggable = 1;
 #else
 static int cpu0_hotpluggable;
@@ -103,6 +105,7 @@ late_initcall_sync(debug_hotplug_cpu);
 
 int __ref arch_register_cpu(int num)
 {
+#ifndef cpu0_hotpluggable
 	struct cpuinfo_x86 *c = &cpu_data(num);
 
 	/*
@@ -133,6 +136,7 @@ int __ref arch_register_cpu(int num)
 			}
 		}
 	}
+#endif
 	if (num || cpu0_hotpluggable)
 		per_cpu(cpu_devices, num).cpu.hotpluggable = 1;
 
--- head.orig/arch/x86/kernel/traps-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/traps-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -55,7 +55,7 @@
 #include <asm/i387.h>
 #include <asm/fpu-internal.h>
 #include <asm/mce.h>
-#include <asm/rcu.h>
+#include <asm/context_tracking.h>
 
 #include <asm/mach_traps.h>
 
@@ -69,9 +69,6 @@
 
 asmlinkage int system_call(void);
 
-/* Do we ignore FPU interrupts ? */
-char ignore_fpu_irq;
-
 #ifndef CONFIG_X86_NO_IDT
 /*
  * The IDT has to be page-aligned to simplify the Pentium
@@ -568,9 +565,6 @@ void math_error(struct pt_regs *regs, in
 
 dotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)
 {
-#ifdef CONFIG_X86_32
-	ignore_fpu_irq = 1;
-#endif
 	exception_enter(regs);
 	math_error(regs, error_code, X86_TRAP_MF);
 	exception_exit(regs);
--- head.orig/arch/x86/kernel/vsyscall_64-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/kernel/vsyscall_64-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -147,19 +147,6 @@ static int addr_to_vsyscall_nr(unsigned 
 	return nr;
 }
 
-#ifdef CONFIG_SECCOMP
-static int vsyscall_seccomp(struct task_struct *tsk, int syscall_nr)
-{
-	if (!seccomp_mode(&tsk->seccomp))
-		return 0;
-	task_pt_regs(tsk)->orig_ax = syscall_nr;
-	task_pt_regs(tsk)->ax = syscall_nr;
-	return __secure_computing(syscall_nr);
-}
-#else
-#define vsyscall_seccomp(_tsk, _nr) 0
-#endif
-
 static bool write_ok_or_segv(unsigned long ptr, size_t size)
 {
 	/*
@@ -192,10 +179,9 @@ bool emulate_vsyscall(struct pt_regs *re
 {
 	struct task_struct *tsk;
 	unsigned long caller;
-	int vsyscall_nr;
+	int vsyscall_nr, syscall_nr, tmp;
 	int prev_sig_on_uaccess_error;
 	long ret;
-	int skip;
 
 	/*
 	 * No point in checking CS -- the only way to get here is a user mode
@@ -227,56 +213,87 @@ bool emulate_vsyscall(struct pt_regs *re
 	}
 
 	tsk = current;
-	/*
-	 * With a real vsyscall, page faults cause SIGSEGV.  We want to
-	 * preserve that behavior to make writing exploits harder.
-	 */
-	prev_sig_on_uaccess_error = current_thread_info()->sig_on_uaccess_error;
-	current_thread_info()->sig_on_uaccess_error = 1;
 
 	/*
+	 * Check for access_ok violations and find the syscall nr.
+	 *
 	 * NULL is a valid user pointer (in the access_ok sense) on 32-bit and
 	 * 64-bit, so we don't need to special-case it here.  For all the
 	 * vsyscalls, NULL means "don't write anything" not "write it at
 	 * address 0".
 	 */
-	ret = -EFAULT;
-	skip = 0;
 	switch (vsyscall_nr) {
 	case 0:
-		skip = vsyscall_seccomp(tsk, __NR_gettimeofday);
-		if (skip)
-			break;
-
 		if (!write_ok_or_segv(regs->di, sizeof(struct timeval)) ||
-		    !write_ok_or_segv(regs->si, sizeof(struct timezone)))
-			break;
+		    !write_ok_or_segv(regs->si, sizeof(struct timezone))) {
+			ret = -EFAULT;
+			goto check_fault;
+		}
 
+		syscall_nr = __NR_gettimeofday;
+		break;
+
+	case 1:
+		if (!write_ok_or_segv(regs->di, sizeof(time_t))) {
+			ret = -EFAULT;
+			goto check_fault;
+		}
+
+		syscall_nr = __NR_time;
+		break;
+
+	case 2:
+		if (!write_ok_or_segv(regs->di, sizeof(unsigned)) ||
+		    !write_ok_or_segv(regs->si, sizeof(unsigned))) {
+			ret = -EFAULT;
+			goto check_fault;
+		}
+
+		syscall_nr = __NR_getcpu;
+		break;
+	default:
+		syscall_nr = __NR_exit;
+		break;
+	}
+
+	/*
+	 * Handle seccomp.  regs->ip must be the original value.
+	 * See seccomp_send_sigsys and Documentation/prctl/seccomp_filter.txt.
+	 *
+	 * We could optimize the seccomp disabled case, but performance
+	 * here doesn't matter.
+	 */
+	regs->orig_ax = syscall_nr;
+	regs->ax = -ENOSYS;
+	tmp = secure_computing(syscall_nr);
+	if ((!tmp && regs->orig_ax != syscall_nr) || regs->ip != address) {
+		warn_bad_vsyscall(KERN_DEBUG, regs,
+				  "seccomp tried to change syscall nr or ip");
+		do_exit(SIGSYS);
+	}
+	if (tmp)
+		goto do_ret;  /* skip requested */
+
+	/*
+	 * With a real vsyscall, page faults cause SIGSEGV.  We want to
+	 * preserve that behavior to make writing exploits harder.
+	 */
+	prev_sig_on_uaccess_error = current_thread_info()->sig_on_uaccess_error;
+	current_thread_info()->sig_on_uaccess_error = 1;
+
+	ret = -EFAULT;
+	switch (vsyscall_nr) {
+	case 0:
 		ret = sys_gettimeofday(
 			(struct timeval __user *)regs->di,
 			(struct timezone __user *)regs->si);
 		break;
 
 	case 1:
-		skip = vsyscall_seccomp(tsk, __NR_time);
-		if (skip)
-			break;
-
-		if (!write_ok_or_segv(regs->di, sizeof(time_t)))
-			break;
-
 		ret = sys_time((time_t __user *)regs->di);
 		break;
 
 	case 2:
-		skip = vsyscall_seccomp(tsk, __NR_getcpu);
-		if (skip)
-			break;
-
-		if (!write_ok_or_segv(regs->di, sizeof(unsigned)) ||
-		    !write_ok_or_segv(regs->si, sizeof(unsigned)))
-			break;
-
 		ret = sys_getcpu((unsigned __user *)regs->di,
 				 (unsigned __user *)regs->si,
 				 NULL);
@@ -288,12 +305,7 @@ bool emulate_vsyscall(struct pt_regs *re
 
 	current_thread_info()->sig_on_uaccess_error = prev_sig_on_uaccess_error;
 
-	if (skip) {
-		if ((long)regs->ax <= 0L) /* seccomp errno emulation */
-			goto do_ret;
-		goto done; /* seccomp trace/trap */
-	}
-
+check_fault:
 	if (ret == -EFAULT) {
 		/* Bad news -- userspace fed a bad pointer to a vsyscall. */
 		warn_bad_vsyscall(KERN_INFO, regs,
@@ -316,7 +328,6 @@ do_ret:
 	/* Emulate a ret instruction. */
 	regs->ip = caller;
 	regs->sp += 8;
-done:
 	return true;
 
 sigsegv:
--- head.orig/arch/x86/mm/fault-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/mm/fault-xen.c	2013-02-20 11:39:48.000000000 +0100
@@ -18,7 +18,7 @@
 #include <asm/pgalloc.h>		/* pgd_*(), ...			*/
 #include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/
 #include <asm/fixmap.h>			/* VSYSCALL_START		*/
-#include <asm/rcu.h>			/* exception_enter(), ...	*/
+#include <asm/context_tracking.h>	/* exception_enter(), ...	*/
 
 /*
  * Page fault error code bits:
@@ -757,13 +757,15 @@ __bad_area_nosemaphore(struct pt_regs *r
 				return;
 		}
 #endif
+		/* Kernel addresses are always protection faults: */
+		if (address >= TASK_SIZE)
+			error_code |= PF_PROT;
 
-		if (unlikely(show_unhandled_signals))
+		if (likely(show_unhandled_signals))
 			show_signal_msg(regs, error_code, address, tsk);
 
-		/* Kernel addresses are always protection faults: */
 		tsk->thread.cr2		= address;
-		tsk->thread.error_code	= error_code | (address >= TASK_SIZE);
+		tsk->thread.error_code	= error_code;
 		tsk->thread.trap_nr	= X86_TRAP_PF;
 
 		force_sig_info_fault(SIGSEGV, si_code, address, tsk, 0);
@@ -812,20 +814,6 @@ bad_area_access_error(struct pt_regs *re
 	__bad_area(regs, error_code, address, SEGV_ACCERR);
 }
 
-/* TODO: fixup for "mm-invoke-oom-killer-from-page-fault.patch" */
-static void
-out_of_memory(struct pt_regs *regs, unsigned long error_code,
-	      unsigned long address)
-{
-	/*
-	 * We ran out of memory, call the OOM killer, and return the userspace
-	 * (which will retry the fault, or kill us if we got oom-killed):
-	 */
-	up_read(&current->mm->mmap_sem);
-
-	pagefault_out_of_memory();
-}
-
 static void
 do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address,
 	  unsigned int fault)
@@ -888,7 +876,14 @@ mm_fault_error(struct pt_regs *regs, uns
 			return 1;
 		}
 
-		out_of_memory(regs, error_code, address);
+		up_read(&current->mm->mmap_sem);
+
+		/*
+		 * We ran out of memory, call the OOM killer, and return the
+		 * userspace (which will retry the fault, or kill us if we got
+		 * oom-killed):
+		 */
+		pagefault_out_of_memory();
 	} else {
 		if (fault & (VM_FAULT_SIGBUS|VM_FAULT_HWPOISON|
 			     VM_FAULT_HWPOISON_LARGE))
--- head.orig/arch/x86/mm/init_32-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/arch/x86/mm/init_32-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -771,10 +771,7 @@ static void __init test_wp_bit(void)
 
 	if (!boot_cpu_data.wp_works_ok) {
 		printk(KERN_CONT "No.\n");
-#ifdef CONFIG_X86_WP_WORKS_OK
-		panic(
-  "This kernel doesn't support CPU's with broken WP. Recompile it for a 386!");
-#endif
+		panic("Linux doesn't support CPUs with broken WP.");
 	} else {
 		printk(KERN_CONT "Ok.\n");
 	}
--- head.orig/arch/x86/mm/init_64-xen.c	2012-10-31 11:57:31.000000000 +0100
+++ head/arch/x86/mm/init_64-xen.c	2013-02-20 11:39:48.000000000 +0100
@@ -885,7 +885,9 @@ void __init paging_init(void)
 	 *	 numa support is not compiled in, and later node_set_state
 	 *	 will not set it back.
 	 */
-	node_clear_state(0, N_NORMAL_MEMORY);
+	node_clear_state(0, N_MEMORY);
+	if (N_MEMORY != N_NORMAL_MEMORY)
+		node_clear_state(0, N_NORMAL_MEMORY);
 
 	zone_sizes_init();
 
@@ -1106,6 +1108,9 @@ int kern_addr_valid(unsigned long addr)
 	if (pud_none(*pud))
 		return 0;
 
+	if (pud_large(*pud))
+		return pfn_valid(pud_pfn(*pud));
+
 	pmd = pmd_offset(pud, addr);
 	if (pmd_none(*pmd))
 		return 0;
--- head.orig/arch/x86/mm/pgtable-xen.c	2011-09-08 17:12:17.000000000 +0200
+++ head/arch/x86/mm/pgtable-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -487,7 +487,7 @@ static void pgd_dtor(pgd_t *pgd)
  * against pageattr.c; it is the unique case in which a valid change
  * of kernel pagetables can't be lazily synchronized by vmalloc faults.
  * vmalloc faults work because attached pagetables are never freed.
- * -- wli
+ * -- nyc
  */
 
 #ifdef CONFIG_X86_PAE
@@ -710,6 +710,13 @@ pte_t xen_ptep_get_and_clear_full(struct
 }
 EXPORT_SYMBOL_GPL(xen_ptep_get_and_clear_full);
 
+/*
+ * Used to set accessed or dirty bits in the page table entries
+ * on other architectures. On x86, the accessed and dirty bits
+ * are tracked by hardware. However, do_wp_page calls this function
+ * to also make the pte writeable at the same time the dirty bit is
+ * set. In that case we do actually need to write the PTE.
+ */
 int ptep_set_access_flags(struct vm_area_struct *vma,
 			  unsigned long address, pte_t *ptep,
 			  pte_t entry, int dirty)
@@ -718,13 +725,11 @@ int ptep_set_access_flags(struct vm_area
 
 	if (changed && dirty) {
 		if (likely(vma->vm_mm == current->mm)) {
-			if (HYPERVISOR_update_va_mapping(address,
-				entry,
-				uvm_multi(mm_cpumask(vma->vm_mm))|UVMF_INVLPG))
+			if (HYPERVISOR_update_va_mapping(address, entry,
+							 UVMF_NONE))
 				BUG();
 		} else {
 			xen_l1_entry_update(ptep, entry);
-			flush_tlb_page(vma, address);
 		}
 	}
 
--- head.orig/arch/x86/pci/common.c	2013-03-05 12:23:59.000000000 +0100
+++ head/arch/x86/pci/common.c	2013-01-22 14:47:01.000000000 +0100
@@ -612,6 +612,7 @@ unsigned int pcibios_assign_all_busses(v
 
 int pcibios_add_device(struct pci_dev *dev)
 {
+#if !defined(CONFIG_XEN)
 	struct setup_data *data;
 	struct pci_setup_rom *rom;
 	u64 pa_data;
@@ -636,6 +637,27 @@ int pcibios_add_device(struct pci_dev *d
 		}
 		pa_data = data->next;
 	}
+#elif defined(CONFIG_EFI)
+	struct xen_platform_op op = {
+		.cmd = XENPF_firmware_info,
+		.u.firmware_info = {
+			.type = XEN_FW_EFI_INFO,
+			.index = XEN_FW_EFI_PCI_ROM,
+			.u.efi_info.pci_rom = {
+				.segment = pci_domain_nr(dev->bus),
+				.bus = dev->bus->number,
+				.devfn = dev->devfn,
+				.vendor = dev->vendor,
+				.devid = dev->device
+			}
+		}
+	};
+
+	if (HYPERVISOR_platform_op(&op) == 0) {
+		dev->rom = op.u.firmware_info.u.efi_info.pci_rom.address;
+		dev->romlen = op.u.firmware_info.u.efi_info.pci_rom.size;
+	}
+#endif
 	return 0;
 }
 
--- head.orig/drivers/acpi/acpi_pad-xen.c	2012-06-01 11:18:36.000000000 +0200
+++ head/drivers/acpi/acpi_pad-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -57,10 +57,10 @@ static long xen_acpi_pad_idle_cpus_num(v
 static ssize_t acpi_pad_idlecpus_store(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	unsigned long num;
+	unsigned int num;
 	int err;
 
-	if (strict_strtoul(buf, 0, &num))
+	if (kstrtouint(buf, 0, &num))
 		return -EINVAL;
 	mutex_lock(&xen_cpu_lock);
 	err = xen_acpi_pad_idle_cpus(num);
@@ -162,7 +162,7 @@ static void acpi_pad_notify(acpi_handle 
 		acpi_pad_handle_notify(handle);
 		break;
 	default:
-		printk(KERN_WARNING "Unsupported event [0x%x]\n", event);
+		pr_warn("Unsupported event [0x%x]\n", event);
 		break;
 	}
 }
--- head.orig/drivers/acpi/processor_driver.c	2013-01-30 11:57:52.000000000 +0100
+++ head/drivers/acpi/processor_driver.c	2013-01-30 12:03:47.000000000 +0100
@@ -798,6 +798,8 @@ static void acpi_processor_hotplug_notif
 	int result;
 
 	switch (event) {
+		struct acpi_processor *pr;
+
 	case ACPI_NOTIFY_BUS_CHECK:
 	case ACPI_NOTIFY_DEVICE_CHECK:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
@@ -840,7 +842,8 @@ static void acpi_processor_hotplug_notif
 			break;
 		}
 
-		if (processor_cntl_external())
+		pr = acpi_driver_data(device);
+		if (processor_cntl_external() && pr)
 			processor_notify_external(pr, PROCESSOR_HOTPLUG,
 						HOTPLUG_TYPE_REMOVE);
 
--- head.orig/drivers/dma/ioat/dma.h	2013-01-14 13:51:50.000000000 +0100
+++ head/drivers/dma/ioat/dma.h	2013-01-30 12:31:16.000000000 +0100
@@ -332,7 +332,7 @@ static inline void ioat_remove_dca_provi
 	struct ioatdma_device *device = pci_get_drvdata(pdev);
 	BUG_ON(device->dca);
 }
-static inline struct dca_provider *__devinit
+static inline struct dca_provider *
 __ioat_dca_init(struct pci_dev *pdev, void __iomem *iobase)
 {
 	return NULL;
--- head.orig/drivers/hwmon/coretemp-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/drivers/hwmon/coretemp-xen.c	2013-01-09 15:32:33.000000000 +0100
@@ -34,7 +34,6 @@
 #include <linux/list.h>
 #include <linux/platform_device.h>
 #include <linux/cpu.h>
-#include <linux/pci.h>
 #include <linux/smp.h>
 #include <linux/moduleparam.h>
 #include <asm/msr.h>
@@ -205,14 +204,6 @@ struct tjmax {
 };
 
 static const struct tjmax tjmax_table[] = {
-	{ "CPU D410", 100000 },
-	{ "CPU D425", 100000 },
-	{ "CPU D510", 100000 },
-	{ "CPU D525", 100000 },
-	{ "CPU N450", 100000 },
-	{ "CPU N455", 100000 },
-	{ "CPU N470", 100000 },
-	{ "CPU N475", 100000 },
 	{ "CPU  230", 100000 },		/* Model 0x1c, stepping 2	*/
 	{ "CPU  330", 125000 },		/* Model 0x1c, stepping 2	*/
 	{ "CPU CE4110", 110000 },	/* Model 0x1c, stepping 10	*/
@@ -220,6 +211,28 @@ static const struct tjmax tjmax_table[] 
 	{ "CPU CE4170", 110000 },	/* Model 0x1c, stepping 10	*/
 };
 
+struct tjmax_model {
+	u8 model;
+	u8 mask;
+	int tjmax;
+};
+
+#define ANY 0xff
+
+static const struct tjmax_model tjmax_model_table[] = {
+	{ 0x1c, 10, 100000 },	/* D4xx, N4xx, D5xx, N5xx */
+	{ 0x1c, ANY, 90000 },	/* Z5xx, N2xx, possibly others
+				 * Note: Also matches 230 and 330,
+				 * which are covered by tjmax_table
+				 */
+	{ 0x26, ANY, 90000 },	/* Atom Tunnel Creek (Exx), Lincroft (Z6xx)
+				 * Note: TjMax for E6xxT is 110C, but CPU type
+				 * is undetectable by software
+				 */
+	{ 0x27, ANY, 90000 },	/* Atom Medfield (Z2460) */
+	{ 0x36, ANY, 100000 },	/* Atom Cedar Trail/Cedarview (N2xxx, D2xxx) */
+};
+
 static int adjust_tjmax(struct platform_data *c, u32 id, struct device *dev)
 {
 	/* The 100C is default for both mobile and non mobile CPUs */
@@ -229,7 +242,6 @@ static int adjust_tjmax(struct platform_
 	int usemsr_ee = 1;
 	int err;
 	u32 eax, edx;
-	struct pci_dev *host_bridge;
 	int i;
 
 	/* explicit tjmax table entries override heuristics */
@@ -238,32 +250,18 @@ static int adjust_tjmax(struct platform_
 			return tjmax_table[i].tjmax;
 	}
 
+	for (i = 0; i < ARRAY_SIZE(tjmax_model_table); i++) {
+		const struct tjmax_model *tm = &tjmax_model_table[i];
+		if (c->x86_model == tm->model &&
+		    (tm->mask == ANY || c->x86_mask == tm->mask))
+			return tm->tjmax;
+	}
+
 	/* Early chips have no MSR for TjMax */
 
 	if (c->x86_model == 0xf && c->x86_mask < 4)
 		usemsr_ee = 0;
 
-	/* Atom CPUs */
-
-	if (c->x86_model == 0x1c || c->x86_model == 0x26
-	    || c->x86_model == 0x27) {
-		usemsr_ee = 0;
-
-		host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
-
-		if (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL
-		    && (host_bridge->device == 0xa000	/* NM10 based nettop */
-		    || host_bridge->device == 0xa010))	/* NM10 based netbook */
-			tjmax = 100000;
-		else
-			tjmax = 90000;
-
-		pci_dev_put(host_bridge);
-	} else if (c->x86_model == 0x36) {
-		usemsr_ee = 0;
-		tjmax = 100000;
-	}
-
 	if (c->x86_model > 0xe && usemsr_ee) {
 		u8 platform_id;
 
--- head.orig/drivers/pci/Kconfig	2012-11-29 10:33:53.000000000 +0100
+++ head/drivers/pci/Kconfig	2013-01-10 14:56:12.000000000 +0100
@@ -88,7 +88,6 @@ config XEN_PCIDEV_FRONTEND
 	def_bool y
 	prompt "Xen PCI Frontend" if X86_64
 	depends on PCI && XEN && (PCI_GOXEN_FE || PCI_GOANY || X86_64)
-	select HOTPLUG
 	help
 	  The PCI device frontend driver allows the kernel to import arbitrary
 	  PCI devices from a PCI backend to support PCI driver domains.
--- head.orig/drivers/xen/Makefile	2012-11-14 13:25:08.000000000 +0100
+++ head/drivers/xen/Makefile	2013-01-09 15:32:33.000000000 +0100
@@ -5,11 +5,11 @@ xen-evtchn-name-$(CONFIG_PARAVIRT_XEN) :
 xen-privcmd_$(CONFIG_PARAVIRT_XEN) := xen-privcmd.o
 
 ifneq ($(CONFIG_ARM),y)
-obj-$(CONFIG_PARAVIRT_XEN)	+= manage.o balloon.o
+obj-$(CONFIG_PARAVIRT_XEN)	+= manage.o
 obj-$(CONFIG_HOTPLUG_CPU)	+= $(xen-hotplug-y)
 endif
 obj-$(CONFIG_X86)		+= fallback.o
-obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o events.o
+obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o events.o balloon.o
 
 xen-balloon_$(CONFIG_XEN)	:= balloon/
 xen-privcmd_$(CONFIG_XEN)	:= privcmd/
@@ -33,7 +33,8 @@ obj-$(CONFIG_XEN)			+= features.o $(xen-
 obj-$(CONFIG_XEN_PRIVILEGED_GUEST)	+= $(priv-y)
 dom0-$(CONFIG_PCI) += pci.o
 dom0-$(CONFIG_USB_SUPPORT) += dbgp.o
-dom0-$(CONFIG_ACPI) += acpi.o
+dom0-$(CONFIG_ACPI) += acpi.o $(xen-pad-y)
+xen-pad-$(CONFIG_X86) += xen-acpi-pad.o
 dom0-$(CONFIG_X86) += pcpu.o
 obj-$(CONFIG_XEN_DOM0)			+= $(dom0-y)
 obj-$(CONFIG_BLOCK)			+= $(xen-biomerge-y)
--- head.orig/drivers/xen/char/mem.c	2012-01-20 15:02:27.000000000 +0100
+++ head/drivers/xen/char/mem.c	2013-01-09 15:32:33.000000000 +0100
@@ -63,7 +63,7 @@ static inline int range_is_allowed(unsig
 static ssize_t read_mem(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos;
+	phys_addr_t p = *ppos;
 	ssize_t read = 0, sz;
 	void __iomem *v;
 
@@ -109,8 +109,8 @@ static ssize_t read_mem(struct file *fil
 static ssize_t write_mem(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos)
 {
-	unsigned long p = *ppos, ignored;
-	ssize_t written = 0, sz;
+	phys_addr_t p = *ppos;
+	ssize_t written = 0, sz, ignored;
 	void __iomem *v;
 
 	while (count > 0) {
--- head.orig/drivers/xen/core/gnttab.c	2012-03-12 16:18:44.000000000 +0100
+++ head/drivers/xen/core/gnttab.c	2013-01-09 17:00:21.000000000 +0100
@@ -881,7 +881,7 @@ static int gnttab_expand(unsigned int re
 	return rc;
 }
 
-int __devinit gnttab_init(void)
+int gnttab_init(void)
 {
 	int i, ret;
 	unsigned int max_nr_glist_frames, nr_glist_frames;
--- head.orig/drivers/xen/core/reboot.c	2012-11-05 12:27:07.000000000 +0100
+++ head/drivers/xen/core/reboot.c	2013-01-11 14:10:58.000000000 +0100
@@ -80,7 +80,6 @@ static int xen_suspend(void *__unused)
 {
 	int err, old_state;
 
-	daemonize("suspend");
 	err = set_cpus_allowed_ptr(current, cpumask_of(0));
 	if (err) {
 		pr_err("Xen suspend can't run on CPU0 (%d)\n", err);
@@ -118,8 +117,6 @@ static int xen_suspend(void *__unused)
 	return 0;
 }
 
-#else
-# define xen_suspend NULL
 #endif
 
 static void switch_shutdown_state(int new_state)
@@ -151,9 +148,12 @@ static void __shutdown_handler(struct wo
 {
 	struct task_struct *taskp;
 
-	taskp = kthread_run((shutting_down == SHUTDOWN_SUSPEND) ?
-			    xen_suspend : shutdown_process,
-			    NULL, "shutdown");
+#ifdef CONFIG_PM_SLEEP
+	if (shutting_down == SHUTDOWN_SUSPEND)
+		taskp = kthread_run(xen_suspend, NULL, "suspend");
+	else
+#endif
+		taskp = kthread_run(shutdown_process, NULL, "shutdown");
 
 	if (IS_ERR(taskp)) {
 		pr_warning("Error creating shutdown process (%ld): "
--- head.orig/drivers/xen/fbfront/xenfb.c	2012-10-30 14:53:54.000000000 +0100
+++ head/drivers/xen/fbfront/xenfb.c	2013-01-09 17:00:48.000000000 +0100
@@ -547,8 +547,7 @@ static unsigned long vmalloc_to_mfn(void
 	return pfn_to_mfn(vmalloc_to_pfn(address));
 }
 
-static __devinit void
-xenfb_make_preferred_console(void)
+static void xenfb_make_preferred_console(void)
 {
 	struct console *c;
 
@@ -569,8 +568,8 @@ xenfb_make_preferred_console(void)
 	}
 }
 
-static int __devinit xenfb_probe(struct xenbus_device *dev,
-				 const struct xenbus_device_id *id)
+static int xenfb_probe(struct xenbus_device *dev,
+		       const struct xenbus_device_id *id)
 {
 	struct xenfb_info *info;
 	struct fb_info *fb_info;
--- head.orig/drivers/xen/fbfront/xenkbd.c	2011-09-20 11:39:37.000000000 +0200
+++ head/drivers/xen/fbfront/xenkbd.c	2013-01-09 17:01:10.000000000 +0100
@@ -102,8 +102,7 @@ static irqreturn_t input_handler(int rq,
 	return IRQ_HANDLED;
 }
 
-int __devinit xenkbd_probe(struct xenbus_device *dev,
-			   const struct xenbus_device_id *id)
+int xenkbd_probe(struct xenbus_device *dev, const struct xenbus_device_id *id)
 {
 	int ret, i, abs;
 	struct xenkbd_info *info;
--- head.orig/drivers/xen/netfront/netfront.c	2013-01-30 12:03:13.000000000 +0100
+++ head/drivers/xen/netfront/netfront.c	2013-01-30 12:03:54.000000000 +0100
@@ -235,7 +235,7 @@ static inline bool xennet_can_sg(struct 
 /*
  * Work around net.ipv4.conf.*.arp_notify not being enabled by default.
  */
-static void __devinit netfront_enable_arp_notify(struct netfront_info *info)
+static void netfront_enable_arp_notify(struct netfront_info *info)
 {
 #ifdef CONFIG_INET
 	struct in_device *in_dev;
@@ -256,8 +256,8 @@ static void __devinit netfront_enable_ar
  * structures and the ring buffers for communication with the backend, and
  * inform the backend of the appropriate details for those.
  */
-static int __devinit netfront_probe(struct xenbus_device *dev,
-				    const struct xenbus_device_id *id)
+static int netfront_probe(struct xenbus_device *dev,
+			  const struct xenbus_device_id *id)
 {
 	int err;
 	struct net_device *netdev;
@@ -298,7 +298,7 @@ static int __devinit netfront_probe(stru
 	return err;
 }
 
-static int __devexit netfront_remove(struct xenbus_device *dev)
+static int netfront_remove(struct xenbus_device *dev)
 {
 	struct netfront_info *info = dev_get_drvdata(&dev->dev);
 
@@ -1424,26 +1424,10 @@ err:	
 		i = xennet_fill_frags(np, skb, &tmpq);
 
 		/*
-		 * Truesize must approximates the size of true data plus
-		 * any supervisor overheads. Adding hypervisor overheads
-		 * has been shown to significantly reduce achievable
-		 * bandwidth with the default receive buffer size. It is
-		 * therefore not wise to account for it here.
-		 *
-		 * After alloc_skb(RX_COPY_THRESHOLD), truesize is set to
-		 * RX_COPY_THRESHOLD + the supervisor overheads. Here, we
-		 * add the size of the data pulled in xennet_fill_frags().
-		 *
-		 * We also adjust for any unused space in the main data
-		 * area by subtracting (RX_COPY_THRESHOLD - len). This is
-		 * especially important with drivers which split incoming
-		 * packets into header and data, using only 66 bytes of
-		 * the main data area (see the e1000 driver for example.)
-		 * On such systems, without this last adjustement, our
-		 * achievable receive throughout using the standard receive
-		 * buffer size was cut by 25%(!!!).
-		 */
-		skb->truesize += skb->data_len - RX_COPY_THRESHOLD;
+                 * Truesize is the actual allocation size, even if the
+                 * allocation is only partially used.
+                 */
+		skb->truesize += PAGE_SIZE * skb_shinfo(skb)->nr_frags;
 		skb->len += skb->data_len;
 
 		if (rx->flags & XEN_NETRXF_csum_blank)
@@ -2122,7 +2106,7 @@ static const struct net_device_ops xenne
 	.ndo_get_stats64        = xennet_get_stats64,
 };
 
-static struct net_device * __devinit create_netdev(struct xenbus_device *dev)
+static struct net_device *create_netdev(struct xenbus_device *dev)
 {
 	int i, err = 0;
 	struct net_device *netdev = NULL;
@@ -2257,7 +2241,7 @@ MODULE_ALIAS("xen:vif");
 
 static DEFINE_XENBUS_DRIVER(netfront, ,
 	.probe = netfront_probe,
-	.remove = __devexit_p(netfront_remove),
+	.remove = netfront_remove,
 	.suspend = netfront_suspend,
 	.suspend_cancel = netfront_suspend_cancel,
 	.resume = netfront_resume,
--- head.orig/drivers/xen/pcifront/pci_op.c	2012-04-13 16:45:40.000000000 +0200
+++ head/drivers/xen/pcifront/pci_op.c	2013-01-09 17:02:21.000000000 +0100
@@ -426,8 +426,8 @@ static int pcifront_claim_resource(struc
 	return 0;
 }
 
-int __devinit pcifront_scan_root(struct pcifront_device *pdev,
-				 unsigned int domain, unsigned int bus)
+int pcifront_scan_root(struct pcifront_device *pdev,
+		       unsigned int domain, unsigned int bus)
 {
 	struct pci_bus *b;
 	struct pcifront_sd *sd;
@@ -483,8 +483,8 @@ int __devinit pcifront_scan_root(struct 
 	return err;
 }
 
-int __devinit pcifront_rescan_root(struct pcifront_device *pdev,
-				   unsigned int domain, unsigned int bus)
+int pcifront_rescan_root(struct pcifront_device *pdev,
+			 unsigned int domain, unsigned int bus)
 {
 	struct pci_bus *b;
 	struct pci_dev *d;
--- head.orig/drivers/xen/pcifront/xenbus.c	2012-10-30 17:25:04.000000000 +0100
+++ head/drivers/xen/pcifront/xenbus.c	2013-01-09 17:02:43.000000000 +0100
@@ -147,7 +147,7 @@ static int pcifront_publish_info(struct 
 	return err;
 }
 
-static int __devinit pcifront_try_connect(struct pcifront_device *pdev)
+static int pcifront_try_connect(struct pcifront_device *pdev)
 {
 	int err = -EFAULT;
 	int i, num_roots, len;
@@ -243,7 +243,7 @@ static int pcifront_try_disconnect(struc
 	return err;
 }
 
-static int __devinit pcifront_attach_devices(struct pcifront_device *pdev)
+static int pcifront_attach_devices(struct pcifront_device *pdev)
 {
 	int err = -EFAULT;
 	int i, num_roots, len;
--- head.orig/drivers/xen/xenbus/xenbus_dev.c	2012-02-16 13:43:48.000000000 +0100
+++ head/drivers/xen/xenbus/xenbus_dev.c	2013-01-09 17:03:12.000000000 +0100
@@ -498,8 +498,6 @@ static const struct file_operations xenb
 int
 #ifndef MODULE
 __init
-#else
-__devinit
 #endif
 xenbus_dev_init(void)
 {
--- head.orig/drivers/xen/xenbus/xenbus_probe.c	2012-10-29 17:13:41.000000000 +0100
+++ head/drivers/xen/xenbus/xenbus_probe.c	2013-01-09 17:03:24.000000000 +0100
@@ -1264,7 +1264,7 @@ enum xenstore_init {
 #ifndef MODULE
 static int __init
 #else
-int __devinit
+int
 #endif
 xenbus_init(void)
 {
--- head.orig/fs/proc/task_mmu.c	2013-03-05 12:23:59.000000000 +0100
+++ head/fs/proc/task_mmu.c	2013-01-11 14:58:25.000000000 +0100
@@ -569,8 +569,12 @@ static void show_smap_vma_flags(struct s
 		[ilog2(VM_ARCH_1)]	= "ar",
 		[ilog2(VM_DONTDUMP)]	= "dd",
 		[ilog2(VM_MIXEDMAP)]	= "mm",
+#ifndef CONFIG_XEN
 		[ilog2(VM_HUGEPAGE)]	= "hg",
 		[ilog2(VM_NOHUGEPAGE)]	= "nh",
+#else
+		[ilog2(VM_FOREIGN)]	= "fo",
+#endif
 		[ilog2(VM_MERGEABLE)]	= "mg",
 	};
 	size_t i;
--- head.orig/include/xen/interface/memory.h	2013-01-08 11:58:46.000000000 +0100
+++ head/include/xen/interface/memory.h	2013-01-09 15:32:33.000000000 +0100
@@ -263,6 +263,7 @@ struct xen_add_to_physmap_range {
     /* GPFN in domid where the source mapping page should appear. */
     XEN_GUEST_HANDLE(xen_pfn_t) gpfns;
 };
+DEFINE_GUEST_HANDLE_STRUCT(xen_add_to_physmap_range);
 typedef struct xen_add_to_physmap_range xen_add_to_physmap_range_t;
 DEFINE_XEN_GUEST_HANDLE(xen_add_to_physmap_range_t);
 
@@ -279,6 +280,7 @@ struct xen_remove_from_physmap {
     /* GPFN of the current mapping of the page. */
     xen_pfn_t     gpfn;
 };
+DEFINE_GUEST_HANDLE_STRUCT(xen_remove_from_physmap);
 typedef struct xen_remove_from_physmap xen_remove_from_physmap_t;
 DEFINE_XEN_GUEST_HANDLE(xen_remove_from_physmap_t);
 
--- head.orig/include/xen/interface/platform.h	2013-03-05 12:40:34.000000000 +0100
+++ head/include/xen/interface/platform.h	2013-03-05 12:41:26.000000000 +0100
@@ -218,6 +218,7 @@ DEFINE_XEN_GUEST_HANDLE(xenpf_efi_runtim
 #define  XEN_FW_EFI_VENDOR         2
 #define  XEN_FW_EFI_MEM_INFO       3
 #define  XEN_FW_EFI_RT_VERSION     4
+#define  XEN_FW_EFI_PCI_ROM        5
 #define XEN_FW_KBD_SHIFT_FLAGS    5 /* Int16, Fn02: Get keyboard shift flags. */
 struct xenpf_firmware_info {
 	/* IN variables. */
@@ -267,6 +268,17 @@ struct xenpf_firmware_info {
 				uint64_t attr;
 				uint32_t type;
 			} mem;
+			struct {
+				/* IN variables */
+				uint16_t segment;
+				uint8_t bus;
+				uint8_t devfn;
+				uint16_t vendor;
+				uint16_t devid;
+				/* OUT variables */
+				uint64_t address;
+				xen_ulong_t size;
+			} pci_rom;
 		} efi_info; /* XEN_FW_EFI_INFO */
 
 		/* Int16, Fn02: Get keyboard shift flags. */
@@ -520,6 +532,7 @@ struct xenpf_core_parking {
 	/* OUT variables: get cpu nums actually be idled */
 	uint32_t idle_nums;
 };
+DEFINE_GUEST_HANDLE_STRUCT(xenpf_core_parking);
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
--- head.orig/lib/swiotlb-xen.c	2012-10-29 17:13:41.000000000 +0100
+++ head/lib/swiotlb-xen.c	2013-01-14 15:36:34.000000000 +0100
@@ -45,7 +45,7 @@ int swiotlb_force;
  * swiotlb_tbl_sync_single_*, to see if the memory was in fact allocated by this
  * API.
  */
-static char *io_tlb_start, *io_tlb_end;
+static phys_addr_t io_tlb_start, io_tlb_end;
 
 /*
  * The number of IO TLB blocks (in groups of 64) between io_tlb_start and
@@ -58,7 +58,7 @@ static unsigned long io_tlb_nslabs;
  */
 static unsigned long io_tlb_overflow = 32*1024;
 
-static void *io_tlb_overflow_buffer;
+static phys_addr_t io_tlb_overflow_buffer;
 
 /*
  * This is a free list describing the number of free entries available from
@@ -119,12 +119,15 @@ unsigned long swiotlb_nr_tbl(void)
 	return io_tlb_nslabs;
 }
 EXPORT_SYMBOL_GPL(swiotlb_nr_tbl);
+
+#ifndef CONFIG_XEN
 /* Note that this doesn't work with highmem page */
 static dma_addr_t swiotlb_virt_to_bus(struct device *hwdev,
 				      volatile void *address)
 {
 	return phys_to_dma(hwdev, virt_to_phys(address));
 }
+#endif
 
 void swiotlb_print_info(void)
 {
@@ -135,23 +138,24 @@ void swiotlb_print_info(void)
 	       " Address size: %u bits\n"
 	       " Kernel range: %p - %p\n",
 	       bytes >> 20, dma_bits,
-	       io_tlb_start, io_tlb_end);
+	       phys_to_virt(io_tlb_start), phys_to_virt(io_tlb_end));
 }
 
 void __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)
 {
+	void *v_overflow_buffer;
 	unsigned long i, bytes;
 	int rc;
 
 	bytes = nslabs << IO_TLB_SHIFT;
 
 	io_tlb_nslabs = nslabs;
-	io_tlb_start = tlb;
+	io_tlb_start = __pa(tlb);
 	dma_bits = get_order(IO_TLB_SEGSIZE << IO_TLB_SHIFT) + PAGE_SHIFT;
 	for (nslabs = 0; nslabs < io_tlb_nslabs; nslabs += IO_TLB_SEGSIZE) {
 		do {
 			rc = xen_create_contiguous_region(
-				(unsigned long)io_tlb_start + (nslabs << IO_TLB_SHIFT),
+				(unsigned long)tlb + (nslabs << IO_TLB_SHIFT),
 				get_order(IO_TLB_SEGSIZE << IO_TLB_SHIFT),
 				dma_bits);
 		} while (rc && dma_bits++ < max_dma_bits);
@@ -162,10 +166,10 @@ void __init swiotlb_init_with_tbl(char *
 				      "some DMA memory (e.g., dom0_mem=-128M).\n");
 			io_tlb_nslabs = nslabs;
 			i = nslabs << IO_TLB_SHIFT;
-			free_bootmem(__pa(io_tlb_start + i), bytes - i);
+			free_bootmem(io_tlb_start + i, bytes - i);
 			bytes = i;
 			for (dma_bits = 0; i > 0; i -= IO_TLB_SEGSIZE << IO_TLB_SHIFT) {
-				unsigned int bits = fls64(virt_to_bus(io_tlb_start + i - 1));
+				unsigned int bits = fls64(virt_to_bus(tlb + i - 1));
 
 				if (bits > dma_bits)
 					dma_bits = bits;
@@ -176,6 +180,15 @@ void __init swiotlb_init_with_tbl(char *
 	io_tlb_end = io_tlb_start + bytes;
 
 	/*
+	 * Get the overflow emergency buffer
+	 */
+	v_overflow_buffer = alloc_bootmem_pages(PAGE_ALIGN(io_tlb_overflow));
+	if (!v_overflow_buffer)
+		panic("Cannot allocate SWIOTLB overflow buffer!\n");
+
+	io_tlb_overflow_buffer = __pa(v_overflow_buffer);
+
+	/*
 	 * Allocate and initialize the free list array.  This array is used
 	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE.
 	 */
@@ -185,16 +198,10 @@ void __init swiotlb_init_with_tbl(char *
 	io_tlb_index = 0;
 	io_tlb_orig_addr = alloc_bootmem_pages(PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));
 
-	/*
-	 * Get the overflow emergency buffer
-	 */
-	io_tlb_overflow_buffer = alloc_bootmem_pages(PAGE_ALIGN(io_tlb_overflow));
-	if (!io_tlb_overflow_buffer)
-		panic("Cannot allocate SWIOTLB overflow buffer!\n");
 
 	do {
 		rc = xen_create_contiguous_region(
-			(unsigned long)io_tlb_overflow_buffer,
+			(unsigned long)v_overflow_buffer,
 			get_order(io_tlb_overflow),
 			dma_bits);
 	} while (rc && dma_bits++ < max_dma_bits);
@@ -211,6 +218,7 @@ void __init swiotlb_init_with_tbl(char *
 static void __init
 swiotlb_init_with_default_size(size_t default_size, int verbose)
 {
+	unsigned char *vstart;
 	unsigned long bytes;
 
 	if (!io_tlb_nslabs) {
@@ -223,11 +231,11 @@ swiotlb_init_with_default_size(size_t de
 	/*
 	 * Get IO TLB memory from the low pages
 	 */
-	io_tlb_start = alloc_bootmem_pages(PAGE_ALIGN(bytes));
-	if (!io_tlb_start)
+	vstart = alloc_bootmem_pages(PAGE_ALIGN(bytes));
+	if (!vstart)
 		panic("Cannot allocate SWIOTLB buffer");
 
-	swiotlb_init_with_tbl(io_tlb_start, io_tlb_nslabs, verbose);
+	swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose);
 }
 
 void __init
@@ -264,8 +272,7 @@ static int is_swiotlb_buffer(dma_addr_t 
 	unsigned long pfn = mfn_to_local_pfn(PFN_DOWN(addr));
 	phys_addr_t paddr = (phys_addr_t)pfn << PAGE_SHIFT;
 
-	return paddr >= virt_to_phys(io_tlb_start) &&
-		paddr < virt_to_phys(io_tlb_end);
+	return paddr >= io_tlb_start && paddr < io_tlb_end;
 }
 
 /*
@@ -276,14 +283,15 @@ static int is_swiotlb_buffer(dma_addr_t 
  * drivers map the buffer for DMA_BIDIRECTIONAL access. This causes an
  * unnecessary copy from the aperture to the host buffer, and a page fault.
  */
-void swiotlb_bounce(phys_addr_t phys, char *dma_addr, size_t size,
-		    enum dma_data_direction dir)
+static void swiotlb_bounce(phys_addr_t orig_addr, phys_addr_t tlb_addr,
+			   size_t size, enum dma_data_direction dir)
 {
-	unsigned long pfn = PFN_DOWN(phys);
+	unsigned long pfn = PFN_DOWN(orig_addr);
+	unsigned char *vaddr = phys_to_virt(tlb_addr);
 
 	if (PageHighMem(pfn_to_page(pfn))) {
 		/* The buffer does not have a mapping.  Map it in and copy */
-		unsigned int offset = phys & ~PAGE_MASK;
+		unsigned int offset = orig_addr & ~PAGE_MASK;
 		char *buffer;
 		unsigned int sz = 0;
 		unsigned long flags;
@@ -294,34 +302,33 @@ void swiotlb_bounce(phys_addr_t phys, ch
 			local_irq_save(flags);
 			buffer = kmap_atomic(pfn_to_page(pfn));
 			if (dir == DMA_TO_DEVICE)
-				memcpy(dma_addr, buffer + offset, sz);
+				memcpy(vaddr, buffer + offset, sz);
 			else if (__copy_to_user_inatomic(buffer + offset,
-							 dma_addr, sz))
+							 vaddr, sz))
 				/* inaccessible */;
 			kunmap_atomic(buffer);
 			local_irq_restore(flags);
 
 			size -= sz;
 			pfn++;
-			dma_addr += sz;
+			vaddr += sz;
 			offset = 0;
 		}
-	} else {
-		if (dir == DMA_TO_DEVICE)
-			memcpy(dma_addr, phys_to_virt(phys), size);
-		else if (__copy_to_user_inatomic(phys_to_virt(phys),
-						 dma_addr, size))
-			/* inaccessible */;
+	} else if (dir == DMA_TO_DEVICE) {
+		memcpy(vaddr, phys_to_virt(orig_addr), size);
+	} else if (__copy_to_user_inatomic(phys_to_virt(orig_addr), vaddr,
+					   size)) {
+		/* inaccessible */;
 	}
 }
-EXPORT_SYMBOL_GPL(swiotlb_bounce);
-
-void *swiotlb_tbl_map_single(struct device *hwdev, dma_addr_t tbl_dma_addr,
-			     phys_addr_t phys, size_t size,
-			     enum dma_data_direction dir)
+
+phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,
+				   dma_addr_t tbl_dma_addr,
+				   phys_addr_t orig_addr, size_t size,
+				   enum dma_data_direction dir)
 {
 	unsigned long flags;
-	char *dma_addr;
+	phys_addr_t tlb_addr;
 	unsigned int nslots, stride, index, wrap;
 	int i;
 	unsigned long mask;
@@ -382,7 +389,7 @@ void *swiotlb_tbl_map_single(struct devi
 				io_tlb_list[i] = 0;
 			for (i = index - 1; (OFFSET(i, IO_TLB_SEGSIZE) != IO_TLB_SEGSIZE - 1) && io_tlb_list[i]; i--)
 				io_tlb_list[i] = ++count;
-			dma_addr = io_tlb_start + (index << IO_TLB_SHIFT);
+			tlb_addr = io_tlb_start + (index << IO_TLB_SHIFT);
 
 			/*
 			 * Update the indices to avoid searching in the next
@@ -400,7 +407,7 @@ void *swiotlb_tbl_map_single(struct devi
 
 not_found:
 	spin_unlock_irqrestore(&io_tlb_lock, flags);
-	return NULL;
+	return SWIOTLB_MAP_ERROR;
 found:
 	spin_unlock_irqrestore(&io_tlb_lock, flags);
 
@@ -410,11 +417,11 @@ found:
 	 * needed.
 	 */
 	for (i = 0; i < nslots; i++)
-		io_tlb_orig_addr[index+i] = phys + (i << IO_TLB_SHIFT);
+		io_tlb_orig_addr[index+i] = orig_addr + (i << IO_TLB_SHIFT);
 	if (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)
-		swiotlb_bounce(phys, dma_addr, size, DMA_TO_DEVICE);
+		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_TO_DEVICE);
 
-	return dma_addr;
+	return tlb_addr;
 }
 EXPORT_SYMBOL_GPL(swiotlb_tbl_map_single);
 
@@ -422,11 +429,10 @@ EXPORT_SYMBOL_GPL(swiotlb_tbl_map_single
  * Allocates bounce buffer and returns its kernel virtual address.
  */
 
-static void *
-map_single(struct device *hwdev, phys_addr_t phys, size_t size,
-	   enum dma_data_direction dir)
+phys_addr_t map_single(struct device *hwdev, phys_addr_t phys, size_t size,
+		       enum dma_data_direction dir)
 {
-	dma_addr_t start_dma_addr = swiotlb_virt_to_bus(hwdev, io_tlb_start);
+	dma_addr_t start_dma_addr = phys_to_dma(hwdev, io_tlb_start);
 
 	return swiotlb_tbl_map_single(hwdev, start_dma_addr, phys, size, dir);
 }
@@ -434,20 +440,19 @@ map_single(struct device *hwdev, phys_ad
 /*
  * dma_addr is the kernel virtual address of the bounce buffer to unmap.
  */
-void
-swiotlb_tbl_unmap_single(struct device *hwdev, char *dma_addr, size_t size,
-			enum dma_data_direction dir)
+void swiotlb_tbl_unmap_single(struct device *hwdev, phys_addr_t tlb_addr,
+			      size_t size, enum dma_data_direction dir)
 {
 	unsigned long flags;
 	int i, count, nslots = ALIGN(size, 1 << IO_TLB_SHIFT) >> IO_TLB_SHIFT;
-	int index = (dma_addr - io_tlb_start) >> IO_TLB_SHIFT;
-	phys_addr_t phys = io_tlb_orig_addr[index];
+	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
+	phys_addr_t orig_addr = io_tlb_orig_addr[index];
 
 	/*
 	 * First, sync the memory before unmapping the entry
 	 */
-	if (phys && ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))
-		swiotlb_bounce(phys, dma_addr, size, DMA_FROM_DEVICE);
+	if (orig_addr && ((dir == DMA_FROM_DEVICE) || (dir == DMA_BIDIRECTIONAL)))
+		swiotlb_bounce(orig_addr, tlb_addr, size, DMA_FROM_DEVICE);
 
 	/*
 	 * Return the buffer to the free list by setting the corresponding
@@ -479,26 +484,27 @@ swiotlb_tbl_unmap_single(struct device *
 }
 EXPORT_SYMBOL_GPL(swiotlb_tbl_unmap_single);
 
-void
-swiotlb_tbl_sync_single(struct device *hwdev, char *dma_addr, size_t size,
-			enum dma_data_direction dir,
-			enum dma_sync_target target)
+void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,
+			     size_t size, enum dma_data_direction dir,
+			     enum dma_sync_target target)
 {
-	int index = (dma_addr - io_tlb_start) >> IO_TLB_SHIFT;
-	phys_addr_t phys = io_tlb_orig_addr[index];
+	int index = (tlb_addr - io_tlb_start) >> IO_TLB_SHIFT;
+	phys_addr_t orig_addr = io_tlb_orig_addr[index];
 
-	phys += ((unsigned long)dma_addr & ((1 << IO_TLB_SHIFT) - 1));
+	orig_addr += (unsigned long)tlb_addr & ((1 << IO_TLB_SHIFT) - 1);
 
 	switch (target) {
 	case SYNC_FOR_CPU:
 		if (likely(dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))
-			swiotlb_bounce(phys, dma_addr, size, DMA_FROM_DEVICE);
+			swiotlb_bounce(orig_addr, tlb_addr,
+				       size, DMA_FROM_DEVICE);
 		else
 			BUG_ON(dir != DMA_TO_DEVICE);
 		break;
 	case SYNC_FOR_DEVICE:
 		if (likely(dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL))
-			swiotlb_bounce(phys, dma_addr, size, DMA_TO_DEVICE);
+			swiotlb_bounce(orig_addr, tlb_addr,
+				       size, DMA_TO_DEVICE);
 		else
 			BUG_ON(dir != DMA_FROM_DEVICE);
 		break;
@@ -545,9 +551,8 @@ dma_addr_t swiotlb_map_page(struct devic
 			    enum dma_data_direction dir,
 			    struct dma_attrs *attrs)
 {
-	phys_addr_t phys = page_to_pseudophys(page) + offset;
+	phys_addr_t map, phys = page_to_pseudophys(page) + offset;
 	dma_addr_t dev_addr = gnttab_dma_map_page(page, offset);
-	void *map;
 
 	BUG_ON(dir == DMA_NONE);
 
@@ -560,24 +565,20 @@ dma_addr_t swiotlb_map_page(struct devic
 	    !range_needs_mapping(phys, size))
 		return dev_addr;
 
-	/*
-	 * Oh well, have to allocate and map a bounce buffer.
-	 */
+	/* Oh well, have to allocate and map a bounce buffer. */
 	gnttab_dma_unmap_page(dev_addr);
 	map = map_single(dev, phys, size, dir);
-	if (!map) {
+	if (map == SWIOTLB_MAP_ERROR) {
 		swiotlb_full(dev, size, dir, 1);
-		map = io_tlb_overflow_buffer;
+		return phys_to_dma(dev, io_tlb_overflow_buffer);
 	}
 
-	dev_addr = swiotlb_virt_to_bus(dev, map);
+	dev_addr = phys_to_dma(dev, map);
 
-	/*
-	 * Ensure that the address returned is DMA'ble
-	 */
+	/* Ensure that the address returned is DMA'ble */
 	if (!dma_capable(dev, dev_addr, size)) {
 		swiotlb_tbl_unmap_single(dev, map, size, dir);
-		dev_addr = swiotlb_virt_to_bus(dev, io_tlb_overflow_buffer);
+		return phys_to_dma(dev, io_tlb_overflow_buffer);
 	}
 
 	return dev_addr;
@@ -600,7 +601,7 @@ static void unmap_single(struct device *
 	BUG_ON(dir == DMA_NONE);
 
 	if (is_swiotlb_buffer(dev_addr)) {
-		swiotlb_tbl_unmap_single(hwdev, phys_to_virt(paddr), size, dir);
+		swiotlb_tbl_unmap_single(hwdev, paddr, size, dir);
 		return;
 	}
 
@@ -635,8 +636,7 @@ swiotlb_sync_single(struct device *hwdev
 	BUG_ON(dir == DMA_NONE);
 
 	if (is_swiotlb_buffer(dev_addr))
-		swiotlb_tbl_sync_single(hwdev, phys_to_virt(paddr), size, dir,
-				       target);
+		swiotlb_tbl_sync_single(hwdev, paddr, size, dir, target);
 }
 
 void
@@ -688,12 +688,12 @@ swiotlb_map_sg_attrs(struct device *hwde
 
 		if (range_needs_mapping(paddr, sg->length) ||
 		    !dma_capable(hwdev, dev_addr, sg->length)) {
-			void *map;
+			phys_addr_t map;
 
 			gnttab_dma_unmap_page(dev_addr);
 			map = map_single(hwdev, paddr,
 					 sg->length, dir);
-			if (!map) {
+			if (map == SWIOTLB_MAP_ERROR) {
 				/* Don't panic here, we expect map_sg users
 				   to do proper error handling. */
 				swiotlb_full(hwdev, sg->length, dir, 0);
@@ -702,7 +702,7 @@ swiotlb_map_sg_attrs(struct device *hwde
 				sgl[0].dma_length = 0;
 				return 0;
 			}
-			sg->dma_address = swiotlb_virt_to_bus(hwdev, map);
+			sg->dma_address = phys_to_dma(hwdev, map);
 		} else
 			sg->dma_address = dev_addr;
 		sg->dma_length = sg->length;
@@ -785,7 +785,7 @@ EXPORT_SYMBOL(swiotlb_sync_sg_for_device
 int
 swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
 {
-	return (dma_addr == swiotlb_virt_to_bus(hwdev, io_tlb_overflow_buffer));
+	return (dma_addr == phys_to_dma(hwdev, io_tlb_overflow_buffer));
 }
 EXPORT_SYMBOL(swiotlb_dma_mapping_error);
 

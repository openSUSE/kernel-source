From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 3.14
Patch-mainline: 3.14

 This patch contains the differences between 3.13 and 3.14.

Automatically created from "patch-3.14" by xen-port-patches.py
Acked-by: jbeulich@suse.com

--- head.orig/arch/x86/include/asm/topology.h	2011-04-13 11:31:41.000000000 +0200
+++ head/arch/x86/include/asm/topology.h	2014-04-01 11:55:17.000000000 +0200
@@ -119,8 +119,10 @@ static inline void setup_node_to_cpumask
 
 extern const struct cpumask *cpu_coregroup_mask(int cpu);
 
+#ifndef CONFIG_XEN
 #define topology_physical_package_id(cpu)	(cpu_data(cpu).phys_proc_id)
 #define topology_core_id(cpu)			(cpu_data(cpu).cpu_core_id)
+#endif
 
 #ifdef ENABLE_TOPO_DEFINES
 #define topology_core_cpumask(cpu)		(per_cpu(cpu_core_map, cpu))
--- head.orig/arch/x86/include/mach-xen/asm/fixmap.h	2013-08-12 13:00:59.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/fixmap.h	2014-02-20 10:49:08.000000000 +0100
@@ -180,64 +180,7 @@ static inline void __set_fixmap(enum fix
 	xen_set_fixmap(idx, phys, flags);
 }
 
-#define set_fixmap(idx, phys)				\
-	__set_fixmap(idx, phys, PAGE_KERNEL)
-
-/*
- * Some hardware wants to get fixmapped without caching.
- */
-#define set_fixmap_nocache(idx, phys)			\
-	__set_fixmap(idx, phys, PAGE_KERNEL_NOCACHE)
-
-#define clear_fixmap(idx)			\
-	__set_fixmap(idx, 0, __pgprot(0))
-
-#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
-#define __virt_to_fix(x)	((FIXADDR_TOP - ((x)&PAGE_MASK)) >> PAGE_SHIFT)
-
-extern void __this_fixmap_does_not_exist(void);
-
-/*
- * 'index to address' translation. If anyone tries to use the idx
- * directly without translation, we catch the bug with a NULL-deference
- * kernel oops. Illegal ranges of incoming indices are caught too.
- */
-static __always_inline unsigned long fix_to_virt(const unsigned int idx)
-{
-	/*
-	 * this branch gets completely eliminated after inlining,
-	 * except when someone tries to use fixaddr indices in an
-	 * illegal way. (such as mixing up address types or using
-	 * out-of-range indices).
-	 *
-	 * If it doesn't get removed, the linker will complain
-	 * loudly with a reasonably clear error message..
-	 */
-	if (idx >= __end_of_fixed_addresses)
-		__this_fixmap_does_not_exist();
-
-	return __fix_to_virt(idx);
-}
-
-static inline unsigned long virt_to_fix(const unsigned long vaddr)
-{
-	BUG_ON(vaddr >= FIXADDR_TOP || vaddr < FIXADDR_START);
-	return __virt_to_fix(vaddr);
-}
-
-/* Return an pointer with offset calculated */
-static __always_inline unsigned long
-__set_fixmap_offset(enum fixed_addresses idx, phys_addr_t phys, pgprot_t flags)
-{
-	__set_fixmap(idx, phys, flags);
-	return fix_to_virt(idx) + (phys & (PAGE_SIZE - 1));
-}
-
-#define set_fixmap_offset(idx, phys)			\
-	__set_fixmap_offset(idx, phys, PAGE_KERNEL)
-
-#define set_fixmap_offset_nocache(idx, phys)			\
-	__set_fixmap_offset(idx, phys, PAGE_KERNEL_NOCACHE)
+#include <asm-generic/fixmap.h>
 
 #endif /* !__ASSEMBLY__ */
 #endif /* _ASM_X86_FIXMAP_H */
--- head.orig/arch/x86/include/mach-xen/asm/io.h	2013-08-12 13:00:59.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/io.h	2014-04-01 11:49:42.000000000 +0200
@@ -233,7 +233,7 @@ memcpy_toio(volatile void __iomem *dst, 
 
 static inline void flush_write_buffers(void)
 {
-#if defined(CONFIG_X86_OOSTORE) || defined(CONFIG_X86_PPRO_FENCE)
+#if defined(CONFIG_X86_PPRO_FENCE)
 	asm volatile("lock; addl $0,0(%%esp)": : :"memory");
 #endif
 }
--- head.orig/arch/x86/include/mach-xen/asm/pci.h	2014-02-13 12:47:14.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/pci.h	2014-02-20 10:49:08.000000000 +0100
@@ -110,7 +110,7 @@ extern void pci_iommu_alloc(void);
 struct msi_desc;
 int native_setup_msi_irqs(struct pci_dev *dev, int nvec, int type);
 void native_teardown_msi_irq(unsigned int irq);
-void native_restore_msi_irqs(struct pci_dev *dev, int irq);
+void native_restore_msi_irqs(struct pci_dev *dev);
 int setup_msi_irq(struct pci_dev *dev, struct msi_desc *msidesc,
 		  unsigned int irq_base, unsigned int irq_offset);
 #else
@@ -131,7 +131,6 @@ int setup_msi_irq(struct pci_dev *dev, s
 
 /* generic pci stuff */
 #include <asm-generic/pci.h>
-#define PCIBIOS_MAX_MEM_32 0xffffffff
 
 #ifdef CONFIG_NUMA
 /* Returns the node based on pci bus */
--- head.orig/arch/x86/include/mach-xen/asm/pgtable_64_types.h	2013-03-25 09:13:57.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/pgtable_64_types.h	2014-02-20 10:49:08.000000000 +0100
@@ -59,7 +59,7 @@ typedef union { pteval_t pte; unsigned i
 #define VMALLOC_START    _AC(0xffffc90000000000, UL)
 #define VMALLOC_END      _AC(0xffffe8ffffffffff, UL)
 #define VMEMMAP_START	 _AC(0xffffea0000000000, UL)
-#define MODULES_VADDR    _AC(0xffffffffa0000000, UL)
+#define MODULES_VADDR    (__START_KERNEL_map + KERNEL_IMAGE_SIZE)
 #define MODULES_END      _AC(0xffffffffff000000, UL)
 #define MODULES_LEN   (MODULES_END - MODULES_VADDR)
 
--- head.orig/arch/x86/include/mach-xen/asm/pgtable_types.h	2013-09-26 15:33:39.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/pgtable_types.h	2014-02-20 10:49:08.000000000 +0100
@@ -129,7 +129,8 @@ extern unsigned int __kernel_page_user;
 
 /* Set of bits not changed in pte_modify */
 #define _PAGE_CHG_MASK	(PTE_PFN_MASK | _PAGE_CACHE_MASK | _PAGE_IOMAP | \
-			 _PAGE_SPECIAL | _PAGE_ACCESSED | _PAGE_DIRTY)
+			 _PAGE_SPECIAL | _PAGE_ACCESSED | _PAGE_DIRTY |	\
+			 _PAGE_SOFT_DIRTY)
 #define _HPAGE_CHG_MASK (_PAGE_CHG_MASK | _PAGE_PSE)
 
 /*
@@ -437,7 +438,8 @@ static inline void update_page_count(int
  */
 extern pte_t *lookup_address(unsigned long address, unsigned int *level);
 extern phys_addr_t slow_virt_to_phys(void *__address);
-
+extern int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,
+				   unsigned numpages, unsigned long page_flags);
 #endif	/* !__ASSEMBLY__ */
 
 #endif /* _ASM_X86_PGTABLE_DEFS_H */
--- head.orig/arch/x86/include/mach-xen/asm/processor.h	2013-12-06 15:23:26.000000000 +0100
+++ head/arch/x86/include/mach-xen/asm/processor.h	2014-02-20 10:49:08.000000000 +0100
@@ -27,7 +27,6 @@ struct mm_struct;
 #include <linux/cache.h>
 #include <linux/threads.h>
 #include <linux/math64.h>
-#include <linux/init.h>
 #include <linux/err.h>
 #include <linux/irqflags.h>
 
@@ -74,6 +73,7 @@ extern u16 __read_mostly tlb_lli_4m[NR_I
 extern u16 __read_mostly tlb_lld_4k[NR_INFO];
 extern u16 __read_mostly tlb_lld_2m[NR_INFO];
 extern u16 __read_mostly tlb_lld_4m[NR_INFO];
+extern u16 __read_mostly tlb_lld_1g[NR_INFO];
 extern s8  __read_mostly tlb_flushall_shift;
 
 /*
@@ -386,6 +386,20 @@ struct ymmh_struct {
 	u32 ymmh_space[64];
 };
 
+/* We don't support LWP yet: */
+struct lwp_struct {
+	u8 reserved[128];
+};
+
+struct bndregs_struct {
+	u64 bndregs[8];
+} __packed;
+
+struct bndcsr_struct {
+	u64 cfg_reg_u;
+	u64 status_reg;
+} __packed;
+
 struct xsave_hdr_struct {
 	u64 xstate_bv;
 	u64 reserved1[2];
@@ -396,6 +410,9 @@ struct xsave_struct {
 	struct i387_fxsave_struct i387;
 	struct xsave_hdr_struct xsave_hdr;
 	struct ymmh_struct ymmh;
+	struct lwp_struct lwp;
+	struct bndregs_struct bndregs;
+	struct bndcsr_struct bndcsr;
 	/* new processor state extensions will go here */
 } __attribute__ ((packed, aligned (64)));
 
@@ -699,29 +716,6 @@ static inline void sync_core(void)
 #endif
 }
 
-static inline void __monitor(const void *eax, unsigned long ecx,
-			     unsigned long edx)
-{
-	/* "monitor %eax, %ecx, %edx;" */
-	asm volatile(".byte 0x0f, 0x01, 0xc8;"
-		     :: "a" (eax), "c" (ecx), "d"(edx));
-}
-
-static inline void __mwait(unsigned long eax, unsigned long ecx)
-{
-	/* "mwait %eax, %ecx;" */
-	asm volatile(".byte 0x0f, 0x01, 0xc9;"
-		     :: "a" (eax), "c" (ecx));
-}
-
-static inline void __sti_mwait(unsigned long eax, unsigned long ecx)
-{
-	trace_hardirqs_on();
-	/* "mwait %eax, %ecx;" */
-	asm volatile("sti; .byte 0x0f, 0x01, 0xc9;"
-		     :: "a" (eax), "c" (ecx));
-}
-
 extern void select_idle_routine(const struct cpuinfo_x86 *c);
 extern void init_amd_e400_c1e_mask(void);
 
--- head.orig/arch/x86/include/mach-xen/asm/smp.h	2013-08-12 13:00:59.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/smp.h	2014-02-20 10:49:08.000000000 +0100
@@ -2,7 +2,6 @@
 #define _ASM_X86_SMP_H
 #ifndef __ASSEMBLY__
 #include <linux/cpumask.h>
-#include <linux/init.h>
 #include <asm/percpu.h>
 
 /*
--- head.orig/arch/x86/include/mach-xen/asm/spinlock.h	2013-09-26 15:42:51.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/spinlock.h	2014-04-01 11:49:42.000000000 +0200
@@ -23,14 +23,13 @@
 # define LOCK_PTR_REG "D"
 #endif
 
-#if defined(CONFIG_XEN) || (defined(CONFIG_X86_32) && \
-	(defined(CONFIG_X86_OOSTORE) || defined(CONFIG_X86_PPRO_FENCE)))
+#if defined(CONFIG_XEN) || (defined(CONFIG_X86_32) && defined(CONFIG_X86_PPRO_FENCE))
 /*
  * On Xen, as we read back the result of the unlocking increment, we must use
  * a locked access (or insert a full memory barrier) in all cases (so that we
  * read what is globally visible).
  *
- * On PPro SMP or if we are using OOSTORE, we use a locked operation to unlock
+ * On PPro SMP, we use a locked operation to unlock
  * (PPro errata 66, 92)
  */
 # define UNLOCK_LOCK_PREFIX LOCK_PREFIX
--- head.orig/arch/x86/include/mach-xen/asm/tlbflush.h	2013-10-10 17:49:53.000000000 +0200
+++ head/arch/x86/include/mach-xen/asm/tlbflush.h	2014-02-20 10:49:08.000000000 +0100
@@ -19,7 +19,7 @@ static inline void __flush_tlb_all(void)
 
 static inline void __flush_tlb_one(unsigned long addr)
 {
-	count_vm_event(NR_TLB_LOCAL_FLUSH_ONE);
+	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
 	__flush_tlb_single(addr);
 }
 
@@ -49,13 +49,13 @@ static inline void __flush_tlb_one(unsig
  */
 static inline void __flush_tlb_up(void)
 {
-	count_vm_event(NR_TLB_LOCAL_FLUSH_ALL);
+	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
 	__flush_tlb();
 }
 
 static inline void flush_tlb_all(void)
 {
-	count_vm_event(NR_TLB_LOCAL_FLUSH_ALL);
+	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
 	__flush_tlb_all();
 }
 
--- head.orig/arch/x86/kernel/Makefile	2013-12-13 10:00:50.000000000 +0100
+++ head/arch/x86/kernel/Makefile	2014-02-21 08:29:03.000000000 +0100
@@ -122,5 +122,6 @@ ifeq ($(CONFIG_X86_64),y)
 endif
 
 disabled-obj-$(CONFIG_XEN) := crash.o early-quirks.o i8237.o i8253.o i8259.o \
-	irqinit.o pci-swiotlb.o reboot.o smpboot.o trampoline%.o tsc%.o vsmp%.o
+	irqinit.o ksysfs.o pci-swiotlb.o reboot.o smpboot.o trampoline%.o \
+	tsc%.o vsmp%.o
 disabled-obj-$(CONFIG_XEN_UNPRIVILEGED_GUEST) += probe_roms.o
--- head.orig/arch/x86/kernel/apic/io_apic-xen.c	2014-09-03 08:53:04.000000000 +0200
+++ head/arch/x86/kernel/apic/io_apic-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -36,9 +36,6 @@ struct msi_msg; /* #include <linux/msi.h
 #include <linux/kthread.h>
 #include <linux/jiffies.h>	/* time_after() */
 #include <linux/slab.h>
-#ifdef CONFIG_ACPI
-#include <acpi/acpi_bus.h>
-#endif
 #include <linux/bootmem.h>
 
 #include <asm/idle.h>
@@ -1201,9 +1198,10 @@ next:
 		if (test_bit(vector, used_vectors))
 			goto next;
 
-		for_each_cpu_and(new_cpu, tmp_mask, cpu_online_mask)
-			if (per_cpu(vector_irq, new_cpu)[vector] != -1)
+		for_each_cpu_and(new_cpu, tmp_mask, cpu_online_mask) {
+			if (per_cpu(vector_irq, new_cpu)[vector] > VECTOR_UNDEFINED)
 				goto next;
+		}
 		/* Found one! */
 		current_vector = vector;
 		current_offset = offset;
@@ -1242,7 +1240,7 @@ static void __clear_irq_vector(int irq, 
 
 	vector = cfg->vector;
 	for_each_cpu_and(cpu, cfg->domain, cpu_online_mask)
-		per_cpu(vector_irq, cpu)[vector] = -1;
+		per_cpu(vector_irq, cpu)[vector] = VECTOR_UNDEFINED;
 
 	cfg->vector = 0;
 	cpumask_clear(cfg->domain);
@@ -1250,11 +1248,10 @@ static void __clear_irq_vector(int irq, 
 	if (likely(!cfg->move_in_progress))
 		return;
 	for_each_cpu_and(cpu, cfg->old_domain, cpu_online_mask) {
-		for (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS;
-								vector++) {
+		for (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS; vector++) {
 			if (per_cpu(vector_irq, cpu)[vector] != irq)
 				continue;
-			per_cpu(vector_irq, cpu)[vector] = -1;
+			per_cpu(vector_irq, cpu)[vector] = VECTOR_UNDEFINED;
 			break;
 		}
 	}
@@ -1287,12 +1284,12 @@ void __setup_vector_irq(int cpu)
 	/* Mark the free vectors */
 	for (vector = 0; vector < NR_VECTORS; ++vector) {
 		irq = per_cpu(vector_irq, cpu)[vector];
-		if (irq < 0)
+		if (irq <= VECTOR_UNDEFINED)
 			continue;
 
 		cfg = irq_cfg(irq);
 		if (!cpumask_test_cpu(cpu, cfg->domain))
-			per_cpu(vector_irq, cpu)[vector] = -1;
+			per_cpu(vector_irq, cpu)[vector] = VECTOR_UNDEFINED;
 	}
 	raw_spin_unlock(&vector_lock);
 }
@@ -2289,13 +2286,13 @@ asmlinkage void smp_irq_move_cleanup_int
 
 	me = smp_processor_id();
 	for (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS; vector++) {
-		unsigned int irq;
+		int irq;
 		unsigned int irr;
 		struct irq_desc *desc;
 		struct irq_cfg *cfg;
 		irq = __this_cpu_read(vector_irq[vector]);
 
-		if (irq == -1)
+		if (irq <= VECTOR_UNDEFINED)
 			continue;
 
 		desc = irq_to_desc(irq);
--- head.orig/arch/x86/kernel/cpu/common-xen.c	2013-12-06 15:23:26.000000000 +0100
+++ head/arch/x86/kernel/cpu/common-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -304,8 +304,13 @@ static __always_inline void setup_smap(s
 	raw_local_save_flags(eflags);
 	BUG_ON(eflags & X86_EFLAGS_AC);
 
-	if (cpu_has(c, X86_FEATURE_SMAP))
+	if (cpu_has(c, X86_FEATURE_SMAP)) {
+#ifdef CONFIG_X86_SMAP
 		set_in_cr4(X86_CR4_SMAP);
+#else
+		clear_in_cr4(X86_CR4_SMAP);
+#endif
+	}
 }
 
 /*
@@ -514,6 +519,7 @@ u16 __read_mostly tlb_lli_4m[NR_INFO];
 u16 __read_mostly tlb_lld_4k[NR_INFO];
 u16 __read_mostly tlb_lld_2m[NR_INFO];
 u16 __read_mostly tlb_lld_4m[NR_INFO];
+u16 __read_mostly tlb_lld_1g[NR_INFO];
 
 /*
  * tlb_flushall_shift shows the balance point in replacing cr3 write
@@ -528,13 +534,13 @@ void cpu_detect_tlb(struct cpuinfo_x86 *
 	if (this_cpu->c_detect_tlb)
 		this_cpu->c_detect_tlb(c);
 
-	printk(KERN_INFO "Last level iTLB entries: 4KB %d, 2MB %d, 4MB %d\n" \
-		"Last level dTLB entries: 4KB %d, 2MB %d, 4MB %d\n"	     \
+	printk(KERN_INFO "Last level iTLB entries: 4KB %d, 2MB %d, 4MB %d\n"
+		"Last level dTLB entries: 4KB %d, 2MB %d, 4MB %d, 1GB %d\n"
 		"tlb_flushall_shift: %d\n",
 		tlb_lli_4k[ENTRIES], tlb_lli_2m[ENTRIES],
 		tlb_lli_4m[ENTRIES], tlb_lld_4k[ENTRIES],
 		tlb_lld_2m[ENTRIES], tlb_lld_4m[ENTRIES],
-		tlb_flushall_shift);
+		tlb_lld_1g[ENTRIES], tlb_flushall_shift);
 }
 
 void detect_ht(struct cpuinfo_x86 *c)
--- head.orig/arch/x86/kernel/e820-xen.c	2013-09-26 15:33:39.000000000 +0200
+++ head/arch/x86/kernel/e820-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -1249,7 +1249,7 @@ void __init memblock_find_dma_reserve(vo
 		nr_pages += end_pfn - start_pfn;
 	}
 
-	for_each_free_mem_range(u, MAX_NUMNODES, &start, &end, NULL) {
+	for_each_free_mem_range(u, NUMA_NO_NODE, &start, &end, NULL) {
 		start_pfn = min_t(unsigned long, PFN_UP(start), MAX_DMA_PFN);
 		end_pfn = min_t(unsigned long, PFN_DOWN(end), MAX_DMA_PFN);
 		if (start_pfn < end_pfn)
--- head.orig/arch/x86/kernel/irq-xen.c	2013-12-13 09:41:27.000000000 +0100
+++ head/arch/x86/kernel/irq-xen.c	2014-09-19 11:12:37.000000000 +0200
@@ -212,9 +212,13 @@ __visible unsigned int __irq_entry do_IR
 	if (!handle_irq(irq, regs)) {
 		ack_APIC_irq();
 
-		if (printk_ratelimit())
-			pr_emerg("%s: %d.%d No irq handler for vector (irq %d)\n",
-				__func__, smp_processor_id(), vector, irq);
+		if (irq != VECTOR_RETRIGGERED) {
+			pr_emerg_ratelimited("%s: %d.%d No irq handler for vector (irq %d)\n",
+					     __func__, smp_processor_id(),
+					     vector, irq);
+		} else {
+			__this_cpu_write(vector_irq[vector], VECTOR_UNDEFINED);
+		}
 	}
 
 	irq_exit();
@@ -283,6 +287,85 @@ EXPORT_SYMBOL_GPL(vector_used_by_percpu_
 
 #ifdef CONFIG_HOTPLUG_CPU
 #include <xen/evtchn.h>
+
+#ifndef CONFIG_XEN
+/* These two declarations are only used in check_irq_vectors_for_cpu_disable()
+ * below, which is protected by stop_machine().  Putting them on the stack
+ * results in a stack frame overflow.  Dynamically allocating could result in a
+ * failure so declare these two cpumasks as global.
+ */
+static struct cpumask affinity_new, online_new;
+
+/*
+ * This cpu is going to be removed and its vectors migrated to the remaining
+ * online cpus.  Check to see if there are enough vectors in the remaining cpus.
+ * This function is protected by stop_machine().
+ */
+int check_irq_vectors_for_cpu_disable(void)
+{
+	int irq, cpu;
+	unsigned int this_cpu, vector, this_count, count;
+	struct irq_desc *desc;
+	struct irq_data *data;
+
+	this_cpu = smp_processor_id();
+	cpumask_copy(&online_new, cpu_online_mask);
+	cpu_clear(this_cpu, online_new);
+
+	this_count = 0;
+	for (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS; vector++) {
+		irq = __this_cpu_read(vector_irq[vector]);
+		if (irq >= 0) {
+			desc = irq_to_desc(irq);
+			data = irq_desc_get_irq_data(desc);
+			cpumask_copy(&affinity_new, data->affinity);
+			cpu_clear(this_cpu, affinity_new);
+
+			/* Do not count inactive or per-cpu irqs. */
+			if (!irq_has_action(irq) || irqd_is_per_cpu(data))
+				continue;
+
+			/*
+			 * A single irq may be mapped to multiple
+			 * cpu's vector_irq[] (for example IOAPIC cluster
+			 * mode).  In this case we have two
+			 * possibilities:
+			 *
+			 * 1) the resulting affinity mask is empty; that is
+			 * this the down'd cpu is the last cpu in the irq's
+			 * affinity mask, or
+			 *
+			 * 2) the resulting affinity mask is no longer
+			 * a subset of the online cpus but the affinity
+			 * mask is not zero; that is the down'd cpu is the
+			 * last online cpu in a user set affinity mask.
+			 */
+			if (cpumask_empty(&affinity_new) ||
+			    !cpumask_subset(&affinity_new, &online_new))
+				this_count++;
+		}
+	}
+
+	count = 0;
+	for_each_online_cpu(cpu) {
+		if (cpu == this_cpu)
+			continue;
+		for (vector = FIRST_EXTERNAL_VECTOR; vector < NR_VECTORS;
+		     vector++) {
+			if (per_cpu(vector_irq, cpu)[vector] < 0)
+				count++;
+		}
+	}
+
+	if (count < this_count) {
+		pr_warn("CPU %d disable failed: CPU has %u vectors assigned and there are only %u available.\n",
+			this_cpu, this_count, count);
+		return -ERANGE;
+	}
+	return 0;
+}
+#endif
+
 /* A cpu has been removed from cpu_online_mask.  Reset irq affinities. */
 void fixup_irqs(void)
 {
--- head.orig/arch/x86/kernel/pci-dma-xen.c	2013-02-06 15:28:03.000000000 +0100
+++ head/arch/x86/kernel/pci-dma-xen.c	2014-02-24 14:47:01.000000000 +0100
@@ -139,8 +139,10 @@ again:
 	flag &= ~(__GFP_DMA | __GFP_DMA32);
 #endif
 	page = NULL;
-	if (!(flag & GFP_ATOMIC))
+	/* CMA can be used only in the context which permits sleeping */
+	if (flag & __GFP_WAIT)
 		page = dma_alloc_from_contiguous(dev, count, order);
+	/* fallback */
 	if (!page)
 		page = alloc_pages_node(dev_to_node(dev), flag, order);
 	if (!page)
--- head.orig/arch/x86/kernel/process_32-xen.c	2013-12-06 15:23:26.000000000 +0100
+++ head/arch/x86/kernel/process_32-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -24,7 +24,6 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/reboot.h>
-#include <linux/init.h>
 #include <linux/mc146818rtc.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
--- head.orig/arch/x86/kernel/setup-xen.c	2013-12-06 15:23:26.000000000 +0100
+++ head/arch/x86/kernel/setup-xen.c	2014-03-11 10:48:09.000000000 +0100
@@ -330,6 +330,10 @@ static void __init reserve_brk(void)
 	_brk_start = 0;
 }
 
+#ifndef CONFIG_XEN
+u64 relocated_ramdisk;
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 
 static u64 __init get_ramdisk_image(void)
@@ -365,25 +369,24 @@ static void __init relocate_initrd(void)
 	u64 ramdisk_image = get_ramdisk_image();
 	u64 ramdisk_size  = get_ramdisk_size();
 	u64 area_size     = PAGE_ALIGN(ramdisk_size);
-	u64 ramdisk_here;
 	unsigned long slop, clen, mapaddr;
 	char *p, *q;
 
 	/* We need to move the initrd down into directly mapped mem */
-	ramdisk_here = memblock_find_in_range(0, PFN_PHYS(max_pfn_mapped),
-						 area_size, PAGE_SIZE);
+	relocated_ramdisk = memblock_find_in_range(0, PFN_PHYS(max_pfn_mapped),
+						   area_size, PAGE_SIZE);
 
-	if (!ramdisk_here)
+	if (!relocated_ramdisk)
 		panic("Cannot find place for new RAMDISK of size %lld\n",
-			 ramdisk_size);
+		      ramdisk_size);
 
 	/* Note: this includes all the mem currently occupied by
 	   the initrd, we rely on that fact to keep the data intact. */
-	memblock_reserve(ramdisk_here, area_size);
-	initrd_start = ramdisk_here + PAGE_OFFSET;
+	memblock_reserve(relocated_ramdisk, area_size);
+	initrd_start = relocated_ramdisk + PAGE_OFFSET;
 	initrd_end   = initrd_start + ramdisk_size;
 	printk(KERN_INFO "Allocated new RAMDISK: [mem %#010llx-%#010llx]\n",
-			 ramdisk_here, ramdisk_here + ramdisk_size - 1);
+	       relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);
 
 	q = (char *)initrd_start;
 
@@ -407,7 +410,7 @@ static void __init relocate_initrd(void)
 	printk(KERN_INFO "Move RAMDISK from [mem %#010llx-%#010llx] to"
 		" [mem %#010llx-%#010llx]\n",
 		ramdisk_image, ramdisk_image + ramdisk_size - 1,
-		ramdisk_here, ramdisk_here + ramdisk_size - 1);
+		relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);
 #else
 	printk(KERN_ERR "initrd extends beyond end of memory "
 	       "(%#010Lx > %#010Lx)\ndisabling initrd\n",
@@ -510,6 +513,9 @@ static void __init parse_setup_data(void
 		case SETUP_DTB:
 			add_dtb(pa_data);
 			break;
+		case SETUP_EFI:
+			parse_efi_setup(pa_data, data_len);
+			break;
 		default:
 			break;
 		}
@@ -900,6 +906,20 @@ static void __init trim_low_memory_range
 #endif
 
 /*
+ * Dump out kernel offset information on panic.
+ */
+static int
+dump_kernel_offset(struct notifier_block *self, unsigned long v, void *p)
+{
+	pr_emerg("Kernel Offset: 0x%lx from 0x%lx "
+		 "(relocation range: 0x%lx-0x%lx)\n",
+		 (unsigned long)&_text - __START_KERNEL, __START_KERNEL,
+		 __START_KERNEL_map, MODULES_VADDR-1);
+
+	return 0;
+}
+
+/*
  * Determine if we were loaded by an EFI loader.  If so, then we have also been
  * passed the efi memmap, systab, etc., so we should use these data structures
  * for initialization.  Note, the efi init code path is determined by the
@@ -1043,8 +1063,6 @@ void __init setup_arch(char **cmdline_p)
 	iomem_resource.end = (1ULL << boot_cpu_data.x86_phys_bits) - 1;
 	setup_memory_map();
 	parse_setup_data();
-	/* update the e820_saved too */
-	e820_reserve_setup_data();
 
 	copy_edd();
 
@@ -1108,6 +1126,8 @@ void __init setup_arch(char **cmdline_p)
 		early_dump_pci_devices();
 #endif
 
+	/* update the e820_saved too */
+	e820_reserve_setup_data();
 	finish_e820_parsing();
 
 	if (efi_enabled(EFI_BOOT))
@@ -1468,14 +1488,8 @@ void __init setup_arch(char **cmdline_p)
 	register_refined_jiffies(CLOCK_TICK_RATE);
 
 #if defined(CONFIG_EFI) && !defined(CONFIG_XEN)
-	/* Once setup is done above, unmap the EFI memory map on
-	 * mismatched firmware/kernel archtectures since there is no
-	 * support for runtime services.
-	 */
-	if (efi_enabled(EFI_BOOT) && !efi_is_native()) {
-		pr_info("efi: Setup done, disabling due to 32/64-bit mismatch\n");
-		efi_unmap_memmap();
-	}
+	if (efi_enabled(EFI_BOOT))
+		efi_apply_memmap_quirks();
 #endif
 }
 
@@ -1497,6 +1511,18 @@ void __init i386_reserve_resources(void)
 
 #endif /* CONFIG_X86_32 */
 
+static struct notifier_block kernel_offset_notifier = {
+	.notifier_call = dump_kernel_offset
+};
+
+static int __init register_kernel_offset_dumper(void)
+{
+	atomic_notifier_chain_register(&panic_notifier_list,
+					&kernel_offset_notifier);
+	return 0;
+}
+__initcall(register_kernel_offset_dumper);
+
 #ifdef CONFIG_XEN
 static int
 xen_panic_event(struct notifier_block *this, unsigned long event, void *ptr)
--- head.orig/arch/x86/kernel/traps-xen.c	2013-12-13 11:05:57.000000000 +0100
+++ head/arch/x86/kernel/traps-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -217,21 +217,17 @@ dotraplinkage void do_##name(struct pt_r
 	exception_exit(prev_state);					\
 }
 
-DO_ERROR_INFO(X86_TRAP_DE, SIGFPE, "divide error", divide_error, FPE_INTDIV,
-		regs->ip)
-DO_ERROR(X86_TRAP_OF, SIGSEGV, "overflow", overflow)
-DO_ERROR(X86_TRAP_BR, SIGSEGV, "bounds", bounds)
-DO_ERROR_INFO(X86_TRAP_UD, SIGILL, "invalid opcode", invalid_op, ILL_ILLOPN,
-		regs->ip)
-DO_ERROR(X86_TRAP_OLD_MF, SIGFPE, "coprocessor segment overrun",
-		coprocessor_segment_overrun)
-DO_ERROR(X86_TRAP_TS, SIGSEGV, "invalid TSS", invalid_TSS)
-DO_ERROR(X86_TRAP_NP, SIGBUS, "segment not present", segment_not_present)
+DO_ERROR_INFO(X86_TRAP_DE,     SIGFPE,  "divide error",			divide_error,		     FPE_INTDIV, regs->ip )
+DO_ERROR     (X86_TRAP_OF,     SIGSEGV, "overflow",			overflow					  )
+DO_ERROR     (X86_TRAP_BR,     SIGSEGV, "bounds",			bounds						  )
+DO_ERROR_INFO(X86_TRAP_UD,     SIGILL,  "invalid opcode",		invalid_op,		     ILL_ILLOPN, regs->ip )
+DO_ERROR     (X86_TRAP_OLD_MF, SIGFPE,  "coprocessor segment overrun",	coprocessor_segment_overrun			  )
+DO_ERROR     (X86_TRAP_TS,     SIGSEGV, "invalid TSS",			invalid_TSS					  )
+DO_ERROR     (X86_TRAP_NP,     SIGBUS,  "segment not present",		segment_not_present				  )
 #ifdef CONFIG_X86_32
-DO_ERROR(X86_TRAP_SS, SIGBUS, "stack segment", stack_segment)
+DO_ERROR     (X86_TRAP_SS,     SIGBUS,  "stack segment",		stack_segment					  )
 #endif
-DO_ERROR_INFO(X86_TRAP_AC, SIGBUS, "alignment check", alignment_check,
-		BUS_ADRALN, 0)
+DO_ERROR_INFO(X86_TRAP_AC,     SIGBUS,  "alignment check",		alignment_check,	     BUS_ADRALN, 0	  )
 
 #ifdef CONFIG_X86_64
 /* Runs on IST stack */
--- head.orig/arch/x86/mm/fault-xen.c	2014-01-22 14:23:28.000000000 +0100
+++ head/arch/x86/mm/fault-xen.c	2014-03-11 10:48:09.000000000 +0100
@@ -1010,6 +1010,12 @@ static int fault_in_kernel_space(unsigne
 
 static inline bool smap_violation(int error_code, struct pt_regs *regs)
 {
+	if (!IS_ENABLED(CONFIG_X86_SMAP))
+		return false;
+
+	if (!static_cpu_has(X86_FEATURE_SMAP))
+		return false;
+
 	if (error_code & PF_USER)
 		return false;
 
@@ -1023,13 +1029,17 @@ static inline bool smap_violation(int er
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
  * routines.
+ *
+ * This function must have noinline because both callers
+ * {,trace_}do_page_fault() have notrace on. Having this an actual function
+ * guarantees there's a function trace entry.
  */
-static void __kprobes
-__do_page_fault(struct pt_regs *regs, unsigned long error_code)
+static void __kprobes noinline
+__do_page_fault(struct pt_regs *regs, unsigned long error_code,
+		unsigned long address)
 {
 	struct vm_area_struct *vma;
 	struct task_struct *tsk;
-	unsigned long address;
 	struct mm_struct *mm;
 	int fault;
 	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
@@ -1043,9 +1053,6 @@ __do_page_fault(struct pt_regs *regs, un
 	tsk = current;
 	mm = tsk->mm;
 
-	/* Get the faulting address: */
-	address = read_cr2();
-
 	/*
 	 * Detect and handle instructions that would cause a page fault for
 	 * both a tracked kernel page and a userspace page.
@@ -1113,11 +1120,9 @@ __do_page_fault(struct pt_regs *regs, un
 	if (unlikely(error_code & PF_RSVD))
 		pgtable_bad(regs, error_code, address);
 
-	if (static_cpu_has(X86_FEATURE_SMAP)) {
-		if (unlikely(smap_violation(error_code, regs))) {
-			bad_area_nosemaphore(regs, error_code, address);
-			return;
-		}
+	if (unlikely(smap_violation(error_code, regs))) {
+		bad_area_nosemaphore(regs, error_code, address);
+		return;
 	}
 
 	/*
@@ -1270,32 +1275,50 @@ good_area:
 	up_read(&mm->mmap_sem);
 }
 
-dotraplinkage void __kprobes
+dotraplinkage void __kprobes notrace
 do_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
+	unsigned long address = read_cr2(); /* Get the faulting address */
 	enum ctx_state prev_state;
 
+	/*
+	 * We must have this function tagged with __kprobes, notrace and call
+	 * read_cr2() before calling anything else. To avoid calling any kind
+	 * of tracing machinery before we've observed the CR2 value.
+	 *
+	 * exception_{enter,exit}() contain all sorts of tracepoints.
+	 */
+
 	prev_state = exception_enter();
-	__do_page_fault(regs, error_code);
+	__do_page_fault(regs, error_code, address);
 	exception_exit(prev_state);
 }
 
-static void trace_page_fault_entries(struct pt_regs *regs,
+#ifdef CONFIG_TRACING
+static void trace_page_fault_entries(unsigned long address, struct pt_regs *regs,
 				     unsigned long error_code)
 {
 	if (user_mode(regs))
-		trace_page_fault_user(read_cr2(), regs, error_code);
+		trace_page_fault_user(address, regs, error_code);
 	else
-		trace_page_fault_kernel(read_cr2(), regs, error_code);
+		trace_page_fault_kernel(address, regs, error_code);
 }
 
-dotraplinkage void __kprobes
+dotraplinkage void __kprobes notrace
 trace_do_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
+	/*
+	 * The exception_enter and tracepoint processing could
+	 * trigger another page faults (user space callchain
+	 * reading) and destroy the original cr2 value, so read
+	 * the faulting address now.
+	 */
+	unsigned long address = read_cr2();
 	enum ctx_state prev_state;
 
 	prev_state = exception_enter();
-	trace_page_fault_entries(regs, error_code);
-	__do_page_fault(regs, error_code);
+	trace_page_fault_entries(address, regs, error_code);
+	__do_page_fault(regs, error_code, address);
 	exception_exit(prev_state);
 }
+#endif /* CONFIG_TRACING */
--- head.orig/arch/x86/mm/init_32-xen.c	2013-08-12 13:00:59.000000000 +0200
+++ head/arch/x86/mm/init_32-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -656,7 +656,7 @@ void __init initmem_init(void)
 	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1;
 #endif
 
-	memblock_set_node(0, (phys_addr_t)ULLONG_MAX, 0);
+	memblock_set_node(0, (phys_addr_t)ULLONG_MAX, &memblock.memory, 0);
 	sparse_memory_present_with_active_regions(0);
 
 #ifdef CONFIG_FLATMEM
@@ -804,6 +804,9 @@ void __init mem_init(void)
 	BUILD_BUG_ON(VMALLOC_START			>= VMALLOC_END);
 #undef high_memory
 #undef __FIXADDR_TOP
+#ifdef CONFIG_RANDOMIZE_BASE
+	BUILD_BUG_ON(CONFIG_RANDOMIZE_BASE_MAX_OFFSET > KERNEL_IMAGE_SIZE);
+#endif
 
 #ifdef CONFIG_HIGHMEM
 	BUG_ON(PKMAP_BASE + LAST_PKMAP*PAGE_SIZE	> FIXADDR_START);
--- head.orig/arch/x86/mm/init_64-xen.c	2014-02-28 15:08:54.000000000 +0100
+++ head/arch/x86/mm/init_64-xen.c	2014-02-28 15:09:23.000000000 +0100
@@ -943,7 +943,7 @@ kernel_physical_mapping_init(unsigned lo
 #ifndef CONFIG_NUMA
 void __init initmem_init(void)
 {
-	memblock_set_node(0, (phys_addr_t)ULLONG_MAX, 0);
+	memblock_set_node(0, (phys_addr_t)ULLONG_MAX, &memblock.memory, 0);
 }
 #endif
 
--- head.orig/arch/x86/mm/pageattr-xen.c	2013-05-24 11:49:51.000000000 +0200
+++ head/arch/x86/mm/pageattr-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -30,6 +30,7 @@
  */
 struct cpa_data {
 	unsigned long	*vaddr;
+	pgd_t		*pgd;
 	pgprot_t	mask_set;
 	pgprot_t	mask_clr;
 	int		numpages;
@@ -322,17 +323,9 @@ static inline pgprot_t static_protection
 	return prot;
 }
 
-/*
- * Lookup the page table entry for a virtual address. Return a pointer
- * to the entry and the level of the mapping.
- *
- * Note: We return pud and pmd either when the entry is marked large
- * or when the present bit is not set. Otherwise we would return a
- * pointer to a nonexisting mapping.
- */
-pte_t *lookup_address(unsigned long address, unsigned int *level)
+static pte_t *__lookup_address_in_pgd(pgd_t *pgd, unsigned long address,
+				      unsigned int *level)
 {
-	pgd_t *pgd = pgd_offset_k(address);
 	pud_t *pud;
 	pmd_t *pmd;
 
@@ -361,8 +354,31 @@ pte_t *lookup_address(unsigned long addr
 
 	return pte_offset_kernel(pmd, address);
 }
+
+/*
+ * Lookup the page table entry for a virtual address. Return a pointer
+ * to the entry and the level of the mapping.
+ *
+ * Note: We return pud and pmd either when the entry is marked large
+ * or when the present bit is not set. Otherwise we would return a
+ * pointer to a nonexisting mapping.
+ */
+pte_t *lookup_address(unsigned long address, unsigned int *level)
+{
+        return __lookup_address_in_pgd(pgd_offset_k(address), address, level);
+}
 EXPORT_SYMBOL_GPL(lookup_address);
 
+static pte_t *_lookup_address_cpa(struct cpa_data *cpa, unsigned long address,
+				  unsigned int *level)
+{
+        if (cpa->pgd)
+		return __lookup_address_in_pgd(cpa->pgd + pgd_index(address),
+					       address, level);
+
+        return lookup_address(address, level);
+}
+
 /*
  * This is necessary because __pa() does not work on some
  * kinds of memory, like vmalloc() or the alloc_remap()
@@ -449,7 +465,7 @@ try_preserve_large_page(pte_t *kpte, uns
 	 * Check for races, another CPU might have split this page
 	 * up already:
 	 */
-	tmp = lookup_address(address, &level);
+	tmp = _lookup_address_cpa(cpa, address, &level);
 	if (tmp != kpte)
 		goto out_unlock;
 
@@ -556,7 +572,8 @@ out_unlock:
 }
 
 static int
-__split_large_page(pte_t *kpte, unsigned long address, struct page *base)
+__split_large_page(struct cpa_data *cpa, pte_t *kpte, unsigned long address,
+		   struct page *base)
 {
 	pte_t *pbase = (pte_t *)page_address(base);
 	unsigned long mfn, mfninc = 1;
@@ -569,7 +586,7 @@ __split_large_page(pte_t *kpte, unsigned
 	 * Check for races, another CPU might have split this page
 	 * up for us already:
 	 */
-	tmp = lookup_address(address, &level);
+	tmp = _lookup_address_cpa(cpa, address, &level);
 	if (tmp != kpte) {
 		spin_unlock(&pgd_lock);
 		return 1;
@@ -649,7 +666,8 @@ __split_large_page(pte_t *kpte, unsigned
 	return 0;
 }
 
-static int split_large_page(pte_t *kpte, unsigned long address)
+static int split_large_page(struct cpa_data *cpa, pte_t *kpte,
+			    unsigned long address)
 {
 	struct page *base;
 
@@ -661,15 +679,396 @@ static int split_large_page(pte_t *kpte,
 	if (!base)
 		return -ENOMEM;
 
-	if (__split_large_page(kpte, address, base))
+	if (__split_large_page(cpa, kpte, address, base))
 		__free_page(base);
 
 	return 0;
 }
 
+#ifndef CONFIG_XEN
+static bool try_to_free_pte_page(pte_t *pte)
+{
+	int i;
+
+	for (i = 0; i < PTRS_PER_PTE; i++)
+		if (!pte_none(pte[i]))
+			return false;
+
+	free_page((unsigned long)pte);
+	return true;
+}
+
+static bool try_to_free_pmd_page(pmd_t *pmd)
+{
+	int i;
+
+	for (i = 0; i < PTRS_PER_PMD; i++)
+		if (!pmd_none(pmd[i]))
+			return false;
+
+	free_page((unsigned long)pmd);
+	return true;
+}
+
+static bool unmap_pte_range(pmd_t *pmd, unsigned long start, unsigned long end)
+{
+	pte_t *pte = pte_offset_kernel(pmd, start);
+
+	while (start < end) {
+		set_pte(pte, __pte(0));
+
+		start += PAGE_SIZE;
+		pte++;
+	}
+
+	if (try_to_free_pte_page((pte_t *)pmd_page_vaddr(*pmd))) {
+		pmd_clear(pmd);
+		return true;
+	}
+	return false;
+}
+
+static void __unmap_pmd_range(pud_t *pud, pmd_t *pmd,
+			      unsigned long start, unsigned long end)
+{
+	if (unmap_pte_range(pmd, start, end))
+		if (try_to_free_pmd_page((pmd_t *)pud_page_vaddr(*pud)))
+			pud_clear(pud);
+}
+
+static void unmap_pmd_range(pud_t *pud, unsigned long start, unsigned long end)
+{
+	pmd_t *pmd = pmd_offset(pud, start);
+
+	/*
+	 * Not on a 2MB page boundary?
+	 */
+	if (start & (PMD_SIZE - 1)) {
+		unsigned long next_page = (start + PMD_SIZE) & PMD_MASK;
+		unsigned long pre_end = min_t(unsigned long, end, next_page);
+
+		__unmap_pmd_range(pud, pmd, start, pre_end);
+
+		start = pre_end;
+		pmd++;
+	}
+
+	/*
+	 * Try to unmap in 2M chunks.
+	 */
+	while (end - start >= PMD_SIZE) {
+		if (pmd_large(*pmd))
+			pmd_clear(pmd);
+		else
+			__unmap_pmd_range(pud, pmd, start, start + PMD_SIZE);
+
+		start += PMD_SIZE;
+		pmd++;
+	}
+
+	/*
+	 * 4K leftovers?
+	 */
+	if (start < end)
+		return __unmap_pmd_range(pud, pmd, start, end);
+
+	/*
+	 * Try again to free the PMD page if haven't succeeded above.
+	 */
+	if (!pud_none(*pud))
+		if (try_to_free_pmd_page((pmd_t *)pud_page_vaddr(*pud)))
+			pud_clear(pud);
+}
+
+static void unmap_pud_range(pgd_t *pgd, unsigned long start, unsigned long end)
+{
+	pud_t *pud = pud_offset(pgd, start);
+
+	/*
+	 * Not on a GB page boundary?
+	 */
+	if (start & (PUD_SIZE - 1)) {
+		unsigned long next_page = (start + PUD_SIZE) & PUD_MASK;
+		unsigned long pre_end	= min_t(unsigned long, end, next_page);
+
+		unmap_pmd_range(pud, start, pre_end);
+
+		start = pre_end;
+		pud++;
+	}
+
+	/*
+	 * Try to unmap in 1G chunks?
+	 */
+	while (end - start >= PUD_SIZE) {
+
+		if (pud_large(*pud))
+			pud_clear(pud);
+		else
+			unmap_pmd_range(pud, start, start + PUD_SIZE);
+
+		start += PUD_SIZE;
+		pud++;
+	}
+
+	/*
+	 * 2M leftovers?
+	 */
+	if (start < end)
+		unmap_pmd_range(pud, start, end);
+
+	/*
+	 * No need to try to free the PUD page because we'll free it in
+	 * populate_pgd's error path
+	 */
+}
+
+static int alloc_pte_page(pmd_t *pmd)
+{
+	pte_t *pte = (pte_t *)get_zeroed_page(GFP_KERNEL | __GFP_NOTRACK);
+	if (!pte)
+		return -1;
+
+	set_pmd(pmd, __pmd(__pa(pte) | _KERNPG_TABLE));
+	return 0;
+}
+
+static int alloc_pmd_page(pud_t *pud)
+{
+	pmd_t *pmd = (pmd_t *)get_zeroed_page(GFP_KERNEL | __GFP_NOTRACK);
+	if (!pmd)
+		return -1;
+
+	set_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE));
+	return 0;
+}
+
+static void populate_pte(struct cpa_data *cpa,
+			 unsigned long start, unsigned long end,
+			 unsigned num_pages, pmd_t *pmd, pgprot_t pgprot)
+{
+	pte_t *pte;
+
+	pte = pte_offset_kernel(pmd, start);
+
+	while (num_pages-- && start < end) {
+
+		/* deal with the NX bit */
+		if (!(pgprot_val(pgprot) & _PAGE_NX))
+			cpa->pfn &= ~_PAGE_NX;
+
+		set_pte(pte, pfn_pte(cpa->pfn >> PAGE_SHIFT, pgprot));
+
+		start	 += PAGE_SIZE;
+		cpa->pfn += PAGE_SIZE;
+		pte++;
+	}
+}
+
+static int populate_pmd(struct cpa_data *cpa,
+			unsigned long start, unsigned long end,
+			unsigned num_pages, pud_t *pud, pgprot_t pgprot)
+{
+	unsigned int cur_pages = 0;
+	pmd_t *pmd;
+
+	/*
+	 * Not on a 2M boundary?
+	 */
+	if (start & (PMD_SIZE - 1)) {
+		unsigned long pre_end = start + (num_pages << PAGE_SHIFT);
+		unsigned long next_page = (start + PMD_SIZE) & PMD_MASK;
+
+		pre_end   = min_t(unsigned long, pre_end, next_page);
+		cur_pages = (pre_end - start) >> PAGE_SHIFT;
+		cur_pages = min_t(unsigned int, num_pages, cur_pages);
+
+		/*
+		 * Need a PTE page?
+		 */
+		pmd = pmd_offset(pud, start);
+		if (pmd_none(*pmd))
+			if (alloc_pte_page(pmd))
+				return -1;
+
+		populate_pte(cpa, start, pre_end, cur_pages, pmd, pgprot);
+
+		start = pre_end;
+	}
+
+	/*
+	 * We mapped them all?
+	 */
+	if (num_pages == cur_pages)
+		return cur_pages;
+
+	while (end - start >= PMD_SIZE) {
+
+		/*
+		 * We cannot use a 1G page so allocate a PMD page if needed.
+		 */
+		if (pud_none(*pud))
+			if (alloc_pmd_page(pud))
+				return -1;
+
+		pmd = pmd_offset(pud, start);
+
+		set_pmd(pmd, __pmd(cpa->pfn | _PAGE_PSE | massage_pgprot(pgprot)));
+
+		start	  += PMD_SIZE;
+		cpa->pfn  += PMD_SIZE;
+		cur_pages += PMD_SIZE >> PAGE_SHIFT;
+	}
+
+	/*
+	 * Map trailing 4K pages.
+	 */
+	if (start < end) {
+		pmd = pmd_offset(pud, start);
+		if (pmd_none(*pmd))
+			if (alloc_pte_page(pmd))
+				return -1;
+
+		populate_pte(cpa, start, end, num_pages - cur_pages,
+			     pmd, pgprot);
+	}
+	return num_pages;
+}
+
+static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,
+			pgprot_t pgprot)
+{
+	pud_t *pud;
+	unsigned long end;
+	int cur_pages = 0;
+
+	end = start + (cpa->numpages << PAGE_SHIFT);
+
+	/*
+	 * Not on a Gb page boundary? => map everything up to it with
+	 * smaller pages.
+	 */
+	if (start & (PUD_SIZE - 1)) {
+		unsigned long pre_end;
+		unsigned long next_page = (start + PUD_SIZE) & PUD_MASK;
+
+		pre_end   = min_t(unsigned long, end, next_page);
+		cur_pages = (pre_end - start) >> PAGE_SHIFT;
+		cur_pages = min_t(int, (int)cpa->numpages, cur_pages);
+
+		pud = pud_offset(pgd, start);
+
+		/*
+		 * Need a PMD page?
+		 */
+		if (pud_none(*pud))
+			if (alloc_pmd_page(pud))
+				return -1;
+
+		cur_pages = populate_pmd(cpa, start, pre_end, cur_pages,
+					 pud, pgprot);
+		if (cur_pages < 0)
+			return cur_pages;
+
+		start = pre_end;
+	}
+
+	/* We mapped them all? */
+	if (cpa->numpages == cur_pages)
+		return cur_pages;
+
+	pud = pud_offset(pgd, start);
+
+	/*
+	 * Map everything starting from the Gb boundary, possibly with 1G pages
+	 */
+	while (end - start >= PUD_SIZE) {
+		set_pud(pud, __pud(cpa->pfn | _PAGE_PSE | massage_pgprot(pgprot)));
+
+		start	  += PUD_SIZE;
+		cpa->pfn  += PUD_SIZE;
+		cur_pages += PUD_SIZE >> PAGE_SHIFT;
+		pud++;
+	}
+
+	/* Map trailing leftover */
+	if (start < end) {
+		int tmp;
+
+		pud = pud_offset(pgd, start);
+		if (pud_none(*pud))
+			if (alloc_pmd_page(pud))
+				return -1;
+
+		tmp = populate_pmd(cpa, start, end, cpa->numpages - cur_pages,
+				   pud, pgprot);
+		if (tmp < 0)
+			return cur_pages;
+
+		cur_pages += tmp;
+	}
+	return cur_pages;
+}
+
+/*
+ * Restrictions for kernel page table do not necessarily apply when mapping in
+ * an alternate PGD.
+ */
+static int populate_pgd(struct cpa_data *cpa, unsigned long addr)
+{
+	pgprot_t pgprot = __pgprot(_KERNPG_TABLE);
+	bool allocd_pgd = false;
+	pgd_t *pgd_entry;
+	pud_t *pud = NULL;	/* shut up gcc */
+	int ret;
+
+	pgd_entry = cpa->pgd + pgd_index(addr);
+
+	/*
+	 * Allocate a PUD page and hand it down for mapping.
+	 */
+	if (pgd_none(*pgd_entry)) {
+		pud = (pud_t *)get_zeroed_page(GFP_KERNEL | __GFP_NOTRACK);
+		if (!pud)
+			return -1;
+
+		set_pgd(pgd_entry, __pgd(__pa(pud) | _KERNPG_TABLE));
+		allocd_pgd = true;
+	}
+
+	pgprot_val(pgprot) &= ~pgprot_val(cpa->mask_clr);
+	pgprot_val(pgprot) |=  pgprot_val(cpa->mask_set);
+
+	ret = populate_pud(cpa, addr, pgd_entry, pgprot);
+	if (ret < 0) {
+		unmap_pud_range(pgd_entry, addr,
+				addr + (cpa->numpages << PAGE_SHIFT));
+
+		if (allocd_pgd) {
+			/*
+			 * If I allocated this PUD page, I can just as well
+			 * free it in this error path.
+			 */
+			pgd_clear(pgd_entry);
+			free_page((unsigned long)pud);
+		}
+		return ret;
+	}
+	cpa->numpages = ret;
+	return 0;
+}
+#endif
+
 static int __cpa_process_fault(struct cpa_data *cpa, unsigned long vaddr,
 			       int primary)
 {
+#ifdef CONFIG_XEN
+	BUG_ON(cpa->pgd);
+#else
+	if (cpa->pgd)
+		return populate_pgd(cpa, vaddr);
+#endif
+
 	/*
 	 * Ignore all non primary paths.
 	 */
@@ -714,7 +1113,7 @@ static int __change_page_attr(struct cpa
 	else
 		address = *cpa->vaddr;
 repeat:
-	kpte = lookup_address(address, &level);
+	kpte = _lookup_address_cpa(cpa, address, &level);
 	if (!kpte)
 		return __cpa_process_fault(cpa, address, primary);
 
@@ -801,7 +1200,7 @@ repeat:
 	/*
 	 * We have to split the large page:
 	 */
-	err = split_large_page(kpte, address);
+	err = split_large_page(cpa, kpte, address);
 	if (!err) {
 		/*
 	 	 * Do a global flush tlb after splitting the large page
@@ -950,6 +1349,8 @@ static int change_page_attr_set_clr(unsi
 	int ret, cache, checkalias;
 	unsigned long baddr = 0;
 
+	memset(&cpa, 0, sizeof(cpa));
+
 	/*
 	 * Check, if we are requested to change a not supported
 	 * feature:
@@ -1441,6 +1842,7 @@ static int __set_pages_p(struct page *pa
 {
 	unsigned long tempaddr = (unsigned long) page_address(page);
 	struct cpa_data cpa = { .vaddr = &tempaddr,
+				.pgd = NULL,
 				.numpages = numpages,
 				.mask_set = __pgprot(_PAGE_PRESENT | _PAGE_RW),
 				.mask_clr = __pgprot(0),
@@ -1459,6 +1861,7 @@ static int __set_pages_np(struct page *p
 {
 	unsigned long tempaddr = (unsigned long) page_address(page);
 	struct cpa_data cpa = { .vaddr = &tempaddr,
+				.pgd = NULL,
 				.numpages = numpages,
 				.mask_set = __pgprot(0),
 				.mask_clr = __pgprot(_PAGE_PRESENT | _PAGE_RW),
@@ -1519,6 +1922,38 @@ bool kernel_page_present(struct page *pa
 
 #endif /* CONFIG_DEBUG_PAGEALLOC */
 
+#ifndef CONFIG_XEN
+int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,
+			    unsigned numpages, unsigned long page_flags)
+{
+	int retval = -EINVAL;
+
+	struct cpa_data cpa = {
+		.vaddr = &address,
+		.pfn = pfn,
+		.pgd = pgd,
+		.numpages = numpages,
+		.mask_set = __pgprot(0),
+		.mask_clr = __pgprot(0),
+		.flags = 0,
+	};
+
+	if (!(__supported_pte_mask & _PAGE_NX))
+		goto out;
+
+	if (!(page_flags & _PAGE_NX))
+		cpa.mask_clr = __pgprot(_PAGE_NX);
+
+	cpa.mask_set = __pgprot(_PAGE_PRESENT | page_flags);
+
+	retval = __change_page_attr_set_clr(&cpa, 0);
+	__flush_tlb_all();
+
+out:
+	return retval;
+}
+#endif
+
 static inline int in_secondary_range(unsigned long va)
 {
 #ifdef CONFIG_X86_64
--- head.orig/arch/x86/mm/tlb-xen.c	2013-09-26 15:33:39.000000000 +0200
+++ head/arch/x86/mm/tlb-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -9,37 +9,12 @@
 #include <asm/cache.h>
 #include <linux/debugfs.h>
 
-/*
- * It can find out the THP large page, or
- * HUGETLB page in tlb_flush when THP disabled
- */
-static inline unsigned long has_large_page(struct mm_struct *mm,
-				 unsigned long start, unsigned long end)
-{
-	pgd_t *pgd;
-	pud_t *pud;
-	pmd_t *pmd;
-	unsigned long addr = ALIGN(start, HPAGE_SIZE);
-	for (; addr < end; addr += HPAGE_SIZE) {
-		pgd = pgd_offset(mm, addr);
-		if (likely(!pgd_none(*pgd))) {
-			pud = pud_offset(pgd, addr);
-			if (likely(!pud_none(*pud))) {
-				pmd = pmd_offset(pud, addr);
-				if (likely(!pmd_none(*pmd)))
-					if (pmd_large(*pmd))
-						return addr;
-			}
-		}
-	}
-	return 0;
-}
-
 void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 				unsigned long end, unsigned long vmflag)
 {
 	unsigned long addr;
 	unsigned act_entries, tlb_entries = 0;
+	unsigned long nr_base_pages;
 	const cpumask_t *mask = mm_cpumask(mm);
 	cpumask_var_t temp;
 
@@ -65,21 +40,22 @@ void flush_tlb_mm_range(struct mm_struct
 		tlb_entries = tlb_lli_4k[ENTRIES];
 	else
 		tlb_entries = tlb_lld_4k[ENTRIES];
+
 	/* Assume all of TLB entries was occupied by this task */
-	act_entries = mm->total_vm > tlb_entries ? tlb_entries : mm->total_vm;
+	act_entries = tlb_entries >> tlb_flushall_shift;
+	act_entries = mm->total_vm > act_entries ? act_entries : mm->total_vm;
+	nr_base_pages = (end - start) >> PAGE_SHIFT;
 
 	/* tlb_flushall_shift is on balance point, details in commit log */
-	if (((end - start) >> PAGE_SHIFT)
-	    <= (act_entries >> tlb_flushall_shift)
-	    && !has_large_page(mm, start, end)) {
+	if (nr_base_pages <= act_entries) {
 		/* flush range by one by one 'invlpg' */
 		for (addr = start; addr < end; addr += PAGE_SIZE) {
-			count_vm_event(NR_TLB_LOCAL_FLUSH_ONE);
+			count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
 			xen_invlpg_mask(mask, addr);
 		}
 	} else {
 flush_all:
-		count_vm_event(NR_TLB_LOCAL_FLUSH_ALL);
+		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
 		xen_tlb_flush_mask(mask);
 	}
 
--- head.orig/arch/x86/xen/Kconfig	2014-04-30 10:50:20.000000000 +0200
+++ head/arch/x86/xen/Kconfig	2014-02-20 14:13:54.000000000 +0100
@@ -48,5 +48,5 @@ config XEN_DEBUG_FS
 
 config XEN_PVH
 	bool "Support for running as a PVH guest"
-	depends on X86_64 && XEN && XEN_PVHVM
+	depends on X86_64 && XEN_PVHVM
 	def_bool n
--- head.orig/drivers/acpi/acpi_pad-xen.c	2013-09-26 15:33:39.000000000 +0200
+++ head/drivers/acpi/acpi_pad-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -23,8 +23,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/types.h>
-#include <acpi/acpi_bus.h>
-#include <acpi/acpi_drivers.h>
+#include <linux/acpi.h>
 #include <asm/hypervisor.h>
 
 #define ACPI_PROCESSOR_AGGREGATOR_CLASS	"acpi_pad"
--- head.orig/drivers/char/tpm/tpm_vtpm.c	2013-04-02 16:11:18.000000000 +0200
+++ head/drivers/char/tpm/tpm_vtpm.c	2014-02-20 17:31:18.000000000 +0100
@@ -455,42 +455,9 @@ static bool vtpm_req_canceled(struct tpm
 	return status == STATUS_READY;
 }
 
-static struct file_operations vtpm_ops = {
-	.owner = THIS_MODULE,
-	.llseek = no_llseek,
-	.open = tpm_open,
-	.read = tpm_read,
-	.write = tpm_write,
-	.release = tpm_release,
-};
-
-static DEVICE_ATTR(pubek, S_IRUGO, tpm_show_pubek, NULL);
-static DEVICE_ATTR(pcrs, S_IRUGO, tpm_show_pcrs, NULL);
-static DEVICE_ATTR(enabled, S_IRUGO, tpm_show_enabled, NULL);
-static DEVICE_ATTR(active, S_IRUGO, tpm_show_active, NULL);
-static DEVICE_ATTR(owned, S_IRUGO, tpm_show_owned, NULL);
-static DEVICE_ATTR(temp_deactivated, S_IRUGO, tpm_show_temp_deactivated,
-		   NULL);
-static DEVICE_ATTR(caps, S_IRUGO, tpm_show_caps, NULL);
-static DEVICE_ATTR(cancel, S_IWUSR |S_IWGRP, NULL, tpm_store_cancel);
-
-static struct attribute *vtpm_attrs[] = {
-	&dev_attr_pubek.attr,
-	&dev_attr_pcrs.attr,
-	&dev_attr_enabled.attr,
-	&dev_attr_active.attr,
-	&dev_attr_owned.attr,
-	&dev_attr_temp_deactivated.attr,
-	&dev_attr_caps.attr,
-	&dev_attr_cancel.attr,
-	NULL,
-};
-
-static struct attribute_group vtpm_attr_grp = { .attrs = vtpm_attrs };
-
 #define TPM_LONG_TIMEOUT   (10 * 60 * HZ)
 
-static struct tpm_vendor_specific tpm_vtpm = {
+static const struct tpm_class_ops tpm_vtpm = {
 	.recv = vtpm_recv,
 	.send = vtpm_send,
 	.cancel = vtpm_cancel,
@@ -498,15 +465,6 @@ static struct tpm_vendor_specific tpm_vt
 	.req_complete_mask = STATUS_BUSY | STATUS_DATA_AVAIL,
 	.req_complete_val  = STATUS_DATA_AVAIL,
 	.req_canceled = vtpm_req_canceled,
-	.attr_group = &vtpm_attr_grp,
-	.miscdev = {
-		.fops = &vtpm_ops,
-	},
-	.duration = {
-		TPM_LONG_TIMEOUT,
-		TPM_LONG_TIMEOUT,
-		TPM_LONG_TIMEOUT,
-	},
 };
 
 struct tpm_chip *init_vtpm(struct device *dev,
@@ -530,6 +488,8 @@ struct tpm_chip *init_vtpm(struct device
 	}
 
 	chip_set_private(chip, vtpms);
+	for (rc = 0; rc < ARRAY_SIZE(chip->vendor.duration); ++rc)
+		chip->vendor.duration[rc] = TPM_LONG_TIMEOUT;
 
 	return chip;
 
--- head.orig/drivers/firmware/efi/Kconfig	2014-10-05 21:23:04.000000000 +0200
+++ head/drivers/firmware/efi/Kconfig	2014-02-25 08:39:54.000000000 +0100
@@ -38,7 +38,7 @@ config EFI_VARS_PSTORE_DEFAULT_DISABLE
 
 config EFI_RUNTIME_MAP
 	bool "Export efi runtime maps to sysfs"
-	depends on X86 && EFI && KEXEC
+	depends on X86 && EFI && KEXEC && !XEN
 	default y
 	help
 	  Export efi runtime memory maps to /sys/firmware/efi/runtime-map.
--- head.orig/drivers/gpu/drm/i915/i915_gem_stolen.c	2014-10-28 12:03:11.000000000 +0100
+++ head/drivers/gpu/drm/i915/i915_gem_stolen.c	2014-10-28 14:00:22.000000000 +0100
@@ -292,7 +292,7 @@ int i915_gem_init_stolen(struct drm_devi
 	u32 tmp;
 	int bios_reserved = 0;
 
-#ifdef CONFIG_INTEL_IOMMU
+#if defined(CONFIG_INTEL_IOMMU) || defined(CONFIG_XEN)
 	if (intel_iommu_gfx_mapped && INTEL_INFO(dev)->gen < 8) {
 		DRM_INFO("DMAR active, disabling use of stolen memory\n");
 		return 0;
--- head.orig/drivers/hwmon/coretemp-xen.c	2014-01-22 14:23:28.000000000 +0100
+++ head/drivers/hwmon/coretemp-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -36,6 +36,7 @@
 #include <linux/cpu.h>
 #include <linux/smp.h>
 #include <linux/moduleparam.h>
+#include <linux/pci.h>
 #include <asm/msr.h>
 #include <asm/cpu_device_id.h>
 #include <xen/pcpu.h>
@@ -184,20 +185,33 @@ static ssize_t show_temp(struct device *
 		if (rdmsr_safe_on_pcpu(tdata->cpu, tdata->status_reg,
 					 &eax, &edx) < 0)
 			eax = ~0;
-		tdata->valid = 0;
-		/* Check whether the data is valid */
-		if (eax & 0x80000000) {
-			tdata->temp = tdata->tjmax -
-					((eax >> 16) & 0x7f) * 1000;
-			tdata->valid = 1;
-		}
+		/*
+		 * Ignore the valid bit. In all observed cases the register
+		 * value is either low or zero if the valid bit is 0.
+		 * Return it instead of reporting an error which doesn't
+		 * really help at all.
+		 */
+		tdata->temp = tdata->tjmax - ((eax >> 16) & 0x7f) * 1000;
+		tdata->valid = 1;
 		tdata->last_updated = jiffies;
 	}
 
 	mutex_unlock(&tdata->update_lock);
-	return tdata->valid ? sprintf(buf, "%d\n", tdata->temp) : -EAGAIN;
+	return sprintf(buf, "%d\n", tdata->temp);
 }
 
+struct tjmax_pci {
+	unsigned int device;
+	int tjmax;
+};
+
+static const struct tjmax_pci tjmax_pci_table[] = {
+	{ 0x0708, 110000 },	/* CE41x0 (Sodaville ) */
+	{ 0x0c72, 102000 },	/* Atom S1240 (Centerton) */
+	{ 0x0c73, 95000 },	/* Atom S1220 (Centerton) */
+	{ 0x0c75, 95000 },	/* Atom S1260 (Centerton) */
+};
+
 struct tjmax {
 	char const *id;
 	int tjmax;
@@ -206,9 +220,6 @@ struct tjmax {
 static const struct tjmax tjmax_table[] = {
 	{ "CPU  230", 100000 },		/* Model 0x1c, stepping 2	*/
 	{ "CPU  330", 125000 },		/* Model 0x1c, stepping 2	*/
-	{ "CPU CE4110", 110000 },	/* Model 0x1c, stepping 10 Sodaville */
-	{ "CPU CE4150", 110000 },	/* Model 0x1c, stepping 10	*/
-	{ "CPU CE4170", 110000 },	/* Model 0x1c, stepping 10	*/
 };
 
 struct tjmax_model {
@@ -230,8 +241,11 @@ static const struct tjmax_model tjmax_mo
 				 * is undetectable by software
 				 */
 	{ 0x27, ANY, 90000 },	/* Atom Medfield (Z2460) */
-	{ 0x35, ANY, 90000 },	/* Atom Clover Trail/Cloverview (Z2760) */
-	{ 0x36, ANY, 100000 },	/* Atom Cedar Trail/Cedarview (N2xxx, D2xxx) */
+	{ 0x35, ANY, 90000 },	/* Atom Clover Trail/Cloverview (Z27x0) */
+	{ 0x36, ANY, 100000 },	/* Atom Cedar Trail/Cedarview (N2xxx, D2xxx)
+				 * Also matches S12x0 (stepping 9), covered by
+				 * PCI table
+				 */
 };
 
 static int adjust_tjmax(struct platform_data *c, u32 id, struct device *dev)
@@ -244,8 +258,20 @@ static int adjust_tjmax(struct platform_
 	int err;
 	u32 eax, edx;
 	int i;
+	struct pci_dev *host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));
+
+	/*
+	 * Explicit tjmax table entries override heuristics.
+	 * First try PCI host bridge IDs, followed by model ID strings
+	 * and model/stepping information.
+	 */
+	if (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL) {
+		for (i = 0; i < ARRAY_SIZE(tjmax_pci_table); i++) {
+			if (host_bridge->device == tjmax_pci_table[i].device)
+				return tjmax_pci_table[i].tjmax;
+		}
+	}
 
-	/* explicit tjmax table entries override heuristics */
 	for (i = 0; i < ARRAY_SIZE(tjmax_table); i++) {
 		if (strstr(boot_cpu_data.x86_model_id, tjmax_table[i].id))
 			return tjmax_table[i].tjmax;
@@ -351,12 +377,12 @@ static int get_tjmax(struct platform_dat
 		if (cpu_has_tjmax(c))
 			dev_warn(dev, "Unable to read TjMax from CPU %u\n", id);
 	} else {
-		val = (eax >> 16) & 0xff;
+		val = (eax >> 16) & 0x7f;
 		/*
 		 * If the TjMax is not plausible, an assumption
 		 * will be used
 		 */
-		if (val) {
+		if (val >= 85) {
 			dev_dbg(dev, "TjMax is %d degrees C\n", val);
 			return val * 1000;
 		}
--- head.orig/drivers/pci/msi-xen.c	2013-12-11 16:30:51.000000000 +0100
+++ head/drivers/pci/msi-xen.c	2014-10-07 12:12:33.000000000 +0200
@@ -43,7 +43,6 @@ struct msi_pirq_entry {
 	int pirq;
 	int entry_nr;
 	struct msi_dev_list *dev_entry;
-	struct kobject kobj;
 };
 
 struct msi_dev_list {
@@ -150,7 +149,6 @@ static int attach_pirq_entry(int pirq, i
 	entry->pirq = pirq;
 	entry->entry_nr = entry_nr;
 	entry->dev_entry = msi_dev_entry;
-	memset(&entry->kobj, 0, sizeof(entry->kobj));
 	spin_lock_irqsave(&msi_dev_entry->pirq_list_lock, flags);
 	list_add_tail(&entry->list, &msi_dev_entry->dev->msi_list);
 	spin_unlock_irqrestore(&msi_dev_entry->pirq_list_lock, flags);
@@ -200,7 +198,7 @@ EXPORT_SYMBOL(unregister_msi_get_owner);
 #endif
 
 static void msi_unmap_pirq(struct pci_dev *dev, int pirq, unsigned int nr,
-			   domid_t owner, struct kobject *kobj)
+			   domid_t owner)
 {
 	struct physdev_unmap_pirq unmap;
 	int rc;
@@ -215,16 +213,6 @@ static void msi_unmap_pirq(struct pci_de
 	if ((rc = HYPERVISOR_physdev_op(PHYSDEVOP_unmap_pirq, &unmap)))
 		dev_warn(&dev->dev, "unmap irq %d failed (%d)\n", pirq, rc);
 
-	/*
-	 * Its possible that we get into this path when populate_msi_sysfs()
-	 * fails, which means the entries were not registered with sysfs.
-	 * In that case don't unregister them.
-	 */
-	if (kobj->parent) {
-		kobject_del(kobj);
-		kobject_put(kobj);
-	}
-
 	if (unmap.domid == DOMID_SELF)
 		evtchn_map_pirq(pirq, 0, nr);
 }
@@ -372,142 +360,185 @@ void pci_restore_msi_state(struct pci_de
 }
 EXPORT_SYMBOL_GPL(pci_restore_msi_state);
 
-
-#define to_msi_attr(obj) container_of(obj, struct msi_attribute, attr)
-#define to_pirq_entry(obj) container_of(obj, struct msi_pirq_entry, kobj)
-
-struct msi_attribute {
-	struct attribute        attr;
-	ssize_t (*show)(struct msi_pirq_entry *, struct msi_attribute *,
-			char *buf);
-	ssize_t (*store)(struct msi_pirq_entry *, struct msi_attribute *,
-			 const char *buf, size_t count);
-};
-
-static ssize_t show_msi_mode(struct msi_pirq_entry *entry,
-			     struct msi_attribute *attr, char *buf)
+static ssize_t msi_mode_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
 {
-	return sprintf(buf, "%s\n", entry->entry_nr >= 0 ? "msix" : "msi");
-}
+	struct pci_dev *pdev = to_pci_dev(dev);
 
-static ssize_t show_xen_irq(struct msi_pirq_entry *entry,
-			    struct msi_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", entry->dev_entry->owner == DOMID_SELF
-				    ? evtchn_get_xen_pirq(entry->pirq)
-				    : entry->pirq);
+	return sprintf(buf, "msi%s\n", pdev->msix_enabled ? "x" : "");
 }
 
-static ssize_t msi_irq_attr_show(struct kobject *kobj,
-				 struct attribute *attr, char *buf)
+static ssize_t msi_xen_irq_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
 {
-	struct msi_attribute *attribute = to_msi_attr(attr);
-	struct msi_pirq_entry *entry = to_pirq_entry(kobj);
-
-	if (!attribute->show)
-		return -EIO;
-
-	return attribute->show(entry, attribute, buf);
-}
-
-static const struct sysfs_ops msi_irq_sysfs_ops = {
-	.show = msi_irq_attr_show,
-};
-
-static struct msi_attribute mode_attribute =
-	__ATTR(mode, S_IRUGO, show_msi_mode, NULL);
-
-static struct msi_attribute xen_irq_attribute =
-	__ATTR(xen_irq, S_IRUGO, show_xen_irq, NULL);
-
-static struct attribute *msi_irq_default_attrs[] = {
-	&mode_attribute.attr,
-	&xen_irq_attribute.attr,
-	NULL
-};
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct msi_dev_list *dev_entry = get_msi_dev_pirq_list(pdev);
+	struct msi_pirq_entry *entry;
+	unsigned long pirq, flags;
+	int retval;
+
+	retval = kstrtoul(attr->attr.name, 10, &pirq);
+	if (retval)
+		return retval;
 
-static struct attribute *msi_pirq_default_attrs[] = {
-	&mode_attribute.attr,
-	NULL
-};
+	if (pdev->msi_enabled) {
+		if (pirq < pdev->irq ||
+		    pirq >= pdev->irq - dev_entry->e.entry_nr)
+			return -ENODEV;
+		return sprintf(buf, "%ld\n",
+			       dev_entry->owner == DOMID_SELF
+			       ? evtchn_get_xen_pirq(pirq) : pirq);
+	}
 
-static void msi_kobj_release(struct kobject *kobj)
-{
-	struct msi_dev_list *entry = to_pirq_entry(kobj)->dev_entry;
+	spin_lock_irqsave(&dev_entry->pirq_list_lock, flags);
+	list_for_each_entry(entry, &pdev->msi_list, list)
+		if (entry->pirq == pirq) {
+			spin_unlock_irqrestore(&dev_entry->pirq_list_lock, flags);
+			return sprintf(buf, "%ld\n",
+				       dev_entry->owner == DOMID_SELF
+				       ? evtchn_get_xen_pirq(pirq) : pirq);
+		}
+	spin_unlock_irqrestore(&dev_entry->pirq_list_lock, flags);
 
-	pci_dev_put(entry->dev);
+	return -ENODEV;
 }
 
-static struct kobj_type msi_irq_ktype = {
-	.release = msi_kobj_release,
-	.sysfs_ops = &msi_irq_sysfs_ops,
-	.default_attrs = msi_irq_default_attrs,
-};
-
-static struct kobj_type msi_pirq_ktype = {
-	.release = msi_kobj_release,
-	.sysfs_ops = &msi_irq_sysfs_ops,
-	.default_attrs = msi_pirq_default_attrs,
-};
-
 static int populate_msi_sysfs(struct pci_dev *pdev)
 {
-	struct msi_dev_list *dev_entry = get_msi_dev_pirq_list(pdev);
-	domid_t owner = dev_entry->owner;
-	struct msi_pirq_entry *pirq_entry;
-	struct kobject *kobj;
-	int ret;
+	struct attribute **msi_attrs, **msi_xen_attrs;
+	struct attribute *msi_attr;
+	struct device_attribute *msi_dev_attr;
+	struct attribute_group *msi_irq_group;
+	const struct attribute_group **msi_irq_groups;
+	const struct msi_dev_list *dev_entry = get_msi_dev_pirq_list(pdev);
+	const struct msi_pirq_entry *entry;
+	int ret = -ENOMEM;
+	int num_msi = 0;
 	int count = 0;
 
-	pdev->msi_kset = kset_create_and_add("msi_irqs", NULL, &pdev->dev.kobj);
-	if (!pdev->msi_kset)
-		return -ENOMEM;
+	/* Determine how many msi entries we have */
+	if (pdev->msi_enabled)
+		num_msi = -dev_entry->e.entry_nr;
+	else
+		list_for_each_entry(entry, &pdev->msi_list, list)
+			++num_msi;
+	if (!num_msi)
+		return 0;
 
-	if (pdev->msi_enabled) {
-		kobj = &dev_entry->e.kobj;
-		kobj->kset = pdev->msi_kset;
-		pci_dev_get(pdev);
-		if (owner == DOMID_SELF)
-			ret = kobject_init_and_add(kobj, &msi_irq_ktype, NULL,
-						   "%u", pdev->irq);
-		else
-			ret = kobject_init_and_add(kobj, &msi_pirq_ktype, NULL,
-						   "xen-%u", pdev->irq);
-		if (ret)
-			pci_dev_put(pdev);
-		return ret;
-	}
+	/* Dynamically create the MSI attributes for the PCI device */
+	msi_attrs = kzalloc(sizeof(void *) * (num_msi + 1) * 2, GFP_KERNEL);
+	if (!msi_attrs)
+		return -ENOMEM;
+	msi_xen_attrs = msi_attrs + num_msi + 1;
+	if (pdev->msi_enabled)
+		while (count < num_msi) {
+			msi_dev_attr = kzalloc(sizeof(*msi_dev_attr) * 2,
+					       GFP_KERNEL);
+			if (!msi_dev_attr)
+				goto error_attrs;
+			msi_attrs[count] = &msi_dev_attr[0].attr;
+			sysfs_attr_init(&msi_dev_attr[0].attr);
+			msi_xen_attrs[count] = &msi_dev_attr[1].attr;
+			sysfs_attr_init(&msi_dev_attr[1].attr);
+			msi_dev_attr[0].attr.name = kasprintf(GFP_KERNEL, "%d",
+							      pdev->irq + count);
+			if (!msi_dev_attr[0].attr.name)
+				goto error_attrs;
+			msi_dev_attr[1].attr.name = msi_dev_attr[0].attr.name;
+			msi_dev_attr[0].attr.mode = S_IRUGO;
+			msi_dev_attr[1].attr.mode = S_IRUGO;
+			msi_dev_attr[0].show = msi_mode_show;
+			msi_dev_attr[1].show = msi_xen_irq_show;
+			++count;
+		}
+	else
+		list_for_each_entry(entry, &pdev->msi_list, list) {
+			msi_dev_attr = kzalloc(sizeof(*msi_dev_attr) * 2,
+					       GFP_KERNEL);
+			if (!msi_dev_attr)
+				goto error_attrs;
+			msi_attrs[count] = &msi_dev_attr[0].attr;
+			sysfs_attr_init(&msi_dev_attr[0].attr);
+			msi_xen_attrs[count] = &msi_dev_attr[1].attr;
+			sysfs_attr_init(&msi_dev_attr[1].attr);
+			msi_dev_attr[0].attr.name = kasprintf(GFP_KERNEL, "%d",
+							      entry->pirq);
+			if (!msi_dev_attr[0].attr.name)
+				goto error_attrs;
+			msi_dev_attr[1].attr.name = msi_dev_attr[0].attr.name;
+			msi_dev_attr[0].attr.mode = S_IRUGO;
+			msi_dev_attr[1].attr.mode = S_IRUGO;
+			msi_dev_attr[0].show = msi_mode_show;
+			msi_dev_attr[1].show = msi_xen_irq_show;
+			++count;
+		}
 
-	list_for_each_entry(pirq_entry, &pdev->msi_list, list) {
-		kobj = &pirq_entry->kobj;
-		kobj->kset = pdev->msi_kset;
-		pci_dev_get(pdev);
-		if (owner == DOMID_SELF)
-			ret = kobject_init_and_add(kobj, &msi_irq_ktype, NULL,
-						   "%u", pirq_entry->pirq);
-		else
-			ret = kobject_init_and_add(kobj, &msi_pirq_ktype, NULL,
-						   "xen-%u", pirq_entry->pirq);
-		if (ret)
-			goto out_unroll;
+	msi_irq_group = kzalloc(sizeof(*msi_irq_group) * 2, GFP_KERNEL);
+	if (!msi_irq_group)
+		goto error_attrs;
+	msi_irq_group[0].name = "msi_irqs";
+	msi_irq_group[0].attrs = msi_attrs;
+	msi_irq_group[1].name = "msi_pirqs";
+	msi_irq_group[1].attrs = msi_xen_attrs;
+
+	msi_irq_groups = kzalloc(sizeof(void *) * 3, GFP_KERNEL);
+	if (!msi_irq_groups)
+		goto error_irq_group;
+	msi_irq_groups[0] = msi_irq_group;
+	if (dev_entry->owner == DOMID_SELF)
+		msi_irq_groups[1] = msi_irq_group + 1;
 
-		count++;
-	}
+	ret = sysfs_create_groups(&pdev->dev.kobj, msi_irq_groups);
+	if (ret)
+		goto error_irq_groups;
+	pdev->msi_irq_groups = msi_irq_groups;
 
 	return 0;
 
-out_unroll:
-	pci_dev_put(pdev);
-	list_for_each_entry(pirq_entry, &pdev->msi_list, list) {
-		if (!count)
-			break;
-		kobject_del(&pirq_entry->kobj);
-		kobject_put(&pirq_entry->kobj);
-		count--;
+error_irq_groups:
+	kfree(msi_irq_groups);
+error_irq_group:
+	kfree(msi_irq_group);
+error_attrs:
+	count = 0;
+	msi_attr = msi_attrs[count];
+	while (msi_attr) {
+		msi_dev_attr = container_of(msi_attr, struct device_attribute, attr);
+		kfree(msi_attr->name);
+		kfree(msi_dev_attr);
+		++count;
+		msi_attr = msi_attrs[count];
 	}
+	kfree(msi_attrs);
 	return ret;
 }
 
+static void cleanup_msi_sysfs(struct pci_dev *pdev)
+{
+	struct attribute **msi_attrs, *msi_attr;
+	unsigned int count = 0;
+
+	if (!pdev->msi_irq_groups)
+		return;
+
+	sysfs_remove_groups(&pdev->dev.kobj, pdev->msi_irq_groups);
+	msi_attrs = pdev->msi_irq_groups[0]->attrs;
+	msi_attr = msi_attrs[count];
+	while (msi_attr) {
+		struct device_attribute *dev_attr;
+
+		dev_attr = container_of(msi_attr, struct device_attribute,
+					attr);
+		kfree(dev_attr->attr.name);
+		kfree(dev_attr);
+		msi_attr = msi_attrs[++count];
+	}
+	kfree(msi_attrs);
+	kfree(pdev->msi_irq_groups[0]);
+	kfree(pdev->msi_irq_groups);
+	pdev->msi_irq_groups = NULL;
+}
+
 /**
  * msi_capability_init - configure device's MSI capability structure
  * @dev: pointer to the pci_dev data structure of MSI device function
@@ -610,8 +641,7 @@ static int msix_capability_init(struct p
 				if (pirq_entry->entry_nr == entries[i].entry)
 					break;
 			msi_unmap_pirq(dev, entries[j].vector, 1,
-				       msi_dev_entry->owner,
-				       &pirq_entry->kobj);
+				       msi_dev_entry->owner);
 			detach_pirq_entry(entries[j].entry, msi_dev_entry);
 			entries[j].vector = 0;
 		}
@@ -680,6 +710,31 @@ static int pci_msi_check_device(struct p
 }
 
 /**
+ * pci_msi_vec_count - Return the number of MSI vectors a device can send
+ * @dev: device to report about
+ *
+ * This function returns the number of MSI vectors a device requested via
+ * Multiple Message Capable register. It returns a negative errno if the
+ * device is not capable sending MSI interrupts. Otherwise, the call succeeds
+ * and returns a power of two, up to a maximum of 2^5 (32), according to the
+ * MSI specification.
+ **/
+int pci_msi_vec_count(struct pci_dev *dev)
+{
+	int ret;
+	u16 msgctl;
+
+	if (!dev->msi_cap)
+		return -EINVAL;
+
+	pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &msgctl);
+	ret = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
+
+	return ret;
+}
+EXPORT_SYMBOL(pci_msi_vec_count);
+
+/**
  * pci_enable_msi_block - configure device's MSI capability structure
  * @dev: device to configure
  * @nvec: number of interrupts to configure
@@ -692,20 +747,20 @@ static int pci_msi_check_device(struct p
  * updates the @dev's irq member to the lowest new interrupt number; the
  * other interrupt numbers allocated to this device are consecutive.
  */
-int pci_enable_msi_block(struct pci_dev *dev, unsigned int nvec)
+int pci_enable_msi_block(struct pci_dev *dev, int nvec)
 {
 	int temp, status, maxvec;
-	u16 msgctl;
 	struct msi_dev_list *msi_dev_entry = get_msi_dev_pirq_list(dev);
 
-	if (!dev->msi_cap || dev->current_state != PCI_D0)
+	if (dev->current_state != PCI_D0)
 		return -EINVAL;
 
-	pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &msgctl);
 	if (msi_multi_vec_supported)
-		maxvec = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
+		maxvec = pci_msi_vec_count(dev);
 	else
 		maxvec = 1;
+	if (maxvec < 0)
+		return maxvec;
 	if (nvec > maxvec)
 		return maxvec;
 
@@ -752,31 +807,6 @@ int pci_enable_msi_block(struct pci_dev 
 }
 EXPORT_SYMBOL(pci_enable_msi_block);
 
-int pci_enable_msi_block_auto(struct pci_dev *dev, unsigned int *maxvec)
-{
-	int ret, nvec;
-	u16 msgctl;
-
-	if (!dev->msi_cap || dev->current_state != PCI_D0)
-		return -EINVAL;
-
-	pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &msgctl);
-	ret = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
-
-	if (maxvec)
-		*maxvec = ret;
-
-	do {
-		nvec = ret;
-		ret = pci_enable_msi_block(dev, nvec);
-	} while (ret > 0);
-
-	if (ret < 0)
-		return ret;
-	return nvec;
-}
-EXPORT_SYMBOL(pci_enable_msi_block_auto);
-
 void pci_msi_shutdown(struct pci_dev *dev)
 {
 	int pirq;
@@ -799,9 +829,8 @@ void pci_msi_shutdown(struct pci_dev *de
 	/* Restore dev->irq to its default pin-assertion vector */
 	dev->irq = msi_dev_entry->default_irq;
 	msi_unmap_pirq(dev, pirq, -msi_dev_entry->e.entry_nr,
-		       msi_dev_entry->owner, &msi_dev_entry->e.kobj);
+		       msi_dev_entry->owner);
 	msi_dev_entry->owner = DOMID_IO;
-	memset(&msi_dev_entry->e.kobj, 0, sizeof(msi_dev_entry->e.kobj));
 
 	/* Disable MSI mode */
 	msi_set_enable(dev, 0);
@@ -812,25 +841,29 @@ void pci_msi_shutdown(struct pci_dev *de
 void pci_disable_msi(struct pci_dev *dev)
 {
 	pci_msi_shutdown(dev);
-	kset_unregister(dev->msi_kset);
-	dev->msi_kset = NULL;
+	cleanup_msi_sysfs(dev);
 }
 EXPORT_SYMBOL(pci_disable_msi);
 
 /**
- * pci_msix_table_size - return the number of device's MSI-X table entries
+ * pci_msix_vec_count - return the number of device's MSI-X table entries
  * @dev: pointer to the pci_dev data structure of MSI-X device function
- */
-int pci_msix_table_size(struct pci_dev *dev)
+ * This function returns the number of device's MSI-X table entries and
+ * therefore the number of MSI-X vectors device is capable of sending.
+ * It returns a negative errno if the device is not capable of sending MSI-X
+ * interrupts.
+ **/
+int pci_msix_vec_count(struct pci_dev *dev)
 {
 	u16 control;
 
 	if (!dev->msix_cap)
-		return 0;
+		return -EINVAL;
 
 	pci_read_config_word(dev, dev->msix_cap + PCI_MSIX_FLAGS, &control);
 	return msix_table_size(control);
 }
+EXPORT_SYMBOL(pci_msix_vec_count);
 
 /**
  * pci_enable_msix - configure device's MSI-X capability structure
@@ -900,7 +933,9 @@ int pci_enable_msix(struct pci_dev *dev,
 	if (status)
 		return status;
 
-	nr_entries = pci_msix_table_size(dev);
+	nr_entries = pci_msix_vec_count(dev);
+	if (nr_entries < 0)
+		return nr_entries;
 	if (nvec > nr_entries)
 		return nr_entries;
 
@@ -956,8 +991,6 @@ void pci_msix_shutdown(struct pci_dev *d
 void pci_disable_msix(struct pci_dev *dev)
 {
 	pci_msix_shutdown(dev);
-	kset_unregister(dev->msi_kset);
-	dev->msi_kset = NULL;
 }
 EXPORT_SYMBOL(pci_disable_msix);
 
@@ -977,6 +1010,8 @@ void msi_remove_pci_irq_vectors(struct p
 	if (!pci_msi_enable || !dev)
 		return;
 
+	cleanup_msi_sysfs(dev);
+
 	msi_dev_entry = get_msi_dev_pirq_list(dev);
 
 	for (;;) {
@@ -994,8 +1029,7 @@ void msi_remove_pci_irq_vectors(struct p
 			break;
 		if (is_initial_xendomain())
 			msi_unmap_pirq(dev, pirq_entry->pirq, 1,
-				       msi_dev_entry->owner,
-				       &pirq_entry->kobj);
+				       msi_dev_entry->owner);
 		else
 			evtchn_map_pirq(pirq_entry->pirq, 0, 1);
 		kfree(pirq_entry);
@@ -1045,3 +1079,77 @@ void pci_msi_init_pci_dev(struct pci_dev
 	if (dev->msix_cap && is_initial_xendomain())
 		msix_set_enable(dev, 0);
 }
+
+/**
+ * pci_enable_msi_range - configure device's MSI capability structure
+ * @dev: device to configure
+ * @minvec: minimal number of interrupts to configure
+ * @maxvec: maximum number of interrupts to configure
+ *
+ * This function tries to allocate a maximum possible number of interrupts in a
+ * range between @minvec and @maxvec. It returns a negative errno if an error
+ * occurs. If it succeeds, it returns the actual number of interrupts allocated
+ * and updates the @dev's irq member to the lowest new interrupt number;
+ * the other interrupt numbers allocated to this device are consecutive.
+ **/
+int pci_enable_msi_range(struct pci_dev *dev, int minvec, int maxvec)
+{
+	int nvec = maxvec;
+	int rc;
+
+	if (maxvec < minvec)
+		return -ERANGE;
+
+	do {
+		rc = pci_enable_msi_block(dev, nvec);
+		if (rc < 0) {
+			return rc;
+		} else if (rc > 0) {
+			if (rc < minvec)
+				return -ENOSPC;
+			nvec = rc;
+		}
+	} while (rc);
+
+	return nvec;
+}
+EXPORT_SYMBOL(pci_enable_msi_range);
+
+/**
+ * pci_enable_msix_range - configure device's MSI-X capability structure
+ * @dev: pointer to the pci_dev data structure of MSI-X device function
+ * @entries: pointer to an array of MSI-X entries
+ * @minvec: minimum number of MSI-X irqs requested
+ * @maxvec: maximum number of MSI-X irqs requested
+ *
+ * Setup the MSI-X capability structure of device function with a maximum
+ * possible number of interrupts in the range between @minvec and @maxvec
+ * upon its software driver call to request for MSI-X mode enabled on its
+ * hardware device function. It returns a negative errno if an error occurs.
+ * If it succeeds, it returns the actual number of interrupts allocated and
+ * indicates the successful configuration of MSI-X capability structure
+ * with new allocated MSI-X interrupts.
+ **/
+int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
+			       int minvec, int maxvec)
+{
+	int nvec = maxvec;
+	int rc;
+
+	if (maxvec < minvec)
+		return -ERANGE;
+
+	do {
+		rc = pci_enable_msix(dev, entries, nvec);
+		if (rc < 0) {
+			return rc;
+		} else if (rc > 0) {
+			if (rc < minvec)
+				return -ENOSPC;
+			nvec = rc;
+		}
+	} while (rc);
+
+	return nvec;
+}
+EXPORT_SYMBOL(pci_enable_msix_range);
--- head.orig/drivers/xen/Makefile	2013-08-12 13:00:59.000000000 +0200
+++ head/drivers/xen/Makefile	2014-02-20 10:49:08.000000000 +0100
@@ -8,7 +8,8 @@ ifeq ($(filter y, $(CONFIG_ARM) $(CONFIG
 obj-$(CONFIG_HOTPLUG_CPU)	+= $(xen-hotplug-y)
 endif
 obj-$(CONFIG_X86)		+= fallback.o
-obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o events.o balloon.o manage.o
+obj-$(CONFIG_PARAVIRT_XEN)	+= grant-table.o features.o balloon.o manage.o
+obj-$(CONFIG_PARAVIRT_XEN)	+= events/
 
 xen-balloon_$(CONFIG_XEN)	:= balloon/
 xen-privcmd_$(CONFIG_XEN)	:= privcmd/
@@ -37,7 +38,6 @@ xen-pad-$(CONFIG_X86) += xen-acpi-pad.o
 dom0-$(CONFIG_X86) += pcpu.o
 obj-$(CONFIG_XEN_DOM0)			+= $(dom0-y)
 obj-$(CONFIG_BLOCK)			+= $(xen-biomerge-y)
-obj-$(CONFIG_XEN_XENCOMM)		+= xencomm.o
 obj-$(CONFIG_XEN_BALLOON)		+= $(xen-balloon_y)
 obj-$(CONFIG_XEN_SELFBALLOONING)	+= xen-selfballoon.o
 obj-$(CONFIG_XEN_DEV_EVTCHN)		+= $(xen-evtchn-name-y).o
--- head.orig/drivers/xen/blkback/blkback.c	2013-04-03 10:59:17.000000000 +0200
+++ head/drivers/xen/blkback/blkback.c	2014-02-21 09:00:42.000000000 +0100
@@ -611,7 +611,7 @@ static void dispatch_rw_block_io(blkif_t
 			bio->bi_bdev    = preq.bdev;
 			bio->bi_private = pending_req;
 			bio->bi_end_io  = end_block_io_op;
-			bio->bi_sector  = preq.sector_number;
+			bio->bi_iter.bi_sector = preq.sector_number;
 		}
 
 		preq.sector_number += seg[i].nsec;
@@ -632,7 +632,7 @@ static void dispatch_rw_block_io(blkif_t
 		bio->bi_bdev    = preq.bdev;
 		bio->bi_private = pending_req;
 		bio->bi_end_io  = end_block_io_op;
-		bio->bi_sector  = -1;
+		bio->bi_iter.bi_sector = -1;
 	}
 
 	atomic_set(&pending_req->pendcnt, nbio);
--- head.orig/drivers/xen/netback/netback.c	2014-03-11 10:41:37.000000000 +0100
+++ head/drivers/xen/netback/netback.c	2014-02-20 14:29:04.000000000 +0100
@@ -1491,10 +1491,7 @@ static int netbk_set_skb_gso(netif_t *ne
 	}
 
 	skb_shinfo(skb)->gso_size = gso->u.gso.size;
-
-	/* Header must be checked, and gso_segs computed. */
-	skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;
-	skb_shinfo(skb)->gso_segs = 0;
+	/* gso_segs will be calculated later */
 
 	return 0;
 }
@@ -1760,7 +1757,7 @@ static void net_tx_action(unsigned long 
 
 		skb->protocol = eth_type_trans(skb, dev);
 
-		if (skb_checksum_setup(skb, &netif->rx_gso_csum_fixups)) {
+		if (xennet_checksum_setup(skb, &netif->rx_gso_csum_fixups)) {
 			netdev_dbg(dev,
 				   "Can't setup checksum in net_tx_action\n");
 			kfree_skb(skb);
@@ -1770,6 +1767,21 @@ static void net_tx_action(unsigned long 
 
 		skb_probe_transport_header(skb, 0);
 
+		/*
+		 * If the packet is GSO then we will have just set up the
+		 * transport header offset in checksum_setup so it's now
+		 * straightforward to calculate gso_segs.
+		 */
+		if (skb_is_gso(skb)) {
+			unsigned int mss = skb_shinfo(skb)->gso_size;
+			unsigned int hdrlen = skb_transport_header(skb) -
+					      skb_mac_header(skb) +
+					      tcp_hdrlen(skb);
+
+			skb_shinfo(skb)->gso_segs =
+				DIV_ROUND_UP(skb->len - hdrlen, mss);
+		}
+
 		dev->stats.rx_bytes += skb->len;
 		dev->stats.rx_packets++;
 
--- head.orig/drivers/xen/netfront/netfront.c	2014-01-07 16:42:29.000000000 +0100
+++ head/drivers/xen/netfront/netfront.c	2014-02-20 14:45:45.000000000 +0100
@@ -476,6 +476,16 @@ again:
 		goto abort_transaction;
 	}
 
+#ifdef NETIF_F_TSO6
+	err = xenbus_write(xbt, dev->nodename, "feature-gso-tcpv6", "1");
+	if (err) {
+		message = "writing feature-gso-tcpv6";
+		goto abort_transaction;
+	}
+#else
+#define NETIF_F_TSO6 0
+#endif
+
 	err = xenbus_transaction_end(xbt, 0);
 	if (err) {
 		if (err == -EAGAIN)
@@ -1061,7 +1071,9 @@ static int network_start_xmit(struct sk_
 			tx->flags |= XEN_NETTXF_extra_info;
 
 		gso->u.gso.size = skb_shinfo(skb)->gso_size;
-		gso->u.gso.type = XEN_NETIF_GSO_TYPE_TCPV4;
+		gso->u.gso.type = skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6 ?
+			XEN_NETIF_GSO_TYPE_TCPV6 :
+			XEN_NETIF_GSO_TYPE_TCPV4;
 		gso->u.gso.pad = 0;
 		gso->u.gso.features = 0;
 
@@ -1348,8 +1360,8 @@ static int xennet_set_skb_gso(struct sk_
 		return -EINVAL;
 	}
 
-	/* Currently only TCPv4 S.O. is supported. */
-	if (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {
+	if (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4 &&
+	    gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV6) {
 		if (net_ratelimit())
 			netdev_warn(skb->dev, "Bad GSO type %d.\n",
 				    gso->u.gso.type);
@@ -1359,7 +1371,9 @@ static int xennet_set_skb_gso(struct sk_
 #if HAVE_TSO
 	skb_shinfo(skb)->gso_size = gso->u.gso.size;
 #if HAVE_GSO
-	skb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;
+	skb_shinfo(skb)->gso_type =
+		gso->u.gso.type == XEN_NETIF_GSO_TYPE_TCPV4
+		? SKB_GSO_TCPV4 : SKB_GSO_TCPV6;
 
 	/* Header must be checked, and gso_segs computed. */
 	skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;
@@ -1487,7 +1501,7 @@ err:	
 		/* Ethernet work: Delayed to here as it peeks the header. */
 		skb->protocol = eth_type_trans(skb, dev);
 
-		if (skb_checksum_setup(skb, &np->rx_gso_csum_fixups)) {
+		if (xennet_checksum_setup(skb, &np->rx_gso_csum_fixups)) {
 			kfree_skb(skb);
 			dev->stats.rx_errors++;
 			--work_done;
@@ -2100,6 +2114,15 @@ static netdev_features_t xennet_fix_feat
 			features &= ~NETIF_F_IPV6_CSUM;
 	}
 
+	if (features & NETIF_F_TSO6) {
+		if (xenbus_scanf(XBT_NIL, np->xbdev->otherend,
+				 "feature-gso-tcpv6", "%d", &val) < 0)
+			val = 0;
+
+		if (!val)
+			features &= ~NETIF_F_TSO6;
+	}
+
 	return features;
 }
 
@@ -2202,7 +2225,7 @@ static struct net_device *create_netdev(
 	netif_napi_add(netdev, &np->napi, netif_poll, 64);
 	netdev->features        = NETIF_F_RXCSUM | NETIF_F_GSO_ROBUST;
 	netdev->hw_features	= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM
-				  | NETIF_F_SG | NETIF_F_TSO;
+				  | NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6;
 
 	/*
          * Assume that all hw features are available for now. This set
--- head.orig/drivers/xen/pcifront/pci_op.c	2013-04-11 16:13:59.000000000 +0200
+++ head/drivers/xen/pcifront/pci_op.c	2014-02-20 14:57:11.000000000 +0100
@@ -459,9 +459,12 @@ int pcifront_scan_root(struct pcifront_d
 	}
 	pcifront_init_sd(sd, domain, bus, pdev);
 
+	pci_lock_rescan_remove();
+
 	b = pci_scan_bus_parented(&pdev->xdev->dev, bus,
 				  &pcifront_bus_ops, sd);
 	if (!b) {
+		pci_unlock_rescan_remove();
 		dev_err(&pdev->xdev->dev,
 			"Error creating PCI Frontend Bus!\n");
 		err = -ENOMEM;
@@ -477,6 +480,7 @@ int pcifront_scan_root(struct pcifront_d
 	pci_walk_bus(b, pcifront_claim_resource, pdev);
 
 	pci_bus_add_devices(b);
+	pci_unlock_rescan_remove();
 
 	return 0;
 
@@ -559,6 +563,7 @@ void pcifront_free_roots(struct pcifront
 
 	dev_dbg(&pdev->xdev->dev, "cleaning up root buses\n");
 
+	pci_lock_rescan_remove();
 	list_for_each_entry_safe(bus_entry, t, &pdev->root_buses, list) {
 		list_del(&bus_entry->list);
 
@@ -571,6 +576,7 @@ void pcifront_free_roots(struct pcifront
 
 		kfree(bus_entry);
 	}
+	pci_unlock_rescan_remove();
 }
 
 static pci_ers_result_t pcifront_common_process( int cmd, struct pcifront_device *pdev,
--- head.orig/drivers/xen/pcifront/xenbus.c	2013-01-09 17:02:43.000000000 +0100
+++ head/drivers/xen/pcifront/xenbus.c	2014-02-20 14:58:48.000000000 +0100
@@ -368,8 +368,10 @@ static int pcifront_detach_devices(struc
 				domain, bus, slot, func);
 			continue;
 		}
+		pci_lock_rescan_remove();
 		pci_stop_and_remove_bus_device(pci_dev);
 		pci_dev_put(pci_dev);
+		pci_unlock_rescan_remove();
 
 		dev_dbg(&pdev->xdev->dev,
 			"PCI device %04x:%02x:%02x.%u removed.\n",
--- head.orig/drivers/xen/sfc_netfront/accel_vi.c	2011-11-21 17:10:44.000000000 +0100
+++ head/drivers/xen/sfc_netfront/accel_vi.c	2014-02-21 09:04:58.000000000 +0100
@@ -767,7 +767,7 @@ static void  netfront_accel_vi_rx_comple
 		spin_unlock_irqrestore(&vnic->table_lock, flags);
 	}
 
-	if (compare_ether_addr(skb->data, vnic->mac)) {
+	if (!ether_addr_equal(skb->data, vnic->mac)) {
 		struct iphdr *ip = (struct iphdr *)(skb->data + ETH_HLEN);
 		u16 port;
 
--- head.orig/drivers/xen/xenbus/xenbus_client.c	2013-06-04 14:12:33.000000000 +0200
+++ head/drivers/xen/xenbus/xenbus_client.c	2014-02-20 10:49:08.000000000 +0100
@@ -50,6 +50,7 @@
 #endif
 #include <xen/xenbus.h>
 #include <xen/xen.h>
+#include <xen/features.h>
 
 #if defined(CONFIG_PARAVIRT_XEN)
 #include "xenbus_probe.h"
@@ -727,7 +728,7 @@ static const struct xenbus_ring_ops ring
 
 void __init xenbus_ring_ops_init(void)
 {
-	if (xen_pv_domain())
+	if (!xen_feature(XENFEAT_auto_translated_physmap))
 		ring_ops = &ring_ops_pv;
 	else
 		ring_ops = &ring_ops_hvm;
--- head.orig/include/xen/evtchn.h	2013-08-08 11:31:59.000000000 +0200
+++ head/include/xen/evtchn.h	2014-02-20 13:52:59.000000000 +0100
@@ -47,6 +47,7 @@
 /*
  * LOW-LEVEL DEFINITIONS
  */
+#define xen_evtchn_nr_channels() EVTCHN_2L_NR_CHANNELS
 
 #ifdef CONFIG_XEN
 struct irq_cfg {
--- head.orig/include/xen/interface/xen.h	2014-03-28 12:30:41.000000000 +0100
+++ head/include/xen/interface/xen.h	2014-02-20 10:49:08.000000000 +0100
@@ -564,7 +564,7 @@ DEFINE_GUEST_HANDLE_STRUCT(multicall_ent
 typedef struct multicall_entry multicall_entry_t;
 DEFINE_XEN_GUEST_HANDLE(multicall_entry_t);
 
-#if defined(CONFIG_PARAVIRT_XEN) || __XEN_INTERFACE_VERSION__ < 0x00040400
+#if defined(__XEN_INTERFACE_VERSION__) && __XEN_INTERFACE_VERSION__ < 0x00040400
 /*
  * Event channel endpoints per domain (when using the 2-level ABI):
  *  1024 if a long is 32 bits; 4096 if a long is 64 bits.
--- head.orig/include/xen/net-util.h	2014-02-12 08:53:44.000000000 +0100
+++ head/include/xen/net-util.h	2014-02-20 13:39:13.000000000 +0100
@@ -3,195 +3,12 @@
 
 #include <linux/kernel.h>
 #include <linux/skbuff.h>
-#include <linux/tcp.h>
-#include <linux/udp.h>
-#include <net/ip.h>
-#include <net/ip6_checksum.h>
 
-static inline int _maybe_pull_tail(struct sk_buff *skb, unsigned int len,
-				   unsigned int max)
-{
-	if (skb_headlen(skb) >= len)
-		return 0;
-
-	/*
-	 * If we need to pullup then pullup to the max, so we won't need to
-	 * do it again.
-	 */
-	if (max > skb->len)
-		max = skb->len;
-
-	if (!__pskb_pull_tail(skb, max - skb_headlen(skb)))
-		return -ENOMEM;
-
-	if (skb_headlen(skb) < len)
-		return -EPROTO;
-
-	return 0;
-}
-
-static inline __be16 *_checksum_setup_ip(struct sk_buff *skb,
-					 typeof(IPPROTO_IP) proto,
-					 unsigned int off, unsigned int ver)
-{
-	switch (proto) {
-		int err;
-
-	case IPPROTO_TCP:
-		err = _maybe_pull_tail(skb, off + sizeof(struct tcphdr),
-				       off + sizeof(struct tcphdr));
-		if (!err && !skb_partial_csum_set(skb, off,
-						  offsetof(struct tcphdr,
-							   check)))
-			err = -EPROTO;
-		return err ? ERR_PTR(err) : &tcp_hdr(skb)->check;
-
-	case IPPROTO_UDP:
-		err = _maybe_pull_tail(skb, off + sizeof(struct udphdr),
-				       off + sizeof(struct udphdr));
-		if (!err && !skb_partial_csum_set(skb, off,
-						  offsetof(struct udphdr,
-							   check)))
-			err = -EPROTO;
-		return err ? ERR_PTR(err) : &udp_hdr(skb)->check;
-	}
-
-	net_err_ratelimited("Attempting to checksum a non-TCPv%u/UDPv%u packet,"
-			    " dropping a protocol %d packet\n",
-			    proto, ver, ver);
-	return ERR_PTR(-EPROTO);
-}
-
-/*
- * This value should be large enough to cover a tagged ethernet header plus
- * maximally sized IP and TCP or UDP headers.
- */
-#define MAX_IP_HDR_LEN 128
-
-static inline int _checksum_setup_ipv4(struct sk_buff *skb, bool recalc)
-{
-	const struct iphdr *iph;
-	__be16 *csum;
-	unsigned int off;
-	int err = _maybe_pull_tail(skb, sizeof(*iph), MAX_IP_HDR_LEN);
-
-	if (err)
-		return err;
-	iph = ip_hdr(skb);
-	if (iph->frag_off & htons(IP_OFFSET | IP_MF)) {
-		net_err_ratelimited("Packet is a fragment\n");
-		return -EPROTO;
-	}
-	off = 4 * iph->ihl;
-	csum = _checksum_setup_ip(skb, iph->protocol, off, 4);
-	if (IS_ERR(csum))
-		return PTR_ERR(csum);
-
-	if (recalc) {
-		iph = ip_hdr(skb);
-		*csum = ~csum_tcpudp_magic(iph->saddr, iph->daddr,
-					   skb->len - off, iph->protocol, 0);
-	}
-
-	return 0;
-}
-
-/*
- * This value should be large enough to cover a tagged ethernet header plus
- * an IPv6 header, all options, and a maximal TCP or UDP header.
- */
-#define MAX_IPV6_HDR_LEN 256
-
-static inline int _checksum_setup_ipv6(struct sk_buff *skb, bool recalc)
-{
-#define OPT_HDR(type, skb, off) ((type *)(skb_network_header(skb) + (off)))
-	const struct ipv6hdr *ipv6h;
-	__be16 *csum;
-	unsigned int off = sizeof(*ipv6h);
-	u8 nexthdr;
-	bool done = false, fragment = false;
-	int err = _maybe_pull_tail(skb, off, MAX_IPV6_HDR_LEN);
-
-	if (err)
-		return err;
-	ipv6h = ipv6_hdr(skb);
-	nexthdr = ipv6h->nexthdr;
-
-	while ((off <= sizeof(*ipv6h) + ntohs(ipv6h->payload_len)) && !done) {
-		switch (nexthdr) {
-		case IPPROTO_DSTOPTS:
-		case IPPROTO_HOPOPTS:
-		case IPPROTO_ROUTING: {
-			const struct ipv6_opt_hdr *hp;
-
-			err = _maybe_pull_tail(skb, off + sizeof(*hp),
-					       MAX_IPV6_HDR_LEN);
-			if (err)
-				return err;
-			hp = OPT_HDR(struct ipv6_opt_hdr, skb, off);
-			nexthdr = hp->nexthdr;
-			off += ipv6_optlen(hp);
-			break;
-		}
-		case IPPROTO_AH: {
-			const struct ip_auth_hdr *hp;
-
-			err = _maybe_pull_tail(skb, off + sizeof(*hp),
-					       MAX_IPV6_HDR_LEN);
-			if (err)
-				return err;
-			hp = OPT_HDR(struct ip_auth_hdr, skb, off);
-			nexthdr = hp->nexthdr;
-			off += ipv6_authlen(hp);
-			break;
-		}
-		case IPPROTO_FRAGMENT: {
-			const struct frag_hdr *hp;
-
-			err = _maybe_pull_tail(skb, off + sizeof(*hp),
-					       MAX_IPV6_HDR_LEN);
-			if (err < 0)
-				return err;
-			hp = OPT_HDR(struct frag_hdr, skb, off);
-			if (hp->frag_off & htons(IP6_OFFSET | IP6_MF))
-				fragment = true;
-			nexthdr = hp->nexthdr;
-			off += sizeof(*hp);
-			break;
-		}
-		default:
-			done = true;
-			break;
-		}
-		ipv6h = ipv6_hdr(skb);
-	}
-
-	if (!done || fragment) {
-		net_err_ratelimited("%s\n",
-				    done ? "Failed to parse packet header"
-					 : "Packet is a v6 fragment");
-		return -EPROTO;
-	}
-
-	csum = _checksum_setup_ip(skb, nexthdr, off, 4);
-	if (IS_ERR(csum))
-		return PTR_ERR(csum);
-
-	if (recalc) {
-		ipv6h = ipv6_hdr(skb);
-		*csum = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,
-					 skb->len - off, nexthdr, 0);
-	}
-
-	return 0;
-#undef OPT_HDR
-}
-
-static inline int skb_checksum_setup(struct sk_buff *skb,
-				     unsigned long *fixup_counter)
+static inline int xennet_checksum_setup(struct sk_buff *skb,
+					unsigned long *fixup_counter)
 {
 	bool recalc = false;
-	int err = -EPROTO;
+	int err;
 
 	skb_reset_network_header(skb);
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
@@ -209,14 +26,7 @@ static inline int skb_checksum_setup(str
 		recalc = true;
 	}
 
-	switch (skb->protocol) {
-	case htons(ETH_P_IP):
-		err = _checksum_setup_ipv4(skb, recalc);
-		break;
-	case htons(ETH_P_IPV6):
-		err = _checksum_setup_ipv6(skb, recalc);
-		break;
-	}
+	err = skb_checksum_setup(skb, recalc);
 	if (!err)
 		skb_probe_transport_header(skb, 0);
 
--- head.orig/include/xen/xen.h	2012-10-23 15:29:28.000000000 +0200
+++ head/include/xen/xen.h	2014-02-20 13:58:16.000000000 +0100
@@ -29,6 +29,7 @@ extern enum xen_domain_type xen_domain_t
 				 xen_start_info && xen_start_info->flags & SIF_INITDOMAIN)
 #elif defined(CONFIG_XEN)
 #define xen_initial_domain()	is_initial_xendomain()
+#define xen_has_pv_devices()	is_running_on_xen()
 #else  /* !CONFIG_XEN_DOM0 */
 #define xen_initial_domain()	(0)
 #endif	/* CONFIG_XEN_DOM0 */
--- head.orig/lib/swiotlb-xen.c	2013-12-06 15:23:26.000000000 +0100
+++ head/lib/swiotlb-xen.c	2014-02-20 10:49:08.000000000 +0100
@@ -214,8 +214,9 @@ _swiotlb_init_with_tbl(char *tlb, unsign
 	/*
 	 * Get the overflow emergency buffer
 	 */
-	v_overflow_buffer = alloc_bootmem_pages_nopanic(
-						PAGE_ALIGN(io_tlb_overflow));
+	v_overflow_buffer = memblock_virt_alloc_nopanic(
+						PAGE_ALIGN(io_tlb_overflow),
+						PAGE_SIZE);
 	if (!v_overflow_buffer)
 		return msg_mem;
 
@@ -225,11 +226,15 @@ _swiotlb_init_with_tbl(char *tlb, unsign
 	 * Allocate and initialize the free list array.  This array is used
 	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE.
 	 */
-	io_tlb_list = alloc_bootmem_pages(PAGE_ALIGN(io_tlb_nslabs * sizeof(int)));
+	io_tlb_list = memblock_virt_alloc(
+				PAGE_ALIGN(io_tlb_nslabs * sizeof(int)),
+				PAGE_SIZE);
 	for (i = 0; i < io_tlb_nslabs; i++)
  		io_tlb_list[i] = IO_TLB_SEGSIZE - OFFSET(i, IO_TLB_SEGSIZE);
 	io_tlb_index = 0;
-	io_tlb_orig_addr = alloc_bootmem_pages(PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)));
+	io_tlb_orig_addr = memblock_virt_alloc(
+				PAGE_ALIGN(io_tlb_nslabs * sizeof(phys_addr_t)),
+				PAGE_SIZE);
 
 	do {
 		rc = xen_create_contiguous_region(
@@ -286,7 +291,7 @@ swiotlb_init(int verbose)
 	bytes = io_tlb_nslabs << IO_TLB_SHIFT;
 
 	/* Get IO TLB memory from the low pages */
-	vstart = alloc_bootmem_pages_nopanic(PAGE_ALIGN(bytes));
+	vstart = memblock_virt_alloc_nopanic(PAGE_ALIGN(bytes), PAGE_SIZE);
 	msg = _swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose);
 	if (!msg)
 		return;
@@ -294,8 +299,8 @@ swiotlb_init(int verbose)
 	if (swiotlb_force > 0)
 		panic(msg);
 	if (io_tlb_start)
-		free_bootmem(io_tlb_start,
-			     PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
+		memblock_free_early(io_tlb_start,
+				    PAGE_ALIGN(io_tlb_nslabs << IO_TLB_SHIFT));
 	pr_warn("%s\n", msg);
 	no_iotlb_memory = true;
 }
@@ -448,7 +453,8 @@ phys_addr_t swiotlb_tbl_map_single(struc
 
 not_found:
 	spin_unlock_irqrestore(&io_tlb_lock, flags);
-	dev_warn(hwdev, "swiotlb buffer is full\n");
+	if (printk_ratelimit())
+		dev_warn(hwdev, "swiotlb buffer is full (sz: %zd bytes)\n", size);
 	return SWIOTLB_MAP_ERROR;
 found:
 	spin_unlock_irqrestore(&io_tlb_lock, flags);

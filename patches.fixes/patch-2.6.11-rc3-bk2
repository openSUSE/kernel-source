From: olh@suse.de
Subject: patch-2.6.11-rc3-bk2

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk1.log	2005-02-04 13:58:58.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc3-bk2.log	2005-02-05 13:59:05.000000000 +0100
 ChangeSet@1.2115, 2005-02-04 20:12:20-08:00, torvalds@ppc970.osdl.org
   Add extra debugging help for bad user accesses.
 
 ChangeSet@1.2114, 2005-02-04 19:49:54-08:00, paulus@samba.org
   [PATCH] Fix PPC rwlock code on SMP
   
   Currently, the kernel won't compile for SMP ppc32 if preempt is
   enabled.  This patch adds suitable read_can_lock and write_can_lock
   definitions.
   
   This patch also adds a real _raw_read_trylock (inline and out-of-line
   versions), changes the rwlock->lock field to a signed int, which is
   what it really was all along, and cleans up the out-of-line rwlock
   code in arch/ppc/lib/locks.c.  It removes the debug fields from the
   rwlock struct because we were never using them, even with
   CONFIG_DEBUG_SPINLOCK set.
   
   I have compile and boot tested this with the four combinations of
   CONFIG_DEBUG_SPINLOCKS on and off, and CONFIG_PREEMPT on and off.
   Please put this patch into 2.6.11 so that 2.6.11 will work for
   ppc32 with CONFIG_SMP and CONFIG_PREEMPT.
   
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2113, 2005-02-04 19:20:45-08:00, venkatesh.pallipadi@intel.com
   [PATCH] x86: HPET setup, duplicate HPET_T0_CMP needed for some platforms
   
   This patch fixes the issue with HPET on some platforms.
   
   According to Vojtech Pavlik:
   
   The first write after writing TN_SETVAL to the config register sets the
   counter value, the second write sets the threshold.
   
   When you only do the first write you never set the threshold and interrupts
   won't be generated properly.
   
   Thanks to John Stultz and Andrew Walrond for reporting, root causing the
   issue and verifying this fix.
   
   Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2112, 2005-02-04 19:20:31-08:00, sfr@canb.auug.org.au
   [PATCH] ppc64: replace last usage of vio dma mapping routines
   
   This patch just replaces the last usage of the vio dma mapping routines
   with the equivalent generic dma mapping routines.
   
   Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2111, 2005-02-04 19:20:17-08:00, nathanl@austin.ibm.com
   [PATCH] ppc64: show -1 for physical_id of non-present cpus
   
   Make the physical_id cpu sysfs attribute on ppc64 show -1 instead of
   65535 for non-present cpus.
   
   Signed-off-by: Nathan Lynch <nathanl@austin.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2110, 2005-02-04 19:20:03-08:00, paulus@samba.org
   [PATCH] ppc64: correct return code in syscall auditing
   
   This patch is from David Woodhouse <dwmw2@infradead.org>.
   
   We were pretending that every syscall returned zero. Don't do that.
   
   Signed-Off-By: David Woodhouse <dwmw2@infradead.org>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2109, 2005-02-04 19:19:47-08:00, anton@samba.org
   [PATCH] Use MM_VM_SIZE in exit_mmap
   
   The 4 level pagetable code changed the exit_mmap code to rely on TASK_SIZE.
    On some architectures (eg ppc64 and ia64), this is a per task property and
   bad things can happen in certain circumstances when using it.
   
   It is possible for one task to end up "owning" an mm from another - we have
   seen this with the procfs code when process 1 accesses /proc/pid/cmdline of
   process 2 while it is exiting.  Process 2 exits but does not tear its mm
   down.  Later on process 1 finishes with the proc file and the mm gets torn
   down at this point.
   
   Now if process 1 was 32bit and process 2 was 64bit then we end up using a
   bad value for TASK_SIZE in exit_mmap.  We only tear down part of the
   address space and leave half initialised pagetables and entries in the MMU
   etc.
   
   MM_VM_SIZE() was created for this purpose (and is used in the next line for
   tlb_finish_mmu), so use it.  I moved the PGD round up of TASK_SIZE into the
   default MM_VM_SIZE.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2108, 2005-02-04 19:19:34-08:00, dwmw2@infradead.org
   [PATCH] TASK_SIZE is variable.
   
   Bad things can happen if a 32-bit process is the last user of a 64-bit mm. 
   TASK_SIZE isn't a constant, and we can end up clearing page tables only up
   to the 32-bit TASK_SIZE instead of all the way.  We should probably
   double-check every instance of TASK_SIZE or USER_PTRS_PER_PGD for this kind
   of problem.
   
   We should also double-check that MM_VM_SIZE() and other such things are
   correctly defined on all architectures.  I already fixed ppc64 which let it
   stay as TASK_SIZE, and hence dependent on the _current_ context instead of
   the mm in the argument.
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2107, 2005-02-04 19:19:20-08:00, trini@kernel.crashing.org
   [PATCH] ppc32: MPC82xx PCI9 errata workaround broken
   
   Changeset 1.1938.196.11 broke MPC8260 PCI9 Errata workaround.  This pach
   makes it work again.
   
   Signed-off-by: Rune Torgersen <runet@innovsys.com>
   Signed-off-by: Tom Rini <trini@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2106, 2005-02-04 19:19:04-08:00, jdike@addtoit.com
   [PATCH] uml: fix x86_64 submode compilation
   
   Forgot to use ARCH_USER_CFLAGS after defining it for x86_64.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2105, 2005-02-04 19:18:49-08:00, jdike@addtoit.com
   [PATCH] uml: fix STATIC_LINK compilation
   
   This fixes a bug which assumes that __binary_start starts on a page boundary,
   which isn't true when UML is configured to load into the normal executable
   area.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2104, 2005-02-04 19:18:36-08:00, jdike@addtoit.com
   [PATCH] uml: fix broken #ifdef clause causing crashes
   
   The previous ifdef to check whether to use the host's vsyscall page was buggy.
   This bug can cause crashes.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2103, 2005-02-04 19:18:22-08:00, jdike@addtoit.com
   [PATCH] uml: fix jiffies initialization
   
   Initialize jiffies_64 to INITIAL_JIFFIES.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2102, 2005-02-04 19:18:08-08:00, bstroesser@fujitsu-siemens.com
   [PATCH] uml: disallow stack access below $esp like i386 / x86_64
   
   When a page fault occurs on an address below the stack-vma, UML tries to
   expand the stack.
   
   On i386 and x86_64, the failing address is compared to the current userspace
   stack pointer.  If the failing address is below "esp-32" resp.  "rsp-128",
   stack expansion is not allowed, and a SIGSEGV is given to the user.
   
   This patch makes UML behave like i386/x86_64.
   
   Signed-off-by: Bodo Stroesser <bstroesser@fujitsu-siemens.com>
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2101, 2005-02-04 19:17:54-08:00, jdike@addtoit.com
   [PATCH] uml: Fix SKAS sig-handler reentrancy
   
   This adds code which enables SIGSEGV reception to the SKAS sig_handler_common,
   which matches the tt code.
   
   I still need to figure out why the SA_NODEFER flag was backed out in favor of
   this.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   CC: uml-devel <user-mode-linux-devel@lists.sourceforge.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2100, 2005-02-04 19:17:41-08:00, blaisorblade@yahoo.it
   [PATCH] uml: kconfig fixes
   
   Change some config text (hide CONFIG_MODVERSION which is broken on UML and fix
   a dummy prompt).
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2099, 2005-02-04 19:17:26-08:00, blaisorblade@yahoo.it
   [PATCH] uml: fix compilation for missing headers
   
   Re-add some needed headers inclusion deleted in
   http://linux.bkbits.net:8080/linux-2.5/cset@41e49628dGbOWX-bT9yZII4f19GT6A
   
   If you think it cannot make sense to include both <sys/ptrace.h> and
   <linux/ptrace.h> (as userspace process, i.e.  host includes), go complaining
   with glibc, or follow the linux-abi includes idea.
   
   However, the compilation failure is possibly glibc-version (or better glibc
   includes version) related - what I now is that the failure happens on my
   system with a glibc 2.3.4 (from Gentoo).
   
   Also, fix the syscall table to both compile and have no empty slot (which
   could cause Oopses).
   
   Acked-by: Jeff Dike <jdike@addtoit.com>
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2098, 2005-02-04 19:17:12-08:00, blaisorblade@yahoo.it
   [PATCH] uml: makefile fix
   
   arch/um/Kconfig_arch is actually a symlink, so
   * Remove it from the tree.
   * Make sure it is removed during make mrproper.
   
   Signed-off-by: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2097, 2005-02-04 19:16:59-08:00, akpm@osdl.org
   [PATCH] nfsd needs exportfs
   
   With NFSD=y, EXPORTFS=m:
   
   fs/built-in.o(.text+0x7fff5): In function `fh_verify':
   /usr/src/25/fs/nfsd/nfsfh.c:221: undefined reference to `export_op_default'
   
   So it seems that nfsd requires exportfs.
   
   For consistency we should tidy up the definition of EXPORTFS too.
   
   Signed-off-by: Neil Brown <neilb@cse.unsw.edu.au>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2096, 2005-02-04 19:16:45-08:00, michal@logix.cz
   [PATCH] Update Michal Ludvig details
   
   Signed-off-by: Michal Ludvig <michal@logix.cz>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2095, 2005-02-04 19:16:31-08:00, nacc@us.ibm.com
   [PATCH] include/jiffies: fix usecs_to_jiffies()/jiffies_to_usecs() math
   
   Fixes the math of both jiffies_to_usecs() and usecs_to_jiffies() which
   improperly assume the same rounding point -- 1,000 -- as jiffies_to_msecs()
   and msecs_to_jiffies(), when in fact it should be 1,000,000.  Furthermore,
   the actual math of both functions is actually wrong and will lead to more
   than just rounding errors.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2094, 2005-02-04 19:16:18-08:00, jimix@watson.ibm.com
   [PATCH] Fix devfs name for the hvcs driver
   
   The hvcs driver does not register a devfs_name resulting in devfs creating
   /dev/<NULL>* entries.  The following one line patch remedies the problem.
   
   Signed-off-by: Jimi Xenidis <jimix@watson.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2093, 2005-02-04 19:16:04-08:00, davej@redhat.com
   [PATCH] ibmveth inlining failure.
   
   Yet another ppc64 build failure..  Move the function before its first
   usage, and the failure goes away.
   
   Signed-off-by: Dave Jones <davej@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2092, 2005-02-04 19:15:50-08:00, nanhai.zou@intel.com
   [PATCH] fix an error in /proc/slabinfo print
   
   There is an obvious error in the header of /proc/slabinfo
   
   Signed-off-by: Zou Nan hai <nanhai.zou@intel.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2091, 2005-02-04 19:15:36-08:00, jgreen@users.sourceforge.net
   [PATCH] pcmcia: ds.c initialisation fix
   
   A wrong ordering of operators in pcmica_register_client() causes
   initialization problems with multiple PCMCIA cards.
   
   Signed-off-by: Josh Green <jgreen@users.sourceforge.net>
   Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2090, 2005-02-04 19:15:23-08:00, sds@tycho.nsa.gov
   [PATCH] SELinux: fix selinux_inode_setattr hook
   
   This fixes the selinux_inode_setattr hook function to honor the ATTR_FORCE
   flag, skipping any permission checking in that case.  Otherwise, it is
   possible though unlikely for a denial from the hook to prevent proper
   updating, e.g.  for remove_suid upon writing to a file.  This would only
   occur if the process had write permission to a suid file but lacked setattr
   permission to it.
   
   Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
   Signed-off-by: James Morris <jmorris@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2089, 2005-02-04 15:26:44-08:00, greg@kroah.com
   [PATCH] Update greg's email address
   
   I have a new job.
   
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2088, 2005-02-04 15:26:30-08:00, dhowells@redhat.com
   [PATCH] FRV: vmlinux.lds.S comment cleanup
   
   This cleans up a comment in vmlinux.lds.S - emacs now has an LD script
   mode, so it shouldn't be forced into C mode. 
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2087, 2005-02-04 15:26:15-08:00, dhowells@redhat.com
   [PATCH] FRV: Make the bit finding functions take const pointers
   
   This makes the bit finding functions in asm/bitops.h take const pointers
   since they don't modify what they access. 
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2086, 2005-02-04 15:26:01-08:00, dhowells@redhat.com
   [PATCH] FRV: Add TIF_MEMDIE
   
   This adds TIF_MEMDIE for FRV. 
   
   Could whoever added it to include/asm-i386/thread_info.h comment this flag
   there please? I've given it a comment here, but I'm not sure it's correct.
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2085, 2005-02-04 15:25:47-08:00, dhowells@redhat.com
   [PATCH] FRV: Semaphore implementation race fix
   
   This fixes a race in the FRV arch's semaphore implementation.  The same
   type of fixes were applied to the rw-semaphore implementations to fix
   the same races there.
   
   The race involved the on-stack record linked into the semaphore's queue
   by the down() executed by a process now sleeping on the semaphore going
   away and the sleeping task going away before the process that woke it up
   during up() processing had finished with those structures.
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2084, 2005-02-04 15:25:33-08:00, dhowells@redhat.com
   [PATCH] FRV: cli/sti cleanup
   
   This cleans up the remaining references to the cli() and sti() functions
   from the FRV arch now they're deprecated. 
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2083, 2005-02-04 15:25:19-08:00, dhowells@redhat.com
   [PATCH] FRV: Make switch_to() return previous task
   
   This makes switch_to() on the FRV pass through and return the previous
   task pointer rather than trusting to luck that it'll be left in the
   correct register/variable. 
   
   Signed-Off-By: David Howells <dhowells@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2082, 2005-02-04 10:25:20-08:00, alan@lxorguk.ukuu.org.uk
   [PATCH] more fixes for the Moxa driver
   
   One user hit problems on SMP that are caused by long standing mxser
   violations of the tty rules. Another report including problems with
   request_irq being called with locks held (legal in 2.4 but not 2.6 due
   to procfs). This fixes both of them
   
   Signed-off-by: Alan Cox <alan@redhat.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2081, 2005-02-04 10:01:31-08:00, nickpiggin@yahoo.com.au
   [PATCH] Fix kswapd spinning
   
   When a zone (usually DMA) has no active pages, pages_scanned (which
   triggers all_unreclaimable) is only incremented when scanning the active
   list. 
   
   Make sure it's incremented for scanned cache entries too.
   
   Tested-by: Terje Fåberg <terje_fb@yahoo.no>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2080, 2005-02-04 08:21:12-08:00, jdike@addtoit.com
   [PATCH] UML: remove not-yet-merged system calls
   
   This fixes UML's sys_call_table to delete some entries for system calls
   which have not yet made it into mainline from -mm.
   
   I also delete UML's __pud_alloc implementation since the memory.c one is
   now enabled.
   
   Signed-off-by: Jeff Dike <jdike@addtoit.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2078, 2005-02-04 07:56:11-08:00, kraxel@bytesex.org
   [PATCH] tv-card tuner fixup
   
   disable + comment current secam tweak, will not work that way ...
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.1983.1.23, 2005-02-03 23:01:36+00:00, nico@org.rmk.(none)
   [ARM PATCH] 2456/1: fix futex syscall argument passing
   
   Patch from Nicolas Pitre
   
   sys_futex wrapper to store its sixth argument on the stack.
   Also fix a typo with sys_clone_wapper.
   
   Signed-off-by: Nicolas Pitre
   Signed-off-by: Russell King
 
 ChangeSet@1.1983.1.22, 2005-02-03 22:19:58+00:00, rmk@flint.arm.linux.org.uk
   [ARM] Fix sys_syscall
   
   Signed-off-by: Russell King
 
diff -purN linux-2.6.11-rc3-bk1/CREDITS linux-2.6.11-rc3-bk2/CREDITS
--- linux-2.6.11-rc3-bk1/CREDITS	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk2/CREDITS	2005-02-05 16:59:13.514160284 +0100
@@ -1811,7 +1811,8 @@ D: CYPRESS CY82C693 chipset IDE, Digital
 
 N: Greg Kroah-Hartman
 E: greg@kroah.com
-W: http://www.kroah.com/linux-usb/
+E: gregkh@suse.de
+W: http://www.kroah.com/linux/
 D: USB Serial Converter driver framework, USB Handspring Visor driver
 D: ConnectTech WHITEHeat USB driver, Generic USB Serial driver
 D: USB I/O Edgeport driver, USB Serial IrDA driver
@@ -1819,6 +1820,7 @@ D: USB Bluetooth driver, USB Skeleton dr
 D: bits and pieces of USB core code.
 D: PCI Hotplug core, PCI Hotplug Compaq driver modifications
 D: portions of the Linux Security Module (LSM) framework
+D: parts of the driver core, debugfs.
 
 N: Russell Kroll
 E: rkroll@exploits.org
@@ -2023,12 +2025,14 @@ D: GCC + libraries hacker
 
 N: Michal Ludvig
 E: michal@logix.cz
+E: michal.ludvig@asterisk.co.nz
 W: http://www.logix.cz/michal
 P: 1024D/C45B2218 1162 6471 D391 76E0 9F99  29DA 0C3A 2509 C45B 2218
 D: VIA PadLock driver
 D: Netfilter pkttype module
-S: Prague 4
-S: Czech Republic
+S: Asterisk Ltd.
+S: Auckland
+S: New Zealand
 
 N: Tuomas J. Lukka
 E: Tuomas.Lukka@Helsinki.FI
diff -purN linux-2.6.11-rc3-bk1/MAINTAINERS linux-2.6.11-rc3-bk2/MAINTAINERS
--- linux-2.6.11-rc3-bk1/MAINTAINERS	2005-02-05 16:59:08.138198431 +0100
+++ linux-2.6.11-rc3-bk2/MAINTAINERS	2005-02-05 16:59:13.522159039 +0100
@@ -749,7 +749,7 @@ S:	Maintained
 
 DRIVER CORE, KOBJECTS, AND SYSFS
 P:	Greg Kroah-Hartman
-M:	greg@kroah.com
+M:	gregkh@suse.de
 L:	linux-kernel@vger.kernel.org
 S:	Supported
 
@@ -1744,14 +1744,14 @@ S:	Maintained
 
 PCI SUBSYSTEM
 P:	Greg Kroah-Hartman
-M:	greg@kroah.com
+M:	gregkh@suse.de
 L:	linux-kernel@vger.kernel.org
 L:	linux-pci@atrey.karlin.mff.cuni.cz
 S:	Supported
 
 PCI HOTPLUG CORE
 P:	Greg Kroah-Hartman
-M:	greg@kroah.com
+M:	gregkh@suse.de
 S:	Supported
 
 PCI HOTPLUG COMPAQ DRIVER
@@ -2386,11 +2386,10 @@ S:	Maintained
 
 USB SERIAL DRIVER
 P:	Greg Kroah-Hartman
-M:	greg@kroah.com
+M:	gregkh@suse.de
 L:	linux-usb-users@lists.sourceforge.net
 L:	linux-usb-devel@lists.sourceforge.net
-S:	Maintained
-W:	http://www.kroah.com/linux-usb/
+S:	Supported
 
 USB SERIAL BELKIN F5U103 DRIVER
 P:	William Greathouse
@@ -2452,7 +2451,7 @@ S:	Maintained
 
 USB SUBSYSTEM
 P:	Greg Kroah-Hartman
-M:	greg@kroah.com
+M:	gregkh@suse.de
 L:	linux-usb-users@lists.sourceforge.net
 L:	linux-usb-devel@lists.sourceforge.net
 W:	http://www.linux-usb.org
diff -purN linux-2.6.11-rc3-bk1/Makefile linux-2.6.11-rc3-bk2/Makefile
--- linux-2.6.11-rc3-bk1/Makefile	2005-02-05 16:59:08.141197964 +0100
+++ linux-2.6.11-rc3-bk2/Makefile	2005-02-05 16:59:13.525158572 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc3-bk1
+EXTRAVERSION = -rc3-bk2
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -purN linux-2.6.11-rc3-bk1/arch/arm/kernel/calls.S linux-2.6.11-rc3-bk2/arch/arm/kernel/calls.S
--- linux-2.6.11-rc3-bk1/arch/arm/kernel/calls.S	2005-02-03 02:57:04.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/arm/kernel/calls.S	2005-02-05 16:59:13.526158416 +0100
@@ -134,7 +134,7 @@ __syscall_start:
 		.long	sys_ipc
 		.long	sys_fsync
 		.long	sys_sigreturn_wrapper
-/* 120 */	.long	sys_clone_wapper
+/* 120 */	.long	sys_clone_wrapper
 		.long	sys_setdomainname
 		.long	sys_newuname
 		.long	sys_ni_syscall
@@ -254,7 +254,7 @@ __syscall_start:
 		.long	sys_fremovexattr
 		.long	sys_tkill
 		.long	sys_sendfile64
-/* 240 */	.long	sys_futex
+/* 240 */	.long	sys_futex_wrapper
 		.long	sys_sched_setaffinity
 		.long	sys_sched_getaffinity
 		.long	sys_io_setup
diff -purN linux-2.6.11-rc3-bk1/arch/arm/kernel/entry-common.S linux-2.6.11-rc3-bk2/arch/arm/kernel/entry-common.S
--- linux-2.6.11-rc3-bk1/arch/arm/kernel/entry-common.S	2005-02-03 02:54:39.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/arm/kernel/entry-common.S	2005-02-05 16:59:13.527158261 +0100
@@ -11,6 +11,7 @@
 
 #include <asm/thread_info.h>
 #include <asm/ptrace.h>
+#include <asm/unistd.h>
 
 #include "entry-header.S"
 
@@ -190,13 +191,14 @@ ENTRY(sys_call_table)
 		.type	sys_syscall, #function
 sys_syscall:
 		eor	scno, r0, #OS_NUMBER << 20
-		cmp	scno, #NR_syscalls	@ check range
-		stmleia	sp, {r5, r6}		@ shuffle args
-		movle	r0, r1
-		movle	r1, r2
-		movle	r2, r3
-		movle	r3, r4
-		ldrle	pc, [tbl, scno, lsl #2]
+		cmp	scno, #__NR_syscall - __NR_SYSCALL_BASE
+		cmpne	scno, #NR_syscalls	@ check range
+		stmloia	sp, {r5, r6}		@ shuffle args
+		movlo	r0, r1
+		movlo	r1, r2
+		movlo	r2, r3
+		movlo	r3, r4
+		ldrlo	pc, [tbl, scno, lsl #2]
 		b	sys_ni_syscall
 
 sys_fork_wrapper:
@@ -211,7 +213,7 @@ sys_execve_wrapper:
 		add	r3, sp, #S_OFF
 		b	sys_execve
 
-sys_clone_wapper:
+sys_clone_wrapper:
 		add	ip, sp, #S_OFF
 		str	ip, [sp, #4]
 		b	sys_clone
@@ -236,6 +238,10 @@ sys_sigaltstack_wrapper:
 		ldr	r2, [sp, #S_OFF + S_SP]
 		b	do_sigaltstack
 
+sys_futex_wrapper:
+		str	r5, [sp, #4]		@ push sixth arg
+		b	sys_futex
+
 /*
  * Note: off_4k (r5) is always units of 4K.  If we can't do the requested
  * offset, we return EINVAL.
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/entry.S linux-2.6.11-rc3-bk2/arch/frv/kernel/entry.S
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/entry.S	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/entry.S	2005-02-05 16:59:13.530157794 +0100
@@ -782,13 +782,12 @@ __entry_do_NMI:
 ###############################################################################
 #
 # the return path for a newly forked child process
-# - __switch_to() saved the old current pointer in GR27 for us
+# - __switch_to() saved the old current pointer in GR8 for us
 #
 ###############################################################################
 	.globl		ret_from_fork
 ret_from_fork:
 	LEDS		0x6100
-	ori.p		gr27,0,gr8
 	call		schedule_tail
 
 	# fork & co. return 0 to child
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/irq-routing.c linux-2.6.11-rc3-bk2/arch/frv/kernel/irq-routing.c
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/irq-routing.c	2005-02-03 02:56:53.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/irq-routing.c	2005-02-05 16:59:13.531157638 +0100
@@ -82,7 +82,7 @@ void distribute_irqs(struct irq_group *g
 			int status = 0;
 
 //			if (!(action->flags & SA_INTERRUPT))
-//				sti();
+//				local_irq_enable();
 
 			do {
 				status |= action->flags;
@@ -92,7 +92,7 @@ void distribute_irqs(struct irq_group *g
 
 			if (status & SA_SAMPLE_RANDOM)
 				add_interrupt_randomness(irq);
-			cli();
+			local_irq_disable();
 		}
 	}
 }
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/irq.c linux-2.6.11-rc3-bk2/arch/frv/kernel/irq.c
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/irq.c	2005-02-03 02:56:48.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/irq.c	2005-02-05 16:59:13.532157482 +0100
@@ -316,16 +316,16 @@ asmlinkage void do_IRQ(void)
 			do_softirq();
 
 #ifdef CONFIG_PREEMPT
-	cli();
+	local_irq_disable();
 	while (--current->preempt_count == 0) {
-		if (!(__frame->psr & PSR_S)
-		    || (current->need_resched == 0)
-		    || in_interrupt())
+		if (!(__frame->psr & PSR_S) ||
+		    current->need_resched == 0 ||
+		    in_interrupt())
 			break;
 		current->preempt_count++;
-		sti();
+		local_irq_enable();
 		preempt_schedule();
-		cli();
+		local_irq_disable();
 	}
 #endif
 
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/pm.c linux-2.6.11-rc3-bk2/arch/frv/kernel/pm.c
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/pm.c	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/pm.c	2005-02-05 16:59:13.534157171 +0100
@@ -36,7 +36,7 @@ extern void frv_change_cmode(int);
 
 int pm_do_suspend(void)
 {
-	cli();
+	local_irq_disable();
 
 	__set_LEDS(0xb1);
 
@@ -45,7 +45,7 @@ int pm_do_suspend(void)
 
 	__set_LEDS(0xb2);
 
-	sti();
+	local_irq_enable();
 
 	return 0;
 }
@@ -84,7 +84,7 @@ void (*__power_switch_wake_cleanup)(void
 
 int pm_do_bus_sleep(void)
 {
-	cli();
+	local_irq_disable();
 
 	/*
          * Here is where we need some platform-dependent setup
@@ -113,7 +113,7 @@ int pm_do_bus_sleep(void)
 	 */
 	__power_switch_wake_cleanup();
 
-	sti();
+	local_irq_enable();
 
 	return 0;
 }
@@ -191,7 +191,7 @@ static int try_set_cmode(int new_cmode)
 	pm_send_all(PM_SUSPEND, (void *)3);
 
 	/* now change cmode */
-	cli();
+	local_irq_disable();
 	frv_dma_pause_all();
 
 	frv_change_cmode(new_cmode);
@@ -203,7 +203,7 @@ static int try_set_cmode(int new_cmode)
 	determine_clocks(1);
 #endif
 	frv_dma_resume_all();
-	sti();
+	local_irq_enable();
 
 	/* tell all the drivers we're resuming */
 	pm_send_all(PM_RESUME, (void *)0);
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/semaphore.c linux-2.6.11-rc3-bk2/arch/frv/kernel/semaphore.c
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/semaphore.c	2005-02-03 02:56:35.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/semaphore.c	2005-02-05 16:59:13.535157015 +0100
@@ -43,17 +43,18 @@ void __down(struct semaphore *sem, unsig
 	struct task_struct *tsk = current;
 	struct sem_waiter waiter;
 
-	semtrace(sem,"Entering __down");
+	semtrace(sem, "Entering __down");
 
 	/* set up my own style of waitqueue */
-	waiter.task	= tsk;
+	waiter.task = tsk;
+	get_task_struct(tsk);
 
 	list_add_tail(&waiter.list, &sem->wait_list);
 
 	/* we don't need to touch the semaphore struct anymore */
 	spin_unlock_irqrestore(&sem->wait_lock, flags);
 
-	/* wait to be given the lock */
+	/* wait to be given the semaphore */
 	set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 
 	for (;;) {
@@ -64,7 +65,7 @@ void __down(struct semaphore *sem, unsig
 	}
 
 	tsk->state = TASK_RUNNING;
-	semtrace(sem,"Leaving __down");
+	semtrace(sem, "Leaving __down");
 }
 
 EXPORT_SYMBOL(__down);
@@ -83,6 +84,7 @@ int __down_interruptible(struct semaphor
 
 	/* set up my own style of waitqueue */
 	waiter.task = tsk;
+	get_task_struct(tsk);
 
 	list_add_tail(&waiter.list, &sem->wait_list);
 
@@ -91,7 +93,7 @@ int __down_interruptible(struct semaphor
 
 	spin_unlock_irqrestore(&sem->wait_lock, flags);
 
-	/* wait to be given the lock */
+	/* wait to be given the semaphore */
 	ret = 0;
 	for (;;) {
 		if (list_empty(&waiter.list))
@@ -116,6 +118,8 @@ int __down_interruptible(struct semaphor
 	}
 
 	spin_unlock_irqrestore(&sem->wait_lock, flags);
+	if (ret == -EINTR)
+		put_task_struct(current);
 	goto out;
 }
 
@@ -127,14 +131,24 @@ EXPORT_SYMBOL(__down_interruptible);
  */
 void __up(struct semaphore *sem)
 {
+	struct task_struct *tsk;
 	struct sem_waiter *waiter;
 
 	semtrace(sem,"Entering __up");
 
 	/* grant the token to the process at the front of the queue */
 	waiter = list_entry(sem->wait_list.next, struct sem_waiter, list);
+
+	/* We must be careful not to touch 'waiter' after we set ->task = NULL.
+	 * It is an allocated on the waiter's stack and may become invalid at
+	 * any time after that point (due to a wakeup from another source).
+	 */
 	list_del_init(&waiter->list);
-	wake_up_process(waiter->task);
+	tsk = waiter->task;
+	mb();
+	waiter->task = NULL;
+	wake_up_process(tsk);
+	put_task_struct(tsk);
 
 	semtrace(sem,"Leaving __up");
 }
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/switch_to.S linux-2.6.11-rc3-bk2/arch/frv/kernel/switch_to.S
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/switch_to.S	2005-02-03 02:57:17.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/switch_to.S	2005-02-05 16:59:13.538156548 +0100
@@ -43,20 +43,22 @@ __kernel_current_task:
 
 ###############################################################################
 #
-# struct task_struct *__switch_to(struct thread_struct *prev, struct thread_struct *next)
+# struct task_struct *__switch_to(struct thread_struct *prev_thread,
+#				  struct thread_struct *next_thread,
+#				  struct task_struct *prev)
 #
 ###############################################################################
 	.globl		__switch_to
 __switch_to:
 	# save outgoing process's context
-	sethi.p		%hi(__switch_back),gr11
-	setlo		%lo(__switch_back),gr11
-	movsg		lr,gr10
+	sethi.p		%hi(__switch_back),gr13
+	setlo		%lo(__switch_back),gr13
+	movsg		lr,gr12
 
 	stdi		gr28,@(gr8,#__THREAD_FRAME)
 	sti		sp  ,@(gr8,#__THREAD_SP)
 	sti		fp  ,@(gr8,#__THREAD_FP)
-	stdi		gr10,@(gr8,#__THREAD_LR)
+	stdi		gr12,@(gr8,#__THREAD_LR)
 	stdi		gr16,@(gr8,#__THREAD_GR(16))
 	stdi		gr18,@(gr8,#__THREAD_GR(18))
 	stdi		gr20,@(gr8,#__THREAD_GR(20))
@@ -68,14 +70,14 @@ __switch_to:
 	ldi.p		@(gr8,#__THREAD_USER),gr8
 	call		save_user_regs
 	or		gr22,gr22,gr8
-
+	
 	# retrieve the new context
 	sethi.p		%hi(__kernel_frame0_ptr),gr6
 	setlo		%lo(__kernel_frame0_ptr),gr6
 	movsg		psr,gr4
 
 	lddi.p		@(gr9,#__THREAD_FRAME),gr10
-	or		gr29,gr29,gr27		; ret_from_fork needs to know old current
+	or		gr10,gr10,gr27		; save prev for the return value
 
 	ldi		@(gr11,#4),gr19		; get new_current->thread_info
 
@@ -88,8 +90,8 @@ __switch_to:
 	andi		gr4,#~PSR_ET,gr5
 	movgs		gr5,psr
 
-	or.p		gr10,gr0,gr28
-	or		gr11,gr0,gr29
+	or.p		gr10,gr0,gr28		; set __frame
+	or		gr11,gr0,gr29		; set __current
 	or.p		gr12,gr0,sp
 	or		gr13,gr0,fp
 	or		gr19,gr0,gr15		; set __current_thread_info
@@ -108,14 +110,17 @@ __switch_to:
 111:
 
 	# jump to __switch_back or ret_from_fork as appropriate
+	# - move prev to GR8
 	movgs		gr4,psr
-	jmpl		@(gr18,gr0)
+	jmpl.p		@(gr18,gr0)
+	or		gr27,gr27,gr8
 
 ###############################################################################
 #
 # restore incoming process's context
 # - on entry:
 #   - SP, FP, LR, GR15, GR28 and GR29 will have been set up appropriately
+#   - GR8 will point to the outgoing task_struct
 #   - GR9 will point to the incoming thread_struct
 #
 ###############################################################################
@@ -128,12 +133,16 @@ __switch_back:
 	lddi		@(gr9,#__THREAD_GR(26)),gr26
 
 	# fall through into restore_user_regs()
-	ldi		@(gr9,#__THREAD_USER),gr8
+	ldi.p		@(gr9,#__THREAD_USER),gr8
+	or		gr8,gr8,gr9
 
 ###############################################################################
 #
 # restore extra general regs and FP/Media regs
-# - void restore_user_regs(const struct user_context *target)
+# - void *restore_user_regs(const struct user_context *target, void *retval)
+# - on entry:
+#   - GR8 will point to the user context to swap in
+#   - GR9 will contain the value to be returned in GR8 (prev task on context switch)
 #
 ###############################################################################
 	.globl		restore_user_regs
@@ -245,6 +254,7 @@ __restore_skip_fr32_fr63:
 	lddi		@(gr8,#__FPMEDIA_FNER(0)),gr4
 	movsg		fner0,gr4
 	movsg		fner1,gr5
+	or.p		gr9,gr9,gr8
 	bralr
 
 	# the FR451 also has ACC8-11/ACCG8-11 regs (but not 4-7...)
diff -purN linux-2.6.11-rc3-bk1/arch/frv/kernel/vmlinux.lds.S linux-2.6.11-rc3-bk2/arch/frv/kernel/vmlinux.lds.S
--- linux-2.6.11-rc3-bk1/arch/frv/kernel/vmlinux.lds.S	2005-02-03 02:55:50.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/frv/kernel/vmlinux.lds.S	2005-02-05 16:59:13.539156393 +0100
@@ -1,4 +1,4 @@
-/* ld script to make FRV Linux kernel -*- c -*-
+/* ld script to make FRV Linux kernel
  * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
  */
 OUTPUT_FORMAT("elf32-frv", "elf32-frv", "elf32-frv")
diff -purN linux-2.6.11-rc3-bk1/arch/i386/kernel/time_hpet.c linux-2.6.11-rc3-bk2/arch/i386/kernel/time_hpet.c
--- linux-2.6.11-rc3-bk1/arch/i386/kernel/time_hpet.c	2005-02-03 02:55:15.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/i386/kernel/time_hpet.c	2005-02-05 16:59:13.540156237 +0100
@@ -81,6 +81,11 @@ static int hpet_timer_stop_set_go(unsign
 	cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC |
 	       HPET_TN_SETVAL | HPET_TN_32BIT;
 	hpet_writel(cfg, HPET_T0_CFG);
+	/*
+	 * Some systems seems to need two writes to HPET_T0_CMP,
+	 * to get interrupts working
+	 */
+	hpet_writel(tick, HPET_T0_CMP);
 	hpet_writel(tick, HPET_T0_CMP);
 
 	/*
diff -purN linux-2.6.11-rc3-bk1/arch/i386/lib/usercopy.c linux-2.6.11-rc3-bk2/arch/i386/lib/usercopy.c
--- linux-2.6.11-rc3-bk1/arch/i386/lib/usercopy.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/i386/lib/usercopy.c	2005-02-05 16:59:13.542155926 +0100
@@ -514,6 +514,7 @@ do {									\
 
 unsigned long __copy_to_user_ll(void __user *to, const void *from, unsigned long n)
 {
+	BUG_ON((long) n < 0);
 #ifndef CONFIG_X86_WP_WORKS_OK
 	if (unlikely(boot_cpu_data.wp_works_ok == 0) &&
 			((unsigned long )to) < TASK_SIZE) {
@@ -573,6 +574,7 @@ survive:
 unsigned long
 __copy_from_user_ll(void *to, const void __user *from, unsigned long n)
 {
+	BUG_ON((long)n < 0);
 	if (movsl_is_ok(to, from, n))
 		__copy_user_zeroing(to, from, n);
 	else
@@ -597,6 +599,7 @@ unsigned long
 copy_to_user(void __user *to, const void *from, unsigned long n)
 {
 	might_sleep();
+	BUG_ON((long) n < 0);
 	if (access_ok(VERIFY_WRITE, to, n))
 		n = __copy_to_user(to, from, n);
 	return n;
@@ -623,6 +626,7 @@ unsigned long
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
 	might_sleep();
+	BUG_ON((long) n < 0);
 	if (access_ok(VERIFY_READ, from, n))
 		n = __copy_from_user(to, from, n);
 	else
diff -purN linux-2.6.11-rc3-bk1/arch/ppc/lib/locks.c linux-2.6.11-rc3-bk2/arch/ppc/lib/locks.c
--- linux-2.6.11-rc3-bk1/arch/ppc/lib/locks.c	2005-02-03 02:55:22.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/ppc/lib/locks.c	2005-02-05 16:59:13.706130397 +0100
@@ -91,44 +91,57 @@ void _raw_spin_unlock(spinlock_t *lp)
 }
 EXPORT_SYMBOL(_raw_spin_unlock);
 
-
 /*
- * Just like x86, implement read-write locks as a 32-bit counter
- * with the high bit (sign) being the "write" bit.
- * -- Cort
+ * For rwlocks, zero is unlocked, -1 is write-locked,
+ * positive is read-locked.
  */
+static __inline__ int __read_trylock(rwlock_t *rw)
+{
+	signed int tmp;
+
+	__asm__ __volatile__(
+"2:	lwarx	%0,0,%1		# __read_trylock\n\
+	addic.	%0,%0,1\n\
+	ble-	1f\n"
+	PPC405_ERR77(0,%1)
+"	stwcx.	%0,0,%1\n\
+	bne-	2b\n\
+	isync\n\
+1:"
+	: "=&r"(tmp)
+	: "r"(&rw->lock)
+	: "cr0", "memory");
+
+	return tmp;
+}
+
+int _raw_read_trylock(rwlock_t *rw)
+{
+	return __read_trylock(rw) > 0;
+}
+EXPORT_SYMBOL(_raw_read_trylock);
+
 void _raw_read_lock(rwlock_t *rw)
 {
-	unsigned long stuck = INIT_STUCK;
-	int cpu = smp_processor_id();
+	unsigned int stuck;
 
-again:
-	/* get our read lock in there */
-	atomic_inc((atomic_t *) &(rw)->lock);
-	if ( (signed long)((rw)->lock) < 0) /* someone has a write lock */
-	{
-		/* turn off our read lock */
-		atomic_dec((atomic_t *) &(rw)->lock);
-		/* wait for the write lock to go away */
-		while ((signed long)((rw)->lock) < 0)
-		{
-			if(!--stuck)
-			{
-				printk("_read_lock(%p) CPU#%d\n", rw, cpu);
+	while (__read_trylock(rw) <= 0) {
+		stuck = INIT_STUCK;
+		while (!read_can_lock(rw)) {
+			if (--stuck == 0) {
+				printk("_read_lock(%p) CPU#%d lock %d\n",
+				       rw, _smp_processor_id(), rw->lock);
 				stuck = INIT_STUCK;
 			}
 		}
-		/* try to get the read lock again */
-		goto again;
 	}
-	wmb();
 }
 EXPORT_SYMBOL(_raw_read_lock);
 
 void _raw_read_unlock(rwlock_t *rw)
 {
 	if ( rw->lock == 0 )
-		printk("_read_unlock(): %s/%d (nip %08lX) lock %lx\n",
+		printk("_read_unlock(): %s/%d (nip %08lX) lock %d\n",
 		       current->comm,current->pid,current->thread.regs->nip,
 		      rw->lock);
 	wmb();
@@ -138,40 +151,17 @@ EXPORT_SYMBOL(_raw_read_unlock);
 
 void _raw_write_lock(rwlock_t *rw)
 {
-	unsigned long stuck = INIT_STUCK;
-	int cpu = smp_processor_id();
+	unsigned int stuck;
 
-again:
-	if ( test_and_set_bit(31,&(rw)->lock) ) /* someone has a write lock */
-	{
-		while ( (rw)->lock & (1<<31) ) /* wait for write lock */
-		{
-			if(!--stuck)
-			{
-				printk("write_lock(%p) CPU#%d lock %lx)\n",
-				       rw, cpu,rw->lock);
+	while (cmpxchg(&rw->lock, 0, -1) != 0) {
+		stuck = INIT_STUCK;
+		while (!write_can_lock(rw)) {
+			if (--stuck == 0) {
+				printk("write_lock(%p) CPU#%d lock %d)\n",
+				       rw, _smp_processor_id(), rw->lock);
 				stuck = INIT_STUCK;
 			}
-			barrier();
 		}
-		goto again;
-	}
-
-	if ( (rw)->lock & ~(1<<31)) /* someone has a read lock */
-	{
-		/* clear our write lock and wait for reads to go away */
-		clear_bit(31,&(rw)->lock);
-		while ( (rw)->lock & ~(1<<31) )
-		{
-			if(!--stuck)
-			{
-				printk("write_lock(%p) 2 CPU#%d lock %lx)\n",
-				       rw, cpu,rw->lock);
-				stuck = INIT_STUCK;
-			}
-			barrier();
-		}
-		goto again;
 	}
 	wmb();
 }
@@ -179,14 +169,8 @@ EXPORT_SYMBOL(_raw_write_lock);
 
 int _raw_write_trylock(rwlock_t *rw)
 {
-	if (test_and_set_bit(31, &(rw)->lock)) /* someone has a write lock */
-		return 0;
-
-	if ((rw)->lock & ~(1<<31)) {	/* someone has a read lock */
-		/* clear our write lock and wait for reads to go away */
-		clear_bit(31,&(rw)->lock);
+	if (cmpxchg(&rw->lock, 0, -1) != 0)
 		return 0;
-	}
 	wmb();
 	return 1;
 }
@@ -194,12 +178,12 @@ EXPORT_SYMBOL(_raw_write_trylock);
 
 void _raw_write_unlock(rwlock_t *rw)
 {
-	if ( !(rw->lock & (1<<31)) )
-		printk("_write_lock(): %s/%d (nip %08lX) lock %lx\n",
+	if (rw->lock >= 0)
+		printk("_write_lock(): %s/%d (nip %08lX) lock %d\n",
 		      current->comm,current->pid,current->thread.regs->nip,
 		      rw->lock);
 	wmb();
-	clear_bit(31,&(rw)->lock);
+	rw->lock = 0;
 }
 EXPORT_SYMBOL(_raw_write_unlock);
 
diff -purN linux-2.6.11-rc3-bk1/arch/ppc64/kernel/entry.S linux-2.6.11-rc3-bk2/arch/ppc64/kernel/entry.S
--- linux-2.6.11-rc3-bk1/arch/ppc64/kernel/entry.S	2005-02-03 02:54:39.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/ppc64/kernel/entry.S	2005-02-05 16:59:13.740125104 +0100
@@ -231,6 +231,7 @@ syscall_dotrace:
 syscall_exit_trace:
 	std	r3,GPR3(r1)
 	bl	.save_nvgprs
+	addi	r3,r1,STACK_FRAME_OVERHEAD
 	bl	.do_syscall_trace_leave
 	REST_NVGPRS(r1)
 	ld	r3,GPR3(r1)
@@ -324,6 +325,7 @@ _GLOBAL(ppc64_rt_sigreturn)
 	ld	r4,TI_FLAGS(r4)
 	andi.	r4,r4,(_TIF_SYSCALL_T_OR_A|_TIF_SINGLESTEP)
 	beq+	81f
+	addi	r3,r1,STACK_FRAME_OVERHEAD
 	bl	.do_syscall_trace_leave
 81:	b	.ret_from_except
 
diff -purN linux-2.6.11-rc3-bk1/arch/ppc64/kernel/ptrace.c linux-2.6.11-rc3-bk2/arch/ppc64/kernel/ptrace.c
--- linux-2.6.11-rc3-bk1/arch/ppc64/kernel/ptrace.c	2005-02-03 02:56:34.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/ppc64/kernel/ptrace.c	2005-02-05 16:59:13.741124948 +0100
@@ -313,10 +313,10 @@ void do_syscall_trace_enter(struct pt_re
 		do_syscall_trace();
 }
 
-void do_syscall_trace_leave(void)
+void do_syscall_trace_leave(struct pt_regs *regs)
 {
 	if (unlikely(current->audit_context))
-		audit_syscall_exit(current, 0);	/* FIXME: pass pt_regs */
+		audit_syscall_exit(current, regs->result);
 
 	if ((test_thread_flag(TIF_SYSCALL_TRACE)
 	     || test_thread_flag(TIF_SINGLESTEP))
diff -purN linux-2.6.11-rc3-bk1/arch/ppc64/kernel/sysfs.c linux-2.6.11-rc3-bk2/arch/ppc64/kernel/sysfs.c
--- linux-2.6.11-rc3-bk1/arch/ppc64/kernel/sysfs.c	2005-02-03 02:55:14.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/ppc64/kernel/sysfs.c	2005-02-05 16:59:13.743258000 +0100
@@ -387,7 +387,7 @@ static ssize_t show_physical_id(struct s
 {
 	struct cpu *cpu = container_of(dev, struct cpu, sysdev);
 
-	return sprintf(buf, "%u\n", get_hard_smp_processor_id(cpu->sysdev.id));
+	return sprintf(buf, "%d\n", get_hard_smp_processor_id(cpu->sysdev.id));
 }
 static SYSDEV_ATTR(physical_id, 0444, show_physical_id, NULL);
 
diff -purN linux-2.6.11-rc3-bk1/arch/um/Kconfig linux-2.6.11-rc3-bk2/arch/um/Kconfig
--- linux-2.6.11-rc3-bk1/arch/um/Kconfig	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/Kconfig	2005-02-05 16:59:13.771253642 +0100
@@ -313,11 +313,9 @@ if BROKEN
 	source "drivers/mtd/Kconfig"
 endif
 
+#This is just to shut up some Kconfig warnings, so no prompt.
 config INPUT
-	bool "Dummy option"
-	depends BROKEN
+	bool
 	default n
-	help
-	This is a dummy option to get rid of warnings.
 
 source "arch/um/Kconfig.debug"
diff -purN linux-2.6.11-rc3-bk1/arch/um/Kconfig_arch linux-2.6.11-rc3-bk2/arch/um/Kconfig_arch
--- linux-2.6.11-rc3-bk1/arch/um/Kconfig_arch	2005-02-03 02:57:17.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/Kconfig_arch	1970-01-01 01:00:00.000000000 +0100
@@ -1,16 +0,0 @@
-config 64_BIT
-	bool
-	default n
-
-config TOP_ADDR
- 	hex
- 	default 0xc0000000 if !HOST_2G_2G
- 	default 0x80000000 if HOST_2G_2G
-
-config 3_LEVEL_PGTABLES
-	bool "Three-level pagetables"
-	default n
-	help
-	Three-level pagetables will let UML have more than 4G of physical
-	memory.  All the memory that can't be mapped directly will be treated
-	as high memory.
diff -purN linux-2.6.11-rc3-bk1/arch/um/Kconfig_i386 linux-2.6.11-rc3-bk2/arch/um/Kconfig_i386
--- linux-2.6.11-rc3-bk1/arch/um/Kconfig_i386	2005-02-03 02:55:52.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/Kconfig_i386	2005-02-05 16:59:13.775253019 +0100
@@ -18,3 +18,7 @@ config 3_LEVEL_PGTABLES
 config ARCH_HAS_SC_SIGNALS
 	bool
 	default y
+
+config ARCH_REUSE_HOST_VSYSCALL_AREA
+	bool
+	default y
diff -purN linux-2.6.11-rc3-bk1/arch/um/Kconfig_x86_64 linux-2.6.11-rc3-bk2/arch/um/Kconfig_x86_64
--- linux-2.6.11-rc3-bk1/arch/um/Kconfig_x86_64	2005-02-03 02:55:36.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/Kconfig_x86_64	2005-02-05 16:59:13.776252863 +0100
@@ -9,3 +9,7 @@ config 3_LEVEL_PGTABLES
 config ARCH_HAS_SC_SIGNALS
 	bool
 	default n
+
+config ARCH_REUSE_HOST_VSYSCALL_AREA
+	bool
+	default n
diff -purN linux-2.6.11-rc3-bk1/arch/um/Makefile linux-2.6.11-rc3-bk2/arch/um/Makefile
--- linux-2.6.11-rc3-bk1/arch/um/Makefile	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/Makefile	2005-02-05 16:59:13.777252708 +0100
@@ -20,8 +20,11 @@ SYMLINK_HEADERS := archparam.h system.h 
 	arch-signal.h module.h vm-flags.h
 SYMLINK_HEADERS := $(foreach header,$(SYMLINK_HEADERS),include/asm-um/$(header))
 
-# The "os" symlink is only used by arch/um/include/os.h, which includes
+# XXX: The "os" symlink is only used by arch/um/include/os.h, which includes
 # ../os/include/file.h
+#
+# These are cleaned up during mrproper. Please DO NOT fix it again, this is
+# the Correct Thing(tm) to do!
 ARCH_SYMLINKS = include/asm-um/arch $(ARCH_DIR)/include/sysdep $(ARCH_DIR)/os \
 	$(SYMLINK_HEADERS) $(ARCH_DIR)/include/uml-config.h
 
@@ -58,7 +61,7 @@ CFLAGS += $(CFLAGS-y) -D__arch_um__ -DSU
 
 USER_CFLAGS := $(patsubst -I%,,$(CFLAGS))
 USER_CFLAGS := $(patsubst -D__KERNEL__,,$(USER_CFLAGS)) $(ARCH_INCLUDE) \
-	$(MODE_INCLUDE)
+	$(MODE_INCLUDE) $(ARCH_USER_CFLAGS)
 CFLAGS += -Derrno=kernel_errno -Dsigprocmask=kernel_sigprocmask
 CFLAGS += $(call cc-option,-fno-unit-at-a-time,)
 
@@ -134,7 +137,8 @@ CLEAN_FILES += linux x.i gmon.out $(ARCH
 	$(GEN_HEADERS) $(ARCH_DIR)/include/skas_ptregs.h
 
 MRPROPER_FILES += $(SYMLINK_HEADERS) $(ARCH_SYMLINKS) \
-	$(addprefix $(ARCH_DIR)/kernel/,$(KERN_SYMLINKS)) $(ARCH_DIR)/os
+	$(addprefix $(ARCH_DIR)/kernel/,$(KERN_SYMLINKS)) $(ARCH_DIR)/os \
+	$(ARCH_DIR)/Kconfig_arch
 
 archclean:
 	$(Q)$(MAKE) $(clean)=$(ARCH_DIR)/util
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/mem.c linux-2.6.11-rc3-bk2/arch/um/kernel/mem.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/mem.c	2005-02-03 02:55:40.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/mem.c	2005-02-05 16:59:13.779252396 +0100
@@ -79,7 +79,7 @@ void mem_init(void)
 	uml_reserved = brk_end;
 
 	/* Fill in any hole at the start of the binary */
-	start = (unsigned long) &__binary_start;
+	start = (unsigned long) &__binary_start & PAGE_MASK;
 	if(uml_physmem != start){
 		map_memory(uml_physmem, __pa(uml_physmem), start - uml_physmem,
 			   1, 1, 0);
@@ -152,6 +152,7 @@ void __init kmap_init(void)
 static void init_highmem(void)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	unsigned long vaddr;
@@ -163,7 +164,8 @@ static void init_highmem(void)
 	fixrange_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, swapper_pg_dir);
 
 	pgd = swapper_pg_dir + pgd_index(vaddr);
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
 	pte = pte_offset_kernel(pmd, vaddr);
 	pkmap_page_table = pte;
 
@@ -173,9 +175,10 @@ static void init_highmem(void)
 
 static void __init fixaddr_user_init( void)
 {
-#if FIXADDR_USER_START != 0
+#if CONFIG_ARCH_REUSE_HOST_VSYSCALL_AREA
 	long size = FIXADDR_USER_END - FIXADDR_USER_START;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	unsigned long paddr, vaddr = FIXADDR_USER_START;
@@ -187,9 +190,10 @@ static void __init fixaddr_user_init( vo
 	paddr = (unsigned long)alloc_bootmem_low_pages( size);
 	memcpy( (void *)paddr, (void *)FIXADDR_USER_START, size);
 	paddr = __pa(paddr);
-	for ( ; size > 0; size-=PAGE_SIZE, vaddr+=PAGE_SIZE, paddr+=PAGE_SIZE) {
+	for ( ; size > 0; size-=PAGE_SIZE, vaddr+=PAGE_SIZE, paddr+=PAGE_SIZE){
 		pgd = swapper_pg_dir + pgd_index(vaddr);
-		pmd = pmd_offset(pgd, vaddr);
+		pud = pud_offset(pgd, vaddr);
+		pmd = pmd_offset(pud, vaddr);
 		pte = pte_offset_kernel(pmd, vaddr);
 		pte_set_val( (*pte), paddr, PAGE_READONLY);
 	}
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/process.c linux-2.6.11-rc3-bk2/arch/um/kernel/process.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/process.c	2005-02-03 02:56:35.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/process.c	2005-02-05 16:59:13.780252241 +0100
@@ -13,6 +13,10 @@
 #include <setjmp.h>
 #include <sys/time.h>
 #include <sys/ptrace.h>
+
+/*Userspace header, must be after sys/ptrace.h, and both must be included. */
+#include <linux/ptrace.h>
+
 #include <sys/wait.h>
 #include <sys/mman.h>
 #include <asm/unistd.h>
@@ -422,14 +426,3 @@ int can_do_skas(void)
 	return(0);
 }
 #endif
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/skas/trap_user.c linux-2.6.11-rc3-bk2/arch/um/kernel/skas/trap_user.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/skas/trap_user.c	2005-02-03 02:55:50.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/skas/trap_user.c	2005-02-05 16:59:13.781252085 +0100
@@ -20,6 +20,14 @@ void sig_handler_common_skas(int sig, vo
 	int save_errno = errno;
 	int save_user;
 
+	/* This is done because to allow SIGSEGV to be delivered inside a SEGV
+	 * handler.  This can happen in copy_user, and if SEGV is disabled,
+	 * the process will die.
+	 * XXX Figure out why this is better than SA_NODEFER
+	 */
+	if(sig == SIGSEGV)
+		change_sig(SIGSEGV, 1);
+
 	r = &TASK_REGS(get_current())->skas;
 	save_user = r->is_user;
 	r->is_user = 0;
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/sys_call_table.c linux-2.6.11-rc3-bk2/arch/um/kernel/sys_call_table.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/sys_call_table.c	2005-02-03 02:56:34.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/sys_call_table.c	2005-02-05 16:59:13.783251774 +0100
@@ -20,7 +20,7 @@
 #define NFSSERVCTL sys_ni_syscall
 #endif
 
-#define LAST_GENERIC_SYSCALL __NR_vperfctr_read
+#define LAST_GENERIC_SYSCALL __NR_keyctl
 
 #if LAST_GENERIC_SYSCALL > LAST_ARCH_SYSCALL
 #define LAST_SYSCALL LAST_GENERIC_SYSCALL
@@ -52,13 +52,7 @@ extern syscall_handler_t sys_vserver;
 extern syscall_handler_t sys_mbind;
 extern syscall_handler_t sys_get_mempolicy;
 extern syscall_handler_t sys_set_mempolicy;
-extern syscall_handler_t sys_sys_kexec_load;
 extern syscall_handler_t sys_sys_setaltroot;
-extern syscall_handler_t sys_vperfctr_open;
-extern syscall_handler_t sys_vperfctr_control;
-extern syscall_handler_t sys_vperfctr_unlink;
-extern syscall_handler_t sys_vperfctr_iresume;
-extern syscall_handler_t sys_vperfctr_read;
 
 syscall_handler_t *sys_call_table[] = {
 	[ __NR_restart_syscall ] = (syscall_handler_t *) sys_restart_syscall,
@@ -273,32 +267,14 @@ syscall_handler_t *sys_call_table[] = {
 	[ __NR_mq_timedreceive ] = (syscall_handler_t *) sys_mq_timedreceive,
 	[ __NR_mq_notify ] = (syscall_handler_t *) sys_mq_notify,
 	[ __NR_mq_getsetattr ] = (syscall_handler_t *) sys_mq_getsetattr,
-	[ __NR_sys_kexec_load ] = (syscall_handler_t *) sys_kexec_load,
+	[ __NR_sys_kexec_load ] = (syscall_handler_t *) sys_ni_syscall,
 	[ __NR_waitid ] = (syscall_handler_t *) sys_waitid,
-#if 0
-	[ __NR_sys_setaltroot ] = (syscall_handler_t *) sys_sys_setaltroot,
-#endif
+	[ 285 ] = (syscall_handler_t *) sys_ni_syscall,
 	[ __NR_add_key ] = (syscall_handler_t *) sys_add_key,
 	[ __NR_request_key ] = (syscall_handler_t *) sys_request_key,
 	[ __NR_keyctl ] = (syscall_handler_t *) sys_keyctl,
-	[ __NR_vperfctr_open ] = (syscall_handler_t *) sys_vperfctr_open,
-	[ __NR_vperfctr_control ] = (syscall_handler_t *) sys_vperfctr_control,
-	[ __NR_vperfctr_unlink ] = (syscall_handler_t *) sys_vperfctr_unlink,
-	[ __NR_vperfctr_iresume ] = (syscall_handler_t *) sys_vperfctr_iresume,
-	[ __NR_vperfctr_read ] = (syscall_handler_t *) sys_vperfctr_read,
 
 	ARCH_SYSCALLS
 	[ LAST_SYSCALL + 1 ... NR_syscalls ] = 
 	        (syscall_handler_t *) sys_ni_syscall
 };
-
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * Emacs will notice this stuff at the end of the file and automatically
- * adjust the settings for this buffer only.  This must remain at the end
- * of the file.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-file-style: "linux"
- * End:
- */
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/time_kern.c linux-2.6.11-rc3-bk2/arch/um/kernel/time_kern.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/time_kern.c	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/time_kern.c	2005-02-05 16:59:13.784251618 +0100
@@ -22,7 +22,7 @@
 #include "mode.h"
 #include "os.h"
 
-u64 jiffies_64;
+u64 jiffies_64 = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
 
diff -purN linux-2.6.11-rc3-bk1/arch/um/kernel/trap_kern.c linux-2.6.11-rc3-bk2/arch/um/kernel/trap_kern.c
--- linux-2.6.11-rc3-bk1/arch/um/kernel/trap_kern.c	2005-02-03 02:55:06.000000000 +0100
+++ linux-2.6.11-rc3-bk2/arch/um/kernel/trap_kern.c	2005-02-05 16:59:13.785251462 +0100
@@ -48,6 +48,8 @@ int handle_page_fault(unsigned long addr
 		goto good_area;
 	else if(!(vma->vm_flags & VM_GROWSDOWN)) 
 		goto out;
+	else if(!ARCH_IS_STACKGROW(address))
+		goto out;
 	else if(expand_stack(vma, address)) 
 		goto out;
 
diff -purN linux-2.6.11-rc3-bk1/drivers/char/hvcs.c linux-2.6.11-rc3-bk2/drivers/char/hvcs.c
--- linux-2.6.11-rc3-bk1/drivers/char/hvcs.c	2005-02-03 02:57:16.000000000 +0100
+++ linux-2.6.11-rc3-bk2/drivers/char/hvcs.c	2005-02-05 16:59:13.788250995 +0100
@@ -1363,6 +1363,7 @@ static int __init hvcs_module_init(void)
 
 	hvcs_tty_driver->driver_name = hvcs_driver_name;
 	hvcs_tty_driver->name = hvcs_device_node;
+	hvcs_tty_driver->devfs_name = hvcs_device_node;
 
 	/*
 	 * We'll let the system assign us a major number, indicated by leaving
diff -purN linux-2.6.11-rc3-bk1/drivers/char/mxser.c linux-2.6.11-rc3-bk2/drivers/char/mxser.c
--- linux-2.6.11-rc3-bk1/drivers/char/mxser.c	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk2/drivers/char/mxser.c	2005-02-05 16:59:13.806248193 +0100
@@ -556,7 +556,7 @@ static int mxser_initbrd(int board, stru
 	info = &mxvar_table[n];
 	/*if (verbose) */  {
 		printk(KERN_DEBUG "        ttyM%d - ttyM%d ", n, n + hwconf->ports - 1);
-		printk(KERN_DEBUG " max. baud rate = %d bps.\n", hwconf->MaxCanSetBaudRate[0]);
+		printk(" max. baud rate = %d bps.\n", hwconf->MaxCanSetBaudRate[0]);
 	}
 
 	for (i = 0; i < hwconf->ports; i++, n++, info++) {
@@ -609,18 +609,12 @@ static int mxser_initbrd(int board, stru
 	n = board * MXSER_PORTS_PER_BOARD;
 	info = &mxvar_table[n];
 
-	spin_lock_irqsave(&info->slock, flags);
 	retval = request_irq(hwconf->irq, mxser_interrupt, IRQ_T(info), "mxser", info);
 	if (retval) {
-		spin_unlock_irqrestore(&info->slock, flags);
 		printk(KERN_ERR "Board %d: %s", board, mxser_brdname[hwconf->board_type - 1]);
 		printk("  Request irq fail,IRQ (%d) may be conflit with another device.\n", info->irq);
 		return retval;
 	}
-
-	spin_unlock_irqrestore(&info->slock, flags);
-
-
 	return 0;
 }
 
@@ -2144,10 +2138,9 @@ intr_old:
 	mxvar_log.rxcnt[info->port] += cnt;
 	info->mon_data.rxcnt += cnt;
 	info->mon_data.up_rxcnt += cnt;
-
-	tty->ldisc.receive_buf(tty, tty->flip.char_buf, tty->flip.flag_buf, count);
 	spin_unlock_irqrestore(&info->slock, flags);
-
+	
+	tty_flip_buffer_push(tty);
 }
 
 static void mxser_transmit_chars(struct mxser_struct *info)
diff -purN linux-2.6.11-rc3-bk1/drivers/media/video/tda9887.c linux-2.6.11-rc3-bk2/drivers/media/video/tda9887.c
--- linux-2.6.11-rc3-bk1/drivers/media/video/tda9887.c	2005-02-05 16:59:08.467147218 +0100
+++ linux-2.6.11-rc3-bk2/drivers/media/video/tda9887.c	2005-02-05 16:59:13.909232160 +0100
@@ -554,10 +554,15 @@ static int tda9887_configure(struct tda9
 	tda9887_set_config(t,buf);
 	tda9887_set_insmod(t,buf);
 
+#if 0
+	/* This as-is breaks some cards, must be fixed in a
+	 * card-specific way, probably using TDA9887_SET_CONFIG to
+	  * turn on/off port2 */
 	if (t->std & V4L2_STD_SECAM_L) {
 		/* secam fixup (FIXME: move this to tvnorms array?) */
 		buf[1] &= ~cOutputPort2Inactive;
 	}
+#endif
 
 	dprintk(PREFIX "writing: b=0x%02x c=0x%02x e=0x%02x\n",
 		buf[1],buf[2],buf[3]);
diff -purN linux-2.6.11-rc3-bk1/drivers/net/ibmveth.c linux-2.6.11-rc3-bk2/drivers/net/ibmveth.c
--- linux-2.6.11-rc3-bk1/drivers/net/ibmveth.c	2005-02-03 02:54:38.000000000 +0100
+++ linux-2.6.11-rc3-bk2/drivers/net/ibmveth.c	2005-02-05 16:59:13.922230136 +0100
@@ -218,7 +218,8 @@ static void ibmveth_replenish_buffer_poo
 		ibmveth_assert(index != IBM_VETH_INVALID_MAP);
 		ibmveth_assert(pool->skbuff[index] == NULL);
 
-		dma_addr = vio_map_single(adapter->vdev, skb->data, pool->buff_size, DMA_FROM_DEVICE);
+		dma_addr = dma_map_single(&adapter->vdev->dev, skb->data,
+				pool->buff_size, DMA_FROM_DEVICE);
 
 		pool->free_map[free_index] = IBM_VETH_INVALID_MAP;
 		pool->dma_addr[index] = dma_addr;
@@ -238,7 +239,9 @@ static void ibmveth_replenish_buffer_poo
 			pool->free_map[free_index] = IBM_VETH_INVALID_MAP;
 			pool->skbuff[index] = NULL;
 			pool->consumer_index--;
-			vio_unmap_single(adapter->vdev, pool->dma_addr[index], pool->buff_size, DMA_FROM_DEVICE);
+			dma_unmap_single(&adapter->vdev->dev,
+					pool->dma_addr[index], pool->buff_size,
+					DMA_FROM_DEVICE);
 			dev_kfree_skb_any(skb);
 			adapter->replenish_add_buff_failure++;
 			break;
@@ -260,6 +263,15 @@ static inline int ibmveth_is_replenishin
 		(atomic_read(&adapter->rx_buff_pool[2].available) < adapter->rx_buff_pool[2].threshold));
 }
 
+/* kick the replenish tasklet if we need replenishing and it isn't already running */
+static inline void ibmveth_schedule_replenishing(struct ibmveth_adapter *adapter)
+{
+	if(ibmveth_is_replenishing_needed(adapter) &&
+	   (atomic_dec_if_positive(&adapter->not_replenishing) == 0)) {
+		schedule_work(&adapter->replenish_task);
+	}
+}
+
 /* replenish tasklet routine */
 static void ibmveth_replenish_task(struct ibmveth_adapter *adapter) 
 {
@@ -276,15 +288,6 @@ static void ibmveth_replenish_task(struc
 	ibmveth_schedule_replenishing(adapter);
 }
 
-/* kick the replenish tasklet if we need replenishing and it isn't already running */
-static inline void ibmveth_schedule_replenishing(struct ibmveth_adapter *adapter)
-{
-	if(ibmveth_is_replenishing_needed(adapter) && 
-	   (atomic_dec_if_positive(&adapter->not_replenishing) == 0)) {	
-		schedule_work(&adapter->replenish_task);
-	}
-}
-
 /* empty and free ana buffer pool - also used to do cleanup in error paths */
 static void ibmveth_free_buffer_pool(struct ibmveth_adapter *adapter, struct ibmveth_buff_pool *pool)
 {
@@ -299,7 +302,7 @@ static void ibmveth_free_buffer_pool(str
 		for(i = 0; i < pool->size; ++i) {
 			struct sk_buff *skb = pool->skbuff[i];
 			if(skb) {
-				vio_unmap_single(adapter->vdev,
+				dma_unmap_single(&adapter->vdev->dev,
 						 pool->dma_addr[i],
 						 pool->buff_size,
 						 DMA_FROM_DEVICE);
@@ -337,7 +340,7 @@ static void ibmveth_remove_buffer_from_p
 
 	adapter->rx_buff_pool[pool].skbuff[index] = NULL;
 
-	vio_unmap_single(adapter->vdev,
+	dma_unmap_single(&adapter->vdev->dev,
 			 adapter->rx_buff_pool[pool].dma_addr[index],
 			 adapter->rx_buff_pool[pool].buff_size,
 			 DMA_FROM_DEVICE);
@@ -408,7 +411,9 @@ static void ibmveth_cleanup(struct ibmve
 {
 	if(adapter->buffer_list_addr != NULL) {
 		if(!dma_mapping_error(adapter->buffer_list_dma)) {
-			vio_unmap_single(adapter->vdev, adapter->buffer_list_dma, 4096, DMA_BIDIRECTIONAL);
+			dma_unmap_single(&adapter->vdev->dev,
+					adapter->buffer_list_dma, 4096,
+					DMA_BIDIRECTIONAL);
 			adapter->buffer_list_dma = DMA_ERROR_CODE;
 		}
 		free_page((unsigned long)adapter->buffer_list_addr);
@@ -417,7 +422,9 @@ static void ibmveth_cleanup(struct ibmve
 
 	if(adapter->filter_list_addr != NULL) {
 		if(!dma_mapping_error(adapter->filter_list_dma)) {
-			vio_unmap_single(adapter->vdev, adapter->filter_list_dma, 4096, DMA_BIDIRECTIONAL);
+			dma_unmap_single(&adapter->vdev->dev,
+					adapter->filter_list_dma, 4096,
+					DMA_BIDIRECTIONAL);
 			adapter->filter_list_dma = DMA_ERROR_CODE;
 		}
 		free_page((unsigned long)adapter->filter_list_addr);
@@ -426,7 +433,10 @@ static void ibmveth_cleanup(struct ibmve
 
 	if(adapter->rx_queue.queue_addr != NULL) {
 		if(!dma_mapping_error(adapter->rx_queue.queue_dma)) {
-			vio_unmap_single(adapter->vdev, adapter->rx_queue.queue_dma, adapter->rx_queue.queue_len, DMA_BIDIRECTIONAL);
+			dma_unmap_single(&adapter->vdev->dev,
+					adapter->rx_queue.queue_dma,
+					adapter->rx_queue.queue_len,
+					DMA_BIDIRECTIONAL);
 			adapter->rx_queue.queue_dma = DMA_ERROR_CODE;
 		}
 		kfree(adapter->rx_queue.queue_addr);
@@ -472,9 +482,13 @@ static int ibmveth_open(struct net_devic
 		return -ENOMEM;
 	}
 
-	adapter->buffer_list_dma = vio_map_single(adapter->vdev, adapter->buffer_list_addr, 4096, DMA_BIDIRECTIONAL);
-	adapter->filter_list_dma = vio_map_single(adapter->vdev, adapter->filter_list_addr, 4096, DMA_BIDIRECTIONAL);
-	adapter->rx_queue.queue_dma = vio_map_single(adapter->vdev, adapter->rx_queue.queue_addr, adapter->rx_queue.queue_len, DMA_BIDIRECTIONAL);
+	adapter->buffer_list_dma = dma_map_single(&adapter->vdev->dev,
+			adapter->buffer_list_addr, 4096, DMA_BIDIRECTIONAL);
+	adapter->filter_list_dma = dma_map_single(&adapter->vdev->dev,
+			adapter->filter_list_addr, 4096, DMA_BIDIRECTIONAL);
+	adapter->rx_queue.queue_dma = dma_map_single(&adapter->vdev->dev,
+			adapter->rx_queue.queue_addr,
+			adapter->rx_queue.queue_len, DMA_BIDIRECTIONAL);
 
 	if((dma_mapping_error(adapter->buffer_list_dma) ) ||
 	   (dma_mapping_error(adapter->filter_list_dma)) ||
@@ -644,7 +658,7 @@ static int ibmveth_start_xmit(struct sk_
 
 	/* map the initial fragment */
 	desc[0].fields.length  = nfrags ? skb->len - skb->data_len : skb->len;
-	desc[0].fields.address = vio_map_single(adapter->vdev, skb->data,
+	desc[0].fields.address = dma_map_single(&adapter->vdev->dev, skb->data,
 					desc[0].fields.length, DMA_TO_DEVICE);
 	desc[0].fields.valid   = 1;
 
@@ -662,7 +676,7 @@ static int ibmveth_start_xmit(struct sk_
 	while(curfrag--) {
 		skb_frag_t *frag = &skb_shinfo(skb)->frags[curfrag];
 		desc[curfrag+1].fields.address
-			= vio_map_single(adapter->vdev,
+			= dma_map_single(&adapter->vdev->dev,
 				page_address(frag->page) + frag->page_offset,
 				frag->size, DMA_TO_DEVICE);
 		desc[curfrag+1].fields.length = frag->size;
@@ -674,7 +688,7 @@ static int ibmveth_start_xmit(struct sk_
 			adapter->stats.tx_dropped++;
 			/* Free all the mappings we just created */
 			while(curfrag < nfrags) {
-				vio_unmap_single(adapter->vdev,
+				dma_unmap_single(&adapter->vdev->dev,
 						 desc[curfrag+1].fields.address,
 						 desc[curfrag+1].fields.length,
 						 DMA_TO_DEVICE);
@@ -714,7 +728,9 @@ static int ibmveth_start_xmit(struct sk_
 	}
 
 	do {
-		vio_unmap_single(adapter->vdev, desc[nfrags].fields.address, desc[nfrags].fields.length, DMA_TO_DEVICE);
+		dma_unmap_single(&adapter->vdev->dev,
+				desc[nfrags].fields.address,
+				desc[nfrags].fields.length, DMA_TO_DEVICE);
 	} while(--nfrags >= 0);
 
 	dev_kfree_skb(skb);
diff -purN linux-2.6.11-rc3-bk1/drivers/pcmcia/ds.c linux-2.6.11-rc3-bk2/drivers/pcmcia/ds.c
--- linux-2.6.11-rc3-bk1/drivers/pcmcia/ds.c	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk2/drivers/pcmcia/ds.c	2005-02-05 16:59:13.940227334 +0100
@@ -660,7 +660,7 @@ int pcmcia_register_client(client_handle
 			p_dev = pcmcia_get_dev(p_dev);
 			if (!p_dev)
 				continue;
-			if ((!p_dev->client.state & CLIENT_UNBOUND) ||
+			if (!(p_dev->client.state & CLIENT_UNBOUND) ||
 			    (!p_dev->dev.driver)) {
 				pcmcia_put_dev(p_dev);
 				continue;
diff -purN linux-2.6.11-rc3-bk1/fs/Kconfig linux-2.6.11-rc3-bk2/fs/Kconfig
--- linux-2.6.11-rc3-bk1/fs/Kconfig	2005-02-03 02:55:53.000000000 +0100
+++ linux-2.6.11-rc3-bk2/fs/Kconfig	2005-02-05 16:59:14.026213947 +0100
@@ -1401,6 +1401,7 @@ config NFSD
 	depends on INET
 	select LOCKD
 	select SUNRPC
+	select EXPORTFS
 	help
 	  If you want your Linux box to act as an NFS *server*, so that other
 	  computers on your local network which support NFS can access certain
@@ -1474,7 +1475,6 @@ config LOCKD_V4
 
 config EXPORTFS
 	tristate
-	default NFSD
 
 config SUNRPC
 	tristate
diff -purN linux-2.6.11-rc3-bk1/include/asm-frv/bitops.h linux-2.6.11-rc3-bk2/include/asm-frv/bitops.h
--- linux-2.6.11-rc3-bk1/include/asm-frv/bitops.h	2005-02-03 02:56:22.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-frv/bitops.h	2005-02-05 16:59:14.034212702 +0100
@@ -178,9 +178,9 @@ extern int find_next_bit(const unsigned 
 #define find_first_zero_bit(addr, size) \
         find_next_zero_bit((addr), (size), 0)
 
-static inline int find_next_zero_bit (void * addr, int size, int offset)
+static inline int find_next_zero_bit(const void *addr, int size, int offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
@@ -277,11 +277,11 @@ static inline int ext2_test_bit(int nr, 
 #define ext2_find_first_zero_bit(addr, size) \
         ext2_find_next_zero_bit((addr), (size), 0)
 
-static inline unsigned long ext2_find_next_zero_bit(void *addr,
+static inline unsigned long ext2_find_next_zero_bit(const void *addr,
 						    unsigned long size,
 						    unsigned long offset)
 {
-	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	const unsigned long *p = ((const unsigned long *) addr) + (offset >> 5);
 	unsigned long result = offset & ~31UL;
 	unsigned long tmp;
 
diff -purN linux-2.6.11-rc3-bk1/include/asm-frv/processor.h linux-2.6.11-rc3-bk2/include/asm-frv/processor.h
--- linux-2.6.11-rc3-bk1/include/asm-frv/processor.h	2005-02-03 02:55:07.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-frv/processor.h	2005-02-05 16:59:14.035212546 +0100
@@ -113,7 +113,7 @@ static inline void release_thread(struct
 
 extern asmlinkage int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
 extern asmlinkage void save_user_regs(struct user_context *target);
-extern asmlinkage void restore_user_regs(const struct user_context *target);
+extern asmlinkage void *restore_user_regs(const struct user_context *target, ...);
 
 #define copy_segments(tsk, mm)		do { } while (0)
 #define release_segments(mm)		do { } while (0)
diff -purN linux-2.6.11-rc3-bk1/include/asm-frv/system.h linux-2.6.11-rc3-bk2/include/asm-frv/system.h
--- linux-2.6.11-rc3-bk1/include/asm-frv/system.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-frv/system.h	2005-02-05 16:59:14.036212390 +0100
@@ -26,13 +26,16 @@ struct thread_struct;
  * The `mb' is to tell GCC not to cache `current' across this call.
  */
 extern asmlinkage
-void __switch_to(struct thread_struct *prev, struct thread_struct *next);
-
-#define switch_to(prev, next, last)						\
-do {										\
-	prev->thread.sched_lr = (unsigned long) __builtin_return_address(0);	\
-	__switch_to(&prev->thread, &next->thread);				\
-	mb();									\
+struct task_struct *__switch_to(struct thread_struct *prev_thread,
+				struct thread_struct *next_thread,
+				struct task_struct *prev);
+
+#define switch_to(prev, next, last)					\
+do {									\
+	(prev)->thread.sched_lr =					\
+		(unsigned long) __builtin_return_address(0);		\
+	(last) = __switch_to(&(prev)->thread, &(next)->thread, (prev));	\
+	mb();								\
 } while(0)
 
 /*
diff -purN linux-2.6.11-rc3-bk1/include/asm-frv/thread_info.h linux-2.6.11-rc3-bk2/include/asm-frv/thread_info.h
--- linux-2.6.11-rc3-bk1/include/asm-frv/thread_info.h	2005-02-03 02:55:23.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-frv/thread_info.h	2005-02-05 16:59:14.037212235 +0100
@@ -132,6 +132,7 @@ register struct thread_info *__current_t
 #define TIF_SINGLESTEP		4	/* restore singlestep on return to user mode */
 #define TIF_IRET		5	/* return with iret */
 #define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+#define TIF_MEMDIE		17	/* OOM killer killed process */
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
diff -purN linux-2.6.11-rc3-bk1/include/asm-ppc/io.h linux-2.6.11-rc3-bk2/include/asm-ppc/io.h
--- linux-2.6.11-rc3-bk1/include/asm-ppc/io.h	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-ppc/io.h	2005-02-05 16:59:14.117199782 +0100
@@ -133,7 +133,10 @@ extern inline void out_be32(volatile uns
 {
 	__asm__ __volatile__("stw%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
-
+#if defined (CONFIG_8260_PCI9)
+#define readb(addr) in_8((volatile u8 *)(addr))
+#define writeb(b,addr) out_8((volatile u8 *)(addr), (b))
+#else
 static inline __u8 readb(volatile void __iomem *addr)
 {
 	return in_8(addr);
@@ -142,6 +145,8 @@ static inline void writeb(__u8 b, volati
 {
 	out_8(addr, b);
 }
+#endif
+
 #if defined(CONFIG_APUS)
 static inline __u16 readw(volatile void __iomem *addr)
 {
@@ -159,6 +164,12 @@ static inline void writel(__u32 b, volat
 {
 	*(__force volatile __u32 *)(addr) = b;
 }
+#elif defined (CONFIG_8260_PCI9)
+/* Use macros if PCI9 workaround enabled */
+#define readw(addr) in_le16((volatile u16 *)(addr))
+#define readl(addr) in_le32((volatile u32 *)(addr))
+#define writew(b,addr) out_le16((volatile u16 *)(addr),(b))
+#define writel(b,addr) out_le32((volatile u32 *)(addr),(b))
 #else
 static inline __u16 readw(volatile void __iomem *addr)
 {
@@ -332,6 +343,11 @@ extern void _outsl_ns(volatile u32 __iom
 
 #define IO_SPACE_LIMIT ~0
 
+#if defined (CONFIG_8260_PCI9)
+#define memset_io(a,b,c)       memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)   memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)     memcpy((void *)(a),(b),(c))
+#else
 static inline void memset_io(volatile void __iomem *addr, unsigned char val, int count)
 {
 	memset((void __force *)addr, val, count);
@@ -392,7 +408,7 @@ extern inline void * bus_to_virt(unsigne
 	return (void*) mm_ptov (address);
 #endif
 }
-
+#endif
 /*
  * Change virtual addresses to physical addresses and vv, for
  * addresses in the area where the kernel has the RAM mapped.
diff -purN linux-2.6.11-rc3-bk1/include/asm-ppc/spinlock.h linux-2.6.11-rc3-bk2/include/asm-ppc/spinlock.h
--- linux-2.6.11-rc3-bk1/include/asm-ppc/spinlock.h	2005-02-03 02:55:36.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-ppc/spinlock.h	2005-02-05 16:59:14.125198536 +0100
@@ -82,29 +82,43 @@ extern int _raw_spin_trylock(spinlock_t 
  * read-locks.
  */
 typedef struct {
-	volatile unsigned long lock;
-#ifdef CONFIG_DEBUG_SPINLOCK
-	volatile unsigned long owner_pc;
-#endif
+	volatile signed int lock;
 #ifdef CONFIG_PREEMPT
 	unsigned int break_lock;
 #endif
 } rwlock_t;
 
-#ifdef CONFIG_DEBUG_SPINLOCK
-#define RWLOCK_DEBUG_INIT     , 0
-#else
-#define RWLOCK_DEBUG_INIT     /* */
-#endif
-
-#define RW_LOCK_UNLOCKED (rwlock_t) { 0 RWLOCK_DEBUG_INIT }
+#define RW_LOCK_UNLOCKED (rwlock_t) { 0 }
 #define rwlock_init(lp) do { *(lp) = RW_LOCK_UNLOCKED; } while(0)
 
+#define read_can_lock(rw)	((rw)->lock >= 0)
+#define write_can_lock(rw)	(!(rw)->lock)
+
 #ifndef CONFIG_DEBUG_SPINLOCK
 
+static __inline__ int _raw_read_trylock(rwlock_t *rw)
+{
+	signed int tmp;
+
+	__asm__ __volatile__(
+"2:	lwarx	%0,0,%1		# read_trylock\n\
+	addic.	%0,%0,1\n\
+	ble-	1f\n"
+	PPC405_ERR77(0,%1)
+"	stwcx.	%0,0,%1\n\
+	bne-	2b\n\
+	isync\n\
+1:"
+	: "=&r"(tmp)
+	: "r"(&rw->lock)
+	: "cr0", "memory");
+
+	return tmp > 0;
+}
+
 static __inline__ void _raw_read_lock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	signed int tmp;
 
 	__asm__ __volatile__(
 	"b	2f		# read_lock\n\
@@ -125,7 +139,7 @@ static __inline__ void _raw_read_lock(rw
 
 static __inline__ void _raw_read_unlock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	signed int tmp;
 
 	__asm__ __volatile__(
 	"eieio			# read_unlock\n\
@@ -141,7 +155,7 @@ static __inline__ void _raw_read_unlock(
 
 static __inline__ int _raw_write_trylock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	signed int tmp;
 
 	__asm__ __volatile__(
 "2:	lwarx	%0,0,%1		# write_trylock\n\
@@ -161,7 +175,7 @@ static __inline__ int _raw_write_trylock
 
 static __inline__ void _raw_write_lock(rwlock_t *rw)
 {
-	unsigned int tmp;
+	signed int tmp;
 
 	__asm__ __volatile__(
 	"b	2f		# write_lock\n\
@@ -192,11 +206,10 @@ extern void _raw_read_lock(rwlock_t *rw)
 extern void _raw_read_unlock(rwlock_t *rw);
 extern void _raw_write_lock(rwlock_t *rw);
 extern void _raw_write_unlock(rwlock_t *rw);
+extern int _raw_read_trylock(rwlock_t *rw);
 extern int _raw_write_trylock(rwlock_t *rw);
 
 #endif
 
-#define _raw_read_trylock(lock) generic_raw_read_trylock(lock)
-
 #endif /* __ASM_SPINLOCK_H */
 #endif /* __KERNEL__ */
diff -purN linux-2.6.11-rc3-bk1/include/asm-ppc64/paca.h linux-2.6.11-rc3-bk2/include/asm-ppc64/paca.h
--- linux-2.6.11-rc3-bk1/include/asm-ppc64/paca.h	2005-02-03 02:55:39.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-ppc64/paca.h	2005-02-05 16:59:14.125198536 +0100
@@ -68,7 +68,7 @@ struct paca_struct {
 	u64 stab_real;			/* Absolute address of segment table */
 	u64 stab_addr;			/* Virtual address of segment table */
 	void *emergency_sp;		/* pointer to emergency stack */
-	u16 hw_cpu_id;			/* Physical processor number */
+	s16 hw_cpu_id;			/* Physical processor number */
 	u8 cpu_start;			/* At startup, processor spins until */
 					/* this becomes non-zero. */
 
diff -purN linux-2.6.11-rc3-bk1/include/asm-um/pgtable.h linux-2.6.11-rc3-bk2/include/asm-um/pgtable.h
--- linux-2.6.11-rc3-bk1/include/asm-um/pgtable.h	2005-02-03 02:57:04.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-um/pgtable.h	2005-02-05 16:59:14.130197758 +0100
@@ -155,12 +155,6 @@ extern pte_t * __bad_pagetable(void);
 #define pud_newpage(x)  (pud_val(x) & _PAGE_NEWPAGE)
 #define pud_mkuptodate(x) (pud_val(x) &= ~_PAGE_NEWPAGE)
 
-static inline pud_t fastcall *__pud_alloc(struct mm_struct *mm, pgd_t *pgd,
-					  unsigned long addr)
-{
-	BUG();
-}
-
 #define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
 
 #define pmd_page(pmd) phys_to_page(pmd_val(pmd) & PAGE_MASK)
diff -purN linux-2.6.11-rc3-bk1/include/asm-um/processor-i386.h linux-2.6.11-rc3-bk2/include/asm-um/processor-i386.h
--- linux-2.6.11-rc3-bk1/include/asm-um/processor-i386.h	2005-02-03 02:55:06.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-um/processor-i386.h	2005-02-05 16:59:14.130197758 +0100
@@ -27,6 +27,9 @@ struct arch_thread {
 #define current_text_addr() \
 	({ void *pc; __asm__("movl $1f,%0\n1:":"=g" (pc)); pc; })
 
+#define ARCH_IS_STACKGROW(address) \
+       (address + 32 >= UPT_SP(&current->thread.regs.regs))
+
 #include "asm/processor-generic.h"
 
 #endif
diff -purN linux-2.6.11-rc3-bk1/include/asm-um/processor-x86_64.h linux-2.6.11-rc3-bk2/include/asm-um/processor-x86_64.h
--- linux-2.6.11-rc3-bk1/include/asm-um/processor-x86_64.h	2005-02-03 02:57:16.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/asm-um/processor-x86_64.h	2005-02-05 16:59:14.131197602 +0100
@@ -17,6 +17,9 @@ struct arch_thread {
 #define current_text_addr() \
 	({ void *pc; __asm__("movq $1f,%0\n1:":"=g" (pc)); pc; })
 
+#define ARCH_IS_STACKGROW(address) \
+        (address + 128 >= UPT_SP(&current->thread.regs.regs))
+
 #include "asm/processor-generic.h"
 
 #endif
diff -purN linux-2.6.11-rc3-bk1/include/linux/jiffies.h linux-2.6.11-rc3-bk2/include/linux/jiffies.h
--- linux-2.6.11-rc3-bk1/include/linux/jiffies.h	2005-02-03 02:54:56.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/linux/jiffies.h	2005-02-05 16:59:14.143195734 +0100
@@ -265,10 +265,10 @@ static inline unsigned int jiffies_to_ms
 
 static inline unsigned int jiffies_to_usecs(const unsigned long j)
 {
-#if HZ <= 1000 && !(1000 % HZ)
+#if HZ <= 1000000 && !(1000000 % HZ)
 	return (1000000 / HZ) * j;
-#elif HZ > 1000 && !(HZ % 1000)
-	return (j*1000 + (HZ - 1000))/(HZ / 1000);
+#elif HZ > 1000000 && !(HZ % 1000000)
+	return (j + (HZ / 1000000) - 1)/(HZ / 1000000);
 #else
 	return (j * 1000000) / HZ;
 #endif
@@ -291,9 +291,9 @@ static inline unsigned long usecs_to_jif
 {
 	if (u > jiffies_to_usecs(MAX_JIFFY_OFFSET))
 		return MAX_JIFFY_OFFSET;
-#if HZ <= 1000 && !(1000 % HZ)
-	return (u + (1000000 / HZ) - 1000) / (1000000 / HZ);
-#elif HZ > 1000 && !(HZ % 1000)
+#if HZ <= 1000000 && !(1000000 % HZ)
+	return (u + (1000000 / HZ) - 1) / (1000000 / HZ);
+#elif HZ > 1000000 && !(HZ % 1000000)
 	return u * (HZ / 1000000);
 #else
 	return (u * HZ + 999999) / 1000000;
diff -purN linux-2.6.11-rc3-bk1/include/linux/mm.h linux-2.6.11-rc3-bk2/include/linux/mm.h
--- linux-2.6.11-rc3-bk1/include/linux/mm.h	2005-02-03 02:54:59.000000000 +0100
+++ linux-2.6.11-rc3-bk2/include/linux/mm.h	2005-02-05 16:59:14.145195423 +0100
@@ -38,7 +38,7 @@ extern int sysctl_legacy_va_layout;
 #include <asm/atomic.h>
 
 #ifndef MM_VM_SIZE
-#define MM_VM_SIZE(mm)	TASK_SIZE
+#define MM_VM_SIZE(mm)	((TASK_SIZE + PGDIR_SIZE - 1) & PGDIR_MASK)
 #endif
 
 #define nth_page(page,n) pfn_to_page(page_to_pfn((page)) + (n))
diff -purN linux-2.6.11-rc3-bk1/init/Kconfig linux-2.6.11-rc3-bk2/init/Kconfig
--- linux-2.6.11-rc3-bk1/init/Kconfig	2005-02-03 02:56:33.000000000 +0100
+++ linux-2.6.11-rc3-bk2/init/Kconfig	2005-02-05 16:59:14.148194956 +0100
@@ -410,7 +410,7 @@ config OBSOLETE_MODPARM
 
 config MODVERSIONS
 	bool "Module versioning support (EXPERIMENTAL)"
-	depends on MODULES && EXPERIMENTAL
+	depends on MODULES && EXPERIMENTAL && !USERMODE
 	help
 	  Usually, you have to use modules compiled with your kernel.
 	  Saying Y here makes it sometimes possible to use modules
diff -purN linux-2.6.11-rc3-bk1/mm/mmap.c linux-2.6.11-rc3-bk2/mm/mmap.c
--- linux-2.6.11-rc3-bk1/mm/mmap.c	2005-02-03 02:56:10.000000000 +0100
+++ linux-2.6.11-rc3-bk2/mm/mmap.c	2005-02-05 16:59:14.152194333 +0100
@@ -1612,8 +1612,8 @@ static void free_pgtables(struct mmu_gat
 	unsigned long last = end + PGDIR_SIZE - 1;
 	struct mm_struct *mm = tlb->mm;
 
-	if (last > TASK_SIZE || last < end)
-		last = TASK_SIZE;
+	if (last > MM_VM_SIZE(mm) || last < end)
+		last = MM_VM_SIZE(mm);
 
 	if (!prev) {
 		prev = mm->mmap;
@@ -1995,8 +1995,7 @@ void exit_mmap(struct mm_struct *mm)
 					~0UL, &nr_accounted, NULL);
 	vm_unacct_memory(nr_accounted);
 	BUG_ON(mm->map_count);	/* This is just debugging */
-	clear_page_range(tlb, FIRST_USER_PGD_NR * PGDIR_SIZE,
-			(TASK_SIZE + PGDIR_SIZE - 1) & PGDIR_MASK);
+	clear_page_range(tlb, FIRST_USER_PGD_NR * PGDIR_SIZE, MM_VM_SIZE(mm));
 	
 	tlb_finish_mmu(tlb, 0, MM_VM_SIZE(mm));
 
diff -purN linux-2.6.11-rc3-bk1/mm/slab.c linux-2.6.11-rc3-bk2/mm/slab.c
--- linux-2.6.11-rc3-bk1/mm/slab.c	2005-02-03 02:57:17.000000000 +0100
+++ linux-2.6.11-rc3-bk2/mm/slab.c	2005-02-05 16:59:14.157193555 +0100
@@ -2860,7 +2860,7 @@ static void *s_start(struct seq_file *m,
 		seq_puts(m, "slabinfo - version: 2.1\n");
 #endif
 		seq_puts(m, "# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>");
-		seq_puts(m, " : tunables <batchcount> <limit> <sharedfactor>");
+		seq_puts(m, " : tunables <limit> <batchcount> <sharedfactor>");
 		seq_puts(m, " : slabdata <active_slabs> <num_slabs> <sharedavail>");
 #if STATS
 		seq_puts(m, " : globalstat <listallocs> <maxobjs> <grown> <reaped>"
diff -purN linux-2.6.11-rc3-bk1/mm/vmscan.c linux-2.6.11-rc3-bk2/mm/vmscan.c
--- linux-2.6.11-rc3-bk1/mm/vmscan.c	2005-02-03 02:55:14.000000000 +0100
+++ linux-2.6.11-rc3-bk2/mm/vmscan.c	2005-02-05 16:59:14.159193244 +0100
@@ -575,6 +575,7 @@ static void shrink_cache(struct zone *zo
 			nr_taken++;
 		}
 		zone->nr_inactive -= nr_taken;
+		zone->pages_scanned += nr_scan;
 		spin_unlock_irq(&zone->lru_lock);
 
 		if (nr_taken == 0)
diff -purN linux-2.6.11-rc3-bk1/security/selinux/hooks.c linux-2.6.11-rc3-bk2/security/selinux/hooks.c
--- linux-2.6.11-rc3-bk1/security/selinux/hooks.c	2005-02-03 02:56:49.000000000 +0100
+++ linux-2.6.11-rc3-bk2/security/selinux/hooks.c	2005-02-05 16:59:14.167191998 +0100
@@ -2140,6 +2140,9 @@ static int selinux_inode_setattr(struct 
 	if (rc)
 		return rc;
 
+	if (iattr->ia_valid & ATTR_FORCE)
+		return 0;
+
 	if (iattr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID |
 			       ATTR_ATIME_SET | ATTR_MTIME_SET))
 		return dentry_has_perm(current, NULL, dentry, FILE__SETATTR);

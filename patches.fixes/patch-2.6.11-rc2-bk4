From: olh@suse.de
Subject: 2.6.11-rc2-bk4

 -- www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc2-bk3.log	2005-01-25 13:30:23.000000000 +0100
 ++ www.kernel.org/pub/linux/kernel/v2.6/snapshots/patch-2.6.11-rc2-bk4.log	2005-01-26 13:51:43.000000000 +0100
 ChangeSet@1.2138, 2005-01-25 22:00:23-08:00, James.Bottomley@SteelEye.com
   [PATCH] fix broken cross compiles
   
   The change to kbuild to use -isystem `gcc -print-file-name=include`
   broke our parisc crosscompile (and presumably everyone else's).
   
   The reason is that you have a := in the NOSTDINC_FLAGS rule, which is
   evaluated in situ (i.e.  before we've had a chance to set CROSSCOMPILE
   on CC) so the gcc include path is actually the native one not the
   crosscompiler one.  On parisc this causes us to be unable to handle
   _builtin_va functions, but I bet there are a heap of other problems. 
   
   Acked-by: Sam Ravnborg <sam@ravnborg.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2137, 2005-01-25 21:15:28-08:00, nathanl@austin.ibm.com
   [PATCH] ppc64: fix use kref for device_node refcounting (fix)
   
   The recent ppc64 patch to use kref for device_node refcounting
   introduced an unbalanced get/put in of_add_node which would cause
   newly-added device nodes to be prematurely freed.  Sorry for the
   screwup, a more rigorously tested fix follows.
   
   Signed-off-by: Nathan Lynch <nathanl@austin.ibm.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2136, 2005-01-25 20:56:30-08:00, olh@suse.de
   [PATCH] fix architecture names in hugetlbpage.txt
   
   Anton fixed the code recently, but forgot to fix the documentation.  There
   is no "ia32" thing, its i386.  The other thing is named 'ia64' in arch/
   
   Signed-off-by: Olaf Hering <olh@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2135, 2005-01-25 20:56:12-08:00, rusty@rustcorp.com.au
   [PATCH] Include type information as module info where possible
   
   Module parameters no longer have a type in general, as we use a callback
   system (module_param_call()).  However, it's useful to include type
   information in the commonly-used wrappers: module_param,
   module_param_string and module_param_array.
   
   Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2134, 2005-01-25 20:55:59-08:00, adaplas@hotpop.com
   [PATCH] matroxfb: FB_MATROX_G Kconfig changes
   
   The current Kconfig entries for the Matrox G cards are quite confusing:
   
     config FB_MATROX_G450
             bool "G100/G200/G400/G450/G550 support"
             depends on FB_MATROX
   
     config FB_MATROX_G100A
             bool "G100/G200/G400 support"
             depends on FB_MATROX && !FB_MATROX_G450
   
     The patch below contains:
     - remove FB_MATROX_G100{,A} and rename FB_MATROX_G to FB_MATROX_G450
       (FB_MATROX_G450 included support from the G100 to the G550, so
        I don't see any non-historic reason why to call it G450)
     - small update for the FB_MATROX_G Kconfig text
   
     The disadvantage of this patch is, that you can no longer select support
     only for the G100-G400 without supporting the G450 and G550. But
     compared with the current confusing Kconfig setup, I don't think that's
     a big issue.
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2133, 2005-01-25 20:55:42-08:00, adaplas@hotpop.com
   [PATCH] backlight: Fix compile error if CONFIG_FB is unset
   
   With Andrew Zabolotny <zap@homelink.ru>
   
      LD      init/built-in.o
       LD      .tmp_vmlinux1
     drivers/built-in.o(.text+0x9bfa): In function `lcd_device_register':
     : undefined reference to `fb_register_client'
     drivers/built-in.o(.text+0x9ce3): In function `lcd_device_unregister':
     : undefined reference to `fb_unregister_client'
     drivers/built-in.o(.text+0xa16a): In function `backlight_device_register':
     : undefined reference to `fb_register_client'
     drivers/built-in.o(.text+0xa253): In function `backlight_device_unregister':
     : undefined reference to `fb_unregister_client'
     make: *** [.tmp_vmlinux1] Error 1
   
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2132, 2005-01-25 20:55:28-08:00, adaplas@hotpop.com
   [PATCH] fbcon: Save blank state last
   
   Save blank state after do_blank|unblank_screen() since this flag is checked in
   fbcon_blank().
   
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2131, 2005-01-25 20:55:14-08:00, adaplas@hotpop.com
   [PATCH] intelfb: Workaround for 830M
   
   This is a work around for the 830M with intelfb.  Relative to 2.6.10.  Without
   this patch, updates to the DSPACNTR register will be ignored.
   
   On the 830M, the display plane needs to be enabled before writing to any of
   the other bits in the DSPACNTR register.
   
   This patch detects the specific case, temporarily enables the plane, updates
   the register, and then disables the plane.  It also appears to require some
   settling time, but not an entire frame's time.
   
   Without this change, the pixel format fields in DSPACNTR won't get written on
   the 830M.
   
   Signed-off-by: Andrew Pfiffer <andrewx.k.pfiffer@intel.com>
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2130, 2005-01-25 20:54:57-08:00, adaplas@hotpop.com
   [PATCH] vesafb: Change return error id
   
   With <Stuart_Hayes@Dell.com>
   
   I'm getting a message in dmesg: "localhost kernel: vesafb: probe of vesafb0
   failed with error -6"
   
   I searched the web, and found that a lot of people are getting this, but I
   couldn't find an answer, so I looked into it.
   
   This appears to be because "vesafb" returns -ENXIO ("No such device or
   address") when its probe function fails.  However, driverse/base/bus.c spews
   an error message during device_attach() if a matching driver's probe function
   returns anything but -ENODEV ("No such device").
   
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2129, 2005-01-25 20:54:43-08:00, adaplas@hotpop.com
   [PATCH] radeonfb: Set accelerator id
   
   Set accelerator id for radeonfb.  This id is checked by some user apps such as
   DirectFB.
   
   Signed-off-by: Antonino Daplas <adaplas@pol.net>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2128, 2005-01-25 20:54:24-08:00, kraxel@bytesex.org
   [PATCH] add i2c adapter id for the cx88 driver.
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2127, 2005-01-25 20:54:10-08:00, kraxel@bytesex.org
   [PATCH] v4l-saa7134-module fix
   
   New version, this time using a #define, which should kill the reference
   to need_* as well ...
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2126, 2005-01-25 20:53:56-08:00, kraxel@bytesex.org
   [PATCH] v4l: saa7134 module
   
   - fix saa7134 module loading issues.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2125, 2005-01-25 20:53:37-08:00, kraxel@bytesex.org
   [PATCH] v4l: bttv update
   
   - some cleanups merged.
   - use new tveeprom module to configure Hauppauge cards.
   - add new tv cards.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2124, 2005-01-25 20:53:22-08:00, kraxel@bytesex.org
   [PATCH] v4l: bttv IR input driver update
   
   This patch enables IR support for one AverMedia card and drops a obsolete
   function.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2123, 2005-01-25 20:53:05-08:00, kraxel@bytesex.org
   [PATCH] v4l: tvaudio update
   
   - minor msp3400 updates.
   - add tea6320 support.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2122, 2005-01-25 20:52:50-08:00, kraxel@bytesex.org
   [PATCH] v4l: add tveeprom module.
   
   Add a module which can parse config informations out of TV card eeproms.  Will
   be used by bttv, cx88 and ivtv.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2121, 2005-01-25 20:52:33-08:00, kraxel@bytesex.org
   [PATCH] v4l: tuner update
   
   - add new tuner types.
   - add support for digital tv tuning.
   - make tda9887 output ports more configurable.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2120, 2005-01-25 20:52:17-08:00, kraxel@bytesex.org
   [PATCH] v4l2 tuner api update
   
   Add new tuner type to the v4l2 API.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2119, 2005-01-25 20:52:00-08:00, kraxel@bytesex.org
   [PATCH] v4l: video-buf update
   
   - Fix a memory leak in video-buf.c
   - Small update for the video-buf-dvb.c module.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2118, 2005-01-25 20:51:45-08:00, kraxel@bytesex.org
   [PATCH] video/zr36120: remove casts
   
   Remove unneeded casts of (void *) pointers.
   
   Signed-off-by: Domen Puncer <domen@coderock.org>
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2117, 2005-01-25 20:51:29-08:00, kraxel@bytesex.org
   [PATCH] video/w9966: remove casts
   
   Remove unneeded casts of (void *) pointers.
   
   Signed-off-by: Domen Puncer <domen@coderock.org>
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2116, 2005-01-25 20:51:15-08:00, kraxel@bytesex.org
   [PATCH] video/arv: remove casts
   
   Remove unneeded casts of (void *) pointers.
   
   Signed-off-by: Domen Puncer <domen@coderock.org>
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>-
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2115, 2005-01-25 20:50:58-08:00, kraxel@bytesex.org
   [PATCH] videotext: ioctls changed to use _IO macros
   
   From: Michael Geng <linux@MichaelGeng.de>
   
   This patch switches the videotext drivers over to use the _IO macros for
   ioctls.  video_usercopy() works correctly then.  The drivers will also map the
   old to the new ioctl numbers to make sure old apps don't break.
   
   The patch also updates Documentation/ioctl.h to reflect that change.  and
   deletes a unused struct in include/linux/videotext.h.
   
   Signed-off-by: Gerd Knorr <kraxel@bytesex.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2114, 2005-01-25 20:50:44-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: use unsigned long for IO port address
   
   With Randy Dunlap <rddunlap@osdl.org>
   
   PCMCIA: convert internal I/O port addresses to unsigned long (kio_addr_t).
   
   Dominik pointed out that some ioaddr_t data are exposed to userspace, so don't
   touch those structures.
   
   Linus said:
   But the right thing is definitely to make an IO port pointer be
   "unsigned int" or even "unsigned long".
   URL:  http://lkml.org/lkml/2005/1/11/168
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2113, 2005-01-25 20:50:25-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: socket->{a,c}region are unused
   
   From: Christoph Hellwig <hch@lst.de>
   
   socket->{a,c}_region aren't ever touched elsewhere, so let's kill this.
   
   Signed-off-by: Christoph Hellwig <hch@lst.de>
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2112, 2005-01-25 20:50:11-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: i82092: fix checking of return value from request_region
   
   From: Randy Dunlap <rddunlap@osdl.org>
   
   i82092: check return value from request_region() correctly;
   apparently unused for awhile now;
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2111, 2005-01-25 20:49:54-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: i82365: use CONFIG_PNP instead of __ISAPNP__
   
   From: Randy Dunlap <rddunlap@osdl.org>
   
   Use CONFIG_PNP consistenly, for allocating and freeing
   resources, drop __ISAPNP__.
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2110, 2005-01-25 20:49:39-08:00, linux@dominikbrodowski.de
   [PATCH] pcmcia: tcic: eleminate deprecated check_region()
   
   From: Randy Dunlap <rddunlap@osdl.org>
   
   tcic: eliminate deprecated check_region();
   
   Signed-off-by: Randy Dunlap <rddunlap@osdl.org>
   Signed-off-by: Dominik Brodowski <linux@brodo.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2109, 2005-01-25 20:49:23-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: initialize mutex  earlier
   
   The cap_mask_mutex needs to be initialized before ib_register_device(),
   because device registration will call client init functions that may try to
   modify the capability mask.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2108, 2005-01-25 20:49:05-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: remove x86 SSE pessimization
   
   Get rid of the x86 SSE code for atomic 64-bit writes to doorbell registers.
   Saving/setting CR0 plus a clts instruction are too expensive for it to ever be
   a win, and the config option was just confusing.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2107, 2005-01-25 20:48:48-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: clean up ioremap()/request_region() usage
   
   From: "Michael S. Tsirkin" <mst@mellanox.co.il>
   
   Here are misc fixes for mthca mapping:
   
   1. Thinkably, MSI tables or another region could fall between HCR
      and ECR tables.
      Thus its arguably wrong to map both tables in one region.
      So, do it separately.
      I think its also more readable to have ecr_base and access ecr there,
      not access ecr with hcr pointer.
   
   2. mthca_request_regions error handling was borken
      (wrong order of cleanups). For example on all errors
      pci_release_region was called which is wrong if the region
      was not yet mapped. And other such cleanups.
   
   3. Fixed some error messages too.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2106, 2005-01-25 20:48:33-08:00, roland@topspin.com
   [PATCH] InfiniBand/core: add IsSM userspace support
   
   Implement setting/clearing IsSM port capability bit from userspace via "issm"
   special files (set IsSM bit on open, clear on close).
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2105, 2005-01-25 20:48:17-08:00, roland@topspin.com
   [PATCH] InfiniBand/ipoib: remove uses of yield()
   
   Replace uses of yield() with msleep(1) as suggested by kernel janitors.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2104, 2005-01-25 20:48:02-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: test IRQ routing during initialization
   
   When we switch to interrupt-driven command mode, test interrupt generation
   with a NOP firmware command.  Broken MSI/MSI-X and interrupt line routing
   problems seem to be very common, and this makes the error message much clearer
   -- before this change we would mysteriously fail when initializing the QP
   table.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2103, 2005-01-25 20:47:46-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: optimize event queue handling
   
   From: "Michael S. Tsirkin" <mst@mellanox.co.il>
   
   Event queue handling performance improvements:
    - Only calculate EQ entry address once, and don't truncate the
      consumer index until we really need to.
    - Only read ECR once.  If a new event occurs while we're in the
      interrupt handler, we'll get another interrupt anyway, since we
      only clear events once.
   
   Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2102, 2005-01-25 20:47:32-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: pass full process_mad info to firmware
   
   From: "Michael S. Tsirkin" <mst@mellanox.co.il>
   
   Pass full extended MAD information to firmware when a work completion is
   supplied to the MAD_IFC command.  This allows B_Key checking/trap generation.
   
   Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2101, 2005-01-25 20:47:14-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: don't write ECR in MSI-X mode
   
   From: "Michael S. Tsirkin" <mst@mellanox.co.il>
   
   We don't need to write to the ECR to clear events when using MSI-X, since we
   never read the ECR anyway.
   
   Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2100, 2005-01-25 20:47:00-08:00, roland@topspin.com
   [PATCH] InfiniBand/core: fix port capability enums bit order
   
   Correct defines of port capability mask enum values (bits were ordered
   backwards) and add new capability bits from IBA spec version 1.2.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2099, 2005-01-25 20:46:43-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: implement modifying port attributes
   
   Implement the port_modify() device method for mthca using the SET_IB firmware
   command.  In particular this allows changing the port capability mask.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2098, 2005-01-25 20:46:29-08:00, roland@topspin.com
   [PATCH] InfiniBand/mthca: more Arbel Mem-Free support
   
   Continue development of Arbel Mem-Free support: we now compute a valid
   profile, allocate context memory, map sufficient aux memory for HCA page
   tables, map sufficient context memory to cover all reserved firmware resources
   and successfully call the INIT_HCA and QUERY_ADAPTER firmware commands.  Fix a
   few error gotos that unwound the wrong things.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2097, 2005-01-25 20:46:12-08:00, roland@topspin.com
   [PATCH] InfiniBand/core: compat_ioctl conversion minor fixes
   
   Slightly tidy up Andi Kleen's compat_ioctl conversion for the InfiniBand MAD
   driver by removing the no-longer-needed include of ioctl32.h, killing
   unreachable code and doing some really anal whitespace fixing.
   
   Signed-off-by: Roland Dreier <roland@topspin.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2096, 2005-01-25 20:45:58-08:00, anton@samba.org
   [PATCH] genhd: rename device_init
   
   Rename device_init to make it more unique.  Useful when looking through
   debug initcall bootlogs.  While I'm in the area, also make it static.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2095, 2005-01-25 20:45:45-08:00, anton@samba.org
   [PATCH] Problems disabling SYSCTL
   
   Create a cond_syscall for sys32_sysctl and make all architectures use it.
   Also fix the architectures that dont wrap their 32bit compat sysctl code.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2094, 2005-01-25 20:45:28-08:00, james4765@cwazy.co.uk
   [PATCH] arm26: new maintainer of Archimedes floppy and hard disk drivers
   
   After getting in touch with the listed maintainer of the ARM26 floppy and
   hard drive maintainer, I found out that he had passed it on to Ian Molton.
   
   Signed-off-by: James Nelson <james4765@gmail.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2093, 2005-01-25 20:45:13-08:00, kevcorry@us.ibm.com
   [PATCH] device-mapper: fix TB stripe data corruption
   
   In stripe_map(), change chunk to 64-bit and use do_div to divide and mod by
   the number of stripes.
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2092, 2005-01-25 20:44:57-08:00, agk@redhat.com
   [PATCH] device-mapper: optionally bypass a bdget
   
   Improve performance by optionally bypassing some code that uses bdget.
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2091, 2005-01-25 20:44:38-08:00, agk@redhat.com
   [PATCH] device-mapper: Add presuspend hook
   
   Add optional callback before each device gets suspended (called 'presuspend').
   Rename existing callback used by dm-mirror from 'suspend' to 'postsuspend'.
   
   dm-multipath will use the new callback.
   
   (Any kernel module using device-mapper must be recompiled after this patch.)
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2090, 2005-01-25 20:44:22-08:00, agk@redhat.com
   [PATCH] device-mapper: remove unused bs_bio_init()
   
   Remove unused bs_bio_init().
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2089, 2005-01-25 20:44:09-08:00, agk@redhat.com
   [PATCH] device-mapper: fix mirror log type module ref count
   
   Fix module reference counting for mirror log type.
   
   Signed-Off-By: Alasdair G Kergon <agk@redhat.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2088, 2005-01-25 20:43:55-08:00, agruen@suse.de
   [PATCH] fs/mbcache.c: Remove an unused wait queue variable
   
   This one slipped me. The "real" wait queue is defined some lines further
   down inside the loop.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2087, 2005-01-25 20:43:39-08:00, dsd@gentoo.org
   [PATCH] Configurable delay before mounting root device
   
   Adds a boot parameter which can be used to specify a delay (in seconds)
   before the root device is decoded/discovered/mounted.
   
   Example usage for 10 second delay:
   
   	rootdelay=10
   
   Useful for usb-storage devices which no longer make their partitions
   immediately available, and for other storage devices which require some
   "spin-up" time.
   
   Signed-off-by: Daniel Drake <dsd@gentoo.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2086, 2005-01-25 20:43:20-08:00, linville@tuxdriver.com
   [PATCH] i810_audio: offset LVI from CIV to avoid stalled start
   
   This fixes a "no sound" problem with Wolfenstein Enemy Territory and
   (apparently) other games using the Quake3 engine.  It probably affects some
   other OSS applications as well.
   
   This recreates some code that had been removed from the i810_audio driver
   around 5/2004.  (This is the 2.6-based version of this patch.)
   
   Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
   Acked-by: Thomas Voegtle <tv@lio96.de>
   Signed-off-by: John W. Linville <linville@tuxdriver.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2085, 2005-01-25 20:43:03-08:00, matthew@wil.cx
   [PATCH] Minor ext2 speedup
   
   Port Andreas Dilger's and Jan Kara's patch for ext3 to ext2.  Also some
   whitespace changes to get ext2/ext3 closer in sync.
   
   Signed-off-by: Matthew Wilcox <matthew@wil.cx>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2084, 2005-01-25 20:42:49-08:00, agruen@suse.de
   [PATCH] ext2/ext3 ACLs: remove the number of acl entries limit
   
   This patch removes the arbitrary limit of 32 acl entries on ext[23] when
   writing acls.  A patch that removes the same check when reding acls is in
   BK since 12 March 2004, so all kernels since then are already able to read
   large acls.  I think that ten+ months are enough so that we can now also
   remove the write limit.
   
   This is the read-limit patch:
   http://linux.bkbits.net:8080/linux-2.6/cset%404051e2863UsuQEgAQShmimgBooAXkg?nav=index.html
   
   Even without this patch the xattr block could already contain less space
   than needed for the acl, because other attributes might already use up
   almost all space.  So this patch does not introduce additional error
   conditions.  We have been shipping with this patch the last year (almost).
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2083, 2005-01-25 20:42:31-08:00, agruen@suse.de
   [PATCH] ext3: fix ea-in-inode default ACL creation
   
   When a new inode is created, ext3_new_inode sets the EXT3_STATE_NEW flag,
   which tells ext3_do_update_inode to zero out the inode before filling in
   the inode's data.  When a file is created in a directory with a default
   acl, the new inode inherits the directory's default acl; this generates
   attributes.  The attributes are created before ext3_do_update_inode is
   called to write out the inode.  In case of in-inode attributes, the new
   inode's attributes are written, and then zeroed out again by
   ext3_do_update_inode.  Bad thing.
   
   Fix this by recognizing the EXT3_STATE_NEW case in ext3_xattr_set_handle,
   and zeroing out the inode there already when necessary.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2082, 2005-01-25 20:42:18-08:00, agruen@suse.de
   [PATCH] ext3/ea: disallow in-inode attributes for reserved inodes
   
   When creating a filesystem with inodes bigger than 128 bytes, mke2fs fails
   to clear out bytes beyond EXT3_GOOD_OLD_INODE_SIZE in all inodes it creates
   (the journal, the filesystem root, and lost+found).  We would require a
   zeroed-out i_extra_isize field but we don't get it, so disallow in-inode
   attributes for those inodes.
   
   Add an i_extra_isize sanity check.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2081, 2005-01-25 20:42:01-08:00, agruen@suse.de
   [PATCH] ext3/ea: ix i_extra_isize check
   
   We are checking for (EXT3_SB(inode->i_sb)->s_inode_size <=
   EXT3_GOOD_OLD_INODE_SIZE) to find out if we can set in-inode attributes;
   the test fails for inodes that have been created before the ea-in-inode
   patch.  Those inodes have (i_extra_isize == 0), so we end up with the
   attributes overlapping the i_extra_isize field.  Checking for
   (i_extra_isize == 0) instead fixes this case.
   
   The EXT3_STATE_XATTR flag is only set if (i_extra_isize > 0) and the inodes
   has in-inode attributes, so that is enough in the first two tests.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2080, 2005-01-25 20:41:47-08:00, agruen@suse.de
   [PATCH] ext3/ea: documentation fix
   
   In-inode xattr entry descriptors are unsorted.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2079, 2005-01-25 20:41:31-08:00, agruen@suse.de
   [PATCH] ext3/ea: set the EXT3_FEATURE_COMPAT_EXT_ATTR for in-inode xattrs
   
   The xattr feature was only set when creating an xattr block. Also set it
   when creating in-inode xattrs.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2078, 2005-01-25 20:41:18-08:00, agruen@suse.de
   [PATCH] ext3/ea: no lock needed when freeing inode
   
   ext3_xattr_delete_inode is called from ext3_free_inode which always has
   exclusive access to the inode, so there is no need to take the xattr
   semaphore.
   
   Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2077, 2005-01-25 20:41:05-08:00, stone_wang@sohu.com
   [PATCH] ext2/ext3: block allocator startup fix
   
   We found strange blocks layout in our mail server, after careful study, we
   got the reason and tried to fix it.
   
   On the very fist attempt to allocate a block to the newly-initialised inode,
   if we are trying to add a block at logical file offset "1" then
   ext2_find_goal() will incorrectly assume that this was a next_alloc_block
   cache hit (because we think the previously-allocated block was at offset
   zero).
   
   Net result: why trying to extend a freshly-opened one-block file we end up
   deciding to place the second file block at disk block "1", rather than going
   off and calling ext2_find_near().
   
   Fix it by checking that we actually do have something valid cached in
   next_alloc_goal.
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2076, 2005-01-25 20:40:51-08:00, klassert@mathematik.tu-chemnitz.de
   [PATCH] 3c59x ethtool: provide NIC-specific stats
   
   With this patch get_ethtool_stats() provides the NIC-specific extra stats. 
   
   Signed-off-by: Steffen Klassert <klassert@mathematik.tu-chemnitz.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2075, 2005-01-25 20:40:34-08:00, bgerst@didntduck.org
   [PATCH] clean up UTS_RELEASE usage
   
   This patch cleans up usage of UTS_RELEASE, by replacing many references
   with system_utsname.release, and deleting others.  This eliminates a
   dependency on version.h for these files, so they don't get rebuilt if
   EXTRAVERSION or localversion change.
   
   Signed-off-by: Brian Gerst <bgerst@didntduck.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2074, 2005-01-25 20:40:18-08:00, hch@lst.de
   [PATCH] kill softirq_pending()
   
   With Steffen Klassert <klassert@mathematik.tu-chemnitz.de>
   
   no more users left, time to kill the various implementations
   
   Signed-off-by: Steffen Klassert <klassert@mathematik.tu-chemnitz.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2073, 2005-01-25 20:40:02-08:00, pavel@ucw.cz
   [PATCH] Enable swsusp on SMP machines
   
   This enables swsusp on SMP machines. It should be working in 2.6.10,
   already (but you may need noapic in 2.6.10).
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2072, 2005-01-25 20:39:48-08:00, pavel@suse.cz
   [PATCH] swsusp: fix buggy comment
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2071, 2005-01-25 20:39:34-08:00, ysato@users.sourceforge.jp
   [PATCH] h8300: makefile update
   
   Fix build error when .config does not exist
   
   Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2070, 2005-01-25 20:39:17-08:00, ysato@users.sourceforge.jp
   [PATCH] h8300: fix warning
   
   update argument type
   
   Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2069, 2005-01-25 20:39:03-08:00, ak@suse.de
   [PATCH] x86_64: Speed up suspend
   
   The following patch speeds up the restoring of swsusp images on x86-64
   and makes the assembly code more readable (tested and works on AMD64).
   
   Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
   
   Changed by AK to not hardcode any C values and get them from offset.h instead
   and not flushing CR3 needlessly (according to Pavel it was just an old
   debugging measure that is not needed anymore)
   
   Signed-off-by: Andi Kleen <ak@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2068, 2005-01-25 20:38:49-08:00, ak@suse.de
   [PATCH] x86_64: Remove earlyprintk help
   
   Remove invisible earlyprintk help.
   
   Signed-off-by: Andi Kleen <ak@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2067, 2005-01-25 20:38:31-08:00, ak@suse.de
   [PATCH] x86_64: Enlarge northbridge numa scan mask
   
   Enlarge max nodes mask in k8 northbridge scan code.
   
   Signed-off-by: Andi Kleen <ak@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2066, 2005-01-25 20:38:18-08:00, ak@suse.de
   [PATCH] x86_64: remove duplicated includes
   
   There's usually no reason for including the same header file twice.
   
   The patch below removes such duplicate includes in x86_64 specific files.
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: Andi Kleen <ak@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2065, 2005-01-25 20:38:01-08:00, ak@suse.de
   [PATCH] x86_64: remove centaur mtrr support
   
   Drop unused centaur mtrr support code.
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: Andi Kleen <ak@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2064, 2005-01-25 20:37:47-08:00, ak@suse.de
   [PATCH] x86: Remove unused function
   
   Remove unused get_cr2 function (from i386)
   
   Signed-off-by: Adrian Bunk <bunk@stusta.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2063, 2005-01-25 20:37:31-08:00, rusty@rustcorp.com.au
   [PATCH] x86: no interrupts from secondary CPUs until officially online
   
   Andi Kleen reported a problem where a very slow boot caused the timer
   interrupt on a secondary CPU to go off before the CPU was actually brought
   up by the core code, so the CPU_PREPARE notifier hadn't been called, so the
   per-cpu timer code wasn't set up.
   
   This was caused by enabling interrupts around calibrate_delay() on
   secondary CPUs, which is not actually neccessary (interrupts on CPU 0
   increments jiffies, which is all that is required).  So delay enabling
   interrupts until the actual __cpu_up() call for that CPU.
   
   Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2062, 2005-01-25 20:37:16-08:00, benh@kernel.crashing.org
   [PATCH] ppc64: Missing call to ioremap in pci_iomap()
   
   This patch adds the missing ioremap call to pci_iomap on ppc64.
   
   Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2061, 2005-01-25 20:37:00-08:00, anton@samba.org
   [PATCH] ppc64: enable virtual ethernet and virtual scsi
   
   Enable the virtual ethernet and virtual scsi drivers in the pseries config.
   Since our root device may be on either we need them compiled in (unless we
   play initrd tricks).
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2060, 2005-01-25 20:36:45-08:00, anton@samba.org
   [PATCH] ppc64: problem disabling SYSVIPC
   
   The kernel wouldnt link when SYSVIPC was disabled.  x86-64 was already
   defining a cond_syscall, instead of duplicating it in the ppc64 port move it
   into the arch specific portion of kernel/sys_ni.c
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2059, 2005-01-25 20:36:29-08:00, anton@samba.org
   [PATCH] ppc64: disable some boot wrapper debug
   
   The debug information in the boot wrapper can be quite verbose (it prints an
   entry for every address it attempts to claim).  Disable it.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2058, 2005-01-25 20:36:14-08:00, anton@samba.org
   [PATCH] ppc64: allow EEH to be disabled
   
   Allow EEH to be disabled for pSeries targets, but only if the EMBEDDED option
   is enabled.  This version incorporates some suggestions from Arnd Bergmann and
   Linas Vepstas.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2057, 2005-01-25 20:35:57-08:00, paulus@samba.org
   [PATCH] ppc64: use kref for device_node refcounting
   
   This patch is from Nathan Lynch <nathanl@austin.ibm.com>.
   
   This changes struct device_node and associated code to use the kref api for
   object refcounting and freeing.  I've given it some testing on pSeries with
   cpu add/remove and verified that the release function works.  The change is
   somewhat cosmetic but it does make the code easier to understand...  at least
   I think so =)
   
   The only real change is that the refcount on all device_nodes is initialized
   at 1, and the device node is freed when the refcount reaches 0 (of_remove_node
   has the extra "put" to ensure that this happens).  This lets us get rid of the
   OF_STALE flag and macros in prom.h.
   
   Signed-off-by: Nathan Lynch <nathanl@austin.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2056, 2005-01-25 20:35:44-08:00, paulus@samba.org
   [PATCH] ppc64: sparse fixes for cpu feature constants
   
   This patch is originally from Nathan Lynch <nathanl@austin.ibm.com>.
   
   Sparse gives a warning "constant ...  is so big it is long" for every
   expression where we check bits in the cur_cpu_spec->cpu_features value.  This
   patch removes the warnings by using the ASM_CONST macro.
   
   Signed-off-by: Nathan Lynch <nathanl@austin.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2055, 2005-01-25 20:35:29-08:00, paulus@samba.org
   [PATCH] ppc64: trivial cleanup: EEH_REGION
   
   This patch is originally from Linas Vepstas <linas@linas.org>.
   
   This is a dumb, dorky cleanup patch: Per last round of emails, the concept of
   EEH_REGION is gone, but a few stubs remained.  This patch removes them.
   
   Signed-off-by: Linas Vepstas <linas@linas.org>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2054, 2005-01-25 20:35:13-08:00, paulus@samba.org
   [PATCH] ppc64: replace schedule_timeout in die
   
   This patch is from Nishanth Aravamudan <nacc@us.ibm.com>.
   
   Replace schedule_timeout() with ssleep to simplify the code and to express the
   delay in seconds instead of HZ.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2053, 2005-01-25 20:34:59-08:00, paulus@samba.org
   [PATCH] ppc64: replace schedule_timeout in __cpu_up
   
   This patch is from Nishanth Aravamudan <nacc@us.ibm.com>.
   
   Replace schedule_timeout() with msleep to simplify the code and to express the
   delay in milliseconds instead of HZ.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2052, 2005-01-25 20:34:42-08:00, paulus@samba.org
   [PATCH] ppc64: replace schedule_timeout in pSeries_cpu_die
   
   This patch is from Nishanth Aravamudan <nacc@us.ibm.com>.
   
   Replace schedule_timeout() with msleep to simplify the code and to express the
   delay in milliseconds instead of HZ.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2051, 2005-01-25 20:34:27-08:00, paulus@samba.org
   [PATCH] ppc64: replace schedule_timeout in iSeries_pci_reset
   
   This patch is from Nishanth Aravamudan <nacc@us.ibm.com>.
   
   Replace schedule_timeout() with msleep to simplify the code and to express the
   delay in milliseconds instead of HZ.
   
   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2050, 2005-01-25 20:34:11-08:00, paulus@samba.org
   [PATCH] ppc64: clear MSR_RI earlier in syscall exit path
   
   This patch is from Craig Chaney <cchaney@us.ibm.com>.
   
   This patch moves the restoring of the stack pointer in the system call exit
   path to after the point where we clear the RI (recoverable interrupt) bit in
   the MSR.  Normally, loading the stack pointer before clearing RI doesn't cause
   any problem because there is no trap that can normally occur in between.  But
   if we are tracing the code using a tool that single-steps instructions, this
   can cause a problem.  In this case, clearing RI serves as an indication that
   the following code can't be safely single-stepped.
   
   Signed-off-by: Craig Chaney <cchaney@us.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2049, 2005-01-25 20:33:57-08:00, paulus@samba.org
   [PATCH] ppc64: fix in_be64 definition
   
   This patch is from Jake Moilanen <moilanen@austin.ibm.com>.
   
   The instruction syntax for the in_be64 inline asm was incorrect for the "m"
   constraint for the address parameter.  This patch fixes the instruction in the
   inline asm.
   
   Signed-off-by: Jake Moilanen <moilanen@austin.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2048, 2005-01-25 20:33:40-08:00, paulus@samba.org
   [PATCH] ppc64: xmon data breakpoints on partitioned systems
   
   This patch is originally from Jake Moilanen <moilanen@austin.ibm.com>,
   substantially modified by me.
   
   On PPC64 systems with a hypervisor, we can't set the Data Address Breakpoint
   Register (DABR) directly, we have to do it through a hypervisor call.
   
   Signed-off-by: Jake Moilanen <moilanen@austin.ibm.com>
   Signed-off-by: Paul Mackerras <paulus@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2047, 2005-01-25 20:33:26-08:00, anton@samba.org
   [PATCH] ppc64: limit segment tables on UP kernels
   
   We were allocating 48 segment tables on UP kernels.  Remove them and save
   192kB of kernel memory on UP builds.
   
   Signed-off-by: Anton Blanchard <anton@samba.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2046, 2005-01-25 20:33:08-08:00, benh@kernel.crashing.org
   [PATCH] ppc32: Add support for Pegasos machines
   
   This patch, mostly from Sven Luther and reworked by me, adds support for
   Pegasos machines to the ppc32 arch. The patch contains all of the arch
   code. I'll send separately a few driver changes as well.
   
   Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2045, 2005-01-25 20:32:53-08:00, galak@freescale.com
   [PATCH] ppc32: fix PCI2 IO space mapping on CDS
   
   The ppc pci bus and resource fixups will automatically adjust the IO space
   mappings by (hose->io_base_virt - isa_io_base).  Since we map all of PCI IO
   space (PCI1 & PCI2) with a single mapping so it is continguious in virtual,
   physical, and PCI IO space the offset will equal MPC85XX_PCI1_IO_SIZE.
   There for we needed to reduce the setting by that amount for everything to
   work properly on CDS.
   
   Signed-off-by: Kumar Gala <kumar.gala@freescale.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2044, 2005-01-25 20:32:37-08:00, rvinson@mvista.com
   [PATCH] ppc32: missing call to ioremap in pci_iomap()
   
   The PPC version of pci_iomap seems to be missing a call to ioremap.  This
   patch corrects that oversight and has been tested on a IBM PPC750FX Eval
   board.
   
   Signed-off-by: Randy Vinson <rvinson@mvista.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2043, 2005-01-25 20:32:23-08:00, galak@freescale.com
   [PATCH] ppc32: allow usage of gen550 on platforms that do not define SERIAL_PORT_DFNS
   
   Allows a platform to initialize serial_state completely from gen550_init
   and no longer requires it to define SERIAL_PORT_DFNS.
   
   Signed-off-by: Kumar Gala <kumar.gala@freescale.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2042, 2005-01-25 20:32:06-08:00, galak@freescale.com
   [PATCH] ppc32: Add defconfigs for 85xx boards -- updated
   
   Adds default config files the MPC8540 ADS, MPC8560 ADS, and MPC8555 CDS
   reference boards.  Hopefully people will stop asking me for mine :)
   
   Signed-off-by: Kumar Gala <kumar.gala@freescale.com>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2041, 2005-01-25 20:31:51-08:00, andrea@suse.de
   [PATCH] mm: truncate SMP race fix
   
   Fix up an smp race introduced in 2.6.11-rc1
   
   Signed-off-by: Andrea Arcangeli <andrea@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2040, 2005-01-25 20:31:34-08:00, andrea@suse.de
   [PATCH] mm: adjust dirty threshold for lowmem-only mappings
   
   With Rik van Riel <riel@redhat.com>
   
   Simply running "dd if=/dev/zero of=/dev/hd<one you can miss>" can cause
   excessive amounts of dirty lowmem pagecache, due to the blockdev's
   non-highmem page allocation strategy.
   
   This patch effectively lowers the dirty limit for mappings which cannot be
   cached in highmem, counting the dirty limit as a percentage of lowmem
   instead.  This should prevent heavy block device writers from pushing the
   VM over the edge and triggering OOM kills.
   
   Signed-off-by: Rik van Riel <riel@redhat.com>
   Acked-by: Andrea Arcangeli <andrea@suse.de>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2039, 2005-01-25 20:31:20-08:00, chrisw@osdl.org
   [PATCH] compat ioctl security hook fixup
   
   Fix a bug spotted by "Michael S. Tsirkin" <mst@mellanox.co.il>
   
   Introduce a simple helper, vfs_ioctl(), so that both sys_ioctl() and
   compat_sys_ioctl() call the security hook in all cases and without
   duplication.
   
   Signed-off-by: Chris Wright <chrisw@osdl.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2038, 2005-01-25 20:31:01-08:00, amgta@yacht.ocn.ne.jp
   [PATCH] oprofile: falling back on timer interrupt mode
   
   When some hardware setups or architectures do not allow OProfile to use
   performance counters, OProfile operates in timer mode.
   
   But, from 2.6.11-rc1, we need to specify the module parameter "timer=1" to
   work on timer interrupt mode.  Change things so that we detect the absence of
   the high-resolution timer and fall back to timer-based profiling
   automatically.
   
   Furthermore we can easily get oops by reading /dev/oprofile/cpu_type.
   
   Signed-off-by: Akinobu Mita <amgta@yacht.ocn.ne.jp>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2037, 2005-01-25 20:30:47-08:00, yuasa@hh.iij4u.or.jp
   [PATCH] mips: fixed conflicting types
   
   arch/mips/lib/csum_partial_copy.c:21: error: conflicting types for `csum_partial_copy_nocheck'
   include/asm/checksum.h:65: error: previous declaration of `csum_partial_copy_nocheck'
   arch/mips/lib/csum_partial_copy.c:38: error: conflicting types for `csum_partial_copy_from_user'
   include/asm/checksum.h:38: error: previous declaration of `csum_partial_copy_from_user'
   make[1]: *** [arch/mips/lib/csum_partial_copy.o] Error 1
   make: *** [arch/mips/lib] Error 2
   
   Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2036, 2005-01-25 20:30:29-08:00, js@linuxtv.org
   [PATCH] DVB linkage fix
   
   We have two global variables called "debug".
   
   The attached patch cleans up various aspects of dibusb module argument
   handling, so it's a bit larger than just renaming "debug".
   
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2035, 2005-01-25 20:30:15-08:00, akpm@osdl.org
   [PATCH] dib3000mc build fix
   
   - Build fix for older gcc's
   
   - Don't typecast when assigning between void*'s and other pointers.
   
   cc: <js@linuxtv.org>
   Signed-off-by: Andrew Morton <akpm@osdl.org>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2034, 2005-01-25 20:29:47-08:00, torvalds@ppc970.osdl.org
   Add 'f_maxcount' to allow filesystems to set a per-file maximum IO size.
 
 ChangeSet@1.2033, 2005-01-25 15:00:33-08:00, torvalds@ppc970.osdl.org
   Rename "locks_verify_area()" to "rw_verify_area()" and clean up the
   arguments.
   
   And make it non-inlined.
 
 ChangeSet@1.2032, 2005-01-25 12:49:07-08:00, greg@kroah.com
   [PATCH] Modules: Allow sysfs module parameters to be written to.
   
   This fixes a bug in the current tree preventing the sysfs module
   parameters from being able to be changed at all from userspace.  It's as
   if someone just forgot to write this function...
   
   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.2031, 2005-01-25 08:03:42-08:00, geert@linux-m68k.org
   [PATCH] m68k csum_partial_copy_* gcc4 warning fixes
   
   The gcc4 signedness warning fix forgot to update the declarations in
   include/asm-m68k/checksum.h.
 
 ChangeSet@1.2030, 2005-01-25 08:01:03-08:00, ecashin@coraid.com
   [PATCH] AOE: fix up the block device registration so that it actually works
   
   Remove __exit from aoeblk_exit (to allow it to be called from __init code).
   
   Remove register_blkdev into aoe_init (it's done in aoemain.c).
   
   Signed-off-by: Ed L. Cashin <ecashin@coraid.com>
   Signed-off-by: Linus Torvalds <torvalds@osdl.org>
 
 ChangeSet@1.1983.6.1, 2005-01-25 10:10:51+00:00, aia21@cantab.net
   NTFS: Add printk rate limiting for ntfs_warning() and ntfs_error() when
         compiled without debug.  This avoids a possible denial of service
         attack.  Thanks to Carl-Daniel Hailfinger from SuSE for pointing this
         out.
 
diff -purN linux-2.6.11-rc2-bk3/Documentation/infiniband/user_mad.txt linux-2.6.11-rc2-bk4/Documentation/infiniband/user_mad.txt
--- linux-2.6.11-rc2-bk3/Documentation/infiniband/user_mad.txt	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/Documentation/infiniband/user_mad.txt	2005-01-26 15:43:25.863452379 +0100
@@ -2,9 +2,10 @@ USERSPACE MAD ACCESS
 
 Device files
 
-  Each port of each InfiniBand device has a "umad" device attached.
-  For example, a two-port HCA will have two devices, while a switch
-  will have one device (for switch port 0).
+  Each port of each InfiniBand device has a "umad" device and an
+  "issm" device attached.  For example, a two-port HCA will have two
+  umad devices and two issm devices, while a switch will have one
+  device of each type (for switch port 0).
 
 Creating MAD agents
 
@@ -63,19 +64,36 @@ Sending MADs
 	if (ret != sizeof mad)
 		perror("write");
 
+Setting IsSM Capability Bit
+
+  To set the IsSM capability bit for a port, simply open the
+  corresponding issm device file.  If the IsSM bit is already set,
+  then the open call will block until the bit is cleared (or return
+  immediately with errno set to EAGAIN if the O_NONBLOCK flag is
+  passed to open()).  The IsSM bit will be cleared when the issm file
+  is closed.  No read, write or other operations can be performed on
+  the issm file.
+
 /dev files
 
   To create the appropriate character device files automatically with
   udev, a rule like
 
     KERNEL="umad*", NAME="infiniband/%k"
+    KERNEL="issm*", NAME="infiniband/%k"
 
-  can be used.  This will create a device node named
+  can be used.  This will create device nodes named
 
     /dev/infiniband/umad0
+    /dev/infiniband/issm0
 
   for the first port, and so on.  The InfiniBand device and port
-  associated with this device can be determined from the files
+  associated with these devices can be determined from the files
 
     /sys/class/infiniband_mad/umad0/ibdev
     /sys/class/infiniband_mad/umad0/port
+
+  and
+
+    /sys/class/infiniband_mad/issm0/ibdev
+    /sys/class/infiniband_mad/issm0/port
diff -purN linux-2.6.11-rc2-bk3/Documentation/ioctl-number.txt linux-2.6.11-rc2-bk4/Documentation/ioctl-number.txt
--- linux-2.6.11-rc2-bk3/Documentation/ioctl-number.txt	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/Documentation/ioctl-number.txt	2005-01-26 15:43:25.864452223 +0100
@@ -146,7 +146,7 @@ Code	Seq#	Include File		Comments
 'p'	40-7F	linux/nvram.h
 'p'	80-9F				user-space parport
 					<mailto:tim@cyberelk.net>
-'q'	00-1F	linux/videotext.h	conflict!
+'q'	00-1F	linux/serio.h
 'q'	80-FF				Internet PhoneJACK, Internet LineJACK
 					<http://www.quicknet.net>
 'r'	00-1F	linux/msdos_fs.h
@@ -164,6 +164,7 @@ Code	Seq#	Include File		Comments
 'z'	40-7F				CAN bus card
 					<mailto:oe@port.de>
 0x80	00-1F	linux/fb.h
+0x81	00-1F	linux/videotext.h
 0x89	00-06	asm-i386/sockios.h
 0x89	0B-DF	linux/sockios.h
 0x89	E0-EF	linux/sockios.h		SIOCPROTOPRIVATE range
diff -purN linux-2.6.11-rc2-bk3/Documentation/kernel-parameters.txt linux-2.6.11-rc2-bk4/Documentation/kernel-parameters.txt
--- linux-2.6.11-rc2-bk3/Documentation/kernel-parameters.txt	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/Documentation/kernel-parameters.txt	2005-01-26 15:43:25.866451911 +0100
@@ -1099,6 +1099,9 @@ running once the system is up.
 
 	root=		[KNL] Root filesystem
 
+	rootdelay=	[KNL] Delay (in seconds) to pause before attempting to
+			mount the root filesystem
+
 	rootflags=	[KNL] Set root filesystem mount option string
 
 	rootfstype=	[KNL] Set root filesystem type
diff -purN linux-2.6.11-rc2-bk3/Documentation/vm/hugetlbpage.txt linux-2.6.11-rc2-bk4/Documentation/vm/hugetlbpage.txt
--- linux-2.6.11-rc2-bk3/Documentation/vm/hugetlbpage.txt	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc2-bk4/Documentation/vm/hugetlbpage.txt	2005-01-26 15:43:25.869451444 +0100
@@ -1,8 +1,8 @@
 
 The intent of this file is to give a brief summary of hugetlbpage support in
 the Linux kernel.  This support is built on top of multiple page size support
-that is provided by most modern architectures.  For example, IA-32
-architecture supports 4K and 4M (2M in PAE mode) page sizes, IA-64
+that is provided by most modern architectures.  For example, i386
+architecture supports 4K and 4M (2M in PAE mode) page sizes, ia64
 architecture supports multiple page sizes 4K, 8K, 64K, 256K, 1M, 4M, 16M,
 256M and ppc64 supports 4K and 16M.  A TLB is a cache of virtual-to-physical
 translations.  Typically this is a very scarce resource on processor.
@@ -107,10 +107,10 @@ mount of filesystem will be required for
  * SHM_HUGETLB in the shmget system call to inform the kernel that it is
  * requesting hugepages.
  *
- * For the IA-64 architecture, the Linux kernel reserves Region number 4 for
+ * For the ia64 architecture, the Linux kernel reserves Region number 4 for
  * hugepages.  That means the addresses starting with 0x800000... will need
  * to be specified.  Specifying a fixed address is not required on ppc64,
- * i386 or amd64.
+ * i386 or x86_64.
  *
  * Note: The default shared memory limit is quite low on many kernels,
  * you may need to increase it via:
@@ -139,8 +139,8 @@ mount of filesystem will be required for
 
 #define dprintf(x)  printf(x)
 
-/* Only IA64 requires this */
-#ifdef IA64
+/* Only ia64 requires this */
+#ifdef __ia64__
 #define ADDR (void *)(0x8000000000000000UL)
 #define SHMAT_FLAGS (SHM_RND)
 #else
@@ -204,10 +204,10 @@ int main(void)
  * example, the app is requesting memory of size 256MB that is backed by
  * huge pages.
  *
- * For IA-64 architecture, Linux kernel reserves Region number 4 for hugepages.
+ * For ia64 architecture, Linux kernel reserves Region number 4 for hugepages.
  * That means the addresses starting with 0x800000... will need to be
  * specified.  Specifying a fixed address is not required on ppc64, i386
- * or amd64.
+ * or x86_64.
  */
 #include <stdlib.h>
 #include <stdio.h>
@@ -219,8 +219,8 @@ int main(void)
 #define LENGTH (256UL*1024*1024)
 #define PROTECTION (PROT_READ | PROT_WRITE)
 
-/* Only IA64 requires this */
-#ifdef IA64
+/* Only ia64 requires this */
+#ifdef __ia64__
 #define ADDR (void *)(0x8000000000000000UL)
 #define FLAGS (MAP_SHARED | MAP_FIXED)
 #else
diff -purN linux-2.6.11-rc2-bk3/MAINTAINERS linux-2.6.11-rc2-bk4/MAINTAINERS
--- linux-2.6.11-rc2-bk3/MAINTAINERS	2005-01-22 02:48:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/MAINTAINERS	2005-01-26 15:43:25.873450820 +0100
@@ -283,8 +283,8 @@ M:	john@dnsworld.co.uk
 S:	Maintained
 
 ARM MFM AND FLOPPY DRIVERS
-P:	Dave Gilbert
-M:	linux@treblig.org
+P:	Ian Molton
+M:	spyro@f2s.com
 S:	Maintained
 
 ARM/CORGI MACHINE SUPPORT
diff -purN linux-2.6.11-rc2-bk3/Makefile linux-2.6.11-rc2-bk4/Makefile
--- linux-2.6.11-rc2-bk3/Makefile	2005-01-26 15:42:47.404584132 +0100
+++ linux-2.6.11-rc2-bk4/Makefile	2005-01-26 15:43:25.875450509 +0100
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION = -rc2-bk3
+EXTRAVERSION = -rc2-bk4
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
@@ -331,7 +331,7 @@ KALLSYMS	= scripts/kallsyms
 PERL		= perl
 CHECK		= sparse
 
-NOSTDINC_FLAGS := -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+NOSTDINC_FLAGS  = -nostdinc -isystem $(shell $(CC) -print-file-name=include)
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 MODFLAGS	= -DMODULE
diff -purN linux-2.6.11-rc2-bk3/arch/alpha/oprofile/common.c linux-2.6.11-rc2-bk4/arch/alpha/oprofile/common.c
--- linux-2.6.11-rc2-bk3/arch/alpha/oprofile/common.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/alpha/oprofile/common.c	2005-01-26 15:43:25.877450197 +0100
@@ -138,7 +138,7 @@ op_axp_create_files(struct super_block *
 	return 0;
 }
 
-void __init
+int __init
 oprofile_arch_init(struct oprofile_operations *ops)
 {
 	struct op_axp_model *lmodel = NULL;
@@ -166,7 +166,7 @@ oprofile_arch_init(struct oprofile_opera
 	}
 
 	if (!lmodel)
-		return;
+		return -ENODEV;
 	model = lmodel;
 
 	ops->create_files = op_axp_create_files;
@@ -178,6 +178,8 @@ oprofile_arch_init(struct oprofile_opera
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       lmodel->cpu_type);
+
+	return 0;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/arch/arm/oprofile/common.c linux-2.6.11-rc2-bk4/arch/arm/oprofile/common.c
--- linux-2.6.11-rc2-bk3/arch/arm/oprofile/common.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/arm/oprofile/common.c	2005-01-26 15:43:25.885448950 +0100
@@ -105,12 +105,13 @@ static void pmu_stop(void)
 	up(&pmu_sem);
 }
 
-void __init pmu_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
+int __init
+pmu_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
 {
 	init_MUTEX(&pmu_sem);
 
 	if (spec->init() < 0)
-		return;
+		return -ENODEV;
 
 	pmu_model = spec;
 	init_driverfs();
@@ -121,6 +122,8 @@ void __init pmu_init(struct oprofile_ope
 	ops->stop = pmu_stop;
 	ops->cpu_type = pmu_model->name;
 	printk(KERN_INFO "oprofile: using %s PMU\n", spec->name);
+
+	return 0;
 }
 
 void pmu_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/arm/oprofile/init.c linux-2.6.11-rc2-bk4/arch/arm/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/arm/oprofile/init.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/arm/oprofile/init.c	2005-01-26 15:43:25.886448794 +0100
@@ -12,11 +12,15 @@
 #include <linux/errno.h>
 #include "op_arm_model.h"
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
+	int ret = -ENODEV;
+
 #ifdef CONFIG_CPU_XSCALE
-	pmu_init(ops, &op_xscale_spec);
+	ret = pmu_init(ops, &op_xscale_spec);
 #endif
+
+	return ret;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/h8300/Makefile linux-2.6.11-rc2-bk4/arch/h8300/Makefile
--- linux-2.6.11-rc2-bk3/arch/h8300/Makefile	2005-01-22 02:47:17.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/h8300/Makefile	2005-01-26 15:43:25.887448639 +0100
@@ -7,9 +7,6 @@
 #
 # (C) Copyright 2002,2003 Yoshinori Sato <ysato@users.sourceforge.jp>
 #
-ifndef include-config
--include $(TOPDIR)/.config
-endif
 
 platform-$(CONFIG_CPU_H8300H)	:= h8300h
 platform-$(CONFIG_CPU_H8S)	:= h8s
@@ -47,9 +44,11 @@ LIBGCC := $(shell $(CROSS-COMPILE)$(CC) 
 head-y := arch/$(ARCH)/platform/$(platform-y)/$(board-y)/crt0_$(model-y).o
 
 core-y	+= arch/$(ARCH)/kernel/ \
-	   arch/$(ARCH)/mm/ \
-	   arch/$(ARCH)/platform/$(PLATFORM)/ \
+	   arch/$(ARCH)/mm/
+ifdef PLATFORM
+core-y	+= arch/$(ARCH)/platform/$(PLATFORM)/ \
 	   arch/$(ARCH)/platform/$(PLATFORM)/$(BOARD)/
+endif
 
 libs-y	+= arch/$(ARCH)/lib/ $(LIBGCC)
 
diff -purN linux-2.6.11-rc2-bk3/arch/i386/kernel/apic.c linux-2.6.11-rc2-bk4/arch/i386/kernel/apic.c
--- linux-2.6.11-rc2-bk3/arch/i386/kernel/apic.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/i386/kernel/apic.c	2005-01-26 15:43:25.889448327 +0100
@@ -1046,9 +1046,7 @@ void __init setup_boot_APIC_clock(void)
 
 void __init setup_secondary_APIC_clock(void)
 {
-	local_irq_disable(); /* FIXME: Do we need this? --RR */
 	setup_APIC_timer(calibration_result);
-	local_irq_enable();
 }
 
 void __init disable_APIC_timer(void)
diff -purN linux-2.6.11-rc2-bk3/arch/i386/kernel/smpboot.c linux-2.6.11-rc2-bk4/arch/i386/kernel/smpboot.c
--- linux-2.6.11-rc2-bk3/arch/i386/kernel/smpboot.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/i386/kernel/smpboot.c	2005-01-26 15:43:25.893447704 +0100
@@ -383,8 +383,6 @@ void __init smp_callin(void)
 	setup_local_APIC();
 	map_cpu_to_logical_apicid();
 
-	local_irq_enable();
-
 	/*
 	 * Get our bogomips.
 	 */
@@ -397,7 +395,7 @@ void __init smp_callin(void)
  	smp_store_cpu_info(cpuid);
 
 	disable_APIC_timer();
-	local_irq_disable();
+
 	/*
 	 * Allow the master to continue.
 	 */
@@ -439,6 +437,10 @@ static void __init start_secondary(void 
 	 */
 	local_flush_tlb();
 	cpu_set(smp_processor_id(), cpu_online_map);
+
+	/* We can take interrupts now: we're officially "up". */
+	local_irq_enable();
+
 	wmb();
 	cpu_idle();
 }
diff -purN linux-2.6.11-rc2-bk3/arch/i386/oprofile/init.c linux-2.6.11-rc2-bk4/arch/i386/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/i386/oprofile/init.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/i386/oprofile/init.c	2005-01-26 15:43:25.899446769 +0100
@@ -21,7 +21,7 @@ extern void nmi_exit(void);
 extern void x86_backtrace(struct pt_regs * const regs, unsigned int depth);
 
 
-void __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations * ops)
 {
 	int ret;
 
@@ -35,6 +35,8 @@ void __init oprofile_arch_init(struct op
 		ret = nmi_timer_init(ops);
 #endif
 	ops->backtrace = x86_backtrace;
+
+	return ret;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/arch/ia64/ia32/sys_ia32.c linux-2.6.11-rc2-bk4/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.11-rc2-bk3/arch/ia64/ia32/sys_ia32.c	2005-01-26 15:42:47.430580080 +0100
+++ linux-2.6.11-rc2-bk4/arch/ia64/ia32/sys_ia32.c	2005-01-26 15:43:25.909445210 +0100
@@ -1973,10 +1973,10 @@ struct sysctl32 {
 	unsigned int	__unused[4];
 };
 
+#ifdef CONFIG_SYSCTL
 asmlinkage long
 sys32_sysctl (struct sysctl32 __user *args)
 {
-#ifdef CONFIG_SYSCTL
 	struct sysctl32 a32;
 	mm_segment_t old_fs = get_fs ();
 	void __user *oldvalp, *newvalp;
@@ -2015,10 +2015,8 @@ sys32_sysctl (struct sysctl32 __user *ar
 		return -EFAULT;
 
 	return ret;
-#else
-	return -ENOSYS;
-#endif
 }
+#endif
 
 asmlinkage long
 sys32_newuname (struct new_utsname __user *name)
diff -purN linux-2.6.11-rc2-bk3/arch/ia64/oprofile/init.c linux-2.6.11-rc2-bk4/arch/ia64/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/ia64/oprofile/init.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ia64/oprofile/init.c	2005-01-26 15:43:25.947439288 +0100
@@ -16,13 +16,17 @@ extern int perfmon_init(struct oprofile_
 extern void perfmon_exit(void);
 extern void ia64_backtrace(struct pt_regs * const regs, unsigned int depth);
 
-void __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations * ops)
 {
+	int ret = -ENODEV;
+
 #ifdef CONFIG_PERFMON
 	/* perfmon_init() can fail, but we have no way to report it */
-	perfmon_init(ops);
+	ret = perfmon_init(ops);
 #endif
 	ops->backtrace = ia64_backtrace;
+
+	return ret;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/arch/m32r/oprofile/init.c linux-2.6.11-rc2-bk4/arch/m32r/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/m32r/oprofile/init.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/m32r/oprofile/init.c	2005-01-26 15:43:25.963436795 +0100
@@ -12,8 +12,9 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 
-void __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations * ops)
 {
+	return -ENODEV;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/mips/kernel/linux32.c linux-2.6.11-rc2-bk4/arch/mips/kernel/linux32.c
--- linux-2.6.11-rc2-bk3/arch/mips/kernel/linux32.c	2005-01-22 02:48:27.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/mips/kernel/linux32.c	2005-01-26 15:43:25.966436327 +0100
@@ -468,8 +468,7 @@ asmlinkage ssize_t sys32_pread(unsigned 
 	if (!(file->f_mode & FMODE_READ))
 		goto out;
 	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
-				file, pos, count);
+	ret = rw_verify_area(READ, file, &pos, count);
 	if (ret)
 		goto out;
 	ret = -EINVAL;
@@ -504,8 +503,7 @@ asmlinkage ssize_t sys32_pwrite(unsigned
 	if (!(file->f_mode & FMODE_WRITE))
 		goto out;
 	pos = merge_64(a4, a5);
-	ret = locks_verify_area(FLOCK_VERIFY_WRITE, file->f_dentry->d_inode,
-				file, pos, count);
+	ret = rw_verify_area(WRITE, file, &pos, count);
 	if (ret)
 		goto out;
 	ret = -EINVAL;
@@ -1194,13 +1192,6 @@ asmlinkage long sys32_sysctl(struct sysc
 	return error;
 }
 
-#else /* CONFIG_SYSCTL */
-
-asmlinkage long sys32_sysctl(struct sysctl_args32 *args)
-{
-	return -ENOSYS;
-}
-
 #endif /* CONFIG_SYSCTL */
 
 asmlinkage long sys32_newuname(struct new_utsname * name)
diff -purN linux-2.6.11-rc2-bk3/arch/mips/lib/csum_partial_copy.c linux-2.6.11-rc2-bk4/arch/mips/lib/csum_partial_copy.c
--- linux-2.6.11-rc2-bk3/arch/mips/lib/csum_partial_copy.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/mips/lib/csum_partial_copy.c	2005-01-26 15:43:25.967436171 +0100
@@ -16,7 +16,7 @@
 /*
  * copy while checksumming, otherwise like csum_partial
  */
-unsigned int csum_partial_copy_nocheck(const char *src, char *dst,
+unsigned int csum_partial_copy_nocheck(const unsigned char *src, unsigned char *dst,
 	int len, unsigned int sum)
 {
 	/*
@@ -33,7 +33,7 @@ unsigned int csum_partial_copy_nocheck(c
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
  */
-unsigned int csum_partial_copy_from_user (const char *src, char *dst,
+unsigned int csum_partial_copy_from_user (const unsigned char *src, unsigned char *dst,
 	int len, unsigned int sum, int *err_ptr)
 {
 	int missing;
diff -purN linux-2.6.11-rc2-bk3/arch/parisc/kernel/sys_parisc32.c linux-2.6.11-rc2-bk4/arch/parisc/kernel/sys_parisc32.c
--- linux-2.6.11-rc2-bk3/arch/parisc/kernel/sys_parisc32.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/parisc/kernel/sys_parisc32.c	2005-01-26 15:43:25.968436015 +0100
@@ -165,12 +165,6 @@ asmlinkage long sys32_sysctl(struct __sy
 	return error;
 }
 
-#else /* CONFIG_SYSCTL */
-
-asmlinkage long sys32_sysctl(struct __sysctl_args *args)
-{
-	return -ENOSYS;
-}
 #endif /* CONFIG_SYSCTL */
 
 asmlinkage long sys32_sched_rr_get_interval(pid_t pid,
diff -purN linux-2.6.11-rc2-bk3/arch/parisc/oprofile/init.c linux-2.6.11-rc2-bk4/arch/parisc/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/parisc/oprofile/init.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/parisc/oprofile/init.c	2005-01-26 15:43:25.970435704 +0100
@@ -12,8 +12,9 @@
 #include <linux/kernel.h>
 #include <linux/oprofile.h>
 
-void __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations * ops)
 {
+	return -ENODEV;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8540_ads_defconfig linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8540_ads_defconfig
--- linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8540_ads_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8540_ads_defconfig	2005-01-26 15:43:25.977434613 +0100
@@ -0,0 +1,707 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1
+# Thu Jan 20 01:23:13 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+# CONFIG_EPOLL is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_PPC_GEN550=y
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+CONFIG_MPC8540_ADS=y
+# CONFIG_MPC8555_CDS is not set
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+CONFIG_MPC8540=y
+
+#
+# Platform options
+#
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_PCI_NAMES=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+CONFIG_GIANFAR=y
+CONFIG_GFAR_NAPI=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8555_cds_defconfig linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8555_cds_defconfig
--- linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8555_cds_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8555_cds_defconfig	2005-01-26 15:43:25.982433834 +0100
@@ -0,0 +1,718 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1
+# Thu Jan 20 01:25:35 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+# CONFIG_EPOLL is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_PPC_GEN550=y
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+CONFIG_MPC8555_CDS=y
+# CONFIG_MPC8560_ADS is not set
+# CONFIG_SBC8560 is not set
+CONFIG_MPC8555=y
+CONFIG_85xx_PCI2=y
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_PCI_NAMES=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+CONFIG_GIANFAR=y
+CONFIG_GFAR_NAPI=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_CPM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+# CONFIG_SCC_ENET is not set
+# CONFIG_FEC_ENET is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_KGDB_CONSOLE is not set
+# CONFIG_SERIAL_TEXT_DEBUG is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8560_ads_defconfig linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8560_ads_defconfig
--- linux-2.6.11-rc2-bk3/arch/ppc/configs/mpc8560_ads_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/configs/mpc8560_ads_defconfig	2005-01-26 15:43:25.988432899 +0100
@@ -0,0 +1,719 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1
+# Thu Jan 20 01:24:56 2005
+#
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+CONFIG_FUTEX=y
+# CONFIG_EPOLL is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+# CONFIG_POWER4 is not set
+# CONFIG_8xx is not set
+CONFIG_E500=y
+CONFIG_BOOKE=y
+CONFIG_FSL_BOOKE=y
+CONFIG_SPE=y
+CONFIG_MATH_EMULATION=y
+# CONFIG_CPU_FREQ is not set
+CONFIG_85xx=y
+CONFIG_PPC_INDIRECT_PCI_BE=y
+
+#
+# Freescale 85xx options
+#
+# CONFIG_MPC8540_ADS is not set
+# CONFIG_MPC8555_CDS is not set
+CONFIG_MPC8560_ADS=y
+# CONFIG_SBC8560 is not set
+CONFIG_MPC8560=y
+
+#
+# Platform options
+#
+CONFIG_CPM2=y
+# CONFIG_PC_KEYBOARD is not set
+# CONFIG_SMP is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_PCI_NAMES=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# Advanced setup
+#
+# CONFIG_ADVANCED_OPTIONS is not set
+
+#
+# Default settings for advanced configuration options are used
+#
+CONFIG_HIGHMEM_START=0xfe000000
+CONFIG_LOWMEM_SIZE=0x30000000
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+CONFIG_GIANFAR=y
+CONFIG_GFAR_NAPI=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_CPM=y
+CONFIG_SERIAL_CPM_CONSOLE=y
+CONFIG_SERIAL_CPM_SCC1=y
+# CONFIG_SERIAL_CPM_SCC2 is not set
+# CONFIG_SERIAL_CPM_SCC3 is not set
+CONFIG_SERIAL_CPM_SCC4=y
+# CONFIG_SERIAL_CPM_SMC1 is not set
+# CONFIG_SERIAL_CPM_SMC2 is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+CONFIG_I2C_MPC=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+# CONFIG_SCC_ENET is not set
+# CONFIG_FEC_ENET is not set
+
+#
+# CPM2 Options
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_KGDB_CONSOLE is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/kernel/pci.c linux-2.6.11-rc2-bk4/arch/ppc/kernel/pci.c
--- linux-2.6.11-rc2-bk3/arch/ppc/kernel/pci.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/kernel/pci.c	2005-01-26 15:43:25.991432431 +0100
@@ -1712,7 +1712,11 @@ void __iomem *pci_iomap(struct pci_dev *
 	if (flags & IORESOURCE_IO)
 		return ioport_map(start, len);
 	if (flags & IORESOURCE_MEM)
-		return (void __iomem *) start;
+		/* Not checking IORESOURCE_CACHEABLE because PPC does
+		 * not currently distinguish between ioremap and
+		 * ioremap_nocache.
+		 */
+		return ioremap(start, len);
 	/* What? */
 	return NULL;
 }
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/platforms/85xx/mpc85xx_cds_common.h linux-2.6.11-rc2-bk4/arch/ppc/platforms/85xx/mpc85xx_cds_common.h
--- linux-2.6.11-rc2-bk3/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2005-01-22 02:47:17.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/platforms/85xx/mpc85xx_cds_common.h	2005-01-26 15:43:25.993432119 +0100
@@ -60,8 +60,10 @@
 #define MPC85XX_PCI1_IO_SIZE         0x01000000
 
 /* PCI 2 memory map */
-#define MPC85XX_PCI2_LOWER_IO        0x01000000
-#define MPC85XX_PCI2_UPPER_IO        0x01ffffff
+/* Note: the standard PPC fixups will cause IO space to get bumped by
+ * hose->io_base_virt - isa_io_base => MPC85XX_PCI1_IO_SIZE */
+#define MPC85XX_PCI2_LOWER_IO        0x00000000
+#define MPC85XX_PCI2_UPPER_IO        0x00ffffff
 
 #define MPC85XX_PCI2_LOWER_MEM       0xa0000000
 #define MPC85XX_PCI2_UPPER_MEM       0xbfffffff
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_pci.c linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_pci.c
--- linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_pci.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_pci.c	2005-01-26 15:43:25.995431808 +0100
@@ -97,8 +97,10 @@ int __chrp
 rtas_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		 int len, u32 *val)
 {
+	struct pci_controller *hose = bus->sysdata;
 	unsigned long addr = (offset & 0xff) | ((devfn & 0xff) << 8)
-		| ((bus->number & 0xff) << 16);
+		| (((bus->number - hose->first_busno) & 0xff) << 16)
+		| (hose->index << 24);
         unsigned long ret = ~0UL;
 	int rval;
 
@@ -111,8 +113,10 @@ int __chrp
 rtas_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		  int len, u32 val)
 {
+	struct pci_controller *hose = bus->sysdata;
 	unsigned long addr = (offset & 0xff) | ((devfn & 0xff) << 8)
-		| ((bus->number & 0xff) << 16);
+		| (((bus->number - hose->first_busno) & 0xff) << 16)
+		| (hose->index << 24);
 	int rval;
 
 	rval = call_rtas("write-pci-config", 3, 1, NULL, addr, len, val);
@@ -186,6 +190,22 @@ setup_python(struct pci_controller *hose
 	iounmap(reg);
 }
 
+/* Marvell Discovery II based Pegasos 2 */
+static void __init setup_peg2(struct pci_controller *hose, struct device_node *dev)
+{
+	struct device_node *root = find_path_device("/");
+	struct device_node *rtas;
+
+	rtas = of_find_node_by_name (root, "rtas");
+	if (rtas) {
+		hose->ops = &rtas_pci_ops;
+	} else {
+		printk ("RTAS supporting Pegasos OF not found, please upgrade"
+			" your firmware\n");
+	}
+	pci_assign_all_busses = 1;
+}
+
 void __init
 chrp_find_bridges(void)
 {
@@ -195,7 +215,7 @@ chrp_find_bridges(void)
 	struct pci_controller *hose;
 	unsigned int *dma;
 	char *model, *machine;
-	int is_longtrail = 0, is_mot = 0;
+	int is_longtrail = 0, is_mot = 0, is_pegasos = 0;
 	struct device_node *root = find_path_device("/");
 
 	/*
@@ -207,6 +227,10 @@ chrp_find_bridges(void)
 	if (machine != NULL) {
 		is_longtrail = strncmp(machine, "IBM,LongTrail", 13) == 0;
 		is_mot = strncmp(machine, "MOT", 3) == 0;
+		if (strncmp(machine, "Pegasos2", 8) == 0)
+			is_pegasos = 2;
+		else if (strncmp(machine, "Pegasos", 7) == 0)
+			is_pegasos = 1;
 	}
 	for (dev = root->child; dev != NULL; dev = dev->sibling) {
 		if (dev->type == NULL || strcmp(dev->type, "pci") != 0)
@@ -257,6 +281,10 @@ chrp_find_bridges(void)
 			hose->ops = &gg2_pci_ops;
 			hose->cfg_data = p;
 			gg2_pci_config_base = p;
+		} else if (is_pegasos == 1) {
+			setup_indirect_pci(hose, 0xfec00cf8, 0xfee00cfc);
+		} else if (is_pegasos == 2) {
+			setup_peg2(hose, dev);
 		} else {
 			printk("No methods for %s (model %s), using RTAS\n",
 			       dev->full_name, model);
@@ -275,5 +303,7 @@ chrp_find_bridges(void)
 		}
 	}
 
-	ppc_md.pcibios_fixup = chrp_pcibios_fixup;
+	/* Do not fixup interrupts from OF tree on pegasos */
+	if (is_pegasos != 0)
+		ppc_md.pcibios_fixup = chrp_pcibios_fixup;
 }
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_setup.c linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_setup.c
--- linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_setup.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_setup.c	2005-01-26 15:43:25.998431340 +0100
@@ -37,6 +37,7 @@
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
 #include <linux/initrd.h>
+#include <linux/module.h>
 
 #include <asm/io.h>
 #include <asm/pgtable.h>
@@ -68,6 +69,9 @@ void btext_progress(char *, unsigned sho
 extern unsigned long pmac_find_end_of_memory(void);
 extern int of_show_percpuinfo(struct seq_file *, int);
 
+int _chrp_type;
+EXPORT_SYMBOL(_chrp_type);
+
 /*
  * XXX this should be in xmon.h, but putting it there means xmon.h
  * has to include <linux/interrupt.h> (to get irqreturn_t), which
@@ -214,8 +218,33 @@ static void __init sio_init(void)
 }
 
 
-void __init
-chrp_setup_arch(void)
+static void __init pegasos_set_l2cr(void)
+{
+	struct device_node *np;
+
+	/* On Pegasos, enable the l2 cache if needed, as the OF forgets it */
+	if (_chrp_type != _CHRP_Pegasos)
+		return;
+
+	/* Enable L2 cache if needed */
+	np = find_type_devices("cpu");
+	if (np != NULL) {
+		unsigned int *l2cr = (unsigned int *)
+			get_property (np, "l2cr", NULL);
+		if (l2cr == NULL) {
+			printk ("Pegasos l2cr : no cpu l2cr property found\n");
+			return;
+		}
+		if (!((*l2cr) & 0x80000000)) {
+			printk ("Pegasos l2cr : L2 cache was not active, "
+				"activating\n");
+			_set_L2CR(0);
+			_set_L2CR((*l2cr) | 0x80000000);
+		}
+	}
+}
+
+void __init chrp_setup_arch(void)
 {
 	struct device_node *device;
 
@@ -232,6 +261,9 @@ chrp_setup_arch(void)
 #endif
 		ROOT_DEV = Root_SDA2; /* sda2 (sda1 is for the kernel) */
 
+	/* On pegasos, enable the L2 cache if not already done by OF */
+	pegasos_set_l2cr();
+
 	/* Lookup PCI host bridges */
 	chrp_find_bridges();
 
@@ -402,15 +434,17 @@ void __init chrp_init_IRQ(void)
 
 	chrp_find_openpic();
 
-	prom_get_irq_senses(init_senses, NUM_8259_INTERRUPTS, NR_IRQS);
-	OpenPIC_InitSenses = init_senses;
-	OpenPIC_NumInitSenses = NR_IRQS - NUM_8259_INTERRUPTS;
-
-	openpic_init(NUM_8259_INTERRUPTS);
-	/* We have a cascade on OpenPIC IRQ 0, Linux IRQ 16 */
-	openpic_hookup_cascade(NUM_8259_INTERRUPTS, "82c59 cascade",
-			       i8259_irq);
+	if (OpenPIC_Addr) {
+		prom_get_irq_senses(init_senses, NUM_8259_INTERRUPTS, NR_IRQS);
+		OpenPIC_InitSenses = init_senses;
+		OpenPIC_NumInitSenses = NR_IRQS - NUM_8259_INTERRUPTS;
+
+		openpic_init(NUM_8259_INTERRUPTS);
+		/* We have a cascade on OpenPIC IRQ 0, Linux IRQ 16 */
+		openpic_hookup_cascade(NUM_8259_INTERRUPTS, "82c59 cascade",
+				       i8259_irq);
 
+	}
 	for (i = 0; i < NUM_8259_INTERRUPTS; i++)
 		irq_desc[i].handler = &i8259_pic;
 	i8259_init(chrp_int_ack);
@@ -450,6 +484,9 @@ void __init
 chrp_init(unsigned long r3, unsigned long r4, unsigned long r5,
 	  unsigned long r6, unsigned long r7)
 {
+	struct device_node *root = find_path_device ("/");
+	char *machine = NULL;
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* take care of initrd if we have one */
 	if ( r6 )
@@ -464,12 +501,29 @@ chrp_init(unsigned long r3, unsigned lon
 	DMA_MODE_WRITE = 0x48;
 	isa_io_base = CHRP_ISA_IO_BASE;		/* default value */
 
+	if (root)
+		machine = get_property(root, "model", NULL);
+	if (machine && strncmp(machine, "Pegasos", 7) == 0) {
+		_chrp_type = _CHRP_Pegasos;
+	} else if (machine && strncmp(machine, "IBM", 3) == 0) {
+		_chrp_type = _CHRP_IBM;
+	} else if (machine && strncmp(machine, "MOT", 3) == 0) {
+		_chrp_type = _CHRP_Motorola;
+	} else {
+		/* Let's assume it is an IBM chrp if all else fails */
+		_chrp_type = _CHRP_IBM;
+	}
+
 	ppc_md.setup_arch     = chrp_setup_arch;
 	ppc_md.show_percpuinfo = of_show_percpuinfo;
 	ppc_md.show_cpuinfo   = chrp_show_cpuinfo;
+
 	ppc_md.irq_canonicalize = chrp_irq_canonicalize;
 	ppc_md.init_IRQ       = chrp_init_IRQ;
-	ppc_md.get_irq        = openpic_get_irq;
+	if (_chrp_type == _CHRP_Pegasos)
+		ppc_md.get_irq        = i8259_irq;
+	else
+		ppc_md.get_irq        = openpic_get_irq;
 
 	ppc_md.init           = chrp_init2;
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_time.c linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_time.c
--- linux-2.6.11-rc2-bk3/arch/ppc/platforms/chrp_time.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/platforms/chrp_time.c	2005-01-26 15:43:25.998431340 +0100
@@ -41,6 +41,8 @@ long __init chrp_time_init(void)
 	int base;
 
 	rtcs = find_compatible_devices("rtc", "pnpPNP,b00");
+	if (rtcs == NULL)
+		rtcs = find_compatible_devices("rtc", "ds1385-rtc");
 	if (rtcs == NULL || rtcs->addrs == NULL)
 		return 0;
 	base = rtcs->addrs[0].address;
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/syslib/gen550_dbg.c linux-2.6.11-rc2-bk4/arch/ppc/syslib/gen550_dbg.c
--- linux-2.6.11-rc2-bk3/arch/ppc/syslib/gen550_dbg.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/syslib/gen550_dbg.c	2005-01-26 15:43:25.999431184 +0100
@@ -29,6 +29,11 @@
 
 #define SERIAL_BAUD	9600
 
+/* SERIAL_PORT_DFNS is defined in <asm/serial.h> */
+#ifndef SERIAL_PORT_DFNS
+#define SERIAL_PORT_DFNS
+#endif
+
 static struct serial_state rs_table[RS_TABLE_SIZE] = {
 	SERIAL_PORT_DFNS	/* defined in <asm/serial.h> */
 };
@@ -154,6 +159,7 @@ gen550_init(int i, struct uart_port *ser
 	rs_table[i].port = serial_req->iobase;
 	rs_table[i].iomem_base = serial_req->membase;
 	rs_table[i].iomem_reg_shift = serial_req->regshift;
+	rs_table[i].baud_base = serial_req->uartclk ? serial_req->uartclk / 16 : BASE_BAUD;
 }
 
 #ifdef CONFIG_SERIAL_TEXT_DEBUG
diff -purN linux-2.6.11-rc2-bk3/arch/ppc/syslib/prom_init.c linux-2.6.11-rc2-bk4/arch/ppc/syslib/prom_init.c
--- linux-2.6.11-rc2-bk3/arch/ppc/syslib/prom_init.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc/syslib/prom_init.c	2005-01-26 15:43:26.001430873 +0100
@@ -810,6 +810,9 @@ prom_init(int r3, int r4, prom_entry pp)
 	char *p, *d;
  	unsigned long phys;
 	void *result[3];
+	char model[32];
+	phandle node;
+	int rc;
 
  	/* Default */
  	phys = (unsigned long) &_stext;
@@ -866,11 +869,20 @@ prom_init(int r3, int r4, prom_entry pp)
 
 	klimit = (char *) (mem - offset);
 
-	/* If we are already running at 0xc0000000, we assume we were
-	 * loaded by an OF bootloader which did set a BAT for us.
-	 * This breaks OF translate so we force phys to be 0.
-	 */
-	if (offset == 0) {
+	node = call_prom("finddevice", 1, 1, "/");
+	rc = call_prom("getprop", 4, 1, node, "model", model, sizeof(model));
+	if (rc > 0 && !strncmp (model, "Pegasos", 7)
+		&& strncmp (model, "Pegasos2", 8)) {
+		/* Pegasos 1 has a broken translate method in the OF,
+		 * and furthermore the BATs are mapped 1:1 so the phys
+		 * address calculated above is correct, so let's use
+		 * it directly.
+		 */
+	} else if (offset == 0) {
+		/* If we are already running at 0xc0000000, we assume we were
+	 	 * loaded by an OF bootloader which did set a BAT for us.
+	 	 * This breaks OF translate so we force phys to be 0.
+	 	 */
 		prom_print("(already at 0xc0000000) phys=0\n");
 		phys = 0;
 	} else if ((int) call_prom("getprop", 4, 1, prom_chosen, "mmu",
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/Kconfig linux-2.6.11-rc2-bk4/arch/ppc64/Kconfig
--- linux-2.6.11-rc2-bk3/arch/ppc64/Kconfig	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/Kconfig	2005-01-26 15:43:26.003430561 +0100
@@ -234,6 +234,11 @@ config PREEMPT_BKL
 	  Say Y here if you are building a kernel for a desktop system.
 	  Say N if you are unsure.
 
+config EEH
+	bool "PCI Extended Error Handling (EEH)" if EMBEDDED
+	depends on PPC_PSERIES
+	default y if !EMBEDDED
+
 #
 # Use the generic interrupt handling code in kernel/irq/:
 #
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/boot/main.c linux-2.6.11-rc2-bk4/arch/ppc64/boot/main.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/boot/main.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/boot/main.c	2005-01-26 15:43:26.004430405 +0100
@@ -73,7 +73,7 @@ void *stdin;
 void *stdout;
 void *stderr;
 
-#define DEBUG
+#undef DEBUG
 
 static unsigned long claim_base = PROG_START;
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/configs/pSeries_defconfig linux-2.6.11-rc2-bk4/arch/ppc64/configs/pSeries_defconfig
--- linux-2.6.11-rc2-bk3/arch/ppc64/configs/pSeries_defconfig	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/configs/pSeries_defconfig	2005-01-26 15:43:26.006430094 +0100
@@ -268,7 +268,7 @@ CONFIG_SCSI_FC_ATTRS=y
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
-CONFIG_SCSI_IBMVSCSI=m
+CONFIG_SCSI_IBMVSCSI=y
 # CONFIG_SCSI_INIA100 is not set
 CONFIG_SCSI_SYM53C8XX_2=y
 CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
@@ -492,7 +492,7 @@ CONFIG_VORTEX=y
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
-CONFIG_IBMVETH=m
+CONFIG_IBMVETH=y
 CONFIG_NET_PCI=y
 CONFIG_PCNET32=y
 # CONFIG_AMD8111_ETH is not set
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/Makefile linux-2.6.11-rc2-bk4/arch/ppc64/kernel/Makefile
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/Makefile	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/Makefile	2005-01-26 15:43:26.007429938 +0100
@@ -30,9 +30,10 @@ obj-$(CONFIG_PPC_ISERIES) += iSeries_irq
 obj-$(CONFIG_PPC_MULTIPLATFORM) += nvram.o i8259.o prom_init.o prom.o mpic.o
 
 obj-$(CONFIG_PPC_PSERIES) += pSeries_pci.o pSeries_lpar.o pSeries_hvCall.o \
-			     eeh.o pSeries_nvram.o rtasd.o ras.o \
+			     pSeries_nvram.o rtasd.o ras.o \
 			     xics.o rtas.o pSeries_setup.o pSeries_iommu.o
 
+obj-$(CONFIG_EEH)		+= eeh.o
 obj-$(CONFIG_PROC_FS)		+= proc_ppc64.o
 obj-$(CONFIG_RTAS_FLASH)	+= rtas_flash.o
 obj-$(CONFIG_SMP)		+= smp.o
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/eeh.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/eeh.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/eeh.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/eeh.c	2005-01-26 15:43:26.009429626 +0100
@@ -764,8 +764,6 @@ void __init eeh_init(void)
 	struct device_node *phb, *np;
 	struct eeh_early_enable_info info;
 
-	init_pci_config_tokens();
-
 	np = of_find_node_by_path("/rtas");
 	if (np == NULL)
 		return;
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/entry.S linux-2.6.11-rc2-bk4/arch/ppc64/kernel/entry.S
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/entry.S	2005-01-22 02:46:47.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/entry.S	2005-01-26 15:43:26.011429314 +0100
@@ -185,10 +185,10 @@ syscall_exit_trace_cont:
 	beq-	1f			/* only restore r13 if */
 	ld	r13,GPR13(r1)		/* returning to usermode */
 1:	ld	r2,GPR2(r1)
-	ld	r1,GPR1(r1)
 	li	r12,MSR_RI
 	andc	r10,r10,r12
 	mtmsrd	r10,1			/* clear MSR.RI */
+	ld	r1,GPR1(r1)
 	mtlr	r4
 	mtcr	r5
 	mtspr	SRR0,r7
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/head.S linux-2.6.11-rc2-bk4/arch/ppc64/kernel/head.S
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/head.S	2005-01-22 02:48:12.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/head.S	2005-01-26 15:43:26.014428847 +0100
@@ -2145,10 +2145,12 @@ swapper_pg_dir:
 ioremap_dir:
 	.space	4096
 
+#ifdef CONFIG_SMP
 /* 1 page segment table per cpu (max 48, cpu0 allocated at STAB0_PHYS_ADDR) */
 	.globl	stab_array
 stab_array:
 	.space	4096 * 48
+#endif
 	
 /*
  * This space gets a copy of optional info passed to us by the bootstrap
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/iSeries_pci_reset.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/iSeries_pci_reset.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/iSeries_pci_reset.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/iSeries_pci_reset.c	2005-01-26 15:43:26.015428691 +0100
@@ -32,6 +32,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/irq.h>
+#include <linux/delay.h>
 
 #include <asm/io.h>
 #include <asm/iSeries/HvCallPci.h>
@@ -49,7 +50,7 @@
 int iSeries_Device_ToggleReset(struct pci_dev *PciDev, int AssertTime,
 		int DelayTime)
 {
-	unsigned long AssertDelay, WaitDelay;
+	unsigned int AssertDelay, WaitDelay;
 	struct iSeries_Device_Node *DeviceNode =
 		(struct iSeries_Device_Node *)PciDev->sysdata;
 
@@ -62,14 +63,14 @@ int iSeries_Device_ToggleReset(struct pc
 	 * Set defaults, Assert is .5 second, Wait is 3 seconds.
 	 */
 	if (AssertTime == 0)
-		AssertDelay = (5 * HZ) / 10;
+		AssertDelay = 500;
 	else
-		AssertDelay = (AssertTime * HZ) / 10;
+		AssertDelay = AssertTime * 100;
 
 	if (DelayTime == 0)
-		WaitDelay = (30 * HZ) / 10;
+		WaitDelay = 3000;
 	else
-		WaitDelay = (DelayTime * HZ) / 10;
+		WaitDelay = DelayTime * 100;
 
 	/*
 	 * Assert reset
@@ -77,8 +78,7 @@ int iSeries_Device_ToggleReset(struct pc
 	DeviceNode->ReturnCode = HvCallPci_setSlotReset(ISERIES_BUS(DeviceNode),
 			0x00, DeviceNode->AgentId, 1);
 	if (DeviceNode->ReturnCode == 0) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(AssertDelay);       /* Sleep for the time */
+		msleep(AssertDelay);			/* Sleep for the time */
 		DeviceNode->ReturnCode =
 			HvCallPci_setSlotReset(ISERIES_BUS(DeviceNode),
 					0x00, DeviceNode->AgentId, 0);
@@ -86,8 +86,7 @@ int iSeries_Device_ToggleReset(struct pc
 		/*
    		 * Wait for device to reset
 		 */
-		set_current_state(TASK_UNINTERRUPTIBLE);  
-		schedule_timeout(WaitDelay);
+		msleep(WaitDelay);
 	}
 	if (DeviceNode->ReturnCode == 0)
 		PCIFR("Slot 0x%04X.%02 Reset\n", ISERIES_BUS(DeviceNode),
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/iomap.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/iomap.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/iomap.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/iomap.c	2005-01-26 15:43:26.016428535 +0100
@@ -113,7 +113,7 @@ void __iomem *pci_iomap(struct pci_dev *
 	if (flags & IORESOURCE_IO)
 		return ioport_map(start, len);
 	if (flags & IORESOURCE_MEM)
-		return (void __iomem *) start;
+		return ioremap(start, len);
 	/* What? */
 	return NULL;
 }
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/pSeries_setup.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/pSeries_setup.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/pSeries_setup.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/pSeries_setup.c	2005-01-26 15:43:26.018428223 +0100
@@ -40,7 +40,6 @@
 #include <linux/adb.h>
 #include <linux/module.h>
 #include <linux/delay.h>
-
 #include <linux/irq.h>
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
@@ -59,13 +58,12 @@
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include <asm/plpar_wrappers.h>
-
-#include "i8259.h"
 #include <asm/xics.h>
-#include <asm/ppcdebug.h>
 #include <asm/cputable.h>
 
+#include "i8259.h"
 #include "mpic.h"
+#include "pci.h"
 
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
@@ -73,7 +71,6 @@
 #define DBG(fmt...)
 #endif
 
-extern void find_and_init_phbs(void);
 extern void pSeries_final_fixup(void);
 
 extern void pSeries_get_boot_time(struct rtc_time *rtc_time);
@@ -87,10 +84,6 @@ extern void generic_find_legacy_serial_p
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
-unsigned long  virtPython0Facilities = 0;  // python0 facility area (memory mapped io) (64-bit format) VIRTUAL address.
-
-extern unsigned long loops_per_jiffy;
-
 extern unsigned long ppc_proc_freq;
 extern unsigned long ppc_tb_freq;
 
@@ -230,7 +223,7 @@ static void __init pSeries_setup_arch(vo
 	fwnmi_init();
 
 	/* Find and initialize PCI host bridges */
-	/* iSeries needs to be done much later. */
+	init_pci_config_tokens();
 	eeh_init();
 	find_and_init_phbs();
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/pSeries_smp.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/pSeries_smp.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/pSeries_smp.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/pSeries_smp.c	2005-01-26 15:43:26.019428068 +0100
@@ -107,8 +107,7 @@ void pSeries_cpu_die(unsigned int cpu)
 		cpu_status = query_cpu_stopped(pcpu);
 		if (cpu_status == 0 || cpu_status == -1)
 			break;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ/5);
+		msleep(200);
 	}
 	if (cpu_status != 0) {
 		printk("Querying DEAD? cpu %i (%i) shows %i\n",
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/process.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/process.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/process.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/process.c	2005-01-26 15:43:26.020427912 +0100
@@ -35,7 +35,7 @@
 #include <linux/ptrace.h>
 #include <linux/kallsyms.h>
 #include <linux/interrupt.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 
 #include <asm/pgtable.h>
 #include <asm/uaccess.h>
@@ -255,7 +255,7 @@ void show_regs(struct pt_regs * regs)
 	printk("NIP: %016lX XER: %08X LR: %016lX CTR: %016lX\n",
 	       regs->nip, (unsigned int)regs->xer, regs->link, regs->ctr);
 	printk("REGS: %p TRAP: %04lx   %s  (%s)\n",
-	       regs, regs->trap, print_tainted(), UTS_RELEASE);
+	       regs, regs->trap, print_tainted(), system_utsname.release);
 	printk("MSR: %016lx EE: %01x PR: %01x FP: %01x ME: %01x "
 	       "IR/DR: %01x%01x CR: %08X\n",
 	       regs->msr, regs->msr&MSR_EE ? 1 : 0, regs->msr&MSR_PR ? 1 : 0,
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/prom.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/prom.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/prom.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/prom.c	2005-01-26 15:43:26.024427288 +0100
@@ -717,6 +717,7 @@ static unsigned long __init unflatten_dt
 				dad->next->sibling = np;
 			dad->next = np;
 		}
+		kref_init(&np->kref);
 	}
 	while(1) {
 		u32 sz, noff;
@@ -1475,24 +1476,31 @@ EXPORT_SYMBOL(of_get_next_child);
  *	@node:	Node to inc refcount, NULL is supported to
  *		simplify writing of callers
  *
- *	Returns the node itself or NULL if gone.
+ *	Returns node.
  */
 struct device_node *of_node_get(struct device_node *node)
 {
-	if (node && !OF_IS_STALE(node)) {
-		atomic_inc(&node->_users);
-		return node;
-	}
-	return NULL;
+	if (node)
+		kref_get(&node->kref);
+	return node;
 }
 EXPORT_SYMBOL(of_node_get);
 
+static inline struct device_node * kref_to_device_node(struct kref *kref)
+{
+	return container_of(kref, struct device_node, kref);
+}
+
 /**
- *	of_node_cleanup - release a dynamically allocated node
- *	@arg:  Node to be released
+ *	of_node_release - release a dynamically allocated node
+ *	@kref:  kref element of the node to be released
+ *
+ *	In of_node_put() this function is passed to kref_put()
+ *	as the destructor.
  */
-static void of_node_cleanup(struct device_node *node)
+static void of_node_release(struct kref *kref)
 {
+	struct device_node *node = kref_to_device_node(kref);
 	struct property *prop = node->properties;
 
 	if (!OF_IS_DYNAMIC(node))
@@ -1518,19 +1526,8 @@ static void of_node_cleanup(struct devic
  */
 void of_node_put(struct device_node *node)
 {
-	if (!node)
-		return;
-
-	WARN_ON(0 == atomic_read(&node->_users));
-
-	if (OF_IS_STALE(node)) {
-		if (atomic_dec_and_test(&node->_users)) {
-			of_node_cleanup(node);
-			return;
-		}
-	}
-	else
-		atomic_dec(&node->_users);
+	if (node)
+		kref_put(&node->kref, of_node_release);
 }
 EXPORT_SYMBOL(of_node_put);
 
@@ -1773,6 +1770,7 @@ int of_add_node(const char *path, struct
 
 	np->properties = proplist;
 	OF_MARK_DYNAMIC(np);
+	kref_init(&np->kref);
 	of_node_get(np);
 	np->parent = derive_parent(path);
 	if (!np->parent) {
@@ -1809,8 +1807,9 @@ static void of_cleanup_node(struct devic
 }
 
 /*
- * Remove an OF device node from the system.
- * Caller should have already "gotten" np.
+ * "Unplug" a node from the device tree.  The caller must hold
+ * a reference to the node.  The memory associated with the node
+ * is not freed until its refcount goes to zero.
  */
 int of_remove_node(struct device_node *np)
 {
@@ -1828,7 +1827,6 @@ int of_remove_node(struct device_node *n
 	of_cleanup_node(np);
 
 	write_lock(&devtree_lock);
-	OF_MARK_STALE(np);
 	remove_node_proc_entries(np);
 	if (allnodes == np)
 		allnodes = np->allnext;
@@ -1853,6 +1851,7 @@ int of_remove_node(struct device_node *n
 	}
 	write_unlock(&devtree_lock);
 	of_node_put(parent);
+	of_node_put(np); /* Must decrement the refcount */
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/smp.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/smp.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/smp.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/smp.c	2005-01-26 15:43:26.027426821 +0100
@@ -459,8 +459,7 @@ int __devinit __cpu_up(unsigned int cpu)
 		 * hotplug case.  Wait five seconds.
 		 */
 		for (c = 25; c && !cpu_callin_map[cpu]; c--) {
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(HZ/5);
+			msleep(200);
 		}
 #endif
 
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/sys_ppc32.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/sys_ppc32.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/sys_ppc32.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/sys_ppc32.c	2005-01-26 15:43:26.029426509 +0100
@@ -492,6 +492,7 @@ asmlinkage long sys32_settimeofday(struc
 	return do_sys_settimeofday(tv ? &kts : NULL, tz ? &ktz : NULL);
 }
 
+#ifdef CONFIG_SYSVIPC
 long sys32_ipc(u32 call, u32 first, u32 second, u32 third, compat_uptr_t ptr,
 	       u32 fifth)
 {
@@ -556,6 +557,7 @@ long sys32_ipc(u32 call, u32 first, u32 
 
 	return -ENOSYS;
 }
+#endif
 
 /* Note: it is necessary to treat out_fd and in_fd as unsigned ints, 
  * with the corresponding cast to a signed int to insure that the 
@@ -1104,6 +1106,7 @@ asmlinkage long sys32_umask(u32 mask)
 	return sys_umask((int)mask);
 }
 
+#ifdef CONFIG_SYSCTL
 struct __sysctl_args32 {
 	u32 name;
 	int nlen;
@@ -1153,6 +1156,7 @@ asmlinkage long sys32_sysctl(struct __sy
 	}
 	return error;
 }
+#endif
 
 asmlinkage int sys32_olduname(struct oldold_utsname __user * name)
 {
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/kernel/traps.c linux-2.6.11-rc2-bk4/arch/ppc64/kernel/traps.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/kernel/traps.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/kernel/traps.c	2005-01-26 15:43:26.031426198 +0100
@@ -29,6 +29,7 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/delay.h>
 #include <asm/kdebug.h>
 
 #include <asm/pgtable.h>
@@ -137,8 +138,7 @@ int die(const char *str, struct pt_regs 
 
 	if (panic_on_oops) {
 		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(5 * HZ);
+		ssleep(5);
 		panic("Fatal exception");
 	}
 	do_exit(SIGSEGV);
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/mm/hash_utils.c linux-2.6.11-rc2-bk4/arch/ppc64/mm/hash_utils.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/mm/hash_utils.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/mm/hash_utils.c	2005-01-26 15:43:26.032426042 +0100
@@ -294,12 +294,6 @@ int hash_page(unsigned long ea, unsigned
 		vsid = get_kernel_vsid(ea);
 		break;
 #if 0
-	case EEH_REGION_ID:
-		/*
-		 * Should only be hit if there is an access to MMIO space
-		 * which is protected by EEH.
-		 * Send the problem up to do_page_fault 
-		 */
 	case KERNEL_REGION_ID:
 		/*
 		 * Should never get here - entire 0xC0... region is bolted.
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/mm/slb.c linux-2.6.11-rc2-bk4/arch/ppc64/mm/slb.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/mm/slb.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/mm/slb.c	2005-01-26 15:43:26.033425886 +0100
@@ -78,7 +78,7 @@ static void slb_flush_and_rebolt(void)
 void switch_slb(struct task_struct *tsk, struct mm_struct *mm)
 {
 	unsigned long offset = get_paca()->slb_cache_ptr;
-	unsigned long esid_data;
+	unsigned long esid_data = 0;
 	unsigned long pc = KSTK_EIP(tsk);
 	unsigned long stack = KSTK_ESP(tsk);
 	unsigned long unmapped_base;
@@ -97,11 +97,8 @@ void switch_slb(struct task_struct *tsk,
 	}
 
 	/* Workaround POWER5 < DD2.1 issue */
-	if (offset == 1 || offset > SLB_CACHE_ENTRIES) {
-		/* flush segment in EEH region, we shouldn't ever
-		 * access addresses in this region. */
-		asm volatile("slbie %0" : : "r"(EEHREGIONBASE));
-	}
+	if (offset == 1 || offset > SLB_CACHE_ENTRIES)
+		asm volatile("slbie %0" : : "r" (esid_data));
 
 	get_paca()->slb_cache_ptr = 0;
 	get_paca()->context = mm->context;
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/oprofile/common.c linux-2.6.11-rc2-bk4/arch/ppc64/oprofile/common.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/oprofile/common.c	2005-01-22 02:49:10.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/oprofile/common.c	2005-01-26 15:43:26.034425730 +0100
@@ -125,7 +125,7 @@ static int op_ppc64_create_files(struct 
 	return 0;
 }
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	unsigned int pvr;
 
@@ -170,7 +170,7 @@ void __init oprofile_arch_init(struct op
 			break;
 
 		default:
-			return;
+			return -ENODEV;
 	}
 
 	ops->create_files = op_ppc64_create_files;
@@ -181,6 +181,8 @@ void __init oprofile_arch_init(struct op
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       ops->cpu_type);
+
+	return 0;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/ppc64/xmon/xmon.c linux-2.6.11-rc2-bk4/arch/ppc64/xmon/xmon.c
--- linux-2.6.11-rc2-bk3/arch/ppc64/xmon/xmon.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/ppc64/xmon/xmon.c	2005-01-26 15:43:26.038425107 +0100
@@ -624,6 +624,17 @@ int xmon_fault_handler(struct pt_regs *r
 	return 0;
 }
 
+/* On systems with a hypervisor, we can't set the DABR
+   (data address breakpoint register) directly. */
+static void set_controlled_dabr(unsigned long val)
+{
+	if (systemcfg->platform == PLATFORM_PSERIES_LPAR) {
+		int rc = plpar_hcall_norets(H_SET_DABR, val);
+		if (rc != H_Success)
+			xmon_printf("Warning: setting DABR failed (%d)\n", rc);
+	} else
+		set_dabr(val);
+}
 
 static struct bpt *at_breakpoint(unsigned long pc)
 {
@@ -711,7 +722,7 @@ static void insert_bpts(void)
 static void insert_cpu_bpts(void)
 {
 	if (dabr.enabled)
-		set_dabr(dabr.address | (dabr.enabled & 7));
+		set_controlled_dabr(dabr.address | (dabr.enabled & 7));
 	if (iabr && (cur_cpu_spec->cpu_features & CPU_FTR_IABR))
 		set_iabr(iabr->address
 			 | (iabr->enabled & (BP_IABR|BP_IABR_TE)));
@@ -739,7 +750,7 @@ static void remove_bpts(void)
 
 static void remove_cpu_bpts(void)
 {
-	set_dabr(0);
+	set_controlled_dabr(0);
 	if ((cur_cpu_spec->cpu_features & CPU_FTR_IABR))
 		set_iabr(0);
 }
@@ -1049,8 +1060,8 @@ static char *breakpoint_help_string = 
     "b <addr> [cnt]   set breakpoint at given instr addr\n"
     "bc               clear all breakpoints\n"
     "bc <n/addr>      clear breakpoint number n or at addr\n"
-    "bi <addr> [cnt]  set hardware instr breakpoint (broken?)\n"
-    "bd <addr> [cnt]  set hardware data breakpoint (broken?)\n"
+    "bi <addr> [cnt]  set hardware instr breakpoint (POWER3/RS64 only)\n"
+    "bd <addr> [cnt]  set hardware data breakpoint\n"
     "";
 
 static void
diff -purN linux-2.6.11-rc2-bk3/arch/s390/kernel/compat_linux.c linux-2.6.11-rc2-bk4/arch/s390/kernel/compat_linux.c
--- linux-2.6.11-rc2-bk3/arch/s390/kernel/compat_linux.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/s390/kernel/compat_linux.c	2005-01-26 15:43:26.040424795 +0100
@@ -906,6 +906,7 @@ asmlinkage long sys32_adjtimex(struct ti
 	return ret;
 }
 
+#ifdef CONFIG_SYSCTL
 struct __sysctl_args32 {
 	u32 name;
 	int nlen;
@@ -953,6 +954,7 @@ asmlinkage long sys32_sysctl(struct __sy
 	}
 	return error;
 }
+#endif
 
 struct stat64_emu31 {
 	unsigned long long  st_dev;
diff -purN linux-2.6.11-rc2-bk3/arch/s390/oprofile/init.c linux-2.6.11-rc2-bk4/arch/s390/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/s390/oprofile/init.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/s390/oprofile/init.c	2005-01-26 15:43:26.042558000 +0100
@@ -12,8 +12,9 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 
-void __init oprofile_arch_init(struct oprofile_operations* ops)
+int __init oprofile_arch_init(struct oprofile_operations* ops)
 {
+	return -ENODEV;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/sh/oprofile/op_model_null.c linux-2.6.11-rc2-bk4/arch/sh/oprofile/op_model_null.c
--- linux-2.6.11-rc2-bk3/arch/sh/oprofile/op_model_null.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/sh/oprofile/op_model_null.c	2005-01-26 15:43:26.043557844 +0100
@@ -12,8 +12,9 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
+	return -ENODEV;
 }
 
 void oprofile_arch_exit(void)
diff -purN linux-2.6.11-rc2-bk3/arch/sparc64/oprofile/init.c linux-2.6.11-rc2-bk4/arch/sparc64/oprofile/init.c
--- linux-2.6.11-rc2-bk3/arch/sparc64/oprofile/init.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/sparc64/oprofile/init.c	2005-01-26 15:43:26.053556286 +0100
@@ -12,8 +12,9 @@
 #include <linux/errno.h>
 #include <linux/init.h>
  
-void __init oprofile_arch_init(struct oprofile_operations * ops)
+int __init oprofile_arch_init(struct oprofile_operations * ops)
 {
+	return -ENODEV;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/arch/um/sys-x86_64/sysrq.c linux-2.6.11-rc2-bk4/arch/um/sys-x86_64/sysrq.c
--- linux-2.6.11-rc2-bk3/arch/um/sys-x86_64/sysrq.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/um/sys-x86_64/sysrq.c	2005-01-26 15:43:26.054556130 +0100
@@ -5,7 +5,7 @@
  */
 
 #include "linux/kernel.h"
-#include "linux/version.h"
+#include "linux/utsname.h"
 #include "linux/module.h"
 #include "asm/current.h"
 #include "asm/ptrace.h"
@@ -16,7 +16,7 @@ void __show_regs(struct pt_regs * regs)
 	printk("\n");
 	print_modules();
 	printk("Pid: %d, comm: %.20s %s %s\n",
-	       current->pid, current->comm, print_tainted(), UTS_RELEASE);
+	       current->pid, current->comm, print_tainted(), system_utsname.release);
 	printk("RIP: %04lx:[<%016lx>] ", PT_REGS_CS(regs) & 0xffff,
 	       PT_REGS_RIP(regs));
 	printk("\nRSP: %016lx  EFLAGS: %08lx\n", PT_REGS_RSP(regs),
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/Kconfig linux-2.6.11-rc2-bk4/arch/x86_64/Kconfig
--- linux-2.6.11-rc2-bk3/arch/x86_64/Kconfig	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/Kconfig	2005-01-26 15:43:26.056555818 +0100
@@ -52,15 +52,6 @@ config X86_CMPXCHG
 config EARLY_PRINTK
 	bool
 	default y
-	help
-	  Write kernel log output directly into the VGA buffer or to a serial
-	  port.
-
-	  This is useful for kernel debugging when your machine crashes very
-	  early before the console code is initialized. For normal operation
-	  it is not recommended because it looks ugly and doesn't cooperate
-	  with klogd/syslogd or the X server. You should normally N here,
-	  unless you want to debug such a crash.
 
 config HPET_TIMER
 	bool
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/ia32/sys_ia32.c linux-2.6.11-rc2-bk4/arch/x86_64/ia32/sys_ia32.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/ia32/sys_ia32.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/ia32/sys_ia32.c	2005-01-26 15:43:26.058555507 +0100
@@ -653,6 +653,7 @@ sys32_pause(void)
 }
 
 
+#ifdef CONFIG_SYSCTL
 struct sysctl_ia32 {
 	unsigned int	name;
 	int		nlen;
@@ -667,9 +668,6 @@ struct sysctl_ia32 {
 asmlinkage long
 sys32_sysctl(struct sysctl_ia32 __user *args32)
 {
-#ifndef CONFIG_SYSCTL
-	return -ENOSYS; 
-#else
 	struct sysctl_ia32 a32;
 	mm_segment_t old_fs = get_fs ();
 	void *oldvalp, *newvalp;
@@ -710,8 +708,8 @@ sys32_sysctl(struct sysctl_ia32 __user *
 		return -EFAULT;
 
 	return ret;
-#endif
 }
+#endif
 
 /* warning: next two assume little endian */ 
 asmlinkage long
@@ -1082,8 +1080,6 @@ long sys32_lookup_dcookie(u32 addr_low, 
 	return sys_lookup_dcookie(((u64)addr_high << 32) | addr_low, buf, len);
 }
 
-cond_syscall(sys32_ipc)
-
 static int __init ia32_init (void)
 {
 	printk("IA32 emulation $Id: sys_ia32.c,v 1.32 2002/03/24 13:02:28 ak Exp $\n");  
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/asm-offsets.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/asm-offsets.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/asm-offsets.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/asm-offsets.c	2005-01-26 15:43:26.059555351 +0100
@@ -8,6 +8,7 @@
 #include <linux/stddef.h>
 #include <linux/errno.h> 
 #include <linux/hardirq.h>
+#include <linux/suspend.h>
 #include <asm/pda.h>
 #include <asm/processor.h>
 #include <asm/segment.h>
@@ -61,6 +62,8 @@ int main(void)
 	       offsetof (struct rt_sigframe32, uc.uc_mcontext));
 	BLANK();
 #endif
-
+	DEFINE(SIZEOF_PBE, sizeof(struct pbe));
+	DEFINE(pbe_address, offsetof(struct pbe, address));
+	DEFINE(pbe_orig_address, offsetof(struct pbe, orig_address));
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/entry.S linux-2.6.11-rc2-bk4/arch/x86_64/kernel/entry.S
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/entry.S	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/entry.S	2005-01-26 15:43:26.062554883 +0100
@@ -41,7 +41,6 @@
 #include <asm/unistd.h>
 #include <asm/thread_info.h>
 #include <asm/hw_irq.h>
-#include <asm/errno.h>
 
 	.code64
 
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/module.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/module.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/module.c	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/module.c	2005-01-26 15:43:26.063554728 +0100
@@ -23,7 +23,6 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 
 #include <asm/system.h>
 #include <asm/page.h>
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/process.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/process.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/process.c	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/process.c	2005-01-26 15:43:26.064554572 +0100
@@ -32,7 +32,7 @@
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/ptrace.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -232,7 +232,7 @@ void __show_regs(struct pt_regs * regs)
 	printk("\n");
 	print_modules();
 	printk("Pid: %d, comm: %.20s %s %s\n", 
-	       current->pid, current->comm, print_tainted(), UTS_RELEASE);
+	       current->pid, current->comm, print_tainted(), system_utsname.release);
 	printk("RIP: %04lx:[<%016lx>] ", regs->cs & 0xffff, regs->rip);
 	printk_address(regs->rip); 
 	printk("\nRSP: %04lx:%016lx  EFLAGS: %08lx\n", regs->ss, regs->rsp, regs->eflags);
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/setup.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/setup.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/setup.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/setup.c	2005-01-26 15:43:26.066554260 +0100
@@ -53,7 +53,6 @@
 #include <asm/mpspec.h>
 #include <asm/mmu_context.h>
 #include <asm/bootsetup.h>
-#include <asm/smp.h>
 #include <asm/proto.h>
 #include <asm/setup.h>
 #include <asm/mach_apic.h>
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/suspend_asm.S linux-2.6.11-rc2-bk4/arch/x86_64/kernel/suspend_asm.S
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/suspend_asm.S	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/suspend_asm.S	2005-01-26 15:43:26.068553948 +0100
@@ -1,6 +1,9 @@
-/* Originally gcc generated, modified by hand
+/* Copyright 2004,2005 Pavel Machek <pavel@suse.cz>, Andi Kleen <ak@suse.de>, Rafael J. Wysocki <rjw@sisk.pl>
  *
- * This may not use any stack, nor any variable that is not "NoSave":
+ * Distribute under GPLv2.
+ *
+ * swsusp_arch_resume may not use any stack, nor any variable that is
+ * not "NoSave" during copying pages:
  *
  * Its rewriting one kernel image with another. What is stack in "old"
  * image could very well be data page in "new" image, and overwriting
@@ -11,6 +14,7 @@
 #include <linux/linkage.h>
 #include <asm/segment.h>
 #include <asm/page.h>
+#include <asm/offset.h>
 
 ENTRY(swsusp_arch_suspend)
 
@@ -49,43 +53,28 @@ ENTRY(swsusp_arch_resume)
 	movq	%rcx, %cr3;
 	movq	%rax, %cr4;  # turn PGE back on
 
+	movq	pagedir_nosave(%rip), %rdx
+	/* compute the limit */
 	movl	nr_copy_pages(%rip), %eax
-	xorl	%ecx, %ecx
-	movq	$0, %r10
 	testl	%eax, %eax
 	jz	done
-.L105:
-	xorl	%esi, %esi
-	movq	$0, %r11
-	jmp	.L104
-	.p2align 4,,7
-copy_one_page:
-	movq	%r10, %rcx
-.L104:
-	movq	pagedir_nosave(%rip), %rdx
-	movq	%rcx, %rax
-	salq	$5, %rax
-	movq	8(%rdx,%rax), %rcx
-	movq	(%rdx,%rax), %rax
-	movzbl	(%rsi,%rax), %eax
-	movb	%al, (%rsi,%rcx)
-
-	movq	%cr3, %rax;  # flush TLB
-	movq	%rax, %cr3;
-
-	movq	%r11, %rax
-	incq	%rax
-	cmpq	$4095, %rax
-	movq	%rax, %rsi
-	movq	%rax, %r11
-	jbe	copy_one_page
-	movq	%r10, %rax
-	incq	%rax
-	movq	%rax, %rcx
-	movq	%rax, %r10
-	mov	nr_copy_pages(%rip), %eax
-	cmpq	%rax, %rcx
-	jb	.L105
+	movq	%rdx,%r8
+	movl	$SIZEOF_PBE,%r9d
+	mul		%r9  # with rax, clobbers rdx
+	movq 	%r8, %rdx
+	addq	%r8, %rax
+loop:
+	/* get addresses from the pbe and copy the page */
+	movq	pbe_address(%rdx), %rsi
+	movq	pbe_orig_address(%rdx), %rdi
+	movq	$512, %rcx
+	rep
+	movsq
+
+	/* progress to the next pbe */
+	addq	$SIZEOF_PBE, %rdx
+	cmpq	%rax, %rdx
+	jb	loop
 done:
 	movl	$24, %eax
 	movl	%eax, %ds
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/time.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/time.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/time.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/time.c	2005-01-26 15:43:26.070553637 +0100
@@ -1029,7 +1029,6 @@ device_initcall(time_init_device);
  * For (3), we use interrupts at 64Hz or user specified periodic
  * frequency, whichever is higher.
  */
-#include <linux/mc146818rtc.h>
 #include <linux/rtc.h>
 
 extern irqreturn_t rtc_interrupt(int irq, void *dev_id, struct pt_regs *regs);
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/traps.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/traps.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/traps.c	2005-01-26 15:42:47.506701753 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/traps.c	2005-01-26 15:43:26.072553325 +0100
@@ -405,15 +405,6 @@ void die_nmi(char *str, struct pt_regs *
 	do_exit(SIGSEGV);
 }
 
-static inline unsigned long get_cr2(void)
-{
-	unsigned long address;
-
-	/* get the address */
-	__asm__("movq %%cr2,%0":"=r" (address));
-	return address;
-}
-
 static void do_trap(int trapnr, int signr, char *str, 
 			   struct pt_regs * regs, long error_code, siginfo_t *info)
 {
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/kernel/x8664_ksyms.c linux-2.6.11-rc2-bk4/arch/x86_64/kernel/x8664_ksyms.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/kernel/x8664_ksyms.c	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/kernel/x8664_ksyms.c	2005-01-26 15:43:26.073553169 +0100
@@ -30,7 +30,6 @@
 #include <asm/nmi.h>
 #include <asm/kdebug.h>
 #include <asm/unistd.h>
-#include <asm/delay.h>
 #include <asm/tlbflush.h>
 #include <asm/kdebug.h>
 
diff -purN linux-2.6.11-rc2-bk3/arch/x86_64/mm/k8topology.c linux-2.6.11-rc2-bk4/arch/x86_64/mm/k8topology.c
--- linux-2.6.11-rc2-bk3/arch/x86_64/mm/k8topology.c	2005-01-22 02:49:13.000000000 +0100
+++ linux-2.6.11-rc2-bk4/arch/x86_64/mm/k8topology.c	2005-01-26 15:43:26.075552857 +0100
@@ -59,7 +59,7 @@ int __init k8_scan_nodes(unsigned long s
 	printk(KERN_INFO "Scanning NUMA topology in Northbridge %d\n", nb); 
 
 	reg = read_pci_config(0, nb, 0, 0x60); 
-	numnodes = ((reg >> 4) & 7) + 1;
+	numnodes = ((reg >> 4) & 0xF) + 1;
 
 	printk(KERN_INFO "Number of nodes %d\n", numnodes);
 
diff -purN linux-2.6.11-rc2-bk3/drivers/block/aoe/aoeblk.c linux-2.6.11-rc2-bk4/drivers/block/aoe/aoeblk.c
--- linux-2.6.11-rc2-bk3/drivers/block/aoe/aoeblk.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/block/aoe/aoeblk.c	2005-01-26 15:43:26.076552702 +0100
@@ -245,7 +245,7 @@ aoeblk_gdalloc(void *vp)
 		d->fw_ver, (long long)d->ssize);
 }
 
-void __exit
+void
 aoeblk_exit(void)
 {
 	kmem_cache_destroy(buf_pool_cache);
@@ -254,19 +254,12 @@ aoeblk_exit(void)
 int __init
 aoeblk_init(void)
 {
-	int n;
-
 	buf_pool_cache = kmem_cache_create("aoe_bufs", 
 					   sizeof(struct buf),
 					   0, 0, NULL, NULL);
 	if (buf_pool_cache == NULL)
 		return -ENOMEM;
 
-	n = register_blkdev(AOE_MAJOR, DEVICE_NAME);
-	if (n < 0) {
-		printk(KERN_ERR "aoe: aoeblk_init: can't register major\n");
-		return n;
-	}
 	return 0;
 }
 
diff -purN linux-2.6.11-rc2-bk3/drivers/block/genhd.c linux-2.6.11-rc2-bk4/drivers/block/genhd.c
--- linux-2.6.11-rc2-bk3/drivers/block/genhd.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/block/genhd.c	2005-01-26 15:43:26.077552546 +0100
@@ -300,7 +300,7 @@ static struct kobject *base_probe(dev_t 
 	return NULL;
 }
 
-int __init device_init(void)
+static int __init genhd_device_init(void)
 {
 	bdev_map = kobj_map_init(base_probe, &block_subsys);
 	blk_dev_init();
@@ -308,7 +308,7 @@ int __init device_init(void)
 	return 0;
 }
 
-subsys_initcall(device_init);
+subsys_initcall(genhd_device_init);
 
 
 
diff -purN linux-2.6.11-rc2-bk3/drivers/bluetooth/bt3c_cs.c linux-2.6.11-rc2-bk4/drivers/bluetooth/bt3c_cs.c
--- linux-2.6.11-rc2-bk3/drivers/bluetooth/bt3c_cs.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/bluetooth/bt3c_cs.c	2005-01-26 15:43:26.079552234 +0100
@@ -771,7 +771,7 @@ static int next_tuple(client_handle_t ha
 
 static void bt3c_config(dev_link_t *link)
 {
-	static ioaddr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
+	static kio_addr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
 	client_handle_t handle = link->handle;
 	bt3c_info_t *info = link->priv;
 	tuple_t tuple;
diff -purN linux-2.6.11-rc2-bk3/drivers/bluetooth/btuart_cs.c linux-2.6.11-rc2-bk4/drivers/bluetooth/btuart_cs.c
--- linux-2.6.11-rc2-bk3/drivers/bluetooth/btuart_cs.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/bluetooth/btuart_cs.c	2005-01-26 15:43:26.080552078 +0100
@@ -690,7 +690,7 @@ static int next_tuple(client_handle_t ha
 
 static void btuart_config(dev_link_t *link)
 {
-	static ioaddr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
+	static kio_addr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
 	client_handle_t handle = link->handle;
 	btuart_info_t *info = link->priv;
 	tuple_t tuple;
diff -purN linux-2.6.11-rc2-bk3/drivers/cdrom/aztcd.c linux-2.6.11-rc2-bk4/drivers/cdrom/aztcd.c
--- linux-2.6.11-rc2-bk3/drivers/cdrom/aztcd.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/cdrom/aztcd.c	2005-01-26 15:43:26.084551455 +0100
@@ -165,7 +165,6 @@
 			 Torben Mathiasen <tmm@image.dk>
 */
 
-#include <linux/version.h>
 #include <linux/blkdev.h>
 #include "aztcd.h"
 
@@ -1708,8 +1707,8 @@ static int __init aztcd_init(void)
 	printk(KERN_INFO "aztcd: (C) 1994-98 W.Zimmermann\n");
 	if (azt_port == -1) {
 		printk
-		    ("aztcd: KernelVersion=%s DriverVersion=%s For IDE/ATAPI-drives use ide-cd.c\n",
-		     UTS_RELEASE, AZT_VERSION);
+		    ("aztcd: DriverVersion=%s For IDE/ATAPI-drives use ide-cd.c\n",
+		     AZT_VERSION);
 	} else
 		printk
 		    ("aztcd: DriverVersion=%s BaseAddress=0x%x  For IDE/ATAPI-drives use ide-cd.c\n",
diff -purN linux-2.6.11-rc2-bk3/drivers/cdrom/mcdx.c linux-2.6.11-rc2-bk4/drivers/cdrom/mcdx.c
--- linux-2.6.11-rc2-bk3/drivers/cdrom/mcdx.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/cdrom/mcdx.c	2005-01-26 15:43:26.088550832 +0100
@@ -56,7 +56,6 @@ static const char *mcdx_c_version
     = "$Id: mcdx.c,v 1.21 1997/01/26 07:12:59 davem Exp $";
 #endif
 
-#include <linux/version.h>
 #include <linux/module.h>
 
 #include <linux/errno.h>
@@ -1265,11 +1264,7 @@ int __init mcdx_init_drive(int drive)
 int __init mcdx_init(void)
 {
 	int drive;
-#ifdef MODULE
-	xwarn("Version 2.14(hs) for " UTS_RELEASE "\n");
-#else
 	xwarn("Version 2.14(hs) \n");
-#endif
 
 	xwarn("$Id: mcdx.c,v 1.21 1997/01/26 07:12:59 davem Exp $\n");
 
diff -purN linux-2.6.11-rc2-bk3/drivers/char/ftape/compressor/zftape-compress.c linux-2.6.11-rc2-bk4/drivers/char/ftape/compressor/zftape-compress.c
--- linux-2.6.11-rc2-bk3/drivers/char/ftape/compressor/zftape-compress.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/char/ftape/compressor/zftape-compress.c	2005-01-26 15:43:26.092550208 +0100
@@ -27,7 +27,6 @@
  *     changed * appropriately. See below.
  */
 
-#include <linux/version.h>
 #include <linux/errno.h>
 #include <linux/mm.h>
 #include <linux/module.h>
@@ -1174,11 +1173,10 @@ int zft_compressor_init(void)
 		printk(
 KERN_INFO "(c) 1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de)\n"
 KERN_INFO "Compressor for zftape (lzrw3 algorithm)\n"
-KERN_INFO "Compiled for kernel version %s\n", UTS_RELEASE);
         }
 #else /* !MODULE */
 	/* print a short no-nonsense boot message */
-	printk("zftape compressor v1.00a 970514 for Linux " UTS_RELEASE "\n");
+	printk("zftape compressor v1.00a 970514\n");
 	printk("For use with " FTAPE_VERSION "\n");
 #endif /* MODULE */
 	TRACE(ft_t_info, "zft_compressor_init @ 0x%p", zft_compressor_init);
diff -purN linux-2.6.11-rc2-bk3/drivers/char/ftape/lowlevel/ftape-init.c linux-2.6.11-rc2-bk4/drivers/char/ftape/lowlevel/ftape-init.c
--- linux-2.6.11-rc2-bk3/drivers/char/ftape/lowlevel/ftape-init.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/char/ftape/lowlevel/ftape-init.c	2005-01-26 15:43:26.093550052 +0100
@@ -23,7 +23,6 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/version.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
@@ -74,11 +73,10 @@ KERN_INFO "(c) 1993-1996 Bas Laarhoven (
 KERN_INFO "(c) 1995-1996 Kai Harrekilde-Petersen (khp@dolphinics.no)\n"
 KERN_INFO "(c) 1996-1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de)\n"
 KERN_INFO "QIC-117 driver for QIC-40/80/3010/3020 floppy tape drives\n"
-KERN_INFO "Compiled for Linux version %s\n", UTS_RELEASE);
         }
 #else /* !MODULE */
 	/* print a short no-nonsense boot message */
-	printk(KERN_INFO FTAPE_VERSION " for Linux " UTS_RELEASE "\n");
+	printk(KERN_INFO FTAPE_VERSION "\n");
 #endif /* MODULE */
 	TRACE(ft_t_info, "installing QIC-117 floppy tape hardware drive ... ");
 	TRACE(ft_t_info, "ftape_init @ 0x%p", ftape_init);
diff -purN linux-2.6.11-rc2-bk3/drivers/char/ftape/zftape/zftape-init.c linux-2.6.11-rc2-bk4/drivers/char/ftape/zftape/zftape-init.c
--- linux-2.6.11-rc2-bk3/drivers/char/ftape/zftape/zftape-init.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/char/ftape/zftape/zftape-init.c	2005-01-26 15:43:26.094549897 +0100
@@ -23,7 +23,6 @@
 #include <linux/config.h>
 #include <linux/module.h>
 #include <linux/errno.h>
-#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
@@ -319,13 +318,11 @@ KERN_INFO
 KERN_INFO
 "Support for QIC-113 compatible volume table, dynamic memory allocation\n"
 KERN_INFO
-"and builtin compression (lzrw3 algorithm).\n"
-KERN_INFO
-"Compiled for Linux version %s\n", UTS_RELEASE);
+"and builtin compression (lzrw3 algorithm).\n");
         }
 #else /* !MODULE */
 	/* print a short no-nonsense boot message */
-	printk(KERN_INFO ZFTAPE_VERSION " for Linux " UTS_RELEASE "\n");
+	printk(KERN_INFO ZFTAPE_VERSION "\n");
 #endif /* MODULE */
 	TRACE(ft_t_info, "zft_init @ 0x%p", zft_init);
 	TRACE(ft_t_info,
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/core/user_mad.c linux-2.6.11-rc2-bk4/drivers/infiniband/core/user_mad.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/core/user_mad.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/core/user_mad.c	2005-01-26 15:43:26.099549117 +0100
@@ -43,9 +43,9 @@
 #include <linux/poll.h>
 #include <linux/rwsem.h>
 #include <linux/kref.h>
-#include <linux/ioctl32.h>
 
 #include <asm/uaccess.h>
+#include <asm/semaphore.h>
 
 #include <ib_mad.h>
 #include <ib_user_mad.h>
@@ -55,7 +55,7 @@ MODULE_DESCRIPTION("InfiniBand userspace
 MODULE_LICENSE("Dual BSD/GPL");
 
 enum {
-	IB_UMAD_MAX_PORTS  = 256,
+	IB_UMAD_MAX_PORTS  = 64,
 	IB_UMAD_MAX_AGENTS = 32
 };
 
@@ -63,6 +63,12 @@ struct ib_umad_port {
 	int                    devnum;
 	struct cdev            dev;
 	struct class_device    class_dev;
+
+	int                    sm_devnum;
+	struct cdev            sm_dev;
+	struct class_device    sm_class_dev;
+	struct semaphore       sm_sem;
+
 	struct ib_device      *ib_dev;
 	struct ib_umad_device *umad_dev;
 	u8                     port_num;
@@ -93,7 +99,7 @@ struct ib_umad_packet {
 
 static dev_t base_dev;
 static spinlock_t map_lock;
-static DECLARE_BITMAP(dev_map, IB_UMAD_MAX_PORTS);
+static DECLARE_BITMAP(dev_map, IB_UMAD_MAX_PORTS * 2);
 
 static void ib_umad_add_one(struct ib_device *device);
 static void ib_umad_remove_one(struct ib_device *device);
@@ -502,14 +508,62 @@ static int ib_umad_close(struct inode *i
 }
 
 static struct file_operations umad_fops = {
-	.owner 	 = THIS_MODULE,
-	.read 	 = ib_umad_read,
-	.write 	 = ib_umad_write,
-	.poll 	 = ib_umad_poll,
+	.owner 	        = THIS_MODULE,
+	.read 	        = ib_umad_read,
+	.write 	        = ib_umad_write,
+	.poll 	        = ib_umad_poll,
 	.unlocked_ioctl = ib_umad_ioctl,
-	.compat_ioctl = ib_umad_ioctl,
-	.open 	 = ib_umad_open,
-	.release = ib_umad_close
+	.compat_ioctl   = ib_umad_ioctl,
+	.open 	        = ib_umad_open,
+	.release        = ib_umad_close
+};
+
+static int ib_umad_sm_open(struct inode *inode, struct file *filp)
+{
+	struct ib_umad_port *port =
+		container_of(inode->i_cdev, struct ib_umad_port, sm_dev);
+	struct ib_port_modify props = {
+		.set_port_cap_mask = IB_PORT_SM
+	};
+	int ret;
+
+	if (filp->f_flags & O_NONBLOCK) {
+		if (down_trylock(&port->sm_sem))
+			return -EAGAIN;
+	} else {
+		if (down_interruptible(&port->sm_sem))
+			return -ERESTARTSYS;
+	}
+
+	ret = ib_modify_port(port->ib_dev, port->port_num, 0, &props);
+	if (ret) {
+		up(&port->sm_sem);
+		return ret;
+	}
+
+	filp->private_data = port;
+
+	return 0;
+}
+
+static int ib_umad_sm_close(struct inode *inode, struct file *filp)
+{
+	struct ib_umad_port *port = filp->private_data;
+	struct ib_port_modify props = {
+		.clr_port_cap_mask = IB_PORT_SM
+	};
+	int ret;
+
+	ret = ib_modify_port(port->ib_dev, port->port_num, 0, &props);
+	up(&port->sm_sem);
+
+	return ret;
+}
+
+static struct file_operations umad_sm_fops = {
+	.owner 	 = THIS_MODULE,
+	.open 	 = ib_umad_sm_open,
+	.release = ib_umad_sm_close
 };
 
 static struct ib_client umad_client = {
@@ -520,17 +574,18 @@ static struct ib_client umad_client = {
 
 static ssize_t show_dev(struct class_device *class_dev, char *buf)
 {
-	struct ib_umad_port *port =
-		container_of(class_dev, struct ib_umad_port, class_dev);
+	struct ib_umad_port *port = class_get_devdata(class_dev);
 
-	return print_dev_t(buf, port->dev.dev);
+	if (class_dev == &port->class_dev)
+		return print_dev_t(buf, port->dev.dev);
+	else
+		return print_dev_t(buf, port->sm_dev.dev);
 }
 static CLASS_DEVICE_ATTR(dev, S_IRUGO, show_dev, NULL);
 
 static ssize_t show_ibdev(struct class_device *class_dev, char *buf)
 {
-	struct ib_umad_port *port =
-		container_of(class_dev, struct ib_umad_port, class_dev);
+	struct ib_umad_port *port = class_get_devdata(class_dev);
 
 	return sprintf(buf, "%s\n", port->ib_dev->name);
 }
@@ -538,8 +593,7 @@ static CLASS_DEVICE_ATTR(ibdev, S_IRUGO,
 
 static ssize_t show_port(struct class_device *class_dev, char *buf)
 {
-	struct ib_umad_port *port =
-		container_of(class_dev, struct ib_umad_port, class_dev);
+	struct ib_umad_port *port = class_get_devdata(class_dev);
 
 	return sprintf(buf, "%d\n", port->port_num);
 }
@@ -555,11 +609,16 @@ static void ib_umad_release_dev(struct k
 
 static void ib_umad_release_port(struct class_device *class_dev)
 {
-	struct ib_umad_port *port =
-		container_of(class_dev, struct ib_umad_port, class_dev);
+	struct ib_umad_port *port = class_get_devdata(class_dev);
+
+	if (class_dev == &port->class_dev) {
+		cdev_del(&port->dev);
+		clear_bit(port->devnum, dev_map);
+	} else {
+		cdev_del(&port->sm_dev);
+		clear_bit(port->sm_devnum, dev_map);
+	}
 
-	cdev_del(&port->dev);
-	clear_bit(port->devnum, dev_map);
 	kref_put(&port->umad_dev->ref, ib_umad_release_dev);
 }
 
@@ -574,6 +633,94 @@ static ssize_t show_abi_version(struct c
 }
 static CLASS_ATTR(abi_version, S_IRUGO, show_abi_version, NULL);
 
+static int ib_umad_init_port(struct ib_device *device, int port_num,
+			     struct ib_umad_port *port)
+{
+	spin_lock(&map_lock);
+	port->devnum = find_first_zero_bit(dev_map, IB_UMAD_MAX_PORTS);
+	if (port->devnum >= IB_UMAD_MAX_PORTS) {
+		spin_unlock(&map_lock);
+		return -1;
+	}
+	port->sm_devnum = find_next_zero_bit(dev_map, IB_UMAD_MAX_PORTS * 2, IB_UMAD_MAX_PORTS);
+	if (port->sm_devnum >= IB_UMAD_MAX_PORTS * 2) {
+		spin_unlock(&map_lock);
+		return -1;
+	}
+	set_bit(port->devnum, dev_map);
+	set_bit(port->sm_devnum, dev_map);
+	spin_unlock(&map_lock);
+
+	port->ib_dev   = device;
+	port->port_num = port_num;
+	init_MUTEX(&port->sm_sem);
+
+	cdev_init(&port->dev, &umad_fops);
+	port->dev.owner = THIS_MODULE;
+	kobject_set_name(&port->dev.kobj, "umad%d", port->devnum);
+	if (cdev_add(&port->dev, base_dev + port->devnum, 1))
+		return -1;
+
+	port->class_dev.class = &umad_class;
+	port->class_dev.dev   = device->dma_device;
+
+	snprintf(port->class_dev.class_id, BUS_ID_SIZE, "umad%d", port->devnum);
+
+	if (class_device_register(&port->class_dev))
+		goto err_cdev;
+
+	class_set_devdata(&port->class_dev, port);
+	kref_get(&port->umad_dev->ref);
+
+	if (class_device_create_file(&port->class_dev, &class_device_attr_dev))
+		goto err_class;
+	if (class_device_create_file(&port->class_dev, &class_device_attr_ibdev))
+		goto err_class;
+	if (class_device_create_file(&port->class_dev, &class_device_attr_port))
+		goto err_class;
+
+	cdev_init(&port->sm_dev, &umad_sm_fops);
+	port->sm_dev.owner = THIS_MODULE;
+	kobject_set_name(&port->dev.kobj, "issm%d", port->sm_devnum - IB_UMAD_MAX_PORTS);
+	if (cdev_add(&port->sm_dev, base_dev + port->sm_devnum, 1))
+		return -1;
+
+	port->sm_class_dev.class = &umad_class;
+	port->sm_class_dev.dev   = device->dma_device;
+
+	snprintf(port->sm_class_dev.class_id, BUS_ID_SIZE, "issm%d", port->sm_devnum - IB_UMAD_MAX_PORTS);
+
+	if (class_device_register(&port->sm_class_dev))
+		goto err_sm_cdev;
+
+	class_set_devdata(&port->sm_class_dev, port);
+	kref_get(&port->umad_dev->ref);
+
+	if (class_device_create_file(&port->sm_class_dev, &class_device_attr_dev))
+		goto err_sm_class;
+	if (class_device_create_file(&port->sm_class_dev, &class_device_attr_ibdev))
+		goto err_sm_class;
+	if (class_device_create_file(&port->sm_class_dev, &class_device_attr_port))
+		goto err_sm_class;
+
+	return 0;
+
+err_sm_class:
+	class_device_unregister(&port->sm_class_dev);
+
+err_sm_cdev:
+	cdev_del(&port->sm_dev);
+
+err_class:
+	class_device_unregister(&port->class_dev);
+
+err_cdev:
+	cdev_del(&port->dev);
+	clear_bit(port->devnum, dev_map);
+
+	return -1;
+}
+
 static void ib_umad_add_one(struct ib_device *device)
 {
 	struct ib_umad_device *umad_dev;
@@ -602,58 +749,20 @@ static void ib_umad_add_one(struct ib_de
 
 	for (i = s; i <= e; ++i) {
 		umad_dev->port[i - s].umad_dev = umad_dev;
-		kref_get(&umad_dev->ref);
 
-		spin_lock(&map_lock);
-		umad_dev->port[i - s].devnum =
-			find_first_zero_bit(dev_map, IB_UMAD_MAX_PORTS);
-		if (umad_dev->port[i - s].devnum >= IB_UMAD_MAX_PORTS) {
-			spin_unlock(&map_lock);
+		if (ib_umad_init_port(device, i, &umad_dev->port[i - s]))
 			goto err;
-		}
-		set_bit(umad_dev->port[i - s].devnum, dev_map);
-		spin_unlock(&map_lock);
-
-		umad_dev->port[i - s].ib_dev   = device;
-		umad_dev->port[i - s].port_num = i;
-
-		cdev_init(&umad_dev->port[i - s].dev, &umad_fops);
-		umad_dev->port[i - s].dev.owner = THIS_MODULE;
-		kobject_set_name(&umad_dev->port[i - s].dev.kobj,
-				 "umad%d", umad_dev->port[i - s].devnum);
-		if (cdev_add(&umad_dev->port[i - s].dev, base_dev +
-			     umad_dev->port[i - s].devnum, 1))
-			goto err;
-
-		umad_dev->port[i - s].class_dev.class = &umad_class;
-		umad_dev->port[i - s].class_dev.dev   = device->dma_device;
-		snprintf(umad_dev->port[i - s].class_dev.class_id,
-			 BUS_ID_SIZE, "umad%d", umad_dev->port[i - s].devnum);
-		if (class_device_register(&umad_dev->port[i - s].class_dev))
-			goto err_class;
-
-		if (class_device_create_file(&umad_dev->port[i - s].class_dev,
-					     &class_device_attr_dev))
-			goto err_class;
-		if (class_device_create_file(&umad_dev->port[i - s].class_dev,
-					     &class_device_attr_ibdev))
-			goto err_class;
-		if (class_device_create_file(&umad_dev->port[i - s].class_dev,
-					     &class_device_attr_port))
-			goto err_class;
 	}
 
 	ib_set_client_data(device, &umad_client, umad_dev);
 
 	return;
 
-err_class:
-	cdev_del(&umad_dev->port[i - s].dev);
-	clear_bit(umad_dev->port[i - s].devnum, dev_map);
-
 err:
-	while (--i >= s)
+	while (--i >= s) {
 		class_device_unregister(&umad_dev->port[i - s].class_dev);
+		class_device_unregister(&umad_dev->port[i - s].sm_class_dev);
+	}
 
 	kref_put(&umad_dev->ref, ib_umad_release_dev);
 }
@@ -666,8 +775,10 @@ static void ib_umad_remove_one(struct ib
 	if (!umad_dev)
 		return;
 
-	for (i = 0; i <= umad_dev->end_port - umad_dev->start_port; ++i)
+	for (i = 0; i <= umad_dev->end_port - umad_dev->start_port; ++i) {
 		class_device_unregister(&umad_dev->port[i].class_dev);
+		class_device_unregister(&umad_dev->port[i].sm_class_dev);
+	}
 
 	kref_put(&umad_dev->ref, ib_umad_release_dev);
 }
@@ -678,7 +789,7 @@ static int __init ib_umad_init(void)
 
 	spin_lock_init(&map_lock);
 
-	ret = alloc_chrdev_region(&base_dev, 0, IB_UMAD_MAX_PORTS,
+	ret = alloc_chrdev_region(&base_dev, 0, IB_UMAD_MAX_PORTS * 2,
 				  "infiniband_mad");
 	if (ret) {
 		printk(KERN_ERR "user_mad: couldn't get device number\n");
@@ -705,13 +816,11 @@ static int __init ib_umad_init(void)
 
 	return 0;
 
-	ib_unregister_client(&umad_client);
-
 out_class:
 	class_unregister(&umad_class);
 
 out_chrdev:
-	unregister_chrdev_region(base_dev, IB_UMAD_MAX_PORTS);
+	unregister_chrdev_region(base_dev, IB_UMAD_MAX_PORTS * 2);
 
 out:
 	return ret;
@@ -721,7 +830,7 @@ static void __exit ib_umad_cleanup(void)
 {
 	ib_unregister_client(&umad_client);
 	class_unregister(&umad_class);
-	unregister_chrdev_region(base_dev, IB_UMAD_MAX_PORTS);
+	unregister_chrdev_region(base_dev, IB_UMAD_MAX_PORTS * 2);
 }
 
 module_init(ib_umad_init);
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/Kconfig linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/Kconfig
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/Kconfig	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/Kconfig	2005-01-26 15:43:26.100548961 +0100
@@ -14,13 +14,3 @@ config INFINIBAND_MTHCA_DEBUG
 	  This option causes the mthca driver produce a bunch of debug
 	  messages.  Select this is you are developing the driver or
 	  trying to diagnose a problem.
-
-config INFINIBAND_MTHCA_SSE_DOORBELL
-	bool "SSE doorbell code"
-	depends on INFINIBAND_MTHCA && X86 && !X86_64
-	default n
-	---help---
-	  This option will have the mthca driver use SSE instructions
-	  to ring hardware doorbell registers.  This may improve
-	  performance for some workloads, but the driver will not run
-	  on processors without SSE instructions.
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_cmd.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_cmd.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_cmd.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_cmd.c	2005-01-26 15:43:26.106548026 +0100
@@ -36,6 +36,7 @@
 #include <linux/pci.h>
 #include <linux/errno.h>
 #include <asm/io.h>
+#include <ib_mad.h>
 
 #include "mthca_dev.h"
 #include "mthca_config_reg.h"
@@ -509,7 +510,8 @@ int mthca_SYS_DIS(struct mthca_dev *dev,
 	return mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, HZ, status);
 }
 
-int mthca_MAP_FA(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status)
+static int mthca_map_cmd(struct mthca_dev *dev, u16 op, struct mthca_icm *icm,
+			 u64 virt, u8 *status)
 {
 	u32 *inbox;
 	dma_addr_t indma;
@@ -518,12 +520,17 @@ int mthca_MAP_FA(struct mthca_dev *dev, 
 	int nent = 0;
 	int i;
 	int err = 0;
-	int ts = 0;
+	int ts = 0, tc = 0;
 
 	inbox = pci_alloc_consistent(dev->pdev, PAGE_SIZE, &indma);
+	if (!inbox)
+		return -ENOMEM;
+
 	memset(inbox, 0, PAGE_SIZE);
 
-	for (mthca_icm_first(icm, &iter); !mthca_icm_last(&iter); mthca_icm_next(&iter)) {
+	for (mthca_icm_first(icm, &iter);
+	     !mthca_icm_last(&iter);
+	     mthca_icm_next(&iter)) {
 		/*
 		 * We have to pass pages that are aligned to their
 		 * size, so find the least significant 1 in the
@@ -538,13 +545,20 @@ int mthca_MAP_FA(struct mthca_dev *dev, 
 			goto out;
 		}
 		for (i = 0; i < mthca_icm_size(&iter) / (1 << lg); ++i, ++nent) {
+			if (virt != -1) {
+				*((__be64 *) (inbox + nent * 4)) =
+					cpu_to_be64(virt);
+				virt += 1 << lg;
+			}
+
 			*((__be64 *) (inbox + nent * 4 + 2)) =
 				cpu_to_be64((mthca_icm_addr(&iter) +
-					     (i << lg)) |
-					    (lg - 12));
+					     (i << lg)) | (lg - 12));
 			ts += 1 << (lg - 10);
+			++tc;
+
 			if (nent == PAGE_SIZE / 16) {
-				err = mthca_cmd(dev, indma, nent, 0, CMD_MAP_FA,
+				err = mthca_cmd(dev, indma, nent, 0, op,
 						CMD_TIME_CLASS_B, status);
 				if (err || *status)
 					goto out;
@@ -553,18 +567,33 @@ int mthca_MAP_FA(struct mthca_dev *dev, 
 		}
 	}
 
-	if (nent) {
-		err = mthca_cmd(dev, indma, nent, 0, CMD_MAP_FA,
+	if (nent)
+		err = mthca_cmd(dev, indma, nent, 0, op,
 				CMD_TIME_CLASS_B, status);
-	}
 
-	mthca_dbg(dev, "Mapped %d KB of host memory for FW.\n", ts);
+	switch (op) {
+	case CMD_MAP_FA:
+		mthca_dbg(dev, "Mapped %d chunks/%d KB for FW.\n", tc, ts);
+		break;
+	case CMD_MAP_ICM_AUX:
+		mthca_dbg(dev, "Mapped %d chunks/%d KB for ICM aux.\n", tc, ts);
+		break;
+	case CMD_MAP_ICM:
+		mthca_dbg(dev, "Mapped %d chunks/%d KB at %llx for ICM.\n",
+			  tc, ts, (unsigned long long) virt - (ts << 10));
+		break;
+	}
 
 out:
 	pci_free_consistent(dev->pdev, PAGE_SIZE, inbox, indma);
 	return err;
 }
 
+int mthca_MAP_FA(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status)
+{
+	return mthca_map_cmd(dev, CMD_MAP_FA, icm, -1, status);
+}
+
 int mthca_UNMAP_FA(struct mthca_dev *dev, u8 *status)
 {
 	return mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_FA, CMD_TIME_CLASS_B, status);
@@ -1068,8 +1097,11 @@ int mthca_INIT_HCA(struct mthca_dev *dev
 #define  INIT_HCA_MTT_BASE_OFFSET        (INIT_HCA_TPT_OFFSET + 0x10)
 #define INIT_HCA_UAR_OFFSET              0x120
 #define  INIT_HCA_UAR_BASE_OFFSET        (INIT_HCA_UAR_OFFSET + 0x00)
+#define  INIT_HCA_UARC_SZ_OFFSET         (INIT_HCA_UAR_OFFSET + 0x09)
+#define  INIT_HCA_LOG_UAR_SZ_OFFSET      (INIT_HCA_UAR_OFFSET + 0x0a)
 #define  INIT_HCA_UAR_PAGE_SZ_OFFSET     (INIT_HCA_UAR_OFFSET + 0x0b)
 #define  INIT_HCA_UAR_SCATCH_BASE_OFFSET (INIT_HCA_UAR_OFFSET + 0x10)
+#define  INIT_HCA_UAR_CTX_BASE_OFFSET    (INIT_HCA_UAR_OFFSET + 0x18)
 
 	inbox = pci_alloc_consistent(dev->pdev, INIT_HCA_IN_SIZE, &indma);
 	if (!inbox)
@@ -1117,7 +1149,8 @@ int mthca_INIT_HCA(struct mthca_dev *dev
 	/* TPT attributes */
 
 	MTHCA_PUT(inbox, param->mpt_base,   INIT_HCA_MPT_BASE_OFFSET);
-	MTHCA_PUT(inbox, param->mtt_seg_sz, INIT_HCA_MTT_SEG_SZ_OFFSET);
+	if (dev->hca_type != ARBEL_NATIVE)
+		MTHCA_PUT(inbox, param->mtt_seg_sz, INIT_HCA_MTT_SEG_SZ_OFFSET);
 	MTHCA_PUT(inbox, param->log_mpt_sz, INIT_HCA_LOG_MPT_SZ_OFFSET);
 	MTHCA_PUT(inbox, param->mtt_base,   INIT_HCA_MTT_BASE_OFFSET);
 
@@ -1125,7 +1158,14 @@ int mthca_INIT_HCA(struct mthca_dev *dev
 	{
 		u8 uar_page_sz = PAGE_SHIFT - 12;
 		MTHCA_PUT(inbox, uar_page_sz, INIT_HCA_UAR_PAGE_SZ_OFFSET);
-		MTHCA_PUT(inbox, param->uar_scratch_base, INIT_HCA_UAR_SCATCH_BASE_OFFSET);
+	}
+
+	MTHCA_PUT(inbox, param->uar_scratch_base, INIT_HCA_UAR_SCATCH_BASE_OFFSET);
+
+	if (dev->hca_type == ARBEL_NATIVE) {
+		MTHCA_PUT(inbox, param->log_uarc_sz, INIT_HCA_UARC_SZ_OFFSET);
+		MTHCA_PUT(inbox, param->log_uar_sz,  INIT_HCA_LOG_UAR_SZ_OFFSET);
+		MTHCA_PUT(inbox, param->uarc_base,   INIT_HCA_UAR_CTX_BASE_OFFSET);
 	}
 
 	err = mthca_cmd(dev, indma, 0, 0, CMD_INIT_HCA,
@@ -1199,6 +1239,103 @@ int mthca_CLOSE_HCA(struct mthca_dev *de
 	return mthca_cmd(dev, 0, 0, panic, CMD_CLOSE_HCA, HZ, status);
 }
 
+int mthca_SET_IB(struct mthca_dev *dev, struct mthca_set_ib_param *param,
+		 int port, u8 *status)
+{
+	u32 *inbox;
+	dma_addr_t indma;
+	int err;
+	u32 flags = 0;
+
+#define SET_IB_IN_SIZE         0x40
+#define SET_IB_FLAGS_OFFSET    0x00
+#define SET_IB_FLAG_SIG        (1 << 18)
+#define SET_IB_FLAG_RQK        (1 <<  0)
+#define SET_IB_CAP_MASK_OFFSET 0x04
+#define SET_IB_SI_GUID_OFFSET  0x08
+
+	inbox = pci_alloc_consistent(dev->pdev, SET_IB_IN_SIZE, &indma);
+	if (!inbox)
+		return -ENOMEM;
+
+	memset(inbox, 0, SET_IB_IN_SIZE);
+
+	flags |= param->set_si_guid     ? SET_IB_FLAG_SIG : 0;
+	flags |= param->reset_qkey_viol ? SET_IB_FLAG_RQK : 0;
+	MTHCA_PUT(inbox, flags, SET_IB_FLAGS_OFFSET);
+
+	MTHCA_PUT(inbox, param->cap_mask, SET_IB_CAP_MASK_OFFSET);
+	MTHCA_PUT(inbox, param->si_guid,  SET_IB_SI_GUID_OFFSET);
+
+	err = mthca_cmd(dev, indma, port, 0, CMD_SET_IB,
+			CMD_TIME_CLASS_B, status);
+
+	pci_free_consistent(dev->pdev, INIT_HCA_IN_SIZE, inbox, indma);
+	return err;
+}
+
+int mthca_MAP_ICM(struct mthca_dev *dev, struct mthca_icm *icm, u64 virt, u8 *status)
+{
+	return mthca_map_cmd(dev, CMD_MAP_ICM, icm, virt, status);
+}
+
+int mthca_MAP_ICM_page(struct mthca_dev *dev, u64 dma_addr, u64 virt, u8 *status)
+{
+	u64 *inbox;
+	dma_addr_t indma;
+	int err;
+
+	inbox = pci_alloc_consistent(dev->pdev, 16, &indma);
+	if (!inbox)
+		return -ENOMEM;
+
+	inbox[0] = cpu_to_be64(virt);
+	inbox[1] = cpu_to_be64(dma_addr | (PAGE_SHIFT - 12));
+
+	err = mthca_cmd(dev, indma, 1, 0, CMD_MAP_ICM, CMD_TIME_CLASS_B, status);
+
+	pci_free_consistent(dev->pdev, 16, inbox, indma);
+
+	if (!err)
+		mthca_dbg(dev, "Mapped page at %llx for ICM.\n",
+			  (unsigned long long) virt);
+
+	return err;
+}
+
+int mthca_UNMAP_ICM(struct mthca_dev *dev, u64 virt, u32 page_count, u8 *status)
+{
+	return mthca_cmd(dev, virt, page_count, 0, CMD_UNMAP_ICM, CMD_TIME_CLASS_B, status);
+}
+
+int mthca_MAP_ICM_AUX(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status)
+{
+	return mthca_map_cmd(dev, CMD_MAP_ICM_AUX, icm, -1, status);
+}
+
+int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev, u8 *status)
+{
+	return mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_ICM_AUX, CMD_TIME_CLASS_B, status);
+}
+
+int mthca_SET_ICM_SIZE(struct mthca_dev *dev, u64 icm_size, u64 *aux_pages,
+		       u8 *status)
+{
+	int ret = mthca_cmd_imm(dev, icm_size, aux_pages, 0, 0, CMD_SET_ICM_SIZE,
+				CMD_TIME_CLASS_A, status);
+
+	if (ret || status)
+		return ret;
+
+	/*
+	 * Arbel page size is always 4 KB; round up number of system
+	 * pages needed.
+	 */
+	*aux_pages = (*aux_pages + (1 << (PAGE_SHIFT - 12)) - 1) >> (PAGE_SHIFT - 12);
+
+	return 0;
+}
+
 int mthca_SW2HW_MPT(struct mthca_dev *dev, void *mpt_entry,
 		    int mpt_index, u8 *status)
 {
@@ -1490,13 +1627,24 @@ int mthca_CONF_SPECIAL_QP(struct mthca_d
 			 CMD_TIME_CLASS_B, status);
 }
 
-int mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int port,
-		  void *in_mad, void *response_mad, u8 *status) {
+int mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int ignore_bkey,
+		  int port, struct ib_wc* in_wc, struct ib_grh* in_grh,
+		  void *in_mad, void *response_mad, u8 *status)
+{
 	void *box;
 	dma_addr_t dma;
 	int err;
+	u32 in_modifier = port;
+	u8 op_modifier = 0;
 
-#define MAD_IFC_BOX_SIZE 512
+#define MAD_IFC_BOX_SIZE      0x400
+#define MAD_IFC_MY_QPN_OFFSET 0x100
+#define MAD_IFC_RQPN_OFFSET   0x104
+#define MAD_IFC_SL_OFFSET     0x108
+#define MAD_IFC_G_PATH_OFFSET 0x109
+#define MAD_IFC_RLID_OFFSET   0x10a
+#define MAD_IFC_PKEY_OFFSET   0x10e
+#define MAD_IFC_GRH_OFFSET    0x140
 
 	box = pci_alloc_consistent(dev->pdev, MAD_IFC_BOX_SIZE, &dma);
 	if (!box)
@@ -1504,11 +1652,46 @@ int mthca_MAD_IFC(struct mthca_dev *dev,
 
 	memcpy(box, in_mad, 256);
 
-	err = mthca_cmd_box(dev, dma, dma + 256, port, !!ignore_mkey,
+	/*
+	 * Key check traps can't be generated unless we have in_wc to
+	 * tell us where to send the trap.
+	 */
+	if (ignore_mkey || !in_wc)
+		op_modifier |= 0x1;
+	if (ignore_bkey || !in_wc)
+		op_modifier |= 0x2;
+
+	if (in_wc) {
+		u8 val;
+
+		memset(box + 256, 0, 256);
+
+		MTHCA_PUT(box, in_wc->qp_num, 	  MAD_IFC_MY_QPN_OFFSET);
+		MTHCA_PUT(box, in_wc->src_qp, 	  MAD_IFC_RQPN_OFFSET);
+
+		val = in_wc->sl << 4;
+		MTHCA_PUT(box, val,               MAD_IFC_SL_OFFSET);
+
+		val = in_wc->dlid_path_bits |
+			(in_wc->wc_flags & IB_WC_GRH ? 0x80 : 0);
+		MTHCA_PUT(box, val,               MAD_IFC_GRH_OFFSET);
+
+		MTHCA_PUT(box, in_wc->slid,       MAD_IFC_RLID_OFFSET);
+		MTHCA_PUT(box, in_wc->pkey_index, MAD_IFC_PKEY_OFFSET);
+
+		if (in_grh)
+			memcpy((u8 *) box + MAD_IFC_GRH_OFFSET, in_grh, 40);
+
+		op_modifier |= 0x10;
+
+		in_modifier |= in_wc->slid << 16;
+	}
+
+	err = mthca_cmd_box(dev, dma, dma + 512, in_modifier, op_modifier,
 			    CMD_MAD_IFC, CMD_TIME_CLASS_C, status);
 
 	if (!err && !*status)
-		memcpy(response_mad, box + 256, 256);
+		memcpy(response_mad, box + 512, 256);
 
 	pci_free_consistent(dev->pdev, MAD_IFC_BOX_SIZE, box, dma);
 	return err;
@@ -1574,3 +1757,8 @@ int mthca_MGID_HASH(struct mthca_dev *de
 	pci_unmap_single(dev->pdev, indma, 16, PCI_DMA_TODEVICE);
 	return err;
 }
+
+int mthca_NOP(struct mthca_dev *dev, u8 *status)
+{
+	return mthca_cmd(dev, 0, 0x1f, 0, CMD_NOP, msecs_to_jiffies(100), status);
+}
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_cmd.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_cmd.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_cmd.h	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_cmd.h	2005-01-26 15:43:26.108547715 +0100
@@ -174,27 +174,30 @@ struct mthca_adapter {
 
 struct mthca_init_hca_param {
 	u64 qpc_base;
-	u8  log_num_qps;
 	u64 eec_base;
-	u8  log_num_eecs;
 	u64 srqc_base;
-	u8  log_num_srqs;
 	u64 cqc_base;
-	u8  log_num_cqs;
 	u64 eqpc_base;
 	u64 eeec_base;
 	u64 eqc_base;
-	u8  log_num_eqs;
 	u64 rdb_base;
 	u64 mc_base;
+	u64 mpt_base;
+	u64 mtt_base;
+	u64 uar_scratch_base;
+	u64 uarc_base;
 	u16 log_mc_entry_sz;
 	u16 mc_hash_sz;
+	u8  log_num_qps;
+	u8  log_num_eecs;
+	u8  log_num_srqs;
+	u8  log_num_cqs;
+	u8  log_num_eqs;
 	u8  log_mc_table_sz;
-	u64 mpt_base;
 	u8  mtt_seg_sz;
 	u8  log_mpt_sz;
-	u64 mtt_base;
-	u64 uar_scratch_base;
+	u8  log_uar_sz;
+	u8  log_uarc_sz;
 };
 
 struct mthca_init_ib_param {
@@ -212,6 +215,13 @@ struct mthca_init_ib_param {
 	u64 si_guid;
 };
 
+struct mthca_set_ib_param {
+	int set_si_guid;
+	int reset_qkey_viol;
+	u64 si_guid;
+	u32 cap_mask;
+};
+
 int mthca_cmd_use_events(struct mthca_dev *dev);
 void mthca_cmd_use_polling(struct mthca_dev *dev);
 void mthca_cmd_event(struct mthca_dev *dev, u16 token,
@@ -238,6 +248,15 @@ int mthca_INIT_IB(struct mthca_dev *dev,
 		  int port, u8 *status);
 int mthca_CLOSE_IB(struct mthca_dev *dev, int port, u8 *status);
 int mthca_CLOSE_HCA(struct mthca_dev *dev, int panic, u8 *status);
+int mthca_SET_IB(struct mthca_dev *dev, struct mthca_set_ib_param *param,
+		 int port, u8 *status);
+int mthca_MAP_ICM(struct mthca_dev *dev, struct mthca_icm *icm, u64 virt, u8 *status);
+int mthca_MAP_ICM_page(struct mthca_dev *dev, u64 dma_addr, u64 virt, u8 *status);
+int mthca_UNMAP_ICM(struct mthca_dev *dev, u64 virt, u32 page_count, u8 *status);
+int mthca_MAP_ICM_AUX(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status);
+int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev, u8 *status);
+int mthca_SET_ICM_SIZE(struct mthca_dev *dev, u64 icm_size, u64 *aux_pages,
+		       u8 *status);
 int mthca_SW2HW_MPT(struct mthca_dev *dev, void *mpt_entry,
 		    int mpt_index, u8 *status);
 int mthca_HW2SW_MPT(struct mthca_dev *dev, void *mpt_entry,
@@ -261,7 +280,8 @@ int mthca_QUERY_QP(struct mthca_dev *dev
 		   void *qp_context, u8 *status);
 int mthca_CONF_SPECIAL_QP(struct mthca_dev *dev, int type, u32 qpn,
 			  u8 *status);
-int mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int port,
+int mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int ignore_bkey,
+		  int port, struct ib_wc* in_wc, struct ib_grh* in_grh,
 		  void *in_mad, void *response_mad, u8 *status);
 int mthca_READ_MGM(struct mthca_dev *dev, int index, void *mgm,
 		   u8 *status);
@@ -269,6 +289,7 @@ int mthca_WRITE_MGM(struct mthca_dev *de
 		    u8 *status);
 int mthca_MGID_HASH(struct mthca_dev *dev, void *gid, u16 *hash,
 		    u8 *status);
+int mthca_NOP(struct mthca_dev *dev, u8 *status);
 
 #define MAILBOX_ALIGN(x) ((void *) ALIGN((unsigned long) (x), MTHCA_CMD_MAILBOX_ALIGN))
 
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_config_reg.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_config_reg.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_config_reg.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_config_reg.h	2005-01-26 15:43:26.109547559 +0100
@@ -43,13 +43,8 @@
 #define MTHCA_ECR_SIZE         0x00008
 #define MTHCA_ECR_CLR_BASE     0x80708
 #define MTHCA_ECR_CLR_SIZE     0x00008
-#define MTHCA_ECR_OFFSET       (MTHCA_ECR_BASE     - MTHCA_HCR_BASE)
-#define MTHCA_ECR_CLR_OFFSET   (MTHCA_ECR_CLR_BASE - MTHCA_HCR_BASE)
+#define MTHCA_MAP_ECR_SIZE     (MTHCA_ECR_SIZE + MTHCA_ECR_CLR_SIZE)
 #define MTHCA_CLR_INT_BASE     0xf00d8
 #define MTHCA_CLR_INT_SIZE     0x00008
 
-#define MTHCA_MAP_HCR_SIZE     (MTHCA_ECR_CLR_BASE   + \
-			        MTHCA_ECR_CLR_SIZE   - \
-			        MTHCA_HCR_BASE)
-
 #endif /* MTHCA_CONFIG_REG_H */
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_dev.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_dev.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_dev.h	2005-01-22 02:47:29.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_dev.h	2005-01-26 15:43:26.111547247 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -153,10 +153,12 @@ struct mthca_pd_table {
 };
 
 struct mthca_mr_table {
-	struct mthca_alloc mpt_alloc;
-	int                max_mtt_order;
-	unsigned long    **mtt_buddy;
-	u64                mtt_base;
+	struct mthca_alloc      mpt_alloc;
+	int                     max_mtt_order;
+	unsigned long         **mtt_buddy;
+	u64                     mtt_base;
+	struct mthca_icm_table *mtt_table;
+	struct mthca_icm_table *mpt_table;
 };
 
 struct mthca_eq_table {
@@ -164,23 +166,29 @@ struct mthca_eq_table {
 	void __iomem      *clr_int;
 	u32                clr_mask;
 	struct mthca_eq    eq[MTHCA_NUM_EQ];
+	u64                icm_virt;
+	struct page       *icm_page;
+	dma_addr_t         icm_dma;
 	int                have_irq;
 	u8                 inta_pin;
 };
 
 struct mthca_cq_table {
-	struct mthca_alloc alloc;
-	spinlock_t         lock;
-	struct mthca_array cq;
+	struct mthca_alloc 	alloc;
+	spinlock_t         	lock;
+	struct mthca_array      cq;
+	struct mthca_icm_table *table;
 };
 
 struct mthca_qp_table {
-	struct mthca_alloc alloc;
-	u32                rdb_base;
-	int                rdb_shift;
-	int                sqp_start;
-	spinlock_t         lock;
-	struct mthca_array qp;
+	struct mthca_alloc     	alloc;
+	u32                    	rdb_base;
+	int                    	rdb_shift;
+	int                    	sqp_start;
+	spinlock_t             	lock;
+	struct mthca_array     	qp;
+	struct mthca_icm_table *qp_table;
+	struct mthca_icm_table *eqp_table;
 };
 
 struct mthca_av_table {
@@ -216,7 +224,8 @@ struct mthca_dev {
 			u64 clr_int_base;
 			u64 eq_arm_base;
 			u64 eq_set_ci_base;
-			struct mthca_icm *icm;
+			struct mthca_icm *fw_icm;
+			struct mthca_icm *aux_icm;
 			u16 fw_pages;
 		}        arbel;
 	}                fw;
@@ -225,8 +234,10 @@ struct mthca_dev {
 	u64              ddr_end;
 
 	MTHCA_DECLARE_DOORBELL_LOCK(doorbell_lock)
+	struct semaphore cap_mask_mutex;
 
 	void __iomem    *hcr;
+	void __iomem    *ecr_base;
 	void __iomem    *clr_base;
 	void __iomem    *kar;
 
@@ -329,6 +340,9 @@ int mthca_mr_alloc_phys(struct mthca_dev
 			u32 access, struct mthca_mr *mr);
 void mthca_free_mr(struct mthca_dev *dev, struct mthca_mr *mr);
 
+int mthca_map_eq_icm(struct mthca_dev *dev, u64 icm_virt);
+void mthca_unmap_eq_icm(struct mthca_dev *dev);
+
 int mthca_poll_cq(struct ib_cq *ibcq, int num_entries,
 		  struct ib_wc *entry);
 void mthca_arm_cq(struct mthca_dev *dev, struct mthca_cq *cq,
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_doorbell.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_doorbell.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_doorbell.h	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_doorbell.h	2005-01-26 15:43:26.112547091 +0100
@@ -32,9 +32,7 @@
  * $Id: mthca_doorbell.h 1349 2004-12-16 21:09:43Z roland $
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
-#include <linux/preempt.h>
 
 #define MTHCA_RD_DOORBELL      0x00
 #define MTHCA_SEND_DOORBELL    0x10
@@ -59,51 +57,13 @@ static inline void mthca_write64(u32 val
 	__raw_writeq(*(u64 *) val, dest);
 }
 
-#elif defined(CONFIG_INFINIBAND_MTHCA_SSE_DOORBELL)
-/* Use SSE to write 64 bits atomically without a lock. */
-
-#define MTHCA_DECLARE_DOORBELL_LOCK(name)
-#define MTHCA_INIT_DOORBELL_LOCK(ptr)    do { } while (0)
-#define MTHCA_GET_DOORBELL_LOCK(ptr)      (NULL)
-
-static inline unsigned long mthca_get_fpu(void)
-{
-	unsigned long cr0;
-
-	preempt_disable();
-	asm volatile("mov %%cr0,%0; clts" : "=r" (cr0));
-	return cr0;
-}
-
-static inline void mthca_put_fpu(unsigned long cr0)
-{
-	asm volatile("mov %0,%%cr0" : : "r" (cr0));
-	preempt_enable();
-}
-
-static inline void mthca_write64(u32 val[2], void __iomem *dest,
-				 spinlock_t *doorbell_lock)
-{
-	/* i386 stack is aligned to 8 bytes, so this should be OK: */
-	u8 xmmsave[8] __attribute__((aligned(8)));
-	unsigned long cr0;
-
-	cr0 = mthca_get_fpu();
-
-	asm volatile (
-		"movlps %%xmm0,(%0); \n\t"
-		"movlps (%1),%%xmm0; \n\t"
-		"movlps %%xmm0,(%2); \n\t"
-		"movlps (%0),%%xmm0; \n\t"
-		:
-		: "r" (xmmsave), "r" (val), "r" (dest)
-		: "memory" );
-
-	mthca_put_fpu(cr0);
-}
-
 #else
-/* Just fall back to a spinlock to protect the doorbell */
+
+/*
+ * Just fall back to a spinlock to protect the doorbell if
+ * BITS_PER_LONG is 32 -- there's no portable way to do atomic 64-bit
+ * MMIO writes.
+ */
 
 #define MTHCA_DECLARE_DOORBELL_LOCK(name) spinlock_t name;
 #define MTHCA_INIT_DOORBELL_LOCK(ptr)     spin_lock_init(ptr)
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_eq.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_eq.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_eq.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_eq.c	2005-01-26 15:43:26.115546624 +0100
@@ -164,12 +164,12 @@ static inline u64 async_mask(struct mthc
 		MTHCA_ASYNC_EVENT_MASK;
 }
 
-static inline void set_eq_ci(struct mthca_dev *dev, int eqn, int ci)
+static inline void set_eq_ci(struct mthca_dev *dev, struct mthca_eq *eq, u32 ci)
 {
 	u32 doorbell[2];
 
-	doorbell[0] = cpu_to_be32(MTHCA_EQ_DB_SET_CI | eqn);
-	doorbell[1] = cpu_to_be32(ci);
+	doorbell[0] = cpu_to_be32(MTHCA_EQ_DB_SET_CI | eq->eqn);
+	doorbell[1] = cpu_to_be32(ci & (eq->nent - 1));
 
 	mthca_write64(doorbell,
 		      dev->kar + MTHCA_EQ_DOORBELL,
@@ -200,21 +200,22 @@ static inline void disarm_cq(struct mthc
 		      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));
 }
 
-static inline struct mthca_eqe *get_eqe(struct mthca_eq *eq, int entry)
+static inline struct mthca_eqe *get_eqe(struct mthca_eq *eq, u32 entry)
 {
-	return eq->page_list[entry * MTHCA_EQ_ENTRY_SIZE / PAGE_SIZE].buf
-		+ (entry * MTHCA_EQ_ENTRY_SIZE) % PAGE_SIZE;
+	unsigned long off = (entry & (eq->nent - 1)) * MTHCA_EQ_ENTRY_SIZE;
+	return eq->page_list[off / PAGE_SIZE].buf + off % PAGE_SIZE;
 }
 
-static inline int next_eqe_sw(struct mthca_eq *eq)
+static inline struct mthca_eqe* next_eqe_sw(struct mthca_eq *eq)
 {
-	return !(MTHCA_EQ_ENTRY_OWNER_HW &
-		 get_eqe(eq, eq->cons_index)->owner);
+	struct mthca_eqe* eqe;
+	eqe = get_eqe(eq, eq->cons_index);
+	return (MTHCA_EQ_ENTRY_OWNER_HW & eqe->owner) ? NULL : eqe;
 }
 
-static inline void set_eqe_hw(struct mthca_eq *eq, int entry)
+static inline void set_eqe_hw(struct mthca_eqe *eqe)
 {
-	get_eqe(eq, entry)->owner =  MTHCA_EQ_ENTRY_OWNER_HW;
+	eqe->owner =  MTHCA_EQ_ENTRY_OWNER_HW;
 }
 
 static void port_change(struct mthca_dev *dev, int port, int active)
@@ -235,10 +236,10 @@ static void mthca_eq_int(struct mthca_de
 {
 	struct mthca_eqe *eqe;
 	int disarm_cqn;
+	int  eqes_found = 0;
 
-	while (next_eqe_sw(eq)) {
+	while ((eqe = next_eqe_sw(eq))) {
 		int set_ci = 0;
-		eqe = get_eqe(eq, eq->cons_index);
 
 		/*
 		 * Make sure we read EQ entry contents after we've
@@ -328,12 +329,13 @@ static void mthca_eq_int(struct mthca_de
 			break;
 		};
 
-		set_eqe_hw(eq, eq->cons_index);
-		eq->cons_index = (eq->cons_index + 1) & (eq->nent - 1);
+		set_eqe_hw(eqe);
+		++eq->cons_index;
+		eqes_found = 1;
 
 		if (set_ci) {
 			wmb(); /* see comment below */
-			set_eq_ci(dev, eq->eqn, eq->cons_index);
+			set_eq_ci(dev, eq, eq->cons_index);
 			set_ci = 0;
 		}
 	}
@@ -347,8 +349,10 @@ static void mthca_eq_int(struct mthca_de
 	 * possibility of the HCA writing an entry and then
 	 * having set_eqe_hw() overwrite the owner field.
 	 */
-	wmb();
-	set_eq_ci(dev, eq->eqn, eq->cons_index);
+	if (likely(eqes_found)) {
+		wmb();
+		set_eq_ci(dev, eq, eq->cons_index);
+	}
 	eq_req_not(dev, eq->eqn);
 }
 
@@ -362,10 +366,11 @@ static irqreturn_t mthca_interrupt(int i
 	if (dev->eq_table.clr_mask)
 		writel(dev->eq_table.clr_mask, dev->eq_table.clr_int);
 
-	while ((ecr = readl(dev->hcr + MTHCA_ECR_OFFSET + 4)) != 0) {
+	if ((ecr = readl(dev->ecr_base + 4)) != 0) {
 		work = 1;
 
-		writel(ecr, dev->hcr + MTHCA_ECR_CLR_OFFSET + 4);
+		writel(ecr, dev->ecr_base +
+		       MTHCA_ECR_CLR_BASE - MTHCA_ECR_BASE + 4);
 
 		for (i = 0; i < MTHCA_NUM_EQ; ++i)
 			if (ecr & dev->eq_table.eq[i].ecr_mask)
@@ -381,7 +386,6 @@ static irqreturn_t mthca_msi_x_interrupt
 	struct mthca_eq  *eq  = eq_ptr;
 	struct mthca_dev *dev = eq->dev;
 
-	writel(eq->ecr_mask, dev->hcr + MTHCA_ECR_CLR_OFFSET + 4);
 	mthca_eq_int(dev, eq);
 
 	/* MSI-X vectors always belong to us */
@@ -441,7 +445,7 @@ static int __devinit mthca_create_eq(str
 	}
 
 	for (i = 0; i < nent; ++i)
-		set_eqe_hw(eq, i);
+		set_eqe_hw(get_eqe(eq, i));
 
 	eq->eqn = mthca_alloc(&dev->eq_table.alloc);
 	if (eq->eqn == -1)
@@ -574,6 +578,50 @@ static void mthca_free_irqs(struct mthca
 				 dev->eq_table.eq + i);
 }
 
+int __devinit mthca_map_eq_icm(struct mthca_dev *dev, u64 icm_virt)
+{
+	int ret;
+	u8 status;
+
+	/*
+	 * We assume that mapping one page is enough for the whole EQ
+	 * context table.  This is fine with all current HCAs, because
+	 * we only use 32 EQs and each EQ uses 32 bytes of context
+	 * memory, or 1 KB total.
+	 */
+	dev->eq_table.icm_virt = icm_virt;
+	dev->eq_table.icm_page = alloc_page(GFP_HIGHUSER);
+	if (!dev->eq_table.icm_page)
+		return -ENOMEM;
+	dev->eq_table.icm_dma  = pci_map_page(dev->pdev, dev->eq_table.icm_page, 0,
+					      PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
+	if (pci_dma_mapping_error(dev->eq_table.icm_dma)) {
+		__free_page(dev->eq_table.icm_page);
+		return -ENOMEM;
+	}
+
+	ret = mthca_MAP_ICM_page(dev, dev->eq_table.icm_dma, icm_virt, &status);
+	if (!ret && status)
+		ret = -EINVAL;
+	if (ret) {
+		pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, PAGE_SIZE,
+			       PCI_DMA_BIDIRECTIONAL);
+		__free_page(dev->eq_table.icm_page);
+	}
+
+	return ret;
+}
+
+void __devexit mthca_unmap_eq_icm(struct mthca_dev *dev)
+{
+	u8 status;
+
+	mthca_UNMAP_ICM(dev, dev->eq_table.icm_virt, PAGE_SIZE / 4096, &status);
+	pci_unmap_page(dev->pdev, dev->eq_table.icm_dma, PAGE_SIZE,
+		       PCI_DMA_BIDIRECTIONAL);
+	__free_page(dev->eq_table.icm_page);
+}
+
 int __devinit mthca_init_eq_table(struct mthca_dev *dev)
 {
 	int err;
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_mad.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_mad.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_mad.c	2005-01-22 02:49:13.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_mad.c	2005-01-26 15:43:26.117546312 +0100
@@ -232,8 +232,9 @@ int mthca_process_mad(struct ib_device *
 		return IB_MAD_RESULT_SUCCESS;
 
 	err = mthca_MAD_IFC(to_mdev(ibdev),
-			    !!(mad_flags & IB_MAD_IGNORE_MKEY),
-			    port_num, in_mad, out_mad,
+			    mad_flags & IB_MAD_IGNORE_MKEY,
+			    mad_flags & IB_MAD_IGNORE_BKEY,
+			    port_num, in_wc, in_grh, in_mad, out_mad,
 			    &status);
 	if (err) {
 		mthca_err(to_mdev(ibdev), "MAD_IFC failed\n");
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_main.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_main.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_main.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_main.c	2005-01-26 15:43:26.126544910 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -40,10 +40,6 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 
-#ifdef CONFIG_INFINIBAND_MTHCA_SSE_DOORBELL
-#include <asm/cpufeature.h>
-#endif
-
 #include "mthca_dev.h"
 #include "mthca_config_reg.h"
 #include "mthca_cmd.h"
@@ -82,12 +78,9 @@ static struct mthca_profile default_prof
 	.num_cq     = 1 << 16,
 	.num_mcg    = 1 << 13,
 	.num_mpt    = 1 << 17,
-	.num_mtt    = 1 << 20
-};
-
-enum {
-	MTHCA_TAVOR_NUM_UDAV  = 1 << 15,
-	MTHCA_ARBEL_UARC_SIZE = 1 << 18
+	.num_mtt    = 1 << 20,
+	.num_udav   = 1 << 15,	/* Tavor only */
+	.uarc_size  = 1 << 18,	/* Arbel only */
 };
 
 static int __devinit mthca_tune_pci(struct mthca_dev *mdev)
@@ -207,58 +200,58 @@ static int __devinit mthca_init_tavor(st
 	err = mthca_QUERY_FW(mdev, &status);
 	if (err) {
 		mthca_err(mdev, "QUERY_FW command failed, aborting.\n");
-		goto err_out_disable;
+		goto err_disable;
 	}
 	if (status) {
 		mthca_err(mdev, "QUERY_FW returned status 0x%02x, "
 			  "aborting.\n", status);
 		err = -EINVAL;
-		goto err_out_disable;
+		goto err_disable;
 	}
 	err = mthca_QUERY_DDR(mdev, &status);
 	if (err) {
 		mthca_err(mdev, "QUERY_DDR command failed, aborting.\n");
-		goto err_out_disable;
+		goto err_disable;
 	}
 	if (status) {
 		mthca_err(mdev, "QUERY_DDR returned status 0x%02x, "
 			  "aborting.\n", status);
 		err = -EINVAL;
-		goto err_out_disable;
+		goto err_disable;
 	}
 
 	err = mthca_dev_lim(mdev, &dev_lim);
 
 	profile = default_profile;
-	profile.num_uar  = dev_lim.uar_size / PAGE_SIZE;
-	profile.num_udav = MTHCA_TAVOR_NUM_UDAV;
+	profile.num_uar   = dev_lim.uar_size / PAGE_SIZE;
+	profile.uarc_size = 0;
 
 	err = mthca_make_profile(mdev, &profile, &dev_lim, &init_hca);
-	if (err)
-		goto err_out_disable;
+	if (err < 0)
+		goto err_disable;
 
 	err = mthca_INIT_HCA(mdev, &init_hca, &status);
 	if (err) {
 		mthca_err(mdev, "INIT_HCA command failed, aborting.\n");
-		goto err_out_disable;
+		goto err_disable;
 	}
 	if (status) {
 		mthca_err(mdev, "INIT_HCA returned status 0x%02x, "
 			  "aborting.\n", status);
 		err = -EINVAL;
-		goto err_out_disable;
+		goto err_disable;
 	}
 
 	err = mthca_QUERY_ADAPTER(mdev, &adapter, &status);
 	if (err) {
 		mthca_err(mdev, "QUERY_ADAPTER command failed, aborting.\n");
-		goto err_out_disable;
+		goto err_close;
 	}
 	if (status) {
 		mthca_err(mdev, "QUERY_ADAPTER returned status 0x%02x, "
 			  "aborting.\n", status);
 		err = -EINVAL;
-		goto err_out_close;
+		goto err_close;
 	}
 
 	mdev->eq_table.inta_pin = adapter.inta_pin;
@@ -266,10 +259,10 @@ static int __devinit mthca_init_tavor(st
 
 	return 0;
 
-err_out_close:
+err_close:
 	mthca_CLOSE_HCA(mdev, 0, &status);
 
-err_out_disable:
+err_disable:
 	mthca_SYS_DIS(mdev, &status);
 
 	return err;
@@ -282,15 +275,15 @@ static int __devinit mthca_load_fw(struc
 
 	/* FIXME: use HCA-attached memory for FW if present */
 
-	mdev->fw.arbel.icm =
+	mdev->fw.arbel.fw_icm =
 		mthca_alloc_icm(mdev, mdev->fw.arbel.fw_pages,
 				GFP_HIGHUSER | __GFP_NOWARN);
-	if (!mdev->fw.arbel.icm) {
+	if (!mdev->fw.arbel.fw_icm) {
 		mthca_err(mdev, "Couldn't allocate FW area, aborting.\n");
 		return -ENOMEM;
 	}
 
-	err = mthca_MAP_FA(mdev, mdev->fw.arbel.icm, &status);
+	err = mthca_MAP_FA(mdev, mdev->fw.arbel.fw_icm, &status);
 	if (err) {
 		mthca_err(mdev, "MAP_FA command failed, aborting.\n");
 		goto err_free;
@@ -317,13 +310,146 @@ err_unmap_fa:
 	mthca_UNMAP_FA(mdev, &status);
 
 err_free:
-	mthca_free_icm(mdev, mdev->fw.arbel.icm);
+	mthca_free_icm(mdev, mdev->fw.arbel.fw_icm);
+	return err;
+}
+
+static int __devinit mthca_init_icm(struct mthca_dev *mdev,
+				    struct mthca_dev_lim *dev_lim,
+				    struct mthca_init_hca_param *init_hca,
+				    u64 icm_size)
+{
+	u64 aux_pages;
+	u8 status;
+	int err;
+
+	err = mthca_SET_ICM_SIZE(mdev, icm_size, &aux_pages, &status);
+	if (err) {
+		mthca_err(mdev, "SET_ICM_SIZE command failed, aborting.\n");
+		return err;
+	}
+	if (status) {
+		mthca_err(mdev, "SET_ICM_SIZE returned status 0x%02x, "
+			  "aborting.\n", status);
+		return -EINVAL;
+	}
+
+	mthca_dbg(mdev, "%lld KB of HCA context requires %lld KB aux memory.\n",
+		  (unsigned long long) icm_size >> 10,
+		  (unsigned long long) aux_pages << 2);
+
+	mdev->fw.arbel.aux_icm = mthca_alloc_icm(mdev, aux_pages,
+						 GFP_HIGHUSER | __GFP_NOWARN);
+	if (!mdev->fw.arbel.aux_icm) {
+		mthca_err(mdev, "Couldn't allocate aux memory, aborting.\n");
+		return -ENOMEM;
+	}
+
+	err = mthca_MAP_ICM_AUX(mdev, mdev->fw.arbel.aux_icm, &status);
+	if (err) {
+		mthca_err(mdev, "MAP_ICM_AUX command failed, aborting.\n");
+		goto err_free_aux;
+	}
+	if (status) {
+		mthca_err(mdev, "MAP_ICM_AUX returned status 0x%02x, aborting.\n", status);
+		err = -EINVAL;
+		goto err_free_aux;
+	}
+
+	err = mthca_map_eq_icm(mdev, init_hca->eqc_base);
+	if (err) {
+		mthca_err(mdev, "Failed to map EQ context memory, aborting.\n");
+		goto err_unmap_aux;
+	}
+
+	mdev->mr_table.mtt_table = mthca_alloc_icm_table(mdev, init_hca->mtt_base,
+							 mdev->limits.num_mtt_segs *
+							 init_hca->mtt_seg_sz,
+							 mdev->limits.reserved_mtts *
+							 init_hca->mtt_seg_sz, 1);
+	if (!mdev->mr_table.mtt_table) {
+		mthca_err(mdev, "Failed to map MTT context memory, aborting.\n");
+		err = -ENOMEM;
+		goto err_unmap_eq;
+	}
+
+	mdev->mr_table.mpt_table = mthca_alloc_icm_table(mdev, init_hca->mpt_base,
+							 mdev->limits.num_mpts *
+							 dev_lim->mpt_entry_sz,
+							 mdev->limits.reserved_mrws *
+							 dev_lim->mpt_entry_sz, 1);
+	if (!mdev->mr_table.mpt_table) {
+		mthca_err(mdev, "Failed to map MPT context memory, aborting.\n");
+		err = -ENOMEM;
+		goto err_unmap_mtt;
+	}
+
+	mdev->qp_table.qp_table = mthca_alloc_icm_table(mdev, init_hca->qpc_base,
+							mdev->limits.num_qps *
+							dev_lim->qpc_entry_sz,
+							mdev->limits.reserved_qps *
+							dev_lim->qpc_entry_sz, 1);
+	if (!mdev->qp_table.qp_table) {
+		mthca_err(mdev, "Failed to map QP context memory, aborting.\n");
+		err = -ENOMEM;
+		goto err_unmap_mpt;
+	}
+
+	mdev->qp_table.eqp_table = mthca_alloc_icm_table(mdev, init_hca->eqpc_base,
+							 mdev->limits.num_qps *
+							 dev_lim->eqpc_entry_sz,
+							 mdev->limits.reserved_qps *
+							 dev_lim->eqpc_entry_sz, 1);
+	if (!mdev->qp_table.eqp_table) {
+		mthca_err(mdev, "Failed to map EQP context memory, aborting.\n");
+		err = -ENOMEM;
+		goto err_unmap_qp;
+	}
+
+	mdev->cq_table.table = mthca_alloc_icm_table(mdev, init_hca->cqc_base,
+						     mdev->limits.num_cqs *
+						     dev_lim->cqc_entry_sz,
+						     mdev->limits.reserved_cqs *
+						     dev_lim->cqc_entry_sz, 1);
+	if (!mdev->cq_table.table) {
+		mthca_err(mdev, "Failed to map CQ context memory, aborting.\n");
+		err = -ENOMEM;
+		goto err_unmap_eqp;
+	}
+
+	return 0;
+
+err_unmap_eqp:
+	mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
+
+err_unmap_qp:
+	mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
+
+err_unmap_mpt:
+	mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
+
+err_unmap_mtt:
+	mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
+
+err_unmap_eq:
+	mthca_unmap_eq_icm(mdev);
+
+err_unmap_aux:
+	mthca_UNMAP_ICM_AUX(mdev, &status);
+
+err_free_aux:
+	mthca_free_icm(mdev, mdev->fw.arbel.aux_icm);
+
 	return err;
 }
 
 static int __devinit mthca_init_arbel(struct mthca_dev *mdev)
 {
-	struct mthca_dev_lim dev_lim;
+	struct mthca_dev_lim        dev_lim;
+	struct mthca_profile        profile;
+	struct mthca_init_hca_param init_hca;
+	struct mthca_adapter        adapter;
+	u64 icm_size;
 	u8 status;
 	int err;
 
@@ -355,26 +481,77 @@ static int __devinit mthca_init_arbel(st
 	err = mthca_load_fw(mdev);
 	if (err) {
 		mthca_err(mdev, "Failed to start FW, aborting.\n");
-		goto err_out_disable;
+		goto err_disable;
 	}
 
 	err = mthca_dev_lim(mdev, &dev_lim);
 	if (err) {
 		mthca_err(mdev, "QUERY_DEV_LIM command failed, aborting.\n");
-		goto err_out_stop_fw;
+		goto err_stop_fw;
 	}
 
-	mthca_warn(mdev, "Sorry, native MT25208 mode support is not done, "
-		   "aborting.\n");
-	err = -ENODEV;
+	profile = default_profile;
+	profile.num_uar  = dev_lim.uar_size / PAGE_SIZE;
+	profile.num_udav = 0;
+
+	icm_size = mthca_make_profile(mdev, &profile, &dev_lim, &init_hca);
+	if ((int) icm_size < 0) {
+		err = icm_size;
+		goto err_stop_fw;
+	}
+
+	err = mthca_init_icm(mdev, &dev_lim, &init_hca, icm_size);
+	if (err)
+		goto err_stop_fw;
 
-err_out_stop_fw:
+	err = mthca_INIT_HCA(mdev, &init_hca, &status);
+	if (err) {
+		mthca_err(mdev, "INIT_HCA command failed, aborting.\n");
+		goto err_free_icm;
+	}
+	if (status) {
+		mthca_err(mdev, "INIT_HCA returned status 0x%02x, "
+			  "aborting.\n", status);
+		err = -EINVAL;
+		goto err_free_icm;
+	}
+
+	err = mthca_QUERY_ADAPTER(mdev, &adapter, &status);
+	if (err) {
+		mthca_err(mdev, "QUERY_ADAPTER command failed, aborting.\n");
+		goto err_free_icm;
+	}
+	if (status) {
+		mthca_err(mdev, "QUERY_ADAPTER returned status 0x%02x, "
+			  "aborting.\n", status);
+		err = -EINVAL;
+		goto err_free_icm;
+	}
+
+	mdev->eq_table.inta_pin = adapter.inta_pin;
+	mdev->rev_id            = adapter.revision_id;
+
+	return 0;
+
+err_free_icm:
+	mthca_free_icm_table(mdev, mdev->cq_table.table);
+	mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
+	mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
+	mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
+	mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
+	mthca_unmap_eq_icm(mdev);
+
+	mthca_UNMAP_ICM_AUX(mdev, &status);
+	mthca_free_icm(mdev, mdev->fw.arbel.aux_icm);
+
+err_stop_fw:
 	mthca_UNMAP_FA(mdev, &status);
-	mthca_free_icm(mdev, mdev->fw.arbel.icm);
+	mthca_free_icm(mdev, mdev->fw.arbel.fw_icm);
 
-err_out_disable:
+err_disable:
 	if (!(mdev->mthca_flags & MTHCA_FLAG_NO_LAM))
 		mthca_DISABLE_LAM(mdev, &status);
+
 	return err;
 }
 
@@ -389,6 +566,7 @@ static int __devinit mthca_init_hca(stru
 static int __devinit mthca_setup_hca(struct mthca_dev *dev)
 {
 	int err;
+	u8 status;
 
 	MTHCA_INIT_DOORBELL_LOCK(&dev->doorbell_lock);
 
@@ -403,82 +581,101 @@ static int __devinit mthca_setup_hca(str
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "memory region table, aborting.\n");
-		goto err_out_pd_table_free;
+		goto err_pd_table_free;
 	}
 
 	err = mthca_pd_alloc(dev, &dev->driver_pd);
 	if (err) {
 		mthca_err(dev, "Failed to create driver PD, "
 			  "aborting.\n");
-		goto err_out_mr_table_free;
+		goto err_mr_table_free;
+	}
+
+	if (dev->hca_type == ARBEL_NATIVE) {
+		mthca_warn(dev, "Sorry, native MT25208 mode support is not done, "
+			   "aborting.\n");
+		err = -ENODEV;
+		goto err_pd_free;
 	}
 
 	err = mthca_init_eq_table(dev);
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "event queue table, aborting.\n");
-		goto err_out_pd_free;
+		goto err_pd_free;
 	}
 
 	err = mthca_cmd_use_events(dev);
 	if (err) {
 		mthca_err(dev, "Failed to switch to event-driven "
 			  "firmware commands, aborting.\n");
-		goto err_out_eq_table_free;
+		goto err_eq_table_free;
 	}
 
+	err = mthca_NOP(dev, &status);
+	if (err || status) {
+		mthca_err(dev, "NOP command failed to generate interrupt, aborting.\n");
+		if (dev->mthca_flags & (MTHCA_FLAG_MSI | MTHCA_FLAG_MSI_X))
+			mthca_err(dev, "Try again with MSI/MSI-X disabled.\n");
+		else
+			mthca_err(dev, "BIOS or ACPI interrupt routing problem?\n");
+
+		goto err_cmd_poll;
+	} else
+		mthca_dbg(dev, "NOP command IRQ test passed\n");
+
 	err = mthca_init_cq_table(dev);
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "completion queue table, aborting.\n");
-		goto err_out_cmd_poll;
+		goto err_cmd_poll;
 	}
 
 	err = mthca_init_qp_table(dev);
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "queue pair table, aborting.\n");
-		goto err_out_cq_table_free;
+		goto err_cq_table_free;
 	}
 
 	err = mthca_init_av_table(dev);
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "address vector table, aborting.\n");
-		goto err_out_qp_table_free;
+		goto err_qp_table_free;
 	}
 
 	err = mthca_init_mcg_table(dev);
 	if (err) {
 		mthca_err(dev, "Failed to initialize "
 			  "multicast group table, aborting.\n");
-		goto err_out_av_table_free;
+		goto err_av_table_free;
 	}
 
 	return 0;
 
-err_out_av_table_free:
+err_av_table_free:
 	mthca_cleanup_av_table(dev);
 
-err_out_qp_table_free:
+err_qp_table_free:
 	mthca_cleanup_qp_table(dev);
 
-err_out_cq_table_free:
+err_cq_table_free:
 	mthca_cleanup_cq_table(dev);
 
-err_out_cmd_poll:
+err_cmd_poll:
 	mthca_cmd_use_polling(dev);
 
-err_out_eq_table_free:
+err_eq_table_free:
 	mthca_cleanup_eq_table(dev);
 
-err_out_pd_free:
+err_pd_free:
 	mthca_pd_free(dev, &dev->driver_pd);
 
-err_out_mr_table_free:
+err_mr_table_free:
 	mthca_cleanup_mr_table(dev);
 
-err_out_pd_table_free:
+err_pd_table_free:
 	mthca_cleanup_pd_table(dev);
 	return err;
 }
@@ -498,57 +695,83 @@ static int __devinit mthca_request_regio
 	 */
 	if (!request_mem_region(pci_resource_start(pdev, 0) +
 				MTHCA_HCR_BASE,
-				MTHCA_MAP_HCR_SIZE,
-				DRV_NAME))
-		return -EBUSY;
+				MTHCA_HCR_SIZE,
+				DRV_NAME)) {
+		err = -EBUSY;
+		goto err_hcr_failed;
+	}
+
+	if (!request_mem_region(pci_resource_start(pdev, 0) +
+				MTHCA_ECR_BASE,
+				MTHCA_MAP_ECR_SIZE,
+				DRV_NAME)) {
+		err = -EBUSY;
+		goto err_ecr_failed;
+	}
 
 	if (!request_mem_region(pci_resource_start(pdev, 0) +
 				MTHCA_CLR_INT_BASE,
 				MTHCA_CLR_INT_SIZE,
 				DRV_NAME)) {
 		err = -EBUSY;
-		goto err_out_bar0_beg;
+		goto err_int_failed;
 	}
 
+
 	err = pci_request_region(pdev, 2, DRV_NAME);
 	if (err)
-		goto err_out_bar0_end;
+		goto err_bar2_failed;
 
 	if (!ddr_hidden) {
 		err = pci_request_region(pdev, 4, DRV_NAME);
 		if (err)
-			goto err_out_bar2;
+			goto err_bar4_failed;
 	}
 
 	return 0;
 
-err_out_bar0_beg:
-	release_mem_region(pci_resource_start(pdev, 0) +
-			   MTHCA_HCR_BASE,
-			   MTHCA_MAP_HCR_SIZE);
+err_bar4_failed:
+
+	pci_release_region(pdev, 2);
+err_bar2_failed:
 
-err_out_bar0_end:
 	release_mem_region(pci_resource_start(pdev, 0) +
 			   MTHCA_CLR_INT_BASE,
 			   MTHCA_CLR_INT_SIZE);
+err_int_failed:
+
+	release_mem_region(pci_resource_start(pdev, 0) +
+			   MTHCA_ECR_BASE,
+			   MTHCA_MAP_ECR_SIZE);
+err_ecr_failed:
+
+	release_mem_region(pci_resource_start(pdev, 0) +
+			   MTHCA_HCR_BASE,
+			   MTHCA_HCR_SIZE);
+err_hcr_failed:
 
-err_out_bar2:
-	pci_release_region(pdev, 2);
 	return err;
 }
 
 static void mthca_release_regions(struct pci_dev *pdev,
 				  int ddr_hidden)
 {
-	release_mem_region(pci_resource_start(pdev, 0) +
-			   MTHCA_HCR_BASE,
-			   MTHCA_MAP_HCR_SIZE);
+	if (!ddr_hidden)
+		pci_release_region(pdev, 4);
+
+	pci_release_region(pdev, 2);
+
 	release_mem_region(pci_resource_start(pdev, 0) +
 			   MTHCA_CLR_INT_BASE,
 			   MTHCA_CLR_INT_SIZE);
-	pci_release_region(pdev, 2);
-	if (!ddr_hidden)
-		pci_release_region(pdev, 4);
+
+	release_mem_region(pci_resource_start(pdev, 0) +
+			   MTHCA_ECR_BASE,
+			   MTHCA_MAP_ECR_SIZE);
+
+	release_mem_region(pci_resource_start(pdev, 0) +
+			   MTHCA_HCR_BASE,
+			   MTHCA_HCR_SIZE);
 }
 
 static int __devinit mthca_enable_msi_x(struct mthca_dev *mdev)
@@ -582,8 +805,18 @@ static void mthca_close_hca(struct mthca
 	mthca_CLOSE_HCA(mdev, 0, &status);
 
 	if (mdev->hca_type == ARBEL_NATIVE) {
+		mthca_free_icm_table(mdev, mdev->cq_table.table);
+		mthca_free_icm_table(mdev, mdev->qp_table.eqp_table);
+		mthca_free_icm_table(mdev, mdev->qp_table.qp_table);
+		mthca_free_icm_table(mdev, mdev->mr_table.mpt_table);
+		mthca_free_icm_table(mdev, mdev->mr_table.mtt_table);
+		mthca_unmap_eq_icm(mdev);
+
+		mthca_UNMAP_ICM_AUX(mdev, &status);
+		mthca_free_icm(mdev, mdev->fw.arbel.aux_icm);
+
 		mthca_UNMAP_FA(mdev, &status);
-		mthca_free_icm(mdev, mdev->fw.arbel.icm);
+		mthca_free_icm(mdev, mdev->fw.arbel.fw_icm);
 
 		if (!(mdev->mthca_flags & MTHCA_FLAG_NO_LAM))
 			mthca_DISABLE_LAM(mdev, &status);
@@ -623,13 +856,13 @@ static int __devinit mthca_init_one(stru
 	    pci_resource_len(pdev, 0) != 1 << 20) {
 		dev_err(&pdev->dev, "Missing DCS, aborting.");
 		err = -ENODEV;
-		goto err_out_disable_pdev;
+		goto err_disable_pdev;
 	}
 	if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM) ||
 	    pci_resource_len(pdev, 2) != 1 << 23) {
 		dev_err(&pdev->dev, "Missing UAR, aborting.");
 		err = -ENODEV;
-		goto err_out_disable_pdev;
+		goto err_disable_pdev;
 	}
 	if (!(pci_resource_flags(pdev, 4) & IORESOURCE_MEM))
 		ddr_hidden = 1;
@@ -638,7 +871,7 @@ static int __devinit mthca_init_one(stru
 	if (err) {
 		dev_err(&pdev->dev, "Cannot obtain PCI resources, "
 			"aborting.\n");
-		goto err_out_disable_pdev;
+		goto err_disable_pdev;
 	}
 
 	pci_set_master(pdev);
@@ -649,7 +882,7 @@ static int __devinit mthca_init_one(stru
 		err = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
 		if (err) {
 			dev_err(&pdev->dev, "Can't set PCI DMA mask, aborting.\n");
-			goto err_out_free_res;
+			goto err_free_res;
 		}
 	}
 	err = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
@@ -660,7 +893,7 @@ static int __devinit mthca_init_one(stru
 		if (err) {
 			dev_err(&pdev->dev, "Can't set consistent PCI DMA mask, "
 				"aborting.\n");
-			goto err_out_free_res;
+			goto err_free_res;
 		}
 	}
 
@@ -669,7 +902,7 @@ static int __devinit mthca_init_one(stru
 		dev_err(&pdev->dev, "Device struct alloc failed, "
 			"aborting.\n");
 		err = -ENOMEM;
-		goto err_out_free_res;
+		goto err_free_res;
 	}
 
 	mdev->pdev     = pdev;
@@ -686,7 +919,7 @@ static int __devinit mthca_init_one(stru
 	err = mthca_reset(mdev);
 	if (err) {
 		mthca_err(mdev, "Failed to reset HCA, aborting.\n");
-		goto err_out_free_dev;
+		goto err_free_dev;
 	}
 
 	if (msi_x && !mthca_enable_msi_x(mdev))
@@ -700,20 +933,30 @@ static int __devinit mthca_init_one(stru
 	mdev->cmd.use_events = 0;
 
 	mthca_base = pci_resource_start(pdev, 0);
-	mdev->hcr = ioremap(mthca_base + MTHCA_HCR_BASE, MTHCA_MAP_HCR_SIZE);
+	mdev->hcr = ioremap(mthca_base + MTHCA_HCR_BASE, MTHCA_HCR_SIZE);
 	if (!mdev->hcr) {
 		mthca_err(mdev, "Couldn't map command register, "
 			  "aborting.\n");
 		err = -ENOMEM;
-		goto err_out_free_dev;
+		goto err_free_dev;
 	}
+
 	mdev->clr_base = ioremap(mthca_base + MTHCA_CLR_INT_BASE,
 				 MTHCA_CLR_INT_SIZE);
 	if (!mdev->clr_base) {
-		mthca_err(mdev, "Couldn't map command register, "
+		mthca_err(mdev, "Couldn't map interrupt clear register, "
+			  "aborting.\n");
+		err = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	mdev->ecr_base = ioremap(mthca_base + MTHCA_ECR_BASE,
+				 MTHCA_ECR_SIZE + MTHCA_ECR_CLR_SIZE);
+	if (!mdev->ecr_base) {
+		mthca_err(mdev, "Couldn't map ecr register, "
 			  "aborting.\n");
 		err = -ENOMEM;
-		goto err_out_iounmap;
+		goto err_iounmap_clr;
 	}
 
 	mthca_base = pci_resource_start(pdev, 2);
@@ -722,37 +965,37 @@ static int __devinit mthca_init_one(stru
 		mthca_err(mdev, "Couldn't map kernel access region, "
 			  "aborting.\n");
 		err = -ENOMEM;
-		goto err_out_iounmap_clr;
+		goto err_iounmap_ecr;
 	}
 
 	err = mthca_tune_pci(mdev);
 	if (err)
-		goto err_out_iounmap_kar;
+		goto err_iounmap_kar;
 
 	err = mthca_init_hca(mdev);
 	if (err)
-		goto err_out_iounmap_kar;
+		goto err_iounmap_kar;
 
 	err = mthca_setup_hca(mdev);
 	if (err)
-		goto err_out_close;
+		goto err_close;
 
 	err = mthca_register_device(mdev);
 	if (err)
-		goto err_out_cleanup;
+		goto err_cleanup;
 
 	err = mthca_create_agents(mdev);
 	if (err)
-		goto err_out_unregister;
+		goto err_unregister;
 
 	pci_set_drvdata(pdev, mdev);
 
 	return 0;
 
-err_out_unregister:
+err_unregister:
 	mthca_unregister_device(mdev);
 
-err_out_cleanup:
+err_cleanup:
 	mthca_cleanup_mcg_table(mdev);
 	mthca_cleanup_av_table(mdev);
 	mthca_cleanup_qp_table(mdev);
@@ -765,19 +1008,22 @@ err_out_cleanup:
 	mthca_cleanup_mr_table(mdev);
 	mthca_cleanup_pd_table(mdev);
 
-err_out_close:
+err_close:
 	mthca_close_hca(mdev);
 
-err_out_iounmap_kar:
+err_iounmap_kar:
 	iounmap(mdev->kar);
 
-err_out_iounmap_clr:
+err_iounmap_ecr:
+	iounmap(mdev->ecr_base);
+
+err_iounmap_clr:
 	iounmap(mdev->clr_base);
 
-err_out_iounmap:
+err_iounmap:
 	iounmap(mdev->hcr);
 
-err_out_free_dev:
+err_free_dev:
 	if (mdev->mthca_flags & MTHCA_FLAG_MSI_X)
 		pci_disable_msix(pdev);
 	if (mdev->mthca_flags & MTHCA_FLAG_MSI)
@@ -785,10 +1031,10 @@ err_out_free_dev:
 
 	ib_dealloc_device(&mdev->ib_dev);
 
-err_out_free_res:
+err_free_res:
 	mthca_release_regions(pdev, ddr_hidden);
 
-err_out_disable_pdev:
+err_disable_pdev:
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
 	return err;
@@ -822,6 +1068,7 @@ static void __devexit mthca_remove_one(s
 		mthca_close_hca(mdev);
 
 		iounmap(mdev->hcr);
+		iounmap(mdev->ecr_base);
 		iounmap(mdev->clr_base);
 
 		if (mdev->mthca_flags & MTHCA_FLAG_MSI_X)
@@ -866,22 +1113,6 @@ static int __init mthca_init(void)
 {
 	int ret;
 
-	/*
-	 * TODO: measure whether dynamically choosing doorbell code at
-	 * runtime affects our performance.  Is there a "magic" way to
-	 * choose without having to follow a function pointer every
-	 * time we ring a doorbell?
-	 */
-#ifdef CONFIG_INFINIBAND_MTHCA_SSE_DOORBELL
-	if (!cpu_has_xmm) {
-		printk(KERN_ERR PFX "mthca was compiled with SSE doorbell code, but\n");
-		printk(KERN_ERR PFX "the current CPU does not support SSE.\n");
-		printk(KERN_ERR PFX "Turn off CONFIG_INFINIBAND_MTHCA_SSE_DOORBELL "
-		       "and recompile.\n");
-		return -ENODEV;
-	}
-#endif
-
 	ret = pci_register_driver(&mthca_driver);
 	return ret < 0 ? ret : 0;
 }
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_memfree.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_memfree.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_memfree.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_memfree.c	2005-01-26 15:43:26.127544754 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -34,6 +34,16 @@
 
 #include "mthca_memfree.h"
 #include "mthca_dev.h"
+#include "mthca_cmd.h"
+
+/*
+ * We allocate in as big chunks as we can, up to a maximum of 256 KB
+ * per chunk.
+ */
+enum {
+	MTHCA_ICM_ALLOC_SIZE   = 1 << 18,
+	MTHCA_TABLE_CHUNK_SIZE = 1 << 18
+};
 
 void mthca_free_icm(struct mthca_dev *dev, struct mthca_icm *icm)
 {
@@ -71,11 +81,7 @@ struct mthca_icm *mthca_alloc_icm(struct
 
 	INIT_LIST_HEAD(&icm->chunk_list);
 
-	/*
-	 * We allocate in as big chunks as we can, up to a maximum of
-	 * 256 KB per chunk.
-	 */
-	cur_order = get_order(1 << 18);
+	cur_order = get_order(MTHCA_ICM_ALLOC_SIZE);
 
 	while (npages > 0) {
 		if (!chunk) {
@@ -131,3 +137,70 @@ fail:
 	mthca_free_icm(dev, icm);
 	return NULL;
 }
+
+struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev,
+					      u64 virt, unsigned size,
+					      unsigned reserved,
+					      int use_lowmem)
+{
+	struct mthca_icm_table *table;
+	int num_icm;
+	int i;
+	u8 status;
+
+	num_icm = size / MTHCA_TABLE_CHUNK_SIZE;
+
+	table = kmalloc(sizeof *table + num_icm * sizeof *table->icm, GFP_KERNEL);
+	if (!table)
+		return NULL;
+
+	table->virt    = virt;
+	table->num_icm = num_icm;
+	init_MUTEX(&table->sem);
+
+	for (i = 0; i < num_icm; ++i)
+		table->icm[i] = NULL;
+
+	for (i = 0; i < (reserved + MTHCA_TABLE_CHUNK_SIZE - 1) / MTHCA_TABLE_CHUNK_SIZE; ++i) {
+		table->icm[i] = mthca_alloc_icm(dev, MTHCA_TABLE_CHUNK_SIZE >> PAGE_SHIFT,
+						(use_lowmem ? GFP_KERNEL : GFP_HIGHUSER) |
+						__GFP_NOWARN);
+		if (!table->icm[i])
+			goto err;
+		if (mthca_MAP_ICM(dev, table->icm[i], virt + i * MTHCA_TABLE_CHUNK_SIZE,
+				  &status) || status) {
+			mthca_free_icm(dev, table->icm[i]);
+			table->icm[i] = NULL;
+			goto err;
+		}
+	}
+
+	return table;
+
+err:
+	for (i = 0; i < num_icm; ++i)
+		if (table->icm[i]) {
+			mthca_UNMAP_ICM(dev, virt + i * MTHCA_TABLE_CHUNK_SIZE,
+					MTHCA_TABLE_CHUNK_SIZE >> 12, &status);
+			mthca_free_icm(dev, table->icm[i]);
+		}
+
+	kfree(table);
+
+	return NULL;
+}
+
+void mthca_free_icm_table(struct mthca_dev *dev, struct mthca_icm_table *table)
+{
+	int i;
+	u8 status;
+
+	for (i = 0; i < table->num_icm; ++i)
+		if (table->icm[i]) {
+			mthca_UNMAP_ICM(dev, table->virt + i * MTHCA_TABLE_CHUNK_SIZE,
+					MTHCA_TABLE_CHUNK_SIZE >> 12, &status);
+			mthca_free_icm(dev, table->icm[i]);
+		}
+
+	kfree(table);
+}
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_memfree.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_memfree.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_memfree.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_memfree.h	2005-01-26 15:43:26.129544442 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -38,8 +38,10 @@
 #include <linux/list.h>
 #include <linux/pci.h>
 
+#include <asm/semaphore.h>
+
 #define MTHCA_ICM_CHUNK_LEN \
-	((512 - sizeof (struct list_head) - 2 * sizeof (int)) /		\
+	((256 - sizeof (struct list_head) - 2 * sizeof (int)) /		\
 	 (sizeof (struct scatterlist)))
 
 struct mthca_icm_chunk {
@@ -53,6 +55,13 @@ struct mthca_icm {
 	struct list_head chunk_list;
 };
 
+struct mthca_icm_table {
+	u64               virt;
+	int               num_icm;
+	struct semaphore  sem;
+	struct mthca_icm *icm[0];
+};
+
 struct mthca_icm_iter {
 	struct mthca_icm       *icm;
 	struct mthca_icm_chunk *chunk;
@@ -65,6 +74,12 @@ struct mthca_icm *mthca_alloc_icm(struct
 				  unsigned int gfp_mask);
 void mthca_free_icm(struct mthca_dev *dev, struct mthca_icm *icm);
 
+struct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev,
+					      u64 virt, unsigned size,
+					      unsigned reserved,
+					      int use_lowmem);
+void mthca_free_icm_table(struct mthca_dev *dev, struct mthca_icm_table *table);
+
 static inline void mthca_icm_first(struct mthca_icm *icm,
 				   struct mthca_icm_iter *iter)
 {
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_profile.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_profile.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_profile.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_profile.c	2005-01-26 15:43:26.130544286 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -60,7 +60,7 @@ enum {
 	MTHCA_NUM_PDS = 1 << 15
 };
 
-int mthca_make_profile(struct mthca_dev *dev,
+u64 mthca_make_profile(struct mthca_dev *dev,
 		       struct mthca_profile *request,
 		       struct mthca_dev_lim *dev_lim,
 		       struct mthca_init_hca_param *init_hca)
@@ -116,6 +116,8 @@ int mthca_make_profile(struct mthca_dev 
 		profile[i].type     = i;
 		profile[i].log_num  = max(ffs(profile[i].num) - 1, 0);
 		profile[i].size    *= profile[i].num;
+		if (dev->hca_type == ARBEL_NATIVE)
+			profile[i].size = max(profile[i].size, (u64) PAGE_SIZE);
 	}
 
 	if (dev->hca_type == ARBEL_NATIVE) {
@@ -239,6 +241,10 @@ int mthca_make_profile(struct mthca_dev 
 		case MTHCA_RES_UDAV:
 			dev->av_table.ddr_av_base = profile[i].start;
 			dev->av_table.num_ddr_avs = profile[i].num;
+		case MTHCA_RES_UARC:
+			init_hca->uarc_base   = profile[i].start;
+			init_hca->log_uarc_sz = ffs(request->uarc_size) - 13;
+			init_hca->log_uar_sz  = ffs(request->num_uar) - 1;
 		default:
 			break;
 		}
@@ -251,5 +257,5 @@ int mthca_make_profile(struct mthca_dev 
 	dev->limits.num_pds = MTHCA_NUM_PDS;
 
 	kfree(profile);
-	return 0;
+	return total_size;
 }
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_profile.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_profile.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_profile.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_profile.h	2005-01-26 15:43:26.131544130 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Topspin Communications.  All rights reserved.
+ * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -50,7 +50,7 @@ struct mthca_profile {
 	int uarc_size;
 };
 
-int mthca_make_profile(struct mthca_dev *mdev,
+u64 mthca_make_profile(struct mthca_dev *mdev,
 		       struct mthca_profile *request,
 		       struct mthca_dev_lim *dev_lim,
 		       struct mthca_init_hca_param *init_hca);
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_provider.c linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_provider.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_provider.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_provider.c	2005-01-26 15:43:26.133543819 +0100
@@ -59,8 +59,8 @@ static int mthca_query_device(struct ib_
 	in_mad->method         	   = IB_MGMT_METHOD_GET;
 	in_mad->attr_id   	   = IB_SMP_ATTR_NODE_INFO;
 
-	err = mthca_MAD_IFC(to_mdev(ibdev), 1,
-			    1, in_mad, out_mad,
+	err = mthca_MAD_IFC(to_mdev(ibdev), 1, 1,
+			    1, NULL, NULL, in_mad, out_mad,
 			    &status);
 	if (err)
 		goto out;
@@ -104,8 +104,8 @@ static int mthca_query_port(struct ib_de
 	in_mad->attr_id   	   = IB_SMP_ATTR_PORT_INFO;
 	in_mad->attr_mod           = cpu_to_be32(port);
 
-	err = mthca_MAD_IFC(to_mdev(ibdev), 1,
-			    port, in_mad, out_mad,
+	err = mthca_MAD_IFC(to_mdev(ibdev), 1, 1,
+			    port, NULL, NULL, in_mad, out_mad,
 			    &status);
 	if (err)
 		goto out;
@@ -137,7 +137,35 @@ static int mthca_modify_port(struct ib_d
 			     u8 port, int port_modify_mask,
 			     struct ib_port_modify *props)
 {
-	return 0;
+	struct mthca_set_ib_param set_ib;
+	struct ib_port_attr attr;
+	int err;
+	u8 status;
+
+	if (down_interruptible(&to_mdev(ibdev)->cap_mask_mutex))
+		return -ERESTARTSYS;
+
+	err = mthca_query_port(ibdev, port, &attr);
+	if (err)
+		goto out;
+
+	set_ib.set_si_guid     = 0;
+	set_ib.reset_qkey_viol = !!(port_modify_mask & IB_PORT_RESET_QKEY_CNTR);
+
+	set_ib.cap_mask = (attr.port_cap_flags | props->set_port_cap_mask) &
+		~props->clr_port_cap_mask;
+
+	err = mthca_SET_IB(to_mdev(ibdev), &set_ib, port, &status);
+	if (err)
+		goto out;
+	if (status) {
+		err = -EINVAL;
+		goto out;
+	}
+
+out:
+	up(&to_mdev(ibdev)->cap_mask_mutex);
+	return err;
 }
 
 static int mthca_query_pkey(struct ib_device *ibdev,
@@ -161,8 +189,8 @@ static int mthca_query_pkey(struct ib_de
 	in_mad->attr_id   	   = IB_SMP_ATTR_PKEY_TABLE;
 	in_mad->attr_mod           = cpu_to_be32(index / 32);
 
-	err = mthca_MAD_IFC(to_mdev(ibdev), 1,
-			    port, in_mad, out_mad,
+	err = mthca_MAD_IFC(to_mdev(ibdev), 1, 1,
+			    port, NULL, NULL, in_mad, out_mad,
 			    &status);
 	if (err)
 		goto out;
@@ -200,8 +228,8 @@ static int mthca_query_gid(struct ib_dev
 	in_mad->attr_id   	   = IB_SMP_ATTR_PORT_INFO;
 	in_mad->attr_mod           = cpu_to_be32(port);
 
-	err = mthca_MAD_IFC(to_mdev(ibdev), 1,
-			    port, in_mad, out_mad,
+	err = mthca_MAD_IFC(to_mdev(ibdev), 1, 1,
+			    port, NULL, NULL, in_mad, out_mad,
 			    &status);
 	if (err)
 		goto out;
@@ -220,8 +248,8 @@ static int mthca_query_gid(struct ib_dev
 	in_mad->attr_id   	   = IB_SMP_ATTR_GUID_INFO;
 	in_mad->attr_mod           = cpu_to_be32(index / 8);
 
-	err = mthca_MAD_IFC(to_mdev(ibdev), 1,
-			    port, in_mad, out_mad,
+	err = mthca_MAD_IFC(to_mdev(ibdev), 1, 1,
+			    port, NULL, NULL, in_mad, out_mad,
 			    &status);
 	if (err)
 		goto out;
@@ -606,6 +634,8 @@ int mthca_register_device(struct mthca_d
 	dev->ib_dev.detach_mcast         = mthca_multicast_detach;
 	dev->ib_dev.process_mad          = mthca_process_mad;
 
+	init_MUTEX(&dev->cap_mask_mutex);
+
 	ret = ib_register_device(&dev->ib_dev);
 	if (ret)
 		return ret;
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_provider.h linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_provider.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/hw/mthca/mthca_provider.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/hw/mthca/mthca_provider.h	2005-01-26 15:43:26.134543663 +0100
@@ -66,11 +66,11 @@ struct mthca_eq {
 	struct mthca_dev      *dev;
 	int                    eqn;
 	u32                    ecr_mask;
+	u32                    cons_index;
 	u16                    msi_x_vector;
 	u16                    msi_x_entry;
 	int                    have_irq;
 	int                    nent;
-	int                    cons_index;
 	struct mthca_buf_list *page_list;
 	struct mthca_mr        mr;
 };
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/include/ib_verbs.h linux-2.6.11-rc2-bk4/drivers/infiniband/include/ib_verbs.h
--- linux-2.6.11-rc2-bk3/drivers/infiniband/include/ib_verbs.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/include/ib_verbs.h	2005-01-26 15:43:26.137543195 +0100
@@ -154,25 +154,28 @@ enum ib_port_state {
 };
 
 enum ib_port_cap_flags {
-	IB_PORT_SM				= (1<<31),
-	IB_PORT_NOTICE_SUP			= (1<<30),
-	IB_PORT_TRAP_SUP			= (1<<29),
-	IB_PORT_AUTO_MIGR_SUP			= (1<<27),
-	IB_PORT_SL_MAP_SUP			= (1<<26),
-	IB_PORT_MKEY_NVRAM			= (1<<25),
-	IB_PORT_PKEY_NVRAM			= (1<<24),
-	IB_PORT_LED_INFO_SUP			= (1<<23),
-	IB_PORT_SM_DISABLED			= (1<<22),
-	IB_PORT_SYS_IMAGE_GUID_SUP		= (1<<21),
-	IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP	= (1<<20),
-	IB_PORT_CM_SUP				= (1<<16),
-	IB_PORT_SNMP_TUNNEL_SUP			= (1<<15),
-	IB_PORT_REINIT_SUP			= (1<<14),
-	IB_PORT_DEVICE_MGMT_SUP			= (1<<13),
-	IB_PORT_VENDOR_CLASS_SUP		= (1<<12),
-	IB_PORT_DR_NOTICE_SUP			= (1<<11),
-	IB_PORT_PORT_NOTICE_SUP			= (1<<10),
-	IB_PORT_BOOT_MGMT_SUP			= (1<<9)
+	IB_PORT_SM				= 1 <<  1,
+	IB_PORT_NOTICE_SUP			= 1 <<  2,
+	IB_PORT_TRAP_SUP			= 1 <<  3,
+	IB_PORT_OPT_IPD_SUP                     = 1 <<  4,
+	IB_PORT_AUTO_MIGR_SUP			= 1 <<  5,
+	IB_PORT_SL_MAP_SUP			= 1 <<  6,
+	IB_PORT_MKEY_NVRAM			= 1 <<  7,
+	IB_PORT_PKEY_NVRAM			= 1 <<  8,
+	IB_PORT_LED_INFO_SUP			= 1 <<  9,
+	IB_PORT_SM_DISABLED			= 1 << 10,
+	IB_PORT_SYS_IMAGE_GUID_SUP		= 1 << 11,
+	IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP	= 1 << 12,
+	IB_PORT_CM_SUP				= 1 << 16,
+	IB_PORT_SNMP_TUNNEL_SUP			= 1 << 17,
+	IB_PORT_REINIT_SUP			= 1 << 18,
+	IB_PORT_DEVICE_MGMT_SUP			= 1 << 19,
+	IB_PORT_VENDOR_CLASS_SUP		= 1 << 20,
+	IB_PORT_DR_NOTICE_SUP			= 1 << 21,
+	IB_PORT_CAP_MASK_NOTICE_SUP		= 1 << 22,
+	IB_PORT_BOOT_MGMT_SUP			= 1 << 23,
+	IB_PORT_LINK_LATENCY_SUP		= 1 << 24,
+	IB_PORT_CLIENT_REG_SUP			= 1 << 25
 };
 
 enum ib_port_width {
diff -purN linux-2.6.11-rc2-bk3/drivers/infiniband/ulp/ipoib/ipoib_ib.c linux-2.6.11-rc2-bk4/drivers/infiniband/ulp/ipoib/ipoib_ib.c
--- linux-2.6.11-rc2-bk3/drivers/infiniband/ulp/ipoib/ipoib_ib.c	2005-01-26 15:42:47.511700974 +0100
+++ linux-2.6.11-rc2-bk4/drivers/infiniband/ulp/ipoib/ipoib_ib.c	2005-01-26 15:43:26.140542728 +0100
@@ -509,7 +509,7 @@ int ipoib_ib_dev_stop(struct net_device 
 			goto timeout;
 		}
 
-		yield();
+		msleep(1);
 	}
 
 	ipoib_dbg(priv, "All sends and receives done.\n");
@@ -535,7 +535,7 @@ timeout:
 			break;
 		}
 
-		yield();
+		msleep(1);
 	}
 
 	return 0;
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-io.c linux-2.6.11-rc2-bk4/drivers/md/dm-io.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-io.c	2005-01-22 02:49:18.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-io.c	2005-01-26 15:43:26.144542104 +0100
@@ -149,22 +149,6 @@ static inline unsigned bvec_index(unsign
 	return 0;
 }
 
-static inline void bs_bio_init(struct bio *bio)
-{
-	bio->bi_next = NULL;
-	bio->bi_flags = 1 << BIO_UPTODATE;
-	bio->bi_rw = 0;
-	bio->bi_vcnt = 0;
-	bio->bi_idx = 0;
-	bio->bi_phys_segments = 0;
-	bio->bi_hw_segments = 0;
-	bio->bi_size = 0;
-	bio->bi_max_vecs = 0;
-	bio->bi_end_io = NULL;
-	atomic_set(&bio->bi_cnt, 1);
-	bio->bi_private = NULL;
-}
-
 static unsigned _bio_count = 0;
 struct bio *bio_set_alloc(struct bio_set *bs, int gfp_mask, int nr_iovecs)
 {
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-ioctl.c linux-2.6.11-rc2-bk4/drivers/md/dm-ioctl.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-ioctl.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-ioctl.c	2005-01-26 15:43:26.146541793 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2001, 2002 Sistina Software (UK) Limited.
- * Copyright (C) 2004 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2004 - 2005 Red Hat, Inc. All rights reserved.
  *
  * This file is released under the GPL.
  */
@@ -520,19 +520,22 @@ static int __dev_status(struct mapped_de
 	if (dm_suspended(md))
 		param->flags |= DM_SUSPEND_FLAG;
 
-	bdev = bdget_disk(disk, 0);
-	if (!bdev)
-		return -ENXIO;
-
 	param->dev = huge_encode_dev(MKDEV(disk->major, disk->first_minor));
 
-	/*
-	 * Yes, this will be out of date by the time it gets back
-	 * to userland, but it is still very useful ofr
-	 * debugging.
-	 */
-	param->open_count = bdev->bd_openers;
-	bdput(bdev);
+	if (!(param->flags & DM_SKIP_BDGET_FLAG)) {
+		bdev = bdget_disk(disk, 0);
+		if (!bdev)
+			return -ENXIO;
+
+		/*
+		 * Yes, this will be out of date by the time it gets back
+		 * to userland, but it is still very useful for
+		 * debugging.
+		 */
+		param->open_count = bdev->bd_openers;
+		bdput(bdev);
+	} else
+		param->open_count = -1;
 
 	if (disk->policy)
 		param->flags |= DM_READONLY_FLAG;
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-log.c linux-2.6.11-rc2-bk4/drivers/md/dm-log.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-log.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-log.c	2005-01-26 15:43:26.148541481 +0100
@@ -17,9 +17,6 @@ static DEFINE_SPINLOCK(_lock);
 
 int dm_register_dirty_log_type(struct dirty_log_type *type)
 {
-	if (!try_module_get(type->module))
-		return -EINVAL;
-
 	spin_lock(&_lock);
 	type->use_count = 0;
 	list_add(&type->list, &_log_types);
@@ -34,10 +31,8 @@ int dm_unregister_dirty_log_type(struct 
 
 	if (type->use_count)
 		DMWARN("Attempt to unregister a log type that is still in use");
-	else {
+	else
 		list_del(&type->list);
-		module_put(type->module);
-	}
 
 	spin_unlock(&_lock);
 
@@ -51,6 +46,10 @@ static struct dirty_log_type *get_type(c
 	spin_lock(&_lock);
 	list_for_each_entry (type, &_log_types, list)
 		if (!strcmp(type_name, type->name)) {
+			if (!type->use_count && !try_module_get(type->module)){
+				spin_unlock(&_lock);
+				return NULL;
+			}
 			type->use_count++;
 			spin_unlock(&_lock);
 			return type;
@@ -63,7 +62,8 @@ static struct dirty_log_type *get_type(c
 static void put_type(struct dirty_log_type *type)
 {
 	spin_lock(&_lock);
-	type->use_count--;
+	if (!--type->use_count)
+		module_put(type->module);
 	spin_unlock(&_lock);
 }
 
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-raid1.c linux-2.6.11-rc2-bk4/drivers/md/dm-raid1.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-raid1.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-raid1.c	2005-01-26 15:43:26.150541169 +0100
@@ -1158,10 +1158,11 @@ static int mirror_end_io(struct dm_targe
 	return 0;
 }
 
-static void mirror_suspend(struct dm_target *ti)
+static void mirror_postsuspend(struct dm_target *ti)
 {
 	struct mirror_set *ms = (struct mirror_set *) ti->private;
 	struct dirty_log *log = ms->rh.log;
+
 	rh_stop_recovery(&ms->rh);
 	if (log->type->suspend && log->type->suspend(log))
 		/* FIXME: need better error handling */
@@ -1220,7 +1221,7 @@ static struct target_type mirror_target 
 	.dtr	 = mirror_dtr,
 	.map	 = mirror_map,
 	.end_io	 = mirror_end_io,
-	.suspend = mirror_suspend,
+	.postsuspend = mirror_postsuspend,
 	.resume	 = mirror_resume,
 	.status	 = mirror_status,
 };
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-stripe.c linux-2.6.11-rc2-bk4/drivers/md/dm-stripe.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-stripe.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-stripe.c	2005-01-26 15:43:26.151541014 +0100
@@ -173,9 +173,8 @@ static int stripe_map(struct dm_target *
 	struct stripe_c *sc = (struct stripe_c *) ti->private;
 
 	sector_t offset = bio->bi_sector - ti->begin;
-	uint32_t chunk = (uint32_t) (offset >> sc->chunk_shift);
-	uint32_t stripe = chunk % sc->stripes;	/* 32bit modulus */
-	chunk = chunk / sc->stripes;
+	sector_t chunk = offset >> sc->chunk_shift;
+	uint32_t stripe = do_div(chunk, sc->stripes);
 
 	bio->bi_bdev = sc->stripe[stripe].dev->bdev;
 	bio->bi_sector = sc->stripe[stripe].physical_start +
@@ -210,7 +209,7 @@ static int stripe_status(struct dm_targe
 
 static struct target_type stripe_target = {
 	.name   = "striped",
-	.version= {1, 0, 1},
+	.version= {1, 0, 2},
 	.module = THIS_MODULE,
 	.ctr    = stripe_ctr,
 	.dtr    = stripe_dtr,
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm-table.c linux-2.6.11-rc2-bk4/drivers/md/dm-table.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm-table.c	2005-01-22 02:49:18.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm-table.c	2005-01-26 15:43:26.153540702 +0100
@@ -849,18 +849,32 @@ int dm_table_get_mode(struct dm_table *t
 	return t->mode;
 }
 
-void dm_table_suspend_targets(struct dm_table *t)
+static void suspend_targets(struct dm_table *t, unsigned postsuspend)
 {
-	int i;
+	int i = t->num_targets;
+	struct dm_target *ti = t->targets;
 
-	for (i = 0; i < t->num_targets; i++) {
-		struct dm_target *ti = t->targets + i;
+	while (i--) {
+		if (postsuspend) {
+			if (ti->type->postsuspend)
+				ti->type->postsuspend(ti);
+		} else if (ti->type->presuspend)
+			ti->type->presuspend(ti);
 
-		if (ti->type->suspend)
-			ti->type->suspend(ti);
+		ti++;
 	}
 }
 
+void dm_table_presuspend_targets(struct dm_table *t)
+{
+	return suspend_targets(t, 0);
+}
+
+void dm_table_postsuspend_targets(struct dm_table *t)
+{
+	return suspend_targets(t, 1);
+}
+
 void dm_table_resume_targets(struct dm_table *t)
 {
 	int i;
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm.c linux-2.6.11-rc2-bk4/drivers/md/dm.c
--- linux-2.6.11-rc2-bk3/drivers/md/dm.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm.c	2005-01-26 15:43:26.155540390 +0100
@@ -919,8 +919,10 @@ void dm_put(struct mapped_device *md)
 	struct dm_table *map = dm_get_table(md);
 
 	if (atomic_dec_and_test(&md->holders)) {
-		if (!test_bit(DMF_SUSPENDED, &md->flags) && map)
-			dm_table_suspend_targets(map);
+		if (!test_bit(DMF_SUSPENDED, &md->flags) && map) {
+			dm_table_presuspend_targets(map);
+			dm_table_postsuspend_targets(map);
+		}
 		__unbind(md);
 		free_dev(md);
 	}
@@ -1032,7 +1034,11 @@ int dm_suspend(struct mapped_device *md)
 		return -EINVAL;
 	}
 
+	map = dm_get_table(md);
+	if (map)
+		dm_table_presuspend_targets(map);
 	__lock_fs(md);
+
 	up_read(&md->lock);
 
 	/*
@@ -1055,7 +1061,6 @@ int dm_suspend(struct mapped_device *md)
 	up_write(&md->lock);
 
 	/* unplug */
-	map = dm_get_table(md);
 	if (map) {
 		dm_table_unplug_all(map);
 		dm_table_put(map);
@@ -1090,7 +1095,7 @@ int dm_suspend(struct mapped_device *md)
 
 	map = dm_get_table(md);
 	if (map)
-		dm_table_suspend_targets(map);
+		dm_table_postsuspend_targets(map);
 	dm_table_put(map);
 	up_write(&md->lock);
 
diff -purN linux-2.6.11-rc2-bk3/drivers/md/dm.h linux-2.6.11-rc2-bk4/drivers/md/dm.h
--- linux-2.6.11-rc2-bk3/drivers/md/dm.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/md/dm.h	2005-01-26 15:43:26.156540234 +0100
@@ -115,7 +115,8 @@ void dm_table_set_restrictions(struct dm
 unsigned int dm_table_get_num_targets(struct dm_table *t);
 struct list_head *dm_table_get_devices(struct dm_table *t);
 int dm_table_get_mode(struct dm_table *t);
-void dm_table_suspend_targets(struct dm_table *t);
+void dm_table_presuspend_targets(struct dm_table *t);
+void dm_table_postsuspend_targets(struct dm_table *t);
 void dm_table_resume_targets(struct dm_table *t);
 int dm_table_any_congested(struct dm_table *t, int bdi_bits);
 void dm_table_unplug_all(struct dm_table *t);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/Kconfig linux-2.6.11-rc2-bk4/drivers/media/Kconfig
--- linux-2.6.11-rc2-bk3/drivers/media/Kconfig	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/Kconfig	2005-01-26 15:43:26.157540079 +0100
@@ -47,5 +47,8 @@ config VIDEO_BTCX
 config VIDEO_IR
 	tristate
 
+config VIDEO_TVEEPROM
+	tristate
+
 endmenu
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/common/ir-common.c linux-2.6.11-rc2-bk4/drivers/media/common/ir-common.c
--- linux-2.6.11-rc2-bk3/drivers/media/common/ir-common.c	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/common/ir-common.c	2005-01-26 15:43:26.158539923 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: ir-common.c,v 1.5 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: ir-common.c,v 1.6 2004/12/10 12:33:39 kraxel Exp $
  *
  * some common structs and functions to handle infrared remotes via
  * input layer ...
@@ -22,6 +22,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 
 #include <media/ir-common.h>
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-core.c linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-core.c
--- linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-core.c	2005-01-26 15:42:47.539696610 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-core.c	2005-01-26 15:43:26.183536027 +0100
@@ -27,17 +27,22 @@
 #include <linux/moduleparam.h>
 
 /* debug */
+int dvb_dibusb_debug;
+module_param_named(debug, dvb_dibusb_debug,  int, 0644);
+
 #ifdef CONFIG_DVB_DIBCOM_DEBUG
-int debug;
-module_param(debug, int, 0644);
-MODULE_PARM_DESC(debug, "set debugging level (1=info,2=xfer,4=alotmore,8=ts,16=err,32=rc (|-able)).");
+#define DBSTATUS ""
+#else
+#define DBSTATUS " (debugging is not enabled)"
 #endif
+MODULE_PARM_DESC(debug, "set debugging level (1=info,2=xfer,4=alotmore,8=ts,16=err,32=rc (|-able))." DBSTATUS);
+#undef DBSTATUS
 
-int pid_parse;
+static int pid_parse;
 module_param(pid_parse, int, 0644);
 MODULE_PARM_DESC(pid_parse, "enable pid parsing (filtering) when running at USB2.0");
 
-int rc_query_interval;
+static int rc_query_interval;
 module_param(rc_query_interval, int, 0644);
 MODULE_PARM_DESC(rc_query_interval, "interval in msecs for remote control query (default: 100; min: 40)");
 
@@ -410,6 +415,10 @@ static int dibusb_probe(struct usb_inter
 		dib->udev = udev;
 		dib->dibdev = dibdev;
 
+		/* store parameters to structures */
+		dib->rc_query_interval = rc_query_interval;
+		dib->pid_parse = pid_parse;
+
 		usb_set_intfdata(intf, dib);
 		
 		ret = dibusb_init(dib);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-remote.c linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-remote.c
--- linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-remote.c	2005-01-26 15:42:47.554694273 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-remote.c	2005-01-26 15:43:26.197533845 +0100
@@ -143,7 +143,7 @@ static void dibusb_remote_query(void *da
 	   if we're busy. */
 	dibusb_read_remote_control(dib);
 	schedule_delayed_work(&dib->rc_query_work,
-			      msecs_to_jiffies(rc_query_interval));
+			      msecs_to_jiffies(dib->rc_query_interval));
 }
 
 int dibusb_remote_init(struct usb_dibusb *dib)
@@ -171,11 +171,11 @@ int dibusb_remote_init(struct usb_dibusb
 	INIT_WORK(&dib->rc_query_work, dibusb_remote_query, dib);
 
 	/* Start the remote-control polling. */
-	if (rc_query_interval < 40)
-		rc_query_interval = 100; /* default */
+	if (dib->rc_query_interval < 40)
+		dib->rc_query_interval = 100; /* default */
 
-	info("schedule remote query interval to %d msecs.",rc_query_interval);
-	schedule_delayed_work(&dib->rc_query_work,msecs_to_jiffies(rc_query_interval));
+	info("schedule remote query interval to %d msecs.",dib->rc_query_interval);
+	schedule_delayed_work(&dib->rc_query_work,msecs_to_jiffies(dib->rc_query_interval));
 
 	dib->init_state |= DIBUSB_STATE_REMOTE;
 	
diff -purN linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-usb.c linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-usb.c
--- linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb-usb.c	2005-01-26 15:42:47.557693805 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb-usb.c	2005-01-26 15:43:26.201533222 +0100
@@ -158,7 +158,7 @@ int dibusb_streaming(struct usb_dibusb *
 
 int dibusb_urb_init(struct usb_dibusb *dib)
 {
-	int ret,i,bufsize;
+	int ret,i,bufsize,def_pid_parse = 1;
 	
 	/*
 	 * when reloading the driver w/o replugging the device 
@@ -210,12 +210,14 @@ int dibusb_urb_init(struct usb_dibusb *d
 		dib->init_state |= DIBUSB_STATE_URB_SUBMIT;
 	}
 
-
-	dib->pid_parse = 1;
+	/* dib->pid_parse here contains the value of the module parameter */
+	/* decide if pid parsing can be deactivated:
+	 * is possible (by speed) and wanted (by user)
+	 */
 	switch (dib->dibdev->dev_cl->id) {
 		case DIBUSB2_0:
-			if (dib->udev->speed == USB_SPEED_HIGH && !pid_parse) {
-				dib->pid_parse = 0;
+			if (dib->udev->speed == USB_SPEED_HIGH && !dib->pid_parse) {
+				def_pid_parse = 0;
 				info("running at HIGH speed, will deliver the complete TS.");
 			} else
 				info("will use pid_parsing.");
@@ -223,6 +225,8 @@ int dibusb_urb_init(struct usb_dibusb *d
 		default: 
 			break;
 	}
+	/* from here on it contains the device and user decision */
+	dib->pid_parse = def_pid_parse;
 	
 	return 0;
 }
diff -purN linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb.h linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb.h
--- linux-2.6.11-rc2-bk3/drivers/media/dvb/dibusb/dvb-dibusb.h	2005-01-26 15:42:47.575691000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/dvb/dibusb/dvb-dibusb.h	2005-01-26 15:43:26.218530572 +0100
@@ -27,31 +27,26 @@
 /* debug */
 #ifdef CONFIG_DVB_DIBCOM_DEBUG
 #define dprintk(level,args...) \
-	    do { if ((debug & level)) { printk(args); } } while (0)
+	    do { if ((dvb_dibusb_debug & level)) { printk(args); } } while (0)
 
-#define debug_dump(b,l) if (debug) {\
-	int i; deb_xfer("%s: %d > ",__FUNCTION__,l); \
+#define debug_dump(b,l) {\
+	int i; \
 	for (i = 0; i < l; i++) deb_xfer("%02x ", b[i]); \
 	deb_xfer("\n");\
 }
 
-/* module parameters - declared in -core.c */
-extern int debug;
-
 #else
 #define dprintk(args...)
 #define debug_dump(b,l)
 #endif
 
+extern int dvb_dibusb_debug;
+
 /* Version information */
 #define DRIVER_VERSION "0.3"
 #define DRIVER_DESC "Driver for DiBcom based USB Budget DVB-T device"
 #define DRIVER_AUTHOR "Patrick Boettcher, patrick.boettcher@desy.de"
 
-/* module parameters - declared in -core.c */
-extern int pid_parse;
-extern int rc_query_interval;
-
 #define deb_info(args...) dprintk(0x01,args)
 #define deb_xfer(args...) dprintk(0x02,args)
 #define deb_alot(args...) dprintk(0x04,args)
@@ -162,7 +157,6 @@ struct usb_dibusb {
 	int init_state;
 
 	int feedcount;
-	int pid_parse;
 	struct dib_fe_xfer_ops xfer_ops;
 
 	struct dibusb_tuner *tuner;
@@ -196,6 +190,10 @@ struct usb_dibusb {
 	struct input_dev rc_input_dev;
 	struct work_struct rc_query_work;
 	int rc_input_event;
+
+	/* module parameters */
+	int pid_parse;
+	int rc_query_interval;
 };
 
 /* commonly used functions in the separated files */
diff -purN linux-2.6.11-rc2-bk3/drivers/media/dvb/frontends/dib3000mc.c linux-2.6.11-rc2-bk4/drivers/media/dvb/frontends/dib3000mc.c
--- linux-2.6.11-rc2-bk3/drivers/media/dvb/frontends/dib3000mc.c	2005-01-26 15:42:47.613685078 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/dvb/frontends/dib3000mc.c	2005-01-26 15:43:26.256524650 +0100
@@ -562,9 +562,11 @@ static int dib3000mc_set_frontend(struct
 
 static int dib3000mc_fe_init(struct dvb_frontend* fe, int mobile_mode)
 {
+	struct dib3000_state *state;
+
 	deb_info("init start\n");
-	struct dib3000_state* state = (struct dib3000_state*) fe->demodulator_priv;
 
+	state = fe->demodulator_priv;
 	state->timing_offset = 0;
 	state->timing_offset_comp_done = 0;
 	
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/Kconfig linux-2.6.11-rc2-bk4/drivers/media/video/Kconfig
--- linux-2.6.11-rc2-bk3/drivers/media/video/Kconfig	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/Kconfig	2005-01-26 15:43:26.313515767 +0100
@@ -16,6 +16,7 @@ config VIDEO_BT848
 	select VIDEO_BUF
 	select VIDEO_IR
 	select VIDEO_TUNER
+	select VIDEO_TVEEPROM
 	---help---
 	  Support for BT848 based frame grabber/overlay boards. This includes
 	  the Miro, Hauppauge and STB boards. Please read the material in
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/Makefile linux-2.6.11-rc2-bk4/drivers/media/video/Makefile
--- linux-2.6.11-rc2-bk3/drivers/media/video/Makefile	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/Makefile	2005-01-26 15:43:26.313515767 +0100
@@ -48,6 +48,7 @@ obj-$(CONFIG_VIDEO_TUNER) += tuner.o tda
 obj-$(CONFIG_VIDEO_BUF)   += video-buf.o
 obj-$(CONFIG_VIDEO_BUF_DVB) += video-buf-dvb.o
 obj-$(CONFIG_VIDEO_BTCX)  += btcx-risc.o
+obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
 
 obj-$(CONFIG_VIDEO_M32R_AR_M64278) += arv.o
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/arv.c linux-2.6.11-rc2-bk4/drivers/media/video/arv.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/arv.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/arv.c	2005-01-26 15:43:26.315515456 +0100
@@ -627,7 +627,7 @@ static void ar_interrupt(int irq, void *
  */
 static int ar_initialize(struct video_device *dev)
 {
-	struct ar_device *ar = (struct ar_device *)dev->priv;
+	struct ar_device *ar = dev->priv;
 	unsigned long cr = 0;
 	int i,found=0;
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/btcx-risc.c linux-2.6.11-rc2-bk4/drivers/media/video/btcx-risc.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/btcx-risc.c	2005-01-22 02:46:43.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/btcx-risc.c	2005-01-26 15:43:26.316515300 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: btcx-risc.c,v 1.4 2004/11/07 13:17:14 kraxel Exp $
+    $Id: btcx-risc.c,v 1.5 2004/12/10 12:33:39 kraxel Exp $
 
     btcx-risc.c
 
@@ -24,6 +24,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-cards.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-cards.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-cards.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-cards.c	2005-01-26 15:43:26.327513586 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-cards.c,v 1.32 2004/11/07 13:17:14 kraxel Exp $
+    $Id: bttv-cards.c,v 1.42 2005/01/13 17:22:33 kraxel Exp $
 
     bttv-cards.c
 
@@ -29,18 +29,19 @@
 #include <linux/config.h>
 #include <linux/delay.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/vmalloc.h>
-#if defined(CONFIG_FW_LOADER) || defined(CONFIG_FW_LOADER_MODULE)
-# include <linux/firmware.h>
-#endif
+#include <linux/firmware.h>
 
 #include <asm/io.h>
 
 #include "bttvp.h"
+#if 0 /* not working yet */
 #include "bt832.h"
+#endif
 
 /* fwd decl */
 static void boot_msp34xx(struct bttv *btv, int pin);
@@ -76,6 +77,9 @@ static void PXC200_muxsel(struct bttv *b
 static void picolo_tetra_muxsel(struct bttv *btv, unsigned int input);
 static void picolo_tetra_init(struct bttv *btv);
 
+static void tibetCS16_muxsel(struct bttv *btv, unsigned int input);
+static void tibetCS16_init(struct bttv *btv);
+
 static void sigmaSLC_muxsel(struct bttv *btv, unsigned int input);
 static void sigmaSQ_muxsel(struct bttv *btv, unsigned int input);
 
@@ -84,12 +88,13 @@ static int tea5757_read(struct bttv *btv
 static int tea5757_write(struct bttv *btv, int value);
 static void identify_by_eeprom(struct bttv *btv,
 			       unsigned char eeprom_data[256]);
+static int __devinit pvr_boot(struct bttv *btv);
 
 /* config variables */
 static unsigned int triton1=0;
 static unsigned int vsfx=0;
 static unsigned int latency = UNSET;
-unsigned int no_overlay=-1;
+static unsigned int no_overlay=-1;
 
 static unsigned int card[BTTV_MAX]   = { [ 0 ... (BTTV_MAX-1) ] = UNSET };
 static unsigned int pll[BTTV_MAX]    = { [ 0 ... (BTTV_MAX-1) ] = UNSET };
@@ -283,12 +288,12 @@ static struct CARD {
 
 	// DVB cards (using pci function .1 for mpeg data xfer)
 	{ 0x01010071, BTTV_NEBULA_DIGITV, "Nebula Electronics DigiTV" },
-	{ 0x07611461, BTTV_AVDVBT_761,    "AverMedia AverTV DVB-T" },
+	{ 0x07611461, BTTV_AVDVBT_761,    "AverMedia AverTV DVB-T 761" },
 	{ 0x001c11bd, BTTV_PINNACLESAT,   "Pinnacle PCTV Sat" },
 	{ 0x002611bd, BTTV_TWINHAN_DST,   "Pinnacle PCTV SAT CI" },
 	{ 0x00011822, BTTV_TWINHAN_DST,   "Twinhan VisionPlus DVB-T" },
 	{ 0xfc00270f, BTTV_TWINHAN_DST,   "ChainTech digitop DST-1000 DVB-S" },
-	{ 0x07711461, BTTV_AVDVBT_771,    "AVermedia DVB-T 771" },
+	{ 0x07711461, BTTV_AVDVBT_771,    "AVermedia AverTV DVB-T 771" },
 	{ 0xdb1018ac, BTTV_DVICO_DVBT_LITE,    "DVICO FusionHDTV DVB-T Lite" },
 
 	{ 0, -1, NULL }
@@ -2156,6 +2161,33 @@ struct tvcard bttv_tvcards[] = {
 	.tuner_type     = TUNER_PHILIPS_NTSC_M,
 	.has_radio      = 0,
 	// .has_remote     = 1,
+},{
+	/* Rick C <cryptdragoon@gmail.com> */
+        .name           = "Super TV Tuner",
+        .video_inputs   = 4,
+        .audio_inputs   = 1,
+        .tuner          = 0,
+        .svhs           = 2,
+        .muxsel         = { 2, 3, 1, 0},
+        .tuner_type     = TUNER_PHILIPS_NTSC,
+        .gpiomask       = 0x008007,
+        .audiomux       = { 0, 0x000001,0,0, 0},
+        .needs_tvaudio  = 1,
+        .has_radio      = 1,
+},{
+		/* Chris Fanning <video4linux@haydon.net> */
+		.name           = "Tibet Systems 'Progress DVR' CS16",
+		.video_inputs   = 16,
+		.audio_inputs   = 0,
+		.tuner          = -1,
+		.svhs           = -1,
+		.muxsel         = { 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 },
+		.pll		= PLL_28,
+		.no_msp34xx     = 1,
+		.no_tda9875     = 1,
+		.no_tda7432	= 1,
+		.tuner_type     = -1,
+		.muxsel_hook    = tibetCS16_muxsel,
 }};
 
 static const unsigned int bttv_num_tvcards = ARRAY_SIZE(bttv_tvcards);
@@ -2499,7 +2531,7 @@ static void sigmaSLC_muxsel(struct bttv 
 
 /* ----------------------------------------------------------------------- */
 
-void bttv_reset_audio(struct bttv *btv)
+static void bttv_reset_audio(struct bttv *btv)
 {
 	/*
 	 * BT878A has a audio-reset register.
@@ -2542,6 +2574,8 @@ void __devinit bttv_init_card1(struct bt
 		btv->use_i2c_hw = 1;
 		break;
 	}
+	if (!bttv_tvcards[btv->c.type].has_dvb)
+		bttv_reset_audio(btv);
 }
 
 /* initialization part two -- after registering i2c bus */
@@ -2645,6 +2679,9 @@ void __devinit bttv_init_card2(struct bt
 	case BTTV_LMLBT4:
 		init_lmlbt4x(btv);
 		break;
+	case BTTV_TIBET_CS16:
+		tibetCS16_init(btv);
+		break;
 	}
 
 	/* pll configuration */
@@ -2681,6 +2718,8 @@ void __devinit bttv_init_card2(struct bt
         }
 	btv->pll.pll_current = -1;
 
+	bttv_reset_audio(btv);
+
 	/* tuner configuration (from card list / autodetect / insmod option) */
  	if (UNSET != bttv_tvcards[btv->c.type].tuner_type)
 		if(UNSET == btv->tuner_type)
@@ -2745,7 +2784,10 @@ void __devinit bttv_init_card2(struct bt
 	if (0 == tda9887 && 0 == bttv_tvcards[btv->c.type].has_dvb &&
 	    bttv_I2CRead(btv, I2C_TDA9887, "TDA9887") >=0)
 		tda9887 = 1;
-	if (tda9887)
+	if((btv->tuner_type == TUNER_PHILIPS_FM1216ME_MK3) ||
+	   (btv->tuner_type == TUNER_PHILIPS_FM1236_MK3) ||
+	   (btv->tuner_type == TUNER_PHILIPS_FM1256_IH3) ||
+	    tda9887)
 		request_module("tda9887");
 	if (btv->tuner_type != UNSET)
 		request_module("tuner");
@@ -2753,67 +2795,6 @@ void __devinit bttv_init_card2(struct bt
 
 
 /* ----------------------------------------------------------------------- */
-/* some hauppauge specific stuff                                           */
-
-static struct HAUPPAUGE_TUNER
-{
-        int  id;
-        char *name;
-}
-hauppauge_tuner[] __devinitdata =
-{
-        { TUNER_ABSENT,        "" },
-        { TUNER_ABSENT,        "External" },
-        { TUNER_ABSENT,        "Unspecified" },
-        { TUNER_PHILIPS_PAL,   "Philips FI1216" },
-        { TUNER_PHILIPS_SECAM, "Philips FI1216MF" },
-        { TUNER_PHILIPS_NTSC,  "Philips FI1236" },
-        { TUNER_PHILIPS_PAL_I, "Philips FI1246" },
-        { TUNER_PHILIPS_PAL_DK,"Philips FI1256" },
-        { TUNER_PHILIPS_PAL,   "Philips FI1216 MK2" },
-        { TUNER_PHILIPS_SECAM, "Philips FI1216MF MK2" },
-        { TUNER_PHILIPS_NTSC,  "Philips FI1236 MK2" },
-        { TUNER_PHILIPS_PAL_I, "Philips FI1246 MK2" },
-        { TUNER_PHILIPS_PAL_DK,"Philips FI1256 MK2" },
-        { TUNER_TEMIC_NTSC,    "Temic 4032FY5" },
-        { TUNER_TEMIC_PAL,     "Temic 4002FH5" },
-        { TUNER_TEMIC_PAL_I,   "Temic 4062FY5" },
-        { TUNER_PHILIPS_PAL,   "Philips FR1216 MK2" },
-        { TUNER_PHILIPS_SECAM, "Philips FR1216MF MK2" },
-        { TUNER_PHILIPS_NTSC,  "Philips FR1236 MK2" },
-        { TUNER_PHILIPS_PAL_I, "Philips FR1246 MK2" },
-        { TUNER_PHILIPS_PAL_DK,"Philips FR1256 MK2" },
-        { TUNER_PHILIPS_PAL,   "Philips FM1216" },
-        { TUNER_PHILIPS_SECAM, "Philips FM1216MF" },
-        { TUNER_PHILIPS_NTSC,  "Philips FM1236" },
-        { TUNER_PHILIPS_PAL_I, "Philips FM1246" },
-        { TUNER_PHILIPS_PAL_DK,"Philips FM1256" },
-        { TUNER_TEMIC_4036FY5_NTSC, "Temic 4036FY5" },
-        { TUNER_ABSENT,        "Samsung TCPN9082D" },
-        { TUNER_ABSENT,        "Samsung TCPM9092P" },
-        { TUNER_TEMIC_4006FH5_PAL, "Temic 4006FH5" },
-        { TUNER_ABSENT,        "Samsung TCPN9085D" },
-        { TUNER_ABSENT,        "Samsung TCPB9085P" },
-        { TUNER_ABSENT,        "Samsung TCPL9091P" },
-        { TUNER_TEMIC_4039FR5_NTSC, "Temic 4039FR5" },
-        { TUNER_PHILIPS_FQ1216ME,   "Philips FQ1216 ME" },
-        { TUNER_TEMIC_4066FY5_PAL_I, "Temic 4066FY5" },
-        { TUNER_PHILIPS_NTSC,        "Philips TD1536" },
-        { TUNER_PHILIPS_NTSC,        "Philips TD1536D" },
-	{ TUNER_PHILIPS_NTSC,  "Philips FMR1236" }, /* mono radio */
-        { TUNER_ABSENT,        "Philips FI1256MP" },
-        { TUNER_ABSENT,        "Samsung TCPQ9091P" },
-        { TUNER_TEMIC_4006FN5_MULTI_PAL, "Temic 4006FN5" },
-        { TUNER_TEMIC_4009FR5_PAL, "Temic 4009FR5" },
-        { TUNER_TEMIC_4046FM5,     "Temic 4046FM5" },
-	{ TUNER_TEMIC_4009FN5_MULTI_PAL_FM, "Temic 4009FN5" },
-	{ TUNER_ABSENT,        "Philips TD1536D_FH_44"},
-	{ TUNER_LG_NTSC_FM,    "LG TPI8NSR01F"},
-	{ TUNER_LG_PAL_FM,     "LG TPI8PSB01D"},
-	{ TUNER_LG_PAL,        "LG TPI8PSB11D"},
-	{ TUNER_LG_PAL_I_FM,   "LG TAPC-I001D"},
-	{ TUNER_LG_PAL_I,      "LG TAPC-I701D"}
-};
 
 static void modtec_eeprom(struct bttv *btv)
 {
@@ -2837,31 +2818,11 @@ static void modtec_eeprom(struct bttv *b
 
 static void __devinit hauppauge_eeprom(struct bttv *btv)
 {
-	unsigned int blk2,tuner,radio,model;
+	struct tveeprom tv;
 
-	if (eeprom_data[0] != 0x84 || eeprom_data[2] != 0)
-		printk(KERN_WARNING "bttv%d: Hauppauge eeprom: invalid\n",
-		       btv->c.nr);
-
-	/* Block 2 starts after len+3 bytes header */
-	blk2 = eeprom_data[1] + 3;
-
-	/* decode + use some config infos */
-	model = eeprom_data[12] << 8 | eeprom_data[11];
-	tuner = eeprom_data[9];
-	radio = eeprom_data[blk2-1] & 0x01;
-
-        if (tuner < ARRAY_SIZE(hauppauge_tuner))
-                btv->tuner_type = hauppauge_tuner[tuner].id;
-	if (radio)
-		btv->has_radio = 1;
-
-	if (bttv_verbose)
-		printk(KERN_INFO "bttv%d: Hauppauge eeprom: model=%d, "
-		       "tuner=%s (%d), radio=%s\n",
-		       btv->c.nr, model, (tuner < ARRAY_SIZE(hauppauge_tuner)
-					  ? hauppauge_tuner[tuner].name : "?"),
-		       btv->tuner_type, radio ? "yes" : "no");
+	tveeprom_hauppauge_analog(&tv, eeprom_data);
+	btv->tuner_type = tv.tuner_type;
+	btv->has_radio  = tv.has_radio;
 }
 
 static int terratec_active_radio_upgrade(struct bttv *btv)
@@ -2947,7 +2908,7 @@ static int __devinit pvr_altera_load(str
 	return 0;
 }
 
-int __devinit pvr_boot(struct bttv *btv)
+static int __devinit pvr_boot(struct bttv *btv)
 {
         const struct firmware *fw_entry;
 	int rc;
@@ -3077,7 +3038,8 @@ static int tuner_0_table[] = {
         TUNER_PHILIPS_PAL,   TUNER_PHILIPS_PAL /* PAL-I*/,
         TUNER_PHILIPS_PAL,   TUNER_PHILIPS_PAL,
         TUNER_PHILIPS_SECAM, TUNER_PHILIPS_SECAM,
-        TUNER_PHILIPS_SECAM, TUNER_PHILIPS_PAL};
+        TUNER_PHILIPS_SECAM, TUNER_PHILIPS_PAL,
+	TUNER_PHILIPS_FM1216ME_MK3 };
 #if 0
 int tuner_0_fm_table[] = {
         PHILIPS_FR1236_NTSC,  PHILIPS_FR1216_PAL,
@@ -3104,12 +3066,16 @@ static void __devinit avermedia_eeprom(s
 	btv->has_remote = (eeprom_data[0x42] & 0x01);
 
 	if (tuner_make == 0 || tuner_make == 2)
-		if(tuner_format <=9)
+		if(tuner_format <=0x0a)
 			tuner = tuner_0_table[tuner_format];
 	if (tuner_make == 1)
 		if(tuner_format <=9)
 			tuner = tuner_1_table[tuner_format];
 
+	if (tuner_make == 4)
+		if(tuner_format == 0x09)
+			tuner = TUNER_LG_NTSC_NEW_TAPC; // TAPC-G702P
+
 	printk(KERN_INFO "bttv%d: Avermedia eeprom[0x%02x%02x]: tuner=",
 		btv->c.nr,eeprom_data[0x41],eeprom_data[0x42]);
 	if(tuner) {
@@ -3167,6 +3133,7 @@ static void __devinit boot_msp34xx(struc
 
 static void __devinit boot_bt832(struct bttv *btv)
 {
+#if 0 /* not working yet */
 	int resetbit=0;
 
 	switch (btv->c.type) {
@@ -3195,6 +3162,7 @@ static void __devinit boot_bt832(struct 
 	// bt832 on pixelview changes from i2c 0x8a to 0x88 after
 	// being reset as above. So we must follow by this:
 	bttv_call_i2c_clients(btv, BT832_REATTACH, NULL);
+#endif
 }
 
 /* ----------------------------------------------------------------------- */
@@ -3885,6 +3853,47 @@ static void rv605_muxsel(struct bttv *bt
 	mdelay(1);
 }
 
+/* Tibet Systems 'Progress DVR' CS16 muxsel helper [Chris Fanning]
+ *
+ * The CS16 (available on eBay cheap) is a PCI board with four Fusion
+ * 878A chips, a PCI bridge, an Atmel microcontroller, four sync seperator
+ * chips, ten eight input analog multiplexors, a not chip and a few
+ * other components.
+ *
+ * 16 inputs on a secondary bracket are provided and can be selected
+ * from each of the four capture chips.  Two of the eight input
+ * multiplexors are used to select from any of the 16 input signals.
+ *
+ * Unsupported hardware capabilities:
+ *  . A video output monitor on the secondary bracket can be selected from
+ *    one of the 878A chips.
+ *  . Another passthrough but I haven't spent any time investigating it.
+ *  . Digital I/O (logic level connected to GPIO) is available from an
+ *    onboard header.
+ *
+ * The on chip input mux should always be set to 2.
+ * GPIO[16:19] - Video input selection
+ * GPIO[0:3]   - Video output monitor select (only available from one 878A)
+ * GPIO[?:?]   - Digital I/O.
+ *
+ * There is an ATMEL microcontroller with an 8031 core on board.  I have not
+ * determined what function (if any) it provides.  With the microcontroller
+ * and sync seperator chips a guess is that it might have to do with video
+ * switching and maybe some digital I/O.
+ */
+static void tibetCS16_muxsel(struct bttv *btv, unsigned int input)
+{
+	/* video mux */
+	gpio_bits(0x0f0000, input << 16);
+}
+
+static void tibetCS16_init(struct bttv *btv)
+{
+	/* enable gpio bits, mask obtained via btSpy */
+	gpio_inout(0xffffff, 0x0f7fff);
+	gpio_write(0x0f7fff);
+}
+
 // The Grandtec X-Guard framegrabber card uses two Dual 4-channel
 // video multiplexers to provide up to 16 video inputs. These
 // multiplexers are controlled by the lower 8 GPIO pins of the
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-driver.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-driver.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-driver.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-driver.c	2005-01-26 15:43:26.333512651 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-driver.c,v 1.27 2004/11/07 14:44:59 kraxel Exp $
+    $Id: bttv-driver.c,v 1.34 2005/01/07 13:11:19 kraxel Exp $
 
     bttv - Bt848 frame grabber driver
 
@@ -27,6 +27,7 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
@@ -105,6 +106,7 @@ module_param(adc_crush,         int, 044
 module_param(whitecrush_upper,  int, 0444);
 module_param(whitecrush_lower,  int, 0444);
 module_param(vcr_hack,          int, 0444);
+
 module_param_array(radio, int, NULL, 0444);
 
 MODULE_PARM_DESC(radio,"The TV card supports radio, default is 0 (no)");
@@ -1063,7 +1065,7 @@ static void init_bt848(struct bttv *btv)
 	init_irqreg(btv);
 }
 
-void bttv_reinit_bt848(struct bttv *btv)
+static void bttv_reinit_bt848(struct bttv *btv)
 {
 	unsigned long flags;
 
@@ -1267,7 +1269,7 @@ void bttv_gpio_tracking(struct bttv *btv
 	       btv->c.nr,outbits,data & outbits, data & ~outbits, comment);
 }
 
-void bttv_field_count(struct bttv *btv)
+static void bttv_field_count(struct bttv *btv)
 {
 	int need_count = 0;
 
@@ -1467,7 +1469,7 @@ static const char *v4l1_ioctls[] = {
 	"SMICROCODE", "GVBIFMT", "SVBIFMT" };
 #define V4L1_IOCTLS ARRAY_SIZE(v4l1_ioctls)
 
-int bttv_common_ioctls(struct bttv *btv, unsigned int cmd, void *arg)
+static int bttv_common_ioctls(struct bttv *btv, unsigned int cmd, void *arg)
 {
 	switch (cmd) {
         case BTTV_VERSION:
@@ -2531,9 +2533,11 @@ static int bttv_do_ioctl(struct inode *i
 			V4L2_CAP_VIDEO_CAPTURE |
 			V4L2_CAP_VIDEO_OVERLAY |
 			V4L2_CAP_VBI_CAPTURE |
-			V4L2_CAP_TUNER |
 			V4L2_CAP_READWRITE |
 			V4L2_CAP_STREAMING;
+		if (bttv_tvcards[btv->c.type].tuner != UNSET &&
+		    bttv_tvcards[btv->c.type].tuner != TUNER_ABSENT)
+			cap->capabilities |= V4L2_CAP_TUNER;
 		return 0;
 	}
 
@@ -2988,6 +2992,9 @@ static int bttv_release(struct inode *in
 		free_btres(btv,fh,RESOURCE_VBI);
 	}
 
+	/* free stuff */
+	videobuf_mmap_free(&fh->cap);
+	videobuf_mmap_free(&fh->vbi);
 	v4l2_prio_close(&btv->prio,&fh->prio);
 	file->private_data = NULL;
 	kfree(fh);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-i2c.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-i2c.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-i2c.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-i2c.c	2005-01-26 15:43:26.335512339 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-i2c.c,v 1.13 2004/11/07 13:17:15 kraxel Exp $
+    $Id: bttv-i2c.c,v 1.17 2004/12/14 15:33:30 kraxel Exp $
 
     bttv-i2c.c  --  all the i2c code is here
 
@@ -26,6 +26,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <asm/io.h>
@@ -327,13 +328,6 @@ void bttv_call_i2c_clients(struct bttv *
 	i2c_clients_command(&btv->c.i2c_adap, cmd, arg);
 }
 
-void bttv_i2c_call(unsigned int card, unsigned int cmd, void *arg)
-{
-	if (card >= bttv_num)
-		return;
-	bttv_call_i2c_clients(&bttvs[card], cmd, arg);
-}
-
 static struct i2c_client bttv_i2c_client_template = {
 	I2C_DEVNAME("bttv internal"),
         .id       = -1,
@@ -385,19 +379,8 @@ int bttv_I2CWrite(struct bttv *btv, unsi
 /* read EEPROM content */
 void __devinit bttv_readee(struct bttv *btv, unsigned char *eedata, int addr)
 {
-	int i;
-
-	if (bttv_I2CWrite(btv, addr, 0, -1, 0)<0) {
-		printk(KERN_WARNING "bttv: readee error\n");
-		return;
-	}
 	btv->i2c_client.addr = addr >> 1;
-	for (i=0; i<256; i+=16) {
-		if (16 != i2c_master_recv(&btv->i2c_client,eedata+i,16)) {
-			printk(KERN_WARNING "bttv: readee error\n");
-			break;
-		}
-	}
+	tveeprom_read(&btv->i2c_client, eedata, 256);
 }
 
 static char *i2c_devs[128] = {
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-if.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-if.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-if.c	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-if.c	2005-01-26 15:43:26.336512183 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-if.c,v 1.3 2004/10/13 10:39:00 kraxel Exp $
+    $Id: bttv-if.c,v 1.4 2004/11/17 18:47:47 kraxel Exp $
 
     bttv-if.c  --  old gpio interface to other kernel modules
                    don't use in new code, will go away in 2.7
@@ -50,6 +50,8 @@ EXPORT_SYMBOL(bttv_i2c_call);
 
 int bttv_get_cardinfo(unsigned int card, int *type, unsigned *cardid)
 {
+	printk("The bttv_* interface is obsolete and will go away,\n"
+	       "please use the new, sysfs based interface instead.\n");
 	if (card >= bttv_num) {
 		return -1;
 	}
@@ -67,7 +69,8 @@ struct pci_dev* bttv_get_pcidev(unsigned
 
 int bttv_get_id(unsigned int card)
 {
-	printk("bttv_get_id is obsolete, use bttv_get_cardinfo instead\n");
+	printk("The bttv_* interface is obsolete and will go away,\n"
+	       "please use the new, sysfs based interface instead.\n");
 	if (card >= bttv_num) {
 		return -1;
 	}
@@ -143,6 +146,13 @@ wait_queue_head_t* bttv_get_gpio_queue(u
 	return &btv->gpioq;
 }
 
+void bttv_i2c_call(unsigned int card, unsigned int cmd, void *arg)
+{
+	if (card >= bttv_num)
+		return;
+	bttv_call_i2c_clients(&bttvs[card], cmd, arg);
+}
+
 /*
  * Local variables:
  * c-basic-offset: 8
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-risc.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-risc.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-risc.c	2005-01-22 02:48:02.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-risc.c	2005-01-26 15:43:26.338511871 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-risc.c,v 1.9 2004/10/13 10:39:00 kraxel Exp $
+    $Id: bttv-risc.c,v 1.10 2004/11/19 18:07:12 kraxel Exp $
 
     bttv-risc.c  --  interfaces to other kernel modules
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv-vbi.c linux-2.6.11-rc2-bk4/drivers/media/video/bttv-vbi.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv-vbi.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv-vbi.c	2005-01-26 15:43:26.339511715 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttv-vbi.c,v 1.7 2004/11/07 13:17:15 kraxel Exp $
+    $Id: bttv-vbi.c,v 1.9 2005/01/13 17:22:33 kraxel Exp $
 
     bttv - Bt848 frame grabber driver
     vbi interface
@@ -22,6 +22,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
 #include <linux/kernel.h>
@@ -182,7 +183,7 @@ void bttv_vbi_try_fmt(struct bttv_fh *fh
 	case 2: /* SECAM */
 	default:
 		start0 = 7;
-		start1 = 319;
+		start1 = 320;
 	}
 
 	count0 = (f->fmt.vbi.start[0] + f->fmt.vbi.count[0]) - start0;
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttv.h linux-2.6.11-rc2-bk4/drivers/media/video/bttv.h
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttv.h	2005-01-22 02:47:15.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttv.h	2005-01-26 15:43:26.340511560 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: bttv.h,v 1.10 2004/10/13 10:39:00 kraxel Exp $
+ * $Id: bttv.h,v 1.14 2005/01/07 13:11:19 kraxel Exp $
  *
  *  bttv - Bt848 frame grabber driver
  *
@@ -133,6 +133,7 @@
 #define BTTV_MATRIX_VISIONSLC 0x7e
 #define BTTV_APAC_VIEWCOMP  0x7f
 #define BTTV_DVICO_DVBT_LITE  0x80
+#define BTTV_TIBET_CS16  0x83
 
 /* i2c address list */
 #define I2C_TSA5522        0xc2
@@ -149,7 +150,7 @@
 #define I2C_VHX            0xc0
 #define I2C_MSP3400        0x80
 #define I2C_MSP3400_ALT    0x88
-#define I2C_TEA6300        0x80
+#define I2C_TEA6300        0x80 /* also used by 6320 */
 #define I2C_DPL3518	   0x84
 #define I2C_TDA9887	   0x86
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/bttvp.h linux-2.6.11-rc2-bk4/drivers/media/video/bttvp.h
--- linux-2.6.11-rc2-bk3/drivers/media/video/bttvp.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/bttvp.h	2005-01-26 15:43:26.341511404 +0100
@@ -1,5 +1,5 @@
 /*
-    $Id: bttvp.h,v 1.12 2004/10/25 11:26:36 kraxel Exp $
+    $Id: bttvp.h,v 1.15 2004/12/14 15:33:30 kraxel Exp $
 
     bttv - Bt848 frame grabber driver
 
@@ -43,6 +43,7 @@
 #include <media/video-buf.h>
 #include <media/audiochip.h>
 #include <media/tuner.h>
+#include <media/tveeprom.h>
 #include <media/ir-common.h>
 
 #include "bt848.h"
@@ -221,11 +222,6 @@ extern unsigned int bttv_gpio;
 extern void bttv_gpio_tracking(struct bttv *btv, char *comment);
 extern int init_bttv_i2c(struct bttv *btv);
 extern int fini_bttv_i2c(struct bttv *btv);
-extern int pvr_boot(struct bttv *btv);
-
-extern int bttv_common_ioctls(struct bttv *btv, unsigned int cmd, void *arg);
-extern void bttv_reinit_bt848(struct bttv *btv);
-extern void bttv_field_count(struct bttv *btv);
 
 #define vprintk  if (bttv_verbose) printk
 #define dprintk  if (bttv_debug >= 1) printk
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/cx88/cx88-i2c.c linux-2.6.11-rc2-bk4/drivers/media/video/cx88/cx88-i2c.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/cx88/cx88-i2c.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/cx88/cx88-i2c.c	2005-01-26 15:43:26.342511248 +0100
@@ -134,7 +134,7 @@ static struct i2c_algo_bit_data cx8800_i
 static struct i2c_adapter cx8800_i2c_adap_template = {
 	I2C_DEVNAME("cx2388x"),
 	.owner             = THIS_MODULE,
-	.id                = I2C_HW_B_BT848,
+	.id                = I2C_HW_B_CX2388x,
 	.client_register   = attach_inform,
 	.client_unregister = detach_inform,
 };
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/ir-kbd-gpio.c linux-2.6.11-rc2-bk4/drivers/media/video/ir-kbd-gpio.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/ir-kbd-gpio.c	2005-01-22 02:48:45.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/ir-kbd-gpio.c	2005-01-26 15:43:26.344510936 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: ir-kbd-gpio.c,v 1.10 2004/09/15 16:15:24 kraxel Exp $
+ * $Id: ir-kbd-gpio.c,v 1.11 2004/10/25 11:26:36 kraxel Exp $
  *
  * Copyright (c) 2003 Gerd Knorr
  * Copyright (c) 2003 Pavel Machek
@@ -366,7 +366,7 @@ static int ir_probe(struct device *dev)
 		break;
 
 	case BTTV_AVDVBT_761:
-	/* case BTTV_AVDVBT_771: */
+	case BTTV_AVDVBT_771:
 		ir_codes         = ir_codes_avermedia_dvbt;
 		ir->mask_keycode = 0x0f00c0;
 		ir->mask_keydown = 0x000020;
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/ir-kbd-i2c.c linux-2.6.11-rc2-bk4/drivers/media/video/ir-kbd-i2c.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/ir-kbd-i2c.c	2005-01-22 02:46:41.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/ir-kbd-i2c.c	2005-01-26 15:43:26.345510780 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: ir-kbd-i2c.c,v 1.8 2004/09/15 16:15:24 kraxel Exp $
+ * $Id: ir-kbd-i2c.c,v 1.10 2004/12/09 12:51:35 kraxel Exp $
  *
  * keyboard input driver for i2c IR remote controls
  *
@@ -433,7 +433,7 @@ static int ir_probe(struct i2c_adapter *
 	*/
 
 	static const int probe_bttv[] = { 0x1a, 0x18, 0x4b, 0x64, 0x30, -1};
-	static const int probe_saa7134[] = { 0x7a, -1};
+	static const int probe_saa7134[] = { 0x7a, -1 };
 	const int *probe = NULL;
 	struct i2c_client c; char buf; int i,rc;
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/msp3400.c linux-2.6.11-rc2-bk4/drivers/media/video/msp3400.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/msp3400.c	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/msp3400.c	2005-01-26 15:43:26.348510313 +0100
@@ -36,6 +36,7 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/string.h>
@@ -379,7 +380,7 @@ static void msp3400c_setvolume(struct i2
 	int val = 0, bal = 0;
 
 	if (!muted) {
-		val = (volume * 0x73 / 65535) << 8;
+		val = (volume * 0x7F / 65535) << 8;
 	}
 	if (val) {
 		bal = (balance / 256) - 128;
@@ -1202,7 +1203,7 @@ static void msp34xxg_set_source(struct i
 static int msp34xxg_init(struct i2c_client *client)
 {
 	struct msp3400c *msp = i2c_get_clientdata(client);
-	int modus;
+	int modus,std;
 
 	if (msp3400c_reset(client))
 		return -1;
@@ -1216,6 +1217,7 @@ static int msp34xxg_init(struct i2c_clie
 
 	/* step-by-step initialisation, as described in the manual */
 	modus = msp34xx_modus(msp->norm);
+	std   = msp34xx_standard(msp->norm);
 	modus &= ~0x03; /* STATUS_CHANGE=0 */
 	modus |= 0x01;  /* AUTOMATIC_SOUND_DETECTION=1 */
 	if (msp3400c_write(client,
@@ -1223,6 +1225,11 @@ static int msp34xxg_init(struct i2c_clie
 			   0x30/*MODUS*/,
 			   modus))
 		return -1;
+	if (msp3400c_write(client,
+			   I2C_MSP3400C_DEM,
+			   0x20/*stanard*/,
+			   std))
+		return -1;
 
 	/* write the dfps that may have an influence on
 	   standard/audio autodetection right now */
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/saa5246a.c linux-2.6.11-rc2-bk4/drivers/media/video/saa5246a.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/saa5246a.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/saa5246a.c	2005-01-26 15:43:26.350510001 +0100
@@ -682,6 +682,54 @@ static int do_saa5246a_ioctl(struct inod
 }
 
 /*
+ * Translates old vtx IOCTLs to new ones
+ *
+ * This keeps new kernel versions compatible with old userspace programs.
+ */
+static inline unsigned int vtx_fix_command(unsigned int cmd)
+{
+	switch (cmd) {
+	case VTXIOCGETINFO_OLD:
+		cmd = VTXIOCGETINFO;
+		break;
+	case VTXIOCCLRPAGE_OLD:
+		cmd = VTXIOCCLRPAGE;
+		break;
+	case VTXIOCCLRFOUND_OLD:
+		cmd = VTXIOCCLRFOUND;
+		break;
+	case VTXIOCPAGEREQ_OLD:
+		cmd = VTXIOCPAGEREQ;
+		break;
+	case VTXIOCGETSTAT_OLD:
+		cmd = VTXIOCGETSTAT;
+		break;
+	case VTXIOCGETPAGE_OLD:
+		cmd = VTXIOCGETPAGE;
+		break;
+	case VTXIOCSTOPDAU_OLD:
+		cmd = VTXIOCSTOPDAU;
+		break;
+	case VTXIOCPUTPAGE_OLD:
+		cmd = VTXIOCPUTPAGE;
+		break;
+	case VTXIOCSETDISP_OLD:
+		cmd = VTXIOCSETDISP;
+		break;
+	case VTXIOCPUTSTAT_OLD:
+		cmd = VTXIOCPUTSTAT;
+		break;
+	case VTXIOCCLRCACHE_OLD:
+		cmd = VTXIOCCLRCACHE;
+		break;
+	case VTXIOCSETVIRT_OLD:
+		cmd = VTXIOCSETVIRT;
+		break;
+	}
+	return cmd;
+}
+
+/*
  *	Handle the locking
  */
 static int saa5246a_ioctl(struct inode *inode, struct file *file,
@@ -691,6 +739,7 @@ static int saa5246a_ioctl(struct inode *
 	struct saa5246a_device *t = vd->priv;
 	int err;
 
+	cmd = vtx_fix_command(cmd);
 	down(&t->lock);
 	err = video_usercopy(inode, file, cmd, arg, do_saa5246a_ioctl);
 	up(&t->lock);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/saa5246a.h linux-2.6.11-rc2-bk4/drivers/media/video/saa5246a.h
--- linux-2.6.11-rc2-bk3/drivers/media/video/saa5246a.h	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/saa5246a.h	2005-01-26 15:43:26.351509845 +0100
@@ -23,7 +23,7 @@
 #define __SAA5246A_H__
 
 #define MAJOR_VERSION 1		/* driver major version number */
-#define MINOR_VERSION 7		/* driver minor version number */
+#define MINOR_VERSION 8		/* driver minor version number */
 
 #define IF_NAME "SAA5246A"
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/saa5249.c linux-2.6.11-rc2-bk4/drivers/media/video/saa5249.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/saa5249.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/saa5249.c	2005-01-26 15:43:26.353509534 +0100
@@ -1,4 +1,7 @@
 /*
+ * Modified in order to keep it compatible both with new and old videotext IOCTLs by
+ * Michael Geng <linux@MichaelGeng.de>
+ *
  *	Cleaned up to use existing videodev interface and allow the idea
  *	of multiple teletext decoders on the video4linux iface. Changed i2c
  *	to cover addressing clashes on device busses. It's also rebuilt so
@@ -58,7 +61,7 @@
 #include <asm/uaccess.h>
 
 #define VTX_VER_MAJ 1
-#define VTX_VER_MIN 7
+#define VTX_VER_MIN 8
 
 
 
@@ -578,6 +581,54 @@ static int do_saa5249_ioctl(struct inode
 }
 
 /*
+ * Translates old vtx IOCTLs to new ones
+ *
+ * This keeps new kernel versions compatible with old userspace programs.
+ */
+static inline unsigned int vtx_fix_command(unsigned int cmd)
+{
+	switch (cmd) {
+	case VTXIOCGETINFO_OLD:
+		cmd = VTXIOCGETINFO;
+		break;
+	case VTXIOCCLRPAGE_OLD:
+		cmd = VTXIOCCLRPAGE;
+		break;
+	case VTXIOCCLRFOUND_OLD:
+		cmd = VTXIOCCLRFOUND;
+		break;
+	case VTXIOCPAGEREQ_OLD:
+		cmd = VTXIOCPAGEREQ;
+		break;
+	case VTXIOCGETSTAT_OLD:
+		cmd = VTXIOCGETSTAT;
+		break;
+	case VTXIOCGETPAGE_OLD:
+		cmd = VTXIOCGETPAGE;
+		break;
+	case VTXIOCSTOPDAU_OLD:
+		cmd = VTXIOCSTOPDAU;
+		break;
+	case VTXIOCPUTPAGE_OLD:
+		cmd = VTXIOCPUTPAGE;
+		break;
+	case VTXIOCSETDISP_OLD:
+		cmd = VTXIOCSETDISP;
+		break;
+	case VTXIOCPUTSTAT_OLD:
+		cmd = VTXIOCPUTSTAT;
+		break;
+	case VTXIOCCLRCACHE_OLD:
+		cmd = VTXIOCCLRCACHE;
+		break;
+	case VTXIOCSETVIRT_OLD:
+		cmd = VTXIOCSETVIRT;
+		break;
+	}
+	return cmd;
+}
+
+/*
  *	Handle the locking
  */
  
@@ -588,6 +639,7 @@ static int saa5249_ioctl(struct inode *i
 	struct saa5249_device *t=vd->priv;
 	int err;
 	
+	cmd = vtx_fix_command(cmd);
 	down(&t->lock);
 	err = video_usercopy(inode,file,cmd,arg,do_saa5249_ioctl);
 	up(&t->lock);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/saa7134/saa7134-core.c linux-2.6.11-rc2-bk4/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/saa7134/saa7134-core.c	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/saa7134/saa7134-core.c	2005-01-26 15:43:26.356509066 +0100
@@ -21,6 +21,7 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/module.h>
@@ -222,6 +223,57 @@ static void dump_statusregs(struct saa71
 }
 #endif
 
+/* ----------------------------------------------------------- */
+/* delayed request_module                                      */
+
+#ifdef CONFIG_MODULES
+
+static int need_empress;
+static int need_dvb;
+
+static int pending_call(struct notifier_block *self, unsigned long state,
+			void *module)
+{
+	if (module != THIS_MODULE || state != MODULE_STATE_LIVE)
+		return NOTIFY_DONE;
+
+        if (need_empress)
+                request_module("saa7134-empress");
+        if (need_dvb)
+                request_module("saa7134-dvb");
+	return NOTIFY_DONE;
+}
+
+static int pending_registered;
+static struct notifier_block pending_notifier = {
+	.notifier_call = pending_call,
+};
+
+static void request_module_depend(char *name, int *flag)
+{
+	switch (THIS_MODULE->state) {
+	case MODULE_STATE_COMING:
+		if (!pending_registered) {
+			register_module_notifier(&pending_notifier);
+			pending_registered = 1;
+		}
+		*flag = 1;
+		break;
+	case MODULE_STATE_LIVE:
+		request_module(name);
+		break;
+	default:
+		/* nothing */;
+		break;
+	}
+}
+
+#else
+
+#define request_module_depend(name,flag)
+
+#endif /* CONFIG_MODULES */
+
 /* ------------------------------------------------------------------ */
 
 /* nr of (saa7134-)pages for the given buffer size */
@@ -941,11 +993,11 @@ static int __devinit saa7134_initdev(str
 	if (dev->tda9887_conf)
 		request_module("tda9887");
   	if (card_is_empress(dev)) {
-		request_module("saa7134-empress");
 		request_module("saa6752hs");
+		request_module_depend("saa7134-empress",&need_empress);
 	}
   	if (card_is_dvb(dev))
-		request_module("saa7134-dvb");
+		request_module_depend("saa7134-dvb",&need_dvb);
 
 	v4l2_prio_init(&dev->prio);
 
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tda9887.c linux-2.6.11-rc2-bk4/drivers/media/video/tda9887.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/tda9887.c	2005-01-22 02:49:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tda9887.c	2005-01-26 15:43:26.359508599 +0100
@@ -1,4 +1,5 @@
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/i2c.h>
 #include <linux/types.h>
@@ -27,6 +28,7 @@
 
 /* Addresses to scan */
 static unsigned short normal_i2c[] = {
+	0x84 >>1,
 	0x86 >>1,
 	0x96 >>1,
 	I2C_CLIENT_END,
@@ -374,8 +376,8 @@ static int tda9887_set_tvnorm(struct tda
 	return 0;
 }
 
-static unsigned int port1  = 1;
-static unsigned int port2  = 1;
+static unsigned int port1  = UNSET;
+static unsigned int port2  = UNSET;
 static unsigned int qss    = UNSET;
 static unsigned int adjust = 0x10;
 module_param(port1, int, 0644);
@@ -385,10 +387,19 @@ module_param(adjust, int, 0644);
 
 static int tda9887_set_insmod(struct tda9887 *t, char *buf)
 {
-	if (port1)
-		buf[1] |= cOutputPort1Inactive;
-	if (port2)
-		buf[1] |= cOutputPort2Inactive;
+	if (UNSET != port1) {
+		if (port1)
+			buf[1] |= cOutputPort1Inactive;
+		else
+			buf[1] &= ~cOutputPort1Inactive;
+	}
+	if (UNSET != port2) {
+		if (port2)
+			buf[1] |= cOutputPort2Inactive;
+		else
+			buf[1] &= ~cOutputPort2Inactive;
+	}
+
 	if (UNSET != qss) {
 		if (qss)
 			buf[1] |= cQSS;
@@ -403,10 +414,15 @@ static int tda9887_set_insmod(struct tda
 
 static int tda9887_set_config(struct tda9887 *t, char *buf)
 {
-	if (t->config & TDA9887_PORT1)
+	if (t->config & TDA9887_PORT1_ACTIVE)
+		buf[1] &= ~cOutputPort1Inactive;
+	if (t->config & TDA9887_PORT1_INACTIVE)
 		buf[1] |= cOutputPort1Inactive;
-	if (t->config & TDA9887_PORT2)
+	if (t->config & TDA9887_PORT2_ACTIVE)
+		buf[1] &= ~cOutputPort2Inactive;
+	if (t->config & TDA9887_PORT2_INACTIVE)
 		buf[1] |= cOutputPort2Inactive;
+
 	if (t->config & TDA9887_QSS)
 		buf[1] |= cQSS;
 	if (t->config & TDA9887_INTERCARRIER)
@@ -437,14 +453,14 @@ static int tda9887_set_pinnacle(struct t
 {
 	unsigned int bCarrierMode = UNSET;
 
-	if (t->std & V4L2_STD_PAL) {
+	if (t->std & V4L2_STD_625_50) {
 		if ((1 == t->pinnacle_id) || (7 == t->pinnacle_id)) {
 			bCarrierMode = cIntercarrier;
 		} else {
 			bCarrierMode = cQSS;
 		}
 	}
-	if (t->std & V4L2_STD_NTSC) {
+	if (t->std & V4L2_STD_525_60) {
                 if ((5 == t->pinnacle_id) || (6 == t->pinnacle_id)) {
 			bCarrierMode = cIntercarrier;
 		} else {
@@ -529,6 +545,8 @@ static int tda9887_configure(struct tda9
 	int rc;
 
 	memset(buf,0,sizeof(buf));
+	buf[1] |= cOutputPort1Inactive;
+	buf[1] |= cOutputPort2Inactive;
 	tda9887_set_tvnorm(t,buf);
 	if (UNSET != t->pinnacle_id) {
 		tda9887_set_pinnacle(t,buf);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tuner.c linux-2.6.11-rc2-bk4/drivers/media/video/tuner.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/tuner.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tuner.c	2005-01-26 15:43:26.363507975 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: tuner.c,v 1.31 2004/11/10 11:07:24 kraxel Exp $
+ * $Id: tuner.c,v 1.36 2005/01/14 13:29:40 kraxel Exp $
  */
 
 #include <linux/module.h>
@@ -62,7 +62,7 @@ struct tuner {
 	v4l2_std_id  std;
 	int          using_v4l2;
 
-	unsigned int radio;
+	enum v4l2_tuner_type mode;
 	unsigned int input;
 
 	// only for MT2032
@@ -265,6 +265,11 @@ static struct tunertype tuners[] = {
 	{ "Philips PAL/SECAM_D (FM 1256 I-H3)", Philips, PAL,
 	  16*160.00,16*442.00,0x01,0x02,0x04,0x8e,623 },
 
+	{ "Thomson DDT 7610 ATSC/NTSC)", THOMSON, ATSC,
+	  16*157.25,16*454.00,0x39,0x3a,0x3c,0x8e,732},
+	{ "Philips FQ1286", Philips, NTSC,
+	  16*160.00,16*454.00,0x41,0x42,0x04,0x8e,940}, // UHF band untested
+
 };
 #define TUNERS ARRAY_SIZE(tuners)
 
@@ -663,7 +668,8 @@ static void mt2050_set_if_freq(struct i2
 	int ret;
 	unsigned char buf[6];
 
-	dprintk("mt2050_set_if_freq freq=%d\n",freq);
+	dprintk("mt2050_set_if_freq freq=%d if1=%d if2=%d\n",
+		freq,if1,if2);
 
 	f_lo1=freq+if1;
 	f_lo1=(f_lo1/1000000)*1000000;
@@ -688,9 +694,10 @@ static void mt2050_set_if_freq(struct i2
 	div2a=(lo2/8)-1;
 	div2b=lo2-(div2a+1)*8;
 
-	dprintk("lo1 lo2 = %d %d\n", lo1, lo2);
-        dprintk("num1 num2 div1a div1b div2a div2b= %x %x %x %x %x %x\n",num1,num2,div1a,div1b,div2a,div2b);
-
+	if (debug > 1) {
+		printk("lo1 lo2 = %d %d\n", lo1, lo2);
+		printk("num1 num2 div1a div1b div2a div2b= %x %x %x %x %x %x\n",num1,num2,div1a,div1b,div2a,div2b);
+	}
 
 	buf[0]=1;
 	buf[1]= 4*div1b + num1;
@@ -702,7 +709,7 @@ static void mt2050_set_if_freq(struct i2
 	buf[5]=div2a;
 	if(num2!=0) buf[5]=buf[5]|0x40;
 
-	if(debug) {
+	if (debug > 1) {
 		int i;
 		printk("bufs is: ");
 		for(i=0;i<6;i++)
@@ -727,6 +734,10 @@ static void mt2050_set_tv_freq(struct i2
                 // PAL
                 if2 = 38900*1000;
         }
+	if (V4L2_TUNER_DIGITAL_TV == t->mode) {
+		// testing for DVB ...
+		if2 = 36150*1000;
+	}
 	mt2050_set_if_freq(c, freq*62500, if2);
 	mt2050_set_antenna(c, tv_antenna);
 }
@@ -1069,14 +1080,18 @@ static void set_freq(struct i2c_client *
 {
 	struct tuner *t = i2c_get_clientdata(c);
 
-	if (t->radio) {
+	switch (t->mode) {
+	case V4L2_TUNER_RADIO:
 		dprintk("tuner: radio freq set to %lu.%02lu\n",
 			freq/16,freq%16*100/16);
 		set_radio_freq(c,freq);
-	} else {
+		break;
+	case V4L2_TUNER_ANALOG_TV:
+	case V4L2_TUNER_DIGITAL_TV:
 		dprintk("tuner: tv freq set to %lu.%02lu\n",
 			freq/16,freq%16*100/16);
 		set_tv_freq(c, freq);
+		break;
 	}
 	t->freq = freq;
 }
@@ -1237,9 +1252,9 @@ tuner_command(struct i2c_client *client,
 		set_type(client,*iarg,client->adapter->name);
 		break;
 	case AUDC_SET_RADIO:
-		if (!t->radio) {
+		if (V4L2_TUNER_RADIO != t->mode) {
 			set_tv_freq(client,400 * 16);
-			t->radio = 1;
+			t->mode = V4L2_TUNER_RADIO;
 		}
 		break;
 	case AUDC_CONFIG_PINNACLE:
@@ -1271,7 +1286,7 @@ tuner_command(struct i2c_client *client,
 		struct video_channel *vc = arg;
 
 		CHECK_V4L2;
-		t->radio = 0;
+		t->mode = V4L2_TUNER_ANALOG_TV;
 		if (vc->norm < ARRAY_SIZE(map))
 			t->std = map[vc->norm];
 		tuner_fixup_std(t);
@@ -1292,7 +1307,7 @@ tuner_command(struct i2c_client *client,
 		struct video_tuner *vt = arg;
 
 		CHECK_V4L2;
-		if (t->radio)
+		if (V4L2_TUNER_RADIO == t->mode)
 			vt->signal = tuner_signal(client);
 		return 0;
 	}
@@ -1301,7 +1316,7 @@ tuner_command(struct i2c_client *client,
 		struct video_audio *va = arg;
 
 		CHECK_V4L2;
-		if (t->radio)
+		if (V4L2_TUNER_RADIO == t->mode)
 			va->mode = (tuner_stereo(client) ? VIDEO_SOUND_STEREO : VIDEO_SOUND_MONO);
 		return 0;
 	}
@@ -1311,7 +1326,7 @@ tuner_command(struct i2c_client *client,
 		v4l2_std_id *id = arg;
 
 		SWITCH_V4L2;
-		t->radio = 0;
+		t->mode = V4L2_TUNER_ANALOG_TV;
 		t->std = *id;
 		tuner_fixup_std(t);
 		if (t->freq)
@@ -1323,15 +1338,10 @@ tuner_command(struct i2c_client *client,
 		struct v4l2_frequency *f = arg;
 
 		SWITCH_V4L2;
-		if (V4L2_TUNER_ANALOG_TV == f->type) {
-			t->radio = 0;
-		}
-		if (V4L2_TUNER_RADIO == f->type) {
-			if (!t->radio) {
-				set_tv_freq(client,400*16);
-				t->radio = 1;
-			}
-		}
+		if (V4L2_TUNER_RADIO == f->type &&
+		    V4L2_TUNER_RADIO != t->mode)
+			set_tv_freq(client,400*16);
+		t->mode  = f->type;
 		t->freq  = f->frequency;
 		set_freq(client,t->freq);
 		break;
@@ -1341,7 +1351,7 @@ tuner_command(struct i2c_client *client,
 		struct v4l2_tuner *tuner = arg;
 
 		SWITCH_V4L2;
-		if (t->radio)
+		if (V4L2_TUNER_RADIO == t->mode)
 			tuner->signal = tuner_signal(client);
 		break;
 	}
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tvaudio.c linux-2.6.11-rc2-bk4/drivers/media/video/tvaudio.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/tvaudio.c	2005-01-22 02:47:33.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tvaudio.c	2005-01-26 15:43:26.367507352 +0100
@@ -16,6 +16,7 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/string.h>
@@ -1027,6 +1028,21 @@ static int tda9874a_initialize(struct CH
 #define TEA6300_S_SC       0x04  /* stereo C */
 #define TEA6300_S_GMU      0x80  /* general mute */
 
+#define TEA6320_V          0x00  /* volume (0-5)/loudness off (6)/zero crossing mute(7) */
+#define TEA6320_FFR        0x01  /* fader front right (0-5) */
+#define TEA6320_FFL        0x02  /* fader front left (0-5) */
+#define TEA6320_FRR        0x03  /* fader rear right (0-5) */
+#define TEA6320_FRL        0x04  /* fader rear left (0-5) */
+#define TEA6320_BA         0x05  /* bass (0-4) */
+#define TEA6320_TR         0x06  /* treble (0-4) */
+#define TEA6320_S          0x07  /* switch register */
+                                 /* values for those registers: */
+#define TEA6320_S_SA       0x07  /* stereo A input */
+#define TEA6320_S_SB       0x06  /* stereo B */
+#define TEA6320_S_SC       0x05  /* stereo C */
+#define TEA6320_S_SD       0x04  /* stereo D */
+#define TEA6320_S_GMU      0x80  /* general mute */
+
 #define TEA6420_S_SA       0x00  /* stereo A input */
 #define TEA6420_S_SB       0x01  /* stereo B */
 #define TEA6420_S_SC       0x02  /* stereo C */
@@ -1037,6 +1053,20 @@ static int tda9874a_initialize(struct CH
 static int tea6300_shift10(int val) { return val >> 10; }
 static int tea6300_shift12(int val) { return val >> 12; }
 
+/* Assumes 16bit input (values 0x3f to 0x0c are unique, values less than */
+/* 0x0c mirror those immediately higher) */
+static int tea6320_volume(int val) { return (val / (65535/(63-12)) + 12) & 0x3f; }
+static int tea6320_shift11(int val) { return val >> 11; }
+static int tea6320_initialize(struct CHIPSTATE * chip)
+{
+	chip_write(chip, TEA6320_FFR, 0x3f);
+	chip_write(chip, TEA6320_FFL, 0x3f);
+	chip_write(chip, TEA6320_FRR, 0x3f);
+	chip_write(chip, TEA6320_FRL, 0x3f);
+
+	return 0;
+}
+
 
 /* ---------------------------------------------------------------------- */
 /* audio chip descriptions - defines+functions for tda8425                */
@@ -1214,6 +1244,7 @@ int tda9855  = 1;
 int tda9873  = 1;
 int tda9874a = 1;
 int tea6300  = 0;  // address clash with msp34xx
+int tea6320  = 0;  // address clash with msp34xx
 int tea6420  = 1;
 int pic16c54 = 1;
 int ta8874z  = 0;  // address clash with tda9840
@@ -1225,6 +1256,7 @@ module_param(tda9855, int, 0444);
 module_param(tda9873, int, 0444);
 module_param(tda9874a, int, 0444);
 module_param(tea6300, int, 0444);
+module_param(tea6320, int, 0444);
 module_param(tea6420, int, 0444);
 module_param(pic16c54, int, 0444);
 module_param(ta8874z, int, 0444);
@@ -1339,6 +1371,28 @@ static struct CHIPDESC chiplist[] = {
 		.inputmute  = TEA6300_S_GMU,
 	},
 	{
+		.name       = "tea6320",
+		.id         = I2C_DRIVERID_TEA6300,
+		.initialize = tea6320_initialize,
+		.insmodopt  = &tea6320,
+		.addr_lo    = I2C_TEA6300 >> 1,
+		.addr_hi    = I2C_TEA6300 >> 1,
+		.registers  = 8,
+		.flags      = CHIP_HAS_VOLUME | CHIP_HAS_BASSTREBLE | CHIP_HAS_INPUTSEL,
+
+		.leftreg    = TEA6320_V,
+		.rightreg   = TEA6320_V,
+		.bassreg    = TEA6320_BA,
+		.treblereg  = TEA6320_TR,
+		.volfunc    = tea6320_volume,
+		.bassfunc   = tea6320_shift11,
+		.treblefunc = tea6320_shift11,
+
+		.inputreg   = TEA6320_S,
+		.inputmap   = { TEA6320_S_SA, TEA6420_S_SB, TEA6300_S_SC, TEA6320_S_SD },
+		.inputmute  = TEA6300_S_GMU,
+	},
+	{
 		.name       = "tea6420",
 		.id         = I2C_DRIVERID_TEA6420,
 		.insmodopt  = &tea6420,
@@ -1571,8 +1625,11 @@ static int chip_command(struct i2c_clien
 		if (desc->flags & CHIP_HAS_VOLUME) {
 			va->flags  |= VIDEO_AUDIO_VOLUME;
 			va->volume  = max(chip->left,chip->right);
-			va->balance = (32768*min(chip->left,chip->right))/
-				(va->volume ? va->volume : 1);
+			if (va->volume)
+				va->balance = (32768*min(chip->left,chip->right))/
+					va->volume;
+			else
+				va->balance = 32768;
 		}
 		if (desc->flags & CHIP_HAS_BASSTREBLE) {
 			va->flags |= VIDEO_AUDIO_BASS | VIDEO_AUDIO_TREBLE;
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tvaudio.h linux-2.6.11-rc2-bk4/drivers/media/video/tvaudio.h
--- linux-2.6.11-rc2-bk3/drivers/media/video/tvaudio.h	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tvaudio.h	2005-01-26 15:43:26.368507196 +0100
@@ -8,7 +8,7 @@
 #define I2C_TDA985x_H      0xb6
 #define I2C_TDA9874        0xb0 /* also used by 9875 */
 
-#define I2C_TEA6300        0x80
+#define I2C_TEA6300        0x80 /* also used by 6320 */
 #define I2C_TEA6420	   0x98
 
 #define I2C_PIC16C54       0x96 /* PV951 */
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tveeprom.c linux-2.6.11-rc2-bk4/drivers/media/video/tveeprom.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/tveeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tveeprom.c	2005-01-26 15:43:26.374506261 +0100
@@ -0,0 +1,577 @@
+/*
+ * tveeprom - eeprom decoder for tvcard configuration eeproms
+ *
+ * Data and decoding routines shamelessly borrowed from bttv-cards.c
+ * eeprom access routine shamelessly borrowed from bttv-if.c
+ * which are:
+
+    Copyright (C) 1996,97,98 Ralph  Metzler (rjkm@thp.uni-koeln.de)
+                           & Marcus Metzler (mocm@thp.uni-koeln.de)
+    (c) 1999-2001 Gerd Knorr <kraxel@goldbach.in-berlin.de>
+
+ * Adjustments to fit a more general model and all bugs:
+
+ 	Copyright (C) 2003 John Klar <linpvr at projectplasma.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+#include <media/tuner.h>
+#include <media/tveeprom.h>
+
+MODULE_DESCRIPTION("i2c Hauppauge eeprom decoder driver");
+MODULE_AUTHOR("John Klar");
+MODULE_LICENSE("GPL");
+
+static int debug = 0;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+#define STRM(array,i) (i < sizeof(array)/sizeof(char*) ? array[i] : "unknown")
+
+#define dprintk(num, args...) \
+	do { \
+		if (debug >= num) \
+			printk(KERN_INFO "tveeprom: " args); \
+	} while (0)
+
+#define TVEEPROM_KERN_ERR(args...) printk(KERN_ERR "tveeprom: " args);
+#define TVEEPROM_KERN_INFO(args...) printk(KERN_INFO "tveeprom: " args);
+
+/* ----------------------------------------------------------------------- */
+/* some hauppauge specific stuff                                           */
+
+static struct HAUPPAUGE_TUNER_FMT
+{
+	int	id;
+	char *name;
+}
+hauppauge_tuner_fmt[] =
+{
+	{ 0x00000000, "unknown1" },
+	{ 0x00000000, "unknown2" },
+	{ 0x00000007, "PAL(B/G)" },
+	{ 0x00001000, "NTSC(M)" },
+	{ 0x00000010, "PAL(I)" },
+	{ 0x00400000, "SECAM(L/L)" },
+	{ 0x00000e00, "PAL(D/K)" },
+	{ 0x03000000, "ATSC Digital" },
+};
+
+/* This is the full list of possible tuners. Many thanks to Hauppauge for
+   supplying this information. Note that many tuners where only used for
+   testing and never made it to the outside world. So you will only see
+   a subset in actual produced cards. */
+static struct HAUPPAUGE_TUNER
+{
+	int  id;
+	char *name;
+}
+hauppauge_tuner[] =
+{
+	/* 0-9 */
+	{ TUNER_ABSENT,        "None" },
+	{ TUNER_ABSENT,        "External" },
+	{ TUNER_ABSENT,        "Unspecified" },
+	{ TUNER_PHILIPS_PAL,   "Philips FI1216" },
+	{ TUNER_PHILIPS_SECAM, "Philips FI1216MF" },
+	{ TUNER_PHILIPS_NTSC,  "Philips FI1236" },
+	{ TUNER_PHILIPS_PAL_I, "Philips FI1246" },
+	{ TUNER_PHILIPS_PAL_DK,"Philips FI1256" },
+	{ TUNER_PHILIPS_PAL,   "Philips FI1216 MK2" },
+	{ TUNER_PHILIPS_SECAM, "Philips FI1216MF MK2" },
+	/* 10-19 */
+	{ TUNER_PHILIPS_NTSC,  "Philips FI1236 MK2" },
+	{ TUNER_PHILIPS_PAL_I, "Philips FI1246 MK2" },
+	{ TUNER_PHILIPS_PAL_DK,"Philips FI1256 MK2" },
+	{ TUNER_TEMIC_NTSC,    "Temic 4032FY5" },
+	{ TUNER_TEMIC_PAL,     "Temic 4002FH5" },
+	{ TUNER_TEMIC_PAL_I,   "Temic 4062FY5" },
+	{ TUNER_PHILIPS_PAL,   "Philips FR1216 MK2" },
+	{ TUNER_PHILIPS_SECAM, "Philips FR1216MF MK2" },
+	{ TUNER_PHILIPS_NTSC,  "Philips FR1236 MK2" },
+	{ TUNER_PHILIPS_PAL_I, "Philips FR1246 MK2" },
+	/* 20-29 */
+	{ TUNER_PHILIPS_PAL_DK,"Philips FR1256 MK2" },
+	{ TUNER_PHILIPS_PAL,   "Philips FM1216" },
+	{ TUNER_PHILIPS_SECAM, "Philips FM1216MF" },
+	{ TUNER_PHILIPS_NTSC,  "Philips FM1236" },
+	{ TUNER_PHILIPS_PAL_I, "Philips FM1246" },
+	{ TUNER_PHILIPS_PAL_DK,"Philips FM1256" },
+	{ TUNER_TEMIC_4036FY5_NTSC, "Temic 4036FY5" },
+	{ TUNER_ABSENT,        "Samsung TCPN9082D" },
+	{ TUNER_ABSENT,        "Samsung TCPM9092P" },
+	{ TUNER_TEMIC_4006FH5_PAL, "Temic 4006FH5" },
+	/* 30-39 */
+	{ TUNER_ABSENT,        "Samsung TCPN9085D" },
+	{ TUNER_ABSENT,        "Samsung TCPB9085P" },
+	{ TUNER_ABSENT,        "Samsung TCPL9091P" },
+	{ TUNER_TEMIC_4039FR5_NTSC, "Temic 4039FR5" },
+	{ TUNER_PHILIPS_FQ1216ME,   "Philips FQ1216 ME" },
+	{ TUNER_TEMIC_4066FY5_PAL_I, "Temic 4066FY5" },
+        { TUNER_PHILIPS_NTSC,        "Philips TD1536" },
+        { TUNER_PHILIPS_NTSC,        "Philips TD1536D" },
+	{ TUNER_PHILIPS_NTSC,  "Philips FMR1236" }, /* mono radio */
+	{ TUNER_ABSENT,        "Philips FI1256MP" },
+	/* 40-49 */
+	{ TUNER_ABSENT,        "Samsung TCPQ9091P" },
+	{ TUNER_TEMIC_4006FN5_MULTI_PAL, "Temic 4006FN5" },
+	{ TUNER_TEMIC_4009FR5_PAL, "Temic 4009FR5" },
+	{ TUNER_TEMIC_4046FM5,     "Temic 4046FM5" },
+	{ TUNER_TEMIC_4009FN5_MULTI_PAL_FM, "Temic 4009FN5" },
+	{ TUNER_ABSENT,        "Philips TD1536D FH 44"},
+	{ TUNER_LG_NTSC_FM,    "LG TP18NSR01F"},
+	{ TUNER_LG_PAL_FM,     "LG TP18PSB01D"},
+	{ TUNER_LG_PAL,        "LG TP18PSB11D"},
+	{ TUNER_LG_PAL_I_FM,   "LG TAPC-I001D"},
+	/* 50-59 */
+	{ TUNER_LG_PAL_I,      "LG TAPC-I701D"},
+	{ TUNER_ABSENT,        "Temic 4042FI5"},
+	{ TUNER_MICROTUNE_4049FM5, "Microtune 4049 FM5"},
+	{ TUNER_ABSENT,        "LG TPI8NSR11F"},
+	{ TUNER_ABSENT,        "Microtune 4049 FM5 Alt I2C"},
+	{ TUNER_ABSENT,        "Philips FQ1216ME MK3"},
+	{ TUNER_ABSENT,        "Philips FI1236 MK3"},
+	{ TUNER_PHILIPS_FM1216ME_MK3, "Philips FM1216 ME MK3"},
+	{ TUNER_ABSENT,        "Philips FM1236 MK3"},
+	{ TUNER_ABSENT,        "Philips FM1216MP MK3"},
+	/* 60-69 */
+	{ TUNER_ABSENT,        "LG S001D MK3"},
+	{ TUNER_ABSENT,        "LG M001D MK3"},
+	{ TUNER_ABSENT,        "LG S701D MK3"},
+	{ TUNER_ABSENT,        "LG M701D MK3"},
+	{ TUNER_ABSENT,        "Temic 4146FM5"},
+	{ TUNER_ABSENT,        "Temic 4136FY5"},
+	{ TUNER_ABSENT,        "Temic 4106FH5"},
+	{ TUNER_ABSENT,        "Philips FQ1216LMP MK3"},
+	{ TUNER_LG_NTSC_TAPE,  "LG TAPE H001F MK3"},
+	{ TUNER_ABSENT,        "LG TAPE H701F MK3"},
+	/* 70-79 */
+	{ TUNER_ABSENT,        "LG TALN H200T"},
+	{ TUNER_ABSENT,        "LG TALN H250T"},
+	{ TUNER_ABSENT,        "LG TALN M200T"},
+	{ TUNER_ABSENT,        "LG TALN Z200T"},
+	{ TUNER_ABSENT,        "LG TALN S200T"},
+	{ TUNER_ABSENT,        "Thompson DTT7595"},
+	{ TUNER_ABSENT,        "Thompson DTT7592"},
+	{ TUNER_ABSENT,        "Silicon TDA8275C1 8290"},
+	{ TUNER_ABSENT,        "Silicon TDA8275C1 8290 FM"},
+	{ TUNER_ABSENT,        "Thompson DTT757"},
+	/* 80-89 */
+	{ TUNER_ABSENT,        "Philips FQ1216LME MK3"},
+	{ TUNER_ABSENT,        "LG TAPC G701D"},
+	{ TUNER_LG_NTSC_NEW_TAPC, "LG TAPC H791F"},
+	{ TUNER_ABSENT,        "TCL 2002MB 3"},
+	{ TUNER_ABSENT,        "TCL 2002MI 3"},
+	{ TUNER_TCL_2002N,     "TCL 2002N 6A"},
+	{ TUNER_ABSENT,        "Philips FQ1236 MK3"},
+	{ TUNER_ABSENT,        "Samsung TCPN 2121P30A"},
+	{ TUNER_ABSENT,        "Samsung TCPE 4121P30A"},
+	{ TUNER_ABSENT,        "TCL MFPE05 2"},
+	/* 90-99 */
+	{ TUNER_ABSENT,        "LG TALN H202T"},
+	{ TUNER_ABSENT,        "Philips FQ1216AME MK4"},
+	{ TUNER_ABSENT,        "Philips FQ1236A MK4"},
+	{ TUNER_ABSENT,        "Philips FQ1286A MK4"},
+	{ TUNER_ABSENT,        "Philips FQ1216ME MK5"},
+	{ TUNER_ABSENT,        "Philips FQ1236 MK5"},
+};
+
+static char *sndtype[] = {
+	"None", "TEA6300", "TEA6320", "TDA9850", "MSP3400C", "MSP3410D",
+	"MSP3415", "MSP3430", "MSP3438", "CS5331", "MSP3435", "MSP3440",
+	"MSP3445", "MSP3411", "MSP3416", "MSP3425",
+
+	"Type 0x10","Type 0x11","Type 0x12","Type 0x13",
+	"Type 0x14","Type 0x15","Type 0x16","Type 0x17",
+	"Type 0x18","MSP4418","Type 0x1a","MSP4448",
+	"Type 0x1c","Type 0x1d","Type 0x1e","Type 0x1f",
+};
+
+static int hasRadioTuner(int tunerType)
+{
+        switch (tunerType) {
+                case 18: //PNPEnv_TUNER_FR1236_MK2:
+                case 23: //PNPEnv_TUNER_FM1236:
+                case 38: //PNPEnv_TUNER_FMR1236:
+                case 16: //PNPEnv_TUNER_FR1216_MK2:
+                case 19: //PNPEnv_TUNER_FR1246_MK2:
+                case 21: //PNPEnv_TUNER_FM1216:
+                case 24: //PNPEnv_TUNER_FM1246:
+                case 17: //PNPEnv_TUNER_FR1216MF_MK2:
+                case 22: //PNPEnv_TUNER_FM1216MF:
+                case 20: //PNPEnv_TUNER_FR1256_MK2:
+                case 25: //PNPEnv_TUNER_FM1256:
+                case 33: //PNPEnv_TUNER_4039FR5:
+                case 42: //PNPEnv_TUNER_4009FR5:
+                case 52: //PNPEnv_TUNER_4049FM5:
+                case 54: //PNPEnv_TUNER_4049FM5_AltI2C:
+                case 44: //PNPEnv_TUNER_4009FN5:
+                case 31: //PNPEnv_TUNER_TCPB9085P:
+                case 30: //PNPEnv_TUNER_TCPN9085D:
+                case 46: //PNPEnv_TUNER_TP18NSR01F:
+                case 47: //PNPEnv_TUNER_TP18PSB01D:
+                case 49: //PNPEnv_TUNER_TAPC_I001D:
+                case 60: //PNPEnv_TUNER_TAPE_S001D_MK3:
+                case 57: //PNPEnv_TUNER_FM1216ME_MK3:
+                case 59: //PNPEnv_TUNER_FM1216MP_MK3:
+                case 58: //PNPEnv_TUNER_FM1236_MK3:
+                case 68: //PNPEnv_TUNER_TAPE_H001F_MK3:
+                case 61: //PNPEnv_TUNER_TAPE_M001D_MK3:
+                case 78: //PNPEnv_TUNER_TDA8275C1_8290_FM:
+                case 89: //PNPEnv_TUNER_TCL_MFPE05_2:
+                    return 1;
+        }
+        return 0;
+}
+
+void tveeprom_hauppauge_analog(struct tveeprom *tvee, unsigned char *eeprom_data)
+{
+	/* ----------------------------------------------
+	** The hauppauge eeprom format is tagged
+	**
+	** if packet[0] == 0x84, then packet[0..1] == length
+	** else length = packet[0] & 3f;
+	** if packet[0] & f8 == f8, then EOD and packet[1] == checksum
+	**
+	** In our (ivtv) case we're interested in the following:
+	** tuner type: tag [00].05 or [0a].01 (index into hauppauge_tuners)
+	** tuner fmts: tag [00].04 or [0a].00 (bitmask index into hauppauge_fmts)
+	** radio:      tag [00].{last} or [0e].00  (bitmask.  bit2=FM)
+	** audio proc: tag [02].01 or [05].00 (lower nibble indexes lut?)
+
+	** Fun info:
+	** model:      tag [00].07-08 or [06].00-01
+	** revision:   tag [00].09-0b or [06].04-06
+	** serial#:    tag [01].05-07 or [04].04-06
+
+	** # of inputs/outputs ???
+	*/
+
+	int i, j, len, done, tag, tuner = 0, t_format = 0;
+	char *t_name = NULL, *t_fmt_name = NULL;
+
+	dprintk(1, "%s\n",__FUNCTION__);
+	tvee->revision = done = len = 0;
+	for (i = 0; !done && i < 256; i += len) {
+		dprintk(2, "processing pos = %02x (%02x, %02x)\n",
+			i, eeprom_data[i], eeprom_data[i + 1]);
+
+		if (eeprom_data[i] == 0x84) {
+			len = eeprom_data[i + 1] + (eeprom_data[i + 2] << 8);
+			i+=3;
+		} else if ((eeprom_data[i] & 0xf0) == 0x70) {
+			if ((eeprom_data[i] & 0x08)) {
+				/* verify checksum! */
+				done = 1;
+				break;
+			}
+			len = eeprom_data[i] & 0x07;
+			++i;
+		} else {
+			TVEEPROM_KERN_ERR("Encountered bad packet header [%02x]. "
+				   "Corrupt or not a Hauppauge eeprom.\n", eeprom_data[i]);
+			return;
+		}
+
+		dprintk(1, "%3d [%02x] ", len, eeprom_data[i]);
+		for(j = 1; j < len; j++) {
+			dprintk(1, "%02x ", eeprom_data[i + j]);
+		}
+		dprintk(1, "\n");
+
+		/* process by tag */
+		tag = eeprom_data[i];
+		switch (tag) {
+		case 0x00:
+			tuner = eeprom_data[i+6];
+			t_format = eeprom_data[i+5];
+			tvee->has_radio = eeprom_data[i+len-1];
+			tvee->model =
+				eeprom_data[i+8] +
+				(eeprom_data[i+9] << 8);
+			tvee->revision = eeprom_data[i+10] +
+				(eeprom_data[i+11] << 8) +
+				(eeprom_data[i+12] << 16);
+			break;
+		case 0x01:
+			tvee->serial_number =
+				eeprom_data[i+6] +
+				(eeprom_data[i+7] << 8) +
+				(eeprom_data[i+8] << 16);
+			break;
+		case 0x02:
+			tvee->audio_processor = eeprom_data[i+2] & 0x0f;
+			break;
+		case 0x04:
+			tvee->serial_number =
+				eeprom_data[i+5] +
+				(eeprom_data[i+6] << 8) +
+				(eeprom_data[i+7] << 16);
+			break;
+		case 0x05:
+			tvee->audio_processor = eeprom_data[i+1] & 0x0f;
+			break;
+		case 0x06:
+			tvee->model =
+				eeprom_data[i+1] +
+				(eeprom_data[i+2] << 8);
+			tvee->revision = eeprom_data[i+5] +
+				(eeprom_data[i+6] << 8) +
+				(eeprom_data[i+7] << 16);
+			break;
+		case 0x0a:
+			tuner = eeprom_data[i+2];
+			t_format = eeprom_data[i+1];
+			break;
+		case 0x0e:
+			tvee->has_radio = eeprom_data[i+1];
+			break;
+		default:
+			dprintk(1, "Not sure what to do with tag [%02x]\n", tag);
+			/* dump the rest of the packet? */
+		}
+
+	}
+
+	if (!done) {
+		TVEEPROM_KERN_ERR("Ran out of data!\n");
+		return;
+	}
+
+	if (tvee->revision != 0) {
+		tvee->rev_str[0] = 32 + ((tvee->revision >> 18) & 0x3f);
+		tvee->rev_str[1] = 32 + ((tvee->revision >> 12) & 0x3f);
+		tvee->rev_str[2] = 32 + ((tvee->revision >>  6) & 0x3f);
+		tvee->rev_str[3] = 32 + ( tvee->revision        & 0x3f);
+		tvee->rev_str[4] = 0;
+	}
+
+        if (hasRadioTuner(tuner) && !tvee->has_radio) {
+	    TVEEPROM_KERN_INFO("The eeprom says no radio is present, but the tuner type\n");
+	    TVEEPROM_KERN_INFO("indicates otherwise. I will assume that radio is present.\n");
+            tvee->has_radio = 1;
+        }
+
+	if (tuner < sizeof(hauppauge_tuner)/sizeof(struct HAUPPAUGE_TUNER)) {
+		tvee->tuner_type = hauppauge_tuner[tuner].id;
+		t_name = hauppauge_tuner[tuner].name;
+	} else {
+		t_name = "<unknown>";
+	}
+
+	tvee->tuner_formats = 0;
+	t_fmt_name = "<none>";
+	for (i = 0; i < 8; i++) {
+		if (t_format & (1<<i)) {
+			tvee->tuner_formats |= hauppauge_tuner_fmt[i].id;
+			/* yuck */
+			t_fmt_name = hauppauge_tuner_fmt[i].name;
+		}
+	}
+
+#if 0
+	if (t_format < sizeof(hauppauge_tuner_fmt)/sizeof(struct HAUPPAUGE_TUNER_FMT)) {
+		tvee->tuner_formats = hauppauge_tuner_fmt[t_format].id;
+		t_fmt_name = hauppauge_tuner_fmt[t_format].name;
+	} else {
+		t_fmt_name = "<unknown>";
+	}
+#endif
+
+	TVEEPROM_KERN_INFO("Hauppauge: model = %d, rev = %s, serial# = %d\n",
+		   tvee->model,
+		   tvee->rev_str,
+		   tvee->serial_number);
+	TVEEPROM_KERN_INFO("tuner = %s (idx = %d, type = %d)\n",
+		   t_name,
+		   tuner,
+		   tvee->tuner_type);
+	TVEEPROM_KERN_INFO("tuner fmt = %s (eeprom = 0x%02x, v4l2 = 0x%08x)\n",
+		   t_fmt_name,
+		   t_format,
+		   tvee->tuner_formats);
+
+	TVEEPROM_KERN_INFO("audio_processor = %s (type = %d)\n",
+		   STRM(sndtype,tvee->audio_processor),
+		   tvee->audio_processor);
+
+}
+EXPORT_SYMBOL(tveeprom_hauppauge_analog);
+
+/* ----------------------------------------------------------------------- */
+/* generic helper functions                                                */
+
+int tveeprom_read(struct i2c_client *c, unsigned char *eedata, int len)
+{
+	unsigned char buf;
+	int err;
+
+	dprintk(1, "%s\n",__FUNCTION__);
+	buf = 0;
+	if (1 != (err = i2c_master_send(c,&buf,1))) {
+		printk(KERN_INFO "tveeprom(%s): Huh, no eeprom present (err=%d)?\n",
+		       c->name,err);
+		return -1;
+	}
+	if (len != (err = i2c_master_recv(c,eedata,len))) {
+		printk(KERN_WARNING "tveeprom(%s): i2c eeprom read error (err=%d)\n",
+		       c->name,err);
+		return -1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tveeprom_read);
+
+int tveeprom_dump(unsigned char *eedata, int len)
+{
+	int i;
+
+	dprintk(1, "%s\n",__FUNCTION__);
+	for (i = 0; i < len; i++) {
+		if (0 == (i % 16))
+			printk(KERN_INFO "tveeprom: %02x:",i);
+		printk(" %02x",eedata[i]);
+		if (15 == (i % 16))
+			printk("\n");
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tveeprom_dump);
+
+/* ----------------------------------------------------------------------- */
+/* needed for ivtv.sf.net at the moment.  Should go away in the long       */
+/* run, just call the exported tveeprom_* directly, there is no point in   */
+/* using the indirect way via i2c_driver->command()                        */
+
+#ifndef I2C_DRIVERID_TVEEPROM
+# define I2C_DRIVERID_TVEEPROM I2C_DRIVERID_EXP2
+#endif
+
+static unsigned short normal_i2c[] = {
+	0xa0 >> 1,
+	I2C_CLIENT_END,
+};
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+I2C_CLIENT_INSMOD;
+
+struct i2c_driver i2c_driver_tveeprom;
+
+static int
+tveeprom_command(struct i2c_client *client,
+		 unsigned int       cmd,
+		 void              *arg)
+{
+	struct tveeprom eeprom;
+	u32 *eeprom_props = arg;
+	u8 *buf;
+
+	switch (cmd) {
+	case 0:
+		buf = kmalloc(256,GFP_KERNEL);
+		memset(buf,0,256);
+		tveeprom_read(client,buf,256);
+		tveeprom_hauppauge_analog(&eeprom,buf);
+		kfree(buf);
+		eeprom_props[0] = eeprom.tuner_type;
+		eeprom_props[1] = eeprom.tuner_formats;
+		eeprom_props[2] = eeprom.model;
+		eeprom_props[3] = eeprom.revision;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int
+tveeprom_detect_client(struct i2c_adapter *adapter,
+		       int                 address,
+		       int                 kind)
+{
+	struct i2c_client *client;
+
+	dprintk(1,"%s: id 0x%x @ 0x%x\n",__FUNCTION__,
+	       adapter->id, address << 1);
+	client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (NULL == client)
+		return -ENOMEM;
+	memset(client, 0, sizeof(struct i2c_client));
+	client->addr = address;
+	client->adapter = adapter;
+	client->driver = &i2c_driver_tveeprom;
+	client->flags = I2C_CLIENT_ALLOW_USE;
+	snprintf(client->name, sizeof(client->name), "tveeprom");
+        i2c_attach_client(client);
+	return 0;
+}
+
+static int
+tveeprom_attach_adapter (struct i2c_adapter *adapter)
+{
+	dprintk(1,"%s: id 0x%x\n",__FUNCTION__,adapter->id);
+	if (adapter->id != (I2C_ALGO_BIT | I2C_HW_B_BT848))
+		return 0;
+	return i2c_probe(adapter, &addr_data, tveeprom_detect_client);
+}
+
+static int
+tveeprom_detach_client (struct i2c_client *client)
+{
+	int err;
+
+	err = i2c_detach_client(client);
+	if (err < 0)
+		return err;
+	kfree(client);
+	return 0;
+}
+
+struct i2c_driver i2c_driver_tveeprom = {
+	.owner          = THIS_MODULE,
+	.name           = "tveeprom",
+	.id             = I2C_DRIVERID_TVEEPROM,
+	.flags          = I2C_DF_NOTIFY,
+	.attach_adapter = tveeprom_attach_adapter,
+	.detach_client  = tveeprom_detach_client,
+	.command        = tveeprom_command,
+};
+
+static int __init tveeprom_init(void)
+{
+	return i2c_add_driver(&i2c_driver_tveeprom);
+}
+
+static void __exit tveeprom_exit(void)
+{
+	i2c_del_driver(&i2c_driver_tveeprom);
+}
+
+module_init(tveeprom_init);
+module_exit(tveeprom_exit);
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/tvmixer.c linux-2.6.11-rc2-bk4/drivers/media/video/tvmixer.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/tvmixer.c	2005-01-22 02:48:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/tvmixer.c	2005-01-26 15:43:26.376505949 +0100
@@ -1,4 +1,5 @@
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/string.h>
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/video-buf-dvb.c linux-2.6.11-rc2-bk4/drivers/media/video/video-buf-dvb.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/video-buf-dvb.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/video-buf-dvb.c	2005-01-26 15:43:26.377505793 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: video-buf-dvb.c,v 1.5 2004/11/07 13:17:15 kraxel Exp $
+ * $Id: video-buf-dvb.c,v 1.7 2004/12/09 12:51:35 kraxel Exp $
  *
  * some helper function for simple DVB cards which simply DMA the
  * complete transport stream and let the computer sort everything else
@@ -35,7 +35,7 @@ module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug,"enable debug messages");
 
 #define dprintk(fmt, arg...)	if (debug)			\
-	printk(KERN_DEBUG "%s/dvb: " fmt, dvb->name, ## arg)
+	printk(KERN_DEBUG "%s/dvb: " fmt, dvb->name , ## arg)
 
 /* ------------------------------------------------------------------ */
 
@@ -134,19 +134,22 @@ static int videobuf_dvb_stop_feed(struct
 
 /* ------------------------------------------------------------------ */
 
-int videobuf_dvb_register(struct videobuf_dvb *dvb)
+int videobuf_dvb_register(struct videobuf_dvb *dvb,
+			  struct module *module,
+			  void *adapter_priv)
 {
 	int result;
 
 	init_MUTEX(&dvb->lock);
 
 	/* register adapter */
-	result = dvb_register_adapter(&dvb->adapter, dvb->name, THIS_MODULE);
+	result = dvb_register_adapter(&dvb->adapter, dvb->name, module);
 	if (result < 0) {
 		printk(KERN_WARNING "%s: dvb_register_adapter failed (errno = %d)\n",
 		       dvb->name, result);
 		goto fail_adapter;
 	}
+	dvb->adapter->priv = adapter_priv;
 
 	/* register frontend */
 	result = dvb_register_frontend(dvb->adapter, dvb->frontend);
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/video-buf.c linux-2.6.11-rc2-bk4/drivers/media/video/video-buf.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/video-buf.c	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/video-buf.c	2005-01-26 15:43:26.379505482 +0100
@@ -1,5 +1,5 @@
 /*
- * $Id: video-buf.c,v 1.15 2004/11/07 14:45:00 kraxel Exp $
+ * $Id: video-buf.c,v 1.17 2004/12/10 12:33:40 kraxel Exp $
  *
  * generic helper functions for video4linux capture buffers, to handle
  * memory management and PCI DMA.  Right now bttv + saa7134 use it.
@@ -20,6 +20,7 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/vmalloc.h>
 #include <linux/pagemap.h>
 #include <linux/slab.h>
@@ -892,6 +893,7 @@ void videobuf_read_stop(struct videobuf_
 	int i;
 
 	videobuf_queue_cancel(q);
+	videobuf_mmap_free(q);
 	INIT_LIST_HEAD(&q->stream);
 	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
 		if (NULL == q->bufs[i])
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/w9966.c linux-2.6.11-rc2-bk4/drivers/media/video/w9966.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/w9966.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/w9966.c	2005-01-26 15:43:26.381505170 +0100
@@ -330,7 +330,7 @@ static int w9966_init(struct w9966_dev* 
 
 // Fill in the video_device struct and register us to v4l
 	memcpy(&cam->vdev, &w9966_template, sizeof(struct video_device));
-	cam->vdev.priv = (void*)cam;
+	cam->vdev.priv = cam;
 
 	if (video_register_device(&cam->vdev, VFL_TYPE_GRABBER, video_nr) == -1)		 
 		return -1;
@@ -712,7 +712,7 @@ static int w9966_v4l_do_ioctl(struct ino
 			      unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
-	struct w9966_dev *cam = (struct w9966_dev*)vdev->priv;
+	struct w9966_dev *cam = vdev->priv;
 	
 	switch(cmd)
 	{
@@ -871,7 +871,7 @@ static ssize_t w9966_v4l_read(struct fil
 			      size_t count, loff_t *ppos)
 {
 	struct video_device *vdev = video_devdata(file);
-	struct w9966_dev *cam = (struct w9966_dev *)vdev->priv;
+	struct w9966_dev *cam = vdev->priv;
 	unsigned char addr = 0xa0;	// ECP, read, CCD-transfer, 00000
 	unsigned char __user *dest = (unsigned char __user *)buf;
 	unsigned long dleft = count;
diff -purN linux-2.6.11-rc2-bk3/drivers/media/video/zr36120.c linux-2.6.11-rc2-bk4/drivers/media/video/zr36120.c
--- linux-2.6.11-rc2-bk3/drivers/media/video/zr36120.c	2005-01-22 02:48:02.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/media/video/zr36120.c	2005-01-26 15:43:26.385504547 +0100
@@ -338,7 +338,7 @@ void zoran_irq(int irq, void *dev_id, st
 {
 	u32 stat,estat;
 	int count = 0;
-	struct zoran *ztv = (struct zoran *)dev_id;
+	struct zoran *ztv = dev_id;
 
 	UNUSED(irq); UNUSED(regs);
 	for (;;) {
@@ -775,7 +775,7 @@ static int zoran_open(struct video_devic
 	memset(ztv->fbuffer,0,ZORAN_MAX_FBUFSIZE);
 
 	if (!ztv->overinfo.overlay)
-		ztv->overinfo.overlay = (void*)kmalloc(1024*1024/8, GFP_KERNEL);
+		ztv->overinfo.overlay = kmalloc(1024*1024/8, GFP_KERNEL);
 	if (!ztv->overinfo.overlay) {
 		/* could not get an overlay buffer, bail out */
 		bfree(ztv->fbuffer, ZORAN_MAX_FBUFSIZE);
@@ -1500,7 +1500,7 @@ static struct video_device zr36120_templ
 static
 int vbi_open(struct video_device *dev, int flags)
 {
-	struct zoran *ztv = (struct zoran*)dev->priv;
+	struct zoran *ztv = dev->priv;
 	struct vidinfo* item;
 
 	DEBUG(printk(CARD_DEBUG "vbi_open(dev,%d)\n",CARD,flags));
@@ -1549,7 +1549,7 @@ int vbi_open(struct video_device *dev, i
 static
 void vbi_close(struct video_device *dev)
 {
-	struct zoran *ztv = (struct zoran*)dev->priv;
+	struct zoran *ztv = dev->priv;
 	struct vidinfo* item;
 
 	DEBUG(printk(CARD_DEBUG "vbi_close(dev)\n",CARD));
@@ -1585,7 +1585,7 @@ void vbi_close(struct video_device *dev)
 static
 long vbi_read(struct video_device* dev, char* buf, unsigned long count, int nonblock)
 {
-	struct zoran *ztv = (struct zoran*)dev->priv;
+	struct zoran *ztv = dev->priv;
 	unsigned long max;
 	struct vidinfo* unused = 0;
 	struct vidinfo* done = 0;
@@ -1740,7 +1740,7 @@ out:
 static
 unsigned int vbi_poll(struct video_device *dev, struct file *file, poll_table *wait)
 {
-	struct zoran *ztv = (struct zoran*)dev->priv;
+	struct zoran *ztv = dev->priv;
 	struct vidinfo* item;
 	unsigned int mask = 0;
 
@@ -1761,7 +1761,7 @@ unsigned int vbi_poll(struct video_devic
 static
 int vbi_ioctl(struct video_device *dev, unsigned int cmd, void *arg)
 {
-	struct zoran* ztv = (struct zoran*)dev->priv;
+	struct zoran* ztv = dev->priv;
 
 	switch (cmd) {
 	 case VIDIOCGVBIFMT:
@@ -1861,7 +1861,7 @@ int __init find_zoran(void)
 		DEBUG(printk(KERN_DEBUG "zoran: mapped-memory at 0x%p\n",ztv->zoran_mem));
 
 		result = request_irq(dev->irq, zoran_irq,
-			SA_SHIRQ|SA_INTERRUPT,"zoran",(void *)ztv);
+			SA_SHIRQ|SA_INTERRUPT,"zoran", ztv);
 		if (result==-EINVAL)
 		{
 			iounmap(ztv->zoran_mem);
diff -purN linux-2.6.11-rc2-bk3/drivers/net/3c59x.c linux-2.6.11-rc2-bk4/drivers/net/3c59x.c
--- linux-2.6.11-rc2-bk3/drivers/net/3c59x.c	2005-01-22 02:46:41.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/3c59x.c	2005-01-26 15:43:26.392503456 +0100
@@ -752,6 +752,12 @@ enum tx_desc_status {
 /* Chip features we care about in vp->capabilities, read from the EEPROM. */
 enum ChipCaps { CapBusMaster=0x20, CapPwrMgmt=0x2000 };
 
+struct vortex_extra_stats {
+        unsigned long tx_deferred;
+        unsigned long tx_multiple_collisions;
+        unsigned long rx_bad_ssd;
+};
+
 struct vortex_private {
 	/* The Rx and Tx rings should be quad-word-aligned. */
 	struct boom_rx_desc* rx_ring;
@@ -763,7 +769,8 @@ struct vortex_private {
 	struct sk_buff* tx_skbuff[TX_RING_SIZE];
 	unsigned int cur_rx, cur_tx;		/* The next free ring entry */
 	unsigned int dirty_rx, dirty_tx;	/* The ring entries to be free()ed. */
-	struct net_device_stats stats;
+	struct net_device_stats stats;		/* Generic stats */
+	struct vortex_extra_stats xstats;	/* NIC-specific extra stats */
 	struct sk_buff *tx_skb;				/* Packet being eaten by bus master ctrl.  */
 	dma_addr_t tx_skb_dma;				/* Allocated DMA address for bus master ctrl DMA.   */
 
@@ -854,18 +861,13 @@ static struct media_table {
 static struct {
 	const char str[ETH_GSTRING_LEN];
 } ethtool_stats_keys[] = {
-	{ "rx_packets" },
-	{ "tx_packets" },
-	{ "rx_bytes" },
-	{ "tx_bytes" },
-	{ "collisions" },
-	{ "tx_carrier_errors" },
-	{ "tx_heartbeat_errors" },
-	{ "tx_window_errors" },
+	{ "tx_deferred" },
+	{ "tx_multiple_collisions" },
+	{ "rx_bad_ssd" },
 };
 
 /* number of ETHTOOL_GSTATS u64's */
-#define VORTEX_NUM_STATS      8
+#define VORTEX_NUM_STATS     3
 
 static int vortex_probe1(struct device *gendev, long ioaddr, int irq,
 				   int chip_idx, int card_idx);
@@ -2871,23 +2873,23 @@ static void update_stats(long ioaddr, st
 	/* Switch to the stats window, and read everything. */
 	EL3WINDOW(6);
 	vp->stats.tx_carrier_errors		+= inb(ioaddr + 0);
-	vp->stats.tx_heartbeat_errors	+= inb(ioaddr + 1);
-	/* Multiple collisions. */		inb(ioaddr + 2);
+	vp->stats.tx_heartbeat_errors		+= inb(ioaddr + 1);
 	vp->stats.collisions			+= inb(ioaddr + 3);
 	vp->stats.tx_window_errors		+= inb(ioaddr + 4);
 	vp->stats.rx_fifo_errors		+= inb(ioaddr + 5);
 	vp->stats.tx_packets			+= inb(ioaddr + 6);
 	vp->stats.tx_packets			+= (inb(ioaddr + 9)&0x30) << 4;
-	/* Rx packets	*/				inb(ioaddr + 7);   /* Must read to clear */
-	/* Tx deferrals */				inb(ioaddr + 8);
+	/* Rx packets	*/			inb(ioaddr + 7);   /* Must read to clear */
 	/* Don't bother with register 9, an extension of registers 6&7.
 	   If we do use the 6&7 values the atomic update assumption above
 	   is invalid. */
-	vp->stats.rx_bytes += inw(ioaddr + 10);
-	vp->stats.tx_bytes += inw(ioaddr + 12);
-	/* New: On the Vortex we must also clear the BadSSD counter. */
+	vp->stats.rx_bytes 			+= inw(ioaddr + 10);
+	vp->stats.tx_bytes 			+= inw(ioaddr + 12);
+	/* Extra stats for get_ethtool_stats() */
+	vp->xstats.tx_multiple_collisions	+= inb(ioaddr + 2);
+	vp->xstats.tx_deferred			+= inb(ioaddr + 8);
 	EL3WINDOW(4);
-	inb(ioaddr + 12);
+	vp->xstats.rx_bad_ssd			+= inb(ioaddr + 12);
 
 	{
 		u8 up = inb(ioaddr + 13);
@@ -2980,14 +2982,9 @@ static void vortex_get_ethtool_stats(str
 	update_stats(dev->base_addr, dev);
 	spin_unlock_irqrestore(&vp->lock, flags);
 
-	data[0] = vp->stats.rx_packets;
-	data[1] = vp->stats.tx_packets;
-	data[2] = vp->stats.rx_bytes;
-	data[3] = vp->stats.tx_bytes;
-	data[4] = vp->stats.collisions;
-	data[5] = vp->stats.tx_carrier_errors;
-	data[6] = vp->stats.tx_heartbeat_errors;
-	data[7] = vp->stats.tx_window_errors;
+	data[0] = vp->xstats.tx_deferred;
+	data[1] = vp->xstats.tx_multiple_collisions;
+	data[2] = vp->xstats.rx_bad_ssd;
 }
 
 
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/3c574_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/3c574_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/3c574_cs.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/3c574_cs.c	2005-01-26 15:43:26.403501742 +0100
@@ -231,10 +231,10 @@ static void tc574_release(dev_link_t *li
 static int tc574_event(event_t event, int priority,
 					   event_callback_args_t *args);
 
-static void mdio_sync(ioaddr_t ioaddr, int bits);
-static int mdio_read(ioaddr_t ioaddr, int phy_id, int location);
-static void mdio_write(ioaddr_t ioaddr, int phy_id, int location, int value);
-static unsigned short read_eeprom(ioaddr_t ioaddr, int index);
+static void mdio_sync(kio_addr_t ioaddr, int bits);
+static int mdio_read(kio_addr_t ioaddr, int phy_id, int location);
+static void mdio_write(kio_addr_t ioaddr, int phy_id, int location, int value);
+static unsigned short read_eeprom(kio_addr_t ioaddr, int index);
 static void tc574_wait_for_completion(struct net_device *dev, int cmd);
 
 static void tc574_reset(struct net_device *dev);
@@ -385,7 +385,7 @@ static void tc574_config(dev_link_t *lin
 	cisparse_t parse;
 	unsigned short buf[32];
 	int last_fn, last_ret, i, j;
-	ioaddr_t ioaddr;
+	kio_addr_t ioaddr;
 	u16 *phys_addr;
 	char *cardname;
 	union wn3_config config;
@@ -606,7 +606,7 @@ static int tc574_event(event_t event, in
 
 static void dump_status(struct net_device *dev)
 {
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	EL3WINDOW(1);
 	printk(KERN_INFO "  irq status %04x, rx status %04x, tx status "
 		   "%02x, tx free %04x\n", inw(ioaddr+EL3_STATUS),
@@ -635,7 +635,7 @@ static void tc574_wait_for_completion(st
 /* Read a word from the EEPROM using the regular EEPROM access register.
    Assume that we are in register window zero.
  */
-static unsigned short read_eeprom(ioaddr_t ioaddr, int index)
+static unsigned short read_eeprom(kio_addr_t ioaddr, int index)
 {
 	int timer;
 	outw(EEPROM_Read + index, ioaddr + Wn0EepromCmd);
@@ -663,9 +663,9 @@ static unsigned short read_eeprom(ioaddr
 
 /* Generate the preamble required for initial synchronization and
    a few older transceivers. */
-static void mdio_sync(ioaddr_t ioaddr, int bits)
+static void mdio_sync(kio_addr_t ioaddr, int bits)
 {
-	int mdio_addr = ioaddr + Wn4_PhysicalMgmt;
+	kio_addr_t mdio_addr = ioaddr + Wn4_PhysicalMgmt;
 
 	/* Establish sync by sending at least 32 logic ones. */
 	while (-- bits >= 0) {
@@ -674,12 +674,12 @@ static void mdio_sync(ioaddr_t ioaddr, i
 	}
 }
 
-static int mdio_read(ioaddr_t ioaddr, int phy_id, int location)
+static int mdio_read(kio_addr_t ioaddr, int phy_id, int location)
 {
 	int i;
 	int read_cmd = (0xf6 << 10) | (phy_id << 5) | location;
 	unsigned int retval = 0;
-	int mdio_addr = ioaddr + Wn4_PhysicalMgmt;
+	kio_addr_t mdio_addr = ioaddr + Wn4_PhysicalMgmt;
 
 	if (mii_preamble_required)
 		mdio_sync(ioaddr, 32);
@@ -699,10 +699,10 @@ static int mdio_read(ioaddr_t ioaddr, in
 	return (retval>>1) & 0xffff;
 }
 
-static void mdio_write(ioaddr_t ioaddr, int phy_id, int location, int value)
+static void mdio_write(kio_addr_t ioaddr, int phy_id, int location, int value)
 {
 	int write_cmd = 0x50020000 | (phy_id << 23) | (location << 18) | value;
-	int mdio_addr = ioaddr + Wn4_PhysicalMgmt;
+	kio_addr_t mdio_addr = ioaddr + Wn4_PhysicalMgmt;
 	int i;
 
 	if (mii_preamble_required)
@@ -727,7 +727,8 @@ static void mdio_write(ioaddr_t ioaddr, 
 static void tc574_reset(struct net_device *dev)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	int i, ioaddr = dev->base_addr;
+	int i;
+	kio_addr_t ioaddr = dev->base_addr;
 	unsigned long flags;
 
 	tc574_wait_for_completion(dev, TotalReset|0x10);
@@ -831,7 +832,7 @@ static int el3_open(struct net_device *d
 static void el3_tx_timeout(struct net_device *dev)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	
 	printk(KERN_NOTICE "%s: Transmit timed out!\n", dev->name);
 	dump_status(dev);
@@ -846,7 +847,7 @@ static void el3_tx_timeout(struct net_de
 static void pop_tx_status(struct net_device *dev)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	int i;
     
 	/* Clear the Tx status stack. */
@@ -869,7 +870,7 @@ static void pop_tx_status(struct net_dev
 
 static int el3_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	struct el3_private *lp = netdev_priv(dev);
 	unsigned long flags;
 
@@ -903,7 +904,8 @@ static irqreturn_t el3_interrupt(int irq
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr, status;
+	kio_addr_t ioaddr;
+	unsigned status;
 	int work_budget = max_interrupt_work;
 	int handled = 0;
 
@@ -996,7 +998,7 @@ static void media_check(unsigned long ar
 {
 	struct net_device *dev = (struct net_device *) arg;
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	unsigned long flags;
 	unsigned short /* cable, */ media, partner;
 
@@ -1085,7 +1087,7 @@ static struct net_device_stats *el3_get_
 static void update_stats(struct net_device *dev)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	u8 rx, tx, up;
 
 	DEBUG(2, "%s: updating the statistics.\n", dev->name);
@@ -1122,7 +1124,7 @@ static void update_stats(struct net_devi
 static int el3_rx(struct net_device *dev, int worklimit)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	short rx_status;
 	
 	DEBUG(3, "%s: in rx_packet(), status %4.4x, rx_status %4.4x.\n",
@@ -1184,7 +1186,7 @@ static struct ethtool_ops netdev_ethtool
 static int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct el3_private *lp = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	u16 *data = (u16 *)&rq->ifr_ifru;
 	int phy = lp->phys & 0x1f;
 
@@ -1238,7 +1240,7 @@ static int el3_ioctl(struct net_device *
 
 static void set_rx_mode(struct net_device *dev)
 {
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 
 	if (dev->flags & IFF_PROMISC)
 		outw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,
@@ -1251,7 +1253,7 @@ static void set_rx_mode(struct net_devic
 
 static int el3_close(struct net_device *dev)
 {
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	struct el3_private *lp = netdev_priv(dev);
 	dev_link_t *link = &lp->link;
 
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/3c589_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/3c589_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/3c589_cs.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/3c589_cs.c	2005-01-26 15:43:26.407501118 +0100
@@ -147,7 +147,7 @@ static void tc589_release(dev_link_t *li
 static int tc589_event(event_t event, int priority,
 		       event_callback_args_t *args);
 
-static u16 read_eeprom(ioaddr_t ioaddr, int index);
+static u16 read_eeprom(kio_addr_t ioaddr, int index);
 static void tc589_reset(struct net_device *dev);
 static void media_check(unsigned long arg);
 static int el3_config(struct net_device *dev, struct ifmap *map);
@@ -299,7 +299,7 @@ static void tc589_config(dev_link_t *lin
     cisparse_t parse;
     u16 buf[32], *phys_addr;
     int last_fn, last_ret, i, j, multi = 0, fifo;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     char *ram_split[] = {"5:3", "3:1", "1:1", "3:5"};
     
     DEBUG(0, "3c589_config(0x%p)\n", link);
@@ -500,7 +500,7 @@ static void tc589_wait_for_completion(st
   Read a word from the EEPROM using the regular EEPROM access register.
   Assume that we are in register window zero.
 */
-static u16 read_eeprom(ioaddr_t ioaddr, int index)
+static u16 read_eeprom(kio_addr_t ioaddr, int index)
 {
     int i;
     outw(EEPROM_READ + index, ioaddr + 10);
@@ -518,7 +518,7 @@ static u16 read_eeprom(ioaddr_t ioaddr, 
 static void tc589_set_xcvr(struct net_device *dev, int if_port)
 {
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     
     EL3WINDOW(0);
     switch (if_port) {
@@ -540,7 +540,7 @@ static void tc589_set_xcvr(struct net_de
 
 static void dump_status(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     EL3WINDOW(1);
     printk(KERN_INFO "  irq status %04x, rx status %04x, tx status "
 	   "%02x  tx free %04x\n", inw(ioaddr+EL3_STATUS),
@@ -556,7 +556,7 @@ static void dump_status(struct net_devic
 /* Reset and restore all of the 3c589 registers. */
 static void tc589_reset(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i;
     
     EL3WINDOW(0);
@@ -664,7 +664,7 @@ static int el3_open(struct net_device *d
 static void el3_tx_timeout(struct net_device *dev)
 {
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     
     printk(KERN_WARNING "%s: Transmit timed out!\n", dev->name);
     dump_status(dev);
@@ -679,7 +679,7 @@ static void el3_tx_timeout(struct net_de
 static void pop_tx_status(struct net_device *dev)
 {
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i;
     
     /* Clear the Tx status stack. */
@@ -701,7 +701,7 @@ static void pop_tx_status(struct net_dev
 
 static int el3_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     struct el3_private *priv = netdev_priv(dev);
 
     DEBUG(3, "%s: el3_start_xmit(length = %ld) called, "
@@ -734,7 +734,8 @@ static irqreturn_t el3_interrupt(int irq
 {
     struct net_device *dev = (struct net_device *) dev_id;
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr, status;
+    kio_addr_t ioaddr;
+    __u16 status;
     int i = 0, handled = 1;
     
     if (!netif_device_present(dev))
@@ -819,7 +820,7 @@ static void media_check(unsigned long ar
 {
     struct net_device *dev = (struct net_device *)(arg);
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u16 media, errs;
     unsigned long flags;
 
@@ -921,7 +922,7 @@ static struct net_device_stats *el3_get_
 static void update_stats(struct net_device *dev)
 {
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     DEBUG(2, "%s: updating the statistics.\n", dev->name);
     /* Turn off statistics updates while reading. */
@@ -948,7 +949,7 @@ static void update_stats(struct net_devi
 static int el3_rx(struct net_device *dev)
 {
     struct el3_private *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int worklimit = 32;
     short rx_status;
     
@@ -1003,7 +1004,7 @@ static void set_multicast_list(struct ne
 {
     struct el3_private *lp = netdev_priv(dev);
     dev_link_t *link = &lp->link;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u16 opts = SetRxFilter | RxStation | RxBroadcast;
 
     if (!(DEV_OK(link))) return;
@@ -1018,7 +1019,7 @@ static int el3_close(struct net_device *
 {
     struct el3_private *lp = netdev_priv(dev);
     dev_link_t *link = &lp->link;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     
     DEBUG(1, "%s: shutting down ethercard.\n", dev->name);
 
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/axnet_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/axnet_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/axnet_cs.c	2005-01-22 02:48:20.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/axnet_cs.c	2005-01-26 15:43:26.411500495 +0100
@@ -98,8 +98,8 @@ static irqreturn_t ei_irq_wrapper(int ir
 static void ei_watchdog(u_long arg);
 static void axnet_reset_8390(struct net_device *dev);
 
-static int mdio_read(ioaddr_t addr, int phy_id, int loc);
-static void mdio_write(ioaddr_t addr, int phy_id, int loc, int value);
+static int mdio_read(kio_addr_t addr, int phy_id, int loc);
+static void mdio_write(kio_addr_t addr, int phy_id, int loc, int value);
 
 static void get_8390_hdr(struct net_device *,
 			 struct e8390_pkt_hdr *, int);
@@ -243,7 +243,7 @@ static void axnet_detach(dev_link_t *lin
 static int get_prom(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i, j;
 
     /* This is based on drivers/net/ne.c */
@@ -563,7 +563,7 @@ static int axnet_event(event_t event, in
 #define MDIO_MASK		0x0f
 #define MDIO_ENB_IN		0x02
 
-static void mdio_sync(ioaddr_t addr)
+static void mdio_sync(kio_addr_t addr)
 {
     int bits;
     for (bits = 0; bits < 32; bits++) {
@@ -572,7 +572,7 @@ static void mdio_sync(ioaddr_t addr)
     }
 }
 
-static int mdio_read(ioaddr_t addr, int phy_id, int loc)
+static int mdio_read(kio_addr_t addr, int phy_id, int loc)
 {
     u_int cmd = (0xf6<<10)|(phy_id<<5)|loc;
     int i, retval = 0;
@@ -591,7 +591,7 @@ static int mdio_read(ioaddr_t addr, int 
     return (retval>>1) & 0xffff;
 }
 
-static void mdio_write(ioaddr_t addr, int phy_id, int loc, int value)
+static void mdio_write(kio_addr_t addr, int phy_id, int loc, int value)
 {
     u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;
     int i;
@@ -662,7 +662,7 @@ static int axnet_close(struct net_device
 
 static void axnet_reset_8390(struct net_device *dev)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     int i;
 
     ei_status.txing = ei_status.dmaing = 0;
@@ -697,8 +697,8 @@ static void ei_watchdog(u_long arg)
 {
     struct net_device *dev = (struct net_device *)(arg);
     axnet_dev_t *info = PRIV(dev);
-    ioaddr_t nic_base = dev->base_addr;
-    ioaddr_t mii_addr = nic_base + AXNET_MII_EEP;
+    kio_addr_t nic_base = dev->base_addr;
+    kio_addr_t mii_addr = nic_base + AXNET_MII_EEP;
     u_short link;
 
     if (!netif_device_present(dev)) goto reschedule;
@@ -768,7 +768,7 @@ static int axnet_ioctl(struct net_device
 {
     axnet_dev_t *info = PRIV(dev);
     u16 *data = (u16 *)&rq->ifr_ifru;
-    ioaddr_t mii_addr = dev->base_addr + AXNET_MII_EEP;
+    kio_addr_t mii_addr = dev->base_addr + AXNET_MII_EEP;
     switch (cmd) {
     case SIOCGMIIPHY:
 	data[0] = info->phy_id;
@@ -790,7 +790,7 @@ static void get_8390_hdr(struct net_devi
 			 struct e8390_pkt_hdr *hdr,
 			 int ring_page)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
 
     outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
     outb_p(ring_page, nic_base + EN0_RSARHI);
@@ -808,7 +808,7 @@ static void get_8390_hdr(struct net_devi
 static void block_input(struct net_device *dev, int count,
 			struct sk_buff *skb, int ring_offset)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     int xfer_count = count;
     char *buf = skb->data;
 
@@ -831,7 +831,7 @@ static void block_input(struct net_devic
 static void block_output(struct net_device *dev, int count,
 			 const u_char *buf, const int start_page)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
 
 #ifdef PCMCIA_DEBUG
     if (ei_debug > 4)
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/fmvj18x_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/fmvj18x_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/fmvj18x_cs.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/fmvj18x_cs.c	2005-01-26 15:43:26.415499872 +0100
@@ -343,7 +343,7 @@ do { last_fn = (fn); if ((last_ret = (re
 static int mfc_try_io_port(dev_link_t *link)
 {
     int i, ret;
-    static ioaddr_t serial_base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
+    static kio_addr_t serial_base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
 
     for (i = 0; i < 5; i++) {
 	link->io.BasePort2 = serial_base[i];
@@ -361,7 +361,7 @@ static int mfc_try_io_port(dev_link_t *l
 static int ungermann_try_io_port(dev_link_t *link)
 {
     int ret;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     /*
 	Ungermann-Bass Access/CARD accepts 0x300,0x320,0x340,0x360
 	0x380,0x3c0 only for ioport.
@@ -388,7 +388,7 @@ static void fmvj18x_config(dev_link_t *l
     cisparse_t parse;
     u_short buf[32];
     int i, last_fn, last_ret, ret;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     cardtype_t cardtype;
     char *card_name = "unknown";
     u_char *node_id;
@@ -668,7 +668,7 @@ static int fmvj18x_setup_mfc(dev_link_t 
     u_char __iomem *base;
     int i, j;
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
 
     /* Allocate a small memory window */
     req.Attributes = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;
@@ -793,7 +793,7 @@ static irqreturn_t fjn_interrupt(int irq
 {
     struct net_device *dev = dev_id;
     local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     unsigned short tx_stat, rx_stat;
 
     if (lp == NULL) {
@@ -852,7 +852,7 @@ static irqreturn_t fjn_interrupt(int irq
 static void fjn_tx_timeout(struct net_device *dev)
 {
     struct local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     printk(KERN_NOTICE "%s: transmit timed out with status %04x, %s?\n",
 	   dev->name, htons(inw(ioaddr + TX_STATUS)),
@@ -882,7 +882,7 @@ static void fjn_tx_timeout(struct net_de
 static int fjn_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
     struct local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     short length = skb->len;
     
     if (length < ETH_ZLEN)
@@ -956,7 +956,7 @@ static int fjn_start_xmit(struct sk_buff
 static void fjn_reset(struct net_device *dev)
 {
     struct local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i;
 
     DEBUG(4, "fjn_reset(%s) called.\n",dev->name);
@@ -1042,7 +1042,7 @@ static void fjn_reset(struct net_device 
 static void fjn_rx(struct net_device *dev)
 {
     struct local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int boguscount = 10;	/* 5 -> 10: by agy 19940922 */
 
     DEBUG(4, "%s: in rx_packet(), rx_status %02x.\n",
@@ -1197,7 +1197,7 @@ static int fjn_close(struct net_device *
 {
     struct local_info_t *lp = netdev_priv(dev);
     dev_link_t *link = &lp->link;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     DEBUG(4, "fjn_close('%s').\n", dev->name);
 
@@ -1240,7 +1240,7 @@ static struct net_device_stats *fjn_get_
 
 static void set_rx_mode(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     struct local_info_t *lp = netdev_priv(dev);
     u_char mc_filter[8];		 /* Multicast hash filter */
     u_long flags;
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/nmclan_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/nmclan_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/nmclan_cs.c	2005-01-22 02:47:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/nmclan_cs.c	2005-01-26 15:43:26.419499248 +0100
@@ -561,7 +561,7 @@ mace_read
 	assuming that during normal operation, the MACE is always in
 	bank 0.
 ---------------------------------------------------------------------------- */
-static int mace_read(mace_private *lp, ioaddr_t ioaddr, int reg)
+static int mace_read(mace_private *lp, kio_addr_t ioaddr, int reg)
 {
   int data = 0xFF;
   unsigned long flags;
@@ -588,7 +588,7 @@ mace_write
 	are assuming that during normal operation, the MACE is always in
 	bank 0.
 ---------------------------------------------------------------------------- */
-static void mace_write(mace_private *lp, ioaddr_t ioaddr, int reg, int data)
+static void mace_write(mace_private *lp, kio_addr_t ioaddr, int reg, int data)
 {
   unsigned long flags;
 
@@ -610,7 +610,7 @@ static void mace_write(mace_private *lp,
 mace_init
 	Resets the MACE chip.
 ---------------------------------------------------------------------------- */
-static int mace_init(mace_private *lp, ioaddr_t ioaddr, char *enet_addr)
+static int mace_init(mace_private *lp, kio_addr_t ioaddr, char *enet_addr)
 {
   int i;
   int ct = 0;
@@ -702,7 +702,7 @@ static void nmclan_config(dev_link_t *li
   cisparse_t parse;
   u_char buf[64];
   int i, last_ret, last_fn;
-  ioaddr_t ioaddr;
+  kio_addr_t ioaddr;
 
   DEBUG(0, "nmclan_config(0x%p)\n", link);
 
@@ -935,7 +935,7 @@ mace_open
 ---------------------------------------------------------------------------- */
 static int mace_open(struct net_device *dev)
 {
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   mace_private *lp = netdev_priv(dev);
   dev_link_t *link = &lp->link;
 
@@ -958,7 +958,7 @@ mace_close
 ---------------------------------------------------------------------------- */
 static int mace_close(struct net_device *dev)
 {
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   mace_private *lp = netdev_priv(dev);
   dev_link_t *link = &lp->link;
 
@@ -1031,7 +1031,7 @@ static void mace_tx_timeout(struct net_d
 static int mace_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
   mace_private *lp = netdev_priv(dev);
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
 
   netif_stop_queue(dev);
 
@@ -1092,7 +1092,7 @@ static irqreturn_t mace_interrupt(int ir
 {
   struct net_device *dev = (struct net_device *) dev_id;
   mace_private *lp = netdev_priv(dev);
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   int status;
   int IntrCnt = MACE_MAX_IR_ITERATIONS;
 
@@ -1234,7 +1234,7 @@ mace_rx
 static int mace_rx(struct net_device *dev, unsigned char RxCnt)
 {
   mace_private *lp = netdev_priv(dev);
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   unsigned char rx_framecnt;
   unsigned short rx_status;
 
@@ -1398,7 +1398,7 @@ update_stats
 	card's SRAM fast enough.  If this happens, something is
 	seriously wrong with the hardware.
 ---------------------------------------------------------------------------- */
-static void update_stats(ioaddr_t ioaddr, struct net_device *dev)
+static void update_stats(kio_addr_t ioaddr, struct net_device *dev)
 {
   mace_private *lp = netdev_priv(dev);
 
@@ -1544,7 +1544,7 @@ static void restore_multicast_list(struc
   mace_private *lp = netdev_priv(dev);
   int num_addrs = lp->multicast_num_addrs;
   int *ladrf = lp->multicast_ladrf;
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   int i;
 
   DEBUG(2, "%s: restoring Rx mode to %d addresses.\n",
@@ -1636,7 +1636,7 @@ static void set_multicast_list(struct ne
 
 static void restore_multicast_list(struct net_device *dev)
 {
-  ioaddr_t ioaddr = dev->base_addr;
+  kio_addr_t ioaddr = dev->base_addr;
   mace_private *lp = netdev_priv(dev);
 
   DEBUG(2, "%s: restoring Rx mode to %d addresses.\n", dev->name,
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/pcnet_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/pcnet_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/pcnet_cs.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/pcnet_cs.c	2005-01-26 15:43:26.423498625 +0100
@@ -388,7 +388,7 @@ static hw_info_t *get_hwinfo(dev_link_t 
 static hw_info_t *get_prom(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_char prom[32];
     int i, j;
 
@@ -464,7 +464,7 @@ static hw_info_t *get_dl10019(dev_link_t
 static hw_info_t *get_ax88190(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i, j;
 
     /* Not much of a test, but the alternatives are messy */
@@ -852,7 +852,7 @@ static int pcnet_event(event_t event, in
 #define MDIO_DATA_READ		0x10
 #define MDIO_MASK		0x0f
 
-static void mdio_sync(ioaddr_t addr)
+static void mdio_sync(kio_addr_t addr)
 {
     int bits, mask = inb(addr) & MDIO_MASK;
     for (bits = 0; bits < 32; bits++) {
@@ -861,7 +861,7 @@ static void mdio_sync(ioaddr_t addr)
     }
 }
 
-static int mdio_read(ioaddr_t addr, int phy_id, int loc)
+static int mdio_read(kio_addr_t addr, int phy_id, int loc)
 {
     u_int cmd = (0x06<<10)|(phy_id<<5)|loc;
     int i, retval = 0, mask = inb(addr) & MDIO_MASK;
@@ -880,7 +880,7 @@ static int mdio_read(ioaddr_t addr, int 
     return (retval>>1) & 0xffff;
 }
 
-static void mdio_write(ioaddr_t addr, int phy_id, int loc, int value)
+static void mdio_write(kio_addr_t addr, int phy_id, int loc, int value)
 {
     u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;
     int i, mask = inb(addr) & MDIO_MASK;
@@ -897,7 +897,7 @@ static void mdio_write(ioaddr_t addr, in
     }
 }
 
-static void mdio_reset(ioaddr_t addr, int phy_id)
+static void mdio_reset(kio_addr_t addr, int phy_id)
 {
     outb_p(0x08, addr);
     outb_p(0x0c, addr);
@@ -923,10 +923,10 @@ static void mdio_reset(ioaddr_t addr, in
 
 #define DL19FDUPLX	0x0400	/* DL10019 Full duplex mode */
 
-static int read_eeprom(ioaddr_t ioaddr, int location)
+static int read_eeprom(kio_addr_t ioaddr, int location)
 {
     int i, retval = 0;
-    ioaddr_t ee_addr = ioaddr + DLINK_EEPROM;
+    kio_addr_t ee_addr = ioaddr + DLINK_EEPROM;
     int read_cmd = location | (EE_READ_CMD << 8);
 
     outb(0, ee_addr);
@@ -957,10 +957,10 @@ static int read_eeprom(ioaddr_t ioaddr, 
     In ASIC mode, EE_ADOT is used to output the data to the ASIC.
 */
 
-static void write_asic(ioaddr_t ioaddr, int location, short asic_data)
+static void write_asic(kio_addr_t ioaddr, int location, short asic_data)
 {
 	int i;
-	ioaddr_t ee_addr = ioaddr + DLINK_EEPROM;
+	kio_addr_t ee_addr = ioaddr + DLINK_EEPROM;
 	short dataval;
 	int read_cmd = location | (EE_READ_CMD << 8);
 
@@ -1002,7 +1002,7 @@ static void write_asic(ioaddr_t ioaddr, 
 
 static void set_misc_reg(struct net_device *dev)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     pcnet_dev_t *info = PRIV(dev);
     u_char tmp;
     
@@ -1034,7 +1034,7 @@ static void set_misc_reg(struct net_devi
 static void mii_phy_probe(struct net_device *dev)
 {
     pcnet_dev_t *info = PRIV(dev);
-    ioaddr_t mii_addr = dev->base_addr + DLINK_GPIO;
+    kio_addr_t mii_addr = dev->base_addr + DLINK_GPIO;
     int i;
     u_int tmp, phyid;
 
@@ -1109,7 +1109,7 @@ static int pcnet_close(struct net_device
 
 static void pcnet_reset_8390(struct net_device *dev)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     int i;
 
     ei_status.txing = ei_status.dmaing = 0;
@@ -1167,8 +1167,8 @@ static void ei_watchdog(u_long arg)
 {
     struct net_device *dev = (struct net_device *)arg;
     pcnet_dev_t *info = PRIV(dev);
-    ioaddr_t nic_base = dev->base_addr;
-    ioaddr_t mii_addr = nic_base + DLINK_GPIO;
+    kio_addr_t nic_base = dev->base_addr;
+    kio_addr_t mii_addr = nic_base + DLINK_GPIO;
     u_short link;
 
     if (!netif_device_present(dev)) goto reschedule;
@@ -1271,7 +1271,7 @@ static int ei_ioctl(struct net_device *d
 {
     pcnet_dev_t *info = PRIV(dev);
     u16 *data = (u16 *)&rq->ifr_ifru;
-    ioaddr_t mii_addr = dev->base_addr + DLINK_GPIO;
+    kio_addr_t mii_addr = dev->base_addr + DLINK_GPIO;
     switch (cmd) {
     case SIOCGMIIPHY:
 	data[0] = info->phy_id;
@@ -1293,7 +1293,7 @@ static void dma_get_8390_hdr(struct net_
 			     struct e8390_pkt_hdr *hdr,
 			     int ring_page)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
 
     if (ei_status.dmaing) {
 	printk(KERN_NOTICE "%s: DMAing conflict in dma_block_input."
@@ -1324,7 +1324,7 @@ static void dma_get_8390_hdr(struct net_
 static void dma_block_input(struct net_device *dev, int count,
 			    struct sk_buff *skb, int ring_offset)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     int xfer_count = count;
     char *buf = skb->data;
 
@@ -1379,7 +1379,7 @@ static void dma_block_input(struct net_d
 static void dma_block_output(struct net_device *dev, int count,
 			     const u_char *buf, const int start_page)
 {
-    ioaddr_t nic_base = dev->base_addr;
+    kio_addr_t nic_base = dev->base_addr;
     pcnet_dev_t *info = PRIV(dev);
 #ifdef PCMCIA_DEBUG
     int retries = 0;
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/smc91c92_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/smc91c92_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/smc91c92_cs.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/smc91c92_cs.c	2005-01-26 15:43:26.430497534 +0100
@@ -295,7 +295,7 @@ static int s9k_config(struct net_device 
 static void smc_set_xcvr(struct net_device *dev, int if_port);
 static void smc_reset(struct net_device *dev);
 static void media_check(u_long arg);
-static void mdio_sync(ioaddr_t addr);
+static void mdio_sync(kio_addr_t addr);
 static int mdio_read(struct net_device *dev, int phy_id, int loc);
 static void mdio_write(struct net_device *dev, int phy_id, int loc, int value);
 static int smc_link_ok(struct net_device *dev);
@@ -611,8 +611,8 @@ static void mot_config(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
-    ioaddr_t iouart = link->io.BasePort2;
+    kio_addr_t ioaddr = dev->base_addr;
+    kio_addr_t iouart = link->io.BasePort2;
 
     /* Set UART base address and force map with COR bit 1 */
     writeb(iouart & 0xff,        smc->base + MOT_UART + CISREG_IOBASE_0);
@@ -631,7 +631,7 @@ static void mot_config(dev_link_t *link)
 static int mot_setup(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int i, wait, loop;
     u_int addr;
 
@@ -739,7 +739,7 @@ static int smc_setup(dev_link_t *link)
 static int osi_config(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    static ioaddr_t com[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
+    static kio_addr_t com[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
     int i, j;
 
     link->conf.Attributes |= CONF_ENABLE_SPKR;
@@ -828,7 +828,7 @@ static int osi_setup(dev_link_t *link, u
 static int check_sig(dev_link_t *link)
 {
     struct net_device *dev = link->priv;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int width;
     u_short s;
 
@@ -892,7 +892,7 @@ static void smc91c92_config(dev_link_t *
     u_short buf[32];
     char *name;
     int i, j, rev;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     u_long mir;
 
     DEBUG(0, "smc91c92_config(0x%p)\n", link);
@@ -1171,7 +1171,7 @@ static int smc91c92_event(event_t event,
 #define MDIO_DATA_WRITE1	(MDIO_DIR_WRITE | MDIO_DATA_OUT)
 #define MDIO_DATA_READ		0x02
 
-static void mdio_sync(ioaddr_t addr)
+static void mdio_sync(kio_addr_t addr)
 {
     int bits;
     for (bits = 0; bits < 32; bits++) {
@@ -1182,7 +1182,7 @@ static void mdio_sync(ioaddr_t addr)
 
 static int mdio_read(struct net_device *dev, int phy_id, int loc)
 {
-    ioaddr_t addr = dev->base_addr + MGMT;
+    kio_addr_t addr = dev->base_addr + MGMT;
     u_int cmd = (0x06<<10)|(phy_id<<5)|loc;
     int i, retval = 0;
 
@@ -1202,7 +1202,7 @@ static int mdio_read(struct net_device *
 
 static void mdio_write(struct net_device *dev, int phy_id, int loc, int value)
 {
-    ioaddr_t addr = dev->base_addr + MGMT;
+    kio_addr_t addr = dev->base_addr + MGMT;
     u_int cmd = (0x05<<28)|(phy_id<<23)|(loc<<18)|(1<<17)|value;
     int i;
 
@@ -1228,7 +1228,7 @@ static void mdio_write(struct net_device
 #ifdef PCMCIA_DEBUG
 static void smc_dump(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_short i, w, save;
     save = inw(ioaddr + BANK_SELECT);
     for (w = 0; w < 4; w++) {
@@ -1283,7 +1283,7 @@ static int smc_close(struct net_device *
 {
     struct smc_private *smc = netdev_priv(dev);
     dev_link_t *link = &smc->link;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     DEBUG(0, "%s: smc_close(), status %4.4x.\n",
 	  dev->name, inw(ioaddr + BANK_SELECT));
@@ -1320,7 +1320,7 @@ static void smc_hardware_send_packet(str
 {
     struct smc_private *smc = netdev_priv(dev);
     struct sk_buff *skb = smc->saved_skb;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_char packet_no;
 
     if (!skb) {
@@ -1384,7 +1384,7 @@ static void smc_hardware_send_packet(str
 static void smc_tx_timeout(struct net_device *dev)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     printk(KERN_NOTICE "%s: SMC91c92 transmit timed out, "
 	   "Tx_status %2.2x status %4.4x.\n",
@@ -1399,7 +1399,7 @@ static void smc_tx_timeout(struct net_de
 static int smc_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_short num_pages;
     short time_out, ir;
 
@@ -1465,7 +1465,7 @@ static int smc_start_xmit(struct sk_buff
 static void smc_tx_err(struct net_device * dev)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int saved_packet = inw(ioaddr + PNR_ARR) & 0xff;
     int packet_no = inw(ioaddr + FIFO_PORTS) & 0x7f;
     int tx_status;
@@ -1509,7 +1509,7 @@ static void smc_tx_err(struct net_device
 static void smc_eph_irq(struct net_device *dev)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_short card_stats, ephs;
 
     SMC_SELECT_BANK(0);
@@ -1544,7 +1544,7 @@ static irqreturn_t smc_interrupt(int irq
 {
     struct net_device *dev = dev_id;
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     u_short saved_bank, saved_pointer, mask, status;
     unsigned int handled = 1;
     char bogus_cnt = INTR_WORK;		/* Work we are willing to do. */
@@ -1662,7 +1662,7 @@ irq_done:
 static void smc_rx(struct net_device *dev)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int rx_status;
     int packet_length;	/* Caution: not frame length, rather words
 			   to transfer from the chip. */
@@ -1768,7 +1768,7 @@ static void fill_multicast_tbl(int count
 
 static void set_rx_mode(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     struct smc_private *smc = netdev_priv(dev);
     u_int multicast_table[ 2 ] = { 0, };
     unsigned long flags;
@@ -1835,7 +1835,7 @@ static int s9k_config(struct net_device 
 static void smc_set_xcvr(struct net_device *dev, int if_port)
 {
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_short saved_bank;
 
     saved_bank = inw(ioaddr + BANK_SELECT);
@@ -1858,7 +1858,7 @@ static void smc_set_xcvr(struct net_devi
 
 static void smc_reset(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     struct smc_private *smc = netdev_priv(dev);
     int i;
 
@@ -1935,7 +1935,7 @@ static void media_check(u_long arg)
 {
     struct net_device *dev = (struct net_device *) arg;
     struct smc_private *smc = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u_short i, media, saved_bank;
     u_short link;
 
@@ -2047,7 +2047,7 @@ reschedule:
 
 static int smc_link_ok(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     struct smc_private *smc = netdev_priv(dev);
 
     if (smc->cfg & CFG_MII_SELECT) {
@@ -2061,7 +2061,7 @@ static int smc_link_ok(struct net_device
 static int smc_netdev_get_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)
 {
     u16 tmp;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     ecmd->supported = (SUPPORTED_TP | SUPPORTED_AUI |
 	SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full);
@@ -2083,7 +2083,7 @@ static int smc_netdev_get_ecmd(struct ne
 static int smc_netdev_set_ecmd(struct net_device *dev, struct ethtool_cmd *ecmd)
 {
     u16 tmp;
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     if (ecmd->speed != SPEED_10)
     	return -EINVAL;
@@ -2126,7 +2126,7 @@ static void smc_get_drvinfo(struct net_d
 static int smc_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 {
 	struct smc_private *smc = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	u16 saved_bank = inw(ioaddr + BANK_SELECT);
 	int ret;
 
@@ -2144,7 +2144,7 @@ static int smc_get_settings(struct net_d
 static int smc_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 {
 	struct smc_private *smc = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	u16 saved_bank = inw(ioaddr + BANK_SELECT);
 	int ret;
 
@@ -2162,7 +2162,7 @@ static int smc_set_settings(struct net_d
 static u32 smc_get_link(struct net_device *dev)
 {
 	struct smc_private *smc = netdev_priv(dev);
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 	u16 saved_bank = inw(ioaddr + BANK_SELECT);
 	u32 ret;
 
@@ -2190,7 +2190,7 @@ static int smc_nway_reset(struct net_dev
 {
 	struct smc_private *smc = netdev_priv(dev);
 	if (smc->cfg & CFG_MII_SELECT) {
-		ioaddr_t ioaddr = dev->base_addr;
+		kio_addr_t ioaddr = dev->base_addr;
 		u16 saved_bank = inw(ioaddr + BANK_SELECT);
 		int res;
 
@@ -2222,7 +2222,7 @@ static int smc_ioctl (struct net_device 
 	struct mii_ioctl_data *mii = if_mii(rq);
 	int rc = 0;
 	u16 saved_bank;
-	ioaddr_t ioaddr = dev->base_addr;
+	kio_addr_t ioaddr = dev->base_addr;
 
 	if (!netif_running(dev))
 		return -EINVAL;
diff -purN linux-2.6.11-rc2-bk3/drivers/net/pcmcia/xirc2ps_cs.c linux-2.6.11-rc2-bk4/drivers/net/pcmcia/xirc2ps_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/pcmcia/xirc2ps_cs.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/pcmcia/xirc2ps_cs.c	2005-01-26 15:43:26.436496599 +0100
@@ -274,12 +274,12 @@ INT_MODULE_PARM(lockup_hack,	0);  /* ant
 static unsigned maxrx_bytes = 22000;
 
 /* MII management prototypes */
-static void mii_idle(ioaddr_t ioaddr);
-static void mii_putbit(ioaddr_t ioaddr, unsigned data);
-static int  mii_getbit(ioaddr_t ioaddr);
-static void mii_wbits(ioaddr_t ioaddr, unsigned data, int len);
-static unsigned mii_rd(ioaddr_t ioaddr,	u_char phyaddr, u_char phyreg);
-static void mii_wr(ioaddr_t ioaddr, u_char phyaddr, u_char phyreg,
+static void mii_idle(kio_addr_t ioaddr);
+static void mii_putbit(kio_addr_t ioaddr, unsigned data);
+static int  mii_getbit(kio_addr_t ioaddr);
+static void mii_wbits(kio_addr_t ioaddr, unsigned data, int len);
+static unsigned mii_rd(kio_addr_t ioaddr, u_char phyaddr, u_char phyreg);
+static void mii_wr(kio_addr_t ioaddr, u_char phyaddr, u_char phyreg,
 		   unsigned data, int len);
 
 /*
@@ -425,7 +425,7 @@ next_tuple(client_handle_t handle, tuple
 static void
 PrintRegisters(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     if (pc_debug > 1) {
 	int i, page;
@@ -461,7 +461,7 @@ PrintRegisters(struct net_device *dev)
  * Turn around for read
  */
 static void
-mii_idle(ioaddr_t ioaddr)
+mii_idle(kio_addr_t ioaddr)
 {
     PutByte(XIRCREG2_GPR2, 0x04|0); /* drive MDCK low */
     udelay(1);
@@ -473,7 +473,7 @@ mii_idle(ioaddr_t ioaddr)
  * Write a bit to MDI/O
  */
 static void
-mii_putbit(ioaddr_t ioaddr, unsigned data)
+mii_putbit(kio_addr_t ioaddr, unsigned data)
 {
   #if 1
     if (data) {
@@ -506,7 +506,7 @@ mii_putbit(ioaddr_t ioaddr, unsigned dat
  * Get a bit from MDI/O
  */
 static int
-mii_getbit(ioaddr_t ioaddr)
+mii_getbit(kio_addr_t ioaddr)
 {
     unsigned d;
 
@@ -519,7 +519,7 @@ mii_getbit(ioaddr_t ioaddr)
 }
 
 static void
-mii_wbits(ioaddr_t ioaddr, unsigned data, int len)
+mii_wbits(kio_addr_t ioaddr, unsigned data, int len)
 {
     unsigned m = 1 << (len-1);
     for (; m; m >>= 1)
@@ -527,7 +527,7 @@ mii_wbits(ioaddr_t ioaddr, unsigned data
 }
 
 static unsigned
-mii_rd(ioaddr_t ioaddr,	u_char phyaddr, u_char phyreg)
+mii_rd(kio_addr_t ioaddr,	u_char phyaddr, u_char phyreg)
 {
     int i;
     unsigned data=0, m;
@@ -549,7 +549,7 @@ mii_rd(ioaddr_t ioaddr,	u_char phyaddr, 
 }
 
 static void
-mii_wr(ioaddr_t ioaddr, u_char phyaddr, u_char phyreg, unsigned data, int len)
+mii_wr(kio_addr_t ioaddr, u_char phyaddr, u_char phyreg, unsigned data, int len)
 {
     int i;
 
@@ -805,7 +805,7 @@ xirc2ps_config(dev_link_t * link)
     local_info_t *local = netdev_priv(dev);
     tuple_t tuple;
     cisparse_t parse;
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     int err, i;
     u_char buf[64];
     cistpl_lan_node_id_t *node_id = (cistpl_lan_node_id_t*)parse.funce.data;
@@ -1240,7 +1240,7 @@ xirc2ps_interrupt(int irq, void *dev_id,
 {
     struct net_device *dev = (struct net_device *)dev_id;
     local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr;
+    kio_addr_t ioaddr;
     u_char saved_page;
     unsigned bytes_rcvd;
     unsigned int_status, eth_status, rx_status, tx_status;
@@ -1345,7 +1345,7 @@ xirc2ps_interrupt(int irq, void *dev_id,
 		    unsigned i;
 		    u_long *p = skb_put(skb, pktlen);
 		    register u_long a;
-		    ioaddr_t edpreg = ioaddr+XIRCREG_EDP-2;
+		    kio_addr_t edpreg = ioaddr+XIRCREG_EDP-2;
 		    for (i=0; i < len ; i += 4, p++) {
 			a = inl(edpreg);
 			__asm__("rorl $16,%0\n\t"
@@ -1474,7 +1474,7 @@ static int
 do_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
     local_info_t *lp = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     int okay;
     unsigned freespace;
     unsigned pktlen = skb? skb->len : 0;
@@ -1544,7 +1544,7 @@ do_get_stats(struct net_device *dev)
 static void
 set_addresses(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     local_info_t *lp = netdev_priv(dev);
     struct dev_mc_list *dmi = dev->mc_list;
     char *addr;
@@ -1586,7 +1586,7 @@ set_addresses(struct net_device *dev)
 static void
 set_multicast_list(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     SelectPage(0x42);
     if (dev->flags & IFF_PROMISC) { /* snoop */
@@ -1670,7 +1670,7 @@ static int
 do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
     local_info_t *local = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     u16 *data = (u16 *)&rq->ifr_ifru;
 
     DEBUG(1, "%s: ioctl(%-.6s, %#04x) %04x %04x %04x %04x\n",
@@ -1702,7 +1702,7 @@ static void
 hardreset(struct net_device *dev)
 {
     local_info_t *local = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     SelectPage(4);
     udelay(1);
@@ -1719,7 +1719,7 @@ static void
 do_reset(struct net_device *dev, int full)
 {
     local_info_t *local = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     unsigned value;
 
     DEBUG(0, "%s: do_reset(%p,%d)\n", dev? dev->name:"eth?", dev, full);
@@ -1880,7 +1880,7 @@ static int
 init_mii(struct net_device *dev)
 {
     local_info_t *local = netdev_priv(dev);
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     unsigned control, status, linkpartner;
     int i;
 
@@ -1953,7 +1953,7 @@ static void
 do_powerdown(struct net_device *dev)
 {
 
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
 
     DEBUG(0, "do_powerdown(%p)\n", dev);
 
@@ -1965,7 +1965,7 @@ do_powerdown(struct net_device *dev)
 static int
 do_stop(struct net_device *dev)
 {
-    ioaddr_t ioaddr = dev->base_addr;
+    kio_addr_t ioaddr = dev->base_addr;
     local_info_t *lp = netdev_priv(dev);
     dev_link_t *link = &lp->link;
 
diff -purN linux-2.6.11-rc2-bk3/drivers/net/wireless/netwave_cs.c linux-2.6.11-rc2-bk4/drivers/net/wireless/netwave_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/wireless/netwave_cs.c	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/wireless/netwave_cs.c	2005-01-26 15:43:26.480489742 +0100
@@ -206,7 +206,7 @@ static dev_link_t *netwave_attach(void);
 static void netwave_detach(dev_link_t *);    /* Destroy instance */
 
 /* Hardware configuration */
-static void netwave_doreset(ioaddr_t iobase, u_char __iomem *ramBase);
+static void netwave_doreset(kio_addr_t iobase, u_char __iomem *ramBase);
 static void netwave_reset(struct net_device *dev);
 
 /* Misc device stuff */
@@ -356,7 +356,7 @@ static inline void wait_WOC(unsigned int
 
 #ifdef WIRELESS_EXT
 static void netwave_snapshot(netwave_private *priv, u_char __iomem *ramBase, 
-			     ioaddr_t iobase) { 
+			     kio_addr_t iobase) {
     u_short resultBuffer;
 
     /* if time since last snapshot is > 1 sec. (100 jiffies?)  then take 
@@ -389,7 +389,7 @@ static void netwave_snapshot(netwave_pri
 static struct iw_statistics *netwave_get_wireless_stats(struct net_device *dev)
 {	
     unsigned long flags;
-    ioaddr_t iobase = dev->base_addr;
+    kio_addr_t iobase = dev->base_addr;
     netwave_private *priv = netdev_priv(dev);
     u_char __iomem *ramBase = priv->ramBase;
     struct iw_statistics* wstats;
@@ -575,7 +575,7 @@ static int netwave_set_nwid(struct net_d
 			    char *extra)
 {
 	unsigned long flags;
-	ioaddr_t iobase = dev->base_addr;
+	kio_addr_t iobase = dev->base_addr;
 	netwave_private *priv = netdev_priv(dev);
 	u_char __iomem *ramBase = priv->ramBase;
 
@@ -633,7 +633,7 @@ static int netwave_set_scramble(struct n
 				char *key)
 {
 	unsigned long flags;
-	ioaddr_t iobase = dev->base_addr;
+	kio_addr_t iobase = dev->base_addr;
 	netwave_private *priv = netdev_priv(dev);
 	u_char __iomem *ramBase = priv->ramBase;
 
@@ -749,7 +749,7 @@ static int netwave_get_snap(struct net_d
 			    char *extra)
 {
 	unsigned long flags;
-	ioaddr_t iobase = dev->base_addr;
+	kio_addr_t iobase = dev->base_addr;
 	netwave_private *priv = netdev_priv(dev);
 	u_char __iomem *ramBase = priv->ramBase;
 
@@ -1192,7 +1192,7 @@ static int netwave_event(event_t event, 
  *
  *    Proper hardware reset of the card.
  */
-static void netwave_doreset(ioaddr_t ioBase, u_char __iomem *ramBase)
+static void netwave_doreset(kio_addr_t ioBase, u_char __iomem *ramBase)
 {
     /* Reset card */
     wait_WOC(ioBase);
@@ -1210,7 +1210,7 @@ static void netwave_reset(struct net_dev
     /* u_char state; */
     netwave_private *priv = netdev_priv(dev);
     u_char __iomem *ramBase = priv->ramBase;
-    ioaddr_t iobase = dev->base_addr;
+    kio_addr_t iobase = dev->base_addr;
 
     DEBUG(0, "netwave_reset: Done with hardware reset\n");
 
@@ -1291,7 +1291,7 @@ static int netwave_hw_xmit(unsigned char
 	
     netwave_private *priv = netdev_priv(dev);
     u_char __iomem * ramBase = priv->ramBase;
-    ioaddr_t iobase = dev->base_addr;
+    kio_addr_t iobase = dev->base_addr;
 
     /* Disable interrupts & save flags */
     spin_lock_irqsave(&priv->spinlock, flags);
@@ -1383,7 +1383,7 @@ static int netwave_start_xmit(struct sk_
  */
 static irqreturn_t netwave_interrupt(int irq, void* dev_id, struct pt_regs *regs)
 {
-    ioaddr_t iobase;
+    kio_addr_t iobase;
     u_char __iomem *ramBase;
     struct net_device *dev = (struct net_device *)dev_id;
     struct netwave_private *priv = netdev_priv(dev);
@@ -1553,7 +1553,7 @@ static int netwave_rx(struct net_device 
 {
     netwave_private *priv = netdev_priv(dev);
     u_char __iomem *ramBase = priv->ramBase;
-    ioaddr_t iobase = dev->base_addr;
+    kio_addr_t iobase = dev->base_addr;
     u_char rxStatus;
     struct sk_buff *skb = NULL;
     unsigned int curBuffer,
@@ -1699,7 +1699,7 @@ module_exit(exit_netwave_cs);
  */
 static void set_multicast_list(struct net_device *dev)
 {
-    ioaddr_t iobase = dev->base_addr;
+    kio_addr_t iobase = dev->base_addr;
     netwave_private *priv = netdev_priv(dev);
     u_char __iomem * ramBase = priv->ramBase;
     u_char  rcvMode = 0;
diff -purN linux-2.6.11-rc2-bk3/drivers/net/wireless/wavelan_cs.c linux-2.6.11-rc2-bk4/drivers/net/wireless/wavelan_cs.c
--- linux-2.6.11-rc2-bk3/drivers/net/wireless/wavelan_cs.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/net/wireless/wavelan_cs.c	2005-01-26 15:43:26.490488183 +0100
@@ -164,7 +164,7 @@ psa_write(struct net_device *	dev,
   net_local *lp = netdev_priv(dev);
   u_char __iomem *ptr = lp->mem + PSA_ADDR + (o << 1);
   int		count = 0;
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   /* As there seem to have no flag PSA_BUSY as in the ISA model, we are
    * oblige to verify this address to know when the PSA is ready... */
   volatile u_char __iomem *verify = lp->mem + PSA_ADDR +
@@ -725,7 +725,7 @@ void wl_update_history(wavepoint_history
 /* Perform a handover to a new WavePoint */
 void wv_roam_handover(wavepoint_history *wavepoint, net_local *lp)
 {
-  ioaddr_t              base = lp->dev->base_addr;  
+  kio_addr_t		base = lp->dev->base_addr;
   mm_t                  m;
   unsigned long         flags;
 
@@ -838,7 +838,7 @@ wv_82593_cmd(struct net_device *	dev,
 	     int	cmd,
 	     int	result)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   int		status;
   int		wait_completed;
   long		spin;
@@ -970,7 +970,7 @@ read_ringbuf(struct net_device *	dev,
 	     char *	buf,
 	     int	len)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   int		ring_ptr = addr;
   int		chunk_len;
   char *	buf_ptr = buf;
@@ -1136,7 +1136,7 @@ wv_psa_show(psa_t *	p)
 static void
 wv_mmc_show(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   net_local *	lp = netdev_priv(dev);
   mmr_t		m;
 
@@ -1316,7 +1316,7 @@ wv_packet_info(u_char *		p,		/* Packet t
 static inline void
 wv_init_info(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   psa_t		psa;
   int		i;
 
@@ -1335,7 +1335,7 @@ wv_init_info(struct net_device *	dev)
 
 #ifdef DEBUG_BASIC_SHOW
   /* Now, let's go for the basic stuff */
-  printk(KERN_NOTICE "%s: WaveLAN: port %#x, irq %d, hw_addr",
+  printk(KERN_NOTICE "%s: WaveLAN: port %#lx, irq %d, hw_addr",
 	 dev->name, base, dev->irq);
   for(i = 0; i < WAVELAN_ADDR_SIZE; i++)
     printk("%s%02X", (i == 0) ? " " : ":", dev->dev_addr[i]);
@@ -1870,7 +1870,7 @@ static int wavelan_set_nwid(struct net_d
 			    union iwreq_data *wrqu,
 			    char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	psa_t psa;
 	mm_t m;
@@ -1960,7 +1960,7 @@ static int wavelan_set_freq(struct net_d
 			    union iwreq_data *wrqu,
 			    char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	unsigned long flags;
 	int ret;
@@ -1990,7 +1990,7 @@ static int wavelan_get_freq(struct net_d
 			    union iwreq_data *wrqu,
 			    char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	psa_t psa;
 	unsigned long flags;
@@ -2036,7 +2036,7 @@ static int wavelan_set_sens(struct net_d
 			    union iwreq_data *wrqu,
 			    char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	psa_t psa;
 	unsigned long flags;
@@ -2102,7 +2102,7 @@ static int wavelan_set_encode(struct net
 			      union iwreq_data *wrqu,
 			      char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	unsigned long flags;
 	psa_t psa;
@@ -2172,7 +2172,7 @@ static int wavelan_get_encode(struct net
 			      union iwreq_data *wrqu,
 			      char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	psa_t psa;
 	unsigned long flags;
@@ -2391,7 +2391,7 @@ static int wavelan_get_range(struct net_
 			     union iwreq_data *wrqu,
 			     char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	struct iw_range *range = (struct iw_range *) extra;
 	unsigned long flags;
@@ -2467,7 +2467,7 @@ static int wavelan_set_qthr(struct net_d
 			    union iwreq_data *wrqu,
 			    char *extra)
 {
-	ioaddr_t base = dev->base_addr;
+	kio_addr_t base = dev->base_addr;
 	net_local *lp = netdev_priv(dev);
 	psa_t psa;
 	unsigned long flags;
@@ -2743,7 +2743,7 @@ static const struct iw_handler_def	wavel
 static iw_stats *
 wavelan_get_wireless_stats(struct net_device *	dev)
 {
-  ioaddr_t		base = dev->base_addr;
+  kio_addr_t		base = dev->base_addr;
   net_local *		lp = netdev_priv(dev);
   mmr_t			m;
   iw_stats *		wstats;
@@ -2807,7 +2807,7 @@ wv_start_of_frame(struct net_device *	de
 		  int		rfp,	/* end of frame */
 		  int		wrap)	/* start of buffer */
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   int		rp;
   int		len;
 
@@ -2970,7 +2970,7 @@ wv_packet_read(struct net_device *		dev,
 static inline void
 wv_packet_rcv(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   net_local *	lp = netdev_priv(dev);
   int		newrfp;
   int		rp;
@@ -3107,7 +3107,7 @@ wv_packet_write(struct net_device *	dev,
 		short		length)
 {
   net_local *		lp = netdev_priv(dev);
-  ioaddr_t		base = dev->base_addr;
+  kio_addr_t		base = dev->base_addr;
   unsigned long		flags;
   int			clen = length;
   register u_short	xmtdata_base = TX_BASE;
@@ -3231,7 +3231,7 @@ wavelan_packet_xmit(struct sk_buff *	skb
 static inline int
 wv_mmc_init(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   psa_t		psa;
   mmw_t		m;
   int		configured;
@@ -3425,7 +3425,7 @@ wv_mmc_init(struct net_device *	dev)
 static int
 wv_ru_stop(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   net_local *	lp = netdev_priv(dev);
   unsigned long	flags;
   int		status;
@@ -3488,7 +3488,7 @@ wv_ru_stop(struct net_device *	dev)
 static int
 wv_ru_start(struct net_device *	dev)
 {
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
   net_local *	lp = netdev_priv(dev);
   unsigned long	flags;
 
@@ -3576,7 +3576,7 @@ wv_ru_start(struct net_device *	dev)
 static int
 wv_82593_config(struct net_device *	dev)
 {
-  ioaddr_t			base = dev->base_addr;
+  kio_addr_t			base = dev->base_addr;
   net_local *			lp = netdev_priv(dev);
   struct i82593_conf_block	cfblk;
   int				ret = TRUE;
@@ -3813,7 +3813,7 @@ static int
 wv_hw_config(struct net_device *	dev)
 {
   net_local *		lp = netdev_priv(dev);
-  ioaddr_t		base = dev->base_addr;
+  kio_addr_t		base = dev->base_addr;
   unsigned long		flags;
   int			ret = FALSE;
 
@@ -4144,7 +4144,7 @@ wavelan_interrupt(int		irq,
 {
   struct net_device *	dev;
   net_local *	lp;
-  ioaddr_t	base;
+  kio_addr_t	base;
   int		status0;
   u_int		tx_status;
 
@@ -4412,7 +4412,7 @@ static void
 wavelan_watchdog(struct net_device *	dev)
 {
   net_local *		lp = netdev_priv(dev);
-  ioaddr_t		base = dev->base_addr;
+  kio_addr_t		base = dev->base_addr;
   unsigned long		flags;
   int			aborted = FALSE;
 
@@ -4488,7 +4488,7 @@ wavelan_open(struct net_device *	dev)
 {
   net_local *	lp = netdev_priv(dev);
   dev_link_t *	link = lp->link;
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
 
 #ifdef DEBUG_CALLBACK_TRACE
   printk(KERN_DEBUG "%s: ->wavelan_open(dev=0x%x)\n", dev->name,
@@ -4542,7 +4542,7 @@ static int
 wavelan_close(struct net_device *	dev)
 {
   dev_link_t *	link = ((net_local *)netdev_priv(dev))->link;
-  ioaddr_t	base = dev->base_addr;
+  kio_addr_t	base = dev->base_addr;
 
 #ifdef DEBUG_CALLBACK_TRACE
   printk(KERN_DEBUG "%s: ->wavelan_close(dev=0x%x)\n", dev->name,
diff -purN linux-2.6.11-rc2-bk3/drivers/oprofile/oprof.c linux-2.6.11-rc2-bk4/drivers/oprofile/oprof.c
--- linux-2.6.11-rc2-bk3/drivers/oprofile/oprof.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/oprofile/oprof.c	2005-01-26 15:43:26.491488028 +0100
@@ -153,11 +153,11 @@ out:
 
 static int __init oprofile_init(void)
 {
-	int err = 0;
+	int err;
 
-	oprofile_arch_init(&oprofile_ops);
+	err = oprofile_arch_init(&oprofile_ops);
 
-	if (timer) {
+	if (err < 0 || timer) {
 		printk(KERN_INFO "oprofile: using timer interrupt.\n");
 		oprofile_timer_init(&oprofile_ops);
 	}
diff -purN linux-2.6.11-rc2-bk3/drivers/parisc/led.c linux-2.6.11-rc2-bk4/drivers/parisc/led.c
--- linux-2.6.11-rc2-bk3/drivers/parisc/led.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/parisc/led.c	2005-01-26 15:43:26.493487716 +0100
@@ -26,7 +26,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 #include <linux/delay.h>
 #include <linux/netdevice.h>
 #include <linux/inetdevice.h>
@@ -56,7 +56,7 @@ static int led_heartbeat = 1;
 static int led_diskio = 1;
 static int led_lanrxtx = 1;
 static char lcd_text[32];
-static char lcd_text_default[] = "Linux " UTS_RELEASE;
+static char lcd_text_default[32];
 
 #if 0
 #define DPRINTK(x)	printk x
@@ -676,6 +676,9 @@ int __init led_init(void)
 	struct pdc_chassis_info chassis_info;
 	int ret;
 
+	snprintf(lcd_text_default, sizeof(lcd_text_default),
+		"Linux %s", system_utsname.release);
+
 	/* Work around the buggy PDC of KittyHawk-machines */
 	switch (CPU_HVERSION) {
 	case 0x580:		/* KittyHawk DC2-100 (K100) */
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/au1000_generic.c linux-2.6.11-rc2-bk4/drivers/pcmcia/au1000_generic.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/au1000_generic.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/au1000_generic.c	2005-01-26 15:43:26.494487560 +0100
@@ -196,13 +196,13 @@ static int __init au1000_pcmcia_driver_i
 		
 		if (i == 0) {
 			pcmcia_socket[i].virt_io = 
-				(u32)ioremap((ioaddr_t)0xF00000000, 0x1000);
+				(u32)ioremap((kio_addr_t)0xF00000000, 0x1000);
 			pcmcia_socket[i].phys_attr = (memaddr_t)0xF40000000;
 			pcmcia_socket[i].phys_mem = (memaddr_t)0xF80000000;
 		}
 		else  {
 			pcmcia_socket[i].virt_io = 
-				(u32)ioremap((ioaddr_t)0xF08000000, 0x1000);
+				(u32)ioremap((kio_addr_t)0xF08000000, 0x1000);
 			pcmcia_socket[i].phys_attr = (memaddr_t)0xF48000000;
 			pcmcia_socket[i].phys_mem = (memaddr_t)0xF88000000;
 		}
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/cs.c linux-2.6.11-rc2-bk4/drivers/pcmcia/cs.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/cs.c	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/cs.c	2005-01-26 15:43:26.498486937 +0100
@@ -341,25 +341,13 @@ EXPORT_SYMBOL(pcmcia_get_socket_by_nr);
 
 /*======================================================================
 
-    Shutdown_Socket() and setup_socket() are scheduled using add_timer
-    calls by the main event handler when card insertion and removal
-    events are received.  Shutdown_Socket() unconfigures a socket and
-    turns off socket power.  Setup_socket() turns on socket power
-    and resets the socket, in two stages.
+    socket_setup() and shutdown_socket() are called by the main event
+    handler when card insertion and removal events are received.
+    socket_setup() turns on socket power and resets the socket, in two stages.
+    shutdown_socket() unconfigures a socket and turns off socket power.
 
 ======================================================================*/
 
-static void free_regions(memory_handle_t *list)
-{
-    memory_handle_t tmp;
-    while (*list != NULL) {
-	tmp = *list;
-	*list = tmp->info.next;
-	tmp->region_magic = 0;
-	kfree(tmp);
-    }
-}
-
 static void shutdown_socket(struct pcmcia_socket *s)
 {
     cs_dbg(s, 1, "shutdown_socket\n");
@@ -379,8 +367,6 @@ static void shutdown_socket(struct pcmci
 	kfree(s->config);
 	s->config = NULL;
     }
-    free_regions(&s->a_region);
-    free_regions(&s->c_region);
 
     {
 	int status;
@@ -755,19 +741,19 @@ static int alloc_io_space(struct pcmcia_
 			  ioaddr_t num, u_int lines)
 {
     int i;
-    ioaddr_t try, align;
+    kio_addr_t try, align;
 
     align = (*base) ? (lines ? 1<<lines : 0) : 1;
     if (align && (align < num)) {
 	if (*base) {
-	    cs_dbg(s, 0, "odd IO request: num %04x align %04x\n",
+	    cs_dbg(s, 0, "odd IO request: num %#x align %#lx\n",
 		   num, align);
 	    align = 0;
 	} else
 	    while (align && (align < num)) align <<= 1;
     }
     if (*base & ~(align-1)) {
-	cs_dbg(s, 0, "odd IO request: base %04x align %04x\n",
+	cs_dbg(s, 0, "odd IO request: base %#x align %#lx\n",
 	       *base, align);
 	align = 0;
     }
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/hd64465_ss.c linux-2.6.11-rc2-bk4/drivers/pcmcia/hd64465_ss.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/hd64465_ss.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/hd64465_ss.c	2005-01-26 15:43:26.500486625 +0100
@@ -566,7 +566,7 @@ static int hs_set_io_map(struct pcmcia_s
 	struct pccard_io_map *sio;
 	pgprot_t prot;
 
-    	DPRINTK("hs_set_io_map(sock=%d, map=%d, flags=0x%x, speed=%dns, start=0x%04x, stop=0x%04x)\n",
+    	DPRINTK("hs_set_io_map(sock=%d, map=%d, flags=0x%x, speed=%dns, start=%#lx, stop=%#lx)\n",
 	    sock, map, io->flags, io->speed, io->start, io->stop);
 	if (map >= MAX_IO_WIN)
 	    return -EINVAL;
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/i82092.c linux-2.6.11-rc2-bk4/drivers/pcmcia/i82092.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/i82092.c	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/i82092.c	2005-01-26 15:43:26.502486313 +0100
@@ -81,7 +81,7 @@ struct socket_info {
 				    1 = empty socket, 
 				    2 = card but not initialized,
 				    3 = operational card */
-	int 	io_base; 	/* base io address of the socket */
+	kio_addr_t io_base; 	/* base io address of the socket */
 	
 	struct pcmcia_socket socket;
 	struct pci_dev *dev;	/* The PCI device for the socket */
@@ -122,7 +122,7 @@ static int __devinit i82092aa_pci_probe(
 	}
 	printk(KERN_INFO "i82092aa: configured as a %d socket device.\n", socket_count);
 
-	if (request_region(pci_resource_start(dev, 0), 2, "i82092aa")) {
+	if (!request_region(pci_resource_start(dev, 0), 2, "i82092aa")) {
 		ret = -EBUSY;
 		goto err_out_disable;
 	}
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/i82365.c linux-2.6.11-rc2-bk4/drivers/pcmcia/i82365.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/i82365.c	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/i82365.c	2005-01-26 15:43:26.506485690 +0100
@@ -96,7 +96,7 @@ static inline int _check_irq(int irq, in
 /* Parameters that can be set with 'insmod' */
 
 /* Default base address for i82365sl and other ISA chips */
-static int i365_base = 0x3e0;
+static unsigned long i365_base = 0x3e0;
 /* Should we probe at 0x3e2 for an extra ISA controller? */
 static int extra_sockets = 0;
 /* Specify a socket number to ignore */
@@ -130,7 +130,7 @@ static int async_clock = -1;
 static int cable_mode = -1;
 static int wakeup = 0;
 
-module_param(i365_base, int, 0444);
+module_param(i365_base, ulong, 0444);
 module_param(ignore, int, 0444);
 module_param(extra_sockets, int, 0444);
 module_param(irq_mask, int, 0444);
@@ -167,7 +167,7 @@ struct i82365_socket {
     u_short		type, flags;
     struct pcmcia_socket	socket;
     unsigned int	number;
-    ioaddr_t		ioaddr;
+    kio_addr_t		ioaddr;
     u_short		psock;
     u_char		cs_irq, intr;
     union {
@@ -240,7 +240,7 @@ static u_char i365_get(u_short sock, u_s
     unsigned long flags;
     spin_lock_irqsave(&bus_lock,flags);
     {
-	ioaddr_t port = socket[sock].ioaddr;
+	kio_addr_t port = socket[sock].ioaddr;
 	u_char val;
 	reg = I365_REG(socket[sock].psock, reg);
 	outb(reg, port); val = inb(port+1);
@@ -254,7 +254,7 @@ static void i365_set(u_short sock, u_sho
     unsigned long flags;
     spin_lock_irqsave(&bus_lock,flags);
     {
-	ioaddr_t port = socket[sock].ioaddr;
+	kio_addr_t port = socket[sock].ioaddr;
 	u_char val = I365_REG(socket[sock].psock, reg);
 	outb(val, port); outb(data, port+1);
 	spin_unlock_irqrestore(&bus_lock,flags);
@@ -589,7 +589,7 @@ static int to_cycles(int ns)
 
 /*====================================================================*/
 
-static int __init identify(u_short port, u_short sock)
+static int __init identify(kio_addr_t port, u_short sock)
 {
     u_char val;
     int type = -1;
@@ -660,7 +660,7 @@ static int __init identify(u_short port,
 static int __init is_alive(u_short sock)
 {
     u_char stat;
-    u_short start, stop;
+    kio_addr_t start, stop;
     
     stat = i365_get(sock, I365_STATUS);
     start = i365_get_pair(sock, I365_IO(0)+I365_W_START);
@@ -677,7 +677,7 @@ static int __init is_alive(u_short sock)
 
 /*====================================================================*/
 
-static void __init add_socket(u_short port, int psock, int type)
+static void __init add_socket(kio_addr_t port, int psock, int type)
 {
     socket[sockets].ioaddr = port;
     socket[sockets].psock = psock;
@@ -699,7 +699,7 @@ static void __init add_pcic(int ns, int 
     
     if (base == 0) printk("\n");
     printk(KERN_INFO "  %s", pcic[type].name);
-    printk(" ISA-to-PCMCIA at port %#x ofs 0x%02x",
+    printk(" ISA-to-PCMCIA at port %#lx ofs 0x%02x",
 	       t->ioaddr, t->psock*0x40);
     printk(", %d socket%s\n", ns, ((ns > 1) ? "s" : ""));
 
@@ -773,7 +773,7 @@ static struct pnp_dev *i82365_pnpdev;
 static void __init isa_probe(void)
 {
     int i, j, sock, k, ns, id;
-    ioaddr_t port;
+    kio_addr_t port;
 #ifdef CONFIG_PNP
     struct isapnp_device_id *devid;
     struct pnp_dev *dev;
@@ -804,7 +804,7 @@ static void __init isa_probe(void)
 
     if (check_region(i365_base, 2) != 0) {
 	if (sockets == 0)
-	    printk("port conflict at %#x\n", i365_base);
+	    printk("port conflict at %#lx\n", i365_base);
 	return;
     }
 
@@ -1127,7 +1127,7 @@ static int i365_set_io_map(u_short sock,
     u_char map, ioctl;
     
     debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
-	  "%#4.4x-%#4.4x)\n", sock, io->map, io->flags,
+	  "%#lx-%#lx)\n", sock, io->map, io->flags,
 	  io->speed, io->start, io->stop);
     map = io->map;
     if ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||
@@ -1156,8 +1156,8 @@ static int i365_set_mem_map(u_short sock
     u_short base, i;
     u_char map;
     
-    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#5.5lx-%#5.5"
-	  "lx, %#5.5x)\n", sock, mem->map, mem->flags, mem->speed,
+    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#lx-%#lx, "
+	  "%#x)\n", sock, mem->map, mem->flags, mem->speed,
 	  mem->res->start, mem->res->end, mem->card_start);
 
     map = mem->map;
@@ -1447,7 +1447,7 @@ static void __exit exit_i82365(void)
 	i365_set(i, I365_CSCINT, 0);
 	release_region(socket[i].ioaddr, 2);
     }
-#ifdef __ISAPNP__
+#ifdef CONFIG_PNP
     if (i82365_pnpdev)
     		pnp_disable_dev(i82365_pnpdev);
 #endif
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/m32r_cfc.c linux-2.6.11-rc2-bk4/drivers/pcmcia/m32r_cfc.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/m32r_cfc.c	2005-01-22 02:48:14.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/m32r_cfc.c	2005-01-26 15:43:26.508485378 +0100
@@ -61,7 +61,7 @@ typedef struct pcc_socket {
 	u_short			type, flags;
 	struct pcmcia_socket	socket;
 	unsigned int		number;
- 	ioaddr_t		ioaddr;
+ 	kio_addr_t		ioaddr;
 	u_long			mapaddr;
 	u_long			base;	/* PCC register base */
 	u_char			cs_irq1, cs_irq2, intr;
@@ -300,7 +300,7 @@ static int __init is_alive(u_short sock)
 	return 0;
 }
 
-static void add_pcc_socket(ulong base, int irq, ulong mapaddr, ioaddr_t ioaddr)
+static void add_pcc_socket(ulong base, int irq, ulong mapaddr, kio_addr_t ioaddr)
 {
 	pcc_socket_t *t = &socket[pcc_sockets];
 
@@ -568,7 +568,7 @@ static int _pcc_set_io_map(u_short sock,
 	u_char map;
 
 	debug(3, "m32r_cfc: SetIOMap(%d, %d, %#2.2x, %d ns, "
-		  "%#4.4x-%#4.4x)\n", sock, io->map, io->flags,
+		  "%#lx-%#lx)\n", sock, io->map, io->flags,
 		  io->speed, io->start, io->stop);
 	map = io->map;
 
@@ -585,7 +585,7 @@ static int _pcc_set_mem_map(u_short sock
 	pcc_socket_t *t = &socket[sock];
 
 	debug(3, "m32r_cfc: SetMemMap(%d, %d, %#2.2x, %d ns, "
-		 "%#5.5lx, %#5.5x)\n", sock, map, mem->flags,
+		 "%#lx, %#x)\n", sock, map, mem->flags,
 		 mem->speed, mem->static_start, mem->card_start);
 
 	/*
@@ -807,7 +807,7 @@ static int __init init_m32r_pcc(void)
 #else	/* CONFIG_PLAT_USRV */
 	{
 		ulong base, mapaddr;
-		ioaddr_t ioaddr;
+		kio_addr_t ioaddr;
 
 		for (i = 0 ; i < M32R_MAX_PCC ; i++) {
 			base = (ulong)PLD_CFRSTCR;
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/m32r_pcc.c linux-2.6.11-rc2-bk4/drivers/pcmcia/m32r_pcc.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/m32r_pcc.c	2005-01-22 02:46:45.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/m32r_pcc.c	2005-01-26 15:43:26.510485067 +0100
@@ -68,7 +68,7 @@ typedef struct pcc_socket {
 	u_short			type, flags;
 	struct pcmcia_socket	socket;
 	unsigned int		number;
- 	ioaddr_t		ioaddr;
+ 	kio_addr_t		ioaddr;
 	u_long			mapaddr;
 	u_long			base;	/* PCC register base */
 	u_char			cs_irq, intr;
@@ -312,7 +312,7 @@ static int __init is_alive(u_short sock)
 	return 0;
 }
 
-static void add_pcc_socket(ulong base, int irq, ulong mapaddr, ioaddr_t ioaddr)
+static void add_pcc_socket(ulong base, int irq, ulong mapaddr, kio_addr_t ioaddr)
 {
   	pcc_socket_t *t = &socket[pcc_sockets];
 
@@ -503,7 +503,7 @@ static int _pcc_set_io_map(u_short sock,
 	u_char map;
 
 	debug(3, "m32r-pcc: SetIOMap(%d, %d, %#2.2x, %d ns, "
-		  "%#4.4x-%#4.4x)\n", sock, io->map, io->flags,
+		  "%#lx-%#lx)\n", sock, io->map, io->flags,
 		  io->speed, io->start, io->stop);
 	map = io->map;
 
@@ -526,7 +526,7 @@ static int _pcc_set_mem_map(u_short sock
 #endif
 
 	debug(3, "m32r-pcc: SetMemMap(%d, %d, %#2.2x, %d ns, "
-		 "%#5.5lx,  %#5.5x)\n", sock, map, mem->flags,
+		 "%#lx,  %#x)\n", sock, map, mem->flags,
 		 mem->speed, mem->static_start, mem->card_start);
 
 	/*
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/rsrc_nonstatic.c linux-2.6.11-rc2-bk4/drivers/pcmcia/rsrc_nonstatic.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/rsrc_nonstatic.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/rsrc_nonstatic.c	2005-01-26 15:43:26.512484755 +0100
@@ -186,14 +186,15 @@ static int sub_interval(struct resource_
 ======================================================================*/
 
 #ifdef CONFIG_PCMCIA_PROBE
-static void do_io_probe(struct pcmcia_socket *s, ioaddr_t base, ioaddr_t num)
+static void do_io_probe(struct pcmcia_socket *s, kio_addr_t base, kio_addr_t num)
 {
     struct resource *res;
     struct socket_data *s_data = s->resource_data;
-    ioaddr_t i, j, bad, any;
+    kio_addr_t i, j, bad;
+    int any;
     u_char *b, hole, most;
 
-    printk(KERN_INFO "cs: IO port probe 0x%04x-0x%04x:",
+    printk(KERN_INFO "cs: IO port probe %#lx-%#lx:",
 	   base, base+num-1);
 
     /* First, what does a floating port look like? */
@@ -233,7 +234,7 @@ static void do_io_probe(struct pcmcia_so
 	} else {
 	    if (bad) {
 		sub_interval(&s_data->io_db, bad, i-bad);
-		printk(" %#04x-%#04x", bad, i-1);
+		printk(" %#lx-%#lx", bad, i-1);
 		bad = 0;
 	    }
 	}
@@ -244,7 +245,7 @@ static void do_io_probe(struct pcmcia_so
 	    return;
 	} else {
 	    sub_interval(&s_data->io_db, bad, i-bad);
-	    printk(" %#04x-%#04x", bad, i-1);
+	    printk(" %#lx-%#lx", bad, i-1);
 	}
     }
 
@@ -725,7 +726,8 @@ static int adjust_memory(struct pcmcia_s
 static int adjust_io(struct pcmcia_socket *s, adjust_t *adj)
 {
 	struct socket_data *data = s->resource_data;
-	int base, num, ret = CS_SUCCESS;
+	kio_addr_t base, num;
+	int ret = CS_SUCCESS;
 
 	base = adj->resource.io.BasePort;
 	num = adj->resource.io.NumPorts;
diff -purN linux-2.6.11-rc2-bk3/drivers/pcmcia/tcic.c linux-2.6.11-rc2-bk4/drivers/pcmcia/tcic.c
--- linux-2.6.11-rc2-bk3/drivers/pcmcia/tcic.c	2005-01-22 02:48:20.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/pcmcia/tcic.c	2005-01-26 15:43:26.514484443 +0100
@@ -80,7 +80,7 @@ MODULE_LICENSE("Dual MPL/GPL");
 /* Parameters that can be set with 'insmod' */
 
 /* The base port address of the TCIC-2 chip */
-static int tcic_base = TCIC_BASE;
+static unsigned long tcic_base = TCIC_BASE;
 
 /* Specify a socket number to ignore */
 static int ignore = -1;
@@ -105,7 +105,7 @@ static int poll_quick = HZ/20;
 /* CCLK external clock time, in nanoseconds.  70 ns = 14.31818 MHz */
 static int cycle_time = 70;
 
-module_param(tcic_base, int, 0444);
+module_param(tcic_base, ulong, 0444);
 module_param(ignore, int, 0444);
 module_param(do_scan, int, 0444);
 module_param(irq_mask, int, 0444);
@@ -144,26 +144,26 @@ static struct tcic_socket socket_table[2
 static u_char tcic_getb(u_char reg)
 {
     u_char val = inb(tcic_base+reg);
-    printk(KERN_DEBUG "tcic_getb(%#x) = %#x\n", tcic_base+reg, val);
+    printk(KERN_DEBUG "tcic_getb(%#lx) = %#x\n", tcic_base+reg, val);
     return val;
 }
 
 static u_short tcic_getw(u_char reg)
 {
     u_short val = inw(tcic_base+reg);
-    printk(KERN_DEBUG "tcic_getw(%#x) = %#x\n", tcic_base+reg, val);
+    printk(KERN_DEBUG "tcic_getw(%#lx) = %#x\n", tcic_base+reg, val);
     return val;
 }
 
 static void tcic_setb(u_char reg, u_char data)
 {
-    printk(KERN_DEBUG "tcic_setb(%#x, %#x)\n", tcic_base+reg, data);
+    printk(KERN_DEBUG "tcic_setb(%#lx, %#x)\n", tcic_base+reg, data);
     outb(data, tcic_base+reg);
 }
 
 static void tcic_setw(u_char reg, u_short data)
 {
-    printk(KERN_DEBUG "tcic_setw(%#x, %#x)\n", tcic_base+reg, data);
+    printk(KERN_DEBUG "tcic_setw(%#lx, %#x)\n", tcic_base+reg, data);
     outw(data, tcic_base+reg);
 }
 #else
@@ -344,10 +344,14 @@ static int __init is_active(int s)
 
     if ((sstat & TCIC_SSTAT_CD) && (pwr & TCIC_PWR_VCC(s)) &&
 	(scf1 & TCIC_SCF1_IOSTS) && (ioctl & TCIC_ICTL_ENA) &&
-	(check_region(base, num) != 0) && ((base & 0xfeef) != 0x02e8))
-	return 1;
-    else
-	return 0;
+	((base & 0xfeef) != 0x02e8)) {
+	struct resource *res = request_region(base, num, "tcic-2");
+	if (!res) /* region is busy */
+	    return 1;
+	release_region(base, num);
+    }
+
+    return 0;
 }
 
 /*======================================================================
@@ -792,7 +796,7 @@ static int tcic_set_io_map(struct pcmcia
     u_short base, len, ioctl;
     
     debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
-	  "%#4.4x-%#4.4x)\n", psock, io->map, io->flags,
+	  "%#lx-%#lx)\n", psock, io->map, io->flags,
 	  io->speed, io->start, io->stop);
     if ((io->map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||
 	(io->stop < io->start)) return -EINVAL;
@@ -829,7 +833,7 @@ static int tcic_set_mem_map(struct pcmci
     u_long base, len, mmap;
 
     debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, "
-	  "%#5.5lx-%#5.5lx, %#5.5x)\n", psock, mem->map, mem->flags,
+	  "%#lx-%#lx, %#x)\n", psock, mem->map, mem->flags,
 	  mem->speed, mem->res->start, mem->res->end, mem->card_start);
     if ((mem->map > 3) || (mem->card_start > 0x3ffffff) ||
 	(mem->res->start > 0xffffff) || (mem->res->end > 0xffffff) ||
diff -purN linux-2.6.11-rc2-bk3/drivers/scsi/aic7xxx_old.c linux-2.6.11-rc2-bk4/drivers/scsi/aic7xxx_old.c
--- linux-2.6.11-rc2-bk3/drivers/scsi/aic7xxx_old.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/scsi/aic7xxx_old.c	2005-01-26 15:43:26.532481638 +0100
@@ -224,7 +224,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/byteorder.h>
-#include <linux/version.h>
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
@@ -10564,8 +10563,7 @@ static void
 aic7xxx_panic_abort(struct aic7xxx_host *p, Scsi_Cmnd *cmd)
 {
 
-  printk("aic7xxx driver version %s/%s\n", AIC7XXX_C_VERSION,
-         UTS_RELEASE);
+  printk("aic7xxx driver version %s\n", AIC7XXX_C_VERSION);
   printk("Controller type:\n    %s\n", board_names[p->board_name_index]);
   printk("p->flags=0x%lx, p->chip=0x%x, p->features=0x%x, "
          "sequencer %s paused\n",
diff -purN linux-2.6.11-rc2-bk3/drivers/serial/serial_cs.c linux-2.6.11-rc2-bk4/drivers/serial/serial_cs.c
--- linux-2.6.11-rc2-bk3/drivers/serial/serial_cs.c	2005-01-22 02:48:02.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/serial/serial_cs.c	2005-01-26 15:43:26.535481171 +0100
@@ -289,7 +289,7 @@ static void serial_detach(dev_link_t * l
 
 /*====================================================================*/
 
-static int setup_serial(struct serial_info * info, ioaddr_t iobase, int irq)
+static int setup_serial(struct serial_info * info, kio_addr_t iobase, int irq)
 {
 	struct uart_port port;
 	int line;
@@ -351,7 +351,7 @@ next_tuple(client_handle_t handle, tuple
 
 static int simple_config(dev_link_t *link)
 {
-	static ioaddr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
+	static kio_addr_t base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };
 	static int size_table[2] = { 8, 16 };
 	client_handle_t handle = link->handle;
 	struct serial_info *info = link->priv;
@@ -366,7 +366,7 @@ static int simple_config(dev_link_t *lin
 	/* If the card is already configured, look up the port and irq */
 	i = pcmcia_get_configuration_info(handle, &config);
 	if ((i == CS_SUCCESS) && (config.Attributes & CONF_VALID_CLIENT)) {
-		ioaddr_t port = 0;
+		kio_addr_t port = 0;
 		if ((config.BasePort2 != 0) && (config.NumPorts2 == 8)) {
 			port = config.BasePort2;
 			info->slave = 1;
diff -purN linux-2.6.11-rc2-bk3/drivers/usb/core/hcd.c linux-2.6.11-rc2-bk4/drivers/usb/core/hcd.c
--- linux-2.6.11-rc2-bk3/drivers/usb/core/hcd.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/usb/core/hcd.c	2005-01-26 15:43:26.538480703 +0100
@@ -33,7 +33,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/completion.h>
-#include <linux/uts.h>			/* for UTS_SYSNAME */
+#include <linux/utsname.h>
 #include <linux/mm.h>
 #include <asm/io.h>
 #include <asm/scatterlist.h>
@@ -309,8 +309,8 @@ static int rh_string (
 
  	// id 3 == vendor description
 	} else if (id == 3) {
-                sprintf (buf, "%s %s %s", UTS_SYSNAME, UTS_RELEASE,
-			hcd->driver->description);
+                sprintf (buf, "%s %s %s",  system_utsname.sysname,
+			system_utsname.release, hcd->driver->description);
 
 	// unsupported IDs --> "protocol stall"
 	} else
diff -purN linux-2.6.11-rc2-bk3/drivers/usb/gadget/ether.c linux-2.6.11-rc2-bk4/drivers/usb/gadget/ether.c
--- linux-2.6.11-rc2-bk3/drivers/usb/gadget/ether.c	2005-01-22 02:49:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/usb/gadget/ether.c	2005-01-26 15:43:26.542480080 +0100
@@ -36,8 +36,7 @@
 #include <linux/timer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
-#include <linux/uts.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
 #include <linux/ctype.h>
@@ -2337,8 +2336,8 @@ eth_bind (struct usb_gadget *gadget)
 			gadget->name);
 		return -ENODEV;
 	}
-	snprintf (manufacturer, sizeof manufacturer,
-		UTS_SYSNAME " " UTS_RELEASE "/%s",
+	snprintf (manufacturer, sizeof manufacturer, "%s %s/%s",
+		system_utsname.sysname, system_utsname.release,
 		gadget->name);
 
 	/* If there's an RNDIS configuration, that's what Windows wants to
diff -purN linux-2.6.11-rc2-bk3/drivers/usb/gadget/file_storage.c linux-2.6.11-rc2-bk4/drivers/usb/gadget/file_storage.c
--- linux-2.6.11-rc2-bk3/drivers/usb/gadget/file_storage.c	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/usb/gadget/file_storage.c	2005-01-26 15:43:26.548479145 +0100
@@ -236,8 +236,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/suspend.h>
-#include <linux/uts.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 #include <linux/wait.h>
 
 #include <linux/usb_ch9.h>
@@ -3954,8 +3953,8 @@ static int __init fsg_bind(struct usb_ga
 	/* This should reflect the actual gadget power source */
 	usb_gadget_set_selfpowered(gadget);
 
-	snprintf(manufacturer, sizeof manufacturer,
-			UTS_SYSNAME " " UTS_RELEASE " with %s",
+	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
+			system_utsname.sysname, system_utsname.release,
 			gadget->name);
 
 	/* On a real device, serial[] would be loaded from permanent
diff -purN linux-2.6.11-rc2-bk3/drivers/usb/gadget/serial.c linux-2.6.11-rc2-bk4/drivers/usb/gadget/serial.c
--- linux-2.6.11-rc2-bk3/drivers/usb/gadget/serial.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/usb/gadget/serial.c	2005-01-26 15:43:26.552478521 +0100
@@ -30,8 +30,7 @@
 #include <linux/timer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
-#include <linux/uts.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 #include <linux/wait.h>
 #include <linux/proc_fs.h>
 #include <linux/device.h>
@@ -1596,8 +1595,9 @@ static int gs_bind(struct usb_gadget *ga
 	if (dev == NULL)
 		return -ENOMEM;
 
-	snprintf(manufacturer, sizeof(manufacturer),
-		UTS_SYSNAME " " UTS_RELEASE " with %s", gadget->name);
+	snprintf(manufacturer, sizeof(manufacturer), "%s %s with %s",
+		system_utsname.sysname, system_utsname.release,
+		gadget->name);
 
 	memset(dev, 0, sizeof(struct gs_dev));
 	dev->dev_gadget = gadget;
diff -purN linux-2.6.11-rc2-bk3/drivers/usb/gadget/zero.c linux-2.6.11-rc2-bk4/drivers/usb/gadget/zero.c
--- linux-2.6.11-rc2-bk3/drivers/usb/gadget/zero.c	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/usb/gadget/zero.c	2005-01-26 15:43:26.555478054 +0100
@@ -75,8 +75,7 @@
 #include <linux/timer.h>
 #include <linux/list.h>
 #include <linux/interrupt.h>
-#include <linux/uts.h>
-#include <linux/version.h>
+#include <linux/utsname.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
 
@@ -1265,8 +1264,8 @@ autoconf_fail:
 	INFO (dev, "using %s, OUT %s IN %s\n", gadget->name,
 		EP_OUT_NAME, EP_IN_NAME);
 
-	snprintf (manufacturer, sizeof manufacturer,
-		UTS_SYSNAME " " UTS_RELEASE " with %s",
+	snprintf (manufacturer, sizeof manufacturer, "%s %s with %s",
+		system_utsname.sysname, system_utsname.release,
 		gadget->name);
 
 	return 0;
diff -purN linux-2.6.11-rc2-bk3/drivers/video/Kconfig linux-2.6.11-rc2-bk4/drivers/video/Kconfig
--- linux-2.6.11-rc2-bk3/drivers/video/Kconfig	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/Kconfig	2005-01-26 15:43:26.558477586 +0100
@@ -574,7 +574,7 @@ config FB_MATROX_MYSTIQUE
 	  packed pixel and 32 bpp packed pixel. You can also use font widths
 	  different from 8.
 
-config FB_MATROX_G450
+config FB_MATROX_G
 	bool "G100/G200/G400/G450/G550 support"
 	depends on FB_MATROX
 	---help---
@@ -585,10 +585,10 @@ config FB_MATROX_G450
 	  different from 8.
 
 	  If you need support for G400 secondary head, you must first say Y to
-	  "I2C support" and "I2C bit-banging support" in the character devices
-	  section, and then to "Matrox I2C support" and "G400 second head
-	  support" here in the framebuffer section. G450/G550 secondary head
-	  and digital output are supported without additional modules.
+	  "I2C support" in the character devices section, and then to
+	  "Matrox I2C support" and "G400 second head support" here in the
+	  framebuffer section. G450/G550 secondary head and digital output
+	  are supported without additional modules.
 
 	  The driver starts in monitor mode. You must use the matroxset tool 
 	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
@@ -605,26 +605,6 @@ config FB_MATROX_G450
 	  G450/G550 hardware can display TV picture only from secondary CRTC,
 	  and it performs no scaling, so picture must have 525 or 625 lines.
 
-config FB_MATROX_G100A
-	bool "G100/G200/G400 support"
-	depends on FB_MATROX && !FB_MATROX_G450
-	---help---
-	  Say Y here if you have a Matrox G100, G200 or G400 based
-	  video card. If you select "Advanced lowlevel driver options", you
-	  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed
-	  pixel and 32 bpp packed pixel. You can also use font widths
-	  different from 8.
-
-	  If you need support for G400 secondary head, you must first say Y to
-	  "I2C support" and "I2C bit-banging support" in the character devices
-	  section, and then to "Matrox I2C support" and "G400 second head
-	  support" here in the framebuffer section.
-
-config FB_MATROX_G100
-	bool
-	depends on FB_MATROX && (FB_MATROX_G450 || FB_MATROX_G100A)
-	default y
-
 config FB_MATROX_I2C
 	tristate "Matrox I2C support"
 	depends on FB_MATROX && I2C
@@ -644,7 +624,7 @@ config FB_MATROX_I2C
 
 config FB_MATROX_MAVEN
 	tristate "G400 second head support"
-	depends on FB_MATROX_G100 && FB_MATROX_I2C
+	depends on FB_MATROX_G && FB_MATROX_I2C
 	---help---
 	  WARNING !!! This support does not work with G450 !!!
 
@@ -1107,7 +1087,7 @@ if FB || SGI_NEWPORT_CONSOLE
 	source "drivers/video/logo/Kconfig"
 endif
 
-if SYSFS
+if FB && SYSFS
 	source "drivers/video/backlight/Kconfig"
 endif
 
diff -purN linux-2.6.11-rc2-bk3/drivers/video/aty/radeon_base.c linux-2.6.11-rc2-bk4/drivers/video/aty/radeon_base.c
--- linux-2.6.11-rc2-bk3/drivers/video/aty/radeon_base.c	2005-01-22 02:47:32.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/aty/radeon_base.c	2005-01-26 15:43:26.562476963 +0100
@@ -1748,6 +1748,7 @@ static int __devinit radeon_set_fbinfo (
         info->fix.type_aux = 0;
         info->fix.mmio_start = rinfo->mmio_base_phys;
         info->fix.mmio_len = RADEON_REGSIZE;
+	info->fix.accel = FB_ACCEL_ATI_RADEON;
 
 	fb_alloc_cmap(&info->cmap, 256, 0);
 
diff -purN linux-2.6.11-rc2-bk3/drivers/video/backlight/Kconfig linux-2.6.11-rc2-bk4/drivers/video/backlight/Kconfig
--- linux-2.6.11-rc2-bk3/drivers/video/backlight/Kconfig	2005-01-22 02:48:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/backlight/Kconfig	2005-01-26 15:43:26.563476807 +0100
@@ -11,6 +11,7 @@ menuconfig BACKLIGHT_LCD_SUPPORT
 config BACKLIGHT_CLASS_DEVICE
         tristate "Lowlevel Backlight controls"
 	depends on BACKLIGHT_LCD_SUPPORT
+	default m
 	help
 	  This framework adds support for low-level control of the LCD
           backlight. This includes support for brightness and power.
@@ -26,6 +27,7 @@ config BACKLIGHT_DEVICE
 config LCD_CLASS_DEVICE
         tristate "Lowlevel LCD controls"
 	depends on BACKLIGHT_LCD_SUPPORT
+	default m
 	help
 	  This framework adds support for low-level control of LCD.
 	  Some framebuffer devices connect to platform-specific LCD modules
diff -purN linux-2.6.11-rc2-bk3/drivers/video/console/fbcon.c linux-2.6.11-rc2-bk4/drivers/video/console/fbcon.c
--- linux-2.6.11-rc2-bk3/drivers/video/console/fbcon.c	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/console/fbcon.c	2005-01-26 15:43:26.567476184 +0100
@@ -2654,13 +2654,12 @@ static void fbcon_fb_blanked(struct fb_i
 		vc = vc_cons[ops->currcon].d;
 
 		if (CON_IS_VISIBLE(vc)) {
-			ops->blank_state = blank;
-
 			if (blank)
 				do_blank_screen(0);
 			else
 				do_unblank_screen(0);
 		}
+		ops->blank_state = blank;
 	}
 }
 
diff -purN linux-2.6.11-rc2-bk3/drivers/video/intelfb/intelfbhw.c linux-2.6.11-rc2-bk4/drivers/video/intelfb/intelfbhw.c
--- linux-2.6.11-rc2-bk3/drivers/video/intelfb/intelfbhw.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/intelfb/intelfbhw.c	2005-01-26 15:43:26.573475249 +0100
@@ -1207,6 +1207,22 @@ intelfbhw_program_mode(struct intelfb_in
 	OUTREG(ADPA, tmp);
 
 	/* setup display plane */
+	if (dinfo->pdev->device == PCI_DEVICE_ID_INTEL_830M) {
+		/*
+		 *      i830M errata: the display plane must be enabled
+		 *      to allow writes to the other bits in the plane
+		 *      control register.
+		 */
+		tmp = INREG(DSPACNTR);
+		if ((tmp & DISPPLANE_PLANE_ENABLE) != DISPPLANE_PLANE_ENABLE) {
+			tmp |= DISPPLANE_PLANE_ENABLE;
+			OUTREG(DSPACNTR, tmp);
+			OUTREG(DSPACNTR,
+			       hw->disp_a_ctrl|DISPPLANE_PLANE_ENABLE);
+			mdelay(1);
+              }
+	}
+
 	OUTREG(DSPACNTR, hw->disp_a_ctrl & ~DISPPLANE_PLANE_ENABLE);
 	OUTREG(DSPASTRIDE, hw->disp_a_stride);
 	OUTREG(DSPABASE, hw->disp_a_base);
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/Makefile linux-2.6.11-rc2-bk4/drivers/video/matrox/Makefile
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/Makefile	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/Makefile	2005-01-26 15:43:26.574475093 +0100
@@ -4,8 +4,7 @@
 
 # Each configuration option enables a list of files.
 
-my-obj-$(CONFIG_FB_MATROX_G100)	  += g450_pll.o
-my-obj-$(CONFIG_FB_MATROX_G450)   += matroxfb_g450.o matroxfb_crtc2.o
+my-obj-$(CONFIG_FB_MATROX_G)      += g450_pll.o matroxfb_g450.o matroxfb_crtc2.o
 
 obj-$(CONFIG_FB_MATROX)           += matroxfb_base.o matroxfb_accel.o matroxfb_DAC1064.o matroxfb_Ti3026.o matroxfb_misc.o $(my-obj-y)
 obj-$(CONFIG_FB_MATROX_I2C)       += i2c-matroxfb.o
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_DAC1064.c linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_DAC1064.c
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_DAC1064.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_DAC1064.c	2005-01-26 15:43:26.577474625 +0100
@@ -155,7 +155,7 @@ static void DAC1064_setmclk(WPMINFO int 
 	hw->MXoptionReg = mx;
 }
 
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 static void g450_set_plls(WPMINFO2) {
 	u_int32_t c2_ctl;
 	unsigned int pxc;
@@ -253,7 +253,7 @@ void DAC1064_global_init(WPMINFO2) {
 	hw->DACreg[POS1064_XMISCCTRL] &= M1064_XMISCCTRL_DAC_WIDTHMASK;
 	hw->DACreg[POS1064_XMISCCTRL] |= M1064_XMISCCTRL_LUT_EN;
 	hw->DACreg[POS1064_XPIXCLKCTRL] = M1064_XPIXCLKCTRL_PLL_UP | M1064_XPIXCLKCTRL_EN | M1064_XPIXCLKCTRL_SRC_PLL;
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 	if (ACCESS_FBINFO(devflags.g450dac)) {
 		hw->DACreg[POS1064_XPWRCTRL] = 0x1F;	/* powerup everything */
 		hw->DACreg[POS1064_XOUTPUTCONN] = 0x00;	/* disable outputs */
@@ -498,7 +498,7 @@ static struct matrox_altout m1064 = {
 	.compute = m1064_compute,
 };
 
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 static int g450_compute(void* out, struct my_timming* m) {
 #define minfo ((struct matrox_fb_info*)out)
 	if (m->mnp < 0) {
@@ -541,7 +541,7 @@ static int MGA1064_init(WPMINFO struct m
 }
 #endif
 
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 static int MGAG100_init(WPMINFO struct my_timming* m) {
 	struct matrox_hw_state* hw = &ACCESS_FBINFO(hw);
 
@@ -562,7 +562,7 @@ static int MGAG100_init(WPMINFO struct m
 	if (DAC1064_init_2(PMINFO m)) return 1;
 	return 0;
 }
-#endif	/* G100 */
+#endif	/* G */
 
 #ifdef CONFIG_FB_MATROX_MYSTIQUE
 static void MGA1064_ramdac_init(WPMINFO2) {
@@ -583,7 +583,7 @@ static void MGA1064_ramdac_init(WPMINFO2
 }
 #endif
 
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 /* BIOS environ */
 static int x7AF4 = 0x10;	/* flags, maybe 0x10 = SDRAM, 0x00 = SGRAM??? */
 				/* G100 wants 0x10, G200 SGRAM does not care... */
@@ -692,8 +692,7 @@ static void MGA1064_reset(WPMINFO2) {
 }
 #endif
 
-#ifdef CONFIG_FB_MATROX_G100
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 static void g450_mclk_init(WPMINFO2) {
 	/* switch all clocks to PCI source */
 	pci_write_config_dword(ACCESS_FBINFO(pcidev), PCI_OPTION_REG, ACCESS_FBINFO(hw).MXoptionReg | 4);
@@ -811,10 +810,6 @@ static void g450_preinit(WPMINFO2) {
 	
 	return;
 }
-#else
-static inline void g450_preinit(WPMINFO2) {
-}
-#endif
 
 static int MGAG100_preinit(WPMINFO2) {
 	static const int vxres_g100[] = {  512,        640, 768,  800,  832,  960,
@@ -851,7 +846,7 @@ static int MGAG100_preinit(WPMINFO2) {
 	ACCESS_FBINFO(capable.plnwt) = ACCESS_FBINFO(devflags.accelerator) == FB_ACCEL_MATROX_MGAG100
 			? ACCESS_FBINFO(devflags.sgram) : 1;
 
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 	if (ACCESS_FBINFO(devflags.g450dac)) {
 		ACCESS_FBINFO(outputs[0]).output = &g450out;
 	} else
@@ -1043,7 +1038,7 @@ static void MGA1064_restore(WPMINFO2) {
 }
 #endif
 
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 static void MGAG100_restore(WPMINFO2) {
 	int i;
 	struct matrox_hw_state* hw = &ACCESS_FBINFO(hw);
@@ -1077,7 +1072,7 @@ struct matrox_switch matrox_mystique = {
 EXPORT_SYMBOL(matrox_mystique);
 #endif
 
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 struct matrox_switch matrox_G100 = {
 	MGAG100_preinit, MGAG100_reset, MGAG100_init, MGAG100_restore,
 };
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_DAC1064.h linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_DAC1064.h
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_DAC1064.h	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_DAC1064.h	2005-01-26 15:43:26.578474469 +0100
@@ -9,7 +9,7 @@
 #ifdef CONFIG_FB_MATROX_MYSTIQUE
 extern struct matrox_switch matrox_mystique;
 #endif
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 extern struct matrox_switch matrox_G100;
 #endif
 #ifdef NEED_DAC1064
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_base.c linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_base.c
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_base.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_base.c	2005-01-26 15:43:26.582473846 +0100
@@ -1346,7 +1346,7 @@ static struct video_board vbMillennium2A
 #ifdef CONFIG_FB_MATROX_MYSTIQUE
 static struct video_board vbMystique		= {0x0800000, 0x0800000, FB_ACCEL_MATROX_MGA1064SG,	&matrox_mystique};
 #endif	/* CONFIG_FB_MATROX_MYSTIQUE */
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 static struct video_board vbG100		= {0x0800000, 0x0800000, FB_ACCEL_MATROX_MGAG100,	&matrox_G100};
 static struct video_board vbG200		= {0x1000000, 0x1000000, FB_ACCEL_MATROX_MGAG200,	&matrox_G100};
 #ifdef CONFIG_FB_MATROX_32MB
@@ -1430,7 +1430,7 @@ static struct board {
 		&vbMystique,
 		"Mystique 220 (PCI)"},
 #endif
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 	{PCI_VENDOR_ID_MATROX,	PCI_DEVICE_ID_MATROX_G100_MM,	0xFF,
 		0,			0,
 		DEVF_G100,
@@ -2105,7 +2105,7 @@ static struct pci_device_id matroxfb_dev
 	{PCI_VENDOR_ID_MATROX,	PCI_DEVICE_ID_MATROX_MYS,
 		PCI_ANY_ID,	PCI_ANY_ID,	0, 0, 0},
 #endif
-#ifdef CONFIG_FB_MATROX_G100
+#ifdef CONFIG_FB_MATROX_G
 	{PCI_VENDOR_ID_MATROX,	PCI_DEVICE_ID_MATROX_G100_MM,
 		PCI_ANY_ID,	PCI_ANY_ID,	0, 0, 0},
 	{PCI_VENDOR_ID_MATROX,	PCI_DEVICE_ID_MATROX_G100_AGP,
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_base.h linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_base.h
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_base.h	2005-01-22 02:48:03.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_base.h	2005-01-26 15:43:26.584473534 +0100
@@ -127,7 +127,7 @@
 
 /* G-series and Mystique have (almost) same DAC */
 #undef NEED_DAC1064
-#if defined(CONFIG_FB_MATROX_MYSTIQUE) || defined(CONFIG_FB_MATROX_G100)
+#if defined(CONFIG_FB_MATROX_MYSTIQUE) || defined(CONFIG_FB_MATROX_G)
 #define NEED_DAC1064 1
 #endif
 
diff -purN linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_g450.h linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_g450.h
--- linux-2.6.11-rc2-bk3/drivers/video/matrox/matroxfb_g450.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/matrox/matroxfb_g450.h	2005-01-26 15:43:26.585473379 +0100
@@ -3,7 +3,7 @@
 
 #include "matroxfb_base.h"
 
-#ifdef CONFIG_FB_MATROX_G450
+#ifdef CONFIG_FB_MATROX_G
 void matroxfb_g450_connect(WPMINFO2);
 void matroxfb_g450_shutdown(WPMINFO2);
 #else
diff -purN linux-2.6.11-rc2-bk3/drivers/video/vesafb.c linux-2.6.11-rc2-bk4/drivers/video/vesafb.c
--- linux-2.6.11-rc2-bk3/drivers/video/vesafb.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/drivers/video/vesafb.c	2005-01-26 15:43:26.586473223 +0100
@@ -229,7 +229,7 @@ static int __init vesafb_probe(struct de
 	unsigned int size_total;
 
 	if (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)
-		return -ENXIO;
+		return -ENODEV;
 
 	vesafb_fix.smem_start = screen_info.lfb_base;
 	vesafb_defined.bits_per_pixel = screen_info.lfb_depth;
@@ -407,7 +407,7 @@ static int __init vesafb_probe(struct de
 		(ypan) ? FBINFO_HWACCEL_YPAN : 0;
 
 	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
-		err = -ENXIO;
+		err = -ENOMEM;
 		goto err;
 	}
 	if (register_framebuffer(info)<0) {
diff -purN linux-2.6.11-rc2-bk3/fs/cifs/connect.c linux-2.6.11-rc2-bk4/fs/cifs/connect.c
--- linux-2.6.11-rc2-bk3/fs/cifs/connect.c	2005-01-22 02:48:57.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/cifs/connect.c	2005-01-26 15:43:26.596471664 +0100
@@ -23,7 +23,6 @@
 #include <linux/string.h>
 #include <linux/list.h>
 #include <linux/wait.h>
-#include <linux/version.h>
 #include <linux/ipv6.h>
 #include <linux/pagemap.h>
 #include <linux/ctype.h>
@@ -1647,7 +1646,7 @@ CIFSSessSetup(unsigned int xid, struct c
 				  32, nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bytes_returned =
-		    cifs_strtoUCS((wchar_t *) bcc_ptr, UTS_RELEASE, 32,
+		    cifs_strtoUCS((wchar_t *) bcc_ptr, system_utsname.release, 32,
 				  nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bcc_ptr += 2;
@@ -1674,8 +1673,8 @@ CIFSSessSetup(unsigned int xid, struct c
 		}
 		strcpy(bcc_ptr, "Linux version ");
 		bcc_ptr += strlen("Linux version ");
-		strcpy(bcc_ptr, UTS_RELEASE);
-		bcc_ptr += strlen(UTS_RELEASE) + 1;
+		strcpy(bcc_ptr, system_utsname.release);
+		bcc_ptr += strlen(system_utsname.release) + 1;
 		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
 		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
 	}
@@ -1891,7 +1890,7 @@ CIFSSpnegoSessSetup(unsigned int xid, st
 				  32, nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bytes_returned =
-		    cifs_strtoUCS((wchar_t *) bcc_ptr, UTS_RELEASE, 32,
+		    cifs_strtoUCS((wchar_t *) bcc_ptr, system_utsname.release, 32,
 				  nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bcc_ptr += 2;
@@ -1916,8 +1915,8 @@ CIFSSpnegoSessSetup(unsigned int xid, st
 		}
 		strcpy(bcc_ptr, "Linux version ");
 		bcc_ptr += strlen("Linux version ");
-		strcpy(bcc_ptr, UTS_RELEASE);
-		bcc_ptr += strlen(UTS_RELEASE) + 1;
+		strcpy(bcc_ptr, system_utsname.release);
+		bcc_ptr += strlen(system_utsname.release) + 1;
 		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
 		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
 	}
@@ -2180,7 +2179,7 @@ CIFSNTLMSSPNegotiateSessSetup(unsigned i
 				  32, nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bytes_returned =
-		    cifs_strtoUCS((wchar_t *) bcc_ptr, UTS_RELEASE, 32,
+		    cifs_strtoUCS((wchar_t *) bcc_ptr, system_utsname.release, 32,
 				  nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bcc_ptr += 2;	/* null terminate Linux version */
@@ -2197,8 +2196,8 @@ CIFSNTLMSSPNegotiateSessSetup(unsigned i
 	} else {		/* ASCII */
 		strcpy(bcc_ptr, "Linux version ");
 		bcc_ptr += strlen("Linux version ");
-		strcpy(bcc_ptr, UTS_RELEASE);
-		bcc_ptr += strlen(UTS_RELEASE) + 1;
+		strcpy(bcc_ptr, system_utsname.release);
+		bcc_ptr += strlen(system_utsname.release) + 1;
 		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
 		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
 		bcc_ptr++;	/* empty domain field */
@@ -2565,7 +2564,7 @@ CIFSNTLMSSPAuthSessSetup(unsigned int xi
 				  32, nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bytes_returned =
-		    cifs_strtoUCS((wchar_t *) bcc_ptr, UTS_RELEASE, 32,
+		    cifs_strtoUCS((wchar_t *) bcc_ptr, system_utsname.release, 32,
 				  nls_codepage);
 		bcc_ptr += 2 * bytes_returned;
 		bcc_ptr += 2;	/* null term version string */
@@ -2617,8 +2616,8 @@ CIFSNTLMSSPAuthSessSetup(unsigned int xi
 
 		strcpy(bcc_ptr, "Linux version ");
 		bcc_ptr += strlen("Linux version ");
-		strcpy(bcc_ptr, UTS_RELEASE);
-		bcc_ptr += strlen(UTS_RELEASE) + 1;
+		strcpy(bcc_ptr, system_utsname.release);
+		bcc_ptr += strlen(system_utsname.release) + 1;
 		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
 		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
 		bcc_ptr++;	/* null domain */
diff -purN linux-2.6.11-rc2-bk3/fs/compat.c linux-2.6.11-rc2-bk4/fs/compat.c
--- linux-2.6.11-rc2-bk3/fs/compat.c	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/compat.c	2005-01-26 15:43:26.600471041 +0100
@@ -439,6 +439,11 @@ asmlinkage long compat_sys_ioctl(unsigne
 	if (!filp)
 		goto out;
 
+	/* RED-PEN how should LSM module know it's handling 32bit? */
+	error = security_file_ioctl(filp, cmd, arg);
+	if (error)
+		goto out_fput;
+
 	/*
 	 * To allow the compat_ioctl handlers to be self contained
 	 * we need to check the common ioctls here first.
@@ -496,11 +501,6 @@ asmlinkage long compat_sys_ioctl(unsigne
 
  found_handler:
 	if (t->handler) {
-		/* RED-PEN how should LSM module know it's handling 32bit? */
-		error = security_file_ioctl(filp, cmd, arg);
-		if (error)
-			goto out_fput;
-
 		lock_kernel();
 		error = t->handler(fd, cmd, arg, filp);
 		unlock_kernel();
@@ -510,7 +510,7 @@ asmlinkage long compat_sys_ioctl(unsigne
 
 	up_read(&ioctl32_sem);
  do_ioctl:
-	error = sys_ioctl(fd, cmd, arg);
+	error = vfs_ioctl(filp, fd, cmd, arg);
  out_fput:
 	fput_light(filp, fput_needed);
  out:
@@ -1126,7 +1126,6 @@ static ssize_t compat_do_readv_writev(in
 	int seg;
 	io_fn_t fn;
 	iov_fn_t fnv;
-	struct inode *inode;
 
 	/*
 	 * SuS says "The readv() function *may* fail if the iovcnt argument
@@ -1191,11 +1190,7 @@ static ssize_t compat_do_readv_writev(in
 		goto out;
 	}
 
-	inode = file->f_dentry->d_inode;
-	/* VERIFY_WRITE actually means a read, as we write to user space */
-	ret = locks_verify_area((type == READ
-				 ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE),
-				inode, file, *pos, tot_len);
+	ret = rw_verify_area(type, file, pos, tot_len);
 	if (ret)
 		goto out;
 
diff -purN linux-2.6.11-rc2-bk3/fs/ext2/acl.c linux-2.6.11-rc2-bk4/fs/ext2/acl.c
--- linux-2.6.11-rc2-bk3/fs/ext2/acl.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext2/acl.c	2005-01-26 15:43:26.607469950 +0100
@@ -255,8 +255,6 @@ ext2_set_acl(struct inode *inode, int ty
 			return -EINVAL;
 	}
  	if (acl) {
-		if (acl->a_count > EXT2_ACL_MAX_ENTRIES)
-			return -EINVAL;
 		value = ext2_acl_to_disk(acl, &size);
 		if (IS_ERR(value))
 			return (int)PTR_ERR(value);
diff -purN linux-2.6.11-rc2-bk3/fs/ext2/acl.h linux-2.6.11-rc2-bk4/fs/ext2/acl.h
--- linux-2.6.11-rc2-bk3/fs/ext2/acl.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext2/acl.h	2005-01-26 15:43:26.608469794 +0100
@@ -7,7 +7,6 @@
 #include <linux/xattr_acl.h>
 
 #define EXT2_ACL_VERSION	0x0001
-#define EXT2_ACL_MAX_ENTRIES	32
 
 typedef struct {
 	__le16		e_tag;
diff -purN linux-2.6.11-rc2-bk3/fs/ext2/balloc.c linux-2.6.11-rc2-bk4/fs/ext2/balloc.c
--- linux-2.6.11-rc2-bk3/fs/ext2/balloc.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext2/balloc.c	2005-01-26 15:43:26.610469483 +0100
@@ -6,7 +6,7 @@
  * Laboratoire MASI - Institut Blaise Pascal
  * Universite Pierre et Marie Curie (Paris VI)
  *
- *  Enhanced block allocation by Stephen Tweedie (sct@dcs.ed.ac.uk), 1993
+ *  Enhanced block allocation by Stephen Tweedie (sct@redhat.com), 1993
  *  Big-endian to little-endian byte-swapping/bitmaps by
  *        David S. Miller (davem@caip.rutgers.edu), 1995
  */
@@ -52,9 +52,9 @@ struct ext2_group_desc * ext2_get_group_
 
 		return NULL;
 	}
-	
-	group_desc = block_group / EXT2_DESC_PER_BLOCK(sb);
-	offset = block_group % EXT2_DESC_PER_BLOCK(sb);
+
+	group_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);
+	offset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);
 	if (!sbi->s_group_desc[group_desc]) {
 		ext2_error (sb, "ext2_get_group_desc",
 			    "Group descriptor not loaded - "
@@ -62,7 +62,7 @@ struct ext2_group_desc * ext2_get_group_
 			     block_group, group_desc, offset);
 		return NULL;
 	}
-	
+
 	desc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;
 	if (bh)
 		*bh = sbi->s_group_desc[group_desc];
@@ -236,12 +236,12 @@ do_more:
 
 	for (i = 0, group_freed = 0; i < count; i++) {
 		if (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),
-					bit + i, (void *) bitmap_bh->b_data))
-			ext2_error (sb, "ext2_free_blocks",
-				      "bit already cleared for block %lu",
-				      block + i);
-		else
+						bit + i, bitmap_bh->b_data)) {
+			ext2_error(sb, __FUNCTION__,
+				"bit already cleared for block %lu", block + i);
+		} else {
 			group_freed++;
+		}
 	}
 
 	mark_buffer_dirty(bitmap_bh);
@@ -569,25 +569,24 @@ unsigned long ext2_count_free_blocks (st
 static inline int
 block_in_use(unsigned long block, struct super_block *sb, unsigned char *map)
 {
-	return ext2_test_bit ((block - le32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block)) %
+	return ext2_test_bit ((block -
+		le32_to_cpu(EXT2_SB(sb)->s_es->s_first_data_block)) %
 			 EXT2_BLOCKS_PER_GROUP(sb), map);
 }
 
 static inline int test_root(int a, int b)
 {
-	if (a == 0)
-		return 1;
-	while (1) {
-		if (a == 1)
-			return 1;
-		if (a % b)
-			return 0;
-		a = a / b;
-	}
+	int num = b;
+
+	while (a > num)
+		num *= b;
+	return num == a;
 }
 
 static int ext2_group_sparse(int group)
 {
+	if (group <= 1)
+		return 1;
 	return (test_root(group, 3) || test_root(group, 5) ||
 		test_root(group, 7));
 }
diff -purN linux-2.6.11-rc2-bk3/fs/ext2/inode.c linux-2.6.11-rc2-bk4/fs/ext2/inode.c
--- linux-2.6.11-rc2-bk3/fs/ext2/inode.c	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext2/inode.c	2005-01-26 15:43:26.612469171 +0100
@@ -354,7 +354,7 @@ static inline int ext2_find_goal(struct 
 {
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	write_lock(&ei->i_meta_lock);
-	if (block == ei->i_next_alloc_block + 1) {
+	if ((block == ei->i_next_alloc_block + 1) && ei->i_next_alloc_goal) {
 		ei->i_next_alloc_block++;
 		ei->i_next_alloc_goal++;
 	} 
diff -purN linux-2.6.11-rc2-bk3/fs/ext3/acl.c linux-2.6.11-rc2-bk4/fs/ext3/acl.c
--- linux-2.6.11-rc2-bk3/fs/ext3/acl.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext3/acl.c	2005-01-26 15:43:26.613469015 +0100
@@ -259,8 +259,6 @@ ext3_set_acl(handle_t *handle, struct in
 			return -EINVAL;
 	}
  	if (acl) {
-		if (acl->a_count > EXT3_ACL_MAX_ENTRIES)
-			return -EINVAL;
 		value = ext3_acl_to_disk(acl, &size);
 		if (IS_ERR(value))
 			return (int)PTR_ERR(value);
diff -purN linux-2.6.11-rc2-bk3/fs/ext3/acl.h linux-2.6.11-rc2-bk4/fs/ext3/acl.h
--- linux-2.6.11-rc2-bk3/fs/ext3/acl.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext3/acl.h	2005-01-26 15:43:26.614468859 +0100
@@ -7,7 +7,6 @@
 #include <linux/xattr_acl.h>
 
 #define EXT3_ACL_VERSION	0x0001
-#define EXT3_ACL_MAX_ENTRIES	32
 
 typedef struct {
 	__le16		e_tag;
diff -purN linux-2.6.11-rc2-bk3/fs/ext3/inode.c linux-2.6.11-rc2-bk4/fs/ext3/inode.c
--- linux-2.6.11-rc2-bk3/fs/ext3/inode.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext3/inode.c	2005-01-26 15:43:26.619468080 +0100
@@ -464,7 +464,7 @@ static int ext3_find_goal(struct inode *
 {
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	/* Writer: ->i_next_alloc* */
-	if (block == ei->i_next_alloc_block + 1) {
+	if ((block == ei->i_next_alloc_block + 1)&& ei->i_next_alloc_goal) {
 		ei->i_next_alloc_block++;
 		ei->i_next_alloc_goal++;
 	}
@@ -2493,15 +2493,30 @@ void ext3_read_inode(struct inode * inod
 		ei->i_data[block] = raw_inode->i_block[block];
 	INIT_LIST_HEAD(&ei->i_orphan);
 
-	ei->i_extra_isize =
-		(EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) ?
-		le16_to_cpu(raw_inode->i_extra_isize) : 0;
-	if (ei->i_extra_isize) {
-		__le32 *magic = (void *)raw_inode + EXT3_GOOD_OLD_INODE_SIZE +
-				ei->i_extra_isize;
-		if (le32_to_cpu(*magic))
-			 ei->i_state |= EXT3_STATE_XATTR;
-	}
+	if (inode->i_ino >= EXT3_FIRST_INO(inode->i_sb) + 1 &&
+	    EXT3_INODE_SIZE(inode->i_sb) > EXT3_GOOD_OLD_INODE_SIZE) {
+		/*
+		 * When mke2fs creates big inodes it does not zero out
+		 * the unused bytes above EXT3_GOOD_OLD_INODE_SIZE,
+		 * so ignore those first few inodes.
+		 */
+		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);
+		if (EXT3_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >
+		    EXT3_INODE_SIZE(inode->i_sb))
+			goto bad_inode;
+		if (ei->i_extra_isize == 0) {
+			/* The extra space is currently unused. Use it. */
+			ei->i_extra_isize = sizeof(struct ext3_inode) -
+					    EXT3_GOOD_OLD_INODE_SIZE;
+		} else {
+			__le32 *magic = (void *)raw_inode +
+					EXT3_GOOD_OLD_INODE_SIZE +
+					ei->i_extra_isize;
+			if (*magic == cpu_to_le32(EXT3_XATTR_MAGIC))
+				 ei->i_state |= EXT3_STATE_XATTR;
+		}
+	} else
+		ei->i_extra_isize = 0;
 
 	if (S_ISREG(inode->i_mode)) {
 		inode->i_op = &ext3_file_inode_operations;
diff -purN linux-2.6.11-rc2-bk3/fs/ext3/xattr.c linux-2.6.11-rc2-bk4/fs/ext3/xattr.c
--- linux-2.6.11-rc2-bk3/fs/ext3/xattr.c	2005-01-22 02:48:21.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ext3/xattr.c	2005-01-26 15:43:26.623467457 +0100
@@ -37,9 +37,9 @@
  *   | value 2          | |
  *   +------------------+
  *
- * The header is followed by multiple entry descriptors. Descriptors are
- * kept sorted. The attribute values are aligned to the end of the block
- * in no specific order.
+ * The header is followed by multiple entry descriptors. In disk blocks, the
+ * entry descriptors are kept sorted. In inodes, they are unsorted. The
+ * attribute values are aligned to the end of the block in no specific order.
  *
  * Locking strategy
  * ----------------
@@ -272,8 +272,7 @@ ext3_xattr_ibody_get(struct inode *inode
 	void *end;
 	int error;
 
-	if (EXT3_SB(inode->i_sb)->s_inode_size <= EXT3_GOOD_OLD_INODE_SIZE ||
-	    !(EXT3_I(inode)->i_state & EXT3_STATE_XATTR))
+	if (!(EXT3_I(inode)->i_state & EXT3_STATE_XATTR))
 		return -ENODATA;
 	error = ext3_get_inode_loc(inode, &iloc);
 	if (error)
@@ -399,8 +398,7 @@ ext3_xattr_ibody_list(struct inode *inod
 	void *end;
 	int error;
 
-	if (EXT3_SB(inode->i_sb)->s_inode_size <= EXT3_GOOD_OLD_INODE_SIZE ||
-	    !(EXT3_I(inode)->i_state & EXT3_STATE_XATTR))
+	if (!(EXT3_I(inode)->i_state & EXT3_STATE_XATTR))
 		return 0;
 	error = ext3_get_inode_loc(inode, &iloc);
 	if (error)
@@ -823,7 +821,6 @@ getblk_failed:
 			error = ext3_journal_dirty_metadata(handle, new_bh);
 			if (error)
 				goto cleanup;
-			ext3_xattr_update_super_block(handle, sb);
 		}
 	}
 
@@ -866,7 +863,7 @@ ext3_xattr_ibody_find(struct inode *inod
 	struct ext3_inode *raw_inode;
 	int error;
 
-	if (EXT3_SB(inode->i_sb)->s_inode_size <= EXT3_GOOD_OLD_INODE_SIZE)
+	if (EXT3_I(inode)->i_extra_isize == 0)
 		return 0;
 	raw_inode = ext3_raw_inode(&is->iloc);
 	header = IHDR(inode, raw_inode);
@@ -897,7 +894,7 @@ ext3_xattr_ibody_set(handle_t *handle, s
 	struct ext3_xattr_search *s = &is->s;
 	int error;
 
-	if (EXT3_SB(inode->i_sb)->s_inode_size <= EXT3_GOOD_OLD_INODE_SIZE)
+	if (EXT3_I(inode)->i_extra_isize == 0)
 		return -ENOSPC;
 	error = ext3_xattr_set_entry(i, s);
 	if (error)
@@ -957,6 +954,13 @@ ext3_xattr_set_handle(handle_t *handle, 
 	error = ext3_get_inode_loc(inode, &is.iloc);
 	if (error)
 		goto cleanup;
+
+	if (EXT3_I(inode)->i_state & EXT3_STATE_NEW) {
+		struct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);
+		memset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);
+		EXT3_I(inode)->i_state &= ~EXT3_STATE_NEW;
+	}
+
 	error = ext3_xattr_ibody_find(inode, &i, &is);
 	if (error)
 		goto cleanup;
@@ -1001,6 +1005,7 @@ ext3_xattr_set_handle(handle_t *handle, 
 		}
 	}
 	if (!error) {
+		ext3_xattr_update_super_block(handle, inode->i_sb);
 		inode->i_ctime = CURRENT_TIME_SEC;
 		error = ext3_mark_iloc_dirty(handle, inode, &is.iloc);
 		/*
@@ -1066,7 +1071,6 @@ ext3_xattr_delete_inode(handle_t *handle
 {
 	struct buffer_head *bh = NULL;
 
-	down_write(&EXT3_I(inode)->xattr_sem);
 	if (!EXT3_I(inode)->i_file_acl)
 		goto cleanup;
 	bh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);
@@ -1088,7 +1092,6 @@ ext3_xattr_delete_inode(handle_t *handle
 
 cleanup:
 	brelse(bh);
-	up_write(&EXT3_I(inode)->xattr_sem);
 }
 
 /*
diff -purN linux-2.6.11-rc2-bk3/fs/file_table.c linux-2.6.11-rc2-bk4/fs/file_table.c
--- linux-2.6.11-rc2-bk3/fs/file_table.c	2005-01-22 02:46:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/file_table.c	2005-01-26 15:43:26.624467301 +0100
@@ -85,6 +85,7 @@ static int old_max;
 			rwlock_init(&f->f_owner.lock);
 			/* f->f_version: 0 */
 			INIT_LIST_HEAD(&f->f_list);
+			f->f_maxcount = INT_MAX;
 			return f;
 		}
 	}
diff -purN linux-2.6.11-rc2-bk3/fs/ioctl.c linux-2.6.11-rc2-bk4/fs/ioctl.c
--- linux-2.6.11-rc2-bk3/fs/ioctl.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ioctl.c	2005-01-26 15:43:26.625467145 +0100
@@ -77,25 +77,17 @@ static int file_ioctl(struct file *filp,
 	return do_ioctl(filp, cmd, arg);
 }
 
-
 /*
  * When you add any new common ioctls to the switches above and below
  * please update compat_sys_ioctl() too.
+ *
+ * vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()'d.
+ * It's just a simple helper for sys_ioctl and compat_sys_ioctl.
  */
-asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+int vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd, unsigned long arg)
 {
-	struct file * filp;
 	unsigned int flag;
-	int on, error = -EBADF;
-	int fput_needed;
-
-	filp = fget_light(fd, &fput_needed);
-	if (!filp)
-		goto out;
-
-	error = security_file_ioctl(filp, cmd, arg);
-	if (error)
-		goto out_fput;
+	int on, error = 0;
 
 	switch (cmd) {
 		case FIOCLEX:
@@ -161,6 +153,24 @@ asmlinkage long sys_ioctl(unsigned int f
 				error = do_ioctl(filp, cmd, arg);
 			break;
 	}
+	return error;
+}
+
+asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	struct file * filp;
+	int error = -EBADF;
+	int fput_needed;
+
+	filp = fget_light(fd, &fput_needed);
+	if (!filp)
+		goto out;
+
+	error = security_file_ioctl(filp, cmd, arg);
+	if (error)
+		goto out_fput;
+
+	error = vfs_ioctl(filp, fd, cmd, arg);
  out_fput:
 	fput_light(filp, fput_needed);
  out:
diff -purN linux-2.6.11-rc2-bk3/fs/locks.c linux-2.6.11-rc2-bk4/fs/locks.c
--- linux-2.6.11-rc2-bk3/fs/locks.c	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/locks.c	2005-01-26 15:43:26.628466677 +0100
@@ -1011,7 +1011,7 @@ int locks_mandatory_locked(struct inode 
  * @count:      length of area to check
  *
  * Searches the inode's list of locks to find any POSIX locks which conflict.
- * This function is called from locks_verify_area() and
+ * This function is called from rw_verify_area() and
  * locks_verify_truncate().
  */
 int locks_mandatory_area(int read_write, struct inode *inode,
diff -purN linux-2.6.11-rc2-bk3/fs/mbcache.c linux-2.6.11-rc2-bk4/fs/mbcache.c
--- linux-2.6.11-rc2-bk3/fs/mbcache.c	2005-01-22 02:49:12.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/mbcache.c	2005-01-26 15:43:26.629466522 +0100
@@ -554,8 +554,6 @@ static struct mb_cache_entry *
 __mb_cache_entry_find(struct list_head *l, struct list_head *head,
 		      int index, struct block_device *bdev, unsigned int key)
 {
-	DEFINE_WAIT(wait);
-
 	while (l != head) {
 		struct mb_cache_entry *ce =
 			list_entry(l, struct mb_cache_entry,
diff -purN linux-2.6.11-rc2-bk3/fs/ntfs/ChangeLog linux-2.6.11-rc2-bk4/fs/ntfs/ChangeLog
--- linux-2.6.11-rc2-bk3/fs/ntfs/ChangeLog	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ntfs/ChangeLog	2005-01-26 15:43:26.633465898 +0100
@@ -25,6 +25,13 @@ ToDo/Notes:
 	- Enable the code for setting the NT4 compatibility flag when we start
 	  making NTFS 1.2 specific modifications.
 
+2.1.23-WIP
+
+	- Add printk rate limiting for ntfs_warning() and ntfs_error() when
+	  compiled without debug.  This avoids a possible denial of service
+	  attack.  Thanks to Carl-Daniel Hailfinger from SuSE for pointing this
+	  out.
+
 2.1.22 - Many bug and race fixes and error handling improvements.
 
 	- Improve error handling in fs/ntfs/inode.c::ntfs_truncate().
diff -purN linux-2.6.11-rc2-bk3/fs/ntfs/debug.c linux-2.6.11-rc2-bk4/fs/ntfs/debug.c
--- linux-2.6.11-rc2-bk3/fs/ntfs/debug.c	2005-01-22 02:49:20.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/ntfs/debug.c	2005-01-26 15:43:26.634465742 +0100
@@ -53,6 +53,10 @@ void __ntfs_warning(const char *function
 	va_list args;
 	int flen = 0;
 
+#ifndef DEBUG
+	if (!printk_ratelimit())
+		return;
+#endif
 	if (function)
 		flen = strlen(function);
 	spin_lock(&err_buf_lock);
@@ -93,6 +97,10 @@ void __ntfs_error(const char *function, 
 	va_list args;
 	int flen = 0;
 
+#ifndef DEBUG
+	if (!printk_ratelimit())
+		return;
+#endif
 	if (function)
 		flen = strlen(function);
 	spin_lock(&err_buf_lock);
diff -purN linux-2.6.11-rc2-bk3/fs/read_write.c linux-2.6.11-rc2-bk4/fs/read_write.c
--- linux-2.6.11-rc2-bk3/fs/read_write.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/fs/read_write.c	2005-01-26 15:43:26.638465119 +0100
@@ -182,6 +182,20 @@ bad:
 }
 #endif
 
+
+int rw_verify_area(int read_write, struct file *file, loff_t *ppos, size_t count)
+{
+	struct inode *inode;
+
+	if (count > file->f_maxcount)
+		return -EINVAL;
+
+	inode = file->f_dentry->d_inode;
+	if (inode->i_flock && MANDATORY_LOCK(inode))
+		return locks_mandatory_area(read_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE, inode, file, *ppos, count);
+	return 0;
+}
+
 ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
 {
 	struct kiocb kiocb;
@@ -200,7 +214,6 @@ EXPORT_SYMBOL(do_sync_read);
 
 ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
 {
-	struct inode *inode = file->f_dentry->d_inode;
 	ssize_t ret;
 
 	if (!(file->f_mode & FMODE_READ))
@@ -208,7 +221,7 @@ ssize_t vfs_read(struct file *file, char
 	if (!file->f_op || (!file->f_op->read && !file->f_op->aio_read))
 		return -EINVAL;
 
-	ret = locks_verify_area(FLOCK_VERIFY_READ, inode, file, *pos, count);
+	ret = rw_verify_area(READ, file, pos, count);
 	if (!ret) {
 		ret = security_file_permission (file, MAY_READ);
 		if (!ret) {
@@ -247,7 +260,6 @@ EXPORT_SYMBOL(do_sync_write);
 
 ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
 {
-	struct inode *inode = file->f_dentry->d_inode;
 	ssize_t ret;
 
 	if (!(file->f_mode & FMODE_WRITE))
@@ -255,7 +267,7 @@ ssize_t vfs_write(struct file *file, con
 	if (!file->f_op || (!file->f_op->write && !file->f_op->aio_write))
 		return -EINVAL;
 
-	ret = locks_verify_area(FLOCK_VERIFY_WRITE, inode, file, *pos, count);
+	ret = rw_verify_area(WRITE, file, pos, count);
 	if (!ret) {
 		ret = security_file_permission (file, MAY_WRITE);
 		if (!ret) {
@@ -399,7 +411,6 @@ static ssize_t do_readv_writev(int type,
 	int seg;
 	io_fn_t fn;
 	iov_fn_t fnv;
-	struct inode *inode;
 
 	/*
 	 * SuS says "The readv() function *may* fail if the iovcnt argument
@@ -452,11 +463,7 @@ static ssize_t do_readv_writev(int type,
 		goto out;
 	}
 
-	inode = file->f_dentry->d_inode;
-	/* VERIFY_WRITE actually means a read, as we write to user space */
-	ret = locks_verify_area((type == READ 
-				 ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE),
-				inode, file, *pos, tot_len);
+	ret = rw_verify_area(type, file, pos, tot_len);
 	if (ret)
 		goto out;
 
@@ -603,7 +610,7 @@ static ssize_t do_sendfile(int out_fd, i
 	else
 		if (!(in_file->f_mode & FMODE_PREAD))
 			goto fput_in;
-	retval = locks_verify_area(FLOCK_VERIFY_READ, in_inode, in_file, *ppos, count);
+	retval = rw_verify_area(READ, in_file, ppos, count);
 	if (retval)
 		goto fput_in;
 
@@ -624,7 +631,7 @@ static ssize_t do_sendfile(int out_fd, i
 	if (!out_file->f_op || !out_file->f_op->sendpage)
 		goto fput_out;
 	out_inode = out_file->f_dentry->d_inode;
-	retval = locks_verify_area(FLOCK_VERIFY_WRITE, out_inode, out_file, out_file->f_pos, count);
+	retval = rw_verify_area(WRITE, out_file, &out_file->f_pos, count);
 	if (retval)
 		goto fput_out;
 
diff -purN linux-2.6.11-rc2-bk3/include/asm-h8300/bitops.h linux-2.6.11-rc2-bk4/include/asm-h8300/bitops.h
--- linux-2.6.11-rc2-bk3/include/asm-h8300/bitops.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-h8300/bitops.h	2005-01-26 15:43:26.661461535 +0100
@@ -196,7 +196,7 @@ static __inline__ unsigned long __ffs(un
 	return result;
 }
 
-static __inline__ int find_next_zero_bit (void * addr, int size, int offset)
+static __inline__ int find_next_zero_bit (const unsigned long * addr, int size, int offset)
 {
 	unsigned long *p = (unsigned long *)(((unsigned long)addr + (offset >> 3)) & ~3);
 	unsigned long result = offset & ~31UL;
diff -purN linux-2.6.11-rc2-bk3/include/asm-ia64/hardirq.h linux-2.6.11-rc2-bk4/include/asm-ia64/hardirq.h
--- linux-2.6.11-rc2-bk3/include/asm-ia64/hardirq.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ia64/hardirq.h	2005-01-26 15:43:26.663461223 +0100
@@ -19,7 +19,6 @@
 
 #define __ARCH_IRQ_STAT	1
 
-#define softirq_pending(cpu)		(cpu_data(cpu)->softirq_pending)
 #define local_softirq_pending()		(local_cpu_data->softirq_pending)
 
 #define HARDIRQ_BITS	14
diff -purN linux-2.6.11-rc2-bk3/include/asm-m68k/checksum.h linux-2.6.11-rc2-bk4/include/asm-m68k/checksum.h
--- linux-2.6.11-rc2-bk3/include/asm-m68k/checksum.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-m68k/checksum.h	2005-01-26 15:43:26.678458885 +0100
@@ -25,11 +25,14 @@ unsigned int csum_partial(const unsigned
  * better 64-bit) boundary
  */
 
-extern unsigned int csum_partial_copy_from_user(const char *src, char *dst,
-						int len, int sum, int *csum_err);
-
-extern unsigned int csum_partial_copy_nocheck(const char *src, char *dst,
-					      int len, int sum);
+extern unsigned int csum_partial_copy_from_user(const unsigned char *src,
+						unsigned char *dst,
+						int len, int sum,
+						int *csum_err);
+
+extern unsigned int csum_partial_copy_nocheck(const unsigned char *src,
+					      unsigned char *dst, int len,
+					      int sum);
 
 /*
  *	This is a version of ip_compute_csum() optimized for IP headers,
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc/processor.h linux-2.6.11-rc2-bk4/include/asm-ppc/processor.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc/processor.h	2005-01-22 02:46:43.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc/processor.h	2005-01-26 15:43:26.680458574 +0100
@@ -34,6 +34,7 @@
 /* these are arbitrary */
 #define _CHRP_Motorola	0x04	/* motorola chrp, the cobra */
 #define _CHRP_IBM	0x05	/* IBM chrp, the longtrail and longtrail 2 */
+#define _CHRP_Pegasos	0x06	/* Genesi/bplan's Pegasos and Pegasos2 */
 
 #define _GLOBAL(n)\
 	.stabs __stringify(n:F-1),N_FUN,0,0,n;\
@@ -54,6 +55,7 @@ extern int _machine;
 
 /* what kind of prep workstation we are */
 extern int _prep_type;
+extern int _chrp_type;
 
 /*
  * This is used to identify the board type from a given PReP board
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/cacheflush.h linux-2.6.11-rc2-bk4/include/asm-ppc64/cacheflush.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/cacheflush.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/cacheflush.h	2005-01-26 15:43:26.682458262 +0100
@@ -40,7 +40,7 @@ extern void __flush_dcache_icache(void *
 
 static inline void flush_icache_range(unsigned long start, unsigned long stop)
 {
-	if (!(cur_cpu_spec->cpu_features & ASM_CONST(CPU_FTR_COHERENT_ICACHE)))
+	if (!(cur_cpu_spec->cpu_features & CPU_FTR_COHERENT_ICACHE))
 		__flush_icache_range(start, stop);
 }
 
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/cputable.h linux-2.6.11-rc2-bk4/include/asm-ppc64/cputable.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/cputable.h	2005-01-22 02:48:29.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/cputable.h	2005-01-26 15:43:26.684457950 +0100
@@ -16,6 +16,7 @@
 #define __ASM_PPC_CPUTABLE_H
 
 #include <linux/config.h>
+#include <asm/page.h> /* for ASM_CONST */
 
 /* Exposed to userland CPU features - Must match ppc32 definitions */
 #define PPC_FEATURE_32			0x80000000
@@ -103,38 +104,38 @@ extern firmware_feature_t firmware_featu
 /* CPU kernel features */
 
 /* Retain the 32b definitions for the time being - use bottom half of word */
-#define CPU_FTR_SPLIT_ID_CACHE		0x0000000000000001
-#define CPU_FTR_L2CR			0x0000000000000002
-#define CPU_FTR_SPEC7450		0x0000000000000004
-#define CPU_FTR_ALTIVEC			0x0000000000000008
-#define CPU_FTR_TAU			0x0000000000000010
-#define CPU_FTR_CAN_DOZE		0x0000000000000020
-#define CPU_FTR_USE_TB			0x0000000000000040
-#define CPU_FTR_604_PERF_MON		0x0000000000000080
-#define CPU_FTR_601			0x0000000000000100
-#define CPU_FTR_HPTE_TABLE		0x0000000000000200
-#define CPU_FTR_CAN_NAP			0x0000000000000400
-#define CPU_FTR_L3CR			0x0000000000000800
-#define CPU_FTR_L3_DISABLE_NAP		0x0000000000001000
-#define CPU_FTR_NAP_DISABLE_L2_PR	0x0000000000002000
-#define CPU_FTR_DUAL_PLL_750FX		0x0000000000004000
+#define CPU_FTR_SPLIT_ID_CACHE		ASM_CONST(0x0000000000000001)
+#define CPU_FTR_L2CR			ASM_CONST(0x0000000000000002)
+#define CPU_FTR_SPEC7450		ASM_CONST(0x0000000000000004)
+#define CPU_FTR_ALTIVEC			ASM_CONST(0x0000000000000008)
+#define CPU_FTR_TAU			ASM_CONST(0x0000000000000010)
+#define CPU_FTR_CAN_DOZE		ASM_CONST(0x0000000000000020)
+#define CPU_FTR_USE_TB			ASM_CONST(0x0000000000000040)
+#define CPU_FTR_604_PERF_MON		ASM_CONST(0x0000000000000080)
+#define CPU_FTR_601			ASM_CONST(0x0000000000000100)
+#define CPU_FTR_HPTE_TABLE		ASM_CONST(0x0000000000000200)
+#define CPU_FTR_CAN_NAP			ASM_CONST(0x0000000000000400)
+#define CPU_FTR_L3CR			ASM_CONST(0x0000000000000800)
+#define CPU_FTR_L3_DISABLE_NAP		ASM_CONST(0x0000000000001000)
+#define CPU_FTR_NAP_DISABLE_L2_PR	ASM_CONST(0x0000000000002000)
+#define CPU_FTR_DUAL_PLL_750FX		ASM_CONST(0x0000000000004000)
 
 /* Add the 64b processor unique features in the top half of the word */
-#define CPU_FTR_SLB           		0x0000000100000000
-#define CPU_FTR_16M_PAGE      		0x0000000200000000
-#define CPU_FTR_TLBIEL         		0x0000000400000000
-#define CPU_FTR_NOEXECUTE     		0x0000000800000000
-#define CPU_FTR_NODSISRALIGN  		0x0000001000000000
-#define CPU_FTR_IABR  			0x0000002000000000
-#define CPU_FTR_MMCRA  			0x0000004000000000
-#define CPU_FTR_PMC8  			0x0000008000000000
-#define CPU_FTR_SMT  			0x0000010000000000
-#define CPU_FTR_COHERENT_ICACHE  	0x0000020000000000
-#define CPU_FTR_LOCKLESS_TLBIE		0x0000040000000000
-#define CPU_FTR_MMCRA_SIHV		0x0000080000000000
+#define CPU_FTR_SLB           		ASM_CONST(0x0000000100000000)
+#define CPU_FTR_16M_PAGE      		ASM_CONST(0x0000000200000000)
+#define CPU_FTR_TLBIEL         		ASM_CONST(0x0000000400000000)
+#define CPU_FTR_NOEXECUTE     		ASM_CONST(0x0000000800000000)
+#define CPU_FTR_NODSISRALIGN  		ASM_CONST(0x0000001000000000)
+#define CPU_FTR_IABR  			ASM_CONST(0x0000002000000000)
+#define CPU_FTR_MMCRA  			ASM_CONST(0x0000004000000000)
+#define CPU_FTR_PMC8  			ASM_CONST(0x0000008000000000)
+#define CPU_FTR_SMT  			ASM_CONST(0x0000010000000000)
+#define CPU_FTR_COHERENT_ICACHE  	ASM_CONST(0x0000020000000000)
+#define CPU_FTR_LOCKLESS_TLBIE		ASM_CONST(0x0000040000000000)
+#define CPU_FTR_MMCRA_SIHV		ASM_CONST(0x0000080000000000)
 
 /* Platform firmware features */
-#define FW_FTR_                         0x0000000000000001
+#define FW_FTR_				ASM_CONST(0x0000000000000001)
 
 #ifndef __ASSEMBLY__
 #define COMMON_USER_PPC64	(PPC_FEATURE_32 | PPC_FEATURE_64 | \
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/eeh.h linux-2.6.11-rc2-bk4/include/asm-ppc64/eeh.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/eeh.h	2005-01-22 02:49:22.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/eeh.h	2005-01-26 15:43:26.686457639 +0100
@@ -20,28 +20,28 @@
 #ifndef _PPC64_EEH_H
 #define _PPC64_EEH_H
 
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/string.h>
-#include <linux/notifier.h>
 
 struct pci_dev;
 struct device_node;
+struct device_node;
+struct notifier_block;
+
+#ifdef CONFIG_EEH
 
 /* Values for eeh_mode bits in device_node */
 #define EEH_MODE_SUPPORTED	(1<<0)
 #define EEH_MODE_NOCHECK	(1<<1)
 #define EEH_MODE_ISOLATED	(1<<2)
 
-#ifdef CONFIG_PPC_PSERIES
-extern void __init eeh_init(void);
-unsigned long eeh_check_failure(const volatile void __iomem *token, unsigned long val);
-int eeh_dn_check_failure (struct device_node *dn, struct pci_dev *dev);
-void __iomem *eeh_ioremap(unsigned long addr, void __iomem *vaddr);
+void __init eeh_init(void);
+unsigned long eeh_check_failure(const volatile void __iomem *token,
+				unsigned long val);
+int eeh_dn_check_failure(struct device_node *dn, struct pci_dev *dev);
 void __init pci_addr_cache_build(void);
-#else
-#define eeh_check_failure(token, val) (val)
-#endif
 
 /**
  * eeh_add_device_early
@@ -52,7 +52,6 @@ void __init pci_addr_cache_build(void);
  * device (including config space i/o).  Call eeh_add_device_late
  * to finish the eeh setup for this device.
  */
-struct device_node;
 void eeh_add_device_early(struct device_node *);
 void eeh_add_device_late(struct pci_dev *);
 
@@ -69,8 +68,6 @@ void eeh_remove_device(struct pci_dev *)
 #define EEH_ENABLE		1
 #define EEH_RELEASE_LOADSTORE	2
 #define EEH_RELEASE_DMA		3
-int eeh_set_option(struct pci_dev *dev, int options);
-
 
 /**
  * Notifier event flags.
@@ -107,6 +104,18 @@ int eeh_unregister_notifier(struct notif
  */
 #define EEH_IO_ERROR_VALUE(size)	(~0U >> ((4 - (size)) * 8))
 
+#else
+#define eeh_init()
+#define eeh_check_failure(token, val) (val)
+#define eeh_dn_check_failure(dn, dev) (0)
+#define pci_addr_cache_build()
+#define eeh_add_device_early(dn)
+#define eeh_add_device_late(dev)
+#define eeh_remove_device(dev)
+#define EEH_POSSIBLE_ERROR(val, type) (0)
+#define EEH_IO_ERROR_VALUE(size) (-1UL)
+#endif
+
 /* 
  * MMIO read/write operations with EEH support.
  */
@@ -194,7 +203,8 @@ static inline void eeh_raw_writeq(u64 va
 #define EEH_CHECK_ALIGN(v,a) \
 	((((unsigned long)(v)) & ((a) - 1)) == 0)
 
-static inline void eeh_memset_io(volatile void __iomem *addr, int c, unsigned long n)
+static inline void eeh_memset_io(volatile void __iomem *addr, int c,
+				 unsigned long n)
 {
 	u32 lc = c;
 	lc |= lc << 8;
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/io.h linux-2.6.11-rc2-bk4/include/asm-ppc64/io.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/io.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/io.h	2005-01-26 15:43:26.687457483 +0100
@@ -371,7 +371,7 @@ static inline unsigned long in_be64(cons
 {
 	unsigned long ret;
 
-	__asm__ __volatile__("ld %0,0(%1); twi 0,%0,0; isync"
+	__asm__ __volatile__("ld%U1%X1 %0,%1; twi 0,%0,0; isync"
 			     : "=r" (ret) : "m" (*addr));
 	return ret;
 }
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/mmu_context.h linux-2.6.11-rc2-bk4/include/asm-ppc64/mmu_context.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/mmu_context.h	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/mmu_context.h	2005-01-26 15:43:26.688457327 +0100
@@ -51,14 +51,6 @@ extern void switch_slb(struct task_struc
 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 			     struct task_struct *tsk)
 {
-#ifdef CONFIG_ALTIVEC
-	asm volatile (
- BEGIN_FTR_SECTION
-	"dssall;\n"
- END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
-	 : : );
-#endif /* CONFIG_ALTIVEC */
-
 	if (!cpu_isset(smp_processor_id(), next->cpu_vm_mask))
 		cpu_set(smp_processor_id(), next->cpu_vm_mask);
 
@@ -66,6 +58,11 @@ static inline void switch_mm(struct mm_s
 	if (prev == next)
 		return;
 
+#ifdef CONFIG_ALTIVEC
+	if (cur_cpu_spec->cpu_features & CPU_FTR_ALTIVEC)
+		asm volatile ("dssall");
+#endif /* CONFIG_ALTIVEC */
+
 	if (cur_cpu_spec->cpu_features & CPU_FTR_SLB)
 		switch_slb(tsk, next);
 	else
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/page.h linux-2.6.11-rc2-bk4/include/asm-ppc64/page.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/page.h	2005-01-22 02:46:44.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/page.h	2005-01-26 15:43:26.689457171 +0100
@@ -205,10 +205,8 @@ extern u64 ppc64_pft_size;		/* Log 2 of 
 #define KERNELBASE      PAGE_OFFSET
 #define VMALLOCBASE     ASM_CONST(0xD000000000000000)
 #define IOREGIONBASE    ASM_CONST(0xE000000000000000)
-#define EEHREGIONBASE   ASM_CONST(0xA000000000000000)
 
 #define IO_REGION_ID       (IOREGIONBASE>>REGION_SHIFT)
-#define EEH_REGION_ID      (EEHREGIONBASE>>REGION_SHIFT)
 #define VMALLOC_REGION_ID  (VMALLOCBASE>>REGION_SHIFT)
 #define KERNEL_REGION_ID   (KERNELBASE>>REGION_SHIFT)
 #define USER_REGION_ID     (0UL)
diff -purN linux-2.6.11-rc2-bk3/include/asm-ppc64/prom.h linux-2.6.11-rc2-bk4/include/asm-ppc64/prom.h
--- linux-2.6.11-rc2-bk3/include/asm-ppc64/prom.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-ppc64/prom.h	2005-01-26 15:43:26.690457015 +0100
@@ -149,18 +149,15 @@ struct device_node {
 	struct  proc_dir_entry *pde;       /* this node's proc directory */
 	struct  proc_dir_entry *name_link; /* name symlink */
 	struct  proc_dir_entry *addr_link; /* addr symlink */
-	atomic_t _users;                 /* reference count */
+	struct  kref kref;
 	unsigned long _flags;
 };
 
 extern struct device_node *of_chosen;
 
 /* flag descriptions */
-#define OF_STALE   0 /* node is slated for deletion */
 #define OF_DYNAMIC 1 /* node and properties were allocated via kmalloc */
 
-#define OF_IS_STALE(x) test_bit(OF_STALE, &x->_flags)
-#define OF_MARK_STALE(x) set_bit(OF_STALE, &x->_flags)
 #define OF_IS_DYNAMIC(x) test_bit(OF_DYNAMIC, &x->_flags)
 #define OF_MARK_DYNAMIC(x) set_bit(OF_DYNAMIC, &x->_flags)
 
diff -purN linux-2.6.11-rc2-bk3/include/asm-s390/hardirq.h linux-2.6.11-rc2-bk4/include/asm-s390/hardirq.h
--- linux-2.6.11-rc2-bk3/include/asm-s390/hardirq.h	2005-01-22 02:49:19.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-s390/hardirq.h	2005-01-26 15:43:26.691456859 +0100
@@ -28,15 +28,6 @@ typedef struct {
 
 #define local_softirq_pending() (S390_lowcore.softirq_pending)
 
-/* this is always called with cpu == smp_processor_id() at the moment */
-static inline __u32
-softirq_pending(unsigned int cpu)
-{
-	if (cpu == smp_processor_id())
-		return local_softirq_pending();
-	return lowcore_ptr[cpu]->softirq_pending;
-}
-
 #define __ARCH_IRQ_STAT
 #define __ARCH_HAS_DO_SOFTIRQ
 
diff -purN linux-2.6.11-rc2-bk3/include/asm-x86_64/mtrr.h linux-2.6.11-rc2-bk4/include/asm-x86_64/mtrr.h
--- linux-2.6.11-rc2-bk3/include/asm-x86_64/mtrr.h	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-x86_64/mtrr.h	2005-01-26 15:43:26.696456080 +0100
@@ -79,7 +79,6 @@ extern int mtrr_add_page (unsigned long 
 		     unsigned int type, char increment);
 extern int mtrr_del (int reg, unsigned long base, unsigned long size);
 extern int mtrr_del_page (int reg, unsigned long base, unsigned long size);
-extern void mtrr_centaur_report_mcr(int mcr, u32 lo, u32 hi);
 #  else
 static __inline__ int mtrr_add (unsigned long base, unsigned long size,
 				unsigned int type, char increment)
@@ -102,8 +101,6 @@ static __inline__ int mtrr_del_page (int
     return -ENODEV;
 }
 
-static __inline__ void mtrr_centaur_report_mcr(int mcr, u32 lo, u32 hi) {}
-
 #  endif
 
 #endif
diff -purN linux-2.6.11-rc2-bk3/include/asm-x86_64/pci.h linux-2.6.11-rc2-bk4/include/asm-x86_64/pci.h
--- linux-2.6.11-rc2-bk3/include/asm-x86_64/pci.h	2005-01-22 02:47:49.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/asm-x86_64/pci.h	2005-01-26 15:43:26.697455924 +0100
@@ -41,7 +41,6 @@ int pcibios_set_irq_routing(struct pci_d
 #include <linux/slab.h>
 #include <asm/scatterlist.h>
 #include <linux/string.h>
-#include <asm/io.h>
 #include <asm/page.h>
 
 extern int iommu_setup(char *opt);
diff -purN linux-2.6.11-rc2-bk3/include/linux/device-mapper.h linux-2.6.11-rc2-bk4/include/linux/device-mapper.h
--- linux-2.6.11-rc2-bk3/include/linux/device-mapper.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/device-mapper.h	2005-01-26 15:43:26.698455769 +0100
@@ -52,7 +52,8 @@ typedef int (*dm_endio_fn) (struct dm_ta
 			    struct bio *bio, int error,
 			    union map_info *map_context);
 
-typedef void (*dm_suspend_fn) (struct dm_target *ti);
+typedef void (*dm_presuspend_fn) (struct dm_target *ti);
+typedef void (*dm_postsuspend_fn) (struct dm_target *ti);
 typedef void (*dm_resume_fn) (struct dm_target *ti);
 
 typedef int (*dm_status_fn) (struct dm_target *ti, status_type_t status_type,
@@ -82,7 +83,8 @@ struct target_type {
 	dm_dtr_fn dtr;
 	dm_map_fn map;
 	dm_endio_fn end_io;
-	dm_suspend_fn suspend;
+	dm_presuspend_fn presuspend;
+	dm_postsuspend_fn postsuspend;
 	dm_resume_fn resume;
 	dm_status_fn status;
 	dm_message_fn message;
diff -purN linux-2.6.11-rc2-bk3/include/linux/dm-ioctl.h linux-2.6.11-rc2-bk4/include/linux/dm-ioctl.h
--- linux-2.6.11-rc2-bk3/include/linux/dm-ioctl.h	2005-01-22 02:46:42.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/dm-ioctl.h	2005-01-26 15:43:26.699455613 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2001 - 2003 Sistina Software (UK) Limited.
- * Copyright (C) 2004 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2004 - 2005 Red Hat, Inc. All rights reserved.
  *
  * This file is released under the LGPL.
  */
@@ -272,9 +272,9 @@ typedef char ioctl_struct[308];
 #define DM_TARGET_MSG	 _IOWR(DM_IOCTL, DM_TARGET_MSG_CMD, struct dm_ioctl)
 
 #define DM_VERSION_MAJOR	4
-#define DM_VERSION_MINOR	3
+#define DM_VERSION_MINOR	4
 #define DM_VERSION_PATCHLEVEL	0
-#define DM_VERSION_EXTRA	"-ioctl (2004-09-30)"
+#define DM_VERSION_EXTRA	"-ioctl (2005-01-12)"
 
 /* Status bits */
 #define DM_READONLY_FLAG	(1 << 0) /* In/Out */
@@ -300,4 +300,9 @@ typedef char ioctl_struct[308];
  */
 #define DM_BUFFER_FULL_FLAG	(1 << 8) /* Out */
 
+/*
+ * Set this to improve performance when you aren't going to use open_count
+ */
+#define DM_SKIP_BDGET_FLAG	(1 << 9) /* In */
+
 #endif				/* _LINUX_DM_IOCTL_H */
diff -purN linux-2.6.11-rc2-bk3/include/linux/fs.h linux-2.6.11-rc2-bk4/include/linux/fs.h
--- linux-2.6.11-rc2-bk3/include/linux/fs.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/fs.h	2005-01-26 15:43:26.706454522 +0100
@@ -586,6 +586,7 @@ struct file {
 	unsigned int		f_uid, f_gid;
 	struct file_ra_state	f_ra;
 
+	size_t			f_maxcount;
 	unsigned long		f_version;
 	void			*f_security;
 
@@ -1222,14 +1223,7 @@ static inline int locks_verify_locked(st
 	return 0;
 }
 
-static inline int locks_verify_area(int read_write, struct inode *inode,
-				    struct file *filp, loff_t offset,
-				    size_t count)
-{
-	if (inode->i_flock && MANDATORY_LOCK(inode))
-		return locks_mandatory_area(read_write, inode, filp, offset, count);
-	return 0;
-}
+extern int rw_verify_area(int, struct file *, loff_t *, size_t);
 
 static inline int locks_verify_truncate(struct inode *inode,
 				    struct file *filp,
@@ -1566,6 +1560,8 @@ extern int vfs_stat(char __user *, struc
 extern int vfs_lstat(char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 
+extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);
+
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
 extern struct super_block *user_get_super(dev_t);
diff -purN linux-2.6.11-rc2-bk3/include/linux/i2c-id.h linux-2.6.11-rc2-bk4/include/linux/i2c-id.h
--- linux-2.6.11-rc2-bk3/include/linux/i2c-id.h	2005-01-22 02:46:59.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/i2c-id.h	2005-01-26 15:43:26.707454366 +0100
@@ -239,6 +239,7 @@
 #define I2C_HW_B_IXP4XX 0x17	/* GPIO on IXP4XX systems		*/
 #define I2C_HW_B_S3VIA	0x18	/* S3Via ProSavage adapter		*/
 #define I2C_HW_B_ZR36067 0x19	/* Zoran-36057/36067 based boards	*/
+#define I2C_HW_B_CX2388x 0x1b	/* connexant 2388x based tv cards	*/
 
 /* --- PCF 8584 based algorithms					*/
 #define I2C_HW_P_LP	0x00	/* Parallel port interface		*/
diff -purN linux-2.6.11-rc2-bk3/include/linux/irq_cpustat.h linux-2.6.11-rc2-bk4/include/linux/irq_cpustat.h
--- linux-2.6.11-rc2-bk3/include/linux/irq_cpustat.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/irq_cpustat.h	2005-01-26 15:43:26.708454210 +0100
@@ -23,8 +23,8 @@ extern irq_cpustat_t irq_stat[];		/* def
 #endif
 
   /* arch independent irq_stat fields */
-#define softirq_pending(cpu)	__IRQ_STAT((cpu), __softirq_pending)
-#define local_softirq_pending()	softirq_pending(smp_processor_id())
+#define local_softirq_pending() \
+	__IRQ_STAT(smp_processor_id(), __softirq_pending)
 
   /* arch dependent irq_stat fields */
 #define nmi_count(cpu)		__IRQ_STAT((cpu), __nmi_count)	/* i386 */
diff -purN linux-2.6.11-rc2-bk3/include/linux/moduleparam.h linux-2.6.11-rc2-bk4/include/linux/moduleparam.h
--- linux-2.6.11-rc2-bk3/include/linux/moduleparam.h	2005-01-22 02:48:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/moduleparam.h	2005-01-26 15:43:26.709454054 +0100
@@ -64,7 +64,8 @@ struct kparam_array
    param_set_XXX and param_check_XXX. */
 #define module_param_named(name, value, type, perm)			   \
 	param_check_##type(name, &(value));				   \
-	module_param_call(name, param_set_##type, param_get_##type, &value, perm)
+	module_param_call(name, param_set_##type, param_get_##type, &value, perm); \
+	__MODULE_INFO(parmtype, name##type, #name ":" #type)
 
 #define module_param(name, type, perm)				\
 	module_param_named(name, name, type, perm)
@@ -74,7 +75,8 @@ struct kparam_array
 	static struct kparam_string __param_string_##name		\
 		= { len, string };					\
 	module_param_call(name, param_set_copystring, param_get_string,	\
-		   &__param_string_##name, perm)
+		   &__param_string_##name, perm);			\
+	__MODULE_INFO(parmtype, name##type, #name ":string")
 
 /* Called on module insert or kernel boot */
 extern int parse_args(const char *name,
@@ -135,7 +137,8 @@ extern int param_get_invbool(char *buffe
 	= { ARRAY_SIZE(array), nump, param_set_##type, param_get_##type,\
 	    sizeof(array[0]), array };					\
 	module_param_call(name, param_array_set, param_array_get, 	\
-			  &__param_arr_##name, perm)
+			  &__param_arr_##name, perm);			\
+	__MODULE_INFO(parmtype, name##type, #name ":array of " #type)
 
 #define module_param_array(name, type, nump, perm)		\
 	module_param_array_named(name, name, type, nump, perm)
diff -purN linux-2.6.11-rc2-bk3/include/linux/oprofile.h linux-2.6.11-rc2-bk4/include/linux/oprofile.h
--- linux-2.6.11-rc2-bk3/include/linux/oprofile.h	2005-01-22 02:48:26.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/oprofile.h	2005-01-26 15:43:26.712453587 +0100
@@ -48,7 +48,7 @@ struct oprofile_operations {
  *
  * If an error occurs, the fields should be left untouched.
  */
-void oprofile_arch_init(struct oprofile_operations * ops);
+int oprofile_arch_init(struct oprofile_operations * ops);
  
 /**
  * One-time exit/cleanup for the arch.
diff -purN linux-2.6.11-rc2-bk3/include/linux/videodev2.h linux-2.6.11-rc2-bk4/include/linux/videodev2.h
--- linux-2.6.11-rc2-bk3/include/linux/videodev2.h	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/videodev2.h	2005-01-26 15:43:26.714453275 +0100
@@ -78,6 +78,7 @@ enum v4l2_ctrl_type {
 enum v4l2_tuner_type {
 	V4L2_TUNER_RADIO	     = 1,
 	V4L2_TUNER_ANALOG_TV	     = 2,
+	V4L2_TUNER_DIGITAL_TV	     = 3,
 };
 
 enum v4l2_memory {
diff -purN linux-2.6.11-rc2-bk3/include/linux/videotext.h linux-2.6.11-rc2-bk4/include/linux/videotext.h
--- linux-2.6.11-rc2-bk3/include/linux/videotext.h	2005-01-22 02:49:18.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/linux/videotext.h	2005-01-26 15:43:26.717452808 +0100
@@ -1,7 +1,13 @@
 #ifndef _VTX_H
 #define _VTX_H
 
-/* $Id: videotext.h,v 1.1 1998/03/30 22:26:39 alan Exp $
+/*
+ * Teletext (=Videotext) hardware decoders using interface /dev/vtx
+ * Do not confuse with drivers using /dev/vbi which decode videotext by software
+ *
+ * Videotext IOCTLs changed in order to use _IO() macros defined in <linux/ioctl.h>,
+ * unused tuner IOCTLs cleaned up by
+ * Michael Geng <linux@MichaelGeng.de>
  *
  * Copyright (c) 1994-97 Martin Buck  <martin-2.buck@student.uni-ulm.de>
  * Read COPYING for more information
@@ -12,19 +18,32 @@
 /*
  *	Videotext ioctls
  */
-#define VTXIOCGETINFO  0x7101  /* get version of driver & capabilities of vtx-chipset */
-#define VTXIOCCLRPAGE  0x7102  /* clear page-buffer */
-#define VTXIOCCLRFOUND 0x7103  /* clear bits indicating that page was found */
-#define VTXIOCPAGEREQ  0x7104  /* search for page */
-#define VTXIOCGETSTAT  0x7105  /* get status of page-buffer */
-#define VTXIOCGETPAGE  0x7106  /* get contents of page-buffer */
-#define VTXIOCSTOPDAU  0x7107  /* stop data acquisition unit */
-#define VTXIOCPUTPAGE  0x7108  /* display page on TV-screen */
-#define VTXIOCSETDISP  0x7109  /* set TV-mode */
-#define VTXIOCPUTSTAT  0x710a  /* set status of TV-output-buffer */
-#define VTXIOCCLRCACHE 0x710b  /* clear cache on VTX-interface (if avail.) */
-#define VTXIOCSETVIRT  0x710c  /* turn on virtual mode (this disables TV-display) */
-
+#define VTXIOCGETINFO	_IOR  (0x81,  1, vtx_info_t)
+#define VTXIOCCLRPAGE	_IOW  (0x81,  2, vtx_pagereq_t)
+#define VTXIOCCLRFOUND	_IOW  (0x81,  3, vtx_pagereq_t)
+#define VTXIOCPAGEREQ	_IOW  (0x81,  4, vtx_pagereq_t)
+#define VTXIOCGETSTAT	_IOW  (0x81,  5, vtx_pagereq_t)
+#define VTXIOCGETPAGE	_IOW  (0x81,  6, vtx_pagereq_t)
+#define VTXIOCSTOPDAU	_IOW  (0x81,  7, vtx_pagereq_t)
+#define VTXIOCPUTPAGE	_IO   (0x81,  8)
+#define VTXIOCSETDISP	_IO   (0x81,  9)
+#define VTXIOCPUTSTAT	_IO   (0x81, 10)
+#define VTXIOCCLRCACHE	_IO   (0x81, 11)
+#define VTXIOCSETVIRT	_IOW  (0x81, 12, long)
+
+/* for compatibility, will go away some day */
+#define VTXIOCGETINFO_OLD  0x7101  /* get version of driver & capabilities of vtx-chipset */
+#define VTXIOCCLRPAGE_OLD  0x7102  /* clear page-buffer */
+#define VTXIOCCLRFOUND_OLD 0x7103  /* clear bits indicating that page was found */
+#define VTXIOCPAGEREQ_OLD  0x7104  /* search for page */
+#define VTXIOCGETSTAT_OLD  0x7105  /* get status of page-buffer */
+#define VTXIOCGETPAGE_OLD  0x7106  /* get contents of page-buffer */
+#define VTXIOCSTOPDAU_OLD  0x7107  /* stop data acquisition unit */
+#define VTXIOCPUTPAGE_OLD  0x7108  /* display page on TV-screen */
+#define VTXIOCSETDISP_OLD  0x7109  /* set TV-mode */
+#define VTXIOCPUTSTAT_OLD  0x710a  /* set status of TV-output-buffer */
+#define VTXIOCCLRCACHE_OLD 0x710b  /* clear cache on VTX-interface (if avail.) */
+#define VTXIOCSETVIRT_OLD  0x710c  /* turn on virtual mode (this disables TV-display) */
 
 /* 
  *	Definitions for VTXIOCGETINFO
@@ -102,43 +121,5 @@ typedef struct 
 	unsigned hamming : 1;		/* hamming-error occurred */
 }
 vtx_pageinfo_t;
-
-
-/*
- *	Definitions for VTXIOCSETDISP
- */
  
-typedef enum { 
-	DISPOFF, DISPNORM, DISPTRANS, DISPINS, INTERLACE_OFFSET 
-} vtxdisp_t;
-
-
-
-/*
- *	Tuner ioctls
- */
- 
-#define TUNIOCGETINFO  0x7201  /* get version of driver & capabilities of tuner */
-#define TUNIOCRESET    0x7202  /* reset tuner */
-#define TUNIOCSETFREQ  0x7203  /* set tuning frequency (unit: kHz) */
-#define TUNIOCGETFREQ  0x7204  /* get tuning frequency (unit: kHz) */
-#define TUNIOCSETCHAN  0x7205  /* set tuning channel */
-#define TUNIOCGETCHAN  0x7206  /* get tuning channel */
-
-
-typedef struct 
-{
-	int version_major, version_minor;	/* version of driver; if version_major changes, driver */
-						/* is not backward compatible!!! CHECK THIS!!! */  
-	unsigned freq : 1;			/* tuner can be set to given frequency */
-	unsigned chan : 1;			/* tuner stores several channels */
-	unsigned scan : 1;			/* tuner supports scanning */
-	unsigned autoscan : 1;		/* tuner supports scanning with automatic stop */
-	unsigned afc : 1;			/* tuner supports AFC */
-	unsigned dummy1, dummy2, dummy3, dummy4, dummy5, dummy6, dummy7, dummy8, dummy9, dummy10,
- 		dummy11 : 1;
-	int dummy12, dummy13, dummy14, dummy15, dummy16, dummy17, dummy18, dummy19;
-} tuner_info_t;
-
-
 #endif /* _VTX_H */
diff -purN linux-2.6.11-rc2-bk3/include/media/tuner.h linux-2.6.11-rc2-bk4/include/media/tuner.h
--- linux-2.6.11-rc2-bk3/include/media/tuner.h	2005-01-22 02:48:34.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/media/tuner.h	2005-01-26 15:43:26.718452652 +0100
@@ -77,6 +77,7 @@
 #define TUNER_MICROTUNE_4042FI5  49	/* FusionHDTV 3 Gold - 4042 FI5 (3X 8147) */
 #define TUNER_TCL_2002N          50
 #define TUNER_PHILIPS_FM1256_IH3   51
+#define TUNER_THOMSON_DTT7610    52
 
 #define NOTUNER 0
 #define PAL     1	/* PAL_BG */
@@ -97,6 +98,7 @@
 #define HITACHI 9
 #define Panasonic 10
 #define TCL     11
+#define THOMSON 12
 
 #define TUNER_SET_TYPE               _IOW('t',1,int)    /* set tuner type */
 #define TUNER_SET_TVFREQ             _IOW('t',2,int)    /* set tv freq */
@@ -108,10 +110,12 @@
 #define  TDA9887_SET_CONFIG          _IOW('t',5,int)
 /* tv card specific */
 # define TDA9887_PRESENT             (1<<0)
-# define TDA9887_PORT1               (1<<1)
-# define TDA9887_PORT2               (1<<2)
+# define TDA9887_PORT1_INACTIVE      (1<<1)
+# define TDA9887_PORT2_INACTIVE      (1<<2)
 # define TDA9887_QSS                 (1<<3)
 # define TDA9887_INTERCARRIER        (1<<4)
+# define TDA9887_PORT1_ACTIVE        (1<<5)
+# define TDA9887_PORT2_ACTIVE        (1<<6)
 /* config options */
 # define TDA9887_DEEMPHASIS_MASK     (3<<16)
 # define TDA9887_DEEMPHASIS_NONE     (1<<16)
diff -purN linux-2.6.11-rc2-bk3/include/media/tveeprom.h linux-2.6.11-rc2-bk4/include/media/tveeprom.h
--- linux-2.6.11-rc2-bk3/include/media/tveeprom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/media/tveeprom.h	2005-01-26 15:43:26.718452652 +0100
@@ -0,0 +1,23 @@
+struct tveeprom {
+	u32 has_radio;
+
+	u32 tuner_type;
+	u32 tuner_formats;
+
+	u32 digitizer;
+	u32 digitizer_formats;
+
+	u32 audio_processor;
+	/* a_p_fmts? */
+
+	u32 model;
+	u32 revision;
+	u32 serial_number;
+	char rev_str[5];
+};
+
+void tveeprom_hauppauge_analog(struct tveeprom *tvee,
+			       unsigned char *eeprom_data);
+
+int tveeprom_read(struct i2c_client *c, unsigned char *eedata, int len);
+int tveeprom_dump(unsigned char *eedata, int len);
diff -purN linux-2.6.11-rc2-bk3/include/media/video-buf-dvb.h linux-2.6.11-rc2-bk4/include/media/video-buf-dvb.h
--- linux-2.6.11-rc2-bk3/include/media/video-buf-dvb.h	2005-01-22 02:48:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/media/video-buf-dvb.h	2005-01-26 15:43:26.719452496 +0100
@@ -24,7 +24,9 @@ struct videobuf_dvb {
 	struct dvb_net             net;
 };
 
-int videobuf_dvb_register(struct videobuf_dvb *dvb);
+int videobuf_dvb_register(struct videobuf_dvb *dvb,
+			  struct module *module,
+			  void *adapter_priv);
 void videobuf_dvb_unregister(struct videobuf_dvb *dvb);
 
 /*
diff -purN linux-2.6.11-rc2-bk3/include/pcmcia/cs_types.h linux-2.6.11-rc2-bk4/include/pcmcia/cs_types.h
--- linux-2.6.11-rc2-bk3/include/pcmcia/cs_types.h	2005-01-22 02:47:31.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/pcmcia/cs_types.h	2005-01-26 15:43:26.720452340 +0100
@@ -22,10 +22,12 @@
 #endif
 
 #if defined(__arm__) || defined(__mips__)
+/* This (ioaddr_t) is exposed to userspace & hence cannot be changed. */
 typedef u_int   ioaddr_t;
 #else
 typedef u_short	ioaddr_t;
 #endif
+typedef unsigned long kio_addr_t;
 
 typedef u_short	socket_t;
 typedef u_int	event_t;
diff -purN linux-2.6.11-rc2-bk3/include/pcmcia/ss.h linux-2.6.11-rc2-bk4/include/pcmcia/ss.h
--- linux-2.6.11-rc2-bk3/include/pcmcia/ss.h	2005-01-22 02:48:58.000000000 +0100
+++ linux-2.6.11-rc2-bk4/include/pcmcia/ss.h	2005-01-26 15:43:26.721452184 +0100
@@ -81,7 +81,7 @@ typedef struct pccard_io_map {
     u_char	map;
     u_char	flags;
     u_short	speed;
-    ioaddr_t	start, stop;
+    kio_addr_t	start, stop;
 } pccard_io_map;
 
 typedef struct pccard_mem_map {
@@ -144,8 +144,8 @@ struct pcmcia_socket;
 
 typedef struct io_window_t {
 	u_int			Attributes;
-	ioaddr_t		BasePort, NumPorts;
-	ioaddr_t		InUse, Config;
+	kio_addr_t		BasePort, NumPorts;
+	kio_addr_t		InUse, Config;
 	struct resource		*res;
 } io_window_t;
 
@@ -165,7 +165,6 @@ typedef struct window_t {
 #define MAX_WIN 4
 
 struct config_t;
-struct region_t;
 struct pcmcia_callback;
 
 
@@ -185,7 +184,6 @@ struct pcmcia_socket {
 	} irq;
 	io_window_t			io[MAX_IO_WIN];
 	window_t			win[MAX_WIN];
-	struct region_t			*c_region, *a_region;
 	struct list_head		cis_cache;
 	u_int				fake_cis_len;
 	char				*fake_cis;
@@ -201,7 +199,7 @@ struct pcmcia_socket {
 	u_int				features;
 	u_int				irq_mask;
 	u_int				map_size;
-	ioaddr_t			io_offset;
+	kio_addr_t			io_offset;
 	u_char				pci_irq;
 	struct pci_dev *		cb_dev;
 
diff -purN linux-2.6.11-rc2-bk3/init/do_mounts.c linux-2.6.11-rc2-bk4/init/do_mounts.c
--- linux-2.6.11-rc2-bk3/init/do_mounts.c	2005-01-22 02:47:48.000000000 +0100
+++ linux-2.6.11-rc2-bk4/init/do_mounts.c	2005-01-26 15:43:26.722452028 +0100
@@ -6,6 +6,7 @@
 #include <linux/suspend.h>
 #include <linux/root_dev.h>
 #include <linux/security.h>
+#include <linux/delay.h>
 
 #include <linux/nfs_fs.h>
 #include <linux/nfs_fs_sb.h>
@@ -228,8 +229,16 @@ static int __init fs_names_setup(char *s
 	return 1;
 }
 
+static unsigned int __initdata root_delay;
+static int __init root_delay_setup(char *str)
+{
+	root_delay = simple_strtoul(str, NULL, 0);
+	return 1;
+}
+
 __setup("rootflags=", root_data_setup);
 __setup("rootfstype=", fs_names_setup);
+__setup("rootdelay=", root_delay_setup);
 
 static void __init get_fs_names(char *page)
 {
@@ -387,6 +396,12 @@ void __init prepare_namespace(void)
 
 	mount_devfs();
 
+	if (root_delay) {
+		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
+		       root_delay);
+		ssleep(root_delay);
+	}
+
 	md_run_setup();
 
 	if (saved_root_name[0]) {
diff -purN linux-2.6.11-rc2-bk3/kernel/params.c linux-2.6.11-rc2-bk4/kernel/params.c
--- linux-2.6.11-rc2-bk3/kernel/params.c	2005-01-22 02:48:47.000000000 +0100
+++ linux-2.6.11-rc2-bk4/kernel/params.c	2005-01-26 15:43:26.725451561 +0100
@@ -640,9 +640,33 @@ static ssize_t module_attr_show(struct k
 	return ret;
 }
 
+static ssize_t module_attr_store(struct kobject *kobj,
+				struct attribute *attr,
+				const char *buf, size_t len)
+{
+	struct module_attribute *attribute;
+	struct module_kobject *mk;
+	int ret;
+
+	attribute = to_module_attr(attr);
+	mk = to_module_kobject(kobj);
+
+	if (!attribute->store)
+		return -EPERM;
+
+	if (!try_module_get(mk->mod))
+		return -ENODEV;
+
+	ret = attribute->store(attribute, mk->mod, buf, len);
+
+	module_put(mk->mod);
+
+	return ret;
+}
+
 static struct sysfs_ops module_sysfs_ops = {
 	.show = module_attr_show,
-	.store = NULL,
+	.store = module_attr_store,
 };
 
 #else
diff -purN linux-2.6.11-rc2-bk3/kernel/power/main.c linux-2.6.11-rc2-bk4/kernel/power/main.c
--- linux-2.6.11-rc2-bk3/kernel/power/main.c	2005-01-22 02:47:30.000000000 +0100
+++ linux-2.6.11-rc2-bk4/kernel/power/main.c	2005-01-26 15:43:26.726451405 +0100
@@ -141,14 +141,14 @@ static int enter_state(suspend_state_t s
 	if (down_trylock(&pm_sem))
 		return -EBUSY;
 
-	/* Suspend is hard to get right on SMP. */
-	if (num_online_cpus() != 1) {
-		error = -EPERM;
+	if (state == PM_SUSPEND_DISK) {
+		error = pm_suspend_disk();
 		goto Unlock;
 	}
 
-	if (state == PM_SUSPEND_DISK) {
-		error = pm_suspend_disk();
+	/* Suspend is hard to get right on SMP. */
+	if (num_online_cpus() != 1) {
+		error = -EPERM;
 		goto Unlock;
 	}
 
diff -purN linux-2.6.11-rc2-bk3/kernel/sys_ni.c linux-2.6.11-rc2-bk4/kernel/sys_ni.c
--- linux-2.6.11-rc2-bk3/kernel/sys_ni.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/kernel/sys_ni.c	2005-01-26 15:43:26.727451249 +0100
@@ -81,4 +81,5 @@ cond_syscall(compat_sys_socketcall)
 cond_syscall(sys_pciconfig_read)
 cond_syscall(sys_pciconfig_write)
 cond_syscall(sys_pciconfig_iobase)
-
+cond_syscall(sys32_ipc)
+cond_syscall(sys32_sysctl)
diff -purN linux-2.6.11-rc2-bk3/mm/memory.c linux-2.6.11-rc2-bk4/mm/memory.c
--- linux-2.6.11-rc2-bk3/mm/memory.c	2005-01-26 15:42:47.786658117 +0100
+++ linux-2.6.11-rc2-bk4/mm/memory.c	2005-01-26 15:43:26.732450470 +0100
@@ -1556,8 +1556,17 @@ void unmap_mapping_range(struct address_
 
 	spin_lock(&mapping->i_mmap_lock);
 
+	/* serialize i_size write against truncate_count write */
+	smp_wmb();
 	/* Protect against page faults, and endless unmapping loops */
 	mapping->truncate_count++;
+	/*
+	 * For archs where spin_lock has inclusive semantics like ia64
+	 * this smp_mb() will prevent to read pagetable contents
+	 * before the truncate_count increment is visible to
+	 * other cpus.
+	 */
+	smp_mb();
 	if (unlikely(is_restart_addr(mapping->truncate_count))) {
 		if (mapping->truncate_count == 0)
 			reset_vma_truncate_counts(mapping);
@@ -1865,10 +1874,18 @@ do_no_page(struct mm_struct *mm, struct 
 	if (vma->vm_file) {
 		mapping = vma->vm_file->f_mapping;
 		sequence = mapping->truncate_count;
+		smp_rmb(); /* serializes i_size against truncate_count */
 	}
 retry:
 	cond_resched();
 	new_page = vma->vm_ops->nopage(vma, address & PAGE_MASK, &ret);
+	/*
+	 * No smp_rmb is needed here as long as there's a full
+	 * spin_lock/unlock sequence inside the ->nopage callback
+	 * (for the pagecache lookup) that acts as an implicit
+	 * smp_mb() and prevents the i_size read to happen
+	 * after the next truncate_count read.
+	 */
 
 	/* no page was available -- either SIGBUS or OOM */
 	if (new_page == NOPAGE_SIGBUS)
diff -purN linux-2.6.11-rc2-bk3/mm/page-writeback.c linux-2.6.11-rc2-bk4/mm/page-writeback.c
--- linux-2.6.11-rc2-bk3/mm/page-writeback.c	2005-01-22 02:48:28.000000000 +0100
+++ linux-2.6.11-rc2-bk4/mm/page-writeback.c	2005-01-26 15:43:26.735450002 +0100
@@ -133,17 +133,29 @@ static void get_writeback_state(struct w
  * clamping level.
  */
 static void
-get_dirty_limits(struct writeback_state *wbs, long *pbackground, long *pdirty)
+get_dirty_limits(struct writeback_state *wbs, long *pbackground, long *pdirty,
+		struct address_space *mapping)
 {
 	int background_ratio;		/* Percentages */
 	int dirty_ratio;
 	int unmapped_ratio;
 	long background;
 	long dirty;
+	unsigned long available_memory = total_pages;
 	struct task_struct *tsk;
 
 	get_writeback_state(wbs);
 
+#ifdef CONFIG_HIGHMEM
+	/*
+	 * If this mapping can only allocate from low memory,
+	 * we exclude high memory from our count.
+	 */
+	if (mapping && !(mapping_gfp_mask(mapping) & __GFP_HIGHMEM))
+		available_memory -= totalhigh_pages;
+#endif
+
+
 	unmapped_ratio = 100 - (wbs->nr_mapped * 100) / total_pages;
 
 	dirty_ratio = vm_dirty_ratio;
@@ -157,8 +169,8 @@ get_dirty_limits(struct writeback_state 
 	if (background_ratio >= dirty_ratio)
 		background_ratio = dirty_ratio / 2;
 
-	background = (background_ratio * total_pages) / 100;
-	dirty = (dirty_ratio * total_pages) / 100;
+	background = (background_ratio * available_memory) / 100;
+	dirty = (dirty_ratio * available_memory) / 100;
 	tsk = current;
 	if (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {
 		background += background / 4;
@@ -194,7 +206,8 @@ static void balance_dirty_pages(struct a
 			.nr_to_write	= write_chunk,
 		};
 
-		get_dirty_limits(&wbs, &background_thresh, &dirty_thresh);
+		get_dirty_limits(&wbs, &background_thresh,
+					&dirty_thresh, mapping);
 		nr_reclaimable = wbs.nr_dirty + wbs.nr_unstable;
 		if (nr_reclaimable + wbs.nr_writeback <= dirty_thresh)
 			break;
@@ -210,7 +223,7 @@ static void balance_dirty_pages(struct a
 		if (nr_reclaimable) {
 			writeback_inodes(&wbc);
 			get_dirty_limits(&wbs, &background_thresh,
-					&dirty_thresh);
+					&dirty_thresh, mapping);
 			nr_reclaimable = wbs.nr_dirty + wbs.nr_unstable;
 			if (nr_reclaimable + wbs.nr_writeback <= dirty_thresh)
 				break;
@@ -296,7 +309,7 @@ static void background_writeout(unsigned
 		long background_thresh;
 		long dirty_thresh;
 
-		get_dirty_limits(&wbs, &background_thresh, &dirty_thresh);
+		get_dirty_limits(&wbs, &background_thresh, &dirty_thresh, NULL);
 		if (wbs.nr_dirty + wbs.nr_unstable < background_thresh
 				&& min_pages <= 0)
 			break;
diff -purN linux-2.6.11-rc2-bk3/net/core/pktgen.c linux-2.6.11-rc2-bk4/net/core/pktgen.c
--- linux-2.6.11-rc2-bk3/net/core/pktgen.c	2005-01-26 15:42:47.801655780 +0100
+++ linux-2.6.11-rc2-bk4/net/core/pktgen.c	2005-01-26 15:43:26.750447665 +0100
@@ -2806,7 +2806,7 @@ static void pktgen_thread_worker(struct 
 			tx_since_softirq += pkt_dev->last_ok;
 
 			if (tx_since_softirq > max_before_softirq) {
-				if(softirq_pending(smp_processor_id()))  
+				if (local_softirq_pending())
 					do_softirq();
 				tx_since_softirq = 0;
 			}
diff -purN linux-2.6.11-rc2-bk3/sound/oss/i810_audio.c linux-2.6.11-rc2-bk4/sound/oss/i810_audio.c
--- linux-2.6.11-rc2-bk3/sound/oss/i810_audio.c	2005-01-22 02:48:35.000000000 +0100
+++ linux-2.6.11-rc2-bk4/sound/oss/i810_audio.c	2005-01-26 15:43:26.767445015 +0100
@@ -1196,10 +1196,20 @@ static void __i810_update_lvi(struct i81
 	if (count < fragsize)
 		return;
 
+	/* if we are currently stopped, then our CIV is actually set to our
+	 * *last* sg segment and we are ready to wrap to the next.  However,
+	 * if we set our LVI to the last sg segment, then it won't wrap to
+	 * the next sg segment, it won't even get a start.  So, instead, when
+	 * we are stopped, we set both the LVI value and also we increment
+	 * the CIV value to the next sg segment to be played so that when
+	 * we call start, things will operate properly
+	 */
 	if (!dmabuf->enable && dmabuf->ready) {
 		if (!(dmabuf->trigger & trigger))
 			return;
 
+		CIV_TO_LVI(state->card, port, 1);
+
 		start(state);
 		while (!(I810_IOREADB(state->card, port + OFF_CR) & ((1<<4) | (1<<2))))
 			;

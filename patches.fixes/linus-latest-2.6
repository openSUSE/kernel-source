diff -purN linux-2.6.1/CREDITS linux-2.5/CREDITS
--- linux-2.6.1/CREDITS	2004-01-09 06:59:47.000000000 +0000
+++ linux-2.5/CREDITS	2004-01-14 20:56:53.000000000 +0000
@@ -1394,7 +1394,9 @@ S: USA
 N: Marcel Holtmann
 E: marcel@holtmann.org
 W: http://www.holtmann.org
+D: Maintainer of the Linux Bluetooth Subsystem
 D: Author and maintainer of the various Bluetooth HCI drivers
+D: Author and maintainer of the CAPI message transport protocol driver
 D: Various other Bluetooth related patches, cleanups and fixes
 S: Germany
 
diff -purN linux-2.6.1/Documentation/networking/ip-sysctl.txt linux-2.5/Documentation/networking/ip-sysctl.txt
--- linux-2.6.1/Documentation/networking/ip-sysctl.txt	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/Documentation/networking/ip-sysctl.txt	2004-01-15 22:15:12.000000000 +0000
@@ -667,6 +667,13 @@ regen_max_retry - INTEGER
 	valid temporary addresses.
 	Default: 5
 
+max_addresses - INTEGER
+	Number of maximum addresses per interface.  0 disables limitation.
+	It is recommended not set too large value (or 0) because it would 
+	be too easy way to crash kernel to allow to create too much of 
+	autoconfigured addresses.
+	Default: 16
+
 icmp/*:
 ratelimit - INTEGER
 	Limit the maximal rates for sending ICMPv6 packets.
diff -purN linux-2.6.1/Documentation/networking/sk98lin.txt linux-2.5/Documentation/networking/sk98lin.txt
--- linux-2.6.1/Documentation/networking/sk98lin.txt	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/Documentation/networking/sk98lin.txt	2004-01-10 16:18:01.000000000 +0000
@@ -2,9 +2,9 @@
 All rights reserved
 ===========================================================================
 
-sk98lin.txt created 23-Sep-2003
+sk98lin.txt created 15-Dec-2003
 
-Readme File for sk98lin v6.18
+Readme File for sk98lin v6.21
 Marvell Yukon/SysKonnect SK-98xx Gigabit Ethernet Adapter family driver for LINUX
 
 This file contains
@@ -466,7 +466,7 @@ The Marvell Yukon/SysKonnect Linux drive
 Link Aggregation according to IEEE standards 802.1, 802.1q, and 802.3ad. 
 These features are only available after installation of open source 
 modules available on the Internet:
-For VLAN go to: http://scry.wanfear.com/~greear/vlan.html
+For VLAN go to: http://www.candelatech.com/~greear/vlan.html
 For Link Aggregation go to: http://www.st.rim.or.jp/~yumo
 
 NOTE: SysKonnect GmbH does not offer any support for these open source 
diff -purN linux-2.6.1/Documentation/scsi/qla2xxx.revision.notes linux-2.5/Documentation/scsi/qla2xxx.revision.notes
--- linux-2.6.1/Documentation/scsi/qla2xxx.revision.notes	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/Documentation/scsi/qla2xxx.revision.notes	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,457 @@
+/*
+ * QLogic ISP2200 and ISP2300 Linux Driver Revision List File.
+ *
+ ********************************************************************
+ *
+ * Revision History
+ *
+ *  Rev  8.00.00b8	December 5, 2003	AV
+ *	- Instruct mid-layer to perform initial scan.
+ *
+ *  Rev  8.00.00b7	December 5, 2003	AV
+ *	- Resync with Linux Kernel 2.6.0-test11.
+ *	- Add basic NVRAM parser (extras/qla_nvr).
+ *
+ *  Rev  8.00.00b7-pre11 December 3, 2003	AV
+ *	- Sanitize the scsi_qla_host structure:
+ *	  - Purge unused elements.
+ *	  - Reorganize high-priority members (cache coherency).
+ *	- Add support for NVRAM access via a sysfs binary attribute:
+ *	  - Consolidate semaphore locking access.
+ *	- Fix more PCI posting issues.
+ *	- Add extras directory for dump/NVRAM tools.
+ *	- Remove unused qla_vendor.c file.
+ *
+ *  Rev  8.00.00b7-pre11 November 26, 2003	DG/AV
+ *	- Merge several patches from Christoph Hellwig [hch@lst.de]:
+ *	  - in Linux 2.6 both pci and the scsi layer use the generic
+ *	    dma direction bits, use them directly instead of the scsi
+ *	    and pci variants and the (noop) conversion routines.
+ *	- Fix _IOXX_BAD() usage for external IOCTL interface.
+ *	- Use atomic construct for HA loop_state member.
+ *	- Add generic model description text for HBA types.
+ *
+ *  Rev  8.00.00b7-pre5	November 17, 2003	AV
+ *	- Merge several patches from Christoph Hellwig [hch@lst.de]:
+ *	  - patch to split the driver into a common qla2xxx.ko and a
+ *	    qla2?00.ko for each HBA type - the latter modules are
+ *	    only very small wrappers, mostly for the firmware
+ *	    images, all the meat is in the common qla2xxx.ko.
+ *	  - make the failover code optional.
+ *	  - kill useless lock_kernel in dpc thread startup.
+ *	  - no need for modversions hacks in 2.6 (or 2.4).
+ *	  - kill qla2x00_register_with_Linux.
+ *	  - simplify EH code, cmd or it's hostdata can't be NULL, no
+ *	    need to search whether the host it's ours, the midlayer
+ *	    makes sure it won't call into a driver for some else
+ *	    host.
+ *	- Merge several patches from Jes Sorensen
+ *	  [jes@wildopensource.com]:
+ *	  - Call qla2x00_config_dma_addressing() before performing
+ *	    any consistent allocations. This is required since the
+ *	    dma mask settings will affect the memory
+ *	    pci_alloc_consistent() will return.
+ *	  - Call pci_set_consistent_dma_mask() to allow for 64 bit
+ *	    consistent allocations, required on some platforms such
+ *	    as the SN2.
+ *	  - Wait 20 usecs (not sure how long is really necessary,
+ *	    but this seems safe) after setting CSR_ISP_SOFT_RESET in
+ *	    the ctrl_status register as the card doesn't respond to
+ *	    PCI reads while in reset state. This causes a machine
+ *	    check on some architectures.
+ *	  - Flush PCI writes before calling udelay() to ensure the
+ *	    write is not sitting idle in-flight for a while before
+ *	    hitting the hardware.
+ *	  - Include linux/vmalloc.h in qla_os.c since it uses
+ *	    vmalloc().
+ *	  - Use auto-negotiate link speed when using default
+ *	    parameters rather than NVRAM settings. Disable NVRAM
+ *	    reading on SN2 since it's not possible to execute the
+ *	    HBA's BIOS on an SN2. I suggest doing something similar
+ *	    for all architectures that do not provide x86 BIOS
+ *	    emulation.
+ *	- Clean-up slab-cache allocations:
+ *	  - locking.
+ *	  - mempool allocations in case of low-memory situations.
+ *	- Fallback to GA_NXT scan if GID_PT call returns more than
+ *	  MAX_FIBRE_DEVICES.
+ *	- Preserve iterating port ID across GA_NXT calls in
+ *	  qla2x00_find_all_fabric_devs().
+ *	- Pre-calculate ASCII firmware dump length as to not incur the
+ *	  cost-to-calculate at each invocation of a read().
+ *
+ *  Rev  8.00.00b6	November 4, 2003	AV
+ *	- Add new 2300 TPX firmware (3.02.18).
+ *
+ *  Rev  8.00.00b6-pre25 October 20, 2003	RA/AV
+ *	- Resync with Linux Kernel 2.6.0-test9.
+ *	- Rework firmware dump process:
+ *	  - Use binary attribute within sysfs tree.
+ *	  - Add user-space tool (gdump.sh) to retrieve formatted
+ *	    buffer.
+ *	  - Add ISP2100 support.
+ *	- Use a slab cache for SRB allocations to reduce memory
+ *	  pressure.
+ *	- Initial conversion of driver logging methods to a new
+ *	  qla_printk() function which uses dev_printk (Daniel
+ *	  Stekloff, IBM).
+ *	- Further reduce stack usage in qla2x00_configure_local_loop()
+ *	  and qla2x00_find_all_fabric_devs().
+ *	- Separate port state used for routing of I/O's from port
+ *	  mgmt-login retry etc.
+ *
+ *  Rev  8.00.00b6-pre19 October 13, 2003	AV
+ *	- Resync with Linux Kernel 2.6.0-test7-bk5.
+ *	- Add intelligent RSCN event handling:
+ *	  - reduce scan time during 'port' RSCN events by only
+ *	    querying specified port ids.
+ *	  - Available on ISP23xx cards only.
+ *	- Increase maximum number of recognizable targets from 256
+ *	  to 512.
+ *	  - Backend changes were previously added to support TPX
+ *	    (2K logins) firmware.  Mid-layer can now scan for targets
+ *	    (H, B, T, L) where 512 < T >= 0.
+ *	- Remove IP support from driver.
+ *	  - Switch firmware types from IP->TP for ISP22xx and
+ *	    IPX->TPX for ISP23xx cards.
+ *	  - Remove files qla_ip.[ch].
+ *	- Remove type designations from firmware filenames.
+ *
+ *  Rev  8.00.00b6-pre11 September 15, 2003	DG/AV
+ *	- Resync with 6.06.00.
+ *	- Resync with Linux Kernel 2.6.0-test5-bk3.
+ *	- Add new 2300 IPX firmware (3.02.15).
+ *
+ *  Rev  8.00.00b5	July 31, 2003		AV
+ *	- Always create an fc_lun_t entry for lun 0 - as the mid-
+ *	  layer requires access to this lun for discovery to occur.
+ *	- General sanitizing:
+ *	  - Add generic firmware option definitions.
+ *	  - Generalize retrieval/update of firmware options.
+ *	  - Fix compile errors which occur with extended debug.
+ *	  - Handle failure cases for scsi_add_host() and
+ *	    down_interruptible().
+ *	- Host template updates:
+ *	  - Use standard bios_param callback function.
+ *	  - Disable clustering.
+ *	  - Remove unchecked_is_dma entry.
+ *
+ *  Rev  8.00.00b5-pre5	July 29, 2003		DG/AV
+ *	- Resync with 6.06.00b13.
+ *	- Resync with Linux Kernel 2.6.0-test2.
+ *	- Pass the complete loop_id, not the masked (0xff) value
+ *	  while issuing mailbox commands (qla_mbx.c/qla_fo.c/
+ *	  qla_iocb.c/qla_init.c).
+ *	- Properly handle zero-length return status for an RLC CDB.
+ *	- Create an fclun_t structure for 'disconnected' luns,
+ *	  peripheral-qualifier of 001b.
+ *	- Remove unused LIP-sequence register access during AE 8010.
+ *	- Generalize qla2x00_mark_device_lost() to handle forced 
+ *	  login request -- modify all direct/indirect invocations 
+ *	  with proper flag.
+ *	- Save RSCN notification (AE 8015h) data in a proper and 
+ *	  consistent format (domain, area, al_pa).
+ *	- General sanitizing:
+ *	  - scsi_qla_host structure member reordering for cache-line
+ *	    coherency.
+ *	  - Remove unused SCSI opcodes, endian-swap definitions.
+ *	  - Remove CMD_* pre-processor defines.
+ *	  - Remove unused SCSIFCHOTSWAP/GAMAP/MULTIHOST codes.
+ *	- Backout patch which added a per-scsi_qla_host scsi host
+ *	  spinlock, since mid-layer already defines one.
+ *	- Add new 2300 IPX firmware (3.02.15).
+ *
+ *  Rev  8.00.00b4	July 14, 2003		RA/DG/AV
+ *	- Resync with 6.06.00b12.
+ *	- Resync with Linux Kernel 2.6.0-test1.
+ *	- Remove IOCB throttling code -- originally #if'd.
+ *	- Remove apidev_*() routines since proc_mknod() has been
+ *	  removed -- need alternate IOCTL interface.
+ *	- Merge several performance/fix patches from Arjan van de
+ *	  Ven:
+ *	  - Undefined operation >> 32.
+ *	  - No need to acquire mid-layer lock during command
+ *	    callback. 
+ *	  - Use a per-HBA mid-layer lock.
+ *	  - Use a non-locked cycle for setting the count of the
+ *	    newly allocated sp (qla2x00_get_new_sp()).
+ *	  - Modify semantic behavior of qla2x00_queuecommand():
+ *	    - Reduce cacheline bouncing by having I/Os submitted
+ *	      by the IRQ handler.
+ *	    - Remove extraneous calls to qla2x00_next() during I/O
+ *	      queuing.
+ *	  - Use list_splice_init() during qla2x00_done() handling
+ *	    of commands to reduce list_lock contention.
+ *	  - RIO mode support for ISP2200:
+ *	    - Implementation differs slightly from original patch.
+ *	  - Do not use bottom-half handler (tasklet/work queue)
+ *	    for qla2x00_done() processing.
+ *
+ *  Rev  8.00.00b4-pre22 July 12, 2003		AV
+ *	- Check for 'Process Response Queue' requests early during
+ *	  the Host Status check.
+ *	- General sanitizing:
+ *	  - srb_t structure rewrite, removal of unused members.
+ *	  - Remove unused fcdev array, fabricid, and PORT_*
+ *	    definitions.
+ *	  - Remove unused config_reg_t PCI definitions.
+ *	- Add new 2200 IP firmware (2.02.06).
+ *	- Add new 2300 IPX firmware (3.02.14).
+ *
+ *  Rev  8.00.00b4-pre19 June 30, 2003		AV
+ *	- Resync with Linux Kernel 2.5.73-bk8.
+ *	- Rework IOCB command queuing methods:
+ *	  - Upper-layer driver *MUST* properly set the direction
+ *	    bit of SCSI commands.
+ *	  - Generalize 32bit/64bit queuing path functions.
+ *	  - Remove costly page-boundary cross check when using
+ *	    64bit address capable IOCBs.
+ *
+ *  Rev  8.00.00b4-pre15 June 19, 2003		AV
+ *	- Resync with 6.06.00b11.
+ *	- Continue fcport list consolidation work:
+ *	  - Updated IOCTL implementations to use new fcports 
+ *	    list.
+ *	- Modified product ID check to not verify ISP chip
+ *	  revision -- ISP2312 v3 (qla2x00_chip_diag()).
+ *	- Add new 2300 IPX firmware (3.02.13):
+ *
+ *  Rev  8.00.00b4-pre13 June 19, 2003		AV
+ *	- Fix build process for qla2100 driver -- no support
+ *	  for IP.
+ *	- SCSI host template modifications:
+ *	  - Set sg_tablesize based on the derived DMA mask.
+ *	  - Increase max_sectors since only limit within RISC
+ *	    is transfer of (((2^32) - 1) >> 9) sectors.
+ *
+ *  Rev  8.00.00b4-pre12 June 18, 2003		RA, DG, RL, AV
+ *	- Resync with 6.06.00b10.
+ *	- Resync with Linux Kernel 2.5.72.
+ *	- Initial fcport list consolidation work:
+ *	  - fcports/fcinitiators/fcdev/fc_ip --> ha->fcports
+ *	    list.
+ *
+ *  Rev  8.00.00b4-pre7	 June 05, 2003		AV
+ *	- Properly release PCI resouces in init-failure case.
+ *	- Reconcile disparite function return code definitions.
+ *
+ *  Rev  8.00.00b4-pre4	 June 03, 2003		AV
+ *	- Resync with Linux Kernel 2.5.70-bk8:
+ *	  - SHT proc_info() changes.
+ *	- Restructure SNS Generic Services routines:
+ *	  - Add qla_gs.c file to driver distribution.
+ *	- Configure PCI latency timer for ISP23xx.
+ *
+ *  Rev  8.00.00b4-pre3	 June 02, 2003		RA, DG, RL, AV
+ *	- Resync with 6.06.00b5.
+ *	- Rework (again) PCI I/O space configuration
+ *	  (Anton Blanchard):
+ *	  - Use pci_set_mwi() routine;
+ *	    - Remove uneeded qla2x00_set_cache_line() function.
+ *	  - Remove extraneous modification of PCI_COMMAND word.
+ *
+ *  Rev  8.00.00b3 	 May 29, 2003		AV
+ *	- Resync with Linux Kernel 2.5.70.
+ *	- Move RISC paused check from ISR fast-path.
+ *
+ *  Rev  8.00.00b3-pre8 May 26, 2003		AV
+ *	- Add new 2300 IPX firmware (3.02.12):
+ *	- Rework PCI I/O space configuration.
+ *
+ *  Rev  8.00.00b3-pre6	May 22, 2003		RA, DG, RL, AV
+ *	- Resync with 6.06.00b3.
+ *
+ *  Rev  8.00.00b3-pre4	May 21 2003		AV
+ *	- Add new 2300 IPX firmware (3.02.11):
+ *	  - Remove 2300 TPX firmware from distribution.
+ *
+ *  Rev  8.00.00b3-pre3	May 21 2003		AV
+ *	- Properly setup PCI configuation space during
+ *	  initialization:
+ *	  - Properly configure Memory-Mapped I/O during early
+ *	    configuration stage.
+ *	- Rework IP functionality to support 2k logins.
+ *	- Add new 2300 IPX firmware (3.02.11):
+ *	  - Remove 2300 TPX firmware from distribution.
+ *
+ *  Rev  8.00.00b3-pre2	May ??, 2003		RA, DG, RL, AV
+ *	- Resync with 6.06.00b1.
+ *
+ *  Rev  8.00.00b3-pre1	May ??, 2003		RA, DG, RL, AV
+ *	- Resync with 6.05.00.
+ *
+ *  Rev  8.00.00b2	May 19, 2003		AV
+ *	- Simplify dma_addr_t handling during command queuing given
+ *	  new block-layer defined restrictions:
+ *	  - Physical addresses not spanning 4GB boundaries.
+ *	- Firmware versions: 2100 TP (1.19.24), 2200 IP (2.02.05),
+ *	  2300 TPX (3.02.10).
+ *
+ *  Rev  8.00.00b2-pre1	May 13, 2003		AV
+ *	- Add support for new 'Hotplug initialization' model. 
+ *	- Simplify host template by removing unused callbacks.
+ *	- Use scsicam facilities to determine geometry.
+ *	- Fix compilation issues for non-ISP23xx builds:
+ *	  - Correct register references in qla_dbg.c.
+ *	  - Correct Makefile build process.
+ *
+ *  Rev  8.00.00b1	May 05, 2003		AV
+ *	- Resync with Linux Kernel 2.5.69.
+ *	- Firmware versions: 2100 TP (1.19.24), 2200 TP (2.02.05),
+ *	  2300 TPX (3.02.10).
+ *
+ *  Rev  8.00.00b1-pre45 April ??, 2003		AV
+ *	- Resync with Linux Kernel 2.5.68-bk11:
+ *	- Fix improper return-code assignment during fabric
+ *	  discovery.
+ *	- Remove additional extraneous #defines from
+ *	  qla_settings.h.
+ *	  - USE_PORTNAME -- FO will always use portname.
+ *	- Default queue depth size set to 64.
+ *
+ *  Rev  8.00.00b1-pre42 April ??, 2003		AV
+ *	- Convert bottom-half tasklet to a work_queue.
+ *	- Initial basic coding of dynamic queue depth handling
+ *	  during QUEUE FULL statuses.
+ *	- Fix mailbox interface problem with
+ *	  qla2x00_get_retry_cnt().
+ *
+ *  Rev  8.00.00b1-pre41 April ??, 2003		AV
+ *	- Convert build defines qla2[1|2|3]00 macros to
+ *	  qla2[1|2|3]xx due to module name stringification clashes.
+ *	- Add additional ISP2322 checks during board configuration.
+ *
+ *  Rev  8.00.00b1-pre40 April ??, 2003		AV
+ *	- Resync with Linux Kernel 2.5.68-bk8:
+ *	  - Updated IRQ handler interface.
+ *	- Add ISP dump code (stub) in case of SYSTEM_ERROR on
+ *	  ISP2100.
+ *	- Add new 2200 IP firmware (2.02.05).
+ *
+ *  Rev  8.00.00b1-pre39 April ??, 2003		AV
+ *	- Resync with Linux Kernel 2.5.68.
+ *	- Add simple build.sh script to aid in external compilation.
+ *	- Clean-break with Kernel 2.4 compatibility.
+ *	  - Rework DPC routine -- completion routines for signaling.
+ *	- Re-add HBAAPI character device node for IOCTL support.
+ *	- Remove residual QLA2X_PERFORMANCE defines.
+ *	- Allocate SP pool via __get_free_pages() rather than
+ *	  individual kmalloc()'s.
+ *	- Inform SCSI mid-layer of 16-byte CDB support
+ *	  (host->max_cmd_len):
+ *	  - Remove unecessary 'more_cdb' handling code from
+ *	    qla_iocb.c and qla_xioct.c.
+ *	- Reduce duplicate code in fabric scanning logic (MS IOCB
+ *	  preparation).
+ *	- Add ISP dump code in case of SYSTEM_ERROR.
+ *	- Remove 2300 VIX firmware from distribution:
+ *	  - Add initial code for IPX support.
+ *	- Add new 2300 TPX firmware (3.02.10).
+ *
+ *  Rev  8.00.00b1-pre34 April ??, 2003		AV
+ *	- Resync with Linux Kernel 2.5.67.
+ *	- Use domain/area/al_pa fields when displaying PortID 
+ *	  values -- addresses endianess issues.
+ *	- Rework large case statement to check 'common' CDB commands
+ *	  early in qla2x00_get_cmd_direction().
+ *
+ *  Rev  8.00.00b1-pre31 April ??, 2003		AV
+ *	- Update makefile to support PPC64 build.
+ *	- Retool NVRAM configuration routine and structures:
+ *	  - Consoldate ISP21xx/ISP22xx/ISP23xx configuration
+ *	    (struct nvram_t).
+ *	  - Remove big/little endian support structures in favor of
+ *	    simplified bit-operations within byte fields.
+ *	- Fix long-standing 'static' buffer sharing problem in 
+ *	  qla2x00_configure_fabric().
+ *
+ *  Rev  8.00.00b1-pre30 April ??, 2003		AV
+ *	- Complete implementation of GID_PT scan.
+ *	- Use consistent MS IOCB invocation method to query SNS:
+ *	  - Add RNN_ID and RSNN_NN registrations in a fabric.
+ *	- Remove unused Mailbox Command 6Eh (Send SNS) support
+ *	  structures.
+ *	- Use 64bit safe IOCBs while issuing INQUIRY and RLC during
+ *	  topology scan.
+ *	- Until reimplementation of fcdev_t/fcport list
+ *	  consolidation, valid loop_id ranges are still limited from
+ *	  0x00 through 0xFF -- enforce this within the code.
+ *
+ *  Rev  8.00.00b1-pre27 March ??, 2003		AV
+ *	- Resync with 6.05.00b9.
+ *	- Retool HBA PCI configuration -- qla2x00_pci_config().
+ *	- Remove inconsistent use of delay routines (UDELAY/SYS*).
+ *	- Continue to teardown/clean/add comments and debug
+ *	  routines.
+ *	- Properly swap bytes of the device's nodename in
+ *	  qla2x00_configure_local_loop().
+ *
+ *  Rev  8.00.00b1-pre25 March ??, 2003		AV
+ *	- Resync with 6.05.00b8.
+ *
+ *  Rev  8.00.00b1-pre23 March ??, 2003		AV
+ *	- Remove (#define) IOCB usage throttling.
+ *	- Abstract interrupt polling with qla2x00_poll().
+ *	- Modify lun scanning logic:
+ *	  - If the device does not support the SCSI Report Luns
+ *	    command, the driver will now only scan from 0 to the
+ *	    max#-luns as defined in the NVRAM (BIOS), rather than
+ *	    blindly scanning from 0 to 255 -- which could result in
+ *	    an increase in startup time when running against slow
+ *	    (JBOD) devices.
+ *	- Rework reset logic in qla2x00_reset_chip() (spec).
+ *
+ *  Rev  8.00.00b1-pre22 March ??, 2003		AV
+ *	- Resync with 6.05.00b7.
+ *	- Cleanup (rewrite) ISR handler.
+ *	- Rename kmem_zalloc --> qla2x00_kmem_zalloc():
+ *	  - This function will eventually be removed.
+ *	- Add new 2300 VIX firmware (3.02.09):
+ *	  - Support for Tape, Fabric, 2K logins, IP, and VI.
+ *
+ *  Rev  8.00.00b1-pre18 March ??, 2003		AV
+ *	- Support 232x type ISPs.
+ *	- Support single firmware for each ISP type:
+ *	  - Restructure brd_info/fw_info methods.
+ *	  - Streamline firmware load process.
+ *	  - Properly query firmware for version information.
+ *	- Remove extraneous scsi_qla_host members:
+ *	  - device_id ==> pdev->device
+ *	- Fix fc4 features (RFF_ID) registration.
+ *	- Convert kmem_zalloc --> qla2x00_kmem_zalloc().
+ *	- Remove unused/extraneous #defines (USE_PORTNAME).
+ *
+ *  Rev  8.00.00b1-pre14 March ??, 2003		AV
+ *	- Resync with 6.05.00b6.
+ *	- Initial source-code restructuring effort.
+ *	  - Build procedure.
+ *	  - Source file layout -- intuitive component layout.
+ *	  - Remove unused #defines (*PERFORMANCE, WORD_FW_LOAD, etc).
+ *	- Add support for 2K logins (TPX -- firmware).
+ *	- Add module parameter ql2xsuspendcount.
+ *	- Add new 2200 IP/TP firmware (2.02.04).
+ *
+ *  Rev  8.00.00b1-pre9	March ??, 2003	RL/DG/RA/AV
+ *	- Use kernel struct list_head for fcport and fclun lists.
+ *	- Remove extraneous (L|M)S_64BITS() and QL21_64*() defines.
+ *
+ *  Rev  8.00.00b1-pre8	February 28, 2003	RL/DG/RA/AV
+ *	- Resync with 6.05.00b3.
+ *
+ *  Rev  8.00.00b1-pre7	February 23, 2003	RL/DG/RA/AV
+ *	- Add alternate fabric scanning logic (GID_PT/GNN_ID/GPN_ID).
+ *	- Remove use of deprecated function check_region().
+ *	- Add new 2300 IP/TP firmware (3.02.08).
+ *
+ *  Rev  8.00.00b1-pre5	January 28, 2003	RL/DG/RA/AV
+ *	- Resync with 6.05.00b3.
+ *	- Consolidate device_reg structure definitions for ISP types.
+ *	- Add support for new queue-depth selection.
+ *	- Add new 2300 IP/TP firmware (3.02.07).
+ *
+ *  Rev  8.00.00b1-pre1	January 17, 2003	AV
+ *	- Initial branch from 6.04.00b8 driver.
+ *	- Remove VMWARE specific code.
+ *	- Add support for pci_driver interface.
+ *
+ ********************************************************************/
diff -purN linux-2.6.1/MAINTAINERS linux-2.5/MAINTAINERS
--- linux-2.6.1/MAINTAINERS	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/MAINTAINERS	2004-01-14 20:56:53.000000000 +0000
@@ -338,35 +338,64 @@ L:	linux-kernel@vger.kernel.org
 S:	Maintained
 
 BLUETOOTH SUBSYSTEM
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
 P:	Maxim Krasnyansky
 M:	maxk@qualcomm.com
+L:	bluez-devel@lists.sf.net
 W:	http://bluez.sf.net
 S:	Maintained
 
 BLUETOOTH RFCOMM LAYER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
 P:	Maxim Krasnyansky
 M:	maxk@qualcomm.com
 W:	http://bluez.sf.net
 S:	Maintained
 
 BLUETOOTH BNEP LAYER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
 P:	Maxim Krasnyansky
 M:	maxk@qualcomm.com
 W:	http://bluez.sf.net
 S:	Maintained
 
+BLUETOOTH CMTP LAYER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
+W:	http://www.holtmann.org/linux/bluetooth/
+S:	Maintained
+
 BLUETOOTH HCI USB DRIVER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
 P:	Maxim Krasnyansky
 M:	maxk@qualcomm.com
 W:	http://bluez.sf.net
 S:	Maintained
 
 BLUETOOTH HCI UART DRIVER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
 P:	Maxim Krasnyansky
 M:	maxk@qualcomm.com
 W:	http://bluez.sf.net
 S:	Maintained
 
+BLUETOOTH HCI BCM203X DRIVER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
+W:	http://www.holtmann.org/linux/bluetooth/
+S:	Maintained
+
+BLUETOOTH HCI BFUSB DRIVER
+P:	Marcel Holtmann
+M:	marcel@holtmann.org
+W:	http://www.holtmann.org/linux/bluetooth/
+S:	Maintained
+
 BLUETOOTH HCI DTL1 DRIVER
 P:	Marcel Holtmann
 M:	marcel@holtmann.org
diff -purN linux-2.6.1/arch/ia64/Kconfig linux-2.5/arch/ia64/Kconfig
--- linux-2.6.1/arch/ia64/Kconfig	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/arch/ia64/Kconfig	2004-01-13 11:51:08.000000000 +0000
@@ -33,6 +33,10 @@ config TIME_INTERPOLATION
 	bool
 	default y
 
+config EFI
+	bool
+	default y
+
 choice
 	prompt "IA-64 processor type"
 	default ITANIUM
@@ -66,26 +70,18 @@ config IA64_GENERIC
 	  will run on any supported IA-64 system.  However, if you configure
 	  a kernel for your specific system, it will be faster and smaller.
 
-	  To find out what type of IA-64 system you have, you may want to
-	  check the IA-64 Linux web site at <http://www.linux-ia64.org/>.
-	  As of the time of this writing, most hardware is DIG compliant,
-	  so the "DIG-compliant" option is usually the right choice.
-
-	  HP-simulator   For the HP simulator
-	  (<http://software.hp.com/ia64linux/>).
-	  HP-zx1         For HP zx1-based systems.
-	  SGI-SN2	 For SGI Altix systems
 	  DIG-compliant  For DIG ("Developer's Interface Guide") compliant
-	  systems.
+	  systems
+	  HP-zx1         For HP systems
+	  SGI-SN2	 For SGI Altix systems
+	  Ski-simulator  For the HP simulator
+	  (<http://www.hpl.hp.com/research/linux/ski/>)
 
 	  If you don't know what to do, choose "generic".
 
 config IA64_DIG
 	bool "DIG-compliant"
 
-config IA64_HP_SIM
-	bool "HP-simulator"
-
 config IA64_HP_ZX1
 	bool "HP-zx1"
 	help
@@ -96,6 +92,9 @@ config IA64_HP_ZX1
 config IA64_SGI_SN2
 	bool "SGI-SN2"
 
+config IA64_HP_SIM
+	bool "Ski-simulator"
+
 endchoice
 
 choice
@@ -395,11 +394,6 @@ config IA64_PALINFO
 	  support" (CONFIG_PROC_FS) is enabled, too.
 
 
-config EFI
-	bool
-	depends on !IA64_HP_SIM
-	default y
-
 config EFI_VARS
 	tristate "/proc/efi/vars support"
 	help
diff -purN linux-2.6.1/arch/ia64/Makefile linux-2.5/arch/ia64/Makefile
--- linux-2.6.1/arch/ia64/Makefile	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/arch/ia64/Makefile	2004-01-16 01:51:26.000000000 +0000
@@ -5,10 +5,11 @@
 # License.  See the file "COPYING" in the main directory of this archive
 # for more details.
 #
-# Copyright (C) 1998-2003 by David Mosberger-Tang <davidm@hpl.hp.com>
+# Copyright (C) 1998-2004 by David Mosberger-Tang <davidm@hpl.hp.com>
 #
 
 NM := $(CROSS_COMPILE)nm -B
+READELF := $(CROSS_COMPILE)readelf
 
 export AWK
 
@@ -25,9 +26,8 @@ CFLAGS_KERNEL	:= -mconstant-gp
 GCC_VERSION=$(shell $(CC) -v 2>&1 | fgrep 'gcc version' | cut -f3 -d' ' | cut -f1 -d'.')
 GCC_MINOR_VERSION=$(shell $(CC) -v 2>&1 | fgrep 'gcc version' | cut -f3 -d' ' | cut -f2 -d'.')
 
-GAS_STATUS=$(shell $(srctree)/arch/ia64/scripts/check-gas $(CC) $(OBJDUMP))
-
-CPPFLAGS	+= $(shell $(srctree)/arch/ia64/scripts/toolchain-flags $(CC) $(OBJDUMP))
+GAS_STATUS	= $(shell $(srctree)/arch/ia64/scripts/check-gas $(CC) $(OBJDUMP))
+CPPFLAGS += $(shell $(srctree)/arch/ia64/scripts/toolchain-flags $(CC) $(OBJDUMP) $(READELF))
 
 ifeq ($(GAS_STATUS),buggy)
 $(error Sorry, you need a newer version of the assember, one that is built from	\
@@ -71,15 +71,15 @@ boot := arch/ia64/hp/sim/boot
 
 .PHONY: boot compressed check
 
-all: compressed
+all: compressed unwcheck
 
 compressed: vmlinux.gz
 
 vmlinux.gz: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $@
 
-check: vmlinux
-	arch/ia64/scripts/unwcheck.sh $<
+unwcheck: vmlinux
+	-$(Q)READELF=$(READELF) $(srctree)/arch/ia64/scripts/unwcheck.py $<
 
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
@@ -88,7 +88,7 @@ CLEAN_FILES += include/asm-ia64/.offsets
 
 prepare: include/asm-ia64/offsets.h
 
-arch/ia64/kernel/asm-offsets.s: include/asm include/linux/version.h
+arch/ia64/kernel/asm-offsets.s: include/asm include/linux/version.h include/config/MARKER
 
 include/asm-ia64/offsets.h: arch/ia64/kernel/asm-offsets.s
 	$(call filechk,gen-asm-offsets)
@@ -108,4 +108,5 @@ boot:	lib/lib.a vmlinux
 define archhelp
   echo '* compressed	- Build compressed kernel image'
   echo '  boot		- Build vmlinux and bootloader for Ski simulator'
+  echo '* unwcheck	- Check vmlinux for invalid unwind info'
 endef
diff -purN linux-2.6.1/arch/ia64/configs/generic_defconfig linux-2.5/arch/ia64/configs/generic_defconfig
--- linux-2.6.1/arch/ia64/configs/generic_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/arch/ia64/configs/generic_defconfig	2004-01-13 01:10:40.000000000 +0000
@@ -0,0 +1,1045 @@
+#
+# Automatically generated make config: don't edit
+#
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=20
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+CONFIG_IA64=y
+CONFIG_64BIT=y
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_TIME_INTERPOLATION=y
+# CONFIG_ITANIUM is not set
+CONFIG_MCKINLEY=y
+CONFIG_IA64_GENERIC=y
+# CONFIG_IA64_DIG is not set
+# CONFIG_IA64_HP_SIM is not set
+# CONFIG_IA64_HP_ZX1 is not set
+# CONFIG_IA64_SGI_SN2 is not set
+# CONFIG_IA64_PAGE_SIZE_4KB is not set
+# CONFIG_IA64_PAGE_SIZE_8KB is not set
+CONFIG_IA64_PAGE_SIZE_16KB=y
+# CONFIG_IA64_PAGE_SIZE_64KB is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_INTERPRETER=y
+CONFIG_ACPI_KERNEL_CONFIG=y
+CONFIG_IA64_L1_CACHE_SHIFT=7
+# CONFIG_MCKINLEY_ASTEP_SPECIFIC is not set
+CONFIG_NUMA=y
+CONFIG_DISCONTIGMEM=y
+CONFIG_VIRTUAL_MEM_MAP=y
+CONFIG_IA64_MCA=y
+CONFIG_PM=y
+CONFIG_IOSAPIC=y
+CONFIG_FORCE_MAX_ZONEORDER=18
+# CONFIG_HUGETLB_PAGE_SIZE_4GB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_1GB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_256MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_64MB is not set
+CONFIG_HUGETLB_PAGE_SIZE_16MB=y
+# CONFIG_HUGETLB_PAGE_SIZE_4MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_1MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_256KB is not set
+# CONFIG_IA64_PAL_IDLE is not set
+CONFIG_SMP=y
+# CONFIG_PREEMPT is not set
+CONFIG_IA32_SUPPORT=y
+CONFIG_COMPAT=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PERFMON=y
+CONFIG_IA64_PALINFO=y
+CONFIG_EFI=y
+CONFIG_EFI_VARS=y
+CONFIG_NR_CPUS=512
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_MISC=m
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+CONFIG_ACPI_BOOT=y
+CONFIG_ACPI_BUTTON=m
+CONFIG_ACPI_FAN=m
+CONFIG_ACPI_PROCESSOR=m
+CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_BUS=y
+CONFIG_ACPI_POWER=y
+CONFIG_ACPI_PCI=y
+CONFIG_ACPI_SYSTEM=y
+# CONFIG_ACPI_RELAXED_AML is not set
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCI Hotplug Support
+#
+CONFIG_HOTPLUG_PCI=m
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+CONFIG_HOTPLUG_PCI_ACPI=m
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+CONFIG_BLK_DEV_IDEFLOPPY=y
+CONFIG_BLK_DEV_IDESCSI=m
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_BLK_DEV_IDEPCI=y
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_IDEDMA_PCI_WIP is not set
+CONFIG_BLK_DEV_ADMA=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+CONFIG_BLK_DEV_CMD64X=y
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_IOCTL_V4=y
+
+#
+# Fusion MPT device support
+#
+CONFIG_FUSION=y
+CONFIG_FUSION_BOOT=y
+CONFIG_FUSION_MAX_SGE=40
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_REPORT_LUNS=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+CONFIG_SCSI_QLOGIC_FC=y
+# CONFIG_SCSI_QLOGIC_FC_FIRMWARE is not set
+CONFIG_SCSI_QLOGIC_1280=y
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_ARPD=y
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+CONFIG_DUMMY=m
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+CONFIG_TULIP=m
+# CONFIG_TULIP_MWI is not set
+# CONFIG_TULIP_MMIO is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_DGRS is not set
+CONFIG_EEPRO100=m
+# CONFIG_EEPRO100_PIO is not set
+CONFIG_E100=m
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=m
+# CONFIG_E1000_NAPI is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+CONFIG_TIGON3=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN_BOOL is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+CONFIG_GAMEPORT=m
+CONFIG_SOUND_GAMEPORT=m
+# CONFIG_GAMEPORT_NS558 is not set
+# CONFIG_GAMEPORT_L4 is not set
+# CONFIG_GAMEPORT_EMU10K1 is not set
+# CONFIG_GAMEPORT_VORTEX is not set
+# CONFIG_GAMEPORT_FM801 is not set
+# CONFIG_GAMEPORT_CS461x is not set
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_STALDRV is not set
+CONFIG_SGI_L1_SERIAL=y
+CONFIG_SGI_L1_SERIAL_CONSOLE=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_ACPI=y
+CONFIG_SERIAL_8250_HCDP=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_RSA is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# I2C Algorithms
+#
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_GEN_RTC is not set
+CONFIG_EFI_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+CONFIG_AGP=m
+CONFIG_AGP_I460=m
+CONFIG_AGP_HP_ZX1=m
+CONFIG_DRM=y
+CONFIG_DRM_TDFX=m
+CONFIG_DRM_GAMMA=m
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+CONFIG_DRM_MGA=m
+CONFIG_DRM_SIS=m
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_XFS_FS=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_TCP=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_SUNRPC=m
+# CONFIG_SUNRPC_GSS is not set
+CONFIG_SMB_FS=m
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+CONFIG_CIFS=m
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_NEC98_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_VERBOSE_PRINTK=y
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+CONFIG_SND_DUMMY=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+
+#
+# PCI devices
+#
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_AZT3328 is not set
+CONFIG_SND_CS46XX=m
+CONFIG_SND_CS46XX_NEW_DSP=y
+CONFIG_SND_CS4281=m
+CONFIG_SND_EMU10K1=m
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_MAESTRO3 is not set
+CONFIG_SND_FM801=m
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VX222 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_OHCI_HCD=m
+CONFIG_USB_UHCI_HCD=m
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_MIDI is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_XPAD is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+
+#
+# HP Simulator drivers
+#
+# CONFIG_HP_SIMETH is not set
+# CONFIG_HP_SIMSERIAL is not set
+# CONFIG_HP_SIMSCSI is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_IA64_GRANULE_16MB=y
+# CONFIG_IA64_GRANULE_64MB is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_IA64_PRINT_HAZARDS is not set
+# CONFIG_DISABLE_VHPT is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_IA64_DEBUG_CMPXCHG is not set
+# CONFIG_IA64_DEBUG_IRQ is not set
+# CONFIG_DEBUG_INFO is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_TEST is not set
diff -purN linux-2.6.1/arch/ia64/configs/sn2_defconfig linux-2.5/arch/ia64/configs/sn2_defconfig
--- linux-2.6.1/arch/ia64/configs/sn2_defconfig	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/arch/ia64/configs/sn2_defconfig	2004-01-05 17:31:29.000000000 +0000
@@ -15,8 +15,6 @@ CONFIG_STANDALONE=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
-CONFIG_PAGG=y
-CONFIG_PAGG_JOB=y
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=20
 # CONFIG_IKCONFIG is not set
@@ -27,6 +25,7 @@ CONFIG_EPOLL=y
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 
 #
 # Loadable module support
@@ -53,7 +52,6 @@ CONFIG_IA64_SGI_SN2=y
 CONFIG_IA64_PAGE_SIZE_16KB=y
 # CONFIG_IA64_PAGE_SIZE_64KB is not set
 CONFIG_ACPI=y
-CONFIG_ACPI_EFI=y
 CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_KERNEL_CONFIG=y
 CONFIG_IA64_L1_CACHE_SHIFT=7
@@ -70,9 +68,10 @@ CONFIG_SMP=y
 # CONFIG_PREEMPT is not set
 CONFIG_IA32_SUPPORT=y
 CONFIG_COMPAT=y
+CONFIG_HAVE_DEC_LOCK=y
 CONFIG_PERFMON=y
 CONFIG_IA64_PALINFO=y
-CONFIG_IA64_SALINFO=y
+CONFIG_EFI=y
 # CONFIG_EFI_VARS is not set
 CONFIG_NR_CPUS=512
 CONFIG_BINFMT_ELF=y
@@ -145,7 +144,60 @@ CONFIG_BLK_DEV_LOOP=y
 #
 # ATA/ATAPI/MFM/RLL support
 #
-# CONFIG_IDE is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDEDISK is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_IDEDMA_PCI_WIP is not set
+CONFIG_BLK_DEV_ADMA=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+CONFIG_BLK_DEV_SGIIOC4=y
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_HD is not set
 
 #
 # IEEE 1394 (FireWire) support (EXPERIMENTAL)
@@ -216,6 +268,7 @@ CONFIG_SCSI_REPORT_LUNS=y
 # CONFIG_SCSI_QLOGIC_FC is not set
 CONFIG_SCSI_QLOGIC_1280=y
 # CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
 # CONFIG_SCSI_DEBUG is not set
 
@@ -585,11 +638,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
 CONFIG_EFI_PARTITION=y
-CONFIG_NLS=y
 
 #
 # Native Language Support
 #
+CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_CODEPAGE_437 is not set
 # CONFIG_NLS_CODEPAGE_737 is not set
diff -purN linux-2.6.1/arch/ia64/hp/common/sba_iommu.c linux-2.5/arch/ia64/hp/common/sba_iommu.c
--- linux-2.6.1/arch/ia64/hp/common/sba_iommu.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/arch/ia64/hp/common/sba_iommu.c	2004-01-12 16:02:23.000000000 +0000
@@ -1,9 +1,9 @@
 /*
 **  IA64 System Bus Adapter (SBA) I/O MMU manager
 **
-**	(c) Copyright 2002-2003 Alex Williamson
+**	(c) Copyright 2002-2004 Alex Williamson
 **	(c) Copyright 2002-2003 Grant Grundler
-**	(c) Copyright 2002-2003 Hewlett-Packard Company
+**	(c) Copyright 2002-2004 Hewlett-Packard Company
 **
 **	Portions (c) 2000 Grant Grundler (from parisc I/O MMU code)
 **	Portions (c) 1999 Dave S. Miller (from sparc64 I/O MMU code)
@@ -39,12 +39,19 @@
 #include <asm/page.h>		/* PAGE_OFFSET */
 #include <asm/dma.h>
 #include <asm/system.h>		/* wmb() */
+#include <asm/bitops.h>		/* hweight64() */
 
 #include <asm/acpi-ext.h>
 
 #define PFX "IOC: "
 
 /*
+** Enabling timing search of the pdir resource map.  Output in /proc.
+** Disabled by default to optimize performance.
+*/
+#undef PDIR_SEARCH_TIMING
+
+/*
 ** This option allows cards capable of 64bit DMA to bypass the IOMMU.  If
 ** not defined, all DMA will be 32bit and go through the TLB.
 ** There's potentially a conflict in the bio merge code with us
@@ -54,11 +61,6 @@
 */
 #define ALLOW_IOV_BYPASS
 
-#ifdef CONFIG_PROC_FS
-  /* turn it off for now; without per-CPU counters, it's too much of a scalability bottleneck: */
-# define SBA_PROC_FS 0
-#endif
-
 /*
 ** If a device prefetches beyond the end of a valid pdir entry, it will cause
 ** a hard failure, ie. MCA.  Version 3.0 and later of the zx1 LBA should
@@ -160,21 +162,18 @@
 #define ZX1_SBA_IOMMU_COOKIE	0x0000badbadc0ffeeUL
 
 /*
-** IOC supports 4/8/16/64KB page sizes (see TCNFG register)
-** It's safer (avoid memory corruption) to keep DMA page mappings
-** equivalently sized to VM PAGE_SIZE.
+** The zx1 IOC supports 4/8/16/64KB page sizes (see TCNFG register)
 **
-** We really can't avoid generating a new mapping for each
-** page since the Virtual Coherence Index has to be generated
-** and updated for each page.
+** Some IOCs (sx1000) can run at the above pages sizes, but are
+** really only supported using the IOC at a 4k page size.
 **
-** IOVP_SIZE could only be greater than PAGE_SIZE if we are
+** iovp_size could only be greater than PAGE_SIZE if we are
 ** confident the drivers really only touch the next physical
 ** page iff that driver instance owns it.
 */
-#define IOVP_SIZE	PAGE_SIZE
-#define IOVP_SHIFT	PAGE_SHIFT
-#define IOVP_MASK	PAGE_MASK
+static unsigned long iovp_size;
+static unsigned long iovp_shift;
+static unsigned long iovp_mask;
 
 struct ioc {
 	void		*ioc_hpa;	/* I/O MMU base address */
@@ -198,24 +197,10 @@ struct ioc {
 	} saved[DELAYED_RESOURCE_CNT];
 #endif
 
-#if SBA_PROC_FS
+#ifdef PDIR_SEARCH_TIMING
 #define SBA_SEARCH_SAMPLE	0x100
 	unsigned long avg_search[SBA_SEARCH_SAMPLE];
 	unsigned long avg_idx;	/* current index into avg_search */
-	unsigned long used_pages;
-	unsigned long msingle_calls;
-	unsigned long msingle_pages;
-	unsigned long msg_calls;
-	unsigned long msg_pages;
-	unsigned long usingle_calls;
-	unsigned long usingle_pages;
-	unsigned long usg_calls;
-	unsigned long usg_pages;
-#ifdef ALLOW_IOV_BYPASS
-	unsigned long msingle_bypass;
-	unsigned long usingle_bypass;
-	unsigned long msg_bypass;
-#endif
 #endif
 
 	/* Stuff we don't need in performance path */
@@ -252,7 +237,7 @@ static u64 prefetch_spill_page;
 ** rather than the HW. I/O MMU allocation alogorithms can be
 ** faster with smaller size is (to some degree).
 */
-#define DMA_CHUNK_SIZE  (BITS_PER_LONG*PAGE_SIZE)
+#define DMA_CHUNK_SIZE  (BITS_PER_LONG*iovp_size)
 
 #define ROUNDUP(x,y) ((x + ((y)-1)) & ~((y)-1))
 
@@ -416,18 +401,37 @@ sba_check_sg( struct ioc *ioc, struct sc
 #define PAGES_PER_RANGE 1	/* could increase this to 4 or 8 if needed */
 
 /* Convert from IOVP to IOVA and vice versa. */
-#define SBA_IOVA(ioc,iovp,offset,hint_reg) ((ioc->ibase) | (iovp) | (offset) |		\
-					    ((hint_reg)<<(ioc->hint_shift_pdir)))
-#define SBA_IOVP(ioc,iova) (((iova) & ioc->hint_mask_pdir) & ~(ioc->ibase))
+#define SBA_IOVA(ioc,iovp,offset,hint_reg) ((ioc->ibase) | (iovp) | (offset))
+#define SBA_IOVP(ioc,iova) ((iova) & ~(ioc->ibase))
 
-/* FIXME : review these macros to verify correctness and usage */
-#define PDIR_INDEX(iovp)   ((iovp)>>IOVP_SHIFT)
+#define PDIR_ENTRY_SIZE	sizeof(u64)
+
+#define PDIR_INDEX(iovp)   ((iovp)>>iovp_shift)
 
 #define RESMAP_MASK(n)    ~(~0UL << (n))
 #define RESMAP_IDX_MASK   (sizeof(unsigned long) - 1)
 
 
 /**
+ * For most cases the normal get_order is sufficient, however it limits us
+ * to PAGE_SIZE being the minimum mapping alignment and TC flush granularity.
+ * It only incurs about 1 clock cycle to use this one with the static variable
+ * and makes the code more intuitive.
+ */
+static SBA_INLINE int
+get_iovp_order (unsigned long size)
+{
+	long double d = size - 1;
+	long order;
+
+	order = ia64_getf_exp(d);
+	order = order - iovp_shift - 0xffff + 1;
+	if (order < 0)
+		order = 0;
+	return order;
+}
+
+/**
  * sba_search_bitmap - find free space in IO PDIR resource bitmap
  * @ioc: IO MMU structure which owns the pdir we are interested in.
  * @bits_wanted: number of entries we need.
@@ -465,7 +469,7 @@ sba_search_bitmap(struct ioc *ioc, unsig
 		** We need the alignment to invalidate I/O TLB using
 		** SBA HW features in the unmap path.
 		*/
-		unsigned long o = 1 << get_order(bits_wanted << PAGE_SHIFT);
+		unsigned long o = 1 << get_iovp_order(bits_wanted << iovp_shift);
 		uint bitshiftcnt = ROUNDUP(ioc->res_bitshift, o);
 		unsigned long mask;
 
@@ -521,16 +525,15 @@ sba_search_bitmap(struct ioc *ioc, unsig
 static int
 sba_alloc_range(struct ioc *ioc, size_t size)
 {
-	unsigned int pages_needed = size >> IOVP_SHIFT;
-#if SBA_PROC_FS
+	unsigned int pages_needed = size >> iovp_shift;
+#ifdef PDIR_SEARCH_TIMING
 	unsigned long itc_start = ia64_get_itc();
 #endif
 	unsigned long pide;
 
 	ASSERT(pages_needed);
-	ASSERT((pages_needed * IOVP_SIZE) <= DMA_CHUNK_SIZE);
 	ASSERT(pages_needed <= BITS_PER_LONG);
-	ASSERT(0 == (size & ~IOVP_MASK));
+	ASSERT(0 == (size & ~iovp_mask));
 
 	/*
 	** "seek and ye shall find"...praying never hurts either...
@@ -546,7 +549,7 @@ sba_alloc_range(struct ioc *ioc, size_t 
 
 #ifdef ASSERT_PDIR_SANITY
 	/* verify the first enable bit is clear */
-	if(0x00 != ((u8 *) ioc->pdir_base)[pide*sizeof(u64) + 7]) {
+	if(0x00 != ((u8 *) ioc->pdir_base)[pide*PDIR_ENTRY_SIZE + 7]) {
 		sba_dump_pdir_entry(ioc, "sba_search_bitmap() botched it?", pide);
 	}
 #endif
@@ -556,17 +559,9 @@ sba_alloc_range(struct ioc *ioc, size_t 
 		(uint) ((unsigned long) ioc->res_hint - (unsigned long) ioc->res_map),
 		ioc->res_bitshift );
 
-#if SBA_PROC_FS
-	{
-		unsigned long itc_end = ia64_get_itc();
-		unsigned long tmp = itc_end - itc_start;
-		/* check for roll over */
-		itc_start = (itc_end < itc_start) ?  -(tmp) : (tmp);
-	}
-	ioc->avg_search[ioc->avg_idx++] = itc_start;
+#ifdef PDIR_SEARCH_TIMING
+	ioc->avg_search[ioc->avg_idx++] = ia64_get_itc() - itc_start;
 	ioc->avg_idx &= SBA_SEARCH_SAMPLE - 1;
-
-	ioc->used_pages += pages_needed;
 #endif
 
 	return (pide);
@@ -589,7 +584,7 @@ sba_free_range(struct ioc *ioc, dma_addr
 	unsigned int ridx = pide >> 3;	/* convert bit to byte address */
 	unsigned long *res_ptr = (unsigned long *) &((ioc)->res_map[ridx & ~RESMAP_IDX_MASK]);
 
-	int bits_not_wanted = size >> IOVP_SHIFT;
+	int bits_not_wanted = size >> iovp_shift;
 
 	/* 3-bits "bit" address plus 2 (or 3) bits for "byte" == bit in word */
 	unsigned long m = RESMAP_MASK(bits_not_wanted) << (pide & (BITS_PER_LONG - 1));
@@ -598,13 +593,9 @@ sba_free_range(struct ioc *ioc, dma_addr
 		__FUNCTION__, (uint) iova, size,
 		bits_not_wanted, m, pide, res_ptr, *res_ptr);
 
-#if SBA_PROC_FS
-	ioc->used_pages -= bits_not_wanted;
-#endif
-
 	ASSERT(m != 0);
 	ASSERT(bits_not_wanted);
-	ASSERT((bits_not_wanted * IOVP_SIZE) <= DMA_CHUNK_SIZE);
+	ASSERT((bits_not_wanted * iovp_size) <= DMA_CHUNK_SIZE);
 	ASSERT(bits_not_wanted <= BITS_PER_LONG);
 	ASSERT((*res_ptr & m) == m); /* verify same bits are set */
 	*res_ptr &= ~m;
@@ -702,7 +693,7 @@ sba_mark_invalid(struct ioc *ioc, dma_ad
 
 	/* Must be non-zero and rounded up */
 	ASSERT(byte_cnt > 0);
-	ASSERT(0 == (byte_cnt & ~IOVP_MASK));
+	ASSERT(0 == (byte_cnt & ~iovp_mask));
 
 #ifdef ASSERT_PDIR_SANITY
 	/* Assert first pdir entry is set */
@@ -711,11 +702,11 @@ sba_mark_invalid(struct ioc *ioc, dma_ad
 	}
 #endif
 
-	if (byte_cnt <= IOVP_SIZE)
+	if (byte_cnt <= iovp_size)
 	{
 		ASSERT(off < ioc->pdir_size);
 
-		iovp |= IOVP_SHIFT;     /* set "size" field for PCOM */
+		iovp |= iovp_shift;     /* set "size" field for PCOM */
 
 #ifndef FULL_VALID_PDIR
 		/*
@@ -734,7 +725,7 @@ sba_mark_invalid(struct ioc *ioc, dma_ad
 		ioc->pdir_base[off] = (0x80000000000000FFULL | prefetch_spill_page);
 #endif
 	} else {
-		u32 t = get_order(byte_cnt) + PAGE_SHIFT;
+		u32 t = get_iovp_order(byte_cnt) + iovp_shift;
 
 		iovp |= t;
 		ASSERT(t <= 31);   /* 2GB! Max value of "size" field */
@@ -749,7 +740,7 @@ sba_mark_invalid(struct ioc *ioc, dma_ad
 			ioc->pdir_base[off] = (0x80000000000000FFULL | prefetch_spill_page);
 #endif
 			off++;
-			byte_cnt -= IOVP_SIZE;
+			byte_cnt -= iovp_size;
 		} while (byte_cnt > 0);
 	}
 
@@ -790,11 +781,6 @@ sba_map_single(struct device *dev, void 
  		** Device is bit capable of DMA'ing to the buffer...
 		** just return the PCI address of ptr
  		*/
-#if SBA_PROC_FS
-		spin_lock_irqsave(&ioc->res_lock, flags);
-		ioc->msingle_bypass++;
-		spin_unlock_irqrestore(&ioc->res_lock, flags);
-#endif
 		DBG_BYPASS("sba_map_single() bypass mask/addr: 0x%lx/0x%lx\n",
 		           *dev->dma_mask, pci_addr);
 		return pci_addr;
@@ -805,10 +791,10 @@ sba_map_single(struct device *dev, void 
 	ASSERT(size <= DMA_CHUNK_SIZE);
 
 	/* save offset bits */
-	offset = ((dma_addr_t) (long) addr) & ~IOVP_MASK;
+	offset = ((dma_addr_t) (long) addr) & ~iovp_mask;
 
-	/* round up to nearest IOVP_SIZE */
-	size = (size + offset + ~IOVP_MASK) & IOVP_MASK;
+	/* round up to nearest iovp_size */
+	size = (size + offset + ~iovp_mask) & iovp_mask;
 
 	spin_lock_irqsave(&ioc->res_lock, flags);
 #ifdef ASSERT_PDIR_SANITY
@@ -816,12 +802,8 @@ sba_map_single(struct device *dev, void 
 		panic("Sanity check failed");
 #endif
 
-#if SBA_PROC_FS
-	ioc->msingle_calls++;
-	ioc->msingle_pages += size >> IOVP_SHIFT;
-#endif
 	pide = sba_alloc_range(ioc, size);
-	iovp = (dma_addr_t) pide << IOVP_SHIFT;
+	iovp = (dma_addr_t) pide << iovp_shift;
 
 	DBG_RUN("%s() 0x%p -> 0x%lx\n",
 		__FUNCTION__, addr, (long) iovp | offset);
@@ -834,8 +816,8 @@ sba_map_single(struct device *dev, void 
 
 		DBG_RUN("     pdir 0x%p %lx\n", pdir_start, *pdir_start);
 
-		addr += IOVP_SIZE;
-		size -= IOVP_SIZE;
+		addr += iovp_size;
+		size -= iovp_size;
 		pdir_start++;
 	}
 	/* force pdir update */
@@ -875,11 +857,6 @@ void sba_unmap_single(struct device *dev
 		/*
 		** Address does not fall w/in IOVA, must be bypassing
 		*/
-#if SBA_PROC_FS
-		spin_lock_irqsave(&ioc->res_lock, flags);
-		ioc->usingle_bypass++;
-		spin_unlock_irqrestore(&ioc->res_lock, flags);
-#endif
 		DBG_BYPASS("sba_unmap_single() bypass addr: 0x%lx\n", iova);
 
 #ifdef ENABLE_MARK_CLEAN
@@ -890,20 +867,16 @@ void sba_unmap_single(struct device *dev
 		return;
 	}
 #endif
-	offset = iova & ~IOVP_MASK;
+	offset = iova & ~iovp_mask;
 
 	DBG_RUN("%s() iovp 0x%lx/%x\n",
 		__FUNCTION__, (long) iova, size);
 
 	iova ^= offset;        /* clear offset bits */
 	size += offset;
-	size = ROUNDUP(size, IOVP_SIZE);
+	size = ROUNDUP(size, iovp_size);
 
 	spin_lock_irqsave(&ioc->res_lock, flags);
-#if SBA_PROC_FS
-	ioc->usingle_calls++;
-	ioc->usingle_pages += size >> IOVP_SHIFT;
-#endif
 
 #if DELAYED_RESOURCE_CNT > 0
 	d = &(ioc->saved[ioc->saved_cnt]);
@@ -930,7 +903,7 @@ void sba_unmap_single(struct device *dev
 		int off = PDIR_INDEX(iovp);
 		void *addr;
 
-		if (size <= IOVP_SIZE) {
+		if (size <= iovp_size) {
 			addr = phys_to_virt(ioc->pdir_base[off] &
 					    ~0xE000000000000FFFULL);
 			mark_clean(addr, size);
@@ -940,9 +913,9 @@ void sba_unmap_single(struct device *dev
 			do {
 				addr = phys_to_virt(ioc->pdir_base[off] &
 				                    ~0xE000000000000FFFULL);
-				mark_clean(addr, min(byte_cnt, IOVP_SIZE));
+				mark_clean(addr, min(byte_cnt, iovp_size));
 				off++;
-				byte_cnt -= IOVP_SIZE;
+				byte_cnt -= iovp_size;
 
 			   } while (byte_cnt > 0);
 		}
@@ -1061,11 +1034,11 @@ sba_fill_pdir(
 		*/
 		if (startsg->dma_address & PIDE_FLAG) {
 			u32 pide = startsg->dma_address & ~PIDE_FLAG;
-			dma_offset = (unsigned long) pide & ~IOVP_MASK;
+			dma_offset = (unsigned long) pide & ~iovp_mask;
 			startsg->dma_address = 0;
 			dma_sg++;
 			dma_sg->dma_address = pide | ioc->ibase;
-			pdirp = &(ioc->pdir_base[pide >> IOVP_SHIFT]);
+			pdirp = &(ioc->pdir_base[pide >> iovp_shift]);
 			n_mappings++;
 		}
 
@@ -1082,14 +1055,11 @@ sba_fill_pdir(
 			dma_sg->dma_length += cnt;
 			cnt += dma_offset;
 			dma_offset=0;	/* only want offset on first chunk */
-			cnt = ROUNDUP(cnt, IOVP_SIZE);
-#if SBA_PROC_FS
-			ioc->msg_pages += cnt >> IOVP_SHIFT;
-#endif
+			cnt = ROUNDUP(cnt, iovp_size);
 			do {
 				sba_io_pdir_entry(pdirp, vaddr);
-				vaddr += IOVP_SIZE;
-				cnt -= IOVP_SIZE;
+				vaddr += iovp_size;
+				cnt -= iovp_size;
 				pdirp++;
 			} while (cnt > 0);
 		}
@@ -1107,12 +1077,12 @@ sba_fill_pdir(
 
 /*
 ** Two address ranges are DMA contiguous *iff* "end of prev" and
-** "start of next" are both on a page boundry.
+** "start of next" are both on an IOV page boundary.
 **
 ** (shift left is a quick trick to mask off upper bits)
 */
 #define DMA_CONTIG(__X, __Y) \
-	(((((unsigned long) __X) | ((unsigned long) __Y)) << (BITS_PER_LONG - PAGE_SHIFT)) == 0UL)
+	(((((unsigned long) __X) | ((unsigned long) __Y)) << (BITS_PER_LONG - iovp_shift)) == 0UL)
 
 
 /**
@@ -1150,7 +1120,7 @@ sba_coalesce_chunks( struct ioc *ioc,
 		dma_sg = vcontig_sg = startsg;
 		dma_len = vcontig_len = vcontig_end = startsg->length;
 		vcontig_end +=  vaddr;
-		dma_offset = vaddr & ~IOVP_MASK;
+		dma_offset = vaddr & ~iovp_mask;
 
 		/* PARANOID: clear entries */
 		startsg->dma_address = startsg->dma_length = 0;
@@ -1175,7 +1145,7 @@ sba_coalesce_chunks( struct ioc *ioc,
 			** exceed DMA_CHUNK_SIZE if we coalesce the
 			** next entry.
 			*/
-			if (((dma_len + dma_offset + startsg->length + ~IOVP_MASK) & IOVP_MASK)
+			if (((dma_len + dma_offset + startsg->length + ~iovp_mask) & iovp_mask)
 			    > DMA_CHUNK_SIZE)
 				break;
 
@@ -1194,7 +1164,7 @@ sba_coalesce_chunks( struct ioc *ioc,
 			}
 
 #ifdef DEBUG_LARGE_SG_ENTRIES
-			dump_run_sg = (vcontig_len > IOVP_SIZE);
+			dump_run_sg = (vcontig_len > iovp_size);
 #endif
 
 			/*
@@ -1233,10 +1203,10 @@ sba_coalesce_chunks( struct ioc *ioc,
 		** Allocate space for DMA stream.
 		*/
 		vcontig_sg->dma_length = vcontig_len;
-		dma_len = (dma_len + dma_offset + ~IOVP_MASK) & IOVP_MASK;
+		dma_len = (dma_len + dma_offset + ~iovp_mask) & iovp_mask;
 		ASSERT(dma_len <= DMA_CHUNK_SIZE);
 		dma_sg->dma_address = (dma_addr_t) (PIDE_FLAG
-			| (sba_alloc_range(ioc, dma_len) << IOVP_SHIFT)
+			| (sba_alloc_range(ioc, dma_len) << iovp_shift)
 			| dma_offset);
 		n_mappings++;
 	}
@@ -1273,11 +1243,6 @@ int sba_map_sg(struct device *dev, struc
 			sg->dma_length = sg->length;
 			sg->dma_address = virt_to_phys(sba_sg_address(sg));
 		}
-#if SBA_PROC_FS
-		spin_lock_irqsave(&ioc->res_lock, flags);
-		ioc->msg_bypass++;
-		spin_unlock_irqrestore(&ioc->res_lock, flags);
-#endif
 		return filled;
 	}
 #endif
@@ -1285,13 +1250,7 @@ int sba_map_sg(struct device *dev, struc
 	if (nents == 1) {
 		sglist->dma_length = sglist->length;
 		sglist->dma_address = sba_map_single(dev, sba_sg_address(sglist), sglist->length,
-						     dir);
-#if SBA_PROC_FS
-		/*
-		** Should probably do some stats counting, but trying to
-		** be precise quickly starts wasting CPU time.
-		*/
-#endif
+		                                     dir);
 		return 1;
 	}
 
@@ -1305,10 +1264,6 @@ int sba_map_sg(struct device *dev, struc
 	}
 #endif
 
-#if SBA_PROC_FS
-	ioc->msg_calls++;
-#endif
-
 	/*
 	** First coalesce the chunks and allocate I/O pdir space
 	**
@@ -1368,10 +1323,6 @@ void sba_unmap_sg (struct device *dev, s
 	ioc = GET_IOC(dev);
 	ASSERT(ioc);
 
-#if SBA_PROC_FS
-	ioc->usg_calls++;
-#endif
-
 #ifdef ASSERT_PDIR_SANITY
 	spin_lock_irqsave(&ioc->res_lock, flags);
 	sba_check_pdir(ioc,"Check before sba_unmap_sg()");
@@ -1381,16 +1332,6 @@ void sba_unmap_sg (struct device *dev, s
 	while (nents && sglist->dma_length) {
 
 		sba_unmap_single(dev, sglist->dma_address, sglist->dma_length, dir);
-#if SBA_PROC_FS
-		/*
-		** This leaves inconsistent data in the stats, but we can't
-		** tell which sg lists were mapped by map_single and which
-		** were coalesced to a single entry.  The stats are fun,
-		** but speed is more important.
-		*/
-		ioc->usg_pages += ((sglist->dma_address & ~IOVP_MASK) + sglist->dma_length
-				   + IOVP_SIZE - 1) >> PAGE_SHIFT;
-#endif
 		sglist++;
 		nents--;
 	}
@@ -1414,8 +1355,7 @@ void sba_unmap_sg (struct device *dev, s
 static void __init
 ioc_iova_init(struct ioc *ioc)
 {
-	u32 iova_space_mask;
-	int iov_order, tcnfg;
+	int tcnfg;
 	int agp_found = 0;
 	struct pci_dev *device = NULL;
 #ifdef FULL_VALID_PDIR
@@ -1428,23 +1368,27 @@ ioc_iova_init(struct ioc *ioc)
 	** IBASE and IMASK registers.
 	*/
 	ioc->ibase = READ_REG(ioc->ioc_hpa + IOC_IBASE) & ~0x1UL;
-	ioc->iov_size = ~(READ_REG(ioc->ioc_hpa + IOC_IMASK) & 0xFFFFFFFFUL) + 1;
+	ioc->imask = READ_REG(ioc->ioc_hpa + IOC_IMASK) | 0xFFFFFFFF00000000UL;
 
-	/*
-	** iov_order is always based on a 1GB IOVA space since we want to
-	** turn on the other half for AGP GART.
-	*/
-	iov_order = get_order(ioc->iov_size >> (IOVP_SHIFT - PAGE_SHIFT));
-	ioc->pdir_size = (ioc->iov_size / IOVP_SIZE) * sizeof(u64);
+	ioc->iov_size = ~ioc->imask + 1;
 
-	DBG_INIT("%s() hpa %p IOV %dMB (%d bits) PDIR size 0x%x\n",
-		 __FUNCTION__, ioc->ioc_hpa, ioc->iov_size >> 20,
-		 iov_order + PAGE_SHIFT, ioc->pdir_size);
-
-	/* FIXME : DMA HINTs not used */
-	ioc->hint_shift_pdir = iov_order + PAGE_SHIFT;
-	ioc->hint_mask_pdir = ~(0x3 << (iov_order + PAGE_SHIFT));
+	DBG_INIT("%s() hpa %p IOV base 0x%lx mask 0x%lx (%dMB)\n",
+		__FUNCTION__, ioc->ioc_hpa, ioc->ibase, ioc->imask,
+		ioc->iov_size >> 20);
+
+	switch (iovp_size) {
+		case  4*1024: tcnfg = 0; break;
+		case  8*1024: tcnfg = 1; break;
+		case 16*1024: tcnfg = 2; break;
+		case 64*1024: tcnfg = 3; break;
+		default:
+			panic(PFX "Unsupported IOTLB page size %ldK",
+				iovp_size >> 10);
+			break;
+	}
+	WRITE_REG(tcnfg, ioc->ioc_hpa + IOC_TCNFG);
 
+	ioc->pdir_size = (ioc->iov_size / iovp_size) * PDIR_ENTRY_SIZE;
 	ioc->pdir_base = (void *) __get_free_pages(GFP_KERNEL,
 						   get_order(ioc->pdir_size));
 	if (!ioc->pdir_base)
@@ -1452,61 +1396,12 @@ ioc_iova_init(struct ioc *ioc)
 
 	memset(ioc->pdir_base, 0, ioc->pdir_size);
 
-	DBG_INIT("%s() pdir %p size %x hint_shift_pdir %x hint_mask_pdir %lx\n",
-		__FUNCTION__, ioc->pdir_base, ioc->pdir_size,
-		ioc->hint_shift_pdir, ioc->hint_mask_pdir);
+	DBG_INIT("%s() IOV page size %ldK pdir %p size %x\n", __FUNCTION__,
+		iovp_size >> 10, ioc->pdir_base, ioc->pdir_size);
 
-	ASSERT((((unsigned long) ioc->pdir_base) & PAGE_MASK) == (unsigned long) ioc->pdir_base);
+	ASSERT(ALIGN((unsigned long) ioc->pdir_base, 4*1024) == (unsigned long) ioc->pdir_base);
 	WRITE_REG(virt_to_phys(ioc->pdir_base), ioc->ioc_hpa + IOC_PDIR_BASE);
 
-	DBG_INIT(" base %p\n", ioc->pdir_base);
-
-	/* build IMASK for IOC and Elroy */
-	iova_space_mask =  0xffffffff;
-	iova_space_mask <<= (iov_order + PAGE_SHIFT);
-	ioc->imask = iova_space_mask;
-
-	DBG_INIT("%s() IOV base 0x%lx mask 0x%0lx\n",
-		__FUNCTION__, ioc->ibase, ioc->imask);
-
-	/*
-	** FIXME: Hint registers are programmed with default hint
-	** values during boot, so hints should be sane even if we
-	** can't reprogram them the way drivers want.
-	*/
-	WRITE_REG(ioc->imask, ioc->ioc_hpa + IOC_IMASK);
-
-	/*
-	** Setting the upper bits makes checking for bypass addresses
-	** a little faster later on.
-	*/
-	ioc->imask |= 0xFFFFFFFF00000000UL;
-
-	/* Set I/O PDIR Page size to system page size */
-	switch (PAGE_SHIFT) {
-		case 12: tcnfg = 0; break;	/*  4K */
-		case 13: tcnfg = 1; break;	/*  8K */
-		case 14: tcnfg = 2; break;	/* 16K */
-		case 16: tcnfg = 3; break;	/* 64K */
-		default:
-			panic(PFX "Unsupported system page size %d",
-				1 << PAGE_SHIFT);
-			break;
-	}
-	WRITE_REG(tcnfg, ioc->ioc_hpa + IOC_TCNFG);
-
-	/*
-	** Program the IOC's ibase and enable IOVA translation
-	** Bit zero == enable bit.
-	*/
-	WRITE_REG(ioc->ibase | 1, ioc->ioc_hpa + IOC_IBASE);
-
-	/*
-	** Clear I/O TLB of any possible entries.
-	** (Yes. This is a bit paranoid...but so what)
-	*/
-	WRITE_REG(ioc->ibase | (iov_order+PAGE_SHIFT), ioc->ioc_hpa + IOC_PCOM);
-
 	/*
 	** If an AGP device is present, only use half of the IOV space
 	** for PCI DMA.  Unfortunately we can't know ahead of time
@@ -1519,8 +1414,8 @@ ioc_iova_init(struct ioc *ioc)
 		agp_found |= pci_find_capability(device, PCI_CAP_ID_AGP);
 
 	if (agp_found && reserve_sba_gart) {
-		DBG_INIT("%s: AGP device found, reserving half of IOVA for GART support\n",
-			 __FUNCTION__);
+		printk(KERN_INFO PFX "reserving %dMb of IOVA space at 0x%lx for agpgart\n",
+		      ioc->iov_size/2 >> 20, ioc->ibase + ioc->iov_size/2);
 		ioc->pdir_size /= 2;
 		((u64 *)ioc->pdir_base)[PDIR_INDEX(ioc->iov_size/2)] = ZX1_SBA_IOMMU_COOKIE;
 	}
@@ -1534,12 +1429,12 @@ ioc_iova_init(struct ioc *ioc)
 		int poison_size = 16;
 		void *poison_addr, *addr;
 
-		addr = (void *)__get_free_pages(GFP_KERNEL, get_order(IOVP_SIZE));
+		addr = (void *)__get_free_pages(GFP_KERNEL, get_order(iovp_size));
 		if (!addr)
 			panic(PFX "Couldn't allocate PDIR spill page\n");
 
 		poison_addr = addr;
-		for ( ; (u64) poison_addr < addr + IOVP_SIZE; poison_addr += poison_size)
+		for ( ; (u64) poison_addr < addr + iovp_size; poison_addr += poison_size)
 			memcpy(poison_addr, spill_poison, poison_size);
 
 		prefetch_spill_page = virt_to_phys(addr);
@@ -1549,10 +1444,17 @@ ioc_iova_init(struct ioc *ioc)
 	/*
   	** Set all the PDIR entries valid w/ the spill page as the target
 	*/
-	for (index = 0 ; index < (ioc->pdir_size / sizeof(u64)) ; index++)
+	for (index = 0 ; index < (ioc->pdir_size / PDIR_ENTRY_SIZE) ; index++)
 		((u64 *)ioc->pdir_base)[index] = (0x80000000000000FF | prefetch_spill_page);
 #endif
 
+	/* Clear I/O TLB of any possible entries */
+	WRITE_REG(ioc->ibase | (get_iovp_order(ioc->iov_size) + iovp_shift), ioc->ioc_hpa + IOC_PCOM);
+	READ_REG(ioc->ioc_hpa + IOC_PCOM);
+
+	/* Enable IOVA translation */
+	WRITE_REG(ioc->ibase | 1, ioc->ioc_hpa + IOC_IBASE);
+	READ_REG(ioc->ioc_hpa + IOC_IBASE);
 }
 
 static void __init
@@ -1561,7 +1463,7 @@ ioc_resource_init(struct ioc *ioc)
 	spin_lock_init(&ioc->res_lock);
 
 	/* resource map size dictated by pdir_size */
-	ioc->res_size = ioc->pdir_size / sizeof(u64); /* entries */
+	ioc->res_size = ioc->pdir_size / PDIR_ENTRY_SIZE; /* entries */
 	ioc->res_size >>= 3;  /* convert bit count to byte count */
 	DBG_INIT("%s() res_size 0x%x\n", __FUNCTION__, ioc->res_size);
 
@@ -1582,7 +1484,7 @@ ioc_resource_init(struct ioc *ioc)
 #ifdef FULL_VALID_PDIR
 	/* Mark the last resource used so we don't prefetch beyond IOVA space */
 	ioc->res_map[ioc->res_size - 1] |= 0x80UL; /* res_map is chars */
-	ioc->pdir_base[(ioc->pdir_size / sizeof(u64)) - 1] = (0x80000000000000FF
+	ioc->pdir_base[(ioc->pdir_size / PDIR_ENTRY_SIZE) - 1] = (0x80000000000000FF
 							      | prefetch_spill_page);
 #endif
 
@@ -1627,6 +1529,23 @@ ioc_zx1_init(struct ioc *ioc)
 		panic(PFX "IOC 2.0 or later required for IOMMU support\n");
 
 	ioc->dma_mask = 0xFFFFFFFFFFUL;
+
+	if (!iovp_shift) {
+		/* 64k is max iommu page size */
+		iovp_shift = min(PAGE_SHIFT, 16);
+		iovp_size = (1 << iovp_shift);
+		iovp_mask = ~(iovp_size - 1);
+	}
+}
+
+static void __init
+ioc_sx1000_init(struct ioc *ioc)
+{
+	if (!iovp_shift) {
+		iovp_shift = 12;	/* 4K for now */
+		iovp_size = (1 << iovp_shift);
+		iovp_mask = ~(iovp_size - 1);
+	}
 }
 
 typedef void (initfunc)(struct ioc *);
@@ -1639,8 +1558,8 @@ struct ioc_iommu {
 
 static struct ioc_iommu ioc_iommu_info[] __initdata = {
 	{ ZX1_IOC_ID, "zx1", ioc_zx1_init },
-	{ REO_IOC_ID, "REO" },
-	{ SX1000_IOC_ID, "sx1000" },
+	{ REO_IOC_ID, "REO", ioc_sx1000_init },
+	{ SX1000_IOC_ID, "sx1000", ioc_sx1000_init },
 };
 
 static struct ioc * __init
@@ -1665,6 +1584,11 @@ ioc_init(u64 hpa, void *handle)
 	ioc->rev = READ_REG(ioc->ioc_hpa + IOC_FCLASS) & 0xFFUL;
 	ioc->dma_mask = 0xFFFFFFFFFFFFFFFFUL;	/* conservative */
 
+	if (iovp_shift) {
+		iovp_size = (1 << iovp_shift);
+		iovp_mask = ~(iovp_size - 1);
+	}
+
 	for (info = ioc_iommu_info; info < ioc_iommu_info + ARRAY_SIZE(ioc_iommu_info); info++) {
 		if (ioc->func_id == info->func_id) {
 			ioc->name = info->name;
@@ -1672,6 +1596,8 @@ ioc_init(u64 hpa, void *handle)
 				(info->init)(ioc);
 		}
 	}
+	DBG_INIT("%s: PAGE_SIZE %ldK, iovp_size %ldK\n", __FUNCTION__,
+		PAGE_SIZE >> 10, iovp_size >> 10);
 
 	if (!ioc->name) {
 		ioc->name = kmalloc(24, GFP_KERNEL);
@@ -1686,8 +1612,8 @@ ioc_init(u64 hpa, void *handle)
 	ioc_resource_init(ioc);
 	ioc_sac_init(ioc);
 
-	if ((long) ~IOVP_MASK > (long) ia64_max_iommu_merge_mask)
-		ia64_max_iommu_merge_mask = ~IOVP_MASK;
+	if ((long) ~iovp_mask > (long) ia64_max_iommu_merge_mask)
+		ia64_max_iommu_merge_mask = ~iovp_mask;
 	MAX_DMA_ADDRESS = ~0UL;
 
 	printk(KERN_INFO PFX
@@ -1709,7 +1635,7 @@ ioc_init(u64 hpa, void *handle)
 **
 **************************************************************************/
 
-#if SBA_PROC_FS
+#ifdef CONFIG_PROC_FS
 static void *
 ioc_start(struct seq_file *s, loff_t *pos)
 {
@@ -1741,55 +1667,37 @@ static int
 ioc_show(struct seq_file *s, void *v)
 {
 	struct ioc *ioc = v;
-	int total_pages = (int) (ioc->res_size << 3); /* 8 bits per byte */
-	unsigned long i = 0, avg = 0, min, max;
+	unsigned long *res_ptr = (unsigned long *)ioc->res_map;
+	int i, used = 0;
 
 	seq_printf(s, "Hewlett Packard %s IOC rev %d.%d\n",
 		ioc->name, ((ioc->rev >> 4) & 0xF), (ioc->rev & 0xF));
-	seq_printf(s, "IO PDIR size    : %d bytes (%d entries)\n",
-		(int) ((ioc->res_size << 3) * sizeof(u64)), /* 8 bits/byte */
-		total_pages);
-
-	seq_printf(s, "IO PDIR entries : %ld free  %ld used (%d%%)\n",
-		total_pages - ioc->used_pages, ioc->used_pages,
-		(int) (ioc->used_pages * 100 / total_pages));
-
-	seq_printf(s, "Resource bitmap : %d bytes (%d pages)\n",
-		ioc->res_size, ioc->res_size << 3);   /* 8 bits per byte */
-
-	min = max = ioc->avg_search[0];
-	for (i = 0; i < SBA_SEARCH_SAMPLE; i++) {
-		avg += ioc->avg_search[i];
-		if (ioc->avg_search[i] > max) max = ioc->avg_search[i];
-		if (ioc->avg_search[i] < min) min = ioc->avg_search[i];
-	}
-	avg /= SBA_SEARCH_SAMPLE;
-	seq_printf(s, "  Bitmap search : %ld/%ld/%ld (min/avg/max CPU Cycles)\n", min, avg, max);
-
-	seq_printf(s, "pci_map_single(): %12ld calls  %12ld pages (avg %d/1000)\n",
-		   ioc->msingle_calls, ioc->msingle_pages,
-		   (int) ((ioc->msingle_pages * 1000)/ioc->msingle_calls));
-#ifdef ALLOW_IOV_BYPASS
-	seq_printf(s, "pci_map_single(): %12ld bypasses\n", ioc->msingle_bypass);
-#endif
+	seq_printf(s, "IOVA size       : %d MB\n", ioc->iov_size/(1024*1024));
+	seq_printf(s, "IOVA page size  : %ld kb\n", iovp_size/1024);
 
-	seq_printf(s, "pci_unmap_single: %12ld calls  %12ld pages (avg %d/1000)\n",
-		   ioc->usingle_calls, ioc->usingle_pages,
-		   (int) ((ioc->usingle_pages * 1000)/ioc->usingle_calls));
-#ifdef ALLOW_IOV_BYPASS
-	seq_printf(s, "pci_unmap_single: %12ld bypasses\n", ioc->usingle_bypass);
-#endif
-
-	seq_printf(s, "pci_map_sg()    : %12ld calls  %12ld pages (avg %d/1000)\n",
-		   ioc->msg_calls, ioc->msg_pages,
-		   (int) ((ioc->msg_pages * 1000)/ioc->msg_calls));
-#ifdef ALLOW_IOV_BYPASS
-	seq_printf(s, "pci_map_sg()    : %12ld bypasses\n", ioc->msg_bypass);
-#endif
+	for (i = 0; i < (ioc->res_size / sizeof(unsigned long)); ++i, ++res_ptr)
+		used += hweight64(*res_ptr);
 
-	seq_printf(s, "pci_unmap_sg()  : %12ld calls  %12ld pages (avg %d/1000)\n",
-		   ioc->usg_calls, ioc->usg_pages, (int) ((ioc->usg_pages * 1000)/ioc->usg_calls));
+	seq_printf(s, "PDIR size       : %d entries\n", ioc->res_size << 3);
+	seq_printf(s, "PDIR used       : %d entries\n", used);
 
+#ifdef PDIR_SEARCH_TIMING
+	{
+		unsigned long i = 0, avg = 0, min, max;
+		min = max = ioc->avg_search[0];
+		for (i = 0; i < SBA_SEARCH_SAMPLE; i++) {
+			avg += ioc->avg_search[i];
+			if (ioc->avg_search[i] > max) max = ioc->avg_search[i];
+			if (ioc->avg_search[i] < min) min = ioc->avg_search[i];
+		}
+		avg /= SBA_SEARCH_SAMPLE;
+		seq_printf(s, "Bitmap search   : %ld/%ld/%ld (min/avg/max CPU Cycles)\n",
+		           min, avg, max);
+	}
+#endif
+#ifndef ALLOW_IOV_BYPASS
+	 seq_printf(s, "IOVA bypass disabled\n");
+#endif
 	return 0;
 }
 
@@ -1813,39 +1721,6 @@ static struct file_operations ioc_fops =
 	.release = seq_release
 };
 
-static int
-ioc_map_show(struct seq_file *s, void *v)
-{
-	struct ioc *ioc = v;
-	unsigned int i, *res_ptr = (unsigned int *)ioc->res_map;
-
-	for (i = 0; i < ioc->res_size / sizeof(unsigned int); ++i, ++res_ptr)
-		seq_printf(s, "%s%08x", (i & 7) ? " " : "\n   ", *res_ptr);
-	seq_printf(s, "\n");
-
-	return 0;
-}
-
-static struct seq_operations ioc_map_ops = {
-	.start = ioc_start,
-	.next  = ioc_next,
-	.stop  = ioc_stop,
-	.show  = ioc_map_show
-};
-
-static int
-ioc_map_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &ioc_map_ops);
-}
-
-static struct file_operations ioc_map_fops = {
-	.open    = ioc_map_open,
-	.read    = seq_read,
-	.llseek  = seq_lseek,
-	.release = seq_release
-};
-
 static void __init
 ioc_proc_init(void)
 {
@@ -1858,10 +1733,6 @@ ioc_proc_init(void)
 	entry = create_proc_entry(ioc_list->name, 0, dir);
 	if (entry)
 		entry->proc_fops = &ioc_fops;
-
-	entry = create_proc_entry("bitmap", 0, dir);
-	if (entry)
-		entry->proc_fops = &ioc_map_fops;
 }
 #endif
 
@@ -1958,7 +1829,7 @@ sba_init(void)
 	}
 #endif
 
-#if SBA_PROC_FS
+#ifdef CONFIG_PROC_FS
 	ioc_proc_init();
 #endif
 	return 0;
@@ -1982,6 +1853,29 @@ sba_dma_supported (struct device *dev, u
 
 __setup("nosbagart", nosbagart);
 
+static int __init
+sba_page_override(char *str)
+{
+	unsigned long page_size;
+
+	page_size = memparse(str, &str);
+	switch (page_size) {
+		case 4096:
+		case 8192:
+		case 16384:
+		case 65536:
+			iovp_shift = ffs(page_size) - 1;
+			break;
+		default:
+			printk("%s: unknown/unsupported iommu page size %ld\n",
+			       __FUNCTION__, page_size);
+	}
+
+	return 1;
+}
+
+__setup("sbapagesize=",sba_page_override);
+
 EXPORT_SYMBOL(sba_map_single);
 EXPORT_SYMBOL(sba_unmap_single);
 EXPORT_SYMBOL(sba_map_sg);
diff -purN linux-2.6.1/arch/ia64/ia32/sys_ia32.c linux-2.5/arch/ia64/ia32/sys_ia32.c
--- linux-2.6.1/arch/ia64/ia32/sys_ia32.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/arch/ia64/ia32/sys_ia32.c	2004-01-13 00:31:14.000000000 +0000
@@ -741,7 +741,7 @@ filldir32 (void *__buf, const char *name
 	    || copy_to_user(dirent->d_name, name, namlen)
 	    || put_user(0, dirent->d_name + namlen))
 		return -EFAULT;
-	((char *) dirent) += reclen;
+	dirent = (struct compat_dirent *) ((char *) dirent + reclen);
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 	return 0;
diff -purN linux-2.6.1/arch/ia64/kernel/acpi.c linux-2.5/arch/ia64/kernel/acpi.c
--- linux-2.6.1/arch/ia64/kernel/acpi.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/acpi.c	2004-01-14 19:09:40.000000000 +0000
@@ -32,6 +32,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -53,6 +54,7 @@
 #define PREFIX			"ACPI: "
 
 void (*pm_idle) (void);
+EXPORT_SYMBOL(pm_idle);
 void (*pm_power_off) (void);
 
 unsigned char acpi_kbd_controller_present = 1;
@@ -629,5 +631,6 @@ acpi_register_irq (u32 gsi, u32 polarity
 			(polarity == ACPI_ACTIVE_HIGH) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
 			(trigger == ACPI_EDGE_SENSITIVE) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
 }
+EXPORT_SYMBOL(acpi_register_irq);
 
 #endif /* CONFIG_ACPI_BOOT */
diff -purN linux-2.6.1/arch/ia64/kernel/efi.c linux-2.5/arch/ia64/kernel/efi.c
--- linux-2.6.1/arch/ia64/kernel/efi.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/efi.c	2004-01-05 15:43:05.000000000 +0000
@@ -19,6 +19,7 @@
  *	Skip non-WB memory and ignore empty memory ranges.
  */
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/types.h>
@@ -37,6 +38,7 @@
 extern efi_status_t efi_call_phys (void *, ...);
 
 struct efi efi;
+EXPORT_SYMBOL(efi);
 static efi_runtime_services_t *runtime;
 
 /*
@@ -48,6 +50,7 @@ static efi_runtime_services_t *runtime;
  */
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *efi_dir;
+EXPORT_SYMBOL(efi_dir);
 #endif
 
 static unsigned long mem_limit = ~0UL;
diff -purN linux-2.6.1/arch/ia64/kernel/ia64_ksyms.c linux-2.5/arch/ia64/kernel/ia64_ksyms.c
--- linux-2.6.1/arch/ia64/kernel/ia64_ksyms.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/ia64_ksyms.c	2004-01-05 15:50:32.000000000 +0000
@@ -1,15 +1,18 @@
 /*
  * Architecture-specific kernel symbols
+ *
+ * Don't put any exports here unless it's defined in an assembler file.
+ * All other exports should be put directly after the definition.
  */
 
 #include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/string.h>
-EXPORT_SYMBOL_NOVERS(memset);			/* gcc generates direct calls to memset()... */
+EXPORT_SYMBOL(memset);
 EXPORT_SYMBOL(memchr);
 EXPORT_SYMBOL(memcmp);
-EXPORT_SYMBOL_NOVERS(memcpy);
+EXPORT_SYMBOL(memcpy);
 EXPORT_SYMBOL(memmove);
 EXPORT_SYMBOL(memscan);
 EXPORT_SYMBOL(strcat);
@@ -25,77 +28,28 @@ EXPORT_SYMBOL(strrchr);
 EXPORT_SYMBOL(strstr);
 EXPORT_SYMBOL(strpbrk);
 
-#include <linux/irq.h>
-EXPORT_SYMBOL(isa_irq_to_vector_map);
-EXPORT_SYMBOL(enable_irq);
-EXPORT_SYMBOL(disable_irq);
-EXPORT_SYMBOL(disable_irq_nosync);
-
-#include <linux/interrupt.h>
-EXPORT_SYMBOL(probe_irq_mask);
-
 #include <asm/checksum.h>
 EXPORT_SYMBOL(ip_fast_csum);		/* hand-coded assembly */
 
-#include <asm/io.h>
-EXPORT_SYMBOL(__ia64_memcpy_fromio);
-EXPORT_SYMBOL(__ia64_memcpy_toio);
-EXPORT_SYMBOL(__ia64_memset_c_io);
-EXPORT_SYMBOL(io_space);
-
 #include <asm/semaphore.h>
-EXPORT_SYMBOL_NOVERS(__down);
-EXPORT_SYMBOL_NOVERS(__down_interruptible);
-EXPORT_SYMBOL_NOVERS(__down_trylock);
-EXPORT_SYMBOL_NOVERS(__up);
+EXPORT_SYMBOL(__down);
+EXPORT_SYMBOL(__down_interruptible);
+EXPORT_SYMBOL(__down_trylock);
+EXPORT_SYMBOL(__up);
 
 #include <asm/page.h>
 EXPORT_SYMBOL(clear_page);
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
 #include <linux/bootmem.h>
-#include <asm/pgtable.h>
-EXPORT_SYMBOL(vmalloc_end);
-EXPORT_SYMBOL(ia64_pfn_valid);
 EXPORT_SYMBOL(max_low_pfn);	/* defined by bootmem.c, but not exported by generic code */
 #endif
 
 #include <asm/processor.h>
 EXPORT_SYMBOL(per_cpu__cpu_info);
 #ifdef CONFIG_SMP
-EXPORT_SYMBOL(__per_cpu_offset);
 EXPORT_SYMBOL(per_cpu__local_per_cpu_offset);
 #endif
-EXPORT_SYMBOL(kernel_thread);
-
-#include <asm/system.h>
-#ifdef CONFIG_IA64_DEBUG_IRQ
-EXPORT_SYMBOL(last_cli_ip);
-#endif
-
-#include <asm/tlbflush.h>
-
-EXPORT_SYMBOL(flush_tlb_range);
-
-#ifdef CONFIG_SMP
-
-EXPORT_SYMBOL(smp_flush_tlb_all);
-
-#include <asm/current.h>
-#include <asm/hardirq.h>
-EXPORT_SYMBOL(synchronize_irq);
-
-#include <asm/smp.h>
-EXPORT_SYMBOL(smp_call_function);
-EXPORT_SYMBOL(smp_call_function_single);
-EXPORT_SYMBOL(cpu_online_map);
-EXPORT_SYMBOL(phys_cpu_present_map);
-EXPORT_SYMBOL(ia64_cpu_to_sapicid);
-#else /* !CONFIG_SMP */
-
-EXPORT_SYMBOL(local_flush_tlb_all);
-
-#endif /* !CONFIG_SMP */
 
 #include <asm/uaccess.h>
 EXPORT_SYMBOL(__copy_user);
@@ -117,14 +71,14 @@ extern void __udivdi3(void);
 extern void __moddi3(void);
 extern void __umoddi3(void);
 
-EXPORT_SYMBOL_NOVERS(__divsi3);
-EXPORT_SYMBOL_NOVERS(__udivsi3);
-EXPORT_SYMBOL_NOVERS(__modsi3);
-EXPORT_SYMBOL_NOVERS(__umodsi3);
-EXPORT_SYMBOL_NOVERS(__divdi3);
-EXPORT_SYMBOL_NOVERS(__udivdi3);
-EXPORT_SYMBOL_NOVERS(__moddi3);
-EXPORT_SYMBOL_NOVERS(__umoddi3);
+EXPORT_SYMBOL(__divsi3);
+EXPORT_SYMBOL(__udivsi3);
+EXPORT_SYMBOL(__modsi3);
+EXPORT_SYMBOL(__umodsi3);
+EXPORT_SYMBOL(__divdi3);
+EXPORT_SYMBOL(__udivdi3);
+EXPORT_SYMBOL(__moddi3);
+EXPORT_SYMBOL(__umoddi3);
 
 #if defined(CONFIG_MD_RAID5) || defined(CONFIG_MD_RAID5_MODULE)
 extern void xor_ia64_2(void);
@@ -132,15 +86,12 @@ extern void xor_ia64_3(void);
 extern void xor_ia64_4(void);
 extern void xor_ia64_5(void);
 
-EXPORT_SYMBOL_NOVERS(xor_ia64_2);
-EXPORT_SYMBOL_NOVERS(xor_ia64_3);
-EXPORT_SYMBOL_NOVERS(xor_ia64_4);
-EXPORT_SYMBOL_NOVERS(xor_ia64_5);
+EXPORT_SYMBOL(xor_ia64_2);
+EXPORT_SYMBOL(xor_ia64_3);
+EXPORT_SYMBOL(xor_ia64_4);
+EXPORT_SYMBOL(xor_ia64_5);
 #endif
 
-extern unsigned long ia64_iobase;
-EXPORT_SYMBOL(ia64_iobase);
-
 #include <asm/pal.h>
 EXPORT_SYMBOL(ia64_pal_call_phys_stacked);
 EXPORT_SYMBOL(ia64_pal_call_phys_static);
@@ -149,44 +100,8 @@ EXPORT_SYMBOL(ia64_pal_call_static);
 EXPORT_SYMBOL(ia64_load_scratch_fpregs);
 EXPORT_SYMBOL(ia64_save_scratch_fpregs);
 
-extern struct efi efi;
-EXPORT_SYMBOL(efi);
-
-#include <linux/proc_fs.h>
-extern struct proc_dir_entry *efi_dir;
-EXPORT_SYMBOL(efi_dir);
-
-#include <asm/machvec.h>
-#ifdef CONFIG_IA64_GENERIC
-EXPORT_SYMBOL(ia64_mv);
-#endif
-EXPORT_SYMBOL(machvec_noop);
-EXPORT_SYMBOL(machvec_memory_fence);
-EXPORT_SYMBOL(zero_page_memmap_ptr);
-#ifdef CONFIG_PERFMON
-#include <asm/perfmon.h>
-EXPORT_SYMBOL(pfm_register_buffer_fmt);
-EXPORT_SYMBOL(pfm_unregister_buffer_fmt);
-EXPORT_SYMBOL(pfm_mod_fast_read_pmds);
-EXPORT_SYMBOL(pfm_mod_read_pmds);
-EXPORT_SYMBOL(pfm_mod_write_pmcs);
-#endif
-
-#ifdef CONFIG_NUMA
-#include <asm/numa.h>
-EXPORT_SYMBOL(cpu_to_node_map);
-#endif
-
 #include <asm/unwind.h>
-EXPORT_SYMBOL(unw_init_from_blocked_task);
 EXPORT_SYMBOL(unw_init_running);
-EXPORT_SYMBOL(unw_unwind);
-EXPORT_SYMBOL(unw_unwind_to_user);
-EXPORT_SYMBOL(unw_access_gr);
-EXPORT_SYMBOL(unw_access_br);
-EXPORT_SYMBOL(unw_access_fr);
-EXPORT_SYMBOL(unw_access_ar);
-EXPORT_SYMBOL(unw_access_pr);
 
 #ifdef CONFIG_SMP
 # if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 3)
@@ -205,8 +120,3 @@ extern char ia64_spinlock_contention;
 EXPORT_SYMBOL(ia64_spinlock_contention);
 # endif
 #endif
-
-EXPORT_SYMBOL(ia64_max_iommu_merge_mask);
-
-#include <linux/pm.h>
-EXPORT_SYMBOL(pm_idle);
diff -purN linux-2.6.1/arch/ia64/kernel/irq.c linux-2.5/arch/ia64/kernel/irq.c
--- linux-2.6.1/arch/ia64/kernel/irq.c	2004-01-09 06:59:57.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/irq.c	2004-01-05 15:38:56.000000000 +0000
@@ -226,6 +226,7 @@ inline void synchronize_irq(unsigned int
 	while (irq_descp(irq)->status & IRQ_INPROGRESS)
 		cpu_relax();
 }
+EXPORT_SYMBOL(synchronize_irq);
 #endif
 
 /*
@@ -367,6 +368,7 @@ inline void disable_irq_nosync(unsigned 
 	}
 	spin_unlock_irqrestore(&desc->lock, flags);
 }
+EXPORT_SYMBOL(disable_irq_nosync);
 
 /**
  *	disable_irq - disable an irq and wait for completion
@@ -389,6 +391,7 @@ void disable_irq(unsigned int irq)
 	if (desc->action)
 		synchronize_irq(irq);
 }
+EXPORT_SYMBOL(disable_irq);
 
 /**
  *	enable_irq - enable handling of an irq
@@ -427,6 +430,7 @@ void enable_irq(unsigned int irq)
 	}
 	spin_unlock_irqrestore(&desc->lock, flags);
 }
+EXPORT_SYMBOL(enable_irq);
 
 /*
  * do_IRQ handles all normal device IRQ's (the special
@@ -795,6 +799,7 @@ unsigned int probe_irq_mask(unsigned lon
 
 	return mask & val;
 }
+EXPORT_SYMBOL(probe_irq_mask);
 
 /**
  *	probe_irq_off	- end an interrupt autodetect
diff -purN linux-2.6.1/arch/ia64/kernel/irq_ia64.c linux-2.5/arch/ia64/kernel/irq_ia64.c
--- linux-2.6.1/arch/ia64/kernel/irq_ia64.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/irq_ia64.c	2004-01-05 15:32:35.000000000 +0000
@@ -13,6 +13,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 
 #include <linux/jiffies.h>
 #include <linux/errno.h>
@@ -54,6 +55,7 @@ __u8 isa_irq_to_vector_map[16] = {
 	0x2f, 0x20, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x29,
 	0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21
 };
+EXPORT_SYMBOL(isa_irq_to_vector_map);
 
 int
 ia64_alloc_vector (void)
diff -purN linux-2.6.1/arch/ia64/kernel/machvec.c linux-2.5/arch/ia64/kernel/machvec.c
--- linux-2.6.1/arch/ia64/kernel/machvec.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/machvec.c	2004-01-05 15:44:04.000000000 +0000
@@ -1,4 +1,5 @@
 #include <linux/config.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 
@@ -11,6 +12,7 @@
 #include <asm/page.h>
 
 struct ia64_machine_vector ia64_mv;
+EXPORT_SYMBOL(ia64_mv);
 
 static struct ia64_machine_vector *
 lookup_machvec (const char *name)
@@ -45,9 +47,11 @@ void
 machvec_noop (void)
 {
 }
+EXPORT_SYMBOL(machvec_noop);
 
 void
 machvec_memory_fence (void)
 {
 	mb();
 }
+EXPORT_SYMBOL(machvec_memory_fence);
diff -purN linux-2.6.1/arch/ia64/kernel/perfmon.c linux-2.5/arch/ia64/kernel/perfmon.c
--- linux-2.6.1/arch/ia64/kernel/perfmon.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/perfmon.c	2004-01-05 15:45:37.000000000 +0000
@@ -20,6 +20,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
@@ -1042,12 +1043,10 @@ pfm_restore_pmds(unsigned long *pmds, un
 	int i;
 	unsigned long val, ovfl_val = pmu_conf.ovfl_val;
 
-	DPRINT(("mask=0x%lx\n", mask));
 	for (i=0; mask; i++, mask>>=1) {
 		if ((mask & 0x1) == 0) continue;
 		val = PMD_IS_COUNTING(i) ? pmds[i] & ovfl_val : pmds[i];
 		ia64_set_pmd(i, val);
-		DPRINT(("pmd[%d]=0x%lx\n", i, val));
 	}
 	ia64_srlz_d();
 }
@@ -1115,11 +1114,9 @@ pfm_restore_pmcs(unsigned long *pmcs, un
 {
 	int i;
 
-	DPRINT(("mask=0x%lx\n", mask));
 	for (i=0; mask; i++, mask>>=1) {
 		if ((mask & 0x1) == 0) continue;
 		ia64_set_pmc(i, pmcs[i]);
-		DPRINT(("pmc[%d]=0x%lx\n", i, pmcs[i]));
 	}
 	ia64_srlz_d();
 }
@@ -1259,6 +1256,7 @@ out:
 	spin_unlock(&pfm_buffer_fmt_lock);
  	return ret;
 }
+EXPORT_SYMBOL(pfm_register_buffer_fmt);
 
 int
 pfm_unregister_buffer_fmt(pfm_uuid_t uuid)
@@ -1282,6 +1280,7 @@ out:
 	return ret;
 
 }
+EXPORT_SYMBOL(pfm_unregister_buffer_fmt);
 
 static int
 pfm_reserve_session(struct task_struct *task, int is_syswide, unsigned int cpu)
@@ -3421,6 +3420,7 @@ pfm_mod_write_pmcs(struct task_struct *t
 
 	return pfm_write_pmcs(ctx, req, nreq, regs);
 }
+EXPORT_SYMBOL(pfm_mod_write_pmcs);
 
 long
 pfm_mod_read_pmds(struct task_struct *task, pfarg_reg_t *req, unsigned int nreq, struct pt_regs *regs)
@@ -3442,6 +3442,7 @@ pfm_mod_read_pmds(struct task_struct *ta
 
 	return pfm_read_pmds(ctx, req, nreq, regs);
 }
+EXPORT_SYMBOL(pfm_mod_read_pmds);
 
 long
 pfm_mod_fast_read_pmds(struct task_struct *task, unsigned long mask[4], unsigned long *addr, struct pt_regs *regs)
@@ -3483,6 +3484,7 @@ pfm_mod_fast_read_pmds(struct task_struc
 	}
 	return 0;
 }
+EXPORT_SYMBOL(pfm_mod_fast_read_pmds);
 
 /*
  * Only call this function when a process it trying to
@@ -5670,7 +5672,7 @@ pfm_save_regs(struct task_struct *task)
 
 
 	ctx = PFM_GET_CTX(task);
-	if (ctx == NULL) goto save_error;
+	if (ctx == NULL) return;
 	t = &task->thread;
 
 	/*
@@ -5685,8 +5687,6 @@ pfm_save_regs(struct task_struct *task)
 
 		pfm_clear_psr_up();
 
-		DPRINT(("ctx zombie, forcing cleanup for [%d]\n", task->pid));
-
 		pfm_force_cleanup(ctx, regs);
 
 		BUG_ON(ctx->ctx_smpl_hdr);
@@ -5701,12 +5701,7 @@ pfm_save_regs(struct task_struct *task)
 	 * sanity check
 	 */
 	if (ctx->ctx_last_activation != GET_ACTIVATION()) {
-		printk("ctx_activation=%lu activation=%lu state=%d: no save\n",
-				ctx->ctx_last_activation,
-				GET_ACTIVATION(), ctx->ctx_state);
-
 		pfm_unprotect_ctx_ctxsw(ctx, flags);
-
 		return;
 	}
 
@@ -5763,13 +5758,6 @@ pfm_save_regs(struct task_struct *task)
 	 * interrupts will still be masked after this call.
 	 */
 	pfm_unprotect_ctx_ctxsw(ctx, flags);
-
-	return;
-
-save_error:
-	printk(KERN_ERR "perfmon: pfm_save_regs CPU%d [%d] NULL context PM_VALID=%ld\n",
-		smp_processor_id(), task->pid,
-		task->thread.flags & IA64_THREAD_PM_VALID);
 }
 
 #else /* !CONFIG_SMP */
@@ -5780,7 +5768,7 @@ pfm_save_regs(struct task_struct *task)
 	u64 psr;
 
 	ctx = PFM_GET_CTX(task);
-	if (ctx == NULL) goto save_error;
+	if (ctx == NULL) return;
 
 	/*
 	 * save current PSR: needed because we modify it
@@ -5802,12 +5790,6 @@ pfm_save_regs(struct task_struct *task)
 	 * keep a copy of psr.up (for reload)
 	 */
 	ctx->ctx_saved_psr_up = psr & IA64_PSR_UP;
-
-	return;
-save_error:
-	printk(KERN_ERR "perfmon: pfm_save_regs CPU%d [%d] NULL context PM_VALID=%ld\n",
-		smp_processor_id(), task->pid,
-		task->thread.flags & IA64_THREAD_PM_VALID);
 }
 
 static void
@@ -5824,8 +5806,6 @@ pfm_lazy_save_regs (struct task_struct *
 	ctx = PFM_GET_CTX(task);
 	t   = &task->thread;
 
-	DPRINT(("on [%d] used_pmds=0x%lx\n", task->pid, ctx->ctx_used_pmds[0]));
-
 	/*
 	 * we need to mask PMU overflow here to
 	 * make sure that we maintain pmc0 until
@@ -5886,10 +5866,7 @@ pfm_load_regs (struct task_struct *task)
 	u64 psr, psr_up;
 
 	ctx = PFM_GET_CTX(task);
-	if (unlikely(ctx == NULL)) {
-		printk(KERN_ERR "perfmon: pfm_load_regs() null context\n");
-		return;
-	}
+	if (unlikely(ctx == NULL)) return;
 
 	BUG_ON(GET_PMU_OWNER());
 
@@ -5897,10 +5874,7 @@ pfm_load_regs (struct task_struct *task)
 	/*
 	 * possible on unload
 	 */
-	if (unlikely((t->flags & IA64_THREAD_PM_VALID) == 0)) {
-		printk("[%d] PM_VALID=0, nothing to do\n", task->pid);
-		return;
-	}
+	if (unlikely((t->flags & IA64_THREAD_PM_VALID) == 0)) return;
 
 	/*
  	 * we always come here with interrupts ALREADY disabled by
@@ -5918,8 +5892,6 @@ pfm_load_regs (struct task_struct *task)
 
 		BUG_ON(ctx->ctx_smpl_hdr);
 
-		DPRINT(("ctx zombie, forcing cleanup for [%d]\n", task->pid));
-
 		pfm_force_cleanup(ctx, regs);
 
 		pfm_unprotect_ctx_ctxsw(ctx, flags);
@@ -5957,7 +5929,6 @@ pfm_load_regs (struct task_struct *task)
 		pmc_mask = ctx->ctx_reload_pmcs[0];
 		pmd_mask = ctx->ctx_reload_pmds[0];
 
-		if (pmc_mask || pmd_mask) DPRINT(("partial reload [%d] pmd_mask=0x%lx pmc_mask=0x%lx\n", task->pid, pmd_mask, pmc_mask));
 	} else {
 		/*
 	 	 * To avoid leaking information to the user level when psr.sp=0,
@@ -5975,12 +5946,6 @@ pfm_load_regs (struct task_struct *task)
 	 	 * PMC0 is never in the mask. It is always restored separately.
 	 	 */
 		pmc_mask = ctx->ctx_all_pmcs[0];
-
-		DPRINT(("full reload for [%d] activation=%lu last_activation=%lu last_cpu=%d pmd_mask=0x%lx pmc_mask=0x%lx\n",
-			task->pid,
-			GET_ACTIVATION(), ctx->ctx_last_activation,
-			GET_LAST_CPU(ctx), pmd_mask, pmc_mask));
-
 	}
 	/*
 	 * when context is MASKED, we will restore PMC with plm=0
@@ -6008,7 +5973,6 @@ pfm_load_regs (struct task_struct *task)
 		/*
 		 * will replay the PMU interrupt
 		 */
-		DPRINT(("perfmon: resend irq for [%d]\n", task->pid));
 		hw_resend_irq(NULL, IA64_PERFMON_VECTOR);
 #endif
 		pfm_stats[smp_processor_id()].pfm_replay_ovfl_intr_count++;
@@ -6102,8 +6066,6 @@ pfm_load_regs (struct task_struct *task)
 		return;
 	}
 
-	DPRINT(("reload for [%d] owner=%d\n", task->pid, owner ? owner->pid : -1));
-
 	/*
 	 * someone else is still using the PMU, first push it out and
 	 * then we'll be able to install our stuff !
@@ -6150,7 +6112,6 @@ pfm_load_regs (struct task_struct *task)
 		/*
 		 * will replay the PMU interrupt
 		 */
-		DPRINT(("perfmon: resend irq for [%d]\n", task->pid));
 		hw_resend_irq(NULL, IA64_PERFMON_VECTOR);
 #endif
 		pfm_stats[smp_processor_id()].pfm_replay_ovfl_intr_count++;
diff -purN linux-2.6.1/arch/ia64/kernel/process.c linux-2.5/arch/ia64/kernel/process.c
--- linux-2.6.1/arch/ia64/kernel/process.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/process.c	2004-01-05 15:37:12.000000000 +0000
@@ -598,6 +598,7 @@ kernel_thread (int (*fn)(void *), void *
 	}
 	return tid;
 }
+EXPORT_SYMBOL(kernel_thread);
 
 /*
  * Flush thread state.  This is called when a thread does an execve().
diff -purN linux-2.6.1/arch/ia64/kernel/setup.c linux-2.5/arch/ia64/kernel/setup.c
--- linux-2.6.1/arch/ia64/kernel/setup.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/setup.c	2004-01-14 05:23:51.000000000 +0000
@@ -17,6 +17,7 @@
  * 06/24/99 W.Drummond	added boot_cpu_data.
  */
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/init.h>
 
 #include <linux/acpi.h>
@@ -60,6 +61,7 @@ int efi_enabled = 1;
 
 #ifdef CONFIG_SMP
 unsigned long __per_cpu_offset[NR_CPUS];
+EXPORT_SYMBOL(__per_cpu_offset);
 #endif
 
 DEFINE_PER_CPU(struct cpuinfo_ia64, cpu_info);
@@ -71,7 +73,9 @@ struct screen_info screen_info;
 
 unsigned long ia64_max_cacheline_size;
 unsigned long ia64_iobase;	/* virtual address for I/O accesses */
+EXPORT_SYMBOL(ia64_iobase);
 struct io_space io_space[MAX_IO_SPACES];
+EXPORT_SYMBOL(io_space);
 unsigned int num_io_spaces;
 
 unsigned char aux_device_present = 0xaa;        /* XXX remove this when legacy I/O is gone */
@@ -86,6 +90,7 @@ unsigned char aux_device_present = 0xaa;
  * page-size of 2^64.
  */
 unsigned long ia64_max_iommu_merge_mask = ~0UL;
+EXPORT_SYMBOL(ia64_max_iommu_merge_mask);
 
 #define COMMAND_LINE_SIZE	512
 
@@ -317,13 +322,13 @@ setup_arch (char **cmdline_p)
 #ifdef CONFIG_ACPI_BOOT
 	acpi_boot_init();
 #endif
+#ifdef CONFIG_SERIAL_8250_CONSOLE
 #ifdef CONFIG_SERIAL_8250_HCDP
 	if (efi.hcdp) {
 		void setup_serial_hcdp(void *);
 		setup_serial_hcdp(efi.hcdp);
 	}
 #endif
-#ifdef CONFIG_SERIAL_8250_CONSOLE
 	/*
 	 * Without HCDP, we won't discover any serial ports until the serial driver looks
 	 * in the ACPI namespace.  If ACPI claims there are some legacy devices, register
@@ -520,8 +525,6 @@ identify_cpu (struct cpuinfo_ia64 *c)
 		impl_va_msb = vm2.pal_vm_info_2_s.impl_va_msb;
 		phys_addr_size = vm1.pal_vm_info_1_s.phys_add_size;
 	}
-	printk(KERN_INFO "CPU %d: %lu virtual and %lu physical address bits\n",
-	       smp_processor_id(), impl_va_msb + 1, phys_addr_size);
 	c->unimpl_va_mask = ~((7L<<61) | ((1L << (impl_va_msb + 1)) - 1));
 	c->unimpl_pa_mask = ~((1L<<63) | ((1L << phys_addr_size) - 1));
 }
diff -purN linux-2.6.1/arch/ia64/kernel/smp.c linux-2.5/arch/ia64/kernel/smp.c
--- linux-2.6.1/arch/ia64/kernel/smp.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/smp.c	2004-01-05 15:39:26.000000000 +0000
@@ -22,6 +22,7 @@
 
 #include <linux/config.h>
 
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/init.h>
@@ -210,6 +211,7 @@ smp_flush_tlb_all (void)
 {
 	on_each_cpu((void (*)(void *))local_flush_tlb_all, 0, 1, 1);
 }
+EXPORT_SYMBOL(smp_flush_tlb_all);
 
 void
 smp_flush_tlb_mm (struct mm_struct *mm)
@@ -283,6 +285,7 @@ smp_call_function_single (int cpuid, voi
 	put_cpu();
 	return 0;
 }
+EXPORT_SYMBOL(smp_call_function_single);
 
 /*
  * this function sends a 'generic call function' IPI to all other CPUs
@@ -337,6 +340,7 @@ smp_call_function (void (*func) (void *i
 	spin_unlock(&call_lock);
 	return 0;
 }
+EXPORT_SYMBOL(smp_call_function);
 
 void
 smp_do_timer (struct pt_regs *regs)
diff -purN linux-2.6.1/arch/ia64/kernel/smpboot.c linux-2.5/arch/ia64/kernel/smpboot.c
--- linux-2.6.1/arch/ia64/kernel/smpboot.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/smpboot.c	2004-01-14 05:24:55.000000000 +0000
@@ -16,6 +16,7 @@
 
 #include <linux/config.h>
 
+#include <linux/module.h>
 #include <linux/acpi.h>
 #include <linux/bootmem.h>
 #include <linux/delay.h>
@@ -81,10 +82,13 @@ task_t *task_for_booting_cpu;
 
 /* Bitmask of currently online CPUs */
 cpumask_t cpu_online_map;
+EXPORT_SYMBOL(cpu_online_map);
 cpumask_t phys_cpu_present_map;
+EXPORT_SYMBOL(phys_cpu_present_map);
 
 /* which logical CPU number maps to which CPU (physical APIC ID) */
 volatile int ia64_cpu_to_sapicid[NR_CPUS];
+EXPORT_SYMBOL(ia64_cpu_to_sapicid);
 
 static volatile cpumask_t cpu_callin_map;
 
@@ -401,10 +405,7 @@ do_boot_cpu (int sapicid, int cpu)
 	}
 	Dprintk("\n");
 
-	if (cpu_isset(cpu, cpu_callin_map)) {
-		/* number CPUs logically, starting from 1 (BSP is 0) */
-		printk(KERN_INFO "CPU%d: CPU has booted.\n", cpu);
-	} else {
+	if (!cpu_isset(cpu, cpu_callin_map)) {
 		printk(KERN_ERR "Processor 0x%x/0x%x is stuck.\n", cpu, sapicid);
 		ia64_cpu_to_sapicid[cpu] = -1;
 		cpu_clear(cpu, cpu_online_map);  /* was set in smp_callin() */
@@ -467,6 +468,7 @@ smp_build_cpu_map (void)
 
 /* on which node is each logical CPU (one cacheline even for 64 CPUs) */
 volatile u8 cpu_to_node_map[NR_CPUS] __cacheline_aligned;
+EXPORT_SYMBOL(cpu_to_node_map);
 /* which logical CPUs are on which nodes */
 volatile cpumask_t node_to_cpu_mask[MAX_NUMNODES] __cacheline_aligned;
 
@@ -578,14 +580,11 @@ __cpu_up (unsigned int cpu)
 	if (sapicid == -1)
 		return -EINVAL;
 
-	printk(KERN_INFO "Processor %d/%d is spinning up...\n", sapicid, cpu);
-
 	/* Processor goes to start_secondary(), sets online flag */
 	ret = do_boot_cpu(sapicid, cpu);
 	if (ret < 0)
 		return ret;
 
-	printk(KERN_INFO "Processor %d has spun up...\n", cpu);
 	return 0;
 }
 
diff -purN linux-2.6.1/arch/ia64/kernel/time.c linux-2.5/arch/ia64/kernel/time.c
--- linux-2.6.1/arch/ia64/kernel/time.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/time.c	2004-01-05 15:37:35.000000000 +0000
@@ -39,6 +39,7 @@ EXPORT_SYMBOL(jiffies_64);
 #ifdef CONFIG_IA64_DEBUG_IRQ
 
 unsigned long last_cli_ip;
+EXPORT_SYMBOL(last_cli_ip);
 
 #endif
 
diff -purN linux-2.6.1/arch/ia64/kernel/unwind.c linux-2.5/arch/ia64/kernel/unwind.c
--- linux-2.6.1/arch/ia64/kernel/unwind.c	2004-01-09 07:00:13.000000000 +0000
+++ linux-2.5/arch/ia64/kernel/unwind.c	2004-01-05 15:47:54.000000000 +0000
@@ -26,6 +26,7 @@
  *	o if both the unw.lock spinlock and a script's read-write lock must be
  *	  acquired, then the read-write lock must be acquired first.
  */
+#include <linux/module.h>
 #include <linux/bootmem.h>
 #include <linux/elf.h>
 #include <linux/kernel.h>
@@ -392,6 +393,7 @@ unw_access_gr (struct unw_frame_info *in
 	}
 	return 0;
 }
+EXPORT_SYMBOL(unw_access_gr);
 
 int
 unw_access_br (struct unw_frame_info *info, int regnum, unsigned long *val, int write)
@@ -423,6 +425,7 @@ unw_access_br (struct unw_frame_info *in
 		*val = *addr;
 	return 0;
 }
+EXPORT_SYMBOL(unw_access_br);
 
 int
 unw_access_fr (struct unw_frame_info *info, int regnum, struct ia64_fpreg *val, int write)
@@ -467,6 +470,7 @@ unw_access_fr (struct unw_frame_info *in
 		*val = *addr;
 	return 0;
 }
+EXPORT_SYMBOL(unw_access_fr);
 
 int
 unw_access_ar (struct unw_frame_info *info, int regnum, unsigned long *val, int write)
@@ -559,6 +563,7 @@ unw_access_ar (struct unw_frame_info *in
 		*val = *addr;
 	return 0;
 }
+EXPORT_SYMBOL(unw_access_ar);
 
 int
 unw_access_pr (struct unw_frame_info *info, unsigned long *val, int write)
@@ -575,6 +580,7 @@ unw_access_pr (struct unw_frame_info *in
 		*val = *addr;
 	return 0;
 }
+EXPORT_SYMBOL(unw_access_pr);
 
 
 /* Routines to manipulate the state stack.  */
@@ -1897,6 +1903,7 @@ unw_unwind (struct unw_frame_info *info)
 	STAT(unw.stat.api.unwind_time += ia64_get_itc() - start; local_irq_restore(flags));
 	return retval;
 }
+EXPORT_SYMBOL(unw_unwind);
 
 int
 unw_unwind_to_user (struct unw_frame_info *info)
@@ -1917,6 +1924,7 @@ unw_unwind_to_user (struct unw_frame_inf
 	UNW_DPRINT(0, "unwind.%s: failed to unwind to user-level (ip=0x%lx)\n", __FUNCTION__, ip);
 	return -1;
 }
+EXPORT_SYMBOL(unw_unwind_to_user);
 
 static void
 init_frame_info (struct unw_frame_info *info, struct task_struct *t,
@@ -2014,6 +2022,7 @@ unw_init_from_blocked_task (struct unw_f
 	UNW_DPRINT(1, "unwind.%s\n", __FUNCTION__);
 	unw_init_frame_info(info, t, sw);
 }
+EXPORT_SYMBOL(unw_init_from_blocked_task);
 
 static void
 init_unwind_table (struct unw_table *table, const char *name, unsigned long segment_base,
diff -purN linux-2.6.1/arch/ia64/lib/Makefile linux-2.5/arch/ia64/lib/Makefile
--- linux-2.6.1/arch/ia64/lib/Makefile	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/arch/ia64/lib/Makefile	2004-01-07 16:08:07.000000000 +0000
@@ -2,11 +2,13 @@
 # Makefile for ia64-specific library routines..
 #
 
+obj-y := io.o
+
 lib-y := __divsi3.o __udivsi3.o __modsi3.o __umodsi3.o			\
 	__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o			\
 	checksum.o clear_page.o csum_partial_copy.o copy_page.o		\
 	clear_user.o strncpy_from_user.o strlen_user.o strnlen_user.o	\
-	flush.o io.o ip_fast_csum.o do_csum.o				\
+	flush.o ip_fast_csum.o do_csum.o				\
 	memset.o strlen.o swiotlb.o
 
 lib-$(CONFIG_ITANIUM)	+= copy_page.o copy_user.o memcpy.o
diff -purN linux-2.6.1/arch/ia64/lib/io.c linux-2.5/arch/ia64/lib/io.c
--- linux-2.6.1/arch/ia64/lib/io.c	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/arch/ia64/lib/io.c	2004-01-05 15:30:22.000000000 +0000
@@ -1,4 +1,5 @@
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/types.h>
 
 #include <asm/io.h>
@@ -17,6 +18,7 @@ __ia64_memcpy_fromio (void * to, unsigne
 		from++;
 	}
 }
+EXPORT_SYMBOL(__ia64_memcpy_fromio);
 
 /*
  * Copy data from "real" memory space to IO memory space.
@@ -32,6 +34,7 @@ __ia64_memcpy_toio (unsigned long to, vo
 		to++;
 	}
 }
+EXPORT_SYMBOL(__ia64_memcpy_toio);
 
 /*
  * "memset" on IO memory space.
@@ -48,6 +51,7 @@ __ia64_memset_c_io (unsigned long dst, u
 		dst++;
 	}
 }
+EXPORT_SYMBOL(__ia64_memset_c_io);
 
 #ifdef CONFIG_IA64_GENERIC
 
diff -purN linux-2.6.1/arch/ia64/lib/memcpy_mck.S linux-2.5/arch/ia64/lib/memcpy_mck.S
--- linux-2.6.1/arch/ia64/lib/memcpy_mck.S	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/lib/memcpy_mck.S	2004-01-16 01:51:26.000000000 +0000
@@ -155,7 +155,7 @@ GLOBAL_ENTRY(__copy_user)
 	mov	ar.ec=2
 (p10)	br.dpnt.few .aligned_src_tail
 	;;
-//	.align 32
+	TEXT_ALIGN(32)
 1:
 EX(.ex_handler, (p16)	ld8	r34=[src0],16)
 EK(.ex_handler, (p16)	ld8	r38=[src1],16)
@@ -312,7 +312,7 @@ EK(.ex_handler,	(p[D])	st8 [dst1] = t15,
 (p7)	mov	ar.lc = r21
 (p8)	mov	ar.lc = r0
 	;;
-//	.align 32
+	TEXT_ALIGN(32)
 1:	lfetch.fault	  [src_pre_mem], 128
 	lfetch.fault.excl [dst_pre_mem], 128
 	br.cloop.dptk.few 1b
@@ -518,7 +518,7 @@ EK(.ex_handler,  (p17)	st8	[dst1]=r39,8)
 		 shrp	r21=r22,r38,shift;	/* speculative work */			\
 		 br.sptk.few .unaligned_src_tail /* branch out of jump table */		\
 		 ;;
-//	.align 32
+	TEXT_ALIGN(32)
 .jump_table:
 	COPYU(8)	// unaligned cases
 .jmp1:
diff -purN linux-2.6.1/arch/ia64/lib/memset.S linux-2.5/arch/ia64/lib/memset.S
--- linux-2.6.1/arch/ia64/lib/memset.S	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/arch/ia64/lib/memset.S	2004-01-16 01:51:26.000000000 +0000
@@ -125,7 +125,7 @@ GLOBAL_ENTRY(memset)
 (p_zr)	br.cond.dptk.many .l1b			// Jump to use stf.spill
 ;; }
 
-//	.align 32 // -------------------------- //  L1A: store ahead into cache lines; fill later
+	TEXT_ALIGN(32) // --------------------- //  L1A: store ahead into cache lines; fill later
 { .mmi
 	and	tmp = -(LINE_SIZE), cnt		// compute end of range
 	mov	ptr9 = ptr1			// used for prefetching
@@ -194,7 +194,7 @@ GLOBAL_ENTRY(memset)
 	br.cond.dpnt.many  .move_bytes_from_alignment	// Branch no. 3
 ;; }
 
-//	.align 32
+	TEXT_ALIGN(32)
 .l1b:	// ------------------------------------ //  L1B: store ahead into cache lines; fill later
 { .mmi
 	and	tmp = -(LINE_SIZE), cnt		// compute end of range
@@ -261,7 +261,7 @@ GLOBAL_ENTRY(memset)
 	and	cnt = 0x1f, cnt			// compute the remaining cnt
 	mov.i   ar.lc = loopcnt
 ;; }
-//	.align 32
+	TEXT_ALIGN(32)
 .l2:	// ------------------------------------ //  L2A:  store 32B in 2 cycles
 { .mmb
 	stf8	[ptr1] = fvalue, 8
diff -purN linux-2.6.1/arch/ia64/mm/init.c linux-2.5/arch/ia64/mm/init.c
--- linux-2.6.1/arch/ia64/mm/init.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/ia64/mm/init.c	2004-01-05 15:44:22.000000000 +0000
@@ -43,15 +43,16 @@ extern void ia64_tlb_init (void);
 unsigned long MAX_DMA_ADDRESS = PAGE_OFFSET + 0x100000000UL;
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
-  unsigned long vmalloc_end = VMALLOC_END_INIT;
-  struct page *vmem_map;
-
-  EXPORT_SYMBOL(vmem_map);
+unsigned long vmalloc_end = VMALLOC_END_INIT;
+EXPORT_SYMBOL(vmalloc_end);
+struct page *vmem_map;
+EXPORT_SYMBOL(vmem_map);
 #endif
 
 static int pgt_cache_water[2] = { 25, 50 };
 
 struct page *zero_page_memmap_ptr;		/* map entry for zero page */
+EXPORT_SYMBOL(zero_page_memmap_ptr);
 
 void
 check_pgt_cache (void)
@@ -457,6 +458,7 @@ ia64_pfn_valid (unsigned long pfn)
 
 	return __get_user(byte, (char *) pfn_to_page(pfn)) == 0;
 }
+EXPORT_SYMBOL(ia64_pfn_valid);
 
 int
 find_largest_hole (u64 start, u64 end, void *arg)
diff -purN linux-2.6.1/arch/ia64/mm/numa.c linux-2.5/arch/ia64/mm/numa.c
--- linux-2.6.1/arch/ia64/mm/numa.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/arch/ia64/mm/numa.c	2004-01-12 06:54:38.000000000 +0000
@@ -18,6 +18,7 @@
 #include <linux/node.h>
 #include <linux/init.h>
 #include <linux/bootmem.h>
+#include <asm/mmzone.h>
 #include <asm/numa.h>
 
 static struct memblk *sysfs_memblks;
@@ -28,7 +29,7 @@ static struct cpu *sysfs_cpus;
  * The following structures are usually initialized by ACPI or
  * similar mechanisms and describe the NUMA characteristics of the machine.
  */
-int num_memblks = 0;
+int num_memblks;
 struct node_memblk_s node_memblk[NR_MEMBLKS];
 struct node_cpuid_s node_cpuid[NR_CPUS];
 /*
diff -purN linux-2.6.1/arch/ia64/mm/tlb.c linux-2.5/arch/ia64/mm/tlb.c
--- linux-2.6.1/arch/ia64/mm/tlb.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/arch/ia64/mm/tlb.c	2004-01-05 15:40:36.000000000 +0000
@@ -10,6 +10,7 @@
  *              IPI based ptc implementation and A-step IPI implementation.
  */
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -126,6 +127,7 @@ local_flush_tlb_all (void)
 	local_irq_restore(flags);
 	ia64_srlz_i();			/* srlz.i implies srlz.d */
 }
+EXPORT_SYMBOL(local_flush_tlb_all);
 
 void
 flush_tlb_range (struct vm_area_struct *vma, unsigned long start, unsigned long end)
@@ -162,6 +164,7 @@ flush_tlb_range (struct vm_area_struct *
 
 	ia64_srlz_i();			/* srlz.i implies srlz.d */
 }
+EXPORT_SYMBOL(flush_tlb_range);
 
 void __init
 ia64_tlb_init (void)
diff -purN linux-2.6.1/arch/ia64/pci/pci.c linux-2.5/arch/ia64/pci/pci.c
--- linux-2.6.1/arch/ia64/pci/pci.c	2004-01-09 06:59:27.000000000 +0000
+++ linux-2.5/arch/ia64/pci/pci.c	2004-01-05 10:33:32.000000000 +0000
@@ -223,6 +223,9 @@ add_window (struct acpi_resource *res, v
 
 	status = acpi_resource_to_address64(res, &addr);
 	if (ACPI_SUCCESS(status)) {
+		if (!addr.address_length)
+			return AE_OK;
+
 		if (addr.resource_type == ACPI_MEMORY_RANGE) {
 			flags = IORESOURCE_MEM;
 			root = &iomem_resource;
diff -purN linux-2.6.1/arch/ia64/scripts/check-text-align.S linux-2.5/arch/ia64/scripts/check-text-align.S
--- linux-2.6.1/arch/ia64/scripts/check-text-align.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/arch/ia64/scripts/check-text-align.S	2004-01-16 01:51:26.000000000 +0000
@@ -0,0 +1,6 @@
+	.proc foo
+	.prologue
+foo:	.save rp, r2
+	nop 0
+	.align 64
+	.endp foo
diff -purN linux-2.6.1/arch/ia64/scripts/unwcheck.py linux-2.5/arch/ia64/scripts/unwcheck.py
--- linux-2.6.1/arch/ia64/scripts/unwcheck.py	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/arch/ia64/scripts/unwcheck.py	2004-01-16 00:39:06.000000000 +0000
@@ -0,0 +1,64 @@
+#!/usr/bin/env python
+#
+# Usage: unwcheck.py FILE
+#
+# This script checks the unwind info of each function in file FILE
+# and verifies that the sum of the region-lengths matches the total
+# length of the function.
+#
+# Based on a shell/awk script originally written by Harish Patil,
+# which was converted to Perl by Matthew Chapman, which was converted
+# to Python by David Mosberger.
+#
+import os
+import re
+import sys
+
+if len(sys.argv) != 2:
+    print "Usage: %s FILE" % sys.argv[0]
+    sys.exit(2)
+
+readelf = os.getenv("READELF", "readelf")
+
+start_pattern = re.compile("<([^>]*)>: \[0x([0-9a-f]+)-0x([0-9a-f]+)\]")
+rlen_pattern  = re.compile(".*rlen=([0-9]+)")
+
+def check_func (func, slots, rlen_sum):
+    if slots != rlen_sum:
+        global num_errors
+        num_errors += 1
+        if not func: func = "[%#x-%#x]" % (start, end)
+        print "ERROR: %s: %lu slots, total region length = %lu" % (func, slots, rlen_sum)
+    return
+
+num_funcs = 0
+num_errors = 0
+func = False
+slots = 0
+rlen_sum = 0
+for line in os.popen("%s -u %s" % (readelf, sys.argv[1])):
+    m = start_pattern.match(line)
+    if m:
+        check_func(func, slots, rlen_sum)
+
+        func  = m.group(1)
+        start = long(m.group(2), 16)
+        end   = long(m.group(3), 16)
+        slots = 3 * (end - start) / 16
+        rlen_sum = 0L
+        num_funcs += 1
+    else:
+        m = rlen_pattern.match(line)
+        if m:
+            rlen_sum += long(m.group(1))
+check_func(func, slots, rlen_sum)
+
+if num_errors == 0:
+    print "No errors detected in %u functions." % num_funcs
+else:
+    if num_errors > 1:
+        err="errors"
+    else:
+        err="error"
+    print "%u %s detected in %u functions." % (num_errors, err, num_funcs)
+    sys.exit(1)
diff -purN linux-2.6.1/arch/ia64/scripts/unwcheck.sh linux-2.5/arch/ia64/scripts/unwcheck.sh
--- linux-2.6.1/arch/ia64/scripts/unwcheck.sh	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/arch/ia64/scripts/unwcheck.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,109 +0,0 @@
-#!/bin/sh
-#   Usage: unwcheck.sh <executable_file_name>
-#   Pre-requisite: readelf [from Gnu binutils package]
-#   Purpose: Check the following invariant
-#       For each code range in the input binary:
-#          Sum[ lengths of unwind regions] = Number of slots in code range.
-#   Author : Harish Patil
-#   First version: January 2002
-#   Modified : 2/13/2002
-#   Modified : 3/15/2002: duplicate detection
-readelf -u $1 | gawk '\
- function todec(hexstr){
-    dec = 0;
-    l = length(hexstr);
-    for (i = 1; i <= l; i++)
-    {
-        c = substr(hexstr, i, 1);
-        if (c == "A")
-            dec = dec*16 + 10;
-        else if (c == "B")
-            dec = dec*16 + 11;
-        else if (c == "C")
-            dec = dec*16 + 12;
-        else if (c == "D")
-            dec = dec*16 + 13;
-        else if (c == "E")
-            dec = dec*16 + 14;
-        else if (c == "F")
-            dec = dec*16 + 15;
-        else
-            dec = dec*16 + c;
-    }
-    return dec;
- }
- BEGIN { first = 1; sum_rlen = 0; no_slots = 0; errors=0; no_code_ranges=0; }
- {
-   if (NF==5 && $3=="info")
-   {
-      no_code_ranges += 1;
-      if (first == 0)
-      {
-         if (sum_rlen != no_slots)
-         {
-            print full_code_range;
-            print "       ", "lo = ", lo, " hi =", hi;
-            print "       ", "sum_rlen = ", sum_rlen, "no_slots = " no_slots;
-            print "       ","   ", "*******ERROR ***********";
-            print "       ","   ", "sum_rlen:", sum_rlen, " != no_slots:" no_slots;
-            errors += 1;
-         }
-         sum_rlen = 0;
-      }
-      full_code_range =  $0;
-      code_range =  $2;
-      gsub("..$", "", code_range);
-      gsub("^.", "", code_range);
-      split(code_range, addr, "-");
-      lo = toupper(addr[1]);
-
-      code_range_lo[no_code_ranges] = addr[1];
-      occurs[addr[1]] += 1;
-      full_range[addr[1]] = $0;
-
-      gsub("0X.[0]*", "", lo);
-      hi = toupper(addr[2]);
-      gsub("0X.[0]*", "", hi);
-      no_slots = (todec(hi) - todec(lo))/ 16*3
-      first = 0;
-   }
-   if (index($0,"rlen") > 0 )
-   {
-    rlen_str =  substr($0, index($0,"rlen"));
-    rlen = rlen_str;
-    gsub("rlen=", "", rlen);
-    gsub(")", "", rlen);
-    sum_rlen = sum_rlen +  rlen;
-   }
-  }
-  END {
-      if (first == 0)
-      {
-         if (sum_rlen != no_slots)
-         {
-            print "code_range=", code_range;
-            print "       ", "lo = ", lo, " hi =", hi;
-            print "       ", "sum_rlen = ", sum_rlen, "no_slots = " no_slots;
-            print "       ","   ", "*******ERROR ***********";
-            print "       ","   ", "sum_rlen:", sum_rlen, " != no_slots:" no_slots;
-            errors += 1;
-         }
-      }
-    no_duplicates = 0;
-    for (i=1; i<=no_code_ranges; i++)
-    {
-        cr = code_range_lo[i];
-        if (reported_cr[cr]==1) continue;
-        if ( occurs[cr] > 1)
-        {
-            reported_cr[cr] = 1;
-            print "Code range low ", code_range_lo[i], ":", full_range[cr], " occurs: ", occurs[cr], " times.";
-            print " ";
-            no_duplicates++;
-        }
-    }
-    print "======================================"
-    print "Total errors:", errors, "/", no_code_ranges, " duplicates:", no_duplicates;
-    print "======================================"
-  }
-  '
diff -purN linux-2.6.1/arch/ia64/sn/kernel/setup.c linux-2.5/arch/ia64/sn/kernel/setup.c
--- linux-2.6.1/arch/ia64/sn/kernel/setup.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/arch/ia64/sn/kernel/setup.c	2004-01-14 05:25:24.000000000 +0000
@@ -398,9 +398,6 @@ sn_cpu_init(void)
 	cnode = nasid_to_cnodeid(nasid);
 	slice = cpu_physical_id_to_slice(cpuphyid);
 
-	printk("CPU %d: nasid %d, slice %d, cnode %d\n",
-			smp_processor_id(), nasid, slice, cnode);
-
 	memset(pda, 0, sizeof(pda));
 	pda->p_nodepda = nodepdaindr[cnode];
 	pda->led_address = (typeof(pda->led_address)) (LED0 + (slice<<LED_CPU_SHIFT));
diff -purN linux-2.6.1/arch/sparc/kernel/irq.c linux-2.5/arch/sparc/kernel/irq.c
--- linux-2.6.1/arch/sparc/kernel/irq.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/arch/sparc/kernel/irq.c	2004-01-09 09:40:53.000000000 +0000
@@ -49,6 +49,9 @@
 #include <asm/pcic.h>
 #include <asm/cacheflush.h>
 
+/* Used to protect the IRQ action lists */
+spinlock_t irq_action_lock = SPIN_LOCK_UNLOCKED;
+
 /*
  * Dave Redman (djhr@tadpole.co.uk)
  *
@@ -492,7 +495,7 @@ int request_fast_irq(unsigned int irq,
 		return -EBUSY;
 	}
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&irq_action_lock, flags);
 
 	/* If this is flagged as statically allocated then we use our
 	 * private struct which is never freed.
@@ -507,10 +510,10 @@ int request_fast_irq(unsigned int irq,
 	
 	if (action == NULL)
 	    action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
-						 GFP_KERNEL);
+						 GFP_ATOMIC);
 	
 	if (!action) { 
-		restore_flags(flags);
+		spin_unlock_irqrestore(&irq_action_lock, flags);
 		return -ENOMEM;
 	}
 
@@ -547,7 +550,7 @@ int request_fast_irq(unsigned int irq,
 	*(cpu_irq + irq_action) = action;
 
 	enable_irq(irq);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&irq_action_lock, flags);
 	return 0;
 }
 
@@ -586,7 +589,7 @@ int request_irq(unsigned int irq,
 		action = NULL;		/* Or else! */
 	}
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&irq_action_lock, flags);
 
 	/* If this is flagged as statically allocated then we use our
 	 * private struct which is never freed.
@@ -600,10 +603,10 @@ int request_irq(unsigned int irq,
 	
 	if (action == NULL)
 	    action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
-						 GFP_KERNEL);
+						 GFP_ATOMIC);
 	
 	if (!action) { 
-		restore_flags(flags);
+		spin_unlock_irqrestore(&irq_action_lock, flags);
 		return -ENOMEM;
 	}
 
@@ -620,7 +623,7 @@ int request_irq(unsigned int irq,
 		*(cpu_irq + irq_action) = action;
 
 	enable_irq(irq);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&irq_action_lock, flags);
 	return 0;
 }
 
diff -purN linux-2.6.1/arch/sparc/mm/fault.c linux-2.5/arch/sparc/mm/fault.c
--- linux-2.6.1/arch/sparc/mm/fault.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/sparc/mm/fault.c	2004-01-09 09:39:38.000000000 +0000
@@ -36,7 +36,6 @@
 
 #define ELEMENTS(arr) (sizeof (arr)/sizeof (arr[0]))
 
-extern struct sparc_phys_banks sp_banks[SPARC_PHYS_BANKS+1];
 extern int prom_node_root;
 
 /* At boot time we determine these two values necessary for setting
diff -purN linux-2.6.1/arch/sparc/mm/srmmu.c linux-2.5/arch/sparc/mm/srmmu.c
--- linux-2.6.1/arch/sparc/mm/srmmu.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/arch/sparc/mm/srmmu.c	2004-01-09 09:39:38.000000000 +0000
@@ -349,7 +349,7 @@ void srmmu_free_nocache(unsigned long va
 		    vaddr, (unsigned long)SRMMU_NOCACHE_VADDR);
 		BUG();
 	}
-	if (vaddr+size >= srmmu_nocache_end) {
+	if (vaddr+size > srmmu_nocache_end) {
 		printk("Vaddr %lx is bigger than nocache end 0x%lx\n",
 		    vaddr, srmmu_nocache_end);
 		BUG();
@@ -1071,7 +1071,7 @@ void __init srmmu_early_allocate_ptable_
 		}
 		if (start > (0xffffffffUL - SRMMU_PMD_SIZE_SOFT))
 			break;
-		start = (start + SRMMU_PMD_SIZE) & SRMMU_PMD_MASK;
+		start = (start + SRMMU_PMD_SIZE_SOFT) & SRMMU_PMD_MASK_SOFT;
 	}
 }
 
@@ -1101,7 +1101,7 @@ void __init srmmu_allocate_ptable_skelet
 		}
 		if (start > (0xffffffffUL - SRMMU_PMD_SIZE_SOFT))
 			break;
-		start = (start + SRMMU_PMD_SIZE) & SRMMU_PMD_MASK;
+		start = (start + SRMMU_PMD_SIZE_SOFT) & SRMMU_PMD_MASK_SOFT;
 	}
 }
 
diff -purN linux-2.6.1/arch/sparc64/Kconfig linux-2.5/arch/sparc64/Kconfig
--- linux-2.6.1/arch/sparc64/Kconfig	2004-01-09 06:59:57.000000000 +0000
+++ linux-2.5/arch/sparc64/Kconfig	2004-01-09 10:13:59.000000000 +0000
@@ -489,6 +489,22 @@ config WATCHDOG_RIO
 	  machines.  The watchdog timeout period is normally one minute but
 	  can be changed with a boot-time parameter.
 
+config CMDLINE_BOOL
+	bool "Default bootloader kernel arguments"
+
+config CMDLINE
+	string "Initial kernel command string"
+	depends on CMDLINE_BOOL
+	default "console=ttyS0,9600 root=/dev/sda1"
+	help
+	  Say Y here if you want to be able to pass default arguments to
+	  the kernel. This will be overridden by the bootloader, if you
+	  use one (such as SILO). This is most useful if you want to boot
+	  a kernel from TFTP, and want default options to be available
+	  with having them passed on the command line.
+
+	  NOTE: This option WILL override the PROM bootargs setting!
+
 endmenu
 
 source "drivers/base/Kconfig"
diff -purN linux-2.6.1/arch/sparc64/defconfig linux-2.5/arch/sparc64/defconfig
--- linux-2.6.1/arch/sparc64/defconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/arch/sparc64/defconfig	2004-01-09 10:14:39.000000000 +0000
@@ -102,6 +102,7 @@ CONFIG_ENVCTRL=m
 CONFIG_DISPLAY7SEG=m
 CONFIG_WATCHDOG_CP1XXX=m
 CONFIG_WATCHDOG_RIO=m
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Generic Driver Options
@@ -1286,6 +1287,7 @@ CONFIG_DVB_CORE=m
 CONFIG_DVB_TWINHAN_DST=m
 CONFIG_DVB_STV0299=m
 CONFIG_DVB_SP887X=m
+CONFIG_DVB_SP887X_FIRMWARE_FILE="/etc/dvb/sc_main.mc"
 CONFIG_DVB_ALPS_TDLB7=m
 CONFIG_DVB_ALPS_TDMB7=m
 CONFIG_DVB_ATMEL_AT76C651=m
@@ -1295,12 +1297,12 @@ CONFIG_DVB_GRUNDIG_29504_401=m
 CONFIG_DVB_MT312=m
 CONFIG_DVB_VES1820=m
 CONFIG_DVB_VES1X93=m
-CONFIG_DVB_SP887X_FIRMWARE_FILE="/etc/dvb/sc_main.mc"
 
 #
 # Supported SAA7146 based PCI Adapters
 #
-# CONFIG_DVB_AV7110 is not set
+CONFIG_DVB_AV7110=m
+# CONFIG_DVB_AV7110_OSD is not set
 CONFIG_DVB_BUDGET=m
 CONFIG_DVB_BUDGET_CI=m
 CONFIG_DVB_BUDGET_AV=m
diff -purN linux-2.6.1/arch/sparc64/kernel/head.S linux-2.5/arch/sparc64/kernel/head.S
--- linux-2.6.1/arch/sparc64/kernel/head.S	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/sparc64/kernel/head.S	2004-01-09 09:31:50.000000000 +0000
@@ -151,6 +151,9 @@ cheetah_generic_boot:
 	blu,pt	%xcc, 1b
 	 add	%l0, (1 << 3), %l0
 
+	/* BUG() if we get here... */
+	ta	0x5
+
 cheetah_got_tlbentry:
 	ldxa	[%l0] ASI_ITLB_DATA_ACCESS, %g0
 	ldxa	[%l0] ASI_ITLB_DATA_ACCESS, %g1
@@ -333,6 +336,9 @@ spitfire_create_mappings:
 	blu,pt	%xcc, 1b
 	 add	%l0, (1 << 3), %l0
 
+	/* BUG() if we get here... */
+	ta	0x5
+
 spitfire_got_tlbentry:
 	/* Nops here again, perhaps Cheetah/Blackbird are better behaved... */
 	nop
diff -purN linux-2.6.1/arch/sparc64/prom/bootstr.c linux-2.5/arch/sparc64/prom/bootstr.c
--- linux-2.6.1/arch/sparc64/prom/bootstr.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/arch/sparc64/prom/bootstr.c	2004-01-09 10:13:59.000000000 +0000
@@ -21,6 +21,10 @@ struct {
 	char bootstr_buf[BARG_LEN];
 } bootstr_info = {
 	.bootstr_len = BARG_LEN,
+#ifdef CONFIG_CMDLINE
+	.bootstr_valid = 1,
+	.bootstr_buf = CONFIG_CMDLINE,
+#endif
 };
 
 char * __init
diff -purN linux-2.6.1/drivers/atm/atmdev_init.c linux-2.5/drivers/atm/atmdev_init.c
--- linux-2.6.1/drivers/atm/atmdev_init.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/atm/atmdev_init.c	2004-01-14 00:28:09.000000000 +0000
@@ -10,9 +10,6 @@
 #ifdef CONFIG_ATM_ZATM
 extern int zatm_detect(void);
 #endif
-#ifdef CONFIG_ATM_NICSTAR
-extern int nicstar_detect(void);
-#endif
 #ifdef CONFIG_ATM_AMBASSADOR
 extern int amb_detect(void);
 #endif
@@ -41,9 +38,6 @@ int __init atmdev_init(void)
 #ifdef CONFIG_ATM_ZATM
 	devs += zatm_detect();
 #endif
-#ifdef CONFIG_ATM_NICSTAR
-	devs += nicstar_detect();
-#endif
 #ifdef CONFIG_ATM_AMBASSADOR
 	devs += amb_detect();
 #endif
diff -purN linux-2.6.1/drivers/atm/nicstar.c linux-2.5/drivers/atm/nicstar.c
--- linux-2.6.1/drivers/atm/nicstar.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/atm/nicstar.c	2004-01-14 00:28:09.000000000 +0000
@@ -214,8 +214,8 @@
 
 static u32 ns_read_sram(ns_dev *card, u32 sram_address);
 static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count);
-static int __init ns_init_card(int i, struct pci_dev *pcidev);
-static void __init ns_init_card_error(ns_dev *card, int error);
+static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
+static void __devinit ns_init_card_error(ns_dev *card, int error);
 static scq_info *get_scq(int size, u32 scd);
 static void free_scq(scq_info *scq, struct atm_vcc *vcc);
 static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
@@ -276,136 +276,151 @@ MODULE_LICENSE("GPL");
 
 /* Functions*******************************************************************/
 
-static int __init nicstar_module_init(void)
+static int __devinit nicstar_init_one(struct pci_dev *pcidev,
+				      const struct pci_device_id *ent)
 {
-   int i;
-   unsigned error = 0;	/* Initialized to remove compile warning */
-   struct pci_dev *pcidev;
+   static int index = -1;
+   unsigned int error;
 
-   XPRINTK("nicstar: nicstar_module_init() called.\n");
+   index++;
+   cards[index] = NULL;
 
-   for(i = 0; i < NS_MAX_CARDS; i++)
-      cards[i] = NULL;
-
-   pcidev = NULL;
-   for(i = 0; i < NS_MAX_CARDS; i++)
-   {
-      if ((pcidev = pci_find_device(PCI_VENDOR_ID_IDT,
-                                    PCI_DEVICE_ID_IDT_IDT77201,
-                                    pcidev)) == NULL)
-         break;
-
-      error = ns_init_card(i, pcidev);
-      if (error)
-         cards[i--] = NULL;	/* Try to find another card but don't increment index */
+   error = ns_init_card(index, pcidev);
+   if (error) {
+      cards[index--] = NULL;	/* don't increment index */
+      goto err_out;
    }
 
-   if (i == 0)
-   {
-      if (!error)
-      {
-         printk("nicstar: no cards found.\n");
-         return -ENXIO;
-      }
-      else
-         return -EIO;
-   }
-   TXPRINTK("nicstar: TX debug enabled.\n");
-   RXPRINTK("nicstar: RX debug enabled.\n");
-   PRINTK("nicstar: General debug enabled.\n");
-#ifdef PHY_LOOPBACK
-   printk("nicstar: using PHY loopback.\n");
-#endif /* PHY_LOOPBACK */
-   XPRINTK("nicstar: nicstar_module_init() returned.\n");
-
-   init_timer(&ns_timer);
-   ns_timer.expires = jiffies + NS_POLL_PERIOD;
-   ns_timer.data = 0UL;
-   ns_timer.function = ns_poll;
-   add_timer(&ns_timer);
    return 0;
+err_out:
+   return -ENODEV;
 }
 
 
 
-static void __exit nicstar_module_exit(void)
+static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
 {
    int i, j;
-   unsigned short pci_command;
-   ns_dev *card;
+   ns_dev *card = pci_get_drvdata(pcidev);
    struct sk_buff *hb;
    struct sk_buff *iovb;
    struct sk_buff *lb;
    struct sk_buff *sb;
    
-   XPRINTK("nicstar: cleanup_module() called.\n");
+   i = card->index;
 
-   del_timer(&ns_timer);
+   if (cards[i] == NULL)
+      return;
 
-   for (i = 0; i < NS_MAX_CARDS; i++)
+   if (card->atmdev->phy && card->atmdev->phy->stop)
+      card->atmdev->phy->stop(card->atmdev);
+
+   /* Stop everything */
+   writel(0x00000000, card->membase + CFG);
+
+   /* De-register device */
+   atm_dev_deregister(card->atmdev);
+
+   /* Disable PCI device */
+   pci_disable_device(pcidev);
+   
+   /* Free up resources */
+   j = 0;
+   PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
+   while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
    {
-      if (cards[i] == NULL)
-         continue;
+      dev_kfree_skb_any(hb);
+      j++;
+   }
+   PRINTK("nicstar%d: %d huge buffers freed.\n", i, j);
+   j = 0;
+   PRINTK("nicstar%d: freeing %d iovec buffers.\n", i, card->iovpool.count);
+   while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
+   {
+      dev_kfree_skb_any(iovb);
+      j++;
+   }
+   PRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);
+   while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
+      dev_kfree_skb_any(lb);
+   while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
+      dev_kfree_skb_any(sb);
+   free_scq(card->scq0, NULL);
+   for (j = 0; j < NS_FRSCD_NUM; j++)
+   {
+      if (card->scd2vc[j] != NULL)
+         free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
+   }
+   kfree(card->rsq.org);
+   kfree(card->tsq.org);
+   free_irq(card->pcidev->irq, card);
+   iounmap((void *) card->membase);
+   kfree(card);
+}
 
-      card = cards[i];
 
-      if (card->atmdev->phy && card->atmdev->phy->stop)
-        card->atmdev->phy->stop(card->atmdev);
 
-      /* Stop everything */
-      writel(0x00000000, card->membase + CFG);
+static struct pci_device_id nicstar_pci_tbl[] __devinitdata =
+{
+	{PCI_VENDOR_ID_IDT, PCI_DEVICE_ID_IDT_IDT77201,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}			/* terminate list */
+};
+MODULE_DEVICE_TABLE(pci, nicstar_pci_tbl);
 
-      /* De-register device */
-      atm_dev_deregister(card->atmdev);
 
-      /* Disable memory mapping and busmastering */
-      if (pci_read_config_word(card->pcidev, PCI_COMMAND, &pci_command) != 0)
-      {
-         printk("nicstar%d: can't read PCI_COMMAND.\n", i);
-      }
-      pci_command &= ~(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
-      if (pci_write_config_word(card->pcidev, PCI_COMMAND, pci_command) != 0)
-      {
-         printk("nicstar%d: can't write PCI_COMMAND.\n", i);
-      }
-      
-      /* Free up resources */
-      j = 0;
-      PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
-      while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
-      {
-         dev_kfree_skb_any(hb);
-	 j++;
-      }
-      PRINTK("nicstar%d: %d huge buffers freed.\n", i, j);
-      j = 0;
-      PRINTK("nicstar%d: freeing %d iovec buffers.\n", i, card->iovpool.count);
-      while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
-      {
-         dev_kfree_skb_any(iovb);
-         j++;
-      }
-      PRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);
-      while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
-         dev_kfree_skb_any(lb);
-      while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
-         dev_kfree_skb_any(sb);
-      free_scq(card->scq0, NULL);
-      for (j = 0; j < NS_FRSCD_NUM; j++)
-      {
-         if (card->scd2vc[j] != NULL)
-	    free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
-      }
-      kfree(card->rsq.org);
-      kfree(card->tsq.org);
-      free_irq(card->pcidev->irq, card);
-      iounmap((void *) card->membase);
-      kfree(card);
-      
+
+static struct pci_driver nicstar_driver = {
+	.name		= "nicstar",
+	.id_table	= nicstar_pci_tbl,
+	.probe		= nicstar_init_one,
+	.remove		= __devexit_p(nicstar_remove_one),
+};
+
+
+
+static int __init nicstar_init(void)
+{
+   unsigned error = 0;	/* Initialized to remove compile warning */
+
+   XPRINTK("nicstar: nicstar_init() called.\n");
+
+   error = pci_module_init(&nicstar_driver);
+   
+   TXPRINTK("nicstar: TX debug enabled.\n");
+   RXPRINTK("nicstar: RX debug enabled.\n");
+   PRINTK("nicstar: General debug enabled.\n");
+#ifdef PHY_LOOPBACK
+   printk("nicstar: using PHY loopback.\n");
+#endif /* PHY_LOOPBACK */
+   XPRINTK("nicstar: nicstar_init() returned.\n");
+
+   if (!error) {
+      init_timer(&ns_timer);
+      ns_timer.expires = jiffies + NS_POLL_PERIOD;
+      ns_timer.data = 0UL;
+      ns_timer.function = ns_poll;
+      add_timer(&ns_timer);
    }
-   XPRINTK("nicstar: cleanup_module() returned.\n");
+   
+   return error;
+}
+
+
+
+static void __exit nicstar_cleanup(void)
+{
+   XPRINTK("nicstar: nicstar_cleanup() called.\n");
+
+   del_timer(&ns_timer);
+
+   pci_unregister_driver(&nicstar_driver);
+
+   XPRINTK("nicstar: nicstar_cleanup() returned.\n");
 }
 
+
+
 static u32 ns_read_sram(ns_dev *card, u32 sram_address)
 {
    unsigned long flags;
@@ -445,11 +460,10 @@ static void ns_write_sram(ns_dev *card, 
 }
 
 
-static int __init ns_init_card(int i, struct pci_dev *pcidev)
+static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 {
    int j;
    struct ns_dev *card = NULL;
-   unsigned short pci_command;
    unsigned char pci_latency;
    unsigned error;
    u32 data;
@@ -478,6 +492,8 @@ static int __init ns_init_card(int i, st
    spin_lock_init(&card->int_lock);
    spin_lock_init(&card->res_lock);
       
+   pci_set_drvdata(pcidev, card);
+   
    card->index = i;
    card->atmdev = NULL;
    card->pcidev = pcidev;
@@ -492,21 +508,7 @@ static int __init ns_init_card(int i, st
    }
    PRINTK("nicstar%d: membase at 0x%x.\n", i, card->membase);
 
-   if (pci_read_config_word(pcidev, PCI_COMMAND, &pci_command) != 0)
-   {
-      printk("nicstar%d: can't read PCI_COMMAND.\n", i);
-      error = 4;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   pci_command |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
-   if (pci_write_config_word(pcidev, PCI_COMMAND, pci_command) != 0)
-   {
-      printk("nicstar%d: can't write PCI_COMMAND.\n", i);
-      error = 5;
-      ns_init_card_error(card, error);
-      return error;
-   }
+   pci_set_master(pcidev);
 
    if (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0)
    {
@@ -932,7 +934,7 @@ static int __init ns_init_card(int i, st
 
 
 
-static void __init ns_init_card_error(ns_dev *card, int error)
+static void __devinit ns_init_card_error(ns_dev *card, int error)
 {
    if (error >= 17)
    {
@@ -981,6 +983,7 @@ static void __init ns_init_card_error(ns
    }
    if (error >= 3)
    {
+      pci_disable_device(card->pcidev);
       kfree(card);
    }
 }
@@ -3099,5 +3102,7 @@ static unsigned char ns_phy_get(struct a
    return (unsigned char) data;
 }
 
-module_init(nicstar_module_init);
-module_exit(nicstar_module_exit);
+
+
+module_init(nicstar_init);
+module_exit(nicstar_cleanup);
diff -purN linux-2.6.1/drivers/bluetooth/Kconfig linux-2.5/drivers/bluetooth/Kconfig
--- linux-2.6.1/drivers/bluetooth/Kconfig	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/bluetooth/Kconfig	2003-12-27 19:03:08.000000000 +0000
@@ -13,22 +13,14 @@ config BT_HCIUSB
 	  Say Y here to compile support for Bluetooth USB devices into the
 	  kernel or say M to compile it as module (hci_usb).
 
-config BT_USB_SCO
-	bool "SCO over HCI USB support"
+config BT_HCIUSB_SCO
+	bool "SCO (voice) support"
 	depends on BT_HCIUSB
 	help
 	  This option enables the SCO support in the HCI USB driver. You need this
-	  to transmit voice data with your Bluetooth USB device. 
-	  Say Y here to compile support for SCO over HCI USB.
+	  to transmit voice data with your Bluetooth USB device.
 
-config BT_USB_ZERO_PACKET
-	bool "USB zero packet support"
-	depends on BT_HCIUSB
-	help
-	  This option is provided only as a work around for buggy Bluetooth USB 
-	  devices. Do _not_ enable it unless you know for sure that your device 
-	  requires zero packets.
-	  Most people should say N here.
+	  Say Y here to compile support for SCO over HCI USB.
 
 config BT_HCIUART
 	tristate "HCI UART driver"
@@ -65,13 +57,38 @@ config BT_HCIUART_BCSP
 	  Say Y here to compile support for HCI BCSP protocol.
 
 config BT_HCIUART_BCSP_TXCRC
-        bool "Transmit CRC with every BCSP packet"
-        depends on BT_HCIUART_BCSP
-        help
+	bool "Transmit CRC with every BCSP packet"
+	depends on BT_HCIUART_BCSP
+	help
 	  If you say Y here, a 16-bit CRC checksum will be transmitted along with
 	  every BCSP (BlueCore Serial Protocol) packet sent to the Bluetooth chip.
 	  This increases reliability, but slightly reduces efficiency.
 
+config BT_HCIBCM203X
+	tristate "HCI BCM203x USB driver"
+	depends on USB && BT
+	select FW_LOADER
+	help
+	  Bluetooth HCI BCM203x USB driver.
+	  This driver provides the firmware loading mechanism for the Broadcom
+	  Blutonium based devices.
+
+	  Say Y here to compile support for HCI BCM203x devices into the
+	  kernel or say M to compile it as module (bcm203x).
+
+config BT_HCIBFUSB
+	tristate "HCI BlueFRITZ! USB driver"
+	depends on USB && BT
+	select FW_LOADER
+	help
+	  Bluetooth HCI BlueFRITZ! USB driver.
+	  This driver provides support for Bluetooth USB devices with AVM
+	  interface:
+	     AVM BlueFRITZ! USB
+
+	  Say Y here to compile support for HCI BFUSB devices into the
+	  kernel or say M to compile it as module (bfusb).
+
 config BT_HCIDTL1
 	tristate "HCI DTL1 (PC Card) driver"
 	depends on PCMCIA && BT
diff -purN linux-2.6.1/drivers/bluetooth/Makefile linux-2.5/drivers/bluetooth/Makefile
--- linux-2.6.1/drivers/bluetooth/Makefile	2004-01-09 07:00:05.000000000 +0000
+++ linux-2.5/drivers/bluetooth/Makefile	2003-12-27 18:57:21.000000000 +0000
@@ -5,6 +5,8 @@
 obj-$(CONFIG_BT_HCIUSB)		+= hci_usb.o
 obj-$(CONFIG_BT_HCIVHCI)	+= hci_vhci.o
 obj-$(CONFIG_BT_HCIUART)	+= hci_uart.o
+obj-$(CONFIG_BT_HCIBCM203X)	+= bcm203x.o
+obj-$(CONFIG_BT_HCIBFUSB)	+= bfusb.o
 obj-$(CONFIG_BT_HCIDTL1)	+= dtl1_cs.o
 obj-$(CONFIG_BT_HCIBT3C)	+= bt3c_cs.o
 obj-$(CONFIG_BT_HCIBLUECARD)	+= bluecard_cs.o
diff -purN linux-2.6.1/drivers/bluetooth/bcm203x.c linux-2.5/drivers/bluetooth/bcm203x.c
--- linux-2.6.1/drivers/bluetooth/bcm203x.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/bluetooth/bcm203x.c	2003-12-28 13:56:20.000000000 +0000
@@ -0,0 +1,309 @@
+/*
+ *
+ *  Broadcom Blutonium firmware driver
+ *
+ *  Copyright (C) 2003  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+#include <linux/usb.h>
+
+#include <net/bluetooth/bluetooth.h>
+
+#ifndef CONFIG_BT_HCIBCM203X_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define VERSION "1.0"
+
+static struct usb_device_id bcm203x_table[] = {
+	/* Broadcom Blutonium (BCM2033) */
+	{ USB_DEVICE(0x0a5c, 0x2033) },
+
+	{ }	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, bcm203x_table);
+
+
+#define BCM203X_ERROR		0
+#define BCM203X_RESET		1
+#define BCM203X_LOAD_MINIDRV	2
+#define BCM203X_SELECT_MEMORY	3
+#define BCM203X_CHECK_MEMORY	4
+#define BCM203X_LOAD_FIRMWARE	5
+#define BCM203X_CHECK_FIRMWARE	6
+
+#define BCM203X_IN_EP		0x81
+#define BCM203X_OUT_EP		0x02
+
+struct bcm203x_data {
+	struct usb_device	*udev;
+
+	unsigned long		state;
+
+	struct timer_list	timer;
+
+	struct urb		*urb;
+	unsigned char		buffer[4096];
+
+	unsigned char		*fw_data;
+	unsigned int		fw_size;
+	unsigned int		fw_sent;
+};
+
+static void bcm203x_complete(struct urb *urb, struct pt_regs *regs)
+{
+	struct bcm203x_data *data = urb->context;
+	struct usb_device *udev = urb->dev;
+	int len;
+
+	BT_DBG("udev %p urb %p", udev, urb);
+
+	if (urb->status) {
+		BT_ERR("URB failed with status %d", urb->status);
+		data->state = BCM203X_ERROR;
+		return;
+	}
+
+	switch (data->state) {
+	case BCM203X_LOAD_MINIDRV:
+		memcpy(data->buffer, "#", 1);
+
+		usb_fill_bulk_urb(urb, udev,
+				usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+				data->buffer, 1, bcm203x_complete, data);
+
+		data->state = BCM203X_SELECT_MEMORY;
+
+		mod_timer(&data->timer, jiffies + (HZ / 10));
+		break;
+
+	case BCM203X_SELECT_MEMORY:
+		usb_fill_int_urb(urb, udev,
+				usb_rcvintpipe(udev, BCM203X_IN_EP),
+				data->buffer, 32, bcm203x_complete, data, 1);
+
+		data->state = BCM203X_CHECK_MEMORY;
+
+		if (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)
+			BT_ERR("Can't submit URB");
+		break;
+
+	case BCM203X_CHECK_MEMORY:
+		if (data->buffer[0] != '#') {
+			BT_ERR("Memory select failed");
+			data->state = BCM203X_ERROR;
+			break;
+		}
+
+		data->state = BCM203X_LOAD_FIRMWARE;
+
+	case BCM203X_LOAD_FIRMWARE:
+		if (data->fw_sent == data->fw_size) {
+			usb_fill_int_urb(urb, udev,
+					usb_rcvintpipe(udev, BCM203X_IN_EP),
+					data->buffer, 32,
+					bcm203x_complete, data, 1);
+
+			data->state = BCM203X_CHECK_FIRMWARE;
+		} else {
+			len = min_t(uint, data->fw_size - data->fw_sent,
+							sizeof(data->buffer));
+
+			usb_fill_bulk_urb(urb, udev,
+					usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+					data->fw_data + data->fw_sent, len,
+					bcm203x_complete, data);
+
+			data->fw_sent += len;
+		}
+
+		if (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)
+			BT_ERR("Can't submit URB");
+		break;
+
+	case BCM203X_CHECK_FIRMWARE:
+		if (data->buffer[0] != '.') {
+			BT_ERR("Firmware loading failed");
+			data->state = BCM203X_ERROR;
+			break;
+		}
+
+		data->state = BCM203X_RESET;
+		break;
+	}
+}
+
+static void bcm203x_timer(unsigned long user_data)
+{
+	struct bcm203x_data *data = (struct bcm203x_data *) user_data;
+
+	if (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)
+		BT_ERR("Can't submit URB");
+}
+
+static int bcm203x_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	const struct firmware *firmware;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct bcm203x_data *data;
+
+	BT_DBG("intf %p id %p", intf, id);
+
+	if (intf->altsetting->desc.bInterfaceNumber != 0)
+		return -ENODEV;
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		BT_ERR("Can't allocate memory for data structure");
+		return -ENOMEM;
+	}
+
+	memset(data, 0, sizeof(*data));
+
+	data->udev  = udev;
+	data->state = BCM203X_LOAD_MINIDRV;
+
+	data->urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!data->urb) {
+		BT_ERR("Can't allocate URB");
+		kfree(data);
+		return -ENOMEM;
+	}
+
+	if (request_firmware(&firmware, "BCM2033-MD.hex", &udev->dev) < 0) {
+		BT_ERR("Mini driver request failed");
+		usb_free_urb(data->urb);
+		kfree(data);
+		return -EIO;
+	}
+
+	BT_DBG("minidrv data %p size %d", firmware->data, firmware->size);
+
+	if (firmware->size > sizeof(data->buffer)) {
+		BT_ERR("Mini driver exceeds size of buffer");
+		release_firmware(firmware);
+		usb_free_urb(data->urb);
+		kfree(data);
+		return -EIO;
+	}
+
+	memcpy(data->buffer, firmware->data, firmware->size);
+
+	usb_fill_bulk_urb(data->urb, udev,
+			usb_sndbulkpipe(udev, BCM203X_OUT_EP),
+			data->buffer, firmware->size, bcm203x_complete, data);
+
+	release_firmware(firmware);
+
+	if (request_firmware(&firmware, "BCM2033-FW.bin", &udev->dev) < 0) {
+		BT_ERR("Firmware request failed");
+		usb_free_urb(data->urb);
+		kfree(data);
+		return -EIO;
+	}
+
+	BT_DBG("firmware data %p size %d", firmware->data, firmware->size);
+
+	data->fw_data = kmalloc(firmware->size, GFP_KERNEL);
+	if (!data->fw_data) {
+		BT_ERR("Can't allocate memory for firmware image");
+		usb_free_urb(data->urb);
+		kfree(data);
+		return -ENOMEM;
+	}
+
+	memcpy(data->fw_data, firmware->data, firmware->size);
+	data->fw_size = firmware->size;
+	data->fw_sent = 0;
+
+	release_firmware(firmware);
+
+	init_timer(&data->timer);
+	data->timer.function = bcm203x_timer;
+	data->timer.data = (unsigned long) data;
+
+	usb_set_intfdata(intf, data);
+
+	mod_timer(&data->timer, jiffies + HZ);
+
+	return 0;
+}
+
+static void bcm203x_disconnect(struct usb_interface *intf)
+{
+	struct bcm203x_data *data = usb_get_intfdata(intf);
+
+	BT_DBG("intf %p", intf);
+
+	usb_unlink_urb(data->urb);
+
+	usb_set_intfdata(intf, NULL);
+
+	usb_free_urb(data->urb);
+	kfree(data->fw_data);
+	kfree(data);
+}
+
+static struct usb_driver bcm203x_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "bcm203x",
+	.probe		= bcm203x_probe,
+	.disconnect	= bcm203x_disconnect,
+	.id_table	= bcm203x_table,
+};
+
+static int __init bcm203x_init(void)
+{
+	int err;
+
+	BT_INFO("Broadcom Blutonium firmware driver ver %s", VERSION);
+
+	err = usb_register(&bcm203x_driver);
+	if (err < 0)
+		BT_ERR("Failed to register USB driver");
+
+	return err;
+}
+
+static void __exit bcm203x_cleanup(void)
+{
+	usb_deregister(&bcm203x_driver);
+}
+
+module_init(bcm203x_init);
+module_exit(bcm203x_cleanup);
+
+MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
+MODULE_DESCRIPTION("Broadcom Blutonium firmware driver ver " VERSION);
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/bluetooth/bfusb.c linux-2.5/drivers/bluetooth/bfusb.c
--- linux-2.6.1/drivers/bluetooth/bfusb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/bluetooth/bfusb.c	2003-12-19 18:20:44.000000000 +0000
@@ -0,0 +1,782 @@
+/*
+ *
+ *  AVM BlueFRITZ! USB driver
+ *
+ *  Copyright (C) 2003  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+#include <linux/usb.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#ifndef CONFIG_BT_HCIBFUSB_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define VERSION "1.1"
+
+static struct usb_driver bfusb_driver;
+
+static struct usb_device_id bfusb_table[] = {
+	/* AVM BlueFRITZ! USB */
+	{ USB_DEVICE(0x057c, 0x2200) },
+
+	{ }	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, bfusb_table);
+
+
+#define BFUSB_MAX_BLOCK_SIZE	256
+
+#define BFUSB_BLOCK_TIMEOUT	(HZ * 3)
+
+#define BFUSB_TX_PROCESS	1
+#define BFUSB_TX_WAKEUP		2
+
+#define BFUSB_MAX_BULK_TX	2
+#define BFUSB_MAX_BULK_RX	2
+
+struct bfusb {
+	struct hci_dev		hdev;
+
+	unsigned long		state;
+
+	struct usb_device	*udev;
+
+	unsigned int		bulk_in_ep;
+	unsigned int		bulk_out_ep;
+	unsigned int		bulk_pkt_size;
+
+	rwlock_t		lock;
+
+	struct sk_buff_head	transmit_q;
+
+	struct sk_buff		*reassembly;
+
+	atomic_t		pending_tx;
+	struct sk_buff_head	pending_q;
+	struct sk_buff_head	completed_q;
+};
+
+struct bfusb_scb {
+	struct urb *urb;
+};
+
+static void bfusb_tx_complete(struct urb *urb, struct pt_regs *regs);
+static void bfusb_rx_complete(struct urb *urb, struct pt_regs *regs);
+
+static struct urb *bfusb_get_completed(struct bfusb *bfusb)
+{
+	struct sk_buff *skb;
+	struct urb *urb = NULL;
+
+	BT_DBG("bfusb %p", bfusb);
+
+	skb = skb_dequeue(&bfusb->completed_q);
+	if (skb) {
+		urb = ((struct bfusb_scb *) skb->cb)->urb;
+		kfree_skb(skb);
+	}
+
+	return urb;
+}
+
+static inline void bfusb_unlink_urbs(struct bfusb *bfusb)
+{
+	struct sk_buff *skb;
+	struct urb *urb;
+
+	BT_DBG("bfusb %p", bfusb);
+
+	while ((skb = skb_dequeue(&bfusb->pending_q))) {
+		urb = ((struct bfusb_scb *) skb->cb)->urb;
+		usb_unlink_urb(urb);
+		skb_queue_tail(&bfusb->completed_q, skb);
+	}
+
+	while ((urb = bfusb_get_completed(bfusb)))
+		usb_free_urb(urb);
+}
+
+
+static int bfusb_send_bulk(struct bfusb *bfusb, struct sk_buff *skb)
+{
+	struct bfusb_scb *scb = (void *) skb->cb;
+	struct urb *urb = bfusb_get_completed(bfusb);
+	int err, pipe;
+
+	BT_DBG("bfusb %p skb %p len %d", bfusb, skb, skb->len);
+
+	if (!urb && !(urb = usb_alloc_urb(0, GFP_ATOMIC)))
+		return -ENOMEM;
+
+	pipe = usb_sndbulkpipe(bfusb->udev, bfusb->bulk_out_ep);
+
+	usb_fill_bulk_urb(urb, bfusb->udev, pipe, skb->data, skb->len,
+			bfusb_tx_complete, skb);
+
+	scb->urb = urb;
+
+	skb_queue_tail(&bfusb->pending_q, skb);
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		BT_ERR("%s bulk tx submit failed urb %p err %d", 
+					bfusb->hdev.name, urb, err);
+		skb_unlink(skb);
+		usb_free_urb(urb);
+	} else
+		atomic_inc(&bfusb->pending_tx);
+
+	return err;
+}
+
+static void bfusb_tx_wakeup(struct bfusb *bfusb)
+{
+	struct sk_buff *skb;
+
+	BT_DBG("bfusb %p", bfusb);
+
+	if (test_and_set_bit(BFUSB_TX_PROCESS, &bfusb->state)) {
+		set_bit(BFUSB_TX_WAKEUP, &bfusb->state);
+		return;
+	}
+
+	do {
+		clear_bit(BFUSB_TX_WAKEUP, &bfusb->state);
+
+		while ((atomic_read(&bfusb->pending_tx) < BFUSB_MAX_BULK_TX) &&
+				(skb = skb_dequeue(&bfusb->transmit_q))) {
+			if (bfusb_send_bulk(bfusb, skb) < 0) {
+				skb_queue_head(&bfusb->transmit_q, skb);
+				break;
+			}
+		}
+
+	} while (test_bit(BFUSB_TX_WAKEUP, &bfusb->state));
+
+	clear_bit(BFUSB_TX_PROCESS, &bfusb->state);
+}
+
+static void bfusb_tx_complete(struct urb *urb, struct pt_regs *regs)
+{
+	struct sk_buff *skb = (struct sk_buff *) urb->context;
+	struct bfusb *bfusb = (struct bfusb *) skb->dev;
+
+	BT_DBG("bfusb %p urb %p skb %p len %d", bfusb, urb, skb, skb->len);
+
+	atomic_dec(&bfusb->pending_tx);
+
+	if (!test_bit(HCI_RUNNING, &bfusb->hdev.flags))
+		return;
+
+	if (!urb->status)
+		bfusb->hdev.stat.byte_tx += skb->len;
+	else
+		bfusb->hdev.stat.err_tx++;
+
+	read_lock(&bfusb->lock);
+
+	skb_unlink(skb);
+	skb_queue_tail(&bfusb->completed_q, skb);
+
+	bfusb_tx_wakeup(bfusb);
+
+	read_unlock(&bfusb->lock);
+}
+
+
+static int bfusb_rx_submit(struct bfusb *bfusb, struct urb *urb)
+{
+	struct bfusb_scb *scb;
+	struct sk_buff *skb;
+	int err, pipe, size = HCI_MAX_FRAME_SIZE + 32;
+
+	BT_DBG("bfusb %p urb %p", bfusb, urb);
+
+	if (!urb && !(urb = usb_alloc_urb(0, GFP_ATOMIC)))
+		return -ENOMEM;
+
+	if (!(skb = bt_skb_alloc(size, GFP_ATOMIC))) {
+		usb_free_urb(urb);
+		return -ENOMEM;
+	}
+
+	skb->dev = (void *) bfusb;
+
+	scb = (struct bfusb_scb *) skb->cb;
+	scb->urb = urb;
+
+	pipe = usb_rcvbulkpipe(bfusb->udev, bfusb->bulk_in_ep);
+
+	usb_fill_bulk_urb(urb, bfusb->udev, pipe, skb->data, size,
+			bfusb_rx_complete, skb);
+
+	skb_queue_tail(&bfusb->pending_q, skb);
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		BT_ERR("%s bulk rx submit failed urb %p err %d",
+					bfusb->hdev.name, urb, err);
+		skb_unlink(skb);
+		kfree_skb(skb);
+		usb_free_urb(urb);
+	}
+
+	return err;
+}
+
+static inline int bfusb_recv_block(struct bfusb *bfusb, int hdr, unsigned char *data, int len)
+{
+	BT_DBG("bfusb %p hdr 0x%02x data %p len %d", bfusb, hdr, data, len);
+
+	if (hdr & 0x10) {
+		BT_ERR("%s error in block", bfusb->hdev.name);
+		if (bfusb->reassembly)
+			kfree_skb(bfusb->reassembly);
+		bfusb->reassembly = NULL;
+		return -EIO;
+	}
+
+	if (hdr & 0x04) {
+		struct sk_buff *skb;
+		unsigned char pkt_type;
+		int pkt_len = 0;
+
+		if (bfusb->reassembly) {
+			BT_ERR("%s unexpected start block", bfusb->hdev.name);
+			kfree_skb(bfusb->reassembly);
+			bfusb->reassembly = NULL;
+		}
+
+		if (len < 1) {
+			BT_ERR("%s no packet type found", bfusb->hdev.name);
+			return -EPROTO;
+		}
+
+		pkt_type = *data++; len--;
+
+		switch (pkt_type) {
+		case HCI_EVENT_PKT:
+			if (len >= HCI_EVENT_HDR_SIZE) {
+				struct hci_event_hdr *hdr = (struct hci_event_hdr *) data;
+				pkt_len = HCI_EVENT_HDR_SIZE + hdr->plen;
+			} else {
+				BT_ERR("%s event block is too short", bfusb->hdev.name);
+				return -EILSEQ;
+			}
+			break;
+
+		case HCI_ACLDATA_PKT:
+			if (len >= HCI_ACL_HDR_SIZE) {
+				struct hci_acl_hdr *hdr = (struct hci_acl_hdr *) data;
+				pkt_len = HCI_ACL_HDR_SIZE + __le16_to_cpu(hdr->dlen);
+			} else {
+				BT_ERR("%s data block is too short", bfusb->hdev.name);
+				return -EILSEQ;
+			}
+			break;
+
+		case HCI_SCODATA_PKT:
+			if (len >= HCI_SCO_HDR_SIZE) {
+				struct hci_sco_hdr *hdr = (struct hci_sco_hdr *) data;
+				pkt_len = HCI_SCO_HDR_SIZE + hdr->dlen;
+			} else {
+				BT_ERR("%s audio block is too short", bfusb->hdev.name);
+				return -EILSEQ;
+			}
+			break;
+		}
+
+		skb = bt_skb_alloc(pkt_len, GFP_ATOMIC);
+		if (!skb) {
+			BT_ERR("%s no memory for the packet", bfusb->hdev.name);
+			return -ENOMEM;
+		}
+
+		skb->dev = (void *) &bfusb->hdev;
+		skb->pkt_type = pkt_type;
+
+		bfusb->reassembly = skb;
+	} else {
+		if (!bfusb->reassembly) {
+			BT_ERR("%s unexpected continuation block", bfusb->hdev.name);
+			return -EIO;
+		}
+	}
+
+	if (len > 0)
+		memcpy(skb_put(bfusb->reassembly, len), data, len);
+
+	if (hdr & 0x08) {
+		hci_recv_frame(bfusb->reassembly);
+		bfusb->reassembly = NULL;
+	}
+
+	return 0;
+}
+
+static void bfusb_rx_complete(struct urb *urb, struct pt_regs *regs)
+{
+	struct sk_buff *skb = (struct sk_buff *) urb->context;
+	struct bfusb *bfusb = (struct bfusb *) skb->dev;
+	unsigned char *buf = urb->transfer_buffer;
+	int count = urb->actual_length;
+	int err, hdr, len;
+
+	BT_DBG("bfusb %p urb %p skb %p len %d", bfusb, urb, skb, skb->len);
+
+	if (!test_bit(HCI_RUNNING, &bfusb->hdev.flags))
+		return;
+
+	read_lock(&bfusb->lock);
+
+	if (urb->status || !count)
+		goto resubmit;
+
+	bfusb->hdev.stat.byte_rx += count;
+
+	skb_put(skb, count);
+
+	while (count) {
+		hdr = buf[0] | (buf[1] << 8);
+
+		if (hdr & 0x4000) {
+			len = 0;
+			count -= 2;
+			buf   += 2;
+		} else {
+			len = (buf[2] == 0) ? 256 : buf[2];
+			count -= 3;
+			buf   += 3;
+		}
+
+		if (count < len) {
+			BT_ERR("%s block extends over URB buffer ranges",
+					bfusb->hdev.name);
+		}
+
+		if ((hdr & 0xe1) == 0xc1)
+			bfusb_recv_block(bfusb, hdr, buf, len);
+
+		count -= len;
+		buf   += len;
+	}
+
+	skb_unlink(skb);
+	kfree_skb(skb);
+
+	bfusb_rx_submit(bfusb, urb);
+
+	read_unlock(&bfusb->lock);
+
+	return;
+
+resubmit:
+	urb->dev = bfusb->udev;
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		BT_ERR("%s bulk resubmit failed urb %p err %d",
+					bfusb->hdev.name, urb, err);
+	}
+
+	read_unlock(&bfusb->lock);
+}
+
+
+static int bfusb_open(struct hci_dev *hdev)
+{
+	struct bfusb *bfusb = (struct bfusb *) hdev->driver_data;
+	unsigned long flags;
+	int i, err;
+
+	BT_DBG("hdev %p bfusb %p", hdev, bfusb);
+
+	if (test_and_set_bit(HCI_RUNNING, &hdev->flags))
+		return 0;
+
+	write_lock_irqsave(&bfusb->lock, flags);
+
+	err = bfusb_rx_submit(bfusb, NULL);
+	if (!err) {
+		for (i = 1; i < BFUSB_MAX_BULK_RX; i++)
+			bfusb_rx_submit(bfusb, NULL);
+	} else {
+		clear_bit(HCI_RUNNING, &hdev->flags);
+	}
+
+	write_unlock_irqrestore(&bfusb->lock, flags);
+
+	return err;
+}
+
+static int bfusb_flush(struct hci_dev *hdev)
+{
+	struct bfusb *bfusb = (struct bfusb *) hdev->driver_data;
+
+	BT_DBG("hdev %p bfusb %p", hdev, bfusb);
+
+	skb_queue_purge(&bfusb->transmit_q);
+
+	return 0;
+}
+
+static int bfusb_close(struct hci_dev *hdev)
+{
+	struct bfusb *bfusb = (struct bfusb *) hdev->driver_data;
+	unsigned long flags;
+
+	BT_DBG("hdev %p bfusb %p", hdev, bfusb);
+
+	if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))
+		return 0;
+
+	write_lock_irqsave(&bfusb->lock, flags);
+	write_unlock_irqrestore(&bfusb->lock, flags);
+
+	bfusb_unlink_urbs(bfusb);
+	bfusb_flush(hdev);
+
+	return 0;
+}
+
+static int bfusb_send_frame(struct sk_buff *skb)
+{
+	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+	struct bfusb *bfusb;
+	struct sk_buff *nskb;
+	unsigned char buf[3];
+	int sent = 0, size, count;
+
+	BT_DBG("hdev %p skb %p type %d len %d", hdev, skb, skb->pkt_type, skb->len);
+
+	if (!hdev) {
+		BT_ERR("Frame for unknown HCI device (hdev=NULL)");
+		return -ENODEV;
+	}
+
+	if (!test_bit(HCI_RUNNING, &hdev->flags))
+		return -EBUSY;
+
+	bfusb = (struct bfusb *) hdev->driver_data;
+
+	switch (skb->pkt_type) {
+	case HCI_COMMAND_PKT:
+		hdev->stat.cmd_tx++;
+		break;
+	case HCI_ACLDATA_PKT:
+		hdev->stat.acl_tx++;
+		break;
+	case HCI_SCODATA_PKT:
+		hdev->stat.sco_tx++;
+		break;
+	};
+
+	/* Prepend skb with frame type */
+	memcpy(skb_push(skb, 1), &(skb->pkt_type), 1);
+
+	count = skb->len;
+
+	/* Max HCI frame size seems to be 1511 + 1 */
+	if (!(nskb = bt_skb_alloc(count + 32, GFP_ATOMIC))) {
+		BT_ERR("Can't allocate memory for new packet");
+		return -ENOMEM;
+	}
+
+	nskb->dev = (void *) bfusb;
+
+	while (count) {
+		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);
+
+		buf[0] = 0xc1 | ((sent == 0) ? 0x04 : 0) | ((count == size) ? 0x08 : 0);
+		buf[1] = 0x00;
+		buf[2] = (size == BFUSB_MAX_BLOCK_SIZE) ? 0 : size;
+
+		memcpy(skb_put(nskb, 3), buf, 3);
+		memcpy(skb_put(nskb, size), skb->data + sent, size);
+
+		sent  += size;
+		count -= size;
+	}
+
+	/* Don't send frame with multiple size of bulk max packet */
+	if ((nskb->len % bfusb->bulk_pkt_size) == 0) {
+		buf[0] = 0xdd;
+		buf[1] = 0x00;
+		memcpy(skb_put(nskb, 2), buf, 2);
+	}
+
+	read_lock(&bfusb->lock);
+
+	skb_queue_tail(&bfusb->transmit_q, nskb);
+	bfusb_tx_wakeup(bfusb);
+
+	read_unlock(&bfusb->lock);
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static void bfusb_destruct(struct hci_dev *hdev)
+{
+	struct bfusb *bfusb = (struct bfusb *) hdev->driver_data;
+
+	BT_DBG("hdev %p bfusb %p", hdev, bfusb);
+
+	kfree(bfusb);
+}
+
+static int bfusb_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
+{
+	return -ENOIOCTLCMD;
+}
+
+
+static int bfusb_load_firmware(struct bfusb *bfusb, unsigned char *firmware, int count)
+{
+	unsigned char *buf;
+	int err, pipe, len, size, sent = 0;
+
+	BT_DBG("bfusb %p udev %p", bfusb, bfusb->udev);
+
+	BT_INFO("BlueFRITZ! USB loading firmware");
+
+	pipe = usb_sndctrlpipe(bfusb->udev, 0);
+
+	if (usb_control_msg(bfusb->udev, pipe, USB_REQ_SET_CONFIGURATION,
+				0, 1, 0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT) < 0) {
+		BT_ERR("Can't change to loading configuration");
+		return -EBUSY;
+	}
+
+	buf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_ATOMIC);
+	if (!buf) {
+		BT_ERR("Can't allocate memory chunk for firmware");
+		return -ENOMEM;
+	}
+
+	pipe = usb_sndbulkpipe(bfusb->udev, bfusb->bulk_out_ep);
+
+	while (count) {
+		size = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);
+
+		memcpy(buf, firmware + sent, size);
+
+		err = usb_bulk_msg(bfusb->udev, pipe, buf, size,
+					&len, BFUSB_BLOCK_TIMEOUT);
+
+		if (err || (len != size)) {
+			BT_ERR("Error in firmware loading");
+			goto error;
+		}
+
+		sent  += size;
+		count -= size;
+	}
+
+	if ((err = usb_bulk_msg(bfusb->udev, pipe, NULL, 0,
+				&len, BFUSB_BLOCK_TIMEOUT)) < 0) {
+		BT_ERR("Error in null packet request");
+		goto error;
+	}
+
+	pipe = usb_sndctrlpipe(bfusb->udev, 0);
+
+        if ((err = usb_control_msg(bfusb->udev, pipe, USB_REQ_SET_CONFIGURATION,
+				0, 2, 0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT)) < 0) {
+		BT_ERR("Can't change to running configuration");
+		goto error;
+	}
+
+	BT_INFO("BlueFRITZ! USB device ready");
+
+	kfree(buf);
+	return 0;
+
+error:
+	kfree(buf);
+
+	pipe = usb_sndctrlpipe(bfusb->udev, 0);
+
+	usb_control_msg(bfusb->udev, pipe, USB_REQ_SET_CONFIGURATION,
+				0, 0, 0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+
+	return err;
+}
+
+static int bfusb_probe(struct usb_interface *iface, const struct usb_device_id *id)
+{
+	const struct firmware *firmware;
+	struct usb_device *udev = interface_to_usbdev(iface);
+	struct usb_host_endpoint *bulk_out_ep;
+	struct usb_host_endpoint *bulk_in_ep;
+	struct hci_dev *hdev;
+	struct bfusb *bfusb;
+
+	BT_DBG("iface %p id %p", iface, id);
+
+	/* Check number of endpoints */
+	if (iface->altsetting[0].desc.bNumEndpoints < 2)
+		return -EIO;
+
+	bulk_out_ep = &iface->altsetting[0].endpoint[0];
+	bulk_in_ep  = &iface->altsetting[0].endpoint[1];
+
+	if (!bulk_out_ep || !bulk_in_ep) {
+		BT_ERR("Bulk endpoints not found");
+		goto done;
+	}
+
+	/* Initialize control structure and load firmware */
+	if (!(bfusb = kmalloc(sizeof(struct bfusb), GFP_KERNEL))) {
+		BT_ERR("Can't allocate memory for control structure");
+		goto done;
+	}
+
+	memset(bfusb, 0, sizeof(struct bfusb));
+
+	bfusb->udev = udev;
+	bfusb->bulk_in_ep    = bulk_in_ep->desc.bEndpointAddress;
+	bfusb->bulk_out_ep   = bulk_out_ep->desc.bEndpointAddress;
+	bfusb->bulk_pkt_size = bulk_out_ep->desc.wMaxPacketSize;
+
+	bfusb->lock = RW_LOCK_UNLOCKED;
+
+	bfusb->reassembly = NULL;
+
+	skb_queue_head_init(&bfusb->transmit_q);
+	skb_queue_head_init(&bfusb->pending_q);
+	skb_queue_head_init(&bfusb->completed_q);
+
+	if (request_firmware(&firmware, "bfubase.frm", &udev->dev) < 0) {
+		BT_ERR("Firmware request failed");
+		goto error;
+	}
+
+	BT_DBG("firmware data %p size %d", firmware->data, firmware->size);
+
+	if (bfusb_load_firmware(bfusb, firmware->data, firmware->size) < 0) {
+		BT_ERR("Firmware loading failed");
+		goto release;
+	}
+
+	release_firmware(firmware);
+
+	/* Initialize and register HCI device */
+	hdev = &bfusb->hdev;
+
+	hdev->type = HCI_USB;
+	hdev->driver_data = bfusb;
+
+	hdev->open     = bfusb_open;
+	hdev->close    = bfusb_close;
+	hdev->flush    = bfusb_flush;
+	hdev->send     = bfusb_send_frame;
+	hdev->destruct = bfusb_destruct;
+	hdev->ioctl    = bfusb_ioctl;
+
+	hdev->owner = THIS_MODULE;
+
+	if (hci_register_dev(hdev) < 0) {
+		BT_ERR("Can't register HCI device");
+		goto error;
+	}
+
+	usb_set_intfdata(iface, bfusb);
+
+	return 0;
+
+release:
+	release_firmware(firmware);
+
+error:
+	kfree(bfusb);
+
+done:
+	return -EIO;
+}
+
+static void bfusb_disconnect(struct usb_interface *iface)
+{
+	struct bfusb *bfusb = usb_get_intfdata(iface);
+	struct hci_dev *hdev = &bfusb->hdev;
+
+	BT_DBG("iface %p", iface);
+
+	if (!hdev)
+		return;
+
+	usb_set_intfdata(iface, NULL);
+
+	bfusb_close(hdev);
+
+	if (hci_unregister_dev(hdev) < 0)
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
+}
+
+static struct usb_driver bfusb_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "bfusb",
+	.probe		= bfusb_probe,
+	.disconnect	= bfusb_disconnect,
+	.id_table	= bfusb_table,
+};
+
+static int __init bfusb_init(void)
+{
+	int err;
+
+	BT_INFO("BlueFRITZ! USB driver ver %s", VERSION);
+
+	if ((err = usb_register(&bfusb_driver)) < 0)
+		BT_ERR("Failed to register BlueFRITZ! USB driver");
+
+	return err;
+}
+
+static void __exit bfusb_cleanup(void)
+{
+	usb_deregister(&bfusb_driver);
+}
+
+module_init(bfusb_init);
+module_exit(bfusb_cleanup);
+
+MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
+MODULE_DESCRIPTION("BlueFRITZ! USB driver ver " VERSION);
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/bluetooth/bluecard_cs.c linux-2.5/drivers/bluetooth/bluecard_cs.c
--- linux-2.6.1/drivers/bluetooth/bluecard_cs.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/drivers/bluetooth/bluecard_cs.c	2004-01-01 16:24:58.000000000 +0000
@@ -499,7 +499,7 @@ static void bluecard_receive(bluecard_in
 }
 
 
-void bluecard_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
+static irqreturn_t bluecard_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
 {
 	bluecard_info_t *info = dev_inst;
 	unsigned int iobase;
@@ -507,11 +507,11 @@ void bluecard_interrupt(int irq, void *d
 
 	if (!info) {
 		printk(KERN_WARNING "bluecard_cs: Call of irq %d for unknown device.\n", irq);
-		return;
+		return IRQ_NONE;
 	}
 
 	if (!test_bit(CARD_READY, &(info->hw_state)))
-		return;
+		return IRQ_NONE;
 
 	iobase = info->link.io.BasePort1;
 
@@ -556,6 +556,8 @@ void bluecard_interrupt(int irq, void *d
 	outb(info->ctrl_reg, iobase + REG_CONTROL);
 
 	spin_unlock(&(info->lock));
+
+	return IRQ_HANDLED;
 }
 
 
diff -purN linux-2.6.1/drivers/bluetooth/bt3c_cs.c linux-2.5/drivers/bluetooth/bt3c_cs.c
--- linux-2.6.1/drivers/bluetooth/bt3c_cs.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/drivers/bluetooth/bt3c_cs.c	2004-01-01 16:25:02.000000000 +0000
@@ -355,7 +355,7 @@ static void bt3c_receive(bt3c_info_t *in
 }
 
 
-void bt3c_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
+static irqreturn_t bt3c_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
 {
 	bt3c_info_t *info = dev_inst;
 	unsigned int iobase;
@@ -363,7 +363,7 @@ void bt3c_interrupt(int irq, void *dev_i
 
 	if (!info) {
 		printk(KERN_WARNING "bt3c_cs: Call of irq %d for unknown device.\n", irq);
-		return;
+		return IRQ_NONE;
 	}
 
 	iobase = info->link.io.BasePort1;
@@ -396,6 +396,8 @@ void bt3c_interrupt(int irq, void *dev_i
 	}
 
 	spin_unlock(&(info->lock));
+
+	return IRQ_HANDLED;
 }
 
 
diff -purN linux-2.6.1/drivers/bluetooth/btuart_cs.c linux-2.5/drivers/bluetooth/btuart_cs.c
--- linux-2.6.1/drivers/bluetooth/btuart_cs.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/drivers/bluetooth/btuart_cs.c	2004-01-01 16:25:04.000000000 +0000
@@ -301,7 +301,7 @@ static void btuart_receive(btuart_info_t
 }
 
 
-void btuart_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
+static irqreturn_t btuart_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
 {
 	btuart_info_t *info = dev_inst;
 	unsigned int iobase;
@@ -310,7 +310,7 @@ void btuart_interrupt(int irq, void *dev
 
 	if (!info) {
 		printk(KERN_WARNING "btuart_cs: Call of irq %d for unknown device.\n", irq);
-		return;
+		return IRQ_NONE;
 	}
 
 	iobase = info->link.io.BasePort1;
@@ -351,6 +351,8 @@ void btuart_interrupt(int irq, void *dev
 	}
 
 	spin_unlock(&(info->lock));
+
+	return IRQ_HANDLED;
 }
 
 
diff -purN linux-2.6.1/drivers/bluetooth/dtl1_cs.c linux-2.5/drivers/bluetooth/dtl1_cs.c
--- linux-2.6.1/drivers/bluetooth/dtl1_cs.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/bluetooth/dtl1_cs.c	2004-01-01 16:24:13.000000000 +0000
@@ -304,7 +304,7 @@ static void dtl1_receive(dtl1_info_t *in
 }
 
 
-void dtl1_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
+static irqreturn_t dtl1_interrupt(int irq, void *dev_inst, struct pt_regs *regs)
 {
 	dtl1_info_t *info = dev_inst;
 	unsigned int iobase;
@@ -314,7 +314,7 @@ void dtl1_interrupt(int irq, void *dev_i
 
 	if (!info) {
 		printk(KERN_WARNING "dtl1_cs: Call of irq %d for unknown device.\n", irq);
-		return;
+		return IRQ_NONE;
 	}
 
 	iobase = info->link.io.BasePort1;
@@ -363,6 +363,8 @@ void dtl1_interrupt(int irq, void *dev_i
 	}
 
 	spin_unlock(&(info->lock));
+
+	return IRQ_HANDLED;
 }
 
 
diff -purN linux-2.6.1/drivers/bluetooth/hci_usb.c linux-2.5/drivers/bluetooth/hci_usb.c
--- linux-2.6.1/drivers/bluetooth/hci_usb.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/drivers/bluetooth/hci_usb.c	2003-12-27 18:49:56.000000000 +0000
@@ -62,7 +62,7 @@
 #define BT_DMP( A... )
 #endif
 
-#ifndef CONFIG_BT_USB_ZERO_PACKET
+#ifndef CONFIG_BT_HCIUSB_ZERO_PACKET
 #undef  URB_ZERO_PACKET
 #define URB_ZERO_PACKET 0
 #endif
@@ -70,12 +70,21 @@
 static struct usb_driver hci_usb_driver; 
 
 static struct usb_device_id bluetooth_ids[] = {
+	/* Broadcom BCM2033 without firmware */
+	{ USB_DEVICE(0x0a5c, 0x2033), driver_info: HCI_IGNORE },
+
+	/* Digianswer device */
+	{ USB_DEVICE(0x08fd, 0x0001), driver_info: HCI_DIGIANSWER },
+
 	/* Generic Bluetooth USB device */
 	{ USB_DEVICE_INFO(HCI_DEV_CLASS, HCI_DEV_SUBCLASS, HCI_DEV_PROTOCOL) },
 
 	/* Ericsson with non-standard id */
 	{ USB_DEVICE(0x0bdb, 0x1002) },
 
+	/* ALPS Module with non-standard id */
+	{ USB_DEVICE(0x044e, 0x3002) },
+
 	/* Bluetooth Ultraport Module from IBM */
 	{ USB_DEVICE(0x04bf, 0x030a) },
 
@@ -84,13 +93,6 @@ static struct usb_device_id bluetooth_id
 
 MODULE_DEVICE_TABLE (usb, bluetooth_ids);
 
-static struct usb_device_id ignore_ids[] = {
-	/* Broadcom BCM2033 without firmware */
-	{ USB_DEVICE(0x0a5c, 0x2033) },
-
-	{ }	/* Terminating entry */
-};
-
 struct _urb *_urb_alloc(int isoc, int gfp)
 {
 	struct _urb *_urb = kmalloc(sizeof(struct _urb) +
@@ -134,7 +136,7 @@ static inline struct _urb *__get_complet
 	return _urb_dequeue(__completed_q(husb, type)); 
 }
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 static void __fill_isoc_desc(struct urb *urb, int len, int mtu)
 {
 	int offset = 0, i;
@@ -232,7 +234,7 @@ static int hci_usb_bulk_rx_submit(struct
 	return err;
 }
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 static int hci_usb_isoc_rx_submit(struct hci_usb *husb)
 {
 	struct _urb *_urb;
@@ -301,9 +303,10 @@ static int hci_usb_open(struct hci_dev *
 		for (i = 0; i < HCI_MAX_BULK_RX; i++)
 			hci_usb_bulk_rx_submit(husb);
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 		if (husb->isoc_iface)
-			hci_usb_isoc_rx_submit(husb);
+			for (i = 0; i < HCI_MAX_ISOC_RX; i++)
+				hci_usb_isoc_rx_submit(husb);
 #endif
 	} else {
 		clear_bit(HCI_RUNNING, &hdev->flags);
@@ -425,7 +428,7 @@ static inline int hci_usb_send_ctrl(stru
 	} else
 		dr = (void *) _urb->urb.setup_packet;
 
-	dr->bRequestType = HCI_CTRL_REQ;
+	dr->bRequestType = husb->ctrl_req;
 	dr->bRequest = 0;
 	dr->wIndex   = 0;
 	dr->wValue   = 0;
@@ -466,7 +469,7 @@ static inline int hci_usb_send_bulk(stru
 	return __tx_submit(husb, _urb);
 }
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 static inline int hci_usb_send_isoc(struct hci_usb *husb, struct sk_buff *skb)
 {
 	struct _urb *_urb = __get_completed(husb, skb->pkt_type);
@@ -517,10 +520,10 @@ static void hci_usb_tx_process(struct hc
 				skb_queue_head(q, skb);
 		}
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 		/* Process SCO queue */
 		q = __transmit_q(husb, HCI_SCODATA_PKT);
-		if (!atomic_read(__pending_tx(husb, HCI_SCODATA_PKT)) &&
+		if (atomic_read(__pending_tx(husb, HCI_SCODATA_PKT)) < HCI_MAX_ISOC_TX &&
 				(skb = skb_dequeue(q))) {
 			if (hci_usb_send_isoc(husb, skb) < 0)
 				skb_queue_head(q, skb);
@@ -576,7 +579,7 @@ static int hci_usb_send_frame(struct sk_
 		hdev->stat.acl_tx++;
 		break;
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 	case HCI_SCODATA_PKT:
 		hdev->stat.sco_tx++;
 		break;
@@ -626,7 +629,7 @@ static inline int __recv_frame(struct hc
 				} else
 					return -EILSEQ;
 				break;
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 			case HCI_SCODATA_PKT:
 				if (count >= HCI_SCO_HDR_SIZE) {
 					struct hci_sco_hdr *h = data;
@@ -691,7 +694,7 @@ static void hci_usb_rx_complete(struct u
 		goto resubmit;
 
 	if (_urb->type == HCI_SCODATA_PKT) {
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 		int i;
 		for (i=0; i < urb->number_of_packets; i++) {
 			BT_DBG("desc %d status %d offset %d len %d", i,
@@ -785,9 +788,11 @@ int hci_usb_probe(struct usb_interface *
 
 	iface = udev->actconfig->interface[0];
 
-	/* Check our black list */
-	if (usb_match_id(intf, ignore_ids))
-		return -EIO;
+	if (id->driver_info & HCI_IGNORE)
+		return -ENODEV;
+
+	if (intf->altsetting->desc.bInterfaceNumber > 0)
+		return -ENODEV;
 
 	/* Check number of endpoints */
 	if (intf->altsetting[0].desc.bNumEndpoints < 3)
@@ -826,9 +831,9 @@ int hci_usb_probe(struct usb_interface *
 						bulk_out_ep[i] = ep;
 					break;
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 				case USB_ENDPOINT_XFER_ISOC:
-					if (ep->desc.wMaxPacketSize < size)
+					if (ep->desc.wMaxPacketSize < size || a > 2)
 						break;
 					size = ep->desc.wMaxPacketSize;
 
@@ -852,7 +857,7 @@ int hci_usb_probe(struct usb_interface *
 		goto done;
 	}
 
-#ifdef CONFIG_BT_USB_SCO
+#ifdef CONFIG_BT_HCIUSB_SCO
 	if (!isoc_in_ep[1] || !isoc_out_ep[1]) {
 		BT_DBG("Isoc endpoints not found");
 		isoc_iface = NULL;
@@ -871,7 +876,12 @@ int hci_usb_probe(struct usb_interface *
 	husb->bulk_in_ep  = bulk_in_ep[0];
 	husb->intr_in_ep  = intr_in_ep[0];
 
-#ifdef CONFIG_BT_USB_SCO
+	if (id->driver_info & HCI_DIGIANSWER)
+		husb->ctrl_req = HCI_DIGI_REQ;
+	else
+		husb->ctrl_req = HCI_CTRL_REQ;
+
+#ifdef CONFIG_BT_HCIUSB_SCO
 	if (isoc_iface) {
 		BT_DBG("isoc ifnum %d alts %d", isoc_ifnum, isoc_alts);
 		if (usb_set_interface(udev, isoc_ifnum, isoc_alts)) {
diff -purN linux-2.6.1/drivers/bluetooth/hci_usb.h linux-2.5/drivers/bluetooth/hci_usb.h
--- linux-2.6.1/drivers/bluetooth/hci_usb.h	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/bluetooth/hci_usb.h	2003-12-27 18:46:21.000000000 +0000
@@ -35,12 +35,19 @@
 #define HCI_DEV_PROTOCOL     0x01	/* Bluetooth programming protocol */
 
 #define HCI_CTRL_REQ	     0x20
+#define HCI_DIGI_REQ	     0x40
+
+#define HCI_IGNORE           0x01
+#define HCI_DIGIANSWER       0x02
 
 #define HCI_MAX_IFACE_NUM	3 
 
 #define HCI_MAX_BULK_TX     	4
 #define HCI_MAX_BULK_RX     	1
 
+#define HCI_MAX_ISOC_RX		2
+#define HCI_MAX_ISOC_TX		2
+
 #define HCI_MAX_ISOC_FRAMES     10
 
 struct _urb_queue {
@@ -119,6 +126,8 @@ struct hci_usb {
 	struct usb_host_endpoint	*isoc_out_ep;
 	struct usb_host_endpoint	*isoc_in_ep;
 
+	__u8			ctrl_req;
+
 	struct sk_buff_head	transmit_q[4];
 	struct sk_buff		*reassembly[4]; // Reassembly buffers
 
diff -purN linux-2.6.1/drivers/ide/ide-disk.c linux-2.5/drivers/ide/ide-disk.c
--- linux-2.6.1/drivers/ide/ide-disk.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/ide/ide-disk.c	2004-01-16 18:37:58.000000000 +0000
@@ -239,8 +239,6 @@ static ide_startstop_t write_intr (ide_d
  * ide_multwrite() transfers a block of up to mcount sectors of data
  * to a drive as part of a disk multiple-sector write operation.
  *
- * Returns 0 on success.
- *
  * Note that we may be called from two contexts - __ide_do_rw_disk() context
  * and IRQ context. The IRQ can happen any time after we've output the
  * full "mcount" number of sectors, so we must make sure we update the
@@ -251,7 +249,7 @@ static ide_startstop_t write_intr (ide_d
  * is shorter or smaller than the BH segment then we should be OKAY.
  * This is only valid if we can rewind the rq->current_nr_sectors counter.
  */
-int ide_multwrite (ide_drive_t *drive, unsigned int mcount)
+static void ide_multwrite(ide_drive_t *drive, unsigned int mcount)
 {
  	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
  	struct request *rq	= &hwgroup->wrq;
@@ -300,8 +298,6 @@ int ide_multwrite (ide_drive_t *drive, u
 		taskfile_output_data(drive, buffer, nsect<<7);
 		ide_unmap_buffer(rq, buffer, &flags);
 	} while (mcount);
-
-        return 0;
 }
 
 /*
@@ -322,8 +318,7 @@ static ide_startstop_t multwrite_intr (i
 			 *	of the request
 			 */
 			if (rq->nr_sectors) {
-				if (ide_multwrite(drive, drive->mult_count))
-					return ide_stopped;
+				ide_multwrite(drive, drive->mult_count);
 				ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
 				return ide_started;
 			}
@@ -506,27 +501,10 @@ ide_startstop_t __ide_do_rw_disk (ide_dr
 			local_irq_disable();
 		if (drive->mult_count) {
 			ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	/*
-	 * Ugh.. this part looks ugly because we MUST set up
-	 * the interrupt handler before outputting the first block
-	 * of data to be written.  If we hit an error (corrupted buffer list)
-	 * in ide_multwrite(), then we need to remove the handler/timer
-	 * before returning.  Fortunately, this NEVER happens (right?).
-	 *
-	 * Except when you get an error it seems...
-	 *
-	 * MAJOR DATA INTEGRITY BUG !!! only if we error 
-	 */
+
 			hwgroup->wrq = *rq; /* scratchpad */
 			ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
-			if (ide_multwrite(drive, drive->mult_count)) {
-				unsigned long flags;
-				spin_lock_irqsave(&ide_lock, flags);
-				hwgroup->handler = NULL;
-				del_timer(&hwgroup->timer);
-				spin_unlock_irqrestore(&ide_lock, flags);
-				return ide_stopped;
-			}
+			ide_multwrite(drive, drive->mult_count);
 		} else {
 			unsigned long flags;
 			char *to = ide_map_buffer(rq, &flags);
diff -purN linux-2.6.1/drivers/ide/ide-taskfile.c linux-2.5/drivers/ide/ide-taskfile.c
--- linux-2.6.1/drivers/ide/ide-taskfile.c	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/ide/ide-taskfile.c	2004-01-16 18:38:19.000000000 +0000
@@ -2208,28 +2208,3 @@ ide_startstop_t flagged_task_mulout_intr
 
 	return ide_started;
 }
-
-/*
- * Beginning of Taskfile OPCODE Library and feature sets.
- */
-
-#ifdef CONFIG_PKT_TASK_IOCTL
-
-int pkt_taskfile_ioctl (ide_drive_t *drive, unsigned int cmd, unsigned long arg)
-{
-#if 0
-	switch(req_task->data_phase) {
-		case TASKFILE_P_OUT_DMAQ:
-		case TASKFILE_P_IN_DMAQ:
-		case TASKFILE_P_OUT_DMA:
-		case TASKFILE_P_IN_DMA:
-		case TASKFILE_P_OUT:
-		case TASKFILE_P_IN:
-	}
-#endif
-	return -ENOMSG;
-}
-
-EXPORT_SYMBOL(pkt_taskfile_ioctl);
-
-#endif /* CONFIG_PKT_TASK_IOCTL */
diff -purN linux-2.6.1/drivers/ide/ide.c linux-2.5/drivers/ide/ide.c
--- linux-2.6.1/drivers/ide/ide.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/ide/ide.c	2004-01-16 18:38:19.000000000 +0000
@@ -1620,12 +1620,6 @@ int generic_ide_ioctl(struct block_devic
 			switch(drive->media) {
 				case ide_disk:
 					return ide_taskfile_ioctl(drive, cmd, arg);
-#ifdef CONFIG_PKT_TASK_IOCTL
-				case ide_cdrom:
-				case ide_tape:
-				case ide_floppy:
-					return pkt_taskfile_ioctl(drive, cmd, arg);
-#endif /* CONFIG_PKT_TASK_IOCTL */
 				default:
 					return -ENOMSG;
 			}
diff -purN linux-2.6.1/drivers/ieee1394/Kconfig linux-2.5/drivers/ieee1394/Kconfig
--- linux-2.6.1/drivers/ieee1394/Kconfig	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/ieee1394/Kconfig	2004-01-14 23:05:36.000000000 +0000
@@ -40,7 +40,7 @@ config IEEE1394_OUI_DB
 	help
 	  If you say Y here, then an OUI list (vendor unique ID's) will be
 	  compiled into the ieee1394 module. This doesn't really do much
-	  accept being able to display the vendor of a hardware node. The
+	  except being able to display the vendor of a hardware node. The
 	  downside is that it adds about 300k to the size of the module,
 	  or kernel (depending on whether you compile ieee1394 as a
 	  module, or static in the kernel).
diff -purN linux-2.6.1/drivers/ieee1394/amdtp.c linux-2.5/drivers/ieee1394/amdtp.c
--- linux-2.6.1/drivers/ieee1394/amdtp.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/ieee1394/amdtp.c	2004-01-14 23:10:07.000000000 +0000
@@ -82,6 +82,7 @@
 #include <linux/poll.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 
@@ -1196,6 +1197,7 @@ static int amdtp_release(struct inode *i
 	return 0;
 }
 
+static struct cdev amdtp_cdev;
 static struct file_operations amdtp_fops =
 {
 	.owner =	THIS_MODULE,
@@ -1262,12 +1264,11 @@ MODULE_LICENSE("GPL");
 
 static int __init amdtp_init_module (void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_AMDTP,
-					THIS_MODULE, &amdtp_fops);
-	if (ret) {
-		HPSB_ERR("amdtp: unable to get minor device block");
+	cdev_init(&amdtp_cdev, &amdtp_fops);
+	amdtp_cdev.owner = THIS_MODULE;
+	kobject_set_name(&amdtp_cdev.kobj, "amdtp");
+	if (cdev_add(&amdtp_cdev, IEEE1394_AMDTP_DEV, 16)) {
+		HPSB_ERR("amdtp: unable to add char device");
  		return -EIO;
  	}
 
@@ -1276,12 +1277,15 @@ static int __init amdtp_init_module (voi
 	hpsb_register_highlevel(&amdtp_highlevel);
 
 #ifdef CONFIG_COMPAT
-	ret = register_ioctl32_conversion(AMDTP_IOC_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_PLUG, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_PING, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_ZAP, NULL);
-	if (ret)
-		HPSB_ERR("amdtp: Error registering ioctl32 translations");
+	{
+		int ret;
+		ret = register_ioctl32_conversion(AMDTP_IOC_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_PLUG, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_PING, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_ZAP, NULL);
+		if (ret)
+			HPSB_ERR("amdtp: Error registering ioctl32 translations");
+	}
 #endif
 
 	HPSB_INFO("Loaded AMDTP driver");
@@ -1304,10 +1308,12 @@ static void __exit amdtp_exit_module (vo
 
         hpsb_unregister_highlevel(&amdtp_highlevel);
 	devfs_remove("amdtp");
-        ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_AMDTP);
+	cdev_unmap(IEEE1394_AMDTP_DEV, 16);
+	cdev_del(&amdtp_cdev);
 
 	HPSB_INFO("Unloaded AMDTP driver");
 }
 
 module_init(amdtp_init_module);
 module_exit(amdtp_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_AMDTP * 16);
diff -purN linux-2.6.1/drivers/ieee1394/cmp.c linux-2.5/drivers/ieee1394/cmp.c
--- linux-2.6.1/drivers/ieee1394/cmp.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/ieee1394/cmp.c	2004-01-14 23:11:56.000000000 +0000
@@ -77,6 +77,25 @@ enum {
 
 static struct hpsb_highlevel cmp_highlevel;
 
+static void cmp_add_host(struct hpsb_host *host);
+static void cmp_host_reset(struct hpsb_host *host);
+static int pcr_read(struct hpsb_host *host, int nodeid, quadlet_t *buf,
+		    u64 addr, size_t length, u16 flags);
+static int pcr_lock(struct hpsb_host *host, int nodeid, quadlet_t *store,
+		    u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 flags);
+
+static struct hpsb_highlevel cmp_highlevel = {
+	.name =		"cmp",
+	.add_host =	cmp_add_host,
+	.host_reset =	cmp_host_reset,
+};
+
+static struct hpsb_address_ops pcr_ops = {
+	.read =	pcr_read,
+	.lock =	pcr_lock,
+};
+
+
 struct cmp_pcr *
 cmp_register_opcr(struct hpsb_host *host, int opcr_number, int payload,
 		  void (*update)(struct cmp_pcr *pcr, void *data),
@@ -137,6 +156,10 @@ static void cmp_add_host(struct hpsb_hos
 		return;
 	}
 
+	hpsb_register_addrspace(&cmp_highlevel, host, &pcr_ops,
+				CSR_REGISTER_BASE + CSR_PCR_MAP,
+				CSR_REGISTER_BASE + CSR_PCR_MAP_END);
+
 	ch->host = host;
 	ch->u.ompr.rate = IEEE1394_SPEED_100;
 	ch->u.ompr.bcast_channel_base = 63;
@@ -258,17 +281,6 @@ static int pcr_lock(struct hpsb_host *ho
 }
 
 
-static struct hpsb_highlevel cmp_highlevel = {
-	.name =		"cmp",
-	.add_host =	cmp_add_host,
-        .host_reset =	cmp_host_reset,
-};
-
-static struct hpsb_address_ops pcr_ops = {
-	.read =	pcr_read,
-        .lock =	pcr_lock,
-};
-
 /* Module interface */
 
 MODULE_AUTHOR("Kristian Hogsberg <hogsberg@users.sf.net>");
@@ -283,10 +295,6 @@ static int __init cmp_init_module (void)
 {
 	hpsb_register_highlevel (&cmp_highlevel);
 
-	hpsb_register_addrspace(&cmp_highlevel, &pcr_ops,
-				CSR_REGISTER_BASE + CSR_PCR_MAP,
-				CSR_REGISTER_BASE + CSR_PCR_MAP_END);
-
 	HPSB_INFO("Loaded CMP driver");
 
 	return 0;
diff -purN linux-2.6.1/drivers/ieee1394/csr.c linux-2.5/drivers/ieee1394/csr.c
--- linux-2.6.1/drivers/ieee1394/csr.c	2004-01-09 06:59:18.000000000 +0000
+++ linux-2.5/drivers/ieee1394/csr.c	2004-01-14 23:11:58.000000000 +0000
@@ -35,6 +35,43 @@ static int fcp = 1;
 module_param(fcp, int, 0444);
 MODULE_PARM_DESC(fcp, "Map FCP registers (default = 1, disable = 0).");
 
+static void add_host(struct hpsb_host *host);
+static void host_reset(struct hpsb_host *host);
+static int read_maps(struct hpsb_host *host, int nodeid, quadlet_t *buffer,
+		     u64 addr, size_t length, u16 fl);
+static int write_fcp(struct hpsb_host *host, int nodeid, int dest,
+		     quadlet_t *data, u64 addr, size_t length, u16 flags);
+static int read_regs(struct hpsb_host *host, int nodeid, quadlet_t *buf,
+		     u64 addr, size_t length, u16 flags);
+static int write_regs(struct hpsb_host *host, int nodeid, int destid,
+		      quadlet_t *data, u64 addr, size_t length, u16 flags);
+static int lock_regs(struct hpsb_host *host, int nodeid, quadlet_t *store,
+		     u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 fl);
+static int lock64_regs(struct hpsb_host *host, int nodeid, octlet_t * store,
+		       u64 addr, octlet_t data, octlet_t arg, int extcode, u16 fl);
+
+static struct hpsb_highlevel csr_highlevel = {
+	.name =		"standard registers",
+	.add_host =	add_host,
+	.host_reset =	host_reset,
+};
+
+static struct hpsb_address_ops map_ops = {
+	.read = read_maps,
+};
+
+static struct hpsb_address_ops fcp_ops = {
+	.write = write_fcp,
+};
+
+static struct hpsb_address_ops reg_ops = {
+	.read = read_regs,
+	.write = write_regs,
+	.lock = lock_regs,
+	.lock64 = lock64_regs,
+};
+
+
 static u16 csr_crc16(unsigned *data, int length)
 {
         int check=0, i;
@@ -125,6 +162,24 @@ static inline void calculate_expire(stru
 
 static void add_host(struct hpsb_host *host)
 {
+	hpsb_register_addrspace(&csr_highlevel, host, &reg_ops,
+				CSR_REGISTER_BASE,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM);
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM_END);
+	if (fcp) {
+		hpsb_register_addrspace(&csr_highlevel, host, &fcp_ops,
+					CSR_REGISTER_BASE + CSR_FCP_COMMAND,
+					CSR_REGISTER_BASE + CSR_FCP_END);
+	}
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP,
+				CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP_END);
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_SPEED_MAP,
+				CSR_REGISTER_BASE + CSR_SPEED_MAP_END);
+
         host->csr.lock = SPIN_LOCK_UNLOCKED;
 
         host->csr.rom_size = host->driver->get_rom(host, &host->csr.rom);
@@ -684,48 +739,10 @@ static int write_fcp(struct hpsb_host *h
 }
 
 
-static struct hpsb_highlevel csr_highlevel = {
-	.name =		"standard registers",
-	.add_host =	add_host,
-        .host_reset =	host_reset,
-};
-
-
-static struct hpsb_address_ops map_ops = {
-        .read = read_maps,
-};
-
-static struct hpsb_address_ops fcp_ops = {
-        .write = write_fcp,
-};
-
-static struct hpsb_address_ops reg_ops = {
-        .read = read_regs,
-        .write = write_regs,
-        .lock = lock_regs,
-	.lock64 = lock64_regs,
-};
 
 void init_csr(void)
 {
 	hpsb_register_highlevel(&csr_highlevel);
-
-        hpsb_register_addrspace(&csr_highlevel, &reg_ops, CSR_REGISTER_BASE,
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM);
-        hpsb_register_addrspace(&csr_highlevel, &map_ops, 
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM,
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM_END);
-        if (fcp) {
-		hpsb_register_addrspace(&csr_highlevel, &fcp_ops,
-                                CSR_REGISTER_BASE + CSR_FCP_COMMAND,
-                                CSR_REGISTER_BASE + CSR_FCP_END);
-	}
-        hpsb_register_addrspace(&csr_highlevel, &map_ops,
-                                CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP,
-                                CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP_END);
-        hpsb_register_addrspace(&csr_highlevel, &map_ops,
-                                CSR_REGISTER_BASE + CSR_SPEED_MAP,
-                                CSR_REGISTER_BASE + CSR_SPEED_MAP_END);
 }
 
 void cleanup_csr(void)
diff -purN linux-2.6.1/drivers/ieee1394/dv1394.c linux-2.5/drivers/ieee1394/dv1394.c
--- linux-2.6.1/drivers/ieee1394/dv1394.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/ieee1394/dv1394.c	2004-01-14 23:10:12.000000000 +0000
@@ -110,6 +110,7 @@
 #include <linux/string.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 
 #include "ieee1394.h"
 #include "ieee1394_types.h"
@@ -2165,6 +2166,7 @@ out:
 	spin_unlock(&video->spinlock);
 }
 
+static struct cdev dv1394_cdev;
 static struct file_operations dv1394_fops=
 {
 	.owner =	THIS_MODULE,
@@ -2607,17 +2609,17 @@ static void __exit dv1394_exit_module(vo
 	hpsb_unregister_protocol(&dv1394_driver);
 
 	hpsb_unregister_highlevel(&dv1394_highlevel);
-	ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_DV1394);
+	cdev_unmap(IEEE1394_DV1394_DEV, 16);
+	cdev_del(&dv1394_cdev);
 	devfs_remove("ieee1394/dv");
 }
 
 static int __init dv1394_init_module(void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_DV1394,
-					THIS_MODULE, &dv1394_fops);
-	if (ret) {
+	cdev_init(&dv1394_cdev, &dv1394_fops);
+	dv1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&dv1394_cdev.kobj, "dv1394");
+	if (cdev_add(&dv1394_cdev, IEEE1394_DV1394_DEV, 16)) {
 		printk(KERN_ERR "dv1394: unable to register character device\n");
 		return -EIO;
 	}
@@ -2629,18 +2631,22 @@ static int __init dv1394_init_module(voi
 	hpsb_register_protocol(&dv1394_driver);
 
 #ifdef CONFIG_COMPAT
-	/* First compatible ones */
-	ret = register_ioctl32_conversion(DV1394_IOC_SHUTDOWN, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_SUBMIT_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_WAIT_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_RECEIVE_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_START_RECEIVE, NULL);
-
-	/* These need to be handled by translation */
-	ret |= register_ioctl32_conversion(DV1394_IOC32_INIT, handle_dv1394_init);
-	ret |= register_ioctl32_conversion(DV1394_IOC32_GET_STATUS, handle_dv1394_get_status);
-	if (ret)
-		printk(KERN_ERR "dv1394: Error registering ioctl32 translations\n");
+	{
+		int ret;
+
+		/* First compatible ones */
+		ret = register_ioctl32_conversion(DV1394_IOC_SHUTDOWN, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_SUBMIT_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_WAIT_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_RECEIVE_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_START_RECEIVE, NULL);
+
+		/* These need to be handled by translation */
+		ret |= register_ioctl32_conversion(DV1394_IOC32_INIT, handle_dv1394_init);
+		ret |= register_ioctl32_conversion(DV1394_IOC32_GET_STATUS, handle_dv1394_get_status);
+		if (ret)
+			printk(KERN_ERR "dv1394: Error registering ioctl32 translations\n");
+	}
 #endif
 
 	return 0;
@@ -2648,3 +2654,4 @@ static int __init dv1394_init_module(voi
 
 module_init(dv1394_init_module);
 module_exit(dv1394_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_DV1394 * 16);
diff -purN linux-2.6.1/drivers/ieee1394/eth1394.c linux-2.5/drivers/ieee1394/eth1394.c
--- linux-2.6.1/drivers/ieee1394/eth1394.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/ieee1394/eth1394.c	2004-01-14 23:20:23.000000000 +0000
@@ -89,7 +89,7 @@
 #define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 1079 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1096 $ Ben Collins <bcollins@debian.org>";
 
 struct fragment_info {
 	struct list_head list;
@@ -168,6 +168,26 @@ static void ether1394_iso(struct hpsb_is
 static int ether1394_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 static int ether1394_ethtool_ioctl(struct net_device *dev, void *useraddr);
 
+static int ether1394_write(struct hpsb_host *host, int srcid, int destid,
+			   quadlet_t *data, u64 addr, size_t len, u16 flags);
+static void ether1394_add_host (struct hpsb_host *host);
+static void ether1394_remove_host (struct hpsb_host *host);
+static void ether1394_host_reset (struct hpsb_host *host);
+
+/* Function for incoming 1394 packets */
+static struct hpsb_address_ops addr_ops = {
+	.write =	ether1394_write,
+};
+
+/* Ieee1394 highlevel driver functions */
+static struct hpsb_highlevel eth1394_highlevel = {
+	.name =		driver_name,
+	.add_host =	ether1394_add_host,
+	.remove_host =	ether1394_remove_host,
+	.host_reset =	ether1394_host_reset,
+};
+
+
 static void eth1394_iso_shutdown(struct eth1394_priv *priv)
 {
 	priv->bc_state = ETHER1394_BC_CLOSED;
@@ -420,6 +440,10 @@ static void ether1394_add_host (struct h
 	struct eth1394_priv *priv;
 	static int version_printed = 0;
 
+	hpsb_register_addrspace(&eth1394_highlevel, host, &addr_ops,
+				ETHER1394_REGION_ADDR,
+				ETHER1394_REGION_ADDR_END);
+
 	if (version_printed++ == 0)
 		ETH1394_PRINT_G (KERN_INFO, "%s\n", version);
 
@@ -1599,7 +1623,7 @@ static int ether1394_ethtool_ioctl(struc
 		case ETHTOOL_GDRVINFO: {
 			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
 			strcpy (info.driver, driver_name);
-			strcpy (info.version, "$Rev: 1079 $");
+			strcpy (info.version, "$Rev: 1096 $");
 			/* FIXME XXX provide sane businfo */
 			strcpy (info.bus_info, "ieee1394");
 			if (copy_to_user (useraddr, &info, sizeof (info)))
@@ -1619,18 +1643,6 @@ static int ether1394_ethtool_ioctl(struc
 	return 0;
 }
 
-/* Function for incoming 1394 packets */
-static struct hpsb_address_ops addr_ops = {
-	.write =	ether1394_write,
-};
-
-/* Ieee1394 highlevel driver functions */
-static struct hpsb_highlevel eth1394_highlevel = {
-	.name =		driver_name,
-	.add_host =	ether1394_add_host,
-	.remove_host =	ether1394_remove_host,
-	.host_reset =	ether1394_host_reset,
-};
 
 static int __init ether1394_init_module (void)
 {
@@ -1640,9 +1652,6 @@ static int __init ether1394_init_module 
 	/* Register ourselves as a highlevel driver */
 	hpsb_register_highlevel(&eth1394_highlevel);
 
-	hpsb_register_addrspace(&eth1394_highlevel, &addr_ops, ETHER1394_REGION_ADDR,
-				 ETHER1394_REGION_ADDR_END);
-
 	return 0;
 }
 
diff -purN linux-2.6.1/drivers/ieee1394/highlevel.c linux-2.5/drivers/ieee1394/highlevel.c
--- linux-2.6.1/drivers/ieee1394/highlevel.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/ieee1394/highlevel.c	2004-01-14 23:15:08.000000000 +0000
@@ -39,7 +39,10 @@ struct hl_host_info {
 
 
 static LIST_HEAD(hl_drivers);
-static rwlock_t hl_drivers_lock = RW_LOCK_UNLOCKED;
+static DECLARE_RWSEM(hl_drivers_sem);
+
+static LIST_HEAD(hl_irqs);
+static rwlock_t hl_irqs_lock = RW_LOCK_UNLOCKED;
 
 static LIST_HEAD(addr_space);
 static rwlock_t addr_space_lock = RW_LOCK_UNLOCKED;
@@ -239,20 +242,22 @@ static int highlevel_for_each_host_reg(s
 
 void hpsb_register_highlevel(struct hpsb_highlevel *hl)
 {
-	unsigned long flags;
-
         INIT_LIST_HEAD(&hl->addr_list);
 	INIT_LIST_HEAD(&hl->host_info_list);
 
 	rwlock_init(&hl->host_info_lock);
 
-	write_lock_irqsave(&hl_drivers_lock, flags);
+	down_write(&hl_drivers_sem);
         list_add_tail(&hl->hl_list, &hl_drivers);
-	write_unlock_irqrestore(&hl_drivers_lock, flags);
+	up_write(&hl_drivers_sem);
 
 	if (hl->add_host)
 		nodemgr_for_each_host(hl, highlevel_for_each_host_reg);
 
+	write_lock(&hl_irqs_lock);
+	list_add_tail(&hl->irq_list, &hl_irqs);
+	write_unlock(&hl_irqs_lock);
+
         return;
 }
 
@@ -280,15 +285,19 @@ void hpsb_unregister_highlevel(struct hp
         }
 	write_unlock_irqrestore(&addr_space_lock, flags);
 
-	write_lock_irqsave(&hl_drivers_lock, flags);
+	write_lock(&hl_irqs_lock);
+	list_del(&hl->irq_list);
+	write_unlock(&hl_irqs_lock);
+
+	down_write(&hl_drivers_sem);
         list_del(&hl->hl_list);
-	write_unlock_irqrestore(&hl_drivers_lock, flags);
+	up_write(&hl_drivers_sem);
 
         if (hl->remove_host)
 		nodemgr_for_each_host(hl, highlevel_for_each_host_unreg);
 }
 
-int hpsb_register_addrspace(struct hpsb_highlevel *hl,
+int hpsb_register_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
                             struct hpsb_address_ops *ops, u64 start, u64 end)
 {
         struct hpsb_address_serve *as;
@@ -314,7 +323,7 @@ int hpsb_register_addrspace(struct hpsb_
         as->end = end;
 
         write_lock_irqsave(&addr_space_lock, flags);
-        entry = addr_space.next;
+        entry = host->addr_space.next;
 
         while (list_entry(entry, struct hpsb_address_serve, as_list)->end
                <= start) {
@@ -336,7 +345,8 @@ int hpsb_register_addrspace(struct hpsb_
         return retval;
 }
 
-int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, u64 start)
+int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
+                              u64 start)
 {
         int retval = 0;
         struct hpsb_address_serve *as;
@@ -350,7 +360,7 @@ int hpsb_unregister_addrspace(struct hps
         while (entry != &hl->addr_list) {
                 as = list_entry(entry, struct hpsb_address_serve, addr_list);
                 entry = entry->next;
-                if (as->start == start) {
+                if (as->start == start && as->host == host) {
                         list_del(&as->as_list);
                         list_del(&as->addr_list);
                         kfree(as);
@@ -395,89 +405,82 @@ void hpsb_unlisten_channel(struct hpsb_h
 
 void highlevel_add_host(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
 
-        read_lock(&hl_drivers_lock);
-        list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
+	down_read(&hl_drivers_sem);
+        list_for_each_entry(hl, &hl_drivers, hl_list) {
 		if (hl->add_host)
 			hl->add_host(host);
         }
-        read_unlock(&hl_drivers_lock);
+	up_read(&hl_drivers_sem);
 }
 
 void highlevel_remove_host(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
+	struct list_head *lh, *next;
+	struct hpsb_address_serve *as;
+	unsigned long flags;
 
-	read_lock(&hl_drivers_lock);
-	list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-
+	down_read(&hl_drivers_sem);
+	list_for_each_entry(hl, &hl_drivers, hl_list) {
 		if (hl->remove_host) {
 			hl->remove_host(host);
 			hpsb_destroy_hostinfo(hl, host);
 		}
         }
-	read_unlock(&hl_drivers_lock);
+	up_read(&hl_drivers_sem);
+
+	/* Free up 1394 address space left behind by high level drivers. */
+	write_lock_irqsave(&addr_space_lock, flags);
+	list_for_each_safe (lh, next, &host->addr_space) {
+		as = list_entry(lh, struct hpsb_address_serve, as_list);
+		if (!list_empty(&as->addr_list)) {
+			list_del(&as->addr_list);
+			kfree(as);
+		}
+	}
+	write_unlock_irqrestore(&addr_space_lock, flags);
 }
 
 void highlevel_host_reset(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
 
-	read_lock(&hl_drivers_lock);
-	list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-
+	read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, hl_list) {
                 if (hl->host_reset)
                         hl->host_reset(host);
         }
-	read_unlock(&hl_drivers_lock);
+	read_unlock(&hl_irqs_lock);
 }
 
-void highlevel_iso_receive(struct hpsb_host *host, void *data,
-			   size_t length)
+void highlevel_iso_receive(struct hpsb_host *host, void *data, size_t length)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
         int channel = (((quadlet_t *)data)[0] >> 8) & 0x3f;
 
-        read_lock(&hl_drivers_lock);
-        entry = hl_drivers.next;
-
-        while (entry != &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-                if (hl->iso_receive) {
+        read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, irq_list) {
+                if (hl->iso_receive)
                         hl->iso_receive(host, channel, data, length);
-                }
-                entry = entry->next;
         }
-        read_unlock(&hl_drivers_lock);
+        read_unlock(&hl_irqs_lock);
 }
 
 void highlevel_fcp_request(struct hpsb_host *host, int nodeid, int direction,
 			   void *data, size_t length)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
         int cts = ((quadlet_t *)data)[0] >> 4;
 
-        read_lock(&hl_drivers_lock);
-        entry = hl_drivers.next;
-
-        while (entry != &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-                if (hl->fcp_request) {
+        read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, irq_list) {
+                if (hl->fcp_request)
                         hl->fcp_request(host, nodeid, direction, cts, data,
-                                            length);
-                }
-                entry = entry->next;
+					length);
         }
-        read_unlock(&hl_drivers_lock);
+        read_unlock(&hl_irqs_lock);
 }
 
 int highlevel_read(struct hpsb_host *host, int nodeid, void *data,
@@ -490,7 +493,7 @@ int highlevel_read(struct hpsb_host *hos
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -536,7 +539,7 @@ int highlevel_write(struct hpsb_host *ho
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -582,7 +585,7 @@ int highlevel_lock(struct hpsb_host *hos
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -615,7 +618,7 @@ int highlevel_lock64(struct hpsb_host *h
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -640,7 +643,7 @@ int highlevel_lock64(struct hpsb_host *h
         return rcode;
 }
 
-void init_hpsb_highlevel(void)
+void init_hpsb_highlevel(struct hpsb_host *host)
 {
         INIT_LIST_HEAD(&dummy_zero_addr.as_list);
         INIT_LIST_HEAD(&dummy_zero_addr.addr_list);
@@ -652,6 +655,6 @@ void init_hpsb_highlevel(void)
         dummy_zero_addr.start = dummy_zero_addr.end = 0;
         dummy_max_addr.start = dummy_max_addr.end = ((u64) 1) << 48;
 
-        list_add_tail(&dummy_zero_addr.as_list, &addr_space);
-        list_add_tail(&dummy_max_addr.as_list, &addr_space);
+        list_add_tail(&dummy_zero_addr.as_list, &host->addr_space);
+        list_add_tail(&dummy_max_addr.as_list, &host->addr_space);
 }
diff -purN linux-2.6.1/drivers/ieee1394/highlevel.h linux-2.5/drivers/ieee1394/highlevel.h
--- linux-2.6.1/drivers/ieee1394/highlevel.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/ieee1394/highlevel.h	2004-01-14 23:15:11.000000000 +0000
@@ -10,6 +10,8 @@ struct hpsb_address_serve {
 
         struct hpsb_address_ops *op;
 
+	struct hpsb_host *host;
+
         /* first address handled and first address behind, quadlet aligned */
         u64 start, end;
 };
@@ -36,9 +38,9 @@ struct hpsb_highlevel {
          * hpsb_unregister_highlevel once for each host. */
         void (*remove_host) (struct hpsb_host *host);
 
-        /* Host experienced bus reset with possible configuration changes.  Note
-         * that this one may occur during interrupt/bottom half handling.  You
-         * can not expect to be able to do stock hpsb_reads. */
+        /* Host experienced bus reset with possible configuration changes.
+	 * Note that this one may occur during interrupt/bottom half handling.
+	 * You can not expect to be able to do stock hpsb_reads. */
         void (*host_reset) (struct hpsb_host *host);
 
         /* An isochronous packet was received.  Channel contains the channel
@@ -50,13 +52,14 @@ struct hpsb_highlevel {
 
         /* A write request was received on either the FCP_COMMAND (direction =
          * 0) or the FCP_RESPONSE (direction = 1) register.  The cts arg
-         * contains the cts field (first byte of data).
-         */
+         * contains the cts field (first byte of data). */
         void (*fcp_request) (struct hpsb_host *host, int nodeid, int direction,
                              int cts, u8 *data, size_t length);
 
-
+	/* These are initialized by the subsystem when the
+	 * hpsb_higlevel is registered. */
 	struct list_head hl_list;
+	struct list_head irq_list;
 	struct list_head addr_list;
 
 	struct list_head host_info_list;
@@ -137,10 +140,11 @@ void hpsb_unregister_highlevel(struct hp
  * It returns true for successful allocation.  There is no unregister function,
  * all address spaces are deallocated together with the hpsb_highlevel.
  */
-int hpsb_register_addrspace(struct hpsb_highlevel *hl,
+int hpsb_register_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
                             struct hpsb_address_ops *ops, u64 start, u64 end);
 
-int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, u64 start);
+int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
+                              u64 start);
 
 /*
  * Enable or disable receving a certain isochronous channel through the
@@ -179,6 +183,6 @@ int hpsb_set_hostinfo(struct hpsb_highle
 struct hpsb_host *hpsb_get_host_bykey(struct hpsb_highlevel *hl, unsigned long key);
 
 /* Initialize the highlevel system */
-void init_hpsb_highlevel(void);
+void init_hpsb_highlevel(struct hpsb_host *host);
 
 #endif /* IEEE1394_HIGHLEVEL_H */
diff -purN linux-2.6.1/drivers/ieee1394/hosts.c linux-2.5/drivers/ieee1394/hosts.c
--- linux-2.6.1/drivers/ieee1394/hosts.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/ieee1394/hosts.c	2004-01-14 23:12:02.000000000 +0000
@@ -89,6 +89,8 @@ struct hpsb_host *hpsb_alloc_host(struct
         INIT_LIST_HEAD(&h->pending_packets);
         spin_lock_init(&h->pending_pkt_lock);
 
+	INIT_LIST_HEAD(&h->addr_space);
+
 	for (i = 0; i < ARRAY_SIZE(h->tpool); i++)
 		HPSB_TPOOL_INIT(&h->tpool[i]);
 
diff -purN linux-2.6.1/drivers/ieee1394/hosts.h linux-2.5/drivers/ieee1394/hosts.h
--- linux-2.6.1/drivers/ieee1394/hosts.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/hosts.h	2004-01-14 23:12:03.000000000 +0000
@@ -69,6 +69,8 @@ struct hpsb_host {
 	int id;
 
 	struct device device;
+
+	struct list_head addr_space;
 };
 
 
diff -purN linux-2.6.1/drivers/ieee1394/ieee1394_core.c linux-2.5/drivers/ieee1394/ieee1394_core.c
--- linux-2.6.1/drivers/ieee1394/ieee1394_core.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ieee1394_core.c	2004-01-14 23:12:04.000000000 +0000
@@ -993,186 +993,11 @@ void abort_timedouts(unsigned long __opa
 }
 
 
-/*
- * character device dispatching (see ieee1394_core.h)
- * Dan Maas <dmaas@dcine.com>
- */
-
-static struct {
-	struct file_operations *file_ops;
-	struct module *module;
-} ieee1394_chardevs[16];
-
-static rwlock_t ieee1394_chardevs_lock = RW_LOCK_UNLOCKED;
-
-static int ieee1394_dispatch_open(struct inode *inode, struct file *file);
-
-static struct file_operations ieee1394_chardev_ops = {
-	.owner =THIS_MODULE,
-	.open =	ieee1394_dispatch_open,
-};
-
-/* claim a block of minor numbers */
-int ieee1394_register_chardev(int blocknum,
-			      struct module *module,
-			      struct file_operations *file_ops)
-{
-	int retval;
-
-	if ( (blocknum < 0) || (blocknum > 15) )
-		return -EINVAL;
-
-	write_lock(&ieee1394_chardevs_lock);
-
-	if (ieee1394_chardevs[blocknum].file_ops == NULL) {
-		/* grab the minor block */
-		ieee1394_chardevs[blocknum].file_ops = file_ops;
-		ieee1394_chardevs[blocknum].module = module;
-		
-		retval = 0;
-	} else {
-		/* block already taken */
-		retval = -EBUSY;
-	}
-
-	write_unlock(&ieee1394_chardevs_lock);
-
-	return retval;
-}
-
-/* release a block of minor numbers */
-void ieee1394_unregister_chardev(int blocknum)
-{
-	if ( (blocknum < 0) || (blocknum > 15) )
-		return;
-
-	write_lock(&ieee1394_chardevs_lock);
-
-	if (ieee1394_chardevs[blocknum].file_ops) {
-		ieee1394_chardevs[blocknum].file_ops = NULL;
-		ieee1394_chardevs[blocknum].module = NULL;
-	}
-
-	write_unlock(&ieee1394_chardevs_lock);
-}
-
-/*
-  ieee1394_get_chardev() - look up and acquire a character device
-  driver that has previously registered using ieee1394_register_chardev()
-  
-  On success, returns 1 and sets module and file_ops to the driver.
-  The module will have an incremented reference count.
-   
-  On failure, returns 0.
-  The module will NOT have an incremented reference count.
-*/
-
-static int ieee1394_get_chardev(int blocknum,
-				struct module **module,
-				struct file_operations **file_ops)
-{
-	int ret = 0;
-       
-	if ((blocknum < 0) || (blocknum > 15))
-		return ret;
-
-	read_lock(&ieee1394_chardevs_lock);
-
-	*module = ieee1394_chardevs[blocknum].module;
-	*file_ops = ieee1394_chardevs[blocknum].file_ops;
-
-	if (*file_ops == NULL)
-		goto out;
-
-	if (!try_module_get(*module))
-		goto out;
-
-	/* success! */
-	ret = 1;
-
-out:
-	read_unlock(&ieee1394_chardevs_lock);
-	return ret;
-}
-
-/* the point of entry for open() on any ieee1394 character device */
-static int ieee1394_dispatch_open(struct inode *inode, struct file *file)
-{
-	struct file_operations *file_ops;
-	struct module *module;
-	int blocknum;
-	int retval;
-
-	/*
-	  Maintaining correct module reference counts is tricky here!
-
-	  The key thing to remember is that the VFS increments the
-	  reference count of ieee1394 before it calls
-	  ieee1394_dispatch_open().
-
-	  If the open() succeeds, then we need to transfer this extra
-	  reference to the task-specific driver module (e.g. raw1394).
-	  The VFS will deref the driver module automatically when the
-	  file is later released.
-
-	  If the open() fails, then the VFS will drop the
-	  reference count of whatever module file->f_op->owner points
-	  to, immediately after this function returns.
-	*/
-
-        /* shift away lower four bits of the minor
-	   to get the index of the ieee1394_driver
-	   we want */
-
-	blocknum = (iminor(inode) >> 4) & 0xF;
-
-	/* look up the driver */
-
-	if (ieee1394_get_chardev(blocknum, &module, &file_ops) == 0)
-		return -ENODEV;
-
-	/* redirect all subsequent requests to the driver's
-	   own file_operations */
-	file->f_op = file_ops;
-
-	/* at this point BOTH ieee1394 and the task-specific driver have
-	   an extra reference */
-
-	/* follow through with the open() */
-	retval = file_ops->open(inode, file);
-
-	if (retval == 0) {
-		
-		/* If the open() succeeded, then ieee1394 will be left
-		 * with an extra module reference, so we discard it here.
-		 *
-		 * The task-specific driver still has the extra reference
-		 * given to it by ieee1394_get_chardev(). This extra
-		 * reference prevents the module from unloading while the
-		 * file is open, and will be dropped by the VFS when the
-		 * file is released. */
-
-		module_put(THIS_MODULE);
-	} else {
-		/* point the file's f_ops back to ieee1394. The VFS will then
-		   decrement ieee1394's reference count immediately after this
-		   function returns. */
-		
-		file->f_op = &ieee1394_chardev_ops;
-
-		/* If the open() failed, then we need to drop the extra
-		 * reference we gave to the task-specific driver. */
-
-		module_put(module);
-	}
-
-	return retval;
-}
-
 static int __init ieee1394_init(void)
 {
 	devfs_mk_dir("ieee1394");
-	if (register_chrdev(IEEE1394_MAJOR, "ieee1394", &ieee1394_chardev_ops)) {
+
+	if (register_chrdev_region(IEEE1394_CORE_DEV, 256, "ieee1394")) {
 		HPSB_ERR("unable to register character device major %d!\n", IEEE1394_MAJOR);
 		return -ENODEV;
 	}
@@ -1184,7 +1009,6 @@ static int __init ieee1394_init(void)
 
 	bus_register(&ieee1394_bus_type);
 
-	init_hpsb_highlevel();
 	init_csr();
 
 	if (!disable_nodemgr)
@@ -1206,7 +1030,7 @@ static void __exit ieee1394_cleanup(void
 
 	kmem_cache_destroy(hpsb_packet_cache);
 
-	unregister_chrdev(IEEE1394_MAJOR, "ieee1394");
+	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
 	devfs_remove("ieee1394");
 }
 
@@ -1234,8 +1058,6 @@ EXPORT_SYMBOL(hpsb_selfid_received);
 EXPORT_SYMBOL(hpsb_selfid_complete);
 EXPORT_SYMBOL(hpsb_packet_sent);
 EXPORT_SYMBOL(hpsb_packet_received);
-EXPORT_SYMBOL(ieee1394_register_chardev);
-EXPORT_SYMBOL(ieee1394_unregister_chardev);
 
 /** ieee1394_transactions.c **/
 EXPORT_SYMBOL(hpsb_get_tlabel);
diff -purN linux-2.6.1/drivers/ieee1394/ieee1394_core.h linux-2.5/drivers/ieee1394/ieee1394_core.h
--- linux-2.6.1/drivers/ieee1394/ieee1394_core.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ieee1394_core.h	2004-01-14 23:07:21.000000000 +0000
@@ -176,9 +176,9 @@ void hpsb_packet_received(struct hpsb_ho
  * task-specific interfaces (raw1394, video1394, dv1394, etc) in
  * blocks of 16.
  *
- * The core ieee1394.o modules handles the initial open() for all
- * character devices on major 171; it then dispatches to the
- * appropriate task-specific driver.
+ * The core ieee1394.o module allocates the device number region
+ * 171:0-255, the various drivers must then cdev_add() their cdev
+ * objects to handle their respective sub-regions.
  *
  * Minor device number block allocations:
  *
@@ -199,29 +199,19 @@ void hpsb_packet_received(struct hpsb_ho
 #define IEEE1394_MINOR_BLOCK_AMDTP         3
 #define IEEE1394_MINOR_BLOCK_EXPERIMENTAL 15
 
+#define IEEE1394_CORE_DEV		MKDEV(IEEE1394_MAJOR, 0)
+#define IEEE1394_RAW1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16)
+#define IEEE1394_VIDEO1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_VIDEO1394 * 16)
+#define IEEE1394_DV1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_DV1394 * 16)
+#define IEEE1394_AMDTP_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_AMDTP * 16)
+#define IEEE1394_EXPERIMENTAL_DEV	MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_EXPERIMENTAL * 16)
+
 /* return the index (within a minor number block) of a file */
 static inline unsigned char ieee1394_file_to_instance(struct file *file)
 {
-	unsigned char minor = iminor(file->f_dentry->d_inode);
-	
-	/* return lower 4 bits */
-	return minor & 0xF;
+	return file->f_dentry->d_inode->i_cindex;
 }
 
-/* 
- * Task-specific drivers should call ieee1394_register_chardev() to
- * request a block of 16 minor numbers.
- *
- * Returns 0 if the request was successful, -EBUSY if the block was
- * already taken.
- */
-
-int  ieee1394_register_chardev(int blocknum,           /* 0-15 */
-			       struct module *module,  /* THIS_MODULE */
-			       struct file_operations *file_ops);
-
-/* release a block of minor numbers */
-void ieee1394_unregister_chardev(int blocknum);
 
 /* Our sysfs bus entry */
 extern struct bus_type ieee1394_bus_type;
diff -purN linux-2.6.1/drivers/ieee1394/ohci1394.c linux-2.5/drivers/ieee1394/ohci1394.c
--- linux-2.6.1/drivers/ieee1394/ohci1394.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ohci1394.c	2004-01-14 23:20:31.000000000 +0000
@@ -161,7 +161,7 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, card , ## args)
 
 static char version[] __devinitdata =
-	"$Rev: 1087 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1097 $ Ben Collins <bcollins@debian.org>";
 
 /* Module Parameters */
 static int phys_dma = 1;
@@ -174,6 +174,7 @@ static void dma_trm_reset(struct dma_trm
 static int alloc_dma_rcv_ctx(struct ti_ohci *ohci, struct dma_rcv_ctx *d,
 			     enum context_type type, int ctx, int num_desc,
 			     int buf_size, int split_buf_size, int context_base);
+static void stop_dma_rcv_ctx(struct dma_rcv_ctx *d);
 static void free_dma_rcv_ctx(struct dma_rcv_ctx *d);
 
 static int alloc_dma_trm_ctx(struct ti_ohci *ohci, struct dma_trm_ctx *d,
@@ -358,7 +359,7 @@ static void ohci_soft_reset(struct ti_oh
 	reg_write(ohci, OHCI1394_HCControlSet, OHCI1394_HCControl_softReset);
   
 	for (i = 0; i < OHCI_LOOP_COUNT; i++) {
-		if (!reg_read(ohci, OHCI1394_HCControlSet) & OHCI1394_HCControl_softReset)
+		if (!(reg_read(ohci, OHCI1394_HCControlSet) & OHCI1394_HCControl_softReset))
 			break;
 		mdelay(1);
 	}
@@ -1077,6 +1078,7 @@ static int ohci_devctl(struct hpsb_host 
                 DBGMSG(ohci->id, "Listening disabled on channel %d", arg);
 
 		if (ohci->ir_legacy_channels == 0) {
+			stop_dma_rcv_ctx(&ohci->ir_legacy_context);
 			free_dma_rcv_ctx(&ohci->ir_legacy_context);
 			DBGMSG(ohci->id, "ISO receive legacy context deactivated");
 		}
@@ -2249,6 +2251,14 @@ static irqreturn_t ohci_irq_handler(int 
 	if (!event)
 		return IRQ_NONE;
 
+	/* If event is ~(u32)0 cardbus card was ejected.  In this case
+	 * we just return, and clean up in the ohci1394_pci_remove
+	 * function. */
+	if (event == ~(u32) 0) {
+		DBGMSG(ohci->id, "Device removed.");
+		return IRQ_NONE;
+	}
+
 	DBGMSG(ohci->id, "IntEvent: %08x", event);
 
 	if (event & OHCI1394_unrecoverableError) {
@@ -2811,15 +2821,8 @@ static void dma_trm_tasklet (unsigned lo
 	spin_unlock_irqrestore(&d->lock, flags);
 }
 
-static void free_dma_rcv_ctx(struct dma_rcv_ctx *d)
+static void stop_dma_rcv_ctx(struct dma_rcv_ctx *d)
 {
-	int i;
-
-	if (d->ohci == NULL)
-		return;
-
-	DBGMSG(d->ohci->id, "Freeing dma_rcv_ctx %d", d->ctx);
-
 	if (d->ctrlClear) {
 		ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
 
@@ -2831,6 +2834,17 @@ static void free_dma_rcv_ctx(struct dma_
 			tasklet_kill(&d->task);
 		}
 	}
+}
+
+
+static void free_dma_rcv_ctx(struct dma_rcv_ctx *d)
+{
+	int i;
+
+	if (d->ohci == NULL)
+		return;
+
+	DBGMSG(d->ohci->id, "Freeing dma_rcv_ctx %d", d->ctx);
 
 	if (d->buf_cpu) {
 		for (i=0; i<d->num_desc; i++)
@@ -2982,19 +2996,6 @@ static void free_dma_trm_ctx(struct dma_
 
 	DBGMSG(d->ohci->id, "Freeing dma_trm_ctx %d", d->ctx);
 
-	if (d->ctrlClear) {
-		ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
-
-		if (d->type == DMA_CTX_ISO) {
-			/* disable interrupts */
-			reg_write(d->ohci, OHCI1394_IsoXmitIntMaskClear, 1 << d->ctx);
-			ohci1394_unregister_iso_tasklet(d->ohci,
-							&d->ohci->it_legacy_tasklet);
-		} else {
-			tasklet_kill(&d->task);
-		}
-	}
-
 	if (d->prg_cpu) {
 		for (i=0; i<d->num_desc; i++) 
 			if (d->prg_cpu[i] && d->prg_bus[i]) {
@@ -3511,6 +3512,8 @@ static void ohci1394_pci_remove(struct p
 		free_irq(ohci->dev->irq, ohci);
 
 	case OHCI_INIT_HAVE_TXRX_BUFFERS__MAYBE:
+		/* The ohci_soft_reset() stops all DMA contexts, so we
+		 * dont need to do this.  */
 		/* Free AR dma */
 		free_dma_rcv_ctx(&ohci->ar_req_context);
 		free_dma_rcv_ctx(&ohci->ar_resp_context);
diff -purN linux-2.6.1/drivers/ieee1394/oui.db linux-2.5/drivers/ieee1394/oui.db
--- linux-2.6.1/drivers/ieee1394/oui.db	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/oui.db	2004-01-14 22:57:14.000000000 +0000
@@ -108,7 +108,7 @@
 00006B SILICON GRAPHICS INC./MIPS
 00006D CRAY COMMUNICATIONS, LTD.
 00006E ARTISOFT, INC.
-00006F MADGE NETWORKS LTD.
+00006F Madge Ltd.
 000070 HCL LIMITED
 000071 ADRA SYSTEMS INC.
 000072 MINIWARE TECHNOLOGY
@@ -137,7 +137,7 @@
 000089 CAYMAN SYSTEMS INC.
 00008A DATAHOUSE INFORMATION SYSTEMS
 00008B INFOTRON
-00008C ALLOY COMPUTER PRODUCTS, INC.
+00008C Alloy Computer Products (Australia) Pty Ltd
 00008D VERDIX CORPORATION
 00008E SOLBOURNE COMPUTER, INC.
 00008F RAYTHEON COMPANY
@@ -190,7 +190,7 @@
 0000BE THE NTI GROUP
 0000BF SYMMETRIC COMPUTER SYSTEMS
 0000C0 WESTERN DIGITAL CORPORATION
-0000C1 Madge Networks Ltd.
+0000C1 Madge Ltd.
 0000C2 INFORMATION PRESENTATION TECH.
 0000C3 HARRIS CORP COMPUTER SYS DIV
 0000C4 WATERS DIV. OF MILLIPORE
@@ -202,7 +202,7 @@
 0000CA APPLITEK
 0000CB COMPU-SHACK ELECTRONIC GMBH
 0000CC DENSAN CO., LTD.
-0000CD Centrecom Systems, Ltd.
+0000CD Allied Telesyn Research Ltd.
 0000CE MEGADATA CORP.
 0000CF HAYES MICROCOMPUTER PRODUCTS
 0000D0 DEVELCON ELECTRONICS LTD.
@@ -271,7 +271,7 @@
 000110 Gotham Networks
 000111 iDigm Inc.
 000112 Shark Multimedia Inc.
-000113 OLYMPUS OPTICAL CO., LTD.
+000113 OLYMPUS CORPORATION
 000114 KANDA TSUSHIN KOGYO CO., LTD.
 000115 EXTRATECH CORPORATION
 000116 Netspect Technologies, Inc.
@@ -345,7 +345,7 @@
 00015A Digital Video Broadcasting
 00015B ITALTEL S.p.A/RF-UP-I
 00015C CADANT INC.
-00015D Pirus Networks
+00015D Sun Microsystems, Inc
 00015E BEST TECHNOLOGY CO., LTD.
 00015F DIGITAL DESIGN GmbH
 000160 ELMEX Co., LTD.
@@ -361,7 +361,7 @@
 00016A ALITEC
 00016B LightChip, Inc.
 00016C FOXCONN
-00016D Triton Network Systems
+00016D CarrierComm Inc.
 00016E Conklin Corporation
 00016F HAITAI ELECTRONICS CO., LTD.
 000170 ESE Embedded System Engineer'g
@@ -445,7 +445,7 @@
 0001BE Gigalink Co., Ltd.
 0001BF Teleforce Co., Ltd.
 0001C0 CompuLab, Ltd.
-0001C1 Exbit Technology
+0001C1 Vitesse Semiconductor Corporation
 0001C2 ARK Research Corp.
 0001C3 Acromag, Inc.
 0001C4 NeoWave, Inc.
@@ -495,6 +495,7 @@
 0001EF Camtel Technology Corp.
 0001F0 Tridium, Inc.
 0001F1 Innovative Concepts, Inc.
+0001F2 Mark of the Unicorn, Inc.
 0001F3 QPS, Inc.
 0001F4 Enterasys Networks
 0001F5 ERIM S.A.
@@ -515,6 +516,7 @@
 000204 Bodmann Industries Elektronik GmbH
 000205 Hitachi Denshi, Ltd.
 000206 Telital R&D Denmark A/S
+000207 VisionGlobal Network Corp.
 000208 Unify Networks, Inc.
 000209 Shenzhen SED Information Technology Co., Ltd.
 00020A Gefran Spa
@@ -579,7 +581,7 @@
 000245 Lampus Co, Ltd.
 000246 All-Win Tech Co., Ltd.
 000247 Great Dragon Information Technology (Group) Co., Ltd.
-000248 Pila GmbH & Co.
+000248 Pilz GmbH & Co.
 000249 Aviv Infocom Co, Ltd.
 00024A Cisco Systems, Inc.
 00024B Cisco Systems, Inc.
@@ -600,6 +602,7 @@
 00025A Catena Networks
 00025B Cambridge Silicon Radio
 00025C SCI Systems (Kunshan) Co., Ltd.
+00025D Calix Networks
 00025E High Technology Ltd
 00025F Nortel Networks
 000260 Accordion Networks, Inc.
@@ -635,7 +638,7 @@
 00027E Cisco Systems, Inc.
 00027F ask-technologies.com
 000280 Mu Net, Inc.
-000281 Red-M (Communications) Ltd.
+000281 Madge Ltd.
 000282 ViaClix, Inc.
 000283 Spectrum Controls, Inc.
 000284 Alstom T&D P&C
@@ -662,6 +665,7 @@
 000299 Apex, Inc.
 00029A Storage Apps
 00029B Kreatel Communications AB
+00029C 3COM
 00029D Merix Corp.
 00029E Information Equipment Co., Ltd.
 00029F L-3 Communication Aviation Recorders
@@ -678,7 +682,7 @@
 0002AA PLcom Co., Ltd.
 0002AB CTC Union Technologies Co., Ltd.
 0002AC 3PAR data
-0002AD Asahi Optical Co., Ltd.
+0002AD Pentax Corpotation
 0002AE Scannex Electronics Ltd.
 0002AF TeleCruz Technology, Inc.
 0002B0 Hokubu Communication & Industrial Co., Ltd.
@@ -740,7 +744,7 @@
 0002E8 E.D.&A.
 0002E9 CS Systemes De Securite - C3S
 0002EA Videonics, Inc.
-0002EB Easent Communications
+0002EB Pico Communications
 0002EC Maschoff Design Engineering
 0002ED DXO Telecom Co., Ltd.
 0002EE Nokia Danmark A/S
@@ -760,7 +764,7 @@
 0002FC Cisco Systems, Inc.
 0002FD Cisco Systems, Inc.
 0002FE Viditec, Inc.
-0002FF Handan Broad InfoCom
+0002FF Handan BroadInfoCom
 000300 NetContinuum, Inc.
 000301 Avantas Networks Corporation
 000302 Oasys Telecom, Inc.
@@ -776,7 +780,7 @@
 00030C Telesoft Technologies Ltd.
 00030D Uniwill Computer Corp.
 00030E Core Communications Co., Ltd.
-00030F Legend Digital China Ltd.
+00030F Digital China (Shanghai) Networks Ltd.
 000310 Link Evolution Corp.
 000311 Micro Technology Co., Ltd.
 000312 TR-Systemtechnik GmbH
@@ -797,7 +801,7 @@
 000321 Reco Research Co., Ltd.
 000322 IDIS Co., Ltd.
 000323 Cornet Technology, Inc.
-000324 Tottori SANYO Electric Co., Ltd.
+000324 SANYO Multimedia Tottori Co., Ltd.
 000325 Arima Computer Corp.
 000326 Iwasaki Information Systems Co., Ltd.
 000327 ACT'L
@@ -851,12 +855,12 @@
 000357 Intervoice-Brite, Inc.
 000358 iCable System Co., Ltd.
 000359 DigitalSis
-00035A Phototron Limited
+00035A Photron Limited
 00035B BridgeWave Communications
 00035C Saint Song Corp.
 00035D Bosung Hi-Net Co., Ltd.
 00035E Metropolitan Area Networks, Inc.
-00035F Schuehle Mess - und. Kontrollsysteme
+00035F Prueftechnik Condition Monitoring GmbH & Co. KG
 000360 PAC Interactive Technology, Inc.
 000361 Widcomm, Inc.
 000362 Vodtel Communications, Inc.
@@ -889,6 +893,7 @@
 00037D Stellcom
 00037E PORTech Communications, Inc.
 00037F Atheros Communications, Inc.
+000380 SSH Communications Security Corp.
 000381 Ingenico International
 000382 A-One Co., Ltd.
 000383 Metera Networks, Inc.
@@ -916,7 +921,7 @@
 00039A nSine, Ltd.
 00039B NetChip Technology, Inc.
 00039C OptiMight Communications, Inc.
-00039D Acer Communications & Multimedia, Inc.
+00039D BENQ CORPORATION
 00039E Tera System Co., Ltd.
 00039F Cisco Systems, Inc.
 0003A0 Cisco Systems, Inc.
@@ -1063,7 +1068,7 @@
 00042E Netous Technologies, Ltd.
 00042F International Communications Products, Inc.
 000430 Netgem
-000431 Play Industries
+000431 GlobalStreams, Inc.
 000432 Voyetra Turtle Beach, Inc.
 000433 Cyberboard A/S
 000434 Accelent Systems, Inc.
@@ -1082,7 +1087,7 @@
 000441 Half Dome Systems, Inc.
 000442 NACT
 000443 Agilent Technologies, Inc.
-000444 Wireless Home
+000444 Western Multiplex Corporation
 000445 LMS Skalar Instruments GmbH
 000446 CYZENTECH Co., Ltd.
 000447 Acrowave Systems Co., Ltd.
@@ -1097,7 +1102,7 @@
 000450 DMD Computers SRL
 000451 Medrad, Inc.
 000452 RocketLogix, Inc.
-000453 Yotta Yotta, Inc.
+000453 YottaYotta, Inc.
 000454 Quadriga UK
 000455 ANTARA.net
 000456 PipingHot Networks
@@ -1108,16 +1113,16 @@
 00045B Techsan Electronics Co., Ltd.
 00045C Mobiwave Pte Ltd
 00045D BEKA Elektronik
-00045E Poly Trax Information Technology AG
+00045E PolyTrax Information Technology AG
 00045F Evalue Technology, Inc.
 000460 Knilink Technology, Inc.
 000461 EPOX Computer Co., Ltd.
 000462 DAKOS Data & Communication Co., Ltd.
-000463 Philips Communication Security & Imaging
+000463 Bosch Security Systems
 000464 Fantasma Networks, Inc.
-000465 ist isdn support tecknik GmbH
+000465 i.s.t isdn-support technik GmbH
 000466 ARMITEL Co.
-000467 Wuhan Research Institute
+000467 Wuhan Research Institute of MII
 000468 Vivity, Inc.
 000469 Innocom, Inc.
 00046A Navini Networks
@@ -1133,7 +1138,7 @@
 000474 LEGRAND
 000475 3 Com Corporation
 000476 3 Com Corporation
-000477 e-Appliance Corp.
+000477 Scalant Systems, Inc.
 000478 G. Star Technology Corporation
 000479 Radius Co., Ltd.
 00047A AXXESSIT ASA
@@ -1144,7 +1149,7 @@
 00047F Chr. Mayr GmbH & Co. KG
 000480 Foundry Networks, Inc.
 000481 Econolite Control Products, Inc.
-000482 MediaLogic Corp.
+000482 Medialogic Corp.
 000483 Deltron Technology, Inc.
 000484 Amann GmbH
 000485 PicoLight
@@ -1195,7 +1200,7 @@
 0004B3 Videotek, Inc.
 0004B4 CIAC
 0004B5 Equitrac Corporation
-0004B6 Tellumat (Pty) Ltd.
+0004B6 Stratex Networks, Inc.
 0004B7 AMB i.t. Holding
 0004B8 Kumahira Co., Ltd.
 0004B9 S.I. Soubou, Inc.
@@ -1204,20 +1209,20 @@
 0004BC Giantec, Inc.
 0004BD Motorola BCS
 0004BE OptXCon, Inc.
-0004BF Versa Logic Corp.
+0004BF VersaLogic Corp.
 0004C0 Cisco Systems, Inc.
 0004C1 Cisco Systems, Inc.
 0004C2 Magnipix, Inc.
 0004C3 CASTOR Informatique
-0004C4 Allen & Health
+0004C4 Allen & Heath Limited
 0004C5 ASE Technologies, USA
 0004C6 Yamaha Motor Co., Ltd.
 0004C7 NetMount
-0004C8 LIBA Maschinefabrik GmbH
+0004C8 LIBA Maschinenfabrik GmbH
 0004C9 Micro Electron Co., Ltd.
 0004CA FreeMs Corp.
 0004CB Tdsoft Communication, Ltd.
-0004CC Peek Traffic BV.
+0004CC Peek Traffic B.V.
 0004CD Informedia Research Group
 0004CE Patria Ailon
 0004CF Seagate Technology
@@ -1286,7 +1291,7 @@
 00050E 3ware, Inc.
 00050F Tanaka S/S Ltd.
 000510 Infinite Shanghai Communication Terminals Ltd.
-000511 Complementaty Technologies Ltd
+000511 Complementary Technologies Ltd
 000512 MeshNetworks, Inc.
 000513 VTLinx Multimedia Systems, Inc.
 000514 KDT Systems Co., Ltd.
@@ -1299,7 +1304,7 @@
 00051B Magic Control Technology Corporation
 00051C Xnet Technology Corp.
 00051D Airocon, Inc.
-00051E Rhapsody Networks
+00051E Brocade Communications Systems, Inc.
 00051F Taijin Media Co., Ltd.
 000520 Smartronix, Inc.
 000521 Control Microsystems
@@ -1339,7 +1344,7 @@
 000543 IQ Wireless GmbH
 000544 Valley Technologies, Inc.
 000545 Internet Photonics
-000546 KDD Network Systems Co., Ltd.
+000546 K-Solutions Inc.
 000547 Starent Networks
 000548 Disco Corporation
 000549 Salira Optical Network Systems
@@ -1374,6 +1379,7 @@
 000567 Etymonic Design, Inc.
 000568 Piltofish Networks AB
 000569 VMWARE, Inc.
+00056A Heuft Systemtechnik GmbH
 00056B C.P. Technology Co., Ltd.
 00056C Hung Chang Co., Ltd.
 00056D Pacific Corporation
@@ -1408,18 +1414,18 @@
 00058B IPmental, Inc.
 00058C Opentech Inc.
 00058D Lynx Photonic Networks, Inc.
-00058E Ahead Communications System GmbH
+00058E Flextronics International GmbH & Co. Nfg. KG
 00058F CLCsoft co.
-000590 Ascom Business Systems
+000590 Swissvoice Ltd.
 000591 Active Silicon Ltd.
-000592 Pultex Corp.
+000592 Pultek Corp.
 000593 Grammar Engine Inc.
 000594 IXXAT Automation GmbH
 000595 Alesis Corporation
 000596 Genotech Co., Ltd.
 000597 Eagle Traffic Control Systems
 000598 CRONOS S.r.l.
-000599 PEI Electronics, Inc.
+000599 DRS Test and Energy Management or DRS-TEM
 00059A Cisco Systems, Inc.
 00059B Cisco Systems, Inc.
 00059C Kleinknecht GmbH, Ing. Buero
@@ -1436,7 +1442,7 @@
 0005A7 Hyperchip, Inc.
 0005A8 WYLE ELECTRONICS
 0005A9 Princeton Networks, Inc.
-0005AA Moore Industries Int.
+0005AA Moore Industries International Inc.
 0005AB Cyber Fone, Inc.
 0005AC Northern Digital, Inc.
 0005AD Topspin Communications, Inc.
@@ -1453,13 +1459,14 @@
 0005B8 Electronic Design Associates, Inc.
 0005B9 Airvana, Inc.
 0005BA Area Netwoeks, Inc.
+0005BB Myspace AB
 0005BC Resorsys Ltd.
 0005BD ROAX BV
 0005BE Kongsberg Seatex AS
 0005BF JustEzy Technology, Inc.
 0005C0 Digital Network Alacarte Co., Ltd.
 0005C1 A-Kyung Motion, Inc.
-0005C2 Digital Archway, Inc.
+0005C2 Soronti, Inc.
 0005C3 Pacific Instruments, Inc.
 0005C4 Telect, Inc.
 0005C5 Flaga HF
@@ -1470,13 +1477,13 @@
 0005CA Hitron Technology, Inc.
 0005CB ROIS Technologies, Inc.
 0005CC Sumtel Communications, Inc.
-0005CD Nippon Columbia
+0005CD Denon, Ltd.
 0005CE Prolink Microsystems Corporation
 0005CF Thunder River Technologies, Inc.
 0005D0 Solinet Systems
 0005D1 Metavector Technologies
 0005D2 DAP Technologies
-0005D3 CAC, Inc.
+0005D3 eProduction Solutions, Inc.
 0005D4 FutureSmart Networks, Inc.
 0005D5 Speedcom Wireless
 0005D6 Titan Wireless
@@ -1496,27 +1503,27 @@
 0005E4 Red Lion Controls L.P.
 0005E5 Renishaw PLC
 0005E6 Egenera, Inc.
-0005E7 Netrake
+0005E7 Netrake Corp.
 0005E8 TurboWave, Inc.
-0005E9 Unicess Networks, Inc.
-0005EA Viewcast Corporation
+0005E9 Unicess Network, Inc.
+0005EA Rednix
 0005EB Blue Ridge Networks, Inc.
 0005EC Mosaic Systems Inc.
-0005ED Technikum Joanneaum GmbH
+0005ED Technikum Joanneum GmbH
 0005EE BEWATOR Group
 0005EF ADOIR Digital Technology
 0005F0 SATEC
-0005F1 VRcom, Inc.
+0005F1 Vrcom, Inc.
 0005F2 Power R, Inc.
 0005F3 Weboyn
-0005F4 SystemBase Co., Ltd.
+0005F4 System Base Co., Ltd.
 0005F5 OYO Geospace Corp.
 0005F6 Young Chang Co. Ltd.
 0005F7 Analog Devices, Inc.
 0005F8 Real Time Access, Inc.
-0005F9 Diva Systems
+0005F9 TOA Corporation
 0005FA IPOptical, Inc.
-0005FB Sharegate
+0005FB ShareGate, Inc.
 0005FC Schenck Pegasus Corp.
 0005FD PacketLight Networks Ltd.
 0005FE Traficon N.V.
@@ -1524,23 +1531,23 @@
 000600 Tokyo Electronic Industry Co., Ltd.
 000601 Otanikeiki Co., Ltd.
 000602 Cirkitech Electronics Co.
-000603 Baker Hughes
+000603 Baker Hughes Inc.
 000604 @Track Communications, Inc.
 000605 Inncom International, Inc.
-000606 RapidWan, Inc.
-000607 Omni-Directional Control Technology Inc.
+000606 RapidWAN, Inc.
+000607 Omni Directional Control Technology Inc.
 000608 At-Sky SAS
 000609 Crossport Systems
-00060A Blue2space.com
+00060A Blue2space
 00060B Paceline Systems Corporation
 00060C Melco Industries, Inc.
 00060D Wave7 Optics
-00060E IGSYS Systems, Inc.
+00060E IGYS Systems, Inc.
 00060F Narad Networks Inc
 000610 Abeona Networks Inc
 000611 Zeus Wireless, Inc.
 000612 Accusys, Inc.
-000613 Kawasaki Steel Corporation
+000613 Kawasaki Microelectronics Incorporated
 000614 Prism Holdings
 000615 Kimoto Electric Co., Ltd.
 000616 Tel Net Co., Ltd.
@@ -1557,7 +1564,7 @@
 000621 Hinox, Co., Ltd.
 000622 Chung Fu Chen Yeh Enterprise Corp.
 000623 MGE UPS Systems France
-000624 Gentner Communications
+000624 Gentner Communications Corp.
 000625 The Linksys Group, Inc.
 000626 MWE GmbH
 000627 Uniwide Technologies, Inc.
@@ -1580,7 +1587,7 @@
 000638 Sungjin C&C Co., Ltd.
 000639 Newtec
 00063A Dura Micro, Inc.
-00063B Lineo Canada Corp.
+00063B Arcturus Networks, Inc.
 00063C NMI Electronics Ltd
 00063D Microwave Data Systems Inc.
 00063E Opthos Inc.
@@ -1622,7 +1629,7 @@
 000662 MBM Technology Ltd.
 000663 Human Technology Co., Ltd.
 000664 Fostex Corporation
-000665 Summy Gikem, Inc.
+000665 Sunny Giken, Inc.
 000666 Roving Networks
 000667 Tripp Lite
 000668 Vicon Industries Inc.
@@ -1639,7 +1646,7 @@
 000673 Optelecom, Inc.
 000674 Spectrum Control, Inc.
 000675 Banderacom, Inc.
-000676 Novra Technologies, Inc.
+000676 Novra Technologies Inc.
 000677 SICK AG
 000678 Marantz Japan, Inc.
 000679 Konami Corporation
@@ -1647,18 +1654,2125 @@
 00067B Toplink C&C Corporation
 00067C CISCO SYSTEMS, INC.
 00067D Takasago Ltd.
+00067E WinCom Systems, Inc.
+00067F Rearden Steel Technologies
+000680 Card Access, Inc.
+000681 Goepel Electronic GmbH
+000682 Convedia
+000683 Bravara Communications, Inc.
+000684 Biacore AB
+000685 NetNearU Corporation
+000686 ZARDCOM Co., Ltd.
+000687 Omnitron Systems Technology, Inc.
+000688 Telways Communication Co., Ltd.
+000689 yLez Technologies Pte Ltd
+00068A NeuronNet Co. Ltd. R&D Center
+00068B AirRunner Technologies, Inc.
+00068C 3Com Corporation
+00068D SANgate Systems
+00068E HID Corporation
+00068F Telemonitor, Inc.
+000690 Euracom Communication GmbH
+000691 PT Inovacao
+000692 Intruvert Networks, Inc.
+000693 Flexus Computer Technology, Inc.
+000694 Mobillian Corporation
+000695 Ensure Technologies, Inc.
+000696 Advent Networks
+000697 R & D Center
+000698 egnite Software GmbH
+000699 Vida Design Co.
+00069A e & Tel
+00069B AVT Audio Video Technologies GmbH
+00069C Transmode Systems AB
+00069D Petards Mobile Intelligence
+00069E UNIQA, Inc.
+00069F Kuokoa Networks
+0006A0 Mx Imaging
+0006A1 Celsian Technologies, Inc.
+0006A2 Microtune, Inc.
+0006A3 Bitran Corporation
+0006A4 INNOWELL Corp.
+0006A5 PINON Corp.
+0006A6 Artistic Licence (UK) Ltd
+0006A7 Primarion
+0006A8 KC Technology, Inc.
+0006A9 Universal Instruments Corp.
+0006AA Miltope Corporation
+0006AB W-Link Systems, Inc.
+0006AC Intersoft Co.
+0006AD KB Electronics Ltd.
+0006AE Himachal Futuristic Communications Ltd
+0006B0 Comtech EF Data Corp.
+0006B1 Sonicwall
+0006B2 Linxtek Co.
+0006B3 Diagraph Corporation
+0006B4 Vorne Industries, Inc.
+0006B5 Luminent, Inc.
+0006B6 Nir-Or Israel Ltd.
+0006B7 TELEM GmbH
+0006B8 Bandspeed Pty Ltd
+0006B9 A5TEK Corp.
+0006BA Westwave Communications
+0006BB ATI Technologies Inc.
+0006BC Macrolink, Inc.
+0006BD BNTECHNOLOGY Co., Ltd.
+0006BE Baumer Optronic GmbH
+0006BF Accella Technologies Co., Ltd.
+0006C0 United Internetworks, Inc.
 0006C1 CISCO SYSTEMS, INC.
+0006C2 Smartmatic Corporation
+0006C3 Schindler Elevators Ltd.
+0006C4 Piolink Inc.
+0006C5 INNOVI Technologies Limited
+0006C6 lesswire AG
+0006C7 RFNET Technologies Pte Ltd (S)
+0006C8 Sumitomo Metal Micro Devices, Inc.
+0006C9 Technical Marketing Research, Inc.
+0006CA American Computer & Digital Components, Inc. (ACDC)
+0006CB Jotron Electronics A/S
+0006CC JMI Electronics Co., Ltd.
+0006CD CreoScitex Corporation Ltd.
+0006CE DATENO
+0006CF Thales Avionics In-Flight Systems, LLC
+0006D0 Elgar Electronics Corp.
+0006D1 Tahoe Networks, Inc.
+0006D2 Tundra Semiconductor Corp.
+0006D3 Alpha Telecom, Inc. U.S.A.
+0006D4 Interactive Objects, Inc.
+0006D5 Diamond Systems Corp.
+0006D6 Cisco Systems, Inc.
+0006D7 Cisco Systems, Inc.
+0006D8 Maple Optical Systems
+0006D9 IPM-Net S.p.A.
+0006DA ITRAN Communications Ltd.
+0006DB ICHIPS Co., Ltd.
+0006DC Syabas Technology (Amquest)
+0006DD AT & T Laboratories - Cambridge Ltd
+0006DE Flash Technology
+0006DF AIDONIC Corporation
+0006E0 MAT Co., Ltd.
+0006E1 Techno Trade s.a
+0006E2 Ceemax Technology Co., Ltd.
+0006E3 Quantitative Imaging Corporation
+0006E4 Citel Technologies Ltd.
+0006E5 Fujian Newland Computer Ltd. Co.
+0006E6 DongYang Telecom Co., Ltd.
+0006E7 Bit Blitz Communications Inc.
+0006E8 Optical Network Testing, Inc.
+0006E9 Intime Corp.
+0006EA ELZET80 Mikrocomputer GmbH&Co. KG
+0006EB Global Data
+0006EC M/A COM Private Radio System Inc.
+0006ED Inara Networks
+0006EE Shenyang Neu-era Information & Technology Stock Co., Ltd
+0006EF Maxxan Systems, Inc.
+0006F0 Digeo, Inc.
+0006F1 Optillion
+0006F2 Platys Communications
+0006F3 AcceLight Networks
+0006F4 Prime Electronics & Satellitics Inc.
+0006F9 Mitsui Zosen Systems Research Inc.
+0006FA IP SQUARE Co, Ltd.
+0006FB Hitachi Printing Solutions, Ltd.
+0006FC Fnet Co., Ltd.
+0006FD Comjet Information Systems Corp.
+0006FE Celion Networks, Inc.
+0006FF Sheba Systems Co., Ltd.
+000700 Zettamedia Korea
 000701 RACAL-DATACOM
+000702 Varian Medical Systems
+000703 CSEE Transport
+000705 Endress & Hauser GmbH & Co
+000706 Sanritz Corporation
+000707 Interalia Inc.
+000708 Bitrage Inc.
+000709 Westerstrand Urfabrik AB
+00070A Unicom Automation Co., Ltd.
+00070B Octal, SA
+00070C SVA-Intrusion.com Co. Ltd.
+00070D Cisco Systems Inc.
+00070E Cisco Systems Inc.
+00070F Fujant, Inc.
+000710 Adax, Inc.
+000711 Acterna
+000712 JAL Information Technology
+000713 IP One, Inc.
+000714 Brightcom
+000715 General Research of Electronics, Inc.
+000716 J & S Marine Ltd.
+000717 Wieland Electric GmbH
+000718 iCanTek Co., Ltd.
+000719 Mobiis Co., Ltd.
+00071A Finedigital Inc.
+00071B Position Technology Inc.
+00071C AT&T Fixed Wireless Services
+00071D Satelsa Sistemas Y Aplicaciones De Telecomunicaciones, S.A.
+00071E Tri-M Engineering / Nupak Dev. Corp.
+00071F European Systems Integration
+000720 Trutzschler GmbH & Co. KG
+000721 Formac Elektronik GmbH
+000722 Nielsen Media Research
+000723 ELCON Systemtechnik GmbH
+000724 Telemax Co., Ltd.
+000725 Bematech International Corp.
+000727 Zi Corporation (HK) Ltd.
+000728 Neo Telecom
+000729 Kistler Instrumente AG
+00072A Innovance Networks
+00072B Jung Myung Telecom Co., Ltd.
+00072C Fabricom
+00072D CNSystems
+00072E North Node AB
+00072F Instransa, Inc.
+000730 Hutchison OPTEL Telecom Technology Co., Ltd.
+000731 Spiricon, Inc.
+000732 AAEON Technology Inc.
+000733 DANCONTROL Engineering
+000734 ONStor, Inc.
+000735 Flarion Technologies, Inc.
+000736 Data Video Technologies Co., Ltd.
+000737 Soriya Co. Ltd.
+000738 Young Technology Co., Ltd.
+000739 Motion Media Technology Ltd.
+00073A Inventel Systemes
+00073B Tenovis GmbH & Co KG
+00073C Telecom Design
+00073D Nanjing Postel Telecommunications Co., Ltd.
+00073E China Great-Wall Computer Shenzhen Co., Ltd.
+00073F Woojyun Systec Co., Ltd.
+000740 Melco Inc.
+000741 Sierra Automated Systems
+000742 Current Technologies
+000743 Chelsio Communications
+000744 Unico, Inc.
+000745 Radlan Computer Communications Ltd.
+000746 Interlink BT, LLC
+000747 Mecalc
+000748 The Imaging Source Europe
+000749 CENiX Inc.
+00074A Carl Valentin GmbH
+00074B Daihen Corporation
+00074C Beicom Inc.
+00074D Zebra Technologies Corp.
+00074E Naughty boy co., Ltd.
+00074F Cisco Systems, Inc.
+000750 Cisco Systems, Inc.
+000751 m.u.t. - GmbH
+000752 Rhythm Watch Co., Ltd.
+000753 Beijing Qxcomm Technology Co., Ltd.
+000754 Xyterra Computing, Inc.
+000755 Lafon SA
+000756 Juyoung Telecom
+000757 Topcall International AG
+000758 Dragonwave
+000759 Boris Manufacturing Corp.
+00075A Air Products and Chemicals, Inc.
+00075B Gibson Guitars
+00075C ENCAD, Inc.
+00075D Celleritas Inc.
+00075E Pulsar Technologies, Inc.
+00075F VCS Video Communication Systems AG
+000760 TOMIS Information & Telecom Corp.
+000761 Logitech SA
+000762 Group Sense Limited
+000763 Sunniwell Cyber Tech. Co., Ltd.
+000764 YoungWoo Telecom Co. Ltd.
+000765 Jade Quantum Technologies, Inc.
+000766 Chou Chin Industrial Co., Ltd.
+000767 Yuxing Electronics Company Limited
+000768 Danfoss A/S
+000769 Italiana Macchi SpA
+00076A NEXTEYE Co., Ltd.
+00076B Stralfors AB
+00076C Daehanet, Inc.
+00076D Flexlight Networks
+00076E Sinetica Corporation Ltd.
+00076F Synoptics Limited
+000770 Locusnetworks Corporation
+000771 Embedded System Corporation
+000772 Alcatel Shanghai Bell Co., Ltd.
+000773 Ascom Powerline Communications Ltd.
+000774 GuangZhou Thinker Technology Co. Ltd.
+000775 Valence Semiconductor, Inc.
+000776 Federal APD
+000777 Motah Ltd.
+000778 GERSTEL GmbH & Co. KG
+000779 Sungil Telecom Co., Ltd.
+00077A Infoware System Co., Ltd.
+00077B Millimetrix Broadband Networks
+00077C OnTime Networks
+00077E Elrest GmbH
+00077F J Communications Co., Ltd.
+000780 Bluegiga Technologies OY
+000781 Itron Inc.
+000782 Nauticus Networks, Inc.
+000783 SynCom Network, Inc.
+000784 Cisco Systems Inc.
+000785 Cisco Systems Inc.
+000786 Wireless Networks Inc.
+000787 Idea System Co., Ltd.
+000788 Clipcomm, Inc.
+000789 Eastel Systems Corporation
+00078A Mentor Data System Inc.
+00078B Wegener Communications, Inc.
+00078C Elektronikspecialisten i Borlange AB
+00078D NetEngines Ltd.
+00078E Garz & Friche GmbH
+00078F Emkay Innovative Products
+000790 Tri-M Technologies (s) Limited
+000791 International Data Communications, Inc.
+000792 Suetron Electronic GmbH
+000794 Simple Devices, Inc.
+000795 Elitegroup Computer System Co. (ECS)
+000796 LSI Systems, Inc.
+000797 Netpower Co., Ltd.
+000798 Selea SRL
+000799 Tipping Point Technologies, Inc.
+00079A SmartSight Networks Inc.
+00079B Aurora Networks
+00079C Golden Electronics Technology Co., Ltd.
+00079D Musashi Co., Ltd.
+00079E Ilinx Co., Ltd.
+00079F Action Digital Inc.
+0007A0 e-Watch Inc.
+0007A1 VIASYS Healthcare GmbH
+0007A2 Opteon Corporation
+0007A3 Ositis Software, Inc.
+0007A4 GN Netcom Ltd.
+0007A5 Y.D.K Co. Ltd.
+0007A6 Home Automation, Inc.
+0007A7 A-Z Inc.
+0007A8 Haier Group Technologies Ltd.
+0007A9 Novasonics
+0007AA Quantum Data Inc.
+0007AC Eolring
+0007AD Pentacon GmbH Foto-und Feinwerktechnik
+0007AE Layer N Networks
+0007AF N-Tron Corp.
+0007B0 Office Details, Inc.
+0007B1 Equator Technologies
+0007B2 Transaccess S.A.
+0007B3 Cisco Systems Inc.
+0007B4 Cisco Systems Inc.
+0007B5 Any One Wireless Ltd.
+0007B6 Telecom Technology Ltd.
+0007B7 Samurai Ind. Prods Eletronicos Ltda
+0007B8 American Predator Corp.
+0007B9 Ginganet Corporation
+0007BA Xebeo Communications, Inc.
+0007BB Candera Inc.
+0007BC Identix Inc.
+0007BD Radionet Ltd.
+0007BE DataLogic SpA
+0007BF Armillaire Technologies, Inc.
+0007C0 NetZerver Inc.
+0007C1 Overture Networks, Inc.
+0007C2 Netsys Telecom
+0007C3 Cirpack
+0007C4 JEAN Co. Ltd.
+0007C5 Gcom, Inc.
+0007C6 VDS Vosskuhler GmbH
+0007C7 Synectics Systems Limited
+0007C8 Brain21, Inc.
+0007C9 Technol Seven Co., Ltd.
+0007CA Creatix Polymedia Ges Fur Kommunikaitonssysteme
+0007CB Freebox SA
+0007CC Kaba Benzing GmbH
+0007CD NMTEL Co., Ltd.
+0007CE Cabletime Limited
+0007CF Anoto AB
+0007D0 Automat Engenharia de Automaoa Ltda.
+0007D1 Spectrum Signal Processing Inc.
+0007D2 Logopak Systeme
+0007D3 Stork Digital Imaging B.V.
+0007D4 Zhejiang Yutong Network Communication Co Ltd.
+0007D5 3e Technologies Int;., Inc.
+0007D6 Commil Ltd.
+0007D7 Caporis Networks AG
+0007D8 Hitron Systems Inc.
+0007D9 Splicecom
+0007DA Neuro Telecom Co., Ltd.
+0007DB Kirana Networks, Inc.
+0007DC Atek Co, Ltd.
+0007DD Cradle Technologies
+0007DE eCopilt AB
+0007DF Vbrick Systems Inc.
+0007E0 Palm Inc.
+0007E1 WIS Communications Co. Ltd.
+0007E2 Bitworks, Inc.
+0007E3 Navcom Technology, Inc.
+0007E4 SoftRadio Co., Ltd.
+0007E5 Coup Corporation
+0007E6 edgeflow Canada Inc.
+0007E7 FreeWave Technologies
+0007E8 St. Bernard Software
+0007E9 Intel Corporation
+0007EA Massana, Inc.
+0007EB Cisco Systems Inc.
+0007EC Cisco Systems Inc.
+0007ED Altera Corporation
+0007EE telco Informationssysteme GmbH
+0007EF Lockheed Martin Tactical Systems
+0007F0 LogiSync Corporation
+0007F1 TeraBurst Networks Inc.
+0007F2 IOA Corporation
+0007F3 Think Engine Networks
+0007F4 Eletex Co., Ltd.
+0007F5 Bridgeco Co AG
+0007F6 Qqest Software Systems
+0007F7 Galtronics
+0007F8 ITDevices, Inc.
+0007F9 Phonetics, Inc.
+0007FA ITT Co., Ltd.
+0007FB Giga Stream UMTS Technologies GmbH
+0007FC Adept Systems Inc.
+0007FD LANergy Ltd.
+0007FE Rigaku Corporation
+0007FF Gluon Networks
 000800 MULTITECH SYSTEMS, INC.
+000801 HighSpeed Surfing Inc.
+000802 Compaq Computer Corporation
+000803 Cos Tron
+000804 ICA Inc.
+000805 Techno-Holon Corporation
+000806 Raonet Systems, Inc.
+000807 Access Devices Limited
+000808 PPT Vision, Inc.
+000809 Systemonic AG
+00080A Espera-Werke GmbH
+00080B Birka BPA Informationssystem AB
+00080C VDA elettronica SrL
+00080D Toshiba
+00080E Motorola, BCS
+00080F Proximion Fiber Optics AB
+000810 Key Technology, Inc.
+000811 VOIX Corporation
+000812 GM-2 Corporation
+000813 Diskbank, Inc.
+000814 TIL Technologies
+000815 CATS Co., Ltd.
+000816 Bluetags A/S
+000817 EmergeCore Networks LLC
+000818 Pixelworks, Inc.
+000819 Banksys
+00081A Sanrad Intelligence Storage Communications (2000) Ltd.
+00081B Windigo Systems
+00081C @pos.com
+00081D Ipsil, Incorporated
+00081E Repeatit AB
+00081F Pou Yuen Tech Corp. Ltd.
+000820 Cisco Systems Inc.
+000821 Cisco Systems Inc.
+000822 InPro Comm
+000823 Texa Corp.
+000824 Promatek Industries Ltd.
+000825 Acme Packet
+000826 Colorado Med Tech
+000827 Pirelli Cables & Systems
+000828 Koei Engineering Ltd.
+000829 Aval Nagasaki Corporation
+00082A Powerwallz Network Security
+00082B Wooksung Electronics, Inc.
+00082C Homag AG
+00082D Indus Teqsite Private Limited
+00082E Multitone Electronics PLC
+00084E DivergeNet, Inc.
+00084F Qualstar Corporation
+000850 Arizona Instrument Corp.
+000851 Canadian Bank Note Company, Ltd.
+000852 Davolink Co. Inc.
+000853 Schleicher GmbH & Co. Relaiswerke KG
+000854 Netronix, Inc.
+000855 NASA-Goddard Space Flight Center
+000856 Gamatronic Electronic Industries Ltd.
+000857 Polaris Networks, Inc.
+000858 Novatechnology Inc.
+000859 ShenZhen Unitone Electronics Co., Ltd.
+00085A IntiGate Inc.
+00085B Hanbit Electronics Co., Ltd.
+00085C Shanghai Dare Technologies Co. Ltd.
+00085D Aastra
+00085E PCO AG
+00085F Picanol N.V.
+000860 LodgeNet Entertainment Corp.
+000861 SoftEnergy Co., Ltd.
+000862 NEC Eluminant Technologies, Inc.
+000863 Entrisphere Inc.
+000864 Fasy S.p.A.
+000865 JASCOM CO., LTD
+000866 DSX Access Systems, Inc.
+000867 Uptime Devices
+000868 PurOptix
+000869 Command-e Technology Co.,Ltd.
+00086A Industrie Technik IPS GmbH
+00086B MIPSYS
+00086C Plasmon LMS
+00086D Missouri FreeNet
+00086E Hyglo AB
+00086F Resources Computer Network Ltd.
+000870 Rasvia Systems, Inc.
+000871 NORTHDATA Co., Ltd.
+000872 Sorenson Technologies, Inc.
+000873 DAP Design B.V.
+000874 Dell Computer Corp.
+000875 Acorp Electronics Corp.
+000876 SDSystem
+000877 Liebert HIROSS S.p.A.
+000878 Benchmark Storage Innovations
+000879 CEM Corporation
+00087A Wipotec GmbH
+00087B RTX Telecom A/S
+00087C Cisco Systems, Inc.
+00087D Cisco Systems Inc.
+00087E Bon Electro-Telecom Inc.
+00087F SPAUN electronic GmbH & Co. KG
+000880 BroadTel Canada Communications inc.
+000881 DIGITAL HANDS CO.,LTD.
+000882 SIGMA CORPORATION
+000883 Hewlett-Packard Company
+000884 Index Braille AB
+000885 EMS Dr. Thomas Wuensche
+000886 Hansung Teliann, Inc.
+000887 Maschinenfabrik Reinhausen GmbH
+000888 OULLIM Information Technology Inc,.
+000889 Echostar Technologies Corp
+00088A Minds@Work
+00088B Tropic Networks Inc.
+00088C Quanta Network Systems Inc.
+00088D Sigma-Links Inc.
+00088E Nihon Computer Co., Ltd.
+00088F ADVANCED DIGITAL TECHNOLOGY
+000890 AVILINKS SA
+000891 Lyan Inc.
+000892 EM Solutions
+000894 InnoVISION Multimedia Ltd.
+000895 DIRC Technologie GmbH & Co.KG
+000896 Printronix, Inc.
+000897 Quake Technologies
+000898 Gigabit Optics Corporation
+000899 Netbind, Inc.
+00089A Alcatel Microelectronics
+00089B ICP Electronics Inc.
+00089C Elecs Industry Co., Ltd.
+00089D UHD-Elektronik
+00089E Beijing Enter-Net co.LTD
+00089F EFM Networks
+0008A0 Stotz Feinmesstechnik GmbH
+0008A1 CNet Technology Inc.
+0008A2 ADI Engineering, Inc.
+0008A3 Cisco Systems
+0008A4 Cisco Systems
+0008A5 Peninsula Systems Inc.
+0008A6 Multiware & Image Co., Ltd.
+0008A7 iLogic Inc.
+0008A8 Systec Co., Ltd.
+0008A9 SangSang Technology, Inc.
+0008AA KARAM
+0008AB EnerLinx.com, Inc.
+0008AD Toyo-Linx Co., Ltd.
+0008AE Packetfront
+0008AF Novatec Corporation
+0008B0 BKtel communications GmbH
+0008B1 ProQuent Systems
+0008B2 SHENZHEN COMPASS TECHNOLOGY DEVELOPMENT CO.,LTD
+0008B3 Fastwel
+0008B4 SYSPOL
+0008B5 TAI GUEN ENTERPRISE CO., LTD
+0008B6 RouteFree, Inc.
+0008B7 HIT Incorporated
+0008B8 E.F. Johnson
+0008B9 KAON MEDIA Co., Ltd.
+0008BA Erskine Systems Ltd
+0008BB NetExcell
+0008BC Ilevo AB
+0008BD TEPG-US
+0008BE XENPAK MSA Group
+0008BF Aptus Elektronik AB
+0008C0 ASA SYSTEMS
+0008C1 Avistar Communications Corporation
+0008C2 Cisco Systems
+0008C3 Contex A/S
+0008C4 Hikari Co.,Ltd.
+0008C5 Liontech Co., Ltd.
+0008C6 Philips Consumer Communications
 0008C7 COMPAQ COMPUTER CORPORATION
+0008C8 Soneticom, Inc.
+0008C9 TechniSat Digital GmbH
+0008CA TwinHan Technology Co.,Ltd
+0008CB Zeta Broadband Inc.
+0008CC Remotec, Inc.
+0008CD With-Net Inc
+0008CF Nippon Koei Power Systems Co., Ltd.
+0008D0 Musashi Engineering Co., LTD.
+0008D1 KAREL INC.
+0008D2 ZOOM Networks Inc.
+0008D3 Hercules Technologies S.A.
+0008D4 IneoQuest Technologies, Inc
+0008D5 Vanguard Managed Solutions
+0008D6 HASSNET Inc.
+0008D7 HOW CORPORATION
+0008D8 Dowkey Microwave
+0008D9 Mitadenshi Co.,LTD
+0008DA SofaWare Technologies Ltd.
+0008DB Corrigent Systems
+0008DC Wiznet
+0008DD Telena Communications, Inc.
+0008DE 3UP Systems
+0008DF Alistel Inc.
+0008E0 ATO Technology Ltd.
+0008E1 Barix AG
+0008E2 Cisco Systems
+0008E3 Cisco Systems
+0008E4 Envenergy Inc
+0008E5 IDK Corporation
+0008E6 Littlefeet
+0008E7 SHI ControlSystems,Ltd.
+0008E8 Excel Master Ltd.
+0008E9 NextGig
+0008EA Motion Control Engineering, Inc
+0008EB ROMWin Co.,Ltd.
+0008EC Zonu, Inc.
+0008ED ST&T Instrument Corp.
+0008EE Logic Product Development
+0008EF DIBAL,S.A.
+0008F0 Next Generation Systems, Inc.
+0008F1 Voltaire
+0008F2 C&S Technology
+0008F3 WANY
+0008F4 Bluetake Technology Co., Ltd.
+0008F5 YESTECHNOLOGY Co.,Ltd.
+0008F6 SUMITOMO ELECTRIC HIGHTECHS.co.,ltd.
+0008F7 Hitachi Ltd, Semiconductor &amp; Integrated Circuits Gr
+0008F8 Guardall Ltd
+0008F9 Padcom, Inc.
+0008FA Karl E.Brinkmann GmbH
+0008FB SonoSite, Inc.
+0008FC Gigaphoton Inc.
+0008FD BlueKorea Co., Ltd.
+0008FE UNIK C&C Co.,Ltd.
+0008FF Trilogy Broadcast (Holdings) Ltd
+000900 TMT
+000901 Shenzhen Shixuntong Information & Technoligy Co
+000902 Redline Communications Inc.
+000903 Panasas, Inc
+000904 MONDIAL electronic
+000905 iTEC Technologies Ltd.
+000906 Esteem Networks
+000907 Chrysalis Development
+000908 VTech Technology Corp.
+000909 Telenor Connect A/S
+00090A SnedFar Technology Co., Ltd.
+00090B MTL  Instruments PLC
+00090C Mayekawa Mfg. Co. Ltd.
+00090D LEADER ELECTRONICS CORP.
+00090E Helix Technology Inc.
+00090F Fortinet Inc.
+000910 Simple Access Inc.
+000911 Cisco Systems
+000912 Cisco Systems
+000914 COMPUTROLS INC.
+000915 CAS Corp.
+000916 Listman Home Technologies, Inc.
+000917 WEM Technology Inc
+000918 SAMSUNG TECHWIN CO.,LTD
+000919 MDS Gateways
+00091A Macat Optics & Electronics Co., Ltd.
+00091B Digital Generation Inc.
+00091C CacheVision, Inc
+00091D Proteam Computer Corporation
+00091E Firstech Technology Corp.
+00091F A&amp;D Co., Ltd.
+000920 EpoX COMPUTER CO.,LTD.
+000921 Planmeca Oy
+000922 Touchless Sensor Technology AG
+000923 Heaman System Co., Ltd
+000924 Telebau GmbH
+000925 VSN Systemen BV
+000926 YODA COMMUNICATIONS, INC.
+000927 TOYOKEIKI CO.,LTD.
+000928 Telecore Inc
+000929 Sanyo Industries (UK) Limited
+00092A MYTECS Co.,Ltd.
+00092B iQstor Networks, Inc.
+00092C Hitpoint Inc.
+00092D High Tech Computer, Corp.
+00092E B&Tech System Inc.
+00092F Akom Technology Corporation
+000930 AeroConcierge Inc.
+000931 Future Internet, Inc.
+000932 Omnilux
+000933 OPTOVALLEY Co. Ltd.
+000934 Dream-Multimedia-Tv GmbH
+000935 Sandvine Incorporated
+000936 Ipetronik GmbH & Co.KG
+000937 Inventec Appliance Corp
+000938 Allot Communications
+000939 ShibaSoku Co.,Ltd.
+00093A Molex Fiber Optics
+00093B HYUNDAI NETWORKS INC.
+00093C Jacques Technologies P/L
+00093D Newisys,Inc.
+00093E C&I Technologies
+00093F Double-Win Enterpirse CO., LTD
+000940 AGFEO GmbH & Co. KG
+000941 Allied Telesis K.K.
+000942 CRESCO, LTD.
+000943 Cisco Systems
+000944 Cisco Systems
+000945 Palmmicro Communications Inc
+000946 Cluster Labs GmbH
+000947 Aztek, Inc.
+000948 Vista Control Systems, Corp.
+000949 Glyph Technologies Inc.
+00094A Homenet Communications
+00094B FillFactory NV
+00094C Communication Weaver Co.,Ltd.
+00094D Braintree Communications Pty Ltd
+00094E BARTECH SYSTEMS INTERNATIONAL, INC
+00094F elmegt GmbH & Co. KG
+000950 Independent Storage Corporation
+000951 Apogee Instruments, Inc
+000952 Auerswald GmbH & Co. KG
+000953 Linkage System Integration Co.Ltd.
+000954 AMiT spol. s. r. o.
+000955 Young Generation International Corp.
+000956 Network Systems Group, Ltd. (NSG)
+000957 Supercaller, Inc.
+000958 INTELNET S.A.
+000959 Sitecsoft
+00095A RACEWOOD TECHNOLOGY
+00095B Netgear, Inc.
+00095C Philips Medical Systems - Cardiac and Monitoring Systems (CM
+00095D Dialogue Technology Corp.
+00095E Masstech Group Inc.
+00095F Telebyte, Inc.
+000960 YOZAN Inc.
+000961 Switchgear and Instrumentation Ltd
+000962 Filetrac AS
+000963 Dominion Lasercom Inc.
+000964 Hi-Techniques
+000966 Thales Navigation
+000967 Tachyon, Inc
+000968 TECHNOVENTURE, INC.
+000969 Meret Optical Communications
+00096A Cloverleaf Communications Inc.
+00096B IBM Corporation
+00096C Imedia Semiconductor Corp.
+00096D Powernet Technologies Corp.
+00096E GIANT ELECTRONICS LTD.
+00096F Beijing Zhongqing Elegant Tech. Corp.,Limited
+000970 Vibration Research Corporation
+000971 Time Management, Inc.
+000972 Securebase,Inc
+000973 Lenten Technology Co., Ltd.
+000974 Innopia Technologies, Inc.
+000975 fSONA Communications Corporation
+000976 Datasoft ISDN Systems GmbH
+000977 Brunner Elektronik AG
+000978 AIJI System Co., Ltd.
+000979 Advanced Television Systems Committee, Inc.
+00097A Louis Design Labs.
+00097B Cisco Systems
+00097C Cisco Systems
+00097D SecWell Networks Oy
+00097E IMI TECHNOLOGY CO., LTD
+00097F Vsecure 2000 LTD.
+000980 Power Zenith Inc.
+000981 Newport Networks
+000982 Loewe Opta GmbH
+000983 Gvision Incorporated
+000984 MyCasa Network Inc.
+000985 Auto Telecom Company
+000986 Metalink LTD.
+000987 NISHI NIPPON ELECTRIC WIRE & CABLE CO.,LTD.
+000988 Nudian Electron Co., Ltd.
+000989 VividLogic Inc.
+00098A EqualLogic Inc
+00098B Entropic Communications, Inc.
+00098C Possio AB
+00098D DCT Ltd (Digital Communication Technologies Ltd)
+00098E ipcas GmbH
+00098F Cetacean Networks
+000990 ACKSYS Communications & systems
+000991 GE Fanuc Automation Manufacturing, Inc.
+000992 InterEpoch Technology,INC.
+000993 Visteon Corporation
+000994 Cronyx Engineering
+000995 Castle Technology Ltd
+000996 RDI
+000997 Nortel Networks
+000998 Capinfo Company Limited
+000999 CP GEORGES RENAULT
+00099A ELMO COMPANY, LIMITED
+00099B Western Telematic Inc.
+00099C Naval Research Laboratory
+00099D Haliplex Communications
+00099E Testech, Inc.
+00099F VIDEX INC.
+0009A0 Microtechno Corporation
+0009A1 Telewise Communications, Inc.
+0009A2 Interface Co., Ltd.
+0009A3 Leadfly Techologies Corp. Ltd.
+0009A4 HARTEC Corporation
+0009A5 HANSUNG ELETRONIC INDUSTRIES DEVELOPMENT CO., LTD
+0009A6 Ignis Optics, Inc.
+0009A7 Bang & Olufsen A/S
+0009A8 Eastmode Pte Ltd
+0009A9 Ikanos Communications
+0009AA Data Comm for Business, Inc.
+0009AB Netcontrol Oy
+0009AC LANVOICE
+0009AD HYUNDAI SYSCOMM, INC.
+0009AE OKANO ELECTRIC CO.,LTD
+0009AF e-generis
+0009B0 Onkyo Corporation
+0009B1 Kanematsu Electronics, Ltd.
+0009B2 L&F Inc.
+0009B3 MCM Systems Ltd
+0009B4 KISAN TELECOM CO., LTD.
+0009B5 3J Tech. Co., Ltd.
+0009B6 Cisco Systems
+0009B7 Cisco Systems
+0009B8 Entise Systems
+0009B9 Action Imaging Solutions
+0009BA MAKU Informationstechik GmbH
+0009BB MathStar, Inc.
+0009BC Digital Safety Technologies Inc.
+0009BD Epygi Technologies, Ltd.
+0009BE Mamiya-OP Co.,Ltd.
+0009BF Nintendo Co.,Ltd.
+0009C0 6WIND
+0009C1 PROCES-DATA A/S
+0009C3 NETAS
+0009C4 Medicore Co., Ltd
+0009C5 KINGENE Technology Corporation
+0009C6 Visionics Corporation
+0009C7 Movistec
+0009C8 SINAGAWA TSUSHIN KEISOU SERVICE
+0009C9 BlueWINC Co., Ltd.
+0009CA iMaxNetworks(Shenzhen)Limited.
+0009CB HBrain
+0009CC Moog GmbH
+0009CD HUDSON SOFT CO.,LTD.
+0009CE SpaceBridge Semiconductor Corp.
+0009CF iAd GmbH
+0009D0 Versatel Networks
+0009D1 SERANOA NETWORKS INC
+0009D2 Mai Logic Inc.
+0009D3 Western DataCom Co., Inc.
+0009D4 Transtech Networks
+0009D5 Signal Communication, Inc.
+0009D6 KNC One GmbH
+0009D7 DC Security Products
+0009D9 Neoscale Systems, Inc
+0009DA Control Module Inc.
+0009DB eSpace
+0009DC Galaxis Technology AG
+0009DD Mavin Technology Inc.
+0009DE Samjin Information & Communications Co., Ltd.
+0009DF Vestel Komunikasyon Sanayi ve Ticaret A.S.
+0009E0 XEMICS S.A.
+0009E1 Gemtek Technology Co., Ltd.
+0009E2 Sinbon Electronics Co., Ltd.
+0009E3 Angel Iglesias S.A.
+0009E4 K Tech Infosystem Inc.
+0009E5 Hottinger Baldwin Messtechnik GmbH
+0009E6 Cyber Switching Inc.
+0009E7 ADC Techonology
+0009E8 Cisco Systems
+0009E9 Cisco Systems
+0009EA YEM Inc.
+0009EB HuMANDATA LTD.
+0009EC Daktronics, Inc.
+0009ED CipherOptics
+0009EE MEIKYO ELECTRIC CO.,LTD
+0009EF Vocera Communications
+0009F0 Shimizu Technology Inc.
+0009F1 Yamaki Electric Corporation
+0009F2 Cohu, Inc., Electronics Division
+0009F3 WELL Communication Corp.
+0009F4 Alcon Laboratories, Inc.
+0009F5 Emerson Network Power Co.,Ltd
+0009F6 Shenzhen Eastern Digital Tech Ltd.
+0009F7 SED, a division of Calian
+0009F8 UNIMO TECHNOLOGY CO., LTD.
+0009F9 ART JAPAN CO., LTD.
+0009FB Philips Medizinsysteme Boeblingen GmbH
+0009FC IPFLEX Inc.
+0009FD Ubinetics Limited
+0009FE Daisy Technologies, Inc.
+0009FF X.net 2000 GmbH
+000A00 Mediatek Corp.
+000A01 SOHOware, Inc.
+000A02 ANNSO CO., LTD.
+000A03 ENDESA SERVICIOS, S.L.
+000A04 3Com Europe Ltd
+000A05 Widax Corp.
+000A06 Teledex LLC
+000A07 WebWayOne Ltd
+000A08 ALPINE ELECTRONICS, INC.
+000A09 TaraCom Integrated Products, Inc.
+000A0A SUNIX Co., Ltd.
+000A0B Sealevel Systems, Inc.
+000A0C Scientific Research Corporation
+000A0D MergeOptics GmbH
+000A0E Invivo Research Inc.
+000A0F Ilryung Telesys, Inc
+000A10 FAST media integrations AG
+000A11 ExPet Technologies, Inc
+000A12 Azylex Technology, Inc
+000A13 Silent Witness
+000A14 TECO a.s.
+000A15 Silicon Data, Inc
+000A16 Lassen Research
+000A17 NESTAR COMMUNICATIONS, INC
+000A18 Vichel Inc.
+000A19 Valere Power, Inc.
+000A1A Imerge Ltd
+000A1B Stream Labs
+000A1C Bridge Information Co., Ltd.
+000A1D Optical Communications Products Inc.
+000A1E Red-M (Communications) Limited
+000A1F ART WARE Telecommunication Co., Ltd.
+000A20 SVA Networks, Inc.
+000A21 Integra Telecom Co. Ltd
+000A22 Amperion Inc
+000A23 Parama Networks Inc
+000A24 Octave Communications
+000A25 CERAGON NETWORKS
+000A26 CEIA S.p.A.
 000A27 Apple Computer, Inc.
-001000 CABLE TELEVISION
+000A28 Motorola
+000A29 Pan Dacom Networking AG
+000A2A QSI Systems Inc.
+000A2B Etherstuff
+000A2C Active Tchnology Corporation
+000A2E MAPLE NETWORKS CO., LTD
+000A2F Artnix Inc.
+000A30 Johnson Controls-ASG
+000A31 HCV Wireless
+000A32 Xsido Corporation
+000A33 Sierra Logic, Inc.
+000A34 Identicard Systems Incorporated
+000A35 Xilinx
+000A36 Synelec Telecom Multimedia
+000A37 Procera Networks, Inc.
+000A38 Netlock Technologies, Inc.
+000A39 LoPA Information Technology
+000A3A J-THREE INTERNATIONAL Holding Co., Ltd.
+000A3B GCT Semiconductor, Inc
+000A3C Enerpoint Ltd.
+000A3D Elo Sistemas Eletronicos S.A.
+000A3E EADS Telecom
+000A3F Data East Corporation
+000A40 Crown Audio
+000A41 Cisco Systems
+000A42 Cisco Systems
+000A43 Chunghwa Telecom Co., Ltd.
+000A44 Avery Dennison Deutschland GmbH
+000A45 Audio-Technica Corp.
+000A46 ARO Controls SAS
+000A47 Allied Vision Technologies
+000A48 Albatron Technology
+000A49 Acopia Networks
+000A4A Targa Systems Ltd.
+000A4B DataPower Technology, Inc.
+000A4C Molecular Devices Corporation
+000A4D Noritz Corporation
+000A4E UNITEK Electronics INC.
+000A4F Brain Boxes Limited
+000A50 REMOTEK CORPORATION
+000A51 GyroSignal Technology Co., Ltd.
+000A52 Venitek Co. Ltd.
+000A53 Intronics, Incorporated
+000A54 Laguna Hills, Inc.
+000A55 MARKEM Corporation
+000A56 HITACHI Maxell Ltd.
+000A57 Hewlett-Packard Company - Standards
+000A58 Ingenieur-Buero Freyer & Siegel
+000A59 HW server
+000A5A GreenNET Technologies Co.,Ltd.
+000A5B Power-One as
+000A5C Carel s.p.a.
+000A5D PUC Founder (MSC) Berhad
+000A5E 3COM Corporation
+000A5F almedio inc.
+000A60 Autostar Technology Pte Ltd
+000A61 Cellinx Systems Inc.
+000A62 Crinis Networks, Inc.
+000A63 DHD GmbH
+000A64 Eracom Technologies
+000A65 GentechMedia.co.,ltd.
+000A66 MITSUBISHI ELECTRIC SYSTEM & SERVICE CO.,LTD.
+000A67 OngCorp
+000A68 SolarFlare Communications, Inc.
+000A69 SUNNY bell Technology Co., Ltd.
+000A6A SVM Microwaves s.r.o.
+000A6B Tadiran Telecom Business Systems LTD
+000A6C Walchem Corporation
+000A6D EKS Elektronikservice GmbH
+000A6E Broadcast Technology Limited
+000A6F ZyTera Technologies Inc.
+000A70 MPLS Forum
+000A71 Avrio Technologies, Inc
+000A72 SimpleTech, Inc.
+000A73 Scientific Atlanta
+000A74 Manticom Networks Inc.
+000A75 Cat Electronics
+000A76 Beida Jade Bird Huaguang Technology Co.,Ltd
+000A77 Bluewire Technologies LLC
+000A78 OLITEC
+000A79 corega K.K.
+000A7A Kyoritsu Electric Co., Ltd.
+000A7B Cornelius Consult
+000A7C Tecton Ltd
+000A7D Valo, Inc.
+000A7E The Advantage Group
+000A7F Teradon Industries, Inc
+000A80 Telkonet Inc.
+000A81 TEIMA Audiotex S.L.
+000A82 TATSUTA SYSTEM ELECTRONICS CO.,LTD.
+000A83 SALTO SYSTEMS S.L.
+000A84 Rainsun Enterprise Co., Ltd.
+000A85 PLAT'C2,Inc
+000A86 Lenze
+000A87 Integrated Micromachines Inc.
+000A88 InCypher S.A.
+000A89 Creval Systems, Inc.
+000A8A Cisco Systems
+000A8B Cisco Systems
+000A8C Guardware Systems Ltd.
+000A8D EUROTHERM LIMITED
+000A8E Invacom Ltd
+000A8F Aska International Inc.
+000A90 Bayside Interactive, Inc.
+000A91 HemoCue AB
+000A92 Presonus Corporation
+000A93 W2 Networks, Inc.
+000A94 ShangHai cellink CO., LTD
+000A95 Apple Computer, Inc.
+000A96 MEWTEL TECHNOLOGY INC.
+000A97 SONICblue, Inc.
+000A98 M+F Gwinner GmbH & Co
+000A99 Dataradio Inc.
+000A9A Aiptek International Inc
+000A9B Towa Meccs Corporation
+000A9C Server Technology, Inc.
+000A9D King Young Technology Co. Ltd.
+000A9E BroadWeb Corportation
+000A9F Pannaway Technologies, Inc.
+000AA0 Cedar Point Communications
+000AA1 V V S Limited
+000AA2 SYSTEK INC.
+000AA3 SHIMAFUJI ELECTRIC CO.,LTD.
+000AA4 SHANGHAI SURVEILLANCE TECHNOLOGY CO,LTD
+000AA5 MAXLINK INDUSTRIES LIMITED
+000AA6 Hochiki Corporation
+000AA7 FEI Company
+000AA8 ePipe Pty. Ltd.
+000AA9 Brooks Automation GmbH
+000AAA AltiGen Communications Inc.
+000AAB TOYOTA MACS, INC.
+000AAC TerraTec Electronic GmbH
+000AAD Stargames Corporation
+000AAE Rosemount Process Analytical
+000AAF Pipal Systems
+000AB0 LOYTEC electronics GmbH
+000AB1 GENETEC Corporation
+000AB2 Fresnel Wireless Systems
+000AB3 Fa. GIRA
+000AB4 ETIC Telecommunications
+000AB5 Digital Electronic Network
+000AB6 COMPUNETIX, INC
+000AB7 Cisco Systems
+000AB8 Cisco Systems
+000AB9 Astera Technologies Corp.
+000ABA Arcon Technology Limited
+000ABB Taiwan Secom Co,. Ltd
+000ABC Seabridge Ltd.
+000ABD Rupprecht & Patashnick Co.
+000ABE OPNET Technologies CO., LTD.
+000ABF HIROTA SS
+000AC0 Fuyoh Video Industry CO., LTD.
+000AC1 Futuretel
+000AC2 FiberHome Telecommunication Technologies CO.,LTD
+000AC3 eM Technics Co., Ltd.
+000AC4 Daewoo Teletech Co., Ltd
+000AC5 Color Kinetics
+000AC7 Unication Group
+000AC8 ZPSYS CO.,LTD. (Planning&Management)
+000AC9 Zambeel Inc
+000ACA YOKOYAMA SHOKAI CO.,Ltd.
+000ACB XPAK MSA Group
+000ACC Winnow Networks, Inc.
+000ACD Sunrich Technology Limited
+000ACE RADIANTECH, INC.
+000ACF PROVIDEO Multimedia Co. Ltd.
+000AD0 Niigata Develoment Center,  F.I.T. Co., Ltd.
+000AD1 MWS
+000AD2 JEPICO Corporation
+000AD3 INITECH Co., Ltd
+000AD4 CoreBell Systems Inc.
+000AD5 Brainchild Electronic Co., Ltd.
+000AD6 BeamReach Networks
+000AD8 IPCserv Technology Corp.
+000AD9 Sony Ericsson Mobile Communications AB
+000ADB SkyPilot Network, Inc
+000ADC RuggedCom Inc.
+000ADD InSciTek Microsystems, Inc.
+000ADE Happy Communication Co., Ltd.
+000ADF Gennum Corporation
+000AE0 Fujitsu Softek
+000AE1 EG Technology
+000AE2 Binatone Electronics International, Ltd
+000AE3 YANG MEI TECHNOLOGY CO., LTD
+000AE4 Wistron Corp.
+000AE5 ScottCare Corporation
+000AE6 Elitegroup Computer System Co. (ECS)
+000AE7 ELIOP S.A.
+000AE8 Cathay Roxus Information Technology Co. LTD
+000AE9 AirVast Technology Inc.
+000AEA ADAM ELEKTRONIK LTD.STI.
+000AEB Shenzhen Tp-link Technology Co; Ltd.
+000AEC Koatsu Gas Kogyo Co., Ltd.
+000AED HARTING Vending G.m.b.H. & CO KG
+000AEE GCD Hard- & Software GmbH
+000AEF OTRUM ASA
+000AF0 SHIN-OH ELECTRONICS CO., LTD. R&D
+000AF1 Clarity Design, Inc.
+000AF2 NeoAxiom Corp.
+000AF3 Cisco Systems
+000AF4 Cisco Systems
+000AF5 Airgo Networks, Inc.
+000AF6 Computer Process Controls
+000AF7 Broadcom Corp.
+000AF8 American Telecare Inc.
+000AFA Traverse Technologies Australia
+000AFB Ambri Limited
+000AFC Core Tec Communications, LLC
+000AFD Viking Electronic Services
+000AFE NovaPal Ltd
+000AFF Kilchherr Elektronik AG
+000B00 FUJIAN START COMPUTER EQUIPMENT CO.,LTD
+000B01 DAIICHI ELECTRONICS CO., LTD.
+000B02 Dallmeier electronic
+000B03 Taekwang Industrial Co., Ltd
+000B04 Volktek Corporation
+000B05 Pacific Broadband Networks
+000B06 Motorola BCS
+000B07 Voxpath Networks
+000B08 Pillar Data Systems
+000B09 Ifoundry Systems Singapore
+000B0A dBm Optics
+000B0B Corrent Corporation
+000B0C Agile Systems Inc.
+000B0D Air2U, Inc.
+000B0E Trapeze Networks
+000B0F Nyquist Industrial Control BV
+000B10 11wave Technonlogy Co.,Ltd
+000B11 HIMEJI ABC TRADING CO.,LTD.
+000B13 ZETRON INC
+000B14 ViewSonic Corporation
+000B15 Platypus Technology
+000B16 Communication Machinery Corporation
+000B17 MKS Instruments
+000B19 Vernier Networks, Inc.
+000B1A Teltone Corporation
+000B1B Systronix, Inc.
+000B1D LayerZero Power Systems, Inc.
+000B1E KAPPA opto-electronics GmbH
+000B1F I CON Computer Co.
+000B20 Hirata corporation
+000B21 G-Star Communications Inc.
+000B22 Environmental Systems and Services
+000B23 Efficient Networks, Inc.
+000B24 AirLogic
+000B25 Aeluros
+000B26 Wetek Corporation
+000B27 Scion Corporation
+000B28 Quatech Inc.
+000B29 LG Industrial Systems Co.,Ltd.
+000B2A HOWTEL Co., Ltd.
+000B2B HOSTNET CORPORATION
+000B2C Eiki Industrial Co. Ltd.
+000B2D Danfoss Inc.
+000B2E Cal-Comp Electronics (Thailand) Public Company Limited Taipe
+000B2F bplan GmbH
+000B30 Beijing Gongye Science & Technology Co.,Ltd
+000B31 Yantai ZhiYang Scientific and technology industry CO., LTD
+000B32 VORMETRIC, INC.
+000B33 Vivato
+000B34 ShangHai Broadband Technologies CO.LTD
+000B35 Quad Bit System co., Ltd.
+000B36 Productivity Systems, Inc.
+000B37 MANUFACTURE DES MONTRES ROLEX SA
+000B38 Knuerr AG
+000B39 Keisoku Giken Co.,Ltd.
+000B3A Fortel DTV, Inc.
+000B3B devolo AG
+000B3C Cygnal Integrated Products, Inc.
+000B3D CONTAL OK Ltd.
+000B3E BittWare, Inc
+000B3F Anthology Solutions Inc.
+000B40 OpNext Inc.
+000B41 Ing. Buero Dr. Beutlhauser
+000B42 commax Co., Ltd.
+000B43 Microscan Systems, Inc.
+000B44 Concord IDea Corp.
+000B45 Cisco
+000B46 Cisco
+000B47 Advanced Energy
+000B48 sofrel
+000B49 RF-Link System Inc.
+000B4A Visimetrics (UK) Ltd
+000B4B VISIOWAVE SA
+000B4C Clarion (M) Sdn Bhd
+000B4D Emuzed
+000B4E VertexRSI Antenna Products Division
+000B4F Verifone, INC.
+000B50 Oxygnet
+000B51 Micetek International Inc.
+000B52 JOYMAX ELECTRONICS CORP.
+000B53 INITIUM Co., Ltd.
+000B54 BiTMICRO Networks, Inc.
+000B55 ADInstruments
+000B56 Cybernetics
+000B57 Silicon Laboratories
+000B58 Astronautics C.A  LTD
+000B59 ScriptPro, LLC
+000B5A HyperEdge
+000B5B Rincon Research Corporation
+000B5C Newtech Co.,Ltd
+000B5D FUJITSU LIMITED
+000B5E ATMAVA Ltd
+000B5F Cisco Systems
+000B60 Cisco Systems
+000B61 Friedrich Ltze GmbH &Co.
+000B62 Ingenieurbro Ingo Mohnen
+000B64 Kieback & Peter GmbH & Co KG
+000B65 Sy.A.C. srl
+000B66 Teralink Communications
+000B67 Topview Technology Corporation
+000B68 Addvalue Communications Pte Ltd
+000B69 Franke Finland Oy
+000B6A Asiarock Incorporation
+000B6B Wistron Neweb Corp.
+000B6C Sychip Inc.
+000B6D SOLECTRON JAPAN NAKANIIDA
+000B6E Neff Instrument Corp.
+000B6F Media Streaming Networks Inc
+000B70 Load Technology, Inc.
+000B71 Litchfield Communications Inc.
+000B72 Lawo AG
+000B73 Kodeos Communications
+000B74 Kingwave Technology Co., Ltd.
+000B75 Iosoft Ltd.
+000B76 ET&T Co. Ltd.
+000B77 Cogent Systems, Inc.
+000B78 TAIFATECH INC.
+000B79 X-COM, Inc.
+000B7B Test-Um Inc.
+000B7C Telex Communications
+000B7D SOLOMON EXTREME INTERNATIONAL LTD.
+000B7E SAGINOMIYA Seisakusho Inc.
+000B7F OmniWerks
+000B81 Kaparel Corporation
+000B82 Grandstream Networks, Inc.
+000B83 DATAWATT B.V.
+000B84 BODET
+000B85 Airespace, Inc.
+000B86 Aruba Networks
+000B87 American Reliance Inc.
+000B88 Vidisco ltd.
+000B89 Top Global Technology, Ltd.
+000B8A MITEQ Inc.
+000B8B KERAJET, S.A.
+000B8C flextronics israel
+000B8D Avvio Networks
+000B8E Ascent Corporation
+000B8F AKITA ELECTRONICS SYSTEMS CO.,LTD.
+000B90 Covaro Networks, Inc.
+000B91 Aglaia Gesellschaft fr Bildverarbeitung und Kommunikation m
+000B92 Ascom Danmark A/S
+000B93 Barmag Electronic
+000B94 Digital Monitoring Products, Inc.
+000B95 eBet Gaming Systems Pty Ltd
+000B96 Innotrac Diagnostics Oy
+000B97 Matsushita Electric Industrial Co.,Ltd.
+000B98 NiceTechVision
+000B99 SensAble Technologies, Inc.
+000B9A Shanghai Ulink Telecom Equipment Co. Ltd.
+000B9B Sirius System Co, Ltd.
+000B9C TriBeam Technologies, Inc.
+000B9D TwinMOS Technologies Inc.
+000B9E Yasing Technology Corp.
+000B9F Neue ELSA GmbH
+000BA0 T&L Information Inc.
+000BA1 SYSCOM Ltd.
+000BA2 Sumitomo Electric Networks, Inc
+000BA3 Siemens AG, I&S
+000BA4 Shiron Satellite Communications Ltd. (1996)
+000BA5 Quasar Cipta Mandiri, PT
+000BA6 Miyakawa Electric Works Ltd.
+000BA7 Maranti Networks
+000BA8 HANBACK ELECTRONICS CO., LTD.
+000BAA Aiphone co.,Ltd
+000BAB Advantech Technology (CHINA) Co., Ltd.
+000BAC 3Com Europe Ltd.
+000BAD PC-PoS Inc.
+000BAE Vitals System Inc.
+000BB0 Sysnet Telematica srl
+000BB1 Super Star Technology Co., Ltd.
+000BB2 SMALLBIG TECHNOLOGY
+000BB3 RiT technologies Ltd.
+000BB4 RDC Semiconductor Inc.,
+000BB5 nStor Technologies, Inc.
+000BB6 Mototech Inc.
+000BB7 Micro Systems Co.,Ltd.
+000BB8 Kihoku Electronic Co.
+000BB9 Imsys AB
+000BBA Harmonic Broadband Access Networks
+000BBB Etin Systems Co., Ltd
+000BBC En Garde Systems, Inc.
+000BBD Connexionz Limited
+000BBE Cisco Systems
+000BBF Cisco Systems
+000BC0 China IWNComm Co., Ltd.
+000BC1 Bay Microsystems, Inc.
+000BC2 Corinex Communication Corp.
+000BC3 Multiplex, Inc.
+000BC4 BIOTRONIK GmbH & Co
+000BC5 SMC Networks, Inc.
+000BC6 ISAC, Inc.
+000BC7 ICET S.p.A.
+000BC8 AirFlow Networks
+000BC9 Electroline Equipment
+000BCA DATAVAN International Corporation
+000BCB Fagor Automation , S. Coop
+000BCC JUSAN, S.A.
+000BCD Compaq (HP)
+000BCE Free2move AB
+000BCF AGFA NDT INC.
+000BD0 XiMeta Technology Americas Inc.
+000BD1 Aeronix, Inc.
+000BD2 Remopro Technology Inc.
+000BD3 cd3o
+000BD4 Beijing Wise Technology & Science Development Co.Ltd
+000BD5 Nvergence, Inc.
+000BD6 Paxton Access Ltd
+000BD7 MBB Gelma GmbH
+000BD8 Industrial Scientific Corp.
+000BD9 General Hydrogen
+000BDA EyeCross Co.,Inc.
+000BDB Dell ESG PCBA Test
+000BDC AKCP
+000BDD TOHOKU RICOH Co., LTD.
+000BDF Shenzhen RouterD Networks Limited
+000BE0 SercoNet Ltd.
+000BE2 Lumenera Corporation
+000BE3 Key Stream Co., Ltd.
+000BE4 Hosiden Corporation
+000BE5 HIMS Korea Co., Ltd.
+000BE6 Datel Electronics
+000BE7 COMFLUX TECHNOLOGY INC.
+000BE8 AOIP
+000BEA Zultys Technologies
+000BEB Systegra AG
+000BEC NIPPON ELECTRIC INSTRUMENT, INC.
+000BED ELM Inc.
+000BEE inc.jet, Incorporated
+000BEF Code Corporation
+000BF0 MoTEX Products Co., Ltd.
+000BF1 LAP Laser Applikations
+000BF2 Chih-Kan Technology Co., Ltd.
+000BF3 BAE SYSTEMS
+000BF5 Shanghai Sibo Telecom Technology Co.,Ltd
+000BF6 Nitgen Co., Ltd
+000BF7 NIDEK CO.,LTD
+000BF8 Infinera
+000BF9 Gemstone communications, Inc.
+000BFB D-NET International Corporation
+000BFC Cisco Systems
+000BFD Cisco Systems
+000BFE CASTEL Broadband Limited
+000BFF Berkeley Camera Engineering
+000C00 BEB Industrie-Elektronik AG
+000C01 Abatron AG
+000C02 ABB Oy
+000C03 HDMI Licensing, LLC
+000C04 Tecnova
+000C05 RPA Reserch Co., Ltd.
+000C06 Nixvue Systems  Pte Ltd
+000C07 Iftest AG
+000C08 HUMEX Technologies Corp.
+000C09 Hitachi IE Systems Co., Ltd
+000C0A Guangdong Province Electronic Technology Research Institute
+000C0B Broadbus Technologies
+000C0C APPRO TECHNOLOGY INC.
+000C0D Communications & Power Industries / Satcom Division
+000C0E XtremeSpectrum, Inc.
+000C0F Techno-One Co., Ltd
+000C10 PNI Corporation
+000C11 NIPPON DEMPA CO.,LTD.
+000C12 Micro-Optronic-Messtechnik GmbH
+000C13 MediaQ
+000C14 Diagnostic Instruments, Inc.
+000C15 CyberPower Systems, Inc.
+000C16 Concorde Microsystems Inc.
+000C17 AJA Video Systems Inc
+000C18 Zenisu Keisoku Inc.
+000C19 Telio Communications GmbH
+000C1A Quest Technical Solutions Inc.
+000C1B ORACOM Co, Ltd.
+000C1C MicroWeb Co., Ltd.
+000C1D Mettler & Fuchs AG
+000C1E Global Cache
+000C1F Glimmerglass Networks
+000C20 Fi WIn, Inc.
+000C21 Faculty of Science and Technology, Keio University
+000C22 Double D Electronics Ltd
+000C23 Beijing Lanchuan Tech. Co., Ltd.
+000C25 Allied Telesyn Networks
+000C26 Weintek Labs. Inc.
+000C27 Sammy Corporation
+000C28 RIFATRON
+000C29 VMware, Inc.
+000C2A OCTTEL Communication Co., Ltd.
+000C2B ELIAS Technology, Inc.
+000C2C Enwiser Inc.
+000C2D FullWave Technology Co., Ltd.
+000C2E Openet information technology(shenzhen) Co., Ltd.
+000C2F SeorimTechnology Co.,Ltd.
+000C30 Cisco
+000C31 Cisco
+000C32 Avionic Design Development GmbH
+000C33 Compucase Enterprise Co. Ltd.
+000C34 Vixen Co., Ltd.
+000C35 KaVo Dental GmbH & Co. KG
+000C36 SHARP TAKAYA ELECTRONICS INDUSTRY CO.,LTD.
+000C37 Geomation, Inc.
+000C38 TelcoBridges Inc.
+000C39 Sentinel Wireless Inc.
+000C3A Oxance
+000C3B Orion Electric Co., Ltd.
+000C3C MediaChorus, Inc.
+000C3D Glsystech Co., Ltd.
+000C3E Crest Audio
+000C3F Cogent Defence & Security Networks,
+000C40 Altech Controls
+000C41 The Linksys Group, Inc.
+000C42 Routerboard.com
+000C43 Ralink Technology, Corp.
+000C44 Automated Interfaces, Inc.
+000C45 Animation Technologies Inc.
+000C46 Allied Telesyn Inc.
+000C47 SK Teletech(R&D Planning Team)
+000C48 QoStek Corporation
+000C49 Dangaard Telecom RTC Division A/S
+000C4A Cygnus Microsystems Private Limited
+000C4B Cheops Elektronik
+000C4C Arcor AG&Co.
+000C4D ACRA CONTROL
+000C4E Winbest Technology CO,LT
+000C4F UDTech Japan Corporation
+000C50 Seagate Technology
+000C51 Scientific Technologies Inc.
+000C52 Roll Systems Inc.
+000C54 Pedestal Networks, Inc
+000C55 Microlink Communications Inc.
+000C56 Megatel Computer (1986) Corp.
+000C57 MACKIE Engineering Services Belgium BVBA
+000C58 M&S Systems
+000C59 Indyme Electronics, Inc.
+000C5A IBSmm Industrieelektronik Multimedia
+000C5B HANWANG TECHNOLOGY CO.,LTD
+000C5C GTN Systems B.V.
+000C5D CHIC TECHNOLOGY (CHINA) CORP.
+000C5F Avtec, Inc.
+000C60 ACM Systems
+000C61 AC Tech corporation DBA Advanced Digital
+000C62 ABB Automation Technology Products AB, Control
+000C63 Zenith Electronics Corporation
+000C64 X2 MSA Group
+000C65 Sunin Telecom
+000C66 Pronto Networks Inc
+000C67 OYO ELECTRIC CO.,LTD
+000C68 Oasis Semiconductor, Inc.
+000C69 National Radio Astronomy Observatory
+000C6A MBARI
+000C6B Kurz Industrie-Elektronik GmbH
+000C6C Elgato Systems LLC
+000C6D BOC Edwards
+000C6E ASUSTEK COMPUTER INC.
+000C6F Amtek system co.,LTD.
+000C70 ACC GmbH
+000C71 Wybron, Inc
+000C72 Tempearl Industrial Co., Ltd.
+000C73 TELSON ELECTRONICS CO., LTD
+000C74 RIVERTEC CORPORATION
+000C75 Oriental integrated electronics. LTD
+000C76 MICRO-STAR INTERNATIONAL CO., LTD.
+000C77 Life Racing Ltd
+000C78 In-Tech Electronics Limited
+000C79 Extel Communications P/L
+000C7A DaTARIUS Technologies GmbH
+000C7B ALPHA PROJECT Co.,Ltd.
+000C7C Internet Information Image Inc.
+000C7D TEIKOKU ELECTRIC MFG. CO., LTD
+000C7E Tellium Incorporated
+000C7F synertronixx GmbH
+000C80 Opelcomm Inc.
+000C81 Nulec Industries Pty Ltd
+000C82 NETWORK TECHNOLOGIES INC
+000C83 Logical Solutions
+000C84 Eazix, Inc.
+000C85 Cisco Systems
+000C86 Cisco Systems
+000C87 ATI
+000C88 Apache Micro Peripherals, Inc.
+000C89 AC Electric Vehicles, Ltd.
+000C8A Bose Corporation
+000C8B Connect Tech Inc
+000C8C KODICOM CO.,LTD.
+000C8D MATRIX VISION GmbH
+000C8E Mentor Engineering Inc
+000C8F Nergal s.r.l.
+000C90 Octasic Inc.
+000C91 Riverhead Networks Inc.
+000C92 WolfVision Gmbh
+000C93 Xeline Co., Ltd.
+000C94 United Electronic Industries, Inc.
+000C95 PrimeNet
+000C96 OQO, Inc.
+000C97 NV ADB TTV Technologies SA
+000C98 LETEK Communications Inc.
+000C99 HITEL LINK Co.,Ltd
+000C9A Hitech Electronics Corp.
+000C9B EE Solutions, Inc
+000C9C Chongho information & communications
+000C9D AirWalk Communications, Inc.
+000C9E MemoryLink Corp.
+000C9F NKE Corporation
+000CA0 StorCase Technology, Inc.
+000CA1 SIGMACOM Co., LTD.
+000CA2 Scopus Network Technologies Ltd
+000CA3 Rancho Technology, Inc.
+000CA4 Prompttec Product Management GmbH
+000CA6 Mintera Corporation
+000CA7 Metro (Suzhou) Technologies Co., Ltd.
+000CA8 Garuda Networks Corporation
+000CA9 Ebtron Inc.
+000CAA Cubic Transportation Systems Inc
+000CAB COMMEND International
+000CAC Citizen Watch Co., Ltd.
+000CAD BTU International
+000CAE Ailocom Oy
+000CAF TRI TERM CO.,LTD.
+000CB0 Star Semiconductor Corporation
+000CB1 Salland Engineering (Europe) BV
+000CB2 safei Co., Ltd.
+000CB3 ROUND Co.,Ltd.
+000CB4 Propagate Networks, Inc
+000CB5 Premier Technolgies, Inc
+000CB6 NANJING SEU MOBILE & INTERNET TECHNOLOGY CO.,LTD
+000CB7 Nanjing Huazhuo Electronics Co., Ltd.
+000CB8 MEDION AG
+000CB9 LEA
+000CBA Jamex
+000CBB ISKRAEMECO
+000CBC Iscutum
+000CBD Interface Masters, Inc
+000CBF Holy Stone Ent. Co., Ltd.
+000CC0 Genera Oy
+000CC1 Cooper Industries Inc.
+000CC3 BeWAN systems
+000CC4 Tiptel AG
+000CC5 Nextlink Co., Ltd.
+000CC6 Ka-Ro electronics GmbH
+000CC7 Intelligent Computer Solutions Inc.
+000CC8 Integrated Digital Systems, Inc.
+000CC9 ILWOO DATA & TECHNOLOGY CO.,LTD
+000CCA Hitachi Global Storage Technologies
+000CCB Design Combus Ltd
+000CCC Bluesoft Ltd.
+000CCD IEC - TC57
+000CCE Cisco Systems
+000CCF Cisco Systems
+000CD0 Symetrix
+000CD1 SFOM Technology Corp.
+000CD2 Schaffner EMV AG
+000CD3 Prettl Elektronik Radeberg GmbH
+000CD4 Positron Public Safety Systems inc.
+000CD5 Passave Inc.
+000CD6 PARTNER TECH
+000CD7 Nallatech Ltd
+000CD8 M. K. Juchheim GmbH & Co
+000CD9 Itcare Co., Ltd
+000CDA FreeHand Systems, Inc.
+000CDB Foundry Networks
+000CDC BECS Technology, Inc
+000CDD AOS Technologies AG
+000CDE ABB STOTZ-KONTAKT GmbH
+000CDF PULNiX America, Inc
+000CE0 Trek Diagnostics Inc.
+000CE1 The Open Group
+000CE2 Rolls-Royce
+000CE3 Option International N.V.
+000CE4 NeuroCom International, Inc.
+000CE5 Motorola BCS
+000CE6 Meru Networks Inc
+000CE7 MediaTek Inc.
+000CE8 GuangZhou AnJuBao Co., Ltd
+000CE9 BLOOMBERG L.P.
+000CEA aphona Kommunikationssysteme
+000CEB CNMP Networks, Inc.
+000CEC Spectracom Corp.
+000CED Real Digital Media
+000CEE Q-Networks
+000CEF Open Networks Engineering Ltd
+000CF0 M & N GmbH
+000CF1 Intel Corporation
+000CF2 GAMESA ELICA
+000CF3 CALL IMAGE SA
+000CF4 AKATSUKI ELECTRIC MFG.CO.,LTD.
+000CF5 InfoExpress
+000CF6 Sitecom Europe BV
+000CF7 Nortel Networks
+000CF8 Nortel Networks
+000CF9 ITT Flygt AB
+000CFA Digital Systems Corp
+000CFB Korea Network Systems
+000CFC S2io Technologies Corp
+000CFE Grand Electronic Co., Ltd
+000CFF MRO-TEK LIMITED
+000D00 Seaway Networks Inc.
+000D01 P&E Microcomputer Systems, Inc.
+000D02 NEC Access Technica,Ltd
+000D03 Matrics, Inc.
+000D04 Foxboro Eckardt Development GmbH
+000D05 cybernet manufacturing inc.
+000D06 Compulogic Limited
+000D07 Calrec Audio Ltd
+000D08 AboveCable, Inc.
+000D09 Yuehua(Zhuhai) Electronic CO. LTD
+000D0A Projectiondesign as
+000D0B Melco Inc.
+000D0C MDI Security Systems
+000D0D ITSupported, LLC
+000D0E Inqnet Systems, Inc.
+000D0F Finlux Ltd
+000D10 Embedtronics Oy
+000D11 DENTSPLY - Gendex
+000D12 AXELL Corporation
+000D13 Wilhelm Rutenbeck GmbH&Co.
+000D14 Vtech Innovation LP dba Advanced American Telephones
+000D15 Voipac s.r.o.
+000D16 UHS Systems Pty Ltd
+000D17 Turbo Networks Co.Ltd
+000D18 Sunitec Enterprise Co., Ltd.
+000D19 ROBE Show lighting
+000D1A Mustek System Inc.
+000D1B Kyoto Electronics Manufacturing Co., Ltd.
+000D1C I2E TELECOM
+000D1D HIGH-TEK HARNESS ENT. CO., LTD.
+000D1E Control Techniques
+000D1F AV Digital
+000D20 ASAHIKASEI TECHNOSYSTEM CO.,LTD.
+000D21 WISCORE Inc.
+000D22 Unitronics
+000D23 Smart Solution, Inc
+000D24 SENTEC E&E CO., LTD.
+000D25 SANDEN CORPORATION
+000D26 Primagraphics Limited
+000D27 MICROPLEX Printware AG
+000D28 Cisco
+000D29 Cisco
+000D2A Scanmatic AS
+000D2B Racal Instruments
+000D2C Patapsco Designs Ltd
+000D2D NCT Deutschland GmbH
+000D2E Matsushita Avionics Systems Corporation
+000D2F AIN Comm.Tech.Co., LTD
+000D30 IceFyre Semiconductor
+000D31 Compellent Technologies, Inc.
+000D32 DispenseSource, Inc.
+000D33 Prediwave Corp.
+000D34 Shell International Exploration and Production, Inc.
+000D35 PAC International Ltd
+000D36 Wu Han Routon Electronic Co., Ltd
+000D37 WIPLUG
+000D38 NISSIN INC.
+000D39 Network Electronics
+000D3A Microsoft Corp.
+000D3B Microelectronics Technology Inc.
+000D3C i.Tech Dynamic Ltd
+000D3E APLUX Communications Ltd.
+000D3F VXI Technology
+000D40 Verint Loronix Video Solutions
+000D41 Siemens AG ICM MP UC RD IT KLF1
+000D42 Newbest Development Limited
+000D43 DRS Tactical Systems Inc.
+000D45 Tottori SANYO Electric Co., Ltd.
+000D46 Eurotherm Drives, Ltd.
+000D47 Collex
+000D48 AEWIN Technologies Co., Ltd.
+000D49 Triton Systems of Delaware, Inc.
+000D4A Steag ETA-Optik
+000D4B Roku, LLC
+000D4C Outline Electronics Ltd.
+000D4D Ninelanes
+000D4E NDR Co.,LTD.
+000D4F Kenwood Corporation
+000D50 Galazar Networks
+000D51 DIVR Systems, Inc.
+000D52 Comart system
+000D53 Beijing 5w Communication Corp.
+000D54 3Com Europe Ltd
+000D55 SANYCOM Technology Co.,Ltd
+000D56 Dell PCBA Test
+000D57 Fujitsu I-Network Systems Limited.
+000D59 Amity Systems, Inc.
+000D5A Tiesse SpA
+000D5B Smart Empire Investments Limited
+000D5C Robert Bosch GmbH, VT-ATMO
+000D5D Raritan Computer, Inc
+000D5E NEC CustomTechnica, Ltd.
+000D5F Minds Inc
+000D60 IBM Corporation
+000D61 Giga-Byte Technology Co., Ltd.
+000D62 Funkwerk Dabendorf GmbH
+000D63 DENT Instruments, Inc.
+000D64 COMAG Handels AG
+000D65 Cisco Systems
+000D66 Cisco Systems
+000D67 BelAir Networks Inc.
+000D68 Vinci Systems, Inc.
+000D69 TMT&D Corporation
+000D6A Redwood Technologies LTD
+000D6B Mita-Teknik A/S
+000D6C M-Audio
+000D6D K-Tech Devices Corp.
+000D6E K-Patents Oy
+000D6F Ember Corporation
+000D70 Datamax Corporation
+000D71 boca systems
+000D72 2Wire, Inc
+000D73 Technical Support, Inc.
+000D74 Sand Network Systems, Inc.
+000D75 Kobian Pte Ltd - Taiwan Branch
+000D76 Hokuto Denshi Co,. Ltd.
+000D77 FalconStor Software
+000D78 Engineering & Security
+000D79 Dynamic Solutions Co,.Ltd.
+000D7A DiGATTO Asia Pacific Pte Ltd
+000D7B Consensys Computers Inc.
+000D7C Codian Ltd
+000D7D Afco Systems
+000D7E Axiowave Networks, Inc.
+000D7F MIDAS  COMMUNICATION TECHNOLOGIES PTE LTD ( Foreign Branch)
+000D80 Online Development Inc
+000D81 Pepperl+Fuchs GmbH
+000D82 PHS srl
+000D83 Sanmina-SCI Hungary  Ltd.
+000D84 Seodu Inchip, Inc.
+000D85 Tapwave, Inc.
+000D86 Huber + Suhner AG
+000D87 Elitegroup Computer System Co. (ECS)
+000D88 D-Link Corporation
+000D89 Bils Technology Inc
+000D8A Winners Electronics Co., Ltd.
+000D8B T&D Corporation
+000D8C Shanghai Wedone Digital Ltd. CO.
+000D8D ProLinx Communication Gateways, Inc.
+000D8E Koden Electronics Co., Ltd.
+000D8F King Tsushin Kogyo Co., LTD.
+000D90 Factum Electronics AB
+000D91 Eclipse (HQ Espana) S.L.
+000D92 Arima Communication Corporation
+000D93 Apple Computer
+000D94 AFAR Communications,Inc
+000D96 Vtera Technology Inc.
+000D97 Tropos Networks, Inc.
+000D98 S.W.A.C. Schmitt-Walter Automation Consult GmbH
+000D99 Orbital Sciences Corp.; Launch Systems Group
+000D9A INFOTEC LTD
+000D9C Elan GmbH & Co KG
+000D9D Hewlett Packard
+000D9E TOKUDEN OHIZUMI SEISAKUSYO Co.,Ltd.
+000D9F RF Micro Devices
+000DA0 NEDAP N.V.
+000DA1 MIRAE ITS Co.,LTD.
+000DA2 Infrant Technologies, Inc.
+000DA3 Emerging Technologies Limited
+000DA4 DOSCH & AMAND SYSTEMS AG
+000DA5 Fabric7 Systems, Inc
+000DA6 Universal Switching Corporation
+000DA8 Teletronics Technology Corporation
+000DA9 T.E.A.M. S.L.
+000DAA S.A.Tehnology co.,Ltd.
+000DAB Parker Hannifin GmbH Electromechanical Division Europe
+000DAC Japan CBM Corporation
+000DAD Dataprobe Inc
+000DAE SAMSUNG HEAVY INDUSTRIES CO., LTD.
+000DAF Plexus Corp (UK) Ltd
+000DB0 Olym-tech Co.,Ltd.
+000DB1 Japan Network Service Co., Ltd.
+000DB2 Ammasso, Inc.
+000DB3 SDO Communication Corperation
+000DB4 NETASQ
+000DB5 GLOBALSAT TECHNOLOGY CORPORATION
+000DB6 Teknovus, Inc.
+000DB7 SANKO ELECTRIC CO,.LTD
+000DB8 SCHILLER AG
+000DB9 PC Engines GmbH
+000DBA Oc Document Technologies GmbH
+000DBB Nippon Dentsu Co.,Ltd.
+000DBC Cisco Systems
+000DBD Cisco Systems
+000DBE Bel Fuse Europe Ltd.,UK
+000DBF TekTone Sound & Signal Mfg., Inc.
+000DC0 Spagat AS
+000DC1 SafeWeb Inc
+000DC3 First Communication, Inc.
+000DC4 Emcore Corporation
+000DC5 EchoStar International Corporation
+000DC6 DigiRose Technology Co., Ltd.
+000DC7 COSMIC ENGINEERING INC.
+000DC8 AirMagnet, Inc
+000DC9 THALES Elektronik Systeme GmbH
+000DCA Tait Electronics
+000DCB Petcomkorea Co., Ltd.
+000DCC NEOSMART Corp.
+000DCD GROUPE TXCOM
+000DCE Dynavac Technology Pte Ltd
+000DCF Cidra Corp.
+000DD0 TetraTec Instruments GmbH
+000DD1 Stryker Corporation
+000DD2 Simrad Optronics ASA
+000DD3 SAMWOO Telecommunication Co.,Ltd.
+000DD4 Revivio Inc.
+000DD5 O'RITE TECHNOLOGY CO.,LTD
+000DD7 Bright
+000DD8 BBN
+000DD9 Anton Paar GmbH
+000DDA ALLIED TELESIS K.K.
+000DDB AIRWAVE TECHNOLOGIES INC.
+000DDC VAC
+000DDD PROFLO TELRA ELEKTRONK SANAY VE TCARET A..
+000DDE Joyteck Co., Ltd.
+000DDF Japan Image & Network Inc.
+000DE0 ICPDAS Co.,LTD
+000DE1 Control Products, Inc.
+000DE2 CMZ Sistemi Elettronici
+000DE3 AT Sweden AB
+000DE4 DIGINICS, Inc.
+000DE5 Samsung Thales
+000DE6 YOUNGBO ENGINEERING CO.,LTD
+000DE7 Snap-on OEM Group
+000DE8 Nasaco Electronics Pte. Ltd
+000DE9 Napatech Aps
+000DEA Kingtel Telecommunication Corp.
+000DEB CompXs Limited
+000DEC Cisco Systems
+000DED Cisco Systems
+000DEF Soc. Coop. Bilanciai
+000DF0 QCOM TECHNOLOGY INC.
+000DF1 IONIX INC.
+000DF3 Asmax Solutions
+000DF4 Watertek Co.
+000DF5 Teletronics International Inc.
+000DF6 Technology Thesaurus Corp.
+000DF7 Space Dynamics Lab
+000DF8 ORGA Kartensysteme GmbH
+000DF9 NDS Limited
+000DFA Micro Control Systems Ltd.
+000DFB Komax AG
+000DFC ITFOR Inc. resarch and development
+000DFD Huges Hi-Tech Inc.,
+000DFE Hauppauge Computer Works, Inc.
+000DFF CHENMING MOLD INDUSTRY CORP.
+000E01 ASIP Technologies Inc.
+000E02 Advantech AMT Inc.
+000E03 Aarohi Communications, Inc.
+000E05 WIRELESS MATRIX CORP.
+000E06 Team Simoco Ltd
+000E07 Sony Ericsson Mobile Communications AB
+000E08 Sipura Technology, Inc.
+000E09 Shenzhen Coship Software Co.,LTD.
+000E0B Netac Technology Co., Ltd.
+000E0C Intel Corporation
+000E0D HESCH Schrder GmbH
+000E0E ESA elettronica S.P.A.
+000E0F ERMME
+000E11 BDT Bro- und Datentechnik GmbH & Co. KG
+000E12 Adaptive Micro Systems Inc.
+000E13 Accu-Sort Systems inc.
+000E14 Visionary Solutions, Inc.
+000E15 Tadlys LTD
+000E16 SouthWing
+000E18 MyA Technology
+000E19 LogicaCMG Pty Ltd
+000E1B IAV GmbH
+000E1C Hach Company
+000E1F TCL Networks Equipment Co., Ltd.
+000E20 PalmSource, Inc.
+000E21 MTU Friedrichshafen GmbH
+000E23 Incipient, Inc.
+000E25 Hannae Technology Co., Ltd
+000E26 Gincom Technology Corp.
+000E27 Crere Networks, Inc.
+000E28 Dynamic Ratings P/L
+000E29 Shester Communications Inc
+000E2B Safari Technologies
+000E2C Netcodec co.
+000E2D Hyundai Digital Technology Co.,Ltd.
+000E2E Edimax Technology Co., Ltd.
+000E2F Disetronic Medical Systems AG
+000E30 AERAS Networks, Inc.
+000E31 Olympus BioSystems GmbH
+000E32 Kontron Medical
+000E33 Shuko Electronics Co.,Ltd
+000E34 NexxGenCity
+000E35 Intel Corp
+000E36 HEINESYS, Inc.
+000E37 Harms & Wende GmbH & Co.KG
+000E38 Cisco Systems
+000E39 Cisco Systems
+000E3A Cirrus Logic
+000E3B Hawking Technologies, Inc.
+000E3C TransAct Technoloiges Inc.
+000E3D Televic N.V.
+000E3E Sun Optronics Inc
+000E3F Soronti, Inc.
+000E40 Nortel Networks
+000E41 NIHON MECHATRONICS CO.,LTD.
+000E42 Motic Incoporation Ltd.
+000E43 G-Tek Electronics Sdn. Bhd.
+000E44 Digital 5, Inc.
+000E45 Beijing Newtry Electronic Technology Ltd
+000E46 Niigata Seimitsu Co.,Ltd.
+000E47 NCI System Co.,Ltd.
+000E48 Lipman TransAction Solutions
+000E49 Forsway Scandinavia AB
+000E4A Changchun Huayu WEBPAD Co.,LTD
+000E4B atrium c and i
+000E4C Bermai Inc.
+000E4D Numesa Inc.
+000E4E Waveplus Technology Co., Ltd.
+000E4F Trajet GmbH
+000E50 Thomson Multi Media
+000E51 tecna elettronica srl
+000E52 Optium Corporation
+000E53 AV TECH CORPORATION
+000E54 AlphaCell Wireless Ltd.
+000E55 AUVITRAN
+000E56 4G Systems GmbH
+000E57 Iworld Networking, Inc.
+000E58 Rincon Networks
+000E5A TELEFIELD inc.
+000E5B ParkerVision - Direct2Data
+000E5C Motorola BCS
+000E5D Com-X Networks
+000E5E Beijing Raisecom Science & Technology Development Co.,Ltd
+000E5F activ-net GmbH & Co. KG
+000E60 360SUN Digital Broadband Corporation
+000E61 MICROTROL LIMITED
+000E62 Nortel Networks
+000E63 Lemke Diagnostics GmbH
+000E64 Elphel, Inc
+000E65 TransCore
+000E66 Hitachi Advanced Digital, Inc.
+000E67 Eltis Microelectronics Ltd.
+000E68 E-TOP Network Technology Inc.
+000E69 China Electric Power Research Institute
+000E6A 3COM EUROPE LTD
+000E6B Janitza electronics GmbH
+000E6C Device Drivers Limited
+000E6D Murata Manufacturing Co., Ltd.
+000E6E MICRELEC  ELECTRONICS S.A
+000E6F IRIS Corporation Berhad
+000E70 in2 Networks
+000E71 Gemstar Technology Development Ltd.
+000E72 CTS electronics
+000E73 Tpack A/S
+000E74 Solar Telecom. Tech
+000E75 New York Air Brake Corp.
+000E76 GEMSOC INNOVISION INC.
+000E77 Decru, Inc.
+000E78 Amtelco
+000E79 Ample Communications Inc.
+000E7B Toshiba
+000E7D Electronics Line 3000 Ltd.
+000E7E Comprog Oy
+000E7F Hewlett Packard
+000E81 Instant802 Networks Inc.
+000E82 Commtech Wireless
+000E83 Cisco Systems
+000E84 Cisco Systems
+000E85 Catalyst Enterprises, Inc.
+000E86 Alcatel North America
+000E87 adp Gauselmann GmbH
+000E88 VIDEOTRON CORP.
+000E89 CLEMATIC
+000E8A Avara Technologies Pty. Ltd.
+000E8B Astarte Technology Co, Ltd.
+000E8C Siemens AG A&D ET
+000E8D Systems in Progress Holding GmbH
+000E8E SparkLAN Communications, Inc.
+000E8F Sercomm Corp.
+000E90 PONICO CORP.
+000E92 Millinet Co., Ltd.
+000E93 Milnio 3 Sistemas Electrnicos, Lda.
+000E94 Maas International BV
+000E95 Fujiya Denki Seisakusho Co.,Ltd.
+000E96 Cubic Defense Applications, Inc.
+000E97 Ultracker Technology CO., Inc
+000E98 Vitec CC, INC.
+000E99 Spectrum Digital, Inc
+000E9A BOE TECHNOLOGY GROUP CO.,LTD
+000E9C Pemstar
+000E9D Video Networks Ltd
+000E9E Topfield Co., Ltd
+000E9F TEMIC SDS GmbH
+000EA0 NetKlass Technology Inc.
+000EA1 Formosa Teletek Corporation
+000EA2 CyberGuard Corporation
+000EA3 CNCR-IT CO.,LTD,HangZhou P.R.CHINA
+000EA4 Certance Inc.
+000EA5 BLIP Systems
+000EA6 ASUSTEK COMPUTER INC.
+000EA7 Endace Inc Ltd.
+000EA8 United Technologists Europe Limited
+000EA9 Shanghai Xun Shi Communications Equipment Ltd. Co.
+000EAC MINTRON ENTERPRISE CO., LTD.
+000EAD Metanoia Technologies, Inc.
+000EAE GAWELL TECHNOLOGIES CORP.
+000EAF CASTEL
+000EB0 Solutions Radio BV
+000EB1 Newcotech,Ltd
+000EB2 Micro-Research Finland Oy
+000EB3 LeftHand Networks
+000EB4 GUANGZHOU GAOKE COMMUNICATIONS TECHNOLOGY CO.LTD.
+000EB5 Ecastle Electronics Co., Ltd.
+000EB6 Riverbed Technology, Inc.
+000EB7 Knovative, Inc.
+000EB8 Iiga co.,Ltd
+000EB9 HASHIMOTO Electronics Industry Co.,Ltd.
+000EBA HANMI SEMICONDUCTOR CO., LTD.
+000EBB Everbee Networks
+000EBC Cullmann GmbH
+000EBD Burdick, a Quinton Compny
+000EBE B&B Electronics Manufacturing Co.
+000EC0 Nortel Networks
+000EC1 MYNAH Technologies
+000EC2 Lowrance Electronics, Inc.
+000EC3 Logic Controls, Inc.
+000EC4 Iskra Transmission d.d.
+000EC6 ASIX ELECTRONICS CORP.
+000EC7 Appeal Telecom Co.,Ltd.
+000EC8 Zoran Corporation
+000EC9 YOKO Technology Corp.
+000ECB VineSys Technology
+000ECC Tableau
+000ECD SKOV A/S
+000ECE S.I.T.T.I. S.p.A.
+000ECF PROFIBUS Nutzerorganisation e.V.
+000ED0 Privaris, Inc.
+000ED1 Osaka Micro Computer.
+000ED2 Filtronic plc
+000ED3 Epicenter, Inc.
+000ED4 CRESITT INDUSTRIE
+000ED5 COPAN Systems Inc.
+000ED6 Cisco Systems
+000ED7 Cisco Systems
+000ED8 Aktino, Inc.
+000ED9 Aksys, Ltd.
+000EDA C-TECH UNITED CORP.
+000EDB XiNCOM Corp.
+000EDC Tellion INC.
+000EDD SHURE INCORPORATED
+000EDE REMEC, Inc.
+000EDF PLX Technology
+000EE0 Mcharge
+000EE1 ExtremeSpeed Inc.
+000EE2 Custom Engineering S.p.A.
+000EE3 Chiyu Technology Co.,Ltd
+000EE5 bitWallet, Inc.
+000EE6 Adimos Systems LTD
+000EE7 AAC ELECTRONICS CORP.
+000EE8 zioncom
+000EE9 WayTech Development, Inc.
+000EEA Shadong Luneng Jicheng Electronics,Co.,Ltd
+000EEB Sandmartin(zhong shan)Electronics Co.,Ltd
+000EEC Orban
+000EED Nokia Danmark A/S
+000EEE Muco Industrie BV
+000EF0 Festo AG & Co. KG
+000EF1 EZQUEST INC.
+000EF3 Smarthome
+000EF4 Shenzhen Kasda Digital Technology Co.,Ltd
+000EF5 iPAC Technology Co., Ltd.
+000EF6 E-TEN Information Systems Co., Ltd.
+000EF7 Vulcan Portals Inc
+000EF8 SBC ASI
+000EF9 REA Elektronik GmbH
+000EFA Optoway Technology Incorporation
+000EFB Macey Enterprises
+000EFC JTAG Technologies B.V.
+000EFD FUJI PHOTO OPTICAL CO., LTD.
+000EFE EndRun Technologies LLC
+000EFF Megasolution,Inc.
+000F00 Legra Systems, Inc.
+000F01 DIGITALKS INC
+000F02 Digicube Technology Co., Ltd
+000F03 COM&C CO., LTD
+000F04 cim-usa inc
+000F05 3B SYSTEM INC.
+000F06 Nortel Networks
+000F07 Mangrove Systems, Inc.
+000F08 Indagon Oy
+000F0B Kentima Technologies AB
+000F0C SYNCHRONIC ENGINEERING
+000F0D Hunt Electronic Co., Ltd.
+000F0E WaveSplitter Technologies, Inc.
+000F0F Real ID Technology Co., Ltd.
+000F10 RDM Corporation
+000F11 Prodrive B.V.
+000F12 Panasonic AVC Networks Germany GmbH
+000F13 Nisca corporation
+000F14 Mindray Co., Ltd.
+000F15 Kjaerulff1 A/S
+000F16 JAY HOW TECHNOLOGY CO.,
+000F17 Insta Elektro GmbH
+000F18 Industrial Control Systems
+000F19 Guidant Corporation
+000F1A Gaming Support B.V.
+000F1B Ego Systems Inc.
+000F1C DigitAll World Co., Ltd
+000F1D Cosmo Techs Co., Ltd.
+000F1E Chengdu KT Electric Co.of High & New Technology
+000F1F WW PCBA Test
+000F20 WW Ops
+000F21 Scientific Atlanta, Inc
+000F22 Helius, Inc.
+000F23 Cisco Systems
+000F24 Cisco Systems
+000F25 AimValley B.V.
+000F26 WorldAccxx  LLC
+000F27 TEAL Electronics, Inc.
+000F28 Itronix Corporation
+000F29 Augmentix Corporation
+000F2A Cableware Electronics
+000F2B GREENBELL SYSTEMS
+000F2C Uplogix, Inc.
+001000 CABLE TELEVISION LABORATORIES, INC.
 001001 MCK COMMUNICATIONS
 001002 ACTIA
 001003 IMATRON, INC.
 001004 THE BRANTLEY COILE COMPANY,INC
 001005 UEC COMMERCIAL
-001006 RACAL RECORDERS LTD.
+001006 Thales Contact Solutions Ltd.
 001007 CISCO SYSTEMS, INC.
 001008 VIENNA SYSTEMS CORPORATION
 001009 HORO QUARTZ
@@ -1673,20 +3787,20 @@
 001012 PROCESSOR SYSTEMS (I) PVT LTD
 001013 INDUSTRIAL COMPUTER SOURCE
 001014 CISCO SYSTEMS, INC.
-001015 OOMON INC.
+001015 OOmon Inc.
 001016 T.SQWARE
-001017 MICOS GMBH
+001017 MICOS GmbH
 001018 BROADCOM CORPORATION
-001019 SIRONA DENTAL SYSTEMS
-00101A PICTURETEL CORP.
+001019 SIRONA DENTAL SYSTEMS GmbH & Co. KG
+00101A PictureTel Corp.
 00101B CORNET TECHNOLOGY, INC.
 00101C OHM TECHNOLOGIES INTL, LLC
 00101D WINBOND ELECTRONICS CORP.
-00101E MATSUSHITA ELECTRONIC
+00101E MATSUSHITA ELECTRONIC INSTRUMENTS CORP.
 00101F CISCO SYSTEMS, INC.
 001020 WELCH ALLYN, DATA COLLECTION
 001021 ENCANTO NETWORKS, INC.
-001022 SATCOM MEDIA CORPORATION
+001022 SatCom Media Corporation
 001023 FLOWWISE NETWORKS, INC.
 001024 NAGOYA ELECTRIC WORKS CO., LTD
 001025 GRAYHILL INC.
@@ -1698,18 +3812,18 @@
 00102B UMAX DATA SYSTEMS, INC.
 00102C Lasat Networks A/S
 00102D HITACHI SOFTWARE ENGINEERING
-00102E NETWORK SYSTEMS & TECHNOLOGIES
+00102E NETWORK SYSTEMS & TECHNOLOGIES PVT. LTD.
 00102F CISCO SYSTEMS, INC.
-001030 WI-LAN, INC.
+001030 Wi-LAN, Inc.
 001031 OBJECTIVE COMMUNICATIONS, INC.
 001032 ALTA TECHNOLOGY
 001033 ACCESSLAN COMMUNICATIONS, INC.
-001034 GNP COMPUTERS
-001035 ELITEGROUP COMPUTER
+001034 GNP Computers
+001035 ELITEGROUP COMPUTER SYSTEMS CO., LTD
 001036 INTER-TEL INTEGRATED SYSTEMS
-001037 CYQ'VE TECHNOLOGY CO., LTD.
+001037 CYQ've Technology Co., Ltd.
 001038 MICRO RESEARCH INSTITUTE, INC.
-001039 VECTRON SYSTEMS GMBH
+001039 Vectron Systems AG
 00103A DIAMOND NETWORK TECH
 00103B HIPPI NETWORKING FORUM
 00103C IC ENSEMBLE, INC.
@@ -1718,9 +3832,9 @@
 00103F TOLLGRADE COMMUNICATIONS, INC.
 001040 INTERMEC CORPORATION
 001041 BRISTOL BABCOCK, INC.
-001042 ALACRITECH
+001042 AlacriTech
 001043 A2 CORPORATION
-001044 INNOLABS CORPORATION
+001044 InnoLabs Corporation
 001045 Nortel Networks
 001046 ALCORN MCBRIDE INC.
 001047 ECHO ELETRIC CO. LTD.
@@ -1740,12 +3854,12 @@
 001055 FUJITSU MICROELECTRONICS, INC.
 001056 SODICK CO., LTD.
 001057 Rebel.com, Inc.
-001058 ARROWPOINT COMMUNICATIONS,INC.
+001058 ArrowPoint Communications
 001059 DIABLO RESEARCH CO. LLC
 00105A 3COM CORPORATION
 00105B NET INSIGHT AB
 00105C QUANTUM DESIGNS (H.K.) LTD.
-00105D DRAGER, BUSINESS UNIT
+00105D Draeger Medical
 00105E HEKIMIAN LABORATORIES, INC.
 00105F IN-SNEC
 001060 BILLIONTON SYSTEMS, INC.
@@ -1760,7 +3874,7 @@
 001069 HELIOSS COMMUNICATIONS, INC.
 00106A DIGITAL MICROWAVE CORPORATION
 00106B SONUS NETWORKS, INC.
-00106C INFRATEC PLUS GMBH
+00106C INFRATEC PLUS GmbH
 00106D INTEGRITY COMMUNICATIONS, INC.
 00106E TADIRAN COM. LTD.
 00106F TRENTON TECHNOLOGY INC.
@@ -1770,15 +3884,15 @@
 001073 TECHNOBOX, INC.
 001074 ATEN INTERNATIONAL CO., LTD.
 001075 Maxtor Corporation
-001076 EUREM GMBH
+001076 EUREM GmbH
 001077 SAF DRIVE SYSTEMS, LTD.
 001078 NUERA COMMUNICATIONS, INC.
 001079 CISCO SYSTEMS, INC.
-00107A AMBICOM, INC.
+00107A AmbiCom, Inc.
 00107B CISCO SYSTEMS, INC.
 00107C P-COM, INC.
 00107D AURORA COMMUNICATIONS, LTD.
-00107E BACHMANN ELECTRONIC GMBH
+00107E BACHMANN ELECTRONIC GmbH
 00107F CRESTRON ELECTRONICS, INC.
 001080 METAWAVE COMMUNICATIONS
 001081 DPS, INC.
@@ -1789,23 +3903,23 @@
 001086 ATTO TECHNOLOGY, INC.
 001087 Xstreamis PLC
 001088 AMERICAN NETWORKS INC.
-001089 WEBSONIC
-00108A TERALOGIC, INC.
-00108B LASERANIMATION SOLLINGER GMBH
-00108C FUJITSU TELECOMMUNICATIONS
+001089 WebSonic
+00108A TeraLogic, Inc.
+00108B LASERANIMATION SOLLINGER GmbH
+00108C FUJITSU TELECOMMUNICATIONS EUROPE, LTD.
 00108D JOHNSON CONTROLS, INC.
-00108E HUGH SYMONS CONCEPT
+00108E HUGH SYMONS CONCEPT Technologies Ltd.
 00108F RAPTOR SYSTEMS
 001090 CIMETRICS, INC.
 001091 NO WIRES NEEDED BV
 001092 NETCORE INC.
 001093 CMS COMPUTERS, LTD.
-001094 ADTECH, INC.
-001095 THOMSON CONSUMER ELECTRONICS
+001094 Performance Analysis Broadband, Spirent plc
+001095 Thomson Multimedia, Inc.
 001096 TRACEWELL SYSTEMS, INC.
-001097 WINNET METROPOLITAN
+001097 WinNet Metropolitan Communications Systems, Inc.
 001098 STARNET TECHNOLOGIES, INC.
-001099 INNOMEDIA, INC.
+001099 InnoMedia, Inc.
 00109A NETLINE
 00109B VIXEL CORPORATION
 00109C M-SYSTEM CO., LTD.
@@ -1840,10 +3954,10 @@
 0010B9 MAXTOR CORP.
 0010BA MARTINHO-DAVIS SYSTEMS, INC.
 0010BB DATA & INFORMATION TECHNOLOGY
-0010BC Nortel Networks
-0010BD THE TELECOMMUNICATION
+0010BC Aastra Telecom
+0010BD THE TELECOMMUNICATION TECHNOLOGY COMMITTEE
 0010BE TELEXIS CORP.
-0010BF INTER AIR WIRELESS
+0010BF InterAir Wireless
 0010C0 ARMA, INC.
 0010C1 OI ELECTRIC CO., LTD.
 0010C2 WILLNET, INC.
@@ -1852,11 +3966,11 @@
 0010C5 PROTOCOL TECHNOLOGIES, INC.
 0010C6 USI
 0010C7 DATA TRANSMISSION NETWORK
-0010C8 COMMUNICATIONS ELECTRONICS
-0010C9 MITSUBISHI ELECTRONICS
+0010C8 COMMUNICATIONS ELECTRONICS SECURITY GROUP
+0010C9 MITSUBISHI ELECTRONICS LOGISTIC SUPPORT CO.
 0010CA INTEGRAL ACCESS
 0010CB FACIT K.K.
-0010CC CLP COMPUTER LOGISTIK
+0010CC CLP COMPUTER LOGISTIK PLANUNG GmbH
 0010CD INTERFACE CONCEPT
 0010CE VOLAMP, LTD.
 0010CF FIBERLANE COMMUNICATIONS
@@ -1866,40 +3980,39 @@
 0010D3 GRIPS ELECTRONIC GMBH
 0010D4 STORAGE COMPUTER CORPORATION
 0010D5 IMASDE CANARIAS, S.A.
-0010D6 ITT A/CD
+0010D6 ITT - A/CD
 0010D7 ARGOSY RESEARCH INC.
 0010D8 CALISTA
 0010D9 IBM JAPAN, FUJISAWA MT+D
 0010DA MOTION ENGINEERING, INC.
-0010DB NETSCREEN TECHNOLOGIES, INC.
-0010DC MICRO-STAR INTERNATIONAL
+0010DB NetScreen Technologies, Inc.
+0010DC MICRO-STAR INTERNATIONAL CO., LTD.
 0010DD ENABLE SEMICONDUCTOR, INC.
-0010DE INTERNATIONAL DATACASTING
+0010DE INTERNATIONAL DATACASTING CORPORATION
 0010DF RISE COMPUTER INC.
 0010E0 COBALT MICROSERVER, INC.
 0010E1 S.I. TECH, INC.
-0010E2 ARRAYCOMM, INC.
+0010E2 ArrayComm, Inc.
 0010E3 COMPAQ COMPUTER CORPORATION
 0010E4 NSI CORPORATION
 0010E5 SOLECTRON TEXAS
-0010E6 APPLIED INTELLIGENT
-0010E7 BREEZECOM
+0010E6 APPLIED INTELLIGENT SYSTEMS, INC.
+0010E7 BreezeCom
 0010E8 TELOCITY, INCORPORATED
 0010E9 RAIDTEC LTD.
 0010EA ADEPT TECHNOLOGY
-0010EB SELSIUS SYSTEMS, ILNC.
+0010EB SELSIUS SYSTEMS, INC.
 0010EC RPCG, LLC
 0010ED SUNDANCE TECHNOLOGY, INC.
 0010EE CTI PRODUCTS, INC.
-0010EF DB NETWORKS, INC.
-0010F0 RITTAL-WERK RUDOLF LOH
+0010EF DBTEL INCORPORATED
 0010F1 I-O CORPORATION
 0010F2 ANTEC
-0010F3 NEXCOM INTERNATIONAL CO., LTD.
+0010F3 Nexcom International Co., Ltd.
 0010F4 VERTICAL NETWORKS, INC.
 0010F5 AMHERST SYSTEMS, INC.
 0010F6 CISCO SYSTEMS, INC.
-0010F7 IRIICHI TECHNOLOGIES
+0010F7 IRIICHI TECHNOLOGIES Inc.
 0010F8 KENWOOD TMI CORPORATION
 0010F9 UNIQUE SYSTEMS, INC.
 0010FA ZAYANTE, INC.
@@ -1934,14 +4047,14 @@
 002016 SHOWA ELECTRIC WIRE & CABLE CO
 002017 ORBOTECH
 002018 CIS TECHNOLOGY INC.
-002019 OHLER GMBH
+002019 OHLER GmbH
 00201A N-BASE SWITCH COMMUNICATIONS
 00201B NORTHERN TELECOM/NETWORK
 00201C EXCEL, INC.
 00201D KATANA PRODUCTS
 00201E NETQUEST CORPORATION
 00201F BEST POWER TECHNOLOGY, INC.
-002020 MEGATRON COMPUTER INDUSTRIES
+002020 MEGATRON COMPUTER INDUSTRIES PTY, LTD.
 002021 ALGORITHMS SOFTWARE PVT. LTD.
 002022 TEKNIQUE, INC.
 002023 T.C. TECHNOLOGIES PTY. LTD
@@ -1952,26 +4065,26 @@
 002028 WEST EGG SYSTEMS, INC.
 002029 TELEPROCESSING PRODUCTS, INC.
 00202A N.V. DZINE
-00202B ADVANCED TELECOMMUNICATIONS
+00202B ADVANCED TELECOMMUNICATIONS MODULES, LTD.
 00202C WELLTRONIX CO., LTD.
 00202D TAIYO CORPORATION
 00202E DAYSTAR DIGITAL
 00202F ZETA COMMUNICATIONS, LTD.
 002030 ANALOG & DIGITAL SYSTEMS
-002031 ERTEC GMBH
+002031 ERTEC GmbH
 002032 ALCATEL TAISEL
 002033 SYNAPSE TECHNOLOGIES, INC.
 002034 ROTEC INDUSTRIEAUTOMATION GMBH
 002035 IBM CORPORATION
 002036 BMC SOFTWARE
 002037 SEAGATE TECHNOLOGY
-002038 VME MICROSYSTEMS INTERNATIONAL
+002038 VME MICROSYSTEMS INTERNATIONAL CORPORATION
 002039 SCINETS
 00203A DIGITAL BI0METRICS INC.
 00203B WISDM LTD.
 00203C EUROTIME AB
 00203D NOVAR ELECTRONICS CORPORATION
-00203E LOGICAN TECHNOLOGIES, INC.
+00203E LogiCan Technologies, Inc.
 00203F JUKI CORPORATION
 002040 Motorola Broadband Communications Sector
 002041 DATA NET
@@ -1990,22 +4103,22 @@
 00204E NETWORK SECURITY SYSTEMS, INC.
 00204F DEUTSCHE AEROSPACE AG
 002050 KOREA COMPUTER INC.
-002051 PHOENIX DATA COMMUNUNICATIONS
+002051 Verilink Corporation
 002052 RAGULA SYSTEMS
 002053 HUNTSVILLE MICROSYSTEMS, INC.
 002054 EASTERN RESEARCH, INC.
 002055 ALTECH CO., LTD.
 002056 NEOPRODUCTS
-002057 TITZE DATENTECHNIK GMBH
+002057 TITZE DATENTECHNIK GmbH
 002058 ALLIED SIGNAL INC.
 002059 MIRO COMPUTER PRODUCTS AG
 00205A COMPUTER IDENTICS
 00205B SKYLINE TECHNOLOGY
-00205C INTERNET SYSTEMS/ FLORIDA INC.
+00205C InterNet Systems of Florida, Inc.
 00205D NANOMATIC OY
 00205E CASTLE ROCK, INC.
 00205F GAMMADATA COMPUTER GMBH
-002060 ALCATEL ITALIA S.P.A.
+002060 ALCATEL ITALIA S.p.A.
 002061 DYNATECH COMMUNICATIONS, INC.
 002062 SCORPION LOGIC, LTD.
 002063 WIPRO INFOTECH LTD.
@@ -2015,7 +4128,7 @@
 002068 ISDYNE
 002069 ISDN SYSTEMS CORPORATION
 00206A OSAKA COMPUTER CORP.
-00206B MINOLTA CO., LTD.
+00206B KONICA MINOLTA HOLDINGS, INC.
 00206C EVERGREEN TECHNOLOGY CORP.
 00206D DATA RACE, INC.
 00206E XACT, INC.
@@ -2030,11 +4143,11 @@
 002077 KARDIOS SYSTEMS CORP.
 002078 RUNTOP, INC.
 002079 MIKRON GMBH
-00207A WISE COMMUNICATIONS, INC.
-00207B LEVEL ONE COMMUNICATIONS
-00207C AUTEC GMBH
+00207A WiSE Communications, Inc.
+00207B Intel Corporation
+00207C AUTEC GmbH
 00207D ADVANCED COMPUTER APPLICATIONS
-00207E FINECOM CO., LTD.
+00207E FINECOM Co., Ltd.
 00207F KYOEI SANGYO CO., LTD.
 002080 SYNERGY (UK) LTD.
 002081 TITAN ELECTRONICS
@@ -2052,13 +4165,13 @@
 00208D CMD TECHNOLOGY
 00208E CHEVIN SOFTWARE ENG. LTD.
 00208F ECI TELECOM LTD.
-002090 ADVANCED COMPRESSION
+002090 ADVANCED COMPRESSION TECHNOLOGY, INC.
 002091 J125, NATIONAL SECURITY AGENCY
 002092 CHESS ENGINEERING B.V.
 002093 LANDINGS TECHNOLOGY CORP.
 002094 CUBIX CORPORATION
 002095 RIVA ELECTRONICS
-002096 SIEBE ENVIRONMENTAL CONTROLS
+002096 Invensys
 002097 APPLIED SIGNAL TECHNOLOGY
 002098 HECTRONIC AB
 002099 BON ELECTRIC CO., LTD.
@@ -2066,7 +4179,7 @@
 00209B ERSAT ELECTRONIC GMBH
 00209C PRIMARY ACCESS CORP.
 00209D LIPPERT AUTOMATIONSTECHNIK
-00209E BROWN'S OPERATING SYSTEM
+00209E BROWN'S OPERATING SYSTEM SERVICES, LTD.
 00209F MERCURY COMPUTER SYSTEMS, INC.
 0020A0 OA LABORATORY CO., LTD.
 0020A1 DOVATRON
@@ -2086,7 +4199,7 @@
 0020AF 3COM CORPORATION
 0020B0 GATEWAY DEVICES, INC.
 0020B1 COMTECH RESEARCH INC.
-0020B2 GKD GESELLSCHAFT FUR
+0020B2 GKD Gesellschaft Fur Kommunikation Und Datentechnik
 0020B3 SCLTEC COMMUNICATIONS SYSTEMS
 0020B4 TERMA ELEKTRONIK AS
 0020B5 YASKAWA ELECTRIC CORPORATION
@@ -2123,18 +4236,18 @@
 0020D4 CABLETRON - ZEITTNET INC.
 0020D5 VIPA GMBH
 0020D6 BREEZECOM
-0020D7 JAPAN MINICOMPUTER SYSTEMS CO.
-0020D8 NETWAVE TECHNOLOGIES, INC.
-0020D9 PANASONIC TECHNOLOGIES, INC./
+0020D7 JAPAN MINICOMPUTER SYSTEMS CO., Ltd.
+0020D8 Nortel Networks
+0020D9 PANASONIC TECHNOLOGIES, INC./MIECO-US
 0020DA XYLAN CORPORATION
 0020DB XNET TECHNOLOGY, INC.
 0020DC DENSITRON TAIWAN LTD.
-0020DD AWA LTD.
+0020DD Cybertec Pty Ltd
 0020DE JAPAN DIGITAL LABORAT'Y CO.LTD
 0020DF KYOSAN ELECTRIC MFG. CO., LTD.
 0020E0 PREMAX ELECTRONICS, INC.
 0020E1 ALAMAR ELECTRONICS
-0020E2 INFORMATION RESOURCE
+0020E2 INFORMATION RESOURCE ENGINEERING
 0020E3 MCD KENCOM CORPORATION
 0020E4 HSING TECH ENTERPRISE CO., LTD
 0020E5 APEX DATA, INC.
@@ -2214,7 +4327,7 @@
 00302F Smiths Industries
 003030 HARMONIX CORPORATION
 003031 LIGHTWAVE COMMUNICATIONS, INC.
-003032 MAGICRAM, INC.
+003032 MagicRam, Inc.
 003033 ORIENT TELECOM CO., LTD.
 003036 RMP ELEKTRONIKSYSTEME GMBH
 003037 Packard Bell Nec Services
@@ -2323,7 +4436,7 @@
 00309E WORKBIT CORPORATION.
 00309F AMBER NETWORKS
 0030A0 TYCO SUBMARINE SYSTEMS, LTD.
-0030A1 OPTI TECH CO., LTD.
+0030A1 WEBGATE Inc.
 0030A2 Lightner Engineering
 0030A3 CISCO SYSTEMS, INC.
 0030A4 Woodwind Communications System
@@ -2337,7 +4450,7 @@
 0030AC Systeme Lauer GmbH & Co., Ltd.
 0030AD SHANGHAI COMMUNICATION
 0030AE Times N System, Inc.
-0030AF Honeywell Reqelsysteme GmbH
+0030AF Honeywell GmbH
 0030B0 Convergenet Technologies
 0030B1 GOC GESELLSCHAFT FUR OPTISCHE
 0030B2 WESCAM - HEALDSBURG
@@ -2531,7 +4644,7 @@
 00406F SYNC RESEARCH INC.
 004070 INTERWARE CO., LTD.
 004071 ATM COMPUTER GMBH
-004072 APPLIED INNOVATION, INC.
+004072 Applied Innovation Inc.
 004073 BASS ASSOCIATES
 004074 CABLE AND WIRELESS
 004075 M-TRADE (UK) LTD
@@ -2544,7 +4657,7 @@
 00407C QUME CORPORATION
 00407D EXTENSION TECHNOLOGY CORP.
 00407E EVERGREEN SYSTEMS, INC.
-00407F AGEMA INFRARED SYSTEMS AB
+00407F FLIR Systems
 004080 ATHENIX CORPORATION
 004081 MANNESMANN SCANGRAPHIC GMBH
 004082 LABORATORY EQUIPMENT CORP.
@@ -2673,34 +4786,35 @@
 0040FD LXE
 0040FE SYMPLEX COMMUNICATIONS
 0040FF TELEBIT CORPORATION
+004252 RLX Technologies
 005000 NEXO COMMUNICATIONS, INC.
 005001 YAMASHITA SYSTEMS CORP.
 005002 OMNISEC AG
 005003 GRETAG MACBETH AG
 005004 3COM CORPORATION
 005006 TAC AB
-005007 SIEMENS TELECOMMUNICATION
+005007 SIEMENS TELECOMMUNICATION SYSTEMS LIMITED
 005008 TIVA MICROCOMPUTER CORP. (TMC)
 005009 PHILIPS BROADBAND NETWORKS
 00500A IRIS TECHNOLOGIES, INC.
 00500B CISCO SYSTEMS, INC.
-00500C ETEK LABS, INC.
+00500C e-Tek Labs, Inc.
 00500D SATORI ELECTORIC CO., LTD.
-00500E CHROMATIS NETWORKS,INC.
+00500E CHROMATIS NETWORKS, INC.
 00500F CISCO SYSTEMS, INC.
-005010 NOVANET LEARNING, INC.
+005010 NovaNET Learning, Inc.
 005012 CBL - GMBH
-005013 Chaparral Technologies, Inc.
+005013 Chaparral Network Storage
 005014 CISCO SYSTEMS, INC.
 005015 BRIGHT STAR ENGINEERING
 005016 SST/WOODHEAD INDUSTRIES
 005017 RSR S.R.L.
-005018 ADVANCED MULTIMEDIA INTERNET
+005018 ADVANCED MULTIMEDIA INTERNET TECHNOLOGY INC.
 005019 SPRING TIDE NETWORKS, INC.
 00501A UISIQN
 00501B ABL CANADA, INC.
 00501C JATOM SYSTEMS, INC.
-00501E MIRANDA TECHNOLOGIES, INC.
+00501E Miranda Technologies, Inc.
 00501F MRG SYSTEMS, LTD.
 005020 MEDIASTAR CO., LTD.
 005021 EIS INTERNATIONAL, INC.
@@ -2716,7 +4830,7 @@
 00502C SOYO COMPUTER, INC.
 00502D ACCEL, INC.
 00502E CAMBEX CORPORATION
-00502F TOLLBRIDGE TECHNOLOGIES, INC.
+00502F TollBridge Technologies, Inc.
 005030 FUTURE PLUS SYSTEMS
 005031 AEROFLEX LABORATORIES, INC.
 005032 PICAZO COMMUNICATIONS, INC.
@@ -2732,7 +4846,7 @@
 00503F ANCHOR GAMES
 005040 EMWARE, INC.
 005041 CTX OPTO ELECTRONIC CORP.
-005042 SCI MANUFACTURING
+005042 SCI MANUFACTURING SINGAPORE PTE, LTD.
 005043 MARVELL SEMICONDUCTOR, INC.
 005044 ASACA CORPORATION
 005045 RIOWORKS SOLUTIONS, INC.
@@ -2751,10 +4865,10 @@
 005053 CISCO SYSTEMS, INC.
 005054 CISCO SYSTEMS, INC.
 005055 DOMS A/S
-005056 VMWARE, INC.
+005056 VMWare, Inc.
 005057 BROADBAND ACCESS SYSTEMS
 005058 VEGASTREAM LIMITED
-005059 SUITE TECHNOLOGY SYSTEMS
+005059 SUITE TECHNOLOGY SYSTEMS NETWORK
 00505A NETWORK ALCHEMY, INC.
 00505B KAWASAKI LSI U.S.A., INC.
 00505C TUNDO CORPORATION
@@ -2765,10 +4879,10 @@
 005063 OY COMSEL SYSTEM AB
 005064 CAE ELECTRONICS
 005065 DENSEI-LAMBAD Co., Ltd.
-005066 ATECOM GMBH ADVANCED
+005066 AtecoM GmbH advanced telecomunication modules
 005067 AEROCOMM, INC.
-005068 ELECTRONIC INDUSTRIES
-005069 PIXSTREAM INCORPORATED
+005068 ELECTRONIC INDUSTRIES ASSOCIATION
+005069 PixStream Incorporated
 00506A EDEVA, INC.
 00506B SPX-ATEG
 00506C G & L BEIJER ELECTRONICS AB
@@ -2789,7 +4903,7 @@
 00507C VIDEOCON AG
 00507D IFP
 00507E NEWER TECHNOLOGY
-00507F DRAYTEK CORP.
+00507F DrayTek Corp.
 005080 CISCO SYSTEMS, INC.
 005081 MURATA MACHINERY, LTD.
 005082 FORESSON CORPORATION
@@ -2811,29 +4925,29 @@
 005094 PACE MICRO TECHNOLOGY PLC
 005095 PERACOM NETWORKS
 005096 SALIX TECHNOLOGIES, INC.
-005097 MMC-EMBEDDED
+005097 MMC-EMBEDDED COMPUTERTECHNIK GmbH
 005098 GLOBALOOP, LTD.
 005099 3COM EUROPE, LTD.
 00509A TAG ELECTRONIC SYSTEMS
 00509B SWITCHCORE AB
 00509C BETA RESEARCH
 00509D THE INDUSTREE B.V.
-00509E LES TECHNOLOGIES
+00509E Les Technologies SoftAcoustik Inc.
 00509F HORIZON COMPUTER
 0050A0 DELTA COMPUTER SYSTEMS, INC.
 0050A1 CARLO GAVAZZI, INC.
 0050A2 CISCO SYSTEMS, INC.
-0050A3 TRANSMEDIA COMMUNICATIONS, INC
+0050A3 TransMedia Communications, Inc.
 0050A4 IO TECH, INC.
 0050A5 CAPITOL BUSINESS SYSTEMS, LTD.
 0050A6 OPTRONICS
 0050A7 CISCO SYSTEMS, INC.
-0050A8 OPENCON SYSTEMS, INC.
+0050A8 OpenCon Systems, Inc.
 0050A9 MOLDAT WIRELESS TECHNOLGIES
-0050AA KONICA CORPORATION
+0050AA KONICA MINOLTA HOLDINGS, INC.
 0050AB NALTEC, INC.
 0050AC MAPLE COMPUTER CORPORATION
-0050AD COMMUNIQUE WIRELESS CORP.
+0050AD CommUnique Wireless Corp.
 0050AE IWAKI ELECTRONICS CO., LTD.
 0050AF INTERGON, INC.
 0050B0 TECHNOLOGY ATLANTA CORPORATION
@@ -2857,7 +4971,7 @@
 0050C2 IEEE REGISTRATION AUTHORITY
 0050C4 IMD
 0050C5 ADS TECHNOLOGIES, INC.
-0050C6 LOOP TELECOMMUNICATION
+0050C6 LOOP TELECOMMUNICATION INTERNATIONAL, INC.
 0050C8 ADDONICS COMMUNICATIONS, INC.
 0050C9 MASPRO DENKOH CORP.
 0050CA NET TO NET TECHNOLOGIES
@@ -2865,52 +4979,52 @@
 0050CC XYRATEX
 0050CD DIGIANSWER A/S
 0050CE LG INTERNATIONAL CORP.
-0050CF VANLINK COMMUNICATION
+0050CF VANLINK COMMUNICATION TECHNOLOGY RESEARCH INSTITUTE
 0050D0 MINERVA SYSTEMS
 0050D1 CISCO SYSTEMS, INC.
 0050D2 BAE Systems Canada, Inc.
-0050D3 DIGITAL AUDIO
+0050D3 DIGITAL AUDIO PROCESSING PTY. LTD.
 0050D4 JOOHONG INFORMATION &
 0050D5 AD SYSTEMS CORP.
 0050D6 ATLAS COPCO TOOLS AB
 0050D7 TELSTRAT
 0050D8 UNICORN COMPUTER CORP.
-0050D9 ENGETRON-ENGENHARIA ELETRONICA
+0050D9 ENGETRON-ENGENHARIA ELETRONICA IND. e COM. LTDA
 0050DA 3COM CORPORATION
 0050DB CONTEMPORARY CONTROL
-0050DC TAS TELEFONBAU A. SCHWABE
+0050DC TAS TELEFONBAU A. SCHWABE GMBH & CO. KG
 0050DD SERRA SOLDADURA, S.A.
 0050DE SIGNUM SYSTEMS CORP.
-0050DF AIRFIBER, INC.
+0050DF AirFiber, Inc.
 0050E1 NS TECH ELECTRONICS SDN BHD
 0050E2 CISCO SYSTEMS, INC.
-0050E3 TELEGATE
+0050E3 Terayon Communications Systems
 0050E4 APPLE COMPUTER, INC.
 0050E6 HAKUSAN CORPORATION
 0050E7 PARADISE INNOVATIONS (ASIA)
 0050E8 NOMADIX INC.
-0050EA XEL COMMUNICTIONS, INC.
+0050EA XEL COMMUNICATIONS, INC.
 0050EB ALPHA-TOP CORPORATION
 0050EC OLICOM A/S
 0050ED ANDA NETWORKS
 0050EE TEK DIGITEL CORPORATION
-0050EF SPE SYSTEMHAUS GMBH
+0050EF SPE Systemhaus GmbH
 0050F0 CISCO SYSTEMS, INC.
 0050F1 LIBIT SIGNAL PROCESSING, LTD.
 0050F2 MICROSOFT CORP.
-0050F3 GLOBAL NET INFORMATION CO.,LTD
+0050F3 GLOBAL NET INFORMATION CO., Ltd.
 0050F4 SIGMATEK GMBH & CO. KG
-0050F6 PAN-INTERNATIONAL
-0050F7 VENTURE MANUFACTURING
+0050F6 PAN-INTERNATIONAL INDUSTRIAL CORP.
+0050F7 VENTURE MANUFACTURING (SINGAPORE) LTD.
 0050F8 ENTREGA TECHNOLOGIES, INC.
 0050FA OXTEL, LTD.
 0050FB VSK ELECTRONICS
 0050FC EDIMAX TECHNOLOGY CO., LTD.
-0050FD ISIONCOMM CO., LTD.
-0050FE PCTVNET ASA
+0050FD VISIONCOMM CO., LTD.
+0050FE PCTVnet ASA
 0050FF HAKKO ELECTRONICS CO., LTD.
 006000 XYCOM INC.
-006001 INNOSYS, INC.
+006001 InnoSys, Inc.
 006002 SCREEN SUBTITLING SYSTEMS, LTD
 006003 TERAOKA WEIGH SYSTEM PTE, LTD.
 006004 COMPUTADORES MODULARES SA
@@ -2920,9 +5034,9 @@
 006008 3COM CORPORATION
 006009 CISCO SYSTEMS, INC.
 00600A SORD COMPUTER CORPORATION
-00600B LOGWARE GMBH
+00600B LOGWARE GmbH
 00600C APPLIED DATA SYSTEMS, INC.
-00600D MICRODESIGN GMBH
+00600D Digital Logic GmbH
 00600E WAVENET INTERNATIONAL, INC.
 00600F WESTELL, INC.
 006010 NETWORK MACHINES, INC.
@@ -2934,7 +5048,7 @@
 006016 CLARIION
 006017 TOKIMEC INC.
 006018 STELLAR ONE CORPORATION
-006019 BOEHRINGER MANNHEIM CORP.
+006019 Roche Diagnostics
 00601A KEITHLEY INSTRUMENTS
 00601B MESA ELECTRONICS
 00601C TELXON CORPORATION
@@ -2951,24 +5065,24 @@
 006027 Superior Modular Products
 006028 MACROVISION CORPORATION
 006029 CARY PERIPHERALS INC.
-00602A SYMICRON COMPUTER
+00602A SYMICRON COMPUTER COMMUNICATIONS, LTD.
 00602B PEAK AUDIO
-00602C LINX DATA TERMINALS, INC.
+00602C LINX Data Terminals, Inc.
 00602D ALERTON TECHNOLOGIES, INC.
 00602E CYCLADES CORPORATION
 00602F CISCO SYSTEMS, INC.
-006030 VILLAGE TRONIC
+006030 VILLAGE TRONIC ENTWICKLUNG
 006031 HRK SYSTEMS
 006032 I-CUBE, INC.
 006033 ACUITY IMAGING, INC.
-006034 ROBERT BOSCH GMBH
+006034 ROBERT BOSCH GmbH
 006035 DALLAS SEMICONDUCTOR, INC.
-006036 AUSTRIAN RESEARCH CENTER
+006036 AUSTRIAN RESEARCH CENTER SEIBERSDORF
 006037 PHILIPS SEMICONDUCTORS
 006038 Nortel Networks
-006039 SANCOM TECHNOLOGY, INC.
+006039 SanCom Technology, Inc.
 00603A QUICK CONTROLS LTD.
-00603B AMTEC SPA
+00603B AMTEC spa
 00603C HAGIWARA SYS-COM CO., LTD.
 00603D 3CX
 00603E CISCO SYSTEMS, INC.
@@ -2976,7 +5090,7 @@
 006040 NETRO CORP.
 006041 Yokogawa Electric Corporation
 006042 TKS (USA), INC.
-006043 COMSOFT SYSTEMS, INC.
+006043 ComSoft Systems, Inc.
 006044 LITTON/POLY-SCIENTIFIC
 006045 PATHLIGHT TECHNOLOGIES
 006046 VMETRO, INC.
@@ -2984,23 +5098,23 @@
 006048 EMC CORPORATION
 006049 VINA TECHNOLOGIES
 00604A SAIC IDEAS GROUP
-00604B BIODATA GMBH
+00604B BIODATA GmbH
 00604C SAT
 00604D MMC NETWORKS, INC.
 00604E CYCLE COMPUTER CORPORATION, INC.
 00604F SUZUKI MFG. CO., LTD.
 006050 INTERNIX INC.
 006051 QUALITY SEMICONDUCTOR
-006052 PERIPHERALS ENTERPRISE CO., L.
+006052 PERIPHERALS ENTERPRISE CO., Ltd.
 006053 TOYODA MACHINE WORKS, LTD.
 006054 CONTROLWARE GMBH
 006055 CORNELL UNIVERSITY
 006056 NETWORK TOOLS, INC.
 006057 MURATA MANUFACTURING CO., LTD.
-006058 COPPER MOUNTAIN
+006058 COPPER MOUNTAIN COMMUNICATIONS, INC.
 006059 TECHNICAL COMMUNICATIONS CORP.
 00605A CELCORE, INC.
-00605B INTRASERVER TECHNOLOGY INC.
+00605B IntraServer Technology, Inc.
 00605C CISCO SYSTEMS, INC.
 00605D SCANIVALVE CORP.
 00605E LIBERTY TECHNOLOGY NETWORKING
@@ -3010,13 +5124,13 @@
 006062 TELESYNC, INC.
 006063 PSION DACOM PLC.
 006064 NETCOMM LIMITED
-006065 BERNECKER & RAINER
+006065 BERNECKER & RAINER INDUSTRIE-ELEKTRONIC GmbH
 006066 LACROIX TECHNOLGIE
 006067 ACER NETXUS INC.
 006068 EICON TECHNOLOGY CORPORATION
-006069 BROCADE COMMUNICATIONS SYSTEMS
-00606A MITSUBISHI WIRELESS COMM. INC.
-00606B AICHI ELECTRONICS CO.,LTD.
+006069 BROCADE COMMUNICATIONS SYSTEMS, Inc.
+00606A MITSUBISHI WIRELESS COMMUNICATIONS. INC.
+00606B Synclayer Inc.
 00606C ARESCOM
 00606D DIGITAL EQUIPMENT CORP.
 00606E DAVICOM SEMICONDUCTOR, INC.
@@ -3027,13 +5141,13 @@
 006073 REDCREEK COMMUNICATIONS, INC.
 006074 QSC AUDIO PRODUCTS
 006075 PENTEK, INC.
-006076 SCHLUMBERGER TECHNOLOGIES
+006076 SCHLUMBERGER TECHNOLOGIES RETAIL PETROLEUM SYSTEMS
 006077 PRISA NETWORKS
 006078 POWER MEASUREMENT LTD.
-006079 WAVEPHORE NETWORKS, INC.
-00607A DVS GMBH
+006079 Mainstream Data, Inc.
+00607A DVS GmbH
 00607B FORE SYSTEMS, INC.
-00607C WAVEACCESS, LTD.
+00607C WaveAccess, Ltd.
 00607D SENTIENT NETWORKS INC.
 00607E GIGALABS, INC.
 00607F AURORA TECHNOLOGIES, INC.
@@ -3042,16 +5156,16 @@
 006082 NOVALINK TECHNOLOGIES, INC.
 006083 CISCO SYSTEMS, INC.
 006084 DIGITAL VIDEO
-006085 STORAGE CONCEPTS
+006085 Storage Concepts
 006086 LOGIC REPLACEMENT TECH. LTD.
 006087 KANSAI ELECTRIC CO., LTD.
 006088 WHITE MOUNTAIN DSP, INC.
 006089 XATA
 00608A CITADEL COMPUTER
-00608B CONFERTECH INTERNATIONAL
+00608B ConferTech International
 00608C 3COM CORPORATION
 00608D UNIPULSE CORP.
-00608E HE ELECTRONICS, TECHNOLOGIE &
+00608E HE ELECTRONICS, TECHNOLOGIE & SYSTEMTECHNIK GmbH
 00608F TEKRAM TECHNOLOGY CO., LTD.
 006090 ABLE COMMUNICATIONS, INC.
 006091 FIRST PACIFIC NETWORKS, INC.
@@ -3065,24 +5179,24 @@
 006099 LAN MEDIA CORPORATION
 00609A NJK TECHNO CO.
 00609B ASTRO-MED, INC.
-00609C PERKIN-ELMER CORPORATION
+00609C Perkin-Elmer Incorporated
 00609D PMI FOOD EQUIPMENT GROUP
-00609E X3 - INFORMATION TECHNOLOGY
+00609E ASC X3 - INFORMATION TECHNOLOGY STANDARDS SECRETARIATS
 00609F PHAST CORPORATION
-0060A0 SWITCHED NETWORK
-0060A1 VPNET
+0060A0 SWITCHED NETWORK TECHNOLOGIES, INC.
+0060A1 VPNet, Inc.
 0060A2 NIHON UNISYS LIMITED CO.
 0060A3 CONTINUUM TECHNOLOGY CORP.
 0060A4 GRINAKER SYSTEM TECHNOLOGIES
 0060A5 PERFORMANCE TELECOM CORP.
 0060A6 PARTICLE MEASURING SYSTEMS
-0060A7 MICROSENS GMBH & CO. KG
+0060A7 MICROSENS GmbH & CO. KG
 0060A8 TIDOMAT AB
-0060A9 GESYTEC MBH
+0060A9 GESYTEC MbH
 0060AA INTELLIGENT DEVICES INC. (IDI)
 0060AB LARSCOM INCORPORATED
 0060AC RESILIENCE CORPORATION
-0060AD MEGACHIPS CORPORATION
+0060AD MegaChips Corporation
 0060AE TRIO INFORMATION SYSTEMS AB
 0060AF PACIFIC MICRO DATA, INC.
 0060B0 HEWLETT-PACKARD CO.
@@ -3090,19 +5204,19 @@
 0060B2 PROCESS CONTROL CORP.
 0060B3 Z-COM, INC.
 0060B4 GLENAYRE R&D INC.
-0060B5 KEBA GMBH
+0060B5 KEBA GmbH
 0060B6 LAND COMPUTER CO., LTD.
 0060B7 CHANNELMATIC, INC.
 0060B8 CORELIS INC.
 0060B9 NITSUKO CORPORATION
 0060BA SAHARA NETWORKS, INC.
 0060BB CABLETRON - NETLINK, INC.
-0060BC KEUNYOUNG ELECTRONICS &
+0060BC KeunYoung Electronics & Communication Co., Ltd.
 0060BD HUBBELL-PULSECOM
 0060BE WEBTRONICS
 0060BF MACRAIGOR SYSTEMS, INC.
 0060C0 NERA AS
-0060C1 WAVESPAN CORPORATION
+0060C1 WaveSpan Corporation
 0060C2 MPL AG
 0060C3 NETVISION CORPORATION
 0060C4 SOLITON SYSTEMS K.K.
@@ -3110,40 +5224,40 @@
 0060C6 DCS AG
 0060C7 AMATI COMMUNICATIONS CORP.
 0060C8 KUKA WELDING SYSTEMS & ROBOTS
-0060C9 CONTROLNET, INC.
+0060C9 ControlNet, Inc.
 0060CA HARMONIC SYSTEMS INCORPORATED
 0060CB HITACHI ZOSEN CORPORATION
 0060CC EMTRAK, INCORPORATED
-0060CD VIDEOSERVER, INC.
+0060CD VideoServer, Inc.
 0060CE ACCLAIM COMMUNICATIONS
 0060CF ALTEON NETWORKS, INC.
 0060D0 SNMP RESEARCH INCORPORATED
 0060D1 CASCADE COMMUNICATIONS
-0060D2 LUCENT TECHNOLOGIES TAIWAN
+0060D2 LUCENT TECHNOLOGIES TAIWAN TELECOMMUNICATIONS CO., LTD.
 0060D3 AT&T
 0060D4 ELDAT COMMUNICATION LTD.
 0060D5 MIYACHI TECHNOS CORP.
-0060D6 NOVATEL WIRELESS TECHNOLOGIES
-0060D7 ECOLE POLYTECHNIQUE FEDERALE
+0060D6 NovAtel Wireless Technologies Ltd.
+0060D7 ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (EPFL)
 0060D8 ELMIC SYSTEMS, INC.
 0060D9 TRANSYS NETWORKS INC.
 0060DA JBM ELECTRONICS CO.
 0060DB NTP ELEKTRONIK A/S
-0060DC TOYO COMMUNICATION EQUIPMENT
+0060DC TOYO COMMUNICATION EQUIPMENT Co., Ltd.
 0060DD MYRICOM, INC.
-0060DE KAYSER-THREDE GMBH
-0060DF INRANGE TECHNOLOGIES CORP.
+0060DE KAYSER-THREDE GmbH
+0060DF CNT Corporation
 0060E0 AXIOM TECHNOLOGY CO., LTD.
 0060E1 ORCKIT COMMUNICATIONS LTD.
-0060E2 QUEST ENGINEERING & DEV.
+0060E2 QUEST ENGINEERING & DEVELOPMENT
 0060E3 ARBIN INSTRUMENTS
 0060E4 COMPUSERVE, INC.
 0060E5 FUJI AUTOMATION CO., LTD.
 0060E6 SHOMITI SYSTEMS INCORPORATED
 0060E7 RANDATA
-0060E8 HITACHI COMPUTER PRODUCTS
+0060E8 HITACHI COMPUTER PRODUCTS (AMERICA), INC.
 0060E9 ATOP TECHNOLOGIES, INC.
-0060EA STREAMLOGIC
+0060EA StreamLogic
 0060EB FOURTHTRACK SYSTEMS
 0060EC HERMARY OPTO ELECTRONICS INC.
 0060ED RICARDO TEST AUTOMATION LTD.
@@ -3152,19 +5266,19 @@
 0060F0 JOHNSON & JOHNSON MEDICAL, INC
 0060F1 EXP COMPUTER, INC.
 0060F2 LASERGRAPHICS, INC.
-0060F3 NETCOM SYSTEMS, INC.
-0060F4 ADVANCED COMPUTER SOLUTIONS,
+0060F3 Performance Analysis Broadband, Spirent plc
+0060F4 ADVANCED COMPUTER SOLUTIONS, Inc.
 0060F5 ICON WEST, INC.
-0060F6 NEXTEST COMMUNICATION
+0060F6 NEXTEST COMMUNICATIONS PRODUCTS, INC.
 0060F7 DATAFUSION SYSTEMS
-0060F8 LORAN INTERNATIONAL TECHN. INC
+0060F8 Loran International Technologies Inc.
 0060F9 DIAMOND LANE COMMUNICATIONS
-0060FA EDUCATIONAL TECHNOLOGY
+0060FA EDUCATIONAL TECHNOLOGY RESOURCES, INC.
 0060FB PACKETEER, INC.
-0060FC CONSERVATION THROUGH
-0060FD NETICS, INC.
+0060FC CONSERVATION THROUGH INNOVATION LTD.
+0060FD NetICs, Inc.
 0060FE LYNX SYSTEM DEVELOPERS, INC.
-0060FF QUVIS, INC.
+0060FF QuVis, Inc.
 0070B0 M/A-COM INC. COMPANIES
 0070B3 DATA RECALL LTD.
 008000 MULTITECH SYSTEMS, INC.
@@ -3200,7 +5314,7 @@
 00801E XINETRON, INC.
 00801F KRUPP ATLAS ELECTRONIK GMBH
 008020 NETWORK PRODUCTS
-008021 NEWBRIDGE RESEARCH CORP.
+008021 Alcatel Canada Inc.
 008022 SCAN-OPTICS
 008023 INTEGRATED BUSINESS NETWORKS
 008024 KALPANA, INC.
@@ -3361,7 +5475,7 @@
 0080BF TAKAOKA ELECTRIC MFG. CO. LTD.
 0080C0 PENRIL DATACOMM
 0080C1 LANEX CORPORATION
-0080C2 IEEE 802 COMMITTEE
+0080C2 IEEE 802.1 COMMITTEE
 0080C3 BICC INFORMATION SYSTEMS & SVC
 0080C4 DOCUMENT TECHNOLOGIES, INC.
 0080C5 NOVELLCO DE MEXICO
@@ -3382,7 +5496,7 @@
 0080D4 CHASE RESEARCH LTD.
 0080D5 CADRE TECHNOLOGIES
 0080D6 NUVOTECH, INC.
-0080D7 FANTUM ENGINEERING, INC.
+0080D7 Fantum Engineering
 0080D8 NETWORK PERIPHERALS INC.
 0080D9 EMK ELEKTRONIK
 0080DA BRUEL & KJAER
@@ -3400,14 +5514,14 @@
 0080E6 PEER NETWORKS, INC.
 0080E7 LYNWOOD SCIENTIFIC DEV. LTD.
 0080E8 CUMULUS CORPORATIION
-0080E9 MADGE NETWORKS
+0080E9 Madge Ltd.
 0080EA ADVA Optical Networking Ltd.
 0080EB COMPCONTROL B.V.
 0080EC SUPERCOMPUTING SOLUTIONS, INC.
 0080ED IQ TECHNOLOGIES, INC.
 0080EE THOMSON CSF
 0080EF RATIONAL
-0080F0 KYUSHU MATSUSHITA ELECTRIC CO.
+0080F0 Panasonic Communications Co., Ltd.
 0080F1 OPUS SYSTEMS
 0080F2 RAYCOM SYSTEMS INC
 0080F3 SUN ELECTRONICS CORP.
@@ -3424,23 +5538,23 @@
 0080FE AZURE TECHNOLOGIES, INC.
 0080FF SOC. DE TELEINFORMATIQUE RTC
 009000 DIAMOND MULTIMEDIA
-009001 NISHIMU ELCTRONICS INDUSTRIES
+009001 NISHIMU ELECTRONICS INDUSTRIES CO., LTD.
 009002 ALLGON AB
 009003 APLIO
 009004 3COM EUROPE LTD.
 009005 PROTECH SYSTEMS CO., LTD.
 009006 HAMAMATSU PHOTONICS K.K.
 009007 DOMEX TECHNOLOGY CORP.
-009008 HAN A SYSTEMS, INC.
+009008 HanA Systems Inc.
 009009 i Controls, Inc.
-00900A PROTON ELECTRONIC INDUSTRIAL
+00900A PROTON ELECTRONIC INDUSTRIAL CO., LTD.
 00900B LANNER ELECTRONICS, INC.
 00900C CISCO SYSTEMS, INC.
 00900D OVERLAND DATA INC.
 00900E HANDLINK TECHNOLOGIES, INC.
 00900F KAWASAKI HEAVY INDUSTRIES, LTD
 009010 SIMULATION LABORATORIES, INC.
-009011 WAVTRACE, INC.
+009011 WAVTrace, Inc.
 009012 GLOBESPAN SEMICONDUCTOR, INC.
 009013 SAMSAN CORP.
 009014 ROTORK INSTRUMENTS, LTD.
@@ -3451,7 +5565,7 @@
 009019 HERMES ELECTRONICS CO., LTD.
 00901A UNISPHERE SOLUTIONS
 00901B DIGITAL CONTROLS
-00901C MPS SOFTWARE GMBH
+00901C mps Software Gmbh
 00901D PEC (NZ) LTD.
 00901E SELESTA INGEGNE RIA S.P.A.
 00901F ADTEC PRODUCTIONS, INC.
@@ -3461,44 +5575,44 @@
 009023 ZILOG INC.
 009024 PIPELINKS, INC.
 009025 VISION SYSTEMS LTD. PTY
-009026 ADVANCED SWITCHING
+009026 ADVANCED SWITCHING COMMUNICATIONS, INC.
 009027 INTEL CORPORATION
 009028 NIPPON SIGNAL CO., LTD.
 009029 CRYPTO AG
 00902A COMMUNICATION DEVICES, INC.
 00902B CISCO SYSTEMS, INC.
 00902C DATA & CONTROL EQUIPMENT LTD.
-00902D DATA ELECTRONICS
+00902D DATA ELECTRONICS (AUST.) PTY, LTD.
 00902E NAMCO LIMITED
 00902F NETCORE SYSTEMS, INC.
 009030 HONEYWELL-DATING
 009031 MYSTICOM, LTD.
 009032 PELCOMBE GROUP LTD.
-009033 INNOVAPHONE GMBH
+009033 INNOVAPHONE GmbH
 009034 IMAGIC, INC.
 009035 ALPHA TELECOM, INC.
-009036 ENS, INC.
+009036 ens, inc.
 009037 ACUCOMM, INC.
 009038 FOUNTAIN TECHNOLOGIES, INC.
 009039 SHASTA NETWORKS
 00903A NIHON MEDIA TOOL INC.
-00903B TRIEMS RESEARCH LAB, INC.
+00903B TriEMS Research Lab, Inc.
 00903C ATLANTIC NETWORK SYSTEMS
 00903D BIOPAC SYSTEMS, INC.
-00903E N.V. PHILIPS INDUSTRIAL
+00903E N.V. PHILIPS INDUSTRIAL ACTIVITIES
 00903F AZTEC RADIOMEDIA
-009040 CASTLE NETWORKS, INC.
+009040 Siemens Network Convergence LLC
 009041 APPLIED DIGITAL ACCESS
-009042 ECCS
+009042 ECCS, Inc.
 009043 NICHIBEI DENSHI CO., LTD.
 009044 ASSURED DIGITAL, INC.
-009045 MARIPOSA TECHNOLOGY
+009045 Marconi Communications
 009046 DEXDYNE, LTD.
 009047 GIGA FAST E. LTD.
 009048 ZEAL CORPORATION
 009049 ENTRIDIA CORPORATION
 00904A CONCUR SYSTEM TECHNOLOGIES
-00904B GEMTEK TECHNOLOGY CO., LTD.
+00904B GemTek Technology Co., Ltd.
 00904C EPIGRAM, INC.
 00904D SPEC S.A.
 00904E DELEM BV
@@ -3508,49 +5622,49 @@
 009052 SELCOM ELETTRONICA S.R.L.
 009053 DAEWOO ELECTRONICS CO., LTD.
 009054 INNOVATIVE SEMICONDUCTORS, INC
-009055 PARKER HANNIFIN CORPORATION
+009055 PARKER HANNIFIN CORPORATION COMPUMOTOR DIVISION
 009056 TELESTREAM, INC.
-009057 AANETCOM, INC.
-009058 ULTRA ELECTRONICS LTD.
+009057 AANetcom, Inc.
+009058 Ultra Electronics Ltd., Command and Control Systems
 009059 TELECOM DEVICE K.K.
 00905A DEARBORN GROUP, INC.
 00905B RAYMOND AND LAE ENGINEERING
 00905C EDMI
-00905D NETCOM SICHERHEITSTECHNIK GMBH
+00905D NETCOM SICHERHEITSTECHNIK GmbH
 00905E RAULAND-BORG CORPORATION
 00905F CISCO SYSTEMS, INC.
 009060 SYSTEM CREATE CORP.
-009061 PACIFIC RESEARCH & ENGINEERING
-009062 ICP VORTEX COMPUTERSYSTEME
-009063 COHERENT COMMUNICATIONS
+009061 PACIFIC RESEARCH & ENGINEERING CORPORATION
+009062 ICP VORTEX COMPUTERSYSTEME GmbH
+009063 COHERENT COMMUNICATIONS SYSTEMS CORPORATION
 009064 THOMSON BROADCAST SYSTEMS
 009065 FINISAR CORPORATION
 009066 Troika Networks, Inc.
-009067 WALKABOUT COMPUTERS, INC.
+009067 WalkAbout Computers, Inc.
 009068 DVT CORP.
 009069 JUNIPER NETWORKS, INC.
 00906A TURNSTONE SYSTEMS, INC.
 00906B APPLIED RESOURCES, INC.
-00906C GWT GLOBAL WEIGHING
+00906C GWT GLOBAL WEIGHING TECHNOLOGIES GmbH
 00906D CISCO SYSTEMS, INC.
 00906E PRAXON, INC.
 00906F CISCO SYSTEMS, INC.
 009070 NEO NETWORKS, INC.
-009071 BADGER TECHNOLOGY, INC.
+009071 Applied Innovation Inc.
 009072 SIMRAD AS
 009073 GAIO TECHNOLOGY
 009074 ARGON NETWORKS, INC.
 009075 NEC DO BRASIL S.A.
-009076 FMT AIRCRAFT GATE SUPPORT
+009076 FMT AIRCRAFT GATE SUPPORT SYSTEMS AB
 009077 ADVANCED FIBRE COMMUNICATIONS
-009078 MER TELEMANAGEMENT
-009079 CLEARONE INC.
+009078 MER TELEMANAGEMENT SOLUTIONS, LTD.
+009079 ClearOne, Inc.
 00907A SPECTRALINK CORP.
 00907B E-TECH, INC.
 00907C DIGITALCAST, INC.
-00907D HOME WIRELESS NETWORKS
+00907D Lake Communications
 00907E VETRONIX CORP.
-00907F WATCHGUARD TECHNOLOGIES, INC.
+00907F WatchGuard Technologies, Inc.
 009080 NOT LIMITED, INC.
 009081 ALOHA NETWORKS, INC.
 009082 FORCE INSTITUTE
@@ -3566,9 +5680,9 @@
 00908C ETREND ELECTRONICS, INC.
 00908D VICKERS ELECTRONICS SYSTEMS
 00908E Nortel Networks Broadband Access
-00908F AUDIOCODES LTD.
+00908F AUDIO CODES LTD.
 009090 I-BUS
-009091 DIGITALSCAPE, INC.
+009091 DigitalScape, Inc.
 009092 CISCO SYSTEMS, INC.
 009093 NANAO CORPORATION
 009094 OSPREY TECHNOLOGIES, INC.
@@ -3576,28 +5690,28 @@
 009096 ASKEY COMPUTER CORP.
 009097 SYCAMORE NETWORKS
 009098 SBC DESIGNS, INC.
-009099 ALLIED TELESIS,K.K.
+009099 ALLIED TELESIS, K.K.
 00909A ONE WORLD SYSTEMS, INC.
 00909B MARKPOINT AB
-00909C COMBOX, LTD.
+00909C Terayon Communications Systems
 00909D GSE SYSTEMS, INC.
-00909E DELPHI ENGINEERING GROUP
+00909E Critical IO, LLC
 00909F DIGI-DATA CORPORATION
 0090A0 8X8 INC.
 0090A1 FLYING PIG SYSTEMS, LTD.
 0090A2 CYBERTAN TECHNOLOGY, INC.
-0090A3 MEDIALINCS CO., LTD.
+0090A3 Corecess Inc.
 0090A4 ALTIGA NETWORKS
 0090A5 SPECTRA LOGIC
 0090A6 CISCO SYSTEMS, INC.
 0090A7 CLIENTEC CORPORATION
-0090A8 NINETILES NETWORKS LTD.
+0090A8 NineTiles Networks, Ltd.
 0090A9 WESTERN DIGITAL
-0090AA INDIGO ACTIVE VISION
+0090AA INDIGO ACTIVE VISION SYSTEMS LIMITED
 0090AB CISCO SYSTEMS, INC.
 0090AC OPTIVISION, INC.
 0090AD ASPECT ELECTRONICS, INC.
-0090AE ITALTEL SPA
+0090AE ITALTEL S.p.A.
 0090AF J. MORITA MFG. CORP.
 0090B0 VADEM
 0090B1 CISCO SYSTEMS, INC.
@@ -3610,46 +5724,46 @@
 0090B8 ROHDE & SCHWARZ GMBH & CO. KG
 0090B9 BERAN INSTRUMENTS LTD.
 0090BA VALID NETWORKS, INC.
-0090BB TAINET COMMUNICATION SYSTEM
+0090BB TAINET COMMUNICATION SYSTEM Corp.
 0090BC TELEMANN CO., LTD.
 0090BD OMNIA COMMUNICATIONS, INC.
-0090BE IBC/INTEGRATED BUSINESS
+0090BE IBC/INTEGRATED BUSINESS COMPUTERS
 0090BF CISCO SYSTEMS, INC.
 0090C0 K.J. LAW ENGINEERS, INC.
-0090C1 EDA INDUSTRIES
-0090C2 JK MICROSYSTEMS, INC.
+0090C1 Peco II, Inc.
+0090C2 JK microsystems, Inc.
 0090C3 TOPIC SEMICONDUCTOR CORP.
 0090C4 JAVELIN SYSTEMS, INC.
 0090C5 INTERNET MAGIC, INC.
 0090C6 OPTIM SYSTEMS, INC.
 0090C7 ICOM INC.
-0090C8 WAVERIDER COMMUNICATIONS
-0090C9 PRODUCTIVITY ENHANCEMENT
-0090CA ACCORD VIDEO
-0090CB WIRELESS ONLINE, INC.
-0090CC PLANEX COMMUNICATIONS, INC.
-0090CD ENT-EMPRESA NACIONAL
-0090CE TETRA GMBH
+0090C8 WAVERIDER COMMUNICATIONS (CANADA) INC.
+0090C9 DPAC Technologies
+0090CA ACCORD VIDEO TELECOMMUNICATIONS, LTD.
+0090CB Wireless OnLine, Inc.
+0090CC PLANET COMMUNICATIONS, INC.
+0090CD ENT-EMPRESA NACIONAL DE TELECOMMUNICACOES, S.A.
+0090CE TETRA GmbH
 0090CF NORTEL
-0090D0 ALCATEL BELL
+0090D0 Thomson Belgium
 0090D1 LEICHU ENTERPRISE CO., LTD.
 0090D2 ARTEL VIDEO SYSTEMS
-0090D3 GIESECKE & DEVRIENT GMBH
-0090D4 BINDVIEW DEVELOPMENT CORP.
+0090D3 GIESECKE & DEVRIENT GmbH
+0090D4 BindView Development Corp.
 0090D5 EUPHONIX, INC.
 0090D6 CRYSTAL GROUP
-0090D7 NETBOOST CORP.
+0090D7 NetBoost Corp.
 0090D8 WHITECROSS SYSTEMS
 0090D9 CISCO SYSTEMS, INC.
 0090DA DYNARC, INC.
 0090DB NEXT LEVEL COMMUNICATIONS
 0090DC TECO INFORMATION SYSTEMS
-0090DD THE MIHARU COMMUNICATIONS
+0090DD THE MIHARU COMMUNICATIONS CO., LTD.
 0090DE CARDKEY SYSTEMS, INC.
-0090DF MITSUBISHI CHEMICAL
+0090DF MITSUBISHI CHEMICAL AMERICA, INC.
 0090E0 SYSTRAN CORP.
 0090E1 TELENA S.P.A.
-0090E2 DISTRIBUTED PROCESSING
+0090E2 DISTRIBUTED PROCESSING TECHNOLOGY
 0090E3 AVEX ELECTRONICS INC.
 0090E4 NEC AMERICA, INC.
 0090E5 TEKNEMA, INC.
@@ -3660,8 +5774,8 @@
 0090EA ALPHA TECHNOLOGIES, INC.
 0090EB SENTRY TELECOM SYSTEMS
 0090EC PYRESCOM
-0090ED CENTRAL SYSTEM RESEARCH
-0090EE PERSONAL COMMUNICATIONS
+0090ED CENTRAL SYSTEM RESEARCH CO., LTD.
+0090EE PERSONAL COMMUNICATIONS TECHNOLOGIES
 0090EF INTEGRIX, INC.
 0090F0 HARMONIC LIGHTWAVES, LTD.
 0090F1 DOT HILL SYSTEMS CORPORATION
@@ -3673,20 +5787,21 @@
 0090F7 NBASE COMMUNICATIONS LTD.
 0090F8 MEDIATRIX TELECOM
 0090F9 LEITCH
-0090FA GIGANET, INC.
+0090FA GigaNet, Inc.
 0090FB PORTWELL, INC.
 0090FC NETWORK COMPUTING DEVICES
-0090FD COPPERCOM, INC.
-0090FE ELECOM CO., LTD.  (LANEED DIV.
+0090FD CopperCom, Inc.
+0090FE ELECOM CO., LTD.  (LANEED DIV.)
 0090FF TELLUS TECHNOLOGY INC.
+0091D6 Crystal Group, Inc.
 009D8E CARDIAC RECORDERS, INC.
 00A000 CENTILLION NETWORKS, INC.
 00A001 WATKINS-JOHNSON COMPANY
-00A002 LEEDS & NORTHRUP AUSTRALIA
+00A002 LEEDS & NORTHRUP AUSTRALIA PTY LTD
 00A003 STAEFA CONTROL SYSTEM
 00A004 NETPOWER, INC.
 00A005 DANIEL INSTRUMENTS, LTD.
-00A006 IMAGE DATA PROCESSING
+00A006 IMAGE DATA PROCESSING SYSTEM GROUP
 00A007 APEXX TECHNOLOGY, INC.
 00A008 NETCORP
 00A009 WHITETREE NETWORK
@@ -3714,8 +5829,8 @@
 00A01F TRICORD SYSTEMS, INC.
 00A020 CITICORP/TTI
 00A021 GENERAL DYNAMICS-
-00A022 CENTRE FOR DEVELOPMENT OF
-00A023 APPLIED CREATIVE TECHNOLOGY,
+00A022 CENTRE FOR DEVELOPMENT OF ADVANCED COMPUTING
+00A023 APPLIED CREATIVE TECHNOLOGY, INC.
 00A024 3COM CORPORATION
 00A025 REDCOM LABS INC.
 00A026 TELDAT, S.A.
@@ -3724,14 +5839,14 @@
 00A029 COULTER CORPORATION
 00A02A TRANCELL SYSTEMS
 00A02B TRANSITIONS RESEARCH CORP.
-00A02C INTERWAVE COMMUNICATIONS
+00A02C interWAVE Communications
 00A02D 1394 Trade Association
 00A02E BRAND COMMUNICATIONS, LTD.
 00A02F PIRELLI CAVI
 00A030 CAPTOR NV/SA
 00A031 HAZELTINE CORPORATION, MS 1-17
 00A032 GES SINGAPORE PTE. LTD.
-00A033 IMC MESS-SYSTEME GMBH
+00A033 imc MeBsysteme GmbH
 00A034 AXEL
 00A035 CYLINK CORPORATION
 00A036 APPLIED NETWORK TECHNOLOGY
@@ -3741,14 +5856,14 @@
 00A03A KUBOTEK CORPORATION
 00A03B TOSHIN ELECTRIC CO., LTD.
 00A03C EG&G NUCLEAR INSTRUMENTS
-00A03D OPTO - 22
+00A03D OPTO-22
 00A03E ATM FORUM
-00A03F COMPUTER SOCIETY MICROPROCES'R
+00A03F COMPUTER SOCIETY MICROPROCESSOR & MICROPROCESSOR STANDARDS C
 00A040 APPLE COMPUTER
 00A041 LEYBOLD-INFICON
 00A042 SPUR PRODUCTS CORP.
 00A043 AMERICAN TECHNOLOGY LABS, INC.
-00A044 NTT INTELLIGENT TECHNOLOGY
+00A044 NTT IT CO., LTD.
 00A045 PHOENIX CONTACT GMBH & CO.
 00A046 SCITEX CORP. LTD.
 00A047 INTEGRATED FITNESS CORP.
@@ -3756,7 +5871,7 @@
 00A049 DIGITECH INDUSTRIES, INC.
 00A04A NISSHIN ELECTRIC CO., LTD.
 00A04B TFL LAN INC.
-00A04C INNOVATIVE SYSTEMS & TECH. INC
+00A04C INNOVATIVE SYSTEMS & TECHNOLOGIES, INC.
 00A04D EDA INSTRUMENTS, INC.
 00A04E VOELKER TECHNOLOGIES, INC.
 00A04F AMERITEC CORP.
@@ -3764,15 +5879,15 @@
 00A051 ANGIA COMMUNICATIONS. INC.
 00A052 STANILITE ELECTRONICS PTY. LTD
 00A053 COMPACT DEVICES, INC.
-00A055 LINKTECH, INC.
+00A055 Data Device Corporation
 00A056 MICROPROSS
-00A057 ELSA AG
+00A057 LANCOM Systems GmbH
 00A058 GLORY, LTD.
 00A059 HAMILTON HALLMARK
 00A05A KOFAX IMAGE PRODUCTS
 00A05B MARQUIP, INC.
 00A05C INVENTORY CONVERSION, INC./
-00A05D CS COMPUTER SYSTEME GMBH
+00A05D CS COMPUTER SYSTEME GmbH
 00A05E MYRIAD LOGIC INC.
 00A05F BTG ENGINEERING BV
 00A060 ACER PERIPHERALS, INC.
@@ -3784,10 +5899,10 @@
 00A066 ISA CO., LTD.
 00A067 NETWORK SERVICES GROUP
 00A068 BHP LIMITED
-00A069 TrueTime
-00A06A VERILINK CORP.
+00A069 Symmetricom, Inc.
+00A06A Verilink Corporation
 00A06B DMS DORSCH MIKROSYSTEM GMBH
-00A06C SHINDENGEN ELECTRIC MFG.
+00A06C SHINDENGEN ELECTRIC MFG. CO., LTD.
 00A06D MANNESMANN TALLY CORPORATION
 00A06E AUSTRON, INC.
 00A06F THE APPCON GROUP, INC.
@@ -3801,7 +5916,7 @@
 00A077 FUJITSU NEXION, INC.
 00A078 Marconi Communications
 00A079 ALPS ELECTRIC (USA), INC.
-00A07A ADVANCED PERIPHERALS
+00A07A ADVANCED PERIPHERALS TECHNOLOGIES, INC.
 00A07B DAWN COMPUTER INCORPORATION
 00A07C TONYANG NYLON CO., LTD.
 00A07D SEEQ TECHNOLOGY, INC.
@@ -3813,28 +5928,28 @@
 00A083 ASIMMPHONY TURKEY
 00A084 DATAPLEX PTY. LTD.
 00A086 AMBER WAVE SYSTEMS, INC.
-00A087 MITEL SEMICONDUCTOR, LTD.
+00A087 Zarlink Semiconductor Ltd.
 00A088 ESSENTIAL COMMUNICATIONS
 00A089 XPOINT TECHNOLOGIES, INC.
 00A08A BROOKTROUT TECHNOLOGY, INC.
 00A08B ASTON ELECTRONIC DESIGNS LTD.
-00A08C MULTIMEDIA LANS, INC.
+00A08C MultiMedia LANs, Inc.
 00A08D JACOMO CORPORATION
 00A08E Nokia Internet Communications
 00A08F DESKNET SYSTEMS, INC.
-00A090 TIMESTEP CORPORATION
+00A090 TimeStep Corporation
 00A091 APPLICOM INTERNATIONAL
 00A092 H. BOLLMANN MANUFACTURERS, LTD
-00A093 B/E AEROSPACE
+00A093 B/E AEROSPACE, Inc.
 00A094 COMSAT CORPORATION
 00A095 ACACIA NETWORKS, INC.
-00A096 MITSUMI ELECTRIC CO., LTD.
+00A096 MITUMI ELECTRIC CO., LTD.
 00A097 JC INFORMATION SYSTEMS
 00A098 NETWORK APPLIANCE CORP.
 00A099 K-NET LTD.
 00A09A NIHON KOHDEN AMERICA
 00A09B QPSX COMMUNICATIONS, LTD.
-00A09C XYPLEX, INC.
+00A09C Xyplex, Inc.
 00A09D JOHNATHON FREEMAN TECHNOLOGIES
 00A09E ICTV
 00A09F COMMVISION CORP.
@@ -3847,7 +5962,7 @@
 00A0A6 M.I. SYSTEMS, K.K.
 00A0A7 VORAX CORPORATION
 00A0A8 RENEX CORPORATION
-00A0A9 GN NETTEST (CANADA) INC.
+00A0A9 GN NETTEST (CANADA) NAVTEL DIVISION
 00A0AA SPACELABS MEDICAL
 00A0AB NETCS INFORMATIONSTECHNIK GMBH
 00A0AC GILAT SATELLITE NETWORKS, LTD.
@@ -3868,7 +5983,7 @@
 00A0BB HILAN GMBH
 00A0BC VIASAT, INCORPORATED
 00A0BD I-TECH CORP.
-00A0BE INTEGRATED CIRCUIT SYSTEMS,INC
+00A0BE INTEGRATED CIRCUIT SYSTEMS, INC. COMMUNICATIONS GROUP
 00A0BF WIRELESS DATA GROUP MOTOROLA
 00A0C0 DIGITAL LINK CORP.
 00A0C1 ORTIVUS MEDICAL AB
@@ -3883,12 +5998,12 @@
 00A0CA FUJITSU DENSO LTD.
 00A0CB ARK TELECOMMUNICATIONS, INC.
 00A0CC LITE-ON COMMUNICATIONS, INC.
-00A0CD DR. JOHANNES HEIDENHAIN GMBH
+00A0CD DR. JOHANNES HEIDENHAIN GmbH
 00A0CE ASTROCOM CORPORATION
 00A0CF SOTAS, INC.
 00A0D0 TEN X TECHNOLOGY, INC.
 00A0D1 INVENTEC CORPORATION
-00A0D2 ALLIED TELESIS INTERNATIONAL
+00A0D2 ALLIED TELESIS INTERNATIONAL CORPORATION
 00A0D3 INSTEM COMPUTER SYSTEMS, LTD.
 00A0D4 RADIOLAN,  INC.
 00A0D5 SIERRA WIRELESS INC.
@@ -3896,14 +6011,14 @@
 00A0D7 KASTEN CHASE APPLIED RESEARCH
 00A0D8 SPECTRA - TEK
 00A0D9 CONVEX COMPUTER CORPORATION
-00A0DA INTEGRATED SYSTEMS
+00A0DA INTEGRATED SYSTEMS Technology, Inc.
 00A0DB FISHER & PAYKEL PRODUCTION
 00A0DC O.N. ELECTRONIC CO., LTD.
 00A0DD AZONIX CORPORATION
 00A0DE YAMAHA CORPORATION
 00A0DF STS TECHNOLOGIES, INC.
 00A0E0 TENNYSON TECHNOLOGIES PTY LTD
-00A0E1 WESTPORT RESEARCH
+00A0E1 WESTPORT RESEARCH ASSOCIATES, INC.
 00A0E2 KEISOKU GIKEN CORP.
 00A0E3 XKL SYSTEMS CORP.
 00A0E4 OPTIQUEST
@@ -3911,9 +6026,9 @@
 00A0E6 DIALOGIC CORPORATION
 00A0E7 CENTRAL DATA CORPORATION
 00A0E8 REUTERS HOLDINGS PLC
-00A0E9 ELECTRONIC RETAILING SYSTEMS
+00A0E9 ELECTRONIC RETAILING SYSTEMS INTERNATIONAL
 00A0EA ETHERCOM CORP.
-00A0EB FASTCOMM COMMUNICATIONS CORP.
+00A0EB Encore Networks
 00A0EC TRANSMITTON LTD.
 00A0ED PRI AUTOMATION
 00A0EE NASHOBA NETWORKS
@@ -3924,7 +6039,7 @@
 00A0F3 STAUBLI
 00A0F4 GE
 00A0F5 RADGUARD LTD.
-00A0F6 AUTOGAS SYSTEMS, INC.
+00A0F6 AutoGas Systems Inc.
 00A0F7 V.I COMPUTER CORP.
 00A0F8 SYMBOL TECHNOLOGIES, INC.
 00A0F9 BINTEC COMMUNICATIONS GMBH
@@ -4016,7 +6131,7 @@
 00C026 LANS TECHNOLOGY CO., LTD.
 00C027 CIPHER SYSTEMS, INC.
 00C028 JASCO CORPORATION
-00C029 KABEL RHEYDT AG
+00C029 Nexans Deutschland AG - ANS
 00C02A OHKURA ELECTRIC CO., LTD.
 00C02B GERLOFF GESELLSCHAFT FUR
 00C02C CENTRUM COMMUNICATIONS, INC.
@@ -4080,7 +6195,7 @@
 00C066 DOCUPOINT, INC.
 00C067 UNITED BARCODE INDUSTRIES
 00C068 PHILIP DRAKE ELECTRONICS LTD.
-00C069 ADAPTIVE BROADBAND CORPORATION
+00C069 Axxcelera Broadband Wireless
 00C06A ZAHNER-ELEKTRIK GMBH & CO. KG
 00C06B OSI PLUS CORPORATION
 00C06C SVEC COMPUTER CORP.
@@ -4157,7 +6272,7 @@
 00C0B3 COMSTAT DATACOMM CORPORATION
 00C0B4 MYSON TECHNOLOGY, INC.
 00C0B5 CORPORATE NETWORK SYSTEMS,INC.
-00C0B6 MERIDIAN DATA, INC.
+00C0B6 Snap Appliance, Inc.
 00C0B7 AMERICAN POWER CONVERSION CORP
 00C0B8 FRASER'S HILL LTD.
 00C0B9 FUNK SOFTWARE, INC.
@@ -4198,7 +6313,7 @@
 00C0DC EOS TECHNOLOGIES, INC.
 00C0DD QLogic Corporation
 00C0DE ZCOMM, INC.
-00C0DF KYE SYSTEMS CORP.
+00C0DF KYE Systems Corp.
 00C0E0 DSC COMMUNICATION CORP.
 00C0E1 SONIC SOLUTIONS
 00C0E2 CALCOMP, INC.
@@ -4275,7 +6390,7 @@
 00D027 APPLIED AUTOMATION, INC.
 00D028 OMNEON VIDEO NETWORKS
 00D029 WAKEFERN FOOD CORPORATION
-00D02A FLEXION SYSTEMS
+00D02A Voxent Systems Ltd.
 00D02B JETCELL, INC.
 00D02C CAMPBELL SCIENTIFIC, INC.
 00D02D ADEMCO
@@ -4294,6 +6409,7 @@
 00D03A ZONEWORX, INC.
 00D03B VISION PRODUCTS PTY. LTD.
 00D03C Vieo, Inc.
+00D03D GALILEO TECHNOLOGY, LTD.
 00D03E ROCKETCHIPS, INC.
 00D03F AMERICAN COMMUNICATION
 00D040 SYSMATE CO., LTD.
@@ -4368,7 +6484,7 @@
 00D085 OTIS ELEVATOR COMPANY
 00D086 FOVEON, INC.
 00D087 MICROFIRST INC.
-00D088 MAINSAIL NETWORKS, INC.
+00D088 Terayon Communications Systems
 00D089 DYNACOLOR, INC.
 00D08A PHOTRON USA
 00D08B ADVA Limited
@@ -4384,7 +6500,7 @@
 00D095 XYLAN CORPORATION
 00D096 3COM EUROPE LTD.
 00D097 CISCO SYSTEMS, INC.
-00D098 IPS AUTOMATION
+00D098 Photon Dynamics Canada Inc.
 00D099 ELCARD OY
 00D09A FILANET CORPORATION
 00D09B SPECTEL LTD.
@@ -4413,9 +6529,9 @@
 00D0B2 XIOTECH CORPORATION
 00D0B3 DRS FLIGHT SAFETY AND
 00D0B4 KATSUJIMA CO., LTD.
-00D0B5 DOTCOM
+00D0B5 IPricot formerly DotCom
 00D0B6 CRESCENT NETWORKS, INC.
-00D0B7 INTEL CORPOTATION
+00D0B7 INTEL CORPORATION
 00D0B8 IOMEGA CORP.
 00D0B9 MICROTEK INTERNATIONAL, INC.
 00D0BA CISCO SYSTEMS, INC.
@@ -4478,7 +6594,7 @@
 00D0F3 SOLARI DI UDINE SPA
 00D0F4 CARINTHIAN TECH INSTITUTE
 00D0F5 ORANGE MICRO, INC.
-00D0F6 NORTHCHURCH COMMUNICATIONS INC
+00D0F6 Alcatel Canada
 00D0F7 NEXT NETS CORPORATION
 00D0F8 FUJIAN STAR TERMINAL
 00D0F9 ACUTE COMMUNICATIONS CORP.
@@ -4520,28 +6636,28 @@
 00E00D RADIANT SYSTEMS
 00E00E AVALON IMAGING SYSTEMS, INC.
 00E00F SHANGHAI BAUD DATA
-00E010 HESS SB-AUTOMATENBAU GMBH
-00E011 UNIDEN SAN DIEGO
-00E012 PLUTO TECHNOLOGIES
+00E010 HESS SB-AUTOMATENBAU GmbH
+00E011 UNIDEN SAN DIEGO R&D CENTER, INC.
+00E012 PLUTO TECHNOLOGIES INTERNATIONAL INC.
 00E013 EASTERN ELECTRONIC CO., LTD.
 00E014 CISCO SYSTEMS, INC.
 00E015 HEIWA CORPORATION
 00E016 RAPID CITY COMMUNICATIONS
-00E017 EXXACT GMBH
+00E017 EXXACT GmbH
 00E018 ASUSTEK COMPUTER INC.
 00E019 ING. GIORDANO ELETTRONICA
 00E01A COMTEC SYSTEMS. CO., LTD.
 00E01B SPHERE COMMUNICATIONS, INC.
 00E01C MOBILITY ELECTRONICSY
-00E01D WEBTV NETWORKS, INC.
+00E01D WebTV NETWORKS, INC.
 00E01E CISCO SYSTEMS, INC.
-00E01F AVIDIA SYSTEMS, INC.
+00E01F AVIDIA Systems, Inc.
 00E020 TECNOMEN OY
 00E021 FREEGATE CORP.
-00E022 MEDIALIGHT INC.
+00E022 MediaLight, Inc.
 00E023 TELRAD
 00E024 GADZOOX NETWORKS
-00E025 DIT CO., LTD.
+00E025 dit CO., LTD.
 00E026 EASTMAN KODAK CO.
 00E027 DUX, INC.
 00E028 APTIX CORPORATION
@@ -4549,13 +6665,13 @@
 00E02A TANDBERG TELEVISION AS
 00E02B EXTREME NETWORKS
 00E02C AST COMPUTER
-00E02D INNOMEDIALOGIC, INC.
+00E02D InnoMediaLogic, Inc.
 00E02E SPC ELECTRONICS CORPORATION
 00E02F MCNS HOLDINGS, L.P.
 00E030 MELITA INTERNATIONAL CORP.
 00E031 HAGIWARA ELECTRIC CO., LTD.
 00E032 MISYS FINANCIAL SYSTEMS, LTD.
-00E033 E.E.P.D. GMBH
+00E033 E.E.P.D. GmbH
 00E034 CISCO SYSTEMS, INC.
 00E035 LOUGHBOROUGH SOUND IMAGES, PLC
 00E036 PIONEER CORPORATION
@@ -4564,64 +6680,64 @@
 00E039 PARADYNE CORP.
 00E03A CABLETRON SYSTEMS, INC.
 00E03B PROMINET CORPORATION
-00E03C ADVANSYS
+00E03C AdvanSys
 00E03D FOCON ELECTRONIC SYSTEMS A/S
 00E03E ALFATECH, INC.
 00E03F JATON CORPORATION
-00E040 DESKSTATION TECHNOLOGY, INC.
+00E040 DeskStation Technology, Inc.
 00E041 CSPI
-00E042 PACOM DATA LTD.
-00E043 VITALCOM
+00E042 Pacom Systems Ltd.
+00E043 VitalCom
 00E044 LSICS CORPORATION
 00E045 TOUCHWAVE, INC.
 00E046 BENTLY NEVADA CORP.
 00E047 INFOCUS SYSTEMS
 00E048 SDL COMMUNICATIONS, INC.
-00E049 MICROWI ELECTRONIC GMBH
-00E04A ENHANCED MESSAGING SYSTEMS,INC
-00E04B JUMP INDUSTRIELLE
+00E049 MICROWI ELECTRONIC GmbH
+00E04A ENHANCED MESSAGING SYSTEMS, INC
+00E04B JUMP INDUSTRIELLE COMPUTERTECHNIK GmbH
 00E04C REALTEK SEMICONDUCTOR CORP.
 00E04D INTERNET INITIATIVE JAPAN, INC
 00E04E SANYO DENKI CO., LTD.
 00E04F CISCO SYSTEMS, INC.
-00E050 EXECUTONE INFORMATION
+00E050 EXECUTONE INFORMATION SYSTEMS, INC.
 00E051 TALX CORPORATION
 00E052 FOUNDRY NETWORKS, INC.
 00E053 CELLPORT LABS, INC.
 00E054 KODAI HITEC CO., LTD.
-00E055 INGENIERIA ELECTRONICA
+00E055 INGENIERIA ELECTRONICA COMERCIAL INELCOM S.A.
 00E056 HOLONTECH CORPORATION
 00E057 HAN MICROTELECOM. CO., LTD.
 00E058 PHASE ONE DENMARK A/S
 00E059 CONTROLLED ENVIRONMENTS, LTD.
 00E05A GALEA NETWORK SECURITY
 00E05B WEST END SYSTEMS CORP.
-00E05C MATSUSHITA KOTOBUKI
+00E05C MATSUSHITA KOTOBUKI ELECTRONICS INDUSTRIES, LTD.
 00E05D UNITEC CO., LTD.
-00E05E JAPAN AVIATION ELECTRONICS
-00E05F E-NET, INC.
+00E05E JAPAN AVIATION ELECTRONICS INDUSTRY, LTD.
+00E05F e-Net, Inc.
 00E060 SHERWOOD
-00E061 EDGEPOINT NETWORKS, INC.
+00E061 EdgePoint Networks, Inc.
 00E062 HOST ENGINEERING
 00E063 CABLETRON - YAGO SYSTEMS, INC.
 00E064 SAMSUNG ELECTRONICS
 00E065 OPTICAL ACCESS INTERNATIONAL
-00E066 PROMAX SYSTEMS, INC.
-00E067 EAC AUTOMATION-CONSULTING GMBH
+00E066 ProMax Systems, Inc.
+00E067 eac AUTOMATION-CONSULTING GmbH
 00E068 MERRIMAC SYSTEMS INC.
-00E069 JAYCOR NETWORKS, INC.
+00E069 JAYCOR
 00E06A KAPSCH AG
 00E06B W&G SPECIAL PRODUCTS
-00E06C BALTIMORE TECHNOLOGIES, LTD.
+00E06C AEP Systems International Ltd
 00E06D COMPUWARE CORPORATION
-00E06E FAR SYSTEMS SPA
-00E06F TERAYON CORP.
+00E06E FAR SYSTEMS S.p.A.
+00E06F Terayon Communications Systems
 00E070 DH TECHNOLOGY
 00E071 EPIS MICROCOMPUTER
 00E072 LYNK
-00E073 NATIONAL AMUSEMENT
+00E073 NATIONAL AMUSEMENT NETWORK, INC.
 00E074 TIERNAN COMMUNICATIONS, INC.
-00E075 ATLAS COMPUTER EQUIPMENT, INC.
+00E075 Verilink Corporation
 00E076 DEVELOPMENT CONCEPTS, INC.
 00E077 WEBGEAR, INC.
 00E078 BERKELEY NETWORKS
@@ -4631,7 +6747,7 @@
 00E07C METTLER-TOLEDO, INC.
 00E07D NETRONIX, INC.
 00E07E WALT DISNEY IMAGINEERING
-00E07F LOGISTISTEM SRL
+00E07F LOGISTISTEM s.r.l.
 00E080 CONTROL RESOURCES CORPORATION
 00E081 TYAN COMPUTER CORP.
 00E082 ANERMA
@@ -4639,11 +6755,11 @@
 00E084 COMPULITE R&D
 00E085 GLOBAL MAINTECH, INC.
 00E086 CYBEX COMPUTER PRODUCTS
-00E087 LECROY
+00E087 LeCroy - Networking Productions Division
 00E088 LTX CORPORATION
 00E089 ION Networks, Inc.
 00E08A GEC AVERY, LTD.
-00E08B QLOGIC CORP.
+00E08B QLogic Corp.
 00E08C NEOPARADIGM LABS, INC.
 00E08D PRESSURE SYSTEMS, INC.
 00E08E UTSTARCOM
@@ -4653,10 +6769,10 @@
 00E092 ADMTEK INCORPORATED
 00E093 ACKFIN NETWORKS
 00E094 OSAI SRL
-00E095 ADVANCED-VISION TECHNOLGIES
+00E095 ADVANCED-VISION TECHNOLGIES CORP.
 00E096 SHIMADZU CORPORATION
 00E097 CARRIER ACCESS CORPORATION
-00E098 ABOCOM SYSTEMS, INC.
+00E098 AboCom Systems, Inc.
 00E099 SAMSON AG
 00E09A POSITRON INDUSTRIES, INC.
 00E09B ENGAGE NETWORKS, INC.
@@ -4665,78 +6781,78 @@
 00E09E QUANTUM CORPORATION
 00E09F PIXEL VISION
 00E0A0 WILTRON CO.
-00E0A1 HIMA PAUL HILDEBRANDT
+00E0A1 HIMA PAUL HILDEBRANDT GmbH Co. KG
 00E0A2 MICROSLATE INC.
 00E0A3 CISCO SYSTEMS, INC.
-00E0A4 ESAOTE S.P.A.
-00E0A5 COMCORE SEMICONDUCTOR, INC.
+00E0A4 ESAOTE S.p.A.
+00E0A5 ComCore Semiconductor, Inc.
 00E0A6 TELOGY NETWORKS, INC.
 00E0A7 IPC INFORMATION SYSTEMS, INC.
-00E0A8 SAT GMBH&CO
+00E0A8 SAT GmbH & Co.
 00E0A9 FUNAI ELECTRIC CO., LTD.
 00E0AA ELECTROSONIC LTD.
 00E0AB DIMAT S.A.
 00E0AC MIDSCO, INC.
 00E0AD EES TECHNOLOGY, LTD.
 00E0AE XAQTI CORPORATION
-00E0AF GENERAL DYNAMICS INFORMATION
+00E0AF GENERAL DYNAMICS INFORMATION SYSTEMS
 00E0B0 CISCO SYSTEMS, INC.
 00E0B1 PACKET ENGINES, INC.
 00E0B2 TELMAX COMMUNICATIONS CORP.
-00E0B3 ETHERWAN SYSTEMS, INC.
+00E0B3 EtherWAN Systems, Inc.
 00E0B4 TECHNO SCOPE CO., LTD.
 00E0B5 ARDENT COMMUNICATIONS CORP.
 00E0B6 Entrada Networks
 00E0B7 PI GROUP, LTD.
 00E0B8 GATEWAY 2000
 00E0B9 BYAS SYSTEMS
-00E0BA BERGHOF AUTOMATIONSTECHNIK
+00E0BA BERGHOF AUTOMATIONSTECHNIK GmbH
 00E0BB NBX CORPORATION
 00E0BC SYMON COMMUNICATIONS, INC.
 00E0BD INTERFACE SYSTEMS, INC.
 00E0BE GENROCO INTERNATIONAL, INC.
-00E0BF TORRENT NETWORKING
-00E0C0 SEIWA ERECTRIC MFG. CO., LTD.
+00E0BF TORRENT NETWORKING TECHNOLOGIES CORP.
+00E0C0 SEIWA ELECTRIC MFG. CO., LTD.
 00E0C1 MEMOREX TELEX JAPAN, LTD.
-00E0C2 NECSY SPA
+00E0C2 NECSY S.p.A.
 00E0C3 SAKAI SYSTEM DEVELOPMENT CORP.
 00E0C4 HORNER ELECTRIC, INC.
 00E0C5 BCOM ELECTRONICS INC.
 00E0C6 LINK2IT, L.L.C.
 00E0C7 EUROTECH SRL
 00E0C8 VIRTUAL ACCESS, LTD.
-00E0C9 AUTOMATEDLOGIC CORPORATION
+00E0C9 AutomatedLogic Corporation
 00E0CA BEST DATA PRODUCTS
 00E0CB RESON, INC.
 00E0CC HERO SYSTEMS, LTD.
 00E0CD SENSIS CORPORATION
 00E0CE ARN
-00E0CF INTEGRATED DEVICE
+00E0CF INTEGRATED DEVICE TECHNOLOGY, INC.
 00E0D0 NETSPEED, INC.
 00E0D1 TELSIS LIMITED
 00E0D2 VERSANET COMMUNICATIONS, INC.
-00E0D3 DATENTECHNIK GMBH
+00E0D3 DATENTECHNIK GmbH
 00E0D4 EXCELLENT COMPUTER
 00E0D5 ARCXEL TECHNOLOGIES, INC.
-00E0D6 COMPUTER & COMMUNICATION
+00E0D6 COMPUTER & COMMUNICATION RESEARCH LAB.
 00E0D7 SUNSHINE ELECTRONICS, INC.
-00E0D8 LANBIT COMPUTER, INC.
+00E0D8 LANBit Computer, Inc.
 00E0D9 TAZMO CO., LTD.
-00E0DA ASSURED ACCESS
-00E0DB VIAVIDEO COMMUNICATIONS
+00E0DA ASSURED ACCESS TECHNOLOGY, INC.
+00E0DB ViaVideo Communications, Inc.
 00E0DC NEXWARE CORP.
 00E0DD ZENITH ELECTRONICS CORPORATION
 00E0DE DATAX NV
 00E0DF KE KOMMUNIKATIONS-ELECTRONIK
 00E0E0 SI ELECTRONICS, LTD.
-00E0E1 G2 NETWORKS, ILNC.
+00E0E1 G2 NETWORKS, INC.
 00E0E2 INNOVA CORP.
-00E0E3 SK-ELEKTRONIK GMBH
-00E0E4 FANUC ROBOTICS NORTH AMERICA,
+00E0E3 SK-ELEKTRONIK GmbH
+00E0E4 FANUC ROBOTICS NORTH AMERICA, Inc.
 00E0E5 CINCO NETWORKS, INC.
 00E0E6 INCAA DATACOM B.V.
 00E0E7 RAYTHEON E-SYSTEMS, INC.
-00E0E8 GRETACODER DATA SYSTEMS AG
+00E0E8 GRETACODER Data Systems AG
 00E0E9 DATA LABS, INC.
 00E0EA INNOVAT COMMUNICATIONS, INC.
 00E0EB DIGICOM SYSTEMS, INCORPORATED
@@ -4747,19 +6863,19 @@
 00E0F0 ABLER TECHNOLOGY, INC.
 00E0F1 THAT CORPORATION
 00E0F2 ARLOTTO COMNET, INC.
-00E0F3 WEBSPRINT COMMUNICATIONS, INC.
-00E0F4 INSIDE TECHNOLOGY A/S
+00E0F3 WebSprint Communications, Inc.
+00E0F4 INSIDE Technology A/S
 00E0F5 TELES AG
 00E0F6 DECISION EUROPE
 00E0F7 CISCO SYSTEMS, INC.
-00E0F8 DIANA CONTROL AB
+00E0F8 DICNA CONTROL AB
 00E0F9 CISCO SYSTEMS, INC.
 00E0FA TRL TECHNOLOGY, LTD.
 00E0FB LEIGHTRONIX, INC.
 00E0FC HUAWEI TECHNOLOGIES CO., LTD.
 00E0FD A-TREND TECHNOLOGY CO., LTD.
 00E0FE CISCO SYSTEMS, INC.
-00E0FF SECURITY DYNAMICS TECHNOLOGIES
+00E0FF SECURITY DYNAMICS TECHNOLOGIES, Inc.
 00E6D3 NIXDORF COMPUTER CORP.
 020701 RACAL-DATACOM
 021C7C PERQ SYSTEMS CORPORATION
@@ -4809,12 +6925,12 @@
 080020 SUN MICROSYSTEMS INC.
 080021 3M COMPANY
 080022 NBI INC.
-080023 MATSUHITA GRAPHIC COMM SYS INC
+080023 Panasonic Communications Co., Ltd.
 080024 10NET COMMUNICATIONS/DCA
 080025 CONTROL DATA
 080026 NORSK DATA A.S.
 080027 CADMUS COMPUTER SYSTEMS
-080028 TEXAS INSTRUMENTS
+080028 Texas Instruments
 080029 MEGATEK CORPORATION
 08002A MOSAIC TECHNOLOGIES INC.
 08002B DIGITAL EQUIPMENT CORPORATION
@@ -4905,10 +7021,10 @@
 080080 AES DATA INC.
 080081 ,ASTECH INC.
 080082 VERITAS SOFTWARE
-080083 SEIKO INSTRUM. AND ELECTRONICS
+080083 Seiko Instruments Inc.
 080084 TOMEN ELECTRONICS CORP.
 080085 ELXSI
-080086 IMAGEN CORPORATION
+080086 KONICA MINOLTA HOLDINGS, INC.
 080087 XYPLEX
 080088 MCDATA CORPORATION
 080089 KINETICS
@@ -4919,7 +7035,8 @@
 08008E TANDEM COMPUTERS
 08008F CHIPCOM CORPORATION
 080090 SONOMA SYSTEMS
-08BBCC AK-NORD EDV VERTRIEBSGES. MBH
+081443 UNIBRAIN S.A.
+08BBCC AK-NORD EDV VERTRIEBSGES. mbH
 10005A IBM CORPORATION
 1000E8 NATIONAL SEMICONDUCTOR
 800010 ATT BELL LABORATORIES
diff -purN linux-2.6.1/drivers/ieee1394/raw1394.c linux-2.5/drivers/ieee1394/raw1394.c
--- linux-2.6.1/drivers/ieee1394/raw1394.c	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/ieee1394/raw1394.c	2004-01-14 23:12:05.000000000 +0000
@@ -38,6 +38,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/vmalloc.h>
+#include <linux/cdev.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <linux/devfs_fs_kernel.h>
@@ -1695,7 +1696,7 @@ static int arm_register(struct file_info
                 spin_unlock_irqrestore(&host_info_lock, flags);
                 return sizeof(struct raw1394_request);
         }
-        retval = hpsb_register_addrspace(&raw1394_highlevel, &arm_ops, req->req.address,
+        retval = hpsb_register_addrspace(&raw1394_highlevel, fi->host, &arm_ops, req->req.address,
                 req->req.address + req->req.length);
         if (retval) {
                /* INSERT ENTRY */
@@ -1782,7 +1783,7 @@ static int arm_unregister(struct file_in
                 spin_unlock_irqrestore(&host_info_lock, flags);
                 return sizeof(struct raw1394_request);
         } 
-        retval = hpsb_unregister_addrspace(&raw1394_highlevel, addr->start);
+        retval = hpsb_unregister_addrspace(&raw1394_highlevel, fi->host, addr->start);
         if (!retval) {
                 printk(KERN_ERR "raw1394: arm_Unregister failed -> EINVAL\n");
                 spin_unlock_irqrestore(&host_info_lock, flags);
@@ -2464,10 +2465,6 @@ static int raw1394_open(struct inode *in
 {
         struct file_info *fi;
 
-        if (ieee1394_file_to_instance(file) > 0) {
-                return -ENXIO;
-        }
-
         fi = kmalloc(sizeof(struct file_info), SLAB_KERNEL);
         if (fi == NULL)
                 return -ENOMEM;
@@ -2554,7 +2551,7 @@ static int raw1394_release(struct inode 
                 }
                 if (!another_host) {
                         DBGMSG("raw1394_release: call hpsb_arm_unregister");
-                        retval = hpsb_unregister_addrspace(&raw1394_highlevel, addr->start);
+                        retval = hpsb_unregister_addrspace(&raw1394_highlevel, fi->host, addr->start);
                         if (!retval) {
                                 ++fail;
                                 printk(KERN_ERR "raw1394_release arm_Unregister failed\n");
@@ -2646,7 +2643,8 @@ static struct hpsb_highlevel raw1394_hig
         .fcp_request = fcp_request,
 };
 
-static struct file_operations file_ops = {
+static struct cdev raw1394_cdev;
+static struct file_operations raw1394_fops = {
 	.owner =	THIS_MODULE,
         .read =		raw1394_read, 
         .write =	raw1394_write,
@@ -2664,8 +2662,10 @@ static int __init init_raw1394(void)
         devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16),
 			S_IFCHR | S_IRUSR | S_IWUSR, RAW1394_DEVICE_NAME);
 
-        if (ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_RAW1394,
-                                      THIS_MODULE, &file_ops)) {
+	cdev_init(&raw1394_cdev, &raw1394_fops);
+	raw1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&raw1394_cdev.kobj, RAW1394_DEVICE_NAME);
+	if (cdev_add(&raw1394_cdev, IEEE1394_RAW1394_DEV, 1)) {
                 HPSB_ERR("raw1394 failed to register minor device block");
                 devfs_remove(RAW1394_DEVICE_NAME);
                 hpsb_unregister_highlevel(&raw1394_highlevel);
@@ -2682,7 +2682,8 @@ static int __init init_raw1394(void)
 static void __exit cleanup_raw1394(void)
 {
 	hpsb_unregister_protocol(&raw1394_driver);
-        ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_RAW1394);
+	cdev_unmap(IEEE1394_RAW1394_DEV, 1);
+	cdev_del(&raw1394_cdev);
         devfs_remove(RAW1394_DEVICE_NAME);
         hpsb_unregister_highlevel(&raw1394_highlevel);
 }
@@ -2690,3 +2691,4 @@ static void __exit cleanup_raw1394(void)
 module_init(init_raw1394);
 module_exit(cleanup_raw1394);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16);
diff -purN linux-2.6.1/drivers/ieee1394/sbp2.c linux-2.5/drivers/ieee1394/sbp2.c
--- linux-2.6.1/drivers/ieee1394/sbp2.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/ieee1394/sbp2.c	2004-01-14 23:20:31.000000000 +0000
@@ -77,7 +77,7 @@
 #include "sbp2.h"
 
 static char version[] __devinitdata =
-	"$Rev: 1082 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1096 $ Ben Collins <bcollins@debian.org>";
 
 /*
  * Module load parameter definitions
@@ -712,6 +712,18 @@ static struct sbp2scsi_host_info *sbp2_a
 		return NULL;
 	}
 
+	/* Register our sbp2 status address space... */
+	hpsb_register_addrspace(&sbp2_highlevel, host, &sbp2_ops,
+				SBP2_STATUS_FIFO_ADDRESS,
+				SBP2_STATUS_FIFO_ADDRESS +
+				SBP2_STATUS_FIFO_ENTRY_TO_OFFSET(SBP2SCSI_MAX_SCSI_IDS+1));
+
+	/* Handle data movement if physical dma is not enabled/supported
+	 * on host controller */
+#ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
+	hpsb_register_addrspace(&sbp2_highlevel, host, &sbp2_physdma_ops, 0x0ULL, 0xfffffffcULL);
+#endif
+
 	hi = hpsb_create_hostinfo(&sbp2_highlevel, host, sizeof(*hi));
 	if (!hi) {
 		SBP2_ERR("failed to allocate hostinfo");
@@ -2881,17 +2893,6 @@ static int sbp2_module_init(void)
 	/* Register our high level driver with 1394 stack */
 	hpsb_register_highlevel(&sbp2_highlevel);
 
-	/* Register our sbp2 status address space... */
-	hpsb_register_addrspace(&sbp2_highlevel, &sbp2_ops, SBP2_STATUS_FIFO_ADDRESS,
-				SBP2_STATUS_FIFO_ADDRESS + 
-				SBP2_STATUS_FIFO_ENTRY_TO_OFFSET(SBP2SCSI_MAX_SCSI_IDS+1));
-
-	/* Handle data movement if physical dma is not enabled/supported
-	 * on host controller */
-#ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
-	hpsb_register_addrspace(&sbp2_highlevel, &sbp2_physdma_ops, 0x0ULL, 0xfffffffcULL);
-#endif
-
 	hpsb_register_protocol(&sbp2_driver);
 
 	return 0;
diff -purN linux-2.6.1/drivers/ieee1394/video1394.c linux-2.5/drivers/ieee1394/video1394.c
--- linux-2.6.1/drivers/ieee1394/video1394.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/video1394.c	2004-01-14 23:10:13.000000000 +0000
@@ -46,6 +46,7 @@
 #include <linux/mm.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 
 #include "ieee1394.h"
 #include "ieee1394_types.h"
@@ -1231,6 +1232,7 @@ static int video1394_release(struct inod
 	return 0;
 }
 
+static struct cdev video1394_cdev;
 static struct file_operations video1394_fops=
 {
 	.owner =	THIS_MODULE,
@@ -1445,18 +1447,18 @@ static void __exit video1394_exit_module
 	hpsb_unregister_highlevel(&video1394_highlevel);
 
 	devfs_remove(VIDEO1394_DRIVER_NAME);
-	ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_VIDEO1394);
+	cdev_unmap(IEEE1394_VIDEO1394_DEV, 16);
+	cdev_del(&video1394_cdev);
 
 	PRINT_G(KERN_INFO, "Removed " VIDEO1394_DRIVER_NAME " module");
 }
 
 static int __init video1394_init_module (void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_VIDEO1394,
-					THIS_MODULE, &video1394_fops);
-	if (ret) {
+	cdev_init(&video1394_cdev, &video1394_fops);
+	video1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&video1394_cdev.kobj, VIDEO1394_DRIVER_NAME);
+	if (cdev_add(&video1394_cdev, IEEE1394_VIDEO1394_DEV, 16)) {
 		PRINT_G(KERN_ERR, "video1394: unable to get minor device block");
 		return -EIO;
         }
@@ -1468,25 +1470,29 @@ static int __init video1394_init_module 
 	hpsb_register_protocol(&video1394_driver);
 
 #ifdef CONFIG_COMPAT
-	/* First the compatible ones */
-	ret = register_ioctl32_conversion(VIDEO1394_IOC_LISTEN_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNLISTEN_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNTALK_CHANNEL, NULL);
-
-	/* These need translation */
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_QUEUE_BUFFER,
-				    video1394_w_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_WAIT_BUFFER,
-				    video1394_wr_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_QUEUE_BUFFER,
-				    video1394_queue_buf32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_TALK_WAIT_BUFFER,
-				    video1394_w_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_POLL_BUFFER,
-				    video1394_wr_wait32);
-	if (ret)
-		PRINT_G(KERN_INFO, "Error registering ioctl32 translations");
+	{
+		int ret;
+
+		/* First the compatible ones */
+		ret = register_ioctl32_conversion(VIDEO1394_IOC_LISTEN_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNLISTEN_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNTALK_CHANNEL, NULL);
+
+		/* These need translation */
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_QUEUE_BUFFER,
+					    video1394_w_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_WAIT_BUFFER,
+					    video1394_wr_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_QUEUE_BUFFER,
+					    video1394_queue_buf32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_TALK_WAIT_BUFFER,
+					    video1394_w_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_POLL_BUFFER,
+					    video1394_wr_wait32);
+		if (ret)
+			PRINT_G(KERN_INFO, "Error registering ioctl32 translations");
+	}
 #endif
 
 	PRINT_G(KERN_INFO, "Installed " VIDEO1394_DRIVER_NAME " module");
@@ -1496,3 +1502,4 @@ static int __init video1394_init_module 
 
 module_init(video1394_init_module);
 module_exit(video1394_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_VIDEO1394 * 16);
diff -purN linux-2.6.1/drivers/net/3c527.c linux-2.5/drivers/net/3c527.c
--- linux-2.6.1/drivers/net/3c527.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/net/3c527.c	2004-01-10 14:38:57.000000000 +0000
@@ -1,9 +1,10 @@
-/* 3c527.c: 3Com Etherlink/MC32 driver for Linux 2.4
+/* 3c527.c: 3Com Etherlink/MC32 driver for Linux 2.4 and 2.6.
  *
  *	(c) Copyright 1998 Red Hat Software Inc
  *	Written by Alan Cox. 
  *	Further debugging by Carl Drougge.
- *      Modified by Richard Procter (rnp@netlink.co.nz)
+ *      Initial SMP support by Felipe W Damasio <felipewd@terra.com.br>
+ *      Heavily modified by Richard Procter <rnp@paradise.net.nz>
  *
  *	Based on skeleton.c written 1993-94 by Donald Becker and ne2.c
  *	(for the MCA stuff) written by Wim Dumon.
@@ -17,11 +18,11 @@
  */
 
 #define DRV_NAME		"3c527"
-#define DRV_VERSION		"0.6a"
-#define DRV_RELDATE		"2001/11/17"
+#define DRV_VERSION		"0.7-SMP"
+#define DRV_RELDATE		"2003/09/21"
 
 static const char *version =
-DRV_NAME ".c:v" DRV_VERSION " " DRV_RELDATE " Richard Proctor (rnp@netlink.co.nz)\n";
+DRV_NAME ".c:v" DRV_VERSION " " DRV_RELDATE " Richard Procter <rnp@paradise.net.nz>\n";
 
 /**
  * DOC: Traps for the unwary
@@ -100,7 +101,9 @@ DRV_NAME ".c:v" DRV_VERSION " " DRV_RELD
 #include <linux/string.h>
 #include <linux/wait.h>
 #include <linux/ethtool.h>
+#include <linux/completion.h>
 
+#include <asm/semaphore.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/bitops.h>
@@ -143,19 +146,19 @@ static unsigned int mc32_debug = NET_DEB
 static const int WORKAROUND_82586=1;
 
 /* Pointers to buffers and their on-card records */
-
 struct mc32_ring_desc 
 {
 	volatile struct skb_header *p;                    
 	struct sk_buff *skb;          
 };
 
-
 /* Information that needs to be kept for each board. */
 struct mc32_local 
 {
-	struct net_device_stats net_stats;
 	int slot;
+
+	u32 base;
+	struct net_device_stats net_stats;
 	volatile struct mc32_mailbox *rx_box;
 	volatile struct mc32_mailbox *tx_box;
 	volatile struct mc32_mailbox *exec_box;
@@ -165,22 +168,23 @@ struct mc32_local 
         u16 tx_len;             /* Transmit list count */ 
         u16 rx_len;             /* Receive list count */
 
-	u32 base;
-	u16 exec_pending;
-	u16 mc_reload_wait;	/* a multicast load request is pending */
+	u16 xceiver_desired_state; /* HALTED or RUNNING */
+	u16 cmd_nonblocking;    /* Thread is uninterested in command result */
+	u16 mc_reload_wait;	/* A multicast load request is pending */
 	u32 mc_list_valid;	/* True when the mclist is set */
-	u16 xceiver_state;      /* Current transceiver state. bitmapped */ 
-	u16 desired_state;      /* The state we want the transceiver to be in */ 
-	atomic_t tx_count;	/* buffers left */
-	wait_queue_head_t event;
 
 	struct mc32_ring_desc tx_ring[TX_RING_LEN];	/* Host Transmit ring */
 	struct mc32_ring_desc rx_ring[RX_RING_LEN];	/* Host Receive ring */
 
+	atomic_t tx_count;	/* buffers left */
+	atomic_t tx_ring_head;  /* index to tx en-queue end */
 	u16 tx_ring_tail;       /* index to tx de-queue end */
-	u16 tx_ring_head;       /* index to tx en-queue end */
 
 	u16 rx_ring_tail;       /* index to rx de-queue end */ 
+
+	struct semaphore cmd_mutex;    /* Serialises issuing of execute commands */
+        struct completion execution_cmd; /* Card has completed an execute command */
+	struct completion xceiver_cmd;   /* Card has completed a tx or rx command */
 };
 
 /* The station (ethernet) address prefix, used for a sanity check. */
@@ -236,7 +240,6 @@ int __init mc32_probe(struct net_device 
 {
 	static int current_mca_slot = -1;
 	int i;
-	int adapter_found = 0;
 
 	SET_MODULE_OWNER(dev);
 
@@ -247,11 +250,11 @@ int __init mc32_probe(struct net_device 
 	   Autodetecting MCA cards is extremely simple. 
 	   Just search for the card. */
 
-	for(i = 0; (mc32_adapters[i].name != NULL) && !adapter_found; i++) {
+	for(i = 0; (mc32_adapters[i].name != NULL); i++) {
 		current_mca_slot = 
 			mca_find_unused_adapter(mc32_adapters[i].id, 0);
 
-		if((current_mca_slot != MCA_NOTFOUND) && !adapter_found) {
+		if(current_mca_slot != MCA_NOTFOUND) {
 			if(!mc32_probe1(dev, current_mca_slot))
 			{
 				mca_set_adapter_name(current_mca_slot, 
@@ -409,7 +412,7 @@ static int __init mc32_probe1(struct net
 	 *	Grab the IRQ
 	 */
 
-	i = request_irq(dev->irq, &mc32_interrupt, SA_SHIRQ, dev->name, dev);
+	i = request_irq(dev->irq, &mc32_interrupt, SA_SHIRQ | SA_SAMPLE_RANDOM, dev->name, dev);
 	if (i) {
 		release_region(dev->base_addr, MC32_IO_EXTENT);
 		printk(KERN_ERR "%s: unable to get IRQ %d.\n", dev->name, dev->irq);
@@ -498,7 +501,9 @@ static int __init mc32_probe1(struct net
 	lp->tx_len 		= lp->exec_box->data[9];   /* Transmit list count */ 
 	lp->rx_len 		= lp->exec_box->data[11];  /* Receive list count */
 
-	init_waitqueue_head(&lp->event);
+	init_MUTEX_LOCKED(&lp->cmd_mutex);
+	init_completion(&lp->execution_cmd);
+	init_completion(&lp->xceiver_cmd);
 	
 	printk("%s: Firmware Rev %d. %d RX buffers, %d TX buffers. Base of 0x%08X.\n",
 		dev->name, lp->exec_box->data[12], lp->rx_len, lp->tx_len, lp->base);
@@ -511,10 +516,6 @@ static int __init mc32_probe1(struct net
 	dev->tx_timeout		= mc32_timeout;
 	dev->watchdog_timeo	= HZ*5;	/* Board does all the work */
 	dev->ethtool_ops	= &netdev_ethtool_ops;
-	
-	lp->xceiver_state = HALTED; 
-	
-	lp->tx_ring_tail=lp->tx_ring_head=0;
 
 	/* Fill in the fields of the device structure with ethernet values. */
 	ether_setup(dev);
@@ -539,7 +540,7 @@ err_exit_irq:
  *	status of any pending commands and takes very little time at all.
  */
  
-static void mc32_ready_poll(struct net_device *dev)
+static inline void mc32_ready_poll(struct net_device *dev)
 {
 	int ioaddr = dev->base_addr;
 	while(!(inb(ioaddr+HOST_STATUS)&HOST_STATUS_CRR));
@@ -554,31 +555,38 @@ static void mc32_ready_poll(struct net_d
  *	@len: Length of the data block
  *
  *	Send a command from interrupt state. If there is a command
- *	currently being executed then we return an error of -1. It simply
- *	isn't viable to wait around as commands may be slow. Providing we
- *	get in, we busy wait for the board to become ready to accept the
- *	command and issue it. We do not wait for the command to complete
- *	--- the card will interrupt us when it's done.
+ *	currently being executed then we return an error of -1. It
+ *	simply isn't viable to wait around as commands may be
+ *	slow. This can theoretically be starved on SMP, but it's hard
+ *	to see a realistic situation.  We do not wait for the command
+ *	to complete --- we rely on the interrupt handler to tidy up
+ *	after us.
  */
 
 static int mc32_command_nowait(struct net_device *dev, u16 cmd, void *data, int len)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
 	int ioaddr = dev->base_addr;
+	int ret = -1;
 
-	if(lp->exec_pending)
-		return -1;
-	
-	lp->exec_pending=3;
-	lp->exec_box->mbox=0;
-	lp->exec_box->mbox=cmd;
-	memcpy((void *)lp->exec_box->data, data, len);
-	barrier();	/* the memcpy forgot the volatile so be sure */
+	if (down_trylock(&lp->cmd_mutex) == 0)
+	{
+		lp->cmd_nonblocking=1;
+		lp->exec_box->mbox=0;
+		lp->exec_box->mbox=cmd;
+		memcpy((void *)lp->exec_box->data, data, len);
+		barrier();	/* the memcpy forgot the volatile so be sure */
+
+		/* Send the command */
+		mc32_ready_poll(dev);
+		outb(1<<6, ioaddr+HOST_CMD);
 
-	/* Send the command */
-	while(!(inb(ioaddr+HOST_STATUS)&HOST_STATUS_CRR));
-	outb(1<<6, ioaddr+HOST_CMD);	
-	return 0;
+		ret = 0;
+
+		/* Interrupt handler will signal mutex on completion */
+	}
+
+	return ret;
 }
 
 
@@ -592,76 +600,47 @@ static int mc32_command_nowait(struct ne
  *	Sends exec commands in a user context. This permits us to wait around
  *	for the replies and also to wait for the command buffer to complete
  *	from a previous command before we execute our command. After our 
- *	command completes we will complete any pending multicast reload
+ *	command completes we will attempt any pending multicast reload
  *	we blocked off by hogging the exec buffer.
  *
  *	You feed the card a command, you wait, it interrupts you get a 
  *	reply. All well and good. The complication arises because you use
  *	commands for filter list changes which come in at bh level from things
  *	like IPV6 group stuff.
- *
- *	We have a simple state machine
- *
- *	0	- nothing issued
- *
- *	1	- command issued, wait reply
- *
- *	2	- reply waiting - reader then goes to state 0
- *
- *	3	- command issued, trash reply. In which case the irq
- *		  takes it back to state 0
- *
  */
   
 static int mc32_command(struct net_device *dev, u16 cmd, void *data, int len)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
 	int ioaddr = dev->base_addr;
-	unsigned long flags;
 	int ret = 0;
 	
+	down(&lp->cmd_mutex);
+
 	/*
-	 *	Wait for a command
-	 */
-	 
-	save_flags(flags);
-	cli();
-	 
-	while(lp->exec_pending)
-		sleep_on(&lp->event);
-		
-	/*
-	 *	Issue mine
+	 *     My Turn
 	 */
 
-	lp->exec_pending=1;
-	
-	restore_flags(flags);
-	
+	lp->cmd_nonblocking=0;
 	lp->exec_box->mbox=0;
 	lp->exec_box->mbox=cmd;
 	memcpy((void *)lp->exec_box->data, data, len);
 	barrier();	/* the memcpy forgot the volatile so be sure */
 
-	/* Send the command */
-	while(!(inb(ioaddr+HOST_STATUS)&HOST_STATUS_CRR));
-	outb(1<<6, ioaddr+HOST_CMD);	
-
-	save_flags(flags);
-	cli();
+	mc32_ready_poll(dev);
+	outb(1<<6, ioaddr+HOST_CMD);
 
-	while(lp->exec_pending!=2)
-		sleep_on(&lp->event);
-	lp->exec_pending=0;
-	restore_flags(flags);
+	wait_for_completion(&lp->execution_cmd);
 	
 	if(lp->exec_box->mbox&(1<<13))
 		ret = -1;
 
+	up(&lp->cmd_mutex);
+
 	/*
-	 *	A multicast set got blocked - do it now
-	 */
-		
+	 *	A multicast set got blocked - try it now
+         */
+
 	if(lp->mc_reload_wait)
 	{
 		mc32_reset_multicast_list(dev);
@@ -678,11 +657,9 @@ static int mc32_command(struct net_devic
  *	This may be called from the interrupt state, where it is used
  *	to restart the rx ring if the card runs out of rx buffers. 
  *	
- * 	First, we check if it's ok to start the transceiver. We then show
- * 	the card where to start in the rx ring and issue the
- * 	commands to start reception and transmission. We don't wait
- * 	around for these to complete.
- */ 
+ * 	We must first check if it's ok to (re)start the transceiver. See
+ *      mc32_close for details.
+ */
 
 static void mc32_start_transceiver(struct net_device *dev) {
 
@@ -690,24 +667,20 @@ static void mc32_start_transceiver(struc
 	int ioaddr = dev->base_addr;
 
 	/* Ignore RX overflow on device closure */ 
-	if (lp->desired_state==HALTED)  
+	if (lp->xceiver_desired_state==HALTED)
 		return; 
 
+	/* Give the card the offset to the post-EOL-bit RX descriptor */
 	mc32_ready_poll(dev); 
-
-	lp->tx_box->mbox=0;
 	lp->rx_box->mbox=0;
-
-	/* Give the card the offset to the post-EOL-bit RX descriptor */ 
 	lp->rx_box->data[0]=lp->rx_ring[prev_rx(lp->rx_ring_tail)].p->next; 
-
 	outb(HOST_CMD_START_RX, ioaddr+HOST_CMD);      
 
 	mc32_ready_poll(dev); 
+	lp->tx_box->mbox=0;
 	outb(HOST_CMD_RESTRT_TX, ioaddr+HOST_CMD);   /* card ignores this on RX restart */ 
 	
 	/* We are not interrupted on start completion */ 
-	lp->xceiver_state=RUNNING; 
 }
 
 
@@ -727,25 +700,17 @@ static void mc32_halt_transceiver(struct
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
 	int ioaddr = dev->base_addr;
-	unsigned long flags;
 
 	mc32_ready_poll(dev);	
-
-	lp->tx_box->mbox=0;
 	lp->rx_box->mbox=0;
-
 	outb(HOST_CMD_SUSPND_RX, ioaddr+HOST_CMD);			
+	wait_for_completion(&lp->xceiver_cmd);
+
 	mc32_ready_poll(dev); 
+	lp->tx_box->mbox=0;
 	outb(HOST_CMD_SUSPND_TX, ioaddr+HOST_CMD);	
-		
-	save_flags(flags);
-	cli();
-		
-	while(lp->xceiver_state!=HALTED) 
-		sleep_on(&lp->event); 
-		
-	restore_flags(flags);	
-} 
+	wait_for_completion(&lp->xceiver_cmd);
+}
 
 
 /**
@@ -756,7 +721,7 @@ static void mc32_halt_transceiver(struct
  *	the point where mc32_start_transceiver() can be called.
  *
  *	The card sets up the receive ring for us. We are required to use the
- *	ring it provides although we can change the size of the ring.
+ *	ring it provides, although the size of the ring is configurable.
  *
  * 	We allocate an sk_buff for each ring entry in turn and
  * 	initalise its house-keeping info. At the same time, we read
@@ -777,7 +742,7 @@ static int mc32_load_rx_ring(struct net_
 	
 	rx_base=lp->rx_chain;
 
-	for(i=0;i<RX_RING_LEN;i++)
+	for(i=0; i<RX_RING_LEN; i++)
 	{
 		lp->rx_ring[i].skb=alloc_skb(1532, GFP_KERNEL);
 		skb_reserve(lp->rx_ring[i].skb, 18);  
@@ -814,21 +779,19 @@ static int mc32_load_rx_ring(struct net_
  *
  *	Free the buffer for each ring slot. This may be called 
  *      before mc32_load_rx_ring(), eg. on error in mc32_open().
+ *      Requires rx skb pointers to point to a valid skb, or NULL.
  */
 
 static void mc32_flush_rx_ring(struct net_device *dev)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
-	
-	struct sk_buff *skb;
 	int i; 
 
 	for(i=0; i < RX_RING_LEN; i++) 
 	{ 
-		skb = lp->rx_ring[i].skb;
-		if (skb!=NULL) {
-			kfree_skb(skb);
-			skb=NULL; 
+		if (lp->rx_ring[i].skb) {
+			dev_kfree_skb(lp->rx_ring[i].skb);
+			lp->rx_ring[i].skb = NULL;
 		}
 		lp->rx_ring[i].p=NULL; 
 	} 
@@ -860,7 +823,7 @@ static void mc32_load_tx_ring(struct net
 
 	tx_base=lp->tx_box->data[0]; 
 
-	for(i=0;i<lp->tx_len;i++) 
+	for(i=0 ; i<TX_RING_LEN ; i++)
 	{
 		p=isa_bus_to_virt(lp->base+tx_base);
 		lp->tx_ring[i].p=p; 
@@ -869,11 +832,12 @@ static void mc32_load_tx_ring(struct net
 		tx_base=p->next;
 	}
 
-	/* -1 so that tx_ring_head cannot "lap" tx_ring_tail,           */
-	/* which would be bad news for mc32_tx_ring as cur. implemented */ 
+	/* -1 so that tx_ring_head cannot "lap" tx_ring_tail */
+	/* see mc32_tx_ring */
 
 	atomic_set(&lp->tx_count, TX_RING_LEN-1); 
-	lp->tx_ring_head=lp->tx_ring_tail=0; 
+	atomic_set(&lp->tx_ring_head, 0); 
+	lp->tx_ring_tail=0; 
 } 
 
 
@@ -881,47 +845,29 @@ static void mc32_load_tx_ring(struct net
  *	mc32_flush_tx_ring 	-	free transmit ring
  *	@lp: Local data of 3c527 to flush the tx ring of
  *
- *	We have to consider two cases here. We want to free the pending
- *	buffers only. If the ring buffer head is past the start then the
- *	ring segment we wish to free wraps through zero. The tx ring 
- *	house-keeping variables are then reset.
+ *      If the ring is non-empty, zip over the it, freeing any
+ *      allocated skb_buffs.  The tx ring house-keeping variables are
+ *      then reset. Requires rx skb pointers to point to a valid skb,
+ *      or NULL.
  */
 
 static void mc32_flush_tx_ring(struct net_device *dev)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
-	
-	if(lp->tx_ring_tail!=lp->tx_ring_head)
+	int i;
+
+	for (i=0; i < TX_RING_LEN; i++)
 	{
-		int i;	
-		if(lp->tx_ring_tail < lp->tx_ring_head)
+		if (lp->tx_ring[i].skb)
 		{
-			for(i=lp->tx_ring_tail;i<lp->tx_ring_head;i++)
-			{
-				dev_kfree_skb(lp->tx_ring[i].skb);
-				lp->tx_ring[i].skb=NULL;
-				lp->tx_ring[i].p=NULL; 
-			}
-		}
-		else
-		{
-			for(i=lp->tx_ring_tail; i<TX_RING_LEN; i++) 
-			{
-				dev_kfree_skb(lp->tx_ring[i].skb);
-				lp->tx_ring[i].skb=NULL;
-				lp->tx_ring[i].p=NULL; 
-			}
-			for(i=0; i<lp->tx_ring_head; i++) 
-			{
-				dev_kfree_skb(lp->tx_ring[i].skb);
-				lp->tx_ring[i].skb=NULL;
-				lp->tx_ring[i].p=NULL; 
-			}
+			dev_kfree_skb(lp->tx_ring[i].skb);
+			lp->tx_ring[i].skb = NULL;
 		}
 	}
-	
+
 	atomic_set(&lp->tx_count, 0); 
-	lp->tx_ring_tail=lp->tx_ring_head=0;
+	atomic_set(&lp->tx_ring_head, 0); 
+	lp->tx_ring_tail=0;
 }
  	
 
@@ -958,6 +904,12 @@ static int mc32_open(struct net_device *
 	regs|=HOST_CTRL_INTE;
 	outb(regs, ioaddr+HOST_CTRL);
 	
+	/*
+	 *      Allow ourselves to issue commands
+	 */
+
+	up(&lp->cmd_mutex);
+
 
 	/*
 	 *	Send the indications on command
@@ -1010,7 +962,7 @@ static int mc32_open(struct net_device *
 		return -ENOBUFS;
 	}
 
-	lp->desired_state = RUNNING; 
+	lp->xceiver_desired_state = RUNNING;
 	
 	/* And finally, set the ball rolling... */
 	mc32_start_transceiver(dev);
@@ -1047,61 +999,64 @@ static void mc32_timeout(struct net_devi
  *	Transmit a buffer. This normally means throwing the buffer onto
  *	the transmit queue as the queue is quite large. If the queue is
  *	full then we set tx_busy and return. Once the interrupt handler
- *	gets messages telling it to reclaim transmit queue entries we will
+ *	gets messages telling it to reclaim transmit queue entries, we will
  *	clear tx_busy and the kernel will start calling this again.
  *
- *	We use cli rather than spinlocks. Since I have no access to an SMP
- *	MCA machine I don't plan to change it. It is probably the top 
- *	performance hit for this driver on SMP however.
+ *      We do not disable interrupts or acquire any locks; this can
+ *      run concurrently with mc32_tx_ring(), and the function itself
+ *      is serialised at a higher layer. However, similarly for the
+ *      card itself, we must ensure that we update tx_ring_head only
+ *      after we've established a valid packet on the tx ring (and
+ *      before we let the card "see" it, to prevent it racing with the
+ *      irq handler).
+ * 
  */
 
 static int mc32_send_packet(struct sk_buff *skb, struct net_device *dev)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
-	unsigned long flags;
-
+	u32 head = atomic_read(&lp->tx_ring_head);
+	
 	volatile struct skb_header *p, *np;
 
 	netif_stop_queue(dev);
 
-	save_flags(flags);
-	cli();
-		
-	if(atomic_read(&lp->tx_count)==0)
-	{
-		restore_flags(flags);
+	if(atomic_read(&lp->tx_count)==0) {
 		return 1;
 	}
 
+	skb = skb_padto(skb, ETH_ZLEN);
+	if (skb == NULL) {
+		netif_wake_queue(dev);
+		return 0;
+	}
+
 	atomic_dec(&lp->tx_count); 
 
 	/* P is the last sending/sent buffer as a pointer */
-	p=lp->tx_ring[lp->tx_ring_head].p; 
+	p=lp->tx_ring[head].p;
 		
-	lp->tx_ring_head=next_tx(lp->tx_ring_head); 
+	head = next_tx(head);
 
 	/* NP is the buffer we will be loading */
-	np=lp->tx_ring[lp->tx_ring_head].p; 
-
-   	if (skb->len < ETH_ZLEN) {
-   		skb = skb_padto(skb, ETH_ZLEN);
-   		if (skb == NULL)
-   			goto out;
-   	}
-
+	np=lp->tx_ring[head].p; 
+	
 	/* We will need this to flush the buffer out */
-	lp->tx_ring[lp->tx_ring_head].skb = skb;
-   	   
-	np->length = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len; 
-			
+	lp->tx_ring[head].skb=skb;
+
+	np->length      = unlikely(skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;			
 	np->data	= isa_virt_to_bus(skb->data);
 	np->status	= 0;
 	np->control     = CONTROL_EOP | CONTROL_EOL;     
 	wmb();
 		
-	p->control     &= ~CONTROL_EOL;     /* Clear EOL on p */ 
-out:	
-	restore_flags(flags);
+	/*
+	 * The new frame has been setup; we can now
+	 * let the interrupt handler and card "see" it
+	 */
+
+	atomic_set(&lp->tx_ring_head, head); 
+	p->control     &= ~CONTROL_EOL;
 
 	netif_wake_queue(dev);
 	return 0;
@@ -1182,10 +1137,11 @@ static void mc32_rx_ring(struct net_devi
 {
 	struct mc32_local *lp=dev->priv;		
 	volatile struct skb_header *p;
-	u16 rx_ring_tail = lp->rx_ring_tail;
-	u16 rx_old_tail = rx_ring_tail; 
-
+	u16 rx_ring_tail;
+	u16 rx_old_tail;
 	int x=0;
+
+	rx_old_tail = rx_ring_tail = lp->rx_ring_tail;
 	
 	do
 	{ 
@@ -1275,9 +1231,14 @@ static void mc32_tx_ring(struct net_devi
 	struct mc32_local *lp=(struct mc32_local *)dev->priv;
 	volatile struct skb_header *np;
 
-	/* NB: lp->tx_count=TX_RING_LEN-1 so that tx_ring_head cannot "lap" tail here */
+	/*
+	 * We rely on head==tail to mean 'queue empty'.
+	 * This is why lp->tx_count=TX_RING_LEN-1: in order to prevent
+	 * tx_ring_head wrapping to tail and confusing a 'queue empty'
+	 * condition with 'queue full'
+	 */
 
-	while (lp->tx_ring_tail != lp->tx_ring_head)  
+	while (lp->tx_ring_tail != atomic_read(&lp->tx_ring_head))  
 	{   
 		u16 t; 
 
@@ -1388,8 +1349,7 @@ static irqreturn_t mc32_interrupt(int ir
 				break;
 			case 3: /* Halt */
 			case 4: /* Abort */
-				lp->xceiver_state |= TX_HALTED; 
-				wake_up(&lp->event);
+				complete(&lp->xceiver_cmd);
 				break;
 			default:
 				printk("%s: strange tx ack %d\n", dev->name, status&7);
@@ -1404,8 +1364,7 @@ static irqreturn_t mc32_interrupt(int ir
 				break;
 			case 3: /* Halt */
 			case 4: /* Abort */
-				lp->xceiver_state |= RX_HALTED;
-				wake_up(&lp->event);
+				complete(&lp->xceiver_cmd);
 				break;
 			case 6:
 				/* Out of RX buffers stat */
@@ -1421,26 +1380,17 @@ static irqreturn_t mc32_interrupt(int ir
 		status>>=3;
 		if(status&1)
 		{
-
-			/* 0=no 1=yes 2=replied, get cmd, 3 = wait reply & dump it */
-			
-			if(lp->exec_pending!=3) {
-				lp->exec_pending=2;
-				wake_up(&lp->event);
-			}
-			else 
-			{				
-			  	lp->exec_pending=0;
-
-				/* A new multicast set may have been
-				   blocked while the old one was
-				   running. If so, do it now. */
+			/*
+			 * No thread is waiting: we need to tidy
+			 * up ourself.
+			 */
 				   
+			if (lp->cmd_nonblocking) {
+				up(&lp->cmd_mutex);
 				if (lp->mc_reload_wait) 
 					mc32_reset_multicast_list(dev);
-				else 
-					wake_up(&lp->event);			       
 			}
+			else complete(&lp->execution_cmd);
 		}
 		if(status&2)
 		{
@@ -1493,12 +1443,12 @@ static irqreturn_t mc32_interrupt(int ir
 static int mc32_close(struct net_device *dev)
 {
 	struct mc32_local *lp = (struct mc32_local *)dev->priv;
-
 	int ioaddr = dev->base_addr;
+
 	u8 regs;
 	u16 one=1;
 	
-	lp->desired_state = HALTED;
+	lp->xceiver_desired_state = HALTED;
 	netif_stop_queue(dev);
 
 	/*
@@ -1511,11 +1461,10 @@ static int mc32_close(struct net_device 
 
 	mc32_halt_transceiver(dev); 
 	
-	/* Catch any waiting commands */
+	/* Ensure we issue no more commands beyond this point */
+
+	down(&lp->cmd_mutex);
 	
-	while(lp->exec_pending==1)
-		sleep_on(&lp->event);
-	       
 	/* Ok the card is now stopping */	
 	
 	regs=inb(ioaddr+HOST_CTRL);
@@ -1542,12 +1491,9 @@ static int mc32_close(struct net_device 
 
 static struct net_device_stats *mc32_get_stats(struct net_device *dev)
 {
-	struct mc32_local *lp;
+	struct mc32_local *lp = (struct mc32_local *)dev->priv;
 	
 	mc32_update_stats(dev); 
-
-	lp = (struct mc32_local *)dev->priv;
-
 	return &lp->net_stats;
 }
 
diff -purN linux-2.6.1/drivers/net/3c527.h linux-2.5/drivers/net/3c527.h
--- linux-2.6.1/drivers/net/3c527.h	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/net/3c527.h	2004-01-10 15:33:28.000000000 +0000
@@ -27,10 +27,8 @@
 
 #define HOST_RAMPAGE		8
 
-#define RX_HALTED (1<<0)
-#define TX_HALTED (1<<1)  
-#define HALTED (RX_HALTED | TX_HALTED)
-#define RUNNING 0
+#define HALTED 0
+#define RUNNING 1
 
 struct mc32_mailbox
 {
diff -purN linux-2.6.1/drivers/net/68360enet.c linux-2.5/drivers/net/68360enet.c
--- linux-2.6.1/drivers/net/68360enet.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/net/68360enet.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,951 +0,0 @@
-/*
- * Ethernet driver for Motorola MPC8xx.
- * Copyright (c) 2000 Michael Leslie <mleslie@lineo.com>
- * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)
- *
- * I copied the basic skeleton from the lance driver, because I did not
- * know how to write the Linux driver, but I did know how the LANCE worked.
- *
- * This version of the driver is somewhat selectable for the different
- * processor/board combinations.  It works for the boards I know about
- * now, and should be easily modified to include others.  Some of the
- * configuration information is contained in "commproc.h" and the
- * remainder is here.
- *
- * Buffer descriptors are kept in the CPM dual port RAM, and the frame
- * buffers are in the host memory.
- *
- * Right now, I am very watseful with the buffers.  I allocate memory
- * pages and then divide them into 2K frame buffers.  This way I know I
- * have buffers large enough to hold one frame within one buffer descriptor.
- * Once I get this working, I will use 64 or 128 byte CPM buffers, which
- * will be much more memory efficient and will easily handle lots of
- * small packets.
- *
- */
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/ptrace.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/spinlock.h> 
-
-#include <asm/irq.h>
-#include <asm/m68360.h>
-/* #include <asm/8xx_immap.h> */
-/* #include <asm/pgtable.h> */
-/* #include <asm/mpc8xx.h> */
-#include <asm/bitops.h>
-/* #include <asm/uaccess.h> */
-#include <asm/commproc.h>
-
-
-/*
- *				Theory of Operation
- *
- * The MPC8xx CPM performs the Ethernet processing on SCC1.  It can use
- * an aribtrary number of buffers on byte boundaries, but must have at
- * least two receive buffers to prevent constant overrun conditions.
- *
- * The buffer descriptors are allocated from the CPM dual port memory
- * with the data buffers allocated from host memory, just like all other
- * serial communication protocols.  The host memory buffers are allocated
- * from the free page pool, and then divided into smaller receive and
- * transmit buffers.  The size of the buffers should be a power of two,
- * since that nicely divides the page.  This creates a ring buffer
- * structure similar to the LANCE and other controllers.
- *
- * Like the LANCE driver:
- * The driver runs as two independent, single-threaded flows of control.  One
- * is the send-packet routine, which enforces single-threaded use by the
- * cep->tx_busy flag.  The other thread is the interrupt handler, which is
- * single threaded by the hardware and other software.
- *
- * The send packet thread has partial control over the Tx ring and the
- * 'cep->tx_busy' flag.  It sets the tx_busy flag whenever it's queuing a Tx
- * packet. If the next queue slot is empty, it clears the tx_busy flag when
- * finished otherwise it sets the 'lp->tx_full' flag.
- *
- * The MBX has a control register external to the MPC8xx that has some
- * control of the Ethernet interface.  Information is in the manual for
- * your board.
- *
- * The RPX boards have an external control/status register.  Consult the
- * programming documents for details unique to your board.
- *
- * For the TQM8xx(L) modules, there is no control register interface.
- * All functions are directly controlled using I/O pins.  See commproc.h.
- */
-
-
-/* The transmitter timeout
- */
-#define TX_TIMEOUT	(2*HZ)
-
-/* The number of Tx and Rx buffers.  These are allocated statically here.
- * We don't need to allocate pages for the transmitter.  We just use
- * the skbuffer directly.
- */
-#ifdef CONFIG_ENET_BIG_BUFFERS
-#define RX_RING_SIZE		64
-#define TX_RING_SIZE		64	/* Must be power of two */
-#define TX_RING_MOD_MASK	63	/*   for this to work */
-#else
-#define RX_RING_SIZE		8
-#define TX_RING_SIZE		8	/* Must be power of two */
-#define TX_RING_MOD_MASK	7	/*   for this to work */
-#endif
-
-#define CPM_ENET_RX_FRSIZE  2048 /* overkill left over from ppc page-based allocation */
-static char rx_buf_pool[RX_RING_SIZE * CPM_ENET_RX_FRSIZE];
-
-
-/* The CPM stores dest/src/type, data, and checksum for receive packets.
- */
-#define PKT_MAXBUF_SIZE		1518
-#define PKT_MINBUF_SIZE		64
-#define PKT_MAXBLR_SIZE		1520
-
-/* The CPM buffer descriptors track the ring buffers.  The rx_bd_base and
- * tx_bd_base always point to the base of the buffer descriptors.  The
- * cur_rx and cur_tx point to the currently available buffer.
- * The dirty_tx tracks the current buffer that is being sent by the
- * controller.  The cur_tx and dirty_tx are equal under both completely
- * empty and completely full conditions.  The empty/ready indicator in
- * the buffer descriptor determines the actual condition.
- */
-struct scc_enet_private {
-	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
-	struct	sk_buff* tx_skbuff[TX_RING_SIZE];
-	ushort	skb_cur;
-	ushort	skb_dirty;
-
-	/* CPM dual port RAM relative addresses.
-	*/
-	QUICC_BD	*rx_bd_base;		/* Address of Rx and Tx buffers. */
-	QUICC_BD	*tx_bd_base;
-	QUICC_BD	*cur_rx, *cur_tx;		/* The next free ring entry */
-	QUICC_BD	*dirty_tx;	/* The ring entries to be free()ed. */
-	volatile struct scc_regs	*sccp;
-	/* struct	net_device_stats stats; */
-	struct	net_device_stats stats;
-	uint	tx_full;
-	/* spinlock_t lock; */
-	volatile unsigned int lock;
-};
-
-
-
-static int scc_enet_open(struct net_device *dev);
-static int scc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev);
-static int scc_enet_rx(struct net_device *dev);
-static irqreturn_t scc_enet_interrupt(int vec, void *dev_id, struct pt_regs *fp);
-static int scc_enet_close(struct net_device *dev);
-/* static struct net_device_stats *scc_enet_get_stats(struct net_device *dev); */
-static struct net_device_stats *scc_enet_get_stats(struct net_device *dev);
-static void set_multicast_list(struct net_device *dev);
-
-/* Get this from various configuration locations (depends on board).
-*/
-/*static	ushort	my_enet_addr[] = { 0x0800, 0x3e26, 0x1559 };*/
-
-/* Typically, 860(T) boards use SCC1 for Ethernet, and other 8xx boards
- * use SCC2.  This is easily extended if necessary.
- */
-
-#define CONFIG_SCC1_ENET /* by default */
-
-#ifdef CONFIG_SCC1_ENET
-#define CPM_CR_ENET CPM_CR_CH_SCC1
-#define PROFF_ENET	PROFF_SCC1
-#define SCC_ENET	0
-#define CPMVEC_ENET	CPMVEC_SCC1
-#endif
-
-#ifdef CONFIG_SCC2_ENET
-#define CPM_CR_ENET	CPM_CR_CH_SCC2
-#define PROFF_ENET	PROFF_SCC2
-#define SCC_ENET	1		/* Index, not number! */
-#define CPMVEC_ENET	CPMVEC_SCC2
-#endif
-
-static int
-scc_enet_open(struct net_device *dev)
-{
-
-	/* I should reset the ring buffers here, but I don't yet know
-	 * a simple way to do that.
-	 * mleslie: That's no biggie. Worth doing, too.
-	 */
-
-	/* netif_start_queue(dev); */
-	return 0;					/* Always succeed */
-}
-
-
-static int
-scc_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
-	volatile QUICC_BD	*bdp;
-
-	/* Fill in a Tx ring entry */
-	bdp = cep->cur_tx;
-
-#ifndef final_version
-	if (bdp->status & BD_ENET_TX_READY) {
-		/* Ooops.  All transmit buffers are full.  Bail out.
-		 * This should not happen, since cep->tx_busy should be set.
-		 */
-		printk("%s: tx queue full!.\n", dev->name);
-		return 1;
-	}
-#endif
-
-	/* Clear all of the status flags.
-	 */
-	bdp->status &= ~BD_ENET_TX_STATS;
-
-	/* If the frame is short, tell CPM to pad it.
-	*/
-	if (skb->len <= ETH_ZLEN)
-		bdp->status |= BD_ENET_TX_PAD;
-	else
-		bdp->status &= ~BD_ENET_TX_PAD;
-
-	/* Set buffer length and buffer pointer.
-	*/
-	bdp->length = skb->len;
-	/* bdp->buf = __pa(skb->data); */
-	bdp->buf = skb->data;
-
-	/* Save skb pointer.
-	*/
-	cep->tx_skbuff[cep->skb_cur] = skb;
-
-	/* cep->stats.tx_bytes += skb->len; */ /* TODO: It would really be nice... */
-
-	cep->skb_cur = (cep->skb_cur+1) & TX_RING_MOD_MASK;
-	
-
-	/* Push the data cache so the CPM does not get stale memory
-	 * data.
-	 */
-/* 	flush_dcache_range((unsigned long)(skb->data), */
-/* 					(unsigned long)(skb->data + skb->len)); */
-
-	/* spin_lock_irq(&cep->lock); */ /* TODO: SPINLOCK */
-	local_irq_disable();
-	if (cep->lock > 0) {
-		printk ("scc_enet_start_xmit() lock == %d\n", cep->lock);
-	} else {
-		cep->lock++;
-	}
-
-	/* Send it on its way.  Tell CPM its ready, interrupt when done,
-	 * its the last BD of the frame, and to put the CRC on the end.
-	 */
-	bdp->status |= (BD_ENET_TX_READY | BD_ENET_TX_INTR | BD_ENET_TX_LAST | BD_ENET_TX_TC);
-
-	dev->trans_start = jiffies;
-
-	/* If this was the last BD in the ring, start at the beginning again.
-	*/
-	if (bdp->status & BD_ENET_TX_WRAP)
-		bdp = cep->tx_bd_base;
-	else
-		bdp++;
-
-	if (bdp->status & BD_ENET_TX_READY) {
-		/* netif_stop_queue(dev); */
-		cep->tx_full = 1;
-	}
-
-	cep->cur_tx = (QUICC_BD *)bdp;
-
-	/* spin_unlock_irq(&cep->lock); */ /* TODO: SPINLOCK */
-	cep->lock--;
-	sti();
-
-	return 0;
-}
-
-#if 0
-static void
-scc_enet_timeout(struct net_device *dev)
-{
-	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
-
-	printk("%s: transmit timed out.\n", dev->name);
-	cep->stats.tx_errors++;
-#ifndef final_version
-	{
-		int	i;
-		QUICC_BD	*bdp;
-		printk(" Ring data dump: cur_tx %p%s cur_rx %p.\n",
-		       cep->cur_tx, cep->tx_full ? " (full)" : "",
-		       cep->cur_rx);
-		bdp = cep->tx_bd_base;
-		for (i = 0 ; i < TX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
-			       bdp->status,
-			       bdp->length,
-			       (int)(bdp->buf));
-		bdp = cep->rx_bd_base;
-		for (i = 0 ; i < RX_RING_SIZE; i++, bdp++)
-			printk("%04x %04x %08x\n",
-			       bdp->status,
-			       bdp->length,
-			       (int)(bdp->buf));
-	}
-#endif
-/* 	if (!cep->tx_full) */
-/* 		netif_wake_queue(dev); */
-}
-#endif
-
-/* The interrupt handler.
- * This is called from the CPM handler, not the MPC core interrupt.
- */
-static irqreturn_t scc_enet_interrupt(int vec, void *dev_id, struct pt_regs *fp)
-{
-	struct	net_device *dev = (struct net_device *)dev_id;
-	volatile struct	scc_enet_private *cep;
-	volatile QUICC_BD	*bdp;
-	ushort	int_events;
-	int	must_restart;
-
-	cep = (struct scc_enet_private *)dev->priv;
-
-	/* Get the interrupt events that caused us to be here.
-	*/
-	int_events = cep->sccp->scc_scce;
-	cep->sccp->scc_scce = int_events;
-	must_restart = 0;
-
-	/* Handle receive event in its own function.
-	*/
-	if (int_events & SCCE_ENET_RXF)
-		scc_enet_rx(dev_id);
-
-	/* Check for a transmit error.  The manual is a little unclear
-	 * about this, so the debug code until I get it figured out.  It
-	 * appears that if TXE is set, then TXB is not set.  However,
-	 * if carrier sense is lost during frame transmission, the TXE
-	 * bit is set, "and continues the buffer transmission normally."
-	 * I don't know if "normally" implies TXB is set when the buffer
-	 * descriptor is closed.....trial and error :-).
-	 */
-
-	/* Transmit OK, or non-fatal error.  Update the buffer descriptors.
-	*/
-	if (int_events & (SCCE_ENET_TXE | SCCE_ENET_TXB)) {
-	    /* spin_lock(&cep->lock); */ /* TODO: SPINLOCK */
-		/* local_irq_disable(); */
-		if (cep->lock > 0) {
-			printk ("scc_enet_interrupt() lock == %d\n", cep->lock);
-		} else {
-			cep->lock++;
-		}
-
-	    bdp = cep->dirty_tx;
-	    while ((bdp->status&BD_ENET_TX_READY)==0) {
-		if ((bdp==cep->cur_tx) && (cep->tx_full == 0))
-		    break;
-
-		if (bdp->status & BD_ENET_TX_HB)	/* No heartbeat */
-			cep->stats.tx_heartbeat_errors++;
-		if (bdp->status & BD_ENET_TX_LC)	/* Late collision */
-			cep->stats.tx_window_errors++;
-		if (bdp->status & BD_ENET_TX_RL)	/* Retrans limit */
-			cep->stats.tx_aborted_errors++;
-		if (bdp->status & BD_ENET_TX_UN)	/* Underrun */
-			cep->stats.tx_fifo_errors++;
-		if (bdp->status & BD_ENET_TX_CSL)	/* Carrier lost */
-			cep->stats.tx_carrier_errors++;
-
-
-		/* No heartbeat or Lost carrier are not really bad errors.
-		 * The others require a restart transmit command.
-		 */
-		if (bdp->status &
-		    (BD_ENET_TX_LC | BD_ENET_TX_RL | BD_ENET_TX_UN)) {
-			must_restart = 1;
-			cep->stats.tx_errors++;
-		}
-
-		cep->stats.tx_packets++;
-
-		/* Deferred means some collisions occurred during transmit,
-		 * but we eventually sent the packet OK.
-		 */
-		if (bdp->status & BD_ENET_TX_DEF)
-			cep->stats.collisions++;
-
-		/* Free the sk buffer associated with this last transmit.
-		*/
-		/* dev_kfree_skb_irq(cep->tx_skbuff[cep->skb_dirty]); */
-		dev_kfree_skb (cep->tx_skbuff[cep->skb_dirty]);
-		cep->skb_dirty = (cep->skb_dirty + 1) & TX_RING_MOD_MASK;
-
-		/* Update pointer to next buffer descriptor to be transmitted.
-		*/
-		if (bdp->status & BD_ENET_TX_WRAP)
-			bdp = cep->tx_bd_base;
-		else
-			bdp++;
-
-		/* I don't know if we can be held off from processing these
-		 * interrupts for more than one frame time.  I really hope
-		 * not.  In such a case, we would now want to check the
-		 * currently available BD (cur_tx) and determine if any
-		 * buffers between the dirty_tx and cur_tx have also been
-		 * sent.  We would want to process anything in between that
-		 * does not have BD_ENET_TX_READY set.
-		 */
-
-		/* Since we have freed up a buffer, the ring is no longer
-		 * full.
-		 */
-		if (cep->tx_full) {
-			cep->tx_full = 0;
-/* 			if (netif_queue_stopped(dev)) */
-/* 				netif_wake_queue(dev); */
-		}
-
-		cep->dirty_tx = (QUICC_BD *)bdp;
-	    }
-
-	    if (must_restart) {
-			volatile QUICC *cp;
-
-		/* Some transmit errors cause the transmitter to shut
-		 * down.  We now issue a restart transmit.  Since the
-		 * errors close the BD and update the pointers, the restart
-		 * _should_ pick up without having to reset any of our
-		 * pointers either.
-		 */
-		cp = pquicc;
-		cp->cp_cr =
-		    mk_cr_cmd(CPM_CR_ENET, CPM_CR_RESTART_TX) | CPM_CR_FLG;
-		while (cp->cp_cr & CPM_CR_FLG);
-	    }
-	    /* spin_unlock(&cep->lock); */ /* TODO: SPINLOCK */
-		/* sti(); */
-		cep->lock--;
-	}
-
-	/* Check for receive busy, i.e. packets coming but no place to
-	 * put them.  This "can't happen" because the receive interrupt
-	 * is tossing previous frames.
-	 */
-	if (int_events & SCCE_ENET_BSY) {
-		cep->stats.rx_dropped++;
-		printk("CPM ENET: BSY can't happen.\n");
-	}
-
-	return IRQ_HANDLED;
-}
-
-/* During a receive, the cur_rx points to the current incoming buffer.
- * When we update through the ring, if the next incoming buffer has
- * not been given to the system, we just set the empty indicator,
- * effectively tossing the packet.
- */
-static int
-scc_enet_rx(struct net_device *dev)
-{
-	struct	scc_enet_private *cep;
-	volatile QUICC_BD	*bdp;
-	struct	sk_buff *skb;
-	ushort	pkt_len;
-
-	cep = (struct scc_enet_private *)dev->priv;
-
-	/* First, grab all of the stats for the incoming packet.
-	 * These get messed up if we get called due to a busy condition.
-	 */
-	bdp = cep->cur_rx;
-
-	for (;;) {
-		if (bdp->status & BD_ENET_RX_EMPTY)
-			break;
-		
-#ifndef final_version
-		/* Since we have allocated space to hold a complete frame, both
-		 * the first and last indicators should be set.
-		 */
-		if ((bdp->status & (BD_ENET_RX_FIRST | BD_ENET_RX_LAST)) !=
-			(BD_ENET_RX_FIRST | BD_ENET_RX_LAST))
-			printk("CPM ENET: rcv is not first+last\n");
-#endif
-
-		/* Frame too long or too short.
-		 */
-		if (bdp->status & (BD_ENET_RX_LG | BD_ENET_RX_SH))
-			cep->stats.rx_length_errors++;
-		if (bdp->status & BD_ENET_RX_NO)	/* Frame alignment */
-			cep->stats.rx_frame_errors++;
-		if (bdp->status & BD_ENET_RX_CR)	/* CRC Error */
-			cep->stats.rx_crc_errors++;
-		if (bdp->status & BD_ENET_RX_OV)	/* FIFO overrun */
-			cep->stats.rx_crc_errors++;
-
-		/* Report late collisions as a frame error.
-		 * On this error, the BD is closed, but we don't know what we
-		 * have in the buffer.  So, just drop this frame on the floor.
-		 */
-		if (bdp->status & BD_ENET_RX_CL) {
-			cep->stats.rx_frame_errors++;
-		}
-		else {
-			
-			/* Process the incoming frame.
-			 */
-			cep->stats.rx_packets++;
-			pkt_len = bdp->length;
-			/* cep->stats.rx_bytes += pkt_len; */  /* TODO: It would really be nice... */
-
-			/* This does 16 byte alignment, much more than we need.
-			 * The packet length includes FCS, but we don't want to
-			 * include that when passing upstream as it messes up
-			 * bridging applications.
-			 */
-			skb = dev_alloc_skb(pkt_len-4);
-
-			if (skb == NULL) {
-				printk("%s: Memory squeeze, dropping packet.\n", dev->name);
-				cep->stats.rx_dropped++;
-			}
-			else {
-				skb->dev = dev;
-				skb_put(skb,pkt_len-4);	/* Make room */
-				eth_copy_and_sum(skb, (unsigned char *)bdp->buf, pkt_len-4, 0);
-				skb->protocol=eth_type_trans(skb,dev);
-				netif_rx(skb);
-			}
-		}
-
-		/* Clear the status flags for this buffer.
-		 */
-		bdp->status &= ~BD_ENET_RX_STATS;
-
-		/* Mark the buffer empty.
-		 */
-		bdp->status |= BD_ENET_RX_EMPTY;
-
-		/* Update BD pointer to next entry.
-		 */
-		if (bdp->status & BD_ENET_RX_WRAP)
-			bdp = cep->rx_bd_base;
-		else
-			bdp++;
-
-	}
-	cep->cur_rx = (QUICC_BD *)bdp;
-
-	return 0;
-}
-
-static int
-scc_enet_close(struct net_device *dev)
-{
-	/* Don't know what to do yet.
-	*/
-	/* netif_stop_queue(dev); */
-
-	return 0;
-}
-
-/* static struct net_device_stats *scc_enet_get_stats(struct net_device *dev) */
-static struct net_device_stats *scc_enet_get_stats(struct net_device *dev)
-{
-	struct scc_enet_private *cep = (struct scc_enet_private *)dev->priv;
-
-	return &cep->stats;
-}
-
-/* Set or clear the multicast filter for this adaptor.
- * Skeleton taken from sunlance driver.
- * The CPM Ethernet implementation allows Multicast as well as individual
- * MAC address filtering.  Some of the drivers check to make sure it is
- * a group multicast address, and discard those that are not.  I guess I
- * will do the same for now, but just remove the test if you want
- * individual filtering as well (do the upper net layers want or support
- * this kind of feature?).
- */
-
-static void set_multicast_list(struct net_device *dev)
-{
-	struct	scc_enet_private *cep;
-	struct	dev_mc_list *dmi;
-	u_char	*mcptr, *tdptr;
-	volatile scc_enet_t *ep;
-	int	i, j;
-	volatile QUICC *cp = pquicc;
-
-	cep = (struct scc_enet_private *)dev->priv;
-
-	/* Get pointer to SCC area in parameter RAM.
-	*/
-	ep = (scc_enet_t *)dev->base_addr;
-
-	if (dev->flags&IFF_PROMISC) {
-	  
-		/* Log any net taps. */
-		printk("%s: Promiscuous mode enabled.\n", dev->name);
-		cep->sccp->scc_psmr |= ETHER_PRO; 
-	} else {
-
-		cep->sccp->scc_psmr &= ~ETHER_PRO;
-
-		if (dev->flags & IFF_ALLMULTI) {
-			/* Catch all multicast addresses, so set the
-			 * filter to all 1's.
-			 */
-			ep->sen_gaddr1 = 0xffff;
-			ep->sen_gaddr2 = 0xffff;
-			ep->sen_gaddr3 = 0xffff;
-			ep->sen_gaddr4 = 0xffff;
-		}
-		else {
-			/* Clear filter and add the addresses in the list.
-			*/
-			ep->sen_gaddr1 = 0;
-			ep->sen_gaddr2 = 0;
-			ep->sen_gaddr3 = 0;
-			ep->sen_gaddr4 = 0;
-
-			dmi = dev->mc_list;
-
-			for (i=0; i<dev->mc_count; i++) {
-				
-				/* Only support group multicast for now.
-				*/
-				if (!(dmi->dmi_addr[0] & 1))
-					continue;
-
-				/* The address in dmi_addr is LSB first,
-				 * and taddr is MSB first.  We have to
-				 * copy bytes MSB first from dmi_addr.
-				 */
-				mcptr = (u_char *)dmi->dmi_addr + 5;
-				tdptr = (u_char *)&ep->sen_taddrh;
-				for (j=0; j<6; j++)
-					*tdptr++ = *mcptr--;
-
-				/* Ask CPM to run CRC and set bit in
-				 * filter mask.
-				 */
-				cp->cp_cr = mk_cr_cmd(CPM_CR_ENET, CPM_CR_SET_GADDR) | CPM_CR_FLG;
-				/* this delay is necessary here -- Cort */
-				udelay(10);
-				while (cp->cp_cr & CPM_CR_FLG);
-			}
-		}
-	}
-}
-
-
-/* Initialize the CPM Ethernet on SCC.
- */
-int scc_enet_init(void)
-{
-	struct net_device *dev;
-	struct scc_enet_private *cep;
-	int i, j;
-	unsigned char	*eap;
-	/* unsigned long	mem_addr; */
-	/* pte_t		*pte; */
-	/* bd_t		*bd; */ /* `board tag' used by ppc - TODO: integrate uC bootloader vars */
-	volatile	QUICC_BD	*bdp;
-	volatile	QUICC	*cp;
-	volatile struct scc_regs	*sccp;
-	volatile struct	ethernet_pram	*ep;
-	/* volatile	immap_t		*immap; */
-
-	cp = pquicc;	/* Get pointer to Communication Processor */
-
-	/* immap = (immap_t *)IMAP_ADDR; */	/* and to internal registers */
-
-	/* bd = (bd_t *)__res; */
-
-	/* Allocate some private information.
-	*/
-	cep = (struct scc_enet_private *)kmalloc(sizeof(*cep), GFP_KERNEL);
-	memset(cep, 0, sizeof(*cep));
-	/* __clear_user(cep,sizeof(*cep)); */
-	/* spin_lock_init(&cep->lock); */ /* TODO: SPINLOCK */
-
-	/* Create an Ethernet device instance.
-	 */
-	dev = init_etherdev(0, 0);
-
-	/* Get pointer to SCC area in parameter RAM.
-	*/
-	/* ep = (ethernet_pram *)(&cp->cp_dparam[PROFF_ENET]); */
-	ep = &pquicc->pram[SCC_ENET].enet_scc;
-
-	/* And another to the SCC register area.
-	*/
-	sccp = &pquicc->scc_regs[SCC_ENET];
-	cep->sccp = sccp;		/* Keep the pointer handy */
-
-	/* Disable receive and transmit in case EPPC-Bug started it.
-	*/
-	sccp->scc_gsmr.w.low &= ~(SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-
-	/* Set up 360 pins for SCC interface to ethernet transceiver.
-	 * Pin mappings (PA_xx and PC_xx) are defined in commproc.h
-	 */
-
-	/* Configure port A pins for Txd and Rxd.
-	 */
-	pquicc->pio_papar |= (PA_ENET_RXD | PA_ENET_TXD);
-	pquicc->pio_padir &= ~(PA_ENET_RXD | PA_ENET_TXD);
-	pquicc->pio_paodr &= ~PA_ENET_TXD;
-
-	/* Configure port C pins to enable CLSN and RENA.
-	 */
-	pquicc->pio_pcpar &= ~(PC_ENET_CLSN | PC_ENET_RENA);
-	pquicc->pio_pcdir &= ~(PC_ENET_CLSN | PC_ENET_RENA);
-	pquicc->pio_pcso |= (PC_ENET_CLSN | PC_ENET_RENA);
-
-	/* Configure port A for TCLK and RCLK.
-	*/
-	pquicc->pio_papar |= (PA_ENET_TCLK | PA_ENET_RCLK);
-	pquicc->pio_padir &= ~(PA_ENET_TCLK | PA_ENET_RCLK);
-
-	/* Configure Serial Interface clock routing.
-	 * First, clear all SCC bits to zero, then set the ones we want.
-	 */
-	pquicc->si_sicr &= ~SICR_ENET_MASK;
-	pquicc->si_sicr |= SICR_ENET_CLKRT;
-
-
-	/* Allocate space for the buffer descriptors in the DP ram.
-	 * These are relative offsets in the DP ram address space.
-	 * Initialize base addresses for the buffer descriptors.
-	 */
-	i = m360_cpm_dpalloc(sizeof(QUICC_BD) * RX_RING_SIZE);
-	ep->rbase = i;
-	cep->rx_bd_base = (QUICC_BD *)((uint)pquicc + i);
-
-	i = m360_cpm_dpalloc(sizeof(QUICC_BD) * TX_RING_SIZE);
-	ep->tbase = i;
-	cep->tx_bd_base = (QUICC_BD *)((uint)pquicc + i);
-
-	cep->dirty_tx = cep->cur_tx = cep->tx_bd_base;
-	cep->cur_rx = cep->rx_bd_base;
-
-	/* Issue init Rx BD command for SCC.
-	 * Manual says to perform an Init Rx parameters here.  We have
-	 * to perform both Rx and Tx because the SCC may have been
-	 * already running. [In uCquicc's case, I don't think that is so - mles]
-	 * In addition, we have to do it later because we don't yet have
-	 * all of the BD control/status set properly.
-	cp->cp_cpcr = mk_cr_cmd(CPM_CR_ENET, CPM_CR_INIT_RX) | CPM_CR_FLG;
-	while (cp->cp_cpcr & CPM_CR_FLG);
-	 */
-
-	/* Initialize function code registers for big-endian.
-	*/
-	ep->rfcr = (SCC_EB | SCC_FC_DMA);
-	ep->tfcr = (SCC_EB | SCC_FC_DMA);
-
-	/* Set maximum bytes per receive buffer.
-	 * This appears to be an Ethernet frame size, not the buffer
-	 * fragment size.  It must be a multiple of four.
-	 */
-	ep->mrblr  = PKT_MAXBLR_SIZE;
-
-	/* Set CRC preset and mask.
-	 */
-	ep->c_pres = 0xffffffff;
-	ep->c_mask = 0xdebb20e3; /* see 360UM p. 7-247 */
-
-	ep->crcec  = 0;	/* CRC Error counter */
-	ep->alec   = 0;	/* alignment error counter */
-	ep->disfc  = 0;	/* discard frame counter */
-
-	ep->pads   = 0x8888;	/* Tx short frame pad character */
-	ep->ret_lim = 0x000f;	/* Retry limit threshold */
-
-	ep->mflr   = PKT_MAXBUF_SIZE;	/* maximum frame length register */
-	ep->minflr = PKT_MINBUF_SIZE;	/* minimum frame length register */
-
-	ep->maxd1 = PKT_MAXBLR_SIZE;	/* maximum DMA1 length */
-	ep->maxd2 = PKT_MAXBLR_SIZE;	/* maximum DMA2 length */
-
-	/* Clear hash tables, group and individual.
-	 */
-	ep->gaddr1 = ep->gaddr2 = ep->gaddr3 = ep->gaddr4 = 0;
-	ep->iaddr1 = ep->iaddr2 = ep->iaddr3 = ep->iaddr4 = 0;
-
-	/* Set Ethernet station address.
-	 *
-	 * The uCbootloader provides a hook to the kernel to retrieve
-	 * stuff like the MAC address. This is retrieved in config_BSP()
-	 */
-#if defined (CONFIG_UCQUICC)
-	{
- 		extern unsigned char *scc1_hwaddr;
-
-		eap = (char *)ep->paddr.b;
-		for (i=5; i>=0; i--)
-			*eap++ = dev->dev_addr[i] = scc1_hwaddr[i];
-	}
-#endif
-
-
-/* #ifndef CONFIG_MBX */
-/* 	eap = (unsigned char *)&(ep->paddrh); */
-
-/* 	for (i=5; i>=0; i--) */
-/* 		*eap++ = dev->dev_addr[i] = bd->bi_enetaddr[i]; */
-/* #else */
-/* 	for (i=5; i>=0; i--) */
-/* 		dev->dev_addr[i] = *eap++; */
-/* #endif */
-
-	ep->p_per   = 0;	/* 'cause the book says so */
-	ep->taddr_l = 0;	/* temp address (LSB) */
-	ep->taddr_m = 0;
-	ep->taddr_h = 0;	/* temp address (MSB) */
-
-	/* Now allocate the host memory pages and initialize the
-	 * buffer descriptors.
-	 */
-	/* initialize rx buffer descriptors */
-	bdp = cep->tx_bd_base;
-	for (j=0; j<(TX_RING_SIZE-1); j++) {
-		bdp->buf = 0;
-		bdp->status = 0;
-		bdp++;
-	}
-	bdp->buf = 0;
-	bdp->status = BD_SC_WRAP;
-
-
-	/* initialize rx buffer descriptors */
-	bdp = cep->rx_bd_base;
-	for (j=0; j<(RX_RING_SIZE-1); j++) {
-		bdp->buf = &rx_buf_pool[j * CPM_ENET_RX_FRSIZE];
-		bdp->status = BD_SC_EMPTY | BD_SC_INTRPT;
-		bdp++;
-	}
-	bdp->buf = &rx_buf_pool[j * CPM_ENET_RX_FRSIZE];
-	bdp->status = BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT;
-
-
-
-	/* Let's re-initialize the channel now.  We have to do it later
-	 * than the manual describes because we have just now finished
-	 * the BD initialization.
-	 */
-	cp->cp_cr = mk_cr_cmd(CPM_CR_ENET, CPM_CR_INIT_TRX) | CPM_CR_FLG;
-	while (cp->cp_cr & CPM_CR_FLG);
-
-	cep->skb_cur = cep->skb_dirty = 0;
-
-	sccp->scc_scce = 0xffff;	/* Clear any pending events */
-
-	/* Enable interrupts for transmit error, complete frame
-	 * received, and any transmit buffer we have also set the
-	 * interrupt flag.
-	 */
-	sccp->scc_sccm = (SCCE_ENET_TXE | SCCE_ENET_RXF | SCCE_ENET_TXB);
-
-	/* Install our interrupt handler.
-	 */
-	/* cpm_install_handler(CPMVEC_ENET, scc_enet_interrupt, dev); */
-	request_irq(CPMVEC_ENET, scc_enet_interrupt,
-		IRQ_FLG_LOCK, dev->name, (void *)dev);
-
-	/* Set GSMR_H to enable all normal operating modes.
-	 * Set GSMR_L to enable Ethernet to MC68160.
-	 */
-	sccp->scc_gsmr.w.high = 0;
-	sccp->scc_gsmr.w.low  = (SCC_GSMRL_TCI | SCC_GSMRL_TPL_48 |
-							 SCC_GSMRL_TPP_10 | SCC_GSMRL_MODE_ENET);
-
-	/* Set sync/delimiters.
-	 */
-	sccp->scc_dsr = 0xd555;
-
-	/* Set processing mode.  Use Ethernet CRC, catch broadcast, and
-	 * start frame search 22 bit times after RENA.
-	 */
-	sccp->scc_psmr = (SCC_PMSR_ENCRC       /* Ethernet CRC mode */
-			  /* | SCC_PSMR_HBC */ /* Enable heartbeat */
-			  /* | SCC_PMSR_PRO */ /* Promiscuous mode */
-			  /* | SCC_PMSR_FDE */ /* Full duplex enable */
-			  | ETHER_NIB_22);
-	/* sccp->scc_psmr = (SCC_PMSR_PRO | ETHER_CRC_32 | ETHER_NIB_22); */
-
-
-	/* It is now OK to enable the Ethernet transmitter.
-	 * Unfortunately, there are board implementation differences here.
-	 */
-#if defined(CONFIG_UCQUICC)
-/* 	 immap->im_ioport.iop_pcpar |= PC_ENET_TENA; */
-/* 	 immap->im_ioport.iop_pcdir &= ~PC_ENET_TENA; */
-	 cp->pio_pcpar |=  PC_ENET_TENA; /* t_en */
-	 cp->pio_pcdir &= ~PC_ENET_TENA;
-
-	 cp->pip_pbpar &= ~(0x00000200); /* power up ethernet transceiver */
-	 cp->pip_pbdir |=  (0x00000200);
-	 cp->pip_pbdat |=  (0x00000200);
-#endif
-
-
-	dev->base_addr = (unsigned long)ep;
-	dev->priv = cep;
-#if 0
-	dev->name = "CPM_ENET";
-#endif
-
-	/* The CPM Ethernet specific entries in the device structure. */
-	dev->open = scc_enet_open;
-	dev->hard_start_xmit = scc_enet_start_xmit;
-	/* dev->tx_timeout = scc_enet_timeout; */
-	/* dev->watchdog_timeo = TX_TIMEOUT; */
-	dev->stop = scc_enet_close;
-	dev->get_stats = scc_enet_get_stats;
-	dev->set_multicast_list = set_multicast_list;
-
-	/* And last, enable the transmit and receive processing.
-	*/
-	sccp->scc_gsmr.w.low |= (SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-
-	printk("%s: CPM ENET Version 0.3, ", dev->name);
-	for (i=0; i<5; i++)
-		printk("%02x:", dev->dev_addr[i]);
-	printk("%02x\n", dev->dev_addr[5]);
-
-	return 0;
-}
-
-
-
-int m68360_enet_probe(struct device *dev)
-{
-	return(scc_enet_init ());
-}
-
-
-/*
- * Local variables:
- *  c-indent-level: 4
- *  c-basic-offset: 4
- *  tab-width: 4
- * End:
- */
diff -purN linux-2.6.1/drivers/net/Kconfig linux-2.5/drivers/net/Kconfig
--- linux-2.6.1/drivers/net/Kconfig	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/Kconfig	2004-01-16 00:45:21.000000000 +0000
@@ -657,7 +657,7 @@ config ELMC
 
 config ELMC_II
 	tristate "3c527 \"EtherLink/MC 32\" support (EXPERIMENTAL)"
-	depends on NET_VENDOR_3COM && MCA && EXPERIMENTAL && BROKEN_ON_SMP
+	depends on NET_VENDOR_3COM && MCA && MCA_LEGACY
 	help
 	  If you have a network (Ethernet) card of this type, say Y and read
 	  the Ethernet-HOWTO, available from
@@ -1283,6 +1283,19 @@ config B44
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called b44.
 
+config FORCEDETH
+	tristate "Reverse Engineered nForce Ethernet support (EXPERIMENTAL)"
+	depends on NET_PCI && PCI && EXPERIMENTAL
+	help
+	  If you have a network (Ethernet) controller of this type, say Y and
+	  read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>.  The module will be
+	  called forcedeth.
+
+
 config CS89x0
 	tristate "CS89x0 support"
 	depends on NET_PCI && ISA
@@ -1957,9 +1970,11 @@ config SK98LIN
 	    - EG1032 v2 Instant Gigabit Network Adapter
 	    - EG1064 v2 Instant Gigabit Network Adapter
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Abit)
+	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Albatron)
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Asus)
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (ECS)
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Epox)
+	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Foxconn)
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Gigabyte)
 	    - Marvell 88E8001 Gigabit LOM Ethernet Adapter (Iwill)
 	    - Marvell RDK-8001 Adapter
@@ -2005,8 +2020,10 @@ config SK98LIN
 	  Questions concerning this driver may be addressed to:
 	      linux@syskonnect.de
 	  
-	  To compile this driver as a module, choose M here: the module
-	  will be called sk98lin.  This is recommended.
+	  If you want to compile this driver as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read Documentation/modules.txt. This is recommended.
+	  The module will be called sk98lin. This is recommended.
 
 config TIGON3
 	tristate "Broadcom Tigon3 support"
diff -purN linux-2.6.1/drivers/net/Makefile linux-2.5/drivers/net/Makefile
--- linux-2.6.1/drivers/net/Makefile	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/Makefile	2004-01-10 15:59:02.000000000 +0000
@@ -95,6 +95,7 @@ obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_NET_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
+obj-$(CONFIG_FORCEDETH) += forcedeth.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
diff -purN linux-2.6.1/drivers/net/dummy.c linux-2.5/drivers/net/dummy.c
--- linux-2.6.1/drivers/net/dummy.c	2004-01-09 06:59:27.000000000 +0000
+++ linux-2.5/drivers/net/dummy.c	2003-12-11 08:34:17.000000000 +0000
@@ -33,6 +33,9 @@
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
+
+static int numdummies = 1;
 
 static int dummy_xmit(struct sk_buff *skb, struct net_device *dev);
 static struct net_device_stats *dummy_get_stats(struct net_device *dev);
@@ -83,10 +86,14 @@ static struct net_device_stats *dummy_ge
 	return dev->priv;
 }
 
-static struct net_device *dev_dummy;
+static struct net_device **dummies;
 
-static int __init dummy_init_module(void)
+/* Number of dummy devices to be set up by this module. */
+module_param(numdummies, int, 0);
+
+static int __init dummy_init_one(int index)
 {
+	struct net_device *dev_dummy;
 	int err;
 
 	dev_dummy = alloc_netdev(sizeof(struct net_device_stats),
@@ -98,15 +105,40 @@ static int __init dummy_init_module(void
 	if ((err = register_netdev(dev_dummy))) {
 		kfree(dev_dummy);
 		dev_dummy = NULL;
+	} else {
+		dummies[index] = dev_dummy; 
 	}
+
 	return err;
 }
 
+static void __exit dummy_free_one(int index) 
+{
+	unregister_netdev(dummies[index]);
+	free_netdev(dummies[index]);
+} 
+
+static int __init dummy_init_module(void)
+{ 
+	int i, err = 0;
+	dummies = kmalloc(numdummies * sizeof(void *), GFP_KERNEL); 
+	if (!dummies)
+		return -ENOMEM; 
+	for (i = 0; i < numdummies && !err; i++)
+		err = dummy_init_one(i); 
+	if (err) { 
+		while (--i >= 0)
+			dummy_free_one(i);
+	}
+	return err;
+} 
+
 static void __exit dummy_cleanup_module(void)
 {
-	unregister_netdev(dev_dummy);
-	free_netdev(dev_dummy);
-	dev_dummy = NULL;
+	int i;
+	for (i = 0; i < numdummies; i++) 
+		dummy_free_one(i); 
+	kfree(dummies);	
 }
 
 module_init(dummy_init_module);
diff -purN linux-2.6.1/drivers/net/forcedeth.c linux-2.5/drivers/net/forcedeth.c
--- linux-2.6.1/drivers/net/forcedeth.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/net/forcedeth.c	2004-01-16 00:47:29.000000000 +0000
@@ -0,0 +1,1501 @@
+/*
+ * forcedeth: Ethernet driver for NVIDIA nForce media access controllers.
+ *
+ * Note: This driver is a cleanroom reimplementation based on reverse
+ *      engineered documentation written by Carl-Daniel Hailfinger
+ *      and Andrew de Quincey. It's neither supported nor endorsed
+ *      by NVIDIA Corp. Use at your own risk.
+ *
+ * NVIDIA, nForce and other NVIDIA marks are trademarks or registered
+ * trademarks of NVIDIA Corporation in the United States and other
+ * countries.
+ *
+ * Copyright (C) 2003 Manfred Spraul
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Changelog:
+ * 	0.01: 05 Oct 2003: First release that compiles without warnings.
+ * 	0.02: 05 Oct 2003: Fix bug for drain_tx: do not try to free NULL skbs.
+ * 			   Check all PCI BARs for the register window.
+ * 			   udelay added to mii_rw.
+ * 	0.03: 06 Oct 2003: Initialize dev->irq.
+ * 	0.04: 07 Oct 2003: Initialize np->lock, reduce handled irqs, add printks.
+ * 	0.05: 09 Oct 2003: printk removed again, irq status print tx_timeout.
+ * 	0.06: 10 Oct 2003: MAC Address read updated, pff flag generation updated,
+ * 			   irq mask updated
+ * 	0.07: 14 Oct 2003: Further irq mask updates.
+ * 	0.08: 20 Oct 2003: rx_desc.Length initialization added, alloc_rx refill
+ * 			   added into irq handler, NULL check for drain_ring.
+ * 	0.09: 20 Oct 2003: Basic link speed irq implementation. Only handle the
+ * 			   requested interrupt sources.
+ * 	0.10: 20 Oct 2003: First cleanup for release.
+ * 	0.11: 21 Oct 2003: hexdump for tx added, rx buffer sizes increased.
+ * 			   MAC Address init fix, set_multicast cleanup.
+ * 	0.12: 23 Oct 2003: Cleanups for release.
+ * 	0.13: 25 Oct 2003: Limit for concurrent tx packets increased to 10.
+ * 			   Set link speed correctly. start rx before starting
+ * 			   tx (start_rx sets the link speed).
+ * 	0.14: 25 Oct 2003: Nic dependant irq mask.
+ * 	0.15: 08 Nov 2003: fix smp deadlock with set_multicast_list during
+ * 			   open.
+ * 	0.16: 15 Nov 2003: include file cleanup for ppc64, rx buffer size
+ * 			   increased to 1628 bytes.
+ * 	0.17: 16 Nov 2003: undo rx buffer size increase. Substract 1 from
+ * 			   the tx length.
+ * 	0.18: 17 Nov 2003: fix oops due to late initialization of dev_stats
+ * 	0.19: 29 Nov 2003: Handle RxNoBuf, detect & handle invalid mac
+ * 			   addresses, really stop rx if already running
+ * 			   in start_rx, clean up a bit.
+ * 				(C) Carl-Daniel Hailfinger
+ * 	0.20: 07 Dev 2003: alloc fixes
+ *
+ * Known bugs:
+ * The irq handling is wrong - no tx done interrupts are generated.
+ * This means recovery from netif_stop_queue only happens in the hw timer
+ * interrupt (1/2 second on nForce2, 1/100 second on nForce3), or if an
+ * rx packet arrives by chance.
+ */
+#define FORCEDETH_VERSION		"0.19"
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/random.h>
+#include <linux/init.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#if 0
+#define dprintk			printk
+#else
+#define dprintk(x...)		do { } while (0)
+#endif
+
+
+/*
+ * Hardware access:
+ */
+
+#define DEV_NEED_LASTPACKET1	0x0001
+#define DEV_IRQMASK_1		0x0002
+#define DEV_IRQMASK_2		0x0004
+
+enum {
+	NvRegIrqStatus = 0x000,
+#define NVREG_IRQSTAT_MIIEVENT	0x040
+#define NVREG_IRQSTAT_MASK		0x1ff
+	NvRegIrqMask = 0x004,
+#define NVREG_IRQ_RX			0x0002
+#define NVREG_IRQ_RX_NOBUF		0x0004
+#define NVREG_IRQ_TX_ERR		0x0008
+#define NVREG_IRQ_TX2			0x0010
+#define NVREG_IRQ_TIMER			0x0020
+#define NVREG_IRQ_LINK			0x0040
+#define NVREG_IRQ_TX1			0x0100
+#define NVREG_IRQMASK_WANTED_1		0x005f
+#define NVREG_IRQMASK_WANTED_2		0x0147
+#define NVREG_IRQ_UNKNOWN		(~(NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF|NVREG_IRQ_TX_ERR|NVREG_IRQ_TX2|NVREG_IRQ_TIMER|NVREG_IRQ_LINK|NVREG_IRQ_TX1))
+
+	NvRegUnknownSetupReg6 = 0x008,
+#define NVREG_UNKSETUP6_VAL		3
+
+	NvRegPollingInterval = 0x00c,
+	NvRegMisc1 = 0x080,
+#define NVREG_MISC1_HD		0x02
+#define NVREG_MISC1_FORCE	0x3b0f3c
+
+	NvRegTransmitterControl = 0x084,
+#define NVREG_XMITCTL_START	0x01
+	NvRegTransmitterStatus = 0x088,
+#define NVREG_XMITSTAT_BUSY	0x01
+
+	NvRegPacketFilterFlags = 0x8c,
+#define NVREG_PFF_ALWAYS	0x7F0008
+#define NVREG_PFF_PROMISC	0x80
+#define NVREG_PFF_MYADDR	0x20
+
+	NvRegOffloadConfig = 0x90,
+#define NVREG_OFFLOAD_HOMEPHY	0x601
+#define NVREG_OFFLOAD_NORMAL	0x5ee
+	NvRegReceiverControl = 0x094,
+#define NVREG_RCVCTL_START	0x01
+	NvRegReceiverStatus = 0x98,
+#define NVREG_RCVSTAT_BUSY	0x01
+
+	NvRegRandomSeed = 0x9c,
+#define NVREG_RNDSEED_MASK	0x00ff
+#define NVREG_RNDSEED_FORCE	0x7f00
+
+	NvRegUnknownSetupReg1 = 0xA0,
+#define NVREG_UNKSETUP1_VAL	0x16070f
+	NvRegUnknownSetupReg2 = 0xA4,
+#define NVREG_UNKSETUP2_VAL	0x16
+	NvRegMacAddrA = 0xA8,
+	NvRegMacAddrB = 0xAC,
+	NvRegMulticastAddrA = 0xB0,
+#define NVREG_MCASTADDRA_FORCE	0x01
+	NvRegMulticastAddrB = 0xB4,
+	NvRegMulticastMaskA = 0xB8,
+	NvRegMulticastMaskB = 0xBC,
+
+	NvRegTxRingPhysAddr = 0x100,
+	NvRegRxRingPhysAddr = 0x104,
+	NvRegRingSizes = 0x108,
+#define NVREG_RINGSZ_TXSHIFT 0
+#define NVREG_RINGSZ_RXSHIFT 16
+	NvRegUnknownTransmitterReg = 0x10c,
+	NvRegLinkSpeed = 0x110,
+#define NVREG_LINKSPEED_FORCE 0x10000
+#define NVREG_LINKSPEED_10	10
+#define NVREG_LINKSPEED_100	100
+#define NVREG_LINKSPEED_1000	1000
+	NvRegUnknownSetupReg5 = 0x130,
+#define NVREG_UNKSETUP5_BIT31	(1<<31)
+	NvRegUnknownSetupReg3 = 0x134,
+#define NVREG_UNKSETUP3_VAL1	0x200010
+	NvRegTxRxControl = 0x144,
+#define NVREG_TXRXCTL_KICK	0x0001
+#define NVREG_TXRXCTL_BIT1	0x0002
+#define NVREG_TXRXCTL_BIT2	0x0004
+#define NVREG_TXRXCTL_IDLE	0x0008
+#define NVREG_TXRXCTL_RESET	0x0010
+	NvRegMIIStatus = 0x180,
+#define NVREG_MIISTAT_ERROR		0x0001
+#define NVREG_MIISTAT_LINKCHANGE	0x0008
+#define NVREG_MIISTAT_MASK		0x000f
+#define NVREG_MIISTAT_MASK2		0x000f
+	NvRegUnknownSetupReg4 = 0x184,
+#define NVREG_UNKSETUP4_VAL	8
+
+	NvRegAdapterControl = 0x188,
+#define NVREG_ADAPTCTL_START	0x02
+#define NVREG_ADAPTCTL_LINKUP	0x04
+#define NVREG_ADAPTCTL_PHYVALID	0x4000
+#define NVREG_ADAPTCTL_RUNNING	0x100000
+#define NVREG_ADAPTCTL_PHYSHIFT	24
+	NvRegMIISpeed = 0x18c,
+#define NVREG_MIISPEED_BIT8	(1<<8)
+#define NVREG_MIIDELAY	5
+	NvRegMIIControl = 0x190,
+#define NVREG_MIICTL_INUSE	0x10000
+#define NVREG_MIICTL_WRITE	0x08000
+#define NVREG_MIICTL_ADDRSHIFT	5
+	NvRegMIIData = 0x194,
+	NvRegWakeUpFlags = 0x200,
+#define NVREG_WAKEUPFLAGS_VAL		0x7770
+#define NVREG_WAKEUPFLAGS_BUSYSHIFT	24
+#define NVREG_WAKEUPFLAGS_ENABLESHIFT	16
+#define NVREG_WAKEUPFLAGS_D3SHIFT	12
+#define NVREG_WAKEUPFLAGS_D2SHIFT	8
+#define NVREG_WAKEUPFLAGS_D1SHIFT	4
+#define NVREG_WAKEUPFLAGS_D0SHIFT	0
+#define NVREG_WAKEUPFLAGS_ACCEPT_MAGPAT		0x01
+#define NVREG_WAKEUPFLAGS_ACCEPT_WAKEUPPAT	0x02
+#define NVREG_WAKEUPFLAGS_ACCEPT_LINKCHANGE	0x04
+
+	NvRegPatternCRC = 0x204,
+	NvRegPatternMask = 0x208,
+	NvRegPowerCap = 0x268,
+#define NVREG_POWERCAP_D3SUPP	(1<<30)
+#define NVREG_POWERCAP_D2SUPP	(1<<26)
+#define NVREG_POWERCAP_D1SUPP	(1<<25)
+	NvRegPowerState = 0x26c,
+#define NVREG_POWERSTATE_POWEREDUP	0x8000
+#define NVREG_POWERSTATE_VALID		0x0100
+#define NVREG_POWERSTATE_MASK		0x0003
+#define NVREG_POWERSTATE_D0		0x0000
+#define NVREG_POWERSTATE_D1		0x0001
+#define NVREG_POWERSTATE_D2		0x0002
+#define NVREG_POWERSTATE_D3		0x0003
+};
+
+struct ring_desc {
+	u32 PacketBuffer;
+	u16 Length;
+	u16 Flags;
+};
+
+#define NV_TX_LASTPACKET	(1<<0)
+#define NV_TX_RETRYERROR	(1<<3)
+#define NV_TX_LASTPACKET1	(1<<8)
+#define NV_TX_DEFERRED		(1<<10)
+#define NV_TX_CARRIERLOST	(1<<11)
+#define NV_TX_LATECOLLISION	(1<<12)
+#define NV_TX_UNDERFLOW		(1<<13)
+#define NV_TX_ERROR		(1<<14)
+#define NV_TX_VALID		(1<<15)
+
+#define NV_RX_DESCRIPTORVALID	(1<<0)
+#define NV_RX_MISSEDFRAME	(1<<1)
+#define NV_RX_SUBSTRACT1	(1<<3)
+#define NV_RX_ERROR1		(1<<7)
+#define NV_RX_ERROR2		(1<<8)
+#define NV_RX_ERROR3		(1<<9)
+#define NV_RX_ERROR4		(1<<10)
+#define NV_RX_CRCERR		(1<<11)
+#define NV_RX_OVERFLOW		(1<<12)
+#define NV_RX_FRAMINGERR	(1<<13)
+#define NV_RX_ERROR		(1<<14)
+#define NV_RX_AVAIL		(1<<15)
+
+/* Miscelaneous hardware related defines: */
+#define NV_PCI_REGSZ		0x270
+
+/* various timeout delays: all in usec */
+#define NV_TXRX_RESET_DELAY	4
+#define NV_TXSTOP_DELAY1	10
+#define NV_TXSTOP_DELAY1MAX	500000
+#define NV_TXSTOP_DELAY2	100
+#define NV_RXSTOP_DELAY1	10
+#define NV_RXSTOP_DELAY1MAX	500000
+#define NV_RXSTOP_DELAY2	100
+#define NV_SETUP5_DELAY		5
+#define NV_SETUP5_DELAYMAX	50000
+#define NV_POWERUP_DELAY	5
+#define NV_POWERUP_DELAYMAX	5000
+#define NV_MIIBUSY_DELAY	50
+#define NV_MIIPHY_DELAY	10
+#define NV_MIIPHY_DELAYMAX	10000
+
+#define NV_WAKEUPPATTERNS	5
+#define NV_WAKEUPMASKENTRIES	4
+
+/* General driver defaults */
+#define NV_WATCHDOG_TIMEO	(2*HZ)
+#define DEFAULT_MTU		1500	/* also maximum supported, at least for now */
+
+#define RX_RING		128
+#define TX_RING		16
+/* limited to 1 packet until we understand NV_TX_LASTPACKET */
+#define TX_LIMIT_STOP	10
+#define TX_LIMIT_START	5
+
+/* rx/tx mac addr + type + vlan + align + slack*/
+#define RX_NIC_BUFSIZE		(DEFAULT_MTU + 64)
+/* even more slack */
+#define RX_ALLOC_BUFSIZE	(DEFAULT_MTU + 128)
+
+#define OOM_REFILL	(1+HZ/20)
+#define POLL_WAIT	(1+HZ/100)
+
+/*
+ * SMP locking:
+ * All hardware access under dev->priv->lock, except the performance
+ * critical parts:
+ * - rx is (pseudo-) lockless: it relies on the single-threading provided
+ * 	by the arch code for interrupts.
+ * - tx setup is lockless: it relies on dev->xmit_lock. Actual submission
+ *	needs dev->priv->lock :-(
+ * - set_multicast_list: preparation lockless, relies on dev->xmit_lock.
+ */
+
+/* in dev: base, irq */
+struct fe_priv {
+	spinlock_t lock;
+
+	/* General data:
+	 * Locking: spin_lock(&np->lock); */
+	struct net_device_stats stats;
+	int in_shutdown;
+	u32 linkspeed;
+	int duplex;
+	int phyaddr;
+
+	/* General data: RO fields */
+	dma_addr_t ring_addr;
+	struct pci_dev *pci_dev;
+	u32 orig_mac[2];
+	u32 irqmask;
+
+	/* rx specific fields.
+	 * Locking: Within irq hander or disable_irq+spin_lock(&np->lock);
+	 */
+	struct ring_desc *rx_ring;
+	unsigned int cur_rx, refill_rx;
+	struct sk_buff *rx_skbuff[RX_RING];
+	dma_addr_t rx_dma[RX_RING];
+	unsigned int rx_buf_sz;
+	struct timer_list oom_kick;
+	struct timer_list nic_poll;
+
+	/*
+	 * tx specific fields.
+	 */
+	struct ring_desc *tx_ring;
+	unsigned int next_tx, nic_tx;
+	struct sk_buff *tx_skbuff[TX_RING];
+	dma_addr_t tx_dma[TX_RING];
+	u16 tx_flags;
+};
+
+/*
+ * Maximum number of loops until we assume that a bit in the irq mask
+ * is stuck. Overridable with module param.
+ */
+static int max_interrupt_work = 5;
+
+static inline struct fe_priv *get_nvpriv(struct net_device *dev)
+{
+	return (struct fe_priv *) dev->priv;
+}
+
+static inline u8 *get_hwbase(struct net_device *dev)
+{
+	return (u8 *) dev->base_addr;
+}
+
+static inline void pci_push(u8 * base)
+{
+	/* force out pending posted writes */
+	readl(base);
+}
+
+static int reg_delay(struct net_device *dev, int offset, u32 mask, u32 target,
+				int delay, int delaymax, const char *msg)
+{
+	u8 *base = get_hwbase(dev);
+
+	pci_push(base);
+	do {
+		udelay(delay);
+		delaymax -= delay;
+		if (delaymax < 0) {
+			if (msg)
+				printk(msg);
+			return 1;
+		}
+	} while ((readl(base + offset) & mask) != target);
+	return 0;
+}
+
+#define MII_READ	(-1)
+/* mii_rw: read/write a register on the PHY.
+ *
+ * Caller must guarantee serialization
+ */
+static int mii_rw(struct net_device *dev, int addr, int miireg, int value)
+{
+	u8 *base = get_hwbase(dev);
+	int was_running;
+	u32 reg;
+	int retval;
+
+	writel(NVREG_MIISTAT_MASK, base + NvRegMIIStatus);
+	was_running = 0;
+	reg = readl(base + NvRegAdapterControl);
+	if (reg & NVREG_ADAPTCTL_RUNNING) {
+		was_running = 1;
+		writel(reg & ~NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+	}
+	reg = readl(base + NvRegMIIControl);
+	if (reg & NVREG_MIICTL_INUSE) {
+		writel(NVREG_MIICTL_INUSE, base + NvRegMIIControl);
+		udelay(NV_MIIBUSY_DELAY);
+	}
+
+	reg = NVREG_MIICTL_INUSE | (addr << NVREG_MIICTL_ADDRSHIFT) | miireg;
+	if (value != MII_READ) {
+		writel(value, base + NvRegMIIData);
+		reg |= NVREG_MIICTL_WRITE;
+	}
+	writel(reg, base + NvRegMIIControl);
+
+	if (reg_delay(dev, NvRegMIIControl, NVREG_MIICTL_INUSE, 0,
+			NV_MIIPHY_DELAY, NV_MIIPHY_DELAYMAX, NULL)) {
+		dprintk(KERN_DEBUG "%s: mii_rw of reg %d at PHY %d timed out.\n",
+				dev->name, miireg, addr);
+		retval = -1;
+	} else if (value != MII_READ) {
+		/* it was a write operation - fewer failures are detectable */
+		dprintk(KERN_DEBUG "%s: mii_rw wrote 0x%x to reg %d at PHY %d\n",
+				dev->name, value, miireg, addr);
+		retval = 0;
+	} else if (readl(base + NvRegMIIStatus) & NVREG_MIISTAT_ERROR) {
+		dprintk(KERN_DEBUG "%s: mii_rw of reg %d at PHY %d failed.\n",
+				dev->name, miireg, addr);
+		retval = -1;
+	} else {
+		/* FIXME: why is that required? */
+		udelay(50);
+		retval = readl(base + NvRegMIIData);
+		dprintk(KERN_DEBUG "%s: mii_rw read from reg %d at PHY %d: 0x%x.\n",
+				dev->name, miireg, addr, retval);
+	}
+	if (was_running) {
+		reg = readl(base + NvRegAdapterControl);
+		writel(reg | NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+	}
+	return retval;
+}
+
+static void start_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: start_rx\n", dev->name);
+	/* Already running? Stop it. */
+	if (readl(base + NvRegReceiverControl) & NVREG_RCVCTL_START) {
+		writel(0, base + NvRegReceiverControl);
+		pci_push(base);
+	}
+	writel(np->linkspeed, base + NvRegLinkSpeed);
+	pci_push(base);
+	writel(NVREG_RCVCTL_START, base + NvRegReceiverControl);
+	pci_push(base);
+}
+
+static void stop_rx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: stop_rx\n", dev->name);
+	writel(0, base + NvRegReceiverControl);
+	reg_delay(dev, NvRegReceiverStatus, NVREG_RCVSTAT_BUSY, 0,
+		       NV_RXSTOP_DELAY1, NV_RXSTOP_DELAY1MAX,
+		       KERN_INFO "stop_rx: ReceiverStatus remained busy");
+
+	udelay(NV_RXSTOP_DELAY2);
+	writel(0, base + NvRegLinkSpeed);
+}
+
+static void start_tx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: start_tx\n", dev->name);
+	writel(NVREG_XMITCTL_START, base + NvRegTransmitterControl);
+	pci_push(base);
+}
+
+static void stop_tx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: stop_tx\n", dev->name);
+	writel(0, base + NvRegTransmitterControl);
+	reg_delay(dev, NvRegTransmitterStatus, NVREG_XMITSTAT_BUSY, 0,
+		       NV_TXSTOP_DELAY1, NV_TXSTOP_DELAY1MAX,
+		       KERN_INFO "stop_tx: TransmitterStatus remained busy");
+
+	udelay(NV_TXSTOP_DELAY2);
+	writel(0, base + NvRegUnknownTransmitterReg);
+}
+
+static void txrx_reset(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: txrx_reset\n", dev->name);
+	writel(NVREG_TXRXCTL_BIT2 | NVREG_TXRXCTL_RESET, base + NvRegTxRxControl);
+	pci_push(base);
+	udelay(NV_TXRX_RESET_DELAY);
+	writel(NVREG_TXRXCTL_BIT2, base + NvRegTxRxControl);
+	pci_push(base);
+}
+
+/*
+ * get_stats: dev->get_stats function
+ * Get latest stats value from the nic.
+ * Called with read_lock(&dev_base_lock) held for read -
+ * only synchronized against unregister_netdevice.
+ */
+static struct net_device_stats *get_stats(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	/* It seems that the nic always generates interrupts and doesn't
+	 * accumulate errors internally. Thus the current values in np->stats
+	 * are already up to date.
+	 */
+	return &np->stats;
+}
+
+
+/*
+ * nic_ioctl: dev->do_ioctl function
+ * Called with rtnl_lock held.
+ */
+static int nic_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+/*
+ * alloc_rx: fill rx ring entries.
+ * Return 1 if the allocations for the skbs failed and the
+ * rx engine is without Available descriptors
+ */
+static int alloc_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	unsigned int refill_rx = np->refill_rx;
+
+	while (np->cur_rx != refill_rx) {
+		int nr = refill_rx % RX_RING;
+		struct sk_buff *skb;
+
+		if (np->rx_skbuff[nr] == NULL) {
+
+			skb = dev_alloc_skb(RX_ALLOC_BUFSIZE);
+			if (!skb)
+				break;
+
+			skb->dev = dev;
+			np->rx_skbuff[nr] = skb;
+		} else {
+			skb = np->rx_skbuff[nr];
+		}
+		np->rx_dma[nr] = pci_map_single(np->pci_dev, skb->data, skb->len,
+						PCI_DMA_FROMDEVICE);
+		np->rx_ring[nr].PacketBuffer = cpu_to_le32(np->rx_dma[nr]);
+		np->rx_ring[nr].Length = cpu_to_le16(RX_NIC_BUFSIZE);
+		wmb();
+		np->rx_ring[nr].Flags = cpu_to_le16(NV_RX_AVAIL);
+		dprintk(KERN_DEBUG "%s: alloc_rx: Packet  %d marked as Available\n",
+					dev->name, refill_rx);
+		refill_rx++;
+	}
+	np->refill_rx = refill_rx;
+	if (np->cur_rx - refill_rx == RX_RING)
+		return 1;
+	return 0;
+}
+
+static void do_rx_refill(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+
+	disable_irq(dev->irq);
+	if (alloc_rx(dev)) {
+		spin_lock(&np->lock);
+		if (!np->in_shutdown)
+			mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+		spin_unlock(&np->lock);
+	}
+	enable_irq(dev->irq);
+}
+
+static int init_ring(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+
+	np->next_tx = np->nic_tx = 0;
+	for (i = 0; i < TX_RING; i++) {
+		np->tx_ring[i].Flags = 0;
+	}
+
+	np->cur_rx = RX_RING;
+	np->refill_rx = 0;
+	for (i = 0; i < RX_RING; i++) {
+		np->rx_ring[i].Flags = 0;
+	}
+	return alloc_rx(dev);
+}
+
+static void drain_tx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+	for (i = 0; i < TX_RING; i++) {
+		np->tx_ring[i].Flags = 0;
+		if (np->tx_skbuff[i]) {
+			pci_unmap_single(np->pci_dev, np->tx_dma[i],
+						np->tx_skbuff[i]->len,
+						PCI_DMA_TODEVICE);
+			dev_kfree_skb(np->tx_skbuff[i]);
+			np->tx_skbuff[i] = NULL;
+			np->stats.tx_dropped++;
+		}
+	}
+}
+
+static void drain_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+	for (i = 0; i < RX_RING; i++) {
+		np->rx_ring[i].Flags = 0;
+		wmb();
+		if (np->rx_skbuff[i]) {
+			pci_unmap_single(np->pci_dev, np->rx_dma[i],
+						np->rx_skbuff[i]->len,
+						PCI_DMA_FROMDEVICE);
+			dev_kfree_skb(np->rx_skbuff[i]);
+			np->rx_skbuff[i] = NULL;
+		}
+	}
+}
+
+static void drain_ring(struct net_device *dev)
+{
+	drain_tx(dev);
+	drain_rx(dev);
+}
+
+/*
+ * start_xmit: dev->hard_start_xmit function
+ * Called with dev->xmit_lock held.
+ */
+static int start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int nr = np->next_tx % TX_RING;
+
+	np->tx_skbuff[nr] = skb;
+	np->tx_dma[nr] = pci_map_single(np->pci_dev, skb->data,skb->len,
+					PCI_DMA_TODEVICE);
+
+	np->tx_ring[nr].PacketBuffer = cpu_to_le32(np->tx_dma[nr]);
+	np->tx_ring[nr].Length = cpu_to_le16(skb->len-1);
+
+	spin_lock_irq(&np->lock);
+	wmb();
+	np->tx_ring[nr].Flags = np->tx_flags;
+	dprintk(KERN_DEBUG "%s: start_xmit: packet packet %d queued for transmission.\n",
+				dev->name, np->next_tx);
+	{
+		int j;
+		for (j=0; j<64; j++) {
+			if ((j%16) == 0)
+				dprintk("\n%03x:", j);
+			dprintk(" %02x", ((unsigned char*)skb->data)[j]);
+		}
+		dprintk("\n");
+	}
+
+	np->next_tx++;
+
+	dev->trans_start = jiffies;
+	if (np->next_tx - np->nic_tx >= TX_LIMIT_STOP)
+		netif_stop_queue(dev);
+	spin_unlock_irq(&np->lock);
+	writel(NVREG_TXRXCTL_KICK, get_hwbase(dev) + NvRegTxRxControl);
+	return 0;
+}
+
+/*
+ * tx_done: check for completed packets, release the skbs.
+ *
+ * Caller must own np->lock.
+ */
+static void tx_done(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	while (np->nic_tx < np->next_tx) {
+		struct ring_desc *prd;
+		int i = np->nic_tx % TX_RING;
+
+		prd = &np->tx_ring[i];
+
+		dprintk(KERN_DEBUG "%s: tx_done: looking at packet %d, Flags 0x%x.\n",
+					dev->name, np->nic_tx, prd->Flags);
+		if (prd->Flags & cpu_to_le16(NV_TX_VALID))
+			break;
+		if (prd->Flags & cpu_to_le16(NV_TX_RETRYERROR|NV_TX_CARRIERLOST|NV_TX_LATECOLLISION|
+						NV_TX_UNDERFLOW|NV_TX_ERROR)) {
+			if (prd->Flags & cpu_to_le16(NV_TX_UNDERFLOW))
+				np->stats.tx_fifo_errors++;
+			if (prd->Flags & cpu_to_le16(NV_TX_CARRIERLOST))
+				np->stats.tx_carrier_errors++;
+			np->stats.tx_errors++;
+		} else {
+			np->stats.tx_packets++;
+			np->stats.tx_bytes += np->tx_skbuff[i]->len;
+		}
+		pci_unmap_single(np->pci_dev, np->tx_dma[i],
+					np->tx_skbuff[i]->len,
+					PCI_DMA_TODEVICE);
+		dev_kfree_skb_irq(np->tx_skbuff[i]);
+		np->tx_skbuff[i] = NULL;
+		np->nic_tx++;
+	}
+	if (np->next_tx - np->nic_tx < TX_LIMIT_START)
+		netif_wake_queue(dev);
+}
+
+/*
+ * tx_timeout: dev->tx_timeout function
+ * Called with dev->xmit_lock held.
+ */
+static void tx_timeout(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: Got tx_timeout. irq: %08x\n", dev->name,
+			readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK);
+
+	spin_lock_irq(&np->lock);
+
+	/* 1) stop tx engine */
+	stop_tx(dev);
+
+	/* 2) check that the packets were not sent already: */
+	tx_done(dev);
+
+	/* 3) if there are dead entries: clear everything */
+	if (np->next_tx != np->nic_tx) {
+		printk(KERN_DEBUG "%s: tx_timeout: dead entries!\n", dev->name);
+		drain_tx(dev);
+		np->next_tx = np->nic_tx = 0;
+		writel((u32) (np->ring_addr + RX_RING*sizeof(struct ring_desc)), base + NvRegTxRingPhysAddr);
+		netif_wake_queue(dev);
+	}
+
+	/* 4) restart tx engine */
+	start_tx(dev);
+	spin_unlock_irq(&np->lock);
+}
+
+static void rx_process(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	for (;;) {
+		struct ring_desc *prd;
+		struct sk_buff *skb;
+		int len;
+		int i;
+		if (np->cur_rx - np->refill_rx >= RX_RING)
+			break;	/* we scanned the whole ring - do not continue */
+
+		i = np->cur_rx % RX_RING;
+		prd = &np->rx_ring[i];
+		dprintk(KERN_DEBUG "%s: rx_process: looking at packet %d, Flags 0x%x.\n",
+					dev->name, np->cur_rx, prd->Flags);
+
+		if (prd->Flags & cpu_to_le16(NV_RX_AVAIL))
+			break;	/* still owned by hardware, */
+
+		/*
+		 * the packet is for us - immediately tear down the pci mapping, and
+		 * prefetch the first cacheline of the packet.
+		 */
+		pci_unmap_single(np->pci_dev, np->rx_dma[i],
+				np->rx_skbuff[i]->len,
+				PCI_DMA_FROMDEVICE);
+		prefetch(np->rx_skbuff[i]->data);
+
+		{
+			int j;
+			dprintk(KERN_DEBUG "Dumping packet (flags 0x%x).",prd->Flags);
+			for (j=0; j<64; j++) {
+				if ((j%16) == 0)
+					dprintk("\n%03x:", j);
+				dprintk(" %02x", ((unsigned char*)np->rx_skbuff[i]->data)[j]);
+			}
+			dprintk("\n");
+		}
+		/* look at what we actually got: */
+		if (!(prd->Flags & cpu_to_le16(NV_RX_DESCRIPTORVALID)))
+			goto next_pkt;
+
+
+		len = le16_to_cpu(prd->Length);
+
+		if (prd->Flags & cpu_to_le16(NV_RX_MISSEDFRAME)) {
+			np->stats.rx_missed_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_ERROR1|NV_RX_ERROR2|NV_RX_ERROR3|NV_RX_ERROR4)) {
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_CRCERR)) {
+			np->stats.rx_crc_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_OVERFLOW)) {
+			np->stats.rx_over_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_ERROR)) {
+			/* framing errors are soft errors, the rest is fatal. */
+			if (prd->Flags & cpu_to_le16(NV_RX_FRAMINGERR)) {
+				if (prd->Flags & cpu_to_le16(NV_RX_SUBSTRACT1)) {
+					len--;
+				}
+			} else {
+				np->stats.rx_errors++;
+				goto next_pkt;
+			}
+		}
+		/* got a valid packet - forward it to the network core */
+		skb = np->rx_skbuff[i];
+		np->rx_skbuff[i] = NULL;
+
+		skb_put(skb, len);
+		skb->protocol = eth_type_trans(skb, dev);
+		dprintk(KERN_DEBUG "%s: rx_process: packet %d with %d bytes, proto %d accepted.\n",
+					dev->name, np->cur_rx, len, skb->protocol);
+		netif_rx(skb);
+		dev->last_rx = jiffies;
+		np->stats.rx_packets++;
+		np->stats.rx_bytes += len;
+next_pkt:
+		np->cur_rx++;
+	}
+}
+
+/*
+ * change_mtu: dev->change_mtu function
+ * Called with dev_base_lock held for read.
+ */
+static int change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu > DEFAULT_MTU)
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+/*
+ * change_mtu: dev->change_mtu function
+ * Called with dev->xmit_lock held.
+ */
+static void set_multicast(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 addr[2];
+	u32 mask[2];
+	u32 pff;
+
+	memset(addr, 0, sizeof(addr));
+	memset(mask, 0, sizeof(mask));
+
+	if (dev->flags & IFF_PROMISC) {
+		printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+		pff = NVREG_PFF_PROMISC;
+	} else {
+		pff = NVREG_PFF_MYADDR;
+
+		if (dev->flags & IFF_ALLMULTI || dev->mc_list) {
+			u32 alwaysOff[2];
+			u32 alwaysOn[2];
+
+			alwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0xffffffff;
+			if (dev->flags & IFF_ALLMULTI) {
+				alwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0;
+			} else {
+				struct dev_mc_list *walk;
+
+				walk = dev->mc_list;
+				while (walk != NULL) {
+					u32 a, b;
+					a = le32_to_cpu(*(u32 *) walk->dmi_addr);
+					b = le16_to_cpu(*(u16 *) (&walk->dmi_addr[4]));
+					alwaysOn[0] &= a;
+					alwaysOff[0] &= ~a;
+					alwaysOn[1] &= b;
+					alwaysOff[1] &= ~b;
+					walk = walk->next;
+				}
+			}
+			addr[0] = alwaysOn[0];
+			addr[1] = alwaysOn[1];
+			mask[0] = alwaysOn[0] | alwaysOff[0];
+			mask[1] = alwaysOn[1] | alwaysOff[1];
+		}
+	}
+	addr[0] |= NVREG_MCASTADDRA_FORCE;
+	pff |= NVREG_PFF_ALWAYS;
+	spin_lock_irq(&np->lock);
+	stop_rx(dev);
+	writel(addr[0], base + NvRegMulticastAddrA);
+	writel(addr[1], base + NvRegMulticastAddrB);
+	writel(mask[0], base + NvRegMulticastMaskA);
+	writel(mask[1], base + NvRegMulticastMaskB);
+	writel(pff, base + NvRegPacketFilterFlags);
+	start_rx(dev);
+	spin_unlock_irq(&np->lock);
+}
+
+static int update_linkspeed(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int adv, lpa, newls, newdup;
+
+	adv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);
+	lpa = mii_rw(dev, np->phyaddr, MII_LPA, MII_READ);
+	dprintk(KERN_DEBUG "%s: update_linkspeed: PHY advertises 0x%04x, lpa 0x%04x.\n",
+				dev->name, adv, lpa);
+
+	/* FIXME: handle parallel detection properly, handle gigabit ethernet */
+	lpa = lpa & adv;
+	if (lpa  & LPA_100FULL) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;
+		newdup = 1;
+	} else if (lpa & LPA_100HALF) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;
+		newdup = 0;
+	} else if (lpa & LPA_10FULL) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 1;
+	} else if (lpa & LPA_10HALF) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 0;
+	} else {
+		dprintk(KERN_DEBUG "%s: bad ability %04x - falling back to 10HD.\n", dev->name, lpa);
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 0;
+	}
+	if (np->duplex != newdup || np->linkspeed != newls) {
+		np->duplex = newdup;
+		np->linkspeed = newls;
+		return 1;
+	}
+	return 0;
+}
+
+static void link_irq(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 miistat;
+	int miival;
+
+	miistat = readl(base + NvRegMIIStatus);
+	writel(NVREG_MIISTAT_MASK, base + NvRegMIIStatus);
+	printk(KERN_DEBUG "%s: link change notification, status 0x%x.\n", dev->name, miistat);
+
+	miival = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);
+	if (miival & BMSR_ANEGCOMPLETE) {
+		update_linkspeed(dev);
+
+		if (netif_carrier_ok(dev)) {
+			stop_rx(dev);
+		} else {
+			netif_carrier_on(dev);
+			printk(KERN_INFO "%s: link up.\n", dev->name);
+		}
+		writel(NVREG_MISC1_FORCE | ( np->duplex ? 0 : NVREG_MISC1_HD),
+					base + NvRegMisc1);
+		start_rx(dev);
+	} else {
+		if (netif_carrier_ok(dev)) {
+			netif_carrier_off(dev);
+			printk(KERN_INFO "%s: link down.\n", dev->name);
+			stop_rx(dev);
+		}
+		writel(np->linkspeed, base + NvRegLinkSpeed);
+		pci_push(base);
+	}
+}
+
+static irqreturn_t nic_irq(int foo, void *data, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 events;
+	int i;
+
+	dprintk(KERN_DEBUG "%s: nic_irq\n", dev->name);
+
+	for (i=0; ; i++) {
+		events = readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK;
+		writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+		pci_push(base);
+		dprintk(KERN_DEBUG "%s: irq: %08x\n", dev->name, events);
+		if (!(events & np->irqmask))
+			break;
+
+		if (events & (NVREG_IRQ_TX1|NVREG_IRQ_TX2|NVREG_IRQ_TX_ERR)) {
+			spin_lock(&np->lock);
+			tx_done(dev);
+			spin_unlock(&np->lock);
+		}
+
+		if (events & (NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF)) {
+			rx_process(dev);
+			if (alloc_rx(dev)) {
+				spin_lock(&np->lock);
+				if (!np->in_shutdown)
+					mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+				spin_unlock(&np->lock);
+			}
+		}
+
+		if (events & NVREG_IRQ_LINK) {
+			spin_lock(&np->lock);
+			link_irq(dev);
+			spin_unlock(&np->lock);
+		}
+		if (events & (NVREG_IRQ_TX_ERR)) {
+			dprintk(KERN_DEBUG "%s: received irq with events 0x%x. Probably TX fail.\n",
+						dev->name, events);
+		}
+		if (events & (NVREG_IRQ_UNKNOWN)) {
+			printk(KERN_DEBUG "%s: received irq with unknown events 0x%x. Please report\n",
+						dev->name, events);
+ 		}
+		if (i > max_interrupt_work) {
+			spin_lock(&np->lock);
+			/* disable interrupts on the nic */
+			writel(0, base + NvRegIrqMask);
+			pci_push(base);
+
+			if (!np->in_shutdown)
+				mod_timer(&np->nic_poll, jiffies + POLL_WAIT);
+			printk(KERN_DEBUG "%s: too many iterations (%d) in nic_irq.\n", dev->name, i);
+			spin_unlock(&np->lock);
+			break;
+		}
+
+	}
+	dprintk(KERN_DEBUG "%s: nic_irq completed\n", dev->name);
+
+	return IRQ_RETVAL(i);
+}
+
+static void do_nic_poll(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	disable_irq(dev->irq);
+	/*
+	 * reenable interrupts on the nic, we have to do this before calling
+	 * nic_irq because that may decide to do otherwise
+	 */
+	writel(np->irqmask, base + NvRegIrqMask);
+	pci_push(base);
+	nic_irq((int) 0, (void *) data, (struct pt_regs *) NULL);
+	enable_irq(dev->irq);
+}
+
+static int open(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	int ret, oom, i;
+
+	dprintk(KERN_DEBUG "forcedeth: open\n");
+
+	/* 1) erase previous misconfiguration */
+	/* 4.1-1: stop adapter: ignored, 4.3 seems to be overkill */
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(0, base + NvRegPacketFilterFlags);
+	writel(0, base + NvRegAdapterControl);
+	writel(0, base + NvRegLinkSpeed);
+	writel(0, base + NvRegUnknownTransmitterReg);
+	txrx_reset(dev);
+	writel(0, base + NvRegUnknownSetupReg6);
+
+	/* 2) initialize descriptor rings */
+	np->in_shutdown = 0;
+	oom = init_ring(dev);
+
+	/* 3) set mac address */
+	{
+		u32 mac[2];
+
+		mac[0] = (dev->dev_addr[0] <<  0) + (dev->dev_addr[1] <<  8) +
+				(dev->dev_addr[2] << 16) + (dev->dev_addr[3] << 24);
+		mac[1] = (dev->dev_addr[4] << 0) + (dev->dev_addr[5] << 8);
+
+		writel(mac[0], base + NvRegMacAddrA);
+		writel(mac[1], base + NvRegMacAddrB);
+	}
+
+	/* 4) continue setup */
+	np->linkspeed = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+	np->duplex = 0;
+	writel(NVREG_UNKSETUP3_VAL1, base + NvRegUnknownSetupReg3);
+	writel(0, base + NvRegTxRxControl);
+	pci_push(base);
+	writel(NVREG_TXRXCTL_BIT1, base + NvRegTxRxControl);
+	reg_delay(dev, NvRegUnknownSetupReg5, NVREG_UNKSETUP5_BIT31, NVREG_UNKSETUP5_BIT31,
+			NV_SETUP5_DELAY, NV_SETUP5_DELAYMAX,
+			KERN_INFO "open: SetupReg5, Bit 31 remained off\n");
+	writel(0, base + NvRegUnknownSetupReg4);
+
+	/* 5) Find a suitable PHY */
+	writel(NVREG_MIISPEED_BIT8|NVREG_MIIDELAY, base + NvRegMIISpeed);
+	for (i = 1; i < 32; i++) {
+		int id1, id2;
+
+		id1 = mii_rw(dev, i, MII_PHYSID1, MII_READ);
+		if (id1 < 0)
+			continue;
+		id2 = mii_rw(dev, i, MII_PHYSID2, MII_READ);
+		if (id2 < 0)
+			continue;
+		dprintk(KERN_DEBUG "%s: open: Found PHY %04x:%04x at address %d.\n",
+				dev->name, id1, id2, i);
+		np->phyaddr = i;
+
+		update_linkspeed(dev);
+
+		break;
+	}
+	if (i == 32) {
+		printk(KERN_INFO "%s: open: failing due to lack of suitable PHY.\n",
+				dev->name);
+		ret = -EINVAL;
+		goto out_drain;
+	}
+
+	/* 6) continue setup */
+	writel(NVREG_MISC1_FORCE | ( np->duplex ? 0 : NVREG_MISC1_HD),
+				base + NvRegMisc1);
+	writel(readl(base + NvRegTransmitterStatus), base + NvRegTransmitterStatus);
+	writel(NVREG_PFF_ALWAYS, base + NvRegPacketFilterFlags);
+	writel(NVREG_OFFLOAD_NORMAL, base + NvRegOffloadConfig);
+
+	writel(readl(base + NvRegReceiverStatus), base + NvRegReceiverStatus);
+	get_random_bytes(&i, sizeof(i));
+	writel(NVREG_RNDSEED_FORCE | (i&NVREG_RNDSEED_MASK), base + NvRegRandomSeed);
+	writel(NVREG_UNKSETUP1_VAL, base + NvRegUnknownSetupReg1);
+	writel(NVREG_UNKSETUP2_VAL, base + NvRegUnknownSetupReg2);
+	writel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);
+	writel((np->phyaddr << NVREG_ADAPTCTL_PHYSHIFT)|NVREG_ADAPTCTL_PHYVALID,
+			base + NvRegAdapterControl);
+	writel(NVREG_UNKSETUP4_VAL, base + NvRegUnknownSetupReg4);
+	writel(NVREG_WAKEUPFLAGS_VAL, base + NvRegWakeUpFlags);
+
+	/* 7) start packet processing */
+	writel((u32) np->ring_addr, base + NvRegRxRingPhysAddr);
+	writel((u32) (np->ring_addr + RX_RING*sizeof(struct ring_desc)), base + NvRegTxRingPhysAddr);
+	writel( ((RX_RING-1) << NVREG_RINGSZ_RXSHIFT) + ((TX_RING-1) << NVREG_RINGSZ_TXSHIFT),
+			base + NvRegRingSizes);
+
+	i = readl(base + NvRegPowerState);
+	if ( (i & NVREG_POWERSTATE_POWEREDUP) == 0) {
+		writel(NVREG_POWERSTATE_POWEREDUP|i, base + NvRegPowerState);
+	}
+	pci_push(base);
+	udelay(10);
+	writel(readl(base + NvRegPowerState) | NVREG_POWERSTATE_VALID, base + NvRegPowerState);
+	writel(NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+
+
+	writel(0, base + NvRegIrqMask);
+	pci_push(base);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+	writel(NVREG_MIISTAT_MASK2, base + NvRegMIIStatus);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+
+	ret = request_irq(dev->irq, &nic_irq, SA_SHIRQ, dev->name, dev);
+	if (ret)
+		goto out_drain;
+
+	writel(np->irqmask, base + NvRegIrqMask);
+
+	spin_lock_irq(&np->lock);
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(NVREG_PFF_ALWAYS|NVREG_PFF_MYADDR, base + NvRegPacketFilterFlags);
+	start_rx(dev);
+	start_tx(dev);
+	netif_start_queue(dev);
+	if (oom)
+		mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+	if (!(mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ) & BMSR_ANEGCOMPLETE)) {
+		printk("%s: no link during initialization.\n", dev->name);
+		netif_carrier_off(dev);
+	}
+
+	spin_unlock_irq(&np->lock);
+
+	return 0;
+out_drain:
+	drain_ring(dev);
+	return ret;
+}
+
+static int close(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	spin_lock_irq(&np->lock);
+	np->in_shutdown = 1;
+	spin_unlock_irq(&np->lock);
+	synchronize_irq(dev->irq);
+
+	del_timer_sync(&np->oom_kick);
+	del_timer_sync(&np->nic_poll);
+
+	netif_stop_queue(dev);
+	spin_lock_irq(&np->lock);
+	stop_tx(dev);
+	stop_rx(dev);
+	spin_unlock_irq(&np->lock);
+
+	free_irq(dev->irq, dev);
+
+	drain_ring(dev);
+
+	/* FIXME: power down nic */
+
+	return 0;
+}
+
+static int __devinit probe_nic(struct pci_dev *pci_dev, const struct pci_device_id *id)
+{
+	struct net_device *dev;
+	struct fe_priv *np;
+	unsigned long addr;
+	u8 *base;
+	int err, i;
+
+	dev = alloc_etherdev(sizeof(struct fe_priv));
+	np = get_nvpriv(dev);
+	err = -ENOMEM;
+	if (!dev)
+		goto out;
+
+	np->pci_dev = pci_dev;
+	spin_lock_init(&np->lock);
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pci_dev->dev);
+
+	init_timer(&np->oom_kick);
+	np->oom_kick.data = (unsigned long) dev;
+	np->oom_kick.function = &do_rx_refill;	/* timer handler */
+	init_timer(&np->nic_poll);
+	np->nic_poll.data = (unsigned long) dev;
+	np->nic_poll.function = &do_nic_poll;	/* timer handler */
+
+	err = pci_enable_device(pci_dev);
+	if (err) {
+		printk(KERN_INFO "forcedeth: pci_enable_dev failed (%d) for device %s\n",
+				err, pci_name(pci_dev));
+		goto out_free;
+	}
+
+	pci_set_master(pci_dev);
+
+	err = pci_request_regions(pci_dev, dev->name);
+	if (err < 0)
+		goto out_disable;
+
+	err = -EINVAL;
+	addr = 0;
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		dprintk(KERN_DEBUG "%s: resource %d start %p len %ld flags 0x%08lx.\n",
+				pci_name(pci_dev), i, (void*)pci_resource_start(pci_dev, i),
+				pci_resource_len(pci_dev, i),
+				pci_resource_flags(pci_dev, i));
+		if (pci_resource_flags(pci_dev, i) & IORESOURCE_MEM &&
+				pci_resource_len(pci_dev, i) >= NV_PCI_REGSZ) {
+			addr = pci_resource_start(pci_dev, i);
+			break;
+		}
+	}
+	if (i == DEVICE_COUNT_RESOURCE) {
+		printk(KERN_INFO "forcedeth: Couldn't find register window for device %s.\n",
+					pci_name(pci_dev));
+		goto out_relreg;
+	}
+
+	err = -ENOMEM;
+	dev->base_addr = (unsigned long) ioremap(addr, NV_PCI_REGSZ);
+	if (!dev->base_addr)
+		goto out_disable;
+	dev->irq = pci_dev->irq;
+	np->rx_ring = pci_alloc_consistent(pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING),
+						&np->ring_addr);
+	if (!np->rx_ring)
+		goto out_unmap;
+	np->tx_ring = &np->rx_ring[RX_RING];
+
+	dev->open = open;
+	dev->stop = close;
+	dev->hard_start_xmit = start_xmit;
+	dev->get_stats = get_stats;
+	dev->change_mtu = change_mtu;
+	dev->set_multicast_list = set_multicast;
+	dev->do_ioctl = nic_ioctl;
+	dev->tx_timeout = tx_timeout;
+	dev->watchdog_timeo = NV_WATCHDOG_TIMEO;
+
+	pci_set_drvdata(pci_dev, dev);
+
+
+	/* read the mac address */
+	base = get_hwbase(dev);
+	np->orig_mac[0] = readl(base + NvRegMacAddrA);
+	np->orig_mac[1] = readl(base + NvRegMacAddrB);
+
+	dev->dev_addr[0] = (np->orig_mac[1] >>  8) & 0xff;
+	dev->dev_addr[1] = (np->orig_mac[1] >>  0) & 0xff;
+	dev->dev_addr[2] = (np->orig_mac[0] >> 24) & 0xff;
+	dev->dev_addr[3] = (np->orig_mac[0] >> 16) & 0xff;
+	dev->dev_addr[4] = (np->orig_mac[0] >>  8) & 0xff;
+	dev->dev_addr[5] = (np->orig_mac[0] >>  0) & 0xff;
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		/*
+		 * Bad mac address. At least one bios sets the mac address
+		 * to 01:23:45:67:89:ab
+		 */
+		printk(KERN_ERR "%s: Invalid Mac address detected: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			pci_name(pci_dev),
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+		printk(KERN_ERR "Please complain to your hardware vendor. Switching to a random MAC.\n");
+		dev->dev_addr[0] = 0x00;
+		dev->dev_addr[1] = 0x00;
+		dev->dev_addr[2] = 0x6c;
+		get_random_bytes(&dev->dev_addr[3], 3);
+	}
+
+	dprintk(KERN_DEBUG "%s: MAC Address %02x:%02x:%02x:%02x:%02x:%02x\n", pci_name(pci_dev),
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	np->tx_flags = cpu_to_le16(NV_TX_LASTPACKET|NV_TX_LASTPACKET1|NV_TX_VALID);
+	if (id->driver_data & DEV_NEED_LASTPACKET1)
+		np->tx_flags |= cpu_to_le16(NV_TX_LASTPACKET1);
+	if (id->driver_data & DEV_IRQMASK_1)
+		np->irqmask = NVREG_IRQMASK_WANTED_1;
+	if (id->driver_data & DEV_IRQMASK_2)
+		np->irqmask = NVREG_IRQMASK_WANTED_2;
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_INFO "forcedeth: unable to register netdev: %d\n", err);
+		goto out_freering;
+	}
+	printk(KERN_INFO "%s: forcedeth.c: subsystem: %05x:%04x bound to %s\n",
+			dev->name, pci_dev->subsystem_vendor, pci_dev->subsystem_device,
+			pci_name(pci_dev));
+
+	return 0;
+
+out_freering:
+	pci_free_consistent(np->pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING),
+				np->rx_ring, np->ring_addr);
+out_unmap:
+	iounmap(get_hwbase(dev));
+out_relreg:
+	pci_release_regions(pci_dev);
+out_disable:
+	pci_disable_device(pci_dev);
+out_free:
+	free_netdev(dev);
+	pci_set_drvdata(pci_dev, NULL);
+out:
+	return err;
+}
+
+static void __devexit remove_nic(struct pci_dev *pci_dev)
+{
+	struct net_device *dev = pci_get_drvdata(pci_dev);
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	unregister_netdev(dev);
+
+	/* special op: write back the misordered MAC address - otherwise
+	 * the next probe_nic would see a wrong address.
+	 */
+	writel(np->orig_mac[0], base + NvRegMacAddrA);
+	writel(np->orig_mac[1], base + NvRegMacAddrB);
+
+	/* free all structures */
+	pci_free_consistent(np->pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING), np->rx_ring, np->ring_addr);
+	iounmap(get_hwbase(dev));
+	pci_release_regions(pci_dev);
+	pci_disable_device(pci_dev);
+	free_netdev(dev);
+	pci_set_drvdata(pci_dev, NULL);
+}
+
+static struct pci_device_id pci_tbl[] = {
+	{	/* nForce Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x1C3,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_IRQMASK_1,
+	},
+	{	/* nForce2 Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x0066,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_NEED_LASTPACKET1|DEV_IRQMASK_2,
+	},
+	{	/* nForce3 Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x00D6,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_NEED_LASTPACKET1|DEV_IRQMASK_2,
+	},
+	{0,},
+};
+
+static struct pci_driver driver = {
+	.name = "forcedeth",
+	.id_table = pci_tbl,
+	.probe = probe_nic,
+	.remove = __devexit_p(remove_nic),
+};
+
+
+static int __init init_nic(void)
+{
+	printk(KERN_INFO "forcedeth.c: Reverse Engineered nForce ethernet driver. Version %s.\n", FORCEDETH_VERSION);
+	return pci_module_init(&driver);
+}
+
+static void __exit exit_nic(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+MODULE_PARM(max_interrupt_work, "i");
+MODULE_PARM_DESC(max_interrupt_work, "forcedeth maximum events handled per interrupt");
+ 
+MODULE_AUTHOR("Manfred Spraul <manfred@colorfullife.com>");
+MODULE_DESCRIPTION("Reverse Engineered nForce ethernet driver");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, pci_tbl);
+
+module_init(init_nic);
+module_exit(exit_nic);
diff -purN linux-2.6.1/drivers/net/hamradio/bpqether.c linux-2.5/drivers/net/hamradio/bpqether.c
--- linux-2.6.1/drivers/net/hamradio/bpqether.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/drivers/net/hamradio/bpqether.c	2004-01-14 00:38:01.000000000 +0000
@@ -606,33 +606,20 @@ static int bpq_device_event(struct notif
  */
 static int __init bpq_init_driver(void)
 {
-	struct net_device *dev;
-
-	dev_add_pack(&bpq_packet_type);
-
-	register_netdevice_notifier(&bpq_dev_notifier);
-
-	printk(banner);
-
 #ifdef CONFIG_PROC_FS
 	if (!proc_net_fops_create("bpqether", S_IRUGO, &bpq_info_fops)) {
 		printk(KERN_ERR
 			"bpq: cannot create /proc/net/bpqether entry.\n");
-		unregister_netdevice_notifier(&bpq_dev_notifier);
-		dev_remove_pack(&bpq_packet_type);
 		return -ENOENT;
 	}
 #endif  /* CONFIG_PROC_FS */
 
-	rtnl_lock();
-	for (dev = dev_base; dev != NULL; dev = dev->next) {
-		if (dev_is_ethdev(dev) && bpq_new_device(dev)) {
-			printk(KERN_ERR
-			       "bpq: cannot setup dev for '%s'\n",
-			       dev->name);
-		}
-	}
-	rtnl_unlock();
+	dev_add_pack(&bpq_packet_type);
+
+	register_netdevice_notifier(&bpq_dev_notifier);
+
+	printk(banner);
+
 	return 0;
 }
 
diff -purN linux-2.6.1/drivers/net/irda/sir-dev.h linux-2.5/drivers/net/irda/sir-dev.h
--- linux-2.6.1/drivers/net/irda/sir-dev.h	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir-dev.h	2004-01-09 10:09:46.000000000 +0000
@@ -179,6 +179,7 @@ struct sir_dev {
 
 	struct sir_fsm fsm;
 	atomic_t enable_rx;
+	int raw_tx;
 	spinlock_t tx_lock;
 
 	u32 new_speed;
diff -purN linux-2.6.1/drivers/net/irda/sir_dev.c linux-2.5/drivers/net/irda/sir_dev.c
--- linux-2.6.1/drivers/net/irda/sir_dev.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir_dev.c	2004-01-09 10:09:46.000000000 +0000
@@ -31,7 +31,9 @@ void sirdev_enable_rx(struct sir_dev *de
 
 	/* flush rx-buffer - should also help in case of problems with echo cancelation */
 	dev->rx_buff.data = dev->rx_buff.head;
-	dev->tx_buff.len = 0;
+	dev->rx_buff.len = 0;
+	dev->rx_buff.in_frame = FALSE;
+	dev->rx_buff.state = OUTSIDE_FRAME;
 	atomic_set(&dev->enable_rx, 1);
 }
 
@@ -62,24 +64,34 @@ int sirdev_set_dongle(struct sir_dev *de
 
 int sirdev_raw_write(struct sir_dev *dev, const char *buf, int len)
 {
+	unsigned long flags;
 	int ret;
 
 	if (unlikely(len > dev->tx_buff.truesize))
 		return -ENOSPC;
 
-	spin_lock_bh(&dev->tx_lock);		/* serialize with other tx operations */
-	while (dev->tx_buff.len > 0) {		/* wait until tx idle */
-		spin_unlock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);	/* serialize with other tx operations */
+	while (dev->tx_buff.len > 0) {			/* wait until tx idle */
+		spin_unlock_irqrestore(&dev->tx_lock, flags);
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(MSECS_TO_JIFFIES(10));
-		spin_lock_bh(&dev->tx_lock);
+		spin_lock_irqsave(&dev->tx_lock, flags);
 	}
 
 	dev->tx_buff.data = dev->tx_buff.head;
 	memcpy(dev->tx_buff.data, buf, len);	
+	dev->tx_buff.len = len;
 
 	ret = dev->drv->do_write(dev, dev->tx_buff.data, dev->tx_buff.len);
-	spin_unlock_bh(&dev->tx_lock);
+	if (ret > 0) {
+		IRDA_DEBUG(3, "%s(), raw-tx started\n", __FUNCTION__);
+
+		dev->tx_buff.data += ret;
+		dev->tx_buff.len -= ret;
+		dev->raw_tx = 1;
+		ret = len;		/* all data is going to be sent */
+	}
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 	return ret;
 }
 
@@ -94,13 +106,13 @@ int sirdev_raw_read(struct sir_dev *dev,
 
 	count = (len < dev->rx_buff.len) ? len : dev->rx_buff.len;
 
-	if (count > 0)
-		memcpy(buf, dev->rx_buff.head, count);
+	if (count > 0) {
+		memcpy(buf, dev->rx_buff.data, count);
+		dev->rx_buff.data += count;
+		dev->rx_buff.len -= count;
+	}
 
-	/* forget trailing stuff */
-	dev->rx_buff.data = dev->rx_buff.head;
-	dev->rx_buff.len = 0;
-	dev->rx_buff.state = OUTSIDE_FRAME;
+	/* remaining stuff gets flushed when re-enabling normal rx */
 
 	return count;
 }
@@ -114,11 +126,12 @@ int sirdev_raw_read(struct sir_dev *dev,
 
 void sirdev_write_complete(struct sir_dev *dev)
 {
+	unsigned long flags;
 	struct sk_buff *skb;
 	int actual = 0;
 	int err;
 	
-	spin_lock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);
 
 	IRDA_DEBUG(3, "%s() - dev->tx_buff.len = %d\n",
 		   __FUNCTION__, dev->tx_buff.len);
@@ -143,11 +156,24 @@ void sirdev_write_complete(struct sir_de
 			dev->tx_buff.len = 0;
 		}
 		if (dev->tx_buff.len > 0) {
-			spin_unlock_bh(&dev->tx_lock);
+			spin_unlock_irqrestore(&dev->tx_lock, flags);
 			return;
 		}
 	}
 
+	if (unlikely(dev->raw_tx != 0)) {
+		/* in raw mode we are just done now after the buffer was sent
+		 * completely. Since this was requested by some dongle driver
+		 * running under the control of the irda-thread we must take
+		 * care here not to re-enable the queue. The queue will be
+		 * restarted when the irda-thread has completed the request.
+		 */
+
+		IRDA_DEBUG(3, "%s(), raw-tx done\n", __FUNCTION__);
+		dev->raw_tx = 0;
+		return;
+	}
+
 	/* we have finished now sending this skb.
 	 * update statistics and free the skb.
 	 * finally we check and trigger a pending speed change, if any.
@@ -190,7 +216,7 @@ void sirdev_write_complete(struct sir_de
 		netif_wake_queue(dev->netdev);
 	}
 
-	spin_unlock_bh(&dev->tx_lock);
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 }
 
 /* called from client driver - likely with bh-context - to give us
@@ -258,6 +284,7 @@ static struct net_device_stats *sirdev_g
 static int sirdev_hard_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct sir_dev *dev = ndev->priv;
+	unsigned long flags;
 	int actual = 0;
 	int err;
 	s32 speed;
@@ -307,7 +334,7 @@ static int sirdev_hard_xmit(struct sk_bu
 	}
 
 	/* serialize with write completion */
-	spin_lock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);
 
         /* Copy skb to tx_buff while wrapping, stuffing and making CRC */
 	dev->tx_buff.len = async_wrap_skb(skb, dev->tx_buff.data, dev->tx_buff.truesize); 
@@ -337,7 +364,7 @@ static int sirdev_hard_xmit(struct sk_bu
 		dev->stats.tx_dropped++;		      
 		netif_wake_queue(ndev);
 	}
-	spin_unlock_bh(&dev->tx_lock);
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 
 	return 0;
 }
@@ -479,6 +506,7 @@ static int sirdev_open(struct net_device
 		goto errout_free;
 
 	sirdev_enable_rx(dev);
+	dev->raw_tx = 0;
 
 	netif_start_queue(ndev);
 	dev->irlap = irlap_open(ndev, &dev->qos, dev->hwname);
diff -purN linux-2.6.1/drivers/net/irda/sir_kthread.c linux-2.5/drivers/net/irda/sir_kthread.c
--- linux-2.6.1/drivers/net/irda/sir_kthread.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir_kthread.c	2004-01-09 10:09:12.000000000 +0000
@@ -436,14 +436,13 @@ int sirdev_schedule_request(struct sir_d
 
 	IRDA_DEBUG(2, "%s - state=0x%04x / param=%u\n", __FUNCTION__, initial_state, param);
 
-	if (in_interrupt()) {
-		if (down_trylock(&fsm->sem)) {
+	if (down_trylock(&fsm->sem)) {
+		if (in_interrupt()  ||  in_atomic()  ||  irqs_disabled()) {
 			IRDA_DEBUG(1, "%s(), state machine busy!\n", __FUNCTION__);
 			return -EWOULDBLOCK;
-		}
+		} else
+			down(&fsm->sem);
 	}
-	else
-		down(&fsm->sem);
 
 	if (fsm->state == SIRDEV_STATE_DEAD) {
 		/* race with sirdev_close should never happen */
diff -purN linux-2.6.1/drivers/net/natsemi.c linux-2.5/drivers/net/natsemi.c
--- linux-2.6.1/drivers/net/natsemi.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/drivers/net/natsemi.c	2004-01-10 14:25:00.000000000 +0000
@@ -765,19 +765,13 @@ static int __devinit natsemi_probe1 (str
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	i = pci_request_regions(pdev, dev->name);
-	if (i) {
-		free_netdev(dev);
-		return i;
-	}
+	if (i)
+		goto err_pci_request_regions;
 
-	{
-		void *mmio = ioremap (ioaddr, iosize);
-		if (!mmio) {
-			pci_release_regions(pdev);
-			free_netdev(dev);
-			return -ENOMEM;
-		}
-		ioaddr = (unsigned long) mmio;
+	ioaddr = (unsigned long) ioremap (ioaddr, iosize);
+	if (!ioaddr) {
+		i = -ENOMEM;
+		goto err_ioremap;
 	}
 
 	/* Work around the dropped serial bit. */
@@ -835,13 +829,9 @@ static int __devinit natsemi_probe1 (str
 		dev->mtu = mtu;
 
 	i = register_netdev(dev);
-	if (i) {
-		pci_release_regions(pdev);
-		unregister_netdev(dev);
-		free_netdev(dev);
-		pci_set_drvdata(pdev, NULL);
-		return i;
-	}
+	if (i)
+		goto err_register_netdev;
+
 	netif_carrier_off(dev);
 
 	if (netif_msg_drv(np)) {
@@ -878,6 +868,17 @@ static int __devinit natsemi_probe1 (str
 
 
 	return 0;
+
+ err_register_netdev:
+	iounmap ((void *) dev->base_addr);
+
+ err_ioremap:
+	pci_release_regions(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+ err_pci_request_regions:
+	free_netdev(dev);
+	return i;
 }
 
 
diff -purN linux-2.6.1/drivers/net/ne2k-pci.c linux-2.5/drivers/net/ne2k-pci.c
--- linux-2.6.1/drivers/net/ne2k-pci.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/net/ne2k-pci.c	2004-01-10 15:38:30.000000000 +0000
@@ -115,6 +115,7 @@ enum ne2k_pci_chipsets {
 	CH_Winbond_W89C940F,
 	CH_Holtek_HT80232,
 	CH_Holtek_HT80229,
+	CH_Winbond_89C940_8c4a,
 };
 
 
@@ -132,6 +133,7 @@ static struct {
 	{"Winbond W89C940F", 0},
 	{"Holtek HT80232", ONLY_16BIT_IO | HOLTEK_FDX},
 	{"Holtek HT80229", ONLY_32BIT_IO | HOLTEK_FDX | STOP_PG_0x60 },
+	{"Winbond W89C940(misprogrammed)", 0},
 	{0,}
 };
 
@@ -147,6 +149,7 @@ static struct pci_device_id ne2k_pci_tbl
 	{ 0x1050, 0x5a5a, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Winbond_W89C940F },
 	{ 0x12c3, 0x0058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Holtek_HT80232 },
 	{ 0x12c3, 0x5598, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Holtek_HT80229 },
+	{ 0x8c4a, 0x1980, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_Winbond_89C940_8c4a },
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, ne2k_pci_tbl);
diff -purN linux-2.6.1/drivers/net/pcmcia/Kconfig linux-2.5/drivers/net/pcmcia/Kconfig
--- linux-2.6.1/drivers/net/pcmcia/Kconfig	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/net/pcmcia/Kconfig	2004-01-01 05:56:50.000000000 +0000
@@ -119,7 +119,7 @@ config ARCNET_COM20020_CS
 
 config PCMCIA_IBMTR
 	tristate "IBM PCMCIA tokenring adapter support"
-	depends on NET_PCMCIA && IBMTR!=y && TR && PCMCIA
+	depends on NET_PCMCIA && IBMTR!=y && TR && PCMCIA && !64BIT
 	help
 	  Say Y here if you intend to attach this type of Token Ring PCMCIA
 	  card to your computer. You then also need to say Y to "Token Ring
diff -purN linux-2.6.1/drivers/net/pppoe.c linux-2.5/drivers/net/pppoe.c
--- linux-2.6.1/drivers/net/pppoe.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/net/pppoe.c	2004-01-09 09:51:46.000000000 +0000
@@ -775,8 +775,8 @@ static int pppoe_ioctl(struct socket *so
 }
 
 
-static int pppoe_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		  int total_len)
+static int pppoe_sendmsg(struct kiocb *iocb, struct socket *sock, 
+		  struct msghdr *m, size_t total_len)
 {
 	struct sk_buff *skb = NULL;
 	struct sock *sk = sock->sk;
@@ -939,7 +939,7 @@ static struct ppp_channel_ops pppoe_chan
 };
 
 static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,
-		  struct msghdr *m, int total_len, int flags)
+		  struct msghdr *m, size_t total_len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb = NULL;
diff -purN linux-2.6.1/drivers/net/sk98lin/Makefile linux-2.5/drivers/net/sk98lin/Makefile
--- linux-2.6.1/drivers/net/sk98lin/Makefile	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/Makefile	2004-01-10 16:16:06.000000000 +0000
@@ -76,7 +76,7 @@ endif
 # SK_DBGCAT_DRV_INT_SRC         0x04000000      interrupts sources
 # SK_DBGCAT_DRV_EVENT           0x08000000      driver events
 
-EXTRA_CFLAGS += -Idrivers/net/sk98lin -DSK_USE_CSUM -DGENESIS -DYUKON $(DBGDEF) $(SKPARAM)
+EXTRA_CFLAGS += -Idrivers/net/sk98lin -DSK_DIAG_SUPPORT -DSK_USE_CSUM -DGENESIS -DYUKON $(DBGDEF) $(SKPARAM)
 
 clean:
 	rm -f core *.o *.a *.s
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skcsum.h linux-2.5/drivers/net/sk98lin/h/skcsum.h
--- linux-2.6.1/drivers/net/sk98lin/h/skcsum.h	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skcsum.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.h
  * Project:	GEnesis - SysKonnect SK-NET Gigabit Ethernet (SK-98xx)
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 2001/02/06 11:21:39 $
+ * Version:	$Revision: 1.10 $
+ * Date:	$Date: 2003/08/20 13:59:57 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
@@ -26,6 +26,10 @@
  * History:
  *
  *	$Log: skcsum.h,v $
+ *	Revision 1.10  2003/08/20 13:59:57  mschmid
+ *	Changed notation of #ifndef SkCsCalculateChecksum to
+ *	#ifndef SK_CS_CALCULATE_CHECKSUM
+ *	
  *	Revision 1.9  2001/02/06 11:21:39  rassmann
  *	Editorial changes.
  *	
@@ -226,11 +230,11 @@ typedef struct s_CsPacketInfo {
 
 /* function prototypes ********************************************************/
 
-#ifndef SkCsCalculateChecksum
+#ifndef SK_CS_CALCULATE_CHECKSUM
 extern unsigned SkCsCalculateChecksum(
 	void		*pData,
 	unsigned	Length);
-#endif
+#endif /* SK_CS_CALCULATE_CHECKSUM */
 
 extern int SkCsEvent(
 	SK_AC		*pAc,
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skdrv1st.h linux-2.5/drivers/net/sk98lin/h/skdrv1st.h
--- linux-2.6.1/drivers/net/sk98lin/h/skdrv1st.h	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skdrv1st.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,15 +2,16 @@
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.1 $
- * Date:	$Date: 2003/07/21 07:22:43 $
+ * Version:	$Revision: 1.4 $
+ * Date:	$Date: 2003/11/12 14:28:14 $
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,15 @@
  * History:
  *
  *	$Log: skdrv1st.h,v $
+ *	Revision 1.4  2003/11/12 14:28:14  rroesler
+ *	Fix: use dedicated ip_fast_csum() on X86_64 systems
+ *	
+ *	Revision 1.3  2003/10/07 08:16:52  mlindner
+ *	Fix: Copyright changes
+ *	
+ *	Revision 1.2  2003/09/29 12:05:59  mlindner
+ *	Fix: Added define SK_CS_CALCULSTE_CHECKSUM
+ *	
  *	Revision 1.1  2003/07/21 07:22:43  rroesler
  *	Fix: Re-Enter after CVS crash
  *	
@@ -110,6 +120,9 @@
 #ifndef __INC_SKDRV1ST_H
 #define __INC_SKDRV1ST_H
 
+/* Check kernel version */
+#include <linux/version.h>
+
 typedef struct s_AC	SK_AC;
 
 /* Set card versions */
@@ -124,17 +137,15 @@ typedef struct s_AC	SK_AC;
 #define SK_PNMI_READ_U32(p,v)		memcpy((char*)&(v),(char*)(p),4)
 #define SK_PNMI_READ_U64(p,v)		memcpy((char*)&(v),(char*)(p),8)
 
-#define SkCsCalculateChecksum(p,l)	((~ip_compute_csum(p, l)) & 0xffff)
-
 #define SK_ADDR_EQUAL(a1,a2)		(!memcmp(a1,a2,6))
 
-
 #if !defined(__OPTIMIZE__)  ||  !defined(__KERNEL__)
 #warning  You must compile this file with the correct options!
 #warning  See the last lines of the source file.
 #error You must compile this driver with "-O".
 #endif
 
+#include <linux/version.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
@@ -154,6 +165,13 @@ typedef struct s_AC	SK_AC;
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 
+#define SK_CS_CALCULATE_CHECKSUM
+#ifndef CONFIG_X86_64
+#define SkCsCalculateChecksum(p,l)	((~ip_compute_csum(p, l)) & 0xffff)
+#else
+#define SkCsCalculateChecksum(p,l)	((~ip_fast_csum(p, l)) & 0xffff)
+#endif
+
 #include	"h/sktypes.h"
 #include	"h/skerror.h"
 #include	"h/skdebug.h"
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skdrv2nd.h linux-2.5/drivers/net/sk98lin/h/skdrv2nd.h
--- linux-2.6.1/drivers/net/sk98lin/h/skdrv2nd.h	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skdrv2nd.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,15 +2,16 @@
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.3 $
- * Date:	$Date: 2003/08/12 16:51:18 $
+ * Version:	$Revision: 1.10 $
+ * Date:	$Date: 2003/12/11 16:04:45 $
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,27 @@
  * History:
  *
  *	$Log: skdrv2nd.h,v $
+ *	Revision 1.10  2003/12/11 16:04:45  mlindner
+ *	Add: New pnmi data backup structure
+ *	
+ *	Revision 1.9  2003/11/10 09:31:37  rroesler
+ *	Add: pnmiBackup structure for DIAG backup restore
+ *	
+ *	Revision 1.8  2003/10/22 14:18:32  rroesler
+ *	Fix: DIAG handling for DualNet cards
+ *	
+ *	Revision 1.7  2003/10/07 09:34:59  mlindner
+ *	Add: New defines for lower and upper range values (interrupt moderation)
+ *	
+ *	Revision 1.6  2003/10/07 08:16:51  mlindner
+ *	Fix: Copyright changes
+ *	
+ *	Revision 1.5  2003/09/01 13:10:39  rroesler
+ *	Add: Prototypes for DIAG Attach/Detach functions
+ *	
+ *	Revision 1.4  2003/09/01 12:33:38  rroesler
+ *	Add: Defines for optimized DIAG interaction
+ *	
  *	Revision 1.3  2003/08/12 16:51:18  mlindner
  *	Fix: UDP and TCP Proto checks
  *	Fix: UDP header offset
@@ -206,6 +228,11 @@ extern int		SkPciWriteCfgWord(SK_AC*, in
 extern int		SkPciWriteCfgByte(SK_AC*, int, SK_U8);
 extern int		SkDrvEvent(SK_AC*, SK_IOC IoC, SK_U32, SK_EVPARA);
 
+#ifdef SK_DIAG_SUPPORT
+extern int		SkDrvEnterDiagMode(SK_AC *pAc);
+extern int		SkDrvLeaveDiagMode(SK_AC *pAc);
+#endif
+
 struct s_DrvRlmtMbuf {
 	SK_MBUF		*pNext;		/* Pointer to next RLMT Mbuf. */
 	SK_U8		*pData;		/* Data buffer (virtually contig.). */
@@ -247,6 +274,7 @@ struct s_DrvRlmtMbuf {
 #define		SK_IOCTL_SETMIB		(SK_IOCTL_BASE + 1)
 #define		SK_IOCTL_PRESETMIB	(SK_IOCTL_BASE + 2)
 #define		SK_IOCTL_GEN		(SK_IOCTL_BASE + 3)
+#define		SK_IOCTL_DIAG		(SK_IOCTL_BASE + 4)
 
 typedef struct s_IOCTL	SK_GE_IOCTL;
 
@@ -462,6 +490,9 @@ struct s_RxPort {
 #define C_INTS_PER_SEC_DEFAULT      2000 
 #define C_INT_MOD_ENABLE_PERCENTAGE   50 /* if higher 50% enable */
 #define C_INT_MOD_DISABLE_PERCENTAGE  50 /* if lower 50% disable */
+#define C_INT_MOD_IPS_LOWER_RANGE     30
+#define C_INT_MOD_IPS_UPPER_RANGE     40000
+
 
 typedef struct s_DynIrqModInfo  DIM_INFO;
 struct s_DynIrqModInfo {
@@ -493,6 +524,11 @@ typedef struct s_PerStrm	PER_STRM;
 
 #define SK_ALLOC_IRQ	0x00000001
 
+#ifdef SK_DIAG_SUPPORT
+#define	DIAG_ACTIVE		1
+#define	DIAG_NOTACTIVE		0
+#endif
+
 /****************************************************************************
  * Per board structure / Adapter Context structure:
  *	Allocated within attach(9e) and freed within detach(9e).
@@ -563,9 +599,18 @@ struct s_AC  {
 	int		PortUp;
 	int		PortDown;
 	int		ChipsetType;	/*  Chipset family type 
-							 *  0 == Genesis family support
-							 *  1 == Yukon family support
-							 */
+					 *  0 == Genesis family support
+					 *  1 == Yukon family support
+					 */
+#ifdef SK_DIAG_SUPPORT
+	SK_U32		DiagModeActive;		/* is diag active?	*/
+	SK_BOOL		DiagFlowCtrl;		/* for control purposes	*/
+	SK_PNMI_STRUCT_DATA PnmiBackup;		/* backup structure for all Pnmi-Data */
+	SK_BOOL         WasIfUp[SK_MAX_MACS];   /* for OpenClose while 
+						 * DIAG is busy with NIC 
+						 */
+#endif
+
 };
 
 
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skgehw.h linux-2.5/drivers/net/sk98lin/h/skgehw.h
--- linux-2.6.1/drivers/net/sk98lin/h/skgehw.h	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skgehw.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgehw.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.53 $
- * Date:	$Date: 2003/07/04 12:39:01 $
+ * Version:	$Revision: 1.56 $
+ * Date:	$Date: 2003/09/23 09:01:00 $
  * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
@@ -26,6 +26,17 @@
  *
  * History:
  * $Log: skgehw.h,v $
+ * Revision 1.56  2003/09/23 09:01:00  malthoff
+ * Minor change: Define I2C device size constants as long.
+ *
+ * Revision 1.55  2003/09/16 14:03:34  rschmidt
+ * Added define for YUKON-Lite Rev. A1,A2 Chip Revision
+ * Moved defines for PHY power down modes to skgeinit.h
+ * Editorial changes
+ *
+ * Revision 1.54  2003/09/16 07:37:58  mschmid
+ * Added defines for Marvell PHY low power modes
+ *
  * Revision 1.53  2003/07/04 12:39:01  rschmidt
  * Added SK_FAR to pointers in XM_IN32() and GM_IN32() macros (for PXE)
  * Editorial changes
@@ -84,7 +95,7 @@
  * Editorial changes
  *
  * Revision 1.39  2002/06/10 09:37:07  rschmidt
- * Added macros for the ADDR-Modul
+ * Added macros for the ADDR-Module
  *
  * Revision 1.38  2002/06/05 08:15:19  rschmidt
  * Added defines for WOL Registers
@@ -628,12 +639,12 @@ extern "C" {
 #define B2_FAR			0x0120	/* 32 bit	Flash-Prom Addr Reg/Cnt */
 #define B2_FDP			0x0124	/*  8 bit	Flash-Prom Data Port */
 	/* 0x0125 - 0x0127:	reserved */
-#define B2_LD_CRTL		0x0128	/*  8 bit	EPROM loader control register */
+#define B2_LD_CTRL		0x0128	/*  8 bit	EPROM loader control register */
 #define B2_LD_TEST		0x0129	/*  8 bit	EPROM loader test register */
 	/* 0x012a - 0x012f:	reserved */
 #define B2_TI_INI		0x0130	/* 32 bit	Timer Init Value */
 #define B2_TI_VAL		0x0134	/* 32 bit	Timer Value */
-#define B2_TI_CRTL		0x0138	/*  8 bit	Timer Control */
+#define B2_TI_CTRL		0x0138	/*  8 bit	Timer Control */
 #define B2_TI_TEST		0x0139	/*  8 Bit	Timer Test */
 	/* 0x013a - 0x013f:	reserved */
 #define B2_IRQM_INI		0x0140	/* 32 bit	IRQ Moderation Timer Init Reg.*/
@@ -1021,7 +1032,7 @@ extern "C" {
 								/* Bit 7:	reserved */
 #define RAP_RAP			0x3f	/* Bit 6..0:	0 = block 0,..,6f = block 6f */
 
-/*	B0_CTST		16 bit	Control/Status register */
+/*	B0_CTST			16 bit	Control/Status register */
 								/* Bit 15..14:	reserved */
 #define CS_CLK_RUN_HOT	BIT_13S		/* CLK_RUN hot m. (YUKON-Lite only) */
 #define CS_CLK_RUN_RST	BIT_12S		/* CLK_RUN reset  (YUKON-Lite only) */
@@ -1038,7 +1049,7 @@ extern "C" {
 #define CS_RST_CLR		BIT_1S		/* Clear Software reset	*/
 #define CS_RST_SET		BIT_0S		/* Set   Software reset	*/
 
-/*	B0_LED		 8 Bit	LED register */
+/*	B0_LED			 8 Bit	LED register */
 								/* Bit  7.. 2:	reserved */
 #define LED_STAT_ON		BIT_1S		/* Status LED on	*/
 #define LED_STAT_OFF	BIT_0S		/* Status LED off	*/
@@ -1053,9 +1064,9 @@ extern "C" {
 #define PC_VCC_ON		BIT_1       /* Switch VCC On  */
 #define PC_VCC_OFF		BIT_0       /* Switch VCC Off */
 
-/*	B0_ISRC		32 bit	Interrupt Source Register */
-/*	B0_IMSK		32 bit	Interrupt Mask Register */
-/*	B0_SP_ISRC	32 bit	Special Interrupt Source Reg */
+/*	B0_ISRC			32 bit	Interrupt Source Register */
+/*	B0_IMSK			32 bit	Interrupt Mask Register */
+/*	B0_SP_ISRC		32 bit	Special Interrupt Source Reg */
 /*	B2_IRQM_MSK 	32 bit	IRQ Moderation Mask */
 #define IS_ALL_MSK		0xbfffffffUL	/* All Interrupt bits */
 #define IS_HW_ERR		BIT_31		/* Interrupt HW Error */
@@ -1099,9 +1110,9 @@ extern "C" {
 #define IS_XA2_C		BIT_0		/* Q_XA2 Encoding Error */
 
 
-/*	B0_HWE_ISRC	32 bit	HW Error Interrupt Src Reg */
-/*	B0_HWE_IMSK	32 bit	HW Error Interrupt Mask Reg */
-/*	B2_IRQM_HWE_MSK 32 bit	IRQ Moderation HW Error Mask */
+/*	B0_HWE_ISRC		32 bit	HW Error Interrupt Src Reg */
+/*	B0_HWE_IMSK		32 bit	HW Error Interrupt Mask Reg */
+/*	B2_IRQM_HWE_MSK	32 bit	IRQ Moderation HW Error Mask */
 #define IS_ERR_MSK		0x00000fffL	/* 		All Error bits */
 								/* Bit 31..14:	reserved */
 #define IS_IRQ_TIST_OV	BIT_13	/* Time Stamp Timer Overflow (YUKON only) */
@@ -1119,29 +1130,32 @@ extern "C" {
 #define IS_R1_PAR_ERR	BIT_1	/* Queue R1 Parity Error */
 #define IS_R2_PAR_ERR	BIT_0	/* Queue R2 Parity Error */
 
-/*	B2_CONN_TYP	 8 bit	Connector type */
-/*	B2_PMD_TYP	 8 bit	PMD type */
+/*	B2_CONN_TYP		 8 bit	Connector type */
+/*	B2_PMD_TYP		 8 bit	PMD type */
 /*	Values of connector and PMD type comply to SysKonnect internal std */
 
-/*	B2_MAC_CFG	 8 bit	MAC Configuration / Chip Revision */
+/*	B2_MAC_CFG		 8 bit	MAC Configuration / Chip Revision */
 #define CFG_CHIP_R_MSK	(0xf<<4)	/* Bit 7.. 4: Chip Revision */
 									/* Bit 3.. 2:	reserved */
 #define CFG_DIS_M2_CLK	BIT_1S		/* Disable Clock for 2nd MAC */
 #define CFG_SNG_MAC		BIT_0S		/* MAC Config: 0=2 MACs / 1=1 MAC*/
 
-/*	B2_CHIP_ID	 8 bit 	Chip Identification Number */
+/*	B2_CHIP_ID		 8 bit 	Chip Identification Number */
 #define CHIP_ID_GENESIS		0x0a	/* Chip ID for GENESIS */
 #define CHIP_ID_YUKON		0xb0	/* Chip ID for YUKON */
-#define CHIP_ID_YUKON_LITE	0xb1	/* Chip ID for YUKON-Lite (Rev. A1) */
+#define CHIP_ID_YUKON_LITE	0xb1	/* Chip ID for YUKON-Lite (Rev. A1-A3) */
 #define CHIP_ID_YUKON_LP	0xb2	/* Chip ID for YUKON-LP */
 
-/*	B2_FAR		32 bit	Flash-Prom Addr Reg/Cnt */
+#define CHIP_REV_YU_LITE_A1	3		/* Chip Rev. for YUKON-Lite A1,A2 */
+#define CHIP_REV_YU_LITE_A3	7		/* Chip Rev. for YUKON-Lite A3 */
+
+/*	B2_FAR			32 bit	Flash-Prom Addr Reg/Cnt */
 #define FAR_ADDR		0x1ffffL	/* Bit 16.. 0:	FPROM Address mask */
 
-/*	B2_LD_CRTL	 8 bit	EPROM loader control register */
+/*	B2_LD_CTRL		 8 bit	EPROM loader control register */
 /*	Bits are currently reserved */
 
-/*	B2_LD_TEST	 8 bit	EPROM loader test register */
+/*	B2_LD_TEST		 8 bit	EPROM loader test register */
 								/* Bit 7.. 4:	reserved */
 #define LD_T_ON			BIT_3S	/* Loader Test mode on */
 #define LD_T_OFF		BIT_2S	/* Loader Test mode off */
@@ -1151,16 +1165,16 @@ extern "C" {
 /*
  *	Timer Section
  */
-/*	B2_TI_CRTL	 8 bit	Timer control */
+/*	B2_TI_CTRL		 8 bit	Timer control */
 /*	B2_IRQM_CTRL	 8 bit	IRQ Moderation Timer Control */
 								/* Bit 7.. 3:	reserved */
 #define TIM_START		BIT_2S	/* Start Timer */
 #define TIM_STOP		BIT_1S	/* Stop  Timer */
 #define TIM_CLR_IRQ		BIT_0S	/* Clear Timer IRQ (!IRQM) */
 
-/*	B2_TI_TEST	 8 Bit	Timer Test */
+/*	B2_TI_TEST		 8 Bit	Timer Test */
 /*	B2_IRQM_TEST	 8 bit	IRQ Moderation Timer Test */
-/*	B28_DPT_TST	 8 bit	Descriptor Poll Timer Test Reg */
+/*	B28_DPT_TST		 8 bit	Descriptor Poll Timer Test Reg */
 								/* Bit 7.. 3:	reserved */
 #define TIM_T_ON		BIT_2S	/* Test mode on */
 #define TIM_T_OFF		BIT_1S	/* Test mode off */
@@ -1197,7 +1211,7 @@ extern "C" {
 #define TST_FRC_APERR_1M64	BIT_1S	/* AddrPERR on 1. phase */
 #define TST_FRC_APERR_2M64	BIT_0S	/* AddrPERR on 2. phase */
 
-/*	B2_GP_IO	32 bit	General Purpose I/O Register */
+/*	B2_GP_IO		32 bit	General Purpose I/O Register */
 							/* Bit 31..26:	reserved */
 #define GP_DIR_9	BIT_25	/* IO_9 direct, 0=In/1=Out */
 #define GP_DIR_8	BIT_24	/* IO_8 direct, 0=In/1=Out */
@@ -1221,28 +1235,28 @@ extern "C" {
 #define GP_IO_1		BIT_1	/* IO_1 pin */
 #define GP_IO_0		BIT_0	/* IO_0 pin */
 
-/*	B2_I2C_CTRL	32 bit	I2C HW Control Register */
+/*	B2_I2C_CTRL		32 bit	I2C HW Control Register */
 #define I2C_FLAG		BIT_31		/* Start read/write if WR */
 #define I2C_ADDR		(0x7fffL<<16)	/* Bit 30..16:	Addr to be RD/WR */
 #define I2C_DEV_SEL		(0x7fL<<9)		/* Bit 15.. 9:	I2C Device Select */
 								/* Bit	8.. 5:	reserved	*/
 #define I2C_BURST_LEN	BIT_4		/* Burst Len, 1/4 bytes */
-#define I2C_DEV_SIZE	(7L<<1)		/* Bit	3.. 1:	I2C Device Size	*/
-#define I2C_025K_DEV	(0L<<1)		/*		0: 256 Bytes or smal. */
-#define I2C_05K_DEV		(1L<<1)		/* 		1: 512	Bytes	*/
-#define I2C_1K_DEV		(2L<<1)		/*		2: 1024 Bytes	*/
-#define I2C_2K_DEV		(3L<<1)		/*		3: 2048	Bytes	*/
-#define I2C_4K_DEV		(4L<<1)		/*		4: 4096 Bytes	*/
-#define I2C_8K_DEV		(5L<<1)		/*		5: 8192 Bytes	*/
-#define I2C_16K_DEV		(6L<<1)		/*		6: 16384 Bytes	*/
-#define I2C_32K_DEV		(7L<<1)		/*		7: 32768 Bytes	*/
+#define I2C_DEV_SIZE	(7<<1)		/* Bit	3.. 1:	I2C Device Size	*/
+#define I2C_025K_DEV	(0<<1)		/*		0: 256 Bytes or smal. */
+#define I2C_05K_DEV		(1<<1)		/* 		1: 512	Bytes	*/
+#define I2C_1K_DEV		(2<<1)		/*		2: 1024 Bytes	*/
+#define I2C_2K_DEV		(3<<1)		/*		3: 2048	Bytes	*/
+#define I2C_4K_DEV		(4<<1)		/*		4: 4096 Bytes	*/
+#define I2C_8K_DEV		(5<<1)		/*		5: 8192 Bytes	*/
+#define I2C_16K_DEV		(6<<1)		/*		6: 16384 Bytes	*/
+#define I2C_32K_DEV		(7<<1)		/*		7: 32768 Bytes	*/
 #define I2C_STOP		BIT_0		/* Interrupt I2C transfer */
 
-/*	B2_I2C_IRQ	32 bit	I2C HW IRQ Register */
+/*	B2_I2C_IRQ		32 bit	I2C HW IRQ Register */
 								/* Bit 31.. 1	reserved */
 #define I2C_CLR_IRQ		BIT_0	/* Clear I2C IRQ */
 
-/*	B2_I2C_SW	32 bit (8 bit access)	I2C HW SW Port Register */
+/*	B2_I2C_SW		32 bit (8 bit access)	I2C HW SW Port Register */
 								/* Bit  7.. 3:	reserved */
 #define I2C_DATA_DIR	BIT_2S		/* direction of I2C_DATA */
 #define I2C_DATA		BIT_1S		/* I2C Data Port	*/
@@ -1254,27 +1268,27 @@ extern "C" {
 #define I2C_SENS_ADDR	LM80_ADDR	/* I2C Sensor Address, (Volt and Temp)*/
 
 
-/*	B2_BSC_CTRL	 8 bit	Blink Source Counter Control */
+/*	B2_BSC_CTRL		 8 bit	Blink Source Counter Control */
 							/* Bit  7.. 2:	reserved */
 #define BSC_START	BIT_1S		/* Start Blink Source Counter */
 #define BSC_STOP	BIT_0S		/* Stop  Blink Source Counter */
 
-/*	B2_BSC_STAT	 8 bit	Blink Source Counter Status */
+/*	B2_BSC_STAT		 8 bit	Blink Source Counter Status */
 							/* Bit  7.. 1:	reserved */
 #define BSC_SRC		BIT_0S		/* Blink Source, 0=Off / 1=On */
 
-/*	B2_BSC_TST	16 bit	Blink Source Counter Test Reg */
+/*	B2_BSC_TST		16 bit	Blink Source Counter Test Reg */
 #define BSC_T_ON	BIT_2S		/* Test mode on */
 #define BSC_T_OFF	BIT_1S		/* Test mode off */
 #define BSC_T_STEP	BIT_0S		/* Test step */
 
 
-/*	B3_RAM_ADDR	32 bit	RAM Address, to read or write */
+/*	B3_RAM_ADDR		32 bit	RAM Address, to read or write */
 					/* Bit 31..19:	reserved */
 #define RAM_ADR_RAN	0x0007ffffL	/* Bit 18.. 0:	RAM Address Range */
 
 /* RAM Interface Registers */
-/*	B3_RI_CTRL	16 bit	RAM Iface Control Register */
+/*	B3_RI_CTRL		16 bit	RAM Iface Control Register */
 								/* Bit 15..10:	reserved */
 #define RI_CLR_RD_PERR	BIT_9S	/* Clear IRQ RAM Read Parity Err */
 #define RI_CLR_WR_PERR	BIT_8S	/* Clear IRQ RAM Write Parity Err*/
@@ -1282,7 +1296,7 @@ extern "C" {
 #define RI_RST_CLR		BIT_1S	/* Clear RAM Interface Reset */
 #define RI_RST_SET		BIT_0S	/* Set   RAM Interface Reset */
 
-/*	B3_RI_TEST	 8 bit	RAM Iface Test Register */
+/*	B3_RI_TEST		 8 bit	RAM Iface Test Register */
 								/* Bit 15.. 4:	reserved */
 #define RI_T_EV			BIT_3S	/* Timeout Event occured */
 #define RI_T_ON			BIT_2S	/* Timeout Timer Test On */
@@ -1309,7 +1323,7 @@ extern "C" {
 #define MA_DIS_REC_RX1	BIT_0S	/* Disable Recovery Timer RX1 */
 
 /* Packet Arbiter Registers */
-/*	B3_PA_CTRL	16 bit	Packet Arbiter Ctrl Register */
+/*	B3_PA_CTRL		16 bit	Packet Arbiter Ctrl Register */
 								/* Bit 15..14:	reserved */
 #define PA_CLR_TO_TX2	BIT_13S	/* Clear IRQ Packet Timeout TX2 */
 #define PA_CLR_TO_TX1	BIT_12S	/* Clear IRQ Packet Timeout TX1 */
@@ -1332,7 +1346,7 @@ extern "C" {
 /* Rx/Tx Path related Arbiter Test Registers */
 /*	B3_MA_TO_TEST	16 bit	MAC Arbiter Timeout Test Reg */
 /*	B3_MA_RC_TEST	16 bit	MAC Arbiter Recovery Test Reg */
-/*	B3_PA_TEST	16 bit	Packet Arbiter Test Register */
+/*	B3_PA_TEST		16 bit	Packet Arbiter Test Register */
 /*			Bit 15, 11, 7, and 3 are reserved in B3_PA_TEST */
 #define TX2_T_EV	BIT_15S		/* TX2 Timeout/Recv Event occured */
 #define TX2_T_ON	BIT_14S		/* TX2 Timeout/Recv Timer Test On */
@@ -1353,14 +1367,14 @@ extern "C" {
 
 
 /* Transmit Arbiter Registers MAC 1 and 2, use MR_ADDR() to access */
-/*	TXA_ITI_INI	32 bit	Tx Arb Interval Timer Init Val */
-/*	TXA_ITI_VAL	32 bit	Tx Arb Interval Timer Value */
-/*	TXA_LIM_INI	32 bit	Tx Arb Limit Counter Init Val */
-/*	TXA_LIM_VAL	32 bit	Tx Arb Limit Counter Value */
+/*	TXA_ITI_INI		32 bit	Tx Arb Interval Timer Init Val */
+/*	TXA_ITI_VAL		32 bit	Tx Arb Interval Timer Value */
+/*	TXA_LIM_INI		32 bit	Tx Arb Limit Counter Init Val */
+/*	TXA_LIM_VAL		32 bit	Tx Arb Limit Counter Value */
 								/* Bit 31..24:	reserved */
 #define TXA_MAX_VAL	0x00ffffffUL/* Bit 23.. 0:	Max TXA Timer/Cnt Val */
 
-/*	TXA_CTRL	 8 bit	Tx Arbiter Control Register */
+/*	TXA_CTRL		 8 bit	Tx Arbiter Control Register */
 #define TXA_ENA_FSYNC	BIT_7S	/* Enable  force of sync Tx queue */
 #define TXA_DIS_FSYNC	BIT_6S	/* Disable force of sync Tx queue */
 #define TXA_ENA_ALLOC	BIT_5S	/* Enable  alloc of free bandwidth */
@@ -1370,7 +1384,7 @@ extern "C" {
 #define TXA_ENA_ARB		BIT_1S	/* Enable  Tx Arbiter */
 #define TXA_DIS_ARB		BIT_0S	/* Disable Tx Arbiter */
 
-/*	TXA_TEST	 8 bit	Tx Arbiter Test Register */
+/*	TXA_TEST		 8 bit	Tx Arbiter Test Register */
 								/* Bit 7.. 6:	reserved */
 #define TXA_INT_T_ON	BIT_5S	/* Tx Arb Interval Timer Test On */
 #define TXA_INT_T_OFF	BIT_4S	/* Tx Arb Interval Timer Test Off */
@@ -1379,22 +1393,22 @@ extern "C" {
 #define TXA_LIM_T_OFF	BIT_1S	/* Tx Arb Limit Timer Test Off */
 #define TXA_LIM_T_STEP	BIT_0S	/* Tx Arb Limit Timer Step */
 
-/*	TXA_STAT	 8 bit	Tx Arbiter Status Register */
+/*	TXA_STAT		 8 bit	Tx Arbiter Status Register */
 								/* Bit 7.. 1:	reserved */
 #define TXA_PRIO_XS		BIT_0S	/* sync queue has prio to send */
 
-/*	Q_BC	32 bit	Current Byte Counter */
+/*	Q_BC			32 bit	Current Byte Counter */
 								/* Bit 31..16:	reserved */
 #define BC_MAX			0xffff	/* Bit 15.. 0:	Byte counter */
 
 /* BMU Control Status Registers */
-/*	B0_R1_CSR	32 bit	BMU Ctrl/Stat Rx Queue 1 */
-/*	B0_R2_CSR	32 bit	BMU Ctrl/Stat Rx Queue 2 */
-/*	B0_XA1_CSR	32 bit	BMU Ctrl/Stat Sync Tx Queue 1 */
-/*	B0_XS1_CSR	32 bit	BMU Ctrl/Stat Async Tx Queue 1 */
-/*	B0_XA2_CSR	32 bit	BMU Ctrl/Stat Sync Tx Queue 2 */
-/*	B0_XS2_CSR	32 bit	BMU Ctrl/Stat Async Tx Queue 2 */
-/*	Q_CSR		32 bit	BMU Control/Status Register */
+/*	B0_R1_CSR		32 bit	BMU Ctrl/Stat Rx Queue 1 */
+/*	B0_R2_CSR		32 bit	BMU Ctrl/Stat Rx Queue 2 */
+/*	B0_XA1_CSR		32 bit	BMU Ctrl/Stat Sync Tx Queue 1 */
+/*	B0_XS1_CSR		32 bit	BMU Ctrl/Stat Async Tx Queue 1 */
+/*	B0_XA2_CSR		32 bit	BMU Ctrl/Stat Sync Tx Queue 2 */
+/*	B0_XS2_CSR		32 bit	BMU Ctrl/Stat Async Tx Queue 2 */
+/*	Q_CSR			32 bit	BMU Control/Status Register */
 								/* Bit 31..25:	reserved */
 #define CSR_SV_IDLE		BIT_24		/* BMU SM Idle */
 								/* Bit 23..22:	reserved */
@@ -1428,7 +1442,7 @@ extern "C" {
 						CSR_SV_RUN | CSR_DREAD_RUN | CSR_DWRITE_RUN |\
 						CSR_TRANS_RUN)
 
-/*	Q_F	32 bit	Flag Register */
+/*	Q_F				32 bit	Flag Register */
 									/* Bit 31..28:	reserved */
 #define F_ALM_FULL		BIT_27		/* Rx FIFO: almost full */
 #define F_EMPTY			BIT_27		/* Tx FIFO: empty flag */
@@ -1439,17 +1453,17 @@ extern "C" {
 									/* Bit 15..11: 	reserved */
 #define F_WATER_MARK	0x0007ffL	/* Bit 10.. 0:	Watermark */
 
-/*	Q_T1	32 bit	Test Register 1 */
+/*	Q_T1			32 bit	Test Register 1 */
 /*		Holds four State Machine control Bytes */
-#define SM_CRTL_SV_MSK	(0xffL<<24)	/* Bit 31..24:	Control Supervisor SM */
-#define SM_CRTL_RD_MSK	(0xffL<<16)	/* Bit 23..16:	Control Read Desc SM */
-#define SM_CRTL_WR_MSK	(0xffL<<8)	/* Bit 15.. 8:	Control Write Desc SM */
-#define SM_CRTL_TR_MSK	0xffL		/* Bit	7.. 0:	Control Transfer SM */
-
-/*	Q_T1_TR	 8 bit	Test Register 1 Transfer SM */
-/*	Q_T1_WR	 8 bit	Test Register 1 Write Descriptor SM */
-/*	Q_T1_RD	 8 bit	Test Register 1 Read Descriptor SM */
-/*	Q_T1_SV	 8 bit	Test Register 1 Supervisor SM */
+#define SM_CTRL_SV_MSK	(0xffL<<24)	/* Bit 31..24:	Control Supervisor SM */
+#define SM_CTRL_RD_MSK	(0xffL<<16)	/* Bit 23..16:	Control Read Desc SM */
+#define SM_CTRL_WR_MSK	(0xffL<<8)	/* Bit 15.. 8:	Control Write Desc SM */
+#define SM_CTRL_TR_MSK	0xffL		/* Bit	7.. 0:	Control Transfer SM */
+
+/*	Q_T1_TR			 8 bit	Test Register 1 Transfer SM */
+/*	Q_T1_WR			 8 bit	Test Register 1 Write Descriptor SM */
+/*	Q_T1_RD			 8 bit	Test Register 1 Read Descriptor SM */
+/*	Q_T1_SV			 8 bit	Test Register 1 Supervisor SM */
 
 /* The control status byte of each machine looks like ... */
 #define SM_STATE		0xf0	/* Bit 7.. 4:	State which shall be loaded */
@@ -1459,7 +1473,7 @@ extern "C" {
 #define SM_STEP			BIT_0S	/* Step the State Machine */
 /* The encoding of the states is not supported by the Diagnostics Tool */
 
-/*	Q_T2	32 bit	Test Register 2	*/
+/*	Q_T2			32 bit	Test Register 2	*/
 								/* Bit 31.. 8:	reserved */
 #define T2_AC_T_ON		BIT_7	/* Address Counter Test Mode on */
 #define T2_AC_T_OFF		BIT_6	/* Address Counter Test Mode off */
@@ -1470,23 +1484,23 @@ extern "C" {
 #define T2_STEP02		BIT_1	/* Inc AC/Dec BC by 2 */
 #define T2_STEP01		BIT_0	/* Inc AC/Dec BC by 1 */
 
-/*	Q_T3	32 bit	Test Register 3	*/
+/*	Q_T3			32 bit	Test Register 3	*/
 								/* Bit 31.. 7:	reserved */
 #define T3_MUX_MSK		(7<<4)	/* Bit  6.. 4:	Mux Position */
 								/* Bit  3:	reserved */
 #define T3_VRAM_MSK		7		/* Bit  2.. 0:	Virtual RAM Buffer Address */
 
 /* RAM Buffer Register Offsets, use RB_ADDR(Queue, Offs) to access */
-/*	RB_START	32 bit	RAM Buffer Start Address */
-/*	RB_END		32 bit	RAM Buffer End Address */
-/*	RB_WP		32 bit	RAM Buffer Write Pointer */
-/*	RB_RP		32 bit	RAM Buffer Read Pointer */
-/*	RB_RX_UTPP	32 bit	Rx Upper Threshold, Pause Pack */
-/*	RB_RX_LTPP	32 bit	Rx Lower Threshold, Pause Pack */
-/*	RB_RX_UTHP	32 bit	Rx Upper Threshold, High Prio */
-/*	RB_RX_LTHP	32 bit	Rx Lower Threshold, High Prio */
-/*	RB_PC		32 bit	RAM Buffer Packet Counter */
-/*	RB_LEV		32 bit	RAM Buffer Level Register */
+/*	RB_START		32 bit	RAM Buffer Start Address */
+/*	RB_END			32 bit	RAM Buffer End Address */
+/*	RB_WP			32 bit	RAM Buffer Write Pointer */
+/*	RB_RP			32 bit	RAM Buffer Read Pointer */
+/*	RB_RX_UTPP		32 bit	Rx Upper Threshold, Pause Pack */
+/*	RB_RX_LTPP		32 bit	Rx Lower Threshold, Pause Pack */
+/*	RB_RX_UTHP		32 bit	Rx Upper Threshold, High Prio */
+/*	RB_RX_LTHP		32 bit	Rx Lower Threshold, High Prio */
+/*	RB_PC			32 bit	RAM Buffer Packet Counter */
+/*	RB_LEV			32 bit	RAM Buffer Level Register */
 				/* Bit 31..19:	reserved */
 #define RB_MSK	0x0007ffff	/* Bit 18.. 0:	RAM Buffer Pointer Bits */
 
@@ -1519,17 +1533,17 @@ extern "C" {
 
 /* Receive and Transmit MAC FIFO Registers (GENESIS only) */
 
-/*	RX_MFF_EA	32 bit	Receive MAC FIFO End Address */
-/*	RX_MFF_WP	32 bit 	Receive MAC FIFO Write Pointer */
-/*	RX_MFF_RP	32 bit	Receive MAC FIFO Read Pointer */
-/*	RX_MFF_PC	32 bit	Receive MAC FIFO Packet Counter */
-/*	RX_MFF_LEV	32 bit	Receive MAC FIFO Level */
-/*	TX_MFF_EA	32 bit	Transmit MAC FIFO End Address */
-/*	TX_MFF_WP	32 bit 	Transmit MAC FIFO Write Pointer */
-/*	TX_MFF_WSP	32 bit	Transmit MAC FIFO WR Shadow Pointer */
-/*	TX_MFF_RP	32 bit	Transmit MAC FIFO Read Pointer */
-/*	TX_MFF_PC	32 bit	Transmit MAC FIFO Packet Cnt */
-/*	TX_MFF_LEV	32 bit	Transmit MAC FIFO Level */
+/*	RX_MFF_EA		32 bit	Receive MAC FIFO End Address */
+/*	RX_MFF_WP		32 bit 	Receive MAC FIFO Write Pointer */
+/*	RX_MFF_RP		32 bit	Receive MAC FIFO Read Pointer */
+/*	RX_MFF_PC		32 bit	Receive MAC FIFO Packet Counter */
+/*	RX_MFF_LEV		32 bit	Receive MAC FIFO Level */
+/*	TX_MFF_EA		32 bit	Transmit MAC FIFO End Address */
+/*	TX_MFF_WP		32 bit 	Transmit MAC FIFO Write Pointer */
+/*	TX_MFF_WSP		32 bit	Transmit MAC FIFO WR Shadow Pointer */
+/*	TX_MFF_RP		32 bit	Transmit MAC FIFO Read Pointer */
+/*	TX_MFF_PC		32 bit	Transmit MAC FIFO Packet Cnt */
+/*	TX_MFF_LEV		32 bit	Transmit MAC FIFO Level */
 								/* Bit 31.. 6:	reserved */
 #define MFF_MSK			0x007fL	/* Bit	5.. 0:	MAC FIFO Address/Ptr Bits */
 
@@ -1682,7 +1696,7 @@ extern "C" {
 
 #define RX_GMF_FL_THR_DEF	0x0a	/* Rx GMAC FIFO Flush Threshold default */
 
-/*	GMAC_TI_ST_CTRL		  8 bit	Time Stamp Timer Ctrl Reg (YUKON only) */
+/*	GMAC_TI_ST_CTRL	 8 bit	Time Stamp Timer Ctrl Reg (YUKON only) */
 								/* Bit 7.. 3:	reserved */
 #define GMT_ST_START	BIT_2S		/* Start Time Stamp Timer */
 #define GMT_ST_STOP		BIT_1S		/* Stop  Time Stamp Timer */
@@ -1766,13 +1780,13 @@ extern "C" {
 #define GMAC_DEF_MSK	(GM_IS_TX_CO_OV | GM_IS_RX_CO_OV | \
 						GM_IS_TX_FF_UR)
 
-/*	GMAC_LINK_CTRL		16 bit	GMAC Link Control Reg (YUKON only) */
+/*	GMAC_LINK_CTRL	16 bit	GMAC Link Control Reg (YUKON only) */
 						/* Bits 15.. 2:	reserved */
 #define GMLC_RST_CLR	BIT_1S		/* Clear GMAC Link Reset */
 #define GMLC_RST_SET	BIT_0S		/* Set   GMAC Link Reset */
 
 
-/*	WOL_CTRL_STAT		16 bit	WOL Control/Status Reg */
+/*	WOL_CTRL_STAT	16 bit	WOL Control/Status Reg */
 #define WOL_CTL_LINK_CHG_OCC			BIT_15S
 #define WOL_CTL_MAGIC_PKT_OCC			BIT_14S
 #define WOL_CTL_PATTERN_OCC				BIT_13S
@@ -1801,7 +1815,7 @@ extern "C" {
 	WOL_CTL_DIS_PATTERN_UNIT |		\
 	WOL_CTL_DIS_MAGIC_PKT_UNIT)
 
-/*	WOL_MATCH_CTL		 8 bit	WOL Match Control Reg */
+/*	WOL_MATCH_CTL	 8 bit	WOL Match Control Reg */
 #define WOL_CTL_PATT_ENA(x)				(BIT_0 << (x))
 
 #define SK_NUM_WOL_PATTERN		7
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skgehwt.h linux-2.5/drivers/net/sk98lin/h/skgehwt.h
--- linux-2.6.1/drivers/net/sk98lin/h/skgehwt.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skgehwt.h	2004-01-10 16:16:06.000000000 +0000
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	skhwt.h
- * Project:	Gigabit Ethernet Adapters, Schedule-Modul
- * Version:	$Revision: 1.6 $
- * Date:	$Date: 2003/05/13 17:57:48 $
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.7 $
+ * Date:	$Date: 2003/09/16 12:55:08 $
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.h,v $
+ *	Revision 1.7  2003/09/16 12:55:08  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.6  2003/05/13 17:57:48  mkarl
  *	Editorial changes.
  *	
@@ -34,7 +37,7 @@
  *	Changed license header to GPL.
  *	
  *	Revision 1.4  1998/08/19 09:50:58  gklug
- *	fix: remove struct keyword from c-code (see CCC) add typedefs
+ *	fix: remove struct keyword from C-code (see CCC) add typedefs
  *	
  *	Revision 1.3  1998/08/14 07:09:29  gklug
  *	fix: chg pAc -> pAC
@@ -44,10 +47,6 @@
  *	
  *	Revision 1.1  1998/08/07 09:32:58  gklug
  *	first version
- *	
- *	
- *	
- *	
  *
  ******************************************************************************/
 
@@ -64,14 +63,14 @@
  * - use in Adapters context name pAC->Hwt
  */
 typedef	struct s_Hwt {
-	SK_U32		TStart ;	/* HWT start */
-	SK_U32		TStop ;		/* HWT stop */
-	int		TActive ;	/* HWT: flag : active/inactive */
+	SK_U32		TStart;	/* HWT start */
+	SK_U32		TStop;	/* HWT stop */
+	int		TActive;	/* HWT: flag : active/inactive */
 } SK_HWT;
 
 extern void SkHwtInit(SK_AC *pAC, SK_IOC Ioc);
 extern void SkHwtStart(SK_AC *pAC, SK_IOC Ioc, SK_U32 Time);
 extern void SkHwtStop(SK_AC *pAC, SK_IOC Ioc);
-extern SK_U32 SkHwtRead(SK_AC *pAC,SK_IOC Ioc);
+extern SK_U32 SkHwtRead(SK_AC *pAC, SK_IOC Ioc);
 extern void SkHwtIsr(SK_AC *pAC, SK_IOC Ioc);
 #endif	/* _SKGEHWT_H_ */
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skgei2c.h linux-2.5/drivers/net/sk98lin/h/skgei2c.h
--- linux-2.6.1/drivers/net/sk98lin/h/skgei2c.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skgei2c.h	2004-01-10 16:16:06.000000000 +0000
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	skgei2c.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.23 $
- * Date:	$Date: 2002/12/19 14:34:27 $
- * Purpose:	Special GEnesis defines for TWSI
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.25 $
+ * Date:	$Date: 2003/10/20 09:06:05 $
+ * Purpose:	Special defines for TWSI
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,12 @@
  * History:
  *
  *	$Log: skgei2c.h,v $
+ *	Revision 1.25  2003/10/20 09:06:05  rschmidt
+ *	Editorial changes.
+ *	
+ *	Revision 1.24  2003/09/23 09:31:15  malthoff
+ *	Parameter dev_size added to macro definition of SK_I2C_CTL.
+ *	
  *	Revision 1.23  2002/12/19 14:34:27  rschmidt
  *	Added cast in macros SK_I2C_SET_BIT() and SK_I2C_CLR_BIT()
  *	Editorial changes (TWSI)
@@ -107,8 +114,6 @@
  *	Revision 1.1  1998/07/17 11:27:56  gklug
  *	Created.
  *
- *
- *
  ******************************************************************************/
 
 /*
@@ -121,12 +126,13 @@
 /*
  * Macros to access the B2_I2C_CTRL
  */
-#define SK_I2C_CTL(IoC, flag, dev, reg, burst) \
+#define SK_I2C_CTL(IoC, flag, dev, dev_size, reg, burst) \
 	SK_OUT32(IoC, B2_I2C_CTRL,\
 		(flag ? 0x80000000UL : 0x0L) | \
-		(((SK_U32) reg << 16) & I2C_ADDR) | \
-		(((SK_U32) dev << 9) & I2C_DEV_SEL) | \
-		(( burst << 4) & I2C_BURST_LEN))
+		(((SK_U32)reg << 16) & I2C_ADDR) | \
+		(((SK_U32)dev << 9) & I2C_DEV_SEL) | \
+		(dev_size & I2C_DEV_SIZE) | \
+		((burst << 4) & I2C_BURST_LEN))
 
 #define SK_I2C_STOP(IoC) {				\
 	SK_U32	I2cCtrl;				\
@@ -166,42 +172,42 @@
  */
 #define	SK_LM80_VT_LSB		22	/* 22mV LSB resolution */
 #define	SK_LM80_TEMP_LSB	10	/* 1 degree LSB resolution */
-#define	SK_LM80_TEMPEXT_LSB	5	/* 0.5 degree LSB resolution for the
-					 * extension value
-					 */
-#define SK_LM80_FAN_FAKTOR	((22500L*60)/(1*2))
-/* formula: counter = (22500*60)/(rpm * divisor * pulses/2)
+#define	SK_LM80_TEMPEXT_LSB	 5	/* 0.5 degree LSB resolution for ext. val. */
+
+/*
+ * formula: counter = (22500*60)/(rpm * divisor * pulses/2)
  * assuming: 6500rpm, 4 pulses, divisor 1
  */
+#define SK_LM80_FAN_FAKTOR	((22500L*60)/(1*2))
 
 /*
  * Define sensor management data
- * Maximum is reached on copperfield with dual Broadcom.
+ * Maximum is reached on Genesis copper dual port and Yukon-64
  * Board specific maximum is in pAC->I2c.MaxSens
  */
 #define	SK_MAX_SENSORS	8	/* maximal no. of installed sensors */
 #define	SK_MIN_SENSORS	5	/* minimal no. of installed sensors */
 
 /*
- * To watch the statemachine (JS) use the timer in two ways instead of one as hitherto
+ * To watch the state machine (SM) use the timer in two ways
+ * instead of one as hitherto
  */
-#define	SK_TIMER_WATCH_STATEMACHINE	0	/* Watch the statemachine to finish in a specific time */
-#define	SK_TIMER_NEW_GAUGING    	1	/* Start a new gauging when timer expires */
-
+#define	SK_TIMER_WATCH_SM		0	/* Watch the SM to finish in a spec. time */
+#define	SK_TIMER_NEW_GAUGING	1	/* Start a new gauging when timer expires */
 
 /*
- * Defines for the individual Thresholds
+ * Defines for the individual thresholds
  */
 
 /* Temperature sensor */
-#define	SK_SEN_TEMP_HIGH_ERR    800	/* Temperature High Err  Threshold */
+#define	SK_SEN_TEMP_HIGH_ERR	800	/* Temperature High Err  Threshold */
 #define	SK_SEN_TEMP_HIGH_WARN	700	/* Temperature High Warn Threshold */
 #define	SK_SEN_TEMP_LOW_WARN	100	/* Temperature Low  Warn Threshold */
-#define	SK_SEN_TEMP_LOW_ERR       0	/* Temperature Low  Err  Threshold */
+#define	SK_SEN_TEMP_LOW_ERR		  0	/* Temperature Low  Err  Threshold */
 
 /* VCC which should be 5 V */
-#define	SK_SEN_PCI_5V_HIGH_ERR  	5588	/* Voltage PCI High Err  Threshold */
-#define	SK_SEN_PCI_5V_HIGH_WARN     5346	/* Voltage PCI High Warn Threshold */
+#define	SK_SEN_PCI_5V_HIGH_ERR		5588	/* Voltage PCI High Err  Threshold */
+#define	SK_SEN_PCI_5V_HIGH_WARN		5346	/* Voltage PCI High Warn Threshold */
 #define	SK_SEN_PCI_5V_LOW_WARN		4664	/* Voltage PCI Low  Warn Threshold */
 #define	SK_SEN_PCI_5V_LOW_ERR		4422	/* Voltage PCI Low  Err  Threshold */
 
@@ -229,17 +235,16 @@
 #define	SK_SEN_PCI_IO_3V3_HIGH_ERR	3850	/* + 15% V PCI-IO High Err Threshold */
 #define	SK_SEN_PCI_IO_3V3_HIGH_WARN	3674	/* + 10% V PCI-IO High Warn Threshold */
 					/*		3300	mVolt */
-#define	SK_SEN_PCI_IO_3V3_LOW_WARN  2926	/* - 10% V PCI-IO Low Warn Threshold */
-#define	SK_SEN_PCI_IO_3V3_LOW_ERR   2772	/* - 15% V PCI-IO Low Err  Threshold */
-
+#define	SK_SEN_PCI_IO_3V3_LOW_WARN	2926	/* - 10% V PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_3V3_LOW_ERR	2772	/* - 15% V PCI-IO Low Err  Threshold */
 
 /*
  * VDD voltage
  */
-#define	SK_SEN_VDD_HIGH_ERR	    3630	/* Voltage ASIC High Err  Threshold */
-#define	SK_SEN_VDD_HIGH_WARN    3476	/* Voltage ASIC High Warn Threshold */
-#define	SK_SEN_VDD_LOW_WARN     3146	/* Voltage ASIC Low  Warn Threshold */
-#define	SK_SEN_VDD_LOW_ERR      2970	/* Voltage ASIC Low  Err  Threshold */
+#define	SK_SEN_VDD_HIGH_ERR		3630	/* Voltage ASIC High Err  Threshold */
+#define	SK_SEN_VDD_HIGH_WARN	3476	/* Voltage ASIC High Warn Threshold */
+#define	SK_SEN_VDD_LOW_WARN		3146	/* Voltage ASIC Low  Warn Threshold */
+#define	SK_SEN_VDD_LOW_ERR		2970	/* Voltage ASIC Low  Err  Threshold */
 
 /*
  * PHY PLL 3V3 voltage
@@ -255,8 +260,8 @@
 #define	SK_SEN_VAUX_3V3_HIGH_ERR	3630	/* Voltage VAUX High Err Threshold */
 #define	SK_SEN_VAUX_3V3_HIGH_WARN	3476	/* Voltage VAUX High Warn Threshold */
 #define	SK_SEN_VAUX_3V3_LOW_WARN	3146	/* Voltage VAUX Low Warn Threshold */
-#define	SK_SEN_VAUX_3V3_LOW_ERR	    2970	/* Voltage VAUX Low Err Threshold */
-#define	SK_SEN_VAUX_0V_WARN_ERR	       0	/* if VAUX not present */
+#define	SK_SEN_VAUX_3V3_LOW_ERR		2970	/* Voltage VAUX Low Err Threshold */
+#define	SK_SEN_VAUX_0V_WARN_ERR		   0	/* if VAUX not present */
 #define	SK_SEN_VAUX_RANGE_LIMITER	1000	/* 1000 mV range delimiter */
 
 /*
@@ -270,7 +275,7 @@
 /*
  * ASIC Core 1V5 voltage (YUKON only)
  */
-#define	SK_SEN_CORE_1V5_HIGH_ERR    1650	/* Voltage ASIC Core High Err Threshold */
+#define	SK_SEN_CORE_1V5_HIGH_ERR	1650	/* Voltage ASIC Core High Err Threshold */
 #define	SK_SEN_CORE_1V5_HIGH_WARN	1575	/* Voltage ASIC Core High Warn Threshold */
 #define	SK_SEN_CORE_1V5_LOW_WARN	1425	/* Voltage ASIC Core Low Warn Threshold */
 #define	SK_SEN_CORE_1V5_LOW_ERR 	1350	/* Voltage ASIC Core Low Err Threshold */
@@ -285,8 +290,8 @@
  */
 #define	SK_SEN_FAN_HIGH_ERR		20000	/* FAN Speed High Err Threshold */
 #define	SK_SEN_FAN_HIGH_WARN	20000	/* FAN Speed High Warn Threshold */
-#define	SK_SEN_FAN_LOW_WARN 	5200	/* FAN Speed Low Warn Threshold */
-#define	SK_SEN_FAN_LOW_ERR		4550	/* FAN Speed Low Err Threshold */
+#define	SK_SEN_FAN_LOW_WARN		 5200	/* FAN Speed Low Warn Threshold */
+#define	SK_SEN_FAN_LOW_ERR		 4550	/* FAN Speed Low Err Threshold */
 
 /*
  * Some Voltages need dynamic thresholds
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skgeinit.h linux-2.5/drivers/net/sk98lin/h/skgeinit.h
--- linux-2.6.1/drivers/net/sk98lin/h/skgeinit.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skgeinit.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.81 $
- * Date:	$Date: 2003/07/04 12:30:38 $
+ * Version:	$Revision: 1.83 $
+ * Date:	$Date: 2003/09/16 14:07:37 $
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
@@ -27,6 +27,23 @@
  * History:
  *
  *	$Log: skgeinit.h,v $
+ *	Revision 1.83  2003/09/16 14:07:37  rschmidt
+ *	Moved defines for PHY power down modes from skgehw.h
+ *	Added prototypes for SkMacClearRst()
+ *	Editorial changes
+ *	
+ *	Revision 1.82  2003/09/16 07:18:36  mschmid
+ *	Added members to port structure for MAC control
+ *	- PMacColThres
+ *	- PMacJamLen
+ *	- PMacJamIpgVal
+ *	- PMacJamIpgData
+ *	- PMacIpgData
+ *	- PMacLimit4
+ *	Added PHY power state to port structure
+ *	- PPhyPowerState
+ *	Added function prototypes to enter and leave low power modes
+ *	
  *	Revision 1.81  2003/07/04 12:30:38  rschmidt
  *	Added SK_FAR to pointers in MAC statistic functions (for PXE)
  *	Editorial changes
@@ -594,6 +611,13 @@ extern "C" {
 #define SK_PRT_INIT		2	/* the port is initialized */
 #define SK_PRT_RUN		3	/* the port has an active link */
 
+/* PHY power down modes */
+#define PHY_PM_OPERATIONAL_MODE		0	/* PHY operational mode */
+#define PHY_PM_DEEP_SLEEP			1	/* coma mode --> minimal power */
+#define PHY_PM_IEEE_POWER_DOWN		2	/* IEEE 22.2.4.1.5 compl. power down */
+#define PHY_PM_ENERGY_DETECT		3	/* energy detect */
+#define PHY_PM_ENERGY_DETECT_PLUS	4	/* energy detect plus */
+
 /* Default receive frame limit for Workaround of XMAC Errata */
 #define SK_DEF_RX_WA_LIM	SK_CONSTU64(100)
 
@@ -685,6 +709,13 @@ typedef	struct s_GePort {
 	SK_U8	PCableLen;		/* Cable Length */
 	SK_U8	PMdiPairLen[4];	/* MDI[0..3] Pair Length */
 	SK_U8	PMdiPairSts[4];	/* MDI[0..3] Pair Diagnostic Status */
+	SK_U8	PPhyPowerState;	/* PHY current power state */
+	int		PMacColThres;	/* MAC Collision Threshold */
+	int		PMacJamLen;		/* MAC Jam length */
+	int		PMacJamIpgVal;	/* MAC Jam IPG */
+	int		PMacJamIpgData;	/* MAC IPG Jam to Data */
+	int		PMacIpgData;	/* MAC Data IPG */
+	SK_BOOL PMacLimit4;		/* reset collision counter and backoff algorithm */
 } SK_GEPORT;
 
 /*
@@ -865,6 +896,11 @@ extern void	SkMacHardRst(
 	SK_IOC	IoC,
 	int		Port);
 
+extern void	SkMacClearRst(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
 extern void	SkXmInitMac(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
@@ -1040,6 +1076,17 @@ extern int SkGmCableDiagStatus(
 	int		Port,
 	SK_BOOL	StartTest);
 
+extern int SkGmEnterLowPowerMode(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_U8	Mode);
+
+extern int SkGmLeaveLowPowerMode(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
 #ifdef SK_DIAG
 extern void	SkGePhyRead(
 	SK_AC	*pAC,
@@ -1101,6 +1148,7 @@ extern int	SkGeInitAssignRamToQueues();
 extern void SkMacRxTxDisable();
 extern void	SkMacSoftRst();
 extern void	SkMacHardRst();
+extern void	SkMacClearRst();
 extern void SkMacInitPhy();
 extern int  SkMacRxTxEnable();
 extern void SkMacPromiscMode();
@@ -1131,6 +1179,8 @@ extern int	SkGmResetCounter();
 extern int	SkXmOverflowStatus();
 extern int	SkGmOverflowStatus();
 extern int	SkGmCableDiagStatus();
+extern int	SkGmEnterLowPowerMode();
+extern int	SkGmLeaveLowPowerMode();
 
 #ifdef SK_DIAG
 extern void	SkGePhyRead();
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skgepnmi.h linux-2.5/drivers/net/sk98lin/h/skgepnmi.h
--- linux-2.6.1/drivers/net/sk98lin/h/skgepnmi.h	2004-01-09 06:59:08.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skgepnmi.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.61 $
- * Date:	$Date: 2003/05/23 12:53:52 $
+ * Version:	$Revision: 1.62 $
+ * Date:	$Date: 2003/08/15 12:31:52 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
@@ -27,6 +27,18 @@
  * History:
  *
  *	$Log: skgepnmi.h,v $
+ *	Revision 1.62  2003/08/15 12:31:52  tschilli
+ *	Added new OIDs:
+ *	OID_SKGE_DRIVER_RELDATE
+ *	OID_SKGE_DRIVER_FILENAME
+ *	OID_SKGE_CHIPID
+ *	OID_SKGE_RAMSIZE
+ *	OID_SKGE_VAUXAVAIL
+ *	OID_SKGE_PHY_TYPE
+ *	OID_SKGE_PHY_LP_MODE
+ *	
+ *	Added new define SK_DIAG_ATTACHED for OID_SKGE_DIAG_MODE handling.
+ *	
  *	Revision 1.61  2003/05/23 12:53:52  tschilli
  *	Generic PNMI IOCTL subcommands added.
  *	Function prototype SkPnmiGenIoctl() added.
@@ -568,15 +580,23 @@
 #define OID_SKGE_ALL_DATA				0xFF020190
 
 /* Defines for VCT. */
-#define OID_SKGE_VCT_GET			0xFF020200
-#define OID_SKGE_VCT_SET			0xFF020201
-#define OID_SKGE_VCT_STATUS			0xFF020202
+#define OID_SKGE_VCT_GET				0xFF020200
+#define OID_SKGE_VCT_SET				0xFF020201
+#define OID_SKGE_VCT_STATUS				0xFF020202
 
 #ifdef SK_DIAG_SUPPORT
 /* Defines for driver DIAG mode. */
-#define OID_SKGE_DIAG_MODE			0xFF020204
+#define OID_SKGE_DIAG_MODE				0xFF020204
 #endif /* SK_DIAG_SUPPORT */
 
+/* New OIDs */
+#define OID_SKGE_DRIVER_RELDATE			0xFF020210
+#define OID_SKGE_DRIVER_FILENAME		0xFF020211
+#define OID_SKGE_CHIPID					0xFF020212
+#define OID_SKGE_RAMSIZE				0xFF020213
+#define OID_SKGE_VAUXAVAIL				0xFF020214
+#define OID_SKGE_PHY_TYPE				0xFF020215
+#define OID_SKGE_PHY_LP_MODE			0xFF020216
 
 /* VCT struct to store a backup copy of VCT data after a port reset. */
 typedef struct s_PnmiVct {
@@ -613,6 +633,12 @@ typedef struct s_PnmiVct {
 #define OID_SKGE_TRAP_RLMT_PORT_UP		523
 #define OID_SKGE_TRAP_RLMT_SEGMENTATION	524
 
+#ifdef SK_DIAG_SUPPORT
+/* Defines for driver DIAG mode. */
+#define SK_DIAG_ATTACHED	2
+#define SK_DIAG_RUNNING		1
+#define SK_DIAG_IDLE		0
+#endif /* SK_DIAG_SUPPORT */
 
 /*
  * Generic PNMI IOCTL subcommand definitions.
@@ -730,6 +756,14 @@ typedef struct s_PnmiVct {
 #define SK_PNMI_ERR051MSG	"SkPnmiEvent: Port switch suspicious"
 #define SK_PNMI_ERR052		(SK_ERRBASE_PNMI + 52)
 #define SK_PNMI_ERR052MSG	""
+#define SK_PNMI_ERR053		(SK_ERRBASE_PNMI + 53)
+#define SK_PNMI_ERR053MSG	"General: Driver release date not initialized"
+#define SK_PNMI_ERR054		(SK_ERRBASE_PNMI + 54)
+#define SK_PNMI_ERR054MSG	"General: Driver release date string too long"
+#define SK_PNMI_ERR055		(SK_ERRBASE_PNMI + 55)
+#define SK_PNMI_ERR055MSG	"General: Driver file name not initialized"
+#define SK_PNMI_ERR056		(SK_ERRBASE_PNMI + 56)
+#define SK_PNMI_ERR056MSG	"General: Driver file name string too long"
 
 /*
  * Management counter macros called by the driver
@@ -740,6 +774,11 @@ typedef struct s_PnmiVct {
 #define SK_PNMI_SET_DRIVER_VER(pAC,v)	((pAC)->Pnmi.pDriverVersion = \
 	(char *)(v))
 
+#define SK_PNMI_SET_DRIVER_RELDATE(pAC,v)	((pAC)->Pnmi.pDriverReleaseDate = \
+	(char *)(v))
+
+#define SK_PNMI_SET_DRIVER_FILENAME(pAC,v)	((pAC)->Pnmi.pDriverFileName = \
+	(char *)(v))
 
 #define SK_PNMI_CNT_TX_QUEUE_LEN(pAC,v,p) \
 	{ \
@@ -916,6 +955,8 @@ typedef struct s_PnmiConf {
 	char			ConfMacFactoryAddr[6];
 	SK_U8			ConfPMD;
 	SK_U8			ConfConnector;
+	SK_U32			ConfPhyType;
+	SK_U32			ConfPhyMode;
 	SK_U8			ConfLinkCapability;
 	SK_U8			ConfLinkMode;
 	SK_U8			ConfLinkModeStatus;
@@ -964,9 +1005,14 @@ typedef struct s_PnmiStrucData {
 	SK_U32			DeviceType;
 	char			DriverDescr[SK_PNMI_STRINGLEN1];
 	char			DriverVersion[SK_PNMI_STRINGLEN2];
+	char			DriverReleaseDate[SK_PNMI_STRINGLEN1];
+	char			DriverFileName[SK_PNMI_STRINGLEN1];
 	char			HwDescr[SK_PNMI_STRINGLEN1];
 	char			HwVersion[SK_PNMI_STRINGLEN2];
 	SK_U16			Chipset;
+	SK_U32			ChipId;
+	SK_U8			VauxAvail;
+	SK_U32			RamSize;
 	SK_U32			MtuSize;
 	SK_U32			Action;
 	SK_U32			TestResult;
@@ -1090,6 +1136,8 @@ typedef struct s_PnmiData {
 
 	char			*pDriverDescription;
 	char			*pDriverVersion;
+	char			*pDriverReleaseDate;
+	char			*pDriverFileName;
 
 	int				MacUpdatedFlag;
 	int				RlmtUpdatedFlag;
@@ -1119,6 +1167,9 @@ typedef struct s_PnmiData {
 	SK_U8		VctStatus[SK_MAX_MACS];
 	SK_PNMI_VCT	VctBackup[SK_MAX_MACS];
 	SK_PNMI_VCT_TIMER VctTimeout[SK_MAX_MACS];
+#ifdef SK_DIAG_SUPPORT
+	SK_U32			DiagAttached;
+#endif /* SK_DIAG_SUPPORT */
 } SK_PNMI;
 
 
diff -purN linux-2.6.1/drivers/net/sk98lin/h/ski2c.h linux-2.5/drivers/net/sk98lin/h/ski2c.h
--- linux-2.6.1/drivers/net/sk98lin/h/ski2c.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/ski2c.h	2004-01-10 16:16:06.000000000 +0000
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	ski2c.h
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.34 $
- * Date:	$Date: 2003/01/28 09:11:21 $
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.35 $
+ * Date:	$Date: 2003/10/20 09:06:30 $
  * Purpose:	Defines to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,10 @@
  * History:
  *
  *	$Log: ski2c.h,v $
+ *	Revision 1.35  2003/10/20 09:06:30  rschmidt
+ *	Added prototypes for SkI2cRead() and SkI2cWrite().
+ *	Editorial changes.
+ *	
  *	Revision 1.34  2003/01/28 09:11:21  rschmidt
  *	Editorial changes
  *	
@@ -137,7 +142,6 @@
  *	Revision 1.1  1998/06/19 14:30:10  malthoff
  *	Created. Sources taken from ML Project.
  *
- *
  ******************************************************************************/
 
 /*
@@ -252,7 +256,7 @@ struct	s_Sensor {
 	SK_I32	SenThreWarnLow;		/* Lower warning Threshold of the sensor */
 	int		SenErrFlag;			/* Sensor indicated an error */
 	SK_BOOL	SenInit;			/* Is sensor initialized ? */
-	SK_U64	SenErrCts;			/* Error  trap counter */
+	SK_U64	SenErrCts;			/* Error trap counter */
 	SK_U64	SenWarnCts;			/* Warning trap counter */
 	SK_U64	SenBegErrTS;		/* Begin error timestamp */
 	SK_U64	SenBegWarnTS;		/* Begin warning timestamp */
@@ -279,13 +283,17 @@ typedef	struct	s_I2c {
 #endif /* !SK_DIAG */
 } SK_I2C;
 
+extern int SkI2cInit(SK_AC *pAC, SK_IOC IoC, int Level);
+extern int SkI2cWrite(SK_AC *pAC, SK_IOC IoC, SK_U32 Data, int Dev, int Size,
+					   int Reg, int Burst);
 extern int SkI2cReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
-#ifndef SK_DIAG
+#ifdef SK_DIAG
+extern	SK_U32 SkI2cRead(SK_AC *pAC, SK_IOC IoC, int Dev, int Size, int Reg,
+						 int Burst);
+#else /* !SK_DIAG */
 extern int SkI2cEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
-extern int SkI2cInit(SK_AC *pAC, SK_IOC IoC, int Level);
 extern void SkI2cWaitIrq(SK_AC *pAC, SK_IOC IoC);
 extern void SkI2cIsr(SK_AC *pAC, SK_IOC IoC);
-
-#endif
+#endif /* !SK_DIAG */
 #endif /* n_SKI2C_H */
 
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skqueue.h linux-2.5/drivers/net/sk98lin/h/skqueue.h
--- linux-2.6.1/drivers/net/sk98lin/h/skqueue.h	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skqueue.h	2004-01-10 16:16:06.000000000 +0000
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	skqueue.h
- * Project:	Gigabit Ethernet Adapters, Schedule-Modul
- * Version:	$Revision: 1.15 $
- * Date:	$Date: 2003/05/13 17:54:57 $
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.16 $
+ * Date:	$Date: 2003/09/16 12:50:32 $
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: skqueue.h,v $
+ *	Revision 1.16  2003/09/16 12:50:32  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.15  2003/05/13 17:54:57  mkarl
  *	Editorial changes.
  *	
@@ -47,7 +50,7 @@
  *	add: typedef SK_QUEUE
  *	
  *	Revision 1.9  1998/08/19 09:50:59  gklug
- *	fix: remove struct keyword from c-code (see CCC) add typedefs
+ *	fix: remove struct keyword from C-code (see CCC) add typedefs
  *	
  *	Revision 1.8  1998/08/18 07:00:01  gklug
  *	fix: SK_PTR not defined use void * instead.
@@ -74,8 +77,6 @@
  *	Revision 1.1  1998/07/30 14:52:12  gklug
  *	Initial version.
  *	Defines Event Classes, Event structs and queue management variables.
- *	
- *	
  *
  ******************************************************************************/
 
@@ -92,7 +93,7 @@
  */
 #define	SKGE_DRV	1	/* Driver Event Class */
 #define	SKGE_RLMT	2	/* RLMT Event Class */
-#define	SKGE_I2C	3	/* i2C Event Class */
+#define	SKGE_I2C	3	/* I2C Event Class */
 #define	SKGE_PNMI	4	/* PNMI Event Class */
 #define	SKGE_CSUM	5	/* Checksum Event Class */
 #define	SKGE_HWAC	6	/* Hardware Access Event Class */
@@ -121,25 +122,25 @@ typedef	union u_EvPara {
  * Event Queue
  *	skqueue.c
  * events are class/value pairs
- *	class	is addressee, e.g. RMT, PCM etc.
+ *	class	is addressee, e.g. RLMT, PNMI etc.
  *	value	is command, e.g. line state change, ring op change etc.
  */
 typedef	struct s_EventElem {
-	SK_U32		Class ;			/* Event class */
-	SK_U32		Event ;			/* Event value */
-	SK_EVPARA	Para ;			/* Event parameter */
+	SK_U32		Class;			/* Event class */
+	SK_U32		Event;			/* Event value */
+	SK_EVPARA	Para;			/* Event parameter */
 } SK_EVENTELEM;
 
 typedef	struct s_Queue {
 	SK_EVENTELEM	EvQueue[SK_MAX_EVENT];
-	SK_EVENTELEM	*EvPut ;
-	SK_EVENTELEM	*EvGet ;
+	SK_EVENTELEM	*EvPut;
+	SK_EVENTELEM	*EvGet;
 } SK_QUEUE;
 
 extern	void SkEventInit(SK_AC *pAC, SK_IOC Ioc, int Level);
 extern	void SkEventQueue(SK_AC *pAC, SK_U32 Class, SK_U32 Event,
 	SK_EVPARA Para);
-extern	int SkEventDispatcher(SK_AC *pAC,SK_IOC Ioc);
+extern	int SkEventDispatcher(SK_AC *pAC, SK_IOC Ioc);
 
 
 /* Define Error Numbers and messages */
diff -purN linux-2.6.1/drivers/net/sk98lin/h/sktimer.h linux-2.5/drivers/net/sk98lin/h/sktimer.h
--- linux-2.6.1/drivers/net/sk98lin/h/sktimer.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/sktimer.h	2004-01-10 16:16:06.000000000 +0000
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	sktimer.h
- * Project:	Gigabit Ethernet Adapters, Schedule-Modul
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 2003/05/13 17:56:44 $
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/09/16 12:58:18 $
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
@@ -27,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.h,v $
+ *	Revision 1.11  2003/09/16 12:58:18  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.10  2003/05/13 17:56:44  mkarl
  *	Editorial changes.
  *	
@@ -40,7 +43,7 @@
  *	fix: SK_TIMCTRL needs to be defined
  *	
  *	Revision 1.6  1998/08/19 09:51:00  gklug
- *	fix: remove struct keyword from c-code (see CCC) add typedefs
+ *	fix: remove struct keyword from C-code (see CCC) add typedefs
  *	
  *	Revision 1.5  1998/08/17 13:43:21  gklug
  *	chg: Parameter will be union of 64bit para, 2 times SK_U32 or SK_PTR
@@ -78,25 +81,25 @@
 typedef	struct s_Timer SK_TIMER;
 
 struct s_Timer {
-	SK_TIMER	*TmNext ;	/* linked list */
-	SK_U32		TmClass ;	/* Timer Event class */
-	SK_U32		TmEvent ;	/* Timer Event value */
-	SK_EVPARA	TmPara ;	/* Timer Event parameter */
-	SK_U32		TmDelta ;	/* delta time */
-	int		TmActive ;	/* flag : active/inactive */
-} ;
+	SK_TIMER	*TmNext;	/* linked list */
+	SK_U32		TmClass;	/* Timer Event class */
+	SK_U32		TmEvent;	/* Timer Event value */
+	SK_EVPARA	TmPara;		/* Timer Event parameter */
+	SK_U32		TmDelta;	/* delta time */
+	int			TmActive;	/* flag: active/inactive */
+};
 
 /*
  * Timer control struct.
  * - use in Adapters context name pAC->Tim
  */
 typedef	struct s_TimCtrl {
-	SK_TIMER	*StQueue ;	/* Head of Timer queue */
-} SK_TIMCTRL ;
+	SK_TIMER	*StQueue;	/* Head of Timer queue */
+} SK_TIMCTRL;
 
-extern void SkTimerInit(SK_AC *pAC,SK_IOC Ioc, int Level);
-extern void SkTimerStop(SK_AC *pAC,SK_IOC Ioc,SK_TIMER *pTimer);
-extern void SkTimerStart(SK_AC *pAC,SK_IOC Ioc,SK_TIMER *pTimer,
-	SK_U32 Time,SK_U32 Class,SK_U32 Event,SK_EVPARA Para);
-extern void SkTimerDone(SK_AC *pAC,SK_IOC Ioc);
+extern void SkTimerInit(SK_AC *pAC, SK_IOC Ioc, int Level);
+extern void SkTimerStop(SK_AC *pAC, SK_IOC Ioc, SK_TIMER *pTimer);
+extern void SkTimerStart(SK_AC *pAC, SK_IOC Ioc, SK_TIMER *pTimer,
+	SK_U32 Time, SK_U32 Class, SK_U32 Event, SK_EVPARA Para);
+extern void SkTimerDone(SK_AC *pAC, SK_IOC Ioc);
 #endif	/* _SKTIMER_H_ */
diff -purN linux-2.6.1/drivers/net/sk98lin/h/sktypes.h linux-2.5/drivers/net/sk98lin/h/sktypes.h
--- linux-2.6.1/drivers/net/sk98lin/h/sktypes.h	2004-01-09 07:00:13.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/sktypes.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,15 +2,16 @@
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.1 $
- * Date:	$Date: 2003/07/21 07:26:01 $
+ * Version:	$Revision: 1.2 $
+ * Date:	$Date: 2003/10/07 08:16:51 $
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,9 @@
  * History:
  *
  *	$Log: sktypes.h,v $
+ *	Revision 1.2  2003/10/07 08:16:51  mlindner
+ *	Fix: Copyright changes
+ *	
  *	Revision 1.1  2003/07/21 07:26:01  rroesler
  *	Fix: Re-Enter after CVS crash
  *	
diff -purN linux-2.6.1/drivers/net/sk98lin/h/skversion.h linux-2.5/drivers/net/sk98lin/h/skversion.h
--- linux-2.6.1/drivers/net/sk98lin/h/skversion.h	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/skversion.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,15 +2,16 @@
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.3 $
- * Date:	$Date: 2003/08/25 13:34:48 $
+ * Version:	$Revision: 1.5 $
+ * Date:	$Date: 2003/10/07 08:16:51 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,6 +26,12 @@
  *
  * History:
  *	$Log: skversion.h,v $
+ *	Revision 1.5  2003/10/07 08:16:51  mlindner
+ *	Fix: Copyright changes
+ *	
+ *	Revision 1.4  2003/09/22 08:40:10  mlindner
+ *	Add: Added DRIVER_FILE_NAME and DRIVER_REL_DATE
+ *	
  *	Revision 1.3  2003/08/25 13:34:48  mlindner
  *	Fix: Lint changes
  *	
@@ -54,12 +61,14 @@
 #ifdef	lint
 static const char SysKonnectFileId[] = "@(#) (C) SysKonnect GmbH.";
 static const char SysKonnectBuildNumber[] =
-	"@(#)SK-BUILD: 6.18 PL: 01"; 
+	"@(#)SK-BUILD: 6.21 PL: 01"; 
 #endif	/* !defined(lint) */
 
-#define BOOT_STRING	"sk98lin: Network Device Driver v6.18\n" \
+#define BOOT_STRING	"sk98lin: Network Device Driver v6.21\n" \
 			"(C)Copyright 1999-2003 Marvell(R)."
 
-#define VER_STRING	"6.18"
+#define VER_STRING	"6.21"
+#define DRIVER_FILE_NAME	"sk98lin"
+#define DRIVER_REL_DATE		"Dec-15-2003"
 
 
diff -purN linux-2.6.1/drivers/net/sk98lin/h/xmac_ii.h linux-2.5/drivers/net/sk98lin/h/xmac_ii.h
--- linux-2.6.1/drivers/net/sk98lin/h/xmac_ii.h	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/h/xmac_ii.h	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	xmac_ii.h
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.48 $
- * Date:	$Date: 2003/05/13 17:17:55 $
+ * Version:	$Revision: 1.52 $
+ * Date:	$Date: 2003/10/02 16:35:50 $
  * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
@@ -27,6 +27,22 @@
  * History:
  *
  *	$Log: xmac_ii.h,v $
+ *	Revision 1.52  2003/10/02 16:35:50  rschmidt
+ *	Added defines for default values of GMAC parameters
+ *	Changed defines for setting GMAC parameters
+ *	Editorial changes
+ *	
+ *	Revision 1.51  2003/09/23 09:04:27  malthoff
+ *	Add bit definitions for PHY_MARV_EXT_P_STAT.
+ *	
+ *	Revision 1.50  2003/09/16 14:15:07  rschmidt
+ *	Added defines for Extended PHY Specific Control
+ *	Editorial changes
+ *	
+ *	Revision 1.49  2003/09/16 07:22:46  mschmid
+ *	Added defines for Marvell PHY energy detect modes
+ *	Added macros for MAC parameter setting in port structure
+ *	
  *	Revision 1.48  2003/05/13 17:17:55  mkarl
  *	Editorial changes.
  *	
@@ -676,7 +692,7 @@ extern "C" {
 #define PHY_XMAC_AUNE_LP	0x05	/* 16 bit r/o	Link Partner Abi Reg */
 #define PHY_XMAC_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_XMAC_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define PHY_XMAC_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
+#define PHY_XMAC_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* 0x09 - 0x0e:		reserved */
 #define PHY_XMAC_EXT_STAT	0x0f	/* 16 bit r/o	Ext Status Register */
 #define PHY_XMAC_RES_ABI	0x10	/* 16 bit r/o	PHY Resolved Ability */
@@ -693,7 +709,7 @@ extern "C" {
 #define PHY_BCOM_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
 #define PHY_BCOM_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_BCOM_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define PHY_BCOM_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
+#define PHY_BCOM_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Broadcom-specific registers */
 #define PHY_BCOM_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
 #define PHY_BCOM_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
@@ -702,7 +718,7 @@ extern "C" {
 #define PHY_BCOM_P_EXT_CTRL	0x10	/* 16 bit r/w	PHY Extended Ctrl Reg */
 #define PHY_BCOM_P_EXT_STAT	0x11	/* 16 bit r/o	PHY Extended Stat Reg */
 #define PHY_BCOM_RE_CTR		0x12	/* 16 bit r/w	Receive Error Counter */
-#define PHY_BCOM_FC_CTR		0x13	/* 16 bit r/w	False Carr Sense Cnt */
+#define PHY_BCOM_FC_CTR		0x13	/* 16 bit r/w	False Carrier Sense Cnt */
 #define PHY_BCOM_RNO_CTR	0x14	/* 16 bit r/w	Receiver NOT_OK Cnt */
 	/* 0x15 - 0x17:		reserved */
 #define PHY_BCOM_AUX_CTRL	0x18	/* 16 bit r/w	Auxiliary Control Reg */
@@ -724,7 +740,7 @@ extern "C" {
 #define PHY_MARV_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
 #define PHY_MARV_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_MARV_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define PHY_MARV_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
+#define PHY_MARV_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Marvel-specific registers */
 #define PHY_MARV_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
 #define PHY_MARV_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
@@ -757,7 +773,7 @@ extern "C" {
 #define PHY_LONE_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
 #define PHY_LONE_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
 #define PHY_LONE_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define PHY_LONE_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner*/
+#define PHY_LONE_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner */
 	/* Level One-specific registers */
 #define PHY_LONE_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg*/
 #define PHY_LONE_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
@@ -804,12 +820,13 @@ extern "C" {
 /*
  * PHY bit definitions
  * Bits defined as PHY_X_..., PHY_B_..., PHY_L_... or PHY_N_... are
- * Xmac/Broadcom/LevelOne/National-specific.
+ * XMAC/Broadcom/LevelOne/National/Marvell-specific.
  * All other are general.
  */
 
 /*****  PHY_XMAC_CTRL	16 bit r/w	PHY Control Register *****/
 /*****  PHY_BCOM_CTRL	16 bit r/w	PHY Control Register *****/
+/*****  PHY_MARV_CTRL	16 bit r/w	PHY Status Register *****/
 /*****  PHY_LONE_CTRL	16 bit r/w	PHY Control Register *****/
 #define PHY_CT_RESET	(1<<15)	/* Bit 15: (sc)	clear all PHY related regs */
 #define PHY_CT_LOOP		(1<<14)	/* Bit 14:	enable Loopback over PHY */
@@ -909,27 +926,20 @@ extern "C" {
 
 /*****  PHY_XMAC_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
 								/* Bit 15..4:	reserved */
-#define PHY_AN_LP_NP	(1<<3)	/* Bit  3:	Link Partner can Next Page */
-#define PHY_AN_LOC_NP	(1<<2)	/* Bit  2:	Local PHY can Next Page */
-#define PHY_AN_RX_PG	(1<<1)	/* Bit  1:	Page Received */
+#define PHY_ANE_LP_NP	(1<<3)	/* Bit  3:	Link Partner can Next Page */
+#define PHY_ANE_LOC_NP	(1<<2)	/* Bit  2:	Local PHY can Next Page */
+#define PHY_ANE_RX_PG	(1<<1)	/* Bit  1:	Page Received */
 								/* Bit  0:	reserved */
 
 /*****  PHY_BCOM_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
-								/* Bit 15..5:	reserved */
-#define PHY_B_AN_PDF	(1<<4)	/* Bit  4:	Parallel Detection Fault */
-/*	PHY_AN_LP_NP		(see XMAC) Bit  3:	Link Partner can Next Page */
-/*	PHY_AN_LOC_NP		(see XMAC) Bit  2:	Local PHY can Next Page */
-/*	PHY_AN_RX_PG		(see XMAC) Bit  1:	Page Received */
-#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit  0:	Link Partner Auto-Neg. Cap. */ 	
-
 /*****  PHY_LONE_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
-#define PHY_L_AN_BP		(1<<5)	/* Bit  5:	Base Page Indication */
-#define PHY_L_AN_PDF	(1<<4)	/* Bit  4:	Parallel Detection Fault */
-/*	PHY_AN_LP_NP		(see XMAC) Bit  3:	Link Partner can Next Page */
-/*	PHY_AN_LOC_NP		(see XMAC) Bit  2:	Local PHY can Next Page */
-/*	PHY_AN_RX_PG		(see XMAC) Bit  1:	Page Received */
-#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit  0:	Link Partner Auto-Neg. Cap. */ 	
-
+/*****  PHY_MARV_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
+								/* Bit 15..5:	reserved */
+#define PHY_ANE_PAR_DF	(1<<4)	/* Bit  4:	Parallel Detection Fault */
+/*	PHY_ANE_LP_NP		(see XMAC) Bit  3:	Link Partner can Next Page */
+/*	PHY_ANE_LOC_NP		(see XMAC) Bit  2:	Local PHY can Next Page */
+/*	PHY_ANE_RX_PG		(see XMAC) Bit  1:	Page Received */
+#define PHY_ANE_LP_CAP	(1<<0)	/* Bit  0:	Link Partner Auto-Neg. Cap. */ 	
 
 /*****  PHY_XMAC_NEPG		16 bit r/w	Next Page Register *****/
 /*****  PHY_BCOM_NEPG		16 bit r/w	Next Page Register *****/
@@ -958,7 +968,7 @@ extern "C" {
 #define PHY_X_RS_HD		(1<<6)	/* Bit  6:	Half Duplex Mode selected */
 #define PHY_X_RS_FD		(1<<5)	/* Bit  5:	Full Duplex Mode selected */
 #define PHY_X_RS_ABLMIS (1<<4)	/* Bit  4:	duplex or pause cap mismatch */
-#define PHY_X_RS_PAUMIS (1<<3)	/* Bit  3:	pause capability missmatch */
+#define PHY_X_RS_PAUMIS (1<<3)	/* Bit  3:	pause capability mismatch */
 								/* Bit  2..0:	reserved */
 /*
  * Remote Fault Bits (PHY_X_AN_RFB) encoding
@@ -990,6 +1000,7 @@ extern "C" {
 									/* Bit  7..0:	reserved */
 
 /*****  PHY_BCOM_1000T_STAT	16 bit r/o	1000Base-T Status Reg *****/
+/*****  PHY_MARV_1000T_STAT	16 bit r/o	1000Base-T Status Reg *****/
 #define PHY_B_1000S_MSF		(1<<15)	/* Bit 15:	Master/Slave Fault */
 #define PHY_B_1000S_MSR		(1<<14)	/* Bit 14:	Master/Slave Result */
 #define PHY_B_1000S_LRS		(1<<13)	/* Bit 13:	Local Receiver Status */
@@ -1309,7 +1320,6 @@ extern "C" {
 									/* Bit  7..0:	reserved */
 
 /*****  PHY_MARV_PHY_CTRL	16 bit r/w	PHY Specific Ctrl Reg *****/
-
 #define PHY_M_PC_TX_FFD_MSK	(3<<14)	/* Bit 15..14:	Tx FIFO Depth Mask */
 #define PHY_M_PC_RX_FFD_MSK	(3<<12)	/* Bit 13..12:	Rx FIFO Depth Mask */
 #define PHY_M_PC_ASS_CRS_TX	(1<<11)	/* Bit 11:	Assert CRS on Transmit */
@@ -1323,6 +1333,9 @@ extern "C" {
 #define PHY_M_PC_POL_R_DIS	(1<<1)	/* Bit  1:	Polarity Reversal Disabled */
 #define PHY_M_PC_DIS_JABBER	(1<<0)	/* Bit  0:	Disable Jabber */
 
+#define PHY_M_PC_EN_DET			SHIFT8(2)	/* Energy Detect (Mode 1) */
+#define PHY_M_PC_EN_DET_PLUS	SHIFT8(3)	/* Energy Detect Plus (Mode 2) */
+
 #define PHY_M_PC_MDI_XMODE(x)	SHIFT5(x)	
 #define PHY_M_PC_MAN_MDI	0    	/* 00 = Manual MDI configuration */
 #define PHY_M_PC_MAN_MDIX	1		/* 01 = Manual MDIX configuration */
@@ -1373,6 +1386,7 @@ extern "C" {
 #define PHY_M_EC_M_DSC_MSK	(3<<10)	/* Bit 11..10:	Master downshift counter */
 #define PHY_M_EC_S_DSC_MSK	(3<<8)	/* Bit  9.. 8:	Slave  downshift counter */
 #define PHY_M_EC_MAC_S_MSK	(7<<4)	/* Bit  6.. 4:	Def. MAC interface speed */
+#define PHY_M_EC_FIB_AN_ENA	(1<<3)	/* Bit  3:	Fiber Auto-Neg. Enable */
 
 #define PHY_M_EC_M_DSC(x)		SHIFT10(x)	/* 00=1x; 01=2x; 10=3x; 11=4x */
 #define PHY_M_EC_S_DSC(x)		SHIFT8(x)	/* 00=dis; 01=1x; 10=2x; 11=3x */
@@ -1434,6 +1448,18 @@ extern "C" {
 #define PHY_M_EC2_FO_BOOST	(1<<3)	/* Bit  3:	Fiber Output Boost */
 #define PHY_M_EC2_FO_AM_MSK	7		/* Bit  2.. 0:	Fiber Output Amplitude */
 
+/*****	PHY_MARV_EXT_P_STAT 16 bit r/w	Ext. PHY Specific Status *****/
+#define PHY_M_FC_AUTO_SEL	(1<<15)	/* Bit 15:	Fiber/Copper Auto Sel. dis. */
+#define PHY_M_FC_AN_REG_ACC (1<<14) /* Bit 14:	Fiber/Copper Autoneg. reg acc */
+#define PHY_M_FC_RESULUTION (1<<13)	/* Bit 13:	Fiber/Copper Resulution */
+#define PHY_M_SER_IF_AN_BP  (1<<12) /* Bit 12:	Ser IF autoneg. bypass enable */
+#define PHY_M_SER_IF_BP_ST	(1<<11) /* Bit 11:	Ser IF autoneg. bypass status */
+#define PHY_M_IRQ_POLARITY	(1<<10) /* Bit 10:	IRQ polarity */
+									/* Bit 9..4: reserved */
+#define PHY_M_UNDOC1		(1<< 7) /* undocumented bit !! */
+#define PHY_M_MODE_MASK		(0xf<<0)/* Bit 3..0: copy of HWCFG MODE[3:0] */
+
+
 /*****  PHY_MARV_CABLE_DIAG	16 bit r/o	Cable Diagnostic Reg *****/
 #define PHY_M_CABD_ENA_TEST	(1<<15)	/* Bit 15:	Enable Test */
 #define PHY_M_CABD_STAT_MSK	(3<<13)	/* Bit 14..13:	Status */
@@ -1531,7 +1557,7 @@ extern "C" {
 #define GM_RXF_SHT \
 			(GM_MIB_CNT_BASE + 80)	/* Frames <64 Byte Received OK */
 #define GM_RXE_FRAG \
-			(GM_MIB_CNT_BASE + 88)	/* Frames <64 Byte Receeived with FCS Err */
+			(GM_MIB_CNT_BASE + 88)	/* Frames <64 Byte Received with FCS Err */
 #define GM_RXF_64B \
 			(GM_MIB_CNT_BASE + 96)	/* 64 Byte Rx Frame */
 #define GM_RXF_127B \
@@ -1606,7 +1632,6 @@ extern "C" {
  */
 
 /*	GM_GP_STAT	16 bit r/o	General Purpose Status Register */
-
 #define GM_GPSR_SPEED		(1<<15) /* Bit 15:	Port Speed (1 = 100 Mbps) */
 #define GM_GPSR_DUPLEX		(1<<14) /* Bit 14:	Duplex Mode (1 = Full) */
 #define GM_GPSR_FC_TX_DIS	(1<<13) /* Bit 13:	Tx Flow-Control Mode Disabled */
@@ -1646,11 +1671,14 @@ extern "C" {
 							 GM_GPCR_AU_SPD_DIS)
 	
 /*	GM_TX_CTRL				16 bit r/w	Transmit Control Register */
-
 #define GM_TXCR_FORCE_JAM	(1<<15)	/* Bit 15:	Force Jam / Flow-Control */
 #define GM_TXCR_CRC_DIS		(1<<14)	/* Bit 14:	Disable insertion of CRC */
 #define GM_TXCR_PAD_DIS		(1<<13)	/* Bit 13:	Disable padding of packets */
-#define GM_TXCR_COL_THR		(4<<10)	/* Bit 12..10:	Collision Threshold */
+#define GM_TXCR_COL_THR_MSK	(1<<10)	/* Bit 12..10:	Collision Threshold */
+
+#define TX_COL_THR(x)		(SHIFT10(x) & GM_TXCR_COL_THR_MSK)
+
+#define TX_COL_DEF			0x04
 	
 /*	GM_RX_CTRL				16 bit r/w	Receive Control Register */
 #define GM_RXCR_UCF_ENA		(1<<15)	/* Bit 15:	Enable Unicast filtering */
@@ -1663,35 +1691,41 @@ extern "C" {
 #define GM_TXPA_JAMIPG_MSK	(0x1f<<9)	/* Bit 13..9:	Jam IPG */
 #define GM_TXPA_JAMDAT_MSK	(0x1f<<4)	/* Bit  8..4:	IPG Jam to Data */
 								/* Bit  3..0:	reserved */
-#define JAM_LEN_VAL(x)		SHIFT14(x)
-#define JAM_IPG_VAL(x)		SHIFT9(x)
-#define IPG_JAM_DATA(x)		SHIFT4(x)
+
+#define TX_JAM_LEN_VAL(x)	(SHIFT14(x) & GM_TXPA_JAMLEN_MSK)
+#define TX_JAM_IPG_VAL(x)	(SHIFT9(x) & GM_TXPA_JAMIPG_MSK)
+#define TX_IPG_JAM_DATA(x)	(SHIFT4(x) & GM_TXPA_JAMDAT_MSK)
+
+#define TX_JAM_LEN_DEF		0x03
+#define TX_JAM_IPG_DEF		0x0b
+#define TX_IPG_JAM_DEF		0x1c
 
 /*	GM_SERIAL_MODE			16 bit r/w	Serial Mode Register */
-#define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder */
+#define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder (r/o) */
 #define GM_SMOD_LIMIT_4		(1<<10)	/* Bit 10:	4 consecutive Tx trials */
 #define GM_SMOD_VLAN_ENA	(1<<9)	/* Bit  9:	Enable VLAN  (Max. Frame Len) */
 #define GM_SMOD_JUMBO_ENA	(1<<8)	/* Bit  8:	Enable Jumbo (Max. Frame Len) */
 								/* Bit  7..5:	reserved */
 #define GM_SMOD_IPG_MSK		0x1f	/* Bit 4..0:	Inter-Packet Gap (IPG) */
 	
-#define DATA_BLIND_VAL(x)	SHIFT11(x)
-#define DATA_BLIND_FAST_ETH	0x1c
-#define DATA_BLIND_GIGABIT	4
+#define DATA_BLIND_VAL(x)	(SHIFT11(x) & GM_SMOD_DATABL_MSK)
+#define DATA_BLIND_DEF		0x04
 
-#define IPG_VAL_FAST_ETH	0x1e
-#define IPG_VAL_GIGABIT		6
+#define IPG_DATA_VAL(x)		(x & GM_SMOD_IPG_MSK)
+#define IPG_DATA_DEF		0x1e
 
 /*	GM_SMI_CTRL				16 bit r/w	SMI Control Register */
-
-#define GM_SMI_CT_PHY_AD(x)	SHIFT11(x)
-#define GM_SMI_CT_REG_AD(x)	SHIFT6(x)
+#define GM_SMI_CT_PHY_A_MSK	(0x1f<<11)	/* Bit 15..11:	PHY Device Address */
+#define GM_SMI_CT_REG_A_MSK	(0x1f<<6)	/* Bit 10.. 6:	PHY Register Address */
 #define GM_SMI_CT_OP_RD		(1<<5)	/* Bit  5:	OpCode Read (0=Write)*/
 #define GM_SMI_CT_RD_VAL	(1<<4)	/* Bit  4:	Read Valid (Read completed) */
 #define GM_SMI_CT_BUSY		(1<<3)	/* Bit  3:	Busy (Operation in progress) */
 								/* Bit   2..0:	reserved */
 	
-/*	GM_PHY_ADDR				16 bit r/w	GPHY Address Register */
+#define GM_SMI_CT_PHY_AD(x)	(SHIFT11(x) & GM_SMI_CT_PHY_A_MSK)
+#define GM_SMI_CT_REG_AD(x)	(SHIFT6(x) & GM_SMI_CT_REG_A_MSK)
+
+	/*	GM_PHY_ADDR				16 bit r/w	GPHY Address Register */
 								/* Bit  15..6:	reserved */
 #define GM_PAR_MIB_CLR		(1<<5)	/* Bit  5:	Set MIB Clear Counter Mode */
 #define GM_PAR_MIB_TST		(1<<4)	/* Bit  4:	MIB Load Counter (Test Mode) */
diff -purN linux-2.6.1/drivers/net/sk98lin/skcsum.c linux-2.5/drivers/net/sk98lin/skcsum.c
--- linux-2.6.1/drivers/net/sk98lin/skcsum.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skcsum.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 2003/03/11 14:05:55 $
+ * Version:	$Revision: 1.12 $
+ * Date:	$Date: 2003/08/20 13:55:53 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
@@ -26,6 +26,10 @@
  * History:
  *
  *	$Log: skcsum.c,v $
+ *	Revision 1.12  2003/08/20 13:55:53  mschmid
+ *	Changed notation of #ifndef SkCsCalculateChecksum to
+ *	#ifndef SK_CS_CALCULATE_CHECKSUM
+ *	
  *	Revision 1.11  2003/03/11 14:05:55  rschmidt
  *	Replaced memset() by macro SK_MEMSET()
  *	Editorial changes
@@ -78,7 +82,7 @@
 
 #ifndef lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skcsum.c,v 1.11 2003/03/11 14:05:55 rschmidt Exp $ (C) SysKonnect.";
+	"@(#) $Id: skcsum.c,v 1.12 2003/08/20 13:55:53 mschmid Exp $ (C) SysKonnect.";
 #endif	/* !lint */
 
 /******************************************************************************
@@ -791,7 +795,7 @@ int			NetNumber)
 	*pChecksum2Offset = SKCS_MAC_HEADER_SIZE + SKCS_IP_HEADER_SIZE;
 }	/* SkCsSetReceiveFlags */
 
-#ifndef SkCsCalculateChecksum
+#ifndef SK_CS_CALCULATE_CHECKSUM
 
 /******************************************************************************
  *
@@ -856,7 +860,7 @@ unsigned	Length)		/* Length of data. */
 	return ((unsigned) Checksum);
 }	/* SkCsCalculateChecksum */
 
-#endif /* SkCsCalculateChecksum */
+#endif /* SK_CS_CALCULATE_CHECKSUM */
 
 /******************************************************************************
  *
diff -purN linux-2.6.1/drivers/net/sk98lin/skdim.c linux-2.5/drivers/net/sk98lin/skdim.c
--- linux-2.6.1/drivers/net/sk98lin/skdim.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skdim.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skdim.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2 $
- * Date:	$Date: 2003/08/21 12:35:05 $
+ * Version:	$Revision: 1.5 $
+ * Date:	$Date: 2003/11/28 12:55:40 $
  * Purpose:	All functions to maintain interrupt moderation
  *
  ******************************************************************************/
@@ -11,6 +11,7 @@
 /******************************************************************************
  *
  *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,15 @@
  * History:
  *	
  *	$Log: skdim.c,v $
+ *	Revision 1.5  2003/11/28 12:55:40  rroesler
+ *	Fix: support for new process timing interface added
+ *	
+ *	Revision 1.4  2003/10/10 10:58:56  mlindner
+ *	Fix: CPU detection under the kernel 2.6
+ *	
+ *	Revision 1.3  2003/10/07 08:17:08  mlindner
+ *	Fix: Copyright changes
+ *	
  *	Revision 1.2  2003/08/21 12:35:05  mlindner
  *	Fix: Corrected CPU detection and compile errors on single CPU machines
  *	
@@ -62,7 +72,7 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skdim.c,v 1.2 2003/08/21 12:35:05 mlindner Exp $ (C) SysKonnect.";
+	"@(#) $Id: skdim.c,v 1.5 2003/11/28 12:55:40 rroesler Exp $ (C) SysKonnect.";
 #endif
 
 #define __SKADDR_C
@@ -327,7 +337,9 @@ GetCurrentSystemLoad(SK_AC *pAC) {
 	**
 	**      struct kernel_stat kstat
 	**
-	** is not marked as an exported symbol
+	** is not marked as an exported symbol in the file
+	**
+	**      kernel/ksyms.c 
 	**
 	** As a consequence, using this driver as KLM is not possible
 	** and any access of the structure kernel_stat via the 
diff -purN linux-2.6.1/drivers/net/sk98lin/skge.c linux-2.5/drivers/net/sk98lin/skge.c
--- linux-2.6.1/drivers/net/sk98lin/skge.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skge.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,35 +1,20 @@
 /******************************************************************************
  *
- * Name:    skge.c
+ * Name:	skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:       	$Date: 2003/08/26 16:05:19 $
+ * Version:	$Revision: 1.42 $
+ * Date:       	$Date: 2003/12/12 10:05:43 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
- *	Driver for SysKonnect Gigabit Ethernet Server Adapters:
- *
- *	SK-9871 (single link 1000Base-ZX)
- *	SK-9872 (dual link   1000Base-ZX)
- *	SK-9861 (single link 1000Base-SX, VF45 Volition Plug)
- *	SK-9862 (dual link   1000Base-SX, VF45 Volition Plug)
- *	SK-9841 (single link 1000Base-LX)
- *	SK-9842 (dual link   1000Base-LX)
- *	SK-9843 (single link 1000Base-SX)
- *	SK-9844 (dual link   1000Base-SX)
- *	SK-9821 (single link 1000Base-T)
- *	SK-9822 (dual link   1000Base-T)
- *	SK-9881 (single link 1000Base-SX V2 LC)
- *	SK-9871 (single link 1000Base-ZX V2)
- *	SK-9861 (single link 1000Base-SX V2, VF45 Volition Plug)
- *	SK-9841 (single link 1000Base-LX V2)
- *	SK-9843 (single link 1000Base-SX V2)
- *	SK-9821 (single link 1000Base-T V2)
+ *	Driver for Marvell Yukon chipset and SysKonnect Gigabit Ethernet 
+ *      Server Adapters.
  *
  *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and
  *	SysKonnects GEnesis Solaris driver
@@ -56,6 +41,87 @@
  * History:
  *
  *	$Log: skge.c,v $
+ *	Revision 1.42  2003/12/12 10:05:43  mlindner
+ *	Fix: Format of error message corrected
+ *	
+ *	Revision 1.41  2003/12/11 16:03:57  mlindner
+ *	Fix: Create backup from pnmi data structure
+ *	
+ *	Revision 1.40  2003/12/11 12:14:48  mlindner
+ *	Fix: Initalize Board before network configuration
+ *	Fix: Change device names to driver name
+ *	
+ *	Revision 1.39  2003/12/10 08:57:38  rroesler
+ *	Fix: Modifications regarding try_module_get() and capable()
+ *	
+ *	Revision 1.38  2003/12/01 17:16:50  mlindner
+ *	Fix: Remove useless register_netdev
+ *	
+ *	Revision 1.37  2003/12/01 17:11:30  mlindner
+ *	Fix: Register net device before SkGeBoardInit
+ *	
+ *	Revision 1.36  2003/11/28 13:04:27  rroesler
+ *	Fix: do not print interface status in case DIAG is used
+ *	
+ *	Revision 1.35  2003/11/17 14:41:06  mlindner
+ *	Fix: Endif command
+ *	
+ *	Revision 1.34  2003/11/17 13:29:05  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.33  2003/11/14 14:56:54  rroesler
+ *	Fix: corrected compilation warnings kernel 2.2
+ *	
+ *	Revision 1.32  2003/11/13 14:18:47  rroesler
+ *	Fix: added latest changes regarding the use of the proc system
+ *	
+ *	Revision 1.31  2003/11/13 09:28:35  rroesler
+ *	Fix: removed kernel warning 'driver changed get_stats after register'
+ *	
+ *	Revision 1.30  2003/11/11 13:15:27  rroesler
+ *	Fix: use suitables kernel usage count macros when using the diag
+ *	
+ *	Revision 1.29  2003/11/10 09:38:26  rroesler
+ *	Fix: restore PNMI structure backup for DIAG actions
+ *	
+ *	Revision 1.28  2003/11/07 17:28:45  rroesler
+ *	Fix: Additions for the LeaveDiagMode
+ *	
+ *	Revision 1.27  2003/11/03 13:21:14  mlindner
+ *	Add: SkGeBuffPad function for padding to ensure the trailing bytes exist
+ *	
+ *	Revision 1.26  2003/10/30 09:20:40  mlindner
+ *	Fix: Control bit check
+ *	
+ *	Revision 1.25  2003/10/29 07:43:37  rroesler
+ *	Fix: Implemented full None values handling for parameter Moderation
+ *	
+ *	Revision 1.24  2003/10/22 14:18:12  rroesler
+ *	Fix: DIAG handling for DualNet cards
+ *	
+ *	Revision 1.23  2003/10/17 10:05:13  mlindner
+ *	Add: New blinkmode for Morvell cards
+ *	
+ *	Revision 1.22  2003/10/15 12:31:25  rroesler
+ *	Fix: Corrected bugreport #10954 (Linux System crash when using vlans)
+ *	
+ *	Revision 1.21  2003/10/07 12:32:28  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.20  2003/10/07 12:22:40  mlindner
+ *	Fix: Compiler warnings
+ *	
+ *	Revision 1.19  2003/10/07 09:33:40  mlindner
+ *	Fix: No warnings for illegal values of Mod and IntsPerSec
+ *	Fix: Speed 100 in Half Duplex not allowed for Yukon
+ *	Fix: PrefPort=B not allowed on single NICs
+ *	
+ *	Revision 1.18  2003/10/07 08:17:08  mlindner
+ *	Fix: Copyright changes
+ *	
+ *	Revision 1.17  2003/09/29 12:06:59  mlindner
+ *	*** empty log message ***
+ *	
  *	Revision 1.16  2003/09/23 11:07:35  mlindner
  *	Fix: IO-control return race condition
  *	Fix: Interrupt moderation value check
@@ -68,6 +134,12 @@
  *	Add: Yukon Plus changes (ChipID, PCI...)
  *	Fix: TCP and UDP Checksum calculation
  *	
+ *	Revision 1.13  2003/09/01 13:30:08  rroesler
+ *	Fix: Corrected missing defines
+ *	
+ *	Revision 1.12  2003/09/01 13:12:02  rroesler
+ *	Add: Code for improved DIAG Attach/Detach interface
+ *	
  *	Revision 1.11  2003/08/26 16:05:19  mlindner
  *	Fix: Compiler warnings (void *)
  *	
@@ -406,7 +478,6 @@
  *	<linux/module.h>
  *
  *	"h/skdrv1st.h"
- *		<linux/version.h>
  *		<linux/types.h>
  *		<linux/kernel.h>
  *		<linux/string.h>
@@ -568,6 +639,12 @@ static void	StartDrvCleanupTimer(SK_AC *
 static void	StopDrvCleanupTimer(SK_AC *pAC);
 static int	XmitFrameSG(SK_AC*, TX_PORT*, struct sk_buff*);
 
+#ifdef SK_DIAG_SUPPORT
+static SK_U32   ParseDeviceNbrFromSlotName(const char *SlotName);
+static int      SkDrvInitAdapter(SK_AC *pAC, int devNbr);
+static int      SkDrvDeInitAdapter(SK_AC *pAC, int devNbr);
+#endif
+
 /*******************************************************************************
  *
  * Extern Function Prototypes
@@ -576,8 +653,8 @@ static int	XmitFrameSG(SK_AC*, TX_PORT*,
 
 #ifdef CONFIG_PROC_FS
 static const char 	SK_Root_Dir_entry[] = "sk98lin";
-static struct		proc_dir_entry *pSkRootDir;
-extern struct		file_operations sk_proc_fops;
+static struct		proc_dir_entry *pSkRootDir = NULL;
+extern struct	file_operations sk_proc_fops;
 #endif
 
 extern void SkDimEnableModerationIfNeeded(SK_AC *pAC);	
@@ -595,12 +672,19 @@ static void	DumpLong(char*, int);
 static const char *BootString = BOOT_STRING;
 struct SK_NET_DEVICE *SkGeRootDev = NULL;
 static int probed __initdata = 0;
+static SK_BOOL DoPrintInterfaceChange = SK_TRUE;
 
 /* local variables **********************************************************/
 static uintptr_t TxQueueAddr[SK_MAX_MACS][2] = {{0x680, 0x600},{0x780, 0x700}};
 static uintptr_t RxQueueAddr[SK_MAX_MACS] = {0x400, 0x480};
 
 
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry	*pSkRootDir;
+#endif
+
+
+
 /*****************************************************************************
  *
  * 	skge_probe - find all SK-98xx adapters
@@ -626,6 +710,7 @@ static int __init skge_probe (void)
 	SK_BOOL BootStringCount = SK_FALSE;
 	int			retval;
 #ifdef CONFIG_PROC_FS
+	int			proc_root_initialized = 0;
 	struct proc_dir_entry	*pProcFile;
 #endif
 
@@ -700,6 +785,7 @@ static int __init skge_probe (void)
 		dev->stop =		&SkGeClose;
 		dev->hard_start_xmit =	&SkGeXmit;
 		dev->get_stats =	&SkGeStats;
+		dev->last_stats =	&SkGeStats;
 		dev->set_multicast_list = &SkGeSetRxMode;
 		dev->set_mac_address =	&SkGeSetMacAddr;
 		dev->do_ioctl =		&SkGeIoctl;
@@ -718,15 +804,13 @@ static int __init skge_probe (void)
 #endif
 
 		pAC->Index = boards_found;
+
 		if (SkGeBoardInit(dev, pAC)) {
-			FreeResources(dev);
 			free_netdev(dev);
 			continue;
 		}
 
-		memcpy((caddr_t) &dev->dev_addr,
-			(caddr_t) &pAC->Addr.Net[0].CurrentMacAddress, 6);
-
+		/* Register net device */
 		if (register_netdev(dev)) {
 			printk(KERN_ERR "SKGE: Could not register device.\n");
 			FreeResources(dev);
@@ -734,6 +818,25 @@ static int __init skge_probe (void)
 			continue;
 		}
 
+		/* Print adapter specific string from vpd */
+		ProductStr(pAC);
+		printk("%s: %s\n", dev->name, pAC->DeviceStr);
+
+		/* Print configuration settings */
+		printk("      PrefPort:%c  RlmtMode:%s\n",
+			'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
+			(pAC->RlmtMode==0)  ? "Check Link State" :
+			((pAC->RlmtMode==1) ? "Check Link State" :
+			((pAC->RlmtMode==3) ? "Check Local Port" :
+			((pAC->RlmtMode==7) ? "Check Segmentation" :
+			((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
+
+		SkGeYellowLED(pAC, pAC->IoBase, 1);
+
+
+		memcpy((caddr_t) &dev->dev_addr,
+			(caddr_t) &pAC->Addr.Net[0].CurrentMacAddress, 6);
+
 		/* First adapter... Create proc and print message */
 #ifdef CONFIG_PROC_FS
 		if (!DeviceFound) {
@@ -744,25 +847,27 @@ static int __init skge_probe (void)
 			/*Create proc (directory)*/
 			if(!pSkRootDir) {
 				pSkRootDir = proc_mkdir(SK_Root_Dir_entry, proc_net);
-				if (!pSkRootDir) 
+				if (!pSkRootDir) {
 					printk(KERN_WARNING "%s: Unable to create /proc/net/%s",
-					       dev->name, SK_Root_Dir_entry);
-				else
+						dev->name, SK_Root_Dir_entry);
+				} else {
 					pSkRootDir->owner = THIS_MODULE;
+				}
 			}
 		}
-		
+
 		/* Create proc file */
-		if (pSkRootDir 
-		    && (pProcFile = create_proc_entry(dev->name, S_IRUGO,
-						      pSkRootDir))) {
+		if (pSkRootDir && 
+			(pProcFile = create_proc_entry(dev->name, S_IRUGO,
+				pSkRootDir))) {
 			pProcFile->proc_fops = &sk_proc_fops;
-			pProcFile->data = dev;
+			pProcFile->data      = dev;
 		}
+
 #endif
 
 		pNet->PortNr = 0;
-		pNet->NetNr = 0;
+		pNet->NetNr  = 0;
 
 		boards_found++;
 
@@ -774,23 +879,24 @@ static int __init skge_probe (void)
 				break;
 			}
 
-			pAC->dev[1] = dev;
-			pNet = dev->priv;
-			pNet->PortNr = 1;
-			pNet->NetNr = 1;
-			pNet->pAC = pAC;
-			pNet->Mtu = 1500;
-			pNet->Up = 0;
-
-			dev->open =		&SkGeOpen;
-			dev->stop =		&SkGeClose;
-			dev->hard_start_xmit =	&SkGeXmit;
-			dev->get_stats =	&SkGeStats;
+			pAC->dev[1]   = dev;
+			pNet          = dev->priv;
+			pNet->PortNr  = 1;
+			pNet->NetNr   = 1;
+			pNet->pAC     = pAC;
+			pNet->Mtu     = 1500;
+			pNet->Up      = 0;
+
+			dev->open               = &SkGeOpen;
+			dev->stop               = &SkGeClose;
+			dev->hard_start_xmit    = &SkGeXmit;
+			dev->get_stats          = &SkGeStats;
+			dev->last_stats         = &SkGeStats;
 			dev->set_multicast_list = &SkGeSetRxMode;
-			dev->set_mac_address =	&SkGeSetMacAddr;
-			dev->do_ioctl =		&SkGeIoctl;
-			dev->change_mtu =	&SkGeChangeMtu;
-			dev->flags &= 		~IFF_RUNNING;
+			dev->set_mac_address    = &SkGeSetMacAddr;
+			dev->do_ioctl           = &SkGeIoctl;
+			dev->change_mtu         = &SkGeChangeMtu;
+			dev->flags             &= ~IFF_RUNNING;
 
 #ifdef SK_ZEROCOPY
 #ifdef USE_SK_TX_CHECKSUM
@@ -802,34 +908,39 @@ static int __init skge_probe (void)
 #endif
 
 			if (register_netdev(dev)) {
-				printk(KERN_ERR "SKGE: Could not register "
-				       "second port.\n");
+				printk(KERN_ERR "SKGE: Could not register device.\n");
 				free_netdev(dev);
 				pAC->dev[1] = pAC->dev[0];
 			} else {
 #ifdef CONFIG_PROC_FS
 				if (pSkRootDir 
 				    && (pProcFile = create_proc_entry(dev->name, 
-								      S_IRUGO,
-								      pSkRootDir))) {
+								S_IRUGO, pSkRootDir))) {
 					pProcFile->proc_fops = &sk_proc_fops;
-					pProcFile->data = dev;
+					pProcFile->data      = dev;
 				}
 #endif
 
-				memcpy((caddr_t) &dev->dev_addr,
-				       (caddr_t) &pAC->Addr.Net[1].CurrentMacAddress, 6);
+			memcpy((caddr_t) &dev->dev_addr,
+			(caddr_t) &pAC->Addr.Net[1].CurrentMacAddress, 6);
 	
-				printk("%s: %s\n", dev->name, pAC->DeviceStr);
-				printk("      PrefPort:B  RlmtMode:Dual Check Link State\n");
+			printk("%s: %s\n", dev->name, pAC->DeviceStr);
+			printk("      PrefPort:B  RlmtMode:Dual Check Link State\n");
 			}
 		}
 
-
 		/* Save the hardware revision */
 		pAC->HWRevision = (((pAC->GIni.GIPciHwRev >> 4) & 0x0F)*10) +
 			(pAC->GIni.GIPciHwRev & 0x0F);
 
+		/* Set driver globals */
+		pAC->Pnmi.pDriverFileName    = DRIVER_FILE_NAME;
+		pAC->Pnmi.pDriverReleaseDate = DRIVER_REL_DATE;
+
+		SK_MEMSET(&(pAC->PnmiBackup), 0, sizeof(SK_PNMI_STRUCT_DATA));
+		SK_MEMCPY(&(pAC->PnmiBackup), &(pAC->PnmiStruct), 
+				sizeof(SK_PNMI_STRUCT_DATA));
+
 		/*
 		 * This is bollocks, but we need to tell the net-init
 		 * code that it shall go for the next device.
@@ -849,7 +960,6 @@ static int __init skge_probe (void)
 } /* skge_probe */
 
 
-
 /*****************************************************************************
  *
  * 	SkGeInitPCI - Init the PCI resources
@@ -1161,8 +1271,7 @@ SK_EVPARA EvPara;
 
 #ifdef CONFIG_PROC_FS
 	/* clear proc-dir */
-	if (pSkRootDir) 
-		remove_proc_entry(pSkRootDir->name, proc_net);
+	remove_proc_entry(pSkRootDir->name, proc_net);
 #endif
 
 } /* skge_cleanup_module */
@@ -1224,7 +1333,7 @@ SK_BOOL	DualNet;
 	SkAddrInit( pAC, pAC->IoBase, SK_INIT_DATA);
 	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_DATA);
 	SkTimerInit(pAC, pAC->IoBase, SK_INIT_DATA);
-	
+
 	pAC->BoardLevel = SK_INIT_DATA;
 	pAC->RxBufSize  = ETH_BUF_SIZE;
 
@@ -1236,7 +1345,7 @@ SK_BOOL	DualNet;
 	/* level 1 init common modules here (HW init) */
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 	if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
-		printk("HWInit (1) failed.\n");
+		printk("sk98lin: HWInit (1) failed.\n");
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 		return(-EAGAIN);
 	}
@@ -1268,14 +1377,14 @@ SK_BOOL	DualNet;
 		Ret = request_irq(dev->irq, SkGeIsrOnePort, SA_SHIRQ,
 			pAC->Name, dev);
 	} else {
-		printk(KERN_WARNING "%s: Illegal number of ports: %d\n",
-		       dev->name, pAC->GIni.GIMacsFound);
+		printk(KERN_WARNING "sk98lin: Illegal number of ports: %d\n",
+		       pAC->GIni.GIMacsFound);
 		return -EAGAIN;
 	}
 
 	if (Ret) {
-		printk(KERN_WARNING "%s: Requested IRQ %d is busy.\n",
-		       dev->name, dev->irq);
+		printk(KERN_WARNING "sk98lin: Requested IRQ %d is busy.\n",
+		       dev->irq);
 		return -EAGAIN;
 	}
 	pAC->AllocFlag |= SK_ALLOC_IRQ;
@@ -1303,25 +1412,10 @@ SK_BOOL	DualNet;
 		pAC->ActivePort,
 		DualNet)) {
 		BoardFreeMem(pAC);
-		printk("SkGeInitAssignRamToQueues failed.\n");
+		printk("sk98lin: SkGeInitAssignRamToQueues failed.\n");
 		return(-EAGAIN);
 	}
 
-	/* Print adapter specific string from vpd */
-	ProductStr(pAC);
-	printk("%s: %s\n", dev->name, pAC->DeviceStr);
-
-	/* Print configuration settings */
-	printk("      PrefPort:%c  RlmtMode:%s\n",
-		'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
-		(pAC->RlmtMode==0)  ? "Check Link State" :
-		((pAC->RlmtMode==1) ? "Check Link State" :
-		((pAC->RlmtMode==3) ? "Check Local Port" :
-		((pAC->RlmtMode==7) ? "Check Segmentation" :
-		((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
-
-	SkGeYellowLED(pAC, pAC->IoBase, 1);
-
 	/*
 	 * Register the device here
 	 */
@@ -1879,14 +1973,26 @@ struct SK_NET_DEVICE	*dev)
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen: pAC=0x%lX:\n", (unsigned long)pAC));
 
+#ifdef SK_DIAG_SUPPORT
+	if (pAC->DiagModeActive == DIAG_ACTIVE) {
+		if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
+			return (-1);   /* still in use by diag; deny actions */
+		} 
+	}
+#endif
+
+	if (!try_module_get(THIS_MODULE)) {
+		return (-1);	/* increase of usage count not possible */
+	}
 
 	/* Set blink mode */
-	if (pAC->PciDev->vendor == 0x1186)
+	if ((pAC->PciDev->vendor == 0x1186) || (pAC->PciDev->vendor == 0x11ab ))
 		pAC->GIni.GILedBlinkCtrl = OEM_CONFIG_VALUE;
 
 	if (pAC->BoardLevel == SK_INIT_DATA) {
 		/* level 1 init common modules here */
 		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
+			module_put(THIS_MODULE); /* decrease usage count */
 			printk("%s: HWInit (1) failed.\n", pAC->dev[pNet->PortNr]->name);
 			return (-1);
 		}
@@ -1902,6 +2008,7 @@ struct SK_NET_DEVICE	*dev)
 	if (pAC->BoardLevel != SK_INIT_RUN) {
 		/* tschilling: Level 2 init modules here, check return value. */
 		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_RUN) != 0) {
+			module_put(THIS_MODULE); /* decrease usage count */
 			printk("%s: HWInit (2) failed.\n", pAC->dev[pNet->PortNr]->name);
 			return (-1);
 		}
@@ -1953,7 +2060,6 @@ struct SK_NET_DEVICE	*dev)
 	pAC->MaxPorts++;
 	pNet->Up = 1;
 
-	try_module_get(THIS_MODULE);
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen suceeded\n"));
@@ -1976,26 +2082,50 @@ struct SK_NET_DEVICE	*dev)
 static int SkGeClose(
 struct SK_NET_DEVICE	*dev)
 {
-	DEV_NET			*pNet;
-	SK_AC			*pAC;
+	DEV_NET		*pNet;
+	DEV_NET		*newPtrNet;
+	SK_AC		*pAC;
 
 	unsigned long	Flags;		/* for spin lock */
-	int				i;
-	int				PortIdx;
-	SK_EVPARA		EvPara;
+	int		i;
+	int		PortIdx;
+	SK_EVPARA	EvPara;
+
+	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
+		("SkGeClose: pAC=0x%lX ", (unsigned long)pAC));
 
-	netif_stop_queue(dev);
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
 
+#ifdef SK_DIAG_SUPPORT
+	if (pAC->DiagModeActive == DIAG_ACTIVE) {
+		if (pAC->DiagFlowCtrl == SK_FALSE) {
+			module_put(THIS_MODULE);
+			/* 
+			** notify that the interface which has been closed
+			** by operator interaction must not be started up 
+			** again when the DIAG has finished. 
+			*/
+			newPtrNet = (DEV_NET *) pAC->dev[0]->priv;
+			if (newPtrNet == pNet) {
+				pAC->WasIfUp[0] = SK_FALSE;
+			} else {
+				pAC->WasIfUp[1] = SK_FALSE;
+			}
+			return 0; /* return to system everything is fine... */
+		} else {
+			pAC->DiagFlowCtrl = SK_FALSE;
+		}
+	}
+#endif
+
+	netif_stop_queue(dev);
+
 	if (pAC->RlmtNets == 1)
 		PortIdx = pAC->ActivePort;
 	else
 		PortIdx = pNet->NetNr;
 
-	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
-		("SkGeClose: pAC=0x%lX ", (unsigned long)pAC));
-
         StopDrvCleanupTimer(pAC);
 
 	/*
@@ -2053,6 +2183,10 @@ struct SK_NET_DEVICE	*dev)
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeClose: done "));
 
+	SK_MEMSET(&(pAC->PnmiBackup), 0, sizeof(SK_PNMI_STRUCT_DATA));
+	SK_MEMCPY(&(pAC->PnmiBackup), &(pAC->PnmiStruct), 
+			sizeof(SK_PNMI_STRUCT_DATA));
+
 	pAC->MaxPorts--;
 	pNet->Up = 0;
 
@@ -2199,9 +2333,10 @@ struct sk_buff	*pMessage)	/* pointer to 
 	** This is to resolve faulty padding by the HW with 0xaa bytes.
 	*/
 	if (BytesSend < C_LEN_ETHERNET_MINSIZE) {
-	    skb_put(pMessage, (C_LEN_ETHERNET_MINSIZE-BytesSend));
-	    SK_MEMSET( ((char *)(pMessage->data))+BytesSend,
-	            0, C_LEN_ETHERNET_MINSIZE-BytesSend);
+		if ((pMessage = skb_padto(pMessage, C_LEN_ETHERNET_MINSIZE)) == NULL) {
+			return 0;
+		}
+		pMessage->len = C_LEN_ETHERNET_MINSIZE;
 	}
 
 	/* 
@@ -3318,6 +3453,16 @@ SK_EVPARA 	EvPara;
 		return -EINVAL;
 	}
 
+#ifdef SK_DIAG_SUPPORT
+	if (pAC->DiagModeActive == DIAG_ACTIVE) {
+		if (pAC->DiagFlowCtrl == SK_FALSE) {
+			return -1; /* still in use, deny any actions of MTU */
+		} else {
+			pAC->DiagFlowCtrl = SK_FALSE;
+		}
+	}
+#endif
+
 	pNet->Mtu = NewMtu;
 	pOtherNet = (DEV_NET*)pAC->dev[1 - pNet->NetNr]->priv;
 	if ((pOtherNet->Mtu>1500) && (NewMtu<=1500) && (pOtherNet->Up==1)) {
@@ -3537,11 +3682,20 @@ unsigned long	Flags;			/* for spin lock 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeStats starts now...\n"));
 	pPnmiStruct = &pAC->PnmiStruct;
-        memset(pPnmiStruct, 0, sizeof(SK_PNMI_STRUCT_DATA));
+
+#ifdef SK_DIAG_SUPPORT
+        if ((pAC->DiagModeActive == DIAG_NOTACTIVE) &&
+                (pAC->BoardLevel == SK_INIT_RUN)) {
+#endif
+        SK_MEMSET(pPnmiStruct, 0, sizeof(SK_PNMI_STRUCT_DATA));
         spin_lock_irqsave(&pAC->SlowPathLock, Flags);
         Size = SK_PNMI_STRUCT_SIZE;
 		SkPnmiGetStruct(pAC, pAC->IoBase, pPnmiStruct, &Size, pNet->NetNr);
         spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+#ifdef SK_DIAG_SUPPORT
+	}
+#endif
+
         pPnmiStat = &pPnmiStruct->Stat[0];
         pPnmiConf = &pPnmiStruct->Conf[0];
 
@@ -3604,7 +3758,7 @@ static int SkGeIoctl(struct SK_NET_DEVIC
 DEV_NET		*pNet;
 SK_AC		*pAC;
 void		*pMemBuf;
-
+struct pci_dev  *pdev = NULL;
 SK_GE_IOCTL	Ioctl;
 unsigned int	Err = 0;
 int		Size = 0;
@@ -3671,6 +3825,45 @@ int		HeaderLength = sizeof(SK_U32) + siz
 fault_gen:
 		kfree(pMemBuf); /* cleanup everything */
 		break;
+#ifdef SK_DIAG_SUPPORT
+       case SK_IOCTL_DIAG:
+		if (!capable(CAP_NET_ADMIN)) return -EPERM;
+		if (Ioctl.Len < (sizeof(pAC->PnmiStruct) + HeaderLength)) {
+			Length = Ioctl.Len;
+		} else {
+			Length = sizeof(pAC->PnmiStruct) + HeaderLength;
+		}
+		if (NULL == (pMemBuf = kmalloc(Length, GFP_KERNEL))) {
+			return -ENOMEM;
+		}
+		if(copy_from_user(pMemBuf, Ioctl.pData, Length)) {
+			Err = -EFAULT;
+			goto fault_diag;
+		}
+		pdev = pAC->PciDev;
+		Length = 3 * sizeof(SK_U32);  /* Error, Bus and Device */
+		/* 
+		** While coding this new IOCTL interface, only a few lines of code
+		** are to to be added. Therefore no dedicated function has been 
+		** added. If more functionality is added, a separate function 
+		** should be used...
+		*/
+		* ((SK_U32 *)pMemBuf) = 0;
+		* ((SK_U32 *)pMemBuf + 1) = pdev->bus->number;
+		* ((SK_U32 *)pMemBuf + 2) = ParseDeviceNbrFromSlotName(pdev->slot_name);
+		if(copy_to_user(Ioctl.pData, pMemBuf, Length) ) {
+			Err = -EFAULT;
+			goto fault_diag;
+		}
+		Ioctl.Len = Length;
+		if(copy_to_user(rq->ifr_data, &Ioctl, sizeof(SK_GE_IOCTL))) {
+			Err = -EFAULT;
+			goto fault_diag;
+		}
+fault_diag:
+		kfree(pMemBuf); /* cleanup everything */
+		break;
+#endif
 	default:
 		Err = -EOPNOTSUPP;
 	}
@@ -3826,10 +4019,9 @@ int	Capabilities[3][3] =
 				(strcmp(ConType[pAC->Index],"Auto")!=0) &&
 				(strcmp(ConType[pAC->Index],"")!=0)) {
 				/* Set the speed parameter back */
-					printk("%s: Illegal value \"%s\" " 
+					printk("sk98lin: Illegal value \"%s\" " 
 							"for ConType."
 							" Using Auto.\n", 
-							pAC->dev[0]->name, 
 							ConType[pAC->Index]);
 
 					sprintf(ConType[pAC->Index], "Auto");	
@@ -3873,8 +4065,8 @@ int	Capabilities[3][3] =
 			M_CurrPort.PLinkSpeed    = SK_LSPEED_10MBPS;
 		    }
                 } else { 
-		    printk("%s: Illegal value \"%s\" for ConType\n", 
-			pAC->dev[0]->name, ConType[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for ConType\n", 
+			ConType[pAC->Index]);
 		    IsConTypeDefined = SK_FALSE; /* Wrong ConType defined */
 		}
         } else {
@@ -3898,8 +4090,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(Speed_A[pAC->Index],"1000")==0) {
 		    LinkSpeed = SK_LSPEED_1000MBPS;
 		} else {
-		    printk("%s: Illegal value \"%s\" for Speed_A\n",
-			pAC->dev[0]->name, Speed_A[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for Speed_A\n",
+			Speed_A[pAC->Index]);
 		    IsLinkSpeedDefined = SK_FALSE;
 		}
 	} else {
@@ -3913,9 +4105,9 @@ int	Capabilities[3][3] =
 	if (((!pAC->ChipsetType) || (pAC->GIni.GICopperType != SK_TRUE)) &&
 		((LinkSpeed != SK_LSPEED_AUTO) &&
 		(LinkSpeed != SK_LSPEED_1000MBPS))) {
-		printk("%s: Illegal value for Speed_A. "
+		printk("sk98lin: Illegal value for Speed_A. "
 			"Not a copper card or GE V2 card\n    Using "
-			"speed 1000\n", pAC->dev[0]->name);
+			"speed 1000\n");
 		LinkSpeed = SK_LSPEED_1000MBPS;
 	}
 	
@@ -3945,8 +4137,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(AutoNeg_A[pAC->Index],"Sense")==0) {
 		    AutoNeg = AN_SENS;
 		} else {
-		    printk("%s: Illegal value \"%s\" for AutoNeg_A\n",
-			pAC->dev[0]->name, AutoNeg_A[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for AutoNeg_A\n",
+			AutoNeg_A[pAC->Index]);
 		}
 	}
 
@@ -3964,33 +4156,32 @@ int	Capabilities[3][3] =
 		} else if (strcmp(DupCap_A[pAC->Index],"Half")==0) {
 		    DuplexCap = DC_HALF;
 		} else {
-		    printk("%s: Illegal value \"%s\" for DupCap_A\n",
-			pAC->dev[0]->name, DupCap_A[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for DupCap_A\n",
+			DupCap_A[pAC->Index]);
 		}
 	}
-	
+
 	/* 
 	** Check for illegal combinations 
 	*/
-	if ((LinkSpeed = SK_LSPEED_1000MBPS) &&
+	if ((LinkSpeed == SK_LSPEED_1000MBPS) &&
 		((DuplexCap == SK_LMODE_STAT_AUTOHALF) ||
 		(DuplexCap == SK_LMODE_STAT_HALF)) &&
 		(pAC->ChipsetType)) {
-		    printk("%s: Half Duplex not possible with Gigabit speed!\n"
-					"    Using Full Duplex.\n",
-				pAC->dev[0]->name);
+		    printk("sk98lin: Half Duplex not possible with Gigabit speed!\n"
+					"    Using Full Duplex.\n");
 				DuplexCap = DC_FULL;
 	}
 
 	if ( AutoSet && AutoNeg==AN_SENS && DupSet) {
-		printk("%s, Port A: DuplexCapabilities"
-			" ignored using Sense mode\n", pAC->dev[0]->name);
+		printk("sk98lin, Port A: DuplexCapabilities"
+			" ignored using Sense mode\n");
 	}
 
 	if (AutoSet && AutoNeg==AN_OFF && DupSet && DuplexCap==DC_BOTH){
-		printk("%s, Port A: Illegal combination"
+		printk("sk98lin: Port A: Illegal combination"
 			" of values AutoNeg. and DuplexCap.\n    Using "
-			"Full Duplex\n", pAC->dev[0]->name);
+			"Full Duplex\n");
 		DuplexCap = DC_FULL;
 	}
 
@@ -3999,10 +4190,9 @@ int	Capabilities[3][3] =
 	}
 	
 	if (!AutoSet && DupSet) {
-		printk("%s, Port A: Duplex setting not"
+		printk("sk98lin: Port A: Duplex setting not"
 			" possible in\n    default AutoNegotiation mode"
-			" (Sense).\n    Using AutoNegotiation On\n",
-			pAC->dev[0]->name);
+			" (Sense).\n    Using AutoNegotiation On\n");
 		AutoNeg = AN_ON;
 	}
 	
@@ -4029,8 +4219,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(FlowCtrl_A[pAC->Index],"None")==0) {
 		    FlowCtrl = SK_FLOW_MODE_NONE;
 		} else {
-		    printk("%s: Illegal value \"%s\" for FlowCtrl_A\n",
-                        pAC->dev[0]->name, FlowCtrl_A[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for FlowCtrl_A\n",
+                        FlowCtrl_A[pAC->Index]);
 		    IsFlowCtrlDefined = SK_FALSE;
 		}
 	} else {
@@ -4039,9 +4229,9 @@ int	Capabilities[3][3] =
 
 	if (IsFlowCtrlDefined) {
 	    if ((AutoNeg == AN_OFF) && (FlowCtrl != SK_FLOW_MODE_NONE)) {
-		printk("%s, Port A: FlowControl"
+		printk("sk98lin: Port A: FlowControl"
 			" impossible without AutoNegotiation,"
-			" disabled\n", pAC->dev[0]->name);
+			" disabled\n");
 		FlowCtrl = SK_FLOW_MODE_NONE;
 	    }
 	    pAC->GIni.GP[0].PFlowCtrlMode = FlowCtrl;
@@ -4061,8 +4251,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(Role_A[pAC->Index],"Slave")==0) {
 		    MSMode = SK_MS_MODE_SLAVE;
 		} else {
-		    printk("%s: Illegal value \"%s\" for Role_A\n",
-			pAC->dev[0]->name, Role_A[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for Role_A\n",
+			Role_A[pAC->Index]);
 		    IsRoleDefined = SK_FALSE;
 		}
 	} else {
@@ -4097,8 +4287,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(Speed_B[pAC->Index],"1000")==0) {
 		    LinkSpeed = SK_LSPEED_1000MBPS;
 		} else {
-		    printk("%s: Illegal value \"%s\" for Speed_B\n",
-			pAC->dev[1]->name, Speed_B[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for Speed_B\n",
+			Speed_B[pAC->Index]);
 		    IsLinkSpeedDefined = SK_FALSE;
 		}
 	} else {
@@ -4112,9 +4302,9 @@ int	Capabilities[3][3] =
 	if (((!pAC->ChipsetType) || (pAC->GIni.GICopperType != SK_TRUE)) &&
 		((LinkSpeed != SK_LSPEED_AUTO) &&
 		(LinkSpeed != SK_LSPEED_1000MBPS))) {
-		printk("%s: Illegal value for Speed_B. "
+		printk("sk98lin: Illegal value for Speed_B. "
 			"Not a copper card or GE V2 card\n    Using "
-			"speed 1000\n", pAC->dev[1]->name);
+			"speed 1000\n");
 		LinkSpeed = SK_LSPEED_1000MBPS;
 	}
 
@@ -4144,8 +4334,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(AutoNeg_B[pAC->Index],"Sense")==0) {
 		    AutoNeg = AN_SENS;
 		} else {
-		    printk("%s: Illegal value \"%s\" for AutoNeg_B\n",
-			pAC->dev[0]->name, AutoNeg_B[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for AutoNeg_B\n",
+			AutoNeg_B[pAC->Index]);
 		}
 	}
 
@@ -4163,8 +4353,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(DupCap_B[pAC->Index],"Half")==0) {
 		    DuplexCap = DC_HALF;
 		} else {
-		    printk("%s: Illegal value \"%s\" for DupCap_B\n",
-			pAC->dev[0]->name, DupCap_B[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for DupCap_B\n",
+			DupCap_B[pAC->Index]);
 		}
 	}
 
@@ -4172,25 +4362,24 @@ int	Capabilities[3][3] =
 	/* 
 	** Check for illegal combinations 
 	*/
-	if ((LinkSpeed = SK_LSPEED_1000MBPS) &&
+	if ((LinkSpeed == SK_LSPEED_1000MBPS) &&
 		((DuplexCap == SK_LMODE_STAT_AUTOHALF) ||
 		(DuplexCap == SK_LMODE_STAT_HALF)) &&
 		(pAC->ChipsetType)) {
-		    printk("%s: Half Duplex not possible with Gigabit speed!\n"
-					"    Using Full Duplex.\n",
-				pAC->dev[1]->name);
+		    printk("sk98lin: Half Duplex not possible with Gigabit speed!\n"
+					"    Using Full Duplex.\n");
 				DuplexCap = DC_FULL;
 	}
 
 	if (AutoSet && AutoNeg==AN_SENS && DupSet) {
-		printk("%s, Port B: DuplexCapabilities"
-			" ignored using Sense mode\n", pAC->dev[1]->name);
+		printk("sk98lin, Port B: DuplexCapabilities"
+			" ignored using Sense mode\n");
 	}
 
 	if (AutoSet && AutoNeg==AN_OFF && DupSet && DuplexCap==DC_BOTH){
-		printk("%s, Port B: Illegal combination"
+		printk("sk98lin: Port B: Illegal combination"
 			" of values AutoNeg. and DuplexCap.\n    Using "
-			"Full Duplex\n", pAC->dev[1]->name);
+			"Full Duplex\n");
 		DuplexCap = DC_FULL;
 	}
 
@@ -4199,10 +4388,9 @@ int	Capabilities[3][3] =
 	}
 	
 	if (!AutoSet && DupSet) {
-		printk("%s, Port B: Duplex setting not"
+		printk("sk98lin: Port B: Duplex setting not"
 			" possible in\n    default AutoNegotiation mode"
-			" (Sense).\n    Using AutoNegotiation On\n",
-			pAC->dev[1]->name);
+			" (Sense).\n    Using AutoNegotiation On\n");
 		AutoNeg = AN_ON;
 	}
 
@@ -4229,8 +4417,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(FlowCtrl_B[pAC->Index],"None")==0) {
 		    FlowCtrl = SK_FLOW_MODE_NONE;
 		} else {
-		    printk("%s: Illegal value \"%s\" for FlowCtrl_B\n",
-			pAC->dev[0]->name, FlowCtrl_B[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for FlowCtrl_B\n",
+			FlowCtrl_B[pAC->Index]);
 		    IsFlowCtrlDefined = SK_FALSE;
 		}
 	} else {
@@ -4239,9 +4427,9 @@ int	Capabilities[3][3] =
 
 	if (IsFlowCtrlDefined) {
 	    if ((AutoNeg == AN_OFF) && (FlowCtrl != SK_FLOW_MODE_NONE)) {
-		printk("%s, Port B: FlowControl"
+		printk("sk98lin: Port B: FlowControl"
 			" impossible without AutoNegotiation,"
-			" disabled\n", pAC->dev[1]->name);
+			" disabled\n");
 		FlowCtrl = SK_FLOW_MODE_NONE;
 	    }
 	    pAC->GIni.GP[1].PFlowCtrlMode = FlowCtrl;
@@ -4261,8 +4449,8 @@ int	Capabilities[3][3] =
 		} else if (strcmp(Role_B[pAC->Index],"Slave")==0) {
 		    MSMode = SK_MS_MODE_SLAVE;
 		} else {
-		    printk("%s: Illegal value \"%s\" for Role_B\n",
-			pAC->dev[1]->name, Role_B[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for Role_B\n",
+			Role_B[pAC->Index]);
 		    IsRoleDefined = SK_FALSE;
 		}
 	} else {
@@ -4280,28 +4468,37 @@ int	Capabilities[3][3] =
 	if (PrefPort != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		PrefPort[pAC->Index] != NULL) {
 		if (strcmp(PrefPort[pAC->Index],"") == 0) { /* Auto */
-		    pAC->ActivePort             =  0;
-		    pAC->Rlmt.Net[0].Preference = -1; /* auto */
-		    pAC->Rlmt.Net[0].PrefPort   =  0;
+			pAC->ActivePort             =  0;
+			pAC->Rlmt.Net[0].Preference = -1; /* auto */
+			pAC->Rlmt.Net[0].PrefPort   =  0;
 		} else if (strcmp(PrefPort[pAC->Index],"A") == 0) {
-		    /*
-		    ** do not set ActivePort here, thus a port
-		    ** switch is issued after net up.
-		    */
-		    Port                        = 0;
-		    pAC->Rlmt.Net[0].Preference = Port;
-		    pAC->Rlmt.Net[0].PrefPort   = Port;
+			/*
+			** do not set ActivePort here, thus a port
+			** switch is issued after net up.
+			*/
+			Port                        = 0;
+			pAC->Rlmt.Net[0].Preference = Port;
+			pAC->Rlmt.Net[0].PrefPort   = Port;
 		} else if (strcmp(PrefPort[pAC->Index],"B") == 0) {
-		    /*
-		    ** do not set ActivePort here, thus a port
-		    ** switch is issued after net up.
-		    */
-		    Port                        = 1;
-		    pAC->Rlmt.Net[0].Preference = Port;
-		    pAC->Rlmt.Net[0].PrefPort   = Port;
+			/*
+			** do not set ActivePort here, thus a port
+			** switch is issued after net up.
+			*/
+			if (pAC->GIni.GIMacsFound == 1) {
+				printk("sk98lin: Illegal value \"B\" for PrefPort.\n"
+					"      Port B not available on single port adapters.\n");
+
+				pAC->ActivePort             =  0;
+				pAC->Rlmt.Net[0].Preference = -1; /* auto */
+				pAC->Rlmt.Net[0].PrefPort   =  0;
+			} else {
+				Port                        = 1;
+				pAC->Rlmt.Net[0].Preference = Port;
+				pAC->Rlmt.Net[0].PrefPort   = Port;
+			}
 		} else {
-		    printk("%s: Illegal value \"%s\" for PrefPort\n",
-			pAC->dev[0]->name, PrefPort[pAC->Index]);
+		    printk("sk98lin: Illegal value \"%s\" for PrefPort\n",
+			PrefPort[pAC->Index]);
 		}
 	}
 
@@ -4325,9 +4522,9 @@ int	Capabilities[3][3] =
 			pAC->RlmtMode = SK_RLMT_CHECK_LINK;
 			pAC->RlmtNets = 2;
 		} else {
-		    printk("%s: Illegal value \"%s\" for"
+		    printk("sk98lin: Illegal value \"%s\" for"
 			" RlmtMode, using default\n", 
-			pAC->dev[0]->name, RlmtMode[pAC->Index]);
+			RlmtMode[pAC->Index]);
 			pAC->RlmtMode = 0;
 		}
 	} else {
@@ -4338,97 +4535,111 @@ int	Capabilities[3][3] =
 	** Check the interrupt moderation parameters
 	*/
 	if (Moderation[pAC->Index] != NULL) {
-	    if (strcmp(Moderation[pAC->Index], "Static") == 0) {
-                pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_STATIC;
-	    } else if (strcmp(Moderation[pAC->Index], "Dynamic") == 0) {
-	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_DYNAMIC;
-	    } else {
-	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
-	    }
+		if (strcmp(Moderation[pAC->Index], "") == 0) {
+			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+		} else if (strcmp(Moderation[pAC->Index], "Static") == 0) {
+			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_STATIC;
+		} else if (strcmp(Moderation[pAC->Index], "Dynamic") == 0) {
+			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_DYNAMIC;
+		} else if (strcmp(Moderation[pAC->Index], "None") == 0) {
+			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+		} else {
+	   		printk("sk98lin: Illegal value \"%s\" for Moderation.\n"
+				"      Disable interrupt moderation.\n",
+				Moderation[pAC->Index]);
+			pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+		}
 	} else {
-	    pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+		pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
 	}
 
 	if (Stats[pAC->Index] != NULL) {
-	    if (strcmp(Stats[pAC->Index], "Yes") == 0) {
-	        pAC->DynIrqModInfo.DisplayStats = SK_TRUE;
-	    } else {
-		pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
-	    }
+		if (strcmp(Stats[pAC->Index], "Yes") == 0) {
+			pAC->DynIrqModInfo.DisplayStats = SK_TRUE;
+		} else {
+			pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+		}
 	} else {
-	    pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+		pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
 	}
 
-        if (ModerationMask[pAC->Index] != NULL) {
-           if (strcmp(ModerationMask[pAC->Index], "Rx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
-           } else if (strcmp(ModerationMask[pAC->Index], "Tx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_ONLY;
-           } else if (strcmp(ModerationMask[pAC->Index], "Sp") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_ONLY;
-           } else if (strcmp(ModerationMask[pAC->Index], "RxSp") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
-           } else if (strcmp(ModerationMask[pAC->Index], "SpRx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
-           } else if (strcmp(ModerationMask[pAC->Index], "RxTx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
-           } else if (strcmp(ModerationMask[pAC->Index], "TxRx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
-           } else if (strcmp(ModerationMask[pAC->Index], "TxSp") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
-           } else if (strcmp(ModerationMask[pAC->Index], "SpTx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
-           } else if (strcmp(ModerationMask[pAC->Index], "RxTxSp") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else if (strcmp(ModerationMask[pAC->Index], "RxSpTx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else if (strcmp(ModerationMask[pAC->Index], "TxRxSp") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else if (strcmp(ModerationMask[pAC->Index], "TxSpRx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else if (strcmp(ModerationMask[pAC->Index], "SpTxRx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else if (strcmp(ModerationMask[pAC->Index], "SpRxTx") == 0) {
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
-           } else { /* some rubbish */
-               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
-           }
-        } else {  /* operator has stated nothing */
-           pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
-        }
-
-        if (AutoSizing[pAC->Index] != NULL) {
-           if (strcmp(AutoSizing[pAC->Index], "On") == 0) {
-               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
-           } else {
-               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
-           }
-        } else {  /* operator has stated nothing */
-           pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
-        }
+	if (ModerationMask[pAC->Index] != NULL) {
+		if (strcmp(ModerationMask[pAC->Index], "Rx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+		} else if (strcmp(ModerationMask[pAC->Index], "Tx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_ONLY;
+		} else if (strcmp(ModerationMask[pAC->Index], "Sp") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_ONLY;
+		} else if (strcmp(ModerationMask[pAC->Index], "RxSp") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+		} else if (strcmp(ModerationMask[pAC->Index], "SpRx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+		} else if (strcmp(ModerationMask[pAC->Index], "RxTx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+		} else if (strcmp(ModerationMask[pAC->Index], "TxRx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+		} else if (strcmp(ModerationMask[pAC->Index], "TxSp") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+		} else if (strcmp(ModerationMask[pAC->Index], "SpTx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+		} else if (strcmp(ModerationMask[pAC->Index], "RxTxSp") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else if (strcmp(ModerationMask[pAC->Index], "RxSpTx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else if (strcmp(ModerationMask[pAC->Index], "TxRxSp") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else if (strcmp(ModerationMask[pAC->Index], "TxSpRx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else if (strcmp(ModerationMask[pAC->Index], "SpTxRx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else if (strcmp(ModerationMask[pAC->Index], "SpRxTx") == 0) {
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+		} else { /* some rubbish */
+			pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+		}
+	} else {  /* operator has stated nothing */
+		pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+	}
+
+	if (AutoSizing[pAC->Index] != NULL) {
+		if (strcmp(AutoSizing[pAC->Index], "On") == 0) {
+			pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+		} else {
+			pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+		}
+	} else {  /* operator has stated nothing */
+		pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+	}
 
-        if (IntsPerSec[pAC->Index] != 0) {
-           if ((IntsPerSec[pAC->Index]< 30) || (IntsPerSec[pAC->Index]> 40000)) {
-              pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
-           } else {
-              pAC->DynIrqModInfo.MaxModIntsPerSec = IntsPerSec[pAC->Index];
-           }
-        } else {
-           pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
-        }
+	if (IntsPerSec[pAC->Index] != 0) {
+		if ((IntsPerSec[pAC->Index]< C_INT_MOD_IPS_LOWER_RANGE) || 
+			(IntsPerSec[pAC->Index] > C_INT_MOD_IPS_UPPER_RANGE)) {
+	   		printk("sk98lin: Illegal value \"%d\" for IntsPerSec. (Range: %d - %d)\n"
+				"      Using default value of %i.\n", 
+				IntsPerSec[pAC->Index],
+				C_INT_MOD_IPS_LOWER_RANGE,
+				C_INT_MOD_IPS_UPPER_RANGE,
+				C_INTS_PER_SEC_DEFAULT);
+			pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+		} else {
+			pAC->DynIrqModInfo.MaxModIntsPerSec = IntsPerSec[pAC->Index];
+		}
+	} else {
+		pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+	}
 
-        /*
+	/*
 	** Evaluate upper and lower moderation threshold
 	*/
-        pAC->DynIrqModInfo.MaxModIntsPerSecUpperLimit =
-            pAC->DynIrqModInfo.MaxModIntsPerSec +
-            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
-
-        pAC->DynIrqModInfo.MaxModIntsPerSecLowerLimit =
-            pAC->DynIrqModInfo.MaxModIntsPerSec -
-            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+	pAC->DynIrqModInfo.MaxModIntsPerSecUpperLimit =
+		pAC->DynIrqModInfo.MaxModIntsPerSec +
+		(pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+
+	pAC->DynIrqModInfo.MaxModIntsPerSecLowerLimit =
+		pAC->DynIrqModInfo.MaxModIntsPerSec -
+		(pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
 
-        pAC->DynIrqModInfo.PrevTimeVal = jiffies;  /* initial value */
+	pAC->DynIrqModInfo.PrevTimeVal = jiffies;  /* initial value */
 
 
 } /* GetConfiguration */
@@ -4826,6 +5037,10 @@ SK_BOOL		DualNet;
 		FromPort = Param.Para32[0];
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_EVENT,
 			("NET UP EVENT, Port: %d ", Param.Para32[0]));
+		/* Mac update */
+		SkAddrMcUpdate(pAC,IoC, FromPort);
+
+		if (DoPrintInterfaceChange) {
 		printk("%s: network connection up using"
 			" port %c\n", pAC->dev[Param.Para32[0]]->name, 'A'+Param.Para32[0]);
 
@@ -4841,8 +5056,6 @@ SK_BOOL		DualNet;
 			printk("    speed:           unknown\n");
 		}
 
-		/* Mac update */
-		SkAddrMcUpdate(pAC,IoC, FromPort);
 
 		Stat = pAC->GIni.GP[FromPort].PLinkModeStatus;
 		if (Stat == SK_LMODE_STAT_AUTOHALF ||
@@ -4920,6 +5133,9 @@ SK_BOOL		DualNet;
 			printk("    rx-checksum:     disabled\n");
 #endif
 
+		} else {
+                        DoPrintInterfaceChange = SK_TRUE;
+                }
 	
 		if ((Param.Para32[0] != pAC->ActivePort) &&
 			(pAC->RlmtNets == 1)) {
@@ -4937,7 +5153,12 @@ SK_BOOL		DualNet;
 		/* action list 7 */
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_EVENT,
 			("NET DOWN EVENT "));
-		printk("%s: network connection down\n", pAC->dev[Param.Para32[1]]->name);
+		if (DoPrintInterfaceChange) {
+			printk("%s: network connection down\n", 
+				pAC->dev[Param.Para32[1]]->name);
+		} else {
+			DoPrintInterfaceChange = SK_TRUE;
+		}
 		pAC->dev[Param.Para32[1]]->flags &= ~IFF_RUNNING;
 		break;
 	case SK_DRV_SWITCH_HARD: /* SK_U32 FromPortIdx SK_U32 ToPortIdx */
@@ -5122,6 +5343,231 @@ char	ClassStr[80];
 
 } /* SkErrorLog */
 
+#ifdef SK_DIAG_SUPPORT
+
+/*****************************************************************************
+ *
+ *	SkDrvEnterDiagMode - handles DIAG attach request
+ *
+ * Description:
+ *	Notify the kernel to NOT access the card any longer due to DIAG
+ *	Deinitialize the Card
+ *
+ * Returns:
+ *	int
+ */
+int SkDrvEnterDiagMode(
+SK_AC   *pAc)   /* pointer to adapter context */
+{
+	SK_AC   *pAC  = NULL;
+	DEV_NET *pNet = NULL;
+
+	pNet = (DEV_NET *) pAc->dev[0]->priv;
+	pAC = pNet->pAC;
+
+	SK_MEMCPY(&(pAc->PnmiBackup), &(pAc->PnmiStruct), 
+			sizeof(SK_PNMI_STRUCT_DATA));
+
+	pAC->DiagModeActive = DIAG_ACTIVE;
+	if (pAC->BoardLevel > SK_INIT_DATA) {
+		if (pNet->Up) {
+			pAC->WasIfUp[0] = SK_TRUE;
+			pAC->DiagFlowCtrl = SK_TRUE; /* for SkGeClose      */
+			DoPrintInterfaceChange = SK_FALSE;
+			SkDrvDeInitAdapter(pAC, 0);  /* performs SkGeClose */
+		} else {
+			pAC->WasIfUp[0] = SK_FALSE;
+		}
+		if (pNet != (DEV_NET *) pAc->dev[1]->priv) {
+			pNet = (DEV_NET *) pAc->dev[1]->priv;
+			if (pNet->Up) {
+				pAC->WasIfUp[1] = SK_TRUE;
+				pAC->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
+				DoPrintInterfaceChange = SK_FALSE;
+				SkDrvDeInitAdapter(pAC, 1);  /* do SkGeClose  */
+			} else {
+				pAC->WasIfUp[1] = SK_FALSE;
+			}
+		}
+		pAC->BoardLevel = SK_INIT_DATA;
+	}
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *	SkDrvLeaveDiagMode - handles DIAG detach request
+ *
+ * Description:
+ *	Notify the kernel to may access the card again after use by DIAG
+ *	Initialize the Card
+ *
+ * Returns:
+ * 	int
+ */
+int SkDrvLeaveDiagMode(
+SK_AC   *pAc)   /* pointer to adapter control context */
+{ 
+	SK_MEMCPY(&(pAc->PnmiStruct), &(pAc->PnmiBackup), 
+			sizeof(SK_PNMI_STRUCT_DATA));
+	pAc->DiagModeActive    = DIAG_NOTACTIVE;
+	pAc->Pnmi.DiagAttached = SK_DIAG_IDLE;
+        if (pAc->WasIfUp[0] == SK_TRUE) {
+                pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
+		DoPrintInterfaceChange = SK_FALSE;
+                SkDrvInitAdapter(pAc, 0);    /* first device  */
+        }
+        if (pAc->WasIfUp[1] == SK_TRUE) {
+                pAc->DiagFlowCtrl = SK_TRUE; /* for SkGeClose */
+		DoPrintInterfaceChange = SK_FALSE;
+                SkDrvInitAdapter(pAc, 1);    /* second device */
+        }
+	return(0);
+}
+
+/*****************************************************************************
+ *
+ *	ParseDeviceNbrFromSlotName - Evaluate PCI device number
+ *
+ * Description:
+ * 	This function parses the PCI slot name information string and will
+ *	retrieve the devcie number out of it. The slot_name maintianed by
+ *	linux is in the form of '02:0a.0', whereas the first two characters 
+ *	represent the bus number in hex (in the sample above this is 
+ *	pci bus 0x02) and the next two characters the device number (0x0a).
+ *
+ * Returns:
+ *	SK_U32: The device number from the PCI slot name
+ */ 
+
+static SK_U32 ParseDeviceNbrFromSlotName(
+const char *SlotName)   /* pointer to pci slot name eg. '02:0a.0' */
+{
+	char	*CurrCharPos	= (char *) SlotName;
+	int	FirstNibble	= -1;
+	int	SecondNibble	= -1;
+	SK_U32	Result		=  0;
+
+	while (*CurrCharPos != '\0') {
+		if (*CurrCharPos == ':') { 
+			while (*CurrCharPos != '.') {
+				CurrCharPos++;  
+				if (	(*CurrCharPos >= '0') && 
+					(*CurrCharPos <= '9')) {
+					if (FirstNibble == -1) {
+						/* dec. value for '0' */
+						FirstNibble = *CurrCharPos - 48;
+					} else {
+						SecondNibble = *CurrCharPos - 48;
+					}  
+				} else if (	(*CurrCharPos >= 'a') && 
+						(*CurrCharPos <= 'f')  ) {
+					if (FirstNibble == -1) {
+						FirstNibble = *CurrCharPos - 87; 
+					} else {
+						SecondNibble = *CurrCharPos - 87; 
+					}
+				} else {
+					Result = 0;
+				}
+			}
+
+			Result = FirstNibble;
+			Result = Result << 4; /* first nibble is higher one */
+			Result = Result | SecondNibble;
+		}
+		CurrCharPos++;   /* next character */
+	}
+	return (Result);
+}
+
+/****************************************************************************
+ *
+ *	SkDrvDeInitAdapter - deinitialize adapter (this function is only 
+ *				called if Diag attaches to that card)
+ *
+ * Description:
+ *	Close initialized adapter.
+ *
+ * Returns:
+ *	0 - on success
+ *	error code - on error
+ */
+static int SkDrvDeInitAdapter(
+SK_AC   *pAC,		/* pointer to adapter context   */
+int      devNbr)	/* what device is to be handled */
+{
+	struct SK_NET_DEVICE *dev;
+
+	dev = pAC->dev[devNbr];
+
+	/*
+	** Function SkGeClose() uses MOD_DEC_USE_COUNT (2.2/2.4)
+	** or module_put() (2.6) to decrease the number of users for
+	** a device, but if a device is to be put under control of 
+	** the DIAG, that count is OK already and does not need to 
+	** be adapted! Hence the opposite MOD_INC_USE_COUNT or 
+	** try_module_get() needs to be used again to correct that.
+	*/
+	if (!try_module_get(THIS_MODULE)) {
+		return (-1);
+	}
+
+	if (SkGeClose(dev) != 0) {
+		module_put(THIS_MODULE);
+		return (-1);
+	}
+	return (0);
+
+} /* SkDrvDeInitAdapter() */
+
+/****************************************************************************
+ *
+ *	SkDrvInitAdapter - Initialize adapter (this function is only 
+ *				called if Diag deattaches from that card)
+ *
+ * Description:
+ *	Close initialized adapter.
+ *
+ * Returns:
+ *	0 - on success
+ *	error code - on error
+ */
+static int SkDrvInitAdapter(
+SK_AC   *pAC,		/* pointer to adapter context   */
+int      devNbr)	/* what device is to be handled */
+{
+	struct SK_NET_DEVICE *dev;
+
+	dev = pAC->dev[devNbr];
+
+	if (SkGeOpen(dev) != 0) {
+		return (-1);
+	} else {
+		/*
+		** Function SkGeOpen() uses MOD_INC_USE_COUNT (2.2/2.4) 
+		** or try_module_get() (2.6) to increase the number of 
+		** users for a device, but if a device was just under 
+		** control of the DIAG, that count is OK already and 
+		** does not need to be adapted! Hence the opposite 
+		** MOD_DEC_USE_COUNT or module_put() needs to be used 
+		** again to correct that.
+		*/
+		module_put(THIS_MODULE);
+	}
+
+	/*
+	** Use correct MTU size and indicate to kernel TX queue can be started
+	*/ 
+	if (SkGeChangeMtu(dev, dev->mtu) != 0) {
+		return (-1);
+	} 
+	return (0);
+
+} /* SkDrvInitAdapter */
+
+#endif
+
 #ifdef DEBUG
 /****************************************************************************/
 /* "debug only" section *****************************************************/
diff -purN linux-2.6.1/drivers/net/sk98lin/skgehwt.c linux-2.5/drivers/net/sk98lin/skgehwt.c
--- linux-2.6.1/drivers/net/sk98lin/skgehwt.c	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skgehwt.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,10 +1,10 @@
 /******************************************************************************
  *
  * Name:	skgehwt.c
- * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 2003/05/13 18:01:58 $
- * Purpose:	Hardware Timer.
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.15 $
+ * Date:	$Date: 2003/09/16 13:41:23 $
+ * Purpose:	Hardware Timer
  *
  ******************************************************************************/
 
@@ -27,6 +27,10 @@
  * History:
  *
  *	$Log: skgehwt.c,v $
+ *	Revision 1.15  2003/09/16 13:41:23  rschmidt
+ *	Added (C) Marvell to SysKonnectFileId
+ *	Editorial changes
+ *	
  *	Revision 1.14  2003/05/13 18:01:58  mkarl
  *	Editorial changes.
  *	
@@ -69,19 +73,15 @@
  *	
  *	Revision 1.1  1998/08/05 11:28:36  gklug
  *	first version: adapted from SMT/FDDI
- *	
- *	
- *	
  *
  ******************************************************************************/
 
-
 /*
-	Event queue and dispatcher
-*/
+ *	Event queue and dispatcher
+ */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.14 2003/05/13 18:01:58 mkarl Exp $" ;
+	"@(#) $Id: skgehwt.c,v 1.15 2003/09/16 13:41:23 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
@@ -89,10 +89,7 @@ static const char SysKonnectFileId[] =
 
 #ifdef __C2MAN__
 /*
-	Hardware Timer function queue management.
-
-	General Description:
-
+ *   Hardware Timer function queue management.
  */
 intro()
 {}
@@ -117,9 +114,9 @@ SK_IOC	Ioc)	/* IoContext */
 {
 	pAC->Hwt.TStart = 0 ;
 	pAC->Hwt.TStop	= 0 ;
-	pAC->Hwt.TActive = SK_FALSE ;
+	pAC->Hwt.TActive = SK_FALSE;
 
-	SkHwtStop(pAC,Ioc) ;
+	SkHwtStop(pAC, Ioc);
 }
 
 /*
@@ -132,28 +129,29 @@ SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc,	/* IoContext */
 SK_U32	Time)	/* Time in units of 16us to load the timer with. */
 {
-	SK_U32	Cnt ;
+	SK_U32	Cnt;
 
 	if (Time > SK_HWT_MAX)
-		Time = SK_HWT_MAX ;
+		Time = SK_HWT_MAX;
 
-	pAC->Hwt.TStart = Time ;
-	pAC->Hwt.TStop = 0L ;
+	pAC->Hwt.TStart = Time;
+	pAC->Hwt.TStop = 0L;
 
-	Cnt = Time ;
+	Cnt = Time;
 
 	/*
 	 * if time < 16 us
 	 *	time = 16 us
 	 */
 	if (!Cnt) {
-		Cnt++ ;
+		Cnt++;
 	}
 
-	SK_OUT32(Ioc, B2_TI_INI, Cnt * SK_HWT_FAC) ;
-	SK_OUT16(Ioc, B2_TI_CRTL, TIM_START) ;	/* Start timer. */
+	SK_OUT32(Ioc, B2_TI_INI, Cnt * SK_HWT_FAC);
+	
+	SK_OUT16(Ioc, B2_TI_CTRL, TIM_START);	/* Start timer. */
 
-	pAC->Hwt.TActive = SK_TRUE ;
+	pAC->Hwt.TActive = SK_TRUE;
 }
 
 /*
@@ -164,10 +162,11 @@ void	SkHwtStop(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
-	SK_OUT16(Ioc, B2_TI_CRTL, TIM_STOP) ;
-	SK_OUT16(Ioc, B2_TI_CRTL, TIM_CLR_IRQ) ;
+	SK_OUT16(Ioc, B2_TI_CTRL, TIM_STOP);
+	
+	SK_OUT16(Ioc, B2_TI_CTRL, TIM_CLR_IRQ);
 
-	pAC->Hwt.TActive = SK_FALSE ;
+	pAC->Hwt.TActive = SK_FALSE;
 }
 
 
@@ -182,26 +181,31 @@ SK_U32	SkHwtRead(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
-	SK_U32	TRead ;
-	SK_U32	IStatus ;
+	SK_U32	TRead;
+	SK_U32	IStatus;
 
 	if (pAC->Hwt.TActive) {
-		SkHwtStop(pAC,Ioc) ;
+		
+		SkHwtStop(pAC, Ioc);
 
 		SK_IN32(Ioc, B2_TI_VAL, &TRead);
 		TRead /= SK_HWT_FAC;
 
 		SK_IN32(Ioc, B0_ISRC, &IStatus);
 
-		/* Check if timer expired (or wraparound). */
+		/* Check if timer expired (or wraped around) */
 		if ((TRead > pAC->Hwt.TStart) || (IStatus & IS_TIMINT)) {
-			SkHwtStop(pAC,Ioc) ;
-			pAC->Hwt.TStop = pAC->Hwt.TStart ;
-		} else {
-			pAC->Hwt.TStop = pAC->Hwt.TStart - TRead ;
+			
+			SkHwtStop(pAC, Ioc);
+			
+			pAC->Hwt.TStop = pAC->Hwt.TStart;
+		}
+		else {
+			
+			pAC->Hwt.TStop = pAC->Hwt.TStart - TRead;
 		}
 	}
-	return (pAC->Hwt.TStop) ;
+	return(pAC->Hwt.TStop);
 }
 
 /*
@@ -211,9 +215,11 @@ void	SkHwtIsr(
 SK_AC	*pAC,	/* Adapters context */
 SK_IOC	Ioc)	/* IoContext */
 {
-	SkHwtStop(pAC,Ioc);
+	SkHwtStop(pAC, Ioc);
+	
 	pAC->Hwt.TStop = pAC->Hwt.TStart;
-	SkTimerDone(pAC,Ioc) ;
+	
+	SkTimerDone(pAC, Ioc);
 }
 
 /* End of file */
diff -purN linux-2.6.1/drivers/net/sk98lin/skgeinit.c linux-2.5/drivers/net/sk98lin/skgeinit.c
--- linux-2.6.1/drivers/net/sk98lin/skgeinit.c	2004-01-09 06:59:42.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skgeinit.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgeinit.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.93 $
- * Date:	$Date: 2003/05/28 15:44:43 $
+ * Version:	$Revision: 1.97 $
+ * Date:	$Date: 2003/10/02 16:45:31 $
  * Purpose:	Contains functions to initialize the adapter
  *
  ******************************************************************************/
@@ -27,6 +27,32 @@
  * History:
  *
  *	$Log: skgeinit.c,v $
+ *	Revision 1.97  2003/10/02 16:45:31  rschmidt
+ *	Replaced default values of GMAC parameters with defines.
+ *	Removed hard reset of MACs in SkGeDeInit().
+ *	Added define SK_PHY_LP_MODE around power saving mode in SkGeDeInit().
+ *	Added check for VAUX available before switch power to VAUX.
+ *	
+ *	Revision 1.96  2003/09/18 14:02:41  rroesler
+ *	Add: Perform a hardreset of MACs in GeDeInit()
+ *	
+ *	Revision 1.95  2003/09/16 14:26:59  rschmidt
+ *	Added switch power to VCC (WA for VAUX problem) in SkGeInit1().
+ *	Fixed setting PHY to coma mode and D3 power state in SkGeDeInit().
+ *	Editorial changes.
+ *	
+ *	Revision 1.94  2003/09/16 07:17:10  mschmid
+ *	Added init for new members in port structure for MAC control
+ *	- PMacColThres
+ *	- PMacJamLen
+ *	- PMacJamIpgVal
+ *	- PMacJamIpgData
+ *	- PMacIpgData
+ *	- PMacLimit4
+ *	Added init for PHY power state in port structure
+ *	- PPhyPowerState
+ *	Added shutdown handling for Yukon Plus in SkGeDeInit()
+ *	
  *	Revision 1.93  2003/05/28 15:44:43  rschmidt
  *	Added check for chip Id on WOL WA for chip Rev. A.
  *	Added setting of GILevel in SkGeDeInit().
@@ -446,7 +472,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgeinit.c,v 1.93 2003/05/28 15:44:43 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skgeinit.c,v 1.97 2003/10/02 16:45:31 rschmidt Exp $ (C) Marvell.";
 #endif
 
 struct s_QOffTab {
@@ -1013,8 +1039,6 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	 *	- enable the FIFO
 	 */
 	
-	Word = (SK_U16)GMF_RX_CTRL_DEF;
-	
 #ifdef GENESIS
 	if (pAC->GIni.GIGenesis) {
 		/* Configure Rx MAC FIFO */
@@ -1039,6 +1063,8 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* set Rx GMAC FIFO Flush Mask */
 		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_MSK), (SK_U16)RX_FF_FL_DEF_MSK);
 		
+		Word = (SK_U16)GMF_RX_CTRL_DEF;
+
 		/* disable Rx GMAC FIFO Flush for YUKON-Lite Rev. A0 only */
 		if (pAC->GIni.GIYukonLite && pAC->GIni.GIChipId == CHIP_ID_YUKON) {
 
@@ -1809,6 +1835,13 @@ SK_IOC	IoC)		/* IO context */
 		pPrt->PAutoNegFail = SK_FALSE;
 		pPrt->PHWLinkUp = SK_FALSE;
 		pPrt->PLinkBroken = SK_TRUE; /* See WA code */
+		pPrt->PPhyPowerState = PHY_PM_OPERATIONAL_MODE;
+		pPrt->PMacColThres = TX_COL_DEF;
+		pPrt->PMacJamLen = TX_JAM_LEN_DEF;
+		pPrt->PMacJamIpgVal	= TX_JAM_IPG_DEF;
+		pPrt->PMacJamIpgData = TX_IPG_JAM_DEF;
+		pPrt->PMacIpgData = IPG_DATA_DEF;
+		pPrt->PMacLimit4 = SK_FALSE;
 	}
 
 	pAC->GIni.GIPortUsage = SK_RED_LINK;
@@ -1963,7 +1996,7 @@ SK_IOC	IoC)		/* IO context */
 	/* restore CLK_RUN bits */
 	SK_OUT16(IoC, B0_CTST, (SK_U16)(CtrlStat &
 		(CS_CLK_RUN_HOT | CS_CLK_RUN_RST | CS_CLK_RUN_ENA)));
-	
+
 	/* read Chip Identification Number */
 	SK_IN8(IoC, B2_CHIP_ID, &Byte);
 	pAC->GIni.GIChipId = Byte;
@@ -2053,6 +2086,10 @@ SK_IOC	IoC)		/* IO context */
 			}
 		}
 
+		/* switch power to VCC (WA for VAUX problem) */
+		SK_OUT8(IoC, B0_POWER_CTRL, (SK_U8)(PC_VAUX_ENA | PC_VCC_ENA |
+			PC_VAUX_OFF | PC_VCC_ON));
+
 		/* read the Interrupt source */
 		SK_IN32(IoC, B0_ISRC, &DWord);
 		
@@ -2395,6 +2432,11 @@ SK_IOC	IoC)		/* IO context */
 	int	i;
 	SK_U16	Word;
 
+#ifdef SK_PHY_LP_MODE
+	SK_U8	Byte;
+	SK_U16	PmCtlSts;
+#endif /* SK_PHY_LP_MODE */
+
 #if (!defined(SK_SLIM) && !defined(VCPU))
 	/* ensure I2C is ready */
 	SkI2cWaitIrq(pAC, IoC);
@@ -2409,6 +2451,38 @@ SK_IOC	IoC)		/* IO context */
 		}
 	}
 
+#ifdef SK_PHY_LP_MODE
+    /*
+	 * for power saving purposes within mobile environments
+	 * we set the PHY to coma mode and switch to D3 power state.
+	 */
+	if (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+
+		/* for all ports switch PHY to coma mode */
+		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+			
+			SkGmEnterLowPowerMode(pAC, IoC, i, PHY_PM_DEEP_SLEEP);
+		}
+
+		if (pAC->GIni.GIVauxAvail) {
+			/* switch power to VAUX */
+			Byte = PC_VAUX_ENA | PC_VCC_ENA | PC_VAUX_ON | PC_VCC_OFF;
+
+			SK_OUT8(IoC, B0_POWER_CTRL, Byte);
+		}
+		
+		/* switch to D3 state */
+		SK_IN16(IoC, PCI_C(PCI_PM_CTL_STS), &PmCtlSts);
+
+		PmCtlSts |= PCI_PM_STATE_D3;
+
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+
+		SK_OUT16(IoC, PCI_C(PCI_PM_CTL_STS), PmCtlSts);
+	}
+#endif /* SK_PHY_LP_MODE */
+
 	/* Reset all bits in the PCI STATUS register */
 	/*
 	 * Note: PCI Cfg cycles cannot be used, because they are not
diff -purN linux-2.6.1/drivers/net/sk98lin/skgemib.c linux-2.5/drivers/net/sk98lin/skgemib.c
--- linux-2.6.1/drivers/net/sk98lin/skgemib.c	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skgemib.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgemib.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 2003/05/23 12:55:20 $
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/09/15 13:38:12 $
  * Purpose:	Private Network Management Interface Management Database
  *
  ****************************************************************************/
@@ -27,6 +27,19 @@
  * History:
  *
  *	$Log: skgemib.c,v $
+ *	Revision 1.11  2003/09/15 13:38:12  tschilli
+ *	OID_SKGE_PHY_LP_MODE included only after using #define SK_PHY_LP_MODE.
+ *	
+ *	Revision 1.10  2003/08/15 12:28:59  tschilli
+ *	Added new OIDs:
+ *	OID_SKGE_DRIVER_RELDATE
+ *	OID_SKGE_DRIVER_FILENAME
+ *	OID_SKGE_CHIPID
+ *	OID_SKGE_RAMSIZE
+ *	OID_SKGE_VAUXAVAIL
+ *	OID_SKGE_PHY_TYPE
+ *	OID_SKGE_PHY_LP_MODE
+ *	
  *	Revision 1.9  2003/05/23 12:55:20  tschilli
  *	OID_SKGE_BOARDLEVEL added.
  *	
@@ -356,6 +369,16 @@ PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTa
 		0,
 		SK_PNMI_MAI_OFF(DriverVersion),
 		SK_PNMI_RO, General, 0},
+	{OID_SKGE_DRIVER_RELDATE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(DriverReleaseDate),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_DRIVER_FILENAME,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(DriverFileName),
+		SK_PNMI_RO, General, 0},
 	{OID_SKGE_HW_DESCR,
 		1,
 		0,
@@ -371,6 +394,21 @@ PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTa
 		0,
 		SK_PNMI_MAI_OFF(Chipset),
 		SK_PNMI_RO, General, 0},
+	{OID_SKGE_CHIPID,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(ChipId),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RAMSIZE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RamSize),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_VAUXAVAIL,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(VauxAvail),
+		SK_PNMI_RO, General, 0},
 	{OID_SKGE_ACTION,
 		1,
 		0,
@@ -876,6 +914,18 @@ PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTa
 		sizeof(SK_PNMI_CONF),
 		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfConnector),
 		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_PHY_TYPE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyType),
+		SK_PNMI_RO, MacPrivateConf, 0},
+#ifdef SK_PHY_LP_MODE
+		{OID_SKGE_PHY_LP_MODE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyMode),
+		SK_PNMI_RW, MacPrivateConf, 0},
+#endif	
 	{OID_SKGE_LINK_CAP,
 		SK_PNMI_MAC_ENTRIES,
 		sizeof(SK_PNMI_CONF),
diff -purN linux-2.6.1/drivers/net/sk98lin/skgepnmi.c linux-2.5/drivers/net/sk98lin/skgepnmi.c
--- linux-2.6.1/drivers/net/sk98lin/skgepnmi.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skgepnmi.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgepnmi.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.109 $
- * Date:	$Date: 2003/07/17 14:15:24 $
+ * Version:	$Revision: 1.111 $
+ * Date:	$Date: 2003/09/15 13:35:35 $
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
@@ -27,6 +27,22 @@
  * History:
  *
  *	$Log: skgepnmi.c,v $
+ *	Revision 1.111  2003/09/15 13:35:35  tschilli
+ *	Code for OID_SKGE_PHY_LP_MODE completed (using #define SK_PHY_LP_MODE).
+ *	SK_DIAG_ATTACHED handling for OID_SKGE_DIAG_MODE in DiagActions() changed.
+ *	
+ *	Revision 1.110  2003/08/15 12:28:04  tschilli
+ *	Added new OIDs:
+ *	OID_SKGE_DRIVER_RELDATE
+ *	OID_SKGE_DRIVER_FILENAME
+ *	OID_SKGE_CHIPID
+ *	OID_SKGE_RAMSIZE
+ *	OID_SKGE_VAUXAVAIL
+ *	OID_SKGE_PHY_TYPE
+ *	OID_SKGE_PHY_LP_MODE
+ *	
+ *	Added SK_DIAG_ATTACHED handling for OID_SKGE_DIAG_MODE in DiagActions().
+ *	
  *	Revision 1.109  2003/07/17 14:15:24  tschilli
  *	Bug in SkPnmiGenIoctl() fixed.
  *	
@@ -471,7 +487,7 @@
 
 #ifndef _lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgepnmi.c,v 1.109 2003/07/17 14:15:24 tschilli Exp $ (C) Marvell.";
+	"@(#) $Id: skgepnmi.c,v 1.111 2003/09/15 13:35:35 tschilli Exp $ (C) Marvell.";
 #endif /* !_lint */
 
 #include "h/skdrv1st.h"
@@ -4008,14 +4024,6 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 #endif /* SK_NDIS_64BIT_CTR */
 		break;
 
-	case OID_SKGE_BOARDLEVEL:
-		if (*pLen < sizeof(SK_U32)) {
-
-			*pLen = sizeof(SK_U32);
-			return (SK_PNMI_ERR_TOO_SHORT);
-		}
-		break;
-
 	case OID_SKGE_PORT_NUMBER:
 	case OID_SKGE_DEVICE_TYPE:
 	case OID_SKGE_RESULT:
@@ -4023,6 +4031,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	case OID_GEN_TRANSMIT_QUEUE_LENGTH:
 	case OID_SKGE_TRAP_NUMBER:
 	case OID_SKGE_MDB_VERSION:
+	case OID_SKGE_BOARDLEVEL:
+	case OID_SKGE_CHIPID:
+	case OID_SKGE_RAMSIZE:
 		if (*pLen < sizeof(SK_U32)) {
 
 			*pLen = sizeof(SK_U32);
@@ -4043,6 +4054,7 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 	case OID_SKGE_BUS_WIDTH:
 	case OID_SKGE_SENSOR_NUMBER:
 	case OID_SKGE_CHKSM_NUMBER:
+	case OID_SKGE_VAUXAVAIL:
 		if (*pLen < sizeof(SK_U8)) {
 
 			*pLen = sizeof(SK_U8);
@@ -4234,6 +4246,66 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = Len;
 		break;
 
+	case OID_SKGE_DRIVER_RELDATE:
+		if (pAC->Pnmi.pDriverReleaseDate == NULL) {
+
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030,
+				SK_PNMI_ERR053MSG);
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+
+		Len = SK_STRLEN(pAC->Pnmi.pDriverReleaseDate) + 1;
+		if (Len > SK_PNMI_STRINGLEN1) {
+
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031,
+				SK_PNMI_ERR054MSG);
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+
+		if (*pLen < Len) {
+
+			*pLen = Len;
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		*pBuf = (char)(Len - 1);
+		SK_MEMCPY(pBuf + 1, pAC->Pnmi.pDriverReleaseDate, Len - 1);
+		*pLen = Len;
+		break;
+
+	case OID_SKGE_DRIVER_FILENAME:
+		if (pAC->Pnmi.pDriverFileName == NULL) {
+
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR030,
+				SK_PNMI_ERR055MSG);
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+
+		Len = SK_STRLEN(pAC->Pnmi.pDriverFileName) + 1;
+		if (Len > SK_PNMI_STRINGLEN1) {
+
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR031,
+				SK_PNMI_ERR056MSG);
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+
+		if (*pLen < Len) {
+
+			*pLen = Len;
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		*pBuf = (char)(Len - 1);
+		SK_MEMCPY(pBuf + 1, pAC->Pnmi.pDriverFileName, Len - 1);
+		*pLen = Len;
+		break;
+
 	case OID_SKGE_HW_DESCR:
 		/*
 		 * The hardware description is located in the VPD. This
@@ -4291,8 +4363,25 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		*pLen = sizeof(SK_U16);
 		break;
 
+	case OID_SKGE_CHIPID:
+		Val32 = pAC->GIni.GIChipId;
+		SK_PNMI_STORE_U32(pBuf, Val32);
+		*pLen = sizeof(SK_U32);
+		break;
+
+	case OID_SKGE_RAMSIZE:
+		Val32 = pAC->GIni.GIRamSize;
+		SK_PNMI_STORE_U32(pBuf, Val32);
+		*pLen = sizeof(SK_U32);
+		break;
+
+	case OID_SKGE_VAUXAVAIL:
+		*pBuf = (char) pAC->GIni.GIVauxAvail;
+		*pLen = sizeof(char);
+		break;
+
 	case OID_SKGE_BUS_TYPE:
-		*pBuf = (char)SK_PNMI_BUS_PCI;
+		*pBuf = (char) SK_PNMI_BUS_PCI;
 		*pLen = sizeof(char);
 		break;
 
@@ -5435,6 +5524,9 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		case OID_SKGE_SPEED_CAP:
 		case OID_SKGE_SPEED_MODE:
 		case OID_SKGE_SPEED_STATUS:
+#ifdef SK_PHY_LP_MODE
+		case OID_SKGE_PHY_LP_MODE:
+#endif
 			if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U8)) {
 
 				*pLen = (Limit - LogPortIndex) * sizeof(SK_U8);
@@ -5443,6 +5535,7 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			break;
 
         case OID_SKGE_MTU:
+        case OID_SKGE_PHY_TYPE:
 			if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U32)) {
 
 				*pLen = (Limit - LogPortIndex) * sizeof(SK_U32);
@@ -5488,6 +5581,49 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 				Offset += sizeof(char);
 				break;
 
+			case OID_SKGE_PHY_TYPE:
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						continue;
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+						Val32 = pAC->GIni.GP[PhysPortIndex].PhyType;
+						SK_PNMI_STORE_U32(pBufPtr, Val32);
+					}
+				}
+				else { /* DualNetMode */
+					
+					Val32 = pAC->GIni.GP[NetIndex].PhyType;
+					SK_PNMI_STORE_U32(pBufPtr, Val32);
+				}
+				Offset += sizeof(SK_U32);
+				break;
+
+#ifdef SK_PHY_LP_MODE
+			case OID_SKGE_PHY_LP_MODE:
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						continue;
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+						Val8 = (SK_U8) pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
+						*pBufPtr = Val8;
+					}
+				}
+				else { /* DualNetMode */
+					
+					Val8 = (SK_U8) pAC->GIni.GP[PhysPortIndex].PPhyPowerState;
+					*pBufPtr = Val8;
+				}
+				Offset += sizeof(SK_U8);
+				break;
+#endif
+
 			case OID_SKGE_LINK_CAP:
 				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
 					if (LogPortIndex == 0) {
@@ -5804,6 +5940,16 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		}
 		break;
 
+#ifdef SK_PHY_LP_MODE
+	case OID_SKGE_PHY_LP_MODE:
+		if (*pLen < Limit - LogPortIndex) {
+
+			*pLen = Limit - LogPortIndex;
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		break;
+#endif
+
 	case OID_SKGE_MTU:
 		if (*pLen < sizeof(SK_U32)) {
 
@@ -6160,6 +6306,116 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 			Offset += sizeof(SK_U32);
 			break;
+		
+#ifdef SK_PHY_LP_MODE
+		case OID_SKGE_PHY_LP_MODE:
+			/* The preset ends here */
+			if (Action == SK_PNMI_PRESET) {
+
+				return (SK_PNMI_ERR_OK);
+			}
+
+			if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+				if (LogPortIndex == 0) {
+					Offset = 0;
+					continue;
+				}
+				else {
+					/* Set value for physical ports */
+					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+
+					switch (*(pBuf + Offset)) {
+						case 0:
+							/* If LowPowerMode is active, we can leave it. */
+							if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
+
+								Val32 = SkGmLeaveLowPowerMode(pAC, IoC, PhysPortIndex);
+								
+								if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState < 3)	{
+									
+									SkDrvInitAdapter(pAC);
+								}
+								break;
+							}
+							else {
+								*pLen = 0;
+								return (SK_PNMI_ERR_GENERAL);
+							}
+						case 1:
+						case 2:
+						case 3:
+						case 4:
+							/* If no LowPowerMode is active, we can enter it. */
+							if (!pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
+
+								if ((*(pBuf + Offset)) < 3)	{
+								
+									SkDrvDeInitAdapter(pAC);
+								}
+
+								Val32 = SkGmEnterLowPowerMode(pAC, IoC, PhysPortIndex, *pBuf);
+								break;
+							}
+							else {
+								*pLen = 0;
+								return (SK_PNMI_ERR_GENERAL);
+							}
+						default:
+							*pLen = 0;
+							return (SK_PNMI_ERR_BAD_VALUE);
+					}
+				}
+			}
+			else { /* DualNetMode */
+				
+				switch (*(pBuf + Offset)) {
+					case 0:
+						/* If we are in a LowPowerMode, we can leave it. */
+						if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
+
+							Val32 = SkGmLeaveLowPowerMode(pAC, IoC, PhysPortIndex);
+							
+							if (pAC->GIni.GP[PhysPortIndex].PPhyPowerState < 3)	{
+
+								SkDrvInitAdapter(pAC);
+							}
+							break;
+						}
+						else {
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
+					
+					case 1:
+					case 2:
+					case 3:
+					case 4:
+						/* If we are not already in LowPowerMode, we can enter it. */
+						if (!pAC->GIni.GP[PhysPortIndex].PPhyPowerState) {
+
+							if ((*(pBuf + Offset)) < 3)	{
+
+								SkDrvDeInitAdapter(pAC);
+							}
+							else {
+
+								Val32 = SkGmEnterLowPowerMode(pAC, IoC, PhysPortIndex, *pBuf);
+							}
+							break;
+						}
+						else {
+							*pLen = 0;
+							return (SK_PNMI_ERR_GENERAL);
+						}
+					
+					default:
+						*pLen = 0;
+						return (SK_PNMI_ERR_BAD_VALUE);
+				}
+			}
+			Offset += sizeof(SK_U8);
+			break;
+#endif
 
 		default:
             SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
@@ -6318,6 +6574,7 @@ char *pBuf)		/* Buffer used for the mana
 	unsigned int	PhysPortMax;
 	unsigned int	PhysPortIndex;
 	SK_U8		Val8;
+	SK_U32		Val32;
 	SK_BOOL		PortActiveFlag;
 	SK_GEPORT	*pPrt;
 
@@ -6340,6 +6597,14 @@ char *pBuf)		/* Buffer used for the mana
 
 		switch (Id) {
 
+		case OID_SKGE_PHY_TYPE:
+			/* Check if it is the first active port */
+			if (*pBuf == 0) {
+				Val32 = pPrt->PhyType;
+				SK_PNMI_STORE_U32(pBuf, Val32);
+				continue;
+			}
+
 		case OID_SKGE_LINK_CAP:
 
 			/*
@@ -7974,6 +8239,7 @@ unsigned int TableIndex, /* Index to the
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
 {
 
+	SK_U32	DiagStatus;
 	SK_U32	RetCode = SK_PNMI_ERR_GENERAL;
 
 	/*
@@ -8012,7 +8278,8 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 		switch (Id) {
 
 		case OID_SKGE_DIAG_MODE:
-			SK_PNMI_STORE_U32(pBuf, pAC->DiagModeActive);
+			DiagStatus = pAC->Pnmi.DiagAttached;
+			SK_PNMI_STORE_U32(pBuf, DiagStatus);
 			*pLen = sizeof(SK_U32);	
 			RetCode = SK_PNMI_ERR_OK;
 			break;
@@ -8022,7 +8289,6 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 			RetCode = SK_PNMI_ERR_GENERAL;
 			break;
 		}
-
 		return (RetCode); 
 	}
 
@@ -8039,23 +8305,84 @@ SK_U32 NetIndex)	/* NetIndex (0..n), in 
 
 			/* Handle the SET. */
 			switch (*pBuf) {
-		
+
+				/* Attach the DIAG to this adapter. */
+				case SK_DIAG_ATTACHED:
+					/* Check if we come from running */
+					if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
+
+						RetCode = SkDrvLeaveDiagMode(pAC);
+
+					}
+					else if (pAC->Pnmi.DiagAttached == SK_DIAG_IDLE) {
+
+						RetCode = SK_PNMI_ERR_OK;
+					}	
+					
+					else {
+
+						RetCode = SK_PNMI_ERR_GENERAL;
+
+					}
+					
+					if (RetCode == SK_PNMI_ERR_OK) {
+
+						pAC->Pnmi.DiagAttached = SK_DIAG_ATTACHED;
+					}
+					break;
+
 				/* Enter the DIAG mode in the driver. */
-				case 1:
-					/* If DiagMode is not active, we can enter it. */
-					if (!pAC->DiagModeActive) {
+				case SK_DIAG_RUNNING:
+					RetCode = SK_PNMI_ERR_OK;
+					
+					/*
+					 * If DiagAttached is set, we can tell the driver
+					 * to enter the DIAG mode.
+					 */
+					if (pAC->Pnmi.DiagAttached == SK_DIAG_ATTACHED) {
+						/* If DiagMode is not active, we can enter it. */
+						if (!pAC->DiagModeActive) {
 
-						RetCode = SkDrvEnterDiagMode(pAC);	
+							RetCode = SkDrvEnterDiagMode(pAC); 
+						}
+						else {
+
+							RetCode = SK_PNMI_ERR_GENERAL;
+						}
 					}
 					else {
 
 						RetCode = SK_PNMI_ERR_GENERAL;
 					}
+					
+					if (RetCode == SK_PNMI_ERR_OK) {
+
+						pAC->Pnmi.DiagAttached = SK_DIAG_RUNNING;
+					}
 					break;
 
-				/* Leave the DIAG mode in the driver. */
-				case 0:
-					RetCode = SkDrvLeaveDiagMode(pAC);	
+				case SK_DIAG_IDLE:
+					/* Check if we come from running */
+					if (pAC->Pnmi.DiagAttached == SK_DIAG_RUNNING) {
+
+						RetCode = SkDrvLeaveDiagMode(pAC);
+
+					}
+					else if (pAC->Pnmi.DiagAttached == SK_DIAG_ATTACHED) {
+
+						RetCode = SK_PNMI_ERR_OK;
+					}	
+					
+					else {
+
+						RetCode = SK_PNMI_ERR_GENERAL;
+
+					}
+
+					if (RetCode == SK_PNMI_ERR_OK) {
+
+						pAC->Pnmi.DiagAttached = SK_DIAG_IDLE;
+					}
 					break;
 
 				default:
diff -purN linux-2.6.1/drivers/net/sk98lin/skgesirq.c linux-2.5/drivers/net/sk98lin/skgesirq.c
--- linux-2.6.1/drivers/net/sk98lin/skgesirq.c	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skgesirq.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skgesirq.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.91 $
- * Date:	$Date: 2003/07/04 12:46:22 $
+ * Version:	$Revision: 1.92 $
+ * Date:	$Date: 2003/09/16 14:37:07 $
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
@@ -27,6 +27,12 @@
  * History:
  *
  *	$Log: skgesirq.c,v $
+ *	Revision 1.92  2003/09/16 14:37:07  rschmidt
+ *	Added debug messages in some SkGePortCheckUp...() routines.
+ *	Fixed compiler warnings for different types.
+ *	Avoided port check up in reset state (eg. coma mode).
+ *	Editorial changes.
+ *	
  *	Revision 1.91  2003/07/04 12:46:22  rschmidt
  *	Added debug messages in SkGePortCheckUpGmac().
  *	Added error log message and new driver event SK_DRV_DOWNSHIFT_DET
@@ -410,7 +416,7 @@
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgesirq.c,v 1.91 2003/07/04 12:46:22 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skgesirq.c,v 1.92 2003/09/16 14:37:07 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
@@ -490,7 +496,7 @@ int		Port)	/* Port Index (MAC_1 + n) */
 		("AutoSensing: First mode %d on Port %d\n",
 		(int)SK_LMODE_AUTOFULL, Port));
 
-	pPrt->PLinkMode = SK_LMODE_AUTOFULL;
+	pPrt->PLinkMode = (SK_U8)SK_LMODE_AUTOFULL;
 
 	return;
 }	/* SkHWInitDefSense */
@@ -606,7 +612,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* Reset Port stati */
     pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
     pPrt->PFlowCtrlStatus = (SK_U8)SK_FLOW_STAT_NONE;
-	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_INDETERMINATED;
+	pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_INDETERMINATED;
 
 	/* Re-init Phy especially when the AutoSense default is set now */
 	SkMacInitPhy(pAC, IoC, Port, SK_FALSE);
@@ -655,19 +661,19 @@ int		Port)	/* Port Index (MAC_1 + n) */
 		case SK_LSPEED_AUTO:
 			/* default is 1000 Mbps */
 		case SK_LSPEED_1000MBPS:
-			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+			pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_1000MBPS;
 			break;
 		case SK_LSPEED_100MBPS:
-			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_100MBPS;
+			pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_100MBPS;
 			break;
 		case SK_LSPEED_10MBPS:
-			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_10MBPS;
+			pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_10MBPS;
 			break;
 		}
 
 		/* Set Link Mode Status */
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
-			pPrt->PLinkModeStatus = SK_LMODE_STAT_FULL;
+			pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_FULL;
 		}
 		else {
             pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_HALF;
@@ -1598,8 +1604,7 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			 * (clear Page Received bit if set)
 			 */
 			SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_EXP, &ExtStat);
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-				("AutoNeg done Port %d\n", Port));
+			
 			return(SK_HW_PS_LINK);
 		}
 		
@@ -1870,7 +1875,7 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
+		("CheckUp Port %d, PhyStat: 0x%04X\n", Port, PhyStat));
 
 	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 
@@ -1897,8 +1902,11 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 
 	if (AutoNeg) {
 		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
+			
 			SkHWLinkUp(pAC, IoC, Port);
+			
 			Done = SkMacAutoNegDone(pAC, IoC, Port);
+			
 			if (Done != SK_AND_OK) {
 #ifdef DEBUG
 				/* Get PHY parameters, for debugging only */
@@ -1924,9 +1932,6 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 						(void *)NULL);
 				}
 #endif /* DEBUG */
-				
-				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-					("AutoNeg done Port %d\n", Port));
 				return(SK_HW_PS_LINK);
 			}
 		}
@@ -1989,9 +1994,22 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	SK_U16		PhySpecStat;/* PHY Specific Status */
 	SK_U16		ResAb;		/* Master/Slave resolution */
 	SK_EVPARA	Para;
+#ifdef DEBUG
+	SK_U16		Word;		/* I/O helper */
+#endif /* DEBUG */
 
 	pPrt = &pAC->GIni.GP[Port];
 
+	if (pPrt->PHWLinkUp) {
+		return(SK_HW_PS_NONE);
+	}
+
+	/* Read PHY Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("CheckUp Port %d, PhyStat: 0x%04X\n", Port, PhyStat));
+
 	/* Read PHY Interrupt Status */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &PhyIsrc);
 
@@ -2005,16 +2023,6 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 			("Link Speed Changed, PhyIsrc: 0x%04X\n", PhyIsrc));
 	}
 
-	if (pPrt->PHWLinkUp) {
-		return(SK_HW_PS_NONE);
-	}
-
-	/* Read PHY Status */
-	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
-
-	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
-
 	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
 	
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_STAT, &ResAb);
@@ -2034,7 +2042,20 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg: %d, PhySpecStat: 0x%04X\n", AutoNeg, PhySpecStat));
+		("Phy1000BT: 0x%04X, PhySpecStat: 0x%04X\n", ResAb, PhySpecStat));
+
+#ifdef DEBUG
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_EXP, &Word);
+
+	if ((PhyIsrc & PHY_M_IS_AN_PR) != 0 || (Word & PHY_ANE_RX_PG) != 0 ||
+		(PhySpecStat & PHY_M_PS_PAGE_REC) != 0)  {
+		/* Read PHY Next Page Link Partner */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_NEPG_LP, &Word);
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Page Received, NextPage: 0x%04X\n", Word));
+	}
+#endif /* DEBUG */
 
 	if ((PhySpecStat & PHY_M_PS_LINK_UP) == 0) {
 		return(SK_HW_PS_NONE);
@@ -2069,8 +2090,6 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 				return(SK_HW_PS_RESTART);
 			}
 			
-			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-				("AutoNeg done Port %d\n", Port));
 			return(SK_HW_PS_LINK);
 		}
 	}
@@ -2179,8 +2198,6 @@ SK_BOOL	AutoNeg)	/* Is Auto-negotiation 
 				 * extra link down/ups
 				 */
 				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_INT_STAT, &ExtStat);
-				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-					("AutoNeg done Port %d\n", Port));
 				return(SK_HW_PS_LINK);
 			}
 		}
@@ -2278,8 +2295,14 @@ SK_EVPARA	Para)		/* Event specific Param
 
 	switch (Event) {
 	case SK_HWEV_WATIM:
-		/* Check whether port came up */
-		PortStat = SkGePortCheckUp(pAC, IoC, (int)Port);
+		if (pPrt->PState == SK_PRT_RESET) {
+		
+			PortStat = SK_HW_PS_NONE;
+		}
+		else {
+			/* Check whether port came up */
+			PortStat = SkGePortCheckUp(pAC, IoC, (int)Port);
+		}
 
 		switch (PortStat) {
 		case SK_HW_PS_RESTART:
diff -purN linux-2.6.1/drivers/net/sk98lin/ski2c.c linux-2.5/drivers/net/sk98lin/ski2c.c
--- linux-2.6.1/drivers/net/sk98lin/ski2c.c	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/ski2c.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	ski2c.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.57 $
- * Date:	$Date: 2003/01/28 09:17:38 $
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.59 $
+ * Date:	$Date: 2003/10/20 09:07:25 $
  * Purpose:	Functions to access Voltage and Temperature Sensor
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,14 @@
  * History:
  *
  *	$Log: ski2c.c,v $
+ *	Revision 1.59  2003/10/20 09:07:25  rschmidt
+ *	Added cast SK_U32 in SkI2cWrite() to avoid compiler warning.
+ *	Editorial changes.
+ *	
+ *	Revision 1.58  2003/09/23 09:22:53  malthoff
+ *	Parameter I2cDevSize added in SkI2cRead and SkI2cWrite to
+ *	support larger devices on the TWSI bus.
+ *	
  *	Revision 1.57  2003/01/28 09:17:38  rschmidt
  *	Fixed handling for sensors on YUKON Fiber.
  *	Editorial changes.
@@ -224,15 +233,15 @@
  *	Created. Sources taken from ML Projekt.
  *	Sources have to be reworked for GE.
  *
- *
  ******************************************************************************/
 
-
 /*
  *	I2C Protocol
  */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Id: ski2c.c,v 1.57 2003/01/28 09:17:38 rschmidt Exp $";
+	"@(#) $Id: ski2c.c,v 1.59 2003/10/20 09:07:25 rschmidt Exp $ (C) Marvell. ";
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -312,7 +321,7 @@ intro()
 {}
 #endif
 
-#ifdef	SK_DIAG
+#ifdef SK_DIAG
 /*
  * I2C Fast Mode timing values used by the LM80.
  * If new devices are added to the I2C bus the timing values have to be checked.
@@ -516,7 +525,6 @@ SK_IOC IoC)	/* I/O Context */
 {
 	/*
 	 * Received bit must be zero.
-	 *
 	 */
 	SkI2cSndBit(IoC, 0);
 }	/* SkI2cSndAck */
@@ -590,7 +598,7 @@ int		Rw)		/* Read / Write Flag */
 	return(SkI2cSndByte(IoC, (Addr<<1) | Rw));
 }	/* SkI2cSndDev */
 
-#endif	/* SK_DIAG */
+#endif /* SK_DIAG */
 
 /*----------------- I2C CTRL Register Functions ----------*/
 
@@ -620,7 +628,7 @@ int		Event)	/* complete event to wait fo
 			SK_I2C_STOP(IoC);
 #ifndef SK_DIAG
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E002, SKERR_I2C_E002MSG);
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 			return(1);
 		}
 		
@@ -661,15 +669,19 @@ SK_IOC	IoC)	/* I/O Context */
 	}
 
 	StartTime = SkOsGetTime(pAC);
+	
 	do {
 		if (SkOsGetTime(pAC) - StartTime > SK_TICKS_PER_SEC / 8) {
+			
 			SK_I2C_STOP(IoC);
 #ifndef SK_DIAG
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E016, SKERR_I2C_E016MSG);
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 			return;
 		}
+		
 		SK_IN32(IoC, B0_ISRC, &IrqSrc);
+
 	} while ((IrqSrc & IS_I2C_READY) == 0);
 
 	pSen->SenState = SK_SEN_IDLE;
@@ -687,18 +699,19 @@ SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* I/O Context */
 SK_U32	I2cData,	/* I2C Data to write */
 int		I2cDev,		/* I2C Device Address */
+int		I2cDevSize, /* I2C Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
 int		I2cReg,		/* I2C Device Register Address */
 int		I2cBurst)	/* I2C Burst Flag */
 {
 	SK_OUT32(IoC, B2_I2C_DATA, I2cData);
-	SK_I2C_CTL(IoC, I2C_WRITE, I2cDev, I2cReg, I2cBurst);
+	
+	SK_I2C_CTL(IoC, I2C_WRITE, I2cDev, I2cDevSize, I2cReg, I2cBurst);
 	
 	return(SkI2cWait(pAC, IoC, I2C_WRITE));
 }	/* SkI2cWrite*/
 
 
 #ifdef	SK_DIAG
-
 /*
  * reads a single byte or 4 bytes from the I2C device
  *
@@ -708,23 +721,24 @@ SK_U32 SkI2cRead(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* I/O Context */
 int		I2cDev,		/* I2C Device Address */
+int		I2cDevSize, /* I2C Device Size (e.g. I2C_025K_DEV or I2C_2K_DEV) */
 int		I2cReg,		/* I2C Device Register Address */
 int		I2cBurst)	/* I2C Burst Flag */
 {
 	SK_U32	Data;
 
 	SK_OUT32(IoC, B2_I2C_DATA, 0);
-	SK_I2C_CTL(IoC, I2C_READ, I2cDev, I2cReg, I2cBurst);
+	SK_I2C_CTL(IoC, I2C_READ, I2cDev, I2cDevSize, I2cReg, I2cBurst);
 	
 	if (SkI2cWait(pAC, IoC, I2C_READ) != 0) {
 		w_print("%s\n", SKERR_I2C_E002MSG);
 	}
 	
 	SK_IN32(IoC, B2_I2C_DATA, &Data);
+	
 	return(Data);
 }	/* SkI2cRead */
-
-#endif	/* SK_DIAG */
+#endif /* SK_DIAG */
 
 
 /*
@@ -745,9 +759,10 @@ SK_SENSOR	*pSen)	/* Sensor to be read */
     if (pSen->SenRead != NULL) {
         return((*pSen->SenRead)(pAC, IoC, pSen));
     }
-    else
+	else {
         return(0); /* no success */
-}	/* SkI2cReadSensor*/
+	}
+}	/* SkI2cReadSensor */
 
 /*
  * Do the Init state 0 initialization
@@ -761,12 +776,12 @@ SK_AC	*pAC)	/* Adapter Context */
 	pAC->I2c.CurrSens = 0;
 	
 	/* Begin with timeout control for state machine */
-	pAC->I2c.TimerMode = SK_TIMER_WATCH_STATEMACHINE;
+	pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
 	
 	/* Set sensor number to zero */
 	pAC->I2c.MaxSens = 0;
 
-#ifndef	SK_DIAG
+#ifndef SK_DIAG
 	/* Initialize Number of Dummy Reads */
 	pAC->I2c.DummyReads = SK_MAX_SENSORS;
 #endif
@@ -840,19 +855,20 @@ SK_IOC	IoC)	/* I/O Context */
     }
 
 	/* Check for 64 Bit Yukon without sensors */
-	if (SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_CFG, 0) != 0) {
+	if (SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_CFG, 0) != 0) {
         return(0);
     }
 
-	(void)SkI2cWrite(pAC, IoC, 0xff, LM80_ADDR, LM80_IMSK_1, 0);
+	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_1, 0);
 	
-	(void)SkI2cWrite(pAC, IoC, 0xff, LM80_ADDR, LM80_IMSK_2, 0);
+	(void)SkI2cWrite(pAC, IoC, 0xffUL, LM80_ADDR, I2C_025K_DEV, LM80_IMSK_2, 0);
 	
-	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_FAN_CTRL, 0);
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_FAN_CTRL, 0);
 	
-	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_TEMP_CTRL, 0);
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, I2C_025K_DEV, LM80_TEMP_CTRL, 0);
 	
-	(void)SkI2cWrite(pAC, IoC, LM80_CFG_START, LM80_ADDR, LM80_CFG, 0);
+	(void)SkI2cWrite(pAC, IoC, (SK_U32)LM80_CFG_START, LM80_ADDR, I2C_025K_DEV,
+		LM80_CFG, 0);
 	
 	/*
 	 * MaxSens has to be updated here, because PhyType is not
@@ -957,7 +973,7 @@ SK_IOC	IoC)	/* I/O Context */
 				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
 			}
 			else {
-				pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC-Co 1V5";
+				pAC->I2c.SenTable[i].SenDesc = "Voltage Core 1V5";
 				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
 				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
 				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
@@ -1015,9 +1031,9 @@ SK_IOC	IoC)	/* I/O Context */
 		pAC->I2c.SenTable[i].SenDev = LM80_ADDR;
 	}
 
-#ifndef	SK_DIAG
+#ifndef SK_DIAG
 	pAC->I2c.DummyReads = pAC->I2c.MaxSens;
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 	
 	/* Clear I2C IRQ */
 	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
@@ -1208,15 +1224,13 @@ SK_SENSOR	*pSen)
 			pSen->SenLastErrLogTS = CurrTime;
 
 			if (pSen->SenType == SK_SEN_TEMP) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E011,
-					SKERR_I2C_E011MSG);
-			} else if (pSen->SenType == SK_SEN_VOLT) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E012,
-					SKERR_I2C_E012MSG);
-			} else
-			{
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E015,
-					SKERR_I2C_E015MSG);
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E011, SKERR_I2C_E011MSG);
+			}
+			else if (pSen->SenType == SK_SEN_VOLT) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E012, SKERR_I2C_E012MSG);
+			}
+			else {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E015, SKERR_I2C_E015MSG);
 			}
 		}
 	}
@@ -1235,8 +1249,7 @@ SK_SENSOR	*pSen)
 			/* This state is the former one */
 
 			/* So check first whether we have to send a trap */
-			if (pSen->SenLastWarnTrapTS + SK_SEN_WARN_TR_HOLD >
-			    CurrTime) {
+			if (pSen->SenLastWarnTrapTS + SK_SEN_WARN_TR_HOLD > CurrTime) {
 				/*
 				 * Do NOT send the Trap. The hold back time
 				 * has to run out first.
@@ -1245,8 +1258,7 @@ SK_SENSOR	*pSen)
 			}
 
 			/* Check now whether we have to log an Error */
-			if (pSen->SenLastWarnLogTS + SK_SEN_WARN_LOG_HOLD >
-			    CurrTime) {
+			if (pSen->SenLastWarnLogTS + SK_SEN_WARN_LOG_HOLD > CurrTime) {
 				/*
 				 * Do NOT log the error. The hold back time
 				 * has to run out first.
@@ -1277,15 +1289,13 @@ SK_SENSOR	*pSen)
 			pSen->SenLastWarnLogTS = CurrTime;
 
 			if (pSen->SenType == SK_SEN_TEMP) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E009,
-					SKERR_I2C_E009MSG);
-			} else if (pSen->SenType == SK_SEN_VOLT) {
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E010,
-					SKERR_I2C_E010MSG);
-			} else
-			{
-				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E014,
-					SKERR_I2C_E014MSG);
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E009, SKERR_I2C_E009MSG);
+			}
+			else if (pSen->SenType == SK_SEN_VOLT) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E010, SKERR_I2C_E010MSG);
+			}
+			else {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E014, SKERR_I2C_E014MSG);
 			}
 		}
 	}
@@ -1317,7 +1327,7 @@ SK_SENSOR	*pSen)
 		}
 	}
 	
-#if 0
+#ifdef TEST_ONLY
     /* Dynamic thresholds also for VAUX of LM80 sensor */
 	if (pSen->SenInit == SK_SEN_DYN_INIT_VAUX) {
 
@@ -1359,7 +1369,7 @@ SK_SENSOR	*pSen)
 	if (pSen->SenInit != SK_SEN_DYN_INIT_NONE) {
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E013, SKERR_I2C_E013MSG);
 	}
-}	/* SkI2cCheckSensor*/
+}	/* SkI2cCheckSensor */
 
 
 /*
@@ -1390,7 +1400,7 @@ SK_EVPARA	Para)	/* Event specific Parame
 
 		if (ReadComplete) {
 			/* Check sensor against defined thresholds */
-			SkI2cCheckSensor (pAC, pSen);
+			SkI2cCheckSensor(pAC, pSen);
 
 			/* Increment Current sensor and set appropriate Timeout */
 			pAC->I2c.CurrSens++;
@@ -1414,7 +1424,7 @@ SK_EVPARA	Para)	/* Event specific Parame
 			/* Start Timer */
 			ParaLocal.Para64 = (SK_U64)0;
 
-			pAC->I2c.TimerMode = SK_TIMER_WATCH_STATEMACHINE;
+			pAC->I2c.TimerMode = SK_TIMER_WATCH_SM;
 
             SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, SK_I2C_TIM_WATCH,
 				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
@@ -1431,7 +1441,7 @@ SK_EVPARA	Para)	/* Event specific Parame
 
 			if (ReadComplete) {
 				/* Check sensor against defined thresholds */
-				SkI2cCheckSensor (pAC, pSen);
+				SkI2cCheckSensor(pAC, pSen);
 
 				/* Increment Current sensor and set appropriate Timeout */
 				pAC->I2c.CurrSens++;
@@ -1496,4 +1506,4 @@ SK_EVPARA	Para)	/* Event specific Parame
 	return(0);
 }	/* SkI2cEvent*/
 
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
diff -purN linux-2.6.1/drivers/net/sk98lin/sklm80.c linux-2.5/drivers/net/sk98lin/sklm80.c
--- linux-2.6.1/drivers/net/sk98lin/sklm80.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/sklm80.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
  * Name:	sklm80.c
- * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.20 $
- * Date:	$Date: 2002/08/13 09:16:27 $
- * Purpose:	Funktions to access Voltage and Temperature Sensor (LM80)
+ * Project:	Gigabit Ethernet Adapters, TWSI-Module
+ * Version:	$Revision: 1.22 $
+ * Date:	$Date: 2003/10/20 09:08:21 $
+ * Purpose:	Functions to access Voltage and Temperature Sensor (LM80)
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,15 +27,21 @@
  * History:
  *
  *	$Log: sklm80.c,v $
+ *	Revision 1.22  2003/10/20 09:08:21  rschmidt
+ *	Editorial changes.
+ *	
+ *	Revision 1.21  2003/09/23 09:29:04  malthoff
+ *	Parameter Dev_Size added to macro SK_I2C_CTL.
+ *	
  *	Revision 1.20  2002/08/13 09:16:27  rschmidt
  *	Changed return value for SkLm80ReadSensor() back to 'int'
- *	Editorial changes
+ *	Editorial changes.
  *	
  *	Revision 1.19  2002/08/06 09:43:31  jschmalz
- *	Extensions and changes for Yukon
+ *	Extensions and changes for Yukon.
  *	
  *	Revision 1.18  2002/08/02 12:26:57  rschmidt
- *	Editorial changes
+ *	Editorial changes.
  *	
  *	Revision 1.17  1999/11/22 13:35:51  cgoos
  *	Changed license header to GPL.
@@ -93,16 +100,15 @@
  *	Revision 1.1  1998/07/17 09:57:12  gklug
  *	initial version
  *
- *
- *
  ******************************************************************************/
 
-
 /*
 	LM80 functions
 */
+#if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Id: sklm80.c,v 1.20 2002/08/13 09:16:27 rschmidt Exp $" ;
+	"@(#) $Id: sklm80.c,v 1.22 2003/10/20 09:08:21 rschmidt Exp $ (C) Marvell. ";
+#endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -202,7 +208,7 @@ SK_SENSOR	*pSen)	/* Sensor to be read */
 	switch (pSen->SenState) {
 	case SK_SEN_IDLE:
 		/* Send address to ADDR register */
-		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, pSen->SenReg, 0);
+		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, I2C_025K_DEV, pSen->SenReg, 0);
 
 		pSen->SenState = SK_SEN_VALUE ;
 		BREAK_OR_WAIT(pAC, IoC, I2C_READ);
@@ -250,7 +256,7 @@ SK_SENSOR	*pSen)	/* Sensor to be read */
 			(pSen->SenValue % SK_LM80_TEMP_LSB);
 
 		/* Send address to ADDR register */
-		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, LM80_TEMP_CTRL, 0);
+		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, I2C_025K_DEV, LM80_TEMP_CTRL, 0);
 
 		pSen->SenState = SK_SEN_VALEXT ;
 		BREAK_OR_WAIT(pAC, IoC, I2C_READ);
@@ -284,3 +290,4 @@ SK_SENSOR	*pSen)	/* Sensor to be read */
 	/* Not completed */
 	return(0);
 }
+
diff -purN linux-2.6.1/drivers/net/sk98lin/skproc.c linux-2.5/drivers/net/sk98lin/skproc.c
--- linux-2.6.1/drivers/net/sk98lin/skproc.c	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skproc.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,16 +1,17 @@
 /******************************************************************************
  *
- * Name:    skproc.c
+ * Name:	skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2 $
- * Date:    $Date: 2003/08/12 16:45:29 $
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/12/11 16:03:57 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
  
 /******************************************************************************
  *
- *	(C)Copyright 1998-2003 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +29,33 @@
  * History:
  *
  *	$Log: skproc.c,v $
+ *	Revision 1.11  2003/12/11 16:03:57  mlindner
+ *	Fix: Create backup from pnmi data structure
+ *	
+ *	Revision 1.10  2003/11/19 16:25:36  mlindner
+ *	Fix: Print output as 64-bit digit
+ *	
+ *	Revision 1.9  2003/11/17 13:29:05  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.8  2003/11/13 14:18:48  rroesler
+ *	Fix: added latest changes regarding the use of the proc system
+ *	
+ *	Revision 1.7  2003/11/10 09:35:07  rroesler
+ *	Fix: diag backup restore of PNMI structure
+ *	
+ *	Revision 1.6  2003/11/07 17:31:39  rroesler
+ *	Add: security counter for the proc file system
+ *	
+ *	Revision 1.5  2003/10/07 08:17:08  mlindner
+ *	Fix: Copyright changes
+ *	
+ *	Revision 1.4  2003/09/01 15:29:24  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.3  2003/08/29 12:30:58  mlindner
+ *	Add: Version entry in the proc file system
+ *	
  *	Revision 1.2  2003/08/12 16:45:29  mlindner
  *	Add: Removed SkNumber and SkDoDiv
  *	Add: Counter output as (unsigned long long)
@@ -94,223 +122,350 @@
 
 #include "h/skdrv1st.h"
 #include "h/skdrv2nd.h"
+#include "h/skversion.h"
 
-#ifdef CONFIG_PROC_FS
+extern struct SK_NET_DEVICE *SkGeRootDev;
+static int sk_proc_print(void *writePtr, char *format, ...);
+static void sk_gen_browse(void *buffer);
+int len;
 
-extern struct net_device	*SkGeRootDev;
+static int sk_seq_show(struct seq_file *seq, void *v);
+static int sk_proc_open(struct inode *inode, struct file *file);
+struct file_operations sk_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= sk_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+struct net_device *currDev = NULL;
 
-static int sk_seq_show(struct seq_file *seq, void *v)
+/*****************************************************************************
+ *
+ * 	sk_gen_browse -generic  print "summaries" entry 
+ *
+ * Description:
+ *  This function fills the proc entry with statistic data about 
+ *  the ethernet device.
+ *  
+ * Returns: -
+ *	
+ */
+static void sk_gen_browse(void *buffer)
 {
-	struct net_device *dev = seq->private;
-	DEV_NET		*pNet = dev->priv;
-	SK_AC		*pAC = pNet->pAC;
-	SK_PNMI_STRUCT_DATA *pPnmiStruct = &pAC->PnmiStruct;
-	SK_PNMI_STAT	*pPnmiStat = &pPnmiStruct->Stat[0];
-	int unit = !(pAC->dev[0] == dev);
-	int i;
-	char sens_msg[50];
-
-	seq_printf(seq,
-		   "\nDetailed statistic for device %s\n",
-		   dev->name);
-	seq_printf(seq,
-		   "=======================================\n");
-	
-	/* Board statistics */
-	seq_printf(seq, 
-		   "\nBoard statistics\n\n");
-	seq_printf(seq,
-		   "Active Port                    %c\n",
-		   'A' + pAC->Rlmt.Net[unit].Port[pAC->Rlmt.
-						 Net[unit].PrefPort]->PortNumber);
-	seq_printf(seq,
-		   "Preferred Port                 %c\n",
-		   'A' + pAC->Rlmt.Net[unit].Port[pAC->Rlmt.
-						 Net[unit].PrefPort]->PortNumber);
-
-	seq_printf(seq,
-		   "Bus speed (MHz)                %d\n",
-		   pPnmiStruct->BusSpeed);
-
-	seq_printf(seq,
-		   "Bus width (Bit)                %d\n",
-		   pPnmiStruct->BusWidth);
-	seq_printf(seq,
-		   "Hardware revision              v%d.%d\n",
-		   (pAC->GIni.GIPciHwRev >> 4) & 0x0F,
-		   pAC->GIni.GIPciHwRev & 0x0F);
-
-	/* Print sensor informations */
-	for (i=0; i < pAC->I2c.MaxSens; i ++) {
-		/* Check type */
-		switch (pAC->I2c.SenTable[i].SenType) {
-		case 1:
-			strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-			strcat(sens_msg, " (C)");
-			seq_printf(seq,
-				   "%-25s      %d.%02d\n",
-				   sens_msg,
-				   pAC->I2c.SenTable[i].SenValue / 10,
-				   pAC->I2c.SenTable[i].SenValue % 10);
-
-			strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-			strcat(sens_msg, " (F)");
-			seq_printf(seq,
-				   "%-25s      %d.%02d\n",
-				   sens_msg,
-				   ((((pAC->I2c.SenTable[i].SenValue)
-				      *10)*9)/5 + 3200)/100,
-				   ((((pAC->I2c.SenTable[i].SenValue)
-				      *10)*9)/5 + 3200) % 10);
-			break;
-		case 2:
-			strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-			strcat(sens_msg, " (V)");
-			seq_printf(seq,
-				   "%-25s      %d.%03d\n",
-				   sens_msg,
-				   pAC->I2c.SenTable[i].SenValue / 1000,
-				   pAC->I2c.SenTable[i].SenValue % 1000);
-			break;
-		case 3:
-			strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
-			strcat(sens_msg, " (rpm)");
-			seq_printf(seq,
-				   "%-25s      %d\n",
-				   sens_msg,
-				   pAC->I2c.SenTable[i].SenValue);
-			break;
-		default:
-			break;
+	struct SK_NET_DEVICE	*SkgeProcDev = SkGeRootDev;
+	struct SK_NET_DEVICE	*next;
+	SK_PNMI_STRUCT_DATA 	*pPnmiStruct;
+	SK_PNMI_STAT		*pPnmiStat;
+	unsigned long		Flags;	
+	unsigned int		Size;
+	DEV_NET			*pNet;
+	SK_AC			*pAC;
+	char			sens_msg[50];
+	int			MaxSecurityCount = 0;
+	int 			t;
+	int 			i;
+
+	while (SkgeProcDev) {
+		MaxSecurityCount++;
+		if (MaxSecurityCount > 100) {
+			printk("Max limit for sk_proc_read security counter!\n");
+			return;
 		}
-	}
+		pNet = (DEV_NET*) SkgeProcDev->priv;
+		pAC = pNet->pAC;
+		next = pAC->Next;
+		pPnmiStruct = &pAC->PnmiStruct;
+		/* NetIndex in GetStruct is now required, zero is only dummy */
+
+		for (t=pAC->GIni.GIMacsFound; t > 0; t--) {
+			if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 1)
+				t--;
+
+			spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+			Size = SK_PNMI_STRUCT_SIZE;
+#ifdef SK_DIAG_SUPPORT
+			if (pAC->BoardLevel == SK_INIT_DATA) {
+				SK_MEMCPY(&(pAC->PnmiStruct), &(pAC->PnmiBackup), sizeof(SK_PNMI_STRUCT_DATA));
+				if (pAC->DiagModeActive == DIAG_NOTACTIVE) {
+					pAC->Pnmi.DiagAttached = SK_DIAG_IDLE;
+				}
+			} else {
+				SkPnmiGetStruct(pAC, pAC->IoBase, pPnmiStruct, &Size, t-1);
+			}
+#else
+			SkPnmiGetStruct(pAC, pAC->IoBase, 
+				pPnmiStruct, &Size, t-1);
+#endif
+			spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+	
+			if (strcmp(pAC->dev[t-1]->name, currDev->name) == 0) {
+				pPnmiStat = &pPnmiStruct->Stat[0];
+				len = sk_proc_print(buffer, 
+					"\nDetailed statistic for device %s\n",
+					pAC->dev[t-1]->name);
+				len += sk_proc_print(buffer,
+					"=======================================\n");
+	
+				/* Board statistics */
+				len += sk_proc_print(buffer, 
+					"\nBoard statistics\n\n");
+				len += sk_proc_print(buffer,
+					"Active Port                    %c\n",
+					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
+					Net[t-1].PrefPort]->PortNumber);
+				len += sk_proc_print(buffer,
+					"Preferred Port                 %c\n",
+					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
+					Net[t-1].PrefPort]->PortNumber);
+
+				len += sk_proc_print(buffer,
+					"Bus speed (MHz)                %d\n",
+					pPnmiStruct->BusSpeed);
+
+				len += sk_proc_print(buffer,
+					"Bus width (Bit)                %d\n",
+					pPnmiStruct->BusWidth);
+				len += sk_proc_print(buffer,
+					"Driver version                 %s\n",
+					VER_STRING);
+				len += sk_proc_print(buffer,
+					"Hardware revision              v%d.%d\n",
+					(pAC->GIni.GIPciHwRev >> 4) & 0x0F,
+					pAC->GIni.GIPciHwRev & 0x0F);
+
+				/* Print sensor informations */
+				for (i=0; i < pAC->I2c.MaxSens; i ++) {
+					/* Check type */
+					switch (pAC->I2c.SenTable[i].SenType) {
+					case 1:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (C)");
+						len += sk_proc_print(buffer,
+							"%-25s      %d.%02d\n",
+							sens_msg,
+							pAC->I2c.SenTable[i].SenValue / 10,
+							pAC->I2c.SenTable[i].SenValue % 10);
+
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (F)");
+						len += sk_proc_print(buffer,
+							"%-25s      %d.%02d\n",
+							sens_msg,
+							((((pAC->I2c.SenTable[i].SenValue)
+							*10)*9)/5 + 3200)/100,
+							((((pAC->I2c.SenTable[i].SenValue)
+							*10)*9)/5 + 3200) % 10);
+						break;
+					case 2:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (V)");
+						len += sk_proc_print(buffer,
+							"%-25s      %d.%03d\n",
+							sens_msg,
+							pAC->I2c.SenTable[i].SenValue / 1000,
+							pAC->I2c.SenTable[i].SenValue % 1000);
+						break;
+					case 3:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (rpm)");
+						len += sk_proc_print(buffer,
+							"%-25s      %d\n",
+							sens_msg,
+							pAC->I2c.SenTable[i].SenValue);
+						break;
+					default:
+						break;
+					}
+				}
 				
-	/*Receive statistics */
-	seq_printf(seq, 
-		   "\nReceive statistics\n\n");
-
-	seq_printf(seq,
-		   "Received bytes                 %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxOctetsOkCts);
-	seq_printf(seq,
-		   "Received packets               %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxOkCts);
+				/*Receive statistics */
+				len += sk_proc_print(buffer, 
+				"\nReceive statistics\n\n");
+
+				len += sk_proc_print(buffer,
+					"Received bytes                 %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxOctetsOkCts);
+				len += sk_proc_print(buffer,
+					"Received packets               %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxOkCts);
 #if 0
-	if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
-	    pAC->HWRevision < 12) {
-		pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts - 
-			pPnmiStat->StatRxShortsCts;
-		pPnmiStat->StatRxShortsCts = 0;
-	}
+				if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
+					pAC->HWRevision < 12) {
+					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts - 
+						pPnmiStat->StatRxShortsCts;
+					pPnmiStat->StatRxShortsCts = 0;
+				}
 #endif
-	if (pNet->Mtu > 1500) 
-		pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts -
-			pPnmiStat->StatRxTooLongCts;
-
-	seq_printf(seq,
-		   "Receive errors                 %Ld\n",
-		   (unsigned long long) pPnmiStruct->InErrorsCts);
-	seq_printf(seq,
-		   "Receive dropped                %Ld\n",
-		   (unsigned long long) pPnmiStruct->RxNoBufCts);
-	seq_printf(seq,
-		   "Received multicast             %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxMulticastOkCts);
-	seq_printf(seq,
-		   "Receive error types\n");
-	seq_printf(seq,
-		   "   length                      %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxRuntCts);
-	seq_printf(seq,
-		   "   buffer overflow             %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxFifoOverflowCts);
-	seq_printf(seq,
-		   "   bad crc                     %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxFcsCts);
-	seq_printf(seq,
-		   "   framing                     %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxFramingCts);
-	seq_printf(seq,
-		   "   missed frames               %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxMissedCts);
-
-	if (pNet->Mtu > 1500)
-		pPnmiStat->StatRxTooLongCts = 0;
-
-	seq_printf(seq,
-		   "   too long                    %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxTooLongCts);					
-	seq_printf(seq,
-		   "   carrier extension           %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxCextCts);				
-	seq_printf(seq,
-		   "   too short                   %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxShortsCts);				
-	seq_printf(seq,
-		   "   symbol                      %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxSymbolCts);				
-	seq_printf(seq,
-		   "   LLC MAC size                %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxIRLengthCts);				
-	seq_printf(seq,
-		   "   carrier event               %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxCarrierCts);				
-	seq_printf(seq,
-		   "   jabber                      %Ld\n",
-		   (unsigned long long) pPnmiStat->StatRxJabberCts);				
-
-
-	/*Transmit statistics */
-	seq_printf(seq, 
-		   "\nTransmit statistics\n\n");
+				if (pNet->Mtu > 1500) 
+					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts -
+						pPnmiStat->StatRxTooLongCts;
+
+				len += sk_proc_print(buffer,
+					"Receive errors                 %Lu\n",
+					(unsigned long long) pPnmiStruct->InErrorsCts);
+				len += sk_proc_print(buffer,
+					"Receive dropped                %Lu\n",
+					(unsigned long long) pPnmiStruct->RxNoBufCts);
+				len += sk_proc_print(buffer,
+					"Received multicast             %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxMulticastOkCts);
+				len += sk_proc_print(buffer,
+					"Receive error types\n");
+				len += sk_proc_print(buffer,
+					"   length                      %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxRuntCts);
+				len += sk_proc_print(buffer,
+					"   buffer overflow             %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxFifoOverflowCts);
+				len += sk_proc_print(buffer,
+					"   bad crc                     %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxFcsCts);
+				len += sk_proc_print(buffer,
+					"   framing                     %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxFramingCts);
+				len += sk_proc_print(buffer,
+					"   missed frames               %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxMissedCts);
+
+				if (pNet->Mtu > 1500)
+					pPnmiStat->StatRxTooLongCts = 0;
+
+				len += sk_proc_print(buffer,
+					"   too long                    %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxTooLongCts);					
+				len += sk_proc_print(buffer,
+					"   carrier extension           %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxCextCts);				
+				len += sk_proc_print(buffer,
+					"   too short                   %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxShortsCts);				
+				len += sk_proc_print(buffer,
+					"   symbol                      %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxSymbolCts);				
+				len += sk_proc_print(buffer,
+					"   LLC MAC size                %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxIRLengthCts);				
+				len += sk_proc_print(buffer,
+					"   carrier event               %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxCarrierCts);				
+				len += sk_proc_print(buffer,
+					"   jabber                      %Lu\n",
+					(unsigned long long) pPnmiStat->StatRxJabberCts);				
+
+
+				/*Transmit statistics */
+				len += sk_proc_print(buffer, 
+				"\nTransmit statistics\n\n");
 				
-	seq_printf(seq,
-		   "Transmited bytes               %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxOctetsOkCts);
-	seq_printf(seq,
-		   "Transmited packets             %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxOkCts);
-	seq_printf(seq,
-		   "Transmit errors                %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
-	seq_printf(seq,
-		   "Transmit dropped               %Ld\n",
-		   (unsigned long long) pPnmiStruct->TxNoBufCts);
-	seq_printf(seq,
-		   "Transmit collisions            %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
-	seq_printf(seq,
-		   "Transmit error types\n");
-	seq_printf(seq,
-		   "   excessive collision         %ld\n",
-		   pAC->stats.tx_aborted_errors);
-	seq_printf(seq,
-		   "   carrier                     %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxCarrierCts);
-	seq_printf(seq,
-		   "   fifo underrun               %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxFifoUnderrunCts);
-	seq_printf(seq,
-		   "   heartbeat                   %Ld\n",
-		   (unsigned long long) pPnmiStat->StatTxCarrierCts);
-	seq_printf(seq,
-		   "   window                      %ld\n",
-		   pAC->stats.tx_window_errors);
+				len += sk_proc_print(buffer,
+					"Transmited bytes               %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxOctetsOkCts);
+				len += sk_proc_print(buffer,
+					"Transmited packets             %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxOkCts);
+				len += sk_proc_print(buffer,
+					"Transmit errors                %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+				len += sk_proc_print(buffer,
+					"Transmit dropped               %Lu\n",
+					(unsigned long long) pPnmiStruct->TxNoBufCts);
+				len += sk_proc_print(buffer,
+					"Transmit collisions            %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxSingleCollisionCts);
+				len += sk_proc_print(buffer,
+					"Transmit error types\n");
+				len += sk_proc_print(buffer,
+					"   excessive collision         %ld\n",
+					pAC->stats.tx_aborted_errors);
+				len += sk_proc_print(buffer,
+					"   carrier                     %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxCarrierCts);
+				len += sk_proc_print(buffer,
+					"   fifo underrun               %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxFifoUnderrunCts);
+				len += sk_proc_print(buffer,
+					"   heartbeat                   %Lu\n",
+					(unsigned long long) pPnmiStat->StatTxCarrierCts);
+				len += sk_proc_print(buffer,
+					"   window                      %ld\n",
+					pAC->stats.tx_window_errors);
 				
-	return 0;
+			} /* if (strcmp(pACname, currDeviceName) == 0) */
+		}
+		SkgeProcDev = next;
+	}
 }
 
+/*****************************************************************************
+ *
+ *      sk_proc_print -generic line print  
+ *
+ * Description:
+ *  This function fills the proc entry with statistic data about 
+ *  the ethernet device.
+ *  
+ * Returns: number of bytes written
+ *      
+ */ 
+static int sk_proc_print(void *writePtr, char *format, ...)
+{   
+#define MAX_LEN_SINGLE_LINE 256
+	char     str[MAX_LEN_SINGLE_LINE];
+	va_list  a_start;
+	int      lenght = 0;
+
+	struct seq_file *seq = (struct seq_file *) writePtr;
+
+	SK_MEMSET(str, 0, MAX_LEN_SINGLE_LINE);
+
+	va_start(a_start, format);
+	vsprintf(str, format, a_start);
+	va_end(a_start);
+
+	lenght = strlen(str);
 
+	seq_printf(seq, str);
+	return lenght;
+}
+
+/*****************************************************************************
+ *
+ *      sk_seq_show - show proc information of a particular adapter
+ *
+ * Description:
+ *  This function fills the proc entry with statistic data about 
+ *  the ethernet device. It invokes the generic sk_gen_browse() to
+ *  print out all items one per one.
+ *  
+ * Returns: number of bytes written
+ *      
+ */
+static int sk_seq_show(struct seq_file *seq, void *v)
+{
+    void *castedBuffer = (void *) seq;
+    currDev = seq->private;
+    sk_gen_browse(castedBuffer);
+    return 0;
+}
+
+/*****************************************************************************
+ *
+ *      sk_proc_open - register the show function when proc is open'ed
+ *  
+ * Description:
+ *  This function is called whenever a sk98lin proc file is queried.
+ *  
+ * Returns: the return value of single_open()
+ *      
+ */
 static int sk_proc_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, sk_seq_show, PDE(inode)->data);
+    return single_open(file, sk_seq_show, PDE(inode)->data);
 }
 
-struct file_operations sk_proc_fops = {
-	.owner = THIS_MODULE,
-	.open  = sk_proc_open,
-	.read  = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-#endif
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
diff -purN linux-2.6.1/drivers/net/sk98lin/skqueue.c linux-2.5/drivers/net/sk98lin/skqueue.c
--- linux-2.6.1/drivers/net/sk98lin/skqueue.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skqueue.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	skqueue.c
- * Project:	Gigabit Ethernet Adapters, Schedule-Modul
- * Version:	$Revision: 1.19 $
- * Date:	$Date: 2003/05/13 18:00:07 $
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.20 $
+ * Date:	$Date: 2003/09/16 13:44:00 $
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
@@ -27,6 +27,10 @@
  * History:
  *
  *	$Log: skqueue.c,v $
+ *	Revision 1.20  2003/09/16 13:44:00  rschmidt
+ *	Added (C) Marvell to SysKonnectFileId
+ *	Editorial changes
+ *	
  *	Revision 1.19  2003/05/13 18:00:07  mkarl
  *	Removed calls to RLMT, TWSI, and PNMI for SLIM driver (SK_SLIM).
  *	Editorial changes.
@@ -85,18 +89,16 @@
  *	
  *	Revision 1.1  1998/07/30 15:14:01  gklug
  *	Initial version. Adapted from SMT
- *	
- *	
  *
  ******************************************************************************/
 
 
 /*
-	Event queue and dispatcher
-*/
+ *	Event queue and dispatcher
+ */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.19 2003/05/13 18:00:07 mkarl Exp $" ;
+	"@(#) $Id: skqueue.c,v 1.20 2003/09/16 13:44:00 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
@@ -124,11 +126,11 @@ intro()
 void	SkEventInit(
 SK_AC	*pAC,	/* Adapter context */
 SK_IOC	Ioc,	/* IO context */
-int	Level)	/* Init level */
+int		Level)	/* Init level */
 {
 	switch (Level) {
 	case SK_INIT_DATA:
-		pAC->Event.EvPut = pAC->Event.EvGet = pAC->Event.EvQueue ;
+		pAC->Event.EvPut = pAC->Event.EvGet = pAC->Event.EvQueue;
 		break;
 	default:
 		break;
@@ -144,14 +146,15 @@ SK_U32		Class,	/* Event Class */
 SK_U32		Event,	/* Event to be queued */
 SK_EVPARA	Para)	/* Event parameter */
 {
-	pAC->Event.EvPut->Class = Class ;
-	pAC->Event.EvPut->Event = Event ;
-	pAC->Event.EvPut->Para = Para ;
+	pAC->Event.EvPut->Class = Class;
+	pAC->Event.EvPut->Event = Event;
+	pAC->Event.EvPut->Para = Para;
+	
 	if (++pAC->Event.EvPut == &pAC->Event.EvQueue[SK_MAX_EVENT])
-		pAC->Event.EvPut = pAC->Event.EvQueue ;
+		pAC->Event.EvPut = pAC->Event.EvQueue;
 
 	if (pAC->Event.EvPut == pAC->Event.EvGet) {
-		SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E001, SKERR_Q_E001MSG) ;
+		SK_ERR_LOG(pAC, SK_ERRCL_NORES, SKERR_Q_E001, SKERR_Q_E001MSG);
 	}
 }
 
@@ -168,77 +171,79 @@ int	SkEventDispatcher(
 SK_AC	*pAC,	/* Adapters Context */
 SK_IOC	Ioc)	/* Io context */
 {
-	SK_EVENTELEM	*pEv ;	/* pointer into queue */
-	SK_U32			Class ;
-	int			Rtv ;
-
-	pEv = pAC->Event.EvGet ;
-	PRINTF("dispatch get %x put %x\n",pEv,pAC->Event.ev_put) ;
+	SK_EVENTELEM	*pEv;	/* pointer into queue */
+	SK_U32			Class;
+	int			Rtv;
+
+	pEv = pAC->Event.EvGet;
+	
+	PRINTF("dispatch get %x put %x\n", pEv, pAC->Event.ev_put);
+	
 	while (pEv != pAC->Event.EvPut) {
-		PRINTF("dispatch Class %d Event %d\n",pEv->Class,pEv->Event) ;
-		switch(Class = pEv->Class) {
+		PRINTF("dispatch Class %d Event %d\n", pEv->Class, pEv->Event);
+
+		switch (Class = pEv->Class) {
 #ifndef SK_USE_LAC_EV
 #ifndef SK_SLIM
-		case SKGE_RLMT :	/* RLMT Event */
-			Rtv = SkRlmtEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
-		case SKGE_I2C :		/* I2C Event */
-			Rtv = SkI2cEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
-		case SKGE_PNMI :
-			Rtv = SkPnmiEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+		case SKGE_RLMT:		/* RLMT Event */
+			Rtv = SkRlmtEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
+		case SKGE_I2C:		/* I2C Event */
+			Rtv = SkI2cEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
+		case SKGE_PNMI:		/* PNMI Event */
+			Rtv = SkPnmiEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 #endif	/* not SK_SLIM */
 #endif	/* not SK_USE_LAC_EV */
-		case SKGE_DRV :		/* Driver Event */
-			Rtv = SkDrvEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
-#ifndef SK_USE_SW_TIMER        
-		case SKGE_HWAC :
-			Rtv = SkGeSirqEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+		case SKGE_DRV:		/* Driver Event */
+			Rtv = SkDrvEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
+#ifndef SK_USE_SW_TIMER
+		case SKGE_HWAC:
+			Rtv = SkGeSirqEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 #else /* !SK_USE_SW_TIMER */
-        case SKGE_SWT : 
-			Rtv = SkSwtEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+        case SKGE_SWT :
+			Rtv = SkSwtEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 #endif /* !SK_USE_SW_TIMER */
-#ifdef SK_USE_LAC_EV        
+#ifdef SK_USE_LAC_EV
 		case SKGE_LACP :
-			Rtv = SkLacpEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+			Rtv = SkLacpEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 		case SKGE_RSF :
-			Rtv = SkRsfEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+			Rtv = SkRsfEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 		case SKGE_MARKER :
-			Rtv = SkMarkerEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+			Rtv = SkMarkerEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 		case SKGE_FD :
-			Rtv = SkFdEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+			Rtv = SkFdEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 #endif /* SK_USE_LAC_EV */
 #ifdef	SK_USE_CSUM
 		case SKGE_CSUM :
-			Rtv = SkCsEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+			Rtv = SkCsEvent(pAC, Ioc, pEv->Event, pEv->Para);
+			break;
 #endif	/* SK_USE_CSUM */
 		default :
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_Q_E002,
-				SKERR_Q_E002MSG) ;
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_Q_E002, SKERR_Q_E002MSG);
 			Rtv = 0;
 		}
 
 		if (Rtv != 0) {
-			return(Rtv) ;
+			return(Rtv);
 		}
 
 		if (++pEv == &pAC->Event.EvQueue[SK_MAX_EVENT])
-			pEv = pAC->Event.EvQueue ;
+			pEv = pAC->Event.EvQueue;
 
 		/* Renew get: it is used in queue_events to detect overruns */
 		pAC->Event.EvGet = pEv;
 	}
 
-	return(0) ;
+	return(0);
 }
 
 /* End of file */
diff -purN linux-2.6.1/drivers/net/sk98lin/sktimer.c linux-2.5/drivers/net/sk98lin/sktimer.c
--- linux-2.6.1/drivers/net/sk98lin/sktimer.c	2004-01-09 06:59:08.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/sktimer.c	2004-01-10 16:16:06.000000000 +0000
@@ -1,9 +1,9 @@
 /******************************************************************************
  *
  * Name:	sktimer.c
- * Project:	Gigabit Ethernet Adapters, Schedule-Modul
- * Version:	$Revision: 1.13 $
- * Date:	$Date: 2003/05/13 18:01:01 $
+ * Project:	Gigabit Ethernet Adapters, Event Scheduler Module
+ * Version:	$Revision: 1.14 $
+ * Date:	$Date: 2003/09/16 13:46:51 $
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
@@ -27,6 +27,10 @@
  * History:
  *
  *	$Log: sktimer.c,v $
+ *	Revision 1.14  2003/09/16 13:46:51  rschmidt
+ *	Added (C) Marvell to SysKonnectFileId
+ *	Editorial changes
+ *	
  *	Revision 1.13  2003/05/13 18:01:01  mkarl
  *	Editorial changes.
  *	
@@ -68,19 +72,16 @@
  *	
  *	Revision 1.1  1998/08/05 11:27:55  gklug
  *	first version: adapted from SMT
- *	
- *	
- *	
  *
  ******************************************************************************/
 
 
 /*
-	Event queue and dispatcher
-*/
+ *	Event queue and dispatcher
+ */
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.13 2003/05/13 18:01:01 mkarl Exp $" ;
+	"@(#) $Id: sktimer.c,v 1.14 2003/09/16 13:46:51 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
@@ -110,14 +111,14 @@ static void timer_done(SK_AC *pAC,SK_IOC
 void	SkTimerInit(
 SK_AC	*pAC,		/* Adapters context */
 SK_IOC	Ioc,		/* IoContext */
-int	Level)		/* Init Level */
+int		Level)		/* Init Level */
 {
 	switch (Level) {
 	case SK_INIT_DATA:
-		pAC->Tim.StQueue = 0 ;
+		pAC->Tim.StQueue = 0;
 		break;
 	case SK_INIT_IO:
-		SkHwtInit(pAC,Ioc) ;
+		SkHwtInit(pAC, Ioc);
 		SkTimerDone(pAC, Ioc);
 		break;
 	default:
@@ -134,31 +135,34 @@ SK_AC		*pAC,		/* Adapters context */
 SK_IOC		Ioc,		/* IoContext */
 SK_TIMER	*pTimer)	/* Timer Pointer to be started */
 {
-	SK_TIMER	**ppTimPrev ;
-	SK_TIMER	*pTm ;
+	SK_TIMER	**ppTimPrev;
+	SK_TIMER	*pTm;
 
 	/*
 	 * remove timer from queue
 	 */
-	pTimer->TmActive = SK_FALSE ;
+	pTimer->TmActive = SK_FALSE;
+	
 	if (pAC->Tim.StQueue == pTimer && !pTimer->TmNext) {
-		SkHwtStop(pAC,Ioc) ;
+		SkHwtStop(pAC, Ioc);
 	}
-	for (ppTimPrev = &pAC->Tim.StQueue ; (pTm = *ppTimPrev) ;
+	
+	for (ppTimPrev = &pAC->Tim.StQueue; (pTm = *ppTimPrev);
 		ppTimPrev = &pTm->TmNext ) {
+		
 		if (pTm == pTimer) {
 			/*
 			 * Timer found in queue
 			 * - dequeue it and
 			 * - correct delta of the next timer
 			 */
-			*ppTimPrev = pTm->TmNext ;
+			*ppTimPrev = pTm->TmNext;
 
 			if (pTm->TmNext) {
 				/* correct delta of next timer in queue */
-				pTm->TmNext->TmDelta += pTm->TmDelta ;
+				pTm->TmNext->TmDelta += pTm->TmDelta;
 			}
-			return ;
+			return;
 		}
 	}
 }
@@ -175,65 +179,67 @@ SK_U32		Class,		/* Event Class for this 
 SK_U32		Event,		/* Event Value for this timer */
 SK_EVPARA	Para)		/* Event Parameter for this timer */
 {
-	SK_TIMER	**ppTimPrev ;
-	SK_TIMER	*pTm ;
-	SK_U32		Delta ;
+	SK_TIMER	**ppTimPrev;
+	SK_TIMER	*pTm;
+	SK_U32		Delta;
 
-	Time /= 16 ;		/* input is uS, clock ticks are 16uS */
+	Time /= 16;		/* input is uS, clock ticks are 16uS */
+	
 	if (!Time)
-		Time = 1 ;
+		Time = 1;
 
-	SkTimerStop(pAC,Ioc,pTimer) ;
+	SkTimerStop(pAC, Ioc, pTimer);
 
-	pTimer->TmClass = Class ;
-	pTimer->TmEvent = Event ;
-	pTimer->TmPara = Para ;
-	pTimer->TmActive = SK_TRUE ;
+	pTimer->TmClass = Class;
+	pTimer->TmEvent = Event;
+	pTimer->TmPara = Para;
+	pTimer->TmActive = SK_TRUE;
 
 	if (!pAC->Tim.StQueue) {
 		/* First Timer to be started */
-		pAC->Tim.StQueue = pTimer ;
-		pTimer->TmNext = 0 ;
-		pTimer->TmDelta = Time ;
-		SkHwtStart(pAC,Ioc,Time) ;
-		return ;
+		pAC->Tim.StQueue = pTimer;
+		pTimer->TmNext = 0;
+		pTimer->TmDelta = Time;
+		
+		SkHwtStart(pAC, Ioc, Time);
+		
+		return;
 	}
 
 	/*
 	 * timer correction
 	 */
-	timer_done(pAC,Ioc,0) ;
+	timer_done(pAC, Ioc, 0);
 
 	/*
 	 * find position in queue
 	 */
-	Delta = 0 ;
-	for (ppTimPrev = &pAC->Tim.StQueue ; (pTm = *ppTimPrev) ;
+	Delta = 0;
+	for (ppTimPrev = &pAC->Tim.StQueue; (pTm = *ppTimPrev);
 		ppTimPrev = &pTm->TmNext ) {
+		
 		if (Delta + pTm->TmDelta > Time) {
 			/* Position found */
 			/* Here the timer needs to be inserted. */
-			break ;
+			break;
 		}
-		Delta += pTm->TmDelta ;
+		Delta += pTm->TmDelta;
 	}
 
 	/* insert in queue */
-	*ppTimPrev = pTimer ;
-	pTimer->TmNext = pTm ;
-	pTimer->TmDelta = Time - Delta ;
+	*ppTimPrev = pTimer;
+	pTimer->TmNext = pTm;
+	pTimer->TmDelta = Time - Delta;
 
 	if (pTm) {
 		/* There is a next timer
 		 * -> correct its Delta value.
 		 */
-		pTm->TmDelta -= pTimer->TmDelta ;
+		pTm->TmDelta -= pTimer->TmDelta;
 	}
 
-	/*
-	 * start new with first
-	 */
-	SkHwtStart(pAC,Ioc,pAC->Tim.StQueue->TmDelta) ;
+	/* restart with first */
+	SkHwtStart(pAC, Ioc, pAC->Tim.StQueue->TmDelta);
 }
 
 
@@ -241,55 +247,56 @@ void	SkTimerDone(
 SK_AC	*pAC,		/* Adapters context */
 SK_IOC	Ioc)		/* IoContext */
 {
-	timer_done(pAC,Ioc,1) ;
+	timer_done(pAC, Ioc, 1);
 }
 
 
 static void	timer_done(
 SK_AC	*pAC,		/* Adapters context */
 SK_IOC	Ioc,		/* IoContext */
-int	Restart)	/* Do we need to restart the Hardware timer ? */
+int		Restart)	/* Do we need to restart the Hardware timer ? */
 {
-	SK_U32		Delta ;
-	SK_TIMER	*pTm ;
-	SK_TIMER	*pTComp ;	/* Timer completed now now */
-	SK_TIMER	**ppLast ;	/* Next field of Last timer to be deq */
-	int		Done = 0 ;
-
-	Delta = SkHwtRead(pAC,Ioc) ;
-	ppLast = &pAC->Tim.StQueue ;
-	pTm = pAC->Tim.StQueue ;
+	SK_U32		Delta;
+	SK_TIMER	*pTm;
+	SK_TIMER	*pTComp;	/* Timer completed now now */
+	SK_TIMER	**ppLast;	/* Next field of Last timer to be deq */
+	int		Done = 0;
+
+	Delta = SkHwtRead(pAC, Ioc);
+	
+	ppLast = &pAC->Tim.StQueue;
+	pTm = pAC->Tim.StQueue;
 	while (pTm && !Done) {
 		if (Delta >= pTm->TmDelta) {
 			/* Timer ran out */
-			pTm->TmActive = SK_FALSE ;
-			Delta -= pTm->TmDelta ;
-			ppLast = &pTm->TmNext ;
-			pTm = pTm->TmNext ;
-		} else {
+			pTm->TmActive = SK_FALSE;
+			Delta -= pTm->TmDelta;
+			ppLast = &pTm->TmNext;
+			pTm = pTm->TmNext;
+		}
+		else {
 			/* We found the first timer that did not run out */
-			pTm->TmDelta -= Delta ;
-			Delta = 0 ;
-			Done = 1 ;
+			pTm->TmDelta -= Delta;
+			Delta = 0;
+			Done = 1;
 		}
 	}
-	*ppLast = 0 ;
+	*ppLast = 0;
 	/*
 	 * pTm points to the first Timer that did not run out.
 	 * StQueue points to the first Timer that run out.
 	 */
 
-	for ( pTComp = pAC->Tim.StQueue ; pTComp ; pTComp = pTComp->TmNext) {
-		SkEventQueue(pAC,pTComp->TmClass, pTComp->TmEvent,
-			pTComp->TmPara) ;
+	for ( pTComp = pAC->Tim.StQueue; pTComp; pTComp = pTComp->TmNext) {
+		SkEventQueue(pAC,pTComp->TmClass, pTComp->TmEvent, pTComp->TmPara);
 	}
 
 	/* Set head of timer queue to the first timer that did not run out */
-	pAC->Tim.StQueue = pTm ;
+	pAC->Tim.StQueue = pTm;
 
 	if (Restart && pAC->Tim.StQueue) {
 		/* Restart HW timer */
-		SkHwtStart(pAC,Ioc,pAC->Tim.StQueue->TmDelta) ;
+		SkHwtStart(pAC, Ioc, pAC->Tim.StQueue->TmDelta);
 	}
 }
 
diff -purN linux-2.6.1/drivers/net/sk98lin/skxmac2.c linux-2.5/drivers/net/sk98lin/skxmac2.c
--- linux-2.6.1/drivers/net/sk98lin/skxmac2.c	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/drivers/net/sk98lin/skxmac2.c	2004-01-10 16:16:06.000000000 +0000
@@ -2,8 +2,8 @@
  *
  * Name:	skxmac2.c
  * Project:	Gigabit Ethernet Adapters, Common Modules
- * Version:	$Revision: 1.99 $
- * Date:	$Date: 2003/07/11 12:19:33 $
+ * Version:	$Revision: 1.102 $
+ * Date:	$Date: 2003/10/02 16:53:58 $
  * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
@@ -27,6 +27,23 @@
  * History:
  *
  *	$Log: skxmac2.c,v $
+ *	Revision 1.102  2003/10/02 16:53:58  rschmidt
+ *	Changed setting of GMAC parameters with new macros.
+ *	Added define SLIM around SkGm...LowPowerMode().
+ *	Editorial changes.
+ *	
+ *	Revision 1.101  2003/09/16 14:49:07  rschmidt
+ *	Added routines SkGmClearRst(), SkXmClearRst, SkMacClearRst().
+ *	Added WA code for Yukon-Lite's COMA mode in SkGmHardRst().
+ *	Replaced PCI-Config R/W through internal access.
+ *	Fixed return from coma mode in SkGmLeaveLowPowerMode().
+ *	Fixed compiler warnings for different types.
+ *	Editorial changes.
+ *	
+ *	Revision 1.100  2003/09/16 07:09:11  mschmid
+ *	Added functions SkGmEnterLowPowerMode() and
+ *	SkGmLeaveLowPowerMode()
+ *	
  *	Revision 1.99  2003/07/11 12:19:33  rschmidt
  *	Reduced init values for Master & Slave downshift counters to
  *	minimum values.
@@ -164,7 +181,7 @@
  *	Revision 1.74  2002/08/12 14:00:17  rschmidt
  *	Replaced usage of Broadcom PHY Ids with defines.
  *	Corrected error messages in SkGmMacStatistic().
- *	Made SkMacPromiscMode() public for ADDR-Modul.
+ *	Made SkMacPromiscMode() public for ADDR-Module.
  *	Editorial changes.
  *	
  *	Revision 1.73  2002/08/08 16:26:24  rschmidt
@@ -475,7 +492,7 @@ typedef struct s_PhyHack {
 
 #if (defined(DEBUG) || ((!defined(LINT)) && (!defined(SK_SLIM))))
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skxmac2.c,v 1.99 2003/07/11 12:19:33 rschmidt Exp $ (C) Marvell.";
+	"@(#) $Id: skxmac2.c,v 1.102 2003/10/02 16:53:58 rschmidt Exp $ (C) Marvell.";
 #endif
 
 #ifdef GENESIS
@@ -1343,7 +1360,7 @@ int		Port)	/* Port Index (MAC_1 + n) */
  * Description:
  *	The XMAC of the specified 'Port' and all connected devices
  *	(PHY and SERDES) will receive a reset signal on its *Reset pins.
- *	External PHYs must be reset be clearing a bit in the GPIO register
+ *	External PHYs must be reset by clearing a bit in the GPIO register
  *  (Timing requirements: Broadcom: 400ns, Level One: none, National: 80ns).
  *
  * ATTENTION:
@@ -1386,23 +1403,62 @@ int		Port)	/* Port Index (MAC_1 + n) */
 
 	/* For external PHYs there must be special handling */
 	if (pAC->GIni.GP[Port].PhyType != SK_PHY_XMAC) {
-		/* reset external PHY */
+		
 		SK_IN32(IoC, B2_GP_IO, &Reg);
+		
 		if (Port == 0) {
-			Reg |= GP_DIR_0; /* set to output */
-			Reg &= ~GP_IO_0;
+			Reg |= GP_DIR_0; 	/* set to output */
+			Reg &= ~GP_IO_0;	/* set PHY reset (active low) */
 		}
 		else {
-			Reg |= GP_DIR_2; /* set to output */
-			Reg &= ~GP_IO_2;
+			Reg |= GP_DIR_2;	/* set to output */
+			Reg &= ~GP_IO_2;	/* set PHY reset (active low) */
 		}
+		/* reset external PHY */
 		SK_OUT32(IoC, B2_GP_IO, Reg);
 
 		/* short delay */
 		SK_IN32(IoC, B2_GP_IO, &Reg);
 	}
-
 }	/* SkXmHardRst */
+
+
+/******************************************************************************
+ *
+ *	SkXmClearRst() - Release the PHY & XMAC reset
+ *
+ * Description:
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkXmClearRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U32	DWord;
+	
+	/* clear HW reset */
+	SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_MAC_RST);
+
+	if (pAC->GIni.GP[Port].PhyType != SK_PHY_XMAC) {
+
+		SK_IN32(IoC, B2_GP_IO, &DWord);
+
+		if (Port == 0) {
+			DWord |= (GP_DIR_0 | GP_IO_0); /* set to output */
+		}
+		else {
+			DWord |= (GP_DIR_2 | GP_IO_2); /* set to output */
+		}
+		/* Clear PHY reset */
+		SK_OUT32(IoC, B2_GP_IO, DWord);
+
+		/* Enable GMII interface */
+		XM_OUT16(IoC, Port, XM_HW_CFG, XM_HW_GMII_MD);
+	}
+}	/* SkXmClearRst */
 #endif /* GENESIS */
 
 
@@ -1452,10 +1508,6 @@ int		Port)	/* Port Index (MAC_1 + n) */
  *
  * Description:
  *
- * ATTENTION:
- * 	It is absolutely necessary to reset the SW_RST Bit first
- *	before calling this function.
- *
  * Returns:
  *	nothing
  */
@@ -1464,6 +1516,20 @@ SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
 int		Port)	/* Port Index (MAC_1 + n) */
 {
+	SK_U32	DWord;
+	
+	/* WA code for COMA mode */
+	if (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+		
+		SK_IN32(IoC, B2_GP_IO, &DWord);
+
+		DWord |= (GP_DIR_9 | GP_IO_9);
+
+		/* set PHY reset */
+		SK_OUT32(IoC, B2_GP_IO, DWord);
+	}
+
 	/* set GPHY Control reset */
 	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), GPC_RST_SET);
 
@@ -1471,6 +1537,73 @@ int		Port)	/* Port Index (MAC_1 + n) */
 	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
 
 }	/* SkGmHardRst */
+
+
+/******************************************************************************
+ *
+ *	SkGmClearRst() - Release the GPHY & GMAC reset
+ *
+ * Description:
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkGmClearRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U32	DWord;
+	
+#ifdef XXX
+		/* clear GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_CLR);
+
+		/* set GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+#endif /* XXX */
+
+	/* WA code for COMA mode */
+	if (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+		
+		SK_IN32(IoC, B2_GP_IO, &DWord);
+
+		DWord |= GP_DIR_9;		/* set to output */
+		DWord &= ~GP_IO_9;		/* clear PHY reset (active high) */
+
+		/* clear PHY reset */
+		SK_OUT32(IoC, B2_GP_IO, DWord);
+	}
+
+	/* set HWCFG_MODE */
+	DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
+		GPC_ENA_XC | GPC_ANEG_ADV_ALL_M | GPC_ENA_PAUSE |
+		(pAC->GIni.GICopperType ? GPC_HWCFG_GMII_COP :
+		GPC_HWCFG_GMII_FIB);
+
+	/* set GPHY Control reset */
+	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_SET);
+
+	/* release GPHY Control reset */
+	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
+
+#ifdef VCPU
+	VCpuWait(9000);
+#endif /* VCPU */
+
+	/* clear GMAC Control reset */
+	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_ON | GMC_RST_CLR);
+
+#ifdef VCPU
+	VCpuWait(2000);
+	
+	SK_IN32(IoC, MR_ADDR(Port, GPHY_CTRL), &DWord);
+			
+	SK_IN32(IoC, B0_ISRC, &DWord);
+#endif /* VCPU */
+
+}	/* SkGmClearRst */
 #endif /* YUKON */
 
 
@@ -1553,6 +1686,38 @@ int		Port)	/* Port Index (MAC_1 + n) */
 }	/* SkMacHardRst */
 
 
+/******************************************************************************
+ *
+ *	SkMacClearRst() - Clear the MAC reset
+ *
+ * Description:	calls a clear MAC reset routine dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacClearRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	
+#ifdef GENESIS
+	if (pAC->GIni.GIGenesis) {
+		
+		SkXmClearRst(pAC, IoC, Port);
+	}
+#endif /* GENESIS */
+	
+#ifdef YUKON
+	if (pAC->GIni.GIYukon) {
+		
+		SkGmClearRst(pAC, IoC, Port);
+	}
+#endif /* YUKON */
+
+}	/* SkMacClearRst */
+
+
 #ifdef GENESIS
 /******************************************************************************
  *
@@ -1574,7 +1739,6 @@ SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
-	SK_U32		Reg;
 	int			i;
 	SK_U16		SWord;
 
@@ -1594,32 +1758,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	}
 
 	if (pPrt->PState == SK_PRT_RESET) {
-		/*
-		 * clear HW reset
-		 * Note: The SW reset is self clearing, therefore there is
-		 *	 nothing to do here.
-		 */
-		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_MAC_RST);
 
-		/* Ensure that XMAC reset release is done (errata from LReinbold?) */
-		SK_IN16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), &SWord);
+		SkXmClearRst(pAC, IoC, Port);
 
-		/* Clear PHY reset */
 		if (pPrt->PhyType != SK_PHY_XMAC) {
-
-			SK_IN32(IoC, B2_GP_IO, &Reg);
-			
-			if (Port == 0) {
-				Reg |= (GP_DIR_0 | GP_IO_0); /* set to output */
-			}
-			else {
-				Reg |= (GP_DIR_2 | GP_IO_2); /* set to output */
-			}
-			SK_OUT32(IoC, B2_GP_IO, Reg);
-
-			/* Enable GMII interface */
-			XM_OUT16(IoC, Port, XM_HW_CFG, XM_HW_GMII_MD);
-
 			/* read Id from external PHY (all have the same address) */
 			SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_ID1, &pPrt->PhyId1);
 
@@ -1831,43 +1973,11 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	}
 
 	if (pPrt->PState == SK_PRT_RESET) {
-		/* set GPHY Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), GPC_RST_SET);
-
-		/* set GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
-
-#ifdef XXX
-		/* clear GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_CLR);
-
-		/* set GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
-#endif /* XXX */
-
-		/* set HWCFG_MODE */
-		DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
-			GPC_ENA_XC | GPC_ANEG_ADV_ALL_M | GPC_ENA_PAUSE |
-			(pAC->GIni.GICopperType ? GPC_HWCFG_GMII_COP :
-			GPC_HWCFG_GMII_FIB);
-
-		/* set GPHY Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_SET);
-
-		/* release GPHY Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
-
-#ifdef VCPU
-		VCpuWait(9000);
-#endif /* VCPU */
-
-		/* clear GMAC Control reset */
-		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_ON | GMC_RST_CLR);
-
-#ifdef VCPU
-		VCpuWait(2000);
-#endif /* VCPU */
+		
+		SkGmHardRst(pAC, IoC, Port);
 
+		SkGmClearRst(pAC, IoC, Port);
+		
 		/* Auto-negotiation ? */
 		if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 			/* Auto-negotiation disabled */
@@ -1906,6 +2016,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 			SWord |= GM_GPCR_DUP_FULL;
 		}
 
+		/* flow-control settings */
 		switch (pPrt->PFlowCtrlMode) {
 		case SK_FLOW_MODE_NONE:
 			/* set Pause Off */
@@ -1940,7 +2051,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	(void)SkGmResetCounter(pAC, IoC, Port);
 
 	/* setup Transmit Control Register */
-	GM_OUT16(IoC, Port, GM_TX_CTRL, GM_TXCR_COL_THR);
+	GM_OUT16(IoC, Port, GM_TX_CTRL, TX_COL_THR(pPrt->PMacColThres));
 
 	/* setup Receive Control Register */
 	GM_OUT16(IoC, Port, GM_RX_CTRL, GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA |
@@ -1954,7 +2065,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	GM_IN16(IoC, Port, GM_TX_PARAM, &SWord);
 #endif /* VCPU */
 
-    SWord = (SK_U16)(JAM_LEN_VAL(3) | JAM_IPG_VAL(11) | IPG_JAM_DATA(26));
+    SWord = TX_JAM_LEN_VAL(pPrt->PMacJamLen) |
+			TX_JAM_IPG_VAL(pPrt->PMacJamIpgVal) |
+			TX_IPG_JAM_DATA(pPrt->PMacJamIpgData);
 	
 	GM_OUT16(IoC, Port, GM_TX_PARAM, SWord);
 
@@ -1963,7 +2076,12 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	GM_IN16(IoC, Port, GM_SERIAL_MODE, &SWord);
 #endif /* VCPU */
 	
-	SWord = GM_SMOD_VLAN_ENA | IPG_VAL_FAST_ETH;
+	SWord = GM_SMOD_VLAN_ENA | IPG_DATA_VAL(pPrt->PMacIpgData);
+
+	if (pPrt->PMacLimit4) {
+		/* reset of collision counter after 4 consecutive collisions */
+		SWord |= GM_SMOD_LIMIT_4;
+	}
 
 	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
 		/* enable jumbo mode (Max. Frame Length = 9018) */
@@ -2021,11 +2139,13 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	GM_OUT16(IoC, Port, GM_RX_IRQ_MSK, 0);
 	GM_OUT16(IoC, Port, GM_TR_IRQ_MSK, 0);
 
+#if defined(SK_DIAG) || defined(DEBUG)
 	/* read General Purpose Status */
 	GM_IN16(IoC, Port, GM_GP_STAT, &SWord);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("MAC Stat Reg=0x%04X\n", SWord));
+		("MAC Stat Reg.=0x%04X\n", SWord));
+#endif /* SK_DIAG || DEBUG */
 
 #ifdef SK_DIAG
 	c_print("MAC Stat Reg=0x%04X\n", SWord);
@@ -2226,6 +2346,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 				SKERR_HWI_E015MSG);
 		}
 
+		/* Set Flow-control capabilities */
 		switch (pPrt->PFlowCtrlMode) {
 		case SK_FLOW_MODE_NONE:
 			Ctrl |= PHY_X_P_NO_PAUSE;
@@ -2306,7 +2427,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("InitPhyBcom: no auto-negotiation Port %d\n", Port));
 		/* Set DuplexMode in Config register */
-		Ctrl1 |= (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
+		if (pPrt->PLinkMode == SK_LMODE_FULL) {
+			Ctrl1 |= PHY_CT_DUP_MD;
+		}
 
 		/* Determine Master/Slave manually if not already done */
 		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
@@ -2346,6 +2469,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 				SKERR_HWI_E015MSG);
 		}
 
+		/* Set Flow-control capabilities */
 		switch (pPrt->PFlowCtrlMode) {
 		case SK_FLOW_MODE_NONE:
 			Ctrl3 |= PHY_B_P_NO_PAUSE;
@@ -2375,12 +2499,12 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* Write 1000Base-T Control Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, Ctrl2);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
+		("Set 1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
 	
 	/* Write AutoNeg Advertisement Register */
 	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, Ctrl3);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
+		("Set Auto-Neg.Adv.Reg=0x%04X\n", Ctrl3));
 	
 	if (DoLoop) {
 		/* Set the Phy Loopback bit, too */
@@ -2409,6 +2533,281 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 
 #ifdef YUKON
+#ifndef SK_SLIM
+/******************************************************************************
+ *
+ *	SkGmEnterLowPowerMode()
+ *
+ * Description:	
+ *	This function sets the Marvell Alaska PHY to the low power mode
+ *	given by parameter mode.
+ *	The following low power modes are available:
+ *		
+ *		- Coma Mode (Deep Sleep):
+ *			Power consumption: ~15 - 30 mW
+ *			The PHY cannot wake up on its own.
+ *
+ *		- IEEE 22.2.4.1.5 compatible power down mode
+ *			Power consumption: ~240 mW
+ *			The PHY cannot wake up on its own.
+ *
+ *		- energy detect mode
+ *			Power consumption: ~160 mW
+ *			The PHY can wake up on its own by detecting activity
+ *			on the CAT 5 cable.
+ *
+ *		- energy detect plus mode
+ *			Power consumption: ~150 mW
+ *			The PHY can wake up on its own by detecting activity
+ *			on the CAT 5 cable.
+ *			Connected devices can be woken up by sending normal link
+ *			pulses every one second.
+ *
+ * Note:
+ *
+ * Returns:
+ *		0: ok
+ *		1: error
+ */
+int SkGmEnterLowPowerMode(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (e.g. MAC_1) */
+SK_U8	Mode)		/* low power mode */
+{
+	SK_U16	Word;
+	SK_U32	DWord;
+	SK_U8	LastMode;
+	int		Ret = 0;
+
+	if (pAC->GIni.GIYukonLite &&
+	    pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+
+		/* save current power mode */
+		LastMode = pAC->GIni.GP[Port].PPhyPowerState;
+		pAC->GIni.GP[Port].PPhyPowerState = Mode;
+
+		switch (Mode) {
+			/* coma mode (deep sleep) */
+			case PHY_PM_DEEP_SLEEP:
+				/* setup General Purpose Control Register */
+				GM_OUT16(IoC, 0, GM_GP_CTRL, GM_GPCR_FL_PASS |
+					GM_GPCR_SPEED_100 | GM_GPCR_AU_ALL_DIS);
+
+				/* apply COMA mode workaround */
+				SkGmPhyWrite(pAC, IoC, Port, 29, 0x001f);
+				SkGmPhyWrite(pAC, IoC, Port, 30, 0xfff3);
+
+				SK_IN32(IoC, PCI_C(PCI_OUR_REG_1), &DWord);
+
+				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+				
+				/* Set PHY to Coma Mode */
+				SK_OUT32(IoC, PCI_C(PCI_OUR_REG_1), DWord | PCI_PHY_COMA);
+				
+				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+
+			break;
+			
+			/* IEEE 22.2.4.1.5 compatible power down mode */
+			case PHY_PM_IEEE_POWER_DOWN:
+				/*
+				 * - disable MAC 125 MHz clock
+				 * - allow MAC power down
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+				Word |= PHY_M_PC_DIS_125CLK;
+				Word &=	~PHY_M_PC_MAC_POW_UP;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+				/*
+				 * register changes must be followed by a software
+				 * reset to take effect
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+				Word |= PHY_CT_RESET;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+
+				/* switch IEEE compatible power down mode on */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+				Word |= PHY_CT_PDOWN;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+			break;
+
+			/* energy detect and energy detect plus mode */
+			case PHY_PM_ENERGY_DETECT:
+			case PHY_PM_ENERGY_DETECT_PLUS:
+				/*
+				 * - disable MAC 125 MHz clock
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+				Word |= PHY_M_PC_DIS_125CLK;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+				
+				/* activate energy detect mode 1 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+
+				/* energy detect mode */
+				if (Mode == PHY_PM_ENERGY_DETECT) {
+					Word |= PHY_M_PC_EN_DET;
+				}
+				/* energy detect plus mode */
+				else {
+					Word |= PHY_M_PC_EN_DET_PLUS;
+				}
+
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+				/*
+				 * reinitialize the PHY to force a software reset
+				 * which is necessary after the register settings
+				 * for the energy detect modes.
+				 * Furthermore reinitialisation prevents that the
+				 * PHY is running out of a stable state.
+				 */
+				SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
+			break;
+
+			/* don't change current power mode */
+			default:
+				pAC->GIni.GP[Port].PPhyPowerState = LastMode;
+				Ret = 1;
+			break;
+		}
+	}
+	/* low power modes are not supported by this chip */
+	else {
+		Ret = 1;
+	}
+
+	return(Ret);
+
+}	/* SkGmEnterLowPowerMode */
+
+/******************************************************************************
+ *
+ *	SkGmLeaveLowPowerMode()
+ *
+ * Description:	
+ *	Leave the current low power mode and switch to normal mode
+ *
+ * Note:
+ *
+ * Returns:
+ *		0:	ok
+ *		1:	error
+ */
+int SkGmLeaveLowPowerMode(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (e.g. MAC_1) */
+{
+	SK_U32	DWord;
+	SK_U16	Word;
+	SK_U8	LastMode;
+	int		Ret = 0;
+
+	if (pAC->GIni.GIYukonLite &&
+		pAC->GIni.GIChipRev == CHIP_REV_YU_LITE_A3) {
+
+		/* save current power mode */
+		LastMode = pAC->GIni.GP[Port].PPhyPowerState;
+		pAC->GIni.GP[Port].PPhyPowerState = PHY_PM_OPERATIONAL_MODE;
+
+		switch (LastMode) {
+			/* coma mode (deep sleep) */
+			case PHY_PM_DEEP_SLEEP:
+				SK_IN32(IoC, PCI_C(PCI_OUR_REG_1), &DWord);
+
+				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
+				
+				/* Release PHY from Coma Mode */
+				SK_OUT32(IoC, PCI_C(PCI_OUR_REG_1), DWord & ~PCI_PHY_COMA);
+				
+				SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
+				
+				SK_IN32(IoC, B2_GP_IO, &DWord);
+
+				/* set to output */
+				DWord |= (GP_DIR_9 | GP_IO_9);
+
+				/* set PHY reset */
+				SK_OUT32(IoC, B2_GP_IO, DWord);
+
+				DWord &= ~GP_IO_9; /* clear PHY reset (active high) */
+
+				/* clear PHY reset */
+				SK_OUT32(IoC, B2_GP_IO, DWord);
+			break;
+			
+			/* IEEE 22.2.4.1.5 compatible power down mode */
+			case PHY_PM_IEEE_POWER_DOWN:
+				/*
+				 * - enable MAC 125 MHz clock
+				 * - set MAC power up
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+				Word &= ~PHY_M_PC_DIS_125CLK;
+				Word |=	PHY_M_PC_MAC_POW_UP;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+				/*
+				 * register changes must be followed by a software
+				 * reset to take effect
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+				Word |= PHY_CT_RESET;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+
+				/* switch IEEE compatible power down mode off */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &Word);
+				Word &= ~PHY_CT_PDOWN;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, Word);
+			break;
+
+			/* energy detect and energy detect plus mode */
+			case PHY_PM_ENERGY_DETECT:
+			case PHY_PM_ENERGY_DETECT_PLUS:
+				/*
+				 * - enable MAC 125 MHz clock
+				 */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+				Word &= ~PHY_M_PC_DIS_125CLK;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+				
+				/* disable energy detect mode */
+				SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_CTRL, &Word);
+				Word &= ~PHY_M_PC_EN_DET_MSK;
+				SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, Word);
+
+				/*
+				 * reinitialize the PHY to force a software reset
+				 * which is necessary after the register settings
+				 * for the energy detect modes.
+				 * Furthermore reinitialisation prevents that the
+				 * PHY is running out of a stable state.
+				 */
+				SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
+			break;
+
+			/* don't change current power mode */
+			default:
+				pAC->GIni.GP[Port].PPhyPowerState = LastMode;
+				Ret = 1;
+			break;
+		}
+	}
+	/* low power modes are not supported by this chip */
+	else {
+		Ret = 1;
+	}
+
+	return(Ret);
+
+}	/* SkGmLeaveLowPowerMode */
+#endif /* !SK_SLIM */
+
+
 /******************************************************************************
  *
  *	SkGmInitPhyMarv() - Initialize the Marvell Phy registers
@@ -2457,7 +2856,6 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	VCPUprintf(0, "SkGmInitPhyMarv(), Port=%u, DoLoop=%u\n",
 		Port, DoLoop);
 #else /* VCPU */
-	
 	if (DoLoop) {
 		/* Set 'MAC Power up'-bit, set Manual MDI configuration */
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
@@ -2475,16 +2873,20 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	
 		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL, ExtPhyCtrl);
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
+			("Set Ext. PHY Ctrl=0x%04X\n", ExtPhyCtrl));
 	}
 
 	/* Read PHY Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
 
+	if (!AutoNeg) {
+		/* Disable Auto-negotiation */
+		PhyCtrl &= ~PHY_CT_ANE;
+	}
+
 	PhyCtrl |= PHY_CT_RESET;
 	/* Assert software reset */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
-
 #endif /* VCPU */
 
 	PhyCtrl = 0 /* PHY_CT_COL_TST */;
@@ -2533,13 +2935,9 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 		if (!DoLoop) {
 			PhyCtrl |= PHY_CT_RESET;
 		}
-		/*
-		 * Do NOT enable Auto-negotiation here. This would hold
-		 * the link down because no IDLES are transmitted
-		 */
 	}
 	else {
-		PhyCtrl |= PHY_CT_ANE;
+		/* Set Auto-negotiation advertisement */
 		
 		if (pAC->GIni.GICopperType) {
 			/* Set Speed capabilities */
@@ -2554,6 +2952,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 				break;
 			case SK_LSPEED_100MBPS:
 				AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
+					/* advertise 10Base-T also */
 					PHY_M_AN_10_FD | PHY_M_AN_10_HD;
 				break;
 			case SK_LSPEED_10MBPS:
@@ -2581,7 +2980,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 					SKERR_HWI_E015MSG);
 			}
 			
-			/* Set Auto-negotiation advertisement */
+			/* Set Flow-control capabilities */
 			switch (pPrt->PFlowCtrlMode) {
 			case SK_FLOW_MODE_NONE:
 				AutoNegAdv |= PHY_B_P_NO_PAUSE;
@@ -2618,7 +3017,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 					SKERR_HWI_E015MSG);
 			}
 			
-			/* Set Auto-negotiation advertisement */
+			/* Set Flow-control capabilities */
 			switch (pPrt->PFlowCtrlMode) {
 			case SK_FLOW_MODE_NONE:
 				AutoNegAdv |= PHY_M_P_NO_PAUSE_X;
@@ -2640,7 +3039,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 		if (!DoLoop) {
 			/* Restart Auto-negotiation */
-			PhyCtrl |= PHY_CT_RE_CFG;
+			PhyCtrl |= PHY_CT_ANE | PHY_CT_RE_CFG;
 		}
 	}
 	
@@ -2659,12 +3058,12 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* Write 1000Base-T Control Register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_1000T_CTRL, C1000BaseT);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("1000B-T Ctrl=0x%04X\n", C1000BaseT));
+		("Set 1000B-T Ctrl =0x%04X\n", C1000BaseT));
 	
 	/* Write AutoNeg Advertisement Register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV, AutoNegAdv);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Auto-Neg.Ad.=0x%04X\n", AutoNegAdv));
+		("Set Auto-Neg.Adv.=0x%04X\n", AutoNegAdv));
 #endif /* VCPU */
 	
 	if (DoLoop) {
@@ -2694,6 +3093,8 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 	/* Write to the PHY Control register */
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Set PHY Ctrl Reg.=0x%04X\n", PhyCtrl));
 
 #ifdef VCPU
 	VCpuWait(2000);
@@ -2712,7 +3113,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_CTRL, LedCtrl);
 
 	if ((pAC->GIni.GILedBlinkCtrl & SK_LED_LINK100_ON) != 0) {
-		/* only in forced 100Mbps mode */
+		/* only in forced 100 Mbps mode */
 		if (!AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_100MBPS) {
 
 			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_OVER,
@@ -2741,7 +3142,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* Read AutoNeg Advertisement Register */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &AutoNegAdv);
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("Auto-Neg. Ad.=0x%04X\n", AutoNegAdv));
+		("Auto-Neg.Adv.=0x%04X\n", AutoNegAdv));
 	
 	/* Read Ext. PHY Specific Control */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
@@ -2818,13 +3219,15 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 	/* Auto-negotiation ? */
 	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		/*
-		 * level one spec say: "1000Mbps: manual mode not allowed"
+		 * level one spec say: "1000 Mbps: manual mode not allowed"
 		 * but lets see what happens...
 		 */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("InitPhyLone: no auto-negotiation Port %d\n", Port));
 		/* Set DuplexMode in Config register */
-		Ctrl1 = (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
+		if (pPrt->PLinkMode == SK_LMODE_FULL) {
+			Ctrl1 |= PHY_CT_DUP_MD;
+		}
 
 		/* Determine Master/Slave manually if not already done */
 		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
@@ -2857,6 +3260,7 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 				SKERR_HWI_E015MSG);
 		}
 
+		/* Set Flow-control capabilities */
 		switch (pPrt->PFlowCtrlMode) {
 		case SK_FLOW_MODE_NONE:
 			Ctrl3 |= PHY_L_P_NO_PAUSE;
@@ -2877,7 +3281,6 @@ SK_BOOL	DoLoop)		/* Should a Phy LoopBac
 
 		/* Restart Auto-negotiation */
 		Ctrl1 = PHY_CT_ANE | PHY_CT_RE_CFG;
-
 	}
 	
 	/* Write 1000Base-T Control Register */
@@ -3019,10 +3422,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 	/* Check Duplex mismatch */
 	if ((ResAb & (PHY_X_RS_HD | PHY_X_RS_FD)) == PHY_X_RS_FD) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOFULL;
 	}
 	else if ((ResAb & (PHY_X_RS_HD | PHY_X_RS_FD)) == PHY_X_RS_HD) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	else {
 		/* Error */
@@ -3055,7 +3458,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* PAUSE mismatch -> no PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 	}
-	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+	pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_1000MBPS;
 
 	return(SK_AND_OK);
 }	/* SkXmAutoNegDoneXmac */
@@ -3110,10 +3513,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 	/* Check Duplex mismatch */
 	if ((AuxStat & PHY_B_AS_AN_RES_MSK) == PHY_B_RES_1000FD) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOFULL;
 	}
 	else if ((AuxStat & PHY_B_AS_AN_RES_MSK) == PHY_B_RES_1000HD) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	else {
 		/* Error */
@@ -3156,7 +3559,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		/* PAUSE mismatch -> no PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 	}
-	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+	pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_1000MBPS;
 
 	return(SK_AND_OK);
 }	/* SkXmAutoNegDoneBcom */
@@ -3192,6 +3595,8 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 	/* Get PHY parameters */
 	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_LP, &LPAb);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Link P.Abil.=0x%04X\n", LPAb));
 	
 	if ((LPAb & PHY_M_AN_RF) != 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
@@ -3222,15 +3627,15 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("AutoNegFail: Speed & Duplex not resolved, Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_UNKNOWN;
 		return(SK_AND_DUP_CAP);
 	}
 	
 	if ((AuxStat & PHY_M_PS_FULL_DUP) != 0) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOFULL;
 	}
 	else {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	
 	/* Check PAUSE mismatch ??? */
@@ -3255,13 +3660,13 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* set used link speed */
 	switch ((unsigned)(AuxStat & PHY_M_PS_SPEED_MSK)) {
 	case (unsigned)PHY_M_PS_SPEED_1000:
-		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_1000MBPS;
 		break;
 	case PHY_M_PS_SPEED_100:
-		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_100MBPS;
+		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_100MBPS;
 		break;
 	default:
-		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_10MBPS;
+		pPrt->PLinkSpeedUsed = (SK_U8)SK_LSPEED_STAT_10MBPS;
 	}
 
 	return(SK_AND_OK);
@@ -3312,10 +3717,10 @@ int		Port)		/* Port Index (MAC_1 + n) */
 
 	/* Check Duplex mismatch */
 	if ((QuickStat & PHY_L_QS_DUP_MOD) != 0) {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOFULL;
 	}
 	else {
-		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
+		pPrt->PLinkModeStatus = (SK_U8)SK_LMODE_STAT_AUTOHALF;
 	}
 	
 	/* Check Master/Slave resolution */
@@ -3338,6 +3743,7 @@ int		Port)		/* Port Index (MAC_1 + n) */
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	/* we must manually resolve the abilities here */
 	pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+	
 	switch (pPrt->PFlowCtrlMode) {
 	case SK_FLOW_MODE_NONE:
 		/* default */
@@ -3457,6 +3863,9 @@ int		Port)		/* Port Index (MAC_1 + n) */
 		return(Rtv);
 	}
 
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNeg done Port %d\n", Port));
+	
 	/* We checked everything and may now enable the link */
 	pPrt->PAutoNegFail = SK_FALSE;
 
diff -purN linux-2.6.1/drivers/net/starfire.c linux-2.5/drivers/net/starfire.c
--- linux-2.6.1/drivers/net/starfire.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/starfire.c	2004-01-10 16:25:49.000000000 +0000
@@ -139,7 +139,6 @@ TODO:	bugfixes (no bugs known as of righ
 #include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
-#include <asm/io.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/netdevice.h>
diff -purN linux-2.6.1/drivers/net/tokenring/olympic.c linux-2.5/drivers/net/tokenring/olympic.c
--- linux-2.6.1/drivers/net/tokenring/olympic.c	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/drivers/net/tokenring/olympic.c	2004-01-11 01:40:26.000000000 +0000
@@ -468,14 +468,7 @@ static int olympic_open(struct net_devic
 	printk("Before the open command \n");
 #endif	
 	do {
-		int i;
-
-		for(i=0;i<SRB_COMMAND_SIZE;i+=4)
-			writel(0,init_srb+i);
-		if(SRB_COMMAND_SIZE & 2)
-			writew(0,init_srb+(SRB_COMMAND_SIZE & ~3));
-		if(SRB_COMMAND_SIZE & 1)
-			writeb(0,init_srb+(SRB_COMMAND_SIZE & ~1));
+		memset_io(init_srb,0,SRB_COMMAND_SIZE);
 
 		writeb(SRB_OPEN_ADAPTER,init_srb) ; 	/* open */
 		writeb(OLYMPIC_CLEAR_RET_CODE,init_srb+2);
diff -purN linux-2.6.1/drivers/net/tokenring/smctr.c linux-2.5/drivers/net/tokenring/smctr.c
--- linux-2.6.1/drivers/net/tokenring/smctr.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/drivers/net/tokenring/smctr.c	2004-01-10 14:29:03.000000000 +0000
@@ -729,10 +729,6 @@ static int smctr_close(struct net_device
 
 	netif_stop_queue(dev);
 	
-#ifdef MODULE
-        MOD_DEC_USE_COUNT;
-#endif
-
 	tp->cleanup = 1;
 
         /* Check to see if adapter is already in a closed state. */
@@ -3490,10 +3486,6 @@ static int smctr_open(struct net_device 
         if(err < 0)
                 return (err);
 
-#ifdef MODULE
-        MOD_INC_USE_COUNT;
-#endif
-
         return (err);
 }
 
diff -purN linux-2.6.1/drivers/net/wan/Kconfig linux-2.5/drivers/net/wan/Kconfig
--- linux-2.6.1/drivers/net/wan/Kconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wan/Kconfig	2004-01-10 16:14:26.000000000 +0000
@@ -325,6 +325,21 @@ config HDLC_X25
 comment "X.25/LAPB support is disabled"
 	depends on WAN && HDLC && (LAPB!=m || HDLC!=m) && LAPB!=y
 
+config PCI200SYN
+	tristate "Goramo PCI200SYN support"
+	depends on HDLC && PCI
+	help
+	  This driver is for PCI200SYN cards made by Goramo sp. j.
+	  If you have such a card, say Y here and see
+	  <http://hq.pm.waw.pl/pub/hdlc/>
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called pci200syn.
+
+	  If unsure, say N here.
+
 config WANXL
 	tristate "SBE Inc. wanXL support"
 	depends on HDLC && PCI
diff -purN linux-2.6.1/drivers/net/wan/Makefile linux-2.5/drivers/net/wan/Makefile
--- linux-2.6.1/drivers/net/wan/Makefile	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/net/wan/Makefile	2004-01-10 16:14:26.000000000 +0000
@@ -67,6 +67,7 @@ endif
 obj-$(CONFIG_N2)		+= n2.o
 obj-$(CONFIG_C101)		+= c101.o
 obj-$(CONFIG_WANXL)		+= wanxl.o
+obj-$(CONFIG_PCI200SYN)		+= pci200syn.o
 
 ifeq ($(CONFIG_WANXL_BUILD_FIRMWARE),y)
 ifeq ($(ARCH),m68k)
diff -purN linux-2.6.1/drivers/net/wan/farsync.c linux-2.5/drivers/net/wan/farsync.c
--- linux-2.6.1/drivers/net/wan/farsync.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/drivers/net/wan/farsync.c	2004-01-10 16:11:07.000000000 +0000
@@ -1313,8 +1313,6 @@ fst_open ( struct net_device *dev )
         if ( err )
                 return err;
 
-        MOD_INC_USE_COUNT;
-
         fst_openport ( dev_to_port ( dev ));
         netif_wake_queue ( dev );
         return 0;
@@ -1326,7 +1324,6 @@ fst_close ( struct net_device *dev )
         netif_stop_queue ( dev );
         fst_closeport ( dev_to_port ( dev ));
         hdlc_close ( dev_to_hdlc  ( dev ));
-        MOD_DEC_USE_COUNT;
         return 0;
 }
 
diff -purN linux-2.6.1/drivers/net/wan/hd64572.h linux-2.5/drivers/net/wan/hd64572.h
--- linux-2.6.1/drivers/net/wan/hd64572.h	2004-01-09 06:59:47.000000000 +0000
+++ linux-2.5/drivers/net/wan/hd64572.h	2004-01-10 16:14:26.000000000 +0000
@@ -23,8 +23,8 @@
  *
  */
 
-#ifndef _HD64572_H
-#define _HD64572_H
+#ifndef __HD64572_H
+#define __HD64572_H
 
 /* Illegal Access Register */
 #define	ILAR	0x00
@@ -59,6 +59,9 @@
 #define IR0_M(val, chan)	((val)<<(8*(chan)))		/* Int MSCI */
 
 /* MSCI Channel Registers */
+#define MSCI0_OFFSET 0x00
+#define MSCI1_OFFSET 0x80
+
 #define MD0	0x138	/* Mode reg 0 */
 #define MD1	0x139	/* Mode reg 1 */
 #define MD2	0x13a	/* Mode reg 2 */
@@ -107,6 +110,11 @@
 #define RCR	0x156	/* Rx DMA Critical Request Reg */
 
 /* Timer Registers */
+#define TIMER0RX_OFFSET 0x00
+#define TIMER0TX_OFFSET 0x10
+#define TIMER1RX_OFFSET 0x20
+#define TIMER1TX_OFFSET 0x30
+
 #define TCNTL	0x200	/* Timer Upcounter L */
 #define TCNTH	0x201	/* Timer Upcounter H */
 #define TCONRL	0x204	/* Timer Constant Register L */
@@ -132,6 +140,11 @@
 #define DCR_TX(chan)	(0x59 + 2*chan)	/* DMA Command Reg (Tx) */
 
 /* DMA Channel Registers */
+#define DMAC0RX_OFFSET 0x00
+#define DMAC0TX_OFFSET 0x20
+#define DMAC1RX_OFFSET 0x40
+#define DMAC1TX_OFFSET 0x60
+
 #define DARL	0x80	/* Dest Addr Register L (single-block, RX only) */
 #define DARH	0x81	/* Dest Addr Register H (single-block, RX only) */
 #define DARB	0x82	/* Dest Addr Register B (single-block, RX only) */
@@ -166,7 +179,17 @@ typedef struct {
 	unsigned char	filler[5];	/* alignment filler (16 bytes) */ 
 } pcsca_bd_t;
 
-/* 
+/* Block Descriptor Structure */
+typedef struct {
+	u32 cp;			/* pointer to next block descriptor */
+	u32 bp;			/* buffer pointer */
+	u16 len;		/* data length */
+	u8 stat;		/* status */
+	u8 unused;		/* pads to 4-byte boundary */
+}pkt_desc;
+
+
+/*
 	Descriptor Status definitions:
 
 	Bit	Transmission	Reception
@@ -190,6 +213,23 @@ typedef struct {
 #define DST_SHRT	0x40	/* Short Frame  */
 #define DST_EOM		0x80	/* End of Message  */
 
+/* Packet Descriptor Status bits */
+
+#define ST_TX_EOM     0x80	/* End of frame */
+#define ST_TX_UNDRRUN 0x08
+#define ST_TX_OWNRSHP 0x02
+#define ST_TX_EOT     0x01	/* End of transmition */
+
+#define ST_RX_EOM     0x80	/* End of frame */
+#define ST_RX_SHORT   0x40	/* Short frame */
+#define ST_RX_ABORT   0x20	/* Abort */
+#define ST_RX_RESBIT  0x10	/* Residual bit */
+#define ST_RX_OVERRUN 0x08	/* Overrun */
+#define ST_RX_CRC     0x04	/* CRC */
+#define ST_RX_OWNRSHP 0x02
+
+#define ST_ERROR_MASK 0x7C
+
 /* Status Counter Registers */
 #define CMCR	0x158	/* Counter Master Ctl Reg */
 #define TECNTL	0x160	/* Tx EOM Counter L */
@@ -246,11 +286,25 @@ typedef struct {
 #define MD0_BIT_SYNC	0x80
 #define MD0_TRANSP	0xc0
 
+#define MD0_HDLC        0x80	/* Bit-sync HDLC mode */
+
+#define MD0_CRC_NONE	0x00
+#define MD0_CRC_16_0	0x04
+#define MD0_CRC_16	0x05
+#define MD0_CRC_ITU32	0x06
+#define MD0_CRC_ITU	0x07
+
 #define MD1_NOADDR	0x00
 #define MD1_SADDR1	0x40
 #define MD1_SADDR2	0x80
 #define MD1_DADDR	0xc0
 
+#define MD2_NRZI_IEEE	0x40
+#define MD2_MANCHESTER	0x80
+#define MD2_FM_MARK	0xA0
+#define MD2_FM_SPACE	0xC0
+#define MD2_LOOPBACK	0x03	/* Local data Loopback */
+
 #define MD2_F_DUPLEX	0x00
 #define MD2_AUTO_ECHO	0x01
 #define MD2_LOOP_HI_Z	0x02
@@ -274,6 +328,10 @@ typedef struct {
 #define CTL_URSKP	0x40
 #define CTL_URCT	0x80
 
+#define CTL_NORTS	0x01
+#define CTL_NODTR	0x02
+#define CTL_IDLE	0x10
+
 #define	RXS_BR0		0x01
 #define	RXS_BR1		0x02
 #define	RXS_BR2		0x04
@@ -302,6 +360,12 @@ typedef struct {
 #define	EXS_TES1	0x20
 #define	EXS_TES2	0x40
 
+#define CLK_BRG_MASK	0x0F
+#define CLK_PIN_OUT	0x80
+#define CLK_LINE    	0x00	/* clock line input */
+#define CLK_BRG     	0x40	/* internal baud rate generator */
+#define CLK_TX_RXCLK	0x60	/* TX clock from RX clock */
+
 #define CMD_RX_RST	0x11
 #define CMD_RX_ENA	0x12
 #define CMD_RX_DIS	0x13
@@ -324,6 +388,10 @@ typedef struct {
 #define CMD_SRCH_MODE	0x31
 #define CMD_NOP		0x00
 
+#define CMD_RESET	0x21
+#define CMD_TX_ENABLE	0x02
+#define CMD_RX_ENABLE	0x12
+
 #define ST0_RXRDY	0x01
 #define ST0_TXRDY	0x02
 #define ST0_RXINTB	0x20
@@ -374,6 +442,8 @@ typedef struct {
 #define IE0_RXINTB	0x20
 #define IE0_RXINTA	0x40
 #define IE0_TXINT	0x80
+#define IE0_UDRN	0x00008000 /* TX underrun MSCI interrupt enable */
+#define IE0_CDCD	0x00000400 /* CD level change interrupt enable */
 
 #define IE1_IDLD	0x01
 #define IE1_ABTD	0x02
@@ -424,14 +494,28 @@ typedef struct {
 #define DIR_EOM		0x40
 #define DIR_EOT		0x80
 
+#define DIR_REFE	0x04
+#define DIR_UDRFE	0x04
+#define DIR_COAE	0x08
+#define DIR_COFE	0x10
+#define DIR_BOFE	0x20
+#define DIR_EOME	0x40
+#define DIR_EOTE	0x80
+
 #define DMR_CNTE	0x02
 #define DMR_NF		0x04
 #define DMR_SEOME	0x08
 #define DMR_TMOD	0x10
 
+#define DMER_DME        0x80	/* DMA Master Enable */
+
 #define DCR_SW_ABT	0x01
 #define DCR_FCT_CLR	0x02
 
+#define DCR_ABORT	0x01
+#define DCR_CLEAR_EOF	0x02
+
+#define PCR_COTE	0x80
 #define PCR_PR0		0x01
 #define PCR_PR1		0x02
 #define PCR_PR2		0x04
@@ -440,4 +524,4 @@ typedef struct {
 #define PCR_OSB		0x40
 #define PCR_BURST	0x80
 
-#endif /* (_HD64572_H) */
+#endif /* (__HD64572_H) */
diff -purN linux-2.6.1/drivers/net/wan/lapbether.c linux-2.5/drivers/net/wan/lapbether.c
--- linux-2.6.1/drivers/net/wan/lapbether.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/net/wan/lapbether.c	2004-01-14 00:38:41.000000000 +0000
@@ -448,22 +448,12 @@ static char banner[] __initdata = KERN_I
 
 static int __init lapbeth_init_driver(void)
 {
-	struct net_device *dev;
-
 	dev_add_pack(&lapbeth_packet_type);
 
 	register_netdevice_notifier(&lapbeth_dev_notifier);
 
 	printk(banner);
 
-	rtnl_lock();
-	for (dev = dev_base; dev; dev = dev->next) {
-		if (dev_is_ethdev(dev)) {
-			lapbeth_new_device(dev);
-		}
-	}
-	rtnl_unlock();
-
 	return 0;
 }
 module_init(lapbeth_init_driver);
diff -purN linux-2.6.1/drivers/net/wan/pc300_drv.c linux-2.5/drivers/net/wan/pc300_drv.c
--- linux-2.6.1/drivers/net/wan/pc300_drv.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/drivers/net/wan/pc300_drv.c	2004-01-10 16:11:20.000000000 +0000
@@ -3165,7 +3165,6 @@ int cpc_open(struct net_device *dev)
 		return result;
 	}
 
-	MOD_INC_USE_COUNT;
 	sprintf(ifr.ifr_name, "%s", dev->name);
 	cpc_opench(d);
 	netif_start_queue(dev);
@@ -3201,7 +3200,6 @@ int cpc_close(struct net_device *dev)
 	}
 #endif
 
-	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
diff -purN linux-2.6.1/drivers/net/wan/pci200syn.c linux-2.5/drivers/net/wan/pci200syn.c
--- linux-2.6.1/drivers/net/wan/pci200syn.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/net/wan/pci200syn.c	2004-01-10 16:14:26.000000000 +0000
@@ -0,0 +1,475 @@
+/*
+ * Goramo PCI200SYN synchronous serial card driver for Linux
+ *
+ * Copyright (C) 2002-2003 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * For information see http://hq.pm.waw.pl/hdlc/
+ *
+ * Sources of information:
+ *    Hitachi HD64572 SCA-II User's Manual
+ *    PLX Technology Inc. PCI9052 Data Book
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/in.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/hdlc.h>
+#include <linux/pci.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+
+#include "hd64572.h"
+
+static const char* version = "Goramo PCI200SYN driver version: 1.16";
+static const char* devname = "PCI200SYN";
+
+#undef DEBUG_PKT
+#define DEBUG_RINGS
+
+#define PCI200SYN_PLX_SIZE	0x80	/* PLX control window size (128b) */
+#define PCI200SYN_SCA_SIZE	0x400	/* SCA window size (1Kb) */
+#define ALL_PAGES_ALWAYS_MAPPED
+#define NEED_DETECT_RAM
+#define NEED_SCA_MSCI_INTR
+#define MAX_TX_BUFFERS		10
+
+static int pci_clock_freq = 33000000;
+#define CLOCK_BASE pci_clock_freq
+
+#define PCI_VENDOR_ID_GORAMO	0x10B5	/* uses PLX:9050 ID - this card	*/
+#define PCI_DEVICE_ID_PCI200SYN	0x9050	/* doesn't have its own ID	*/
+
+
+/*
+ *      PLX PCI9052 local configuration and shared runtime registers.
+ *      This structure can be used to access 9052 registers (memory mapped).
+ */
+typedef struct {
+	u32 loc_addr_range[4];	/* 00-0Ch : Local Address Ranges */
+	u32 loc_rom_range;	/* 10h : Local ROM Range */
+	u32 loc_addr_base[4];	/* 14-20h : Local Address Base Addrs */
+	u32 loc_rom_base;	/* 24h : Local ROM Base */
+	u32 loc_bus_descr[4];	/* 28-34h : Local Bus Descriptors */
+	u32 rom_bus_descr;	/* 38h : ROM Bus Descriptor */
+	u32 cs_base[4];		/* 3C-48h : Chip Select Base Addrs */
+	u32 intr_ctrl_stat;	/* 4Ch : Interrupt Control/Status */
+	u32 init_ctrl;		/* 50h : EEPROM ctrl, Init Ctrl, etc */
+}plx9052;
+
+
+
+typedef struct port_s {
+	hdlc_device hdlc;	/* HDLC device struct - must be first */
+	struct card_s *card;
+	spinlock_t lock;	/* TX lock */
+	sync_serial_settings settings;
+	int rxpart;		/* partial frame received, next frame invalid*/
+	unsigned short encoding;
+	unsigned short parity;
+	u16 rxin;		/* rx ring buffer 'in' pointer */
+	u16 txin;		/* tx ring buffer 'in' and 'last' pointers */
+	u16 txlast;
+	u8 rxs, txs, tmc;	/* SCA registers */
+	u8 phy_node;		/* physical port # - 0 or 1 */
+}port_t;
+
+
+
+typedef struct card_s {
+	u8* rambase;		/* buffer memory base (virtual) */
+	u8* scabase;		/* SCA memory base (virtual) */
+	plx9052* plxbase;	/* PLX registers memory base (virtual) */
+	u16 rx_ring_buffers;	/* number of buffers in a ring */
+	u16 tx_ring_buffers;
+	u16 buff_offset;	/* offset of first buffer of first channel */
+	u8 irq;			/* interrupt request level */
+
+	port_t ports[2];
+}card_t;
+
+
+#define sca_in(reg, card)	     readb(card->scabase + (reg))
+#define sca_out(value, reg, card)    writeb(value, card->scabase + (reg))
+#define sca_inw(reg, card)	     readw(card->scabase + (reg))
+#define sca_outw(value, reg, card)   writew(value, card->scabase + (reg))
+#define sca_inl(reg, card)	     readl(card->scabase + (reg))
+#define sca_outl(value, reg, card)   writel(value, card->scabase + (reg))
+
+#define port_to_card(port)	     (port->card)
+#define log_node(port)		     (port->phy_node)
+#define phy_node(port)		     (port->phy_node)
+#define winbase(card)		     (card->rambase)
+#define get_port(card, port)	     (&card->ports[port])
+#define sca_flush(card)		     (sca_in(IER0, card));
+
+static inline void new_memcpy_toio(char *dest, char *src, int length)
+{
+	int len;
+	do {
+		len = length > 256 ? 256 : length;
+		memcpy_toio(dest, src, len);
+		dest += len;
+		src += len;
+		length -= len;
+		readb(dest);
+	} while (len);
+}
+
+#undef memcpy_toio
+#define memcpy_toio new_memcpy_toio
+
+#include "hd6457x.c"
+
+
+static void pci200_set_iface(port_t *port)
+{
+	card_t *card = port->card;
+	u16 msci = get_msci(port);
+	u8 rxs = port->rxs & CLK_BRG_MASK;
+	u8 txs = port->txs & CLK_BRG_MASK;
+
+	sca_out(EXS_TES1, (phy_node(port) ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,
+		port_to_card(port));
+	switch(port->settings.clock_type) {
+	case CLOCK_INT:
+		rxs |= CLK_BRG; /* BRG output */
+		txs |= CLK_PIN_OUT | CLK_TX_RXCLK; /* RX clock */
+		break;
+
+	case CLOCK_TXINT:
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_BRG; /* BRG output */
+		break;
+
+	case CLOCK_TXFROMRX:
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_TX_RXCLK; /* RX clock */
+		break;
+
+	default:		/* EXTernal clock */
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_LINE; /* TXC input */
+		break;
+	}
+
+	port->rxs = rxs;
+	port->txs = txs;
+	sca_out(rxs, msci + RXS, card);
+	sca_out(txs, msci + TXS, card);
+	sca_set_port(port);
+}
+
+
+
+static int pci200_open(struct net_device *dev)
+{
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	port_t *port = hdlc_to_port(hdlc);
+
+	int result = hdlc_open(hdlc);
+	if (result)
+		return result;
+
+	sca_open(hdlc);
+	pci200_set_iface(port);
+	sca_flush(port_to_card(port));
+	return 0;
+}
+
+
+
+static int pci200_close(struct net_device *dev)
+{
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	sca_close(hdlc);
+	sca_flush(port_to_card(dev_to_port(dev)));
+	hdlc_close(hdlc);
+	return 0;
+}
+
+
+
+static int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	const size_t size = sizeof(sync_serial_settings);
+	sync_serial_settings new_line, *line = ifr->ifr_settings.ifs_ifsu.sync;
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	port_t *port = hdlc_to_port(hdlc);
+
+#ifdef DEBUG_RINGS
+	if (cmd == SIOCDEVPRIVATE) {
+		sca_dump_rings(hdlc);
+		return 0;
+	}
+#endif
+	if (cmd != SIOCWANDEV)
+		return hdlc_ioctl(dev, ifr, cmd);
+
+	switch(ifr->ifr_settings.type) {
+	case IF_GET_IFACE:
+		ifr->ifr_settings.type = IF_IFACE_V35;
+		if (ifr->ifr_settings.size < size) {
+			ifr->ifr_settings.size = size; /* data size wanted */
+			return -ENOBUFS;
+		}
+		if (copy_to_user(line, &port->settings, size))
+			return -EFAULT;
+		return 0;
+
+	case IF_IFACE_V35:
+	case IF_IFACE_SYNC_SERIAL:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		if (copy_from_user(&new_line, line, size))
+			return -EFAULT;
+
+		if (new_line.clock_type != CLOCK_EXT &&
+		    new_line.clock_type != CLOCK_TXFROMRX &&
+		    new_line.clock_type != CLOCK_INT &&
+		    new_line.clock_type != CLOCK_TXINT)
+		return -EINVAL;	/* No such clock setting */
+
+		if (new_line.loopback != 0 && new_line.loopback != 1)
+			return -EINVAL;
+
+		memcpy(&port->settings, &new_line, size); /* Update settings */
+		pci200_set_iface(port);
+		sca_flush(port_to_card(port));
+		return 0;
+
+	default:
+		return hdlc_ioctl(dev, ifr, cmd);
+	}
+}
+
+
+
+static void pci200_pci_remove_one(struct pci_dev *pdev)
+{
+	int i;
+	card_t *card = pci_get_drvdata(pdev);
+
+	for(i = 0; i < 2; i++)
+		if (card->ports[i].card)
+			unregister_hdlc_device(&card->ports[i].hdlc);
+
+	if (card->irq)
+		free_irq(card->irq, card);
+
+	if (card->rambase)
+		iounmap(card->rambase);
+	if (card->scabase)
+		iounmap(card->scabase);
+	if (card->plxbase)
+		iounmap(card->plxbase);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	kfree(card);
+}
+
+
+
+static int __devinit pci200_pci_init_one(struct pci_dev *pdev,
+					 const struct pci_device_id *ent)
+{
+	card_t *card;
+	u8 rev_id;
+	u32 *p;
+	int i;
+	u32 ramsize;
+	u32 ramphys;		/* buffer memory base */
+	u32 scaphys;		/* SCA memory base */
+	u32 plxphys;		/* PLX registers memory base */
+
+#ifndef MODULE
+	static int printed_version;
+	if (!printed_version++)
+		printk(KERN_INFO "%s\n", version);
+#endif
+
+	i = pci_enable_device(pdev);
+	if (i)
+		return i;
+
+	i = pci_request_regions(pdev, "PCI200SYN");
+	if (i) {
+		pci_disable_device(pdev);
+		return i;
+	}
+
+	card = kmalloc(sizeof(card_t), GFP_KERNEL);
+	if (card == NULL) {
+		printk(KERN_ERR "pci200syn: unable to allocate memory\n");
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		return -ENOBUFS;
+	}
+	memset(card, 0, sizeof(card_t));
+	pci_set_drvdata(pdev, card);
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	if (pci_resource_len(pdev, 0) != PCI200SYN_PLX_SIZE ||
+	    pci_resource_len(pdev, 2) != PCI200SYN_SCA_SIZE ||
+	    pci_resource_len(pdev, 3) < 16384) {
+		printk(KERN_ERR "pci200syn: invalid card EEPROM parameters\n");
+		pci200_pci_remove_one(pdev);
+		return -EFAULT;
+	}
+
+	plxphys = pci_resource_start(pdev,0) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);
+
+	scaphys = pci_resource_start(pdev,2) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);
+
+	ramphys = pci_resource_start(pdev,3) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->rambase = ioremap(ramphys, pci_resource_len(pdev,3));
+
+	if (card->plxbase == NULL ||
+	    card->scabase == NULL ||
+	    card->rambase == NULL) {
+		printk(KERN_ERR "pci200syn: ioremap() failed\n");
+		pci200_pci_remove_one(pdev);
+	}
+
+	/* Reset PLX */
+	p = &card->plxbase->init_ctrl;
+	writel(readl(p) | 0x40000000, p);
+	readl(p);		/* Flush the write - do not use sca_flush */
+	udelay(1);
+
+	writel(readl(p) & ~0x40000000, p);
+	readl(p);		/* Flush the write - do not use sca_flush */
+	udelay(1);
+
+	ramsize = sca_detect_ram(card, card->rambase,
+				 pci_resource_len(pdev, 3));
+
+	/* number of TX + RX buffers for one port - this is dual port card */
+	i = ramsize / (2 * (sizeof(pkt_desc) + HDLC_MAX_MRU));
+	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
+	card->rx_ring_buffers = i - card->tx_ring_buffers;
+
+	card->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +
+						    card->rx_ring_buffers);
+
+	printk(KERN_INFO "pci200syn: %u KB RAM at 0x%x, IRQ%u, using %u TX +"
+	       " %u RX packets rings\n", ramsize / 1024, ramphys,
+	       pdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);
+
+	if (card->tx_ring_buffers < 1) {
+		printk(KERN_ERR "pci200syn: RAM test failed\n");
+		pci200_pci_remove_one(pdev);
+		return -EFAULT;
+	}
+
+	/* Enable interrupts on the PCI bridge */
+	p = &card->plxbase->intr_ctrl_stat;
+	writew(readw(p) | 0x0040, p);
+
+	/* Allocate IRQ */
+	if(request_irq(pdev->irq, sca_intr, SA_SHIRQ, devname, card)) {
+		printk(KERN_WARNING "pci200syn: could not allocate IRQ%d.\n",
+		       pdev->irq);
+		pci200_pci_remove_one(pdev);
+		return -EBUSY;
+	}
+	card->irq = pdev->irq;
+
+	sca_init(card, 0);
+
+	for(i = 0; i < 2; i++) {
+		port_t *port = &card->ports[i];
+		struct net_device *dev = hdlc_to_dev(&port->hdlc);
+		port->phy_node = i;
+
+		spin_lock_init(&port->lock);
+		SET_MODULE_OWNER(dev);
+		dev->irq = card->irq;
+		dev->mem_start = ramphys;
+		dev->mem_end = ramphys + ramsize - 1;
+		dev->tx_queue_len = 50;
+		dev->do_ioctl = pci200_ioctl;
+		dev->open = pci200_open;
+		dev->stop = pci200_close;
+		port->hdlc.attach = sca_attach;
+		port->hdlc.xmit = sca_xmit;
+		port->settings.clock_type = CLOCK_EXT;
+		if(register_hdlc_device(&port->hdlc)) {
+			printk(KERN_ERR "pci200syn: unable to register hdlc "
+			       "device\n");
+			pci200_pci_remove_one(pdev);
+			return -ENOBUFS;
+		}
+		port->card = card;
+		sca_init_sync_port(port);	/* Set up SCA memory */
+
+		printk(KERN_INFO "%s: PCI200SYN node %d\n",
+		       hdlc_to_name(&port->hdlc), port->phy_node);
+	}
+
+	sca_flush(card);
+	return 0;
+}
+
+
+
+static struct pci_device_id pci200_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_GORAMO, PCI_DEVICE_ID_PCI200SYN, PCI_ANY_ID,
+	  PCI_ANY_ID, 0, 0, 0 },
+	{ 0, }
+};
+
+
+static struct pci_driver pci200_pci_driver = {
+	name:	  "PCI200SYN",
+	id_table: pci200_pci_tbl,
+	probe:	  pci200_pci_init_one,
+	remove:	  pci200_pci_remove_one,
+};
+
+
+static int __init pci200_init_module(void)
+{
+#ifdef MODULE
+	printk(KERN_INFO "%s\n", version);
+#endif
+	if (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {
+		printk(KERN_ERR "pci200syn: Invalid PCI clock frequency\n");
+		return -EINVAL;
+	}
+	return pci_module_init(&pci200_pci_driver);
+}
+
+
+
+static void __exit pci200_cleanup_module(void)
+{
+	pci_unregister_driver(&pci200_pci_driver);
+}
+
+MODULE_AUTHOR("Krzysztof Halasa <khc@pm.waw.pl>");
+MODULE_DESCRIPTION("Goramo PCI200SYN serial port driver");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(pci, pci200_pci_tbl);
+module_param(pci_clock_freq, int, 0444);
+MODULE_PARM_DESC(pci_clock_freq, "System PCI clock frequency in Hz");
+module_init(pci200_init_module);
+module_exit(pci200_cleanup_module);
diff -purN linux-2.6.1/drivers/net/wireless/Kconfig linux-2.5/drivers/net/wireless/Kconfig
--- linux-2.6.1/drivers/net/wireless/Kconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wireless/Kconfig	2004-01-11 00:57:32.000000000 +0000
@@ -282,7 +282,7 @@ config PCMCIA_ATMEL
          one of these, you will need to provide a firmware image
 	 to be loaded into the card by the driver. The Atmel
 	 firmware package can be downloaded from
-	 http://www.thekelleys.org.uk/atmel/atmel_firmware.tar.gz
+	 http://www.thekelleys.org.uk/atmel
 
 config PCMCIA_WL3501
       tristate "Planet WL3501 PCMCIA cards"
diff -purN linux-2.6.1/drivers/net/wireless/airo.c linux-2.5/drivers/net/wireless/airo.c
--- linux-2.6.1/drivers/net/wireless/airo.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/net/wireless/airo.c	2004-01-10 16:04:13.000000000 +0000
@@ -1027,7 +1027,6 @@ struct airo_info {
 #define FLAG_802_11	7
 #define FLAG_PENDING_XMIT 9
 #define FLAG_PENDING_XMIT11 10
-#define FLAG_PCI	11
 #define JOB_MASK	0x1ff0000
 #define JOB_DIE		16
 #define JOB_XMIT	17
@@ -4623,7 +4622,6 @@ static int __devinit airo_pci_probe(stru
 		return -ENODEV;
 
 	pci_set_drvdata(pdev, dev);
-	set_bit (FLAG_PCI, &((struct airo_info *)dev->priv)->flags);
 	return 0;
 }
 
@@ -4653,7 +4651,7 @@ static int __init airo_init_module( void
 
 #ifdef CONFIG_PCI
 	printk( KERN_INFO "airo:  Probing for PCI adapters\n" );
-	pci_module_init(&airo_driver);
+	pci_register_driver(&airo_driver);
 	printk( KERN_INFO "airo:  Finished probing for PCI adapters\n" );
 #endif
 
@@ -4665,22 +4663,15 @@ static int __init airo_init_module( void
 
 static void __exit airo_cleanup_module( void )
 {
-	int is_pci = 0;
 	while( airo_devices ) {
 		printk( KERN_INFO "airo: Unregistering %s\n", airo_devices->dev->name );
-#ifdef CONFIG_PCI
-		if (test_bit(FLAG_PCI, &((struct airo_info *)airo_devices->dev->priv)->flags))
-			is_pci = 1;
-#endif
 		stop_airo_card( airo_devices->dev, 1 );
 	}
 	remove_proc_entry("aironet", proc_root_driver);
 
-	if (is_pci) {
 #ifdef CONFIG_PCI
-		pci_unregister_driver(&airo_driver);
+	pci_unregister_driver(&airo_driver);
 #endif
-	}
 }
 
 #ifdef WIRELESS_EXT
diff -purN linux-2.6.1/drivers/net/wireless/atmel.c linux-2.5/drivers/net/wireless/atmel.c
--- linux-2.6.1/drivers/net/wireless/atmel.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wireless/atmel.c	2004-01-11 00:57:32.000000000 +0000
@@ -67,7 +67,7 @@
 #include "ieee802_11.h"
 
 #define DRIVER_MAJOR 0
-#define DRIVER_MINOR 8
+#define DRIVER_MINOR 9
 
 MODULE_AUTHOR("Simon Kelley");
 MODULE_DESCRIPTION("Support for Atmel at76c50x 802.11 wireless ethernet cards.");
@@ -153,12 +153,15 @@ module_param(firmware, charp, 0);
 #define C80211_MGMT_ElementID_ChallengeText     16
 #define C80211_MGMT_CAPABILITY_ShortPreamble    0x0020
 
+#define MIB_MAX_DATA_BYTES    212
+#define MIB_HEADER_SIZE       4    /* first four fields */
+
 struct get_set_mib {
         u8 type;
         u8 size;
         u8 index;
         u8 reserved;
-        u8 data[72];
+        u8 data[MIB_MAX_DATA_BYTES];
 };
 
 struct rx_desc {
@@ -195,32 +198,40 @@ struct rx_desc {
 
 
 struct tx_desc {
-   u32       NextDescriptor;
-   u16       TxStartOfFrame;
-   u16       TxLength;
-   
-   u8        TxState;
-   u8        TxStatus;
-   u8        RetryCount;
-
-   u8        TxRate;
-   u32       TxTime;
-   u8        Reserved;
-   u8        PacketType;
-   u16       HostTxLength;
-
+	u32       NextDescriptor;
+	u16       TxStartOfFrame;
+	u16       TxLength;
+	
+	u8        TxState;
+	u8        TxStatus;
+	u8        RetryCount;
+	
+	u8        TxRate;
+
+	u8        KeyIndex;
+	u8        ChiperType;
+	u8        ChipreLength;
+        u8        Reserved1;
+
+	u8        Reserved;
+	u8        PacketType;
+	u16       HostTxLength;
+	
 };
 
 
-#define TX_DESC_NEXT_OFFSET        0
-#define TX_DESC_POS_OFFSET         4
-#define TX_DESC_SIZE_OFFSET        6
-#define TX_DESC_FLAGS_OFFSET       8
-#define TX_DESC_STATUS_OFFSET      9
-#define TX_DESC_RETRY_OFFSET       10
-#define TX_DESC_RATE_OFFSET        11
-#define TX_DESC_PACKET_TYPE_OFFSET 17
-#define TX_DESC_HOST_LENGTH_OFFSET 18
+#define TX_DESC_NEXT_OFFSET          0
+#define TX_DESC_POS_OFFSET           4
+#define TX_DESC_SIZE_OFFSET          6
+#define TX_DESC_FLAGS_OFFSET         8
+#define TX_DESC_STATUS_OFFSET        9
+#define TX_DESC_RETRY_OFFSET         10
+#define TX_DESC_RATE_OFFSET          11
+#define TX_DESC_KEY_INDEX_OFFSET     12
+#define TX_DESC_CIPHER_TYPE_OFFSET   13
+#define TX_DESC_CIPHER_LENGTH_OFFSET 14
+#define TX_DESC_PACKET_TYPE_OFFSET   17
+#define TX_DESC_HOST_LENGTH_OFFSET   18
 
 
 
@@ -324,6 +335,9 @@ struct tx_desc {
 #define ACTIVE_MODE 	1
 #define PS_MODE 	2
 
+#define MAX_ENCRYPTION_KEYS 4
+#define MAX_ENCRYPTION_KEY_SIZE 40
+
 ///////////////////////////////////////////////////////////////////////////
 // 802.11 related definitions
 ///////////////////////////////////////////////////////////////////////////
@@ -370,6 +384,14 @@ struct tx_desc {
 #define IFACE_FUNC_CTRL_OFFSET		28
 #define IFACE_MAC_STAT_OFFSET		30
 #define IFACE_GENERIC_INT_TYPE_OFFSET	32
+
+#define CIPHER_SUITE_NONE     0 
+#define CIPHER_SUITE_WEP_64   1
+#define CIPHER_SUITE_TKIP     2
+#define CIPHER_SUITE_AES      3
+#define CIPHER_SUITE_CCX      4
+#define CIPHER_SUITE_WEP_128  5
+
 //
 // IFACE MACROS & definitions
 //
@@ -432,6 +454,7 @@ struct atmel_private {
 	void *card; /* Bus dependent stucture varies for PCcard */
 	int (*present_callback)(void *); /* And callback which uses it */
 	char firmware_id[32];
+	char firmware_template[32];
 	unsigned char *firmware;
 	int firmware_length;
 	struct timer_list management_timer;
@@ -457,20 +480,11 @@ struct atmel_private {
 	u16 frag_seq, frag_len, frag_no;
 	u8 frag_source[6]; 
 	
-	int wep_key_len[4]; /* need to know these and not stored in Mib. */
-	struct { /* NB this is matched to the hardware, don't change. */
-		u8 wep_is_on;                 
-		u8 default_key; /* 0..3 */
-		u8 reserved;
-		u8 exclude_unencrypted;
-		
-		u32 WEPICV_error_count;
-		u32 WEP_excluded_count;
-		
-		u8 wep_keys[4][13];
-		u8 encryption_level; /* 0, 1, 2 */
-		u8 reserved2[3];
-	} wep;
+	u8 wep_is_on, default_key, exclude_unencrypted, encryption_level;
+	u8 group_cipher_suite, pairwise_cipher_suite;
+	u8 wep_keys[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];
+	int wep_key_len[MAX_ENCRYPTION_KEYS]; 
+	int use_wpa;
 
 	u16 host_info_base;
 	struct host_info_struct { 
@@ -510,8 +524,6 @@ struct atmel_private {
 		STATION_STATE_ASSOCIATING,
 		STATION_STATE_READY,
 		STATION_STATE_REASSOCIATING,
-		STATION_STATE_FORCED_JOINNING,
-		STATION_STATE_FORCED_JOIN_FAILURE,
 		STATION_STATE_DOWN,
 		STATION_STATE_NO_CARD,
 		STATION_STATE_MGMT_ERROR 
@@ -564,6 +576,7 @@ struct atmel_private {
 
 static u8 atmel_basic_rates[4] = {0x82,0x84,0x0b,0x16};
 
+static void build_wpa_mib(struct atmel_private *priv);
 static int atmel_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void atmel_copy_to_card(struct net_device *dev, u16 dest, unsigned char *src, u16 len);
 static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest, u16 src, u16 len);
@@ -717,14 +730,54 @@ static u16 find_tx_buff(struct atmel_pri
 	return 0;
 }
 
-static void tx_update_descriptor(struct atmel_private *priv, u16 len, u16 buff, u8 type)
+static void tx_update_descriptor(struct atmel_private *priv, int is_bcast, u16 len, u16 buff, u8 type)
 {
 	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, priv->tx_desc_tail), buff);
 	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_tail), len);
-	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);
+	if (!priv->use_wpa)
+		atmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_tail), type);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_RATE_OFFSET, priv->tx_desc_tail), priv->tx_rate);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_RETRY_OFFSET, priv->tx_desc_tail), 0);
+	if (priv->use_wpa) {
+		int cipher_type, cipher_length;
+		if (is_bcast) {
+			cipher_type = priv->group_cipher_suite;
+			if (cipher_type == CIPHER_SUITE_WEP_64 || 
+			    cipher_type == CIPHER_SUITE_WEP_128 )
+				cipher_length = 8;
+			else if (cipher_type == CIPHER_SUITE_TKIP)
+				cipher_length = 12;
+			else if (priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_64 ||
+				 priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_128) {
+				cipher_type = priv->pairwise_cipher_suite;
+				cipher_length = 8;
+			} else {
+				cipher_type = CIPHER_SUITE_NONE;
+				cipher_length = 0;
+			}
+		} else {
+			cipher_type = priv->pairwise_cipher_suite;
+			if (cipher_type == CIPHER_SUITE_WEP_64 || 
+			    cipher_type == CIPHER_SUITE_WEP_128 )
+				cipher_length = 8;
+			else if (cipher_type == CIPHER_SUITE_TKIP)
+				cipher_length = 12;
+			else if (priv->group_cipher_suite == CIPHER_SUITE_WEP_64 ||
+				 priv->group_cipher_suite == CIPHER_SUITE_WEP_128) {
+				cipher_type = priv->group_cipher_suite;
+				cipher_length = 8;
+			} else {
+				cipher_type = CIPHER_SUITE_NONE;
+				cipher_length = 0;
+			}
+		}
+		
+		atmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_TYPE_OFFSET, priv->tx_desc_tail),
+			    cipher_type);	
+		atmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_LENGTH_OFFSET, priv->tx_desc_tail),
+			    cipher_length);
+	}
 	atmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_tail), 0x80000000L);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_tail), TX_FIRM_OWN);
 	if (priv->tx_desc_previous != priv->tx_desc_tail)
@@ -745,16 +798,19 @@ static int start_tx (struct sk_buff *skb
 	struct ieee802_11_hdr header;
 	unsigned long flags;
 	u16 buff, frame_ctl, len = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;
-	
-	if(priv->station_state != STATION_STATE_READY) {
+	u8 SNAP_RFC1024[6] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+ 
+	if (priv->station_state != STATION_STATE_READY) {
 		priv->stats.tx_errors++;
-		goto done;
+		dev_kfree_skb(skb);
+		return 0;
 	}
 	
 	if (priv->card && priv->present_callback && 
 	    !(*priv->present_callback)(priv->card)) {
 		priv->stats.tx_errors++;
-		goto done;
+		dev_kfree_skb(skb);
+		return 0;
 	}
 	
 	/* first ensure the timer func cannot run */
@@ -778,7 +834,7 @@ static int start_tx (struct sk_buff *skb
 	frame_ctl = IEEE802_11_FTYPE_DATA;
 	header.duration_id = 0;
 	header.seq_ctl = 0;
-	if (priv->wep.wep_is_on)
+	if (priv->wep_is_on)
 		frame_ctl |= IEEE802_11_FCTL_WEP;
 	if (priv->operating_mode == IW_MODE_ADHOC) {
 		memcpy(&header.addr1, skb->data, 6);
@@ -791,6 +847,9 @@ static int start_tx (struct sk_buff *skb
 		memcpy(&header.addr3, skb->data, 6);
 	}
 	
+	if (priv->use_wpa)
+		memcpy(&header.addr4, SNAP_RFC1024, 6);
+
 	header.frame_ctl = cpu_to_le16(frame_ctl);
 	/* Copy the wireless header into the card */
 	atmel_copy_to_card(dev, buff, (unsigned char *)&header, DATA_FRAME_WS_HEADER_SIZE);
@@ -798,14 +857,13 @@ static int start_tx (struct sk_buff *skb
 	atmel_copy_to_card(dev, buff + DATA_FRAME_WS_HEADER_SIZE, skb->data + 12, len - 12);
 	priv->tx_buff_tail += len - 12 + DATA_FRAME_WS_HEADER_SIZE;
 	
-	tx_update_descriptor(priv, len + 18, buff, TX_PACKET_TYPE_DATA);
+	/* low bit of first byte of destination tells us if broadcast */
+	tx_update_descriptor(priv, *(skb->data) & 0x01, len + 18, buff, TX_PACKET_TYPE_DATA);
 	dev->trans_start = jiffies;
 	priv->stats.tx_bytes += len;
 	
 	spin_unlock_irqrestore(&priv->irqlock, flags);
 	spin_unlock_bh(&priv->timerlock);
-
-done:
 	dev_kfree_skb(skb);
 	
 	return 0;	
@@ -824,7 +882,7 @@ static void atmel_transmit_management_fr
 	atmel_copy_to_card(priv->dev, buff, (u8 *)header, MGMT_FRAME_BODY_OFFSET);
 	atmel_copy_to_card(priv->dev, buff + MGMT_FRAME_BODY_OFFSET, body, body_len);
 	priv->tx_buff_tail += len;
-	tx_update_descriptor(priv, len, buff, TX_PACKET_TYPE_MGMT);
+	tx_update_descriptor(priv, header->addr1[0] & 0x01, len, buff, TX_PACKET_TYPE_MGMT);
 }
 	
 static void fast_rx_path(struct atmel_private *priv, struct ieee802_11_hdr *header, 
@@ -1027,7 +1085,7 @@ static void rx_done_irq(struct atmel_pri
 		/* probe for CRC use here if needed  once five packets have arrived with
 		   the same crc status, we assume we know what's happening and stop probing */
 		if (priv->probe_crc) {
-			if (!priv->wep.wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP)) {
+			if (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP)) {
 				priv->do_rx_crc = probe_crc(priv, rx_packet_loc, msdu_size);
 			} else {
 				priv->do_rx_crc = probe_crc(priv, rx_packet_loc + 24, msdu_size - 24);
@@ -1042,7 +1100,7 @@ static void rx_done_irq(struct atmel_pri
 		}
 		    
 		/* don't CRC header when WEP in use */
-		if (priv->do_rx_crc && (!priv->wep.wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP))) {
+		if (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP))) {
 			crc = crc32_le(0xffffffff, (unsigned char *)&header, 24);
 		}
 		msdu_size -= 24; /* header */
@@ -1158,6 +1216,9 @@ static irqreturn_t service_interrupt(int
 			reset_irq_status(priv, ISR_IBSS_MERGE);
 			atmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS, 
 				      priv->CurrentBSSID, 6);
+			/* The WPA stuff cares about the current AP address */
+			if (priv->use_wpa)
+				build_wpa_mib(priv);
 		} else if (isr & ISR_GENERIC_IRQ) {
 			reset_irq_status(priv, ISR_GENERIC_IRQ);
 			printk(KERN_INFO "%s: Generic_irq recieved.\n", dev->name);
@@ -1237,6 +1298,7 @@ static int atmel_close (struct net_devic
 {
 	struct atmel_private *priv = (struct atmel_private *) dev->priv;
 		
+	netif_carrier_off(dev);	
 	if (netif_running(dev))
 		netif_stop_queue(dev);
 	
@@ -1255,17 +1317,17 @@ static int atmel_proc_output (char *buf,
 	p += sprintf(p, "Driver version:\t\t%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR);
 	
 	if (priv->station_state != STATION_STATE_DOWN) {
-		p += sprintf(p, "Firmware version:\t%d.%d build %d ", 
+		p += sprintf(p, "Firmware version:\t%d.%d build %d\nFirmware location:\t", 
 			     priv->host_info.major_version,
 			     priv->host_info.minor_version,
 			     priv->host_info.build_version);
 		
 		if (priv->card_type != CARD_TYPE_EEPROM) 
-			p += sprintf(p, "[built-in]\n");
+			p += sprintf(p, "on card\n");
 		else if (priv->firmware) 
-			p += sprintf(p, "[%s loaded by host]\n", priv->firmware_id);
+			p += sprintf(p, "%s loaded by host\n", priv->firmware_id);
 		else
-			p += sprintf(p, "[%s loaded by hotplug]\n", priv->firmware_id);
+			p += sprintf(p, "%s loaded by hotplug\n", priv->firmware_id);
 		
 		switch(priv->card_type) {
 		case CARD_TYPE_PARALLEL_FLASH: c = "Parallel flash"; break;
@@ -1289,6 +1351,8 @@ static int atmel_proc_output (char *buf,
 		p += sprintf(p, "Regulatory domain:\t%s\n", r);
 		p += sprintf(p, "Host CRC checking:\t%s\n", 
 			     priv->do_rx_crc ? "On" : "Off");
+		p += sprintf(p, "WPA-capable firmware:\t%s\n",
+			     priv->use_wpa ? "Yes" : "No");
 	}
 	
 	switch(priv->station_state) {
@@ -1299,8 +1363,6 @@ static int atmel_proc_output (char *buf,
 	case STATION_STATE_ASSOCIATING: s = "Associating"; break;
 	case STATION_STATE_READY: s = "Ready"; break;
 	case STATION_STATE_REASSOCIATING: s = "Reassociating"; break;
-	case STATION_STATE_FORCED_JOINNING: s = "Forced joining"; break;
-	case STATION_STATE_FORCED_JOIN_FAILURE: s = "Forced join failure"; break;
 	case STATION_STATE_NO_CARD: s = "No card"; break;
 	case STATION_STATE_MGMT_ERROR: s = "Management error"; break;
 	case STATION_STATE_DOWN: s = "Down"; break;
@@ -1348,12 +1410,12 @@ struct net_device *init_atmel_card( unsi
 	priv->present_callback = card_present;
 	priv->card = card;
 	priv->firmware = NULL;
+	priv->firmware_id[0] = '\0';
+	priv->firmware_template[0] = '\0';
 	if (firmware) /* module parameter */
 		strcpy(priv->firmware_id, firmware);
 	else if (firmware_id) /* from PCMCIA card-matching or PCI */
-		strcpy(priv->firmware_id, firmware_id);
-	else
-		priv->firmware_id[0] = '\0';
+		strcpy(priv->firmware_template, firmware_id);
 	priv->bus_type = card_present ? BUS_TYPE_PCCARD : BUS_TYPE_PCI;
 	priv->station_state = STATION_STATE_DOWN;
 	priv->is3com = is3com;
@@ -1389,9 +1451,16 @@ struct net_device *init_atmel_card( unsi
 	priv->rts_threshold = 2347;
 	priv->short_retry = 7;
 	priv->long_retry = 4;
-	priv->wep.wep_is_on = 0;
-	priv->wep.default_key = 0;
-	priv->wep.encryption_level = 0;
+
+	priv->wep_is_on = 0;
+	priv->default_key = 0;
+	priv->encryption_level = 0;
+	priv->exclude_unencrypted = 0;
+	priv->group_cipher_suite = priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;
+	priv->use_wpa = 0;
+	memset(priv->wep_keys, 0, sizeof(priv->wep_keys));
+	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
+
 	priv->default_beacon_period = priv->beacon_period = 100;
 	priv->listen_interval = 1;
 
@@ -1426,8 +1495,12 @@ struct net_device *init_atmel_card( unsi
 	if (register_netdev(dev))
 		goto err_out_res;
 	
-	if (!probe_atmel_card(dev))
+	if (!probe_atmel_card(dev)){
+		unregister_netdev(dev);
 		goto err_out_res;
+	}
+	
+	netif_carrier_off(dev);
 	
 	create_proc_read_entry ("driver/atmel", 0, 0, atmel_read_proc, priv);	
 	
@@ -1443,7 +1516,7 @@ struct net_device *init_atmel_card( unsi
  err_out_irq:
 	free_irq(dev->irq, dev);
  err_out_free:
-	kfree(dev);
+	free_netdev(dev);
 	return NULL;
 }
 
@@ -1582,7 +1655,7 @@ static int atmel_set_encode(struct net_d
 	 * don't do it. - Jean II */
 	if (dwrq->length > 0) {
 		int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
-		int current_index = priv->wep.default_key;
+		int current_index = priv->default_key;
 		/* Check the size of the key */
 		if (dwrq->length > 13) {
 			return -EINVAL;
@@ -1591,7 +1664,7 @@ static int atmel_set_encode(struct net_d
 		if (index < 0 || index >= 4)
 			index = current_index;
 		else
-			priv->wep.default_key = index;
+			priv->default_key = index;
 		/* Set the length */
 		if (dwrq->length > 5)
 			priv->wep_key_len[index] = 13;
@@ -1604,27 +1677,30 @@ static int atmel_set_encode(struct net_d
 		/* Check if the key is not marked as invalid */
 		if(!(dwrq->flags & IW_ENCODE_NOKEY)) {
 			/* Cleanup */
-			memset(priv->wep.wep_keys[index], 0, 13);
+			memset(priv->wep_keys[index], 0, 13);
 			/* Copy the key in the driver */
-			memcpy(priv->wep.wep_keys[index], extra, dwrq->length);
+			memcpy(priv->wep_keys[index], extra, dwrq->length);
 		}
 		/* WE specify that if a valid key is set, encryption
 		 * should be enabled (user may turn it off later)
 		 * This is also how "iwconfig ethX key on" works */
 		if (index == current_index && 
 		    priv->wep_key_len[index] > 0) {
-			priv->wep.wep_is_on = 1;
-			priv->wep.exclude_unencrypted = 1;
-			if (priv->wep_key_len[index] > 5)
-				priv->wep.encryption_level = 2;
-			else
-				priv->wep.encryption_level = 1;
+			priv->wep_is_on = 1;
+			priv->exclude_unencrypted = 1;
+			if (priv->wep_key_len[index] > 5) {
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+				priv->encryption_level = 2;
+			} else {
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+				priv->encryption_level = 1;
+			}
 		}
 	} else {
 		/* Do we want to just set the transmit key index ? */
 		int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 		if ( index>=0 && index < 4 ) {
-			priv->wep.default_key = index;
+			priv->default_key = index;
 		} else
 			/* Don't complain if only change the mode */
 			if(!dwrq->flags & IW_ENCODE_MODE) {
@@ -1633,19 +1709,23 @@ static int atmel_set_encode(struct net_d
 	}
 	/* Read the flags */
 	if(dwrq->flags & IW_ENCODE_DISABLED) {
-		priv->wep.wep_is_on = 0;
-		priv->wep.encryption_level = 0; 
+		priv->wep_is_on = 0;
+		priv->encryption_level = 0; 	
+		priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;
 	} else {
-		priv->wep.wep_is_on = 1;
-		if (priv->wep_key_len[priv->wep.default_key] > 5)
-			priv->wep.encryption_level = 2;
-		else
-			priv->wep.encryption_level = 1;
+		priv->wep_is_on = 1;
+		if (priv->wep_key_len[priv->default_key] > 5) {
+			priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+			priv->encryption_level = 2;
+		} else {
+			priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+			priv->encryption_level = 1;
+		}
 	}
 	if(dwrq->flags & IW_ENCODE_RESTRICTED)
-		priv->wep.exclude_unencrypted = 1;
+		priv->exclude_unencrypted = 1;
 	if(dwrq->flags & IW_ENCODE_OPEN)
-		priv->wep.exclude_unencrypted = 0;
+		priv->exclude_unencrypted = 0;
 	
 	return -EINPROGRESS;		/* Call commit handler */
 }
@@ -1659,16 +1739,16 @@ static int atmel_get_encode(struct net_d
 	struct atmel_private *priv = dev->priv;
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 	
-	if (!priv->wep.wep_is_on)
+	if (!priv->wep_is_on)
 		dwrq->flags = IW_ENCODE_DISABLED;
-	else if (priv->wep.exclude_unencrypted)
+	else if (priv->exclude_unencrypted)
 		dwrq->flags = IW_ENCODE_RESTRICTED;
 	else
 		dwrq->flags = IW_ENCODE_OPEN;
 		
 		/* Which key do we want ? -1 -> tx index */
 	if (index < 0 || index >= 4)
-		index = priv->wep.default_key;
+		index = priv->default_key;
 	dwrq->flags |= index + 1;
 	/* Copy the key to the user buffer */
 	dwrq->length = priv->wep_key_len[index];
@@ -1676,7 +1756,7 @@ static int atmel_get_encode(struct net_d
 		dwrq->length=0;
 	} else {
 		memset(extra, 0, 16);
-		memcpy(extra, priv->wep.wep_keys[index], dwrq->length);
+		memcpy(extra, priv->wep_keys[index], dwrq->length);
 	}
 	
 	return 0;
@@ -1711,10 +1791,10 @@ static int atmel_set_rate(struct net_dev
 		} else {
 		/* Setting by frequency value */
 			switch (vwrq->value) {
-			case (int)1e6: priv->tx_rate = 0; break;
-			case (int)2e6: priv->tx_rate = 1; break;
-			case (int)5.5e6: priv->tx_rate = 2; break;
-			case (int)11e6:  priv->tx_rate = 3; break;
+			case  1000000: priv->tx_rate = 0; break;
+			case  2000000: priv->tx_rate = 1; break;
+			case  5500000: priv->tx_rate = 2; break;
+			case 11000000: priv->tx_rate = 3; break;
 			default: return -EINVAL;
 			}
 		}
@@ -1757,14 +1837,14 @@ static int atmel_get_rate(struct net_dev
 
 	if (priv->auto_tx_rate) {
 		vwrq->fixed = 0;
-		vwrq->value = 11e6;
+		vwrq->value = 11000000;
 	} else {
 		vwrq->fixed = 1;
 		switch(priv->tx_rate) {
-		case 0: vwrq->value = 1e6; break;
-		case 1: vwrq->value = 2e6; break;
-		case 2: vwrq->value = 5.5e6; break;
-		case 3: vwrq->value = 11e6; break;
+		case 0: vwrq->value =  1000000; break;
+		case 1: vwrq->value =  2000000; break;
+		case 2: vwrq->value =  5500000; break;
+		case 3: vwrq->value = 11000000; break;
 		}
 	}
 	return 0;
@@ -1982,6 +2062,7 @@ static int atmel_set_scan(struct net_dev
 	
 	atmel_clear_gcr(dev, GCR_ENINT); /* disable interrupts */
 	del_timer_sync(&priv->management_timer);
+	priv->fast_scan = 0;
 	atmel_scan(priv, 0);
 	atmel_set_gcr(dev, GCR_ENINT); /* enable interrupts */
 	
@@ -2073,10 +2154,10 @@ static int atmel_get_range(struct net_de
 	range->max_qual.noise = 0;
 	range->sensitivity = 0;
 
-	range->bitrate[0] = 1e6;
-	range->bitrate[1] = 2e6;
-	range->bitrate[2] = 5.5e6;
-	range->bitrate[3] = 11e6;
+	range->bitrate[0] =  1000000;
+	range->bitrate[1] =  2000000;
+	range->bitrate[2] =  5500000;
+	range->bitrate[3] = 11000000;
 	range->num_bitrates = 4;
 
 	range->min_rts = 0;
@@ -2129,9 +2210,9 @@ static int atmel_set_wap(struct net_devi
 	
 	for(i=0; i<priv->BSS_list_entries; i++) {
 		if (memcmp(priv->BSSinfo[i].BSSID, awrq->sa_data, 6) == 0) {
-			if (!priv->wep.wep_is_on && priv->BSSinfo[i].UsingWEP) {
+			if (!priv->wep_is_on && priv->BSSinfo[i].UsingWEP) {
 				return -EINVAL;
-			} else if  (priv->wep.wep_is_on && !priv->BSSinfo[i].UsingWEP) {
+			} else if  (priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) {
 				return -EINVAL;
 			} else 
 				atmel_join_bss(priv, i);  
@@ -2313,10 +2394,13 @@ static void atmel_enter_state(struct atm
 	if (new_state == old_state)
 		return;
 
-	if (new_state == STATION_STATE_READY)
+	if (new_state == STATION_STATE_READY) {
 		netif_start_queue(priv->dev);
+		netif_carrier_on(priv->dev);
+	}
 
 	if (old_state == STATION_STATE_READY) {
+		netif_carrier_off(priv->dev);
 		netif_stop_queue(priv->dev);
 		priv->last_beacon_timestamp = 0;
 	}
@@ -2453,7 +2537,7 @@ static void send_authentication_request(
 	memcpy(header.addr2, priv->dev->dev_addr, 6);
 	memcpy(header.addr3, priv->CurrentBSSID, 6);
 	
-	if (priv->wep.wep_is_on) {
+	if (priv->wep_is_on) {
 		auth.alg = C80211_MGMT_AAN_SHAREDKEY; 
 		/* no WEP for authentication frames with TrSeqNo 1 */
 		if (priv->CurrentAuthentTransactionSeqNum != 1)
@@ -2504,7 +2588,7 @@ static void send_association_request(str
 	memcpy(header.addr3, priv->CurrentBSSID, 6); 
 
 	body.capability = cpu_to_le16(C80211_MGMT_CAPABILITY_ESS);
-	if (priv->wep.wep_is_on)
+	if (priv->wep_is_on)
 		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_Privacy);
 	if (priv->preamble == SHORT_PREAMBLE)
 		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_ShortPreamble);
@@ -2555,8 +2639,8 @@ static int retrieve_bss(struct atmel_pri
 		priv->current_BSS = 0;
 		for(i=0; i<priv->BSS_list_entries; i++) { 
 			if (priv->operating_mode == priv->BSSinfo[i].BSStype &&
-			    ((!priv->wep.wep_is_on && !priv->BSSinfo[i].UsingWEP) || 
-			     (priv->wep.wep_is_on && priv->BSSinfo[i].UsingWEP)) &&
+			    ((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) || 
+			     (priv->wep_is_on && priv->BSSinfo[i].UsingWEP)) &&
 			    !(priv->BSSinfo[i].channel & 0x80)) {
 				max_rssi = priv->BSSinfo[i].RSSI;
 				priv->current_BSS = max_index = i;
@@ -2630,7 +2714,7 @@ static void authenticate(struct atmel_pr
 	u16 status = le16_to_cpu(auth->status);
 	u16 trans_seq_no = le16_to_cpu(auth->trans_seq);
 	
-	if (status == C80211_MGMT_SC_Success && !priv->wep.wep_is_on) { 
+	if (status == C80211_MGMT_SC_Success && !priv->wep_is_on) { 
 		/* no WEP */
 		if (priv->station_was_associated) {
 			atmel_enter_state(priv, STATION_STATE_REASSOCIATING);
@@ -2643,7 +2727,7 @@ static void authenticate(struct atmel_pr
 		} 
 	}
 		
-	if (status == C80211_MGMT_SC_Success && priv->wep.wep_is_on) { 
+	if (status == C80211_MGMT_SC_Success && priv->wep_is_on) { 
 		/* WEP */
 		if (trans_seq_no != priv->ExpectedAuthentTransactionSeqNum)
 			return;
@@ -2765,6 +2849,10 @@ void atmel_join_bss(struct atmel_private
 
 	memcpy(priv->CurrentBSSID, bss->BSSID, 6);
 	memcpy(priv->SSID, bss->SSID, priv->SSID_size = bss->SSIDsize);
+
+	/* The WPA stuff cares about the current AP address */
+	if (priv->use_wpa)
+		build_wpa_mib(priv);
 	
 	/* When switching to AdHoc turn OFF Power Save if needed */
 
@@ -2786,13 +2874,13 @@ void atmel_join_bss(struct atmel_private
 		atmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, bss->preamble);
 	}
 	
-	if (!priv->wep.wep_is_on && bss->UsingWEP) {
+	if (!priv->wep_is_on && bss->UsingWEP) {
 		atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
 		priv->station_is_associated = 0;
 		return;
 	}
 		
-	if (priv->wep.wep_is_on && !bss->UsingWEP) {
+	if (priv->wep_is_on && !bss->UsingWEP) {
 		atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
 		priv->station_is_associated = 0;
 		return;
@@ -3071,6 +3159,7 @@ static void atmel_command_irq(struct atm
 				priv->fast_scan = !fast_scan;
 				atmel_scan(priv, 1);
 			}
+			priv->site_survey_state = SITE_SURVEY_COMPLETED;
 		}
 		break;
 		
@@ -3104,12 +3193,8 @@ static void atmel_command_irq(struct atm
 			return;
 		}
 		
-
-		if (priv->station_state == STATION_STATE_FORCED_JOINNING) {
-			atmel_enter_state(priv, STATION_STATE_FORCED_JOIN_FAILURE); 
-		} else {
-			atmel_scan(priv, 1);
-		}
+		atmel_scan(priv, 1);
+		
 	}
 }
 
@@ -3275,7 +3360,7 @@ static int probe_atmel_card(struct net_d
 			printk(KERN_ALERT "%s: *** Invalid MAC address. UPGRADE Firmware ****\n", dev->name);
 			memcpy(dev->dev_addr, default_mac, 6);
 		}
-		printk(KERN_INFO "%s: MAC address %x:%x:%x:%x:%x:%x\n",
+		printk(KERN_INFO "%s: MAC address %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 		       dev->name,
 		       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
 		       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
@@ -3285,6 +3370,105 @@ static int probe_atmel_card(struct net_d
 	return rc;
 }
 
+static void build_wep_mib(struct atmel_private *priv)
+/* Move the encyption information on the MIB structure.
+   This routine is for the pre-WPA firmware: later firmware has
+   a different format MIB and a different routine. */
+{
+	struct { /* NB this is matched to the hardware, don't change. */
+		u8 wep_is_on;                 
+		u8 default_key; /* 0..3 */
+		u8 reserved;
+		u8 exclude_unencrypted;
+		
+		u32 WEPICV_error_count;
+		u32 WEP_excluded_count;
+		
+		u8 wep_keys[MAX_ENCRYPTION_KEYS][13];
+ 		u8 encryption_level; /* 0, 1, 2 */
+		u8 reserved2[3]; 
+	} mib;
+	int i;
+
+	mib.wep_is_on = priv->wep_is_on;
+	if (priv->wep_is_on) {
+		if (priv->wep_key_len[priv->default_key] > 5)
+			mib.encryption_level = 2;
+		else
+			mib.encryption_level = 1;	
+	} else {
+		mib.encryption_level = 0;
+	}
+
+	mib.default_key = priv->default_key;
+	mib.exclude_unencrypted = priv->exclude_unencrypted;
+	
+	for(i = 0; i < MAX_ENCRYPTION_KEYS;  i++)
+		memcpy(mib.wep_keys[i], priv->wep_keys[i], 13);
+		
+	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));
+}
+
+static void build_wpa_mib(struct atmel_private *priv)
+{
+	/* This is for the later (WPA enabled) firmware. */	   
+
+	struct { /* NB this is matched to the hardware, don't change. */
+		u8 cipher_default_key_value[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];
+		u8 receiver_address[6];
+		u8 wep_is_on;                 
+		u8 default_key; /* 0..3 */
+		u8 group_key;
+		u8 exclude_unencrypted;
+		u8 encryption_type;
+		u8 reserved;
+		
+		u32 WEPICV_error_count;
+		u32 WEP_excluded_count;
+		
+		u8 key_RSC[4][8];
+	} mib;
+	
+	int i;
+
+	mib.wep_is_on = priv->wep_is_on;
+	mib.exclude_unencrypted = priv->exclude_unencrypted;
+	memcpy(mib.receiver_address, priv->CurrentBSSID, 6);
+	
+	/* zero all the keys before adding in valid ones. */
+	memset(mib.cipher_default_key_value, 0, sizeof(mib.cipher_default_key_value));
+	
+	if (priv->wep_is_on) {
+		/* There's a comment in the Atmel code to the effect that this is only valid
+		   when still using WEP, it may need to be set to something to use WPA */
+		memset(mib.key_RSC, 0, sizeof(mib.key_RSC));
+		
+		mib.default_key = mib.group_key = 255;
+		for (i = 0; i < MAX_ENCRYPTION_KEYS; i++) {
+			if (priv->wep_key_len[i] > 0) {
+				memcpy(mib.cipher_default_key_value[i], priv->wep_keys[i], MAX_ENCRYPTION_KEY_SIZE);
+				if (i == priv->default_key) {
+					mib.default_key = i;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 7;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite; 
+				} else {
+					mib.group_key = i;
+					priv->group_cipher_suite = priv->pairwise_cipher_suite;
+				        mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;	
+				}
+			}
+		}
+		if (mib.default_key == 255)
+			mib.default_key = mib.group_key != 255 ? mib.group_key : 0;
+		if (mib.group_key == 255)
+			mib.group_key = mib.default_key;
+		
+	}
+	
+	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));
+}
+					
 int reset_atmel_card(struct net_device *dev) 
 {
 	/* do everything necessary to wake up the hardware, including
@@ -3305,6 +3489,15 @@ int reset_atmel_card(struct net_device *
 	struct atmel_private *priv = dev->priv;
 	u8 configuration;
 	
+	/* data to add to the firmware names, in priority order
+	   this implemenents firmware versioning */
+	
+	static char *firmware_modifier[] = {
+		"-wpa",
+		"",
+		NULL
+	};
+	
 	if (priv->station_state == STATION_STATE_NO_CARD ||
 	    priv->station_state == STATION_STATE_DOWN)
 		return 0;
@@ -3341,21 +3534,41 @@ int reset_atmel_card(struct net_device *
 		unsigned char *fw;
 		int len = priv->firmware_length;
 		if (!(fw = priv->firmware)) { 
-			if (strlen(priv->firmware_id) == 0) {
-				printk(KERN_INFO
-				       "%s: card type is unknown: assuming at76c502 firmware is OK.\n",
-				       dev->name);
-				printk(KERN_INFO
-				       "%s: if not, use the firmware= module parameter.\n", 
-				       dev->name);
-				strcpy(priv->firmware_id, "atmel_at76c502.bin");
-			}
-			if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) != 0) {
-				printk(KERN_ALERT 
-				       "%s: firmware %s is missing, cannot start.\n", 
-				       dev->name, priv->firmware_id);
-				return 0;
+			if (strlen(priv->firmware_template) == 0) {	
+				if (strlen(priv->firmware_id) == 0) {
+					printk(KERN_INFO
+					       "%s: card type is unknown: assuming at76c502 firmware is OK.\n",
+					       dev->name);
+					printk(KERN_INFO
+					       "%s: if not, use the firmware= module parameter.\n", 
+					       dev->name);
+					strcpy(priv->firmware_id, "atmel_at76c502.bin");
+				}
+				if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) != 0) {
+					printk(KERN_ALERT 
+					       "%s: firmware %s is missing, cannot continue.\n", 
+					       dev->name, priv->firmware_id);
+					return 0;
+					
+				} 
+			} else {
+				int i;
+				
+				for (i = 0; firmware_modifier[i]; i++) {
+					sprintf(priv->firmware_id, priv->firmware_template, firmware_modifier[i]);
+					if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) == 0) 
+						break;
+				}
+				if (!firmware_modifier[i]) {
+					printk(KERN_ALERT 
+					       "%s: firmware %s is missing, cannot start.\n", 
+					       dev->name, priv->firmware_id);
+					priv->firmware_id[0] = '\0';
+					return 0;	
+				}
+				priv->firmware_template[0] = '\0';	
 			}
+			
 			fw = fw_entry->data;
 			len = fw_entry->size;
 		}
@@ -3379,6 +3592,10 @@ int reset_atmel_card(struct net_device *
 
 	if (!atmel_wakeup_firmware(priv))
 		return 0;
+
+	/* Check the version and set the correct flag for wpa stuff,
+	   old and new firmware is incompatible. */
+	priv->use_wpa = (priv->host_info.major_version >= 4);
 	
         /* unmask all irq sources */
 	atmel_wmem8(priv, atmel_hi(priv, IFACE_INT_MASK_OFFSET), 0xff);
@@ -3447,9 +3664,12 @@ int reset_atmel_card(struct net_device *
 	atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
 	atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_BEACON_PER_POS, priv->default_beacon_period);
 	atmel_set_mib(priv, Phy_Mib_Type, PHY_MIB_RATE_SET_POS, atmel_basic_rates, 4);
-	atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep.wep_is_on);
-	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&priv->wep, sizeof(priv->wep));
-		
+	atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep_is_on);
+	if (priv->use_wpa)
+		build_wpa_mib(priv);
+	else
+		build_wep_mib(priv);
+	
 	atmel_scan(priv, 1);
 	
 	atmel_set_gcr(priv->dev, GCR_ENINT); /* enable interrupts */
@@ -3500,8 +3720,8 @@ static u8 atmel_get_mib8(struct atmel_pr
 	m.size = 1;
 	m.index = index;
 
-	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, sizeof(m));
-	return atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + 4));
+	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + 1);
+	return atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE));
 }
 
 static void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index, u8 data)
@@ -3512,7 +3732,7 @@ static void atmel_set_mib8(struct atmel_
 	m.index = index;
 	m.data[0] = data;
 
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 1);
 }
 
 static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index, u16 data)
@@ -3524,7 +3744,7 @@ static void atmel_set_mib16(struct atmel
 	m.data[0] = data;
 	m.data[1] = data >> 8;
 
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 2);
 }
 
 static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
@@ -3534,8 +3754,11 @@ static void atmel_set_mib(struct atmel_p
 	m.size = data_len;
 	m.index = index;
 
+	if (data_len > MIB_MAX_DATA_BYTES)
+		printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);
+	
 	memcpy(m.data, data, data_len);
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
 }
 
 static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
@@ -3545,10 +3768,14 @@ static void atmel_get_mib(struct atmel_p
 	m.size = data_len;
 	m.index = index;
 	
-	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, sizeof(m));
-	atmel_copy_to_host(priv->dev, data, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + 4), data_len);
-}
+	if (data_len > MIB_MAX_DATA_BYTES)
+		printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);
 	
+	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
+	atmel_copy_to_host(priv->dev, data, 
+			   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);
+}
+
 static void atmel_writeAR(struct net_device *dev, u16 data)
 {
 	int i;
diff -purN linux-2.6.1/drivers/net/wireless/atmel_cs.c linux-2.5/drivers/net/wireless/atmel_cs.c
--- linux-2.6.1/drivers/net/wireless/atmel_cs.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/drivers/net/wireless/atmel_cs.c	2004-01-11 00:57:32.000000000 +0000
@@ -330,20 +330,20 @@ static struct { 
 	char *firmware;
 	char *name;
 } card_table[] = {
-	{ 0, 0, "WLAN/802.11b PC CARD", "atmel_at76c502d.bin", "Actiontec 802CAT1" },  
-	{ 0, 0, "ATMEL/AT76C502AR", "atmel_at76c502.bin", "NoName-RFMD" }, 
-	{ 0, 0, "ATMEL/AT76C502AR_D", "atmel_at76c502d.bin", "NoName-revD" }, 
-	{ 0, 0, "ATMEL/AT76C502AR_E", "atmel_at76c502e.bin", "NoName-revE" },
-	{ 0, 0, "ATMEL/AT76C504", "atmel_at76c504.bin", "NoName-504" },
-	{ MANFID_3COM, 0x0620, NULL, "atmel_at76c502_3com.bin", "3com 3CRWE62092B" }, 
-	{ MANFID_3COM, 0x0696, NULL, "atmel_at76c502_3com.bin", "3com 3CRSHPW_96" }, 
-	{ 0, 0, "SMC/2632W-V2", "atmel_at76c502.bin", "SMC 2632W-V2" },
-        { 0, 0, "SMC/2632W", "atmel_at76c502d.bin", "SMC 2632W-V3" },
-	{ 0xd601, 0x0007, NULL, "atmel_at76c502.bin", "Sitecom WLAN-011"}, /* suspect - from a usenet posting. */
-	{ 0x01bf, 0x3302, NULL, "atmel_at76c502d.bin", "Belkin F5D6060u"},  /*    "        "  "    "      "     */
-	{ 0, 0, "BT/Voyager 1020 Laptop Adapter", "atmel_at76c502.bin", "BT Voyager 1020"},
-        { 0, 0, "IEEE 802.11b/Wireless LAN PC Card", "atmel_at76c502.bin", "Siemens Gigaset PC Card II" },
-	{ 0, 0, "CNet/CNWLC 11Mbps Wireless PC Card V-5", "atmel_at76c502e.bin", "CNet CNWLC-811ARL" }
+	{ 0, 0, "WLAN/802.11b PC CARD", "atmel_at76c502d%s.bin", "Actiontec 802CAT1" },  
+	{ 0, 0, "ATMEL/AT76C502AR", "atmel_at76c502%s.bin", "NoName-RFMD" }, 
+	{ 0, 0, "ATMEL/AT76C502AR_D", "atmel_at76c502d%s.bin", "NoName-revD" }, 
+	{ 0, 0, "ATMEL/AT76C502AR_E", "atmel_at76c502e%s.bin", "NoName-revE" },
+	{ 0, 0, "ATMEL/AT76C504", "atmel_at76c504%s.bin", "NoName-504" },
+	{ MANFID_3COM, 0x0620, NULL, "atmel_at76c502_3com%s.bin", "3com 3CRWE62092B" }, 
+	{ MANFID_3COM, 0x0696, NULL, "atmel_at76c502_3com%s.bin", "3com 3CRSHPW_96" }, 
+	{ 0, 0, "SMC/2632W-V2", "atmel_at76c502%s.bin", "SMC 2632W-V2" },
+        { 0, 0, "SMC/2632W", "atmel_at76c502d%s.bin", "SMC 2632W-V3" },
+	{ 0xd601, 0x0007, NULL, "atmel_at76c502%s.bin", "Sitecom WLAN-011"}, /* suspect - from a usenet posting. */
+	{ 0x01bf, 0x3302, NULL, "atmel_at76c502d%s.bin", "Belkin F5D6060u"},  /*    "        "  "    "      "     */
+	{ 0, 0, "BT/Voyager 1020 Laptop Adapter", "atmel_at76c502%s.bin", "BT Voyager 1020"},
+        { 0, 0, "IEEE 802.11b/Wireless LAN PC Card", "atmel_at76c502%s.bin", "Siemens Gigaset PC Card II" },
+	{ 0, 0, "CNet/CNWLC 11Mbps Wireless PC Card V-5", "atmel_at76c502e%s.bin", "CNet CNWLC-811ARL" }
 };
 
 /* This is strictly temporary, until PCMCIA devices get integrated into the device model. */
diff -purN linux-2.6.1/drivers/net/wireless/orinoco_pci.c linux-2.5/drivers/net/wireless/orinoco_pci.c
--- linux-2.6.1/drivers/net/wireless/orinoco_pci.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/drivers/net/wireless/orinoco_pci.c	2004-01-10 16:25:36.000000000 +0000
@@ -360,6 +360,7 @@ static int orinoco_pci_resume(struct pci
 }
 
 static struct pci_device_id orinoco_pci_pci_id_table[] = {
+	{0x1260, 0x3872, PCI_ANY_ID, PCI_ANY_ID,},
 	{0x1260, 0x3873, PCI_ANY_ID, PCI_ANY_ID,},
 	{0,},
 };
diff -purN linux-2.6.1/drivers/scsi/53c7xx.c linux-2.5/drivers/scsi/53c7xx.c
--- linux-2.6.1/drivers/scsi/53c7xx.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/drivers/scsi/53c7xx.c	2004-01-11 02:15:44.000000000 +0000
@@ -1102,8 +1102,8 @@ NCR53c7x0_init (struct Scsi_Host *host) 
 }
 
 /* 
- * Function : static int ncr53c7xx_init(Scsi_Host_Template *tpnt, int board, 
- *	int chip, u32 base, int io_port, int irq, int dma, long long options,
+ * Function : int ncr53c7xx_init(Scsi_Host_Template *tpnt, int board, int chip,
+ *	unsigned long base, int io_port, int irq, int dma, long long options,
  *	int clock);
  *
  * Purpose : initializes a NCR53c7,8x0 based on base addresses,
diff -purN linux-2.6.1/drivers/scsi/53c7xx.h linux-2.5/drivers/scsi/53c7xx.h
--- linux-2.6.1/drivers/scsi/53c7xx.h	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/drivers/scsi/53c7xx.h	2004-01-11 02:15:44.000000000 +0000
@@ -1600,5 +1600,9 @@ struct NCR53c7x0_hostdata {
 /* Paranoid people could use panic() here. */
 #define FATAL(host) shutdown((host));
 
+extern int ncr53c7xx_init(Scsi_Host_Template *tpnt, int board, int chip,
+			  unsigned long base, int io_port, int irq, int dma,
+			  long long options, int clock);
+
 #endif /* NCR53c710_C */
 #endif /* NCR53c710_H */
diff -purN linux-2.6.1/drivers/scsi/Kconfig linux-2.5/drivers/scsi/Kconfig
--- linux-2.6.1/drivers/scsi/Kconfig	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/drivers/scsi/Kconfig	2004-01-15 10:18:55.000000000 +0000
@@ -1210,6 +1210,8 @@ config SCSI_QLOGICPTI
 	  To compile this driver as a module, choose M here: the
 	  module will be called qlogicpti.
 
+source "drivers/scsi/qla2xxx/Kconfig"
+
 config SCSI_SEAGATE
 	tristate "Seagate ST-02 and Future Domain TMC-8xx SCSI support"
 	depends on X86 && ISA && SCSI && BROKEN
@@ -1473,12 +1475,6 @@ config A3000_SCSI
 	  To compile this driver as a module, choose M here: the
 	  module will be called wd33c93.
 
-config A4000T_SCSI
-	bool "A4000T SCSI support (EXPERIMENTAL)"
-	depends on AMIGA && SCSI && EXPERIMENTAL && BROKEN
-	help
-	  Support for the NCR53C710 SCSI controller on the Amiga 4000T.
-
 config A2091_SCSI
 	tristate "A2091/A590 WD33C93A support"
 	depends on ZORRO && SCSI
@@ -1541,28 +1537,24 @@ config FASTLANE_SCSI
 	  If you have the Phase5 Fastlane Z3 SCSI controller, or plan to use
 	  one in the near future, say Y to this question. Otherwise, say N.
 
-config A4091_SCSI
-	bool "A4091 SCSI support (EXPERIMENTAL)"
-	depends on ZORRO && SCSI && EXPERIMENTAL && BROKEN
-	help
-	  Support for the NCR53C710 chip on the Amiga 4091 Z3 SCSI2 controller
-	  (1993).  Very obscure -- the 4091 was part of an Amiga 4000 upgrade
-	  plan at the time the Amiga business was sold to DKB.
-
-config WARPENGINE_SCSI
-	bool "WarpEngine SCSI support (EXPERIMENTAL)"
-	depends on ZORRO && SCSI && EXPERIMENTAL && BROKEN
-	help
-	  Support for MacroSystem Development's WarpEngine Amiga SCSI-2
-	  controller. Info at
-	  <http://www.lysator.liu.se/amiga/ar/guide/ar310.guide?FEATURE5>.
-
-config BLZ603EPLUS_SCSI
-	bool "Blizzard PowerUP 603e+ SCSI (EXPERIMENTAL)"
-	depends on ZORRO && SCSI && EXPERIMENTAL && BROKEN
+config SCSI_AMIGA7XX
+	bool "Amiga NCR53c710 SCSI support (EXPERIMENTAL)"
+	depends on AMIGA && SCSI && EXPERIMENTAL && BROKEN
 	help
-	  If you have an Amiga 1200 with a Phase5 Blizzard PowerUP 603e+
-	  accelerator, say Y. Otherwise, say N.
+	  Support for various NCR53c710-based SCSI controllers on the Amiga.
+	  This includes:
+	    - the builtin SCSI controller on the Amiga 4000T,
+	    - the Amiga 4091 Zorro III SCSI-2 controller,
+	    - the MacroSystem Development's WarpEngine Amiga SCSI-2 controller
+	      (info at
+	      <http://www.lysator.liu.se/amiga/ar/guide/ar310.guide?FEATURE5>),
+	    - the SCSI controller on the Phase5 Blizzard PowerUP 603e+
+	      accelerator card for the Amiga 1200,
+	    - the SCSI controller on the GVP Turbo 040/060 accelerator.
+	  Note that all of the above SCSI controllers, except for the builtin
+	  SCSI controller on the Amiga 4000T, reside on the Zorro expansion
+	  bus, so you also have to enable Zorro bus support if you want to use
+	  them.
 
 config OKTAGON_SCSI
 	tristate "BSC Oktagon SCSI support (EXPERIMENTAL)"
@@ -1660,7 +1652,7 @@ config BVME6000_SCSI
 
 config SCSI_NCR53C7xx_FAST
 	bool "allow FAST-SCSI [10MHz]"
-	depends on A4000T_SCSI || A4091_SCSI || BLZ603EPLUS_SCSI || WARPENGINE_SCSI || MVME16x_SCSI || BVME6000_SCSI
+	depends on SCSI_AMIGA7XX || MVME16x_SCSI || BVME6000_SCSI
 	help
 	  This will enable 10MHz FAST-SCSI transfers with your host
 	  adapter. Some systems have problems with that speed, so it's safest
@@ -1706,7 +1698,6 @@ config WD33C93_PIO
 	default y
 
 #      bool 'Cyberstorm Mk III SCSI support (EXPERIMENTAL)' CONFIG_CYBERSTORMIII_SCSI
-#      bool 'GVP Turbo 040/060 SCSI support (EXPERIMENTAL)' CONFIG_GVP_TURBO_SCSI
 
 config ZFCP
 	tristate "IBM z900 OpenFCP/SCSI support"
diff -purN linux-2.6.1/drivers/scsi/Makefile linux-2.5/drivers/scsi/Makefile
--- linux-2.6.1/drivers/scsi/Makefile	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/scsi/Makefile	2004-01-15 10:18:55.000000000 +0000
@@ -22,10 +22,7 @@ subdir-$(CONFIG_PCMCIA)		+= pcmcia
 
 obj-$(CONFIG_SCSI)		+= scsi_mod.o
 
-obj-$(CONFIG_A4000T_SCSI)	+= amiga7xx.o	53c7xx.o
-obj-$(CONFIG_A4091_SCSI)	+= amiga7xx.o	53c7xx.o
-obj-$(CONFIG_BLZ603EPLUS_SCSI)	+= amiga7xx.o	53c7xx.o
-obj-$(CONFIG_WARPENGINE_SCSI)	+= amiga7xx.o	53c7xx.o
+obj-$(CONFIG_SCSI_AMIGA7XX)	+= amiga7xx.o	53c7xx.o
 obj-$(CONFIG_A3000_SCSI)	+= a3000.o	wd33c93.o
 obj-$(CONFIG_A2091_SCSI)	+= a2091.o	wd33c93.o
 obj-$(CONFIG_GVP11_SCSI)	+= gvp11.o	wd33c93.o
@@ -74,6 +71,7 @@ obj-$(CONFIG_SCSI_QLOGIC_FAS)	+= qlogicf
 obj-$(CONFIG_SCSI_QLOGIC_ISP)	+= qlogicisp.o 
 obj-$(CONFIG_SCSI_QLOGIC_FC)	+= qlogicfc.o 
 obj-$(CONFIG_SCSI_QLOGIC_1280)	+= qla1280.o 
+obj-$(CONFIG_SCSI_QLA2XXX)	+= qla2xxx/
 obj-$(CONFIG_SCSI_PAS16)	+= pas16.o
 obj-$(CONFIG_SCSI_SEAGATE)	+= seagate.o
 obj-$(CONFIG_SCSI_FD_8xx)	+= seagate.o
diff -purN linux-2.6.1/drivers/scsi/NCR53C9x.h linux-2.5/drivers/scsi/NCR53C9x.h
--- linux-2.6.1/drivers/scsi/NCR53C9x.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/scsi/NCR53C9x.h	2004-01-11 02:19:04.000000000 +0000
@@ -652,8 +652,7 @@ extern int nesps, esps_in_use, esps_runn
 
 
 /* External functions */
-extern inline void esp_cmd(struct NCR_ESP *esp, struct ESP_regs *eregs,
-			   unchar cmd);
+extern void esp_cmd(struct NCR_ESP *esp, struct ESP_regs *eregs, unchar cmd);
 extern struct NCR_ESP *esp_allocate(Scsi_Host_Template *, void *);
 extern void esp_deallocate(struct NCR_ESP *);
 extern void esp_release(void);
diff -purN linux-2.6.1/drivers/scsi/aacraid/aachba.c linux-2.5/drivers/scsi/aacraid/aachba.c
--- linux-2.6.1/drivers/scsi/aacraid/aachba.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/scsi/aacraid/aachba.c	2004-01-11 00:21:26.000000000 +0000
@@ -1427,6 +1427,7 @@ static int aac_send_srb_fib(struct scsi_
 		flag = SRB_DataIn;
 		break;
 	case DMA_NONE:
+	default:	/* shuts up some versions of gcc */
 		flag = SRB_NoDataXfer;
 		break;
 	}
diff -purN linux-2.6.1/drivers/scsi/aha152x.c linux-2.5/drivers/scsi/aha152x.c
--- linux-2.6.1/drivers/scsi/aha152x.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/drivers/scsi/aha152x.c	2004-01-10 19:05:31.000000000 +0000
@@ -860,9 +860,6 @@ static int aha152x_porttest(int io_port)
 {
 	int i;
 
-	if (check_region(io_port, IO_RANGE))
-		return 0;
-
 	SETPORT(io_port + O_DMACNTRL1, 0);	/* reset stack pointer */
 	for (i = 0; i < 16; i++)
 		SETPORT(io_port + O_STACK, i);
@@ -878,9 +875,6 @@ static int tc1550_porttest(int io_port)
 {
 	int i;
 
-	if (check_region(io_port, IO_RANGE))
-		return 0;
-
 	SETPORT(io_port + O_TC_DMACNTRL1, 0);	/* reset stack pointer */
 	for (i = 0; i < 16; i++)
 		SETPORT(io_port + O_STACK, i);
@@ -903,13 +897,20 @@ static int checksetup(struct aha152x_set
 	if (i == ARRAY_SIZE(ports))
 		return 0;
 #endif
+	if (!request_region(setup->io_port, IO_RANGE, "aha152x"))
+		return 0;
 
 	if(aha152x_porttest(setup->io_port)) {
-          setup->tc1550=0;
+		setup->tc1550=0;
         } else if(tc1550_porttest(setup->io_port)) {
-          setup->tc1550=1;
-        } else
-          return 0;
+		setup->tc1550=1;
+	} else {
+		release_region(setup->io_port, IO_RANGE);
+		return 0;
+	}
+
+	release_region(setup->io_port, IO_RANGE);
+
 
 	if ((setup->irq < IRQ_MIN) || (setup->irq > IRQ_MAX))
 		return 0;
@@ -965,7 +966,7 @@ struct Scsi_Host *aha152x_probe_one(stru
 {
 	struct Scsi_Host *shpnt;
 
-	shpnt = scsi_register(&aha152x_driver_template, sizeof(struct aha152x_hostdata));
+	shpnt = scsi_host_alloc(&aha152x_driver_template, sizeof(struct aha152x_hostdata));
 	if (!shpnt) {
 		printk(KERN_ERR "aha152x: scsi_register failed\n");
 		return NULL;
@@ -1080,6 +1081,9 @@ struct Scsi_Host *aha152x_probe_one(stru
 		printk(KERN_ERR "aha152x%d: failed to reassign interrupt.\n", shpnt->host_no);
 		goto out_unregister_host;
 	}
+
+	scsi_add_host(shpnt, 0);
+	scsi_scan_host(shpnt);
 	return shpnt;	/* the pcmcia stub needs the return value; */
 
 out_unregister_host:
@@ -1087,11 +1091,11 @@ out_unregister_host:
 out_release_region:
 	release_region(shpnt->io_port, IO_RANGE);
 out_unregister:
-	scsi_unregister(shpnt);
+	scsi_host_put(shpnt);
 	return NULL;
 }
 
-static int aha152x_detect(Scsi_Host_Template * tpnt)
+static int __init aha152x_init(void)
 {
 	int i, j, ok;
 #if defined(AUTOCONF)
@@ -1360,7 +1364,6 @@ static int aha152x_detect(Scsi_Host_Temp
 	return registered_count>0;
 }
 
-
 static int aha152x_release(struct Scsi_Host *shpnt)
 {
 	if (shpnt->irq)
@@ -1374,11 +1377,25 @@ static int aha152x_release(struct Scsi_H
 		pnp_device_detach(HOSTDATA(shpnt)->pnpdev);
 #endif
 
-	scsi_unregister(shpnt);
+	scsi_host_put(shpnt);
 
 	return 0;
 }
 
+static void __exit aha152x_exit(void)
+{
+	int i;
+
+	for(i=0; i<ARRAY_SIZE(setup); i++) {
+		if(aha152x_host[i]) {
+			scsi_remove_host(aha152x_host[i]);
+			aha152x_release(aha152x_host[i]);
+			aha152x_host[i]=0;
+		}
+	}
+}
+
+
 /*
  * setup controller to generate interrupts depending
  * on current state (lock has to be acquired)
@@ -3880,26 +3897,22 @@ static int aha152x_proc_info(struct Scsi
 }
 
 static Scsi_Host_Template aha152x_driver_template = {
-	.module			= THIS_MODULE,
-	.name			= AHA152X_REVID,
-	.proc_name		= "aha152x",
-	.proc_info		= aha152x_proc_info,
-	.detect			= aha152x_detect,
-	.queuecommand		= aha152x_queue,
-	.eh_abort_handler	= aha152x_abort,
-	.eh_device_reset_handler = aha152x_device_reset,
-	.eh_bus_reset_handler	= aha152x_bus_reset,
-	.eh_host_reset_handler	= aha152x_host_reset,
-	.release		= aha152x_release,
-	.bios_param		= aha152x_biosparam,
-	.can_queue		= 1,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.module				= THIS_MODULE,
+	.name				= AHA152X_REVID,
+	.proc_name			= "aha152x",
+	.proc_info			= aha152x_proc_info,
+	.queuecommand			= aha152x_queue,
+	.eh_abort_handler		= aha152x_abort,
+	.eh_device_reset_handler	= aha152x_device_reset,
+	.eh_bus_reset_handler		= aha152x_bus_reset,
+	.eh_host_reset_handler		= aha152x_host_reset,
+	.bios_param			= aha152x_biosparam,
+	.can_queue			= 1,
+	.this_id			= 7,
+	.sg_tablesize			= SG_ALL,
+	.cmd_per_lun			= 1,
+	.use_clustering			= DISABLE_CLUSTERING,
 };
 
-#ifndef PCMCIA
-#define driver_template aha152x_driver_template
-#include "scsi_module.c"
-#endif
+module_init(aha152x_init);
+module_exit(aha152x_exit);
diff -purN linux-2.6.1/drivers/scsi/aic7xxx/aic79xx_osm.c linux-2.5/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-2.6.1/drivers/scsi/aic7xxx/aic79xx_osm.c	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/drivers/scsi/aic7xxx/aic79xx_osm.c	2003-12-19 21:35:11.000000000 +0000
@@ -1776,12 +1776,18 @@ ahd_dmamem_alloc(struct ahd_softc *ahd, 
 	 * our dma mask when doing allocations.
 	 */
 	if (ahd->dev_softc != NULL)
-		ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF);
+		if (ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF)) {
+			printk(KERN_WARNING "aic79xx: No suitable DMA available.\n");
+			return (ENODEV);
+		}
 	*vaddr = pci_alloc_consistent(ahd->dev_softc,
 				      dmat->maxsize, &map->bus_addr);
 	if (ahd->dev_softc != NULL)
-		ahd_pci_set_dma_mask(ahd->dev_softc,
-				     ahd->platform_data->hw_dma_mask);
+		if (ahd_pci_set_dma_mask(ahd->dev_softc,
+				     ahd->platform_data->hw_dma_mask)) {
+			printk(KERN_WARNING "aic79xx: No suitable DMA available.\n");
+			return (ENODEV);
+		}
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
 	/*
 	 * At least in 2.2.14, malloc is a slab allocator so all
diff -purN linux-2.6.1/drivers/scsi/aic7xxx/aic7xxx_osm.c linux-2.5/drivers/scsi/aic7xxx/aic7xxx_osm.c
--- linux-2.6.1/drivers/scsi/aic7xxx/aic7xxx_osm.c	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/scsi/aic7xxx/aic7xxx_osm.c	2003-12-19 21:29:17.000000000 +0000
@@ -1411,12 +1411,18 @@ ahc_dmamem_alloc(struct ahc_softc *ahc, 
 	 * our dma mask when doing allocations.
 	 */
 	if (ahc->dev_softc != NULL)
-		ahc_pci_set_dma_mask(ahc->dev_softc, 0xFFFFFFFF);
+		if (ahc_pci_set_dma_mask(ahc->dev_softc, 0xFFFFFFFF)) {
+			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
+			return (ENODEV);
+		}
 	*vaddr = pci_alloc_consistent(ahc->dev_softc,
 				      dmat->maxsize, &map->bus_addr);
 	if (ahc->dev_softc != NULL)
-		ahc_pci_set_dma_mask(ahc->dev_softc,
-				     ahc->platform_data->hw_dma_mask);
+		if (ahc_pci_set_dma_mask(ahc->dev_softc,
+				     ahc->platform_data->hw_dma_mask)) {
+			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
+			return (ENODEV);
+		}
 #else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
 	/*
 	 * At least in 2.2.14, malloc is a slab allocator so all
diff -purN linux-2.6.1/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c linux-2.5/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
--- linux-2.6.1/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c	2003-12-19 21:31:43.000000000 +0000
@@ -166,7 +166,10 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 		ahc->flags |= AHC_39BIT_ADDRESSING;
 		ahc->platform_data->hw_dma_mask = mask_39bit;
 	} else {
-		ahc_pci_set_dma_mask(pdev, 0xFFFFFFFF);
+		if (ahc_pci_set_dma_mask(pdev, 0xFFFFFFFF)) {
+			printk(KERN_WARNING "aic7xxx: No suitable DMA available.\n");
+                	return (-ENODEV);
+		}
 		ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	}
 #endif
diff -purN linux-2.6.1/drivers/scsi/aic7xxx_old/aic7xxx_proc.c linux-2.5/drivers/scsi/aic7xxx_old/aic7xxx_proc.c
--- linux-2.6.1/drivers/scsi/aic7xxx_old/aic7xxx_proc.c	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/drivers/scsi/aic7xxx_old/aic7xxx_proc.c	2004-01-11 00:25:57.000000000 +0000
@@ -90,9 +90,7 @@ aic7xxx_proc_info ( struct Scsi_Host *HB
   unsigned char i;
   unsigned char tindex;
 
-  HBAptr = NULL;
-
-  for(p=first_aic7xxx; p->host != HBAptr; p=p->next)
+  for(p=first_aic7xxx; p && p->host != HBAptr; p=p->next)
     ;
 
   if (!p)
diff -purN linux-2.6.1/drivers/scsi/amiga7xx.c linux-2.5/drivers/scsi/amiga7xx.c
--- linux-2.6.1/drivers/scsi/amiga7xx.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/scsi/amiga7xx.c	2004-01-11 02:18:15.000000000 +0000
@@ -1,6 +1,6 @@
 /*
  * Detection routine for the NCR53c710 based Amiga SCSI Controllers for Linux.
- *  		Amiga MacroSystemUS WarpEngine SCSI controller.
+ *		Amiga MacroSystemUS WarpEngine SCSI controller.
  *		Amiga Technologies A4000T SCSI controller.
  *		Amiga Technologies/DKB A4091 SCSI controller.
  *
@@ -14,13 +14,14 @@
 #include <linux/version.h>
 #include <linux/config.h>
 #include <linux/zorro.h>
+#include <linux/stat.h>
 
 #include <asm/setup.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/amigaints.h>
 #include <asm/amigahw.h>
-
+#include <asm/dma.h>
 #include <asm/irq.h>
 
 #include "scsi.h"
@@ -28,107 +29,83 @@
 #include "53c7xx.h"
 #include "amiga7xx.h"
 
-#include<linux/stat.h>
-
-extern int ncr53c7xx_init (Scsi_Host_Template *tpnt, int board, int chip, 
-			   unsigned long base, int io_port, int irq, int dma,
-			   long long options, int clock);
 
-int __init amiga7xx_detect(Scsi_Host_Template *tpnt)
+static int amiga7xx_register_one(Scsi_Host_Template *tpnt,
+				 unsigned long address)
 {
-    static unsigned char called = 0;
-    int num = 0, clock;
     long long options;
-    struct zorro_dev *z = NULL;
-    unsigned long address;
+    int clock;
 
-    if (called || !MACH_IS_AMIGA)
+    if (!request_mem_region(address, 0x1000, "ncr53c710"))
 	return 0;
 
-    tpnt->proc_name = "Amiga7xx";
+    address = (unsigned long)z_ioremap(address, 0x1000);
+    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 | OPTION_INTFLY |
+	      OPTION_SYNCHRONOUS | OPTION_ALWAYS_SYNCHRONOUS |
+	      OPTION_DISCONNECT;
+    clock = 50000000;	/* 50 MHz SCSI Clock */
+    ncr53c7xx_init(tpnt, 0, 710, address, 0, IRQ_AMIGA_PORTS, DMA_NONE,
+		   options, clock);
+    return 1;
+}
 
-#ifdef CONFIG_A4000T_SCSI
-    if (AMIGAHW_PRESENT(A4000_SCSI)) {
-	address = 0xdd0040;
-	if (request_mem_region(address, 0x1000, "ncr53c710")) { 
-	    address = ZTWO_VADDR(address);
-	    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 |
-		      OPTION_INTFLY | OPTION_SYNCHRONOUS |
-		      OPTION_ALWAYS_SYNCHRONOUS | OPTION_DISCONNECT;
-	    clock = 50000000;	/* 50MHz SCSI Clock */
-	    ncr53c7xx_init(tpnt, 0, 710, address, 0, IRQ_AMIGA_PORTS, DMA_NONE,
-			   options, clock);
-	    num++;
-	}
-    }
-#endif
+
+#ifdef CONFIG_ZORRO
+
+static struct {
+    zorro_id id;
+    unsigned long offset;
+    int absolute;	/* offset is absolute address */
+} amiga7xx_table[] = {
+    { .id = ZORRO_PROD_PHASE5_BLIZZARD_603E_PLUS, .offset = 0xf40000,
+      .absolute = 1 },
+    { .id = ZORRO_PROD_MACROSYSTEMS_WARP_ENGINE_40xx, .offset = 0x40000 },
+    { .id = ZORRO_PROD_CBM_A4091_1, .offset = 0x800000 },
+    { .id = ZORRO_PROD_CBM_A4091_2, .offset = 0x800000 },
+    { .id = ZORRO_PROD_GVP_GFORCE_040_060, .offset = 0x40000 },
+    { 0 }
+};
+
+static int __init amiga7xx_zorro_detect(Scsi_Host_Template *tpnt)
+{
+    int num = 0, i;
+    struct zorro_dev *z = NULL;
+    unsigned long address;
 
     while ((z = zorro_find_device(ZORRO_WILDCARD, z))) {
-	unsigned long address = z->resource.start;
-	unsigned long size = z->resource.end-z->resource.start+1;
-	switch (z->id) {
-#ifdef CONFIG_BLZ603EPLUS_SCSI
-	    case ZORRO_PROD_PHASE5_BLIZZARD_603E_PLUS:
-		address = 0xf40000;
-		if (request_mem_region(address, 0x1000, "ncr53c710")) {
-		    address = ZTWO_VADDR(address);
-		    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 |
-			      OPTION_INTFLY | OPTION_SYNCHRONOUS | 
-			      OPTION_ALWAYS_SYNCHRONOUS | OPTION_DISCONNECT;
-		    clock = 50000000;	/* 50MHz SCSI Clock */
-		    ncr53c7xx_init(tpnt, 0, 710, address, 0, IRQ_AMIGA_PORTS,
-				   DMA_NONE, options, clock);
-		    num++;
-		}
+	for (i = 0; amiga7xx_table[i].id; i++)
+	    if (z->id == amiga7xx_table[i].id)
 		break;
-#endif
+	if (!amiga7xx_table[i].id)
+	    continue;
+	if (amiga7xx_table[i].absolute)
+	    address = amiga7xx_table[i].offset;
+	else
+	    address = z->resource.start + amiga7xx_table[i].offset;
+	num += amiga7xx_register_one(tpnt, address);
+    }
+    return num;
+}
 
-#ifdef CONFIG_WARPENGINE_SCSI
-    	    case ZORRO_PROD_MACROSYSTEMS_WARP_ENGINE_40xx:
-		if (request_mem_region(address+0x40000, 0x1000, "ncr53c710")) {
-		    address = (unsigned long)z_ioremap(address, size);
-		    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 |
-			      OPTION_INTFLY | OPTION_SYNCHRONOUS |
-			      OPTION_ALWAYS_SYNCHRONOUS | OPTION_DISCONNECT;
-		    clock = 50000000;	/* 50MHz SCSI Clock */
-		    ncr53c7xx_init(tpnt, 0, 710, address+0x40000, 0,
-				   IRQ_AMIGA_PORTS, DMA_NONE, options, clock);
-		    num++;
-		}
-		break;
-#endif
+#endif /* CONFIG_ZORRO */
 
-#ifdef CONFIG_A4091_SCSI
-	    case ZORRO_PROD_CBM_A4091_1:
-	    case ZORRO_PROD_CBM_A4091_2:
-		if (request_mem_region(address+0x800000, 0x1000, "ncr53c710")) {
-		    address = (unsigned long)z_ioremap(address, size);
-		    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 |
-			      OPTION_INTFLY | OPTION_SYNCHRONOUS |
-			      OPTION_ALWAYS_SYNCHRONOUS | OPTION_DISCONNECT;
-		    clock = 50000000;	/* 50MHz SCSI Clock */
-		    ncr53c7xx_init(tpnt, 0, 710, address+0x800000, 0,
-				   IRQ_AMIGA_PORTS, DMA_NONE, options, clock);
-		    num++;
-		}
-		break;
-#endif
 
-#ifdef CONFIG_GVP_TURBO_SCSI
-    	    case ZORRO_PROD_GVP_GFORCE_040_060:
-		if (request_mem_region(address+0x40000, 0x1000, "ncr53c710")) {
-		    address = ZTWO_VADDR(address);
-		    options = OPTION_MEMORY_MAPPED | OPTION_DEBUG_TEST1 |
-			      OPTION_INTFLY | OPTION_SYNCHRONOUS |
-			      OPTION_ALWAYS_SYNCHRONOUS | OPTION_DISCONNECT;
-		    clock = 50000000;	/* 50MHz SCSI Clock */
-		    ncr53c7xx_init(tpnt, 0, 710, address+0x40000, 0,
-				   IRQ_AMIGA_PORTS, DMA_NONE, options, clock);
-		    num++;
-		}
+int __init amiga7xx_detect(Scsi_Host_Template *tpnt)
+{
+    static unsigned char called = 0;
+    int num = 0;
+
+    if (called || !MACH_IS_AMIGA)
+	return 0;
+
+    tpnt->proc_name = "Amiga7xx";
+
+    if (AMIGAHW_PRESENT(A4000_SCSI))
+	num += amiga7xx_register_one(tpnt, 0xdd0040);
+
+#ifdef CONFIG_ZORRO
+    num += amiga7xx_zorro_detect(tpnt);
 #endif
-	}
-    }
 
     called = 1;
     return num;
diff -purN linux-2.6.1/drivers/scsi/atp870u.c linux-2.5/drivers/scsi/atp870u.c
--- linux-2.6.1/drivers/scsi/atp870u.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/scsi/atp870u.c	2004-01-10 19:05:06.000000000 +0000
@@ -42,50 +42,6 @@
 
 static unsigned short int sync_idu;
 
-#define MAX_ATP		16
-
-struct atp_unit {
-	unsigned long ioport;
-	unsigned long irq;
-	unsigned long pciport;
-	unsigned char last_cmd;
-	unsigned char in_snd;
-	unsigned char in_int;
-	unsigned char quhdu;
-	unsigned char quendu;
-	unsigned char scam_on;
-	unsigned char global_map;
-	unsigned char chip_veru;
-	unsigned char host_idu;
-	int working;
-	unsigned short wide_idu;
-	unsigned short active_idu;
-	unsigned short ultra_map;
-	unsigned short async;
-	unsigned short deviceid;
-	unsigned char ata_cdbu[16];
-	unsigned char sp[16];
-	Scsi_Cmnd *querequ[qcnt];
-	struct atp_id {
-		unsigned char dirctu;
-		unsigned char devspu;
-		unsigned char devtypeu;
-		unsigned long prdaddru;
-		unsigned long tran_lenu;
-		unsigned long last_lenu;
-		unsigned char *prd_posu;
-		unsigned char *prd_tableu;
-		dma_addr_t prd_phys;
-		Scsi_Cmnd *curr_req;
-	} id[16];
-	struct Scsi_Host *host;
-	struct pci_dev *pdev;
-};
-
-static struct Scsi_Host *atp_host[MAX_ATP];
-
-static void send_s870(struct Scsi_Host *);
-
 static irqreturn_t atp870u_intr_handle(int irq, void *dev_id,
 					struct pt_regs *regs)
 {
@@ -878,7 +834,7 @@ static void tscam(struct Scsi_Host *host
 	unsigned long n;
 	unsigned short int m, assignid_map, val;
 	unsigned char mbuf[33], quintet[2];
-	struct atp_unit *dev = (struct atp_unit *)host->hostdata;
+	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
 	static unsigned char g2q_tab[8] = {
 		0x38, 0x31, 0x32, 0x2b, 0x34, 0x2d, 0x2e, 0x27
 	};
@@ -2253,15 +2209,31 @@ set_syn_ok:
 	}
 }
 
-
-static void atp870u_init_tables(struct Scsi_Host *host)
+static void atp870u_free_tables(struct Scsi_Host *host)
 {
-	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
+	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
 	int k;
 
 	for (k = 0; k < 16; k++) {
-		/* FIXME */
+		if (!atp_dev->id[k].prd_tableu)
+			continue;
+		pci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[k].prd_tableu,
+					atp_dev->id[k].prd_phys);
+		atp_dev->id[k].prd_tableu = NULL;
+	}
+}
+
+static int atp870u_init_tables(struct Scsi_Host *host)
+{
+	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
+	int k, i;
+
+	for (i = k = 0; k < 16; k++) {
 		dev->id[k].prd_tableu = pci_alloc_consistent(dev->pdev, 1024, &dev->id[k].prd_phys);
+		if (!dev->id[k].prd_tableu) {
+			atp870u_free_tables(host);
+			return -ENOMEM;
+		}
 		dev->id[k].devspu = 0x20;
 		dev->id[k].devtypeu = 0;
 		dev->id[k].curr_req = NULL;
@@ -2282,293 +2254,294 @@ static void atp870u_init_tables(struct S
 		dev->id[k].curr_req = 0;
 		dev->sp[k] = 0x04;
 	}
+	return 0;
 }			
 
 /* return non-zero on detection */
-static int atp870u_detect(Scsi_Host_Template * tpnt)
+static int atp870u_probe(struct pci_dev *dev, const struct pci_device_id *ent)
 {
-	unsigned char irq, h, k, m;
+	unsigned char k, m;
 	unsigned long flags;
 	unsigned int base_io, error, tmport;
-	struct pci_dev *pdev[MAX_ATP];
-	unsigned char chip_ver[MAX_ATP], host_id;
-	unsigned short dev_id[MAX_ATP], n;
-	struct Scsi_Host *shpnt = NULL;
-	int card = 0;
-	int count = 0;
-
-	static unsigned short devid[9] = {
-		0x8081, 0x8002, 0x8010, 0x8020, 0x8030, 0x8040, 0x8050, 0x8060, 0
-	};
-
-	printk(KERN_INFO "aec671x_detect: \n");
-	tpnt->proc_name = "atp870u";
+	unsigned char host_id;
+	unsigned short n;
+	struct Scsi_Host *shpnt;
+	struct atp_unit atp_dev, *p;
+	static int count;
+
+	if (pci_enable_device(dev))
+		return -EIO;
+
+	if (pci_set_dma_mask(dev, 0xFFFFFFFFUL)) {
+		printk(KERN_ERR "atp870u: 32bit DMA mask required but not available.\n");
+		return -EIO;
+	}
+	
+	memset(&atp_dev, 0, sizeof atp_dev);
+ 
+	/*
+	 * It's probably easier to weed out some revisions like
+	 * this than via the PCI device table
+	 */
+	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
+		error = pci_read_config_byte(dev, PCI_CLASS_REVISION, &atp_dev.chip_veru);
+		if (atp_dev.chip_veru < 2)
+			return -EIO;
+	}
+
+	switch (ent->device) {
+	case 0x8081:
+	case PCI_DEVICE_ID_ARTOP_AEC7612UW:
+	case PCI_DEVICE_ID_ARTOP_AEC7612SUW:
+		atp_dev.chip_veru = 0x04;
+	default:
+		break;
+	}
+
+	base_io = pci_resource_start(dev, 0);
+
+	if (ent->device != 0x8081) {
+		error = pci_read_config_byte(dev, 0x49, &host_id);
+		base_io &= 0xfffffff8;
+
+		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-3 Host Adapter: %d "
+			"IO:%x, IRQ:%d.\n", count, base_io, dev->irq);
+
+		atp_dev.unit = count;	
+		atp_dev.ioport = base_io;
+		atp_dev.pciport = base_io + 0x20;
+		atp_dev.deviceid = ent->device;
+		host_id &= 0x07;
+		atp_dev.host_idu = host_id;
+		tmport = base_io + 0x22;
+		atp_dev.scam_on = inb(tmport);
+		tmport += 0x0b;
+		atp_dev.global_map = inb(tmport++);
+		atp_dev.ultra_map = inw(tmport);
+
+		if (atp_dev.ultra_map == 0) {
+			atp_dev.scam_on = 0x00;
+			atp_dev.global_map = 0x20;
+			atp_dev.ultra_map = 0xffff;
+		}
+
+		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+		if (!shpnt)
+			return -ENOMEM;
 
-	for (h = 0; devid[h]; h++) {
-		struct pci_dev *dev = NULL;
+		p = (struct atp_unit *)&shpnt->hostdata;
 		
-		while((dev = pci_find_device(0x1191, devid[h], dev))!=NULL)
-		{
-			if(pci_enable_device(dev))
-				continue;
-
-			if(pci_set_dma_mask(dev, 0xFFFFFFFFUL))
-			{
-				printk(KERN_ERR "atp870u: 32bit DMA mask required but not available.\n");
-				continue;
-			}
-			chip_ver[card] = 0;
-			dev_id[card] = devid[h];
-
-			if (devid[h] == 0x8002) {
-				error = pci_read_config_byte(dev, 0x08, &chip_ver[card]);
-				if (chip_ver[card] < 2) {
-					continue;
-				}
-			}
-			if (devid[h] == 0x8010 || devid[h] == 0x8081 || devid[h] == 0x8050) {
-				chip_ver[card] = 0x04;
-			}
-			pdev[card] = dev;
-			card++;
-			if (card == MAX_ATP)
-				break;
-		}
-	}
-	for (h = 0; h < card; h++) {
-		struct atp_unit tmp, *dev;
-
-		/* Found an atp870u/w. */
-		base_io = pci_resource_start(pdev[h], 0);
-		irq = pdev[h]->irq;
-
-		if (dev_id[h] != 0x8081) {
-			error = pci_read_config_byte(pdev[h], 0x49, &host_id);
-
-			base_io &= 0xfffffff8;
-
-			if (check_region(base_io, 0x40) != 0) {
-				return 0;
-			}
-			printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-3 Host Adapter: %d    IO:%x, IRQ:%d.\n", h, base_io, irq);
-			
-			tmp.ioport = base_io;
-			tmp.pciport = base_io + 0x20;
-			tmp.deviceid = dev_id[h];
-			host_id &= 0x07;
-			tmp.host_idu = host_id;
-			tmp.chip_veru = chip_ver[h];
-
-			tmport = base_io + 0x22;
-			tmp.scam_on = inb(tmport);
-			tmport += 0x0b;
-			tmp.global_map = inb(tmport++);
-			tmp.ultra_map = inw(tmport);
-			if (tmp.ultra_map == 0) {
-				tmp.scam_on = 0x00;
-				tmp.global_map = 0x20;
-				tmp.ultra_map = 0xffff;
-			}
-			shpnt = scsi_register(tpnt, sizeof(struct atp_unit));
-			if (shpnt == NULL)
-				return count;
-			tmp.host = shpnt;
-			tmp.pdev = pdev[h];
-			/* Save the atp_unit data */
-			memcpy(&shpnt->hostdata, &tmp, sizeof(tmp));
-
-			atp870u_init_tables(shpnt);
-			spin_lock_irqsave(shpnt->host_lock, flags);
-			if (request_irq(irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
-				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
-				goto unregister;
-			}
-
-			if (chip_ver[h] > 0x07) {	/* check if atp876 chip   *//* then enable terminator */
-				tmport = base_io + 0x3e;
-				outb(0x00, tmport);
-			}
+		atp_dev.host = shpnt;
+		atp_dev.pdev = dev;
+		pci_set_drvdata(dev, p);
+		memcpy(p, &atp_dev, sizeof atp_dev);
+		if (atp870u_init_tables(shpnt) < 0)
+			goto unregister;
+
+		if (request_irq(dev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
+			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", dev->irq);
+			goto free_tables;
+		}
 
-			tmport = base_io + 0x3a;
-			k = (inb(tmport) & 0xf3) | 0x10;
-			outb(k, tmport);
-			outb((k & 0xdf), tmport);
-			mdelay(32);
-			outb(k, tmport);
-			mdelay(32);
-			tmport = base_io;
-			outb((host_id | 0x08), tmport);
-			tmport += 0x18;
-			outb(0, tmport);
-			tmport += 0x07;
-			while ((inb(tmport) & 0x80) == 0);
-			tmport -= 0x08;
-			inb(tmport);
-			tmport = base_io + 1;
-			outb(8, tmport++);
-			outb(0x7f, tmport);
-			tmport = base_io + 0x11;
-			outb(0x20, tmport);
-
-			tscam(shpnt);
-			is870(shpnt, base_io);
-			tmport = base_io + 0x3a;
-			outb((inb(tmport) & 0xef), tmport);
-			tmport++;
-			outb((inb(tmport) | 0x20), tmport);
-		} else {
-			base_io &= 0xfffffff8;
+		spin_lock_irqsave(shpnt->host_lock, flags);
+		if (atp_dev.chip_veru > 0x07) {	/* check if atp876 chip then enable terminator */
+			tmport = base_io + 0x3e;
+			outb(0x00, tmport);
+		}
+ 
+		tmport = base_io + 0x3a;
+		k = (inb(tmport) & 0xf3) | 0x10;
+		outb(k, tmport);
+		outb((k & 0xdf), tmport);
+		mdelay(32);
+		outb(k, tmport);
+		mdelay(32);
+		tmport = base_io;
+		outb((host_id | 0x08), tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0)
+			mdelay(1);
 
-			if (check_region(base_io, 0x60) != 0) {
-				return 0;
-			}
-			host_id = inb(base_io + 0x39);
-			host_id >>= 0x04;
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 1;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0x11;
+		outb(0x20, tmport);
 
-			printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d    IO:%x, IRQ:%d.\n", h, base_io, irq);
-			tmp.ioport = base_io + 0x40;
-			tmp.pciport = base_io + 0x28;
-			tmp.deviceid = dev_id[h];
-			tmp.host_idu = host_id;
-			tmp.chip_veru = chip_ver[h];
-
-			tmport = base_io + 0x22;
-			tmp.scam_on = inb(tmport);
-			tmport += 0x13;
-			tmp.global_map = inb(tmport);
-			tmport += 0x07;
-			tmp.ultra_map = inw(tmport);
+		tscam(shpnt);
+		is870(shpnt, base_io);
+		tmport = base_io + 0x3a;
+		outb((inb(tmport) & 0xef), tmport);
+		tmport++;
+		outb((inb(tmport) | 0x20), tmport);
+	} else {
+		base_io &= 0xfffffff8;
+		host_id = inb(base_io + 0x39);
+		host_id >>= 0x04;
+
+		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"
+			"    IO:%x, IRQ:%d.\n", count, base_io, dev->irq);
+		atp_dev.ioport = base_io + 0x40;
+		atp_dev.pciport = base_io + 0x28;
+		atp_dev.deviceid = ent->device;
+		atp_dev.host_idu = host_id;
+
+		tmport = base_io + 0x22;
+		atp_dev.scam_on = inb(tmport);
+		tmport += 0x13;
+		atp_dev.global_map = inb(tmport);
+		tmport += 0x07;
+		atp_dev.ultra_map = inw(tmport);
 
-			n = 0x3f09;
+		n = 0x3f09;
 next_fblk:
-			if (n >= 0x4000) {
-				goto flash_ok;
-			}
-			m = 0;
-			outw(n, base_io + 0x34);
-			n += 0x0002;
-			if (inb(base_io + 0x30) == 0xff) {
-				goto flash_ok;
-			}
-			tmp.sp[m++] = inb(base_io + 0x30);
-			tmp.sp[m++] = inb(base_io + 0x31);
-			tmp.sp[m++] = inb(base_io + 0x32);
-			tmp.sp[m++] = inb(base_io + 0x33);
-			outw(n, base_io + 0x34);
-			n += 0x0002;
-			tmp.sp[m++] = inb(base_io + 0x30);
-			tmp.sp[m++] = inb(base_io + 0x31);
-			tmp.sp[m++] = inb(base_io + 0x32);
-			tmp.sp[m++] = inb(base_io + 0x33);
-			outw(n, base_io + 0x34);
-			n += 0x0002;
-			tmp.sp[m++] = inb(base_io + 0x30);
-			tmp.sp[m++] = inb(base_io + 0x31);
-			tmp.sp[m++] = inb(base_io + 0x32);
-			tmp.sp[m++] = inb(base_io + 0x33);
-			outw(n, base_io + 0x34);
-			n += 0x0002;
-			tmp.sp[m++] = inb(base_io + 0x30);
-			tmp.sp[m++] = inb(base_io + 0x31);
-			tmp.sp[m++] = inb(base_io + 0x32);
-			tmp.sp[m++] = inb(base_io + 0x33);
-			n += 0x0018;
-			goto next_fblk;
+		if (n >= 0x4000)
+			goto flash_ok;
+
+		m = 0;
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		if (inb(base_io + 0x30) == 0xff)
+			goto flash_ok;
+
+		atp_dev.sp[m++] = inb(base_io + 0x30);
+		atp_dev.sp[m++] = inb(base_io + 0x31);
+		atp_dev.sp[m++] = inb(base_io + 0x32);
+		atp_dev.sp[m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[m++] = inb(base_io + 0x30);
+		atp_dev.sp[m++] = inb(base_io + 0x31);
+		atp_dev.sp[m++] = inb(base_io + 0x32);
+		atp_dev.sp[m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[m++] = inb(base_io + 0x30);
+		atp_dev.sp[m++] = inb(base_io + 0x31);
+		atp_dev.sp[m++] = inb(base_io + 0x32);
+		atp_dev.sp[m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[m++] = inb(base_io + 0x30);
+		atp_dev.sp[m++] = inb(base_io + 0x31);
+		atp_dev.sp[m++] = inb(base_io + 0x32);
+		atp_dev.sp[m++] = inb(base_io + 0x33);
+		n += 0x0018;
+		goto next_fblk;
 flash_ok:
-			outw(0, base_io + 0x34);
-			tmp.ultra_map = 0;
-			tmp.async = 0;
-			for (k = 0; k < 16; k++) {
-				n = 1;
-				n = n << k;
-				if (tmp.sp[k] > 1) {
-					tmp.ultra_map |= n;
-				} else {
-					if (tmp.sp[k] == 0) {
-						tmp.async |= n;
-					}
-				}
-			}
-			tmp.async = ~(tmp.async);
-			outb(tmp.global_map, base_io + 0x35);
+		outw(0, base_io + 0x34);
+		atp_dev.ultra_map = 0;
+		atp_dev.async = 0;
+		for (k = 0; k < 16; k++) {
+			n = 1;
+			n = n << k;
+			if (atp_dev.sp[k] > 1) {
+				atp_dev.ultra_map |= n;
+			} else {
+				if (atp_dev.sp[k] == 0)
+					atp_dev.async |= n;
+ 			}
+	 	}
+		atp_dev.async = ~(atp_dev.async);
+		outb(atp_dev.global_map, base_io + 0x35);
+ 
+		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+		if (!shpnt)
+			return -ENOMEM;
+
+		p = (struct atp_unit *)&shpnt->hostdata;
+
+		atp_dev.host = shpnt;
+		atp_dev.pdev = dev;
+		pci_set_drvdata(dev, p);
+		memcpy(p, &atp_dev, sizeof atp_dev);
+		if (atp870u_init_tables(shpnt) < 0) {
+			printk(KERN_ERR "Unable to allocate tables for Acard controller\n");
+			goto unregister;
+		}
+
+		if (request_irq(dev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
+ 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", dev->irq);
+			goto free_tables;
+		}
+
+		spin_lock_irqsave(shpnt->host_lock, flags);
+		tmport = base_io + 0x38;
+		k = inb(tmport) & 0x80;
+		outb(k, tmport);
+		tmport += 0x03;
+		outb(0x20, tmport);
+		mdelay(32);
+		outb(0, tmport);
+		mdelay(32);
+		tmport = base_io + 0x5b;
+		inb(tmport);
+		tmport -= 0x04;
+		inb(tmport);
+		tmport = base_io + 0x40;
+		outb((host_id | 0x08), tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0)
+			mdelay(1);
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 0x41;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0x51;
+		outb(0x20, tmport);
 
-			shpnt = scsi_register(tpnt, sizeof(struct atp_unit));
-			if (shpnt == NULL)
-				return count;
-				
-			tmp.pdev = pdev[h];
-			memcpy(&shpnt->hostdata, &tmp, sizeof(tmp));
-			
-			atp870u_init_tables(shpnt);
-
-			spin_lock_irqsave(shpnt->host_lock, flags);
-			if (request_irq(irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
-				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
-				goto unregister;
-			}
-
-			tmport = base_io + 0x38;
-			k = inb(tmport) & 0x80;
-			outb(k, tmport);
-			tmport += 0x03;
-			outb(0x20, tmport);
-			mdelay(32);
-			outb(0, tmport);
-			mdelay(32);
-			tmport = base_io + 0x5b;
-			inb(tmport);
-			tmport -= 0x04;
-			inb(tmport);
-			tmport = base_io + 0x40;
-			outb((host_id | 0x08), tmport);
-			tmport += 0x18;
-			outb(0, tmport);
-			tmport += 0x07;
-			while ((inb(tmport) & 0x80) == 0);
-			tmport -= 0x08;
-			inb(tmport);
-			tmport = base_io + 0x41;
-			outb(8, tmport++);
-			outb(0x7f, tmport);
-			tmport = base_io + 0x51;
-			outb(0x20, tmport);
-
-			tscam(shpnt);
-			is880(shpnt, base_io);
-			tmport = base_io + 0x38;
-			outb(0xb0, tmport);
-		}
+		tscam(shpnt);
+		is880(shpnt, base_io);
+		tmport = base_io + 0x38;
+		outb(0xb0, tmport);
+	}
 
-		dev = (struct atp_unit *)&shpnt->hostdata;
-		
-		atp_host[h] = shpnt;
-		if (dev->chip_veru == 4) {
-			shpnt->max_id = 16;
-		}
-		shpnt->this_id = host_id;
-		shpnt->unique_id = base_io;
-		shpnt->io_port = base_io;
-		if (dev_id[h] == 0x8081) {
-			shpnt->n_io_port = 0x60;	/* Number of bytes of I/O space used */
-		} else {
-			shpnt->n_io_port = 0x40;	/* Number of bytes of I/O space used */
-		}
-		shpnt->irq = irq;
-		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		if (dev_id[h] == 0x8081) {
-			request_region(base_io, 0x60, "atp870u");	/* Register the IO ports that we use */
-		} else {
-			request_region(base_io, 0x40, "atp870u");	/* Register the IO ports that we use */
-		}
-		count++;
-		continue;
-unregister:
-		scsi_unregister(shpnt);
-		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		continue;
+	if (p->chip_veru == 4)
+		shpnt->max_id = 16;
+
+	shpnt->this_id = host_id;
+	shpnt->unique_id = base_io;
+	shpnt->io_port = base_io;
+	if (ent->device == 0x8081) {
+		shpnt->n_io_port = 0x60;	/* Number of bytes of I/O space used */
+	} else {
+		shpnt->n_io_port = 0x40;	/* Number of bytes of I/O space used */
+	}
+	shpnt->irq = dev->irq;
+	spin_unlock_irqrestore(shpnt->host_lock, flags);
+	if (ent->device == 0x8081) {
+		if (!request_region(base_io, 0x60, "atp870u"))
+			goto request_io_fail;
+	} else {
+		if (!request_region(base_io, 0x40, "atp870u"))
+			goto request_io_fail;
 	}
 
-	return count;
+	count++;
+	if (scsi_add_host(shpnt, &dev->dev))
+		goto scsi_add_fail;
+	scsi_scan_host(shpnt);
+	return 0;
+  
+scsi_add_fail:
+	if (ent->device == 0x8081)
+		release_region(base_io, 0x60);
+	else
+		release_region(base_io, 0x40);
+request_io_fail:
+	free_irq(dev->irq, shpnt);
+free_tables:
+	atp870u_free_tables(shpnt);
+unregister:
+	scsi_host_put(shpnt);
+	return -1;
 }
 
 /* The abort command does not leave the device in a clean state where
@@ -2684,25 +2657,26 @@ static int atp870u_biosparam(struct scsi
 	return 0;
 }
 
-
-static int atp870u_release(struct Scsi_Host *pshost)
+static void atp870u_remove(struct pci_dev *pdev)
 {
-	struct atp_unit *dev = (struct atp_unit *)&pshost->hostdata;
-	int k;
+	struct atp_unit *atp_dev = pci_get_drvdata(pdev);
+	struct Scsi_Host *pshost = atp_dev->host;
+
+	scsi_remove_host(pshost);
 	free_irq(pshost->irq, pshost);
 	release_region(pshost->io_port, pshost->n_io_port);
-	scsi_unregister(pshost);
-	for (k = 0; k < 16; k++)
-		pci_free_consistent(dev->pdev, 1024, dev->id[k].prd_tableu, dev->id[k].prd_phys);
-	return 0;
+	atp870u_free_tables(pshost);
+	scsi_host_put(pshost);
+	pci_set_drvdata(pdev, NULL);
 }
 
 MODULE_LICENSE("GPL");
 
-static Scsi_Host_Template driver_template = {
+static Scsi_Host_Template atp870u_template = {
+	.module			= THIS_MODULE,
+	.name			= "atp870u",
+	.proc_name		= "atp870u",
 	.proc_info		= atp870u_proc_info,
-	.detect			= atp870u_detect,
-	.release		= atp870u_release,
 	.info			= atp870u_info,
 	.queuecommand		= atp870u_queuecommand,
 	.eh_abort_handler	= atp870u_abort,
@@ -2713,4 +2687,39 @@ static Scsi_Host_Template driver_templat
 	.cmd_per_lun		= ATP870U_CMDLUN,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
-#include "scsi_module.c"
+
+static struct pci_device_id atp870u_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, 0x8081)			  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7610)    },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612UW)  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612U)   },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612S)   },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612D)	  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612SUW) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_8060)	  },
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, atp870u_id_table);
+
+static struct pci_driver atp870u_driver = {	
+	.id_table	= atp870u_id_table,
+	.name		= "atp870u",
+	.probe		= atp870u_probe,
+	.remove		= __devexit_p(atp870u_remove),
+};
+
+static int __init atp870u_init(void)
+{
+	pci_register_driver(&atp870u_driver);
+	return 0;
+}
+
+static void __exit atp870u_exit(void)
+{
+	pci_unregister_driver(&atp870u_driver);
+}
+
+module_init(atp870u_init);
+module_exit(atp870u_exit);
+
diff -purN linux-2.6.1/drivers/scsi/atp870u.h linux-2.5/drivers/scsi/atp870u.h
--- linux-2.6.1/drivers/scsi/atp870u.h	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/scsi/atp870u.h	2004-01-10 19:05:06.000000000 +0000
@@ -1,4 +1,5 @@
 #ifndef _ATP870U_H
+#define _ATP870U_H
 
 /* $Id: atp870u.h,v 1.0 1997/05/07 15:09:00 root Exp root $
 
@@ -14,20 +15,57 @@
 
 /* I/O Port */
 
-#define MAX_CDB 12
-#define MAX_SENSE 14
+#define MAX_CDB		12
+#define MAX_SENSE	14
+#define qcnt		32
+#define ATP870U_SCATTER 128
+#define ATP870U_CMDLUN 	1
+
+struct atp_unit {
+	unsigned long ioport;
+	unsigned long pciport;
+	unsigned char last_cmd;
+	unsigned char in_snd;
+	unsigned char in_int;
+	unsigned char quhdu;
+	unsigned char quendu;
+	unsigned char scam_on;
+	unsigned char global_map;
+	unsigned char chip_veru;
+	unsigned char host_idu;
+	volatile int working;
+	unsigned short wide_idu;
+	unsigned short active_idu;
+	unsigned short ultra_map;
+	unsigned short async;
+	unsigned short deviceid;
+	unsigned char ata_cdbu[16];
+	unsigned char sp[16];
+	Scsi_Cmnd *querequ[qcnt];
+	struct atp_id {
+		unsigned char dirctu;
+		unsigned char devspu;
+		unsigned char devtypeu;
+		unsigned long prdaddru;
+		unsigned long tran_lenu;
+		unsigned long last_lenu;
+		unsigned char *prd_posu;
+		unsigned char *prd_tableu;
+		dma_addr_t prd_phys;
+		Scsi_Cmnd *curr_req;
+	} id[16];
+	struct Scsi_Host *host;
+	struct pci_dev *pdev;
+	unsigned int unit;
+};
 
-static int atp870u_detect(Scsi_Host_Template *);
 static int atp870u_queuecommand(Scsi_Cmnd *, void (*done) (Scsi_Cmnd *));
 static int atp870u_abort(Scsi_Cmnd *);
 static int atp870u_biosparam(struct scsi_device *, struct block_device *,
 		sector_t, int *);
-static int atp870u_release(struct Scsi_Host *);
-
-#define qcnt		32
-#define ATP870U_SCATTER 128
-#define ATP870U_CMDLUN 1
+static void send_s870(struct Scsi_Host *);
 
 extern const char *atp870u_info(struct Scsi_Host *);
+static Scsi_Host_Template atp870u_template;
 
 #endif
diff -purN linux-2.6.1/drivers/scsi/bvme6000.c linux-2.5/drivers/scsi/bvme6000.c
--- linux-2.6.1/drivers/scsi/bvme6000.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/scsi/bvme6000.c	2004-01-11 02:16:37.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Detection routine for the NCR53c710 based MVME16x SCSI Controllers for Linux.
+ * Detection routine for the NCR53c710 based BVME6000 SCSI Controllers for Linux.
  *
  * Based on work by Alan Hourihane
  */
@@ -23,9 +23,6 @@
 
 #include<linux/stat.h>
 
-extern int ncr53c7xx_init(Scsi_Host_Template *tpnt, int board, int chip,
-			  unsigned long base, int io_port, int irq, int dma,
-			  long long options, int clock);
 
 int bvme6000_scsi_detect(Scsi_Host_Template *tpnt)
 {
@@ -51,7 +48,7 @@ int bvme6000_scsi_detect(Scsi_Host_Templ
     return 1;
 }
 
-static int mvme6000_scsi_release(struct Scsi_Host *shost)
+static int bvme6000_scsi_release(struct Scsi_Host *shost)
 {
 	if (shost->irq)
 		free_irq(shost->irq, NULL);
diff -purN linux-2.6.1/drivers/scsi/g_NCR5380.c linux-2.5/drivers/scsi/g_NCR5380.c
--- linux-2.6.1/drivers/scsi/g_NCR5380.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/scsi/g_NCR5380.c	2004-01-15 15:23:42.000000000 +0000
@@ -290,6 +290,7 @@ int __init generic_NCR5380_detect(Scsi_H
 	static int current_override = 0;
 	int count, i;
 	unsigned int *ports;
+	unsigned long region_size = 16;
 	static unsigned int __initdata ncr_53c400a_ports[] = {
 		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
 	};
@@ -420,6 +421,7 @@ int __init generic_NCR5380_detect(Scsi_H
 			/* Not a 53C400A style setup - just grab */
 			if(!(request_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380")))
 				continue;
+			region_size = NCR5380_region_size;
 		}
 #else
 		if(!request_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380"))
@@ -428,7 +430,7 @@ int __init generic_NCR5380_detect(Scsi_H
 		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
 		if (instance == NULL) {
 #ifndef CONFIG_SCSI_G_NCR5380_MEM
-			release_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size);
+			release_region(overrides[current_override].NCR5380_map_name, region_size);
 #else
 			release_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size);
 #endif
@@ -436,6 +438,9 @@ int __init generic_NCR5380_detect(Scsi_H
 		}
 
 		instance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		instance->n_io_port = region_size;
+#endif
 
 		NCR5380_init(instance, flags);
 
@@ -498,7 +503,7 @@ int generic_NCR5380_release_resources(st
 	NCR5380_setup(instance);
 
 #ifndef CONFIG_SCSI_G_NCR5380_MEM
-	release_region(instance->NCR5380_instance_name, NCR5380_region_size);
+	release_region(instance->NCR5380_instance_name, instance->n_io_port);
 #else
 	release_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);
 #endif
diff -purN linux-2.6.1/drivers/scsi/ini9100u.c linux-2.5/drivers/scsi/ini9100u.c
--- linux-2.6.1/drivers/scsi/ini9100u.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/scsi/ini9100u.c	2003-12-22 23:28:28.000000000 +0000
@@ -484,7 +484,7 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 	dma_addr = dma_map_single(&pHCB->pci_dev->dev, SCpnt->sense_buffer,
 				  SENSE_SIZE, DMA_FROM_DEVICE);
 	pSCB->SCB_SensePtr = cpu_to_le32((u32)dma_addr);
-	pSCB->SCB_SenseLen = SENSE_SIZE;
+	pSCB->SCB_SenseLen = cpu_to_le32(SENSE_SIZE);
 	SCpnt->SCp.ptr = (char *)(unsigned long)dma_addr;
 
 	pSCB->SCB_CDBLen = SCpnt->cmd_len;
@@ -502,7 +502,7 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 		dma_addr = dma_map_single(&pHCB->pci_dev->dev, &pSCB->SCB_SGList[0],
 					  sizeof(struct SG_Struc) * TOTAL_SG_ENTRY,
 					  DMA_BIDIRECTIONAL);
-		pSCB->SCB_BufPtr = dma_addr;
+		pSCB->SCB_BufPtr = cpu_to_le32((u32)dma_addr);
 		SCpnt->SCp.dma_handle = dma_addr;
 
 		pSrbSG = (struct scatterlist *) SCpnt->request_buffer;
@@ -512,8 +512,8 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 		pSCB->SCB_Flags |= SCF_SG;	/* Turn on SG list flag       */
 		for (i = 0, TotalLen = 0, pSG = &pSCB->SCB_SGList[0];	/* 1.01g */
 		     i < pSCB->SCB_SGLen; i++, pSG++, pSrbSG++) {
-			pSG->SG_Ptr = (u32)sg_dma_address(pSrbSG);
-			TotalLen += pSG->SG_Len = (u32)sg_dma_len(pSrbSG);
+			pSG->SG_Ptr = cpu_to_le32((u32)sg_dma_address(pSrbSG));
+			TotalLen += pSG->SG_Len = cpu_to_le32((u32)sg_dma_len(pSrbSG));
 		}
 
 		pSCB->SCB_BufLen = (SCpnt->request_bufflen > TotalLen) ?
@@ -523,8 +523,8 @@ static void i91uBuildSCB(HCS * pHCB, SCB
 					  SCpnt->request_bufflen,
 					  SCpnt->sc_data_direction);
 		SCpnt->SCp.dma_handle = dma_addr;
-		pSCB->SCB_BufPtr = (u32)dma_addr;
-		pSCB->SCB_BufLen = (u32)SCpnt->request_bufflen;
+		pSCB->SCB_BufPtr = cpu_to_le32((u32)dma_addr);
+		pSCB->SCB_BufLen = cpu_to_le32((u32)SCpnt->request_bufflen);
 		pSCB->SCB_SGLen = 0;
 	} else {
 		pSCB->SCB_BufLen = 0;
diff -purN linux-2.6.1/drivers/scsi/inia100.c linux-2.5/drivers/scsi/inia100.c
--- linux-2.6.1/drivers/scsi/inia100.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/scsi/inia100.c	2004-01-02 04:15:03.000000000 +0000
@@ -420,7 +420,7 @@ static int __devinit inia100_probe_one(s
 	struct Scsi_Host *shost;
 	ORC_HCS *pHCB;
 	unsigned long port, bios;
-	int ok = -ENODEV;
+	int error = -ENODEV;
 	u32 sz;
 	unsigned long dBiosAdr;
 	char *pbBiosAdr;
@@ -433,17 +433,17 @@ static int __devinit inia100_probe_one(s
 		goto out_disable_device;
 	}
 
+	pci_set_master(pdev);
+
 	port = pci_resource_start(pdev, 0);
-	if (!request_region(pHCB->HCS_Base, 256, "inia100")) {
-		printk(KERN_WARNING "inia100: io port 0x%x, is busy.\n", 
-		       pHCB->HCS_Base);
-		goto out_disable_device; /* XXX: undo init_orchid() ?? */
+	if (!request_region(port, 256, "inia100")) {
+		printk(KERN_WARNING "inia100: io port 0x%lx, is busy.\n", port);
+		goto out_disable_device;
 	}
 
 	/* <02> read from base address + 0x50 offset to get the bios balue. */
 	bios = ORC_RDWORD(port, 0x50);
 
-	pci_set_master(pdev);
 
 	shost = scsi_host_alloc(&inia100_template, sizeof(ORC_HCS));
 	if (!shost)
@@ -460,7 +460,8 @@ static int __devinit inia100_probe_one(s
 
 	/* Get total memory needed for SCB */
 	sz = ORC_MAXQUEUE * sizeof(ORC_SCB);
-	pHCB->HCS_virScbArray = pci_alloc_consistent(pdev, sz, &pHCB->HCS_physScbArray);
+	pHCB->HCS_virScbArray = pci_alloc_consistent(pdev, sz,
+			&pHCB->HCS_physScbArray);
 	if (!pHCB->HCS_virScbArray) {
 		printk("inia100: SCB memory allocation error\n");
 		goto out_host_put;
@@ -469,7 +470,8 @@ static int __devinit inia100_probe_one(s
 
 	/* Get total memory needed for ESCB */
 	sz = ORC_MAXQUEUE * sizeof(ESCB);
-	pHCB->HCS_virEscbArray = pci_alloc_consistent(pdev, sz, &pHCB->HCS_physEscbArray);
+	pHCB->HCS_virEscbArray = pci_alloc_consistent(pdev, sz,
+			&pHCB->HCS_physEscbArray);
 	if (!pHCB->HCS_virEscbArray) {
 		printk("inia100: ESCB memory allocation error\n");
 		goto out_free_scb_array;
@@ -490,21 +492,23 @@ static int __devinit inia100_probe_one(s
 	shost->unique_id = shost->io_port;
 	shost->max_id = pHCB->HCS_MaxTar;
 	shost->max_lun = 16;
-	shost->irq = pHCB->HCS_Intr;
+	shost->irq = pHCB->HCS_Intr = pdev->irq;
 	shost->this_id = pHCB->HCS_SCSI_ID;	/* Assign HCS index */
 	shost->sg_tablesize = TOTAL_SG_ENTRY;
 
 	/* Initial orc chip           */
-	ok = request_irq(pHCB->HCS_Intr, inia100_intr, SA_SHIRQ, "inia100", shost);
-	if (ok < 0) {
-		printk(KERN_WARNING "inia100: unable to get irq %d\n", pHCB->HCS_Intr);
+	error = request_irq(pdev->irq, inia100_intr, SA_SHIRQ,
+			"inia100", shost);
+	if (error < 0) {
+		printk(KERN_WARNING "inia100: unable to get irq %d\n",
+				pdev->irq);
 		goto out_free_escb_array;
 	}
 
 	pci_set_drvdata(pdev, shost);
 
-	ok = scsi_add_host(shost, &pdev->dev);
-	if (!ok)
+	error = scsi_add_host(shost, &pdev->dev);
+	if (error)
 		goto out_free_irq;
 
 	scsi_scan_host(shost);
@@ -521,11 +525,11 @@ static int __devinit inia100_probe_one(s
  out_host_put:
 	scsi_host_put(shost);
  out_release_region:
-        release_region(pHCB->HCS_Base, 256);
+        release_region(port, 256);
  out_disable_device:
 	pci_disable_device(pdev);
  out:
-	return ok;
+	return error;
 }
 
 static void __devexit inia100_remove_one(struct pci_dev *pdev)
diff -purN linux-2.6.1/drivers/scsi/ips.c linux-2.5/drivers/scsi/ips.c
--- linux-2.6.1/drivers/scsi/ips.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/drivers/scsi/ips.c	2004-01-13 19:10:51.000000000 +0000
@@ -131,6 +131,8 @@
 /* 5.30.00  - use __devexit_p()                                              */
 /* 6.00.00  - Add 6x Adapters and Battery Flash                              */
 /* 6.10.00  - Remove 1G Addressing Limitations                               */
+/* 6.11.xx  - Get VersionInfo buffer off the stack !              DDTS 60401 */
+/* 6.11.xx  - Make Logical Drive Info structure safe for DMA      DDTS 60639 */
 /*****************************************************************************/
 
 /*
@@ -195,8 +197,8 @@ MODULE_PARM(ips, "s");
 /*
  * DRIVER_VER
  */
-#define IPS_VERSION_HIGH        "6.10"
-#define IPS_VERSION_LOW         ".90-BETA"
+#define IPS_VERSION_HIGH        "7.00"
+#define IPS_VERSION_LOW         ".00 "
 
 #if !defined(__i386__) && !defined(__ia64__) && !defined(__x86_64__)
 #warning "This driver has only been tested on the x86/ia64/x86_64 platforms"
@@ -497,8 +499,7 @@ int ips_proc_info(struct Scsi_Host *, ch
 static int ips_host_info(ips_ha_t *, char *, off_t, int);
 static void copy_mem_info(IPS_INFOSTR *, char *, int);
 static int copy_info(IPS_INFOSTR *, char *, ...);
-static int ips_get_version_info(ips_ha_t * ha, IPS_VERSION_DATA * Buffer,
-				int intr);
+static int ips_get_version_info(ips_ha_t * ha, dma_addr_t, int intr);
 static void ips_version_check(ips_ha_t * ha, int intr);
 static int ips_abort_init(ips_ha_t * ha, int index);
 static int ips_init_phase2(int index);
@@ -2159,27 +2160,60 @@ ips_host_info(ips_ha_t * ha, char *ptr, 
 
 	copy_info(&info, "\tIRQ number                        : %d\n", ha->irq);
 
-	if (le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG)
-		copy_info(&info,
-			  "\tBIOS Version                      : %c%c%c%c%c%c%c%c\n",
-			  ha->nvram->bios_high[0], ha->nvram->bios_high[1],
-			  ha->nvram->bios_high[2], ha->nvram->bios_high[3],
-			  ha->nvram->bios_low[0], ha->nvram->bios_low[1],
-			  ha->nvram->bios_low[2], ha->nvram->bios_low[3]);
-
-	copy_info(&info,
-		  "\tFirmware Version                  : %c%c%c%c%c%c%c%c\n",
-		  ha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],
-		  ha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],
-		  ha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],
-		  ha->enq->CodeBlkVersion[6], ha->enq->CodeBlkVersion[7]);
-
-	copy_info(&info,
-		  "\tBoot Block Version                : %c%c%c%c%c%c%c%c\n",
-		  ha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],
-		  ha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],
-		  ha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],
-		  ha->enq->BootBlkVersion[6], ha->enq->BootBlkVersion[7]);
+    /* For the Next 3 lines Check for Binary 0 at the end and don't include it if it's there. */
+    /* That keeps everything happy for "text" operations on the proc file.                    */
+
+	if (le32_to_cpu(ha->nvram->signature) == IPS_NVRAM_P5_SIG) {
+        if (ha->nvram->bios_low[3] == 0) { 
+            copy_info(&info,
+			          "\tBIOS Version                      : %c%c%c%c%c%c%c\n",
+			          ha->nvram->bios_high[0], ha->nvram->bios_high[1],
+			          ha->nvram->bios_high[2], ha->nvram->bios_high[3],
+			          ha->nvram->bios_low[0], ha->nvram->bios_low[1],
+			          ha->nvram->bios_low[2]);
+
+        } else {
+		    copy_info(&info,
+			          "\tBIOS Version                      : %c%c%c%c%c%c%c%c\n",
+			          ha->nvram->bios_high[0], ha->nvram->bios_high[1],
+			          ha->nvram->bios_high[2], ha->nvram->bios_high[3],
+			          ha->nvram->bios_low[0], ha->nvram->bios_low[1],
+			          ha->nvram->bios_low[2], ha->nvram->bios_low[3]);
+        }
+
+    }
+
+    if (ha->enq->CodeBlkVersion[7] == 0) {
+        copy_info(&info,
+		          "\tFirmware Version                  : %c%c%c%c%c%c%c\n",
+		          ha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],
+		          ha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],
+		          ha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],
+		          ha->enq->CodeBlkVersion[6]);
+    } else {
+        copy_info(&info,
+		          "\tFirmware Version                  : %c%c%c%c%c%c%c%c\n",
+		          ha->enq->CodeBlkVersion[0], ha->enq->CodeBlkVersion[1],
+		          ha->enq->CodeBlkVersion[2], ha->enq->CodeBlkVersion[3],
+		          ha->enq->CodeBlkVersion[4], ha->enq->CodeBlkVersion[5],
+		          ha->enq->CodeBlkVersion[6], ha->enq->CodeBlkVersion[7]);
+    }
+
+    if (ha->enq->BootBlkVersion[7] == 0) {
+        copy_info(&info,
+		          "\tBoot Block Version                : %c%c%c%c%c%c%c\n",
+		          ha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],
+		          ha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],
+		          ha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],
+		          ha->enq->BootBlkVersion[6]);
+    } else {
+        copy_info(&info,
+		          "\tBoot Block Version                : %c%c%c%c%c%c%c%c\n",
+		          ha->enq->BootBlkVersion[0], ha->enq->BootBlkVersion[1],
+		          ha->enq->BootBlkVersion[2], ha->enq->BootBlkVersion[3],
+		          ha->enq->BootBlkVersion[4], ha->enq->BootBlkVersion[5],
+		          ha->enq->BootBlkVersion[6], ha->enq->BootBlkVersion[7]);
+    }
 
 	copy_info(&info, "\tDriver Version                    : %s%s\n",
 		  IPS_VERSION_HIGH, IPS_VERSION_LOW);
@@ -2841,6 +2875,11 @@ ips_next(ips_ha_t * ha, int intr)
 		scb->dcdb.cmd_attribute =
 		    ips_command_direction[scb->scsi_cmd->cmnd[0]];
 
+        /* Allow a WRITE BUFFER Command to Have no Data */
+        /* This is Used by Tape Flash Utilites          */
+        if ((scb->scsi_cmd->cmnd[0] == WRITE_BUFFER) && (scb->data_len == 0)) 
+            scb->dcdb.cmd_attribute = 0;                  
+
 		if (!(scb->dcdb.cmd_attribute & 0x3))
 			scb->dcdb.transfer_length = 0;
 
@@ -3820,23 +3859,14 @@ ips_send_cmd(ips_ha_t * ha, ips_scb_t * 
 					scb->scsi_cmd->result = DID_OK << 16;
 				}
 			} else {
-				scb->cmd.logical_info.op_code =
-				    IPS_CMD_GET_LD_INFO;
-				scb->cmd.logical_info.command_id =
-				    IPS_COMMAND_ID(ha, scb);
+				scb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;
+				scb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);
 				scb->cmd.logical_info.reserved = 0;
 				scb->cmd.logical_info.reserved2 = 0;
-				scb->data_len =
-				    sizeof (ha->adapt->logical_drive_info);
-				scb->data_busaddr =
-				    pci_map_single(ha->pcidev,
-						   &ha->adapt->
-						   logical_drive_info,
-						   scb->data_len,
-						   IPS_DMA_DIR(scb));
-				scb->flags |= IPS_SCB_MAP_SINGLE;
-				scb->cmd.logical_info.buffer_addr =
-				    scb->data_busaddr;
+				scb->data_len = sizeof (IPS_LD_INFO);
+				scb->data_busaddr = ha->logical_drive_info_dma_addr;
+				scb->flags = 0;
+				scb->cmd.logical_info.buffer_addr = scb->data_busaddr;
 				ret = IPS_SUCCESS;
 			}
 
@@ -3967,18 +3997,13 @@ ips_send_cmd(ips_ha_t * ha, ips_scb_t * 
 
 		case READ_CAPACITY:
 			scb->cmd.logical_info.op_code = IPS_CMD_GET_LD_INFO;
-			scb->cmd.logical_info.command_id =
-			    IPS_COMMAND_ID(ha, scb);
+			scb->cmd.logical_info.command_id = IPS_COMMAND_ID(ha, scb);
 			scb->cmd.logical_info.reserved = 0;
 			scb->cmd.logical_info.reserved2 = 0;
 			scb->cmd.logical_info.reserved3 = 0;
-			scb->data_len = sizeof (ha->adapt->logical_drive_info);
-			scb->data_busaddr = pci_map_single(ha->pcidev,
-							   &ha->adapt->
-							   logical_drive_info,
-							   scb->data_len,
-							   IPS_DMA_DIR(scb));
-			scb->flags |= IPS_SCB_MAP_SINGLE;
+			scb->data_len = sizeof (IPS_LD_INFO);
+			scb->data_busaddr = ha->logical_drive_info_dma_addr;
+			scb->flags = 0;
 			scb->cmd.logical_info.buffer_addr = scb->data_busaddr;
 			ret = IPS_SUCCESS;
 			break;
@@ -4302,19 +4327,17 @@ ips_online(ips_ha_t * ha, ips_scb_t * sc
 		return (0);
 
 	if ((scb->basic_status & IPS_GSC_STATUS_MASK) > 1) {
-		memset(&ha->adapt->logical_drive_info, 0,
-		       sizeof (ha->adapt->logical_drive_info));
-
+		memset(ha->logical_drive_info, 0, sizeof (IPS_LD_INFO));
 		return (0);
 	}
 
-	if (ha->adapt->logical_drive_info.drive_info[scb->target_id].state !=
+	if (ha->logical_drive_info->drive_info[scb->target_id].state !=
 	    IPS_LD_OFFLINE
-	    && ha->adapt->logical_drive_info.drive_info[scb->target_id].state !=
+	    && ha->logical_drive_info->drive_info[scb->target_id].state !=
 	    IPS_LD_FREE
-	    && ha->adapt->logical_drive_info.drive_info[scb->target_id].state !=
+	    && ha->logical_drive_info->drive_info[scb->target_id].state !=
 	    IPS_LD_CRS
-	    && ha->adapt->logical_drive_info.drive_info[scb->target_id].state !=
+	    && ha->logical_drive_info->drive_info[scb->target_id].state !=
 	    IPS_LD_SYS)
 		return (1);
 	else
@@ -4377,7 +4400,7 @@ ips_rdcap(ips_ha_t * ha, ips_scb_t * scb
 
 	cap.lba =
 	    cpu_to_be32(le32_to_cpu
-			(ha->adapt->logical_drive_info.
+			(ha->logical_drive_info->
 			 drive_info[scb->target_id].sector_count) - 1);
 	cap.len = cpu_to_be32((uint32_t) IPS_BLKSIZE);
 
@@ -4541,6 +4564,14 @@ ips_free(ips_ha_t * ha)
 			ha->adapt = NULL;
 		}
 
+		if (ha->logical_drive_info) {
+			pci_free_consistent(ha->pcidev,
+					    sizeof (IPS_LD_INFO),
+					    ha->logical_drive_info,
+					    ha->logical_drive_info_dma_addr);
+			ha->logical_drive_info = NULL;
+		}
+
 		if (ha->nvram) {
 			kfree(ha->nvram);
 			ha->nvram = NULL;
@@ -4730,6 +4761,7 @@ ips_getscb(ips_ha_t * ha)
 	}
 
 	ha->scb_freelist = scb->q_next;
+	scb->flags = 0;
 	scb->q_next = NULL;
 
 	ips_init_scb(ha, scb);
@@ -6777,7 +6809,7 @@ ips_verify_bios_memio(ips_ha_t * ha, cha
 static void
 ips_version_check(ips_ha_t * ha, int intr)
 {
-	IPS_VERSION_DATA VersionInfo;
+	IPS_VERSION_DATA *VersionInfo;
 	uint8_t FirmwareVersion[IPS_COMPAT_ID_LENGTH + 1];
 	uint8_t BiosVersion[IPS_COMPAT_ID_LENGTH + 1];
 	int MatchError;
@@ -6787,6 +6819,8 @@ ips_version_check(ips_ha_t * ha, int int
 
 	METHOD_TRACE("ips_version_check", 1);
 
+	VersionInfo = ( IPS_VERSION_DATA * ) ha->ioctl_data;
+
 	memset(FirmwareVersion, 0, IPS_COMPAT_ID_LENGTH + 1);
 	memset(BiosVersion, 0, IPS_COMPAT_ID_LENGTH + 1);
 
@@ -6797,9 +6831,10 @@ ips_version_check(ips_ha_t * ha, int int
 	rc = IPS_FAILURE;
 	if (ha->subsys->param[4] & IPS_GET_VERSION_SUPPORT) {	/* If Versioning is Supported */
 		/* Get the Version Info with a Get Version Command */
-		rc = ips_get_version_info(ha, &VersionInfo, intr);
+		memset( VersionInfo, 0, sizeof (IPS_VERSION_DATA));
+		rc = ips_get_version_info(ha, ha->ioctl_busaddr, intr);
 		if (rc == IPS_SUCCESS)
-			memcpy(FirmwareVersion, VersionInfo.compatibilityId,
+			memcpy(FirmwareVersion, VersionInfo->compatibilityId,
 			       IPS_COMPAT_ID_LENGTH);
 	}
 
@@ -6862,14 +6897,13 @@ ips_version_check(ips_ha_t * ha, int int
 /*     0 if Successful, else non-zero                                        */
 /*---------------------------------------------------------------------------*/
 static int
-ips_get_version_info(ips_ha_t * ha, IPS_VERSION_DATA * Buffer, int intr)
+ips_get_version_info(ips_ha_t * ha, dma_addr_t Buffer, int intr)
 {
 	ips_scb_t *scb;
 	int rc;
 
 	METHOD_TRACE("ips_get_version_info", 1);
 
-	memset(Buffer, 0, sizeof (IPS_VERSION_DATA));
 	scb = &ha->scbs[ha->max_cmds - 1];
 
 	ips_init_scb(ha, scb);
@@ -6881,11 +6915,10 @@ ips_get_version_info(ips_ha_t * ha, IPS_
 	scb->cmd.version_info.reserved = 0;
 	scb->cmd.version_info.count = sizeof (IPS_VERSION_DATA);
 	scb->cmd.version_info.reserved2 = 0;
-	scb->data_len = sizeof (*Buffer);
-	scb->data_busaddr = pci_map_single(ha->pcidev, Buffer,
-					   scb->data_len, IPS_DMA_DIR(scb));
-	scb->cmd.version_info.buffer_addr = scb->data_busaddr;
-	scb->flags |= IPS_SCB_MAP_SINGLE;
+	scb->data_len = sizeof (IPS_VERSION_DATA);
+	scb->data_busaddr = Buffer;
+	scb->cmd.version_info.buffer_addr = Buffer;
+	scb->flags = 0;
 
 	/* issue command */
 	rc = ips_send_wait(ha, scb, ips_cmd_timeout, intr);
@@ -7356,6 +7389,17 @@ ips_init_phase1(struct pci_dev *pci_dev,
 	ha->adapt->hw_status_start = dma_address;
 	ha->dummy = (void *) (ha->adapt + 1);
 
+
+
+	ha->logical_drive_info = pci_alloc_consistent(pci_dev, sizeof (IPS_LD_INFO), &dma_address);
+	if (!ha->logical_drive_info) {
+		IPS_PRINTK(KERN_WARNING, pci_dev,
+			   "Unable to allocate logical drive info structure\n");
+		return ips_abort_init(ha, index);
+	}
+	ha->logical_drive_info_dma_addr = dma_address;
+
+
 	ha->conf = kmalloc(sizeof (IPS_CONF), GFP_KERNEL);
 
 	if (!ha->conf) {
diff -purN linux-2.6.1/drivers/scsi/ips.h linux-2.5/drivers/scsi/ips.h
--- linux-2.6.1/drivers/scsi/ips.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/scsi/ips.h	2004-01-13 19:10:51.000000000 +0000
@@ -711,7 +711,6 @@ typedef struct {
    volatile PIPS_STATUS p_status_tail;
    volatile uint32_t    hw_status_start;
    volatile uint32_t    hw_status_tail;
-   IPS_LD_INFO          logical_drive_info;
 } IPS_ADAPTER, *PIPS_ADAPTER;
 
 typedef struct {
@@ -1084,6 +1083,8 @@ typedef struct ips_ha {
    ips_scb_queue_t    scb_activelist;     /* Active SCB list            */
    IPS_IO_CMD        *dummy;              /* dummy command              */
    IPS_ADAPTER       *adapt;              /* Adapter status area        */
+   IPS_LD_INFO       *logical_drive_info; /* Adapter Logical Drive Info */
+   dma_addr_t         logical_drive_info_dma_addr; /* Logical Drive Info DMA Address */
    IPS_ENQ           *enq;                /* Adapter Enquiry data       */
    IPS_CONF          *conf;               /* Adapter config data        */
    IPS_NVRAM_P5      *nvram;              /* NVRAM page 5 data          */
@@ -1132,7 +1133,7 @@ typedef struct ips_scb {
    uint8_t           lun;
    uint8_t           cdb[12];
    uint32_t          scb_busaddr;
-   uint32_t          data_busaddr;
+   uint32_t          old_data_busaddr;  // Obsolete, but kept for old utility compatibility
    uint32_t          timeout;
    uint8_t           basic_status;
    uint8_t           extended_status;
@@ -1148,6 +1149,7 @@ typedef struct ips_scb {
    ips_scb_callback  callback;
    uint32_t          sg_busaddr;
    int               sg_count;
+   dma_addr_t        data_busaddr;
 } ips_scb_t;
 
 typedef struct ips_scb_pt {
@@ -1201,15 +1203,15 @@ typedef struct {
 *
 *************************************************************************/
 
-#define IPS_VER_MAJOR 6
-#define IPS_VER_MAJOR_STRING "6"
-#define IPS_VER_MINOR 10
-#define IPS_VER_MINOR_STRING "10"
-#define IPS_VER_BUILD 90
-#define IPS_VER_BUILD_STRING "90"
-#define IPS_VER_STRING "6.10.90"
-#define IPS_RELEASE_ID 0x00010000
-#define IPS_BUILD_IDENT 364
+#define IPS_VER_MAJOR 7
+#define IPS_VER_MAJOR_STRING "7"
+#define IPS_VER_MINOR 00
+#define IPS_VER_MINOR_STRING "00"
+#define IPS_VER_BUILD 00
+#define IPS_VER_BUILD_STRING "00"
+#define IPS_VER_STRING "7.00.00"
+#define IPS_RELEASE_ID 0x00010001
+#define IPS_BUILD_IDENT 475
 #define IPS_LEGALCOPYRIGHT_STRING "(C) Copyright IBM Corp. 1994, 2003. All Rights Reserved."
 #define IPS_ADAPTECCOPYRIGHT_STRING "(c) Copyright Adaptec, Inc. 2002 to present. All Rights Reserved."
 #define IPS_NT_LEGALCOPYRIGHT_STRING "(C) Copyright IBM Corp. 1994, 2003."
@@ -1219,11 +1221,11 @@ typedef struct {
 #define IPS_VER_SERVERAID2 "2.88.13"
 #define IPS_VER_NAVAJO "2.88.13"
 #define IPS_VER_SERVERAID3 "6.10.24"
-#define IPS_VER_SERVERAID4H "6.10.24"
-#define IPS_VER_SERVERAID4MLx "6.10.24"
-#define IPS_VER_SARASOTA "6.10.24"
-#define IPS_VER_MARCO "6.10.24"
-#define IPS_VER_SEBRING "6.10.24"
+#define IPS_VER_SERVERAID4H "6.11.07"
+#define IPS_VER_SERVERAID4MLx "6.11.07"
+#define IPS_VER_SARASOTA "6.11.07"
+#define IPS_VER_MARCO "6.11.07"
+#define IPS_VER_SEBRING "6.11.07"
 
 /* Compatability IDs for various adapters */
 #define IPS_COMPAT_UNKNOWN ""
diff -purN linux-2.6.1/drivers/scsi/mac_esp.c linux-2.5/drivers/scsi/mac_esp.c
--- linux-2.6.1/drivers/scsi/mac_esp.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/drivers/scsi/mac_esp.c	2004-01-11 02:19:04.000000000 +0000
@@ -46,7 +46,7 @@
 #define mac_turnon_irq(x)	mac_enable_irq(x)
 #define mac_turnoff_irq(x)	mac_disable_irq(x)
 
-extern inline void esp_handle(struct NCR_ESP *esp);
+extern void esp_handle(struct NCR_ESP *esp);
 extern void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs);
 
 static int  dma_bytes_sent(struct NCR_ESP * esp, int fifo_count);
@@ -151,92 +151,98 @@ irqreturn_t fake_drq(int irq, void *dev_
 #define DRIVER_SETUP
 
 /*
- * Function : mac_esp_setup(char *str, int *ints)
+ * Function : mac_esp_setup(char *str)
  *
  * Purpose : booter command line initialization of the overrides array,
  *
- * Inputs : str - unused, ints - array of integer parameters with ints[0]
- *	equal to the number of ints.
+ * Inputs : str - parameters, separated by commas.
  *
  * Currently unused in the new driver; need to add settable parameters to the 
  * detect function.
  *
  */
 
-static int __init mac_esp_setup(char *str, int *ints) {
+static int __init mac_esp_setup(char *str) {
 #ifdef DRIVER_SETUP
 	/* Format of mac53c9x parameter is:
 	 *   mac53c9x=<num_esps>,<disconnect>,<nosync>,<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
 	 * Negative values mean don't change.
 	 */
 	
-	/* Grmbl... the standard parameter parsing can't handle negative numbers
-	 * :-( So let's do it ourselves!
-	 */
+	char *this_opt;
+	long opt;
 
-	int i = ints[0]+1, fact;
+	this_opt = strsep (&str, ",");
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt >= 0 && opt <= 2)
+			setup_num_esps = opt;
+		else if (opt > 2)
+			printk( "mac_esp_setup: invalid number of hosts %ld !\n", opt );
 
-	while( str && (isdigit(*str) || *str == '-') && i <= 10) {
-		if (*str == '-')
-			fact = -1, ++str;
-		else
-			fact = 1;
-		ints[i++] = simple_strtoul( str, NULL, 0 ) * fact;
-		if ((str = strchr( str, ',' )) != NULL)
-			++str;
+		this_opt = strsep (&str, ",");
 	}
-	ints[0] = i-1;
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
 	
-	if (ints[0] < 1) {
-		printk( "mac_esp_setup: no arguments!\n" );
-		return 0;
+		if (opt > 0)
+			setup_disconnect = opt;
+
+		this_opt = strsep (&str, ",");
 	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
 
-	if (ints[0] >= 1) {
-		if (ints[1] > 0)
-			/* no limits on this, just > 0 */
-		if (ints[1] >= 0 && ints[1] <= 2)
-			setup_num_esps = ints[1];
-		else if (ints[1] > 2)
-			printk( "mac_esp_setup: invalid number of hosts %d !\n", ints[1] );
-	}
-	if (ints[0] >= 2) {
-		if (ints[2] > 0)
-			setup_disconnect = ints[2];
-	}
-	if (ints[0] >= 3) {
-		if (ints[3] >= 0) {
-			setup_nosync = ints[3];
-		}
+		if (opt >= 0)
+			setup_nosync = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt > 0)
+			setup_can_queue = opt;
+
+		this_opt = strsep (&str, ",");
 	}
-	if (ints[0] >= 4) {
-		if (ints[4] > 0)
-			/* no limits on this, just > 0 */
-			setup_can_queue = ints[4];
-	}
-	if (ints[0] >= 5) {
-		if (ints[5] > 0)
-			setup_cmd_per_lun = ints[5];
-	}
-	if (ints[0] >= 6) {
-		if (ints[6] >= 0) {
-			setup_sg_tablesize = ints[6];
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt > 0)
+			setup_cmd_per_lun = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt >= 0) {
+			setup_sg_tablesize = opt;
 			/* Must be <= SG_ALL (255) */
 			if (setup_sg_tablesize > SG_ALL)
 				setup_sg_tablesize = SG_ALL;
 		}
+
+		this_opt = strsep (&str, ",");
 	}
-	if (ints[0] >= 7) {
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
 		/* Must be between 0 and 7 */
-		if (ints[7] >= 0 && ints[7] <= 7)
-			setup_hostid = ints[7];
-		else if (ints[7] > 7)
-			printk( "mac_esp_setup: invalid host ID %d !\n", ints[7] );
+		if (opt >= 0 && opt <= 7)
+			setup_hostid = opt;
+		else if (opt > 7)
+			printk( "mac_esp_setup: invalid host ID %ld !\n", opt);
+
+		this_opt = strsep (&str, ",");
 	}
 #ifdef SUPPORT_TAGS
-	if (ints[0] >= 8) {
-		if (ints[8] >= 0)
-			setup_use_tagged_queuing = !!ints[8];
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+		if (opt >= 0)
+			setup_use_tagged_queuing = !!opt;
 	}
 #endif
 #endif
@@ -245,6 +251,7 @@ static int __init mac_esp_setup(char *st
 
 __setup("mac53c9x=", mac_esp_setup);
 
+
 /*
  * ESP address 'detection'
  */
diff -purN linux-2.6.1/drivers/scsi/mac_scsi.c linux-2.5/drivers/scsi/mac_scsi.c
--- linux-2.6.1/drivers/scsi/mac_scsi.c	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/drivers/scsi/mac_scsi.c	2004-01-11 02:14:48.000000000 +0000
@@ -74,9 +74,6 @@ extern void via_scsi_clear(void);
 static void mac_scsi_reset_boot(struct Scsi_Host *instance);
 #endif
 
-static __inline__ char macscsi_read(struct Scsi_Host *instance, int reg);
-static __inline__ void macscsi_write(struct Scsi_Host *instance, int reg, int value);
-
 static int setup_called = 0;
 static int setup_can_queue = -1;
 static int setup_cmd_per_lun = -1;
@@ -102,6 +99,52 @@ static volatile unsigned char *mac_scsi_
 static volatile unsigned char *mac_scsi_drq  = NULL;
 static volatile unsigned char *mac_scsi_nodrq = NULL;
 
+
+/*
+ * NCR 5380 register access functions
+ */
+
+#if 0
+/* Debug versions */
+#define CTRL(p,v) (*ctrl = (v))
+
+static char macscsi_read(struct Scsi_Host *instance, int reg)
+{
+  int iobase = instance->io_port;
+  int i;
+  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+
+  CTRL(iobase, 0);
+  i = in_8(iobase + (reg<<4));
+  CTRL(iobase, 0x40);
+
+  return i;
+}
+
+static void macscsi_write(struct Scsi_Host *instance, int reg, int value)
+{
+  int iobase = instance->io_port;
+  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+
+  CTRL(iobase, 0);
+  out_8(iobase + (reg<<4), value);
+  CTRL(iobase, 0x40);
+}
+#else
+
+/* Fast versions */
+static __inline__ char macscsi_read(struct Scsi_Host *instance, int reg)
+{
+  return in_8(instance->io_port + (reg<<4));
+}
+
+static __inline__ void macscsi_write(struct Scsi_Host *instance, int reg, int value)
+{
+  out_8(instance->io_port + (reg<<4), value);
+}
+#endif
+
+
 /*
  * Function : mac_scsi_setup(char *str)
  *
@@ -163,18 +206,20 @@ static int __init mac_scsi_setup(char *s
 	    if (ints[5] >= 0)
 		setup_use_pdma = ints[5];
 	}
-#endif
+#endif /* SUPPORT_TAGS */
 	
-#endif
+#endif /* DRIVER_SETUP */
 	return 1;
 }
 
 __setup("mac5380=", mac_scsi_setup);
 
 /*
- * XXX: status debug
+ * If you want to find the instance with (k)gdb ...
  */
+#if NDEBUG
 static struct Scsi_Host *default_instance;
+#endif
 
 /*
  * Function : int macscsi_detect(Scsi_Host_Template * tpnt)
@@ -223,7 +268,9 @@ int macscsi_detect(Scsi_Host_Template * 
     /* Once we support multiple 5380s (e.g. DuoDock) we'll do
        something different here */
     instance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));
+#if NDEBUG
     default_instance = instance;
+#endif
     
     if (macintosh_config->ident == MAC_MODEL_IIFX) {
 	mac_scsi_regp  = via1+0x8000;
@@ -331,49 +378,6 @@ const char * macscsi_info (struct Scsi_H
 	return "";
 }
 
-/*
- * NCR 5380 register access functions
- */
-
-/* Debug versions
-#define CTRL(p,v) (*ctrl = (v))
-
-static char macscsi_read(struct Scsi_Host *instance, int reg)
-{
-  int iobase = instance->io_port;
-  int i;
-  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
-
-  CTRL(iobase, 0);
-  i = in_8(iobase + (reg<<4));
-  CTRL(iobase, 0x40);
-
-  return i;
-}
-
-static void macscsi_write(struct Scsi_Host *instance, int reg, int value)
-{
-  int iobase = instance->io_port;
-  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
-
-  CTRL(iobase, 0);
-  out_8(value, iobase + (reg<<4));
-  CTRL(iobase, 0x40);
-}
-*/
-
-/* Fast versions */
-static __inline__ char macscsi_read(struct Scsi_Host *instance, int reg)
-{
-  return in_8(instance->io_port + (reg<<4));
-}
-
-static __inline__ void macscsi_write(struct Scsi_Host *instance, int reg, int value)
-{
-  out_8(value, instance->io_port + (reg<<4));
-}
-
-
 /* 
    Pseudo-DMA: (Ove Edlund)
    The code attempts to catch bus errors that occur if one for example
diff -purN linux-2.6.1/drivers/scsi/mvme16x.c linux-2.5/drivers/scsi/mvme16x.c
--- linux-2.6.1/drivers/scsi/mvme16x.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/scsi/mvme16x.c	2004-01-11 02:15:44.000000000 +0000
@@ -21,9 +21,6 @@
 
 #include<linux/stat.h>
 
-extern int ncr53c7xx_init(Scsi_Host_Template *tpnt, int board, int chip,
-			  unsigned long base, int io_port, int irq, int dma,
-			  long long options, int clock);
 
 int mvme16x_scsi_detect(Scsi_Host_Template *tpnt)
 {
diff -purN linux-2.6.1/drivers/scsi/nsp32.h linux-2.5/drivers/scsi/nsp32.h
--- linux-2.6.1/drivers/scsi/nsp32.h	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/scsi/nsp32.h	2004-01-06 04:12:03.000000000 +0000
@@ -667,10 +667,5 @@ static inline struct Scsi_Host *scsi_hos
 }
 #endif
 
-/* for Kernel 2.6 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
-# define __devinitdata /* */
-#endif
-
 #endif /* _NSP32_H */
 /* end */
diff -purN linux-2.6.1/drivers/scsi/nsp32_io.h linux-2.5/drivers/scsi/nsp32_io.h
--- linux-2.6.1/drivers/scsi/nsp32_io.h	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/drivers/scsi/nsp32_io.h	2004-01-06 04:12:03.000000000 +0000
@@ -173,7 +173,7 @@ static inline void nsp32_index_write4(un
 
 /*==============================================*/
 
-static inline unsigned char nsp32_mmio_index_read1(unsigned int base,
+static inline unsigned char nsp32_mmio_index_read1(unsigned long base,
 						   unsigned int reg)
 {
 	volatile unsigned short *index_ptr, *data_ptr;
@@ -185,7 +185,7 @@ static inline unsigned char nsp32_mmio_i
 	return readb(data_ptr);
 }
 
-static inline void nsp32_mmio_index_write1(unsigned int  base,
+static inline void nsp32_mmio_index_write1(unsigned long base,
 					   unsigned int  reg,
 					   unsigned char val)
 {
@@ -198,8 +198,8 @@ static inline void nsp32_mmio_index_writ
 	writeb(val, data_ptr );
 }
 
-static inline unsigned short nsp32_mmio_index_read2(unsigned int base,
-						    unsigned int reg)
+static inline unsigned short nsp32_mmio_index_read2(unsigned long base,
+						    unsigned int  reg)
 {
 	volatile unsigned short *index_ptr, *data_ptr;
 
@@ -210,7 +210,7 @@ static inline unsigned short nsp32_mmio_
 	return le16_to_cpu(readw(data_ptr));
 }
 
-static inline void nsp32_mmio_index_write2(unsigned int   base,
+static inline void nsp32_mmio_index_write2(unsigned long  base,
 					   unsigned int   reg,
 					   unsigned short val)
 {
diff -purN linux-2.6.1/drivers/scsi/qla1280.c linux-2.5/drivers/scsi/qla1280.c
--- linux-2.6.1/drivers/scsi/qla1280.c	2004-01-09 07:00:13.000000000 +0000
+++ linux-2.5/drivers/scsi/qla1280.c	2004-01-08 21:42:46.000000000 +0000
@@ -3,7 +3,8 @@
 *
 * QLogic  QLA1280 (Ultra2)  and  QLA12160 (Ultra3) SCSI driver
 * Copyright (C) 2000 Qlogic Corporation (www.qlogic.com)
-* Copyright (C) 2001-2003 Jes Sorensen, Wild Open Source Inc.
+* Copyright (C) 2001-2004 Jes Sorensen, Wild Open Source Inc.
+* Copyright (C) 2003 Christoph Hellwig
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
@@ -16,13 +17,30 @@
 * General Public License for more details.
 *
 ******************************************************************************/
-#define QLA1280_VERSION      "3.23.37.1"
+#define QLA1280_VERSION      "3.24.1"
 /*****************************************************************************
     Revision History:
-    Rev  3.23.37.1 December 17, 2003, Jes Sorensen
+    Rev  3.24.1 January 5, 2004, Jes Sorensen
+	- Initialize completion queue to avoid OOPS on probe
+	- Handle interrupts during mailbox testing
+    Rev  3.24 November 17, 2003, Christoph Hellwig
+    	- use struct list_head for completion queue
+	- avoid old Scsi_FOO typedefs
+	- cleanup 2.4 compat glue a bit
+	- use <scsi/scsi_*.h> headers on 2.6 instead of "scsi.h"
+	- make initialization for memory mapped vs port I/O more similar
+	- remove broken pci config space manipulation
+	- kill more cruft
+	- this is an almost perfect 2.6 scsi driver now! ;)
+    Rev  3.23.39 December 17, 2003, Jes Sorensen
 	- Delete completion queue from srb if mailbox command failed to
 	  to avoid qla1280_done completeting qla1280_error_action's
 	  obsolete context
+	- Reduce arguments for qla1280_done
+    Rev  3.23.38 October 18, 2003, Christoph Hellwig
+	- Convert to new-style hotplugable driver for 2.6
+	- Fix missing scsi_unregister/scsi_host_put on HBA removal
+	- Kill some more cruft
     Rev  3.23.37 October 1, 2003, Jes Sorensen
 	- Make MMIO depend on CONFIG_X86_VISWS instead of yet another
 	  random CONFIG option
@@ -323,7 +341,12 @@
 #include <asm/system.h>
 
 #if LINUX_VERSION_CODE >= 0x020545
+#include <asm/cacheflush.h>	/* for flush_cache_all() */
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
 #include "scsi.h"
 #else
 #include <linux/blk.h>
@@ -341,9 +364,6 @@
  * Compile time Options:
  *            0 - Disable and 1 - Enable
  */
-#define  QL1280_LUN_SUPPORT	0
-#define  WATCHDOGTIMER		0
-
 #define  DEBUG_QLA1280_INTR	0
 #define  DEBUG_PRINT_NVRAM	0
 #define  DEBUG_QLA1280		0
@@ -414,8 +434,18 @@ extern int snia_pcibr_rrb_alloc(struct p
 #define irqreturn_t			void
 #define IRQ_RETVAL(foo)
 #define MSG_ORDERED_TAG			1
+
+#define DMA_BIDIRECTIONAL	SCSI_DATA_UNKNOWN
+#define DMA_TO_DEVICE		SCSI_DATA_WRITE
+#define DMA_FROM_DEVICE		SCSI_DATA_READ
+#define DMA_NONE		SCSI_DATA_NONE
+
+#ifndef HAVE_SECTOR_T
+typedef unsigned int sector_t;
+#endif
+
 static inline void
-scsi_adjust_queue_depth(Scsi_Device *device, int tag, int depth)
+scsi_adjust_queue_depth(struct scsi_device *device, int tag, int depth)
 {
 	if (tag) {
 		device->tagged_queue = tag;
@@ -423,11 +453,25 @@ scsi_adjust_queue_depth(Scsi_Device *dev
 	}
 	device->queue_depth = depth;
 }
+static inline struct Scsi_Host *scsi_host_alloc(Scsi_Host_Template *t, size_t s)
+{
+	return scsi_register(t, s);
+}
+static inline void scsi_host_put(struct Scsi_Host *h)
+{
+	scsi_unregister(h);
+}
 #else
 #define HOST_LOCK			ha->host->host_lock
 #endif
 #if LINUX_VERSION_CODE < 0x020600
 #define DEV_SIMPLE_TAGS(device)		device->tagged_queue
+/*
+ * Hack around that qla1280_remove_one is called from
+ * qla1280_release in 2.4
+ */
+#undef __devexit
+#define __devexit
 #else
 #define DEV_SIMPLE_TAGS(device)		device->simple_tags
 #endif
@@ -435,30 +479,23 @@ scsi_adjust_queue_depth(Scsi_Device *dev
 #define ia64_platform_is(foo)		(!strcmp(x, platform_name))
 #endif
 
+static int qla1280_probe_one(struct pci_dev *, const struct pci_device_id *);
+static void qla1280_remove_one(struct pci_dev *);
+
 /*
  *  QLogic Driver Support Function Prototypes.
  */
-static void qla1280_done(struct scsi_qla_host *, struct srb **, struct srb **);
-static void qla1280_done_q_put(struct srb *, struct srb **, struct srb **);
-static int qla1280_slave_configure(Scsi_Device *);
+static void qla1280_done(struct scsi_qla_host *);
 #if LINUX_VERSION_CODE < 0x020545
-static void qla1280_select_queue_depth(struct Scsi_Host *, Scsi_Device *);
 static void qla1280_get_target_options(struct scsi_cmnd *, struct scsi_qla_host *);
 #endif
-
-static int qla1280_return_status(struct response * sts, Scsi_Cmnd * cp);
-static void qla1280_mem_free(struct scsi_qla_host *ha);
 static int qla1280_get_token(char *);
 static int qla1280_setup(char *s) __init;
-static inline void qla1280_enable_intrs(struct scsi_qla_host *);
-static inline void qla1280_disable_intrs(struct scsi_qla_host *);
 
 /*
  *  QLogic ISP1280 Hardware Support Function Prototypes.
  */
-static int qla1280_initialize_adapter(struct scsi_qla_host *ha);
 static int qla1280_isp_firmware(struct scsi_qla_host *);
-static int qla1280_pci_config(struct scsi_qla_host *);
 static int qla1280_chip_diag(struct scsi_qla_host *);
 static int qla1280_setup_chip(struct scsi_qla_host *);
 static int qla1280_init_rings(struct scsi_qla_host *);
@@ -477,24 +514,21 @@ static void qla1280_poll(struct scsi_qla
 static void qla1280_reset_adapter(struct scsi_qla_host *);
 static void qla1280_marker(struct scsi_qla_host *, int, int, int, u8);
 static void qla1280_isp_cmd(struct scsi_qla_host *);
-irqreturn_t qla1280_intr_handler(int, void *, struct pt_regs *);
-static void qla1280_isr(struct scsi_qla_host *, struct srb **, struct srb **);
+static void qla1280_isr(struct scsi_qla_host *, struct list_head *);
 static void qla1280_rst_aen(struct scsi_qla_host *);
 static void qla1280_status_entry(struct scsi_qla_host *, struct response *,
-				 struct srb **, struct srb **);
+				 struct list_head *);
 static void qla1280_error_entry(struct scsi_qla_host *, struct response *,
-				struct srb **, struct srb **);
+				struct list_head *);
 static uint16_t qla1280_get_nvram_word(struct scsi_qla_host *, uint32_t);
 static uint16_t qla1280_nvram_request(struct scsi_qla_host *, uint32_t);
 static uint16_t qla1280_debounce_register(volatile uint16_t *);
 static request_t *qla1280_req_pkt(struct scsi_qla_host *);
 static int qla1280_check_for_dead_scsi_bus(struct scsi_qla_host *,
 					   unsigned int);
-static int qla1280_mem_alloc(struct scsi_qla_host *ha);
-
-static void qla12160_get_target_parameters(struct scsi_qla_host *,
-					   Scsi_Device *);
-static int qla12160_set_target_parameters(struct scsi_qla_host *, int, int);
+static void qla1280_get_target_parameters(struct scsi_qla_host *,
+					   struct scsi_device *);
+static int qla1280_set_target_parameters(struct scsi_qla_host *, int, int);
 
 
 static struct qla_driver_setup driver_setup __initdata;
@@ -505,36 +539,26 @@ static struct qla_driver_setup driver_se
 static inline uint16_t
 qla1280_data_direction(struct scsi_cmnd *cmnd)
 {
-	uint16_t flags = 0;
-
 	switch(cmnd->sc_data_direction) {
-
-	case SCSI_DATA_NONE:
-		flags = 0;
-		break;
-
-	case SCSI_DATA_READ:
-		flags = BIT_5;
-		break;
-
-	case SCSI_DATA_WRITE:
-		flags = BIT_6;
-		break;
-
-	case SCSI_DATA_UNKNOWN:
+	case DMA_FROM_DEVICE:
+		return BIT_5;
+	case DMA_TO_DEVICE:
+		return BIT_6;
+	case DMA_BIDIRECTIONAL:
+		return BIT_5 | BIT_6;
+	/*
+	 * We could BUG() on default here if one of the four cases aren't
+	 * met, but then again if we receive something like that from the
+	 * SCSI layer we have more serious problems. This shuts up GCC.
+	 */
+	case DMA_NONE:
 	default:
-		flags = BIT_5 | BIT_6;
-		break;
+		return 0;
 	}
-	return flags;
 }
 		
-#if QL1280_LUN_SUPPORT
-static void qla1280_enable_lun(struct scsi_qla_host *, int, int);
-#endif
-
 #if DEBUG_QLA1280
-static void __qla1280_print_scsi_cmd(Scsi_Cmnd * cmd);
+static void __qla1280_print_scsi_cmd(struct scsi_cmnd * cmd);
 static void __qla1280_dump_buffer(char *, int);
 #endif
 
@@ -551,21 +575,11 @@ MODULE_PARM(qla1280, "s");
 __setup("qla1280=", qla1280_setup);
 #endif
 
-MODULE_LICENSE("GPL");
 
-
-/* We use the Scsi_Pointer structure that's included with each command
- * SCSI_Cmnd as a scratchpad for our SRB.
- *
- * SCp will always point to the SRB structure (defined in qla1280.h).
- * It is define as follows:
- *  - SCp.ptr  -- > pointer back to the cmd
- *  - SCp.this_residual --> used as forward pointer to next srb
- *  - SCp.buffer --> used as backward pointer to next srb
- *  - SCp.buffers_residual --> used as flags field
- *  - SCp.have_data_in --> not used
- *  - SCp.sent_command --> not used
- *  - SCp.phase --> not used
+/*
+ * We use the scsi_pointer structure that's included with each scsi_command
+ * to overlay our struct srb over it. qla1280_init() checks that a srb is not
+ * bigger than a scsi_pointer.
  */
 
 #define	CMD_SP(Cmnd)		&Cmnd->SCp
@@ -576,28 +590,23 @@ MODULE_LICENSE("GPL");
 #define	CMD_RESULT(Cmnd)	Cmnd->result
 #define	CMD_HANDLE(Cmnd)	Cmnd->host_scribble
 #if LINUX_VERSION_CODE < 0x020545
-#define	CMD_HOST(Cmnd)		Cmnd->host
 #define CMD_REQUEST(Cmnd)	Cmnd->request.cmd
-#define SCSI_BUS_32(Cmnd)	Cmnd->channel
-#define SCSI_TCN_32(Cmnd)	Cmnd->target
-#define SCSI_LUN_32(Cmnd)	Cmnd->lun
 #else
-#define	CMD_HOST(Cmnd)		Cmnd->device->host
 #define CMD_REQUEST(Cmnd)	Cmnd->request->cmd
+#endif
+
+#define CMD_HOST(Cmnd)		Cmnd->device->host
 #define SCSI_BUS_32(Cmnd)	Cmnd->device->channel
 #define SCSI_TCN_32(Cmnd)	Cmnd->device->id
 #define SCSI_LUN_32(Cmnd)	Cmnd->device->lun
-#endif
+
 
 /*****************************************/
 /*   ISP Boards supported by this driver */
 /*****************************************/
 
-#define NUM_OF_ISP_DEVICES	6
-
 struct qla_boards {
 	unsigned char name[9];	/* Board ID String */
-	unsigned long device_id;	/* Device PCI ID   */
 	int numPorts;		/* Number of SCSI ports */
 	unsigned short *fwcode;	/* pointer to FW array         */
 	unsigned short *fwlen;	/* number of words in array    */
@@ -605,28 +614,38 @@ struct qla_boards {
 	unsigned char *fwver;	/* Ptr to F/W version array    */
 };
 
-struct qla_boards ql1280_board_tbl[NUM_OF_ISP_DEVICES] = {
-	/* Name ,  Board PCI Device ID,         Number of ports */
-	{"QLA12160", PCI_DEVICE_ID_QLOGIC_ISP12160, 2,
-	 &fw12160i_code01[0], &fw12160i_length01,
+/* NOTE: qla1280_pci_tbl and ql1280_board_tbl must be in the same order */
+static struct pci_device_id qla1280_pci_tbl[] = {
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP12160,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1080,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1240,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1280,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP10160,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);
+
+static struct qla_boards ql1280_board_tbl[] = {
+	/* Name ,  Number of ports, FW details */
+	{"QLA12160", 2, &fw12160i_code01[0], &fw12160i_length01,
 	 &fw12160i_addr01, &fw12160i_version_str[0]},
-	{"QLA1080", PCI_DEVICE_ID_QLOGIC_ISP1080, 1,
-	 &fw1280ei_code01[0], &fw1280ei_length01,
+	{"QLA1080", 1, &fw1280ei_code01[0], &fw1280ei_length01,
 	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA1240", PCI_DEVICE_ID_QLOGIC_ISP1240, 2,
-	 &fw1280ei_code01[0], &fw1280ei_length01,
+	{"QLA1240", 2, &fw1280ei_code01[0], &fw1280ei_length01,
 	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA1280", PCI_DEVICE_ID_QLOGIC_ISP1280, 2,
-	 &fw1280ei_code01[0], &fw1280ei_length01,
+	{"QLA1280", 2, &fw1280ei_code01[0], &fw1280ei_length01,
 	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA10160", PCI_DEVICE_ID_QLOGIC_ISP10160, 1,
-	 &fw12160i_code01[0], &fw12160i_length01,
+	{"QLA10160", 1, &fw12160i_code01[0], &fw12160i_length01,
 	 &fw12160i_addr01, &fw12160i_version_str[0]},
-	{"        ", 0, 0}
+	{"        ", 0}
 };
 
 static int qla1280_verbose = 1;
-static struct scsi_qla_host *qla1280_hostlist;
 static int qla1280_buffer_size;
 static char *qla1280_buffer;
 
@@ -663,43 +682,13 @@ static int ql_debug_level = 1;
  *************************************************************************/
 #define	PROC_BUF	&qla1280_buffer[len]
 
-#if LINUX_VERSION_CODE < 0x020600
-static int qla1280_proc_info(char *buffer, char **start, off_t offset,
-			     int length, int hostno, int inout)
-#else
 static int qla1280_proc_info(struct Scsi_Host *host, char *buffer,
 			     char **start, off_t offset, int length, int inout)
-#endif
 {
-	struct scsi_qla_host *ha;
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+	struct qla_boards *bdp = &ql1280_board_tbl[ha->devnum];
 	int size = 0;
 	int len = 0;
-	struct qla_boards *bdp;
-#ifdef BOGUS_QUEUE
-	struct scsi_lu *up;
-	uint32_t b, t, l;
-#endif
-#if LINUX_VERSION_CODE >= 0x020600
-	ha = (struct scsi_qla_host *)host->hostdata;
-#else
-	struct Scsi_Host *host;
-	/* Find the host that was specified */
-	for (ha = qla1280_hostlist; (ha != NULL)
-		     && ha->host->host_no != hostno; ha = ha->next) ;
-
-	/* if host wasn't found then exit */
-	if (!ha) {
-		size =  sprintf(buffer, "Can't find adapter for host "
-				"number %d\n", hostno);
-		if (size > length) {
-			return size;
-		} else {
-			return 0;
-		}
-	}
-
-	host = ha->host;
-#endif
 
 	if (inout)
 		return -ENOSYS;
@@ -728,7 +717,6 @@ static int qla1280_proc_info(struct Scsi
 	memset(qla1280_buffer, 0, PAGE_SIZE);
 
 	/* start building the print buffer */
-	bdp = &ql1280_board_tbl[ha->devnum];
 	size = sprintf(PROC_BUF,
 		       "QLogic PCI to SCSI Adapter for ISP 1280/12160:\n"
 		       "        Firmware version: %2d.%02d.%02d, Driver version %s\n",
@@ -753,51 +741,6 @@ static int qla1280_proc_info(struct Scsi
 	size = sprintf(PROC_BUF, "\n");	/* 1       */
 	len += size;
 
-	size = sprintf(PROC_BUF, "SCSI device Information:\n");
-	len += size;
-#ifdef BOGUS_QUEUE
-	/* scan for all equipment stats */
-	for (b = 0; b < MAX_BUSES; b++)
-		for (t = 0; t < MAX_TARGETS; t++) {
-			for (l = 0; l < MAX_LUNS; l++) {
-				up = LU_Q(ha, b, t, l);
-				if (up == NULL)
-					continue;
-				/* unused device/lun */
-				if (up->io_cnt == 0 || up->io_cnt < 2)
-					continue;
-				/* total reads since boot */
-				/* total writes since boot */
-				/* total requests since boot  */
-				size = sprintf (PROC_BUF,
-						"(%2d:%2d:%2d): Total reqs %ld,",
-						b, t, l, up->io_cnt);
-				len += size;
-				/* current number of pending requests */
-				size =	sprintf(PROC_BUF, " Pend reqs %d,",
-						up->q_outcnt);
-				len += size;
-#if 0
-				/* avg response time */
-				size = sprintf(PROC_BUF, " Avg resp time %ld%%,",
-					       (up->resp_time / up->io_cnt) *
-					       100);
-				len += size;
-
-				/* avg active time */
-				size = sprintf(PROC_BUF,
-					       " Avg active time %ld%%\n",
-					       (up->act_time / up->io_cnt) * 100);
-#else
-				size = sprintf(PROC_BUF, "\n");
-#endif
-				len += size;
-			}
-			if (len >= qla1280_buffer_size)
-				break;
-		}
-#endif
-
 	if (len >= qla1280_buffer_size) {
 		printk(KERN_WARNING
 		       "qla1280: Overflow buffer in qla1280_proc.c\n");
@@ -875,312 +818,6 @@ static int qla1280_read_nvram(struct scs
 	return chksum;
 }
 
-
-/**************************************************************************
- * qla1280_do_device_init
- *    This routine will register the device with the SCSI subsystem,
- *    initialize the host adapter structure and call the device init
- *    routines.
- *
- * Input:
- *     pdev      - pointer to struct pci_dev for adapter
- *     template  - pointer to SCSI template
- *     devnum    - the device number
- *     bdp       - pointer to struct _qlaboards
- *     num_hosts - the host number
- *
- * Returns:
- *  host - pointer to SCSI host structure
- **************************************************************************/
-struct Scsi_Host *
-qla1280_do_device_init(struct pci_dev *pdev, Scsi_Host_Template * template,
-		       int devnum, struct qla_boards *bdp, int num_hosts)
-{
-	struct Scsi_Host *host;
-	struct scsi_qla_host *ha;
-
-	printk(KERN_INFO "qla1280: %s found on PCI bus %i, dev %i\n",
-	       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));
-
-	host = scsi_register(template, sizeof(struct scsi_qla_host));
-	if (!host) {
-		printk(KERN_WARNING
-		       "qla1280: Failed to register host, aborting.\n");
-		goto error;
-	}
-
-#if LINUX_VERSION_CODE < 0x020545
-	scsi_set_pci_device(host, pdev);
-#else
-	scsi_set_device(host, &pdev->dev);
-#endif
-	ha = (struct scsi_qla_host *)host->hostdata;
-	/* Clear our data area */
-	memset(ha, 0, sizeof(struct scsi_qla_host));
-	/* Sanitize the information from PCI BIOS.  */
-	host->irq = pdev->irq;
-	ha->pci_bus = pdev->bus->number;
-	ha->pci_device_fn = pdev->devfn;
-	ha->pdev = pdev;
-	ha->device_id = bdp->device_id;
-	ha->devnum = devnum;	/* specifies microcode load address */
-
-	if (qla1280_mem_alloc(ha)) {
-		printk(KERN_INFO "qla1x160: Failed to get memory\n");
-		goto error_scsi_unregister;
-	}
-
-	ha->ports = bdp->numPorts;
-	/* following needed for all cases of OS versions */
-	ha->host = host;
-	ha->host_no = host->host_no;
-
-	host->can_queue = 0xfffff;	/* unlimited  */
-	host->cmd_per_lun = 1;
-	host->base = (unsigned long)ha->mmpbase;
-	host->max_channel = bdp->numPorts - 1;
-	host->max_lun = MAX_LUNS - 1;
-	host->max_id = MAX_TARGETS;
-	host->max_sectors = 1024;
-#if LINUX_VERSION_CODE < 0x020545
-	host->select_queue_depths = qla1280_select_queue_depth;
-#endif
-
-	ha->instance = num_hosts;
-	host->unique_id = ha->instance;
-
-	if (qla1280_pci_config(ha)) {
-		printk(KERN_INFO "qla1x160: Unable to configure PCI\n");
-		goto error_mem_alloced;
-	}
-
-	/* Disable ISP interrupts. */
-	qla1280_disable_intrs(ha);
-
-	/* Register the IRQ with Linux (sharable) */
-	if (request_irq(host->irq, qla1280_intr_handler, SA_SHIRQ,
-			"qla1280", ha)) {
-		printk("qla1280 : Failed to reserve interrupt %d already "
-		       "in use\n", host->irq);
-		goto error_iounmap;
-	}
-#if !MEMORY_MAPPED_IO
-	/* Register the I/O space with Linux */
-	if (!request_region(host->io_port, 0xff, "qla1280")) {
-		printk("qla1280: Failed to reserve i/o region 0x%04lx-0x%04lx"
-		       " already in use\n",
-		       host->io_port, host->io_port + 0xff);
-		goto error_free_irq;
-	}
-#endif
-
-	/* load the F/W, read paramaters, and init the H/W */
-	if (qla1280_initialize_adapter(ha)) {
-		printk(KERN_INFO "qla1x160: Failed to initialize adapter\n");
-		goto error_release_region;
-	}
-
-	/* set our host ID  (need to do something about our two IDs) */
-	host->this_id = ha->bus_settings[0].id;
-
-	return host;
-
- error_release_region:
-#if !MEMORY_MAPPED_IO
-	release_region(host->io_port, 0xff);
- error_free_irq:
-#endif
-	free_irq(host->irq, ha);
- error_iounmap:
-#if MEMORY_MAPPED_IO
-	if (ha->mmpbase)
-		iounmap((void *)(((unsigned long) ha->mmpbase) & PAGE_MASK));
-#endif
- error_mem_alloced:
-	qla1280_mem_free(ha);
- error_scsi_unregister:
-	scsi_unregister(host);
- error:
-	return NULL;
-}
-
-/**************************************************************************
- * qla1280_detect
- *    This routine will probe for Qlogic 1280 SCSI host adapters.
- *    It returns the number of host adapters of a particular
- *    type that were found.	 It also initialize all data necessary for
- *    the driver.  It is passed-in the host number, so that it
- *    knows where its first entry is in the scsi_hosts[] array.
- *
- * Input:
- *     template - pointer to SCSI template
- *
- * Returns:
- *  num - number of host adapters found.
- **************************************************************************/
-static int
-qla1280_detect(Scsi_Host_Template * template)
-{
-	struct pci_dev *pdev = NULL;
-	struct Scsi_Host *host;
-	struct scsi_qla_host *ha, *cur_ha;
-	struct qla_boards *bdp;
-	uint16_t subsys_vendor, subsys_device;
-	int num_hosts = 0;
-	int devnum = 0;
-
-	ENTER("qla1280_detect");
-
-	if (sizeof(struct srb) > sizeof(Scsi_Pointer)) {
-		printk(KERN_WARNING
-		       "qla1280_detect: [WARNING] struct srb too big\n");
-		return 0;
-	}
-#ifdef MODULE
-	/*
-	 * If we are called as a module, the qla1280 pointer may not be null
-	 * and it would point to our bootup string, just like on the lilo
-	 * command line.  IF not NULL, then process this config string with
-	 * qla1280_setup
-	 *
-	 * Boot time Options
-	 * To add options at boot time add a line to your lilo.conf file like:
-	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
-	 * which will result in the first four devices on the first two
-	 * controllers being set to a tagged queue depth of 32.
-	 */
-	if (qla1280)
-		qla1280_setup(qla1280);
-#endif
-
-	bdp = &ql1280_board_tbl[0];
-	qla1280_hostlist = NULL;
-	template->proc_name = "qla1280";
-
-	/* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
-	while ((pdev = pci_find_subsys(PCI_VENDOR_ID_QLOGIC, bdp->device_id,
-				       PCI_ANY_ID, PCI_ANY_ID, pdev))) {
-
-		/* find QLA12160 device on PCI bus=1 slot=2 */
-		if ((pdev->bus->number != 1) || (PCI_SLOT(pdev->devfn) != 2))
-			continue;
-
-		/* Bypass all AMI SUBSYS VENDOR IDs */
-		if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {
-			printk(KERN_INFO
-			       "qla1x160: Skip AMI SubSys Vendor ID Chip\n");
-			continue;
-		}
-
-		if (pci_enable_device(pdev))
-			goto find_devices;
-
-		host = qla1280_do_device_init(pdev, template, devnum,
-					      bdp, num_hosts);
-		if (!host)
-			continue;
-		ha = (struct scsi_qla_host *)host->hostdata;
-
-		/* this preferred device will always be the first one found */
-		cur_ha = qla1280_hostlist = ha;
-		num_hosts++;
-	}
-
- find_devices:
-
-	pdev = NULL;
-	/* Try and find each different type of adapter we support */
-	for (devnum = 0; bdp->device_id != 0 && devnum < NUM_OF_ISP_DEVICES;
-	     devnum++, bdp++) {
-		/* PCI_SUBSYSTEM_IDS supported */
-		while ((pdev = pci_find_subsys(PCI_VENDOR_ID_QLOGIC,
-					       bdp->device_id, PCI_ANY_ID,
-					       PCI_ANY_ID, pdev))) {
-			if (pci_enable_device(pdev))
-				continue;
-			/* found an adapter */
-			subsys_vendor = pdev->subsystem_vendor;
-			subsys_device = pdev->subsystem_device;
-
-			/*
-			 * skip QLA12160 already initialized on
-			 * PCI Bus 1 Dev 2 since we already initialized
-			 * and presented it
-			 */
-			if ((bdp->device_id == PCI_DEVICE_ID_QLOGIC_ISP12160)&&
-			    (pdev->bus->number == 1) &&
-			    (PCI_SLOT(pdev->devfn) == 2))
-				continue;
-
-			/* Bypass all AMI SUBSYS VENDOR IDs */
-			if (subsys_vendor == PCI_VENDOR_ID_AMI) {
-				printk(KERN_INFO
-				       "qla1x160: Skip AMI SubSys Vendor ID Chip\n");
-				continue;
-			}
-			dprintk(1, "qla1x160: Supported Device Found VID=%x "
-			       "DID=%x SSVID=%x SSDID=%x\n", pdev->vendor,
-			       pdev->device, subsys_vendor, subsys_device);
-
-			host = qla1280_do_device_init(pdev, template,
-						      devnum, bdp, num_hosts);
-			if (!host)
-				continue;
-			ha = (struct scsi_qla_host *)host->hostdata;
-
-			if (qla1280_hostlist == NULL) {
-				cur_ha = qla1280_hostlist = ha;
-			} else {
-				cur_ha = qla1280_hostlist;
-				while (cur_ha->next != NULL)
-					cur_ha = cur_ha->next;
-				cur_ha->next = ha;
-			}
-			num_hosts++;
-		}		/* end of WHILE */
-	}			/* end of FOR */
-
-	LEAVE("qla1280_detect");
-	return num_hosts;
-}
-
-/**************************************************************************
- *   qla1280_release
- *   Free the passed in Scsi_Host memory structures prior to unloading the
- *   module.
- **************************************************************************/
-static int
-qla1280_release(struct Scsi_Host *host)
-{
-	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
-
-	ENTER("qla1280_release");
-
-	if (!ha->flags.online)
-		return 0;
-
-	/* turn-off interrupts on the card */
-	WRT_REG_WORD(&ha->iobase->ictrl, 0);
-
-	/* Detach interrupts */
-	if (host->irq)
-		free_irq(host->irq, ha);
-
-#if MEMORY_MAPPED_IO
-	if (ha->mmpbase)
-		iounmap(ha->mmpbase);
-#else
-	/* release io space registers  */
-	if (host->io_port)
-		release_region(host->io_port, 0xff);
-#endif				/* MEMORY_MAPPED_IO */
-
-	qla1280_mem_free(ha);
-
-	ENTER("qla1280_release");
-	return 0;
-}
-
 /**************************************************************************
  *   qla1280_info
  *     Return a string describing the driver.
@@ -1197,11 +834,11 @@ qla1280_info(struct Scsi_Host *host)
 	ha = (struct scsi_qla_host *)host->hostdata;
 	bdp = &ql1280_board_tbl[ha->devnum];
 	memset(bp, 0, sizeof(qla1280_scsi_name_buffer));
+
 	sprintf (bp,
-		 "QLogic %s PCI to SCSI Host Adapter: bus %d device %d irq %d\n"
+		 "QLogic %s PCI to SCSI Host Adapter\n"
 		 "       Firmware version: %2d.%02d.%02d, Driver version %s",
-		 &bdp->name[0], ha->pci_bus, (ha->pci_device_fn & 0xf8) >> 3,
-		 host->irq, bdp->fwver[0], bdp->fwver[1], bdp->fwver[2],
+		 &bdp->name[0], bdp->fwver[0], bdp->fwver[1], bdp->fwver[2],
 		 QLA1280_VERSION);
 	return bp;
 }
@@ -1218,40 +855,21 @@ qla1280_info(struct Scsi_Host *host)
  * context which is a big NO! NO!.
  **************************************************************************/
 static int
-qla1280_queuecommand(Scsi_Cmnd * cmd, void (*fn) (Scsi_Cmnd *))
+qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 {
-	struct scsi_qla_host *ha;
-	struct srb *sp;
-	struct Scsi_Host *host;
-	int bus, target, lun;
-	int status;
-
-	/*ENTER("qla1280_queuecommand");
-	 */
-	dprintk(2, "qla1280_queuecommand(): jiffies %li\n", jiffies);
-
-	host = CMD_HOST(cmd);
-	ha = (struct scsi_qla_host *)host->hostdata;
+	struct Scsi_Host *host = cmd->device->host;
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+	struct srb *sp = (struct srb *)&cmd->SCp;
 
-	/* send command to adapter */
-	sp = (struct srb *)CMD_SP(cmd);
-	sp->cmd = cmd;
 	cmd->scsi_done = fn;
+	sp->cmd = cmd;
 	sp->flags = 0;
 
 	qla1280_print_scsi_cmd(5, cmd);
 
-	/* Generate LU queue on bus, target, LUN */
-	bus = SCSI_BUS_32(cmd);
-	target = SCSI_TCN_32(cmd);
-	lun = SCSI_LUN_32(cmd);
 	if (ha->flags.enable_64bit_addressing)
-		status = qla1280_64bit_start_scsi(ha, sp);
-	else
-		status = qla1280_32bit_start_scsi(ha, sp);
-
-	/*LEAVE("qla1280_queuecommand"); */
-	return status;
+		return qla1280_64bit_start_scsi(ha, sp);
+	return qla1280_32bit_start_scsi(ha, sp);
 }
 
 enum action {
@@ -1305,7 +923,7 @@ static void qla1280_mailbox_timeout(unsi
  *      the SCSI bus reset line.
  **************************************************************************/
 static int
-qla1280_error_action(Scsi_Cmnd * cmd, enum action action)
+qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 {
 	struct scsi_qla_host *ha;
 	int bus, target, lun;
@@ -1350,7 +968,7 @@ qla1280_error_action(Scsi_Cmnd * cmd, en
 	 * grabs the lock. /Jes
 	 */
 	if (data & RISC_INT)
-		qla1280_isr(ha, &ha->done_q_first, &ha->done_q_last);
+		qla1280_isr(ha, &ha->done_q);
 
 	/*
 	 * Determine the suggested action that the mid-level driver wants
@@ -1461,8 +1079,8 @@ qla1280_error_action(Scsi_Cmnd * cmd, en
 		ha->flags.reset_active = 0;
 	}
 
-	if (ha->done_q_first)
-		qla1280_done(ha, &ha->done_q_first, &ha->done_q_last);
+	if (!list_empty(&ha->done_q))
+		qla1280_done(ha);
 	ha->flags.in_reset = 0;
 
 	/* If we didn't manage to issue the action, or we have no
@@ -1547,22 +1165,11 @@ qla1280_eh_adapter_reset(struct scsi_cmn
 	return qla1280_error_action(cmd, ADAPTER_RESET);
 }
 
-/**************************************************************************
- * qla1280_biosparam
- *   Return the disk geometry for the given SCSI device.
- **************************************************************************/
 static int
-#if LINUX_VERSION_CODE < 0x020545
-qla1280_biosparam(Disk * disk, kdev_t dev, int geom[])
-#else
 qla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 		  sector_t capacity, int geom[])
-#endif
 {
 	int heads, sectors, cylinders;
-#if LINUX_VERSION_CODE < 0x020545
-	unsigned long capacity = disk->capacity;
-#endif
 
 	heads = 64;
 	sectors = 32;
@@ -1582,11 +1189,118 @@ qla1280_biosparam(struct scsi_device *sd
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < 0x020600
+static int
+qla1280_detect(Scsi_Host_Template *template)
+{
+	struct pci_device_id *id = &qla1280_pci_tbl[0];
+	struct pci_dev *pdev = NULL;
+	int num_hosts = 0;
+
+	if (sizeof(struct srb) > sizeof(Scsi_Pointer)) {
+		printk(KERN_WARNING
+		       "qla1280: struct srb too big, aborting\n");
+		return 0;
+	}
+
+	if ((DMA_BIDIRECTIONAL != PCI_DMA_BIDIRECTIONAL) ||
+	    (DMA_TO_DEVICE != PCI_DMA_TODEVICE) ||
+	    (DMA_FROM_DEVICE != PCI_DMA_FROMDEVICE) ||
+	    (DMA_NONE != PCI_DMA_NONE)) {
+		printk(KERN_WARNING
+		       "qla1280: dma direction bits don't match\n");
+		return 0;
+	}
+
+#ifdef MODULE
+	/*
+	 * If we are called as a module, the qla1280 pointer may not be null
+	 * and it would point to our bootup string, just like on the lilo
+	 * command line.  IF not NULL, then process this config string with
+	 * qla1280_setup
+	 *
+	 * Boot time Options
+	 * To add options at boot time add a line to your lilo.conf file like:
+	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
+	 * which will result in the first four devices on the first two
+	 * controllers being set to a tagged queue depth of 32.
+	 */
+	if (qla1280)
+		qla1280_setup(qla1280);
+#endif
+
+	/* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
+	while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
+		if (pdev->bus->number == 1 && PCI_SLOT(pdev->devfn) == 2) {
+			if (!qla1280_probe_one(pdev, id))
+				num_hosts++;
+		}
+	}
+
+	pdev = NULL;
+	/* Try and find each different type of adapter we support */
+	for (id = &qla1280_pci_tbl[0]; id->device; id++) {
+		while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
+			/*
+			 * skip QLA12160 already initialized on
+			 * PCI Bus 1 Dev 2 since we already initialized
+			 * and presented it
+			 */
+			if (id->device == PCI_DEVICE_ID_QLOGIC_ISP12160 &&
+			    pdev->bus->number == 1 &&
+			    PCI_SLOT(pdev->devfn) == 2)
+				continue;
+
+			if (!qla1280_probe_one(pdev, id))
+				num_hosts++;
+		}
+	}
+
+	return num_hosts;
+}
+
+/*
+ * This looks a bit ugly as we could just pass down host to
+ * qla1280_remove_one, but I want to keep qla1280_release purely a wrapper
+ * around pci_driver::remove as used from 2.6 onwards.
+ */
+static int
+qla1280_release(struct Scsi_Host *host)
+{
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+
+	qla1280_remove_one(ha->pdev);
+	return 0;
+}
+
+static int
+qla1280_biosparam_old(Disk * disk, kdev_t dev, int geom[])
+{
+	return qla1280_biosparam(disk->device, NULL, disk->capacity, geom);
+}
+
+static int
+qla1280_proc_info_old(char *buffer, char **start, off_t offset, int length,
+		      int hostno, int inout)
+{
+	struct Scsi_Host *host;
+
+	for (host = scsi_hostlist; host; host = host->next) {
+		if (host->host_no == hostno) {
+			return qla1280_proc_info(host, buffer, start,
+						 offset, length, inout);
+		}
+	}
+
+	return -ESRCH;
+}
+#endif
+
 /**************************************************************************
  * qla1280_intr_handler
  *   Handles the H/W interrupt
  **************************************************************************/
-irqreturn_t
+static irqreturn_t
 qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct scsi_qla_host *ha;
@@ -1606,12 +1320,12 @@ qla1280_intr_handler(int irq, void *dev_
 
 	data = qla1280_debounce_register(&reg->istatus);
 	/* Check for pending interrupts. */
-	if (data & RISC_INT) {
-		qla1280_isr(ha, &ha->done_q_first, &ha->done_q_last);
+	if (data & RISC_INT) {	
+		qla1280_isr(ha, &ha->done_q);
 		handled = 1;
 	}
-	if (ha->done_q_first)
-		qla1280_done(ha, &ha->done_q_first, &ha->done_q_last);
+	if (!list_empty(&ha->done_q))
+		qla1280_done(ha);
 
 	spin_unlock(HOST_LOCK);
 
@@ -1624,7 +1338,7 @@ qla1280_intr_handler(int irq, void *dev_
 
 
 static int
-qla12160_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)
+qla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)
 {
 	uint8_t mr;
 	uint16_t mb[MAILBOX_REGISTER_COUNT];
@@ -1633,8 +1347,8 @@ qla12160_set_target_parameters(struct sc
 
 	nv = &ha->nvram;
 
-	if (ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
-	    ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP10160)
+	if (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
+	    ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160)
 		is1x160 = 1;
 	else
 		is1x160 = 0;
@@ -1683,7 +1397,7 @@ qla12160_set_target_parameters(struct sc
  *   default queue depth (dependent on the number of hardware SCBs).
  **************************************************************************/
 static int
-qla1280_slave_configure(Scsi_Device *device)
+qla1280_slave_configure(struct scsi_device *device)
 {
 	struct scsi_qla_host *ha;
 	int default_depth = 3;
@@ -1721,8 +1435,8 @@ qla1280_slave_configure(Scsi_Device *dev
 	    (driver_setup.wide_mask &&
 	     (~driver_setup.wide_mask & (1 << target))))
 		nv->bus[bus].target[target].parameter.f.enable_wide = 0;
-	if (ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
-	    ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP10160) {
+	if (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
+	    ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160) {
 		if (driver_setup.no_ppr ||
 		    (driver_setup.ppr_mask &&
 		     (~driver_setup.ppr_mask & (1 << target))))
@@ -1730,11 +1444,9 @@ qla1280_slave_configure(Scsi_Device *dev
 	}
 
 	spin_lock_irqsave(HOST_LOCK, flags);
-	if (nv->bus[bus].target[target].parameter.f.enable_sync) {
-		status = qla12160_set_target_parameters(ha, bus, target);
-	}
-
-	qla12160_get_target_parameters(ha, device);
+	if (nv->bus[bus].target[target].parameter.f.enable_sync)
+		status = qla1280_set_target_parameters(ha, bus, target);
+	qla1280_get_target_parameters(ha, device);
 	spin_unlock_irqrestore(HOST_LOCK, flags);
 	return status;
 }
@@ -1748,55 +1460,47 @@ qla1280_slave_configure(Scsi_Device *dev
  *   support tagged queueing.
  **************************************************************************/
 static void
-qla1280_select_queue_depth(struct Scsi_Host *host, Scsi_Device *scsi_devs)
+qla1280_select_queue_depth(struct Scsi_Host *host, struct scsi_device *sdev_q)
 {
-	Scsi_Device *device;
 	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+	struct scsi_device *sdev;
 
 	ENTER("qla1280_select_queue_depth");
-	for (device = scsi_devs; device != NULL; device = device->next) {
-		if (device->host == host)
-			qla1280_slave_configure(device);
-	}
-
-	if (scsi_devs)
-		qla1280_check_for_dead_scsi_bus(ha, scsi_devs->channel);
+	for (sdev = sdev_q; sdev; sdev = sdev->next)
+		if (sdev->host == host)
+			qla1280_slave_configure(sdev);
 
+	if (sdev_q)
+		qla1280_check_for_dead_scsi_bus(ha, sdev_q->channel);
 	LEAVE("qla1280_select_queue_depth");
 }
 #endif
 
 /*
- * Driver Support Routines
- */
-
-/*
  * qla1280_done
  *      Process completed commands.
  *
  * Input:
  *      ha           = adapter block pointer.
- *      done_q_first = done queue first pointer.
- *      done_q_last  = done queue last pointer.
+ *      done_q       = done queue.
  */
 static void
-qla1280_done(struct scsi_qla_host *ha, struct srb ** done_q_first,
-	     struct srb ** done_q_last)
+qla1280_done(struct scsi_qla_host *ha)
 {
 	struct srb *sp;
+	struct list_head *done_q;
 	int bus, target, lun;
-	Scsi_Cmnd *cmd;
+	struct scsi_cmnd *cmd;
 
 	ENTER("qla1280_done");
 
-	while (*done_q_first != NULL) {
-		/* remove command from done list */
-		sp = *done_q_first;
-		if (!(*done_q_first = sp->s_next))
-			*done_q_last = NULL;
-		else
-			(*done_q_first)->s_prev = NULL;
+	done_q = &ha->done_q;
+
+	while (!list_empty(done_q)) {
+		sp = list_entry(done_q->next, struct srb, list);
 
+		list_del(&sp->list);
+	
 		cmd = sp->cmd;
 		bus = SCSI_BUS_32(cmd);
 		target = SCSI_TCN_32(cmd);
@@ -1822,15 +1526,13 @@ qla1280_done(struct scsi_qla_host *ha, s
 			dprintk(3, "S/G unmap_sg cmd=%p\n", cmd);
 
 			pci_unmap_sg(ha->pdev, cmd->request_buffer,
-				     cmd->use_sg,
-				     scsi_to_pci_dma_dir(cmd->sc_data_direction));
+				     cmd->use_sg, cmd->sc_data_direction);
 		} else if (cmd->request_bufflen) {
 			/*dprintk(1, "No S/G unmap_single cmd=%x saved_dma_handle=%lx\n",
 			  cmd, sp->saved_dma_handle); */
 
 			pci_unmap_page(ha->pdev, sp->saved_dma_handle,
-				       cmd->request_bufflen,
-				       scsi_to_pci_dma_dir(cmd->sc_data_direction));
+				       cmd->request_bufflen, cmd->sc_data_direction);
 		}
 
 		/* Call the mid-level driver interrupt handler */
@@ -1845,7 +1547,6 @@ qla1280_done(struct scsi_qla_host *ha, s
 
 		if(sp->wait != NULL)
 			complete(sp->wait);
-
 	}
 	LEAVE("qla1280_done");
 }
@@ -1854,7 +1555,7 @@ qla1280_done(struct scsi_qla_host *ha, s
  * Translates a ISP error to a Linux SCSI error
  */
 static int
-qla1280_return_status(struct response * sts, Scsi_Cmnd * cp)
+qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 {
 	int host_status = DID_ERROR;
 #if DEBUG_QLA1280_INTR
@@ -1924,133 +1625,25 @@ qla1280_return_status(struct response * 
 		    cp->underflow) {
 			printk(KERN_WARNING
 			       "scsi: Underflow detected - retrying "
-			       "command.\n");
-			host_status = DID_ERROR;
-		} else
-			host_status = DID_OK;
-		break;
-
-	default:
-		host_status = DID_ERROR;
-		break;
-	}
-
-#if DEBUG_QLA1280_INTR
-	dprintk(1, "qla1280 ISP status: host status (%s) scsi status %x\n",
-		reason[host_status], sts->scsi_status);
-#endif
-
-	LEAVE("qla1280_return_status");
-
-	return (sts->scsi_status & 0xff) | (host_status << 16);
-}
-
-/*
- * qla1280_done_q_put
- *      Place SRB command on done queue.
- *
- * Input:
- *      sp           = srb pointer.
- *      done_q_first = done queue first pointer.
- *      done_q_last  = done queue last pointer.
- */
-static void
-qla1280_done_q_put(struct srb * sp, struct srb ** done_q_first,
-		   struct srb ** done_q_last)
-{
-	ENTER("qla1280_put_done_q");
-
-	/* Place block on done queue */
-	sp->s_next = NULL;
-	sp->s_prev = *done_q_last;
-	if (!*done_q_first)
-		*done_q_first = sp;
-	else
-		(*done_q_last)->s_next = sp;
-	*done_q_last = sp;
-
-	LEAVE("qla1280_put_done_q");
-}
-
-
-/*
-* qla1280_mem_alloc
-*      Allocates adapter memory.
-*
-* Returns:
-*      0  = success.
-*      1  = failure.
-*/
-static int
-qla1280_mem_alloc(struct scsi_qla_host *ha)
-{
-	int status = 1;
-	dma_addr_t dma_handle;
-
-	ENTER("qla1280_mem_alloc");
-
-	/* get consistent memory allocated for request and response rings */
-	ha->request_ring = pci_alloc_consistent(ha->pdev,
-						((REQUEST_ENTRY_CNT + 1) *
-						 (sizeof(request_t))),
-						&dma_handle);
-	if (!ha->request_ring)
-		goto error;
-	ha->request_dma = dma_handle;
-	ha->response_ring = pci_alloc_consistent(ha->pdev,
-						 ((RESPONSE_ENTRY_CNT + 1) *
-						  (sizeof(struct response))),
-						 &dma_handle);
-	if (!ha->response_ring)
-		goto error;
-	ha->response_dma = dma_handle;
-	status = 0;
-	goto finish;
-
- error:
-	if (status)
-		dprintk(2, "qla1280_mem_alloc: **** FAILED ****\n");
+			       "command.\n");
+			host_status = DID_ERROR;
+		} else
+			host_status = DID_OK;
+		break;
 
-	if (ha->request_ring)
-		pci_free_consistent(ha->pdev,
-                                    ((REQUEST_ENTRY_CNT + 1) *
-				     (sizeof(request_t))),
-                                    ha->request_ring, ha->request_dma);
- finish:
-	LEAVE("qla1280_mem_alloc");
-	return status;
-}
+	default:
+		host_status = DID_ERROR;
+		break;
+	}
 
-/*
- * qla1280_mem_free
- *      Frees adapter allocated memory.
- *
- * Input:
- *      ha = adapter block pointer.
- */
-static void
-qla1280_mem_free(struct scsi_qla_host *ha)
-{
-	ENTER("qlc1280_mem_free");
-	/* free consistent memory allocated for request and response rings */
-	if (ha->request_ring)
-		pci_free_consistent(ha->pdev,
-				    ((REQUEST_ENTRY_CNT + 1) *
-				     (sizeof(request_t))),
-				    ha->request_ring, ha->request_dma);
-
-	if (ha->response_ring)
-		pci_free_consistent(ha->pdev,
-				    ((RESPONSE_ENTRY_CNT + 1) *
-				     (sizeof(struct response))),
-				    ha->response_ring, ha->response_dma);
+#if DEBUG_QLA1280_INTR
+	dprintk(1, "qla1280 ISP status: host status (%s) scsi status %x\n",
+		reason[host_status], sts->scsi_status);
+#endif
 
-	if (qla1280_buffer) {
-		free_page((unsigned long) qla1280_buffer);
-		qla1280_buffer = NULL;
-	}
+	LEAVE("qla1280_return_status");
 
-	LEAVE("qlc1280_mem_free");
+	return (sts->scsi_status & 0xff) | (host_status << 16);
 }
 
 /****************************************************************************/
@@ -2058,14 +1651,14 @@ qla1280_mem_free(struct scsi_qla_host *h
 /****************************************************************************/
 
  /*
-    * qla2100_enable_intrs
-    * qla2100_disable_intrs
-    *
-    * Input:
-    *      ha = adapter block pointer.
-    *
-    * Returns:
-    *      None
+  * qla2100_enable_intrs
+  * qla2100_disable_intrs
+  *
+  * Input:
+  *      ha = adapter block pointer.
+  *
+  * Returns:
+  *      None
   */
 static inline void
 qla1280_enable_intrs(struct scsi_qla_host *ha)
@@ -2101,7 +1694,7 @@ qla1280_disable_intrs(struct scsi_qla_ho
  * Returns:
  *      0 = success
  */
-static int
+static int __devinit
 qla1280_initialize_adapter(struct scsi_qla_host *ha)
 {
 	struct device_reg *reg;
@@ -2132,7 +1725,8 @@ qla1280_initialize_adapter(struct scsi_q
 		if ((c = snia_pcibr_rrb_alloc(ha->pdev, &count1, &count2)) < 0)
 			printk(KERN_ERR "scsi(%li): Unable to allocate SN2 "
 			       "virtual DMA channels\n", ha->host_no);
-		ha->flags.use_pci_vchannel = 1;
+		else
+			ha->flags.use_pci_vchannel = 1;
 
 		driver_setup.no_nvram = 1;
 	}
@@ -2164,7 +1758,7 @@ qla1280_initialize_adapter(struct scsi_q
 #endif
 	/* If firmware needs to be loaded */
 	if (qla1280_isp_firmware(ha)) {
-		if (!(status = qla1280_chip_diag (ha))) {
+		if (!(status = qla1280_chip_diag(ha))) {
 			status = qla1280_setup_chip(ha);
 		}
 	} else {
@@ -2288,72 +1882,6 @@ qla1280_isp_firmware(struct scsi_qla_hos
 }
 
 /*
- * PCI configuration
- *      Setup device PCI configuration registers.
- *
- * Input:
- *      ha = adapter block pointer.
- *
- * Returns:
- *      0 = success.
- */
-static int
-qla1280_pci_config(struct scsi_qla_host *ha)
-{
-#if MEMORY_MAPPED_IO
-	unsigned long base;
-	int size;
-#endif
-	uint16_t buf_wd;
-	int status = 1;
-
-	ENTER("qla1280_pci_config");
-
-	pci_set_master(ha->pdev);
-	/*
-	 * Set Bus Master Enable, Memory Address Space Enable and
-	 * reset any error bits, in the command register.
-	 */
-	pci_read_config_word (ha->pdev, PCI_COMMAND, &buf_wd);
-#if MEMORY_MAPPED_IO
-	buf_wd |= PCI_COMMAND_MEMORY;
-#endif
-	buf_wd |= PCI_COMMAND_IO;
-	pci_write_config_word (ha->pdev, PCI_COMMAND, buf_wd);
-	/*
-	 * Reset expansion ROM address decode enable.
-	 */
-	pci_read_config_word(ha->pdev, PCI_ROM_ADDRESS, &buf_wd);
-	buf_wd &= ~PCI_ROM_ADDRESS_ENABLE;
-	pci_write_config_word (ha->pdev, PCI_ROM_ADDRESS, buf_wd);
-
-	ha->host->io_port = pci_resource_start(ha->pdev, 0);
-	ha->host->io_port &= PCI_BASE_ADDRESS_IO_MASK;
-	ha->iobase = (struct device_reg *) ha->host->io_port;
-
-#if MEMORY_MAPPED_IO
-	/*
-	 * Find proper memory chunk for memory map I/O reg.
-	 */
-	base = pci_resource_start(ha->pdev, 1);
-	size = pci_resource_len(ha->pdev, 1);
-	/*
-	 * Get virtual address for I/O registers.
-	 */
-	ha->mmpbase = ioremap(base, size);
-	if (ha->mmpbase) {
-		ha->iobase = (struct device_reg *)ha->mmpbase;
-		status = 0;
-	}
-#else				/* MEMORY_MAPPED_IO */
-	status = 0;
-#endif				/* MEMORY_MAPPED_IO */
-
-	LEAVE("qla1280_pci_config");
-	return status;
-}
-
-/*
  * Chip diagnostics
  *      Test chip for proper operation.
  *
@@ -2724,8 +2252,8 @@ qla1280_nvram_config(struct scsi_qla_hos
 
 	ENTER("qla1280_nvram_config");
 
-	if (ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
-	    ha->device_id == PCI_DEVICE_ID_QLOGIC_ISP10160)
+	if (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160 ||
+	    ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160)
 		is1x160 = 1;
 	else
 		is1x160 = 0;
@@ -3196,8 +2724,7 @@ qla1280_mailbox_command(struct scsi_qla_
 {
 	struct device_reg *reg = ha->iobase;
 #if 0
-	struct srb *done_q_first = 0;
-	struct srb *done_q_last = 0;
+	LIST_HEAD(done_q);
 #endif
 	int status = 0;
 	int cnt;
@@ -3208,8 +2735,6 @@ qla1280_mailbox_command(struct scsi_qla_
 
 	ENTER("qla1280_mailbox_command");
 
-	ha->flags.mbox_busy = 1;
-
 	if (ha->mailbox_wait) {
 		printk(KERN_ERR "Warning mailbox wait already in use!\n");
 	}
@@ -3233,7 +2758,6 @@ qla1280_mailbox_command(struct scsi_qla_
 	}
 
 	/* Issue set host interrupt command. */
-	ha->flags.mbox_busy = 0;
 
 	/* set up a timer just in case we're really jammed */
 	init_timer(&timer);
@@ -3276,15 +2800,15 @@ qla1280_mailbox_command(struct scsi_qla_
 
 #if 0
 	/* Go check for any response interrupts pending. */
-	qla1280_isr(ha, &done_q_first, &done_q_last);
+	qla1280_isr(ha, &done_q);
 #endif
 
 	if (ha->flags.reset_marker)
 		qla1280_rst_aen(ha);
 
 #if 0
-	if (done_q_first)
-		qla1280_done (ha, &done_q_first, &done_q_last);
+	if (!list_empty(&done_q))
+		qla1280_done(ha, &done_q);
 #endif
 
 	if (status)
@@ -3307,23 +2831,22 @@ qla1280_poll(struct scsi_qla_host *ha)
 {
 	struct device_reg *reg = ha->iobase;
 	uint16_t data;
-	struct srb *done_q_first = 0;
-	struct srb *done_q_last = 0;
+	LIST_HEAD(done_q);
 
 	/* ENTER("qla1280_poll"); */
 
 	/* Check for pending interrupts. */
 	data = RD_REG_WORD(&reg->istatus);
 	if (data & RISC_INT)
-		qla1280_isr(ha, &done_q_first, &done_q_last);
+		qla1280_isr(ha, &done_q);
 
-	if (!ha->flags.mbox_busy) {
+	if (!ha->mailbox_wait) {
 		if (ha->flags.reset_marker)
 			qla1280_rst_aen(ha);
 	}
 
-	if (done_q_first)
-		qla1280_done(ha, &done_q_first, &done_q_last);
+	if (!list_empty(&done_q))
+		qla1280_done(ha);
 
 	/* LEAVE("qla1280_poll"); */
 }
@@ -3573,7 +3096,7 @@ static int
 qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 {
 	struct device_reg *reg = ha->iobase;
-	Scsi_Cmnd *cmd = sp->cmd;
+	struct scsi_cmnd *cmd = sp->cmd;
 	cmd_a64_entry_t *pkt;
 	struct scatterlist *sg = NULL;
 	u32 *dword_ptr;
@@ -3582,6 +3105,7 @@ qla1280_64bit_start_scsi(struct scsi_qla
 	int cnt;
 	int req_cnt;
 	u16 seg_cnt;
+	u8 dir;
 
 	ENTER("qla1280_64bit_start_scsi:");
 
@@ -3590,7 +3114,7 @@ qla1280_64bit_start_scsi(struct scsi_qla
 	if (cmd->use_sg) {
 		sg = (struct scatterlist *) cmd->request_buffer;
 		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
-				     scsi_to_pci_dma_dir(cmd->sc_data_direction));
+				     cmd->sc_data_direction);
 
 		if (seg_cnt > 2) {
 			req_cnt += (seg_cnt - 2) / 5;
@@ -3675,8 +3199,8 @@ qla1280_64bit_start_scsi(struct scsi_qla
 	/* dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
 
 	/* Set transfer direction. */
-	sp->dir = qla1280_data_direction(cmd);
-	pkt->control_flags |= cpu_to_le16(sp->dir);
+	dir = qla1280_data_direction(cmd);
+	pkt->control_flags |= cpu_to_le16(dir);
 
 	/* Set total data segment count. */
 	pkt->dseg_count = cpu_to_le16(seg_cnt);
@@ -3780,7 +3304,7 @@ qla1280_64bit_start_scsi(struct scsi_qla
 
 			dma_handle = pci_map_page(ha->pdev, page, off,
 						  cmd->request_bufflen,
-						  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+						  cmd->sc_data_direction);
 
 			/* save dma_handle for pci_unmap_page */
 			sp->saved_dma_handle = dma_handle;
@@ -3858,7 +3382,7 @@ static int
 qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 {
 	struct device_reg *reg = ha->iobase;
-	Scsi_Cmnd *cmd = sp->cmd;
+	struct scsi_cmnd *cmd = sp->cmd;
 	struct cmd_entry *pkt;
 	struct scatterlist *sg = NULL;
 	uint32_t *dword_ptr;
@@ -3867,6 +3391,7 @@ qla1280_32bit_start_scsi(struct scsi_qla
 	int req_cnt;
 	uint16_t seg_cnt;
 	dma_addr_t dma_handle;
+	u8 dir;
 
 	ENTER("qla1280_32bit_start_scsi");
 
@@ -3884,7 +3409,7 @@ qla1280_32bit_start_scsi(struct scsi_qla
 		 */
 		sg = (struct scatterlist *) cmd->request_buffer;
 		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
-				     scsi_to_pci_dma_dir(cmd->sc_data_direction));
+				     cmd->sc_data_direction);
 
 		/*
 		 * if greater than four sg entries then we need to allocate
@@ -3975,8 +3500,8 @@ qla1280_32bit_start_scsi(struct scsi_qla
 
 	/*dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
 	/* Set transfer direction. */
-	sp->dir = qla1280_data_direction(cmd);
-	pkt->control_flags |= cpu_to_le16(sp->dir);
+	dir = qla1280_data_direction(cmd);
+	pkt->control_flags |= cpu_to_le16(dir);
 
 	/* Set total data segment count. */
 	pkt->dseg_count = cpu_to_le16(seg_cnt);
@@ -4061,7 +3586,7 @@ qla1280_32bit_start_scsi(struct scsi_qla
 			unsigned long off = (unsigned long)cmd->request_buffer & ~PAGE_MASK;
 			dma_handle = pci_map_page(ha->pdev, page, off,
 						  cmd->request_bufflen,
-						  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+						  cmd->sc_data_direction);
 			sp->saved_dma_handle = dma_handle;
 
 			*dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
@@ -4207,48 +3732,6 @@ qla1280_isp_cmd(struct scsi_qla_host *ha
 	LEAVE("qla1280_isp_cmd");
 }
 
-#if QL1280_LUN_SUPPORT
-/*
- * qla1280_enable_lun
- *      Issue enable LUN entry IOCB.
- *
- * Input:
- *      ha  = adapter block pointer.
- *      bus = SCSI BUS number.
- *      lun  = LUN number.
- */
-static void
-qla1280_enable_lun(struct scsi_qla_host *ha, int bus, int lun)
-{
-	struct elun_entry *pkt;
-
-	ENTER("qla1280_enable_lun");
-
-	/* Get request packet. */
-	/*
-	  if (pkt = (struct elun_entry *)qla1280_req_pkt(ha))
-	  {
-	  pkt->entry_type = ENABLE_LUN_TYPE;
-	  pkt->lun = cpu_to_le16(bus ? lun | BIT_15 : lun);
-	  pkt->command_count = 32;
-	  pkt->immed_notify_count = 1;
-	  pkt->group_6_length = MAX_CMDSZ;
-	  pkt->group_7_length = MAX_CMDSZ;
-	  pkt->timeout = cpu_to_le16(0x30);
-
-	  qla1280_isp_cmd(ha);
-	  }
-	*/
-	pkt = (struct elun_entry *) 1;
-
-	if (!pkt)
-		dprintk(2, "qla1280_enable_lun: **** FAILED ****\n");
-	else
-		dprintk(3, "qla1280_enable_lun: exiting normally\n");
-}
-#endif
-
-
 /****************************************************************************/
 /*                        Interrupt Service Routine.                        */
 /****************************************************************************/
@@ -4259,12 +3742,10 @@ qla1280_enable_lun(struct scsi_qla_host 
  *
  * Input:
  *      ha           = adapter block pointer.
- *      done_q_first = done queue first pointer.
- *      done_q_last  = done queue last pointer.
+ *      done_q       = done queue.
  ****************************************************************************/
 static void
-qla1280_isr(struct scsi_qla_host *ha, struct srb ** done_q_first,
-	    struct srb ** done_q_last)
+qla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)
 {
 	struct device_reg *reg = ha->iobase;
 	struct response *pkt;
@@ -4336,13 +3817,7 @@ qla1280_isr(struct scsi_qla_host *ha, st
 					CMD_RESULT(sp->cmd) = 0;
 
 					/* Place block on done queue */
-					sp->s_next = NULL;
-					sp->s_prev = *done_q_last;
-					if (!*done_q_first)
-						*done_q_first = sp;
-					else
-						(*done_q_last)->s_next = sp;
-					*done_q_last = sp;
+					list_add_tail(&sp->list, done_q);
 				} else {
 					/*
 					 * If we get here we have a real problem!
@@ -4420,15 +3895,10 @@ qla1280_isr(struct scsi_qla_host *ha, st
 	}
 
 	/*
-	 * Response ring - waiting for the mbox_busy flag here seems
-	 * unnecessary as the mailbox data has been copied to ha->mailbox_out
-	 * by the time we actually get here!
+	 * We will receive interrupts during mailbox testing prior to
+	 * the card being marked online, hence the double check.
 	 */
-	if (!(ha->flags.online
-#if 0
-	    && !ha->flags.mbox_busy
-#endif
-		)) {
+	if (!(ha->flags.online && !ha->mailbox_wait)) {
 		dprintk(2, "qla1280_isr: Response pointer Error\n");
 		goto out;
 	}
@@ -4468,12 +3938,9 @@ qla1280_isr(struct scsi_qla_host *ha, st
 				ha->outstanding_cmds[pkt->handle]->cmd,
 				pkt->handle);
 			if (pkt->entry_type == STATUS_TYPE)
-				qla1280_status_entry(ha, pkt, done_q_first,
-						     done_q_last);
+				qla1280_status_entry(ha, pkt, done_q);
 			else
-				qla1280_error_entry(ha, pkt, done_q_first,
-						    done_q_last);
-
+				qla1280_error_entry(ha, pkt, done_q);
 			/* Adjust ring index. */
 			ha->rsp_ring_index++;
 			if (ha->rsp_ring_index == RESPONSE_ENTRY_CNT) {
@@ -4575,17 +4042,16 @@ qla1280_get_target_options(struct scsi_c
  * Input:
  *      ha           = adapter block pointer.
  *      pkt          = entry pointer.
- *      done_q_first = done queue first pointer.
- *      done_q_last  = done queue last pointer.
+ *      done_q       = done queue.
  */
 static void
 qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
-		     struct srb **done_q_first, struct srb **done_q_last)
+		     struct list_head *done_q)
 {
 	unsigned int bus, target, lun;
 	int sense_sz;
 	struct srb *sp;
-	Scsi_Cmnd *cmd;
+	struct scsi_cmnd *cmd;
 	uint32_t handle = le32_to_cpu(pkt->handle);
 	uint16_t scsi_status = le16_to_cpu(pkt->scsi_status);
 	uint16_t comp_status = le16_to_cpu(pkt->comp_status);
@@ -4637,7 +4103,7 @@ qla1280_status_entry(struct scsi_qla_hos
 					sense_sz = req_sense_length;
 				else
 					/*
-					 * Scsi_Cmnd->sense_buffer is
+					 * scsi_cmnd->sense_buffer is
 					 * 64 bytes, why only copy 63?
 					 * This looks wrong! /Jes
 					 */
@@ -4659,9 +4125,9 @@ qla1280_status_entry(struct scsi_qla_hos
 						    sense_sz);
 		}
 	}
-	/* Place command on done queue. */
-	qla1280_done_q_put(sp, done_q_first, done_q_last);
 
+	/* Place command on done queue. */
+	list_add_tail(&sp->list, done_q);
  out:
 	LEAVE("qla1280_status_entry");
 }
@@ -4673,12 +4139,11 @@ qla1280_status_entry(struct scsi_qla_hos
  * Input:
  *      ha           = adapter block pointer.
  *      pkt          = entry pointer.
- *      done_q_first = done queue first pointer.
- *      done_q_last  = done queue last pointer.
+ *      done_q       = done queue.
  */
 static void
-qla1280_error_entry(struct scsi_qla_host *ha, struct response * pkt,
-		    struct srb ** done_q_first, struct srb ** done_q_last)
+qla1280_error_entry(struct scsi_qla_host *ha, struct response *pkt,
+		    struct list_head *done_q)
 {
 	struct srb *sp;
 	uint32_t handle = le32_to_cpu(pkt->handle);
@@ -4715,8 +4180,9 @@ qla1280_error_entry(struct scsi_qla_host
 			/* Set error status. */
 			CMD_RESULT(sp->cmd) = DID_ERROR << 16;
 		}
+
 		/* Place command on done queue. */
-		qla1280_done_q_put(sp, done_q_first, done_q_last);
+		list_add_tail(&sp->list, done_q);
 	}
 #ifdef QLA_64BIT_PTR
 	else if (pkt->entry_type == COMMAND_A64_TYPE) {
@@ -4760,7 +4226,7 @@ qla1280_abort_isp(struct scsi_qla_host *
 		       ha->host_no);
 		/* Dequeue all commands in outstanding command list. */
 		for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
-			Scsi_Cmnd *cmd;
+			struct scsi_cmnd *cmd;
 			sp = ha->outstanding_cmds[cnt];
 			if (sp) {
 
@@ -4894,7 +4360,8 @@ qla1280_check_for_dead_scsi_bus(struct s
 }
 
 static void
-qla12160_get_target_parameters(struct scsi_qla_host *ha, Scsi_Device *device)
+qla1280_get_target_parameters(struct scsi_qla_host *ha,
+			      struct scsi_device *device)
 {
 	uint16_t mb[MAILBOX_REGISTER_COUNT];
 	int bus, target, lun;
@@ -4959,7 +4426,7 @@ __qla1280_dump_buffer(char *b, int size)
  *
  **************************************************************************/
 static void
-__qla1280_print_scsi_cmd(Scsi_Cmnd * cmd)
+__qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)
 {
 	struct scsi_qla_host *ha;
 	struct Scsi_Host *host = CMD_HOST(cmd);
@@ -4987,11 +4454,11 @@ __qla1280_print_scsi_cmd(Scsi_Cmnd * cmd
 	   printk("  SG buffer: \n");
 	   qla1280_dump_buffer(1, (char *)sg, (cmd->use_sg*sizeof(struct scatterlist)));
 	   } */
-	printk("  tag=%d, flags=0x%x, transfersize=0x%x \n",
-	       cmd->tag, cmd->flags, cmd->transfersize);
+	printk("  tag=%d, transfersize=0x%x \n",
+	       cmd->tag, cmd->transfersize);
 	printk("  Pid=%li, SP=0x%p\n", cmd->pid, CMD_SP(cmd));
 	printk(" underflow size = 0x%x, direction=0x%x\n",
-	       cmd->underflow, sp->dir);
+	       cmd->underflow, cmd->sc_data_direction);
 }
 
 /**************************************************************************
@@ -5002,7 +4469,7 @@ static void
 ql1280_dump_device(struct scsi_qla_host *ha)
 {
 
-	Scsi_Cmnd *cp;
+	struct scsi_cmnd *cp;
 	struct srb *sp;
 	int i;
 
@@ -5136,34 +4603,294 @@ qla1280_get_token(char *str)
 	return ret;
 }
 
-
-static Scsi_Host_Template driver_template = {
+#if LINUX_VERSION_CODE >= 0x020600
+static struct scsi_host_template qla1280_driver_template = {
+	.proc_name		= "qla1280",
+	.name			= "Qlogic ISP 1280/12160",
+	.info			= qla1280_info,
+	.slave_configure	= qla1280_slave_configure,
+	.queuecommand		= qla1280_queuecommand,
+	.eh_abort_handler	= qla1280_eh_abort,
+	.eh_device_reset_handler= qla1280_eh_device_reset,
+	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
+	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
+	.bios_param		= qla1280_biosparam,
 	.proc_info		= qla1280_proc_info,
+	.can_queue		= 0xfffff,
+	.this_id		= -1,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+};
+#else
+static Scsi_Host_Template qla1280_driver_template = {
+	.proc_name		= "qla1280",
 	.name			= "Qlogic ISP 1280/12160",
 	.detect			= qla1280_detect,
 	.release		= qla1280_release,
 	.info			= qla1280_info,
 	.queuecommand		= qla1280_queuecommand,
-#if LINUX_VERSION_CODE >= 0x020545
-	.slave_configure	= qla1280_slave_configure,
-#endif
 	.eh_abort_handler	= qla1280_eh_abort,
 	.eh_device_reset_handler= qla1280_eh_device_reset,
 	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
 	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
-	.bios_param		= qla1280_biosparam,
-	.can_queue		= 255,
+	.bios_param		= qla1280_biosparam_old,
+	.proc_info		= qla1280_proc_info_old,
+	.can_queue		= 0xfffff,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 3,
+	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
-#if LINUX_VERSION_CODE < 0x020545
 	.use_new_eh_code	= 1,
+};
+#endif
+
+static int __devinit
+qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int devnum = id->driver_data;
+	struct qla_boards *bdp = &ql1280_board_tbl[devnum];
+	struct Scsi_Host *host;
+	struct scsi_qla_host *ha;
+	int error = -ENODEV;
+
+	/* Bypass all AMI SUBSYS VENDOR IDs */
+	if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {
+		printk(KERN_INFO
+		       "qla1280: Skipping AMI SubSys Vendor ID Chip\n");
+		goto error;
+	}
+
+	printk(KERN_INFO "qla1280: %s found on PCI bus %i, dev %i\n",
+	       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));
+	
+	if (pci_enable_device(pdev)) {
+		printk(KERN_WARNING
+		       "qla1280: Failed to enabled pci device, aborting.\n");
+		goto error;
+	}
+
+	pci_set_master(pdev);
+
+	error = -ENOMEM;
+	host = scsi_host_alloc(&qla1280_driver_template, sizeof(*ha));
+	if (!host) {
+		printk(KERN_WARNING
+		       "qla1280: Failed to register host, aborting.\n");
+		goto error_disable_device;
+	}
+
+	ha = (struct scsi_qla_host *)host->hostdata;
+	memset(ha, 0, sizeof(struct scsi_qla_host));
+
+	ha->pdev = pdev;
+	ha->devnum = devnum;	/* specifies microcode load address */
+
+	ha->request_ring = pci_alloc_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			&ha->request_dma);
+	if (!ha->request_ring) {
+		printk(KERN_INFO "qla1280: Failed to get request memory\n");
+		goto error_put_host;
+	}
+
+	ha->response_ring = pci_alloc_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			&ha->response_dma);
+	if (!ha->response_ring) {
+		printk(KERN_INFO "qla1280: Failed to get response memory\n");
+		goto error_free_request_ring;
+	}
+
+	ha->ports = bdp->numPorts;
+
+	ha->host = host;
+	ha->host_no = host->host_no;
+
+	host->irq = pdev->irq;
+	host->max_channel = bdp->numPorts - 1;
+	host->max_lun = MAX_LUNS - 1;
+	host->max_id = MAX_TARGETS;
+	host->max_sectors = 1024;
+	host->unique_id = host->host_no;
+
+#if LINUX_VERSION_CODE < 0x020545
+	host->select_queue_depths = qla1280_select_queue_depth;
+#endif
+
+	error = -ENODEV;
+
+#if MEMORY_MAPPED_IO
+	ha->mmpbase = ioremap(pci_resource_start(ha->pdev, 1),
+			      pci_resource_len(ha->pdev, 1));
+	if (!ha->mmpbase) {
+		printk(KERN_INFO "qla1280: Unable to map I/O memory\n");
+		goto error_free_response_ring;
+	}
+
+	host->base = (unsigned long)ha->mmpbase;
+	ha->iobase = (struct device_reg *)ha->mmpbase;
+#else
+	host->io_port = pci_resource_start(ha->pdev, 0);
+	if (!request_region(host->io_port, 0xff, "qla1280")) {
+		printk(KERN_INFO "qla1280: Failed to reserve i/o region "
+				 "0x%04lx-0x%04lx - already in use\n",
+		       host->io_port, host->io_port + 0xff);
+		goto error_free_response_ring;
+	}
+
+	ha->iobase = (struct device_reg *)host->io_port;
+#endif
+
+	INIT_LIST_HEAD(&ha->done_q);
+
+	/* Disable ISP interrupts. */
+	qla1280_disable_intrs(ha);
+
+	if (request_irq(pdev->irq, qla1280_intr_handler, SA_SHIRQ,
+				"qla1280", ha)) {
+		printk("qla1280 : Failed to reserve interrupt %d already "
+		       "in use\n", pdev->irq);
+		goto error_release_region;
+	}
+
+	/* load the F/W, read paramaters, and init the H/W */
+	if (qla1280_initialize_adapter(ha)) {
+		printk(KERN_INFO "qla1x160: Failed to initialize adapter\n");
+		goto error_free_irq;
+	}
+
+	/* set our host ID  (need to do something about our two IDs) */
+	host->this_id = ha->bus_settings[0].id;
+
+	pci_set_drvdata(pdev, host);
+
+#if LINUX_VERSION_CODE >= 0x020600
+	error = scsi_add_host(host, &pdev->dev);
+	if (error)
+		goto error_disable_adapter;
+	scsi_scan_host(host);
+#else
+	scsi_set_pci_device(host, pdev);
+#endif
+
+	return 0;
+
+#if LINUX_VERSION_CODE >= 0x020600
+ error_disable_adapter:
+	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+#endif
+ error_release_region:
+#if MEMORY_MAPPED_IO
+	iounmap(ha->mmpbase);
+#else
+	release_region(host->io_port, 0xff);
+#endif
+ error_free_irq:
+	free_irq(pdev->irq, ha);
+ error_free_response_ring:
+	pci_free_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			ha->response_ring, ha->response_dma);
+ error_free_request_ring:
+	pci_free_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			ha->request_ring, ha->request_dma);
+ error_put_host:
+	scsi_host_put(host);
+ error_disable_device:
+	pci_disable_device(pdev);
+ error:
+	return error;
+}
+
+
+static void __devexit
+qla1280_remove_one(struct pci_dev *pdev)
+{
+	struct Scsi_Host *host = pci_get_drvdata(pdev);
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+
+#if LINUX_VERSION_CODE >= 0x020600
+	scsi_remove_host(host);
+#endif
+
+	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+
+	free_irq(pdev->irq, ha);
+
+#if MEMORY_MAPPED_IO
+	iounmap(ha->mmpbase);
+#else
+	release_region(host->io_port, 0xff);
 #endif
+
+	pci_free_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			ha->request_ring, ha->request_dma);
+	pci_free_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			ha->response_ring, ha->response_dma);
+
+	pci_disable_device(pdev);
+
+	scsi_host_put(host);
+}
+
+#if LINUX_VERSION_CODE >= 0x020600
+static struct pci_driver qla1280_pci_driver = {
+	.name		= "qla1280",
+	.id_table	= qla1280_pci_tbl,
+	.probe		= qla1280_probe_one,
+	.remove		= __devexit_p(qla1280_remove_one),
 };
 
-#include "scsi_module.c"
+static int __init
+qla1280_init(void)
+{
+	if (sizeof(struct srb) > sizeof(struct scsi_pointer)) {
+		printk(KERN_WARNING
+		       "qla1280: struct srb too big, aborting\n");
+		return -EINVAL;
+	}
+
+#ifdef MODULE
+	/*
+	 * If we are called as a module, the qla1280 pointer may not be null
+	 * and it would point to our bootup string, just like on the lilo
+	 * command line.  IF not NULL, then process this config string with
+	 * qla1280_setup
+	 *
+	 * Boot time Options
+	 * To add options at boot time add a line to your lilo.conf file like:
+	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
+	 * which will result in the first four devices on the first two
+	 * controllers being set to a tagged queue depth of 32.
+	 */
+	if (qla1280)
+		qla1280_setup(qla1280);
+#endif
+
+	return pci_module_init(&qla1280_pci_driver);
+}
+
+static void __exit
+qla1280_exit(void)
+{
+	pci_unregister_driver(&qla1280_pci_driver);
+}
+
+module_init(qla1280_init);
+module_exit(qla1280_exit);
 
+#else
+# define driver_template qla1280_driver_template
+# include "scsi_module.c"
+#endif
+
+MODULE_AUTHOR("Qlogic & Jes Sorensen");
+MODULE_DESCRIPTION("Qlogic ISP SCSI (qla1x80/qla1x160) driver");
+MODULE_LICENSE("GPL");
 
 /*
  * Overrides for Emacs so that we almost follow Linus's tabbing style.
diff -purN linux-2.6.1/drivers/scsi/qla1280.h linux-2.5/drivers/scsi/qla1280.h
--- linux-2.6.1/drivers/scsi/qla1280.h	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/drivers/scsi/qla1280.h	2004-01-05 05:07:47.000000000 +0000
@@ -17,8 +17,8 @@
 *
 ******************************************************************************/
 
-#ifndef	_IO_HBA_QLA1280_H	/* wrapper symbol for kernel use */
-#define	_IO_HBA_QLA1280_H	/* subject to change without notice */
+#ifndef	_QLA1280_H
+#define	_QLA1280_H
 
 /*
  * Data bit definitions.
@@ -100,55 +100,23 @@
  * on cmd->SCp location of every I/O
  */
 struct srb {
-	Scsi_Cmnd *cmd;		/* (4/8) SCSI command block */
-	struct srb *s_next;	/* (4/8) Next block on LU queue */
-	struct srb *s_prev;	/* (4/8) Previous block on LU queue */
-	uint8_t flags;		/* (1) Status flags. */
-	uint8_t dir;		/* direction of transfer */
-	/*
-	 * This should be moved around to save space.
-	 */
-	dma_addr_t saved_dma_handle;	/* for unmap of single transfers */
+	struct list_head list;		/* (8/16) LU queue */
+	struct scsi_cmnd *cmd;	/* (4/8) SCSI command block */
 	/* NOTE: the sp->cmd will be NULL when this completion is
 	 * called, so you should know the scsi_cmnd when using this */
 	struct completion *wait;
+	dma_addr_t saved_dma_handle;	/* for unmap of single transfers */
+	uint8_t flags;		/* (1) Status flags. */
+	uint8_t dir;		/* direction of transfer */
 };
 
 /*
  * SRB flag definitions
  */
-#define SRB_TIMEOUT		BIT_0	/* Command timed out */
-#define SRB_SENT		BIT_1	/* Command sent to ISP */
-#define SRB_ABORT_PENDING	BIT_2	/* Command abort sent to device */
-#define SRB_ABORTED		BIT_3	/* Command aborted command already */
-
-/*
- * Logical Unit Queue structure
- */
-struct scsi_lu {
-	struct srb *q_first;	/* First block on LU queue */
-	struct srb *q_last;	/* Last block on LU queue */
-	uint8_t q_flag;		/* LU queue state flags */
-	uint8_t q_sense[16];	/* sense data */
-	unsigned long io_cnt;	/* total xfer count */
-	unsigned long resp_time;/* total response time (start - finish) */
-	unsigned long act_time;	/* total actived time (minus queuing time) */
-	unsigned long w_cnt;	/* total writes */
-	unsigned long r_cnt;	/* total reads */
-	uint16_t q_outcnt;	/* Pending jobs for this LU */
-};
-
-/*
- * Logical Unit flags
- */
-#define QLA1280_QBUSY	BIT_0
-#define QLA1280_QWAIT	BIT_1
-#define QLA1280_QSUSP	BIT_2
-#define QLA1280_QSENSE	BIT_3	/* Sense data cache valid */
-#define QLA1280_QRESET	BIT_4
-#define QLA1280_QHBA	BIT_5
-#define QLA1280_BSUSP	BIT_6	/* controller is suspended */
-#define QLA1280_BREM	BIT_7	/* controller is removed */
+#define SRB_TIMEOUT		(1 << 0)	/* Command timed out */
+#define SRB_SENT		(1 << 1)	/* Command sent to ISP */
+#define SRB_ABORT_PENDING	(1 << 2)	/* Command abort sent to device */
+#define SRB_ABORTED		(1 << 3)	/* Command aborted command already */
 
 /*
  *  ISP I/O Register Set structure definitions.
@@ -1021,11 +989,7 @@ struct scsi_qla_host {
 
 	unsigned char *mmpbase;	/* memory mapped address */
 	unsigned long host_no;
-	unsigned long instance;
 	struct pci_dev *pdev;
-	uint32_t device_id;
-	uint8_t pci_bus;
-	uint8_t pci_device_fn;
 	uint8_t devnum;
 	uint8_t revision;
 	uint8_t ports;
@@ -1040,18 +1004,9 @@ struct scsi_qla_host {
 	/* BUS configuration data */
 	struct bus_param bus_settings[MAX_BUSES];
 
-#if 0
-	/* bottom half run queue */
-	struct tq_struct run_qla_bh;
-#endif
-
 	/* Received ISP mailbox data. */
 	volatile uint16_t mailbox_out[MAILBOX_REGISTER_COUNT];
 
-#ifdef UNUSED
-	struct timer_list dev_timer[MAX_TARGETS];
-#endif
-
 	dma_addr_t request_dma;		/* Physical Address */
 	request_t *request_ring;	/* Base virtual address */
 	request_t *request_ring_ptr;	/* Current address. */
@@ -1063,30 +1018,19 @@ struct scsi_qla_host {
 	struct response *response_ring_ptr;	/* Current address. */
 	uint16_t rsp_ring_index;	/* Current index. */
 
-#if WATCHDOGTIMER
-	/* Watchdog queue, lock and total timer */
-	uint8_t watchdog_q_lock;	/* Lock for watchdog queue */
-	struct srb *wdg_q_first;	/* First job on watchdog queue */
-	struct srb *wdg_q_last;	/* Last job on watchdog queue */
-	uint32_t total_timeout;	/* Total timeout (quantum count) */
-	uint32_t watchdogactive;
-#endif
-
-	struct srb *done_q_first;	/* First job on done queue */
-	struct srb *done_q_last;	/* Last job on done queue */
+	struct list_head done_q;	/* Done queue */
 
 	struct completion *mailbox_wait;
 
 	volatile struct {
-		uint32_t mbox_busy:1;			/* 0 */
-		uint32_t online:1;			/* 1 */
-		uint32_t reset_marker:1;		/* 2 */
-		uint32_t disable_host_adapter:1;	/* 4 */
-		uint32_t reset_active:1;		/* 5 */
-		uint32_t abort_isp_active:1;		/* 6 */
-		uint32_t disable_risc_code_load:1;	/* 7 */
-		uint32_t enable_64bit_addressing:1;	/* 8 */
-		uint32_t in_reset:1;			/* 9 */
+		uint32_t online:1;			/* 0 */
+		uint32_t reset_marker:1;		/* 1 */
+		uint32_t disable_host_adapter:1;	/* 2 */
+		uint32_t reset_active:1;		/* 3 */
+		uint32_t abort_isp_active:1;		/* 4 */
+		uint32_t disable_risc_code_load:1;	/* 5 */
+		uint32_t enable_64bit_addressing:1;	/* 6 */
+		uint32_t in_reset:1;			/* 7 */
 		uint32_t ints_enabled:1;
 		uint32_t ignore_nvram:1;
 #ifdef __ia64__
@@ -1098,10 +1042,4 @@ struct scsi_qla_host {
 	int nvram_valid;
 };
 
-/*
- * Macros to help code, maintain, etc.
- */
-#define SUBDEV(b, t, l)		((b << (MAX_T_BITS + MAX_L_BITS)) | (t << MAX_L_BITS) | l)
-#define LU_Q(ha, b, t, l)	(ha->dev[SUBDEV(b, t, l)])
-
-#endif				/* _IO_HBA_QLA1280_H */
+#endif /* _QLA1280_H */
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/Kconfig linux-2.5/drivers/scsi/qla2xxx/Kconfig
--- linux-2.6.1/drivers/scsi/qla2xxx/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/Kconfig	2004-01-15 17:48:36.000000000 +0000
@@ -0,0 +1,29 @@
+config SCSI_QLA2XXX_CONFIG
+	tristate
+	default (SCSI && PCI)
+	depends on SCSI && PCI
+
+config SCSI_QLA2XXX
+	tristate
+
+config SCSI_QLA21XX
+	tristate "Qlogic ISP2100 host adapter family support"
+	select SCSI_QLA2XXX
+	depends on SCSI_QLA2XXX_CONFIG
+	---help---
+	This driver supports the QLogic 21xx (ISP2100) host adapter family.
+
+config SCSI_QLA22XX
+	tristate "Qlogic ISP2200 host adapter family support"
+	select SCSI_QLA2XXX
+	depends on SCSI_QLA2XXX_CONFIG
+	---help---
+	This driver supports the QLogic 22xx (ISP2200) host adapter family.
+
+config SCSI_QLA23XX
+	tristate "Qlogic ISP23xx host adapter family support"
+	select SCSI_QLA2XXX
+	depends on SCSI_QLA2XXX_CONFIG
+	---help---
+	This driver supports the QLogic 23xx (ISP2300, ISP2312, and ISP2322)
+	host adapter family.
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/Makefile linux-2.5/drivers/scsi/qla2xxx/Makefile
--- linux-2.6.1/drivers/scsi/qla2xxx/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/Makefile	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,12 @@
+EXTRA_CFLAGS += -g -Idrivers/scsi -DUNIQUE_FW_NAME
+
+qla2xxx-y := qla_os.o qla_init.o qla_mbx.o qla_iocb.o qla_isr.o qla_gs.o \
+		qla_dbg.o qla_sup.o qla_rscn.o
+
+qla2100-y := ql2100.o ql2100_fw.o
+qla2200-y := ql2200.o ql2200_fw.o
+qla2300-y := ql2300.o ql2300_fw.o #ql2322_fw.o
+
+obj-$(CONFIG_SCSI_QLA21XX) += qla2xxx.o qla2100.o
+obj-$(CONFIG_SCSI_QLA22XX) += qla2xxx.o qla2200.o
+obj-$(CONFIG_SCSI_QLA23XX) += qla2xxx.o qla2300.o
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2100.c linux-2.5/drivers/scsi/qla2xxx/ql2100.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2100.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2100.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,92 @@
+/*
+ * QLogic ISP2100 device driver for Linux 2.6.x
+ * Copyright (C) 2003 Christoph Hellwig.
+ * Copyright (C) 2003 QLogic Corporation (www.qlogic.com)
+ *
+ * Released under GPL v2.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+static char qla_driver_name[] = "qla2100";
+
+extern unsigned char  fw2100tp_version[];
+extern unsigned char  fw2100tp_version_str[];
+extern unsigned short fw2100tp_addr01;
+extern unsigned short fw2100tp_code01[];
+extern unsigned short fw2100tp_length01;
+
+static struct qla_fw_info qla_fw_tbl[] = {
+	{
+		.addressing	= FW_INFO_ADDR_NORMAL,
+		.fwcode		= &fw2100tp_code01[0],
+		.fwlen		= &fw2100tp_length01,
+		.fwstart	= &fw2100tp_addr01,
+	},
+
+	{ FW_INFO_ADDR_NOMORE, },
+};
+
+static struct qla_board_info qla_board_tbl = {
+	.drv_name	= qla_driver_name,
+
+	.isp_name	= "ISP2100",
+	.fw_info	= qla_fw_tbl,
+};
+
+static struct pci_device_id qla2100_pci_tbl[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP2100,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= (unsigned long)&qla_board_tbl,
+	},
+
+	{0, 0},
+};
+MODULE_DEVICE_TABLE(pci, qla2100_pci_tbl);
+
+static int __devinit
+qla2100_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	return qla2x00_probe_one(pdev,
+	    (struct qla_board_info *)id->driver_data);
+}
+
+static void __devexit
+qla2100_remove_one(struct pci_dev *pdev)
+{
+	qla2x00_remove_one(pdev);
+}
+
+static struct pci_driver qla2100_pci_driver = {
+	.name		= "qla2100",
+	.id_table	= qla2100_pci_tbl,
+	.probe		= qla2100_probe_one,
+	.remove		= __devexit_p(qla2100_remove_one),
+};
+
+static int __init
+qla2100_init(void)
+{
+	return pci_module_init(&qla2100_pci_driver);
+}
+
+static void __exit
+qla2100_exit(void)
+{
+	pci_unregister_driver(&qla2100_pci_driver);
+}
+
+module_init(qla2100_init);
+module_exit(qla2100_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP21xx FC-SCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2100_fw.c linux-2.5/drivers/scsi/qla2xxx/ql2100_fw.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2100_fw.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2100_fw.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,4858 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ *************************************************************************/
+
+/*
+ *	Firmware Version 1.19.24 (14:02 Jul 16, 2002)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_version = 1*1024+19;
+#else
+unsigned short risc_code_version = 1*1024+19;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2100tp_version_str[] = {1,19,24};
+#else
+unsigned char firmware_version[] = {1,19,24};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2100tp_VERSION_STRING "1.19.24"
+#else
+#define FW_VERSION_STRING "1.19.24"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_addr01 = 0x1000 ;
+#else
+unsigned short risc_code_addr01 = 0x1000 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0078, 0x102d, 0x0000, 0x95f1, 0x0000, 0x0001, 0x0013, 0x0018,
+	0x0017, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2032, 0x3030,
+	0x3120, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3231, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x312e, 0x3139, 0x2020, 0x2020, 0x2400, 0x2091, 0x2000, 0x20c1,
+	0x0021, 0x2039, 0xffff, 0x2019, 0xaaaa, 0x2760, 0x2069, 0x7fff,
+	0x20c1, 0x0020, 0x2c2c, 0x2d34, 0x2762, 0x236a, 0x2c24, 0x2d04,
+	0x266a, 0x2562, 0xa406, 0x00c0, 0x1052, 0x20c1, 0x0021, 0x2c2c,
+	0x2362, 0x2c04, 0x2562, 0xa306, 0x0040, 0x1052, 0x20c1, 0x0020,
+	0x2039, 0x8fff, 0x20a1, 0xad00, 0x2708, 0x810d, 0x810d, 0x810d,
+	0x810d, 0xa18c, 0x000f, 0x2001, 0x000a, 0xa112, 0xa00e, 0x21a8,
+	0x41a4, 0x3400, 0x8211, 0x00c0, 0x105f, 0x2708, 0x3400, 0xa102,
+	0x0040, 0x106f, 0x0048, 0x106f, 0x20a8, 0xa00e, 0x41a4, 0x20a1,
+	0xa5f1, 0x2009, 0x0000, 0x20a9, 0x070f, 0x41a4, 0x3400, 0x20c9,
+	0xaaff, 0x2059, 0x0000, 0x2b78, 0x7823, 0x0004, 0x2089, 0x25c7,
+	0x2051, 0xa600, 0x2a70, 0x7762, 0xa786, 0x8fff, 0x0040, 0x1092,
+	0x705f, 0xcd00, 0x705b, 0xccf1, 0x7067, 0x0200, 0x706b, 0x0200,
+	0x0078, 0x109a, 0x705b, 0xbd01, 0x7067, 0x0100, 0x706b, 0x0100,
+	0x705f, 0xbd00, 0x1078, 0x12df, 0x1078, 0x13ca, 0x1078, 0x1577,
+	0x1078, 0x1ce9, 0x1078, 0x42ec, 0x1078, 0x76bf, 0x1078, 0x1355,
+	0x1078, 0x2ac0, 0x1078, 0x4e93, 0x1078, 0x49a3, 0x1078, 0x594a,
+	0x1078, 0x2263, 0x1078, 0x5c43, 0x1078, 0x5485, 0x1078, 0x2162,
+	0x1078, 0x2240, 0x2091, 0x3009, 0x7823, 0x0000, 0x0090, 0x10cf,
+	0x7820, 0xa086, 0x0002, 0x00c0, 0x10cf, 0x7823, 0x4000, 0x0068,
+	0x10c7, 0x781b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2a70,
+	0x7003, 0x0000, 0x2001, 0x017f, 0x2003, 0x0000, 0x2a70, 0x7000,
+	0xa08e, 0x0003, 0x00c0, 0x10ef, 0x1078, 0x365e, 0x1078, 0x2ae8,
+	0x1078, 0x4ee3, 0x1078, 0x4b66, 0x2009, 0x0100, 0x2104, 0xa082,
+	0x0002, 0x0048, 0x10f3, 0x1078, 0x5966, 0x0078, 0x10d6, 0x1079,
+	0x10f7, 0x0078, 0x10dc, 0x1078, 0x7197, 0x0078, 0x10eb, 0x1101,
+	0x1102, 0x11be, 0x10ff, 0x1246, 0x12dc, 0x12dd, 0x12de, 0x1078,
+	0x1332, 0x007c, 0x127e, 0x0f7e, 0x2091, 0x8000, 0x7000, 0xa086,
+	0x0001, 0x00c0, 0x1198, 0x1078, 0x3aec, 0x2079, 0x0100, 0x7844,
+	0xa005, 0x00c0, 0x1198, 0x2011, 0x41dc, 0x1078, 0x5a45, 0x1078,
+	0x1adf, 0x780f, 0x00ff, 0x7840, 0xa084, 0xfffb, 0x7842, 0x2011,
+	0x8010, 0x73c4, 0x1078, 0x361b, 0x2001, 0xffff, 0x1078, 0x5ae6,
+	0x723c, 0xc284, 0x723e, 0x2001, 0xa60c, 0x2014, 0xc2ac, 0x2202,
+	0x1078, 0x6f9f, 0x2011, 0x0004, 0x1078, 0x8d1b, 0x1078, 0x489e,
+	0x1078, 0x42d4, 0x0040, 0x1144, 0x7087, 0x0001, 0x70bf, 0x0000,
+	0x1078, 0x3c9e, 0x0078, 0x1198, 0x1078, 0x4967, 0x0040, 0x114d,
+	0x7a0c, 0xc2b4, 0x7a0e, 0x0078, 0x1159, 0x1078, 0x90a6, 0x70cc,
+	0xd09c, 0x00c0, 0x1159, 0x7098, 0xa005, 0x0040, 0x1159, 0x1078,
+	0x42b8, 0x70d7, 0x0000, 0x70d3, 0x0000, 0x72cc, 0x2079, 0xa652,
+	0x7804, 0xd0ac, 0x0040, 0x1165, 0xc295, 0x72ce, 0xa296, 0x0004,
+	0x0040, 0x1186, 0x2011, 0x0001, 0x1078, 0x8d1b, 0x7093, 0x0000,
+	0x7097, 0xffff, 0x7003, 0x0002, 0x0f7f, 0x1078, 0x2677, 0x2011,
+	0x0005, 0x1078, 0x70e0, 0x1078, 0x62d1, 0x0c7e, 0x2061, 0x0100,
+	0x60e3, 0x0008, 0x0c7f, 0x127f, 0x0078, 0x119a, 0x7093, 0x0000,
+	0x7097, 0xffff, 0x7003, 0x0002, 0x2011, 0x0005, 0x1078, 0x70e0,
+	0x1078, 0x62d1, 0x0c7e, 0x2061, 0x0100, 0x60e3, 0x0008, 0x0c7f,
+	0x0f7f, 0x127f, 0x007c, 0x0c7e, 0x20a9, 0x0082, 0x2009, 0x007e,
+	0x017e, 0x027e, 0x037e, 0x2110, 0x027e, 0x2019, 0x0029, 0x1078,
+	0x73d0, 0x027f, 0x1078, 0xa4f1, 0x037f, 0x027f, 0x017f, 0x1078,
+	0x298e, 0x8108, 0x00f0, 0x11a0, 0x0c7f, 0x706f, 0x0000, 0x7070,
+	0xa084, 0x00ff, 0x7072, 0x709b, 0x0000, 0x007c, 0x127e, 0x2091,
+	0x8000, 0x7000, 0xa086, 0x0002, 0x00c0, 0x1244, 0x7094, 0xa086,
+	0xffff, 0x0040, 0x11d1, 0x1078, 0x2677, 0x1078, 0x62d1, 0x0078,
+	0x1244, 0x70cc, 0xd09c, 0x0040, 0x11fd, 0xd084, 0x0040, 0x11fd,
+	0x0f7e, 0x2079, 0x0100, 0x790c, 0xc1b5, 0x790e, 0x0f7f, 0xd08c,
+	0x0040, 0x11fd, 0x70d0, 0xa086, 0xffff, 0x0040, 0x11f9, 0x1078,
+	0x27f7, 0x1078, 0x62d1, 0x70cc, 0xd094, 0x00c0, 0x1244, 0x2011,
+	0x0001, 0x2019, 0x0000, 0x1078, 0x282f, 0x1078, 0x62d1, 0x0078,
+	0x1244, 0x70d4, 0xa005, 0x00c0, 0x1244, 0x7090, 0xa005, 0x00c0,
+	0x1244, 0x1078, 0x4967, 0x00c0, 0x1244, 0x2001, 0xa653, 0x2004,
+	0xd0ac, 0x0040, 0x1227, 0x157e, 0x0c7e, 0x20a9, 0x007f, 0x2009,
+	0x0000, 0x017e, 0x1078, 0x45c4, 0x00c0, 0x121a, 0x6000, 0xd0ec,
+	0x00c0, 0x1222, 0x017f, 0x8108, 0x00f0, 0x1211, 0x0c7f, 0x157f,
+	0x0078, 0x1227, 0x017f, 0x0c7f, 0x157f, 0x0078, 0x1244, 0x7003,
+	0x0003, 0x7097, 0xffff, 0x2001, 0x0000, 0x1078, 0x24e8, 0x1078,
+	0x3699, 0x2001, 0xa8b2, 0x2004, 0xa086, 0x0005, 0x00c0, 0x123c,
+	0x2011, 0x0000, 0x1078, 0x70e0, 0x2011, 0x0000, 0x1078, 0x70ea,
+	0x1078, 0x62d1, 0x1078, 0x639b, 0x127f, 0x007c, 0x017e, 0x0f7e,
+	0x127e, 0x2091, 0x8000, 0x2079, 0x0100, 0x2009, 0x00f7, 0x1078,
+	0x42a1, 0x7940, 0xa18c, 0x0010, 0x7942, 0x7924, 0xd1b4, 0x0040,
+	0x125b, 0x7827, 0x0040, 0xd19c, 0x0040, 0x1260, 0x7827, 0x0008,
+	0x007e, 0x037e, 0x157e, 0xa006, 0x1078, 0x5ae6, 0x7900, 0xa18a,
+	0x0003, 0x0050, 0x1289, 0x7954, 0xd1ac, 0x00c0, 0x1289, 0x2009,
+	0x00f8, 0x1078, 0x42a1, 0x7843, 0x0090, 0x7843, 0x0010, 0x20a9,
+	0x09c4, 0x7820, 0xd09c, 0x00c0, 0x1281, 0x7824, 0xd0ac, 0x00c0,
+	0x12ca, 0x00f0, 0x1279, 0x2001, 0x0001, 0x1078, 0x24e8, 0x0078,
+	0x12d5, 0x7853, 0x0000, 0x782f, 0x0020, 0x20a9, 0x0050, 0x00e0,
+	0x128f, 0x2091, 0x6000, 0x00f0, 0x128f, 0x7853, 0x0400, 0x782f,
+	0x0000, 0x2009, 0x00f8, 0x1078, 0x42a1, 0x20a9, 0x000e, 0x0005,
+	0x00f0, 0x129f, 0x7853, 0x1400, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x2019, 0x61a8, 0x7854, 0x0005, 0x0005, 0xd08c, 0x0040, 0x12b4,
+	0x7824, 0xd0ac, 0x00c0, 0x12ca, 0x8319, 0x00c0, 0x12aa, 0x2009,
+	0xa632, 0x2104, 0x8000, 0x200a, 0xa084, 0xfff0, 0x0040, 0x12c4,
+	0x200b, 0x0000, 0x1078, 0x2588, 0x2001, 0x0001, 0x1078, 0x24e8,
+	0x0078, 0x12d3, 0x2001, 0xa632, 0x2003, 0x0000, 0x7828, 0xc09d,
+	0x782a, 0x7827, 0x0048, 0x7853, 0x0400, 0x157f, 0x037f, 0x007f,
+	0x127f, 0x0f7f, 0x017f, 0x007c, 0x007c, 0x007c, 0x007c, 0x2a70,
+	0x2061, 0xa8ad, 0x2063, 0x0001, 0x6007, 0x0013, 0x600b, 0x0018,
+	0x600f, 0x0017, 0x2009, 0x0100, 0x2104, 0xa082, 0x0002, 0x0048,
+	0x12f5, 0x7053, 0xffff, 0x0078, 0x12f7, 0x7053, 0x0000, 0x7057,
+	0xffff, 0x706f, 0x0000, 0x7073, 0x0000, 0x1078, 0x90a6, 0x2061,
+	0xa88d, 0x6003, 0x0909, 0x6007, 0x0000, 0x600b, 0x8800, 0x600f,
+	0x0200, 0x6013, 0x00ff, 0x6017, 0x0003, 0x601b, 0x0000, 0x601f,
+	0x07d0, 0x2061, 0xa895, 0x6003, 0x8000, 0x6007, 0x0000, 0x600b,
+	0x0000, 0x600f, 0x0200, 0x6013, 0x00ff, 0x6017, 0x0000, 0x601b,
+	0x0001, 0x601f, 0x0000, 0x2061, 0xa8a5, 0x6003, 0x514c, 0x6007,
+	0x4f47, 0x600b, 0x4943, 0x600f, 0x2020, 0x2001, 0xa626, 0x2003,
+	0x0000, 0x007c, 0x2091, 0x8000, 0x0068, 0x1334, 0x007e, 0x017e,
+	0x2079, 0x0000, 0x7818, 0xd084, 0x00c0, 0x133a, 0x017f, 0x792e,
+	0x007f, 0x782a, 0x007f, 0x7826, 0x3900, 0x783a, 0x7823, 0x8002,
+	0x781b, 0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2079, 0xa600,
+	0x7803, 0x0005, 0x0078, 0x1352, 0x007c, 0x2071, 0xa600, 0x715c,
+	0x712e, 0x2021, 0x0001, 0xa190, 0x002d, 0xa298, 0x002d, 0x0048,
+	0x136b, 0x7060, 0xa302, 0x00c8, 0x136b, 0x220a, 0x2208, 0x2310,
+	0x8420, 0x0078, 0x135d, 0x200b, 0x0000, 0x74aa, 0x74ae, 0x007c,
+	0x0e7e, 0x127e, 0x2091, 0x8000, 0x2071, 0xa600, 0x70ac, 0xa0ea,
+	0x0010, 0x00c8, 0x137e, 0xa06e, 0x0078, 0x1388, 0x8001, 0x70ae,
+	0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807, 0x0000,
+	0x127f, 0x0e7f, 0x007c, 0x0e7e, 0x2071, 0xa600, 0x127e, 0x2091,
+	0x8000, 0x70ac, 0x8001, 0x00c8, 0x1398, 0xa06e, 0x0078, 0x13a1,
+	0x70ae, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000, 0x6807,
+	0x0000, 0x127f, 0x0e7f, 0x007c, 0x0e7e, 0x127e, 0x2091, 0x8000,
+	0x2071, 0xa600, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70ac, 0x8000,
+	0x70ae, 0x127f, 0x0e7f, 0x007c, 0x8dff, 0x0040, 0x13c0, 0x6804,
+	0x6807, 0x0000, 0x007e, 0x1078, 0x13a4, 0x0d7f, 0x0078, 0x13b4,
+	0x007c, 0x0e7e, 0x2071, 0xa600, 0x70ac, 0xa08a, 0x0010, 0xa00d,
+	0x0e7f, 0x007c, 0x0e7e, 0x2071, 0xa8d6, 0x7007, 0x0000, 0x701b,
+	0x0000, 0x701f, 0x0000, 0x2071, 0x0000, 0x7010, 0xa085, 0x8004,
+	0x7012, 0x0e7f, 0x007c, 0x127e, 0x2091, 0x8000, 0x0e7e, 0x2270,
+	0x700b, 0x0000, 0x2071, 0xa8d6, 0x7018, 0xa088, 0xa8df, 0x220a,
+	0x8000, 0xa084, 0x0007, 0x701a, 0x7004, 0xa005, 0x00c0, 0x13f6,
+	0x0f7e, 0x2079, 0x0010, 0x1078, 0x1408, 0x0f7f, 0x0e7f, 0x127f,
+	0x007c, 0x0e7e, 0x2071, 0xa8d6, 0x7004, 0xa005, 0x00c0, 0x1406,
+	0x0f7e, 0x2079, 0x0010, 0x1078, 0x1408, 0x0f7f, 0x0e7f, 0x007c,
+	0x7000, 0x0079, 0x140b, 0x140f, 0x1479, 0x1496, 0x1496, 0x7018,
+	0x711c, 0xa106, 0x00c0, 0x1417, 0x7007, 0x0000, 0x007c, 0x0d7e,
+	0xa180, 0xa8df, 0x2004, 0x700a, 0x2068, 0x8108, 0xa18c, 0x0007,
+	0x711e, 0x7803, 0x0026, 0x6824, 0x7832, 0x6828, 0x7836, 0x682c,
+	0x783a, 0x6830, 0x783e, 0x6810, 0x700e, 0x680c, 0x7016, 0x6804,
+	0x0d7f, 0xd084, 0x0040, 0x1439, 0x7007, 0x0001, 0x1078, 0x143e,
+	0x007c, 0x7007, 0x0002, 0x1078, 0x1454, 0x007c, 0x017e, 0x027e,
+	0x710c, 0x2011, 0x0040, 0xa182, 0x0040, 0x00c8, 0x1449, 0x2110,
+	0xa006, 0x700e, 0x7212, 0x8203, 0x7822, 0x7803, 0x0020, 0x7803,
+	0x0041, 0x027f, 0x017f, 0x007c, 0x017e, 0x027e, 0x137e, 0x147e,
+	0x157e, 0x7014, 0x2098, 0x20a1, 0x0014, 0x7803, 0x0026, 0x710c,
+	0x2011, 0x0040, 0xa182, 0x0040, 0x00c8, 0x1468, 0x2110, 0xa006,
+	0x700e, 0x22a8, 0x53a6, 0x8203, 0x7822, 0x7803, 0x0020, 0x3300,
+	0x7016, 0x7803, 0x0001, 0x157f, 0x147f, 0x137f, 0x027f, 0x017f,
+	0x007c, 0x137e, 0x147e, 0x157e, 0x2099, 0xa6fa, 0x20a1, 0x0018,
+	0x20a9, 0x0008, 0x53a3, 0x7803, 0x0020, 0x127e, 0x2091, 0x8000,
+	0x7803, 0x0041, 0x7007, 0x0003, 0x7000, 0xc084, 0x7002, 0x700b,
+	0xa6f5, 0x127f, 0x157f, 0x147f, 0x137f, 0x007c, 0x137e, 0x147e,
+	0x157e, 0x2001, 0xa729, 0x209c, 0x20a1, 0x0014, 0x7803, 0x0026,
+	0x2001, 0xa72a, 0x20ac, 0x53a6, 0x2099, 0xa72b, 0x20a1, 0x0018,
+	0x20a9, 0x0008, 0x53a3, 0x7803, 0x0020, 0x127e, 0x2091, 0x8000,
+	0x7803, 0x0001, 0x7007, 0x0004, 0x7000, 0xc08c, 0x7002, 0x700b,
+	0xa726, 0x127f, 0x157f, 0x147f, 0x137f, 0x007c, 0x017e, 0x0e7e,
+	0x2071, 0xa8d6, 0x0f7e, 0x2079, 0x0010, 0x7904, 0x7803, 0x0002,
+	0xd1fc, 0x0040, 0x14d0, 0xa18c, 0x0700, 0x7004, 0x1079, 0x14d4,
+	0x0f7f, 0x0e7f, 0x017f, 0x007c, 0x1408, 0x14dc, 0x1509, 0x1531,
+	0x1564, 0x14da, 0x0078, 0x14da, 0xa18c, 0x0700, 0x00c0, 0x1502,
+	0x137e, 0x147e, 0x157e, 0x7014, 0x20a0, 0x2099, 0x0014, 0x7803,
+	0x0040, 0x7010, 0x20a8, 0x53a5, 0x3400, 0x7016, 0x157f, 0x147f,
+	0x137f, 0x700c, 0xa005, 0x0040, 0x151e, 0x1078, 0x143e, 0x007c,
+	0x7008, 0xa080, 0x0002, 0x2003, 0x0100, 0x7007, 0x0000, 0x1078,
+	0x1408, 0x007c, 0x7008, 0xa080, 0x0002, 0x2003, 0x0200, 0x0078,
+	0x14fd, 0xa18c, 0x0700, 0x00c0, 0x1514, 0x700c, 0xa005, 0x0040,
+	0x151e, 0x1078, 0x1454, 0x007c, 0x7008, 0xa080, 0x0002, 0x2003,
+	0x0200, 0x7007, 0x0000, 0x1078, 0x1408, 0x007c, 0x0d7e, 0x7008,
+	0x2068, 0x7830, 0x6826, 0x7834, 0x682a, 0x7838, 0x682e, 0x783c,
+	0x6832, 0x680b, 0x0100, 0x0d7f, 0x7007, 0x0000, 0x1078, 0x1408,
+	0x007c, 0xa18c, 0x0700, 0x00c0, 0x155e, 0x137e, 0x147e, 0x157e,
+	0x2001, 0xa6f8, 0x2004, 0xa080, 0x000d, 0x20a0, 0x2099, 0x0014,
+	0x7803, 0x0040, 0x20a9, 0x0020, 0x53a5, 0x2001, 0xa6fa, 0x2004,
+	0xd0bc, 0x0040, 0x1554, 0x2001, 0xa703, 0x2004, 0xa080, 0x000d,
+	0x20a0, 0x20a9, 0x0020, 0x53a5, 0x157f, 0x147f, 0x137f, 0x7007,
+	0x0000, 0x1078, 0x4f8c, 0x1078, 0x1408, 0x007c, 0x2011, 0x8003,
+	0x1078, 0x361b, 0x0078, 0x1562, 0xa18c, 0x0700, 0x00c0, 0x1571,
+	0x2001, 0xa728, 0x2003, 0x0100, 0x7007, 0x0000, 0x1078, 0x1408,
+	0x007c, 0x2011, 0x8004, 0x1078, 0x361b, 0x0078, 0x1575, 0x127e,
+	0x2091, 0x2100, 0x2079, 0x0030, 0x2071, 0xa8e7, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x700f, 0xa8ed, 0x7013, 0xa8ed, 0x780f, 0x0076,
+	0x7803, 0x0004, 0x127f, 0x007c, 0x6934, 0xa184, 0x0007, 0x0079,
+	0x1591, 0x1599, 0x15df, 0x1599, 0x1599, 0x1599, 0x15c4, 0x15a8,
+	0x159d, 0xa085, 0x0001, 0x0078, 0x15f9, 0x684c, 0xd0bc, 0x0040,
+	0x1599, 0x6860, 0x682e, 0x685c, 0x682a, 0x6858, 0x0078, 0x15e7,
+	0xa18c, 0x00ff, 0xa186, 0x001e, 0x00c0, 0x1599, 0x684c, 0xd0bc,
+	0x0040, 0x1599, 0x6860, 0x682e, 0x685c, 0x682a, 0x6804, 0x681a,
+	0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x206a, 0x2004,
+	0x6832, 0x6858, 0x0078, 0x15ef, 0xa18c, 0x00ff, 0xa186, 0x0015,
+	0x00c0, 0x1599, 0x684c, 0xd0ac, 0x0040, 0x1599, 0x6804, 0x681a,
+	0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x206a, 0x2004,
+	0x6832, 0xa006, 0x682e, 0x682a, 0x6858, 0x0078, 0x15ef, 0x684c,
+	0xd0ac, 0x0040, 0x1599, 0xa006, 0x682e, 0x682a, 0x6858, 0xa18c,
+	0x000f, 0xa188, 0x206a, 0x210c, 0x6932, 0x2d08, 0x691a, 0x6826,
+	0x684c, 0xc0dd, 0x684e, 0xa006, 0x680a, 0x697c, 0x6912, 0x6980,
+	0x6916, 0x007c, 0x20e1, 0x0007, 0x20e1, 0x2000, 0x2001, 0x020a,
+	0x2004, 0x82ff, 0x0040, 0x161c, 0xa280, 0x0004, 0x0d7e, 0x206c,
+	0x684c, 0xd0dc, 0x00c0, 0x1618, 0x1078, 0x158c, 0x0040, 0x1618,
+	0x0d7f, 0xa280, 0x0000, 0x2003, 0x0002, 0xa016, 0x0078, 0x161c,
+	0x6808, 0x8000, 0x680a, 0x0d7f, 0x127e, 0x047e, 0x037e, 0x027e,
+	0x2091, 0x2100, 0x027f, 0x037f, 0x047f, 0x7000, 0xa005, 0x00c0,
+	0x1630, 0x7206, 0x2001, 0x1651, 0x007e, 0x2260, 0x0078, 0x17e0,
+	0x710c, 0x220a, 0x8108, 0x230a, 0x8108, 0x240a, 0x8108, 0xa182,
+	0xa908, 0x0048, 0x163d, 0x2009, 0xa8ed, 0x710e, 0x7010, 0xa102,
+	0xa082, 0x0009, 0x0040, 0x1648, 0xa080, 0x001b, 0x00c0, 0x164b,
+	0x2009, 0x0138, 0x200a, 0x7000, 0xa005, 0x00c0, 0x1651, 0x1078,
+	0x17c1, 0x127f, 0x007c, 0x127e, 0x027e, 0x037e, 0x0c7e, 0x007e,
+	0x2091, 0x2100, 0x007f, 0x047f, 0x037f, 0x027f, 0x0d7e, 0x0c7e,
+	0x2460, 0x6110, 0x2168, 0x6a62, 0x6b5e, 0xa005, 0x0040, 0x16dd,
+	0x6808, 0xa005, 0x0040, 0x174a, 0x7000, 0xa005, 0x00c0, 0x1672,
+	0x0078, 0x16d2, 0x700c, 0x7110, 0xa106, 0x00c0, 0x1753, 0x7004,
+	0xa406, 0x00c0, 0x16d2, 0x2001, 0x0005, 0x2004, 0xd08c, 0x0040,
+	0x168f, 0x047e, 0x1078, 0x1913, 0x047f, 0x2460, 0x6010, 0xa080,
+	0x0002, 0x2004, 0xa005, 0x0040, 0x174a, 0x0078, 0x166c, 0x2001,
+	0x0207, 0x2004, 0xd09c, 0x00c0, 0x167b, 0x7804, 0xa084, 0x6000,
+	0x0040, 0x16a0, 0xa086, 0x6000, 0x0040, 0x16a0, 0x0078, 0x167b,
+	0x7100, 0xa186, 0x0002, 0x00c0, 0x16c0, 0x0e7e, 0x2b68, 0x6818,
+	0x2060, 0x1078, 0x203f, 0x2804, 0xac70, 0x6034, 0xd09c, 0x00c0,
+	0x16b5, 0x7108, 0x720c, 0x0078, 0x16b7, 0x7110, 0x7214, 0x6810,
+	0xa100, 0x6812, 0x6814, 0xa201, 0x6816, 0x0e7f, 0x0078, 0x16c4,
+	0xa186, 0x0001, 0x00c0, 0x16cc, 0x7820, 0x6910, 0xa100, 0x6812,
+	0x7824, 0x6914, 0xa101, 0x6816, 0x7803, 0x0004, 0x7003, 0x0000,
+	0x7004, 0x2060, 0x6100, 0xa18e, 0x0004, 0x00c0, 0x1753, 0x2009,
+	0x0048, 0x1078, 0x775c, 0x0078, 0x1753, 0x6808, 0xa005, 0x0040,
+	0x174a, 0x7000, 0xa005, 0x00c0, 0x16e7, 0x0078, 0x174a, 0x700c,
+	0x7110, 0xa106, 0x00c0, 0x16f0, 0x7004, 0xa406, 0x00c0, 0x174a,
+	0x2001, 0x0005, 0x2004, 0xd08c, 0x0040, 0x1704, 0x047e, 0x1078,
+	0x1913, 0x047f, 0x2460, 0x6010, 0xa080, 0x0002, 0x2004, 0xa005,
+	0x0040, 0x174a, 0x0078, 0x16e1, 0x2001, 0x0207, 0x2004, 0xd09c,
+	0x00c0, 0x16f0, 0x2001, 0x0005, 0x2004, 0xd08c, 0x00c0, 0x16f6,
+	0x7804, 0xa084, 0x6000, 0x0040, 0x171b, 0xa086, 0x6000, 0x0040,
+	0x171b, 0x0078, 0x16f0, 0x7007, 0x0000, 0xa016, 0x2218, 0x7000,
+	0xa08e, 0x0001, 0x0040, 0x173c, 0xa08e, 0x0002, 0x00c0, 0x174a,
+	0x0c7e, 0x0e7e, 0x6818, 0x2060, 0x1078, 0x203f, 0x2804, 0xac70,
+	0x6034, 0xd09c, 0x00c0, 0x1738, 0x7308, 0x720c, 0x0078, 0x173a,
+	0x7310, 0x7214, 0x0e7f, 0x0c7f, 0x7820, 0xa318, 0x7824, 0xa211,
+	0x6810, 0xa300, 0x6812, 0x6814, 0xa201, 0x6816, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x6100, 0xa18e, 0x0004, 0x00c0, 0x1753, 0x2009,
+	0x0048, 0x1078, 0x775c, 0x0c7f, 0x0d7f, 0x127f, 0x007c, 0x0f7e,
+	0x0e7e, 0x027e, 0x037e, 0x047e, 0x057e, 0x2071, 0xa8e7, 0x7000,
+	0xa086, 0x0000, 0x0040, 0x17ba, 0x7004, 0xac06, 0x00c0, 0x17ab,
+	0x2079, 0x0030, 0x7000, 0xa086, 0x0003, 0x0040, 0x17ab, 0x7804,
+	0xd0fc, 0x00c0, 0x17a7, 0x20e1, 0x6000, 0x2011, 0x0032, 0x2001,
+	0x0208, 0x200c, 0x2001, 0x0209, 0x2004, 0xa106, 0x00c0, 0x176f,
+	0x8211, 0x00c0, 0x1777, 0x7804, 0xd0fc, 0x00c0, 0x17a7, 0x1078,
+	0x1b22, 0x027e, 0x057e, 0x7803, 0x0004, 0x7804, 0xd0ac, 0x00c0,
+	0x178d, 0x7803, 0x0002, 0x7803, 0x0009, 0x7003, 0x0003, 0x7007,
+	0x0000, 0x057f, 0x027f, 0x2001, 0x015d, 0x2003, 0x0000, 0x2001,
+	0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x0078, 0x17ab, 0x1078,
+	0x1913, 0x0078, 0x175f, 0x157e, 0x20a9, 0x0009, 0x2009, 0xa8ed,
+	0x2104, 0xac06, 0x00c0, 0x17b5, 0x200a, 0xa188, 0x0003, 0x00f0,
+	0x17b0, 0x157f, 0x057f, 0x047f, 0x037f, 0x027f, 0x0e7f, 0x0f7f,
+	0x007c, 0x700c, 0x7110, 0xa106, 0x00c0, 0x17c9, 0x7003, 0x0000,
+	0x007c, 0x2104, 0x7006, 0x2060, 0x8108, 0x211c, 0x8108, 0x2124,
+	0x8108, 0xa182, 0xa908, 0x0048, 0x17d7, 0x2009, 0xa8ed, 0x7112,
+	0x700c, 0xa106, 0x00c0, 0x17e0, 0x2001, 0x0138, 0x2003, 0x0008,
+	0x8cff, 0x00c0, 0x17e7, 0x1078, 0x1b4d, 0x0078, 0x1854, 0x6010,
+	0x2068, 0x2d58, 0x6828, 0xa406, 0x00c0, 0x17f2, 0x682c, 0xa306,
+	0x0040, 0x182f, 0x601c, 0xa086, 0x0008, 0x0040, 0x182f, 0x6024,
+	0xd0f4, 0x00c0, 0x181c, 0xd0d4, 0x0040, 0x1818, 0x6038, 0xa402,
+	0x6034, 0xa303, 0x0040, 0x1806, 0x00c8, 0x1818, 0x643a, 0x6336,
+	0x6c2a, 0x6b2e, 0x047e, 0x037e, 0x2400, 0x6c7c, 0xa402, 0x6812,
+	0x2300, 0x6b80, 0xa303, 0x6816, 0x037f, 0x047f, 0x0078, 0x181c,
+	0x1078, 0x9053, 0x0040, 0x17e3, 0x2001, 0xa674, 0x2004, 0xd0b4,
+	0x00c0, 0x182b, 0x6018, 0x2004, 0xd0bc, 0x00c0, 0x182b, 0x6817,
+	0x7fff, 0x6813, 0xffff, 0x1078, 0x208a, 0x00c0, 0x17e3, 0x0c7e,
+	0x7004, 0x2060, 0x6024, 0xc0d4, 0x6026, 0x0c7f, 0x684c, 0xd0f4,
+	0x0040, 0x1840, 0x6817, 0xffff, 0x6813, 0xffff, 0x0078, 0x17e3,
+	0x6824, 0x2050, 0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc,
+	0x000f, 0x2009, 0x0011, 0x1078, 0x1855, 0x0040, 0x1853, 0x2009,
+	0x0001, 0x1078, 0x1855, 0x2d58, 0x007c, 0x8aff, 0x0040, 0x18ec,
+	0xa03e, 0x2730, 0x6850, 0xd0fc, 0x00c0, 0x1877, 0xd0f4, 0x00c0,
+	0x1887, 0x0d7e, 0x2804, 0xac68, 0x2900, 0x0079, 0x1867, 0x18ce,
+	0x188e, 0x188e, 0x18ce, 0x18ce, 0x18c6, 0x18ce, 0x188e, 0x18ce,
+	0x1894, 0x1894, 0x18ce, 0x18ce, 0x18ce, 0x18bd, 0x1894, 0xc0fc,
+	0x6852, 0x6b6c, 0x6a70, 0x6d1c, 0x6c20, 0x0d7e, 0xd99c, 0x0040,
+	0x18d1, 0x2804, 0xac68, 0x6f08, 0x6e0c, 0x0078, 0x18d1, 0xc0f4,
+	0x6852, 0x6b6c, 0x6a70, 0x0d7e, 0x0078, 0x18d8, 0x6b08, 0x6a0c,
+	0x6d00, 0x6c04, 0x0078, 0x18d1, 0x7b0c, 0xd3bc, 0x0040, 0x18b5,
+	0x7004, 0x0e7e, 0x2070, 0x701c, 0x0e7f, 0xa086, 0x0008, 0x00c0,
+	0x18b5, 0x7b08, 0xa39c, 0x0fff, 0x2d20, 0x0d7f, 0x0d7e, 0x6a14,
+	0x82ff, 0x00c0, 0x18b0, 0x6810, 0xa302, 0x0048, 0x18b0, 0x6b10,
+	0x2011, 0x0000, 0x2468, 0x0078, 0x18b7, 0x6b10, 0x6a14, 0x6d00,
+	0x6c04, 0x6f08, 0x6e0c, 0x0078, 0x18d1, 0x0d7f, 0x0d7e, 0x6834,
+	0xa084, 0x00ff, 0xa086, 0x001e, 0x00c0, 0x18ce, 0x0d7f, 0x1078,
+	0x2026, 0x00c0, 0x1855, 0xa00e, 0x0078, 0x18ec, 0x0d7f, 0x1078,
+	0x1332, 0x7b22, 0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e, 0x7902,
+	0x7000, 0x8000, 0x7002, 0x0d7f, 0x6828, 0xa300, 0x682a, 0x682c,
+	0xa201, 0x682e, 0x2300, 0x6b10, 0xa302, 0x6812, 0x2200, 0x6a14,
+	0xa203, 0x6816, 0x1078, 0x2026, 0x007c, 0x1078, 0x1332, 0x1078,
+	0x1c97, 0x7004, 0x2060, 0x0d7e, 0x6010, 0x2068, 0x7003, 0x0000,
+	0x1078, 0x1af4, 0x1078, 0x8d06, 0x0040, 0x190c, 0x6808, 0x8001,
+	0x680a, 0x697c, 0x6912, 0x6980, 0x6916, 0x682b, 0xffff, 0x682f,
+	0xffff, 0x6850, 0xc0bd, 0x6852, 0x0d7f, 0x1078, 0x8a01, 0x0078,
+	0x1adb, 0x1078, 0x1332, 0x127e, 0x2091, 0x2100, 0x007e, 0x017e,
+	0x2b68, 0x6818, 0x2060, 0x7904, 0x7803, 0x0002, 0xa184, 0x0700,
+	0x00c0, 0x18ef, 0xa184, 0x0003, 0xa086, 0x0003, 0x0040, 0x1911,
+	0x7000, 0x0079, 0x192b, 0x1933, 0x1935, 0x1a34, 0x1ab2, 0x1ac9,
+	0x1933, 0x1933, 0x1933, 0x1078, 0x1332, 0x8001, 0x7002, 0xa184,
+	0x0880, 0x00c0, 0x194a, 0x8aff, 0x0040, 0x19d4, 0x2009, 0x0001,
+	0x1078, 0x1855, 0x0040, 0x1adb, 0x2009, 0x0001, 0x1078, 0x1855,
+	0x0078, 0x1adb, 0x7803, 0x0004, 0x7003, 0x0000, 0xd1bc, 0x00c0,
+	0x19b2, 0x027e, 0x037e, 0x017e, 0x7808, 0xd0ec, 0x00c0, 0x1962,
+	0x7c20, 0x7d24, 0x7e30, 0x7f34, 0x7803, 0x0009, 0x7003, 0x0004,
+	0x0078, 0x1964, 0x1078, 0x1bd7, 0x017f, 0xd194, 0x0040, 0x196b,
+	0x8aff, 0x0040, 0x19a1, 0x6b28, 0x6a2c, 0x2400, 0x686e, 0xa31a,
+	0x2500, 0x6872, 0xa213, 0x6b2a, 0x6a2e, 0x0c7e, 0x7004, 0x2060,
+	0x6024, 0xd0f4, 0x00c0, 0x197e, 0x633a, 0x6236, 0x0c7f, 0x2400,
+	0x6910, 0xa100, 0x6812, 0x2500, 0x6914, 0xa101, 0x6816, 0x037f,
+	0x027f, 0x2600, 0x681e, 0x2700, 0x6822, 0x1078, 0x203f, 0x2a00,
+	0x6826, 0x2c00, 0x681a, 0x2800, 0x6832, 0x6850, 0xc0fd, 0x6852,
+	0x6808, 0x8001, 0x680a, 0x00c0, 0x19a7, 0x684c, 0xd0e4, 0x0040,
+	0x19a7, 0x7004, 0x2060, 0x2009, 0x0048, 0x1078, 0x775c, 0x7000,
+	0xa086, 0x0004, 0x0040, 0x1adb, 0x7003, 0x0000, 0x1078, 0x17c1,
+	0x0078, 0x1adb, 0x057e, 0x7d0c, 0xd5bc, 0x00c0, 0x19b9, 0x1078,
+	0xa57e, 0x057f, 0x1078, 0x1af4, 0x0f7e, 0x7004, 0x2078, 0x1078,
+	0x4963, 0x0040, 0x19c6, 0x7824, 0xc0f5, 0x7826, 0x0f7f, 0x682b,
+	0xffff, 0x682f, 0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912,
+	0x6980, 0x6916, 0x0078, 0x1adb, 0x7004, 0x0c7e, 0x2060, 0x6024,
+	0x0c7f, 0xd0f4, 0x0040, 0x19e1, 0x6808, 0x8001, 0x680a, 0x0078,
+	0x19f5, 0x684c, 0xc0f5, 0x684e, 0x7814, 0xa005, 0x00c0, 0x19f9,
+	0x7003, 0x0000, 0x6808, 0x8001, 0x680a, 0x00c0, 0x19f5, 0x7004,
+	0x2060, 0x2009, 0x0048, 0x1078, 0x775c, 0x1078, 0x17c1, 0x0078,
+	0x1adb, 0x7814, 0x6910, 0xa102, 0x6812, 0x6914, 0xa183, 0x0000,
+	0x6816, 0x7814, 0x7908, 0xa18c, 0x0fff, 0xa192, 0x0841, 0x00c8,
+	0x18ef, 0xa188, 0x0007, 0x8114, 0x8214, 0x8214, 0xa10a, 0x8104,
+	0x8004, 0x8004, 0xa20a, 0x810b, 0x810b, 0x810b, 0x1078, 0x1b5e,
+	0x7803, 0x0004, 0x780f, 0xffff, 0x7803, 0x0001, 0x7804, 0xd0fc,
+	0x0040, 0x1a1e, 0x7803, 0x0002, 0x7803, 0x0004, 0x780f, 0x0076,
+	0x7004, 0x7007, 0x0000, 0x2060, 0x2009, 0x0048, 0x1078, 0x775c,
+	0x1078, 0x1b92, 0x0040, 0x19f5, 0x8001, 0x7002, 0xd194, 0x0040,
+	0x1a46, 0x7804, 0xd0fc, 0x00c0, 0x191b, 0x8aff, 0x0040, 0x1adb,
+	0x2009, 0x0001, 0x1078, 0x1855, 0x0078, 0x1adb, 0xa184, 0x0880,
+	0x00c0, 0x1a53, 0x8aff, 0x0040, 0x1adb, 0x2009, 0x0001, 0x1078,
+	0x1855, 0x0078, 0x1adb, 0x7803, 0x0004, 0x7003, 0x0000, 0xd1bc,
+	0x00c0, 0x1a93, 0x027e, 0x037e, 0x7808, 0xd0ec, 0x00c0, 0x1a66,
+	0x7803, 0x0009, 0x7003, 0x0004, 0x0078, 0x1a68, 0x1078, 0x1bd7,
+	0x6b28, 0x6a2c, 0x1078, 0x203f, 0x0d7e, 0x0f7e, 0x2d78, 0x2804,
+	0xac68, 0x6034, 0xd09c, 0x00c0, 0x1a83, 0x6808, 0x2008, 0xa31a,
+	0x680c, 0xa213, 0x7810, 0xa100, 0x7812, 0x690c, 0x7814, 0xa101,
+	0x7816, 0x0078, 0x1a8f, 0x6810, 0x2008, 0xa31a, 0x6814, 0xa213,
+	0x7810, 0xa100, 0x7812, 0x6914, 0x7814, 0xa101, 0x7816, 0x0f7f,
+	0x0d7f, 0x0078, 0x196d, 0x057e, 0x7d0c, 0x1078, 0xa57e, 0x057f,
+	0x1078, 0x1af4, 0x0f7e, 0x7004, 0x2078, 0x1078, 0x4963, 0x0040,
+	0x1aa4, 0x7824, 0xc0f5, 0x7826, 0x0f7f, 0x682b, 0xffff, 0x682f,
+	0xffff, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912, 0x6980, 0x6916,
+	0x0078, 0x1adb, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0xa00d,
+	0x0040, 0x1ac5, 0x6808, 0x8001, 0x680a, 0x00c0, 0x1ac5, 0x7004,
+	0x2060, 0x2009, 0x0048, 0x1078, 0x775c, 0x1078, 0x17c1, 0x0078,
+	0x1adb, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060, 0x6010,
+	0xa005, 0x0040, 0x1ac5, 0x2068, 0x6808, 0x8000, 0x680a, 0x6c28,
+	0x6b2c, 0x1078, 0x17e0, 0x017f, 0x007f, 0x127f, 0x007c, 0x127e,
+	0x2091, 0x2100, 0x7000, 0xa086, 0x0003, 0x00c0, 0x1af2, 0x700c,
+	0x7110, 0xa106, 0x0040, 0x1af2, 0x20e1, 0x9028, 0x700f, 0xa8ed,
+	0x7013, 0xa8ed, 0x127f, 0x007c, 0x0c7e, 0x1078, 0x1b22, 0x20e1,
+	0x9028, 0x700c, 0x7110, 0xa106, 0x0040, 0x1b19, 0x2104, 0xa005,
+	0x0040, 0x1b08, 0x2060, 0x6010, 0x2060, 0x6008, 0x8001, 0x600a,
+	0xa188, 0x0003, 0xa182, 0xa908, 0x0048, 0x1b10, 0x2009, 0xa8ed,
+	0x7112, 0x700c, 0xa106, 0x00c0, 0x1af9, 0x2011, 0x0008, 0x0078,
+	0x1af9, 0x2001, 0x015d, 0x2003, 0x0000, 0x2001, 0x0138, 0x2202,
+	0x0c7f, 0x007c, 0x2001, 0x0138, 0x2014, 0x2003, 0x0000, 0x2021,
+	0xb015, 0x2001, 0x0141, 0x201c, 0xd3dc, 0x00c0, 0x1b3f, 0x2001,
+	0x0109, 0x201c, 0xa39c, 0x0048, 0x00c0, 0x1b3f, 0x2001, 0x0111,
+	0x201c, 0x83ff, 0x00c0, 0x1b3f, 0x8421, 0x00c0, 0x1b29, 0x007c,
+	0x2011, 0x0201, 0x2009, 0x003c, 0x2204, 0xa005, 0x00c0, 0x1b4c,
+	0x8109, 0x00c0, 0x1b44, 0x007c, 0x007c, 0x1078, 0x1b40, 0x0040,
+	0x1b55, 0x780c, 0xd0a4, 0x0040, 0x1b5b, 0x1078, 0x1af4, 0xa085,
+	0x0001, 0x0078, 0x1b5d, 0x1078, 0x1b92, 0x007c, 0x0e7e, 0x2071,
+	0x0200, 0x7808, 0xa084, 0xf000, 0xa10d, 0x1078, 0x1b22, 0x2019,
+	0x5000, 0x8319, 0x0040, 0x1b7c, 0x2001, 0xa908, 0x2004, 0xa086,
+	0x0000, 0x0040, 0x1b7c, 0x2001, 0x0021, 0xd0fc, 0x0040, 0x1b69,
+	0x1078, 0x1eaa, 0x0078, 0x1b67, 0x20e1, 0x7000, 0x7324, 0x7420,
+	0x7028, 0x7028, 0x7426, 0x7037, 0x0001, 0x810f, 0x712e, 0x702f,
+	0x0100, 0x7037, 0x0008, 0x7326, 0x7422, 0x2001, 0x0138, 0x2202,
+	0x0e7f, 0x007c, 0x027e, 0x2001, 0x015d, 0x2001, 0x0000, 0x7908,
+	0xa18c, 0x0fff, 0xa182, 0x0ffd, 0x0048, 0x1ba0, 0x2009, 0x0000,
+	0xa190, 0x0007, 0xa294, 0x1ff8, 0x8214, 0x8214, 0x8214, 0x2001,
+	0x020a, 0x82ff, 0x0040, 0x1bb5, 0x20e1, 0x6000, 0x200c, 0x200c,
+	0x200c, 0x200c, 0x8211, 0x00c0, 0x1bae, 0x20e1, 0x7000, 0x200c,
+	0x200c, 0x7003, 0x0000, 0x20e1, 0x6000, 0x2001, 0x0208, 0x200c,
+	0x2001, 0x0209, 0x2004, 0xa106, 0x0040, 0x1bd4, 0x1078, 0x1b40,
+	0x0040, 0x1bd2, 0x7908, 0xd1ec, 0x00c0, 0x1bd4, 0x790c, 0xd1a4,
+	0x0040, 0x1b97, 0x1078, 0x1af4, 0xa006, 0x027f, 0x007c, 0x7c20,
+	0x7d24, 0x7e30, 0x7f34, 0x700c, 0x7110, 0xa106, 0x0040, 0x1c69,
+	0x7004, 0x017e, 0x210c, 0xa106, 0x017f, 0x0040, 0x1c69, 0x0d7e,
+	0x0c7e, 0x216c, 0x2d00, 0xa005, 0x0040, 0x1c67, 0x681c, 0xa086,
+	0x0008, 0x0040, 0x1c67, 0x6824, 0xd0d4, 0x00c0, 0x1c67, 0x6810,
+	0x2068, 0x6850, 0xd0fc, 0x0040, 0x1c29, 0x8108, 0x2104, 0x6b2c,
+	0xa306, 0x00c0, 0x1c67, 0x8108, 0x2104, 0x6a28, 0xa206, 0x00c0,
+	0x1c67, 0x6850, 0xc0fc, 0xc0f5, 0x6852, 0x686c, 0x7822, 0x6870,
+	0x7826, 0x681c, 0x7832, 0x6820, 0x7836, 0x6818, 0x2060, 0x6034,
+	0xd09c, 0x0040, 0x1c24, 0x6830, 0x2004, 0xac68, 0x6808, 0x783a,
+	0x680c, 0x783e, 0x0078, 0x1c65, 0xa006, 0x783a, 0x783e, 0x0078,
+	0x1c65, 0x8108, 0x2104, 0xa005, 0x00c0, 0x1c67, 0x6b2c, 0xa306,
+	0x00c0, 0x1c67, 0x8108, 0x2104, 0xa005, 0x00c0, 0x1c67, 0x6a28,
+	0xa206, 0x00c0, 0x1c67, 0x6850, 0xc0f5, 0x6852, 0x6830, 0x2004,
+	0x6918, 0xa160, 0xa180, 0x000d, 0x2004, 0xd09c, 0x00c0, 0x1c57,
+	0x6008, 0x7822, 0x686e, 0x600c, 0x7826, 0x6872, 0x6000, 0x7832,
+	0x6004, 0x7836, 0xa006, 0x783a, 0x783e, 0x0078, 0x1c65, 0x6010,
+	0x7822, 0x686e, 0x6014, 0x7826, 0x6872, 0x6000, 0x7832, 0x6004,
+	0x7836, 0x6008, 0x783a, 0x600c, 0x783e, 0x7803, 0x0011, 0x0c7f,
+	0x0d7f, 0x007c, 0x0f7e, 0x0e7e, 0x017e, 0x027e, 0x2071, 0xa8e7,
+	0x2079, 0x0030, 0x2011, 0x0050, 0x7000, 0xa086, 0x0000, 0x0040,
+	0x1c92, 0x8211, 0x0040, 0x1c90, 0x2001, 0x0005, 0x2004, 0xd08c,
+	0x0040, 0x1c79, 0x7904, 0xa18c, 0x0780, 0x017e, 0x1078, 0x1913,
+	0x017f, 0x81ff, 0x00c0, 0x1c90, 0x2011, 0x0050, 0x0078, 0x1c74,
+	0xa085, 0x0001, 0x027f, 0x017f, 0x0e7f, 0x0f7f, 0x007c, 0x7803,
+	0x0004, 0x2009, 0x0064, 0x7804, 0xd0ac, 0x0040, 0x1ce8, 0x8109,
+	0x00c0, 0x1c9b, 0x2009, 0x0100, 0x210c, 0xa18a, 0x0003, 0x1048,
+	0x1332, 0x1078, 0x1fca, 0x0e7e, 0x0f7e, 0x2071, 0xa8d6, 0x2079,
+	0x0010, 0x7004, 0xa086, 0x0000, 0x0040, 0x1ce0, 0x7800, 0x007e,
+	0x7820, 0x007e, 0x7830, 0x007e, 0x7834, 0x007e, 0x7838, 0x007e,
+	0x783c, 0x007e, 0x7803, 0x0004, 0x7823, 0x0000, 0x0005, 0x0005,
+	0x2079, 0x0030, 0x7804, 0xd0ac, 0x10c0, 0x1332, 0x2079, 0x0010,
+	0x007f, 0x783e, 0x007f, 0x783a, 0x007f, 0x7836, 0x007f, 0x7832,
+	0x007f, 0x7822, 0x007f, 0x7802, 0x0f7f, 0x0e7f, 0x0078, 0x1ce6,
+	0x0f7f, 0x0e7f, 0x7804, 0xd0ac, 0x10c0, 0x1332, 0x1078, 0x639b,
+	0x007c, 0x0e7e, 0x2071, 0xa908, 0x7003, 0x0000, 0x0e7f, 0x007c,
+	0x0d7e, 0xa280, 0x0004, 0x206c, 0x694c, 0xd1dc, 0x00c0, 0x1d6b,
+	0x6934, 0xa184, 0x0007, 0x0079, 0x1cfd, 0x1d05, 0x1d56, 0x1d05,
+	0x1d05, 0x1d05, 0x1d3b, 0x1d18, 0x1d07, 0x1078, 0x1332, 0x684c,
+	0xd0b4, 0x0040, 0x1e79, 0x6860, 0x682e, 0x6816, 0x685c, 0x682a,
+	0x6812, 0x687c, 0x680a, 0x6880, 0x680e, 0x6958, 0x0078, 0x1d5e,
+	0x6834, 0xa084, 0x00ff, 0xa086, 0x001e, 0x00c0, 0x1d05, 0x684c,
+	0xd0b4, 0x0040, 0x1e79, 0x6860, 0x682e, 0x6816, 0x685c, 0x682a,
+	0x6812, 0x687c, 0x680a, 0x6880, 0x680e, 0x6804, 0x681a, 0xa080,
+	0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x206a, 0x2004, 0x6832,
+	0x6958, 0x0078, 0x1d67, 0xa18c, 0x00ff, 0xa186, 0x0015, 0x00c0,
+	0x1d6b, 0x684c, 0xd0b4, 0x0040, 0x1e79, 0x6804, 0x681a, 0xa080,
+	0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x206a, 0x2004, 0x6832,
+	0x6958, 0xa006, 0x682e, 0x682a, 0x0078, 0x1d67, 0x684c, 0xd0b4,
+	0x0040, 0x18ed, 0x6958, 0xa006, 0x682e, 0x682a, 0x2d00, 0x681a,
+	0x6834, 0xa084, 0x000f, 0xa080, 0x206a, 0x2004, 0x6832, 0x6926,
+	0x684c, 0xc0dd, 0x684e, 0x0d7f, 0x007c, 0x0f7e, 0x2079, 0x0020,
+	0x7804, 0xd0fc, 0x10c0, 0x1eaa, 0x0e7e, 0x0d7e, 0x2071, 0xa908,
+	0x7000, 0xa005, 0x00c0, 0x1df0, 0x0c7e, 0x7206, 0xa280, 0x0004,
+	0x205c, 0x7004, 0x2068, 0x7803, 0x0004, 0x6818, 0x0d7e, 0x2068,
+	0x686c, 0x7812, 0x6890, 0x0f7e, 0x20e1, 0x9040, 0x2079, 0x0200,
+	0x781a, 0x2079, 0x0100, 0x8004, 0x78d6, 0x0f7f, 0x0d7f, 0x2b68,
+	0x6824, 0x2050, 0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc,
+	0x000f, 0x6908, 0x2001, 0x04fd, 0x2004, 0xa086, 0x0007, 0x0040,
+	0x1db2, 0xa184, 0x0007, 0x0040, 0x1db2, 0x017e, 0x2009, 0x0008,
+	0xa102, 0x017f, 0xa108, 0x791a, 0x7116, 0x701e, 0x680c, 0xa081,
+	0x0000, 0x781e, 0x701a, 0xa006, 0x700e, 0x7012, 0x7004, 0x692c,
+	0x6814, 0xa106, 0x00c0, 0x1dc9, 0x6928, 0x6810, 0xa106, 0x0040,
+	0x1dd6, 0x037e, 0x047e, 0x6b14, 0x6c10, 0x1078, 0x208a, 0x047f,
+	0x037f, 0x0040, 0x1dd6, 0x0c7f, 0x0078, 0x1df0, 0x8aff, 0x00c0,
+	0x1dde, 0x0c7f, 0xa085, 0x0001, 0x0078, 0x1df0, 0x127e, 0x2091,
+	0x8000, 0x2079, 0x0020, 0x2009, 0x0001, 0x1078, 0x1df4, 0x0040,
+	0x1ded, 0x2009, 0x0001, 0x1078, 0x1df4, 0x127f, 0x0c7f, 0xa006,
+	0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x077e, 0x067e, 0x057e, 0x047e,
+	0x037e, 0x027e, 0x8aff, 0x0040, 0x1e72, 0x700c, 0x7214, 0xa23a,
+	0x7010, 0x7218, 0xa203, 0x0048, 0x1e71, 0xa705, 0x0040, 0x1e71,
+	0xa03e, 0x2730, 0x6850, 0xd0fc, 0x00c0, 0x1e24, 0x0d7e, 0x2804,
+	0xac68, 0x2900, 0x0079, 0x1e14, 0x1e53, 0x1e34, 0x1e34, 0x1e53,
+	0x1e53, 0x1e4b, 0x1e53, 0x1e34, 0x1e53, 0x1e3a, 0x1e3a, 0x1e53,
+	0x1e53, 0x1e53, 0x1e42, 0x1e3a, 0xc0fc, 0x6852, 0x6b6c, 0x6a70,
+	0x6d1c, 0x6c20, 0xd99c, 0x0040, 0x1e57, 0x0d7e, 0x2804, 0xac68,
+	0x6f08, 0x6e0c, 0x0078, 0x1e56, 0x6b08, 0x6a0c, 0x6d00, 0x6c04,
+	0x0078, 0x1e56, 0x6b10, 0x6a14, 0x6d00, 0x6c04, 0x6f08, 0x6e0c,
+	0x0078, 0x1e56, 0x0d7f, 0x0d7e, 0x6834, 0xa084, 0x00ff, 0xa086,
+	0x001e, 0x00c0, 0x1e53, 0x0d7f, 0x1078, 0x2026, 0x00c0, 0x1dfa,
+	0xa00e, 0x0078, 0x1e72, 0x0d7f, 0x1078, 0x1332, 0x0d7f, 0x7b22,
+	0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e, 0x7902, 0x7000, 0x8000,
+	0x7002, 0x6828, 0xa300, 0x682a, 0x682c, 0xa201, 0x682e, 0x700c,
+	0xa300, 0x700e, 0x7010, 0xa201, 0x7012, 0x1078, 0x2026, 0x0078,
+	0x1e72, 0xa006, 0x027f, 0x037f, 0x047f, 0x057f, 0x067f, 0x077f,
+	0x007c, 0x1078, 0x1332, 0x027e, 0x2001, 0x0105, 0x2003, 0x0010,
+	0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060,
+	0x0d7e, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x1e92, 0x6850,
+	0xc0bd, 0x6852, 0x0d7f, 0x0c7e, 0x1078, 0x8a01, 0x0c7f, 0x2001,
+	0xa8c0, 0x2004, 0xac06, 0x00c0, 0x1ea7, 0x20e1, 0x9040, 0x1078,
+	0x738a, 0x2011, 0x0000, 0x1078, 0x70ea, 0x1078, 0x639b, 0x027f,
+	0x0078, 0x1f76, 0x127e, 0x2091, 0x2200, 0x007e, 0x017e, 0x0f7e,
+	0x0e7e, 0x0d7e, 0x0c7e, 0x2079, 0x0020, 0x2071, 0xa908, 0x2b68,
+	0x6818, 0x2060, 0x7904, 0x7803, 0x0002, 0xa184, 0x0700, 0x00c0,
+	0x1e7b, 0x7000, 0x0079, 0x1ec4, 0x1f76, 0x1ec8, 0x1f43, 0x1f74,
+	0x8001, 0x7002, 0xd19c, 0x00c0, 0x1edc, 0x8aff, 0x0040, 0x1efb,
+	0x2009, 0x0001, 0x1078, 0x1df4, 0x0040, 0x1f76, 0x2009, 0x0001,
+	0x1078, 0x1df4, 0x0078, 0x1f76, 0x7803, 0x0004, 0xd194, 0x0040,
+	0x1eec, 0x6850, 0xc0fc, 0x6852, 0x8aff, 0x00c0, 0x1ef1, 0x684c,
+	0xc0f5, 0x684e, 0x0078, 0x1ef1, 0x1078, 0x203f, 0x6850, 0xc0fd,
+	0x6852, 0x2a00, 0x6826, 0x2c00, 0x681a, 0x2800, 0x6832, 0x7003,
+	0x0000, 0x0078, 0x1f76, 0x711c, 0x81ff, 0x0040, 0x1f11, 0x7918,
+	0x7922, 0x7827, 0x0000, 0x7803, 0x0001, 0x7000, 0x8000, 0x7002,
+	0x700c, 0xa100, 0x700e, 0x7010, 0xa081, 0x0000, 0x7012, 0x0078,
+	0x1f76, 0x0f7e, 0x027e, 0x781c, 0x007e, 0x7818, 0x007e, 0x2079,
+	0x0100, 0x7a14, 0xa284, 0x0004, 0xa085, 0x0012, 0x7816, 0x037e,
+	0x2019, 0x1000, 0x8319, 0x1040, 0x1332, 0x7820, 0xd0bc, 0x00c0,
+	0x1f22, 0x037f, 0x79c8, 0x007f, 0xa102, 0x017f, 0x007e, 0x017e,
+	0x79c4, 0x007f, 0xa103, 0x78c6, 0x007f, 0x78ca, 0xa284, 0x0004,
+	0xa085, 0x0012, 0x7816, 0x027f, 0x0f7f, 0x7803, 0x0008, 0x7003,
+	0x0000, 0x0078, 0x1f76, 0x8001, 0x7002, 0xd194, 0x0040, 0x1f58,
+	0x7804, 0xd0fc, 0x00c0, 0x1eba, 0xd19c, 0x00c0, 0x1f72, 0x8aff,
+	0x0040, 0x1f76, 0x2009, 0x0001, 0x1078, 0x1df4, 0x0078, 0x1f76,
+	0x027e, 0x037e, 0x6b28, 0x6a2c, 0x1078, 0x203f, 0x0d7e, 0x2804,
+	0xac68, 0x6034, 0xd09c, 0x00c0, 0x1f6b, 0x6808, 0xa31a, 0x680c,
+	0xa213, 0x0078, 0x1f6f, 0x6810, 0xa31a, 0x6814, 0xa213, 0x0d7f,
+	0x0078, 0x1eec, 0x0078, 0x1eec, 0x1078, 0x1332, 0x0c7f, 0x0d7f,
+	0x0e7f, 0x0f7f, 0x017f, 0x007f, 0x127f, 0x007c, 0x0f7e, 0x0e7e,
+	0x2071, 0xa908, 0x7000, 0xa086, 0x0000, 0x0040, 0x1fc7, 0x2079,
+	0x0020, 0x017e, 0x2009, 0x0207, 0x210c, 0xd194, 0x0040, 0x1fa4,
+	0x2009, 0x020c, 0x210c, 0xa184, 0x0003, 0x0040, 0x1fa4, 0x1078,
+	0xa5d2, 0x2001, 0x0133, 0x2004, 0xa005, 0x1040, 0x1332, 0x20e1,
+	0x9040, 0x2001, 0x020c, 0x2102, 0x2009, 0x0206, 0x2104, 0x2009,
+	0x0203, 0x210c, 0xa106, 0x00c0, 0x1faf, 0x20e1, 0x9040, 0x7804,
+	0xd0fc, 0x0040, 0x1f8a, 0x1078, 0x1eaa, 0x7000, 0xa086, 0x0000,
+	0x00c0, 0x1f8a, 0x017f, 0x7803, 0x0004, 0x7804, 0xd0ac, 0x00c0,
+	0x1fbd, 0x20e1, 0x9040, 0x7803, 0x0002, 0x7003, 0x0000, 0x0e7f,
+	0x0f7f, 0x007c, 0x027e, 0x0c7e, 0x0d7e, 0x0e7e, 0x0f7e, 0x2071,
+	0xa908, 0x2079, 0x0020, 0x7000, 0xa086, 0x0000, 0x0040, 0x2003,
+	0x7004, 0x2060, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x1fed,
+	0x6850, 0xc0b5, 0x6852, 0x680c, 0x7a1c, 0xa206, 0x00c0, 0x1fed,
+	0x6808, 0x7a18, 0xa206, 0x0040, 0x2009, 0x2001, 0x0105, 0x2003,
+	0x0010, 0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004,
+	0x2060, 0x1078, 0x8a01, 0x20e1, 0x9040, 0x1078, 0x738a, 0x2011,
+	0x0000, 0x1078, 0x70ea, 0x0f7f, 0x0e7f, 0x0d7f, 0x0c7f, 0x027f,
+	0x007c, 0x6810, 0x6a14, 0xa205, 0x00c0, 0x1fed, 0x684c, 0xc0dc,
+	0x684e, 0x2c10, 0x1078, 0x1cf0, 0x2001, 0x0105, 0x2003, 0x0010,
+	0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000, 0x2069, 0xa8b1,
+	0x6833, 0x0000, 0x683f, 0x0000, 0x0078, 0x2003, 0x8840, 0x2804,
+	0xa005, 0x00c0, 0x203a, 0x6004, 0xa005, 0x0040, 0x203c, 0x681a,
+	0x2060, 0x6034, 0xa084, 0x000f, 0xa080, 0x206a, 0x2044, 0x88ff,
+	0x1040, 0x1332, 0x8a51, 0x007c, 0x2051, 0x0000, 0x007c, 0x8a50,
+	0x8841, 0x2804, 0xa005, 0x00c0, 0x2059, 0x2c00, 0xad06, 0x0040,
+	0x204e, 0x6000, 0xa005, 0x00c0, 0x204e, 0x2d00, 0x2060, 0x681a,
+	0x6034, 0xa084, 0x000f, 0xa080, 0x207a, 0x2044, 0x88ff, 0x1040,
+	0x1332, 0x007c, 0x0000, 0x0011, 0x0015, 0x0019, 0x001d, 0x0021,
+	0x0025, 0x0029, 0x0000, 0x000f, 0x0015, 0x001b, 0x0021, 0x0027,
+	0x0000, 0x0000, 0x0000, 0x205f, 0x205b, 0x0000, 0x0000, 0x2069,
+	0x0000, 0x205f, 0x0000, 0x2066, 0x2063, 0x0000, 0x0000, 0x0000,
+	0x2069, 0x2066, 0x0000, 0x2061, 0x2061, 0x0000, 0x0000, 0x2069,
+	0x0000, 0x2061, 0x0000, 0x2067, 0x2067, 0x0000, 0x0000, 0x0000,
+	0x2069, 0x2067, 0x0a7e, 0x097e, 0x087e, 0x6b2e, 0x6c2a, 0x6858,
+	0xa055, 0x0040, 0x212d, 0x2d60, 0x6034, 0xa0cc, 0x000f, 0xa9c0,
+	0x206a, 0xa986, 0x0007, 0x0040, 0x20a5, 0xa986, 0x000e, 0x0040,
+	0x20a5, 0xa986, 0x000f, 0x00c0, 0x20a9, 0x605c, 0xa422, 0x6060,
+	0xa31a, 0x2804, 0xa045, 0x00c0, 0x20b7, 0x0050, 0x20b1, 0x0078,
+	0x212d, 0x6004, 0xa065, 0x0040, 0x212d, 0x0078, 0x2094, 0x2804,
+	0xa005, 0x0040, 0x20d5, 0xac68, 0xd99c, 0x00c0, 0x20c5, 0x6808,
+	0xa422, 0x680c, 0xa31b, 0x0078, 0x20c9, 0x6810, 0xa422, 0x6814,
+	0xa31b, 0x0048, 0x20f4, 0x2300, 0xa405, 0x0040, 0x20db, 0x8a51,
+	0x0040, 0x212d, 0x8840, 0x0078, 0x20b7, 0x6004, 0xa065, 0x0040,
+	0x212d, 0x0078, 0x2094, 0x8a51, 0x0040, 0x212d, 0x8840, 0x2804,
+	0xa005, 0x00c0, 0x20ee, 0x6004, 0xa065, 0x0040, 0x212d, 0x6034,
+	0xa0cc, 0x000f, 0xa9c0, 0x206a, 0x2804, 0x2040, 0x2b68, 0x6850,
+	0xc0fc, 0x6852, 0x0078, 0x2121, 0x8422, 0x8420, 0x831a, 0xa399,
+	0x0000, 0x0d7e, 0x2b68, 0x6c6e, 0x6b72, 0x0d7f, 0xd99c, 0x00c0,
+	0x210f, 0x6908, 0x2400, 0xa122, 0x690c, 0x2300, 0xa11b, 0x1048,
+	0x1332, 0x6800, 0xa420, 0x6804, 0xa319, 0x0078, 0x211b, 0x6910,
+	0x2400, 0xa122, 0x6914, 0x2300, 0xa11b, 0x1048, 0x1332, 0x6800,
+	0xa420, 0x6804, 0xa319, 0x2b68, 0x6c1e, 0x6b22, 0x6850, 0xc0fd,
+	0x6852, 0x2c00, 0x681a, 0x2800, 0x6832, 0x2a00, 0x6826, 0x007f,
+	0x007f, 0x007f, 0xa006, 0x0078, 0x2132, 0x087f, 0x097f, 0x0a7f,
+	0xa085, 0x0001, 0x007c, 0x2001, 0x0005, 0x2004, 0xa084, 0x0007,
+	0x0079, 0x213a, 0x2142, 0x2143, 0x2146, 0x2149, 0x214e, 0x2151,
+	0x2156, 0x215b, 0x007c, 0x1078, 0x1eaa, 0x007c, 0x1078, 0x1913,
+	0x007c, 0x1078, 0x1913, 0x1078, 0x1eaa, 0x007c, 0x1078, 0x14be,
+	0x007c, 0x1078, 0x1eaa, 0x1078, 0x14be, 0x007c, 0x1078, 0x1913,
+	0x1078, 0x14be, 0x007c, 0x1078, 0x1913, 0x1078, 0x1eaa, 0x1078,
+	0x14be, 0x007c, 0x127e, 0x2091, 0x2300, 0x2079, 0x0200, 0x2071,
+	0xab80, 0x2069, 0xa600, 0x2009, 0x0004, 0x7912, 0x7817, 0x0004,
+	0x1078, 0x251f, 0x781b, 0x0002, 0x20e1, 0x8700, 0x127f, 0x007c,
+	0x127e, 0x2091, 0x2300, 0x781c, 0xa084, 0x0007, 0x0079, 0x2180,
+	0x21a4, 0x2188, 0x218c, 0x2190, 0x2196, 0x219a, 0x219e, 0x21a2,
+	0x1078, 0x548e, 0x0078, 0x21a4, 0x1078, 0x54da, 0x0078, 0x21a4,
+	0x1078, 0x548e, 0x1078, 0x54da, 0x0078, 0x21a4, 0x1078, 0x21a6,
+	0x0078, 0x21a4, 0x1078, 0x21a6, 0x0078, 0x21a4, 0x1078, 0x21a6,
+	0x0078, 0x21a4, 0x1078, 0x21a6, 0x127f, 0x007c, 0x007e, 0x017e,
+	0x027e, 0x1078, 0xa5d2, 0x7930, 0xa184, 0x0003, 0x0040, 0x21c9,
+	0x2001, 0xa8c0, 0x2004, 0xa005, 0x0040, 0x21c5, 0x2001, 0x0133,
+	0x2004, 0xa005, 0x1040, 0x1332, 0x0c7e, 0x2001, 0xa8c0, 0x2064,
+	0x1078, 0x8a01, 0x0c7f, 0x0078, 0x21f2, 0x20e1, 0x9040, 0x0078,
+	0x21f2, 0xa184, 0x0030, 0x0040, 0x21da, 0x6a00, 0xa286, 0x0003,
+	0x00c0, 0x21d4, 0x0078, 0x21d6, 0x1078, 0x4224, 0x20e1, 0x9010,
+	0x0078, 0x21f2, 0xa184, 0x00c0, 0x0040, 0x21ec, 0x0e7e, 0x037e,
+	0x047e, 0x057e, 0x2071, 0xa8e7, 0x1078, 0x1af4, 0x057f, 0x047f,
+	0x037f, 0x0e7f, 0x0078, 0x21f2, 0xa184, 0x0300, 0x0040, 0x21f2,
+	0x20e1, 0x9020, 0x7932, 0x027f, 0x017f, 0x007f, 0x007c, 0x017e,
+	0x0e7e, 0x0f7e, 0x2071, 0xa600, 0x7128, 0x2001, 0xa890, 0x2102,
+	0x2001, 0xa898, 0x2102, 0xa182, 0x0211, 0x00c8, 0x220b, 0x2009,
+	0x0008, 0x0078, 0x2235, 0xa182, 0x0259, 0x00c8, 0x2213, 0x2009,
+	0x0007, 0x0078, 0x2235, 0xa182, 0x02c1, 0x00c8, 0x221b, 0x2009,
+	0x0006, 0x0078, 0x2235, 0xa182, 0x0349, 0x00c8, 0x2223, 0x2009,
+	0x0005, 0x0078, 0x2235, 0xa182, 0x0421, 0x00c8, 0x222b, 0x2009,
+	0x0004, 0x0078, 0x2235, 0xa182, 0x0581, 0x00c8, 0x2233, 0x2009,
+	0x0003, 0x0078, 0x2235, 0x2009, 0x0002, 0x2079, 0x0200, 0x7912,
+	0x7817, 0x0004, 0x1078, 0x251f, 0x0f7f, 0x0e7f, 0x017f, 0x007c,
+	0x127e, 0x2091, 0x2200, 0x2061, 0x0100, 0x2071, 0xa600, 0x6024,
+	0x6026, 0x6053, 0x0030, 0x6033, 0x00ef, 0x60e7, 0x0000, 0x60eb,
+	0x00ef, 0x60e3, 0x0008, 0x604b, 0xf7f7, 0x6043, 0x0000, 0x602f,
+	0x0080, 0x602f, 0x0000, 0x6007, 0x0eaf, 0x600f, 0x00ff, 0x602b,
+	0x002f, 0x127f, 0x007c, 0x2001, 0xa630, 0x2003, 0x0000, 0x2001,
+	0xa62f, 0x2003, 0x0001, 0x007c, 0x127e, 0x2091, 0x2200, 0x007e,
+	0x017e, 0x027e, 0x6124, 0xa184, 0x002c, 0x00c0, 0x227b, 0xa184,
+	0x0007, 0x0079, 0x2281, 0xa195, 0x0004, 0xa284, 0x0007, 0x0079,
+	0x2281, 0x22ad, 0x2289, 0x228d, 0x2291, 0x2297, 0x229b, 0x22a1,
+	0x22a7, 0x1078, 0x5c56, 0x0078, 0x22ad, 0x1078, 0x5d45, 0x0078,
+	0x22ad, 0x1078, 0x5d45, 0x1078, 0x5c56, 0x0078, 0x22ad, 0x1078,
+	0x22b2, 0x0078, 0x22ad, 0x1078, 0x5c56, 0x1078, 0x22b2, 0x0078,
+	0x22ad, 0x1078, 0x5d45, 0x1078, 0x22b2, 0x0078, 0x22ad, 0x1078,
+	0x5d45, 0x1078, 0x5c56, 0x1078, 0x22b2, 0x027f, 0x017f, 0x007f,
+	0x127f, 0x007c, 0x6124, 0xd1ac, 0x0040, 0x23ac, 0x017e, 0x047e,
+	0x0c7e, 0x644c, 0xa486, 0xf0f0, 0x00c0, 0x22c5, 0x2061, 0x0100,
+	0x644a, 0x6043, 0x0090, 0x6043, 0x0010, 0x74c6, 0xa48c, 0xff00,
+	0x7034, 0xd084, 0x0040, 0x22dd, 0xa186, 0xf800, 0x00c0, 0x22dd,
+	0x703c, 0xd084, 0x00c0, 0x22dd, 0xc085, 0x703e, 0x037e, 0x2418,
+	0x2011, 0x8016, 0x1078, 0x361b, 0x037f, 0xa196, 0xff00, 0x0040,
+	0x231f, 0x6030, 0xa084, 0x00ff, 0x810f, 0xa116, 0x0040, 0x231f,
+	0x7130, 0xd184, 0x00c0, 0x231f, 0x2011, 0xa653, 0x2214, 0xd2ec,
+	0x0040, 0x22fa, 0xc18d, 0x7132, 0x2011, 0xa653, 0x2214, 0xd2ac,
+	0x00c0, 0x231f, 0x6240, 0xa294, 0x0010, 0x0040, 0x2306, 0x6248,
+	0xa294, 0xff00, 0xa296, 0xff00, 0x0040, 0x231f, 0x7030, 0xd08c,
+	0x0040, 0x2371, 0x7034, 0xd08c, 0x00c0, 0x2316, 0x2001, 0xa60c,
+	0x200c, 0xd1ac, 0x00c0, 0x2371, 0xc1ad, 0x2102, 0x037e, 0x73c4,
+	0x2011, 0x8013, 0x1078, 0x361b, 0x037f, 0x0078, 0x2371, 0x7034,
+	0xd08c, 0x00c0, 0x232b, 0x2001, 0xa60c, 0x200c, 0xd1ac, 0x00c0,
+	0x2371, 0xc1ad, 0x2102, 0x037e, 0x73c4, 0x2011, 0x8013, 0x1078,
+	0x361b, 0x037f, 0x7130, 0xc185, 0x7132, 0x2011, 0xa653, 0x220c,
+	0xd1a4, 0x0040, 0x2355, 0x017e, 0x2009, 0x0001, 0x2011, 0x0100,
+	0x1078, 0x5bf1, 0x2019, 0x000e, 0x1078, 0xa195, 0xa484, 0x00ff,
+	0xa080, 0x29c0, 0x200c, 0xa18c, 0xff00, 0x810f, 0x8127, 0xa006,
+	0x2009, 0x000e, 0x1078, 0xa21d, 0x017f, 0xd1ac, 0x00c0, 0x2362,
+	0x017e, 0x2009, 0x0000, 0x2019, 0x0004, 0x1078, 0x284f, 0x017f,
+	0x0078, 0x2371, 0x157e, 0x20a9, 0x007f, 0x2009, 0x0000, 0x1078,
+	0x45c4, 0x00c0, 0x236d, 0x1078, 0x42f8, 0x8108, 0x00f0, 0x2367,
+	0x157f, 0x0c7f, 0x047f, 0x0f7e, 0x2079, 0xa8c4, 0x783c, 0xa086,
+	0x0000, 0x0040, 0x2383, 0x6027, 0x0004, 0x783f, 0x0000, 0x2079,
+	0x0140, 0x7803, 0x0000, 0x0f7f, 0x2011, 0x0003, 0x1078, 0x70e0,
+	0x2011, 0x0002, 0x1078, 0x70ea, 0x1078, 0x6fc4, 0x037e, 0x2019,
+	0x0000, 0x1078, 0x7058, 0x037f, 0x60e3, 0x0000, 0x017f, 0x2001,
+	0xa600, 0x2014, 0xa296, 0x0004, 0x00c0, 0x23a4, 0xd19c, 0x00c0,
+	0x23ac, 0x6228, 0xc29d, 0x622a, 0x2003, 0x0001, 0x2001, 0xa622,
+	0x2003, 0x0000, 0x6027, 0x0020, 0xd194, 0x0040, 0x2490, 0x0f7e,
+	0x2079, 0xa8c4, 0x783c, 0xa086, 0x0001, 0x00c0, 0x23d0, 0x017e,
+	0x6027, 0x0004, 0x783f, 0x0000, 0x2079, 0x0140, 0x7803, 0x1000,
+	0x7803, 0x0000, 0x2079, 0xa8b1, 0x7807, 0x0000, 0x7833, 0x0000,
+	0x1078, 0x62d1, 0x1078, 0x639b, 0x017f, 0x0f7f, 0x0078, 0x2490,
+	0x0f7f, 0x017e, 0x3900, 0xa082, 0xa9e3, 0x00c8, 0x23db, 0x017e,
+	0x1078, 0x747a, 0x017f, 0x6220, 0xd2b4, 0x0040, 0x2446, 0x1078,
+	0x5acb, 0x1078, 0x6e0f, 0x6027, 0x0004, 0x0f7e, 0x2019, 0xa8ba,
+	0x2304, 0xa07d, 0x0040, 0x241c, 0x7804, 0xa086, 0x0032, 0x00c0,
+	0x241c, 0x0d7e, 0x0c7e, 0x0e7e, 0x2069, 0x0140, 0x618c, 0x6288,
+	0x7818, 0x608e, 0x7808, 0x608a, 0x6043, 0x0002, 0x2001, 0x0003,
+	0x8001, 0x00c0, 0x2400, 0x6043, 0x0000, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x618e, 0x628a, 0x1078, 0x61cd, 0x1078, 0x62d1, 0x7810,
+	0x2070, 0x7037, 0x0103, 0x2f60, 0x1078, 0x772d, 0x0e7f, 0x0c7f,
+	0x0d7f, 0x0f7f, 0x017f, 0x007c, 0x0f7f, 0x0d7e, 0x2069, 0x0140,
+	0x6804, 0xa084, 0x4000, 0x0040, 0x2429, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x0d7f, 0x0c7e, 0x2061, 0xa8b1, 0x6028, 0xa09a, 0x00c8,
+	0x00c8, 0x2439, 0x8000, 0x602a, 0x0c7f, 0x1078, 0x6e01, 0x0078,
+	0x248f, 0x2019, 0xa8ba, 0x2304, 0xa065, 0x0040, 0x2443, 0x2009,
+	0x0027, 0x1078, 0x775c, 0x0c7f, 0x0078, 0x248f, 0xd2bc, 0x0040,
+	0x248f, 0x1078, 0x5ad8, 0x6017, 0x0010, 0x6027, 0x0004, 0x0d7e,
+	0x2069, 0x0140, 0x6804, 0xa084, 0x4000, 0x0040, 0x245b, 0x6803,
+	0x1000, 0x6803, 0x0000, 0x0d7f, 0x0c7e, 0x2061, 0xa8b1, 0x6044,
+	0xa09a, 0x00c8, 0x00c8, 0x247e, 0x8000, 0x6046, 0x603c, 0x0c7f,
+	0xa005, 0x0040, 0x248f, 0x2009, 0x07d0, 0x1078, 0x5ad0, 0xa080,
+	0x0007, 0x2004, 0xa086, 0x0006, 0x00c0, 0x247a, 0x6017, 0x0012,
+	0x0078, 0x248f, 0x6017, 0x0016, 0x0078, 0x248f, 0x037e, 0x2019,
+	0x0001, 0x1078, 0x7058, 0x037f, 0x2019, 0xa8c0, 0x2304, 0xa065,
+	0x0040, 0x248e, 0x2009, 0x004f, 0x1078, 0x775c, 0x0c7f, 0x017f,
+	0xd19c, 0x0040, 0x24e4, 0x7034, 0xd0ac, 0x00c0, 0x24c1, 0x017e,
+	0x157e, 0x6027, 0x0008, 0x602f, 0x0020, 0x20a9, 0x000a, 0x00f0,
+	0x249f, 0x602f, 0x0000, 0x6150, 0xa185, 0x1400, 0x6052, 0x20a9,
+	0x0320, 0x00e0, 0x24a9, 0x2091, 0x6000, 0x6020, 0xd09c, 0x00c0,
+	0x24b8, 0x157f, 0x6152, 0x017f, 0x6027, 0x0008, 0x0078, 0x24e4,
+	0x1078, 0x2577, 0x00f0, 0x24a9, 0x157f, 0x6152, 0x017f, 0x6027,
+	0x0008, 0x017e, 0x6028, 0xc09c, 0x602a, 0x2011, 0x0003, 0x1078,
+	0x70e0, 0x2011, 0x0002, 0x1078, 0x70ea, 0x1078, 0x6fc4, 0x037e,
+	0x2019, 0x0000, 0x1078, 0x7058, 0x037f, 0x60e3, 0x0000, 0x1078,
+	0xa5ad, 0x1078, 0xa5cb, 0x2001, 0xa600, 0x2003, 0x0004, 0x6027,
+	0x0008, 0x1078, 0x1246, 0x017f, 0xa18c, 0xffd0, 0x6126, 0x007c,
+	0x007e, 0x017e, 0x027e, 0x0e7e, 0x0f7e, 0x127e, 0x2091, 0x8000,
+	0x2071, 0xa600, 0x71bc, 0x70be, 0xa116, 0x0040, 0x2518, 0x81ff,
+	0x0040, 0x2500, 0x2011, 0x8011, 0x1078, 0x361b, 0x0078, 0x2518,
+	0x2011, 0x8012, 0x1078, 0x361b, 0x2001, 0xa672, 0x2004, 0xd0fc,
+	0x00c0, 0x2518, 0x037e, 0x0c7e, 0x1078, 0x6f9f, 0x2061, 0x0100,
+	0x2019, 0x0028, 0x2009, 0x0000, 0x1078, 0x284f, 0x0c7f, 0x037f,
+	0x127f, 0x0f7f, 0x0e7f, 0x027f, 0x017f, 0x007f, 0x007c, 0x0c7e,
+	0x0f7e, 0x007e, 0x027e, 0x2061, 0x0100, 0xa190, 0x253b, 0x2204,
+	0x60f2, 0x2011, 0x2548, 0x6000, 0xa082, 0x0003, 0x00c8, 0x2534,
+	0x2001, 0x00ff, 0x0078, 0x2535, 0x2204, 0x60ee, 0x027f, 0x007f,
+	0x0f7f, 0x0c7f, 0x007c, 0x0840, 0x0840, 0x0840, 0x0580, 0x0420,
+	0x0348, 0x02c0, 0x0258, 0x0210, 0x01a8, 0x01a8, 0x01a8, 0x01a8,
+	0x0140, 0x00f8, 0x00d0, 0x00b0, 0x00a0, 0x2028, 0xa18c, 0x00ff,
+	0x2130, 0xa094, 0xff00, 0x00c0, 0x2558, 0x81ff, 0x0040, 0x255c,
+	0x1078, 0x5761, 0x0078, 0x2563, 0xa080, 0x29c0, 0x200c, 0xa18c,
+	0xff00, 0x810f, 0xa006, 0x007c, 0xa080, 0x29c0, 0x200c, 0xa18c,
+	0x00ff, 0x007c, 0x0c7e, 0x2061, 0xa600, 0x6030, 0x0040, 0x2573,
+	0xc09d, 0x0078, 0x2574, 0xc09c, 0x6032, 0x0c7f, 0x007c, 0x007e,
+	0x157e, 0x0f7e, 0x2079, 0x0100, 0x20a9, 0x000a, 0x7854, 0xd08c,
+	0x00c0, 0x2584, 0x00f0, 0x257e, 0x0f7f, 0x157f, 0x007f, 0x007c,
+	0x0c7e, 0x007e, 0x2061, 0x0100, 0x6030, 0x007e, 0x6048, 0x007e,
+	0x60e4, 0x007e, 0x60e8, 0x007e, 0x6050, 0x007e, 0x60f0, 0x007e,
+	0x60ec, 0x007e, 0x600c, 0x007e, 0x6004, 0x007e, 0x6028, 0x007e,
+	0x60e0, 0x007e, 0x602f, 0x0100, 0x602f, 0x0000, 0x0005, 0x0005,
+	0x0005, 0x0005, 0x602f, 0x0040, 0x602f, 0x0000, 0x007f, 0x60e2,
+	0x007f, 0x602a, 0x007f, 0x6006, 0x007f, 0x600e, 0x007f, 0x60ee,
+	0x007f, 0x60f2, 0x007f, 0x6052, 0x007f, 0x60ea, 0x007f, 0x60e6,
+	0x007f, 0x604a, 0x007f, 0x6032, 0x007f, 0x0c7f, 0x007c, 0x25e7,
+	0x25eb, 0x25ef, 0x25f5, 0x25fb, 0x2601, 0x2607, 0x260f, 0x2617,
+	0x261d, 0x2623, 0x262b, 0x2633, 0x263b, 0x2643, 0x264d, 0x2657,
+	0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x2657,
+	0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x2657, 0x107e,
+	0x007e, 0x0078, 0x2670, 0x107e, 0x007e, 0x0078, 0x2670, 0x107e,
+	0x007e, 0x1078, 0x226c, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078,
+	0x226c, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x2133, 0x0078,
+	0x2670, 0x107e, 0x007e, 0x1078, 0x2133, 0x0078, 0x2670, 0x107e,
+	0x007e, 0x1078, 0x226c, 0x1078, 0x2133, 0x0078, 0x2670, 0x107e,
+	0x007e, 0x1078, 0x226c, 0x1078, 0x2133, 0x0078, 0x2670, 0x107e,
+	0x007e, 0x1078, 0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078,
+	0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x226c, 0x1078,
+	0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x226c, 0x1078,
+	0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x2133, 0x1078,
+	0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x2133, 0x1078,
+	0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078, 0x226c, 0x1078,
+	0x2133, 0x1078, 0x2178, 0x0078, 0x2670, 0x107e, 0x007e, 0x1078,
+	0x226c, 0x1078, 0x2133, 0x1078, 0x2178, 0x0078, 0x2670, 0x0005,
+	0x0078, 0x2657, 0xb084, 0x003c, 0x8004, 0x8004, 0x0079, 0x2660,
+	0x2670, 0x25ed, 0x25f1, 0x25f7, 0x25fd, 0x2603, 0x2609, 0x2611,
+	0x2619, 0x261f, 0x2625, 0x262d, 0x2635, 0x263d, 0x2645, 0x264f,
+	0x0008, 0x265a, 0x007f, 0x107f, 0x2091, 0x8001, 0x007c, 0x0c7e,
+	0x027e, 0x047e, 0x2021, 0x0000, 0x1078, 0x4967, 0x00c0, 0x2772,
+	0x70cc, 0xd09c, 0x0040, 0x268e, 0xd084, 0x00c0, 0x268e, 0xd0bc,
+	0x00c0, 0x2772, 0x1078, 0x2776, 0x0078, 0x2772, 0xd0cc, 0x00c0,
+	0x2772, 0xd094, 0x0040, 0x2698, 0x7097, 0xffff, 0x0078, 0x2772,
+	0x2001, 0x010c, 0x203c, 0x7284, 0xd284, 0x0040, 0x2701, 0xd28c,
+	0x00c0, 0x2701, 0x037e, 0x7394, 0xa38e, 0xffff, 0x0040, 0x26ab,
+	0x83ff, 0x00c0, 0x26ad, 0x2019, 0x0001, 0x8314, 0xa2e0, 0xacc0,
+	0x2c04, 0xa38c, 0x0001, 0x0040, 0x26ba, 0xa084, 0xff00, 0x8007,
+	0x0078, 0x26bc, 0xa084, 0x00ff, 0xa70e, 0x0040, 0x26f6, 0xa08e,
+	0x0000, 0x0040, 0x26f6, 0xa08e, 0x00ff, 0x00c0, 0x26d3, 0x7230,
+	0xd284, 0x00c0, 0x26fc, 0x7284, 0xc28d, 0x7286, 0x7097, 0xffff,
+	0x037f, 0x0078, 0x2701, 0x2009, 0x0000, 0x1078, 0x254d, 0x1078,
+	0x455c, 0x00c0, 0x26f9, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x00c0, 0x26f0, 0x7030, 0xd08c, 0x0040, 0x26ea, 0x6000, 0xd0bc,
+	0x0040, 0x26f0, 0x1078, 0x278c, 0x0040, 0x26f9, 0x0078, 0x26f6,
+	0x1078, 0x28c4, 0x1078, 0x27b9, 0x0040, 0x26f9, 0x8318, 0x0078,
+	0x26ad, 0x7396, 0x0078, 0x26fe, 0x7097, 0xffff, 0x037f, 0x0078,
+	0x2772, 0xa780, 0x29c0, 0x203c, 0xa7bc, 0xff00, 0x873f, 0x2041,
+	0x007e, 0x7094, 0xa096, 0xffff, 0x00c0, 0x2713, 0x2009, 0x0000,
+	0x28a8, 0x0078, 0x271f, 0xa812, 0x0048, 0x271b, 0x2008, 0xa802,
+	0x20a8, 0x0078, 0x271f, 0x7097, 0xffff, 0x0078, 0x2772, 0x2700,
+	0x157e, 0x017e, 0xa106, 0x0040, 0x2766, 0xc484, 0x1078, 0x45c4,
+	0x0040, 0x2730, 0x1078, 0x455c, 0x00c0, 0x276f, 0x0078, 0x2731,
+	0xc485, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x2740,
+	0x7030, 0xd08c, 0x0040, 0x275e, 0x6000, 0xd0bc, 0x00c0, 0x275e,
+	0x7284, 0xd28c, 0x0040, 0x2756, 0x6004, 0xa084, 0x00ff, 0xa082,
+	0x0006, 0x0048, 0x2766, 0xd484, 0x00c0, 0x2752, 0x1078, 0x457f,
+	0x0078, 0x2754, 0x1078, 0x298e, 0x0078, 0x2766, 0x1078, 0x28c4,
+	0x1078, 0x27b9, 0x0040, 0x276f, 0x0078, 0x2766, 0x1078, 0x2959,
+	0x0040, 0x2766, 0x1078, 0x278c, 0x0040, 0x276f, 0x017f, 0x8108,
+	0x157f, 0x00f0, 0x271f, 0x7097, 0xffff, 0x0078, 0x2772, 0x017f,
+	0x157f, 0x7196, 0x047f, 0x027f, 0x0c7f, 0x007c, 0x0c7e, 0x017e,
+	0x7097, 0x0001, 0x2009, 0x007e, 0x1078, 0x455c, 0x00c0, 0x2789,
+	0x1078, 0x28c4, 0x1078, 0x27b9, 0x0040, 0x2789, 0x70cc, 0xc0bd,
+	0x70ce, 0x017f, 0x0c7f, 0x007c, 0x017e, 0x077e, 0x0d7e, 0x0c7e,
+	0x2c68, 0x2001, 0xa657, 0x2004, 0xa084, 0x00ff, 0x6842, 0x1078,
+	0x76c7, 0x0040, 0x27b4, 0x2d00, 0x601a, 0x601f, 0x0001, 0x2001,
+	0x0000, 0x1078, 0x44ee, 0x2001, 0x0000, 0x1078, 0x4502, 0x127e,
+	0x2091, 0x8000, 0x7090, 0x8000, 0x7092, 0x127f, 0x2009, 0x0004,
+	0x1078, 0x775c, 0xa085, 0x0001, 0x0c7f, 0x0d7f, 0x077f, 0x017f,
+	0x007c, 0x017e, 0x077e, 0x0d7e, 0x0c7e, 0x2c68, 0x2001, 0xa657,
+	0x2004, 0xa084, 0x00ff, 0x6842, 0x1078, 0x9187, 0x0040, 0x27f2,
+	0x2d00, 0x601a, 0x6800, 0xc0c4, 0x6802, 0x68a0, 0xa086, 0x007e,
+	0x0040, 0x27db, 0x6804, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0,
+	0x27db, 0x1078, 0x2880, 0x601f, 0x0001, 0x2001, 0x0000, 0x1078,
+	0x44ee, 0x2001, 0x0002, 0x1078, 0x4502, 0x127e, 0x2091, 0x8000,
+	0x7090, 0x8000, 0x7092, 0x127f, 0x2009, 0x0002, 0x1078, 0x775c,
+	0xa085, 0x0001, 0x0c7f, 0x0d7f, 0x077f, 0x017f, 0x007c, 0x0c7e,
+	0x027e, 0x2009, 0x0080, 0x1078, 0x455c, 0x00c0, 0x2805, 0x1078,
+	0x2808, 0x0040, 0x2805, 0x70d3, 0xffff, 0x027f, 0x0c7f, 0x007c,
+	0x017e, 0x077e, 0x0d7e, 0x0c7e, 0x2c68, 0x1078, 0x76c7, 0x0040,
+	0x282a, 0x2d00, 0x601a, 0x601f, 0x0001, 0x2001, 0x0000, 0x1078,
+	0x44ee, 0x2001, 0x0002, 0x1078, 0x4502, 0x127e, 0x2091, 0x8000,
+	0x70d4, 0x8000, 0x70d6, 0x127f, 0x2009, 0x0002, 0x1078, 0x775c,
+	0xa085, 0x0001, 0x0c7f, 0x0d7f, 0x077f, 0x017f, 0x007c, 0x0c7e,
+	0x0d7e, 0x127e, 0x2091, 0x8000, 0x2009, 0x007f, 0x1078, 0x455c,
+	0x00c0, 0x284b, 0x2c68, 0x1078, 0x76c7, 0x0040, 0x284b, 0x2d00,
+	0x601a, 0x6312, 0x601f, 0x0001, 0x620a, 0x2009, 0x0022, 0x1078,
+	0x775c, 0xa085, 0x0001, 0x127f, 0x0d7f, 0x0c7f, 0x007c, 0x0e7e,
+	0x0c7e, 0x067e, 0x037e, 0x027e, 0x1078, 0x5f0e, 0x1078, 0x5eae,
+	0x1078, 0x8068, 0x2130, 0x81ff, 0x0040, 0x2864, 0x20a9, 0x007e,
+	0x2009, 0x0000, 0x0078, 0x2868, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x017e, 0x1078, 0x45c4, 0x00c0, 0x2871, 0x1078, 0x47e9, 0x1078,
+	0x42f8, 0x017f, 0x8108, 0x00f0, 0x2868, 0x86ff, 0x00c0, 0x287a,
+	0x1078, 0x119b, 0x027f, 0x037f, 0x067f, 0x0c7f, 0x0e7f, 0x007c,
+	0x0e7e, 0x0c7e, 0x037e, 0x027e, 0x017e, 0x6218, 0x2270, 0x72a0,
+	0x027e, 0x2019, 0x0029, 0x1078, 0x5f01, 0x077e, 0x2039, 0x0000,
+	0x1078, 0x5e0a, 0x2c08, 0x1078, 0x9f8b, 0x077f, 0x017f, 0x2e60,
+	0x1078, 0x47e9, 0x6210, 0x6314, 0x1078, 0x42f8, 0x6212, 0x6316,
+	0x017f, 0x027f, 0x037f, 0x0c7f, 0x0e7f, 0x007c, 0x0e7e, 0x007e,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xd0bc, 0x00c0, 0x28ba, 0x2071,
+	0xa600, 0x7090, 0xa005, 0x0040, 0x28b7, 0x8001, 0x7092, 0x007f,
+	0x0e7f, 0x007c, 0x2071, 0xa600, 0x70d4, 0xa005, 0x0040, 0x28b7,
+	0x8001, 0x70d6, 0x0078, 0x28b7, 0x6000, 0xc08c, 0x6002, 0x007c,
+	0x0f7e, 0x0e7e, 0x0c7e, 0x037e, 0x027e, 0x017e, 0x157e, 0x2178,
+	0x81ff, 0x00c0, 0x28d7, 0x20a9, 0x0001, 0x0078, 0x28f2, 0x2001,
+	0xa653, 0x2004, 0xd0c4, 0x0040, 0x28ee, 0xd0a4, 0x0040, 0x28ee,
+	0x047e, 0x6018, 0xa080, 0x0028, 0x2024, 0xa4a4, 0x00ff, 0x8427,
+	0xa006, 0x2009, 0x002d, 0x1078, 0xa21d, 0x047f, 0x20a9, 0x00ff,
+	0x2011, 0x0000, 0x027e, 0xa28e, 0x007e, 0x0040, 0x2936, 0xa28e,
+	0x007f, 0x0040, 0x2936, 0xa28e, 0x0080, 0x0040, 0x2936, 0xa288,
+	0xa735, 0x210c, 0x81ff, 0x0040, 0x2936, 0x8fff, 0x1040, 0x2942,
+	0x0c7e, 0x2160, 0x2001, 0x0001, 0x1078, 0x4972, 0x0c7f, 0x2019,
+	0x0029, 0x1078, 0x5f01, 0x077e, 0x2039, 0x0000, 0x1078, 0x5e0a,
+	0x0c7e, 0x027e, 0x2160, 0x6204, 0xa294, 0x00ff, 0xa286, 0x0006,
+	0x00c0, 0x2926, 0x6007, 0x0404, 0x0078, 0x292b, 0x2001, 0x0004,
+	0x8007, 0xa215, 0x6206, 0x027f, 0x0c7f, 0x017e, 0x2c08, 0x1078,
+	0x9f8b, 0x017f, 0x077f, 0x2160, 0x1078, 0x47e9, 0x027f, 0x8210,
+	0x00f0, 0x28f2, 0x157f, 0x017f, 0x027f, 0x037f, 0x0c7f, 0x0e7f,
+	0x0f7f, 0x007c, 0x047e, 0x027e, 0x017e, 0x2001, 0xa653, 0x2004,
+	0xd0c4, 0x0040, 0x2955, 0xd0a4, 0x0040, 0x2955, 0xa006, 0x2220,
+	0x8427, 0x2009, 0x0029, 0x1078, 0xa21d, 0x017f, 0x027f, 0x047f,
+	0x007c, 0x017e, 0x027e, 0x037e, 0x0c7e, 0x7284, 0x82ff, 0x0040,
+	0x2987, 0xa290, 0xa653, 0x2214, 0xd2ac, 0x00c0, 0x2987, 0x2100,
+	0x1078, 0x2564, 0x81ff, 0x0040, 0x2989, 0x2019, 0x0001, 0x8314,
+	0xa2e0, 0xacc0, 0x2c04, 0xd384, 0x0040, 0x297b, 0xa084, 0xff00,
+	0x8007, 0x0078, 0x297d, 0xa084, 0x00ff, 0xa116, 0x0040, 0x2989,
+	0xa096, 0x00ff, 0x0040, 0x2987, 0x8318, 0x0078, 0x296f, 0xa085,
+	0x0001, 0x0c7f, 0x037f, 0x027f, 0x017f, 0x007c, 0x017e, 0x0c7e,
+	0x127e, 0x2091, 0x8000, 0x017e, 0x027e, 0x037e, 0x2110, 0x027e,
+	0x2019, 0x0029, 0x1078, 0x73d0, 0x027f, 0x1078, 0xa4f1, 0x037f,
+	0x027f, 0x017f, 0xa180, 0xa735, 0x2004, 0xa065, 0x0040, 0x29b7,
+	0x017e, 0x0c7e, 0x1078, 0x9187, 0x017f, 0x1040, 0x1332, 0x611a,
+	0x1078, 0x2880, 0x1078, 0x772d, 0x017f, 0x1078, 0x457f, 0x127f,
+	0x0c7f, 0x017f, 0x007c, 0x2001, 0xa633, 0x2004, 0xd0cc, 0x007c,
+	0x7eef, 0x7de8, 0x7ce4, 0x80e2, 0x7be1, 0x80e0, 0x80dc, 0x80da,
+	0x7ad9, 0x80d6, 0x80d5, 0x80d4, 0x80d3, 0x80d2, 0x80d1, 0x79ce,
+	0x78cd, 0x80cc, 0x80cb, 0x80ca, 0x80c9, 0x80c7, 0x80c6, 0x77c5,
+	0x76c3, 0x80bc, 0x80ba, 0x75b9, 0x80b6, 0x74b5, 0x73b4, 0x72b3,
+	0x80b2, 0x80b1, 0x80ae, 0x71ad, 0x80ac, 0x70ab, 0x6faa, 0x6ea9,
+	0x80a7, 0x6da6, 0x6ca5, 0x6ba3, 0x6a9f, 0x699e, 0x689d, 0x809b,
+	0x8098, 0x6797, 0x6690, 0x658f, 0x6488, 0x6384, 0x6282, 0x8081,
+	0x8080, 0x617c, 0x607a, 0x8079, 0x5f76, 0x8075, 0x8074, 0x8073,
+	0x8072, 0x8071, 0x806e, 0x5e6d, 0x806c, 0x5d6b, 0x5c6a, 0x5b69,
+	0x8067, 0x5a66, 0x5965, 0x5863, 0x575c, 0x565a, 0x5559, 0x8056,
+	0x8055, 0x5454, 0x5353, 0x5252, 0x5151, 0x504e, 0x4f4d, 0x804c,
+	0x804b, 0x4e4a, 0x4d49, 0x8047, 0x4c46, 0x8045, 0x8043, 0x803c,
+	0x803a, 0x8039, 0x8036, 0x4b35, 0x8034, 0x4a33, 0x4932, 0x4831,
+	0x802e, 0x472d, 0x462c, 0x452b, 0x442a, 0x4329, 0x4227, 0x8026,
+	0x8025, 0x4123, 0x401f, 0x3f1e, 0x3e1d, 0x3d1b, 0x3c18, 0x8017,
+	0x8010, 0x3b0f, 0x3a08, 0x8004, 0x3902, 0x8001, 0x8000, 0x8000,
+	0x3800, 0x3700, 0x3600, 0x8000, 0x3500, 0x8000, 0x8000, 0x8000,
+	0x3400, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x3300,
+	0x3200, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x3100,
+	0x3000, 0x8000, 0x8000, 0x2f00, 0x8000, 0x2e00, 0x2d00, 0x2c00,
+	0x8000, 0x8000, 0x8000, 0x2b00, 0x8000, 0x2a00, 0x2900, 0x2800,
+	0x8000, 0x2700, 0x2600, 0x2500, 0x2400, 0x2300, 0x2200, 0x8000,
+	0x8000, 0x2100, 0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00, 0x8000,
+	0x8000, 0x1b00, 0x1a00, 0x8000, 0x1900, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x1800, 0x8000, 0x1700, 0x1600, 0x1500,
+	0x8000, 0x1400, 0x1300, 0x1200, 0x1100, 0x1000, 0x0f00, 0x8000,
+	0x8000, 0x0e00, 0x0d00, 0x0c00, 0x0b00, 0x0a00, 0x0900, 0x8000,
+	0x8000, 0x0800, 0x0700, 0x8000, 0x0600, 0x8000, 0x8000, 0x8000,
+	0x0500, 0x0400, 0x0300, 0x8000, 0x0200, 0x8000, 0x8000, 0x8000,
+	0x0100, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x0000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x2071, 0xa682, 0x7003, 0x0002, 0xa006, 0x7012, 0x7016, 0x703a,
+	0x703e, 0x7033, 0xa692, 0x7037, 0xa692, 0x7007, 0x0001, 0x2061,
+	0xa6d2, 0x6003, 0x0002, 0x007c, 0x0090, 0x2ae7, 0x0068, 0x2ae7,
+	0x2071, 0xa682, 0x2b78, 0x7818, 0xd084, 0x00c0, 0x2ae7, 0x2a60,
+	0x7820, 0xa08e, 0x0069, 0x00c0, 0x2bd7, 0x0079, 0x2b6b, 0x007c,
+	0x2071, 0xa682, 0x7004, 0x0079, 0x2aed, 0x2af1, 0x2af2, 0x2afc,
+	0x2b0e, 0x007c, 0x0090, 0x2afb, 0x0068, 0x2afb, 0x2b78, 0x7818,
+	0xd084, 0x0040, 0x2b1a, 0x007c, 0x2b78, 0x2061, 0xa6d2, 0x6008,
+	0xa08e, 0x0100, 0x0040, 0x2b09, 0xa086, 0x0200, 0x0040, 0x2bcf,
+	0x007c, 0x7014, 0x2068, 0x2a60, 0x7018, 0x007a, 0x7010, 0x2068,
+	0x6834, 0xa086, 0x0103, 0x0040, 0x2b16, 0x007c, 0x2a60, 0x2b78,
+	0x7018, 0x007a, 0x2a60, 0x7820, 0xa08a, 0x0040, 0x00c8, 0x2b23,
+	0x61bc, 0x0079, 0x2b2b, 0x2100, 0xa08a, 0x003f, 0x00c8, 0x2bcb,
+	0x61bc, 0x0079, 0x2b6b, 0x2bad, 0x2bdf, 0x2be7, 0x2beb, 0x2bf3,
+	0x2bf9, 0x2bfd, 0x2c09, 0x2c0d, 0x2c17, 0x2c1b, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2c1f, 0x2bcb, 0x2c2f, 0x2c46, 0x2c5d, 0x2cdd, 0x2ce2,
+	0x2d0f, 0x2d69, 0x2d7a, 0x2d98, 0x2dd9, 0x2de3, 0x2df0, 0x2e03,
+	0x2e22, 0x2e2b, 0x2e68, 0x2e6e, 0x2bcb, 0x2e8a, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x2e91, 0x2e9b, 0x2bcb, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x2ea3, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x2eb5, 0x2ece, 0x2bcb, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x2ee0, 0x2f37, 0x2f95, 0x2fa9, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x398e, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x2c17, 0x2c1b, 0x2fc0, 0x2bcb, 0x2fcd,
+	0x3a26, 0x3a83, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb,
+	0x2bcb, 0x2bcb, 0x2bcb, 0x301a, 0x314f, 0x316b, 0x3177, 0x31da,
+	0x3233, 0x323e, 0x327d, 0x328c, 0x329b, 0x329e, 0x2fd1, 0x32c2,
+	0x331e, 0x332b, 0x343c, 0x356f, 0x3599, 0x36a6, 0x2bcb, 0x36b6,
+	0x36f0, 0x37bf, 0x2bcb, 0x2bcb, 0x2bcb, 0x2bcb, 0x3827, 0x3843,
+	0x38bd, 0x3977, 0x713c, 0x0078, 0x2bad, 0x2021, 0x4000, 0x1078,
+	0x35f5, 0x127e, 0x2091, 0x8000, 0x0068, 0x2bba, 0x7818, 0xd084,
+	0x0040, 0x2bbd, 0x127f, 0x0078, 0x2bb1, 0x7c22, 0x7926, 0x7a2a,
+	0x7b2e, 0x781b, 0x0001, 0x2091, 0x4080, 0x7007, 0x0001, 0x2091,
+	0x5000, 0x127f, 0x007c, 0x2021, 0x4001, 0x0078, 0x2baf, 0x2021,
+	0x4002, 0x0078, 0x2baf, 0x2021, 0x4003, 0x0078, 0x2baf, 0x2021,
+	0x4005, 0x0078, 0x2baf, 0x2021, 0x4006, 0x0078, 0x2baf, 0xa02e,
+	0x2520, 0x7b28, 0x7a2c, 0x7824, 0x7930, 0x0078, 0x3604, 0x7823,
+	0x0004, 0x7824, 0x007a, 0xa02e, 0x2520, 0x7b28, 0x7a2c, 0x7824,
+	0x7930, 0x0078, 0x3608, 0x7924, 0x7828, 0x2114, 0x200a, 0x0078,
+	0x2bad, 0x7924, 0x2114, 0x0078, 0x2bad, 0x2099, 0x0009, 0x20a1,
+	0x0009, 0x20a9, 0x0007, 0x53a3, 0x7924, 0x7a28, 0x7b2c, 0x0078,
+	0x2bad, 0x7824, 0x2060, 0x0078, 0x2c21, 0x2009, 0x0001, 0x2011,
+	0x0013, 0x2019, 0x0018, 0x783b, 0x0017, 0x0078, 0x2bad, 0x7d38,
+	0x7c3c, 0x0078, 0x2be1, 0x7d38, 0x7c3c, 0x0078, 0x2bed, 0x2061,
+	0x1000, 0x610c, 0xa006, 0x2c14, 0xa200, 0x8c60, 0x8109, 0x00c0,
+	0x2c23, 0x2010, 0xa005, 0x0040, 0x2bad, 0x0078, 0x2bd3, 0x2069,
+	0xa652, 0x7824, 0x7930, 0xa11a, 0x00c8, 0x2bdb, 0x8019, 0x0040,
+	0x2bdb, 0x684a, 0x6942, 0x782c, 0x6852, 0x7828, 0x6856, 0xa006,
+	0x685a, 0x685e, 0x1078, 0x4eae, 0x0078, 0x2bad, 0x2069, 0xa652,
+	0x7824, 0x7934, 0xa11a, 0x00c8, 0x2bdb, 0x8019, 0x0040, 0x2bdb,
+	0x684e, 0x6946, 0x782c, 0x6862, 0x7828, 0x6866, 0xa006, 0x686a,
+	0x686e, 0x1078, 0x4a3e, 0x0078, 0x2bad, 0xa02e, 0x2520, 0x81ff,
+	0x00c0, 0x2bd7, 0x7924, 0x7b28, 0x7a2c, 0x20a9, 0x0005, 0x20a1,
+	0xa689, 0x41a1, 0x1078, 0x35ba, 0x0040, 0x2bd7, 0x2009, 0x0020,
+	0x1078, 0x3604, 0x701b, 0x2c75, 0x007c, 0x6834, 0x2008, 0xa084,
+	0x00ff, 0xa096, 0x0011, 0x0040, 0x2c85, 0xa096, 0x0019, 0x0040,
+	0x2c85, 0xa096, 0x0015, 0x00c0, 0x2bd7, 0x810f, 0xa18c, 0x00ff,
+	0x0040, 0x2bd7, 0x710e, 0x700c, 0x8001, 0x0040, 0x2cb6, 0x700e,
+	0x1078, 0x35ba, 0x0040, 0x2bd7, 0x2009, 0x0020, 0x2061, 0xa6d2,
+	0x6224, 0x6328, 0x642c, 0x6530, 0xa290, 0x0040, 0xa399, 0x0000,
+	0xa4a1, 0x0000, 0xa5a9, 0x0000, 0x1078, 0x3604, 0x701b, 0x2ca9,
+	0x007c, 0x6834, 0xa084, 0x00ff, 0xa096, 0x0002, 0x0040, 0x2cb4,
+	0xa096, 0x000a, 0x00c0, 0x2bd7, 0x0078, 0x2c8b, 0x7010, 0x2068,
+	0x6838, 0xc0fd, 0x683a, 0x1078, 0x4431, 0x00c0, 0x2cc4, 0x7007,
+	0x0003, 0x701b, 0x2cc6, 0x007c, 0x1078, 0x4b51, 0x127e, 0x2091,
+	0x8000, 0x20a9, 0x0005, 0x2099, 0xa689, 0x530a, 0x2100, 0xa210,
+	0xa399, 0x0000, 0xa4a1, 0x0000, 0xa5a9, 0x0000, 0xad80, 0x000d,
+	0x2009, 0x0020, 0x127f, 0x0078, 0x3608, 0x61a4, 0x7824, 0x60a6,
+	0x0078, 0x2bad, 0x2091, 0x8000, 0x7823, 0x4000, 0x7827, 0x4953,
+	0x782b, 0x5020, 0x782f, 0x2020, 0x2009, 0x017f, 0x2104, 0x7832,
+	0x3f00, 0x7836, 0x2061, 0x0100, 0x6200, 0x2061, 0x0200, 0x603c,
+	0x8007, 0xa205, 0x783a, 0x2009, 0x04fd, 0x2104, 0x783e, 0x781b,
+	0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2071, 0x0010, 0x20c1,
+	0x00f0, 0xa08a, 0x0003, 0x00c8, 0x0427, 0x0078, 0x0423, 0x81ff,
+	0x00c0, 0x2bd7, 0x7924, 0x810f, 0xa18c, 0x00ff, 0x1078, 0x45c4,
+	0x00c0, 0x2bdb, 0x7e38, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0048,
+	0x2d23, 0x0078, 0x2bdb, 0x7c28, 0x7d2c, 0x1078, 0x47a4, 0xd28c,
+	0x00c0, 0x2d2e, 0x1078, 0x4736, 0x0078, 0x2d30, 0x1078, 0x4772,
+	0x00c0, 0x2d5a, 0x2061, 0xad00, 0x127e, 0x2091, 0x8000, 0x6000,
+	0xa086, 0x0000, 0x0040, 0x2d48, 0x6010, 0xa06d, 0x0040, 0x2d48,
+	0x683c, 0xa406, 0x00c0, 0x2d48, 0x6840, 0xa506, 0x0040, 0x2d53,
+	0x127f, 0xace0, 0x0010, 0x2001, 0xa616, 0x2004, 0xac02, 0x00c8,
+	0x2bd7, 0x0078, 0x2d34, 0x1078, 0x8a01, 0x127f, 0x0040, 0x2bd7,
+	0x0078, 0x2bad, 0xa00e, 0x2001, 0x0005, 0x1078, 0x4b51, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x8f85, 0x1078, 0x4a73, 0x127f, 0x0078,
+	0x2bad, 0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35d2, 0x0040, 0x2bdb,
+	0x1078, 0x4673, 0x0040, 0x2bd7, 0x1078, 0x47b2, 0x0040, 0x2bd7,
+	0x0078, 0x2bad, 0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35e4, 0x0040,
+	0x2bdb, 0x1078, 0x482f, 0x0040, 0x2bd7, 0x2019, 0x0005, 0x1078,
+	0x47d3, 0x0040, 0x2bd7, 0x7828, 0xa08a, 0x1000, 0x00c8, 0x2bdb,
+	0x8003, 0x800b, 0x810b, 0xa108, 0x1078, 0x5a52, 0x0078, 0x2bad,
+	0x127e, 0x2091, 0x8000, 0x81ff, 0x0040, 0x2da2, 0x2009, 0x0001,
+	0x0078, 0x2dd3, 0x2029, 0x00ff, 0x6450, 0x2400, 0xa506, 0x0040,
+	0x2dcd, 0x2508, 0x1078, 0x45c4, 0x00c0, 0x2dcd, 0x1078, 0x482f,
+	0x00c0, 0x2db8, 0x2009, 0x0002, 0x62ac, 0x2518, 0x0078, 0x2dd3,
+	0x2019, 0x0004, 0x1078, 0x47d3, 0x00c0, 0x2dc2, 0x2009, 0x0006,
+	0x0078, 0x2dd3, 0x7824, 0xa08a, 0x1000, 0x00c8, 0x2dd6, 0x8003,
+	0x800b, 0x810b, 0xa108, 0x1078, 0x5a52, 0x8529, 0x00c8, 0x2da5,
+	0x127f, 0x0078, 0x2bad, 0x127f, 0x0078, 0x2bd7, 0x127f, 0x0078,
+	0x2bdb, 0x1078, 0x35d2, 0x0040, 0x2bdb, 0x1078, 0x46e7, 0x1078,
+	0x47a4, 0x0078, 0x2bad, 0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35d2,
+	0x0040, 0x2bdb, 0x1078, 0x46d6, 0x1078, 0x47a4, 0x0078, 0x2bad,
+	0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35d2, 0x0040, 0x2bdb, 0x1078,
+	0x4775, 0x0040, 0x2bd7, 0x1078, 0x4484, 0x1078, 0x472f, 0x1078,
+	0x47a4, 0x0078, 0x2bad, 0x1078, 0x35d2, 0x0040, 0x2bdb, 0x1078,
+	0x4673, 0x0040, 0x2bd7, 0x62a0, 0x2019, 0x0005, 0x0c7e, 0x1078,
+	0x47e9, 0x0c7f, 0x1078, 0x5f01, 0x077e, 0x2039, 0x0000, 0x1078,
+	0x5e0a, 0x2009, 0x0000, 0x1078, 0x9f8b, 0x077f, 0x1078, 0x47a4,
+	0x0078, 0x2bad, 0x1078, 0x35d2, 0x0040, 0x2bdb, 0x1078, 0x47a4,
+	0x2208, 0x0078, 0x2bad, 0x157e, 0x0d7e, 0x0e7e, 0x2069, 0xa714,
+	0x6810, 0x6914, 0xa10a, 0x00c8, 0x2e37, 0x2009, 0x0000, 0x6816,
+	0x2011, 0x0000, 0x2019, 0x0000, 0x20a9, 0x00ff, 0x2069, 0xa735,
+	0x2d04, 0xa075, 0x0040, 0x2e4c, 0x704c, 0x1078, 0x2e56, 0xa210,
+	0x7080, 0x1078, 0x2e56, 0xa318, 0x8d68, 0x00f0, 0x2e40, 0x2300,
+	0xa218, 0x0e7f, 0x0d7f, 0x157f, 0x0078, 0x2bad, 0x0f7e, 0x017e,
+	0xa07d, 0x0040, 0x2e65, 0x2001, 0x0000, 0x8000, 0x2f0c, 0x81ff,
+	0x0040, 0x2e65, 0x2178, 0x0078, 0x2e5d, 0x017f, 0x0f7f, 0x007c,
+	0x2069, 0xa714, 0x6910, 0x62a8, 0x0078, 0x2bad, 0x81ff, 0x00c0,
+	0x2bd7, 0x6150, 0xa190, 0x29c0, 0x2214, 0xa294, 0x00ff, 0x6070,
+	0xa084, 0xff00, 0xa215, 0x636c, 0x67cc, 0xd79c, 0x0040, 0x2e84,
+	0x2031, 0x0001, 0x0078, 0x2e86, 0x2031, 0x0000, 0x7e3a, 0x7f3e,
+	0x0078, 0x2bad, 0x6140, 0x6244, 0x2019, 0xa8a2, 0x231c, 0x0078,
+	0x2bad, 0x127e, 0x2091, 0x8000, 0x6134, 0x6338, 0xa006, 0x2010,
+	0x127f, 0x0078, 0x2bad, 0x1078, 0x35e4, 0x0040, 0x2bdb, 0x6244,
+	0x6338, 0x0078, 0x2bad, 0x6140, 0x6244, 0x7824, 0x6042, 0x7b28,
+	0x6346, 0x2069, 0xa652, 0x831f, 0xa305, 0x6816, 0x782c, 0x2069,
+	0xa8a2, 0x2d1c, 0x206a, 0x0078, 0x2bad, 0x017e, 0x127e, 0x2091,
+	0x8000, 0x7824, 0x6036, 0xd094, 0x0040, 0x2ec8, 0x7828, 0xa085,
+	0x0001, 0x2009, 0xa8ab, 0x200a, 0x2001, 0xffff, 0x1078, 0x5ae6,
+	0x782c, 0x603a, 0x127f, 0x017f, 0x0078, 0x2bad, 0x1078, 0x35e4,
+	0x0040, 0x2bdb, 0x7828, 0xa00d, 0x0040, 0x2bdb, 0x782c, 0xa005,
+	0x0040, 0x2bdb, 0x6244, 0x6146, 0x6338, 0x603a, 0x0078, 0x2bad,
+	0x2001, 0xa600, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2bd7, 0x0c7e,
+	0x2061, 0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196, 0x00ff,
+	0x00c0, 0x2ef7, 0x6030, 0xa085, 0xff00, 0x0078, 0x2f06, 0xa182,
+	0x007f, 0x00c8, 0x2f30, 0xa188, 0x29c0, 0x210c, 0xa18c, 0x00ff,
+	0x6030, 0xa116, 0x0040, 0x2f30, 0x810f, 0xa105, 0x127e, 0x2091,
+	0x8000, 0x007e, 0x1078, 0x76c7, 0x007f, 0x0040, 0x2f2c, 0x601a,
+	0x600b, 0xbc09, 0x601f, 0x0001, 0x1078, 0x35ba, 0x0040, 0x2f33,
+	0x6837, 0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x701b, 0x2f8e, 0x2d00, 0x6012, 0x2009, 0x0032, 0x1078,
+	0x775c, 0x127f, 0x0c7f, 0x007c, 0x127f, 0x0c7f, 0x0078, 0x2bd7,
+	0x0c7f, 0x0078, 0x2bdb, 0x1078, 0x772d, 0x0078, 0x2f2c, 0x2001,
+	0xa600, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2bd7, 0x0c7e, 0x2061,
+	0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196, 0x00ff, 0x00c0,
+	0x2f4e, 0x6030, 0xa085, 0xff00, 0x0078, 0x2f5d, 0xa182, 0x007f,
+	0x00c8, 0x2f87, 0xa188, 0x29c0, 0x210c, 0xa18c, 0x00ff, 0x6030,
+	0xa116, 0x0040, 0x2f87, 0x810f, 0xa105, 0x127e, 0x2091, 0x8000,
+	0x007e, 0x1078, 0x76c7, 0x007f, 0x0040, 0x2f83, 0x601a, 0x600b,
+	0xbc05, 0x601f, 0x0001, 0x1078, 0x35ba, 0x0040, 0x2f8a, 0x6837,
+	0x0000, 0x7007, 0x0003, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x701b, 0x2f8e, 0x2d00, 0x6012, 0x2009, 0x0032, 0x1078, 0x775c,
+	0x127f, 0x0c7f, 0x007c, 0x127f, 0x0c7f, 0x0078, 0x2bd7, 0x0c7f,
+	0x0078, 0x2bdb, 0x1078, 0x772d, 0x0078, 0x2f83, 0x6830, 0xa086,
+	0x0100, 0x0040, 0x2bd7, 0x0078, 0x2bad, 0x2061, 0xa933, 0x127e,
+	0x2091, 0x8000, 0x6000, 0xd084, 0x0040, 0x2fa6, 0x6104, 0x6208,
+	0x2019, 0xa612, 0x231c, 0x127f, 0x0078, 0x2bad, 0x127f, 0x0078,
+	0x2bdb, 0x81ff, 0x00c0, 0x2bd7, 0x127e, 0x2091, 0x8000, 0x6248,
+	0x6064, 0xa202, 0x0048, 0x2fbd, 0xa085, 0x0001, 0x1078, 0x256a,
+	0x1078, 0x3c9e, 0x127f, 0x0078, 0x2bad, 0x127f, 0x0078, 0x2bdb,
+	0x127e, 0x2091, 0x8000, 0x20a9, 0x0012, 0x2001, 0xa640, 0x20a0,
+	0xa006, 0x40a4, 0x127f, 0x0078, 0x2bad, 0x7d38, 0x7c3c, 0x0078,
+	0x2c5f, 0x7824, 0xa09c, 0x00ff, 0xa39a, 0x0003, 0x00c8, 0x2bd7,
+	0x6250, 0xa084, 0xff00, 0x8007, 0xa206, 0x00c0, 0x2fe9, 0x2001,
+	0xa640, 0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0078,
+	0x3608, 0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35e4, 0x0040, 0x2bdb,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x2bd7, 0x0c7e,
+	0x1078, 0x35ba, 0x0c7f, 0x0040, 0x2bd7, 0x6837, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x1078, 0x8e4a, 0x0040, 0x2bd7, 0x7007, 0x0003,
+	0x701b, 0x300b, 0x007c, 0x6830, 0xa086, 0x0100, 0x0040, 0x2bd7,
+	0xad80, 0x000e, 0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38,
+	0x0078, 0x3608, 0x1078, 0x35ba, 0x0040, 0x2bd7, 0x1078, 0x42dd,
+	0x2009, 0x001c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3604,
+	0x701b, 0x302b, 0x007c, 0xade8, 0x000d, 0x6800, 0xa005, 0x0040,
+	0x2bdb, 0x6804, 0xd0ac, 0x0040, 0x3038, 0xd0a4, 0x0040, 0x2bdb,
+	0xd094, 0x0040, 0x3043, 0x0c7e, 0x2061, 0x0100, 0x6104, 0xa18c,
+	0xffdf, 0x6106, 0x0c7f, 0xd08c, 0x0040, 0x304e, 0x0c7e, 0x2061,
+	0x0100, 0x6104, 0xa18d, 0x0010, 0x6106, 0x0c7f, 0x2009, 0x0100,
+	0x210c, 0xa18a, 0x0002, 0x0048, 0x3063, 0xd084, 0x0040, 0x3063,
+	0x6a28, 0xa28a, 0x007f, 0x00c8, 0x2bdb, 0xa288, 0x29c0, 0x210c,
+	0xa18c, 0x00ff, 0x6156, 0xd0dc, 0x0040, 0x306c, 0x6828, 0xa08a,
+	0x007f, 0x00c8, 0x2bdb, 0x6052, 0x6808, 0xa08a, 0x0100, 0x0048,
+	0x2bdb, 0xa08a, 0x0841, 0x00c8, 0x2bdb, 0xa084, 0x0007, 0x00c0,
+	0x2bdb, 0x680c, 0xa005, 0x0040, 0x2bdb, 0x6810, 0xa005, 0x0040,
+	0x2bdb, 0x6848, 0x6940, 0xa10a, 0x00c8, 0x2bdb, 0x8001, 0x0040,
+	0x2bdb, 0x684c, 0x6944, 0xa10a, 0x00c8, 0x2bdb, 0x8001, 0x0040,
+	0x2bdb, 0x6804, 0xd0fc, 0x0040, 0x30c2, 0x1078, 0x35ba, 0x0040,
+	0x2bd7, 0x2009, 0x0014, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0xa290,
+	0x0038, 0xa399, 0x0000, 0x1078, 0x3604, 0x701b, 0x30a8, 0x007c,
+	0xade8, 0x000d, 0x20a9, 0x0014, 0x2d98, 0x2069, 0xa66e, 0x2da0,
+	0x53a3, 0x7010, 0xa0e8, 0x000d, 0x2001, 0xa672, 0x200c, 0xd1e4,
+	0x0040, 0x30c2, 0x0c7e, 0x2061, 0x0100, 0x6004, 0xa085, 0x0b00,
+	0x6006, 0x0c7f, 0x20a9, 0x001c, 0x2d98, 0x2069, 0xa652, 0x2da0,
+	0x53a3, 0x6814, 0xa08c, 0x00ff, 0x6142, 0x8007, 0xa084, 0x00ff,
+	0x6046, 0x1078, 0x4eae, 0x1078, 0x49ce, 0x1078, 0x4a3e, 0x6000,
+	0xa086, 0x0000, 0x00c0, 0x314d, 0x6808, 0x602a, 0x1078, 0x21f7,
+	0x6818, 0x691c, 0x6a20, 0x6b24, 0x8007, 0x810f, 0x8217, 0x831f,
+	0x6016, 0x611a, 0x621e, 0x6322, 0x6c04, 0xd4f4, 0x0040, 0x30fa,
+	0x6830, 0x6934, 0x6a38, 0x6b3c, 0x8007, 0x810f, 0x8217, 0x831f,
+	0x0078, 0x30fc, 0xa084, 0xf0ff, 0x6006, 0x610a, 0x620e, 0x6312,
+	0x1078, 0x5b19, 0x6904, 0xd1fc, 0x0040, 0x312f, 0x0c7e, 0x2009,
+	0x0000, 0x20a9, 0x0001, 0x6b70, 0xd384, 0x0040, 0x312c, 0x0078,
+	0x3116, 0x839d, 0x00c8, 0x312c, 0x3508, 0x8109, 0x1078, 0x5480,
+	0x6878, 0x6016, 0x6874, 0x2008, 0xa084, 0xff00, 0x8007, 0x600a,
+	0xa184, 0x00ff, 0x6006, 0x8108, 0x00c0, 0x312a, 0x6003, 0x0003,
+	0x0078, 0x312c, 0x6003, 0x0001, 0x00f0, 0x3111, 0x0c7f, 0x0c7e,
+	0x2061, 0x0100, 0x602f, 0x0040, 0x602f, 0x0000, 0x0c7f, 0x1078,
+	0x3819, 0x0040, 0x313d, 0x1078, 0x256a, 0x60c0, 0xa005, 0x0040,
+	0x3149, 0x6003, 0x0001, 0x2091, 0x301d, 0x1078, 0x4224, 0x0078,
+	0x314d, 0x6003, 0x0004, 0x2091, 0x301d, 0x0078, 0x2bad, 0x6000,
+	0xa086, 0x0000, 0x0040, 0x2bd7, 0x2069, 0xa652, 0x7830, 0x6842,
+	0x7834, 0x6846, 0x6804, 0xd0fc, 0x0040, 0x3162, 0x2009, 0x0030,
+	0x0078, 0x3164, 0x2009, 0x001c, 0x2d00, 0x7a2c, 0x7b28, 0x7c3c,
+	0x7d38, 0x0078, 0x3608, 0xa006, 0x1078, 0x256a, 0x81ff, 0x00c0,
+	0x2bd7, 0x1078, 0x42dd, 0x1078, 0x4224, 0x0078, 0x2bad, 0x81ff,
+	0x00c0, 0x2bd7, 0x6184, 0x81ff, 0x0040, 0x3191, 0x703f, 0x0000,
+	0x2001, 0xacc0, 0x2009, 0x0040, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x3608, 0x701b, 0x2baa, 0x127f,
+	0x007c, 0x703f, 0x0001, 0x0d7e, 0x2069, 0xacc0, 0x20a9, 0x0040,
+	0x20a1, 0xacc0, 0x2019, 0xffff, 0x43a4, 0x6550, 0xa588, 0x29c0,
+	0x210c, 0xa18c, 0x00ff, 0x216a, 0xa00e, 0x2011, 0x0002, 0x2100,
+	0xa506, 0x0040, 0x31c3, 0x1078, 0x45c4, 0x00c0, 0x31c3, 0x6014,
+	0x821c, 0x0048, 0x31bb, 0xa398, 0xacc0, 0xa085, 0xff00, 0x8007,
+	0x201a, 0x0078, 0x31c2, 0xa398, 0xacc0, 0x2324, 0xa4a4, 0xff00,
+	0xa405, 0x201a, 0x8210, 0x8108, 0xa182, 0x0080, 0x00c8, 0x31ca,
+	0x0078, 0x31a7, 0x8201, 0x8007, 0x2d0c, 0xa105, 0x206a, 0x0d7f,
+	0x20a9, 0x0040, 0x20a1, 0xacc0, 0x2099, 0xacc0, 0x1078, 0x4281,
+	0x0078, 0x3180, 0x1078, 0x35e4, 0x0040, 0x2bdb, 0x0c7e, 0x1078,
+	0x35ba, 0x0c7f, 0x00c0, 0x31e8, 0x2009, 0x0002, 0x0078, 0x2bd7,
+	0x2001, 0xa653, 0x2004, 0xd0b4, 0x0040, 0x320f, 0x6000, 0xd08c,
+	0x00c0, 0x320f, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0,
+	0x320f, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x1078, 0x8e9e,
+	0x00c0, 0x3206, 0x2009, 0x0003, 0x0078, 0x2bd7, 0x7007, 0x0003,
+	0x701b, 0x320b, 0x007c, 0x1078, 0x35e4, 0x0040, 0x2bdb, 0x20a9,
+	0x002b, 0x2c98, 0xade8, 0x0002, 0x2da0, 0x53a3, 0x20a9, 0x0004,
+	0xac80, 0x0006, 0x2098, 0xad80, 0x0006, 0x20a0, 0x1078, 0x4281,
+	0x20a9, 0x0004, 0xac80, 0x000a, 0x2098, 0xad80, 0x000a, 0x20a0,
+	0x1078, 0x4281, 0x2d00, 0x2009, 0x002b, 0x7a2c, 0x7b28, 0x7c3c,
+	0x7d38, 0x0078, 0x3608, 0x81ff, 0x00c0, 0x2bd7, 0x1078, 0x35d2,
+	0x0040, 0x2bdb, 0x1078, 0x47bd, 0x0078, 0x2bad, 0x81ff, 0x00c0,
+	0x2bd7, 0x7828, 0xa08a, 0x1000, 0x00c8, 0x2bdb, 0x1078, 0x35e4,
+	0x0040, 0x2bdb, 0x1078, 0x482f, 0x0040, 0x2bd7, 0x2019, 0x0004,
+	0x1078, 0x47d3, 0x7924, 0x810f, 0x7a28, 0x1078, 0x3259, 0x0078,
+	0x2bad, 0xa186, 0x00ff, 0x0040, 0x3261, 0x1078, 0x3271, 0x0078,
+	0x3270, 0x2029, 0x007e, 0x2061, 0xa600, 0x6450, 0x2400, 0xa506,
+	0x0040, 0x326d, 0x2508, 0x1078, 0x3271, 0x8529, 0x00c8, 0x3266,
+	0x007c, 0x1078, 0x45c4, 0x00c0, 0x327c, 0x2200, 0x8003, 0x800b,
+	0x810b, 0xa108, 0x1078, 0x5a52, 0x007c, 0x81ff, 0x00c0, 0x2bd7,
+	0x1078, 0x35d2, 0x0040, 0x2bdb, 0x1078, 0x4673, 0x0040, 0x2bd7,
+	0x1078, 0x47c8, 0x0078, 0x2bad, 0x81ff, 0x00c0, 0x2bd7, 0x1078,
+	0x35d2, 0x0040, 0x2bdb, 0x1078, 0x4673, 0x0040, 0x2bd7, 0x1078,
+	0x47b2, 0x0078, 0x2bad, 0x6100, 0x0078, 0x2bad, 0x1078, 0x35e4,
+	0x0040, 0x2bdb, 0x2001, 0xa600, 0x2004, 0xa086, 0x0003, 0x00c0,
+	0x2bd7, 0x0d7e, 0xace8, 0x000a, 0x7924, 0xd184, 0x0040, 0x32b2,
+	0xace8, 0x0006, 0x680c, 0x8007, 0x783e, 0x6808, 0x8007, 0x783a,
+	0x6b04, 0x831f, 0x6a00, 0x8217, 0x0d7f, 0x6100, 0xa18c, 0x0200,
+	0x0078, 0x2bad, 0xa006, 0x1078, 0x256a, 0x7824, 0xa084, 0x00ff,
+	0xa086, 0x00ff, 0x0040, 0x32cf, 0x81ff, 0x00c0, 0x2bd7, 0x1078,
+	0x42dd, 0x7828, 0xa08a, 0x1000, 0x00c8, 0x2bdb, 0x7924, 0xa18c,
+	0xff00, 0x810f, 0xa186, 0x00ff, 0x0040, 0x32e5, 0xa182, 0x007f,
+	0x00c8, 0x2bdb, 0x2100, 0x1078, 0x2564, 0x027e, 0x0c7e, 0x127e,
+	0x2091, 0x8000, 0x2061, 0xa8c4, 0x601b, 0x0000, 0x601f, 0x0000,
+	0x2011, 0x0003, 0x1078, 0x70e0, 0x2011, 0x0002, 0x1078, 0x70ea,
+	0x1078, 0x6fc4, 0x037e, 0x2019, 0x0000, 0x1078, 0x7058, 0x037f,
+	0x2061, 0x0100, 0x6030, 0xa084, 0x00ff, 0x810f, 0xa105, 0x604a,
+	0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x002d, 0x2011, 0x4259,
+	0x1078, 0x5add, 0x7924, 0xa18c, 0xff00, 0x810f, 0x7a28, 0x1078,
+	0x3259, 0x127f, 0x0c7f, 0x027f, 0x0078, 0x2bad, 0x7924, 0xa18c,
+	0xff00, 0x810f, 0x0c7e, 0x1078, 0x455c, 0x2c08, 0x0c7f, 0x00c0,
+	0x2bdb, 0x0078, 0x2bad, 0x81ff, 0x0040, 0x3332, 0x2009, 0x0001,
+	0x0078, 0x2bd7, 0x60cc, 0xd09c, 0x00c0, 0x333a, 0x2009, 0x0005,
+	0x0078, 0x2bd7, 0x1078, 0x35ba, 0x00c0, 0x3342, 0x2009, 0x0002,
+	0x0078, 0x2bd7, 0x7924, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078,
+	0x3604, 0x701b, 0x334c, 0x007c, 0x2009, 0x0080, 0x1078, 0x45c4,
+	0x00c0, 0x3359, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x0040,
+	0x335d, 0x2021, 0x400a, 0x0078, 0x2baf, 0x0d7e, 0xade8, 0x000d,
+	0x6900, 0x6a08, 0x6b0c, 0x6c10, 0x6d14, 0x6e18, 0x6820, 0xa0be,
+	0x0100, 0x0040, 0x33d0, 0xa0be, 0x0112, 0x0040, 0x33d0, 0xa0be,
+	0x0113, 0x0040, 0x33d0, 0xa0be, 0x0114, 0x0040, 0x33d0, 0xa0be,
+	0x0117, 0x0040, 0x33d0, 0xa0be, 0x011a, 0x0040, 0x33d0, 0xa0be,
+	0x0121, 0x0040, 0x33c6, 0xa0be, 0x0131, 0x0040, 0x33c6, 0xa0be,
+	0x0171, 0x0040, 0x33d0, 0xa0be, 0x0173, 0x0040, 0x33d0, 0xa0be,
+	0x01a1, 0x00c0, 0x3398, 0x6830, 0x8007, 0x6832, 0x0078, 0x33d6,
+	0xa0be, 0x0212, 0x0040, 0x33cc, 0xa0be, 0x0213, 0x0040, 0x33cc,
+	0xa0be, 0x0214, 0x0040, 0x33be, 0xa0be, 0x0217, 0x0040, 0x33b8,
+	0xa0be, 0x021a, 0x00c0, 0x33b1, 0x6838, 0x8007, 0x683a, 0x0078,
+	0x33d0, 0xa0be, 0x0300, 0x0040, 0x33d0, 0x0d7f, 0x0078, 0x2bdb,
+	0xad80, 0x0010, 0x20a9, 0x0007, 0x1078, 0x3418, 0xad80, 0x000e,
+	0x20a9, 0x0001, 0x1078, 0x3418, 0x0078, 0x33d0, 0xad80, 0x000c,
+	0x1078, 0x3426, 0x0078, 0x33d6, 0xad80, 0x000e, 0x1078, 0x3426,
+	0xad80, 0x000c, 0x20a9, 0x0001, 0x1078, 0x3418, 0x0c7e, 0x1078,
+	0x35ba, 0x0040, 0x3409, 0x6838, 0xc0fd, 0x683a, 0x6837, 0x0119,
+	0x6853, 0x0000, 0x684f, 0x0020, 0x685b, 0x0001, 0x810b, 0x697e,
+	0x6883, 0x0000, 0x6a86, 0x6b8a, 0x6c8e, 0x6d92, 0x6996, 0x689b,
+	0x0000, 0x0c7f, 0x0d7f, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x6823, 0x0000, 0x6804, 0x2068, 0x1078, 0x8e66, 0x00c0, 0x3404,
+	0x2009, 0x0003, 0x0078, 0x2bd7, 0x7007, 0x0003, 0x701b, 0x340f,
+	0x007c, 0x0c7f, 0x0d7f, 0x2009, 0x0002, 0x0078, 0x2bd7, 0x6820,
+	0xa086, 0x8001, 0x00c0, 0x2bad, 0x2009, 0x0004, 0x0078, 0x2bd7,
+	0x017e, 0x2008, 0x2044, 0x8000, 0x204c, 0x8000, 0x290a, 0x8108,
+	0x280a, 0x8108, 0x00f0, 0x341a, 0x017f, 0x007c, 0x017e, 0x0a7e,
+	0x0b7e, 0x2008, 0x2044, 0x8000, 0x204c, 0x8000, 0x2054, 0x8000,
+	0x205c, 0x2b0a, 0x8108, 0x2a0a, 0x8108, 0x290a, 0x8108, 0x280a,
+	0x0b7f, 0x0a7f, 0x017f, 0x007c, 0x81ff, 0x0040, 0x3443, 0x2009,
+	0x0001, 0x0078, 0x2bd7, 0x60cc, 0xd09c, 0x00c0, 0x344b, 0x2009,
+	0x0005, 0x0078, 0x2bd7, 0x7924, 0x2140, 0xa18c, 0xff00, 0x810f,
+	0xa182, 0x0080, 0x0048, 0x2bdb, 0xa182, 0x00ff, 0x00c8, 0x2bdb,
+	0x7a2c, 0x7b28, 0x606c, 0xa306, 0x00c0, 0x3466, 0x6070, 0xa24e,
+	0x0040, 0x2bdb, 0xa9cc, 0xff00, 0x0040, 0x2bdb, 0x0c7e, 0x1078,
+	0x350f, 0x2c68, 0x0c7f, 0x0040, 0x349e, 0xa0c6, 0x4000, 0x00c0,
+	0x3484, 0x0c7e, 0x007e, 0x2d60, 0x2009, 0x0000, 0x1078, 0x489b,
+	0x00c0, 0x347b, 0xc185, 0x6000, 0xd0bc, 0x0040, 0x3480, 0xc18d,
+	0x007f, 0x0c7f, 0x0078, 0x349b, 0xa0c6, 0x4007, 0x00c0, 0x348b,
+	0x2408, 0x0078, 0x349b, 0xa0c6, 0x4008, 0x00c0, 0x3493, 0x2708,
+	0x2610, 0x0078, 0x349b, 0xa0c6, 0x4009, 0x00c0, 0x3499, 0x0078,
+	0x349b, 0x2001, 0x4006, 0x2020, 0x0078, 0x2baf, 0x2d00, 0x7022,
+	0x017e, 0x0b7e, 0x0c7e, 0x0e7e, 0x2c70, 0x1078, 0x76c7, 0x0040,
+	0x34e4, 0x2d00, 0x601a, 0x2001, 0xa657, 0x2004, 0xa084, 0x00ff,
+	0x6842, 0x2e58, 0x0e7f, 0x0e7e, 0x0c7e, 0x1078, 0x35ba, 0x0c7f,
+	0x2b70, 0x00c0, 0x34c5, 0x1078, 0x772d, 0x0e7f, 0x0c7f, 0x0b7f,
+	0x017f, 0x2009, 0x0002, 0x0078, 0x2bd7, 0x6837, 0x0000, 0x2d00,
+	0x6012, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x2880, 0x127f, 0x601f, 0x0001, 0x2001, 0x0000,
+	0x1078, 0x44ee, 0x2001, 0x0002, 0x1078, 0x4502, 0x2009, 0x0002,
+	0x1078, 0x775c, 0xa085, 0x0001, 0x0e7f, 0x0c7f, 0x0b7f, 0x017f,
+	0x00c0, 0x34ee, 0x2009, 0x0003, 0x0078, 0x2bd7, 0x7007, 0x0003,
+	0x701b, 0x34f3, 0x007c, 0x6830, 0xa086, 0x0100, 0x7020, 0x2060,
+	0x00c0, 0x3501, 0x2009, 0x0004, 0x6204, 0xa294, 0x00ff, 0x0078,
+	0x2bd7, 0x2009, 0x0000, 0x1078, 0x489b, 0x00c0, 0x3508, 0xc185,
+	0x6000, 0xd0bc, 0x0040, 0x350d, 0xc18d, 0x0078, 0x2bad, 0x0e7e,
+	0x0d7e, 0x2029, 0x0000, 0x2021, 0x0080, 0x20a9, 0x007f, 0x2071,
+	0xa7b5, 0x2e04, 0xa005, 0x00c0, 0x3524, 0x2100, 0xa406, 0x00c0,
+	0x3555, 0x2428, 0x0078, 0x3555, 0x2068, 0x6f10, 0x2700, 0xa306,
+	0x00c0, 0x3546, 0x6e14, 0x2600, 0xa206, 0x00c0, 0x3546, 0x2400,
+	0xa106, 0x00c0, 0x3542, 0x2d60, 0xd884, 0x0040, 0x356a, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x356a, 0x2001, 0x4000,
+	0x0078, 0x356b, 0x2001, 0x4007, 0x0078, 0x356b, 0x2400, 0xa106,
+	0x00c0, 0x3555, 0x6e14, 0x87ff, 0x00c0, 0x3551, 0x86ff, 0x0040,
+	0x3521, 0x2001, 0x4008, 0x0078, 0x356b, 0x8420, 0x8e70, 0x00f0,
+	0x3519, 0x85ff, 0x00c0, 0x3564, 0x2001, 0x4009, 0x0078, 0x356b,
+	0x2001, 0x0001, 0x0078, 0x356b, 0x1078, 0x455c, 0x00c0, 0x3560,
+	0x6312, 0x6216, 0xa006, 0xa005, 0x0d7f, 0x0e7f, 0x007c, 0x81ff,
+	0x00c0, 0x2bd7, 0x1078, 0x35ba, 0x0040, 0x2bd7, 0x6837, 0x0000,
+	0x6838, 0xc0fd, 0x683a, 0x7824, 0xa005, 0x0040, 0x2bdb, 0xa096,
+	0x00ff, 0x0040, 0x3587, 0xa092, 0x0004, 0x00c8, 0x2bdb, 0x2010,
+	0x2d18, 0x1078, 0x282f, 0x0040, 0x2bd7, 0x7007, 0x0003, 0x701b,
+	0x3592, 0x007c, 0x6830, 0xa086, 0x0100, 0x0040, 0x2bd7, 0x0078,
+	0x2bad, 0x7924, 0xa18c, 0xff00, 0x810f, 0xa182, 0x0080, 0x0048,
+	0x2bdb, 0xa182, 0x00ff, 0x00c8, 0x2bdb, 0x127e, 0x2091, 0x8000,
+	0x1078, 0x8d4b, 0x00c0, 0x35b7, 0xa190, 0xa735, 0x2204, 0xa065,
+	0x0040, 0x35b7, 0x1078, 0x42f8, 0x127f, 0x0078, 0x2bad, 0x127f,
+	0x0078, 0x2bd7, 0x1078, 0x138b, 0x0040, 0x35d1, 0xa006, 0x6802,
+	0x7010, 0xa005, 0x00c0, 0x35c9, 0x2d00, 0x7012, 0x7016, 0x0078,
+	0x35cf, 0x7014, 0x6802, 0x2060, 0x2d00, 0x6006, 0x7016, 0xad80,
+	0x000d, 0x007c, 0x7924, 0x810f, 0xa18c, 0x00ff, 0x1078, 0x45c4,
+	0x00c0, 0x35e1, 0x7e28, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0048,
+	0x35e2, 0xa066, 0x8cff, 0x007c, 0x7e24, 0x860f, 0xa18c, 0x00ff,
+	0x1078, 0x45c4, 0x00c0, 0x35f2, 0xa6b4, 0x00ff, 0xa682, 0x4000,
+	0x0048, 0x35f3, 0xa066, 0x8cff, 0x007c, 0x017e, 0x7110, 0x81ff,
+	0x0040, 0x3600, 0x2168, 0x6904, 0x1078, 0x13a4, 0x0078, 0x35f7,
+	0x7112, 0x7116, 0x017f, 0x007c, 0x2031, 0x0001, 0x0078, 0x360a,
+	0x2031, 0x0000, 0x2061, 0xa6d2, 0x6606, 0x6112, 0x600e, 0x6226,
+	0x632a, 0x642e, 0x6532, 0x2c10, 0x1078, 0x13db, 0x7007, 0x0002,
+	0x701b, 0x2bad, 0x007c, 0x0f7e, 0x127e, 0x2091, 0x8000, 0x2079,
+	0x0000, 0x2001, 0xa690, 0x2004, 0xa005, 0x00c0, 0x3636, 0x0068,
+	0x3636, 0x7818, 0xd084, 0x00c0, 0x3636, 0x7a22, 0x7b26, 0x7c2a,
+	0x781b, 0x0001, 0x2091, 0x4080, 0x0078, 0x365b, 0x017e, 0x0c7e,
+	0x0e7e, 0x2071, 0xa682, 0x7138, 0xa182, 0x0008, 0x0048, 0x3644,
+	0x7030, 0x2060, 0x0078, 0x3655, 0x7030, 0xa0e0, 0x0008, 0xac82,
+	0xa6d2, 0x0048, 0x364d, 0x2061, 0xa692, 0x2c00, 0x7032, 0x81ff,
+	0x00c0, 0x3653, 0x7036, 0x8108, 0x713a, 0x2262, 0x6306, 0x640a,
+	0x0e7f, 0x0c7f, 0x017f, 0x127f, 0x0f7f, 0x007c, 0x0e7e, 0x2071,
+	0xa682, 0x7038, 0xa005, 0x0040, 0x3697, 0x127e, 0x2091, 0x8000,
+	0x0068, 0x3696, 0x0f7e, 0x2079, 0x0000, 0x7818, 0xd084, 0x00c0,
+	0x3695, 0x0c7e, 0x7034, 0x2060, 0x2c04, 0x7822, 0x6004, 0x7826,
+	0x6008, 0x782a, 0x781b, 0x0001, 0x2091, 0x4080, 0x7038, 0x8001,
+	0x703a, 0xa005, 0x00c0, 0x368b, 0x7033, 0xa692, 0x7037, 0xa692,
+	0x0c7f, 0x0078, 0x3695, 0xac80, 0x0008, 0xa0fa, 0xa6d2, 0x0048,
+	0x3693, 0x2001, 0xa692, 0x7036, 0x0c7f, 0x0f7f, 0x127f, 0x0e7f,
+	0x007c, 0x027e, 0x2001, 0xa653, 0x2004, 0xd0c4, 0x0040, 0x36a4,
+	0x2011, 0x8014, 0x1078, 0x361b, 0x027f, 0x007c, 0x81ff, 0x00c0,
+	0x2bd7, 0x127e, 0x2091, 0x8000, 0x6030, 0xc08d, 0xc085, 0xc0ac,
+	0x6032, 0x1078, 0x4224, 0x127f, 0x0078, 0x2bad, 0x81ff, 0x00c0,
+	0x2bd7, 0x6000, 0xa086, 0x0003, 0x00c0, 0x2bd7, 0x2001, 0xa653,
+	0x2004, 0xd0ac, 0x00c0, 0x2bd7, 0x1078, 0x35e4, 0x0040, 0x2bdb,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x36d3, 0x7828,
+	0xa005, 0x0040, 0x2bad, 0x0c7e, 0x1078, 0x35ba, 0x0c7f, 0x0040,
+	0x2bd7, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a,
+	0x1078, 0x8f12, 0x0040, 0x2bd7, 0x7007, 0x0003, 0x701b, 0x36e9,
+	0x007c, 0x6830, 0xa086, 0x0100, 0x0040, 0x2bd7, 0x0078, 0x2bad,
+	0x2001, 0xa600, 0x2004, 0xa086, 0x0003, 0x00c0, 0x2bd7, 0x7f24,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x35ba, 0x0040, 0x2bd7,
+	0x2009, 0x0000, 0x2031, 0x0000, 0x7023, 0x0000, 0x702f, 0x0000,
+	0xad80, 0x0005, 0x7026, 0x20a0, 0x1078, 0x45c4, 0x00c0, 0x376d,
+	0x6004, 0xa0c4, 0x00ff, 0xa8c6, 0x0006, 0x0040, 0x371d, 0xa0c4,
+	0xff00, 0xa8c6, 0x0600, 0x00c0, 0x376d, 0x2001, 0xa653, 0x2004,
+	0xd0ac, 0x00c0, 0x372a, 0x1078, 0x489b, 0x00c0, 0x372a, 0xd79c,
+	0x0040, 0x376d, 0xd794, 0x00c0, 0x3730, 0xd784, 0x0040, 0x373c,
+	0xac80, 0x0006, 0x2098, 0x3400, 0x20a9, 0x0004, 0x53a3, 0x1078,
+	0x3426, 0xd794, 0x0040, 0x3745, 0xac80, 0x000a, 0x2098, 0x3400,
+	0x20a9, 0x0004, 0x53a3, 0x1078, 0x3426, 0x21a2, 0xd794, 0x0040,
+	0x3765, 0xac80, 0x0000, 0x2098, 0x94a0, 0x20a9, 0x0002, 0x53a3,
+	0xac80, 0x0003, 0x20a6, 0x94a0, 0xac80, 0x0004, 0x2098, 0x3400,
+	0x20a9, 0x0002, 0x53a3, 0x1078, 0x3418, 0xac80, 0x0026, 0x2098,
+	0x20a9, 0x0002, 0x53a3, 0x0078, 0x3766, 0x94a0, 0xd794, 0x0040,
+	0x376b, 0xa6b0, 0x000b, 0xa6b0, 0x0005, 0x8108, 0xd78c, 0x0040,
+	0x3777, 0xa186, 0x0100, 0x0040, 0x3788, 0x0078, 0x377b, 0xa186,
+	0x007e, 0x0040, 0x3788, 0xd794, 0x0040, 0x3782, 0xa686, 0x0020,
+	0x0078, 0x3784, 0xa686, 0x0028, 0x0040, 0x3791, 0x0078, 0x370c,
+	0x86ff, 0x00c0, 0x378f, 0x7120, 0x810b, 0x0078, 0x2bad, 0x702f,
+	0x0001, 0x711e, 0x7020, 0xa600, 0x7022, 0x772a, 0x2061, 0xa6d2,
+	0x6007, 0x0000, 0x6612, 0x7024, 0x600e, 0x6226, 0x632a, 0x642e,
+	0x6532, 0x2c10, 0x1078, 0x13db, 0x7007, 0x0002, 0x701b, 0x37a9,
+	0x007c, 0x702c, 0xa005, 0x00c0, 0x37bb, 0x711c, 0x7024, 0x20a0,
+	0x7728, 0x2031, 0x0000, 0x2061, 0xa6d2, 0x6224, 0x6328, 0x642c,
+	0x6530, 0x0078, 0x370c, 0x7120, 0x810b, 0x0078, 0x2bad, 0x2029,
+	0x007e, 0x7924, 0x7a28, 0x7b2c, 0x7c38, 0xa184, 0xff00, 0x8007,
+	0xa0e2, 0x0020, 0x0048, 0x2bdb, 0xa502, 0x0048, 0x2bdb, 0xa184,
+	0x00ff, 0xa0e2, 0x0020, 0x0048, 0x2bdb, 0xa502, 0x0048, 0x2bdb,
+	0xa284, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0048, 0x2bdb, 0xa502,
+	0x0048, 0x2bdb, 0xa284, 0x00ff, 0xa0e2, 0x0020, 0x0048, 0x2bdb,
+	0xa502, 0x0048, 0x2bdb, 0xa384, 0xff00, 0x8007, 0xa0e2, 0x0020,
+	0x0048, 0x2bdb, 0xa502, 0x0048, 0x2bdb, 0xa384, 0x00ff, 0xa0e2,
+	0x0020, 0x0048, 0x2bdb, 0xa502, 0x0048, 0x2bdb, 0xa484, 0xff00,
+	0x8007, 0xa0e2, 0x0020, 0x0048, 0x2bdb, 0xa502, 0x0048, 0x2bdb,
+	0xa484, 0x00ff, 0xa0e2, 0x0020, 0x0048, 0x2bdb, 0xa502, 0x0048,
+	0x2bdb, 0x2061, 0xa8a5, 0x6102, 0x6206, 0x630a, 0x640e, 0x0078,
+	0x2bad, 0x007e, 0x2001, 0xa653, 0x2004, 0xd0cc, 0x007f, 0x007c,
+	0x007e, 0x2001, 0xa672, 0x2004, 0xd0bc, 0x007f, 0x007c, 0x6164,
+	0x7a24, 0x6300, 0x82ff, 0x00c0, 0x3830, 0x7926, 0x0078, 0x2bad,
+	0x83ff, 0x00c0, 0x2bdb, 0x2001, 0xfff0, 0xa200, 0x00c8, 0x2bdb,
+	0x2019, 0xffff, 0x6068, 0xa302, 0xa200, 0x0048, 0x2bdb, 0x7926,
+	0x6266, 0x0078, 0x2bad, 0x2001, 0xa600, 0x2004, 0xa086, 0x0003,
+	0x00c0, 0x2bd7, 0x7c28, 0x7d24, 0x7e38, 0x7f2c, 0x1078, 0x35ba,
+	0x0040, 0x2bd7, 0x2009, 0x0000, 0x2019, 0x0000, 0x7023, 0x0000,
+	0x702f, 0x0000, 0xad80, 0x0003, 0x7026, 0x20a0, 0xa1e0, 0xa735,
+	0x2c64, 0x8cff, 0x0040, 0x387d, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x0006, 0x0040, 0x3872, 0x6004, 0xa084, 0xff00, 0xa086, 0x0600,
+	0x00c0, 0x387d, 0x6014, 0x20a2, 0x94a0, 0x6010, 0x8007, 0xa105,
+	0x8007, 0x20a2, 0x94a0, 0xa398, 0x0002, 0x8108, 0xa182, 0x00ff,
+	0x0040, 0x3888, 0xa386, 0x002a, 0x0040, 0x3891, 0x0078, 0x385e,
+	0x83ff, 0x00c0, 0x388f, 0x7120, 0x810c, 0x0078, 0x2bad, 0x702f,
+	0x0001, 0x711e, 0x7020, 0xa300, 0x7022, 0x2061, 0xa6d2, 0x6007,
+	0x0000, 0x6312, 0x7024, 0x600e, 0x6426, 0x652a, 0x662e, 0x6732,
+	0x2c10, 0x1078, 0x13db, 0x7007, 0x0002, 0x701b, 0x38a8, 0x007c,
+	0x702c, 0xa005, 0x00c0, 0x38b9, 0x711c, 0x7024, 0x20a0, 0x2019,
+	0x0000, 0x2061, 0xa6d2, 0x6424, 0x6528, 0x662c, 0x6730, 0x0078,
+	0x385e, 0x7120, 0x810c, 0x0078, 0x2bad, 0x81ff, 0x00c0, 0x2bd7,
+	0x60cc, 0xd09c, 0x0040, 0x2bd7, 0x1078, 0x35ba, 0x0040, 0x2bd7,
+	0x7924, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3604, 0x701b,
+	0x38d2, 0x007c, 0x0d7e, 0xade8, 0x000d, 0x6828, 0xa0be, 0x7000,
+	0x0040, 0x38e5, 0xa0be, 0x7100, 0x0040, 0x38e5, 0xa0be, 0x7200,
+	0x0040, 0x38e5, 0x0d7f, 0x0078, 0x2bdb, 0x6820, 0x6924, 0x1078,
+	0x254d, 0x00c0, 0x3910, 0x1078, 0x455c, 0x00c0, 0x3910, 0x7122,
+	0x6612, 0x6516, 0x6e18, 0x0c7e, 0x1078, 0x35ba, 0x0040, 0x3910,
+	0x1078, 0x35ba, 0x0040, 0x3910, 0x0c7f, 0x0d7f, 0x6837, 0x0000,
+	0x6838, 0xc0fd, 0x683a, 0x6823, 0x0000, 0x6804, 0x2068, 0x1078,
+	0x8e82, 0x0040, 0x2bd7, 0x7007, 0x0003, 0x701b, 0x3913, 0x007c,
+	0x0d7f, 0x0078, 0x2bd7, 0x7120, 0x1078, 0x298e, 0x6820, 0xa086,
+	0x8001, 0x0040, 0x2bd7, 0x2d00, 0x701e, 0x6804, 0xa080, 0x0002,
+	0x007e, 0x20a9, 0x002a, 0x2098, 0x20a0, 0x1078, 0x4281, 0x007f,
+	0xade8, 0x000d, 0x6a08, 0x6b0c, 0x6c10, 0x6d14, 0x2061, 0xa6d2,
+	0x6007, 0x0000, 0x6e00, 0x6f28, 0xa7c6, 0x7000, 0x00c0, 0x393a,
+	0x0078, 0x393e, 0xa7c6, 0x7100, 0x00c0, 0x3946, 0xa6c2, 0x0004,
+	0x0048, 0x2bdb, 0x2009, 0x0004, 0x0078, 0x3608, 0xa7c6, 0x7200,
+	0x00c0, 0x2bdb, 0xa6c2, 0x0054, 0x0048, 0x2bdb, 0x600e, 0x6013,
+	0x002a, 0x6226, 0x632a, 0x642e, 0x6532, 0x2c10, 0x1078, 0x13db,
+	0x7007, 0x0002, 0x701b, 0x395d, 0x007c, 0x701c, 0x2068, 0x6804,
+	0xa080, 0x0001, 0x2004, 0xa080, 0x0002, 0x007e, 0x20a9, 0x002a,
+	0x2098, 0x20a0, 0x1078, 0x4281, 0x007f, 0x2009, 0x002a, 0x2061,
+	0xa6d2, 0x6224, 0x6328, 0x642c, 0x6530, 0x0078, 0x3608, 0x81ff,
+	0x00c0, 0x2bd7, 0x792c, 0x2001, 0xa89d, 0x2102, 0x1078, 0x35d2,
+	0x0040, 0x2bdb, 0x1078, 0x4673, 0x0040, 0x2bd7, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x47de, 0x127f, 0x0078, 0x2bad, 0x7824, 0xd08c,
+	0x00c0, 0x3995, 0xd084, 0x0040, 0x31da, 0x1078, 0x35e4, 0x0040,
+	0x2bdb, 0x0c7e, 0x1078, 0x35ba, 0x0c7f, 0x00c0, 0x39a3, 0x2009,
+	0x0002, 0x0078, 0x2bd7, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x0040, 0x39b0, 0xa08e, 0x0004, 0x0040, 0x39b0, 0xa08e, 0x0005,
+	0x00c0, 0x39dd, 0x7824, 0xd08c, 0x0040, 0x39bb, 0x6000, 0xc08c,
+	0x6002, 0x0078, 0x39c5, 0x2001, 0xa653, 0x2004, 0xd0b4, 0x0040,
+	0x320f, 0x6000, 0xd08c, 0x00c0, 0x320f, 0x6837, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x1078, 0x8e9e, 0x00c0, 0x39d2, 0x2009, 0x0003,
+	0x0078, 0x2bd7, 0x7007, 0x0003, 0x701b, 0x39d7, 0x007c, 0x1078,
+	0x35e4, 0x0040, 0x2bdb, 0x0078, 0x320f, 0x2009, 0xa62f, 0x210c,
+	0x81ff, 0x0040, 0x39e7, 0x2009, 0x0001, 0x0078, 0x2bd7, 0x2001,
+	0xa600, 0x2004, 0xa086, 0x0003, 0x0040, 0x39f2, 0x2009, 0x0007,
+	0x0078, 0x2bd7, 0x2001, 0xa653, 0x2004, 0xd0ac, 0x0040, 0x39fc,
+	0x2009, 0x0008, 0x0078, 0x2bd7, 0x609c, 0xd0a4, 0x00c0, 0x3a03,
+	0xd0ac, 0x00c0, 0x320f, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x1078, 0x8f12, 0x00c0, 0x3a12, 0x2009, 0x0003,
+	0x0078, 0x2bd7, 0x7007, 0x0003, 0x701b, 0x3a17, 0x007c, 0x6830,
+	0xa086, 0x0100, 0x00c0, 0x3a20, 0x2009, 0x0004, 0x0078, 0x2bd7,
+	0x1078, 0x35e4, 0x0040, 0x2bdb, 0x0078, 0x39b2, 0x81ff, 0x2009,
+	0x0001, 0x00c0, 0x2bd7, 0x6000, 0xa086, 0x0003, 0x2009, 0x0007,
+	0x00c0, 0x2bd7, 0x2001, 0xa653, 0x2004, 0xd0ac, 0x2009, 0x0008,
+	0x00c0, 0x2bd7, 0x1078, 0x35e4, 0x0040, 0x2bdb, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x2009, 0x0009, 0x00c0, 0x2bd7, 0x0c7e,
+	0x1078, 0x35ba, 0x0c7f, 0x2009, 0x0002, 0x0040, 0x2bd7, 0x6837,
+	0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x7928, 0xa194,
+	0xff00, 0xa18c, 0x00ff, 0xa006, 0x82ff, 0x00c0, 0x3a65, 0xc0ed,
+	0x6952, 0x792c, 0x6956, 0x0078, 0x3a6e, 0xa28e, 0x0100, 0x00c0,
+	0x2bdb, 0xc0e5, 0x6853, 0x0000, 0x6857, 0x0000, 0x683e, 0x1078,
+	0x90bd, 0x2009, 0x0003, 0x0040, 0x2bd7, 0x7007, 0x0003, 0x701b,
+	0x3a7a, 0x007c, 0x6830, 0xa086, 0x0100, 0x2009, 0x0004, 0x0040,
+	0x2bd7, 0x0078, 0x2bad, 0x81ff, 0x2009, 0x0001, 0x00c0, 0x2bd7,
+	0x6000, 0xa086, 0x0003, 0x2009, 0x0007, 0x00c0, 0x2bd7, 0x1078,
+	0x35e4, 0x0040, 0x2bdb, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006,
+	0x2009, 0x0009, 0x00c0, 0x2bd7, 0x0c7e, 0x1078, 0x35ba, 0x0c7f,
+	0x2009, 0x0002, 0x0040, 0x2bd7, 0xad80, 0x000f, 0x2009, 0x0008,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x1078, 0x3604, 0x701b, 0x3ab1,
+	0x007c, 0x0d7e, 0xade8, 0x000f, 0x6800, 0xa086, 0x0500, 0x00c0,
+	0x3ac4, 0x6804, 0xa005, 0x00c0, 0x3ac4, 0x6808, 0xa084, 0xff00,
+	0x00c0, 0x3ac4, 0x0078, 0x3ac7, 0x0d7f, 0x00c0, 0x2bdb, 0x0d7f,
+	0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x0c7e,
+	0x1078, 0x35e4, 0x00c0, 0x3ad7, 0x0c7f, 0x0078, 0x2bdb, 0x1078,
+	0x9119, 0x2009, 0x0003, 0x0c7f, 0x0040, 0x2bd7, 0x7007, 0x0003,
+	0x701b, 0x3ae3, 0x007c, 0x6830, 0xa086, 0x0100, 0x2009, 0x0004,
+	0x0040, 0x2bd7, 0x0078, 0x2bad, 0x127e, 0x0c7e, 0x0e7e, 0x2061,
+	0x0100, 0x2071, 0xa600, 0x6044, 0xd0a4, 0x00c0, 0x3b15, 0xd084,
+	0x0040, 0x3afe, 0x1078, 0x3c75, 0x0078, 0x3b11, 0xd08c, 0x0040,
+	0x3b05, 0x1078, 0x3b8c, 0x0078, 0x3b11, 0xd094, 0x0040, 0x3b0c,
+	0x1078, 0x3b60, 0x0078, 0x3b11, 0xd09c, 0x0040, 0x3b11, 0x1078,
+	0x3b1f, 0x0e7f, 0x0c7f, 0x127f, 0x007c, 0x017e, 0x6128, 0xd19c,
+	0x00c0, 0x3b1c, 0xc19d, 0x612a, 0x017f, 0x0078, 0x3b11, 0x624c,
+	0xa286, 0xf0f0, 0x00c0, 0x3b30, 0x6048, 0xa086, 0xf0f0, 0x0040,
+	0x3b30, 0x624a, 0x6043, 0x0090, 0x6043, 0x0010, 0x0078, 0x3b5f,
+	0xa294, 0xff00, 0xa296, 0xf700, 0x0040, 0x3b45, 0x7134, 0xd1a4,
+	0x00c0, 0x3b45, 0x6240, 0xa294, 0x0010, 0x0040, 0x3b45, 0x2009,
+	0x00f7, 0x1078, 0x42a1, 0x0078, 0x3b5f, 0x6043, 0x0040, 0x6043,
+	0x0000, 0x7077, 0x0000, 0x708f, 0x0001, 0x70b3, 0x0000, 0x70cf,
+	0x0000, 0x2009, 0xacc0, 0x200b, 0x0000, 0x7087, 0x0000, 0x707b,
+	0x000f, 0x2009, 0x000f, 0x2011, 0x41d5, 0x1078, 0x5add, 0x007c,
+	0x157e, 0x7078, 0xa005, 0x00c0, 0x3b8a, 0x2011, 0x41d5, 0x1078,
+	0x5a45, 0x6040, 0xa094, 0x0010, 0xa285, 0x0020, 0x6042, 0x20a9,
+	0x00c8, 0x6044, 0xd08c, 0x00c0, 0x3b83, 0x00f0, 0x3b71, 0x6242,
+	0x708b, 0x0000, 0x6040, 0xa094, 0x0010, 0xa285, 0x0080, 0x6042,
+	0x6242, 0x0078, 0x3b8a, 0x6242, 0x708b, 0x0000, 0x707f, 0x0000,
+	0x0078, 0x3b8a, 0x157f, 0x007c, 0x707c, 0xa08a, 0x0003, 0x00c8,
+	0x3b95, 0x1079, 0x3b98, 0x0078, 0x3b97, 0x1078, 0x1332, 0x007c,
+	0x3b9b, 0x3bea, 0x3c74, 0x0f7e, 0x707f, 0x0001, 0x20e1, 0xa000,
+	0x20e1, 0x8700, 0x1078, 0x21f7, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x2079, 0xab00, 0x207b, 0x2200, 0x7807, 0x00ef, 0x780b, 0x0000,
+	0x780f, 0x00ef, 0x7813, 0x0138, 0x7817, 0x0000, 0x781b, 0x0000,
+	0x781f, 0x0000, 0x7823, 0xffff, 0x7827, 0xffff, 0x782b, 0x0000,
+	0x782f, 0x0000, 0x2079, 0xab0c, 0x207b, 0x1101, 0x7807, 0x0000,
+	0x2099, 0xa605, 0x20a1, 0xab0e, 0x20a9, 0x0004, 0x53a3, 0x2079,
+	0xab12, 0x207b, 0x0000, 0x7807, 0x0000, 0x2099, 0xab00, 0x20a1,
+	0x020b, 0x20a9, 0x0014, 0x53a6, 0x60c3, 0x000c, 0x600f, 0x0000,
+	0x1078, 0x420b, 0x0f7f, 0x7083, 0x0000, 0x6043, 0x0008, 0x6043,
+	0x0000, 0x007c, 0x0d7e, 0x7080, 0x7083, 0x0000, 0xa025, 0x0040,
+	0x3c5e, 0x6020, 0xd0b4, 0x00c0, 0x3c5c, 0x718c, 0x81ff, 0x0040,
+	0x3c4b, 0xa486, 0x000c, 0x00c0, 0x3c56, 0xa480, 0x0018, 0x8004,
+	0x20a8, 0x2011, 0xab80, 0x2019, 0xab00, 0x220c, 0x2304, 0xa106,
+	0x00c0, 0x3c22, 0x8210, 0x8318, 0x00f0, 0x3c05, 0x6043, 0x0004,
+	0x608b, 0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0006, 0x707f, 0x0002,
+	0x708b, 0x0002, 0x2009, 0x07d0, 0x2011, 0x41dc, 0x1078, 0x5add,
+	0x0078, 0x3c5c, 0x2069, 0xab80, 0x6930, 0xa18e, 0x1101, 0x00c0,
+	0x3c56, 0x6834, 0xa005, 0x00c0, 0x3c56, 0x6900, 0xa18c, 0x00ff,
+	0x00c0, 0x3c36, 0x6804, 0xa005, 0x0040, 0x3c4b, 0x2011, 0xab8e,
+	0x2019, 0xa605, 0x20a9, 0x0004, 0x220c, 0x2304, 0xa102, 0x0048,
+	0x3c49, 0x00c0, 0x3c56, 0x8210, 0x8318, 0x00f0, 0x3c3c, 0x0078,
+	0x3c56, 0x708f, 0x0000, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xab80, 0x20a1, 0x020b, 0x20a9, 0x0014, 0x53a6, 0x6043, 0x0008,
+	0x6043, 0x0000, 0x0078, 0x3c5e, 0x0d7f, 0x007c, 0x6020, 0xd0b4,
+	0x00c0, 0x3c5c, 0x60c3, 0x000c, 0x2011, 0xa8bb, 0x2013, 0x0000,
+	0x7083, 0x0000, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575,
+	0x1078, 0x6e06, 0x0078, 0x3c5c, 0x007c, 0x7088, 0xa08a, 0x001d,
+	0x00c8, 0x3c7e, 0x1079, 0x3c81, 0x0078, 0x3c80, 0x1078, 0x1332,
+	0x007c, 0x3cab, 0x3cba, 0x3ce9, 0x3d02, 0x3d2e, 0x3d5a, 0x3d86,
+	0x3dbc, 0x3de8, 0x3e10, 0x3e53, 0x3e7d, 0x3e9f, 0x3eb5, 0x3edb,
+	0x3eee, 0x3ef7, 0x3f2b, 0x3f57, 0x3f83, 0x3faf, 0x3fe5, 0x4030,
+	0x405f, 0x4081, 0x40c3, 0x40e9, 0x4102, 0x4103, 0x0c7e, 0x2061,
+	0xa600, 0x6003, 0x0007, 0x2061, 0x0100, 0x6004, 0xa084, 0xfff9,
+	0x6006, 0x0c7f, 0x007c, 0x608b, 0xbc94, 0x608f, 0xf0f0, 0x6043,
+	0x0002, 0x708b, 0x0001, 0x2009, 0x07d0, 0x2011, 0x41dc, 0x1078,
+	0x5add, 0x007c, 0x0f7e, 0x7080, 0xa086, 0x0014, 0x00c0, 0x3ce7,
+	0x6043, 0x0000, 0x6020, 0xd0b4, 0x00c0, 0x3ce7, 0x2079, 0xab80,
+	0x7a30, 0xa296, 0x1102, 0x00c0, 0x3ce5, 0x7834, 0xa005, 0x00c0,
+	0x3ce5, 0x7a38, 0xd2fc, 0x0040, 0x3cdb, 0x70b0, 0xa005, 0x00c0,
+	0x3cdb, 0x70b3, 0x0001, 0x2011, 0x41dc, 0x1078, 0x5a45, 0x708b,
+	0x0010, 0x1078, 0x3ef7, 0x0078, 0x3ce7, 0x1078, 0x4224, 0x0f7f,
+	0x007c, 0x708b, 0x0003, 0x6043, 0x0004, 0x2011, 0x41dc, 0x1078,
+	0x5a45, 0x1078, 0x4289, 0x20a3, 0x1102, 0x20a3, 0x0000, 0x20a9,
+	0x000a, 0x20a3, 0x0000, 0x00f0, 0x3cf9, 0x60c3, 0x0014, 0x1078,
+	0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040, 0x3d2c, 0x2011,
+	0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014, 0x00c0, 0x3d2a, 0x2079,
+	0xab80, 0x7a30, 0xa296, 0x1102, 0x00c0, 0x3d2a, 0x7834, 0xa005,
+	0x00c0, 0x3d2a, 0x7a38, 0xd2fc, 0x0040, 0x3d24, 0x70b0, 0xa005,
+	0x00c0, 0x3d24, 0x70b3, 0x0001, 0x708b, 0x0004, 0x1078, 0x3d2e,
+	0x0078, 0x3d2c, 0x1078, 0x4224, 0x0f7f, 0x007c, 0x708b, 0x0005,
+	0x1078, 0x4289, 0x20a3, 0x1103, 0x20a3, 0x0000, 0x3430, 0x2011,
+	0xab8e, 0x1078, 0x42d4, 0x00c0, 0x3d4c, 0x7074, 0xa005, 0x00c0,
+	0x3d4c, 0x7150, 0xa186, 0xffff, 0x0040, 0x3d4c, 0x1078, 0x419d,
+	0x0040, 0x3d4c, 0x1078, 0x42b8, 0x20a9, 0x0008, 0x2298, 0x26a0,
+	0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078,
+	0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040, 0x3d84, 0x2011,
+	0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014, 0x00c0, 0x3d82, 0x2079,
+	0xab80, 0x7a30, 0xa296, 0x1103, 0x00c0, 0x3d82, 0x7834, 0xa005,
+	0x00c0, 0x3d82, 0x7a38, 0xd2fc, 0x0040, 0x3d7c, 0x70b0, 0xa005,
+	0x00c0, 0x3d7c, 0x70b3, 0x0001, 0x708b, 0x0006, 0x1078, 0x3d86,
+	0x0078, 0x3d84, 0x1078, 0x4224, 0x0f7f, 0x007c, 0x708b, 0x0007,
+	0x1078, 0x4289, 0x20a3, 0x1104, 0x20a3, 0x0000, 0x3430, 0x2011,
+	0xab8e, 0x1078, 0x42d4, 0x00c0, 0x3dae, 0x7074, 0xa005, 0x00c0,
+	0x3dae, 0x7154, 0xa186, 0xffff, 0x0040, 0x3dae, 0xa180, 0x29c0,
+	0x200c, 0xa18c, 0xff00, 0x810f, 0x1078, 0x419d, 0x0040, 0x3dae,
+	0x1078, 0x3820, 0x0040, 0x3dae, 0x1078, 0x256a, 0x20a9, 0x0008,
+	0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040,
+	0x3de6, 0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014, 0x00c0,
+	0x3de4, 0x2079, 0xab80, 0x7a30, 0xa296, 0x1104, 0x00c0, 0x3de4,
+	0x7834, 0xa005, 0x00c0, 0x3de4, 0x7a38, 0xd2fc, 0x0040, 0x3dde,
+	0x70b0, 0xa005, 0x00c0, 0x3dde, 0x70b3, 0x0001, 0x708b, 0x0008,
+	0x1078, 0x3de8, 0x0078, 0x3de6, 0x1078, 0x4224, 0x0f7f, 0x007c,
+	0x708b, 0x0009, 0x1078, 0x4289, 0x20a3, 0x1105, 0x20a3, 0x0100,
+	0x3430, 0x1078, 0x42d4, 0x00c0, 0x3e01, 0x7074, 0xa005, 0x00c0,
+	0x3e01, 0x1078, 0x4104, 0x00c0, 0x3e0b, 0xa085, 0x0001, 0x1078,
+	0x256a, 0x20a9, 0x0008, 0x2099, 0xab8e, 0x26a0, 0x53a6, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x420b, 0x007c,
+	0x0f7e, 0x7080, 0xa005, 0x0040, 0x3e51, 0x2011, 0x41dc, 0x1078,
+	0x5a45, 0xa086, 0x0014, 0x00c0, 0x3e4f, 0x2079, 0xab80, 0x7a30,
+	0xa296, 0x1105, 0x00c0, 0x3e4f, 0x7834, 0x2011, 0x0100, 0xa21e,
+	0x00c0, 0x3e3a, 0x7a38, 0xd2fc, 0x0040, 0x3e34, 0x70b0, 0xa005,
+	0x00c0, 0x3e34, 0x70b3, 0x0001, 0x708b, 0x000a, 0x1078, 0x3e53,
+	0x0078, 0x3e51, 0xa005, 0x00c0, 0x3e4f, 0x7a38, 0xd2fc, 0x0040,
+	0x3e47, 0x70b0, 0xa005, 0x00c0, 0x3e47, 0x70b3, 0x0001, 0x7087,
+	0x0000, 0x708b, 0x000e, 0x1078, 0x3edb, 0x0078, 0x3e51, 0x1078,
+	0x4224, 0x0f7f, 0x007c, 0x708b, 0x000b, 0x2011, 0xab0e, 0x22a0,
+	0x20a9, 0x0040, 0x2019, 0xffff, 0x43a4, 0x20a9, 0x0002, 0x2009,
+	0x0000, 0x41a4, 0x1078, 0x4289, 0x20a3, 0x1106, 0x20a3, 0x0000,
+	0x1078, 0x42d4, 0x0040, 0x3e70, 0x2013, 0x0000, 0x0078, 0x3e74,
+	0x6030, 0xa085, 0x0100, 0x2012, 0x2298, 0x20a9, 0x0042, 0x53a6,
+	0x60c3, 0x0084, 0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005,
+	0x0040, 0x3e9d, 0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0084,
+	0x00c0, 0x3e9b, 0x2079, 0xab80, 0x7a30, 0xa296, 0x1106, 0x00c0,
+	0x3e9b, 0x7834, 0xa005, 0x00c0, 0x3e9b, 0x708b, 0x000c, 0x1078,
+	0x3e9f, 0x0078, 0x3e9d, 0x1078, 0x4224, 0x0f7f, 0x007c, 0x708b,
+	0x000d, 0x1078, 0x4289, 0x20a3, 0x1107, 0x20a3, 0x0000, 0x2099,
+	0xab8e, 0x20a9, 0x0040, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0084, 0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005,
+	0x0040, 0x3ed9, 0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0084,
+	0x00c0, 0x3ed7, 0x2079, 0xab80, 0x7a30, 0xa296, 0x1107, 0x00c0,
+	0x3ed7, 0x7834, 0xa005, 0x00c0, 0x3ed7, 0x7087, 0x0001, 0x1078,
+	0x427b, 0x708b, 0x000e, 0x1078, 0x3edb, 0x0078, 0x3ed9, 0x1078,
+	0x4224, 0x0f7f, 0x007c, 0x708b, 0x000f, 0x7083, 0x0000, 0x608b,
+	0xbc85, 0x608f, 0xb5b5, 0x6043, 0x0005, 0x6043, 0x0004, 0x2009,
+	0x07d0, 0x2011, 0x41dc, 0x1078, 0x5a38, 0x007c, 0x7080, 0xa005,
+	0x0040, 0x3ef6, 0x2011, 0x41dc, 0x1078, 0x5a45, 0x007c, 0x708b,
+	0x0011, 0x1078, 0x42d4, 0x00c0, 0x3f14, 0x716c, 0x81ff, 0x0040,
+	0x3f14, 0x2009, 0x0000, 0x7070, 0xa084, 0x00ff, 0x1078, 0x254d,
+	0xa186, 0x007e, 0x0040, 0x3f14, 0xa186, 0x0080, 0x0040, 0x3f14,
+	0x2011, 0xab8e, 0x1078, 0x419d, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x2099, 0xab80, 0x20a1, 0x020b, 0x7480, 0xa480, 0x0018, 0xa080,
+	0x0007, 0xa084, 0x03f8, 0x8004, 0x20a8, 0x53a6, 0x60c3, 0x0014,
+	0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040, 0x3f55,
+	0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014, 0x00c0, 0x3f53,
+	0x2079, 0xab80, 0x7a30, 0xa296, 0x1103, 0x00c0, 0x3f53, 0x7834,
+	0xa005, 0x00c0, 0x3f53, 0x7a38, 0xd2fc, 0x0040, 0x3f4d, 0x70b0,
+	0xa005, 0x00c0, 0x3f4d, 0x70b3, 0x0001, 0x708b, 0x0012, 0x1078,
+	0x3f57, 0x0078, 0x3f55, 0x1078, 0x4224, 0x0f7f, 0x007c, 0x708b,
+	0x0013, 0x1078, 0x4295, 0x20a3, 0x1103, 0x20a3, 0x0000, 0x3430,
+	0x2011, 0xab8e, 0x1078, 0x42d4, 0x00c0, 0x3f75, 0x7074, 0xa005,
+	0x00c0, 0x3f75, 0x7150, 0xa186, 0xffff, 0x0040, 0x3f75, 0x1078,
+	0x419d, 0x0040, 0x3f75, 0x1078, 0x42b8, 0x20a9, 0x0008, 0x2298,
+	0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040, 0x3fad,
+	0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014, 0x00c0, 0x3fab,
+	0x2079, 0xab80, 0x7a30, 0xa296, 0x1104, 0x00c0, 0x3fab, 0x7834,
+	0xa005, 0x00c0, 0x3fab, 0x7a38, 0xd2fc, 0x0040, 0x3fa5, 0x70b0,
+	0xa005, 0x00c0, 0x3fa5, 0x70b3, 0x0001, 0x708b, 0x0014, 0x1078,
+	0x3faf, 0x0078, 0x3fad, 0x1078, 0x4224, 0x0f7f, 0x007c, 0x708b,
+	0x0015, 0x1078, 0x4295, 0x20a3, 0x1104, 0x20a3, 0x0000, 0x3430,
+	0x2011, 0xab8e, 0x1078, 0x42d4, 0x00c0, 0x3fd7, 0x7074, 0xa005,
+	0x00c0, 0x3fd7, 0x7154, 0xa186, 0xffff, 0x0040, 0x3fd7, 0xa180,
+	0x29c0, 0x200c, 0xa18c, 0xff00, 0x810f, 0x1078, 0x419d, 0x0040,
+	0x3fd7, 0x1078, 0x3820, 0x0040, 0x3fd7, 0x1078, 0x256a, 0x20a9,
+	0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0014, 0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005,
+	0x0040, 0x402e, 0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0014,
+	0x00c0, 0x402c, 0x2079, 0xab80, 0x7a30, 0xa296, 0x1105, 0x00c0,
+	0x402c, 0x7834, 0x2011, 0x0100, 0xa21e, 0x00c0, 0x400b, 0x7a38,
+	0xd2fc, 0x0040, 0x4009, 0x70b0, 0xa005, 0x00c0, 0x4009, 0x70b3,
+	0x0001, 0x0078, 0x401a, 0xa005, 0x00c0, 0x402c, 0x7a38, 0xd2fc,
+	0x0040, 0x4018, 0x70b0, 0xa005, 0x00c0, 0x4018, 0x70b3, 0x0001,
+	0x7087, 0x0000, 0x7a38, 0xd2f4, 0x0040, 0x4026, 0x2001, 0xa674,
+	0x2004, 0xd0a4, 0x00c0, 0x4026, 0x70cf, 0x0008, 0x708b, 0x0016,
+	0x1078, 0x4030, 0x0078, 0x402e, 0x1078, 0x4224, 0x0f7f, 0x007c,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xab80, 0x20a1, 0x020b,
+	0x20a9, 0x000e, 0x53a6, 0x3430, 0x2011, 0xab8e, 0x708b, 0x0017,
+	0x1078, 0x42d4, 0x00c0, 0x4050, 0x7074, 0xa005, 0x00c0, 0x4050,
+	0x1078, 0x4104, 0x00c0, 0x405a, 0xa085, 0x0001, 0x1078, 0x256a,
+	0x20a9, 0x0008, 0x2099, 0xab8e, 0x26a0, 0x53a6, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078, 0x420b, 0x007c, 0x0f7e,
+	0x7080, 0xa005, 0x0040, 0x407f, 0x2011, 0x41dc, 0x1078, 0x5a45,
+	0xa086, 0x0084, 0x00c0, 0x407d, 0x2079, 0xab80, 0x7a30, 0xa296,
+	0x1106, 0x00c0, 0x407d, 0x7834, 0xa005, 0x00c0, 0x407d, 0x708b,
+	0x0018, 0x1078, 0x4081, 0x0078, 0x407f, 0x1078, 0x4224, 0x0f7f,
+	0x007c, 0x708b, 0x0019, 0x1078, 0x4295, 0x20a3, 0x1106, 0x20a3,
+	0x0000, 0x3430, 0x2099, 0xab8e, 0x2039, 0xab0e, 0x27a0, 0x20a9,
+	0x0040, 0x53a3, 0x1078, 0x42d4, 0x00c0, 0x40b5, 0x2728, 0x2514,
+	0x8207, 0xa084, 0x00ff, 0x8000, 0x2018, 0xa294, 0x00ff, 0x8007,
+	0xa205, 0x202a, 0x6030, 0x2310, 0x8214, 0xa2a0, 0xab0e, 0x2414,
+	0xa38c, 0x0001, 0x0040, 0x40b0, 0xa294, 0xff00, 0x0078, 0x40b3,
+	0xa294, 0x00ff, 0x8007, 0xa215, 0x2222, 0x2798, 0x26a0, 0x20a9,
+	0x0040, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0084,
+	0x1078, 0x420b, 0x007c, 0x0f7e, 0x7080, 0xa005, 0x0040, 0x40e7,
+	0x2011, 0x41dc, 0x1078, 0x5a45, 0xa086, 0x0084, 0x00c0, 0x40e5,
+	0x2079, 0xab80, 0x7a30, 0xa296, 0x1107, 0x00c0, 0x40e5, 0x7834,
+	0xa005, 0x00c0, 0x40e5, 0x7087, 0x0001, 0x1078, 0x427b, 0x708b,
+	0x001a, 0x1078, 0x40e9, 0x0078, 0x40e7, 0x1078, 0x4224, 0x0f7f,
+	0x007c, 0x708b, 0x001b, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xab80, 0x20a1, 0x020b, 0x7480, 0xa480, 0x0018, 0xa080, 0x0007,
+	0xa084, 0x03f8, 0x8004, 0x20a8, 0x53a6, 0x60c3, 0x0084, 0x1078,
+	0x420b, 0x007c, 0x007c, 0x007c, 0x087e, 0x097e, 0x2029, 0xa653,
+	0x252c, 0x20a9, 0x0008, 0x2041, 0xab0e, 0x28a0, 0x2099, 0xab8e,
+	0x53a3, 0x20a9, 0x0008, 0x2011, 0x0007, 0xd5d4, 0x0040, 0x411a,
+	0x2011, 0x0000, 0x2800, 0xa200, 0x200c, 0xa1a6, 0xffff, 0x00c0,
+	0x412c, 0xd5d4, 0x0040, 0x4127, 0x8210, 0x0078, 0x4128, 0x8211,
+	0x00f0, 0x411a, 0x0078, 0x4194, 0x82ff, 0x00c0, 0x413e, 0xd5d4,
+	0x0040, 0x4138, 0xa1a6, 0x3fff, 0x0040, 0x4124, 0x0078, 0x413c,
+	0xa1a6, 0x3fff, 0x0040, 0x4194, 0xa18d, 0xc000, 0x20a9, 0x0010,
+	0x2019, 0x0001, 0xd5d4, 0x0040, 0x4147, 0x2019, 0x0010, 0x2120,
+	0xd5d4, 0x0040, 0x414e, 0x8423, 0x0078, 0x414f, 0x8424, 0x00c8,
+	0x415c, 0xd5d4, 0x0040, 0x4157, 0x8319, 0x0078, 0x4158, 0x8318,
+	0x00f0, 0x4148, 0x0078, 0x4194, 0x23a8, 0x2021, 0x0001, 0x8426,
+	0x8425, 0x00f0, 0x4160, 0x2328, 0x8529, 0xa2be, 0x0007, 0x0040,
+	0x4174, 0x007e, 0x2039, 0x0007, 0x2200, 0xa73a, 0x007f, 0x27a8,
+	0xa5a8, 0x0010, 0x00f0, 0x4170, 0x7552, 0xa5c8, 0x29c0, 0x292c,
+	0xa5ac, 0x00ff, 0x6532, 0x60e7, 0x0000, 0x65ea, 0x706f, 0x0000,
+	0x7572, 0x2018, 0x2304, 0xa405, 0x201a, 0x7077, 0x0001, 0x26a0,
+	0x2898, 0x20a9, 0x0008, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0xa085, 0x0001, 0x0078, 0x419a, 0xa006, 0x0078, 0x419a, 0xa006,
+	0x1078, 0x1332, 0x097f, 0x087f, 0x007c, 0x2118, 0x2021, 0x0000,
+	0x2001, 0x0007, 0xa39a, 0x0010, 0x0048, 0x41aa, 0x8420, 0x8001,
+	0x0078, 0x41a2, 0x2118, 0x84ff, 0x0040, 0x41b3, 0xa39a, 0x0010,
+	0x8421, 0x00c0, 0x41ae, 0x2021, 0x0001, 0x83ff, 0x0040, 0x41bc,
+	0x8423, 0x8319, 0x00c0, 0x41b8, 0xa238, 0x2704, 0xa42c, 0x00c0,
+	0x41d4, 0xa405, 0x203a, 0x7152, 0xa1a0, 0x29c0, 0x242c, 0xa5ac,
+	0x00ff, 0x6532, 0x60e7, 0x0000, 0x65ea, 0x706f, 0x0000, 0x7572,
+	0x7077, 0x0001, 0xa084, 0x0000, 0x007c, 0x0e7e, 0x2071, 0xa600,
+	0x707b, 0x0000, 0x0e7f, 0x007c, 0x0e7e, 0x0f7e, 0x2001, 0x0002,
+	0x1078, 0x5ae6, 0x2079, 0x0100, 0x2071, 0x0140, 0x1078, 0x6e0f,
+	0x7004, 0xa084, 0x4000, 0x0040, 0x41f1, 0x7003, 0x1000, 0x7003,
+	0x0000, 0x127e, 0x2091, 0x8000, 0x2071, 0xa622, 0x2073, 0x0000,
+	0x7840, 0x027e, 0x017e, 0x2009, 0x00f7, 0x1078, 0x42a1, 0x017f,
+	0xa094, 0x0010, 0xa285, 0x0080, 0x7842, 0x7a42, 0x027f, 0x127f,
+	0x0f7f, 0x0e7f, 0x007c, 0x127e, 0x2091, 0x8000, 0x2011, 0xa8bb,
+	0x2013, 0x0000, 0x7083, 0x0000, 0x127f, 0x20e1, 0x9080, 0x60a3,
+	0x0056, 0x60a7, 0x9575, 0x1078, 0x6e06, 0x2009, 0x07d0, 0x2011,
+	0x41dc, 0x1078, 0x5add, 0x007c, 0x017e, 0x027e, 0x0c7e, 0x127e,
+	0x2091, 0x8000, 0x2011, 0x0003, 0x1078, 0x70e0, 0x2011, 0x0002,
+	0x1078, 0x70ea, 0x1078, 0x6fc4, 0x037e, 0x2019, 0x0000, 0x1078,
+	0x7058, 0x037f, 0x2009, 0x00f7, 0x1078, 0x42a1, 0x2061, 0xa8c4,
+	0x601b, 0x0000, 0x601f, 0x0000, 0x2061, 0xa600, 0x6003, 0x0001,
+	0x2061, 0x0100, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x002d,
+	0x2011, 0x4259, 0x1078, 0x5a38, 0x127f, 0x0c7f, 0x027f, 0x017f,
+	0x007c, 0x0e7e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2001, 0x0001,
+	0x1078, 0x5ae6, 0x2071, 0x0100, 0x1078, 0x6e0f, 0x2071, 0x0140,
+	0x7004, 0xa084, 0x4000, 0x0040, 0x4271, 0x7003, 0x1000, 0x7003,
+	0x0000, 0x2001, 0x0001, 0x1078, 0x24e8, 0x1078, 0x4224, 0x127f,
+	0x007f, 0x0e7f, 0x007c, 0x20a9, 0x0040, 0x20a1, 0xacc0, 0x2099,
+	0xab8e, 0x3304, 0x8007, 0x20a2, 0x9398, 0x94a0, 0x00f0, 0x4281,
+	0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xab00, 0x20a1,
+	0x020b, 0x20a9, 0x000c, 0x53a6, 0x007c, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x2099, 0xab80, 0x20a1, 0x020b, 0x20a9, 0x000c, 0x53a6,
+	0x007c, 0x0c7e, 0x007e, 0x2061, 0x0100, 0x810f, 0x2001, 0xa62f,
+	0x2004, 0xa005, 0x00c0, 0x42b2, 0x6030, 0xa084, 0x00ff, 0xa105,
+	0x0078, 0x42b4, 0xa185, 0x00f7, 0x604a, 0x007f, 0x0c7f, 0x007c,
+	0x017e, 0x047e, 0x2001, 0xa653, 0x2004, 0xd0a4, 0x0040, 0x42cb,
+	0xa006, 0x2020, 0x2009, 0x002a, 0x1078, 0xa21d, 0x2001, 0xa60c,
+	0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009, 0x0000, 0x1078,
+	0x284f, 0x047f, 0x017f, 0x007c, 0x007e, 0x2001, 0xa60c, 0x2004,
+	0xd09c, 0x0040, 0x42db, 0x007f, 0x007c, 0x007e, 0x017e, 0x127e,
+	0x2091, 0x8000, 0x2001, 0x0101, 0x200c, 0xa18d, 0x0006, 0x2102,
+	0x127f, 0x017f, 0x007f, 0x007c, 0x157e, 0x20a9, 0x00ff, 0x2009,
+	0xa735, 0xa006, 0x200a, 0x8108, 0x00f0, 0x42f2, 0x157f, 0x007c,
+	0x0d7e, 0x037e, 0x157e, 0x137e, 0x147e, 0x2069, 0xa652, 0xa006,
+	0x6002, 0x6007, 0x0707, 0x600a, 0x600e, 0x6012, 0xa198, 0x29c0,
+	0x231c, 0xa39c, 0x00ff, 0x6316, 0x20a9, 0x0004, 0xac98, 0x0006,
+	0x23a0, 0x40a4, 0x20a9, 0x0004, 0xac98, 0x000a, 0x23a0, 0x40a4,
+	0x603e, 0x6042, 0x604e, 0x6052, 0x6056, 0x605a, 0x605e, 0x6062,
+	0x6066, 0x606a, 0x606e, 0x6072, 0x6076, 0x607a, 0x607e, 0x6082,
+	0x6086, 0x608a, 0x608e, 0x6092, 0x6096, 0x609a, 0x609e, 0x60ae,
+	0x61a2, 0x0d7e, 0x60a4, 0xa06d, 0x0040, 0x4338, 0x1078, 0x13a4,
+	0x60a7, 0x0000, 0x60a8, 0xa06d, 0x0040, 0x4340, 0x1078, 0x13a4,
+	0x60ab, 0x0000, 0x0d7f, 0xa006, 0x604a, 0x6810, 0x603a, 0x680c,
+	0x6046, 0x6814, 0xa084, 0x00ff, 0x6042, 0x147f, 0x137f, 0x157f,
+	0x037f, 0x0d7f, 0x007c, 0x127e, 0x2091, 0x8000, 0x6944, 0x6e48,
+	0xa684, 0x3fff, 0xa082, 0x4000, 0x00c8, 0x4424, 0xa18c, 0xff00,
+	0x810f, 0xa182, 0x00ff, 0x00c8, 0x442a, 0x2001, 0xa60c, 0x2004,
+	0xa084, 0x0003, 0x0040, 0x4385, 0x2001, 0xa60c, 0x2004, 0xd084,
+	0x00c0, 0x4405, 0xa188, 0xa735, 0x2104, 0xa065, 0x0040, 0x4405,
+	0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006, 0x00c0, 0x4405, 0x6000,
+	0xd0c4, 0x0040, 0x4405, 0x0078, 0x4392, 0xa188, 0xa735, 0x2104,
+	0xa065, 0x0040, 0x43e9, 0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006,
+	0x00c0, 0x43ef, 0x60a4, 0xa00d, 0x0040, 0x439a, 0x1078, 0x4817,
+	0x0040, 0x43e3, 0x60a8, 0xa00d, 0x0040, 0x43b4, 0x1078, 0x486a,
+	0x00c0, 0x43b4, 0x694c, 0xd1fc, 0x00c0, 0x43aa, 0x1078, 0x44df,
+	0x0078, 0x43de, 0x1078, 0x4484, 0x694c, 0xd1ec, 0x00c0, 0x43de,
+	0x1078, 0x46d6, 0x0078, 0x43de, 0x694c, 0xa184, 0xa000, 0x0040,
+	0x43ce, 0xd1ec, 0x0040, 0x43c7, 0xd1fc, 0x0040, 0x43c3, 0x1078,
+	0x46e7, 0x0078, 0x43ca, 0x1078, 0x46e7, 0x0078, 0x43ce, 0xd1fc,
+	0x0040, 0x43ce, 0x1078, 0x4484, 0x0078, 0x43de, 0x6050, 0xa00d,
+	0x0040, 0x43d9, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052, 0x0078,
+	0x43de, 0x2d00, 0x6052, 0x604e, 0x6803, 0x0000, 0x1078, 0x5da9,
+	0xa006, 0x127f, 0x007c, 0x2001, 0x0005, 0x2009, 0x0000, 0x0078,
+	0x442e, 0x2001, 0x0028, 0x2009, 0x0000, 0x0078, 0x442e, 0xa082,
+	0x0006, 0x00c8, 0x4405, 0x60a0, 0xd0bc, 0x00c0, 0x4401, 0x6100,
+	0xd1fc, 0x0040, 0x4392, 0x2001, 0x0029, 0x2009, 0x1000, 0x0078,
+	0x442e, 0x2001, 0x0028, 0x0078, 0x4420, 0x2009, 0xa60c, 0x210c,
+	0xd18c, 0x0040, 0x440f, 0x2001, 0x0004, 0x0078, 0x4420, 0xd184,
+	0x0040, 0x4416, 0x2001, 0x0004, 0x0078, 0x4420, 0x2001, 0x0029,
+	0x6100, 0xd1fc, 0x0040, 0x4420, 0x2009, 0x1000, 0x0078, 0x442e,
+	0x2009, 0x0000, 0x0078, 0x442e, 0x2001, 0x0029, 0x2009, 0x0000,
+	0x0078, 0x442e, 0x2001, 0x0029, 0x2009, 0x0000, 0xa005, 0x127f,
+	0x007c, 0x6944, 0x6e48, 0xa684, 0x3fff, 0xa082, 0x4000, 0x00c8,
+	0x447e, 0xa18c, 0xff00, 0x810f, 0xa182, 0x00ff, 0x00c8, 0x4464,
+	0xa188, 0xa735, 0x2104, 0xa065, 0x0040, 0x4464, 0x6004, 0xa084,
+	0x00ff, 0xa08e, 0x0006, 0x00c0, 0x446a, 0x684c, 0xd0ec, 0x0040,
+	0x4457, 0x1078, 0x46e7, 0x1078, 0x4484, 0x0078, 0x445f, 0x1078,
+	0x4484, 0x684c, 0xd0fc, 0x0040, 0x445f, 0x1078, 0x46d6, 0x1078,
+	0x472f, 0xa006, 0x0078, 0x4482, 0x2001, 0x0028, 0x2009, 0x0000,
+	0x0078, 0x4482, 0xa082, 0x0006, 0x00c8, 0x4478, 0x6100, 0xd1fc,
+	0x0040, 0x444d, 0x2001, 0x0029, 0x2009, 0x1000, 0x0078, 0x4482,
+	0x2001, 0x0029, 0x2009, 0x0000, 0x0078, 0x4482, 0x2001, 0x0029,
+	0x2009, 0x0000, 0xa005, 0x007c, 0x127e, 0x2091, 0x8000, 0x6050,
+	0xa00d, 0x0040, 0x4492, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052,
+	0x127f, 0x007c, 0x2d00, 0x6052, 0x604e, 0x6803, 0x0000, 0x0078,
+	0x4490, 0x127e, 0x2091, 0x8000, 0x604c, 0xa005, 0x0040, 0x44af,
+	0x0e7e, 0x2071, 0xa8b1, 0x7004, 0xa086, 0x0002, 0x0040, 0x44b6,
+	0x0e7f, 0x604c, 0x6802, 0x2d00, 0x604e, 0x127f, 0x007c, 0x2d00,
+	0x6052, 0x604e, 0x6803, 0x0000, 0x0078, 0x44ad, 0x701c, 0xac06,
+	0x00c0, 0x44a8, 0x604c, 0x2070, 0x7000, 0x6802, 0x2d00, 0x7002,
+	0x0e7f, 0x127f, 0x007c, 0x127e, 0x2091, 0x8000, 0x604c, 0xa06d,
+	0x0040, 0x44d1, 0x6800, 0xa005, 0x00c0, 0x44cf, 0x6052, 0x604e,
+	0xad05, 0x127f, 0x007c, 0x604c, 0xa06d, 0x0040, 0x44de, 0x6800,
+	0xa005, 0x00c0, 0x44dc, 0x6052, 0x604e, 0xad05, 0x007c, 0x6803,
+	0x0000, 0x6084, 0xa00d, 0x0040, 0x44e9, 0x2d00, 0x200a, 0x6086,
+	0x007c, 0x2d00, 0x6086, 0x6082, 0x0078, 0x44e8, 0x127e, 0x0c7e,
+	0x027e, 0x2091, 0x8000, 0x6218, 0x2260, 0x6200, 0xa005, 0x0040,
+	0x44fc, 0xc285, 0x0078, 0x44fd, 0xc284, 0x6202, 0x027f, 0x0c7f,
+	0x127f, 0x007c, 0x127e, 0x0c7e, 0x2091, 0x8000, 0x6218, 0x2260,
+	0x6204, 0x007e, 0xa086, 0x0006, 0x00c0, 0x4521, 0x609c, 0xd0ac,
+	0x0040, 0x4521, 0x2001, 0xa653, 0x2004, 0xd0a4, 0x0040, 0x4521,
+	0xa284, 0xff00, 0x8007, 0xa086, 0x0007, 0x00c0, 0x4521, 0x2011,
+	0x0600, 0x007f, 0xa294, 0xff00, 0xa215, 0x6206, 0x007e, 0xa086,
+	0x0006, 0x00c0, 0x4531, 0x6290, 0x82ff, 0x00c0, 0x4531, 0x1078,
+	0x1332, 0x007f, 0x0c7f, 0x127f, 0x007c, 0x127e, 0x0c7e, 0x2091,
+	0x8000, 0x6218, 0x2260, 0x6204, 0x007e, 0xa086, 0x0006, 0x00c0,
+	0x4553, 0x609c, 0xd0a4, 0x0040, 0x4553, 0x2001, 0xa653, 0x2004,
+	0xd0ac, 0x00c0, 0x4553, 0xa284, 0x00ff, 0xa086, 0x0007, 0x00c0,
+	0x4553, 0x2011, 0x0006, 0x007f, 0xa294, 0x00ff, 0x8007, 0xa215,
+	0x6206, 0x0c7f, 0x127f, 0x007c, 0x027e, 0xa182, 0x00ff, 0x0048,
+	0x4565, 0xa085, 0x0001, 0x0078, 0x457d, 0xa190, 0xa735, 0x2204,
+	0xa065, 0x00c0, 0x457c, 0x017e, 0x0d7e, 0x1078, 0x1370, 0x2d60,
+	0x0d7f, 0x017f, 0x0040, 0x4561, 0x2c00, 0x2012, 0x60a7, 0x0000,
+	0x60ab, 0x0000, 0x1078, 0x42f8, 0xa006, 0x027f, 0x007c, 0x127e,
+	0x2091, 0x8000, 0x027e, 0xa182, 0x00ff, 0x0048, 0x458b, 0xa085,
+	0x0001, 0x0078, 0x45c1, 0x0d7e, 0xa190, 0xa735, 0x2204, 0xa06d,
+	0x0040, 0x45bf, 0x2013, 0x0000, 0x0d7e, 0x0c7e, 0x2d60, 0x60a4,
+	0xa06d, 0x0040, 0x459d, 0x1078, 0x13a4, 0x60a8, 0xa06d, 0x0040,
+	0x45a3, 0x1078, 0x13a4, 0x0c7f, 0x0d7f, 0x0d7e, 0x0c7e, 0x68ac,
+	0x2060, 0x8cff, 0x0040, 0x45bb, 0x600c, 0x007e, 0x6010, 0x2068,
+	0x1078, 0x8d06, 0x0040, 0x45b6, 0x1078, 0x13b4, 0x1078, 0x772d,
+	0x0c7f, 0x0078, 0x45a9, 0x0c7f, 0x0d7f, 0x1078, 0x13a4, 0x0d7f,
+	0xa006, 0x027f, 0x127f, 0x007c, 0x017e, 0xa182, 0x00ff, 0x0048,
+	0x45cd, 0xa085, 0x0001, 0x0078, 0x45d4, 0xa188, 0xa735, 0x2104,
+	0xa065, 0x0040, 0x45c9, 0xa006, 0x017f, 0x007c, 0x0d7e, 0x157e,
+	0x137e, 0x147e, 0x600b, 0x0000, 0x600f, 0x0000, 0x6000, 0xc08c,
+	0x6002, 0x2069, 0xab8e, 0x6808, 0x605e, 0x6810, 0x6062, 0x6138,
+	0xa10a, 0x0048, 0x45ec, 0x603a, 0x6814, 0x6066, 0x2099, 0xab96,
+	0xac88, 0x000a, 0x21a0, 0x20a9, 0x0004, 0x53a3, 0x2099, 0xab9a,
+	0xac88, 0x0006, 0x21a0, 0x20a9, 0x0004, 0x53a3, 0x2069, 0xabae,
+	0x6808, 0x606a, 0x690c, 0x616e, 0x6810, 0x6072, 0x6818, 0x6076,
+	0x60a0, 0xa086, 0x007e, 0x00c0, 0x4611, 0x2069, 0xab8e, 0x690c,
+	0x616e, 0xa182, 0x0211, 0x00c8, 0x4619, 0x2009, 0x0008, 0x0078,
+	0x4643, 0xa182, 0x0259, 0x00c8, 0x4621, 0x2009, 0x0007, 0x0078,
+	0x4643, 0xa182, 0x02c1, 0x00c8, 0x4629, 0x2009, 0x0006, 0x0078,
+	0x4643, 0xa182, 0x0349, 0x00c8, 0x4631, 0x2009, 0x0005, 0x0078,
+	0x4643, 0xa182, 0x0421, 0x00c8, 0x4639, 0x2009, 0x0004, 0x0078,
+	0x4643, 0xa182, 0x0581, 0x00c8, 0x4641, 0x2009, 0x0003, 0x0078,
+	0x4643, 0x2009, 0x0002, 0x6192, 0x147f, 0x137f, 0x157f, 0x0d7f,
+	0x007c, 0x017e, 0x027e, 0x0e7e, 0x2071, 0xab8d, 0x2e04, 0x6896,
+	0x2071, 0xab8e, 0x7004, 0x689a, 0x701c, 0x689e, 0x6a00, 0x2009,
+	0xa672, 0x210c, 0xd0bc, 0x0040, 0x4663, 0xd1ec, 0x0040, 0x4663,
+	0xc2ad, 0x0078, 0x4664, 0xc2ac, 0xd0c4, 0x0040, 0x466d, 0xd1e4,
+	0x0040, 0x466d, 0xc2bd, 0x0078, 0x466e, 0xc2bc, 0x6a02, 0x0e7f,
+	0x027f, 0x017f, 0x007c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x60a4,
+	0xa06d, 0x0040, 0x4697, 0x6900, 0x81ff, 0x00c0, 0x46ab, 0x6a04,
+	0xa282, 0x0010, 0x00c8, 0x46b0, 0xad88, 0x0004, 0x20a9, 0x0010,
+	0x2104, 0xa086, 0xffff, 0x0040, 0x4692, 0x8108, 0x00f0, 0x4688,
+	0x1078, 0x1332, 0x260a, 0x8210, 0x6a06, 0x0078, 0x46ab, 0x1078,
+	0x138b, 0x0040, 0x46b0, 0x2d00, 0x60a6, 0x6803, 0x0000, 0xad88,
+	0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108, 0x00f0, 0x46a3,
+	0x6807, 0x0001, 0x6e12, 0xa085, 0x0001, 0x127f, 0x0d7f, 0x007c,
+	0xa006, 0x0078, 0x46ad, 0x127e, 0x2091, 0x8000, 0x0d7e, 0x60a4,
+	0xa00d, 0x0040, 0x46d3, 0x2168, 0x6800, 0xa005, 0x00c0, 0x46cf,
+	0x1078, 0x4817, 0x00c0, 0x46d3, 0x200b, 0xffff, 0x6804, 0xa08a,
+	0x0002, 0x0048, 0x46cf, 0x8001, 0x6806, 0x0078, 0x46d3, 0x1078,
+	0x13a4, 0x60a7, 0x0000, 0x0d7f, 0x127f, 0x007c, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x487f, 0x0078, 0x46df, 0x1078, 0x4484, 0x1078,
+	0x4775, 0x00c0, 0x46dd, 0x1078, 0x472f, 0x127f, 0x007c, 0x0d7e,
+	0x127e, 0x2091, 0x8000, 0x60a8, 0xa06d, 0x0040, 0x470b, 0x6950,
+	0x81ff, 0x00c0, 0x471f, 0x6a54, 0xa282, 0x0010, 0x00c8, 0x472c,
+	0xad88, 0x0018, 0x20a9, 0x0010, 0x2104, 0xa086, 0xffff, 0x0040,
+	0x4706, 0x8108, 0x00f0, 0x46fc, 0x1078, 0x1332, 0x260a, 0x8210,
+	0x6a56, 0x0078, 0x471f, 0x1078, 0x138b, 0x0040, 0x472c, 0x2d00,
+	0x60aa, 0x6853, 0x0000, 0xad88, 0x0018, 0x20a9, 0x0010, 0x200b,
+	0xffff, 0x8108, 0x00f0, 0x4717, 0x6857, 0x0001, 0x6e62, 0x0078,
+	0x4723, 0x1078, 0x44df, 0x1078, 0x4739, 0x00c0, 0x4721, 0xa085,
+	0x0001, 0x127f, 0x0d7f, 0x007c, 0xa006, 0x0078, 0x4729, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x5da9, 0x127f, 0x007c, 0xa01e, 0x0078,
+	0x473b, 0x2019, 0x0001, 0xa00e, 0x127e, 0x2091, 0x8000, 0x604c,
+	0x2068, 0x6000, 0xd0dc, 0x00c0, 0x4759, 0x8dff, 0x0040, 0x4770,
+	0x83ff, 0x0040, 0x4751, 0x6848, 0xa606, 0x0040, 0x475e, 0x0078,
+	0x4759, 0x683c, 0xa406, 0x00c0, 0x4759, 0x6840, 0xa506, 0x0040,
+	0x475e, 0x2d08, 0x6800, 0x2068, 0x0078, 0x4745, 0x1078, 0x7233,
+	0x6a00, 0x604c, 0xad06, 0x00c0, 0x4768, 0x624e, 0x0078, 0x476b,
+	0xa180, 0x0000, 0x2202, 0x82ff, 0x00c0, 0x4770, 0x6152, 0x8dff,
+	0x127f, 0x007c, 0xa01e, 0x0078, 0x4777, 0x2019, 0x0001, 0xa00e,
+	0x6080, 0x2068, 0x8dff, 0x0040, 0x47a3, 0x83ff, 0x0040, 0x4786,
+	0x6848, 0xa606, 0x0040, 0x4793, 0x0078, 0x478e, 0x683c, 0xa406,
+	0x00c0, 0x478e, 0x6840, 0xa506, 0x0040, 0x4793, 0x2d08, 0x6800,
+	0x2068, 0x0078, 0x477a, 0x6a00, 0x6080, 0xad06, 0x00c0, 0x479b,
+	0x6282, 0x0078, 0x479e, 0xa180, 0x0000, 0x2202, 0x82ff, 0x00c0,
+	0x47a3, 0x6186, 0x8dff, 0x007c, 0xa016, 0x1078, 0x4810, 0x00c0,
+	0x47ab, 0x2011, 0x0001, 0x1078, 0x4863, 0x00c0, 0x47b1, 0xa295,
+	0x0002, 0x007c, 0x1078, 0x489b, 0x0040, 0x47ba, 0x1078, 0x8dca,
+	0x0078, 0x47bc, 0xa085, 0x0001, 0x007c, 0x1078, 0x489b, 0x0040,
+	0x47c5, 0x1078, 0x8d62, 0x0078, 0x47c7, 0xa085, 0x0001, 0x007c,
+	0x1078, 0x489b, 0x0040, 0x47d0, 0x1078, 0x8dac, 0x0078, 0x47d2,
+	0xa085, 0x0001, 0x007c, 0x1078, 0x489b, 0x0040, 0x47db, 0x1078,
+	0x8d7e, 0x0078, 0x47dd, 0xa085, 0x0001, 0x007c, 0x1078, 0x489b,
+	0x0040, 0x47e6, 0x1078, 0x8de8, 0x0078, 0x47e8, 0xa085, 0x0001,
+	0x007c, 0x127e, 0x007e, 0x0d7e, 0x2091, 0x8000, 0x6080, 0xa06d,
+	0x0040, 0x4808, 0x6800, 0x007e, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x1078, 0x8f7d, 0x007e, 0x6000, 0xd0fc, 0x0040, 0x4802,
+	0x1078, 0xa4ed, 0x007f, 0x1078, 0x4a73, 0x007f, 0x0078, 0x47ef,
+	0x6083, 0x0000, 0x6087, 0x0000, 0x0d7f, 0x007f, 0x127f, 0x007c,
+	0x60a4, 0xa00d, 0x00c0, 0x4817, 0xa085, 0x0001, 0x007c, 0x0e7e,
+	0x2170, 0x7000, 0xa005, 0x00c0, 0x482c, 0x20a9, 0x0010, 0xae88,
+	0x0004, 0x2104, 0xa606, 0x0040, 0x482c, 0x8108, 0x00f0, 0x4821,
+	0xa085, 0x0001, 0x0078, 0x482d, 0xa006, 0x0e7f, 0x007c, 0x0d7e,
+	0x127e, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x00c0, 0x483d, 0x1078,
+	0x138b, 0x0040, 0x484f, 0x2d00, 0x60a6, 0x6803, 0x0001, 0x6807,
+	0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108,
+	0x00f0, 0x4845, 0xa085, 0x0001, 0x127f, 0x0d7f, 0x007c, 0xa006,
+	0x0078, 0x484c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x60a4, 0xa06d,
+	0x0040, 0x4860, 0x60a7, 0x0000, 0x1078, 0x13a4, 0xa085, 0x0001,
+	0x127f, 0x0d7f, 0x007c, 0x60a8, 0xa00d, 0x00c0, 0x486a, 0xa085,
+	0x0001, 0x007c, 0x0e7e, 0x2170, 0x7050, 0xa005, 0x00c0, 0x487d,
+	0x20a9, 0x0010, 0xae88, 0x0018, 0x2104, 0xa606, 0x0040, 0x487d,
+	0x8108, 0x00f0, 0x4874, 0xa085, 0x0001, 0x0e7f, 0x007c, 0x127e,
+	0x2091, 0x8000, 0x1078, 0x4863, 0x00c0, 0x4899, 0x200b, 0xffff,
+	0x0d7e, 0x60a8, 0x2068, 0x6854, 0xa08a, 0x0002, 0x0048, 0x4894,
+	0x8001, 0x6856, 0x0078, 0x4898, 0x1078, 0x13a4, 0x60ab, 0x0000,
+	0x0d7f, 0x127f, 0x007c, 0x609c, 0xd0a4, 0x007c, 0x0f7e, 0x71b0,
+	0x81ff, 0x00c0, 0x48b9, 0x71cc, 0xd19c, 0x0040, 0x48b9, 0x2001,
+	0x007e, 0xa080, 0xa735, 0x2004, 0xa07d, 0x0040, 0x48b9, 0x7804,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x00c0, 0x48b9, 0x7800, 0xc0ed,
+	0x7802, 0x2079, 0xa652, 0x7804, 0xd0a4, 0x0040, 0x48df, 0x157e,
+	0x0c7e, 0x20a9, 0x007f, 0x2009, 0x0000, 0x017e, 0x1078, 0x45c4,
+	0x00c0, 0x48d9, 0x6004, 0xa084, 0xff00, 0x8007, 0xa096, 0x0004,
+	0x0040, 0x48d6, 0xa086, 0x0006, 0x00c0, 0x48d9, 0x6000, 0xc0ed,
+	0x6002, 0x017f, 0x8108, 0x00f0, 0x48c5, 0x0c7f, 0x157f, 0x1078,
+	0x4967, 0x0040, 0x48e8, 0x2001, 0xa8a1, 0x200c, 0x0078, 0x48f0,
+	0x2079, 0xa652, 0x7804, 0xd0a4, 0x0040, 0x48f4, 0x2009, 0x07d0,
+	0x2011, 0x48f6, 0x1078, 0x5add, 0x0f7f, 0x007c, 0x2011, 0x48f6,
+	0x1078, 0x5a45, 0x1078, 0x4967, 0x0040, 0x491e, 0x2001, 0xa7b3,
+	0x2004, 0xa080, 0x0000, 0x200c, 0xc1ec, 0x2102, 0x2001, 0xa653,
+	0x2004, 0xd0a4, 0x0040, 0x4912, 0x2009, 0x07d0, 0x2011, 0x48f6,
+	0x1078, 0x5add, 0x0e7e, 0x2071, 0xa600, 0x706f, 0x0000, 0x7073,
+	0x0000, 0x1078, 0x2677, 0x0e7f, 0x0078, 0x4956, 0x157e, 0x0c7e,
+	0x20a9, 0x007f, 0x2009, 0x0000, 0x017e, 0x1078, 0x45c4, 0x00c0,
+	0x4950, 0x6000, 0xd0ec, 0x0040, 0x4950, 0x047e, 0x62a0, 0xa294,
+	0x00ff, 0x8227, 0xa006, 0x2009, 0x0029, 0x1078, 0xa21d, 0x6000,
+	0xc0e5, 0xc0ec, 0x6002, 0x6004, 0xa084, 0x00ff, 0xa085, 0x0700,
+	0x6006, 0x2019, 0x0029, 0x1078, 0x5f01, 0x077e, 0x2039, 0x0000,
+	0x1078, 0x5e0a, 0x2009, 0x0000, 0x1078, 0x9f8b, 0x077f, 0x047f,
+	0x017f, 0x8108, 0x00f0, 0x4924, 0x0c7f, 0x157f, 0x007c, 0x0c7e,
+	0x6018, 0x2060, 0x6000, 0xc0ec, 0x6002, 0x0c7f, 0x007c, 0x7818,
+	0x2004, 0xd0ac, 0x007c, 0x7818, 0x2004, 0xd0bc, 0x007c, 0x0f7e,
+	0x2001, 0xa7b3, 0x2004, 0xa07d, 0x0040, 0x4970, 0x7800, 0xd0ec,
+	0x0f7f, 0x007c, 0x127e, 0x027e, 0x2091, 0x8000, 0x007e, 0x62a0,
+	0xa290, 0xa735, 0x2204, 0xac06, 0x10c0, 0x1332, 0x007f, 0x6200,
+	0xa005, 0x0040, 0x4986, 0xc2fd, 0x0078, 0x4987, 0xc2fc, 0x6202,
+	0x027f, 0x127f, 0x007c, 0x2011, 0xa633, 0x2204, 0xd0cc, 0x0040,
+	0x4998, 0x2001, 0xa89f, 0x200c, 0x2011, 0x4999, 0x1078, 0x5add,
+	0x007c, 0x2011, 0x4999, 0x1078, 0x5a45, 0x2011, 0xa633, 0x2204,
+	0xc0cc, 0x2012, 0x007c, 0x2071, 0xa714, 0x7003, 0x0001, 0x7007,
+	0x0000, 0x7013, 0x0000, 0x7017, 0x0000, 0x701b, 0x0000, 0x701f,
+	0x0000, 0x700b, 0x0000, 0x704b, 0x0001, 0x704f, 0x0000, 0x705b,
+	0x0020, 0x705f, 0x0040, 0x707f, 0x0000, 0x2071, 0xa87d, 0x7003,
+	0xa714, 0x7007, 0x0000, 0x700b, 0x0000, 0x700f, 0xa85d, 0x7013,
+	0x0020, 0x7017, 0x0040, 0x7037, 0x0000, 0x007c, 0x017e, 0x0e7e,
+	0x2071, 0xa835, 0xa00e, 0x7186, 0x718a, 0x7097, 0x0001, 0x2001,
+	0xa653, 0x2004, 0xd0fc, 0x00c0, 0x49e8, 0x2001, 0xa653, 0x2004,
+	0xa00e, 0xd09c, 0x0040, 0x49e5, 0x8108, 0x7102, 0x0078, 0x4a3b,
+	0x2001, 0xa672, 0x200c, 0xa184, 0x000f, 0x2009, 0xa673, 0x210c,
+	0x0079, 0x49f2, 0x49dd, 0x4a13, 0x4a1b, 0x4a26, 0x4a2c, 0x49dd,
+	0x49dd, 0x49dd, 0x4a02, 0x49dd, 0x49dd, 0x49dd, 0x49dd, 0x49dd,
+	0x49dd, 0x49dd, 0x7003, 0x0004, 0x137e, 0x147e, 0x157e, 0x2099,
+	0xa676, 0x20a1, 0xa886, 0x20a9, 0x0004, 0x53a3, 0x157f, 0x147f,
+	0x137f, 0x0078, 0x4a3b, 0x708f, 0x0005, 0x7007, 0x0122, 0x2001,
+	0x0002, 0x0078, 0x4a21, 0x708f, 0x0002, 0x7007, 0x0121, 0x2001,
+	0x0003, 0x7002, 0x7097, 0x0001, 0x0078, 0x4a38, 0x7007, 0x0122,
+	0x2001, 0x0002, 0x0078, 0x4a30, 0x7007, 0x0121, 0x2001, 0x0003,
+	0x7002, 0xa006, 0x7096, 0x708e, 0xa184, 0xff00, 0x8007, 0x709a,
+	0xa184, 0x00ff, 0x7092, 0x0e7f, 0x017f, 0x007c, 0x0e7e, 0x2071,
+	0xa714, 0x684c, 0xa005, 0x00c0, 0x4a4c, 0x7028, 0xc085, 0x702a,
+	0xa085, 0x0001, 0x0078, 0x4a71, 0x6a60, 0x7236, 0x6b64, 0x733a,
+	0x6868, 0x703e, 0x7076, 0x686c, 0x7042, 0x707a, 0x684c, 0x702e,
+	0x6844, 0x7032, 0x2009, 0x000d, 0x200a, 0x700b, 0x0000, 0x8007,
+	0x8006, 0x8006, 0xa08c, 0x003f, 0xa084, 0xffc0, 0xa210, 0x2100,
+	0xa319, 0x726e, 0x7372, 0x7028, 0xc084, 0x702a, 0x7007, 0x0001,
+	0xa006, 0x0e7f, 0x007c, 0x0e7e, 0x027e, 0x6838, 0xd0fc, 0x00c0,
+	0x4ac9, 0x6804, 0xa00d, 0x0040, 0x4a8f, 0x0d7e, 0x2071, 0xa600,
+	0xa016, 0x702c, 0x2168, 0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff,
+	0x00c0, 0x4a82, 0x702e, 0x70ac, 0xa200, 0x70ae, 0x0d7f, 0x2071,
+	0xa714, 0x701c, 0xa005, 0x00c0, 0x4adb, 0x0068, 0x4ad9, 0x2071,
+	0xa835, 0x7200, 0x82ff, 0x0040, 0x4ad9, 0x6934, 0xa186, 0x0103,
+	0x00c0, 0x4aec, 0x6948, 0x6844, 0xa105, 0x00c0, 0x4acc, 0x2009,
+	0x8020, 0x2200, 0x0079, 0x4aac, 0x4ad9, 0x4ab1, 0x4b09, 0x4b17,
+	0x4ad9, 0x2071, 0x0000, 0x7018, 0xd084, 0x00c0, 0x4ad9, 0x7122,
+	0x683c, 0x7026, 0x6840, 0x702a, 0x701b, 0x0001, 0x2091, 0x4080,
+	0x2071, 0xa600, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70ac, 0x8000,
+	0x70ae, 0x027f, 0x0e7f, 0x007c, 0x6844, 0xa086, 0x0100, 0x00c0,
+	0x4ad9, 0x6868, 0xa005, 0x00c0, 0x4ad9, 0x2009, 0x8020, 0x0078,
+	0x4aa9, 0x2071, 0xa714, 0x2d08, 0x206b, 0x0000, 0x7010, 0x8000,
+	0x7012, 0x7018, 0xa06d, 0x711a, 0x0040, 0x4ae9, 0x6902, 0x0078,
+	0x4aea, 0x711e, 0x0078, 0x4ac9, 0xa18c, 0x00ff, 0xa186, 0x0017,
+	0x0040, 0x4afa, 0xa186, 0x001e, 0x0040, 0x4afa, 0xa18e, 0x001f,
+	0x00c0, 0x4ad9, 0x684c, 0xd0cc, 0x0040, 0x4ad9, 0x6850, 0xa084,
+	0x00ff, 0xa086, 0x0001, 0x00c0, 0x4ad9, 0x2009, 0x8021, 0x0078,
+	0x4aa9, 0x7084, 0x8008, 0xa092, 0x001e, 0x00c8, 0x4ad9, 0x7186,
+	0xae90, 0x0003, 0xa210, 0x683c, 0x2012, 0x0078, 0x4b27, 0x7084,
+	0x8008, 0xa092, 0x000f, 0x00c8, 0x4ad9, 0x7186, 0xae90, 0x0003,
+	0x8003, 0xa210, 0x683c, 0x2012, 0x8210, 0x6840, 0x2012, 0x7088,
+	0xa10a, 0x0048, 0x4ac0, 0x718c, 0x7084, 0xa10a, 0x0048, 0x4ac0,
+	0x2071, 0x0000, 0x7018, 0xd084, 0x00c0, 0x4ac0, 0x2071, 0xa835,
+	0x7000, 0xa086, 0x0002, 0x00c0, 0x4b47, 0x1078, 0x4dc3, 0x2071,
+	0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x4ac0, 0x1078,
+	0x4dee, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0078,
+	0x4ac0, 0x007e, 0x684c, 0x007e, 0x6837, 0x0103, 0x20a9, 0x001c,
+	0xad80, 0x0011, 0x20a0, 0x2001, 0x0000, 0x40a4, 0x007f, 0xa084,
+	0x00ff, 0x684e, 0x007f, 0x684a, 0x6952, 0x007c, 0x2071, 0xa714,
+	0x7004, 0x0079, 0x4b6b, 0x4b75, 0x4b86, 0x4d94, 0x4d95, 0x4dbc,
+	0x4dc2, 0x4b76, 0x4d82, 0x4d23, 0x4da5, 0x007c, 0x127e, 0x2091,
+	0x8000, 0x0068, 0x4b85, 0x2009, 0x000d, 0x7030, 0x200a, 0x2091,
+	0x4080, 0x7007, 0x0001, 0x700b, 0x0000, 0x127f, 0x2069, 0xa8c4,
+	0x6844, 0xa005, 0x0050, 0x4bae, 0x00c0, 0x4bae, 0x127e, 0x2091,
+	0x8000, 0x2069, 0x0000, 0x6934, 0x2001, 0xa720, 0x2004, 0xa10a,
+	0x0040, 0x4ba9, 0x0068, 0x4bad, 0x2069, 0x0000, 0x6818, 0xd084,
+	0x00c0, 0x4bad, 0x2009, 0x8040, 0x6922, 0x681b, 0x0001, 0x2091,
+	0x4080, 0x2069, 0xa8c4, 0x6847, 0xffff, 0x127f, 0x2069, 0xa600,
+	0x6848, 0x6964, 0xa102, 0x2069, 0xa835, 0x688a, 0x6984, 0x701c,
+	0xa06d, 0x0040, 0x4bc0, 0x81ff, 0x0040, 0x4c08, 0x0078, 0x4bd6,
+	0x81ff, 0x0040, 0x4cda, 0x2071, 0xa835, 0x7184, 0x7088, 0xa10a,
+	0x00c8, 0x4bd6, 0x7190, 0x2071, 0xa8c4, 0x7040, 0xa005, 0x0040,
+	0x4bd6, 0x00d0, 0x4cda, 0x7142, 0x0078, 0x4cda, 0x2071, 0xa835,
+	0x718c, 0x127e, 0x2091, 0x8000, 0x7084, 0xa10a, 0x0048, 0x4cf7,
+	0x0068, 0x4c8c, 0x2071, 0x0000, 0x7018, 0xd084, 0x00c0, 0x4c8c,
+	0x2001, 0xffff, 0x2071, 0xa8c4, 0x7042, 0x2071, 0xa835, 0x7000,
+	0xa086, 0x0002, 0x00c0, 0x4bfe, 0x1078, 0x4dc3, 0x2071, 0x0000,
+	0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x4c8c, 0x1078, 0x4dee,
+	0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0078, 0x4c8c,
+	0x2071, 0xa835, 0x7000, 0xa005, 0x0040, 0x4cb9, 0x6934, 0xa186,
+	0x0103, 0x00c0, 0x4c8f, 0x684c, 0xd0bc, 0x00c0, 0x4cb9, 0x6948,
+	0x6844, 0xa105, 0x00c0, 0x4cac, 0x2009, 0x8020, 0x2071, 0xa835,
+	0x7000, 0x0079, 0x4c23, 0x4cb9, 0x4c71, 0x4c49, 0x4c5b, 0x4c28,
+	0x137e, 0x147e, 0x157e, 0x2099, 0xa676, 0x20a1, 0xa886, 0x20a9,
+	0x0004, 0x53a3, 0x157f, 0x147f, 0x137f, 0x2071, 0xa87d, 0xad80,
+	0x000f, 0x700e, 0x7013, 0x0002, 0x7007, 0x0002, 0x700b, 0x0000,
+	0x2e10, 0x1078, 0x13db, 0x2071, 0xa714, 0x7007, 0x0009, 0x0078,
+	0x4cda, 0x7084, 0x8008, 0xa092, 0x001e, 0x00c8, 0x4cda, 0xae90,
+	0x0003, 0xa210, 0x683c, 0x2012, 0x7186, 0x2071, 0xa714, 0x1078,
+	0x4e4c, 0x0078, 0x4cda, 0x7084, 0x8008, 0xa092, 0x000f, 0x00c8,
+	0x4cda, 0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012, 0x8210,
+	0x6840, 0x2012, 0x7186, 0x2071, 0xa714, 0x1078, 0x4e4c, 0x0078,
+	0x4cda, 0x127e, 0x2091, 0x8000, 0x0068, 0x4c8c, 0x2071, 0x0000,
+	0x7018, 0xd084, 0x00c0, 0x4c8c, 0x7122, 0x683c, 0x7026, 0x6840,
+	0x702a, 0x701b, 0x0001, 0x2091, 0x4080, 0x127f, 0x2071, 0xa714,
+	0x1078, 0x4e4c, 0x0078, 0x4cda, 0x127f, 0x0078, 0x4cda, 0xa18c,
+	0x00ff, 0xa186, 0x0017, 0x0040, 0x4c9d, 0xa186, 0x001e, 0x0040,
+	0x4c9d, 0xa18e, 0x001f, 0x00c0, 0x4cb9, 0x684c, 0xd0cc, 0x0040,
+	0x4cb9, 0x6850, 0xa084, 0x00ff, 0xa086, 0x0001, 0x00c0, 0x4cb9,
+	0x2009, 0x8021, 0x0078, 0x4c1e, 0x6844, 0xa086, 0x0100, 0x00c0,
+	0x4cb9, 0x6868, 0xa005, 0x00c0, 0x4cb9, 0x2009, 0x8020, 0x0078,
+	0x4c1e, 0x2071, 0xa714, 0x1078, 0x4e60, 0x0040, 0x4cda, 0x2071,
+	0xa714, 0x700f, 0x0001, 0x6934, 0xa184, 0x00ff, 0xa086, 0x0003,
+	0x00c0, 0x4cd1, 0x810f, 0xa18c, 0x00ff, 0x8101, 0x0040, 0x4cd1,
+	0x710e, 0x7007, 0x0003, 0x1078, 0x4e80, 0x7050, 0xa086, 0x0100,
+	0x0040, 0x4d95, 0x127e, 0x2091, 0x8000, 0x2071, 0xa714, 0x7008,
+	0xa086, 0x0001, 0x00c0, 0x4cf5, 0x0068, 0x4cf5, 0x2009, 0x000d,
+	0x7030, 0x200a, 0x2091, 0x4080, 0x700b, 0x0000, 0x7004, 0xa086,
+	0x0006, 0x00c0, 0x4cf5, 0x7007, 0x0001, 0x127f, 0x007c, 0x2071,
+	0xa714, 0x1078, 0x4e60, 0x0040, 0x4d20, 0x2071, 0xa835, 0x7084,
+	0x700a, 0x20a9, 0x0020, 0x2099, 0xa836, 0x20a1, 0xa85d, 0x53a3,
+	0x7087, 0x0000, 0x2071, 0xa714, 0x2069, 0xa87d, 0x706c, 0x6826,
+	0x7070, 0x682a, 0x7074, 0x682e, 0x7078, 0x6832, 0x2d10, 0x1078,
+	0x13db, 0x7007, 0x0008, 0x2001, 0xffff, 0x2071, 0xa8c4, 0x7042,
+	0x127f, 0x0078, 0x4cda, 0x2069, 0xa87d, 0x6808, 0xa08e, 0x0000,
+	0x0040, 0x4d81, 0xa08e, 0x0200, 0x0040, 0x4d7f, 0xa08e, 0x0100,
+	0x00c0, 0x4d81, 0x127e, 0x2091, 0x8000, 0x0068, 0x4d7c, 0x2069,
+	0x0000, 0x6818, 0xd084, 0x00c0, 0x4d7c, 0x702c, 0x7130, 0x8108,
+	0xa102, 0x0048, 0x4d4a, 0xa00e, 0x7034, 0x706e, 0x7038, 0x7072,
+	0x0078, 0x4d54, 0x706c, 0xa080, 0x0040, 0x706e, 0x00c8, 0x4d54,
+	0x7070, 0xa081, 0x0000, 0x7072, 0x7132, 0x6936, 0x700b, 0x0000,
+	0x2001, 0xa85a, 0x2004, 0xa005, 0x00c0, 0x4d73, 0x6934, 0x2069,
+	0xa835, 0x689c, 0x699e, 0x2069, 0xa8c4, 0xa102, 0x00c0, 0x4d6c,
+	0x6844, 0xa005, 0x00d0, 0x4d7a, 0x2001, 0xa85b, 0x200c, 0x810d,
+	0x6946, 0x0078, 0x4d7a, 0x2009, 0x8040, 0x6922, 0x681b, 0x0001,
+	0x2091, 0x4080, 0x7007, 0x0001, 0x127f, 0x0078, 0x4d81, 0x7007,
+	0x0005, 0x007c, 0x701c, 0xa06d, 0x0040, 0x4d93, 0x1078, 0x4e60,
+	0x0040, 0x4d93, 0x7007, 0x0003, 0x1078, 0x4e80, 0x7050, 0xa086,
+	0x0100, 0x0040, 0x4d95, 0x007c, 0x007c, 0x7050, 0xa09e, 0x0100,
+	0x00c0, 0x4d9e, 0x7007, 0x0004, 0x0078, 0x4dbc, 0xa086, 0x0200,
+	0x00c0, 0x4da4, 0x7007, 0x0005, 0x007c, 0x2001, 0xa87f, 0x2004,
+	0xa08e, 0x0100, 0x00c0, 0x4db1, 0x7007, 0x0001, 0x1078, 0x4e4c,
+	0x007c, 0xa08e, 0x0000, 0x0040, 0x4db0, 0xa08e, 0x0200, 0x00c0,
+	0x4db0, 0x7007, 0x0005, 0x007c, 0x1078, 0x4e16, 0x7006, 0x1078,
+	0x4e4c, 0x007c, 0x007c, 0x0e7e, 0x157e, 0x2071, 0xa835, 0x7184,
+	0x81ff, 0x0040, 0x4deb, 0xa006, 0x7086, 0xae80, 0x0003, 0x2071,
+	0x0000, 0x21a8, 0x2014, 0x7226, 0x8000, 0x0070, 0x4de8, 0x2014,
+	0x722a, 0x8000, 0x0070, 0x4de8, 0x2014, 0x722e, 0x8000, 0x0070,
+	0x4de8, 0x2014, 0x723a, 0x8000, 0x0070, 0x4de8, 0x2014, 0x723e,
+	0xa180, 0x8030, 0x7022, 0x157f, 0x0e7f, 0x007c, 0x0e7e, 0x157e,
+	0x2071, 0xa835, 0x7184, 0x81ff, 0x0040, 0x4e13, 0xa006, 0x7086,
+	0xae80, 0x0003, 0x2071, 0x0000, 0x21a8, 0x2014, 0x7226, 0x8000,
+	0x2014, 0x722a, 0x8000, 0x0070, 0x4e0c, 0x2014, 0x723a, 0x8000,
+	0x2014, 0x723e, 0x0078, 0x4e10, 0x2001, 0x8020, 0x0078, 0x4e12,
+	0x2001, 0x8042, 0x7022, 0x157f, 0x0e7f, 0x007c, 0x702c, 0x7130,
+	0x8108, 0xa102, 0x0048, 0x4e23, 0xa00e, 0x7034, 0x706e, 0x7038,
+	0x7072, 0x0078, 0x4e2d, 0x706c, 0xa080, 0x0040, 0x706e, 0x00c8,
+	0x4e2d, 0x7070, 0xa081, 0x0000, 0x7072, 0x7132, 0x700c, 0x8001,
+	0x700e, 0x00c0, 0x4e43, 0x127e, 0x2091, 0x8000, 0x0068, 0x4e46,
+	0x2001, 0x000d, 0x2102, 0x2091, 0x4080, 0x2001, 0x0001, 0x700b,
+	0x0000, 0x127f, 0x007c, 0x2001, 0x0007, 0x007c, 0x2001, 0x0006,
+	0x700b, 0x0001, 0x127f, 0x007c, 0x701c, 0xa06d, 0x0040, 0x4e5f,
+	0x127e, 0x2091, 0x8000, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e,
+	0xa005, 0x00c0, 0x4e5c, 0x701a, 0x127f, 0x1078, 0x13a4, 0x007c,
+	0x2019, 0x000d, 0x2304, 0x230c, 0xa10e, 0x0040, 0x4e6f, 0x2304,
+	0x230c, 0xa10e, 0x0040, 0x4e6f, 0xa006, 0x0078, 0x4e7f, 0x732c,
+	0x8319, 0x7130, 0xa102, 0x00c0, 0x4e79, 0x2300, 0xa005, 0x0078,
+	0x4e7f, 0x0048, 0x4e7e, 0xa302, 0x0078, 0x4e7f, 0x8002, 0x007c,
+	0x2d00, 0x7026, 0xa080, 0x000d, 0x7056, 0x7053, 0x0000, 0x127e,
+	0x2091, 0x8000, 0x2009, 0xa8d6, 0x2104, 0xc08d, 0x200a, 0x127f,
+	0x1078, 0x13f9, 0x007c, 0x2071, 0xa6e2, 0x7003, 0x0000, 0x7007,
+	0x0000, 0x700f, 0x0000, 0x702b, 0x0001, 0x704f, 0x0000, 0x7053,
+	0x0001, 0x705f, 0x0020, 0x7063, 0x0040, 0x7083, 0x0000, 0x708b,
+	0x0000, 0x708f, 0x0001, 0x70bf, 0x0000, 0x007c, 0x0e7e, 0x2071,
+	0xa6e2, 0x6848, 0xa005, 0x00c0, 0x4ebc, 0x7028, 0xc085, 0x702a,
+	0xa085, 0x0001, 0x0078, 0x4ee1, 0x6a50, 0x7236, 0x6b54, 0x733a,
+	0x6858, 0x703e, 0x707a, 0x685c, 0x7042, 0x707e, 0x6848, 0x702e,
+	0x6840, 0x7032, 0x2009, 0x000c, 0x200a, 0x8007, 0x8006, 0x8006,
+	0xa08c, 0x003f, 0xa084, 0xffc0, 0xa210, 0x2100, 0xa319, 0x7272,
+	0x7376, 0x7028, 0xc084, 0x702a, 0x7007, 0x0001, 0x700f, 0x0000,
+	0xa006, 0x0e7f, 0x007c, 0x2b78, 0x2071, 0xa6e2, 0x7004, 0x1079,
+	0x4f41, 0x700c, 0x0079, 0x4eec, 0x4ef1, 0x4ee6, 0x4ee6, 0x4ee6,
+	0x4ee6, 0x007c, 0x700c, 0x0079, 0x4ef5, 0x4efa, 0x4f3f, 0x4f3f,
+	0x4f40, 0x4f40, 0x7830, 0x7930, 0xa106, 0x0040, 0x4f04, 0x7830,
+	0x7930, 0xa106, 0x00c0, 0x4f2a, 0x7030, 0xa10a, 0x0040, 0x4f2a,
+	0x00c8, 0x4f0c, 0x712c, 0xa10a, 0xa18a, 0x0002, 0x00c8, 0x4f2b,
+	0x1078, 0x1370, 0x0040, 0x4f2a, 0x2d00, 0x705a, 0x7063, 0x0040,
+	0x2001, 0x0003, 0x7057, 0x0000, 0x127e, 0x007e, 0x2091, 0x8000,
+	0x2009, 0xa8d6, 0x2104, 0xc085, 0x200a, 0x007f, 0x700e, 0x127f,
+	0x1078, 0x13f9, 0x007c, 0x1078, 0x1370, 0x0040, 0x4f2a, 0x2d00,
+	0x705a, 0x1078, 0x1370, 0x00c0, 0x4f37, 0x0078, 0x4f16, 0x2d00,
+	0x7086, 0x7063, 0x0080, 0x2001, 0x0004, 0x0078, 0x4f1a, 0x007c,
+	0x007c, 0x4f52, 0x4f53, 0x4f8a, 0x4f8b, 0x4f3f, 0x4fc1, 0x4fc6,
+	0x4ffd, 0x4ffe, 0x5019, 0x501a, 0x501b, 0x501c, 0x501d, 0x501e,
+	0x509e, 0x50c8, 0x007c, 0x700c, 0x0079, 0x4f56, 0x4f5b, 0x4f5e,
+	0x4f6e, 0x4f89, 0x4f89, 0x1078, 0x4ef2, 0x007c, 0x127e, 0x8001,
+	0x700e, 0x7058, 0x007e, 0x1078, 0x5464, 0x0040, 0x4f6b, 0x2091,
+	0x8000, 0x1078, 0x4ef2, 0x0d7f, 0x0078, 0x4f77, 0x127e, 0x8001,
+	0x700e, 0x1078, 0x5464, 0x7058, 0x2068, 0x7084, 0x705a, 0x6803,
+	0x0000, 0x6807, 0x0000, 0x6834, 0xa084, 0x00ff, 0xa08a, 0x0020,
+	0x00c8, 0x4f86, 0x1079, 0x4fa1, 0x127f, 0x007c, 0x127f, 0x1078,
+	0x501f, 0x007c, 0x007c, 0x007c, 0x0e7e, 0x2071, 0xa6e2, 0x700c,
+	0x0079, 0x4f92, 0x4f97, 0x4f97, 0x4f97, 0x4f99, 0x4f9d, 0x0e7f,
+	0x007c, 0x700f, 0x0001, 0x0078, 0x4f9f, 0x700f, 0x0002, 0x0e7f,
+	0x007c, 0x501f, 0x501f, 0x503b, 0x501f, 0x5171, 0x501f, 0x501f,
+	0x501f, 0x501f, 0x501f, 0x503b, 0x51bb, 0x5208, 0x5261, 0x5277,
+	0x501f, 0x501f, 0x5057, 0x503b, 0x501f, 0x501f, 0x5078, 0x5338,
+	0x5356, 0x501f, 0x5057, 0x501f, 0x501f, 0x501f, 0x501f, 0x506d,
+	0x5356, 0x7020, 0x2068, 0x1078, 0x13a4, 0x007c, 0x700c, 0x0079,
+	0x4fc9, 0x4fce, 0x4fd1, 0x4fe1, 0x4ffc, 0x4ffc, 0x1078, 0x4ef2,
+	0x007c, 0x127e, 0x8001, 0x700e, 0x7058, 0x007e, 0x1078, 0x5464,
+	0x0040, 0x4fde, 0x2091, 0x8000, 0x1078, 0x4ef2, 0x0d7f, 0x0078,
+	0x4fea, 0x127e, 0x8001, 0x700e, 0x1078, 0x5464, 0x7058, 0x2068,
+	0x7084, 0x705a, 0x6803, 0x0000, 0x6807, 0x0000, 0x6834, 0xa084,
+	0x00ff, 0xa08a, 0x001a, 0x00c8, 0x4ff9, 0x1079, 0x4fff, 0x127f,
+	0x007c, 0x127f, 0x1078, 0x501f, 0x007c, 0x007c, 0x007c, 0x501f,
+	0x503b, 0x515b, 0x501f, 0x503b, 0x501f, 0x503b, 0x503b, 0x501f,
+	0x503b, 0x515b, 0x503b, 0x503b, 0x503b, 0x503b, 0x503b, 0x501f,
+	0x503b, 0x515b, 0x501f, 0x501f, 0x503b, 0x501f, 0x501f, 0x501f,
+	0x503b, 0x007c, 0x007c, 0x007c, 0x007c, 0x007c, 0x007c, 0x7007,
+	0x0001, 0x6838, 0xa084, 0x00ff, 0xc0d5, 0x683a, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x4a73, 0x127f, 0x007c, 0x7007, 0x0001, 0x6838,
+	0xa084, 0x00ff, 0xc0e5, 0x683a, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x4a73, 0x127f, 0x007c, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff,
+	0xc0ed, 0x683a, 0x127e, 0x2091, 0x8000, 0x1078, 0x4a73, 0x127f,
+	0x007c, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0dd, 0x683a,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x4a73, 0x127f, 0x007c, 0x6834,
+	0x8007, 0xa084, 0x00ff, 0x0040, 0x502d, 0x8001, 0x00c0, 0x5064,
+	0x7007, 0x0001, 0x0078, 0x513a, 0x7007, 0x0006, 0x7012, 0x2d00,
+	0x7016, 0x701a, 0x704b, 0x513a, 0x007c, 0x684c, 0xa084, 0x00c0,
+	0xa086, 0x00c0, 0x00c0, 0x5078, 0x7007, 0x0001, 0x0078, 0x5373,
+	0x2d00, 0x7016, 0x701a, 0x20a9, 0x0004, 0xa080, 0x0024, 0x2098,
+	0x20a1, 0xa70d, 0x53a3, 0x6858, 0x7012, 0xa082, 0x0401, 0x00c8,
+	0x5049, 0x6884, 0xa08a, 0x0002, 0x00c8, 0x5049, 0x82ff, 0x00c0,
+	0x509a, 0x6888, 0x698c, 0xa105, 0x0040, 0x509a, 0x2001, 0x510a,
+	0x0078, 0x509d, 0xa280, 0x5100, 0x2004, 0x70c6, 0x7010, 0xa015,
+	0x0040, 0x50e8, 0x1078, 0x1370, 0x00c0, 0x50a9, 0x7007, 0x000f,
+	0x007c, 0x2d00, 0x7022, 0x70c4, 0x2060, 0x6000, 0x6836, 0x6004,
+	0xad00, 0x7096, 0x6008, 0xa20a, 0x00c8, 0x50b8, 0xa00e, 0x2200,
+	0x7112, 0x620c, 0x8003, 0x800b, 0xa296, 0x0004, 0x0040, 0x50c1,
+	0xa108, 0x719a, 0x810b, 0x719e, 0xae90, 0x0022, 0x1078, 0x13db,
+	0x7090, 0xa08e, 0x0100, 0x0040, 0x50dc, 0xa086, 0x0200, 0x0040,
+	0x50d4, 0x7007, 0x0010, 0x007c, 0x7020, 0x2068, 0x1078, 0x13a4,
+	0x7014, 0x2068, 0x0078, 0x5049, 0x7020, 0x2068, 0x7018, 0x6802,
+	0x6807, 0x0000, 0x2d08, 0x2068, 0x6906, 0x711a, 0x0078, 0x509e,
+	0x7014, 0x2068, 0x7007, 0x0001, 0x6884, 0xa005, 0x00c0, 0x50f7,
+	0x6888, 0x698c, 0xa105, 0x0040, 0x50f7, 0x1078, 0x510e, 0x6834,
+	0xa084, 0x00ff, 0xa086, 0x001e, 0x0040, 0x5373, 0x0078, 0x513a,
+	0x5102, 0x5106, 0x0002, 0x0011, 0x0007, 0x0004, 0x000a, 0x000f,
+	0x0005, 0x0006, 0x000a, 0x0011, 0x0005, 0x0004, 0x0f7e, 0x0e7e,
+	0x0c7e, 0x077e, 0x067e, 0x6f88, 0x6e8c, 0x6804, 0x2060, 0xacf0,
+	0x0021, 0xacf8, 0x0027, 0x2009, 0x0005, 0x700c, 0x7816, 0x7008,
+	0x7812, 0x7004, 0x7806, 0x7000, 0x7802, 0x7e0e, 0x7f0a, 0x8109,
+	0x0040, 0x5130, 0xaef2, 0x0004, 0xaffa, 0x0006, 0x0078, 0x511d,
+	0x6004, 0xa065, 0x00c0, 0x5117, 0x067f, 0x077f, 0x0c7f, 0x0e7f,
+	0x0f7f, 0x007c, 0x2009, 0xa62f, 0x210c, 0x81ff, 0x00c0, 0x5155,
+	0x6838, 0xa084, 0x00ff, 0x683a, 0x1078, 0x4353, 0x00c0, 0x5149,
+	0x007c, 0x1078, 0x4b51, 0x127e, 0x2091, 0x8000, 0x1078, 0x8f7d,
+	0x1078, 0x4a73, 0x127f, 0x0078, 0x5148, 0x2001, 0x0028, 0x2009,
+	0x0000, 0x0078, 0x5149, 0x7018, 0x6802, 0x2d08, 0x2068, 0x6906,
+	0x711a, 0x7010, 0x8001, 0x7012, 0x0040, 0x516a, 0x7007, 0x0006,
+	0x0078, 0x5170, 0x7014, 0x2068, 0x7007, 0x0001, 0x7048, 0x107a,
+	0x007c, 0x7007, 0x0001, 0x6944, 0x810f, 0xa18c, 0x00ff, 0x6848,
+	0xa084, 0x00ff, 0x20a9, 0x0001, 0xa096, 0x0001, 0x0040, 0x519a,
+	0x2009, 0x0000, 0x20a9, 0x00ff, 0xa096, 0x0002, 0x0040, 0x519a,
+	0xa005, 0x00c0, 0x51ad, 0x6944, 0x810f, 0xa18c, 0x00ff, 0x1078,
+	0x45c4, 0x00c0, 0x51ad, 0x067e, 0x6e50, 0x1078, 0x46b3, 0x067f,
+	0x0078, 0x51ad, 0x047e, 0x2011, 0xa60c, 0x2224, 0xc484, 0xc48c,
+	0x2412, 0x047f, 0x0c7e, 0x1078, 0x45c4, 0x00c0, 0x51a9, 0x1078,
+	0x4852, 0x8108, 0x00f0, 0x51a3, 0x0c7f, 0x684c, 0xd084, 0x00c0,
+	0x51b4, 0x1078, 0x13a4, 0x007c, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x4a73, 0x127f, 0x007c, 0x127e, 0x2091, 0x8000, 0x7007, 0x0001,
+	0x2001, 0xa653, 0x2004, 0xd0a4, 0x0040, 0x51ff, 0x2061, 0xa933,
+	0x6100, 0xd184, 0x0040, 0x51df, 0x6858, 0xa084, 0x00ff, 0x00c0,
+	0x5202, 0x6000, 0xd084, 0x0040, 0x51ff, 0x6004, 0xa005, 0x00c0,
+	0x5205, 0x6003, 0x0000, 0x600b, 0x0000, 0x0078, 0x51fc, 0x2011,
+	0x0001, 0x6860, 0xa005, 0x00c0, 0x51e7, 0x2001, 0x001e, 0x8000,
+	0x6016, 0x6858, 0xa084, 0x00ff, 0x0040, 0x51ff, 0x6006, 0x6858,
+	0x8007, 0xa084, 0x00ff, 0x0040, 0x51ff, 0x600a, 0x6858, 0x8000,
+	0x00c0, 0x51fb, 0xc28d, 0x6202, 0x127f, 0x0078, 0x5453, 0x127f,
+	0x0078, 0x544b, 0x127f, 0x0078, 0x5443, 0x127f, 0x0078, 0x5447,
+	0x127e, 0x2091, 0x8000, 0x7007, 0x0001, 0x2001, 0xa653, 0x2004,
+	0xd0a4, 0x0040, 0x525e, 0x2061, 0xa933, 0x6000, 0xd084, 0x0040,
+	0x525e, 0x6204, 0x6308, 0xd08c, 0x00c0, 0x5250, 0x6c48, 0xa484,
+	0x0003, 0x0040, 0x5236, 0x6958, 0xa18c, 0x00ff, 0x8001, 0x00c0,
+	0x522f, 0x2100, 0xa210, 0x0048, 0x525b, 0x0078, 0x5236, 0x8001,
+	0x00c0, 0x525b, 0x2100, 0xa212, 0x0048, 0x525b, 0xa484, 0x000c,
+	0x0040, 0x5250, 0x6958, 0x810f, 0xa18c, 0x00ff, 0xa082, 0x0004,
+	0x00c0, 0x5248, 0x2100, 0xa318, 0x0048, 0x525b, 0x0078, 0x5250,
+	0xa082, 0x0004, 0x00c0, 0x525b, 0x2100, 0xa31a, 0x0048, 0x525b,
+	0x6860, 0xa005, 0x0040, 0x5256, 0x8000, 0x6016, 0x6206, 0x630a,
+	0x127f, 0x0078, 0x5453, 0x127f, 0x0078, 0x544f, 0x127f, 0x0078,
+	0x544b, 0x127e, 0x2091, 0x8000, 0x7007, 0x0001, 0x2061, 0xa933,
+	0x6300, 0xd38c, 0x00c0, 0x5271, 0x6308, 0x8318, 0x0048, 0x5274,
+	0x630a, 0x127f, 0x0078, 0x5461, 0x127f, 0x0078, 0x544f, 0x127e,
+	0x0c7e, 0x2091, 0x8000, 0x7007, 0x0001, 0x684c, 0xd0ac, 0x0040,
+	0x528b, 0x0c7e, 0x2061, 0xa933, 0x6000, 0xa084, 0xfcff, 0x6002,
+	0x0c7f, 0x0078, 0x52ba, 0x6858, 0xa005, 0x0040, 0x52d1, 0x685c,
+	0xa065, 0x0040, 0x52cd, 0x2001, 0xa62f, 0x2004, 0xa005, 0x0040,
+	0x529d, 0x1078, 0x8ec6, 0x0078, 0x52ab, 0x6013, 0x0400, 0x6037,
+	0x0000, 0x694c, 0xd1a4, 0x0040, 0x52a7, 0x6950, 0x6136, 0x2009,
+	0x0041, 0x1078, 0x775c, 0x6958, 0xa18c, 0xff00, 0xa186, 0x2000,
+	0x00c0, 0x52ba, 0x027e, 0x2009, 0x0000, 0x2011, 0xfdff, 0x1078,
+	0x5bf1, 0x027f, 0x684c, 0xd0c4, 0x0040, 0x52c9, 0x2061, 0xa933,
+	0x6000, 0xd08c, 0x00c0, 0x52c9, 0x6008, 0x8000, 0x0048, 0x52cd,
+	0x600a, 0x0c7f, 0x127f, 0x0078, 0x5453, 0x0c7f, 0x127f, 0x0078,
+	0x544b, 0x6954, 0xa186, 0x0045, 0x0040, 0x5306, 0xa186, 0x002a,
+	0x00c0, 0x52e1, 0x2001, 0xa60c, 0x200c, 0xc194, 0x2102, 0x0078,
+	0x52ba, 0xa186, 0x0020, 0x0040, 0x52fa, 0xa186, 0x0029, 0x0040,
+	0x52ed, 0xa186, 0x002d, 0x00c0, 0x52cd, 0x6944, 0xa18c, 0xff00,
+	0x810f, 0x1078, 0x45c4, 0x00c0, 0x52ba, 0x6000, 0xc0e4, 0x6002,
+	0x0078, 0x52ba, 0x685c, 0xa065, 0x0040, 0x52cd, 0x6007, 0x0024,
+	0x2001, 0xa8a3, 0x2004, 0x6016, 0x0078, 0x52ba, 0x685c, 0xa065,
+	0x0040, 0x52cd, 0x0e7e, 0x6860, 0xa075, 0x2001, 0xa62f, 0x2004,
+	0xa005, 0x0040, 0x531e, 0x1078, 0x8ec6, 0x8eff, 0x0040, 0x531b,
+	0x2e60, 0x1078, 0x8ec6, 0x0e7f, 0x0078, 0x52ba, 0x6024, 0xc0dc,
+	0xc0d5, 0x6026, 0x2e60, 0x6007, 0x003a, 0x6870, 0xa005, 0x0040,
+	0x532f, 0x6007, 0x003b, 0x6874, 0x602a, 0x6878, 0x6012, 0x6003,
+	0x0001, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0e7f, 0x0078, 0x52ba,
+	0x2061, 0xa933, 0x6000, 0xd084, 0x0040, 0x5352, 0xd08c, 0x00c0,
+	0x5461, 0x2091, 0x8000, 0x6204, 0x8210, 0x0048, 0x534c, 0x6206,
+	0x2091, 0x8001, 0x0078, 0x5461, 0x2091, 0x8001, 0x6853, 0x0016,
+	0x0078, 0x545a, 0x6853, 0x0007, 0x0078, 0x545a, 0x6834, 0x8007,
+	0xa084, 0x00ff, 0x00c0, 0x5360, 0x1078, 0x502d, 0x0078, 0x5372,
+	0x2030, 0x8001, 0x00c0, 0x536a, 0x7007, 0x0001, 0x1078, 0x5373,
+	0x0078, 0x5372, 0x7007, 0x0006, 0x7012, 0x2d00, 0x7016, 0x701a,
+	0x704b, 0x5373, 0x007c, 0x0e7e, 0x127e, 0x2091, 0x8000, 0xa03e,
+	0x2009, 0xa62f, 0x210c, 0x81ff, 0x00c0, 0x53ff, 0x2009, 0xa60c,
+	0x210c, 0xd194, 0x00c0, 0x5431, 0x6848, 0x2070, 0xae82, 0xad00,
+	0x0048, 0x53ef, 0x2001, 0xa616, 0x2004, 0xae02, 0x00c8, 0x53ef,
+	0x2061, 0xa933, 0x6100, 0xa184, 0x0301, 0xa086, 0x0001, 0x00c0,
+	0x53d2, 0x711c, 0xa186, 0x0006, 0x00c0, 0x53da, 0x7018, 0xa005,
+	0x0040, 0x53ff, 0x2004, 0xd0e4, 0x00c0, 0x542b, 0x7024, 0xd0dc,
+	0x00c0, 0x5435, 0x6853, 0x0000, 0x6803, 0x0000, 0x2d08, 0x7010,
+	0xa005, 0x00c0, 0x53be, 0x7112, 0x684c, 0xd0f4, 0x00c0, 0x5439,
+	0x2e60, 0x1078, 0x5b27, 0x127f, 0x0e7f, 0x007c, 0x2068, 0x6800,
+	0xa005, 0x00c0, 0x53be, 0x6902, 0x2168, 0x684c, 0xd0f4, 0x00c0,
+	0x5439, 0x127f, 0x0e7f, 0x007c, 0x127f, 0x0e7f, 0x6853, 0x0006,
+	0x0078, 0x545a, 0xd184, 0x0040, 0x53cc, 0xd1c4, 0x00c0, 0x53f3,
+	0x0078, 0x53f7, 0x6944, 0xa18c, 0xff00, 0x810f, 0x1078, 0x45c4,
+	0x00c0, 0x542b, 0x6000, 0xd0e4, 0x00c0, 0x542b, 0x711c, 0xa186,
+	0x0007, 0x00c0, 0x53ef, 0x6853, 0x0002, 0x0078, 0x542d, 0x6853,
+	0x0008, 0x0078, 0x542d, 0x6853, 0x000e, 0x0078, 0x542d, 0x6853,
+	0x0017, 0x0078, 0x542d, 0x6853, 0x0035, 0x0078, 0x542d, 0x2001,
+	0xa672, 0x2004, 0xd0fc, 0x0040, 0x5427, 0x6848, 0x2070, 0xae82,
+	0xad00, 0x0048, 0x5427, 0x6058, 0xae02, 0x00c8, 0x5427, 0x711c,
+	0xa186, 0x0006, 0x00c0, 0x5427, 0x7018, 0xa005, 0x0040, 0x5427,
+	0x2004, 0xd0bc, 0x0040, 0x5427, 0x2039, 0x0001, 0x7000, 0xa086,
+	0x0007, 0x00c0, 0x537e, 0x7003, 0x0002, 0x0078, 0x537e, 0x6853,
+	0x0028, 0x0078, 0x542d, 0x6853, 0x0029, 0x127f, 0x0e7f, 0x0078,
+	0x545a, 0x6853, 0x002a, 0x0078, 0x542d, 0x6853, 0x0045, 0x0078,
+	0x542d, 0x2e60, 0x2019, 0x0002, 0x6017, 0x0014, 0x1078, 0x9dc7,
+	0x127f, 0x0e7f, 0x007c, 0x2009, 0x003e, 0x0078, 0x5455, 0x2009,
+	0x0004, 0x0078, 0x5455, 0x2009, 0x0006, 0x0078, 0x5455, 0x2009,
+	0x0016, 0x0078, 0x5455, 0x2009, 0x0001, 0x6854, 0xa084, 0xff00,
+	0xa105, 0x6856, 0x2091, 0x8000, 0x1078, 0x4a73, 0x2091, 0x8001,
+	0x007c, 0x1078, 0x13a4, 0x007c, 0x702c, 0x7130, 0x8108, 0xa102,
+	0x0048, 0x5471, 0xa00e, 0x7034, 0x7072, 0x7038, 0x7076, 0x0078,
+	0x547d, 0x7070, 0xa080, 0x0040, 0x7072, 0x00c8, 0x547d, 0x7074,
+	0xa081, 0x0000, 0x7076, 0xa085, 0x0001, 0x7932, 0x7132, 0x007c,
+	0x0d7e, 0x1078, 0x5b1e, 0x0d7f, 0x007c, 0x0d7e, 0x2011, 0x0004,
+	0x2204, 0xa085, 0x8002, 0x2012, 0x0d7f, 0x007c, 0x20e1, 0x0002,
+	0x3d08, 0x20e1, 0x2000, 0x3d00, 0xa084, 0x7000, 0x0040, 0x549c,
+	0xa086, 0x1000, 0x00c0, 0x54d3, 0x20e1, 0x0000, 0x3d00, 0xa094,
+	0xff00, 0x8217, 0xa084, 0xf000, 0xa086, 0x3000, 0x00c0, 0x54b7,
+	0xa184, 0xff00, 0x8007, 0xa086, 0x0008, 0x00c0, 0x54d3, 0x1078,
+	0x29bb, 0x00c0, 0x54d3, 0x1078, 0x56b2, 0x0078, 0x54ce, 0x20e1,
+	0x0004, 0x3d60, 0xd1bc, 0x00c0, 0x54be, 0x3e60, 0xac84, 0x000f,
+	0x00c0, 0x54d3, 0xac82, 0xad00, 0x0048, 0x54d3, 0x6858, 0xac02,
+	0x00c8, 0x54d3, 0x2009, 0x0047, 0x1078, 0x775c, 0x7a1c, 0xd284,
+	0x00c0, 0x548e, 0x007c, 0xa016, 0x1078, 0x15fa, 0x0078, 0x54ce,
+	0x0078, 0x54d3, 0x781c, 0xd08c, 0x0040, 0x5502, 0x157e, 0x137e,
+	0x147e, 0x20e1, 0x3000, 0x3d20, 0x3e28, 0xa584, 0x0076, 0x00c0,
+	0x5518, 0xa484, 0x7000, 0xa086, 0x1000, 0x00c0, 0x5507, 0x1078,
+	0x554e, 0x0040, 0x5518, 0x20e1, 0x3000, 0x7828, 0x7828, 0x1078,
+	0x556c, 0x147f, 0x137f, 0x157f, 0x2009, 0xa8b9, 0x2104, 0xa005,
+	0x00c0, 0x5503, 0x007c, 0x1078, 0x62d1, 0x0078, 0x5502, 0xa484,
+	0x7000, 0x00c0, 0x5518, 0x1078, 0x554e, 0x0040, 0x552c, 0x7000,
+	0xa084, 0xff00, 0xa086, 0x8100, 0x0040, 0x54f3, 0x0078, 0x552c,
+	0x1078, 0xa54f, 0xd5a4, 0x0040, 0x5528, 0x047e, 0x1078, 0x1b22,
+	0x047f, 0x20e1, 0x9010, 0x2001, 0x0138, 0x2202, 0x0078, 0x5530,
+	0x1078, 0x554e, 0x6883, 0x0000, 0x20e1, 0x3000, 0x7828, 0x7828,
+	0x1078, 0x5537, 0x147f, 0x137f, 0x157f, 0x0078, 0x5502, 0x2001,
+	0xa60e, 0x2004, 0xd08c, 0x0040, 0x554d, 0x2001, 0xa600, 0x2004,
+	0xa086, 0x0003, 0x00c0, 0x554d, 0x027e, 0x037e, 0x2011, 0x8048,
+	0x2518, 0x1078, 0x361b, 0x037f, 0x027f, 0x007c, 0xa484, 0x01ff,
+	0x6882, 0xa005, 0x0040, 0x5560, 0xa080, 0x001f, 0xa084, 0x03f8,
+	0x80ac, 0x20e1, 0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0x007c,
+	0x20a9, 0x000c, 0x20e1, 0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5,
+	0xa085, 0x0001, 0x0078, 0x555f, 0x7000, 0xa084, 0xff00, 0xa08c,
+	0xf000, 0x8007, 0xa196, 0x0000, 0x00c0, 0x5579, 0x0078, 0x57ba,
+	0x007c, 0xa196, 0x2000, 0x00c0, 0x558a, 0x6900, 0xa18e, 0x0001,
+	0x00c0, 0x5586, 0x1078, 0x3aec, 0x0078, 0x5578, 0x1078, 0x5592,
+	0x0078, 0x5578, 0xa196, 0x8000, 0x00c0, 0x5578, 0x1078, 0x5871,
+	0x0078, 0x5578, 0x0c7e, 0x7110, 0xa18c, 0xff00, 0x810f, 0xa196,
+	0x0001, 0x0040, 0x559f, 0xa196, 0x0023, 0x00c0, 0x56aa, 0xa08e,
+	0x0023, 0x00c0, 0x55d4, 0x1078, 0x591d, 0x0040, 0x56aa, 0x7124,
+	0x610a, 0x7030, 0xa08e, 0x0200, 0x00c0, 0x55b8, 0x7034, 0xa005,
+	0x00c0, 0x56aa, 0x2009, 0x0015, 0x1078, 0x775c, 0x0078, 0x56aa,
+	0xa08e, 0x0214, 0x0040, 0x55c0, 0xa08e, 0x0210, 0x00c0, 0x55c6,
+	0x2009, 0x0015, 0x1078, 0x775c, 0x0078, 0x56aa, 0xa08e, 0x0100,
+	0x00c0, 0x56aa, 0x7034, 0xa005, 0x00c0, 0x56aa, 0x2009, 0x0016,
+	0x1078, 0x775c, 0x0078, 0x56aa, 0xa08e, 0x0022, 0x00c0, 0x56aa,
+	0x7030, 0xa08e, 0x0300, 0x00c0, 0x55e5, 0x7034, 0xa005, 0x00c0,
+	0x56aa, 0x2009, 0x0017, 0x0078, 0x5676, 0xa08e, 0x0500, 0x00c0,
+	0x55f1, 0x7034, 0xa005, 0x00c0, 0x56aa, 0x2009, 0x0018, 0x0078,
+	0x5676, 0xa08e, 0x2010, 0x00c0, 0x55f9, 0x2009, 0x0019, 0x0078,
+	0x5676, 0xa08e, 0x2110, 0x00c0, 0x5601, 0x2009, 0x001a, 0x0078,
+	0x5676, 0xa08e, 0x5200, 0x00c0, 0x560d, 0x7034, 0xa005, 0x00c0,
+	0x56aa, 0x2009, 0x001b, 0x0078, 0x5676, 0xa08e, 0x5000, 0x00c0,
+	0x5619, 0x7034, 0xa005, 0x00c0, 0x56aa, 0x2009, 0x001c, 0x0078,
+	0x5676, 0xa08e, 0x1300, 0x00c0, 0x5621, 0x2009, 0x0034, 0x0078,
+	0x5676, 0xa08e, 0x1200, 0x00c0, 0x562d, 0x7034, 0xa005, 0x00c0,
+	0x56aa, 0x2009, 0x0024, 0x0078, 0x5676, 0xa08c, 0xff00, 0xa18e,
+	0x2400, 0x00c0, 0x5637, 0x2009, 0x002d, 0x0078, 0x5676, 0xa08c,
+	0xff00, 0xa18e, 0x5300, 0x00c0, 0x5641, 0x2009, 0x002a, 0x0078,
+	0x5676, 0xa08e, 0x0f00, 0x00c0, 0x5649, 0x2009, 0x0020, 0x0078,
+	0x5676, 0xa08e, 0x5300, 0x00c0, 0x564f, 0x0078, 0x566c, 0xa08e,
+	0x6104, 0x00c0, 0x566c, 0x2011, 0xab8d, 0x8208, 0x2204, 0xa082,
+	0x0004, 0x20a8, 0x95ac, 0x95ac, 0x2011, 0x8015, 0x211c, 0x8108,
+	0x047e, 0x2124, 0x1078, 0x361b, 0x047f, 0x8108, 0x00f0, 0x565c,
+	0x2009, 0x0023, 0x0078, 0x5676, 0xa08e, 0x6000, 0x00c0, 0x5674,
+	0x2009, 0x003f, 0x0078, 0x5676, 0x2009, 0x001d, 0x017e, 0x2011,
+	0xab83, 0x2204, 0x8211, 0x220c, 0x1078, 0x254d, 0x00c0, 0x56ac,
+	0x1078, 0x455c, 0x00c0, 0x56ac, 0x6612, 0x6516, 0x86ff, 0x0040,
+	0x569c, 0x017f, 0x017e, 0xa186, 0x0017, 0x00c0, 0x569c, 0x686c,
+	0xa606, 0x00c0, 0x569c, 0x6870, 0xa506, 0xa084, 0xff00, 0x00c0,
+	0x569c, 0x6000, 0xc0f5, 0x6002, 0x0c7e, 0x1078, 0x76c7, 0x0040,
+	0x56af, 0x017f, 0x611a, 0x601f, 0x0004, 0x7120, 0x610a, 0x017f,
+	0x1078, 0x775c, 0x0c7f, 0x007c, 0x017f, 0x0078, 0x56aa, 0x0c7f,
+	0x0078, 0x56ac, 0x0c7e, 0x1078, 0x570f, 0x00c0, 0x570d, 0xa28e,
+	0x0033, 0x00c0, 0x56de, 0x1078, 0x591d, 0x0040, 0x570d, 0x7124,
+	0x610a, 0x7030, 0xa08e, 0x0200, 0x00c0, 0x56d0, 0x7034, 0xa005,
+	0x00c0, 0x570d, 0x2009, 0x0015, 0x1078, 0x775c, 0x0078, 0x570d,
+	0xa08e, 0x0100, 0x00c0, 0x570d, 0x7034, 0xa005, 0x00c0, 0x570d,
+	0x2009, 0x0016, 0x1078, 0x775c, 0x0078, 0x570d, 0xa28e, 0x0032,
+	0x00c0, 0x570d, 0x7030, 0xa08e, 0x1400, 0x00c0, 0x570d, 0x2009,
+	0x0038, 0x017e, 0x2011, 0xab83, 0x2204, 0x8211, 0x220c, 0x1078,
+	0x254d, 0x00c0, 0x570c, 0x1078, 0x455c, 0x00c0, 0x570c, 0x6612,
+	0x6516, 0x0c7e, 0x1078, 0x76c7, 0x0040, 0x570b, 0x017f, 0x611a,
+	0x601f, 0x0004, 0x7120, 0x610a, 0x017f, 0x1078, 0x775c, 0x1078,
+	0x62d1, 0x0078, 0x570d, 0x0c7f, 0x017f, 0x0c7f, 0x007c, 0x0f7e,
+	0x0d7e, 0x027e, 0x017e, 0x137e, 0x147e, 0x157e, 0x3c00, 0x007e,
+	0x2079, 0x0030, 0x2069, 0x0200, 0x1078, 0x1c6a, 0x00c0, 0x5750,
+	0x1078, 0x1b40, 0x0040, 0x575d, 0x7908, 0xa18c, 0x1fff, 0xa182,
+	0x0011, 0x00c8, 0x575a, 0x20a9, 0x000c, 0x20e1, 0x0000, 0x2ea0,
+	0x2099, 0x020a, 0x53a5, 0x20e1, 0x2000, 0x2001, 0x020a, 0x2004,
+	0x7a0c, 0x7808, 0xa080, 0x0007, 0xa084, 0x1ff8, 0xa08a, 0x0140,
+	0x10c8, 0x1332, 0x80ac, 0x20e1, 0x6000, 0x2099, 0x020a, 0x53a5,
+	0x20e1, 0x7000, 0x6828, 0x6828, 0x7803, 0x0004, 0xa294, 0x0070,
+	0x007f, 0x20e0, 0x157f, 0x147f, 0x137f, 0x017f, 0x027f, 0x0d7f,
+	0x0f7f, 0x007c, 0xa016, 0x1078, 0x15fa, 0xa085, 0x0001, 0x0078,
+	0x5750, 0x047e, 0x0e7e, 0x0d7e, 0x2028, 0x2130, 0xa696, 0x00ff,
+	0x00c0, 0x5782, 0xa596, 0xfffd, 0x00c0, 0x5772, 0x2009, 0x007f,
+	0x0078, 0x57b5, 0xa596, 0xfffe, 0x00c0, 0x577a, 0x2009, 0x007e,
+	0x0078, 0x57b5, 0xa596, 0xfffc, 0x00c0, 0x5782, 0x2009, 0x0080,
+	0x0078, 0x57b5, 0x2011, 0x0000, 0x2021, 0x0081, 0x20a9, 0x007e,
+	0x2071, 0xa7b6, 0x2e1c, 0x83ff, 0x00c0, 0x5794, 0x82ff, 0x00c0,
+	0x57a9, 0x2410, 0x0078, 0x57a9, 0x2368, 0x6f10, 0x007e, 0x2100,
+	0xa706, 0x007f, 0x6b14, 0x00c0, 0x57a3, 0xa346, 0x00c0, 0x57a3,
+	0x2408, 0x0078, 0x57b5, 0x87ff, 0x00c0, 0x57a9, 0x83ff, 0x0040,
+	0x578e, 0x8420, 0x8e70, 0x00f0, 0x578a, 0x82ff, 0x00c0, 0x57b4,
+	0xa085, 0x0001, 0x0078, 0x57b6, 0x2208, 0xa006, 0x0d7f, 0x0e7f,
+	0x047f, 0x007c, 0xa084, 0x0007, 0x0079, 0x57bf, 0x007c, 0x57c7,
+	0x57c7, 0x57c7, 0x5933, 0x57c7, 0x57c8, 0x57e1, 0x5858, 0x007c,
+	0x7110, 0xd1bc, 0x0040, 0x57e0, 0x7120, 0x2160, 0xac8c, 0x000f,
+	0x00c0, 0x57e0, 0xac8a, 0xad00, 0x0048, 0x57e0, 0x6858, 0xac02,
+	0x00c8, 0x57e0, 0x7124, 0x610a, 0x2009, 0x0046, 0x1078, 0x775c,
+	0x007c, 0x0c7e, 0xa484, 0x01ff, 0x0040, 0x5833, 0x7110, 0xd1bc,
+	0x00c0, 0x5833, 0x2011, 0xab83, 0x2204, 0x8211, 0x220c, 0x1078,
+	0x254d, 0x00c0, 0x5833, 0x1078, 0x455c, 0x00c0, 0x5833, 0x6612,
+	0x6516, 0x6000, 0xd0ec, 0x00c0, 0x5833, 0x6204, 0xa294, 0xff00,
+	0x8217, 0xa286, 0x0006, 0x00c0, 0x5818, 0x0c7e, 0x1078, 0x76c7,
+	0x017f, 0x0040, 0x5835, 0x611a, 0x601f, 0x0006, 0x7120, 0x610a,
+	0x7130, 0x6122, 0x2009, 0x0044, 0x1078, 0x775c, 0x0078, 0x5833,
+	0x0c7e, 0x1078, 0x76c7, 0x017f, 0x0040, 0x5833, 0x611a, 0x601f,
+	0x0004, 0x7120, 0x610a, 0xa286, 0x0004, 0x00c0, 0x582b, 0x6007,
+	0x0005, 0x0078, 0x582d, 0x6007, 0x0001, 0x6003, 0x0001, 0x1078,
+	0x5dd7, 0x1078, 0x62d1, 0x0c7f, 0x007c, 0x2001, 0xa60d, 0x2004,
+	0xd0ec, 0x0040, 0x583f, 0x2011, 0x8049, 0x1078, 0x361b, 0x0c7e,
+	0x1078, 0x9187, 0x017f, 0x0040, 0x5833, 0x611a, 0x601f, 0x0006,
+	0x7120, 0x610a, 0x7130, 0x6122, 0x6013, 0x0300, 0x6003, 0x0001,
+	0x6007, 0x0041, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0078, 0x5833,
+	0x7110, 0xd1bc, 0x0040, 0x5870, 0x7020, 0x2060, 0xac84, 0x000f,
+	0x00c0, 0x5870, 0xac82, 0xad00, 0x0048, 0x5870, 0x6858, 0xac02,
+	0x00c8, 0x5870, 0x7124, 0x610a, 0x2009, 0x0045, 0x1078, 0x775c,
+	0x007c, 0x007e, 0x1078, 0x29bb, 0x007f, 0x00c0, 0x5887, 0x7110,
+	0xa18c, 0xff00, 0x810f, 0xa18e, 0x0000, 0x00c0, 0x5887, 0xa084,
+	0x000f, 0xa08a, 0x0006, 0x00c8, 0x5887, 0x1079, 0x5888, 0x007c,
+	0x588e, 0x588f, 0x588e, 0x588e, 0x58ff, 0x590e, 0x007c, 0x7110,
+	0xd1bc, 0x0040, 0x5897, 0x702c, 0xd084, 0x0040, 0x58fe, 0x700c,
+	0x7108, 0x1078, 0x254d, 0x00c0, 0x58fe, 0x1078, 0x455c, 0x00c0,
+	0x58fe, 0x6612, 0x6516, 0x6204, 0x7110, 0xd1bc, 0x0040, 0x58c9,
+	0xa28c, 0x00ff, 0xa186, 0x0004, 0x0040, 0x58b2, 0xa186, 0x0006,
+	0x00c0, 0x58ef, 0x0c7e, 0x1078, 0x591d, 0x0c7f, 0x0040, 0x58fe,
+	0x0c7e, 0x1078, 0x76c7, 0x017f, 0x0040, 0x58fe, 0x611a, 0x601f,
+	0x0002, 0x7120, 0x610a, 0x2009, 0x0088, 0x1078, 0x775c, 0x0078,
+	0x58fe, 0xa28c, 0x00ff, 0xa186, 0x0006, 0x0040, 0x58de, 0xa186,
+	0x0004, 0x0040, 0x58de, 0xa294, 0xff00, 0x8217, 0xa286, 0x0004,
+	0x0040, 0x58de, 0xa286, 0x0006, 0x00c0, 0x58ef, 0x0c7e, 0x1078,
+	0x76c7, 0x017f, 0x0040, 0x58fe, 0x611a, 0x601f, 0x0005, 0x7120,
+	0x610a, 0x2009, 0x0088, 0x1078, 0x775c, 0x0078, 0x58fe, 0x0c7e,
+	0x1078, 0x76c7, 0x017f, 0x0040, 0x58fe, 0x611a, 0x601f, 0x0004,
+	0x7120, 0x610a, 0x2009, 0x0001, 0x1078, 0x775c, 0x007c, 0x7110,
+	0xd1bc, 0x0040, 0x590d, 0x1078, 0x591d, 0x0040, 0x590d, 0x7124,
+	0x610a, 0x2009, 0x0089, 0x1078, 0x775c, 0x007c, 0x7110, 0xd1bc,
+	0x0040, 0x591c, 0x1078, 0x591d, 0x0040, 0x591c, 0x7124, 0x610a,
+	0x2009, 0x008a, 0x1078, 0x775c, 0x007c, 0x7020, 0x2060, 0xac84,
+	0x000f, 0x00c0, 0x5930, 0xac82, 0xad00, 0x0048, 0x5930, 0x2001,
+	0xa616, 0x2004, 0xac02, 0x00c8, 0x5930, 0xa085, 0x0001, 0x007c,
+	0xa006, 0x0078, 0x592f, 0x7110, 0xd1bc, 0x00c0, 0x5949, 0x7024,
+	0x2060, 0xac84, 0x000f, 0x00c0, 0x5949, 0xac82, 0xad00, 0x0048,
+	0x5949, 0x6858, 0xac02, 0x00c8, 0x5949, 0x2009, 0x0051, 0x1078,
+	0x775c, 0x007c, 0x2071, 0xa8c4, 0x7003, 0x0003, 0x700f, 0x0361,
+	0xa006, 0x701a, 0x7012, 0x7017, 0xad00, 0x7007, 0x0000, 0x7026,
+	0x702b, 0x6e1c, 0x7032, 0x7037, 0x6e70, 0x703b, 0x0002, 0x703f,
+	0x0000, 0x7043, 0xffff, 0x7047, 0xffff, 0x007c, 0x2071, 0xa8c4,
+	0x00e0, 0x5a32, 0x2091, 0x6000, 0x700c, 0x8001, 0x700e, 0x00c0,
+	0x59de, 0x700f, 0x0361, 0x7007, 0x0001, 0x127e, 0x2091, 0x8000,
+	0x7138, 0x8109, 0x713a, 0x00c0, 0x59dc, 0x703b, 0x0002, 0x2009,
+	0x0100, 0x2104, 0xa082, 0x0003, 0x00c8, 0x59dc, 0x703c, 0xa086,
+	0x0001, 0x00c0, 0x59b9, 0x0d7e, 0x2069, 0x0140, 0x6804, 0xa084,
+	0x4000, 0x0040, 0x5997, 0x6803, 0x1000, 0x0078, 0x599e, 0x6804,
+	0xa084, 0x1000, 0x0040, 0x599e, 0x6803, 0x0100, 0x6803, 0x0000,
+	0x703f, 0x0000, 0x2069, 0xa8b1, 0x6804, 0xa082, 0x0006, 0x00c0,
+	0x59ab, 0x6807, 0x0000, 0x6830, 0xa082, 0x0003, 0x00c0, 0x59b2,
+	0x6833, 0x0000, 0x1078, 0x62d1, 0x1078, 0x639b, 0x0d7f, 0x0078,
+	0x59dc, 0x0d7e, 0x2069, 0xa600, 0x6948, 0x6864, 0xa102, 0x00c8,
+	0x59db, 0x2069, 0xa8b1, 0x6804, 0xa086, 0x0000, 0x00c0, 0x59db,
+	0x6830, 0xa086, 0x0000, 0x00c0, 0x59db, 0x703f, 0x0001, 0x6807,
+	0x0006, 0x6833, 0x0003, 0x2069, 0x0100, 0x6830, 0x689e, 0x2069,
+	0x0140, 0x6803, 0x0600, 0x0d7f, 0x0078, 0x59e1, 0x127e, 0x2091,
+	0x8000, 0x7024, 0xa00d, 0x0040, 0x59f9, 0x7020, 0x8001, 0x7022,
+	0x00c0, 0x59f9, 0x7023, 0x0009, 0x8109, 0x7126, 0xa186, 0x03e8,
+	0x00c0, 0x59f4, 0x7028, 0x107a, 0x81ff, 0x00c0, 0x59f9, 0x7028,
+	0x107a, 0x7030, 0xa00d, 0x0040, 0x5a10, 0x702c, 0x8001, 0x702e,
+	0x00c0, 0x5a10, 0x702f, 0x0009, 0x8109, 0x7132, 0x0040, 0x5a0e,
+	0xa184, 0x007f, 0x1040, 0x6ea2, 0x0078, 0x5a10, 0x7034, 0x107a,
+	0x7040, 0xa005, 0x0040, 0x5a18, 0x0050, 0x5a18, 0x8001, 0x7042,
+	0x7044, 0xa005, 0x0040, 0x5a20, 0x0050, 0x5a20, 0x8001, 0x7046,
+	0x7018, 0xa00d, 0x0040, 0x5a31, 0x7008, 0x8001, 0x700a, 0x00c0,
+	0x5a31, 0x700b, 0x0009, 0x8109, 0x711a, 0x00c0, 0x5a31, 0x701c,
+	0x107a, 0x127f, 0x7004, 0x0079, 0x5a35, 0x5a5c, 0x5a5d, 0x5a79,
+	0x0e7e, 0x2071, 0xa8c4, 0x7018, 0xa005, 0x00c0, 0x5a43, 0x711a,
+	0x721e, 0x700b, 0x0009, 0x0e7f, 0x007c, 0x0e7e, 0x007e, 0x2071,
+	0xa8c4, 0x701c, 0xa206, 0x00c0, 0x5a4f, 0x701a, 0x701e, 0x007f,
+	0x0e7f, 0x007c, 0x0e7e, 0x2071, 0xa8c4, 0x6088, 0xa102, 0x0048,
+	0x5a5a, 0x618a, 0x0e7f, 0x007c, 0x007c, 0x7110, 0x1078, 0x45c4,
+	0x00c0, 0x5a6f, 0x6088, 0x8001, 0x0048, 0x5a6f, 0x608a, 0x00c0,
+	0x5a6f, 0x127e, 0x2091, 0x8000, 0x1078, 0x62d1, 0x127f, 0x8108,
+	0xa182, 0x00ff, 0x0048, 0x5a77, 0xa00e, 0x7007, 0x0002, 0x7112,
+	0x007c, 0x7014, 0x2060, 0x127e, 0x2091, 0x8000, 0x603c, 0xa005,
+	0x0040, 0x5a88, 0x8001, 0x603e, 0x00c0, 0x5a88, 0x1078, 0x8f9c,
+	0x6014, 0xa005, 0x0040, 0x5ab2, 0x8001, 0x6016, 0x00c0, 0x5ab2,
+	0x611c, 0xa186, 0x0003, 0x0040, 0x5a99, 0xa186, 0x0006, 0x00c0,
+	0x5ab0, 0x6010, 0x2068, 0x6854, 0xa08a, 0x199a, 0x0048, 0x5ab0,
+	0xa082, 0x1999, 0x6856, 0xa08a, 0x199a, 0x0048, 0x5aa9, 0x2001,
+	0x1999, 0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x0078, 0x5ab2,
+	0x1078, 0x8abe, 0x127f, 0xac88, 0x0010, 0x7116, 0x2001, 0xcd00,
+	0xa102, 0x0048, 0x5abf, 0x7017, 0xad00, 0x7007, 0x0000, 0x007c,
+	0x0e7e, 0x2071, 0xa8c4, 0x7027, 0x07d0, 0x7023, 0x0009, 0x703b,
+	0x0002, 0x0e7f, 0x007c, 0x2001, 0xa8cd, 0x2003, 0x0000, 0x007c,
+	0x0e7e, 0x2071, 0xa8c4, 0x7132, 0x702f, 0x0009, 0x0e7f, 0x007c,
+	0x2011, 0xa8d0, 0x2013, 0x0000, 0x007c, 0x0e7e, 0x2071, 0xa8c4,
+	0x711a, 0x721e, 0x700b, 0x0009, 0x0e7f, 0x007c, 0x027e, 0x0e7e,
+	0x0f7e, 0x2079, 0xa600, 0x7a34, 0xd294, 0x0040, 0x5b15, 0x2071,
+	0xa8ac, 0x2e14, 0xa0fe, 0x0000, 0x0040, 0x5b02, 0xa0fe, 0x0001,
+	0x0040, 0x5b06, 0xa0fe, 0x0002, 0x00c0, 0x5b11, 0xa292, 0x0085,
+	0x0078, 0x5b08, 0xa292, 0x0005, 0x0078, 0x5b08, 0xa292, 0x0002,
+	0x2272, 0x0040, 0x5b0d, 0x00c8, 0x5b15, 0x2011, 0x8037, 0x1078,
+	0x361b, 0x2011, 0xa8ab, 0x2204, 0x2072, 0x0f7f, 0x0e7f, 0x027f,
+	0x007c, 0x0c7e, 0x2061, 0xa933, 0x0c7f, 0x007c, 0xa184, 0x000f,
+	0x8003, 0x8003, 0x8003, 0xa080, 0xa933, 0x2060, 0x007c, 0x6854,
+	0xa08a, 0x199a, 0x0048, 0x5b2e, 0x2001, 0x1999, 0xa005, 0x00c0,
+	0x5b3d, 0x0c7e, 0x2061, 0xa933, 0x6014, 0x0c7f, 0xa005, 0x00c0,
+	0x5b42, 0x2001, 0x001e, 0x0078, 0x5b42, 0xa08e, 0xffff, 0x00c0,
+	0x5b42, 0xa006, 0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x684c,
+	0xa08c, 0x00c0, 0xa18e, 0x00c0, 0x0040, 0x5b9e, 0xd0b4, 0x00c0,
+	0x5b59, 0xd0bc, 0x00c0, 0x5b8b, 0x2009, 0x0006, 0x1078, 0x5bc3,
+	0x007c, 0xd0fc, 0x0040, 0x5b64, 0xa084, 0x0003, 0x0040, 0x5b64,
+	0xa086, 0x0003, 0x00c0, 0x5bbc, 0x6024, 0xd0d4, 0x0040, 0x5b6e,
+	0xc0d4, 0x6026, 0x6860, 0x602a, 0x685c, 0x602e, 0x2009, 0xa674,
+	0x2104, 0xd084, 0x0040, 0x5b83, 0x6118, 0xa188, 0x0027, 0x2104,
+	0xd08c, 0x00c0, 0x5b83, 0x87ff, 0x00c0, 0x5b82, 0x2009, 0x0042,
+	0x1078, 0x775c, 0x007c, 0x87ff, 0x00c0, 0x5b8a, 0x2009, 0x0043,
+	0x1078, 0x775c, 0x007c, 0xd0fc, 0x0040, 0x5b96, 0xa084, 0x0003,
+	0x0040, 0x5b96, 0xa086, 0x0003, 0x00c0, 0x5bbc, 0x87ff, 0x00c0,
+	0x5b9d, 0x2009, 0x0042, 0x1078, 0x775c, 0x007c, 0xd0fc, 0x0040,
+	0x5baf, 0xa084, 0x0003, 0xa08e, 0x0002, 0x0040, 0x5bb3, 0x87ff,
+	0x00c0, 0x5bae, 0x2009, 0x0041, 0x1078, 0x775c, 0x007c, 0x1078,
+	0x5bc1, 0x0078, 0x5bae, 0x87ff, 0x00c0, 0x5bae, 0x2009, 0x0043,
+	0x1078, 0x775c, 0x0078, 0x5bae, 0x2009, 0x0004, 0x1078, 0x5bc3,
+	0x007c, 0x2009, 0x0001, 0x0d7e, 0x6010, 0xa0ec, 0xf000, 0x0040,
+	0x5bef, 0x2068, 0x6952, 0x6800, 0x6012, 0xa186, 0x0001, 0x00c0,
+	0x5be5, 0x694c, 0xa18c, 0x8100, 0xa18e, 0x8100, 0x00c0, 0x5be5,
+	0x0c7e, 0x2061, 0xa933, 0x6200, 0xd28c, 0x00c0, 0x5be4, 0x6204,
+	0x8210, 0x0048, 0x5be4, 0x6206, 0x0c7f, 0x1078, 0x4a73, 0x6010,
+	0xa06d, 0x077e, 0x2039, 0x0000, 0x10c0, 0x5b27, 0x077f, 0x0d7f,
+	0x007c, 0x157e, 0x0c7e, 0x2061, 0xa933, 0x6000, 0x81ff, 0x0040,
+	0x5bfc, 0xa205, 0x0078, 0x5bfd, 0xa204, 0x6002, 0x0c7f, 0x157f,
+	0x007c, 0x6800, 0xd08c, 0x00c0, 0x5c0d, 0x6808, 0xa005, 0x0040,
+	0x5c0d, 0x8001, 0x680a, 0xa085, 0x0001, 0x007c, 0x20a9, 0x0010,
+	0xa006, 0x8004, 0x8086, 0x818e, 0x00c8, 0x5c17, 0xa200, 0x00f0,
+	0x5c12, 0x8086, 0x818e, 0x007c, 0x157e, 0x20a9, 0x0010, 0xa005,
+	0x0040, 0x5c3d, 0xa11a, 0x00c8, 0x5c3d, 0x8213, 0x818d, 0x0048,
+	0x5c30, 0xa11a, 0x00c8, 0x5c31, 0x00f0, 0x5c25, 0x0078, 0x5c35,
+	0xa11a, 0x2308, 0x8210, 0x00f0, 0x5c25, 0x007e, 0x3200, 0xa084,
+	0xf7ff, 0x2080, 0x007f, 0x157f, 0x007c, 0x007e, 0x3200, 0xa085,
+	0x0800, 0x0078, 0x5c39, 0x127e, 0x2091, 0x2200, 0x2079, 0xa8b1,
+	0x127f, 0x0d7e, 0x2069, 0xa8b1, 0x6803, 0x0005, 0x2069, 0x0004,
+	0x2d04, 0xa085, 0x8001, 0x206a, 0x0d7f, 0x007c, 0x0c7e, 0x6027,
+	0x0001, 0x7804, 0xa084, 0x0007, 0x0079, 0x5c5e, 0x5c68, 0x5c8d,
+	0x5ce8, 0x5c6e, 0x5c8d, 0x5c68, 0x5c66, 0x5c66, 0x1078, 0x1332,
+	0x1078, 0x5acb, 0x1078, 0x62d1, 0x0c7f, 0x007c, 0x62c0, 0x82ff,
+	0x00c0, 0x5c74, 0x0c7f, 0x007c, 0x2011, 0x41dc, 0x1078, 0x5a45,
+	0x7828, 0xa092, 0x00c8, 0x00c8, 0x5c83, 0x8000, 0x782a, 0x1078,
+	0x421b, 0x0078, 0x5c72, 0x1078, 0x41dc, 0x7807, 0x0003, 0x7827,
+	0x0000, 0x782b, 0x0000, 0x0078, 0x5c72, 0x1078, 0x5acb, 0x3c00,
+	0x007e, 0x2011, 0x0209, 0x20e1, 0x4000, 0x2214, 0x007f, 0x20e0,
+	0x82ff, 0x0040, 0x5cab, 0x62c0, 0x82ff, 0x00c0, 0x5cab, 0x782b,
+	0x0000, 0x7824, 0xa065, 0x1040, 0x1332, 0x2009, 0x0013, 0x1078,
+	0x775c, 0x0c7f, 0x007c, 0x3900, 0xa082, 0xa9e3, 0x00c8, 0x5cb2,
+	0x1078, 0x747a, 0x0c7e, 0x7824, 0xa065, 0x1040, 0x1332, 0x7804,
+	0xa086, 0x0004, 0x0040, 0x5d2d, 0x7828, 0xa092, 0x2710, 0x00c8,
+	0x5cc8, 0x8000, 0x782a, 0x0c7f, 0x1078, 0x6e01, 0x0078, 0x5ca9,
+	0x6104, 0xa186, 0x0003, 0x00c0, 0x5cdf, 0x0e7e, 0x2071, 0xa600,
+	0x70d8, 0x0e7f, 0xd08c, 0x0040, 0x5cdf, 0x0c7e, 0x0e7e, 0x2061,
+	0x0100, 0x2071, 0xa600, 0x1078, 0x4224, 0x0e7f, 0x0c7f, 0x1078,
+	0xa5c4, 0x2009, 0x0014, 0x1078, 0x775c, 0x0c7f, 0x0078, 0x5ca9,
+	0x2001, 0xa8cd, 0x2003, 0x0000, 0x62c0, 0x82ff, 0x00c0, 0x5cfc,
+	0x782b, 0x0000, 0x7824, 0xa065, 0x1040, 0x1332, 0x2009, 0x0013,
+	0x1078, 0x77b3, 0x0c7f, 0x007c, 0x0c7e, 0x0d7e, 0x3900, 0xa082,
+	0xa9e3, 0x00c8, 0x5d05, 0x1078, 0x747a, 0x7824, 0xa005, 0x1040,
+	0x1332, 0x781c, 0xa06d, 0x1040, 0x1332, 0x6800, 0xc0dc, 0x6802,
+	0x7924, 0x2160, 0x1078, 0x772d, 0x693c, 0x81ff, 0x1040, 0x1332,
+	0x8109, 0x693e, 0x6854, 0xa015, 0x0040, 0x5d21, 0x7a1e, 0x0078,
+	0x5d23, 0x7918, 0x791e, 0x7807, 0x0000, 0x7827, 0x0000, 0x0d7f,
+	0x0c7f, 0x1078, 0x62d1, 0x0078, 0x5cfa, 0x6104, 0xa186, 0x0002,
+	0x0040, 0x5d38, 0xa186, 0x0004, 0x0040, 0x5d38, 0x0078, 0x5cbc,
+	0x7808, 0xac06, 0x0040, 0x5cbc, 0x1078, 0x61cd, 0x1078, 0x5dd7,
+	0x0c7f, 0x1078, 0x62d1, 0x0078, 0x5ca9, 0x0c7e, 0x6027, 0x0002,
+	0x62c8, 0x82ff, 0x00c0, 0x5d61, 0x62c4, 0x82ff, 0x00c0, 0x5d61,
+	0x793c, 0xa1e5, 0x0000, 0x0040, 0x5d5b, 0x2009, 0x0049, 0x1078,
+	0x775c, 0x0c7f, 0x007c, 0x2011, 0xa8d0, 0x2013, 0x0000, 0x0078,
+	0x5d59, 0x3908, 0xa192, 0xa9e3, 0x00c8, 0x5d68, 0x1078, 0x747a,
+	0x6017, 0x0010, 0x793c, 0x81ff, 0x0040, 0x5d5b, 0x7944, 0xa192,
+	0x7530, 0x00c8, 0x5d85, 0x8108, 0x7946, 0x793c, 0xa188, 0x0007,
+	0x210c, 0xa18e, 0x0006, 0x00c0, 0x5d81, 0x6017, 0x0012, 0x0078,
+	0x5d59, 0x6017, 0x0016, 0x0078, 0x5d59, 0x7848, 0xc085, 0x784a,
+	0x0078, 0x5d59, 0x007e, 0x017e, 0x0c7e, 0x127e, 0x2091, 0x8000,
+	0x600f, 0x0000, 0x2c08, 0x2061, 0xa8b1, 0x6020, 0x8000, 0x6022,
+	0x6010, 0xa005, 0x0040, 0x5da5, 0xa080, 0x0003, 0x2102, 0x6112,
+	0x127f, 0x0c7f, 0x017f, 0x007f, 0x007c, 0x6116, 0x6112, 0x0078,
+	0x5da0, 0x0d7e, 0x2069, 0xa8b1, 0x6000, 0xd0d4, 0x0040, 0x5dbe,
+	0x6820, 0x8000, 0x6822, 0xa086, 0x0001, 0x00c0, 0x5db9, 0x2c00,
+	0x681e, 0x6804, 0xa084, 0x0007, 0x0079, 0x62d9, 0xc0d5, 0x6002,
+	0x6818, 0xa005, 0x0040, 0x5dd0, 0x6056, 0x605b, 0x0000, 0x007e,
+	0x2c00, 0x681a, 0x0d7f, 0x685a, 0x2069, 0xa8b1, 0x0078, 0x5db0,
+	0x6056, 0x605a, 0x2c00, 0x681a, 0x681e, 0x0078, 0x5db0, 0x007e,
+	0x017e, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08,
+	0x2061, 0xa8b1, 0x6020, 0x8000, 0x6022, 0x6008, 0xa005, 0x0040,
+	0x5df2, 0xa080, 0x0003, 0x2102, 0x610a, 0x127f, 0x0c7f, 0x017f,
+	0x007f, 0x007c, 0x610e, 0x610a, 0x0078, 0x5ded, 0x0c7e, 0x600f,
+	0x0000, 0x2c08, 0x2061, 0xa8b1, 0x6034, 0xa005, 0x0040, 0x5e06,
+	0xa080, 0x0003, 0x2102, 0x6136, 0x0c7f, 0x007c, 0x613a, 0x6136,
+	0x0078, 0x5e04, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e, 0x057e,
+	0x037e, 0x027e, 0x017e, 0x007e, 0x127e, 0xa02e, 0x2071, 0xa8b1,
+	0x7638, 0x2660, 0x2678, 0x2091, 0x8000, 0x8cff, 0x0040, 0x5e8c,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x00c0, 0x5e87, 0x87ff,
+	0x0040, 0x5e2e, 0x6020, 0xa106, 0x00c0, 0x5e87, 0x703c, 0xac06,
+	0x00c0, 0x5e44, 0x037e, 0x2019, 0x0001, 0x1078, 0x7058, 0x7033,
+	0x0000, 0x703f, 0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x704b,
+	0x0000, 0x037f, 0x2029, 0x0001, 0x7038, 0xac36, 0x00c0, 0x5e4a,
+	0x660c, 0x763a, 0x7034, 0xac36, 0x00c0, 0x5e58, 0x2c00, 0xaf36,
+	0x0040, 0x5e56, 0x2f00, 0x7036, 0x0078, 0x5e58, 0x7037, 0x0000,
+	0x660c, 0x067e, 0x2c00, 0xaf06, 0x0040, 0x5e61, 0x7e0e, 0x0078,
+	0x5e62, 0x2678, 0x600f, 0x0000, 0x1078, 0x8d06, 0x0040, 0x5e82,
+	0x6010, 0x2068, 0x601c, 0xa086, 0x0003, 0x00c0, 0x5e9d, 0x6837,
+	0x0103, 0x6b4a, 0x6847, 0x0000, 0x017e, 0x037e, 0x077e, 0x1078,
+	0x8f7d, 0x1078, 0xa4e2, 0x1078, 0x4a73, 0x077f, 0x037f, 0x017f,
+	0x1078, 0x8eb9, 0x1078, 0x8ec6, 0x0c7f, 0x0078, 0x5e1d, 0x2c78,
+	0x600c, 0x2060, 0x0078, 0x5e1d, 0x85ff, 0x0040, 0x5e91, 0x1078,
+	0x639b, 0x127f, 0x007f, 0x017f, 0x027f, 0x037f, 0x057f, 0x067f,
+	0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x601c, 0xa086, 0x0006,
+	0x00c0, 0x5e6f, 0x017e, 0x037e, 0x077e, 0x1078, 0xa4e2, 0x1078,
+	0xa1ca, 0x077f, 0x037f, 0x017f, 0x0078, 0x5e82, 0x007e, 0x067e,
+	0x0c7e, 0x0d7e, 0x0f7e, 0x2031, 0x0000, 0x127e, 0x2091, 0x8000,
+	0x2079, 0xa8b1, 0x7838, 0xa065, 0x0040, 0x5eef, 0x600c, 0x007e,
+	0x600f, 0x0000, 0x783c, 0xac06, 0x00c0, 0x5ed6, 0x037e, 0x2019,
+	0x0001, 0x1078, 0x7058, 0x7833, 0x0000, 0x783f, 0x0000, 0x7843,
+	0x0000, 0x7847, 0x0000, 0x784b, 0x0000, 0x037f, 0x1078, 0x8d06,
+	0x0040, 0x5eea, 0x6010, 0x2068, 0x601c, 0xa086, 0x0003, 0x00c0,
+	0x5ef8, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x4a73,
+	0x1078, 0x8eb9, 0x1078, 0x8ec6, 0x007f, 0x0078, 0x5ebb, 0x7e3a,
+	0x7e36, 0x127f, 0x0f7f, 0x0d7f, 0x0c7f, 0x067f, 0x007f, 0x007c,
+	0x601c, 0xa086, 0x0006, 0x00c0, 0x5ee1, 0x1078, 0xa1ca, 0x0078,
+	0x5eea, 0x017e, 0x027e, 0x087e, 0x2041, 0x0000, 0x1078, 0x5f1b,
+	0x1078, 0x5fdb, 0x087f, 0x027f, 0x017f, 0x007c, 0x0f7e, 0x127e,
+	0x2079, 0xa8b1, 0x2091, 0x8000, 0x1078, 0x6076, 0x1078, 0x60ec,
+	0x127f, 0x0f7f, 0x007c, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e,
+	0x017e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2071, 0xa8b1, 0x7614,
+	0x2660, 0x2678, 0x8cff, 0x0040, 0x5fb5, 0x6018, 0xa080, 0x0028,
+	0x2004, 0xa206, 0x00c0, 0x5fb0, 0x88ff, 0x0040, 0x5f3b, 0x6020,
+	0xa106, 0x00c0, 0x5fb0, 0x7024, 0xac06, 0x00c0, 0x5f6b, 0x2069,
+	0x0100, 0x68c0, 0xa005, 0x0040, 0x5f66, 0x1078, 0x5acb, 0x1078,
+	0x6e0f, 0x68c3, 0x0000, 0x1078, 0x7378, 0x7027, 0x0000, 0x037e,
+	0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x5f5b, 0x6803,
+	0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0040,
+	0x5f63, 0x6827, 0x0001, 0x037f, 0x0078, 0x5f6b, 0x6003, 0x0009,
+	0x630a, 0x0078, 0x5fb0, 0x7014, 0xac36, 0x00c0, 0x5f71, 0x660c,
+	0x7616, 0x7010, 0xac36, 0x00c0, 0x5f7f, 0x2c00, 0xaf36, 0x0040,
+	0x5f7d, 0x2f00, 0x7012, 0x0078, 0x5f7f, 0x7013, 0x0000, 0x660c,
+	0x067e, 0x2c00, 0xaf06, 0x0040, 0x5f88, 0x7e0e, 0x0078, 0x5f89,
+	0x2678, 0x600f, 0x0000, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040,
+	0x5fa9, 0x601c, 0xa086, 0x0003, 0x00c0, 0x5fbe, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x017e, 0x037e, 0x087e, 0x1078, 0x8f7d,
+	0x1078, 0xa4e2, 0x1078, 0x4a73, 0x087f, 0x037f, 0x017f, 0x1078,
+	0x8eb9, 0x1078, 0x8ec6, 0x1078, 0x7233, 0x0c7f, 0x0078, 0x5f2a,
+	0x2c78, 0x600c, 0x2060, 0x0078, 0x5f2a, 0x127f, 0x007f, 0x017f,
+	0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x601c, 0xa086,
+	0x0006, 0x00c0, 0x5fcf, 0x017e, 0x037e, 0x087e, 0x1078, 0xa4e2,
+	0x1078, 0xa1ca, 0x087f, 0x037f, 0x017f, 0x0078, 0x5fa9, 0x601c,
+	0xa086, 0x0002, 0x00c0, 0x5fa9, 0x6004, 0xa086, 0x0085, 0x0040,
+	0x5f96, 0x0078, 0x5fa9, 0x0c7e, 0x007e, 0x127e, 0x2091, 0x8000,
+	0xa280, 0xa735, 0x2004, 0xa065, 0x0040, 0x6072, 0x0f7e, 0x0e7e,
+	0x0d7e, 0x067e, 0x2071, 0xa8b1, 0x6654, 0x7018, 0xac06, 0x00c0,
+	0x5ff2, 0x761a, 0x701c, 0xac06, 0x00c0, 0x5ffe, 0x86ff, 0x00c0,
+	0x5ffd, 0x7018, 0x701e, 0x0078, 0x5ffe, 0x761e, 0x6058, 0xa07d,
+	0x0040, 0x6003, 0x7e56, 0xa6ed, 0x0000, 0x0040, 0x6009, 0x2f00,
+	0x685a, 0x6057, 0x0000, 0x605b, 0x0000, 0x6000, 0xc0d4, 0xc0dc,
+	0x6002, 0x1078, 0x44d3, 0x0040, 0x606e, 0x7624, 0x86ff, 0x0040,
+	0x605c, 0xa680, 0x0004, 0x2004, 0xad06, 0x00c0, 0x605c, 0x0d7e,
+	0x2069, 0x0100, 0x68c0, 0xa005, 0x0040, 0x6053, 0x1078, 0x5acb,
+	0x1078, 0x6e0f, 0x68c3, 0x0000, 0x1078, 0x7378, 0x7027, 0x0000,
+	0x037e, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x603c,
+	0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084,
+	0x0040, 0x6044, 0x6827, 0x0001, 0x037f, 0x0d7f, 0x0c7e, 0x603c,
+	0xa005, 0x0040, 0x604d, 0x8001, 0x603e, 0x2660, 0x1078, 0x8ec6,
+	0x0c7f, 0x0078, 0x605c, 0x0d7f, 0x0c7e, 0x2660, 0x6003, 0x0009,
+	0x630a, 0x0c7f, 0x0078, 0x6011, 0x8dff, 0x0040, 0x606a, 0x6837,
+	0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x8f7d, 0x1078, 0xa4e2,
+	0x1078, 0x4a73, 0x1078, 0x7233, 0x0078, 0x6011, 0x067f, 0x0d7f,
+	0x0e7f, 0x0f7f, 0x127f, 0x007f, 0x0c7f, 0x007c, 0x007e, 0x067e,
+	0x0c7e, 0x0d7e, 0x2031, 0x0000, 0x7814, 0xa065, 0x0040, 0x60d0,
+	0x600c, 0x007e, 0x600f, 0x0000, 0x7824, 0xac06, 0x00c0, 0x60b5,
+	0x2069, 0x0100, 0x68c0, 0xa005, 0x0040, 0x60af, 0x1078, 0x5acb,
+	0x1078, 0x6e0f, 0x68c3, 0x0000, 0x1078, 0x7378, 0x7827, 0x0000,
+	0x037e, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0040, 0x60a4,
+	0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084,
+	0x0040, 0x60ac, 0x6827, 0x0001, 0x037f, 0x0078, 0x60b5, 0x6003,
+	0x0009, 0x630a, 0x2c30, 0x0078, 0x60cd, 0x6010, 0x2068, 0x1078,
+	0x8d06, 0x0040, 0x60c9, 0x601c, 0xa086, 0x0003, 0x00c0, 0x60d7,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x4a73, 0x1078,
+	0x8eb9, 0x1078, 0x8ec6, 0x1078, 0x7233, 0x007f, 0x0078, 0x607d,
+	0x7e16, 0x7e12, 0x0d7f, 0x0c7f, 0x067f, 0x007f, 0x007c, 0x601c,
+	0xa086, 0x0006, 0x00c0, 0x60e0, 0x1078, 0xa1ca, 0x0078, 0x60c9,
+	0x601c, 0xa086, 0x0002, 0x00c0, 0x60c9, 0x6004, 0xa086, 0x0085,
+	0x0040, 0x60c0, 0x0078, 0x60c9, 0x007e, 0x067e, 0x0c7e, 0x0d7e,
+	0x7818, 0xa065, 0x0040, 0x615a, 0x6054, 0x007e, 0x6057, 0x0000,
+	0x605b, 0x0000, 0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x1078, 0x44d3,
+	0x0040, 0x6157, 0x7e24, 0x86ff, 0x0040, 0x6149, 0xa680, 0x0004,
+	0x2004, 0xad06, 0x00c0, 0x6149, 0x0d7e, 0x2069, 0x0100, 0x68c0,
+	0xa005, 0x0040, 0x6140, 0x1078, 0x5acb, 0x1078, 0x6e0f, 0x68c3,
+	0x0000, 0x1078, 0x7378, 0x7827, 0x0000, 0x037e, 0x2069, 0x0140,
+	0x6b04, 0xa384, 0x1000, 0x0040, 0x6129, 0x6803, 0x0100, 0x6803,
+	0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0040, 0x6131, 0x6827,
+	0x0001, 0x037f, 0x0d7f, 0x0c7e, 0x603c, 0xa005, 0x0040, 0x613a,
+	0x8001, 0x603e, 0x2660, 0x1078, 0x8ec6, 0x0c7f, 0x0078, 0x6149,
+	0x0d7f, 0x0c7e, 0x2660, 0x6003, 0x0009, 0x630a, 0x0c7f, 0x0078,
+	0x60fe, 0x8dff, 0x0040, 0x6153, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x1078, 0x4a73, 0x1078, 0x7233, 0x0078, 0x60fe, 0x007f,
+	0x0078, 0x60f1, 0x781e, 0x781a, 0x0d7f, 0x0c7f, 0x067f, 0x007f,
+	0x007c, 0x0e7e, 0x0d7e, 0x067e, 0x6000, 0xd0dc, 0x0040, 0x6181,
+	0x604c, 0xa06d, 0x0040, 0x6181, 0x6848, 0xa606, 0x00c0, 0x6181,
+	0x2071, 0xa8b1, 0x7024, 0xa035, 0x0040, 0x6181, 0xa080, 0x0004,
+	0x2004, 0xad06, 0x00c0, 0x6181, 0x6000, 0xc0dc, 0x6002, 0x1078,
+	0x6185, 0x067f, 0x0d7f, 0x0e7f, 0x007c, 0x0f7e, 0x2079, 0x0100,
+	0x78c0, 0xa005, 0x00c0, 0x6194, 0x0c7e, 0x2660, 0x6003, 0x0009,
+	0x630a, 0x0c7f, 0x0078, 0x61cb, 0x1078, 0x6e0f, 0x78c3, 0x0000,
+	0x1078, 0x7378, 0x7027, 0x0000, 0x037e, 0x2079, 0x0140, 0x7b04,
+	0xa384, 0x1000, 0x0040, 0x61a8, 0x7803, 0x0100, 0x7803, 0x0000,
+	0x2079, 0x0100, 0x7824, 0xd084, 0x0040, 0x61b0, 0x7827, 0x0001,
+	0x1078, 0x7378, 0x037f, 0x1078, 0x44d3, 0x0c7e, 0x603c, 0xa005,
+	0x0040, 0x61bc, 0x8001, 0x603e, 0x2660, 0x1078, 0x772d, 0x0c7f,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x8f7d, 0x1078,
+	0x4a73, 0x1078, 0x7233, 0x0f7f, 0x007c, 0x0e7e, 0x0c7e, 0x2071,
+	0xa8b1, 0x7004, 0xa084, 0x0007, 0x0079, 0x61d6, 0x61e0, 0x61e3,
+	0x61fc, 0x6218, 0x6262, 0x61e0, 0x61e0, 0x61de, 0x1078, 0x1332,
+	0x0c7f, 0x0e7f, 0x007c, 0x7024, 0xa065, 0x0040, 0x61f1, 0x7020,
+	0x8001, 0x7022, 0x600c, 0xa015, 0x0040, 0x61f8, 0x7216, 0x600f,
+	0x0000, 0x7007, 0x0000, 0x7027, 0x0000, 0x0c7f, 0x0e7f, 0x007c,
+	0x7216, 0x7212, 0x0078, 0x61f1, 0x6018, 0x2060, 0x1078, 0x44d3,
+	0x6000, 0xc0dc, 0x6002, 0x7020, 0x8001, 0x7022, 0x0040, 0x620d,
+	0x6054, 0xa015, 0x0040, 0x6214, 0x721e, 0x7007, 0x0000, 0x7027,
+	0x0000, 0x0c7f, 0x0e7f, 0x007c, 0x7218, 0x721e, 0x0078, 0x620d,
+	0x7024, 0xa065, 0x0040, 0x625f, 0x700c, 0xac06, 0x00c0, 0x622f,
+	0x1078, 0x7233, 0x600c, 0xa015, 0x0040, 0x622b, 0x720e, 0x600f,
+	0x0000, 0x0078, 0x625d, 0x720e, 0x720a, 0x0078, 0x625d, 0x7014,
+	0xac06, 0x00c0, 0x6242, 0x1078, 0x7233, 0x600c, 0xa015, 0x0040,
+	0x623e, 0x7216, 0x600f, 0x0000, 0x0078, 0x625d, 0x7216, 0x7212,
+	0x0078, 0x625d, 0x601c, 0xa086, 0x0003, 0x00c0, 0x625d, 0x6018,
+	0x2060, 0x1078, 0x44d3, 0x6000, 0xc0dc, 0x6002, 0x1078, 0x7233,
+	0x701c, 0xa065, 0x0040, 0x625d, 0x6054, 0xa015, 0x0040, 0x625b,
+	0x721e, 0x0078, 0x625d, 0x7218, 0x721e, 0x7027, 0x0000, 0x0c7f,
+	0x0e7f, 0x007c, 0x7024, 0xa065, 0x0040, 0x626f, 0x1078, 0x7233,
+	0x600c, 0xa015, 0x0040, 0x6276, 0x720e, 0x600f, 0x0000, 0x1078,
+	0x7378, 0x7027, 0x0000, 0x0c7f, 0x0e7f, 0x007c, 0x720e, 0x720a,
+	0x0078, 0x626f, 0x0d7e, 0x2069, 0xa8b1, 0x6830, 0xa084, 0x0003,
+	0x0079, 0x6282, 0x6288, 0x628a, 0x62b4, 0x6288, 0x1078, 0x1332,
+	0x0d7f, 0x007c, 0x0c7e, 0x6840, 0xa086, 0x0001, 0x0040, 0x62aa,
+	0x683c, 0xa065, 0x0040, 0x629b, 0x600c, 0xa015, 0x0040, 0x62a6,
+	0x6a3a, 0x600f, 0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x2011,
+	0xa8d0, 0x2013, 0x0000, 0x0c7f, 0x0d7f, 0x007c, 0x683a, 0x6836,
+	0x0078, 0x629b, 0x6843, 0x0000, 0x6838, 0xa065, 0x0040, 0x629b,
+	0x6003, 0x0003, 0x0078, 0x629b, 0x0c7e, 0x6843, 0x0000, 0x6847,
+	0x0000, 0x684b, 0x0000, 0x683c, 0xa065, 0x0040, 0x62ce, 0x600c,
+	0xa015, 0x0040, 0x62ca, 0x6a3a, 0x600f, 0x0000, 0x683f, 0x0000,
+	0x0078, 0x62ce, 0x683f, 0x0000, 0x683a, 0x6836, 0x0c7f, 0x0d7f,
+	0x007c, 0x0d7e, 0x2069, 0xa8b1, 0x6804, 0xa084, 0x0007, 0x0079,
+	0x62d9, 0x62e3, 0x638a, 0x638a, 0x638a, 0x638a, 0x638c, 0x638a,
+	0x62e1, 0x1078, 0x1332, 0x6820, 0xa005, 0x00c0, 0x62e9, 0x0d7f,
+	0x007c, 0x0c7e, 0x680c, 0xa065, 0x0040, 0x62f8, 0x6807, 0x0004,
+	0x6826, 0x682b, 0x0000, 0x1078, 0x63d4, 0x0c7f, 0x0d7f, 0x007c,
+	0x6814, 0xa065, 0x0040, 0x6306, 0x6807, 0x0001, 0x6826, 0x682b,
+	0x0000, 0x1078, 0x63d4, 0x0c7f, 0x0d7f, 0x007c, 0x0e7e, 0x037e,
+	0x6a1c, 0xa2f5, 0x0000, 0x0040, 0x6385, 0x704c, 0xa00d, 0x0040,
+	0x6315, 0x7088, 0xa005, 0x0040, 0x632d, 0x7054, 0xa075, 0x0040,
+	0x631e, 0xa20e, 0x0040, 0x6385, 0x0078, 0x6323, 0x6818, 0xa20e,
+	0x0040, 0x6385, 0x2070, 0x704c, 0xa00d, 0x0040, 0x6315, 0x7088,
+	0xa005, 0x00c0, 0x6315, 0x2e00, 0x681e, 0x733c, 0x7038, 0xa302,
+	0x00c8, 0x6315, 0x1078, 0x76fc, 0x0040, 0x6385, 0x8318, 0x733e,
+	0x6112, 0x2e10, 0x621a, 0xa180, 0x0014, 0x2004, 0xa084, 0x00ff,
+	0x6032, 0xa180, 0x0014, 0x2003, 0x0000, 0xa180, 0x0015, 0x2004,
+	0xa08a, 0x199a, 0x0048, 0x634e, 0x2001, 0x1999, 0x8003, 0x801b,
+	0x831b, 0xa318, 0x6316, 0x037f, 0x0f7e, 0x2c78, 0x71a0, 0xd1bc,
+	0x0040, 0x6367, 0x7100, 0xd1f4, 0x0040, 0x6363, 0x7114, 0xa18c,
+	0x00ff, 0x0078, 0x636c, 0x2009, 0x0000, 0x0078, 0x636c, 0xa1e0,
+	0x29c0, 0x2c0c, 0xa18c, 0x00ff, 0x2061, 0x0100, 0x619a, 0x1078,
+	0x6965, 0x7300, 0xc3dd, 0x7302, 0x6807, 0x0002, 0x2f18, 0x6b26,
+	0x682b, 0x0000, 0x781f, 0x0003, 0x7803, 0x0001, 0x7807, 0x0040,
+	0x0f7f, 0x0e7f, 0x0c7f, 0x0d7f, 0x007c, 0x037f, 0x0e7f, 0x0c7f,
+	0x0078, 0x6383, 0x0d7f, 0x007c, 0x0c7e, 0x680c, 0xa065, 0x0040,
+	0x6398, 0x6807, 0x0004, 0x6826, 0x682b, 0x0000, 0x1078, 0x63d4,
+	0x0c7f, 0x0d7f, 0x007c, 0x0f7e, 0x0d7e, 0x2069, 0xa8b1, 0x6830,
+	0xa086, 0x0000, 0x00c0, 0x63bb, 0x6838, 0xa07d, 0x0040, 0x63bb,
+	0x6833, 0x0001, 0x683e, 0x6847, 0x0000, 0x684b, 0x0000, 0x127e,
+	0x0f7e, 0x2091, 0x2200, 0x027f, 0x1078, 0x1d6d, 0x00c0, 0x63be,
+	0x127f, 0x1078, 0x6cb3, 0x0d7f, 0x0f7f, 0x007c, 0x127f, 0x6843,
+	0x0000, 0x7803, 0x0002, 0x780c, 0xa015, 0x0040, 0x63d0, 0x6a3a,
+	0x780f, 0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x0078, 0x63bb,
+	0x683a, 0x6836, 0x0078, 0x63ca, 0x601c, 0xa084, 0x000f, 0x1079,
+	0x63da, 0x007c, 0x63e3, 0x63e8, 0x6809, 0x6922, 0x63e8, 0x6809,
+	0x6922, 0x63e3, 0x63e8, 0x1078, 0x61cd, 0x1078, 0x62d1, 0x007c,
+	0x157e, 0x137e, 0x147e, 0x0c7e, 0x0f7e, 0x6004, 0xa08a, 0x0044,
+	0x10c8, 0x1332, 0x6118, 0x2178, 0x79a0, 0xd1bc, 0x0040, 0x6405,
+	0x7900, 0xd1f4, 0x0040, 0x6401, 0x7914, 0xa18c, 0x00ff, 0x0078,
+	0x640a, 0x2009, 0x0000, 0x0078, 0x640a, 0xa1f8, 0x29c0, 0x2f0c,
+	0xa18c, 0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a, 0xa08a, 0x0040,
+	0x00c8, 0x645c, 0x1079, 0x641a, 0x0f7f, 0x0c7f, 0x147f, 0x137f,
+	0x157f, 0x007c, 0x64c2, 0x650a, 0x6532, 0x65cd, 0x65fd, 0x6605,
+	0x662c, 0x663d, 0x664e, 0x6656, 0x666e, 0x6656, 0x66d9, 0x663d,
+	0x66fa, 0x6702, 0x664e, 0x6702, 0x6713, 0x645a, 0x645a, 0x645a,
+	0x645a, 0x645a, 0x645a, 0x645a, 0x645a, 0x645a, 0x645a, 0x645a,
+	0x6eef, 0x6f14, 0x6f29, 0x6f4c, 0x6f6d, 0x662c, 0x645a, 0x662c,
+	0x6656, 0x645a, 0x6532, 0x65cd, 0x645a, 0x749c, 0x6656, 0x645a,
+	0x74bc, 0x6656, 0x645a, 0x645a, 0x64bd, 0x646b, 0x645a, 0x74e1,
+	0x7558, 0x7640, 0x645a, 0x7651, 0x6626, 0x766d, 0x645a, 0x6f82,
+	0x645a, 0x645a, 0x1078, 0x1332, 0x2100, 0x1079, 0x6465, 0x0f7f,
+	0x0c7f, 0x147f, 0x137f, 0x157f, 0x007c, 0x6469, 0x6469, 0x6469,
+	0x649f, 0x1078, 0x1332, 0x0d7e, 0x20a1, 0x020b, 0x1078, 0x6731,
+	0x7810, 0x2068, 0x20a3, 0x2414, 0x20a3, 0x0018, 0x20a3, 0x0800,
+	0x683c, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x6850, 0x20a2, 0x6854, 0x20a2, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x0018, 0x1078, 0x6dfb, 0x0d7f, 0x007c,
+	0x0d7e, 0x7818, 0x2068, 0x68a0, 0xa082, 0x007e, 0x0048, 0x649c,
+	0xa085, 0x0001, 0x0d7f, 0x007c, 0xa006, 0x0078, 0x649a, 0x0d7e,
+	0x20a1, 0x020b, 0x1078, 0x6731, 0x20a3, 0x0500, 0x20a3, 0x0000,
+	0x7810, 0xa0e8, 0x000f, 0x6808, 0x20a2, 0x680c, 0x20a2, 0x6810,
+	0x20a2, 0x6814, 0x20a2, 0x6818, 0x20a2, 0x681c, 0x20a2, 0x60c3,
+	0x0010, 0x1078, 0x6dfb, 0x0d7f, 0x007c, 0x6030, 0x609a, 0x1078,
+	0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078, 0x6731, 0x20a3, 0x5200,
+	0x20a3, 0x0000, 0x0d7e, 0x2069, 0xa652, 0x6804, 0xd084, 0x0040,
+	0x64dc, 0x6828, 0x20a3, 0x0000, 0x017e, 0x1078, 0x2564, 0x21a2,
+	0x017f, 0x0d7f, 0x0078, 0x64e1, 0x0d7f, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a9, 0x0004, 0x2099, 0xa605, 0x53a6, 0x20a9, 0x0004,
+	0x2099, 0xa601, 0x53a6, 0x7818, 0xa080, 0x0028, 0x2004, 0xa082,
+	0x007f, 0x0048, 0x64fb, 0x2001, 0xa61b, 0x20a6, 0x2001, 0xa61c,
+	0x20a6, 0x0078, 0x6501, 0x20a3, 0x0000, 0x6030, 0xa084, 0x00ff,
+	0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x1078,
+	0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078, 0x6731, 0x20a3, 0x0500,
+	0x20a3, 0x0000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007f,
+	0x0048, 0x6522, 0x2001, 0xa61b, 0x20a6, 0x2001, 0xa61c, 0x20a6,
+	0x0078, 0x6528, 0x20a3, 0x0000, 0x6030, 0xa084, 0x00ff, 0x20a2,
+	0x20a9, 0x0004, 0x2099, 0xa605, 0x53a6, 0x60c3, 0x0010, 0x1078,
+	0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078, 0x6731, 0x0c7e, 0x7818,
+	0x2060, 0x2001, 0x0000, 0x1078, 0x4972, 0x0c7f, 0x7818, 0xa080,
+	0x0028, 0x2004, 0xa086, 0x007e, 0x00c0, 0x654d, 0x20a3, 0x0400,
+	0x620c, 0xc2b4, 0x620e, 0x0078, 0x654f, 0x20a3, 0x0300, 0x20a3,
+	0x0000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa086, 0x007e, 0x00c0,
+	0x659c, 0x2099, 0xa88d, 0x33a6, 0x9398, 0x33a6, 0x9398, 0x3304,
+	0xa084, 0x3fff, 0x20a2, 0x9398, 0x33a6, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004, 0x2099,
+	0xa605, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xa601, 0x53a6, 0x20a9,
+	0x0010, 0x20a3, 0x0000, 0x00f0, 0x6579, 0x2099, 0xa895, 0x3304,
+	0xc0dd, 0x20a2, 0x2001, 0xa672, 0x2004, 0xd0e4, 0x0040, 0x6594,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x9398, 0x9398, 0x9398, 0x33a6,
+	0x20a9, 0x0004, 0x0078, 0x6596, 0x20a9, 0x0007, 0x20a3, 0x0000,
+	0x00f0, 0x6596, 0x0078, 0x65bc, 0x2099, 0xa88d, 0x20a9, 0x0008,
+	0x53a6, 0x20a9, 0x0004, 0x2099, 0xa605, 0x53a6, 0x20a9, 0x0004,
+	0x2099, 0xa601, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x00f0,
+	0x65ad, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x00f0, 0x65b3, 0x2099,
+	0xa895, 0x20a9, 0x0008, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000,
+	0x00f0, 0x65be, 0x20a9, 0x000a, 0x20a3, 0x0000, 0x00f0, 0x65c4,
+	0x60c3, 0x0074, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x6731, 0x20a3, 0x2010, 0x20a3, 0x0014, 0x20a3, 0x0800, 0x20a3,
+	0x2000, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x0f7e,
+	0x2079, 0xa652, 0x7904, 0x0f7f, 0xd1ac, 0x00c0, 0x65e9, 0xa085,
+	0x0020, 0xd1a4, 0x0040, 0x65ee, 0xa085, 0x0010, 0xa085, 0x0002,
+	0x0d7e, 0x0078, 0x66b7, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0014, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x6731, 0x20a3, 0x5000, 0x0078, 0x654f, 0x20a1, 0x020b, 0x1078,
+	0x6731, 0x20a3, 0x2110, 0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x0014, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b,
+	0x1078, 0x67b9, 0x0078, 0x6630, 0x20a1, 0x020b, 0x1078, 0x67c2,
+	0x20a3, 0x0200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0004, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x67c2, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3,
+	0x2a00, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b,
+	0x1078, 0x67c2, 0x20a3, 0x0200, 0x0078, 0x654f, 0x20a1, 0x020b,
+	0x1078, 0x67c2, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0xa005,
+	0x0040, 0x6665, 0x20a2, 0x0078, 0x6667, 0x20a3, 0x0003, 0x7810,
+	0x20a2, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x007c, 0x0d7e, 0x20a1,
+	0x020b, 0x1078, 0x67c2, 0x20a3, 0x0210, 0x20a3, 0x0014, 0x20a3,
+	0x0800, 0x7818, 0x2068, 0x6894, 0xa086, 0x0014, 0x00c0, 0x6694,
+	0x6998, 0xa184, 0xc000, 0x00c0, 0x6690, 0xd1ec, 0x0040, 0x668c,
+	0x20a3, 0x2100, 0x0078, 0x6696, 0x20a3, 0x0100, 0x0078, 0x6696,
+	0x20a3, 0x0400, 0x0078, 0x6696, 0x20a3, 0x0700, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x0f7e, 0x2079, 0xa652, 0x7904,
+	0x0f7f, 0xd1ac, 0x00c0, 0x66a6, 0xa085, 0x0020, 0xd1a4, 0x0040,
+	0x66ab, 0xa085, 0x0010, 0x2009, 0xa674, 0x210c, 0xd184, 0x0040,
+	0x66b5, 0x699c, 0xd18c, 0x0040, 0x66b7, 0xa085, 0x0002, 0x027e,
+	0x2009, 0xa672, 0x210c, 0xd1e4, 0x0040, 0x66c5, 0xc0c5, 0xa094,
+	0x0030, 0xa296, 0x0010, 0x0040, 0x66cf, 0xd1ec, 0x0040, 0x66cf,
+	0xa094, 0x0030, 0xa296, 0x0010, 0x0040, 0x66cf, 0xc0bd, 0x027f,
+	0x20a2, 0x20a2, 0x20a2, 0x60c3, 0x0014, 0x1078, 0x6dfb, 0x0d7f,
+	0x007c, 0x20a1, 0x020b, 0x1078, 0x67c2, 0x20a3, 0x0210, 0x20a3,
+	0x0014, 0x20a3, 0x0000, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x1078,
+	0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078, 0x67c2, 0x20a3, 0x0200,
+	0x0078, 0x64c8, 0x20a1, 0x020b, 0x1078, 0x67c2, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3, 0x0008,
+	0x1078, 0x6dfb, 0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a1,
+	0x020b, 0x1078, 0x67c2, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3,
+	0x000b, 0x20a3, 0x0000, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x007c,
+	0x027e, 0x037e, 0x047e, 0x2019, 0x3200, 0x2021, 0x0800, 0x0078,
+	0x6738, 0x027e, 0x037e, 0x047e, 0x2019, 0x2200, 0x2021, 0x0100,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2014,
+	0xa286, 0x007e, 0x00c0, 0x674b, 0xa385, 0x00ff, 0x20a2, 0x20a3,
+	0xfffe, 0x0078, 0x6780, 0xa286, 0x007f, 0x00c0, 0x6757, 0x0d7e,
+	0xa385, 0x00ff, 0x20a2, 0x20a3, 0xfffd, 0x0078, 0x676e, 0xd2bc,
+	0x0040, 0x6776, 0xa286, 0x0080, 0x0d7e, 0x00c0, 0x6766, 0xa385,
+	0x00ff, 0x20a2, 0x20a3, 0xfffc, 0x0078, 0x676e, 0xa2e8, 0xa735,
+	0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6784, 0x0d7e, 0xa2e8,
+	0xa735, 0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x0d7f,
+	0x20a3, 0x0000, 0x6230, 0x22a2, 0xa485, 0x0029, 0x20a2, 0x047f,
+	0x037f, 0x20a3, 0x0000, 0x1078, 0x6dea, 0x22a2, 0x20a3, 0x0000,
+	0x2fa2, 0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f,
+	0x007c, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a3, 0x02ff,
+	0x2011, 0xfffc, 0x22a2, 0x0d7e, 0x2069, 0xa61b, 0x2da6, 0x8d68,
+	0x2da6, 0x0d7f, 0x20a3, 0x2029, 0x20a3, 0x0000, 0x0078, 0x678b,
+	0x20a3, 0x0100, 0x20a3, 0x0000, 0x20a3, 0xfc02, 0x20a3, 0x0000,
+	0x007c, 0x027e, 0x037e, 0x047e, 0x2019, 0x3300, 0x2021, 0x0800,
+	0x0078, 0x67c9, 0x027e, 0x037e, 0x047e, 0x2019, 0x2300, 0x2021,
+	0x0100, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa092, 0x007e, 0x0048, 0x67e6, 0x0d7e, 0xa0e8, 0xa735,
+	0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x67f4, 0x0d7e, 0xa0e8,
+	0xa735, 0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x0d7f,
+	0x20a3, 0x0000, 0x6230, 0x22a2, 0xa485, 0x0098, 0x20a2, 0x20a3,
+	0x0000, 0x047f, 0x037f, 0x1078, 0x6dea, 0x22a2, 0x20a3, 0x0000,
+	0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f,
+	0x007c, 0x0c7e, 0x0f7e, 0x6004, 0xa08a, 0x0085, 0x1048, 0x1332,
+	0xa08a, 0x008c, 0x10c8, 0x1332, 0x6118, 0x2178, 0x79a0, 0xd1bc,
+	0x0040, 0x6827, 0x7900, 0xd1f4, 0x0040, 0x6823, 0x7914, 0xa18c,
+	0x00ff, 0x0078, 0x682c, 0x2009, 0x0000, 0x0078, 0x682c, 0xa1f8,
+	0x29c0, 0x2f0c, 0xa18c, 0x00ff, 0x2c78, 0x2061, 0x0100, 0x619a,
+	0xa082, 0x0085, 0x1079, 0x6837, 0x0f7f, 0x0c7f, 0x007c, 0x6840,
+	0x684b, 0x6866, 0x683e, 0x683e, 0x683e, 0x6840, 0x1078, 0x1332,
+	0x147e, 0x20a1, 0x020b, 0x1078, 0x6879, 0x60c3, 0x0000, 0x1078,
+	0x6dfb, 0x147f, 0x007c, 0x147e, 0x20a1, 0x020b, 0x1078, 0x68ad,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808, 0x20a2, 0x7810, 0x20a2,
+	0x20a3, 0x0000, 0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x000c, 0x1078, 0x6dfb, 0x147f, 0x007c, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x68ee, 0x20a3, 0x0003, 0x20a3, 0x0300, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004, 0x1078, 0x6dfb, 0x147f,
+	0x007c, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080,
+	0x0028, 0x2004, 0xa092, 0x007e, 0x0048, 0x6898, 0x0d7e, 0xa0e8,
+	0xa735, 0x2d6c, 0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xa61b, 0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x68a7,
+	0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085, 0x8100, 0x20a2,
+	0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3,
+	0x0009, 0x20a3, 0x0000, 0x0078, 0x678b, 0x027e, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa092, 0x007e,
+	0x0048, 0x68cc, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085,
+	0x8400, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b, 0x2da6, 0x8d68,
+	0x2da6, 0x0d7f, 0x0078, 0x68db, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c,
+	0x6810, 0xa085, 0x8400, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3,
+	0x0000, 0x6230, 0x22a2, 0x20a3, 0x0099, 0x20a3, 0x0000, 0x1078,
+	0x6dea, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x7a10, 0x22a2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f, 0x007c, 0x027e, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xa092,
+	0x007e, 0x0048, 0x690d, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810,
+	0xa085, 0x8500, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b, 0x2da6,
+	0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x691c, 0x0d7e, 0xa0e8, 0xa735,
+	0x2d6c, 0x6810, 0xa085, 0x8500, 0x20a2, 0x6814, 0x20a2, 0x0d7f,
+	0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3, 0x0099, 0x20a3, 0x0000,
+	0x0078, 0x68df, 0x0c7e, 0x0f7e, 0x2c78, 0x7804, 0xa08a, 0x0040,
+	0x1048, 0x1332, 0xa08a, 0x0053, 0x10c8, 0x1332, 0x7918, 0x2160,
+	0x61a0, 0xd1bc, 0x0040, 0x6941, 0x6100, 0xd1f4, 0x0040, 0x693d,
+	0x6114, 0xa18c, 0x00ff, 0x0078, 0x6946, 0x2009, 0x0000, 0x0078,
+	0x6946, 0xa1e0, 0x29c0, 0x2c0c, 0xa18c, 0x00ff, 0x2061, 0x0100,
+	0x619a, 0xa082, 0x0040, 0x1079, 0x6950, 0x0f7f, 0x0c7f, 0x007c,
+	0x6965, 0x6a73, 0x6a14, 0x6c27, 0x6963, 0x6963, 0x6963, 0x6963,
+	0x6963, 0x6963, 0x6963, 0x714c, 0x715d, 0x716e, 0x717f, 0x6963,
+	0x767e, 0x6963, 0x713b, 0x1078, 0x1332, 0x0d7e, 0x157e, 0x147e,
+	0x780b, 0xffff, 0x20a1, 0x020b, 0x1078, 0x69d0, 0x7910, 0x2168,
+	0x6948, 0x7922, 0x21a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x694c,
+	0xa184, 0x000f, 0x00c0, 0x6980, 0x2001, 0x0005, 0x0078, 0x698a,
+	0xd184, 0x0040, 0x6987, 0x2001, 0x0004, 0x0078, 0x698a, 0xa084,
+	0x0006, 0x8004, 0x017e, 0x2008, 0x7830, 0xa084, 0x00ff, 0x8007,
+	0xa105, 0x017f, 0x20a2, 0xd1ac, 0x0040, 0x699a, 0x20a3, 0x0002,
+	0x0078, 0x69a6, 0xd1b4, 0x0040, 0x69a1, 0x20a3, 0x0001, 0x0078,
+	0x69a6, 0x20a3, 0x0000, 0x2230, 0x0078, 0x69a8, 0x6a80, 0x6e7c,
+	0x20a9, 0x0008, 0xad80, 0x0017, 0x200c, 0x810f, 0x21a2, 0x8000,
+	0x00f0, 0x69ac, 0x22a2, 0x26a2, 0x60c3, 0x0020, 0x20e1, 0x9080,
+	0x6014, 0xa084, 0x0004, 0xa085, 0x0009, 0x6016, 0x2001, 0xa8cd,
+	0x2003, 0x07d0, 0x2001, 0xa8cc, 0x2003, 0x0009, 0x2001, 0xa8d2,
+	0x2003, 0x0002, 0x1078, 0x158c, 0x147f, 0x157f, 0x0d7f, 0x007c,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7a18, 0xa280, 0x0023, 0x2014,
+	0x8210, 0xa294, 0x00ff, 0x2202, 0x8217, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xd0bc, 0x0040, 0x69f6, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c,
+	0x6810, 0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6a05, 0x0d7e, 0xa0e8,
+	0xa735, 0x2d6c, 0x6810, 0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2,
+	0x0d7f, 0x20a3, 0x0000, 0x6130, 0x21a2, 0x20a3, 0x0829, 0x20a3,
+	0x0000, 0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x20a3, 0xffff, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e,
+	0x20a1, 0x020b, 0x1078, 0x6a34, 0x7810, 0x2068, 0x6860, 0x20a2,
+	0x685c, 0x20a2, 0x6880, 0x20a2, 0x687c, 0x20a2, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x60c3, 0x000c, 0x1078, 0x6dfb, 0x147f,
+	0x137f, 0x157f, 0x0d7f, 0x007c, 0x027e, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040, 0x6a52,
+	0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085, 0x0500, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xa61b, 0x2da6, 0x8d68, 0x2da6, 0x0d7f,
+	0x0078, 0x6a61, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085,
+	0x0500, 0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230,
+	0x22a2, 0x20a3, 0x0889, 0x20a3, 0x0000, 0x1078, 0x6dea, 0x22a2,
+	0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x027f, 0x007c, 0x0d7e, 0x157e, 0x137e, 0x147e, 0x7810,
+	0xa0ec, 0xf000, 0x0040, 0x6a8b, 0xa06d, 0x1078, 0x495f, 0x0040,
+	0x6a8b, 0x684c, 0xa084, 0x2020, 0xa086, 0x2020, 0x00c0, 0x6a8b,
+	0x7824, 0xc0cd, 0x7826, 0x20a1, 0x020b, 0x1078, 0x6be0, 0xa016,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x7810, 0xa084, 0xf000,
+	0x00c0, 0x6aa2, 0x7810, 0xa084, 0x0700, 0x8007, 0x1079, 0x6aaa,
+	0x0078, 0x6aa5, 0xa006, 0x1079, 0x6aaa, 0x147f, 0x137f, 0x157f,
+	0x0d7f, 0x007c, 0x6ab4, 0x6b4c, 0x6b57, 0x6b81, 0x6b95, 0x6bb1,
+	0x6bbc, 0x6ab2, 0x1078, 0x1332, 0x017e, 0x037e, 0x694c, 0xa18c,
+	0x0003, 0x0040, 0x6abf, 0xa186, 0x0003, 0x00c0, 0x6ace, 0x6b78,
+	0x7824, 0xd0cc, 0x0040, 0x6ac5, 0xc3e5, 0x23a2, 0x6868, 0x20a2,
+	0x6864, 0x20a2, 0x037f, 0x017f, 0x0078, 0x6b8c, 0xa186, 0x0001,
+	0x10c0, 0x1332, 0x6b78, 0x7824, 0xd0cc, 0x0040, 0x6ad8, 0xc3e5,
+	0x23a2, 0x6868, 0x20a2, 0x6864, 0x20a2, 0x22a2, 0x6874, 0x20a2,
+	0x22a2, 0x687c, 0x20a2, 0x2009, 0x0018, 0xa384, 0x0300, 0x0040,
+	0x6b46, 0xd3c4, 0x0040, 0x6aee, 0x687c, 0xa108, 0xd3cc, 0x0040,
+	0x6af3, 0x6874, 0xa108, 0x157e, 0x20a9, 0x000d, 0xad80, 0x0020,
+	0x201c, 0x831f, 0x23a2, 0x8000, 0x00f0, 0x6af8, 0x157f, 0x22a2,
+	0x22a2, 0x22a2, 0xa184, 0x0003, 0x0040, 0x6b46, 0x20a1, 0x020b,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x007e, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xd0bc, 0x0040, 0x6b26, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c,
+	0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6b35, 0x0d7e, 0xa0e8,
+	0xa735, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x007f, 0x7b24, 0xd3cc,
+	0x0040, 0x6b3e, 0x20a3, 0x0889, 0x0078, 0x6b40, 0x20a3, 0x0898,
+	0x20a2, 0x1078, 0x6dea, 0x22a2, 0x20a3, 0x0000, 0x61c2, 0x037f,
+	0x017f, 0x1078, 0x6dfb, 0x007c, 0x2011, 0x0008, 0x7824, 0xd0cc,
+	0x0040, 0x6b53, 0xc2e5, 0x22a2, 0xa016, 0x0078, 0x6b8a, 0x2011,
+	0x0302, 0x7824, 0xd0cc, 0x0040, 0x6b5e, 0xc2e5, 0x22a2, 0xa016,
+	0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x0012, 0x22a2, 0x20a3, 0x0008,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x7000, 0x20a3, 0x0500,
+	0x22a2, 0x20a3, 0x000a, 0x22a2, 0x22a2, 0x20a3, 0x2500, 0x22a2,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0032, 0x1078, 0x6dfb,
+	0x007c, 0x2011, 0x0028, 0x7824, 0xd0cc, 0x0040, 0x6b88, 0xc2e5,
+	0x22a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2,
+	0x60c3, 0x0018, 0x1078, 0x6dfb, 0x007c, 0x2011, 0x0100, 0x7824,
+	0xd0cc, 0x0040, 0x6b9c, 0xc2e5, 0x22a2, 0xa016, 0x22a2, 0x22a2,
+	0x22a2, 0x22a2, 0x22a2, 0x20a3, 0x0008, 0x22a2, 0x7834, 0xa084,
+	0x00ff, 0x20a2, 0x22a2, 0x22a2, 0x60c3, 0x0020, 0x1078, 0x6dfb,
+	0x007c, 0x2011, 0x0008, 0x7824, 0xd0cc, 0x0040, 0x6bb8, 0xc2e5,
+	0x22a2, 0xa016, 0x0078, 0x6b8a, 0x037e, 0x7b10, 0xa384, 0xff00,
+	0x7812, 0xa384, 0x00ff, 0x8001, 0x00c0, 0x6bcf, 0x7824, 0xd0cc,
+	0x0040, 0x6bcb, 0xc2e5, 0x22a2, 0x037f, 0x0078, 0x6b8a, 0x047e,
+	0x2021, 0x0800, 0x007e, 0x7824, 0xd0cc, 0x007f, 0x0040, 0x6bd9,
+	0xc4e5, 0x24a2, 0x047f, 0x22a2, 0x20a2, 0x037f, 0x0078, 0x6b8c,
+	0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xd0bc, 0x0040, 0x6bfe, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c,
+	0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x6c0d, 0x0d7e, 0xa0e8,
+	0xa735, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x7824, 0xd0cc, 0x0040,
+	0x6c15, 0x20a3, 0x0889, 0x0078, 0x6c17, 0x20a3, 0x0898, 0x20a3,
+	0x0000, 0x1078, 0x6dea, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2,
+	0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x027f, 0x007c, 0x0d7e,
+	0x157e, 0x137e, 0x147e, 0x017e, 0x037e, 0x7810, 0xa084, 0x0700,
+	0x8007, 0x1079, 0x6c3a, 0x037f, 0x017f, 0x147f, 0x137f, 0x157f,
+	0x0d7f, 0x007c, 0x6c42, 0x6c42, 0x6c44, 0x6c42, 0x6c42, 0x6c42,
+	0x6c69, 0x6c42, 0x1078, 0x1332, 0x7910, 0xa18c, 0xf8ff, 0xa18d,
+	0x0600, 0x7912, 0x20a1, 0x020b, 0x2009, 0x0003, 0x1078, 0x6c73,
+	0x0d7e, 0x2069, 0xa652, 0x6804, 0xd0bc, 0x0040, 0x6c5e, 0x682c,
+	0xa084, 0x00ff, 0x8007, 0x20a2, 0x0078, 0x6c60, 0x20a3, 0x3f00,
+	0x0d7f, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0001, 0x1078, 0x6dfb,
+	0x007c, 0x20a1, 0x020b, 0x2009, 0x0003, 0x1078, 0x6c73, 0x20a3,
+	0x7f00, 0x0078, 0x6c61, 0x027e, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x7818, 0xa080, 0x0028, 0x2004, 0xd0bc, 0x0040, 0x6c91, 0x0d7e,
+	0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085, 0x0100, 0x20a2, 0x6814,
+	0x20a2, 0x2069, 0xa61b, 0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078,
+	0x6ca0, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c, 0x6810, 0xa085, 0x0100,
+	0x20a2, 0x6814, 0x20a2, 0x0d7f, 0x20a3, 0x0000, 0x6230, 0x22a2,
+	0x20a3, 0x0888, 0xa18d, 0x0008, 0x21a2, 0x1078, 0x6dea, 0x22a2,
+	0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x027f, 0x007c, 0x0e7e, 0x0d7e, 0x0c7e, 0x057e, 0x047e,
+	0x037e, 0x2061, 0x0100, 0x2071, 0xa600, 0x6130, 0x7818, 0x2068,
+	0x68a0, 0x2028, 0xd0bc, 0x00c0, 0x6cca, 0x6910, 0x6a14, 0x6430,
+	0x0078, 0x6cce, 0x6910, 0x6a14, 0x736c, 0x7470, 0x781c, 0xa086,
+	0x0006, 0x0040, 0x6d2d, 0xd5bc, 0x0040, 0x6cde, 0xa185, 0x0100,
+	0x6062, 0x6266, 0x636a, 0x646e, 0x0078, 0x6ce5, 0xa185, 0x0100,
+	0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x6073, 0x0809, 0x6077,
+	0x0008, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e, 0x8007, 0x607a,
+	0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086, 0x7810, 0x2070,
+	0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6, 0x7008, 0x60ca,
+	0x686c, 0x60ce, 0x60ab, 0x0036, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xa582, 0x0080, 0x0048, 0x6d17, 0x6a00, 0xd2f4, 0x0040, 0x6d15,
+	0x6a14, 0xa294, 0x00ff, 0x0078, 0x6d17, 0x2011, 0x0000, 0x629e,
+	0x6017, 0x0016, 0x2009, 0x07d0, 0x60c4, 0xa084, 0xfff0, 0xa005,
+	0x0040, 0x6d24, 0x2009, 0x1b58, 0x1078, 0x5ad0, 0x037f, 0x047f,
+	0x057f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x7810, 0x2070, 0x704c,
+	0xa084, 0x0003, 0xa086, 0x0002, 0x0040, 0x6d85, 0xd5bc, 0x0040,
+	0x6d41, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e, 0x0078,
+	0x6d48, 0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e,
+	0x6073, 0x0880, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084, 0x00ff,
+	0x688e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6086, 0x7808,
+	0x6082, 0x7060, 0x608a, 0x705c, 0x608e, 0x7080, 0x60c6, 0x707c,
+	0x60ca, 0x707c, 0x792c, 0xa108, 0x792e, 0x7080, 0x7928, 0xa109,
+	0x792a, 0x686c, 0x60ce, 0x60ab, 0x0036, 0x60af, 0x95d5, 0x60d7,
+	0x0000, 0xa582, 0x0080, 0x0048, 0x6d80, 0x6a00, 0xd2f4, 0x0040,
+	0x6d7e, 0x6a14, 0xa294, 0x00ff, 0x0078, 0x6d80, 0x2011, 0x0000,
+	0x629e, 0x6017, 0x0012, 0x0078, 0x6d1a, 0xd5bc, 0x0040, 0x6d90,
+	0xa185, 0x0700, 0x6062, 0x6266, 0x636a, 0x646e, 0x0078, 0x6d97,
+	0xa185, 0x0700, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x1078,
+	0x495f, 0x0040, 0x6dad, 0x0d7e, 0x7810, 0xa06d, 0x684c, 0x0d7f,
+	0xa084, 0x2020, 0xa086, 0x2020, 0x00c0, 0x6dad, 0x7824, 0xc0cd,
+	0x7826, 0x6073, 0x0889, 0x0078, 0x6daf, 0x6073, 0x0898, 0x6077,
+	0x0000, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e, 0x8007, 0x607a,
+	0x607f, 0x0000, 0x2f00, 0x6086, 0x7808, 0x6082, 0x7014, 0x608a,
+	0x7010, 0x608e, 0x700c, 0x60c6, 0x7008, 0x60ca, 0x686c, 0x60ce,
+	0x60ab, 0x0036, 0x60af, 0x95d5, 0x60d7, 0x0000, 0xa582, 0x0080,
+	0x0048, 0x6ddd, 0x6a00, 0xd2f4, 0x0040, 0x6ddb, 0x6a14, 0xa294,
+	0x00ff, 0x0078, 0x6ddd, 0x2011, 0x0000, 0x629e, 0x7824, 0xd0cc,
+	0x0040, 0x6de6, 0x6017, 0x0016, 0x0078, 0x6d1a, 0x6017, 0x0012,
+	0x0078, 0x6d1a, 0x7a18, 0xa280, 0x0023, 0x2014, 0x8210, 0xa294,
+	0x00ff, 0x2202, 0x8217, 0x007c, 0x0d7e, 0x2069, 0xa8b1, 0x6843,
+	0x0001, 0x0d7f, 0x007c, 0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7,
+	0x9575, 0x1078, 0x6e06, 0x1078, 0x5ac0, 0x007c, 0x007e, 0x6014,
+	0xa084, 0x0004, 0xa085, 0x0009, 0x6016, 0x007f, 0x007c, 0x007e,
+	0x0c7e, 0x2061, 0x0100, 0x6014, 0xa084, 0x0004, 0xa085, 0x0008,
+	0x6016, 0x0c7f, 0x007f, 0x007c, 0x0c7e, 0x0d7e, 0x017e, 0x027e,
+	0x2061, 0x0100, 0x2069, 0x0140, 0x6904, 0xa194, 0x4000, 0x0040,
+	0x6e59, 0x1078, 0x6e0f, 0x6803, 0x1000, 0x6803, 0x0000, 0x0c7e,
+	0x2061, 0xa8b1, 0x6128, 0xa192, 0x00c8, 0x00c8, 0x6e44, 0x8108,
+	0x612a, 0x6124, 0x0c7f, 0x81ff, 0x0040, 0x6e54, 0x1078, 0x5ac0,
+	0x1078, 0x6e06, 0x0078, 0x6e54, 0x6124, 0xa1e5, 0x0000, 0x0040,
+	0x6e51, 0x1078, 0xa5c4, 0x1078, 0x5acb, 0x2009, 0x0014, 0x1078,
+	0x775c, 0x0c7f, 0x0078, 0x6e54, 0x027f, 0x017f, 0x0d7f, 0x0c7f,
+	0x007c, 0x2001, 0xa8cd, 0x2004, 0xa005, 0x00c0, 0x6e54, 0x0c7e,
+	0x2061, 0xa8b1, 0x6128, 0xa192, 0x0003, 0x00c8, 0x6e44, 0x8108,
+	0x612a, 0x0c7f, 0x1078, 0x5ac0, 0x1078, 0x4224, 0x0078, 0x6e54,
+	0x0c7e, 0x0d7e, 0x0e7e, 0x017e, 0x027e, 0x1078, 0x5ad8, 0x2071,
+	0xa8b1, 0x713c, 0x81ff, 0x0040, 0x6e9a, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x6904, 0xa194, 0x4000, 0x0040, 0x6ea0, 0x6803, 0x1000,
+	0x6803, 0x0000, 0x037e, 0x2019, 0x0001, 0x1078, 0x7058, 0x037f,
+	0x713c, 0x2160, 0x1078, 0xa5c4, 0x2009, 0x004a, 0x1078, 0x775c,
+	0x0078, 0x6e9a, 0x027f, 0x017f, 0x0e7f, 0x0d7f, 0x0c7f, 0x007c,
+	0x0078, 0x6e8a, 0x0e7e, 0x2071, 0xa8b1, 0x7048, 0xd084, 0x0040,
+	0x6ebc, 0x713c, 0x81ff, 0x0040, 0x6ebc, 0x2071, 0x0100, 0xa188,
+	0x0007, 0x210c, 0xa18e, 0x0006, 0x00c0, 0x6eba, 0x7017, 0x0012,
+	0x0078, 0x6ebc, 0x7017, 0x0016, 0x0e7f, 0x007c, 0x0e7e, 0x0d7e,
+	0x0c7e, 0x067e, 0x057e, 0x047e, 0x007e, 0x127e, 0x2091, 0x8000,
+	0x6018, 0x2068, 0x6ca0, 0x2071, 0xa8b1, 0x7018, 0x2068, 0x8dff,
+	0x0040, 0x6ee6, 0x68a0, 0xa406, 0x0040, 0x6eda, 0x6854, 0x2068,
+	0x0078, 0x6ecf, 0x6010, 0x2060, 0x643c, 0x6540, 0x6648, 0x2d60,
+	0x1078, 0x4736, 0x0040, 0x6ee6, 0xa085, 0x0001, 0x127f, 0x007f,
+	0x047f, 0x057f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0x20a1,
+	0x020b, 0x1078, 0x6731, 0x20a3, 0x1200, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x781c, 0xa086, 0x0004, 0x00c0, 0x6f01, 0x6098, 0x0078,
+	0x6f02, 0x6030, 0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a9,
+	0x0010, 0xa006, 0x20a2, 0x00f0, 0x6f0a, 0x20a2, 0x20a2, 0x60c3,
+	0x002c, 0x1078, 0x6dfb, 0x007c, 0x157e, 0x147e, 0x20a1, 0x020b,
+	0x1078, 0x6731, 0x20a3, 0x0f00, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x7808, 0x20a2, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x147f, 0x157f,
+	0x007c, 0x157e, 0x147e, 0x20a1, 0x020b, 0x1078, 0x67c2, 0x20a3,
+	0x0200, 0x20a3, 0x0000, 0x20a9, 0x0006, 0x2011, 0xa640, 0x2019,
+	0xa641, 0x23a6, 0x22a6, 0xa398, 0x0002, 0xa290, 0x0002, 0x00f0,
+	0x6f39, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x1078,
+	0x6dfb, 0x147f, 0x157f, 0x007c, 0x157e, 0x147e, 0x017e, 0x027e,
+	0x20a1, 0x020b, 0x1078, 0x6799, 0x1078, 0x67b0, 0x7810, 0xa080,
+	0x0000, 0x2004, 0xa080, 0x0015, 0x2098, 0x7808, 0xa088, 0x0002,
+	0x21a8, 0x53a6, 0xa080, 0x0004, 0x8003, 0x60c2, 0x1078, 0x6dfb,
+	0x027f, 0x017f, 0x147f, 0x157f, 0x007c, 0x157e, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x6731, 0x20a3, 0x6200, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x7808, 0x20a2, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x147f,
+	0x157f, 0x007c, 0x157e, 0x147e, 0x017e, 0x027e, 0x20a1, 0x020b,
+	0x1078, 0x6731, 0x7810, 0xa080, 0x0000, 0x2004, 0xa080, 0x0017,
+	0x2098, 0x7808, 0xa088, 0x0002, 0x21a8, 0x53a6, 0x8003, 0x60c2,
+	0x1078, 0x6dfb, 0x027f, 0x017f, 0x147f, 0x157f, 0x007c, 0x0e7e,
+	0x0c7e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2071, 0xa8b1, 0x700c,
+	0x2060, 0x8cff, 0x0040, 0x6fbb, 0x1078, 0x8f00, 0x00c0, 0x6fb2,
+	0x1078, 0x7c83, 0x600c, 0x007e, 0x1078, 0x772d, 0x1078, 0x7233,
+	0x0c7f, 0x0078, 0x6fa9, 0x700f, 0x0000, 0x700b, 0x0000, 0x127f,
+	0x007f, 0x0c7f, 0x0e7f, 0x007c, 0x127e, 0x157e, 0x0f7e, 0x0e7e,
+	0x0d7e, 0x0c7e, 0x027e, 0x017e, 0x007e, 0x2091, 0x8000, 0x2069,
+	0x0100, 0x2079, 0x0140, 0x2071, 0xa8b1, 0x7024, 0x2060, 0x8cff,
+	0x0040, 0x7014, 0x1078, 0x6e0f, 0x68c3, 0x0000, 0x1078, 0x5acb,
+	0x2009, 0x0013, 0x1078, 0x775c, 0x20a9, 0x01f4, 0x6824, 0xd094,
+	0x0040, 0x6ff7, 0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x0040,
+	0x7009, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078, 0x7009, 0xd084,
+	0x0040, 0x6ffe, 0x6827, 0x0001, 0x0078, 0x7000, 0x00f0, 0x6fe6,
+	0x7804, 0xa084, 0x1000, 0x0040, 0x7009, 0x7803, 0x0100, 0x7803,
+	0x0000, 0x6824, 0x007f, 0x017f, 0x027f, 0x0c7f, 0x0d7f, 0x0e7f,
+	0x0f7f, 0x157f, 0x127f, 0x007c, 0x2001, 0xa600, 0x2004, 0xa096,
+	0x0001, 0x0040, 0x704e, 0xa096, 0x0004, 0x0040, 0x704e, 0x1078,
+	0x5acb, 0x6817, 0x0008, 0x68c3, 0x0000, 0x2011, 0x41dc, 0x1078,
+	0x5a45, 0x20a9, 0x01f4, 0x6824, 0xd094, 0x0040, 0x703c, 0x6827,
+	0x0004, 0x7804, 0xa084, 0x4000, 0x0040, 0x704e, 0x7803, 0x1000,
+	0x7803, 0x0000, 0x0078, 0x704e, 0xd084, 0x0040, 0x7043, 0x6827,
+	0x0001, 0x0078, 0x7045, 0x00f0, 0x702b, 0x7804, 0xa084, 0x1000,
+	0x0040, 0x704e, 0x7803, 0x0100, 0x7803, 0x0000, 0x007f, 0x017f,
+	0x027f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x157f, 0x127f, 0x007c,
+	0x127e, 0x157e, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x027e, 0x017e,
+	0x007e, 0x2091, 0x8000, 0x2069, 0x0100, 0x2079, 0x0140, 0x2071,
+	0xa8b1, 0x703c, 0x2060, 0x8cff, 0x0040, 0x70d6, 0x68af, 0x95f5,
+	0x6817, 0x0010, 0x2009, 0x00fa, 0x8109, 0x00c0, 0x7074, 0x68c7,
+	0x0000, 0x68cb, 0x0008, 0x1078, 0x5ad8, 0x1078, 0x1f7e, 0x047e,
+	0x057e, 0x2009, 0x017f, 0x212c, 0x200b, 0x00a5, 0x2021, 0x0169,
+	0x2404, 0xa084, 0x000f, 0xa086, 0x0004, 0x00c0, 0x70a5, 0x68c7,
+	0x0000, 0x68cb, 0x0008, 0x0e7e, 0x0f7e, 0x2079, 0x0020, 0x2071,
+	0xa908, 0x6814, 0xa084, 0x0004, 0xa085, 0x0012, 0x6816, 0x7803,
+	0x0008, 0x7003, 0x0000, 0x0f7f, 0x0e7f, 0x250a, 0x057f, 0x047f,
+	0xa39d, 0x0000, 0x00c0, 0x70b0, 0x2009, 0x0049, 0x1078, 0x775c,
+	0x20a9, 0x03e8, 0x6824, 0xd094, 0x0040, 0x70c3, 0x6827, 0x0004,
+	0x7804, 0xa084, 0x4000, 0x0040, 0x70d5, 0x7803, 0x1000, 0x7803,
+	0x0000, 0x0078, 0x70d5, 0xd08c, 0x0040, 0x70ca, 0x6827, 0x0002,
+	0x0078, 0x70cc, 0x00f0, 0x70b2, 0x7804, 0xa084, 0x1000, 0x0040,
+	0x70d5, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824, 0x007f, 0x017f,
+	0x027f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f, 0x157f, 0x127f, 0x007c,
+	0x0d7e, 0x127e, 0x2091, 0x8000, 0x2069, 0xa8b1, 0x6a06, 0x127f,
+	0x0d7f, 0x007c, 0x0d7e, 0x127e, 0x2091, 0x8000, 0x2069, 0xa8b1,
+	0x6a32, 0x127f, 0x0d7f, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e, 0x067e,
+	0x007e, 0x127e, 0x2071, 0xa8b1, 0x7614, 0x2660, 0x2678, 0x2091,
+	0x8000, 0x8cff, 0x0040, 0x7134, 0x601c, 0xa206, 0x00c0, 0x712f,
+	0x7014, 0xac36, 0x00c0, 0x710e, 0x660c, 0x7616, 0x7010, 0xac36,
+	0x00c0, 0x711c, 0x2c00, 0xaf36, 0x0040, 0x711a, 0x2f00, 0x7012,
+	0x0078, 0x711c, 0x7013, 0x0000, 0x660c, 0x067e, 0x2c00, 0xaf06,
+	0x0040, 0x7125, 0x7e0e, 0x0078, 0x7126, 0x2678, 0x600f, 0x0000,
+	0x1078, 0x8ec6, 0x1078, 0x7233, 0x0c7f, 0x0078, 0x7101, 0x2c78,
+	0x600c, 0x2060, 0x0078, 0x7101, 0x127f, 0x007f, 0x067f, 0x0c7f,
+	0x0e7f, 0x0f7f, 0x007c, 0x157e, 0x147e, 0x20a1, 0x020b, 0x1078,
+	0x69d0, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2,
+	0x20a3, 0x1000, 0x0078, 0x718e, 0x157e, 0x147e, 0x20a1, 0x020b,
+	0x1078, 0x69d0, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x20a3, 0x4000, 0x0078, 0x718e, 0x157e, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x69d0, 0x7810, 0x20a2, 0xa006, 0x20a2, 0x20a2,
+	0x20a2, 0x20a2, 0x20a3, 0x2000, 0x0078, 0x718e, 0x157e, 0x147e,
+	0x20a1, 0x020b, 0x1078, 0x69d0, 0x7810, 0x20a2, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0400, 0x0078, 0x718e, 0x157e,
+	0x147e, 0x20a1, 0x020b, 0x1078, 0x69d0, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0200, 0x1078, 0x723e,
+	0x60c3, 0x0020, 0x1078, 0x6dfb, 0x147f, 0x157f, 0x007c, 0x127e,
+	0x0c7e, 0x2091, 0x8000, 0x2061, 0x0100, 0x6120, 0xd1b4, 0x00c0,
+	0x71a6, 0xd1bc, 0x00c0, 0x71f0, 0x0078, 0x7230, 0x2009, 0x017f,
+	0x200b, 0x00a1, 0x157e, 0x007e, 0x0d7e, 0x2069, 0x0140, 0x20a9,
+	0x001e, 0x2009, 0x0169, 0x6804, 0xa084, 0x4000, 0x0040, 0x71e7,
+	0x6020, 0xd0b4, 0x0040, 0x71e7, 0x6024, 0xd094, 0x00c0, 0x71e7,
+	0x2104, 0xa084, 0x000f, 0xa086, 0x0004, 0x00c0, 0x71e7, 0x00f0,
+	0x71b3, 0x027e, 0x6198, 0xa18c, 0x00ff, 0x8107, 0x6130, 0xa18c,
+	0x00ff, 0xa10d, 0x6088, 0x628c, 0x618e, 0x608b, 0xbc91, 0x6043,
+	0x0001, 0x6043, 0x0000, 0x608a, 0x628e, 0x6024, 0xd094, 0x00c0,
+	0x71e6, 0x6a04, 0xa294, 0x4000, 0x00c0, 0x71dd, 0x027f, 0x0d7f,
+	0x007f, 0x157f, 0x2009, 0x017f, 0x200b, 0x0000, 0x0078, 0x7230,
+	0x2009, 0x017f, 0x200b, 0x00a1, 0x157e, 0x007e, 0x0d7e, 0x2069,
+	0x0140, 0x20a9, 0x001e, 0x2009, 0x0169, 0x6804, 0xa084, 0x4000,
+	0x0040, 0x7229, 0x6020, 0xd0bc, 0x0040, 0x7229, 0x2104, 0xa084,
+	0x000f, 0xa086, 0x0004, 0x00c0, 0x7229, 0x00f0, 0x71fd, 0x027e,
+	0x6164, 0xa18c, 0x00ff, 0x8107, 0x6130, 0xa18c, 0x00ff, 0xa10d,
+	0x6088, 0x628c, 0x608b, 0xbc91, 0x618e, 0x6043, 0x0001, 0x6043,
+	0x0000, 0x608a, 0x628e, 0x6a04, 0xa294, 0x4000, 0x00c0, 0x7223,
+	0x027f, 0x0d7f, 0x007f, 0x157f, 0x2009, 0x017f, 0x200b, 0x0000,
+	0x0c7f, 0x127f, 0x007c, 0x0e7e, 0x2071, 0xa8b1, 0x7020, 0xa005,
+	0x0040, 0x723c, 0x8001, 0x7022, 0x0e7f, 0x007c, 0x20a9, 0x0008,
+	0x20a2, 0x00f0, 0x7240, 0x20a2, 0x20a2, 0x007c, 0x0f7e, 0x0e7e,
+	0x0d7e, 0x0c7e, 0x077e, 0x067e, 0x007e, 0x127e, 0x2091, 0x8000,
+	0x2071, 0xa8b1, 0x7614, 0x2660, 0x2678, 0x2039, 0x0001, 0x87ff,
+	0x0040, 0x72e2, 0x8cff, 0x0040, 0x72e2, 0x601c, 0xa086, 0x0006,
+	0x00c0, 0x72dd, 0x88ff, 0x0040, 0x726d, 0x2800, 0xac06, 0x00c0,
+	0x72dd, 0x2039, 0x0000, 0x0078, 0x7278, 0x6018, 0xa206, 0x00c0,
+	0x72dd, 0x85ff, 0x0040, 0x7278, 0x6020, 0xa106, 0x00c0, 0x72dd,
+	0x7024, 0xac06, 0x00c0, 0x72a8, 0x2069, 0x0100, 0x68c0, 0xa005,
+	0x0040, 0x72a3, 0x1078, 0x5acb, 0x6817, 0x0008, 0x68c3, 0x0000,
+	0x1078, 0x7378, 0x7027, 0x0000, 0x037e, 0x2069, 0x0140, 0x6b04,
+	0xa384, 0x1000, 0x0040, 0x7298, 0x6803, 0x0100, 0x6803, 0x0000,
+	0x2069, 0x0100, 0x6824, 0xd084, 0x0040, 0x72a0, 0x6827, 0x0001,
+	0x037f, 0x0078, 0x72a8, 0x6003, 0x0009, 0x630a, 0x0078, 0x72dd,
+	0x7014, 0xac36, 0x00c0, 0x72ae, 0x660c, 0x7616, 0x7010, 0xac36,
+	0x00c0, 0x72bc, 0x2c00, 0xaf36, 0x0040, 0x72ba, 0x2f00, 0x7012,
+	0x0078, 0x72bc, 0x7013, 0x0000, 0x660c, 0x067e, 0x2c00, 0xaf06,
+	0x0040, 0x72c5, 0x7e0e, 0x0078, 0x72c6, 0x2678, 0x89ff, 0x00c0,
+	0x72d5, 0x600f, 0x0000, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040,
+	0x72d3, 0x1078, 0xa1ca, 0x1078, 0x8ec6, 0x1078, 0x7233, 0x88ff,
+	0x00c0, 0x72ec, 0x0c7f, 0x0078, 0x7257, 0x2c78, 0x600c, 0x2060,
+	0x0078, 0x7257, 0xa006, 0x127f, 0x007f, 0x067f, 0x077f, 0x0c7f,
+	0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x6017, 0x0000, 0x0c7f, 0xa8c5,
+	0x0001, 0x0078, 0x72e3, 0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e,
+	0x027e, 0x007e, 0x127e, 0x2091, 0x8000, 0x2071, 0xa8b1, 0x7638,
+	0x2660, 0x2678, 0x8cff, 0x0040, 0x7367, 0x601c, 0xa086, 0x0006,
+	0x00c0, 0x7362, 0x87ff, 0x0040, 0x7313, 0x2700, 0xac06, 0x00c0,
+	0x7362, 0x0078, 0x731e, 0x6018, 0xa206, 0x00c0, 0x7362, 0x85ff,
+	0x0040, 0x731e, 0x6020, 0xa106, 0x00c0, 0x7362, 0x703c, 0xac06,
+	0x00c0, 0x7332, 0x037e, 0x2019, 0x0001, 0x1078, 0x7058, 0x7033,
+	0x0000, 0x703f, 0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x704b,
+	0x0000, 0x037f, 0x7038, 0xac36, 0x00c0, 0x7338, 0x660c, 0x763a,
+	0x7034, 0xac36, 0x00c0, 0x7346, 0x2c00, 0xaf36, 0x0040, 0x7344,
+	0x2f00, 0x7036, 0x0078, 0x7346, 0x7037, 0x0000, 0x660c, 0x067e,
+	0x2c00, 0xaf06, 0x0040, 0x734f, 0x7e0e, 0x0078, 0x7350, 0x2678,
+	0x600f, 0x0000, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x735a,
+	0x1078, 0xa1ca, 0x1078, 0x8ec6, 0x87ff, 0x00c0, 0x7371, 0x0c7f,
+	0x0078, 0x7302, 0x2c78, 0x600c, 0x2060, 0x0078, 0x7302, 0xa006,
+	0x127f, 0x007f, 0x027f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x007c, 0x6017, 0x0000, 0x0c7f, 0xa7bd, 0x0001, 0x0078, 0x7368,
+	0x0e7e, 0x2071, 0xa8b1, 0x2001, 0xa600, 0x2004, 0xa086, 0x0002,
+	0x00c0, 0x7386, 0x7007, 0x0005, 0x0078, 0x7388, 0x7007, 0x0000,
+	0x0e7f, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e, 0x067e, 0x027e, 0x007e,
+	0x127e, 0x2091, 0x8000, 0x2071, 0xa8b1, 0x2c10, 0x7638, 0x2660,
+	0x2678, 0x8cff, 0x0040, 0x73c8, 0x2200, 0xac06, 0x00c0, 0x73c3,
+	0x7038, 0xac36, 0x00c0, 0x73a6, 0x660c, 0x763a, 0x7034, 0xac36,
+	0x00c0, 0x73b4, 0x2c00, 0xaf36, 0x0040, 0x73b2, 0x2f00, 0x7036,
+	0x0078, 0x73b4, 0x7037, 0x0000, 0x660c, 0x2c00, 0xaf06, 0x0040,
+	0x73bc, 0x7e0e, 0x0078, 0x73bd, 0x2678, 0x600f, 0x0000, 0xa085,
+	0x0001, 0x0078, 0x73c8, 0x2c78, 0x600c, 0x2060, 0x0078, 0x7399,
+	0x127f, 0x007f, 0x027f, 0x067f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c,
+	0x0f7e, 0x0e7e, 0x0d7e, 0x0c7e, 0x067e, 0x007e, 0x127e, 0x2091,
+	0x8000, 0x2071, 0xa8b1, 0x760c, 0x2660, 0x2678, 0x8cff, 0x0040,
+	0x7469, 0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x00c0, 0x7464,
+	0x7024, 0xac06, 0x00c0, 0x740f, 0x2069, 0x0100, 0x68c0, 0xa005,
+	0x0040, 0x743d, 0x1078, 0x6e0f, 0x68c3, 0x0000, 0x1078, 0x7378,
+	0x7027, 0x0000, 0x037e, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000,
+	0x0040, 0x7406, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0040, 0x740e, 0x6827, 0x0001, 0x037f, 0x700c,
+	0xac36, 0x00c0, 0x7415, 0x660c, 0x760e, 0x7008, 0xac36, 0x00c0,
+	0x7423, 0x2c00, 0xaf36, 0x0040, 0x7421, 0x2f00, 0x700a, 0x0078,
+	0x7423, 0x700b, 0x0000, 0x660c, 0x067e, 0x2c00, 0xaf06, 0x0040,
+	0x742c, 0x7e0e, 0x0078, 0x742d, 0x2678, 0x600f, 0x0000, 0x1078,
+	0x8eec, 0x00c0, 0x7441, 0x1078, 0x28a6, 0x1078, 0x8f00, 0x00c0,
+	0x745d, 0x1078, 0x7c83, 0x0078, 0x745d, 0x1078, 0x7378, 0x0078,
+	0x740f, 0x1078, 0x8f00, 0x00c0, 0x7449, 0x1078, 0x7c83, 0x0078,
+	0x745d, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x745d, 0x601c,
+	0xa086, 0x0003, 0x00c0, 0x7471, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x1078, 0x4a73, 0x1078, 0x8eb9, 0x1078, 0x8ec6, 0x1078,
+	0x7233, 0x0c7f, 0x0078, 0x73de, 0x2c78, 0x600c, 0x2060, 0x0078,
+	0x73de, 0x127f, 0x007f, 0x067f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0f7f,
+	0x007c, 0x601c, 0xa086, 0x0006, 0x00c0, 0x745d, 0x1078, 0xa1ca,
+	0x0078, 0x745d, 0x037e, 0x157e, 0x137e, 0x147e, 0x3908, 0xa006,
+	0xa190, 0x0020, 0x221c, 0xa39e, 0x2676, 0x00c0, 0x748b, 0x8210,
+	0x8000, 0x0078, 0x7482, 0xa005, 0x0040, 0x7497, 0x20a9, 0x0020,
+	0x2198, 0x8211, 0xa282, 0x0020, 0x20c8, 0x20a0, 0x53a3, 0x147f,
+	0x137f, 0x157f, 0x037f, 0x007c, 0x0d7e, 0x20a1, 0x020b, 0x1078,
+	0x67c2, 0x20a3, 0x0200, 0x20a3, 0x0014, 0x60c3, 0x0014, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x2099, 0xa8a5, 0x20a9, 0x0004, 0x53a6,
+	0x20a3, 0x0004, 0x20a3, 0x7878, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x1078, 0x6dfb, 0x0d7f, 0x007c, 0x20a1, 0x020b, 0x1078, 0x67c2,
+	0x20a3, 0x0214, 0x20a3, 0x0018, 0x20a3, 0x0800, 0x7810, 0xa084,
+	0xff00, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x7810, 0xa084, 0x00ff, 0x20a2, 0x7828, 0x20a2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x1078, 0x6dfb,
+	0x007c, 0x0d7e, 0x017e, 0x2f68, 0x2009, 0x0035, 0x1078, 0x91bc,
+	0x00c0, 0x7551, 0x20a1, 0x020b, 0x1078, 0x6731, 0x20a3, 0x1300,
+	0x20a3, 0x0000, 0x7828, 0x2068, 0x681c, 0xa086, 0x0003, 0x0040,
+	0x752d, 0x7818, 0xa080, 0x0028, 0x2014, 0xa286, 0x007e, 0x00c0,
+	0x7507, 0x20a3, 0x00ff, 0x20a3, 0xfffe, 0x0078, 0x7542, 0xa286,
+	0x007f, 0x00c0, 0x7511, 0x20a3, 0x00ff, 0x20a3, 0xfffd, 0x0078,
+	0x7542, 0xd2bc, 0x0040, 0x7527, 0xa286, 0x0080, 0x00c0, 0x751e,
+	0x20a3, 0x00ff, 0x20a3, 0xfffc, 0x0078, 0x7542, 0xa2e8, 0xa735,
+	0x2d6c, 0x6810, 0x20a2, 0x6814, 0x20a2, 0x0078, 0x7542, 0x20a3,
+	0x0000, 0x6098, 0x20a2, 0x0078, 0x7542, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa082, 0x007e, 0x0048, 0x753e, 0x0d7e, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x7542, 0x20a3, 0x0000,
+	0x6030, 0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x000c, 0x1078, 0x6dfb, 0x017f, 0x0d7f,
+	0x007c, 0x7817, 0x0001, 0x7803, 0x0006, 0x017f, 0x0d7f, 0x007c,
+	0x0d7e, 0x027e, 0x7928, 0x2168, 0x691c, 0xa186, 0x0006, 0x0040,
+	0x757a, 0xa186, 0x0003, 0x0040, 0x75d5, 0xa186, 0x0005, 0x0040,
+	0x75b8, 0xa186, 0x0004, 0x0040, 0x75a8, 0xa186, 0x0008, 0x0040,
+	0x75c2, 0x7807, 0x0037, 0x7813, 0x1700, 0x1078, 0x7640, 0x027f,
+	0x0d7f, 0x007c, 0x1078, 0x75fd, 0x2009, 0x4000, 0x6800, 0x0079,
+	0x7581, 0x7594, 0x75a2, 0x7596, 0x75a2, 0x759d, 0x7594, 0x7594,
+	0x75a2, 0x75a2, 0x75a2, 0x75a2, 0x7594, 0x7594, 0x7594, 0x7594,
+	0x7594, 0x75a2, 0x7594, 0x75a2, 0x1078, 0x1332, 0x6824, 0xd0e4,
+	0x0040, 0x759d, 0xd0cc, 0x0040, 0x75a0, 0xa00e, 0x0078, 0x75a2,
+	0x2009, 0x2000, 0x6828, 0x20a2, 0x682c, 0x20a2, 0x0078, 0x75f3,
+	0x1078, 0x75fd, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0x6a00, 0xa286, 0x0002, 0x00c0, 0x75b6, 0xa00e, 0x0078, 0x75f3,
+	0x1078, 0x75fd, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0x0078, 0x75f3, 0x1078, 0x75fd, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x2009, 0x4000, 0xa286, 0x0005, 0x0040, 0x75d2, 0xa286, 0x0002,
+	0x00c0, 0x75d3, 0xa00e, 0x0078, 0x75f3, 0x1078, 0x75fd, 0x6810,
+	0x2068, 0x697c, 0x6810, 0xa112, 0x6980, 0x6814, 0xa103, 0x20a2,
+	0x22a2, 0x7928, 0xa180, 0x0000, 0x2004, 0xa08e, 0x0002, 0x0040,
+	0x75f1, 0xa08e, 0x0004, 0x0040, 0x75f1, 0x2009, 0x4000, 0x0078,
+	0x75f3, 0x2009, 0x0000, 0x21a2, 0x20a3, 0x0000, 0x60c3, 0x0018,
+	0x1078, 0x6dfb, 0x027f, 0x0d7f, 0x007c, 0x037e, 0x047e, 0x057e,
+	0x067e, 0x20a1, 0x020b, 0x1078, 0x67c2, 0xa006, 0x20a3, 0x0200,
+	0x20a2, 0x7934, 0x21a2, 0x7938, 0x21a2, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa092, 0x007e, 0x0048, 0x7623, 0x0d7e, 0x2069, 0xa61b,
+	0x2d2c, 0x8d68, 0x2d34, 0xa0e8, 0xa735, 0x2d6c, 0x6b10, 0x6c14,
+	0x0d7f, 0x0078, 0x7629, 0x2019, 0x0000, 0x6498, 0x2029, 0x0000,
+	0x6630, 0x7828, 0xa080, 0x0007, 0x2004, 0xa086, 0x0003, 0x00c0,
+	0x7637, 0x25a2, 0x26a2, 0x23a2, 0x24a2, 0x0078, 0x763b, 0x23a2,
+	0x24a2, 0x25a2, 0x26a2, 0x067f, 0x057f, 0x047f, 0x037f, 0x007c,
+	0x20a1, 0x020b, 0x1078, 0x67c2, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x0009, 0x7810, 0x20a2, 0x60c3, 0x0008, 0x1078, 0x6dfb,
+	0x007c, 0x20a1, 0x020b, 0x1078, 0x6728, 0x20a3, 0x1400, 0x20a3,
+	0x0000, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x7828, 0x20a2, 0x782c,
+	0x20a2, 0x7830, 0xa084, 0x00ff, 0x8007, 0x20a2, 0x20a3, 0x0000,
+	0x60c3, 0x0010, 0x1078, 0x6dfb, 0x007c, 0x20a1, 0x020b, 0x1078,
+	0x67b9, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0x20a2, 0x7810,
+	0x20a2, 0x60c3, 0x0008, 0x1078, 0x6dfb, 0x007c, 0x147e, 0x20a1,
+	0x020b, 0x1078, 0x7689, 0x60c3, 0x0000, 0x1078, 0x6dfb, 0x147f,
+	0x007c, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xd0bc, 0x0040, 0x76a6, 0x0d7e, 0xa0e8, 0xa735, 0x2d6c,
+	0x6810, 0xa085, 0x0300, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xa61b,
+	0x2da6, 0x8d68, 0x2da6, 0x0d7f, 0x0078, 0x76ae, 0x20a3, 0x0300,
+	0x6298, 0x22a2, 0x20a3, 0x0000, 0x6230, 0x22a2, 0x20a3, 0x0819,
+	0x20a3, 0x0000, 0x1078, 0x6dea, 0x22a2, 0x20a3, 0x0000, 0x2fa2,
+	0x7a08, 0x22a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x007c, 0x2061,
+	0xad00, 0x2a70, 0x7064, 0x704a, 0x704f, 0xad00, 0x007c, 0x0e7e,
+	0x127e, 0x2071, 0xa600, 0x2091, 0x8000, 0x7548, 0xa582, 0x0010,
+	0x0048, 0x76f9, 0x704c, 0x2060, 0x6000, 0xa086, 0x0000, 0x0040,
+	0x76e5, 0xace0, 0x0010, 0x7058, 0xac02, 0x00c8, 0x76e1, 0x0078,
+	0x76d4, 0x2061, 0xad00, 0x0078, 0x76d4, 0x6003, 0x0008, 0x8529,
+	0x754a, 0xaca8, 0x0010, 0x7058, 0xa502, 0x00c8, 0x76f5, 0x754e,
+	0xa085, 0x0001, 0x127f, 0x0e7f, 0x007c, 0x704f, 0xad00, 0x0078,
+	0x76f0, 0xa006, 0x0078, 0x76f2, 0x0e7e, 0x2071, 0xa600, 0x7548,
+	0xa582, 0x0010, 0x0048, 0x772a, 0x704c, 0x2060, 0x6000, 0xa086,
+	0x0000, 0x0040, 0x7717, 0xace0, 0x0010, 0x7058, 0xac02, 0x00c8,
+	0x7713, 0x0078, 0x7706, 0x2061, 0xad00, 0x0078, 0x7706, 0x6003,
+	0x0008, 0x8529, 0x754a, 0xaca8, 0x0010, 0x7058, 0xa502, 0x00c8,
+	0x7726, 0x754e, 0xa085, 0x0001, 0x0e7f, 0x007c, 0x704f, 0xad00,
+	0x0078, 0x7722, 0xa006, 0x0078, 0x7724, 0xac82, 0xad00, 0x1048,
+	0x1332, 0x2001, 0xa616, 0x2004, 0xac02, 0x10c8, 0x1332, 0xa006,
+	0x6006, 0x600a, 0x600e, 0x6012, 0x6016, 0x601a, 0x601f, 0x0000,
+	0x6003, 0x0000, 0x6022, 0x6026, 0x602a, 0x602e, 0x6032, 0x6036,
+	0x603a, 0x603e, 0x2061, 0xa600, 0x6048, 0x8000, 0x604a, 0xa086,
+	0x0001, 0x0040, 0x7754, 0x007c, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x62d1, 0x127f, 0x0078, 0x7753, 0x601c, 0xa084, 0x000f, 0x0079,
+	0x7761, 0x776a, 0x777b, 0x7797, 0x77b3, 0x920e, 0x922a, 0x9246,
+	0x776a, 0x777b, 0xa186, 0x0013, 0x00c0, 0x7773, 0x1078, 0x61cd,
+	0x1078, 0x62d1, 0x007c, 0xa18e, 0x0047, 0x00c0, 0x777a, 0xa016,
+	0x1078, 0x15fa, 0x007c, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8,
+	0x1332, 0x1079, 0x7785, 0x067f, 0x007c, 0x7795, 0x7b00, 0x7cb2,
+	0x7795, 0x7d36, 0x77cf, 0x7795, 0x7795, 0x7a92, 0x80f6, 0x7795,
+	0x7795, 0x7795, 0x7795, 0x7795, 0x7795, 0x1078, 0x1332, 0x067e,
+	0x6000, 0xa0b2, 0x0010, 0x10c8, 0x1332, 0x1079, 0x77a1, 0x067f,
+	0x007c, 0x77b1, 0x87c3, 0x77b1, 0x77b1, 0x77b1, 0x77b1, 0x77b1,
+	0x77b1, 0x8766, 0x8951, 0x77b1, 0x87f3, 0x8879, 0x87f3, 0x8879,
+	0x77b1, 0x1078, 0x1332, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8,
+	0x1332, 0x1079, 0x77bd, 0x067f, 0x007c, 0x77cd, 0x813d, 0x820e,
+	0x8368, 0x84e4, 0x77cd, 0x77cd, 0x77cd, 0x8116, 0x870e, 0x8712,
+	0x77cd, 0x77cd, 0x77cd, 0x77cd, 0x8742, 0x1078, 0x1332, 0xa1b6,
+	0x0015, 0x00c0, 0x77d7, 0x1078, 0x772d, 0x0078, 0x77dd, 0xa1b6,
+	0x0016, 0x10c0, 0x1332, 0x1078, 0x772d, 0x007c, 0x20a9, 0x000e,
+	0x2e98, 0x6010, 0x20a0, 0x53a3, 0x20a9, 0x0006, 0x3310, 0x3420,
+	0x9398, 0x94a0, 0x3318, 0x3428, 0x222e, 0x2326, 0xa290, 0x0002,
+	0xa5a8, 0x0002, 0xa398, 0x0002, 0xa4a0, 0x0002, 0x00f0, 0x77ec,
+	0x0e7e, 0x1078, 0x8d06, 0x0040, 0x7803, 0x6010, 0x2070, 0x7007,
+	0x0000, 0x7037, 0x0103, 0x0e7f, 0x1078, 0x772d, 0x007c, 0x0d7e,
+	0x037e, 0x7330, 0xa386, 0x0200, 0x00c0, 0x7814, 0x6018, 0x2068,
+	0x6813, 0x00ff, 0x6817, 0xfffd, 0x6010, 0xa005, 0x0040, 0x781e,
+	0x2068, 0x6807, 0x0000, 0x6837, 0x0103, 0x6b32, 0x1078, 0x772d,
+	0x037f, 0x0d7f, 0x007c, 0x017e, 0x20a9, 0x002a, 0xae80, 0x000c,
+	0x2098, 0x6010, 0xa080, 0x0002, 0x20a0, 0x53a3, 0x20a9, 0x002a,
+	0x6010, 0xa080, 0x0001, 0x2004, 0xa080, 0x0002, 0x20a0, 0x53a3,
+	0x0e7e, 0x6010, 0x2004, 0x2070, 0x7037, 0x0103, 0x0e7f, 0x1078,
+	0x772d, 0x017f, 0x007c, 0x0e7e, 0x0d7e, 0x603f, 0x0000, 0x2c68,
+	0x017e, 0x2009, 0x0035, 0x1078, 0x91bc, 0x017f, 0x00c0, 0x785f,
+	0x027e, 0x6228, 0x2268, 0x027f, 0x2071, 0xab8c, 0x6b1c, 0xa386,
+	0x0003, 0x0040, 0x7863, 0xa386, 0x0006, 0x0040, 0x7867, 0x1078,
+	0x772d, 0x0078, 0x7869, 0x1078, 0x786c, 0x0078, 0x7869, 0x1078,
+	0x7938, 0x0d7f, 0x0e7f, 0x007c, 0x0f7e, 0x6810, 0x2078, 0xa186,
+	0x0015, 0x0040, 0x791d, 0xa18e, 0x0016, 0x00c0, 0x7936, 0x700c,
+	0xa08c, 0xff00, 0xa186, 0x1700, 0x0040, 0x7882, 0xa186, 0x0300,
+	0x00c0, 0x78f8, 0x8fff, 0x00c0, 0x788c, 0x6800, 0xa086, 0x000f,
+	0x0040, 0x78db, 0x0078, 0x7934, 0x6808, 0xa086, 0xffff, 0x00c0,
+	0x7921, 0x784c, 0xa084, 0x0060, 0xa086, 0x0020, 0x00c0, 0x78a2,
+	0x797c, 0x7810, 0xa106, 0x00c0, 0x7921, 0x7980, 0x7814, 0xa106,
+	0x00c0, 0x7921, 0x1078, 0x8eb9, 0x6830, 0x7852, 0x784c, 0xc0dc,
+	0xc0f4, 0xc0d4, 0x784e, 0x027e, 0xa00e, 0x6a14, 0x2001, 0x000a,
+	0x1078, 0x5c1c, 0x7854, 0xa20a, 0x0048, 0x78b7, 0x8011, 0x7a56,
+	0x82ff, 0x027f, 0x00c0, 0x78c3, 0x0c7e, 0x2d60, 0x1078, 0x8ae0,
+	0x0c7f, 0x0078, 0x7934, 0x0c7e, 0x0d7e, 0x2f68, 0x6838, 0xd0fc,
+	0x00c0, 0x78ce, 0x1078, 0x4353, 0x0078, 0x78d0, 0x1078, 0x4431,
+	0x0d7f, 0x0c7f, 0x00c0, 0x7921, 0x0c7e, 0x2d60, 0x1078, 0x772d,
+	0x0c7f, 0x0078, 0x7934, 0x0c7e, 0x1078, 0x9187, 0x0040, 0x78f1,
+	0x6013, 0x0000, 0x6818, 0x601a, 0x601f, 0x0003, 0x6904, 0x0c7e,
+	0x2d60, 0x1078, 0x772d, 0x0c7f, 0x1078, 0x775c, 0x0c7f, 0x0078,
+	0x7934, 0x2001, 0xa8a4, 0x2004, 0x683e, 0x0c7f, 0x0078, 0x7934,
+	0x7008, 0xa086, 0x000b, 0x00c0, 0x7912, 0x6018, 0x200c, 0xc1bc,
+	0x2102, 0x0c7e, 0x2d60, 0x7853, 0x0003, 0x6007, 0x0085, 0x6003,
+	0x000b, 0x601f, 0x0002, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0c7f,
+	0x0078, 0x7934, 0x700c, 0xa086, 0x2a00, 0x00c0, 0x7921, 0x2001,
+	0xa8a4, 0x2004, 0x683e, 0x0078, 0x7934, 0x1078, 0x7953, 0x0078,
+	0x7936, 0x8fff, 0x1040, 0x1332, 0x0c7e, 0x0d7e, 0x2d60, 0x2f68,
+	0x6837, 0x0103, 0x684b, 0x0003, 0x1078, 0x89cf, 0x1078, 0x8eb9,
+	0x1078, 0x8ec6, 0x0d7f, 0x0c7f, 0x1078, 0x772d, 0x0f7f, 0x007c,
+	0xa186, 0x0015, 0x00c0, 0x7942, 0x2001, 0xa8a4, 0x2004, 0x683e,
+	0x0078, 0x7950, 0xa18e, 0x0016, 0x00c0, 0x7952, 0x0c7e, 0x2d00,
+	0x2060, 0x1078, 0xa495, 0x1078, 0x5bc1, 0x1078, 0x772d, 0x0c7f,
+	0x1078, 0x772d, 0x007c, 0x027e, 0x037e, 0x047e, 0x7228, 0x7c80,
+	0x7b7c, 0xd2f4, 0x0040, 0x7962, 0x2001, 0xa8a4, 0x2004, 0x683e,
+	0x0078, 0x79c6, 0x0c7e, 0x2d60, 0x1078, 0x89f3, 0x0c7f, 0x6804,
+	0xa086, 0x0050, 0x00c0, 0x797a, 0x0c7e, 0x2d00, 0x2060, 0x6003,
+	0x0001, 0x6007, 0x0050, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0c7f,
+	0x0078, 0x79c6, 0x6800, 0xa086, 0x000f, 0x0040, 0x799c, 0x8fff,
+	0x1040, 0x1332, 0x6824, 0xd0dc, 0x00c0, 0x799c, 0x6800, 0xa086,
+	0x0004, 0x00c0, 0x79a1, 0x784c, 0xd0ac, 0x0040, 0x79a1, 0x784c,
+	0xc0dc, 0xc0f4, 0x784e, 0x7850, 0xc0f4, 0xc0fc, 0x7852, 0x2001,
+	0x0001, 0x682e, 0x0078, 0x79c0, 0x2001, 0x0007, 0x682e, 0x0078,
+	0x79c0, 0x784c, 0xd0b4, 0x00c0, 0x79ae, 0xd0ac, 0x0040, 0x799c,
+	0x784c, 0xd0f4, 0x00c0, 0x799c, 0x0078, 0x798f, 0xd2ec, 0x00c0,
+	0x799c, 0x7024, 0xa306, 0x00c0, 0x79b9, 0x7020, 0xa406, 0x0040,
+	0x799c, 0x7020, 0x6836, 0x7024, 0x683a, 0x2001, 0x0005, 0x682e,
+	0x1078, 0x8ff0, 0x1078, 0x62d1, 0x0078, 0x79c8, 0x1078, 0x772d,
+	0x047f, 0x037f, 0x027f, 0x007c, 0x0e7e, 0x0d7e, 0x027e, 0x6034,
+	0x2068, 0x6a1c, 0xa286, 0x0007, 0x0040, 0x7a35, 0xa286, 0x0002,
+	0x0040, 0x7a35, 0xa286, 0x0000, 0x0040, 0x7a35, 0x6808, 0x6338,
+	0xa306, 0x00c0, 0x7a35, 0x2071, 0xab8c, 0xa186, 0x0015, 0x0040,
+	0x7a2f, 0xa18e, 0x0016, 0x00c0, 0x7a02, 0x6030, 0xa084, 0x00ff,
+	0xa086, 0x0001, 0x00c0, 0x7a02, 0x700c, 0xa086, 0x2a00, 0x00c0,
+	0x7a02, 0x6034, 0xa080, 0x0009, 0x200c, 0xc1dd, 0xc1f5, 0x2102,
+	0x0078, 0x7a2f, 0x0c7e, 0x6034, 0x2060, 0x6104, 0xa186, 0x004b,
+	0x0040, 0x7a22, 0xa186, 0x004c, 0x0040, 0x7a22, 0xa186, 0x004d,
+	0x0040, 0x7a22, 0xa186, 0x004e, 0x0040, 0x7a22, 0xa186, 0x0052,
+	0x0040, 0x7a22, 0x6010, 0x2068, 0x1078, 0x8d06, 0x1040, 0x1332,
+	0x6853, 0x0003, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002,
+	0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0c7f, 0x0078, 0x7a35, 0x6034,
+	0x2068, 0x2001, 0xa8a4, 0x2004, 0x683e, 0x1078, 0x772d, 0x027f,
+	0x0d7f, 0x0e7f, 0x007c, 0x0d7e, 0x20a9, 0x000e, 0x2e98, 0x6010,
+	0x20a0, 0x53a3, 0xa1b6, 0x0015, 0x00c0, 0x7a73, 0x6018, 0x2068,
+	0x157e, 0x037e, 0x027e, 0xae90, 0x000c, 0xa290, 0x0004, 0x20a9,
+	0x0004, 0xad98, 0x000a, 0x1078, 0x80de, 0x027f, 0x037f, 0x157f,
+	0x00c0, 0x7a76, 0x157e, 0x037e, 0x027e, 0xae90, 0x000c, 0xa290,
+	0x0008, 0x20a9, 0x0004, 0xad98, 0x0006, 0x1078, 0x80de, 0x027f,
+	0x037f, 0x157f, 0x00c0, 0x7a76, 0x7038, 0x680a, 0x703c, 0x680e,
+	0x6800, 0xc08d, 0x6802, 0x0d7f, 0x0078, 0x77f8, 0x1078, 0x2880,
+	0x0c7e, 0x1078, 0x76c7, 0x2f00, 0x601a, 0x6013, 0x0000, 0x601f,
+	0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x2001, 0x0007, 0x1078,
+	0x4502, 0x1078, 0x4535, 0x1078, 0x5dd7, 0x1078, 0x62d1, 0x0c7f,
+	0x0078, 0x7a73, 0x2100, 0xa1b2, 0x0044, 0x10c8, 0x1332, 0xa1b2,
+	0x0040, 0x00c8, 0x7af7, 0x0079, 0x7a9d, 0x7aeb, 0x7adf, 0x7aeb,
+	0x7aeb, 0x7aeb, 0x7aeb, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add,
+	0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add,
+	0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add,
+	0x7add, 0x7add, 0x7add, 0x7add, 0x7aeb, 0x7add, 0x7aeb, 0x7aeb,
+	0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7aeb, 0x7add, 0x7add,
+	0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7aeb,
+	0x7aeb, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add, 0x7add,
+	0x7add, 0x7add, 0x7aeb, 0x7add, 0x7add, 0x1078, 0x1332, 0x6003,
+	0x0001, 0x6106, 0x1078, 0x5dd7, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x62d1, 0x127f, 0x007c, 0x6003, 0x0001, 0x6106, 0x1078, 0x5dd7,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x62d1, 0x127f, 0x007c, 0x2600,
+	0x0079, 0x7afa, 0x7afe, 0x7afe, 0x7afe, 0x7aeb, 0x1078, 0x1332,
+	0x6004, 0xa0b2, 0x0044, 0x10c8, 0x1332, 0xa1b6, 0x0013, 0x00c0,
+	0x7b10, 0xa0b2, 0x0040, 0x00c8, 0x7c79, 0x2008, 0x0079, 0x7bbf,
+	0xa1b6, 0x0027, 0x00c0, 0x7b7c, 0x1078, 0x61cd, 0x6004, 0x1078,
+	0x8eec, 0x0040, 0x7b2d, 0x1078, 0x8f00, 0x0040, 0x7b74, 0xa08e,
+	0x0021, 0x0040, 0x7b78, 0xa08e, 0x0022, 0x0040, 0x7b74, 0xa08e,
+	0x003d, 0x0040, 0x7b78, 0x0078, 0x7b6f, 0x1078, 0x28a6, 0x2001,
+	0x0007, 0x1078, 0x4502, 0x6018, 0xa080, 0x0028, 0x200c, 0x1078,
+	0x7c83, 0xa186, 0x007e, 0x00c0, 0x7b42, 0x2001, 0xa633, 0x2014,
+	0xc285, 0x2202, 0x017e, 0x027e, 0x037e, 0x2110, 0x027e, 0x2019,
+	0x0028, 0x1078, 0x73d0, 0x027f, 0x1078, 0xa4f1, 0x037f, 0x027f,
+	0x017f, 0x017e, 0x027e, 0x037e, 0x2110, 0x2019, 0x0028, 0x1078,
+	0x5f01, 0x077e, 0x2039, 0x0000, 0x1078, 0x5e0a, 0x0c7e, 0x6018,
+	0xa065, 0x0040, 0x7b65, 0x1078, 0x47e9, 0x0c7f, 0x2c08, 0x1078,
+	0x9f8b, 0x077f, 0x037f, 0x027f, 0x017f, 0x1078, 0x457f, 0x1078,
+	0x772d, 0x1078, 0x62d1, 0x007c, 0x1078, 0x7c83, 0x0078, 0x7b6f,
+	0x1078, 0x7ca6, 0x0078, 0x7b6f, 0xa186, 0x0014, 0x00c0, 0x7b73,
+	0x1078, 0x61cd, 0x1078, 0x2880, 0x1078, 0x8eec, 0x00c0, 0x7b9b,
+	0x1078, 0x28a6, 0x6018, 0xa080, 0x0028, 0x200c, 0x1078, 0x7c83,
+	0xa186, 0x007e, 0x00c0, 0x7b99, 0x2001, 0xa633, 0x200c, 0xc185,
+	0x2102, 0x0078, 0x7b6f, 0x1078, 0x8f00, 0x00c0, 0x7ba3, 0x1078,
+	0x7c83, 0x0078, 0x7b6f, 0x6004, 0xa08e, 0x0032, 0x00c0, 0x7bb4,
+	0x0e7e, 0x0f7e, 0x2071, 0xa682, 0x2079, 0x0000, 0x1078, 0x2bd7,
+	0x0f7f, 0x0e7f, 0x0078, 0x7b6f, 0x6004, 0xa08e, 0x0021, 0x0040,
+	0x7b9f, 0xa08e, 0x0022, 0x1040, 0x7c83, 0x0078, 0x7b6f, 0x7c01,
+	0x7c03, 0x7c07, 0x7c0b, 0x7c0f, 0x7c13, 0x7bff, 0x7bff, 0x7bff,
+	0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff,
+	0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff,
+	0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7c17, 0x7c29, 0x7bff,
+	0x7c2b, 0x7c29, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7c29,
+	0x7c29, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff, 0x7bff,
+	0x7bff, 0x7c5c, 0x7c29, 0x7bff, 0x7c23, 0x7bff, 0x7bff, 0x7bff,
+	0x7c25, 0x7bff, 0x7bff, 0x7bff, 0x7c29, 0x7bff, 0x7bff, 0x1078,
+	0x1332, 0x0078, 0x7c29, 0x2001, 0x000b, 0x0078, 0x7c36, 0x2001,
+	0x0003, 0x0078, 0x7c36, 0x2001, 0x0005, 0x0078, 0x7c36, 0x2001,
+	0x0001, 0x0078, 0x7c36, 0x2001, 0x0009, 0x0078, 0x7c36, 0x1078,
+	0x61cd, 0x6003, 0x0005, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x1078,
+	0x62d1, 0x0078, 0x7c35, 0x0078, 0x7c29, 0x0078, 0x7c29, 0x1078,
+	0x4502, 0x0078, 0x7c6e, 0x1078, 0x61cd, 0x6003, 0x0004, 0x2001,
+	0xa8a2, 0x2004, 0x6016, 0x1078, 0x62d1, 0x007c, 0x1078, 0x4502,
+	0x1078, 0x61cd, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x6003, 0x0002,
+	0x037e, 0x2019, 0xa65d, 0x2304, 0xa084, 0xff00, 0x00c0, 0x7c4d,
+	0x2019, 0xa8a2, 0x231c, 0x0078, 0x7c56, 0x8007, 0xa09a, 0x0004,
+	0x0048, 0x7c48, 0x8003, 0x801b, 0x831b, 0xa318, 0x6316, 0x037f,
+	0x1078, 0x62d1, 0x0078, 0x7c35, 0x0e7e, 0x0f7e, 0x2071, 0xa682,
+	0x2079, 0x0000, 0x1078, 0x2bd7, 0x0f7f, 0x0e7f, 0x1078, 0x61cd,
+	0x1078, 0x772d, 0x1078, 0x62d1, 0x0078, 0x7c35, 0x1078, 0x61cd,
+	0x6003, 0x0002, 0x2001, 0xa8a2, 0x2004, 0x6016, 0x1078, 0x62d1,
+	0x007c, 0x2600, 0x2008, 0x0079, 0x7c7d, 0x7c81, 0x7c81, 0x7c81,
+	0x7c6e, 0x1078, 0x1332, 0x0e7e, 0x1078, 0x8d06, 0x0040, 0x7c9f,
+	0x6010, 0x2070, 0x7038, 0xd0fc, 0x0040, 0x7c9f, 0x7007, 0x0000,
+	0x017e, 0x6004, 0xa08e, 0x0021, 0x0040, 0x7ca1, 0xa08e, 0x003d,
+	0x0040, 0x7ca1, 0x017f, 0x7037, 0x0103, 0x7033, 0x0100, 0x0e7f,
+	0x007c, 0x017f, 0x1078, 0x7ca6, 0x0078, 0x7c9f, 0x0e7e, 0xacf0,
+	0x0004, 0x2e74, 0x7000, 0x2070, 0x7037, 0x0103, 0x7023, 0x8001,
+	0x0e7f, 0x007c, 0x0d7e, 0x6618, 0x2668, 0x6804, 0xa084, 0x00ff,
+	0x0d7f, 0xa0b2, 0x000c, 0x10c8, 0x1332, 0x6604, 0xa6b6, 0x0043,
+	0x00c0, 0x7cc6, 0x1078, 0x9134, 0x0078, 0x7d25, 0x6604, 0xa6b6,
+	0x0033, 0x00c0, 0x7ccf, 0x1078, 0x90d8, 0x0078, 0x7d25, 0x6604,
+	0xa6b6, 0x0028, 0x00c0, 0x7cd8, 0x1078, 0x8f2f, 0x0078, 0x7d25,
+	0x6604, 0xa6b6, 0x0029, 0x00c0, 0x7ce1, 0x1078, 0x8f49, 0x0078,
+	0x7d25, 0x6604, 0xa6b6, 0x001f, 0x00c0, 0x7cea, 0x1078, 0x77de,
+	0x0078, 0x7d25, 0x6604, 0xa6b6, 0x0000, 0x00c0, 0x7cf3, 0x1078,
+	0x7a3b, 0x0078, 0x7d25, 0x6604, 0xa6b6, 0x0022, 0x00c0, 0x7cfc,
+	0x1078, 0x7807, 0x0078, 0x7d25, 0x6604, 0xa6b6, 0x0035, 0x00c0,
+	0x7d05, 0x1078, 0x7843, 0x0078, 0x7d25, 0x6604, 0xa6b6, 0x0039,
+	0x00c0, 0x7d0e, 0x1078, 0x79cc, 0x0078, 0x7d25, 0x6604, 0xa6b6,
+	0x003d, 0x00c0, 0x7d17, 0x1078, 0x7823, 0x0078, 0x7d25, 0xa1b6,
+	0x0015, 0x00c0, 0x7d1f, 0x1079, 0x7d2a, 0x0078, 0x7d25, 0xa1b6,
+	0x0016, 0x00c0, 0x7d26, 0x1079, 0x7e7f, 0x007c, 0x1078, 0x7773,
+	0x0078, 0x7d25, 0x7d4e, 0x7d51, 0x7d4e, 0x7d9c, 0x7d4e, 0x7e13,
+	0x7e8b, 0x7d4e, 0x7d4e, 0x7e57, 0x7d4e, 0x7e6d, 0xa1b6, 0x0048,
+	0x0040, 0x7d42, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x1078,
+	0x15fa, 0x007c, 0x0e7e, 0xacf0, 0x0004, 0x2e74, 0x7000, 0x2070,
+	0x7037, 0x0103, 0x0e7f, 0x1078, 0x772d, 0x007c, 0x0005, 0x0005,
+	0x007c, 0x0e7e, 0x2071, 0xa600, 0x7080, 0xa086, 0x0074, 0x00c0,
+	0x7d85, 0x1078, 0x9f5f, 0x00c0, 0x7d77, 0x0d7e, 0x6018, 0x2068,
+	0x7030, 0xd08c, 0x0040, 0x7d6a, 0x6800, 0xd0bc, 0x0040, 0x7d6a,
+	0xc0c5, 0x6802, 0x1078, 0x7d89, 0x0d7f, 0x2001, 0x0006, 0x1078,
+	0x4502, 0x1078, 0x28a6, 0x1078, 0x772d, 0x0078, 0x7d87, 0x2001,
+	0x000a, 0x1078, 0x4502, 0x1078, 0x28a6, 0x6003, 0x0001, 0x6007,
+	0x0001, 0x1078, 0x5dd7, 0x0078, 0x7d87, 0x1078, 0x7dff, 0x0e7f,
+	0x007c, 0x6800, 0xd084, 0x0040, 0x7d9b, 0x2001, 0x0000, 0x1078,
+	0x44ee, 0x2069, 0xa652, 0x6804, 0xd0a4, 0x0040, 0x7d9b, 0x2001,
+	0x0006, 0x1078, 0x4535, 0x007c, 0x0d7e, 0x2011, 0xa620, 0x2204,
+	0xa086, 0x0074, 0x00c0, 0x7dfb, 0x6018, 0x2068, 0x6aa0, 0xa286,
+	0x007e, 0x00c0, 0x7daf, 0x1078, 0x7f9b, 0x0078, 0x7dfd, 0x1078,
+	0x7f91, 0x6018, 0x2068, 0xa080, 0x0028, 0x2014, 0xa286, 0x0080,
+	0x00c0, 0x7dd3, 0x6813, 0x00ff, 0x6817, 0xfffc, 0x6010, 0xa005,
+	0x0040, 0x7dc9, 0x2068, 0x6807, 0x0000, 0x6837, 0x0103, 0x6833,
+	0x0200, 0x2001, 0x0006, 0x1078, 0x4502, 0x1078, 0x28a6, 0x1078,
+	0x772d, 0x0078, 0x7dfd, 0x0e7e, 0x2071, 0xa633, 0x2e04, 0xd09c,
+	0x0040, 0x7dee, 0x2071, 0xab80, 0x7108, 0x720c, 0xa18c, 0x00ff,
+	0x00c0, 0x7de6, 0xa284, 0xff00, 0x0040, 0x7dee, 0x6018, 0x2070,
+	0x70a0, 0xd0bc, 0x00c0, 0x7dee, 0x7112, 0x7216, 0x0e7f, 0x2001,
+	0x0004, 0x1078, 0x4502, 0x6003, 0x0001, 0x6007, 0x0003, 0x1078,
+	0x5dd7, 0x0078, 0x7dfd, 0x1078, 0x7dff, 0x0d7f, 0x007c, 0x2001,
+	0x0007, 0x1078, 0x4502, 0x2001, 0xa600, 0x2004, 0xa086, 0x0003,
+	0x00c0, 0x7e0e, 0x2001, 0x0007, 0x1078, 0x4535, 0x1078, 0x28a6,
+	0x1078, 0x772d, 0x007c, 0x0e7e, 0x2071, 0xa600, 0x7080, 0xa086,
+	0x0014, 0x00c0, 0x7e51, 0x7000, 0xa086, 0x0003, 0x00c0, 0x7e26,
+	0x6010, 0xa005, 0x00c0, 0x7e26, 0x1078, 0x3699, 0x0d7e, 0x6018,
+	0x2068, 0x1078, 0x4649, 0x1078, 0x7d89, 0x0d7f, 0x1078, 0x8043,
+	0x00c0, 0x7e51, 0x0d7e, 0x6018, 0x2068, 0x6890, 0x0d7f, 0xa005,
+	0x0040, 0x7e51, 0x2001, 0x0006, 0x1078, 0x4502, 0x0e7e, 0x6010,
+	0xa005, 0x0040, 0x7e4a, 0x2070, 0x7007, 0x0000, 0x7037, 0x0103,
+	0x7033, 0x0200, 0x0e7f, 0x1078, 0x28a6, 0x1078, 0x772d, 0x0078,
+	0x7e55, 0x1078, 0x7c83, 0x1078, 0x7dff, 0x0e7f, 0x007c, 0x2011,
+	0xa620, 0x2204, 0xa086, 0x0014, 0x00c0, 0x7e6a, 0x2001, 0x0002,
+	0x1078, 0x4502, 0x6003, 0x0001, 0x6007, 0x0001, 0x1078, 0x5dd7,
+	0x0078, 0x7e6c, 0x1078, 0x7dff, 0x007c, 0x2011, 0xa620, 0x2204,
+	0xa086, 0x0004, 0x00c0, 0x7e7c, 0x2001, 0x0007, 0x1078, 0x4502,
+	0x1078, 0x772d, 0x0078, 0x7e7e, 0x1078, 0x7dff, 0x007c, 0x7d4e,
+	0x7e97, 0x7d4e, 0x7ed2, 0x7d4e, 0x7f44, 0x7e8b, 0x7d4e, 0x7d4e,
+	0x7f59, 0x7d4e, 0x7f6c, 0x6604, 0xa686, 0x0003, 0x0040, 0x7e13,
+	0xa6b6, 0x001e, 0x00c0, 0x7e96, 0x1078, 0x772d, 0x007c, 0x0d7e,
+	0x0c7e, 0x1078, 0x7f7f, 0x00c0, 0x7ead, 0x2001, 0x0000, 0x1078,
+	0x44ee, 0x2001, 0x0002, 0x1078, 0x4502, 0x6003, 0x0001, 0x6007,
+	0x0002, 0x1078, 0x5dd7, 0x0078, 0x7ecf, 0x2009, 0xab8e, 0x2104,
+	0xa086, 0x0009, 0x00c0, 0x7ec2, 0x6018, 0x2068, 0x6840, 0xa084,
+	0x00ff, 0xa005, 0x0040, 0x7ecd, 0x8001, 0x6842, 0x6017, 0x000a,
+	0x0078, 0x7ecf, 0x2009, 0xab8f, 0x2104, 0xa084, 0xff00, 0xa086,
+	0x1900, 0x00c0, 0x7ecd, 0x0078, 0x7ea1, 0x1078, 0x7dff, 0x0c7f,
+	0x0d7f, 0x007c, 0x1078, 0x7f8e, 0x00c0, 0x7ee6, 0x2001, 0x0000,
+	0x1078, 0x44ee, 0x2001, 0x0002, 0x1078, 0x4502, 0x6003, 0x0001,
+	0x6007, 0x0002, 0x1078, 0x5dd7, 0x0078, 0x7f12, 0x1078, 0x7c83,
+	0x2009, 0xab8e, 0x2134, 0xa6b4, 0x00ff, 0xa686, 0x0005, 0x0040,
+	0x7f13, 0xa686, 0x000b, 0x0040, 0x7f10, 0x2009, 0xab8f, 0x2104,
+	0xa084, 0xff00, 0x00c0, 0x7f00, 0xa686, 0x0009, 0x0040, 0x7f13,
+	0xa086, 0x1900, 0x00c0, 0x7f10, 0xa686, 0x0009, 0x0040, 0x7f13,
+	0x2001, 0x0004, 0x1078, 0x4502, 0x1078, 0x772d, 0x0078, 0x7f12,
+	0x1078, 0x7dff, 0x007c, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8d06,
+	0x0040, 0x7f21, 0x6838, 0xd0fc, 0x0040, 0x7f21, 0x0d7f, 0x0078,
+	0x7f10, 0x6018, 0x2068, 0x6840, 0xa084, 0x00ff, 0xa005, 0x0040,
+	0x7f32, 0x8001, 0x6842, 0x6017, 0x000a, 0x6007, 0x0016, 0x0d7f,
+	0x0078, 0x7f12, 0x68a0, 0xa086, 0x007e, 0x00c0, 0x7f3f, 0x0e7e,
+	0x2071, 0xa600, 0x1078, 0x42b8, 0x0e7f, 0x0078, 0x7f41, 0x1078,
+	0x2880, 0x0d7f, 0x0078, 0x7f10, 0x1078, 0x7f8e, 0x00c0, 0x7f54,
+	0x2001, 0x0004, 0x1078, 0x4502, 0x6003, 0x0001, 0x6007, 0x0003,
+	0x1078, 0x5dd7, 0x0078, 0x7f58, 0x1078, 0x7c83, 0x1078, 0x7dff,
+	0x007c, 0x1078, 0x7f8e, 0x00c0, 0x7f69, 0x2001, 0x0008, 0x1078,
+	0x4502, 0x6003, 0x0001, 0x6007, 0x0005, 0x1078, 0x5dd7, 0x0078,
+	0x7f6b, 0x1078, 0x7dff, 0x007c, 0x1078, 0x7f8e, 0x00c0, 0x7f7c,
+	0x2001, 0x000a, 0x1078, 0x4502, 0x6003, 0x0001, 0x6007, 0x0001,
+	0x1078, 0x5dd7, 0x0078, 0x7f7e, 0x1078, 0x7dff, 0x007c, 0x2009,
+	0xab8e, 0x2104, 0xa086, 0x0003, 0x00c0, 0x7f8d, 0x2009, 0xab8f,
+	0x2104, 0xa084, 0xff00, 0xa086, 0x2a00, 0x007c, 0xa085, 0x0001,
+	0x007c, 0x0c7e, 0x017e, 0xac88, 0x0006, 0x2164, 0x1078, 0x45d6,
+	0x017f, 0x0c7f, 0x007c, 0x0f7e, 0x0e7e, 0x0d7e, 0x037e, 0x017e,
+	0x6018, 0x2068, 0x2071, 0xa633, 0x2e04, 0xa085, 0x0003, 0x2072,
+	0x1078, 0x8014, 0x0040, 0x7fd9, 0x2009, 0xa633, 0x2104, 0xc0cd,
+	0x200a, 0x2001, 0xa653, 0x2004, 0xd0a4, 0x0040, 0x7fc2, 0xa006,
+	0x2020, 0x2009, 0x002a, 0x1078, 0xa21d, 0x2001, 0xa60c, 0x200c,
+	0xc195, 0x2102, 0x2019, 0x002a, 0x2009, 0x0001, 0x1078, 0x284f,
+	0x2071, 0xa600, 0x1078, 0x2677, 0x0c7e, 0x157e, 0x20a9, 0x0081,
+	0x2009, 0x007f, 0x1078, 0x298e, 0x8108, 0x00f0, 0x7fd2, 0x157f,
+	0x0c7f, 0x1078, 0x7f91, 0x6813, 0x00ff, 0x6817, 0xfffe, 0x2071,
+	0xab80, 0x2079, 0x0100, 0x2e04, 0xa084, 0x00ff, 0x2069, 0xa61b,
+	0x206a, 0x78e6, 0x007e, 0x8e70, 0x2e04, 0x2069, 0xa61c, 0x206a,
+	0x78ea, 0xa084, 0xff00, 0x017f, 0xa105, 0x2009, 0xa626, 0x200a,
+	0x2069, 0xab8e, 0x2071, 0xa89e, 0x6810, 0x2072, 0x6814, 0x7006,
+	0x6818, 0x700a, 0x681c, 0x700e, 0x1078, 0x906e, 0x2001, 0x0006,
+	0x1078, 0x4502, 0x1078, 0x28a6, 0x1078, 0x772d, 0x017f, 0x037f,
+	0x0d7f, 0x0e7f, 0x0f7f, 0x007c, 0x027e, 0x037e, 0x0e7e, 0x157e,
+	0x2019, 0xa626, 0x231c, 0x83ff, 0x0040, 0x803e, 0x2071, 0xab80,
+	0x2e14, 0xa294, 0x00ff, 0x7004, 0xa084, 0xff00, 0xa205, 0xa306,
+	0x00c0, 0x803e, 0x2011, 0xab96, 0xad98, 0x000a, 0x20a9, 0x0004,
+	0x1078, 0x80de, 0x00c0, 0x803e, 0x2011, 0xab9a, 0xad98, 0x0006,
+	0x20a9, 0x0004, 0x1078, 0x80de, 0x00c0, 0x803e, 0x157f, 0x0e7f,
+	0x037f, 0x027f, 0x007c, 0x0e7e, 0x2071, 0xab8c, 0x7004, 0xa086,
+	0x0014, 0x00c0, 0x8066, 0x7008, 0xa086, 0x0800, 0x00c0, 0x8066,
+	0x700c, 0xd0ec, 0x0040, 0x8064, 0xa084, 0x0f00, 0xa086, 0x0100,
+	0x00c0, 0x8064, 0x7024, 0xd0a4, 0x00c0, 0x8061, 0xd0ac, 0x0040,
+	0x8064, 0xa006, 0x0078, 0x8066, 0xa085, 0x0001, 0x0e7f, 0x007c,
+	0x0e7e, 0x0d7e, 0x0c7e, 0x077e, 0x057e, 0x047e, 0x027e, 0x007e,
+	0x127e, 0x2091, 0x8000, 0x2029, 0xa8ba, 0x252c, 0x2021, 0xa8c0,
+	0x2424, 0x2061, 0xad00, 0x2071, 0xa600, 0x7248, 0x7064, 0xa202,
+	0x00c8, 0x80cc, 0x1078, 0xa242, 0x0040, 0x80c4, 0x671c, 0xa786,
+	0x0001, 0x0040, 0x80c4, 0xa786, 0x0007, 0x0040, 0x80c4, 0x2500,
+	0xac06, 0x0040, 0x80c4, 0x2400, 0xac06, 0x0040, 0x80c4, 0x0c7e,
+	0x6000, 0xa086, 0x0004, 0x00c0, 0x809f, 0x1078, 0x1757, 0xa786,
+	0x0008, 0x00c0, 0x80ae, 0x1078, 0x8f00, 0x00c0, 0x80ae, 0x0c7f,
+	0x1078, 0x7c83, 0x1078, 0x8ec6, 0x0078, 0x80c4, 0x6010, 0x2068,
+	0x1078, 0x8d06, 0x0040, 0x80c1, 0xa786, 0x0003, 0x00c0, 0x80d6,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0x4a73, 0x1078,
+	0x8eb9, 0x1078, 0x8ec6, 0x0c7f, 0xace0, 0x0010, 0x7058, 0xac02,
+	0x00c8, 0x80cc, 0x0078, 0x807d, 0x127f, 0x007f, 0x027f, 0x047f,
+	0x057f, 0x077f, 0x0c7f, 0x0d7f, 0x0e7f, 0x007c, 0xa786, 0x0006,
+	0x00c0, 0x80b8, 0x1078, 0xa1ca, 0x0078, 0x80c1, 0x220c, 0x2304,
+	0xa106, 0x00c0, 0x80e9, 0x8210, 0x8318, 0x00f0, 0x80de, 0xa006,
+	0x007c, 0x2304, 0xa102, 0x0048, 0x80f1, 0x2001, 0x0001, 0x0078,
+	0x80f3, 0x2001, 0x0000, 0xa18d, 0x0001, 0x007c, 0x6004, 0xa08a,
+	0x0044, 0x10c8, 0x1332, 0x1078, 0x8eec, 0x0040, 0x8105, 0x1078,
+	0x8f00, 0x0040, 0x8112, 0x0078, 0x810b, 0x1078, 0x28a6, 0x1078,
+	0x8f00, 0x0040, 0x8112, 0x1078, 0x61cd, 0x1078, 0x772d, 0x1078,
+	0x62d1, 0x007c, 0x1078, 0x7c83, 0x0078, 0x810b, 0xa182, 0x0040,
+	0x0079, 0x811a, 0x812d, 0x812d, 0x812d, 0x812d, 0x812d, 0x812d,
+	0x812d, 0x812d, 0x812d, 0x812d, 0x812d, 0x812f, 0x812f, 0x812f,
+	0x812f, 0x812d, 0x812d, 0x812d, 0x812f, 0x1078, 0x1332, 0x600b,
+	0xffff, 0x6003, 0x0001, 0x6106, 0x1078, 0x5d8a, 0x127e, 0x2091,
+	0x8000, 0x1078, 0x62d1, 0x127f, 0x007c, 0xa186, 0x0013, 0x00c0,
+	0x8146, 0x6004, 0xa082, 0x0040, 0x0079, 0x81d1, 0xa186, 0x0027,
+	0x00c0, 0x8168, 0x1078, 0x61cd, 0x1078, 0x2880, 0x0d7e, 0x6110,
+	0x2168, 0x1078, 0x8d06, 0x0040, 0x8162, 0x6837, 0x0103, 0x684b,
+	0x0029, 0x6847, 0x0000, 0x694c, 0xc1c5, 0x694e, 0x1078, 0x4a73,
+	0x1078, 0x8eb9, 0x0d7f, 0x1078, 0x772d, 0x1078, 0x62d1, 0x007c,
+	0xa186, 0x0014, 0x00c0, 0x8171, 0x6004, 0xa082, 0x0040, 0x0079,
+	0x8199, 0xa186, 0x0046, 0x0040, 0x817d, 0xa186, 0x0045, 0x0040,
+	0x817d, 0xa186, 0x0047, 0x10c0, 0x1332, 0x2001, 0x0109, 0x2004,
+	0xd084, 0x0040, 0x8196, 0x127e, 0x2091, 0x2200, 0x007e, 0x017e,
+	0x027e, 0x1078, 0x5c56, 0x027f, 0x017f, 0x007f, 0x127f, 0x6000,
+	0xa086, 0x0002, 0x00c0, 0x8196, 0x0078, 0x820e, 0x1078, 0x7773,
+	0x007c, 0x81ae, 0x81ac, 0x81ac, 0x81ac, 0x81ac, 0x81ac, 0x81ac,
+	0x81ac, 0x81ac, 0x81ac, 0x81ac, 0x81ca, 0x81ca, 0x81ca, 0x81ca,
+	0x81ac, 0x81ca, 0x81ac, 0x81ca, 0x1078, 0x1332, 0x1078, 0x61cd,
+	0x0d7e, 0x6110, 0x2168, 0x1078, 0x8d06, 0x0040, 0x81c4, 0x6837,
+	0x0103, 0x684b, 0x0006, 0x6847, 0x0000, 0x6850, 0xc0ec, 0x6852,
+	0x1078, 0x4a73, 0x1078, 0x8eb9, 0x0d7f, 0x1078, 0x772d, 0x1078,
+	0x62d1, 0x007c, 0x1078, 0x61cd, 0x1078, 0x772d, 0x1078, 0x62d1,
+	0x007c, 0x81e6, 0x81e4, 0x81e4, 0x81e4, 0x81e4, 0x81e4, 0x81e4,
+	0x81e4, 0x81e4, 0x81e4, 0x81e4, 0x81f8, 0x81f8, 0x81f8, 0x81f8,
+	0x81e4, 0x8207, 0x81e4, 0x81f8, 0x1078, 0x1332, 0x1078, 0x61cd,
+	0x2001, 0xa8a4, 0x2004, 0x603e, 0x6003, 0x0002, 0x1078, 0x62d1,
+	0x6010, 0xa088, 0x0013, 0x2104, 0xa085, 0x0400, 0x200a, 0x007c,
+	0x1078, 0x61cd, 0x2001, 0xa8a2, 0x2004, 0x6016, 0x2001, 0xa8a4,
+	0x2004, 0x603e, 0x6003, 0x000f, 0x1078, 0x62d1, 0x007c, 0x1078,
+	0x61cd, 0x1078, 0x772d, 0x1078, 0x62d1, 0x007c, 0xa182, 0x0040,
+	0x0079, 0x8212, 0x8225, 0x8225, 0x8225, 0x8225, 0x8225, 0x8227,
+	0x8327, 0x8359, 0x8225, 0x8225, 0x8225, 0x8225, 0x8225, 0x8225,
+	0x8225, 0x8225, 0x8225, 0x8225, 0x8225, 0x1078, 0x1332, 0x0e7e,
+	0x0d7e, 0x603f, 0x0000, 0x2071, 0xab80, 0x7124, 0x610a, 0x2071,
+	0xab8c, 0x6110, 0x2168, 0x7614, 0xa6b4, 0x0fff, 0x86ff, 0x0040,
+	0x82e9, 0xa68c, 0x0c00, 0x0040, 0x825e, 0x0f7e, 0x2c78, 0x1078,
+	0x4963, 0x0f7f, 0x0040, 0x825a, 0x684c, 0xd0ac, 0x0040, 0x825a,
+	0x6024, 0xd0dc, 0x00c0, 0x825a, 0x6850, 0xd0bc, 0x00c0, 0x825a,
+	0x7318, 0x6814, 0xa306, 0x00c0, 0x8301, 0x731c, 0x6810, 0xa306,
+	0x00c0, 0x8301, 0x7318, 0x6b62, 0x731c, 0x6b5e, 0xa68c, 0x00ff,
+	0xa186, 0x0002, 0x0040, 0x8291, 0xa186, 0x0028, 0x00c0, 0x826e,
+	0x1078, 0x8eda, 0x684b, 0x001c, 0x0078, 0x8293, 0xd6dc, 0x0040,
+	0x828a, 0x684b, 0x0015, 0x684c, 0xd0ac, 0x0040, 0x8288, 0x6914,
+	0x6a10, 0x2100, 0xa205, 0x0040, 0x8288, 0x7018, 0xa106, 0x00c0,
+	0x8285, 0x701c, 0xa206, 0x0040, 0x8288, 0x6962, 0x6a5e, 0xc6dc,
+	0x0078, 0x8293, 0xd6d4, 0x0040, 0x8291, 0x684b, 0x0007, 0x0078,
+	0x8293, 0x684b, 0x0000, 0x6837, 0x0103, 0x6e46, 0xa01e, 0xd6c4,
+	0x0040, 0x82bc, 0xa686, 0x0100, 0x00c0, 0x82a7, 0x2001, 0xab99,
+	0x2004, 0xa005, 0x00c0, 0x82a7, 0xc6c4, 0x0078, 0x8236, 0x7328,
+	0x732c, 0x6b56, 0x83ff, 0x0040, 0x82bc, 0xa38a, 0x0009, 0x0048,
+	0x82b3, 0x2019, 0x0008, 0x037e, 0x2308, 0x2019, 0xab98, 0xad90,
+	0x0019, 0x1078, 0x89e2, 0x037f, 0xd6cc, 0x0040, 0x8317, 0x7124,
+	0x695a, 0x81ff, 0x0040, 0x8317, 0xa192, 0x0021, 0x00c8, 0x82d5,
+	0x2071, 0xab98, 0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x1078,
+	0x89e2, 0x1078, 0x91f4, 0x0078, 0x8317, 0x6838, 0xd0fc, 0x0040,
+	0x82de, 0x2009, 0x0020, 0x695a, 0x0078, 0x82c8, 0x0f7e, 0x2d78,
+	0x1078, 0x897a, 0x0f7f, 0x1078, 0x91f4, 0x1078, 0x89cf, 0x0078,
+	0x8319, 0x0f7e, 0x2c78, 0x1078, 0x4963, 0x0f7f, 0x0040, 0x8307,
+	0x684c, 0xd0ac, 0x0040, 0x8307, 0x6024, 0xd0dc, 0x00c0, 0x8307,
+	0x6850, 0xd0bc, 0x00c0, 0x8307, 0x6810, 0x6914, 0xa105, 0x0040,
+	0x8307, 0x1078, 0x8fbf, 0x0d7f, 0x0e7f, 0x0078, 0x8326, 0x684b,
+	0x0000, 0x6837, 0x0103, 0x6e46, 0x684c, 0xd0ac, 0x0040, 0x8317,
+	0x6810, 0x6914, 0xa115, 0x0040, 0x8317, 0x1078, 0x84d5, 0x1078,
+	0x4a73, 0x6218, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x1078, 0x8f89,
+	0x0d7f, 0x0e7f, 0x00c0, 0x8326, 0x1078, 0x772d, 0x007c, 0x0f7e,
+	0x6003, 0x0003, 0x2079, 0xab8c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08,
+	0x6010, 0x2078, 0x784c, 0xd0ac, 0x0040, 0x833e, 0x6003, 0x0002,
+	0x0f7f, 0x007c, 0x2130, 0x2228, 0x0078, 0x834a, 0x2400, 0x797c,
+	0xa10a, 0x2300, 0x7a80, 0xa213, 0x2600, 0xa102, 0x2500, 0xa203,
+	0x0048, 0x833a, 0x7c12, 0x7b16, 0x7e0a, 0x7d0e, 0x0f7f, 0x603f,
+	0x0000, 0x2c10, 0x1078, 0x1cf0, 0x1078, 0x5df6, 0x1078, 0x639b,
+	0x007c, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x6003, 0x0004, 0x6110,
+	0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x1078, 0x15fa, 0x007c,
+	0xa182, 0x0040, 0x0079, 0x836c, 0x837f, 0x837f, 0x837f, 0x837f,
+	0x837f, 0x8381, 0x8424, 0x837f, 0x837f, 0x843a, 0x84ab, 0x837f,
+	0x837f, 0x837f, 0x837f, 0x84ba, 0x837f, 0x837f, 0x837f, 0x1078,
+	0x1332, 0x077e, 0x0f7e, 0x0e7e, 0x0d7e, 0x2071, 0xab8c, 0x6110,
+	0x2178, 0x7614, 0xa6b4, 0x0fff, 0x7e46, 0x7f4c, 0xc7e5, 0x7f4e,
+	0x6218, 0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0040, 0x841f,
+	0xa694, 0xff00, 0xa284, 0x0c00, 0x0040, 0x83a2, 0x7018, 0x7862,
+	0x701c, 0x785e, 0xa284, 0x0300, 0x0040, 0x841f, 0x1078, 0x138b,
+	0x1040, 0x1332, 0x2d00, 0x784a, 0x7f4c, 0xc7cd, 0x7f4e, 0x6837,
+	0x0103, 0x7838, 0x683a, 0x783c, 0x683e, 0x7840, 0x6842, 0x6e46,
+	0xa68c, 0x0c00, 0x0040, 0x83c0, 0x7318, 0x6b62, 0x731c, 0x6b5e,
+	0xa68c, 0x00ff, 0xa186, 0x0002, 0x0040, 0x83dc, 0xa186, 0x0028,
+	0x00c0, 0x83ce, 0x684b, 0x001c, 0x0078, 0x83de, 0xd6dc, 0x0040,
+	0x83d5, 0x684b, 0x0015, 0x0078, 0x83de, 0xd6d4, 0x0040, 0x83dc,
+	0x684b, 0x0007, 0x0078, 0x83de, 0x684b, 0x0000, 0x6f4e, 0x7850,
+	0x6852, 0x7854, 0x6856, 0xa01e, 0xd6c4, 0x0040, 0x83fc, 0x7328,
+	0x732c, 0x6b56, 0x83ff, 0x0040, 0x83fc, 0xa38a, 0x0009, 0x0048,
+	0x83f3, 0x2019, 0x0008, 0x037e, 0x2308, 0x2019, 0xab98, 0xad90,
+	0x0019, 0x1078, 0x89e2, 0x037f, 0xd6cc, 0x0040, 0x841f, 0x7124,
+	0x695a, 0x81ff, 0x0040, 0x841f, 0xa192, 0x0021, 0x00c8, 0x8413,
+	0x2071, 0xab98, 0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x1078,
+	0x89e2, 0x0078, 0x841f, 0x7838, 0xd0fc, 0x0040, 0x841c, 0x2009,
+	0x0020, 0x695a, 0x0078, 0x8408, 0x2d78, 0x1078, 0x897a, 0x0d7f,
+	0x0e7f, 0x0f7f, 0x077f, 0x007c, 0x0f7e, 0x6003, 0x0003, 0x2079,
+	0xab8c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08, 0x6010, 0x2078, 0x7c12,
+	0x7b16, 0x7e0a, 0x7d0e, 0x0f7f, 0x2c10, 0x1078, 0x1cf0, 0x1078,
+	0x6df4, 0x007c, 0x0d7e, 0x0f7e, 0x2c78, 0x1078, 0x4963, 0x0f7f,
+	0x0040, 0x8446, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x6003, 0x0002,
+	0x1078, 0x627a, 0x1078, 0x639b, 0x6110, 0x2168, 0x694c, 0xd1e4,
+	0x0040, 0x84a9, 0xd1cc, 0x0040, 0x8480, 0x6948, 0x6838, 0xd0fc,
+	0x0040, 0x8478, 0x017e, 0x684c, 0x007e, 0x6850, 0x007e, 0xad90,
+	0x000d, 0xa198, 0x000d, 0x2009, 0x0020, 0x157e, 0x21a8, 0x2304,
+	0x2012, 0x8318, 0x8210, 0x00f0, 0x8467, 0x157f, 0x007f, 0x6852,
+	0x007f, 0x684e, 0x017f, 0x2168, 0x1078, 0x13b4, 0x0078, 0x84a3,
+	0x017e, 0x1078, 0x13b4, 0x0d7f, 0x1078, 0x89cf, 0x0078, 0x84a3,
+	0x6837, 0x0103, 0x6944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0040,
+	0x849f, 0xa086, 0x0028, 0x00c0, 0x8491, 0x684b, 0x001c, 0x0078,
+	0x84a1, 0xd1dc, 0x0040, 0x8498, 0x684b, 0x0015, 0x0078, 0x84a1,
+	0xd1d4, 0x0040, 0x849f, 0x684b, 0x0007, 0x0078, 0x84a1, 0x684b,
+	0x0000, 0x1078, 0x4a73, 0x1078, 0x8f89, 0x00c0, 0x84a9, 0x1078,
+	0x772d, 0x0d7f, 0x007c, 0x2019, 0x0001, 0x1078, 0x7058, 0x6003,
+	0x0002, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x1078, 0x627a, 0x1078,
+	0x639b, 0x007c, 0x1078, 0x627a, 0x1078, 0x2880, 0x0d7e, 0x6110,
+	0x2168, 0x1078, 0x8d06, 0x0040, 0x84cf, 0x6837, 0x0103, 0x684b,
+	0x0029, 0x6847, 0x0000, 0x1078, 0x4a73, 0x1078, 0x8eb9, 0x0d7f,
+	0x1078, 0x772d, 0x1078, 0x639b, 0x007c, 0x684b, 0x0015, 0xd1fc,
+	0x0040, 0x84e1, 0x684b, 0x0007, 0x8002, 0x8000, 0x810a, 0xa189,
+	0x0000, 0x6962, 0x685e, 0x007c, 0xa182, 0x0040, 0x0079, 0x84e8,
+	0x84fb, 0x84fb, 0x84fb, 0x84fb, 0x84fb, 0x84fd, 0x84fb, 0x85d0,
+	0x85dc, 0x84fb, 0x84fb, 0x84fb, 0x84fb, 0x84fb, 0x84fb, 0x84fb,
+	0x84fb, 0x84fb, 0x84fb, 0x1078, 0x1332, 0x077e, 0x0f7e, 0x0e7e,
+	0x0d7e, 0x2071, 0xab8c, 0x6110, 0x2178, 0x7614, 0xa6b4, 0x0fff,
+	0x0f7e, 0x2c78, 0x1078, 0x4963, 0x0f7f, 0x0040, 0x851b, 0xa684,
+	0x00ff, 0x00c0, 0x851b, 0x6024, 0xd0f4, 0x0040, 0x851b, 0x1078,
+	0x8fbf, 0x0078, 0x85cb, 0x7e46, 0x7f4c, 0xc7e5, 0x7f4e, 0x6218,
+	0x2268, 0x6a3c, 0x8211, 0x6a3e, 0x86ff, 0x0040, 0x85c0, 0xa694,
+	0xff00, 0xa284, 0x0c00, 0x0040, 0x8531, 0x7018, 0x7862, 0x701c,
+	0x785e, 0xa284, 0x0300, 0x0040, 0x85bd, 0xa686, 0x0100, 0x00c0,
+	0x8543, 0x2001, 0xab99, 0x2004, 0xa005, 0x00c0, 0x8543, 0xc6c4,
+	0x7e46, 0x0078, 0x8524, 0x1078, 0x138b, 0x1040, 0x1332, 0x2d00,
+	0x784a, 0x7f4c, 0xa7bd, 0x0200, 0x7f4e, 0x6837, 0x0103, 0x7838,
+	0x683a, 0x783c, 0x683e, 0x7840, 0x6842, 0x6e46, 0xa68c, 0x0c00,
+	0x0040, 0x855e, 0x7318, 0x6b62, 0x731c, 0x6b5e, 0xa68c, 0x00ff,
+	0xa186, 0x0002, 0x0040, 0x857a, 0xa186, 0x0028, 0x00c0, 0x856c,
+	0x684b, 0x001c, 0x0078, 0x857c, 0xd6dc, 0x0040, 0x8573, 0x684b,
+	0x0015, 0x0078, 0x857c, 0xd6d4, 0x0040, 0x857a, 0x684b, 0x0007,
+	0x0078, 0x857c, 0x684b, 0x0000, 0x6f4e, 0x7850, 0x6852, 0x7854,
+	0x6856, 0xa01e, 0xd6c4, 0x0040, 0x859a, 0x7328, 0x732c, 0x6b56,
+	0x83ff, 0x0040, 0x859a, 0xa38a, 0x0009, 0x0048, 0x8591, 0x2019,
+	0x0008, 0x037e, 0x2308, 0x2019, 0xab98, 0xad90, 0x0019, 0x1078,
+	0x89e2, 0x037f, 0xd6cc, 0x0040, 0x85bd, 0x7124, 0x695a, 0x81ff,
+	0x0040, 0x85bd, 0xa192, 0x0021, 0x00c8, 0x85b1, 0x2071, 0xab98,
+	0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x1078, 0x89e2, 0x0078,
+	0x85bd, 0x7838, 0xd0fc, 0x0040, 0x85ba, 0x2009, 0x0020, 0x695a,
+	0x0078, 0x85a6, 0x2d78, 0x1078, 0x897a, 0xd6dc, 0x00c0, 0x85c3,
+	0xa006, 0x0078, 0x85c9, 0x2001, 0x0001, 0x2071, 0xab8c, 0x7218,
+	0x731c, 0x1078, 0x1653, 0x0d7f, 0x0e7f, 0x0f7f, 0x077f, 0x007c,
+	0x2001, 0xa8a4, 0x2004, 0x603e, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x1078, 0x15fa, 0x007c, 0x2001, 0xa8a4, 0x2004, 0x603e,
+	0x0d7e, 0x6003, 0x0002, 0x6110, 0x2168, 0x694c, 0xd1e4, 0x0040,
+	0x870c, 0x603f, 0x0000, 0x0f7e, 0x2c78, 0x1078, 0x4963, 0x0f7f,
+	0x0040, 0x8622, 0x6814, 0x6910, 0xa115, 0x0040, 0x8622, 0x6a60,
+	0xa206, 0x00c0, 0x85ff, 0x685c, 0xa106, 0x0040, 0x8622, 0x684c,
+	0xc0e4, 0x684e, 0x6847, 0x0000, 0x6863, 0x0000, 0x685f, 0x0000,
+	0x6024, 0xd0f4, 0x00c0, 0x8617, 0x697c, 0x6810, 0xa102, 0x603a,
+	0x6980, 0x6814, 0xa103, 0x6036, 0x6024, 0xc0f5, 0x6026, 0x0d7e,
+	0x6018, 0x2068, 0x683c, 0x8000, 0x683e, 0x0d7f, 0x1078, 0x8fbf,
+	0x0078, 0x870c, 0x694c, 0xd1cc, 0x0040, 0x86d1, 0x6948, 0x6838,
+	0xd0fc, 0x0040, 0x8689, 0x017e, 0x684c, 0x007e, 0x6850, 0x007e,
+	0x0f7e, 0x2178, 0x7944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0040,
+	0x865c, 0xa086, 0x0028, 0x00c0, 0x8643, 0x684b, 0x001c, 0x784b,
+	0x001c, 0x0078, 0x8667, 0xd1dc, 0x0040, 0x8653, 0x684b, 0x0015,
+	0x784b, 0x0015, 0x1078, 0x916c, 0x0040, 0x8651, 0x7944, 0xc1dc,
+	0x7946, 0x0078, 0x8667, 0xd1d4, 0x0040, 0x865c, 0x684b, 0x0007,
+	0x784b, 0x0007, 0x0078, 0x8667, 0x684c, 0xd0ac, 0x0040, 0x8667,
+	0x6810, 0x6914, 0xa115, 0x0040, 0x8667, 0x1078, 0x84d5, 0x6848,
+	0x784a, 0x6860, 0x7862, 0x685c, 0x785e, 0xad90, 0x000d, 0xaf98,
+	0x000d, 0x2009, 0x0020, 0x157e, 0x21a8, 0x2304, 0x2012, 0x8318,
+	0x8210, 0x00f0, 0x8675, 0x157f, 0x0f7f, 0x007f, 0x6852, 0x007f,
+	0x684e, 0x1078, 0x91f4, 0x017f, 0x2168, 0x1078, 0x13b4, 0x0078,
+	0x8706, 0x017e, 0x0f7e, 0x2178, 0x7944, 0xa184, 0x00ff, 0xa0b6,
+	0x0002, 0x0040, 0x86b6, 0xa086, 0x0028, 0x00c0, 0x869d, 0x684b,
+	0x001c, 0x784b, 0x001c, 0x0078, 0x86c1, 0xd1dc, 0x0040, 0x86ad,
+	0x684b, 0x0015, 0x784b, 0x0015, 0x1078, 0x916c, 0x0040, 0x86ab,
+	0x7944, 0xc1dc, 0x7946, 0x0078, 0x86c1, 0xd1d4, 0x0040, 0x86b6,
+	0x684b, 0x0007, 0x784b, 0x0007, 0x0078, 0x86c1, 0x684c, 0xd0ac,
+	0x0040, 0x86c1, 0x6810, 0x6914, 0xa115, 0x0040, 0x86c1, 0x1078,
+	0x84d5, 0x6860, 0x7862, 0x685c, 0x785e, 0x684c, 0x784e, 0x0f7f,
+	0x1078, 0x13b4, 0x0d7f, 0x1078, 0x91f4, 0x1078, 0x89cf, 0x0078,
+	0x8706, 0x6837, 0x0103, 0x6944, 0xa184, 0x00ff, 0xa0b6, 0x0002,
+	0x0040, 0x86f7, 0xa086, 0x0028, 0x00c0, 0x86e2, 0x684b, 0x001c,
+	0x0078, 0x8704, 0xd1dc, 0x0040, 0x86f0, 0x684b, 0x0015, 0x1078,
+	0x916c, 0x0040, 0x86ee, 0x6944, 0xc1dc, 0x6946, 0x0078, 0x8704,
+	0xd1d4, 0x0040, 0x86f7, 0x684b, 0x0007, 0x0078, 0x8704, 0x684b,
+	0x0000, 0x684c, 0xd0ac, 0x0040, 0x8704, 0x6810, 0x6914, 0xa115,
+	0x0040, 0x8704, 0x1078, 0x84d5, 0x1078, 0x4a73, 0x1078, 0x8f89,
+	0x00c0, 0x870c, 0x1078, 0x772d, 0x0d7f, 0x007c, 0x1078, 0x61cd,
+	0x0078, 0x8714, 0x1078, 0x627a, 0x1078, 0x8d06, 0x0040, 0x8733,
+	0x0d7e, 0x6110, 0x2168, 0x6837, 0x0103, 0x2009, 0xa60c, 0x210c,
+	0xd18c, 0x00c0, 0x873e, 0xd184, 0x00c0, 0x873a, 0x6108, 0x694a,
+	0xa18e, 0x0029, 0x00c0, 0x872e, 0x1078, 0xa4e2, 0x6847, 0x0000,
+	0x1078, 0x4a73, 0x0d7f, 0x1078, 0x772d, 0x1078, 0x62d1, 0x1078,
+	0x639b, 0x007c, 0x684b, 0x0004, 0x0078, 0x872e, 0x684b, 0x0004,
+	0x0078, 0x872e, 0xa182, 0x0040, 0x0079, 0x8746, 0x8759, 0x8759,
+	0x8759, 0x8759, 0x8759, 0x875b, 0x8759, 0x875e, 0x8759, 0x8759,
+	0x8759, 0x8759, 0x8759, 0x8759, 0x8759, 0x8759, 0x8759, 0x8759,
+	0x8759, 0x1078, 0x1332, 0x1078, 0x772d, 0x007c, 0x007e, 0x027e,
+	0xa016, 0x1078, 0x15fa, 0x027f, 0x007f, 0x007c, 0xa182, 0x0085,
+	0x0079, 0x876a, 0x8773, 0x8771, 0x8771, 0x877f, 0x8771, 0x8771,
+	0x8771, 0x1078, 0x1332, 0x6003, 0x0001, 0x6106, 0x1078, 0x5d8a,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x62d1, 0x127f, 0x007c, 0x027e,
+	0x057e, 0x0d7e, 0x0e7e, 0x2071, 0xab80, 0x7224, 0x6212, 0x7220,
+	0x1078, 0x8cf2, 0x0040, 0x87a4, 0x2268, 0x6800, 0xa086, 0x0000,
+	0x0040, 0x87a4, 0x6018, 0x6d18, 0xa52e, 0x00c0, 0x87a4, 0x0c7e,
+	0x2d60, 0x1078, 0x89f3, 0x0c7f, 0x0040, 0x87a4, 0x6803, 0x0002,
+	0x6007, 0x0086, 0x0078, 0x87a6, 0x6007, 0x0087, 0x6003, 0x0001,
+	0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0f7e, 0x2278, 0x1078, 0x4963,
+	0x0f7f, 0x0040, 0x87be, 0x6824, 0xd0ec, 0x0040, 0x87be, 0x0c7e,
+	0x2260, 0x603f, 0x0000, 0x1078, 0x8fbf, 0x0c7f, 0x0e7f, 0x0d7f,
+	0x057f, 0x027f, 0x007c, 0xa186, 0x0013, 0x00c0, 0x87d4, 0x6004,
+	0xa08a, 0x0085, 0x1048, 0x1332, 0xa08a, 0x008c, 0x10c8, 0x1332,
+	0xa082, 0x0085, 0x0079, 0x87e3, 0xa186, 0x0027, 0x0040, 0x87dc,
+	0xa186, 0x0014, 0x10c0, 0x1332, 0x1078, 0x61cd, 0x1078, 0x8ec6,
+	0x1078, 0x62d1, 0x007c, 0x87ea, 0x87ec, 0x87ec, 0x87ea, 0x87ea,
+	0x87ea, 0x87ea, 0x1078, 0x1332, 0x1078, 0x61cd, 0x1078, 0x8ec6,
+	0x1078, 0x62d1, 0x007c, 0xa186, 0x0013, 0x00c0, 0x87fd, 0x6004,
+	0xa082, 0x0085, 0x2008, 0x0078, 0x8838, 0xa186, 0x0027, 0x00c0,
+	0x8820, 0x1078, 0x61cd, 0x1078, 0x2880, 0x0d7e, 0x6010, 0x2068,
+	0x1078, 0x8d06, 0x0040, 0x8816, 0x6837, 0x0103, 0x6847, 0x0000,
+	0x684b, 0x0029, 0x1078, 0x4a73, 0x1078, 0x8eb9, 0x0d7f, 0x1078,
+	0x772d, 0x1078, 0x62d1, 0x007c, 0x1078, 0x7773, 0x0078, 0x881b,
+	0xa186, 0x0014, 0x00c0, 0x881c, 0x1078, 0x61cd, 0x0d7e, 0x6010,
+	0x2068, 0x1078, 0x8d06, 0x0040, 0x8816, 0x6837, 0x0103, 0x6847,
+	0x0000, 0x684b, 0x0006, 0x6850, 0xc0ec, 0x6852, 0x0078, 0x8812,
+	0x0079, 0x883a, 0x8843, 0x8841, 0x8841, 0x8841, 0x8841, 0x8841,
+	0x885e, 0x1078, 0x1332, 0x1078, 0x61cd, 0x6030, 0xa08c, 0xff00,
+	0x810f, 0xa186, 0x0039, 0x0040, 0x8851, 0xa186, 0x0035, 0x00c0,
+	0x8855, 0x2001, 0xa8a2, 0x0078, 0x8857, 0x2001, 0xa8a3, 0x2004,
+	0x6016, 0x6003, 0x000c, 0x1078, 0x62d1, 0x007c, 0x1078, 0x61cd,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0040, 0x886c,
+	0xa186, 0x0035, 0x00c0, 0x8870, 0x2001, 0xa8a2, 0x0078, 0x8872,
+	0x2001, 0xa8a3, 0x2004, 0x6016, 0x6003, 0x000e, 0x1078, 0x62d1,
+	0x007c, 0xa182, 0x008c, 0x00c8, 0x8883, 0xa182, 0x0085, 0x0048,
+	0x8883, 0x0079, 0x8886, 0x1078, 0x7773, 0x007c, 0x888d, 0x888d,
+	0x888d, 0x888d, 0x888f, 0x88ec, 0x888d, 0x1078, 0x1332, 0x0f7e,
+	0x2c78, 0x1078, 0x4963, 0x0f7f, 0x0040, 0x88a2, 0x6030, 0xa08c,
+	0xff00, 0x810f, 0xa186, 0x0039, 0x0040, 0x8903, 0xa186, 0x0035,
+	0x0040, 0x8903, 0x0d7e, 0x1078, 0x8d06, 0x00c0, 0x88ab, 0x1078,
+	0x8eb9, 0x0078, 0x88ce, 0x6010, 0x2068, 0x684c, 0xd0e4, 0x00c0,
+	0x88b3, 0x1078, 0x8eb9, 0x6837, 0x0103, 0x6850, 0xd0b4, 0x0040,
+	0x88bf, 0x684b, 0x0006, 0xc0ec, 0x6852, 0x0078, 0x88ca, 0xd0bc,
+	0x0040, 0x88c6, 0x684b, 0x0002, 0x0078, 0x88ca, 0x684b, 0x0005,
+	0x1078, 0x8f85, 0x6847, 0x0000, 0x1078, 0x4a73, 0x2c68, 0x1078,
+	0x76c7, 0x0040, 0x88e7, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009,
+	0xab8e, 0x210c, 0x6136, 0x2009, 0xab8f, 0x210c, 0x613a, 0x6918,
+	0x611a, 0x6920, 0x6122, 0x601f, 0x0001, 0x1078, 0x5d8a, 0x2d60,
+	0x1078, 0x772d, 0x0d7f, 0x007c, 0x0f7e, 0x2c78, 0x1078, 0x4963,
+	0x0f7f, 0x0040, 0x8929, 0x6030, 0xa08c, 0xff00, 0x810f, 0xa186,
+	0x0035, 0x0040, 0x8903, 0xa186, 0x001e, 0x0040, 0x8903, 0xa186,
+	0x0039, 0x00c0, 0x8929, 0x0d7e, 0x2c68, 0x1078, 0x91bc, 0x00c0,
+	0x894d, 0x1078, 0x76c7, 0x0040, 0x8926, 0x6106, 0x6003, 0x0001,
+	0x601f, 0x0001, 0x6918, 0x611a, 0x6928, 0x612a, 0x692c, 0x612e,
+	0x6930, 0xa18c, 0x00ff, 0x6132, 0x6934, 0x6136, 0x6938, 0x613a,
+	0x6920, 0x6122, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x2d60, 0x0078,
+	0x894d, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x894d,
+	0x6837, 0x0103, 0x6850, 0xd0b4, 0x0040, 0x893c, 0xc0ec, 0x6852,
+	0x684b, 0x0006, 0x0078, 0x8947, 0xd0bc, 0x0040, 0x8943, 0x684b,
+	0x0002, 0x0078, 0x8947, 0x684b, 0x0005, 0x1078, 0x8f85, 0x6847,
+	0x0000, 0x1078, 0x4a73, 0x1078, 0x8eb9, 0x0d7f, 0x1078, 0x772d,
+	0x007c, 0x017e, 0x0d7e, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040,
+	0x8961, 0x6837, 0x0103, 0x684b, 0x0028, 0x6847, 0x0000, 0x1078,
+	0x4a73, 0x0d7f, 0x017f, 0xa186, 0x0013, 0x0040, 0x8973, 0xa186,
+	0x0014, 0x0040, 0x8973, 0xa186, 0x0027, 0x0040, 0x8973, 0x1078,
+	0x7773, 0x0078, 0x8979, 0x1078, 0x61cd, 0x1078, 0x8ec6, 0x1078,
+	0x62d1, 0x007c, 0x057e, 0x067e, 0x0d7e, 0x0f7e, 0x2029, 0x0001,
+	0xa182, 0x0101, 0x00c8, 0x8986, 0x0078, 0x8988, 0x2009, 0x0100,
+	0x2130, 0x2069, 0xab98, 0x831c, 0x2300, 0xad18, 0x2009, 0x0020,
+	0xaf90, 0x001d, 0x1078, 0x89e2, 0xa6b2, 0x0020, 0x7804, 0xa06d,
+	0x0040, 0x899c, 0x1078, 0x13b4, 0x1078, 0x138b, 0x0040, 0x89c6,
+	0x8528, 0x6837, 0x0110, 0x683b, 0x0000, 0x2d20, 0x7c06, 0xa68a,
+	0x003d, 0x00c8, 0x89b2, 0x2608, 0xad90, 0x000f, 0x1078, 0x89e2,
+	0x0078, 0x89c6, 0xa6b2, 0x003c, 0x2009, 0x003c, 0x2d78, 0xad90,
+	0x000f, 0x1078, 0x89e2, 0x0078, 0x899c, 0x0f7f, 0x852f, 0xa5ad,
+	0x0003, 0x7d36, 0xa5ac, 0x0000, 0x0078, 0x89cb, 0x0f7f, 0x852f,
+	0xa5ad, 0x0003, 0x7d36, 0x0d7f, 0x067f, 0x057f, 0x007c, 0x0f7e,
+	0x8dff, 0x0040, 0x89e0, 0x6804, 0xa07d, 0x0040, 0x89de, 0x6807,
+	0x0000, 0x1078, 0x4a73, 0x2f68, 0x0078, 0x89d3, 0x1078, 0x4a73,
+	0x0f7f, 0x007c, 0x157e, 0xa184, 0x0001, 0x0040, 0x89e8, 0x8108,
+	0x810c, 0x21a8, 0x2304, 0x8007, 0x2012, 0x8318, 0x8210, 0x00f0,
+	0x89ea, 0x157f, 0x007c, 0x067e, 0x127e, 0x2091, 0x8000, 0x2031,
+	0x0001, 0x601c, 0xa084, 0x000f, 0x1079, 0x8a0f, 0x127f, 0x067f,
+	0x007c, 0x127e, 0x2091, 0x8000, 0x067e, 0x2031, 0x0000, 0x601c,
+	0xa084, 0x000f, 0x1079, 0x8a0f, 0x067f, 0x127f, 0x007c, 0x8a29,
+	0x8a17, 0x8a24, 0x8a45, 0x8a17, 0x8a24, 0x8a45, 0x8a24, 0x1078,
+	0x1332, 0x037e, 0x2019, 0x0010, 0x1078, 0x9dc7, 0x601f, 0x0006,
+	0x6003, 0x0007, 0x037f, 0x007c, 0xa006, 0x007c, 0xa085, 0x0001,
+	0x007c, 0x0d7e, 0x86ff, 0x00c0, 0x8a40, 0x6010, 0x2068, 0x1078,
+	0x8d06, 0x0040, 0x8a42, 0xa00e, 0x2001, 0x0005, 0x1078, 0x4b51,
+	0x1078, 0x8f85, 0x1078, 0x4a73, 0x1078, 0x772d, 0xa085, 0x0001,
+	0x0d7f, 0x007c, 0xa006, 0x0078, 0x8a40, 0x6000, 0xa08a, 0x0010,
+	0x10c8, 0x1332, 0x1079, 0x8a4d, 0x007c, 0x8a5d, 0x8a82, 0x8a5f,
+	0x8aa5, 0x8a7e, 0x8a5d, 0x8a24, 0x8a29, 0x8a29, 0x8a24, 0x8a24,
+	0x8a24, 0x8a24, 0x8a24, 0x8a24, 0x8a24, 0x1078, 0x1332, 0x86ff,
+	0x00c0, 0x8a7b, 0x601c, 0xa086, 0x0006, 0x0040, 0x8a7b, 0x0d7e,
+	0x6010, 0x2068, 0x1078, 0x8d06, 0x0040, 0x8a70, 0x1078, 0x8f85,
+	0x0d7f, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x1078,
+	0x5d8a, 0x1078, 0x62d1, 0xa085, 0x0001, 0x007c, 0x1078, 0x1757,
+	0x0078, 0x8a5f, 0x0e7e, 0x2071, 0xa8b1, 0x7024, 0xac06, 0x00c0,
+	0x8a8b, 0x1078, 0x6fc4, 0x601c, 0xa084, 0x000f, 0xa086, 0x0006,
+	0x00c0, 0x8a9d, 0x087e, 0x097e, 0x2049, 0x0001, 0x2c40, 0x1078,
+	0x7246, 0x097f, 0x087f, 0x0078, 0x8a9f, 0x1078, 0x6ebe, 0x0e7f,
+	0x00c0, 0x8a5f, 0x1078, 0x8a24, 0x007c, 0x037e, 0x0e7e, 0x2071,
+	0xa8b1, 0x703c, 0xac06, 0x00c0, 0x8ab5, 0x2019, 0x0000, 0x1078,
+	0x7058, 0x0e7f, 0x037f, 0x0078, 0x8a5f, 0x1078, 0x738a, 0x0e7f,
+	0x037f, 0x00c0, 0x8a5f, 0x1078, 0x8a24, 0x007c, 0x0c7e, 0x601c,
+	0xa084, 0x000f, 0x1079, 0x8ac6, 0x0c7f, 0x007c, 0x8ad5, 0x8b47,
+	0x8c7f, 0x8ae0, 0x8ec6, 0x8ad5, 0x9db8, 0x772d, 0x8b47, 0x1078,
+	0x8f00, 0x00c0, 0x8ad5, 0x1078, 0x7c83, 0x007c, 0x1078, 0x61cd,
+	0x1078, 0x62d1, 0x1078, 0x772d, 0x007c, 0x6017, 0x0001, 0x007c,
+	0x1078, 0x8d06, 0x0040, 0x8ae8, 0x6010, 0xa080, 0x0019, 0x2c02,
+	0x6000, 0xa08a, 0x0010, 0x10c8, 0x1332, 0x1079, 0x8af0, 0x007c,
+	0x8b00, 0x8b02, 0x8b24, 0x8b36, 0x8b43, 0x8b00, 0x8ad5, 0x8ad5,
+	0x8ad5, 0x8b36, 0x8b36, 0x8b00, 0x8b00, 0x8b00, 0x8b00, 0x8b40,
+	0x1078, 0x1332, 0x0e7e, 0x6010, 0x2070, 0x7050, 0xc0b5, 0x7052,
+	0x2071, 0xa8b1, 0x7024, 0xac06, 0x0040, 0x8b20, 0x1078, 0x6ebe,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x2001, 0xa8a3,
+	0x2004, 0x6016, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0e7f, 0x007c,
+	0x6017, 0x0001, 0x0078, 0x8b1e, 0x0d7e, 0x6010, 0x2068, 0x6850,
+	0xc0b5, 0x6852, 0x0d7f, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f,
+	0x0002, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x007c, 0x0d7e, 0x6017,
+	0x0001, 0x6010, 0x2068, 0x6850, 0xc0b5, 0x6852, 0x0d7f, 0x007c,
+	0x1078, 0x772d, 0x007c, 0x1078, 0x1757, 0x0078, 0x8b24, 0x6000,
+	0xa08a, 0x0010, 0x10c8, 0x1332, 0x1079, 0x8b4f, 0x007c, 0x8b5f,
+	0x8add, 0x8b61, 0x8b5f, 0x8b61, 0x8b61, 0x8ad6, 0x8b5f, 0x8acf,
+	0x8acf, 0x8b5f, 0x8b5f, 0x8b5f, 0x8b5f, 0x8b5f, 0x8b5f, 0x1078,
+	0x1332, 0x0d7e, 0x6018, 0x2068, 0x6804, 0xa084, 0x00ff, 0x0d7f,
+	0xa08a, 0x000c, 0x10c8, 0x1332, 0x1079, 0x8b6f, 0x007c, 0x8b7b,
+	0x8c23, 0x8b7d, 0x8bbd, 0x8b7d, 0x8bbd, 0x8b7d, 0x8b8a, 0x8b7b,
+	0x8bbd, 0x8b7b, 0x8ba7, 0x1078, 0x1332, 0x6004, 0xa08e, 0x0016,
+	0x0040, 0x8bb8, 0xa08e, 0x0004, 0x0040, 0x8bb8, 0xa08e, 0x0002,
+	0x0040, 0x8bb8, 0x6004, 0x1078, 0x8f00, 0x0040, 0x8c3e, 0xa08e,
+	0x0021, 0x0040, 0x8c42, 0xa08e, 0x0022, 0x0040, 0x8c3e, 0xa08e,
+	0x003d, 0x0040, 0x8c42, 0xa08e, 0x0039, 0x0040, 0x8c46, 0xa08e,
+	0x0035, 0x0040, 0x8c46, 0xa08e, 0x001e, 0x0040, 0x8bba, 0xa08e,
+	0x0001, 0x00c0, 0x8bb6, 0x0d7e, 0x6018, 0x2068, 0x6804, 0xa084,
+	0x00ff, 0x0d7f, 0xa086, 0x0006, 0x0040, 0x8bb8, 0x1078, 0x2880,
+	0x1078, 0x7c83, 0x1078, 0x8ec6, 0x007c, 0x0c7e, 0x0d7e, 0x6104,
+	0xa186, 0x0016, 0x0040, 0x8c13, 0xa186, 0x0002, 0x00c0, 0x8be6,
+	0x6018, 0x2068, 0x68a0, 0xd0bc, 0x00c0, 0x8c6a, 0x6840, 0xa084,
+	0x00ff, 0xa005, 0x0040, 0x8be6, 0x8001, 0x6842, 0x6013, 0x0000,
+	0x601f, 0x0007, 0x6017, 0x0398, 0x1078, 0x76c7, 0x0040, 0x8be6,
+	0x2d00, 0x601a, 0x601f, 0x0001, 0x0078, 0x8c13, 0x0d7f, 0x0c7f,
+	0x6004, 0xa08e, 0x0002, 0x00c0, 0x8c04, 0x6018, 0xa080, 0x0028,
+	0x2004, 0xa086, 0x007e, 0x00c0, 0x8c04, 0x2009, 0xa633, 0x2104,
+	0xc085, 0x200a, 0x0e7e, 0x2071, 0xa600, 0x1078, 0x42b8, 0x0e7f,
+	0x1078, 0x7c83, 0x0078, 0x8c08, 0x1078, 0x7c83, 0x1078, 0x2880,
+	0x0e7e, 0x127e, 0x2091, 0x8000, 0x1078, 0x28a6, 0x127f, 0x0e7f,
+	0x1078, 0x8ec6, 0x007c, 0x2001, 0x0002, 0x1078, 0x4502, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x1078, 0x5dd7, 0x1078, 0x62d1, 0x0d7f,
+	0x0c7f, 0x0078, 0x8c12, 0x0c7e, 0x0d7e, 0x6104, 0xa186, 0x0016,
+	0x0040, 0x8c13, 0x6018, 0x2068, 0x6840, 0xa084, 0x00ff, 0xa005,
+	0x0040, 0x8be6, 0x8001, 0x6842, 0x6003, 0x0001, 0x1078, 0x5dd7,
+	0x1078, 0x62d1, 0x0d7f, 0x0c7f, 0x0078, 0x8c12, 0x1078, 0x7c83,
+	0x0078, 0x8bba, 0x1078, 0x7ca6, 0x0078, 0x8bba, 0x0d7e, 0x2c68,
+	0x6104, 0x1078, 0x91bc, 0x0d7f, 0x0040, 0x8c52, 0x1078, 0x772d,
+	0x0078, 0x8c69, 0x6004, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105,
+	0x6032, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x6038,
+	0x600a, 0x2001, 0xa8a3, 0x2004, 0x6016, 0x1078, 0x5d8a, 0x1078,
+	0x62d1, 0x007c, 0x0d7f, 0x0c7f, 0x1078, 0x7c83, 0x1078, 0x2880,
+	0x0e7e, 0x127e, 0x2091, 0x8000, 0x1078, 0x28a6, 0x6013, 0x0000,
+	0x601f, 0x0007, 0x6017, 0x0398, 0x127f, 0x0e7f, 0x007c, 0x6000,
+	0xa08a, 0x0010, 0x10c8, 0x1332, 0x1079, 0x8c87, 0x007c, 0x8c97,
+	0x8c97, 0x8c97, 0x8c97, 0x8c97, 0x8c97, 0x8c97, 0x8c97, 0x8c97,
+	0x8ad5, 0x8c97, 0x8add, 0x8c99, 0x8add, 0x8ca7, 0x8c97, 0x1078,
+	0x1332, 0x6004, 0xa086, 0x008b, 0x0040, 0x8ca7, 0x6007, 0x008b,
+	0x6003, 0x000d, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x007c, 0x1078,
+	0x8eb9, 0x1078, 0x8d06, 0x0040, 0x8cdf, 0x1078, 0x2880, 0x0d7e,
+	0x1078, 0x8d06, 0x0040, 0x8cc1, 0x6010, 0x2068, 0x6837, 0x0103,
+	0x684b, 0x0006, 0x6847, 0x0000, 0x6850, 0xc0ed, 0x6852, 0x1078,
+	0x4a73, 0x2c68, 0x1078, 0x76c7, 0x0040, 0x8ccf, 0x6818, 0x601a,
+	0x0c7e, 0x2d60, 0x1078, 0x8ec6, 0x0c7f, 0x0078, 0x8cd0, 0x2d60,
+	0x0d7f, 0x6013, 0x0000, 0x601f, 0x0001, 0x6007, 0x0001, 0x6003,
+	0x0001, 0x1078, 0x5dd7, 0x1078, 0x62d1, 0x0078, 0x8cf1, 0x6030,
+	0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0040, 0x8ceb, 0xa186,
+	0x0035, 0x00c0, 0x8cef, 0x1078, 0x2880, 0x0078, 0x8cc1, 0x1078,
+	0x8ec6, 0x007c, 0xa284, 0x000f, 0x00c0, 0x8d03, 0xa282, 0xad00,
+	0x0048, 0x8d03, 0x2001, 0xa616, 0x2004, 0xa202, 0x00c8, 0x8d03,
+	0xa085, 0x0001, 0x007c, 0xa006, 0x0078, 0x8d02, 0x027e, 0x0e7e,
+	0x2071, 0xa600, 0x6210, 0x705c, 0xa202, 0x0048, 0x8d18, 0x7060,
+	0xa202, 0x00c8, 0x8d18, 0xa085, 0x0001, 0x0e7f, 0x027f, 0x007c,
+	0xa006, 0x0078, 0x8d15, 0x0e7e, 0x0c7e, 0x037e, 0x007e, 0x127e,
+	0x2091, 0x8000, 0x2061, 0xad00, 0x2071, 0xa600, 0x7348, 0x7064,
+	0xa302, 0x00c8, 0x8d45, 0x601c, 0xa206, 0x00c0, 0x8d3d, 0x1078,
+	0x902b, 0x0040, 0x8d3d, 0x1078, 0x8f00, 0x00c0, 0x8d39, 0x1078,
+	0x7c83, 0x0c7e, 0x1078, 0x772d, 0x0c7f, 0xace0, 0x0010, 0x7058,
+	0xac02, 0x00c8, 0x8d45, 0x0078, 0x8d26, 0x127f, 0x007f, 0x037f,
+	0x0c7f, 0x0e7f, 0x007c, 0x0e7e, 0x0c7e, 0x017e, 0xa188, 0xa735,
+	0x210c, 0x81ff, 0x0040, 0x8d59, 0x2061, 0xa9b3, 0x611a, 0x1078,
+	0x2880, 0xa006, 0x0078, 0x8d5e, 0xa085, 0x0001, 0x017f, 0x0c7f,
+	0x0e7f, 0x007c, 0x0c7e, 0x057e, 0x127e, 0x2091, 0x8000, 0x0c7e,
+	0x1078, 0x76c7, 0x057f, 0x0040, 0x8d7b, 0x6612, 0x651a, 0x601f,
+	0x0003, 0x2009, 0x004b, 0x1078, 0x775c, 0xa085, 0x0001, 0x127f,
+	0x057f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x8d77, 0x0c7e, 0x057e,
+	0x127e, 0x2091, 0x8000, 0x62a0, 0x0c7e, 0x1078, 0x76c7, 0x057f,
+	0x0040, 0x8da9, 0x6013, 0x0000, 0x651a, 0x601f, 0x0003, 0x0c7e,
+	0x2560, 0x1078, 0x47e9, 0x0c7f, 0x1078, 0x5f01, 0x077e, 0x2039,
+	0x0000, 0x1078, 0x5e0a, 0x2c08, 0x1078, 0x9f8b, 0x077f, 0x2009,
+	0x004c, 0x1078, 0x775c, 0xa085, 0x0001, 0x127f, 0x057f, 0x0c7f,
+	0x007c, 0xa006, 0x0078, 0x8da5, 0x0f7e, 0x0c7e, 0x047e, 0x0c7e,
+	0x1078, 0x76c7, 0x2c78, 0x0c7f, 0x0040, 0x8dc6, 0x7e12, 0x2c00,
+	0x781a, 0x781f, 0x0003, 0x2021, 0x0005, 0x1078, 0x8e11, 0x2f60,
+	0x2009, 0x004d, 0x1078, 0x775c, 0xa085, 0x0001, 0x047f, 0x0c7f,
+	0x0f7f, 0x007c, 0x0f7e, 0x0c7e, 0x047e, 0x0c7e, 0x1078, 0x76c7,
+	0x2c78, 0x0c7f, 0x0040, 0x8de4, 0x7e12, 0x2c00, 0x781a, 0x781f,
+	0x0003, 0x2021, 0x0005, 0x1078, 0x8e11, 0x2f60, 0x2009, 0x004e,
+	0x1078, 0x775c, 0xa085, 0x0001, 0x047f, 0x0c7f, 0x0f7f, 0x007c,
+	0x0f7e, 0x0c7e, 0x047e, 0x0c7e, 0x1078, 0x76c7, 0x2c78, 0x0c7f,
+	0x0040, 0x8e0d, 0x7e12, 0x2c00, 0x781a, 0x781f, 0x0003, 0x2021,
+	0x0004, 0x1078, 0x8e11, 0x2001, 0xa89d, 0x2004, 0xd0fc, 0x0040,
+	0x8e06, 0x2f60, 0x1078, 0x772d, 0x0078, 0x8e0b, 0x2f60, 0x2009,
+	0x0052, 0x1078, 0x775c, 0xa085, 0x0001, 0x047f, 0x0c7f, 0x0f7f,
+	0x007c, 0x097e, 0x077e, 0x127e, 0x2091, 0x8000, 0x1078, 0x4775,
+	0x0040, 0x8e1e, 0x2001, 0x8e16, 0x0078, 0x8e24, 0x1078, 0x4739,
+	0x0040, 0x8e2d, 0x2001, 0x8e1e, 0x007e, 0xa00e, 0x2400, 0x1078,
+	0x4b51, 0x1078, 0x4a73, 0x007f, 0x007a, 0x2418, 0x1078, 0x6161,
+	0x62a0, 0x087e, 0x2041, 0x0001, 0x2039, 0x0001, 0x2608, 0x1078,
+	0x5f1b, 0x087f, 0x1078, 0x5e0a, 0x2f08, 0x2648, 0x1078, 0x9f8b,
+	0x613c, 0x81ff, 0x1040, 0x5fdb, 0x1078, 0x62d1, 0x127f, 0x077f,
+	0x097f, 0x007c, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078,
+	0x76c7, 0x017f, 0x0040, 0x8e63, 0x660a, 0x611a, 0x601f, 0x0001,
+	0x2d00, 0x6012, 0x2009, 0x001f, 0x1078, 0x775c, 0xa085, 0x0001,
+	0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x8e60, 0x0c7e, 0x127e,
+	0x2091, 0x8000, 0x0c7e, 0x1078, 0x76c7, 0x017f, 0x0040, 0x8e7f,
+	0x660a, 0x611a, 0x601f, 0x0008, 0x2d00, 0x6012, 0x2009, 0x0021,
+	0x1078, 0x775c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006,
+	0x0078, 0x8e7c, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078,
+	0x76c7, 0x017f, 0x0040, 0x8e9b, 0x660a, 0x611a, 0x601f, 0x0001,
+	0x2d00, 0x6012, 0x2009, 0x003d, 0x1078, 0x775c, 0xa085, 0x0001,
+	0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x8e98, 0x0c7e, 0x127e,
+	0x2091, 0x8000, 0x0c7e, 0x1078, 0x76c7, 0x017f, 0x0040, 0x8eb6,
+	0x611a, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0000, 0x1078,
+	0x775c, 0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078,
+	0x8eb3, 0x027e, 0x0d7e, 0x6218, 0x2268, 0x6a3c, 0x82ff, 0x0040,
+	0x8ec3, 0x8211, 0x6a3e, 0x0d7f, 0x027f, 0x007c, 0x007e, 0x6000,
+	0xa086, 0x0000, 0x0040, 0x8ed8, 0x6013, 0x0000, 0x601f, 0x0007,
+	0x2001, 0xa8a3, 0x2004, 0x6016, 0x1078, 0xa495, 0x603f, 0x0000,
+	0x007f, 0x007c, 0x067e, 0x0c7e, 0x0d7e, 0x2031, 0xa653, 0x2634,
+	0xd6e4, 0x0040, 0x8ee8, 0x6618, 0x2660, 0x6e48, 0x1078, 0x46e7,
+	0x0d7f, 0x0c7f, 0x067f, 0x007c, 0x007e, 0x017e, 0x6004, 0xa08e,
+	0x0002, 0x0040, 0x8efd, 0xa08e, 0x0003, 0x0040, 0x8efd, 0xa08e,
+	0x0004, 0x0040, 0x8efd, 0xa085, 0x0001, 0x017f, 0x007f, 0x007c,
+	0x007e, 0x0d7e, 0x6010, 0xa06d, 0x0040, 0x8f0d, 0x6838, 0xd0fc,
+	0x0040, 0x8f0d, 0xa006, 0x0078, 0x8f0f, 0xa085, 0x0001, 0x0d7f,
+	0x007f, 0x007c, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078,
+	0x76c7, 0x017f, 0x0040, 0x8f2c, 0x611a, 0x601f, 0x0001, 0x2d00,
+	0x6012, 0x1078, 0x2880, 0x2009, 0x0028, 0x1078, 0x775c, 0xa085,
+	0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x8f29, 0xa186,
+	0x0015, 0x00c0, 0x8f44, 0x2011, 0xa620, 0x2204, 0xa086, 0x0074,
+	0x00c0, 0x8f44, 0x1078, 0x7f91, 0x6003, 0x0001, 0x6007, 0x0029,
+	0x1078, 0x5dd7, 0x0078, 0x8f48, 0x1078, 0x7c83, 0x1078, 0x772d,
+	0x007c, 0xa186, 0x0016, 0x00c0, 0x8f53, 0x2001, 0x0004, 0x1078,
+	0x4502, 0x0078, 0x8f74, 0xa186, 0x0015, 0x00c0, 0x8f78, 0x2011,
+	0xa620, 0x2204, 0xa086, 0x0014, 0x00c0, 0x8f78, 0x0d7e, 0x6018,
+	0x2068, 0x1078, 0x4649, 0x0d7f, 0x1078, 0x8043, 0x00c0, 0x8f78,
+	0x0d7e, 0x6018, 0x2068, 0x6890, 0x0d7f, 0xa005, 0x0040, 0x8f78,
+	0x2001, 0x0006, 0x1078, 0x4502, 0x1078, 0x77f8, 0x0078, 0x8f7c,
+	0x1078, 0x7c83, 0x1078, 0x772d, 0x007c, 0x6848, 0xa086, 0x0005,
+	0x00c0, 0x8f84, 0x1078, 0x8f85, 0x007c, 0x6850, 0xc0ad, 0x6852,
+	0x007c, 0x0e7e, 0x2071, 0xab8c, 0x7014, 0xd0e4, 0x0040, 0x8f9a,
+	0x6013, 0x0000, 0x6003, 0x0001, 0x6007, 0x0050, 0x1078, 0x5d8a,
+	0x1078, 0x62d1, 0x0e7f, 0x007c, 0x0c7e, 0x0f7e, 0x2c78, 0x1078,
+	0x4963, 0x0f7f, 0x0040, 0x8fa9, 0x601c, 0xa084, 0x000f, 0x1079,
+	0x8fab, 0x0c7f, 0x007c, 0x8ad5, 0x8fb6, 0x8fb9, 0x8fbc, 0xa25d,
+	0xa279, 0xa27c, 0x8ad5, 0x8ad5, 0x1078, 0x1332, 0x0005, 0x0005,
+	0x007c, 0x0005, 0x0005, 0x007c, 0x1078, 0x8fbf, 0x007c, 0x0f7e,
+	0x2c78, 0x1078, 0x4963, 0x0040, 0x8fee, 0x1078, 0x76c7, 0x00c0,
+	0x8fcf, 0x2001, 0xa8a4, 0x2004, 0x783e, 0x0078, 0x8fee, 0x7818,
+	0x601a, 0x781c, 0xa086, 0x0003, 0x0040, 0x8fdc, 0x7808, 0x6036,
+	0x2f00, 0x603a, 0x0078, 0x8fe0, 0x7808, 0x603a, 0x2f00, 0x6036,
+	0x602a, 0x601f, 0x0001, 0x6007, 0x0035, 0x6003, 0x0001, 0x7920,
+	0x6122, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x2f60, 0x0f7f, 0x007c,
+	0x017e, 0x0f7e, 0x682c, 0x6032, 0xa08e, 0x0001, 0x0040, 0x9001,
+	0xa086, 0x0005, 0x0040, 0x9005, 0xa006, 0x602a, 0x602e, 0x0078,
+	0x9016, 0x6824, 0xc0f4, 0xc0d5, 0x6826, 0x6810, 0x2078, 0x787c,
+	0x6938, 0xa102, 0x7880, 0x6934, 0xa103, 0x00c8, 0x8ffc, 0x6834,
+	0x602a, 0x6838, 0xa084, 0xfffc, 0x683a, 0x602e, 0x2d00, 0x6036,
+	0x6808, 0x603a, 0x6918, 0x611a, 0x6920, 0x6122, 0x601f, 0x0001,
+	0x6007, 0x0039, 0x6003, 0x0001, 0x1078, 0x5d8a, 0x6803, 0x0002,
+	0x0f7f, 0x017f, 0x007c, 0x007e, 0x017e, 0x6004, 0xa08e, 0x0034,
+	0x0040, 0x9050, 0xa08e, 0x0035, 0x0040, 0x9050, 0xa08e, 0x0036,
+	0x0040, 0x9050, 0xa08e, 0x0037, 0x0040, 0x9050, 0xa08e, 0x0038,
+	0x0040, 0x9050, 0xa08e, 0x0039, 0x0040, 0x9050, 0xa08e, 0x003a,
+	0x0040, 0x9050, 0xa08e, 0x003b, 0x0040, 0x9050, 0xa085, 0x0001,
+	0x017f, 0x007f, 0x007c, 0x0f7e, 0x2c78, 0x1078, 0x4963, 0x00c0,
+	0x905d, 0xa085, 0x0001, 0x0078, 0x906c, 0x6024, 0xd0f4, 0x00c0,
+	0x906b, 0xc0f5, 0x6026, 0x6010, 0x2078, 0x7828, 0x603a, 0x782c,
+	0x6036, 0x1078, 0x1757, 0xa006, 0x0f7f, 0x007c, 0x007e, 0x017e,
+	0x027e, 0x037e, 0x0e7e, 0x2001, 0xa89e, 0x200c, 0x8000, 0x2014,
+	0x2001, 0x0032, 0x1078, 0x5c1c, 0x2001, 0xa8a2, 0x82ff, 0x00c0,
+	0x9083, 0x2011, 0x0014, 0x2202, 0x2001, 0xa8a0, 0x200c, 0x8000,
+	0x2014, 0x2071, 0xa88d, 0x711a, 0x721e, 0x2001, 0x0064, 0x1078,
+	0x5c1c, 0x2001, 0xa8a3, 0x82ff, 0x00c0, 0x9098, 0x2011, 0x0014,
+	0x2202, 0x2009, 0xa8a4, 0xa280, 0x000a, 0x200a, 0x1078, 0x498b,
+	0x0e7f, 0x037f, 0x027f, 0x017f, 0x007f, 0x007c, 0x007e, 0x0e7e,
+	0x2001, 0xa8a2, 0x2003, 0x0028, 0x2001, 0xa8a3, 0x2003, 0x0014,
+	0x2071, 0xa88d, 0x701b, 0x0000, 0x701f, 0x07d0, 0x2001, 0xa8a4,
+	0x2003, 0x001e, 0x0e7f, 0x007f, 0x007c, 0x0c7e, 0x127e, 0x2091,
+	0x8000, 0x0c7e, 0x1078, 0x76c7, 0x017f, 0x0040, 0x90d5, 0x611a,
+	0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0033, 0x1078, 0x775c,
+	0xa085, 0x0001, 0x127f, 0x0c7f, 0x007c, 0xa006, 0x0078, 0x90d2,
+	0x0d7e, 0x0e7e, 0x0f7e, 0x2071, 0xa600, 0xa186, 0x0015, 0x00c0,
+	0x9107, 0x7080, 0xa086, 0x0018, 0x00c0, 0x9107, 0x6010, 0x2068,
+	0x6a3c, 0xd2e4, 0x00c0, 0x90fb, 0x2c78, 0x1078, 0x6490, 0x0040,
+	0x910f, 0x706c, 0x6a50, 0xa206, 0x00c0, 0x9103, 0x7070, 0x6a54,
+	0xa206, 0x00c0, 0x9103, 0x6218, 0xa290, 0x0028, 0x2214, 0x2009,
+	0x0000, 0x1078, 0x28c8, 0x1078, 0x77f8, 0x0078, 0x910b, 0x1078,
+	0x7c83, 0x1078, 0x772d, 0x0f7f, 0x0e7f, 0x0d7f, 0x007c, 0x7050,
+	0xa080, 0x29c0, 0x2004, 0x6a54, 0xa206, 0x0040, 0x90fb, 0x0078,
+	0x9103, 0x0c7e, 0x127e, 0x2091, 0x8000, 0x0c7e, 0x1078, 0x76c7,
+	0x017f, 0x0040, 0x9131, 0x611a, 0x601f, 0x0001, 0x2d00, 0x6012,
+	0x2009, 0x0043, 0x1078, 0x775c, 0xa085, 0x0001, 0x127f, 0x0c7f,
+	0x007c, 0xa006, 0x0078, 0x912e, 0x0d7e, 0x0e7e, 0x0f7e, 0x2071,
+	0xa600, 0xa186, 0x0015, 0x00c0, 0x915a, 0x7080, 0xa086, 0x0004,
+	0x00c0, 0x915a, 0x6010, 0xa0e8, 0x000f, 0x2c78, 0x1078, 0x6490,
+	0x0040, 0x9162, 0x706c, 0x6a08, 0xa206, 0x00c0, 0x9156, 0x7070,
+	0x6a0c, 0xa206, 0x00c0, 0x9156, 0x1078, 0x2880, 0x1078, 0x77f8,
+	0x0078, 0x915e, 0x1078, 0x7c83, 0x1078, 0x772d, 0x0f7f, 0x0e7f,
+	0x0d7f, 0x007c, 0x7050, 0xa080, 0x29c0, 0x2004, 0x6a0c, 0xa206,
+	0x0040, 0x9154, 0x0078, 0x9156, 0x017e, 0x027e, 0x684c, 0xd0ac,
+	0x0040, 0x9184, 0x6914, 0x6a10, 0x2100, 0xa205, 0x0040, 0x9184,
+	0x6860, 0xa106, 0x00c0, 0x9180, 0x685c, 0xa206, 0x0040, 0x9184,
+	0x6962, 0x6a5e, 0xa085, 0x0001, 0x027f, 0x017f, 0x007c, 0x0e7e,
+	0x127e, 0x2071, 0xa600, 0x2091, 0x8000, 0x7548, 0xa582, 0x0001,
+	0x0048, 0x91b9, 0x704c, 0x2060, 0x6000, 0xa086, 0x0000, 0x0040,
+	0x91a5, 0xace0, 0x0010, 0x7058, 0xac02, 0x00c8, 0x91a1, 0x0078,
+	0x9194, 0x2061, 0xad00, 0x0078, 0x9194, 0x6003, 0x0008, 0x8529,
+	0x754a, 0xaca8, 0x0010, 0x7058, 0xa502, 0x00c8, 0x91b5, 0x754e,
+	0xa085, 0x0001, 0x127f, 0x0e7f, 0x007c, 0x704f, 0xad00, 0x0078,
+	0x91b0, 0xa006, 0x0078, 0x91b2, 0x0c7e, 0x027e, 0x017e, 0xa186,
+	0x0035, 0x0040, 0x91c6, 0x6a34, 0x0078, 0x91c7, 0x6a28, 0x1078,
+	0x8cf2, 0x0040, 0x91f0, 0x2260, 0x611c, 0xa186, 0x0003, 0x0040,
+	0x91d5, 0xa186, 0x0006, 0x00c0, 0x91ec, 0x6834, 0xa206, 0x0040,
+	0x91e4, 0x6838, 0xa206, 0x00c0, 0x91ec, 0x6108, 0x6834, 0xa106,
+	0x00c0, 0x91ec, 0x0078, 0x91e9, 0x6008, 0x6938, 0xa106, 0x00c0,
+	0x91ec, 0x6018, 0x6918, 0xa106, 0x017f, 0x027f, 0x0c7f, 0x007c,
+	0xa085, 0x0001, 0x0078, 0x91ec, 0x6944, 0xd1cc, 0x0040, 0x920d,
+	0xa18c, 0x00ff, 0xa18e, 0x0002, 0x00c0, 0x920d, 0xad88, 0x001e,
+	0x210c, 0xa18c, 0x0f00, 0x810f, 0xa18e, 0x0001, 0x00c0, 0x920d,
+	0x6810, 0x6914, 0xa115, 0x10c0, 0x84d5, 0x007c, 0x067e, 0x6000,
+	0xa0b2, 0x0010, 0x10c8, 0x1332, 0x1079, 0x9218, 0x067f, 0x007c,
+	0x9228, 0x96df, 0x97fb, 0x9228, 0x9228, 0x9228, 0x9228, 0x9228,
+	0x9262, 0x988e, 0x9228, 0x9228, 0x9228, 0x9228, 0x9228, 0x9228,
+	0x1078, 0x1332, 0x067e, 0x6000, 0xa0b2, 0x0010, 0x10c8, 0x1332,
+	0x1079, 0x9234, 0x067f, 0x007c, 0x9244, 0x9d53, 0x9244, 0x9244,
+	0x9244, 0x9244, 0x9244, 0x9244, 0x9d11, 0x9da1, 0x9244, 0xa3b0,
+	0xa3e4, 0xa3b0, 0xa3e4, 0x9244, 0x1078, 0x1332, 0x067e, 0x6000,
+	0xa0b2, 0x0010, 0x10c8, 0x1332, 0x1079, 0x9250, 0x067f, 0x007c,
+	0x9260, 0x99eb, 0x9ac7, 0x9af5, 0x9b70, 0x9260, 0x9c76, 0x9c1e,
+	0x989a, 0x9ce5, 0x9cfb, 0x9260, 0x9260, 0x9260, 0x9260, 0x9260,
+	0x1078, 0x1332, 0xa1b2, 0x0044, 0x10c8, 0x1332, 0x2100, 0x0079,
+	0x9269, 0x92a9, 0x9498, 0x92a9, 0x92a9, 0x92a9, 0x94a0, 0x92a9,
+	0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9,
+	0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9,
+	0x92ab, 0x9311, 0x9320, 0x9377, 0x9396, 0x9415, 0x9485, 0x92a9,
+	0x92a9, 0x94a4, 0x92a9, 0x92a9, 0x94b7, 0x94c2, 0x92a9, 0x92a9,
+	0x92a9, 0x92a9, 0x92a9, 0x94fa, 0x92a9, 0x92a9, 0x9509, 0x92a9,
+	0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x9522, 0x92a9, 0x92a9,
+	0x92a9, 0x95af, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9, 0x92a9,
+	0x9629, 0x1078, 0x1332, 0x1078, 0x4967, 0x00c0, 0x92bb, 0x2001,
+	0xa633, 0x2004, 0xd0cc, 0x00c0, 0x92bb, 0xa084, 0x0009, 0xa086,
+	0x0008, 0x00c0, 0x92c3, 0x6007, 0x0009, 0x602b, 0x0009, 0x6013,
+	0x0000, 0x0078, 0x9493, 0x1078, 0x4957, 0x0e7e, 0x0c7e, 0x037e,
+	0x027e, 0x017e, 0x6218, 0x2270, 0x72a0, 0x027e, 0x2019, 0x0029,
+	0x1078, 0x5f01, 0x077e, 0x2039, 0x0000, 0x1078, 0x5e0a, 0x2c08,
+	0x1078, 0x9f8b, 0x077f, 0x017f, 0x2e60, 0x1078, 0x47e9, 0x017f,
+	0x027f, 0x037f, 0x0c7f, 0x0e7f, 0x6618, 0x0c7e, 0x2660, 0x1078,
+	0x45d6, 0x0c7f, 0xa6b0, 0x0001, 0x2634, 0xa684, 0x00ff, 0xa082,
+	0x0006, 0x0048, 0x9303, 0x1078, 0x9ebf, 0x00c0, 0x9371, 0x1078,
+	0x9e50, 0x00c0, 0x92ff, 0x6007, 0x0008, 0x0078, 0x9493, 0x6007,
+	0x0009, 0x0078, 0x9493, 0x1078, 0xa09f, 0x0040, 0x930d, 0x1078,
+	0x9ebf, 0x0040, 0x92f7, 0x0078, 0x9371, 0x6013, 0x1900, 0x0078,
+	0x92ff, 0x1078, 0x29bb, 0x00c0, 0x9664, 0x6106, 0x1078, 0x9e05,
+	0x6007, 0x0006, 0x0078, 0x9493, 0x6007, 0x0007, 0x0078, 0x9493,
+	0x1078, 0xa41c, 0x00c0, 0x9664, 0x1078, 0x29bb, 0x00c0, 0x9664,
+	0x0d7e, 0x6618, 0x2668, 0x6e04, 0xa684, 0x00ff, 0xa082, 0x0006,
+	0x00c8, 0x9336, 0x2001, 0x0001, 0x1078, 0x44ee, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0006, 0x0040, 0x9353, 0xa686, 0x0004, 0x0040,
+	0x9353, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006, 0x0040, 0x9353,
+	0xa686, 0x0004, 0x0040, 0x9353, 0xa686, 0x0005, 0x0040, 0x9353,
+	0x0d7f, 0x0078, 0x9371, 0x1078, 0x9f25, 0x00c0, 0x936c, 0xa686,
+	0x0006, 0x00c0, 0x9365, 0x027e, 0x6218, 0xa290, 0x0028, 0x2214,
+	0x2009, 0x0000, 0x1078, 0x28c8, 0x027f, 0x1078, 0x4649, 0x6007,
+	0x000a, 0x0d7f, 0x0078, 0x9493, 0x6007, 0x000b, 0x0d7f, 0x0078,
+	0x9493, 0x1078, 0x2880, 0x6007, 0x0001, 0x0078, 0x9493, 0x1078,
+	0xa41c, 0x00c0, 0x9664, 0x1078, 0x29bb, 0x00c0, 0x9664, 0x6618,
+	0x0d7e, 0x2668, 0x6e04, 0x0d7f, 0xa686, 0x0707, 0x0040, 0x9371,
+	0x027e, 0x6218, 0xa290, 0x0028, 0x2214, 0x2009, 0x0000, 0x1078,
+	0x28c8, 0x027f, 0x6007, 0x000c, 0x0078, 0x9493, 0x1078, 0x4967,
+	0x00c0, 0x93a3, 0x2001, 0xa633, 0x2004, 0xa084, 0x0009, 0xa086,
+	0x0008, 0x00c0, 0x93ab, 0x6007, 0x0009, 0x602b, 0x0009, 0x6013,
+	0x0000, 0x0078, 0x9493, 0x1078, 0x4957, 0x6618, 0xa6b0, 0x0001,
+	0x2634, 0xa684, 0x00ff, 0xa082, 0x0006, 0x0048, 0x93ef, 0xa6b4,
+	0xff00, 0x8637, 0xa686, 0x0004, 0x0040, 0x93c2, 0xa686, 0x0006,
+	0x00c0, 0x9371, 0x1078, 0x9f34, 0x00c0, 0x93ca, 0x6007, 0x000e,
+	0x0078, 0x9493, 0x047e, 0x6418, 0xa4a0, 0x0028, 0x2424, 0xa4a4,
+	0x00ff, 0x8427, 0x047e, 0x1078, 0x2880, 0x047f, 0x017e, 0xa006,
+	0x2009, 0xa653, 0x210c, 0xd1a4, 0x0040, 0x93e9, 0x2009, 0x0029,
+	0x1078, 0xa21d, 0x6018, 0x0d7e, 0x2068, 0x6800, 0xc0e5, 0x6802,
+	0x0d7f, 0x017f, 0x047f, 0x6007, 0x0001, 0x0078, 0x9493, 0x2001,
+	0x0001, 0x1078, 0x44ee, 0x157e, 0x017e, 0x027e, 0x037e, 0x20a9,
+	0x0004, 0x2019, 0xa605, 0x2011, 0xab90, 0x1078, 0x80de, 0x037f,
+	0x027f, 0x017f, 0x157f, 0xa005, 0x0040, 0x940f, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0006, 0x0040, 0x93c2, 0x0078, 0x9371, 0x6013,
+	0x1900, 0x6007, 0x0009, 0x0078, 0x9493, 0x1078, 0x4967, 0x00c0,
+	0x9422, 0x2001, 0xa633, 0x2004, 0xa084, 0x0009, 0xa086, 0x0008,
+	0x00c0, 0x942a, 0x6007, 0x0009, 0x602b, 0x0009, 0x6013, 0x0000,
+	0x0078, 0x9493, 0x1078, 0x4957, 0x6618, 0xa6b0, 0x0001, 0x2634,
+	0xa684, 0x00ff, 0xa082, 0x0006, 0x0048, 0x9472, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0004, 0x0040, 0x9441, 0xa686, 0x0006, 0x00c0,
+	0x9371, 0x1078, 0x9f5f, 0x00c0, 0x944d, 0x1078, 0x9e50, 0x00c0,
+	0x944d, 0x6007, 0x0010, 0x0078, 0x9493, 0x047e, 0x6418, 0xa4a0,
+	0x0028, 0x2424, 0xa4a4, 0x00ff, 0x8427, 0x047e, 0x1078, 0x2880,
+	0x047f, 0x017e, 0xa006, 0x2009, 0xa653, 0x210c, 0xd1a4, 0x0040,
+	0x946c, 0x2009, 0x0029, 0x1078, 0xa21d, 0x6018, 0x0d7e, 0x2068,
+	0x6800, 0xc0e5, 0x6802, 0x0d7f, 0x017f, 0x047f, 0x6007, 0x0001,
+	0x0078, 0x9493, 0x1078, 0xa09f, 0x0040, 0x947f, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0006, 0x0040, 0x9441, 0x0078, 0x9371, 0x6013,
+	0x1900, 0x6007, 0x0009, 0x0078, 0x9493, 0x1078, 0x29bb, 0x00c0,
+	0x9664, 0x1078, 0xa41c, 0x00c0, 0x9664, 0x1078, 0x9667, 0x00c0,
+	0x9371, 0x6007, 0x0012, 0x6003, 0x0001, 0x1078, 0x5dd7, 0x007c,
+	0x6007, 0x0001, 0x6003, 0x0001, 0x1078, 0x5dd7, 0x0078, 0x9497,
+	0x6007, 0x0005, 0x0078, 0x949a, 0x1078, 0xa41c, 0x00c0, 0x9664,
+	0x1078, 0x29bb, 0x00c0, 0x9664, 0x1078, 0x9667, 0x00c0, 0x9371,
+	0x6007, 0x0020, 0x6003, 0x0001, 0x1078, 0x5dd7, 0x007c, 0x1078,
+	0x29bb, 0x00c0, 0x9664, 0x6007, 0x0023, 0x6003, 0x0001, 0x1078,
+	0x5dd7, 0x007c, 0x1078, 0xa41c, 0x00c0, 0x9664, 0x1078, 0x29bb,
+	0x00c0, 0x9664, 0x1078, 0x9667, 0x00c0, 0x9371, 0x017e, 0x027e,
+	0x2011, 0xab90, 0x2214, 0x2c08, 0xa006, 0x1078, 0xa1e6, 0x00c0,
+	0x94e9, 0x2160, 0x6007, 0x0026, 0x6013, 0x1700, 0x2011, 0xab89,
+	0x2214, 0xa296, 0xffff, 0x00c0, 0x94f3, 0x6007, 0x0025, 0x0078,
+	0x94f3, 0x6004, 0xa086, 0x0024, 0x00c0, 0x94f0, 0x1078, 0x772d,
+	0x2160, 0x6007, 0x0025, 0x6003, 0x0001, 0x1078, 0x5dd7, 0x027f,
+	0x017f, 0x007c, 0x1078, 0x29bb, 0x00c0, 0x9664, 0x6106, 0x1078,
+	0x9687, 0x6007, 0x002b, 0x0078, 0x9493, 0x6007, 0x002c, 0x0078,
+	0x9493, 0x1078, 0xa41c, 0x00c0, 0x9664, 0x1078, 0x29bb, 0x00c0,
+	0x9664, 0x1078, 0x9667, 0x00c0, 0x9371, 0x6106, 0x1078, 0x968c,
+	0x00c0, 0x951e, 0x6007, 0x002e, 0x0078, 0x9493, 0x6007, 0x002f,
+	0x0078, 0x9493, 0x1078, 0x29bb, 0x00c0, 0x9664, 0x0e7e, 0x0d7e,
+	0x0c7e, 0x6018, 0xa080, 0x0001, 0x200c, 0xa184, 0x00ff, 0xa086,
+	0x0006, 0x0040, 0x953f, 0xa184, 0xff00, 0x8007, 0xa086, 0x0006,
+	0x0040, 0x953f, 0x0c7f, 0x0d7f, 0x0e7f, 0x0078, 0x9498, 0x2001,
+	0xa672, 0x2004, 0xd0e4, 0x0040, 0x95ab, 0x2071, 0xab8c, 0x7010,
+	0x6036, 0x7014, 0x603a, 0x7108, 0x720c, 0x2001, 0xa653, 0x2004,
+	0xd0a4, 0x0040, 0x955d, 0x6018, 0x2068, 0x6810, 0xa106, 0x00c0,
+	0x955d, 0x6814, 0xa206, 0x0040, 0x9581, 0x2001, 0xa653, 0x2004,
+	0xd0ac, 0x00c0, 0x959f, 0x2069, 0xa600, 0x6870, 0xa206, 0x00c0,
+	0x959f, 0x686c, 0xa106, 0x00c0, 0x959f, 0x7210, 0x1078, 0x8cf2,
+	0x0040, 0x95a5, 0x1078, 0xa28e, 0x0040, 0x95a5, 0x622a, 0x6007,
+	0x0036, 0x6003, 0x0001, 0x1078, 0x5d8a, 0x0c7f, 0x0d7f, 0x0e7f,
+	0x007c, 0x7214, 0xa286, 0xffff, 0x0040, 0x9593, 0x1078, 0x8cf2,
+	0x0040, 0x95a5, 0xa280, 0x0002, 0x2004, 0x7110, 0xa106, 0x00c0,
+	0x95a5, 0x0078, 0x956e, 0x7210, 0x2c08, 0xa085, 0x0001, 0x1078,
+	0xa1e6, 0x2c10, 0x2160, 0x0040, 0x95a5, 0x0078, 0x956e, 0x6007,
+	0x0037, 0x6013, 0x1500, 0x0078, 0x9579, 0x6007, 0x0037, 0x6013,
+	0x1700, 0x0078, 0x9579, 0x6007, 0x0012, 0x0078, 0x9579, 0x1078,
+	0x29bb, 0x00c0, 0x9664, 0x6018, 0xa080, 0x0001, 0x2004, 0xa084,
+	0xff00, 0x8007, 0xa086, 0x0006, 0x00c0, 0x9498, 0x0e7e, 0x0d7e,
+	0x0c7e, 0x2001, 0xa672, 0x2004, 0xd0e4, 0x0040, 0x9621, 0x2069,
+	0xa600, 0x2071, 0xab8c, 0x7008, 0x6036, 0x720c, 0x623a, 0xa286,
+	0xffff, 0x00c0, 0x95de, 0x7208, 0x0c7e, 0x2c08, 0xa085, 0x0001,
+	0x1078, 0xa1e6, 0x2c10, 0x0c7f, 0x0040, 0x9615, 0x1078, 0x8cf2,
+	0x0040, 0x9615, 0x0c7e, 0x027e, 0x2260, 0x1078, 0x89f3, 0x027f,
+	0x0c7f, 0x7118, 0xa18c, 0xff00, 0x810f, 0xa186, 0x0001, 0x0040,
+	0x95ff, 0xa186, 0x0005, 0x0040, 0x95f9, 0xa186, 0x0007, 0x00c0,
+	0x9609, 0xa280, 0x0004, 0x2004, 0xa005, 0x0040, 0x9609, 0x057e,
+	0x7510, 0x7614, 0x1078, 0xa2a3, 0x057f, 0x0c7f, 0x0d7f, 0x0e7f,
+	0x007c, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013, 0x2a00, 0x6003,
+	0x0001, 0x1078, 0x5d8a, 0x0078, 0x9605, 0x6007, 0x003b, 0x602b,
+	0x0009, 0x6013, 0x1700, 0x6003, 0x0001, 0x1078, 0x5d8a, 0x0078,
+	0x9605, 0x6007, 0x003b, 0x602b, 0x000b, 0x6013, 0x0000, 0x0078,
+	0x9579, 0x0e7e, 0x027e, 0x1078, 0x4967, 0x0040, 0x965e, 0x1078,
+	0x4957, 0x1078, 0xa4a9, 0x00c0, 0x965c, 0x2071, 0xa600, 0x70cc,
+	0xc085, 0x70ce, 0x0f7e, 0x2079, 0x0100, 0x7298, 0xa284, 0x00ff,
+	0x706e, 0x78e6, 0xa284, 0xff00, 0x7270, 0xa205, 0x7072, 0x78ea,
+	0x0f7f, 0x70d7, 0x0000, 0x2001, 0xa653, 0x2004, 0xd0a4, 0x0040,
+	0x9655, 0x2011, 0xa8ca, 0x2013, 0x07d0, 0xd0ac, 0x00c0, 0x965e,
+	0x1078, 0x2677, 0x0078, 0x965e, 0x1078, 0xa4d9, 0x027f, 0x0e7f,
+	0x1078, 0x772d, 0x0078, 0x9497, 0x1078, 0x772d, 0x007c, 0x0d7e,
+	0x067e, 0x6618, 0x2668, 0x6e04, 0xa6b4, 0xff00, 0x8637, 0xa686,
+	0x0006, 0x0040, 0x9684, 0xa686, 0x0004, 0x0040, 0x9684, 0x6e04,
+	0xa6b4, 0x00ff, 0xa686, 0x0006, 0x0040, 0x9684, 0xa686, 0x0004,
+	0x0040, 0x9684, 0xa085, 0x0001, 0x067f, 0x0d7f, 0x007c, 0x0d7e,
+	0x1078, 0x96bb, 0x0d7f, 0x007c, 0x0d7e, 0x1078, 0x96ca, 0x00c0,
+	0x96b4, 0x680c, 0xa08c, 0xff00, 0x6820, 0xa084, 0x00ff, 0xa115,
+	0x6212, 0x6824, 0x602a, 0xd1e4, 0x0040, 0x96a2, 0x2009, 0x0001,
+	0x0078, 0x96b0, 0xd1ec, 0x0040, 0x96b4, 0x6920, 0xa18c, 0x00ff,
+	0x6824, 0x1078, 0x254d, 0x00c0, 0x96b4, 0x2110, 0x2009, 0x0000,
+	0x1078, 0x28c8, 0x0078, 0x96b8, 0xa085, 0x0001, 0x0078, 0x96b9,
+	0xa006, 0x0d7f, 0x007c, 0x2069, 0xab8d, 0x6800, 0xa082, 0x0010,
+	0x00c8, 0x96c8, 0x6013, 0x0000, 0xa085, 0x0001, 0x0078, 0x96c9,
+	0xa006, 0x007c, 0x6013, 0x0000, 0x2069, 0xab8c, 0x6808, 0xa084,
+	0xff00, 0xa086, 0x0800, 0x00c0, 0x96de, 0x6800, 0xa084, 0x00ff,
+	0xa08e, 0x0014, 0x0040, 0x96de, 0xa08e, 0x0010, 0x007c, 0x6004,
+	0xa0b2, 0x0044, 0x10c8, 0x1332, 0xa1b6, 0x0013, 0x00c0, 0x96eb,
+	0x2008, 0x0079, 0x96fe, 0xa1b6, 0x0027, 0x0040, 0x96f3, 0xa1b6,
+	0x0014, 0x10c0, 0x1332, 0x2001, 0x0007, 0x1078, 0x4535, 0x1078,
+	0x61cd, 0x1078, 0x8ec6, 0x1078, 0x62d1, 0x007c, 0x973e, 0x9740,
+	0x973e, 0x973e, 0x973e, 0x9740, 0x974c, 0x97d6, 0x9799, 0x97d6,
+	0x97ad, 0x97d6, 0x974c, 0x97d6, 0x97ce, 0x97d6, 0x97ce, 0x97d6,
+	0x97d6, 0x973e, 0x973e, 0x973e, 0x973e, 0x973e, 0x973e, 0x973e,
+	0x973e, 0x973e, 0x973e, 0x973e, 0x9740, 0x973e, 0x97d6, 0x973e,
+	0x973e, 0x97d6, 0x973e, 0x97d6, 0x97d6, 0x973e, 0x973e, 0x973e,
+	0x973e, 0x97d6, 0x97d6, 0x973e, 0x97d6, 0x97d6, 0x973e, 0x973e,
+	0x973e, 0x973e, 0x973e, 0x9740, 0x97d6, 0x97d6, 0x973e, 0x973e,
+	0x97d6, 0x97d6, 0x973e, 0x973e, 0x973e, 0x973e, 0x1078, 0x1332,
+	0x1078, 0x61cd, 0x2001, 0xa8a2, 0x2004, 0x6016, 0x6003, 0x0002,
+	0x1078, 0x62d1, 0x0078, 0x97dc, 0x0f7e, 0x2079, 0xa652, 0x7804,
+	0x0f7f, 0xd0ac, 0x00c0, 0x97d6, 0x2001, 0x0000, 0x1078, 0x44ee,
+	0x6018, 0xa080, 0x0004, 0x2004, 0xa086, 0x00ff, 0x0040, 0x97d6,
+	0x0c7e, 0x6018, 0x2060, 0x6000, 0xd0f4, 0x00c0, 0x9770, 0x6010,
+	0xa005, 0x0040, 0x9770, 0x0c7f, 0x1078, 0x3699, 0x0078, 0x97d6,
+	0x0c7f, 0x2001, 0xa600, 0x2004, 0xa086, 0x0002, 0x00c0, 0x977f,
+	0x0f7e, 0x2079, 0xa600, 0x7890, 0x8000, 0x7892, 0x0f7f, 0x2001,
+	0x0002, 0x1078, 0x4502, 0x1078, 0x61cd, 0x601f, 0x0001, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x1078, 0x5dd7, 0x1078, 0x62d1, 0x0c7e,
+	0x6118, 0x2160, 0x2009, 0x0001, 0x1078, 0x5a52, 0x0c7f, 0x0078,
+	0x97dc, 0x6618, 0x0d7e, 0x2668, 0x6e04, 0x0d7f, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0006, 0x0040, 0x97d6, 0xa686, 0x0004, 0x0040,
+	0x97d6, 0x2001, 0x0004, 0x0078, 0x97d4, 0x2001, 0xa600, 0x2004,
+	0xa086, 0x0003, 0x00c0, 0x97b6, 0x1078, 0x3699, 0x2001, 0x0006,
+	0x1078, 0x97dd, 0x6618, 0x0d7e, 0x2668, 0x6e04, 0x0d7f, 0xa6b4,
+	0xff00, 0x8637, 0xa686, 0x0006, 0x0040, 0x97d6, 0x2001, 0x0006,
+	0x0078, 0x97d4, 0x2001, 0x0004, 0x0078, 0x97d4, 0x2001, 0x0006,
+	0x1078, 0x97dd, 0x0078, 0x97d6, 0x1078, 0x4535, 0x1078, 0x61cd,
+	0x1078, 0x772d, 0x1078, 0x62d1, 0x007c, 0x017e, 0x0d7e, 0x6118,
+	0x2168, 0x6900, 0xd184, 0x0040, 0x97f8, 0x6104, 0xa18e, 0x000a,
+	0x00c0, 0x97f0, 0x699c, 0xd1a4, 0x00c0, 0x97f0, 0x2001, 0x0007,
+	0x1078, 0x4502, 0x2001, 0x0000, 0x1078, 0x44ee, 0x1078, 0x28a6,
+	0x0d7f, 0x017f, 0x007c, 0x0d7e, 0x6618, 0x2668, 0x6804, 0xa084,
+	0xff00, 0x8007, 0x0d7f, 0xa0b2, 0x000c, 0x10c8, 0x1332, 0xa1b6,
+	0x0015, 0x00c0, 0x980f, 0x1079, 0x9816, 0x0078, 0x9815, 0xa1b6,
+	0x0016, 0x10c0, 0x1332, 0x1079, 0x9822, 0x007c, 0x7d4e, 0x7d4e,
+	0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x9877, 0x982e, 0x7d4e, 0x7d4e,
+	0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e,
+	0x9877, 0x987f, 0x7d4e, 0x7d4e, 0x7d4e, 0x7d4e, 0x0f7e, 0x2079,
+	0xa652, 0x7804, 0xd0ac, 0x00c0, 0x9855, 0x6018, 0xa07d, 0x0040,
+	0x9855, 0x7800, 0xd0f4, 0x00c0, 0x9841, 0x7810, 0xa005, 0x00c0,
+	0x9855, 0x2001, 0x0000, 0x1078, 0x44ee, 0x2001, 0x0002, 0x1078,
+	0x4502, 0x601f, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x1078,
+	0x5dd7, 0x1078, 0x62d1, 0x0078, 0x9875, 0x2011, 0xab83, 0x2204,
+	0x8211, 0x220c, 0x1078, 0x254d, 0x00c0, 0x9875, 0x0c7e, 0x1078,
+	0x45c4, 0x0040, 0x9868, 0x0c7f, 0x1078, 0x772d, 0x0078, 0x9875,
+	0x6010, 0x007e, 0x6014, 0x007e, 0x1078, 0x42f8, 0x007f, 0x6016,
+	0x007f, 0x6012, 0x0c7f, 0x1078, 0x772d, 0x0f7f, 0x007c, 0x6604,
+	0xa6b6, 0x001e, 0x00c0, 0x987e, 0x1078, 0x772d, 0x007c, 0x1078,
+	0x7f8e, 0x00c0, 0x988b, 0x6003, 0x0001, 0x6007, 0x0001, 0x1078,
+	0x5dd7, 0x0078, 0x988d, 0x1078, 0x772d, 0x007c, 0x6004, 0xa08a,
+	0x0044, 0x10c8, 0x1332, 0x1078, 0x61cd, 0x1078, 0x8ec6, 0x1078,
+	0x62d1, 0x007c, 0xa182, 0x0040, 0x0079, 0x989e, 0x98b1, 0x98b1,
+	0x98b1, 0x98b1, 0x98b3, 0x98b1, 0x98b1, 0x98b1, 0x98b1, 0x98b1,
+	0x98b1, 0x98b1, 0x98b1, 0x98b1, 0x98b1, 0x98b1, 0x98b1, 0x98b1,
+	0x98b1, 0x1078, 0x1332, 0x0d7e, 0x0e7e, 0x0f7e, 0x157e, 0x047e,
+	0x027e, 0x6218, 0xa280, 0x002b, 0x2004, 0xa005, 0x0040, 0x98c4,
+	0x2021, 0x0000, 0x1078, 0xa472, 0x6106, 0x2071, 0xab80, 0x7444,
+	0xa4a4, 0xff00, 0x0040, 0x991b, 0xa486, 0x2000, 0x00c0, 0x98d6,
+	0x2009, 0x0001, 0x2011, 0x0200, 0x1078, 0x5bf1, 0x1078, 0x138b,
+	0x1040, 0x1332, 0x6003, 0x0007, 0x2d00, 0x6837, 0x010d, 0x6803,
+	0x0000, 0x683b, 0x0000, 0x6c5a, 0x2c00, 0x685e, 0x6008, 0x68b2,
+	0x6018, 0x2078, 0x78a0, 0x8007, 0x7130, 0x694a, 0x017e, 0xa084,
+	0xff00, 0x6846, 0x684f, 0x0000, 0x6857, 0x0036, 0x1078, 0x4a73,
+	0x017f, 0xa486, 0x2000, 0x00c0, 0x9903, 0x2019, 0x0017, 0x1078,
+	0xa195, 0x0078, 0x997d, 0xa486, 0x0400, 0x00c0, 0x990d, 0x2019,
+	0x0002, 0x1078, 0xa146, 0x0078, 0x997d, 0xa486, 0x0200, 0x00c0,
+	0x9913, 0x1078, 0xa12b, 0xa486, 0x1000, 0x00c0, 0x9919, 0x1078,
+	0xa17a, 0x0078, 0x997d, 0x2069, 0xa933, 0x6a00, 0xd284, 0x0040,
+	0x99e7, 0xa284, 0x0300, 0x00c0, 0x99df, 0x6804, 0xa005, 0x0040,
+	0x99c5, 0x2d78, 0x6003, 0x0007, 0x1078, 0x1370, 0x0040, 0x9984,
+	0x7800, 0xd08c, 0x00c0, 0x9937, 0x7804, 0x8001, 0x7806, 0x6013,
+	0x0000, 0x6803, 0x0000, 0x6837, 0x0116, 0x683b, 0x0000, 0x6008,
+	0x68b2, 0x2c00, 0x684a, 0x6018, 0x2078, 0x78a0, 0x8007, 0x7130,
+	0x6986, 0x6846, 0x7928, 0x698a, 0x792c, 0x698e, 0x7930, 0x6992,
+	0x7934, 0x6996, 0x6853, 0x003d, 0x7244, 0xa294, 0x0003, 0xa286,
+	0x0002, 0x00c0, 0x995f, 0x684f, 0x0040, 0x0078, 0x9969, 0xa286,
+	0x0001, 0x00c0, 0x9967, 0x684f, 0x0080, 0x0078, 0x9969, 0x684f,
+	0x0000, 0x20a9, 0x000a, 0x2001, 0xab90, 0xad90, 0x0015, 0x200c,
+	0x810f, 0x2112, 0x8000, 0x8210, 0x00f0, 0x996f, 0x200c, 0x6982,
+	0x8000, 0x200c, 0x697e, 0x1078, 0x4a73, 0x027f, 0x047f, 0x157f,
+	0x0f7f, 0x0e7f, 0x0d7f, 0x007c, 0x2001, 0xa60e, 0x2004, 0xd084,
+	0x0040, 0x998e, 0x1078, 0x138b, 0x00c0, 0x9930, 0x6013, 0x0100,
+	0x6003, 0x0001, 0x6007, 0x0041, 0x1078, 0x5d8a, 0x1078, 0x62d1,
+	0x0078, 0x997d, 0x2069, 0xab92, 0x2d04, 0xa084, 0xff00, 0xa086,
+	0x1200, 0x00c0, 0x99b9, 0x2069, 0xab80, 0x686c, 0xa084, 0x00ff,
+	0x017e, 0x6110, 0xa18c, 0x0700, 0xa10d, 0x6112, 0x017f, 0x6003,
+	0x0001, 0x6007, 0x0043, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0078,
+	0x997d, 0x6013, 0x0200, 0x6003, 0x0001, 0x6007, 0x0041, 0x1078,
+	0x5d8a, 0x1078, 0x62d1, 0x0078, 0x997d, 0x2001, 0xa60d, 0x2004,
+	0xd0ec, 0x0040, 0x99cf, 0x2011, 0x8049, 0x1078, 0x361b, 0x6013,
+	0x0300, 0x0078, 0x99d5, 0x6013, 0x0100, 0x6003, 0x0001, 0x6007,
+	0x0041, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0078, 0x997d, 0x6013,
+	0x0500, 0x0078, 0x99d5, 0x6013, 0x0600, 0x0078, 0x999a, 0x6013,
+	0x0200, 0x0078, 0x999a, 0xa186, 0x0013, 0x00c0, 0x99fd, 0x6004,
+	0xa08a, 0x0040, 0x1048, 0x1332, 0xa08a, 0x0053, 0x10c8, 0x1332,
+	0xa082, 0x0040, 0x2008, 0x0079, 0x9a82, 0xa186, 0x0051, 0x0040,
+	0x9a0a, 0xa186, 0x0047, 0x00c0, 0x9a23, 0x6004, 0xa086, 0x0041,
+	0x0040, 0x9a31, 0x2001, 0x0109, 0x2004, 0xd084, 0x0040, 0x9a31,
+	0x127e, 0x2091, 0x2200, 0x007e, 0x017e, 0x027e, 0x1078, 0x5c56,
+	0x027f, 0x017f, 0x007f, 0x127f, 0x6000, 0xa086, 0x0002, 0x00c0,
+	0x9a31, 0x0078, 0x9ac7, 0xa186, 0x0027, 0x0040, 0x9a2b, 0xa186,
+	0x0014, 0x10c0, 0x1332, 0x6004, 0xa082, 0x0040, 0x2008, 0x0079,
+	0x9a34, 0x1078, 0x7773, 0x007c, 0x9a47, 0x9a49, 0x9a49, 0x9a71,
+	0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47,
+	0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x9a47, 0x1078,
+	0x1332, 0x1078, 0x61cd, 0x1078, 0x62d1, 0x037e, 0x0d7e, 0x6010,
+	0xa06d, 0x0040, 0x9a6e, 0xad84, 0xf000, 0x0040, 0x9a6e, 0x6003,
+	0x0002, 0x6018, 0x2004, 0xd0bc, 0x00c0, 0x9a6e, 0x2019, 0x0004,
+	0x1078, 0xa1ca, 0x6013, 0x0000, 0x6014, 0xa005, 0x00c0, 0x9a6c,
+	0x2001, 0xa8a3, 0x2004, 0x6016, 0x6003, 0x0007, 0x0d7f, 0x037f,
+	0x007c, 0x0d7e, 0x1078, 0x61cd, 0x1078, 0x62d1, 0x1078, 0x8d06,
+	0x0040, 0x9a7e, 0x6010, 0x2068, 0x1078, 0x13a4, 0x1078, 0x8ec6,
+	0x0d7f, 0x007c, 0x9a95, 0x9ab4, 0x9a9e, 0x9ac1, 0x9a95, 0x9a95,
+	0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x9a95,
+	0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x9a95, 0x1078, 0x1332, 0x6010,
+	0xa088, 0x0013, 0x2104, 0xa085, 0x0400, 0x200a, 0x1078, 0x61cd,
+	0x6010, 0xa080, 0x0013, 0x2004, 0xd0b4, 0x0040, 0x9aaf, 0x6003,
+	0x0007, 0x2009, 0x0043, 0x1078, 0x775c, 0x0078, 0x9ab1, 0x6003,
+	0x0002, 0x1078, 0x62d1, 0x007c, 0x1078, 0x61cd, 0x1078, 0xa423,
+	0x00c0, 0x9abe, 0x1078, 0x5bc1, 0x1078, 0x772d, 0x1078, 0x62d1,
+	0x007c, 0x1078, 0x61cd, 0x2009, 0x0041, 0x0078, 0x9c1e, 0xa182,
+	0x0040, 0x0079, 0x9acb, 0x9ade, 0x9ae0, 0x9ade, 0x9ade, 0x9ade,
+	0x9ade, 0x9ade, 0x9ae1, 0x9ade, 0x9ade, 0x9ade, 0x9ade, 0x9ade,
+	0x9ade, 0x9ade, 0x9ade, 0x9ade, 0x9aec, 0x9ade, 0x1078, 0x1332,
+	0x007c, 0x6003, 0x0004, 0x6110, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x1078, 0x15fa, 0x007c, 0x0d7e, 0x1078, 0x5bc1, 0x0d7f,
+	0x1078, 0xa495, 0x1078, 0x772d, 0x007c, 0xa182, 0x0040, 0x0079,
+	0x9af9, 0x9b0c, 0x9b0c, 0x9b0c, 0x9b0c, 0x9b0c, 0x9b0c, 0x9b0c,
+	0x9b0e, 0x9b0c, 0x9b11, 0x9b3c, 0x9b0c, 0x9b0c, 0x9b0c, 0x9b0c,
+	0x9b3c, 0x9b0c, 0x9b0c, 0x9b0c, 0x1078, 0x1332, 0x1078, 0x7773,
+	0x007c, 0x1078, 0x627a, 0x1078, 0x639b, 0x6010, 0x0d7e, 0x2068,
+	0x684c, 0xd0fc, 0x0040, 0x9b27, 0xa08c, 0x0003, 0xa18e, 0x0002,
+	0x0040, 0x9b2f, 0x2009, 0x0041, 0x0d7f, 0x0078, 0x9c1e, 0x6003,
+	0x0007, 0x6017, 0x0000, 0x1078, 0x5bc1, 0x0d7f, 0x007c, 0x1078,
+	0xa423, 0x0040, 0x9b35, 0x0d7f, 0x007c, 0x1078, 0x5bc1, 0x1078,
+	0x772d, 0x0d7f, 0x0078, 0x9b2e, 0x037e, 0x1078, 0x627a, 0x1078,
+	0x639b, 0x6010, 0x0d7e, 0x2068, 0x6018, 0x2004, 0xd0bc, 0x0040,
+	0x9b5c, 0x684c, 0xa084, 0x0003, 0xa086, 0x0002, 0x0040, 0x9b58,
+	0x687c, 0x632c, 0xa31a, 0x632e, 0x6880, 0x6328, 0xa31b, 0x632a,
+	0x6003, 0x0002, 0x0078, 0x9b6d, 0x2019, 0x0004, 0x1078, 0xa1ca,
+	0x6014, 0xa005, 0x00c0, 0x9b69, 0x2001, 0xa8a3, 0x2004, 0x8003,
+	0x6016, 0x6013, 0x0000, 0x6003, 0x0007, 0x0d7f, 0x037f, 0x007c,
+	0xa186, 0x0013, 0x00c0, 0x9b7e, 0x6004, 0xa086, 0x0042, 0x10c0,
+	0x1332, 0x1078, 0x61cd, 0x1078, 0x62d1, 0x007c, 0xa186, 0x0027,
+	0x0040, 0x9b86, 0xa186, 0x0014, 0x00c0, 0x9b96, 0x6004, 0xa086,
+	0x0042, 0x10c0, 0x1332, 0x2001, 0x0007, 0x1078, 0x4535, 0x1078,
+	0x61cd, 0x1078, 0x8ec6, 0x1078, 0x62d1, 0x007c, 0xa182, 0x0040,
+	0x0079, 0x9b9a, 0x9bad, 0x9bad, 0x9bad, 0x9bad, 0x9bad, 0x9bad,
+	0x9bad, 0x9baf, 0x9bbb, 0x9bad, 0x9bad, 0x9bad, 0x9bad, 0x9bad,
+	0x9bad, 0x9bad, 0x9bad, 0x9bad, 0x9bad, 0x1078, 0x1332, 0x037e,
+	0x047e, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x1078, 0x15fa,
+	0x047f, 0x037f, 0x007c, 0x6010, 0x0d7e, 0x2068, 0x6810, 0x6a14,
+	0x6118, 0x210c, 0xd1bc, 0x0040, 0x9bda, 0x6124, 0xd1f4, 0x00c0,
+	0x9bda, 0x007e, 0x047e, 0x057e, 0x6c7c, 0xa422, 0x6d80, 0x2200,
+	0xa52b, 0x602c, 0xa420, 0x642e, 0x6028, 0xa529, 0x652a, 0x057f,
+	0x047f, 0x007f, 0xa20d, 0x00c0, 0x9bee, 0x684c, 0xd0fc, 0x0040,
+	0x9be6, 0x2009, 0x0041, 0x0d7f, 0x0078, 0x9c1e, 0x6003, 0x0007,
+	0x6017, 0x0000, 0x1078, 0x5bc1, 0x0d7f, 0x007c, 0x007e, 0x0f7e,
+	0x2c78, 0x1078, 0x4963, 0x0f7f, 0x007f, 0x0040, 0x9bfb, 0x6003,
+	0x0002, 0x0d7f, 0x007c, 0x2009, 0xa60d, 0x210c, 0xd19c, 0x0040,
+	0x9c05, 0x6003, 0x0007, 0x0078, 0x9c07, 0x6003, 0x0006, 0x1078,
+	0x9c0d, 0x1078, 0x5bc3, 0x0d7f, 0x007c, 0xd2fc, 0x0040, 0x9c19,
+	0x8002, 0x8000, 0x8212, 0xa291, 0x0000, 0x2009, 0x0009, 0x0078,
+	0x9c1b, 0x2009, 0x0015, 0x6a6a, 0x6866, 0x007c, 0xa182, 0x0040,
+	0x0048, 0x9c24, 0x0079, 0x9c31, 0xa186, 0x0013, 0x0040, 0x9c2c,
+	0xa186, 0x0014, 0x10c0, 0x1332, 0x6024, 0xd0dc, 0x1040, 0x1332,
+	0x007c, 0x9c44, 0x9c4b, 0x9c57, 0x9c63, 0x9c44, 0x9c44, 0x9c44,
+	0x9c72, 0x9c44, 0x9c46, 0x9c46, 0x9c44, 0x9c44, 0x9c44, 0x9c44,
+	0x9c44, 0x9c44, 0x9c44, 0x9c44, 0x1078, 0x1332, 0x6024, 0xd0dc,
+	0x1040, 0x1332, 0x007c, 0x6003, 0x0001, 0x6106, 0x1078, 0x5d8a,
+	0x127e, 0x2091, 0x8000, 0x1078, 0x62d1, 0x127f, 0x007c, 0x6003,
+	0x0001, 0x6106, 0x1078, 0x5d8a, 0x127e, 0x2091, 0x8000, 0x1078,
+	0x62d1, 0x127f, 0x007c, 0x6003, 0x0003, 0x6106, 0x2c10, 0x1078,
+	0x1cf0, 0x127e, 0x2091, 0x8000, 0x1078, 0x5df6, 0x1078, 0x639b,
+	0x127f, 0x007c, 0xa016, 0x1078, 0x15fa, 0x007c, 0x127e, 0x2091,
+	0x8000, 0x037e, 0x0d7e, 0xa182, 0x0040, 0x1079, 0x9c83, 0x0d7f,
+	0x037f, 0x127f, 0x007c, 0x9c93, 0x9c95, 0x9caa, 0x9cc9, 0x9c93,
+	0x9c93, 0x9c93, 0x9ce1, 0x9c93, 0x9c93, 0x9c93, 0x9c93, 0x9c93,
+	0x9c93, 0x9c93, 0x9c93, 0x1078, 0x1332, 0x6010, 0x2068, 0x684c,
+	0xd0fc, 0x0040, 0x9cbf, 0xa09c, 0x0003, 0xa39e, 0x0003, 0x0040,
+	0x9cbf, 0x6003, 0x0001, 0x6106, 0x1078, 0x5d8a, 0x1078, 0x62d1,
+	0x0078, 0x9ce4, 0x6010, 0x2068, 0x684c, 0xd0fc, 0x0040, 0x9cbf,
+	0xa09c, 0x0003, 0xa39e, 0x0003, 0x0040, 0x9cbf, 0x6003, 0x0001,
+	0x6106, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0078, 0x9ce4, 0x6013,
+	0x0000, 0x6017, 0x0000, 0x2019, 0x0004, 0x1078, 0xa1ca, 0x0078,
+	0x9ce4, 0x6010, 0x2068, 0x684c, 0xd0fc, 0x0040, 0x9cbf, 0xa09c,
+	0x0003, 0xa39e, 0x0003, 0x0040, 0x9cbf, 0x6003, 0x0003, 0x6106,
+	0x2c10, 0x1078, 0x1cf0, 0x1078, 0x5df6, 0x1078, 0x639b, 0x0078,
+	0x9ce4, 0xa016, 0x1078, 0x15fa, 0x007c, 0x1078, 0x61cd, 0x6110,
+	0x81ff, 0x0040, 0x9cf6, 0x0d7e, 0x2168, 0x1078, 0xa4e2, 0x037e,
+	0x2019, 0x0029, 0x1078, 0xa1ca, 0x037f, 0x0d7f, 0x1078, 0x8ec6,
+	0x1078, 0x62d1, 0x007c, 0x1078, 0x627a, 0x6110, 0x81ff, 0x0040,
+	0x9d0c, 0x0d7e, 0x2168, 0x1078, 0xa4e2, 0x037e, 0x2019, 0x0029,
+	0x1078, 0xa1ca, 0x037f, 0x0d7f, 0x1078, 0x8ec6, 0x1078, 0x639b,
+	0x007c, 0xa182, 0x0085, 0x0079, 0x9d15, 0x9d1e, 0x9d1c, 0x9d1c,
+	0x9d2a, 0x9d1c, 0x9d1c, 0x9d1c, 0x1078, 0x1332, 0x6003, 0x000b,
+	0x6106, 0x1078, 0x5d8a, 0x127e, 0x2091, 0x8000, 0x1078, 0x62d1,
+	0x127f, 0x007c, 0x027e, 0x0e7e, 0x1078, 0xa41c, 0x0040, 0x9d34,
+	0x1078, 0x772d, 0x0078, 0x9d50, 0x2071, 0xab80, 0x7224, 0x6212,
+	0x7220, 0x1078, 0xa069, 0x0040, 0x9d41, 0x6007, 0x0086, 0x0078,
+	0x9d4a, 0x6007, 0x0087, 0x7224, 0xa296, 0xffff, 0x00c0, 0x9d4a,
+	0x6007, 0x0086, 0x6003, 0x0001, 0x1078, 0x5d8a, 0x1078, 0x62d1,
+	0x0e7f, 0x027f, 0x007c, 0xa186, 0x0013, 0x00c0, 0x9d64, 0x6004,
+	0xa08a, 0x0085, 0x1048, 0x1332, 0xa08a, 0x008c, 0x10c8, 0x1332,
+	0xa082, 0x0085, 0x0079, 0x9d7b, 0xa186, 0x0027, 0x0040, 0x9d70,
+	0xa186, 0x0014, 0x0040, 0x9d70, 0x1078, 0x7773, 0x0078, 0x9d7a,
+	0x2001, 0x0007, 0x1078, 0x4535, 0x1078, 0x61cd, 0x1078, 0x8ec6,
+	0x1078, 0x62d1, 0x007c, 0x9d82, 0x9d84, 0x9d84, 0x9d82, 0x9d82,
+	0x9d82, 0x9d82, 0x1078, 0x1332, 0x1078, 0x61cd, 0x1078, 0x8ec6,
+	0x1078, 0x62d1, 0x007c, 0xa182, 0x0085, 0x1048, 0x1332, 0xa182,
+	0x008c, 0x10c8, 0x1332, 0xa182, 0x0085, 0x0079, 0x9d97, 0x9d9e,
+	0x9d9e, 0x9d9e, 0x9da0, 0x9d9e, 0x9d9e, 0x9d9e, 0x1078, 0x1332,
+	0x007c, 0xa186, 0x0013, 0x0040, 0x9db1, 0xa186, 0x0014, 0x0040,
+	0x9db1, 0xa186, 0x0027, 0x0040, 0x9db1, 0x1078, 0x7773, 0x0078,
+	0x9db7, 0x1078, 0x61cd, 0x1078, 0x8ec6, 0x1078, 0x62d1, 0x007c,
+	0x037e, 0x1078, 0xa495, 0x603f, 0x0000, 0x2019, 0x000b, 0x1078,
+	0x9dc7, 0x601f, 0x0006, 0x6003, 0x0007, 0x037f, 0x007c, 0x127e,
+	0x037e, 0x2091, 0x8000, 0x087e, 0x2c40, 0x097e, 0x2049, 0x0000,
+	0x1078, 0x7246, 0x097f, 0x087f, 0x00c0, 0x9e02, 0x077e, 0x2c38,
+	0x1078, 0x72f3, 0x077f, 0x00c0, 0x9e02, 0x6000, 0xa086, 0x0000,
+	0x0040, 0x9e02, 0x601c, 0xa086, 0x0007, 0x0040, 0x9e02, 0x0d7e,
+	0x6000, 0xa086, 0x0004, 0x00c0, 0x9df3, 0x1078, 0xa495, 0x601f,
+	0x0007, 0x1078, 0x1757, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040,
+	0x9dfb, 0x1078, 0xa1ca, 0x0d7f, 0x6013, 0x0000, 0x1078, 0xa495,
+	0x601f, 0x0007, 0x037f, 0x127f, 0x007c, 0x0f7e, 0x0c7e, 0x037e,
+	0x157e, 0x2079, 0xab80, 0x7938, 0x783c, 0x1078, 0x254d, 0x00c0,
+	0x9e49, 0x017e, 0x0c7e, 0x1078, 0x45c4, 0x00c0, 0x9e49, 0x017f,
+	0x027f, 0x027e, 0x017e, 0x2019, 0x0029, 0x1078, 0x73d0, 0x1078,
+	0x5f01, 0x077e, 0x2039, 0x0000, 0x1078, 0x5e0a, 0x077f, 0x017f,
+	0x077e, 0x2039, 0x0000, 0x1078, 0x9f8b, 0x077f, 0x1078, 0x47e9,
+	0x027e, 0x6204, 0xa294, 0xff00, 0x8217, 0xa286, 0x0006, 0x0040,
+	0x9e3d, 0xa286, 0x0004, 0x00c0, 0x9e40, 0x62a0, 0x1078, 0x2942,
+	0x027f, 0x017f, 0x1078, 0x42f8, 0x6612, 0x6516, 0xa006, 0x0078,
+	0x9e4b, 0x0c7f, 0x017f, 0x157f, 0x037f, 0x0c7f, 0x0f7f, 0x007c,
+	0x0c7e, 0x0d7e, 0x0e7e, 0x017e, 0x2009, 0xa620, 0x2104, 0xa086,
+	0x0074, 0x00c0, 0x9eb3, 0x2069, 0xab8e, 0x690c, 0xa182, 0x0100,
+	0x0048, 0x9ea3, 0x6908, 0xa184, 0x8000, 0x0040, 0x9eaf, 0x6018,
+	0x2070, 0x7010, 0xa084, 0x00ff, 0x0040, 0x9e72, 0x7000, 0xd0f4,
+	0x0040, 0x9e76, 0xa184, 0x0800, 0x0040, 0x9eaf, 0x6910, 0xa18a,
+	0x0001, 0x0048, 0x9ea7, 0x6914, 0x2069, 0xabae, 0x6904, 0x81ff,
+	0x00c0, 0x9e9b, 0x690c, 0xa182, 0x0100, 0x0048, 0x9ea3, 0x6908,
+	0x81ff, 0x00c0, 0x9e9f, 0x6910, 0xa18a, 0x0001, 0x0048, 0x9ea7,
+	0x6918, 0xa18a, 0x0001, 0x0048, 0x9eaf, 0x0078, 0x9eb9, 0x6013,
+	0x0100, 0x0078, 0x9eb5, 0x6013, 0x0300, 0x0078, 0x9eb5, 0x6013,
+	0x0500, 0x0078, 0x9eb5, 0x6013, 0x0700, 0x0078, 0x9eb5, 0x6013,
+	0x0900, 0x0078, 0x9eb5, 0x6013, 0x0b00, 0x0078, 0x9eb5, 0x6013,
+	0x0f00, 0x0078, 0x9eb5, 0x6013, 0x2d00, 0xa085, 0x0001, 0x0078,
+	0x9eba, 0xa006, 0x017f, 0x0e7f, 0x0d7f, 0x0c7f, 0x007c, 0x0c7e,
+	0x0d7e, 0x027e, 0x037e, 0x157e, 0x6218, 0x2268, 0x6b04, 0xa394,
+	0x00ff, 0xa286, 0x0006, 0x0040, 0x9ee3, 0xa286, 0x0004, 0x0040,
+	0x9ee3, 0xa394, 0xff00, 0x8217, 0xa286, 0x0006, 0x0040, 0x9ee3,
+	0xa286, 0x0004, 0x0040, 0x9ee3, 0x0c7e, 0x2d60, 0x1078, 0x45d6,
+	0x0c7f, 0x0078, 0x9f1e, 0x2011, 0xab96, 0xad98, 0x000a, 0x20a9,
+	0x0004, 0x1078, 0x80de, 0x00c0, 0x9f1f, 0x2011, 0xab9a, 0xad98,
+	0x0006, 0x20a9, 0x0004, 0x1078, 0x80de, 0x00c0, 0x9f1f, 0x047e,
+	0x017e, 0x6aa0, 0xa294, 0x00ff, 0x8227, 0xa006, 0x2009, 0xa653,
+	0x210c, 0xd1a4, 0x0040, 0x9f0b, 0x2009, 0x0029, 0x1078, 0xa21d,
+	0x6800, 0xc0e5, 0x6802, 0x2019, 0x0029, 0x1078, 0x5f01, 0x077e,
+	0x2039, 0x0000, 0x1078, 0x5e0a, 0x2c08, 0x1078, 0x9f8b, 0x077f,
+	0x2001, 0x0007, 0x1078, 0x4535, 0x017f, 0x047f, 0xa006, 0x157f,
+	0x037f, 0x027f, 0x0d7f, 0x0c7f, 0x007c, 0x0d7e, 0x2069, 0xab8e,
+	0x6800, 0xa086, 0x0800, 0x0040, 0x9f31, 0x6013, 0x0000, 0x0078,
+	0x9f32, 0xa006, 0x0d7f, 0x007c, 0x0c7e, 0x0f7e, 0x017e, 0x027e,
+	0x037e, 0x157e, 0x2079, 0xab8c, 0x7930, 0x7834, 0x1078, 0x254d,
+	0x00c0, 0x9f58, 0x1078, 0x45c4, 0x00c0, 0x9f58, 0x2011, 0xab90,
+	0xac98, 0x000a, 0x20a9, 0x0004, 0x1078, 0x80de, 0x00c0, 0x9f58,
+	0x2011, 0xab94, 0xac98, 0x0006, 0x20a9, 0x0004, 0x1078, 0x80de,
+	0x157f, 0x037f, 0x027f, 0x017f, 0x0f7f, 0x0c7f, 0x007c, 0x0c7e,
+	0x007e, 0x017e, 0x027e, 0x037e, 0x157e, 0x2011, 0xab83, 0x2204,
+	0x8211, 0x220c, 0x1078, 0x254d, 0x00c0, 0x9f84, 0x1078, 0x45c4,
+	0x00c0, 0x9f84, 0x2011, 0xab96, 0xac98, 0x000a, 0x20a9, 0x0004,
+	0x1078, 0x80de, 0x00c0, 0x9f84, 0x2011, 0xab9a, 0xac98, 0x0006,
+	0x20a9, 0x0004, 0x1078, 0x80de, 0x157f, 0x037f, 0x027f, 0x017f,
+	0x007f, 0x0c7f, 0x007c, 0x0e7e, 0x0c7e, 0x087e, 0x077e, 0x067e,
+	0x057e, 0x047e, 0x027e, 0x127e, 0x2091, 0x8000, 0x2740, 0x2029,
+	0xa8ba, 0x252c, 0x2021, 0xa8c0, 0x2424, 0x2061, 0xad00, 0x2071,
+	0xa600, 0x7648, 0x7064, 0x81ff, 0x0040, 0x9fb2, 0x007e, 0xa186,
+	0xa9b3, 0x007f, 0x0040, 0x9fb2, 0x8001, 0xa602, 0x00c8, 0xa01c,
+	0x0078, 0x9fb5, 0xa606, 0x0040, 0xa01c, 0x2100, 0xac06, 0x0040,
+	0xa012, 0x1078, 0xa242, 0x0040, 0xa012, 0x671c, 0xa786, 0x0001,
+	0x0040, 0xa037, 0xa786, 0x0004, 0x0040, 0xa037, 0xa786, 0x0007,
+	0x0040, 0xa012, 0x2500, 0xac06, 0x0040, 0xa012, 0x2400, 0xac06,
+	0x0040, 0xa012, 0x1078, 0xa256, 0x00c0, 0xa012, 0x88ff, 0x0040,
+	0x9fdd, 0x6020, 0xa906, 0x00c0, 0xa012, 0x0d7e, 0x6000, 0xa086,
+	0x0004, 0x00c0, 0x9fe7, 0x017e, 0x1078, 0x1757, 0x017f, 0xa786,
+	0x0008, 0x00c0, 0x9ff6, 0x1078, 0x8f00, 0x00c0, 0x9ff6, 0x1078,
+	0x7c83, 0x0d7f, 0x1078, 0x8ec6, 0x0078, 0xa012, 0x6010, 0x2068,
+	0x1078, 0x8d06, 0x0040, 0xa00f, 0xa786, 0x0003, 0x00c0, 0xa026,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x1078, 0xa4e2, 0x017e,
+	0x1078, 0x8f7d, 0x1078, 0x4a73, 0x017f, 0x1078, 0x8eb9, 0x0d7f,
+	0x1078, 0x8ec6, 0xace0, 0x0010, 0x2001, 0xa616, 0x2004, 0xac02,
+	0x00c8, 0xa01c, 0x0078, 0x9f9f, 0x127f, 0x027f, 0x047f, 0x057f,
+	0x067f, 0x077f, 0x087f, 0x0c7f, 0x0e7f, 0x007c, 0xa786, 0x0006,
+	0x00c0, 0xa000, 0xa386, 0x0005, 0x0040, 0xa034, 0x1078, 0xa4e2,
+	0x1078, 0xa1ca, 0x0078, 0xa00f, 0x0d7f, 0x0078, 0xa012, 0x1078,
+	0xa256, 0x00c0, 0xa012, 0x81ff, 0x0040, 0xa012, 0xa180, 0x0001,
+	0x2004, 0xa086, 0x0018, 0x0040, 0xa04c, 0xa180, 0x0001, 0x2004,
+	0xa086, 0x002d, 0x00c0, 0xa012, 0x6000, 0xa086, 0x0002, 0x00c0,
+	0xa012, 0x1078, 0x8eec, 0x0040, 0xa05d, 0x1078, 0x8f00, 0x00c0,
+	0xa012, 0x1078, 0x7c83, 0x0078, 0xa065, 0x1078, 0x28a6, 0x1078,
+	0x8f00, 0x00c0, 0xa065, 0x1078, 0x7c83, 0x1078, 0x8ec6, 0x0078,
+	0xa012, 0x0c7e, 0x0e7e, 0x017e, 0x2c08, 0x2170, 0xa006, 0x1078,
+	0xa1e6, 0x017f, 0x0040, 0xa079, 0x601c, 0xa084, 0x000f, 0x1079,
+	0xa07c, 0x0e7f, 0x0c7f, 0x007c, 0xa084, 0xa084, 0xa084, 0xa084,
+	0xa084, 0xa084, 0xa086, 0xa084, 0xa006, 0x007c, 0x047e, 0x017e,
+	0x7018, 0xa080, 0x0028, 0x2024, 0xa4a4, 0x00ff, 0x8427, 0x2c00,
+	0x2009, 0x0020, 0x1078, 0xa21d, 0x017f, 0x047f, 0x037e, 0x2019,
+	0x0002, 0x1078, 0x9dc7, 0x037f, 0xa085, 0x0001, 0x007c, 0x2001,
+	0x0001, 0x1078, 0x44ee, 0x157e, 0x017e, 0x027e, 0x037e, 0x20a9,
+	0x0004, 0x2019, 0xa605, 0x2011, 0xab96, 0x1078, 0x80de, 0x037f,
+	0x027f, 0x017f, 0x157f, 0xa005, 0x007c, 0x0f7e, 0x0e7e, 0x0c7e,
+	0x087e, 0x077e, 0x067e, 0x027e, 0x127e, 0x2091, 0x8000, 0x2740,
+	0x2061, 0xad00, 0x2079, 0x0001, 0x8fff, 0x0040, 0xa11d, 0x2071,
+	0xa600, 0x7648, 0x7064, 0x8001, 0xa602, 0x00c8, 0xa11d, 0x88ff,
+	0x0040, 0xa0d8, 0x2800, 0xac06, 0x00c0, 0xa113, 0x2079, 0x0000,
+	0x1078, 0xa242, 0x0040, 0xa113, 0x2400, 0xac06, 0x0040, 0xa113,
+	0x671c, 0xa786, 0x0006, 0x00c0, 0xa113, 0xa786, 0x0007, 0x0040,
+	0xa113, 0x88ff, 0x00c0, 0xa0f7, 0x6018, 0xa206, 0x00c0, 0xa113,
+	0x85ff, 0x0040, 0xa0f7, 0x6020, 0xa106, 0x00c0, 0xa113, 0x0d7e,
+	0x6000, 0xa086, 0x0004, 0x00c0, 0xa103, 0x1078, 0xa495, 0x601f,
+	0x0007, 0x1078, 0x1757, 0x6010, 0x2068, 0x1078, 0x8d06, 0x0040,
+	0xa10d, 0x047e, 0x1078, 0xa1ca, 0x047f, 0x0d7f, 0x1078, 0x8ec6,
+	0x88ff, 0x00c0, 0xa127, 0xace0, 0x0010, 0x2001, 0xa616, 0x2004,
+	0xac02, 0x00c8, 0xa11d, 0x0078, 0xa0c4, 0xa006, 0x127f, 0x027f,
+	0x067f, 0x077f, 0x087f, 0x0c7f, 0x0e7f, 0x0f7f, 0x007c, 0xa8c5,
+	0x0001, 0x0078, 0xa11e, 0x077e, 0x057e, 0x087e, 0x2041, 0x0000,
+	0x2029, 0x0001, 0x2c20, 0x2019, 0x0002, 0x6218, 0x097e, 0x2049,
+	0x0000, 0x1078, 0x7246, 0x097f, 0x087f, 0x2039, 0x0000, 0x1078,
+	0x72f3, 0x1078, 0xa0b5, 0x057f, 0x077f, 0x007c, 0x027e, 0x047e,
+	0x057e, 0x077e, 0x0c7e, 0x157e, 0x2c20, 0x2128, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0x017e, 0x037e, 0x1078, 0x45c4, 0x00c0, 0xa16e,
+	0x2c10, 0x057e, 0x087e, 0x2041, 0x0000, 0x2508, 0x2029, 0x0001,
+	0x097e, 0x2049, 0x0000, 0x1078, 0x7246, 0x097f, 0x087f, 0x2039,
+	0x0000, 0x1078, 0x72f3, 0x1078, 0xa0b5, 0x057f, 0x037f, 0x017f,
+	0x8108, 0x00f0, 0xa152, 0x157f, 0x0c7f, 0x077f, 0x057f, 0x047f,
+	0x027f, 0x007c, 0x077e, 0x057e, 0x6218, 0x087e, 0x2041, 0x0000,
+	0x2029, 0x0001, 0x2019, 0x0048, 0x097e, 0x2049, 0x0000, 0x1078,
+	0x7246, 0x097f, 0x087f, 0x2039, 0x0000, 0x1078, 0x72f3, 0x2c20,
+	0x1078, 0xa0b5, 0x057f, 0x077f, 0x007c, 0x027e, 0x047e, 0x057e,
+	0x077e, 0x0c7e, 0x157e, 0x2c20, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x017e, 0x037e, 0x1078, 0x45c4, 0x00c0, 0xa1be, 0x2c10, 0x087e,
+	0x2041, 0x0000, 0x2828, 0x047e, 0x2021, 0x0001, 0x1078, 0xa472,
+	0x047f, 0x097e, 0x2049, 0x0000, 0x1078, 0x7246, 0x097f, 0x087f,
+	0x2039, 0x0000, 0x1078, 0x72f3, 0x1078, 0xa0b5, 0x037f, 0x017f,
+	0x8108, 0x00f0, 0xa1a0, 0x157f, 0x0c7f, 0x077f, 0x057f, 0x047f,
+	0x027f, 0x007c, 0x017e, 0x0f7e, 0xad82, 0xcd00, 0x0048, 0xa1e3,
+	0xad82, 0xffff, 0x00c8, 0xa1e3, 0x6800, 0xa07d, 0x0040, 0xa1e0,
+	0x6803, 0x0000, 0x6b52, 0x1078, 0x4a73, 0x2f68, 0x0078, 0xa1d4,
+	0x6b52, 0x1078, 0x4a73, 0x0f7f, 0x017f, 0x007c, 0x0e7e, 0x047e,
+	0x037e, 0x2061, 0xad00, 0xa005, 0x00c0, 0xa1f6, 0x2071, 0xa600,
+	0x7448, 0x7064, 0x8001, 0xa402, 0x00c8, 0xa218, 0x2100, 0xac06,
+	0x0040, 0xa20a, 0x6000, 0xa086, 0x0000, 0x0040, 0xa20a, 0x6008,
+	0xa206, 0x00c0, 0xa20a, 0x6018, 0xa1a0, 0x0006, 0x2424, 0xa406,
+	0x0040, 0xa214, 0xace0, 0x0010, 0x2001, 0xa616, 0x2004, 0xac02,
+	0x00c8, 0xa218, 0x0078, 0xa1f6, 0xa085, 0x0001, 0x0078, 0xa219,
+	0xa006, 0x037f, 0x047f, 0x0e7f, 0x007c, 0x0d7e, 0x007e, 0x1078,
+	0x138b, 0x007f, 0x1040, 0x1332, 0x6837, 0x010d, 0x685e, 0x027e,
+	0x2010, 0x1078, 0x8cf2, 0x2001, 0x0000, 0x0040, 0xa233, 0x2200,
+	0xa080, 0x0008, 0x2004, 0x027f, 0x684a, 0x6956, 0x6c46, 0x684f,
+	0x0000, 0xa006, 0x68b2, 0x6802, 0x683a, 0x685a, 0x1078, 0x4a73,
+	0x0d7f, 0x007c, 0x6700, 0xa786, 0x0000, 0x0040, 0xa255, 0xa786,
+	0x0001, 0x0040, 0xa255, 0xa786, 0x000a, 0x0040, 0xa255, 0xa786,
+	0x0009, 0x0040, 0xa255, 0xa085, 0x0001, 0x007c, 0x0e7e, 0x6018,
+	0x2070, 0x70a0, 0xa206, 0x0e7f, 0x007c, 0x017e, 0x6004, 0xa08e,
+	0x001e, 0x00c0, 0xa277, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105,
+	0x6032, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0005, 0x2001,
+	0xa8a3, 0x2004, 0x6016, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x017f,
+	0x007c, 0x0005, 0x0005, 0x007c, 0x6024, 0xd0e4, 0x0040, 0xa28d,
+	0xd0cc, 0x0040, 0xa287, 0x1078, 0x8fbf, 0x0078, 0xa28d, 0x1078,
+	0xa495, 0x1078, 0x5bc1, 0x1078, 0x772d, 0x007c, 0xa280, 0x0007,
+	0x2004, 0xa084, 0x000f, 0x0079, 0xa295, 0xa29e, 0xa29e, 0xa29e,
+	0xa2a0, 0xa29e, 0xa2a0, 0xa2a0, 0xa29e, 0xa2a0, 0xa006, 0x007c,
+	0xa085, 0x0001, 0x007c, 0xa280, 0x0007, 0x2004, 0xa084, 0x000f,
+	0x0079, 0xa2aa, 0xa2b3, 0xa2b3, 0xa2b3, 0xa2b3, 0xa2b3, 0xa2b3,
+	0xa2be, 0xa2b3, 0xa2b3, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013,
+	0x2a00, 0x6003, 0x0001, 0x1078, 0x5d8a, 0x007c, 0x0c7e, 0x2260,
+	0x1078, 0xa495, 0x603f, 0x0000, 0x6024, 0xc0f4, 0xc0cc, 0x6026,
+	0x0c7f, 0x0d7e, 0x2268, 0xa186, 0x0007, 0x00c0, 0xa31f, 0x6810,
+	0xa005, 0x0040, 0xa2dc, 0xa080, 0x0013, 0x2004, 0xd0fc, 0x00c0,
+	0xa2dc, 0x0d7f, 0x0078, 0xa2b3, 0x6007, 0x003a, 0x6003, 0x0001,
+	0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0c7e, 0x2d60, 0x6100, 0xa186,
+	0x0002, 0x00c0, 0xa3ad, 0x6010, 0xa005, 0x00c0, 0xa2f6, 0x6000,
+	0xa086, 0x0007, 0x10c0, 0x1332, 0x0078, 0xa3ad, 0xa08c, 0xf000,
+	0x00c0, 0xa302, 0x0078, 0xa302, 0x2068, 0x6800, 0xa005, 0x00c0,
+	0xa2fc, 0x2d00, 0xa080, 0x0013, 0x2004, 0xa084, 0x0003, 0xa086,
+	0x0002, 0x00c0, 0xa31b, 0x6010, 0x2068, 0x684c, 0xc0dc, 0xc0f4,
+	0x684e, 0x6850, 0xc0f4, 0xc0fc, 0x6852, 0x2009, 0x0043, 0x1078,
+	0x9c1e, 0x0078, 0xa3ad, 0x2009, 0x0041, 0x0078, 0xa3a7, 0xa186,
+	0x0005, 0x00c0, 0xa366, 0x6810, 0xa080, 0x0013, 0x2004, 0xd0bc,
+	0x00c0, 0xa32d, 0x0d7f, 0x0078, 0xa2b3, 0xd0b4, 0x0040, 0xa335,
+	0xd0fc, 0x1040, 0x1332, 0x0078, 0xa2cf, 0x6007, 0x003a, 0x6003,
+	0x0001, 0x1078, 0x5d8a, 0x1078, 0x62d1, 0x0c7e, 0x2d60, 0x6100,
+	0xa186, 0x0002, 0x0040, 0xa348, 0xa186, 0x0004, 0x00c0, 0xa3ad,
+	0x2071, 0xa8e7, 0x7000, 0xa086, 0x0003, 0x00c0, 0xa355, 0x7004,
+	0xac06, 0x00c0, 0xa355, 0x7003, 0x0000, 0x6810, 0xa080, 0x0013,
+	0x200c, 0xc1f4, 0xc1dc, 0x2102, 0x8000, 0x200c, 0xc1f4, 0xc1fc,
+	0xc1bc, 0x2102, 0x2009, 0x0042, 0x0078, 0xa3a7, 0x037e, 0x0d7e,
+	0x0d7e, 0x1078, 0x138b, 0x037f, 0x1040, 0x1332, 0x6837, 0x010d,
+	0x6803, 0x0000, 0x683b, 0x0000, 0x685b, 0x0000, 0x6b5e, 0x6857,
+	0x0045, 0x2c00, 0x6862, 0x6034, 0x6872, 0x2360, 0x6024, 0xc0dd,
+	0x6026, 0x6018, 0xa080, 0x0028, 0x2004, 0xa084, 0x00ff, 0x8007,
+	0x6320, 0x6b4a, 0x6846, 0x684f, 0x0000, 0x6d6a, 0x6e66, 0x686f,
+	0x0001, 0x1078, 0x4a73, 0x2019, 0x0045, 0x6008, 0x2068, 0x1078,
+	0x9dc7, 0x2d00, 0x600a, 0x601f, 0x0006, 0x6003, 0x0007, 0x6017,
+	0x0000, 0x603f, 0x0000, 0x0d7f, 0x037f, 0x0078, 0xa3ae, 0x603f,
+	0x0000, 0x6003, 0x0007, 0x1078, 0x9c1e, 0x0c7f, 0x0d7f, 0x007c,
+	0xa186, 0x0013, 0x00c0, 0xa3ba, 0x6004, 0xa082, 0x0085, 0x2008,
+	0x0079, 0xa3d4, 0xa186, 0x0027, 0x00c0, 0xa3cd, 0x1078, 0x61cd,
+	0x037e, 0x0d7e, 0x6010, 0x2068, 0x2019, 0x0004, 0x1078, 0xa1ca,
+	0x0d7f, 0x037f, 0x1078, 0x62d1, 0x007c, 0xa186, 0x0014, 0x0040,
+	0xa3be, 0x1078, 0x7773, 0x007c, 0xa3dd, 0xa3db, 0xa3db, 0xa3db,
+	0xa3db, 0xa3db, 0xa3dd, 0x1078, 0x1332, 0x1078, 0x61cd, 0x6003,
+	0x000c, 0x1078, 0x62d1, 0x007c, 0xa182, 0x008c, 0x00c8, 0xa3ee,
+	0xa182, 0x0085, 0x0048, 0xa3ee, 0x0079, 0xa3f1, 0x1078, 0x7773,
+	0x007c, 0xa3f8, 0xa3f8, 0xa3f8, 0xa3f8, 0xa3fa, 0xa419, 0xa3f8,
+	0x1078, 0x1332, 0x0d7e, 0x2c68, 0x1078, 0x76c7, 0x0040, 0xa414,
+	0x6003, 0x0001, 0x6007, 0x001e, 0x2009, 0xab8e, 0x210c, 0x6136,
+	0x2009, 0xab8f, 0x210c, 0x613a, 0x600b, 0xffff, 0x6918, 0x611a,
+	0x601f, 0x0004, 0x1078, 0x5d8a, 0x2d60, 0x1078, 0x772d, 0x0d7f,
+	0x007c, 0x1078, 0x772d, 0x007c, 0x0e7e, 0x6018, 0x2070, 0x7000,
+	0xd0ec, 0x0e7f, 0x007c, 0x6010, 0xa08c, 0xf000, 0x0040, 0xa471,
+	0xa080, 0x0013, 0x200c, 0xd1ec, 0x0040, 0xa471, 0x2001, 0xa672,
+	0x2004, 0xd0ec, 0x0040, 0xa471, 0x6003, 0x0002, 0x6024, 0xc0e5,
+	0x6026, 0xd1ac, 0x0040, 0xa44f, 0x0f7e, 0x2c78, 0x1078, 0x495f,
+	0x0f7f, 0x0040, 0xa44f, 0x2001, 0xa8a4, 0x2004, 0x603e, 0x2009,
+	0xa672, 0x210c, 0xd1f4, 0x00c0, 0xa46f, 0x0078, 0xa461, 0x2009,
+	0xa672, 0x210c, 0xd1f4, 0x0040, 0xa45b, 0x6024, 0xc0e4, 0x6026,
+	0xa006, 0x0078, 0xa471, 0x2001, 0xa8a4, 0x200c, 0x8103, 0xa100,
+	0x603e, 0x6018, 0xa088, 0x002b, 0x2104, 0xa005, 0x0040, 0xa46c,
+	0xa088, 0x0003, 0x0078, 0xa464, 0x2c0a, 0x600f, 0x0000, 0xa085,
+	0x0001, 0x007c, 0x017e, 0x0c7e, 0x0e7e, 0x6120, 0xa2f0, 0x002b,
+	0x2e04, 0x2060, 0x8cff, 0x0040, 0xa491, 0x84ff, 0x00c0, 0xa484,
+	0x6020, 0xa106, 0x00c0, 0xa48c, 0x600c, 0x2072, 0x1078, 0x5bc1,
+	0x1078, 0x772d, 0x0078, 0xa48e, 0xacf0, 0x0003, 0x2e64, 0x0078,
+	0xa47a, 0x0e7f, 0x0c7f, 0x017f, 0x007c, 0x0d7e, 0x6018, 0xa0e8,
+	0x002b, 0x2d04, 0xa005, 0x0040, 0xa4a7, 0xac06, 0x0040, 0xa4a5,
+	0x2d04, 0xa0e8, 0x0003, 0x0078, 0xa499, 0x600c, 0x206a, 0x0d7f,
+	0x007c, 0x027e, 0x037e, 0x157e, 0x2011, 0xa626, 0x2204, 0xa084,
+	0x00ff, 0x2019, 0xab8e, 0x2334, 0xa636, 0x00c0, 0xa4d5, 0x8318,
+	0x2334, 0x2204, 0xa084, 0xff00, 0xa636, 0x00c0, 0xa4d5, 0x2011,
+	0xab90, 0x6018, 0xa098, 0x000a, 0x20a9, 0x0004, 0x1078, 0x80de,
+	0x00c0, 0xa4d5, 0x2011, 0xab94, 0x6018, 0xa098, 0x0006, 0x20a9,
+	0x0004, 0x1078, 0x80de, 0x00c0, 0xa4d5, 0x157f, 0x037f, 0x027f,
+	0x007c, 0x0e7e, 0x2071, 0xa600, 0x1078, 0x42b8, 0x1078, 0x2677,
+	0x0e7f, 0x007c, 0x0e7e, 0x6018, 0x2070, 0x7000, 0xd0fc, 0x0040,
+	0xa4eb, 0x1078, 0xa4ed, 0x0e7f, 0x007c, 0x6850, 0xc0e5, 0x6852,
+	0x007c, 0x0e7e, 0x0c7e, 0x077e, 0x067e, 0x057e, 0x047e, 0x027e,
+	0x017e, 0x127e, 0x2091, 0x8000, 0x2029, 0xa8ba, 0x252c, 0x2021,
+	0xa8c0, 0x2424, 0x2061, 0xad00, 0x2071, 0xa600, 0x7648, 0x7064,
+	0xa606, 0x0040, 0xa545, 0x671c, 0xa786, 0x0001, 0x0040, 0xa514,
+	0xa786, 0x0008, 0x00c0, 0xa53b, 0x2500, 0xac06, 0x0040, 0xa53b,
+	0x2400, 0xac06, 0x0040, 0xa53b, 0x1078, 0xa242, 0x0040, 0xa53b,
+	0x1078, 0xa256, 0x00c0, 0xa53b, 0x6000, 0xa086, 0x0004, 0x00c0,
+	0xa52d, 0x017e, 0x1078, 0x1757, 0x017f, 0x1078, 0x8eec, 0x00c0,
+	0xa533, 0x1078, 0x28a6, 0x1078, 0x8f00, 0x00c0, 0xa539, 0x1078,
+	0x7c83, 0x1078, 0x8ec6, 0xace0, 0x0010, 0x2001, 0xa616, 0x2004,
+	0xac02, 0x00c8, 0xa545, 0x0078, 0xa504, 0x127f, 0x017f, 0x027f,
+	0x047f, 0x057f, 0x067f, 0x077f, 0x0c7f, 0x0e7f, 0x007c, 0x127e,
+	0x007e, 0x0e7e, 0x017e, 0x2091, 0x8000, 0x2071, 0xa640, 0xd5a4,
+	0x0040, 0xa55d, 0x7034, 0x8000, 0x7036, 0xd5b4, 0x0040, 0xa563,
+	0x7030, 0x8000, 0x7032, 0xd5ac, 0x0040, 0xa579, 0x2500, 0xa084,
+	0x0007, 0xa08e, 0x0003, 0x0040, 0xa579, 0xa08e, 0x0004, 0x0040,
+	0xa579, 0xa08e, 0x0005, 0x0040, 0xa579, 0x2071, 0xa64a, 0x1078,
+	0xa5ba, 0x017f, 0x0e7f, 0x007f, 0x127f, 0x007c, 0x127e, 0x007e,
+	0x0e7e, 0x017e, 0x2091, 0x8000, 0x2071, 0xa640, 0xd5a4, 0x0040,
+	0xa58c, 0x7034, 0x8000, 0x7036, 0xd5b4, 0x0040, 0xa592, 0x7030,
+	0x8000, 0x7032, 0xd5ac, 0x0040, 0xa5a8, 0x2500, 0xa084, 0x0007,
+	0xa08e, 0x0003, 0x0040, 0xa5a8, 0xa08e, 0x0004, 0x0040, 0xa5a8,
+	0xa08e, 0x0005, 0x0040, 0xa5a8, 0x2071, 0xa64a, 0x1078, 0xa5ba,
+	0x017f, 0x0e7f, 0x007f, 0x127f, 0x007c, 0x127e, 0x007e, 0x0e7e,
+	0x2091, 0x8000, 0x2071, 0xa642, 0x1078, 0xa5ba, 0x0e7f, 0x007f,
+	0x127f, 0x007c, 0x2e04, 0x8000, 0x2072, 0x00c8, 0xa5c3, 0x8e70,
+	0x2e04, 0x8000, 0x2072, 0x007c, 0x0e7e, 0x2071, 0xa640, 0x1078,
+	0xa5ba, 0x0e7f, 0x007c, 0x0e7e, 0x2071, 0xa644, 0x1078, 0xa5ba,
+	0x0e7f, 0x007c, 0x127e, 0x007e, 0x0e7e, 0x2091, 0x8000, 0x2071,
+	0xa640, 0x7044, 0x8000, 0x7046, 0x0e7f, 0x007f, 0x127f, 0x007c,
+	0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
+	0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
+	0xa50c
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2100tp_length01 = 0x95f1;
+#else
+unsigned short risc_code_length01 = 0x95f1;
+#endif
+
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2200.c linux-2.5/drivers/scsi/qla2xxx/ql2200.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2200.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2200.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,92 @@
+/*
+ * QLogic ISP2200 device driver for Linux 2.6.x
+ * Copyright (C) 2003 Christoph Hellwig.
+ * Copyright (C) 2003 QLogic Corporation (www.qlogic.com)
+ *
+ * Released under GPL v2.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+static char qla_driver_name[] = "qla2200";
+
+extern unsigned char  fw2200tp_version[];
+extern unsigned char  fw2200tp_version_str[];
+extern unsigned short fw2200tp_addr01;
+extern unsigned short fw2200tp_code01[];
+extern unsigned short fw2200tp_length01;
+
+static struct qla_fw_info qla_fw_tbl[] = {
+	{
+		.addressing	= FW_INFO_ADDR_NORMAL,
+		.fwcode		= &fw2200tp_code01[0],
+		.fwlen		= &fw2200tp_length01,
+		.fwstart	= &fw2200tp_addr01,
+	},
+
+	{ FW_INFO_ADDR_NOMORE, },
+};
+
+static struct qla_board_info qla_board_tbl = {
+	.drv_name	= qla_driver_name,
+
+	.isp_name	= "ISP2200",
+	.fw_info	= qla_fw_tbl,
+};
+
+static struct pci_device_id qla2200_pci_tbl[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP2200,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= (unsigned long)&qla_board_tbl,
+	},
+
+	{0, 0},
+};
+MODULE_DEVICE_TABLE(pci, qla2200_pci_tbl);
+
+static int __devinit
+qla2200_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	return qla2x00_probe_one(pdev,
+	    (struct qla_board_info *)id->driver_data);
+}
+
+static void __devexit
+qla2200_remove_one(struct pci_dev *pdev)
+{
+	qla2x00_remove_one(pdev);
+}
+
+static struct pci_driver qla2200_pci_driver = {
+	.name		= "qla2200",
+	.id_table	= qla2200_pci_tbl,
+	.probe		= qla2200_probe_one,
+	.remove		= __devexit_p(qla2200_remove_one),
+};
+
+static int __init
+qla2200_init(void)
+{
+	return pci_module_init(&qla2200_pci_driver);
+}
+
+static void __exit
+qla2200_exit(void)
+{
+	pci_unregister_driver(&qla2200_pci_driver);
+}
+
+module_init(qla2200_init);
+module_exit(qla2200_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP22xx FC-SCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2200_fw.c linux-2.5/drivers/scsi/qla2xxx/ql2200_fw.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2200_fw.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2200_fw.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,5321 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ *************************************************************************/
+
+/*
+ *	Firmware Version 2.02.06 (08:46 Jun 26, 2003)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_version = 2*1024+2;
+#else
+unsigned short risc_code_version = 2*1024+2;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2200tp_version_str[] = {2,2,6};
+#else
+unsigned char firmware_version[] = {2,2,6};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2200tp_VERSION_STRING "2.02.06"
+#else
+#define FW_VERSION_STRING "2.02.06"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_addr01 = 0x1000 ;
+#else
+unsigned short risc_code_addr01 = 0x1000 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0470, 0x0000, 0x0000, 0xa46f, 0x0000, 0x0002, 0x0002, 0x0006,
+	0x0017, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2032, 0x3030,
+	0x3120, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3232, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x322e, 0x3032, 0x2e30, 0x3620, 0x2020, 0x2020, 0x2400, 0x20c1,
+	0x0005, 0x2001, 0x017f, 0x2003, 0x0000, 0x20c9, 0xbaff, 0x2091,
+	0x2000, 0x2059, 0x0000, 0x2b78, 0x7823, 0x0004, 0x2089, 0x296a,
+	0x2051, 0xb500, 0x2a70, 0x2029, 0xed00, 0x2031, 0xffff, 0x2039,
+	0xece9, 0x2021, 0x0200, 0x0804, 0x1468, 0x20a1, 0xb46f, 0xa00e,
+	0x20a9, 0x0891, 0x41a4, 0x3400, 0x7562, 0x7666, 0x775e, 0x746a,
+	0x746e, 0x20a1, 0xbd00, 0x7164, 0x810d, 0x810d, 0x810d, 0x810d,
+	0xa18c, 0x000f, 0x2001, 0x000b, 0xa112, 0xa00e, 0x21a8, 0x41a4,
+	0x3400, 0x8211, 0x1dd8, 0x7164, 0x3400, 0xa102, 0x0120, 0x0218,
+	0x20a8, 0xa00e, 0x41a4, 0x3800, 0xd08c, 0x01d8, 0x2009, 0xb500,
+	0x810d, 0x810d, 0x810d, 0x810d, 0xa18c, 0x000f, 0x2001, 0x0001,
+	0xa112, 0x20a1, 0x1000, 0xa00e, 0x21a8, 0x41a4, 0x8211, 0x1de0,
+	0x2009, 0xb500, 0x3400, 0xa102, 0x0120, 0x0218, 0x20a8, 0xa00e,
+	0x41a4, 0x080c, 0x1411, 0x080c, 0x1632, 0x080c, 0x17cf, 0x080c,
+	0x1fa2, 0x080c, 0x4bff, 0x080c, 0x85bf, 0x080c, 0x15bb, 0x080c,
+	0x2ec4, 0x080c, 0x5d8a, 0x080c, 0x5341, 0x080c, 0x68ce, 0x080c,
+	0x2510, 0x080c, 0x6b61, 0x080c, 0x63bb, 0x080c, 0x23ca, 0x080c,
+	0x24de, 0x2091, 0x3009, 0x7823, 0x0000, 0x1004, 0x10c5, 0x7820,
+	0xa086, 0x0002, 0x1150, 0x7823, 0x4000, 0x0e04, 0x10bd, 0x781b,
+	0x0001, 0x2091, 0x5000, 0x2091, 0x4080, 0x2a70, 0x7003, 0x0000,
+	0x2a70, 0x7000, 0xa08e, 0x0003, 0x1158, 0x080c, 0x3f08, 0x080c,
+	0x2eeb, 0x080c, 0x5dd8, 0x080c, 0x54f0, 0x080c, 0x68f9, 0x0c80,
+	0x000b, 0x0c98, 0x10e4, 0x10e5, 0x1210, 0x10e2, 0x12dd, 0x140e,
+	0x140f, 0x1410, 0x080c, 0x1515, 0x0005, 0x0126, 0x00f6, 0x2091,
+	0x8000, 0x7000, 0xa086, 0x0001, 0x1904, 0x11ed, 0x080c, 0x1588,
+	0x080c, 0x5acf, 0x0150, 0x080c, 0x5af5, 0x15c0, 0x2079, 0x0100,
+	0x7828, 0xa085, 0x1800, 0x782a, 0x0488, 0x080c, 0x5a07, 0x7000,
+	0xa086, 0x0001, 0x1904, 0x11ed, 0x708c, 0xa086, 0x0028, 0x1904,
+	0x11ed, 0x2001, 0x0161, 0x2003, 0x0001, 0x2079, 0x0100, 0x7827,
+	0xffff, 0x7a28, 0xa295, 0x1e2f, 0x7a2a, 0x2011, 0x59a2, 0x080c,
+	0x699c, 0x2011, 0x5995, 0x080c, 0x6a5c, 0x2011, 0x59e4, 0x080c,
+	0x699c, 0x2011, 0x4adc, 0x080c, 0x699c, 0x2011, 0x8030, 0x2019,
+	0x0000, 0x708b, 0x0000, 0x080c, 0x1de9, 0x00e8, 0x080c, 0x448f,
+	0x2079, 0x0100, 0x7844, 0xa005, 0x1904, 0x11ed, 0x2011, 0x4adc,
+	0x080c, 0x699c, 0x2011, 0x59e4, 0x080c, 0x699c, 0x080c, 0x1de9,
+	0x2001, 0xb78d, 0x2004, 0x780e, 0x7840, 0xa084, 0xfffb, 0x7842,
+	0x2011, 0x8010, 0x73cc, 0x080c, 0x3ecc, 0x723c, 0xc284, 0x723e,
+	0x2001, 0xb50c, 0x200c, 0xc1ac, 0x2102, 0x080c, 0x7f35, 0x2011,
+	0x0004, 0x080c, 0x9c60, 0x080c, 0x524d, 0x080c, 0x5acf, 0x0158,
+	0x080c, 0x4be8, 0x0140, 0x708b, 0x0001, 0x70c7, 0x0000, 0x080c,
+	0x462c, 0x0804, 0x11ed, 0x080c, 0x5309, 0x0120, 0x7a0c, 0xc2b4,
+	0x7a0e, 0x0060, 0x7073, 0x0000, 0x080c, 0xa008, 0x70d4, 0xd09c,
+	0x1128, 0x70a0, 0xa005, 0x0110, 0x080c, 0x4bc6, 0x70df, 0x0000,
+	0x70db, 0x0000, 0x72d4, 0x080c, 0x5acf, 0x1178, 0x2011, 0x0000,
+	0x0016, 0x080c, 0x28eb, 0x2019, 0xb78f, 0x211a, 0x001e, 0x7053,
+	0xffff, 0x7057, 0x00ef, 0x7077, 0x0000, 0x2079, 0xb552, 0x7804,
+	0xd0ac, 0x0108, 0xc295, 0x72d6, 0x080c, 0x5acf, 0x0118, 0xa296,
+	0x0004, 0x0548, 0x2011, 0x0001, 0x080c, 0x9c60, 0x709b, 0x0000,
+	0x709f, 0xffff, 0x7003, 0x0002, 0x2079, 0x0100, 0x7827, 0x0003,
+	0x7828, 0xa085, 0x0003, 0x782a, 0x00fe, 0x080c, 0x2ab8, 0x2011,
+	0x0005, 0x080c, 0x8075, 0x080c, 0x7173, 0x080c, 0x5acf, 0x0148,
+	0x00c6, 0x2061, 0x0100, 0x0016, 0x080c, 0x28eb, 0x61e2, 0x001e,
+	0x00ce, 0x012e, 0x0420, 0x709b, 0x0000, 0x709f, 0xffff, 0x7003,
+	0x0002, 0x00f6, 0x2079, 0x0100, 0x7827, 0x0003, 0x7828, 0xa085,
+	0x0003, 0x782a, 0x00fe, 0x2011, 0x0005, 0x080c, 0x8075, 0x080c,
+	0x7173, 0x080c, 0x5acf, 0x0148, 0x00c6, 0x2061, 0x0100, 0x0016,
+	0x080c, 0x28eb, 0x61e2, 0x001e, 0x00ce, 0x00fe, 0x012e, 0x0005,
+	0x00c6, 0x080c, 0x5acf, 0x1118, 0x20a9, 0x0100, 0x0010, 0x20a9,
+	0x0082, 0x080c, 0x5acf, 0x1118, 0x2009, 0x0000, 0x0010, 0x2009,
+	0x007e, 0x080c, 0x2d97, 0x8108, 0x1f04, 0x1201, 0x00ce, 0x7073,
+	0x0000, 0x7074, 0xa084, 0x00ff, 0x7076, 0x70a3, 0x0000, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x7000, 0xa086, 0x0002, 0x1904, 0x12db,
+	0x709c, 0xa086, 0xffff, 0x0130, 0x080c, 0x2ab8, 0x080c, 0x7173,
+	0x0804, 0x12db, 0x70d4, 0xd0ac, 0x1110, 0xd09c, 0x0540, 0xd084,
+	0x0530, 0x0006, 0x0016, 0x2001, 0x0103, 0x2009, 0xb78d, 0x210c,
+	0x2102, 0x001e, 0x000e, 0xd08c, 0x01d0, 0x70d8, 0xa086, 0xffff,
+	0x0190, 0x080c, 0x2c17, 0x080c, 0x7173, 0x70d4, 0xd094, 0x1904,
+	0x12db, 0x2011, 0x0001, 0x2019, 0x0000, 0x080c, 0x2c4f, 0x080c,
+	0x7173, 0x0804, 0x12db, 0x70dc, 0xa005, 0x1904, 0x12db, 0x7098,
+	0xa005, 0x1904, 0x12db, 0x70d4, 0xd0a4, 0x0118, 0xd0b4, 0x0904,
+	0x12db, 0x080c, 0x5309, 0x1904, 0x12db, 0x2001, 0xb553, 0x2004,
+	0xd0ac, 0x01c8, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x0016, 0x080c, 0x4fa9, 0x1118, 0x6000, 0xd0ec, 0x1138, 0x001e,
+	0x8108, 0x1f04, 0x1268, 0x00ce, 0x015e, 0x0028, 0x001e, 0x00ce,
+	0x015e, 0x0804, 0x12db, 0x0006, 0x0016, 0x2001, 0x0103, 0x2009,
+	0xb78d, 0x210c, 0x2102, 0x001e, 0x000e, 0x71a8, 0x81ff, 0x11b0,
+	0xa006, 0x2009, 0x0200, 0x20a9, 0x0002, 0x20a1, 0xb7de, 0x40a1,
+	0x2009, 0x0700, 0x20a9, 0x0002, 0x20a1, 0xb7ce, 0x40a1, 0x7070,
+	0x8007, 0x7174, 0x810f, 0x20a9, 0x0002, 0x40a1, 0x20a1, 0xb7d2,
+	0x2009, 0x0000, 0x080c, 0x14fb, 0x2001, 0x0000, 0x810f, 0x20a9,
+	0x0002, 0x40a1, 0x7030, 0xc08c, 0x7032, 0x7003, 0x0003, 0x709f,
+	0xffff, 0x080c, 0x1581, 0xa006, 0x080c, 0x27c3, 0x080c, 0x3f3e,
+	0x00f6, 0x2079, 0x0100, 0x080c, 0x5af5, 0x0150, 0x080c, 0x5acf,
+	0x7828, 0x0118, 0xa084, 0xe1ff, 0x0010, 0xa084, 0xffdf, 0x782a,
+	0x00fe, 0x2001, 0xb7e1, 0x2004, 0xa086, 0x0005, 0x1120, 0x2011,
+	0x0000, 0x080c, 0x8075, 0x2011, 0x0000, 0x080c, 0x807f, 0x080c,
+	0x7173, 0x080c, 0x7230, 0x012e, 0x0005, 0x0016, 0x0046, 0x00f6,
+	0x0126, 0x2091, 0x8000, 0x2079, 0x0100, 0x2009, 0xb534, 0x2104,
+	0xa005, 0x1110, 0x080c, 0x2917, 0x2009, 0x00f7, 0x080c, 0x4baf,
+	0x7940, 0xa18c, 0x0010, 0x7942, 0x7924, 0xd1b4, 0x0110, 0x7827,
+	0x0040, 0xd19c, 0x0110, 0x7827, 0x0008, 0x0006, 0x0036, 0x0156,
+	0x7954, 0xd1ac, 0x1904, 0x134b, 0x080c, 0x5ae1, 0x0158, 0x080c,
+	0x5af5, 0x1128, 0x2001, 0xb79e, 0x2003, 0x0000, 0x0070, 0x080c,
+	0x5ad7, 0x0dc0, 0x2001, 0xb79e, 0x2003, 0xaaaa, 0x2001, 0xb79f,
+	0x2003, 0x0001, 0x080c, 0x5a07, 0x0058, 0x080c, 0x5acf, 0x0140,
+	0x2009, 0x00f8, 0x080c, 0x4baf, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x20a9, 0x09c4, 0x7820, 0xd09c, 0x1138, 0x080c, 0x5acf, 0x0138,
+	0x7824, 0xd0ac, 0x1904, 0x13f5, 0x1f04, 0x132a, 0x0070, 0x7824,
+	0x080c, 0x5aeb, 0x0118, 0xd0ac, 0x1904, 0x13f5, 0xa084, 0x1800,
+	0x0d98, 0x7003, 0x0001, 0x0804, 0x13f5, 0x2001, 0x0001, 0x080c,
+	0x27c3, 0x0804, 0x1404, 0x7850, 0xa084, 0x0180, 0x7852, 0x782f,
+	0x0020, 0x20a9, 0x0046, 0x1d04, 0x1353, 0x080c, 0x6a44, 0x1f04,
+	0x1353, 0x7850, 0xa084, 0x0180, 0xa085, 0x0400, 0x7852, 0x782f,
+	0x0000, 0x080c, 0x5ae1, 0x0158, 0x080c, 0x5af5, 0x1128, 0x2001,
+	0xb79e, 0x2003, 0x0000, 0x0070, 0x080c, 0x5ad7, 0x0dc0, 0x2001,
+	0xb79e, 0x2003, 0xaaaa, 0x2001, 0xb79f, 0x2003, 0x0001, 0x080c,
+	0x5a07, 0x0020, 0x2009, 0x00f8, 0x080c, 0x4baf, 0x20a9, 0x000e,
+	0xe000, 0x1f04, 0x1380, 0x7850, 0xa084, 0x0180, 0xa085, 0x1400,
+	0x7852, 0x080c, 0x5acf, 0x0120, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x2021, 0xe678, 0x2019, 0xea60, 0x7820, 0xd09c, 0x1558, 0x080c,
+	0x5acf, 0x05d8, 0x7824, 0xd0ac, 0x1904, 0x13f5, 0x080c, 0x5af5,
+	0x1508, 0x0046, 0x2021, 0x0190, 0x8421, 0x1df0, 0x004e, 0x8421,
+	0x11c8, 0x7827, 0x0048, 0x20a9, 0x01f4, 0x1d04, 0x13ad, 0x080c,
+	0x6a44, 0x1f04, 0x13ad, 0x7824, 0xa084, 0x0068, 0x15c8, 0x2001,
+	0xb79e, 0x2003, 0xaaaa, 0x2001, 0xb79f, 0x2003, 0x0001, 0x7003,
+	0x0001, 0x0498, 0x1d04, 0x13c6, 0x080c, 0x6a44, 0x8319, 0x1960,
+	0x2009, 0xb534, 0x2104, 0x8000, 0x200a, 0xa084, 0xfff0, 0x0120,
+	0x200b, 0x0000, 0x080c, 0x2917, 0x00d8, 0x080c, 0x5ae1, 0x1140,
+	0xa4a2, 0x0064, 0x1128, 0x080c, 0x5aa6, 0x7003, 0x0001, 0x00a8,
+	0x7827, 0x1800, 0xe000, 0xe000, 0x7824, 0x080c, 0x5aeb, 0x0110,
+	0xd0ac, 0x1158, 0xa084, 0x1800, 0x09a8, 0x7003, 0x0001, 0x0028,
+	0x2001, 0x0001, 0x080c, 0x27c3, 0x0048, 0x2001, 0xb534, 0x2003,
+	0x0000, 0x7827, 0x0048, 0x7828, 0xc09d, 0x782a, 0x7850, 0xa084,
+	0x0180, 0xa085, 0x0400, 0x7852, 0x015e, 0x003e, 0x000e, 0x080c,
+	0x1558, 0x012e, 0x00fe, 0x004e, 0x001e, 0x0005, 0x0005, 0x0005,
+	0x0005, 0x2a70, 0x2061, 0xb7c1, 0x2063, 0x0002, 0x6007, 0x0002,
+	0x600b, 0x0006, 0x600f, 0x0017, 0x2001, 0xb79e, 0x2003, 0x0000,
+	0x708b, 0x0000, 0x2009, 0x0100, 0x2104, 0xa082, 0x0002, 0x0218,
+	0x7053, 0xffff, 0x0010, 0x7053, 0x0000, 0x705b, 0xffff, 0x7073,
+	0x0000, 0x7077, 0x0000, 0x080c, 0xa008, 0x2061, 0xb78e, 0x6003,
+	0x0909, 0x6007, 0x0000, 0x600b, 0x8800, 0x600f, 0x0200, 0x6013,
+	0x00ff, 0x6017, 0x000f, 0x601b, 0x0000, 0x601f, 0x07d0, 0x2061,
+	0xb796, 0x6003, 0x8000, 0x6007, 0x0000, 0x600b, 0x0000, 0x600f,
+	0x0200, 0x6013, 0x00ff, 0x6017, 0x0000, 0x601b, 0x0001, 0x601f,
+	0x0000, 0x2061, 0xb7b9, 0x6003, 0x514c, 0x6007, 0x4f47, 0x600b,
+	0x4943, 0x600f, 0x2020, 0x2001, 0xb528, 0x2003, 0x0000, 0x0005,
+	0x04a0, 0x2011, 0x0000, 0x81ff, 0x0570, 0xa186, 0x0001, 0x1148,
+	0x2031, 0x8fff, 0x2039, 0xd501, 0x2021, 0x0100, 0x2029, 0xd500,
+	0x00e8, 0xa186, 0x0002, 0x1118, 0x2011, 0x0000, 0x00b8, 0xa186,
+	0x0005, 0x1118, 0x2011, 0x0001, 0x0088, 0xa186, 0x0009, 0x1118,
+	0x2011, 0x0002, 0x0058, 0xa186, 0x000a, 0x1118, 0x2011, 0x0002,
+	0x0028, 0xa186, 0x0055, 0x1110, 0x2011, 0x0003, 0x3800, 0xa084,
+	0xfffc, 0xa205, 0x20c0, 0x0804, 0x104d, 0xa00e, 0x2011, 0x0003,
+	0x2019, 0x14a4, 0x0804, 0x14f5, 0x2019, 0xaaaa, 0x2061, 0xffff,
+	0x2c14, 0x2362, 0xe000, 0xe000, 0x2c04, 0xa306, 0x2262, 0x1110,
+	0xc1b5, 0xc1a5, 0x2011, 0x0000, 0x2019, 0x14b7, 0x04f0, 0x2019,
+	0xaaaa, 0x2061, 0xffff, 0x2c14, 0x2362, 0xe000, 0xe000, 0x2c1c,
+	0x2061, 0x7fff, 0xe000, 0xe000, 0x2c04, 0x2061, 0xffff, 0x2262,
+	0xa306, 0x0110, 0xc18d, 0x0008, 0xc185, 0x2011, 0x0002, 0x2019,
+	0x14d2, 0x0418, 0x2061, 0xffff, 0x2019, 0xaaaa, 0x2c14, 0x2362,
+	0xe000, 0xe000, 0x2c04, 0x2262, 0xa306, 0x1180, 0x2c14, 0x2362,
+	0xe000, 0xe000, 0x2c1c, 0x2061, 0x7fff, 0x2c04, 0x2061, 0xffff,
+	0x2262, 0xa306, 0x1110, 0xc195, 0x0008, 0xc19d, 0x2011, 0x0001,
+	0x2019, 0x14f3, 0x0010, 0x0804, 0x1469, 0x3800, 0xa084, 0xfffc,
+	0xa205, 0x20c0, 0x0837, 0x2011, 0x0000, 0x080c, 0x4fa9, 0x1178,
+	0x6004, 0xa0c4, 0x00ff, 0xa8c6, 0x0006, 0x0128, 0xa0c4, 0xff00,
+	0xa8c6, 0x0600, 0x1120, 0xa186, 0x0080, 0x0108, 0x8210, 0x8108,
+	0xa186, 0x0100, 0x1d50, 0x2208, 0x0005, 0x2091, 0x8000, 0x0e04,
+	0x1517, 0x0006, 0x0016, 0x2079, 0x0000, 0x7818, 0xd084, 0x1de8,
+	0x001e, 0x792e, 0x000e, 0x782a, 0x000e, 0x7826, 0x3900, 0x783a,
+	0x7823, 0x8002, 0x781b, 0x0001, 0x2091, 0x5000, 0x0126, 0x0156,
+	0x0146, 0x20a9, 0x0010, 0x20a1, 0xb90c, 0x2091, 0x2000, 0x40a1,
+	0x20a9, 0x0010, 0x2091, 0x2200, 0x40a1, 0x20a9, 0x0010, 0x2091,
+	0x2400, 0x40a1, 0x20a9, 0x0010, 0x2091, 0x2600, 0x40a1, 0x20a9,
+	0x0010, 0x2091, 0x2800, 0x40a1, 0x014e, 0x015e, 0x012e, 0x2079,
+	0xb500, 0x7803, 0x0005, 0x2091, 0x4080, 0x04c9, 0x0cf8, 0x0005,
+	0x0006, 0x080c, 0x15a3, 0x1518, 0x00f6, 0x2079, 0xb524, 0x2f04,
+	0x8000, 0x207a, 0xa082, 0x000f, 0x0258, 0xa006, 0x207a, 0x2079,
+	0xb526, 0x2f04, 0xa084, 0x0001, 0xa086, 0x0001, 0x207a, 0x0070,
+	0x2079, 0xb526, 0x2f7c, 0x8fff, 0x1128, 0x2001, 0x0c03, 0x2003,
+	0x0040, 0x0020, 0x2001, 0x0c03, 0x2003, 0x00c0, 0x00fe, 0x000e,
+	0x0005, 0x0409, 0x1120, 0x2001, 0x0c03, 0x2003, 0x0080, 0x0005,
+	0x00d1, 0x1120, 0x2001, 0x0c03, 0x2003, 0x0040, 0x0005, 0x0006,
+	0x0091, 0x1178, 0x2001, 0x0c03, 0x2003, 0x0040, 0x2009, 0x0fff,
+	0x00a1, 0x2001, 0x0c03, 0x2003, 0x0080, 0x2009, 0x0fff, 0x0069,
+	0x0c88, 0x000e, 0x0005, 0x00c6, 0x2061, 0x0c00, 0x2c04, 0xa084,
+	0x00ff, 0xa086, 0x00aa, 0x00ce, 0x0005, 0x0156, 0x0126, 0xa18c,
+	0x0fff, 0x21a8, 0x1d04, 0x15b2, 0x2091, 0x6000, 0x1f04, 0x15b2,
+	0x012e, 0x015e, 0x0005, 0x2071, 0xb500, 0x7160, 0x712e, 0x2021,
+	0x0001, 0xa190, 0x0030, 0xa298, 0x0030, 0x0240, 0x7064, 0xa302,
+	0x1228, 0x220a, 0x2208, 0x2310, 0x8420, 0x0ca8, 0x3800, 0xd08c,
+	0x0148, 0x7064, 0xa086, 0xb500, 0x0128, 0x7067, 0xb500, 0x2011,
+	0x1000, 0x0c48, 0x200b, 0x0000, 0x74b2, 0x74b6, 0x0005, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x2071, 0xb500, 0x70b4, 0xa0ea, 0x0010,
+	0x0268, 0x8001, 0x70b6, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b,
+	0x0000, 0x6807, 0x0000, 0x012e, 0x00ee, 0x0005, 0xa06e, 0x0cd8,
+	0x00e6, 0x2071, 0xb500, 0x0126, 0x2091, 0x8000, 0x70b4, 0x8001,
+	0x0260, 0x70b6, 0x702c, 0x2068, 0x2d04, 0x702e, 0x206b, 0x0000,
+	0x6807, 0x0000, 0x012e, 0x00ee, 0x0005, 0xa06e, 0x0cd8, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x2071, 0xb500, 0x702c, 0x206a, 0x2d00,
+	0x702e, 0x70b4, 0x8000, 0x70b6, 0x012e, 0x00ee, 0x0005, 0x8dff,
+	0x0138, 0x6804, 0x6807, 0x0000, 0x0006, 0x0c49, 0x00de, 0x0cb8,
+	0x0005, 0x00e6, 0x2071, 0xb500, 0x70b4, 0xa08a, 0x0010, 0xa00d,
+	0x00ee, 0x0005, 0x00e6, 0x2071, 0xb812, 0x7007, 0x0000, 0x701b,
+	0x0000, 0x701f, 0x0000, 0x2071, 0x0000, 0x7010, 0xa085, 0x8004,
+	0x7012, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x00e6, 0x2270,
+	0x700b, 0x0000, 0x2071, 0xb812, 0x7018, 0xa088, 0xb81b, 0x220a,
+	0x8000, 0xa084, 0x0007, 0x701a, 0x7004, 0xa005, 0x1128, 0x00f6,
+	0x2079, 0x0010, 0x0089, 0x00fe, 0x00ee, 0x012e, 0x0005, 0x00e6,
+	0x2071, 0xb812, 0x7004, 0xa005, 0x1128, 0x00f6, 0x2079, 0x0010,
+	0x0019, 0x00fe, 0x00ee, 0x0005, 0x7000, 0x0002, 0x1672, 0x16d6,
+	0x16f3, 0x16f3, 0x7018, 0x711c, 0xa106, 0x1118, 0x7007, 0x0000,
+	0x0005, 0x00d6, 0xa180, 0xb81b, 0x2004, 0x700a, 0x2068, 0x8108,
+	0xa18c, 0x0007, 0x711e, 0x7803, 0x0026, 0x6824, 0x7832, 0x6828,
+	0x7836, 0x682c, 0x783a, 0x6830, 0x783e, 0x6810, 0x700e, 0x680c,
+	0x7016, 0x6804, 0x00de, 0xd084, 0x0120, 0x7007, 0x0001, 0x0029,
+	0x0005, 0x7007, 0x0002, 0x00b1, 0x0005, 0x0016, 0x0026, 0x710c,
+	0x2011, 0x0040, 0xa182, 0x0040, 0x1210, 0x2110, 0xa006, 0x700e,
+	0x7212, 0x8203, 0x7822, 0x7803, 0x0020, 0x7803, 0x0041, 0x002e,
+	0x001e, 0x0005, 0x0016, 0x0026, 0x0136, 0x0146, 0x0156, 0x7014,
+	0x2098, 0x20a1, 0x0014, 0x7803, 0x0026, 0x710c, 0x2011, 0x0040,
+	0xa182, 0x0040, 0x1210, 0x2110, 0xa006, 0x700e, 0x22a8, 0x53a6,
+	0x8203, 0x7822, 0x7803, 0x0020, 0x3300, 0x7016, 0x7803, 0x0001,
+	0x015e, 0x014e, 0x013e, 0x002e, 0x001e, 0x0005, 0x0136, 0x0146,
+	0x0156, 0x2099, 0xb5fa, 0x20a1, 0x0018, 0x20a9, 0x0008, 0x53a3,
+	0x7803, 0x0020, 0x0126, 0x2091, 0x8000, 0x7803, 0x0041, 0x7007,
+	0x0003, 0x7000, 0xc084, 0x7002, 0x700b, 0xb5f5, 0x012e, 0x015e,
+	0x014e, 0x013e, 0x0005, 0x0136, 0x0146, 0x0156, 0x2001, 0xb629,
+	0x209c, 0x20a1, 0x0014, 0x7803, 0x0026, 0x2001, 0xb62a, 0x20ac,
+	0x53a6, 0x2099, 0xb62b, 0x20a1, 0x0018, 0x20a9, 0x0008, 0x53a3,
+	0x7803, 0x0020, 0x0126, 0x2091, 0x8000, 0x7803, 0x0001, 0x7007,
+	0x0004, 0x7000, 0xc08c, 0x7002, 0x700b, 0xb626, 0x012e, 0x015e,
+	0x014e, 0x013e, 0x0005, 0x0016, 0x00e6, 0x2071, 0xb812, 0x00f6,
+	0x2079, 0x0010, 0x7904, 0x7803, 0x0002, 0xd1fc, 0x0120, 0xa18c,
+	0x0700, 0x7004, 0x0023, 0x00fe, 0x00ee, 0x001e, 0x0005, 0x166c,
+	0x1736, 0x1764, 0x178e, 0x17be, 0x1735, 0x0cf8, 0xa18c, 0x0700,
+	0x1528, 0x0136, 0x0146, 0x0156, 0x7014, 0x20a0, 0x2099, 0x0014,
+	0x7803, 0x0040, 0x7010, 0x20a8, 0x53a5, 0x3400, 0x7016, 0x015e,
+	0x014e, 0x013e, 0x700c, 0xa005, 0x0570, 0x7830, 0x7832, 0x7834,
+	0x7836, 0x080c, 0x169d, 0x0005, 0x7008, 0xa080, 0x0002, 0x2003,
+	0x0100, 0x7007, 0x0000, 0x080c, 0x166c, 0x0005, 0x7008, 0xa080,
+	0x0002, 0x2003, 0x0200, 0x0ca8, 0xa18c, 0x0700, 0x1150, 0x700c,
+	0xa005, 0x0188, 0x7830, 0x7832, 0x7834, 0x7836, 0x080c, 0x16b2,
+	0x0005, 0x7008, 0xa080, 0x0002, 0x2003, 0x0200, 0x7007, 0x0000,
+	0x080c, 0x166c, 0x0005, 0x00d6, 0x7008, 0x2068, 0x7830, 0x6826,
+	0x7834, 0x682a, 0x7838, 0x682e, 0x783c, 0x6832, 0x680b, 0x0100,
+	0x00de, 0x7007, 0x0000, 0x080c, 0x166c, 0x0005, 0xa18c, 0x0700,
+	0x1540, 0x0136, 0x0146, 0x0156, 0x2001, 0xb5f8, 0x2004, 0xa080,
+	0x000d, 0x20a0, 0x2099, 0x0014, 0x7803, 0x0040, 0x20a9, 0x0020,
+	0x53a5, 0x2001, 0xb5fa, 0x2004, 0xd0bc, 0x0148, 0x2001, 0xb603,
+	0x2004, 0xa080, 0x000d, 0x20a0, 0x20a9, 0x0020, 0x53a5, 0x015e,
+	0x014e, 0x013e, 0x7007, 0x0000, 0x080c, 0x5e6f, 0x080c, 0x166c,
+	0x0005, 0x2011, 0x8003, 0x080c, 0x3ecc, 0x0cf8, 0xa18c, 0x0700,
+	0x1148, 0x2001, 0xb628, 0x2003, 0x0100, 0x7007, 0x0000, 0x080c,
+	0x166c, 0x0005, 0x2011, 0x8004, 0x080c, 0x3ecc, 0x0cf8, 0x0126,
+	0x2091, 0x2200, 0x2079, 0x0030, 0x2071, 0xb823, 0x7003, 0x0000,
+	0x700f, 0xb82f, 0x7013, 0xb82f, 0x780f, 0x00f6, 0x7803, 0x0004,
+	0x012e, 0x0005, 0x6934, 0xa184, 0x0007, 0x0002, 0x17ee, 0x182c,
+	0x17ee, 0x17ee, 0x17ee, 0x1814, 0x17fb, 0x17f2, 0xa085, 0x0001,
+	0x0804, 0x1846, 0x684c, 0xd0bc, 0x0dc8, 0x6860, 0x682e, 0x685c,
+	0x682a, 0x6858, 0x04c8, 0xa18c, 0x00ff, 0xa186, 0x001e, 0x1d70,
+	0x684c, 0xd0bc, 0x0d58, 0x6860, 0x682e, 0x685c, 0x682a, 0x6804,
+	0x681a, 0xa080, 0x000d, 0x2004, 0xa084, 0x000f, 0xa080, 0x22e5,
+	0x2005, 0x6832, 0x6858, 0x0440, 0xa18c, 0x00ff, 0xa186, 0x0015,
+	0x19a8, 0x684c, 0xd0ac, 0x0990, 0x6804, 0x681a, 0xa080, 0x000d,
+	0x2004, 0xa084, 0x000f, 0xa080, 0x22e5, 0x2005, 0x6832, 0xa006,
+	0x682e, 0x682a, 0x6858, 0x0080, 0x684c, 0xd0ac, 0x0904, 0x17ee,
+	0xa006, 0x682e, 0x682a, 0x6858, 0xa18c, 0x000f, 0xa188, 0x22e5,
+	0x210d, 0x6932, 0x2d08, 0x691a, 0x6826, 0x684c, 0xc0dd, 0x684e,
+	0xa006, 0x680a, 0x697c, 0x6912, 0x6980, 0x6916, 0x0005, 0x684c,
+	0xd0ac, 0x090c, 0x1515, 0x6833, 0x22e2, 0x2d08, 0x691a, 0x6858,
+	0x8001, 0x6826, 0x684c, 0xc0dd, 0x684e, 0xa006, 0x680a, 0x682e,
+	0x682a, 0x697c, 0x6912, 0x6980, 0x6916, 0x0005, 0x20e1, 0x0007,
+	0x20e1, 0x2000, 0x2001, 0x020a, 0x2004, 0x82ff, 0x01e8, 0xa280,
+	0x0004, 0x00d6, 0x206c, 0x684c, 0xd0dc, 0x1190, 0xa280, 0x0007,
+	0x2004, 0xa086, 0x000a, 0x1110, 0x0891, 0x0010, 0x080c, 0x17e2,
+	0x0138, 0x00de, 0xa280, 0x0000, 0x2003, 0x0002, 0xa016, 0x0020,
+	0x6808, 0x8000, 0x680a, 0x00de, 0x0126, 0x0046, 0x0036, 0x0026,
+	0x2091, 0x2200, 0x002e, 0x003e, 0x004e, 0x7000, 0xa005, 0x01d0,
+	0x710c, 0x220a, 0x8108, 0x230a, 0x8108, 0x240a, 0x8108, 0xa182,
+	0xb84a, 0x0210, 0x2009, 0xb82f, 0x710e, 0x7010, 0xa102, 0xa082,
+	0x0009, 0x0118, 0xa080, 0x001b, 0x1118, 0x2009, 0x0138, 0x200a,
+	0x012e, 0x0005, 0x7206, 0x2001, 0x18a8, 0x0006, 0x2260, 0x0804,
+	0x19d5, 0x0126, 0x0026, 0x0036, 0x00c6, 0x0006, 0x2091, 0x2200,
+	0x000e, 0x004e, 0x003e, 0x002e, 0x00d6, 0x00c6, 0x2460, 0x6110,
+	0x2168, 0x6a62, 0x6b5e, 0xa005, 0x0904, 0x190a, 0x6808, 0xa005,
+	0x0904, 0x1941, 0x7000, 0xa005, 0x1108, 0x0488, 0x700c, 0x7110,
+	0xa106, 0x1904, 0x1949, 0x7004, 0xa406, 0x1548, 0x2001, 0x0005,
+	0x2004, 0xd08c, 0x0168, 0x0046, 0x080c, 0x1b06, 0x004e, 0x2460,
+	0x6010, 0xa080, 0x0002, 0x2004, 0xa005, 0x0904, 0x1941, 0x0c10,
+	0x2001, 0x0207, 0x2004, 0xd09c, 0x1d48, 0x7804, 0xa084, 0x6000,
+	0x0120, 0xa086, 0x6000, 0x0108, 0x0c08, 0x7818, 0x6812, 0x781c,
+	0x6816, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060, 0x6100,
+	0xa18e, 0x0004, 0x1904, 0x1949, 0x2009, 0x0048, 0x080c, 0x864c,
+	0x0804, 0x1949, 0x6808, 0xa005, 0x05a0, 0x7000, 0xa005, 0x0588,
+	0x700c, 0x7110, 0xa106, 0x1118, 0x7004, 0xa406, 0x1550, 0x2001,
+	0x0005, 0x2004, 0xd08c, 0x0160, 0x0046, 0x080c, 0x1b06, 0x004e,
+	0x2460, 0x6010, 0xa080, 0x0002, 0x2004, 0xa005, 0x01d0, 0x0c28,
+	0x2001, 0x0207, 0x2004, 0xd09c, 0x1d50, 0x2001, 0x0005, 0x2004,
+	0xd08c, 0x1d50, 0x7804, 0xa084, 0x6000, 0x0118, 0xa086, 0x6000,
+	0x19f0, 0x7818, 0x6812, 0x781c, 0x6816, 0x7803, 0x0004, 0x7003,
+	0x0000, 0x6100, 0xa18e, 0x0004, 0x1120, 0x2009, 0x0048, 0x080c,
+	0x864c, 0x00ce, 0x00de, 0x012e, 0x0005, 0x00f6, 0x00e6, 0x0026,
+	0x0036, 0x0046, 0x0056, 0x2071, 0xb823, 0x7000, 0xa086, 0x0000,
+	0x0904, 0x19b3, 0x7004, 0xac06, 0x1904, 0x19a5, 0x2079, 0x0030,
+	0x7000, 0xa086, 0x0003, 0x0904, 0x19a5, 0x7804, 0xd0fc, 0x15c8,
+	0x20e1, 0x6000, 0x2011, 0x0032, 0x2001, 0x0208, 0x200c, 0x2001,
+	0x0209, 0x2004, 0xa106, 0x1d88, 0x8211, 0x1db0, 0x7804, 0xd0fc,
+	0x1540, 0x080c, 0x1e6e, 0x0026, 0x0056, 0x7803, 0x0004, 0x7804,
+	0xd0ac, 0x1de8, 0x7803, 0x0002, 0x7803, 0x0009, 0x7003, 0x0003,
+	0x7007, 0x0000, 0x005e, 0x002e, 0x2001, 0x015d, 0x2003, 0x0000,
+	0x080c, 0x5acf, 0x1138, 0x0066, 0x2031, 0x0001, 0x080c, 0x5b51,
+	0x006e, 0x0058, 0x2001, 0x0160, 0x2502, 0x2001, 0x0138, 0x2202,
+	0x0020, 0x080c, 0x1b06, 0x0804, 0x1955, 0x0156, 0x20a9, 0x0009,
+	0x2009, 0xb82f, 0x2104, 0xac06, 0x1108, 0x200a, 0xa188, 0x0003,
+	0x1f04, 0x19aa, 0x015e, 0x005e, 0x004e, 0x003e, 0x002e, 0x00ee,
+	0x00fe, 0x0005, 0x700c, 0x7110, 0xa106, 0x0904, 0x1a49, 0x2104,
+	0x7006, 0x2060, 0x8108, 0x211c, 0x8108, 0x2124, 0x8108, 0xa182,
+	0xb84a, 0x0210, 0x2009, 0xb82f, 0x7112, 0x700c, 0xa106, 0x1128,
+	0x080c, 0x28eb, 0x2001, 0x0138, 0x2102, 0x8cff, 0x0598, 0x6010,
+	0x2068, 0x2d58, 0x6828, 0xa406, 0x1590, 0x682c, 0xa306, 0x1578,
+	0x7004, 0x2060, 0x6020, 0xc0d4, 0x6022, 0x684c, 0xd0f4, 0x0128,
+	0x6817, 0xffff, 0x6813, 0xffff, 0x00e8, 0x6850, 0xd0f4, 0x1130,
+	0x7803, 0x0004, 0x6810, 0x781a, 0x6814, 0x781e, 0x6824, 0x2050,
+	0x6818, 0x2060, 0x6830, 0x2040, 0x6034, 0xa0cc, 0x000f, 0x2009,
+	0x0011, 0x080c, 0x1a4c, 0x0120, 0x2009, 0x0001, 0x080c, 0x1a4c,
+	0x2d58, 0x0005, 0x080c, 0x1ddd, 0x0904, 0x19ba, 0x0cd0, 0x6020,
+	0xd0f4, 0x11e0, 0xd0d4, 0x01b8, 0x6038, 0xa402, 0x6034, 0xa303,
+	0x0108, 0x1288, 0x643a, 0x6336, 0x6c2a, 0x6b2e, 0x0046, 0x0036,
+	0x2400, 0x6c7c, 0xa402, 0x6812, 0x2300, 0x6b80, 0xa303, 0x6816,
+	0x003e, 0x004e, 0x0018, 0x080c, 0x9f9a, 0x09e0, 0x601c, 0xa08e,
+	0x0008, 0x0904, 0x19e0, 0xa08e, 0x000a, 0x0904, 0x19e0, 0x2001,
+	0xb574, 0x2004, 0xd0b4, 0x1140, 0x6018, 0x2004, 0xd0bc, 0x1120,
+	0x6817, 0x7fff, 0x6813, 0xffff, 0x080c, 0x2305, 0x1918, 0x0804,
+	0x19e0, 0x7003, 0x0000, 0x0005, 0x8aff, 0x0904, 0x1ae0, 0xa03e,
+	0x2730, 0xc9fc, 0x6850, 0xd0fc, 0x11b8, 0xd0f4, 0x1528, 0x00d6,
+	0x2805, 0xac68, 0x2900, 0x0002, 0x1a9e, 0x1a82, 0x1a82, 0x1a9e,
+	0x1a9e, 0x1a96, 0x1a9e, 0x1a82, 0x1a9e, 0x1a87, 0x1a87, 0x1a9e,
+	0x1a9e, 0x1a9e, 0x1a8e, 0x1a87, 0x7803, 0x0004, 0xc0fc, 0x6852,
+	0x6b6c, 0x6a70, 0x6d1c, 0x6c20, 0x00d6, 0xd99c, 0x0550, 0x2805,
+	0xac68, 0x6f08, 0x6e0c, 0x0430, 0xc0f4, 0x6852, 0x6b6c, 0x6a70,
+	0x00d6, 0x0468, 0x6b08, 0x6a0c, 0x6d00, 0x6c04, 0x00d0, 0x6b10,
+	0x6a14, 0x6d00, 0x6c04, 0x6f08, 0x6e0c, 0x00a0, 0x00de, 0x00d6,
+	0x6834, 0xa084, 0x00ff, 0xa086, 0x001e, 0x1140, 0x00de, 0x080c,
+	0x22a7, 0x1904, 0x1a4c, 0xa00e, 0x0804, 0x1ae0, 0x00de, 0x080c,
+	0x1515, 0xc9fd, 0x7b22, 0x7a26, 0x7d32, 0x7c36, 0x7f3a, 0x7e3e,
+	0x7316, 0x721a, 0x751e, 0x7422, 0x7726, 0x762a, 0x7902, 0x7100,
+	0x8108, 0x7102, 0x00de, 0x6828, 0xa300, 0x682a, 0x682c, 0xa201,
+	0x682e, 0x8109, 0x2d08, 0x1500, 0xd9fc, 0x0160, 0xc9fc, 0x080c,
+	0x22a7, 0x01e8, 0x2805, 0xac68, 0x6800, 0xa506, 0x11c0, 0x6804,
+	0xa406, 0x00a8, 0xc9fc, 0x080c, 0x22a7, 0x0188, 0x2805, 0xac68,
+	0x6800, 0xa506, 0x1160, 0x6804, 0xa406, 0x1148, 0x6808, 0xa706,
+	0x1130, 0x680c, 0xa606, 0x0018, 0xc9fc, 0x080c, 0x22a7, 0x2168,
+	0x0005, 0x080c, 0x1515, 0x080c, 0x1f55, 0x7004, 0x2060, 0x00d6,
+	0x6010, 0x2068, 0x7003, 0x0000, 0x080c, 0x1dfe, 0x080c, 0x9c5a,
+	0x0170, 0x6808, 0x8001, 0x680a, 0x697c, 0x6912, 0x6980, 0x6916,
+	0x682b, 0xffff, 0x682f, 0xffff, 0x6850, 0xc0bd, 0x6852, 0x00de,
+	0x080c, 0x992a, 0x0804, 0x1d2b, 0x080c, 0x1515, 0x0126, 0x2091,
+	0x2200, 0x0006, 0x0016, 0x2b68, 0x6818, 0x2060, 0x7904, 0x7803,
+	0x0002, 0xa184, 0x0700, 0x1978, 0xa184, 0x0003, 0xa086, 0x0003,
+	0x0d58, 0x7000, 0x0002, 0x1b23, 0x1b29, 0x1c3a, 0x1d06, 0x1d1a,
+	0x1b23, 0x1b23, 0x1b23, 0x7804, 0xd09c, 0x1904, 0x1d2b, 0x080c,
+	0x1515, 0x8001, 0x7002, 0xd1bc, 0x11a0, 0xd19c, 0x1904, 0x1bbe,
+	0xd1dc, 0x1178, 0x8aff, 0x0904, 0x1bbe, 0x2009, 0x0001, 0x080c,
+	0x1a4c, 0x0904, 0x1d2b, 0x2009, 0x0001, 0x080c, 0x1a4c, 0x0804,
+	0x1d2b, 0x7803, 0x0004, 0x7003, 0x0000, 0xd1bc, 0x1904, 0x1b9e,
+	0x0026, 0x0036, 0x7c20, 0x7d24, 0x7e30, 0x7f34, 0x7818, 0x6812,
+	0x781c, 0x6816, 0x2001, 0x0201, 0x2004, 0xa005, 0x0140, 0x7808,
+	0xd0ec, 0x1128, 0x7803, 0x0009, 0x7003, 0x0004, 0x0010, 0x080c,
+	0x1d2f, 0x6b28, 0x6a2c, 0x2400, 0x686e, 0xa31a, 0x2500, 0x6872,
+	0xa213, 0x6b2a, 0x6a2e, 0x00c6, 0x7004, 0x2060, 0x6020, 0xd0f4,
+	0x1110, 0x633a, 0x6236, 0x00ce, 0x003e, 0x002e, 0x6e1e, 0x6f22,
+	0x2500, 0xa405, 0x0128, 0x080c, 0x22bd, 0x6850, 0xc0fd, 0x6852,
+	0x2a00, 0x6826, 0x2c00, 0x681a, 0x2800, 0x6832, 0x6808, 0x8001,
+	0x680a, 0x1148, 0x684c, 0xd0e4, 0x0130, 0x7004, 0x2060, 0x2009,
+	0x0048, 0x080c, 0x864c, 0x7000, 0xa086, 0x0004, 0x0904, 0x1d2b,
+	0x7003, 0x0000, 0x080c, 0x19ba, 0x0804, 0x1d2b, 0x0056, 0x7d0c,
+	0xd5bc, 0x1110, 0x080c, 0xb407, 0x005e, 0x080c, 0x1dfe, 0x00f6,
+	0x7004, 0x2078, 0x080c, 0x5305, 0x0118, 0x7820, 0xc0f5, 0x7822,
+	0x00fe, 0x682b, 0xffff, 0x682f, 0xffff, 0x6808, 0x8001, 0x680a,
+	0x697c, 0x791a, 0x6980, 0x791e, 0x0804, 0x1d2b, 0x7004, 0x00c6,
+	0x2060, 0x6020, 0x00ce, 0xd0f4, 0x0120, 0x6808, 0x8001, 0x680a,
+	0x04c0, 0x7818, 0x6812, 0x7a1c, 0x6a16, 0xd19c, 0x0160, 0xa205,
+	0x0150, 0x7004, 0xa080, 0x0007, 0x2004, 0xa084, 0xfffd, 0xa086,
+	0x0008, 0x1904, 0x1b41, 0x684c, 0xc0f5, 0x684e, 0x7814, 0xa005,
+	0x1520, 0x7003, 0x0000, 0x6808, 0x8001, 0x680a, 0x01a0, 0x7004,
+	0x2060, 0x601c, 0xa086, 0x000a, 0x11a0, 0x0156, 0x20a9, 0x0009,
+	0x2009, 0xb82f, 0x2104, 0xac06, 0x1108, 0x200a, 0xa188, 0x0003,
+	0x1f04, 0x1bf2, 0x015e, 0x7004, 0x2060, 0x2009, 0x0048, 0x080c,
+	0x864c, 0x080c, 0x19ba, 0x0804, 0x1d2b, 0x7818, 0x6812, 0x781c,
+	0x6816, 0x7814, 0x7908, 0xa18c, 0x0fff, 0xa192, 0x0841, 0x1a04,
+	0x1ae3, 0xa188, 0x0007, 0x8114, 0x8214, 0x8214, 0xa10a, 0x8104,
+	0x8004, 0x8004, 0xa20a, 0x810b, 0x810b, 0x810b, 0x080c, 0x1e99,
+	0x7803, 0x0004, 0x780f, 0xffff, 0x7803, 0x0001, 0x7804, 0xd0fc,
+	0x0de8, 0x7803, 0x0002, 0x7803, 0x0004, 0x780f, 0x00f6, 0x7004,
+	0x7007, 0x0000, 0x2060, 0x2009, 0x0048, 0x080c, 0x864c, 0x080c,
+	0x1eef, 0x0838, 0x8001, 0x7002, 0xd194, 0x01b0, 0x7804, 0xd0fc,
+	0x1904, 0x1cd6, 0xd09c, 0x0138, 0x7804, 0xd0fc, 0x1904, 0x1cd6,
+	0xd09c, 0x1904, 0x1cda, 0x8aff, 0x0904, 0x1d2b, 0x2009, 0x0001,
+	0x080c, 0x1a4c, 0x0804, 0x1d2b, 0xa184, 0x0888, 0x1148, 0x8aff,
+	0x0904, 0x1d2b, 0x2009, 0x0001, 0x080c, 0x1a4c, 0x0804, 0x1d2b,
+	0x7818, 0x6812, 0x7a1c, 0x6a16, 0xa205, 0x0904, 0x1bdb, 0x7803,
+	0x0004, 0x7003, 0x0000, 0xd1bc, 0x1904, 0x1cb8, 0x6834, 0xa084,
+	0x00ff, 0xa086, 0x0029, 0x1118, 0xd19c, 0x1904, 0x1bdb, 0x0026,
+	0x0036, 0x7c20, 0x7d24, 0x7e30, 0x7f34, 0x7818, 0x6812, 0x781c,
+	0x6816, 0x2001, 0x0201, 0x2004, 0xa005, 0x0140, 0x7808, 0xd0ec,
+	0x1128, 0x7803, 0x0009, 0x7003, 0x0004, 0x0020, 0x0016, 0x080c,
+	0x1d2f, 0x001e, 0x6b28, 0x6a2c, 0x080c, 0x22bd, 0x00d6, 0x2805,
+	0xac68, 0x6034, 0xd09c, 0x1128, 0x6808, 0xa31a, 0x680c, 0xa213,
+	0x0020, 0x6810, 0xa31a, 0x6814, 0xa213, 0x00de, 0xd194, 0x0904,
+	0x1b63, 0x2a00, 0x6826, 0x2c00, 0x681a, 0x2800, 0x6832, 0x6808,
+	0x8001, 0x680a, 0x6b2a, 0x6a2e, 0x003e, 0x002e, 0x0804, 0x1c01,
+	0x0056, 0x7d0c, 0x080c, 0xb407, 0x005e, 0x080c, 0x1dfe, 0x00f6,
+	0x7004, 0x2078, 0x080c, 0x5305, 0x0118, 0x7820, 0xc0f5, 0x7822,
+	0x00fe, 0x682b, 0xffff, 0x682f, 0xffff, 0x6808, 0x8001, 0x680a,
+	0x697c, 0x791a, 0x6980, 0x791e, 0x0804, 0x1d2b, 0x7804, 0xd09c,
+	0x0904, 0x1b0e, 0x7c20, 0x7824, 0xa405, 0x1904, 0x1b0e, 0x7818,
+	0x6812, 0x7c1c, 0x6c16, 0xa405, 0x1120, 0x7803, 0x0002, 0x0804,
+	0x1bdb, 0x751c, 0x7420, 0x7724, 0x7628, 0x7014, 0xa528, 0x7018,
+	0xa421, 0xa7b9, 0x0000, 0xa6b1, 0x0000, 0x7830, 0xa506, 0x1150,
+	0x7834, 0xa406, 0x1138, 0x7838, 0xa706, 0x1120, 0x783c, 0xa606,
+	0x0904, 0x1b0e, 0x7803, 0x0002, 0x0804, 0x1c67, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x7004, 0xa00d, 0x0150, 0x6808, 0x8001, 0x680a,
+	0x1130, 0x7004, 0x2060, 0x2009, 0x0048, 0x080c, 0x864c, 0x080c,
+	0x19ba, 0x0088, 0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060,
+	0x6010, 0xa005, 0x0da0, 0x2068, 0x6808, 0x8000, 0x680a, 0x6c28,
+	0x6b2c, 0x080c, 0x19d5, 0x001e, 0x000e, 0x012e, 0x0005, 0x700c,
+	0x7110, 0xa106, 0x0904, 0x1dd1, 0x7004, 0x0016, 0x210c, 0xa106,
+	0x001e, 0x0904, 0x1dd1, 0x00d6, 0x00c6, 0x216c, 0x2d00, 0xa005,
+	0x0904, 0x1dcf, 0x681c, 0xa086, 0x0008, 0x0904, 0x1dcf, 0x6820,
+	0xd0d4, 0x1904, 0x1dcf, 0x6810, 0x2068, 0x6850, 0xd0fc, 0x05a8,
+	0x8108, 0x2104, 0x6b2c, 0xa306, 0x1904, 0x1dcf, 0x8108, 0x2104,
+	0x6a28, 0xa206, 0x1904, 0x1dcf, 0x6850, 0xc0fc, 0xc0f5, 0x6852,
+	0x686c, 0x7822, 0x7016, 0x6870, 0x7826, 0x701a, 0x681c, 0x7832,
+	0x701e, 0x6820, 0x7836, 0x7022, 0x6818, 0x2060, 0x6034, 0xd09c,
+	0x0168, 0x6830, 0x2005, 0x00d6, 0xac68, 0x6808, 0x783a, 0x7026,
+	0x680c, 0x783e, 0x702a, 0x00de, 0x0804, 0x1dc9, 0xa006, 0x783a,
+	0x783e, 0x7026, 0x702a, 0x0804, 0x1dc9, 0x8108, 0x2104, 0xa005,
+	0x1904, 0x1dcf, 0x6b2c, 0xa306, 0x1904, 0x1dcf, 0x8108, 0x2104,
+	0xa005, 0x15e8, 0x6a28, 0xa206, 0x15d0, 0x6850, 0xc0f5, 0x6852,
+	0x6830, 0x2005, 0x6918, 0xa160, 0xa180, 0x000d, 0x2004, 0xd09c,
+	0x11a0, 0x6008, 0x7822, 0x7016, 0x686e, 0x600c, 0x7826, 0x701a,
+	0x6872, 0x6000, 0x7832, 0x701e, 0x6004, 0x7836, 0x7022, 0xa006,
+	0x783a, 0x783e, 0x7026, 0x702a, 0x00a0, 0x6010, 0x7822, 0x7016,
+	0x686e, 0x6014, 0x7826, 0x701a, 0x6872, 0x6000, 0x7832, 0x701e,
+	0x6004, 0x7836, 0x7022, 0x6008, 0x783a, 0x7026, 0x600c, 0x783e,
+	0x702a, 0x6810, 0x781a, 0x6814, 0x781e, 0x7803, 0x0011, 0x00ce,
+	0x00de, 0x0005, 0x2011, 0x0201, 0x2009, 0x003c, 0x2204, 0xa005,
+	0x1118, 0x8109, 0x1dd8, 0x0005, 0x0005, 0x0ca1, 0x0118, 0x780c,
+	0xd0a4, 0x0120, 0x00d9, 0xa085, 0x0001, 0x0010, 0x080c, 0x1eef,
+	0x0005, 0x0126, 0x2091, 0x2200, 0x7000, 0xa086, 0x0003, 0x1160,
+	0x700c, 0x7110, 0xa106, 0x0140, 0x080c, 0x295c, 0x20e1, 0x9028,
+	0x700f, 0xb82f, 0x7013, 0xb82f, 0x012e, 0x0005, 0x00c6, 0x080c,
+	0x5acf, 0x11b8, 0x2001, 0x0160, 0x2003, 0x0000, 0x2001, 0x0138,
+	0x2003, 0x0000, 0x2011, 0x00c8, 0xe000, 0xe000, 0x8211, 0x1de0,
+	0x04b1, 0x0066, 0x2031, 0x0000, 0x080c, 0x5b51, 0x006e, 0x00ce,
+	0x0005, 0x080c, 0x1e6e, 0x080c, 0x295c, 0x20e1, 0x9028, 0x700c,
+	0x7110, 0xa106, 0x01c0, 0x2104, 0xa005, 0x0130, 0x2060, 0x6010,
+	0x2060, 0x6008, 0x8001, 0x600a, 0xa188, 0x0003, 0xa182, 0xb84a,
+	0x0210, 0x2009, 0xb82f, 0x7112, 0x700c, 0xa106, 0x1d40, 0x080c,
+	0x28eb, 0x2110, 0x0c20, 0x2001, 0x015d, 0x2003, 0x0000, 0x2001,
+	0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x00ce, 0x0005, 0x080c,
+	0x295c, 0x20e1, 0x9028, 0x2001, 0x015d, 0x2003, 0x0000, 0x00e6,
+	0x00c6, 0x0016, 0x2071, 0xb823, 0x700c, 0x7110, 0xa106, 0x0190,
+	0x2104, 0xa005, 0x0130, 0x2060, 0x6010, 0x2060, 0x6008, 0x8001,
+	0x600a, 0xa188, 0x0003, 0xa182, 0xb84a, 0x0210, 0x2009, 0xb82f,
+	0x7112, 0x0c50, 0x001e, 0x00ce, 0x00ee, 0x0005, 0x2001, 0x0138,
+	0x2014, 0x2003, 0x0000, 0x2001, 0x0160, 0x202c, 0x2003, 0x0000,
+	0x080c, 0x5acf, 0x1148, 0x2021, 0x0002, 0x1d04, 0x1e7d, 0x2091,
+	0x6000, 0x8421, 0x1dd0, 0x0005, 0x2021, 0xb015, 0x2001, 0x0141,
+	0x201c, 0xd3dc, 0x1168, 0x2001, 0x0109, 0x201c, 0xa39c, 0x0048,
+	0x1138, 0x2001, 0x0111, 0x201c, 0x83ff, 0x1110, 0x8421, 0x1d70,
+	0x0005, 0x00e6, 0x2071, 0x0200, 0x7808, 0xa084, 0xf000, 0xa10d,
+	0x0869, 0x2001, 0x0105, 0x2004, 0xa084, 0x0003, 0x1130, 0x2001,
+	0xb84a, 0x2004, 0xa086, 0x0000, 0x0548, 0xa026, 0x2019, 0xf000,
+	0x8319, 0x1148, 0x2001, 0x012b, 0x2003, 0x95f5, 0x2001, 0x0129,
+	0x2003, 0x95f5, 0x00d8, 0x2001, 0x0105, 0x2004, 0xa084, 0x0003,
+	0x1130, 0x2001, 0xb84a, 0x2004, 0xa086, 0x0000, 0x0178, 0x2001,
+	0x0132, 0x2004, 0xa436, 0x0110, 0x2020, 0x0c00, 0x2001, 0x0021,
+	0x2004, 0xd0fc, 0x09e8, 0x080c, 0x214a, 0x08c0, 0x20e1, 0x7000,
+	0x7324, 0x7420, 0x7028, 0x7028, 0x7426, 0x7037, 0x0001, 0x810f,
+	0x712e, 0x702f, 0x0100, 0x7037, 0x0008, 0x7326, 0x7422, 0x2001,
+	0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x00ee, 0x0005, 0x0026,
+	0x2001, 0x015d, 0x2003, 0x0000, 0x7908, 0xa18c, 0x0fff, 0xa182,
+	0x0ffd, 0x0210, 0x2009, 0x0000, 0xa190, 0x0007, 0xa294, 0x1ff8,
+	0x8214, 0x8214, 0x8214, 0x2001, 0x020a, 0x82ff, 0x0140, 0x20e1,
+	0x6000, 0x200c, 0x200c, 0x200c, 0x200c, 0x8211, 0x1dd0, 0x20e1,
+	0x7000, 0x200c, 0x200c, 0x7003, 0x0000, 0x20e1, 0x6000, 0x2001,
+	0x0208, 0x200c, 0x2001, 0x0209, 0x2004, 0xa106, 0x0158, 0x080c,
+	0x1dd2, 0x0130, 0x7908, 0xd1ec, 0x1128, 0x790c, 0xd1a4, 0x0960,
+	0x080c, 0x1dfe, 0xa006, 0x002e, 0x0005, 0x00f6, 0x00e6, 0x0016,
+	0x0026, 0x2071, 0xb823, 0x2079, 0x0030, 0x2011, 0x0050, 0x7000,
+	0xa086, 0x0000, 0x01a8, 0x8211, 0x0188, 0x2001, 0x0005, 0x2004,
+	0xd08c, 0x0dc8, 0x7904, 0xa18c, 0x0780, 0x0016, 0x080c, 0x1b06,
+	0x001e, 0x81ff, 0x1118, 0x2011, 0x0050, 0x0c48, 0xa085, 0x0001,
+	0x002e, 0x001e, 0x00ee, 0x00fe, 0x0005, 0x7803, 0x0004, 0x2009,
+	0x0064, 0x7804, 0xd0ac, 0x0904, 0x1fa1, 0x8109, 0x1dd0, 0x2009,
+	0x0100, 0x210c, 0xa18a, 0x0003, 0x0a0c, 0x1515, 0x080c, 0x2251,
+	0x00e6, 0x00f6, 0x2071, 0xb812, 0x2079, 0x0010, 0x7004, 0xa086,
+	0x0000, 0x0538, 0x7800, 0x0006, 0x7820, 0x0006, 0x7830, 0x0006,
+	0x7834, 0x0006, 0x7838, 0x0006, 0x783c, 0x0006, 0x7803, 0x0004,
+	0xe000, 0xe000, 0x2079, 0x0030, 0x7804, 0xd0ac, 0x190c, 0x1515,
+	0x2079, 0x0010, 0x000e, 0x783e, 0x000e, 0x783a, 0x000e, 0x7836,
+	0x000e, 0x7832, 0x000e, 0x7822, 0x000e, 0x7802, 0x00fe, 0x00ee,
+	0x0030, 0x00fe, 0x00ee, 0x7804, 0xd0ac, 0x190c, 0x1515, 0x080c,
+	0x7230, 0x0005, 0x00e6, 0x2071, 0xb84a, 0x7003, 0x0000, 0x00ee,
+	0x0005, 0x00d6, 0xa280, 0x0004, 0x206c, 0x694c, 0xd1dc, 0x1904,
+	0x201f, 0x6934, 0xa184, 0x0007, 0x0002, 0x1fbd, 0x200a, 0x1fbd,
+	0x1fbd, 0x1fbd, 0x1ff1, 0x1fd0, 0x1fbf, 0x080c, 0x1515, 0x684c,
+	0xd0b4, 0x0904, 0x2107, 0x6860, 0x682e, 0x6816, 0x685c, 0x682a,
+	0x6812, 0x687c, 0x680a, 0x6880, 0x680e, 0x6958, 0x0804, 0x2012,
+	0x6834, 0xa084, 0x00ff, 0xa086, 0x001e, 0x1d38, 0x684c, 0xd0b4,
+	0x0904, 0x2107, 0x6860, 0x682e, 0x6816, 0x685c, 0x682a, 0x6812,
+	0x687c, 0x680a, 0x6880, 0x680e, 0x6804, 0x681a, 0xa080, 0x000d,
+	0x2004, 0xa084, 0x000f, 0xa080, 0x22e5, 0x2005, 0x6832, 0x6958,
+	0x0450, 0xa18c, 0x00ff, 0xa186, 0x0015, 0x1548, 0x684c, 0xd0b4,
+	0x0904, 0x2107, 0x6804, 0x681a, 0xa080, 0x000d, 0x2004, 0xa084,
+	0x000f, 0xa080, 0x22e5, 0x2005, 0x6832, 0x6958, 0xa006, 0x682e,
+	0x682a, 0x0088, 0x684c, 0xd0b4, 0x0904, 0x1ae1, 0x6958, 0xa006,
+	0x682e, 0x682a, 0x2d00, 0x681a, 0x6834, 0xa084, 0x000f, 0xa080,
+	0x22e5, 0x2005, 0x6832, 0x6926, 0x684c, 0xc0dd, 0x684e, 0x00de,
+	0x0005, 0x00f6, 0x2079, 0x0020, 0x7804, 0xd0fc, 0x190c, 0x214a,
+	0x00e6, 0x00d6, 0x2071, 0xb84a, 0x7000, 0xa005, 0x1904, 0x2087,
+	0x00c6, 0x7206, 0xa280, 0x0004, 0x205c, 0x7004, 0x2068, 0x7803,
+	0x0004, 0x6818, 0x00d6, 0x2068, 0x686c, 0x7812, 0x6890, 0x00f6,
+	0x20e1, 0x9040, 0x2079, 0x0200, 0x781a, 0x2079, 0x0100, 0x8004,
+	0x78d6, 0x00fe, 0x00de, 0x2b68, 0x6824, 0x2050, 0x6818, 0x2060,
+	0x6830, 0x2040, 0x6034, 0xa0cc, 0x000f, 0x6908, 0x791a, 0x7116,
+	0x680c, 0x781e, 0x701a, 0xa006, 0x700e, 0x7012, 0x7004, 0x692c,
+	0x6814, 0xa106, 0x1120, 0x6928, 0x6810, 0xa106, 0x0158, 0x0036,
+	0x0046, 0x6b14, 0x6c10, 0x080c, 0x2305, 0x004e, 0x003e, 0x0110,
+	0x00ce, 0x00a8, 0x8aff, 0x1120, 0x00ce, 0xa085, 0x0001, 0x0078,
+	0x0126, 0x2091, 0x8000, 0x2079, 0x0020, 0x2009, 0x0001, 0x0059,
+	0x0118, 0x2009, 0x0001, 0x0039, 0x012e, 0x00ce, 0xa006, 0x00de,
+	0x00ee, 0x00fe, 0x0005, 0x0076, 0x0066, 0x0056, 0x0046, 0x0036,
+	0x0026, 0x8aff, 0x0904, 0x2100, 0x700c, 0x7214, 0xa23a, 0x7010,
+	0x7218, 0xa203, 0x0a04, 0x20ff, 0xa705, 0x0904, 0x20ff, 0xa03e,
+	0x2730, 0x6850, 0xd0fc, 0x11a8, 0x00d6, 0x2805, 0xac68, 0x2900,
+	0x0002, 0x20e2, 0x20c7, 0x20c7, 0x20e2, 0x20e2, 0x20db, 0x20e2,
+	0x20c7, 0x20e2, 0x20cc, 0x20cc, 0x20e2, 0x20e2, 0x20e2, 0x20d3,
+	0x20cc, 0xc0fc, 0x6852, 0x6b6c, 0x6a70, 0x6d1c, 0x6c20, 0xd99c,
+	0x0528, 0x00d6, 0x2805, 0xac68, 0x6f08, 0x6e0c, 0x00f0, 0x6b08,
+	0x6a0c, 0x6d00, 0x6c04, 0x00c8, 0x6b10, 0x6a14, 0x6d00, 0x6c04,
+	0x6f08, 0x6e0c, 0x0090, 0x00de, 0x00d6, 0x6834, 0xa084, 0x00ff,
+	0xa086, 0x001e, 0x1138, 0x00de, 0x080c, 0x22a7, 0x1904, 0x2091,
+	0xa00e, 0x00f0, 0x00de, 0x080c, 0x1515, 0x00de, 0x7b22, 0x7a26,
+	0x7d32, 0x7c36, 0x7f3a, 0x7e3e, 0x7902, 0x7000, 0x8000, 0x7002,
+	0x6828, 0xa300, 0x682a, 0x682c, 0xa201, 0x682e, 0x700c, 0xa300,
+	0x700e, 0x7010, 0xa201, 0x7012, 0x080c, 0x22a7, 0x0008, 0xa006,
+	0x002e, 0x003e, 0x004e, 0x005e, 0x006e, 0x007e, 0x0005, 0x080c,
+	0x1515, 0x0026, 0x2001, 0x0105, 0x2003, 0x0010, 0x20e1, 0x9040,
+	0x7803, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060, 0x00d6, 0x6010,
+	0x2068, 0x080c, 0x9c5a, 0x0118, 0x6850, 0xc0bd, 0x6852, 0x601c,
+	0xa086, 0x0006, 0x1180, 0x2061, 0x0100, 0x62c8, 0x2001, 0x00fa,
+	0x8001, 0x1df0, 0x60c8, 0xa206, 0x1dc0, 0x60c4, 0x686a, 0x60c8,
+	0x6866, 0x7004, 0x2060, 0x00de, 0x00c6, 0x080c, 0x992a, 0x00ce,
+	0x2001, 0xb7ef, 0x2004, 0xac06, 0x1150, 0x20e1, 0x9040, 0x080c,
+	0x825d, 0x2011, 0x0000, 0x080c, 0x807f, 0x080c, 0x7230, 0x002e,
+	0x0804, 0x2204, 0x0126, 0x2091, 0x2400, 0x0006, 0x0016, 0x00f6,
+	0x00e6, 0x00d6, 0x00c6, 0x2079, 0x0020, 0x2071, 0xb84a, 0x2b68,
+	0x6818, 0x2060, 0x7904, 0x7803, 0x0002, 0xa184, 0x0700, 0x1904,
+	0x2109, 0x7000, 0x0002, 0x2204, 0x2167, 0x21d7, 0x2202, 0x8001,
+	0x7002, 0xd19c, 0x1170, 0x8aff, 0x05d0, 0x2009, 0x0001, 0x080c,
+	0x208b, 0x0904, 0x2204, 0x2009, 0x0001, 0x080c, 0x208b, 0x0804,
+	0x2204, 0x7803, 0x0004, 0xd194, 0x0148, 0x6850, 0xc0fc, 0x6852,
+	0x8aff, 0x11d8, 0x684c, 0xc0f5, 0x684e, 0x00b8, 0x0026, 0x0036,
+	0x6b28, 0x6a2c, 0x7820, 0x686e, 0xa31a, 0x7824, 0x6872, 0xa213,
+	0x7830, 0x681e, 0x7834, 0x6822, 0x6b2a, 0x6a2e, 0x003e, 0x002e,
+	0x080c, 0x22bd, 0x6850, 0xc0fd, 0x6852, 0x2a00, 0x6826, 0x2c00,
+	0x681a, 0x2800, 0x6832, 0x7003, 0x0000, 0x0804, 0x2204, 0x00f6,
+	0x0026, 0x781c, 0x0006, 0x7818, 0x0006, 0x2079, 0x0100, 0x7a14,
+	0xa284, 0x0184, 0xa085, 0x0012, 0x7816, 0x0036, 0x2019, 0x1000,
+	0x8319, 0x090c, 0x1515, 0x7820, 0xd0bc, 0x1dd0, 0x003e, 0x79c8,
+	0x000e, 0xa102, 0x001e, 0x0006, 0x0016, 0x79c4, 0x000e, 0xa103,
+	0x78c6, 0x000e, 0x78ca, 0xa284, 0x0184, 0xa085, 0x0012, 0x7816,
+	0x002e, 0x00fe, 0x7803, 0x0008, 0x7003, 0x0000, 0x0468, 0x8001,
+	0x7002, 0xd194, 0x0168, 0x7804, 0xd0fc, 0x1904, 0x215a, 0xd19c,
+	0x11f8, 0x8aff, 0x0508, 0x2009, 0x0001, 0x080c, 0x208b, 0x00e0,
+	0x0026, 0x0036, 0x6b28, 0x6a2c, 0x080c, 0x22bd, 0x00d6, 0x2805,
+	0xac68, 0x6034, 0xd09c, 0x1128, 0x6808, 0xa31a, 0x680c, 0xa213,
+	0x0020, 0x6810, 0xa31a, 0x6814, 0xa213, 0x00de, 0x0804, 0x218a,
+	0x0804, 0x2186, 0x080c, 0x1515, 0x00ce, 0x00de, 0x00ee, 0x00fe,
+	0x001e, 0x000e, 0x012e, 0x0005, 0x00f6, 0x00e6, 0x2071, 0xb84a,
+	0x7000, 0xa086, 0x0000, 0x05d0, 0x2079, 0x0020, 0x0016, 0x2009,
+	0x0207, 0x210c, 0xd194, 0x0198, 0x2009, 0x020c, 0x210c, 0xa184,
+	0x0003, 0x0168, 0x080c, 0xb450, 0x2001, 0x0133, 0x2004, 0xa005,
+	0x090c, 0x1515, 0x20e1, 0x9040, 0x2001, 0x020c, 0x2102, 0x2009,
+	0x0206, 0x2104, 0x2009, 0x0203, 0x210c, 0xa106, 0x1110, 0x20e1,
+	0x9040, 0x7804, 0xd0fc, 0x09d8, 0x080c, 0x214a, 0x7000, 0xa086,
+	0x0000, 0x19a8, 0x001e, 0x7803, 0x0004, 0x7804, 0xd0ac, 0x1de8,
+	0x20e1, 0x9040, 0x7803, 0x0002, 0x7003, 0x0000, 0x00ee, 0x00fe,
+	0x0005, 0x0026, 0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2071, 0xb84a,
+	0x2079, 0x0020, 0x7000, 0xa086, 0x0000, 0x0540, 0x7004, 0x2060,
+	0x6010, 0x2068, 0x080c, 0x9c5a, 0x0158, 0x6850, 0xc0b5, 0x6852,
+	0x680c, 0x7a1c, 0xa206, 0x1120, 0x6808, 0x7a18, 0xa206, 0x01e0,
+	0x2001, 0x0105, 0x2003, 0x0010, 0x20e1, 0x9040, 0x7803, 0x0004,
+	0x7003, 0x0000, 0x7004, 0x2060, 0x080c, 0x992a, 0x20e1, 0x9040,
+	0x080c, 0x825d, 0x2011, 0x0000, 0x080c, 0x807f, 0x00fe, 0x00ee,
+	0x00de, 0x00ce, 0x002e, 0x0005, 0x6810, 0x6a14, 0xa205, 0x1d00,
+	0x684c, 0xc0dc, 0x684e, 0x2c10, 0x080c, 0x1fa9, 0x2001, 0x0105,
+	0x2003, 0x0010, 0x20e1, 0x9040, 0x7803, 0x0004, 0x7003, 0x0000,
+	0x2069, 0xb7e0, 0x6833, 0x0000, 0x683f, 0x0000, 0x08f8, 0x8840,
+	0x2805, 0xa005, 0x1170, 0x6004, 0xa005, 0x0168, 0x681a, 0x2060,
+	0x6034, 0xa084, 0x000f, 0xa080, 0x22e5, 0x2045, 0x88ff, 0x090c,
+	0x1515, 0x8a51, 0x0005, 0x2050, 0x0005, 0x8a50, 0x8841, 0x2805,
+	0xa005, 0x1190, 0x2c00, 0xad06, 0x0120, 0x6000, 0xa005, 0x1108,
+	0x2d00, 0x2060, 0x681a, 0x6034, 0xa084, 0x000f, 0xa080, 0x22f5,
+	0x2045, 0x88ff, 0x090c, 0x1515, 0x0005, 0x0000, 0x0011, 0x0015,
+	0x0019, 0x001d, 0x0021, 0x0025, 0x0029, 0x0000, 0x000f, 0x0015,
+	0x001b, 0x0021, 0x0027, 0x0000, 0x0000, 0x0000, 0x22da, 0x22d6,
+	0x0000, 0x0000, 0x22e4, 0x0000, 0x22da, 0x0000, 0x22e1, 0x22de,
+	0x0000, 0x0000, 0x0000, 0x22e4, 0x22e1, 0x0000, 0x22dc, 0x22dc,
+	0x0000, 0x0000, 0x22e4, 0x0000, 0x22dc, 0x0000, 0x22e2, 0x22e2,
+	0x0000, 0x0000, 0x0000, 0x22e4, 0x22e2, 0x00a6, 0x0096, 0x0086,
+	0x6b2e, 0x6c2a, 0x6858, 0xa055, 0x0904, 0x2396, 0x2d60, 0x6034,
+	0xa0cc, 0x000f, 0xa9c0, 0x22e5, 0xa986, 0x0007, 0x0130, 0xa986,
+	0x000e, 0x0118, 0xa986, 0x000f, 0x1120, 0x605c, 0xa422, 0x6060,
+	0xa31b, 0x2805, 0xa045, 0x1140, 0x0310, 0x0804, 0x2396, 0x6004,
+	0xa065, 0x0904, 0x2396, 0x0c18, 0x2805, 0xa005, 0x01a8, 0xac68,
+	0xd99c, 0x1128, 0x6808, 0xa422, 0x680c, 0xa31b, 0x0020, 0x6810,
+	0xa422, 0x6814, 0xa31b, 0x0620, 0x2300, 0xa405, 0x0150, 0x8a51,
+	0x0904, 0x2396, 0x8840, 0x0c40, 0x6004, 0xa065, 0x0904, 0x2396,
+	0x0830, 0x8a51, 0x0904, 0x2396, 0x8840, 0x2805, 0xa005, 0x1158,
+	0x6004, 0xa065, 0x0904, 0x2396, 0x6034, 0xa0cc, 0x000f, 0xa9c0,
+	0x22e5, 0x2805, 0x2040, 0x2b68, 0x6850, 0xc0fc, 0x6852, 0x0458,
+	0x8422, 0x8420, 0x831a, 0xa399, 0x0000, 0x00d6, 0x2b68, 0x6c6e,
+	0x6b72, 0x00de, 0xd99c, 0x1168, 0x6908, 0x2400, 0xa122, 0x690c,
+	0x2300, 0xa11b, 0x0a0c, 0x1515, 0x6800, 0xa420, 0x6804, 0xa319,
+	0x0060, 0x6910, 0x2400, 0xa122, 0x6914, 0x2300, 0xa11b, 0x0a0c,
+	0x1515, 0x6800, 0xa420, 0x6804, 0xa319, 0x2b68, 0x6c1e, 0x6b22,
+	0x6850, 0xc0fd, 0x6852, 0x2c00, 0x681a, 0x2800, 0x6832, 0x2a00,
+	0x6826, 0x000e, 0x000e, 0x000e, 0xa006, 0x0028, 0x008e, 0x009e,
+	0x00ae, 0xa085, 0x0001, 0x0005, 0x2001, 0x0005, 0x2004, 0xa084,
+	0x0007, 0x0002, 0x23aa, 0x23ab, 0x23ae, 0x23b1, 0x23b6, 0x23b9,
+	0x23be, 0x23c3, 0x0005, 0x080c, 0x214a, 0x0005, 0x080c, 0x1b06,
+	0x0005, 0x080c, 0x1b06, 0x080c, 0x214a, 0x0005, 0x080c, 0x171b,
+	0x0005, 0x080c, 0x214a, 0x080c, 0x171b, 0x0005, 0x080c, 0x1b06,
+	0x080c, 0x171b, 0x0005, 0x080c, 0x1b06, 0x080c, 0x214a, 0x080c,
+	0x171b, 0x0005, 0x0126, 0x2091, 0x2600, 0x2079, 0x0200, 0x2071,
+	0xbb80, 0x2069, 0xb500, 0x080c, 0x24c0, 0x080c, 0x24b0, 0x2009,
+	0x0004, 0x7912, 0x7817, 0x0004, 0x080c, 0x27f8, 0x781b, 0x0002,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x20a9, 0x0080, 0x782f, 0x0000,
+	0x1f04, 0x23e6, 0x20e1, 0x9080, 0x783b, 0x001f, 0x20e1, 0x8700,
+	0x012e, 0x0005, 0x0126, 0x2091, 0x2600, 0x781c, 0xd0a4, 0x190c,
+	0x24ad, 0xa084, 0x0007, 0x0002, 0x2416, 0x2404, 0x2407, 0x240a,
+	0x240f, 0x2411, 0x2413, 0x2415, 0x080c, 0x63c4, 0x0078, 0x080c,
+	0x6403, 0x0060, 0x080c, 0x63c4, 0x080c, 0x6403, 0x0038, 0x0041,
+	0x0028, 0x0031, 0x0018, 0x0021, 0x0008, 0x0011, 0x012e, 0x0005,
+	0x0006, 0x0016, 0x0026, 0x080c, 0xb450, 0x7930, 0xa184, 0x0003,
+	0x01b0, 0x2001, 0xb7ef, 0x2004, 0xa005, 0x0170, 0x2001, 0x0133,
+	0x2004, 0xa005, 0x090c, 0x1515, 0x00c6, 0x2001, 0xb7ef, 0x2064,
+	0x080c, 0x992a, 0x00ce, 0x04b8, 0x20e1, 0x9040, 0x04a0, 0xa184,
+	0x0030, 0x01e0, 0x6a00, 0xa286, 0x0003, 0x1108, 0x00a0, 0x080c,
+	0x5acf, 0x1178, 0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500,
+	0x2003, 0x0001, 0xa085, 0x0001, 0x080c, 0x5b13, 0x080c, 0x5a07,
+	0x0010, 0x080c, 0x4b1f, 0x080c, 0x24b0, 0x00a8, 0xa184, 0x00c0,
+	0x0168, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0xb823, 0x080c,
+	0x1dfe, 0x005e, 0x004e, 0x003e, 0x00ee, 0x0028, 0xa184, 0x0300,
+	0x0110, 0x20e1, 0x9020, 0x7932, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x0016, 0x00e6, 0x00f6, 0x2071, 0xb500, 0x7128, 0x2001, 0xb791,
+	0x2102, 0x2001, 0xb799, 0x2102, 0xa182, 0x0211, 0x1218, 0x2009,
+	0x0008, 0x0400, 0xa182, 0x0259, 0x1218, 0x2009, 0x0007, 0x00d0,
+	0xa182, 0x02c1, 0x1218, 0x2009, 0x0006, 0x00a0, 0xa182, 0x0349,
+	0x1218, 0x2009, 0x0005, 0x0070, 0xa182, 0x0421, 0x1218, 0x2009,
+	0x0004, 0x0040, 0xa182, 0x0581, 0x1218, 0x2009, 0x0003, 0x0010,
+	0x2009, 0x0002, 0x2079, 0x0200, 0x7912, 0x7817, 0x0004, 0x080c,
+	0x27f8, 0x00fe, 0x00ee, 0x001e, 0x0005, 0x7938, 0x080c, 0x1515,
+	0x00e6, 0x0026, 0x2071, 0x0200, 0x20e1, 0x1000, 0x7220, 0x7028,
+	0x7020, 0xa206, 0x0de0, 0x20e1, 0x9010, 0x002e, 0x00ee, 0x0005,
+	0x20e1, 0xa000, 0x7837, 0x0001, 0x782f, 0x0000, 0x782f, 0x0000,
+	0x782f, 0x0000, 0x782f, 0x0000, 0x7837, 0x0005, 0x20a9, 0x0210,
+	0x7830, 0xd0bc, 0x1110, 0x1f04, 0x24d0, 0x7837, 0x0001, 0x7837,
+	0x0000, 0xe000, 0xe000, 0x20e1, 0xa000, 0x0005, 0x0126, 0x2091,
+	0x2800, 0x2061, 0x0100, 0x2071, 0xb500, 0x6024, 0x6026, 0x6053,
+	0x0030, 0x080c, 0x2837, 0x6050, 0xa084, 0xfe7f, 0x6052, 0x2009,
+	0x00ef, 0x6132, 0x6136, 0x080c, 0x2847, 0x60e7, 0x0000, 0x61ea,
+	0x60e3, 0x0008, 0x604b, 0xf7f7, 0x6043, 0x0000, 0x602f, 0x0080,
+	0x602f, 0x0000, 0x6007, 0x0e9f, 0x601b, 0x001e, 0x600f, 0x00ff,
+	0x2001, 0xb78d, 0x2003, 0x00ff, 0x602b, 0x002f, 0x012e, 0x0005,
+	0x2001, 0xb532, 0x2003, 0x0000, 0x2001, 0xb531, 0x2003, 0x0001,
+	0x0005, 0x0126, 0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x6124,
+	0xa184, 0x1e2c, 0x1118, 0xa184, 0x0007, 0x002a, 0xa195, 0x0004,
+	0xa284, 0x0007, 0x0002, 0x254d, 0x2533, 0x2536, 0x2539, 0x253e,
+	0x2540, 0x2544, 0x2548, 0x080c, 0x6b74, 0x00b8, 0x080c, 0x6c4f,
+	0x00a0, 0x080c, 0x6c4f, 0x080c, 0x6b74, 0x0078, 0x0099, 0x0068,
+	0x080c, 0x6b74, 0x0079, 0x0048, 0x080c, 0x6c4f, 0x0059, 0x0028,
+	0x080c, 0x6c4f, 0x080c, 0x6b74, 0x0029, 0x002e, 0x001e, 0x000e,
+	0x012e, 0x0005, 0x6124, 0x6028, 0xd09c, 0x0118, 0xd19c, 0x1904,
+	0x2766, 0x080c, 0x5acf, 0x0578, 0x7000, 0xa086, 0x0003, 0x0198,
+	0x6024, 0xa084, 0x1800, 0x0178, 0x080c, 0x5af5, 0x0118, 0x080c,
+	0x5ae1, 0x1148, 0x6027, 0x0020, 0x6043, 0x0000, 0x2001, 0xb79e,
+	0x2003, 0xaaaa, 0x0458, 0x080c, 0x5af5, 0x15d0, 0x6024, 0xa084,
+	0x1800, 0x1108, 0x04a8, 0x2001, 0xb79e, 0x2003, 0xaaaa, 0x2001,
+	0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0x080c,
+	0x5a07, 0x0804, 0x2766, 0xd1ac, 0x1518, 0x6024, 0xd0dc, 0x1170,
+	0xd0e4, 0x1188, 0xd0d4, 0x11a0, 0xd0cc, 0x0130, 0x708c, 0xa086,
+	0x0028, 0x1110, 0x080c, 0x5c5e, 0x0804, 0x2766, 0x2001, 0xb79f,
+	0x2003, 0x0000, 0x0048, 0x2001, 0xb79f, 0x2003, 0x0002, 0x0020,
+	0x080c, 0x5bd1, 0x0804, 0x2766, 0x080c, 0x5d03, 0x0804, 0x2766,
+	0xd1ac, 0x0904, 0x26ae, 0x080c, 0x5acf, 0x11d8, 0x6027, 0x0020,
+	0x0006, 0x0026, 0x0036, 0x080c, 0x5aeb, 0x1170, 0x2001, 0xb79f,
+	0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0x080c, 0x5a07,
+	0x003e, 0x002e, 0x000e, 0x0005, 0x003e, 0x002e, 0x000e, 0x080c,
+	0x5aa6, 0x0016, 0x0046, 0x00c6, 0x644c, 0xa486, 0xf0f0, 0x1138,
+	0x2061, 0x0100, 0x644a, 0x6043, 0x0090, 0x6043, 0x0010, 0x74ce,
+	0xa48c, 0xff00, 0x7034, 0xd084, 0x0178, 0xa186, 0xf800, 0x1160,
+	0x703c, 0xd084, 0x1148, 0xc085, 0x703e, 0x0036, 0x2418, 0x2011,
+	0x8016, 0x080c, 0x3ecc, 0x003e, 0xa196, 0xff00, 0x05b8, 0x7054,
+	0xa084, 0x00ff, 0x810f, 0xa116, 0x0588, 0x7130, 0xd184, 0x1570,
+	0x2011, 0xb553, 0x2214, 0xd2ec, 0x0138, 0xc18d, 0x7132, 0x2011,
+	0xb553, 0x2214, 0xd2ac, 0x1510, 0x6240, 0xa294, 0x0010, 0x0130,
+	0x6248, 0xa294, 0xff00, 0xa296, 0xff00, 0x01c0, 0x7030, 0xd08c,
+	0x0904, 0x267b, 0x7034, 0xd08c, 0x1140, 0x2001, 0xb50c, 0x200c,
+	0xd1ac, 0x1904, 0x267b, 0xc1ad, 0x2102, 0x0036, 0x73cc, 0x2011,
+	0x8013, 0x080c, 0x3ecc, 0x003e, 0x0804, 0x267b, 0x7034, 0xd08c,
+	0x1140, 0x2001, 0xb50c, 0x200c, 0xd1ac, 0x1904, 0x267b, 0xc1ad,
+	0x2102, 0x0036, 0x73cc, 0x2011, 0x8013, 0x080c, 0x3ecc, 0x003e,
+	0x7130, 0xc185, 0x7132, 0x2011, 0xb553, 0x220c, 0xd1a4, 0x01d0,
+	0x0016, 0x2009, 0x0001, 0x2011, 0x0100, 0x080c, 0x6b1a, 0x2019,
+	0x000e, 0x080c, 0xb065, 0xa484, 0x00ff, 0xa080, 0x2dc4, 0x200d,
+	0xa18c, 0xff00, 0x810f, 0x8127, 0xa006, 0x2009, 0x000e, 0x080c,
+	0xb0e8, 0x001e, 0xd1ac, 0x1148, 0x0016, 0x2009, 0x0000, 0x2019,
+	0x0004, 0x080c, 0x2c6f, 0x001e, 0x0070, 0x0156, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0x080c, 0x4fa9, 0x1110, 0x080c, 0x4c0b, 0x8108,
+	0x1f04, 0x2672, 0x015e, 0x00ce, 0x004e, 0x2011, 0x0003, 0x080c,
+	0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c, 0x7f59, 0x0036,
+	0x2019, 0x0000, 0x080c, 0x7fe4, 0x003e, 0x60e3, 0x0000, 0x001e,
+	0x2001, 0xb500, 0x2014, 0xa296, 0x0004, 0x1128, 0xd19c, 0x11b0,
+	0x6228, 0xc29d, 0x622a, 0x2003, 0x0001, 0x2001, 0xb523, 0x2003,
+	0x0000, 0x6027, 0x0020, 0x080c, 0x5af5, 0x1140, 0x0016, 0x2009,
+	0x07d0, 0x2011, 0x59e4, 0x080c, 0x6a22, 0x001e, 0xd194, 0x0904,
+	0x2766, 0x0016, 0x6220, 0xd2b4, 0x0904, 0x2717, 0x080c, 0x6a10,
+	0x080c, 0x7d7a, 0x6027, 0x0004, 0x00f6, 0x2019, 0xb7e9, 0x2304,
+	0xa07d, 0x0570, 0x7804, 0xa086, 0x0032, 0x1550, 0x00d6, 0x00c6,
+	0x00e6, 0x2069, 0x0140, 0x618c, 0x6288, 0x7818, 0x608e, 0x7808,
+	0x608a, 0x6043, 0x0002, 0x2001, 0x0003, 0x8001, 0x1df0, 0x6043,
+	0x0000, 0x6803, 0x1000, 0x6803, 0x0000, 0x618e, 0x628a, 0x080c,
+	0x7090, 0x080c, 0x7173, 0x7810, 0x2070, 0x7037, 0x0103, 0x2f60,
+	0x080c, 0x861d, 0x00ee, 0x00ce, 0x00de, 0x00fe, 0x001e, 0x0005,
+	0x00fe, 0x00d6, 0x2069, 0x0140, 0x6804, 0xa084, 0x4000, 0x0120,
+	0x6803, 0x1000, 0x6803, 0x0000, 0x00de, 0x00c6, 0x2061, 0xb7e0,
+	0x6028, 0xa09a, 0x00c8, 0x1238, 0x8000, 0x602a, 0x00ce, 0x080c,
+	0x7d6d, 0x0804, 0x2765, 0x2019, 0xb7e9, 0x2304, 0xa065, 0x0120,
+	0x2009, 0x0027, 0x080c, 0x864c, 0x00ce, 0x0804, 0x2765, 0xd2bc,
+	0x0904, 0x2765, 0x080c, 0x6a1d, 0x6014, 0xa084, 0x0184, 0xa085,
+	0x0010, 0x6016, 0x6027, 0x0004, 0x00d6, 0x2069, 0x0140, 0x6804,
+	0xa084, 0x4000, 0x0120, 0x6803, 0x1000, 0x6803, 0x0000, 0x00de,
+	0x00c6, 0x2061, 0xb7e0, 0x6044, 0xa09a, 0x00c8, 0x12f0, 0x8000,
+	0x6046, 0x603c, 0x00ce, 0xa005, 0x0540, 0x2009, 0x07d0, 0x080c,
+	0x6a15, 0xa080, 0x0007, 0x2004, 0xa086, 0x0006, 0x1138, 0x6114,
+	0xa18c, 0x0184, 0xa18d, 0x0012, 0x6116, 0x00b8, 0x6114, 0xa18c,
+	0x0184, 0xa18d, 0x0016, 0x6116, 0x0080, 0x0036, 0x2019, 0x0001,
+	0x080c, 0x7fe4, 0x003e, 0x2019, 0xb7ef, 0x2304, 0xa065, 0x0120,
+	0x2009, 0x004f, 0x080c, 0x864c, 0x00ce, 0x001e, 0xd19c, 0x0904,
+	0x27bf, 0x7034, 0xd0ac, 0x1560, 0x0016, 0x0156, 0x6027, 0x0008,
+	0x602f, 0x0020, 0x20a9, 0x0006, 0x1d04, 0x2774, 0x2091, 0x6000,
+	0x1f04, 0x2774, 0x602f, 0x0000, 0x6150, 0xa185, 0x1400, 0x6052,
+	0x20a9, 0x0366, 0x1d04, 0x2782, 0x2091, 0x6000, 0x6020, 0xd09c,
+	0x1130, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008, 0x0480, 0x080c,
+	0x2907, 0x1f04, 0x2782, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008,
+	0x0016, 0x6028, 0xc09c, 0x602a, 0x2011, 0x0003, 0x080c, 0x8075,
+	0x2011, 0x0002, 0x080c, 0x807f, 0x080c, 0x7f59, 0x0036, 0x2019,
+	0x0000, 0x080c, 0x7fe4, 0x003e, 0x60e3, 0x0000, 0x080c, 0xb42f,
+	0x080c, 0xb44a, 0xa085, 0x0001, 0x080c, 0x5b13, 0x2001, 0xb500,
+	0x2003, 0x0004, 0x6027, 0x0008, 0x080c, 0x12dd, 0x001e, 0xa18c,
+	0xffd0, 0x6126, 0x0005, 0x0006, 0x0016, 0x0026, 0x00e6, 0x00f6,
+	0x0126, 0x2091, 0x8000, 0x2071, 0xb500, 0x71c4, 0x70c6, 0xa116,
+	0x0500, 0x81ff, 0x0128, 0x2011, 0x8011, 0x080c, 0x3ecc, 0x00c8,
+	0x2011, 0x8012, 0x080c, 0x3ecc, 0x2001, 0xb572, 0x2004, 0xd0fc,
+	0x1180, 0x0036, 0x00c6, 0x080c, 0x2892, 0x080c, 0x7f35, 0x2061,
+	0x0100, 0x2019, 0x0028, 0x2009, 0x0000, 0x080c, 0x2c6f, 0x00ce,
+	0x003e, 0x012e, 0x00fe, 0x00ee, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x00c6, 0x00f6, 0x0006, 0x0026, 0x2061, 0x0100, 0xa190, 0x280b,
+	0x2205, 0x60f2, 0x2011, 0x2818, 0x2205, 0x60ee, 0x002e, 0x000e,
+	0x00fe, 0x00ce, 0x0005, 0x0840, 0x0840, 0x0840, 0x0580, 0x0420,
+	0x0348, 0x02c0, 0x0258, 0x0210, 0x01a8, 0x01a8, 0x01a8, 0x01a8,
+	0x0140, 0x00f8, 0x00d0, 0x00b0, 0x00a0, 0x2028, 0xa18c, 0x00ff,
+	0x2130, 0xa094, 0xff00, 0x1110, 0x81ff, 0x0118, 0x080c, 0x66b1,
+	0x0038, 0xa080, 0x2dc4, 0x200d, 0xa18c, 0xff00, 0x810f, 0xa006,
+	0x0005, 0xa080, 0x2dc4, 0x200d, 0xa18c, 0x00ff, 0x0005, 0x00d6,
+	0x2069, 0x0140, 0x2001, 0xb515, 0x2003, 0x00ef, 0x20a9, 0x0010,
+	0xa006, 0x6852, 0x6856, 0x1f04, 0x2842, 0x00de, 0x0005, 0x0006,
+	0x00d6, 0x0026, 0x2069, 0x0140, 0x2001, 0xb515, 0x2102, 0x8114,
+	0x8214, 0x8214, 0x8214, 0x20a9, 0x0010, 0x6853, 0x0000, 0xa006,
+	0x82ff, 0x1128, 0xa184, 0x000f, 0xa080, 0xb45e, 0x2005, 0x6856,
+	0x8211, 0x1f04, 0x2857, 0x002e, 0x00de, 0x000e, 0x0005, 0x00c6,
+	0x2061, 0xb500, 0x6030, 0x0110, 0xc09d, 0x0008, 0xc09c, 0x6032,
+	0x00ce, 0x0005, 0x0156, 0x00d6, 0x0026, 0x0016, 0x0006, 0x2069,
+	0x0140, 0x6980, 0xa116, 0x0180, 0xa112, 0x1230, 0x8212, 0x8210,
+	0x22a8, 0x2001, 0x0402, 0x0018, 0x22a8, 0x2001, 0x0404, 0x680e,
+	0x1f04, 0x2887, 0x680f, 0x0000, 0x000e, 0x001e, 0x002e, 0x00de,
+	0x015e, 0x0005, 0x2001, 0xb553, 0x2004, 0xd0c4, 0x0150, 0xd0a4,
+	0x0140, 0xa006, 0x0046, 0x2020, 0x2009, 0x002e, 0x080c, 0xb0e8,
+	0x004e, 0x0005, 0x00f6, 0x0016, 0x0026, 0x2079, 0x0140, 0x78c4,
+	0xd0dc, 0x0548, 0xa084, 0x0700, 0xa08e, 0x0300, 0x1520, 0x2011,
+	0x0000, 0x2009, 0x0002, 0x2300, 0xa080, 0x0020, 0x2018, 0x2300,
+	0x080c, 0x6b40, 0x2011, 0x0030, 0x2200, 0x8007, 0xa085, 0x004c,
+	0x78c2, 0x2009, 0x0204, 0x210c, 0x2200, 0xa100, 0x2009, 0x0138,
+	0x200a, 0x080c, 0x5acf, 0x1118, 0x2009, 0xb78f, 0x200a, 0x002e,
+	0x001e, 0x00fe, 0x0005, 0x78c3, 0x0000, 0x0cc8, 0x0126, 0x2091,
+	0x2800, 0x0006, 0x0016, 0x0026, 0x2001, 0x0170, 0x200c, 0x8000,
+	0x2014, 0xa184, 0x0003, 0x0110, 0x0804, 0x1b04, 0x002e, 0x001e,
+	0x000e, 0x012e, 0x0005, 0x0006, 0x2001, 0x0100, 0x2004, 0xa082,
+	0x0005, 0x000e, 0x0268, 0x2001, 0x0170, 0x200c, 0xa18c, 0x00ff,
+	0xa18e, 0x004c, 0x1128, 0x200c, 0xa18c, 0xff00, 0x810f, 0x0010,
+	0x2009, 0x0000, 0x2001, 0x0204, 0x2004, 0xa108, 0x0005, 0x0006,
+	0x0156, 0x00f6, 0x2079, 0x0100, 0x20a9, 0x000a, 0x7854, 0xd08c,
+	0x1110, 0x1f04, 0x290e, 0x00fe, 0x015e, 0x000e, 0x0005, 0x0016,
+	0x00c6, 0x0006, 0x2061, 0x0100, 0x6030, 0x0006, 0x6048, 0x0006,
+	0x60e4, 0x0006, 0x60e8, 0x0006, 0x6050, 0x0006, 0x60f0, 0x0006,
+	0x60ec, 0x0006, 0x600c, 0x0006, 0x6004, 0x0006, 0x6028, 0x0006,
+	0x60e0, 0x0006, 0x602f, 0x0100, 0x602f, 0x0000, 0xe000, 0xe000,
+	0xe000, 0xe000, 0x602f, 0x0040, 0x602f, 0x0000, 0x000e, 0x60e2,
+	0x000e, 0x602a, 0x000e, 0x6006, 0x000e, 0x600e, 0x000e, 0x60ee,
+	0x000e, 0x60f2, 0x000e, 0x6052, 0x000e, 0x60ea, 0x000e, 0x60e6,
+	0x000e, 0x604a, 0x000e, 0x6032, 0x6036, 0x2008, 0x080c, 0x2847,
+	0x000e, 0x00ce, 0x001e, 0x0005, 0x2009, 0x0171, 0x2104, 0xd0dc,
+	0x0140, 0x2009, 0x0170, 0x2104, 0x200b, 0x0080, 0xe000, 0xe000,
+	0x200a, 0x0005, 0x29fa, 0x29fe, 0x2a02, 0x2a08, 0x2a0e, 0x2a14,
+	0x2a1a, 0x2a22, 0x2a2a, 0x2a30, 0x2a36, 0x2a3e, 0x2a46, 0x2a4e,
+	0x2a56, 0x2a60, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2a6c, 0x2a6c, 0x2a72, 0x2a72, 0x2a79, 0x2a79,
+	0x2a80, 0x2a80, 0x2a89, 0x2a89, 0x2a90, 0x2a90, 0x2a99, 0x2a99,
+	0x2aa2, 0x2aa2, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad, 0x2aad,
+	0x2aad, 0x2aad, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a, 0x2a6a,
+	0x2a6a, 0x2a6a, 0x0106, 0x0006, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x2519, 0x0804, 0x2ab5,
+	0x0106, 0x0006, 0x080c, 0x2519, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x239c, 0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x239c,
+	0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x2519, 0x080c, 0x239c,
+	0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x2519, 0x080c, 0x239c,
+	0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x23f2, 0x0804, 0x2ab5,
+	0x0106, 0x0006, 0x080c, 0x23f2, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x2519, 0x080c, 0x23f2, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x2519, 0x080c, 0x23f2, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x239c, 0x080c, 0x23f2, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x239c, 0x080c, 0x23f2, 0x0804, 0x2ab5, 0x0106, 0x0006,
+	0x080c, 0x2519, 0x080c, 0x239c, 0x080c, 0x23f2, 0x0804, 0x2ab5,
+	0x0106, 0x0006, 0x080c, 0x2519, 0x080c, 0x239c, 0x080c, 0x23f2,
+	0x0804, 0x2ab5, 0xe000, 0x0cf0, 0x0106, 0x0006, 0x080c, 0x28d6,
+	0x0804, 0x2ab5, 0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x2519,
+	0x04e0, 0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x239c, 0x04a8,
+	0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x2519, 0x080c, 0x239c,
+	0x0460, 0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x23f2, 0x0428,
+	0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x2519, 0x080c, 0x23f2,
+	0x00e0, 0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x239c, 0x080c,
+	0x23f2, 0x0098, 0x0106, 0x0006, 0x080c, 0x28d6, 0x080c, 0x2519,
+	0x080c, 0x239c, 0x080c, 0x23f2, 0x0040, 0x20d1, 0x0000, 0x20d1,
+	0x0001, 0x20d1, 0x0000, 0x080c, 0x1515, 0x000e, 0x010e, 0x000d,
+	0x00c6, 0x0026, 0x0046, 0x2021, 0x0000, 0x080c, 0x5309, 0x1904,
+	0x2b95, 0x72d4, 0x2001, 0xb79e, 0x2004, 0xa005, 0x1110, 0xd29c,
+	0x0148, 0xd284, 0x1138, 0xd2bc, 0x1904, 0x2b95, 0x080c, 0x2b99,
+	0x0804, 0x2b95, 0xd2cc, 0x1904, 0x2b95, 0x080c, 0x5acf, 0x1120,
+	0x709f, 0xffff, 0x0804, 0x2b95, 0xd294, 0x0120, 0x709f, 0xffff,
+	0x0804, 0x2b95, 0x2001, 0xb515, 0x203c, 0x7288, 0xd284, 0x0904,
+	0x2b37, 0xd28c, 0x1904, 0x2b37, 0x0036, 0x739c, 0xa38e, 0xffff,
+	0x1110, 0x2019, 0x0001, 0x8314, 0xa2e0, 0xbcc0, 0x2c04, 0xa38c,
+	0x0001, 0x0120, 0xa084, 0xff00, 0x8007, 0x0010, 0xa084, 0x00ff,
+	0xa70e, 0x0560, 0xa08e, 0x0000, 0x0548, 0xa08e, 0x00ff, 0x1150,
+	0x7230, 0xd284, 0x1538, 0x7288, 0xc28d, 0x728a, 0x709f, 0xffff,
+	0x003e, 0x0428, 0x2009, 0x0000, 0x080c, 0x281d, 0x080c, 0x4f4d,
+	0x11b8, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1150, 0x7030,
+	0xd08c, 0x0118, 0x6000, 0xd0bc, 0x0120, 0x080c, 0x2bac, 0x0140,
+	0x0028, 0x080c, 0x2cdd, 0x080c, 0x2bda, 0x0110, 0x8318, 0x0818,
+	0x739e, 0x0010, 0x709f, 0xffff, 0x003e, 0x0804, 0x2b95, 0xa780,
+	0x2dc4, 0x203d, 0xa7bc, 0xff00, 0x873f, 0x2041, 0x007e, 0x709c,
+	0xa096, 0xffff, 0x1120, 0x2009, 0x0000, 0x28a8, 0x0050, 0xa812,
+	0x0220, 0x2008, 0xa802, 0x20a8, 0x0020, 0x709f, 0xffff, 0x0804,
+	0x2b95, 0x2700, 0x0156, 0x0016, 0xa106, 0x05a0, 0xc484, 0x080c,
+	0x4fa9, 0x0120, 0x080c, 0x4f4d, 0x15a8, 0x0008, 0xc485, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x1130, 0x7030, 0xd08c, 0x01e8,
+	0x6000, 0xd0bc, 0x11d0, 0x7288, 0xd28c, 0x0188, 0x6004, 0xa084,
+	0x00ff, 0xa082, 0x0006, 0x02b0, 0xd484, 0x1118, 0x080c, 0x4f6c,
+	0x0028, 0x080c, 0x2d6a, 0x0170, 0x080c, 0x2d97, 0x0058, 0x080c,
+	0x2cdd, 0x080c, 0x2bda, 0x0170, 0x0028, 0x080c, 0x2d6a, 0x0110,
+	0x0419, 0x0140, 0x001e, 0x8108, 0x015e, 0x1f04, 0x2b51, 0x709f,
+	0xffff, 0x0018, 0x001e, 0x015e, 0x719e, 0x004e, 0x002e, 0x00ce,
+	0x0005, 0x00c6, 0x0016, 0x709f, 0x0001, 0x2009, 0x007e, 0x080c,
+	0x4f4d, 0x1138, 0x080c, 0x2cdd, 0x04a9, 0x0118, 0x70d4, 0xc0bd,
+	0x70d6, 0x001e, 0x00ce, 0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6,
+	0x2c68, 0x2001, 0xb557, 0x2004, 0xa084, 0x00ff, 0x6842, 0x080c,
+	0x9ed6, 0x01d8, 0x2d00, 0x601a, 0x080c, 0xa027, 0x601f, 0x0001,
+	0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001, 0x0000, 0x080c, 0x4efd,
+	0x0126, 0x2091, 0x8000, 0x7098, 0x8000, 0x709a, 0x012e, 0x2009,
+	0x0004, 0x080c, 0x864c, 0xa085, 0x0001, 0x00ce, 0x00de, 0x007e,
+	0x001e, 0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6, 0x2c68, 0x2001,
+	0xb557, 0x2004, 0xa084, 0x00ff, 0x6842, 0x080c, 0x9ed6, 0x0550,
+	0x2d00, 0x601a, 0x6800, 0xc0c4, 0x6802, 0x68a0, 0xa086, 0x007e,
+	0x0140, 0x6804, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1110, 0x080c,
+	0x2c9c, 0x080c, 0xa027, 0x601f, 0x0001, 0x2001, 0x0000, 0x080c,
+	0x4eeb, 0x2001, 0x0002, 0x080c, 0x4efd, 0x0126, 0x2091, 0x8000,
+	0x7098, 0x8000, 0x709a, 0x012e, 0x2009, 0x0002, 0x080c, 0x864c,
+	0xa085, 0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005, 0x00c6,
+	0x0026, 0x2009, 0x0080, 0x080c, 0x4f4d, 0x1120, 0x0031, 0x0110,
+	0x70db, 0xffff, 0x002e, 0x00ce, 0x0005, 0x0016, 0x0076, 0x00d6,
+	0x00c6, 0x2c68, 0x080c, 0x85c7, 0x01e8, 0x2d00, 0x601a, 0x080c,
+	0xa027, 0x601f, 0x0001, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001,
+	0x0002, 0x080c, 0x4efd, 0x0126, 0x2091, 0x8000, 0x080c, 0x2c9c,
+	0x70dc, 0x8000, 0x70de, 0x012e, 0x2009, 0x0002, 0x080c, 0x864c,
+	0xa085, 0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005, 0x00c6,
+	0x00d6, 0x0126, 0x2091, 0x8000, 0x2009, 0x007f, 0x080c, 0x4f4d,
+	0x1190, 0x2c68, 0x080c, 0x85c7, 0x0170, 0x2d00, 0x601a, 0x6312,
+	0x601f, 0x0001, 0x620a, 0x080c, 0xa027, 0x2009, 0x0022, 0x080c,
+	0x864c, 0xa085, 0x0001, 0x012e, 0x00de, 0x00ce, 0x0005, 0x00e6,
+	0x00c6, 0x0066, 0x0036, 0x0026, 0x080c, 0x6e01, 0x080c, 0x6da4,
+	0x080c, 0x906f, 0x2130, 0x81ff, 0x0128, 0x20a9, 0x007e, 0x2009,
+	0x0000, 0x0020, 0x20a9, 0x007f, 0x2009, 0x0000, 0x0016, 0x080c,
+	0x4fa9, 0x1120, 0x080c, 0x51aa, 0x080c, 0x4c0b, 0x001e, 0x8108,
+	0x1f04, 0x2c86, 0x86ff, 0x1110, 0x080c, 0x11f0, 0x002e, 0x003e,
+	0x006e, 0x00ce, 0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0036, 0x0026,
+	0x0016, 0x6218, 0x2270, 0x72a0, 0x0026, 0x2019, 0x0029, 0x080c,
+	0x6df5, 0x0076, 0x2039, 0x0000, 0x080c, 0x6d02, 0x2c08, 0x080c,
+	0xae82, 0x007e, 0x001e, 0x2e60, 0x080c, 0x51aa, 0x6210, 0x6314,
+	0x080c, 0x4c0b, 0x6212, 0x6316, 0x001e, 0x002e, 0x003e, 0x00ce,
+	0x00ee, 0x0005, 0x00e6, 0x0006, 0x6018, 0xa080, 0x0028, 0x2004,
+	0xa086, 0x0080, 0x0150, 0x2071, 0xb500, 0x7098, 0xa005, 0x0110,
+	0x8001, 0x709a, 0x000e, 0x00ee, 0x0005, 0x2071, 0xb500, 0x70dc,
+	0xa005, 0x0dc0, 0x8001, 0x70de, 0x0ca8, 0x6000, 0xc08c, 0x6002,
+	0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x0156,
+	0x2178, 0x81ff, 0x1118, 0x20a9, 0x0001, 0x0098, 0x2001, 0xb553,
+	0x2004, 0xd0c4, 0x0150, 0xd0a4, 0x0140, 0xa006, 0x0046, 0x2020,
+	0x2009, 0x002d, 0x080c, 0xb0e8, 0x004e, 0x20a9, 0x00ff, 0x2011,
+	0x0000, 0x0026, 0xa28e, 0x007e, 0x0904, 0x2d49, 0xa28e, 0x007f,
+	0x0904, 0x2d49, 0xa28e, 0x0080, 0x05e0, 0xa288, 0xb635, 0x210c,
+	0x81ff, 0x05b8, 0x8fff, 0x1148, 0x2001, 0xb7be, 0x0006, 0x2003,
+	0x0001, 0x04d9, 0x000e, 0x2003, 0x0000, 0x00c6, 0x2160, 0x2001,
+	0x0001, 0x080c, 0x5313, 0x00ce, 0x2019, 0x0029, 0x080c, 0x6df5,
+	0x0076, 0x2039, 0x0000, 0x080c, 0x6d02, 0x00c6, 0x0026, 0x2160,
+	0x6204, 0xa294, 0x00ff, 0xa286, 0x0006, 0x1118, 0x6007, 0x0404,
+	0x0028, 0x2001, 0x0004, 0x8007, 0xa215, 0x6206, 0x002e, 0x00ce,
+	0x0016, 0x2c08, 0x080c, 0xae82, 0x001e, 0x007e, 0x2160, 0x080c,
+	0x51aa, 0x002e, 0x8210, 0x1f04, 0x2d01, 0x015e, 0x001e, 0x002e,
+	0x003e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x0046, 0x0026, 0x0016,
+	0x2001, 0xb553, 0x2004, 0xd0c4, 0x0148, 0xd0a4, 0x0138, 0xa006,
+	0x2220, 0x8427, 0x2009, 0x0029, 0x080c, 0xb0e8, 0x001e, 0x002e,
+	0x004e, 0x0005, 0x0016, 0x0026, 0x0036, 0x00c6, 0x7288, 0x82ff,
+	0x01f8, 0x2011, 0xb553, 0x2214, 0xd2ac, 0x11d0, 0x2100, 0x080c,
+	0x2831, 0x81ff, 0x01b8, 0x2019, 0x0001, 0x8314, 0xa2e0, 0xbcc0,
+	0x2c04, 0xd384, 0x0120, 0xa084, 0xff00, 0x8007, 0x0010, 0xa084,
+	0x00ff, 0xa116, 0x0138, 0xa096, 0x00ff, 0x0110, 0x8318, 0x0c68,
+	0xa085, 0x0001, 0x00ce, 0x003e, 0x002e, 0x001e, 0x0005, 0x0016,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x0016, 0x0026, 0x0036, 0x2110,
+	0x0026, 0x2019, 0x0029, 0x080c, 0x8299, 0x002e, 0x080c, 0xb38d,
+	0x003e, 0x002e, 0x001e, 0xa180, 0xb635, 0x2004, 0xa065, 0x0158,
+	0x0016, 0x00c6, 0x2061, 0xb8f4, 0x001e, 0x611a, 0x080c, 0x2c9c,
+	0x001e, 0x080c, 0x4f6c, 0x012e, 0x00ce, 0x001e, 0x0005, 0x2001,
+	0xb535, 0x2004, 0xd0cc, 0x0005, 0x7eef, 0x7de8, 0x7ce4, 0x80e2,
+	0x7be1, 0x80e0, 0x80dc, 0x80da, 0x7ad9, 0x80d6, 0x80d5, 0x80d4,
+	0x80d3, 0x80d2, 0x80d1, 0x79ce, 0x78cd, 0x80cc, 0x80cb, 0x80ca,
+	0x80c9, 0x80c7, 0x80c6, 0x77c5, 0x76c3, 0x80bc, 0x80ba, 0x75b9,
+	0x80b6, 0x74b5, 0x73b4, 0x72b3, 0x80b2, 0x80b1, 0x80ae, 0x71ad,
+	0x80ac, 0x70ab, 0x6faa, 0x6ea9, 0x80a7, 0x6da6, 0x6ca5, 0x6ba3,
+	0x6a9f, 0x699e, 0x689d, 0x809b, 0x8098, 0x6797, 0x6690, 0x658f,
+	0x6488, 0x6384, 0x6282, 0x8081, 0x8080, 0x617c, 0x607a, 0x8079,
+	0x5f76, 0x8075, 0x8074, 0x8073, 0x8072, 0x8071, 0x806e, 0x5e6d,
+	0x806c, 0x5d6b, 0x5c6a, 0x5b69, 0x8067, 0x5a66, 0x5965, 0x5863,
+	0x575c, 0x565a, 0x5559, 0x8056, 0x8055, 0x5454, 0x5353, 0x5252,
+	0x5151, 0x504e, 0x4f4d, 0x804c, 0x804b, 0x4e4a, 0x4d49, 0x8047,
+	0x4c46, 0x8045, 0x8043, 0x803c, 0x803a, 0x8039, 0x8036, 0x4b35,
+	0x8034, 0x4a33, 0x4932, 0x4831, 0x802e, 0x472d, 0x462c, 0x452b,
+	0x442a, 0x4329, 0x4227, 0x8026, 0x8025, 0x4123, 0x401f, 0x3f1e,
+	0x3e1d, 0x3d1b, 0x3c18, 0x8017, 0x8010, 0x3b0f, 0x3a08, 0x8004,
+	0x3902, 0x8001, 0x8000, 0x8000, 0x3800, 0x3700, 0x3600, 0x8000,
+	0x3500, 0x8000, 0x8000, 0x8000, 0x3400, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x3300, 0x3200, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x3100, 0x3000, 0x8000, 0x8000, 0x2f00,
+	0x8000, 0x2e00, 0x2d00, 0x2c00, 0x8000, 0x8000, 0x8000, 0x2b00,
+	0x8000, 0x2a00, 0x2900, 0x2800, 0x8000, 0x2700, 0x2600, 0x2500,
+	0x2400, 0x2300, 0x2200, 0x8000, 0x8000, 0x2100, 0x2000, 0x1f00,
+	0x1e00, 0x1d00, 0x1c00, 0x8000, 0x8000, 0x1b00, 0x1a00, 0x8000,
+	0x1900, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x1800,
+	0x8000, 0x1700, 0x1600, 0x1500, 0x8000, 0x1400, 0x1300, 0x1200,
+	0x1100, 0x1000, 0x0f00, 0x8000, 0x8000, 0x0e00, 0x0d00, 0x0c00,
+	0x0b00, 0x0a00, 0x0900, 0x8000, 0x8000, 0x0800, 0x0700, 0x8000,
+	0x0600, 0x8000, 0x8000, 0x8000, 0x0500, 0x0400, 0x0300, 0x8000,
+	0x0200, 0x8000, 0x8000, 0x8000, 0x0100, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x0000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x2071, 0xb582, 0x7003, 0x0002,
+	0xa006, 0x7012, 0x7016, 0x703a, 0x703e, 0x7033, 0xb592, 0x7037,
+	0xb592, 0x7007, 0x0001, 0x2061, 0xb5d2, 0x6003, 0x0002, 0x0005,
+	0x1004, 0x2eea, 0x0e04, 0x2eea, 0x2071, 0xb582, 0x2b78, 0x7818,
+	0xd084, 0x1140, 0x2a60, 0x7820, 0xa08e, 0x0069, 0x1904, 0x2fcf,
+	0x0804, 0x2f68, 0x0005, 0x2071, 0xb582, 0x7004, 0x0002, 0x2ef3,
+	0x2ef4, 0x2efd, 0x2f0e, 0x0005, 0x1004, 0x2efc, 0x0e04, 0x2efc,
+	0x2b78, 0x7818, 0xd084, 0x01e8, 0x0005, 0x2b78, 0x2061, 0xb5d2,
+	0x6008, 0xa08e, 0x0100, 0x0128, 0xa086, 0x0200, 0x0904, 0x2fc9,
+	0x0005, 0x7014, 0x2068, 0x2a60, 0x7018, 0x0807, 0x7010, 0x2068,
+	0x6834, 0xa086, 0x0103, 0x0108, 0x0005, 0x2a60, 0x2b78, 0x7018,
+	0x0807, 0x2a60, 0x7820, 0xa08a, 0x0040, 0x1210, 0x61c4, 0x0042,
+	0x2100, 0xa08a, 0x003f, 0x1a04, 0x2fc6, 0x61c4, 0x0804, 0x2f68,
+	0x2faa, 0x2fd5, 0x2fdd, 0x2fe1, 0x2fe9, 0x2fef, 0x2ff3, 0x2fff,
+	0x3002, 0x300c, 0x300f, 0x2fc6, 0x2fc6, 0x2fc6, 0x3012, 0x2fc6,
+	0x3021, 0x3038, 0x304f, 0x30c9, 0x30ce, 0x30f7, 0x3148, 0x3159,
+	0x3178, 0x31b0, 0x31ba, 0x31c7, 0x31da, 0x31fb, 0x3204, 0x323a,
+	0x3240, 0x2fc6, 0x3269, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6,
+	0x3270, 0x327a, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6,
+	0x2fc6, 0x2fc6, 0x3282, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6,
+	0x3294, 0x329e, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6,
+	0x0002, 0x32c8, 0x331c, 0x3377, 0x3391, 0x2fc6, 0x33c2, 0x37f5,
+	0x4233, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6,
+	0x2fc6, 0x300c, 0x300f, 0x37f7, 0x2fc6, 0x3804, 0x42cc, 0x4327,
+	0x438b, 0x2fc6, 0x43ee, 0x4418, 0x4437, 0x4469, 0x2fc6, 0x2fc6,
+	0x2fc6, 0x3808, 0x39ad, 0x39c7, 0x39e5, 0x3a46, 0x3aa6, 0x3ab1,
+	0x3ae9, 0x3af8, 0x3b07, 0x3b0a, 0x3b2d, 0x3b79, 0x3bef, 0x3bfc,
+	0x3cfd, 0x3e23, 0x3e4c, 0x3f4a, 0x3f6c, 0x3f78, 0x3fb1, 0x4075,
+	0x2fc6, 0x2fc6, 0x2fc6, 0x2fc6, 0x40dd, 0x40f8, 0x416a, 0x421c,
+	0x713c, 0x0000, 0x2021, 0x4000, 0x080c, 0x3ea9, 0x0126, 0x2091,
+	0x8000, 0x0e04, 0x2fb6, 0x7818, 0xd084, 0x0110, 0x012e, 0x0cb0,
+	0x7c22, 0x7926, 0x7a2a, 0x7b2e, 0x781b, 0x0001, 0x2091, 0x4080,
+	0x7007, 0x0001, 0x2091, 0x5000, 0x012e, 0x0005, 0x2021, 0x4001,
+	0x0c18, 0x2021, 0x4002, 0x0c00, 0x2021, 0x4003, 0x08e8, 0x2021,
+	0x4005, 0x08d0, 0x2021, 0x4006, 0x08b8, 0xa02e, 0x2520, 0x7b28,
+	0x7a2c, 0x7824, 0x7930, 0x0804, 0x3eb6, 0x7823, 0x0004, 0x7824,
+	0x0807, 0xa02e, 0x2520, 0x7b28, 0x7a2c, 0x7824, 0x7930, 0x0804,
+	0x3eb9, 0x7924, 0x7828, 0x2114, 0x200a, 0x0804, 0x2faa, 0x7924,
+	0x2114, 0x0804, 0x2faa, 0x2099, 0x0009, 0x20a1, 0x0009, 0x20a9,
+	0x0007, 0x53a3, 0x7924, 0x7a28, 0x7b2c, 0x0804, 0x2faa, 0x7824,
+	0x2060, 0x0090, 0x2009, 0x0002, 0x2011, 0x0002, 0x2019, 0x0006,
+	0x783b, 0x0017, 0x0804, 0x2faa, 0x7d38, 0x7c3c, 0x0840, 0x7d38,
+	0x7c3c, 0x0888, 0x2061, 0x1000, 0xe10c, 0xa006, 0x2c15, 0xa200,
+	0x8c60, 0x8109, 0x1dd8, 0x2010, 0xa005, 0x0904, 0x2faa, 0x0804,
+	0x2fcc, 0x2069, 0xb552, 0x7824, 0x7930, 0xa11a, 0x1a04, 0x2fd2,
+	0x8019, 0x0904, 0x2fd2, 0x684a, 0x6942, 0x782c, 0x6852, 0x7828,
+	0x6856, 0xa006, 0x685a, 0x685e, 0x080c, 0x5da5, 0x0804, 0x2faa,
+	0x2069, 0xb552, 0x7824, 0x7934, 0xa11a, 0x1a04, 0x2fd2, 0x8019,
+	0x0904, 0x2fd2, 0x684e, 0x6946, 0x782c, 0x6862, 0x7828, 0x6866,
+	0xa006, 0x686a, 0x686e, 0x080c, 0x53d5, 0x0804, 0x2faa, 0xa02e,
+	0x2520, 0x81ff, 0x1904, 0x2fcf, 0x7924, 0x7b28, 0x7a2c, 0x20a9,
+	0x0005, 0x20a1, 0xb589, 0x41a1, 0x080c, 0x3e75, 0x0904, 0x2fcf,
+	0x2009, 0x0020, 0x080c, 0x3eb6, 0x701b, 0x3067, 0x0005, 0x6834,
+	0x2008, 0xa084, 0x00ff, 0xa096, 0x0011, 0x0138, 0xa096, 0x0019,
+	0x0120, 0xa096, 0x0015, 0x1904, 0x2fcf, 0x810f, 0xa18c, 0x00ff,
+	0x0904, 0x2fcf, 0x710e, 0x700c, 0x8001, 0x0528, 0x700e, 0x080c,
+	0x3e75, 0x0904, 0x2fcf, 0x2009, 0x0020, 0x2061, 0xb5d2, 0x6224,
+	0x6328, 0x642c, 0x6530, 0xa290, 0x0040, 0xa399, 0x0000, 0xa4a1,
+	0x0000, 0xa5a9, 0x0000, 0x080c, 0x3eb6, 0x701b, 0x3098, 0x0005,
+	0x6834, 0xa084, 0x00ff, 0xa096, 0x0002, 0x0120, 0xa096, 0x000a,
+	0x1904, 0x2fcf, 0x08c0, 0x7010, 0x2068, 0x6838, 0xc0fd, 0x683a,
+	0x080c, 0x4e49, 0x1128, 0x7007, 0x0003, 0x701b, 0x30b2, 0x0005,
+	0x080c, 0x54db, 0x0126, 0x2091, 0x8000, 0x20a9, 0x0005, 0x2099,
+	0xb589, 0x530a, 0x2100, 0xa210, 0xa399, 0x0000, 0xa4a1, 0x0000,
+	0xa5a9, 0x0000, 0xad80, 0x000d, 0x2009, 0x0020, 0x012e, 0x0804,
+	0x3eb9, 0x61ac, 0x7824, 0x60ae, 0x0804, 0x2faa, 0x2091, 0x8000,
+	0x7823, 0x4000, 0x7827, 0x4953, 0x782b, 0x5020, 0x782f, 0x2020,
+	0x2009, 0x017f, 0x2104, 0x7832, 0x3f00, 0x7836, 0x2061, 0x0100,
+	0x6200, 0x2061, 0x0200, 0x603c, 0x8007, 0xa205, 0x783a, 0x2009,
+	0x04fd, 0x2104, 0x783e, 0x781b, 0x0001, 0x2091, 0x5000, 0x2091,
+	0x4080, 0x2071, 0x0010, 0x20c1, 0x00f0, 0x0804, 0x0427, 0x81ff,
+	0x1904, 0x2fcf, 0x7924, 0x810f, 0xa18c, 0x00ff, 0x080c, 0x4fa9,
+	0x1904, 0x2fd2, 0x7e38, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0210,
+	0x0804, 0x2fd2, 0x7c28, 0x7d2c, 0x080c, 0x5171, 0xd28c, 0x1118,
+	0x080c, 0x511a, 0x0010, 0x080c, 0x514a, 0x1518, 0x2061, 0xbd00,
+	0x0126, 0x2091, 0x8000, 0x6000, 0xa086, 0x0000, 0x0148, 0x6010,
+	0xa06d, 0x0130, 0x683c, 0xa406, 0x1118, 0x6840, 0xa506, 0x0150,
+	0x012e, 0xace0, 0x0018, 0x2001, 0xb517, 0x2004, 0xac02, 0x1a04,
+	0x2fcf, 0x0c30, 0x080c, 0x992a, 0x012e, 0x0904, 0x2fcf, 0x0804,
+	0x2faa, 0xa00e, 0x2001, 0x0005, 0x080c, 0x54db, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x9ed2, 0x080c, 0x5408, 0x012e, 0x0804, 0x2faa,
+	0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c,
+	0x506f, 0x0904, 0x2fcf, 0x080c, 0x517d, 0x0904, 0x2fcf, 0x0804,
+	0x2faa, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e9a, 0x0904, 0x2fd2,
+	0x080c, 0x51e9, 0x0904, 0x2fcf, 0x2019, 0x0005, 0x7924, 0x080c,
+	0x5198, 0x0904, 0x2fcf, 0x7828, 0xa08a, 0x1000, 0x1a04, 0x2fd2,
+	0x8003, 0x800b, 0x810b, 0xa108, 0x080c, 0x69a8, 0x0804, 0x2faa,
+	0x0126, 0x2091, 0x8000, 0x81ff, 0x0118, 0x2009, 0x0001, 0x0450,
+	0x2029, 0x00ff, 0x6450, 0x2400, 0xa506, 0x01f8, 0x2508, 0x080c,
+	0x4fa9, 0x11d8, 0x080c, 0x51e9, 0x1128, 0x2009, 0x0002, 0x62b4,
+	0x2518, 0x00c0, 0x2019, 0x0004, 0xa00e, 0x080c, 0x5198, 0x1118,
+	0x2009, 0x0006, 0x0078, 0x7824, 0xa08a, 0x1000, 0x1270, 0x8003,
+	0x800b, 0x810b, 0xa108, 0x080c, 0x69a8, 0x8529, 0x1ae0, 0x012e,
+	0x0804, 0x2faa, 0x012e, 0x0804, 0x2fcf, 0x012e, 0x0804, 0x2fd2,
+	0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c, 0x50d5, 0x080c, 0x5171,
+	0x0804, 0x2faa, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e8a, 0x0904,
+	0x2fd2, 0x080c, 0x50c6, 0x080c, 0x5171, 0x0804, 0x2faa, 0x81ff,
+	0x1904, 0x2fcf, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c, 0x514c,
+	0x0904, 0x2fcf, 0x080c, 0x4e8d, 0x080c, 0x5113, 0x080c, 0x5171,
+	0x0804, 0x2faa, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c, 0x506f,
+	0x0904, 0x2fcf, 0x62a0, 0x2019, 0x0005, 0x00c6, 0x080c, 0x51aa,
+	0x2061, 0x0000, 0x080c, 0x6df5, 0x0076, 0x2039, 0x0000, 0x080c,
+	0x6d02, 0x2009, 0x0000, 0x080c, 0xae82, 0x007e, 0x00ce, 0x080c,
+	0x5171, 0x0804, 0x2faa, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c,
+	0x5171, 0x2208, 0x0804, 0x2faa, 0x0156, 0x00d6, 0x00e6, 0x2069,
+	0xb614, 0x6810, 0x6914, 0xa10a, 0x1210, 0x2009, 0x0000, 0x6816,
+	0x2011, 0x0000, 0x2019, 0x0000, 0x20a9, 0x007e, 0x2069, 0xb635,
+	0x2d04, 0xa075, 0x0130, 0x704c, 0x0071, 0xa210, 0x7080, 0x0059,
+	0xa318, 0x8d68, 0x1f04, 0x3218, 0x2300, 0xa218, 0x00ee, 0x00de,
+	0x015e, 0x0804, 0x2faa, 0x00f6, 0x0016, 0xa07d, 0x0140, 0x2001,
+	0x0000, 0x8000, 0x2f0c, 0x81ff, 0x0110, 0x2178, 0x0cd0, 0x001e,
+	0x00fe, 0x0005, 0x2069, 0xb614, 0x6910, 0x62b0, 0x0804, 0x2faa,
+	0x81ff, 0x1904, 0x2fcf, 0x6150, 0xa190, 0x2dc4, 0x2215, 0xa294,
+	0x00ff, 0x6370, 0x83ff, 0x0108, 0x6274, 0x67d4, 0xd79c, 0x0118,
+	0x2031, 0x0001, 0x0090, 0xd7ac, 0x0118, 0x2031, 0x0003, 0x0068,
+	0xd7a4, 0x0118, 0x2031, 0x0002, 0x0040, 0x080c, 0x5acf, 0x1118,
+	0x2031, 0x0004, 0x0010, 0x2031, 0x0000, 0x7e3a, 0x7f3e, 0x0804,
+	0x2faa, 0x6140, 0x6244, 0x2019, 0xb7b6, 0x231c, 0x0804, 0x2faa,
+	0x0126, 0x2091, 0x8000, 0x6134, 0xa006, 0x2010, 0x6338, 0x012e,
+	0x0804, 0x2faa, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x6244, 0x6338,
+	0x0804, 0x2faa, 0x6140, 0x6244, 0x7824, 0x6042, 0x7b28, 0x6346,
+	0x2069, 0xb552, 0x831f, 0xa305, 0x6816, 0x782c, 0x2069, 0xb7b6,
+	0x2d1c, 0x206a, 0x0804, 0x2faa, 0x0126, 0x2091, 0x8000, 0x7824,
+	0x6036, 0x782c, 0x603a, 0x012e, 0x0804, 0x2faa, 0x7838, 0xa005,
+	0x01a8, 0x7828, 0xa025, 0x0904, 0x2fd2, 0x782c, 0xa02d, 0x0904,
+	0x2fd2, 0xa00e, 0x080c, 0x4fa9, 0x1120, 0x6244, 0x6338, 0x6446,
+	0x653a, 0xa186, 0x00ff, 0x0190, 0x8108, 0x0ca0, 0x080c, 0x3e9a,
+	0x0904, 0x2fd2, 0x7828, 0xa00d, 0x0904, 0x2fd2, 0x782c, 0xa005,
+	0x0904, 0x2fd2, 0x6244, 0x6146, 0x6338, 0x603a, 0x0804, 0x2faa,
+	0x2001, 0xb500, 0x2004, 0xa086, 0x0003, 0x1904, 0x2fcf, 0x00c6,
+	0x2061, 0x0100, 0x7924, 0x810f, 0xa18c, 0x00ff, 0xa196, 0x00ff,
+	0x1130, 0x2001, 0xb515, 0x2004, 0xa085, 0xff00, 0x0078, 0xa182,
+	0x007f, 0x16a0, 0xa188, 0x2dc4, 0x210d, 0xa18c, 0x00ff, 0x2001,
+	0xb515, 0x2004, 0xa116, 0x0550, 0x810f, 0xa105, 0x0126, 0x2091,
+	0x8000, 0x0006, 0x080c, 0x85c7, 0x000e, 0x01e0, 0x601a, 0x600b,
+	0xbc09, 0x601f, 0x0001, 0x080c, 0x3e75, 0x01d8, 0x6837, 0x0000,
+	0x7007, 0x0003, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x701b,
+	0x3370, 0x2d00, 0x6012, 0x2009, 0x0032, 0x080c, 0x864c, 0x012e,
+	0x00ce, 0x0005, 0x012e, 0x00ce, 0x0804, 0x2fcf, 0x00ce, 0x0804,
+	0x2fd2, 0x080c, 0x861d, 0x0cb0, 0x2001, 0xb500, 0x2004, 0xa086,
+	0x0003, 0x1904, 0x2fcf, 0x00c6, 0x2061, 0x0100, 0x7924, 0x810f,
+	0xa18c, 0x00ff, 0xa196, 0x00ff, 0x1130, 0x2001, 0xb515, 0x2004,
+	0xa085, 0xff00, 0x0078, 0xa182, 0x007f, 0x16a0, 0xa188, 0x2dc4,
+	0x210d, 0xa18c, 0x00ff, 0x2001, 0xb515, 0x2004, 0xa116, 0x0550,
+	0x810f, 0xa105, 0x0126, 0x2091, 0x8000, 0x0006, 0x080c, 0x85c7,
+	0x000e, 0x01e0, 0x601a, 0x600b, 0xbc05, 0x601f, 0x0001, 0x080c,
+	0x3e75, 0x01d8, 0x6837, 0x0000, 0x7007, 0x0003, 0x6833, 0x0000,
+	0x6838, 0xc0fd, 0x683a, 0x701b, 0x3370, 0x2d00, 0x6012, 0x2009,
+	0x0032, 0x080c, 0x864c, 0x012e, 0x00ce, 0x0005, 0x012e, 0x00ce,
+	0x0804, 0x2fcf, 0x00ce, 0x0804, 0x2fd2, 0x080c, 0x861d, 0x0cb0,
+	0x6830, 0xa086, 0x0100, 0x0904, 0x2fcf, 0x0804, 0x2faa, 0x2061,
+	0xb874, 0x0126, 0x2091, 0x8000, 0x6000, 0xd084, 0x0178, 0x6104,
+	0x6208, 0x2a60, 0x6068, 0x783a, 0x60b4, 0x783e, 0x60b0, 0x2019,
+	0x0072, 0x201a, 0x6348, 0x012e, 0x0804, 0x2faa, 0xa00e, 0x2110,
+	0x0c80, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x5acf, 0x0904, 0x2fcf,
+	0x0126, 0x2091, 0x8000, 0x6248, 0x6068, 0xa202, 0x0248, 0xa085,
+	0x0001, 0x080c, 0x2867, 0x080c, 0x462c, 0x012e, 0x0804, 0x2faa,
+	0x012e, 0x0804, 0x2fd2, 0x0006, 0x0016, 0x00c6, 0x00e6, 0x2001,
+	0xb7bf, 0x2070, 0x2061, 0xb552, 0x6008, 0x2072, 0x2009, 0x0000,
+	0x2011, 0x1000, 0x080c, 0x6b40, 0x7206, 0x00ee, 0x00ce, 0x001e,
+	0x000e, 0x0005, 0x0126, 0x2091, 0x8000, 0x7824, 0xa084, 0x0007,
+	0x0002, 0x33d4, 0x33dd, 0x33e4, 0x33d1, 0x33d1, 0x33d1, 0x33d1,
+	0x33d1, 0x012e, 0x0804, 0x2fd2, 0x2009, 0x0114, 0x2104, 0xa085,
+	0x0800, 0x200a, 0x080c, 0x354f, 0x0070, 0x2009, 0x010b, 0x200b,
+	0x0010, 0x080c, 0x354f, 0x0038, 0x81ff, 0x0128, 0x012e, 0x2021,
+	0x400b, 0x0804, 0x2fac, 0x0086, 0x0096, 0x00a6, 0x00b6, 0x00c6,
+	0x00d6, 0x00e6, 0x00f6, 0x080c, 0x33ab, 0x2009, 0x0101, 0x210c,
+	0x0016, 0x2001, 0x0138, 0x200c, 0x2003, 0x0001, 0x0016, 0x2001,
+	0x007a, 0x2034, 0x2001, 0x007b, 0x202c, 0xa006, 0x2048, 0x2050,
+	0x2058, 0x080c, 0x379a, 0x080c, 0x36fe, 0xa03e, 0x2720, 0x00f6,
+	0x00e6, 0x00c6, 0x2d60, 0x2071, 0xb84a, 0x2079, 0x0020, 0x00d6,
+	0x2069, 0x0000, 0x6824, 0xd0b4, 0x0140, 0x2001, 0x007d, 0x2004,
+	0x783e, 0x2001, 0x007c, 0x2004, 0x783a, 0x00de, 0x2011, 0x0001,
+	0x080c, 0x36aa, 0x080c, 0x36aa, 0x00ce, 0x00ee, 0x00fe, 0x080c,
+	0x35f5, 0x080c, 0x36d2, 0x080c, 0x364f, 0x080c, 0x35b4, 0x080c,
+	0x35e5, 0x00f6, 0x2079, 0x0100, 0x7824, 0xd094, 0x0530, 0x7814,
+	0xa084, 0x0184, 0xa085, 0x0010, 0x7816, 0x2079, 0x0140, 0x080c,
+	0x352d, 0x1110, 0x00fe, 0x0430, 0x7804, 0xd0dc, 0x0dc0, 0x2079,
+	0x0100, 0x7827, 0x0086, 0x7814, 0xa084, 0x0184, 0xa085, 0x0032,
+	0x7816, 0x080c, 0x352d, 0x1110, 0x00fe, 0x00a0, 0x7824, 0xd0bc,
+	0x0dc0, 0x7827, 0x0080, 0xa026, 0x7c16, 0x7824, 0xd0ac, 0x0130,
+	0x8b58, 0x080c, 0x3537, 0x00fe, 0x0804, 0x34f7, 0x00fe, 0x080c,
+	0x352d, 0x1150, 0x8948, 0x2001, 0x007a, 0x2602, 0x2001, 0x007b,
+	0x2502, 0x080c, 0x3537, 0x0088, 0x87ff, 0x0140, 0x2001, 0x0201,
+	0x2004, 0xa005, 0x1904, 0x3431, 0x8739, 0x0038, 0x2001, 0xb823,
+	0x2004, 0xa086, 0x0000, 0x1904, 0x3431, 0x2001, 0x0033, 0x2003,
+	0x00f6, 0x8631, 0x1208, 0x8529, 0x2500, 0xa605, 0x0904, 0x34f7,
+	0x7824, 0xd0bc, 0x0128, 0x2900, 0xaa05, 0xab05, 0x1904, 0x34f7,
+	0x6033, 0x000d, 0x2001, 0x0030, 0x2003, 0x0004, 0x7824, 0xd0ac,
+	0x1148, 0x2001, 0xb823, 0x2003, 0x0003, 0x2001, 0x0030, 0x2003,
+	0x0009, 0x0040, 0x6027, 0x0001, 0x2001, 0x0075, 0x2004, 0xa005,
+	0x0108, 0x6026, 0x2c00, 0x601a, 0x20e1, 0x9040, 0x2d00, 0x681a,
+	0x6833, 0x000d, 0x7824, 0xd0a4, 0x1180, 0x6827, 0x0000, 0x00c6,
+	0x20a9, 0x0004, 0x2061, 0x0020, 0x6003, 0x0008, 0x2001, 0x0203,
+	0x2004, 0x1f04, 0x34cc, 0x00ce, 0x0040, 0x6827, 0x0001, 0x2001,
+	0x0074, 0x2004, 0xa005, 0x0108, 0x6826, 0x00f6, 0x00c6, 0x2079,
+	0x0100, 0x2061, 0x0020, 0x7827, 0x0002, 0x2001, 0x0072, 0x2004,
+	0xa084, 0xfff8, 0x601a, 0x0006, 0x2001, 0x0073, 0x2004, 0x601e,
+	0x78c6, 0x000e, 0x78ca, 0x00ce, 0x00fe, 0x0804, 0x340f, 0x2061,
+	0x0100, 0x6027, 0x0002, 0x001e, 0x61e2, 0x001e, 0x6106, 0x7824,
+	0xa084, 0x0003, 0xa086, 0x0002, 0x0188, 0x20e1, 0x9028, 0x6050,
+	0xa084, 0xf7ef, 0x6052, 0x602f, 0x0000, 0x602c, 0xc0ac, 0x602e,
+	0x604b, 0xf7f7, 0x6043, 0x0090, 0x6043, 0x0010, 0x2908, 0x2a10,
+	0x2b18, 0x2b00, 0xaa05, 0xa905, 0x00fe, 0x00ee, 0x00de, 0x00ce,
+	0x00be, 0x00ae, 0x009e, 0x008e, 0x1118, 0x012e, 0x0804, 0x2faa,
+	0x012e, 0x2021, 0x400c, 0x0804, 0x2fac, 0xa085, 0x0001, 0x1d04,
+	0x3536, 0x2091, 0x6000, 0x8420, 0xa486, 0x0064, 0x0005, 0x2001,
+	0x0105, 0x2003, 0x0010, 0x2001, 0x0030, 0x2003, 0x0004, 0x2001,
+	0x0020, 0x2003, 0x0004, 0x2001, 0xb823, 0x2003, 0x0000, 0x2001,
+	0xb84a, 0x2003, 0x0000, 0x20e1, 0xf000, 0xa026, 0x0005, 0x00f6,
+	0x2079, 0x0100, 0x2001, 0xb515, 0x200c, 0x7932, 0x7936, 0x080c,
+	0x2847, 0x7850, 0xa084, 0x0980, 0xa085, 0x0030, 0x7852, 0x2019,
+	0x01f4, 0x8319, 0x1df0, 0xa084, 0x0980, 0x7852, 0x782c, 0xc0ad,
+	0x782e, 0x20a9, 0x0046, 0x1d04, 0x356b, 0x2091, 0x6000, 0x1f04,
+	0x356b, 0x7850, 0xa085, 0x0400, 0x7852, 0x2001, 0x0009, 0x2004,
+	0xa084, 0x0003, 0xa086, 0x0001, 0x1118, 0x782c, 0xc0ac, 0x782e,
+	0x784b, 0xf7f7, 0x7843, 0x0090, 0x7843, 0x0010, 0x20a9, 0x000e,
+	0xe000, 0x1f04, 0x3588, 0x7850, 0xa085, 0x1400, 0x7852, 0x2019,
+	0x61a8, 0x7854, 0xe000, 0xe000, 0xd08c, 0x1110, 0x8319, 0x1dc8,
+	0x7827, 0x0048, 0x7850, 0xa085, 0x0400, 0x7852, 0x7843, 0x0040,
+	0x2019, 0x01f4, 0xe000, 0xe000, 0x8319, 0x1de0, 0x2001, 0x0140,
+	0x2003, 0x0100, 0x7827, 0x0020, 0x7843, 0x0000, 0x2003, 0x0000,
+	0x7827, 0x0048, 0x00fe, 0x0005, 0x7824, 0xd0ac, 0x11c8, 0x00f6,
+	0x00e6, 0x2071, 0xb823, 0x2079, 0x0030, 0x2001, 0x0201, 0x2004,
+	0xa005, 0x0160, 0x7000, 0xa086, 0x0000, 0x1140, 0x0051, 0xd0bc,
+	0x0108, 0x8738, 0x7003, 0x0003, 0x7803, 0x0019, 0x00ee, 0x00fe,
+	0x0005, 0x780c, 0xa08c, 0x0070, 0x0178, 0x2009, 0x007a, 0x260a,
+	0x2009, 0x007b, 0x250a, 0xd0b4, 0x0108, 0x8a50, 0xd0ac, 0x0108,
+	0x8948, 0xd0a4, 0x0108, 0x8b58, 0x0005, 0x00f6, 0x2079, 0x0200,
+	0x781c, 0xd084, 0x0140, 0x20e1, 0x0007, 0x20e1, 0x2000, 0x2001,
+	0x020a, 0x2004, 0x0ca8, 0x00fe, 0x0005, 0x00e6, 0x2071, 0x0100,
+	0x2001, 0xb7c0, 0x2004, 0x70e2, 0x2009, 0xb515, 0x210c, 0x716e,
+	0x7063, 0x0100, 0x7166, 0x719e, 0x706b, 0x0000, 0x7073, 0x0809,
+	0x7077, 0x0008, 0x7078, 0xa080, 0x0100, 0x707a, 0x7080, 0x8000,
+	0x7082, 0x7087, 0xaaaa, 0xa006, 0x708a, 0x708e, 0x707e, 0x70d6,
+	0x70ab, 0x0036, 0x70af, 0x95d5, 0x7027, 0x0080, 0x7014, 0xa084,
+	0x0184, 0xa085, 0x0032, 0x7016, 0x080c, 0x36d2, 0x080c, 0x352d,
+	0x1110, 0x8421, 0x0028, 0x7024, 0xd0bc, 0x0db0, 0x7027, 0x0080,
+	0x00f6, 0x00e6, 0x2071, 0xb823, 0x2079, 0x0030, 0x00d6, 0x2069,
+	0x0000, 0x6824, 0xd0b4, 0x0120, 0x683c, 0x783e, 0x6838, 0x783a,
+	0x00de, 0x2011, 0x0011, 0x080c, 0x36aa, 0x2011, 0x0001, 0x080c,
+	0x36aa, 0x00ee, 0x00fe, 0x7017, 0x0000, 0x00ee, 0x0005, 0x00f6,
+	0x00e6, 0x2071, 0xb823, 0x2079, 0x0030, 0x7904, 0xd1fc, 0x0904,
+	0x36a7, 0x7803, 0x0002, 0xa026, 0xd19c, 0x1904, 0x36a3, 0x7000,
+	0x0002, 0x36a7, 0x3665, 0x3689, 0x36a3, 0xd1bc, 0x1150, 0xd1dc,
+	0x1150, 0x8001, 0x7002, 0x2011, 0x0001, 0x04e1, 0x05c0, 0x04d1,
+	0x04b0, 0x780f, 0x0000, 0x7820, 0x7924, 0x7803, 0x0004, 0x7822,
+	0x7926, 0x2001, 0x0201, 0x200c, 0x81ff, 0x0de8, 0x080c, 0x35d1,
+	0x2009, 0x0001, 0x7808, 0xd0ec, 0x0110, 0x2009, 0x0011, 0x7902,
+	0x00f0, 0x8001, 0x7002, 0xa184, 0x0880, 0x1138, 0x7804, 0xd0fc,
+	0x1940, 0x2011, 0x0001, 0x00b1, 0x0090, 0x6030, 0xa092, 0x0004,
+	0xa086, 0x0009, 0x1120, 0x6000, 0x601a, 0x2011, 0x0025, 0x6232,
+	0xd1dc, 0x1988, 0x0870, 0x7803, 0x0004, 0x7003, 0x0000, 0x00ee,
+	0x00fe, 0x0005, 0x6024, 0xa005, 0x0520, 0x8001, 0x6026, 0x6018,
+	0x6130, 0xa140, 0x2804, 0x7832, 0x8840, 0x2804, 0x7836, 0x8840,
+	0x2804, 0x7822, 0x8840, 0x2804, 0x7826, 0x8840, 0x7a02, 0x7000,
+	0x8000, 0x7002, 0x6018, 0xa802, 0xa08a, 0x0029, 0x1138, 0x6018,
+	0xa080, 0x0001, 0x2004, 0x601a, 0x2001, 0x000d, 0x6032, 0xa085,
+	0x0001, 0x0005, 0x00f6, 0x00e6, 0x00c6, 0x2071, 0xb84a, 0x2079,
+	0x0020, 0x7904, 0xd1fc, 0x01f0, 0x7803, 0x0002, 0x2d60, 0xa026,
+	0x7000, 0x0002, 0x36fa, 0x36e5, 0x36f1, 0x8001, 0x7002, 0xd19c,
+	0x1188, 0x2011, 0x0001, 0x080c, 0x36aa, 0x0160, 0x080c, 0x36aa,
+	0x0048, 0x8001, 0x7002, 0x7804, 0xd0fc, 0x1d30, 0x2011, 0x0001,
+	0x080c, 0x36aa, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0x00e6,
+	0x00c6, 0x2061, 0x0200, 0x2001, 0xb7c0, 0x2004, 0x601a, 0x2061,
+	0x0100, 0x2001, 0xb7bf, 0x2004, 0x60ce, 0x6004, 0xc0ac, 0xa085,
+	0x0200, 0x6006, 0x2001, 0x0074, 0x2004, 0xa005, 0x01f8, 0x2038,
+	0x2001, 0x0076, 0x2024, 0x2001, 0x0077, 0x201c, 0x080c, 0x3e75,
+	0x6833, 0x000d, 0x6f26, 0x2d00, 0x681a, 0xa78a, 0x0007, 0x0220,
+	0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0xa03e, 0x6818, 0xa080,
+	0x000d, 0x04b1, 0x1d90, 0x2d00, 0x681a, 0x0088, 0x080c, 0x3e75,
+	0x6833, 0x000d, 0x2070, 0x6827, 0x0001, 0x2d00, 0x681a, 0x2001,
+	0x0076, 0x2004, 0x2072, 0x2001, 0x0077, 0x2004, 0x7006, 0x2061,
+	0x0020, 0x2079, 0x0100, 0x2001, 0xb7bf, 0x2004, 0x6012, 0x20e1,
+	0x9040, 0x2001, 0x0072, 0x2004, 0xa084, 0xfff8, 0x700a, 0x601a,
+	0x0006, 0x2001, 0x0073, 0x2004, 0x700e, 0x601e, 0x78c6, 0x000e,
+	0x78ca, 0xa006, 0x603a, 0x603e, 0x00ce, 0x00ee, 0x00fe, 0x0005,
+	0x00e6, 0x2071, 0x0010, 0x20a0, 0x2099, 0x0014, 0x7003, 0x0026,
+	0x7432, 0x7336, 0xa006, 0x703a, 0x703e, 0x810b, 0x810b, 0x21a8,
+	0x810b, 0x7122, 0x7003, 0x0041, 0x7004, 0xd0fc, 0x0de8, 0x7003,
+	0x0002, 0x7003, 0x0040, 0x53a5, 0x7430, 0x7334, 0x87ff, 0x0180,
+	0x00c6, 0x00d6, 0x2d60, 0x00c6, 0x080c, 0x3e75, 0x00ce, 0x6018,
+	0x2070, 0x2d00, 0x7006, 0x601a, 0x00de, 0x00ce, 0xa085, 0x0001,
+	0x00ee, 0x0005, 0x00e6, 0x2001, 0x0075, 0x2004, 0xa005, 0x0508,
+	0x2038, 0x2001, 0x0078, 0x2024, 0x2001, 0x0079, 0x201c, 0x080c,
+	0x3e75, 0x2d60, 0x6833, 0x000d, 0x6f26, 0x2d00, 0x681a, 0xa78a,
+	0x0007, 0x0220, 0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0xa03e,
+	0x6818, 0xa080, 0x000d, 0x080c, 0x3768, 0x1d88, 0x2d00, 0x681a,
+	0x00e0, 0x080c, 0x3e75, 0x2d60, 0x6033, 0x000d, 0x2070, 0x6027,
+	0x0001, 0x2c00, 0x601a, 0x2001, 0x0078, 0x2004, 0x2072, 0x2001,
+	0x0079, 0x2004, 0x7006, 0x2001, 0x0072, 0x2004, 0xa084, 0xfff8,
+	0x700a, 0x2001, 0x0073, 0x2004, 0x700e, 0x2001, 0x0030, 0x2003,
+	0x0004, 0x7824, 0xd0ac, 0x1178, 0x2001, 0x0101, 0x200c, 0xc1ed,
+	0x2102, 0x6027, 0x0000, 0x2001, 0xb823, 0x2003, 0x0003, 0x2001,
+	0x0030, 0x2003, 0x0009, 0x00ee, 0x0005, 0x0804, 0x2faa, 0x0126,
+	0x2091, 0x8000, 0x20a9, 0x0012, 0x2001, 0xb540, 0x20a0, 0xa006,
+	0x40a4, 0x012e, 0x0804, 0x2faa, 0x7d38, 0x7c3c, 0x0804, 0x3051,
+	0x080c, 0x3e75, 0x0904, 0x2fcf, 0x080c, 0x5acf, 0x0110, 0x080c,
+	0x4bf0, 0x2009, 0x001c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c,
+	0x3eb6, 0x701b, 0x381c, 0x0005, 0xade8, 0x000d, 0x6800, 0xa005,
+	0x0904, 0x2fd2, 0x6804, 0xd0ac, 0x0118, 0xd0a4, 0x0904, 0x2fd2,
+	0xd094, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0138, 0x6200, 0xa292,
+	0x0005, 0x0218, 0xa18c, 0xffdf, 0x0010, 0xa18d, 0x0020, 0x6106,
+	0x00ce, 0xd08c, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0118, 0xa18d,
+	0x0010, 0x0010, 0xa18c, 0xffef, 0x6106, 0x00ce, 0x2009, 0x0100,
+	0x210c, 0xa18a, 0x0002, 0x0268, 0xd084, 0x0158, 0x6a28, 0xa28a,
+	0x007f, 0x1a04, 0x2fd2, 0xa288, 0x2dc4, 0x210d, 0xa18c, 0x00ff,
+	0x615a, 0xd0dc, 0x0130, 0x6828, 0xa08a, 0x007f, 0x1a04, 0x2fd2,
+	0x6052, 0x6808, 0xa08a, 0x0100, 0x0a04, 0x2fd2, 0xa08a, 0x0841,
+	0x1a04, 0x2fd2, 0xa084, 0x0007, 0x1904, 0x2fd2, 0x680c, 0xa005,
+	0x0904, 0x2fd2, 0x6810, 0xa005, 0x0904, 0x2fd2, 0x6848, 0x6940,
+	0xa10a, 0x1a04, 0x2fd2, 0x8001, 0x0904, 0x2fd2, 0x684c, 0x6944,
+	0xa10a, 0x1a04, 0x2fd2, 0x8001, 0x0904, 0x2fd2, 0x6804, 0xd0fc,
+	0x0560, 0x080c, 0x3e75, 0x0904, 0x2fcf, 0x2009, 0x0014, 0x7a2c,
+	0x7b28, 0x7c3c, 0x7d38, 0xa290, 0x0038, 0xa399, 0x0000, 0x080c,
+	0x3eb6, 0x701b, 0x389c, 0x0005, 0xade8, 0x000d, 0x20a9, 0x0014,
+	0x2d98, 0x2069, 0xb56e, 0x2da0, 0x53a3, 0x7010, 0xa0e8, 0x000d,
+	0x2001, 0xb572, 0x200c, 0xd1e4, 0x0140, 0x00c6, 0x2061, 0x0100,
+	0x6004, 0xa085, 0x0b00, 0x6006, 0x00ce, 0x2009, 0xb7b1, 0x200b,
+	0x0000, 0x2001, 0xb574, 0x2004, 0xd0ac, 0x0158, 0x7824, 0x200a,
+	0x2009, 0x017f, 0x200a, 0x3200, 0xa084, 0x003f, 0xa085, 0x3020,
+	0x2090, 0x20a9, 0x001c, 0x2d98, 0x2069, 0xb552, 0x2da0, 0x53a3,
+	0x6814, 0xa08c, 0x00ff, 0x6142, 0x8007, 0xa084, 0x00ff, 0x6046,
+	0x080c, 0x5da5, 0x080c, 0x536c, 0x080c, 0x53d5, 0x6000, 0xa086,
+	0x0000, 0x1904, 0x3997, 0x6808, 0x602a, 0x080c, 0x2470, 0x0006,
+	0x2001, 0x0100, 0x2004, 0xa082, 0x0005, 0x000e, 0x0268, 0x2009,
+	0x0170, 0x200b, 0x0080, 0xe000, 0xe000, 0x200b, 0x0000, 0x0036,
+	0x6b08, 0x080c, 0x28a2, 0x003e, 0x6818, 0x691c, 0x6a20, 0x6b24,
+	0x8007, 0x810f, 0x8217, 0x831f, 0x6016, 0x611a, 0x621e, 0x6322,
+	0x6c04, 0xd4f4, 0x0148, 0x6830, 0x6934, 0x6a38, 0x6b3c, 0x8007,
+	0x810f, 0x8217, 0x831f, 0x0010, 0xa084, 0xf0ff, 0x6006, 0x610a,
+	0x620e, 0x6312, 0x8007, 0x810f, 0x8217, 0x831f, 0x20a9, 0x0004,
+	0x20a1, 0xb7c6, 0x40a1, 0x080c, 0x6a68, 0x6904, 0xd1fc, 0x0520,
+	0x00c6, 0x2009, 0x0000, 0x20a9, 0x0001, 0x6b70, 0xd384, 0x01c8,
+	0x0020, 0x839d, 0x12b0, 0x3508, 0x8109, 0x080c, 0x635c, 0x6878,
+	0x6016, 0x6874, 0x2008, 0xa084, 0xff00, 0x8007, 0x600a, 0xa184,
+	0x00ff, 0x6006, 0x8108, 0x1118, 0x6003, 0x0003, 0x0010, 0x6003,
+	0x0001, 0x1f04, 0x3931, 0x00ce, 0x2069, 0xb552, 0x2001, 0xb79e,
+	0x6a80, 0xa294, 0x0030, 0xa28e, 0x0000, 0x0170, 0xa28e, 0x0010,
+	0x0118, 0xa28e, 0x0020, 0x0140, 0x2003, 0xaaaa, 0x080c, 0x28eb,
+	0x2001, 0xb78f, 0x2102, 0x0008, 0x2102, 0x00c6, 0x2061, 0x0100,
+	0x602f, 0x0040, 0x602f, 0x0000, 0x00ce, 0x080c, 0x5acf, 0x0128,
+	0x080c, 0x40cf, 0x0110, 0x080c, 0x2867, 0x60c8, 0xa005, 0x01d0,
+	0x6003, 0x0001, 0x2009, 0x397d, 0x00e0, 0x080c, 0x5acf, 0x1178,
+	0x2011, 0x59a2, 0x080c, 0x699c, 0x2011, 0x5995, 0x080c, 0x6a5c,
+	0x2001, 0xb79f, 0x2003, 0x0000, 0x080c, 0x5a07, 0x0040, 0x080c,
+	0x4b1f, 0x0028, 0x6003, 0x0004, 0x2009, 0x3997, 0x0010, 0x0804,
+	0x2faa, 0x2001, 0x0100, 0x2004, 0xa082, 0x0005, 0x0258, 0x2001,
+	0x0170, 0x2004, 0xa084, 0x00ff, 0xa086, 0x004c, 0x1118, 0x2091,
+	0x309d, 0x0817, 0x2091, 0x301d, 0x0817, 0x6000, 0xa086, 0x0000,
+	0x0904, 0x2fcf, 0x2069, 0xb552, 0x7830, 0x6842, 0x7834, 0x6846,
+	0x6804, 0xd0fc, 0x0118, 0x2009, 0x0030, 0x0010, 0x2009, 0x001c,
+	0x2d00, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3eb9, 0xa006,
+	0x080c, 0x2867, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x5acf, 0x1178,
+	0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001,
+	0xa085, 0x0001, 0x080c, 0x5b13, 0x080c, 0x5a07, 0x0020, 0x080c,
+	0x4bf0, 0x080c, 0x4b1f, 0x0804, 0x2faa, 0x81ff, 0x1904, 0x2fcf,
+	0x080c, 0x5acf, 0x1110, 0x0804, 0x2fcf, 0x6188, 0x81ff, 0x0198,
+	0x703f, 0x0000, 0x2001, 0xbcc0, 0x2009, 0x0040, 0x7a2c, 0x7b28,
+	0x7c3c, 0x7d38, 0x0126, 0x2091, 0x8000, 0x080c, 0x3eb9, 0x701b,
+	0x2fa8, 0x012e, 0x0005, 0x703f, 0x0001, 0x00d6, 0x2069, 0xbcc0,
+	0x20a9, 0x0040, 0x20a1, 0xbcc0, 0x2019, 0xffff, 0x43a4, 0x6550,
+	0xa588, 0x2dc4, 0x210d, 0xa18c, 0x00ff, 0x216a, 0xa00e, 0x2011,
+	0x0002, 0x2100, 0xa506, 0x01a8, 0x080c, 0x4fa9, 0x1190, 0x6014,
+	0x821c, 0x0238, 0xa398, 0xbcc0, 0xa085, 0xff00, 0x8007, 0x201a,
+	0x0038, 0xa398, 0xbcc0, 0x2324, 0xa4a4, 0xff00, 0xa405, 0x201a,
+	0x8210, 0x8108, 0xa182, 0x0080, 0x1208, 0x0c18, 0x8201, 0x8007,
+	0x2d0c, 0xa105, 0x206a, 0x00de, 0x20a9, 0x0040, 0x20a1, 0xbcc0,
+	0x2099, 0xbcc0, 0x080c, 0x4b8f, 0x0804, 0x39f2, 0x080c, 0x3e9a,
+	0x0904, 0x2fd2, 0x00c6, 0x080c, 0x3e75, 0x00ce, 0x1120, 0x2009,
+	0x0002, 0x0804, 0x2fcf, 0x2001, 0xb553, 0x2004, 0xd0b4, 0x0550,
+	0x7824, 0xa084, 0xff00, 0xa08e, 0x7e00, 0x0520, 0xa08e, 0x7f00,
+	0x0508, 0xa08e, 0x8000, 0x01f0, 0x6000, 0xd08c, 0x11d8, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x11a8, 0x6837, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x080c, 0x9dda, 0x1120, 0x2009, 0x0003, 0x0804,
+	0x2fcf, 0x7007, 0x0003, 0x701b, 0x3a7e, 0x0005, 0x080c, 0x3e9a,
+	0x0904, 0x2fd2, 0x20a9, 0x002b, 0x2c98, 0xade8, 0x0002, 0x2da0,
+	0x53a3, 0x20a9, 0x0004, 0xac80, 0x0006, 0x2098, 0xad80, 0x0006,
+	0x20a0, 0x080c, 0x4b8f, 0x20a9, 0x0004, 0xac80, 0x000a, 0x2098,
+	0xad80, 0x000a, 0x20a0, 0x080c, 0x4b8f, 0x2d00, 0x2009, 0x002b,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3eb9, 0x81ff, 0x1904,
+	0x2fcf, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c, 0x5186, 0x0804,
+	0x2faa, 0x81ff, 0x1904, 0x2fcf, 0x7828, 0xa08a, 0x1000, 0x1a04,
+	0x2fd2, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x080c, 0x51e9, 0x0904,
+	0x2fcf, 0x2019, 0x0004, 0xa00e, 0x080c, 0x5198, 0x7924, 0x810f,
+	0x7a28, 0x0011, 0x0804, 0x2faa, 0xa186, 0x00ff, 0x0110, 0x0071,
+	0x0060, 0x2029, 0x007e, 0x2061, 0xb500, 0x6450, 0x2400, 0xa506,
+	0x0110, 0x2508, 0x0019, 0x8529, 0x1ec8, 0x0005, 0x080c, 0x4fa9,
+	0x1138, 0x2200, 0x8003, 0x800b, 0x810b, 0xa108, 0x080c, 0x69a8,
+	0x0005, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e8a, 0x0904, 0x2fd2,
+	0x080c, 0x506f, 0x0904, 0x2fcf, 0x080c, 0x518f, 0x0804, 0x2faa,
+	0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c,
+	0x506f, 0x0904, 0x2fcf, 0x080c, 0x517d, 0x0804, 0x2faa, 0x6100,
+	0x0804, 0x2faa, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x2001, 0xb500,
+	0x2004, 0xa086, 0x0003, 0x1904, 0x2fcf, 0x00d6, 0xace8, 0x000a,
+	0x7924, 0xd184, 0x0110, 0xace8, 0x0006, 0x680c, 0x8007, 0x783e,
+	0x6808, 0x8007, 0x783a, 0x6b04, 0x831f, 0x6a00, 0x8217, 0x00de,
+	0x6100, 0xa18c, 0x0200, 0x0804, 0x2faa, 0x7824, 0xa09c, 0x0003,
+	0xd0b4, 0x1160, 0xa39a, 0x0003, 0x1a04, 0x2fcf, 0x6250, 0xa294,
+	0x00ff, 0xa084, 0xff00, 0x8007, 0xa206, 0x1150, 0x2001, 0xb540,
+	0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3eb9,
+	0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x1904, 0x2fcf, 0x00c6, 0x080c,
+	0x3e75, 0x00ce, 0x0904, 0x2fcf, 0x6837, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x080c, 0x9d86, 0x0904, 0x2fcf, 0x7007, 0x0003, 0x701b,
+	0x3b6a, 0x0005, 0x6830, 0xa086, 0x0100, 0x0904, 0x2fcf, 0xad80,
+	0x000e, 0x2009, 0x000c, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804,
+	0x3eb9, 0xa006, 0x080c, 0x2867, 0x7824, 0xa084, 0x00ff, 0xa086,
+	0x00ff, 0x0118, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x5acf, 0x0110,
+	0x080c, 0x4bf0, 0x7828, 0xa08a, 0x1000, 0x1a04, 0x2fd2, 0x7924,
+	0xa18c, 0xff00, 0x810f, 0xa186, 0x00ff, 0x0138, 0xa182, 0x007f,
+	0x1a04, 0x2fd2, 0x2100, 0x080c, 0x2831, 0x0026, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x2061, 0xb7f3, 0x601b, 0x0000, 0x601f, 0x0000,
+	0x080c, 0x5acf, 0x1178, 0x2001, 0xb79f, 0x2003, 0x0001, 0x2001,
+	0xb500, 0x2003, 0x0001, 0xa085, 0x0001, 0x080c, 0x5b13, 0x080c,
+	0x5a07, 0x0420, 0x2011, 0x0003, 0x080c, 0x8075, 0x2011, 0x0002,
+	0x080c, 0x807f, 0x080c, 0x7f59, 0x0036, 0x2019, 0x0000, 0x080c,
+	0x7fe4, 0x003e, 0x2061, 0x0100, 0x2001, 0xb515, 0x2004, 0xa084,
+	0x00ff, 0x810f, 0xa105, 0x604a, 0x6043, 0x0090, 0x6043, 0x0010,
+	0x2009, 0x002d, 0x2011, 0x4b54, 0x080c, 0x6a22, 0x7924, 0xa18c,
+	0xff00, 0x810f, 0x080c, 0x5acf, 0x1110, 0x2009, 0x00ff, 0x7a28,
+	0x080c, 0x3acc, 0x012e, 0x00ce, 0x002e, 0x0804, 0x2faa, 0x7924,
+	0xa18c, 0xff00, 0x810f, 0x00c6, 0x080c, 0x4f4d, 0x2c08, 0x00ce,
+	0x1904, 0x2fd2, 0x0804, 0x2faa, 0x81ff, 0x0120, 0x2009, 0x0001,
+	0x0804, 0x2fcf, 0x60d4, 0xd0ac, 0x1130, 0xd09c, 0x1120, 0x2009,
+	0x0005, 0x0804, 0x2fcf, 0x080c, 0x3e75, 0x1120, 0x2009, 0x0002,
+	0x0804, 0x2fcf, 0x7924, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c,
+	0x3eb6, 0x701b, 0x3c1c, 0x0005, 0x2009, 0x0080, 0x080c, 0x4fa9,
+	0x1130, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x0120, 0x2021,
+	0x400a, 0x0804, 0x2fac, 0x00d6, 0xade8, 0x000d, 0x6900, 0x6a08,
+	0x6b0c, 0x6c10, 0x6d14, 0x6e18, 0x6820, 0xa0be, 0x0100, 0x0904,
+	0x3c93, 0xa0be, 0x0112, 0x0904, 0x3c93, 0xa0be, 0x0113, 0x0904,
+	0x3c93, 0xa0be, 0x0114, 0x0904, 0x3c93, 0xa0be, 0x0117, 0x0904,
+	0x3c93, 0xa0be, 0x011a, 0x0904, 0x3c93, 0xa0be, 0x011c, 0x0904,
+	0x3c93, 0xa0be, 0x0121, 0x05b0, 0xa0be, 0x0131, 0x0598, 0xa0be,
+	0x0171, 0x05c8, 0xa0be, 0x0173, 0x05b0, 0xa0be, 0x01a1, 0x1120,
+	0x6830, 0x8007, 0x6832, 0x04a8, 0xa0be, 0x0212, 0x0540, 0xa0be,
+	0x0213, 0x0528, 0xa0be, 0x0214, 0x01b0, 0xa0be, 0x0217, 0x0168,
+	0xa0be, 0x021a, 0x1120, 0x6838, 0x8007, 0x683a, 0x00e0, 0xa0be,
+	0x0300, 0x01c8, 0x00de, 0x0804, 0x2fd2, 0xad80, 0x0010, 0x20a9,
+	0x0007, 0x080c, 0x3cd9, 0xad80, 0x000e, 0x20a9, 0x0001, 0x080c,
+	0x3cd9, 0x0048, 0xad80, 0x000c, 0x080c, 0x3ce7, 0x0050, 0xad80,
+	0x000e, 0x080c, 0x3ce7, 0xad80, 0x000c, 0x20a9, 0x0001, 0x080c,
+	0x3cd9, 0x00c6, 0x080c, 0x3e75, 0x0568, 0x6838, 0xc0fd, 0x683a,
+	0x6837, 0x0119, 0x6853, 0x0000, 0x684f, 0x0020, 0x685b, 0x0001,
+	0x810b, 0x697e, 0x6883, 0x0000, 0x6a86, 0x6b8a, 0x6c8e, 0x6d92,
+	0x6996, 0x689b, 0x0000, 0x00ce, 0x00de, 0x6837, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x6823, 0x0000, 0x6804, 0x2068, 0x080c, 0x9da2,
+	0x1120, 0x2009, 0x0003, 0x0804, 0x2fcf, 0x7007, 0x0003, 0x701b,
+	0x3cd0, 0x0005, 0x00ce, 0x00de, 0x2009, 0x0002, 0x0804, 0x2fcf,
+	0x6820, 0xa086, 0x8001, 0x1904, 0x2faa, 0x2009, 0x0004, 0x0804,
+	0x2fcf, 0x0016, 0x2008, 0x2044, 0x8000, 0x204c, 0x8000, 0x290a,
+	0x8108, 0x280a, 0x8108, 0x1f04, 0x3cdb, 0x001e, 0x0005, 0x0016,
+	0x00a6, 0x00b6, 0x2008, 0x2044, 0x8000, 0x204c, 0x8000, 0x2054,
+	0x8000, 0x205c, 0x2b0a, 0x8108, 0x2a0a, 0x8108, 0x290a, 0x8108,
+	0x280a, 0x00be, 0x00ae, 0x001e, 0x0005, 0x81ff, 0x0120, 0x2009,
+	0x0001, 0x0804, 0x2fcf, 0x60d4, 0xd0ac, 0x1130, 0xd09c, 0x1120,
+	0x2009, 0x0005, 0x0804, 0x2fcf, 0x7924, 0x2140, 0xa18c, 0xff00,
+	0x810f, 0x60d4, 0xd0ac, 0x1120, 0xa182, 0x0080, 0x0a04, 0x2fd2,
+	0xa182, 0x00ff, 0x1a04, 0x2fd2, 0x7a2c, 0x7b28, 0x6070, 0xa306,
+	0x1140, 0x6074, 0xa24e, 0x0904, 0x2fd2, 0xa9cc, 0xff00, 0x0904,
+	0x2fd2, 0x00c6, 0x080c, 0x3dc5, 0x2c68, 0x00ce, 0x0530, 0xa0c6,
+	0x4000, 0x1178, 0x00c6, 0x0006, 0x2d60, 0xa00e, 0x080c, 0x524a,
+	0x1108, 0xc185, 0x6000, 0xd0bc, 0x0108, 0xc18d, 0x000e, 0x00ce,
+	0x0088, 0xa0c6, 0x4007, 0x1110, 0x2408, 0x0060, 0xa0c6, 0x4008,
+	0x1118, 0x2708, 0x2610, 0x0030, 0xa0c6, 0x4009, 0x1108, 0x0010,
+	0x2001, 0x4006, 0x2020, 0x0804, 0x2fac, 0x2d00, 0x7022, 0x0016,
+	0x00b6, 0x00c6, 0x00e6, 0x2c70, 0x080c, 0x85c7, 0x05d8, 0x2d00,
+	0x601a, 0x080c, 0xa027, 0x2e58, 0x00ee, 0x00e6, 0x00c6, 0x080c,
+	0x3e75, 0x00ce, 0x2b70, 0x1150, 0x080c, 0x861d, 0x00ee, 0x00ce,
+	0x00be, 0x001e, 0x2009, 0x0002, 0x0804, 0x2fcf, 0x6837, 0x0000,
+	0x683b, 0x0000, 0x2d00, 0x6012, 0x6833, 0x0000, 0x6838, 0xc0fd,
+	0xd88c, 0x0108, 0xc0f5, 0x683a, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x2c9c, 0x012e, 0x601f, 0x0001, 0x2001, 0x0000, 0x080c, 0x4eeb,
+	0x2001, 0x0002, 0x080c, 0x4efd, 0x2009, 0x0002, 0x080c, 0x864c,
+	0xa085, 0x0001, 0x00ee, 0x00ce, 0x00be, 0x001e, 0x1120, 0x2009,
+	0x0003, 0x0804, 0x2fcf, 0x7007, 0x0003, 0x701b, 0x3da8, 0x0005,
+	0x6830, 0xa086, 0x0100, 0x7020, 0x2060, 0x1138, 0x2009, 0x0004,
+	0x6204, 0xa294, 0x00ff, 0x0804, 0x2fcf, 0x2009, 0x0000, 0x6838,
+	0xd0f4, 0x1904, 0x2faa, 0x080c, 0x524a, 0x1108, 0xc185, 0x6000,
+	0xd0bc, 0x0108, 0xc18d, 0x0804, 0x2faa, 0x00e6, 0x00d6, 0xa02e,
+	0x2001, 0xb535, 0x2004, 0xd0ac, 0x0130, 0xa026, 0x20a9, 0x00ff,
+	0x2071, 0xb635, 0x0030, 0x2021, 0x0080, 0x20a9, 0x007f, 0x2071,
+	0xb6b5, 0x2e04, 0xa005, 0x1130, 0x2100, 0xa406, 0x1570, 0x2428,
+	0xc5fd, 0x0458, 0x2068, 0x6f10, 0x2700, 0xa306, 0x11b0, 0x6e14,
+	0x2600, 0xa206, 0x1190, 0x2400, 0xa106, 0x1160, 0x2d60, 0xd884,
+	0x0568, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1538, 0x2001,
+	0x4000, 0x0428, 0x2001, 0x4007, 0x0410, 0x2400, 0xa106, 0x1168,
+	0x6e14, 0x87ff, 0x1138, 0x86ff, 0x09d0, 0x2001, 0xb535, 0x2004,
+	0xd0ac, 0x19a8, 0x2001, 0x4008, 0x0090, 0x8420, 0x8e70, 0x1f04,
+	0x3dd9, 0x85ff, 0x1130, 0x2001, 0x4009, 0x0048, 0x2001, 0x0001,
+	0x0030, 0x080c, 0x4f4d, 0x1dd0, 0x6312, 0x6216, 0xa006, 0xa005,
+	0x00de, 0x00ee, 0x0005, 0x81ff, 0x1904, 0x2fcf, 0x080c, 0x3e75,
+	0x0904, 0x2fcf, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x7824,
+	0xa005, 0x0904, 0x2fd2, 0xa096, 0x00ff, 0x0120, 0xa092, 0x0004,
+	0x1a04, 0x2fd2, 0x2010, 0x2d18, 0x080c, 0x2c4f, 0x0904, 0x2fcf,
+	0x7007, 0x0003, 0x701b, 0x3e45, 0x0005, 0x6830, 0xa086, 0x0100,
+	0x0904, 0x2fcf, 0x0804, 0x2faa, 0x7924, 0xa18c, 0xff00, 0x810f,
+	0x60d4, 0xd0ac, 0x1120, 0xa182, 0x0080, 0x0a04, 0x2fd2, 0xa182,
+	0x00ff, 0x1a04, 0x2fd2, 0x0126, 0x2091, 0x8000, 0x080c, 0x9c8a,
+	0x1188, 0xa190, 0xb635, 0x2204, 0xa065, 0x0160, 0x080c, 0x4c0b,
+	0x2001, 0xb535, 0x2004, 0xd0ac, 0x0110, 0x6017, 0x0000, 0x012e,
+	0x0804, 0x2faa, 0x012e, 0x0804, 0x2fcf, 0x080c, 0x15f8, 0x0188,
+	0xa006, 0x6802, 0x7010, 0xa005, 0x1120, 0x2d00, 0x7012, 0x7016,
+	0x0030, 0x7014, 0x6802, 0x2060, 0x2d00, 0x6006, 0x7016, 0xad80,
+	0x000d, 0x0005, 0x7924, 0x810f, 0xa18c, 0x00ff, 0x080c, 0x4fa9,
+	0x1130, 0x7e28, 0xa684, 0x3fff, 0xa082, 0x4000, 0x0208, 0xa066,
+	0x8cff, 0x0005, 0x7e24, 0x860f, 0xa18c, 0x00ff, 0x080c, 0x4fa9,
+	0x1128, 0xa6b4, 0x00ff, 0xa682, 0x4000, 0x0208, 0xa066, 0x8cff,
+	0x0005, 0x0016, 0x7110, 0x81ff, 0x0128, 0x2168, 0x6904, 0x080c,
+	0x160f, 0x0cc8, 0x7112, 0x7116, 0x001e, 0x0005, 0x2031, 0x0001,
+	0x0010, 0x2031, 0x0000, 0x2061, 0xb5d2, 0x6606, 0x6112, 0x600e,
+	0x6226, 0x632a, 0x642e, 0x6532, 0x2c10, 0x080c, 0x1643, 0x7007,
+	0x0002, 0x701b, 0x2faa, 0x0005, 0x00f6, 0x0126, 0x2091, 0x8000,
+	0x2079, 0x0000, 0x2001, 0xb590, 0x2004, 0xa005, 0x1168, 0x0e04,
+	0x3ee4, 0x7818, 0xd084, 0x1140, 0x7a22, 0x7b26, 0x7c2a, 0x781b,
+	0x0001, 0x2091, 0x4080, 0x0408, 0x0016, 0x00c6, 0x00e6, 0x2071,
+	0xb582, 0x7138, 0xa182, 0x0010, 0x0218, 0x7030, 0x2060, 0x0078,
+	0x7030, 0xa0e0, 0x0004, 0xac82, 0xb5d2, 0x0210, 0x2061, 0xb592,
+	0x2c00, 0x7032, 0x81ff, 0x1108, 0x7036, 0x8108, 0x713a, 0x2262,
+	0x6306, 0x640a, 0x00ee, 0x00ce, 0x001e, 0x012e, 0x00fe, 0x0005,
+	0x00e6, 0x2071, 0xb582, 0x7038, 0xa005, 0x0570, 0x0126, 0x2091,
+	0x8000, 0x0e04, 0x3f3b, 0x00f6, 0x2079, 0x0000, 0x7818, 0xd084,
+	0x1508, 0x00c6, 0x7034, 0x2060, 0x2c04, 0x7822, 0x6004, 0x7826,
+	0x6008, 0x782a, 0x781b, 0x0001, 0x2091, 0x4080, 0x7038, 0x8001,
+	0x703a, 0xa005, 0x1130, 0x7033, 0xb592, 0x7037, 0xb592, 0x00ce,
+	0x0048, 0xac80, 0x0004, 0xa0fa, 0xb5d2, 0x0210, 0x2001, 0xb592,
+	0x7036, 0x00ce, 0x00fe, 0x012e, 0x00ee, 0x0005, 0x0026, 0x2001,
+	0xb553, 0x2004, 0xd0c4, 0x0120, 0x2011, 0x8014, 0x080c, 0x3ecc,
+	0x002e, 0x0005, 0x81ff, 0x1904, 0x2fcf, 0x0126, 0x2091, 0x8000,
+	0x6030, 0xc08d, 0xc085, 0xc0ac, 0x6032, 0x080c, 0x5acf, 0x1178,
+	0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001,
+	0xa085, 0x0001, 0x080c, 0x5b13, 0x080c, 0x5a07, 0x0010, 0x080c,
+	0x4b1f, 0x012e, 0x0804, 0x2faa, 0x7824, 0x2008, 0xa18c, 0xfffd,
+	0x1128, 0x61e0, 0xa10d, 0x61e2, 0x0804, 0x2faa, 0x0804, 0x2fd2,
+	0x81ff, 0x1904, 0x2fcf, 0x6000, 0xa086, 0x0003, 0x1904, 0x2fcf,
+	0x2001, 0xb553, 0x2004, 0xd0ac, 0x1904, 0x2fcf, 0x080c, 0x3e9a,
+	0x0904, 0x2fd2, 0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x1120,
+	0x7828, 0xa005, 0x0904, 0x2faa, 0x00c6, 0x080c, 0x3e75, 0x00ce,
+	0x0904, 0x2fcf, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd,
+	0x683a, 0x080c, 0x9e6b, 0x0904, 0x2fcf, 0x7007, 0x0003, 0x701b,
+	0x3faa, 0x0005, 0x6830, 0xa086, 0x0100, 0x0904, 0x2fcf, 0x0804,
+	0x2faa, 0x2001, 0xb500, 0x2004, 0xa086, 0x0003, 0x1904, 0x2fcf,
+	0x7f24, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3e75, 0x0904,
+	0x2fcf, 0x2009, 0x0000, 0x2031, 0x0000, 0x7023, 0x0000, 0x702f,
+	0x0000, 0xad80, 0x0005, 0x7026, 0x20a0, 0x080c, 0x4fa9, 0x1904,
+	0x4024, 0x6004, 0xa0c4, 0x00ff, 0xa8c6, 0x0006, 0x0130, 0xa0c4,
+	0xff00, 0xa8c6, 0x0600, 0x1904, 0x4024, 0x2001, 0xb553, 0x2004,
+	0xd0ac, 0x1128, 0x080c, 0x524a, 0x1110, 0xd79c, 0x05e8, 0xd794,
+	0x1110, 0xd784, 0x0158, 0xac80, 0x0006, 0x2098, 0x3400, 0x20a9,
+	0x0004, 0x53a3, 0x080c, 0x3ce7, 0xd794, 0x0148, 0xac80, 0x000a,
+	0x2098, 0x3400, 0x20a9, 0x0004, 0x53a3, 0x080c, 0x3ce7, 0x21a2,
+	0xd794, 0x01d8, 0xac80, 0x0000, 0x2098, 0x94a0, 0x20a9, 0x0002,
+	0x53a3, 0xac80, 0x0003, 0x20a6, 0x94a0, 0xac80, 0x0004, 0x2098,
+	0x3400, 0x20a9, 0x0002, 0x53a3, 0x080c, 0x3cd9, 0xac80, 0x0026,
+	0x2098, 0x20a9, 0x0002, 0x53a3, 0x0008, 0x94a0, 0xd794, 0x0110,
+	0xa6b0, 0x000b, 0xa6b0, 0x0005, 0x8108, 0x2001, 0xb535, 0x2004,
+	0xd0ac, 0x0118, 0xa186, 0x0100, 0x0040, 0xd78c, 0x0120, 0xa186,
+	0x0100, 0x0170, 0x0018, 0xa186, 0x007e, 0x0150, 0xd794, 0x0118,
+	0xa686, 0x0020, 0x0010, 0xa686, 0x0028, 0x0150, 0x0804, 0x3fcd,
+	0x86ff, 0x1120, 0x7120, 0x810b, 0x0804, 0x2faa, 0x702f, 0x0001,
+	0x711e, 0x7020, 0xa600, 0x7022, 0x772a, 0x2061, 0xb5d2, 0x6007,
+	0x0000, 0x6612, 0x7024, 0x600e, 0x6226, 0x632a, 0x642e, 0x6532,
+	0x2c10, 0x080c, 0x1643, 0x7007, 0x0002, 0x701b, 0x4060, 0x0005,
+	0x702c, 0xa005, 0x1170, 0x711c, 0x7024, 0x20a0, 0x7728, 0x2031,
+	0x0000, 0x2061, 0xb5d2, 0x6224, 0x6328, 0x642c, 0x6530, 0x0804,
+	0x3fcd, 0x7120, 0x810b, 0x0804, 0x2faa, 0x2029, 0x007e, 0x7924,
+	0x7a28, 0x7b2c, 0x7c38, 0xa184, 0xff00, 0x8007, 0xa0e2, 0x0020,
+	0x0a04, 0x2fd2, 0xa502, 0x0a04, 0x2fd2, 0xa184, 0x00ff, 0xa0e2,
+	0x0020, 0x0a04, 0x2fd2, 0xa502, 0x0a04, 0x2fd2, 0xa284, 0xff00,
+	0x8007, 0xa0e2, 0x0020, 0x0a04, 0x2fd2, 0xa502, 0x0a04, 0x2fd2,
+	0xa284, 0x00ff, 0xa0e2, 0x0020, 0x0a04, 0x2fd2, 0xa502, 0x0a04,
+	0x2fd2, 0xa384, 0xff00, 0x8007, 0xa0e2, 0x0020, 0x0a04, 0x2fd2,
+	0xa502, 0x0a04, 0x2fd2, 0xa384, 0x00ff, 0xa0e2, 0x0020, 0x0a04,
+	0x2fd2, 0xa502, 0x0a04, 0x2fd2, 0xa484, 0xff00, 0x8007, 0xa0e2,
+	0x0020, 0x0a04, 0x2fd2, 0xa502, 0x0a04, 0x2fd2, 0xa484, 0x00ff,
+	0xa0e2, 0x0020, 0x0a04, 0x2fd2, 0xa502, 0x0a04, 0x2fd2, 0x2061,
+	0xb7b9, 0x6102, 0x6206, 0x630a, 0x640e, 0x0804, 0x2faa, 0x0006,
+	0x2001, 0xb553, 0x2004, 0xd0cc, 0x000e, 0x0005, 0x0006, 0x2001,
+	0xb572, 0x2004, 0xd0bc, 0x000e, 0x0005, 0x6168, 0x7a24, 0x6300,
+	0x82ff, 0x1118, 0x7926, 0x0804, 0x2faa, 0x83ff, 0x1904, 0x2fd2,
+	0x2001, 0xfff0, 0xa200, 0x1a04, 0x2fd2, 0x2019, 0xffff, 0x606c,
+	0xa302, 0xa200, 0x0a04, 0x2fd2, 0x7926, 0x626a, 0x0804, 0x2faa,
+	0x2001, 0xb500, 0x2004, 0xa086, 0x0003, 0x1904, 0x2fcf, 0x7c28,
+	0x7d24, 0x7e38, 0x7f2c, 0x080c, 0x3e75, 0x0904, 0x2fcf, 0x2009,
+	0x0000, 0x2019, 0x0000, 0x7023, 0x0000, 0x702f, 0x0000, 0xad80,
+	0x0003, 0x7026, 0x20a0, 0xa1e0, 0xb635, 0x2c64, 0x8cff, 0x01b8,
+	0x6004, 0xa084, 0x00ff, 0xa086, 0x0006, 0x0130, 0x6004, 0xa084,
+	0xff00, 0xa086, 0x0600, 0x1158, 0x6014, 0x20a2, 0x94a0, 0x6010,
+	0x8007, 0xa105, 0x8007, 0x20a2, 0x94a0, 0xa398, 0x0002, 0x8108,
+	0xa182, 0x00ff, 0x0120, 0xa386, 0x002a, 0x0148, 0x08e0, 0x83ff,
+	0x1120, 0x7120, 0x810c, 0x0804, 0x2faa, 0x702f, 0x0001, 0x711e,
+	0x7020, 0xa300, 0x7022, 0x2061, 0xb5d2, 0x6007, 0x0000, 0x6312,
+	0x7024, 0x600e, 0x6426, 0x652a, 0x662e, 0x6732, 0x2c10, 0x080c,
+	0x1643, 0x7007, 0x0002, 0x701b, 0x4156, 0x0005, 0x702c, 0xa005,
+	0x1168, 0x711c, 0x7024, 0x20a0, 0x2019, 0x0000, 0x2061, 0xb5d2,
+	0x6424, 0x6528, 0x662c, 0x6730, 0x0804, 0x4113, 0x7120, 0x810c,
+	0x0804, 0x2faa, 0x81ff, 0x1904, 0x2fcf, 0x60d4, 0xd0ac, 0x1118,
+	0xd09c, 0x0904, 0x2fcf, 0x080c, 0x3e75, 0x0904, 0x2fcf, 0x7924,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3eb6, 0x701b, 0x4181,
+	0x0005, 0x00d6, 0xade8, 0x000d, 0x6828, 0xa0be, 0x7000, 0x0148,
+	0xa0be, 0x7100, 0x0130, 0xa0be, 0x7200, 0x0118, 0x00de, 0x0804,
+	0x2fd2, 0x6820, 0x6924, 0x080c, 0x281d, 0x1510, 0x080c, 0x4f4d,
+	0x11f8, 0x7122, 0x6612, 0x6516, 0x6e18, 0x00c6, 0x080c, 0x3e75,
+	0x01b8, 0x080c, 0x3e75, 0x01a0, 0x00ce, 0x00de, 0x6837, 0x0000,
+	0x6838, 0xc0fd, 0x683a, 0x6823, 0x0000, 0x6804, 0x2068, 0x080c,
+	0x9dbe, 0x0904, 0x2fcf, 0x7007, 0x0003, 0x701b, 0x41bb, 0x0005,
+	0x00de, 0x0804, 0x2fcf, 0x7120, 0x080c, 0x2d97, 0x6820, 0xa086,
+	0x8001, 0x0904, 0x2fcf, 0x2d00, 0x701e, 0x6804, 0xa080, 0x0002,
+	0x0006, 0x20a9, 0x002a, 0x2098, 0x20a0, 0x080c, 0x4b8f, 0x000e,
+	0xade8, 0x000d, 0x6a08, 0x6b0c, 0x6c10, 0x6d14, 0x2061, 0xb5d2,
+	0x6007, 0x0000, 0x6e00, 0x6f28, 0xa7c6, 0x7000, 0x1108, 0x0018,
+	0xa7c6, 0x7100, 0x1140, 0xa6c2, 0x0004, 0x0a04, 0x2fd2, 0x2009,
+	0x0004, 0x0804, 0x3eb9, 0xa7c6, 0x7200, 0x1904, 0x2fd2, 0xa6c2,
+	0x0054, 0x0a04, 0x2fd2, 0x600e, 0x6013, 0x002a, 0x6226, 0x632a,
+	0x642e, 0x6532, 0x2c10, 0x080c, 0x1643, 0x7007, 0x0002, 0x701b,
+	0x4202, 0x0005, 0x701c, 0x2068, 0x6804, 0xa080, 0x0001, 0x2004,
+	0xa080, 0x0002, 0x0006, 0x20a9, 0x002a, 0x2098, 0x20a0, 0x080c,
+	0x4b8f, 0x000e, 0x2009, 0x002a, 0x2061, 0xb5d2, 0x6224, 0x6328,
+	0x642c, 0x6530, 0x0804, 0x3eb9, 0x81ff, 0x1904, 0x2fcf, 0x792c,
+	0x2001, 0xb7a0, 0x2102, 0x080c, 0x3e8a, 0x0904, 0x2fd2, 0x080c,
+	0x506f, 0x0904, 0x2fcf, 0x0126, 0x2091, 0x8000, 0x080c, 0x51a1,
+	0x012e, 0x0804, 0x2faa, 0x7824, 0xd08c, 0x1118, 0xd084, 0x0904,
+	0x3a46, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x00c6, 0x080c, 0x3e75,
+	0x00ce, 0x1120, 0x2009, 0x0002, 0x0804, 0x2fcf, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x0128, 0xa08e, 0x0004, 0x0110, 0xa08e,
+	0x0005, 0x15b8, 0x7824, 0xd08c, 0x0120, 0x6000, 0xc08c, 0x6002,
+	0x0030, 0x2001, 0xb553, 0x2004, 0xd0b4, 0x0904, 0x3a82, 0x7824,
+	0xa084, 0xff00, 0xa08e, 0x7e00, 0x0904, 0x3a82, 0xa08e, 0x7f00,
+	0x0904, 0x3a82, 0xa08e, 0x8000, 0x0904, 0x3a82, 0x6000, 0xd08c,
+	0x1904, 0x3a82, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x080c,
+	0x9dda, 0x1120, 0x2009, 0x0003, 0x0804, 0x2fcf, 0x7007, 0x0003,
+	0x701b, 0x4283, 0x0005, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x0804,
+	0x3a82, 0x2009, 0xb531, 0x210c, 0x81ff, 0x0120, 0x2009, 0x0001,
+	0x0804, 0x2fcf, 0x2001, 0xb500, 0x2004, 0xa086, 0x0003, 0x0120,
+	0x2009, 0x0007, 0x0804, 0x2fcf, 0x2001, 0xb553, 0x2004, 0xd0ac,
+	0x0120, 0x2009, 0x0008, 0x0804, 0x2fcf, 0x609c, 0xd0a4, 0x1118,
+	0xd0ac, 0x1904, 0x3a82, 0x6837, 0x0000, 0x6833, 0x0000, 0x6838,
+	0xc0fd, 0x683a, 0x080c, 0x9e6b, 0x1120, 0x2009, 0x0003, 0x0804,
+	0x2fcf, 0x7007, 0x0003, 0x701b, 0x42be, 0x0005, 0x6830, 0xa086,
+	0x0100, 0x1120, 0x2009, 0x0004, 0x0804, 0x2fcf, 0x080c, 0x3e9a,
+	0x0904, 0x2fd2, 0x0804, 0x4252, 0x81ff, 0x2009, 0x0001, 0x1904,
+	0x2fcf, 0x6000, 0xa086, 0x0003, 0x2009, 0x0007, 0x1904, 0x2fcf,
+	0x2001, 0xb553, 0x2004, 0xd0ac, 0x2009, 0x0008, 0x1904, 0x2fcf,
+	0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x6004, 0xa084, 0x00ff, 0xa086,
+	0x0006, 0x2009, 0x0009, 0x1904, 0x2fcf, 0x00c6, 0x080c, 0x3e75,
+	0x00ce, 0x2009, 0x0002, 0x0904, 0x2fcf, 0x6837, 0x0000, 0x6833,
+	0x0000, 0x6838, 0xc0fd, 0x683a, 0x7928, 0xa194, 0xff00, 0xa18c,
+	0x00ff, 0xa006, 0x82ff, 0x1128, 0xc0ed, 0x6952, 0x792c, 0x6956,
+	0x0048, 0xa28e, 0x0100, 0x1904, 0x2fd2, 0xc0e5, 0x6853, 0x0000,
+	0x6857, 0x0000, 0x683e, 0x080c, 0xa028, 0x2009, 0x0003, 0x0904,
+	0x2fcf, 0x7007, 0x0003, 0x701b, 0x431e, 0x0005, 0x6830, 0xa086,
+	0x0100, 0x2009, 0x0004, 0x0904, 0x2fcf, 0x0804, 0x2faa, 0x81ff,
+	0x2009, 0x0001, 0x1904, 0x2fcf, 0x6000, 0xa086, 0x0003, 0x2009,
+	0x0007, 0x1904, 0x2fcf, 0x080c, 0x3e9a, 0x0904, 0x2fd2, 0x6004,
+	0xa084, 0x00ff, 0xa086, 0x0006, 0x2009, 0x0009, 0x1904, 0x2fcf,
+	0x00c6, 0x080c, 0x3e75, 0x00ce, 0x2009, 0x0002, 0x0904, 0x2fcf,
+	0xad80, 0x000f, 0x2009, 0x0008, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38,
+	0x080c, 0x3eb6, 0x701b, 0x4355, 0x0005, 0x00d6, 0xade8, 0x000f,
+	0x6800, 0xa086, 0x0500, 0x1140, 0x6804, 0xa005, 0x1128, 0x6808,
+	0xa084, 0xff00, 0x1108, 0x0018, 0x00de, 0x1904, 0x2fd2, 0x00de,
+	0x6837, 0x0000, 0x6833, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x00c6,
+	0x080c, 0x3e9a, 0x1118, 0x00ce, 0x0804, 0x2fd2, 0x080c, 0xa077,
+	0x2009, 0x0003, 0x00ce, 0x0904, 0x2fcf, 0x7007, 0x0003, 0x701b,
+	0x4382, 0x0005, 0x6830, 0xa086, 0x0100, 0x2009, 0x0004, 0x0904,
+	0x2fcf, 0x0804, 0x2faa, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804,
+	0x2fcf, 0x6000, 0xa086, 0x0003, 0x0120, 0x2009, 0x0007, 0x0804,
+	0x2fcf, 0x7e24, 0x860f, 0xa18c, 0x00ff, 0xa6b4, 0x00ff, 0x080c,
+	0x4fa9, 0x1904, 0x2fd2, 0xa186, 0x007f, 0x0150, 0x6004, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x0120, 0x2009, 0x0009, 0x0804, 0x2fcf,
+	0x00c6, 0x080c, 0x3e75, 0x00ce, 0x1120, 0x2009, 0x0002, 0x0804,
+	0x2fcf, 0x6837, 0x0000, 0x6838, 0xc0fd, 0x683a, 0x2001, 0x0100,
+	0x8007, 0x680a, 0x080c, 0x9df5, 0x1120, 0x2009, 0x0003, 0x0804,
+	0x2fcf, 0x7007, 0x0003, 0x701b, 0x43ce, 0x0005, 0x6808, 0x8007,
+	0xa086, 0x0100, 0x1120, 0x2009, 0x0004, 0x0804, 0x2fcf, 0x68b0,
+	0x6836, 0x6810, 0x8007, 0xa084, 0x00ff, 0x800c, 0x6814, 0x8007,
+	0xa084, 0x00ff, 0x8004, 0xa080, 0x0002, 0xa108, 0xad80, 0x0004,
+	0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3eb9, 0x080c, 0x3e75,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x2fcf, 0x7924, 0xa194, 0xff00,
+	0xa18c, 0x00ff, 0x8217, 0x82ff, 0x0110, 0x0804, 0x2fd2, 0x2009,
+	0x001a, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x080c, 0x3eb6, 0x701b,
+	0x440a, 0x0005, 0x2001, 0xb52a, 0x2003, 0x0001, 0xad80, 0x000d,
+	0x2098, 0x20a9, 0x001a, 0x20a1, 0xb7c6, 0x53a3, 0x0804, 0x2faa,
+	0x080c, 0x3e75, 0x1120, 0x2009, 0x0002, 0x0804, 0x2fcf, 0x7924,
+	0xa194, 0xff00, 0xa18c, 0x00ff, 0x8217, 0x82ff, 0x0110, 0x0804,
+	0x2fd2, 0x2099, 0xb7c6, 0x20a0, 0x20a9, 0x001a, 0x53a3, 0x2009,
+	0x001a, 0x7a2c, 0x7b28, 0x7c3c, 0x7d38, 0x0804, 0x3eb9, 0x7824,
+	0xa08a, 0x1000, 0x1a04, 0x2fd2, 0x0126, 0x2091, 0x8000, 0x8003,
+	0x800b, 0x810b, 0xa108, 0x00c6, 0x2061, 0xb7f3, 0x6142, 0x00ce,
+	0x012e, 0x0804, 0x2faa, 0x00c6, 0x080c, 0x5acf, 0x1188, 0x2001,
+	0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0xa085,
+	0x0001, 0x080c, 0x5b13, 0x080c, 0x5a07, 0x080c, 0x1515, 0x0038,
+	0x2061, 0xb500, 0x6030, 0xc09d, 0x6032, 0x080c, 0x4b1f, 0x00ce,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x00c6, 0x2061, 0xb7f3, 0x7924,
+	0x6152, 0x614e, 0x6057, 0x0000, 0x604b, 0x0009, 0x7838, 0x606a,
+	0x783c, 0x6066, 0x7828, 0x6062, 0x782c, 0x605e, 0x2061, 0xb7a1,
+	0x2001, 0xb808, 0x600e, 0x6013, 0x0001, 0x6017, 0x0002, 0x6007,
+	0x0000, 0x6037, 0x0000, 0x00ce, 0x012e, 0x0804, 0x2faa, 0x0126,
+	0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071, 0xb500, 0x6044, 0xd0a4,
+	0x11b0, 0xd084, 0x0118, 0x080c, 0x4606, 0x0068, 0xd08c, 0x0118,
+	0x080c, 0x4527, 0x0040, 0xd094, 0x0118, 0x080c, 0x44f8, 0x0018,
+	0xd09c, 0x0108, 0x0061, 0x00ee, 0x00ce, 0x012e, 0x0005, 0x0016,
+	0x6128, 0xd19c, 0x1110, 0xc19d, 0x612a, 0x001e, 0x0ca0, 0x624c,
+	0xa286, 0xf0f0, 0x1150, 0x6048, 0xa086, 0xf0f0, 0x0130, 0x624a,
+	0x6043, 0x0090, 0x6043, 0x0010, 0x0490, 0xa294, 0xff00, 0xa296,
+	0xf700, 0x0178, 0x7134, 0xd1a4, 0x1160, 0x6240, 0xa295, 0x0100,
+	0x6242, 0xa294, 0x0010, 0x0128, 0x2009, 0x00f7, 0x080c, 0x4baf,
+	0x00f0, 0x6040, 0xa084, 0x0010, 0xa085, 0x0140, 0x6042, 0x6043,
+	0x0000, 0x707b, 0x0000, 0x7097, 0x0001, 0x70bb, 0x0000, 0x70d7,
+	0x0000, 0x2009, 0xbcc0, 0x200b, 0x0000, 0x708b, 0x0000, 0x707f,
+	0x000a, 0x2009, 0x000a, 0x2011, 0x4ad5, 0x080c, 0x6a22, 0x0005,
+	0x0156, 0x2001, 0xb574, 0x2004, 0xd08c, 0x0110, 0x7053, 0xffff,
+	0x707c, 0xa005, 0x1510, 0x2011, 0x4ad5, 0x080c, 0x699c, 0x6040,
+	0xa094, 0x0010, 0xa285, 0x0020, 0x6042, 0x20a9, 0x00c8, 0x6044,
+	0xd08c, 0x1168, 0x1f04, 0x450f, 0x6242, 0x708f, 0x0000, 0x6040,
+	0xa094, 0x0010, 0xa285, 0x0080, 0x6042, 0x6242, 0x0030, 0x6242,
+	0x708f, 0x0000, 0x7083, 0x0000, 0x0000, 0x015e, 0x0005, 0x7080,
+	0xa08a, 0x0003, 0x1210, 0x0023, 0x0010, 0x080c, 0x1515, 0x0005,
+	0x4533, 0x4583, 0x4605, 0x00f6, 0x7083, 0x0001, 0x20e1, 0xa000,
+	0xe000, 0x20e1, 0x8700, 0x080c, 0x2470, 0x20e1, 0x9080, 0x20e1,
+	0x4000, 0x2079, 0xbb00, 0x207b, 0x2200, 0x7807, 0x00ef, 0x780b,
+	0x0000, 0x780f, 0x00ef, 0x7813, 0x0138, 0x7817, 0x0000, 0x781b,
+	0x0000, 0x781f, 0x0000, 0x7823, 0xffff, 0x7827, 0xffff, 0x782b,
+	0x0000, 0x782f, 0x0000, 0x2079, 0xbb0c, 0x207b, 0x1101, 0x7807,
+	0x0000, 0x2099, 0xb505, 0x20a1, 0xbb0e, 0x20a9, 0x0004, 0x53a3,
+	0x2079, 0xbb12, 0x207b, 0x0000, 0x7807, 0x0000, 0x2099, 0xbb00,
+	0x20a1, 0x020b, 0x20a9, 0x0014, 0x53a6, 0x60c3, 0x000c, 0x600f,
+	0x0000, 0x080c, 0x4b06, 0x00fe, 0x7087, 0x0000, 0x6043, 0x0008,
+	0x6043, 0x0000, 0x0005, 0x00d6, 0x7084, 0x7087, 0x0000, 0xa025,
+	0x0904, 0x45ed, 0x6020, 0xd0b4, 0x1904, 0x45eb, 0x7194, 0x81ff,
+	0x0904, 0x45db, 0xa486, 0x000c, 0x1904, 0x45e6, 0xa480, 0x0018,
+	0x8004, 0x20a8, 0x2011, 0xbb80, 0x2019, 0xbb00, 0x220c, 0x2304,
+	0xa106, 0x11b8, 0x8210, 0x8318, 0x1f04, 0x459e, 0x6043, 0x0004,
+	0x608b, 0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0006, 0x7083, 0x0002,
+	0x708f, 0x0002, 0x2009, 0x07d0, 0x2011, 0x4adc, 0x080c, 0x6a22,
+	0x0490, 0x2069, 0xbb80, 0x6930, 0xa18e, 0x1101, 0x1538, 0x6834,
+	0xa005, 0x1520, 0x6900, 0xa18c, 0x00ff, 0x1118, 0x6804, 0xa005,
+	0x0190, 0x2011, 0xbb8e, 0x2019, 0xb505, 0x20a9, 0x0004, 0x220c,
+	0x2304, 0xa102, 0x0230, 0x1190, 0x8210, 0x8318, 0x1f04, 0x45cf,
+	0x0068, 0x7097, 0x0000, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xbb80, 0x20a1, 0x020b, 0x20a9, 0x0014, 0x53a6, 0x6043, 0x0008,
+	0x6043, 0x0000, 0x0010, 0x00de, 0x0005, 0x6040, 0xa085, 0x0100,
+	0x6042, 0x6020, 0xd0b4, 0x1db8, 0x60c3, 0x000c, 0x2011, 0xb7ea,
+	0x2013, 0x0000, 0x7087, 0x0000, 0x20e1, 0x9080, 0x60a3, 0x0056,
+	0x60a7, 0x9575, 0x080c, 0x7d71, 0x0c30, 0x0005, 0x708c, 0xa08a,
+	0x001d, 0x1210, 0x0023, 0x0010, 0x080c, 0x1515, 0x0005, 0x4639,
+	0x4648, 0x4670, 0x4689, 0x46ad, 0x46d5, 0x46f9, 0x472a, 0x474e,
+	0x4776, 0x47ad, 0x47d5, 0x47f1, 0x4807, 0x4827, 0x483a, 0x4842,
+	0x4872, 0x4896, 0x48be, 0x48e2, 0x4913, 0x4950, 0x497f, 0x499b,
+	0x49da, 0x49fa, 0x4a13, 0x4a14, 0x00c6, 0x2061, 0xb500, 0x6003,
+	0x0007, 0x2061, 0x0100, 0x6004, 0xa084, 0xfff9, 0x6006, 0x00ce,
+	0x0005, 0x608b, 0xbc94, 0x608f, 0xf0f0, 0x6043, 0x0002, 0x708f,
+	0x0001, 0x2009, 0x07d0, 0x2011, 0x4adc, 0x080c, 0x6a22, 0x0005,
+	0x00f6, 0x7084, 0xa086, 0x0014, 0x1508, 0x6043, 0x0000, 0x6020,
+	0xd0b4, 0x11e0, 0x2079, 0xbb80, 0x7a30, 0xa296, 0x1102, 0x11a0,
+	0x7834, 0xa005, 0x1188, 0x7a38, 0xd2fc, 0x0128, 0x70b8, 0xa005,
+	0x1110, 0x70bb, 0x0001, 0x2011, 0x4adc, 0x080c, 0x699c, 0x708f,
+	0x0010, 0x080c, 0x4842, 0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005,
+	0x708f, 0x0003, 0x6043, 0x0004, 0x2011, 0x4adc, 0x080c, 0x699c,
+	0x080c, 0x4b97, 0x20a3, 0x1102, 0x20a3, 0x0000, 0x20a9, 0x000a,
+	0x20a3, 0x0000, 0x1f04, 0x4680, 0x60c3, 0x0014, 0x080c, 0x4b06,
+	0x0005, 0x00f6, 0x7084, 0xa005, 0x01f0, 0x2011, 0x4adc, 0x080c,
+	0x699c, 0xa086, 0x0014, 0x11a8, 0x2079, 0xbb80, 0x7a30, 0xa296,
+	0x1102, 0x1178, 0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc, 0x0128,
+	0x70b8, 0xa005, 0x1110, 0x70bb, 0x0001, 0x708f, 0x0004, 0x0029,
+	0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005, 0x708f, 0x0005, 0x080c,
+	0x4b97, 0x20a3, 0x1103, 0x20a3, 0x0000, 0x3430, 0x2011, 0xbb8e,
+	0x080c, 0x4be8, 0x1160, 0x7078, 0xa005, 0x1148, 0x7150, 0xa186,
+	0xffff, 0x0128, 0x080c, 0x4aa0, 0x0110, 0x080c, 0x4bc6, 0x20a9,
+	0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x60c3, 0x0014, 0x080c, 0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005,
+	0x01f0, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086, 0x0014, 0x11a8,
+	0x2079, 0xbb80, 0x7a30, 0xa296, 0x1103, 0x1178, 0x7834, 0xa005,
+	0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b8, 0xa005, 0x1110, 0x70bb,
+	0x0001, 0x708f, 0x0006, 0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe,
+	0x0005, 0x708f, 0x0007, 0x080c, 0x4b97, 0x20a3, 0x1104, 0x20a3,
+	0x0000, 0x3430, 0x2011, 0xbb8e, 0x080c, 0x4be8, 0x11a8, 0x7078,
+	0xa005, 0x1190, 0x7158, 0xa186, 0xffff, 0x0170, 0xa180, 0x2dc4,
+	0x200d, 0xa18c, 0xff00, 0x810f, 0x080c, 0x4aa0, 0x0128, 0x080c,
+	0x40d6, 0x0110, 0x080c, 0x2867, 0x20a9, 0x0008, 0x2298, 0x26a0,
+	0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014, 0x080c,
+	0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005, 0x01f0, 0x2011, 0x4adc,
+	0x080c, 0x699c, 0xa086, 0x0014, 0x11a8, 0x2079, 0xbb80, 0x7a30,
+	0xa296, 0x1104, 0x1178, 0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70b8, 0xa005, 0x1110, 0x70bb, 0x0001, 0x708f, 0x0008,
+	0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005, 0x708f, 0x0009,
+	0x080c, 0x4b97, 0x20a3, 0x1105, 0x20a3, 0x0100, 0x3430, 0x080c,
+	0x4be8, 0x1150, 0x7078, 0xa005, 0x1138, 0x080c, 0x4a15, 0x1170,
+	0xa085, 0x0001, 0x080c, 0x2867, 0x20a9, 0x0008, 0x2099, 0xbb8e,
+	0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x080c, 0x4b06, 0x0010, 0x080c, 0x462c, 0x0005, 0x00f6, 0x7084,
+	0xa005, 0x0588, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086, 0x0014,
+	0x1540, 0x2079, 0xbb80, 0x7a30, 0xa296, 0x1105, 0x1510, 0x7834,
+	0x2011, 0x0100, 0xa21e, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b8,
+	0xa005, 0x1110, 0x70bb, 0x0001, 0x708f, 0x000a, 0x00b1, 0x0098,
+	0xa005, 0x1178, 0x7a38, 0xd2fc, 0x0128, 0x70b8, 0xa005, 0x1110,
+	0x70bb, 0x0001, 0x708b, 0x0000, 0x708f, 0x000e, 0x080c, 0x4827,
+	0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005, 0x708f, 0x000b, 0x2011,
+	0xbb0e, 0x22a0, 0x20a9, 0x0040, 0x2019, 0xffff, 0x43a4, 0x20a9,
+	0x0002, 0x2009, 0x0000, 0x41a4, 0x080c, 0x4b97, 0x20a3, 0x1106,
+	0x20a3, 0x0000, 0x080c, 0x4be8, 0x0118, 0x2013, 0x0000, 0x0020,
+	0x7054, 0xa085, 0x0100, 0x2012, 0x2298, 0x20a9, 0x0042, 0x53a6,
+	0x60c3, 0x0084, 0x080c, 0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005,
+	0x01b0, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086, 0x0084, 0x1168,
+	0x2079, 0xbb80, 0x7a30, 0xa296, 0x1106, 0x1138, 0x7834, 0xa005,
+	0x1120, 0x708f, 0x000c, 0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe,
+	0x0005, 0x708f, 0x000d, 0x080c, 0x4b97, 0x20a3, 0x1107, 0x20a3,
+	0x0000, 0x2099, 0xbb8e, 0x20a9, 0x0040, 0x53a6, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x0084, 0x080c, 0x4b06, 0x0005, 0x00f6,
+	0x7084, 0xa005, 0x01d0, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086,
+	0x0084, 0x1188, 0x2079, 0xbb80, 0x7a30, 0xa296, 0x1107, 0x1158,
+	0x7834, 0xa005, 0x1140, 0x708b, 0x0001, 0x080c, 0x4b89, 0x708f,
+	0x000e, 0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005, 0x708f,
+	0x000f, 0x7087, 0x0000, 0x608b, 0xbc85, 0x608f, 0xb5b5, 0x6043,
+	0x0005, 0x6043, 0x0004, 0x2009, 0x07d0, 0x2011, 0x4adc, 0x080c,
+	0x6990, 0x0005, 0x7084, 0xa005, 0x0120, 0x2011, 0x4adc, 0x080c,
+	0x699c, 0x0005, 0x708f, 0x0011, 0x080c, 0x4be8, 0x11a0, 0x7170,
+	0x81ff, 0x0188, 0x2009, 0x0000, 0x7074, 0xa084, 0x00ff, 0x080c,
+	0x281d, 0xa186, 0x007e, 0x0138, 0xa186, 0x0080, 0x0120, 0x2011,
+	0xbb8e, 0x080c, 0x4aa0, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xbb80, 0x20a1, 0x020b, 0x7484, 0xa480, 0x0018, 0xa080, 0x0007,
+	0xa084, 0x03f8, 0x8004, 0x20a8, 0x53a6, 0x60c3, 0x0014, 0x080c,
+	0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005, 0x01f0, 0x2011, 0x4adc,
+	0x080c, 0x699c, 0xa086, 0x0014, 0x11a8, 0x2079, 0xbb80, 0x7a30,
+	0xa296, 0x1103, 0x1178, 0x7834, 0xa005, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70b8, 0xa005, 0x1110, 0x70bb, 0x0001, 0x708f, 0x0012,
+	0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005, 0x708f, 0x0013,
+	0x080c, 0x4ba3, 0x20a3, 0x1103, 0x20a3, 0x0000, 0x3430, 0x2011,
+	0xbb8e, 0x080c, 0x4be8, 0x1160, 0x7078, 0xa005, 0x1148, 0x7150,
+	0xa186, 0xffff, 0x0128, 0x080c, 0x4aa0, 0x0110, 0x080c, 0x4bc6,
+	0x20a9, 0x0008, 0x2298, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x0014, 0x080c, 0x4b06, 0x0005, 0x00f6, 0x7084,
+	0xa005, 0x01f0, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086, 0x0014,
+	0x11a8, 0x2079, 0xbb80, 0x7a30, 0xa296, 0x1104, 0x1178, 0x7834,
+	0xa005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70b8, 0xa005, 0x1110,
+	0x70bb, 0x0001, 0x708f, 0x0014, 0x0029, 0x0010, 0x080c, 0x4b1f,
+	0x00fe, 0x0005, 0x708f, 0x0015, 0x080c, 0x4ba3, 0x20a3, 0x1104,
+	0x20a3, 0x0000, 0x3430, 0x2011, 0xbb8e, 0x080c, 0x4be8, 0x11a8,
+	0x7078, 0xa005, 0x1190, 0x7158, 0xa186, 0xffff, 0x0170, 0xa180,
+	0x2dc4, 0x200d, 0xa18c, 0xff00, 0x810f, 0x080c, 0x4aa0, 0x0128,
+	0x080c, 0x40d6, 0x0110, 0x080c, 0x2867, 0x20a9, 0x0008, 0x2298,
+	0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x080c, 0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005, 0x05b8, 0x2011,
+	0x4adc, 0x080c, 0x699c, 0xa086, 0x0014, 0x1570, 0x2079, 0xbb80,
+	0x7a30, 0xa296, 0x1105, 0x1540, 0x7834, 0x2011, 0x0100, 0xa21e,
+	0x1148, 0x7a38, 0xd2fc, 0x0128, 0x70b8, 0xa005, 0x1110, 0x70bb,
+	0x0001, 0x0060, 0xa005, 0x11c0, 0x7a38, 0xd2fc, 0x0128, 0x70b8,
+	0xa005, 0x1110, 0x70bb, 0x0001, 0x708b, 0x0000, 0x7a38, 0xd2f4,
+	0x0138, 0x2001, 0xb574, 0x2004, 0xd0a4, 0x1110, 0x70d7, 0x0008,
+	0x708f, 0x0016, 0x0029, 0x0010, 0x080c, 0x4b1f, 0x00fe, 0x0005,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099, 0xbb80, 0x20a1, 0x020b,
+	0x20a9, 0x000e, 0x53a6, 0x3430, 0x2011, 0xbb8e, 0x708f, 0x0017,
+	0x080c, 0x4be8, 0x1150, 0x7078, 0xa005, 0x1138, 0x080c, 0x4a15,
+	0x1170, 0xa085, 0x0001, 0x080c, 0x2867, 0x20a9, 0x0008, 0x2099,
+	0xbb8e, 0x26a0, 0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x080c, 0x4b06, 0x0010, 0x080c, 0x462c, 0x0005, 0x00f6,
+	0x7084, 0xa005, 0x01b0, 0x2011, 0x4adc, 0x080c, 0x699c, 0xa086,
+	0x0084, 0x1168, 0x2079, 0xbb80, 0x7a30, 0xa296, 0x1106, 0x1138,
+	0x7834, 0xa005, 0x1120, 0x708f, 0x0018, 0x0029, 0x0010, 0x080c,
+	0x4b1f, 0x00fe, 0x0005, 0x708f, 0x0019, 0x080c, 0x4ba3, 0x20a3,
+	0x1106, 0x20a3, 0x0000, 0x3430, 0x2099, 0xbb8e, 0x2039, 0xbb0e,
+	0x27a0, 0x20a9, 0x0040, 0x53a3, 0x080c, 0x4be8, 0x11e8, 0x2728,
+	0x2514, 0x8207, 0xa084, 0x00ff, 0x8000, 0x2018, 0xa294, 0x00ff,
+	0x8007, 0xa205, 0x202a, 0x7054, 0x2310, 0x8214, 0xa2a0, 0xbb0e,
+	0x2414, 0xa38c, 0x0001, 0x0118, 0xa294, 0xff00, 0x0018, 0xa294,
+	0x00ff, 0x8007, 0xa215, 0x2222, 0x2798, 0x26a0, 0x20a9, 0x0040,
+	0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0084, 0x080c,
+	0x4b06, 0x0005, 0x00f6, 0x7084, 0xa005, 0x01d0, 0x2011, 0x4adc,
+	0x080c, 0x699c, 0xa086, 0x0084, 0x1188, 0x2079, 0xbb80, 0x7a30,
+	0xa296, 0x1107, 0x1158, 0x7834, 0xa005, 0x1140, 0x708b, 0x0001,
+	0x080c, 0x4b89, 0x708f, 0x001a, 0x0029, 0x0010, 0x080c, 0x4b1f,
+	0x00fe, 0x0005, 0x708f, 0x001b, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x2099, 0xbb80, 0x20a1, 0x020b, 0x7484, 0xa480, 0x0018, 0xa080,
+	0x0007, 0xa084, 0x03f8, 0x8004, 0x20a8, 0x53a6, 0x60c3, 0x0084,
+	0x080c, 0x4b06, 0x0005, 0x0005, 0x0005, 0x0086, 0x0096, 0x2029,
+	0xb553, 0x252c, 0x20a9, 0x0008, 0x2041, 0xbb0e, 0x28a0, 0x2099,
+	0xbb8e, 0x53a3, 0x20a9, 0x0008, 0x2011, 0x0007, 0xd5d4, 0x0110,
+	0x2011, 0x0000, 0x2800, 0xa200, 0x200c, 0xa1a6, 0xffff, 0x1148,
+	0xd5d4, 0x0110, 0x8210, 0x0008, 0x8211, 0x1f04, 0x4a2a, 0x0804,
+	0x4a98, 0x82ff, 0x1160, 0xd5d4, 0x0120, 0xa1a6, 0x3fff, 0x0d90,
+	0x0020, 0xa1a6, 0x3fff, 0x0904, 0x4a98, 0xa18d, 0xc000, 0x20a9,
+	0x0010, 0x2019, 0x0001, 0xd5d4, 0x0110, 0x2019, 0x0010, 0x2120,
+	0xd5d4, 0x0110, 0x8423, 0x0008, 0x8424, 0x1240, 0xd5d4, 0x0110,
+	0x8319, 0x0008, 0x8318, 0x1f04, 0x4a50, 0x04d0, 0x23a8, 0x2021,
+	0x0001, 0x8426, 0x8425, 0x1f04, 0x4a62, 0x2328, 0x8529, 0xa2be,
+	0x0007, 0x0158, 0x0006, 0x2039, 0x0007, 0x2200, 0xa73a, 0x000e,
+	0x27a8, 0xa5a8, 0x0010, 0x1f04, 0x4a71, 0x7552, 0xa5c8, 0x2dc4,
+	0x292d, 0xa5ac, 0x00ff, 0x7576, 0x6532, 0x6536, 0x0016, 0x2508,
+	0x080c, 0x2847, 0x001e, 0x60e7, 0x0000, 0x65ea, 0x2018, 0x2304,
+	0xa405, 0x201a, 0x707b, 0x0001, 0x26a0, 0x2898, 0x20a9, 0x0008,
+	0x53a6, 0x20a3, 0x0000, 0x20a3, 0x0000, 0xa085, 0x0001, 0x0028,
+	0xa006, 0x0018, 0xa006, 0x080c, 0x1515, 0x009e, 0x008e, 0x0005,
+	0x2118, 0x2021, 0x0000, 0x2001, 0x0007, 0xa39a, 0x0010, 0x0218,
+	0x8420, 0x8001, 0x0cd0, 0x2118, 0x84ff, 0x0120, 0xa39a, 0x0010,
+	0x8421, 0x1de0, 0x2021, 0x0001, 0x83ff, 0x0118, 0x8423, 0x8319,
+	0x1de8, 0xa238, 0x2704, 0xa42c, 0x11b8, 0xa405, 0x203a, 0x7152,
+	0xa1a0, 0x2dc4, 0x242d, 0xa5ac, 0x00ff, 0x7576, 0x6532, 0x6536,
+	0x0016, 0x2508, 0x080c, 0x2847, 0x001e, 0x60e7, 0x0000, 0x65ea,
+	0x707b, 0x0001, 0xa084, 0x0000, 0x0005, 0x00e6, 0x2071, 0xb500,
+	0x707f, 0x0000, 0x00ee, 0x0005, 0x00e6, 0x00f6, 0x2079, 0x0100,
+	0x2071, 0x0140, 0x080c, 0x7d7a, 0x7004, 0xa084, 0x4000, 0x0120,
+	0x7003, 0x1000, 0x7003, 0x0000, 0x0126, 0x2091, 0x8000, 0x2071,
+	0xb523, 0x2073, 0x0000, 0x7840, 0x0026, 0x0016, 0x2009, 0x00f7,
+	0x080c, 0x4baf, 0x001e, 0xa094, 0x0010, 0xa285, 0x0080, 0x7842,
+	0x7a42, 0x002e, 0x012e, 0x00fe, 0x00ee, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x2011, 0xb7ea, 0x2013, 0x0000, 0x7087, 0x0000, 0x012e,
+	0x20e1, 0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575, 0x080c, 0x7d71,
+	0x2009, 0x07d0, 0x2011, 0x4adc, 0x080c, 0x6a22, 0x0005, 0x0016,
+	0x0026, 0x00c6, 0x0126, 0x2091, 0x8000, 0x2011, 0x0003, 0x080c,
+	0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c, 0x7f59, 0x0036,
+	0x2019, 0x0000, 0x080c, 0x7fe4, 0x003e, 0x2009, 0x00f7, 0x080c,
+	0x4baf, 0x2061, 0xb7f3, 0x601b, 0x0000, 0x601f, 0x0000, 0x2061,
+	0xb500, 0x6003, 0x0001, 0x2061, 0x0100, 0x6043, 0x0090, 0x6043,
+	0x0010, 0x2009, 0x002d, 0x2011, 0x4b54, 0x080c, 0x6990, 0x012e,
+	0x00ce, 0x002e, 0x001e, 0x0005, 0x00e6, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x2071, 0x0100, 0x080c, 0x7d7a, 0x2071, 0x0140, 0x7004,
+	0xa084, 0x4000, 0x0120, 0x7003, 0x1000, 0x7003, 0x0000, 0x080c,
+	0x5ad7, 0x01a8, 0x080c, 0x5af5, 0x1190, 0x2001, 0xb79e, 0x2003,
+	0xaaaa, 0x0016, 0x080c, 0x28eb, 0x2001, 0xb78f, 0x2102, 0x001e,
+	0x2001, 0xb79f, 0x2003, 0x0000, 0x080c, 0x5a07, 0x0030, 0x2001,
+	0x0001, 0x080c, 0x27c3, 0x080c, 0x4b1f, 0x012e, 0x000e, 0x00ee,
+	0x0005, 0x20a9, 0x0040, 0x20a1, 0xbcc0, 0x2099, 0xbb8e, 0x3304,
+	0x8007, 0x20a2, 0x9398, 0x94a0, 0x1f04, 0x4b8f, 0x0005, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x2099, 0xbb00, 0x20a1, 0x020b, 0x20a9,
+	0x000c, 0x53a6, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x2099,
+	0xbb80, 0x20a1, 0x020b, 0x20a9, 0x000c, 0x53a6, 0x0005, 0x00c6,
+	0x0006, 0x2061, 0x0100, 0x810f, 0x2001, 0xb531, 0x2004, 0xa005,
+	0x1138, 0x2001, 0xb515, 0x2004, 0xa084, 0x00ff, 0xa105, 0x0010,
+	0xa185, 0x00f7, 0x604a, 0x000e, 0x00ce, 0x0005, 0x0016, 0x0046,
+	0x2001, 0xb553, 0x2004, 0xd0a4, 0x0158, 0xa006, 0x2020, 0x2009,
+	0x002a, 0x080c, 0xb0e8, 0x2001, 0xb50c, 0x200c, 0xc195, 0x2102,
+	0x2019, 0x002a, 0x2009, 0x0000, 0x080c, 0x2c6f, 0x004e, 0x001e,
+	0x0005, 0x080c, 0x4b1f, 0x708f, 0x0000, 0x7087, 0x0000, 0x0005,
+	0x0006, 0x2001, 0xb50c, 0x2004, 0xd09c, 0x0100, 0x000e, 0x0005,
+	0x0006, 0x0016, 0x0126, 0x2091, 0x8000, 0x2001, 0x0101, 0x200c,
+	0xa18d, 0x0006, 0x2102, 0x012e, 0x001e, 0x000e, 0x0005, 0x0156,
+	0x20a9, 0x00ff, 0x2009, 0xb635, 0xa006, 0x200a, 0x8108, 0x1f04,
+	0x4c05, 0x015e, 0x0005, 0x00d6, 0x0036, 0x0156, 0x0136, 0x0146,
+	0x2069, 0xb552, 0xa006, 0x6002, 0x6007, 0x0707, 0x600a, 0x600e,
+	0x6012, 0xa198, 0x2dc4, 0x231d, 0xa39c, 0x00ff, 0x6316, 0x20a9,
+	0x0004, 0xac98, 0x0006, 0x23a0, 0x40a4, 0x20a9, 0x0004, 0xac98,
+	0x000a, 0x23a0, 0x40a4, 0x603e, 0x6042, 0x604e, 0x6052, 0x6056,
+	0x605a, 0x605e, 0x6062, 0x6066, 0x606a, 0x606e, 0x6072, 0x6076,
+	0x607a, 0x607e, 0x6082, 0x6086, 0x608a, 0x608e, 0x6092, 0x6096,
+	0x609a, 0x609e, 0x60ae, 0x61a2, 0x00d6, 0x60a4, 0xa06d, 0x0110,
+	0x080c, 0x160f, 0x60a7, 0x0000, 0x60a8, 0xa06d, 0x0110, 0x080c,
+	0x160f, 0x60ab, 0x0000, 0x00de, 0xa006, 0x604a, 0x6810, 0x603a,
+	0x680c, 0x6046, 0x6814, 0xa084, 0x00ff, 0x6042, 0x014e, 0x013e,
+	0x015e, 0x003e, 0x00de, 0x0005, 0x0126, 0x2091, 0x8000, 0x6944,
+	0x6e48, 0xa684, 0x3fff, 0xa082, 0x4000, 0x1a04, 0x4d1a, 0xa18c,
+	0xff00, 0x810f, 0xa182, 0x00ff, 0x1a04, 0x4d1f, 0x2001, 0xb50c,
+	0x2004, 0xa084, 0x0003, 0x01c0, 0x2001, 0xb50c, 0x2004, 0xd084,
+	0x1904, 0x4d02, 0xa188, 0xb635, 0x2104, 0xa065, 0x0904, 0x4d02,
+	0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006, 0x1904, 0x4d02, 0x6000,
+	0xd0c4, 0x0904, 0x4d02, 0x0068, 0xa188, 0xb635, 0x2104, 0xa065,
+	0x0904, 0x4ce6, 0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006, 0x1904,
+	0x4ceb, 0x60a4, 0xa00d, 0x0118, 0x080c, 0x51d4, 0x05d0, 0x60a8,
+	0xa00d, 0x0188, 0x080c, 0x521f, 0x1170, 0x694c, 0xd1fc, 0x1118,
+	0x080c, 0x4ede, 0x0448, 0x080c, 0x4e8d, 0x694c, 0xd1ec, 0x1520,
+	0x080c, 0x50c6, 0x0408, 0x694c, 0xa184, 0xa000, 0x0178, 0xd1ec,
+	0x0140, 0xd1fc, 0x0118, 0x080c, 0x50d5, 0x0028, 0x080c, 0x50d5,
+	0x0028, 0xd1fc, 0x0118, 0x080c, 0x4e8d, 0x0070, 0x6050, 0xa00d,
+	0x0130, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052, 0x0028, 0x2d00,
+	0x6052, 0x604e, 0x6803, 0x0000, 0x080c, 0x6caa, 0xa006, 0x012e,
+	0x0005, 0x2001, 0x0005, 0x2009, 0x0000, 0x04e8, 0x2001, 0x0028,
+	0x2009, 0x0000, 0x04c0, 0xa082, 0x0006, 0x12a0, 0x2001, 0xb535,
+	0x2004, 0xd0ac, 0x1160, 0x60a0, 0xd0bc, 0x1148, 0x6100, 0xd1fc,
+	0x0904, 0x4ca1, 0x2001, 0x0029, 0x2009, 0x1000, 0x0420, 0x2001,
+	0x0028, 0x00a8, 0x2009, 0xb50c, 0x210c, 0xd18c, 0x0118, 0x2001,
+	0x0004, 0x0068, 0xd184, 0x0118, 0x2001, 0x0004, 0x0040, 0x2001,
+	0x0029, 0x6100, 0xd1fc, 0x0118, 0x2009, 0x1000, 0x0060, 0x2009,
+	0x0000, 0x0048, 0x2001, 0x0029, 0x2009, 0x0000, 0x0020, 0x2001,
+	0x0029, 0x2009, 0x0000, 0xa005, 0x012e, 0x0005, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0x6844, 0x8007, 0xa084, 0x00ff, 0x2008, 0xa182,
+	0x00ff, 0x1a04, 0x4d79, 0xa188, 0xb635, 0x2104, 0xa065, 0x01c0,
+	0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006, 0x11a8, 0x2c70, 0x080c,
+	0x85c7, 0x05e8, 0x2e00, 0x601a, 0x2d00, 0x6012, 0x600b, 0xffff,
+	0x601f, 0x000a, 0x2009, 0x0003, 0x080c, 0x864c, 0xa006, 0x0460,
+	0x2001, 0x0028, 0x0440, 0xa082, 0x0006, 0x1298, 0x2001, 0xb535,
+	0x2004, 0xd0ac, 0x1158, 0x60a0, 0xd0bc, 0x1140, 0x6100, 0xd1fc,
+	0x09e8, 0x2001, 0x0029, 0x2009, 0x1000, 0x00a8, 0x2001, 0x0028,
+	0x0090, 0x2009, 0xb50c, 0x210c, 0xd18c, 0x0118, 0x2001, 0x0004,
+	0x0050, 0xd184, 0x0118, 0x2001, 0x0004, 0x0028, 0x2001, 0x0029,
+	0x0010, 0x2001, 0x0029, 0xa005, 0x012e, 0x00ee, 0x0005, 0x2001,
+	0x002c, 0x0cc8, 0x00f6, 0x00e6, 0x0126, 0x2091, 0x8000, 0x2011,
+	0x0000, 0x2079, 0xb500, 0x6944, 0xa18c, 0xff00, 0x810f, 0xa182,
+	0x00ff, 0x1a04, 0x4e44, 0x080c, 0x4fa9, 0x11a0, 0x6004, 0xa084,
+	0x00ff, 0xa082, 0x0006, 0x1270, 0x6864, 0xa0c6, 0x006f, 0x0150,
+	0x2001, 0xb535, 0x2004, 0xd0ac, 0x1904, 0x4e2d, 0x60a0, 0xd0bc,
+	0x1904, 0x4e2d, 0x6864, 0xa0c6, 0x006f, 0x0118, 0x2008, 0x0804,
+	0x4df6, 0x6968, 0x2140, 0xa18c, 0xff00, 0x810f, 0x78d4, 0xd0ac,
+	0x1118, 0xa182, 0x0080, 0x06d0, 0xa182, 0x00ff, 0x16b8, 0x6a70,
+	0x6b6c, 0x7870, 0xa306, 0x1160, 0x7874, 0xa24e, 0x1118, 0x2208,
+	0x2310, 0x0460, 0xa9cc, 0xff00, 0x1118, 0x2208, 0x2310, 0x0430,
+	0x080c, 0x3dc5, 0x2c70, 0x0550, 0x2009, 0x0000, 0x2011, 0x0000,
+	0xa0c6, 0x4000, 0x1160, 0x0006, 0x2e60, 0x080c, 0x524a, 0x1108,
+	0xc185, 0x7000, 0xd0bc, 0x0108, 0xc18d, 0x000e, 0x0088, 0xa0c6,
+	0x4007, 0x1110, 0x2408, 0x0060, 0xa0c6, 0x4008, 0x1118, 0x2708,
+	0x2610, 0x0030, 0xa0c6, 0x4009, 0x1108, 0x0010, 0x2001, 0x4006,
+	0x6866, 0x696a, 0x6a6e, 0x2001, 0x0030, 0x0450, 0x080c, 0x85c7,
+	0x1138, 0x2001, 0x4005, 0x2009, 0x0003, 0x2011, 0x0000, 0x0c80,
+	0x2e00, 0x601a, 0x080c, 0xa027, 0x2d00, 0x6012, 0x601f, 0x0001,
+	0x6838, 0xd88c, 0x0108, 0xc0f5, 0x683a, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x2c9c, 0x012e, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001,
+	0x0002, 0x080c, 0x4efd, 0x2009, 0x0002, 0x080c, 0x864c, 0xa006,
+	0xa005, 0x012e, 0x00ee, 0x00fe, 0x0005, 0x2001, 0x0028, 0x2009,
+	0x0000, 0x0cb0, 0x2009, 0xb50c, 0x210c, 0xd18c, 0x0118, 0x2001,
+	0x0004, 0x0038, 0xd184, 0x0118, 0x2001, 0x0004, 0x0010, 0x2001,
+	0x0029, 0x2009, 0x0000, 0x0c20, 0x2001, 0x0029, 0x2009, 0x0000,
+	0x08f8, 0x6944, 0x6e48, 0xa684, 0x3fff, 0xa082, 0x4000, 0x16b8,
+	0xa18c, 0xff00, 0x810f, 0xa182, 0x00ff, 0x12e0, 0xa188, 0xb635,
+	0x2104, 0xa065, 0x01b8, 0x6004, 0xa084, 0x00ff, 0xa08e, 0x0006,
+	0x11b0, 0x684c, 0xd0ec, 0x0120, 0x080c, 0x50d5, 0x0431, 0x0030,
+	0x0421, 0x684c, 0xd0fc, 0x0110, 0x080c, 0x50c6, 0x080c, 0x5113,
+	0xa006, 0x00c8, 0x2001, 0x0028, 0x2009, 0x0000, 0x00a0, 0xa082,
+	0x0006, 0x1240, 0x6100, 0xd1fc, 0x0d20, 0x2001, 0x0029, 0x2009,
+	0x1000, 0x0048, 0x2001, 0x0029, 0x2009, 0x0000, 0x0020, 0x2001,
+	0x0029, 0x2009, 0x0000, 0xa005, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x6050, 0xa00d, 0x0138, 0x2d00, 0x200a, 0x6803, 0x0000, 0x6052,
+	0x012e, 0x0005, 0x2d00, 0x6052, 0x604e, 0x6803, 0x0000, 0x0cc0,
+	0x0126, 0x2091, 0x8000, 0x604c, 0xa005, 0x0170, 0x00e6, 0x2071,
+	0xb7e0, 0x7004, 0xa086, 0x0002, 0x0168, 0x00ee, 0x604c, 0x6802,
+	0x2d00, 0x604e, 0x012e, 0x0005, 0x2d00, 0x6052, 0x604e, 0x6803,
+	0x0000, 0x0cc0, 0x701c, 0xac06, 0x1d80, 0x604c, 0x2070, 0x7000,
+	0x6802, 0x2d00, 0x7002, 0x00ee, 0x012e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x604c, 0xa06d, 0x0130, 0x6800, 0xa005, 0x1108, 0x6052,
+	0x604e, 0xad05, 0x012e, 0x0005, 0x604c, 0xa06d, 0x0130, 0x6800,
+	0xa005, 0x1108, 0x6052, 0x604e, 0xad05, 0x0005, 0x6803, 0x0000,
+	0x6084, 0xa00d, 0x0120, 0x2d00, 0x200a, 0x6086, 0x0005, 0x2d00,
+	0x6086, 0x6082, 0x0cd8, 0x0126, 0x00c6, 0x0026, 0x2091, 0x8000,
+	0x6218, 0x2260, 0x6200, 0xa005, 0x0110, 0xc285, 0x0008, 0xc284,
+	0x6202, 0x002e, 0x00ce, 0x012e, 0x0005, 0x0126, 0x00c6, 0x2091,
+	0x8000, 0x6218, 0x2260, 0x6204, 0x0006, 0xa086, 0x0006, 0x1180,
+	0x609c, 0xd0ac, 0x0168, 0x2001, 0xb553, 0x2004, 0xd0a4, 0x0140,
+	0xa284, 0xff00, 0x8007, 0xa086, 0x0007, 0x1110, 0x2011, 0x0600,
+	0x000e, 0xa294, 0xff00, 0xa215, 0x6206, 0x0006, 0xa086, 0x0006,
+	0x1128, 0x6290, 0x82ff, 0x1110, 0x080c, 0x1515, 0x000e, 0x00ce,
+	0x012e, 0x0005, 0x0126, 0x00c6, 0x2091, 0x8000, 0x6218, 0x2260,
+	0x6204, 0x0006, 0xa086, 0x0006, 0x1178, 0x609c, 0xd0a4, 0x0160,
+	0x2001, 0xb553, 0x2004, 0xd0ac, 0x1138, 0xa284, 0x00ff, 0xa086,
+	0x0007, 0x1110, 0x2011, 0x0006, 0x000e, 0xa294, 0x00ff, 0x8007,
+	0xa215, 0x6206, 0x00ce, 0x012e, 0x0005, 0x0026, 0xa182, 0x00ff,
+	0x0218, 0xa085, 0x0001, 0x00b0, 0xa190, 0xb635, 0x2204, 0xa065,
+	0x1180, 0x0016, 0x00d6, 0x080c, 0x15df, 0x2d60, 0x00de, 0x001e,
+	0x0d80, 0x2c00, 0x2012, 0x60a7, 0x0000, 0x60ab, 0x0000, 0x080c,
+	0x4c0b, 0xa006, 0x002e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0026,
+	0xa182, 0x00ff, 0x0218, 0xa085, 0x0001, 0x0480, 0x00d6, 0xa190,
+	0xb635, 0x2204, 0xa06d, 0x0540, 0x2013, 0x0000, 0x00d6, 0x00c6,
+	0x2d60, 0x60a4, 0xa06d, 0x0110, 0x080c, 0x160f, 0x60a8, 0xa06d,
+	0x0110, 0x080c, 0x160f, 0x00ce, 0x00de, 0x00d6, 0x00c6, 0x68ac,
+	0x2060, 0x8cff, 0x0168, 0x600c, 0x0006, 0x6010, 0x2068, 0x080c,
+	0x9c5a, 0x0110, 0x080c, 0x161f, 0x080c, 0x861d, 0x00ce, 0x0c88,
+	0x00ce, 0x00de, 0x080c, 0x160f, 0x00de, 0xa006, 0x002e, 0x012e,
+	0x0005, 0x0016, 0xa182, 0x00ff, 0x0218, 0xa085, 0x0001, 0x0030,
+	0xa188, 0xb635, 0x2104, 0xa065, 0x0dc0, 0xa006, 0x001e, 0x0005,
+	0x00d6, 0x0156, 0x0136, 0x0146, 0x600b, 0x0000, 0x600f, 0x0000,
+	0x6000, 0xc08c, 0x6002, 0x080c, 0x5acf, 0x1558, 0x60a0, 0xa086,
+	0x007e, 0x2069, 0xbb90, 0x0130, 0x2001, 0xb535, 0x2004, 0xd0ac,
+	0x1500, 0x0098, 0x2d04, 0xd0e4, 0x01e0, 0x00d6, 0x2069, 0xbb8e,
+	0x00c6, 0x2061, 0xb7b2, 0x6810, 0x2062, 0x6814, 0x6006, 0x6818,
+	0x600a, 0x681c, 0x600e, 0x00ce, 0x00de, 0x8d69, 0x2d04, 0x2069,
+	0x0140, 0xa005, 0x1110, 0x2001, 0x0001, 0x6886, 0x2069, 0xb500,
+	0x68a6, 0x2069, 0xbb8e, 0x6808, 0x605e, 0x6810, 0x6062, 0x6138,
+	0xa10a, 0x0208, 0x603a, 0x6814, 0x6066, 0x2099, 0xbb96, 0xac88,
+	0x000a, 0x21a0, 0x20a9, 0x0004, 0x53a3, 0x2099, 0xbb9a, 0xac88,
+	0x0006, 0x21a0, 0x20a9, 0x0004, 0x53a3, 0x2069, 0xbbae, 0x6808,
+	0x606a, 0x690c, 0x616e, 0x6810, 0x6072, 0x6818, 0x6076, 0x60a0,
+	0xa086, 0x007e, 0x1120, 0x2069, 0xbb8e, 0x690c, 0x616e, 0xa182,
+	0x0211, 0x1218, 0x2009, 0x0008, 0x0400, 0xa182, 0x0259, 0x1218,
+	0x2009, 0x0007, 0x00d0, 0xa182, 0x02c1, 0x1218, 0x2009, 0x0006,
+	0x00a0, 0xa182, 0x0349, 0x1218, 0x2009, 0x0005, 0x0070, 0xa182,
+	0x0421, 0x1218, 0x2009, 0x0004, 0x0040, 0xa182, 0x0581, 0x1218,
+	0x2009, 0x0003, 0x0010, 0x2009, 0x0002, 0x6192, 0x014e, 0x013e,
+	0x015e, 0x00de, 0x0005, 0x0016, 0x0026, 0x00e6, 0x2071, 0xbb8d,
+	0x2e04, 0x6896, 0x2071, 0xbb8e, 0x7004, 0x689a, 0x701c, 0x689e,
+	0x6a00, 0x2009, 0xb572, 0x210c, 0xd0bc, 0x0120, 0xd1ec, 0x0110,
+	0xc2ad, 0x0008, 0xc2ac, 0xd0c4, 0x0120, 0xd1e4, 0x0110, 0xc2bd,
+	0x0008, 0xc2bc, 0x6a02, 0x00ee, 0x002e, 0x001e, 0x0005, 0x00d6,
+	0x0126, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x01c0, 0x6900, 0x81ff,
+	0x1540, 0x6a04, 0xa282, 0x0010, 0x1648, 0xad88, 0x0004, 0x20a9,
+	0x0010, 0x2104, 0xa086, 0xffff, 0x0128, 0x8108, 0x1f04, 0x5081,
+	0x080c, 0x1515, 0x260a, 0x8210, 0x6a06, 0x0098, 0x080c, 0x15f8,
+	0x01a8, 0x2d00, 0x60a6, 0x6803, 0x0000, 0xad88, 0x0004, 0x20a9,
+	0x0010, 0x200b, 0xffff, 0x8108, 0x1f04, 0x5099, 0x6807, 0x0001,
+	0x6e12, 0xa085, 0x0001, 0x012e, 0x00de, 0x0005, 0xa006, 0x0cd8,
+	0x0126, 0x2091, 0x8000, 0x00d6, 0x60a4, 0xa00d, 0x01a0, 0x2168,
+	0x6800, 0xa005, 0x1160, 0x080c, 0x51d4, 0x1168, 0x200b, 0xffff,
+	0x6804, 0xa08a, 0x0002, 0x0218, 0x8001, 0x6806, 0x0020, 0x080c,
+	0x160f, 0x60a7, 0x0000, 0x00de, 0x012e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x5232, 0x0010, 0x080c, 0x4e8d, 0x080c, 0x514c,
+	0x1dd8, 0x080c, 0x5113, 0x012e, 0x0005, 0x00d6, 0x0126, 0x2091,
+	0x8000, 0x60a8, 0xa06d, 0x01c0, 0x6950, 0x81ff, 0x1540, 0x6a54,
+	0xa282, 0x0010, 0x1670, 0xad88, 0x0018, 0x20a9, 0x0010, 0x2104,
+	0xa086, 0xffff, 0x0128, 0x8108, 0x1f04, 0x50e7, 0x080c, 0x1515,
+	0x260a, 0x8210, 0x6a56, 0x0098, 0x080c, 0x15f8, 0x01d0, 0x2d00,
+	0x60aa, 0x6853, 0x0000, 0xad88, 0x0018, 0x20a9, 0x0010, 0x200b,
+	0xffff, 0x8108, 0x1f04, 0x50ff, 0x6857, 0x0001, 0x6e62, 0x0010,
+	0x080c, 0x4ede, 0x0089, 0x1de0, 0xa085, 0x0001, 0x012e, 0x00de,
+	0x0005, 0xa006, 0x0cd8, 0x0126, 0x2091, 0x8000, 0x080c, 0x6caa,
+	0x012e, 0x0005, 0xa01e, 0x0010, 0x2019, 0x0001, 0xa00e, 0x0126,
+	0x2091, 0x8000, 0x604c, 0x2068, 0x6000, 0xd0dc, 0x1170, 0x8dff,
+	0x01f8, 0x83ff, 0x0120, 0x6848, 0xa606, 0x0158, 0x0030, 0x683c,
+	0xa406, 0x1118, 0x6840, 0xa506, 0x0120, 0x2d08, 0x6800, 0x2068,
+	0x0c70, 0x080c, 0x811e, 0x6a00, 0x604c, 0xad06, 0x1110, 0x624e,
+	0x0018, 0xa180, 0x0000, 0x2202, 0x82ff, 0x1110, 0x6152, 0x8dff,
+	0x012e, 0x0005, 0xa01e, 0x0010, 0x2019, 0x0001, 0xa00e, 0x6080,
+	0x2068, 0x8dff, 0x01e8, 0x83ff, 0x0120, 0x6848, 0xa606, 0x0158,
+	0x0030, 0x683c, 0xa406, 0x1118, 0x6840, 0xa506, 0x0120, 0x2d08,
+	0x6800, 0x2068, 0x0c70, 0x6a00, 0x6080, 0xad06, 0x1110, 0x6282,
+	0x0018, 0xa180, 0x0000, 0x2202, 0x82ff, 0x1110, 0x6186, 0x8dff,
+	0x0005, 0xa016, 0x080c, 0x51ce, 0x1110, 0x2011, 0x0001, 0x080c,
+	0x5219, 0x1110, 0xa295, 0x0002, 0x0005, 0x080c, 0x524a, 0x0118,
+	0x080c, 0x9d0f, 0x0010, 0xa085, 0x0001, 0x0005, 0x080c, 0x524a,
+	0x0118, 0x080c, 0x9c9f, 0x0010, 0xa085, 0x0001, 0x0005, 0x080c,
+	0x524a, 0x0118, 0x080c, 0x9cf2, 0x0010, 0xa085, 0x0001, 0x0005,
+	0x080c, 0x524a, 0x0118, 0x080c, 0x9cbb, 0x0010, 0xa085, 0x0001,
+	0x0005, 0x080c, 0x524a, 0x0118, 0x080c, 0x9d2b, 0x0010, 0xa085,
+	0x0001, 0x0005, 0x0126, 0x0006, 0x00d6, 0x2091, 0x8000, 0x6080,
+	0xa06d, 0x01a0, 0x6800, 0x0006, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x080c, 0x9ecc, 0x0006, 0x6000, 0xd0fc, 0x0110, 0x080c,
+	0xb389, 0x000e, 0x080c, 0x5408, 0x000e, 0x0c50, 0x6083, 0x0000,
+	0x6087, 0x0000, 0x00de, 0x000e, 0x012e, 0x0005, 0x60a4, 0xa00d,
+	0x1118, 0xa085, 0x0001, 0x0005, 0x00e6, 0x2170, 0x7000, 0xa005,
+	0x1168, 0x20a9, 0x0010, 0xae88, 0x0004, 0x2104, 0xa606, 0x0130,
+	0x8108, 0x1f04, 0x51dd, 0xa085, 0x0001, 0x0008, 0xa006, 0x00ee,
+	0x0005, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x1128,
+	0x080c, 0x15f8, 0x01a0, 0x2d00, 0x60a6, 0x6803, 0x0001, 0x6807,
+	0x0000, 0xad88, 0x0004, 0x20a9, 0x0010, 0x200b, 0xffff, 0x8108,
+	0x1f04, 0x51fd, 0xa085, 0x0001, 0x012e, 0x00de, 0x0005, 0xa006,
+	0x0cd8, 0x00d6, 0x0126, 0x2091, 0x8000, 0x60a4, 0xa06d, 0x0130,
+	0x60a7, 0x0000, 0x080c, 0x160f, 0xa085, 0x0001, 0x012e, 0x00de,
+	0x0005, 0x60a8, 0xa00d, 0x1118, 0xa085, 0x0001, 0x0005, 0x00e6,
+	0x2170, 0x7050, 0xa005, 0x1160, 0x20a9, 0x0010, 0xae88, 0x0018,
+	0x2104, 0xa606, 0x0128, 0x8108, 0x1f04, 0x5228, 0xa085, 0x0001,
+	0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x0c19, 0x1188, 0x200b,
+	0xffff, 0x00d6, 0x60a8, 0x2068, 0x6854, 0xa08a, 0x0002, 0x0218,
+	0x8001, 0x6856, 0x0020, 0x080c, 0x160f, 0x60ab, 0x0000, 0x00de,
+	0x012e, 0x0005, 0x609c, 0xd0a4, 0x0005, 0x00f6, 0x080c, 0x5acf,
+	0x01b0, 0x71b8, 0x81ff, 0x1198, 0x71d4, 0xd19c, 0x0180, 0x2001,
+	0x007e, 0xa080, 0xb635, 0x2004, 0xa07d, 0x0148, 0x7804, 0xa084,
+	0x00ff, 0xa086, 0x0006, 0x1118, 0x7800, 0xc0ed, 0x7802, 0x2079,
+	0xb552, 0x7804, 0xd0a4, 0x01e8, 0x0156, 0x00c6, 0x20a9, 0x007f,
+	0x2009, 0x0000, 0x0016, 0x080c, 0x4fa9, 0x1168, 0x6004, 0xa084,
+	0xff00, 0x8007, 0xa096, 0x0004, 0x0118, 0xa086, 0x0006, 0x1118,
+	0x6000, 0xc0ed, 0x6002, 0x001e, 0x8108, 0x1f04, 0x5272, 0x00ce,
+	0x015e, 0x080c, 0x5309, 0x0120, 0x2001, 0xb7b5, 0x200c, 0x0038,
+	0x2079, 0xb552, 0x7804, 0xd0a4, 0x0130, 0x2009, 0x07d0, 0x2011,
+	0x529d, 0x080c, 0x6a22, 0x00fe, 0x0005, 0x2011, 0x529d, 0x080c,
+	0x699c, 0x080c, 0x5309, 0x01f0, 0x2001, 0xb6b3, 0x2004, 0xa080,
+	0x0000, 0x200c, 0xc1ec, 0x2102, 0x2001, 0xb553, 0x2004, 0xd0a4,
+	0x0130, 0x2009, 0x07d0, 0x2011, 0x529d, 0x080c, 0x6a22, 0x00e6,
+	0x2071, 0xb500, 0x7073, 0x0000, 0x7077, 0x0000, 0x080c, 0x2ab8,
+	0x00ee, 0x04b0, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x0016, 0x080c, 0x4fa9, 0x1530, 0x6000, 0xd0ec, 0x0518, 0x0046,
+	0x62a0, 0xa294, 0x00ff, 0x8227, 0xa006, 0x2009, 0x0029, 0x080c,
+	0xb0e8, 0x6000, 0xc0e5, 0xc0ec, 0x6002, 0x6004, 0xa084, 0x00ff,
+	0xa085, 0x0700, 0x6006, 0x2019, 0x0029, 0x080c, 0x6df5, 0x0076,
+	0x2039, 0x0000, 0x080c, 0x6d02, 0x2009, 0x0000, 0x080c, 0xae82,
+	0x007e, 0x004e, 0x001e, 0x8108, 0x1f04, 0x52c8, 0x00ce, 0x015e,
+	0x0005, 0x00c6, 0x6018, 0x2060, 0x6000, 0xc0ec, 0x6002, 0x00ce,
+	0x0005, 0x7818, 0x2004, 0xd0ac, 0x0005, 0x7818, 0x2004, 0xd0bc,
+	0x0005, 0x00f6, 0x2001, 0xb6b3, 0x2004, 0xa07d, 0x0110, 0x7800,
+	0xd0ec, 0x00fe, 0x0005, 0x0126, 0x0026, 0x2091, 0x8000, 0x0006,
+	0x62a0, 0xa290, 0xb635, 0x2204, 0xac06, 0x190c, 0x1515, 0x000e,
+	0x6200, 0xa005, 0x0110, 0xc2fd, 0x0008, 0xc2fc, 0x6202, 0x002e,
+	0x012e, 0x0005, 0x2011, 0xb535, 0x2204, 0xd0cc, 0x0138, 0x2001,
+	0xb7b3, 0x200c, 0x2011, 0x5337, 0x080c, 0x6a22, 0x0005, 0x2011,
+	0x5337, 0x080c, 0x699c, 0x2011, 0xb535, 0x2204, 0xc0cc, 0x2012,
+	0x0005, 0x2071, 0xb614, 0x7003, 0x0001, 0x7007, 0x0000, 0x7013,
+	0x0000, 0x7017, 0x0000, 0x701b, 0x0000, 0x701f, 0x0000, 0x700b,
+	0x0000, 0x704b, 0x0001, 0x704f, 0x0000, 0x705b, 0x0020, 0x705f,
+	0x0040, 0x707f, 0x0000, 0x2071, 0xb77d, 0x7003, 0xb614, 0x7007,
+	0x0000, 0x700b, 0x0000, 0x700f, 0xb75d, 0x7013, 0x0020, 0x7017,
+	0x0040, 0x7037, 0x0000, 0x0005, 0x0016, 0x00e6, 0x2071, 0xb735,
+	0xa00e, 0x7186, 0x718a, 0x7097, 0x0001, 0x2001, 0xb553, 0x2004,
+	0xd0fc, 0x1150, 0x2001, 0xb553, 0x2004, 0xa00e, 0xd09c, 0x0108,
+	0x8108, 0x7102, 0x0804, 0x53d2, 0x2001, 0xb572, 0x200c, 0xa184,
+	0x000f, 0x2009, 0xb573, 0x210c, 0x0002, 0x537a, 0x53ad, 0x53b4,
+	0x53be, 0x53c3, 0x537a, 0x537a, 0x537a, 0x539d, 0x537a, 0x537a,
+	0x537a, 0x537a, 0x537a, 0x537a, 0x537a, 0x7003, 0x0004, 0x0136,
+	0x0146, 0x0156, 0x2099, 0xb576, 0x20a1, 0xb786, 0x20a9, 0x0004,
+	0x53a3, 0x015e, 0x014e, 0x013e, 0x0428, 0x708f, 0x0005, 0x7007,
+	0x0122, 0x2001, 0x0002, 0x0030, 0x708f, 0x0002, 0x7007, 0x0121,
+	0x2001, 0x0003, 0x7002, 0x7097, 0x0001, 0x0088, 0x7007, 0x0122,
+	0x2001, 0x0002, 0x0020, 0x7007, 0x0121, 0x2001, 0x0003, 0x7002,
+	0xa006, 0x7096, 0x708e, 0xa184, 0xff00, 0x8007, 0x709a, 0xa184,
+	0x00ff, 0x7092, 0x00ee, 0x001e, 0x0005, 0x00e6, 0x2071, 0xb614,
+	0x684c, 0xa005, 0x1130, 0x7028, 0xc085, 0x702a, 0xa085, 0x0001,
+	0x0428, 0x6a60, 0x7236, 0x6b64, 0x733a, 0x6868, 0x703e, 0x7076,
+	0x686c, 0x7042, 0x707a, 0x684c, 0x702e, 0x6844, 0x7032, 0x2009,
+	0x000d, 0x200a, 0x700b, 0x0000, 0x8007, 0x8006, 0x8006, 0xa08c,
+	0x003f, 0xa084, 0xffc0, 0xa210, 0x2100, 0xa319, 0x726e, 0x7372,
+	0x7028, 0xc084, 0x702a, 0x7007, 0x0001, 0xa006, 0x00ee, 0x0005,
+	0x0156, 0x00e6, 0x0026, 0x6838, 0xd0fc, 0x1904, 0x5461, 0x6804,
+	0xa00d, 0x0188, 0x00d6, 0x2071, 0xb500, 0xa016, 0x702c, 0x2168,
+	0x6904, 0x206a, 0x8210, 0x2d00, 0x81ff, 0x1dc8, 0x702e, 0x70b4,
+	0xa200, 0x70b6, 0x00de, 0x2071, 0xb614, 0x701c, 0xa005, 0x1904,
+	0x5471, 0x20a9, 0x0032, 0x0f04, 0x546f, 0x0e04, 0x542b, 0x2071,
+	0xb735, 0x7200, 0x82ff, 0x05d8, 0x6934, 0xa186, 0x0103, 0x1904,
+	0x547f, 0x6948, 0x6844, 0xa105, 0x1540, 0x2009, 0x8020, 0x2200,
+	0x0002, 0x546f, 0x5446, 0x5497, 0x54a3, 0x546f, 0x2071, 0x0000,
+	0x20a9, 0x0032, 0x0f04, 0x546f, 0x7018, 0xd084, 0x1dd8, 0x7122,
+	0x683c, 0x7026, 0x6840, 0x702a, 0x701b, 0x0001, 0x2091, 0x4080,
+	0x2071, 0xb500, 0x702c, 0x206a, 0x2d00, 0x702e, 0x70b4, 0x8000,
+	0x70b6, 0x002e, 0x00ee, 0x015e, 0x0005, 0x6844, 0xa086, 0x0100,
+	0x1130, 0x6868, 0xa005, 0x1118, 0x2009, 0x8020, 0x0880, 0x2071,
+	0xb614, 0x2d08, 0x206b, 0x0000, 0x7010, 0x8000, 0x7012, 0x7018,
+	0xa06d, 0x711a, 0x0110, 0x6902, 0x0008, 0x711e, 0x0c10, 0xa18c,
+	0x00ff, 0xa186, 0x0017, 0x0130, 0xa186, 0x001e, 0x0118, 0xa18e,
+	0x001f, 0x1d28, 0x684c, 0xd0cc, 0x0d10, 0x6850, 0xa084, 0x00ff,
+	0xa086, 0x0001, 0x19e0, 0x2009, 0x8021, 0x0804, 0x543f, 0x7084,
+	0x8008, 0xa092, 0x001e, 0x1a98, 0x7186, 0xae90, 0x0003, 0xa210,
+	0x683c, 0x2012, 0x0078, 0x7084, 0x8008, 0xa092, 0x000f, 0x1a38,
+	0x7186, 0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012, 0x8210,
+	0x6840, 0x2012, 0x7088, 0xa10a, 0x0a04, 0x5458, 0x718c, 0x7084,
+	0xa10a, 0x0a04, 0x5458, 0x2071, 0x0000, 0x7018, 0xd084, 0x1904,
+	0x5458, 0x2071, 0xb735, 0x7000, 0xa086, 0x0002, 0x1150, 0x080c,
+	0x5722, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0804,
+	0x5458, 0x080c, 0x574c, 0x2071, 0x0000, 0x701b, 0x0001, 0x2091,
+	0x4080, 0x0804, 0x5458, 0x0006, 0x684c, 0x0006, 0x6837, 0x0103,
+	0x20a9, 0x001c, 0xad80, 0x0011, 0x20a0, 0x2001, 0x0000, 0x40a4,
+	0x000e, 0xa084, 0x00ff, 0x684e, 0x000e, 0x684a, 0x6952, 0x0005,
+	0x2071, 0xb614, 0x7004, 0x0002, 0x54fe, 0x550f, 0x570d, 0x570e,
+	0x571b, 0x5721, 0x54ff, 0x56fe, 0x5694, 0x56ea, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x0e04, 0x550e, 0x2009, 0x000d, 0x7030, 0x200a,
+	0x2091, 0x4080, 0x7007, 0x0001, 0x700b, 0x0000, 0x012e, 0x2069,
+	0xb7f3, 0x683c, 0xa005, 0x03f8, 0x11f0, 0x0126, 0x2091, 0x8000,
+	0x2069, 0x0000, 0x6934, 0x2001, 0xb620, 0x2004, 0xa10a, 0x0170,
+	0x0e04, 0x5532, 0x2069, 0x0000, 0x6818, 0xd084, 0x1158, 0x2009,
+	0x8040, 0x6922, 0x681b, 0x0001, 0x2091, 0x4080, 0x2069, 0xb7f3,
+	0x683f, 0xffff, 0x012e, 0x2069, 0xb500, 0x6848, 0x6968, 0xa102,
+	0x2069, 0xb735, 0x688a, 0x6984, 0x701c, 0xa06d, 0x0120, 0x81ff,
+	0x0904, 0x5588, 0x00a0, 0x81ff, 0x0904, 0x564e, 0x2071, 0xb735,
+	0x7184, 0x7088, 0xa10a, 0x1258, 0x7190, 0x2071, 0xb7f3, 0x7038,
+	0xa005, 0x0128, 0x1b04, 0x564e, 0x713a, 0x0804, 0x564e, 0x2071,
+	0xb735, 0x718c, 0x0126, 0x2091, 0x8000, 0x7084, 0xa10a, 0x0a04,
+	0x5669, 0x0e04, 0x560a, 0x2071, 0x0000, 0x7018, 0xd084, 0x1904,
+	0x560a, 0x2001, 0xffff, 0x2071, 0xb7f3, 0x703a, 0x2071, 0xb735,
+	0x7000, 0xa086, 0x0002, 0x1150, 0x080c, 0x5722, 0x2071, 0x0000,
+	0x701b, 0x0001, 0x2091, 0x4080, 0x0804, 0x560a, 0x080c, 0x574c,
+	0x2071, 0x0000, 0x701b, 0x0001, 0x2091, 0x4080, 0x0804, 0x560a,
+	0x2071, 0xb735, 0x7000, 0xa005, 0x0904, 0x5630, 0x6934, 0xa186,
+	0x0103, 0x1904, 0x560d, 0x684c, 0xd0bc, 0x1904, 0x5630, 0x6948,
+	0x6844, 0xa105, 0x1904, 0x5625, 0x2009, 0x8020, 0x2071, 0xb735,
+	0x7000, 0x0002, 0x5630, 0x55f0, 0x55c8, 0x55da, 0x55a7, 0x0136,
+	0x0146, 0x0156, 0x2099, 0xb576, 0x20a1, 0xb786, 0x20a9, 0x0004,
+	0x53a3, 0x015e, 0x014e, 0x013e, 0x2071, 0xb77d, 0xad80, 0x000f,
+	0x700e, 0x7013, 0x0002, 0x7007, 0x0002, 0x700b, 0x0000, 0x2e10,
+	0x080c, 0x1643, 0x2071, 0xb614, 0x7007, 0x0009, 0x0804, 0x564e,
+	0x7084, 0x8008, 0xa092, 0x001e, 0x1a04, 0x564e, 0xae90, 0x0003,
+	0xa210, 0x683c, 0x2012, 0x7186, 0x2071, 0xb614, 0x080c, 0x57a3,
+	0x0804, 0x564e, 0x7084, 0x8008, 0xa092, 0x000f, 0x1a04, 0x564e,
+	0xae90, 0x0003, 0x8003, 0xa210, 0x683c, 0x2012, 0x8210, 0x6840,
+	0x2012, 0x7186, 0x2071, 0xb614, 0x080c, 0x57a3, 0x0804, 0x564e,
+	0x0126, 0x2091, 0x8000, 0x0e04, 0x560a, 0x2071, 0x0000, 0x7018,
+	0xd084, 0x1180, 0x7122, 0x683c, 0x7026, 0x6840, 0x702a, 0x701b,
+	0x0001, 0x2091, 0x4080, 0x012e, 0x2071, 0xb614, 0x080c, 0x57a3,
+	0x0804, 0x564e, 0x012e, 0x0804, 0x564e, 0xa18c, 0x00ff, 0xa186,
+	0x0017, 0x0130, 0xa186, 0x001e, 0x0118, 0xa18e, 0x001f, 0x11c0,
+	0x684c, 0xd0cc, 0x01a8, 0x6850, 0xa084, 0x00ff, 0xa086, 0x0001,
+	0x1178, 0x2009, 0x8021, 0x0804, 0x559e, 0x6844, 0xa086, 0x0100,
+	0x1138, 0x6868, 0xa005, 0x1120, 0x2009, 0x8020, 0x0804, 0x559e,
+	0x2071, 0xb614, 0x080c, 0x57b5, 0x01c8, 0x2071, 0xb614, 0x700f,
+	0x0001, 0x6934, 0xa184, 0x00ff, 0xa086, 0x0003, 0x1130, 0x810f,
+	0xa18c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x7007, 0x0003, 0x080c,
+	0x57ce, 0x7050, 0xa086, 0x0100, 0x0904, 0x570e, 0x0126, 0x2091,
+	0x8000, 0x2071, 0xb614, 0x7008, 0xa086, 0x0001, 0x1180, 0x0e04,
+	0x5667, 0x2009, 0x000d, 0x7030, 0x200a, 0x2091, 0x4080, 0x700b,
+	0x0000, 0x7004, 0xa086, 0x0006, 0x1110, 0x7007, 0x0001, 0x012e,
+	0x0005, 0x2071, 0xb614, 0x080c, 0x57b5, 0x0518, 0x2071, 0xb735,
+	0x7084, 0x700a, 0x20a9, 0x0020, 0x2099, 0xb736, 0x20a1, 0xb75d,
+	0x53a3, 0x7087, 0x0000, 0x2071, 0xb614, 0x2069, 0xb77d, 0x706c,
+	0x6826, 0x7070, 0x682a, 0x7074, 0x682e, 0x7078, 0x6832, 0x2d10,
+	0x080c, 0x1643, 0x7007, 0x0008, 0x2001, 0xffff, 0x2071, 0xb7f3,
+	0x703a, 0x012e, 0x0804, 0x564e, 0x2069, 0xb77d, 0x6808, 0xa08e,
+	0x0000, 0x0904, 0x56e9, 0xa08e, 0x0200, 0x0904, 0x56e7, 0xa08e,
+	0x0100, 0x1904, 0x56e9, 0x0126, 0x2091, 0x8000, 0x0e04, 0x56e5,
+	0x2069, 0x0000, 0x6818, 0xd084, 0x15c0, 0x702c, 0x7130, 0x8108,
+	0xa102, 0x0230, 0xa00e, 0x7034, 0x706e, 0x7038, 0x7072, 0x0048,
+	0x706c, 0xa080, 0x0040, 0x706e, 0x1220, 0x7070, 0xa081, 0x0000,
+	0x7072, 0x7132, 0x6936, 0x700b, 0x0000, 0x2001, 0xb75a, 0x2004,
+	0xa005, 0x1190, 0x6934, 0x2069, 0xb735, 0x689c, 0x699e, 0x2069,
+	0xb7f3, 0xa102, 0x1118, 0x683c, 0xa005, 0x1368, 0x2001, 0xb75b,
+	0x200c, 0x810d, 0x693e, 0x0038, 0x2009, 0x8040, 0x6922, 0x681b,
+	0x0001, 0x2091, 0x4080, 0x7007, 0x0001, 0x012e, 0x0010, 0x7007,
+	0x0005, 0x0005, 0x2001, 0xb77f, 0x2004, 0xa08e, 0x0100, 0x1128,
+	0x7007, 0x0001, 0x080c, 0x57a3, 0x0005, 0xa08e, 0x0000, 0x0de0,
+	0xa08e, 0x0200, 0x1dc8, 0x7007, 0x0005, 0x0005, 0x701c, 0xa06d,
+	0x0158, 0x080c, 0x57b5, 0x0140, 0x7007, 0x0003, 0x080c, 0x57ce,
+	0x7050, 0xa086, 0x0100, 0x0110, 0x0005, 0x0005, 0x7050, 0xa09e,
+	0x0100, 0x1118, 0x7007, 0x0004, 0x0030, 0xa086, 0x0200, 0x1110,
+	0x7007, 0x0005, 0x0005, 0x080c, 0x5771, 0x7006, 0x080c, 0x57a3,
+	0x0005, 0x0005, 0x00e6, 0x0156, 0x2071, 0xb735, 0x7184, 0x81ff,
+	0x0500, 0xa006, 0x7086, 0xae80, 0x0003, 0x2071, 0x0000, 0x21a8,
+	0x2014, 0x7226, 0x8000, 0x0f04, 0x5746, 0x2014, 0x722a, 0x8000,
+	0x0f04, 0x5746, 0x2014, 0x722e, 0x8000, 0x0f04, 0x5746, 0x2014,
+	0x723a, 0x8000, 0x0f04, 0x5746, 0x2014, 0x723e, 0xa180, 0x8030,
+	0x7022, 0x015e, 0x00ee, 0x0005, 0x00e6, 0x0156, 0x2071, 0xb735,
+	0x7184, 0x81ff, 0x01d8, 0xa006, 0x7086, 0xae80, 0x0003, 0x2071,
+	0x0000, 0x21a8, 0x2014, 0x7226, 0x8000, 0x2014, 0x722a, 0x8000,
+	0x0f04, 0x5768, 0x2014, 0x723a, 0x8000, 0x2014, 0x723e, 0x0018,
+	0x2001, 0x8020, 0x0010, 0x2001, 0x8042, 0x7022, 0x015e, 0x00ee,
+	0x0005, 0x702c, 0x7130, 0x8108, 0xa102, 0x0230, 0xa00e, 0x7034,
+	0x706e, 0x7038, 0x7072, 0x0048, 0x706c, 0xa080, 0x0040, 0x706e,
+	0x1220, 0x7070, 0xa081, 0x0000, 0x7072, 0x7132, 0x700c, 0x8001,
+	0x700e, 0x1180, 0x0126, 0x2091, 0x8000, 0x0e04, 0x579d, 0x2001,
+	0x000d, 0x2102, 0x2091, 0x4080, 0x2001, 0x0001, 0x700b, 0x0000,
+	0x012e, 0x0005, 0x2001, 0x0007, 0x0005, 0x2001, 0x0006, 0x700b,
+	0x0001, 0x012e, 0x0005, 0x701c, 0xa06d, 0x0170, 0x0126, 0x2091,
+	0x8000, 0x7010, 0x8001, 0x7012, 0x2d04, 0x701e, 0xa005, 0x1108,
+	0x701a, 0x012e, 0x080c, 0x160f, 0x0005, 0x2019, 0x000d, 0x2304,
+	0x230c, 0xa10e, 0x0130, 0x2304, 0x230c, 0xa10e, 0x0110, 0xa006,
+	0x0060, 0x732c, 0x8319, 0x7130, 0xa102, 0x1118, 0x2300, 0xa005,
+	0x0020, 0x0210, 0xa302, 0x0008, 0x8002, 0x0005, 0x2d00, 0x7026,
+	0xa080, 0x000d, 0x7056, 0x7053, 0x0000, 0x0126, 0x2091, 0x8000,
+	0x2009, 0xb812, 0x2104, 0xc08d, 0x200a, 0x012e, 0x080c, 0x165f,
+	0x0005, 0x708c, 0xa08a, 0x0029, 0x1220, 0xa082, 0x001d, 0x0033,
+	0x0010, 0x080c, 0x1515, 0x6027, 0x1e00, 0x0005, 0x58dc, 0x5857,
+	0x586f, 0x58ac, 0x58cd, 0x5907, 0x5919, 0x586f, 0x58f3, 0x57fb,
+	0x5829, 0x57fa, 0x0005, 0x00d6, 0x2069, 0x0200, 0x6804, 0xa005,
+	0x1180, 0x6808, 0xa005, 0x1518, 0x708f, 0x0028, 0x2069, 0xb7c5,
+	0x2d04, 0x7002, 0x080c, 0x5bd1, 0x6028, 0xa085, 0x0600, 0x602a,
+	0x00b0, 0x708f, 0x0028, 0x2069, 0xb7c5, 0x2d04, 0x7002, 0x6028,
+	0xa085, 0x0600, 0x602a, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071,
+	0xb823, 0x080c, 0x1dfe, 0x005e, 0x004e, 0x003e, 0x00ee, 0x00de,
+	0x0005, 0x00d6, 0x2069, 0x0200, 0x6804, 0xa005, 0x1180, 0x6808,
+	0xa005, 0x1518, 0x708f, 0x0028, 0x2069, 0xb7c5, 0x2d04, 0x7002,
+	0x080c, 0x5c5e, 0x6028, 0xa085, 0x0600, 0x602a, 0x00b0, 0x708f,
+	0x0028, 0x2069, 0xb7c5, 0x2d04, 0x7002, 0x6028, 0xa085, 0x0600,
+	0x602a, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0xb823, 0x080c,
+	0x1dfe, 0x005e, 0x004e, 0x003e, 0x00ee, 0x00de, 0x0005, 0x6803,
+	0x0090, 0x6124, 0xd1e4, 0x1190, 0x080c, 0x5984, 0xd1d4, 0x1160,
+	0xd1dc, 0x1138, 0xd1cc, 0x0150, 0x708f, 0x0020, 0x080c, 0x5984,
+	0x0028, 0x708f, 0x001d, 0x0010, 0x708f, 0x001f, 0x0005, 0x6803,
+	0x0088, 0x6124, 0xd1cc, 0x1590, 0xd1dc, 0x1568, 0xd1e4, 0x1540,
+	0xa184, 0x1e00, 0x1580, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e,
+	0x080c, 0x5aff, 0x080c, 0x24b0, 0x0156, 0x6803, 0x0100, 0x20a9,
+	0x0014, 0x6804, 0xd0dc, 0x1118, 0x1f04, 0x5889, 0x0048, 0x20a9,
+	0x0014, 0x6803, 0x0080, 0x6804, 0xd0d4, 0x1130, 0x1f04, 0x5893,
+	0x080c, 0x5b20, 0x015e, 0x0078, 0x015e, 0x708f, 0x0028, 0x0058,
+	0x708f, 0x001e, 0x0040, 0x708f, 0x001d, 0x0028, 0x708f, 0x0020,
+	0x0010, 0x708f, 0x001f, 0x0005, 0x60e3, 0x0001, 0x600c, 0xc0b4,
+	0x600e, 0x080c, 0x5aff, 0x080c, 0x24b0, 0x6803, 0x0080, 0x6124,
+	0xd1d4, 0x1180, 0xd1dc, 0x1158, 0xd1e4, 0x1130, 0xa184, 0x1e00,
+	0x1158, 0x708f, 0x0028, 0x0040, 0x708f, 0x001e, 0x0028, 0x708f,
+	0x001d, 0x0010, 0x708f, 0x001f, 0x0005, 0x6803, 0x00a0, 0x6124,
+	0xd1dc, 0x1138, 0xd1e4, 0x0138, 0x080c, 0x1e47, 0x708f, 0x001e,
+	0x0010, 0x708f, 0x001d, 0x0005, 0x080c, 0x59f6, 0x6124, 0xd1dc,
+	0x1188, 0x080c, 0x5984, 0x0016, 0x080c, 0x1e47, 0x001e, 0xd1d4,
+	0x1128, 0xd1e4, 0x0138, 0x708f, 0x001e, 0x0020, 0x708f, 0x001f,
+	0x080c, 0x5984, 0x0005, 0x6803, 0x00a0, 0x6124, 0xd1d4, 0x1160,
+	0xd1cc, 0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0140, 0x708f, 0x001e,
+	0x0028, 0x708f, 0x001d, 0x0010, 0x708f, 0x0021, 0x0005, 0x080c,
+	0x59f6, 0x6124, 0xd1d4, 0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0140,
+	0x708f, 0x001e, 0x0028, 0x708f, 0x001d, 0x0010, 0x708f, 0x001f,
+	0x0005, 0x6803, 0x0090, 0x6124, 0xd1d4, 0x1178, 0xd1cc, 0x1150,
+	0xd1dc, 0x1128, 0xd1e4, 0x0158, 0x708f, 0x001e, 0x0040, 0x708f,
+	0x001d, 0x0028, 0x708f, 0x0020, 0x0010, 0x708f, 0x001f, 0x0005,
+	0x0016, 0x00c6, 0x00d6, 0x00e6, 0x0126, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x2071, 0xb500, 0x2091, 0x8000, 0x080c, 0x5acf, 0x11e8,
+	0x2001, 0xb50c, 0x200c, 0xd1b4, 0x01c0, 0xc1b4, 0x2102, 0x6027,
+	0x0200, 0xe000, 0xe000, 0x6024, 0xd0cc, 0x0158, 0x6803, 0x00a0,
+	0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001,
+	0x0428, 0x6028, 0xc0cd, 0x602a, 0x0408, 0x080c, 0x5aeb, 0x0150,
+	0x080c, 0x5ae1, 0x1138, 0x2001, 0x0001, 0x080c, 0x27c3, 0x080c,
+	0x5aa6, 0x00a0, 0x080c, 0x59f3, 0x0178, 0x2001, 0x0001, 0x080c,
+	0x27c3, 0x708c, 0xa086, 0x001e, 0x0120, 0x708c, 0xa086, 0x0022,
+	0x1118, 0x708f, 0x0025, 0x0010, 0x708f, 0x0021, 0x012e, 0x00ee,
+	0x00de, 0x00ce, 0x001e, 0x0005, 0x0026, 0x2011, 0x5995, 0x080c,
+	0x6a5c, 0x002e, 0x0016, 0x0026, 0x2009, 0x0064, 0x2011, 0x5995,
+	0x080c, 0x6a53, 0x002e, 0x001e, 0x0005, 0x00e6, 0x00f6, 0x0016,
+	0x080c, 0x7d7a, 0x2071, 0xb500, 0x080c, 0x5930, 0x001e, 0x00fe,
+	0x00ee, 0x0005, 0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6,
+	0x00f6, 0x0126, 0x080c, 0x7d7a, 0x2061, 0x0100, 0x2069, 0x0140,
+	0x2071, 0xb500, 0x2091, 0x8000, 0x6028, 0xc09c, 0x602a, 0x2011,
+	0x0003, 0x080c, 0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c,
+	0x7f59, 0x080c, 0x6a10, 0x0036, 0x2019, 0x0000, 0x080c, 0x7fe4,
+	0x003e, 0x60e3, 0x0000, 0x080c, 0xb42f, 0x080c, 0xb44a, 0x2001,
+	0xb500, 0x2003, 0x0004, 0x6027, 0x0008, 0x080c, 0x12dd, 0x2001,
+	0x0001, 0x080c, 0x27c3, 0x012e, 0x00fe, 0x00ee, 0x00de, 0x00ce,
+	0x003e, 0x002e, 0x001e, 0x0005, 0x2001, 0xb500, 0x2004, 0xa086,
+	0x0004, 0x0140, 0x2001, 0xb79e, 0x2003, 0xaaaa, 0x2001, 0xb79f,
+	0x2003, 0x0000, 0x0005, 0x6020, 0xd09c, 0x0005, 0x6800, 0xa086,
+	0x00c0, 0x0160, 0x6803, 0x00c0, 0x0156, 0x20a9, 0x002d, 0x1d04,
+	0x59ff, 0x2091, 0x6000, 0x1f04, 0x59ff, 0x015e, 0x0005, 0x00c6,
+	0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0xb500,
+	0x2001, 0xb79f, 0x200c, 0xa186, 0x0000, 0x0158, 0xa186, 0x0001,
+	0x0158, 0xa186, 0x0002, 0x0158, 0xa186, 0x0003, 0x0158, 0x0804,
+	0x5a94, 0x708f, 0x0022, 0x0040, 0x708f, 0x0021, 0x0028, 0x708f,
+	0x0023, 0x0020, 0x708f, 0x0024, 0x6043, 0x0000, 0x60e3, 0x0000,
+	0x6887, 0x0001, 0x2001, 0x0001, 0x080c, 0x2872, 0x0026, 0x2011,
+	0x0003, 0x080c, 0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c,
+	0x7f59, 0x0036, 0x2019, 0x0000, 0x080c, 0x7fe4, 0x003e, 0x002e,
+	0x7000, 0xa08e, 0x0004, 0x0118, 0x602b, 0x0028, 0x0010, 0x602b,
+	0x0020, 0x0156, 0x0126, 0x2091, 0x8000, 0x20a9, 0x0005, 0x6024,
+	0xd0ac, 0x0120, 0x012e, 0x015e, 0x0804, 0x5aa2, 0x6800, 0xa084,
+	0x00a0, 0xc0bd, 0x6802, 0x6904, 0xd1d4, 0x1130, 0x6803, 0x0100,
+	0x1f04, 0x5a57, 0x080c, 0x5b20, 0x012e, 0x015e, 0x080c, 0x5ae1,
+	0x01a8, 0x6044, 0xa005, 0x0168, 0x6050, 0x0006, 0xa085, 0x0020,
+	0x6052, 0x080c, 0x5b20, 0xa006, 0x8001, 0x1df0, 0x000e, 0x6052,
+	0x0028, 0x6804, 0xd0d4, 0x1110, 0x080c, 0x5b20, 0x0016, 0x0026,
+	0x2009, 0x00c8, 0x2011, 0x59a2, 0x080c, 0x6a22, 0x002e, 0x001e,
+	0x2001, 0xb79f, 0x2003, 0x0004, 0x080c, 0x57e1, 0x080c, 0x5ae1,
+	0x0148, 0x6804, 0xd0d4, 0x1130, 0xd0dc, 0x1100, 0x2001, 0xb79f,
+	0x2003, 0x0000, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6,
+	0x00e6, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0xb500, 0x2001,
+	0xb79e, 0x2003, 0x0000, 0x2001, 0xb78f, 0x2003, 0x0000, 0x708f,
+	0x0000, 0x60e3, 0x0000, 0x6887, 0x0000, 0x2001, 0x0000, 0x080c,
+	0x2872, 0x6803, 0x0000, 0x6043, 0x0090, 0x6043, 0x0010, 0x6027,
+	0xffff, 0x602b, 0x182f, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x0006,
+	0x2001, 0xb79e, 0x2004, 0xa086, 0xaaaa, 0x000e, 0x0005, 0x0006,
+	0x2001, 0xb572, 0x2004, 0xa084, 0x0030, 0xa086, 0x0000, 0x000e,
+	0x0005, 0x0006, 0x2001, 0xb572, 0x2004, 0xa084, 0x0030, 0xa086,
+	0x0030, 0x000e, 0x0005, 0x0006, 0x2001, 0xb572, 0x2004, 0xa084,
+	0x0030, 0xa086, 0x0010, 0x000e, 0x0005, 0x0006, 0x2001, 0xb572,
+	0x2004, 0xa084, 0x0030, 0xa086, 0x0020, 0x000e, 0x0005, 0x2001,
+	0xb50c, 0x2004, 0xd0a4, 0x0170, 0x080c, 0x2892, 0x0036, 0x0016,
+	0x2009, 0x0000, 0x2019, 0x0028, 0x080c, 0x2c6f, 0x001e, 0x003e,
+	0xa006, 0x0009, 0x0005, 0x00e6, 0x2071, 0xb50c, 0x2e04, 0x0118,
+	0xa085, 0x0010, 0x0010, 0xa084, 0xffef, 0x2072, 0x00ee, 0x0005,
+	0x6050, 0x0006, 0x60f0, 0x0006, 0x60ec, 0x0006, 0x600c, 0x0006,
+	0x6004, 0x0006, 0x6028, 0x0006, 0x602f, 0x0100, 0x602f, 0x0000,
+	0x602f, 0x0040, 0x602f, 0x0000, 0x000e, 0x602a, 0x000e, 0x6006,
+	0x000e, 0x600e, 0x000e, 0x60ee, 0x000e, 0x60f2, 0x60e3, 0x0000,
+	0x6887, 0x0001, 0x2001, 0x0001, 0x080c, 0x2872, 0x6800, 0xa084,
+	0x00a0, 0xc0bd, 0x6802, 0x6803, 0x00a0, 0x000e, 0x6052, 0x6050,
+	0x0005, 0x0156, 0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6,
+	0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0xb500, 0x6020, 0xa084,
+	0x0080, 0x0138, 0x2001, 0xb50c, 0x200c, 0xc1bd, 0x2102, 0x0804,
+	0x5bc9, 0x2001, 0xb50c, 0x200c, 0xc1bc, 0x2102, 0x6028, 0xa084,
+	0xe1ff, 0x602a, 0x6027, 0x0200, 0x6803, 0x0090, 0x20a9, 0x0384,
+	0x6024, 0xd0cc, 0x1508, 0x1d04, 0x5b78, 0x2091, 0x6000, 0x1f04,
+	0x5b78, 0x2011, 0x0003, 0x080c, 0x8075, 0x2011, 0x0002, 0x080c,
+	0x807f, 0x080c, 0x7f59, 0x2019, 0x0000, 0x080c, 0x7fe4, 0x6803,
+	0x00a0, 0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003,
+	0x0001, 0xa085, 0x0001, 0x0468, 0x86ff, 0x1120, 0x080c, 0x1e47,
+	0x080c, 0x24b0, 0x60e3, 0x0000, 0x2001, 0xb78f, 0x2004, 0x080c,
+	0x2872, 0x60e2, 0x6803, 0x0080, 0x20a9, 0x0384, 0x6027, 0x1e00,
+	0x2009, 0x1e00, 0xe000, 0x6024, 0xa10c, 0x0138, 0x1d04, 0x5bae,
+	0x2091, 0x6000, 0x1f04, 0x5bae, 0x0820, 0x6028, 0xa085, 0x1e00,
+	0x602a, 0x70a4, 0xa005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886,
+	0xa006, 0x00ee, 0x00de, 0x00ce, 0x003e, 0x002e, 0x001e, 0x015e,
+	0x0005, 0x0156, 0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6,
+	0x2061, 0x0100, 0x2071, 0xb500, 0x2069, 0x0140, 0x6020, 0xa084,
+	0x00c0, 0x0120, 0x6884, 0xa005, 0x1904, 0x5c25, 0x6803, 0x0088,
+	0x60e3, 0x0000, 0x6887, 0x0000, 0x2001, 0x0000, 0x080c, 0x2872,
+	0x2069, 0x0200, 0x6804, 0xa005, 0x1118, 0x6808, 0xa005, 0x01c0,
+	0x6028, 0xa084, 0xfbff, 0x602a, 0x6027, 0x0400, 0x2069, 0xb7c5,
+	0x7000, 0x206a, 0x708f, 0x0026, 0x7003, 0x0001, 0x20a9, 0x0002,
+	0x1d04, 0x5c08, 0x2091, 0x6000, 0x1f04, 0x5c08, 0x0804, 0x5c56,
+	0x2069, 0x0140, 0x20a9, 0x0384, 0x6027, 0x1e00, 0x2009, 0x1e00,
+	0xe000, 0x6024, 0xa10c, 0x0520, 0xa084, 0x1a00, 0x1508, 0x1d04,
+	0x5c14, 0x2091, 0x6000, 0x1f04, 0x5c14, 0x2011, 0x0003, 0x080c,
+	0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c, 0x7f59, 0x2019,
+	0x0000, 0x080c, 0x7fe4, 0x6803, 0x00a0, 0x2001, 0xb79f, 0x2003,
+	0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0xa085, 0x0001, 0x00b0,
+	0x080c, 0x24b0, 0x6803, 0x0080, 0x2069, 0x0140, 0x60e3, 0x0000,
+	0x70a4, 0xa005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x2001,
+	0xb78f, 0x2004, 0x080c, 0x2872, 0x60e2, 0xa006, 0x00ee, 0x00de,
+	0x00ce, 0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016,
+	0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2071,
+	0xb500, 0x6020, 0xa084, 0x00c0, 0x01e0, 0x2011, 0x0003, 0x080c,
+	0x8075, 0x2011, 0x0002, 0x080c, 0x807f, 0x080c, 0x7f59, 0x2019,
+	0x0000, 0x080c, 0x7fe4, 0x2069, 0x0140, 0x6803, 0x00a0, 0x2001,
+	0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0x0804,
+	0x5cfb, 0x2001, 0xb50c, 0x200c, 0xd1b4, 0x1160, 0xc1b5, 0x2102,
+	0x080c, 0x598a, 0x2069, 0x0140, 0x080c, 0x24b0, 0x6803, 0x0080,
+	0x60e3, 0x0000, 0x2069, 0x0200, 0x6804, 0xa005, 0x1118, 0x6808,
+	0xa005, 0x01c0, 0x6028, 0xa084, 0xfdff, 0x602a, 0x6027, 0x0200,
+	0x2069, 0xb7c5, 0x7000, 0x206a, 0x708f, 0x0027, 0x7003, 0x0001,
+	0x20a9, 0x0002, 0x1d04, 0x5cb2, 0x2091, 0x6000, 0x1f04, 0x5cb2,
+	0x0804, 0x5cfb, 0x6027, 0x1e00, 0x2009, 0x1e00, 0xe000, 0x6024,
+	0xa10c, 0x01c8, 0xa084, 0x1c00, 0x11b0, 0x1d04, 0x5cba, 0x0006,
+	0x0016, 0x00c6, 0x00d6, 0x00e6, 0x080c, 0x68f9, 0x00ee, 0x00de,
+	0x00ce, 0x001e, 0x000e, 0x00e6, 0x2071, 0xb7f3, 0x7018, 0x00ee,
+	0xa005, 0x1d00, 0x0500, 0x0026, 0x2011, 0x59a2, 0x080c, 0x699c,
+	0x2011, 0x5995, 0x080c, 0x6a5c, 0x002e, 0x2069, 0x0140, 0x60e3,
+	0x0000, 0x70a4, 0xa005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886,
+	0x2001, 0xb78f, 0x2004, 0x080c, 0x2872, 0x60e2, 0x2001, 0xb50c,
+	0x200c, 0xc1b4, 0x2102, 0x00ee, 0x00de, 0x00ce, 0x003e, 0x002e,
+	0x001e, 0x015e, 0x0005, 0x0156, 0x0016, 0x0026, 0x0036, 0x0046,
+	0x00c6, 0x00e6, 0x2061, 0x0100, 0x2071, 0xb500, 0x7130, 0xd184,
+	0x1180, 0x2011, 0xb553, 0x2214, 0xd2ec, 0x0138, 0xc18d, 0x7132,
+	0x2011, 0xb553, 0x2214, 0xd2ac, 0x1120, 0x7030, 0xd08c, 0x0904,
+	0x5d68, 0x7130, 0xc185, 0x7132, 0x2011, 0xb553, 0x220c, 0xd1a4,
+	0x0530, 0x0016, 0x2019, 0x000e, 0x080c, 0xb065, 0x0156, 0x20a9,
+	0x007f, 0x2009, 0x0000, 0xa186, 0x007e, 0x01a0, 0xa186, 0x0080,
+	0x0188, 0x080c, 0x4fa9, 0x1170, 0x8127, 0xa006, 0x0016, 0x2009,
+	0x000e, 0x080c, 0xb0e8, 0x2009, 0x0001, 0x2011, 0x0100, 0x080c,
+	0x6b1a, 0x001e, 0x8108, 0x1f04, 0x5d33, 0x015e, 0x001e, 0xd1ac,
+	0x1148, 0x0016, 0x2009, 0x0000, 0x2019, 0x0004, 0x080c, 0x2c6f,
+	0x001e, 0x0070, 0x0156, 0x20a9, 0x007f, 0x2009, 0x0000, 0x080c,
+	0x4fa9, 0x1110, 0x080c, 0x4c0b, 0x8108, 0x1f04, 0x5d5f, 0x015e,
+	0x080c, 0x1e47, 0x2011, 0x0003, 0x080c, 0x8075, 0x2011, 0x0002,
+	0x080c, 0x807f, 0x080c, 0x7f59, 0x0036, 0x2019, 0x0000, 0x080c,
+	0x7fe4, 0x003e, 0x60e3, 0x0000, 0x2001, 0xb500, 0x2003, 0x0001,
+	0x080c, 0x5a07, 0x00ee, 0x00ce, 0x004e, 0x003e, 0x002e, 0x001e,
+	0x015e, 0x0005, 0x2071, 0xb5e2, 0x7003, 0x0000, 0x7007, 0x0000,
+	0x700f, 0x0000, 0x702b, 0x0001, 0x704f, 0x0000, 0x7053, 0x0001,
+	0x705f, 0x0020, 0x7063, 0x0040, 0x7083, 0x0000, 0x708b, 0x0000,
+	0x708f, 0x0001, 0x70bf, 0x0000, 0x0005, 0x00e6, 0x2071, 0xb5e2,
+	0x6848, 0xa005, 0x1130, 0x7028, 0xc085, 0x702a, 0xa085, 0x0001,
+	0x0428, 0x6a50, 0x7236, 0x6b54, 0x733a, 0x6858, 0x703e, 0x707a,
+	0x685c, 0x7042, 0x707e, 0x6848, 0x702e, 0x6840, 0x7032, 0x2009,
+	0x000c, 0x200a, 0x8007, 0x8006, 0x8006, 0xa08c, 0x003f, 0xa084,
+	0xffc0, 0xa210, 0x2100, 0xa319, 0x7272, 0x7376, 0x7028, 0xc084,
+	0x702a, 0x7007, 0x0001, 0x700f, 0x0000, 0xa006, 0x00ee, 0x0005,
+	0x2b78, 0x2071, 0xb5e2, 0x7004, 0x0043, 0x700c, 0x0002, 0x5de4,
+	0x5ddb, 0x5ddb, 0x5ddb, 0x5ddb, 0x0005, 0x5e3a, 0x5e3b, 0x5e6d,
+	0x5e6e, 0x5e38, 0x5ebc, 0x5ec1, 0x5ef2, 0x5ef3, 0x5f0e, 0x5f0f,
+	0x5f10, 0x5f11, 0x5f12, 0x5f13, 0x5fc9, 0x5ff0, 0x700c, 0x0002,
+	0x5dfd, 0x5e38, 0x5e38, 0x5e39, 0x5e39, 0x7830, 0x7930, 0xa106,
+	0x0120, 0x7830, 0x7930, 0xa106, 0x1510, 0x7030, 0xa10a, 0x01f8,
+	0x1210, 0x712c, 0xa10a, 0xa18a, 0x0002, 0x12d0, 0x080c, 0x15df,
+	0x01b0, 0x2d00, 0x705a, 0x7063, 0x0040, 0x2001, 0x0003, 0x7057,
+	0x0000, 0x0126, 0x0006, 0x2091, 0x8000, 0x2009, 0xb812, 0x2104,
+	0xc085, 0x200a, 0x000e, 0x700e, 0x012e, 0x080c, 0x165f, 0x0005,
+	0x080c, 0x15df, 0x0de0, 0x2d00, 0x705a, 0x080c, 0x15df, 0x1108,
+	0x0c10, 0x2d00, 0x7086, 0x7063, 0x0080, 0x2001, 0x0004, 0x08f8,
+	0x0005, 0x0005, 0x0005, 0x700c, 0x0002, 0x5e42, 0x5e45, 0x5e53,
+	0x5e6c, 0x5e6c, 0x080c, 0x5df6, 0x0005, 0x0126, 0x8001, 0x700e,
+	0x7058, 0x0006, 0x080c, 0x6343, 0x0120, 0x2091, 0x8000, 0x080c,
+	0x5df6, 0x00de, 0x0048, 0x0126, 0x8001, 0x700e, 0x080c, 0x6343,
+	0x7058, 0x2068, 0x7084, 0x705a, 0x6803, 0x0000, 0x6807, 0x0000,
+	0x6834, 0xa084, 0x00ff, 0xa08a, 0x003a, 0x1218, 0x00db, 0x012e,
+	0x0005, 0x012e, 0x080c, 0x5f14, 0x0005, 0x0005, 0x0005, 0x00e6,
+	0x2071, 0xb5e2, 0x700c, 0x0002, 0x5e79, 0x5e79, 0x5e79, 0x5e7b,
+	0x5e7e, 0x00ee, 0x0005, 0x700f, 0x0001, 0x0010, 0x700f, 0x0002,
+	0x00ee, 0x0005, 0x5f14, 0x5f14, 0x5f30, 0x5f14, 0x60ad, 0x5f14,
+	0x5f14, 0x5f14, 0x5f14, 0x5f14, 0x5f30, 0x60ef, 0x6132, 0x617b,
+	0x618f, 0x5f14, 0x5f14, 0x5f4c, 0x5f30, 0x5f14, 0x5f14, 0x5fa6,
+	0x623b, 0x6256, 0x5f14, 0x5f4c, 0x5f14, 0x5f14, 0x5f14, 0x5f14,
+	0x5f9c, 0x6256, 0x5f14, 0x5f14, 0x5f14, 0x5f14, 0x5f14, 0x5f14,
+	0x5f14, 0x5f14, 0x5f14, 0x5f60, 0x5f14, 0x5f14, 0x5f14, 0x5f14,
+	0x5f14, 0x5f14, 0x5f14, 0x5f14, 0x5f14, 0x6361, 0x5f14, 0x5f14,
+	0x5f14, 0x5f14, 0x5f14, 0x5f75, 0x7020, 0x2068, 0x080c, 0x160f,
+	0x0005, 0x700c, 0x0002, 0x5ec8, 0x5ecb, 0x5ed9, 0x5ef1, 0x5ef1,
+	0x080c, 0x5df6, 0x0005, 0x0126, 0x8001, 0x700e, 0x7058, 0x0006,
+	0x080c, 0x6343, 0x0120, 0x2091, 0x8000, 0x080c, 0x5df6, 0x00de,
+	0x0048, 0x0126, 0x8001, 0x700e, 0x080c, 0x6343, 0x7058, 0x2068,
+	0x7084, 0x705a, 0x6803, 0x0000, 0x6807, 0x0000, 0x6834, 0xa084,
+	0x00ff, 0xa08a, 0x001a, 0x1218, 0x003b, 0x012e, 0x0005, 0x012e,
+	0x0419, 0x0005, 0x0005, 0x0005, 0x5f14, 0x5f30, 0x6099, 0x5f14,
+	0x5f30, 0x5f14, 0x5f30, 0x5f30, 0x5f14, 0x5f30, 0x6099, 0x5f30,
+	0x5f30, 0x5f30, 0x5f30, 0x5f30, 0x5f14, 0x5f30, 0x6099, 0x5f14,
+	0x5f14, 0x5f30, 0x5f14, 0x5f14, 0x5f14, 0x5f30, 0x0005, 0x0005,
+	0x0005, 0x0005, 0x0005, 0x0005, 0x7007, 0x0001, 0x6838, 0xa084,
+	0x00ff, 0xc0d5, 0x683a, 0x0126, 0x2091, 0x8000, 0x080c, 0x5408,
+	0x012e, 0x0005, 0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0e5,
+	0x683a, 0x0126, 0x2091, 0x8000, 0x080c, 0x5408, 0x012e, 0x0005,
+	0x7007, 0x0001, 0x6838, 0xa084, 0x00ff, 0xc0ed, 0x683a, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x5408, 0x012e, 0x0005, 0x7007, 0x0001,
+	0x6838, 0xa084, 0x00ff, 0xc0dd, 0x683a, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x5408, 0x012e, 0x0005, 0x6834, 0x8007, 0xa084, 0x00ff,
+	0x0988, 0x8001, 0x1120, 0x7007, 0x0001, 0x0804, 0x6059, 0x7007,
+	0x0006, 0x7012, 0x2d00, 0x7016, 0x701a, 0x704b, 0x6059, 0x0005,
+	0x6834, 0x8007, 0xa084, 0x00ff, 0x0904, 0x5f22, 0x8001, 0x1120,
+	0x7007, 0x0001, 0x0804, 0x6076, 0x7007, 0x0006, 0x7012, 0x2d00,
+	0x7016, 0x701a, 0x704b, 0x6076, 0x0005, 0x6834, 0x8007, 0xa084,
+	0x00ff, 0xa086, 0x0001, 0x1904, 0x5f22, 0x7007, 0x0001, 0x2009,
+	0xb531, 0x210c, 0x81ff, 0x11a8, 0x6838, 0xa084, 0x00ff, 0x683a,
+	0x6853, 0x0000, 0x080c, 0x4d82, 0x1108, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x6837, 0x0139, 0x684a, 0x6952, 0x080c, 0x5408, 0x012e,
+	0x0ca0, 0x2001, 0x0028, 0x0c90, 0x684c, 0xa084, 0x00c0, 0xa086,
+	0x00c0, 0x1120, 0x7007, 0x0001, 0x0804, 0x626e, 0x2d00, 0x7016,
+	0x701a, 0x20a9, 0x0004, 0xa080, 0x0024, 0x2098, 0x20a1, 0xb60d,
+	0x53a3, 0x6858, 0x7012, 0xa082, 0x0401, 0x1a04, 0x5f3e, 0x6a84,
+	0xa28a, 0x0002, 0x1a04, 0x5f3e, 0x82ff, 0x1138, 0x6888, 0x698c,
+	0xa105, 0x0118, 0x2001, 0x602c, 0x0018, 0xa280, 0x6022, 0x2005,
+	0x70c6, 0x7010, 0xa015, 0x0904, 0x600e, 0x080c, 0x15df, 0x1118,
+	0x7007, 0x000f, 0x0005, 0x2d00, 0x7022, 0x70c4, 0x2060, 0x2c05,
+	0x6836, 0xe004, 0xad00, 0x7096, 0xe008, 0xa20a, 0x1210, 0xa00e,
+	0x2200, 0x7112, 0xe20c, 0x8003, 0x800b, 0xa296, 0x0004, 0x0108,
+	0xa108, 0x719a, 0x810b, 0x719e, 0xae90, 0x0022, 0x080c, 0x1643,
+	0x7090, 0xa08e, 0x0100, 0x0170, 0xa086, 0x0200, 0x0118, 0x7007,
+	0x0010, 0x0005, 0x7020, 0x2068, 0x080c, 0x160f, 0x7014, 0x2068,
+	0x0804, 0x5f3e, 0x7020, 0x2068, 0x7018, 0x6802, 0x6807, 0x0000,
+	0x2d08, 0x2068, 0x6906, 0x711a, 0x0804, 0x5fc9, 0x7014, 0x2068,
+	0x7007, 0x0001, 0x6884, 0xa005, 0x1128, 0x6888, 0x698c, 0xa105,
+	0x0108, 0x00b1, 0x6834, 0xa084, 0x00ff, 0xa086, 0x001e, 0x0904,
+	0x626e, 0x04b8, 0x6024, 0x6028, 0x0002, 0x0011, 0x0007, 0x0004,
+	0x000a, 0x000f, 0x0005, 0x0006, 0x000a, 0x0011, 0x0005, 0x0004,
+	0x00f6, 0x00e6, 0x00c6, 0x0076, 0x0066, 0x6f88, 0x6e8c, 0x6804,
+	0x2060, 0xacf0, 0x0021, 0xacf8, 0x0027, 0x2009, 0x0005, 0x700c,
+	0x7816, 0x7008, 0x7812, 0x7004, 0x7806, 0x7000, 0x7802, 0x7e0e,
+	0x7f0a, 0x8109, 0x0128, 0xaef2, 0x0004, 0xaffa, 0x0006, 0x0c78,
+	0x6004, 0xa065, 0x1d30, 0x006e, 0x007e, 0x00ce, 0x00ee, 0x00fe,
+	0x0005, 0x2009, 0xb531, 0x210c, 0x81ff, 0x1198, 0x6838, 0xa084,
+	0x00ff, 0x683a, 0x080c, 0x4c64, 0x1108, 0x0005, 0x080c, 0x54db,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x9ecc, 0x080c, 0x5408, 0x012e,
+	0x0ca0, 0x2001, 0x0028, 0x2009, 0x0000, 0x0c80, 0x2009, 0xb531,
+	0x210c, 0x81ff, 0x11b0, 0x6858, 0xa005, 0x01c0, 0x6838, 0xa084,
+	0x00ff, 0x683a, 0x6853, 0x0000, 0x080c, 0x4d26, 0x1108, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x684a, 0x6952, 0x080c, 0x5408, 0x012e,
+	0x0cb0, 0x2001, 0x0028, 0x2009, 0x0000, 0x0c90, 0x2001, 0x0000,
+	0x0c78, 0x7018, 0x6802, 0x2d08, 0x2068, 0x6906, 0x711a, 0x7010,
+	0x8001, 0x7012, 0x0118, 0x7007, 0x0006, 0x0030, 0x7014, 0x2068,
+	0x7007, 0x0001, 0x7048, 0x080f, 0x0005, 0x7007, 0x0001, 0x6944,
+	0x810f, 0xa18c, 0x00ff, 0x6848, 0xa084, 0x00ff, 0x20a9, 0x0001,
+	0xa096, 0x0001, 0x01b0, 0x2009, 0x0000, 0x20a9, 0x00ff, 0xa096,
+	0x0002, 0x0178, 0xa005, 0x11f0, 0x6944, 0x810f, 0xa18c, 0x00ff,
+	0x080c, 0x4fa9, 0x11b8, 0x0066, 0x6e50, 0x080c, 0x50a8, 0x006e,
+	0x0088, 0x0046, 0x2011, 0xb50c, 0x2224, 0xc484, 0x2412, 0x004e,
+	0x00c6, 0x080c, 0x4fa9, 0x1110, 0x080c, 0x5209, 0x8108, 0x1f04,
+	0x60d9, 0x00ce, 0x684c, 0xd084, 0x1118, 0x080c, 0x160f, 0x0005,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x5408, 0x012e, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x7007, 0x0001, 0x2001, 0xb553, 0x2004, 0xd0a4,
+	0x0580, 0x2061, 0xb874, 0x6100, 0xd184, 0x0178, 0x6858, 0xa084,
+	0x00ff, 0x1550, 0x6000, 0xd084, 0x0520, 0x6004, 0xa005, 0x1538,
+	0x6003, 0x0000, 0x600b, 0x0000, 0x00c8, 0x2011, 0x0001, 0x6860,
+	0xa005, 0x1110, 0x2001, 0x001e, 0x8000, 0x6016, 0x6858, 0xa084,
+	0x00ff, 0x0178, 0x6006, 0x6858, 0x8007, 0xa084, 0x00ff, 0x0148,
+	0x600a, 0x6858, 0x8000, 0x1108, 0xc28d, 0x6202, 0x012e, 0x0804,
+	0x6332, 0x012e, 0x0804, 0x632c, 0x012e, 0x0804, 0x6326, 0x012e,
+	0x0804, 0x6329, 0x0126, 0x2091, 0x8000, 0x7007, 0x0001, 0x2001,
+	0xb553, 0x2004, 0xd0a4, 0x05e0, 0x2061, 0xb874, 0x6000, 0xd084,
+	0x05b8, 0x6204, 0x6308, 0xd08c, 0x1530, 0x6c48, 0xa484, 0x0003,
+	0x0170, 0x6958, 0xa18c, 0x00ff, 0x8001, 0x1120, 0x2100, 0xa210,
+	0x0620, 0x0028, 0x8001, 0x1508, 0x2100, 0xa212, 0x02f0, 0xa484,
+	0x000c, 0x0188, 0x6958, 0x810f, 0xa18c, 0x00ff, 0xa082, 0x0004,
+	0x1120, 0x2100, 0xa318, 0x0288, 0x0030, 0xa082, 0x0004, 0x1168,
+	0x2100, 0xa31a, 0x0250, 0x6860, 0xa005, 0x0110, 0x8000, 0x6016,
+	0x6206, 0x630a, 0x012e, 0x0804, 0x6332, 0x012e, 0x0804, 0x632f,
+	0x012e, 0x0804, 0x632c, 0x0126, 0x2091, 0x8000, 0x7007, 0x0001,
+	0x2061, 0xb874, 0x6300, 0xd38c, 0x1120, 0x6308, 0x8318, 0x0220,
+	0x630a, 0x012e, 0x0804, 0x6340, 0x012e, 0x0804, 0x632f, 0x0126,
+	0x00c6, 0x2091, 0x8000, 0x7007, 0x0001, 0x684c, 0xd0ac, 0x0148,
+	0x00c6, 0x2061, 0xb874, 0x6000, 0xa084, 0xfcff, 0x6002, 0x00ce,
+	0x0448, 0x6858, 0xa005, 0x05d0, 0x685c, 0xa065, 0x0598, 0x2001,
+	0xb531, 0x2004, 0xa005, 0x0118, 0x080c, 0x9e1d, 0x0068, 0x6013,
+	0x0400, 0x6057, 0x0000, 0x694c, 0xd1a4, 0x0110, 0x6950, 0x6156,
+	0x2009, 0x0041, 0x080c, 0x864c, 0x6958, 0xa18c, 0xff00, 0xa186,
+	0x2000, 0x1140, 0x0026, 0x2009, 0x0000, 0x2011, 0xfdff, 0x080c,
+	0x6b1a, 0x002e, 0x684c, 0xd0c4, 0x0148, 0x2061, 0xb874, 0x6000,
+	0xd08c, 0x1120, 0x6008, 0x8000, 0x0208, 0x600a, 0x00ce, 0x012e,
+	0x0804, 0x6332, 0x00ce, 0x012e, 0x0804, 0x632c, 0x6954, 0xa186,
+	0x002e, 0x0d40, 0xa186, 0x002d, 0x0d28, 0xa186, 0x0045, 0x0528,
+	0xa186, 0x002a, 0x1130, 0x2001, 0xb50c, 0x200c, 0xc194, 0x2102,
+	0x08c8, 0xa186, 0x0020, 0x0170, 0xa186, 0x0029, 0x1d18, 0x6944,
+	0xa18c, 0xff00, 0x810f, 0x080c, 0x4fa9, 0x1960, 0x6000, 0xc0e4,
+	0x6002, 0x0840, 0x685c, 0xa065, 0x09a8, 0x6007, 0x0024, 0x2001,
+	0xb7b6, 0x2004, 0x6016, 0x0804, 0x61ca, 0x685c, 0xa065, 0x0950,
+	0x00e6, 0x6860, 0xa075, 0x2001, 0xb531, 0x2004, 0xa005, 0x0150,
+	0x080c, 0x9e1d, 0x8eff, 0x0118, 0x2e60, 0x080c, 0x9e1d, 0x00ee,
+	0x0804, 0x61ca, 0x6020, 0xc0dc, 0xc0d5, 0x6022, 0x2e60, 0x6007,
+	0x003a, 0x6870, 0xa005, 0x0130, 0x6007, 0x003b, 0x6874, 0x602a,
+	0x6878, 0x6012, 0x6003, 0x0001, 0x080c, 0x6c8d, 0x080c, 0x7173,
+	0x00ee, 0x0804, 0x61ca, 0x2061, 0xb874, 0x6000, 0xd084, 0x0190,
+	0xd08c, 0x1904, 0x6340, 0x0126, 0x2091, 0x8000, 0x6204, 0x8210,
+	0x0220, 0x6206, 0x012e, 0x0804, 0x6340, 0x012e, 0x6853, 0x0016,
+	0x0804, 0x6339, 0x6853, 0x0007, 0x0804, 0x6339, 0x6834, 0x8007,
+	0xa084, 0x00ff, 0x1118, 0x080c, 0x5f22, 0x0078, 0x2030, 0x8001,
+	0x1120, 0x7007, 0x0001, 0x0051, 0x0040, 0x7007, 0x0006, 0x7012,
+	0x2d00, 0x7016, 0x701a, 0x704b, 0x626e, 0x0005, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0xa03e, 0x2009, 0xb531, 0x210c, 0x81ff, 0x1904,
+	0x62ec, 0x2009, 0xb50c, 0x210c, 0xd194, 0x1904, 0x6316, 0x6848,
+	0x2070, 0xae82, 0xbd00, 0x0a04, 0x62e0, 0x2001, 0xb517, 0x2004,
+	0xae02, 0x1a04, 0x62e0, 0x711c, 0xa186, 0x0006, 0x1904, 0x62cf,
+	0x7018, 0xa005, 0x0904, 0x62ec, 0x2004, 0xd0e4, 0x1904, 0x6311,
+	0x2061, 0xb874, 0x6100, 0xa184, 0x0301, 0xa086, 0x0001, 0x1550,
+	0x7020, 0xd0dc, 0x1904, 0x6319, 0x6853, 0x0000, 0x6803, 0x0000,
+	0x2d08, 0x7010, 0xa005, 0x1158, 0x7112, 0x684c, 0xd0f4, 0x1904,
+	0x631c, 0x2e60, 0x080c, 0x6a76, 0x012e, 0x00ee, 0x0005, 0x2068,
+	0x6800, 0xa005, 0x1de0, 0x6902, 0x2168, 0x684c, 0xd0f4, 0x1904,
+	0x631c, 0x012e, 0x00ee, 0x0005, 0x012e, 0x00ee, 0x6853, 0x0006,
+	0x0804, 0x6339, 0xd184, 0x0dc0, 0xd1c4, 0x11a8, 0x00b8, 0x6944,
+	0xa18c, 0xff00, 0x810f, 0x080c, 0x4fa9, 0x15d8, 0x6000, 0xd0e4,
+	0x15c0, 0x711c, 0xa186, 0x0007, 0x1118, 0x6853, 0x0002, 0x0498,
+	0x6853, 0x0008, 0x0480, 0x6853, 0x000e, 0x0468, 0x6853, 0x0017,
+	0x0450, 0x6853, 0x0035, 0x0438, 0x2001, 0xb572, 0x2004, 0xd0fc,
+	0x01e8, 0x6848, 0x2070, 0xae82, 0xbd00, 0x02c0, 0x605c, 0xae02,
+	0x12a8, 0x711c, 0xa186, 0x0006, 0x1188, 0x7018, 0xa005, 0x0170,
+	0x2004, 0xd0bc, 0x0158, 0x2039, 0x0001, 0x7000, 0xa086, 0x0007,
+	0x1904, 0x6279, 0x7003, 0x0002, 0x0804, 0x6279, 0x6853, 0x0028,
+	0x0010, 0x6853, 0x0029, 0x012e, 0x00ee, 0x0418, 0x6853, 0x002a,
+	0x0cd0, 0x6853, 0x0045, 0x0cb8, 0x2e60, 0x2019, 0x0002, 0x6017,
+	0x0014, 0x080c, 0xace0, 0x012e, 0x00ee, 0x0005, 0x2009, 0x003e,
+	0x0058, 0x2009, 0x0004, 0x0040, 0x2009, 0x0006, 0x0028, 0x2009,
+	0x0016, 0x0010, 0x2009, 0x0001, 0x6854, 0xa084, 0xff00, 0xa105,
+	0x6856, 0x0126, 0x2091, 0x8000, 0x080c, 0x5408, 0x012e, 0x0005,
+	0x080c, 0x160f, 0x0005, 0x702c, 0x7130, 0x8108, 0xa102, 0x0230,
+	0xa00e, 0x7034, 0x7072, 0x7038, 0x7076, 0x0058, 0x7070, 0xa080,
+	0x0040, 0x7072, 0x1230, 0x7074, 0xa081, 0x0000, 0x7076, 0xa085,
+	0x0001, 0x7932, 0x7132, 0x0005, 0x00d6, 0x080c, 0x6a6d, 0x00de,
+	0x0005, 0x00d6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x7007, 0x0001,
+	0x6a44, 0xa282, 0x0004, 0x1a04, 0x63ac, 0xd284, 0x0170, 0x6a4c,
+	0xa290, 0xb635, 0x2204, 0xa065, 0x6004, 0x05e0, 0x8007, 0xa084,
+	0x00ff, 0xa084, 0x0006, 0x1108, 0x04a8, 0x2c10, 0x080c, 0x85c7,
+	0x1118, 0x080c, 0x9ed6, 0x05a0, 0x621a, 0x6844, 0x0002, 0x638b,
+	0x6390, 0x6393, 0x6399, 0x2019, 0x0002, 0x080c, 0xb065, 0x0060,
+	0x080c, 0xaffc, 0x0048, 0x2019, 0x0002, 0x6950, 0x080c, 0xb017,
+	0x0018, 0x6950, 0x080c, 0xaffc, 0x080c, 0x861d, 0x6857, 0x0000,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x5408, 0x012e, 0x001e, 0x002e,
+	0x003e, 0x00ce, 0x00de, 0x0005, 0x6857, 0x0006, 0x0c88, 0x6857,
+	0x0002, 0x0c70, 0x6857, 0x0005, 0x0c58, 0x6857, 0x0004, 0x0c40,
+	0x6857, 0x0007, 0x0c28, 0x00d6, 0x2011, 0x0004, 0x2204, 0xa085,
+	0x8002, 0x2012, 0x00de, 0x0005, 0x20e1, 0x0002, 0x3d08, 0x20e1,
+	0x2000, 0x3d00, 0xa084, 0x7000, 0x0118, 0xa086, 0x1000, 0x1570,
+	0x20e1, 0x0000, 0x3d00, 0xa094, 0xff00, 0x8217, 0xa084, 0xf000,
+	0xa086, 0x3000, 0x1160, 0xa184, 0xff00, 0x8007, 0xa086, 0x0008,
+	0x11e8, 0x080c, 0x2dbf, 0x11d0, 0x080c, 0x6603, 0x0098, 0x20e1,
+	0x0004, 0x3d60, 0xd1bc, 0x1108, 0x3e60, 0xac84, 0x0007, 0x1170,
+	0xac82, 0xbd00, 0x0258, 0x685c, 0xac02, 0x1240, 0x2009, 0x0047,
+	0x080c, 0x864c, 0x7a1c, 0xd284, 0x1938, 0x0005, 0xa016, 0x080c,
+	0x185e, 0x0cc0, 0x0cd8, 0x781c, 0xd08c, 0x0500, 0x0156, 0x0136,
+	0x0146, 0x20e1, 0x3000, 0x3d20, 0x3e28, 0xa584, 0x0076, 0x1538,
+	0xa484, 0x7000, 0xa086, 0x1000, 0x11a8, 0x080c, 0x647e, 0x01f8,
+	0x20e1, 0x3000, 0x7828, 0x7828, 0x080c, 0x649a, 0x014e, 0x013e,
+	0x015e, 0x2009, 0xb7e8, 0x2104, 0xa005, 0x1108, 0x0005, 0x080c,
+	0x7173, 0x0ce0, 0xa484, 0x7000, 0x1548, 0x080c, 0x647e, 0x01d8,
+	0x7000, 0xa084, 0xff00, 0xa086, 0x8100, 0x0d10, 0x00a0, 0xd5a4,
+	0x0178, 0x0056, 0x0046, 0x080c, 0x1e6e, 0x080c, 0x24b0, 0x2001,
+	0x0160, 0x2502, 0x2001, 0x0138, 0x2202, 0x004e, 0x005e, 0x0048,
+	0x04a9, 0x6887, 0x0000, 0x080c, 0xb3df, 0x20e1, 0x3000, 0x7828,
+	0x7828, 0x00b9, 0x014e, 0x013e, 0x015e, 0x0880, 0x0439, 0x1130,
+	0x7000, 0xa084, 0xff00, 0xa086, 0x8100, 0x1d68, 0x080c, 0xb3df,
+	0x20e1, 0x3000, 0x7828, 0x7828, 0x0056, 0x080c, 0x6874, 0x005e,
+	0x0c40, 0x2001, 0xb50e, 0x2004, 0xd08c, 0x0178, 0x2001, 0xb500,
+	0x2004, 0xa086, 0x0003, 0x1148, 0x0026, 0x0036, 0x2011, 0x8048,
+	0x2518, 0x080c, 0x3ecc, 0x003e, 0x002e, 0x0005, 0xa484, 0x01ff,
+	0x6886, 0xa005, 0x0160, 0xa080, 0x001f, 0xa084, 0x03f8, 0x80ac,
+	0x20e1, 0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0x0005, 0x20a9,
+	0x000c, 0x20e1, 0x1000, 0x2ea0, 0x2099, 0x020a, 0x53a5, 0xa085,
+	0x0001, 0x0ca0, 0x7000, 0xa084, 0xff00, 0xa08c, 0xf000, 0x8007,
+	0xa196, 0x0000, 0x1118, 0x0804, 0x6708, 0x0005, 0xa196, 0x2000,
+	0x1148, 0x6900, 0xa18e, 0x0001, 0x1118, 0x080c, 0x448f, 0x0ca8,
+	0x0039, 0x0c98, 0xa196, 0x8000, 0x1d80, 0x080c, 0x67b4, 0x0c68,
+	0x00c6, 0x6a84, 0x82ff, 0x0904, 0x65fd, 0x7110, 0xa18c, 0xff00,
+	0x810f, 0xa196, 0x0001, 0x0120, 0xa196, 0x0023, 0x1904, 0x65fd,
+	0xa08e, 0x0023, 0x1570, 0x080c, 0x684f, 0x0904, 0x65fd, 0x7124,
+	0x610a, 0x7030, 0xa08e, 0x0200, 0x1150, 0x7034, 0xa005, 0x1904,
+	0x65fd, 0x2009, 0x0015, 0x080c, 0x864c, 0x0804, 0x65fd, 0xa08e,
+	0x0214, 0x0118, 0xa08e, 0x0210, 0x1130, 0x2009, 0x0015, 0x080c,
+	0x864c, 0x0804, 0x65fd, 0xa08e, 0x0100, 0x1904, 0x65fd, 0x7034,
+	0xa005, 0x1904, 0x65fd, 0x2009, 0x0016, 0x080c, 0x864c, 0x0804,
+	0x65fd, 0xa08e, 0x0022, 0x1904, 0x65fd, 0x7030, 0xa08e, 0x0300,
+	0x1580, 0x68d4, 0xd0a4, 0x0528, 0xc0b5, 0x68d6, 0x7100, 0xa18c,
+	0x00ff, 0x6972, 0x7004, 0x6876, 0x00f6, 0x2079, 0x0100, 0x79e6,
+	0x78ea, 0x0006, 0xa084, 0x00ff, 0x0016, 0x2008, 0x080c, 0x2847,
+	0x7932, 0x7936, 0x001e, 0x000e, 0x00fe, 0x080c, 0x281d, 0x6952,
+	0x703c, 0x00e6, 0x2071, 0x0140, 0x7086, 0x2071, 0xb500, 0x70a6,
+	0x00ee, 0x7034, 0xa005, 0x1904, 0x65fd, 0x2009, 0x0017, 0x0804,
+	0x65c3, 0xa08e, 0x0400, 0x1158, 0x7034, 0xa005, 0x1904, 0x65fd,
+	0x68d4, 0xc0a5, 0x68d6, 0x2009, 0x0030, 0x0804, 0x65c3, 0xa08e,
+	0x0500, 0x1140, 0x7034, 0xa005, 0x1904, 0x65fd, 0x2009, 0x0018,
+	0x0804, 0x65c3, 0xa08e, 0x2010, 0x1120, 0x2009, 0x0019, 0x0804,
+	0x65c3, 0xa08e, 0x2110, 0x1120, 0x2009, 0x001a, 0x0804, 0x65c3,
+	0xa08e, 0x5200, 0x1140, 0x7034, 0xa005, 0x1904, 0x65fd, 0x2009,
+	0x001b, 0x0804, 0x65c3, 0xa08e, 0x5000, 0x1140, 0x7034, 0xa005,
+	0x1904, 0x65fd, 0x2009, 0x001c, 0x0804, 0x65c3, 0xa08e, 0x1300,
+	0x1120, 0x2009, 0x0034, 0x0804, 0x65c3, 0xa08e, 0x1200, 0x1140,
+	0x7034, 0xa005, 0x1904, 0x65fd, 0x2009, 0x0024, 0x0804, 0x65c3,
+	0xa08c, 0xff00, 0xa18e, 0x2400, 0x1118, 0x2009, 0x002d, 0x04d8,
+	0xa08c, 0xff00, 0xa18e, 0x5300, 0x1118, 0x2009, 0x002a, 0x0498,
+	0xa08e, 0x0f00, 0x1118, 0x2009, 0x0020, 0x0468, 0xa08e, 0x5300,
+	0x1108, 0x00d8, 0xa08e, 0x6104, 0x11c0, 0x2011, 0xbb8d, 0x8208,
+	0x2204, 0xa082, 0x0004, 0x20a8, 0x95ac, 0x95ac, 0x2011, 0x8015,
+	0x211c, 0x8108, 0x0046, 0x2124, 0x080c, 0x3ecc, 0x004e, 0x8108,
+	0x1f04, 0x65a6, 0x2009, 0x0023, 0x0070, 0xa08e, 0x6000, 0x1118,
+	0x2009, 0x003f, 0x0040, 0xa08e, 0x7800, 0x1118, 0x2009, 0x0045,
+	0x0010, 0x2009, 0x001d, 0x0016, 0x2011, 0xbb83, 0x2204, 0x8211,
+	0x220c, 0x080c, 0x281d, 0x1598, 0x080c, 0x4f4d, 0x1580, 0x6612,
+	0x6516, 0x86ff, 0x01e8, 0x001e, 0x0016, 0xa186, 0x0017, 0x1158,
+	0x6870, 0xa606, 0x11a8, 0x6874, 0xa506, 0xa084, 0xff00, 0x1180,
+	0x6000, 0xc0f5, 0x6002, 0xa186, 0x0046, 0x1150, 0x6870, 0xa606,
+	0x1138, 0x6874, 0xa506, 0xa084, 0xff00, 0x1110, 0x001e, 0x0068,
+	0x00c6, 0x080c, 0x85c7, 0x0168, 0x001e, 0x611a, 0x601f, 0x0004,
+	0x7120, 0x610a, 0x001e, 0x080c, 0x864c, 0x00ce, 0x0005, 0x001e,
+	0x0ce0, 0x00ce, 0x0ce0, 0x00c6, 0x0046, 0x080c, 0x6657, 0x1904,
+	0x6654, 0xa28e, 0x0033, 0x11e8, 0x080c, 0x684f, 0x0904, 0x6654,
+	0x7124, 0x610a, 0x7030, 0xa08e, 0x0200, 0x1140, 0x7034, 0xa005,
+	0x15d8, 0x2009, 0x0015, 0x080c, 0x864c, 0x04b0, 0xa08e, 0x0100,
+	0x1598, 0x7034, 0xa005, 0x1580, 0x2009, 0x0016, 0x080c, 0x864c,
+	0x0458, 0xa28e, 0x0032, 0x1540, 0x7030, 0xa08e, 0x1400, 0x1520,
+	0x2009, 0x0038, 0x0016, 0x2011, 0xbb83, 0x2204, 0x8211, 0x220c,
+	0x080c, 0x281d, 0x11c0, 0x080c, 0x4f4d, 0x11a8, 0x6612, 0x6516,
+	0x00c6, 0x080c, 0x85c7, 0x0170, 0x001e, 0x611a, 0x080c, 0xa027,
+	0x601f, 0x0004, 0x7120, 0x610a, 0x001e, 0x080c, 0x864c, 0x080c,
+	0x7173, 0x0010, 0x00ce, 0x001e, 0x004e, 0x00ce, 0x0005, 0x00f6,
+	0x00d6, 0x0026, 0x0016, 0x0136, 0x0146, 0x0156, 0x3c00, 0x0006,
+	0x2079, 0x0030, 0x2069, 0x0200, 0x080c, 0x1f2d, 0x1590, 0x080c,
+	0x1dd2, 0x05e0, 0x04f1, 0x1130, 0x7908, 0xa18c, 0x1fff, 0xa182,
+	0x0011, 0x1688, 0x20a9, 0x000c, 0x20e1, 0x0000, 0x2ea0, 0x2099,
+	0x020a, 0x53a5, 0x20e1, 0x2000, 0x2001, 0x020a, 0x2004, 0x7a0c,
+	0x7808, 0xa080, 0x0007, 0xa084, 0x1ff8, 0x0419, 0x1120, 0xa08a,
+	0x0140, 0x1a0c, 0x1515, 0x80ac, 0x20e1, 0x6000, 0x2099, 0x020a,
+	0x53a5, 0x20e1, 0x7000, 0x6828, 0x6828, 0x7803, 0x0004, 0xa294,
+	0x0070, 0x000e, 0x20e0, 0x015e, 0x014e, 0x013e, 0x001e, 0x002e,
+	0x00de, 0x00fe, 0x0005, 0xa016, 0x080c, 0x185e, 0xa085, 0x0001,
+	0x0c80, 0x0006, 0x2001, 0x0111, 0x2004, 0xa084, 0x0003, 0x000e,
+	0x0005, 0x0046, 0x00e6, 0x00d6, 0x2028, 0x2130, 0xa696, 0x00ff,
+	0x1198, 0xa596, 0xfffd, 0x1120, 0x2009, 0x007f, 0x0804, 0x6703,
+	0xa596, 0xfffe, 0x1118, 0x2009, 0x007e, 0x04e8, 0xa596, 0xfffc,
+	0x1118, 0x2009, 0x0080, 0x04b8, 0x2011, 0x0000, 0x2019, 0xb535,
+	0x231c, 0xd3ac, 0x0138, 0x2021, 0x0000, 0x20a9, 0x00ff, 0x2071,
+	0xb635, 0x0030, 0x2021, 0x0081, 0x20a9, 0x007e, 0x2071, 0xb6b6,
+	0x2e1c, 0x83ff, 0x1128, 0x82ff, 0x1198, 0x2410, 0xc2fd, 0x0080,
+	0x2368, 0x6f10, 0x0006, 0x2100, 0xa706, 0x000e, 0x6b14, 0x1120,
+	0xa346, 0x1110, 0x2408, 0x0078, 0x87ff, 0x1110, 0x83ff, 0x0d58,
+	0x8420, 0x8e70, 0x1f04, 0x66e0, 0x82ff, 0x1118, 0xa085, 0x0001,
+	0x0018, 0xc2fc, 0x2208, 0xa006, 0x00de, 0x00ee, 0x004e, 0x0005,
+	0xa084, 0x0007, 0x000a, 0x0005, 0x6714, 0x6714, 0x6714, 0x6861,
+	0x6714, 0x6715, 0x672a, 0x679f, 0x0005, 0x7110, 0xd1bc, 0x0188,
+	0x7120, 0x2160, 0xac8c, 0x0007, 0x1160, 0xac8a, 0xbd00, 0x0248,
+	0x685c, 0xac02, 0x1230, 0x7124, 0x610a, 0x2009, 0x0046, 0x080c,
+	0x864c, 0x0005, 0x00c6, 0xa484, 0x01ff, 0x0904, 0x677d, 0x7110,
+	0xd1bc, 0x1904, 0x677d, 0x2011, 0xbb83, 0x2204, 0x8211, 0x220c,
+	0x080c, 0x281d, 0x1904, 0x677d, 0x080c, 0x4f4d, 0x15f0, 0x6612,
+	0x6516, 0x6000, 0xd0ec, 0x15c8, 0x6204, 0xa294, 0xff00, 0x8217,
+	0xa286, 0x0006, 0x0148, 0x6204, 0xa294, 0x00ff, 0xa286, 0x0006,
+	0x11a0, 0xa295, 0x0600, 0x6206, 0x00c6, 0x080c, 0x85c7, 0x001e,
+	0x0530, 0x611a, 0x601f, 0x0006, 0x7120, 0x610a, 0x7130, 0x6152,
+	0x2009, 0x0044, 0x080c, 0x864c, 0x00c0, 0x00c6, 0x080c, 0x85c7,
+	0x001e, 0x0198, 0x611a, 0x601f, 0x0004, 0x7120, 0x610a, 0xa286,
+	0x0004, 0x1118, 0x6007, 0x0005, 0x0010, 0x6007, 0x0001, 0x6003,
+	0x0001, 0x080c, 0x6cd3, 0x080c, 0x7173, 0x00ce, 0x0005, 0x2001,
+	0xb50d, 0x2004, 0xd0ec, 0x0120, 0x2011, 0x8049, 0x080c, 0x3ecc,
+	0x00c6, 0x080c, 0x9ed6, 0x001e, 0x0d80, 0x611a, 0x601f, 0x0006,
+	0x7120, 0x610a, 0x7130, 0x6152, 0x6013, 0x0300, 0x6003, 0x0001,
+	0x6007, 0x0041, 0x080c, 0x6c8d, 0x080c, 0x7173, 0x08f0, 0x7110,
+	0xd1bc, 0x0188, 0x7020, 0x2060, 0xac84, 0x0007, 0x1160, 0xac82,
+	0xbd00, 0x0248, 0x685c, 0xac02, 0x1230, 0x7124, 0x610a, 0x2009,
+	0x0045, 0x080c, 0x864c, 0x0005, 0x0006, 0x080c, 0x2dbf, 0x000e,
+	0x1168, 0x7110, 0xa18c, 0xff00, 0x810f, 0xa18e, 0x0000, 0x1130,
+	0xa084, 0x000f, 0xa08a, 0x0006, 0x1208, 0x000b, 0x0005, 0x67cd,
+	0x67ce, 0x67cd, 0x67cd, 0x6837, 0x6843, 0x0005, 0x7110, 0xd1bc,
+	0x0120, 0x702c, 0xd084, 0x0904, 0x6836, 0x700c, 0x7108, 0x080c,
+	0x281d, 0x1904, 0x6836, 0x080c, 0x4f4d, 0x1904, 0x6836, 0x6612,
+	0x6516, 0x6204, 0x7110, 0xd1bc, 0x01f8, 0xa28c, 0x00ff, 0xa186,
+	0x0004, 0x0118, 0xa186, 0x0006, 0x15c8, 0x00c6, 0x080c, 0x684f,
+	0x00ce, 0x0904, 0x6836, 0x00c6, 0x080c, 0x85c7, 0x001e, 0x05f0,
+	0x611a, 0x080c, 0xa027, 0x601f, 0x0002, 0x7120, 0x610a, 0x2009,
+	0x0088, 0x080c, 0x864c, 0x0490, 0xa28c, 0x00ff, 0xa186, 0x0006,
+	0x0160, 0xa186, 0x0004, 0x0148, 0xa294, 0xff00, 0x8217, 0xa286,
+	0x0004, 0x0118, 0xa286, 0x0006, 0x1188, 0x00c6, 0x080c, 0x85c7,
+	0x001e, 0x01e0, 0x611a, 0x080c, 0xa027, 0x601f, 0x0005, 0x7120,
+	0x610a, 0x2009, 0x0088, 0x080c, 0x864c, 0x0080, 0x00c6, 0x080c,
+	0x85c7, 0x001e, 0x0158, 0x611a, 0x080c, 0xa027, 0x601f, 0x0004,
+	0x7120, 0x610a, 0x2009, 0x0001, 0x080c, 0x864c, 0x0005, 0x7110,
+	0xd1bc, 0x0140, 0x00a1, 0x0130, 0x7124, 0x610a, 0x2009, 0x0089,
+	0x080c, 0x864c, 0x0005, 0x7110, 0xd1bc, 0x0140, 0x0041, 0x0130,
+	0x7124, 0x610a, 0x2009, 0x008a, 0x080c, 0x864c, 0x0005, 0x7020,
+	0x2060, 0xac84, 0x0007, 0x1158, 0xac82, 0xbd00, 0x0240, 0x2001,
+	0xb517, 0x2004, 0xac02, 0x1218, 0xa085, 0x0001, 0x0005, 0xa006,
+	0x0ce8, 0x7110, 0xd1bc, 0x1178, 0x7024, 0x2060, 0xac84, 0x0007,
+	0x1150, 0xac82, 0xbd00, 0x0238, 0x685c, 0xac02, 0x1220, 0x2009,
+	0x0051, 0x080c, 0x864c, 0x0005, 0x2031, 0x0105, 0x0069, 0x0005,
+	0x2031, 0x0206, 0x0049, 0x0005, 0x2031, 0x0207, 0x0029, 0x0005,
+	0x2031, 0x0213, 0x0009, 0x0005, 0x00c6, 0x00d6, 0x00f6, 0x7000,
+	0xa084, 0xf000, 0xa086, 0xc000, 0x05b0, 0x080c, 0x85c7, 0x0598,
+	0x0066, 0x00c6, 0x0046, 0x2011, 0xbb83, 0x2204, 0x8211, 0x220c,
+	0x080c, 0x281d, 0x1580, 0x080c, 0x4f4d, 0x1568, 0x6612, 0x6516,
+	0x2c00, 0x004e, 0x00ce, 0x601a, 0x080c, 0xa027, 0x080c, 0x15f8,
+	0x01f0, 0x2d00, 0x6056, 0x6803, 0x0000, 0x6837, 0x0000, 0x6c3a,
+	0xadf8, 0x000f, 0x20a9, 0x000e, 0x2fa0, 0x2e98, 0x53a3, 0x006e,
+	0x6612, 0x6007, 0x003e, 0x601f, 0x0001, 0x6003, 0x0001, 0x080c,
+	0x6cd3, 0x080c, 0x7173, 0x00fe, 0x00de, 0x00ce, 0x0005, 0x080c,
+	0x861d, 0x006e, 0x0cc0, 0x004e, 0x00ce, 0x0cc8, 0x2071, 0xb7f3,
+	0x7003, 0x0003, 0x700f, 0x0361, 0xa006, 0x701a, 0x7076, 0x7012,
+	0x7017, 0xbd00, 0x7007, 0x0000, 0x7026, 0x702b, 0x7d91, 0x7032,
+	0x7037, 0x7df1, 0x703b, 0xffff, 0x703f, 0xffff, 0x7042, 0x7047,
+	0x444b, 0x704a, 0x705b, 0x6a2b, 0x2001, 0xb7a1, 0x2003, 0x0003,
+	0x2001, 0xb7a3, 0x2003, 0x0100, 0x3a00, 0xa084, 0x0005, 0x706e,
+	0x0005, 0x2071, 0xb7f3, 0x1d04, 0x698b, 0x2091, 0x6000, 0x700c,
+	0x8001, 0x700e, 0x1518, 0x700f, 0x0361, 0x7007, 0x0001, 0x0126,
+	0x2091, 0x8000, 0x7040, 0xa00d, 0x0128, 0x8109, 0x7142, 0x1110,
+	0x7044, 0x080f, 0x00c6, 0x2061, 0xb500, 0x6034, 0x00ce, 0xd0cc,
+	0x0180, 0x3a00, 0xa084, 0x0005, 0x726c, 0xa216, 0x0150, 0x706e,
+	0x2011, 0x8043, 0x2018, 0x080c, 0x3ecc, 0x0018, 0x0126, 0x2091,
+	0x8000, 0x7024, 0xa00d, 0x0188, 0x7020, 0x8001, 0x7022, 0x1168,
+	0x7023, 0x0009, 0x8109, 0x7126, 0xa186, 0x03e8, 0x1110, 0x7028,
+	0x080f, 0x81ff, 0x1110, 0x7028, 0x080f, 0x7030, 0xa00d, 0x0180,
+	0x702c, 0x8001, 0x702e, 0x1160, 0x702f, 0x0009, 0x8109, 0x7132,
+	0x0128, 0xa184, 0x007f, 0x090c, 0x7e36, 0x0010, 0x7034, 0x080f,
+	0x7038, 0xa005, 0x0118, 0x0310, 0x8001, 0x703a, 0x703c, 0xa005,
+	0x0118, 0x0310, 0x8001, 0x703e, 0x704c, 0xa00d, 0x0168, 0x7048,
+	0x8001, 0x704a, 0x1148, 0x704b, 0x0009, 0x8109, 0x714e, 0x1120,
+	0x7150, 0x714e, 0x7058, 0x080f, 0x7018, 0xa00d, 0x01d8, 0x0016,
+	0x7074, 0xa00d, 0x0158, 0x7070, 0x8001, 0x7072, 0x1138, 0x7073,
+	0x0009, 0x8109, 0x7176, 0x1110, 0x7078, 0x080f, 0x001e, 0x7008,
+	0x8001, 0x700a, 0x1138, 0x700b, 0x0009, 0x8109, 0x711a, 0x1110,
+	0x701c, 0x080f, 0x012e, 0x7004, 0x0002, 0x69b1, 0x69b2, 0x69ca,
+	0x00e6, 0x2071, 0xb7f3, 0x7018, 0xa005, 0x1120, 0x711a, 0x721e,
+	0x700b, 0x0009, 0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0xb7f3,
+	0x701c, 0xa206, 0x1110, 0x701a, 0x701e, 0x000e, 0x00ee, 0x0005,
+	0x00e6, 0x2071, 0xb7f3, 0x6088, 0xa102, 0x0208, 0x618a, 0x00ee,
+	0x0005, 0x0005, 0x7110, 0x080c, 0x4fa9, 0x1158, 0x6088, 0x8001,
+	0x0240, 0x608a, 0x1130, 0x0126, 0x2091, 0x8000, 0x080c, 0x7173,
+	0x012e, 0x8108, 0xa182, 0x00ff, 0x0218, 0xa00e, 0x7007, 0x0002,
+	0x7112, 0x0005, 0x7014, 0x2060, 0x0126, 0x2091, 0x8000, 0x603c,
+	0xa005, 0x0128, 0x8001, 0x603e, 0x1110, 0x080c, 0x9f15, 0x6014,
+	0xa005, 0x0500, 0x8001, 0x6016, 0x11e8, 0x611c, 0xa186, 0x0003,
+	0x0118, 0xa186, 0x0006, 0x11a0, 0x6010, 0x2068, 0x6854, 0xa08a,
+	0x199a, 0x0270, 0xa082, 0x1999, 0x6856, 0xa08a, 0x199a, 0x0210,
+	0x2001, 0x1999, 0x8003, 0x800b, 0x810b, 0xa108, 0x6116, 0x0010,
+	0x080c, 0x99e5, 0x012e, 0xac88, 0x0018, 0x7116, 0x2001, 0xed00,
+	0xa102, 0x0220, 0x7017, 0xbd00, 0x7007, 0x0000, 0x0005, 0x00e6,
+	0x2071, 0xb7f3, 0x7027, 0x07d0, 0x7023, 0x0009, 0x00ee, 0x0005,
+	0x2001, 0xb7fc, 0x2003, 0x0000, 0x0005, 0x00e6, 0x2071, 0xb7f3,
+	0x7132, 0x702f, 0x0009, 0x00ee, 0x0005, 0x2011, 0xb7ff, 0x2013,
+	0x0000, 0x0005, 0x00e6, 0x2071, 0xb7f3, 0x711a, 0x721e, 0x700b,
+	0x0009, 0x00ee, 0x0005, 0x00c6, 0x0026, 0x7054, 0x8000, 0x7056,
+	0x2061, 0xb7a1, 0x6008, 0xa086, 0x0000, 0x0158, 0x7068, 0x6032,
+	0x7064, 0x602e, 0x7060, 0x602a, 0x705c, 0x6026, 0x2c10, 0x080c,
+	0x1643, 0x002e, 0x00ce, 0x0005, 0x0006, 0x0016, 0x00c6, 0x00d6,
+	0x00e6, 0x00f6, 0x080c, 0x68f9, 0x00fe, 0x00ee, 0x00de, 0x00ce,
+	0x001e, 0x000e, 0x0005, 0x00e6, 0x2071, 0xb7f3, 0x7176, 0x727a,
+	0x7073, 0x0009, 0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0xb7f3,
+	0x7078, 0xa206, 0x1110, 0x7076, 0x707a, 0x000e, 0x00ee, 0x0005,
+	0x00c6, 0x2061, 0xb874, 0x00ce, 0x0005, 0xa184, 0x000f, 0x8003,
+	0x8003, 0x8003, 0xa080, 0xb874, 0x2060, 0x0005, 0x6854, 0xa08a,
+	0x199a, 0x0210, 0x2001, 0x1999, 0xa005, 0x1150, 0x00c6, 0x2061,
+	0xb874, 0x6014, 0x00ce, 0xa005, 0x1138, 0x2001, 0x001e, 0x0020,
+	0xa08e, 0xffff, 0x1108, 0xa006, 0x8003, 0x800b, 0x810b, 0xa108,
+	0x6116, 0x684c, 0xa08c, 0x00c0, 0xa18e, 0x00c0, 0x05e8, 0xd0b4,
+	0x1138, 0xd0bc, 0x1550, 0x2009, 0x0006, 0x080c, 0x6af1, 0x0005,
+	0xd0fc, 0x0138, 0xa084, 0x0003, 0x0120, 0xa086, 0x0003, 0x1904,
+	0x6aeb, 0x6020, 0xd0d4, 0x0130, 0xc0d4, 0x6022, 0x6860, 0x602a,
+	0x685c, 0x602e, 0x2009, 0xb574, 0x2104, 0xd084, 0x0138, 0x87ff,
+	0x1120, 0x2009, 0x0042, 0x080c, 0x864c, 0x0005, 0x87ff, 0x1120,
+	0x2009, 0x0043, 0x080c, 0x864c, 0x0005, 0xd0fc, 0x0130, 0xa084,
+	0x0003, 0x0118, 0xa086, 0x0003, 0x11f0, 0x87ff, 0x1120, 0x2009,
+	0x0042, 0x080c, 0x864c, 0x0005, 0xd0fc, 0x0160, 0xa084, 0x0003,
+	0xa08e, 0x0002, 0x0148, 0x87ff, 0x1120, 0x2009, 0x0041, 0x080c,
+	0x864c, 0x0005, 0x0061, 0x0ce8, 0x87ff, 0x1dd8, 0x2009, 0x0043,
+	0x080c, 0x864c, 0x0cb0, 0x2009, 0x0004, 0x0019, 0x0005, 0x2009,
+	0x0001, 0x00d6, 0x6010, 0xa0ec, 0xf000, 0x0510, 0x2068, 0x6952,
+	0x6800, 0x6012, 0xa186, 0x0001, 0x1188, 0x694c, 0xa18c, 0x8100,
+	0xa18e, 0x8100, 0x1158, 0x00c6, 0x2061, 0xb874, 0x6200, 0xd28c,
+	0x1120, 0x6204, 0x8210, 0x0208, 0x6206, 0x00ce, 0x080c, 0x5408,
+	0x6010, 0xa06d, 0x0076, 0x2039, 0x0000, 0x190c, 0x6a76, 0x007e,
+	0x00de, 0x0005, 0x0156, 0x00c6, 0x2061, 0xb874, 0x6000, 0x81ff,
+	0x0110, 0xa205, 0x0008, 0xa204, 0x6002, 0x00ce, 0x015e, 0x0005,
+	0x6800, 0xd08c, 0x1138, 0x6808, 0xa005, 0x0120, 0x8001, 0x680a,
+	0xa085, 0x0001, 0x0005, 0x20a9, 0x0010, 0xa006, 0x8004, 0x8086,
+	0x818e, 0x1208, 0xa200, 0x1f04, 0x6b37, 0x8086, 0x818e, 0x0005,
+	0x0156, 0x20a9, 0x0010, 0xa005, 0x01b8, 0xa11a, 0x12a8, 0x8213,
+	0x818d, 0x0228, 0xa11a, 0x1220, 0x1f04, 0x6b47, 0x0028, 0xa11a,
+	0x2308, 0x8210, 0x1f04, 0x6b47, 0x0006, 0x3200, 0xa084, 0xefff,
+	0x2080, 0x000e, 0x015e, 0x0005, 0x0006, 0x3200, 0xa085, 0x1000,
+	0x0cb8, 0x0126, 0x2091, 0x2800, 0x2079, 0xb7e0, 0x012e, 0x00d6,
+	0x2069, 0xb7e0, 0x6803, 0x0005, 0x2069, 0x0004, 0x2d04, 0xa085,
+	0x8001, 0x206a, 0x00de, 0x0005, 0x00c6, 0x6027, 0x0001, 0x7804,
+	0xa084, 0x0007, 0x0002, 0x6b85, 0x6ba6, 0x6bf9, 0x6b8b, 0x6ba6,
+	0x6b85, 0x6b83, 0x6b83, 0x080c, 0x1515, 0x080c, 0x6a10, 0x080c,
+	0x7173, 0x00ce, 0x0005, 0x62c0, 0x82ff, 0x1110, 0x00ce, 0x0005,
+	0x2011, 0x4adc, 0x080c, 0x699c, 0x7828, 0xa092, 0x00c8, 0x1228,
+	0x8000, 0x782a, 0x080c, 0x4b16, 0x0c88, 0x080c, 0x4adc, 0x7807,
+	0x0003, 0x7827, 0x0000, 0x782b, 0x0000, 0x0c40, 0x080c, 0x6a10,
+	0x3c00, 0x0006, 0x2011, 0x0209, 0x20e1, 0x4000, 0x2214, 0x000e,
+	0x20e0, 0x82ff, 0x0178, 0x62c0, 0x82ff, 0x1160, 0x782b, 0x0000,
+	0x7824, 0xa065, 0x090c, 0x1515, 0x2009, 0x0013, 0x080c, 0x864c,
+	0x00ce, 0x0005, 0x3900, 0xa082, 0xb92c, 0x1210, 0x080c, 0x8332,
+	0x00c6, 0x7824, 0xa065, 0x090c, 0x1515, 0x7804, 0xa086, 0x0004,
+	0x0904, 0x6c39, 0x7828, 0xa092, 0x2710, 0x1230, 0x8000, 0x782a,
+	0x00ce, 0x080c, 0x7d6d, 0x0c20, 0x6104, 0xa186, 0x0003, 0x1188,
+	0x00e6, 0x2071, 0xb500, 0x70e0, 0x00ee, 0xd08c, 0x0150, 0x00c6,
+	0x00e6, 0x2061, 0x0100, 0x2071, 0xb500, 0x080c, 0x4b1f, 0x00ee,
+	0x00ce, 0x080c, 0xb444, 0x2009, 0x0014, 0x080c, 0x864c, 0x00ce,
+	0x0838, 0x2001, 0xb7fc, 0x2003, 0x0000, 0x62c0, 0x82ff, 0x1160,
+	0x782b, 0x0000, 0x7824, 0xa065, 0x090c, 0x1515, 0x2009, 0x0013,
+	0x080c, 0x86a0, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x3900, 0xa082,
+	0xb92c, 0x1210, 0x080c, 0x8332, 0x7824, 0xa005, 0x090c, 0x1515,
+	0x781c, 0xa06d, 0x090c, 0x1515, 0x6800, 0xc0dc, 0x6802, 0x7924,
+	0x2160, 0x080c, 0x861d, 0x693c, 0x81ff, 0x090c, 0x1515, 0x8109,
+	0x693e, 0x6854, 0xa015, 0x0110, 0x7a1e, 0x0010, 0x7918, 0x791e,
+	0x7807, 0x0000, 0x7827, 0x0000, 0x00de, 0x00ce, 0x080c, 0x7173,
+	0x0888, 0x6104, 0xa186, 0x0002, 0x0128, 0xa186, 0x0004, 0x0110,
+	0x0804, 0x6bd2, 0x7808, 0xac06, 0x0904, 0x6bd2, 0x080c, 0x7090,
+	0x080c, 0x6cd3, 0x00ce, 0x080c, 0x7173, 0x0804, 0x6bc0, 0x00c6,
+	0x6027, 0x0002, 0x62c8, 0x60c4, 0xa205, 0x1178, 0x793c, 0xa1e5,
+	0x0000, 0x0130, 0x2009, 0x0049, 0x080c, 0x864c, 0x00ce, 0x0005,
+	0x2011, 0xb7ff, 0x2013, 0x0000, 0x0cc8, 0x3908, 0xa192, 0xb92c,
+	0x1210, 0x080c, 0x8332, 0x793c, 0x81ff, 0x0d90, 0x7944, 0xa192,
+	0x7530, 0x12b8, 0x8108, 0x7946, 0x793c, 0xa188, 0x0007, 0x210c,
+	0xa18e, 0x0006, 0x1138, 0x6014, 0xa084, 0x0184, 0xa085, 0x0012,
+	0x6016, 0x08e0, 0x6014, 0xa084, 0x0184, 0xa085, 0x0016, 0x6016,
+	0x08a8, 0x7848, 0xc085, 0x784a, 0x0888, 0x0006, 0x0016, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0x600f, 0x0000, 0x2c08, 0x2061, 0xb7e0,
+	0x6020, 0x8000, 0x6022, 0x6010, 0xa005, 0x0148, 0xa080, 0x0003,
+	0x2102, 0x6112, 0x012e, 0x00ce, 0x001e, 0x000e, 0x0005, 0x6116,
+	0x6112, 0x0cc0, 0x00d6, 0x2069, 0xb7e0, 0x6000, 0xd0d4, 0x0168,
+	0x6820, 0x8000, 0x6822, 0xa086, 0x0001, 0x1110, 0x2c00, 0x681e,
+	0x6804, 0xa084, 0x0007, 0x0804, 0x7179, 0xc0d5, 0x6002, 0x6818,
+	0xa005, 0x0158, 0x6056, 0x605b, 0x0000, 0x0006, 0x2c00, 0x681a,
+	0x00de, 0x685a, 0x2069, 0xb7e0, 0x0c18, 0x6056, 0x605a, 0x2c00,
+	0x681a, 0x681e, 0x08e8, 0x0006, 0x0016, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x600f, 0x0000, 0x2c08, 0x2061, 0xb7e0, 0x6020, 0x8000,
+	0x6022, 0x6008, 0xa005, 0x0148, 0xa080, 0x0003, 0x2102, 0x610a,
+	0x012e, 0x00ce, 0x001e, 0x000e, 0x0005, 0x610e, 0x610a, 0x0cc0,
+	0x00c6, 0x600f, 0x0000, 0x2c08, 0x2061, 0xb7e0, 0x6034, 0xa005,
+	0x0130, 0xa080, 0x0003, 0x2102, 0x6136, 0x00ce, 0x0005, 0x613a,
+	0x6136, 0x0cd8, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0076, 0x0066,
+	0x0056, 0x0036, 0x0026, 0x0016, 0x0006, 0x0126, 0xa02e, 0x2071,
+	0xb7e0, 0x7638, 0x2660, 0x2678, 0x2091, 0x8000, 0x8cff, 0x0904,
+	0x6d7b, 0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x1904, 0x6d76,
+	0x87ff, 0x0120, 0x6050, 0xa106, 0x1904, 0x6d76, 0x703c, 0xac06,
+	0x1190, 0x0036, 0x2019, 0x0001, 0x080c, 0x7fe4, 0x7033, 0x0000,
+	0x703f, 0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x704b, 0x0000,
+	0x003e, 0x2029, 0x0001, 0x7038, 0xac36, 0x1110, 0x660c, 0x763a,
+	0x7034, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118, 0x2f00, 0x7036,
+	0x0010, 0x7037, 0x0000, 0x660c, 0x0066, 0x2c00, 0xaf06, 0x0110,
+	0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x080c, 0x9c5a, 0x01c8,
+	0x6010, 0x2068, 0x601c, 0xa086, 0x0003, 0x1580, 0x6837, 0x0103,
+	0x6b4a, 0x6847, 0x0000, 0x0016, 0x0036, 0x0076, 0x080c, 0x9ecc,
+	0x080c, 0xb380, 0x080c, 0x5408, 0x007e, 0x003e, 0x001e, 0x080c,
+	0x9e11, 0x080c, 0x9e1d, 0x00ce, 0x0804, 0x6d16, 0x2c78, 0x600c,
+	0x2060, 0x0804, 0x6d16, 0x85ff, 0x0120, 0x0036, 0x080c, 0x7230,
+	0x003e, 0x012e, 0x000e, 0x001e, 0x002e, 0x003e, 0x005e, 0x006e,
+	0x007e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x601c, 0xa086,
+	0x0006, 0x1158, 0x0016, 0x0036, 0x0076, 0x080c, 0xb380, 0x080c,
+	0xb099, 0x007e, 0x003e, 0x001e, 0x08a0, 0x601c, 0xa086, 0x000a,
+	0x0904, 0x6d60, 0x0804, 0x6d5e, 0x0006, 0x0066, 0x00c6, 0x00d6,
+	0x00f6, 0x2031, 0x0000, 0x0126, 0x2091, 0x8000, 0x2079, 0xb7e0,
+	0x7838, 0xa065, 0x0568, 0x600c, 0x0006, 0x600f, 0x0000, 0x783c,
+	0xac06, 0x1180, 0x0036, 0x2019, 0x0001, 0x080c, 0x7fe4, 0x7833,
+	0x0000, 0x783f, 0x0000, 0x7843, 0x0000, 0x7847, 0x0000, 0x784b,
+	0x0000, 0x003e, 0x080c, 0x9c5a, 0x0178, 0x6010, 0x2068, 0x601c,
+	0xa086, 0x0003, 0x11b0, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000,
+	0x080c, 0x5408, 0x080c, 0x9e11, 0x080c, 0x9e1d, 0x000e, 0x0888,
+	0x7e3a, 0x7e36, 0x012e, 0x00fe, 0x00de, 0x00ce, 0x006e, 0x000e,
+	0x0005, 0x601c, 0xa086, 0x0006, 0x1118, 0x080c, 0xb099, 0x0c60,
+	0x601c, 0xa086, 0x000a, 0x0d08, 0x08f0, 0x0016, 0x0026, 0x0086,
+	0x2041, 0x0000, 0x0099, 0x080c, 0x6ec3, 0x008e, 0x002e, 0x001e,
+	0x0005, 0x00f6, 0x0126, 0x2079, 0xb7e0, 0x2091, 0x8000, 0x080c,
+	0x6f50, 0x080c, 0x6fc2, 0x012e, 0x00fe, 0x0005, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0066, 0x0016, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb7e0, 0x7614, 0x2660, 0x2678, 0x8cff, 0x0904, 0x6e99,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x1904, 0x6e94, 0x88ff,
+	0x0120, 0x6050, 0xa106, 0x1904, 0x6e94, 0x7024, 0xac06, 0x1538,
+	0x2069, 0x0100, 0x68c0, 0xa005, 0x01f0, 0x080c, 0x6a10, 0x080c,
+	0x7d7a, 0x68c3, 0x0000, 0x080c, 0x824d, 0x7027, 0x0000, 0x0036,
+	0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827,
+	0x0001, 0x003e, 0x0020, 0x6003, 0x0009, 0x630a, 0x04e8, 0x7014,
+	0xac36, 0x1110, 0x660c, 0x7616, 0x7010, 0xac36, 0x1140, 0x2c00,
+	0xaf36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000, 0x660c,
+	0x0066, 0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f,
+	0x0000, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x01b8, 0x601c, 0xa086,
+	0x0003, 0x1540, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x0016,
+	0x0036, 0x0086, 0x080c, 0x9ecc, 0x080c, 0xb380, 0x080c, 0x5408,
+	0x008e, 0x003e, 0x001e, 0x080c, 0x9e11, 0x080c, 0x9e1d, 0x080c,
+	0x811e, 0x00ce, 0x0804, 0x6e1d, 0x2c78, 0x600c, 0x2060, 0x0804,
+	0x6e1d, 0x012e, 0x000e, 0x001e, 0x006e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x0005, 0x601c, 0xa086, 0x0006, 0x1158, 0x0016, 0x0036,
+	0x0086, 0x080c, 0xb380, 0x080c, 0xb099, 0x008e, 0x003e, 0x001e,
+	0x08e0, 0x601c, 0xa086, 0x0002, 0x1128, 0x6004, 0xa086, 0x0085,
+	0x0908, 0x0898, 0x601c, 0xa086, 0x0005, 0x1978, 0x6004, 0xa086,
+	0x0085, 0x0d20, 0x0850, 0x00c6, 0x0006, 0x0126, 0x2091, 0x8000,
+	0xa280, 0xb635, 0x2004, 0xa065, 0x0904, 0x6f4c, 0x00f6, 0x00e6,
+	0x00d6, 0x0066, 0x2071, 0xb7e0, 0x6654, 0x7018, 0xac06, 0x1108,
+	0x761a, 0x701c, 0xac06, 0x1130, 0x86ff, 0x1118, 0x7018, 0x701e,
+	0x0008, 0x761e, 0x6058, 0xa07d, 0x0108, 0x7e56, 0xa6ed, 0x0000,
+	0x0110, 0x2f00, 0x685a, 0x6057, 0x0000, 0x605b, 0x0000, 0x6000,
+	0xc0d4, 0xc0dc, 0x6002, 0x080c, 0x4ed4, 0x0904, 0x6f48, 0x7624,
+	0x86ff, 0x05e8, 0xa680, 0x0004, 0x2004, 0xad06, 0x15c0, 0x00d6,
+	0x2069, 0x0100, 0x68c0, 0xa005, 0x0548, 0x080c, 0x6a10, 0x080c,
+	0x7d7a, 0x68c3, 0x0000, 0x080c, 0x824d, 0x7027, 0x0000, 0x0036,
+	0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803, 0x0100,
+	0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827,
+	0x0001, 0x003e, 0x00de, 0x00c6, 0x603c, 0xa005, 0x0110, 0x8001,
+	0x603e, 0x2660, 0x080c, 0x9e1d, 0x00ce, 0x0048, 0x00de, 0x00c6,
+	0x2660, 0x6003, 0x0009, 0x630a, 0x00ce, 0x0804, 0x6ef3, 0x8dff,
+	0x0158, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c, 0x9ecc,
+	0x080c, 0xb380, 0x080c, 0x5408, 0x080c, 0x811e, 0x0804, 0x6ef3,
+	0x006e, 0x00de, 0x00ee, 0x00fe, 0x012e, 0x000e, 0x00ce, 0x0005,
+	0x0006, 0x0066, 0x00c6, 0x00d6, 0x2031, 0x0000, 0x7814, 0xa065,
+	0x0904, 0x6fa2, 0x600c, 0x0006, 0x600f, 0x0000, 0x7824, 0xac06,
+	0x1540, 0x2069, 0x0100, 0x68c0, 0xa005, 0x01f0, 0x080c, 0x6a10,
+	0x080c, 0x7d7a, 0x68c3, 0x0000, 0x080c, 0x824d, 0x7827, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803,
+	0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110,
+	0x6827, 0x0001, 0x003e, 0x0028, 0x6003, 0x0009, 0x630a, 0x2c30,
+	0x00b0, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0168, 0x601c, 0xa086,
+	0x0003, 0x11b8, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c,
+	0x5408, 0x080c, 0x9e11, 0x080c, 0x9e1d, 0x080c, 0x811e, 0x000e,
+	0x0804, 0x6f57, 0x7e16, 0x7e12, 0x00de, 0x00ce, 0x006e, 0x000e,
+	0x0005, 0x601c, 0xa086, 0x0006, 0x1118, 0x080c, 0xb099, 0x0c58,
+	0x601c, 0xa086, 0x0002, 0x1128, 0x6004, 0xa086, 0x0085, 0x09d0,
+	0x0c10, 0x601c, 0xa086, 0x0005, 0x19f0, 0x6004, 0xa086, 0x0085,
+	0x0d60, 0x08c8, 0x0006, 0x0066, 0x00c6, 0x00d6, 0x7818, 0xa065,
+	0x0904, 0x7028, 0x6054, 0x0006, 0x6057, 0x0000, 0x605b, 0x0000,
+	0x6000, 0xc0d4, 0xc0dc, 0x6002, 0x080c, 0x4ed4, 0x0904, 0x7025,
+	0x7e24, 0x86ff, 0x05e8, 0xa680, 0x0004, 0x2004, 0xad06, 0x15c0,
+	0x00d6, 0x2069, 0x0100, 0x68c0, 0xa005, 0x0548, 0x080c, 0x6a10,
+	0x080c, 0x7d7a, 0x68c3, 0x0000, 0x080c, 0x824d, 0x7827, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000, 0x0120, 0x6803,
+	0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110,
+	0x6827, 0x0001, 0x003e, 0x00de, 0x00c6, 0x603c, 0xa005, 0x0110,
+	0x8001, 0x603e, 0x2660, 0x080c, 0x9e1d, 0x00ce, 0x0048, 0x00de,
+	0x00c6, 0x2660, 0x6003, 0x0009, 0x630a, 0x00ce, 0x0804, 0x6fd4,
+	0x8dff, 0x0138, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c,
+	0x5408, 0x080c, 0x811e, 0x0804, 0x6fd4, 0x000e, 0x0804, 0x6fc7,
+	0x781e, 0x781a, 0x00de, 0x00ce, 0x006e, 0x000e, 0x0005, 0x00e6,
+	0x00d6, 0x0066, 0x6000, 0xd0dc, 0x01a0, 0x604c, 0xa06d, 0x0188,
+	0x6848, 0xa606, 0x1170, 0x2071, 0xb7e0, 0x7024, 0xa035, 0x0148,
+	0xa080, 0x0004, 0x2004, 0xad06, 0x1120, 0x6000, 0xc0dc, 0x6002,
+	0x0021, 0x006e, 0x00de, 0x00ee, 0x0005, 0x00f6, 0x2079, 0x0100,
+	0x78c0, 0xa005, 0x1138, 0x00c6, 0x2660, 0x6003, 0x0009, 0x630a,
+	0x00ce, 0x04a0, 0x080c, 0x7d7a, 0x78c3, 0x0000, 0x080c, 0x824d,
+	0x7027, 0x0000, 0x0036, 0x2079, 0x0140, 0x7b04, 0xa384, 0x1000,
+	0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x2079, 0x0100, 0x7824,
+	0xd084, 0x0110, 0x7827, 0x0001, 0x080c, 0x824d, 0x003e, 0x080c,
+	0x4ed4, 0x00c6, 0x603c, 0xa005, 0x0110, 0x8001, 0x603e, 0x2660,
+	0x080c, 0x861d, 0x00ce, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000,
+	0x080c, 0x9ecc, 0x080c, 0x5408, 0x080c, 0x811e, 0x00fe, 0x0005,
+	0x00e6, 0x00c6, 0x2071, 0xb7e0, 0x7004, 0xa084, 0x0007, 0x0002,
+	0x70a2, 0x70a5, 0x70bb, 0x70d4, 0x7111, 0x70a2, 0x70a0, 0x70a0,
+	0x080c, 0x1515, 0x00ce, 0x00ee, 0x0005, 0x7024, 0xa065, 0x0148,
+	0x7020, 0x8001, 0x7022, 0x600c, 0xa015, 0x0150, 0x7216, 0x600f,
+	0x0000, 0x7007, 0x0000, 0x7027, 0x0000, 0x00ce, 0x00ee, 0x0005,
+	0x7216, 0x7212, 0x0cb0, 0x6018, 0x2060, 0x080c, 0x4ed4, 0x6000,
+	0xc0dc, 0x6002, 0x7020, 0x8001, 0x7022, 0x0120, 0x6054, 0xa015,
+	0x0140, 0x721e, 0x7007, 0x0000, 0x7027, 0x0000, 0x00ce, 0x00ee,
+	0x0005, 0x7218, 0x721e, 0x0cb0, 0x7024, 0xa065, 0x05b8, 0x700c,
+	0xac06, 0x1160, 0x080c, 0x811e, 0x600c, 0xa015, 0x0120, 0x720e,
+	0x600f, 0x0000, 0x0448, 0x720e, 0x720a, 0x0430, 0x7014, 0xac06,
+	0x1160, 0x080c, 0x811e, 0x600c, 0xa015, 0x0120, 0x7216, 0x600f,
+	0x0000, 0x00d0, 0x7216, 0x7212, 0x00b8, 0x601c, 0xa086, 0x0003,
+	0x1198, 0x6018, 0x2060, 0x080c, 0x4ed4, 0x6000, 0xc0dc, 0x6002,
+	0x080c, 0x811e, 0x701c, 0xa065, 0x0138, 0x6054, 0xa015, 0x0110,
+	0x721e, 0x0010, 0x7218, 0x721e, 0x7027, 0x0000, 0x00ce, 0x00ee,
+	0x0005, 0x7024, 0xa065, 0x0140, 0x080c, 0x811e, 0x600c, 0xa015,
+	0x0150, 0x720e, 0x600f, 0x0000, 0x080c, 0x824d, 0x7027, 0x0000,
+	0x00ce, 0x00ee, 0x0005, 0x720e, 0x720a, 0x0cb0, 0x00d6, 0x2069,
+	0xb7e0, 0x6830, 0xa084, 0x0003, 0x0002, 0x7133, 0x7135, 0x7159,
+	0x7131, 0x080c, 0x1515, 0x00de, 0x0005, 0x00c6, 0x6840, 0xa086,
+	0x0001, 0x01b8, 0x683c, 0xa065, 0x0130, 0x600c, 0xa015, 0x0170,
+	0x6a3a, 0x600f, 0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x2011,
+	0xb7ff, 0x2013, 0x0000, 0x00ce, 0x00de, 0x0005, 0x683a, 0x6836,
+	0x0c90, 0x6843, 0x0000, 0x6838, 0xa065, 0x0d68, 0x6003, 0x0003,
+	0x0c50, 0x00c6, 0x6843, 0x0000, 0x6847, 0x0000, 0x684b, 0x0000,
+	0x683c, 0xa065, 0x0168, 0x600c, 0xa015, 0x0130, 0x6a3a, 0x600f,
+	0x0000, 0x683f, 0x0000, 0x0020, 0x683f, 0x0000, 0x683a, 0x6836,
+	0x00ce, 0x00de, 0x0005, 0x00d6, 0x2069, 0xb7e0, 0x6804, 0xa084,
+	0x0007, 0x0002, 0x7184, 0x7220, 0x7220, 0x7220, 0x7220, 0x7222,
+	0x7182, 0x7182, 0x080c, 0x1515, 0x6820, 0xa005, 0x1110, 0x00de,
+	0x0005, 0x00c6, 0x680c, 0xa065, 0x0150, 0x6807, 0x0004, 0x6826,
+	0x682b, 0x0000, 0x080c, 0x7272, 0x00ce, 0x00de, 0x0005, 0x6814,
+	0xa065, 0x0150, 0x6807, 0x0001, 0x6826, 0x682b, 0x0000, 0x080c,
+	0x7272, 0x00ce, 0x00de, 0x0005, 0x00e6, 0x0036, 0x6a1c, 0xa2f5,
+	0x0000, 0x0904, 0x721c, 0x704c, 0xa00d, 0x0118, 0x7088, 0xa005,
+	0x01a0, 0x7054, 0xa075, 0x0120, 0xa20e, 0x0904, 0x721c, 0x0028,
+	0x6818, 0xa20e, 0x0904, 0x721c, 0x2070, 0x704c, 0xa00d, 0x0d88,
+	0x7088, 0xa005, 0x1d70, 0x2e00, 0x681e, 0x733c, 0x7038, 0xa302,
+	0x1e40, 0x080c, 0x85f4, 0x0904, 0x721c, 0x8318, 0x733e, 0x6112,
+	0x2e10, 0x621a, 0xa180, 0x0014, 0x2004, 0xa084, 0x00ff, 0x605a,
+	0xa180, 0x0014, 0x2003, 0x0000, 0xa180, 0x0015, 0x2004, 0xa08a,
+	0x199a, 0x0210, 0x2001, 0x1999, 0x8003, 0x801b, 0x831b, 0xa318,
+	0x6316, 0x003e, 0x00f6, 0x2c78, 0x71a0, 0x2001, 0xb535, 0x2004,
+	0xd0ac, 0x1110, 0xd1bc, 0x0150, 0x7100, 0xd1f4, 0x0120, 0x7114,
+	0xa18c, 0x00ff, 0x0040, 0x2009, 0x0000, 0x0028, 0xa1e0, 0x2dc4,
+	0x2c0d, 0xa18c, 0x00ff, 0x2061, 0x0100, 0x619a, 0x080c, 0x78a2,
+	0x7300, 0xc3dd, 0x7302, 0x6807, 0x0002, 0x2f18, 0x6b26, 0x682b,
+	0x0000, 0x781f, 0x0003, 0x7803, 0x0001, 0x7807, 0x0040, 0x00fe,
+	0x00ee, 0x00ce, 0x00de, 0x0005, 0x003e, 0x00ee, 0x00ce, 0x0cd0,
+	0x00de, 0x0005, 0x00c6, 0x680c, 0xa065, 0x0138, 0x6807, 0x0004,
+	0x6826, 0x682b, 0x0000, 0x080c, 0x7272, 0x00ce, 0x00de, 0x0005,
+	0x00f6, 0x00d6, 0x2069, 0xb7e0, 0x6830, 0xa086, 0x0000, 0x11d0,
+	0x2001, 0xb50c, 0x200c, 0xd1bc, 0x1560, 0x6838, 0xa07d, 0x0190,
+	0x6833, 0x0001, 0x683e, 0x6847, 0x0000, 0x684b, 0x0000, 0x0126,
+	0x00f6, 0x2091, 0x2400, 0x002e, 0x080c, 0x2021, 0x1130, 0x012e,
+	0x080c, 0x7beb, 0x00de, 0x00fe, 0x0005, 0x012e, 0xe000, 0x6843,
+	0x0000, 0x7803, 0x0002, 0x780c, 0xa015, 0x0140, 0x6a3a, 0x780f,
+	0x0000, 0x6833, 0x0000, 0x683f, 0x0000, 0x0c60, 0x683a, 0x6836,
+	0x0cc0, 0xc1bc, 0x2102, 0x0066, 0x2031, 0x0001, 0x080c, 0x5b51,
+	0x006e, 0x0858, 0x601c, 0xa084, 0x000f, 0x000b, 0x0005, 0x7280,
+	0x7285, 0x7743, 0x785f, 0x7285, 0x7743, 0x785f, 0x7280, 0x7285,
+	0x080c, 0x7090, 0x080c, 0x7173, 0x0005, 0x0156, 0x0136, 0x0146,
+	0x00c6, 0x00f6, 0x6004, 0xa08a, 0x0080, 0x1a0c, 0x1515, 0x6118,
+	0x2178, 0x79a0, 0x2011, 0xb535, 0x2214, 0xd2ac, 0x1110, 0xd1bc,
+	0x0150, 0x7900, 0xd1f4, 0x0120, 0x7914, 0xa18c, 0x00ff, 0x0040,
+	0x2009, 0x0000, 0x0028, 0xa1f8, 0x2dc4, 0x2f0d, 0xa18c, 0x00ff,
+	0x2c78, 0x2061, 0x0100, 0x619a, 0xa08a, 0x0040, 0x1a04, 0x72f9,
+	0x0033, 0x00fe, 0x00ce, 0x014e, 0x013e, 0x015e, 0x0005, 0x73a8,
+	0x73f3, 0x7420, 0x74ed, 0x751b, 0x7523, 0x7549, 0x755a, 0x756b,
+	0x7573, 0x7589, 0x7573, 0x75ea, 0x755a, 0x760b, 0x7613, 0x756b,
+	0x7613, 0x7624, 0x72f7, 0x72f7, 0x72f7, 0x72f7, 0x72f7, 0x72f7,
+	0x72f7, 0x72f7, 0x72f7, 0x72f7, 0x72f7, 0x7e85, 0x7eaa, 0x7ebf,
+	0x7ee2, 0x7f03, 0x7549, 0x72f7, 0x7549, 0x7573, 0x72f7, 0x7420,
+	0x74ed, 0x72f7, 0x834f, 0x7573, 0x72f7, 0x836f, 0x7573, 0x72f7,
+	0x756b, 0x73a1, 0x730c, 0x72f7, 0x8394, 0x8409, 0x84e0, 0x72f7,
+	0x84f1, 0x7544, 0x850d, 0x72f7, 0x7f18, 0x8568, 0x72f7, 0x080c,
+	0x1515, 0x2100, 0x0033, 0x00fe, 0x00ce, 0x014e, 0x013e, 0x015e,
+	0x0005, 0x730a, 0x730a, 0x730a, 0x7340, 0x735e, 0x7374, 0x730a,
+	0x730a, 0x730a, 0x080c, 0x1515, 0x00d6, 0x20a1, 0x020b, 0x080c,
+	0x7641, 0x7810, 0x2068, 0x20a3, 0x2414, 0x20a3, 0x0018, 0x20a3,
+	0x0800, 0x683c, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x6850, 0x20a2, 0x6854, 0x20a2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x080c, 0x7d67, 0x00de,
+	0x0005, 0x00d6, 0x7818, 0x2068, 0x68a0, 0x2069, 0xb500, 0x6ad4,
+	0xd2ac, 0x1110, 0xd0bc, 0x0110, 0xa085, 0x0001, 0x00de, 0x0005,
+	0x00d6, 0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3, 0x0500, 0x20a3,
+	0x0000, 0x7810, 0xa0e8, 0x000f, 0x6808, 0x20a2, 0x680c, 0x20a2,
+	0x6810, 0x20a2, 0x6814, 0x20a2, 0x6818, 0x20a2, 0x681c, 0x20a2,
+	0x60c3, 0x0010, 0x080c, 0x7d67, 0x00de, 0x0005, 0x0156, 0x0146,
+	0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3, 0x7800, 0x20a3, 0x0000,
+	0x7808, 0x8007, 0x20a2, 0x20a3, 0x0000, 0x60c3, 0x0008, 0x080c,
+	0x7d67, 0x014e, 0x015e, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b,
+	0x080c, 0x76dd, 0x20a3, 0x0200, 0x20a3, 0x0000, 0x20a3, 0xdf10,
+	0x20a3, 0x0034, 0x2099, 0xb505, 0x20a9, 0x0004, 0x53a6, 0x2099,
+	0xb501, 0x20a9, 0x0004, 0x53a6, 0x2099, 0xb7c6, 0x20a9, 0x001a,
+	0x3304, 0x8007, 0x20a2, 0x9398, 0x1f04, 0x7390, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x60c3, 0x004c, 0x080c, 0x7d67, 0x014e, 0x015e,
+	0x0005, 0x2001, 0xb515, 0x2004, 0x609a, 0x080c, 0x7d67, 0x0005,
+	0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3, 0x5200, 0x20a3, 0x0000,
+	0x00d6, 0x2069, 0xb552, 0x6804, 0xd084, 0x0150, 0x6828, 0x20a3,
+	0x0000, 0x0016, 0x080c, 0x2831, 0x21a2, 0x001e, 0x00de, 0x0028,
+	0x00de, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004, 0x2099,
+	0xb505, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xb501, 0x53a6, 0x2001,
+	0xb535, 0x2004, 0xd0ac, 0x1138, 0x7818, 0xa080, 0x0028, 0x2004,
+	0xa082, 0x007f, 0x0238, 0x2001, 0xb51c, 0x20a6, 0x2001, 0xb51d,
+	0x20a6, 0x0040, 0x20a3, 0x0000, 0x2001, 0xb515, 0x2004, 0xa084,
+	0x00ff, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c,
+	0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3,
+	0x0500, 0x20a3, 0x0000, 0x2001, 0xb535, 0x2004, 0xd0ac, 0x1138,
+	0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007f, 0x0238, 0x2001,
+	0xb51c, 0x20a6, 0x2001, 0xb51d, 0x20a6, 0x0040, 0x20a3, 0x0000,
+	0x2001, 0xb515, 0x2004, 0xa084, 0x00ff, 0x20a2, 0x20a9, 0x0004,
+	0x2099, 0xb505, 0x53a6, 0x60c3, 0x0010, 0x080c, 0x7d67, 0x0005,
+	0x20a1, 0x020b, 0x080c, 0x7641, 0x00c6, 0x7818, 0x2060, 0x2001,
+	0x0000, 0x080c, 0x5313, 0x00ce, 0x7818, 0xa080, 0x0028, 0x2004,
+	0xa086, 0x007e, 0x1130, 0x20a3, 0x0400, 0x620c, 0xc2b4, 0x620e,
+	0x0010, 0x20a3, 0x0300, 0x20a3, 0x0000, 0x7818, 0xa080, 0x0028,
+	0x2004, 0xa086, 0x007e, 0x1904, 0x74af, 0x2001, 0xb535, 0x2004,
+	0xd0a4, 0x01c8, 0x2099, 0xb78e, 0x33a6, 0x9398, 0x20a3, 0x0000,
+	0x9398, 0x3304, 0xa084, 0x2000, 0x20a2, 0x9398, 0x33a6, 0x9398,
+	0x20a3, 0x0000, 0x9398, 0x2001, 0x2710, 0x20a2, 0x9398, 0x33a6,
+	0x9398, 0x33a6, 0x00d0, 0x2099, 0xb78e, 0x33a6, 0x9398, 0x33a6,
+	0x9398, 0x3304, 0x080c, 0x5acf, 0x1118, 0xa084, 0x37ff, 0x0010,
+	0xa084, 0x3fff, 0x20a2, 0x9398, 0x33a6, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a9, 0x0004, 0x2099,
+	0xb505, 0x53a6, 0x20a9, 0x0004, 0x2099, 0xb501, 0x53a6, 0x20a9,
+	0x0008, 0x20a3, 0x0000, 0x1f04, 0x7489, 0x20a9, 0x0008, 0x20a3,
+	0x0000, 0x1f04, 0x748f, 0x2099, 0xb796, 0x3304, 0xc0dd, 0x20a2,
+	0x2001, 0xb572, 0x2004, 0xd0e4, 0x0158, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x9398, 0x9398, 0x9398, 0x33a6, 0x20a9, 0x0004, 0x0010,
+	0x20a9, 0x0007, 0x20a3, 0x0000, 0x1f04, 0x74aa, 0x0468, 0x2001,
+	0xb535, 0x2004, 0xd0a4, 0x0140, 0x2001, 0xb78f, 0x2004, 0x60e3,
+	0x0000, 0x080c, 0x2872, 0x60e2, 0x2099, 0xb78e, 0x20a9, 0x0008,
+	0x53a6, 0x20a9, 0x0004, 0x2099, 0xb505, 0x53a6, 0x20a9, 0x0004,
+	0x2099, 0xb501, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x1f04,
+	0x74cd, 0x20a9, 0x0008, 0x20a3, 0x0000, 0x1f04, 0x74d3, 0x2099,
+	0xb796, 0x20a9, 0x0008, 0x53a6, 0x20a9, 0x0008, 0x20a3, 0x0000,
+	0x1f04, 0x74de, 0x20a9, 0x000a, 0x20a3, 0x0000, 0x1f04, 0x74e4,
+	0x60c3, 0x0074, 0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x7641, 0x20a3, 0x2010, 0x20a3, 0x0014, 0x20a3, 0x0800, 0x20a3,
+	0x2000, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x00f6,
+	0x2079, 0xb552, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0xa085, 0x0020,
+	0xd1a4, 0x0110, 0xa085, 0x0010, 0xa085, 0x0002, 0x00d6, 0x0804,
+	0x75cc, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3,
+	0x5000, 0x0804, 0x743b, 0x20a1, 0x020b, 0x080c, 0x7641, 0x20a3,
+	0x2110, 0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0014, 0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x76d5,
+	0x0020, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0200, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004, 0x080c,
+	0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0100,
+	0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3, 0x0008,
+	0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3,
+	0x0200, 0x0804, 0x743b, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3,
+	0x0100, 0x20a3, 0x0000, 0x7828, 0xa005, 0x0110, 0x20a2, 0x0010,
+	0x20a3, 0x0003, 0x7810, 0x20a2, 0x60c3, 0x0008, 0x080c, 0x7d67,
+	0x0005, 0x00d6, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0210,
+	0x20a3, 0x0014, 0x20a3, 0x0800, 0x7818, 0x2068, 0x6894, 0xa086,
+	0x0014, 0x1198, 0x699c, 0xa184, 0x0030, 0x0190, 0x6998, 0xa184,
+	0xc000, 0x1140, 0xd1ec, 0x0118, 0x20a3, 0x2100, 0x0058, 0x20a3,
+	0x0100, 0x0040, 0x20a3, 0x0400, 0x0028, 0x20a3, 0x0700, 0x0010,
+	0x700f, 0x0800, 0xa006, 0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a2,
+	0x00f6, 0x2079, 0xb552, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0xa085,
+	0x0020, 0xd1a4, 0x0110, 0xa085, 0x0010, 0x2009, 0xb574, 0x210c,
+	0xd184, 0x1110, 0xa085, 0x0002, 0x0026, 0x2009, 0xb572, 0x210c,
+	0xd1e4, 0x0130, 0xc0c5, 0xa094, 0x0030, 0xa296, 0x0010, 0x0140,
+	0xd1ec, 0x0130, 0xa094, 0x0030, 0xa296, 0x0010, 0x0108, 0xc0bd,
+	0x002e, 0x20a2, 0x20a2, 0x20a2, 0x60c3, 0x0014, 0x080c, 0x7d67,
+	0x00de, 0x0005, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0210,
+	0x20a3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0014,
+	0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3,
+	0x0200, 0x0804, 0x73ae, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3,
+	0x0100, 0x20a3, 0x0000, 0x20a3, 0x0003, 0x20a3, 0x2a00, 0x60c3,
+	0x0008, 0x080c, 0x7d67, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x000b, 0x20a3, 0x0000, 0x60c3, 0x0008, 0x080c, 0x7d67,
+	0x0005, 0x0026, 0x0036, 0x0046, 0x2019, 0x3200, 0x2021, 0x0800,
+	0x0038, 0x0026, 0x0036, 0x0046, 0x2019, 0x2200, 0x2021, 0x0100,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2014,
+	0xa286, 0x007e, 0x11a0, 0xa385, 0x00ff, 0x20a2, 0x20a3, 0xfffe,
+	0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x2001, 0xb79e, 0x2004,
+	0xa005, 0x0118, 0x2011, 0xb51d, 0x2214, 0x22a2, 0x04d0, 0xa286,
+	0x007f, 0x1138, 0x00d6, 0xa385, 0x00ff, 0x20a2, 0x20a3, 0xfffd,
+	0x00c8, 0x2001, 0xb535, 0x2004, 0xd0ac, 0x1110, 0xd2bc, 0x01c8,
+	0xa286, 0x0080, 0x00d6, 0x1130, 0xa385, 0x00ff, 0x20a2, 0x20a3,
+	0xfffc, 0x0040, 0xa2e8, 0xb635, 0x2d6c, 0x6810, 0xa305, 0x20a2,
+	0x6814, 0x20a2, 0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de,
+	0x0080, 0x00d6, 0xa2e8, 0xb635, 0x2d6c, 0x6810, 0xa305, 0x20a2,
+	0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214,
+	0x22a2, 0xa485, 0x0029, 0x20a2, 0x004e, 0x003e, 0x20a3, 0x0000,
+	0x080c, 0x7d56, 0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x20a3, 0xffff,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005, 0x0026, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x20a3, 0x02ff, 0x2011, 0xfffc, 0x22a2,
+	0x00d6, 0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x20a3,
+	0x2029, 0x20a3, 0x0000, 0x08e0, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0xfc02, 0x20a3, 0x0000, 0x0005, 0x0026, 0x0036, 0x0046,
+	0x2019, 0x3300, 0x2021, 0x0800, 0x0038, 0x0026, 0x0036, 0x0046,
+	0x2019, 0x2300, 0x2021, 0x0100, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb535, 0x2214, 0xd2ac,
+	0x1118, 0xa092, 0x007e, 0x02d8, 0x00d6, 0xa0e8, 0xb635, 0x2d6c,
+	0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2, 0x6810, 0xa005, 0x1140,
+	0x6814, 0xa005, 0x1128, 0x20a3, 0x00ff, 0x20a3, 0xfffe, 0x0028,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0080, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa305, 0x20a2, 0x6814, 0x20a2,
+	0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2, 0xa485,
+	0x0098, 0x20a2, 0x20a3, 0x0000, 0x004e, 0x003e, 0x080c, 0x7d56,
+	0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x002e, 0x0005, 0x080c, 0x7d56, 0x22a2, 0x20a3,
+	0x0000, 0x7a08, 0x22a2, 0x7810, 0x20a2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x002e, 0x0005, 0x00c6, 0x00f6, 0x6004, 0xa08a, 0x0085,
+	0x0a0c, 0x1515, 0xa08a, 0x008c, 0x1a0c, 0x1515, 0x6118, 0x2178,
+	0x79a0, 0x2011, 0xb535, 0x2214, 0xd2ac, 0x1110, 0xd1bc, 0x0150,
+	0x7900, 0xd1f4, 0x0120, 0x7914, 0xa18c, 0x00ff, 0x0040, 0x2009,
+	0x0000, 0x0028, 0xa1f8, 0x2dc4, 0x2f0d, 0xa18c, 0x00ff, 0x2c78,
+	0x2061, 0x0100, 0x619a, 0xa082, 0x0085, 0x001b, 0x00fe, 0x00ce,
+	0x0005, 0x777a, 0x7784, 0x779f, 0x7778, 0x7778, 0x7778, 0x777a,
+	0x080c, 0x1515, 0x0146, 0x20a1, 0x020b, 0x04a1, 0x60c3, 0x0000,
+	0x080c, 0x7d67, 0x014e, 0x0005, 0x0146, 0x20a1, 0x020b, 0x080c,
+	0x77eb, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808, 0x20a2, 0x7810,
+	0x20a2, 0x20a3, 0x0000, 0x20a3, 0xffff, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x60c3, 0x000c, 0x080c, 0x7d67, 0x014e, 0x0005, 0x0146,
+	0x20a1, 0x020b, 0x080c, 0x7825, 0x20a3, 0x0003, 0x20a3, 0x0300,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3, 0x0004, 0x080c, 0x7d67,
+	0x014e, 0x0005, 0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818,
+	0xa080, 0x0028, 0x2004, 0x2011, 0xb535, 0x2214, 0xd2ac, 0x1118,
+	0xa092, 0x007e, 0x0288, 0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810,
+	0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb51c, 0x2da6,
+	0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb635, 0x2d6c,
+	0x6810, 0xa085, 0x8100, 0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3,
+	0x0000, 0x2011, 0xb515, 0x2214, 0x22a2, 0x20a3, 0x0009, 0x20a3,
+	0x0000, 0x0804, 0x76a8, 0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000,
+	0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb535, 0x2214, 0xd2ac,
+	0x1118, 0xa092, 0x007e, 0x0288, 0x00d6, 0xa0e8, 0xb635, 0x2d6c,
+	0x6810, 0xa085, 0x8400, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb51c,
+	0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb635,
+	0x2d6c, 0x6810, 0xa085, 0x8400, 0x20a2, 0x6814, 0x20a2, 0x00de,
+	0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2, 0x2001, 0x0099,
+	0x20a2, 0x20a3, 0x0000, 0x0804, 0x7734, 0x0026, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011, 0xb535,
+	0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x0288, 0x00d6, 0xa0e8,
+	0xb635, 0x2d6c, 0x6810, 0xa085, 0x8500, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x8500, 0x20a2, 0x6814,
+	0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2,
+	0x2001, 0x0099, 0x20a2, 0x20a3, 0x0000, 0x0804, 0x7734, 0x00c6,
+	0x00f6, 0x2c78, 0x7804, 0xa08a, 0x0040, 0x0a0c, 0x1515, 0xa08a,
+	0x0053, 0x1a0c, 0x1515, 0x7918, 0x2160, 0x61a0, 0x2011, 0xb535,
+	0x2214, 0xd2ac, 0x1110, 0xd1bc, 0x0150, 0x6100, 0xd1f4, 0x0120,
+	0x6114, 0xa18c, 0x00ff, 0x0040, 0x2009, 0x0000, 0x0028, 0xa1e0,
+	0x2dc4, 0x2c0d, 0xa18c, 0x00ff, 0x2061, 0x0100, 0x619a, 0xa082,
+	0x0040, 0x001b, 0x00fe, 0x00ce, 0x0005, 0x78a2, 0x79ae, 0x794b,
+	0x7b60, 0x78a0, 0x78a0, 0x78a0, 0x78a0, 0x78a0, 0x78a0, 0x78a0,
+	0x80d7, 0x80e7, 0x80f7, 0x8107, 0x78a0, 0x851e, 0x78a0, 0x80c6,
+	0x080c, 0x1515, 0x00d6, 0x0156, 0x0146, 0x780b, 0xffff, 0x20a1,
+	0x020b, 0x080c, 0x7902, 0x7910, 0x2168, 0x6948, 0x7952, 0x21a2,
+	0xa016, 0x22a2, 0x22a2, 0x22a2, 0x694c, 0xa184, 0x000f, 0x1118,
+	0x2001, 0x0005, 0x0040, 0xd184, 0x0118, 0x2001, 0x0004, 0x0018,
+	0xa084, 0x0006, 0x8004, 0x0016, 0x2008, 0x7858, 0xa084, 0x00ff,
+	0x8007, 0xa105, 0x001e, 0x20a2, 0xd1ac, 0x0118, 0x20a3, 0x0002,
+	0x0048, 0xd1b4, 0x0118, 0x20a3, 0x0001, 0x0020, 0x20a3, 0x0000,
+	0x2230, 0x0010, 0x6a80, 0x6e7c, 0x20a9, 0x0008, 0x0136, 0xad88,
+	0x0017, 0x2198, 0x20a1, 0x021b, 0x53a6, 0x013e, 0x20a1, 0x020b,
+	0x22a2, 0x26a2, 0x60c3, 0x0020, 0x20e1, 0x9080, 0x6014, 0xa084,
+	0x0004, 0xa085, 0x0009, 0x6016, 0x2001, 0xb7fc, 0x2003, 0x07d0,
+	0x2001, 0xb7fb, 0x2003, 0x0009, 0x080c, 0x17e2, 0x014e, 0x015e,
+	0x00de, 0x0005, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7a18, 0xa280,
+	0x0023, 0x2014, 0x8210, 0xa294, 0x00ff, 0x2202, 0x8217, 0x7818,
+	0xa080, 0x0028, 0x2004, 0x2019, 0xb535, 0x231c, 0xd3ac, 0x1110,
+	0xd0bc, 0x0188, 0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085,
+	0x0600, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb51c, 0x2da6, 0x8d68,
+	0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810,
+	0xa085, 0x0600, 0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000,
+	0x2009, 0xb515, 0x210c, 0x21a2, 0x20a3, 0x0829, 0x20a3, 0x0000,
+	0x22a2, 0x20a3, 0x0000, 0x2fa2, 0x20a3, 0xffff, 0x20a3, 0x0000,
+	0x20a3, 0x0000, 0x0005, 0x00d6, 0x0156, 0x0136, 0x0146, 0x20a1,
+	0x020b, 0x00c1, 0x7810, 0x2068, 0x6860, 0x20a2, 0x685c, 0x20a2,
+	0x6880, 0x20a2, 0x687c, 0x20a2, 0xa006, 0x20a2, 0x20a2, 0x20a2,
+	0x20a2, 0x60c3, 0x000c, 0x080c, 0x7d67, 0x014e, 0x013e, 0x015e,
+	0x00de, 0x0005, 0x0026, 0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818,
+	0xa080, 0x0028, 0x2004, 0x2011, 0xb535, 0x2214, 0xd2ac, 0x1110,
+	0xd0bc, 0x0188, 0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085,
+	0x0500, 0x20a2, 0x6814, 0x20a2, 0x2069, 0xb51c, 0x2da6, 0x8d68,
+	0x2da6, 0x00de, 0x0088, 0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810,
+	0xa085, 0x0500, 0x20a2, 0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000,
+	0x2011, 0xb515, 0x2214, 0x22a2, 0x20a3, 0x0889, 0x20a3, 0x0000,
+	0x080c, 0x7d56, 0x22a2, 0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2,
+	0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005, 0x00d6, 0x0156,
+	0x0136, 0x0146, 0x7810, 0xa0ec, 0xf000, 0x0168, 0xa06d, 0x080c,
+	0x5301, 0x0148, 0x684c, 0xa084, 0x2020, 0xa086, 0x2020, 0x1118,
+	0x7820, 0xc0cd, 0x7822, 0x20a1, 0x020b, 0x080c, 0x7b16, 0xa016,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x7810, 0xa084, 0xf000,
+	0x1130, 0x7810, 0xa084, 0x0700, 0x8007, 0x0043, 0x0010, 0xa006,
+	0x002b, 0x014e, 0x013e, 0x015e, 0x00de, 0x0005, 0x79e8, 0x7a7d,
+	0x7a8d, 0x7abf, 0x7ad2, 0x7aed, 0x7af6, 0x79e6, 0x080c, 0x1515,
+	0x0016, 0x0036, 0x694c, 0xa18c, 0x0003, 0x0118, 0xa186, 0x0003,
+	0x1170, 0x6b78, 0x7820, 0xd0cc, 0x0108, 0xc3e5, 0x23a2, 0x6868,
+	0x20a2, 0x6864, 0x20a2, 0x003e, 0x001e, 0x0804, 0x7ac9, 0xa186,
+	0x0001, 0x190c, 0x1515, 0x6b78, 0x7820, 0xd0cc, 0x0108, 0xc3e5,
+	0x23a2, 0x6868, 0x20a2, 0x6864, 0x20a2, 0x22a2, 0x6874, 0x20a2,
+	0x22a2, 0x687c, 0x20a2, 0x2009, 0x0018, 0xa384, 0x0300, 0x0904,
+	0x7a77, 0xd3c4, 0x0110, 0x687c, 0xa108, 0xd3cc, 0x0110, 0x6874,
+	0xa108, 0x0156, 0x20a9, 0x000d, 0xad80, 0x0020, 0x201c, 0x831f,
+	0x23a2, 0x8000, 0x1f04, 0x7a26, 0x015e, 0x22a2, 0x22a2, 0x22a2,
+	0xa184, 0x0003, 0x0904, 0x7a77, 0x20a1, 0x020b, 0x20e1, 0x9080,
+	0x20e1, 0x4000, 0x0006, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011,
+	0xb535, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8,
+	0xb635, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814,
+	0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2,
+	0x000e, 0x7b20, 0xd3cc, 0x0118, 0x20a3, 0x0889, 0x0010, 0x20a3,
+	0x0898, 0x20a2, 0x080c, 0x7d56, 0x22a2, 0x20a3, 0x0000, 0x61c2,
+	0x003e, 0x001e, 0x080c, 0x7d67, 0x0005, 0x2011, 0x0008, 0x2001,
+	0xb50d, 0x2004, 0xd0f4, 0x0110, 0x2011, 0x0028, 0x7820, 0xd0cc,
+	0x0108, 0xc2e5, 0x22a2, 0xa016, 0x04d0, 0x2011, 0x0302, 0x0016,
+	0x0036, 0x7828, 0x792c, 0xa11d, 0x0108, 0xc2dd, 0x7b20, 0xd3cc,
+	0x0108, 0xc2e5, 0x22a2, 0x20a2, 0x21a2, 0x003e, 0x001e, 0xa016,
+	0x22a2, 0x20a3, 0x0012, 0x22a2, 0x20a3, 0x0008, 0x22a2, 0x22a2,
+	0x22a2, 0x22a2, 0x20a3, 0x7000, 0x20a3, 0x0500, 0x22a2, 0x20a3,
+	0x000a, 0x22a2, 0x22a2, 0x20a3, 0x2500, 0x22a2, 0x22a2, 0x22a2,
+	0x22a2, 0x22a2, 0x60c3, 0x0032, 0x080c, 0x7d67, 0x0005, 0x2011,
+	0x0028, 0x7820, 0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0xa016, 0x22a2,
+	0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x60c3, 0x0018, 0x080c,
+	0x7d67, 0x0005, 0x2011, 0x0100, 0x7820, 0xd0cc, 0x0108, 0xc2e5,
+	0x22a2, 0xa016, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x22a2, 0x20a3,
+	0x0008, 0x22a2, 0x7854, 0xa084, 0x00ff, 0x20a2, 0x22a2, 0x22a2,
+	0x60c3, 0x0020, 0x080c, 0x7d67, 0x0005, 0x2011, 0x0008, 0x7820,
+	0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0xa016, 0x0888, 0x0036, 0x7b10,
+	0xa384, 0xff00, 0x7812, 0xa384, 0x00ff, 0x8001, 0x1138, 0x7820,
+	0xd0cc, 0x0108, 0xc2e5, 0x22a2, 0x003e, 0x0808, 0x0046, 0x2021,
+	0x0800, 0x0006, 0x7820, 0xd0cc, 0x000e, 0x0108, 0xc4e5, 0x24a2,
+	0x004e, 0x22a2, 0x20a2, 0x003e, 0x0804, 0x7ac9, 0x0026, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011,
+	0xb535, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8,
+	0xb635, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x0700, 0x20a2, 0x6814,
+	0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2,
+	0x7820, 0xd0cc, 0x0118, 0x20a3, 0x0889, 0x0010, 0x20a3, 0x0898,
+	0x20a3, 0x0000, 0x080c, 0x7d56, 0x22a2, 0x20a3, 0x0000, 0x7a08,
+	0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x002e, 0x0005,
+	0x00d6, 0x0156, 0x0136, 0x0146, 0x0016, 0x0036, 0x7810, 0xa084,
+	0x0700, 0x8007, 0x003b, 0x003e, 0x001e, 0x014e, 0x013e, 0x015e,
+	0x00de, 0x0005, 0x7b7a, 0x7b7a, 0x7b7c, 0x7b7a, 0x7b7a, 0x7b7a,
+	0x7b9e, 0x7b7a, 0x080c, 0x1515, 0x7910, 0xa18c, 0xf8ff, 0xa18d,
+	0x0600, 0x7912, 0x20a1, 0x020b, 0x2009, 0x0003, 0x00f9, 0x00d6,
+	0x2069, 0xb552, 0x6804, 0xd0bc, 0x0130, 0x682c, 0xa084, 0x00ff,
+	0x8007, 0x20a2, 0x0010, 0x20a3, 0x3f00, 0x00de, 0x22a2, 0x22a2,
+	0x22a2, 0x60c3, 0x0001, 0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b,
+	0x2009, 0x0003, 0x0019, 0x20a3, 0x7f00, 0x0c80, 0x0026, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004, 0x2011,
+	0xb535, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6, 0xa0e8,
+	0xb635, 0x2d6c, 0x6810, 0xa085, 0x0100, 0x20a2, 0x6814, 0x20a2,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0088, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x0100, 0x20a2, 0x6814,
+	0x20a2, 0x00de, 0x20a3, 0x0000, 0x2011, 0xb515, 0x2214, 0x22a2,
+	0x20a3, 0x0888, 0xa18d, 0x0008, 0x21a2, 0x080c, 0x7d56, 0x22a2,
+	0x20a3, 0x0000, 0x7a08, 0x22a2, 0x2fa2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x002e, 0x0005, 0x00e6, 0x00d6, 0x00c6, 0x0056, 0x0046,
+	0x0036, 0x2061, 0x0100, 0x2071, 0xb500, 0x7154, 0x7818, 0x2068,
+	0x68a0, 0x2028, 0x76d4, 0xd6ac, 0x1130, 0xd0bc, 0x1120, 0x6910,
+	0x6a14, 0x7454, 0x0020, 0x6910, 0x6a14, 0x7370, 0x7474, 0x781c,
+	0xa0be, 0x0006, 0x0904, 0x7ca1, 0xa0be, 0x000a, 0x15e8, 0xa185,
+	0x0200, 0x6062, 0x6266, 0x636a, 0x646e, 0x6073, 0x2029, 0x6077,
+	0x0000, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e, 0x8007, 0x607a,
+	0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086, 0x7810, 0x2070,
+	0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6, 0x7008, 0x60ca,
+	0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000, 0x609f, 0x0000,
+	0x080c, 0x85b9, 0x2009, 0x07d0, 0x60c4, 0xa084, 0xfff0, 0xa005,
+	0x0110, 0x2009, 0x1b58, 0x080c, 0x6a15, 0x003e, 0x004e, 0x005e,
+	0x00ce, 0x00de, 0x00ee, 0x0005, 0x70d4, 0xd0ac, 0x1110, 0xd5bc,
+	0x0138, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e, 0x0038,
+	0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x6073,
+	0x0809, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086,
+	0x7810, 0x2070, 0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6,
+	0x7008, 0x60ca, 0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xa582, 0x0080, 0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0xa294,
+	0x00ff, 0x0010, 0x2011, 0x0000, 0x629e, 0x080c, 0x85b9, 0x2009,
+	0x07d0, 0x60c4, 0xa084, 0xfff0, 0xa005, 0x0110, 0x2009, 0x1b58,
+	0x080c, 0x6a15, 0x003e, 0x004e, 0x005e, 0x00ce, 0x00de, 0x00ee,
+	0x0005, 0x7810, 0x2070, 0x704c, 0xa084, 0x0003, 0xa086, 0x0002,
+	0x0904, 0x7cf7, 0x2001, 0xb535, 0x2004, 0xd0ac, 0x1110, 0xd5bc,
+	0x0138, 0xa185, 0x0100, 0x6062, 0x6266, 0x636a, 0x646e, 0x0038,
+	0xa185, 0x0100, 0x6062, 0x6266, 0x606b, 0x0000, 0x646e, 0x6073,
+	0x0880, 0x6077, 0x0008, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x7834, 0x607e, 0x2f00, 0x6086, 0x7808, 0x6082,
+	0x7060, 0x608a, 0x705c, 0x608e, 0x7080, 0x60c6, 0x707c, 0x60ca,
+	0x707c, 0x792c, 0xa108, 0x792e, 0x7080, 0x7928, 0xa109, 0x792a,
+	0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000, 0xa582, 0x0080,
+	0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0xa294, 0x00ff, 0x0010,
+	0x2011, 0x0000, 0x629e, 0x080c, 0x85b6, 0x0804, 0x7c8f, 0x2001,
+	0xb535, 0x2004, 0xd0ac, 0x1110, 0xd5bc, 0x0138, 0xa185, 0x0700,
+	0x6062, 0x6266, 0x636a, 0x646e, 0x0038, 0xa185, 0x0700, 0x6062,
+	0x6266, 0x606b, 0x0000, 0x646e, 0x080c, 0x5301, 0x0180, 0x00d6,
+	0x7810, 0xa06d, 0x684c, 0x00de, 0xa084, 0x2020, 0xa086, 0x2020,
+	0x1130, 0x7820, 0xc0cd, 0x7822, 0x6073, 0x0889, 0x0010, 0x6073,
+	0x0898, 0x6077, 0x0000, 0x688c, 0x8000, 0xa084, 0x00ff, 0x688e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6086, 0x7808, 0x6082,
+	0x7014, 0x608a, 0x7010, 0x608e, 0x700c, 0x60c6, 0x7008, 0x60ca,
+	0x686c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000, 0xa582, 0x0080,
+	0x0248, 0x6a00, 0xd2f4, 0x0120, 0x6a14, 0xa294, 0x00ff, 0x0010,
+	0x2011, 0x0000, 0x629e, 0x7820, 0xd0cc, 0x0120, 0x080c, 0x85b9,
+	0x0804, 0x7c8f, 0x080c, 0x85b6, 0x0804, 0x7c8f, 0x7a18, 0xa280,
+	0x0023, 0x2014, 0x8210, 0xa294, 0x00ff, 0x2202, 0x8217, 0x0005,
+	0x00d6, 0x2069, 0xb7e0, 0x6843, 0x0001, 0x00de, 0x0005, 0x20e1,
+	0x9080, 0x60a3, 0x0056, 0x60a7, 0x9575, 0x0019, 0x080c, 0x6a07,
+	0x0005, 0x0006, 0x6014, 0xa084, 0x0004, 0xa085, 0x0009, 0x6016,
+	0x000e, 0x0005, 0x0016, 0x00c6, 0x0006, 0x2061, 0x0100, 0x61a4,
+	0x60a7, 0x95f5, 0x6014, 0xa084, 0x0004, 0xa085, 0x0008, 0x6016,
+	0x000e, 0xe000, 0xe000, 0xe000, 0xe000, 0x61a6, 0x00ce, 0x001e,
+	0x0005, 0x00c6, 0x00d6, 0x0016, 0x0026, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x5acf, 0x1198, 0x2001, 0xb7fc, 0x2004, 0xa005,
+	0x15b8, 0x0066, 0x2031, 0x0001, 0x080c, 0x5b51, 0x006e, 0x1118,
+	0x080c, 0x6a07, 0x0468, 0x00c6, 0x2061, 0xb7e0, 0x00d8, 0x6904,
+	0xa194, 0x4000, 0x0550, 0x0831, 0x6803, 0x1000, 0x6803, 0x0000,
+	0x00c6, 0x2061, 0xb7e0, 0x6128, 0xa192, 0x00c8, 0x1258, 0x8108,
+	0x612a, 0x6124, 0x00ce, 0x81ff, 0x0198, 0x080c, 0x6a07, 0x080c,
+	0x7d71, 0x0070, 0x6124, 0xa1e5, 0x0000, 0x0140, 0x080c, 0xb444,
+	0x080c, 0x6a10, 0x2009, 0x0014, 0x080c, 0x864c, 0x00ce, 0x0000,
+	0x002e, 0x001e, 0x00de, 0x00ce, 0x0005, 0x2001, 0xb7fc, 0x2004,
+	0xa005, 0x1db0, 0x00c6, 0x2061, 0xb7e0, 0x6128, 0xa192, 0x0003,
+	0x1e08, 0x8108, 0x612a, 0x00ce, 0x080c, 0x6a07, 0x080c, 0x4b1f,
+	0x0c38, 0x00c6, 0x00d6, 0x00e6, 0x0016, 0x0026, 0x080c, 0x6a1d,
+	0x2071, 0xb7e0, 0x713c, 0x81ff, 0x0590, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x5acf, 0x11a8, 0x0036, 0x2019, 0x0002, 0x080c,
+	0x7fe4, 0x003e, 0x713c, 0x2160, 0x080c, 0xb444, 0x2009, 0x004a,
+	0x080c, 0x864c, 0x0066, 0x2031, 0x0001, 0x080c, 0x5b51, 0x006e,
+	0x00b0, 0x6904, 0xa194, 0x4000, 0x01c0, 0x6803, 0x1000, 0x6803,
+	0x0000, 0x0036, 0x2019, 0x0001, 0x080c, 0x7fe4, 0x003e, 0x713c,
+	0x2160, 0x080c, 0xb444, 0x2009, 0x004a, 0x080c, 0x864c, 0x002e,
+	0x001e, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x0c58, 0x0026, 0x00e6,
+	0x2071, 0xb7e0, 0x7048, 0xd084, 0x01c0, 0x713c, 0x81ff, 0x01a8,
+	0x2071, 0x0100, 0xa188, 0x0007, 0x2114, 0xa28e, 0x0006, 0x1138,
+	0x7014, 0xa084, 0x0184, 0xa085, 0x0012, 0x7016, 0x0030, 0x7014,
+	0xa084, 0x0184, 0xa085, 0x0016, 0x7016, 0x00ee, 0x002e, 0x0005,
+	0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0056, 0x0046, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x6018, 0x2068, 0x6ca0, 0x2071, 0xb7e0, 0x7018,
+	0x2068, 0x8dff, 0x0188, 0x68a0, 0xa406, 0x0118, 0x6854, 0x2068,
+	0x0cc0, 0x6010, 0x2060, 0x643c, 0x6540, 0x6648, 0x2d60, 0x080c,
+	0x511a, 0x0110, 0xa085, 0x0001, 0x012e, 0x000e, 0x004e, 0x005e,
+	0x006e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x7641, 0x20a3, 0x1200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x781c,
+	0xa086, 0x0004, 0x1110, 0x6098, 0x0018, 0x2001, 0xb515, 0x2004,
+	0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a9, 0x0010, 0xa006,
+	0x20a2, 0x1f04, 0x7ea0, 0x20a2, 0x20a2, 0x60c3, 0x002c, 0x080c,
+	0x7d67, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b, 0x080c, 0x7641,
+	0x20a3, 0x0f00, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808, 0x20a2,
+	0x60c3, 0x0008, 0x080c, 0x7d67, 0x014e, 0x015e, 0x0005, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0200, 0x20a3,
+	0x0000, 0x20a9, 0x0006, 0x2011, 0xb540, 0x2019, 0xb541, 0x23a6,
+	0x22a6, 0xa398, 0x0002, 0xa290, 0x0002, 0x1f04, 0x7ecf, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x001c, 0x080c, 0x7d67, 0x014e,
+	0x015e, 0x0005, 0x0156, 0x0146, 0x0016, 0x0026, 0x20a1, 0x020b,
+	0x080c, 0x76b6, 0x080c, 0x76cc, 0x7810, 0xa080, 0x0000, 0x2004,
+	0xa080, 0x0015, 0x2098, 0x7808, 0xa088, 0x0002, 0x21a8, 0x53a6,
+	0xa080, 0x0004, 0x8003, 0x60c2, 0x080c, 0x7d67, 0x002e, 0x001e,
+	0x014e, 0x015e, 0x0005, 0x0156, 0x0146, 0x20a1, 0x020b, 0x080c,
+	0x7641, 0x20a3, 0x6200, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7808,
+	0x20a2, 0x60c3, 0x0008, 0x080c, 0x7d67, 0x014e, 0x015e, 0x0005,
+	0x0156, 0x0146, 0x0016, 0x0026, 0x20a1, 0x020b, 0x080c, 0x7641,
+	0x7810, 0xa080, 0x0000, 0x2004, 0xa080, 0x0017, 0x2098, 0x7808,
+	0xa088, 0x0002, 0x21a8, 0x53a6, 0x8003, 0x60c2, 0x080c, 0x7d67,
+	0x002e, 0x001e, 0x014e, 0x015e, 0x0005, 0x00e6, 0x00c6, 0x0006,
+	0x0126, 0x2091, 0x8000, 0x2071, 0xb7e0, 0x700c, 0x2060, 0x8cff,
+	0x0178, 0x080c, 0x9e58, 0x1110, 0x080c, 0x8c19, 0x600c, 0x0006,
+	0x080c, 0xa01f, 0x080c, 0x861d, 0x080c, 0x811e, 0x00ce, 0x0c78,
+	0x700f, 0x0000, 0x700b, 0x0000, 0x012e, 0x000e, 0x00ce, 0x00ee,
+	0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0026,
+	0x0016, 0x0006, 0x2091, 0x8000, 0x2069, 0x0100, 0x2079, 0x0140,
+	0x2071, 0xb7e0, 0x7024, 0x2060, 0x8cff, 0x05a0, 0x080c, 0x7d7a,
+	0x68c3, 0x0000, 0x080c, 0x6a10, 0x2009, 0x0013, 0x080c, 0x864c,
+	0x20a9, 0x01f4, 0x6824, 0xd094, 0x0158, 0x6827, 0x0004, 0x7804,
+	0xa084, 0x4000, 0x01a0, 0x7803, 0x1000, 0x7803, 0x0000, 0x0078,
+	0xd084, 0x0118, 0x6827, 0x0001, 0x0010, 0x1f04, 0x7f7a, 0x7804,
+	0xa084, 0x1000, 0x0120, 0x7803, 0x0100, 0x7803, 0x0000, 0x6824,
+	0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x015e,
+	0x012e, 0x0005, 0x2001, 0xb500, 0x2004, 0xa096, 0x0001, 0x0590,
+	0xa096, 0x0004, 0x0578, 0x080c, 0x6a10, 0x6814, 0xa084, 0x0001,
+	0x0110, 0x68a7, 0x95f5, 0x6817, 0x0008, 0x68c3, 0x0000, 0x2011,
+	0x4adc, 0x080c, 0x699c, 0x20a9, 0x01f4, 0x6824, 0xd094, 0x0158,
+	0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x01a0, 0x7803, 0x1000,
+	0x7803, 0x0000, 0x0078, 0xd084, 0x0118, 0x6827, 0x0001, 0x0010,
+	0x1f04, 0x7fbd, 0x7804, 0xa084, 0x1000, 0x0120, 0x7803, 0x0100,
+	0x7803, 0x0000, 0x000e, 0x001e, 0x002e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x015e, 0x012e, 0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0026, 0x0016, 0x0006, 0x2091, 0x8000, 0x2069,
+	0x0100, 0x2079, 0x0140, 0x2071, 0xb7e0, 0x703c, 0x2060, 0x8cff,
+	0x0904, 0x806b, 0xa386, 0x0002, 0x1128, 0x6814, 0xa084, 0x0002,
+	0x0904, 0x806b, 0x68af, 0x95f5, 0x6817, 0x0010, 0x2009, 0x00fa,
+	0x8109, 0x1df0, 0x68c7, 0x0000, 0x68cb, 0x0008, 0x080c, 0x6a1d,
+	0x080c, 0x220c, 0x0046, 0x2009, 0x017f, 0x200b, 0x00a5, 0x2021,
+	0x0169, 0x2404, 0xa084, 0x000f, 0xa086, 0x0004, 0x1500, 0x68af,
+	0x95f5, 0x68c7, 0x0000, 0x68cb, 0x0008, 0x00e6, 0x00f6, 0x2079,
+	0x0020, 0x2071, 0xb84a, 0x6814, 0xa084, 0x0184, 0xa085, 0x0012,
+	0x6816, 0x7803, 0x0008, 0x7003, 0x0000, 0x00fe, 0x00ee, 0xa386,
+	0x0002, 0x1128, 0x7884, 0xa005, 0x1110, 0x7887, 0x0001, 0x2001,
+	0xb7b1, 0x2004, 0x200a, 0x004e, 0xa39d, 0x0000, 0x1120, 0x2009,
+	0x0049, 0x080c, 0x864c, 0x20a9, 0x03e8, 0x6824, 0xd094, 0x0158,
+	0x6827, 0x0004, 0x7804, 0xa084, 0x4000, 0x01a0, 0x7803, 0x1000,
+	0x7803, 0x0000, 0x0078, 0xd08c, 0x0118, 0x6827, 0x0002, 0x0010,
+	0x1f04, 0x804d, 0x7804, 0xa084, 0x1000, 0x0120, 0x7803, 0x0100,
+	0x7803, 0x0000, 0x6824, 0x000e, 0x001e, 0x002e, 0x00ce, 0x00de,
+	0x00ee, 0x00fe, 0x015e, 0x012e, 0x0005, 0x00d6, 0x0126, 0x2091,
+	0x8000, 0x2069, 0xb7e0, 0x6a06, 0x012e, 0x00de, 0x0005, 0x00d6,
+	0x0126, 0x2091, 0x8000, 0x2069, 0xb7e0, 0x6a32, 0x012e, 0x00de,
+	0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0066, 0x0006, 0x0126, 0x2071,
+	0xb7e0, 0x7614, 0x2660, 0x2678, 0x2091, 0x8000, 0x8cff, 0x0538,
+	0x601c, 0xa206, 0x1500, 0x7014, 0xac36, 0x1110, 0x660c, 0x7616,
+	0x7010, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118, 0x2f00, 0x7012,
+	0x0010, 0x7013, 0x0000, 0x660c, 0x0066, 0x2c00, 0xaf06, 0x0110,
+	0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x080c, 0x9e1d, 0x080c,
+	0x811e, 0x00ce, 0x08d8, 0x2c78, 0x600c, 0x2060, 0x08b8, 0x012e,
+	0x000e, 0x006e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x0156, 0x0146,
+	0x20a1, 0x020b, 0x080c, 0x7902, 0x7810, 0x20a2, 0xa006, 0x20a2,
+	0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x1000, 0x0804, 0x8116, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x7902, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x4000, 0x0478, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x7902, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x2000, 0x00f8, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x7902, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0400, 0x0078, 0x0156,
+	0x0146, 0x20a1, 0x020b, 0x080c, 0x7902, 0x7810, 0x20a2, 0xa006,
+	0x20a2, 0x20a2, 0x20a2, 0x20a2, 0x20a3, 0x0200, 0x0089, 0x60c3,
+	0x0020, 0x080c, 0x7d67, 0x014e, 0x015e, 0x0005, 0x00e6, 0x2071,
+	0xb7e0, 0x7020, 0xa005, 0x0110, 0x8001, 0x7022, 0x00ee, 0x0005,
+	0x20a9, 0x0008, 0x20a2, 0x1f04, 0x812a, 0x20a2, 0x20a2, 0x0005,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0076, 0x0066, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2071, 0xb7e0, 0x7614, 0x2660, 0x2678, 0x2039,
+	0x0001, 0x87ff, 0x0904, 0x81c6, 0x8cff, 0x0904, 0x81c6, 0x601c,
+	0xa086, 0x0006, 0x1904, 0x81c1, 0x88ff, 0x0138, 0x2800, 0xac06,
+	0x1904, 0x81c1, 0x2039, 0x0000, 0x0050, 0x6018, 0xa206, 0x1904,
+	0x81c1, 0x85ff, 0x0120, 0x6050, 0xa106, 0x1904, 0x81c1, 0x7024,
+	0xac06, 0x1598, 0x2069, 0x0100, 0x68c0, 0xa005, 0x1160, 0x6824,
+	0xd084, 0x0148, 0x6827, 0x0001, 0x080c, 0x6a10, 0x080c, 0x824d,
+	0x7027, 0x0000, 0x0410, 0x080c, 0x6a10, 0x6820, 0xd0b4, 0x0110,
+	0x68a7, 0x95f5, 0x6817, 0x0008, 0x68c3, 0x0000, 0x080c, 0x824d,
+	0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000,
+	0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824,
+	0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x7014, 0xac36, 0x1110,
+	0x660c, 0x7616, 0x7010, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118,
+	0x2f00, 0x7012, 0x0010, 0x7013, 0x0000, 0x660c, 0x0066, 0x2c00,
+	0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x89ff, 0x1158, 0x600f,
+	0x0000, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0110, 0x080c, 0xb099,
+	0x080c, 0x9e1d, 0x080c, 0x811e, 0x88ff, 0x1190, 0x00ce, 0x0804,
+	0x8141, 0x2c78, 0x600c, 0x2060, 0x0804, 0x8141, 0xa006, 0x012e,
+	0x000e, 0x006e, 0x007e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005,
+	0x6017, 0x0000, 0x00ce, 0xa8c5, 0x0001, 0x0c88, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0066, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2071, 0xb7e0, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0904, 0x823d,
+	0x601c, 0xa086, 0x0006, 0x1904, 0x8238, 0x87ff, 0x0128, 0x2700,
+	0xac06, 0x1904, 0x8238, 0x0048, 0x6018, 0xa206, 0x1904, 0x8238,
+	0x85ff, 0x0118, 0x6050, 0xa106, 0x15d8, 0x703c, 0xac06, 0x1180,
+	0x0036, 0x2019, 0x0001, 0x080c, 0x7fe4, 0x7033, 0x0000, 0x703f,
+	0x0000, 0x7043, 0x0000, 0x7047, 0x0000, 0x704b, 0x0000, 0x003e,
+	0x7038, 0xac36, 0x1110, 0x660c, 0x763a, 0x7034, 0xac36, 0x1140,
+	0x2c00, 0xaf36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037, 0x0000,
+	0x660c, 0x0066, 0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678,
+	0x600f, 0x0000, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0110, 0x080c,
+	0xb099, 0x080c, 0x9e1d, 0x87ff, 0x1190, 0x00ce, 0x0804, 0x81e5,
+	0x2c78, 0x600c, 0x2060, 0x0804, 0x81e5, 0xa006, 0x012e, 0x000e,
+	0x002e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x6017,
+	0x0000, 0x00ce, 0xa7bd, 0x0001, 0x0c88, 0x00e6, 0x2071, 0xb7e0,
+	0x2001, 0xb500, 0x2004, 0xa086, 0x0002, 0x1118, 0x7007, 0x0005,
+	0x0010, 0x7007, 0x0000, 0x00ee, 0x0005, 0x00f6, 0x00e6, 0x00c6,
+	0x0066, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0xb7e0,
+	0x2c10, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0518, 0x2200, 0xac06,
+	0x11e0, 0x7038, 0xac36, 0x1110, 0x660c, 0x763a, 0x7034, 0xac36,
+	0x1140, 0x2c00, 0xaf36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037,
+	0x0000, 0x660c, 0x2c00, 0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678,
+	0x600f, 0x0000, 0xa085, 0x0001, 0x0020, 0x2c78, 0x600c, 0x2060,
+	0x08d8, 0x012e, 0x000e, 0x002e, 0x006e, 0x00ce, 0x00ee, 0x00fe,
+	0x0005, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2071, 0xb7e0, 0x760c, 0x2660, 0x2678, 0x8cff,
+	0x0904, 0x8323, 0x6018, 0xa080, 0x0028, 0x2004, 0xa206, 0x1904,
+	0x831e, 0x7024, 0xac06, 0x1508, 0x2069, 0x0100, 0x68c0, 0xa005,
+	0x0904, 0x82fa, 0x080c, 0x7d7a, 0x68c3, 0x0000, 0x080c, 0x824d,
+	0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0xa384, 0x1000,
+	0x0120, 0x6803, 0x0100, 0x6803, 0x0000, 0x2069, 0x0100, 0x6824,
+	0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x700c, 0xac36, 0x1110,
+	0x660c, 0x760e, 0x7008, 0xac36, 0x1140, 0x2c00, 0xaf36, 0x0118,
+	0x2f00, 0x700a, 0x0010, 0x700b, 0x0000, 0x660c, 0x0066, 0x2c00,
+	0xaf06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x080c,
+	0x9e47, 0x1158, 0x080c, 0x2cc2, 0x080c, 0x9e58, 0x11f0, 0x080c,
+	0x8c19, 0x00d8, 0x080c, 0x824d, 0x08c0, 0x080c, 0x9e58, 0x1118,
+	0x080c, 0x8c19, 0x0090, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0168,
+	0x601c, 0xa086, 0x0003, 0x11f8, 0x6837, 0x0103, 0x6b4a, 0x6847,
+	0x0000, 0x080c, 0x5408, 0x080c, 0x9e11, 0x080c, 0xa01f, 0x080c,
+	0x9e1d, 0x080c, 0x811e, 0x00ce, 0x0804, 0x82a7, 0x2c78, 0x600c,
+	0x2060, 0x0804, 0x82a7, 0x012e, 0x000e, 0x006e, 0x00ce, 0x00de,
+	0x00ee, 0x00fe, 0x0005, 0x601c, 0xa086, 0x0006, 0x1d30, 0x080c,
+	0xb099, 0x0c18, 0x0036, 0x0156, 0x0136, 0x0146, 0x3908, 0xa006,
+	0xa190, 0x0020, 0x221c, 0xa39e, 0x2ab7, 0x1118, 0x8210, 0x8000,
+	0x0cc8, 0xa005, 0x0138, 0x20a9, 0x0020, 0x2198, 0xa110, 0x22a0,
+	0x22c8, 0x53a3, 0x014e, 0x013e, 0x015e, 0x003e, 0x0005, 0x00d6,
+	0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0200, 0x20a3, 0x0014,
+	0x60c3, 0x0014, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2099, 0xb7b9,
+	0x20a9, 0x0004, 0x53a6, 0x20a3, 0x0004, 0x20a3, 0x7878, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x080c, 0x7d67, 0x00de, 0x0005, 0x20a1,
+	0x020b, 0x080c, 0x76dd, 0x20a3, 0x0214, 0x20a3, 0x0018, 0x20a3,
+	0x0800, 0x7810, 0xa084, 0xff00, 0x20a2, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x7810, 0xa084, 0x00ff,
+	0x20a2, 0x7828, 0x20a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x60c3,
+	0x0018, 0x080c, 0x7d67, 0x0005, 0x00d6, 0x0016, 0x2f68, 0x2009,
+	0x0035, 0x080c, 0xa10a, 0x1904, 0x8402, 0x20a1, 0x020b, 0x080c,
+	0x7641, 0x20a3, 0x1300, 0x20a3, 0x0000, 0x7828, 0x2068, 0x681c,
+	0xa086, 0x0003, 0x0580, 0x7818, 0xa080, 0x0028, 0x2014, 0x2001,
+	0xb535, 0x2004, 0xd0ac, 0x11d0, 0xa286, 0x007e, 0x1128, 0x20a3,
+	0x00ff, 0x20a3, 0xfffe, 0x04b8, 0xa286, 0x007f, 0x1128, 0x20a3,
+	0x00ff, 0x20a3, 0xfffd, 0x0478, 0xd2bc, 0x0180, 0xa286, 0x0080,
+	0x1128, 0x20a3, 0x00ff, 0x20a3, 0xfffc, 0x0428, 0xa2e8, 0xb635,
+	0x2d6c, 0x6810, 0x20a2, 0x6814, 0x20a2, 0x00e8, 0x20a3, 0x0000,
+	0x6098, 0x20a2, 0x00c0, 0x2001, 0xb535, 0x2004, 0xd0ac, 0x1138,
+	0x7818, 0xa080, 0x0028, 0x2004, 0xa082, 0x007e, 0x0240, 0x00d6,
+	0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0020, 0x20a3,
+	0x0000, 0x6034, 0x20a2, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x20a3,
+	0x0000, 0x20a3, 0x0000, 0x60c3, 0x000c, 0x080c, 0x7d67, 0x001e,
+	0x00de, 0x0005, 0x7817, 0x0001, 0x7803, 0x0006, 0x001e, 0x00de,
+	0x0005, 0x00d6, 0x0026, 0x7928, 0x2168, 0x691c, 0xa186, 0x0006,
+	0x01c0, 0xa186, 0x0003, 0x0904, 0x8478, 0xa186, 0x0005, 0x0904,
+	0x8461, 0xa186, 0x0004, 0x05b8, 0xa186, 0x0008, 0x0904, 0x8469,
+	0x7807, 0x0037, 0x7813, 0x1700, 0x080c, 0x84e0, 0x002e, 0x00de,
+	0x0005, 0x080c, 0x849c, 0x2009, 0x4000, 0x6800, 0x0002, 0x8442,
+	0x844d, 0x8444, 0x844d, 0x8449, 0x8442, 0x8442, 0x844d, 0x844d,
+	0x844d, 0x844d, 0x8442, 0x8442, 0x8442, 0x8442, 0x8442, 0x844d,
+	0x8442, 0x844d, 0x080c, 0x1515, 0x6820, 0xd0e4, 0x0110, 0xd0cc,
+	0x0110, 0xa00e, 0x0010, 0x2009, 0x2000, 0x6828, 0x20a2, 0x682c,
+	0x20a2, 0x0804, 0x8492, 0x080c, 0x849c, 0x20a3, 0x0000, 0x20a3,
+	0x0000, 0x2009, 0x4000, 0x6a00, 0xa286, 0x0002, 0x1108, 0xa00e,
+	0x0488, 0x04d1, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0x0448, 0x0491, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x2009, 0x4000,
+	0xa286, 0x0005, 0x0118, 0xa286, 0x0002, 0x1108, 0xa00e, 0x00d0,
+	0x0419, 0x6810, 0x2068, 0x697c, 0x6810, 0xa112, 0x6980, 0x6814,
+	0xa103, 0x20a2, 0x22a2, 0x7928, 0xa180, 0x0000, 0x2004, 0xa08e,
+	0x0002, 0x0130, 0xa08e, 0x0004, 0x0118, 0x2009, 0x4000, 0x0010,
+	0x2009, 0x0000, 0x21a2, 0x20a3, 0x0000, 0x60c3, 0x0018, 0x080c,
+	0x7d67, 0x002e, 0x00de, 0x0005, 0x0036, 0x0046, 0x0056, 0x0066,
+	0x20a1, 0x020b, 0x080c, 0x76dd, 0xa006, 0x20a3, 0x0200, 0x20a2,
+	0x7934, 0x21a2, 0x7938, 0x21a2, 0x7818, 0xa080, 0x0028, 0x2004,
+	0x2011, 0xb535, 0x2214, 0xd2ac, 0x1118, 0xa092, 0x007e, 0x0268,
+	0x00d6, 0x2069, 0xb51c, 0x2d2c, 0x8d68, 0x2d34, 0xa0e8, 0xb635,
+	0x2d6c, 0x6b10, 0x6c14, 0x00de, 0x0030, 0x2019, 0x0000, 0x6498,
+	0x2029, 0x0000, 0x6634, 0x7828, 0xa080, 0x0007, 0x2004, 0xa086,
+	0x0003, 0x1128, 0x25a2, 0x26a2, 0x23a2, 0x24a2, 0x0020, 0x23a2,
+	0x24a2, 0x25a2, 0x26a2, 0x006e, 0x005e, 0x004e, 0x003e, 0x0005,
+	0x20a1, 0x020b, 0x080c, 0x76dd, 0x20a3, 0x0100, 0x20a3, 0x0000,
+	0x20a3, 0x0009, 0x7810, 0x20a2, 0x60c3, 0x0008, 0x080c, 0x7d67,
+	0x0005, 0x20a1, 0x020b, 0x080c, 0x7639, 0x20a3, 0x1400, 0x20a3,
+	0x0000, 0x7834, 0x20a2, 0x7838, 0x20a2, 0x7828, 0x20a2, 0x782c,
+	0x20a2, 0x7830, 0xa084, 0x00ff, 0x8007, 0x20a2, 0x20a3, 0x0000,
+	0x60c3, 0x0010, 0x080c, 0x7d67, 0x0005, 0x20a1, 0x020b, 0x080c,
+	0x76d5, 0x20a3, 0x0100, 0x20a3, 0x0000, 0x7828, 0x20a2, 0x7810,
+	0x20a2, 0x60c3, 0x0008, 0x080c, 0x7d67, 0x0005, 0x0146, 0x20a1,
+	0x020b, 0x0031, 0x60c3, 0x0000, 0x080c, 0x7d67, 0x014e, 0x0005,
+	0x20e1, 0x9080, 0x20e1, 0x4000, 0x7818, 0xa080, 0x0028, 0x2004,
+	0x2011, 0xb535, 0x2214, 0xd2ac, 0x1110, 0xd0bc, 0x0188, 0x00d6,
+	0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x0300, 0x20a2, 0x6814,
+	0x20a2, 0x2069, 0xb51c, 0x2da6, 0x8d68, 0x2da6, 0x00de, 0x0078,
+	0x00d6, 0xa0e8, 0xb635, 0x2d6c, 0x6810, 0xa085, 0x0300, 0x20a2,
+	0x6814, 0x20a2, 0x00de, 0x20a3, 0x0000, 0x6234, 0x22a2, 0x20a3,
+	0x0819, 0x20a3, 0x0000, 0x080c, 0x7d56, 0x22a2, 0x20a3, 0x0000,
+	0x2fa2, 0x7a08, 0x22a2, 0x20a3, 0x0000, 0x20a3, 0x0000, 0x0005,
+	0x20a1, 0x020b, 0x0079, 0x7910, 0x21a2, 0x20a3, 0x0000, 0x60c3,
+	0x0000, 0x20e1, 0x9080, 0x60a7, 0x9575, 0x080c, 0x7d71, 0x080c,
+	0x6a07, 0x0005, 0x0156, 0x0136, 0x0036, 0x00d6, 0x00e6, 0x20e1,
+	0x9080, 0x20e1, 0x4000, 0x7854, 0x2068, 0xadf0, 0x000f, 0x7210,
+	0xa296, 0x00c0, 0xa294, 0xfffd, 0x7212, 0x7214, 0xa294, 0x0300,
+	0x7216, 0x7100, 0xa194, 0x00ff, 0x7308, 0xa384, 0x00ff, 0xa08d,
+	0xc200, 0x7102, 0xa384, 0xff00, 0xa215, 0x720a, 0x7004, 0x720c,
+	0x700e, 0x7206, 0x20a9, 0x000a, 0x2e98, 0x53a6, 0x60a3, 0x0035,
+	0x6a38, 0xa294, 0x7000, 0xa286, 0x3000, 0x0110, 0x60a3, 0x0037,
+	0x00ee, 0x00de, 0x003e, 0x013e, 0x015e, 0x0005, 0x2009, 0x0092,
+	0x0010, 0x2009, 0x0096, 0x60ab, 0x0036, 0x6116, 0x0005, 0x2061,
+	0xbd00, 0x2a70, 0x7068, 0x704a, 0x704f, 0xbd00, 0x0005, 0x00e6,
+	0x0126, 0x2071, 0xb500, 0x2091, 0x8000, 0x7548, 0xa582, 0x0010,
+	0x0608, 0x704c, 0x2060, 0x6000, 0xa086, 0x0000, 0x0148, 0xace0,
+	0x0018, 0x705c, 0xac02, 0x1208, 0x0cb0, 0x2061, 0xbd00, 0x0c98,
+	0x6003, 0x0008, 0x8529, 0x754a, 0xaca8, 0x0018, 0x705c, 0xa502,
+	0x1230, 0x754e, 0xa085, 0x0001, 0x012e, 0x00ee, 0x0005, 0x704f,
+	0xbd00, 0x0cc0, 0xa006, 0x0cc0, 0x00e6, 0x2071, 0xb500, 0x7548,
+	0xa582, 0x0010, 0x0600, 0x704c, 0x2060, 0x6000, 0xa086, 0x0000,
+	0x0148, 0xace0, 0x0018, 0x705c, 0xac02, 0x1208, 0x0cb0, 0x2061,
+	0xbd00, 0x0c98, 0x6003, 0x0008, 0x8529, 0x754a, 0xaca8, 0x0018,
+	0x705c, 0xa502, 0x1228, 0x754e, 0xa085, 0x0001, 0x00ee, 0x0005,
+	0x704f, 0xbd00, 0x0cc8, 0xa006, 0x0cc8, 0xac82, 0xbd00, 0x0a0c,
+	0x1515, 0x2001, 0xb517, 0x2004, 0xac02, 0x1a0c, 0x1515, 0xa006,
+	0x6006, 0x600a, 0x600e, 0x6012, 0x6016, 0x601a, 0x601f, 0x0000,
+	0x6003, 0x0000, 0x6052, 0x6056, 0x6022, 0x6026, 0x602a, 0x602e,
+	0x6032, 0x6036, 0x603a, 0x603e, 0x2061, 0xb500, 0x6048, 0x8000,
+	0x604a, 0xa086, 0x0001, 0x0108, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x7173, 0x012e, 0x0cc0, 0x601c, 0xa084, 0x000f, 0x0002,
+	0x865b, 0x866a, 0x8685, 0x86a0, 0xa152, 0xa16d, 0xa188, 0x865b,
+	0x866a, 0x865b, 0x86bb, 0xa186, 0x0013, 0x1128, 0x080c, 0x7090,
+	0x080c, 0x7173, 0x0005, 0xa18e, 0x0047, 0x1118, 0xa016, 0x080c,
+	0x185e, 0x0005, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x1515,
+	0x0013, 0x006e, 0x0005, 0x8683, 0x8a9b, 0x8c53, 0x8683, 0x8cc8,
+	0x8779, 0x8683, 0x8683, 0x8a2d, 0x90ef, 0x8683, 0x8683, 0x8683,
+	0x8683, 0x8683, 0x8683, 0x080c, 0x1515, 0x0066, 0x6000, 0xa0b2,
+	0x0010, 0x1a0c, 0x1515, 0x0013, 0x006e, 0x0005, 0x869e, 0x9722,
+	0x869e, 0x869e, 0x869e, 0x869e, 0x869e, 0x869e, 0x96cd, 0x988e,
+	0x869e, 0x974f, 0x97c6, 0x974f, 0x97c6, 0x869e, 0x080c, 0x1515,
+	0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x1515, 0x0013, 0x006e,
+	0x0005, 0x86b9, 0x9130, 0x91fa, 0x9335, 0x9491, 0x86b9, 0x86b9,
+	0x86b9, 0x910a, 0x967d, 0x9680, 0x86b9, 0x86b9, 0x86b9, 0x86b9,
+	0x96aa, 0x080c, 0x1515, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c,
+	0x1515, 0x0013, 0x006e, 0x0005, 0x86d4, 0x86d4, 0x86d4, 0x8702,
+	0x874f, 0x86d4, 0x86d4, 0x86d4, 0x86d6, 0x86d4, 0x86d4, 0x86d4,
+	0x86d4, 0x86d4, 0x86d4, 0x86d4, 0x080c, 0x1515, 0xa186, 0x0003,
+	0x190c, 0x1515, 0x00d6, 0x6003, 0x0003, 0x6106, 0x6010, 0x2068,
+	0x684f, 0x0040, 0x687c, 0x680a, 0x6880, 0x680e, 0x6813, 0x0000,
+	0x6817, 0x0000, 0x6854, 0xa092, 0x199a, 0x0210, 0x2001, 0x1999,
+	0x8003, 0x8013, 0x8213, 0xa210, 0x6216, 0x00de, 0x2c10, 0x080c,
+	0x1fa9, 0x080c, 0x6cf0, 0x0126, 0x2091, 0x8000, 0x080c, 0x7230,
+	0x012e, 0x0005, 0xa182, 0x0047, 0x0002, 0x870e, 0x870e, 0x8710,
+	0x8729, 0x870e, 0x870e, 0x870e, 0x870e, 0x873b, 0x080c, 0x1515,
+	0x00d6, 0x0016, 0x080c, 0x7126, 0x080c, 0x7230, 0x6003, 0x0004,
+	0x6110, 0x2168, 0x684f, 0x0020, 0x685c, 0x685a, 0x6874, 0x687e,
+	0x6878, 0x6882, 0x6897, 0x0000, 0x689b, 0x0000, 0x001e, 0x00de,
+	0x0005, 0x080c, 0x7126, 0x00d6, 0x6110, 0x2168, 0x080c, 0x9c5a,
+	0x0120, 0x684b, 0x0006, 0x080c, 0x5408, 0x00de, 0x080c, 0x861d,
+	0x080c, 0x7230, 0x0005, 0x080c, 0x7126, 0x080c, 0x2c9c, 0x00d6,
+	0x6110, 0x2168, 0x080c, 0x9c5a, 0x0120, 0x684b, 0x0029, 0x080c,
+	0x5408, 0x00de, 0x080c, 0x861d, 0x080c, 0x7230, 0x0005, 0xa182,
+	0x0047, 0x0002, 0x875d, 0x876c, 0x875b, 0x875b, 0x875b, 0x875b,
+	0x875b, 0x875b, 0x875b, 0x080c, 0x1515, 0x00d6, 0x6010, 0x2068,
+	0x684c, 0xc0f4, 0x684e, 0x00de, 0x20e1, 0x0005, 0x3d18, 0x3e20,
+	0x2c10, 0x080c, 0x185e, 0x0005, 0x00d6, 0x6110, 0x2168, 0x684b,
+	0x0000, 0x6853, 0x0000, 0x080c, 0x5408, 0x00de, 0x080c, 0x861d,
+	0x0005, 0xa1b6, 0x0015, 0x1118, 0x080c, 0x861d, 0x0030, 0xa1b6,
+	0x0016, 0x190c, 0x1515, 0x080c, 0x861d, 0x0005, 0x20a9, 0x000e,
+	0x2e98, 0x6010, 0x20a0, 0x53a3, 0x20a9, 0x0006, 0x3310, 0x3420,
+	0x9398, 0x94a0, 0x3318, 0x3428, 0x222e, 0x2326, 0xa290, 0x0002,
+	0xa5a8, 0x0002, 0xa398, 0x0002, 0xa4a0, 0x0002, 0x1f04, 0x8794,
+	0x00e6, 0x080c, 0x9c5a, 0x0130, 0x6010, 0x2070, 0x7007, 0x0000,
+	0x7037, 0x0103, 0x00ee, 0x080c, 0x861d, 0x0005, 0x00d6, 0x0036,
+	0x7330, 0xa386, 0x0200, 0x1130, 0x6018, 0x2068, 0x6813, 0x00ff,
+	0x6817, 0xfffd, 0x6010, 0xa005, 0x0130, 0x2068, 0x6807, 0x0000,
+	0x6837, 0x0103, 0x6b32, 0x080c, 0x861d, 0x003e, 0x00de, 0x0005,
+	0x0016, 0x20a9, 0x002a, 0xae80, 0x000c, 0x2098, 0x6010, 0xa080,
+	0x0002, 0x20a0, 0x53a3, 0x20a9, 0x002a, 0x6010, 0xa080, 0x0001,
+	0x2004, 0xa080, 0x0002, 0x20a0, 0x53a3, 0x00e6, 0x6010, 0x2004,
+	0x2070, 0x7037, 0x0103, 0x00ee, 0x080c, 0x861d, 0x001e, 0x0005,
+	0x0016, 0x2009, 0x0000, 0x7030, 0xa086, 0x0100, 0x0140, 0x7038,
+	0xa084, 0x00ff, 0x800c, 0x703c, 0xa084, 0x00ff, 0x8004, 0xa080,
+	0x0004, 0xa108, 0x21a8, 0xae80, 0x000c, 0x2098, 0x6010, 0xa080,
+	0x0002, 0x20a0, 0x080c, 0x4b8f, 0x00e6, 0x080c, 0x9c5a, 0x0140,
+	0x6010, 0x2070, 0x7007, 0x0000, 0x7034, 0x70b2, 0x7037, 0x0103,
+	0x00ee, 0x080c, 0x861d, 0x001e, 0x0005, 0x00e6, 0x00d6, 0x603f,
+	0x0000, 0x2c68, 0x0016, 0x2009, 0x0035, 0x080c, 0xa10a, 0x001e,
+	0x1168, 0x0026, 0x6228, 0x2268, 0x002e, 0x2071, 0xbb8c, 0x6b1c,
+	0xa386, 0x0003, 0x0130, 0xa386, 0x0006, 0x0128, 0x080c, 0x861d,
+	0x0020, 0x0031, 0x0010, 0x080c, 0x88f6, 0x00de, 0x00ee, 0x0005,
+	0x00f6, 0x6810, 0x2078, 0xa186, 0x0015, 0x0904, 0x88dd, 0xa18e,
+	0x0016, 0x1904, 0x88f4, 0x700c, 0xa08c, 0xff00, 0xa186, 0x1700,
+	0x0120, 0xa186, 0x0300, 0x1904, 0x88bc, 0x8fff, 0x1138, 0x6800,
+	0xa086, 0x000f, 0x0904, 0x88a0, 0x0804, 0x88f2, 0x6808, 0xa086,
+	0xffff, 0x1904, 0x88df, 0x784c, 0xa084, 0x0060, 0xa086, 0x0020,
+	0x1150, 0x797c, 0x7810, 0xa106, 0x1904, 0x88df, 0x7980, 0x7814,
+	0xa106, 0x1904, 0x88df, 0x080c, 0x9e11, 0x6858, 0x7852, 0x784c,
+	0xc0dc, 0xc0f4, 0xc0d4, 0x784e, 0x0026, 0xa00e, 0x6a14, 0x2001,
+	0x000a, 0x080c, 0x6b40, 0x7854, 0xa20a, 0x0208, 0x8011, 0x7a56,
+	0x82ff, 0x002e, 0x1138, 0x00c6, 0x2d60, 0x080c, 0x9a09, 0x00ce,
+	0x0804, 0x88f2, 0x00c6, 0x00d6, 0x2f68, 0x6838, 0xd0fc, 0x1118,
+	0x080c, 0x4c64, 0x0010, 0x080c, 0x4e49, 0x00de, 0x00ce, 0x1904,
+	0x88df, 0x00c6, 0x2d60, 0x080c, 0x861d, 0x00ce, 0x0804, 0x88f2,
+	0x00c6, 0x080c, 0x9ed6, 0x0190, 0x6013, 0x0000, 0x6818, 0x601a,
+	0x080c, 0xa027, 0x601f, 0x0003, 0x6904, 0x00c6, 0x2d60, 0x080c,
+	0x861d, 0x00ce, 0x080c, 0x864c, 0x00ce, 0x04e0, 0x2001, 0xb7b8,
+	0x2004, 0x683e, 0x00ce, 0x04b0, 0x7008, 0xa086, 0x000b, 0x11a0,
+	0x6018, 0x200c, 0xc1bc, 0x2102, 0x00c6, 0x2d60, 0x7853, 0x0003,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x6c8d,
+	0x080c, 0x7173, 0x00ce, 0x00f0, 0x700c, 0xa086, 0x2a00, 0x1138,
+	0x2001, 0xb7b8, 0x2004, 0x683e, 0x00a8, 0x0481, 0x00a8, 0x8fff,
+	0x090c, 0x1515, 0x00c6, 0x00d6, 0x2d60, 0x2f68, 0x6837, 0x0103,
+	0x684b, 0x0003, 0x080c, 0x98fd, 0x080c, 0x9e11, 0x080c, 0x9e1d,
+	0x00de, 0x00ce, 0x080c, 0x861d, 0x00fe, 0x0005, 0xa186, 0x0015,
+	0x1128, 0x2001, 0xb7b8, 0x2004, 0x683e, 0x0068, 0xa18e, 0x0016,
+	0x1160, 0x00c6, 0x2d00, 0x2060, 0x080c, 0xb33a, 0x080c, 0x6aef,
+	0x080c, 0x861d, 0x00ce, 0x080c, 0x861d, 0x0005, 0x0026, 0x0036,
+	0x0046, 0x7228, 0x7c80, 0x7b7c, 0xd2f4, 0x0130, 0x2001, 0xb7b8,
+	0x2004, 0x683e, 0x0804, 0x8970, 0x00c6, 0x2d60, 0x080c, 0x991d,
+	0x00ce, 0x6804, 0xa086, 0x0050, 0x1168, 0x00c6, 0x2d00, 0x2060,
+	0x6003, 0x0001, 0x6007, 0x0050, 0x080c, 0x6c8d, 0x080c, 0x7173,
+	0x00ce, 0x04f0, 0x6800, 0xa086, 0x000f, 0x01c8, 0x8fff, 0x090c,
+	0x1515, 0x6820, 0xd0dc, 0x1198, 0x6800, 0xa086, 0x0004, 0x1198,
+	0x784c, 0xd0ac, 0x0180, 0x784c, 0xc0dc, 0xc0f4, 0x784e, 0x7850,
+	0xc0f4, 0xc0fc, 0x7852, 0x2001, 0x0001, 0x682e, 0x00e0, 0x2001,
+	0x0007, 0x682e, 0x00c0, 0x784c, 0xd0b4, 0x1130, 0xd0ac, 0x0db8,
+	0x784c, 0xd0f4, 0x1da0, 0x0c38, 0xd2ec, 0x1d88, 0x7024, 0xa306,
+	0x1118, 0x7020, 0xa406, 0x0d58, 0x7020, 0x6836, 0x7024, 0x683a,
+	0x2001, 0x0005, 0x682e, 0x080c, 0x9f63, 0x080c, 0x7173, 0x0010,
+	0x080c, 0x861d, 0x004e, 0x003e, 0x002e, 0x0005, 0x00e6, 0x00d6,
+	0x0026, 0x6034, 0x2068, 0x6a1c, 0xa286, 0x0007, 0x0904, 0x89d4,
+	0xa286, 0x0002, 0x0904, 0x89d4, 0xa286, 0x0000, 0x0904, 0x89d4,
+	0x6808, 0x6338, 0xa306, 0x1904, 0x89d4, 0x2071, 0xbb8c, 0xa186,
+	0x0015, 0x05e0, 0xa18e, 0x0016, 0x1190, 0x6030, 0xa084, 0x00ff,
+	0xa086, 0x0001, 0x1160, 0x700c, 0xa086, 0x2a00, 0x1140, 0x6034,
+	0xa080, 0x0008, 0x200c, 0xc1dd, 0xc1f5, 0x2102, 0x0438, 0x00c6,
+	0x6034, 0x2060, 0x6104, 0xa186, 0x004b, 0x01a0, 0xa186, 0x004c,
+	0x0188, 0xa186, 0x004d, 0x0170, 0xa186, 0x004e, 0x0158, 0xa186,
+	0x0052, 0x0140, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x090c, 0x1515,
+	0x6853, 0x0003, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002,
+	0x080c, 0x6c8d, 0x080c, 0x7173, 0x00ce, 0x0030, 0x6034, 0x2070,
+	0x2001, 0xb7b8, 0x2004, 0x703e, 0x080c, 0x861d, 0x002e, 0x00de,
+	0x00ee, 0x0005, 0x00d6, 0x20a9, 0x000e, 0x2e98, 0x6010, 0x20a0,
+	0x53a3, 0xa1b6, 0x0015, 0x1558, 0x6018, 0x2068, 0x0156, 0x0036,
+	0x0026, 0xae90, 0x000c, 0xa290, 0x0004, 0x20a9, 0x0004, 0xad98,
+	0x000a, 0x080c, 0x90da, 0x002e, 0x003e, 0x015e, 0x11d8, 0x0156,
+	0x0036, 0x0026, 0xae90, 0x000c, 0xa290, 0x0008, 0x20a9, 0x0004,
+	0xad98, 0x0006, 0x080c, 0x90da, 0x002e, 0x003e, 0x015e, 0x1150,
+	0x7038, 0x680a, 0x703c, 0x680e, 0x6800, 0xc08d, 0x6802, 0x00de,
+	0x0804, 0x87a0, 0x080c, 0x2c9c, 0x00c6, 0x080c, 0x85c7, 0x2f00,
+	0x601a, 0x6013, 0x0000, 0x601f, 0x0001, 0x6007, 0x0001, 0x6003,
+	0x0001, 0x2001, 0x0007, 0x080c, 0x4efd, 0x080c, 0x4f2a, 0x080c,
+	0x6cd3, 0x080c, 0x7173, 0x00ce, 0x0c10, 0x2100, 0xa1b2, 0x0080,
+	0x1a0c, 0x1515, 0xa1b2, 0x0040, 0x1a04, 0x8a91, 0x0002, 0x8a85,
+	0x8a79, 0x8a85, 0x8a85, 0x8a85, 0x8a85, 0x8a77, 0x8a77, 0x8a77,
+	0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77,
+	0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77,
+	0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a85, 0x8a77,
+	0x8a85, 0x8a85, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a85,
+	0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77,
+	0x8a77, 0x8a85, 0x8a85, 0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a77,
+	0x8a77, 0x8a77, 0x8a77, 0x8a77, 0x8a85, 0x8a77, 0x8a77, 0x080c,
+	0x1515, 0x6003, 0x0001, 0x6106, 0x080c, 0x6cd3, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x7173, 0x012e, 0x0005, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x6cd3, 0x0126, 0x2091, 0x8000, 0x080c, 0x7173, 0x012e,
+	0x0005, 0x2600, 0x0002, 0x8a85, 0x8a85, 0x8a99, 0x8a85, 0x8a85,
+	0x8a99, 0x080c, 0x1515, 0x6004, 0xa0b2, 0x0080, 0x1a0c, 0x1515,
+	0xa1b6, 0x0013, 0x0904, 0x8b4b, 0xa1b6, 0x0027, 0x1904, 0x8b11,
+	0x080c, 0x7090, 0x6004, 0x080c, 0x9e47, 0x0190, 0x080c, 0x9e58,
+	0x0904, 0x8b0b, 0xa08e, 0x0021, 0x0904, 0x8b0e, 0xa08e, 0x0022,
+	0x0904, 0x8b0b, 0xa08e, 0x003d, 0x0904, 0x8b0e, 0x0804, 0x8b04,
+	0x080c, 0x2cc2, 0x2001, 0x0007, 0x080c, 0x4efd, 0x6018, 0xa080,
+	0x0028, 0x200c, 0x080c, 0x8c19, 0xa186, 0x007e, 0x1148, 0x2001,
+	0xb535, 0x2014, 0xc285, 0x080c, 0x5acf, 0x1108, 0xc2ad, 0x2202,
+	0x0016, 0x0026, 0x0036, 0x2110, 0x0026, 0x2019, 0x0028, 0x080c,
+	0x8299, 0x002e, 0x080c, 0xb38d, 0x003e, 0x002e, 0x001e, 0x0016,
+	0x0026, 0x0036, 0x2110, 0x2019, 0x0028, 0x080c, 0x6df5, 0x0076,
+	0x2039, 0x0000, 0x080c, 0x6d02, 0x00c6, 0x6018, 0xa065, 0x0110,
+	0x080c, 0x51aa, 0x00ce, 0x2c08, 0x080c, 0xae82, 0x007e, 0x003e,
+	0x002e, 0x001e, 0x080c, 0x4f6c, 0x080c, 0xa01f, 0x080c, 0x861d,
+	0x080c, 0x7173, 0x0005, 0x080c, 0x8c19, 0x0cb0, 0x080c, 0x8c47,
+	0x0c98, 0xa186, 0x0014, 0x1db0, 0x080c, 0x7090, 0x080c, 0x2c9c,
+	0x080c, 0x9e47, 0x1188, 0x080c, 0x2cc2, 0x6018, 0xa080, 0x0028,
+	0x200c, 0x080c, 0x8c19, 0xa186, 0x007e, 0x1128, 0x2001, 0xb535,
+	0x200c, 0xc185, 0x2102, 0x08c0, 0x080c, 0x9e58, 0x1118, 0x080c,
+	0x8c19, 0x0890, 0x6004, 0xa08e, 0x0032, 0x1158, 0x00e6, 0x00f6,
+	0x2071, 0xb582, 0x2079, 0x0000, 0x080c, 0x2fcf, 0x00fe, 0x00ee,
+	0x0818, 0x6004, 0xa08e, 0x0021, 0x0d50, 0xa08e, 0x0022, 0x090c,
+	0x8c19, 0x0804, 0x8b04, 0xa0b2, 0x0040, 0x1a04, 0x8c0e, 0x2008,
+	0x0002, 0x8b93, 0x8b94, 0x8b97, 0x8b9a, 0x8b9d, 0x8ba0, 0x8b91,
+	0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91,
+	0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91,
+	0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8ba3,
+	0x8bb2, 0x8b91, 0x8bb4, 0x8bb2, 0x8b91, 0x8b91, 0x8b91, 0x8b91,
+	0x8b91, 0x8bb2, 0x8bb2, 0x8b91, 0x8b91, 0x8b91, 0x8b91, 0x8b91,
+	0x8b91, 0x8b91, 0x8b91, 0x8bee, 0x8bb2, 0x8b91, 0x8bae, 0x8b91,
+	0x8b91, 0x8b91, 0x8baf, 0x8b91, 0x8b91, 0x8b91, 0x8bb2, 0x8be5,
+	0x8b91, 0x080c, 0x1515, 0x00f0, 0x2001, 0x000b, 0x0460, 0x2001,
+	0x0003, 0x0448, 0x2001, 0x0005, 0x0430, 0x2001, 0x0001, 0x0418,
+	0x2001, 0x0009, 0x0400, 0x080c, 0x7090, 0x6003, 0x0005, 0x2001,
+	0xb7b8, 0x2004, 0x603e, 0x080c, 0x7173, 0x00a0, 0x0018, 0x0010,
+	0x080c, 0x4efd, 0x0804, 0x8bff, 0x080c, 0x7090, 0x2001, 0xb7b6,
+	0x2004, 0x6016, 0x2001, 0xb7b8, 0x2004, 0x603e, 0x6003, 0x0004,
+	0x080c, 0x7173, 0x0005, 0x080c, 0x4efd, 0x080c, 0x7090, 0x6003,
+	0x0002, 0x2001, 0xb7b8, 0x2004, 0x603e, 0x0036, 0x2019, 0xb55d,
+	0x2304, 0xa084, 0xff00, 0x1120, 0x2001, 0xb7b6, 0x201c, 0x0040,
+	0x8007, 0xa09a, 0x0004, 0x0ec0, 0x8003, 0x801b, 0x831b, 0xa318,
+	0x6316, 0x003e, 0x080c, 0x7173, 0x08e8, 0x080c, 0x7090, 0x080c,
+	0xa01f, 0x080c, 0x861d, 0x080c, 0x7173, 0x08a0, 0x00e6, 0x00f6,
+	0x2071, 0xb582, 0x2079, 0x0000, 0x080c, 0x2fcf, 0x00fe, 0x00ee,
+	0x080c, 0x7090, 0x080c, 0x861d, 0x080c, 0x7173, 0x0818, 0x080c,
+	0x7090, 0x2001, 0xb7b8, 0x2004, 0x603e, 0x6003, 0x0002, 0x2001,
+	0xb7b6, 0x2004, 0x6016, 0x080c, 0x7173, 0x0005, 0x2600, 0x2008,
+	0x0002, 0x8c17, 0x8c17, 0x8c17, 0x8bff, 0x8bff, 0x8c17, 0x080c,
+	0x1515, 0x00e6, 0x0026, 0x0016, 0x080c, 0x9c5a, 0x0508, 0x6010,
+	0x2070, 0x7034, 0xa086, 0x0139, 0x1148, 0x2001, 0x0030, 0x2009,
+	0x0000, 0x2011, 0x4005, 0x080c, 0xa0d6, 0x0090, 0x7038, 0xd0fc,
+	0x0178, 0x7007, 0x0000, 0x0016, 0x6004, 0xa08e, 0x0021, 0x0160,
+	0xa08e, 0x003d, 0x0148, 0x001e, 0x7037, 0x0103, 0x7033, 0x0100,
+	0x001e, 0x002e, 0x00ee, 0x0005, 0x001e, 0x0009, 0x0cc8, 0x00e6,
+	0xacf0, 0x0004, 0x2e74, 0x7000, 0x2070, 0x7037, 0x0103, 0x7023,
+	0x8001, 0x00ee, 0x0005, 0x00d6, 0x6618, 0x2668, 0x6804, 0xa084,
+	0x00ff, 0x00de, 0xa0b2, 0x000c, 0x1a0c, 0x1515, 0x6604, 0xa6b6,
+	0x0043, 0x1120, 0x080c, 0xa092, 0x0804, 0x8cb8, 0x6604, 0xa6b6,
+	0x0033, 0x1120, 0x080c, 0xa042, 0x0804, 0x8cb8, 0x6604, 0xa6b6,
+	0x0028, 0x1120, 0x080c, 0x9e88, 0x0804, 0x8cb8, 0x6604, 0xa6b6,
+	0x0029, 0x1118, 0x080c, 0x9e9f, 0x04d8, 0x6604, 0xa6b6, 0x001f,
+	0x1118, 0x080c, 0x8786, 0x04a0, 0x6604, 0xa6b6, 0x0000, 0x1118,
+	0x080c, 0x89da, 0x0468, 0x6604, 0xa6b6, 0x0022, 0x1118, 0x080c,
+	0x87ae, 0x0430, 0x6604, 0xa6b6, 0x0035, 0x1118, 0x080c, 0x8815,
+	0x00f8, 0x6604, 0xa6b6, 0x0039, 0x1118, 0x080c, 0x8976, 0x00c0,
+	0x6604, 0xa6b6, 0x003d, 0x1118, 0x080c, 0x87c8, 0x0088, 0x6604,
+	0xa6b6, 0x0044, 0x1118, 0x080c, 0x87e8, 0x0050, 0xa1b6, 0x0015,
+	0x1110, 0x0053, 0x0028, 0xa1b6, 0x0016, 0x1118, 0x0804, 0x8e7c,
+	0x0005, 0x080c, 0x8663, 0x0ce0, 0x8cdf, 0x8ce2, 0x8cdf, 0x8d24,
+	0x8cdf, 0x8e09, 0x8e8a, 0x8cdf, 0x8cdf, 0x8e58, 0x8cdf, 0x8e6c,
+	0xa1b6, 0x0048, 0x0140, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10,
+	0x080c, 0x185e, 0x0005, 0x00e6, 0xacf0, 0x0004, 0x2e74, 0x7000,
+	0x2070, 0x7037, 0x0103, 0x00ee, 0x080c, 0x861d, 0x0005, 0xe000,
+	0xe000, 0x0005, 0x00e6, 0x2071, 0xb500, 0x7084, 0xa086, 0x0074,
+	0x1530, 0x080c, 0xae59, 0x11b0, 0x00d6, 0x6018, 0x2068, 0x7030,
+	0xd08c, 0x0128, 0x6800, 0xd0bc, 0x0110, 0xc0c5, 0x6802, 0x00d9,
+	0x00de, 0x2001, 0x0006, 0x080c, 0x4efd, 0x080c, 0x2cc2, 0x080c,
+	0x861d, 0x0078, 0x2001, 0x000a, 0x080c, 0x4efd, 0x080c, 0x2cc2,
+	0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x6cd3, 0x0010, 0x080c,
+	0x8df6, 0x00ee, 0x0005, 0x6800, 0xd084, 0x0168, 0x2001, 0x0000,
+	0x080c, 0x4eeb, 0x2069, 0xb552, 0x6804, 0xd0a4, 0x0120, 0x2001,
+	0x0006, 0x080c, 0x4f2a, 0x0005, 0x00d6, 0x2011, 0xb521, 0x2204,
+	0xa086, 0x0074, 0x1904, 0x8df3, 0x6018, 0x2068, 0x6aa0, 0xa286,
+	0x007e, 0x1120, 0x080c, 0x8fa2, 0x0804, 0x8d92, 0x080c, 0x8f98,
+	0x6018, 0x2068, 0xa080, 0x0028, 0x2014, 0xa286, 0x0080, 0x11c0,
+	0x6813, 0x00ff, 0x6817, 0xfffc, 0x6010, 0xa005, 0x0138, 0x2068,
+	0x6807, 0x0000, 0x6837, 0x0103, 0x6833, 0x0200, 0x2001, 0x0006,
+	0x080c, 0x4efd, 0x080c, 0x2cc2, 0x080c, 0x861d, 0x0804, 0x8df4,
+	0x00e6, 0x2071, 0xb535, 0x2e04, 0xd09c, 0x0188, 0x2071, 0xbb80,
+	0x7108, 0x720c, 0xa18c, 0x00ff, 0x1118, 0xa284, 0xff00, 0x0138,
+	0x6018, 0x2070, 0x70a0, 0xd0bc, 0x1110, 0x7112, 0x7216, 0x00ee,
+	0x6010, 0xa005, 0x0198, 0x2068, 0x6838, 0xd0f4, 0x0178, 0x6834,
+	0xa084, 0x00ff, 0xa086, 0x0039, 0x1958, 0x2001, 0x0000, 0x2009,
+	0x0000, 0x2011, 0x4000, 0x080c, 0xa0d6, 0x0840, 0x2001, 0x0004,
+	0x080c, 0x4efd, 0x6003, 0x0001, 0x6007, 0x0003, 0x080c, 0x6cd3,
+	0x0804, 0x8df4, 0x685c, 0xd0e4, 0x01d8, 0x080c, 0x9fd2, 0x080c,
+	0x5acf, 0x0118, 0xd0dc, 0x1904, 0x8d4e, 0x2011, 0xb535, 0x2204,
+	0xc0ad, 0x2012, 0x2001, 0xb78f, 0x2004, 0x00f6, 0x2079, 0x0100,
+	0x78e3, 0x0000, 0x080c, 0x2872, 0x78e2, 0x00fe, 0x0804, 0x8d4e,
+	0x080c, 0xa008, 0x2011, 0xb535, 0x2204, 0xc0a5, 0x2012, 0x0006,
+	0x080c, 0xaf7b, 0x000e, 0x1904, 0x8d4e, 0xc0b5, 0x2012, 0x2001,
+	0x0006, 0x080c, 0x4efd, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x00c6,
+	0x2009, 0x00ef, 0x00f6, 0x2079, 0x0100, 0x79ea, 0x7932, 0x7936,
+	0x00fe, 0x080c, 0x2847, 0x00f6, 0x2079, 0xb500, 0x7976, 0x2100,
+	0x2009, 0x0000, 0x080c, 0x281d, 0x7952, 0x00fe, 0x8108, 0x080c,
+	0x4f4d, 0x2c00, 0x00ce, 0x1904, 0x8d4e, 0x601a, 0x2001, 0x0002,
+	0x080c, 0x4efd, 0x601f, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002,
+	0x080c, 0x6cd3, 0x0008, 0x0011, 0x00de, 0x0005, 0x2001, 0x0007,
+	0x080c, 0x4efd, 0x2001, 0xb500, 0x2004, 0xa086, 0x0003, 0x1120,
+	0x2001, 0x0007, 0x080c, 0x4f2a, 0x080c, 0x2cc2, 0x080c, 0x861d,
+	0x0005, 0x00e6, 0x0026, 0x0016, 0x2071, 0xb500, 0x7084, 0xa086,
+	0x0014, 0x15f0, 0x7000, 0xa086, 0x0003, 0x1128, 0x6010, 0xa005,
+	0x1110, 0x080c, 0x3f3e, 0x00d6, 0x6018, 0x2068, 0x080c, 0x504b,
+	0x080c, 0x8d13, 0x00de, 0x080c, 0x9051, 0x1550, 0x00d6, 0x6018,
+	0x2068, 0x6890, 0x00de, 0xa005, 0x0518, 0x2001, 0x0006, 0x080c,
+	0x4efd, 0x00e6, 0x6010, 0xa075, 0x01a8, 0x7034, 0xa084, 0x00ff,
+	0xa086, 0x0039, 0x1148, 0x2001, 0x0000, 0x2009, 0x0000, 0x2011,
+	0x4000, 0x080c, 0xa0d6, 0x0030, 0x7007, 0x0000, 0x7037, 0x0103,
+	0x7033, 0x0200, 0x00ee, 0x080c, 0x2cc2, 0x080c, 0x861d, 0x0020,
+	0x080c, 0x8c19, 0x080c, 0x8df6, 0x001e, 0x002e, 0x00ee, 0x0005,
+	0x2011, 0xb521, 0x2204, 0xa086, 0x0014, 0x1158, 0x2001, 0x0002,
+	0x080c, 0x4efd, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x6cd3,
+	0x0010, 0x080c, 0x8df6, 0x0005, 0x2011, 0xb521, 0x2204, 0xa086,
+	0x0004, 0x1138, 0x2001, 0x0007, 0x080c, 0x4efd, 0x080c, 0x861d,
+	0x0010, 0x080c, 0x8df6, 0x0005, 0x000b, 0x0005, 0x8cdf, 0x8e95,
+	0x8cdf, 0x8ec9, 0x8cdf, 0x8f54, 0x8e8a, 0x8cdf, 0x8cdf, 0x8f67,
+	0x8cdf, 0x8f77, 0x6604, 0xa686, 0x0003, 0x0904, 0x8e09, 0xa6b6,
+	0x001e, 0x1110, 0x080c, 0x861d, 0x0005, 0x00d6, 0x00c6, 0x080c,
+	0x8f87, 0x1178, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001, 0x0002,
+	0x080c, 0x4efd, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x6cd3,
+	0x00e8, 0x2009, 0xbb8e, 0x2104, 0xa086, 0x0009, 0x1160, 0x6018,
+	0x2068, 0x6840, 0xa084, 0x00ff, 0xa005, 0x0170, 0x8001, 0x6842,
+	0x6017, 0x000a, 0x0058, 0x2009, 0xbb8f, 0x2104, 0xa084, 0xff00,
+	0xa086, 0x1900, 0x1108, 0x08d0, 0x080c, 0x8df6, 0x00ce, 0x00de,
+	0x0005, 0x0026, 0x2011, 0x0000, 0x080c, 0x8f95, 0x00d6, 0x2069,
+	0xb79e, 0x2d04, 0xa005, 0x0168, 0x6018, 0x2068, 0x68a0, 0xa086,
+	0x007e, 0x1138, 0x2069, 0xb51d, 0x2d04, 0x8000, 0x206a, 0x00de,
+	0x0010, 0x00de, 0x0078, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001,
+	0x0002, 0x080c, 0x4efd, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c,
+	0x6cd3, 0x0480, 0x00d6, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x00de,
+	0x0108, 0x6a34, 0x080c, 0x8c19, 0x2009, 0xbb8e, 0x2134, 0xa6b4,
+	0x00ff, 0xa686, 0x0005, 0x0500, 0xa686, 0x000b, 0x01c8, 0x2009,
+	0xbb8f, 0x2104, 0xa084, 0xff00, 0x1118, 0xa686, 0x0009, 0x01a0,
+	0xa086, 0x1900, 0x1168, 0xa686, 0x0009, 0x0170, 0x2001, 0x0004,
+	0x080c, 0x4efd, 0x2001, 0x0028, 0x6016, 0x6007, 0x004b, 0x0010,
+	0x080c, 0x8df6, 0x002e, 0x0005, 0x00d6, 0xa286, 0x0139, 0x0160,
+	0x6010, 0x2068, 0x080c, 0x9c5a, 0x0148, 0x6834, 0xa086, 0x0139,
+	0x0118, 0x6838, 0xd0fc, 0x0110, 0x00de, 0x0c50, 0x6018, 0x2068,
+	0x6840, 0xa084, 0x00ff, 0xa005, 0x0140, 0x8001, 0x6842, 0x6017,
+	0x000a, 0x6007, 0x0016, 0x00de, 0x08e8, 0x68a0, 0xa086, 0x007e,
+	0x1138, 0x00e6, 0x2071, 0xb500, 0x080c, 0x4bc6, 0x00ee, 0x0010,
+	0x080c, 0x2c9c, 0x00de, 0x0860, 0x080c, 0x8f95, 0x1158, 0x2001,
+	0x0004, 0x080c, 0x4efd, 0x6003, 0x0001, 0x6007, 0x0003, 0x080c,
+	0x6cd3, 0x0020, 0x080c, 0x8c19, 0x080c, 0x8df6, 0x0005, 0x0469,
+	0x1158, 0x2001, 0x0008, 0x080c, 0x4efd, 0x6003, 0x0001, 0x6007,
+	0x0005, 0x080c, 0x6cd3, 0x0010, 0x080c, 0x8df6, 0x0005, 0x00e9,
+	0x1158, 0x2001, 0x000a, 0x080c, 0x4efd, 0x6003, 0x0001, 0x6007,
+	0x0001, 0x080c, 0x6cd3, 0x0010, 0x080c, 0x8df6, 0x0005, 0x2009,
+	0xbb8e, 0x2104, 0xa086, 0x0003, 0x1138, 0x2009, 0xbb8f, 0x2104,
+	0xa084, 0xff00, 0xa086, 0x2a00, 0x0005, 0xa085, 0x0001, 0x0005,
+	0x00c6, 0x0016, 0xac88, 0x0006, 0x2164, 0x080c, 0x4fb8, 0x001e,
+	0x00ce, 0x0005, 0x00f6, 0x00e6, 0x00d6, 0x0036, 0x0016, 0x6018,
+	0x2068, 0x2071, 0xb535, 0x2e04, 0xa085, 0x0003, 0x2072, 0x080c,
+	0x9026, 0x0560, 0x2009, 0xb535, 0x2104, 0xc0cd, 0x200a, 0x2001,
+	0xb553, 0x2004, 0xd0a4, 0x0158, 0xa006, 0x2020, 0x2009, 0x002a,
+	0x080c, 0xb0e8, 0x2001, 0xb50c, 0x200c, 0xc195, 0x2102, 0x2019,
+	0x002a, 0x2009, 0x0001, 0x080c, 0x2c6f, 0x2071, 0xb500, 0x080c,
+	0x2ab8, 0x00c6, 0x0156, 0x20a9, 0x0081, 0x2009, 0x007f, 0x080c,
+	0x2d97, 0x8108, 0x1f04, 0x8fd7, 0x015e, 0x00ce, 0x080c, 0x8f98,
+	0x6813, 0x00ff, 0x6817, 0xfffe, 0x2071, 0xbb80, 0x2079, 0x0100,
+	0x2e04, 0xa084, 0x00ff, 0x2069, 0xb51c, 0x206a, 0x78e6, 0x0006,
+	0x8e70, 0x2e04, 0x2069, 0xb51d, 0x206a, 0x78ea, 0x7832, 0x7836,
+	0x2010, 0xa084, 0xff00, 0x001e, 0xa105, 0x2009, 0xb528, 0x200a,
+	0x2200, 0xa084, 0x00ff, 0x2008, 0x080c, 0x2847, 0x080c, 0x5acf,
+	0x0170, 0x2069, 0xbb8e, 0x2071, 0xb7b2, 0x6810, 0x2072, 0x6814,
+	0x7006, 0x6818, 0x700a, 0x681c, 0x700e, 0x080c, 0x9fd2, 0x0040,
+	0x2001, 0x0006, 0x080c, 0x4efd, 0x080c, 0x2cc2, 0x080c, 0x861d,
+	0x001e, 0x003e, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x0026, 0x0036,
+	0x00e6, 0x0156, 0x2019, 0xb528, 0x231c, 0x83ff, 0x01e8, 0x2071,
+	0xbb80, 0x2e14, 0xa294, 0x00ff, 0x7004, 0xa084, 0xff00, 0xa205,
+	0xa306, 0x1190, 0x2011, 0xbb96, 0xad98, 0x000a, 0x20a9, 0x0004,
+	0x080c, 0x90da, 0x1148, 0x2011, 0xbb9a, 0xad98, 0x0006, 0x20a9,
+	0x0004, 0x080c, 0x90da, 0x1100, 0x015e, 0x00ee, 0x003e, 0x002e,
+	0x0005, 0x00e6, 0x2071, 0xbb8c, 0x7004, 0xa086, 0x0014, 0x11a8,
+	0x7008, 0xa086, 0x0800, 0x1188, 0x700c, 0xd0ec, 0x0160, 0xa084,
+	0x0f00, 0xa086, 0x0100, 0x1138, 0x7024, 0xd0a4, 0x1110, 0xd0ac,
+	0x0110, 0xa006, 0x0010, 0xa085, 0x0001, 0x00ee, 0x0005, 0x00e6,
+	0x00d6, 0x00c6, 0x0076, 0x0056, 0x0046, 0x0026, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2029, 0xb7e9, 0x252c, 0x2021, 0xb7ef, 0x2424,
+	0x2061, 0xbd00, 0x2071, 0xb500, 0x7248, 0x7068, 0xa202, 0x16f0,
+	0x080c, 0xb110, 0x05a0, 0x671c, 0xa786, 0x0001, 0x0580, 0xa786,
+	0x0007, 0x0568, 0x2500, 0xac06, 0x0550, 0x2400, 0xac06, 0x0538,
+	0x00c6, 0x6000, 0xa086, 0x0004, 0x1110, 0x080c, 0x194d, 0xa786,
+	0x0008, 0x1148, 0x080c, 0x9e58, 0x1130, 0x00ce, 0x080c, 0x8c19,
+	0x080c, 0x9e1d, 0x00a0, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0160,
+	0xa786, 0x0003, 0x11e8, 0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000,
+	0x080c, 0x5408, 0x080c, 0x9e11, 0x080c, 0x9e1d, 0x00ce, 0xace0,
+	0x0018, 0x705c, 0xac02, 0x1210, 0x0804, 0x9084, 0x012e, 0x000e,
+	0x002e, 0x004e, 0x005e, 0x007e, 0x00ce, 0x00de, 0x00ee, 0x0005,
+	0xa786, 0x0006, 0x1118, 0x080c, 0xb099, 0x0c30, 0xa786, 0x000a,
+	0x09e0, 0x08c8, 0x220c, 0x2304, 0xa106, 0x1130, 0x8210, 0x8318,
+	0x1f04, 0x90da, 0xa006, 0x0005, 0x2304, 0xa102, 0x0218, 0x2001,
+	0x0001, 0x0010, 0x2001, 0x0000, 0xa18d, 0x0001, 0x0005, 0x6004,
+	0xa08a, 0x0080, 0x1a0c, 0x1515, 0x080c, 0x9e47, 0x0120, 0x080c,
+	0x9e58, 0x0168, 0x0028, 0x080c, 0x2cc2, 0x080c, 0x9e58, 0x0138,
+	0x080c, 0x7090, 0x080c, 0x861d, 0x080c, 0x7173, 0x0005, 0x080c,
+	0x8c19, 0x0cb0, 0xa182, 0x0040, 0x0002, 0x9120, 0x9120, 0x9120,
+	0x9120, 0x9120, 0x9120, 0x9120, 0x9120, 0x9120, 0x9120, 0x9120,
+	0x9122, 0x9122, 0x9122, 0x9122, 0x9120, 0x9120, 0x9120, 0x9122,
+	0x080c, 0x1515, 0x600b, 0xffff, 0x6003, 0x0001, 0x6106, 0x080c,
+	0x6c8d, 0x0126, 0x2091, 0x8000, 0x080c, 0x7173, 0x012e, 0x0005,
+	0xa186, 0x0013, 0x1128, 0x6004, 0xa082, 0x0040, 0x0804, 0x91bc,
+	0xa186, 0x0027, 0x11e8, 0x080c, 0x7090, 0x080c, 0x2c9c, 0x00d6,
+	0x6110, 0x2168, 0x080c, 0x9c5a, 0x0168, 0x6837, 0x0103, 0x684b,
+	0x0029, 0x6847, 0x0000, 0x694c, 0xc1c5, 0x694e, 0x080c, 0x5408,
+	0x080c, 0x9e11, 0x00de, 0x080c, 0x861d, 0x080c, 0x7173, 0x0005,
+	0xa186, 0x0014, 0x1120, 0x6004, 0xa082, 0x0040, 0x0428, 0xa186,
+	0x0046, 0x0138, 0xa186, 0x0045, 0x0120, 0xa186, 0x0047, 0x190c,
+	0x1515, 0x2001, 0x0109, 0x2004, 0xd084, 0x0198, 0x0126, 0x2091,
+	0x2800, 0x0006, 0x0016, 0x0026, 0x080c, 0x6b74, 0x002e, 0x001e,
+	0x000e, 0x012e, 0xe000, 0x6000, 0xa086, 0x0002, 0x1110, 0x0804,
+	0x91fa, 0x080c, 0x8663, 0x0005, 0x0002, 0x919a, 0x9198, 0x9198,
+	0x9198, 0x9198, 0x9198, 0x9198, 0x9198, 0x9198, 0x9198, 0x9198,
+	0x91b5, 0x91b5, 0x91b5, 0x91b5, 0x9198, 0x91b5, 0x9198, 0x91b5,
+	0x080c, 0x1515, 0x080c, 0x7090, 0x00d6, 0x6110, 0x2168, 0x080c,
+	0x9c5a, 0x0168, 0x6837, 0x0103, 0x684b, 0x0006, 0x6847, 0x0000,
+	0x6850, 0xc0ec, 0x6852, 0x080c, 0x5408, 0x080c, 0x9e11, 0x00de,
+	0x080c, 0x861d, 0x080c, 0x7173, 0x0005, 0x080c, 0x7090, 0x080c,
+	0x861d, 0x080c, 0x7173, 0x0005, 0x0002, 0x91d2, 0x91d0, 0x91d0,
+	0x91d0, 0x91d0, 0x91d0, 0x91d0, 0x91d0, 0x91d0, 0x91d0, 0x91d0,
+	0x91e4, 0x91e4, 0x91e4, 0x91e4, 0x91d0, 0x91f3, 0x91d0, 0x91e4,
+	0x080c, 0x1515, 0x080c, 0x7090, 0x2001, 0xb7b8, 0x2004, 0x603e,
+	0x6003, 0x0002, 0x080c, 0x7173, 0x6010, 0xa088, 0x0013, 0x2104,
+	0xa085, 0x0400, 0x200a, 0x0005, 0x080c, 0x7090, 0x2001, 0xb7b6,
+	0x2004, 0x6016, 0x2001, 0xb7b8, 0x2004, 0x603e, 0x6003, 0x000f,
+	0x080c, 0x7173, 0x0005, 0x080c, 0x7090, 0x080c, 0x861d, 0x080c,
+	0x7173, 0x0005, 0xa182, 0x0040, 0x0002, 0x9210, 0x9210, 0x9210,
+	0x9210, 0x9210, 0x9212, 0x92f7, 0x9326, 0x9210, 0x9210, 0x9210,
+	0x9210, 0x9210, 0x9210, 0x9210, 0x9210, 0x9210, 0x9210, 0x9210,
+	0x080c, 0x1515, 0x00e6, 0x00d6, 0x603f, 0x0000, 0x2071, 0xbb80,
+	0x7124, 0x610a, 0x2071, 0xbb8c, 0x6110, 0x2168, 0x7614, 0xa6b4,
+	0x0fff, 0x86ff, 0x0904, 0x92c0, 0xa68c, 0x0c00, 0x0518, 0x00f6,
+	0x2c78, 0x080c, 0x5305, 0x00fe, 0x01c8, 0x684c, 0xd0ac, 0x01b0,
+	0x6020, 0xd0dc, 0x1198, 0x6850, 0xd0bc, 0x1180, 0x7318, 0x6814,
+	0xa306, 0x1904, 0x92d3, 0x731c, 0x6810, 0xa31e, 0x0138, 0xd6d4,
+	0x0904, 0x92d3, 0x6b14, 0xa305, 0x1904, 0x92d3, 0x7318, 0x6b62,
+	0x731c, 0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002, 0x0518, 0xa186,
+	0x0028, 0x1128, 0x080c, 0x9e36, 0x684b, 0x001c, 0x00e8, 0xd6dc,
+	0x01a0, 0x684b, 0x0015, 0x684c, 0xd0ac, 0x0170, 0x6914, 0x6a10,
+	0x2100, 0xa205, 0x0148, 0x7018, 0xa106, 0x1118, 0x701c, 0xa206,
+	0x0118, 0x6962, 0x6a5e, 0xc6dc, 0x0038, 0xd6d4, 0x0118, 0x684b,
+	0x0007, 0x0010, 0x684b, 0x0000, 0x6837, 0x0103, 0x6e46, 0xa01e,
+	0xd6c4, 0x01f0, 0xa686, 0x0100, 0x1140, 0x2001, 0xbb99, 0x2004,
+	0xa005, 0x1118, 0xc6c4, 0x0804, 0x9221, 0x7328, 0x732c, 0x6b56,
+	0x83ff, 0x0170, 0xa38a, 0x0009, 0x0210, 0x2019, 0x0008, 0x0036,
+	0x2308, 0x2019, 0xbb98, 0xad90, 0x0019, 0x080c, 0x990d, 0x003e,
+	0xd6cc, 0x0904, 0x92e6, 0x7124, 0x695a, 0x81ff, 0x0904, 0x92e6,
+	0xa192, 0x0021, 0x1260, 0x2071, 0xbb98, 0x831c, 0x2300, 0xae18,
+	0xad90, 0x001d, 0x080c, 0x990d, 0x080c, 0xa137, 0x04b8, 0x6838,
+	0xd0fc, 0x0120, 0x2009, 0x0020, 0x695a, 0x0c68, 0x00f6, 0x2d78,
+	0x080c, 0x98b2, 0x00fe, 0x080c, 0xa137, 0x080c, 0x98fd, 0x0440,
+	0x00f6, 0x2c78, 0x080c, 0x5305, 0x00fe, 0x0190, 0x684c, 0xd0ac,
+	0x0178, 0x6020, 0xd0dc, 0x1160, 0x6850, 0xd0bc, 0x1148, 0x6810,
+	0x6914, 0xa105, 0x0128, 0x080c, 0x9f35, 0x00de, 0x00ee, 0x00f0,
+	0x684b, 0x0000, 0x6837, 0x0103, 0x6e46, 0x684c, 0xd0ac, 0x0130,
+	0x6810, 0x6914, 0xa115, 0x0110, 0x080c, 0x9483, 0x080c, 0x5408,
+	0x6218, 0x2268, 0x6a3c, 0x82ff, 0x0110, 0x8211, 0x6a3e, 0x080c,
+	0x9f03, 0x00de, 0x00ee, 0x1110, 0x080c, 0x861d, 0x0005, 0x00f6,
+	0x6003, 0x0003, 0x2079, 0xbb8c, 0x7c04, 0x7b00, 0x7e0c, 0x7d08,
+	0x6010, 0x2078, 0x784c, 0xd0ac, 0x0138, 0x6003, 0x0002, 0x00fe,
+	0x0005, 0x2130, 0x2228, 0x0058, 0x2400, 0x797c, 0xa10a, 0x2300,
+	0x7a80, 0xa213, 0x2600, 0xa102, 0x2500, 0xa203, 0x0e90, 0x7c12,
+	0x7b16, 0x7e0a, 0x7d0e, 0x00fe, 0x603f, 0x0000, 0x2c10, 0x080c,
+	0x1fa9, 0x080c, 0x6cf0, 0x080c, 0x7230, 0x0005, 0x2001, 0xb7b8,
+	0x2004, 0x603e, 0x6003, 0x0004, 0x6110, 0x20e1, 0x0005, 0x3d18,
+	0x3e20, 0x2c10, 0x080c, 0x185e, 0x0005, 0xa182, 0x0040, 0x0002,
+	0x934b, 0x934b, 0x934b, 0x934b, 0x934b, 0x934d, 0x93e0, 0x934b,
+	0x934b, 0x93f6, 0x945a, 0x934b, 0x934b, 0x934b, 0x934b, 0x9469,
+	0x934b, 0x934b, 0x934b, 0x080c, 0x1515, 0x0076, 0x00f6, 0x00e6,
+	0x00d6, 0x2071, 0xbb8c, 0x6110, 0x2178, 0x7614, 0xa6b4, 0x0fff,
+	0x7e46, 0x7f4c, 0xc7e5, 0x7f4e, 0x6218, 0x2268, 0x6a3c, 0x82ff,
+	0x0110, 0x8211, 0x6a3e, 0x86ff, 0x0904, 0x93db, 0xa694, 0xff00,
+	0xa284, 0x0c00, 0x0120, 0x7018, 0x7862, 0x701c, 0x785e, 0xa284,
+	0x0300, 0x0904, 0x93db, 0x080c, 0x15f8, 0x090c, 0x1515, 0x2d00,
+	0x784a, 0x7f4c, 0xc7cd, 0x7f4e, 0x6837, 0x0103, 0x7838, 0x683a,
+	0x783c, 0x683e, 0x7840, 0x6842, 0x6e46, 0xa68c, 0x0c00, 0x0120,
+	0x7318, 0x6b62, 0x731c, 0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002,
+	0x0180, 0xa186, 0x0028, 0x1118, 0x684b, 0x001c, 0x0060, 0xd6dc,
+	0x0118, 0x684b, 0x0015, 0x0038, 0xd6d4, 0x0118, 0x684b, 0x0007,
+	0x0010, 0x684b, 0x0000, 0x6f4e, 0x7850, 0x6852, 0x7854, 0x6856,
+	0xa01e, 0xd6c4, 0x0198, 0x7328, 0x732c, 0x6b56, 0x83ff, 0x0170,
+	0xa38a, 0x0009, 0x0210, 0x2019, 0x0008, 0x0036, 0x2308, 0x2019,
+	0xbb98, 0xad90, 0x0019, 0x080c, 0x990d, 0x003e, 0xd6cc, 0x01d8,
+	0x7124, 0x695a, 0x81ff, 0x01b8, 0xa192, 0x0021, 0x1250, 0x2071,
+	0xbb98, 0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x080c, 0x990d,
+	0x0050, 0x7838, 0xd0fc, 0x0120, 0x2009, 0x0020, 0x695a, 0x0c78,
+	0x2d78, 0x080c, 0x98b2, 0x00de, 0x00ee, 0x00fe, 0x007e, 0x0005,
+	0x00f6, 0x6003, 0x0003, 0x2079, 0xbb8c, 0x7c04, 0x7b00, 0x7e0c,
+	0x7d08, 0x6010, 0x2078, 0x7c12, 0x7b16, 0x7e0a, 0x7d0e, 0x00fe,
+	0x2c10, 0x080c, 0x1fa9, 0x080c, 0x7d60, 0x0005, 0x00d6, 0x00f6,
+	0x2c78, 0x080c, 0x5305, 0x00fe, 0x0120, 0x2001, 0xb7b8, 0x2004,
+	0x603e, 0x6003, 0x0002, 0x080c, 0x7126, 0x080c, 0x7230, 0x6110,
+	0x2168, 0x694c, 0xd1e4, 0x0904, 0x9458, 0xd1cc, 0x0540, 0x6948,
+	0x6838, 0xd0fc, 0x01e8, 0x0016, 0x684c, 0x0006, 0x6850, 0x0006,
+	0xad90, 0x000d, 0xa198, 0x000d, 0x2009, 0x0020, 0x0156, 0x21a8,
+	0x2304, 0x2012, 0x8318, 0x8210, 0x1f04, 0x9420, 0x015e, 0x000e,
+	0x6852, 0x000e, 0x684e, 0x001e, 0x2168, 0x080c, 0x161f, 0x0418,
+	0x0016, 0x080c, 0x161f, 0x00de, 0x080c, 0x98fd, 0x00e0, 0x6837,
+	0x0103, 0x6944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x0180, 0xa086,
+	0x0028, 0x1118, 0x684b, 0x001c, 0x0060, 0xd1dc, 0x0118, 0x684b,
+	0x0015, 0x0038, 0xd1d4, 0x0118, 0x684b, 0x0007, 0x0010, 0x684b,
+	0x0000, 0x080c, 0x5408, 0x080c, 0x9f03, 0x1110, 0x080c, 0x861d,
+	0x00de, 0x0005, 0x2019, 0x0001, 0x080c, 0x7fe4, 0x6003, 0x0002,
+	0x2001, 0xb7b8, 0x2004, 0x603e, 0x080c, 0x7126, 0x080c, 0x7230,
+	0x0005, 0x080c, 0x7126, 0x080c, 0x2c9c, 0x00d6, 0x6110, 0x2168,
+	0x080c, 0x9c5a, 0x0150, 0x6837, 0x0103, 0x684b, 0x0029, 0x6847,
+	0x0000, 0x080c, 0x5408, 0x080c, 0x9e11, 0x00de, 0x080c, 0x861d,
+	0x080c, 0x7230, 0x0005, 0x684b, 0x0015, 0xd1fc, 0x0138, 0x684b,
+	0x0007, 0x8002, 0x8000, 0x810a, 0xa189, 0x0000, 0x6962, 0x685e,
+	0x0005, 0xa182, 0x0040, 0x0002, 0x94a7, 0x94a7, 0x94a7, 0x94a7,
+	0x94a7, 0x94a9, 0x94a7, 0x9564, 0x9570, 0x94a7, 0x94a7, 0x94a7,
+	0x94a7, 0x94a7, 0x94a7, 0x94a7, 0x94a7, 0x94a7, 0x94a7, 0x080c,
+	0x1515, 0x0076, 0x00f6, 0x00e6, 0x00d6, 0x2071, 0xbb8c, 0x6110,
+	0x2178, 0x7614, 0xa6b4, 0x0fff, 0x00f6, 0x2c78, 0x080c, 0x5305,
+	0x00fe, 0x0150, 0xa684, 0x00ff, 0x1138, 0x6020, 0xd0f4, 0x0120,
+	0x080c, 0x9f35, 0x0804, 0x955f, 0x7e46, 0x7f4c, 0xc7e5, 0x7f4e,
+	0x6218, 0x2268, 0x6a3c, 0x82ff, 0x0110, 0x8211, 0x6a3e, 0x86ff,
+	0x0904, 0x9555, 0xa694, 0xff00, 0xa284, 0x0c00, 0x0120, 0x7018,
+	0x7862, 0x701c, 0x785e, 0xa284, 0x0300, 0x0904, 0x9553, 0xa686,
+	0x0100, 0x1140, 0x2001, 0xbb99, 0x2004, 0xa005, 0x1118, 0xc6c4,
+	0x7e46, 0x0c28, 0x080c, 0x15f8, 0x090c, 0x1515, 0x2d00, 0x784a,
+	0x7f4c, 0xa7bd, 0x0200, 0x7f4e, 0x6837, 0x0103, 0x7838, 0x683a,
+	0x783c, 0x683e, 0x7840, 0x6842, 0x6e46, 0xa68c, 0x0c00, 0x0120,
+	0x7318, 0x6b62, 0x731c, 0x6b5e, 0xa68c, 0x00ff, 0xa186, 0x0002,
+	0x0180, 0xa186, 0x0028, 0x1118, 0x684b, 0x001c, 0x0060, 0xd6dc,
+	0x0118, 0x684b, 0x0015, 0x0038, 0xd6d4, 0x0118, 0x684b, 0x0007,
+	0x0010, 0x684b, 0x0000, 0x6f4e, 0x7850, 0x6852, 0x7854, 0x6856,
+	0xa01e, 0xd6c4, 0x0198, 0x7328, 0x732c, 0x6b56, 0x83ff, 0x0170,
+	0xa38a, 0x0009, 0x0210, 0x2019, 0x0008, 0x0036, 0x2308, 0x2019,
+	0xbb98, 0xad90, 0x0019, 0x080c, 0x990d, 0x003e, 0xd6cc, 0x01d8,
+	0x7124, 0x695a, 0x81ff, 0x01b8, 0xa192, 0x0021, 0x1250, 0x2071,
+	0xbb98, 0x831c, 0x2300, 0xae18, 0xad90, 0x001d, 0x080c, 0x990d,
+	0x0050, 0x7838, 0xd0fc, 0x0120, 0x2009, 0x0020, 0x695a, 0x0c78,
+	0x2d78, 0x080c, 0x98b2, 0xd6dc, 0x1110, 0xa006, 0x0030, 0x2001,
+	0x0001, 0x2071, 0xbb8c, 0x7218, 0x731c, 0x080c, 0x18b1, 0x00de,
+	0x00ee, 0x00fe, 0x007e, 0x0005, 0x2001, 0xb7b8, 0x2004, 0x603e,
+	0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x080c, 0x185e, 0x0005,
+	0x2001, 0xb7b8, 0x2004, 0x603e, 0x00d6, 0x6003, 0x0002, 0x6110,
+	0x2168, 0x694c, 0xd1e4, 0x0904, 0x967b, 0x603f, 0x0000, 0x00f6,
+	0x2c78, 0x080c, 0x5305, 0x00fe, 0x0560, 0x6814, 0x6910, 0xa115,
+	0x0540, 0x6a60, 0xa206, 0x1118, 0x685c, 0xa106, 0x0510, 0x684c,
+	0xc0e4, 0x684e, 0x6847, 0x0000, 0x6863, 0x0000, 0x685f, 0x0000,
+	0x6020, 0xd0f4, 0x1158, 0x697c, 0x6810, 0xa102, 0x603a, 0x6980,
+	0x6814, 0xa103, 0x6036, 0x6020, 0xc0f5, 0x6022, 0x00d6, 0x6018,
+	0x2068, 0x683c, 0x8000, 0x683e, 0x00de, 0x080c, 0x9f35, 0x0804,
+	0x967b, 0x694c, 0xd1cc, 0x0904, 0x964b, 0x6948, 0x6838, 0xd0fc,
+	0x0904, 0x960e, 0x0016, 0x684c, 0x0006, 0x6850, 0x0006, 0x00f6,
+	0x2178, 0x7944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x01e0, 0xa086,
+	0x0028, 0x1128, 0x684b, 0x001c, 0x784b, 0x001c, 0x00e8, 0xd1dc,
+	0x0158, 0x684b, 0x0015, 0x784b, 0x0015, 0x080c, 0xa0bf, 0x0118,
+	0x7944, 0xc1dc, 0x7946, 0x0080, 0xd1d4, 0x0128, 0x684b, 0x0007,
+	0x784b, 0x0007, 0x0048, 0x684c, 0xd0ac, 0x0130, 0x6810, 0x6914,
+	0xa115, 0x0110, 0x080c, 0x9483, 0x6848, 0x784a, 0x6860, 0x7862,
+	0x685c, 0x785e, 0xad90, 0x000d, 0xaf98, 0x000d, 0x2009, 0x0020,
+	0x0156, 0x21a8, 0x2304, 0x2012, 0x8318, 0x8210, 0x1f04, 0x95fa,
+	0x015e, 0x00fe, 0x000e, 0x6852, 0x000e, 0x684e, 0x080c, 0xa137,
+	0x001e, 0x2168, 0x080c, 0x161f, 0x0804, 0x9676, 0x0016, 0x00f6,
+	0x2178, 0x7944, 0xa184, 0x00ff, 0xa0b6, 0x0002, 0x01e0, 0xa086,
+	0x0028, 0x1128, 0x684b, 0x001c, 0x784b, 0x001c, 0x00e8, 0xd1dc,
+	0x0158, 0x684b, 0x0015, 0x784b, 0x0015, 0x080c, 0xa0bf, 0x0118,
+	0x7944, 0xc1dc, 0x7946, 0x0080, 0xd1d4, 0x0128, 0x684b, 0x0007,
+	0x784b, 0x0007, 0x0048, 0x684c, 0xd0ac, 0x0130, 0x6810, 0x6914,
+	0xa115, 0x0110, 0x080c, 0x9483, 0x6860, 0x7862, 0x685c, 0x785e,
+	0x684c, 0x784e, 0x00fe, 0x080c, 0x161f, 0x00de, 0x080c, 0xa137,
+	0x080c, 0x98fd, 0x0458, 0x6837, 0x0103, 0x6944, 0xa184, 0x00ff,
+	0xa0b6, 0x0002, 0x01b0, 0xa086, 0x0028, 0x1118, 0x684b, 0x001c,
+	0x00d8, 0xd1dc, 0x0148, 0x684b, 0x0015, 0x080c, 0xa0bf, 0x0118,
+	0x6944, 0xc1dc, 0x6946, 0x0080, 0xd1d4, 0x0118, 0x684b, 0x0007,
+	0x0058, 0x684b, 0x0000, 0x684c, 0xd0ac, 0x0130, 0x6810, 0x6914,
+	0xa115, 0x0110, 0x080c, 0x9483, 0x080c, 0x5408, 0x080c, 0x9f03,
+	0x1110, 0x080c, 0x861d, 0x00de, 0x0005, 0x080c, 0x7090, 0x0010,
+	0x080c, 0x7126, 0x080c, 0x9c5a, 0x01c0, 0x00d6, 0x6110, 0x2168,
+	0x6837, 0x0103, 0x2009, 0xb50c, 0x210c, 0xd18c, 0x11c0, 0xd184,
+	0x1198, 0x6108, 0x694a, 0xa18e, 0x0029, 0x1110, 0x080c, 0xb380,
+	0x6847, 0x0000, 0x080c, 0x5408, 0x00de, 0x080c, 0x861d, 0x080c,
+	0x7173, 0x080c, 0x7230, 0x0005, 0x684b, 0x0004, 0x0c88, 0x684b,
+	0x0004, 0x0c70, 0xa182, 0x0040, 0x0002, 0x96c0, 0x96c0, 0x96c0,
+	0x96c0, 0x96c0, 0x96c2, 0x96c0, 0x96c5, 0x96c0, 0x96c0, 0x96c0,
+	0x96c0, 0x96c0, 0x96c0, 0x96c0, 0x96c0, 0x96c0, 0x96c0, 0x96c0,
+	0x080c, 0x1515, 0x080c, 0x861d, 0x0005, 0x0006, 0x0026, 0xa016,
+	0x080c, 0x185e, 0x002e, 0x000e, 0x0005, 0xa182, 0x0085, 0x0002,
+	0x96d9, 0x96d7, 0x96d7, 0x96e5, 0x96d7, 0x96d7, 0x96d7, 0x080c,
+	0x1515, 0x6003, 0x0001, 0x6106, 0x080c, 0x6c8d, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x7173, 0x012e, 0x0005, 0x0026, 0x0056, 0x00d6,
+	0x00e6, 0x2071, 0xbb80, 0x7224, 0x6212, 0x7220, 0x080c, 0x9c4a,
+	0x01a0, 0x2268, 0x6800, 0xa086, 0x0000, 0x0178, 0x6018, 0x6d18,
+	0xa52e, 0x1158, 0x00c6, 0x2d60, 0x080c, 0x991d, 0x00ce, 0x0128,
+	0x6803, 0x0002, 0x6007, 0x0086, 0x0010, 0x6007, 0x0087, 0x6003,
+	0x0001, 0x080c, 0x6c8d, 0x080c, 0x7173, 0x00f6, 0x2278, 0x080c,
+	0x5305, 0x00fe, 0x0150, 0x6820, 0xd0ec, 0x0138, 0x00c6, 0x2260,
+	0x603f, 0x0000, 0x080c, 0x9f35, 0x00ce, 0x00ee, 0x00de, 0x005e,
+	0x002e, 0x0005, 0xa186, 0x0013, 0x1160, 0x6004, 0xa08a, 0x0085,
+	0x0a0c, 0x1515, 0xa08a, 0x008c, 0x1a0c, 0x1515, 0xa082, 0x0085,
+	0x0072, 0xa186, 0x0027, 0x0120, 0xa186, 0x0014, 0x190c, 0x1515,
+	0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c, 0x7173, 0x0005, 0x9746,
+	0x9748, 0x9748, 0x9746, 0x9746, 0x9746, 0x9746, 0x080c, 0x1515,
+	0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c, 0x7173, 0x0005, 0xa186,
+	0x0013, 0x1128, 0x6004, 0xa082, 0x0085, 0x2008, 0x04a8, 0xa186,
+	0x0027, 0x11e8, 0x080c, 0x7090, 0x080c, 0x2c9c, 0x00d6, 0x6010,
+	0x2068, 0x080c, 0x9c5a, 0x0150, 0x6837, 0x0103, 0x6847, 0x0000,
+	0x684b, 0x0029, 0x080c, 0x5408, 0x080c, 0x9e11, 0x00de, 0x080c,
+	0x861d, 0x080c, 0x7173, 0x0005, 0x080c, 0x8663, 0x0ce0, 0xa186,
+	0x0014, 0x1dd0, 0x080c, 0x7090, 0x00d6, 0x6010, 0x2068, 0x080c,
+	0x9c5a, 0x0d60, 0x6837, 0x0103, 0x6847, 0x0000, 0x684b, 0x0006,
+	0x6850, 0xc0ec, 0x6852, 0x08f0, 0x0002, 0x9796, 0x9794, 0x9794,
+	0x9794, 0x9794, 0x9794, 0x97ae, 0x080c, 0x1515, 0x080c, 0x7090,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x2001, 0xb7b6, 0x0010, 0x2001, 0xb7b7, 0x2004,
+	0x6016, 0x6003, 0x000c, 0x080c, 0x7173, 0x0005, 0x080c, 0x7090,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x2001, 0xb7b6, 0x0010, 0x2001, 0xb7b7, 0x2004,
+	0x6016, 0x6003, 0x000e, 0x080c, 0x7173, 0x0005, 0xa182, 0x008c,
+	0x1220, 0xa182, 0x0085, 0x0208, 0x001a, 0x080c, 0x8663, 0x0005,
+	0x97d7, 0x97d7, 0x97d7, 0x97d7, 0x97d9, 0x9832, 0x97d7, 0x080c,
+	0x1515, 0x00d6, 0x00f6, 0x2c78, 0x080c, 0x5305, 0x00fe, 0x0168,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0039, 0x0118, 0xa186,
+	0x0035, 0x1118, 0x00de, 0x0804, 0x9845, 0x080c, 0x9c5a, 0x1118,
+	0x080c, 0x9e11, 0x00f0, 0x6010, 0x2068, 0x684c, 0xd0e4, 0x1110,
+	0x080c, 0x9e11, 0x6837, 0x0103, 0x6850, 0xd0b4, 0x0128, 0x684b,
+	0x0006, 0xc0ec, 0x6852, 0x0048, 0xd0bc, 0x0118, 0x684b, 0x0002,
+	0x0020, 0x684b, 0x0005, 0x080c, 0x9ed2, 0x6847, 0x0000, 0x080c,
+	0x5408, 0x2c68, 0x080c, 0x85c7, 0x01c0, 0x6003, 0x0001, 0x6007,
+	0x001e, 0x600b, 0xffff, 0x2009, 0xbb8e, 0x210c, 0x6136, 0x2009,
+	0xbb8f, 0x210c, 0x613a, 0x6918, 0x611a, 0x080c, 0xa027, 0x6950,
+	0x6152, 0x601f, 0x0001, 0x080c, 0x6c8d, 0x2d60, 0x080c, 0x861d,
+	0x00de, 0x0005, 0x00f6, 0x2c78, 0x080c, 0x5305, 0x00fe, 0x0598,
+	0x6030, 0xa08c, 0xff00, 0x810f, 0xa186, 0x0035, 0x0130, 0xa186,
+	0x001e, 0x0118, 0xa186, 0x0039, 0x1530, 0x00d6, 0x2c68, 0x080c,
+	0xa10a, 0x1904, 0x988a, 0x080c, 0x85c7, 0x01d8, 0x6106, 0x6003,
+	0x0001, 0x601f, 0x0001, 0x6918, 0x611a, 0x6928, 0x612a, 0x692c,
+	0x612e, 0x6930, 0xa18c, 0x00ff, 0x6132, 0x6934, 0x6136, 0x6938,
+	0x613a, 0x6950, 0x6152, 0x080c, 0xa027, 0x080c, 0x6c8d, 0x080c,
+	0x7173, 0x2d60, 0x00f8, 0x00d6, 0x6010, 0x2068, 0x080c, 0x9c5a,
+	0x01c8, 0x6837, 0x0103, 0x6850, 0xd0b4, 0x0128, 0xc0ec, 0x6852,
+	0x684b, 0x0006, 0x0048, 0xd0bc, 0x0118, 0x684b, 0x0002, 0x0020,
+	0x684b, 0x0005, 0x080c, 0x9ed2, 0x6847, 0x0000, 0x080c, 0x5408,
+	0x080c, 0x9e11, 0x00de, 0x080c, 0x861d, 0x0005, 0x0016, 0x00d6,
+	0x6010, 0x2068, 0x080c, 0x9c5a, 0x0140, 0x6837, 0x0103, 0x684b,
+	0x0028, 0x6847, 0x0000, 0x080c, 0x5408, 0x00de, 0x001e, 0xa186,
+	0x0013, 0x0148, 0xa186, 0x0014, 0x0130, 0xa186, 0x0027, 0x0118,
+	0x080c, 0x8663, 0x0030, 0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c,
+	0x7173, 0x0005, 0x0056, 0x0066, 0x00d6, 0x00f6, 0x2029, 0x0001,
+	0xa182, 0x0101, 0x1208, 0x0010, 0x2009, 0x0100, 0x2130, 0x2069,
+	0xbb98, 0x831c, 0x2300, 0xad18, 0x2009, 0x0020, 0xaf90, 0x001d,
+	0x080c, 0x990d, 0xa6b2, 0x0020, 0x7804, 0xa06d, 0x0110, 0x080c,
+	0x161f, 0x080c, 0x15f8, 0x0500, 0x8528, 0x6837, 0x0110, 0x683b,
+	0x0000, 0x2d20, 0x7c06, 0xa68a, 0x003d, 0x1228, 0x2608, 0xad90,
+	0x000f, 0x0459, 0x0088, 0xa6b2, 0x003c, 0x2009, 0x003c, 0x2d78,
+	0xad90, 0x000f, 0x0411, 0x0c28, 0x00fe, 0x852f, 0xa5ad, 0x0003,
+	0x7d36, 0xa5ac, 0x0000, 0x0028, 0x00fe, 0x852f, 0xa5ad, 0x0003,
+	0x7d36, 0x00de, 0x006e, 0x005e, 0x0005, 0x00f6, 0x8dff, 0x0158,
+	0x6804, 0xa07d, 0x0130, 0x6807, 0x0000, 0x080c, 0x5408, 0x2f68,
+	0x0cb8, 0x080c, 0x5408, 0x00fe, 0x0005, 0x0156, 0xa184, 0x0001,
+	0x0108, 0x8108, 0x810c, 0x21a8, 0x2304, 0x8007, 0x2012, 0x8318,
+	0x8210, 0x1f04, 0x9914, 0x015e, 0x0005, 0x0066, 0x0126, 0x2091,
+	0x8000, 0x2031, 0x0001, 0x601c, 0xa084, 0x000f, 0x0083, 0x012e,
+	0x006e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0066, 0x2031, 0x0000,
+	0x601c, 0xa084, 0x000f, 0x001b, 0x006e, 0x012e, 0x0005, 0x9954,
+	0x9954, 0x994f, 0x9976, 0x9942, 0x994f, 0x9976, 0x994f, 0x994f,
+	0x9942, 0x994f, 0x080c, 0x1515, 0x0036, 0x2019, 0x0010, 0x080c,
+	0xace0, 0x601f, 0x0006, 0x6003, 0x0007, 0x003e, 0x0005, 0xa006,
+	0x0005, 0xa085, 0x0001, 0x0005, 0x00d6, 0x86ff, 0x11d8, 0x6010,
+	0x2068, 0x080c, 0x9c5a, 0x01c0, 0x6834, 0xa086, 0x0139, 0x1128,
+	0x684b, 0x0005, 0x6853, 0x0000, 0x0028, 0xa00e, 0x2001, 0x0005,
+	0x080c, 0x54db, 0x080c, 0x9ed2, 0x080c, 0x5408, 0x080c, 0x861d,
+	0xa085, 0x0001, 0x00de, 0x0005, 0xa006, 0x0ce0, 0x6000, 0xa08a,
+	0x0010, 0x1a0c, 0x1515, 0x000b, 0x0005, 0x998d, 0x99ae, 0x998f,
+	0x99cd, 0x99ab, 0x998d, 0x994f, 0x9954, 0x9954, 0x994f, 0x994f,
+	0x994f, 0x994f, 0x994f, 0x994f, 0x994f, 0x080c, 0x1515, 0x86ff,
+	0x11b8, 0x601c, 0xa086, 0x0006, 0x0198, 0x00d6, 0x6010, 0x2068,
+	0x080c, 0x9c5a, 0x0110, 0x080c, 0x9ed2, 0x00de, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x6c8d, 0x080c, 0x7173,
+	0xa085, 0x0001, 0x0005, 0x080c, 0x194d, 0x0c08, 0x00e6, 0x2071,
+	0xb7e0, 0x7024, 0xac06, 0x1110, 0x080c, 0x7f59, 0x601c, 0xa084,
+	0x000f, 0xa086, 0x0006, 0x1150, 0x0086, 0x0096, 0x2049, 0x0001,
+	0x2c40, 0x080c, 0x8130, 0x009e, 0x008e, 0x0010, 0x080c, 0x7e58,
+	0x00ee, 0x1928, 0x080c, 0x994f, 0x0005, 0x0036, 0x00e6, 0x2071,
+	0xb7e0, 0x703c, 0xac06, 0x1140, 0x2019, 0x0000, 0x080c, 0x7fe4,
+	0x00ee, 0x003e, 0x0804, 0x998f, 0x080c, 0x825d, 0x00ee, 0x003e,
+	0x1904, 0x998f, 0x080c, 0x994f, 0x0005, 0x00c6, 0x601c, 0xa084,
+	0x000f, 0x0013, 0x00ce, 0x0005, 0x99fe, 0x9a6b, 0x9bb9, 0x9a09,
+	0x9e1d, 0x99fe, 0xacd2, 0xa14e, 0x9a6b, 0x99f7, 0x9c24, 0x080c,
+	0x1515, 0x080c, 0x9e58, 0x1110, 0x080c, 0x8c19, 0x0005, 0x080c,
+	0x7090, 0x080c, 0x7173, 0x080c, 0x861d, 0x0005, 0x6017, 0x0001,
+	0x0005, 0x080c, 0x9c5a, 0x0120, 0x6010, 0xa080, 0x0019, 0x2c02,
+	0x6000, 0xa08a, 0x0010, 0x1a0c, 0x1515, 0x000b, 0x0005, 0x9a27,
+	0x9a29, 0x9a49, 0x9a5b, 0x9a68, 0x9a27, 0x99fe, 0x99fe, 0x99fe,
+	0x9a5b, 0x9a5b, 0x9a27, 0x9a27, 0x9a27, 0x9a27, 0x9a65, 0x080c,
+	0x1515, 0x00e6, 0x6010, 0x2070, 0x7050, 0xc0b5, 0x7052, 0x2071,
+	0xb7e0, 0x7024, 0xac06, 0x0190, 0x080c, 0x7e58, 0x6007, 0x0085,
+	0x6003, 0x000b, 0x601f, 0x0002, 0x2001, 0xb7b7, 0x2004, 0x6016,
+	0x080c, 0x6c8d, 0x080c, 0x7173, 0x00ee, 0x0005, 0x6017, 0x0001,
+	0x0cd8, 0x00d6, 0x6010, 0x2068, 0x6850, 0xc0b5, 0x6852, 0x00de,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x080c, 0x6c8d,
+	0x080c, 0x7173, 0x0005, 0x00d6, 0x6017, 0x0001, 0x6010, 0x2068,
+	0x6850, 0xc0b5, 0x6852, 0x00de, 0x0005, 0x080c, 0x861d, 0x0005,
+	0x080c, 0x194d, 0x08f0, 0x6000, 0xa08a, 0x0010, 0x1a0c, 0x1515,
+	0x000b, 0x0005, 0x9a82, 0x9a06, 0x9a84, 0x9a82, 0x9a84, 0x9a84,
+	0x99ff, 0x9a82, 0x99f9, 0x99f9, 0x9a82, 0x9a82, 0x9a82, 0x9a82,
+	0x9a82, 0x9a82, 0x080c, 0x1515, 0x00d6, 0x6018, 0x2068, 0x6804,
+	0xa084, 0x00ff, 0x00de, 0xa08a, 0x000c, 0x1a0c, 0x1515, 0x000b,
+	0x0005, 0x9a9d, 0x9b5f, 0x9a9f, 0x9add, 0x9a9f, 0x9add, 0x9a9f,
+	0x9aad, 0x9a9d, 0x9add, 0x9a9d, 0x9ac9, 0x080c, 0x1515, 0x6004,
+	0xa08e, 0x0016, 0x05a8, 0xa08e, 0x0004, 0x0590, 0xa08e, 0x0002,
+	0x0578, 0xa08e, 0x004b, 0x0904, 0x9b5b, 0x6004, 0x080c, 0x9e58,
+	0x0904, 0x9b78, 0xa08e, 0x0021, 0x0904, 0x9b7c, 0xa08e, 0x0022,
+	0x0904, 0x9b78, 0xa08e, 0x003d, 0x0904, 0x9b7c, 0xa08e, 0x0039,
+	0x0904, 0x9b80, 0xa08e, 0x0035, 0x0904, 0x9b80, 0xa08e, 0x001e,
+	0x0188, 0xa08e, 0x0001, 0x1150, 0x00d6, 0x6018, 0x2068, 0x6804,
+	0xa084, 0x00ff, 0x00de, 0xa086, 0x0006, 0x0110, 0x080c, 0x2c9c,
+	0x080c, 0x8c19, 0x080c, 0x9e1d, 0x0005, 0x00c6, 0x00d6, 0x6104,
+	0xa186, 0x0016, 0x0904, 0x9b4c, 0xa186, 0x0002, 0x15d8, 0x2001,
+	0xb535, 0x2004, 0xd08c, 0x1198, 0x080c, 0x5acf, 0x1180, 0x2001,
+	0xb79f, 0x2003, 0x0001, 0x2001, 0xb500, 0x2003, 0x0001, 0xa085,
+	0x0001, 0x080c, 0x5b13, 0x080c, 0x5a07, 0x0804, 0x9ba2, 0x6018,
+	0x2068, 0x2001, 0xb535, 0x2004, 0xd0ac, 0x1904, 0x9ba2, 0x68a0,
+	0xd0bc, 0x1904, 0x9ba2, 0x6840, 0xa084, 0x00ff, 0xa005, 0x0190,
+	0x8001, 0x6842, 0x6013, 0x0000, 0x601f, 0x0007, 0x6017, 0x0398,
+	0x603f, 0x0000, 0x080c, 0x85c7, 0x0128, 0x2d00, 0x601a, 0x601f,
+	0x0001, 0x0450, 0x00de, 0x00ce, 0x6004, 0xa08e, 0x0002, 0x11a8,
+	0x6018, 0xa080, 0x0028, 0x2004, 0xa086, 0x007e, 0x1170, 0x2009,
+	0xb535, 0x2104, 0xc085, 0x200a, 0x00e6, 0x2071, 0xb500, 0x080c,
+	0x4bc6, 0x00ee, 0x080c, 0x8c19, 0x0020, 0x080c, 0x8c19, 0x080c,
+	0x2c9c, 0x00e6, 0x0126, 0x2091, 0x8000, 0x080c, 0x2cc2, 0x012e,
+	0x00ee, 0x080c, 0x9e1d, 0x0005, 0x2001, 0x0002, 0x080c, 0x4efd,
+	0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x6cd3, 0x080c, 0x7173,
+	0x00de, 0x00ce, 0x0c80, 0x080c, 0x2cc2, 0x0804, 0x9ad8, 0x00c6,
+	0x00d6, 0x6104, 0xa186, 0x0016, 0x0d38, 0x6018, 0x2068, 0x6840,
+	0xa084, 0x00ff, 0xa005, 0x0904, 0x9b22, 0x8001, 0x6842, 0x6003,
+	0x0001, 0x080c, 0x6cd3, 0x080c, 0x7173, 0x00de, 0x00ce, 0x0898,
+	0x080c, 0x8c19, 0x0804, 0x9ada, 0x080c, 0x8c47, 0x0804, 0x9ada,
+	0x00d6, 0x2c68, 0x6104, 0x080c, 0xa10a, 0x00de, 0x0118, 0x080c,
+	0x861d, 0x00b8, 0x6004, 0x8007, 0x6130, 0xa18c, 0x00ff, 0xa105,
+	0x6032, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0002, 0x6038,
+	0x600a, 0x2001, 0xb7b7, 0x2004, 0x6016, 0x080c, 0x6c8d, 0x080c,
+	0x7173, 0x0005, 0x00de, 0x00ce, 0x080c, 0x8c19, 0x080c, 0x2c9c,
+	0x00e6, 0x0126, 0x2091, 0x8000, 0x080c, 0x2cc2, 0x6013, 0x0000,
+	0x601f, 0x0007, 0x6017, 0x0398, 0x603f, 0x0000, 0x012e, 0x00ee,
+	0x0005, 0x6000, 0xa08a, 0x0010, 0x1a0c, 0x1515, 0x000b, 0x0005,
+	0x9bd0, 0x9bd0, 0x9bd0, 0x9bd0, 0x9bd0, 0x9bd0, 0x9bd0, 0x9bd0,
+	0x9bd0, 0x99fe, 0x9bd0, 0x9a06, 0x9bd2, 0x9a06, 0x9bdf, 0x9bd0,
+	0x080c, 0x1515, 0x6004, 0xa086, 0x008b, 0x0148, 0x6007, 0x008b,
+	0x6003, 0x000d, 0x080c, 0x6c8d, 0x080c, 0x7173, 0x0005, 0x080c,
+	0x9e11, 0x080c, 0x9c5a, 0x0580, 0x080c, 0x2c9c, 0x00d6, 0x080c,
+	0x9c5a, 0x0168, 0x6010, 0x2068, 0x6837, 0x0103, 0x684b, 0x0006,
+	0x6847, 0x0000, 0x6850, 0xc0ed, 0x6852, 0x080c, 0x5408, 0x2c68,
+	0x080c, 0x85c7, 0x0150, 0x6818, 0x601a, 0x080c, 0xa027, 0x00c6,
+	0x2d60, 0x080c, 0x9e1d, 0x00ce, 0x0008, 0x2d60, 0x00de, 0x6013,
+	0x0000, 0x601f, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c,
+	0x6cd3, 0x080c, 0x7173, 0x0078, 0x6030, 0xa08c, 0xff00, 0x810f,
+	0xa186, 0x0039, 0x0118, 0xa186, 0x0035, 0x1118, 0x080c, 0x2c9c,
+	0x08b0, 0x080c, 0x9e1d, 0x0005, 0x6000, 0xa08a, 0x0010, 0x1a0c,
+	0x1515, 0x000b, 0x0005, 0x9c3b, 0x9c3b, 0x9c3b, 0x9c3d, 0x9c3d,
+	0x9c3b, 0x9c3b, 0x9c3b, 0x9c3b, 0x9c3b, 0x9c3b, 0x9c3b, 0x9c3b,
+	0x9c3b, 0x9c3b, 0x9c3b, 0x080c, 0x1515, 0x080c, 0x825d, 0x190c,
+	0x1515, 0x6110, 0x2168, 0x684b, 0x0006, 0x080c, 0x5408, 0x080c,
+	0x861d, 0x0005, 0xa284, 0x0007, 0x1158, 0xa282, 0xbd00, 0x0240,
+	0x2001, 0xb517, 0x2004, 0xa202, 0x1218, 0xa085, 0x0001, 0x0005,
+	0xa006, 0x0ce8, 0x0026, 0x6210, 0xa294, 0xf000, 0x002e, 0x0005,
+	0x00e6, 0x00c6, 0x0036, 0x0006, 0x0126, 0x2091, 0x8000, 0x2061,
+	0xbd00, 0x2071, 0xb500, 0x7348, 0x7068, 0xa302, 0x12a8, 0x601c,
+	0xa206, 0x1160, 0x080c, 0x9fb2, 0x0148, 0x080c, 0x9e58, 0x1110,
+	0x080c, 0x8c19, 0x00c6, 0x080c, 0x861d, 0x00ce, 0xace0, 0x0018,
+	0x705c, 0xac02, 0x1208, 0x0c38, 0x012e, 0x000e, 0x003e, 0x00ce,
+	0x00ee, 0x0005, 0x00e6, 0x00c6, 0x0016, 0xa188, 0xb635, 0x210c,
+	0x81ff, 0x0128, 0x2061, 0xb8f4, 0x611a, 0x080c, 0x2c9c, 0xa006,
+	0x0010, 0xa085, 0x0001, 0x001e, 0x00ce, 0x00ee, 0x0005, 0x00c6,
+	0x0056, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x85c7, 0x005e,
+	0x0180, 0x6612, 0x651a, 0x080c, 0xa027, 0x601f, 0x0003, 0x2009,
+	0x004b, 0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x005e, 0x00ce,
+	0x0005, 0xa006, 0x0cd0, 0x00c6, 0x0056, 0x0126, 0x2091, 0x8000,
+	0x62a0, 0x00c6, 0x080c, 0x9ed6, 0x005e, 0x0550, 0x6013, 0x0000,
+	0x651a, 0x080c, 0xa027, 0x601f, 0x0003, 0x0016, 0x00c6, 0x2560,
+	0x080c, 0x51aa, 0x00ce, 0x080c, 0x6df5, 0x0076, 0x2039, 0x0000,
+	0x080c, 0x6d02, 0x2c08, 0x080c, 0xae82, 0x007e, 0x001e, 0xd184,
+	0x0128, 0x080c, 0x861d, 0xa085, 0x0001, 0x0030, 0x2009, 0x004c,
+	0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x005e, 0x00ce, 0x0005,
+	0xa006, 0x0cd0, 0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c, 0x85c7,
+	0x2c78, 0x00ce, 0x0180, 0x7e12, 0x2c00, 0x781a, 0x781f, 0x0003,
+	0x2021, 0x0005, 0x080c, 0x9d50, 0x2f60, 0x2009, 0x004d, 0x080c,
+	0x864c, 0xa085, 0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005, 0x00f6,
+	0x00c6, 0x0046, 0x00c6, 0x080c, 0x85c7, 0x2c78, 0x00ce, 0x0178,
+	0x7e12, 0x2c00, 0x781a, 0x781f, 0x0003, 0x2021, 0x0005, 0x0481,
+	0x2f60, 0x2009, 0x004e, 0x080c, 0x864c, 0xa085, 0x0001, 0x004e,
+	0x00ce, 0x00fe, 0x0005, 0x00f6, 0x00c6, 0x0046, 0x00c6, 0x080c,
+	0x85c7, 0x2c78, 0x00ce, 0x01c0, 0x7e12, 0x2c00, 0x781a, 0x781f,
+	0x0003, 0x2021, 0x0004, 0x00a1, 0x2001, 0xb7a0, 0x2004, 0xd0fc,
+	0x0120, 0x2f60, 0x080c, 0x861d, 0x0028, 0x2f60, 0x2009, 0x0052,
+	0x080c, 0x864c, 0xa085, 0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005,
+	0x0096, 0x0076, 0x0126, 0x2091, 0x8000, 0x080c, 0x514c, 0x0118,
+	0x2001, 0x9d55, 0x0028, 0x080c, 0x511c, 0x0158, 0x2001, 0x9d5b,
+	0x0006, 0xa00e, 0x2400, 0x080c, 0x54db, 0x080c, 0x5408, 0x000e,
+	0x0807, 0x2418, 0x080c, 0x702f, 0x62a0, 0x0086, 0x2041, 0x0001,
+	0x2039, 0x0001, 0x2608, 0x080c, 0x6e0e, 0x008e, 0x080c, 0x6d02,
+	0x2f08, 0x2648, 0x080c, 0xae82, 0x613c, 0x81ff, 0x090c, 0x6ec3,
+	0x080c, 0x7173, 0x012e, 0x007e, 0x009e, 0x0005, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x00c6, 0x080c, 0x85c7, 0x001e, 0x0188, 0x660a,
+	0x611a, 0x080c, 0xa027, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009,
+	0x001f, 0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005,
+	0xa006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c,
+	0x85c7, 0x001e, 0x0188, 0x660a, 0x611a, 0x080c, 0xa027, 0x601f,
+	0x0008, 0x2d00, 0x6012, 0x2009, 0x0021, 0x080c, 0x864c, 0xa085,
+	0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x00c6, 0x080c, 0x85c7, 0x001e, 0x0188, 0x660a,
+	0x611a, 0x080c, 0xa027, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009,
+	0x003d, 0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005,
+	0xa006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c,
+	0x9ed6, 0x001e, 0x0180, 0x611a, 0x080c, 0xa027, 0x601f, 0x0001,
+	0x2d00, 0x6012, 0x2009, 0x0000, 0x080c, 0x864c, 0xa085, 0x0001,
+	0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x00c6, 0x080c, 0x85c7, 0x001e, 0x0188, 0x660a, 0x611a,
+	0x080c, 0xa027, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009, 0x0044,
+	0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006,
+	0x0cd8, 0x0026, 0x00d6, 0x6218, 0x2268, 0x6a3c, 0x82ff, 0x0110,
+	0x8211, 0x6a3e, 0x00de, 0x002e, 0x0005, 0x0006, 0x6000, 0xa086,
+	0x0000, 0x0190, 0x6013, 0x0000, 0x601f, 0x0007, 0x2001, 0xb7b6,
+	0x2004, 0x0006, 0xa082, 0x0051, 0x000e, 0x0208, 0x8004, 0x6016,
+	0x080c, 0xb33a, 0x603f, 0x0000, 0x000e, 0x0005, 0x0066, 0x00c6,
+	0x00d6, 0x2031, 0xb553, 0x2634, 0xd6e4, 0x0128, 0x6618, 0x2660,
+	0x6e48, 0x080c, 0x50d5, 0x00de, 0x00ce, 0x006e, 0x0005, 0x0006,
+	0x0016, 0x6004, 0xa08e, 0x0002, 0x0140, 0xa08e, 0x0003, 0x0128,
+	0xa08e, 0x0004, 0x0110, 0xa085, 0x0001, 0x001e, 0x000e, 0x0005,
+	0x0006, 0x00d6, 0x6010, 0xa06d, 0x0148, 0x6834, 0xa086, 0x0139,
+	0x0138, 0x6838, 0xd0fc, 0x0110, 0xa006, 0x0010, 0xa085, 0x0001,
+	0x00de, 0x000e, 0x0005, 0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6,
+	0x080c, 0x85c7, 0x001e, 0x0190, 0x611a, 0x080c, 0xa027, 0x601f,
+	0x0001, 0x2d00, 0x6012, 0x080c, 0x2c9c, 0x2009, 0x0028, 0x080c,
+	0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005, 0xa006, 0x0cd8,
+	0xa186, 0x0015, 0x1178, 0x2011, 0xb521, 0x2204, 0xa086, 0x0074,
+	0x1148, 0x080c, 0x8f98, 0x6003, 0x0001, 0x6007, 0x0029, 0x080c,
+	0x6cd3, 0x0020, 0x080c, 0x8c19, 0x080c, 0x861d, 0x0005, 0xa186,
+	0x0016, 0x1128, 0x2001, 0x0004, 0x080c, 0x4efd, 0x00e8, 0xa186,
+	0x0015, 0x11e8, 0x2011, 0xb521, 0x2204, 0xa086, 0x0014, 0x11b8,
+	0x00d6, 0x6018, 0x2068, 0x080c, 0x504b, 0x00de, 0x080c, 0x9051,
+	0x1170, 0x00d6, 0x6018, 0x2068, 0x6890, 0x00de, 0xa005, 0x0138,
+	0x2001, 0x0006, 0x080c, 0x4efd, 0x080c, 0x87a0, 0x0020, 0x080c,
+	0x8c19, 0x080c, 0x861d, 0x0005, 0x6848, 0xa086, 0x0005, 0x1108,
+	0x0009, 0x0005, 0x6850, 0xc0ad, 0x6852, 0x0005, 0x00e6, 0x0126,
+	0x2071, 0xb500, 0x2091, 0x8000, 0x7548, 0xa582, 0x0001, 0x0608,
+	0x704c, 0x2060, 0x6000, 0xa086, 0x0000, 0x0148, 0xace0, 0x0018,
+	0x705c, 0xac02, 0x1208, 0x0cb0, 0x2061, 0xbd00, 0x0c98, 0x6003,
+	0x0008, 0x8529, 0x754a, 0xaca8, 0x0018, 0x705c, 0xa502, 0x1230,
+	0x754e, 0xa085, 0x0001, 0x012e, 0x00ee, 0x0005, 0x704f, 0xbd00,
+	0x0cc0, 0xa006, 0x0cc0, 0x00e6, 0x2071, 0xbb8c, 0x7014, 0xd0e4,
+	0x0150, 0x6013, 0x0000, 0x6003, 0x0001, 0x6007, 0x0050, 0x080c,
+	0x6c8d, 0x080c, 0x7173, 0x00ee, 0x0005, 0x00c6, 0x00f6, 0x2c78,
+	0x080c, 0x5305, 0x00fe, 0x0120, 0x601c, 0xa084, 0x000f, 0x0013,
+	0x00ce, 0x0005, 0x99fe, 0x9f2d, 0x9f30, 0x9f33, 0xb127, 0xb142,
+	0xb145, 0x99fe, 0x99fe, 0x080c, 0x1515, 0xe000, 0xe000, 0x0005,
+	0xe000, 0xe000, 0x0005, 0x0009, 0x0005, 0x00f6, 0x2c78, 0x080c,
+	0x5305, 0x0538, 0x080c, 0x85c7, 0x1128, 0x2001, 0xb7b8, 0x2004,
+	0x783e, 0x00f8, 0x7818, 0x601a, 0x080c, 0xa027, 0x781c, 0xa086,
+	0x0003, 0x0128, 0x7808, 0x6036, 0x2f00, 0x603a, 0x0020, 0x7808,
+	0x603a, 0x2f00, 0x6036, 0x602a, 0x601f, 0x0001, 0x6007, 0x0035,
+	0x6003, 0x0001, 0x7950, 0x6152, 0x080c, 0x6c8d, 0x080c, 0x7173,
+	0x2f60, 0x00fe, 0x0005, 0x0016, 0x00f6, 0x682c, 0x6032, 0xa08e,
+	0x0001, 0x0138, 0xa086, 0x0005, 0x0140, 0xa006, 0x602a, 0x602e,
+	0x00a0, 0x6820, 0xc0f4, 0xc0d5, 0x6822, 0x6810, 0x2078, 0x787c,
+	0x6938, 0xa102, 0x7880, 0x6934, 0xa103, 0x1e78, 0x6834, 0x602a,
+	0x6838, 0xa084, 0xfffc, 0x683a, 0x602e, 0x2d00, 0x6036, 0x6808,
+	0x603a, 0x6918, 0x611a, 0x6950, 0x6152, 0x601f, 0x0001, 0x6007,
+	0x0039, 0x6003, 0x0001, 0x080c, 0x6c8d, 0x6803, 0x0002, 0x00fe,
+	0x001e, 0x0005, 0x00f6, 0x2c78, 0x080c, 0x5305, 0x1118, 0xa085,
+	0x0001, 0x0070, 0x6020, 0xd0f4, 0x1150, 0xc0f5, 0x6022, 0x6010,
+	0x2078, 0x7828, 0x603a, 0x782c, 0x6036, 0x080c, 0x194d, 0xa006,
+	0x00fe, 0x0005, 0x0006, 0x0016, 0x6004, 0xa08e, 0x0034, 0x01b8,
+	0xa08e, 0x0035, 0x01a0, 0xa08e, 0x0036, 0x0188, 0xa08e, 0x0037,
+	0x0170, 0xa08e, 0x0038, 0x0158, 0xa08e, 0x0039, 0x0140, 0xa08e,
+	0x003a, 0x0128, 0xa08e, 0x003b, 0x0110, 0xa085, 0x0001, 0x001e,
+	0x000e, 0x0005, 0x0006, 0x0016, 0x0026, 0x0036, 0x00e6, 0x2001,
+	0xb7b2, 0x200c, 0x8000, 0x2014, 0x2001, 0x0032, 0x080c, 0x6b40,
+	0x2001, 0xb7b6, 0x82ff, 0x1110, 0x2011, 0x0014, 0x2202, 0x2001,
+	0xb7b4, 0x200c, 0x8000, 0x2014, 0x2071, 0xb78e, 0x711a, 0x721e,
+	0x2001, 0x0064, 0x080c, 0x6b40, 0x2001, 0xb7b7, 0x82ff, 0x1110,
+	0x2011, 0x0014, 0x2202, 0x2009, 0xb7b8, 0xa280, 0x000a, 0x200a,
+	0x080c, 0x532a, 0x00ee, 0x003e, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x0006, 0x00e6, 0x2001, 0xb7b6, 0x2003, 0x0028, 0x2001, 0xb7b7,
+	0x2003, 0x0014, 0x2071, 0xb78e, 0x701b, 0x0000, 0x701f, 0x07d0,
+	0x2001, 0xb7b8, 0x2003, 0x001e, 0x00ee, 0x000e, 0x0005, 0x00d6,
+	0x6054, 0xa06d, 0x0110, 0x080c, 0x160f, 0x00de, 0x0005, 0x0005,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x85c7, 0x001e,
+	0x0178, 0x611a, 0x0ca1, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009,
+	0x0033, 0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005,
+	0xa006, 0x0cd8, 0x00d6, 0x00e6, 0x00f6, 0x2071, 0xb500, 0xa186,
+	0x0015, 0x1500, 0x7084, 0xa086, 0x0018, 0x11e0, 0x6010, 0x2068,
+	0x6a3c, 0xd2e4, 0x1160, 0x2c78, 0x080c, 0x7331, 0x01d8, 0x7070,
+	0x6a50, 0xa206, 0x1160, 0x7074, 0x6a54, 0xa206, 0x1140, 0x6218,
+	0xa290, 0x0028, 0x2214, 0x2009, 0x0000, 0x080c, 0x2ce1, 0x080c,
+	0x87a0, 0x0020, 0x080c, 0x8c19, 0x080c, 0x861d, 0x00fe, 0x00ee,
+	0x00de, 0x0005, 0x7054, 0x6a54, 0xa206, 0x0d48, 0x0c80, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0x00c6, 0x080c, 0x85c7, 0x001e, 0x0180,
+	0x611a, 0x080c, 0xa027, 0x601f, 0x0001, 0x2d00, 0x6012, 0x2009,
+	0x0043, 0x080c, 0x864c, 0xa085, 0x0001, 0x012e, 0x00ce, 0x0005,
+	0xa006, 0x0cd8, 0x00d6, 0x00e6, 0x00f6, 0x2071, 0xb500, 0xa186,
+	0x0015, 0x11c0, 0x7084, 0xa086, 0x0004, 0x11a0, 0x6010, 0xa0e8,
+	0x000f, 0x2c78, 0x080c, 0x7331, 0x01a8, 0x7070, 0x6a08, 0xa206,
+	0x1130, 0x7074, 0x6a0c, 0xa206, 0x1110, 0x080c, 0x2c9c, 0x080c,
+	0x87a0, 0x0020, 0x080c, 0x8c19, 0x080c, 0x861d, 0x00fe, 0x00ee,
+	0x00de, 0x0005, 0x7054, 0x6a0c, 0xa206, 0x0d78, 0x0c80, 0x0016,
+	0x0026, 0x684c, 0xd0ac, 0x0178, 0x6914, 0x6a10, 0x2100, 0xa205,
+	0x0150, 0x6860, 0xa106, 0x1118, 0x685c, 0xa206, 0x0120, 0x6962,
+	0x6a5e, 0xa085, 0x0001, 0x002e, 0x001e, 0x0005, 0x00d6, 0x0036,
+	0x6310, 0x2368, 0x684a, 0x6952, 0xa29e, 0x4000, 0x11a0, 0x00c6,
+	0x6318, 0x2360, 0x2009, 0x0000, 0x6838, 0xd0f4, 0x1140, 0x080c,
+	0x524a, 0x1108, 0xc185, 0x6000, 0xd0bc, 0x0108, 0xc18d, 0x6a66,
+	0x696a, 0x00ce, 0x0080, 0x6a66, 0x3918, 0xa398, 0x0006, 0x231c,
+	0x686b, 0x0004, 0x6b72, 0x00c6, 0x6318, 0x2360, 0x6004, 0xa084,
+	0x00ff, 0x686e, 0x00ce, 0x080c, 0x5408, 0x6013, 0x0000, 0x003e,
+	0x00de, 0x0005, 0x00c6, 0x0026, 0x0016, 0xa186, 0x0035, 0x0110,
+	0x6a34, 0x0008, 0x6a28, 0x080c, 0x9c4a, 0x01f0, 0x2260, 0x611c,
+	0xa186, 0x0003, 0x0118, 0xa186, 0x0006, 0x1190, 0x6834, 0xa206,
+	0x0140, 0x6838, 0xa206, 0x1160, 0x6108, 0x6834, 0xa106, 0x1140,
+	0x0020, 0x6008, 0x6938, 0xa106, 0x1118, 0x6018, 0x6918, 0xa106,
+	0x001e, 0x002e, 0x00ce, 0x0005, 0xa085, 0x0001, 0x0cc8, 0x6944,
+	0xd1cc, 0x0198, 0xa18c, 0x00ff, 0xa18e, 0x0002, 0x1170, 0xad88,
+	0x001e, 0x210c, 0xa18c, 0x0f00, 0x810f, 0xa18e, 0x0001, 0x1128,
+	0x6810, 0x6914, 0xa115, 0x190c, 0x9483, 0x0005, 0x080c, 0x861d,
+	0x0804, 0x7173, 0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x1515,
+	0x0013, 0x006e, 0x0005, 0xa16b, 0xa646, 0xa76c, 0xa16b, 0xa16b,
+	0xa16b, 0xa16b, 0xa16b, 0xa1a3, 0xa7f0, 0xa16b, 0xa16b, 0xa16b,
+	0xa16b, 0xa16b, 0xa16b, 0x080c, 0x1515, 0x0066, 0x6000, 0xa0b2,
+	0x0010, 0x1a0c, 0x1515, 0x0013, 0x006e, 0x0005, 0xa186, 0xac77,
+	0xa186, 0xa186, 0xa186, 0xa186, 0xa186, 0xa186, 0xac39, 0xacbf,
+	0xa186, 0xb26c, 0xb29c, 0xb26c, 0xb29c, 0xa186, 0x080c, 0x1515,
+	0x0066, 0x6000, 0xa0b2, 0x0010, 0x1a0c, 0x1515, 0x0013, 0x006e,
+	0x0005, 0xa1a1, 0xa940, 0xaa0d, 0xaa3a, 0xaabe, 0xa1a1, 0xabab,
+	0xab56, 0xa7fc, 0xac0f, 0xac24, 0xa1a1, 0xa1a1, 0xa1a1, 0xa1a1,
+	0xa1a1, 0x080c, 0x1515, 0xa1b2, 0x0080, 0x1a0c, 0x1515, 0x2100,
+	0xa1b2, 0x0040, 0x1a04, 0xa5ba, 0x0002, 0xa1ed, 0xa3b8, 0xa1ed,
+	0xa1ed, 0xa1ed, 0xa3bf, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed,
+	0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed,
+	0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ef, 0xa24d, 0xa25c, 0xa2aa,
+	0xa2c8, 0xa346, 0xa3a5, 0xa1ed, 0xa1ed, 0xa3c2, 0xa1ed, 0xa1ed,
+	0xa3d5, 0xa3e0, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa46b,
+	0xa1ed, 0xa1ed, 0xa47e, 0xa1ed, 0xa1ed, 0xa436, 0xa1ed, 0xa1ed,
+	0xa1ed, 0xa496, 0xa1ed, 0xa1ed, 0xa1ed, 0xa510, 0xa1ed, 0xa1ed,
+	0xa1ed, 0xa1ed, 0xa1ed, 0xa1ed, 0xa581, 0x080c, 0x1515, 0x080c,
+	0x5309, 0x1150, 0x2001, 0xb535, 0x2004, 0xd0cc, 0x1128, 0xa084,
+	0x0009, 0xa086, 0x0008, 0x1140, 0x6007, 0x0009, 0x602b, 0x0009,
+	0x6013, 0x0000, 0x0804, 0xa3b3, 0x080c, 0x52f9, 0x00e6, 0x00c6,
+	0x0036, 0x0026, 0x0016, 0x6218, 0x2270, 0x72a0, 0x0026, 0x2019,
+	0x0029, 0x080c, 0x6df5, 0x0076, 0x2039, 0x0000, 0x080c, 0x6d02,
+	0x2c08, 0x080c, 0xae82, 0x007e, 0x001e, 0x2e60, 0x080c, 0x51aa,
+	0x001e, 0x002e, 0x003e, 0x00ce, 0x00ee, 0x6618, 0x00c6, 0x2660,
+	0x080c, 0x4fb8, 0x00ce, 0xa6b0, 0x0001, 0x2634, 0xa684, 0x00ff,
+	0xa082, 0x0006, 0x0278, 0x080c, 0xadc6, 0x1904, 0xa2a4, 0x080c,
+	0xad66, 0x1120, 0x6007, 0x0008, 0x0804, 0xa3b3, 0x6007, 0x0009,
+	0x0804, 0xa3b3, 0x080c, 0xaf7b, 0x0128, 0x080c, 0xadc6, 0x0d78,
+	0x0804, 0xa2a4, 0x6013, 0x1900, 0x0c88, 0x080c, 0x2dbf, 0x1904,
+	0xa5b7, 0x6106, 0x080c, 0xad20, 0x6007, 0x0006, 0x0804, 0xa3b3,
+	0x6007, 0x0007, 0x0804, 0xa3b3, 0x080c, 0xb2d0, 0x1904, 0xa5b7,
+	0x080c, 0x2dbf, 0x1904, 0xa5b7, 0x00d6, 0x6618, 0x2668, 0x6e04,
+	0xa684, 0x00ff, 0xa082, 0x0006, 0x1220, 0x2001, 0x0001, 0x080c,
+	0x4eeb, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0188, 0xa686,
+	0x0004, 0x0170, 0x6e04, 0xa6b4, 0x00ff, 0xa686, 0x0006, 0x0140,
+	0xa686, 0x0004, 0x0128, 0xa686, 0x0005, 0x0110, 0x00de, 0x00e0,
+	0x080c, 0xae24, 0x11a0, 0xa686, 0x0006, 0x1150, 0x0026, 0x6218,
+	0xa290, 0x0028, 0x2214, 0x2009, 0x0000, 0x080c, 0x2ce1, 0x002e,
+	0x080c, 0x504b, 0x6007, 0x000a, 0x00de, 0x0804, 0xa3b3, 0x6007,
+	0x000b, 0x00de, 0x0804, 0xa3b3, 0x080c, 0x2c9c, 0x6007, 0x0001,
+	0x0804, 0xa3b3, 0x080c, 0xb2d0, 0x1904, 0xa5b7, 0x080c, 0x2dbf,
+	0x1904, 0xa5b7, 0x6618, 0x00d6, 0x2668, 0x6e04, 0x00de, 0xa686,
+	0x0707, 0x0d50, 0x0026, 0x6218, 0xa290, 0x0028, 0x2214, 0x2009,
+	0x0000, 0x080c, 0x2ce1, 0x002e, 0x6007, 0x000c, 0x0804, 0xa3b3,
+	0x080c, 0x5309, 0x1140, 0x2001, 0xb535, 0x2004, 0xa084, 0x0009,
+	0xa086, 0x0008, 0x1110, 0x0804, 0xa1fc, 0x080c, 0x52f9, 0x6618,
+	0xa6b0, 0x0001, 0x2634, 0xa684, 0x00ff, 0xa082, 0x0006, 0x06e8,
+	0x1138, 0x0026, 0x2001, 0x0006, 0x080c, 0x4f2a, 0x002e, 0x0050,
+	0xa6b4, 0xff00, 0x8637, 0xa686, 0x0004, 0x0120, 0xa686, 0x0006,
+	0x1904, 0xa2a4, 0x080c, 0xae31, 0x1120, 0x6007, 0x000e, 0x0804,
+	0xa3b3, 0x0046, 0x6418, 0xa4a0, 0x0028, 0x2424, 0xa4a4, 0x00ff,
+	0x8427, 0x0046, 0x080c, 0x2c9c, 0x004e, 0x0016, 0xa006, 0x2009,
+	0xb553, 0x210c, 0xd1a4, 0x0158, 0x2009, 0x0029, 0x080c, 0xb0e8,
+	0x6018, 0x00d6, 0x2068, 0x6800, 0xc0e5, 0x6802, 0x00de, 0x001e,
+	0x004e, 0x6007, 0x0001, 0x0804, 0xa3b3, 0x2001, 0x0001, 0x080c,
+	0x4eeb, 0x0156, 0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019,
+	0xb505, 0x2011, 0xbb90, 0x080c, 0x90da, 0x003e, 0x002e, 0x001e,
+	0x015e, 0xa005, 0x0168, 0xa6b4, 0xff00, 0x8637, 0xa682, 0x0004,
+	0x0a04, 0xa2a4, 0xa682, 0x0007, 0x0a04, 0xa2f2, 0x0804, 0xa2a4,
+	0x6013, 0x1900, 0x6007, 0x0009, 0x0804, 0xa3b3, 0x080c, 0x5309,
+	0x1140, 0x2001, 0xb535, 0x2004, 0xa084, 0x0009, 0xa086, 0x0008,
+	0x1110, 0x0804, 0xa1fc, 0x080c, 0x52f9, 0x6618, 0xa6b0, 0x0001,
+	0x2634, 0xa684, 0x00ff, 0xa082, 0x0006, 0x06b8, 0xa6b4, 0xff00,
+	0x8637, 0xa686, 0x0004, 0x0120, 0xa686, 0x0006, 0x1904, 0xa2a4,
+	0x080c, 0xae59, 0x1138, 0x080c, 0xad66, 0x1120, 0x6007, 0x0010,
+	0x0804, 0xa3b3, 0x0046, 0x6418, 0xa4a0, 0x0028, 0x2424, 0xa4a4,
+	0x00ff, 0x8427, 0x0046, 0x080c, 0x2c9c, 0x004e, 0x0016, 0xa006,
+	0x2009, 0xb553, 0x210c, 0xd1a4, 0x0158, 0x2009, 0x0029, 0x080c,
+	0xb0e8, 0x6018, 0x00d6, 0x2068, 0x6800, 0xc0e5, 0x6802, 0x00de,
+	0x001e, 0x004e, 0x6007, 0x0001, 0x00f0, 0x080c, 0xaf7b, 0x0140,
+	0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006, 0x0950, 0x0804, 0xa2a4,
+	0x6013, 0x1900, 0x6007, 0x0009, 0x0070, 0x080c, 0x2dbf, 0x1904,
+	0xa5b7, 0x080c, 0xb2d0, 0x1904, 0xa5b7, 0x080c, 0xa5df, 0x1904,
+	0xa2a4, 0x6007, 0x0012, 0x6003, 0x0001, 0x080c, 0x6cd3, 0x0005,
+	0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x6cd3, 0x0cc0, 0x6007,
+	0x0005, 0x0cc0, 0x080c, 0xb2d0, 0x1904, 0xa5b7, 0x080c, 0x2dbf,
+	0x1904, 0xa5b7, 0x080c, 0xa5df, 0x1904, 0xa2a4, 0x6007, 0x0020,
+	0x6003, 0x0001, 0x080c, 0x6cd3, 0x0005, 0x080c, 0x2dbf, 0x1904,
+	0xa5b7, 0x6007, 0x0023, 0x6003, 0x0001, 0x080c, 0x6cd3, 0x0005,
+	0x080c, 0xb2d0, 0x1904, 0xa5b7, 0x080c, 0x2dbf, 0x1904, 0xa5b7,
+	0x080c, 0xa5df, 0x1904, 0xa2a4, 0x0016, 0x0026, 0x2011, 0xbb91,
+	0x2214, 0xa286, 0xffff, 0x0190, 0x2c08, 0x080c, 0x9c4a, 0x01e0,
+	0x2260, 0x2011, 0xbb90, 0x2214, 0x6008, 0xa206, 0x11a8, 0x6018,
+	0xa190, 0x0006, 0x2214, 0xa206, 0x01e8, 0x0070, 0x2011, 0xbb90,
+	0x2214, 0x2c08, 0xa006, 0x080c, 0xb0ba, 0x11a0, 0x2011, 0xbb91,
+	0x2214, 0xa286, 0xffff, 0x01c0, 0x2160, 0x6007, 0x0026, 0x6013,
+	0x1700, 0x2011, 0xbb89, 0x2214, 0xa296, 0xffff, 0x1180, 0x6007,
+	0x0025, 0x0068, 0x601c, 0xa086, 0x0007, 0x1d70, 0x6004, 0xa086,
+	0x0024, 0x1110, 0x080c, 0x861d, 0x2160, 0x6007, 0x0025, 0x6003,
+	0x0001, 0x080c, 0x6cd3, 0x002e, 0x001e, 0x0005, 0x2001, 0x0001,
+	0x080c, 0x4eeb, 0x0156, 0x0016, 0x0026, 0x0036, 0x20a9, 0x0004,
+	0x2019, 0xb505, 0x2011, 0xbb96, 0x080c, 0x90da, 0x003e, 0x002e,
+	0x001e, 0x015e, 0x0120, 0x6007, 0x0031, 0x0804, 0xa3b3, 0x080c,
+	0x8df6, 0x080c, 0x5acf, 0x11b0, 0x0006, 0x0026, 0x0036, 0x080c,
+	0x5aeb, 0x1158, 0x2001, 0xb79f, 0x2003, 0x0001, 0x2001, 0xb500,
+	0x2003, 0x0001, 0x080c, 0x5a07, 0x0010, 0x080c, 0x5aa6, 0x003e,
+	0x002e, 0x000e, 0x0005, 0x080c, 0x2dbf, 0x1904, 0xa5b7, 0x080c,
+	0xa5df, 0x1904, 0xa2a4, 0x6106, 0x080c, 0xa5fb, 0x6007, 0x002b,
+	0x0804, 0xa3b3, 0x6007, 0x002c, 0x0804, 0xa3b3, 0x080c, 0xb2d0,
+	0x1904, 0xa5b7, 0x080c, 0x2dbf, 0x1904, 0xa5b7, 0x080c, 0xa5df,
+	0x1904, 0xa2a4, 0x6106, 0x080c, 0xa5ff, 0x1120, 0x6007, 0x002e,
+	0x0804, 0xa3b3, 0x6007, 0x002f, 0x0804, 0xa3b3, 0x080c, 0x2dbf,
+	0x1904, 0xa5b7, 0x00e6, 0x00d6, 0x00c6, 0x6018, 0xa080, 0x0001,
+	0x200c, 0xa184, 0x00ff, 0xa086, 0x0006, 0x0158, 0xa184, 0xff00,
+	0x8007, 0xa086, 0x0006, 0x0128, 0x00ce, 0x00de, 0x00ee, 0x0804,
+	0xa3b8, 0x2001, 0xb572, 0x2004, 0xd0e4, 0x0904, 0xa50d, 0x2071,
+	0xbb8c, 0x7010, 0x6036, 0x7014, 0x603a, 0x7108, 0x720c, 0x2001,
+	0xb553, 0x2004, 0xd0a4, 0x0140, 0x6018, 0x2068, 0x6810, 0xa106,
+	0x1118, 0x6814, 0xa206, 0x01f8, 0x2001, 0xb553, 0x2004, 0xd0ac,
+	0x1590, 0x2069, 0xb500, 0x6874, 0xa206, 0x1568, 0x6870, 0xa106,
+	0x1550, 0x7210, 0x080c, 0x9c4a, 0x0558, 0x080c, 0xb154, 0x0540,
+	0x622a, 0x6007, 0x0036, 0x6003, 0x0001, 0x080c, 0x6c8d, 0x00ce,
+	0x00de, 0x00ee, 0x0005, 0x7214, 0xa286, 0xffff, 0x0150, 0x080c,
+	0x9c4a, 0x01b0, 0xa280, 0x0002, 0x2004, 0x7110, 0xa106, 0x1180,
+	0x0c08, 0x7210, 0x2c08, 0xa085, 0x0001, 0x080c, 0xb0ba, 0x2c10,
+	0x2160, 0x0130, 0x08b8, 0x6007, 0x0037, 0x6013, 0x1500, 0x08d8,
+	0x6007, 0x0037, 0x6013, 0x1700, 0x08b0, 0x6007, 0x0012, 0x0898,
+	0x080c, 0x2dbf, 0x1904, 0xa5b7, 0x6018, 0xa080, 0x0001, 0x2004,
+	0xa084, 0xff00, 0x8007, 0xa086, 0x0006, 0x1904, 0xa3b8, 0x00e6,
+	0x00d6, 0x00c6, 0x2001, 0xb572, 0x2004, 0xd0e4, 0x0904, 0xa579,
+	0x2069, 0xb500, 0x2071, 0xbb8c, 0x7008, 0x6036, 0x720c, 0x623a,
+	0xa286, 0xffff, 0x1150, 0x7208, 0x00c6, 0x2c08, 0xa085, 0x0001,
+	0x080c, 0xb0ba, 0x2c10, 0x00ce, 0x0588, 0x080c, 0x9c4a, 0x0570,
+	0x00c6, 0x0026, 0x2260, 0x080c, 0x991d, 0x002e, 0x00ce, 0x7118,
+	0xa18c, 0xff00, 0x810f, 0xa186, 0x0001, 0x0158, 0xa186, 0x0005,
+	0x0118, 0xa186, 0x0007, 0x1178, 0xa280, 0x0004, 0x2004, 0xa005,
+	0x0150, 0x0056, 0x7510, 0x7614, 0x080c, 0xb16b, 0x005e, 0x00ce,
+	0x00de, 0x00ee, 0x0005, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013,
+	0x2a00, 0x6003, 0x0001, 0x080c, 0x6c8d, 0x0c88, 0x6007, 0x003b,
+	0x602b, 0x0009, 0x6013, 0x1700, 0x6003, 0x0001, 0x080c, 0x6c8d,
+	0x0c30, 0x6007, 0x003b, 0x602b, 0x000b, 0x6013, 0x0000, 0x0804,
+	0xa4e3, 0x00e6, 0x0026, 0x080c, 0x5309, 0x0558, 0x080c, 0x52f9,
+	0x080c, 0xb34b, 0x1520, 0x2071, 0xb500, 0x70d4, 0xc085, 0x70d6,
+	0x00f6, 0x2079, 0x0100, 0x72a0, 0xa284, 0x00ff, 0x7072, 0x78e6,
+	0xa284, 0xff00, 0x7274, 0xa205, 0x7076, 0x78ea, 0x00fe, 0x70df,
+	0x0000, 0x2001, 0xb553, 0x2004, 0xd0a4, 0x0120, 0x2011, 0xb7f9,
+	0x2013, 0x07d0, 0xd0ac, 0x1128, 0x080c, 0x2ab8, 0x0010, 0x080c,
+	0xb377, 0x002e, 0x00ee, 0x080c, 0x861d, 0x0804, 0xa3b7, 0x080c,
+	0x861d, 0x0005, 0x2600, 0x0002, 0xa5c5, 0xa5c5, 0xa5c5, 0xa5c5,
+	0xa5c5, 0xa5c7, 0xa5c5, 0xa5c5, 0xa5c5, 0x080c, 0x1515, 0x080c,
+	0xb2d0, 0x1d68, 0x080c, 0x2dbf, 0x1d50, 0x0089, 0x1138, 0x6007,
+	0x0045, 0x6003, 0x0001, 0x080c, 0x6cd3, 0x0005, 0x080c, 0x2c9c,
+	0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x6cd3, 0x0005, 0x00d6,
+	0x0066, 0x6618, 0x2668, 0x6e04, 0xa6b4, 0xff00, 0x8637, 0xa686,
+	0x0006, 0x0170, 0xa686, 0x0004, 0x0158, 0x6e04, 0xa6b4, 0x00ff,
+	0xa686, 0x0006, 0x0128, 0xa686, 0x0004, 0x0110, 0xa085, 0x0001,
+	0x006e, 0x00de, 0x0005, 0x00d6, 0x0449, 0x00de, 0x0005, 0x00d6,
+	0x0491, 0x11f0, 0x680c, 0xa08c, 0xff00, 0x6820, 0xa084, 0x00ff,
+	0xa115, 0x6212, 0x6824, 0x602a, 0xd1e4, 0x0118, 0x2009, 0x0001,
+	0x0060, 0xd1ec, 0x0168, 0x6920, 0xa18c, 0x00ff, 0x6824, 0x080c,
+	0x281d, 0x1130, 0x2110, 0x2009, 0x0000, 0x080c, 0x2ce1, 0x0018,
+	0xa085, 0x0001, 0x0008, 0xa006, 0x00de, 0x0005, 0x2069, 0xbb8d,
+	0x6800, 0xa082, 0x0010, 0x1228, 0x6013, 0x0000, 0xa085, 0x0001,
+	0x0008, 0xa006, 0x0005, 0x6013, 0x0000, 0x2069, 0xbb8c, 0x6808,
+	0xa084, 0xff00, 0xa086, 0x0800, 0x1140, 0x6800, 0xa084, 0x00ff,
+	0xa08e, 0x0014, 0x0110, 0xa08e, 0x0010, 0x0005, 0x6004, 0xa0b2,
+	0x0080, 0x1a0c, 0x1515, 0xa1b6, 0x0013, 0x1130, 0x2008, 0xa1b2,
+	0x0040, 0x1a04, 0xa746, 0x0092, 0xa1b6, 0x0027, 0x0120, 0xa1b6,
+	0x0014, 0x190c, 0x1515, 0x2001, 0x0007, 0x080c, 0x4f2a, 0x080c,
+	0x7090, 0x080c, 0x9e1d, 0x080c, 0x7173, 0x0005, 0xa6a6, 0xa6a8,
+	0xa6a6, 0xa6a6, 0xa6a6, 0xa6a8, 0xa6ba, 0xa73f, 0xa70a, 0xa73f,
+	0xa71b, 0xa73f, 0xa6ba, 0xa73f, 0xa737, 0xa73f, 0xa737, 0xa73f,
+	0xa73f, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6,
+	0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a8, 0xa6a6, 0xa73f, 0xa6a6,
+	0xa6a6, 0xa73f, 0xa6a6, 0xa73c, 0xa73f, 0xa6a6, 0xa6a6, 0xa6a6,
+	0xa6a6, 0xa73f, 0xa73f, 0xa6a6, 0xa73f, 0xa73f, 0xa6a6, 0xa6b4,
+	0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0xa73b, 0xa73f, 0xa6a6, 0xa6a6,
+	0xa73f, 0xa73f, 0xa6a6, 0xa6a6, 0xa6a6, 0xa6a6, 0x080c, 0x1515,
+	0x080c, 0x7090, 0x2001, 0xb7b6, 0x2004, 0x6016, 0x6003, 0x0002,
+	0x080c, 0x7173, 0x0804, 0xa745, 0x2001, 0x0000, 0x080c, 0x4eeb,
+	0x0804, 0xa73f, 0x00f6, 0x2079, 0xb552, 0x7804, 0x00fe, 0xd0ac,
+	0x1904, 0xa73f, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x6018, 0xa080,
+	0x0004, 0x2004, 0xa086, 0x00ff, 0x1140, 0x00f6, 0x2079, 0xb500,
+	0x7898, 0x8000, 0x789a, 0x00fe, 0x00e0, 0x00c6, 0x6018, 0x2060,
+	0x6000, 0xd0f4, 0x1140, 0x6010, 0xa005, 0x0128, 0x00ce, 0x080c,
+	0x3f3e, 0x0804, 0xa73f, 0x00ce, 0x2001, 0xb500, 0x2004, 0xa086,
+	0x0002, 0x1138, 0x00f6, 0x2079, 0xb500, 0x7898, 0x8000, 0x789a,
+	0x00fe, 0x2001, 0x0002, 0x080c, 0x4efd, 0x080c, 0x7090, 0x601f,
+	0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x6cd3, 0x080c,
+	0x7173, 0x00c6, 0x6118, 0x2160, 0x2009, 0x0001, 0x080c, 0x69a8,
+	0x00ce, 0x04d8, 0x6618, 0x00d6, 0x2668, 0x6e04, 0x00de, 0xa6b4,
+	0xff00, 0x8637, 0xa686, 0x0006, 0x0550, 0xa686, 0x0004, 0x0538,
+	0x2001, 0x0004, 0x0410, 0x2001, 0xb500, 0x2004, 0xa086, 0x0003,
+	0x1110, 0x080c, 0x3f3e, 0x2001, 0x0006, 0x04a1, 0x6618, 0x00d6,
+	0x2668, 0x6e04, 0x00de, 0xa6b4, 0xff00, 0x8637, 0xa686, 0x0006,
+	0x0170, 0x2001, 0x0006, 0x0048, 0x2001, 0x0004, 0x0030, 0x2001,
+	0x0006, 0x0401, 0x0020, 0x0018, 0x0010, 0x080c, 0x4f2a, 0x080c,
+	0x7090, 0x080c, 0x861d, 0x080c, 0x7173, 0x0005, 0x2600, 0x0002,
+	0xa751, 0xa751, 0xa751, 0xa751, 0xa751, 0xa753, 0xa751, 0xa751,
+	0xa751, 0x080c, 0x1515, 0x080c, 0x7090, 0x080c, 0x861d, 0x080c,
+	0x7173, 0x0005, 0x0016, 0x00d6, 0x6118, 0x2168, 0x6900, 0xd184,
+	0x0140, 0x080c, 0x4efd, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x080c,
+	0x2cc2, 0x00de, 0x001e, 0x0005, 0x00d6, 0x6618, 0x2668, 0x6804,
+	0xa084, 0xff00, 0x8007, 0x00de, 0xa0b2, 0x000c, 0x1a0c, 0x1515,
+	0xa1b6, 0x0015, 0x1110, 0x003b, 0x0028, 0xa1b6, 0x0016, 0x190c,
+	0x1515, 0x006b, 0x0005, 0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf,
+	0x8cdf, 0xa7dc, 0xa79b, 0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf,
+	0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf, 0x8cdf, 0xa7dc, 0xa7e3, 0x8cdf,
+	0x8cdf, 0x8cdf, 0x8cdf, 0x00f6, 0x2079, 0xb552, 0x7804, 0xd0ac,
+	0x11e0, 0x6018, 0xa07d, 0x01c8, 0x7800, 0xd0f4, 0x1118, 0x7810,
+	0xa005, 0x1198, 0x2001, 0x0000, 0x080c, 0x4eeb, 0x2001, 0x0002,
+	0x080c, 0x4efd, 0x601f, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002,
+	0x080c, 0x6cd3, 0x080c, 0x7173, 0x00e8, 0x2011, 0xbb83, 0x2204,
+	0x8211, 0x220c, 0x080c, 0x281d, 0x11a8, 0x00c6, 0x080c, 0x4fa9,
+	0x0120, 0x00ce, 0x080c, 0x861d, 0x0068, 0x6010, 0x0006, 0x6014,
+	0x0006, 0x080c, 0x4c0b, 0x000e, 0x6016, 0x000e, 0x6012, 0x00ce,
+	0x080c, 0x861d, 0x00fe, 0x0005, 0x6604, 0xa6b6, 0x001e, 0x1110,
+	0x080c, 0x861d, 0x0005, 0x080c, 0x8f95, 0x1138, 0x6003, 0x0001,
+	0x6007, 0x0001, 0x080c, 0x6cd3, 0x0010, 0x080c, 0x861d, 0x0005,
+	0x6004, 0xa08a, 0x0080, 0x1a0c, 0x1515, 0x080c, 0x7090, 0x080c,
+	0x9e1d, 0x080c, 0x7173, 0x0005, 0xa182, 0x0040, 0x0002, 0xa812,
+	0xa812, 0xa812, 0xa812, 0xa814, 0xa812, 0xa812, 0xa812, 0xa812,
+	0xa812, 0xa812, 0xa812, 0xa812, 0xa812, 0xa812, 0xa812, 0xa812,
+	0xa812, 0xa812, 0x080c, 0x1515, 0x00d6, 0x00e6, 0x00f6, 0x0156,
+	0x0046, 0x0026, 0x6218, 0xa280, 0x002b, 0x2004, 0xa005, 0x0120,
+	0x2021, 0x0000, 0x080c, 0xb31c, 0x6106, 0x2071, 0xbb80, 0x7444,
+	0xa4a4, 0xff00, 0x0904, 0xa878, 0xa486, 0x2000, 0x1130, 0x2009,
+	0x0001, 0x2011, 0x0200, 0x080c, 0x6b1a, 0x080c, 0x15f8, 0x090c,
+	0x1515, 0x6003, 0x0007, 0x2d00, 0x6837, 0x010d, 0x6803, 0x0000,
+	0x683b, 0x0000, 0x6c5a, 0x2c00, 0x685e, 0x6008, 0x68b2, 0x6018,
+	0x2078, 0x78a0, 0x8007, 0x7130, 0x694a, 0x0016, 0xa084, 0xff00,
+	0x6846, 0x684f, 0x0000, 0x6853, 0x0000, 0x6857, 0x0036, 0x080c,
+	0x5408, 0x001e, 0xa486, 0x2000, 0x1130, 0x2019, 0x0017, 0x080c,
+	0xb065, 0x0804, 0xa8d5, 0xa486, 0x0400, 0x1130, 0x2019, 0x0002,
+	0x080c, 0xb017, 0x0804, 0xa8d5, 0xa486, 0x0200, 0x1110, 0x080c,
+	0xaffc, 0xa486, 0x1000, 0x1110, 0x080c, 0xb04a, 0x0804, 0xa8d5,
+	0x2069, 0xb874, 0x6a00, 0xd284, 0x0904, 0xa93c, 0xa284, 0x0300,
+	0x1904, 0xa935, 0x6804, 0xa005, 0x0904, 0xa91d, 0x2d78, 0x6003,
+	0x0007, 0x080c, 0x15df, 0x0904, 0xa8dc, 0x7800, 0xd08c, 0x1118,
+	0x7804, 0x8001, 0x7806, 0x6013, 0x0000, 0x6803, 0x0000, 0x6837,
+	0x0116, 0x683b, 0x0000, 0x6008, 0x68b2, 0x2c00, 0x684a, 0x6018,
+	0x2078, 0x78a0, 0x8007, 0x7130, 0x6986, 0x6846, 0x7928, 0x698a,
+	0x792c, 0x698e, 0x7930, 0x6992, 0x7934, 0x6996, 0x6853, 0x003d,
+	0x7244, 0xa294, 0x0003, 0xa286, 0x0002, 0x1118, 0x684f, 0x0040,
+	0x0040, 0xa286, 0x0001, 0x1118, 0x684f, 0x0080, 0x0010, 0x684f,
+	0x0000, 0x20a9, 0x000a, 0x2001, 0xbb90, 0xad90, 0x0015, 0x200c,
+	0x810f, 0x2112, 0x8000, 0x8210, 0x1f04, 0xa8c7, 0x200c, 0x6982,
+	0x8000, 0x200c, 0x697e, 0x080c, 0x5408, 0x002e, 0x004e, 0x015e,
+	0x00fe, 0x00ee, 0x00de, 0x0005, 0x2001, 0xb50e, 0x2004, 0xd084,
+	0x0120, 0x080c, 0x15f8, 0x1904, 0xa88d, 0x6013, 0x0100, 0x6003,
+	0x0001, 0x6007, 0x0041, 0x080c, 0x6c8d, 0x080c, 0x7173, 0x0c28,
+	0x2069, 0xbb92, 0x2d04, 0xa084, 0xff00, 0xa086, 0x1200, 0x11a8,
+	0x2069, 0xbb80, 0x686c, 0xa084, 0x00ff, 0x0016, 0x6110, 0xa18c,
+	0x0700, 0xa10d, 0x6112, 0x001e, 0x6003, 0x0001, 0x6007, 0x0043,
+	0x080c, 0x6c8d, 0x080c, 0x7173, 0x0840, 0x6868, 0x602a, 0x686c,
+	0x602e, 0x6013, 0x0200, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c,
+	0x6c8d, 0x080c, 0x7173, 0x0804, 0xa8d5, 0x2001, 0xb50d, 0x2004,
+	0xd0ec, 0x0120, 0x2011, 0x8049, 0x080c, 0x3ecc, 0x6013, 0x0300,
+	0x0010, 0x6013, 0x0100, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c,
+	0x6c8d, 0x080c, 0x7173, 0x0804, 0xa8d5, 0x6013, 0x0500, 0x0c98,
+	0x6013, 0x0600, 0x0804, 0xa8f0, 0x6013, 0x0200, 0x0804, 0xa8f0,
+	0xa186, 0x0013, 0x1170, 0x6004, 0xa08a, 0x0040, 0x0a0c, 0x1515,
+	0xa08a, 0x0053, 0x1a0c, 0x1515, 0xa082, 0x0040, 0x2008, 0x0804,
+	0xa9ca, 0xa186, 0x0051, 0x0138, 0xa186, 0x0047, 0x11d8, 0x6004,
+	0xa086, 0x0041, 0x0518, 0x2001, 0x0109, 0x2004, 0xd084, 0x01f0,
+	0x0126, 0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x080c, 0x6b74,
+	0x002e, 0x001e, 0x000e, 0x012e, 0x6000, 0xa086, 0x0002, 0x1170,
+	0x0804, 0xaa0d, 0xa186, 0x0027, 0x0120, 0xa186, 0x0014, 0x190c,
+	0x1515, 0x6004, 0xa082, 0x0040, 0x2008, 0x001a, 0x080c, 0x8663,
+	0x0005, 0xa994, 0xa996, 0xa996, 0xa9ba, 0xa994, 0xa994, 0xa994,
+	0xa994, 0xa994, 0xa994, 0xa994, 0xa994, 0xa994, 0xa994, 0xa994,
+	0xa994, 0xa994, 0xa994, 0xa994, 0x080c, 0x1515, 0x080c, 0x7090,
+	0x080c, 0x7173, 0x0036, 0x00d6, 0x6010, 0xa06d, 0x01c0, 0xad84,
+	0xf000, 0x01a8, 0x6003, 0x0002, 0x6018, 0x2004, 0xd0bc, 0x1178,
+	0x2019, 0x0004, 0x080c, 0xb099, 0x6013, 0x0000, 0x6014, 0xa005,
+	0x1120, 0x2001, 0xb7b7, 0x2004, 0x6016, 0x6003, 0x0007, 0x00de,
+	0x003e, 0x0005, 0x00d6, 0x080c, 0x7090, 0x080c, 0x7173, 0x080c,
+	0x9c5a, 0x0120, 0x6010, 0x2068, 0x080c, 0x160f, 0x080c, 0x9e1d,
+	0x00de, 0x0005, 0x0002, 0xa9de, 0xa9fb, 0xa9e7, 0xaa07, 0xa9de,
+	0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de,
+	0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de, 0xa9de, 0x080c, 0x1515,
+	0x6010, 0xa088, 0x0013, 0x2104, 0xa085, 0x0400, 0x200a, 0x080c,
+	0x7090, 0x6010, 0xa080, 0x0013, 0x2004, 0xd0b4, 0x0138, 0x6003,
+	0x0007, 0x2009, 0x0043, 0x080c, 0x864c, 0x0010, 0x6003, 0x0002,
+	0x080c, 0x7173, 0x0005, 0x080c, 0x7090, 0x080c, 0xb2d7, 0x1120,
+	0x080c, 0x6aef, 0x080c, 0x861d, 0x080c, 0x7173, 0x0005, 0x080c,
+	0x7090, 0x2009, 0x0041, 0x0804, 0xab56, 0xa182, 0x0040, 0x0002,
+	0xaa23, 0xaa25, 0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa26,
+	0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa23, 0xaa23,
+	0xaa23, 0xaa31, 0xaa23, 0x080c, 0x1515, 0x0005, 0x6003, 0x0004,
+	0x6110, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10, 0x080c, 0x185e,
+	0x0005, 0x00d6, 0x080c, 0x6aef, 0x00de, 0x080c, 0xb33a, 0x080c,
+	0x861d, 0x0005, 0xa182, 0x0040, 0x0002, 0xaa50, 0xaa50, 0xaa50,
+	0xaa50, 0xaa50, 0xaa50, 0xaa50, 0xaa52, 0xaa50, 0xaa55, 0xaa8e,
+	0xaa50, 0xaa50, 0xaa50, 0xaa50, 0xaa8e, 0xaa50, 0xaa50, 0xaa50,
+	0x080c, 0x1515, 0x080c, 0x8663, 0x0005, 0x2001, 0xb572, 0x2004,
+	0xd0e4, 0x0158, 0x2001, 0x0100, 0x2004, 0xa082, 0x0005, 0x0228,
+	0x2001, 0x011f, 0x2004, 0x6036, 0x0010, 0x6037, 0x0000, 0x080c,
+	0x7126, 0x080c, 0x7230, 0x6010, 0x00d6, 0x2068, 0x684c, 0xd0fc,
+	0x0150, 0xa08c, 0x0003, 0xa18e, 0x0002, 0x0168, 0x2009, 0x0041,
+	0x00de, 0x0804, 0xab56, 0x6003, 0x0007, 0x6017, 0x0000, 0x080c,
+	0x6aef, 0x00de, 0x0005, 0x080c, 0xb2d7, 0x0110, 0x00de, 0x0005,
+	0x080c, 0x6aef, 0x080c, 0x861d, 0x00de, 0x0ca0, 0x0036, 0x080c,
+	0x7126, 0x080c, 0x7230, 0x6010, 0x00d6, 0x2068, 0x6018, 0x2004,
+	0xd0bc, 0x0188, 0x684c, 0xa084, 0x0003, 0xa086, 0x0002, 0x0140,
+	0x687c, 0x632c, 0xa31a, 0x632e, 0x6880, 0x6328, 0xa31b, 0x632a,
+	0x6003, 0x0002, 0x0080, 0x2019, 0x0004, 0x080c, 0xb099, 0x6014,
+	0xa005, 0x1128, 0x2001, 0xb7b7, 0x2004, 0x8003, 0x6016, 0x6013,
+	0x0000, 0x6003, 0x0007, 0x00de, 0x003e, 0x0005, 0xa186, 0x0013,
+	0x1150, 0x6004, 0xa086, 0x0042, 0x190c, 0x1515, 0x080c, 0x7090,
+	0x080c, 0x7173, 0x0005, 0xa186, 0x0027, 0x0118, 0xa186, 0x0014,
+	0x1180, 0x6004, 0xa086, 0x0042, 0x190c, 0x1515, 0x2001, 0x0007,
+	0x080c, 0x4f2a, 0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c, 0x7173,
+	0x0005, 0xa182, 0x0040, 0x0002, 0xaaf7, 0xaaf7, 0xaaf7, 0xaaf7,
+	0xaaf7, 0xaaf7, 0xaaf7, 0xaaf9, 0xab05, 0xaaf7, 0xaaf7, 0xaaf7,
+	0xaaf7, 0xaaf7, 0xaaf7, 0xaaf7, 0xaaf7, 0xaaf7, 0xaaf7, 0x080c,
+	0x1515, 0x0036, 0x0046, 0x20e1, 0x0005, 0x3d18, 0x3e20, 0x2c10,
+	0x080c, 0x185e, 0x004e, 0x003e, 0x0005, 0x6010, 0x00d6, 0x2068,
+	0x6810, 0x6a14, 0x0006, 0x0046, 0x0056, 0x6c7c, 0xa422, 0x6d80,
+	0x2200, 0xa52b, 0x602c, 0xa420, 0x642e, 0x6028, 0xa529, 0x652a,
+	0x005e, 0x004e, 0x000e, 0xa20d, 0x1178, 0x684c, 0xd0fc, 0x0120,
+	0x2009, 0x0041, 0x00de, 0x0490, 0x6003, 0x0007, 0x6017, 0x0000,
+	0x080c, 0x6aef, 0x00de, 0x0005, 0x0006, 0x00f6, 0x2c78, 0x080c,
+	0x5305, 0x00fe, 0x000e, 0x0120, 0x6003, 0x0002, 0x00de, 0x0005,
+	0x2009, 0xb50d, 0x210c, 0xd19c, 0x0118, 0x6003, 0x0007, 0x0010,
+	0x6003, 0x0006, 0x0021, 0x080c, 0x6af1, 0x00de, 0x0005, 0xd2fc,
+	0x0140, 0x8002, 0x8000, 0x8212, 0xa291, 0x0000, 0x2009, 0x0009,
+	0x0010, 0x2009, 0x0015, 0x6a6a, 0x6866, 0x0005, 0xa182, 0x0040,
+	0x0208, 0x0062, 0xa186, 0x0013, 0x0120, 0xa186, 0x0014, 0x190c,
+	0x1515, 0x6020, 0xd0dc, 0x090c, 0x1515, 0x0005, 0xab79, 0xab80,
+	0xab8c, 0xab98, 0xab79, 0xab79, 0xab79, 0xaba7, 0xab79, 0xab7b,
+	0xab7b, 0xab79, 0xab79, 0xab79, 0xab79, 0xab7b, 0xab79, 0xab7b,
+	0xab79, 0x080c, 0x1515, 0x6020, 0xd0dc, 0x090c, 0x1515, 0x0005,
+	0x6003, 0x0001, 0x6106, 0x080c, 0x6c8d, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x7173, 0x012e, 0x0005, 0x6003, 0x0001, 0x6106, 0x080c,
+	0x6c8d, 0x0126, 0x2091, 0x8000, 0x080c, 0x7173, 0x012e, 0x0005,
+	0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x1fa9, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x6cf0, 0x080c, 0x7230, 0x012e, 0x0005, 0xa016,
+	0x080c, 0x185e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0036, 0x00d6,
+	0xa182, 0x0040, 0x0023, 0x00de, 0x003e, 0x012e, 0x0005, 0xabc7,
+	0xabc9, 0xabdb, 0xabf6, 0xabc7, 0xabc7, 0xabc7, 0xac0b, 0xabc7,
+	0xabc7, 0xabc7, 0xabc7, 0xabc7, 0xabc7, 0xabc7, 0xabc7, 0x080c,
+	0x1515, 0x6010, 0x2068, 0x684c, 0xd0fc, 0x01f8, 0xa09c, 0x0003,
+	0xa39e, 0x0003, 0x01d0, 0x6003, 0x0001, 0x6106, 0x080c, 0x6c8d,
+	0x080c, 0x7173, 0x0498, 0x6010, 0x2068, 0x684c, 0xd0fc, 0x0168,
+	0xa09c, 0x0003, 0xa39e, 0x0003, 0x0140, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x6c8d, 0x080c, 0x7173, 0x0408, 0x6013, 0x0000, 0x6017,
+	0x0000, 0x2019, 0x0004, 0x080c, 0xb099, 0x00c0, 0x6010, 0x2068,
+	0x684c, 0xd0fc, 0x0d90, 0xa09c, 0x0003, 0xa39e, 0x0003, 0x0d68,
+	0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x1fa9, 0x080c, 0x6cf0,
+	0x080c, 0x7230, 0x0018, 0xa016, 0x080c, 0x185e, 0x0005, 0x080c,
+	0x7090, 0x6110, 0x81ff, 0x0158, 0x00d6, 0x2168, 0x080c, 0xb380,
+	0x0036, 0x2019, 0x0029, 0x080c, 0xb099, 0x003e, 0x00de, 0x080c,
+	0x9e1d, 0x080c, 0x7173, 0x0005, 0x080c, 0x7126, 0x6110, 0x81ff,
+	0x0158, 0x00d6, 0x2168, 0x080c, 0xb380, 0x0036, 0x2019, 0x0029,
+	0x080c, 0xb099, 0x003e, 0x00de, 0x080c, 0x9e1d, 0x080c, 0x7230,
+	0x0005, 0xa182, 0x0085, 0x0002, 0xac45, 0xac43, 0xac43, 0xac51,
+	0xac43, 0xac43, 0xac43, 0x080c, 0x1515, 0x6003, 0x000b, 0x6106,
+	0x080c, 0x6c8d, 0x0126, 0x2091, 0x8000, 0x080c, 0x7173, 0x012e,
+	0x0005, 0x0026, 0x00e6, 0x080c, 0xb2d0, 0x0118, 0x080c, 0x861d,
+	0x00d8, 0x2071, 0xbb80, 0x7224, 0x6212, 0x7220, 0x080c, 0xaf47,
+	0x0118, 0x6007, 0x0086, 0x0040, 0x6007, 0x0087, 0x7224, 0xa296,
+	0xffff, 0x1110, 0x6007, 0x0086, 0x6003, 0x0001, 0x080c, 0x6c8d,
+	0x080c, 0x7173, 0x080c, 0x7230, 0x00ee, 0x002e, 0x0005, 0xa186,
+	0x0013, 0x1160, 0x6004, 0xa08a, 0x0085, 0x0a0c, 0x1515, 0xa08a,
+	0x008c, 0x1a0c, 0x1515, 0xa082, 0x0085, 0x00a2, 0xa186, 0x0027,
+	0x0130, 0xa186, 0x0014, 0x0118, 0x080c, 0x8663, 0x0050, 0x2001,
+	0x0007, 0x080c, 0x4f2a, 0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c,
+	0x7173, 0x0005, 0xaca1, 0xaca3, 0xaca3, 0xaca1, 0xaca1, 0xaca1,
+	0xaca1, 0x080c, 0x1515, 0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c,
+	0x7173, 0x0005, 0xa182, 0x0085, 0x0a0c, 0x1515, 0xa182, 0x008c,
+	0x1a0c, 0x1515, 0xa182, 0x0085, 0x0002, 0xacbc, 0xacbc, 0xacbc,
+	0xacbe, 0xacbc, 0xacbc, 0xacbc, 0x080c, 0x1515, 0x0005, 0xa186,
+	0x0013, 0x0148, 0xa186, 0x0014, 0x0130, 0xa186, 0x0027, 0x0118,
+	0x080c, 0x8663, 0x0030, 0x080c, 0x7090, 0x080c, 0x9e1d, 0x080c,
+	0x7173, 0x0005, 0x0036, 0x080c, 0xb33a, 0x603f, 0x0000, 0x2019,
+	0x000b, 0x0031, 0x601f, 0x0006, 0x6003, 0x0007, 0x003e, 0x0005,
+	0x0126, 0x0036, 0x2091, 0x8000, 0x0086, 0x2c40, 0x0096, 0x2049,
+	0x0000, 0x080c, 0x8130, 0x009e, 0x008e, 0x1578, 0x0076, 0x2c38,
+	0x080c, 0x81d6, 0x007e, 0x1548, 0x6000, 0xa086, 0x0000, 0x0528,
+	0x601c, 0xa086, 0x0007, 0x0508, 0x00d6, 0x6000, 0xa086, 0x0004,
+	0x1150, 0x080c, 0xb33a, 0x601f, 0x0007, 0x2001, 0xb7b6, 0x2004,
+	0x6016, 0x080c, 0x194d, 0x6010, 0x2068, 0x080c, 0x9c5a, 0x0110,
+	0x080c, 0xb099, 0x00de, 0x6013, 0x0000, 0x080c, 0xb33a, 0x601f,
+	0x0007, 0x2001, 0xb7b6, 0x2004, 0x6016, 0x003e, 0x012e, 0x0005,
+	0x00f6, 0x00c6, 0x0036, 0x0156, 0x2079, 0xbb80, 0x7938, 0x783c,
+	0x080c, 0x281d, 0x15b0, 0x0016, 0x00c6, 0x080c, 0x4fa9, 0x1578,
+	0x001e, 0x002e, 0x0026, 0x0016, 0x2019, 0x0029, 0x080c, 0x8299,
+	0x080c, 0x6df5, 0x0076, 0x2039, 0x0000, 0x080c, 0x6d02, 0x007e,
+	0x001e, 0x0076, 0x2039, 0x0000, 0x080c, 0xae82, 0x007e, 0x080c,
+	0x51aa, 0x0026, 0x6204, 0xa294, 0xff00, 0x8217, 0xa286, 0x0006,
+	0x0118, 0xa286, 0x0004, 0x1118, 0x62a0, 0x080c, 0x2d55, 0x002e,
+	0x001e, 0x080c, 0x4c0b, 0x6612, 0x6516, 0xa006, 0x0010, 0x00ce,
+	0x001e, 0x015e, 0x003e, 0x00ce, 0x00fe, 0x0005, 0x00c6, 0x00d6,
+	0x00e6, 0x0016, 0x2009, 0xb521, 0x2104, 0xa086, 0x0074, 0x1904,
+	0xadbb, 0x2069, 0xbb8e, 0x690c, 0xa182, 0x0100, 0x06c0, 0x6908,
+	0xa184, 0x8000, 0x05e8, 0x2001, 0xb79e, 0x2004, 0xa005, 0x1160,
+	0x6018, 0x2070, 0x7010, 0xa084, 0x00ff, 0x0118, 0x7000, 0xd0f4,
+	0x0118, 0xa184, 0x0800, 0x0560, 0x6910, 0xa18a, 0x0001, 0x0610,
+	0x6914, 0x2069, 0xbbae, 0x6904, 0x81ff, 0x1198, 0x690c, 0xa182,
+	0x0100, 0x02a8, 0x6908, 0x81ff, 0x1178, 0x6910, 0xa18a, 0x0001,
+	0x0288, 0x6918, 0xa18a, 0x0001, 0x0298, 0x00d0, 0x6013, 0x0100,
+	0x00a0, 0x6013, 0x0300, 0x0088, 0x6013, 0x0500, 0x0070, 0x6013,
+	0x0700, 0x0058, 0x6013, 0x0900, 0x0040, 0x6013, 0x0b00, 0x0028,
+	0x6013, 0x0f00, 0x0010, 0x6013, 0x2d00, 0xa085, 0x0001, 0x0008,
+	0xa006, 0x001e, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6,
+	0x0026, 0x0036, 0x0156, 0x6218, 0x2268, 0x6b04, 0xa394, 0x00ff,
+	0xa286, 0x0006, 0x0190, 0xa286, 0x0004, 0x0178, 0xa394, 0xff00,
+	0x8217, 0xa286, 0x0006, 0x0148, 0xa286, 0x0004, 0x0130, 0x00c6,
+	0x2d60, 0x080c, 0x4fb8, 0x00ce, 0x04c0, 0x2011, 0xbb96, 0xad98,
+	0x000a, 0x20a9, 0x0004, 0x080c, 0x90da, 0x1580, 0x2011, 0xbb9a,
+	0xad98, 0x0006, 0x20a9, 0x0004, 0x080c, 0x90da, 0x1538, 0x0046,
+	0x0016, 0x6aa0, 0xa294, 0x00ff, 0x8227, 0xa006, 0x2009, 0xb553,
+	0x210c, 0xd1a4, 0x0138, 0x2009, 0x0029, 0x080c, 0xb0e8, 0x6800,
+	0xc0e5, 0x6802, 0x2019, 0x0029, 0x080c, 0x6df5, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x6d02, 0x2c08, 0x080c, 0xae82, 0x007e, 0x2001,
+	0x0007, 0x080c, 0x4f2a, 0x001e, 0x004e, 0xa006, 0x015e, 0x003e,
+	0x002e, 0x00de, 0x00ce, 0x0005, 0x00d6, 0x2069, 0xbb8e, 0x6800,
+	0xa086, 0x0800, 0x0118, 0x6013, 0x0000, 0x0008, 0xa006, 0x00de,
+	0x0005, 0x00c6, 0x00f6, 0x0016, 0x0026, 0x0036, 0x0156, 0x2079,
+	0xbb8c, 0x7930, 0x7834, 0x080c, 0x281d, 0x11a0, 0x080c, 0x4fa9,
+	0x1188, 0x2011, 0xbb90, 0xac98, 0x000a, 0x20a9, 0x0004, 0x080c,
+	0x90da, 0x1140, 0x2011, 0xbb94, 0xac98, 0x0006, 0x20a9, 0x0004,
+	0x080c, 0x90da, 0x015e, 0x003e, 0x002e, 0x001e, 0x00fe, 0x00ce,
+	0x0005, 0x00c6, 0x0006, 0x0016, 0x0026, 0x0036, 0x0156, 0x2011,
+	0xbb83, 0x2204, 0x8211, 0x220c, 0x080c, 0x281d, 0x11a0, 0x080c,
+	0x4fa9, 0x1188, 0x2011, 0xbb96, 0xac98, 0x000a, 0x20a9, 0x0004,
+	0x080c, 0x90da, 0x1140, 0x2011, 0xbb9a, 0xac98, 0x0006, 0x20a9,
+	0x0004, 0x080c, 0x90da, 0x015e, 0x003e, 0x002e, 0x001e, 0x000e,
+	0x00ce, 0x0005, 0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x0056,
+	0x0046, 0x0026, 0x0126, 0x2091, 0x8000, 0x2740, 0x2029, 0xb7e9,
+	0x252c, 0x2021, 0xb7ef, 0x2424, 0x2061, 0xbd00, 0x2071, 0xb500,
+	0x7648, 0x7068, 0x81ff, 0x0150, 0x0006, 0xa186, 0xb8f4, 0x000e,
+	0x0128, 0x8001, 0xa602, 0x1a04, 0xaf03, 0x0018, 0xa606, 0x0904,
+	0xaf03, 0x2100, 0xac06, 0x0904, 0xaefa, 0x080c, 0xb110, 0x0904,
+	0xaefa, 0x671c, 0xa786, 0x0001, 0x0904, 0xaf1e, 0xa786, 0x0004,
+	0x0904, 0xaf1e, 0xa786, 0x0007, 0x05e8, 0x2500, 0xac06, 0x05d0,
+	0x2400, 0xac06, 0x05b8, 0x080c, 0xb120, 0x15a0, 0x88ff, 0x0118,
+	0x6050, 0xa906, 0x1578, 0x00d6, 0x6000, 0xa086, 0x0004, 0x1120,
+	0x0016, 0x080c, 0x194d, 0x001e, 0xa786, 0x0008, 0x1148, 0x080c,
+	0x9e58, 0x1130, 0x080c, 0x8c19, 0x00de, 0x080c, 0x9e1d, 0x00d0,
+	0x6010, 0x2068, 0x080c, 0x9c5a, 0x0190, 0xa786, 0x0003, 0x1528,
+	0x6837, 0x0103, 0x6b4a, 0x6847, 0x0000, 0x080c, 0xb380, 0x0016,
+	0x080c, 0x9ecc, 0x080c, 0x5408, 0x001e, 0x080c, 0x9e11, 0x00de,
+	0x080c, 0x9e1d, 0xace0, 0x0018, 0x2001, 0xb517, 0x2004, 0xac02,
+	0x1210, 0x0804, 0xae96, 0x012e, 0x002e, 0x004e, 0x005e, 0x006e,
+	0x007e, 0x008e, 0x00ce, 0x00ee, 0x0005, 0xa786, 0x0006, 0x1150,
+	0xa386, 0x0005, 0x0128, 0x080c, 0xb380, 0x080c, 0xb099, 0x08f8,
+	0x00de, 0x0c00, 0xa786, 0x000a, 0x0968, 0x0850, 0x080c, 0xb120,
+	0x19c8, 0x81ff, 0x09b8, 0xa180, 0x0001, 0x2004, 0xa086, 0x0018,
+	0x0130, 0xa180, 0x0001, 0x2004, 0xa086, 0x002d, 0x1958, 0x6000,
+	0xa086, 0x0002, 0x1938, 0x080c, 0x9e47, 0x0130, 0x080c, 0x9e58,
+	0x1908, 0x080c, 0x8c19, 0x0038, 0x080c, 0x2cc2, 0x080c, 0x9e58,
+	0x1110, 0x080c, 0x8c19, 0x080c, 0x9e1d, 0x0804, 0xaefa, 0x00c6,
+	0x00e6, 0x0016, 0x2c08, 0x2170, 0xa006, 0x080c, 0xb0ba, 0x001e,
+	0x0120, 0x601c, 0xa084, 0x000f, 0x001b, 0x00ee, 0x00ce, 0x0005,
+	0xaf60, 0xaf60, 0xaf60, 0xaf60, 0xaf60, 0xaf60, 0xaf62, 0xaf60,
+	0xa006, 0x0005, 0x0046, 0x0016, 0x7018, 0xa080, 0x0028, 0x2024,
+	0xa4a4, 0x00ff, 0x8427, 0x2c00, 0x2009, 0x0020, 0x080c, 0xb0e8,
+	0x001e, 0x004e, 0x0036, 0x2019, 0x0002, 0x080c, 0xace0, 0x003e,
+	0xa085, 0x0001, 0x0005, 0x2001, 0x0001, 0x080c, 0x4eeb, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0xb505, 0x2011,
+	0xbb96, 0x080c, 0x90da, 0x003e, 0x002e, 0x001e, 0x015e, 0xa005,
+	0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x0026,
+	0x0126, 0x2091, 0x8000, 0x2740, 0x2061, 0xbd00, 0x2079, 0x0001,
+	0x8fff, 0x0904, 0xafef, 0x2071, 0xb500, 0x7648, 0x7068, 0x8001,
+	0xa602, 0x1a04, 0xafef, 0x88ff, 0x0128, 0x2800, 0xac06, 0x15b0,
+	0x2079, 0x0000, 0x080c, 0xb110, 0x0588, 0x2400, 0xac06, 0x0570,
+	0x671c, 0xa786, 0x0006, 0x1550, 0xa786, 0x0007, 0x0538, 0x88ff,
+	0x1140, 0x6018, 0xa206, 0x1510, 0x85ff, 0x0118, 0x6050, 0xa106,
+	0x11e8, 0x00d6, 0x6000, 0xa086, 0x0004, 0x1150, 0x080c, 0xb33a,
+	0x601f, 0x0007, 0x2001, 0xb7b6, 0x2004, 0x6016, 0x080c, 0x194d,
+	0x6010, 0x2068, 0x080c, 0x9c5a, 0x0120, 0x0046, 0x080c, 0xb099,
+	0x004e, 0x00de, 0x080c, 0x9e1d, 0x88ff, 0x1198, 0xace0, 0x0018,
+	0x2001, 0xb517, 0x2004, 0xac02, 0x1210, 0x0804, 0xafa0, 0xa006,
+	0x012e, 0x002e, 0x006e, 0x007e, 0x008e, 0x00ce, 0x00ee, 0x00fe,
+	0x0005, 0xa8c5, 0x0001, 0x0ca0, 0x0076, 0x0056, 0x0086, 0x2041,
+	0x0000, 0x2029, 0x0001, 0x2c20, 0x2019, 0x0002, 0x6218, 0x0096,
+	0x2049, 0x0000, 0x080c, 0x8130, 0x009e, 0x008e, 0x2039, 0x0000,
+	0x080c, 0x81d6, 0x080c, 0xaf91, 0x005e, 0x007e, 0x0005, 0x0026,
+	0x0046, 0x0056, 0x0076, 0x00c6, 0x0156, 0x2c20, 0x2128, 0x20a9,
+	0x007f, 0x2009, 0x0000, 0x0016, 0x0036, 0x080c, 0x4fa9, 0x11b0,
+	0x2c10, 0x0056, 0x0086, 0x2041, 0x0000, 0x2508, 0x2029, 0x0001,
+	0x0096, 0x2049, 0x0000, 0x080c, 0x8130, 0x009e, 0x008e, 0x2039,
+	0x0000, 0x080c, 0x81d6, 0x080c, 0xaf91, 0x005e, 0x003e, 0x001e,
+	0x8108, 0x1f04, 0xb023, 0x015e, 0x00ce, 0x007e, 0x005e, 0x004e,
+	0x002e, 0x0005, 0x0076, 0x0056, 0x6218, 0x0086, 0x2041, 0x0000,
+	0x2029, 0x0001, 0x2019, 0x0048, 0x0096, 0x2049, 0x0000, 0x080c,
+	0x8130, 0x009e, 0x008e, 0x2039, 0x0000, 0x080c, 0x81d6, 0x2c20,
+	0x080c, 0xaf91, 0x005e, 0x007e, 0x0005, 0x0026, 0x0046, 0x0056,
+	0x0076, 0x00c6, 0x0156, 0x2c20, 0x20a9, 0x007f, 0x2009, 0x0000,
+	0x0016, 0x0036, 0x080c, 0x4fa9, 0x11c0, 0x2c10, 0x0086, 0x2041,
+	0x0000, 0x2828, 0x0046, 0x2021, 0x0001, 0x080c, 0xb31c, 0x004e,
+	0x0096, 0x2049, 0x0000, 0x080c, 0x8130, 0x009e, 0x008e, 0x2039,
+	0x0000, 0x080c, 0x81d6, 0x080c, 0xaf91, 0x003e, 0x001e, 0x8108,
+	0x1f04, 0xb070, 0x015e, 0x00ce, 0x007e, 0x005e, 0x004e, 0x002e,
+	0x0005, 0x0016, 0x00f6, 0x3800, 0xd08c, 0x0130, 0xad82, 0x1000,
+	0x02b0, 0xad82, 0xb500, 0x0230, 0xad82, 0xed00, 0x0280, 0xad82,
+	0xffff, 0x1268, 0x6800, 0xa07d, 0x0138, 0x6803, 0x0000, 0x6b52,
+	0x080c, 0x5408, 0x2f68, 0x0cb0, 0x6b52, 0x080c, 0x5408, 0x00fe,
+	0x001e, 0x0005, 0x00e6, 0x0046, 0x0036, 0x2061, 0xbd00, 0xa005,
+	0x1138, 0x2071, 0xb500, 0x7448, 0x7068, 0x8001, 0xa402, 0x12d8,
+	0x2100, 0xac06, 0x0168, 0x6000, 0xa086, 0x0000, 0x0148, 0x6008,
+	0xa206, 0x1130, 0x6018, 0xa1a0, 0x0006, 0x2424, 0xa406, 0x0140,
+	0xace0, 0x0018, 0x2001, 0xb517, 0x2004, 0xac02, 0x1220, 0x0c40,
+	0xa085, 0x0001, 0x0008, 0xa006, 0x003e, 0x004e, 0x00ee, 0x0005,
+	0x00d6, 0x0006, 0x080c, 0x15f8, 0x000e, 0x090c, 0x1515, 0x6837,
+	0x010d, 0x685e, 0x0026, 0x2010, 0x080c, 0x9c4a, 0x2001, 0x0000,
+	0x0120, 0x2200, 0xa080, 0x0014, 0x2004, 0x002e, 0x684a, 0x6956,
+	0x6c46, 0x684f, 0x0000, 0x2001, 0xb7be, 0x2004, 0x6852, 0xa006,
+	0x68b2, 0x6802, 0x683a, 0x685a, 0x080c, 0x5408, 0x00de, 0x0005,
+	0x6700, 0xa786, 0x0000, 0x0158, 0xa786, 0x0001, 0x0140, 0xa786,
+	0x000a, 0x0128, 0xa786, 0x0009, 0x0110, 0xa085, 0x0001, 0x0005,
+	0x00e6, 0x6018, 0x2070, 0x70a0, 0xa206, 0x00ee, 0x0005, 0x0016,
+	0x6004, 0xa08e, 0x001e, 0x11a0, 0x8007, 0x6130, 0xa18c, 0x00ff,
+	0xa105, 0x6032, 0x6007, 0x0085, 0x6003, 0x000b, 0x601f, 0x0005,
+	0x2001, 0xb7b7, 0x2004, 0x6016, 0x080c, 0x6c8d, 0x080c, 0x7173,
+	0x001e, 0x0005, 0xe000, 0xe000, 0x0005, 0x6020, 0xd0e4, 0x0158,
+	0xd0cc, 0x0118, 0x080c, 0x9f35, 0x0030, 0x080c, 0xb33a, 0x080c,
+	0x6aef, 0x080c, 0x861d, 0x0005, 0xa280, 0x0007, 0x2004, 0xa084,
+	0x000f, 0x0002, 0xb163, 0xb163, 0xb163, 0xb168, 0xb163, 0xb165,
+	0xb165, 0xb163, 0xb165, 0xa006, 0x0005, 0x00c6, 0x2260, 0x00ce,
+	0xa085, 0x0001, 0x0005, 0xa280, 0x0007, 0x2004, 0xa084, 0x000f,
+	0x0002, 0xb17a, 0xb17a, 0xb17a, 0xb17a, 0xb17a, 0xb17a, 0xb185,
+	0xb17a, 0xb17a, 0x6007, 0x003b, 0x602b, 0x0009, 0x6013, 0x2a00,
+	0x6003, 0x0001, 0x080c, 0x6c8d, 0x0005, 0x00c6, 0x2260, 0x080c,
+	0xb33a, 0x603f, 0x0000, 0x6020, 0xc0f4, 0xc0cc, 0x6022, 0x6037,
+	0x0000, 0x00ce, 0x00d6, 0x2268, 0xa186, 0x0007, 0x1904, 0xb1e0,
+	0x6810, 0xa005, 0x0138, 0xa080, 0x0013, 0x2004, 0xd0fc, 0x1110,
+	0x00de, 0x08c0, 0x6007, 0x003a, 0x6003, 0x0001, 0x080c, 0x6c8d,
+	0x080c, 0x7173, 0x00c6, 0x2d60, 0x6100, 0xa186, 0x0002, 0x1904,
+	0xb269, 0x6010, 0xa005, 0x1138, 0x6000, 0xa086, 0x0007, 0x190c,
+	0x1515, 0x0804, 0xb269, 0xa08c, 0xf000, 0x1130, 0x0028, 0x2068,
+	0x6800, 0xa005, 0x1de0, 0x2d00, 0xa080, 0x0013, 0x2004, 0xa084,
+	0x0003, 0xa086, 0x0002, 0x1180, 0x6010, 0x2068, 0x684c, 0xc0dc,
+	0xc0f4, 0x684e, 0x6850, 0xc0f4, 0xc0fc, 0x6852, 0x2009, 0x0043,
+	0x080c, 0xab56, 0x0804, 0xb269, 0x2009, 0x0041, 0x0804, 0xb263,
+	0xa186, 0x0005, 0x15f0, 0x6810, 0xa080, 0x0013, 0x2004, 0xd0bc,
+	0x1118, 0x00de, 0x0804, 0xb17a, 0xd0b4, 0x0128, 0xd0fc, 0x090c,
+	0x1515, 0x0804, 0xb198, 0x6007, 0x003a, 0x6003, 0x0001, 0x080c,
+	0x6c8d, 0x080c, 0x7173, 0x00c6, 0x2d60, 0x6100, 0xa186, 0x0002,
+	0x0120, 0xa186, 0x0004, 0x1904, 0xb269, 0x2071, 0xb823, 0x7000,
+	0xa086, 0x0003, 0x1128, 0x7004, 0xac06, 0x1110, 0x7003, 0x0000,
+	0x6810, 0xa080, 0x0013, 0x200c, 0xc1f4, 0xc1dc, 0x2102, 0x8000,
+	0x200c, 0xc1f4, 0xc1fc, 0xc1bc, 0x2102, 0x2009, 0x0042, 0x0804,
+	0xb263, 0x0036, 0x00d6, 0x00d6, 0x080c, 0x15f8, 0x003e, 0x090c,
+	0x1515, 0x6837, 0x010d, 0x6803, 0x0000, 0x683b, 0x0000, 0x685b,
+	0x0000, 0x6b5e, 0x6857, 0x0045, 0x2c00, 0x6862, 0x6034, 0x6872,
+	0x2360, 0x6020, 0xc0dd, 0x6022, 0x6018, 0xa080, 0x0028, 0x2004,
+	0xa084, 0x00ff, 0x8007, 0x6350, 0x6b4a, 0x6846, 0x684f, 0x0000,
+	0x6853, 0x0000, 0x6d6a, 0x6e66, 0x686f, 0x0001, 0x080c, 0x5408,
+	0x2019, 0x0045, 0x6008, 0x2068, 0x080c, 0xace0, 0x2d00, 0x600a,
+	0x601f, 0x0006, 0x6003, 0x0007, 0x6017, 0x0000, 0x603f, 0x0000,
+	0x00de, 0x003e, 0x0038, 0x603f, 0x0000, 0x6003, 0x0007, 0x080c,
+	0xab56, 0x00ce, 0x00de, 0x0005, 0xa186, 0x0013, 0x1128, 0x6004,
+	0xa082, 0x0085, 0x2008, 0x00c2, 0xa186, 0x0027, 0x1178, 0x080c,
+	0x7090, 0x0036, 0x00d6, 0x6010, 0x2068, 0x2019, 0x0004, 0x080c,
+	0xb099, 0x00de, 0x003e, 0x080c, 0x7173, 0x0005, 0xa186, 0x0014,
+	0x0d70, 0x080c, 0x8663, 0x0005, 0xb295, 0xb293, 0xb293, 0xb293,
+	0xb293, 0xb293, 0xb295, 0x080c, 0x1515, 0x080c, 0x7090, 0x6003,
+	0x000c, 0x080c, 0x7173, 0x0005, 0xa182, 0x008c, 0x1220, 0xa182,
+	0x0085, 0x0208, 0x001a, 0x080c, 0x8663, 0x0005, 0xb2ad, 0xb2ad,
+	0xb2ad, 0xb2ad, 0xb2af, 0xb2cd, 0xb2ad, 0x080c, 0x1515, 0x00d6,
+	0x2c68, 0x080c, 0x85c7, 0x01a0, 0x6003, 0x0001, 0x6007, 0x001e,
+	0x2009, 0xbb8e, 0x210c, 0x6136, 0x2009, 0xbb8f, 0x210c, 0x613a,
+	0x600b, 0xffff, 0x6918, 0x611a, 0x601f, 0x0004, 0x080c, 0x6c8d,
+	0x2d60, 0x080c, 0x861d, 0x00de, 0x0005, 0x080c, 0x861d, 0x0005,
+	0x00e6, 0x6018, 0x2070, 0x7000, 0xd0ec, 0x00ee, 0x0005, 0x6010,
+	0xa08c, 0xf000, 0x0904, 0xb31b, 0xa080, 0x0013, 0x200c, 0xd1ec,
+	0x05d0, 0x2001, 0xb572, 0x2004, 0xd0ec, 0x05a8, 0x6003, 0x0002,
+	0x6020, 0xc0e5, 0x6022, 0xd1ac, 0x0180, 0x00f6, 0x2c78, 0x080c,
+	0x5301, 0x00fe, 0x0150, 0x2001, 0xb7b8, 0x2004, 0x603e, 0x2009,
+	0xb572, 0x210c, 0xd1f4, 0x11e8, 0x0080, 0x2009, 0xb572, 0x210c,
+	0xd1f4, 0x0128, 0x6020, 0xc0e4, 0x6022, 0xa006, 0x00a0, 0x2001,
+	0xb7b8, 0x200c, 0x8103, 0xa100, 0x603e, 0x6018, 0xa088, 0x002b,
+	0x2104, 0xa005, 0x0118, 0xa088, 0x0003, 0x0cd0, 0x2c0a, 0x600f,
+	0x0000, 0xa085, 0x0001, 0x0005, 0x0016, 0x00c6, 0x00e6, 0x6150,
+	0xa2f0, 0x002b, 0x2e04, 0x2060, 0x8cff, 0x0180, 0x84ff, 0x1118,
+	0x6050, 0xa106, 0x1138, 0x600c, 0x2072, 0x080c, 0x6aef, 0x080c,
+	0x861d, 0x0010, 0xacf0, 0x0003, 0x2e64, 0x0c70, 0x00ee, 0x00ce,
+	0x001e, 0x0005, 0x00d6, 0x6018, 0xa0e8, 0x002b, 0x2d04, 0xa005,
+	0x0140, 0xac06, 0x0120, 0x2d04, 0xa0e8, 0x0003, 0x0cb8, 0x600c,
+	0x206a, 0x00de, 0x0005, 0x0026, 0x0036, 0x0156, 0x2011, 0xb528,
+	0x2204, 0xa084, 0x00ff, 0x2019, 0xbb8e, 0x2334, 0xa636, 0x11d8,
+	0x8318, 0x2334, 0x2204, 0xa084, 0xff00, 0xa636, 0x11a0, 0x2011,
+	0xbb90, 0x6018, 0xa098, 0x000a, 0x20a9, 0x0004, 0x080c, 0x90da,
+	0x1150, 0x2011, 0xbb94, 0x6018, 0xa098, 0x0006, 0x20a9, 0x0004,
+	0x080c, 0x90da, 0x1100, 0x015e, 0x003e, 0x002e, 0x0005, 0x00e6,
+	0x2071, 0xb500, 0x080c, 0x4bc6, 0x080c, 0x2ab8, 0x00ee, 0x0005,
+	0x00e6, 0x6018, 0x2070, 0x7000, 0xd0fc, 0x0108, 0x0011, 0x00ee,
+	0x0005, 0x6850, 0xc0e5, 0x6852, 0x0005, 0x00e6, 0x00c6, 0x0076,
+	0x0066, 0x0056, 0x0046, 0x0026, 0x0016, 0x0126, 0x2091, 0x8000,
+	0x2029, 0xb7e9, 0x252c, 0x2021, 0xb7ef, 0x2424, 0x2061, 0xbd00,
+	0x2071, 0xb500, 0x7648, 0x7068, 0xa606, 0x0578, 0x671c, 0xa786,
+	0x0001, 0x0118, 0xa786, 0x0008, 0x1500, 0x2500, 0xac06, 0x01e8,
+	0x2400, 0xac06, 0x01d0, 0x080c, 0xb110, 0x01b8, 0x080c, 0xb120,
+	0x11a0, 0x6000, 0xa086, 0x0004, 0x1120, 0x0016, 0x080c, 0x194d,
+	0x001e, 0x080c, 0x9e47, 0x1110, 0x080c, 0x2cc2, 0x080c, 0x9e58,
+	0x1110, 0x080c, 0x8c19, 0x080c, 0x9e1d, 0xace0, 0x0018, 0x2001,
+	0xb517, 0x2004, 0xac02, 0x1208, 0x0858, 0x012e, 0x001e, 0x002e,
+	0x004e, 0x005e, 0x006e, 0x007e, 0x00ce, 0x00ee, 0x0005, 0x0126,
+	0x0006, 0x00e6, 0x0016, 0x2091, 0x8000, 0x2071, 0xb540, 0xd5a4,
+	0x0118, 0x7034, 0x8000, 0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000,
+	0x7032, 0xd5ac, 0x0178, 0x2500, 0xa084, 0x0007, 0xa08e, 0x0003,
+	0x0148, 0xa08e, 0x0004, 0x0130, 0xa08e, 0x0005, 0x0118, 0x2071,
+	0xb54a, 0x04c9, 0x001e, 0x00ee, 0x000e, 0x012e, 0x0005, 0x0126,
+	0x0006, 0x00e6, 0x0016, 0x2091, 0x8000, 0x2071, 0xb540, 0xd5a4,
+	0x0118, 0x7034, 0x8000, 0x7036, 0xd5b4, 0x0118, 0x7030, 0x8000,
+	0x7032, 0xd5ac, 0x0178, 0x2500, 0xa084, 0x0007, 0xa08e, 0x0003,
+	0x0148, 0xa08e, 0x0004, 0x0130, 0xa08e, 0x0005, 0x0118, 0x2071,
+	0xb54a, 0x0089, 0x001e, 0x00ee, 0x000e, 0x012e, 0x0005, 0x0126,
+	0x0006, 0x00e6, 0x2091, 0x8000, 0x2071, 0xb542, 0x0021, 0x00ee,
+	0x000e, 0x012e, 0x0005, 0x2e04, 0x8000, 0x2072, 0x1220, 0x8e70,
+	0x2e04, 0x8000, 0x2072, 0x0005, 0x00e6, 0x2071, 0xb540, 0x0c99,
+	0x00ee, 0x0005, 0x00e6, 0x2071, 0xb544, 0x0c69, 0x00ee, 0x0005,
+	0x0126, 0x0006, 0x00e6, 0x2091, 0x8000, 0x2071, 0xb540, 0x7044,
+	0x8000, 0x7046, 0x00ee, 0x000e, 0x012e, 0x0005, 0x0001, 0x0002,
+	0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100, 0x0200,
+	0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x2440
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2200tp_length01 = 0xa46f;
+#else
+unsigned short risc_code_length01 = 0xa46f;
+#endif
+
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2300.c linux-2.5/drivers/scsi/qla2xxx/ql2300.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2300.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2300.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,161 @@
+/*
+ * QLogic ISP23XX device driver for Linux 2.6.x
+ * Copyright (C) 2003 Christoph Hellwig.
+ * Copyright (C) 2003 QLogic Corporation (www.qlogic.com)
+ *
+ * Released under GPL v2.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+static char qla_driver_name[] = "qla2300";
+
+extern unsigned char  fw2300tpx_version[];
+extern unsigned char  fw2300tpx_version_str[];
+extern unsigned short fw2300tpx_addr01;
+extern unsigned short fw2300tpx_code01[];
+extern unsigned short fw2300tpx_length01;
+
+extern unsigned char  fw2322tpx_version[];
+extern unsigned char  fw2322tpx_version_str[];
+extern unsigned short fw2322tpx_addr01;
+extern unsigned short fw2322tpx_code01[];
+extern unsigned short fw2322tpx_length01;
+extern unsigned long rseqtpx_code_addr01;
+extern unsigned short rseqtpx_code01[];
+extern unsigned short rseqtpx_code_length01;
+extern unsigned long xseqtpx_code_addr01;
+extern unsigned short xseqtpx_code01[];
+extern unsigned short xseqtpx_code_length01;
+
+static struct qla_fw_info qla_fw_tbl[] = {
+	{
+		.addressing	= FW_INFO_ADDR_NORMAL,
+		.fwcode		= &fw2300tpx_code01[0],
+		.fwlen		= &fw2300tpx_length01,
+		.fwstart	= &fw2300tpx_addr01,
+	},
+#if defined(ISP2322)
+	/* End of 23xx firmware list */
+	{ FW_INFO_ADDR_NOMORE, },
+
+	/* Start of 232x firmware list */
+	{
+		.addressing	= FW_INFO_ADDR_NORMAL,
+		.fwcode		= &fw2322tpx_code01[0],
+		.fwlen		= &fw2322tpx_length01,
+		.fwstart	= &fw2322tpx_addr01,
+	},
+	{
+		.addressing	= FW_INFO_ADDR_EXTENDED,
+		.fwcode		= &rseqtpx_code01[0],
+		.fwlen		= &rseqtpx_code_length01,
+		.lfwstart	= &rseqtpx_code_addr01,
+	},
+	{
+		.addressing	= FW_INFO_ADDR_EXTENDED,
+		.fwcode		= &xseqtpx_code01[0],
+		.fwlen		= &xseqtpx_code_length01,
+		.lfwstart	= &xseqtpx_code_addr01,
+	},
+#endif
+	{ FW_INFO_ADDR_NOMORE, },
+};
+
+static struct qla_board_info qla_board_tbl[] = {
+	{
+		.drv_name	= qla_driver_name,
+
+		.isp_name	= "ISP2300",
+		.fw_info	= qla_fw_tbl,
+	},
+
+	{
+		.drv_name	= qla_driver_name,
+
+		.isp_name	= "ISP2312",
+		.fw_info	= qla_fw_tbl,
+	},
+#if defined(ISP2322)
+	{
+		.drv_name	= qla_driver_name,
+
+		.isp_name	= "ISP2322",
+		.fw_info	= &qla_fw_tbl[2],
+	},
+#endif
+};
+
+static struct pci_device_id qla2300_pci_tbl[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP2300,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= (unsigned long)&qla_board_tbl[0],
+	},
+
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP2312,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= (unsigned long)&qla_board_tbl[1],
+	},
+
+#if defined(ISP2322)
+	{
+		.vendor		= PCI_VENDOR_ID_QLOGIC,
+		.device		= PCI_DEVICE_ID_QLOGIC_ISP2322,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+		.driver_data	= (unsigned long)&qla_board_tbl[2],
+	},
+#endif
+	{0, 0},
+};
+MODULE_DEVICE_TABLE(pci, qla2300_pci_tbl);
+
+static int __devinit
+qla2300_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	return qla2x00_probe_one(pdev,
+	    (struct qla_board_info *)id->driver_data);
+}
+
+static void __devexit
+qla2300_remove_one(struct pci_dev *pdev)
+{
+	qla2x00_remove_one(pdev);
+}
+
+static struct pci_driver qla2300_pci_driver = {
+	.name		= "qla2300",
+	.id_table	= qla2300_pci_tbl,
+	.probe		= qla2300_probe_one,
+	.remove		= __devexit_p(qla2300_remove_one),
+};
+
+static int __init
+qla2300_init(void)
+{
+	return pci_module_init(&qla2300_pci_driver);
+}
+
+static void __exit
+qla2300_exit(void)
+{
+	pci_unregister_driver(&qla2300_pci_driver);
+}
+
+module_init(qla2300_init);
+module_exit(qla2300_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP23xx FC-SCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/ql2300_fw.c linux-2.5/drivers/scsi/qla2xxx/ql2300_fw.c
--- linux-2.6.1/drivers/scsi/qla2xxx/ql2300_fw.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/ql2300_fw.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,6695 @@
+/**************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ *************************************************************************/
+
+/*
+ *	Firmware Version 3.02.18 (10:33 Nov 03, 2003)
+ */
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tpx_version = 3*1024+2;
+#else
+unsigned short risc_code_version = 3*1024+2;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned char fw2300tpx_version_str[] = {3, 2,18};
+#else
+unsigned char firmware_version[] = {3, 2,18};
+#endif
+
+#ifdef UNIQUE_FW_NAME
+#define fw2300tpx_VERSION_STRING "3.02.18"
+#else
+#define FW_VERSION_STRING "3.02.18"
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tpx_addr01 = 0x0800 ;
+#else
+unsigned short risc_code_addr01 = 0x0800 ;
+#endif
+
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tpx_code01[] = { 
+#else
+unsigned short risc_code01[] = { 
+#endif
+	0x0470, 0x0000, 0x0000, 0xcf5b, 0x0000, 0x0003, 0x0002, 0x0012,
+	0x0117, 0x2043, 0x4f50, 0x5952, 0x4947, 0x4854, 0x2032, 0x3030,
+	0x3120, 0x514c, 0x4f47, 0x4943, 0x2043, 0x4f52, 0x504f, 0x5241,
+	0x5449, 0x4f4e, 0x2049, 0x5350, 0x3233, 0x3030, 0x2046, 0x6972,
+	0x6d77, 0x6172, 0x6520, 0x2056, 0x6572, 0x7369, 0x6f6e, 0x2030,
+	0x332e, 0x3032, 0x2e31, 0x3820, 0x2020, 0x2020, 0x2400, 0x20a9,
+	0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2200, 0x20a9, 0x000f,
+	0x2001, 0x0000, 0x400f, 0x2091, 0x2400, 0x20a9, 0x000f, 0x2001,
+	0x0000, 0x400f, 0x2091, 0x2600, 0x20a9, 0x000f, 0x2001, 0x0000,
+	0x400f, 0x2091, 0x2800, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f,
+	0x2091, 0x2a00, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091,
+	0x2c00, 0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2e00,
+	0x20a9, 0x000f, 0x2001, 0x0000, 0x400f, 0x2091, 0x2000, 0x2001,
+	0x0000, 0x20c1, 0x0004, 0x2001, 0x017f, 0x2003, 0x0000, 0x20c9,
+	0x1bff, 0x2059, 0x0000, 0x2b78, 0x7883, 0x0004, 0x2089, 0x29be,
+	0x2051, 0x1800, 0x2a70, 0x20e1, 0x0001, 0x20e9, 0x0001, 0x2029,
+	0x4d00, 0x2031, 0xffff, 0x2039, 0x4cd0, 0x2021, 0x0200, 0x20e9,
+	0x0001, 0x20a1, 0x0000, 0x20a9, 0x0800, 0x900e, 0x4104, 0x20e9,
+	0x0001, 0x20a1, 0x1000, 0x900e, 0x2001, 0x0cc0, 0x9084, 0x0fff,
+	0x20a8, 0x4104, 0x2001, 0x0000, 0x9086, 0x0000, 0x0120, 0x21a8,
+	0x4104, 0x8001, 0x1de0, 0x7566, 0x766a, 0x7762, 0x746e, 0x7472,
+	0x00e6, 0x2071, 0x1a8b, 0x2472, 0x00ee, 0x20a1, 0x1cd0, 0x7168,
+	0x810d, 0x810d, 0x810d, 0x810d, 0x918c, 0x000f, 0x2001, 0x0001,
+	0x9112, 0x900e, 0x21a8, 0x4104, 0x8211, 0x1de0, 0x7168, 0x3400,
+	0x8001, 0x9102, 0x0120, 0x0218, 0x20a8, 0x900e, 0x4104, 0x2009,
+	0x1800, 0x810d, 0x810d, 0x810d, 0x810d, 0x810d, 0x918c, 0x001f,
+	0x2001, 0x0001, 0x9112, 0x20e9, 0x0001, 0x20a1, 0x0800, 0x900e,
+	0x20a9, 0x0800, 0x4104, 0x8211, 0x1dd8, 0x080c, 0x0eed, 0x080c,
+	0x5a2f, 0x080c, 0x996c, 0x080c, 0x10a4, 0x080c, 0x127c, 0x080c,
+	0x196d, 0x080c, 0x0d4b, 0x080c, 0x1029, 0x080c, 0x3092, 0x080c,
+	0x6f3e, 0x080c, 0x62c8, 0x080c, 0x7b85, 0x080c, 0x217b, 0x080c,
+	0x7eaf, 0x080c, 0x757c, 0x080c, 0x1fb8, 0x080c, 0x20ec, 0x080c,
+	0x2170, 0x2091, 0x3009, 0x7883, 0x0000, 0x1004, 0x091d, 0x7880,
+	0x9086, 0x0002, 0x1190, 0x7883, 0x4000, 0x7837, 0x4000, 0x7833,
+	0x0010, 0x0e04, 0x0911, 0x2091, 0x5000, 0x2091, 0x4080, 0x2001,
+	0x0089, 0x2004, 0xd084, 0x190c, 0x1167, 0x2071, 0x1800, 0x7003,
+	0x0000, 0x2071, 0x1800, 0x7000, 0x908e, 0x0003, 0x1168, 0x080c,
+	0x4737, 0x080c, 0x30b9, 0x080c, 0x6faf, 0x080c, 0x6787, 0x080c,
+	0x7bae, 0x080c, 0x292b, 0x0c68, 0x000b, 0x0c88, 0x0940, 0x0941,
+	0x0ad4, 0x093e, 0x0b94, 0x0d4a, 0x0d4a, 0x0d4a, 0x080c, 0x0db2,
+	0x0005, 0x0126, 0x00f6, 0x2091, 0x8000, 0x7000, 0x9086, 0x0001,
+	0x1904, 0x0aa7, 0x080c, 0x0e5a, 0x080c, 0x6c53, 0x0150, 0x080c,
+	0x6c76, 0x1590, 0x2079, 0x0100, 0x7828, 0x9085, 0x1800, 0x782a,
+	0x0458, 0x080c, 0x6b8a, 0x7000, 0x9086, 0x0001, 0x1904, 0x0aa7,
+	0x7090, 0x9086, 0x0028, 0x1904, 0x0aa7, 0x080c, 0x7b7c, 0x2001,
+	0x0161, 0x2003, 0x0001, 0x2079, 0x0100, 0x7827, 0xffff, 0x7a28,
+	0x9295, 0x5e2f, 0x7a2a, 0x2011, 0x6ad9, 0x080c, 0x7c4a, 0x2011,
+	0x6acc, 0x080c, 0x7d1b, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x2011,
+	0x8030, 0x901e, 0x738e, 0x04a0, 0x080c, 0x5137, 0x2079, 0x0100,
+	0x7844, 0x9005, 0x1904, 0x0aa7, 0x2011, 0x588a, 0x080c, 0x7c4a,
+	0x2011, 0x6ad9, 0x080c, 0x7c4a, 0x2011, 0x6acc, 0x080c, 0x7d1b,
+	0x2001, 0x0265, 0x2001, 0x0205, 0x2003, 0x0000, 0x7840, 0x9084,
+	0xfffb, 0x7842, 0x2001, 0x1975, 0x2004, 0x9005, 0x1140, 0x00c6,
+	0x2061, 0x0100, 0x080c, 0x59d7, 0x00ce, 0x0804, 0x0aa7, 0x780f,
+	0x006b, 0x7a28, 0x9295, 0x5e2f, 0x7a2a, 0x2011, 0x8010, 0x73d0,
+	0x2001, 0x1976, 0x2003, 0x0001, 0x080c, 0x27f1, 0x080c, 0x4672,
+	0x7240, 0xc284, 0x7242, 0x2001, 0x180c, 0x200c, 0xc1ac, 0xc1cc,
+	0x2102, 0x080c, 0x91bb, 0x2011, 0x0004, 0x080c, 0xb60b, 0x080c,
+	0x61a1, 0x080c, 0x6c53, 0x1120, 0x080c, 0x2835, 0x02e0, 0x0400,
+	0x080c, 0x59de, 0x0140, 0x708f, 0x0001, 0x70cb, 0x0000, 0x080c,
+	0x5304, 0x0804, 0x0aa7, 0x080c, 0x5113, 0xd094, 0x0188, 0x2011,
+	0x180c, 0x2204, 0xc0cd, 0x2012, 0x080c, 0x5117, 0xd0d4, 0x1118,
+	0x080c, 0x2835, 0x1270, 0x2011, 0x180c, 0x2204, 0xc0bc, 0x00a8,
+	0x080c, 0x5117, 0xd0d4, 0x1db8, 0x2011, 0x180c, 0x2204, 0xc0bd,
+	0x0060, 0x2011, 0x180c, 0x2204, 0xc0bd, 0x2012, 0x080c, 0x629c,
+	0x1128, 0xd0a4, 0x0118, 0x2204, 0xc0fd, 0x2012, 0x080c, 0x6262,
+	0x0120, 0x7a0c, 0xc2b4, 0x7a0e, 0x00a8, 0x7077, 0x0000, 0x080c,
+	0x6c53, 0x1130, 0x70a8, 0x9005, 0x1168, 0x080c, 0xba40, 0x0050,
+	0x080c, 0xba40, 0x70d4, 0xd09c, 0x1128, 0x70a8, 0x9005, 0x0110,
+	0x080c, 0x59b4, 0x70df, 0x0000, 0x70db, 0x0000, 0x709f, 0x0000,
+	0x080c, 0x283d, 0x0228, 0x2011, 0x0101, 0x2204, 0xc0c4, 0x2012,
+	0x72d4, 0x080c, 0x6c53, 0x1178, 0x9016, 0x0016, 0x080c, 0x25ee,
+	0x2019, 0x193e, 0x211a, 0x001e, 0x7057, 0xffff, 0x705b, 0x00ef,
+	0x707b, 0x0000, 0x0020, 0x2019, 0x193e, 0x201b, 0x0000, 0x2079,
+	0x1853, 0x7804, 0xd0ac, 0x0108, 0xc295, 0x72d6, 0x080c, 0x6c53,
+	0x0118, 0x9296, 0x0004, 0x0548, 0x2011, 0x0001, 0x080c, 0xb60b,
+	0x70a3, 0x0000, 0x70a7, 0xffff, 0x7003, 0x0002, 0x2079, 0x0100,
+	0x7827, 0x0003, 0x7828, 0x9085, 0x0003, 0x782a, 0x00fe, 0x080c,
+	0x2c2b, 0x2011, 0x0005, 0x080c, 0x92ec, 0x080c, 0x8582, 0x080c,
+	0x6c53, 0x0148, 0x00c6, 0x2061, 0x0100, 0x0016, 0x080c, 0x25ee,
+	0x61e2, 0x001e, 0x00ce, 0x012e, 0x0420, 0x70a3, 0x0000, 0x70a7,
+	0xffff, 0x7003, 0x0002, 0x00f6, 0x2079, 0x0100, 0x7827, 0x0003,
+	0x7828, 0x9085, 0x0003, 0x782a, 0x00fe, 0x2011, 0x0005, 0x080c,
+	0x92ec, 0x080c, 0x8582, 0x080c, 0x6c53, 0x0148, 0x00c6, 0x2061,
+	0x0100, 0x0016, 0x080c, 0x25ee, 0x61e2, 0x001e, 0x00ce, 0x00fe,
+	0x012e, 0x0005, 0x00c6, 0x00b6, 0x080c, 0x6c53, 0x1118, 0x20a9,
+	0x0800, 0x0010, 0x20a9, 0x0782, 0x080c, 0x6c53, 0x1110, 0x900e,
+	0x0010, 0x2009, 0x007e, 0x86ff, 0x0138, 0x9180, 0x1000, 0x2004,
+	0x905d, 0x0110, 0xb800, 0xd0bc, 0x090c, 0x2f28, 0x8108, 0x1f04,
+	0x0abb, 0x7077, 0x0000, 0x7078, 0x9084, 0x00ff, 0x707a, 0x70ab,
+	0x0000, 0x00be, 0x00ce, 0x0005, 0x00b6, 0x0126, 0x2091, 0x8000,
+	0x7000, 0x9086, 0x0002, 0x1904, 0x0b91, 0x70a4, 0x9086, 0xffff,
+	0x0130, 0x080c, 0x2c2b, 0x080c, 0x8582, 0x0804, 0x0b91, 0x70d4,
+	0xd0ac, 0x1110, 0xd09c, 0x0558, 0xd084, 0x0548, 0x0006, 0x2001,
+	0x0103, 0x2003, 0x002b, 0x000e, 0xd08c, 0x0508, 0x080c, 0x2f8b,
+	0x11d0, 0x70d8, 0x9086, 0xffff, 0x01b0, 0x080c, 0x2d9c, 0x080c,
+	0x8582, 0x70d4, 0xd094, 0x1904, 0x0b91, 0x2011, 0x0001, 0x080c,
+	0xbcec, 0x0110, 0x2011, 0x0003, 0x901e, 0x080c, 0x2dd6, 0x080c,
+	0x8582, 0x0804, 0x0b91, 0x70dc, 0x9005, 0x1904, 0x0b91, 0x70a0,
+	0x9005, 0x1904, 0x0b91, 0x70d4, 0xd0a4, 0x0118, 0xd0b4, 0x0904,
+	0x0b91, 0x080c, 0x6262, 0x1904, 0x0b91, 0x080c, 0x62b5, 0x1904,
+	0x0b91, 0x080c, 0x629c, 0x01c0, 0x0156, 0x00c6, 0x20a9, 0x007f,
+	0x900e, 0x0016, 0x080c, 0x5f7e, 0x1118, 0xb800, 0xd0ec, 0x1138,
+	0x001e, 0x8108, 0x1f04, 0x0b31, 0x00ce, 0x015e, 0x0028, 0x001e,
+	0x00ce, 0x015e, 0x0804, 0x0b91, 0x0006, 0x2001, 0x0103, 0x2003,
+	0x006b, 0x000e, 0x2011, 0x1982, 0x080c, 0x0f5d, 0x2011, 0x199c,
+	0x080c, 0x0f5d, 0x7030, 0xc08c, 0x7032, 0x7003, 0x0003, 0x70a7,
+	0xffff, 0x080c, 0x0e3c, 0x9006, 0x080c, 0x247f, 0x080c, 0x2f8b,
+	0x0118, 0x080c, 0x480f, 0x0050, 0x0036, 0x0046, 0x2019, 0xffff,
+	0x2021, 0x0006, 0x080c, 0x4829, 0x004e, 0x003e, 0x00f6, 0x2079,
+	0x0100, 0x080c, 0x6c76, 0x0150, 0x080c, 0x6c53, 0x7828, 0x0118,
+	0x9084, 0xe1ff, 0x0010, 0x9084, 0xffdf, 0x782a, 0x00fe, 0x2001,
+	0x19b7, 0x2004, 0x9086, 0x0005, 0x1120, 0x2011, 0x0000, 0x080c,
+	0x92ec, 0x2011, 0x0000, 0x080c, 0x92f6, 0x080c, 0x8582, 0x080c,
+	0x865d, 0x012e, 0x00be, 0x0005, 0x0016, 0x0046, 0x00f6, 0x0126,
+	0x2091, 0x8000, 0x2079, 0x0100, 0x7904, 0x918c, 0xfffd, 0x7906,
+	0x2009, 0x00f7, 0x080c, 0x599d, 0x7940, 0x918c, 0x0010, 0x7942,
+	0x7924, 0xd1b4, 0x0110, 0x7827, 0x0040, 0xd19c, 0x0110, 0x7827,
+	0x0008, 0x0006, 0x0036, 0x0156, 0x7954, 0xd1ac, 0x1904, 0x0c21,
+	0x2001, 0x1976, 0x2004, 0x9005, 0x1518, 0x080c, 0x28b8, 0x1148,
+	0x2001, 0x0001, 0x080c, 0x2820, 0x2001, 0x0001, 0x080c, 0x2803,
+	0x00b8, 0x080c, 0x28c0, 0x1138, 0x9006, 0x080c, 0x2820, 0x9006,
+	0x080c, 0x2803, 0x0068, 0x080c, 0x28c8, 0x1d50, 0x2001, 0x1967,
+	0x2004, 0xd0fc, 0x0108, 0x0020, 0x080c, 0x261a, 0x0804, 0x0d01,
+	0x080c, 0x6c64, 0x0148, 0x080c, 0x6c76, 0x1118, 0x080c, 0x6f39,
+	0x0050, 0x080c, 0x6c5b, 0x0dd0, 0x080c, 0x6f34, 0x080c, 0x6f2a,
+	0x080c, 0x6b8a, 0x0058, 0x080c, 0x6c53, 0x0140, 0x2009, 0x00f8,
+	0x080c, 0x599d, 0x7843, 0x0090, 0x7843, 0x0010, 0x20a9, 0x09c4,
+	0x7820, 0xd09c, 0x1138, 0x080c, 0x6c53, 0x0138, 0x7824, 0xd0ac,
+	0x1904, 0x0d06, 0x1f04, 0x0c00, 0x0070, 0x7824, 0x080c, 0x6c6d,
+	0x0118, 0xd0ac, 0x1904, 0x0d06, 0x9084, 0x1800, 0x0d98, 0x7003,
+	0x0001, 0x0804, 0x0d06, 0x2001, 0x0001, 0x080c, 0x247f, 0x0804,
+	0x0d19, 0x2001, 0x1976, 0x2004, 0x9005, 0x1518, 0x080c, 0x28b8,
+	0x1148, 0x2001, 0x0001, 0x080c, 0x2820, 0x2001, 0x0001, 0x080c,
+	0x2803, 0x00b8, 0x080c, 0x28c0, 0x1138, 0x9006, 0x080c, 0x2820,
+	0x9006, 0x080c, 0x2803, 0x0068, 0x080c, 0x28c8, 0x1d50, 0x2001,
+	0x1967, 0x2004, 0xd0fc, 0x0108, 0x0020, 0x080c, 0x261a, 0x0804,
+	0x0d01, 0x7850, 0x9085, 0x0040, 0x7852, 0x7938, 0x7850, 0x9084,
+	0xfbcf, 0x7852, 0x080c, 0x28d0, 0x9085, 0x2000, 0x7852, 0x793a,
+	0x20a9, 0x0046, 0x1d04, 0x0c5a, 0x080c, 0x7cfb, 0x1f04, 0x0c5a,
+	0x7850, 0x9085, 0x0400, 0x9084, 0xdfbf, 0x7852, 0x793a, 0x080c,
+	0x6c64, 0x0148, 0x080c, 0x6c76, 0x1118, 0x080c, 0x6f39, 0x0050,
+	0x080c, 0x6c5b, 0x0dd0, 0x080c, 0x6f34, 0x080c, 0x6f2a, 0x080c,
+	0x6b8a, 0x0020, 0x2009, 0x00f8, 0x080c, 0x599d, 0x20a9, 0x0028,
+	0xa001, 0x1f04, 0x0c80, 0x7850, 0x9085, 0x1400, 0x7852, 0x080c,
+	0x6c53, 0x0120, 0x7843, 0x0090, 0x7843, 0x0010, 0x2021, 0xe678,
+	0x2019, 0xea60, 0x0d0c, 0x7cfb, 0x7820, 0xd09c, 0x1588, 0x080c,
+	0x6c53, 0x0904, 0x0ce6, 0x7824, 0xd0ac, 0x1904, 0x0d06, 0x080c,
+	0x6c76, 0x1530, 0x0046, 0x2021, 0x0320, 0x8421, 0x1df0, 0x004e,
+	0x7827, 0x1800, 0x080c, 0x28d0, 0x7824, 0x9084, 0x1800, 0x1168,
+	0x9484, 0x0fff, 0x1140, 0x2001, 0x180f, 0x2004, 0x9084, 0x9000,
+	0x0110, 0x080c, 0x0d27, 0x8421, 0x1158, 0x1d04, 0x0cc1, 0x080c,
+	0x7cfb, 0x080c, 0x6f34, 0x080c, 0x6f2a, 0x7003, 0x0001, 0x04f0,
+	0x8319, 0x1940, 0x1d04, 0x0cce, 0x080c, 0x7cfb, 0x2009, 0x196a,
+	0x2104, 0x9005, 0x0118, 0x8001, 0x200a, 0x1178, 0x200b, 0x000a,
+	0x7827, 0x0048, 0x20a9, 0x0002, 0x080c, 0x28b1, 0x7924, 0x080c,
+	0x28d0, 0xd19c, 0x0110, 0x080c, 0x27f1, 0x00d8, 0x080c, 0x6c64,
+	0x1140, 0x94a2, 0x03e8, 0x1128, 0x080c, 0x6c2d, 0x7003, 0x0001,
+	0x00a8, 0x7827, 0x1800, 0x080c, 0x28d0, 0x7824, 0x080c, 0x6c6d,
+	0x0110, 0xd0ac, 0x1158, 0x9084, 0x1800, 0x0950, 0x7003, 0x0001,
+	0x0028, 0x2001, 0x0001, 0x080c, 0x247f, 0x0078, 0x2009, 0x180c,
+	0x210c, 0xd19c, 0x1120, 0x7904, 0x918d, 0x0002, 0x7906, 0x7827,
+	0x0048, 0x7828, 0x9085, 0x0028, 0x782a, 0x7850, 0x9085, 0x0400,
+	0x7852, 0x2001, 0x1976, 0x2003, 0x0000, 0x9006, 0x78f2, 0x015e,
+	0x003e, 0x000e, 0x012e, 0x00fe, 0x004e, 0x001e, 0x0005, 0x0006,
+	0x0016, 0x0036, 0x0046, 0x00b6, 0x00c6, 0x00d6, 0x00e6, 0x00f6,
+	0x0156, 0x0069, 0x0d0c, 0x7cfb, 0x015e, 0x00fe, 0x00ee, 0x00de,
+	0x00ce, 0x00be, 0x004e, 0x003e, 0x001e, 0x000e, 0x0005, 0x00e6,
+	0x2071, 0x1894, 0x7004, 0x9086, 0x0001, 0x1110, 0x080c, 0x30b9,
+	0x00ee, 0x0005, 0x0005, 0x2a70, 0x2061, 0x197a, 0x2063, 0x0003,
+	0x6007, 0x0002, 0x600b, 0x0012, 0x600f, 0x0117, 0x2001, 0x194d,
+	0x900e, 0x2102, 0x718e, 0x2001, 0x0100, 0x2004, 0x9082, 0x0002,
+	0x0218, 0x7057, 0xffff, 0x0008, 0x7156, 0x705f, 0xffff, 0x7176,
+	0x717a, 0x080c, 0xba40, 0x70e3, 0x00c0, 0x2061, 0x193d, 0x6003,
+	0x0909, 0x6106, 0x600b, 0x8800, 0x600f, 0x0200, 0x6013, 0x00ff,
+	0x6017, 0x000f, 0x611a, 0x601f, 0x07d0, 0x2061, 0x1945, 0x6003,
+	0x8000, 0x6106, 0x610a, 0x600f, 0x0200, 0x6013, 0x00ff, 0x6116,
+	0x601b, 0x0001, 0x611e, 0x2061, 0x1958, 0x6003, 0x514c, 0x6007,
+	0x4f47, 0x600b, 0x4943, 0x600f, 0x2020, 0x2001, 0x182a, 0x2102,
+	0x0005, 0x9016, 0x080c, 0x5f7e, 0x1178, 0xb804, 0x90c4, 0x00ff,
+	0x98c6, 0x0006, 0x0128, 0x90c4, 0xff00, 0x98c6, 0x0600, 0x1120,
+	0x9186, 0x0080, 0x0108, 0x8210, 0x8108, 0x9186, 0x0800, 0x1d50,
+	0x2208, 0x0005, 0x2091, 0x8000, 0x0e04, 0x0db4, 0x0006, 0x0016,
+	0x2001, 0x8002, 0x0006, 0x2079, 0x0000, 0x000e, 0x7882, 0x7836,
+	0x001e, 0x798e, 0x000e, 0x788a, 0x000e, 0x7886, 0x3900, 0x789a,
+	0x7833, 0x0012, 0x2091, 0x5000, 0x0156, 0x00d6, 0x0036, 0x0026,
+	0x2079, 0x0300, 0x2069, 0x1a66, 0x7a18, 0x226a, 0x8d68, 0x7a1c,
+	0x226a, 0x782c, 0x2019, 0x1a73, 0x201a, 0x2019, 0x1a76, 0x9016,
+	0x7808, 0xd09c, 0x0168, 0x7820, 0x201a, 0x8210, 0x8318, 0x9386,
+	0x1a8b, 0x0108, 0x0ca8, 0x7808, 0xd09c, 0x0110, 0x2011, 0xdead,
+	0x2019, 0x1a74, 0x782c, 0x201a, 0x8318, 0x221a, 0x7803, 0x0000,
+	0x2069, 0x1a46, 0x901e, 0x20a9, 0x0020, 0x7b26, 0x7a28, 0x226a,
+	0x8d68, 0x8318, 0x1f04, 0x0dfd, 0x002e, 0x003e, 0x00de, 0x015e,
+	0x2079, 0x1800, 0x7803, 0x0005, 0x2091, 0x4080, 0x2001, 0x0089,
+	0x2004, 0xd084, 0x0180, 0x2001, 0x19e8, 0x2004, 0x9005, 0x0128,
+	0x2001, 0x008b, 0x2004, 0xd0fc, 0x0dd8, 0x2001, 0x008a, 0x2003,
+	0x0002, 0x2003, 0x1001, 0x080c, 0x5122, 0x1108, 0x0011, 0x0cd8,
+	0x0005, 0x0026, 0x0126, 0x2011, 0x0080, 0x080c, 0x0eb4, 0x20a9,
+	0x0900, 0x080c, 0x0ed5, 0x2011, 0x0040, 0x080c, 0x0eb4, 0x20a9,
+	0x0900, 0x080c, 0x0ed5, 0x0c78, 0x0026, 0x080c, 0x0ec1, 0x1118,
+	0x2011, 0x0040, 0x0098, 0x2011, 0x010e, 0x2214, 0x9294, 0x0007,
+	0x9296, 0x0007, 0x0118, 0x2011, 0xa880, 0x0010, 0x2011, 0x6840,
+	0xd0e4, 0x70e7, 0x0000, 0x1128, 0x70e7, 0x0fa0, 0x080c, 0x0ec6,
+	0x002e, 0x0005, 0x0026, 0x080c, 0x0ec1, 0x0128, 0xd0a4, 0x1138,
+	0x2011, 0xcdd5, 0x0010, 0x2011, 0x0080, 0x080c, 0x0ec6, 0x002e,
+	0x0005, 0x0026, 0x70e7, 0x0000, 0x080c, 0x0ec1, 0x1148, 0x080c,
+	0x28c8, 0x1118, 0x2011, 0x8484, 0x0058, 0x2011, 0x8282, 0x0040,
+	0x080c, 0x28c8, 0x1118, 0x2011, 0xcdc5, 0x0010, 0x2011, 0xcac2,
+	0x080c, 0x0ec6, 0x002e, 0x0005, 0x00e6, 0x0006, 0x2071, 0x1800,
+	0xd0b4, 0x70e0, 0x1110, 0xc0e4, 0x0048, 0x0006, 0x3b00, 0x9084,
+	0xff3f, 0x20d8, 0x000e, 0x70e7, 0x0000, 0xc0e5, 0x0079, 0x000e,
+	0x00ee, 0x0005, 0x00e6, 0x2071, 0x1800, 0xd0e4, 0x70e0, 0x1110,
+	0xc0dc, 0x0008, 0xc0dd, 0x0011, 0x00ee, 0x0005, 0x70e2, 0x7000,
+	0x9084, 0x0007, 0x000b, 0x0005, 0x0e83, 0x0e5a, 0x0e5a, 0x0e3c,
+	0x0e69, 0x0e5a, 0x0e5a, 0x0e69, 0x0016, 0x3b08, 0x3a00, 0x9104,
+	0x918d, 0x00c0, 0x21d8, 0x9084, 0xff3f, 0x9205, 0x20d0, 0x001e,
+	0x0005, 0x2001, 0x1838, 0x2004, 0xd0dc, 0x0005, 0x9e86, 0x1800,
+	0x190c, 0x0db2, 0x70e0, 0xd0e4, 0x0108, 0xc2e5, 0x72e2, 0xd0e4,
+	0x1118, 0x9294, 0x00c0, 0x0c01, 0x0005, 0x1d04, 0x0ed5, 0x2091,
+	0x6000, 0x1f04, 0x0ed5, 0x0005, 0x890e, 0x810e, 0x810f, 0x9194,
+	0x003f, 0x918c, 0xffc0, 0x0005, 0x0006, 0x2200, 0x914d, 0x894f,
+	0x894d, 0x894d, 0x000e, 0x000e, 0x0005, 0x01d6, 0x0146, 0x0036,
+	0x0096, 0x2061, 0x1883, 0x600b, 0x0000, 0x600f, 0x0000, 0x6003,
+	0x0000, 0x6007, 0x0000, 0x2009, 0xffc0, 0x2105, 0x0006, 0x2001,
+	0xaaaa, 0x200f, 0x2019, 0x5555, 0x9016, 0x2049, 0x0bff, 0xab02,
+	0xa001, 0xa001, 0xa800, 0x9306, 0x1138, 0x2105, 0x9306, 0x0120,
+	0x8210, 0x99c8, 0x0400, 0x0c98, 0x000e, 0x200f, 0x2001, 0x1893,
+	0x928a, 0x000e, 0x1638, 0x928a, 0x0006, 0x2011, 0x0006, 0x1210,
+	0x2011, 0x0000, 0x2202, 0x9006, 0x2008, 0x82ff, 0x01b0, 0x8200,
+	0x600a, 0x600f, 0xffff, 0x6003, 0x0002, 0x6007, 0x0000, 0x0026,
+	0x2019, 0x0010, 0x9280, 0x0001, 0x20e8, 0x21a0, 0x21a8, 0x4104,
+	0x8319, 0x1de0, 0x8211, 0x1da0, 0x002e, 0x009e, 0x003e, 0x014e,
+	0x01de, 0x0005, 0x2011, 0x000e, 0x08e8, 0x0016, 0x0026, 0x0096,
+	0x3348, 0x080c, 0x0edc, 0x2100, 0x9300, 0x2098, 0x22e0, 0x009e,
+	0x002e, 0x001e, 0x0036, 0x3518, 0x20a9, 0x0001, 0x4002, 0x8007,
+	0x4004, 0x8319, 0x1dd8, 0x003e, 0x0005, 0x20e9, 0x0001, 0x71b0,
+	0x81ff, 0x11c0, 0x9006, 0x2009, 0x0200, 0x20a9, 0x0002, 0x9298,
+	0x0018, 0x23a0, 0x4001, 0x2009, 0x0700, 0x20a9, 0x0002, 0x9298,
+	0x0008, 0x23a0, 0x4001, 0x7074, 0x8007, 0x7178, 0x810f, 0x20a9,
+	0x0002, 0x4001, 0x9298, 0x000c, 0x23a0, 0x900e, 0x080c, 0x0d99,
+	0x2001, 0x0000, 0x810f, 0x20a9, 0x0002, 0x4001, 0x0005, 0x89ff,
+	0x0140, 0xa804, 0xa807, 0x0000, 0x0006, 0x080c, 0x1007, 0x009e,
+	0x0cb0, 0x0005, 0x00e6, 0x2071, 0x1800, 0x080c, 0x1080, 0x090c,
+	0x0db2, 0x00ee, 0x0005, 0x0086, 0x00e6, 0x0006, 0x0026, 0x0036,
+	0x0126, 0x2091, 0x8000, 0x00c9, 0x2071, 0x1800, 0x73b8, 0x702c,
+	0x9016, 0x9045, 0x0158, 0x8210, 0x9906, 0x090c, 0x0db2, 0x2300,
+	0x9202, 0x0120, 0x1a0c, 0x0db2, 0xa000, 0x0c98, 0x012e, 0x003e,
+	0x002e, 0x000e, 0x00ee, 0x008e, 0x0005, 0x0086, 0x00e6, 0x0006,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x1906, 0x7010, 0x9005, 0x0140,
+	0x7018, 0x9045, 0x0128, 0x9906, 0x090c, 0x0db2, 0xa000, 0x0cc8,
+	0x012e, 0x000e, 0x00ee, 0x008e, 0x0005, 0x00e6, 0x2071, 0x1800,
+	0x0126, 0x2091, 0x8000, 0x70b8, 0x8001, 0x0270, 0x70ba, 0x702c,
+	0x2048, 0x9085, 0x0001, 0xa800, 0x702e, 0xa803, 0x0000, 0xa807,
+	0x0000, 0x012e, 0x00ee, 0x0005, 0x904e, 0x0cd8, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x1800, 0x70b8, 0x90ca, 0x0040, 0x0268,
+	0x8001, 0x70ba, 0x702c, 0x2048, 0xa800, 0x702e, 0xa803, 0x0000,
+	0xa807, 0x0000, 0x012e, 0x00ee, 0x0005, 0x904e, 0x0cd8, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x0016, 0x890e, 0x810e, 0x810f, 0x9184,
+	0x003f, 0xa862, 0x9184, 0xffc0, 0xa85e, 0x001e, 0x0020, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x1800, 0x702c, 0xa802, 0x2900,
+	0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c, 0x7b7c, 0x012e, 0x00ee,
+	0x0005, 0x2071, 0x1800, 0x9026, 0x2009, 0x0000, 0x2049, 0x0400,
+	0x2900, 0x702e, 0x8940, 0x2800, 0xa802, 0xa95e, 0xa863, 0x0001,
+	0x8420, 0x9886, 0x0440, 0x0120, 0x2848, 0x9188, 0x0040, 0x0c90,
+	0x2071, 0x1883, 0x7000, 0x9005, 0x11a0, 0x2001, 0x0534, 0xa802,
+	0x2048, 0x2009, 0x4d00, 0x8940, 0x2800, 0xa802, 0xa95e, 0xa863,
+	0x0001, 0x8420, 0x9886, 0x0800, 0x0120, 0x2848, 0x9188, 0x0040,
+	0x0c90, 0x2071, 0x1883, 0x7104, 0x7200, 0x82ff, 0x01d0, 0x7308,
+	0x8318, 0x831f, 0x831b, 0x831b, 0x7312, 0x8319, 0x2001, 0x0800,
+	0xa802, 0x2048, 0x8900, 0xa802, 0x2040, 0xa95e, 0xaa62, 0x8420,
+	0x2300, 0x9906, 0x0130, 0x2848, 0x9188, 0x0040, 0x9291, 0x0000,
+	0x0c88, 0xa803, 0x0000, 0x2071, 0x1800, 0x74b6, 0x74ba, 0x0005,
+	0x00e6, 0x0016, 0x9984, 0xfc00, 0x01e8, 0x908c, 0xf800, 0x1168,
+	0x9982, 0x0400, 0x02b8, 0x9982, 0x0440, 0x0278, 0x9982, 0x0534,
+	0x0288, 0x9982, 0x0800, 0x1270, 0x0040, 0x9982, 0x0800, 0x0250,
+	0x2071, 0x1883, 0x7010, 0x9902, 0x1228, 0x9085, 0x0001, 0x001e,
+	0x00ee, 0x0005, 0x9006, 0x0cd8, 0x00e6, 0x2071, 0x19e7, 0x7007,
+	0x0000, 0x9006, 0x701e, 0x7022, 0x7002, 0x2071, 0x0000, 0x7010,
+	0x9085, 0x8004, 0x7012, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x00e6, 0xa06f, 0x0000, 0x2071, 0x19e7, 0x701c, 0x9088, 0x19f1,
+	0x280a, 0x8000, 0x9084, 0x003f, 0x701e, 0x7120, 0x9106, 0x090c,
+	0x0db2, 0x7004, 0x9005, 0x1128, 0x00f6, 0x2079, 0x0080, 0x00a9,
+	0x00fe, 0x00ee, 0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0x00e6,
+	0x2071, 0x19e7, 0x7004, 0x9005, 0x1128, 0x00f6, 0x2079, 0x0080,
+	0x0021, 0x00fe, 0x00ee, 0x012e, 0x0005, 0x7004, 0x9086, 0x0000,
+	0x1110, 0x7007, 0x0006, 0x7000, 0x0002, 0x10f7, 0x10f5, 0x10f5,
+	0x10f5, 0x126b, 0x126b, 0x126b, 0x126b, 0x080c, 0x0db2, 0x701c,
+	0x7120, 0x9106, 0x1148, 0x792c, 0x9184, 0x0001, 0x1120, 0xd1fc,
+	0x1110, 0x7007, 0x0000, 0x0005, 0x0096, 0x9180, 0x19f1, 0x2004,
+	0x700a, 0x2048, 0x8108, 0x918c, 0x003f, 0x7122, 0x782b, 0x0026,
+	0xa88c, 0x7802, 0xa890, 0x7806, 0xa894, 0x780a, 0xa898, 0x780e,
+	0xa878, 0x700e, 0xa870, 0x7016, 0xa874, 0x701a, 0xa868, 0x009e,
+	0xd084, 0x0120, 0x7007, 0x0001, 0x0029, 0x0005, 0x7007, 0x0002,
+	0x00b1, 0x0005, 0x0016, 0x0026, 0x710c, 0x2011, 0x0040, 0x9182,
+	0x0040, 0x1210, 0x2110, 0x9006, 0x700e, 0x7212, 0x8203, 0x7812,
+	0x782b, 0x0020, 0x782b, 0x0041, 0x002e, 0x001e, 0x0005, 0x0016,
+	0x0026, 0x0136, 0x0146, 0x0156, 0x7014, 0x20e0, 0x7018, 0x2098,
+	0x20e9, 0x0000, 0x20a1, 0x0088, 0x782b, 0x0026, 0x710c, 0x2011,
+	0x0040, 0x9182, 0x0040, 0x1210, 0x2110, 0x9006, 0x700e, 0x22a8,
+	0x4006, 0x8203, 0x7812, 0x782b, 0x0020, 0x3300, 0x701a, 0x782b,
+	0x0001, 0x015e, 0x014e, 0x013e, 0x002e, 0x001e, 0x0005, 0x2009,
+	0x19e7, 0x2104, 0xc095, 0x200a, 0x080c, 0x10d4, 0x0005, 0x0016,
+	0x00e6, 0x2071, 0x19e7, 0x00f6, 0x2079, 0x0080, 0x792c, 0x782b,
+	0x0002, 0xd1fc, 0x0120, 0x918c, 0x0700, 0x7004, 0x0023, 0x00fe,
+	0x00ee, 0x001e, 0x0005, 0x10e5, 0x118a, 0x11be, 0x0db2, 0x0db2,
+	0x1277, 0x0db2, 0x918c, 0x0700, 0x1550, 0x0136, 0x0146, 0x0156,
+	0x7014, 0x20e8, 0x7018, 0x20a0, 0x20e1, 0x0000, 0x2099, 0x0088,
+	0x782b, 0x0040, 0x7010, 0x20a8, 0x4005, 0x3400, 0x701a, 0x015e,
+	0x014e, 0x013e, 0x700c, 0x9005, 0x0578, 0x7800, 0x7802, 0x7804,
+	0x7806, 0x080c, 0x112a, 0x0005, 0x7008, 0x0096, 0x2048, 0xa86f,
+	0x0100, 0x009e, 0x7007, 0x0000, 0x080c, 0x10e5, 0x0005, 0x7008,
+	0x0096, 0x2048, 0xa86f, 0x0200, 0x009e, 0x0ca0, 0x918c, 0x0700,
+	0x1150, 0x700c, 0x9005, 0x0180, 0x7800, 0x7802, 0x7804, 0x7806,
+	0x080c, 0x113f, 0x0005, 0x7008, 0x0096, 0x2048, 0xa86f, 0x0200,
+	0x009e, 0x7007, 0x0000, 0x0080, 0x0096, 0x7008, 0x2048, 0x7800,
+	0xa88e, 0x7804, 0xa892, 0x7808, 0xa896, 0x780c, 0xa89a, 0xa86f,
+	0x0100, 0x009e, 0x7007, 0x0000, 0x0096, 0x00d6, 0x7008, 0x2048,
+	0x2001, 0x18af, 0x2004, 0x9906, 0x1128, 0xa89c, 0x080f, 0x00de,
+	0x009e, 0x00a0, 0x00de, 0x009e, 0x0096, 0x00d6, 0x7008, 0x2048,
+	0x0081, 0x0150, 0xa89c, 0x0086, 0x2940, 0x080f, 0x008e, 0x00de,
+	0x009e, 0x080c, 0x10d4, 0x0005, 0x00de, 0x009e, 0x080c, 0x10d4,
+	0x0005, 0xa8a8, 0xd08c, 0x0005, 0x0096, 0xa0a0, 0x904d, 0x090c,
+	0x0db2, 0xa06c, 0x908e, 0x0100, 0x0130, 0xa87b, 0x0030, 0xa883,
+	0x0000, 0xa897, 0x4002, 0x080c, 0x6529, 0xa09f, 0x0000, 0xa0a3,
+	0x0000, 0x2848, 0x080c, 0x1007, 0x009e, 0x0005, 0x00a6, 0xa0a0,
+	0x904d, 0x090c, 0x0db2, 0xa06c, 0x908e, 0x0100, 0x0128, 0xa87b,
+	0x0001, 0xa883, 0x0000, 0x00c0, 0xa80c, 0x2050, 0xb004, 0x9005,
+	0x0198, 0xa80e, 0x2050, 0x8006, 0x8006, 0x8007, 0x908c, 0x003f,
+	0x9084, 0xffc0, 0x9080, 0x0002, 0xa076, 0xa172, 0xb000, 0xa07a,
+	0x2810, 0x080c, 0x10b5, 0x00e8, 0xa97c, 0xa894, 0x0016, 0x0006,
+	0x080c, 0x6529, 0x000e, 0x001e, 0xd1fc, 0x1138, 0xd1f4, 0x0128,
+	0x00c6, 0x2060, 0x080c, 0x99d6, 0x00ce, 0x7008, 0x2048, 0xa89f,
+	0x0000, 0xa8a3, 0x0000, 0x080c, 0x1007, 0x7007, 0x0000, 0x080c,
+	0x10d4, 0x00ae, 0x0005, 0x0126, 0x2091, 0x8000, 0x782b, 0x1001,
+	0x7007, 0x0005, 0x7000, 0xc094, 0x7002, 0x012e, 0x0005, 0x7007,
+	0x0000, 0x080c, 0x10e5, 0x0005, 0x0126, 0x2091, 0x2200, 0x2079,
+	0x0300, 0x2071, 0x1a31, 0x7003, 0x0000, 0x78bf, 0x00f6, 0x00c1,
+	0x7803, 0x0003, 0x780f, 0x0000, 0x20a9, 0x01ed, 0x2061, 0xd372,
+	0x2c0d, 0x7912, 0xe104, 0x9ce0, 0x0002, 0x7916, 0x1f04, 0x1290,
+	0x7807, 0x0001, 0x7803, 0x0000, 0x7803, 0x0001, 0x012e, 0x0005,
+	0x00c6, 0x7803, 0x0000, 0x7808, 0xd09c, 0x0110, 0x7820, 0x0cd8,
+	0x2001, 0x1a32, 0x2003, 0x0000, 0x78ab, 0x0004, 0x78ac, 0xd0ac,
+	0x1de8, 0x78ab, 0x0002, 0x7807, 0x0001, 0x7827, 0x0030, 0x782b,
+	0x0400, 0x7827, 0x0031, 0x782b, 0x1a46, 0x781f, 0xff00, 0x781b,
+	0xff00, 0x2001, 0x0200, 0x2004, 0xd0dc, 0x0110, 0x781f, 0x0303,
+	0x2061, 0x1a46, 0x602f, 0x1cd0, 0x2001, 0x1818, 0x2004, 0x9082,
+	0x1cd0, 0x6032, 0x603b, 0x1da2, 0x00ce, 0x0005, 0x0126, 0x2091,
+	0x2200, 0x7808, 0xd09c, 0x0158, 0x7820, 0x908c, 0xf000, 0x1588,
+	0x908a, 0x0021, 0x1a0c, 0x0db2, 0x0043, 0x012e, 0x0005, 0x9084,
+	0x0070, 0x190c, 0x0db2, 0x012e, 0x0005, 0x130f, 0x130f, 0x1318,
+	0x131d, 0x1321, 0x1326, 0x134e, 0x1352, 0x1360, 0x1364, 0x130f,
+	0x13ee, 0x13f2, 0x1455, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f,
+	0x130f, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f,
+	0x1328, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f, 0x130f, 0x080c,
+	0x0db2, 0x2009, 0x0048, 0x2060, 0x080c, 0x9a50, 0x012e, 0x0005,
+	0x7004, 0xc085, 0xc0b5, 0x7006, 0x0005, 0x7004, 0xc085, 0x7006,
+	0x0005, 0x080c, 0x145c, 0x080c, 0x1518, 0x0005, 0x080c, 0x0db2,
+	0x080c, 0x145c, 0x2060, 0x6014, 0x0096, 0x2048, 0xa83b, 0xffff,
+	0x009e, 0x2009, 0x0048, 0x080c, 0x9a50, 0x2001, 0x015d, 0x2003,
+	0x0000, 0x2009, 0x03e8, 0x8109, 0x0160, 0x2001, 0x0201, 0x2004,
+	0x9005, 0x0dc8, 0x2001, 0x0218, 0x2004, 0xd0ec, 0x1110, 0x080c,
+	0x1461, 0x2001, 0x0307, 0x2003, 0x8000, 0x0005, 0x7004, 0xc095,
+	0x7006, 0x0005, 0x080c, 0x145c, 0x2060, 0x6014, 0x0096, 0x2048,
+	0xa83b, 0xffff, 0x009e, 0x2009, 0x0048, 0x080c, 0x9a50, 0x0005,
+	0x080c, 0x145c, 0x080c, 0x0db2, 0x080c, 0x145c, 0x080c, 0x13d9,
+	0x7827, 0x0018, 0x79ac, 0xd1dc, 0x0540, 0x7827, 0x0015, 0x7828,
+	0x782b, 0x0000, 0x9065, 0x0138, 0x2001, 0x020d, 0x2003, 0x0050,
+	0x2003, 0x0020, 0x0400, 0x7004, 0x9005, 0x1180, 0x78ab, 0x0004,
+	0x7827, 0x0018, 0x782b, 0x0000, 0xd1bc, 0x090c, 0x0db2, 0x2001,
+	0x020d, 0x2003, 0x0050, 0x2003, 0x0020, 0x0480, 0x78ab, 0x0004,
+	0x7803, 0x0001, 0x080c, 0x13f2, 0x0005, 0x7828, 0x782b, 0x0000,
+	0x9065, 0x090c, 0x0db2, 0x6014, 0x2048, 0x78ab, 0x0004, 0x918c,
+	0x0700, 0x0198, 0x080c, 0x763f, 0x080c, 0x1872, 0x080c, 0xb5fb,
+	0x0158, 0xa9ac, 0xa936, 0xa9b0, 0xa93a, 0xa83f, 0xffff, 0xa843,
+	0xffff, 0xa880, 0xc0bd, 0xa882, 0x0005, 0x6010, 0x00b6, 0x2058,
+	0xb800, 0x00be, 0xd0bc, 0x6024, 0x190c, 0xb9d9, 0x2029, 0x00c8,
+	0x8529, 0x0128, 0x2001, 0x0201, 0x2004, 0x9005, 0x0dc8, 0x7dbc,
+	0x080c, 0xd31b, 0xd5a4, 0x1118, 0x080c, 0x1461, 0x0005, 0x080c,
+	0x763f, 0x080c, 0x1872, 0x0005, 0x781f, 0x0300, 0x7803, 0x0001,
+	0x0005, 0x0016, 0x0066, 0x0076, 0x00f6, 0x2079, 0x0300, 0x7908,
+	0x918c, 0x0007, 0x9186, 0x0003, 0x0120, 0x2001, 0x0016, 0x080c,
+	0x14d2, 0x00fe, 0x007e, 0x006e, 0x001e, 0x0005, 0x7004, 0xc09d,
+	0x7006, 0x0005, 0x7104, 0x9184, 0x0004, 0x190c, 0x0db2, 0xd184,
+	0x1189, 0xd19c, 0x0158, 0xc19c, 0x7106, 0x2001, 0x020d, 0x2003,
+	0x0050, 0x2003, 0x0020, 0x080c, 0x1461, 0x0005, 0x81ff, 0x190c,
+	0x0db2, 0x0005, 0xc184, 0xd1b4, 0xc1b4, 0x7106, 0x0016, 0x00e6,
+	0x15e0, 0x2071, 0x0200, 0x080c, 0x150c, 0x6014, 0x9005, 0x05a8,
+	0x0096, 0x2048, 0xa864, 0x009e, 0x9084, 0x00ff, 0x908e, 0x0029,
+	0x0160, 0x908e, 0x0048, 0x1548, 0x601c, 0xd084, 0x11d8, 0x00f6,
+	0x2c78, 0x080c, 0x1582, 0x00fe, 0x00a8, 0x00f6, 0x2c78, 0x080c,
+	0x16b6, 0x00fe, 0x2009, 0x01f4, 0x8109, 0x0160, 0x2001, 0x0201,
+	0x2004, 0x9005, 0x0dc8, 0x2001, 0x0218, 0x2004, 0xd0ec, 0x1110,
+	0x0401, 0x0040, 0x2001, 0x020d, 0x2003, 0x0020, 0x080c, 0x12a0,
+	0x7803, 0x0001, 0x00ee, 0x001e, 0x0005, 0x2001, 0x020d, 0x2003,
+	0x0050, 0x2003, 0x0020, 0x0069, 0x0ca8, 0x0031, 0x2060, 0x2009,
+	0x0053, 0x080c, 0x9a50, 0x0005, 0x7808, 0xd09c, 0x0de8, 0x7820,
+	0x0005, 0x080c, 0x13d9, 0x00d6, 0x2069, 0x0200, 0x2009, 0x01f4,
+	0x8109, 0x0510, 0x6804, 0x9005, 0x0dd8, 0x2001, 0x015d, 0x2003,
+	0x0000, 0x79bc, 0xd1a4, 0x1528, 0x79b8, 0x918c, 0x0fff, 0x0180,
+	0x9182, 0x0841, 0x1268, 0x9188, 0x0007, 0x918c, 0x0ff8, 0x810c,
+	0x810c, 0x810c, 0x080c, 0x14c4, 0x6827, 0x0001, 0x8109, 0x1dd0,
+	0x04d9, 0x6827, 0x0002, 0x04c1, 0x6804, 0x9005, 0x1130, 0x682c,
+	0xd0e4, 0x1500, 0x6804, 0x9005, 0x0de8, 0x79b8, 0xd1ec, 0x1130,
+	0x08c0, 0x080c, 0x763f, 0x080c, 0x1872, 0x0090, 0x7827, 0x0015,
+	0x782b, 0x0000, 0x7827, 0x0018, 0x782b, 0x0000, 0x2001, 0x020d,
+	0x2003, 0x0020, 0x2001, 0x0307, 0x2003, 0x0300, 0x7803, 0x0001,
+	0x00de, 0x0005, 0x682c, 0x9084, 0x5400, 0x9086, 0x5400, 0x0d30,
+	0x7827, 0x0015, 0x782b, 0x0000, 0x7803, 0x0001, 0x6800, 0x9085,
+	0x1800, 0x6802, 0x00de, 0x0005, 0x6824, 0x9084, 0x0003, 0x1de0,
+	0x0005, 0x2001, 0x0030, 0x2c08, 0x621c, 0x0021, 0x7830, 0x9086,
+	0x0041, 0x0005, 0x00f6, 0x2079, 0x0300, 0x0006, 0x7808, 0xd09c,
+	0x0140, 0x0016, 0x0026, 0x00c6, 0x080c, 0x12d6, 0x00ce, 0x002e,
+	0x001e, 0x000e, 0x0006, 0x7832, 0x7936, 0x7a3a, 0x781b, 0x8080,
+	0x2009, 0xff00, 0x8109, 0x0130, 0x7818, 0xd0bc, 0x1dd8, 0x000e,
+	0x00fe, 0x0005, 0x000e, 0x792c, 0x3900, 0x8000, 0x2004, 0x080c,
+	0x0db2, 0x7832, 0x7936, 0x7a3a, 0x781b, 0x8080, 0x2009, 0xff00,
+	0x8109, 0x0120, 0x7818, 0xd0bc, 0x1dd8, 0x0005, 0x792c, 0x3900,
+	0x8000, 0x2004, 0x080c, 0x0db2, 0x7037, 0x0001, 0x7150, 0x7037,
+	0x0002, 0x7050, 0x2060, 0xd1bc, 0x1110, 0x7054, 0x2060, 0x0005,
+	0x00e6, 0x0016, 0x2071, 0x0200, 0x0c79, 0x6124, 0xd1dc, 0x01f8,
+	0x701c, 0xd08c, 0x0904, 0x1577, 0x7017, 0x0000, 0x2001, 0x0264,
+	0x2004, 0xd0bc, 0x0904, 0x1577, 0x2001, 0x0268, 0x00c6, 0x2064,
+	0x6104, 0x6038, 0x00ce, 0x918e, 0x0039, 0x1904, 0x1577, 0x9c06,
+	0x15f0, 0x0126, 0x2091, 0x2600, 0x080c, 0x7597, 0x012e, 0x7358,
+	0x745c, 0x6014, 0x905d, 0x0598, 0x2b48, 0x6010, 0x00b6, 0x2058,
+	0xb800, 0x00be, 0xd0bc, 0x190c, 0xb9b4, 0xab42, 0xac3e, 0x2001,
+	0x1875, 0x2004, 0xd0b4, 0x1170, 0x601c, 0xd0e4, 0x1158, 0x6010,
+	0x00b6, 0x2058, 0xb800, 0x00be, 0xd0bc, 0x1120, 0xa83b, 0x7fff,
+	0xa837, 0xffff, 0x080c, 0x1dc2, 0x1190, 0x080c, 0x1705, 0x2a00,
+	0xa816, 0x0130, 0x2800, 0xa80e, 0x2c05, 0xa80a, 0x2c00, 0xa812,
+	0x7037, 0x0020, 0x781f, 0x0300, 0x001e, 0x00ee, 0x0005, 0x7037,
+	0x0050, 0x7037, 0x0020, 0x001e, 0x00ee, 0x080c, 0x1461, 0x0005,
+	0x080c, 0x0db2, 0x2ff0, 0x0126, 0x2091, 0x2200, 0x3e60, 0x6014,
+	0x2048, 0x2940, 0x903e, 0x2730, 0xa864, 0x2068, 0xa81a, 0x9d84,
+	0x000f, 0x9088, 0x1da2, 0x2165, 0x0002, 0x15ac, 0x15f9, 0x15ac,
+	0x15ac, 0x15ac, 0x15db, 0x15ac, 0x15b0, 0x15a5, 0x15f0, 0x15ac,
+	0x15ac, 0x15ac, 0x16b4, 0x15c4, 0x15ba, 0xa964, 0x918c, 0x00ff,
+	0x918e, 0x0048, 0x0904, 0x15f0, 0x9085, 0x0001, 0x0804, 0x16ac,
+	0xa87c, 0xd0bc, 0x0dc8, 0xa890, 0xa842, 0xa88c, 0xa83e, 0xa888,
+	0x0804, 0x1600, 0xa87c, 0xd0bc, 0x0d78, 0xa890, 0xa842, 0xa88c,
+	0xa83e, 0xa888, 0x0804, 0x164f, 0xa87c, 0xd0bc, 0x0d28, 0xa890,
+	0xa842, 0xa88c, 0xa83e, 0xa804, 0x9045, 0x090c, 0x0db2, 0xa164,
+	0xa91a, 0x91ec, 0x000f, 0x9d80, 0x1da2, 0x2065, 0xa888, 0xd19c,
+	0x1904, 0x164f, 0x0428, 0xa87c, 0xd0ac, 0x0970, 0xa804, 0x9045,
+	0x090c, 0x0db2, 0xa164, 0xa91a, 0x91ec, 0x000f, 0x9d80, 0x1da2,
+	0x2065, 0x9006, 0xa842, 0xa83e, 0xd19c, 0x1904, 0x164f, 0x0080,
+	0xa87c, 0xd0ac, 0x0904, 0x15ac, 0x9006, 0xa842, 0xa83e, 0x0804,
+	0x164f, 0xa87c, 0xd0ac, 0x0904, 0x15ac, 0x9006, 0xa842, 0xa83e,
+	0x2c05, 0x908a, 0x0036, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002,
+	0x1623, 0x1623, 0x1625, 0x1623, 0x1623, 0x1623, 0x162b, 0x1623,
+	0x1623, 0x1623, 0x1631, 0x1623, 0x1623, 0x1623, 0x1637, 0x1623,
+	0x1623, 0x1623, 0x163d, 0x1623, 0x1623, 0x1623, 0x1643, 0x1623,
+	0x1623, 0x1623, 0x1649, 0x080c, 0x0db2, 0xa574, 0xa478, 0xa37c,
+	0xa280, 0x0804, 0x1694, 0xa584, 0xa488, 0xa38c, 0xa290, 0x0804,
+	0x1694, 0xa594, 0xa498, 0xa39c, 0xa2a0, 0x0804, 0x1694, 0xa5a4,
+	0xa4a8, 0xa3ac, 0xa2b0, 0x0804, 0x1694, 0xa5b4, 0xa4b8, 0xa3bc,
+	0xa2c0, 0x0804, 0x1694, 0xa5c4, 0xa4c8, 0xa3cc, 0xa2d0, 0x0804,
+	0x1694, 0xa5d4, 0xa4d8, 0xa3dc, 0xa2e0, 0x0804, 0x1694, 0x2c05,
+	0x908a, 0x0034, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1672,
+	0x1670, 0x1670, 0x1670, 0x1670, 0x1670, 0x1679, 0x1670, 0x1670,
+	0x1670, 0x1670, 0x1670, 0x1680, 0x1670, 0x1670, 0x1670, 0x1670,
+	0x1670, 0x1687, 0x1670, 0x1670, 0x1670, 0x1670, 0x1670, 0x168e,
+	0x080c, 0x0db2, 0xa56c, 0xa470, 0xa774, 0xa678, 0xa37c, 0xa280,
+	0x00d8, 0xa584, 0xa488, 0xa78c, 0xa690, 0xa394, 0xa298, 0x00a0,
+	0xa59c, 0xa4a0, 0xa7a4, 0xa6a8, 0xa3ac, 0xa2b0, 0x0068, 0xa5b4,
+	0xa4b8, 0xa7bc, 0xa6c0, 0xa3c4, 0xa2c8, 0x0030, 0xa5cc, 0xa4d0,
+	0xa7d4, 0xa6d8, 0xa3dc, 0xa2e0, 0xab2e, 0xaa32, 0xad1e, 0xac22,
+	0xaf26, 0xae2a, 0xa988, 0x8c60, 0x2c1d, 0xa8ac, 0xaab0, 0xa836,
+	0xaa3a, 0x8109, 0xa916, 0x1150, 0x3e60, 0x601c, 0xc085, 0x601e,
+	0xa87c, 0xc0dd, 0xa87e, 0x9006, 0x012e, 0x0005, 0x2800, 0xa80e,
+	0xab0a, 0x2c00, 0xa812, 0x0c80, 0x0804, 0x15ac, 0x2ff0, 0x0126,
+	0x2091, 0x2200, 0x3e60, 0x6014, 0x2048, 0x2940, 0xa80e, 0x2061,
+	0x1d9d, 0xa80b, 0x1d9d, 0x2c05, 0xa812, 0xa964, 0xa91a, 0xa87c,
+	0xd0ac, 0x090c, 0x0db2, 0x9006, 0xa842, 0xa83e, 0x2c05, 0x908a,
+	0x0034, 0x1a0c, 0x0db2, 0xadcc, 0xacd0, 0xafd4, 0xaed8, 0xabdc,
+	0xaae0, 0xab2e, 0xaa32, 0xad1e, 0xac22, 0xaf26, 0xae2a, 0xa8ac,
+	0xaab0, 0xa836, 0xaa3a, 0xa988, 0x918a, 0x0002, 0xa916, 0x1150,
+	0x3e60, 0x601c, 0xc085, 0x601e, 0xa87c, 0xc0dd, 0xa87e, 0x9006,
+	0x012e, 0x0005, 0xa804, 0x9045, 0x090c, 0x0db2, 0xa80e, 0xa064,
+	0xa81a, 0x9084, 0x000f, 0x9080, 0x1da2, 0x2015, 0x82ff, 0x090c,
+	0x0db2, 0xaa0a, 0x2205, 0xa812, 0x0c18, 0x903e, 0x2730, 0xa880,
+	0xd0fc, 0x1190, 0x2d00, 0x0002, 0x17fa, 0x175c, 0x175c, 0x17fa,
+	0x17fa, 0x17f4, 0x17fa, 0x175c, 0x17fa, 0x17ab, 0x17ab, 0x17fa,
+	0x17fa, 0x17fa, 0x17f1, 0x17ab, 0xc0fc, 0xa882, 0xab2c, 0xaa30,
+	0xad1c, 0xac20, 0xdd9c, 0x0904, 0x17fc, 0x2c05, 0x908a, 0x0034,
+	0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1748, 0x1746, 0x1746,
+	0x1746, 0x1746, 0x1746, 0x174c, 0x1746, 0x1746, 0x1746, 0x1746,
+	0x1746, 0x1750, 0x1746, 0x1746, 0x1746, 0x1746, 0x1746, 0x1754,
+	0x1746, 0x1746, 0x1746, 0x1746, 0x1746, 0x1758, 0x080c, 0x0db2,
+	0xa774, 0xa678, 0x0804, 0x17fc, 0xa78c, 0xa690, 0x0804, 0x17fc,
+	0xa7a4, 0xa6a8, 0x0804, 0x17fc, 0xa7bc, 0xa6c0, 0x0804, 0x17fc,
+	0xa7d4, 0xa6d8, 0x0804, 0x17fc, 0x2c05, 0x908a, 0x0036, 0x1a0c,
+	0x0db2, 0x9082, 0x001b, 0x0002, 0x177f, 0x177f, 0x1781, 0x177f,
+	0x177f, 0x177f, 0x1787, 0x177f, 0x177f, 0x177f, 0x178d, 0x177f,
+	0x177f, 0x177f, 0x1793, 0x177f, 0x177f, 0x177f, 0x1799, 0x177f,
+	0x177f, 0x177f, 0x179f, 0x177f, 0x177f, 0x177f, 0x17a5, 0x080c,
+	0x0db2, 0xa574, 0xa478, 0xa37c, 0xa280, 0x0804, 0x17fc, 0xa584,
+	0xa488, 0xa38c, 0xa290, 0x0804, 0x17fc, 0xa594, 0xa498, 0xa39c,
+	0xa2a0, 0x0804, 0x17fc, 0xa5a4, 0xa4a8, 0xa3ac, 0xa2b0, 0x0804,
+	0x17fc, 0xa5b4, 0xa4b8, 0xa3bc, 0xa2c0, 0x0804, 0x17fc, 0xa5c4,
+	0xa4c8, 0xa3cc, 0xa2d0, 0x0804, 0x17fc, 0xa5d4, 0xa4d8, 0xa3dc,
+	0xa2e0, 0x0804, 0x17fc, 0x2c05, 0x908a, 0x0034, 0x1a0c, 0x0db2,
+	0x9082, 0x001b, 0x0002, 0x17ce, 0x17cc, 0x17cc, 0x17cc, 0x17cc,
+	0x17cc, 0x17d5, 0x17cc, 0x17cc, 0x17cc, 0x17cc, 0x17cc, 0x17dc,
+	0x17cc, 0x17cc, 0x17cc, 0x17cc, 0x17cc, 0x17e3, 0x17cc, 0x17cc,
+	0x17cc, 0x17cc, 0x17cc, 0x17ea, 0x080c, 0x0db2, 0xa56c, 0xa470,
+	0xa774, 0xa678, 0xa37c, 0xa280, 0x0438, 0xa584, 0xa488, 0xa78c,
+	0xa690, 0xa394, 0xa298, 0x0400, 0xa59c, 0xa4a0, 0xa7a4, 0xa6a8,
+	0xa3ac, 0xa2b0, 0x00c8, 0xa5b4, 0xa4b8, 0xa7bc, 0xa6c0, 0xa3c4,
+	0xa2c8, 0x0090, 0xa5cc, 0xa4d0, 0xa7d4, 0xa6d8, 0xa3dc, 0xa2e0,
+	0x0058, 0x9d86, 0x000e, 0x1130, 0x080c, 0x1d60, 0x1904, 0x1705,
+	0x900e, 0x0050, 0x080c, 0x0db2, 0xab2e, 0xaa32, 0xad1e, 0xac22,
+	0xaf26, 0xae2a, 0x080c, 0x1d60, 0x0005, 0x6014, 0x2048, 0x6118,
+	0x810c, 0x810c, 0x810c, 0x81ff, 0x1118, 0xa887, 0x0001, 0x0008,
+	0xa986, 0x601b, 0x0002, 0xa974, 0xd1dc, 0x1108, 0x0005, 0xa934,
+	0xa88c, 0x9106, 0x1158, 0xa938, 0xa890, 0x9106, 0x1138, 0x601c,
+	0xc084, 0x601e, 0x2009, 0x0048, 0x0804, 0x9a50, 0x0005, 0x0126,
+	0x00c6, 0x2091, 0x2200, 0x00ce, 0x7908, 0x918c, 0x0007, 0x9186,
+	0x0000, 0x05b0, 0x9186, 0x0003, 0x0598, 0x6020, 0x6023, 0x0000,
+	0x0006, 0x2031, 0x0008, 0x00c6, 0x781f, 0x0808, 0x7808, 0xd09c,
+	0x0120, 0x080c, 0x12d6, 0x8631, 0x1db8, 0x00ce, 0x781f, 0x0800,
+	0x2031, 0x0168, 0x00c6, 0x7808, 0xd09c, 0x190c, 0x12d6, 0x00ce,
+	0x2001, 0x0038, 0x080c, 0x18ff, 0x7930, 0x9186, 0x0040, 0x0160,
+	0x9186, 0x0042, 0x190c, 0x0db2, 0x2001, 0x001e, 0x8001, 0x1df0,
+	0x8631, 0x1d40, 0x080c, 0x190e, 0x000e, 0x6022, 0x012e, 0x0005,
+	0x080c, 0x18fb, 0x7827, 0x0015, 0x7828, 0x9c06, 0x1db8, 0x782b,
+	0x0000, 0x0ca0, 0x00f6, 0x2079, 0x0300, 0x7803, 0x0000, 0x78ab,
+	0x0004, 0x00fe, 0x080c, 0x6c53, 0x11b0, 0x2001, 0x0138, 0x2003,
+	0x0000, 0x2001, 0x0160, 0x2003, 0x0000, 0x2011, 0x012c, 0xa001,
+	0xa001, 0x8211, 0x1de0, 0x0081, 0x0066, 0x2031, 0x0000, 0x080c,
+	0x6d03, 0x006e, 0x0005, 0x0479, 0x0039, 0x2001, 0x0160, 0x2502,
+	0x2001, 0x0138, 0x2202, 0x0005, 0x00e6, 0x2071, 0x0200, 0x080c,
+	0x28dc, 0x2009, 0x003c, 0x080c, 0x20d9, 0x2001, 0x015d, 0x2003,
+	0x0000, 0x7000, 0x9084, 0x003c, 0x1de0, 0x080c, 0x7b7c, 0x70a0,
+	0x70a2, 0x7098, 0x709a, 0x709c, 0x709e, 0x2001, 0x020d, 0x2003,
+	0x0020, 0x00f6, 0x2079, 0x0300, 0x080c, 0x12a0, 0x7803, 0x0001,
+	0x00fe, 0x00ee, 0x0005, 0x2001, 0x0138, 0x2014, 0x2003, 0x0000,
+	0x2001, 0x0160, 0x202c, 0x2003, 0x0000, 0x080c, 0x6c53, 0x1108,
+	0x0005, 0x2021, 0x0260, 0x2001, 0x0141, 0x201c, 0xd3dc, 0x1168,
+	0x2001, 0x0109, 0x201c, 0x939c, 0x0048, 0x1160, 0x2001, 0x0111,
+	0x201c, 0x83ff, 0x1110, 0x8421, 0x1d70, 0x2001, 0x015d, 0x2003,
+	0x0000, 0x0005, 0x0046, 0x2021, 0x0019, 0x2003, 0x0048, 0xa001,
+	0xa001, 0x201c, 0x939c, 0x0048, 0x0120, 0x8421, 0x1db0, 0x004e,
+	0x0c60, 0x004e, 0x0c40, 0x601c, 0xc084, 0x601e, 0x0005, 0x2c08,
+	0x621c, 0x080c, 0x14d2, 0x7930, 0x0005, 0x2c08, 0x621c, 0x080c,
+	0x14f9, 0x7930, 0x0005, 0x8001, 0x1df0, 0x0005, 0x2031, 0x0005,
+	0x781c, 0x9084, 0x0007, 0x0170, 0x2001, 0x0038, 0x0c41, 0x9186,
+	0x0040, 0x0904, 0x196c, 0x2001, 0x001e, 0x0c69, 0x8631, 0x1d80,
+	0x080c, 0x0db2, 0x781f, 0x0202, 0x2001, 0x015d, 0x2003, 0x0000,
+	0x2001, 0x0b10, 0x0c01, 0x781c, 0xd084, 0x0110, 0x0861, 0x04e0,
+	0x2001, 0x0030, 0x0891, 0x9186, 0x0040, 0x0568, 0x781c, 0xd084,
+	0x1da8, 0x781f, 0x0101, 0x2001, 0x0014, 0x0869, 0x2001, 0x0037,
+	0x0821, 0x9186, 0x0040, 0x0140, 0x2001, 0x0030, 0x080c, 0x1905,
+	0x9186, 0x0040, 0x190c, 0x0db2, 0x00d6, 0x2069, 0x0200, 0x692c,
+	0xd1f4, 0x1170, 0xd1c4, 0x0160, 0xd19c, 0x0130, 0x6800, 0x9085,
+	0x1800, 0x6802, 0x00de, 0x0080, 0x6908, 0x9184, 0x0007, 0x1db0,
+	0x00de, 0x781f, 0x0100, 0x791c, 0x9184, 0x0007, 0x090c, 0x0db2,
+	0xa001, 0xa001, 0x781f, 0x0200, 0x0005, 0x0126, 0x2091, 0x2400,
+	0x2071, 0x1a34, 0x2079, 0x0090, 0x012e, 0x0005, 0x9280, 0x0005,
+	0x2004, 0x2048, 0xa97c, 0xd1dc, 0x1904, 0x19f1, 0xa964, 0x9184,
+	0x0007, 0x0002, 0x198a, 0x19dc, 0x1991, 0x1991, 0x1991, 0x19c4,
+	0x19a4, 0x1993, 0x2100, 0x9084, 0x00ff, 0x9086, 0x0048, 0x0904,
+	0x19dc, 0x080c, 0x0db2, 0xa87c, 0xd0b4, 0x0904, 0x1ba3, 0xa890,
+	0xa842, 0xa83a, 0xa88c, 0xa83e, 0xa836, 0xa8ac, 0xa846, 0xa8b0,
+	0xa84a, 0xa988, 0x0804, 0x19e4, 0xa864, 0x9084, 0x00ff, 0x9086,
+	0x001e, 0x1d38, 0xa87c, 0xd0b4, 0x0904, 0x1ba3, 0xa890, 0xa842,
+	0xa83a, 0xa88c, 0xa83e, 0xa836, 0xa8ac, 0xa846, 0xa8b0, 0xa84a,
+	0xa804, 0xa85a, 0x2040, 0xa064, 0x9084, 0x000f, 0x9080, 0x1da2,
+	0x2005, 0xa812, 0xa988, 0x0448, 0x918c, 0x00ff, 0x9186, 0x0015,
+	0x1540, 0xa87c, 0xd0b4, 0x0904, 0x1ba3, 0xa804, 0xa85a, 0x2040,
+	0xa064, 0x9084, 0x000f, 0x9080, 0x1da2, 0x2005, 0xa812, 0xa988,
+	0x9006, 0xa842, 0xa83e, 0x0088, 0xa87c, 0xd0b4, 0x0904, 0x1ba3,
+	0xa988, 0x9006, 0xa842, 0xa83e, 0x2900, 0xa85a, 0xa864, 0x9084,
+	0x000f, 0x9080, 0x1da2, 0x2005, 0xa812, 0xa916, 0xa87c, 0xc0dd,
+	0xa87e, 0x0005, 0x00f6, 0x2079, 0x0090, 0x782c, 0xd0fc, 0x190c,
+	0x1be4, 0x00e6, 0x2071, 0x1a34, 0x7000, 0x9005, 0x1904, 0x1a4b,
+	0x7206, 0x9280, 0x0005, 0x204c, 0x9280, 0x0004, 0x2004, 0x782b,
+	0x0004, 0x00f6, 0x2079, 0x0200, 0x7803, 0x0040, 0x00fe, 0x00b6,
+	0x2058, 0xb86c, 0x7836, 0xb890, 0x00be, 0x00f6, 0x2079, 0x0200,
+	0x7803, 0x0040, 0xa001, 0xa001, 0xa001, 0xa001, 0xa001, 0xa001,
+	0x781a, 0x2079, 0x0100, 0x8004, 0x78d6, 0x00fe, 0xa814, 0x2050,
+	0xa858, 0x2040, 0xa810, 0x2060, 0xa064, 0x90ec, 0x000f, 0xa944,
+	0x791a, 0x7116, 0xa848, 0x781e, 0x701a, 0x9006, 0x700e, 0x7012,
+	0x7004, 0xa940, 0xa838, 0x9106, 0x1188, 0xa93c, 0xa834, 0x9106,
+	0x1168, 0x8aff, 0x01a8, 0x0126, 0x2091, 0x8000, 0x00a1, 0x0108,
+	0x0091, 0x012e, 0x9006, 0x00ee, 0x00fe, 0x0005, 0x0036, 0x0046,
+	0xab38, 0xac34, 0x080c, 0x1dc2, 0x004e, 0x003e, 0x0d50, 0x0c98,
+	0x9085, 0x0001, 0x0c80, 0x0076, 0x0066, 0x0056, 0x0046, 0x0036,
+	0x0026, 0x8aff, 0x0904, 0x1b9c, 0x700c, 0x7214, 0x923a, 0x7010,
+	0x7218, 0x9203, 0x0a04, 0x1b9b, 0x9705, 0x0904, 0x1b9b, 0x903e,
+	0x2730, 0xa880, 0xd0fc, 0x1190, 0x2d00, 0x0002, 0x1b7f, 0x1ac6,
+	0x1ac6, 0x1b7f, 0x1b7f, 0x1b62, 0x1b7f, 0x1ac6, 0x1b68, 0x1b15,
+	0x1b15, 0x1b7f, 0x1b7f, 0x1b7f, 0x1b5c, 0x1b15, 0xc0fc, 0xa882,
+	0xab2c, 0xaa30, 0xad1c, 0xac20, 0xdd9c, 0x0904, 0x1b81, 0x2c05,
+	0x908a, 0x0034, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1ab2,
+	0x1ab0, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ab6, 0x1ab0, 0x1ab0,
+	0x1ab0, 0x1ab0, 0x1ab0, 0x1aba, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ab0,
+	0x1ab0, 0x1abe, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ab0, 0x1ac2,
+	0x080c, 0x0db2, 0xa774, 0xa678, 0x0804, 0x1b81, 0xa78c, 0xa690,
+	0x0804, 0x1b81, 0xa7a4, 0xa6a8, 0x0804, 0x1b81, 0xa7bc, 0xa6c0,
+	0x0804, 0x1b81, 0xa7d4, 0xa6d8, 0x0804, 0x1b81, 0x2c05, 0x908a,
+	0x0036, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1ae9, 0x1ae9,
+	0x1aeb, 0x1ae9, 0x1ae9, 0x1ae9, 0x1af1, 0x1ae9, 0x1ae9, 0x1ae9,
+	0x1af7, 0x1ae9, 0x1ae9, 0x1ae9, 0x1afd, 0x1ae9, 0x1ae9, 0x1ae9,
+	0x1b03, 0x1ae9, 0x1ae9, 0x1ae9, 0x1b09, 0x1ae9, 0x1ae9, 0x1ae9,
+	0x1b0f, 0x080c, 0x0db2, 0xa574, 0xa478, 0xa37c, 0xa280, 0x0804,
+	0x1b81, 0xa584, 0xa488, 0xa38c, 0xa290, 0x0804, 0x1b81, 0xa594,
+	0xa498, 0xa39c, 0xa2a0, 0x0804, 0x1b81, 0xa5a4, 0xa4a8, 0xa3ac,
+	0xa2b0, 0x0804, 0x1b81, 0xa5b4, 0xa4b8, 0xa3bc, 0xa2c0, 0x0804,
+	0x1b81, 0xa5c4, 0xa4c8, 0xa3cc, 0xa2d0, 0x0804, 0x1b81, 0xa5d4,
+	0xa4d8, 0xa3dc, 0xa2e0, 0x0804, 0x1b81, 0x2c05, 0x908a, 0x0034,
+	0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1b38, 0x1b36, 0x1b36,
+	0x1b36, 0x1b36, 0x1b36, 0x1b40, 0x1b36, 0x1b36, 0x1b36, 0x1b36,
+	0x1b36, 0x1b47, 0x1b36, 0x1b36, 0x1b36, 0x1b36, 0x1b36, 0x1b4e,
+	0x1b36, 0x1b36, 0x1b36, 0x1b36, 0x1b36, 0x1b55, 0x080c, 0x0db2,
+	0xa56c, 0xa470, 0xa774, 0xa678, 0xa37c, 0xa280, 0x0804, 0x1b81,
+	0xa584, 0xa488, 0xa78c, 0xa690, 0xa394, 0xa298, 0x04d0, 0xa59c,
+	0xa4a0, 0xa7a4, 0xa6a8, 0xa3ac, 0xa2b0, 0x0498, 0xa5b4, 0xa4b8,
+	0xa7bc, 0xa6c0, 0xa3c4, 0xa2c8, 0x0460, 0xa5cc, 0xa4d0, 0xa7d4,
+	0xa6d8, 0xa3dc, 0xa2e0, 0x0428, 0xa864, 0x9084, 0x00ff, 0x9086,
+	0x001e, 0x11e8, 0x080c, 0x1d60, 0x1904, 0x1a61, 0x900e, 0x04a0,
+	0xa864, 0x9084, 0x00ff, 0x9086, 0x0048, 0x190c, 0x0db2, 0x00c6,
+	0x7004, 0x2060, 0x6004, 0x9086, 0x0043, 0x00ce, 0x0904, 0x1b15,
+	0xab9c, 0x9016, 0xad8c, 0xac90, 0xaf94, 0xae98, 0x0010, 0x080c,
+	0x0db2, 0x7b12, 0x7a16, 0x7d02, 0x7c06, 0x7f0a, 0x7e0e, 0x782b,
+	0x0001, 0x7000, 0x8000, 0x7002, 0xa83c, 0x9300, 0xa83e, 0xa840,
+	0x9201, 0xa842, 0x700c, 0x9300, 0x700e, 0x7010, 0x9201, 0x7012,
+	0x080c, 0x1d60, 0x0008, 0x9006, 0x002e, 0x003e, 0x004e, 0x005e,
+	0x006e, 0x007e, 0x0005, 0x080c, 0x0db2, 0x0026, 0x2001, 0x0105,
+	0x2003, 0x0010, 0x782b, 0x0004, 0x7003, 0x0000, 0x7004, 0x2060,
+	0x6014, 0x2048, 0x080c, 0xb5fb, 0x0118, 0xa880, 0xc0bd, 0xa882,
+	0x6020, 0x9086, 0x0006, 0x1180, 0x2061, 0x0100, 0x62c8, 0x2001,
+	0x00fa, 0x8001, 0x1df0, 0x60c8, 0x9206, 0x1dc0, 0x60c4, 0xa89a,
+	0x60c8, 0xa896, 0x7004, 0x2060, 0x00c6, 0x080c, 0xb251, 0x00ce,
+	0x2001, 0x19c5, 0x2004, 0x9c06, 0x1160, 0x2009, 0x0040, 0x080c,
+	0x20d9, 0x080c, 0x9479, 0x2011, 0x0000, 0x080c, 0x92f6, 0x080c,
+	0x865d, 0x002e, 0x0804, 0x1d12, 0x0126, 0x2091, 0x2400, 0xa858,
+	0x2040, 0x792c, 0x782b, 0x0002, 0x9184, 0x0700, 0x1904, 0x1ba5,
+	0x7000, 0x0002, 0x1d12, 0x1bf6, 0x1c63, 0x1d10, 0x8001, 0x7002,
+	0xd19c, 0x1150, 0x8aff, 0x05b0, 0x080c, 0x1a5b, 0x0904, 0x1d12,
+	0x080c, 0x1a5b, 0x0804, 0x1d12, 0x782b, 0x0004, 0xd194, 0x0148,
+	0xa880, 0xc0fc, 0xa882, 0x8aff, 0x11d8, 0xa87c, 0xc0f5, 0xa87e,
+	0x00b8, 0x0026, 0x0036, 0xab3c, 0xaa40, 0x7810, 0xa82e, 0x931a,
+	0x7814, 0xa832, 0x9213, 0x7800, 0xa81e, 0x7804, 0xa822, 0xab3e,
+	0xaa42, 0x003e, 0x002e, 0x080c, 0x1d78, 0xa880, 0xc0fd, 0xa882,
+	0x2a00, 0xa816, 0x2800, 0xa85a, 0x2c00, 0xa812, 0x7003, 0x0000,
+	0x0804, 0x1d12, 0x00f6, 0x0026, 0x781c, 0x0006, 0x7818, 0x0006,
+	0x2079, 0x0100, 0x7a14, 0x9284, 0x1984, 0x9085, 0x0012, 0x7816,
+	0x0036, 0x2019, 0x1000, 0x8319, 0x090c, 0x0db2, 0x7820, 0xd0bc,
+	0x1dd0, 0x003e, 0x79c8, 0x000e, 0x9102, 0x001e, 0x0006, 0x0016,
+	0x79c4, 0x000e, 0x9103, 0x78c6, 0x000e, 0x78ca, 0x9284, 0x1984,
+	0x9085, 0x0012, 0x7816, 0x002e, 0x00fe, 0x782b, 0x0008, 0x7003,
+	0x0000, 0x0804, 0x1d12, 0x8001, 0x7002, 0xd194, 0x0170, 0x782c,
+	0xd0fc, 0x1904, 0x1be9, 0xd19c, 0x1904, 0x1d0e, 0x8aff, 0x0904,
+	0x1d12, 0x080c, 0x1a5b, 0x0804, 0x1d12, 0x0026, 0x0036, 0xab3c,
+	0xaa40, 0x080c, 0x1d78, 0xdd9c, 0x1904, 0x1ccd, 0x2c05, 0x908a,
+	0x0036, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1ca1, 0x1ca1,
+	0x1ca3, 0x1ca1, 0x1ca1, 0x1ca1, 0x1ca9, 0x1ca1, 0x1ca1, 0x1ca1,
+	0x1caf, 0x1ca1, 0x1ca1, 0x1ca1, 0x1cb5, 0x1ca1, 0x1ca1, 0x1ca1,
+	0x1cbb, 0x1ca1, 0x1ca1, 0x1ca1, 0x1cc1, 0x1ca1, 0x1ca1, 0x1ca1,
+	0x1cc7, 0x080c, 0x0db2, 0xa07c, 0x931a, 0xa080, 0x9213, 0x0804,
+	0x1c15, 0xa08c, 0x931a, 0xa090, 0x9213, 0x0804, 0x1c15, 0xa09c,
+	0x931a, 0xa0a0, 0x9213, 0x0804, 0x1c15, 0xa0ac, 0x931a, 0xa0b0,
+	0x9213, 0x0804, 0x1c15, 0xa0bc, 0x931a, 0xa0c0, 0x9213, 0x0804,
+	0x1c15, 0xa0cc, 0x931a, 0xa0d0, 0x9213, 0x0804, 0x1c15, 0xa0dc,
+	0x931a, 0xa0e0, 0x9213, 0x0804, 0x1c15, 0x2c05, 0x908a, 0x0034,
+	0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1cf0, 0x1cee, 0x1cee,
+	0x1cee, 0x1cee, 0x1cee, 0x1cf6, 0x1cee, 0x1cee, 0x1cee, 0x1cee,
+	0x1cee, 0x1cfc, 0x1cee, 0x1cee, 0x1cee, 0x1cee, 0x1cee, 0x1d02,
+	0x1cee, 0x1cee, 0x1cee, 0x1cee, 0x1cee, 0x1d08, 0x080c, 0x0db2,
+	0xa07c, 0x931a, 0xa080, 0x9213, 0x0804, 0x1c15, 0xa094, 0x931a,
+	0xa098, 0x9213, 0x0804, 0x1c15, 0xa0ac, 0x931a, 0xa0b0, 0x9213,
+	0x0804, 0x1c15, 0xa0c4, 0x931a, 0xa0c8, 0x9213, 0x0804, 0x1c15,
+	0xa0dc, 0x931a, 0xa0e0, 0x9213, 0x0804, 0x1c15, 0x0804, 0x1c11,
+	0x080c, 0x0db2, 0x012e, 0x0005, 0x00f6, 0x00e6, 0x2071, 0x1a34,
+	0x7000, 0x9086, 0x0000, 0x0904, 0x1d5d, 0x2079, 0x0090, 0x2009,
+	0x0207, 0x210c, 0xd194, 0x01b8, 0x2009, 0x020c, 0x210c, 0x9184,
+	0x0003, 0x0188, 0x080c, 0xd364, 0x2001, 0x0133, 0x2004, 0x9005,
+	0x090c, 0x0db2, 0x0016, 0x2009, 0x0040, 0x080c, 0x20d9, 0x001e,
+	0x2001, 0x020c, 0x2102, 0x2009, 0x0206, 0x2104, 0x2009, 0x0203,
+	0x210c, 0x9106, 0x1120, 0x2009, 0x0040, 0x080c, 0x20d9, 0x782c,
+	0xd0fc, 0x09a8, 0x080c, 0x1be4, 0x7000, 0x9086, 0x0000, 0x1978,
+	0x782b, 0x0004, 0x782c, 0xd0ac, 0x1de8, 0x2009, 0x0040, 0x080c,
+	0x20d9, 0x782b, 0x0002, 0x7003, 0x0000, 0x00ee, 0x00fe, 0x0005,
+	0x8c60, 0x2c05, 0x9005, 0x0110, 0x8a51, 0x0005, 0xa004, 0x9005,
+	0x0168, 0xa85a, 0x2040, 0xa064, 0x9084, 0x000f, 0x9080, 0x1da2,
+	0x2065, 0x8cff, 0x090c, 0x0db2, 0x8a51, 0x0005, 0x2050, 0x0005,
+	0x8a50, 0x8c61, 0x2c05, 0x9005, 0x1190, 0x2800, 0x9906, 0x0120,
+	0xa000, 0x9005, 0x1108, 0x2900, 0x2040, 0xa85a, 0xa064, 0x9084,
+	0x000f, 0x9080, 0x1db2, 0x2065, 0x8cff, 0x090c, 0x0db2, 0x0005,
+	0x0000, 0x001d, 0x0021, 0x0025, 0x0029, 0x002d, 0x0031, 0x0035,
+	0x0000, 0x001b, 0x0021, 0x0027, 0x002d, 0x0033, 0x0000, 0x0000,
+	0x0023, 0x0000, 0x0000, 0x1d95, 0x1d91, 0x0000, 0x0000, 0x1d9f,
+	0x0000, 0x1d95, 0x1d9c, 0x1d9c, 0x1d99, 0x0000, 0x0000, 0x0000,
+	0x1d9f, 0x1d9c, 0x0000, 0x1d97, 0x1d97, 0x0000, 0x0000, 0x1d9f,
+	0x0000, 0x1d97, 0x1d9d, 0x1d9d, 0x1d9d, 0x0000, 0x0000, 0x0000,
+	0x1d9f, 0x1d9d, 0x00c6, 0x00d6, 0x0086, 0xab42, 0xac3e, 0xa888,
+	0x9055, 0x0904, 0x1f99, 0x2940, 0xa064, 0x90ec, 0x000f, 0x9de0,
+	0x1da2, 0x9d86, 0x0007, 0x0130, 0x9d86, 0x000e, 0x0118, 0x9d86,
+	0x000f, 0x1120, 0xa08c, 0x9422, 0xa090, 0x931b, 0x2c05, 0x9065,
+	0x1140, 0x0310, 0x0804, 0x1f99, 0xa004, 0x9045, 0x0904, 0x1f99,
+	0x0c18, 0x2c05, 0x9005, 0x0904, 0x1e81, 0xdd9c, 0x1904, 0x1e3d,
+	0x908a, 0x0036, 0x1a0c, 0x0db2, 0x9082, 0x001b, 0x0002, 0x1e12,
+	0x1e12, 0x1e14, 0x1e12, 0x1e12, 0x1e12, 0x1e1a, 0x1e12, 0x1e12,
+	0x1e12, 0x1e20, 0x1e12, 0x1e12, 0x1e12, 0x1e26, 0x1e12, 0x1e12,
+	0x1e12, 0x1e2c, 0x1e12, 0x1e12, 0x1e12, 0x1e32, 0x1e12, 0x1e12,
+	0x1e12, 0x1e38, 0x080c, 0x0db2, 0xa07c, 0x9422, 0xa080, 0x931b,
+	0x0804, 0x1e77, 0xa08c, 0x9422, 0xa090, 0x931b, 0x0804, 0x1e77,
+	0xa09c, 0x9422, 0xa0a0, 0x931b, 0x0804, 0x1e77, 0xa0ac, 0x9422,
+	0xa0b0, 0x931b, 0x0804, 0x1e77, 0xa0bc, 0x9422, 0xa0c0, 0x931b,
+	0x0804, 0x1e77, 0xa0cc, 0x9422, 0xa0d0, 0x931b, 0x0804, 0x1e77,
+	0xa0dc, 0x9422, 0xa0e0, 0x931b, 0x04d0, 0x908a, 0x0034, 0x1a0c,
+	0x0db2, 0x9082, 0x001b, 0x0002, 0x1e5f, 0x1e5d, 0x1e5d, 0x1e5d,
+	0x1e5d, 0x1e5d, 0x1e64, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e5d,
+	0x1e69, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e6e, 0x1e5d,
+	0x1e5d, 0x1e5d, 0x1e5d, 0x1e5d, 0x1e73, 0x080c, 0x0db2, 0xa07c,
+	0x9422, 0xa080, 0x931b, 0x0098, 0xa094, 0x9422, 0xa098, 0x931b,
+	0x0070, 0xa0ac, 0x9422, 0xa0b0, 0x931b, 0x0048, 0xa0c4, 0x9422,
+	0xa0c8, 0x931b, 0x0020, 0xa0dc, 0x9422, 0xa0e0, 0x931b, 0x0630,
+	0x2300, 0x9405, 0x0160, 0x8a51, 0x0904, 0x1f99, 0x8c60, 0x0804,
+	0x1de9, 0xa004, 0x9045, 0x0904, 0x1f99, 0x0804, 0x1dcc, 0x8a51,
+	0x0904, 0x1f99, 0x8c60, 0x2c05, 0x9005, 0x1158, 0xa004, 0x9045,
+	0x0904, 0x1f99, 0xa064, 0x90ec, 0x000f, 0x9de0, 0x1da2, 0x2c05,
+	0x2060, 0xa880, 0xc0fc, 0xa882, 0x0804, 0x1f8e, 0x2c05, 0x8422,
+	0x8420, 0x831a, 0x9399, 0x0000, 0xac2e, 0xab32, 0xdd9c, 0x1904,
+	0x1f2b, 0x9082, 0x001b, 0x0002, 0x1ec7, 0x1ec7, 0x1ec9, 0x1ec7,
+	0x1ec7, 0x1ec7, 0x1ed7, 0x1ec7, 0x1ec7, 0x1ec7, 0x1ee5, 0x1ec7,
+	0x1ec7, 0x1ec7, 0x1ef3, 0x1ec7, 0x1ec7, 0x1ec7, 0x1f01, 0x1ec7,
+	0x1ec7, 0x1ec7, 0x1f0f, 0x1ec7, 0x1ec7, 0x1ec7, 0x1f1d, 0x080c,
+	0x0db2, 0xa17c, 0x2400, 0x9122, 0xa180, 0x2300, 0x911b, 0x0a0c,
+	0x0db2, 0xa074, 0x9420, 0xa078, 0x9319, 0x0804, 0x1f89, 0xa18c,
+	0x2400, 0x9122, 0xa190, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa084,
+	0x9420, 0xa088, 0x9319, 0x0804, 0x1f89, 0xa19c, 0x2400, 0x9122,
+	0xa1a0, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa094, 0x9420, 0xa098,
+	0x9319, 0x0804, 0x1f89, 0xa1ac, 0x2400, 0x9122, 0xa1b0, 0x2300,
+	0x911b, 0x0a0c, 0x0db2, 0xa0a4, 0x9420, 0xa0a8, 0x9319, 0x0804,
+	0x1f89, 0xa1bc, 0x2400, 0x9122, 0xa1c0, 0x2300, 0x911b, 0x0a0c,
+	0x0db2, 0xa0b4, 0x9420, 0xa0b8, 0x9319, 0x0804, 0x1f89, 0xa1cc,
+	0x2400, 0x9122, 0xa1d0, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa0c4,
+	0x9420, 0xa0c8, 0x9319, 0x0804, 0x1f89, 0xa1dc, 0x2400, 0x9122,
+	0xa1e0, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa0d4, 0x9420, 0xa0d8,
+	0x9319, 0x0804, 0x1f89, 0x9082, 0x001b, 0x0002, 0x1f49, 0x1f47,
+	0x1f47, 0x1f47, 0x1f47, 0x1f47, 0x1f56, 0x1f47, 0x1f47, 0x1f47,
+	0x1f47, 0x1f47, 0x1f63, 0x1f47, 0x1f47, 0x1f47, 0x1f47, 0x1f47,
+	0x1f70, 0x1f47, 0x1f47, 0x1f47, 0x1f47, 0x1f47, 0x1f7d, 0x080c,
+	0x0db2, 0xa17c, 0x2400, 0x9122, 0xa180, 0x2300, 0x911b, 0x0a0c,
+	0x0db2, 0xa06c, 0x9420, 0xa070, 0x9319, 0x0498, 0xa194, 0x2400,
+	0x9122, 0xa198, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa084, 0x9420,
+	0xa088, 0x9319, 0x0430, 0xa1ac, 0x2400, 0x9122, 0xa1b0, 0x2300,
+	0x911b, 0x0a0c, 0x0db2, 0xa09c, 0x9420, 0xa0a0, 0x9319, 0x00c8,
+	0xa1c4, 0x2400, 0x9122, 0xa1c8, 0x2300, 0x911b, 0x0a0c, 0x0db2,
+	0xa0b4, 0x9420, 0xa0b8, 0x9319, 0x0060, 0xa1dc, 0x2400, 0x9122,
+	0xa1e0, 0x2300, 0x911b, 0x0a0c, 0x0db2, 0xa0cc, 0x9420, 0xa0d0,
+	0x9319, 0xac1e, 0xab22, 0xa880, 0xc0fd, 0xa882, 0x2800, 0xa85a,
+	0x2c00, 0xa812, 0x2a00, 0xa816, 0x000e, 0x000e, 0x000e, 0x9006,
+	0x0028, 0x008e, 0x00de, 0x00ce, 0x9085, 0x0001, 0x0005, 0x2001,
+	0x0005, 0x2004, 0x9084, 0x0007, 0x0002, 0x1fb7, 0x1be4, 0x1fb7,
+	0x1fad, 0x1fb0, 0x1fb3, 0x1fb0, 0x1fb3, 0x080c, 0x1be4, 0x0005,
+	0x080c, 0x116f, 0x0005, 0x080c, 0x1be4, 0x080c, 0x116f, 0x0005,
+	0x0126, 0x2091, 0x2600, 0x2079, 0x0200, 0x2071, 0x0260, 0x2069,
+	0x1800, 0x7817, 0x0000, 0x789b, 0x0814, 0x78a3, 0x0406, 0x789f,
+	0x0410, 0x2009, 0x013b, 0x200b, 0x0400, 0x781b, 0x0002, 0x783b,
+	0x001f, 0x7837, 0x0020, 0x7803, 0x1600, 0x012e, 0x0005, 0x2091,
+	0x2600, 0x781c, 0xd0a4, 0x190c, 0x20d6, 0x7900, 0xd1dc, 0x1118,
+	0x9084, 0x0006, 0x001a, 0x9084, 0x000e, 0x0002, 0x1ffe, 0x1ff6,
+	0x7597, 0x1ff6, 0x1ff8, 0x1ff8, 0x1ff8, 0x1ff8, 0x757d, 0x1ff6,
+	0x1ffa, 0x1ff6, 0x1ff8, 0x1ff6, 0x1ff8, 0x1ff6, 0x080c, 0x0db2,
+	0x0031, 0x0020, 0x080c, 0x757d, 0x080c, 0x7597, 0x0005, 0x0006,
+	0x0016, 0x0026, 0x080c, 0xd364, 0x7930, 0x9184, 0x0003, 0x01c0,
+	0x2001, 0x19c5, 0x2004, 0x9005, 0x0170, 0x2001, 0x0133, 0x2004,
+	0x9005, 0x090c, 0x0db2, 0x00c6, 0x2001, 0x19c5, 0x2064, 0x080c,
+	0xb251, 0x00ce, 0x00f8, 0x2009, 0x0040, 0x080c, 0x20d9, 0x00d0,
+	0x9184, 0x0014, 0x01a0, 0x6a00, 0x9286, 0x0003, 0x0160, 0x080c,
+	0x6c53, 0x1138, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x080c, 0x6b8a,
+	0x0010, 0x080c, 0x58e0, 0x080c, 0x7635, 0x0041, 0x0018, 0x9184,
+	0x9540, 0x1dc8, 0x002e, 0x001e, 0x000e, 0x0005, 0x00e6, 0x0036,
+	0x0046, 0x0056, 0x2071, 0x1a31, 0x080c, 0x1872, 0x005e, 0x004e,
+	0x003e, 0x00ee, 0x0005, 0x0126, 0x2091, 0x2e00, 0x2071, 0x1800,
+	0x7128, 0x2001, 0x1940, 0x2102, 0x2001, 0x1948, 0x2102, 0x2001,
+	0x013b, 0x2102, 0x2079, 0x0200, 0x2001, 0x0201, 0x789e, 0x78a3,
+	0x0200, 0x9198, 0x0007, 0x831c, 0x831c, 0x831c, 0x9398, 0x0005,
+	0x2320, 0x9182, 0x0204, 0x1230, 0x2011, 0x0008, 0x8423, 0x8423,
+	0x8423, 0x0488, 0x9182, 0x024c, 0x1240, 0x2011, 0x0007, 0x8403,
+	0x8003, 0x9400, 0x9400, 0x9420, 0x0430, 0x9182, 0x02bc, 0x1238,
+	0x2011, 0x0006, 0x8403, 0x8003, 0x9400, 0x9420, 0x00e0, 0x9182,
+	0x034c, 0x1230, 0x2011, 0x0005, 0x8403, 0x8003, 0x9420, 0x0098,
+	0x9182, 0x042c, 0x1228, 0x2011, 0x0004, 0x8423, 0x8423, 0x0058,
+	0x9182, 0x059c, 0x1228, 0x2011, 0x0003, 0x8403, 0x9420, 0x0018,
+	0x2011, 0x0002, 0x8423, 0x9482, 0x0228, 0x8002, 0x8020, 0x8301,
+	0x9402, 0x0110, 0x0208, 0x8321, 0x8217, 0x8203, 0x9405, 0x789a,
+	0x012e, 0x0005, 0x0006, 0x00d6, 0x2069, 0x0200, 0x6814, 0x9084,
+	0xffc0, 0x910d, 0x6916, 0x00de, 0x000e, 0x0005, 0x00d6, 0x2069,
+	0x0200, 0x9005, 0x6810, 0x0110, 0xc0a5, 0x0008, 0xc0a4, 0x6812,
+	0x00de, 0x0005, 0x0006, 0x00d6, 0x2069, 0x0200, 0x6810, 0x9084,
+	0xfff8, 0x910d, 0x6912, 0x00de, 0x000e, 0x0005, 0x7938, 0x080c,
+	0x0db2, 0x00f6, 0x2079, 0x0200, 0x7902, 0xa001, 0xa001, 0xa001,
+	0xa001, 0xa001, 0xa001, 0x7902, 0xa001, 0xa001, 0xa001, 0xa001,
+	0xa001, 0xa001, 0x00fe, 0x0005, 0x0126, 0x2091, 0x2800, 0x2061,
+	0x0100, 0x2071, 0x1800, 0x2009, 0x0000, 0x080c, 0x28d6, 0x080c,
+	0x27f1, 0x6054, 0x8004, 0x8004, 0x8004, 0x8004, 0x9084, 0x000c,
+	0x6150, 0x918c, 0xfff3, 0x9105, 0x6052, 0x6050, 0x9084, 0xb17f,
+	0x9085, 0x2000, 0x6052, 0x2009, 0x196c, 0x2011, 0x196d, 0x6358,
+	0x939c, 0x38f0, 0x2320, 0x080c, 0x2835, 0x1238, 0x939d, 0x4003,
+	0x94a5, 0x8603, 0x230a, 0x2412, 0x0030, 0x939d, 0x0203, 0x94a5,
+	0x8603, 0x230a, 0x2412, 0x9006, 0x080c, 0x2820, 0x9006, 0x080c,
+	0x2803, 0x20a9, 0x0012, 0x1d04, 0x212b, 0x2091, 0x6000, 0x1f04,
+	0x212b, 0x602f, 0x0100, 0x602f, 0x0000, 0x6050, 0x9085, 0x0400,
+	0x9084, 0xdfff, 0x6052, 0x6024, 0x6026, 0x080c, 0x250f, 0x2009,
+	0x00ef, 0x6132, 0x6136, 0x080c, 0x251f, 0x60e7, 0x0000, 0x61ea,
+	0x60e3, 0x0008, 0x604b, 0xf7f7, 0x6043, 0x0000, 0x602f, 0x0080,
+	0x602f, 0x0000, 0x6007, 0x049f, 0x60bb, 0x0000, 0x20a9, 0x0018,
+	0x60bf, 0x0000, 0x1f04, 0x2158, 0x60bb, 0x0000, 0x60bf, 0x0108,
+	0x60bf, 0x0012, 0x60bf, 0x0320, 0x60bf, 0x0018, 0x601b, 0x00f0,
+	0x601f, 0x001e, 0x600f, 0x006b, 0x602b, 0x402f, 0x012e, 0x0005,
+	0x00f6, 0x2079, 0x0140, 0x78c3, 0x0080, 0x78c3, 0x0083, 0x78c3,
+	0x0000, 0x00fe, 0x0005, 0x2001, 0x1833, 0x2003, 0x0000, 0x2001,
+	0x1832, 0x2003, 0x0001, 0x0005, 0x0126, 0x2091, 0x2800, 0x0006,
+	0x0016, 0x0026, 0x6124, 0x9184, 0x5e2c, 0x1118, 0x9184, 0x0007,
+	0x002a, 0x9195, 0x0004, 0x9284, 0x0007, 0x0002, 0x21b8, 0x219e,
+	0x21a1, 0x21a4, 0x21a9, 0x21ab, 0x21af, 0x21b3, 0x080c, 0x7eec,
+	0x00b8, 0x080c, 0x7fb9, 0x00a0, 0x080c, 0x7fb9, 0x080c, 0x7eec,
+	0x0078, 0x0099, 0x0068, 0x080c, 0x7eec, 0x0079, 0x0048, 0x080c,
+	0x7fb9, 0x0059, 0x0028, 0x080c, 0x7fb9, 0x080c, 0x7eec, 0x0029,
+	0x002e, 0x001e, 0x000e, 0x012e, 0x0005, 0x00a6, 0x6124, 0x6028,
+	0xd09c, 0x0118, 0xd19c, 0x1904, 0x2408, 0xd1f4, 0x0110, 0x080c,
+	0x0db2, 0x080c, 0x6c53, 0x0904, 0x2214, 0x080c, 0xbcec, 0x1120,
+	0x7000, 0x9086, 0x0003, 0x0570, 0x6024, 0x9084, 0x1800, 0x0550,
+	0x080c, 0x6c76, 0x0118, 0x080c, 0x6c64, 0x1520, 0x6027, 0x0020,
+	0x6043, 0x0000, 0x080c, 0xbcec, 0x0168, 0x080c, 0x6c76, 0x1150,
+	0x2001, 0x1976, 0x2003, 0x0001, 0x6027, 0x1800, 0x080c, 0x6ad9,
+	0x0804, 0x240b, 0x709c, 0x9005, 0x1150, 0x709f, 0x0001, 0x00d6,
+	0x2069, 0x0140, 0x080c, 0x6caa, 0x00de, 0x1904, 0x240b, 0x080c,
+	0x6f34, 0x0428, 0x080c, 0x6c76, 0x1590, 0x6024, 0x9084, 0x1800,
+	0x1108, 0x0468, 0x080c, 0x6f34, 0x080c, 0x6f2a, 0x080c, 0x5a21,
+	0x080c, 0x6b8a, 0x0804, 0x2408, 0xd1ac, 0x1508, 0x6024, 0xd0dc,
+	0x1170, 0xd0e4, 0x1178, 0xd0d4, 0x1190, 0xd0cc, 0x0130, 0x7090,
+	0x9086, 0x0028, 0x1110, 0x080c, 0x6e17, 0x0804, 0x2408, 0x080c,
+	0x6f2f, 0x0048, 0x2001, 0x194e, 0x2003, 0x0002, 0x0020, 0x080c,
+	0x6d8d, 0x0804, 0x2408, 0x080c, 0x6eb2, 0x0804, 0x2408, 0xd1ac,
+	0x0904, 0x2329, 0x080c, 0x6c53, 0x11c0, 0x6027, 0x0020, 0x0006,
+	0x0026, 0x0036, 0x080c, 0x6c6d, 0x1158, 0x080c, 0x6f2a, 0x080c,
+	0x5a21, 0x080c, 0x6b8a, 0x003e, 0x002e, 0x000e, 0x00ae, 0x0005,
+	0x003e, 0x002e, 0x000e, 0x080c, 0x6c2d, 0x0016, 0x0046, 0x00c6,
+	0x644c, 0x9486, 0xf0f0, 0x1138, 0x2061, 0x0100, 0x644a, 0x6043,
+	0x0090, 0x6043, 0x0010, 0x74d2, 0x948c, 0xff00, 0x7034, 0xd084,
+	0x0178, 0x9186, 0xf800, 0x1160, 0x7040, 0xd084, 0x1148, 0xc085,
+	0x7042, 0x0036, 0x2418, 0x2011, 0x8016, 0x080c, 0x4672, 0x003e,
+	0x080c, 0xbce5, 0x1904, 0x2306, 0x9196, 0xff00, 0x05a8, 0x7058,
+	0x9084, 0x00ff, 0x810f, 0x81ff, 0x0110, 0x9116, 0x0568, 0x7130,
+	0xd184, 0x1550, 0x080c, 0x2f86, 0x0128, 0xc18d, 0x7132, 0x080c,
+	0x629c, 0x1510, 0x6240, 0x9294, 0x0010, 0x0130, 0x6248, 0x9294,
+	0xff00, 0x9296, 0xff00, 0x01c0, 0x7030, 0xd08c, 0x0904, 0x2306,
+	0x7034, 0xd08c, 0x1140, 0x2001, 0x180c, 0x200c, 0xd1ac, 0x1904,
+	0x2306, 0xc1ad, 0x2102, 0x0036, 0x73d0, 0x2011, 0x8013, 0x080c,
+	0x4672, 0x003e, 0x0804, 0x2306, 0x7034, 0xd08c, 0x1140, 0x2001,
+	0x180c, 0x200c, 0xd1ac, 0x1904, 0x2306, 0xc1ad, 0x2102, 0x0036,
+	0x73d0, 0x2011, 0x8013, 0x080c, 0x4672, 0x003e, 0x7130, 0xc185,
+	0x7132, 0x2011, 0x1854, 0x220c, 0xd1a4, 0x01f0, 0x0016, 0x2009,
+	0x0001, 0x2011, 0x0100, 0x080c, 0x7e3e, 0x2019, 0x000e, 0x00c6,
+	0x2061, 0x0000, 0x080c, 0xcf62, 0x00ce, 0x9484, 0x00ff, 0x9080,
+	0x2f92, 0x200d, 0x918c, 0xff00, 0x810f, 0x2120, 0x9006, 0x2009,
+	0x000e, 0x080c, 0xcfe6, 0x001e, 0xd1ac, 0x1148, 0x0016, 0x2009,
+	0x0002, 0x2019, 0x0004, 0x080c, 0x2dfb, 0x001e, 0x0078, 0x0156,
+	0x00b6, 0x20a9, 0x007f, 0x900e, 0x080c, 0x5f7e, 0x1110, 0x080c,
+	0x5a3b, 0x8108, 0x1f04, 0x22fc, 0x00be, 0x015e, 0x00ce, 0x004e,
+	0x080c, 0x9947, 0x60e3, 0x0000, 0x001e, 0x2001, 0x1800, 0x2014,
+	0x9296, 0x0004, 0x1170, 0xd19c, 0x11a0, 0x2011, 0x180c, 0x2214,
+	0xd29c, 0x1120, 0x6204, 0x9295, 0x0002, 0x6206, 0x6228, 0xc29d,
+	0x622a, 0x2003, 0x0001, 0x2001, 0x1824, 0x2003, 0x0000, 0x6027,
+	0x0020, 0xd194, 0x0904, 0x2408, 0x0016, 0x6220, 0xd2b4, 0x0904,
+	0x23b1, 0x080c, 0x7cc7, 0x080c, 0x8fbb, 0x6027, 0x0004, 0x00f6,
+	0x2019, 0x19bf, 0x2304, 0x907d, 0x0904, 0x2380, 0x7804, 0x9086,
+	0x0032, 0x15f0, 0x00d6, 0x00c6, 0x00e6, 0x0096, 0x2069, 0x0140,
+	0x782c, 0x685e, 0x7808, 0x685a, 0x6043, 0x0002, 0x2001, 0x0003,
+	0x8001, 0x1df0, 0x6043, 0x0000, 0x2001, 0x003c, 0x8001, 0x1df0,
+	0x080c, 0x2997, 0x2001, 0x001e, 0x8001, 0x0240, 0x20a9, 0x0009,
+	0x080c, 0x28b1, 0x6904, 0xd1dc, 0x1140, 0x0cb0, 0x2001, 0x0100,
+	0x080c, 0x2987, 0x9006, 0x080c, 0x2987, 0x080c, 0x847d, 0x080c,
+	0x8582, 0x7814, 0x2048, 0xa867, 0x0103, 0x2f60, 0x080c, 0x99d6,
+	0x009e, 0x00ee, 0x00ce, 0x00de, 0x00fe, 0x001e, 0x00ae, 0x0005,
+	0x00fe, 0x00d6, 0x2069, 0x0140, 0x6804, 0x9084, 0x4000, 0x0110,
+	0x080c, 0x2997, 0x00de, 0x00c6, 0x2061, 0x19b6, 0x6028, 0x080c,
+	0xbcec, 0x0120, 0x909a, 0x0003, 0x1258, 0x0018, 0x909a, 0x00c8,
+	0x1238, 0x8000, 0x602a, 0x00ce, 0x080c, 0x8f97, 0x0804, 0x2407,
+	0x2061, 0x0100, 0x62c0, 0x080c, 0x97d2, 0x2019, 0x19bf, 0x2304,
+	0x9065, 0x0120, 0x2009, 0x0027, 0x080c, 0x9a50, 0x00ce, 0x0804,
+	0x2407, 0xd2bc, 0x0904, 0x23f4, 0x080c, 0x7cd4, 0x6014, 0x9084,
+	0x1984, 0x9085, 0x0010, 0x6016, 0x6027, 0x0004, 0x00d6, 0x2069,
+	0x0140, 0x6804, 0x9084, 0x4000, 0x0110, 0x080c, 0x2997, 0x00de,
+	0x00c6, 0x2061, 0x19b6, 0x6044, 0x080c, 0xbcec, 0x0120, 0x909a,
+	0x0003, 0x1628, 0x0018, 0x909a, 0x00c8, 0x1608, 0x8000, 0x6046,
+	0x603c, 0x00ce, 0x9005, 0x0558, 0x2009, 0x07d0, 0x080c, 0x7ccc,
+	0x9080, 0x0008, 0x2004, 0x9086, 0x0006, 0x1138, 0x6114, 0x918c,
+	0x1984, 0x918d, 0x0012, 0x6116, 0x00d0, 0x6114, 0x918c, 0x1984,
+	0x918d, 0x0016, 0x6116, 0x0098, 0x6027, 0x0004, 0x0080, 0x0036,
+	0x2019, 0x0001, 0x080c, 0x9254, 0x003e, 0x2019, 0x19c5, 0x2304,
+	0x9065, 0x0120, 0x2009, 0x004f, 0x080c, 0x9a50, 0x00ce, 0x001e,
+	0xd19c, 0x0904, 0x247a, 0x7034, 0xd0ac, 0x1904, 0x244f, 0x0016,
+	0x0156, 0x6027, 0x0008, 0x6050, 0x9085, 0x0040, 0x6052, 0x6050,
+	0x9084, 0xfbcf, 0x6052, 0x080c, 0x28d0, 0x9085, 0x2000, 0x6052,
+	0x20a9, 0x0012, 0x1d04, 0x2422, 0x080c, 0x7cfb, 0x1f04, 0x2422,
+	0x6050, 0x9085, 0x0400, 0x9084, 0xdfbf, 0x6052, 0x20a9, 0x0028,
+	0xa001, 0x1f04, 0x2430, 0x6150, 0x9185, 0x1400, 0x6052, 0x20a9,
+	0x0366, 0x1d04, 0x2439, 0x080c, 0x7cfb, 0x6020, 0xd09c, 0x1130,
+	0x015e, 0x6152, 0x001e, 0x6027, 0x0008, 0x04a0, 0x080c, 0x2898,
+	0x1f04, 0x2439, 0x015e, 0x6152, 0x001e, 0x6027, 0x0008, 0x0016,
+	0x6028, 0xc09c, 0x602a, 0x080c, 0x9947, 0x60e3, 0x0000, 0x080c,
+	0xd343, 0x080c, 0xd35e, 0x080c, 0x5117, 0xd0fc, 0x1138, 0x080c,
+	0xbce5, 0x1120, 0x9085, 0x0001, 0x080c, 0x6c9a, 0x9006, 0x080c,
+	0x2987, 0x2009, 0x0002, 0x080c, 0x28d6, 0x00e6, 0x2071, 0x1800,
+	0x7003, 0x0004, 0x080c, 0x0e69, 0x00ee, 0x6027, 0x0008, 0x080c,
+	0x0b94, 0x001e, 0x918c, 0xffd0, 0x6126, 0x00ae, 0x0005, 0x0006,
+	0x0016, 0x0026, 0x0036, 0x00e6, 0x00f6, 0x0126, 0x2091, 0x8000,
+	0x2071, 0x1800, 0x71c8, 0x70ca, 0x9116, 0x0904, 0x24ce, 0x81ff,
+	0x01a0, 0x2009, 0x0000, 0x080c, 0x28d6, 0x2011, 0x8011, 0x2019,
+	0x010e, 0x231c, 0x939e, 0x0007, 0x1118, 0x2019, 0x0001, 0x0010,
+	0x2019, 0x0000, 0x080c, 0x4672, 0x0448, 0x2001, 0x1977, 0x200c,
+	0x81ff, 0x1140, 0x2001, 0x0109, 0x2004, 0xd0b4, 0x0118, 0x2019,
+	0x0003, 0x0008, 0x2118, 0x2011, 0x8012, 0x080c, 0x4672, 0x080c,
+	0x0e69, 0x080c, 0x5117, 0xd0fc, 0x1188, 0x080c, 0xbce5, 0x1170,
+	0x00c6, 0x080c, 0x256a, 0x080c, 0x91bb, 0x2061, 0x0100, 0x2019,
+	0x0028, 0x2009, 0x0002, 0x080c, 0x2dfb, 0x00ce, 0x012e, 0x00fe,
+	0x00ee, 0x003e, 0x002e, 0x001e, 0x000e, 0x0005, 0x2028, 0x918c,
+	0x00ff, 0x2130, 0x9094, 0xff00, 0x11f0, 0x2011, 0x1835, 0x2214,
+	0xd2ac, 0x11c8, 0x81ff, 0x01e8, 0x2011, 0x181d, 0x2204, 0x9106,
+	0x1190, 0x2011, 0x181e, 0x2214, 0x9294, 0xff00, 0x9584, 0xff00,
+	0x9206, 0x1148, 0x2011, 0x181e, 0x2214, 0x9294, 0x00ff, 0x9584,
+	0x00ff, 0x9206, 0x1120, 0x2500, 0x080c, 0x7876, 0x0048, 0x9584,
+	0x00ff, 0x9080, 0x2f92, 0x200d, 0x918c, 0xff00, 0x810f, 0x9006,
+	0x0005, 0x9080, 0x2f92, 0x200d, 0x918c, 0x00ff, 0x0005, 0x00d6,
+	0x2069, 0x0140, 0x2001, 0x1816, 0x2003, 0x00ef, 0x20a9, 0x0010,
+	0x9006, 0x6852, 0x6856, 0x1f04, 0x251a, 0x00de, 0x0005, 0x0006,
+	0x00d6, 0x0026, 0x2069, 0x0140, 0x2001, 0x1816, 0x2102, 0x8114,
+	0x8214, 0x8214, 0x8214, 0x20a9, 0x0010, 0x6853, 0x0000, 0x9006,
+	0x82ff, 0x1128, 0x9184, 0x000f, 0x9080, 0xd74a, 0x2005, 0x6856,
+	0x8211, 0x1f04, 0x252f, 0x002e, 0x00de, 0x000e, 0x0005, 0x00c6,
+	0x2061, 0x1800, 0x6030, 0x0110, 0xc09d, 0x0008, 0xc09c, 0x6032,
+	0x00ce, 0x0005, 0x0156, 0x00d6, 0x0026, 0x0016, 0x0006, 0x2069,
+	0x0140, 0x6980, 0x9116, 0x0180, 0x9112, 0x1230, 0x8212, 0x8210,
+	0x22a8, 0x2001, 0x0402, 0x0018, 0x22a8, 0x2001, 0x0404, 0x680e,
+	0x1f04, 0x255f, 0x680f, 0x0000, 0x000e, 0x001e, 0x002e, 0x00de,
+	0x015e, 0x0005, 0x080c, 0x5113, 0xd0c4, 0x0150, 0xd0a4, 0x0140,
+	0x9006, 0x0046, 0x2020, 0x2009, 0x002e, 0x080c, 0xcfe6, 0x004e,
+	0x0005, 0x00f6, 0x0016, 0x0026, 0x2079, 0x0140, 0x78c4, 0xd0dc,
+	0x0904, 0x25d6, 0x080c, 0x2835, 0x0660, 0x9084, 0x0700, 0x908e,
+	0x0600, 0x1120, 0x2011, 0x4000, 0x900e, 0x0458, 0x908e, 0x0500,
+	0x1120, 0x2011, 0x8000, 0x900e, 0x0420, 0x908e, 0x0400, 0x1120,
+	0x9016, 0x2009, 0x0001, 0x00e8, 0x908e, 0x0300, 0x1120, 0x9016,
+	0x2009, 0x0002, 0x00b0, 0x908e, 0x0200, 0x1120, 0x9016, 0x2009,
+	0x0004, 0x0078, 0x908e, 0x0100, 0x1548, 0x9016, 0x2009, 0x0008,
+	0x0040, 0x9084, 0x0700, 0x908e, 0x0300, 0x1500, 0x2011, 0x0030,
+	0x0058, 0x2300, 0x9080, 0x0020, 0x2018, 0x080c, 0x7e7f, 0x928c,
+	0xff00, 0x0110, 0x2011, 0x00ff, 0x2200, 0x8007, 0x9085, 0x004c,
+	0x78c2, 0x2009, 0x0138, 0x220a, 0x080c, 0x6c53, 0x1118, 0x2009,
+	0x193e, 0x220a, 0x002e, 0x001e, 0x00fe, 0x0005, 0x78c3, 0x0000,
+	0x0cc8, 0x0126, 0x2091, 0x2800, 0x0006, 0x0016, 0x0026, 0x2001,
+	0x0170, 0x200c, 0x8000, 0x2014, 0x9184, 0x0003, 0x0110, 0x080c,
+	0x0db2, 0x002e, 0x001e, 0x000e, 0x012e, 0x0005, 0x2001, 0x0171,
+	0x2004, 0xd0dc, 0x0168, 0x2001, 0x0170, 0x200c, 0x918c, 0x00ff,
+	0x918e, 0x004c, 0x1128, 0x200c, 0x918c, 0xff00, 0x810f, 0x0005,
+	0x900e, 0x2001, 0x0227, 0x2004, 0x8007, 0x9084, 0x00ff, 0x8004,
+	0x9108, 0x2001, 0x0226, 0x2004, 0x8007, 0x9084, 0x00ff, 0x8004,
+	0x9108, 0x0005, 0x0018, 0x000c, 0x0018, 0x0020, 0x1000, 0x0800,
+	0x1000, 0x1800, 0x0156, 0x0006, 0x0016, 0x0026, 0x00e6, 0x2001,
+	0x195f, 0x2004, 0x908a, 0x0007, 0x1a0c, 0x0db2, 0x0033, 0x00ee,
+	0x002e, 0x001e, 0x000e, 0x015e, 0x0005, 0x2634, 0x2652, 0x2676,
+	0x2678, 0x26a1, 0x26a3, 0x26a5, 0x2001, 0x0001, 0x080c, 0x247f,
+	0x080c, 0x2893, 0x2001, 0x1961, 0x2003, 0x0000, 0x7828, 0x9084,
+	0xe1d7, 0x782a, 0x9006, 0x20a9, 0x0009, 0x080c, 0x2851, 0x2001,
+	0x195f, 0x2003, 0x0006, 0x2009, 0x001e, 0x2011, 0x26a6, 0x080c,
+	0x7cd9, 0x0005, 0x2009, 0x1964, 0x200b, 0x0000, 0x2001, 0x1969,
+	0x2003, 0x0036, 0x2001, 0x1968, 0x2003, 0x002a, 0x2001, 0x1961,
+	0x2003, 0x0001, 0x9006, 0x080c, 0x2803, 0x2001, 0xffff, 0x20a9,
+	0x0009, 0x080c, 0x2851, 0x2001, 0x195f, 0x2003, 0x0006, 0x2009,
+	0x001e, 0x2011, 0x26a6, 0x080c, 0x7cd9, 0x0005, 0x080c, 0x0db2,
+	0x2001, 0x1969, 0x2003, 0x0036, 0x2001, 0x1961, 0x2003, 0x0003,
+	0x7a38, 0x9294, 0x0005, 0x9296, 0x0004, 0x0110, 0x9006, 0x0010,
+	0x2001, 0x0001, 0x080c, 0x2803, 0x2001, 0x1965, 0x2003, 0x0000,
+	0x2001, 0xffff, 0x20a9, 0x0009, 0x080c, 0x2851, 0x2001, 0x195f,
+	0x2003, 0x0006, 0x2009, 0x001e, 0x2011, 0x26a6, 0x080c, 0x7cd9,
+	0x0005, 0x080c, 0x0db2, 0x080c, 0x0db2, 0x0005, 0x0006, 0x0016,
+	0x0026, 0x00e6, 0x00f6, 0x0156, 0x0126, 0x2091, 0x8000, 0x2079,
+	0x0100, 0x2001, 0x1961, 0x2004, 0x908a, 0x0007, 0x1a0c, 0x0db2,
+	0x0043, 0x012e, 0x015e, 0x00fe, 0x00ee, 0x002e, 0x001e, 0x000e,
+	0x0005, 0x26c8, 0x26e8, 0x2728, 0x2758, 0x277c, 0x278c, 0x278e,
+	0x080c, 0x2845, 0x11b0, 0x7850, 0x9084, 0xefff, 0x7852, 0x2009,
+	0x1967, 0x2104, 0x7a38, 0x9294, 0x0005, 0x9296, 0x0004, 0x0110,
+	0xc08d, 0x0008, 0xc085, 0x200a, 0x2001, 0x195f, 0x2003, 0x0001,
+	0x0030, 0x080c, 0x27b2, 0x2001, 0xffff, 0x080c, 0x2643, 0x0005,
+	0x080c, 0x2790, 0x05e0, 0x2009, 0x1968, 0x2104, 0x8001, 0x200a,
+	0x080c, 0x2845, 0x1178, 0x7850, 0x9084, 0xefff, 0x7852, 0x7a38,
+	0x9294, 0x0005, 0x9296, 0x0005, 0x0518, 0x2009, 0x1967, 0x2104,
+	0xc085, 0x200a, 0x2009, 0x1964, 0x2104, 0x8000, 0x200a, 0x9086,
+	0x0005, 0x0118, 0x080c, 0x2798, 0x00c0, 0x200b, 0x0000, 0x7a38,
+	0x9294, 0x0006, 0x9296, 0x0004, 0x0110, 0x9006, 0x0010, 0x2001,
+	0x0001, 0x080c, 0x2820, 0x2001, 0x1961, 0x2003, 0x0002, 0x0028,
+	0x2001, 0x195f, 0x2003, 0x0003, 0x0010, 0x080c, 0x2665, 0x0005,
+	0x080c, 0x2790, 0x0560, 0x2009, 0x1968, 0x2104, 0x8001, 0x200a,
+	0x080c, 0x2845, 0x1168, 0x7850, 0x9084, 0xefff, 0x7852, 0x2001,
+	0x195f, 0x2003, 0x0003, 0x2001, 0x1960, 0x2003, 0x0000, 0x00b8,
+	0x2009, 0x1968, 0x2104, 0x9005, 0x1118, 0x080c, 0x27d5, 0x0010,
+	0x080c, 0x27a5, 0x080c, 0x2798, 0x2009, 0x1964, 0x200b, 0x0000,
+	0x2001, 0x1961, 0x2003, 0x0001, 0x080c, 0x2665, 0x0000, 0x0005,
+	0x04b9, 0x0508, 0x080c, 0x2845, 0x11b8, 0x7850, 0x9084, 0xefff,
+	0x7852, 0x2009, 0x1965, 0x2104, 0x8000, 0x200a, 0x9086, 0x0007,
+	0x0108, 0x0078, 0x2001, 0x196a, 0x2003, 0x000a, 0x2009, 0x1967,
+	0x2104, 0xc0fd, 0x200a, 0x0038, 0x0419, 0x2001, 0x1961, 0x2003,
+	0x0004, 0x080c, 0x2690, 0x0005, 0x0099, 0x0168, 0x080c, 0x2845,
+	0x1138, 0x7850, 0x9084, 0xefff, 0x7852, 0x080c, 0x267c, 0x0018,
+	0x0079, 0x080c, 0x2690, 0x0005, 0x080c, 0x0db2, 0x080c, 0x0db2,
+	0x2009, 0x1969, 0x2104, 0x8001, 0x200a, 0x090c, 0x27f1, 0x0005,
+	0x7a38, 0x9294, 0x0005, 0x9296, 0x0005, 0x0110, 0x9006, 0x0010,
+	0x2001, 0x0001, 0x080c, 0x2820, 0x0005, 0x7a38, 0x9294, 0x0006,
+	0x9296, 0x0006, 0x0110, 0x9006, 0x0010, 0x2001, 0x0001, 0x080c,
+	0x2803, 0x0005, 0x2009, 0x1964, 0x2104, 0x8000, 0x200a, 0x9086,
+	0x0005, 0x0108, 0x0068, 0x200b, 0x0000, 0x7a38, 0x9294, 0x0006,
+	0x9296, 0x0006, 0x0110, 0x9006, 0x0010, 0x2001, 0x0001, 0x04d9,
+	0x7a38, 0x9294, 0x0005, 0x9296, 0x0005, 0x0110, 0x9006, 0x0010,
+	0x2001, 0x0001, 0x080c, 0x2820, 0x0005, 0x0086, 0x2001, 0x1967,
+	0x2004, 0x9084, 0x7fff, 0x090c, 0x0db2, 0x2009, 0x1966, 0x2144,
+	0x8846, 0x280a, 0x9844, 0x0dd8, 0xd08c, 0x1120, 0xd084, 0x1120,
+	0x080c, 0x0db2, 0x9006, 0x0010, 0x2001, 0x0001, 0x00a1, 0x008e,
+	0x0005, 0x0006, 0x0156, 0x2001, 0x195f, 0x20a9, 0x0009, 0x2003,
+	0x0000, 0x8000, 0x1f04, 0x27f7, 0x2001, 0x1966, 0x2003, 0x8000,
+	0x015e, 0x000e, 0x0005, 0x00f6, 0x2079, 0x0100, 0x9085, 0x0000,
+	0x0158, 0x7838, 0x9084, 0xfff9, 0x9085, 0x0004, 0x783a, 0x2009,
+	0x196c, 0x210c, 0x795a, 0x0050, 0x7838, 0x9084, 0xfffb, 0x9085,
+	0x0006, 0x783a, 0x2009, 0x196d, 0x210c, 0x795a, 0x00fe, 0x0005,
+	0x00f6, 0x2079, 0x0100, 0x9085, 0x0000, 0x0138, 0x7838, 0x9084,
+	0xfffa, 0x9085, 0x0004, 0x783a, 0x0030, 0x7838, 0x9084, 0xfffb,
+	0x9085, 0x0005, 0x783a, 0x00fe, 0x0005, 0x0006, 0x2001, 0x0100,
+	0x2004, 0x9082, 0x0007, 0x000e, 0x0005, 0x0006, 0x2001, 0x0100,
+	0x2004, 0x9082, 0x0009, 0x000e, 0x0005, 0x0156, 0x20a9, 0x0064,
+	0x7820, 0x080c, 0x28d0, 0xd09c, 0x1110, 0x1f04, 0x2848, 0x015e,
+	0x0005, 0x0126, 0x0016, 0x0006, 0x2091, 0x8000, 0x7850, 0x9085,
+	0x0040, 0x7852, 0x7850, 0x9084, 0xfbcf, 0x7852, 0x080c, 0x28d0,
+	0x9085, 0x2000, 0x7852, 0x000e, 0x2008, 0x9186, 0x0000, 0x1118,
+	0x783b, 0x0007, 0x0090, 0x9186, 0x0001, 0x1118, 0x783b, 0x0006,
+	0x0060, 0x9186, 0x0002, 0x1118, 0x783b, 0x0005, 0x0030, 0x9186,
+	0x0003, 0x1118, 0x783b, 0x0004, 0x0000, 0x0006, 0x1d04, 0x287e,
+	0x080c, 0x7cfb, 0x1f04, 0x287e, 0x7850, 0x9085, 0x0400, 0x9084,
+	0xdfbf, 0x7852, 0x080c, 0x28d0, 0x9085, 0x1000, 0x7852, 0x000e,
+	0x001e, 0x012e, 0x0005, 0x7850, 0x9084, 0xffcf, 0x7852, 0x0005,
+	0x0006, 0x0156, 0x00f6, 0x2079, 0x0100, 0x20a9, 0x000a, 0x7854,
+	0xd0ac, 0x1130, 0x7820, 0xd0e4, 0x1140, 0x1f04, 0x28a2, 0x0028,
+	0x7854, 0xd08c, 0x1110, 0x1f04, 0x28a8, 0x00fe, 0x015e, 0x000e,
+	0x0005, 0x1d04, 0x28b1, 0x080c, 0x7cfb, 0x1f04, 0x28b1, 0x0005,
+	0x0006, 0x2001, 0x196b, 0x2004, 0x9086, 0x0000, 0x000e, 0x0005,
+	0x0006, 0x2001, 0x196b, 0x2004, 0x9086, 0x0001, 0x000e, 0x0005,
+	0x0006, 0x2001, 0x196b, 0x2004, 0x9086, 0x0002, 0x000e, 0x0005,
+	0xa001, 0xa001, 0xa001, 0xa001, 0xa001, 0x0005, 0x0006, 0x2001,
+	0x1977, 0x2102, 0x000e, 0x0005, 0x2009, 0x0171, 0x2104, 0xd0dc,
+	0x0140, 0x2009, 0x0170, 0x2104, 0x200b, 0x0080, 0xa001, 0xa001,
+	0x200a, 0x0005, 0x0036, 0x0046, 0x2001, 0x0141, 0x200c, 0x918c,
+	0xff00, 0x9186, 0x2000, 0x0118, 0x9186, 0x0100, 0x1588, 0x2009,
+	0x017f, 0x200b, 0x00a2, 0x2019, 0x0160, 0x2324, 0x2011, 0x0003,
+	0x2009, 0x0169, 0x2104, 0x9084, 0x0007, 0x210c, 0x918c, 0x0007,
+	0x910e, 0x1db0, 0x9086, 0x0003, 0x11b8, 0x2304, 0x9402, 0x02a0,
+	0x1d60, 0x8211, 0x1d68, 0x84ff, 0x0170, 0x2001, 0x0141, 0x200c,
+	0x918c, 0xff00, 0x9186, 0x0100, 0x0130, 0x2009, 0x180c, 0x2104,
+	0xc0dd, 0x200a, 0x0008, 0x0419, 0x2001, 0x017f, 0x2003, 0x0000,
+	0x004e, 0x003e, 0x0005, 0x2001, 0x180c, 0x2004, 0xd0dc, 0x01b0,
+	0x2001, 0x0160, 0x2004, 0x9005, 0x0140, 0x2001, 0x0141, 0x2004,
+	0x9084, 0xff00, 0x9086, 0x0100, 0x1148, 0x0126, 0x2091, 0x8000,
+	0x0016, 0x0026, 0x0021, 0x002e, 0x001e, 0x012e, 0x0005, 0x00c6,
+	0x2061, 0x0100, 0x6014, 0x0006, 0x2001, 0x0161, 0x2003, 0x0000,
+	0x6017, 0x0018, 0xa001, 0xa001, 0x602f, 0x0008, 0x6104, 0x918e,
+	0x0010, 0x6106, 0x918e, 0x0010, 0x6106, 0x6017, 0x0040, 0x04b9,
+	0x001e, 0x9184, 0x0003, 0x01e0, 0x0036, 0x0016, 0x2019, 0x0141,
+	0x6124, 0x918c, 0x0028, 0x1120, 0x2304, 0x9084, 0x2800, 0x0dc0,
+	0x001e, 0x919c, 0xffe4, 0x9184, 0x0001, 0x0118, 0x9385, 0x0009,
+	0x6016, 0x9184, 0x0002, 0x0118, 0x9385, 0x0012, 0x6016, 0x003e,
+	0x2001, 0x180c, 0x200c, 0xc1dc, 0x2102, 0x00ce, 0x0005, 0x0016,
+	0x0026, 0x080c, 0x6c6d, 0x0108, 0xc0bc, 0x2009, 0x0140, 0x2114,
+	0x9294, 0x0001, 0x9215, 0x220a, 0x002e, 0x001e, 0x0005, 0x0016,
+	0x0026, 0x2009, 0x0140, 0x2114, 0x9294, 0x0001, 0x9285, 0x1000,
+	0x200a, 0x220a, 0x002e, 0x001e, 0x0005, 0x0016, 0x0026, 0x2009,
+	0x0140, 0x2114, 0x9294, 0x0001, 0x9215, 0x220a, 0x002e, 0x001e,
+	0x0005, 0x0006, 0x0016, 0x2009, 0x0140, 0x2104, 0x1110, 0xc0bc,
+	0x0008, 0xc0bd, 0x200a, 0x001e, 0x000e, 0x0005, 0x2c2a, 0x2c2a,
+	0x2a4e, 0x2a4e, 0x2a5a, 0x2a5a, 0x2a66, 0x2a66, 0x2a74, 0x2a74,
+	0x2a80, 0x2a80, 0x2a8e, 0x2a8e, 0x2a9c, 0x2a9c, 0x2aae, 0x2aae,
+	0x2aba, 0x2aba, 0x2ac8, 0x2ac8, 0x2ae6, 0x2ae6, 0x2b06, 0x2b06,
+	0x2ad6, 0x2ad6, 0x2af6, 0x2af6, 0x2b14, 0x2b14, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2b26, 0x2b26,
+	0x2b32, 0x2b32, 0x2b40, 0x2b40, 0x2b4e, 0x2b4e, 0x2b5e, 0x2b5e,
+	0x2b6c, 0x2b6c, 0x2b7c, 0x2b7c, 0x2b8c, 0x2b8c, 0x2b9e, 0x2b9e,
+	0x2bac, 0x2bac, 0x2bbc, 0x2bbc, 0x2bde, 0x2bde, 0x2c00, 0x2c00,
+	0x2bcc, 0x2bcc, 0x2bef, 0x2bef, 0x2c0f, 0x2c0f, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac,
+	0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x2aac, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x2184,
+	0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x1f9f, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f,
+	0x080c, 0x2184, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1fd7, 0x0804, 0x2c22,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x2184, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f, 0x080c, 0x2184,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0xa001, 0x0cf0, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x12d6,
+	0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x2184, 0x080c, 0x12d6, 0x0804, 0x2c22,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x1f9f, 0x080c, 0x12d6, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x2184,
+	0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f,
+	0x080c, 0x2184, 0x080c, 0x12d6, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f,
+	0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x12d6,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x1f9f, 0x080c, 0x2184,
+	0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9,
+	0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136,
+	0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x2184, 0x0804, 0x2c22,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x25d9, 0x080c, 0x1f9f, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9,
+	0x080c, 0x1f9f, 0x080c, 0x2184, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x2184,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x1f9f,
+	0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x1f9f,
+	0x080c, 0x2184, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9,
+	0x080c, 0x12d6, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x2184,
+	0x080c, 0x12d6, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x1f9f,
+	0x080c, 0x12d6, 0x0804, 0x2c22, 0x0106, 0x0006, 0x0126, 0x01c6,
+	0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9, 0x080c, 0x2184,
+	0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0804, 0x2c22, 0x0106, 0x0006,
+	0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c, 0x25d9,
+	0x080c, 0x1f9f, 0x080c, 0x2184, 0x080c, 0x12d6, 0x0498, 0x0106,
+	0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c,
+	0x25d9, 0x080c, 0x1f9f, 0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0410,
+	0x0106, 0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156,
+	0x080c, 0x25d9, 0x080c, 0x12d6, 0x080c, 0x1fd7, 0x0098, 0x0106,
+	0x0006, 0x0126, 0x01c6, 0x01d6, 0x0136, 0x0146, 0x0156, 0x080c,
+	0x25d9, 0x080c, 0x1f9f, 0x080c, 0x2184, 0x080c, 0x12d6, 0x080c,
+	0x1fd7, 0x0000, 0x015e, 0x014e, 0x013e, 0x01de, 0x01ce, 0x012e,
+	0x000e, 0x010e, 0x000d, 0x00b6, 0x00c6, 0x0026, 0x0046, 0x9026,
+	0x080c, 0x6262, 0x1904, 0x2d17, 0x72d4, 0x2001, 0x194d, 0x2004,
+	0x9005, 0x1110, 0xd29c, 0x0148, 0xd284, 0x1138, 0xd2bc, 0x1904,
+	0x2d17, 0x080c, 0x2d1c, 0x0804, 0x2d17, 0xd2cc, 0x1904, 0x2d17,
+	0x080c, 0x6c53, 0x1120, 0x70a7, 0xffff, 0x0804, 0x2d17, 0xd294,
+	0x0120, 0x70a7, 0xffff, 0x0804, 0x2d17, 0x080c, 0x2f81, 0x0160,
+	0x080c, 0xbcec, 0x0128, 0x2001, 0x1816, 0x203c, 0x0804, 0x2cb5,
+	0x70a7, 0xffff, 0x0804, 0x2d17, 0x2001, 0x1816, 0x203c, 0x728c,
+	0xd284, 0x0904, 0x2cb5, 0xd28c, 0x1904, 0x2cb5, 0x0036, 0x73a4,
+	0x938e, 0xffff, 0x1110, 0x2019, 0x0001, 0x8314, 0x92e0, 0x1c80,
+	0x2c04, 0x938c, 0x0001, 0x0120, 0x9084, 0xff00, 0x8007, 0x0010,
+	0x9084, 0x00ff, 0x970e, 0x0540, 0x908e, 0x0000, 0x0528, 0x908e,
+	0x00ff, 0x1150, 0x7230, 0xd284, 0x1518, 0x728c, 0xc28d, 0x728e,
+	0x70a7, 0xffff, 0x003e, 0x0408, 0x900e, 0x080c, 0x24d6, 0x080c,
+	0x5f1e, 0x11a0, 0x080c, 0x62a4, 0x1150, 0x7030, 0xd08c, 0x0118,
+	0xb800, 0xd0bc, 0x0120, 0x080c, 0x2d35, 0x0140, 0x0028, 0x080c,
+	0x2e71, 0x080c, 0x2d61, 0x0110, 0x8318, 0x0838, 0x73a6, 0x0010,
+	0x70a7, 0xffff, 0x003e, 0x0804, 0x2d17, 0x9780, 0x2f92, 0x203d,
+	0x97bc, 0xff00, 0x873f, 0x2041, 0x007e, 0x70a4, 0x9096, 0xffff,
+	0x1118, 0x900e, 0x28a8, 0x0050, 0x9812, 0x0220, 0x2008, 0x9802,
+	0x20a8, 0x0020, 0x70a7, 0xffff, 0x0804, 0x2d17, 0x2700, 0x0156,
+	0x0016, 0x9106, 0x05c8, 0xc484, 0x080c, 0x5f7e, 0x0138, 0x080c,
+	0xbcec, 0x1590, 0x080c, 0x5f1e, 0x15b8, 0x0008, 0xc485, 0x080c,
+	0x62a4, 0x1130, 0x7030, 0xd08c, 0x01f8, 0xb800, 0xd0bc, 0x11e0,
+	0x728c, 0xd28c, 0x0180, 0x080c, 0x62a4, 0x9082, 0x0006, 0x02e0,
+	0xd484, 0x1118, 0x080c, 0x5f42, 0x0028, 0x080c, 0x2efd, 0x01a0,
+	0x080c, 0x2f28, 0x0088, 0x080c, 0x2e71, 0x080c, 0xbcec, 0x1160,
+	0x080c, 0x2d61, 0x0188, 0x0040, 0x080c, 0xbcec, 0x1118, 0x080c,
+	0x2efd, 0x0110, 0x0451, 0x0140, 0x001e, 0x8108, 0x015e, 0x1f04,
+	0x2cce, 0x70a7, 0xffff, 0x0018, 0x001e, 0x015e, 0x71a6, 0x004e,
+	0x002e, 0x00ce, 0x00be, 0x0005, 0x00c6, 0x0016, 0x70a7, 0x0001,
+	0x2009, 0x007e, 0x080c, 0x5f1e, 0x1168, 0xb813, 0x00ff, 0xb817,
+	0xfffe, 0x080c, 0x2e71, 0x04a9, 0x0128, 0x70d4, 0xc0bd, 0x70d6,
+	0x080c, 0xba40, 0x001e, 0x00ce, 0x0005, 0x0016, 0x0076, 0x00d6,
+	0x00c6, 0x2001, 0x1858, 0x2004, 0x9084, 0x00ff, 0xb842, 0x080c,
+	0x9a23, 0x01d0, 0x2b00, 0x6012, 0x080c, 0xba69, 0x6023, 0x0001,
+	0x9006, 0x080c, 0x5ebb, 0x2001, 0x0000, 0x080c, 0x5ecf, 0x0126,
+	0x2091, 0x8000, 0x70a0, 0x8000, 0x70a2, 0x012e, 0x2009, 0x0004,
+	0x080c, 0x9a50, 0x9085, 0x0001, 0x00ce, 0x00de, 0x007e, 0x001e,
+	0x0005, 0x0016, 0x0076, 0x00d6, 0x00c6, 0x2001, 0x1858, 0x2004,
+	0x9084, 0x00ff, 0xb842, 0x080c, 0x9a23, 0x0548, 0x2b00, 0x6012,
+	0xb800, 0xc0c4, 0xb802, 0xb8a0, 0x9086, 0x007e, 0x0140, 0xb804,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x1110, 0x080c, 0x2e30, 0x080c,
+	0xba69, 0x6023, 0x0001, 0x9006, 0x080c, 0x5ebb, 0x2001, 0x0002,
+	0x080c, 0x5ecf, 0x0126, 0x2091, 0x8000, 0x70a0, 0x8000, 0x70a2,
+	0x012e, 0x2009, 0x0002, 0x080c, 0x9a50, 0x9085, 0x0001, 0x00ce,
+	0x00de, 0x007e, 0x001e, 0x0005, 0x00b6, 0x00c6, 0x0026, 0x2009,
+	0x0080, 0x080c, 0x5f1e, 0x1140, 0xb813, 0x00ff, 0xb817, 0xfffc,
+	0x0039, 0x0110, 0x70db, 0xffff, 0x002e, 0x00ce, 0x00be, 0x0005,
+	0x0016, 0x0076, 0x00d6, 0x00c6, 0x080c, 0x9980, 0x01d0, 0x2b00,
+	0x6012, 0x080c, 0xba69, 0x6023, 0x0001, 0x9006, 0x080c, 0x5ebb,
+	0x2001, 0x0002, 0x080c, 0x5ecf, 0x0126, 0x2091, 0x8000, 0x70dc,
+	0x8000, 0x70de, 0x012e, 0x2009, 0x0002, 0x080c, 0x9a50, 0x9085,
+	0x0001, 0x00ce, 0x00de, 0x007e, 0x001e, 0x0005, 0x00c6, 0x00d6,
+	0x0126, 0x2091, 0x8000, 0x2009, 0x007f, 0x080c, 0x5f1e, 0x11b8,
+	0xb813, 0x00ff, 0xb817, 0xfffd, 0xb8bf, 0x0004, 0x080c, 0x9980,
+	0x0170, 0x2b00, 0x6012, 0x6316, 0x6023, 0x0001, 0x620a, 0x080c,
+	0xba69, 0x2009, 0x0022, 0x080c, 0x9a50, 0x9085, 0x0001, 0x012e,
+	0x00de, 0x00ce, 0x0005, 0x00e6, 0x00c6, 0x0066, 0x0036, 0x0026,
+	0x00b6, 0x21f0, 0x080c, 0x818b, 0x080c, 0x811a, 0x080c, 0x9819,
+	0x080c, 0xa893, 0x3e08, 0x2130, 0x81ff, 0x0120, 0x20a9, 0x007e,
+	0x900e, 0x0018, 0x20a9, 0x007f, 0x900e, 0x0016, 0x080c, 0x5f7e,
+	0x1140, 0x9686, 0x0002, 0x1118, 0xb800, 0xd0bc, 0x1110, 0x080c,
+	0x5a3b, 0x001e, 0x8108, 0x1f04, 0x2e15, 0x9686, 0x0001, 0x190c,
+	0x2f55, 0x00be, 0x002e, 0x003e, 0x006e, 0x00ce, 0x00ee, 0x0005,
+	0x00e6, 0x00c6, 0x0036, 0x0026, 0x0016, 0x00b6, 0x6210, 0x2258,
+	0xbaa0, 0x0026, 0x2019, 0x0029, 0x080c, 0x8180, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x8078, 0x2c08, 0x080c, 0xcd62, 0x007e, 0x001e,
+	0xba10, 0xbb14, 0x080c, 0x5a3b, 0xba12, 0xbb16, 0x00be, 0x001e,
+	0x002e, 0x003e, 0x00ce, 0x00ee, 0x0005, 0x00e6, 0x0006, 0x00b6,
+	0x6010, 0x2058, 0xb8a0, 0x00be, 0x9086, 0x0080, 0x0150, 0x2071,
+	0x1800, 0x70a0, 0x9005, 0x0110, 0x8001, 0x70a2, 0x000e, 0x00ee,
+	0x0005, 0x2071, 0x1800, 0x70dc, 0x9005, 0x0dc0, 0x8001, 0x70de,
+	0x0ca8, 0xb800, 0xc08c, 0xb802, 0x0005, 0x00f6, 0x00e6, 0x00c6,
+	0x00b6, 0x0036, 0x0026, 0x0016, 0x0156, 0x2178, 0x81ff, 0x1118,
+	0x20a9, 0x0001, 0x0088, 0x080c, 0x5113, 0xd0c4, 0x0150, 0xd0a4,
+	0x0140, 0x9006, 0x0046, 0x2020, 0x2009, 0x002d, 0x080c, 0xcfe6,
+	0x004e, 0x20a9, 0x0800, 0x9016, 0x0026, 0x928e, 0x007e, 0x0904,
+	0x2edd, 0x928e, 0x007f, 0x0904, 0x2edd, 0x928e, 0x0080, 0x05e8,
+	0x9288, 0x1000, 0x210c, 0x81ff, 0x05c0, 0x8fff, 0x1148, 0x2001,
+	0x195d, 0x0006, 0x2003, 0x0001, 0x04e9, 0x000e, 0x2003, 0x0000,
+	0x00b6, 0x00c6, 0x2158, 0x2001, 0x0001, 0x080c, 0x626e, 0x00ce,
+	0x00be, 0x2019, 0x0029, 0x080c, 0x8180, 0x0076, 0x2039, 0x0000,
+	0x080c, 0x8078, 0x00b6, 0x00c6, 0x0026, 0x2158, 0xba04, 0x9294,
+	0x00ff, 0x9286, 0x0006, 0x1118, 0xb807, 0x0404, 0x0028, 0x2001,
+	0x0004, 0x8007, 0x9215, 0xba06, 0x002e, 0x00ce, 0x00be, 0x0016,
+	0x2c08, 0x080c, 0xcd62, 0x001e, 0x007e, 0x002e, 0x8210, 0x1f04,
+	0x2e94, 0x015e, 0x001e, 0x002e, 0x003e, 0x00be, 0x00ce, 0x00ee,
+	0x00fe, 0x0005, 0x0046, 0x0026, 0x0016, 0x080c, 0x5113, 0xd0c4,
+	0x0140, 0xd0a4, 0x0130, 0x9006, 0x2220, 0x2009, 0x0029, 0x080c,
+	0xcfe6, 0x001e, 0x002e, 0x004e, 0x0005, 0x0016, 0x0026, 0x0036,
+	0x00c6, 0x728c, 0x82ff, 0x01e8, 0x080c, 0x629c, 0x11d0, 0x2100,
+	0x080c, 0x2509, 0x81ff, 0x01b8, 0x2019, 0x0001, 0x8314, 0x92e0,
+	0x1c80, 0x2c04, 0xd384, 0x0120, 0x9084, 0xff00, 0x8007, 0x0010,
+	0x9084, 0x00ff, 0x9116, 0x0138, 0x9096, 0x00ff, 0x0110, 0x8318,
+	0x0c68, 0x9085, 0x0001, 0x00ce, 0x003e, 0x002e, 0x001e, 0x0005,
+	0x0016, 0x00c6, 0x0126, 0x2091, 0x8000, 0x0036, 0x2019, 0x0029,
+	0x00a9, 0x003e, 0x9180, 0x1000, 0x2004, 0x9065, 0x0158, 0x0016,
+	0x00c6, 0x2061, 0x1a73, 0x001e, 0x6112, 0x080c, 0x2e30, 0x001e,
+	0x080c, 0x5f42, 0x012e, 0x00ce, 0x001e, 0x0005, 0x0016, 0x0026,
+	0x2110, 0x080c, 0x94b5, 0x080c, 0xd29b, 0x002e, 0x001e, 0x0005,
+	0x2001, 0x1835, 0x2004, 0xd0cc, 0x0005, 0x00c6, 0x00b6, 0x080c,
+	0x6c53, 0x1118, 0x20a9, 0x0800, 0x0010, 0x20a9, 0x0782, 0x080c,
+	0x6c53, 0x1110, 0x900e, 0x0010, 0x2009, 0x007e, 0x9180, 0x1000,
+	0x2004, 0x905d, 0x0130, 0x86ff, 0x0110, 0xb800, 0xd0bc, 0x090c,
+	0x5f42, 0x8108, 0x1f04, 0x2f66, 0x2061, 0x1800, 0x6077, 0x0000,
+	0x6078, 0x9084, 0x00ff, 0x607a, 0x60ab, 0x0000, 0x00be, 0x00ce,
+	0x0005, 0x2001, 0x1875, 0x2004, 0xd0bc, 0x0005, 0x2011, 0x1854,
+	0x2214, 0xd2ec, 0x0005, 0x0026, 0x2011, 0x1873, 0x2214, 0xd2dc,
+	0x002e, 0x0005, 0x7eef, 0x7de8, 0x7ce4, 0x80e2, 0x7be1, 0x80e0,
+	0x80dc, 0x80da, 0x7ad9, 0x80d6, 0x80d5, 0x80d4, 0x80d3, 0x80d2,
+	0x80d1, 0x79ce, 0x78cd, 0x80cc, 0x80cb, 0x80ca, 0x80c9, 0x80c7,
+	0x80c6, 0x77c5, 0x76c3, 0x80bc, 0x80ba, 0x75b9, 0x80b6, 0x74b5,
+	0x73b4, 0x72b3, 0x80b2, 0x80b1, 0x80ae, 0x71ad, 0x80ac, 0x70ab,
+	0x6faa, 0x6ea9, 0x80a7, 0x6da6, 0x6ca5, 0x6ba3, 0x6a9f, 0x699e,
+	0x689d, 0x809b, 0x8098, 0x6797, 0x6690, 0x658f, 0x6488, 0x6384,
+	0x6282, 0x8081, 0x8080, 0x617c, 0x607a, 0x8079, 0x5f76, 0x8075,
+	0x8074, 0x8073, 0x8072, 0x8071, 0x806e, 0x5e6d, 0x806c, 0x5d6b,
+	0x5c6a, 0x5b69, 0x8067, 0x5a66, 0x5965, 0x5863, 0x575c, 0x565a,
+	0x5559, 0x8056, 0x8055, 0x5454, 0x5353, 0x5252, 0x5151, 0x504e,
+	0x4f4d, 0x804c, 0x804b, 0x4e4a, 0x4d49, 0x8047, 0x4c46, 0x8045,
+	0x8043, 0x803c, 0x803a, 0x8039, 0x8036, 0x4b35, 0x8034, 0x4a33,
+	0x4932, 0x4831, 0x802e, 0x472d, 0x462c, 0x452b, 0x442a, 0x4329,
+	0x4227, 0x8026, 0x8025, 0x4123, 0x401f, 0x3f1e, 0x3e1d, 0x3d1b,
+	0x3c18, 0x8017, 0x8010, 0x3b0f, 0x3a08, 0x8004, 0x3902, 0x8001,
+	0x8000, 0x8000, 0x3800, 0x3700, 0x3600, 0x8000, 0x3500, 0x8000,
+	0x8000, 0x8000, 0x3400, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x3300, 0x3200, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x3100, 0x3000, 0x8000, 0x8000, 0x2f00, 0x8000, 0x2e00,
+	0x2d00, 0x2c00, 0x8000, 0x8000, 0x8000, 0x2b00, 0x8000, 0x2a00,
+	0x2900, 0x2800, 0x8000, 0x2700, 0x2600, 0x2500, 0x2400, 0x2300,
+	0x2200, 0x8000, 0x8000, 0x2100, 0x2000, 0x1f00, 0x1e00, 0x1d00,
+	0x1c00, 0x8000, 0x8000, 0x1b00, 0x1a00, 0x8000, 0x1900, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x1800, 0x8000, 0x1700,
+	0x1600, 0x1500, 0x8000, 0x1400, 0x1300, 0x1200, 0x1100, 0x1000,
+	0x0f00, 0x8000, 0x8000, 0x0e00, 0x0d00, 0x0c00, 0x0b00, 0x0a00,
+	0x0900, 0x8000, 0x8000, 0x0800, 0x0700, 0x8000, 0x0600, 0x8000,
+	0x8000, 0x8000, 0x0500, 0x0400, 0x0300, 0x8000, 0x0200, 0x8000,
+	0x8000, 0x8000, 0x0100, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x0000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
+	0x8000, 0x8000, 0x2071, 0x1894, 0x7003, 0x0002, 0x9006, 0x7016,
+	0x701a, 0x704a, 0x704e, 0x700e, 0x7042, 0x7046, 0x703b, 0x18b0,
+	0x703f, 0x18b0, 0x7007, 0x0001, 0x080c, 0x0fee, 0x090c, 0x0db2,
+	0x2900, 0x706a, 0xa867, 0x0002, 0xa8ab, 0xdcb0, 0x080c, 0x0fee,
+	0x090c, 0x0db2, 0x2900, 0x706e, 0xa867, 0x0002, 0xa8ab, 0xdcb0,
+	0x0005, 0x2071, 0x1894, 0x7004, 0x0002, 0x30c1, 0x30c2, 0x30d5,
+	0x30e9, 0x0005, 0x1004, 0x30d2, 0x0e04, 0x30d2, 0x2079, 0x0000,
+	0x0126, 0x2091, 0x8000, 0x700c, 0x9005, 0x1128, 0x700f, 0x0001,
+	0x012e, 0x0468, 0x0005, 0x012e, 0x0ce8, 0x2079, 0x0000, 0x2061,
+	0x18ae, 0x2c4c, 0xa86c, 0x908e, 0x0100, 0x0128, 0x9086, 0x0200,
+	0x0904, 0x31bd, 0x0005, 0x7018, 0x2048, 0x2061, 0x1800, 0x701c,
+	0x0807, 0x7014, 0x2048, 0xa864, 0x9094, 0x00ff, 0x9296, 0x0029,
+	0x1120, 0xaa78, 0xd2fc, 0x0128, 0x0005, 0x9086, 0x0103, 0x0108,
+	0x0005, 0x2079, 0x0000, 0x2061, 0x1800, 0x701c, 0x0807, 0x2061,
+	0x1800, 0x7880, 0x908a, 0x0040, 0x1210, 0x61c8, 0x0042, 0x2100,
+	0x908a, 0x003f, 0x1a04, 0x31ba, 0x61c8, 0x0804, 0x314f, 0x3191,
+	0x31c9, 0x31d3, 0x31d7, 0x31e1, 0x31e7, 0x31eb, 0x31fb, 0x31fe,
+	0x3208, 0x320d, 0x3212, 0x321d, 0x3228, 0x3237, 0x3246, 0x3254,
+	0x326b, 0x3286, 0x31ba, 0x332f, 0x336d, 0x3413, 0x3424, 0x3447,
+	0x31ba, 0x31ba, 0x31ba, 0x347f, 0x349b, 0x34a4, 0x34d3, 0x34d9,
+	0x31ba, 0x351f, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x352a,
+	0x3533, 0x353b, 0x353d, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba,
+	0x31ba, 0x3569, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x3586,
+	0x35e1, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x0002,
+	0x360b, 0x360e, 0x366d, 0x3686, 0x36b6, 0x3954, 0x31ba, 0x4cec,
+	0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba, 0x31ba,
+	0x3208, 0x320d, 0x3e75, 0x31ba, 0x3e8b, 0x4d7b, 0x4dcc, 0x4ecf,
+	0x31ba, 0x4f31, 0x4f6d, 0x4f9e, 0x50a2, 0x4fcb, 0x5022, 0x31ba,
+	0x3e8f, 0x404f, 0x4065, 0x408a, 0x40ef, 0x4163, 0x4183, 0x41fa,
+	0x420b, 0x421c, 0x421f, 0x4244, 0x42b7, 0x431d, 0x4325, 0x4457,
+	0x459c, 0x45d0, 0x4834, 0x31ba, 0x4852, 0x48fe, 0x49d4, 0x31ba,
+	0x31ba, 0x31ba, 0x31ba, 0x4a3a, 0x4a55, 0x4325, 0x4c9b, 0x714c,
+	0x0000, 0x2021, 0x4000, 0x080c, 0x464e, 0x0126, 0x2091, 0x8000,
+	0x0e04, 0x319b, 0x0010, 0x012e, 0x0cc0, 0x7c36, 0x9486, 0x4000,
+	0x0118, 0x7833, 0x0011, 0x0010, 0x7833, 0x0010, 0x7c82, 0x7986,
+	0x7a8a, 0x7b8e, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084,
+	0x190c, 0x1167, 0x7007, 0x0001, 0x2091, 0x5000, 0x700f, 0x0000,
+	0x012e, 0x0005, 0x2021, 0x4001, 0x08b0, 0x2021, 0x4002, 0x0898,
+	0x2021, 0x4003, 0x0880, 0x2021, 0x4005, 0x0868, 0x2021, 0x4006,
+	0x0850, 0x2039, 0x0001, 0x902e, 0x2520, 0x7b88, 0x7a8c, 0x7884,
+	0x7990, 0x0804, 0x465b, 0x7883, 0x0004, 0x7884, 0x0807, 0x2039,
+	0x0001, 0x902e, 0x2520, 0x7b88, 0x7a8c, 0x7884, 0x7990, 0x0804,
+	0x465e, 0x7984, 0x7888, 0x2114, 0x200a, 0x0804, 0x3191, 0x7984,
+	0x2114, 0x0804, 0x3191, 0x20e1, 0x0000, 0x2099, 0x0021, 0x20e9,
+	0x0000, 0x20a1, 0x0021, 0x20a9, 0x001f, 0x4003, 0x7984, 0x7a88,
+	0x7b8c, 0x0804, 0x3191, 0x7884, 0x2060, 0x04d8, 0x2009, 0x0003,
+	0x2011, 0x0002, 0x2019, 0x0012, 0x789b, 0x0117, 0x0804, 0x3191,
+	0x2039, 0x0001, 0x7d98, 0x7c9c, 0x0800, 0x2039, 0x0001, 0x7d98,
+	0x7c9c, 0x0848, 0x79a0, 0x9182, 0x0040, 0x0210, 0x0804, 0x31c6,
+	0x2138, 0x7d98, 0x7c9c, 0x0804, 0x31cd, 0x79a0, 0x9182, 0x0040,
+	0x0210, 0x0804, 0x31c6, 0x2138, 0x7d98, 0x7c9c, 0x0804, 0x31db,
+	0x79a0, 0x9182, 0x0040, 0x0210, 0x0804, 0x31c6, 0x21e8, 0x7984,
+	0x7888, 0x20a9, 0x0001, 0x21a0, 0x4004, 0x0804, 0x3191, 0x2061,
+	0x0800, 0xe10c, 0x9006, 0x2c15, 0x9200, 0x8c60, 0x8109, 0x1dd8,
+	0x2010, 0x9005, 0x0904, 0x3191, 0x0804, 0x31c0, 0x79a0, 0x9182,
+	0x0040, 0x0210, 0x0804, 0x31c6, 0x21e0, 0x20a9, 0x0001, 0x7984,
+	0x2198, 0x4012, 0x0804, 0x3191, 0x2069, 0x1853, 0x7884, 0x7990,
+	0x911a, 0x1a04, 0x31c6, 0x8019, 0x0904, 0x31c6, 0x684a, 0x6942,
+	0x788c, 0x6852, 0x7888, 0x6856, 0x9006, 0x685a, 0x685e, 0x080c,
+	0x6f5b, 0x0804, 0x3191, 0x2069, 0x1853, 0x7884, 0x7994, 0x911a,
+	0x1a04, 0x31c6, 0x8019, 0x0904, 0x31c6, 0x684e, 0x6946, 0x788c,
+	0x6862, 0x7888, 0x6866, 0x9006, 0x686a, 0x686e, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x630e, 0x012e, 0x0804, 0x3191, 0x902e, 0x2520,
+	0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x31c3, 0x7984, 0x7b88,
+	0x7a8c, 0x20a9, 0x0005, 0x20e9, 0x0001, 0x20a1, 0x189c, 0x4101,
+	0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804, 0x31c3, 0x2009,
+	0x0020, 0xa85c, 0x9080, 0x0019, 0xaf60, 0x080c, 0x465b, 0x701f,
+	0x32aa, 0x0005, 0xa864, 0x2008, 0x9084, 0x00ff, 0x9096, 0x0011,
+	0x0168, 0x9096, 0x0019, 0x0150, 0x9096, 0x0015, 0x0138, 0x9096,
+	0x0048, 0x0120, 0x9096, 0x0029, 0x1904, 0x31c3, 0x810f, 0x918c,
+	0x00ff, 0x0904, 0x31c3, 0x7112, 0x7010, 0x8001, 0x0560, 0x7012,
+	0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804, 0x31c3, 0x2009,
+	0x0020, 0x7068, 0x2040, 0xa28c, 0xa390, 0xa494, 0xa598, 0x9290,
+	0x0040, 0x9399, 0x0000, 0x94a1, 0x0000, 0x95a9, 0x0000, 0xa85c,
+	0x9080, 0x0019, 0xaf60, 0x080c, 0x465b, 0x701f, 0x32e8, 0x0005,
+	0xa864, 0x9084, 0x00ff, 0x9096, 0x0002, 0x0120, 0x9096, 0x000a,
+	0x1904, 0x31c3, 0x0888, 0x7014, 0x2048, 0xa868, 0xc0fd, 0xa86a,
+	0xa864, 0x9084, 0x00ff, 0x9096, 0x0029, 0x1160, 0xc2fd, 0xaa7a,
+	0x080c, 0x5b2d, 0x0150, 0x0126, 0x2091, 0x8000, 0xa87a, 0xa982,
+	0x012e, 0x0050, 0x080c, 0x5e34, 0x1128, 0x7007, 0x0003, 0x701f,
+	0x3314, 0x0005, 0x080c, 0x6770, 0x0126, 0x2091, 0x8000, 0x20a9,
+	0x0005, 0x20e1, 0x0001, 0x2099, 0x189c, 0x400a, 0x2100, 0x9210,
+	0x9399, 0x0000, 0x94a1, 0x0000, 0x95a9, 0x0000, 0xa85c, 0x9080,
+	0x0019, 0x2009, 0x0020, 0x012e, 0xaf60, 0x0804, 0x465e, 0x2091,
+	0x8000, 0x7837, 0x4000, 0x7833, 0x0010, 0x7883, 0x4000, 0x7887,
+	0x4953, 0x788b, 0x5020, 0x788f, 0x2020, 0x2009, 0x017f, 0x2104,
+	0x7892, 0x3f00, 0x7896, 0x2061, 0x0100, 0x6200, 0x2061, 0x0200,
+	0x603c, 0x8007, 0x9205, 0x789a, 0x2009, 0x04fd, 0x2104, 0x789e,
+	0x2091, 0x5000, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084,
+	0x0180, 0x2001, 0x19e8, 0x2004, 0x9005, 0x0128, 0x2001, 0x008b,
+	0x2004, 0xd0fc, 0x0dd8, 0x2001, 0x008a, 0x2003, 0x0002, 0x2003,
+	0x1001, 0x2071, 0x0080, 0x0804, 0x0427, 0x81ff, 0x1904, 0x31c3,
+	0x7984, 0x080c, 0x5f7e, 0x1904, 0x31c6, 0x7e98, 0x9684, 0x3fff,
+	0x9082, 0x4000, 0x1a04, 0x31c6, 0x7c88, 0x7d8c, 0x080c, 0x60e1,
+	0x080c, 0x60b0, 0x0000, 0x1518, 0x2061, 0x1cd0, 0x0126, 0x2091,
+	0x8000, 0x6000, 0x9086, 0x0000, 0x0148, 0x6014, 0x904d, 0x0130,
+	0xa86c, 0x9406, 0x1118, 0xa870, 0x9506, 0x0150, 0x012e, 0x9ce0,
+	0x0018, 0x2001, 0x1818, 0x2004, 0x9c02, 0x1a04, 0x31c3, 0x0c30,
+	0x080c, 0xb251, 0x012e, 0x0904, 0x31c3, 0x0804, 0x3191, 0x900e,
+	0x2001, 0x0005, 0x080c, 0x6770, 0x0126, 0x2091, 0x8000, 0x080c,
+	0xb8e9, 0x080c, 0x6536, 0x012e, 0x0804, 0x3191, 0x00a6, 0x2950,
+	0xb198, 0x080c, 0x5f7e, 0x1904, 0x3400, 0xb6a4, 0x9684, 0x3fff,
+	0x9082, 0x4000, 0x16e8, 0xb49c, 0xb5a0, 0x080c, 0x60e1, 0x080c,
+	0x60b0, 0x1520, 0x2061, 0x1cd0, 0x0126, 0x2091, 0x8000, 0x6000,
+	0x9086, 0x0000, 0x0148, 0x6014, 0x904d, 0x0130, 0xa86c, 0x9406,
+	0x1118, 0xa870, 0x9506, 0x0158, 0x012e, 0x9ce0, 0x0018, 0x2001,
+	0x1818, 0x2004, 0x9c02, 0x2009, 0x000d, 0x12b0, 0x0c28, 0x080c,
+	0xb251, 0x012e, 0x2009, 0x0003, 0x0178, 0x00e0, 0x900e, 0x2001,
+	0x0005, 0x080c, 0x6770, 0x0126, 0x2091, 0x8000, 0x080c, 0xb8e9,
+	0x080c, 0x6529, 0x012e, 0x0070, 0xb097, 0x4005, 0xb19a, 0x0010,
+	0xb097, 0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030, 0x2a48,
+	0x00ae, 0x0005, 0xb097, 0x4000, 0x9006, 0x918d, 0x0001, 0x2008,
+	0x2a48, 0x00ae, 0x0005, 0x81ff, 0x1904, 0x31c3, 0x080c, 0x4629,
+	0x0904, 0x31c6, 0x080c, 0x6045, 0x0904, 0x31c3, 0x080c, 0x60e7,
+	0x0904, 0x31c3, 0x0804, 0x417a, 0x81ff, 0x1904, 0x31c3, 0x080c,
+	0x4645, 0x0904, 0x31c6, 0x080c, 0x6175, 0x0904, 0x31c3, 0x2019,
+	0x0005, 0x79a8, 0x080c, 0x6102, 0x0904, 0x31c3, 0x7888, 0x908a,
+	0x1000, 0x1a04, 0x31c6, 0x8003, 0x800b, 0x810b, 0x9108, 0x080c,
+	0x7c58, 0x7984, 0xd184, 0x1904, 0x3191, 0x0804, 0x417a, 0x0126,
+	0x2091, 0x8000, 0x81ff, 0x0118, 0x2009, 0x0001, 0x0450, 0x2029,
+	0x07ff, 0x6454, 0x2400, 0x9506, 0x01f8, 0x2508, 0x080c, 0x5f7e,
+	0x11d8, 0x080c, 0x6175, 0x1128, 0x2009, 0x0002, 0x62b8, 0x2518,
+	0x00c0, 0x2019, 0x0004, 0x900e, 0x080c, 0x6102, 0x1118, 0x2009,
+	0x0006, 0x0078, 0x7884, 0x908a, 0x1000, 0x1270, 0x8003, 0x800b,
+	0x810b, 0x9108, 0x080c, 0x7c58, 0x8529, 0x1ae0, 0x012e, 0x0804,
+	0x3191, 0x012e, 0x0804, 0x31c3, 0x012e, 0x0804, 0x31c6, 0x080c,
+	0x4629, 0x0904, 0x31c6, 0x080c, 0x6045, 0x0904, 0x31c3, 0xbaa0,
+	0x2019, 0x0005, 0x00c6, 0x9066, 0x080c, 0x8180, 0x0076, 0x903e,
+	0x080c, 0x8078, 0x900e, 0x080c, 0xcd62, 0x007e, 0x00ce, 0x080c,
+	0x60e1, 0x0804, 0x3191, 0x080c, 0x4629, 0x0904, 0x31c6, 0x080c,
+	0x60e1, 0x2208, 0x0804, 0x3191, 0x0156, 0x00d6, 0x00e6, 0x2069,
+	0x1906, 0x6810, 0x6914, 0x910a, 0x1208, 0x900e, 0x6816, 0x9016,
+	0x901e, 0x20a9, 0x007e, 0x2069, 0x1000, 0x2d04, 0x905d, 0x0118,
+	0xb84c, 0x0059, 0x9210, 0x8d68, 0x1f04, 0x34b5, 0x2300, 0x9218,
+	0x00ee, 0x00de, 0x015e, 0x0804, 0x3191, 0x00f6, 0x0016, 0x907d,
+	0x0138, 0x9006, 0x8000, 0x2f0c, 0x81ff, 0x0110, 0x2178, 0x0cd0,
+	0x001e, 0x00fe, 0x0005, 0x2069, 0x1906, 0x6910, 0x62b4, 0x0804,
+	0x3191, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x31c3, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x5127, 0x0128, 0x2009, 0x0007, 0x012e,
+	0x0804, 0x31c3, 0x012e, 0x6154, 0x9190, 0x2f92, 0x2215, 0x9294,
+	0x00ff, 0x6374, 0x83ff, 0x0108, 0x6278, 0x67d4, 0x97c4, 0x000a,
+	0x98c6, 0x000a, 0x1118, 0x2031, 0x0001, 0x00e8, 0x97c4, 0x0022,
+	0x98c6, 0x0022, 0x1118, 0x2031, 0x0003, 0x00a8, 0x97c4, 0x0012,
+	0x98c6, 0x0012, 0x1118, 0x2031, 0x0002, 0x0068, 0x080c, 0x6c53,
+	0x1118, 0x2031, 0x0004, 0x0038, 0xd79c, 0x0120, 0x2009, 0x0005,
+	0x0804, 0x31c3, 0x9036, 0x7e9a, 0x7f9e, 0x0804, 0x3191, 0x6144,
+	0x6248, 0x2019, 0x1955, 0x231c, 0x2001, 0x1956, 0x2004, 0x789a,
+	0x0804, 0x3191, 0x0126, 0x2091, 0x8000, 0x6134, 0x6238, 0x633c,
+	0x012e, 0x0804, 0x3191, 0x080c, 0x4645, 0x0904, 0x31c6, 0xba44,
+	0xbb38, 0x0804, 0x3191, 0x080c, 0x0db2, 0x080c, 0x4645, 0x2110,
+	0x0904, 0x31c6, 0xb804, 0x908c, 0x00ff, 0x918e, 0x0006, 0x0140,
+	0x9084, 0xff00, 0x9086, 0x0600, 0x2009, 0x0009, 0x1904, 0x31c3,
+	0x0126, 0x2091, 0x8000, 0x2019, 0x0005, 0x00c6, 0x9066, 0x080c,
+	0x94b5, 0x080c, 0x8180, 0x0076, 0x903e, 0x080c, 0x8078, 0x900e,
+	0x080c, 0xcd62, 0x007e, 0x00ce, 0xb807, 0x0407, 0x012e, 0x0804,
+	0x3191, 0x6144, 0x6248, 0x7884, 0x6046, 0x7b88, 0x634a, 0x2069,
+	0x1853, 0x831f, 0x9305, 0x6816, 0x788c, 0x2069, 0x1955, 0x2d1c,
+	0x206a, 0x7e98, 0x9682, 0x0014, 0x1210, 0x2031, 0x07d0, 0x2069,
+	0x1956, 0x2d04, 0x266a, 0x789a, 0x0804, 0x3191, 0x0126, 0x2091,
+	0x8000, 0x6134, 0x7884, 0x6036, 0x910e, 0xd1b4, 0x190c, 0x0e84,
+	0xd0c4, 0x01a8, 0x00d6, 0x78a8, 0x2009, 0x196c, 0x200a, 0x78ac,
+	0x2011, 0x196d, 0x2012, 0x2069, 0x0100, 0x6838, 0x9086, 0x0007,
+	0x1118, 0x2214, 0x6a5a, 0x0010, 0x210c, 0x695a, 0x00de, 0x7888,
+	0x603a, 0x2011, 0x0114, 0x220c, 0x7888, 0xd08c, 0x0118, 0x918d,
+	0x0080, 0x0010, 0x918c, 0xff7f, 0x2112, 0x613c, 0x788c, 0x603e,
+	0x910e, 0xd1e4, 0x190c, 0x0e9a, 0x603c, 0xd0cc, 0x0120, 0x78b0,
+	0x2011, 0x0114, 0x2012, 0x012e, 0x0804, 0x3191, 0x00f6, 0x2079,
+	0x1800, 0x7a34, 0xa898, 0x9084, 0xfebf, 0x9215, 0xa89c, 0x9084,
+	0xfebf, 0x8002, 0x9214, 0x7834, 0x9084, 0x0140, 0x9215, 0x7a36,
+	0xa897, 0x4000, 0x900e, 0x9085, 0x0001, 0x2001, 0x0000, 0x00fe,
+	0x0005, 0x7898, 0x9005, 0x01a8, 0x7888, 0x9025, 0x0904, 0x31c6,
+	0x788c, 0x902d, 0x0904, 0x31c6, 0x900e, 0x080c, 0x5f7e, 0x1120,
+	0xba44, 0xbb38, 0xbc46, 0xbd3a, 0x9186, 0x07ff, 0x0190, 0x8108,
+	0x0ca0, 0x080c, 0x4645, 0x0904, 0x31c6, 0x7888, 0x900d, 0x0904,
+	0x31c6, 0x788c, 0x9005, 0x0904, 0x31c6, 0xba44, 0xb946, 0xbb38,
+	0xb83a, 0x0804, 0x3191, 0x2011, 0xbc09, 0x0010, 0x2011, 0xbc05,
+	0x080c, 0x5127, 0x1904, 0x31c3, 0x00c6, 0x2061, 0x0100, 0x7984,
+	0x9186, 0x00ff, 0x1130, 0x2001, 0x1816, 0x2004, 0x9085, 0xff00,
+	0x0088, 0x9182, 0x007f, 0x16e0, 0x9188, 0x2f92, 0x210d, 0x918c,
+	0x00ff, 0x2001, 0x1816, 0x2004, 0x0026, 0x9116, 0x002e, 0x0580,
+	0x810f, 0x9105, 0x0126, 0x2091, 0x8000, 0x0006, 0x080c, 0x9980,
+	0x000e, 0x0510, 0x602e, 0x620a, 0x7984, 0x00b6, 0x080c, 0x5f24,
+	0x2b08, 0x00be, 0x1500, 0x6112, 0x6023, 0x0001, 0x080c, 0x4612,
+	0x01d0, 0x9006, 0xa866, 0x7007, 0x0003, 0xa832, 0xa868, 0xc0fd,
+	0xa86a, 0x701f, 0x3666, 0x2900, 0x6016, 0x2009, 0x0032, 0x080c,
+	0x9a50, 0x012e, 0x00ce, 0x0005, 0x012e, 0x00ce, 0x0804, 0x31c3,
+	0x00ce, 0x0804, 0x31c6, 0x080c, 0x99d6, 0x0cb0, 0xa830, 0x9086,
+	0x0100, 0x0904, 0x31c3, 0x0804, 0x3191, 0x2061, 0x1a3e, 0x0126,
+	0x2091, 0x8000, 0x6000, 0xd084, 0x0170, 0x6104, 0x6208, 0x2061,
+	0x1800, 0x634c, 0x606c, 0x789a, 0x60b8, 0x789e, 0x60b4, 0x78aa,
+	0x012e, 0x0804, 0x3191, 0x900e, 0x2110, 0x0c88, 0x81ff, 0x1904,
+	0x31c3, 0x080c, 0x6c53, 0x0904, 0x31c3, 0x0126, 0x2091, 0x8000,
+	0x624c, 0x606c, 0x9202, 0x0248, 0x9085, 0x0001, 0x080c, 0x253f,
+	0x080c, 0x5304, 0x012e, 0x0804, 0x3191, 0x012e, 0x0804, 0x31c6,
+	0x0006, 0x0016, 0x00c6, 0x00e6, 0x2001, 0x1978, 0x2070, 0x2061,
+	0x1853, 0x6008, 0x2072, 0x900e, 0x2011, 0x1400, 0x080c, 0x7e7f,
+	0x7206, 0x00ee, 0x00ce, 0x001e, 0x000e, 0x0005, 0x0126, 0x2091,
+	0x8000, 0x81ff, 0x0128, 0x012e, 0x2021, 0x400b, 0x0804, 0x3193,
+	0x7884, 0xd0fc, 0x0148, 0x2001, 0x002a, 0x2004, 0x9082, 0x00e1,
+	0x0288, 0x012e, 0x0804, 0x31c6, 0x2001, 0x002a, 0x2004, 0x2069,
+	0x1853, 0x6908, 0x9102, 0x1230, 0x012e, 0x0804, 0x31c6, 0x012e,
+	0x0804, 0x31c3, 0x080c, 0x9940, 0x0dd0, 0x7884, 0xd0fc, 0x0904,
+	0x3731, 0x00c6, 0x080c, 0x4612, 0x00ce, 0x0d88, 0xa867, 0x0000,
+	0x7884, 0xa80a, 0x7898, 0xa80e, 0x789c, 0xa812, 0x2001, 0x002e,
+	0x2004, 0xa81a, 0x2001, 0x002f, 0x2004, 0xa81e, 0x2001, 0x0030,
+	0x2004, 0xa822, 0x2001, 0x0031, 0x2004, 0xa826, 0x2001, 0x0034,
+	0x2004, 0xa82a, 0x2001, 0x0035, 0x2004, 0xa82e, 0x2001, 0x002a,
+	0x2004, 0x9080, 0x0003, 0x9084, 0x00fc, 0x8004, 0xa816, 0x080c,
+	0x38b7, 0x0928, 0x7014, 0x2048, 0xad2c, 0xac28, 0xab1c, 0xaa18,
+	0xa930, 0xa808, 0xd0b4, 0x1120, 0x2029, 0x0000, 0x2021, 0x0000,
+	0x8906, 0x8006, 0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080,
+	0x001b, 0x080c, 0x465b, 0x701f, 0x37f4, 0x7023, 0x0001, 0x012e,
+	0x0005, 0x0046, 0x0086, 0x0096, 0x00a6, 0x00b6, 0x00c6, 0x00d6,
+	0x00e6, 0x00f6, 0x080c, 0x36a0, 0x2001, 0x196e, 0x2003, 0x0000,
+	0x2021, 0x000a, 0x2061, 0x0100, 0x6104, 0x0016, 0x60bb, 0x0000,
+	0x60bf, 0x32e1, 0x60bf, 0x0012, 0x080c, 0x3926, 0x080c, 0x38e5,
+	0x00f6, 0x00e6, 0x0086, 0x2940, 0x2071, 0x1a34, 0x2079, 0x0090,
+	0x00d6, 0x2069, 0x0000, 0x6884, 0xd0b4, 0x0140, 0x2001, 0x0035,
+	0x2004, 0x780e, 0x2001, 0x0034, 0x2004, 0x780a, 0x00de, 0x2011,
+	0x0001, 0x080c, 0x3cb9, 0x008e, 0x00ee, 0x00fe, 0x080c, 0x3be6,
+	0x080c, 0x3aeb, 0x05b8, 0x2001, 0x020b, 0x2004, 0x9084, 0x0140,
+	0x1db8, 0x080c, 0x3d2d, 0x00f6, 0x2079, 0x0300, 0x78bc, 0x00fe,
+	0x908c, 0x0070, 0x1560, 0x2071, 0x0200, 0x7037, 0x0000, 0x7050,
+	0x9084, 0xff00, 0x9086, 0x3200, 0x1510, 0x7037, 0x0001, 0x7050,
+	0x9084, 0xff00, 0x9086, 0xe100, 0x11d0, 0x7037, 0x0000, 0x7054,
+	0x7037, 0x0000, 0x715c, 0x9106, 0x1190, 0x2001, 0x181e, 0x2004,
+	0x9106, 0x1168, 0x00c6, 0x2061, 0x0100, 0x6024, 0x9084, 0x1e00,
+	0x00ce, 0x0138, 0x080c, 0x3af5, 0x080c, 0x38e0, 0x0058, 0x080c,
+	0x38e0, 0x080c, 0x3c51, 0x080c, 0x3bdc, 0x2001, 0x020b, 0x2004,
+	0xd0e4, 0x0dd8, 0x2001, 0x032a, 0x2003, 0x0004, 0x2061, 0x0100,
+	0x6027, 0x0002, 0x001e, 0x6106, 0x2011, 0x020d, 0x2013, 0x0020,
+	0x60bb, 0x0000, 0x60bf, 0x0108, 0x60bf, 0x0012, 0x2001, 0x0004,
+	0x200c, 0x918c, 0xfffd, 0x2102, 0x080c, 0x127c, 0x2009, 0x0028,
+	0x080c, 0x20d9, 0x2001, 0x0227, 0x200c, 0x2102, 0x00fe, 0x00ee,
+	0x00de, 0x00ce, 0x00be, 0x00ae, 0x009e, 0x008e, 0x004e, 0x2001,
+	0x196e, 0x2004, 0x9005, 0x1118, 0x012e, 0x0804, 0x3191, 0x012e,
+	0x2021, 0x400c, 0x0804, 0x3193, 0x0016, 0x0026, 0x0036, 0x0046,
+	0x0056, 0x0076, 0x0086, 0x0096, 0x00d6, 0x0156, 0x7014, 0x2048,
+	0x7020, 0x20a8, 0x8000, 0x7022, 0xa804, 0x9005, 0x0904, 0x3850,
+	0x2048, 0x1f04, 0x3804, 0x7068, 0x2040, 0xa28c, 0xa390, 0xa494,
+	0xa598, 0xa930, 0xa808, 0xd0b4, 0x1120, 0x2029, 0x0000, 0x2021,
+	0x0000, 0x0096, 0x7014, 0x2048, 0xa864, 0x009e, 0x9086, 0x0103,
+	0x0170, 0x8906, 0x8006, 0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0,
+	0x9080, 0x001b, 0x080c, 0x465b, 0x701f, 0x37f4, 0x00b0, 0x8906,
+	0x8006, 0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080, 0x001b,
+	0x21a8, 0x27e0, 0x2098, 0x27e8, 0x20a0, 0x0006, 0x080c, 0x0f52,
+	0x000e, 0x080c, 0x465e, 0x701f, 0x37f4, 0x015e, 0x00de, 0x009e,
+	0x008e, 0x007e, 0x005e, 0x004e, 0x003e, 0x002e, 0x001e, 0x0005,
+	0x7014, 0x2048, 0xa864, 0x9086, 0x0103, 0x1118, 0x701f, 0x38b5,
+	0x0450, 0x7014, 0x2048, 0xa868, 0xc0fd, 0xa86a, 0x2009, 0x007f,
+	0x080c, 0x5f1e, 0x0110, 0x9006, 0x0030, 0xb813, 0x00ff, 0xb817,
+	0xfffd, 0x080c, 0xbab8, 0x015e, 0x00de, 0x009e, 0x008e, 0x007e,
+	0x005e, 0x004e, 0x003e, 0x002e, 0x001e, 0x0904, 0x31c3, 0x0016,
+	0x0026, 0x0036, 0x0046, 0x0056, 0x0076, 0x0086, 0x0096, 0x00d6,
+	0x0156, 0x701f, 0x3887, 0x7007, 0x0003, 0x0804, 0x3845, 0x0076,
+	0xa830, 0x9086, 0x0100, 0x2021, 0x400c, 0x0904, 0x3193, 0xad10,
+	0xac0c, 0xab24, 0xaa20, 0xa930, 0xa808, 0xd0b4, 0x1120, 0x2029,
+	0x0000, 0x2021, 0x0000, 0x8906, 0x8006, 0x8007, 0x90bc, 0x003f,
+	0x9084, 0xffc0, 0x9080, 0x001b, 0x21a8, 0x27e0, 0x2098, 0x27e8,
+	0x20a0, 0x0006, 0x080c, 0x0f52, 0x000e, 0x080c, 0x465e, 0x007e,
+	0x701f, 0x37f4, 0x7023, 0x0001, 0x0005, 0x0804, 0x3191, 0x0156,
+	0x00c6, 0xa814, 0x908a, 0x001e, 0x0218, 0xa833, 0x001e, 0x0010,
+	0xa832, 0x0078, 0x81ff, 0x0168, 0x0016, 0x080c, 0x4612, 0x001e,
+	0x0130, 0xa800, 0x2040, 0xa008, 0xa80a, 0x2100, 0x0c58, 0x9006,
+	0x0010, 0x9085, 0x0001, 0x00ce, 0x015e, 0x0005, 0x0006, 0x00f6,
+	0x2079, 0x0000, 0x7880, 0x9086, 0x0044, 0x00fe, 0x000e, 0x0005,
+	0x2001, 0x196e, 0x2003, 0x0001, 0x0005, 0x00f6, 0x00e6, 0x00c6,
+	0x2061, 0x0200, 0x2001, 0x1979, 0x2004, 0x601a, 0x2061, 0x0100,
+	0x2001, 0x1978, 0x2004, 0x60ce, 0x6104, 0xc1ac, 0x6106, 0x080c,
+	0x4612, 0xa813, 0x0019, 0xa817, 0x0001, 0x2900, 0xa85a, 0x2001,
+	0x002e, 0x2004, 0xa866, 0x2001, 0x002f, 0x2004, 0xa86a, 0x2061,
+	0x0090, 0x2079, 0x0100, 0x2001, 0x1978, 0x2004, 0x6036, 0x2009,
+	0x0040, 0x080c, 0x20d9, 0x2001, 0x002a, 0x2004, 0x9084, 0xfff8,
+	0xa86e, 0x601a, 0xa873, 0x0000, 0x601f, 0x0000, 0x78ca, 0x9006,
+	0x600a, 0x600e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x00e6, 0x080c,
+	0x4612, 0x2940, 0xa013, 0x0019, 0xa017, 0x0001, 0x2800, 0xa05a,
+	0x2001, 0x0030, 0x2004, 0xa866, 0x2001, 0x0031, 0x2004, 0xa86a,
+	0x2001, 0x002a, 0x2004, 0x9084, 0xfff8, 0xa86e, 0xa873, 0x0000,
+	0x2001, 0x032a, 0x2003, 0x0004, 0x2001, 0x0300, 0x2003, 0x0000,
+	0x2001, 0x020d, 0x2003, 0x0000, 0x2001, 0x0004, 0x200c, 0x918d,
+	0x0002, 0x2102, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x81ff,
+	0x0148, 0x080c, 0x28c8, 0x1130, 0x9006, 0x080c, 0x2820, 0x9006,
+	0x080c, 0x2803, 0x7884, 0x9084, 0x0007, 0x0002, 0x3971, 0x397a,
+	0x3983, 0x396e, 0x396e, 0x396e, 0x396e, 0x396e, 0x012e, 0x0804,
+	0x31c6, 0x2009, 0x0114, 0x2104, 0x9085, 0x0800, 0x200a, 0x080c,
+	0x3b3f, 0x00c0, 0x2009, 0x0114, 0x2104, 0x9085, 0x4000, 0x200a,
+	0x080c, 0x3b3f, 0x0078, 0x080c, 0x6c53, 0x1128, 0x012e, 0x2009,
+	0x0016, 0x0804, 0x31c3, 0x81ff, 0x0128, 0x012e, 0x2021, 0x400b,
+	0x0804, 0x3193, 0x0086, 0x0096, 0x00a6, 0x00b6, 0x00c6, 0x00d6,
+	0x00e6, 0x00f6, 0x080c, 0x36a0, 0x2009, 0x0101, 0x210c, 0x0016,
+	0x7ec8, 0x7dcc, 0x9006, 0x2068, 0x2060, 0x2058, 0x080c, 0x3e08,
+	0x080c, 0x3d58, 0x903e, 0x2720, 0x00f6, 0x00e6, 0x0086, 0x2940,
+	0x2071, 0x1a34, 0x2079, 0x0090, 0x00d6, 0x2069, 0x0000, 0x6884,
+	0xd0b4, 0x0120, 0x68d4, 0x780e, 0x68d0, 0x780a, 0x00de, 0x2011,
+	0x0001, 0x080c, 0x3cb9, 0x080c, 0x28d0, 0x080c, 0x28d0, 0x080c,
+	0x28d0, 0x080c, 0x28d0, 0x080c, 0x3cb9, 0x008e, 0x00ee, 0x00fe,
+	0x080c, 0x3be6, 0x2009, 0x0190, 0x8109, 0x11b0, 0x080c, 0x3af5,
+	0x2001, 0x0004, 0x200c, 0x918c, 0xfffd, 0x2102, 0x001e, 0x00fe,
+	0x00ee, 0x00de, 0x00ce, 0x00be, 0x00ae, 0x009e, 0x008e, 0x2009,
+	0x0017, 0x080c, 0x31c3, 0x0cf8, 0x2001, 0x020b, 0x2004, 0x9084,
+	0x0140, 0x1d10, 0x00f6, 0x2079, 0x0000, 0x7884, 0x00fe, 0xd0bc,
+	0x0178, 0x2001, 0x0201, 0x200c, 0x81ff, 0x0150, 0x080c, 0x3bc4,
+	0x2d00, 0x9c05, 0x9b05, 0x0120, 0x080c, 0x3af5, 0x0804, 0x3aa2,
+	0x080c, 0x3d2d, 0x080c, 0x3c51, 0x080c, 0x3ba7, 0x080c, 0x3bdc,
+	0x00f6, 0x2079, 0x0100, 0x7824, 0xd0ac, 0x0130, 0x8b58, 0x080c,
+	0x3af5, 0x00fe, 0x0804, 0x3aa2, 0x00fe, 0x080c, 0x3aeb, 0x1150,
+	0x8d68, 0x2001, 0x0032, 0x2602, 0x2001, 0x0033, 0x2502, 0x080c,
+	0x3af5, 0x0080, 0x87ff, 0x0138, 0x2001, 0x0201, 0x2004, 0x9005,
+	0x1908, 0x8739, 0x0038, 0x2001, 0x1a31, 0x2004, 0x9086, 0x0000,
+	0x1904, 0x39f2, 0x2001, 0x032f, 0x2003, 0x00f6, 0x8631, 0x1208,
+	0x8529, 0x2500, 0x9605, 0x0904, 0x3aa2, 0x7884, 0xd0bc, 0x0128,
+	0x2d00, 0x9c05, 0x9b05, 0x1904, 0x3aa2, 0xa013, 0x0019, 0x2001,
+	0x032a, 0x2003, 0x0004, 0x7884, 0xd0ac, 0x1148, 0x2001, 0x1a31,
+	0x2003, 0x0003, 0x2001, 0x032a, 0x2003, 0x0009, 0x0030, 0xa017,
+	0x0001, 0x78b4, 0x9005, 0x0108, 0xa016, 0x2800, 0xa05a, 0x2009,
+	0x0040, 0x080c, 0x20d9, 0x2900, 0xa85a, 0xa813, 0x0019, 0x7884,
+	0xd0a4, 0x1180, 0xa817, 0x0000, 0x00c6, 0x20a9, 0x0004, 0x2061,
+	0x0090, 0x602b, 0x0008, 0x2001, 0x0203, 0x2004, 0x1f04, 0x3a79,
+	0x00ce, 0x0030, 0xa817, 0x0001, 0x78b0, 0x9005, 0x0108, 0xa816,
+	0x00f6, 0x00c6, 0x2079, 0x0100, 0x2061, 0x0090, 0x7827, 0x0002,
+	0x2001, 0x002a, 0x2004, 0x9084, 0xfff8, 0x601a, 0x0006, 0x2001,
+	0x002b, 0x2004, 0x601e, 0x78c6, 0x000e, 0x78ca, 0x00ce, 0x00fe,
+	0x0804, 0x39ac, 0x001e, 0x00c6, 0x2001, 0x032a, 0x2003, 0x0004,
+	0x2061, 0x0100, 0x6027, 0x0002, 0x6106, 0x2011, 0x020d, 0x2013,
+	0x0020, 0x2001, 0x0004, 0x200c, 0x918c, 0xfffd, 0x2102, 0x080c,
+	0x127c, 0x7884, 0x9084, 0x0003, 0x9086, 0x0002, 0x01a0, 0x2009,
+	0x0028, 0x080c, 0x20d9, 0x2001, 0x0227, 0x200c, 0x2102, 0x6050,
+	0x9084, 0xb7ef, 0x6052, 0x602f, 0x0000, 0x604b, 0xf7f7, 0x6043,
+	0x0090, 0x6043, 0x0010, 0x00ce, 0x2d08, 0x2c10, 0x2b18, 0x2b00,
+	0x9c05, 0x9d05, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x00be, 0x00ae,
+	0x009e, 0x008e, 0x1118, 0x012e, 0x0804, 0x3191, 0x012e, 0x2021,
+	0x400c, 0x0804, 0x3193, 0x9085, 0x0001, 0x1d04, 0x3af4, 0x2091,
+	0x6000, 0x8420, 0x9486, 0x0064, 0x0005, 0x2001, 0x0105, 0x2003,
+	0x0010, 0x2001, 0x032a, 0x2003, 0x0004, 0x2001, 0x1a31, 0x2003,
+	0x0000, 0x0071, 0x2009, 0x0048, 0x080c, 0x20d9, 0x2001, 0x0227,
+	0x2024, 0x2402, 0x2001, 0x0109, 0x2003, 0x4000, 0x9026, 0x0005,
+	0x00f6, 0x00e6, 0x2071, 0x1a34, 0x7000, 0x9086, 0x0000, 0x0520,
+	0x2079, 0x0090, 0x2009, 0x0206, 0x2104, 0x2009, 0x0203, 0x210c,
+	0x9106, 0x1120, 0x2009, 0x0040, 0x080c, 0x20d9, 0x782c, 0xd0fc,
+	0x0d88, 0x080c, 0x3d2d, 0x7000, 0x9086, 0x0000, 0x1d58, 0x782b,
+	0x0004, 0x782c, 0xd0ac, 0x1de8, 0x2009, 0x0040, 0x080c, 0x20d9,
+	0x782b, 0x0002, 0x7003, 0x0000, 0x00ee, 0x00fe, 0x0005, 0x00f6,
+	0x2079, 0x0100, 0x2001, 0x1816, 0x200c, 0x7932, 0x7936, 0x080c,
+	0x251f, 0x7850, 0x9084, 0xfbff, 0x9085, 0x0030, 0x7852, 0x2019,
+	0x01f4, 0x8319, 0x1df0, 0x9084, 0xffcf, 0x9085, 0x2000, 0x7852,
+	0x20a9, 0x0046, 0x1d04, 0x3b5a, 0x2091, 0x6000, 0x1f04, 0x3b5a,
+	0x7850, 0x9085, 0x0400, 0x9084, 0xdfff, 0x7852, 0x2001, 0x0021,
+	0x2004, 0x9084, 0x0003, 0x9086, 0x0001, 0x1120, 0x7850, 0x9084,
+	0xdfff, 0x7852, 0x784b, 0xf7f7, 0x7843, 0x0090, 0x7843, 0x0010,
+	0x20a9, 0x0028, 0xa001, 0x1f04, 0x3b7a, 0x7850, 0x9085, 0x1400,
+	0x7852, 0x2019, 0x61a8, 0x7854, 0xa001, 0xa001, 0xd08c, 0x1110,
+	0x8319, 0x1dc8, 0x7827, 0x0048, 0x7850, 0x9085, 0x0400, 0x7852,
+	0x7843, 0x0040, 0x2019, 0x01f4, 0xa001, 0xa001, 0x8319, 0x1de0,
+	0x2001, 0x0100, 0x080c, 0x2987, 0x7827, 0x0020, 0x7843, 0x0000,
+	0x9006, 0x080c, 0x2987, 0x7827, 0x0048, 0x00fe, 0x0005, 0x7884,
+	0xd0ac, 0x11c8, 0x00f6, 0x00e6, 0x2071, 0x1a31, 0x2079, 0x0320,
+	0x2001, 0x0201, 0x2004, 0x9005, 0x0160, 0x7000, 0x9086, 0x0000,
+	0x1140, 0x0051, 0xd0bc, 0x0108, 0x8738, 0x7003, 0x0003, 0x782b,
+	0x0019, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0x2079, 0x0300, 0x78bc,
+	0x00fe, 0x908c, 0x0070, 0x0178, 0x2009, 0x0032, 0x260a, 0x2009,
+	0x0033, 0x250a, 0xd0b4, 0x0108, 0x8c60, 0xd0ac, 0x0108, 0x8d68,
+	0xd0a4, 0x0108, 0x8b58, 0x0005, 0x00f6, 0x2079, 0x0200, 0x781c,
+	0xd084, 0x0110, 0x7837, 0x0050, 0x00fe, 0x0005, 0x00e6, 0x2071,
+	0x0100, 0x2001, 0x1979, 0x2004, 0x70e2, 0x080c, 0x38d6, 0x1188,
+	0x2001, 0x181e, 0x2004, 0x2009, 0x181d, 0x210c, 0x918c, 0x00ff,
+	0x706e, 0x716a, 0x7066, 0x918d, 0x3200, 0x7162, 0x7073, 0xe109,
+	0x0080, 0x702c, 0x9085, 0x0002, 0x702e, 0x2009, 0x1816, 0x210c,
+	0x716e, 0x7063, 0x0100, 0x7166, 0x719e, 0x706b, 0x0000, 0x7073,
+	0x0809, 0x7077, 0x0008, 0x7078, 0x9080, 0x0100, 0x707a, 0x7080,
+	0x8000, 0x7082, 0x7087, 0xaaaa, 0x9006, 0x708a, 0x708e, 0x707e,
+	0x70d6, 0x70ab, 0x0036, 0x70af, 0x95d5, 0x7014, 0x9084, 0x1984,
+	0x9085, 0x0092, 0x7016, 0x080c, 0x3d2d, 0x00f6, 0x2071, 0x1a31,
+	0x2079, 0x0320, 0x00d6, 0x2069, 0x0000, 0x6884, 0xd0b4, 0x0120,
+	0x689c, 0x780e, 0x6898, 0x780a, 0x00de, 0x2009, 0x03e8, 0x8109,
+	0x1df0, 0x792c, 0xd1fc, 0x0110, 0x782b, 0x0004, 0x2011, 0x0011,
+	0x080c, 0x3cb9, 0x2011, 0x0001, 0x080c, 0x3cb9, 0x00fe, 0x00ee,
+	0x0005, 0x00f6, 0x00e6, 0x2071, 0x1a31, 0x2079, 0x0320, 0x792c,
+	0xd1fc, 0x0904, 0x3cb6, 0x782b, 0x0002, 0x9026, 0xd19c, 0x1904,
+	0x3cb2, 0x7000, 0x0002, 0x3cb6, 0x3c67, 0x3c97, 0x3cb2, 0xd1bc,
+	0x1170, 0xd1dc, 0x1190, 0x8001, 0x7002, 0x2011, 0x0001, 0x080c,
+	0x3cb9, 0x0904, 0x3cb6, 0x080c, 0x3cb9, 0x0804, 0x3cb6, 0x00f6,
+	0x2079, 0x0300, 0x78bf, 0x0000, 0x00fe, 0x7810, 0x7914, 0x782b,
+	0x0004, 0x7812, 0x7916, 0x2001, 0x0201, 0x200c, 0x81ff, 0x0de8,
+	0x080c, 0x3bc4, 0x2009, 0x0001, 0x00f6, 0x2079, 0x0300, 0x78b8,
+	0x00fe, 0xd0ec, 0x0110, 0x2009, 0x0011, 0x792a, 0x00f8, 0x8001,
+	0x7002, 0x9184, 0x0880, 0x1140, 0x782c, 0xd0fc, 0x1904, 0x3c5b,
+	0x2011, 0x0001, 0x00b1, 0x0090, 0xa010, 0x9092, 0x0004, 0x9086,
+	0x0015, 0x1120, 0xa000, 0xa05a, 0x2011, 0x0031, 0xa212, 0xd1dc,
+	0x1960, 0x0828, 0x782b, 0x0004, 0x7003, 0x0000, 0x00ee, 0x00fe,
+	0x0005, 0xa014, 0x9005, 0x0550, 0x8001, 0x0036, 0x0096, 0xa016,
+	0xa058, 0x2048, 0xa010, 0x2009, 0x0031, 0x911a, 0x831c, 0x831c,
+	0x938a, 0x0007, 0x1a0c, 0x0db2, 0x9398, 0x3ce7, 0x231d, 0x083f,
+	0x9080, 0x0004, 0x7a2a, 0x7100, 0x8108, 0x7102, 0x009e, 0x003e,
+	0x908a, 0x0035, 0x1140, 0x0096, 0xa058, 0x2048, 0xa804, 0xa05a,
+	0x2001, 0x0019, 0x009e, 0xa012, 0x9085, 0x0001, 0x0005, 0x3d24,
+	0x3d1b, 0x3d12, 0x3d09, 0x3d00, 0x3cf7, 0x3cee, 0xa964, 0x7902,
+	0xa968, 0x7906, 0xa96c, 0x7912, 0xa970, 0x7916, 0x0005, 0xa974,
+	0x7902, 0xa978, 0x7906, 0xa97c, 0x7912, 0xa980, 0x7916, 0x0005,
+	0xa984, 0x7902, 0xa988, 0x7906, 0xa98c, 0x7912, 0xa990, 0x7916,
+	0x0005, 0xa994, 0x7902, 0xa998, 0x7906, 0xa99c, 0x7912, 0xa9a0,
+	0x7916, 0x0005, 0xa9a4, 0x7902, 0xa9a8, 0x7906, 0xa9ac, 0x7912,
+	0xa9b0, 0x7916, 0x0005, 0xa9b4, 0x7902, 0xa9b8, 0x7906, 0xa9bc,
+	0x7912, 0xa9c0, 0x7916, 0x0005, 0xa9c4, 0x7902, 0xa9c8, 0x7906,
+	0xa9cc, 0x7912, 0xa9d0, 0x7916, 0x0005, 0x00f6, 0x00e6, 0x0086,
+	0x2071, 0x1a34, 0x2079, 0x0090, 0x792c, 0xd1fc, 0x01e8, 0x782b,
+	0x0002, 0x2940, 0x9026, 0x7000, 0x0002, 0x3d54, 0x3d40, 0x3d4b,
+	0x8001, 0x7002, 0xd19c, 0x1180, 0x2011, 0x0001, 0x080c, 0x3cb9,
+	0x190c, 0x3cb9, 0x0048, 0x8001, 0x7002, 0x782c, 0xd0fc, 0x1d38,
+	0x2011, 0x0001, 0x080c, 0x3cb9, 0x008e, 0x00ee, 0x00fe, 0x0005,
+	0x00f6, 0x00e6, 0x00c6, 0x0086, 0x2061, 0x0200, 0x2001, 0x1979,
+	0x2004, 0x601a, 0x2061, 0x0100, 0x2001, 0x1978, 0x2004, 0x60ce,
+	0x6104, 0xc1ac, 0x6106, 0x2001, 0x002c, 0x2004, 0x9005, 0x0520,
+	0x2038, 0x2001, 0x002e, 0x2024, 0x2001, 0x002f, 0x201c, 0x080c,
+	0x4612, 0xa813, 0x0019, 0xaf16, 0x2900, 0xa85a, 0x978a, 0x0007,
+	0x0220, 0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0x903e, 0x0096,
+	0xa858, 0x2048, 0xa85c, 0x9080, 0x0019, 0x009e, 0x080c, 0x3dd0,
+	0x1d68, 0x2900, 0xa85a, 0x00d0, 0x080c, 0x4612, 0xa813, 0x0019,
+	0xa817, 0x0001, 0x2900, 0xa85a, 0x2001, 0x002e, 0x2004, 0xa866,
+	0x2001, 0x002f, 0x2004, 0xa86a, 0x2001, 0x002a, 0x2004, 0x9084,
+	0xfff8, 0xa86e, 0x2001, 0x002b, 0x2004, 0xa872, 0x2061, 0x0090,
+	0x2079, 0x0100, 0x2001, 0x1978, 0x2004, 0x6036, 0x2009, 0x0040,
+	0x080c, 0x20d9, 0x2001, 0x002a, 0x2004, 0x9084, 0xfff8, 0x601a,
+	0x0006, 0x2001, 0x002b, 0x2004, 0x601e, 0x78c6, 0x000e, 0x78ca,
+	0x9006, 0x600a, 0x600e, 0x008e, 0x00ce, 0x00ee, 0x00fe, 0x0005,
+	0x00e6, 0x2071, 0x0080, 0xaa60, 0x22e8, 0x20a0, 0x20e1, 0x0000,
+	0x2099, 0x0088, 0x702b, 0x0026, 0x7402, 0x7306, 0x9006, 0x700a,
+	0x700e, 0x810b, 0x810b, 0x21a8, 0x810b, 0x7112, 0x702b, 0x0041,
+	0x702c, 0xd0fc, 0x0de8, 0x702b, 0x0002, 0x702b, 0x0040, 0x4005,
+	0x7400, 0x7304, 0x87ff, 0x0190, 0x0086, 0x0096, 0x2940, 0x0086,
+	0x080c, 0x4612, 0x008e, 0xa058, 0x00a6, 0x2050, 0x2900, 0xb006,
+	0xa05a, 0x00ae, 0x009e, 0x008e, 0x9085, 0x0001, 0x00ee, 0x0005,
+	0x00e6, 0x2001, 0x002d, 0x2004, 0x9005, 0x0528, 0x2038, 0x2001,
+	0x0030, 0x2024, 0x2001, 0x0031, 0x201c, 0x080c, 0x4612, 0x2940,
+	0xa813, 0x0019, 0xaf16, 0x2900, 0xa85a, 0x978a, 0x0007, 0x0220,
+	0x2138, 0x2009, 0x0007, 0x0010, 0x2708, 0x903e, 0x0096, 0xa858,
+	0x2048, 0xa85c, 0x9080, 0x0019, 0x009e, 0x080c, 0x3dd0, 0x1d68,
+	0x2900, 0xa85a, 0x00d8, 0x080c, 0x4612, 0x2940, 0xa013, 0x0019,
+	0xa017, 0x0001, 0x2800, 0xa05a, 0x2001, 0x0030, 0x2004, 0xa066,
+	0x2001, 0x0031, 0x2004, 0xa06a, 0x2001, 0x002a, 0x2004, 0x9084,
+	0xfff8, 0xa06e, 0x2001, 0x002b, 0x2004, 0xa072, 0x2001, 0x032a,
+	0x2003, 0x0004, 0x7884, 0xd0ac, 0x1180, 0x2001, 0x0101, 0x200c,
+	0x918d, 0x0200, 0x2102, 0xa017, 0x0000, 0x2001, 0x1a31, 0x2003,
+	0x0003, 0x2001, 0x032a, 0x2003, 0x0009, 0x2001, 0x0300, 0x2003,
+	0x0000, 0x2001, 0x020d, 0x2003, 0x0000, 0x2001, 0x0004, 0x200c,
+	0x918d, 0x0002, 0x2102, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x20a9, 0x0013, 0x20a1, 0x1840, 0x20e9, 0x0001, 0x9006, 0x4004,
+	0x2009, 0x013c, 0x200a, 0x012e, 0x7880, 0x9086, 0x0052, 0x0108,
+	0x0005, 0x0804, 0x3191, 0x7d98, 0x7c9c, 0x0804, 0x3288, 0x080c,
+	0x6c53, 0x190c, 0x59e6, 0x2069, 0x1853, 0x2d00, 0x2009, 0x0030,
+	0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001, 0x080c, 0x465b,
+	0x701f, 0x3ea3, 0x0005, 0x080c, 0x5122, 0x1130, 0x3b00, 0x3a08,
+	0xc194, 0xc095, 0x20d8, 0x21d0, 0x2069, 0x1853, 0x6800, 0x9005,
+	0x0904, 0x31c6, 0x6804, 0xd0ac, 0x0118, 0xd0a4, 0x0904, 0x31c6,
+	0xd094, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0138, 0x6200, 0x9292,
+	0x0005, 0x0218, 0x918c, 0xffdf, 0x0010, 0x918d, 0x0020, 0x6106,
+	0x00ce, 0xd08c, 0x00c6, 0x2061, 0x0100, 0x6104, 0x0118, 0x918d,
+	0x0010, 0x0010, 0x918c, 0xffef, 0x6106, 0x00ce, 0xd084, 0x0158,
+	0x6a28, 0x928a, 0x007f, 0x1a04, 0x31c6, 0x9288, 0x2f92, 0x210d,
+	0x918c, 0x00ff, 0x615e, 0xd0dc, 0x0130, 0x6828, 0x908a, 0x007f,
+	0x1a04, 0x31c6, 0x6056, 0x6888, 0x9084, 0x0030, 0x8004, 0x8004,
+	0x8004, 0x8004, 0x0006, 0x2009, 0x1980, 0x9080, 0x2612, 0x2005,
+	0x200a, 0x000e, 0x2009, 0x1981, 0x9080, 0x2616, 0x2005, 0x200a,
+	0x6808, 0x908a, 0x0100, 0x0a04, 0x31c6, 0x908a, 0x0841, 0x1a04,
+	0x31c6, 0x9084, 0x0007, 0x1904, 0x31c6, 0x680c, 0x9005, 0x0904,
+	0x31c6, 0x6810, 0x9005, 0x0904, 0x31c6, 0x6848, 0x6940, 0x910a,
+	0x1a04, 0x31c6, 0x8001, 0x0904, 0x31c6, 0x684c, 0x6944, 0x910a,
+	0x1a04, 0x31c6, 0x8001, 0x0904, 0x31c6, 0x2009, 0x1950, 0x200b,
+	0x0000, 0x2001, 0x1875, 0x2004, 0xd0c4, 0x0140, 0x7884, 0x200a,
+	0x2009, 0x017f, 0x200a, 0x3b00, 0xc085, 0x20d8, 0x6814, 0x908c,
+	0x00ff, 0x6146, 0x8007, 0x9084, 0x00ff, 0x604a, 0x080c, 0x6f5b,
+	0x080c, 0x62da, 0x080c, 0x630e, 0x6808, 0x602a, 0x080c, 0x204b,
+	0x2009, 0x0170, 0x200b, 0x0080, 0xa001, 0xa001, 0x200b, 0x0000,
+	0x0036, 0x6b08, 0x080c, 0x2579, 0x003e, 0x6000, 0x9086, 0x0000,
+	0x1904, 0x403f, 0x6818, 0x691c, 0x6a20, 0x6b24, 0x8007, 0x810f,
+	0x8217, 0x831f, 0x6016, 0x611a, 0x621e, 0x6322, 0x6c04, 0xd4f4,
+	0x0148, 0x6830, 0x6934, 0x6a38, 0x6b3c, 0x8007, 0x810f, 0x8217,
+	0x831f, 0x0010, 0x9084, 0xf0ff, 0x6006, 0x610a, 0x620e, 0x6312,
+	0x8007, 0x810f, 0x8217, 0x831f, 0x20a9, 0x0004, 0x20a1, 0x1982,
+	0x20e9, 0x0001, 0x4001, 0x20a9, 0x0004, 0x20a1, 0x199c, 0x20e9,
+	0x0001, 0x4001, 0x080c, 0x7d50, 0x00c6, 0x900e, 0x20a9, 0x0001,
+	0x6b70, 0xd384, 0x0510, 0x0068, 0x2009, 0x0100, 0x210c, 0x918e,
+	0x0008, 0x1110, 0x839d, 0x0010, 0x83f5, 0x3e18, 0x12b0, 0x3508,
+	0x8109, 0x080c, 0x74e0, 0x6878, 0x6016, 0x6874, 0x2008, 0x9084,
+	0xff00, 0x8007, 0x600a, 0x9184, 0x00ff, 0x6006, 0x8108, 0x1118,
+	0x6003, 0x0003, 0x0010, 0x6003, 0x0001, 0x1f04, 0x3f94, 0x00ce,
+	0x00c6, 0x2061, 0x196b, 0x6a88, 0x9284, 0xc000, 0x2010, 0x9286,
+	0x0000, 0x1158, 0x2063, 0x0000, 0x2001, 0x0001, 0x080c, 0x2820,
+	0x2001, 0x0001, 0x080c, 0x2803, 0x0088, 0x9286, 0x4000, 0x1148,
+	0x2063, 0x0001, 0x9006, 0x080c, 0x2820, 0x9006, 0x080c, 0x2803,
+	0x0028, 0x9286, 0x8000, 0x1d30, 0x2063, 0x0002, 0x00ce, 0x00e6,
+	0x2c70, 0x080c, 0x0e69, 0x00ee, 0x6888, 0xd0ec, 0x0130, 0x2011,
+	0x0114, 0x2204, 0x9085, 0x0100, 0x2012, 0x6a80, 0x9284, 0x0030,
+	0x9086, 0x0030, 0x1128, 0x9294, 0xffcf, 0x9295, 0x0020, 0x6a82,
+	0x2001, 0x194d, 0x6a80, 0x9294, 0x0030, 0x928e, 0x0000, 0x0170,
+	0x928e, 0x0010, 0x0118, 0x928e, 0x0020, 0x0140, 0x2003, 0xaaaa,
+	0x080c, 0x25ee, 0x2001, 0x193e, 0x2102, 0x0008, 0x2102, 0x00c6,
+	0x2061, 0x0100, 0x602f, 0x0040, 0x602f, 0x0000, 0x00ce, 0x080c,
+	0x6c53, 0x0128, 0x080c, 0x4a2e, 0x0110, 0x080c, 0x253f, 0x60cc,
+	0x9005, 0x01c0, 0x6003, 0x0001, 0x2009, 0x4027, 0x00d0, 0x080c,
+	0x6c53, 0x1168, 0x2011, 0x6ad9, 0x080c, 0x7c4a, 0x2011, 0x6acc,
+	0x080c, 0x7d1b, 0x080c, 0x6f2f, 0x080c, 0x6b8a, 0x0040, 0x080c,
+	0x58e0, 0x0028, 0x6003, 0x0004, 0x2009, 0x403f, 0x0010, 0x0804,
+	0x3191, 0x2001, 0x0170, 0x2004, 0x9084, 0x00ff, 0x9086, 0x004c,
+	0x1118, 0x2091, 0x30bd, 0x0817, 0x2091, 0x303d, 0x0817, 0x6000,
+	0x9086, 0x0000, 0x0904, 0x31c3, 0x2069, 0x1853, 0x7890, 0x6842,
+	0x7894, 0x6846, 0x2d00, 0x2009, 0x0030, 0x7a8c, 0x7b88, 0x7c9c,
+	0x7d98, 0x2039, 0x0001, 0x0804, 0x465e, 0x9006, 0x080c, 0x253f,
+	0x81ff, 0x1904, 0x31c3, 0x080c, 0x6c53, 0x11b0, 0x080c, 0x6f2a,
+	0x080c, 0x5a21, 0x080c, 0x2f86, 0x0118, 0x6130, 0xc18d, 0x6132,
+	0x080c, 0xbcec, 0x0130, 0x080c, 0x6c76, 0x1118, 0x080c, 0x6c2d,
+	0x0038, 0x080c, 0x6b8a, 0x0020, 0x080c, 0x59e6, 0x080c, 0x58e0,
+	0x0804, 0x3191, 0x81ff, 0x1904, 0x31c3, 0x080c, 0x6c53, 0x1110,
+	0x0804, 0x31c3, 0x618c, 0x81ff, 0x01a8, 0x704f, 0x0000, 0x2001,
+	0x1c80, 0x2009, 0x0040, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x0126,
+	0x2091, 0x8000, 0x2039, 0x0001, 0x080c, 0x465e, 0x701f, 0x318f,
+	0x012e, 0x0005, 0x704f, 0x0001, 0x00d6, 0x2069, 0x1c80, 0x20a9,
+	0x0040, 0x20e9, 0x0001, 0x20a1, 0x1c80, 0x2019, 0xffff, 0x4304,
+	0x6554, 0x9588, 0x2f92, 0x210d, 0x918c, 0x00ff, 0x216a, 0x900e,
+	0x2011, 0x0002, 0x2100, 0x9506, 0x01a8, 0x080c, 0x5f7e, 0x1190,
+	0xb814, 0x821c, 0x0238, 0x9398, 0x1c80, 0x9085, 0xff00, 0x8007,
+	0x201a, 0x0038, 0x9398, 0x1c80, 0x2324, 0x94a4, 0xff00, 0x9405,
+	0x201a, 0x8210, 0x8108, 0x9182, 0x0080, 0x1208, 0x0c18, 0x8201,
+	0x8007, 0x2d0c, 0x9105, 0x206a, 0x00de, 0x20a9, 0x0040, 0x20a1,
+	0x1c80, 0x2099, 0x1c80, 0x080c, 0x5971, 0x0804, 0x4097, 0x080c,
+	0x4645, 0x0904, 0x31c6, 0x080c, 0x4612, 0x1120, 0x2009, 0x0002,
+	0x0804, 0x31c3, 0x080c, 0x5113, 0xd0b4, 0x0558, 0x7884, 0x908e,
+	0x007e, 0x0538, 0x908e, 0x007f, 0x0520, 0x908e, 0x0080, 0x0508,
+	0x080c, 0x2f81, 0x1148, 0xb800, 0xd08c, 0x11d8, 0xb804, 0x9084,
+	0x00ff, 0x9086, 0x0006, 0x11a8, 0xa867, 0x0000, 0xa868, 0xc0fd,
+	0xa86a, 0x080c, 0xb7bd, 0x1120, 0x2009, 0x0003, 0x0804, 0x31c3,
+	0x7007, 0x0003, 0x701f, 0x4125, 0x0005, 0x080c, 0x4645, 0x0904,
+	0x31c6, 0x20a9, 0x002b, 0xb8b4, 0x20e0, 0xb8b8, 0x2098, 0xa860,
+	0x20e8, 0xa85c, 0x9080, 0x0002, 0x20a0, 0x4003, 0x20a9, 0x0008,
+	0x9080, 0x0006, 0x20a0, 0xb8b4, 0x20e0, 0xb8b8, 0x9080, 0x0006,
+	0x2098, 0x080c, 0x0f52, 0x0070, 0x20a9, 0x0004, 0xa85c, 0x9080,
+	0x000a, 0x20a0, 0xb8b4, 0x20e0, 0xb8b8, 0x9080, 0x000a, 0x2098,
+	0x080c, 0x0f52, 0x8906, 0x8006, 0x8007, 0x90bc, 0x003f, 0x9084,
+	0xffc0, 0x9080, 0x0002, 0x2009, 0x002b, 0x7a8c, 0x7b88, 0x7c9c,
+	0x7d98, 0x0804, 0x465e, 0x81ff, 0x1904, 0x31c3, 0x080c, 0x4629,
+	0x0904, 0x31c6, 0x080c, 0x60f0, 0x0904, 0x31c3, 0x0058, 0xa878,
+	0x9005, 0x0120, 0x2009, 0x0004, 0x0804, 0x31c3, 0xa974, 0xaa94,
+	0x0804, 0x3191, 0x080c, 0x511b, 0x0904, 0x3191, 0x701f, 0x416f,
+	0x7007, 0x0003, 0x0005, 0x81ff, 0x1904, 0x31c3, 0x7888, 0x908a,
+	0x1000, 0x1a04, 0x31c6, 0x080c, 0x4645, 0x0904, 0x31c6, 0x080c,
+	0x62a4, 0x0120, 0x080c, 0x62ac, 0x1904, 0x31c6, 0x080c, 0x6175,
+	0x0904, 0x31c3, 0x2019, 0x0004, 0x900e, 0x080c, 0x6102, 0x0904,
+	0x31c3, 0x7984, 0x7a88, 0x04c9, 0x08a8, 0xa89c, 0x908a, 0x1000,
+	0x12f8, 0x080c, 0x4643, 0x01e0, 0x080c, 0x62a4, 0x0118, 0x080c,
+	0x62ac, 0x11b0, 0x080c, 0x6175, 0x2009, 0x0002, 0x0168, 0x2009,
+	0x0002, 0x2019, 0x0004, 0x080c, 0x6102, 0x2009, 0x0003, 0x0120,
+	0xa998, 0xaa9c, 0x00d1, 0x0060, 0xa897, 0x4005, 0xa99a, 0x0010,
+	0xa897, 0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030, 0x0005,
+	0xa897, 0x4000, 0x080c, 0x511b, 0x0110, 0x9006, 0x0018, 0x900e,
+	0x9085, 0x0001, 0x2001, 0x0000, 0x0005, 0x9186, 0x00ff, 0x0110,
+	0x0071, 0x0060, 0x2029, 0x007e, 0x2061, 0x1800, 0x6454, 0x2400,
+	0x9506, 0x0110, 0x2508, 0x0019, 0x8529, 0x1ec8, 0x0005, 0x080c,
+	0x5f7e, 0x1138, 0x2200, 0x8003, 0x800b, 0x810b, 0x9108, 0x080c,
+	0x7c58, 0x0005, 0x81ff, 0x1904, 0x31c3, 0x080c, 0x4629, 0x0904,
+	0x31c6, 0x080c, 0x6045, 0x0904, 0x31c3, 0x080c, 0x60f9, 0x0904,
+	0x31c3, 0x0804, 0x417a, 0x81ff, 0x1904, 0x31c3, 0x080c, 0x4629,
+	0x0904, 0x31c6, 0x080c, 0x6045, 0x0904, 0x31c3, 0x080c, 0x60e7,
+	0x0904, 0x31c3, 0x0804, 0x417a, 0x6100, 0x0804, 0x3191, 0x080c,
+	0x4645, 0x0904, 0x31c6, 0x080c, 0x5127, 0x1904, 0x31c3, 0x79a8,
+	0xd184, 0x1158, 0xb834, 0x8007, 0x789e, 0xb830, 0x8007, 0x789a,
+	0xbb2c, 0x831f, 0xba28, 0x8217, 0x0050, 0xb824, 0x8007, 0x789e,
+	0xb820, 0x8007, 0x789a, 0xbb1c, 0x831f, 0xba18, 0x8217, 0xb900,
+	0x918c, 0x0200, 0x0804, 0x3191, 0x78a8, 0x909c, 0x0003, 0xd0b4,
+	0x1140, 0x939a, 0x0003, 0x1a04, 0x31c3, 0x6254, 0x7884, 0x9206,
+	0x1560, 0x2031, 0x1848, 0x2009, 0x013c, 0x2136, 0x2001, 0x1840,
+	0x2009, 0x000c, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x2039, 0x0001,
+	0x0006, 0x78a8, 0x9084, 0x0080, 0x1118, 0x000e, 0x0804, 0x465e,
+	0x000e, 0x2031, 0x0000, 0x2061, 0x18ae, 0x2c44, 0xa66a, 0xa17a,
+	0xa772, 0xa076, 0xa28e, 0xa392, 0xa496, 0xa59a, 0x080c, 0x10b5,
+	0x7007, 0x0002, 0x701f, 0x429d, 0x0005, 0x81ff, 0x1904, 0x31c3,
+	0x080c, 0x4645, 0x0904, 0x31c6, 0x080c, 0x62a4, 0x1904, 0x31c3,
+	0x00c6, 0x080c, 0x4612, 0x00ce, 0x0904, 0x31c3, 0xa867, 0x0000,
+	0xa868, 0xc0fd, 0xa86a, 0x7ea8, 0x080c, 0xb763, 0x0904, 0x31c3,
+	0x7007, 0x0003, 0x701f, 0x42a1, 0x0005, 0x080c, 0x3e75, 0x0804,
+	0x3191, 0xa830, 0x9086, 0x0100, 0x0904, 0x31c3, 0x8906, 0x8006,
+	0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080, 0x001b, 0x2009,
+	0x000c, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x0804, 0x465e, 0x9006,
+	0x080c, 0x253f, 0x78a8, 0x9084, 0x00ff, 0x9086, 0x00ff, 0x0118,
+	0x81ff, 0x1904, 0x31c3, 0x080c, 0x6c53, 0x0110, 0x080c, 0x59e6,
+	0x7888, 0x908a, 0x1000, 0x1a04, 0x31c6, 0x7984, 0x9186, 0x00ff,
+	0x0138, 0x9182, 0x007f, 0x1a04, 0x31c6, 0x2100, 0x080c, 0x2509,
+	0x0026, 0x00c6, 0x0126, 0x2091, 0x8000, 0x2061, 0x19c9, 0x601b,
+	0x0000, 0x601f, 0x0000, 0x6073, 0x0000, 0x6077, 0x0000, 0x080c,
+	0x6c53, 0x1158, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x9085, 0x0001,
+	0x080c, 0x6c9a, 0x080c, 0x6b8a, 0x00d0, 0x080c, 0x9947, 0x2061,
+	0x0100, 0x2001, 0x1816, 0x2004, 0x9084, 0x00ff, 0x810f, 0x9105,
+	0x604a, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x1968, 0x200b,
+	0x0000, 0x2009, 0x002d, 0x2011, 0x590c, 0x080c, 0x7cd9, 0x7984,
+	0x080c, 0x6c53, 0x1110, 0x2009, 0x00ff, 0x7a88, 0x080c, 0x41dd,
+	0x012e, 0x00ce, 0x002e, 0x0804, 0x3191, 0x7984, 0x080c, 0x5f1e,
+	0x2b08, 0x1904, 0x31c6, 0x0804, 0x3191, 0x81ff, 0x0120, 0x2009,
+	0x0001, 0x0804, 0x31c3, 0x60d4, 0xd0ac, 0x1130, 0xd09c, 0x1120,
+	0x2009, 0x0005, 0x0804, 0x31c3, 0x080c, 0x4612, 0x1120, 0x2009,
+	0x0002, 0x0804, 0x31c3, 0x7984, 0x9192, 0x0021, 0x1a04, 0x31c6,
+	0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0xa85c, 0x9080, 0x0019, 0x702a,
+	0xaf60, 0x7736, 0x080c, 0x465b, 0x701f, 0x4355, 0x7880, 0x9086,
+	0x006e, 0x0110, 0x701f, 0x4be0, 0x0005, 0x2009, 0x0080, 0x080c,
+	0x5f7e, 0x1118, 0x080c, 0x62a4, 0x0120, 0x2021, 0x400a, 0x0804,
+	0x3193, 0x00d6, 0x0096, 0xa964, 0xaa6c, 0xab70, 0xac74, 0xad78,
+	0xae7c, 0xa884, 0x90be, 0x0100, 0x0904, 0x43ee, 0x90be, 0x0112,
+	0x0904, 0x43ee, 0x90be, 0x0113, 0x0904, 0x43ee, 0x90be, 0x0114,
+	0x0904, 0x43ee, 0x90be, 0x0117, 0x0904, 0x43ee, 0x90be, 0x011a,
+	0x0904, 0x43ee, 0x90be, 0x011c, 0x0904, 0x43ee, 0x90be, 0x0121,
+	0x0904, 0x43d5, 0x90be, 0x0131, 0x0904, 0x43d5, 0x90be, 0x0171,
+	0x0904, 0x43ee, 0x90be, 0x0173, 0x0904, 0x43ee, 0x90be, 0x01a1,
+	0x1128, 0xa894, 0x8007, 0xa896, 0x0804, 0x43f9, 0x90be, 0x0212,
+	0x0904, 0x43e2, 0x90be, 0x0213, 0x05e8, 0x90be, 0x0214, 0x0500,
+	0x90be, 0x0217, 0x0188, 0x90be, 0x021a, 0x1120, 0xa89c, 0x8007,
+	0xa89e, 0x04e0, 0x90be, 0x021f, 0x05c8, 0x90be, 0x0300, 0x05b0,
+	0x009e, 0x00de, 0x0804, 0x31c6, 0x7028, 0x9080, 0x0010, 0x2098,
+	0x20a0, 0x7034, 0x20e0, 0x20e8, 0x20a9, 0x0007, 0x080c, 0x4437,
+	0x7028, 0x9080, 0x000e, 0x2098, 0x20a0, 0x7034, 0x20e0, 0x20e8,
+	0x20a9, 0x0001, 0x080c, 0x4437, 0x00c8, 0x7028, 0x9080, 0x000c,
+	0x2098, 0x20a0, 0x7034, 0x20e0, 0x20e8, 0x20a9, 0x0001, 0x080c,
+	0x4444, 0x00b8, 0x7028, 0x9080, 0x000e, 0x2098, 0x20a0, 0x7034,
+	0x20e0, 0x20e8, 0x20a9, 0x0001, 0x080c, 0x4444, 0x7028, 0x9080,
+	0x000c, 0x2098, 0x20a0, 0x7034, 0x20e0, 0x20e8, 0x20a9, 0x0001,
+	0x04f1, 0x00c6, 0x080c, 0x4612, 0x0550, 0xa868, 0xc0fd, 0xa86a,
+	0xa867, 0x0119, 0x9006, 0xa882, 0xa87f, 0x0020, 0xa88b, 0x0001,
+	0x810b, 0xa9ae, 0xa8b2, 0xaab6, 0xabba, 0xacbe, 0xadc2, 0xa9c6,
+	0xa8ca, 0x00ce, 0x009e, 0x00de, 0xa866, 0xa822, 0xa868, 0xc0fd,
+	0xa86a, 0xa804, 0x2048, 0x080c, 0xb77e, 0x1120, 0x2009, 0x0003,
+	0x0804, 0x31c3, 0x7007, 0x0003, 0x701f, 0x442e, 0x0005, 0x00ce,
+	0x009e, 0x00de, 0x2009, 0x0002, 0x0804, 0x31c3, 0xa820, 0x9086,
+	0x8001, 0x1904, 0x3191, 0x2009, 0x0004, 0x0804, 0x31c3, 0x0016,
+	0x0026, 0x3510, 0x20a9, 0x0002, 0x4002, 0x4104, 0x4004, 0x8211,
+	0x1dc8, 0x002e, 0x001e, 0x0005, 0x0016, 0x0026, 0x0036, 0x0046,
+	0x3520, 0x20a9, 0x0004, 0x4002, 0x4304, 0x4204, 0x4104, 0x4004,
+	0x8421, 0x1db8, 0x004e, 0x003e, 0x002e, 0x001e, 0x0005, 0x81ff,
+	0x0120, 0x2009, 0x0001, 0x0804, 0x31c3, 0x60d4, 0xd0ac, 0x1130,
+	0xd09c, 0x1120, 0x2009, 0x0005, 0x0804, 0x31c3, 0x7984, 0x78a8,
+	0x2040, 0x080c, 0x9940, 0x1120, 0x9182, 0x007f, 0x0a04, 0x31c6,
+	0x9186, 0x00ff, 0x0904, 0x31c6, 0x9182, 0x0800, 0x1a04, 0x31c6,
+	0x7a8c, 0x7b88, 0x6074, 0x9306, 0x1140, 0x6078, 0x924e, 0x0904,
+	0x31c6, 0x99cc, 0xff00, 0x0904, 0x31c6, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x452c, 0x0560, 0x90c6, 0x4000, 0x1170, 0x00c6, 0x0006,
+	0x900e, 0x080c, 0x619e, 0x1108, 0xc185, 0xb800, 0xd0bc, 0x0108,
+	0xc18d, 0x000e, 0x00ce, 0x00b8, 0x90c6, 0x4007, 0x1110, 0x2408,
+	0x0090, 0x90c6, 0x4008, 0x1118, 0x2708, 0x2610, 0x0060, 0x90c6,
+	0x4009, 0x1108, 0x0040, 0x90c6, 0x4006, 0x1108, 0x0020, 0x2001,
+	0x4005, 0x2009, 0x000a, 0x2020, 0x012e, 0x0804, 0x3193, 0x2b00,
+	0x7026, 0x0016, 0x00b6, 0x00c6, 0x00e6, 0x2c70, 0x080c, 0x9a23,
+	0x0904, 0x4501, 0x2b00, 0x6012, 0x080c, 0xba69, 0x2e58, 0x00ee,
+	0x00e6, 0x00c6, 0x080c, 0x4612, 0x00ce, 0x2b70, 0x1158, 0x080c,
+	0x99d6, 0x00ee, 0x00ce, 0x00be, 0x001e, 0x012e, 0x2009, 0x0002,
+	0x0804, 0x31c3, 0x900e, 0xa966, 0xa96a, 0x2900, 0x6016, 0xa932,
+	0xa868, 0xc0fd, 0xd88c, 0x0108, 0xc0f5, 0xa86a, 0x080c, 0x2e30,
+	0x6023, 0x0001, 0x9006, 0x080c, 0x5ebb, 0x2001, 0x0002, 0x080c,
+	0x5ecf, 0x2009, 0x0002, 0x080c, 0x9a50, 0x78a8, 0xd094, 0x0138,
+	0x00ee, 0x7024, 0x00e6, 0x2058, 0xb8bc, 0xc08d, 0xb8be, 0x9085,
+	0x0001, 0x00ee, 0x00ce, 0x00be, 0x001e, 0x012e, 0x1120, 0x2009,
+	0x0003, 0x0804, 0x31c3, 0x7007, 0x0003, 0x701f, 0x4510, 0x0005,
+	0xa830, 0x9086, 0x0100, 0x7024, 0x2058, 0x1138, 0x2009, 0x0004,
+	0xba04, 0x9294, 0x00ff, 0x0804, 0x5070, 0x900e, 0xa868, 0xd0f4,
+	0x1904, 0x3191, 0x080c, 0x619e, 0x1108, 0xc185, 0xb800, 0xd0bc,
+	0x0108, 0xc18d, 0x0804, 0x3191, 0x00e6, 0x00d6, 0x0096, 0x83ff,
+	0x0904, 0x4574, 0x902e, 0x080c, 0x9940, 0x0130, 0x9026, 0x20a9,
+	0x0800, 0x2071, 0x1000, 0x0030, 0x2021, 0x007f, 0x20a9, 0x0781,
+	0x2071, 0x107f, 0x2e04, 0x9005, 0x11b0, 0x2100, 0x9406, 0x15e8,
+	0x2428, 0x94ce, 0x007f, 0x1120, 0x92ce, 0xfffd, 0x1528, 0x0030,
+	0x94ce, 0x0080, 0x1130, 0x92ce, 0xfffc, 0x11f0, 0x93ce, 0x00ff,
+	0x11d8, 0xc5fd, 0x0450, 0x2058, 0xbf10, 0x2700, 0x9306, 0x11b8,
+	0xbe14, 0x2600, 0x9206, 0x1198, 0x2400, 0x9106, 0x1150, 0xd884,
+	0x0568, 0xd894, 0x1558, 0x080c, 0x62a4, 0x1540, 0x2001, 0x4000,
+	0x0430, 0x2001, 0x4007, 0x0418, 0x2001, 0x4006, 0x0400, 0x2400,
+	0x9106, 0x1158, 0xbe14, 0x87ff, 0x1128, 0x86ff, 0x0948, 0x080c,
+	0x9940, 0x1930, 0x2001, 0x4008, 0x0090, 0x8420, 0x8e70, 0x1f04,
+	0x4542, 0x85ff, 0x1130, 0x2001, 0x4009, 0x0048, 0x2001, 0x0001,
+	0x0030, 0x080c, 0x5f1e, 0x1dd0, 0xbb12, 0xba16, 0x9006, 0x9005,
+	0x009e, 0x00de, 0x00ee, 0x0005, 0x81ff, 0x0120, 0x2009, 0x0001,
+	0x0804, 0x31c3, 0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804,
+	0x31c3, 0xa867, 0x0000, 0xa868, 0xc0fd, 0xa86a, 0x7884, 0x9005,
+	0x0904, 0x31c6, 0x9096, 0x00ff, 0x0120, 0x9092, 0x0004, 0x1a04,
+	0x31c6, 0x2010, 0x2918, 0x080c, 0x2dd6, 0x1120, 0x2009, 0x0003,
+	0x0804, 0x31c3, 0x7007, 0x0003, 0x701f, 0x45c7, 0x0005, 0xa830,
+	0x9086, 0x0100, 0x1904, 0x3191, 0x2009, 0x0004, 0x0804, 0x31c3,
+	0x7984, 0x080c, 0x9940, 0x1120, 0x9182, 0x007f, 0x0a04, 0x31c6,
+	0x9186, 0x00ff, 0x0904, 0x31c6, 0x9182, 0x0800, 0x1a04, 0x31c6,
+	0x2001, 0x9000, 0x080c, 0x50cb, 0x1904, 0x31c3, 0x0804, 0x3191,
+	0xa998, 0x080c, 0x9940, 0x1118, 0x9182, 0x007f, 0x0280, 0x9186,
+	0x00ff, 0x0168, 0x9182, 0x0800, 0x1250, 0x2001, 0x9000, 0x080c,
+	0x50cb, 0x11a8, 0x0060, 0xa897, 0x4005, 0xa99a, 0x0010, 0xa897,
+	0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030, 0x0005, 0xa897,
+	0x4000, 0x900e, 0x9085, 0x0001, 0x2001, 0x0000, 0x0005, 0x2009,
+	0x000a, 0x0c48, 0x080c, 0x0fd5, 0x0198, 0x9006, 0xa802, 0x7014,
+	0x9005, 0x1120, 0x2900, 0x7016, 0x701a, 0x0040, 0x7018, 0xa802,
+	0x0086, 0x2040, 0x2900, 0xa006, 0x701a, 0x008e, 0x9085, 0x0001,
+	0x0005, 0x7984, 0x080c, 0x5f7e, 0x1130, 0x7e88, 0x9684, 0x3fff,
+	0x9082, 0x4000, 0x0208, 0x905e, 0x8bff, 0x0005, 0xa998, 0x080c,
+	0x5f7e, 0x1130, 0xae9c, 0x9684, 0x3fff, 0x9082, 0x4000, 0x0208,
+	0x905e, 0x8bff, 0x0005, 0xae98, 0x0008, 0x7e84, 0x2608, 0x080c,
+	0x5f7e, 0x1108, 0x0008, 0x905e, 0x8bff, 0x0005, 0x0016, 0x7114,
+	0x81ff, 0x0128, 0x2148, 0xa904, 0x080c, 0x1007, 0x0cc8, 0x7116,
+	0x711a, 0x001e, 0x0005, 0x2031, 0x0001, 0x0010, 0x2031, 0x0000,
+	0x2061, 0x18ae, 0x2c44, 0xa66a, 0xa17a, 0xa772, 0xa076, 0xa28e,
+	0xa392, 0xa496, 0xa59a, 0x080c, 0x10b5, 0x7007, 0x0002, 0x701f,
+	0x3191, 0x0005, 0x00f6, 0x0126, 0x2091, 0x8000, 0x2079, 0x0000,
+	0x2001, 0x18a6, 0x2004, 0x9005, 0x1190, 0x0e04, 0x468f, 0x7a36,
+	0x7833, 0x0012, 0x7a82, 0x7b86, 0x7c8a, 0x2091, 0x4080, 0x2001,
+	0x0089, 0x2004, 0xd084, 0x190c, 0x1167, 0x0804, 0x46f5, 0x0016,
+	0x0086, 0x0096, 0x00c6, 0x00e6, 0x2071, 0x1894, 0x7044, 0x9005,
+	0x1540, 0x7148, 0x9182, 0x0010, 0x0288, 0x7038, 0x2060, 0x080c,
+	0x0fd5, 0x0904, 0x46ed, 0xa84b, 0x0000, 0x2900, 0x7046, 0x2001,
+	0x0002, 0x9080, 0x1da2, 0x2005, 0xa846, 0x0098, 0x7038, 0x90e0,
+	0x0004, 0x2001, 0x18b0, 0x9c82, 0x18f0, 0x0210, 0x2061, 0x18b0,
+	0x2c00, 0x703a, 0x7148, 0x81ff, 0x1108, 0x703e, 0x8108, 0x714a,
+	0x0460, 0x7148, 0x8108, 0x714a, 0x7044, 0x2040, 0xa144, 0x2105,
+	0x0016, 0x908a, 0x0036, 0x1a0c, 0x0db2, 0x2060, 0x001e, 0x8108,
+	0x2105, 0x9005, 0xa146, 0x1520, 0x080c, 0x0fd5, 0x1130, 0x8109,
+	0xa946, 0x7148, 0x8109, 0x714a, 0x00d8, 0x9006, 0xa806, 0xa84a,
+	0xa046, 0x2800, 0xa802, 0x2900, 0xa006, 0x7046, 0x2001, 0x0002,
+	0x9080, 0x1da2, 0x2005, 0xa846, 0x0058, 0x2262, 0x6306, 0x640a,
+	0x00ee, 0x00ce, 0x009e, 0x008e, 0x001e, 0x012e, 0x00fe, 0x0005,
+	0x2c00, 0x9082, 0x001b, 0x0002, 0x4717, 0x4717, 0x4719, 0x4717,
+	0x4717, 0x4717, 0x471d, 0x4717, 0x4717, 0x4717, 0x4721, 0x4717,
+	0x4717, 0x4717, 0x4725, 0x4717, 0x4717, 0x4717, 0x4729, 0x4717,
+	0x4717, 0x4717, 0x472d, 0x4717, 0x4717, 0x4717, 0x4732, 0x080c,
+	0x0db2, 0xa276, 0xa37a, 0xa47e, 0x0898, 0xa286, 0xa38a, 0xa48e,
+	0x0878, 0xa296, 0xa39a, 0xa49e, 0x0858, 0xa2a6, 0xa3aa, 0xa4ae,
+	0x0838, 0xa2b6, 0xa3ba, 0xa4be, 0x0818, 0xa2c6, 0xa3ca, 0xa4ce,
+	0x0804, 0x46f0, 0xa2d6, 0xa3da, 0xa4de, 0x0804, 0x46f0, 0x00e6,
+	0x2071, 0x1894, 0x7048, 0x9005, 0x0904, 0x47c9, 0x0126, 0x2091,
+	0x8000, 0x0e04, 0x47c8, 0x00f6, 0x2079, 0x0000, 0x00c6, 0x0096,
+	0x0086, 0x0076, 0x9006, 0x2038, 0x7040, 0x2048, 0x9005, 0x0500,
+	0xa948, 0x2105, 0x0016, 0x908a, 0x0036, 0x1a0c, 0x0db2, 0x2060,
+	0x001e, 0x8108, 0x2105, 0x9005, 0xa94a, 0x1904, 0x47cb, 0xa804,
+	0x9005, 0x090c, 0x0db2, 0x7042, 0x2938, 0x2040, 0xa003, 0x0000,
+	0x2001, 0x0002, 0x9080, 0x1da2, 0x2005, 0xa04a, 0x0804, 0x47cb,
+	0x703c, 0x2060, 0x2c14, 0x6304, 0x6408, 0x650c, 0x2200, 0x7836,
+	0x7833, 0x0012, 0x7882, 0x2300, 0x7886, 0x2400, 0x788a, 0x2091,
+	0x4080, 0x2001, 0x0089, 0x2004, 0xd084, 0x190c, 0x1167, 0x87ff,
+	0x0118, 0x2748, 0x080c, 0x1007, 0x7048, 0x8001, 0x704a, 0x9005,
+	0x1170, 0x7040, 0x2048, 0x9005, 0x0128, 0x080c, 0x1007, 0x9006,
+	0x7042, 0x7046, 0x703b, 0x18b0, 0x703f, 0x18b0, 0x0420, 0x7040,
+	0x9005, 0x1508, 0x7238, 0x2c00, 0x9206, 0x0148, 0x9c80, 0x0004,
+	0x90fa, 0x18f0, 0x0210, 0x2001, 0x18b0, 0x703e, 0x00a0, 0x9006,
+	0x703e, 0x703a, 0x7044, 0x9005, 0x090c, 0x0db2, 0x2048, 0xa800,
+	0x9005, 0x1de0, 0x2900, 0x7042, 0x2001, 0x0002, 0x9080, 0x1da2,
+	0x2005, 0xa84a, 0x0000, 0x007e, 0x008e, 0x009e, 0x00ce, 0x00fe,
+	0x012e, 0x00ee, 0x0005, 0x2c00, 0x9082, 0x001b, 0x0002, 0x47ea,
+	0x47ea, 0x47ec, 0x47ea, 0x47ea, 0x47ea, 0x47f1, 0x47ea, 0x47ea,
+	0x47ea, 0x47f6, 0x47ea, 0x47ea, 0x47ea, 0x47fb, 0x47ea, 0x47ea,
+	0x47ea, 0x4800, 0x47ea, 0x47ea, 0x47ea, 0x4805, 0x47ea, 0x47ea,
+	0x47ea, 0x480a, 0x080c, 0x0db2, 0xaa74, 0xab78, 0xac7c, 0x0804,
+	0x4776, 0xaa84, 0xab88, 0xac8c, 0x0804, 0x4776, 0xaa94, 0xab98,
+	0xac9c, 0x0804, 0x4776, 0xaaa4, 0xaba8, 0xacac, 0x0804, 0x4776,
+	0xaab4, 0xabb8, 0xacbc, 0x0804, 0x4776, 0xaac4, 0xabc8, 0xaccc,
+	0x0804, 0x4776, 0xaad4, 0xabd8, 0xacdc, 0x0804, 0x4776, 0x0016,
+	0x0026, 0x0036, 0x00b6, 0x00c6, 0x2009, 0x007e, 0x080c, 0x5f7e,
+	0x2019, 0x0001, 0xb85c, 0xd0ac, 0x0110, 0x2019, 0x0000, 0x2011,
+	0x801b, 0x080c, 0x4672, 0x00ce, 0x00be, 0x003e, 0x002e, 0x001e,
+	0x0005, 0x0026, 0x080c, 0x5113, 0xd0c4, 0x0120, 0x2011, 0x8014,
+	0x080c, 0x4672, 0x002e, 0x0005, 0x81ff, 0x1904, 0x31c3, 0x0126,
+	0x2091, 0x8000, 0x6030, 0xc08d, 0xc085, 0xc0ac, 0x6032, 0x080c,
+	0x6c53, 0x1158, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x9085, 0x0001,
+	0x080c, 0x6c9a, 0x080c, 0x6b8a, 0x0010, 0x080c, 0x58e0, 0x012e,
+	0x0804, 0x3191, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x31c3,
+	0x080c, 0x5127, 0x0120, 0x2009, 0x0007, 0x0804, 0x31c3, 0x080c,
+	0x629c, 0x0120, 0x2009, 0x0008, 0x0804, 0x31c3, 0x080c, 0x2f81,
+	0x0128, 0x7984, 0x080c, 0x5f1e, 0x1904, 0x31c6, 0x080c, 0x4645,
+	0x0904, 0x31c6, 0x2b00, 0x7026, 0x080c, 0x62a4, 0x7888, 0x1170,
+	0x9084, 0x0005, 0x1158, 0x900e, 0x080c, 0x619e, 0x1108, 0xc185,
+	0xb800, 0xd0bc, 0x0108, 0xc18d, 0x0804, 0x3191, 0x080c, 0x4612,
+	0x0904, 0x31c3, 0x9006, 0xa866, 0xa832, 0xa868, 0xc0fd, 0xa86a,
+	0x080c, 0xb817, 0x0904, 0x31c3, 0x7888, 0xd094, 0x0118, 0xb8bc,
+	0xc08d, 0xb8be, 0x7007, 0x0003, 0x701f, 0x48eb, 0x0005, 0x2061,
+	0x1800, 0x080c, 0x5127, 0x2009, 0x0007, 0x1578, 0x080c, 0x629c,
+	0x0118, 0x2009, 0x0008, 0x0448, 0x080c, 0x2f81, 0x0120, 0xa998,
+	0x080c, 0x5f1e, 0x1530, 0x080c, 0x4643, 0x0518, 0x080c, 0x62a4,
+	0xa89c, 0x1168, 0x9084, 0x0005, 0x1150, 0x900e, 0x080c, 0x619e,
+	0x1108, 0xc185, 0xb800, 0xd0bc, 0x0108, 0xc18d, 0x00d0, 0xa868,
+	0xc0fc, 0xa86a, 0x080c, 0xb817, 0x11e0, 0xa89c, 0xd094, 0x0118,
+	0xb8bc, 0xc08d, 0xb8be, 0x2009, 0x0003, 0xa897, 0x4005, 0xa99a,
+	0x0010, 0xa897, 0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030,
+	0x0005, 0xa897, 0x4000, 0xa99a, 0x9006, 0x918d, 0x0001, 0x2008,
+	0x0005, 0x9006, 0x0005, 0xa830, 0x9086, 0x0100, 0x7024, 0x2058,
+	0x1110, 0x0804, 0x5070, 0x900e, 0x080c, 0x619e, 0x1108, 0xc185,
+	0xb800, 0xd0bc, 0x0108, 0xc18d, 0x0804, 0x3191, 0x080c, 0x5127,
+	0x0120, 0x2009, 0x0007, 0x0804, 0x31c3, 0x7f84, 0x7a8c, 0x7b88,
+	0x7c9c, 0x7d98, 0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804,
+	0x31c3, 0x900e, 0x2130, 0x7126, 0x7132, 0xa860, 0x20e8, 0x7036,
+	0xa85c, 0x9080, 0x0005, 0x702a, 0x20a0, 0x080c, 0x5f7e, 0x1904,
+	0x4981, 0x080c, 0x62a4, 0x0120, 0x080c, 0x62ac, 0x1904, 0x4981,
+	0x080c, 0x629c, 0x1130, 0x080c, 0x619e, 0x1118, 0xd79c, 0x0904,
+	0x4981, 0xd794, 0x1110, 0xd784, 0x01a8, 0xb8b4, 0x20e0, 0xb8b8,
+	0x9080, 0x0006, 0x2098, 0x3400, 0xd794, 0x0160, 0x20a9, 0x0008,
+	0x4003, 0x2098, 0x20a0, 0x3d00, 0x20e0, 0x20a9, 0x0002, 0x080c,
+	0x4444, 0x0048, 0x20a9, 0x0004, 0x4003, 0x2098, 0x20a0, 0x3d00,
+	0x20e0, 0x080c, 0x4444, 0x4104, 0xd794, 0x0528, 0xb8b4, 0x20e0,
+	0xb8b8, 0x2060, 0x9c80, 0x0000, 0x2098, 0x20a9, 0x0002, 0x4003,
+	0x9c80, 0x0003, 0x2098, 0x20a9, 0x0001, 0x4005, 0x9c80, 0x0004,
+	0x2098, 0x3400, 0x20a9, 0x0002, 0x4003, 0x2098, 0x20a0, 0x3d00,
+	0x20e0, 0x080c, 0x4437, 0x9c80, 0x0026, 0x2098, 0xb8b4, 0x20e0,
+	0x20a9, 0x0002, 0x4003, 0xd794, 0x0110, 0x96b0, 0x000b, 0x96b0,
+	0x0005, 0x8108, 0x080c, 0x9940, 0x0118, 0x9186, 0x0800, 0x0040,
+	0xd78c, 0x0120, 0x9186, 0x0800, 0x0170, 0x0018, 0x9186, 0x007e,
+	0x0150, 0xd794, 0x0118, 0x9686, 0x0020, 0x0010, 0x9686, 0x0028,
+	0x0150, 0x0804, 0x491d, 0x86ff, 0x1120, 0x7124, 0x810b, 0x0804,
+	0x3191, 0x7033, 0x0001, 0x7122, 0x7024, 0x9600, 0x7026, 0x772e,
+	0x2061, 0x18ae, 0x2c44, 0xa06b, 0x0000, 0xa67a, 0x7034, 0xa072,
+	0x7028, 0xa076, 0xa28e, 0xa392, 0xa496, 0xa59a, 0x080c, 0x10b5,
+	0x7007, 0x0002, 0x701f, 0x49bd, 0x0005, 0x7030, 0x9005, 0x1180,
+	0x7120, 0x7028, 0x20a0, 0x772c, 0x9036, 0x7034, 0x20e8, 0x2061,
+	0x18ae, 0x2c44, 0xa28c, 0xa390, 0xa494, 0xa598, 0x0804, 0x491d,
+	0x7124, 0x810b, 0x0804, 0x3191, 0x2029, 0x007e, 0x7984, 0x7a88,
+	0x7b8c, 0x7c98, 0x9184, 0xff00, 0x8007, 0x90e2, 0x0020, 0x0a04,
+	0x31c6, 0x9502, 0x0a04, 0x31c6, 0x9184, 0x00ff, 0x90e2, 0x0020,
+	0x0a04, 0x31c6, 0x9502, 0x0a04, 0x31c6, 0x9284, 0xff00, 0x8007,
+	0x90e2, 0x0020, 0x0a04, 0x31c6, 0x9502, 0x0a04, 0x31c6, 0x9284,
+	0x00ff, 0x90e2, 0x0020, 0x0a04, 0x31c6, 0x9502, 0x0a04, 0x31c6,
+	0x9384, 0xff00, 0x8007, 0x90e2, 0x0020, 0x0a04, 0x31c6, 0x9502,
+	0x0a04, 0x31c6, 0x9384, 0x00ff, 0x90e2, 0x0020, 0x0a04, 0x31c6,
+	0x9502, 0x0a04, 0x31c6, 0x9484, 0xff00, 0x8007, 0x90e2, 0x0020,
+	0x0a04, 0x31c6, 0x9502, 0x0a04, 0x31c6, 0x9484, 0x00ff, 0x90e2,
+	0x0020, 0x0a04, 0x31c6, 0x9502, 0x0a04, 0x31c6, 0x2061, 0x1958,
+	0x6102, 0x6206, 0x630a, 0x640e, 0x0804, 0x3191, 0x0006, 0x080c,
+	0x5113, 0xd0cc, 0x000e, 0x0005, 0x0006, 0x080c, 0x5117, 0xd0bc,
+	0x000e, 0x0005, 0x616c, 0x7a84, 0x6300, 0x82ff, 0x1118, 0x7986,
+	0x0804, 0x3191, 0x83ff, 0x1904, 0x31c6, 0x2001, 0xfff0, 0x9200,
+	0x1a04, 0x31c6, 0x2019, 0xffff, 0x6070, 0x9302, 0x9200, 0x0a04,
+	0x31c6, 0x7986, 0x626e, 0x0804, 0x3191, 0x080c, 0x5127, 0x1904,
+	0x31c3, 0x7c88, 0x7d84, 0x7e98, 0x7f8c, 0x080c, 0x4612, 0x0904,
+	0x31c3, 0x900e, 0x901e, 0x7326, 0x7332, 0xa860, 0x20e8, 0x7036,
+	0xa85c, 0x9080, 0x0003, 0x702a, 0x20a0, 0x91d8, 0x1000, 0x2b5c,
+	0x8bff, 0x0178, 0x080c, 0x62a4, 0x0118, 0x080c, 0x62ac, 0x1148,
+	0x20a9, 0x0001, 0xb814, 0x4004, 0xb810, 0x4004, 0x4104, 0x9398,
+	0x0003, 0x8108, 0x9182, 0x0800, 0x0120, 0x9386, 0x003c, 0x0170,
+	0x0c20, 0x83ff, 0x1148, 0x7224, 0x900e, 0x2001, 0x0003, 0x080c,
+	0x7e7f, 0x2208, 0x0804, 0x3191, 0x7033, 0x0001, 0x7122, 0x7024,
+	0x9300, 0x7026, 0x2061, 0x18ae, 0x2c44, 0xa06b, 0x0000, 0xa37a,
+	0x7028, 0xa076, 0x7034, 0xa072, 0xa48e, 0xa592, 0xa696, 0xa79a,
+	0x080c, 0x10b5, 0x7007, 0x0002, 0x701f, 0x4aaf, 0x0005, 0x7030,
+	0x9005, 0x1178, 0x7120, 0x7028, 0x20a0, 0x901e, 0x7034, 0x20e8,
+	0x2061, 0x18ae, 0x2c44, 0xa48c, 0xa590, 0xa694, 0xa798, 0x0804,
+	0x4a6d, 0x7224, 0x900e, 0x2001, 0x0003, 0x080c, 0x7e7f, 0x2208,
+	0x0804, 0x3191, 0x00f6, 0x00e6, 0x080c, 0x5127, 0x2009, 0x0007,
+	0x1904, 0x4b42, 0x2071, 0x1894, 0x745c, 0x84ff, 0x2009, 0x000e,
+	0x1904, 0x4b42, 0xac9c, 0xad98, 0xaea4, 0xafa0, 0x0096, 0x080c,
+	0x0fee, 0x2009, 0x0002, 0x0904, 0x4b42, 0x2900, 0x705e, 0x900e,
+	0x901e, 0x7356, 0x7362, 0xa860, 0x7066, 0xa85c, 0x9080, 0x0003,
+	0x705a, 0x20a0, 0x91d8, 0x1000, 0x2b5c, 0x8bff, 0x0178, 0x080c,
+	0x62a4, 0x0118, 0x080c, 0x62ac, 0x1148, 0xb814, 0x20a9, 0x0001,
+	0x4004, 0xb810, 0x4004, 0x4104, 0x9398, 0x0003, 0x8108, 0x9182,
+	0x0800, 0x0120, 0x9386, 0x003c, 0x01e8, 0x0c20, 0x83ff, 0x11c0,
+	0x7254, 0x900e, 0x2001, 0x0003, 0x080c, 0x7e7f, 0x2208, 0x009e,
+	0xa897, 0x4000, 0xa99a, 0x715c, 0x81ff, 0x090c, 0x0db2, 0x2148,
+	0x080c, 0x1007, 0x9006, 0x705e, 0x918d, 0x0001, 0x2008, 0x0418,
+	0x7063, 0x0001, 0x7152, 0x7054, 0x9300, 0x7056, 0x2061, 0x18af,
+	0x2c44, 0xa37a, 0x7058, 0xa076, 0x7064, 0xa072, 0xa48e, 0xa592,
+	0xa696, 0xa79a, 0xa09f, 0x4b4e, 0x000e, 0xa0a2, 0x080c, 0x10b5,
+	0x9006, 0x0048, 0x009e, 0xa897, 0x4005, 0xa99a, 0x900e, 0x9085,
+	0x0001, 0x2001, 0x0030, 0x00ee, 0x00fe, 0x0005, 0x00f6, 0xa0a0,
+	0x904d, 0x090c, 0x0db2, 0x00e6, 0x2071, 0x1894, 0xa06c, 0x908e,
+	0x0100, 0x0138, 0xa87b, 0x0030, 0xa883, 0x0000, 0xa897, 0x4002,
+	0x00d8, 0x7060, 0x9005, 0x1158, 0x7150, 0x7058, 0x20a0, 0x901e,
+	0x7064, 0x20e8, 0xa48c, 0xa590, 0xa694, 0xa798, 0x0428, 0xa87b,
+	0x0000, 0xa883, 0x0000, 0xa897, 0x4000, 0x7254, 0x900e, 0x2001,
+	0x0003, 0x080c, 0x7e7f, 0xaa9a, 0x715c, 0x81ff, 0x090c, 0x0db2,
+	0x2148, 0x080c, 0x1007, 0x705f, 0x0000, 0xa0a0, 0x2048, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x6536, 0x012e, 0xa09f, 0x0000, 0xa0a3,
+	0x0000, 0x00ee, 0x00fe, 0x0005, 0x91d8, 0x1000, 0x2b5c, 0x8bff,
+	0x0178, 0x080c, 0x62a4, 0x0118, 0x080c, 0x62ac, 0x1148, 0xb814,
+	0x20a9, 0x0001, 0x4004, 0xb810, 0x4004, 0x4104, 0x9398, 0x0003,
+	0x8108, 0x9182, 0x0800, 0x0120, 0x9386, 0x003c, 0x0518, 0x0c20,
+	0x83ff, 0x11f0, 0x7154, 0x810c, 0xa99a, 0xa897, 0x4000, 0x715c,
+	0x81ff, 0x090c, 0x0db2, 0x2148, 0x080c, 0x1007, 0x9006, 0x705e,
+	0x918d, 0x0001, 0x2008, 0xa0a0, 0x2048, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x6536, 0x012e, 0xa09f, 0x0000, 0xa0a3, 0x0000, 0x0070,
+	0x7063, 0x0001, 0x7152, 0x7054, 0x9300, 0x7056, 0xa37a, 0xa48e,
+	0xa592, 0xa696, 0xa79a, 0x080c, 0x10b5, 0x9006, 0x00ee, 0x0005,
+	0x0096, 0xa88c, 0x90be, 0x7000, 0x0148, 0x90be, 0x7100, 0x0130,
+	0x90be, 0x7200, 0x0118, 0x009e, 0x0804, 0x31c6, 0xa884, 0xa988,
+	0x080c, 0x24d6, 0x1518, 0x080c, 0x5f1e, 0x1500, 0x7126, 0xbe12,
+	0xbd16, 0xae7c, 0x080c, 0x4612, 0x01c8, 0x080c, 0x4612, 0x01b0,
+	0x009e, 0xa867, 0x0000, 0xa868, 0xc0fd, 0xa86a, 0xa823, 0x0000,
+	0xa804, 0x2048, 0x080c, 0xb79e, 0x1120, 0x2009, 0x0003, 0x0804,
+	0x31c3, 0x7007, 0x0003, 0x701f, 0x4c1b, 0x0005, 0x009e, 0x2009,
+	0x0002, 0x0804, 0x31c3, 0x7124, 0x080c, 0x2f28, 0xa820, 0x9086,
+	0x8001, 0x1120, 0x2009, 0x0004, 0x0804, 0x31c3, 0x2900, 0x7022,
+	0xa804, 0x0096, 0x2048, 0x8906, 0x8006, 0x8007, 0x90bc, 0x003f,
+	0x9084, 0xffc0, 0x009e, 0x9080, 0x0002, 0x0076, 0x0006, 0x2098,
+	0x20a0, 0x27e0, 0x27e8, 0x20a9, 0x002a, 0x080c, 0x0f52, 0xaa6c,
+	0xab70, 0xac74, 0xad78, 0x2061, 0x18ae, 0x2c44, 0xa06b, 0x0000,
+	0xae64, 0xaf8c, 0x97c6, 0x7000, 0x0118, 0x97c6, 0x7100, 0x1148,
+	0x96c2, 0x0004, 0x0600, 0x2009, 0x0004, 0x000e, 0x007e, 0x0804,
+	0x465e, 0x97c6, 0x7200, 0x11b8, 0x96c2, 0x0054, 0x02a0, 0x000e,
+	0x007e, 0x2061, 0x18ae, 0x2c44, 0xa076, 0xa772, 0xa07b, 0x002a,
+	0xa28e, 0xa392, 0xa496, 0xa59a, 0x080c, 0x10b5, 0x7007, 0x0002,
+	0x701f, 0x4c77, 0x0005, 0x000e, 0x007e, 0x0804, 0x31c6, 0x7020,
+	0x2048, 0xa804, 0x2048, 0xa804, 0x2048, 0x8906, 0x8006, 0x8007,
+	0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080, 0x0002, 0x2098, 0x20a0,
+	0x27e0, 0x27e8, 0x20a9, 0x002a, 0x080c, 0x0f52, 0x2100, 0x2238,
+	0x2061, 0x18ae, 0x2c44, 0xa28c, 0xa390, 0xa494, 0xa598, 0x2009,
+	0x002a, 0x0804, 0x465e, 0x81ff, 0x1904, 0x31c3, 0x798c, 0x2001,
+	0x194f, 0x2102, 0x080c, 0x4629, 0x0904, 0x31c6, 0x080c, 0x62a4,
+	0x0120, 0x080c, 0x62ac, 0x1904, 0x31c6, 0x080c, 0x6045, 0x0904,
+	0x31c3, 0x0126, 0x2091, 0x8000, 0x080c, 0x610b, 0x012e, 0x0904,
+	0x31c3, 0x0804, 0x417a, 0xa9a0, 0x2001, 0x194f, 0xc18d, 0x2102,
+	0x080c, 0x4636, 0x01a0, 0x080c, 0x62a4, 0x0118, 0x080c, 0x62ac,
+	0x1170, 0x080c, 0x6045, 0x2009, 0x0002, 0x0128, 0x080c, 0x610b,
+	0x1170, 0x2009, 0x0003, 0xa897, 0x4005, 0xa99a, 0x0010, 0xa897,
+	0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030, 0x0005, 0xa897,
+	0x4000, 0x080c, 0x511b, 0x0110, 0x9006, 0x0018, 0x900e, 0x9085,
+	0x0001, 0x2001, 0x0000, 0x0005, 0x78a8, 0xd08c, 0x1118, 0xd084,
+	0x0904, 0x40ef, 0x080c, 0x4645, 0x0904, 0x31c6, 0x080c, 0x4612,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x31c3, 0x080c, 0x62a4, 0x0130,
+	0x908e, 0x0004, 0x0118, 0x908e, 0x0005, 0x15a0, 0x78a8, 0xd08c,
+	0x0120, 0xb800, 0xc08c, 0xb802, 0x0028, 0x080c, 0x5113, 0xd0b4,
+	0x0904, 0x4129, 0x7884, 0x908e, 0x007e, 0x0904, 0x4129, 0x908e,
+	0x007f, 0x0904, 0x4129, 0x908e, 0x0080, 0x0904, 0x4129, 0xb800,
+	0xd08c, 0x1904, 0x4129, 0xa867, 0x0000, 0xa868, 0xc0fd, 0xa86a,
+	0x080c, 0xb7bd, 0x1120, 0x2009, 0x0003, 0x0804, 0x31c3, 0x7007,
+	0x0003, 0x701f, 0x4d34, 0x0005, 0x080c, 0x4645, 0x0904, 0x31c6,
+	0x0804, 0x4129, 0x080c, 0x2f81, 0x0108, 0x0005, 0x2009, 0x1832,
+	0x210c, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x31c3, 0x080c,
+	0x5127, 0x0120, 0x2009, 0x0007, 0x0804, 0x31c3, 0x080c, 0x629c,
+	0x0120, 0x2009, 0x0008, 0x0804, 0x31c3, 0xb89c, 0xd0a4, 0x1118,
+	0xd0ac, 0x1904, 0x4129, 0x9006, 0xa866, 0xa832, 0xa868, 0xc0fd,
+	0xa86a, 0x080c, 0xb817, 0x1120, 0x2009, 0x0003, 0x0804, 0x31c3,
+	0x7007, 0x0003, 0x701f, 0x4d6d, 0x0005, 0xa830, 0x9086, 0x0100,
+	0x1120, 0x2009, 0x0004, 0x0804, 0x5070, 0x080c, 0x4645, 0x0904,
+	0x31c6, 0x0804, 0x4d06, 0x81ff, 0x2009, 0x0001, 0x1904, 0x31c3,
+	0x080c, 0x5127, 0x2009, 0x0007, 0x1904, 0x31c3, 0x080c, 0x629c,
+	0x0120, 0x2009, 0x0008, 0x0804, 0x31c3, 0x080c, 0x4645, 0x0904,
+	0x31c6, 0x080c, 0x62a4, 0x2009, 0x0009, 0x1904, 0x31c3, 0x080c,
+	0x4612, 0x2009, 0x0002, 0x0904, 0x31c3, 0x9006, 0xa866, 0xa832,
+	0xa868, 0xc0fd, 0xa86a, 0x7988, 0x9194, 0xff00, 0x918c, 0x00ff,
+	0x9006, 0x82ff, 0x1128, 0xc0ed, 0xa952, 0x798c, 0xa956, 0x0038,
+	0x928e, 0x0100, 0x1904, 0x31c6, 0xc0e5, 0xa952, 0xa956, 0xa83e,
+	0x080c, 0xba6a, 0x2009, 0x0003, 0x0904, 0x31c3, 0x7007, 0x0003,
+	0x701f, 0x4dc3, 0x0005, 0xa830, 0x9086, 0x0100, 0x2009, 0x0004,
+	0x0904, 0x31c3, 0x0804, 0x3191, 0x7aa8, 0x9284, 0xc000, 0x0148,
+	0xd2ec, 0x01a0, 0x080c, 0x5127, 0x1188, 0x2009, 0x0014, 0x0804,
+	0x31c3, 0xd2dc, 0x1568, 0x81ff, 0x2009, 0x0001, 0x1904, 0x31c3,
+	0x080c, 0x5127, 0x2009, 0x0007, 0x1904, 0x31c3, 0xd2f4, 0x0130,
+	0x9284, 0x5000, 0x080c, 0x50ee, 0x0804, 0x3191, 0xd2fc, 0x0158,
+	0x080c, 0x4645, 0x0904, 0x31c6, 0x7984, 0x9284, 0x9000, 0x080c,
+	0x50cb, 0x0804, 0x3191, 0x080c, 0x4645, 0x0904, 0x31c6, 0xb804,
+	0x9084, 0x00ff, 0x9086, 0x0006, 0x2009, 0x0009, 0x1904, 0x4eac,
+	0x080c, 0x4612, 0x2009, 0x0002, 0x0904, 0x4eac, 0xa85c, 0x9080,
+	0x001b, 0xaf60, 0x2009, 0x0008, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98,
+	0x080c, 0x465b, 0x701f, 0x4e1d, 0x0005, 0xa86c, 0x9086, 0x0500,
+	0x1138, 0xa870, 0x9005, 0x1120, 0xa874, 0x9084, 0xff00, 0x0110,
+	0x1904, 0x31c6, 0xa866, 0xa832, 0xa868, 0xc0fd, 0xa86a, 0x080c,
+	0x4645, 0x1110, 0x0804, 0x31c6, 0x2009, 0x0043, 0x080c, 0xbad2,
+	0x2009, 0x0003, 0x0904, 0x4eac, 0x7007, 0x0003, 0x701f, 0x4e41,
+	0x0005, 0xa830, 0x9086, 0x0100, 0x2009, 0x0004, 0x0904, 0x4eac,
+	0x7984, 0x7aa8, 0x9284, 0x1000, 0x080c, 0x50cb, 0x0804, 0x3191,
+	0x00c6, 0xaab0, 0x9284, 0xc000, 0x0140, 0xd2ec, 0x0168, 0x080c,
+	0x5127, 0x1150, 0x2009, 0x0014, 0x04f0, 0x2061, 0x1800, 0x080c,
+	0x5127, 0x2009, 0x0007, 0x15b8, 0xd2f4, 0x0128, 0x9284, 0x5000,
+	0x080c, 0x50ee, 0x0050, 0xd2fc, 0x0178, 0x080c, 0x4643, 0x0588,
+	0xa998, 0x9284, 0x9000, 0x080c, 0x50cb, 0xa87b, 0x0000, 0xa883,
+	0x0000, 0xa897, 0x4000, 0x0438, 0x080c, 0x4643, 0x0510, 0x080c,
+	0x62a4, 0x2009, 0x0009, 0x11b8, 0xa8c4, 0x9086, 0x0500, 0x11c8,
+	0xa8c8, 0x9005, 0x11b0, 0xa8cc, 0x9084, 0xff00, 0x1190, 0x080c,
+	0x4643, 0x1108, 0x0070, 0x2009, 0x004b, 0x080c, 0xbad2, 0x2009,
+	0x0003, 0x0108, 0x0078, 0x0429, 0x19c0, 0xa897, 0x4005, 0xa99a,
+	0x0010, 0xa897, 0x4006, 0x900e, 0x9085, 0x0001, 0x2001, 0x0030,
+	0x00ce, 0x0005, 0x9006, 0x0ce0, 0x7aa8, 0xd2dc, 0x0904, 0x31c3,
+	0x0016, 0x7984, 0x9284, 0x1000, 0xc0fd, 0x080c, 0x50cb, 0x001e,
+	0x1904, 0x31c3, 0x0804, 0x3191, 0x00f6, 0x2d78, 0x0011, 0x00fe,
+	0x0005, 0xaab0, 0xd2dc, 0x0150, 0x0016, 0xa998, 0x9284, 0x1000,
+	0xc0fd, 0x080c, 0x50cb, 0x001e, 0x9085, 0x0001, 0x0005, 0x81ff,
+	0x0120, 0x2009, 0x0001, 0x0804, 0x31c3, 0x080c, 0x5127, 0x0120,
+	0x2009, 0x0007, 0x0804, 0x31c3, 0x7984, 0x7ea8, 0x96b4, 0x00ff,
+	0x080c, 0x5f7e, 0x1904, 0x31c6, 0x9186, 0x007f, 0x0138, 0x080c,
+	0x62a4, 0x0120, 0x2009, 0x0009, 0x0804, 0x31c3, 0x080c, 0x4612,
+	0x1120, 0x2009, 0x0002, 0x0804, 0x31c3, 0xa867, 0x0000, 0xa868,
+	0xc0fd, 0xa86a, 0x2001, 0x0100, 0x8007, 0xa80a, 0x080c, 0xb7d7,
+	0x1120, 0x2009, 0x0003, 0x0804, 0x31c3, 0x7007, 0x0003, 0x701f,
+	0x4f0a, 0x0005, 0xa808, 0x8007, 0x9086, 0x0100, 0x1120, 0x2009,
+	0x0004, 0x0804, 0x31c3, 0xa8e0, 0xa866, 0xa810, 0x8007, 0x9084,
+	0x00ff, 0x800c, 0xa814, 0x8007, 0x9084, 0x00ff, 0x8004, 0x9080,
+	0x0002, 0x9108, 0x8906, 0x8006, 0x8007, 0x90bc, 0x003f, 0x9084,
+	0xffc0, 0x9080, 0x0004, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0x0804,
+	0x465e, 0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804, 0x31c3,
+	0x7984, 0x9194, 0xff00, 0x918c, 0x00ff, 0x8217, 0x82ff, 0x1118,
+	0x7023, 0x1982, 0x0040, 0x92c6, 0x0001, 0x1118, 0x7023, 0x199c,
+	0x0010, 0x0804, 0x31c6, 0x2009, 0x001a, 0x7a8c, 0x7b88, 0x7c9c,
+	0x7d98, 0xa85c, 0x9080, 0x0019, 0xaf60, 0x080c, 0x465b, 0x701f,
+	0x4f5a, 0x0005, 0x2001, 0x182c, 0x2003, 0x0001, 0xa85c, 0x9080,
+	0x0019, 0x2098, 0xa860, 0x20e0, 0x20a9, 0x001a, 0x7020, 0x20a0,
+	0x20e9, 0x0001, 0x4003, 0x0804, 0x3191, 0x080c, 0x4612, 0x1120,
+	0x2009, 0x0002, 0x0804, 0x31c3, 0x7984, 0x9194, 0xff00, 0x918c,
+	0x00ff, 0x8217, 0x82ff, 0x1118, 0x2099, 0x1982, 0x0040, 0x92c6,
+	0x0001, 0x1118, 0x2099, 0x199c, 0x0010, 0x0804, 0x31c6, 0xa85c,
+	0x9080, 0x0019, 0x20a0, 0xa860, 0x20e8, 0x20a9, 0x001a, 0x20e1,
+	0x0001, 0x4003, 0x2009, 0x001a, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98,
+	0xa85c, 0x9080, 0x0019, 0xaf60, 0x0804, 0x465e, 0x7884, 0x908a,
+	0x1000, 0x1a04, 0x31c6, 0x0126, 0x2091, 0x8000, 0x8003, 0x800b,
+	0x810b, 0x9108, 0x00c6, 0x2061, 0x19c9, 0x6142, 0x00ce, 0x012e,
+	0x0804, 0x3191, 0x00c6, 0x080c, 0x6c53, 0x1160, 0x080c, 0x6f2a,
+	0x080c, 0x5a21, 0x9085, 0x0001, 0x080c, 0x6c9a, 0x080c, 0x6b8a,
+	0x080c, 0x0db2, 0x2061, 0x1800, 0x6030, 0xc09d, 0x6032, 0x080c,
+	0x58e0, 0x00ce, 0x0005, 0x00c6, 0x2001, 0x1800, 0x2004, 0x908e,
+	0x0000, 0x0904, 0x31c3, 0x7884, 0x9005, 0x0188, 0x7888, 0x2061,
+	0x196b, 0x2c0c, 0x2062, 0x080c, 0x28b8, 0x01a0, 0x080c, 0x28c0,
+	0x0188, 0x080c, 0x28c8, 0x0170, 0x2162, 0x0804, 0x31c6, 0x2061,
+	0x0100, 0x6038, 0x9086, 0x0007, 0x1118, 0x2009, 0x0001, 0x0010,
+	0x2009, 0x0000, 0x7884, 0x9086, 0x0002, 0x1548, 0x2061, 0x0100,
+	0x6028, 0xc09c, 0x602a, 0x0026, 0x2011, 0x0003, 0x080c, 0x92ec,
+	0x2011, 0x0002, 0x080c, 0x92f6, 0x002e, 0x080c, 0x91de, 0x0036,
+	0x901e, 0x080c, 0x9254, 0x003e, 0x60e3, 0x0000, 0x080c, 0xd343,
+	0x080c, 0xd35e, 0x9085, 0x0001, 0x080c, 0x6c9a, 0x9006, 0x080c,
+	0x2987, 0x2001, 0x1800, 0x2003, 0x0004, 0x6027, 0x0008, 0x00ce,
+	0x0804, 0x3191, 0x81ff, 0x0120, 0x2009, 0x0001, 0x0804, 0x31c3,
+	0x080c, 0x5127, 0x0120, 0x2009, 0x0007, 0x0804, 0x31c3, 0x7984,
+	0x7ea8, 0x96b4, 0x00ff, 0x080c, 0x5f7e, 0x1904, 0x31c6, 0x9186,
+	0x007f, 0x0138, 0x080c, 0x62a4, 0x0120, 0x2009, 0x0009, 0x0804,
+	0x31c3, 0x080c, 0x4612, 0x1120, 0x2009, 0x0002, 0x0804, 0x31c3,
+	0xa867, 0x0000, 0xa868, 0xc0fd, 0xa86a, 0x080c, 0xb7da, 0x1120,
+	0x2009, 0x0003, 0x0804, 0x31c3, 0x7007, 0x0003, 0x701f, 0x5059,
+	0x0005, 0xa830, 0x9086, 0x0100, 0x1120, 0x2009, 0x0004, 0x0804,
+	0x31c3, 0xa8e0, 0xa866, 0xa834, 0x8007, 0x800c, 0xa85c, 0x9080,
+	0x000c, 0x7a8c, 0x7b88, 0x7c9c, 0x7d98, 0xaf60, 0x0804, 0x465e,
+	0xa898, 0x9086, 0x000d, 0x1904, 0x31c3, 0x2021, 0x4005, 0x0126,
+	0x2091, 0x8000, 0x0e04, 0x507d, 0x0010, 0x012e, 0x0cc0, 0x7c36,
+	0x9486, 0x4000, 0x0118, 0x7833, 0x0011, 0x0010, 0x7833, 0x0010,
+	0x7883, 0x4005, 0xa998, 0x7986, 0xa9a4, 0x799a, 0xa9a8, 0x799e,
+	0x080c, 0x464e, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084,
+	0x190c, 0x1167, 0x7007, 0x0001, 0x2091, 0x5000, 0x700f, 0x0000,
+	0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0x00c6, 0x2061, 0x19c9,
+	0x7984, 0x6152, 0x614e, 0x6057, 0x0000, 0x604b, 0x0009, 0x7898,
+	0x606a, 0x789c, 0x6066, 0x7888, 0x6062, 0x788c, 0x605e, 0x2001,
+	0x19d7, 0x2044, 0x2001, 0x19de, 0xa076, 0xa060, 0xa072, 0xa07b,
+	0x0001, 0xa07f, 0x0002, 0xa06b, 0x0000, 0xa09f, 0x0000, 0x00ce,
+	0x012e, 0x0804, 0x3191, 0x0126, 0x2091, 0x8000, 0x00b6, 0x00c6,
+	0x90e4, 0xc000, 0x0128, 0x0006, 0x080c, 0xb648, 0x000e, 0x1198,
+	0xd0e4, 0x0160, 0x9180, 0x1000, 0x2004, 0x905d, 0x0160, 0x080c,
+	0x5a3b, 0x080c, 0x9940, 0x0110, 0xb817, 0x0000, 0x9006, 0x00ce,
+	0x00be, 0x012e, 0x0005, 0x9085, 0x0001, 0x0cc8, 0x0126, 0x2091,
+	0x8000, 0x0156, 0x2010, 0x900e, 0x20a9, 0x0800, 0x0016, 0x9180,
+	0x1000, 0x2004, 0x9005, 0x0180, 0x9186, 0x007e, 0x0168, 0x9186,
+	0x007f, 0x0150, 0x9186, 0x0080, 0x0138, 0x9186, 0x00ff, 0x0120,
+	0x0026, 0x2200, 0x0801, 0x002e, 0x001e, 0x8108, 0x1f04, 0x50f6,
+	0x015e, 0x012e, 0x0005, 0x2001, 0x1854, 0x2004, 0x0005, 0x2001,
+	0x1873, 0x2004, 0x0005, 0x0006, 0x2001, 0x180f, 0x2004, 0xd0d4,
+	0x000e, 0x0005, 0x2001, 0x180d, 0x2004, 0xd0b4, 0x0005, 0x2001,
+	0x1800, 0x2004, 0x9086, 0x0003, 0x0005, 0x0016, 0x00e6, 0x2071,
+	0x1894, 0x7108, 0x910d, 0x710a, 0x00ee, 0x001e, 0x0005, 0x0126,
+	0x0156, 0x0136, 0x0146, 0x01c6, 0x01d6, 0x00c6, 0x00d6, 0x00e6,
+	0x00f6, 0x2061, 0x0100, 0x2069, 0x0200, 0x2071, 0x1800, 0x6044,
+	0xd0a4, 0x11e8, 0xd084, 0x0118, 0x080c, 0x52e0, 0x0068, 0xd08c,
+	0x0118, 0x080c, 0x51e9, 0x0040, 0xd094, 0x0118, 0x080c, 0x51b9,
+	0x0018, 0xd09c, 0x0108, 0x0099, 0x00fe, 0x00ee, 0x00de, 0x00ce,
+	0x01de, 0x01ce, 0x014e, 0x013e, 0x015e, 0x012e, 0x0005, 0x0016,
+	0x6128, 0xd19c, 0x1110, 0xc19d, 0x612a, 0x001e, 0x0c68, 0x0006,
+	0x7090, 0x9005, 0x000e, 0x0120, 0x7093, 0x0000, 0x708b, 0x0000,
+	0x624c, 0x9286, 0xf0f0, 0x1150, 0x6048, 0x9086, 0xf0f0, 0x0130,
+	0x624a, 0x6043, 0x0090, 0x6043, 0x0010, 0x0490, 0x9294, 0xff00,
+	0x9296, 0xf700, 0x0178, 0x7134, 0xd1a4, 0x1160, 0x6240, 0x9295,
+	0x0100, 0x6242, 0x9294, 0x0010, 0x0128, 0x2009, 0x00f7, 0x080c,
+	0x599d, 0x00f0, 0x6040, 0x9084, 0x0010, 0x9085, 0x0140, 0x6042,
+	0x6043, 0x0000, 0x707f, 0x0000, 0x709b, 0x0001, 0x70bf, 0x0000,
+	0x70d7, 0x0000, 0x2009, 0x1c80, 0x200b, 0x0000, 0x708f, 0x0000,
+	0x7083, 0x000f, 0x2009, 0x000f, 0x2011, 0x5883, 0x080c, 0x7cd9,
+	0x0005, 0x2001, 0x1875, 0x2004, 0xd08c, 0x0110, 0x7057, 0xffff,
+	0x7080, 0x9005, 0x1528, 0x2011, 0x5883, 0x080c, 0x7c4a, 0x6040,
+	0x9094, 0x0010, 0x9285, 0x0020, 0x6042, 0x20a9, 0x00c8, 0x6044,
+	0xd08c, 0x1168, 0x1f04, 0x51cf, 0x6242, 0x7093, 0x0000, 0x6040,
+	0x9094, 0x0010, 0x9285, 0x0080, 0x6042, 0x6242, 0x0048, 0x6242,
+	0x7093, 0x0000, 0x7087, 0x0000, 0x9006, 0x080c, 0x5a26, 0x0000,
+	0x0005, 0x7084, 0x908a, 0x0003, 0x1a0c, 0x0db2, 0x000b, 0x0005,
+	0x51f3, 0x5244, 0x52df, 0x00f6, 0x0016, 0x6900, 0x918c, 0x0800,
+	0x7087, 0x0001, 0x2001, 0x015d, 0x2003, 0x0000, 0x6803, 0x00fc,
+	0x20a9, 0x0004, 0x6800, 0x9084, 0x00fc, 0x0120, 0x1f04, 0x5202,
+	0x080c, 0x0db2, 0x68a0, 0x68a2, 0x689c, 0x689e, 0x6898, 0x689a,
+	0xa001, 0x918d, 0x1600, 0x6902, 0x001e, 0x6837, 0x0020, 0x080c,
+	0x5a02, 0x2079, 0x1c00, 0x7833, 0x1101, 0x7837, 0x0000, 0x20e1,
+	0x0001, 0x2099, 0x1805, 0x20e9, 0x0001, 0x20a1, 0x1c0e, 0x20a9,
+	0x0004, 0x4003, 0x080c, 0x97ce, 0x20e1, 0x0001, 0x2099, 0x1c00,
+	0x20e9, 0x0000, 0x20a1, 0x0240, 0x20a9, 0x0014, 0x4003, 0x60c3,
+	0x000c, 0x600f, 0x0000, 0x080c, 0x58b4, 0x00fe, 0x9006, 0x708a,
+	0x6043, 0x0008, 0x6042, 0x0005, 0x00f6, 0x7088, 0x708b, 0x0000,
+	0x9025, 0x0904, 0x52bc, 0x6020, 0xd0b4, 0x1904, 0x52ba, 0x7198,
+	0x81ff, 0x0904, 0x52a8, 0x9486, 0x000c, 0x1904, 0x52b5, 0x9480,
+	0x0018, 0x8004, 0x20a8, 0x080c, 0x59fb, 0x2011, 0x0260, 0x2019,
+	0x1c00, 0x220c, 0x2304, 0x9106, 0x11e8, 0x8210, 0x8318, 0x1f04,
+	0x5261, 0x6043, 0x0004, 0x2061, 0x0140, 0x605b, 0xbc94, 0x605f,
+	0xf0f0, 0x2061, 0x0100, 0x6043, 0x0006, 0x7087, 0x0002, 0x7093,
+	0x0002, 0x2009, 0x07d0, 0x2011, 0x588a, 0x080c, 0x7cd9, 0x080c,
+	0x5a02, 0x04c0, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7930, 0x918e,
+	0x1101, 0x1558, 0x7834, 0x9005, 0x1540, 0x7900, 0x918c, 0x00ff,
+	0x1118, 0x7804, 0x9005, 0x0190, 0x080c, 0x59fb, 0x2011, 0x026e,
+	0x2019, 0x1805, 0x20a9, 0x0004, 0x220c, 0x2304, 0x9102, 0x0230,
+	0x11a0, 0x8210, 0x8318, 0x1f04, 0x529c, 0x0078, 0x709b, 0x0000,
+	0x080c, 0x59fb, 0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0001,
+	0x20a1, 0x1c00, 0x20a9, 0x0014, 0x4003, 0x6043, 0x0008, 0x6043,
+	0x0000, 0x0010, 0x00fe, 0x0005, 0x6040, 0x9085, 0x0100, 0x6042,
+	0x6020, 0xd0b4, 0x1db8, 0x080c, 0x97ce, 0x20e1, 0x0001, 0x2099,
+	0x1c00, 0x20e9, 0x0000, 0x20a1, 0x0240, 0x20a9, 0x0014, 0x4003,
+	0x60c3, 0x000c, 0x2011, 0x19c0, 0x2013, 0x0000, 0x708b, 0x0000,
+	0x60a3, 0x0056, 0x60a7, 0x9575, 0x080c, 0x8fb2, 0x08d8, 0x0005,
+	0x7090, 0x908a, 0x001d, 0x1a0c, 0x0db2, 0x000b, 0x0005, 0x5311,
+	0x5324, 0x534d, 0x536d, 0x5393, 0x53c2, 0x53e8, 0x5420, 0x5446,
+	0x5474, 0x54af, 0x54e7, 0x5505, 0x5530, 0x5552, 0x556d, 0x5577,
+	0x55ab, 0x55d1, 0x5600, 0x5626, 0x565e, 0x56a2, 0x56df, 0x5700,
+	0x5759, 0x577b, 0x57a9, 0x57a9, 0x00c6, 0x2061, 0x1800, 0x6003,
+	0x0007, 0x2061, 0x0100, 0x6004, 0x9084, 0xfff9, 0x6006, 0x00ce,
+	0x0005, 0x2061, 0x0140, 0x605b, 0xbc94, 0x605f, 0xf0f0, 0x2061,
+	0x0100, 0x6043, 0x0002, 0x7093, 0x0001, 0x2009, 0x07d0, 0x2011,
+	0x588a, 0x080c, 0x7cd9, 0x0005, 0x00f6, 0x7088, 0x9086, 0x0014,
+	0x1510, 0x6042, 0x6020, 0xd0b4, 0x11f0, 0x080c, 0x59fb, 0x2079,
+	0x0260, 0x7a30, 0x9296, 0x1102, 0x11a0, 0x7834, 0x9005, 0x1188,
+	0x7a38, 0xd2fc, 0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001,
+	0x2011, 0x588a, 0x080c, 0x7c4a, 0x7093, 0x0010, 0x080c, 0x5577,
+	0x0010, 0x708b, 0x0000, 0x00fe, 0x0005, 0x00f6, 0x7093, 0x0003,
+	0x6043, 0x0004, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x080c, 0x597f,
+	0x2079, 0x0240, 0x7833, 0x1102, 0x7837, 0x0000, 0x20a9, 0x0008,
+	0x9f88, 0x000e, 0x200b, 0x0000, 0x8108, 0x1f04, 0x5362, 0x60c3,
+	0x0014, 0x080c, 0x58b4, 0x00fe, 0x0005, 0x00f6, 0x7088, 0x9005,
+	0x0500, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x9086, 0x0014, 0x11b8,
+	0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1102, 0x1178,
+	0x7834, 0x9005, 0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70bc, 0x9005,
+	0x1110, 0x70bf, 0x0001, 0x7093, 0x0004, 0x0029, 0x0010, 0x080c,
+	0x59d7, 0x00fe, 0x0005, 0x00f6, 0x7093, 0x0005, 0x080c, 0x597f,
+	0x2079, 0x0240, 0x7833, 0x1103, 0x7837, 0x0000, 0x080c, 0x59fb,
+	0x080c, 0x59de, 0x1170, 0x707c, 0x9005, 0x1158, 0x7154, 0x9186,
+	0xffff, 0x0138, 0x2011, 0x0008, 0x080c, 0x5837, 0x0168, 0x080c,
+	0x59b4, 0x20a9, 0x0008, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9,
+	0x0000, 0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x58b4,
+	0x00fe, 0x0005, 0x00f6, 0x7088, 0x9005, 0x0500, 0x2011, 0x588a,
+	0x080c, 0x7c4a, 0x9086, 0x0014, 0x11b8, 0x080c, 0x59fb, 0x2079,
+	0x0260, 0x7a30, 0x9296, 0x1103, 0x1178, 0x7834, 0x9005, 0x1160,
+	0x7a38, 0xd2fc, 0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001,
+	0x7093, 0x0006, 0x0029, 0x0010, 0x080c, 0x59d7, 0x00fe, 0x0005,
+	0x00f6, 0x7093, 0x0007, 0x080c, 0x597f, 0x2079, 0x0240, 0x7833,
+	0x1104, 0x7837, 0x0000, 0x080c, 0x59fb, 0x080c, 0x59de, 0x11b8,
+	0x707c, 0x9005, 0x11a0, 0x715c, 0x9186, 0xffff, 0x0180, 0x9180,
+	0x2f92, 0x200d, 0x918c, 0xff00, 0x810f, 0x2011, 0x0008, 0x080c,
+	0x5837, 0x0180, 0x080c, 0x4a34, 0x0110, 0x080c, 0x253f, 0x20a9,
+	0x0008, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1,
+	0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x58b4, 0x00fe, 0x0005,
+	0x00f6, 0x7088, 0x9005, 0x0500, 0x2011, 0x588a, 0x080c, 0x7c4a,
+	0x9086, 0x0014, 0x11b8, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30,
+	0x9296, 0x1104, 0x1178, 0x7834, 0x9005, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001, 0x7093, 0x0008,
+	0x0029, 0x0010, 0x080c, 0x59d7, 0x00fe, 0x0005, 0x00f6, 0x7093,
+	0x0009, 0x080c, 0x597f, 0x2079, 0x0240, 0x7833, 0x1105, 0x7837,
+	0x0100, 0x080c, 0x59de, 0x1150, 0x707c, 0x9005, 0x1138, 0x080c,
+	0x57aa, 0x1188, 0x9085, 0x0001, 0x080c, 0x253f, 0x20a9, 0x0008,
+	0x080c, 0x59fb, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000,
+	0x20a1, 0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x58b4, 0x0010,
+	0x080c, 0x5304, 0x00fe, 0x0005, 0x00f6, 0x7088, 0x9005, 0x05a8,
+	0x2011, 0x588a, 0x080c, 0x7c4a, 0x9086, 0x0014, 0x1560, 0x080c,
+	0x59fb, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1105, 0x1520, 0x7834,
+	0x9084, 0x0100, 0x2011, 0x0100, 0x921e, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001, 0x7093, 0x000a,
+	0x00b1, 0x0098, 0x9005, 0x1178, 0x7a38, 0xd2fc, 0x0128, 0x70bc,
+	0x9005, 0x1110, 0x70bf, 0x0001, 0x708f, 0x0000, 0x7093, 0x000e,
+	0x080c, 0x5552, 0x0010, 0x080c, 0x59d7, 0x00fe, 0x0005, 0x00f6,
+	0x7093, 0x000b, 0x2011, 0x1c0e, 0x20e9, 0x0001, 0x22a0, 0x20a9,
+	0x0040, 0x2019, 0xffff, 0x4304, 0x080c, 0x597f, 0x2079, 0x0240,
+	0x7833, 0x1106, 0x7837, 0x0000, 0x080c, 0x59de, 0x0118, 0x2013,
+	0x0000, 0x0020, 0x7058, 0x9085, 0x0100, 0x2012, 0x20a9, 0x0040,
+	0x2009, 0x024e, 0x2011, 0x1c0e, 0x220e, 0x8210, 0x8108, 0x9186,
+	0x0260, 0x1128, 0x6810, 0x8000, 0x6812, 0x2009, 0x0240, 0x1f04,
+	0x54d4, 0x60c3, 0x0084, 0x080c, 0x58b4, 0x00fe, 0x0005, 0x00f6,
+	0x7088, 0x9005, 0x01c0, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x9086,
+	0x0084, 0x1178, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30, 0x9296,
+	0x1106, 0x1138, 0x7834, 0x9005, 0x1120, 0x7093, 0x000c, 0x0029,
+	0x0010, 0x080c, 0x59d7, 0x00fe, 0x0005, 0x00f6, 0x7093, 0x000d,
+	0x080c, 0x597f, 0x2079, 0x0240, 0x7833, 0x1107, 0x7837, 0x0000,
+	0x080c, 0x59fb, 0x20a9, 0x0040, 0x2011, 0x026e, 0x2009, 0x024e,
+	0x220e, 0x8210, 0x8108, 0x9186, 0x0260, 0x1150, 0x6810, 0x8000,
+	0x6812, 0x2009, 0x0240, 0x6814, 0x8000, 0x6816, 0x2011, 0x0260,
+	0x1f04, 0x5518, 0x60c3, 0x0084, 0x080c, 0x58b4, 0x00fe, 0x0005,
+	0x00f6, 0x7088, 0x9005, 0x01e0, 0x2011, 0x588a, 0x080c, 0x7c4a,
+	0x9086, 0x0084, 0x1198, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30,
+	0x9296, 0x1107, 0x1158, 0x7834, 0x9005, 0x1140, 0x708f, 0x0001,
+	0x080c, 0x5951, 0x7093, 0x000e, 0x0029, 0x0010, 0x080c, 0x59d7,
+	0x00fe, 0x0005, 0x918d, 0x0001, 0x080c, 0x5a26, 0x7093, 0x000f,
+	0x708b, 0x0000, 0x2061, 0x0140, 0x605b, 0xbc85, 0x605f, 0xb5b5,
+	0x2061, 0x0100, 0x6043, 0x0005, 0x6043, 0x0004, 0x2009, 0x07d0,
+	0x2011, 0x588a, 0x080c, 0x7c3e, 0x0005, 0x7088, 0x9005, 0x0130,
+	0x2011, 0x588a, 0x080c, 0x7c4a, 0x7093, 0x0000, 0x0005, 0x7093,
+	0x0011, 0x080c, 0x97ce, 0x080c, 0x59fb, 0x20e1, 0x0000, 0x2099,
+	0x0260, 0x20e9, 0x0000, 0x20a1, 0x0240, 0x7488, 0x9480, 0x0018,
+	0x9080, 0x0007, 0x9084, 0x03f8, 0x8004, 0x20a8, 0x4003, 0x080c,
+	0x59de, 0x11a0, 0x7174, 0x81ff, 0x0188, 0x900e, 0x7078, 0x9084,
+	0x00ff, 0x0160, 0x080c, 0x24d6, 0x9186, 0x007e, 0x0138, 0x9186,
+	0x0080, 0x0120, 0x2011, 0x0008, 0x080c, 0x5837, 0x60c3, 0x0014,
+	0x080c, 0x58b4, 0x0005, 0x00f6, 0x7088, 0x9005, 0x0500, 0x2011,
+	0x588a, 0x080c, 0x7c4a, 0x9086, 0x0014, 0x11b8, 0x080c, 0x59fb,
+	0x2079, 0x0260, 0x7a30, 0x9296, 0x1103, 0x1178, 0x7834, 0x9005,
+	0x1160, 0x7a38, 0xd2fc, 0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf,
+	0x0001, 0x7093, 0x0012, 0x0029, 0x0010, 0x708b, 0x0000, 0x00fe,
+	0x0005, 0x00f6, 0x7093, 0x0013, 0x080c, 0x598d, 0x2079, 0x0240,
+	0x7833, 0x1103, 0x7837, 0x0000, 0x080c, 0x59fb, 0x080c, 0x59de,
+	0x1170, 0x707c, 0x9005, 0x1158, 0x7154, 0x9186, 0xffff, 0x0138,
+	0x2011, 0x0008, 0x080c, 0x5837, 0x0168, 0x080c, 0x59b4, 0x20a9,
+	0x0008, 0x20e1, 0x0000, 0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1,
+	0x024e, 0x4003, 0x60c3, 0x0014, 0x080c, 0x58b4, 0x00fe, 0x0005,
+	0x00f6, 0x7088, 0x9005, 0x0500, 0x2011, 0x588a, 0x080c, 0x7c4a,
+	0x9086, 0x0014, 0x11b8, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30,
+	0x9296, 0x1104, 0x1178, 0x7834, 0x9005, 0x1160, 0x7a38, 0xd2fc,
+	0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001, 0x7093, 0x0014,
+	0x0029, 0x0010, 0x708b, 0x0000, 0x00fe, 0x0005, 0x00f6, 0x7093,
+	0x0015, 0x080c, 0x598d, 0x2079, 0x0240, 0x7833, 0x1104, 0x7837,
+	0x0000, 0x080c, 0x59fb, 0x080c, 0x59de, 0x11b8, 0x707c, 0x9005,
+	0x11a0, 0x715c, 0x9186, 0xffff, 0x0180, 0x9180, 0x2f92, 0x200d,
+	0x918c, 0xff00, 0x810f, 0x2011, 0x0008, 0x080c, 0x5837, 0x0180,
+	0x080c, 0x4a34, 0x0110, 0x080c, 0x253f, 0x20a9, 0x0008, 0x20e1,
+	0x0000, 0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x4003,
+	0x60c3, 0x0014, 0x080c, 0x58b4, 0x00fe, 0x0005, 0x00f6, 0x7088,
+	0x9005, 0x05f0, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x9086, 0x0014,
+	0x15a8, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30, 0x9296, 0x1105,
+	0x1568, 0x7834, 0x9084, 0x0100, 0x2011, 0x0100, 0x921e, 0x1168,
+	0x9085, 0x0001, 0x080c, 0x5a26, 0x7a38, 0xd2fc, 0x0128, 0x70bc,
+	0x9005, 0x1110, 0x70bf, 0x0001, 0x0080, 0x9005, 0x11b8, 0x7a38,
+	0xd2fc, 0x0128, 0x70bc, 0x9005, 0x1110, 0x70bf, 0x0001, 0x9085,
+	0x0001, 0x080c, 0x5a26, 0x708f, 0x0000, 0x7a38, 0xd2f4, 0x0110,
+	0x70d7, 0x0008, 0x7093, 0x0016, 0x0029, 0x0010, 0x708b, 0x0000,
+	0x00fe, 0x0005, 0x080c, 0x97ce, 0x080c, 0x59fb, 0x20e1, 0x0000,
+	0x2099, 0x0260, 0x20e9, 0x0000, 0x20a1, 0x0240, 0x20a9, 0x000e,
+	0x4003, 0x2011, 0x026d, 0x2204, 0x9084, 0x0100, 0x2011, 0x024d,
+	0x2012, 0x2011, 0x026e, 0x7093, 0x0017, 0x080c, 0x59de, 0x1150,
+	0x707c, 0x9005, 0x1138, 0x080c, 0x57aa, 0x1188, 0x9085, 0x0001,
+	0x080c, 0x253f, 0x20a9, 0x0008, 0x080c, 0x59fb, 0x20e1, 0x0000,
+	0x2099, 0x026e, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x4003, 0x60c3,
+	0x0014, 0x080c, 0x58b4, 0x0010, 0x080c, 0x5304, 0x0005, 0x00f6,
+	0x7088, 0x9005, 0x01d8, 0x2011, 0x588a, 0x080c, 0x7c4a, 0x9086,
+	0x0084, 0x1190, 0x080c, 0x59fb, 0x2079, 0x0260, 0x7a30, 0x9296,
+	0x1106, 0x1150, 0x7834, 0x9005, 0x1138, 0x9006, 0x080c, 0x5a26,
+	0x7093, 0x0018, 0x0029, 0x0010, 0x708b, 0x0000, 0x00fe, 0x0005,
+	0x00f6, 0x7093, 0x0019, 0x080c, 0x598d, 0x2079, 0x0240, 0x7833,
+	0x1106, 0x7837, 0x0000, 0x080c, 0x59fb, 0x2009, 0x026e, 0x2039,
+	0x1c0e, 0x20a9, 0x0040, 0x213e, 0x8738, 0x8108, 0x9186, 0x0280,
+	0x1128, 0x6814, 0x8000, 0x6816, 0x2009, 0x0260, 0x1f04, 0x5713,
+	0x2039, 0x1c0e, 0x080c, 0x59de, 0x11e8, 0x2728, 0x2514, 0x8207,
+	0x9084, 0x00ff, 0x8000, 0x2018, 0x9294, 0x00ff, 0x8007, 0x9205,
+	0x202a, 0x7058, 0x2310, 0x8214, 0x92a0, 0x1c0e, 0x2414, 0x938c,
+	0x0001, 0x0118, 0x9294, 0xff00, 0x0018, 0x9294, 0x00ff, 0x8007,
+	0x9215, 0x2222, 0x20a9, 0x0040, 0x2009, 0x024e, 0x270e, 0x8738,
+	0x8108, 0x9186, 0x0260, 0x1128, 0x6810, 0x8000, 0x6812, 0x2009,
+	0x0240, 0x1f04, 0x5746, 0x60c3, 0x0084, 0x080c, 0x58b4, 0x00fe,
+	0x0005, 0x00f6, 0x7088, 0x9005, 0x01e0, 0x2011, 0x588a, 0x080c,
+	0x7c4a, 0x9086, 0x0084, 0x1198, 0x080c, 0x59fb, 0x2079, 0x0260,
+	0x7a30, 0x9296, 0x1107, 0x1158, 0x7834, 0x9005, 0x1140, 0x708f,
+	0x0001, 0x080c, 0x5951, 0x7093, 0x001a, 0x0029, 0x0010, 0x708b,
+	0x0000, 0x00fe, 0x0005, 0x9085, 0x0001, 0x080c, 0x5a26, 0x7093,
+	0x001b, 0x080c, 0x97ce, 0x080c, 0x59fb, 0x2011, 0x0260, 0x2009,
+	0x0240, 0x7488, 0x9480, 0x0018, 0x9080, 0x0007, 0x9084, 0x03f8,
+	0x8004, 0x20a8, 0x220e, 0x8210, 0x8108, 0x9186, 0x0260, 0x1150,
+	0x6810, 0x8000, 0x6812, 0x2009, 0x0240, 0x6814, 0x8000, 0x6816,
+	0x2011, 0x0260, 0x1f04, 0x5792, 0x60c3, 0x0084, 0x080c, 0x58b4,
+	0x0005, 0x0005, 0x0086, 0x0096, 0x2029, 0x1854, 0x252c, 0x20a9,
+	0x0008, 0x2041, 0x1c0e, 0x20e9, 0x0001, 0x28a0, 0x080c, 0x59fb,
+	0x20e1, 0x0000, 0x2099, 0x026e, 0x4003, 0x20a9, 0x0008, 0x2011,
+	0x0007, 0xd5d4, 0x0108, 0x9016, 0x2800, 0x9200, 0x200c, 0x91a6,
+	0xffff, 0x1148, 0xd5d4, 0x0110, 0x8210, 0x0008, 0x8211, 0x1f04,
+	0x57c4, 0x0804, 0x5833, 0x82ff, 0x1160, 0xd5d4, 0x0120, 0x91a6,
+	0x3fff, 0x0d90, 0x0020, 0x91a6, 0x3fff, 0x0904, 0x5833, 0x918d,
+	0xc000, 0x20a9, 0x0010, 0x2019, 0x0001, 0xd5d4, 0x0110, 0x2019,
+	0x0010, 0x2120, 0xd5d4, 0x0110, 0x8423, 0x0008, 0x8424, 0x1240,
+	0xd5d4, 0x0110, 0x8319, 0x0008, 0x8318, 0x1f04, 0x57ea, 0x04d8,
+	0x23a8, 0x2021, 0x0001, 0x8426, 0x8425, 0x1f04, 0x57fc, 0x2328,
+	0x8529, 0x92be, 0x0007, 0x0158, 0x0006, 0x2039, 0x0007, 0x2200,
+	0x973a, 0x000e, 0x27a8, 0x95a8, 0x0010, 0x1f04, 0x580b, 0x7556,
+	0x95c8, 0x2f92, 0x292d, 0x95ac, 0x00ff, 0x757a, 0x6532, 0x6536,
+	0x0016, 0x2508, 0x080c, 0x251f, 0x001e, 0x60e7, 0x0000, 0x65ea,
+	0x2018, 0x2304, 0x9405, 0x201a, 0x707f, 0x0001, 0x20e9, 0x0000,
+	0x20a1, 0x024e, 0x20e1, 0x0001, 0x2898, 0x20a9, 0x0008, 0x4003,
+	0x9085, 0x0001, 0x0008, 0x9006, 0x009e, 0x008e, 0x0005, 0x0156,
+	0x01c6, 0x01d6, 0x0136, 0x0146, 0x22a8, 0x20e1, 0x0000, 0x2099,
+	0x026e, 0x20e9, 0x0000, 0x2011, 0x024e, 0x22a0, 0x4003, 0x014e,
+	0x013e, 0x01de, 0x01ce, 0x015e, 0x2118, 0x9026, 0x2001, 0x0007,
+	0x939a, 0x0010, 0x0218, 0x8420, 0x8001, 0x0cd0, 0x2118, 0x84ff,
+	0x0120, 0x939a, 0x0010, 0x8421, 0x1de0, 0x2021, 0x0001, 0x83ff,
+	0x0118, 0x8423, 0x8319, 0x1de8, 0x9238, 0x2029, 0x026e, 0x9528,
+	0x2504, 0x942c, 0x11b8, 0x9405, 0x203a, 0x7156, 0x91a0, 0x2f92,
+	0x242d, 0x95ac, 0x00ff, 0x757a, 0x6532, 0x6536, 0x0016, 0x2508,
+	0x080c, 0x251f, 0x001e, 0x60e7, 0x0000, 0x65ea, 0x707f, 0x0001,
+	0x9084, 0x0000, 0x0005, 0x00e6, 0x2071, 0x1800, 0x7083, 0x0000,
+	0x00ee, 0x0005, 0x00e6, 0x00f6, 0x2079, 0x0100, 0x2071, 0x0140,
+	0x080c, 0x5940, 0x080c, 0x8fbb, 0x7004, 0x9084, 0x4000, 0x0110,
+	0x080c, 0x2997, 0x0126, 0x2091, 0x8000, 0x2071, 0x1824, 0x2073,
+	0x0000, 0x7840, 0x0026, 0x0016, 0x2009, 0x00f7, 0x080c, 0x599d,
+	0x001e, 0x9094, 0x0010, 0x9285, 0x0080, 0x7842, 0x7a42, 0x002e,
+	0x012e, 0x00fe, 0x00ee, 0x0005, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x283d, 0x0228, 0x2011, 0x0101, 0x2204, 0xc0c5, 0x2012, 0x2011,
+	0x19c0, 0x2013, 0x0000, 0x708b, 0x0000, 0x012e, 0x60a3, 0x0056,
+	0x60a7, 0x9575, 0x080c, 0x8fb2, 0x6144, 0xd184, 0x0120, 0x7190,
+	0x918d, 0x2000, 0x0018, 0x7184, 0x918d, 0x1000, 0x2011, 0x1968,
+	0x2112, 0x2009, 0x07d0, 0x2011, 0x588a, 0x080c, 0x7cd9, 0x0005,
+	0x0016, 0x0026, 0x00c6, 0x0126, 0x2091, 0x8000, 0x080c, 0x9947,
+	0x2009, 0x00f7, 0x080c, 0x599d, 0x2061, 0x19c9, 0x900e, 0x611a,
+	0x611e, 0x6172, 0x6176, 0x2061, 0x1800, 0x6003, 0x0001, 0x2061,
+	0x0100, 0x6043, 0x0090, 0x6043, 0x0010, 0x2009, 0x1968, 0x200b,
+	0x0000, 0x2009, 0x002d, 0x2011, 0x590c, 0x080c, 0x7c3e, 0x012e,
+	0x00ce, 0x002e, 0x001e, 0x0005, 0x00e6, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x0471, 0x2071, 0x0100, 0x080c, 0x8fbb, 0x2071, 0x0140,
+	0x7004, 0x9084, 0x4000, 0x0110, 0x080c, 0x2997, 0x080c, 0x6c5b,
+	0x0188, 0x080c, 0x6c76, 0x1170, 0x080c, 0x6f34, 0x0016, 0x080c,
+	0x25ee, 0x2001, 0x193e, 0x2102, 0x001e, 0x080c, 0x6f2f, 0x080c,
+	0x6b8a, 0x0050, 0x2009, 0x0001, 0x080c, 0x28d6, 0x2001, 0x0001,
+	0x080c, 0x247f, 0x080c, 0x58e0, 0x012e, 0x000e, 0x00ee, 0x0005,
+	0x2001, 0x180d, 0x2004, 0xd0bc, 0x0158, 0x0026, 0x0036, 0x2011,
+	0x8017, 0x2001, 0x1968, 0x201c, 0x080c, 0x4672, 0x003e, 0x002e,
+	0x0005, 0x20a9, 0x0012, 0x20e9, 0x0001, 0x20a1, 0x1c80, 0x080c,
+	0x59fb, 0x20e9, 0x0000, 0x2099, 0x026e, 0x0099, 0x20a9, 0x0020,
+	0x080c, 0x59f5, 0x2099, 0x0260, 0x20a1, 0x1c92, 0x0051, 0x20a9,
+	0x000e, 0x080c, 0x59f8, 0x2099, 0x0260, 0x20a1, 0x1cb2, 0x0009,
+	0x0005, 0x0016, 0x0026, 0x3410, 0x3308, 0x2104, 0x8007, 0x2012,
+	0x8108, 0x8210, 0x1f04, 0x5975, 0x002e, 0x001e, 0x0005, 0x080c,
+	0x97ce, 0x20e1, 0x0001, 0x2099, 0x1c00, 0x20e9, 0x0000, 0x20a1,
+	0x0240, 0x20a9, 0x000c, 0x4003, 0x0005, 0x080c, 0x97ce, 0x080c,
+	0x59fb, 0x20e1, 0x0000, 0x2099, 0x0260, 0x20e9, 0x0000, 0x20a1,
+	0x0240, 0x20a9, 0x000c, 0x4003, 0x0005, 0x00c6, 0x0006, 0x2061,
+	0x0100, 0x810f, 0x2001, 0x1832, 0x2004, 0x9005, 0x1138, 0x2001,
+	0x1816, 0x2004, 0x9084, 0x00ff, 0x9105, 0x0010, 0x9185, 0x00f7,
+	0x604a, 0x000e, 0x00ce, 0x0005, 0x0016, 0x0046, 0x080c, 0x62a0,
+	0x0158, 0x9006, 0x2020, 0x2009, 0x002a, 0x080c, 0xcfe6, 0x2001,
+	0x180c, 0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x900e, 0x080c,
+	0x2dfb, 0x080c, 0xbcec, 0x0140, 0x0036, 0x2019, 0xffff, 0x2021,
+	0x0007, 0x080c, 0x4829, 0x003e, 0x004e, 0x001e, 0x0005, 0x080c,
+	0x58e0, 0x7093, 0x0000, 0x708b, 0x0000, 0x0005, 0x0006, 0x2001,
+	0x180c, 0x2004, 0xd09c, 0x0100, 0x000e, 0x0005, 0x0006, 0x0016,
+	0x0126, 0x2091, 0x8000, 0x2001, 0x0101, 0x200c, 0x918d, 0x0006,
+	0x2102, 0x012e, 0x001e, 0x000e, 0x0005, 0x2009, 0x0001, 0x0020,
+	0x2009, 0x0002, 0x0008, 0x900e, 0x6814, 0x9084, 0xffc0, 0x910d,
+	0x6916, 0x0005, 0x00f6, 0x0156, 0x0146, 0x01d6, 0x9006, 0x20a9,
+	0x0080, 0x20e9, 0x0001, 0x20a1, 0x1c00, 0x4004, 0x2079, 0x1c00,
+	0x7803, 0x2200, 0x7807, 0x00ef, 0x780f, 0x00ef, 0x7813, 0x0138,
+	0x7823, 0xffff, 0x7827, 0xffff, 0x01de, 0x014e, 0x015e, 0x00fe,
+	0x0005, 0x2001, 0x1800, 0x2003, 0x0001, 0x0005, 0x2001, 0x1975,
+	0x0118, 0x2003, 0x0001, 0x0010, 0x2003, 0x0000, 0x0005, 0x0156,
+	0x20a9, 0x0800, 0x2009, 0x1000, 0x9006, 0x200a, 0x8108, 0x1f04,
+	0x5a35, 0x015e, 0x0005, 0x00d6, 0x0036, 0x0156, 0x0136, 0x0146,
+	0x2069, 0x1853, 0x9006, 0xb802, 0xb8be, 0xb807, 0x0707, 0xb80a,
+	0xb80e, 0xb812, 0x9198, 0x2f92, 0x231d, 0x939c, 0x00ff, 0xbb16,
+	0x0016, 0x0026, 0xb8b2, 0x080c, 0x9940, 0x1120, 0x9192, 0x007e,
+	0x1208, 0xbbb2, 0x20a9, 0x0004, 0xb8b4, 0x20e8, 0xb9b8, 0x9198,
+	0x0006, 0x9006, 0x23a0, 0x4004, 0x20a9, 0x0004, 0x9198, 0x000a,
+	0x23a0, 0x4004, 0x002e, 0x001e, 0xb83e, 0xb842, 0xb84e, 0xb852,
+	0xb856, 0xb85a, 0xb85e, 0xb862, 0xb866, 0xb86a, 0xb86f, 0x0100,
+	0xb872, 0xb876, 0xb87a, 0xb88a, 0xb88e, 0xb893, 0x0008, 0xb896,
+	0xb89a, 0xb89e, 0xb8ae, 0xb9a2, 0x0096, 0xb8a4, 0x904d, 0x0110,
+	0x080c, 0x1007, 0xb8a7, 0x0000, 0x009e, 0x9006, 0xb84a, 0x6810,
+	0xb83a, 0x680c, 0xb846, 0x6814, 0x9084, 0x00ff, 0xb842, 0x014e,
+	0x013e, 0x015e, 0x003e, 0x00de, 0x0005, 0x0126, 0x2091, 0x8000,
+	0xa974, 0xae78, 0x9684, 0x3fff, 0x9082, 0x4000, 0x1a04, 0x5b0b,
+	0x9182, 0x0800, 0x1a04, 0x5b0f, 0x2001, 0x180c, 0x2004, 0x9084,
+	0x0003, 0x1904, 0x5b15, 0x9188, 0x1000, 0x2104, 0x905d, 0x0518,
+	0xb804, 0x9084, 0x00ff, 0x908e, 0x0006, 0x1508, 0xb8a4, 0x900d,
+	0x1904, 0x5b27, 0xb850, 0x900d, 0x1148, 0xa802, 0x2900, 0xb852,
+	0xb84e, 0x080c, 0x801d, 0x9006, 0x012e, 0x0005, 0x00a6, 0x2150,
+	0x2900, 0xb002, 0xa803, 0x0000, 0x00ae, 0xb852, 0x0c90, 0x2001,
+	0x0005, 0x900e, 0x04b8, 0x2001, 0x0028, 0x900e, 0x0498, 0x9082,
+	0x0006, 0x1290, 0x080c, 0x9940, 0x1160, 0xb8a0, 0x9084, 0xff80,
+	0x1140, 0xb900, 0xd1fc, 0x0990, 0x2001, 0x0029, 0x2009, 0x1000,
+	0x0408, 0x2001, 0x0028, 0x00a8, 0x2009, 0x180c, 0x210c, 0xd18c,
+	0x0118, 0x2001, 0x0004, 0x0068, 0xd184, 0x0118, 0x2001, 0x0004,
+	0x0040, 0x2001, 0x0029, 0xb900, 0xd1fc, 0x0118, 0x2009, 0x1000,
+	0x0048, 0x900e, 0x0038, 0x2001, 0x0029, 0x900e, 0x0018, 0x2001,
+	0x0029, 0x900e, 0x9005, 0x012e, 0x0005, 0x2001, 0x180c, 0x2004,
+	0xd084, 0x19d0, 0x9188, 0x1000, 0x2104, 0x905d, 0x09a8, 0x080c,
+	0x62a4, 0x1990, 0xb800, 0xd0bc, 0x0978, 0x0804, 0x5abe, 0x080c,
+	0x611a, 0x0904, 0x5ad7, 0x0804, 0x5ac2, 0x00b6, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0xa974, 0x9182, 0x0800, 0x1a04, 0x5ba8, 0x9188,
+	0x1000, 0x2104, 0x905d, 0x0904, 0x5b80, 0xb8a0, 0x9086, 0x007f,
+	0x0178, 0x080c, 0x62ac, 0x0160, 0xa994, 0x81ff, 0x0130, 0x908e,
+	0x0004, 0x0130, 0x908e, 0x0005, 0x0118, 0x080c, 0x62a4, 0x1598,
+	0xa87c, 0xd0fc, 0x01e0, 0xa894, 0x9005, 0x01c8, 0x2060, 0x0026,
+	0x2010, 0x080c, 0xb5e9, 0x002e, 0x1120, 0x2001, 0x0008, 0x0804,
+	0x5baa, 0x6020, 0x9086, 0x000a, 0x0120, 0x2001, 0x0008, 0x0804,
+	0x5baa, 0x601a, 0x6003, 0x0008, 0x2900, 0x6016, 0x0058, 0x080c,
+	0x9980, 0x05e8, 0x2b00, 0x6012, 0x2900, 0x6016, 0x600b, 0xffff,
+	0x6023, 0x000a, 0x2009, 0x0003, 0x080c, 0x9a50, 0x9006, 0x0458,
+	0x2001, 0x0028, 0x0438, 0x9082, 0x0006, 0x1290, 0x080c, 0x9940,
+	0x1160, 0xb8a0, 0x9084, 0xff80, 0x1140, 0xb900, 0xd1fc, 0x0900,
+	0x2001, 0x0029, 0x2009, 0x1000, 0x00a8, 0x2001, 0x0028, 0x0090,
+	0x2009, 0x180c, 0x210c, 0xd18c, 0x0118, 0x2001, 0x0004, 0x0050,
+	0xd184, 0x0118, 0x2001, 0x0004, 0x0028, 0x2001, 0x0029, 0x0010,
+	0x2001, 0x0029, 0x9005, 0x012e, 0x00ee, 0x00be, 0x0005, 0x2001,
+	0x002c, 0x0cc0, 0x00f6, 0x00b6, 0x0126, 0x2091, 0x8000, 0xa8e0,
+	0x9005, 0x1550, 0xa8dc, 0x9082, 0x0101, 0x1630, 0xa8c8, 0x9005,
+	0x1518, 0xa8c4, 0x9082, 0x0101, 0x12f8, 0xa974, 0x2079, 0x1800,
+	0x9182, 0x0800, 0x12e8, 0x7830, 0x9084, 0x0003, 0x1130, 0xaa98,
+	0xab94, 0xa878, 0x9084, 0x0007, 0x00ea, 0x7930, 0xd18c, 0x0118,
+	0x2001, 0x0004, 0x0038, 0xd184, 0x0118, 0x2001, 0x0004, 0x0010,
+	0x2001, 0x0029, 0x900e, 0x0038, 0x2001, 0x002c, 0x900e, 0x0018,
+	0x2001, 0x0029, 0x900e, 0x9006, 0x0008, 0x9005, 0x012e, 0x00be,
+	0x00fe, 0x0005, 0x5c3f, 0x5bfa, 0x5c11, 0x5c3f, 0x5c3f, 0x5c3f,
+	0x5c3f, 0x5c3f, 0x2100, 0x9082, 0x007e, 0x1278, 0x080c, 0x5f1e,
+	0x0148, 0x9046, 0xb810, 0x9306, 0x1904, 0x5c47, 0xb814, 0x9206,
+	0x15f0, 0x0028, 0xbb12, 0xba16, 0x0010, 0x080c, 0x452c, 0x0150,
+	0x04b0, 0x080c, 0x5f7e, 0x1598, 0xb810, 0x9306, 0x1580, 0xb814,
+	0x9206, 0x1568, 0x080c, 0x9980, 0x0530, 0x2b00, 0x6012, 0x080c,
+	0xba69, 0x2900, 0x6016, 0x600b, 0xffff, 0x6023, 0x000a, 0xa878,
+	0x9086, 0x0001, 0x1170, 0x080c, 0x2e30, 0x9006, 0x080c, 0x5ebb,
+	0x2001, 0x0002, 0x080c, 0x5ecf, 0x2001, 0x0200, 0xb86e, 0xb893,
+	0x0002, 0x2009, 0x0003, 0x080c, 0x9a50, 0x9006, 0x0068, 0x2001,
+	0x0001, 0x900e, 0x0038, 0x2001, 0x002c, 0x900e, 0x0018, 0x2001,
+	0x0028, 0x900e, 0x9005, 0x0000, 0x012e, 0x00be, 0x00fe, 0x0005,
+	0x00b6, 0x00f6, 0x00e6, 0x0126, 0x2091, 0x8000, 0xa894, 0x90c6,
+	0x0015, 0x0904, 0x5e14, 0x90c6, 0x0056, 0x0904, 0x5e18, 0x90c6,
+	0x0066, 0x0904, 0x5e1c, 0x90c6, 0x0071, 0x0904, 0x5e20, 0x90c6,
+	0x0074, 0x0904, 0x5e24, 0x90c6, 0x007c, 0x0904, 0x5e28, 0x90c6,
+	0x007e, 0x0904, 0x5e2c, 0x90c6, 0x0037, 0x0904, 0x5e30, 0x9016,
+	0x2079, 0x1800, 0xa974, 0x9186, 0x00ff, 0x0904, 0x5e0f, 0x9182,
+	0x0800, 0x1a04, 0x5e0f, 0x080c, 0x5f7e, 0x1198, 0xb804, 0x9084,
+	0x00ff, 0x9082, 0x0006, 0x1268, 0xa894, 0x90c6, 0x006f, 0x0148,
+	0x080c, 0x9940, 0x1904, 0x5df8, 0xb8a0, 0x9084, 0xff80, 0x1904,
+	0x5df8, 0xa894, 0x90c6, 0x006f, 0x0158, 0x90c6, 0x005e, 0x0904,
+	0x5d58, 0x90c6, 0x0064, 0x0904, 0x5d81, 0x2008, 0x0804, 0x5d1b,
+	0xa998, 0xa8b0, 0x2040, 0x080c, 0x9940, 0x1120, 0x9182, 0x007f,
+	0x0a04, 0x5d1b, 0x9186, 0x00ff, 0x0904, 0x5d1b, 0x9182, 0x0800,
+	0x1a04, 0x5d1b, 0xaaa0, 0xab9c, 0x7874, 0x9306, 0x1188, 0x7878,
+	0x0096, 0x924e, 0x1128, 0x2208, 0x2310, 0x009e, 0x0804, 0x5d1b,
+	0x99cc, 0xff00, 0x009e, 0x1120, 0x2208, 0x2310, 0x0804, 0x5d1b,
+	0x080c, 0x452c, 0x0904, 0x5d24, 0x900e, 0x9016, 0x90c6, 0x4000,
+	0x1558, 0x0006, 0x080c, 0x619e, 0x1108, 0xc185, 0xb800, 0xd0bc,
+	0x0108, 0xc18d, 0x20a9, 0x0004, 0xa860, 0x20e8, 0xa85c, 0x9080,
+	0x0031, 0x20a0, 0xb8b4, 0x20e0, 0xb8b8, 0x9080, 0x0006, 0x2098,
+	0x080c, 0x0f52, 0x20a9, 0x0004, 0xa860, 0x20e8, 0xa85c, 0x9080,
+	0x0035, 0x20a0, 0xb8b4, 0x20e0, 0xb8b8, 0x9080, 0x000a, 0x2098,
+	0x080c, 0x0f52, 0x000e, 0x00c8, 0x90c6, 0x4007, 0x1110, 0x2408,
+	0x00a0, 0x90c6, 0x4008, 0x1118, 0x2708, 0x2610, 0x0070, 0x90c6,
+	0x4009, 0x1108, 0x0050, 0x90c6, 0x4006, 0x0138, 0x2001, 0x4005,
+	0x2009, 0x000a, 0x0010, 0x2001, 0x4006, 0xa896, 0xa99a, 0xaa9e,
+	0x2001, 0x0030, 0x900e, 0x0470, 0x080c, 0x9980, 0x1130, 0x2001,
+	0x4005, 0x2009, 0x0003, 0x9016, 0x0c80, 0x2b00, 0x6012, 0x080c,
+	0xba69, 0x2900, 0x6016, 0x6023, 0x0001, 0xa868, 0xd88c, 0x0108,
+	0xc0f5, 0xa86a, 0x0126, 0x2091, 0x8000, 0x080c, 0x2e30, 0x012e,
+	0x9006, 0x080c, 0x5ebb, 0x2001, 0x0002, 0x080c, 0x5ecf, 0x2009,
+	0x0002, 0x080c, 0x9a50, 0xa8b0, 0xd094, 0x0118, 0xb8bc, 0xc08d,
+	0xb8be, 0x9006, 0x9005, 0x012e, 0x00ee, 0x00fe, 0x00be, 0x0005,
+	0x080c, 0x5127, 0x0118, 0x2009, 0x0007, 0x00f8, 0xa998, 0xaeb0,
+	0x080c, 0x5f7e, 0x1904, 0x5d16, 0x9186, 0x007f, 0x0130, 0x080c,
+	0x62a4, 0x0118, 0x2009, 0x0009, 0x0080, 0x0096, 0x080c, 0x0fd5,
+	0x1120, 0x009e, 0x2009, 0x0002, 0x0040, 0x2900, 0x009e, 0xa806,
+	0x080c, 0xb7da, 0x19b0, 0x2009, 0x0003, 0x2001, 0x4005, 0x0804,
+	0x5d1d, 0xa998, 0xaeb0, 0x080c, 0x5f7e, 0x1904, 0x5d16, 0x0096,
+	0x080c, 0x0fd5, 0x1128, 0x009e, 0x2009, 0x0002, 0x0804, 0x5dd5,
+	0x2900, 0x009e, 0xa806, 0x0096, 0x2048, 0x20a9, 0x002b, 0xb8b4,
+	0x20e0, 0xb8b8, 0x2098, 0xa860, 0x20e8, 0xa85c, 0x9080, 0x0002,
+	0x20a0, 0x4003, 0x20a9, 0x0008, 0x9080, 0x0006, 0x20a0, 0xbbb8,
+	0x9398, 0x0006, 0x2398, 0x080c, 0x0f52, 0x009e, 0xa87b, 0x0000,
+	0xa883, 0x0000, 0xa897, 0x4000, 0xd684, 0x1168, 0x080c, 0x5113,
+	0xd0b4, 0x1118, 0xa89b, 0x000b, 0x00e0, 0xb800, 0xd08c, 0x0118,
+	0xa89b, 0x000c, 0x00b0, 0x080c, 0x62a4, 0x0118, 0xa89b, 0x0009,
+	0x0080, 0x080c, 0x5127, 0x0118, 0xa89b, 0x0007, 0x0050, 0x080c,
+	0xb7bd, 0x1904, 0x5d51, 0x2009, 0x0003, 0x2001, 0x4005, 0x0804,
+	0x5d1d, 0xa87b, 0x0030, 0xa897, 0x4005, 0xa804, 0x8006, 0x8006,
+	0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080, 0x0002, 0x2009,
+	0x002b, 0xaaa0, 0xab9c, 0xaca8, 0xada4, 0x2031, 0x0000, 0x2041,
+	0x120c, 0x080c, 0x9ed6, 0x1904, 0x5d51, 0x2009, 0x0002, 0x08e8,
+	0x2001, 0x0028, 0x900e, 0x0804, 0x5d52, 0x2009, 0x180c, 0x210c,
+	0xd18c, 0x0118, 0x2001, 0x0004, 0x0038, 0xd184, 0x0118, 0x2001,
+	0x0004, 0x0010, 0x2001, 0x0029, 0x900e, 0x0804, 0x5d52, 0x2001,
+	0x0029, 0x900e, 0x0804, 0x5d52, 0x080c, 0x33b6, 0x0804, 0x5d53,
+	0x080c, 0x4e50, 0x0804, 0x5d53, 0x080c, 0x41a5, 0x0804, 0x5d53,
+	0x080c, 0x45e8, 0x0804, 0x5d53, 0x080c, 0x489f, 0x0804, 0x5d53,
+	0x080c, 0x4aca, 0x0804, 0x5d53, 0x080c, 0x4cbb, 0x0804, 0x5d53,
+	0x080c, 0x35c6, 0x0804, 0x5d53, 0x00b6, 0xa974, 0xae78, 0x9684,
+	0x3fff, 0x9082, 0x4000, 0x1618, 0x9182, 0x0800, 0x1268, 0x9188,
+	0x1000, 0x2104, 0x905d, 0x0140, 0x080c, 0x62a4, 0x1148, 0x00e9,
+	0x080c, 0x60a9, 0x9006, 0x00b0, 0x2001, 0x0028, 0x900e, 0x0090,
+	0x9082, 0x0006, 0x1240, 0xb900, 0xd1fc, 0x0d88, 0x2001, 0x0029,
+	0x2009, 0x1000, 0x0038, 0x2001, 0x0029, 0x900e, 0x0018, 0x2001,
+	0x0029, 0x900e, 0x9005, 0x00be, 0x0005, 0x0126, 0x2091, 0x8000,
+	0xb850, 0x900d, 0x0150, 0x2900, 0x0096, 0x2148, 0xa802, 0x009e,
+	0xa803, 0x0000, 0xb852, 0x012e, 0x0005, 0x2900, 0xb852, 0xb84e,
+	0xa803, 0x0000, 0x0cc0, 0x0126, 0x2091, 0x8000, 0xb84c, 0x9005,
+	0x0170, 0x00e6, 0x2071, 0x19b6, 0x7004, 0x9086, 0x0002, 0x0168,
+	0x00ee, 0xb84c, 0xa802, 0x2900, 0xb84e, 0x012e, 0x0005, 0x2900,
+	0xb852, 0xb84e, 0xa803, 0x0000, 0x0cc0, 0x701c, 0x9b06, 0x1d80,
+	0xb84c, 0x00a6, 0x2050, 0xb000, 0xa802, 0x2900, 0xb002, 0x00ae,
+	0x00ee, 0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0xb84c, 0x904d,
+	0x0130, 0xa800, 0x9005, 0x1108, 0xb852, 0xb84e, 0x9905, 0x012e,
+	0x0005, 0xb84c, 0x904d, 0x0130, 0xa800, 0x9005, 0x1108, 0xb852,
+	0xb84e, 0x9905, 0x0005, 0x00b6, 0x0126, 0x00c6, 0x0026, 0x2091,
+	0x8000, 0x6210, 0x2258, 0xba00, 0x9005, 0x0110, 0xc285, 0x0008,
+	0xc284, 0xba02, 0x002e, 0x00ce, 0x012e, 0x00be, 0x0005, 0x00b6,
+	0x0126, 0x00c6, 0x2091, 0x8000, 0x6210, 0x2258, 0xba04, 0x0006,
+	0x9086, 0x0006, 0x1170, 0xb89c, 0xd0ac, 0x0158, 0x080c, 0x62a0,
+	0x0140, 0x9284, 0xff00, 0x8007, 0x9086, 0x0007, 0x1110, 0x2011,
+	0x0600, 0x000e, 0x9294, 0xff00, 0x9215, 0xba06, 0x0006, 0x9086,
+	0x0006, 0x1120, 0xba90, 0x82ff, 0x090c, 0x0db2, 0x000e, 0x00ce,
+	0x012e, 0x00be, 0x0005, 0x00b6, 0x0126, 0x00c6, 0x2091, 0x8000,
+	0x6210, 0x2258, 0xba04, 0x0006, 0x9086, 0x0006, 0x1168, 0xb89c,
+	0xd0a4, 0x0150, 0x080c, 0x629c, 0x1138, 0x9284, 0x00ff, 0x9086,
+	0x0007, 0x1110, 0x2011, 0x0006, 0x000e, 0x9294, 0x00ff, 0x8007,
+	0x9215, 0xba06, 0x00ce, 0x012e, 0x00be, 0x0005, 0x9182, 0x0800,
+	0x0218, 0x9085, 0x0001, 0x0005, 0x00d6, 0x0026, 0x9190, 0x1000,
+	0x2204, 0x905d, 0x1180, 0x0096, 0x080c, 0x0fd5, 0x2958, 0x009e,
+	0x0160, 0x2b00, 0x2012, 0xb85c, 0xb8ba, 0xb860, 0xb8b6, 0x9006,
+	0xb8a6, 0x080c, 0x5a3b, 0x9006, 0x0010, 0x9085, 0x0001, 0x002e,
+	0x00de, 0x0005, 0x00b6, 0x0096, 0x0126, 0x2091, 0x8000, 0x0026,
+	0x9182, 0x0800, 0x0218, 0x9085, 0x0001, 0x0458, 0x00d6, 0x9190,
+	0x1000, 0x2204, 0x905d, 0x0518, 0x2013, 0x0000, 0xb8a4, 0x904d,
+	0x0110, 0x080c, 0x1007, 0x00d6, 0x00c6, 0xb8ac, 0x2060, 0x8cff,
+	0x0168, 0x600c, 0x0006, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x0110,
+	0x080c, 0x0f87, 0x080c, 0x99d6, 0x00ce, 0x0c88, 0x00ce, 0x00de,
+	0x2b48, 0xb8b8, 0xb85e, 0xb8b4, 0xb862, 0x080c, 0x1017, 0x00de,
+	0x9006, 0x002e, 0x012e, 0x009e, 0x00be, 0x0005, 0x0016, 0x9182,
+	0x0800, 0x0218, 0x9085, 0x0001, 0x0030, 0x9188, 0x1000, 0x2104,
+	0x905d, 0x0dc0, 0x9006, 0x001e, 0x0005, 0x00d6, 0x0156, 0x0136,
+	0x0146, 0x9006, 0xb80a, 0xb80e, 0xb800, 0xc08c, 0xb802, 0x080c,
+	0x6c53, 0x1510, 0xb8a0, 0x9086, 0x007e, 0x0120, 0x080c, 0x9940,
+	0x11d8, 0x0078, 0x7040, 0xd0e4, 0x01b8, 0x00c6, 0x2061, 0x1951,
+	0x7048, 0x2062, 0x704c, 0x6006, 0x7050, 0x600a, 0x7054, 0x600e,
+	0x00ce, 0x703c, 0x2069, 0x0140, 0x9005, 0x1110, 0x2001, 0x0001,
+	0x6886, 0x2069, 0x1800, 0x68ae, 0x7040, 0xb85e, 0x7048, 0xb862,
+	0x704c, 0xb866, 0x20e1, 0x0000, 0x2099, 0x0276, 0xb8b4, 0x20e8,
+	0xb8b8, 0x9088, 0x000a, 0x21a0, 0x20a9, 0x0004, 0x4003, 0x2099,
+	0x027a, 0x9088, 0x0006, 0x21a0, 0x20a9, 0x0004, 0x4003, 0x2069,
+	0x0200, 0x6817, 0x0001, 0x7040, 0xb86a, 0x7144, 0xb96e, 0x7048,
+	0xb872, 0x7050, 0xb876, 0x2069, 0x0200, 0x6817, 0x0000, 0xb8a0,
+	0x9086, 0x007e, 0x1110, 0x7144, 0xb96e, 0x9182, 0x0211, 0x1218,
+	0x2009, 0x0008, 0x0400, 0x9182, 0x0259, 0x1218, 0x2009, 0x0007,
+	0x00d0, 0x9182, 0x02c1, 0x1218, 0x2009, 0x0006, 0x00a0, 0x9182,
+	0x0349, 0x1218, 0x2009, 0x0005, 0x0070, 0x9182, 0x0421, 0x1218,
+	0x2009, 0x0004, 0x0040, 0x9182, 0x0581, 0x1218, 0x2009, 0x0003,
+	0x0010, 0x2009, 0x0002, 0xb992, 0x014e, 0x013e, 0x015e, 0x00de,
+	0x0005, 0x0016, 0x0026, 0x00e6, 0x2071, 0x0260, 0x7034, 0xb896,
+	0x703c, 0xb89a, 0x7054, 0xb89e, 0x0036, 0xbbbc, 0xc384, 0xba00,
+	0x2009, 0x1873, 0x210c, 0xd0bc, 0x0120, 0xd1ec, 0x0110, 0xc2ad,
+	0x0008, 0xc2ac, 0xd0c4, 0x0148, 0xd1e4, 0x0138, 0xc2bd, 0xd0cc,
+	0x0128, 0xd38c, 0x1108, 0xc385, 0x0008, 0xc2bc, 0xba02, 0xbbbe,
+	0x003e, 0x00ee, 0x002e, 0x001e, 0x0005, 0x0096, 0x0126, 0x2091,
+	0x8000, 0xb8a4, 0x904d, 0x0578, 0xa900, 0x81ff, 0x15c0, 0xaa04,
+	0x9282, 0x0010, 0x16c8, 0x0136, 0x0146, 0x01c6, 0x01d6, 0x8906,
+	0x8006, 0x8007, 0x908c, 0x003f, 0x21e0, 0x9084, 0xffc0, 0x9080,
+	0x0004, 0x2098, 0x2009, 0x0010, 0x20a9, 0x0001, 0x4002, 0x9086,
+	0xffff, 0x0120, 0x8109, 0x1dd0, 0x080c, 0x0db2, 0x3c00, 0x20e8,
+	0x3300, 0x8001, 0x20a0, 0x4604, 0x8210, 0xaa06, 0x01de, 0x01ce,
+	0x014e, 0x013e, 0x0060, 0x080c, 0x0fd5, 0x0170, 0x2900, 0xb8a6,
+	0xa803, 0x0000, 0x080c, 0x613a, 0xa807, 0x0001, 0xae12, 0x9085,
+	0x0001, 0x012e, 0x009e, 0x0005, 0x9006, 0x0cd8, 0x0126, 0x2091,
+	0x8000, 0x0096, 0xb8a4, 0x904d, 0x0188, 0xa800, 0x9005, 0x1150,
+	0x080c, 0x6149, 0x1158, 0xa804, 0x908a, 0x0002, 0x0218, 0x8001,
+	0xa806, 0x0020, 0x080c, 0x1007, 0xb8a7, 0x0000, 0x009e, 0x012e,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x080c, 0x801d, 0x012e, 0x0005,
+	0x901e, 0x0010, 0x2019, 0x0001, 0x900e, 0x0126, 0x2091, 0x8000,
+	0xb84c, 0x2048, 0xb800, 0xd0dc, 0x1170, 0x89ff, 0x0500, 0x83ff,
+	0x0120, 0xa878, 0x9606, 0x0158, 0x0030, 0xa86c, 0x9406, 0x1118,
+	0xa870, 0x9506, 0x0120, 0x2908, 0xa800, 0x2048, 0x0c70, 0x080c,
+	0x933f, 0xaa00, 0xb84c, 0x9906, 0x1110, 0xba4e, 0x0020, 0x00a6,
+	0x2150, 0xb202, 0x00ae, 0x82ff, 0x1110, 0xb952, 0x89ff, 0x012e,
+	0x0005, 0x9016, 0x0489, 0x1110, 0x2011, 0x0001, 0x0005, 0x080c,
+	0x619e, 0x0128, 0x080c, 0xb6c3, 0x0010, 0x9085, 0x0001, 0x0005,
+	0x080c, 0x619e, 0x0128, 0x080c, 0xb65d, 0x0010, 0x9085, 0x0001,
+	0x0005, 0x080c, 0x619e, 0x0128, 0x080c, 0xb6c0, 0x0010, 0x9085,
+	0x0001, 0x0005, 0x080c, 0x619e, 0x0128, 0x080c, 0xb681, 0x0010,
+	0x9085, 0x0001, 0x0005, 0x080c, 0x619e, 0x0128, 0x080c, 0xb6ed,
+	0x0010, 0x9085, 0x0001, 0x0005, 0xb8a4, 0x900d, 0x1118, 0x9085,
+	0x0001, 0x0005, 0x0136, 0x01c6, 0xa800, 0x9005, 0x11b8, 0x890e,
+	0x810e, 0x810f, 0x9184, 0x003f, 0x20e0, 0x9184, 0xffc0, 0x9080,
+	0x0004, 0x2098, 0x20a9, 0x0001, 0x2009, 0x0010, 0x4002, 0x9606,
+	0x0128, 0x8109, 0x1dd8, 0x9085, 0x0001, 0x0008, 0x9006, 0x01ce,
+	0x013e, 0x0005, 0x0146, 0x01d6, 0xa860, 0x20e8, 0xa85c, 0x9080,
+	0x0004, 0x20a0, 0x20a9, 0x0010, 0x2009, 0xffff, 0x4104, 0x01de,
+	0x014e, 0x0136, 0x01c6, 0xa800, 0x9005, 0x11b8, 0x890e, 0x810e,
+	0x810f, 0x9184, 0x003f, 0x20e0, 0x9184, 0xffc0, 0x9080, 0x0004,
+	0x2098, 0x20a9, 0x0001, 0x2009, 0x0010, 0x4002, 0x9606, 0x0128,
+	0x8109, 0x1dd8, 0x9085, 0x0001, 0x0068, 0x0146, 0x01d6, 0x3300,
+	0x8001, 0x20a0, 0x3c00, 0x20e8, 0x2001, 0xffff, 0x4004, 0x01de,
+	0x014e, 0x9006, 0x01ce, 0x013e, 0x0005, 0x0096, 0x0126, 0x2091,
+	0x8000, 0xb8a4, 0x904d, 0x1128, 0x080c, 0x0fd5, 0x0168, 0x2900,
+	0xb8a6, 0x080c, 0x613a, 0xa803, 0x0001, 0xa807, 0x0000, 0x9085,
+	0x0001, 0x012e, 0x009e, 0x0005, 0x9006, 0x0cd8, 0x0096, 0x0126,
+	0x2091, 0x8000, 0xb8a4, 0x904d, 0x0130, 0xb8a7, 0x0000, 0x080c,
+	0x1007, 0x9085, 0x0001, 0x012e, 0x009e, 0x0005, 0xb89c, 0xd0a4,
+	0x0005, 0x00b6, 0x00f6, 0x080c, 0x6c53, 0x01b0, 0x71bc, 0x81ff,
+	0x1198, 0x71d4, 0xd19c, 0x0180, 0x2001, 0x007e, 0x9080, 0x1000,
+	0x2004, 0x905d, 0x0148, 0xb804, 0x9084, 0x00ff, 0x9086, 0x0006,
+	0x1118, 0xb800, 0xc0ed, 0xb802, 0x2079, 0x1853, 0x7804, 0xd0a4,
+	0x01d0, 0x0156, 0x20a9, 0x007f, 0x900e, 0x0016, 0x080c, 0x5f7e,
+	0x1168, 0xb804, 0x9084, 0xff00, 0x8007, 0x9096, 0x0004, 0x0118,
+	0x9086, 0x0006, 0x1118, 0xb800, 0xc0ed, 0xb802, 0x001e, 0x8108,
+	0x1f04, 0x61c5, 0x015e, 0x080c, 0x6262, 0x0120, 0x2001, 0x1954,
+	0x200c, 0x0038, 0x2079, 0x1853, 0x7804, 0xd0a4, 0x0130, 0x2009,
+	0x07d0, 0x2011, 0x61f0, 0x080c, 0x7cd9, 0x00fe, 0x00be, 0x0005,
+	0x00b6, 0x2011, 0x61f0, 0x080c, 0x7c4a, 0x080c, 0x6262, 0x01d8,
+	0x2001, 0x107e, 0x2004, 0x2058, 0xb900, 0xc1ec, 0xb902, 0x080c,
+	0x62a0, 0x0130, 0x2009, 0x07d0, 0x2011, 0x61f0, 0x080c, 0x7cd9,
+	0x00e6, 0x2071, 0x1800, 0x9006, 0x7076, 0x7058, 0x707a, 0x080c,
+	0x2c2b, 0x00ee, 0x04b0, 0x0156, 0x00c6, 0x20a9, 0x007f, 0x900e,
+	0x0016, 0x080c, 0x5f7e, 0x1538, 0xb800, 0xd0ec, 0x0520, 0x0046,
+	0xbaa0, 0x2220, 0x9006, 0x2009, 0x0029, 0x080c, 0xcfe6, 0xb800,
+	0xc0e5, 0xc0ec, 0xb802, 0x080c, 0x629c, 0x2001, 0x0707, 0x1128,
+	0xb804, 0x9084, 0x00ff, 0x9085, 0x0700, 0xb806, 0x2019, 0x0029,
+	0x080c, 0x8180, 0x0076, 0x903e, 0x080c, 0x8078, 0x900e, 0x080c,
+	0xcd62, 0x007e, 0x004e, 0x001e, 0x8108, 0x1f04, 0x6218, 0x00ce,
+	0x015e, 0x00be, 0x0005, 0x00b6, 0x6010, 0x2058, 0xb800, 0xc0ec,
+	0xb802, 0x00be, 0x0005, 0x7810, 0x00b6, 0x2058, 0xb800, 0x00be,
+	0xd0ac, 0x0005, 0x6010, 0x00b6, 0x905d, 0x0108, 0xb800, 0x00be,
+	0xd0bc, 0x0005, 0x00b6, 0x00f6, 0x2001, 0x107e, 0x2004, 0x905d,
+	0x0110, 0xb800, 0xd0ec, 0x00fe, 0x00be, 0x0005, 0x0126, 0x0026,
+	0x2091, 0x8000, 0x0006, 0xbaa0, 0x9290, 0x1000, 0x2204, 0x9b06,
+	0x190c, 0x0db2, 0x000e, 0xba00, 0x9005, 0x0110, 0xc2fd, 0x0008,
+	0xc2fc, 0xba02, 0x002e, 0x012e, 0x0005, 0x2011, 0x1835, 0x2204,
+	0xd0cc, 0x0138, 0x2001, 0x1952, 0x200c, 0x2011, 0x6292, 0x080c,
+	0x7cd9, 0x0005, 0x2011, 0x6292, 0x080c, 0x7c4a, 0x2011, 0x1835,
+	0x2204, 0xc0cc, 0x2012, 0x0005, 0x080c, 0x5113, 0xd0ac, 0x0005,
+	0x080c, 0x5113, 0xd0a4, 0x0005, 0x0016, 0xb904, 0x9184, 0x00ff,
+	0x908e, 0x0006, 0x001e, 0x0005, 0x0016, 0xb904, 0x9184, 0xff00,
+	0x8007, 0x908e, 0x0006, 0x001e, 0x0005, 0x00b6, 0x00f6, 0x080c,
+	0xbcec, 0x0158, 0x70d4, 0x9084, 0x0028, 0x0138, 0x2001, 0x107f,
+	0x2004, 0x905d, 0x0110, 0xb8bc, 0xd094, 0x00fe, 0x00be, 0x0005,
+	0x2071, 0x1906, 0x7003, 0x0001, 0x7007, 0x0000, 0x9006, 0x7012,
+	0x7016, 0x701a, 0x701e, 0x700a, 0x7046, 0x2001, 0x1919, 0x2003,
+	0x0000, 0x0005, 0x0016, 0x00e6, 0x2071, 0x191a, 0x900e, 0x710a,
+	0x080c, 0x5113, 0xd0fc, 0x1140, 0x080c, 0x5113, 0x900e, 0xd09c,
+	0x0108, 0x8108, 0x7102, 0x00f8, 0x2001, 0x1873, 0x200c, 0x9184,
+	0x0007, 0x0002, 0x62e4, 0x62e4, 0x62e4, 0x62e4, 0x62e4, 0x62fa,
+	0x6308, 0x62e4, 0x7003, 0x0003, 0x2009, 0x1874, 0x210c, 0x9184,
+	0xff00, 0x8007, 0x9005, 0x1110, 0x2001, 0x0002, 0x7006, 0x0018,
+	0x7003, 0x0005, 0x0c88, 0x00ee, 0x001e, 0x0005, 0x00e6, 0x2071,
+	0x0050, 0x684c, 0x9005, 0x1150, 0x00e6, 0x2071, 0x1906, 0x7028,
+	0xc085, 0x702a, 0x00ee, 0x9085, 0x0001, 0x0488, 0x6844, 0x9005,
+	0x0158, 0x080c, 0x6f9c, 0x6a60, 0x9200, 0x7002, 0x6864, 0x9101,
+	0x7006, 0x9006, 0x7012, 0x7016, 0x6860, 0x7002, 0x6864, 0x7006,
+	0x6868, 0x700a, 0x686c, 0x700e, 0x6844, 0x9005, 0x1110, 0x7012,
+	0x7016, 0x684c, 0x701a, 0x701c, 0x9085, 0x0040, 0x701e, 0x7037,
+	0x0019, 0x702b, 0x0001, 0x00e6, 0x2071, 0x1906, 0x7028, 0xc084,
+	0x702a, 0x7007, 0x0001, 0x700b, 0x0000, 0x00ee, 0x9006, 0x00ee,
+	0x0005, 0xa868, 0xd0fc, 0x11d8, 0x00e6, 0x0026, 0x2001, 0x191a,
+	0x2004, 0x9005, 0x0904, 0x653b, 0xa87c, 0xd0bc, 0x1904, 0x653b,
+	0xa978, 0xa874, 0x9105, 0x1904, 0x653b, 0x2001, 0x191a, 0x2004,
+	0x0002, 0x653b, 0x6394, 0x63d0, 0x63d0, 0x653b, 0x63d0, 0x0005,
+	0xa868, 0xd0fc, 0x1500, 0x00e6, 0x0026, 0x2009, 0x191a, 0x210c,
+	0x81ff, 0x0904, 0x653b, 0xa87c, 0xd0cc, 0x0904, 0x653b, 0xa880,
+	0x9084, 0x00ff, 0x9086, 0x0001, 0x1904, 0x653b, 0x9186, 0x0003,
+	0x0904, 0x63d0, 0x9186, 0x0005, 0x0904, 0x63d0, 0xa84f, 0x8021,
+	0xa853, 0x0017, 0x0028, 0x0005, 0xa84f, 0x8020, 0xa853, 0x0016,
+	0x2071, 0x1906, 0x701c, 0x9005, 0x1904, 0x66fb, 0x0e04, 0x6746,
+	0x2071, 0x0000, 0xa84c, 0x7082, 0xa850, 0x7032, 0xa86c, 0x7086,
+	0x7036, 0xa870, 0x708a, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004,
+	0xd084, 0x190c, 0x1167, 0x2071, 0x1800, 0x2011, 0x0001, 0xa804,
+	0x900d, 0x702c, 0x1158, 0xa802, 0x2900, 0x702e, 0x70b8, 0x9200,
+	0x70ba, 0x080c, 0x7b7c, 0x002e, 0x00ee, 0x0005, 0x0096, 0x2148,
+	0xa904, 0xa802, 0x8210, 0x2900, 0x81ff, 0x1dc8, 0x009e, 0x0c58,
+	0xa84f, 0x0000, 0x00f6, 0x2079, 0x0050, 0x2071, 0x1906, 0xa803,
+	0x0000, 0x7010, 0x9005, 0x1904, 0x64bf, 0x782c, 0x908c, 0x0780,
+	0x190c, 0x686d, 0x8004, 0x8004, 0x8004, 0x9084, 0x0003, 0x0002,
+	0x63ee, 0x64bf, 0x6413, 0x645a, 0x080c, 0x0db2, 0x2071, 0x1800,
+	0x2900, 0x7822, 0xa804, 0x900d, 0x1170, 0x2071, 0x19c9, 0x703c,
+	0x9005, 0x1328, 0x2001, 0x191b, 0x2004, 0x8005, 0x703e, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802,
+	0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba,
+	0x080c, 0x7b7c, 0x0c10, 0x2071, 0x1800, 0x2900, 0x7822, 0xa804,
+	0x900d, 0x1580, 0x7824, 0x00e6, 0x2071, 0x0040, 0x712c, 0xd19c,
+	0x1148, 0x2009, 0x182e, 0x210c, 0x918a, 0x0040, 0x0218, 0x7022,
+	0x00ee, 0x0058, 0x00ee, 0x2048, 0x702c, 0xa802, 0x2900, 0x702e,
+	0x70b8, 0x8000, 0x70ba, 0x080c, 0x7b7c, 0x782c, 0x9094, 0x0780,
+	0x190c, 0x686d, 0xd0a4, 0x19f0, 0x2071, 0x19c9, 0x703c, 0x9005,
+	0x1328, 0x2001, 0x191b, 0x2004, 0x8005, 0x703e, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802, 0x8210,
+	0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba, 0x080c,
+	0x7b7c, 0x0800, 0x0096, 0x00e6, 0x7824, 0x2048, 0x2071, 0x1800,
+	0x702c, 0xa802, 0x2900, 0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c,
+	0x7b7c, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4, 0x1d60,
+	0x00ee, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd09c, 0x11a0,
+	0x009e, 0x2900, 0x7822, 0xa804, 0x900d, 0x1560, 0x2071, 0x19c9,
+	0x703c, 0x9005, 0x1328, 0x2001, 0x191b, 0x2004, 0x8005, 0x703e,
+	0x00fe, 0x002e, 0x00ee, 0x0005, 0x009e, 0x2908, 0x7010, 0x8000,
+	0x7012, 0x7018, 0x904d, 0x711a, 0x0110, 0xa902, 0x0008, 0x711e,
+	0x2148, 0xa804, 0x900d, 0x1170, 0x2071, 0x19c9, 0x703c, 0x9005,
+	0x1328, 0x2001, 0x191b, 0x2004, 0x8005, 0x703e, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x2071, 0x1800, 0x9016, 0x702c, 0x2148, 0xa904,
+	0xa802, 0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200,
+	0x70ba, 0x080c, 0x7b7c, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x2908,
+	0x7010, 0x8000, 0x7012, 0x7018, 0x904d, 0x711a, 0x0110, 0xa902,
+	0x0008, 0x711e, 0x2148, 0xa804, 0x900d, 0x1904, 0x6514, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x686d, 0xd09c, 0x1198, 0x701c, 0x904d,
+	0x0180, 0x7010, 0x8001, 0x7012, 0x1108, 0x701a, 0xa800, 0x701e,
+	0x2900, 0x7822, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd09c,
+	0x0d68, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4, 0x01b0,
+	0x00e6, 0x7824, 0x2048, 0x2071, 0x1800, 0x702c, 0xa802, 0x2900,
+	0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c, 0x7b7c, 0x782c, 0x9094,
+	0x0780, 0x190c, 0x686d, 0xd0a4, 0x1d60, 0x00ee, 0x2071, 0x19c9,
+	0x703c, 0x9005, 0x1328, 0x2001, 0x191b, 0x2004, 0x8005, 0x703e,
+	0x00fe, 0x002e, 0x00ee, 0x0005, 0x00e6, 0x2071, 0x1800, 0x9016,
+	0x702c, 0x2148, 0xa904, 0xa802, 0x8210, 0x2900, 0x81ff, 0x1dc8,
+	0x702e, 0x70b8, 0x9200, 0x70ba, 0x080c, 0x7b7c, 0x00ee, 0x0804,
+	0x64cf, 0xa868, 0xd0fc, 0x1904, 0x6577, 0x0096, 0xa804, 0xa807,
+	0x0000, 0x904d, 0x190c, 0x0f87, 0x009e, 0x0018, 0xa868, 0xd0fc,
+	0x15f0, 0x00e6, 0x0026, 0xa84f, 0x0000, 0x00f6, 0x2079, 0x0050,
+	0x2071, 0x1800, 0x70e4, 0x8001, 0x01d0, 0x1678, 0x2071, 0x1906,
+	0xa803, 0x0000, 0x7010, 0x9005, 0x1904, 0x6675, 0x782c, 0x908c,
+	0x0780, 0x190c, 0x686d, 0x8004, 0x8004, 0x8004, 0x9084, 0x0003,
+	0x0002, 0x6578, 0x6675, 0x6593, 0x6604, 0x080c, 0x0db2, 0x70e7,
+	0x0fa0, 0x71e0, 0x8107, 0x9106, 0x9094, 0x00c0, 0x9184, 0xff3f,
+	0x9205, 0x70e2, 0x3b08, 0x3a00, 0x9104, 0x918d, 0x00c0, 0x21d8,
+	0x9084, 0xff3f, 0x9205, 0x20d0, 0x0888, 0x70e6, 0x0878, 0x0005,
+	0x2071, 0x1800, 0x2900, 0x7822, 0xa804, 0x900d, 0x1120, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802,
+	0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba,
+	0x080c, 0x7b7c, 0x0c60, 0x2071, 0x1800, 0x2900, 0x7822, 0xa804,
+	0x900d, 0x1904, 0x65f3, 0x7830, 0x8007, 0x9084, 0x001f, 0x9082,
+	0x0005, 0x1220, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x7824, 0x00e6,
+	0x2071, 0x0040, 0x712c, 0xd19c, 0x1148, 0x2009, 0x182e, 0x210c,
+	0x918a, 0x0040, 0x0218, 0x7022, 0x00ee, 0x0058, 0x00ee, 0x2048,
+	0x702c, 0xa802, 0x2900, 0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c,
+	0x7b7c, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4, 0x19f0,
+	0x0e04, 0x65ea, 0x7838, 0x7938, 0x910e, 0x1de0, 0x00d6, 0x2069,
+	0x0000, 0x6836, 0x6833, 0x0013, 0x00de, 0x2001, 0x1917, 0x200c,
+	0xc184, 0x2102, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084,
+	0x190c, 0x1167, 0x2009, 0x1919, 0x200b, 0x0000, 0x00fe, 0x002e,
+	0x00ee, 0x0005, 0x2001, 0x1917, 0x200c, 0xc185, 0x2102, 0x00fe,
+	0x002e, 0x00ee, 0x0005, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802,
+	0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba,
+	0x080c, 0x7b7c, 0x0804, 0x65a6, 0x0096, 0x00e6, 0x7824, 0x2048,
+	0x2071, 0x1800, 0x702c, 0xa802, 0x2900, 0x702e, 0x70b8, 0x8000,
+	0x70ba, 0x080c, 0x7b7c, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d,
+	0xd0a4, 0x1d60, 0x00ee, 0x0e04, 0x6648, 0x7838, 0x7938, 0x910e,
+	0x1de0, 0x00d6, 0x2069, 0x0000, 0x6836, 0x6833, 0x0013, 0x00de,
+	0x7044, 0xc084, 0x7046, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004,
+	0xd084, 0x190c, 0x1167, 0x2009, 0x1919, 0x200b, 0x0000, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x686d, 0xd09c, 0x1170, 0x009e, 0x2900,
+	0x7822, 0xa804, 0x900d, 0x11e0, 0x00fe, 0x002e, 0x00ee, 0x0005,
+	0x7044, 0xc085, 0x7046, 0x0c58, 0x009e, 0x2908, 0x7010, 0x8000,
+	0x7012, 0x7018, 0x904d, 0x711a, 0x0110, 0xa902, 0x0008, 0x711e,
+	0x2148, 0xa804, 0x900d, 0x1120, 0x00fe, 0x002e, 0x00ee, 0x0005,
+	0x2071, 0x1800, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802, 0x8210,
+	0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba, 0x080c,
+	0x7b7c, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x2908, 0x7010, 0x8000,
+	0x7012, 0x7018, 0x904d, 0x711a, 0x0110, 0xa902, 0x0008, 0x711e,
+	0x2148, 0xa804, 0x900d, 0x1904, 0x66e6, 0x782c, 0x9094, 0x0780,
+	0x190c, 0x686d, 0xd09c, 0x11b0, 0x701c, 0x904d, 0x0198, 0xa84c,
+	0x9005, 0x1180, 0x7010, 0x8001, 0x7012, 0x1108, 0x701a, 0xa800,
+	0x701e, 0x2900, 0x7822, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d,
+	0xd09c, 0x0d50, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4,
+	0x05c8, 0x00e6, 0x7824, 0x2048, 0x2071, 0x1800, 0x702c, 0xa802,
+	0x2900, 0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c, 0x7b7c, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4, 0x1d60, 0x00ee, 0x0e04,
+	0x66df, 0x7838, 0x7938, 0x910e, 0x1de0, 0x00d6, 0x2069, 0x0000,
+	0x6836, 0x6833, 0x0013, 0x00de, 0x7044, 0xc084, 0x7046, 0x2091,
+	0x4080, 0x2001, 0x0089, 0x2004, 0xd084, 0x190c, 0x1167, 0x2009,
+	0x1919, 0x200b, 0x0000, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x7044,
+	0xc085, 0x7046, 0x00fe, 0x002e, 0x00ee, 0x0005, 0x00e6, 0x2071,
+	0x1800, 0x9016, 0x702c, 0x2148, 0xa904, 0xa802, 0x8210, 0x2900,
+	0x81ff, 0x1dc8, 0x702e, 0x70b8, 0x9200, 0x70ba, 0x080c, 0x7b7c,
+	0x00ee, 0x0804, 0x6685, 0x2071, 0x1906, 0xa803, 0x0000, 0x2908,
+	0x7010, 0x8000, 0x7012, 0x7018, 0x904d, 0x711a, 0x0110, 0xa902,
+	0x0008, 0x711e, 0x2148, 0xa804, 0x900d, 0x1128, 0x1e04, 0x6726,
+	0x002e, 0x00ee, 0x0005, 0x2071, 0x1800, 0x9016, 0x702c, 0x2148,
+	0xa904, 0xa802, 0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e, 0x70b8,
+	0x9200, 0x70ba, 0x080c, 0x7b7c, 0x0e04, 0x6710, 0x2071, 0x1906,
+	0x701c, 0x2048, 0xa84c, 0x900d, 0x0d18, 0x2071, 0x0000, 0x7182,
+	0xa850, 0x7032, 0xa86c, 0x7086, 0x7036, 0xa870, 0x708a, 0x2091,
+	0x4080, 0x2001, 0x0089, 0x2004, 0xd084, 0x190c, 0x1167, 0x2071,
+	0x1906, 0x080c, 0x6859, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1906,
+	0xa803, 0x0000, 0x2908, 0x7010, 0x8000, 0x7012, 0x7018, 0x904d,
+	0x711a, 0x0110, 0xa902, 0x0008, 0x711e, 0x2148, 0xa804, 0x900d,
+	0x1118, 0x002e, 0x00ee, 0x0005, 0x2071, 0x1800, 0x9016, 0x702c,
+	0x2148, 0xa904, 0xa802, 0x8210, 0x2900, 0x81ff, 0x1dc8, 0x702e,
+	0x70b8, 0x9200, 0x70ba, 0x080c, 0x7b7c, 0x002e, 0x00ee, 0x0005,
+	0x0006, 0xa87c, 0x0006, 0xa867, 0x0103, 0x20a9, 0x001c, 0xa860,
+	0x20e8, 0xa85c, 0x9080, 0x001d, 0x20a0, 0x9006, 0x4004, 0x000e,
+	0x9084, 0x00ff, 0xa87e, 0x000e, 0xa87a, 0xa982, 0x0005, 0x2071,
+	0x1906, 0x7004, 0x0002, 0x6791, 0x6792, 0x6858, 0x6792, 0x0db2,
+	0x6858, 0x0005, 0x2001, 0x191a, 0x2004, 0x0002, 0x679c, 0x679c,
+	0x67f1, 0x67f2, 0x679c, 0x67f2, 0x0126, 0x2091, 0x8000, 0x1e0c,
+	0x6878, 0x701c, 0x904d, 0x01e0, 0xa84c, 0x9005, 0x01d8, 0x0e04,
+	0x67c0, 0xa94c, 0x2071, 0x0000, 0x7182, 0xa850, 0x7032, 0xa86c,
+	0x7086, 0x7036, 0xa870, 0x708a, 0x2091, 0x4080, 0x2001, 0x0089,
+	0x2004, 0xd084, 0x190c, 0x1167, 0x2071, 0x1906, 0x080c, 0x6859,
+	0x012e, 0x0470, 0x2001, 0x005b, 0x2004, 0x9094, 0x0780, 0x190c,
+	0x686d, 0xd09c, 0x2071, 0x1906, 0x1510, 0x2071, 0x1906, 0x700f,
+	0x0001, 0xa964, 0x9184, 0x00ff, 0x9086, 0x0003, 0x1130, 0x810f,
+	0x918c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x2900, 0x00d6, 0x2069,
+	0x0050, 0x6822, 0x00de, 0x2071, 0x1906, 0x701c, 0x2048, 0x7010,
+	0x8001, 0x7012, 0xa800, 0x701e, 0x9005, 0x1108, 0x701a, 0x012e,
+	0x0005, 0x0005, 0x00d6, 0x2008, 0x2069, 0x19c9, 0x683c, 0x9005,
+	0x0760, 0x0158, 0x9186, 0x0003, 0x0540, 0x2001, 0x1813, 0x2004,
+	0x2009, 0x1a8b, 0x210c, 0x9102, 0x1500, 0x0126, 0x2091, 0x8000,
+	0x2069, 0x0050, 0x693c, 0x6838, 0x9106, 0x0190, 0x0e04, 0x6824,
+	0x2069, 0x0000, 0x6837, 0x8040, 0x6833, 0x0012, 0x6883, 0x8040,
+	0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084, 0x190c, 0x1167,
+	0x2069, 0x19c9, 0x683f, 0xffff, 0x012e, 0x00de, 0x0126, 0x2091,
+	0x8000, 0x1e0c, 0x68e9, 0x701c, 0x904d, 0x0540, 0x2001, 0x005b,
+	0x2004, 0x9094, 0x0780, 0x15c9, 0xd09c, 0x1500, 0x2071, 0x1906,
+	0x700f, 0x0001, 0xa964, 0x9184, 0x00ff, 0x9086, 0x0003, 0x1130,
+	0x810f, 0x918c, 0x00ff, 0x8101, 0x0108, 0x710e, 0x2900, 0x00d6,
+	0x2069, 0x0050, 0x6822, 0x00de, 0x701c, 0x2048, 0x7010, 0x8001,
+	0x7012, 0xa800, 0x701e, 0x9005, 0x1108, 0x701a, 0x012e, 0x0005,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x701c, 0x904d, 0x0160, 0x7010,
+	0x8001, 0x7012, 0xa800, 0x701e, 0x9005, 0x1108, 0x701a, 0x012e,
+	0x080c, 0x1007, 0x0005, 0x012e, 0x0005, 0x2091, 0x8000, 0x0e04,
+	0x686f, 0x0006, 0x0016, 0x2001, 0x8004, 0x0006, 0x0804, 0x0dbb,
+	0x0096, 0x00f6, 0x2079, 0x0050, 0x7044, 0xd084, 0x01e0, 0xc084,
+	0x7046, 0x7838, 0x7938, 0x910e, 0x1de0, 0x00d6, 0x2069, 0x0000,
+	0x6836, 0x6833, 0x0013, 0x00de, 0x2091, 0x4080, 0x2001, 0x0089,
+	0x2004, 0xd084, 0x190c, 0x1167, 0x2009, 0x1919, 0x200b, 0x0000,
+	0x00fe, 0x009e, 0x0005, 0x782c, 0x9094, 0x0780, 0x1971, 0xd0a4,
+	0x0db8, 0x2009, 0x1919, 0x2104, 0x8000, 0x200a, 0x9082, 0x000f,
+	0x0e78, 0x00e6, 0x2071, 0x1800, 0x7824, 0x00e6, 0x2071, 0x0040,
+	0x712c, 0xd19c, 0x1148, 0x2009, 0x182e, 0x210c, 0x918a, 0x0040,
+	0x0218, 0x7022, 0x00ee, 0x0058, 0x00ee, 0x2048, 0x702c, 0xa802,
+	0x2900, 0x702e, 0x70b8, 0x8000, 0x70ba, 0x080c, 0x7b7c, 0x782c,
+	0x9094, 0x0780, 0x190c, 0x686d, 0xd0a4, 0x19f0, 0x7838, 0x7938,
+	0x910e, 0x1de0, 0x00d6, 0x2069, 0x0000, 0x6836, 0x6833, 0x0013,
+	0x00de, 0x2091, 0x4080, 0x2001, 0x0089, 0x2004, 0xd084, 0x190c,
+	0x1167, 0x2009, 0x1919, 0x200b, 0x0000, 0x00ee, 0x00fe, 0x009e,
+	0x0005, 0x00f6, 0x2079, 0x0050, 0x7044, 0xd084, 0x01b8, 0xc084,
+	0x7046, 0x7838, 0x7938, 0x910e, 0x1de0, 0x00d6, 0x2069, 0x0000,
+	0x6836, 0x6833, 0x0013, 0x00de, 0x2091, 0x4080, 0x2001, 0x0089,
+	0x2004, 0xd084, 0x190c, 0x1167, 0x00fe, 0x0005, 0x782c, 0x9094,
+	0x0780, 0x190c, 0x686d, 0xd0a4, 0x0db8, 0x00e6, 0x2071, 0x1800,
+	0x7824, 0x2048, 0x702c, 0xa802, 0x2900, 0x702e, 0x70b8, 0x8000,
+	0x70ba, 0x080c, 0x7b7c, 0x782c, 0x9094, 0x0780, 0x190c, 0x686d,
+	0xd0a4, 0x1d70, 0x00d6, 0x2069, 0x0050, 0x693c, 0x2069, 0x191a,
+	0x6808, 0x690a, 0x2069, 0x19c9, 0x9102, 0x1118, 0x683c, 0x9005,
+	0x1328, 0x2001, 0x191b, 0x200c, 0x810d, 0x693e, 0x00de, 0x00ee,
+	0x00fe, 0x0005, 0x7090, 0x908a, 0x0029, 0x1a0c, 0x0db2, 0x9082,
+	0x001d, 0x001b, 0x6027, 0x1e00, 0x0005, 0x6a0d, 0x6997, 0x69b3,
+	0x69db, 0x69fc, 0x6a3c, 0x6a4e, 0x69b3, 0x6a24, 0x6952, 0x6980,
+	0x6951, 0x0005, 0x00d6, 0x2069, 0x0200, 0x6804, 0x9005, 0x1180,
+	0x6808, 0x9005, 0x1518, 0x7093, 0x0028, 0x2069, 0x195e, 0x2d04,
+	0x7002, 0x080c, 0x6d8d, 0x6028, 0x9085, 0x0600, 0x602a, 0x00b0,
+	0x7093, 0x0028, 0x2069, 0x195e, 0x2d04, 0x7002, 0x6028, 0x9085,
+	0x0600, 0x602a, 0x00e6, 0x0036, 0x0046, 0x0056, 0x2071, 0x1a31,
+	0x080c, 0x1872, 0x005e, 0x004e, 0x003e, 0x00ee, 0x00de, 0x0005,
+	0x00d6, 0x2069, 0x0200, 0x6804, 0x9005, 0x1178, 0x6808, 0x9005,
+	0x1160, 0x7093, 0x0028, 0x2069, 0x195e, 0x2d04, 0x7002, 0x080c,
+	0x6e17, 0x6028, 0x9085, 0x0600, 0x602a, 0x00de, 0x0005, 0x0006,
+	0x2001, 0x0090, 0x080c, 0x2987, 0x000e, 0x6124, 0xd1e4, 0x1190,
+	0x080c, 0x6abb, 0xd1d4, 0x1160, 0xd1dc, 0x1138, 0xd1cc, 0x0150,
+	0x7093, 0x0020, 0x080c, 0x6abb, 0x0028, 0x7093, 0x001d, 0x0010,
+	0x7093, 0x001f, 0x0005, 0x2001, 0x0088, 0x080c, 0x2987, 0x6124,
+	0xd1cc, 0x11d8, 0xd1dc, 0x11b0, 0xd1e4, 0x1188, 0x9184, 0x1e00,
+	0x11c8, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e, 0x080c, 0x6c7f,
+	0x2001, 0x0080, 0x080c, 0x2987, 0x7093, 0x0028, 0x0058, 0x7093,
+	0x001e, 0x0040, 0x7093, 0x001d, 0x0028, 0x7093, 0x0020, 0x0010,
+	0x7093, 0x001f, 0x0005, 0x60e3, 0x0001, 0x600c, 0xc0b4, 0x600e,
+	0x080c, 0x6c7f, 0x2001, 0x0080, 0x080c, 0x2987, 0x6124, 0xd1d4,
+	0x1180, 0xd1dc, 0x1158, 0xd1e4, 0x1130, 0x9184, 0x1e00, 0x1158,
+	0x7093, 0x0028, 0x0040, 0x7093, 0x001e, 0x0028, 0x7093, 0x001d,
+	0x0010, 0x7093, 0x001f, 0x0005, 0x2001, 0x00a0, 0x080c, 0x2987,
+	0x6124, 0xd1dc, 0x1138, 0xd1e4, 0x0138, 0x080c, 0x189c, 0x7093,
+	0x001e, 0x0010, 0x7093, 0x001d, 0x0005, 0x080c, 0x6b3e, 0x6124,
+	0xd1dc, 0x1188, 0x080c, 0x6abb, 0x0016, 0x080c, 0x189c, 0x001e,
+	0xd1d4, 0x1128, 0xd1e4, 0x0138, 0x7093, 0x001e, 0x0020, 0x7093,
+	0x001f, 0x080c, 0x6abb, 0x0005, 0x0006, 0x2001, 0x00a0, 0x080c,
+	0x2987, 0x000e, 0x6124, 0xd1d4, 0x1160, 0xd1cc, 0x1150, 0xd1dc,
+	0x1128, 0xd1e4, 0x0140, 0x7093, 0x001e, 0x0028, 0x7093, 0x001d,
+	0x0010, 0x7093, 0x0021, 0x0005, 0x080c, 0x6b3e, 0x6124, 0xd1d4,
+	0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0140, 0x7093, 0x001e, 0x0028,
+	0x7093, 0x001d, 0x0010, 0x7093, 0x001f, 0x0005, 0x0006, 0x2001,
+	0x0090, 0x080c, 0x2987, 0x000e, 0x6124, 0xd1d4, 0x1178, 0xd1cc,
+	0x1150, 0xd1dc, 0x1128, 0xd1e4, 0x0158, 0x7093, 0x001e, 0x0040,
+	0x7093, 0x001d, 0x0028, 0x7093, 0x0020, 0x0010, 0x7093, 0x001f,
+	0x0005, 0x0016, 0x00c6, 0x00d6, 0x00e6, 0x0126, 0x2061, 0x0100,
+	0x2069, 0x0140, 0x2071, 0x1800, 0x2091, 0x8000, 0x080c, 0x6c53,
+	0x11d8, 0x2001, 0x180c, 0x200c, 0xd1b4, 0x01b0, 0xc1b4, 0x2102,
+	0x6027, 0x0200, 0x080c, 0x28d0, 0x6024, 0xd0cc, 0x0148, 0x2001,
+	0x00a0, 0x080c, 0x2987, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x0428,
+	0x6028, 0xc0cd, 0x602a, 0x0408, 0x080c, 0x6c6d, 0x0150, 0x080c,
+	0x6c64, 0x1138, 0x2001, 0x0001, 0x080c, 0x247f, 0x080c, 0x6c2d,
+	0x00a0, 0x080c, 0x6b3b, 0x0178, 0x2001, 0x0001, 0x080c, 0x247f,
+	0x7090, 0x9086, 0x001e, 0x0120, 0x7090, 0x9086, 0x0022, 0x1118,
+	0x7093, 0x0025, 0x0010, 0x7093, 0x0021, 0x012e, 0x00ee, 0x00de,
+	0x00ce, 0x001e, 0x0005, 0x0026, 0x2011, 0x6acc, 0x080c, 0x7d1b,
+	0x002e, 0x0016, 0x0026, 0x2009, 0x0064, 0x2011, 0x6acc, 0x080c,
+	0x7d12, 0x002e, 0x001e, 0x0005, 0x00e6, 0x00f6, 0x0016, 0x080c,
+	0x8fbb, 0x2071, 0x1800, 0x080c, 0x6a69, 0x001e, 0x00fe, 0x00ee,
+	0x0005, 0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x00f6,
+	0x0126, 0x080c, 0x8fbb, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071,
+	0x1800, 0x2091, 0x8000, 0x6028, 0xc09c, 0x602a, 0x2011, 0x0003,
+	0x080c, 0x92ec, 0x2011, 0x0002, 0x080c, 0x92f6, 0x080c, 0x91de,
+	0x080c, 0x7cc7, 0x0036, 0x901e, 0x080c, 0x9254, 0x003e, 0x60e3,
+	0x0000, 0x080c, 0xd343, 0x080c, 0xd35e, 0x2009, 0x0004, 0x080c,
+	0x28d6, 0x080c, 0x27f1, 0x2001, 0x1800, 0x2003, 0x0004, 0x6027,
+	0x0008, 0x2011, 0x6acc, 0x080c, 0x7d1b, 0x080c, 0x6c6d, 0x0118,
+	0x9006, 0x080c, 0x2987, 0x080c, 0x0b94, 0x2001, 0x0001, 0x080c,
+	0x247f, 0x012e, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x003e, 0x002e,
+	0x001e, 0x0005, 0x0026, 0x00e6, 0x2011, 0x6ad9, 0x2071, 0x19c9,
+	0x701c, 0x9206, 0x1118, 0x7018, 0x9005, 0x0110, 0x9085, 0x0001,
+	0x00ee, 0x002e, 0x0005, 0x6020, 0xd09c, 0x0005, 0x6800, 0x9084,
+	0xfffe, 0x9086, 0x00c0, 0x01b8, 0x2001, 0x00c0, 0x080c, 0x2987,
+	0x0156, 0x20a9, 0x002d, 0x1d04, 0x6b4b, 0x2091, 0x6000, 0x1f04,
+	0x6b4b, 0x015e, 0x00d6, 0x2069, 0x1800, 0x6894, 0x8001, 0x0220,
+	0x0118, 0x6896, 0x00de, 0x0005, 0x6897, 0x0014, 0x68e0, 0xd0dc,
+	0x0dc8, 0x6800, 0x9086, 0x0001, 0x1da8, 0x080c, 0x7d27, 0x0c90,
+	0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071,
+	0x1800, 0x080c, 0x6f39, 0x2001, 0x193e, 0x2003, 0x0000, 0x9006,
+	0x7092, 0x60e2, 0x6886, 0x080c, 0x254a, 0x9006, 0x080c, 0x2987,
+	0x080c, 0x58e0, 0x6027, 0xffff, 0x602b, 0x182f, 0x00ee, 0x00de,
+	0x00ce, 0x0005, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x2071, 0x1800, 0x2001, 0x194e, 0x200c, 0x9186, 0x0000,
+	0x0158, 0x9186, 0x0001, 0x0158, 0x9186, 0x0002, 0x0158, 0x9186,
+	0x0003, 0x0158, 0x0804, 0x6c1d, 0x7093, 0x0022, 0x0040, 0x7093,
+	0x0021, 0x0028, 0x7093, 0x0023, 0x0010, 0x7093, 0x0024, 0x60e3,
+	0x0000, 0x6887, 0x0001, 0x2001, 0x0001, 0x080c, 0x254a, 0x0026,
+	0x080c, 0x9947, 0x002e, 0x7000, 0x908e, 0x0004, 0x0118, 0x602b,
+	0x0028, 0x0010, 0x602b, 0x0020, 0x0156, 0x0126, 0x2091, 0x8000,
+	0x20a9, 0x0005, 0x6024, 0xd0ac, 0x0150, 0x012e, 0x015e, 0x080c,
+	0xbcec, 0x0118, 0x9006, 0x080c, 0x29b1, 0x0804, 0x6c29, 0x6800,
+	0x9084, 0x00a1, 0xc0bd, 0x6802, 0x080c, 0x28d0, 0x6904, 0xd1d4,
+	0x1140, 0x2001, 0x0100, 0x080c, 0x2987, 0x1f04, 0x6bca, 0x080c,
+	0x6caa, 0x012e, 0x015e, 0x080c, 0x6c64, 0x01a8, 0x6044, 0x9005,
+	0x0168, 0x6050, 0x0006, 0x9085, 0x0020, 0x6052, 0x080c, 0x6caa,
+	0x9006, 0x8001, 0x1df0, 0x000e, 0x6052, 0x0028, 0x6804, 0xd0d4,
+	0x1110, 0x080c, 0x6caa, 0x080c, 0xbcec, 0x0118, 0x9006, 0x080c,
+	0x29b1, 0x0016, 0x0026, 0x7000, 0x908e, 0x0004, 0x0130, 0x2009,
+	0x00c8, 0x2011, 0x6ad9, 0x080c, 0x7cd9, 0x002e, 0x001e, 0x080c,
+	0x7b73, 0x2001, 0x194e, 0x2003, 0x0004, 0x080c, 0x693a, 0x080c,
+	0x6c64, 0x0138, 0x6804, 0xd0d4, 0x1120, 0xd0dc, 0x1100, 0x080c,
+	0x6f2f, 0x00ee, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00d6, 0x00e6,
+	0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0x1800, 0x080c, 0x7b7c,
+	0x080c, 0x6f39, 0x2001, 0x193e, 0x2003, 0x0000, 0x9006, 0x7092,
+	0x60e2, 0x6886, 0x080c, 0x254a, 0x9006, 0x080c, 0x2987, 0x6043,
+	0x0090, 0x6043, 0x0010, 0x6027, 0xffff, 0x602b, 0x182f, 0x00ee,
+	0x00de, 0x00ce, 0x0005, 0x0006, 0x2001, 0x194d, 0x2004, 0x9086,
+	0xaaaa, 0x000e, 0x0005, 0x0006, 0x080c, 0x5117, 0x9084, 0x0030,
+	0x9086, 0x0000, 0x000e, 0x0005, 0x0006, 0x080c, 0x5117, 0x9084,
+	0x0030, 0x9086, 0x0030, 0x000e, 0x0005, 0x0006, 0x080c, 0x5117,
+	0x9084, 0x0030, 0x9086, 0x0010, 0x000e, 0x0005, 0x0006, 0x080c,
+	0x5117, 0x9084, 0x0030, 0x9086, 0x0020, 0x000e, 0x0005, 0x0036,
+	0x0016, 0x2001, 0x180c, 0x2004, 0x908c, 0x0013, 0x0180, 0x0020,
+	0x080c, 0x256a, 0x900e, 0x0028, 0x080c, 0x629c, 0x1dc8, 0x2009,
+	0x0002, 0x2019, 0x0028, 0x080c, 0x2dfb, 0x9006, 0x0019, 0x001e,
+	0x003e, 0x0005, 0x00e6, 0x2071, 0x180c, 0x2e04, 0x0130, 0x080c,
+	0xbce5, 0x1128, 0x9085, 0x0010, 0x0010, 0x9084, 0xffef, 0x2072,
+	0x00ee, 0x0005, 0x6050, 0x0006, 0x60ec, 0x0006, 0x600c, 0x0006,
+	0x6004, 0x0006, 0x6028, 0x0006, 0x0016, 0x6138, 0x6050, 0x9084,
+	0xfbff, 0x9085, 0x2000, 0x6052, 0x613a, 0x20a9, 0x0012, 0x1d04,
+	0x6cbf, 0x2091, 0x6000, 0x1f04, 0x6cbf, 0x602f, 0x0100, 0x602f,
+	0x0000, 0x6050, 0x9085, 0x0400, 0x9084, 0xdfff, 0x6052, 0x613a,
+	0x001e, 0x602f, 0x0040, 0x602f, 0x0000, 0x000e, 0x602a, 0x000e,
+	0x6006, 0x000e, 0x600e, 0x000e, 0x60ee, 0x60e3, 0x0000, 0x6887,
+	0x0001, 0x2001, 0x0001, 0x080c, 0x254a, 0x2001, 0x00a0, 0x0006,
+	0x080c, 0xbcec, 0x000e, 0x0130, 0x080c, 0x29a5, 0x9006, 0x080c,
+	0x29b1, 0x0010, 0x080c, 0x2987, 0x000e, 0x6052, 0x6050, 0x0006,
+	0xc0e5, 0x6052, 0x00f6, 0x2079, 0x0100, 0x080c, 0x2845, 0x00fe,
+	0x000e, 0x6052, 0x0005, 0x0156, 0x0016, 0x0026, 0x0036, 0x00c6,
+	0x00d6, 0x00e6, 0x2061, 0x0100, 0x2069, 0x0140, 0x2071, 0x1800,
+	0x6020, 0x9084, 0x0080, 0x0138, 0x2001, 0x180c, 0x200c, 0xc1c5,
+	0x2102, 0x0804, 0x6d7f, 0x2001, 0x180c, 0x200c, 0xc1c4, 0x2102,
+	0x6028, 0x9084, 0xe1ff, 0x602a, 0x6027, 0x0200, 0x2001, 0x0090,
+	0x080c, 0x2987, 0x20a9, 0x0366, 0x6024, 0xd0cc, 0x1518, 0x1d04,
+	0x6d2c, 0x2091, 0x6000, 0x1f04, 0x6d2c, 0x2011, 0x0003, 0x080c,
+	0x92ec, 0x2011, 0x0002, 0x080c, 0x92f6, 0x080c, 0x91de, 0x901e,
+	0x080c, 0x9254, 0x2001, 0x00a0, 0x080c, 0x2987, 0x080c, 0x6f2a,
+	0x080c, 0x5a21, 0x080c, 0xbcec, 0x0110, 0x080c, 0x0d27, 0x9085,
+	0x0001, 0x0498, 0x86ff, 0x1110, 0x080c, 0x189c, 0x60e3, 0x0000,
+	0x2001, 0x193e, 0x2004, 0x080c, 0x254a, 0x60e2, 0x2001, 0x0080,
+	0x080c, 0x2987, 0x20a9, 0x0366, 0x6027, 0x1e00, 0x2009, 0x1e00,
+	0x080c, 0x28d0, 0x6024, 0x910c, 0x0138, 0x1d04, 0x6d64, 0x2091,
+	0x6000, 0x1f04, 0x6d64, 0x0808, 0x6028, 0x9085, 0x1e00, 0x602a,
+	0x70ac, 0x9005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x080c,
+	0xbcec, 0x0110, 0x080c, 0x0d27, 0x9006, 0x00ee, 0x00de, 0x00ce,
+	0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156, 0x0016, 0x0026,
+	0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100, 0x2071, 0x1800,
+	0x2069, 0x0140, 0x6020, 0x9084, 0x00c0, 0x0120, 0x6884, 0x9005,
+	0x1904, 0x6de1, 0x2001, 0x0088, 0x080c, 0x2987, 0x9006, 0x60e2,
+	0x6886, 0x080c, 0x254a, 0x2069, 0x0200, 0x6804, 0x9005, 0x1118,
+	0x6808, 0x9005, 0x01c0, 0x6028, 0x9084, 0xfbff, 0x602a, 0x6027,
+	0x0400, 0x2069, 0x195e, 0x7000, 0x206a, 0x7093, 0x0026, 0x7003,
+	0x0001, 0x20a9, 0x0002, 0x1d04, 0x6dc3, 0x2091, 0x6000, 0x1f04,
+	0x6dc3, 0x0804, 0x6e0f, 0x2069, 0x0140, 0x20a9, 0x0384, 0x6027,
+	0x1e00, 0x2009, 0x1e00, 0x080c, 0x28d0, 0x6024, 0x910c, 0x0508,
+	0x9084, 0x1a00, 0x11f0, 0x1d04, 0x6dcf, 0x2091, 0x6000, 0x1f04,
+	0x6dcf, 0x2011, 0x0003, 0x080c, 0x92ec, 0x2011, 0x0002, 0x080c,
+	0x92f6, 0x080c, 0x91de, 0x901e, 0x080c, 0x9254, 0x2001, 0x00a0,
+	0x080c, 0x2987, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x9085, 0x0001,
+	0x00b0, 0x2001, 0x0080, 0x080c, 0x2987, 0x2069, 0x0140, 0x60e3,
+	0x0000, 0x70ac, 0x9005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886,
+	0x2001, 0x193e, 0x2004, 0x080c, 0x254a, 0x60e2, 0x9006, 0x00ee,
+	0x00de, 0x00ce, 0x003e, 0x002e, 0x001e, 0x015e, 0x0005, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x00c6, 0x00d6, 0x00e6, 0x2061, 0x0100,
+	0x2071, 0x1800, 0x6020, 0x9084, 0x00c0, 0x01c8, 0x2011, 0x0003,
+	0x080c, 0x92ec, 0x2011, 0x0002, 0x080c, 0x92f6, 0x080c, 0x91de,
+	0x901e, 0x080c, 0x9254, 0x2069, 0x0140, 0x2001, 0x00a0, 0x080c,
+	0x2987, 0x080c, 0x6f2a, 0x080c, 0x5a21, 0x0804, 0x6eaa, 0x2001,
+	0x180c, 0x200c, 0xd1b4, 0x1160, 0xc1b5, 0x2102, 0x080c, 0x6ac1,
+	0x2069, 0x0140, 0x2001, 0x0080, 0x080c, 0x2987, 0x60e3, 0x0000,
+	0x2069, 0x0200, 0x6804, 0x9005, 0x1118, 0x6808, 0x9005, 0x0180,
+	0x6028, 0x9084, 0xfdff, 0x602a, 0x6027, 0x0200, 0x2069, 0x195e,
+	0x7000, 0x206a, 0x7093, 0x0027, 0x7003, 0x0001, 0x0804, 0x6eaa,
+	0x6027, 0x1e00, 0x2009, 0x1e00, 0x080c, 0x28d0, 0x6024, 0x910c,
+	0x01c8, 0x9084, 0x1c00, 0x11b0, 0x1d04, 0x6e68, 0x0006, 0x0016,
+	0x00c6, 0x00d6, 0x00e6, 0x080c, 0x7bae, 0x00ee, 0x00de, 0x00ce,
+	0x001e, 0x000e, 0x00e6, 0x2071, 0x19c9, 0x7018, 0x00ee, 0x9005,
+	0x19f8, 0x0500, 0x0026, 0x2011, 0x6ad9, 0x080c, 0x7c4a, 0x2011,
+	0x6acc, 0x080c, 0x7d1b, 0x002e, 0x2069, 0x0140, 0x60e3, 0x0000,
+	0x70ac, 0x9005, 0x1118, 0x6887, 0x0001, 0x0008, 0x6886, 0x2001,
+	0x193e, 0x2004, 0x080c, 0x254a, 0x60e2, 0x2001, 0x180c, 0x200c,
+	0xc1b4, 0x2102, 0x00ee, 0x00de, 0x00ce, 0x003e, 0x002e, 0x001e,
+	0x015e, 0x0005, 0x0156, 0x0016, 0x0026, 0x0036, 0x0046, 0x00c6,
+	0x00e6, 0x2061, 0x0100, 0x2071, 0x1800, 0x080c, 0xbce5, 0x1904,
+	0x6f18, 0x7130, 0xd184, 0x1170, 0x080c, 0x2f86, 0x0138, 0xc18d,
+	0x7132, 0x2011, 0x1854, 0x2214, 0xd2ac, 0x1120, 0x7030, 0xd08c,
+	0x0904, 0x6f18, 0x2011, 0x1854, 0x220c, 0xd1a4, 0x0538, 0x0016,
+	0x2019, 0x000e, 0x080c, 0xcf62, 0x0156, 0x00b6, 0x20a9, 0x007f,
+	0x900e, 0x9186, 0x007e, 0x01a0, 0x9186, 0x0080, 0x0188, 0x080c,
+	0x5f7e, 0x1170, 0x2120, 0x9006, 0x0016, 0x2009, 0x000e, 0x080c,
+	0xcfe6, 0x2009, 0x0001, 0x2011, 0x0100, 0x080c, 0x7e3e, 0x001e,
+	0x8108, 0x1f04, 0x6ee1, 0x00be, 0x015e, 0x001e, 0xd1ac, 0x1148,
+	0x0016, 0x2009, 0x0002, 0x2019, 0x0004, 0x080c, 0x2dfb, 0x001e,
+	0x0078, 0x0156, 0x00b6, 0x20a9, 0x007f, 0x900e, 0x080c, 0x5f7e,
+	0x1110, 0x080c, 0x5a3b, 0x8108, 0x1f04, 0x6f0e, 0x00be, 0x015e,
+	0x080c, 0x189c, 0x080c, 0x9947, 0x60e3, 0x0000, 0x080c, 0x5a21,
+	0x080c, 0x6b8a, 0x00ee, 0x00ce, 0x004e, 0x003e, 0x002e, 0x001e,
+	0x015e, 0x0005, 0x2001, 0x194e, 0x2003, 0x0001, 0x0005, 0x2001,
+	0x194e, 0x2003, 0x0000, 0x0005, 0x2001, 0x194d, 0x2003, 0xaaaa,
+	0x0005, 0x2001, 0x194d, 0x2003, 0x0000, 0x0005, 0x2071, 0x18f0,
+	0x7003, 0x0000, 0x7007, 0x0000, 0x080c, 0x0fee, 0x090c, 0x0db2,
+	0xa8ab, 0xdcb0, 0x2900, 0x704e, 0x080c, 0x0fee, 0x090c, 0x0db2,
+	0xa8ab, 0xdcb0, 0x2900, 0x7052, 0xa867, 0x0000, 0xa86b, 0x0001,
+	0xa89f, 0x0000, 0x0005, 0x00e6, 0x2071, 0x0040, 0x6848, 0x9005,
+	0x1118, 0x9085, 0x0001, 0x04b0, 0x6840, 0x9005, 0x0150, 0x04a1,
+	0x6a50, 0x9200, 0x7002, 0x6854, 0x9101, 0x7006, 0x9006, 0x7012,
+	0x7016, 0x6850, 0x7002, 0x6854, 0x7006, 0x6858, 0x700a, 0x685c,
+	0x700e, 0x6840, 0x9005, 0x1110, 0x7012, 0x7016, 0x6848, 0x701a,
+	0x701c, 0x9085, 0x0040, 0x701e, 0x2001, 0x0019, 0x7036, 0x702b,
+	0x0001, 0x2001, 0x0004, 0x200c, 0x918c, 0xfff7, 0x918d, 0x8000,
+	0x2102, 0x00d6, 0x2069, 0x18f0, 0x6807, 0x0001, 0x00de, 0x080c,
+	0x74e5, 0x9006, 0x00ee, 0x0005, 0x900e, 0x0156, 0x20a9, 0x0006,
+	0x8003, 0x2011, 0x0100, 0x2214, 0x9296, 0x0008, 0x1110, 0x818d,
+	0x0010, 0x81f5, 0x3e08, 0x1f04, 0x6fa0, 0x015e, 0x0005, 0x2079,
+	0x0040, 0x2071, 0x18f0, 0x7004, 0x0002, 0x6fbf, 0x6fc0, 0x6ff7,
+	0x7052, 0x714d, 0x6fbd, 0x6fbd, 0x7177, 0x080c, 0x0db2, 0x0005,
+	0x2079, 0x0040, 0x782c, 0x908c, 0x0780, 0x190c, 0x7571, 0xd0a4,
+	0x01f0, 0x7824, 0x2048, 0x9006, 0xa802, 0xa806, 0xa864, 0x9084,
+	0x00ff, 0x908a, 0x0040, 0x0608, 0x00b8, 0x2001, 0x1800, 0x200c,
+	0x9186, 0x0003, 0x1160, 0x7104, 0x9186, 0x0004, 0x0140, 0x9186,
+	0x0007, 0x0128, 0x9186, 0x0003, 0x19e8, 0x080c, 0x7052, 0x782c,
+	0xd09c, 0x090c, 0x74e5, 0x0005, 0x9082, 0x005a, 0x1218, 0x2100,
+	0x003b, 0x0c18, 0x080c, 0x7088, 0x0c90, 0x00e3, 0x08f0, 0x0005,
+	0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x70aa, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x7088, 0x7094, 0x7088, 0x724c, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x7088, 0x7094, 0x728d, 0x72ce, 0x7315,
+	0x7329, 0x7088, 0x7088, 0x70aa, 0x7094, 0x7088, 0x7088, 0x7121,
+	0x73d4, 0x73ef, 0x7088, 0x70aa, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7117, 0x73ef, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x70be, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x7088, 0x7088, 0x7515, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x7088, 0x70d2, 0x7088, 0x7088, 0x7088, 0x7088,
+	0x7088, 0x7088, 0x2079, 0x0040, 0x7004, 0x9086, 0x0003, 0x1198,
+	0x782c, 0x080c, 0x750e, 0xd0a4, 0x0170, 0x7824, 0x2048, 0x9006,
+	0xa802, 0xa806, 0xa864, 0x9084, 0x00ff, 0x908a, 0x001a, 0x1210,
+	0x002b, 0x0c50, 0x00e9, 0x080c, 0x74e5, 0x0005, 0x7088, 0x7094,
+	0x7238, 0x7088, 0x7094, 0x7088, 0x7094, 0x7094, 0x7088, 0x7094,
+	0x7238, 0x7094, 0x7094, 0x7094, 0x7094, 0x7094, 0x7088, 0x7094,
+	0x7238, 0x7088, 0x7088, 0x7094, 0x7088, 0x7088, 0x7088, 0x7094,
+	0x00e6, 0x2071, 0x18f0, 0x2009, 0x0400, 0x0071, 0x00ee, 0x0005,
+	0x2009, 0x1000, 0x0049, 0x0005, 0x2009, 0x2000, 0x0029, 0x0005,
+	0x2009, 0x0800, 0x0009, 0x0005, 0x7007, 0x0001, 0xa868, 0x9084,
+	0x00ff, 0x9105, 0xa86a, 0x0126, 0x2091, 0x8000, 0x080c, 0x6536,
+	0x012e, 0x0005, 0xa864, 0x8007, 0x9084, 0x00ff, 0x0d08, 0x8001,
+	0x1120, 0x7007, 0x0001, 0x0804, 0x71f6, 0x7007, 0x0003, 0x7012,
+	0x2900, 0x7016, 0x701a, 0x704b, 0x71f6, 0x0005, 0xa864, 0x8007,
+	0x9084, 0x00ff, 0x0968, 0x8001, 0x1120, 0x7007, 0x0001, 0x0804,
+	0x7211, 0x7007, 0x0003, 0x7012, 0x2900, 0x7016, 0x701a, 0x704b,
+	0x7211, 0x0005, 0xa864, 0x8007, 0x9084, 0x00ff, 0x9086, 0x0001,
+	0x1904, 0x7090, 0x7007, 0x0001, 0x2009, 0x1832, 0x210c, 0x81ff,
+	0x11a8, 0xa868, 0x9084, 0x00ff, 0xa86a, 0xa883, 0x0000, 0x080c,
+	0x5c50, 0x1108, 0x0005, 0x0126, 0x2091, 0x8000, 0xa867, 0x0139,
+	0xa87a, 0xa982, 0x080c, 0x6536, 0x012e, 0x0ca0, 0xa994, 0x9186,
+	0x0071, 0x0d38, 0x9186, 0x0064, 0x0d20, 0x9186, 0x007c, 0x0d08,
+	0x9186, 0x0028, 0x09f0, 0x9186, 0x0038, 0x09d8, 0x9186, 0x0078,
+	0x09c0, 0x9186, 0x005f, 0x09a8, 0x9186, 0x0056, 0x0990, 0xa897,
+	0x4005, 0xa89b, 0x0001, 0x2001, 0x0030, 0x900e, 0x08a0, 0xa87c,
+	0x9084, 0x00c0, 0x9086, 0x00c0, 0x1120, 0x7007, 0x0001, 0x0804,
+	0x7406, 0x2900, 0x7016, 0x701a, 0x20a9, 0x0004, 0xa860, 0x20e0,
+	0xa85c, 0x9080, 0x0030, 0x2098, 0x7050, 0x2040, 0xa060, 0x20e8,
+	0xa05c, 0x9080, 0x0023, 0x20a0, 0x4003, 0xa888, 0x7012, 0x9082,
+	0x0401, 0x1a04, 0x7098, 0xaab4, 0x928a, 0x0002, 0x1a04, 0x7098,
+	0x82ff, 0x1138, 0xa8b8, 0xa9bc, 0x9105, 0x0118, 0x2001, 0x71b4,
+	0x0018, 0x9280, 0x71aa, 0x2005, 0x7056, 0x7010, 0x9015, 0x0904,
+	0x7195, 0x080c, 0x0fee, 0x1118, 0x7007, 0x0004, 0x0005, 0x2900,
+	0x7022, 0x7054, 0x2060, 0xe000, 0xa866, 0x7050, 0x2040, 0xa95c,
+	0xe004, 0x9100, 0xa076, 0xa860, 0xa072, 0xe008, 0x920a, 0x1210,
+	0x900e, 0x2200, 0x7112, 0xe20c, 0x8003, 0x800b, 0x9296, 0x0004,
+	0x0108, 0x9108, 0xa17a, 0x810b, 0xa17e, 0x080c, 0x10b5, 0xa06c,
+	0x908e, 0x0100, 0x0170, 0x9086, 0x0200, 0x0118, 0x7007, 0x0007,
+	0x0005, 0x7020, 0x2048, 0x080c, 0x1007, 0x7014, 0x2048, 0x0804,
+	0x7098, 0x7020, 0x2048, 0x7018, 0xa802, 0xa807, 0x0000, 0x2908,
+	0x2048, 0xa906, 0x711a, 0x0804, 0x714d, 0x7014, 0x2048, 0x7007,
+	0x0001, 0xa8b4, 0x9005, 0x1128, 0xa8b8, 0xa9bc, 0x9105, 0x0108,
+	0x00b9, 0xa864, 0x9084, 0x00ff, 0x9086, 0x001e, 0x0904, 0x7406,
+	0x0804, 0x71f6, 0x71ac, 0x71b0, 0x0002, 0x001d, 0x0007, 0x0004,
+	0x000a, 0x001b, 0x0005, 0x0006, 0x000a, 0x001d, 0x0005, 0x0004,
+	0x0076, 0x0066, 0xafb8, 0xaebc, 0xa804, 0x2050, 0xb0c0, 0xb0e2,
+	0xb0bc, 0xb0de, 0xb0b8, 0xb0d2, 0xb0b4, 0xb0ce, 0xb6da, 0xb7d6,
+	0xb0b0, 0xb0ca, 0xb0ac, 0xb0c6, 0xb0a8, 0xb0ba, 0xb0a4, 0xb0b6,
+	0xb6c2, 0xb7be, 0xb0a0, 0xb0b2, 0xb09c, 0xb0ae, 0xb098, 0xb0a2,
+	0xb094, 0xb09e, 0xb6aa, 0xb7a6, 0xb090, 0xb09a, 0xb08c, 0xb096,
+	0xb088, 0xb08a, 0xb084, 0xb086, 0xb692, 0xb78e, 0xb080, 0xb082,
+	0xb07c, 0xb07e, 0xb078, 0xb072, 0xb074, 0xb06e, 0xb67a, 0xb776,
+	0xb004, 0x9055, 0x1958, 0x006e, 0x007e, 0x0005, 0x2009, 0x1832,
+	0x210c, 0x81ff, 0x1178, 0x080c, 0x5a9d, 0x1108, 0x0005, 0x080c,
+	0x6770, 0x0126, 0x2091, 0x8000, 0x080c, 0xb8e3, 0x080c, 0x6536,
+	0x012e, 0x0ca0, 0x080c, 0xbce5, 0x1d70, 0x2001, 0x0028, 0x900e,
+	0x0c70, 0x2009, 0x1832, 0x210c, 0x81ff, 0x11d8, 0xa888, 0x9005,
+	0x01e0, 0xa883, 0x0000, 0xa87c, 0xd0f4, 0x0120, 0x080c, 0x5bb2,
+	0x1138, 0x0005, 0x9006, 0xa87a, 0x080c, 0x5b2d, 0x1108, 0x0005,
+	0x0126, 0x2091, 0x8000, 0xa87a, 0xa982, 0x080c, 0x6536, 0x012e,
+	0x0cb0, 0x2001, 0x0028, 0x900e, 0x0c98, 0x2001, 0x0000, 0x0c80,
+	0x7018, 0xa802, 0x2908, 0x2048, 0xa906, 0x711a, 0x7010, 0x8001,
+	0x7012, 0x0118, 0x7007, 0x0003, 0x0030, 0x7014, 0x2048, 0x7007,
+	0x0001, 0x7048, 0x080f, 0x0005, 0x00b6, 0x7007, 0x0001, 0xa974,
+	0xa878, 0x9084, 0x00ff, 0x9096, 0x0004, 0x0540, 0x20a9, 0x0001,
+	0x9096, 0x0001, 0x0190, 0x900e, 0x20a9, 0x0800, 0x9096, 0x0002,
+	0x0160, 0x9005, 0x11d8, 0xa974, 0x080c, 0x5f7e, 0x11b8, 0x0066,
+	0xae80, 0x080c, 0x608e, 0x006e, 0x0088, 0x0046, 0x2011, 0x180c,
+	0x2224, 0xc484, 0x2412, 0x004e, 0x00c6, 0x080c, 0x5f7e, 0x1110,
+	0x080c, 0x618e, 0x8108, 0x1f04, 0x7275, 0x00ce, 0xa87c, 0xd084,
+	0x1120, 0x080c, 0x1007, 0x00be, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x6536, 0x012e, 0x00be, 0x0005, 0x0126, 0x2091, 0x8000,
+	0x7007, 0x0001, 0x080c, 0x62a0, 0x0580, 0x2061, 0x1a3e, 0x6100,
+	0xd184, 0x0178, 0xa888, 0x9084, 0x00ff, 0x1550, 0x6000, 0xd084,
+	0x0520, 0x6004, 0x9005, 0x1538, 0x6003, 0x0000, 0x600b, 0x0000,
+	0x00c8, 0x2011, 0x0001, 0xa890, 0x9005, 0x1110, 0x2001, 0x001e,
+	0x8000, 0x6016, 0xa888, 0x9084, 0x00ff, 0x0178, 0x6006, 0xa888,
+	0x8007, 0x9084, 0x00ff, 0x0148, 0x600a, 0xa888, 0x8000, 0x1108,
+	0xc28d, 0x6202, 0x012e, 0x0804, 0x74cf, 0x012e, 0x0804, 0x74c9,
+	0x012e, 0x0804, 0x74c3, 0x012e, 0x0804, 0x74c6, 0x0126, 0x2091,
+	0x8000, 0x7007, 0x0001, 0x080c, 0x62a0, 0x05e0, 0x2061, 0x1a3e,
+	0x6000, 0xd084, 0x05b8, 0x6204, 0x6308, 0xd08c, 0x1530, 0xac78,
+	0x9484, 0x0003, 0x0170, 0xa988, 0x918c, 0x00ff, 0x8001, 0x1120,
+	0x2100, 0x9210, 0x0620, 0x0028, 0x8001, 0x1508, 0x2100, 0x9212,
+	0x02f0, 0x9484, 0x000c, 0x0188, 0xa988, 0x810f, 0x918c, 0x00ff,
+	0x9082, 0x0004, 0x1120, 0x2100, 0x9318, 0x0288, 0x0030, 0x9082,
+	0x0004, 0x1168, 0x2100, 0x931a, 0x0250, 0xa890, 0x9005, 0x0110,
+	0x8000, 0x6016, 0x6206, 0x630a, 0x012e, 0x0804, 0x74cf, 0x012e,
+	0x0804, 0x74cc, 0x012e, 0x0804, 0x74c9, 0x0126, 0x2091, 0x8000,
+	0x7007, 0x0001, 0x2061, 0x1a3e, 0x6300, 0xd38c, 0x1120, 0x6308,
+	0x8318, 0x0220, 0x630a, 0x012e, 0x0804, 0x74dd, 0x012e, 0x0804,
+	0x74cc, 0x00b6, 0x0126, 0x00c6, 0x2091, 0x8000, 0x7007, 0x0001,
+	0xa87c, 0xd0ac, 0x0148, 0x00c6, 0x2061, 0x1a3e, 0x6000, 0x9084,
+	0xfcff, 0x6002, 0x00ce, 0x0440, 0xa888, 0x9005, 0x05d8, 0xa88c,
+	0x9065, 0x0598, 0x2001, 0x1832, 0x2004, 0x9005, 0x0118, 0x080c,
+	0x9a06, 0x0068, 0x6017, 0xf400, 0x605b, 0x0000, 0xa97c, 0xd1a4,
+	0x0110, 0xa980, 0x615a, 0x2009, 0x0041, 0x080c, 0x9a50, 0xa988,
+	0x918c, 0xff00, 0x9186, 0x2000, 0x1138, 0x0026, 0x900e, 0x2011,
+	0xfdff, 0x080c, 0x7e3e, 0x002e, 0xa87c, 0xd0c4, 0x0148, 0x2061,
+	0x1a3e, 0x6000, 0xd08c, 0x1120, 0x6008, 0x8000, 0x0208, 0x600a,
+	0x00ce, 0x012e, 0x00be, 0x0804, 0x74cf, 0x00ce, 0x012e, 0x00be,
+	0x0804, 0x74c9, 0xa984, 0x9186, 0x002e, 0x0d30, 0x9186, 0x002d,
+	0x0d18, 0x9186, 0x0045, 0x0510, 0x9186, 0x002a, 0x1130, 0x2001,
+	0x180c, 0x200c, 0xc194, 0x2102, 0x08b8, 0x9186, 0x0020, 0x0158,
+	0x9186, 0x0029, 0x1d10, 0xa974, 0x080c, 0x5f7e, 0x1968, 0xb800,
+	0xc0e4, 0xb802, 0x0848, 0xa88c, 0x9065, 0x09b8, 0x6007, 0x0024,
+	0x2001, 0x1955, 0x2004, 0x601a, 0x0804, 0x7364, 0xa88c, 0x9065,
+	0x0960, 0x00e6, 0xa890, 0x9075, 0x2001, 0x1832, 0x2004, 0x9005,
+	0x0150, 0x080c, 0x9a06, 0x8eff, 0x0118, 0x2e60, 0x080c, 0x9a06,
+	0x00ee, 0x0804, 0x7364, 0x6024, 0xc0dc, 0xc0d5, 0x6026, 0x2e60,
+	0x6007, 0x003a, 0xa8a0, 0x9005, 0x0130, 0x6007, 0x003b, 0xa8a4,
+	0x602e, 0xa8a8, 0x6016, 0x6003, 0x0001, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x00ee, 0x0804, 0x7364, 0x2061, 0x1a3e, 0x6000, 0xd084,
+	0x0190, 0xd08c, 0x1904, 0x74dd, 0x0126, 0x2091, 0x8000, 0x6204,
+	0x8210, 0x0220, 0x6206, 0x012e, 0x0804, 0x74dd, 0x012e, 0xa883,
+	0x0016, 0x0804, 0x74d6, 0xa883, 0x0007, 0x0804, 0x74d6, 0xa864,
+	0x8007, 0x9084, 0x00ff, 0x0130, 0x8001, 0x1138, 0x7007, 0x0001,
+	0x0069, 0x0005, 0x080c, 0x7090, 0x0040, 0x7007, 0x0003, 0x7012,
+	0x2900, 0x7016, 0x701a, 0x704b, 0x7406, 0x0005, 0x00b6, 0x00e6,
+	0x0126, 0x2091, 0x8000, 0x903e, 0x2061, 0x1800, 0x61c8, 0x81ff,
+	0x1904, 0x7488, 0x6130, 0xd194, 0x1904, 0x74b2, 0xa878, 0x2070,
+	0x9e82, 0x1cd0, 0x0a04, 0x747c, 0x6060, 0x9e02, 0x1a04, 0x747c,
+	0x7120, 0x9186, 0x0006, 0x1904, 0x746e, 0x7010, 0x905d, 0x0904,
+	0x7488, 0xb800, 0xd0e4, 0x1904, 0x74ac, 0x2061, 0x1a3e, 0x6100,
+	0x9184, 0x0301, 0x9086, 0x0001, 0x15a0, 0x7024, 0xd0dc, 0x1904,
+	0x74b5, 0xa883, 0x0000, 0xa803, 0x0000, 0x2908, 0x7014, 0x9005,
+	0x1198, 0x7116, 0xa87c, 0xd0f4, 0x1904, 0x74b8, 0x080c, 0x5113,
+	0xd09c, 0x1118, 0xa87c, 0xc0cc, 0xa87e, 0x2e60, 0x080c, 0x7d5e,
+	0x012e, 0x00ee, 0x00be, 0x0005, 0x2048, 0xa800, 0x9005, 0x1de0,
+	0xa902, 0x2148, 0xa87c, 0xd0f4, 0x1904, 0x74b8, 0x012e, 0x00ee,
+	0x00be, 0x0005, 0x012e, 0x00ee, 0xa883, 0x0006, 0x00be, 0x0804,
+	0x74d6, 0xd184, 0x0db8, 0xd1c4, 0x1190, 0x00a0, 0xa974, 0x080c,
+	0x5f7e, 0x15d0, 0xb800, 0xd0e4, 0x15b8, 0x7120, 0x9186, 0x0007,
+	0x1118, 0xa883, 0x0002, 0x0490, 0xa883, 0x0008, 0x0478, 0xa883,
+	0x000e, 0x0460, 0xa883, 0x0017, 0x0448, 0xa883, 0x0035, 0x0430,
+	0x080c, 0x5117, 0xd0fc, 0x01e8, 0xa878, 0x2070, 0x9e82, 0x1cd0,
+	0x02c0, 0x6060, 0x9e02, 0x12a8, 0x7120, 0x9186, 0x0006, 0x1188,
+	0x7010, 0x905d, 0x0170, 0xb800, 0xd0bc, 0x0158, 0x2039, 0x0001,
+	0x7000, 0x9086, 0x0007, 0x1904, 0x7412, 0x7003, 0x0002, 0x0804,
+	0x7412, 0xa883, 0x0028, 0x0010, 0xa883, 0x0029, 0x012e, 0x00ee,
+	0x00be, 0x0420, 0xa883, 0x002a, 0x0cc8, 0xa883, 0x0045, 0x0cb0,
+	0x2e60, 0x2019, 0x0002, 0x601b, 0x0014, 0x080c, 0xcbad, 0x012e,
+	0x00ee, 0x00be, 0x0005, 0x2009, 0x003e, 0x0058, 0x2009, 0x0004,
+	0x0040, 0x2009, 0x0006, 0x0028, 0x2009, 0x0016, 0x0010, 0x2009,
+	0x0001, 0xa884, 0x9084, 0xff00, 0x9105, 0xa886, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x6536, 0x012e, 0x0005, 0x080c, 0x1007, 0x0005,
+	0x00d6, 0x080c, 0x7d55, 0x00de, 0x0005, 0x00d6, 0x00e6, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x0040, 0x702c, 0xd084, 0x01d8, 0x908c,
+	0x0780, 0x190c, 0x7571, 0xd09c, 0x11a8, 0x2071, 0x1800, 0x70b8,
+	0x90ea, 0x0040, 0x0278, 0x8001, 0x70ba, 0x702c, 0x2048, 0xa800,
+	0x702e, 0x9006, 0xa802, 0xa806, 0x2071, 0x0040, 0x2900, 0x7022,
+	0x702c, 0x0c28, 0x012e, 0x00ee, 0x00de, 0x0005, 0x0006, 0x9084,
+	0x0780, 0x190c, 0x7571, 0x000e, 0x0005, 0x00d6, 0x00c6, 0x0036,
+	0x0026, 0x0016, 0x00b6, 0x7007, 0x0001, 0xaa74, 0x9282, 0x0004,
+	0x1a04, 0x7562, 0xa97c, 0x9188, 0x1000, 0x2104, 0x905d, 0xb804,
+	0xd284, 0x0140, 0x05e8, 0x8007, 0x9084, 0x00ff, 0x9084, 0x0006,
+	0x1108, 0x04b0, 0x2b10, 0x080c, 0x9980, 0x1118, 0x080c, 0x9a23,
+	0x05a8, 0x6212, 0xa874, 0x0002, 0x7540, 0x7545, 0x7548, 0x754e,
+	0x2019, 0x0002, 0x080c, 0xcf62, 0x0060, 0x080c, 0xcefe, 0x0048,
+	0x2019, 0x0002, 0xa980, 0x080c, 0xcf19, 0x0018, 0xa980, 0x080c,
+	0xcefe, 0x080c, 0x99d6, 0xa887, 0x0000, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x6536, 0x012e, 0x00be, 0x001e, 0x002e, 0x003e, 0x00ce,
+	0x00de, 0x0005, 0xa887, 0x0006, 0x0c80, 0xa887, 0x0002, 0x0c68,
+	0xa887, 0x0005, 0x0c50, 0xa887, 0x0004, 0x0c38, 0xa887, 0x0007,
+	0x0c20, 0x2091, 0x8000, 0x0e04, 0x7573, 0x0006, 0x0016, 0x2001,
+	0x8003, 0x0006, 0x0804, 0x0dbb, 0x0005, 0x00f6, 0x2079, 0x0300,
+	0x2001, 0x0200, 0x200c, 0xc1e5, 0xc1dc, 0x2102, 0x2009, 0x0218,
+	0x210c, 0xd1ec, 0x1120, 0x080c, 0x1461, 0x00fe, 0x0005, 0x2001,
+	0x020d, 0x2003, 0x0020, 0x781f, 0x0300, 0x00fe, 0x0005, 0x781c,
+	0xd08c, 0x0904, 0x75dd, 0x68b8, 0x90aa, 0x0005, 0x0a04, 0x7b73,
+	0x7d44, 0x7c40, 0x9584, 0x00f6, 0x1508, 0x9484, 0x7000, 0x0138,
+	0x908a, 0x2000, 0x1258, 0x9584, 0x0700, 0x8007, 0x04a8, 0x7000,
+	0x9084, 0xff00, 0x9086, 0x8100, 0x0db0, 0x00b0, 0x9484, 0x0fff,
+	0x1130, 0x7000, 0x9084, 0xff00, 0x9086, 0x8100, 0x11c0, 0x080c,
+	0xd31b, 0x080c, 0x7ab8, 0x7817, 0x0140, 0x00a8, 0x9584, 0x0076,
+	0x1118, 0x080c, 0x7b16, 0x19c8, 0xd5a4, 0x0148, 0x0046, 0x0056,
+	0x080c, 0x763f, 0x080c, 0x203e, 0x005e, 0x004e, 0x0020, 0x080c,
+	0xd31b, 0x7817, 0x0140, 0x080c, 0x7620, 0x2001, 0x19bf, 0x2004,
+	0x9005, 0x090c, 0x8582, 0x0005, 0x0002, 0x75f6, 0x78da, 0x75ed,
+	0x75ed, 0x75ed, 0x75ed, 0x75ed, 0x75ed, 0x7817, 0x0140, 0x2001,
+	0x19bf, 0x2004, 0x9005, 0x090c, 0x8582, 0x0005, 0x7000, 0x908c,
+	0xff00, 0x9194, 0xf000, 0x810f, 0x9484, 0x0fff, 0x688a, 0x9286,
+	0x2000, 0x1150, 0x6800, 0x9086, 0x0001, 0x1118, 0x080c, 0x5137,
+	0x0070, 0x080c, 0x765f, 0x0058, 0x9286, 0x3000, 0x1118, 0x080c,
+	0x7815, 0x0028, 0x9286, 0x8000, 0x1110, 0x080c, 0x79e8, 0x7817,
+	0x0140, 0x2001, 0x19bf, 0x2004, 0x9005, 0x090c, 0x8582, 0x0005,
+	0x2001, 0x180f, 0x2004, 0xd08c, 0x0178, 0x2001, 0x1800, 0x2004,
+	0x9086, 0x0003, 0x1148, 0x0026, 0x0036, 0x2011, 0x8048, 0x2518,
+	0x080c, 0x4672, 0x003e, 0x002e, 0x0005, 0x0036, 0x0046, 0x0056,
+	0x00f6, 0x2079, 0x0200, 0x2019, 0xfffe, 0x7c30, 0x0050, 0x0036,
+	0x0046, 0x0056, 0x00f6, 0x2079, 0x0200, 0x7d44, 0x7c40, 0x2019,
+	0xffff, 0x2001, 0x180f, 0x2004, 0xd08c, 0x0160, 0x2001, 0x1800,
+	0x2004, 0x9086, 0x0003, 0x1130, 0x0026, 0x2011, 0x8048, 0x080c,
+	0x4672, 0x002e, 0x00fe, 0x005e, 0x004e, 0x003e, 0x0005, 0x00b6,
+	0x00c6, 0x7010, 0x9084, 0xff00, 0x8007, 0x9096, 0x0001, 0x0120,
+	0x9096, 0x0023, 0x1904, 0x77e6, 0x9186, 0x0023, 0x15c0, 0x080c,
+	0x7a7d, 0x0904, 0x77e6, 0x6120, 0x9186, 0x0001, 0x0150, 0x9186,
+	0x0004, 0x0138, 0x9186, 0x0008, 0x0120, 0x9186, 0x000a, 0x1904,
+	0x77e6, 0x7124, 0x610a, 0x7030, 0x908e, 0x0200, 0x1130, 0x2009,
+	0x0015, 0x080c, 0x9a50, 0x0804, 0x77e6, 0x908e, 0x0214, 0x0118,
+	0x908e, 0x0210, 0x1130, 0x2009, 0x0015, 0x080c, 0x9a50, 0x0804,
+	0x77e6, 0x908e, 0x0100, 0x1904, 0x77e6, 0x7034, 0x9005, 0x1904,
+	0x77e6, 0x2009, 0x0016, 0x080c, 0x9a50, 0x0804, 0x77e6, 0x9186,
+	0x0022, 0x1904, 0x77e6, 0x7030, 0x908e, 0x0300, 0x1580, 0x68d4,
+	0xd0a4, 0x0528, 0xc0b5, 0x68d6, 0x7100, 0x918c, 0x00ff, 0x6976,
+	0x7004, 0x687a, 0x00f6, 0x2079, 0x0100, 0x79e6, 0x78ea, 0x0006,
+	0x9084, 0x00ff, 0x0016, 0x2008, 0x080c, 0x251f, 0x7932, 0x7936,
+	0x001e, 0x000e, 0x00fe, 0x080c, 0x24d6, 0x6956, 0x703c, 0x00e6,
+	0x2071, 0x0140, 0x7086, 0x2071, 0x1800, 0x70ae, 0x00ee, 0x7034,
+	0x9005, 0x1904, 0x77e6, 0x2009, 0x0017, 0x0804, 0x77b3, 0x908e,
+	0x0400, 0x1190, 0x7034, 0x9005, 0x1904, 0x77e6, 0x080c, 0x6c53,
+	0x0120, 0x2009, 0x001d, 0x0804, 0x77b3, 0x68d4, 0xc0a5, 0x68d6,
+	0x2009, 0x0030, 0x0804, 0x77b3, 0x908e, 0x0500, 0x1140, 0x7034,
+	0x9005, 0x1904, 0x77e6, 0x2009, 0x0018, 0x0804, 0x77b3, 0x908e,
+	0x2010, 0x1120, 0x2009, 0x0019, 0x0804, 0x77b3, 0x908e, 0x2110,
+	0x1120, 0x2009, 0x001a, 0x0804, 0x77b3, 0x908e, 0x5200, 0x1140,
+	0x7034, 0x9005, 0x1904, 0x77e6, 0x2009, 0x001b, 0x0804, 0x77b3,
+	0x908e, 0x5000, 0x1140, 0x7034, 0x9005, 0x1904, 0x77e6, 0x2009,
+	0x001c, 0x0804, 0x77b3, 0x908e, 0x1300, 0x1120, 0x2009, 0x0034,
+	0x0804, 0x77b3, 0x908e, 0x1200, 0x1140, 0x7034, 0x9005, 0x1904,
+	0x77e6, 0x2009, 0x0024, 0x0804, 0x77b3, 0x908c, 0xff00, 0x918e,
+	0x2400, 0x1170, 0x2009, 0x002d, 0x2001, 0x180f, 0x2004, 0xd09c,
+	0x0904, 0x77b3, 0x080c, 0xc384, 0x1904, 0x77e6, 0x0804, 0x77b1,
+	0x908c, 0xff00, 0x918e, 0x5300, 0x1120, 0x2009, 0x002a, 0x0804,
+	0x77b3, 0x908e, 0x0f00, 0x1120, 0x2009, 0x0020, 0x0804, 0x77b3,
+	0x908e, 0x5300, 0x1108, 0x0440, 0x908e, 0x6104, 0x1528, 0x2029,
+	0x0205, 0x2011, 0x026d, 0x8208, 0x2204, 0x9082, 0x0004, 0x8004,
+	0x8004, 0x20a8, 0x2011, 0x8015, 0x211c, 0x8108, 0x0046, 0x2124,
+	0x080c, 0x4672, 0x004e, 0x8108, 0x0f04, 0x777f, 0x9186, 0x0280,
+	0x1d88, 0x2504, 0x8000, 0x202a, 0x2009, 0x0260, 0x0c58, 0x202b,
+	0x0000, 0x2009, 0x0023, 0x0478, 0x908e, 0x6000, 0x1118, 0x2009,
+	0x003f, 0x0448, 0x908e, 0x7800, 0x1118, 0x2009, 0x0045, 0x0418,
+	0x908e, 0x1000, 0x1118, 0x2009, 0x004e, 0x00e8, 0x908e, 0x6300,
+	0x1118, 0x2009, 0x004a, 0x00b8, 0x908c, 0xff00, 0x918e, 0x5600,
+	0x1118, 0x2009, 0x004f, 0x0078, 0x908c, 0xff00, 0x918e, 0x5700,
+	0x1118, 0x2009, 0x0050, 0x0038, 0x2009, 0x001d, 0x6834, 0xd0d4,
+	0x0110, 0x2009, 0x004c, 0x0016, 0x2011, 0x0263, 0x2204, 0x8211,
+	0x220c, 0x080c, 0x24d6, 0x1568, 0x080c, 0x5f1e, 0x1550, 0xbe12,
+	0xbd16, 0x001e, 0x0016, 0xb8b0, 0x9005, 0x1168, 0x9186, 0x0046,
+	0x1150, 0x6874, 0x9606, 0x1138, 0x6878, 0x9506, 0x9084, 0xff00,
+	0x1110, 0x001e, 0x0098, 0x080c, 0x9980, 0x01a8, 0x2b08, 0x6112,
+	0x6023, 0x0004, 0x7120, 0x610a, 0x001e, 0x9186, 0x004c, 0x1110,
+	0x6023, 0x000a, 0x0016, 0x001e, 0x080c, 0x9a50, 0x00ce, 0x00be,
+	0x0005, 0x001e, 0x0cd8, 0x2001, 0x180d, 0x2004, 0xd0ec, 0x0120,
+	0x2011, 0x8049, 0x080c, 0x4672, 0x080c, 0x9a23, 0x0d90, 0x2b08,
+	0x6112, 0x6023, 0x0004, 0x7120, 0x610a, 0x001e, 0x0016, 0x9186,
+	0x0017, 0x0118, 0x9186, 0x0030, 0x1128, 0x6007, 0x0009, 0x6017,
+	0x2900, 0x0020, 0x6007, 0x0051, 0x6017, 0x0000, 0x602f, 0x0009,
+	0x6003, 0x0001, 0x080c, 0x8048, 0x08a0, 0x080c, 0x2f50, 0x1140,
+	0x7010, 0x9084, 0xff00, 0x8007, 0x908e, 0x0008, 0x1108, 0x0009,
+	0x0005, 0x00b6, 0x00c6, 0x0046, 0x7000, 0x908c, 0xff00, 0x810f,
+	0x9186, 0x0033, 0x11e8, 0x080c, 0x7a7d, 0x0904, 0x7872, 0x7124,
+	0x610a, 0x7030, 0x908e, 0x0200, 0x1140, 0x7034, 0x9005, 0x15d0,
+	0x2009, 0x0015, 0x080c, 0x9a50, 0x04a8, 0x908e, 0x0100, 0x1590,
+	0x7034, 0x9005, 0x1578, 0x2009, 0x0016, 0x080c, 0x9a50, 0x0450,
+	0x9186, 0x0032, 0x1538, 0x7030, 0x908e, 0x1400, 0x1518, 0x2009,
+	0x0038, 0x0016, 0x2011, 0x0263, 0x2204, 0x8211, 0x220c, 0x080c,
+	0x24d6, 0x11b8, 0x080c, 0x5f1e, 0x11a0, 0xbe12, 0xbd16, 0x080c,
+	0x9980, 0x0178, 0x2b08, 0x6112, 0x080c, 0xba69, 0x6023, 0x0004,
+	0x7120, 0x610a, 0x001e, 0x080c, 0x9a50, 0x080c, 0x8582, 0x0010,
+	0x00ce, 0x001e, 0x004e, 0x00ce, 0x00be, 0x0005, 0x00b6, 0x0046,
+	0x00e6, 0x00d6, 0x2028, 0x2130, 0x9696, 0x00ff, 0x11b8, 0x9592,
+	0xfffc, 0x02a0, 0x9596, 0xfffd, 0x1120, 0x2009, 0x007f, 0x0804,
+	0x78d4, 0x9596, 0xfffe, 0x1120, 0x2009, 0x007e, 0x0804, 0x78d4,
+	0x9596, 0xfffc, 0x1118, 0x2009, 0x0080, 0x04f0, 0x2011, 0x0000,
+	0x2019, 0x1835, 0x231c, 0xd3ac, 0x0130, 0x9026, 0x20a9, 0x0800,
+	0x2071, 0x1000, 0x0030, 0x2021, 0x0081, 0x20a9, 0x077f, 0x2071,
+	0x1081, 0x2e1c, 0x93dd, 0x0000, 0x1140, 0x82ff, 0x11d0, 0x9496,
+	0x00ff, 0x01b8, 0x2410, 0xc2fd, 0x00a0, 0xbf10, 0x2600, 0x9706,
+	0xb814, 0x1120, 0x9546, 0x1110, 0x2408, 0x00b0, 0x9745, 0x1148,
+	0x94c6, 0x007e, 0x0130, 0x94c6, 0x007f, 0x0118, 0x94c6, 0x0080,
+	0x1d20, 0x8420, 0x8e70, 0x1f04, 0x78a9, 0x82ff, 0x1118, 0x9085,
+	0x0001, 0x0018, 0xc2fc, 0x2208, 0x9006, 0x00de, 0x00ee, 0x004e,
+	0x00be, 0x0005, 0x7000, 0x908c, 0xff00, 0x810f, 0x9184, 0x000f,
+	0x0002, 0x78f1, 0x78f1, 0x78f1, 0x7a8f, 0x78f1, 0x78fa, 0x7925,
+	0x79b3, 0x78f1, 0x78f1, 0x78f1, 0x78f1, 0x78f1, 0x78f1, 0x78f1,
+	0x78f1, 0x7817, 0x0140, 0x2001, 0x19bf, 0x2004, 0x9005, 0x090c,
+	0x8582, 0x0005, 0x00b6, 0x7110, 0xd1bc, 0x01e8, 0x7120, 0x2160,
+	0x9c8c, 0x0007, 0x11c0, 0x9c8a, 0x1cd0, 0x02a8, 0x6860, 0x9c02,
+	0x1290, 0x7008, 0x9084, 0x00ff, 0x6110, 0x2158, 0xb910, 0x9106,
+	0x1150, 0x700c, 0xb914, 0x9106, 0x1130, 0x7124, 0x610a, 0x2009,
+	0x0046, 0x080c, 0x9a50, 0x7817, 0x0140, 0x2001, 0x19bf, 0x2004,
+	0x9005, 0x090c, 0x8582, 0x00be, 0x0005, 0x00b6, 0x00c6, 0x9484,
+	0x0fff, 0x0904, 0x7989, 0x7110, 0xd1bc, 0x1904, 0x7989, 0x7108,
+	0x700c, 0x2028, 0x918c, 0x00ff, 0x2130, 0x9094, 0xff00, 0x15b0,
+	0x81ff, 0x15a0, 0x9080, 0x2f92, 0x200d, 0x918c, 0xff00, 0x810f,
+	0x2001, 0x0080, 0x9106, 0x0904, 0x7989, 0x080c, 0x5f1e, 0x1904,
+	0x7989, 0xbe12, 0xbd16, 0xb800, 0xd0ec, 0x15d8, 0xba04, 0x9294,
+	0xff00, 0x9286, 0x0600, 0x11a0, 0x080c, 0x9980, 0x05e8, 0x2b08,
+	0x7028, 0x604a, 0x702c, 0x6046, 0x6112, 0x6023, 0x0006, 0x7120,
+	0x610a, 0x7130, 0x6156, 0x2009, 0x0044, 0x080c, 0xc5dc, 0x0408,
+	0x080c, 0x62a4, 0x1138, 0xb807, 0x0606, 0x0c30, 0x190c, 0x7876,
+	0x11c0, 0x0898, 0x080c, 0x9980, 0x2b08, 0x0198, 0x6112, 0x6023,
+	0x0004, 0x7120, 0x610a, 0x9286, 0x0400, 0x1118, 0x6007, 0x0005,
+	0x0010, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x8048, 0x080c,
+	0x8582, 0x7817, 0x0140, 0x2001, 0x19bf, 0x2004, 0x9005, 0x090c,
+	0x8582, 0x00ce, 0x00be, 0x0005, 0x2001, 0x180d, 0x2004, 0xd0ec,
+	0x0120, 0x2011, 0x8049, 0x080c, 0x4672, 0x080c, 0x9a23, 0x0d48,
+	0x2b08, 0x6112, 0x6023, 0x0006, 0x7120, 0x610a, 0x7130, 0x6156,
+	0x6017, 0xf300, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c, 0x8000,
+	0x080c, 0x8582, 0x08b0, 0x00b6, 0x7110, 0xd1bc, 0x01e8, 0x7020,
+	0x2060, 0x9c84, 0x0007, 0x11c0, 0x9c82, 0x1cd0, 0x02a8, 0x6860,
+	0x9c02, 0x1290, 0x7008, 0x9084, 0x00ff, 0x6110, 0x2158, 0xb910,
+	0x9106, 0x1150, 0x700c, 0xb914, 0x9106, 0x1130, 0x7124, 0x610a,
+	0x2009, 0x0045, 0x080c, 0x9a50, 0x7817, 0x0140, 0x2001, 0x19bf,
+	0x2004, 0x9005, 0x090c, 0x8582, 0x00be, 0x0005, 0x6120, 0x9186,
+	0x0002, 0x0128, 0x9186, 0x0005, 0x0110, 0x9085, 0x0001, 0x0005,
+	0x080c, 0x2f50, 0x1168, 0x7010, 0x9084, 0xff00, 0x8007, 0x9086,
+	0x0000, 0x1130, 0x9184, 0x000f, 0x908a, 0x0006, 0x1208, 0x000b,
+	0x0005, 0x79ff, 0x7a00, 0x79ff, 0x79ff, 0x7a5f, 0x7a6e, 0x0005,
+	0x00b6, 0x7110, 0xd1bc, 0x0120, 0x702c, 0xd084, 0x0904, 0x7a5d,
+	0x700c, 0x7108, 0x080c, 0x24d6, 0x1904, 0x7a5d, 0x080c, 0x5f1e,
+	0x1904, 0x7a5d, 0xbe12, 0xbd16, 0x7110, 0xd1bc, 0x01d8, 0x080c,
+	0x62a4, 0x0118, 0x9086, 0x0004, 0x1588, 0x00c6, 0x080c, 0x7a7d,
+	0x00ce, 0x05d8, 0x080c, 0x9980, 0x2b08, 0x05b8, 0x6112, 0x080c,
+	0xba69, 0x6023, 0x0002, 0x7120, 0x610a, 0x2009, 0x0088, 0x080c,
+	0x9a50, 0x0458, 0x080c, 0x62a4, 0x0148, 0x9086, 0x0004, 0x0130,
+	0x080c, 0x62ac, 0x0118, 0x9086, 0x0004, 0x1180, 0x080c, 0x9980,
+	0x2b08, 0x01d8, 0x6112, 0x080c, 0xba69, 0x6023, 0x0005, 0x7120,
+	0x610a, 0x2009, 0x0088, 0x080c, 0x9a50, 0x0078, 0x080c, 0x9980,
+	0x2b08, 0x0158, 0x6112, 0x080c, 0xba69, 0x6023, 0x0004, 0x7120,
+	0x610a, 0x2009, 0x0001, 0x080c, 0x9a50, 0x00be, 0x0005, 0x7110,
+	0xd1bc, 0x0158, 0x00d1, 0x0148, 0x080c, 0x79de, 0x1130, 0x7124,
+	0x610a, 0x2009, 0x0089, 0x080c, 0x9a50, 0x0005, 0x7110, 0xd1bc,
+	0x0158, 0x0059, 0x0148, 0x080c, 0x79de, 0x1130, 0x7124, 0x610a,
+	0x2009, 0x008a, 0x080c, 0x9a50, 0x0005, 0x7020, 0x2060, 0x9c84,
+	0x0007, 0x1158, 0x9c82, 0x1cd0, 0x0240, 0x2001, 0x1818, 0x2004,
+	0x9c02, 0x1218, 0x9085, 0x0001, 0x0005, 0x9006, 0x0ce8, 0x00b6,
+	0x7110, 0xd1bc, 0x11d8, 0x7024, 0x2060, 0x9c84, 0x0007, 0x11b0,
+	0x9c82, 0x1cd0, 0x0298, 0x6860, 0x9c02, 0x1280, 0x7008, 0x9084,
+	0x00ff, 0x6110, 0x2158, 0xb910, 0x9106, 0x1140, 0x700c, 0xb914,
+	0x9106, 0x1120, 0x2009, 0x0051, 0x080c, 0x9a50, 0x7817, 0x0140,
+	0x2001, 0x19bf, 0x2004, 0x9005, 0x090c, 0x8582, 0x00be, 0x0005,
+	0x2031, 0x0105, 0x0069, 0x0005, 0x2031, 0x0206, 0x0049, 0x0005,
+	0x2031, 0x0207, 0x0029, 0x0005, 0x2031, 0x0213, 0x0009, 0x0005,
+	0x00c6, 0x0096, 0x00f6, 0x7000, 0x9084, 0xf000, 0x9086, 0xc000,
+	0x05d0, 0x080c, 0x9980, 0x05b8, 0x0066, 0x00c6, 0x0046, 0x2011,
+	0x0263, 0x2204, 0x8211, 0x220c, 0x080c, 0x24d6, 0x15a0, 0x080c,
+	0x5f1e, 0x1588, 0xbe12, 0xbd16, 0x2b00, 0x004e, 0x00ce, 0x6012,
+	0x080c, 0xba69, 0x080c, 0x0fd5, 0x0510, 0x2900, 0x605a, 0x9006,
+	0xa802, 0xa866, 0xac6a, 0xa85c, 0x90f8, 0x001b, 0x20a9, 0x000e,
+	0xa860, 0x20e8, 0x20e1, 0x0000, 0x2fa0, 0x2e98, 0x4003, 0x006e,
+	0x6616, 0x6007, 0x003e, 0x6023, 0x0001, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x080c, 0x8582, 0x00fe, 0x009e, 0x00ce, 0x0005, 0x080c,
+	0x99d6, 0x006e, 0x0cc0, 0x004e, 0x00ce, 0x0cc8, 0x00c6, 0x7000,
+	0x908c, 0xff00, 0x9184, 0xf000, 0x810f, 0x9086, 0x2000, 0x1904,
+	0x7b6d, 0x9186, 0x0022, 0x15f0, 0x2001, 0x0111, 0x2004, 0x9005,
+	0x1904, 0x7b6f, 0x7030, 0x908e, 0x0400, 0x0904, 0x7b6f, 0x908e,
+	0x6000, 0x05e8, 0x908e, 0x5400, 0x05d0, 0x908e, 0x0300, 0x11d8,
+	0x2009, 0x1835, 0x210c, 0xd18c, 0x1590, 0xd1a4, 0x1580, 0x080c,
+	0x6262, 0x0558, 0x68a8, 0x9084, 0x00ff, 0x7100, 0x918c, 0x00ff,
+	0x9106, 0x1518, 0x6878, 0x69a8, 0x918c, 0xff00, 0x9105, 0x7104,
+	0x9106, 0x11d8, 0x00e0, 0x2009, 0x0103, 0x210c, 0xd1b4, 0x11a8,
+	0x908e, 0x5200, 0x09e8, 0x908e, 0x0500, 0x09d0, 0x908e, 0x5000,
+	0x09b8, 0x0058, 0x9186, 0x0023, 0x1140, 0x080c, 0x7a7d, 0x0128,
+	0x6004, 0x9086, 0x0002, 0x0118, 0x0000, 0x9006, 0x0010, 0x9085,
+	0x0001, 0x00ce, 0x0005, 0x00f6, 0x2079, 0x0200, 0x7800, 0xc0e5,
+	0xc0cc, 0x7802, 0x00fe, 0x0005, 0x00f6, 0x2079, 0x0200, 0x7800,
+	0x9085, 0x1200, 0x7802, 0x00fe, 0x0005, 0x2071, 0x19c9, 0x7003,
+	0x0003, 0x700f, 0x0361, 0x9006, 0x701a, 0x7072, 0x7012, 0x7017,
+	0x1cd0, 0x7007, 0x0000, 0x7026, 0x702b, 0x8fd1, 0x7032, 0x7037,
+	0x903f, 0x703f, 0xffff, 0x7042, 0x7047, 0x4fb2, 0x704a, 0x705b,
+	0x7ce2, 0x080c, 0x0fee, 0x090c, 0x0db2, 0x2900, 0x703a, 0xa867,
+	0x0003, 0xa86f, 0x0100, 0xa8ab, 0xdcb0, 0x0005, 0x2071, 0x19c9,
+	0x1d04, 0x7c39, 0x2091, 0x6000, 0x700c, 0x8001, 0x700e, 0x1510,
+	0x2001, 0x1875, 0x2004, 0xd0c4, 0x0158, 0x3a00, 0xd08c, 0x1140,
+	0x20d1, 0x0000, 0x20d1, 0x0001, 0x20d1, 0x0000, 0x080c, 0x0db2,
+	0x700f, 0x0361, 0x7007, 0x0001, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x7d27, 0x7040, 0x900d, 0x0148, 0x8109, 0x7142, 0x1130, 0x7044,
+	0x080f, 0x0018, 0x0126, 0x2091, 0x8000, 0x7024, 0x900d, 0x0188,
+	0x7020, 0x8001, 0x7022, 0x1168, 0x7023, 0x0009, 0x8109, 0x7126,
+	0x9186, 0x03e8, 0x1110, 0x7028, 0x080f, 0x81ff, 0x1110, 0x7028,
+	0x080f, 0x7030, 0x900d, 0x0180, 0x702c, 0x8001, 0x702e, 0x1160,
+	0x702f, 0x0009, 0x8109, 0x7132, 0x0128, 0x9184, 0x007f, 0x090c,
+	0x90b9, 0x0010, 0x7034, 0x080f, 0x703c, 0x9005, 0x0118, 0x0310,
+	0x8001, 0x703e, 0x704c, 0x900d, 0x0168, 0x7048, 0x8001, 0x704a,
+	0x1148, 0x704b, 0x0009, 0x8109, 0x714e, 0x1120, 0x7150, 0x714e,
+	0x7058, 0x080f, 0x7018, 0x900d, 0x01d8, 0x0016, 0x7070, 0x900d,
+	0x0158, 0x706c, 0x8001, 0x706e, 0x1138, 0x706f, 0x0009, 0x8109,
+	0x7172, 0x1110, 0x7074, 0x080f, 0x001e, 0x7008, 0x8001, 0x700a,
+	0x1138, 0x700b, 0x0009, 0x8109, 0x711a, 0x1110, 0x701c, 0x080f,
+	0x012e, 0x7004, 0x0002, 0x7c61, 0x7c62, 0x7c7e, 0x00e6, 0x2071,
+	0x19c9, 0x7018, 0x9005, 0x1120, 0x711a, 0x721e, 0x700b, 0x0009,
+	0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0x19c9, 0x701c, 0x9206,
+	0x1120, 0x701a, 0x701e, 0x7072, 0x7076, 0x000e, 0x00ee, 0x0005,
+	0x00e6, 0x2071, 0x19c9, 0xb888, 0x9102, 0x0208, 0xb98a, 0x00ee,
+	0x0005, 0x0005, 0x00b6, 0x7110, 0x080c, 0x5f7e, 0x1168, 0xb888,
+	0x8001, 0x0250, 0xb88a, 0x1140, 0x0126, 0x2091, 0x8000, 0x0016,
+	0x080c, 0x8582, 0x001e, 0x012e, 0x8108, 0x9182, 0x0800, 0x0218,
+	0x900e, 0x7007, 0x0002, 0x7112, 0x00be, 0x0005, 0x7014, 0x2060,
+	0x0126, 0x2091, 0x8000, 0x6040, 0x9005, 0x0128, 0x8001, 0x6042,
+	0x1110, 0x080c, 0xb8fa, 0x6018, 0x9005, 0x0510, 0x8001, 0x601a,
+	0x11f8, 0x6120, 0x9186, 0x0003, 0x0118, 0x9186, 0x0006, 0x11b0,
+	0x6014, 0x2048, 0xa884, 0x908a, 0x199a, 0x0280, 0x9082, 0x1999,
+	0xa886, 0x908a, 0x199a, 0x0210, 0x2001, 0x1999, 0x8003, 0x800b,
+	0x810b, 0x9108, 0x611a, 0xa87c, 0xd0e4, 0x0110, 0x080c, 0xb313,
+	0x012e, 0x9c88, 0x0018, 0x7116, 0x2001, 0x1818, 0x2004, 0x9102,
+	0x0220, 0x7017, 0x1cd0, 0x7007, 0x0000, 0x0005, 0x00e6, 0x2071,
+	0x19c9, 0x7027, 0x07d0, 0x7023, 0x0009, 0x00ee, 0x0005, 0x2001,
+	0x19d2, 0x2003, 0x0000, 0x0005, 0x00e6, 0x2071, 0x19c9, 0x7132,
+	0x702f, 0x0009, 0x00ee, 0x0005, 0x2011, 0x19d5, 0x2013, 0x0000,
+	0x0005, 0x00e6, 0x2071, 0x19c9, 0x711a, 0x721e, 0x700b, 0x0009,
+	0x00ee, 0x0005, 0x0086, 0x0026, 0x7054, 0x8000, 0x7056, 0x2001,
+	0x19d7, 0x2044, 0xa06c, 0x9086, 0x0000, 0x0150, 0x7068, 0xa09a,
+	0x7064, 0xa096, 0x7060, 0xa092, 0x705c, 0xa08e, 0x080c, 0x10b5,
+	0x002e, 0x008e, 0x0005, 0x0006, 0x0016, 0x0096, 0x00a6, 0x00b6,
+	0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x0156, 0x080c, 0x7bae, 0x015e,
+	0x00fe, 0x00ee, 0x00de, 0x00ce, 0x00be, 0x00ae, 0x009e, 0x001e,
+	0x000e, 0x0005, 0x00e6, 0x2071, 0x19c9, 0x7172, 0x7276, 0x706f,
+	0x0009, 0x00ee, 0x0005, 0x00e6, 0x0006, 0x2071, 0x19c9, 0x7074,
+	0x9206, 0x1110, 0x7072, 0x7076, 0x000e, 0x00ee, 0x0005, 0x2069,
+	0x1800, 0x69e0, 0xd1e4, 0x1518, 0x0026, 0xd1ec, 0x0140, 0x6a4c,
+	0x686c, 0x9202, 0x0288, 0x8117, 0x9294, 0x00c0, 0x0088, 0x9184,
+	0x0007, 0x01a0, 0x8109, 0x9184, 0x0007, 0x0110, 0x69e2, 0x0070,
+	0x8107, 0x9084, 0x0007, 0x910d, 0x8107, 0x9106, 0x9094, 0x00c0,
+	0x9184, 0xff3f, 0x9205, 0x68e2, 0x080c, 0x0eb4, 0x002e, 0x0005,
+	0x00c6, 0x2061, 0x1a3e, 0x00ce, 0x0005, 0x9184, 0x000f, 0x8003,
+	0x8003, 0x8003, 0x9080, 0x1a3e, 0x2060, 0x0005, 0xa884, 0x908a,
+	0x199a, 0x1638, 0x9005, 0x1150, 0x00c6, 0x2061, 0x1a3e, 0x6014,
+	0x00ce, 0x9005, 0x1130, 0x2001, 0x001e, 0x0018, 0x908e, 0xffff,
+	0x01b0, 0x8003, 0x800b, 0x810b, 0x9108, 0x611a, 0xa87c, 0x908c,
+	0x00c0, 0x918e, 0x00c0, 0x0904, 0x7de8, 0xd0b4, 0x1168, 0xd0bc,
+	0x1904, 0x7dc1, 0x2009, 0x0006, 0x080c, 0x7e15, 0x0005, 0x900e,
+	0x0c60, 0x2001, 0x1999, 0x08b0, 0xd0fc, 0x0160, 0x908c, 0x0003,
+	0x0120, 0x918e, 0x0003, 0x1904, 0x7e0f, 0x908c, 0x2020, 0x918e,
+	0x2020, 0x01a8, 0x6024, 0xd0d4, 0x11e8, 0x2009, 0x1875, 0x2104,
+	0xd084, 0x1138, 0x87ff, 0x1120, 0x2009, 0x0043, 0x0804, 0x9a50,
+	0x0005, 0x87ff, 0x1de8, 0x2009, 0x0042, 0x0804, 0x9a50, 0x6110,
+	0x00b6, 0x2158, 0xb900, 0x00be, 0xd1ac, 0x0d20, 0x6024, 0xc0cd,
+	0x6026, 0x0c00, 0xc0d4, 0x6026, 0xa890, 0x602e, 0xa88c, 0x6032,
+	0x08e0, 0xd0fc, 0x0160, 0x908c, 0x0003, 0x0120, 0x918e, 0x0003,
+	0x1904, 0x7e0f, 0x908c, 0x2020, 0x918e, 0x2020, 0x0170, 0x0076,
+	0x00f6, 0x2c78, 0x080c, 0x1582, 0x00fe, 0x007e, 0x87ff, 0x1120,
+	0x2009, 0x0042, 0x080c, 0x9a50, 0x0005, 0x6110, 0x00b6, 0x2158,
+	0xb900, 0x00be, 0xd1ac, 0x0d58, 0x6124, 0xc1cd, 0x6126, 0x0c38,
+	0xd0fc, 0x0188, 0x908c, 0x2020, 0x918e, 0x2020, 0x01a8, 0x9084,
+	0x0003, 0x908e, 0x0002, 0x0148, 0x87ff, 0x1120, 0x2009, 0x0041,
+	0x080c, 0x9a50, 0x0005, 0x00b9, 0x0ce8, 0x87ff, 0x1dd8, 0x2009,
+	0x0043, 0x080c, 0x9a50, 0x0cb0, 0x6110, 0x00b6, 0x2158, 0xb900,
+	0x00be, 0xd1ac, 0x0d20, 0x6124, 0xc1cd, 0x6126, 0x0c00, 0x2009,
+	0x0004, 0x0019, 0x0005, 0x2009, 0x0001, 0x0096, 0x080c, 0xb5fb,
+	0x0518, 0x6014, 0x2048, 0xa982, 0xa800, 0x6016, 0x9186, 0x0001,
+	0x1188, 0xa97c, 0x918c, 0x8100, 0x918e, 0x8100, 0x1158, 0x00c6,
+	0x2061, 0x1a3e, 0x6200, 0xd28c, 0x1120, 0x6204, 0x8210, 0x0208,
+	0x6206, 0x00ce, 0x080c, 0x6370, 0x6014, 0x904d, 0x0076, 0x2039,
+	0x0000, 0x190c, 0x7d5e, 0x007e, 0x009e, 0x0005, 0x0156, 0x00c6,
+	0x2061, 0x1a3e, 0x6000, 0x81ff, 0x0110, 0x9205, 0x0008, 0x9204,
+	0x6002, 0x00ce, 0x015e, 0x0005, 0x6800, 0xd08c, 0x1138, 0x6808,
+	0x9005, 0x0120, 0x8001, 0x680a, 0x9085, 0x0001, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x0036, 0x0046, 0x20a9, 0x0010, 0x9006, 0x8004,
+	0x2019, 0x0100, 0x231c, 0x93a6, 0x0008, 0x1118, 0x8086, 0x818e,
+	0x0020, 0x80f6, 0x3e00, 0x81f6, 0x3e08, 0x1208, 0x9200, 0x1f04,
+	0x7e60, 0x93a6, 0x0008, 0x1118, 0x8086, 0x818e, 0x0020, 0x80f6,
+	0x3e00, 0x81f6, 0x3e08, 0x004e, 0x003e, 0x012e, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x0076, 0x0156, 0x20a9, 0x0010, 0x9005, 0x0510,
+	0x911a, 0x1600, 0x8213, 0x2039, 0x0100, 0x273c, 0x97be, 0x0008,
+	0x1110, 0x818d, 0x0010, 0x81f5, 0x3e08, 0x0228, 0x911a, 0x1220,
+	0x1f04, 0x7e8a, 0x0028, 0x911a, 0x2308, 0x8210, 0x1f04, 0x7e8a,
+	0x0006, 0x3200, 0x9084, 0xefff, 0x2080, 0x000e, 0x015e, 0x007e,
+	0x012e, 0x0005, 0x0006, 0x3200, 0x9085, 0x1000, 0x0ca8, 0x0126,
+	0x2091, 0x2800, 0x2079, 0x19b6, 0x012e, 0x00d6, 0x2069, 0x19b6,
+	0x6803, 0x0005, 0x0156, 0x0146, 0x01d6, 0x20e9, 0x0000, 0x2069,
+	0x0200, 0x080c, 0x97ce, 0x0401, 0x080c, 0x97b9, 0x00e9, 0x080c,
+	0x97bc, 0x00d1, 0x080c, 0x97bf, 0x00b9, 0x080c, 0x97c2, 0x00a1,
+	0x080c, 0x97c5, 0x0089, 0x080c, 0x97c8, 0x0071, 0x080c, 0x97cb,
+	0x0059, 0x01de, 0x014e, 0x015e, 0x2069, 0x0004, 0x2d04, 0x9085,
+	0x8001, 0x206a, 0x00de, 0x0005, 0x20a9, 0x0020, 0x20a1, 0x0240,
+	0x2001, 0x0000, 0x4004, 0x0005, 0x00c6, 0x6027, 0x0001, 0x7804,
+	0x9084, 0x0007, 0x0002, 0x7efd, 0x7f21, 0x7f60, 0x7f03, 0x7f21,
+	0x7efd, 0x7efb, 0x7efb, 0x080c, 0x0db2, 0x080c, 0x7cc7, 0x080c,
+	0x8582, 0x00ce, 0x0005, 0x62c0, 0x82ff, 0x1110, 0x00ce, 0x0005,
+	0x2011, 0x588a, 0x080c, 0x7c4a, 0x7828, 0x9092, 0x00c8, 0x1228,
+	0x8000, 0x782a, 0x080c, 0x58ca, 0x0c88, 0x62c0, 0x080c, 0x97d2,
+	0x080c, 0x588a, 0x7807, 0x0003, 0x7827, 0x0000, 0x782b, 0x0000,
+	0x0c28, 0x080c, 0x7cc7, 0x6220, 0xd2a4, 0x0160, 0x782b, 0x0000,
+	0x7824, 0x9065, 0x090c, 0x0db2, 0x2009, 0x0013, 0x080c, 0x9a50,
+	0x00ce, 0x0005, 0x00c6, 0x7824, 0x9065, 0x090c, 0x0db2, 0x7828,
+	0x9092, 0xc350, 0x12c0, 0x8000, 0x782a, 0x00ce, 0x080c, 0x283d,
+	0x0278, 0x00c6, 0x7924, 0x2160, 0x6010, 0x906d, 0x090c, 0x0db2,
+	0x7807, 0x0000, 0x7827, 0x0000, 0x00ce, 0x080c, 0x8582, 0x0c00,
+	0x080c, 0x8f97, 0x08e8, 0x2011, 0x0130, 0x2214, 0x080c, 0x97d2,
+	0x080c, 0xd358, 0x2009, 0x0014, 0x080c, 0x9a50, 0x00ce, 0x0880,
+	0x2001, 0x19d2, 0x2003, 0x0000, 0x62c0, 0x82ff, 0x1160, 0x782b,
+	0x0000, 0x7824, 0x9065, 0x090c, 0x0db2, 0x2009, 0x0013, 0x080c,
+	0x9aa2, 0x00ce, 0x0005, 0x00b6, 0x00c6, 0x00d6, 0x7824, 0x9005,
+	0x090c, 0x0db2, 0x7828, 0x9092, 0xc350, 0x1648, 0x8000, 0x782a,
+	0x00de, 0x00ce, 0x00be, 0x080c, 0x283d, 0x02f0, 0x00b6, 0x00c6,
+	0x00d6, 0x781c, 0x905d, 0x090c, 0x0db2, 0xb800, 0xc0dc, 0xb802,
+	0x7924, 0x2160, 0x080c, 0x99d6, 0xb93c, 0x81ff, 0x090c, 0x0db2,
+	0x8109, 0xb93e, 0x7807, 0x0000, 0x7827, 0x0000, 0x00de, 0x00ce,
+	0x00be, 0x080c, 0x8582, 0x0868, 0x080c, 0x8f97, 0x0850, 0x2011,
+	0x0130, 0x2214, 0x080c, 0x97d2, 0x080c, 0xd358, 0x7824, 0x9065,
+	0x2009, 0x0014, 0x080c, 0x9a50, 0x00de, 0x00ce, 0x00be, 0x0804,
+	0x7f71, 0x00c6, 0x2001, 0x009b, 0x2004, 0xd0fc, 0x190c, 0x1be4,
+	0x6024, 0x6027, 0x0002, 0xd0f4, 0x1580, 0x62c8, 0x60c4, 0x9205,
+	0x1170, 0x783c, 0x9065, 0x0130, 0x2009, 0x0049, 0x080c, 0x9a50,
+	0x00ce, 0x0005, 0x2011, 0x19d5, 0x2013, 0x0000, 0x0cc8, 0x793c,
+	0x81ff, 0x0dc0, 0x7944, 0x9192, 0x7530, 0x12f0, 0x8108, 0x7946,
+	0x793c, 0x9188, 0x0008, 0x210c, 0x918e, 0x0006, 0x1138, 0x6014,
+	0x9084, 0x1984, 0x9085, 0x0012, 0x6016, 0x0c10, 0x6014, 0x9084,
+	0x1984, 0x9085, 0x0016, 0x6016, 0x08d8, 0x793c, 0x2160, 0x2009,
+	0x004a, 0x080c, 0x9a50, 0x08a0, 0x7848, 0xc085, 0x784a, 0x0880,
+	0x0006, 0x0016, 0x00c6, 0x0126, 0x2091, 0x8000, 0x600f, 0x0000,
+	0x2c08, 0x2061, 0x19b6, 0x6020, 0x8000, 0x6022, 0x6010, 0x9005,
+	0x0148, 0x9080, 0x0003, 0x2102, 0x6112, 0x012e, 0x00ce, 0x001e,
+	0x000e, 0x0005, 0x6116, 0x6112, 0x0cc0, 0x00d6, 0x2069, 0x19b6,
+	0xb800, 0xd0d4, 0x0168, 0x6820, 0x8000, 0x6822, 0x9086, 0x0001,
+	0x1110, 0x2b00, 0x681e, 0x00de, 0x0804, 0x8582, 0x00de, 0x0005,
+	0xc0d5, 0xb802, 0x6818, 0x9005, 0x0168, 0xb856, 0xb85b, 0x0000,
+	0x0086, 0x0006, 0x2b00, 0x681a, 0x008e, 0xa05a, 0x008e, 0x2069,
+	0x19b6, 0x0c08, 0xb856, 0xb85a, 0x2b00, 0x681a, 0x681e, 0x08d8,
+	0x0006, 0x0016, 0x00c6, 0x0126, 0x2091, 0x8000, 0x600f, 0x0000,
+	0x2c08, 0x2061, 0x19b6, 0x6020, 0x8000, 0x6022, 0x6008, 0x9005,
+	0x0148, 0x9080, 0x0003, 0x2102, 0x610a, 0x012e, 0x00ce, 0x001e,
+	0x000e, 0x0005, 0x610e, 0x610a, 0x0cc0, 0x00c6, 0x600f, 0x0000,
+	0x2c08, 0x2061, 0x19b6, 0x6034, 0x9005, 0x0130, 0x9080, 0x0003,
+	0x2102, 0x6136, 0x00ce, 0x0005, 0x613a, 0x6136, 0x00ce, 0x0005,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x00b6, 0x0096, 0x0076, 0x0066,
+	0x0056, 0x0036, 0x0026, 0x0016, 0x0006, 0x0126, 0x902e, 0x2071,
+	0x19b6, 0x7638, 0x2660, 0x2678, 0x2091, 0x8000, 0x8cff, 0x0904,
+	0x80ef, 0x6010, 0x2058, 0xb8a0, 0x9206, 0x1904, 0x80ea, 0x87ff,
+	0x0120, 0x6054, 0x9106, 0x1904, 0x80ea, 0x703c, 0x9c06, 0x1178,
+	0x0036, 0x2019, 0x0001, 0x080c, 0x9254, 0x7033, 0x0000, 0x9006,
+	0x703e, 0x7042, 0x7046, 0x704a, 0x003e, 0x2029, 0x0001, 0x7038,
+	0x9c36, 0x1110, 0x660c, 0x763a, 0x7034, 0x9c36, 0x1140, 0x2c00,
+	0x9f36, 0x0118, 0x2f00, 0x7036, 0x0010, 0x7037, 0x0000, 0x660c,
+	0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f,
+	0x0000, 0x080c, 0xb5fb, 0x01c8, 0x6014, 0x2048, 0x6020, 0x9086,
+	0x0003, 0x1590, 0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x0016,
+	0x0036, 0x0076, 0x080c, 0xb8e3, 0x080c, 0xd28c, 0x080c, 0x6536,
+	0x007e, 0x003e, 0x001e, 0x080c, 0xb7dd, 0x080c, 0x9a06, 0x00ce,
+	0x0804, 0x808e, 0x2c78, 0x600c, 0x2060, 0x0804, 0x808e, 0x85ff,
+	0x0120, 0x0036, 0x080c, 0x865d, 0x003e, 0x012e, 0x000e, 0x001e,
+	0x002e, 0x003e, 0x005e, 0x006e, 0x007e, 0x009e, 0x00be, 0x00ce,
+	0x00de, 0x00ee, 0x00fe, 0x0005, 0x6020, 0x9086, 0x0006, 0x1158,
+	0x0016, 0x0036, 0x0076, 0x080c, 0xd28c, 0x080c, 0xcf91, 0x007e,
+	0x003e, 0x001e, 0x0890, 0x6020, 0x9086, 0x000a, 0x0904, 0x80d4,
+	0x0804, 0x80d2, 0x0006, 0x0066, 0x0096, 0x00c6, 0x00d6, 0x00f6,
+	0x9036, 0x0126, 0x2091, 0x8000, 0x2079, 0x19b6, 0x7838, 0x9065,
+	0x0904, 0x816a, 0x600c, 0x0006, 0x600f, 0x0000, 0x783c, 0x9c06,
+	0x1168, 0x0036, 0x2019, 0x0001, 0x080c, 0x9254, 0x7833, 0x0000,
+	0x901e, 0x7b3e, 0x7b42, 0x7b46, 0x7b4a, 0x003e, 0x080c, 0xb5fb,
+	0x0520, 0x6014, 0x2048, 0x6020, 0x9086, 0x0003, 0x1568, 0x3e08,
+	0x918e, 0x0002, 0x1188, 0x6010, 0x9005, 0x0170, 0x00b6, 0x2058,
+	0xb800, 0x00be, 0xd0bc, 0x0140, 0x6040, 0x9005, 0x1180, 0x2001,
+	0x1957, 0x2004, 0x6042, 0x0058, 0xa867, 0x0103, 0xab7a, 0xa877,
+	0x0000, 0x080c, 0x6529, 0x080c, 0xb7dd, 0x080c, 0x9a06, 0x000e,
+	0x0804, 0x8127, 0x7e3a, 0x7e36, 0x012e, 0x00fe, 0x00de, 0x00ce,
+	0x009e, 0x006e, 0x000e, 0x0005, 0x6020, 0x9086, 0x0006, 0x1118,
+	0x080c, 0xcf91, 0x0c50, 0x6020, 0x9086, 0x000a, 0x09f8, 0x08e0,
+	0x0016, 0x0026, 0x0086, 0x9046, 0x0099, 0x080c, 0x8269, 0x008e,
+	0x002e, 0x001e, 0x0005, 0x00f6, 0x0126, 0x2079, 0x19b6, 0x2091,
+	0x8000, 0x080c, 0x8300, 0x080c, 0x838e, 0x012e, 0x00fe, 0x0005,
+	0x00b6, 0x0096, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0016,
+	0x0006, 0x0126, 0x2091, 0x8000, 0x2071, 0x19b6, 0x7614, 0x2660,
+	0x2678, 0x8cff, 0x0904, 0x822e, 0x6010, 0x2058, 0xb8a0, 0x9206,
+	0x1904, 0x8229, 0x88ff, 0x0120, 0x6054, 0x9106, 0x1904, 0x8229,
+	0x7024, 0x9c06, 0x1558, 0x2069, 0x0100, 0x6820, 0xd0a4, 0x1508,
+	0x080c, 0x7cc7, 0x080c, 0x8fbb, 0x68c3, 0x0000, 0x080c, 0x9469,
+	0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000,
+	0x0138, 0x2001, 0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987,
+	0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e,
+	0x0028, 0x6003, 0x0009, 0x630a, 0x0804, 0x8229, 0x7014, 0x9c36,
+	0x1110, 0x660c, 0x7616, 0x7010, 0x9c36, 0x1140, 0x2c00, 0x9f36,
+	0x0118, 0x2f00, 0x7012, 0x0010, 0x7013, 0x0000, 0x660c, 0x0066,
+	0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000,
+	0x6014, 0x2048, 0x080c, 0xb5fb, 0x01e8, 0x6020, 0x9086, 0x0003,
+	0x1580, 0x080c, 0xb7fa, 0x1118, 0x080c, 0xa364, 0x0098, 0xa867,
+	0x0103, 0xab7a, 0xa877, 0x0000, 0x0016, 0x0036, 0x0086, 0x080c,
+	0xb8e3, 0x080c, 0xd28c, 0x080c, 0x6536, 0x008e, 0x003e, 0x001e,
+	0x080c, 0xb7dd, 0x080c, 0x9a06, 0x080c, 0x933f, 0x00ce, 0x0804,
+	0x81a9, 0x2c78, 0x600c, 0x2060, 0x0804, 0x81a9, 0x012e, 0x000e,
+	0x001e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x009e, 0x00be,
+	0x0005, 0x6020, 0x9086, 0x0006, 0x1158, 0x0016, 0x0036, 0x0086,
+	0x080c, 0xd28c, 0x080c, 0xcf91, 0x008e, 0x003e, 0x001e, 0x08d0,
+	0x080c, 0xa364, 0x6020, 0x9086, 0x0002, 0x1160, 0x6004, 0x0006,
+	0x9086, 0x0085, 0x000e, 0x0904, 0x820f, 0x9086, 0x008b, 0x0904,
+	0x820f, 0x0840, 0x6020, 0x9086, 0x0005, 0x1920, 0x6004, 0x0006,
+	0x9086, 0x0085, 0x000e, 0x09c8, 0x9086, 0x008b, 0x09b0, 0x0804,
+	0x8222, 0x00b6, 0x00a6, 0x0096, 0x00c6, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x9280, 0x1000, 0x2004, 0x905d, 0x0904, 0x82f9, 0x00f6,
+	0x00e6, 0x00d6, 0x0066, 0x2071, 0x19b6, 0xbe54, 0x7018, 0x9b06,
+	0x1108, 0x761a, 0x701c, 0x9b06, 0x1130, 0x86ff, 0x1118, 0x7018,
+	0x701e, 0x0008, 0x761e, 0xb858, 0x904d, 0x0108, 0xae56, 0x96d5,
+	0x0000, 0x0110, 0x2900, 0xb05a, 0xb857, 0x0000, 0xb85b, 0x0000,
+	0xb800, 0xc0d4, 0xc0dc, 0xb802, 0x080c, 0x5eb1, 0x0904, 0x82f5,
+	0x7624, 0x86ff, 0x0904, 0x82e4, 0x9680, 0x0005, 0x2004, 0x9906,
+	0x15d8, 0x00d6, 0x2069, 0x0100, 0x68c0, 0x9005, 0x0560, 0x080c,
+	0x7cc7, 0x080c, 0x8fbb, 0x68c3, 0x0000, 0x080c, 0x9469, 0x7027,
+	0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0138,
+	0x2001, 0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x00de,
+	0x00c6, 0xb83c, 0x9005, 0x0110, 0x8001, 0xb83e, 0x2660, 0x080c,
+	0x9a06, 0x00ce, 0x0048, 0x00de, 0x00c6, 0x2660, 0x6003, 0x0009,
+	0x630a, 0x00ce, 0x0804, 0x829c, 0x89ff, 0x0158, 0xa867, 0x0103,
+	0xab7a, 0xa877, 0x0000, 0x080c, 0xb8e3, 0x080c, 0xd28c, 0x080c,
+	0x6536, 0x080c, 0x933f, 0x0804, 0x829c, 0x006e, 0x00de, 0x00ee,
+	0x00fe, 0x012e, 0x000e, 0x00ce, 0x009e, 0x00ae, 0x00be, 0x0005,
+	0x0096, 0x0006, 0x0066, 0x00c6, 0x00d6, 0x9036, 0x7814, 0x9065,
+	0x0904, 0x8361, 0x600c, 0x0006, 0x600f, 0x0000, 0x7824, 0x9c06,
+	0x1570, 0x2069, 0x0100, 0x6820, 0xd0a4, 0x1508, 0x080c, 0x7cc7,
+	0x080c, 0x8fbb, 0x68c3, 0x0000, 0x080c, 0x9469, 0x7827, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0138, 0x2001,
+	0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x0040, 0x080c,
+	0x625a, 0x1520, 0x6003, 0x0009, 0x630a, 0x2c30, 0x00f8, 0x6014,
+	0x2048, 0x080c, 0xb5f9, 0x01b0, 0x6020, 0x9086, 0x0003, 0x1508,
+	0x080c, 0xb7fa, 0x1118, 0x080c, 0xa364, 0x0060, 0x080c, 0x625a,
+	0x1168, 0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x080c, 0x6536,
+	0x080c, 0xb7dd, 0x080c, 0x9a06, 0x080c, 0x933f, 0x000e, 0x0804,
+	0x8307, 0x7e16, 0x7e12, 0x00de, 0x00ce, 0x006e, 0x000e, 0x009e,
+	0x0005, 0x6020, 0x9086, 0x0006, 0x1118, 0x080c, 0xcf91, 0x0c50,
+	0x080c, 0xa364, 0x6020, 0x9086, 0x0002, 0x1150, 0x6004, 0x0006,
+	0x9086, 0x0085, 0x000e, 0x0990, 0x9086, 0x008b, 0x0978, 0x08d0,
+	0x6020, 0x9086, 0x0005, 0x19b0, 0x6004, 0x0006, 0x9086, 0x0085,
+	0x000e, 0x0d18, 0x9086, 0x008b, 0x0d00, 0x0860, 0x0006, 0x0066,
+	0x0096, 0x00b6, 0x00c6, 0x00d6, 0x7818, 0x905d, 0x0904, 0x840e,
+	0xb854, 0x0006, 0x9006, 0xb856, 0xb85a, 0xb800, 0xc0d4, 0xc0dc,
+	0xb802, 0x080c, 0x5eb1, 0x0904, 0x840b, 0x7e24, 0x86ff, 0x0904,
+	0x83fe, 0x9680, 0x0005, 0x2004, 0x9906, 0x1904, 0x83fe, 0x00d6,
+	0x2069, 0x0100, 0x68c0, 0x9005, 0x0904, 0x83f5, 0x080c, 0x7cc7,
+	0x080c, 0x8fbb, 0x68c3, 0x0000, 0x080c, 0x9469, 0x7827, 0x0000,
+	0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0138, 0x2001,
+	0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987, 0x2069, 0x0100,
+	0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x00de, 0x00c6,
+	0x3e08, 0x918e, 0x0002, 0x1168, 0xb800, 0xd0bc, 0x0150, 0x9680,
+	0x0010, 0x200c, 0x81ff, 0x1518, 0x2009, 0x1957, 0x210c, 0x2102,
+	0x00f0, 0xb83c, 0x9005, 0x0110, 0x8001, 0xb83e, 0x2660, 0x600f,
+	0x0000, 0x080c, 0x9a06, 0x00ce, 0x0048, 0x00de, 0x00c6, 0x2660,
+	0x6003, 0x0009, 0x630a, 0x00ce, 0x0804, 0x83a1, 0x89ff, 0x0138,
+	0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x080c, 0x6536, 0x080c,
+	0x933f, 0x0804, 0x83a1, 0x000e, 0x0804, 0x8395, 0x781e, 0x781a,
+	0x00de, 0x00ce, 0x00be, 0x009e, 0x006e, 0x000e, 0x0005, 0x00e6,
+	0x00d6, 0x0096, 0x0066, 0xb800, 0xd0dc, 0x01a0, 0xb84c, 0x904d,
+	0x0188, 0xa878, 0x9606, 0x1170, 0x2071, 0x19b6, 0x7024, 0x9035,
+	0x0148, 0x9080, 0x0005, 0x2004, 0x9906, 0x1120, 0xb800, 0xc0dc,
+	0xb802, 0x0029, 0x006e, 0x009e, 0x00de, 0x00ee, 0x0005, 0x00f6,
+	0x2079, 0x0100, 0x78c0, 0x9005, 0x1138, 0x00c6, 0x2660, 0x6003,
+	0x0009, 0x630a, 0x00ce, 0x04b8, 0x080c, 0x8fbb, 0x78c3, 0x0000,
+	0x080c, 0x9469, 0x7027, 0x0000, 0x0036, 0x2079, 0x0140, 0x7b04,
+	0x9384, 0x1000, 0x0138, 0x2001, 0x0100, 0x080c, 0x2987, 0x9006,
+	0x080c, 0x2987, 0x2079, 0x0100, 0x7824, 0xd084, 0x0110, 0x7827,
+	0x0001, 0x080c, 0x9469, 0x003e, 0x080c, 0x5eb1, 0x00c6, 0xb83c,
+	0x9005, 0x0110, 0x8001, 0xb83e, 0x2660, 0x080c, 0x99d6, 0x00ce,
+	0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x080c, 0xb8e3, 0x080c,
+	0x6536, 0x080c, 0x933f, 0x00fe, 0x0005, 0x00b6, 0x00e6, 0x00c6,
+	0x2011, 0x0101, 0x2204, 0xc0c4, 0x2012, 0x2001, 0x180c, 0x2014,
+	0xc2e4, 0x2202, 0x2071, 0x19b6, 0x7004, 0x9084, 0x0007, 0x0002,
+	0x849a, 0x849e, 0x84b5, 0x84de, 0x851c, 0x849a, 0x84b5, 0x8498,
+	0x080c, 0x0db2, 0x00ce, 0x00ee, 0x00be, 0x0005, 0x7024, 0x9065,
+	0x0148, 0x7020, 0x8001, 0x7022, 0x600c, 0x9015, 0x0158, 0x7216,
+	0x600f, 0x0000, 0x7007, 0x0000, 0x7027, 0x0000, 0x00ce, 0x00ee,
+	0x00be, 0x0005, 0x7216, 0x7212, 0x0ca8, 0x6010, 0x2058, 0x080c,
+	0x5eb1, 0xb800, 0xc0dc, 0xb802, 0x7007, 0x0000, 0x7027, 0x0000,
+	0x7020, 0x8001, 0x7022, 0x1148, 0x2001, 0x180c, 0x2014, 0xd2ec,
+	0x1180, 0x00ce, 0x00ee, 0x00be, 0x0005, 0xb854, 0x9015, 0x0120,
+	0x721e, 0x080c, 0x8582, 0x0ca8, 0x7218, 0x721e, 0x080c, 0x8582,
+	0x0c80, 0xc2ec, 0x2202, 0x080c, 0x865d, 0x0c58, 0x7024, 0x9065,
+	0x05b8, 0x700c, 0x9c06, 0x1160, 0x080c, 0x933f, 0x600c, 0x9015,
+	0x0120, 0x720e, 0x600f, 0x0000, 0x0448, 0x720e, 0x720a, 0x0430,
+	0x7014, 0x9c06, 0x1160, 0x080c, 0x933f, 0x600c, 0x9015, 0x0120,
+	0x7216, 0x600f, 0x0000, 0x00d0, 0x7216, 0x7212, 0x00b8, 0x6020,
+	0x9086, 0x0003, 0x1198, 0x6010, 0x2058, 0x080c, 0x5eb1, 0xb800,
+	0xc0dc, 0xb802, 0x080c, 0x933f, 0x701c, 0x9065, 0x0138, 0xb854,
+	0x9015, 0x0110, 0x721e, 0x0010, 0x7218, 0x721e, 0x7027, 0x0000,
+	0x00ce, 0x00ee, 0x00be, 0x0005, 0x7024, 0x9065, 0x0140, 0x080c,
+	0x933f, 0x600c, 0x9015, 0x0158, 0x720e, 0x600f, 0x0000, 0x080c,
+	0x9469, 0x7027, 0x0000, 0x00ce, 0x00ee, 0x00be, 0x0005, 0x720e,
+	0x720a, 0x0ca8, 0x00d6, 0x2069, 0x19b6, 0x6830, 0x9084, 0x0003,
+	0x0002, 0x853f, 0x8541, 0x8565, 0x853d, 0x080c, 0x0db2, 0x00de,
+	0x0005, 0x00c6, 0x6840, 0x9086, 0x0001, 0x01b8, 0x683c, 0x9065,
+	0x0130, 0x600c, 0x9015, 0x0170, 0x6a3a, 0x600f, 0x0000, 0x6833,
+	0x0000, 0x683f, 0x0000, 0x2011, 0x19d5, 0x2013, 0x0000, 0x00ce,
+	0x00de, 0x0005, 0x683a, 0x6836, 0x0c90, 0x6843, 0x0000, 0x6838,
+	0x9065, 0x0d68, 0x6003, 0x0003, 0x0c50, 0x00c6, 0x9006, 0x6842,
+	0x6846, 0x684a, 0x683c, 0x9065, 0x0160, 0x600c, 0x9015, 0x0130,
+	0x6a3a, 0x600f, 0x0000, 0x683f, 0x0000, 0x0018, 0x683e, 0x683a,
+	0x6836, 0x00ce, 0x00de, 0x0005, 0x2001, 0x180c, 0x200c, 0xc1e5,
+	0x2102, 0x0005, 0x2001, 0x180c, 0x200c, 0xd1ec, 0x0120, 0xc1ec,
+	0x2102, 0x080c, 0x865d, 0x2001, 0x19c2, 0x2004, 0x9086, 0x0001,
+	0x0d58, 0x00d6, 0x2069, 0x19b6, 0x6804, 0x9084, 0x0007, 0x0002,
+	0x85a2, 0x8645, 0x8645, 0x8645, 0x8645, 0x8647, 0x8645, 0x85a0,
+	0x080c, 0x0db2, 0x6820, 0x9005, 0x1110, 0x00de, 0x0005, 0x00c6,
+	0x680c, 0x9065, 0x0150, 0x6807, 0x0004, 0x6826, 0x682b, 0x0000,
+	0x080c, 0x86b3, 0x00ce, 0x00de, 0x0005, 0x6814, 0x9065, 0x0150,
+	0x6807, 0x0001, 0x6826, 0x682b, 0x0000, 0x080c, 0x86b3, 0x00ce,
+	0x00de, 0x0005, 0x00b6, 0x00e6, 0x6a1c, 0x92dd, 0x0000, 0x0904,
+	0x8631, 0xb84c, 0x900d, 0x0118, 0xb888, 0x9005, 0x01a0, 0xb854,
+	0x905d, 0x0120, 0x920e, 0x0904, 0x8631, 0x0028, 0x6818, 0x920e,
+	0x0904, 0x8631, 0x2058, 0xb84c, 0x900d, 0x0d88, 0xb888, 0x9005,
+	0x1d70, 0x2b00, 0x681e, 0xbb3c, 0xb838, 0x9302, 0x1e40, 0x080c,
+	0x99ad, 0x0904, 0x8631, 0x8318, 0xbb3e, 0x6116, 0x2b10, 0x6212,
+	0x0096, 0x2148, 0xa880, 0x9084, 0x00ff, 0x605e, 0xa883, 0x0000,
+	0xa884, 0x009e, 0x908a, 0x199a, 0x0210, 0x2001, 0x1999, 0x8003,
+	0x801b, 0x831b, 0x9318, 0x631a, 0x6114, 0x0096, 0x2148, 0xa964,
+	0x009e, 0x918c, 0x00ff, 0x918e, 0x0048, 0x0538, 0x00f6, 0x2c78,
+	0x2061, 0x0100, 0xbab0, 0x629a, 0x2069, 0x0200, 0x2071, 0x0240,
+	0x080c, 0x8bf2, 0x2069, 0x19b6, 0xbb00, 0xc3dd, 0xbb02, 0x6807,
+	0x0002, 0x2f18, 0x6b26, 0x682b, 0x0000, 0x7823, 0x0003, 0x7803,
+	0x0001, 0x7807, 0x0040, 0x00fe, 0x00ee, 0x00be, 0x00ce, 0x00de,
+	0x0005, 0x00ee, 0x00be, 0x00ce, 0x0cd0, 0xbb00, 0xc3dd, 0xbb02,
+	0x6807, 0x0006, 0x2f18, 0x6b26, 0x682b, 0x0000, 0x080c, 0x97f2,
+	0x00ee, 0x00be, 0x00ce, 0x00de, 0x0005, 0x00de, 0x0005, 0x00c6,
+	0x680c, 0x9065, 0x0138, 0x6807, 0x0004, 0x6826, 0x682b, 0x0000,
+	0x080c, 0x86b3, 0x00ce, 0x00de, 0x0005, 0x2001, 0x180c, 0x2014,
+	0xc2ed, 0x2202, 0x00de, 0x00fe, 0x0005, 0x00f6, 0x00d6, 0x2069,
+	0x19b6, 0x6830, 0x9086, 0x0000, 0x1548, 0x2001, 0x180c, 0x2014,
+	0xd2e4, 0x0130, 0xc2e4, 0x2202, 0x080c, 0x8591, 0x2069, 0x19b6,
+	0x2001, 0x180c, 0x200c, 0xd1c4, 0x11e0, 0x6838, 0x907d, 0x01b0,
+	0x6a04, 0x9296, 0x0000, 0x1588, 0x6833, 0x0001, 0x683e, 0x6847,
+	0x0000, 0x684b, 0x0000, 0x0126, 0x00f6, 0x2091, 0x2400, 0x002e,
+	0x080c, 0x19f2, 0x1178, 0x012e, 0x080c, 0x8e0a, 0x00de, 0x00fe,
+	0x0005, 0xc1c4, 0x2102, 0x0066, 0x2031, 0x0001, 0x080c, 0x6d03,
+	0x006e, 0x08d8, 0x012e, 0x6843, 0x0000, 0x7803, 0x0002, 0x780c,
+	0x9015, 0x0140, 0x6a3a, 0x780f, 0x0000, 0x6833, 0x0000, 0x683f,
+	0x0000, 0x0c20, 0x683a, 0x6836, 0x0cc0, 0x6a04, 0x9296, 0x0006,
+	0x0958, 0x0804, 0x8655, 0x6020, 0x9084, 0x000f, 0x000b, 0x0005,
+	0x86c7, 0x86cc, 0x8b2c, 0x8bbb, 0x86cc, 0x8b2c, 0x8bbb, 0x86c7,
+	0x86cc, 0x86c7, 0x86c7, 0x86c7, 0x86c7, 0x86c7, 0x86c7, 0x080c,
+	0x847d, 0x080c, 0x8582, 0x0005, 0x00b6, 0x0156, 0x0136, 0x0146,
+	0x01c6, 0x01d6, 0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2069, 0x0200,
+	0x2071, 0x0240, 0x6004, 0x908a, 0x0053, 0x1a0c, 0x0db2, 0x6110,
+	0x2158, 0xb9b0, 0x2c78, 0x2061, 0x0100, 0x619a, 0x908a, 0x0040,
+	0x1a04, 0x8738, 0x005b, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x01de,
+	0x01ce, 0x014e, 0x013e, 0x015e, 0x00be, 0x0005, 0x88af, 0x88ea,
+	0x8913, 0x89bb, 0x89dd, 0x89e3, 0x89f0, 0x89f8, 0x8a04, 0x8a0a,
+	0x8a1b, 0x8a0a, 0x8a73, 0x89f8, 0x8a7f, 0x8a85, 0x8a04, 0x8a85,
+	0x8a91, 0x8736, 0x8736, 0x8736, 0x8736, 0x8736, 0x8736, 0x8736,
+	0x8736, 0x8736, 0x8736, 0x8736, 0x910b, 0x912e, 0x913f, 0x915f,
+	0x9191, 0x89f0, 0x8736, 0x89f0, 0x8a0a, 0x8736, 0x8913, 0x89bb,
+	0x8736, 0x9556, 0x8a0a, 0x8736, 0x9572, 0x8a0a, 0x8736, 0x8a04,
+	0x88a9, 0x8759, 0x8736, 0x958e, 0x95fb, 0x96d2, 0x8736, 0x96df,
+	0x89ed, 0x970a, 0x8736, 0x919b, 0x9737, 0x8736, 0x080c, 0x0db2,
+	0x2100, 0x005b, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x01de, 0x01ce,
+	0x014e, 0x013e, 0x015e, 0x00be, 0x0005, 0x8757, 0x8757, 0x8757,
+	0x8780, 0x882c, 0x8837, 0x8757, 0x8757, 0x8757, 0x887e, 0x888a,
+	0x879b, 0x8757, 0x87b6, 0x87ea, 0x98b4, 0x98f9, 0x8a0a, 0x080c,
+	0x0db2, 0x00d6, 0x0096, 0x080c, 0x8aa4, 0x7003, 0x2414, 0x7007,
+	0x0018, 0x700b, 0x0800, 0x7814, 0x2048, 0xa83c, 0x700e, 0xa850,
+	0x7022, 0xa854, 0x7026, 0x60c3, 0x0018, 0x080c, 0x8f8f, 0x009e,
+	0x00de, 0x0005, 0x7810, 0x00b6, 0x2058, 0xb8a0, 0x00be, 0x080c,
+	0x9940, 0x1118, 0x9084, 0xff80, 0x0110, 0x9085, 0x0001, 0x0005,
+	0x00d6, 0x0096, 0x080c, 0x8aa4, 0x7003, 0x0500, 0x7814, 0x2048,
+	0xa874, 0x700a, 0xa878, 0x700e, 0xa87c, 0x7012, 0xa880, 0x7016,
+	0xa884, 0x701a, 0xa888, 0x701e, 0x60c3, 0x0010, 0x080c, 0x8f8f,
+	0x009e, 0x00de, 0x0005, 0x00d6, 0x0096, 0x080c, 0x8aa4, 0x7003,
+	0x0500, 0x7814, 0x2048, 0xa8cc, 0x700a, 0xa8d0, 0x700e, 0xa8d4,
+	0x7012, 0xa8d8, 0x7016, 0xa8dc, 0x701a, 0xa8e0, 0x701e, 0x60c3,
+	0x0010, 0x080c, 0x8f8f, 0x009e, 0x00de, 0x0005, 0x00d6, 0x0096,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x8aa4, 0x20e9, 0x0000, 0x2001,
+	0x1972, 0x2003, 0x0000, 0x7814, 0x2048, 0xa814, 0x8003, 0x60c2,
+	0xa830, 0x20a8, 0xa860, 0x20e0, 0xa85c, 0x9080, 0x001b, 0x2098,
+	0x2001, 0x1972, 0x0016, 0x200c, 0x2001, 0x0001, 0x080c, 0x20be,
+	0x080c, 0xc2e6, 0x9006, 0x080c, 0x20be, 0x001e, 0xa804, 0x9005,
+	0x0110, 0x2048, 0x0c28, 0x04d9, 0x080c, 0x8f8f, 0x012e, 0x009e,
+	0x00de, 0x0005, 0x00d6, 0x0096, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x8aef, 0x20e9, 0x0000, 0x2001, 0x1972, 0x2003, 0x0000, 0x7814,
+	0x2048, 0xa86f, 0x0200, 0xa873, 0x0000, 0xa814, 0x8003, 0x60c2,
+	0xa830, 0x20a8, 0xa860, 0x20e0, 0xa85c, 0x9080, 0x001b, 0x2098,
+	0x2001, 0x1972, 0x0016, 0x200c, 0x080c, 0xc2e6, 0x001e, 0xa804,
+	0x9005, 0x0110, 0x2048, 0x0c60, 0x0051, 0x7814, 0x2048, 0x080c,
+	0x0f87, 0x080c, 0x8f8f, 0x012e, 0x009e, 0x00de, 0x0005, 0x60c0,
+	0x8004, 0x9084, 0x0003, 0x9005, 0x0130, 0x9082, 0x0004, 0x20a3,
+	0x0000, 0x8000, 0x1de0, 0x0005, 0x080c, 0x8aa4, 0x7003, 0x7800,
+	0x7808, 0x8007, 0x700a, 0x60c3, 0x0008, 0x0804, 0x8f8f, 0x00d6,
+	0x00e6, 0x080c, 0x8aef, 0x7814, 0x9084, 0xff00, 0x2073, 0x0200,
+	0x8e70, 0x8e70, 0x9095, 0x0010, 0x2272, 0x8e70, 0x2073, 0x0034,
+	0x8e70, 0x2069, 0x1805, 0x20a9, 0x0004, 0x2d76, 0x8d68, 0x8e70,
+	0x1f04, 0x884d, 0x2069, 0x1801, 0x20a9, 0x0004, 0x2d76, 0x8d68,
+	0x8e70, 0x1f04, 0x8856, 0x2069, 0x1982, 0x9086, 0xdf00, 0x0110,
+	0x2069, 0x199c, 0x20a9, 0x001a, 0x9e86, 0x0260, 0x1148, 0x00c6,
+	0x2061, 0x0200, 0x6010, 0x8000, 0x6012, 0x00ce, 0x2071, 0x0240,
+	0x2d04, 0x8007, 0x2072, 0x8d68, 0x8e70, 0x1f04, 0x8864, 0x60c3,
+	0x004c, 0x080c, 0x8f8f, 0x00ee, 0x00de, 0x0005, 0x080c, 0x8aa4,
+	0x7003, 0x6300, 0x7007, 0x0028, 0x7808, 0x700e, 0x60c3, 0x0008,
+	0x0804, 0x8f8f, 0x00d6, 0x0026, 0x0016, 0x080c, 0x8aef, 0x7003,
+	0x0200, 0x7814, 0x700e, 0x00e6, 0x9ef0, 0x0004, 0x2009, 0x0001,
+	0x2011, 0x000c, 0x2073, 0x0800, 0x8e70, 0x2073, 0x0000, 0x00ee,
+	0x7206, 0x710a, 0x62c2, 0x080c, 0x8f8f, 0x001e, 0x002e, 0x00de,
+	0x0005, 0x2001, 0x1816, 0x2004, 0x609a, 0x0804, 0x8f8f, 0x080c,
+	0x8aa4, 0x7003, 0x5200, 0x2069, 0x1853, 0x6804, 0xd084, 0x0130,
+	0x6828, 0x0016, 0x080c, 0x2509, 0x710e, 0x001e, 0x20a9, 0x0004,
+	0x20e1, 0x0001, 0x2099, 0x1805, 0x20e9, 0x0000, 0x20a1, 0x0250,
+	0x4003, 0x20a9, 0x0004, 0x2099, 0x1801, 0x20a1, 0x0254, 0x4003,
+	0x080c, 0x9940, 0x1120, 0xb8a0, 0x9082, 0x007f, 0x0248, 0x2001,
+	0x181d, 0x2004, 0x7032, 0x2001, 0x181e, 0x2004, 0x7036, 0x0030,
+	0x2001, 0x1816, 0x2004, 0x9084, 0x00ff, 0x7036, 0x60c3, 0x001c,
+	0x0804, 0x8f8f, 0x080c, 0x8aa4, 0x7003, 0x0500, 0x080c, 0x9940,
+	0x1120, 0xb8a0, 0x9082, 0x007f, 0x0248, 0x2001, 0x181d, 0x2004,
+	0x700a, 0x2001, 0x181e, 0x2004, 0x700e, 0x0030, 0x2001, 0x1816,
+	0x2004, 0x9084, 0x00ff, 0x700e, 0x20a9, 0x0004, 0x20e1, 0x0001,
+	0x2099, 0x1805, 0x20e9, 0x0000, 0x20a1, 0x0250, 0x4003, 0x60c3,
+	0x0010, 0x0804, 0x8f8f, 0x080c, 0x8aa4, 0x9006, 0x080c, 0x626e,
+	0xb8a0, 0x9086, 0x007e, 0x1130, 0x7003, 0x0400, 0x620c, 0xc2b4,
+	0x620e, 0x0058, 0x7814, 0x0096, 0x904d, 0x0120, 0x9006, 0xa89a,
+	0xa8a6, 0xa8aa, 0x009e, 0x7003, 0x0300, 0xb8a0, 0x9086, 0x007e,
+	0x1904, 0x8982, 0x00d6, 0x2069, 0x193d, 0x2001, 0x1835, 0x2004,
+	0xd0a4, 0x0188, 0x6800, 0x700a, 0x6808, 0x9084, 0x2000, 0x7012,
+	0x080c, 0x9957, 0x680c, 0x7016, 0x701f, 0x2710, 0x6818, 0x7022,
+	0x681c, 0x7026, 0x0090, 0x6800, 0x700a, 0x6804, 0x700e, 0x6808,
+	0x080c, 0x6c53, 0x1118, 0x9084, 0x37ff, 0x0010, 0x9084, 0x3fff,
+	0x7012, 0x080c, 0x9957, 0x680c, 0x7016, 0x00de, 0x20a9, 0x0004,
+	0x20e1, 0x0001, 0x2099, 0x1805, 0x20e9, 0x0000, 0x20a1, 0x0256,
+	0x4003, 0x20a9, 0x0004, 0x2099, 0x1801, 0x20a1, 0x025a, 0x4003,
+	0x00d6, 0x080c, 0x97b9, 0x2069, 0x1945, 0x2071, 0x024e, 0x6800,
+	0xc0dd, 0x7002, 0x080c, 0x5117, 0xd0e4, 0x0110, 0x680c, 0x700e,
+	0x00de, 0x04a8, 0x2001, 0x1835, 0x2004, 0xd0a4, 0x0170, 0x0016,
+	0x2001, 0x193e, 0x200c, 0x60e0, 0x9106, 0x0130, 0x2100, 0x60e3,
+	0x0000, 0x080c, 0x254a, 0x61e2, 0x001e, 0x20e1, 0x0001, 0x2099,
+	0x193d, 0x20e9, 0x0000, 0x20a1, 0x024e, 0x20a9, 0x0008, 0x4003,
+	0x20a9, 0x0004, 0x2099, 0x1805, 0x20a1, 0x0256, 0x4003, 0x20a9,
+	0x0004, 0x2099, 0x1801, 0x20a1, 0x025a, 0x4003, 0x080c, 0x97b9,
+	0x20a1, 0x024e, 0x20a9, 0x0008, 0x2099, 0x1945, 0x4003, 0x60c3,
+	0x0074, 0x0804, 0x8f8f, 0x080c, 0x8aa4, 0x7003, 0x2010, 0x7007,
+	0x0014, 0x700b, 0x0800, 0x700f, 0x2000, 0x9006, 0x00f6, 0x2079,
+	0x1853, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0x9085, 0x0020, 0xd1a4,
+	0x0110, 0x9085, 0x0010, 0x9085, 0x0002, 0x00d6, 0x0804, 0x8a54,
+	0x7026, 0x60c3, 0x0014, 0x0804, 0x8f8f, 0x080c, 0x8aa4, 0x7003,
+	0x5000, 0x0804, 0x892d, 0x080c, 0x8aa4, 0x7003, 0x2110, 0x7007,
+	0x0014, 0x60c3, 0x0014, 0x0804, 0x8f8f, 0x080c, 0x8ae6, 0x0010,
+	0x080c, 0x8aef, 0x7003, 0x0200, 0x60c3, 0x0004, 0x0804, 0x8f8f,
+	0x080c, 0x8aef, 0x7003, 0x0100, 0x700b, 0x0003, 0x700f, 0x2a00,
+	0x60c3, 0x0008, 0x0804, 0x8f8f, 0x080c, 0x8aef, 0x7003, 0x0200,
+	0x0804, 0x892d, 0x080c, 0x8aef, 0x7003, 0x0100, 0x782c, 0x9005,
+	0x0110, 0x700a, 0x0010, 0x700b, 0x0003, 0x7814, 0x700e, 0x60c3,
+	0x0008, 0x0804, 0x8f8f, 0x00d6, 0x080c, 0x8aef, 0x7003, 0x0210,
+	0x7007, 0x0014, 0x700b, 0x0800, 0xb894, 0x9086, 0x0014, 0x1198,
+	0xb99c, 0x9184, 0x0030, 0x0190, 0xb998, 0x9184, 0xc000, 0x1140,
+	0xd1ec, 0x0118, 0x700f, 0x2100, 0x0058, 0x700f, 0x0100, 0x0040,
+	0x700f, 0x0400, 0x0028, 0x700f, 0x0700, 0x0010, 0x700f, 0x0800,
+	0x00f6, 0x2079, 0x1853, 0x7904, 0x00fe, 0xd1ac, 0x1110, 0x9085,
+	0x0020, 0xd1a4, 0x0110, 0x9085, 0x0010, 0x2009, 0x1875, 0x210c,
+	0xd184, 0x1110, 0x9085, 0x0002, 0x0026, 0x2009, 0x1873, 0x210c,
+	0xd1e4, 0x0150, 0xc0c5, 0xbabc, 0xd28c, 0x1108, 0xc0cd, 0x9094,
+	0x0030, 0x9296, 0x0010, 0x0140, 0xd1ec, 0x0130, 0x9094, 0x0030,
+	0x9296, 0x0010, 0x0108, 0xc0bd, 0x002e, 0x7026, 0x60c3, 0x0014,
+	0x00de, 0x0804, 0x8f8f, 0x080c, 0x8aef, 0x7003, 0x0210, 0x7007,
+	0x0014, 0x700f, 0x0100, 0x60c3, 0x0014, 0x0804, 0x8f8f, 0x080c,
+	0x8aef, 0x7003, 0x0200, 0x0804, 0x88b3, 0x080c, 0x8aef, 0x7003,
+	0x0100, 0x700b, 0x0003, 0x700f, 0x2a00, 0x60c3, 0x0008, 0x0804,
+	0x8f8f, 0x080c, 0x8aef, 0x7003, 0x0100, 0x700b, 0x000b, 0x60c3,
+	0x0008, 0x0804, 0x8f8f, 0x0026, 0x00d6, 0x0036, 0x0046, 0x2019,
+	0x3200, 0x2021, 0x0800, 0x0040, 0x0026, 0x00d6, 0x0036, 0x0046,
+	0x2019, 0x2200, 0x2021, 0x0100, 0x080c, 0x97ce, 0xb810, 0x9305,
+	0x7002, 0xb814, 0x7006, 0x2069, 0x1800, 0x6874, 0x700a, 0x6878,
+	0x700e, 0x9485, 0x0029, 0x7012, 0x004e, 0x003e, 0x00de, 0x080c,
+	0x8f7d, 0x721a, 0x9f95, 0x0000, 0x7222, 0x7027, 0xffff, 0x2071,
+	0x024c, 0x002e, 0x0005, 0x0026, 0x080c, 0x97ce, 0x7003, 0x02ff,
+	0x7007, 0xfffc, 0x00d6, 0x2069, 0x1800, 0x6874, 0x700a, 0x6878,
+	0x700e, 0x00de, 0x7013, 0x2029, 0x0c10, 0x7003, 0x0100, 0x7007,
+	0x0000, 0x700b, 0xfc02, 0x700f, 0x0000, 0x0005, 0x0026, 0x00d6,
+	0x0036, 0x0046, 0x2019, 0x3300, 0x2021, 0x0800, 0x0040, 0x0026,
+	0x00d6, 0x0036, 0x0046, 0x2019, 0x2300, 0x2021, 0x0100, 0x080c,
+	0x97ce, 0xb810, 0x9305, 0x7002, 0xb814, 0x7006, 0x2069, 0x1800,
+	0xb810, 0x9005, 0x1140, 0xb814, 0x9005, 0x1128, 0x700b, 0x00ff,
+	0x700f, 0xfffe, 0x0020, 0x6874, 0x700a, 0x6878, 0x700e, 0x0000,
+	0x9485, 0x0098, 0x7012, 0x004e, 0x003e, 0x00de, 0x080c, 0x8f7d,
+	0x721a, 0x7a08, 0x7222, 0x2f10, 0x7226, 0x2071, 0x024c, 0x002e,
+	0x0005, 0x080c, 0x8f7d, 0x721a, 0x7a08, 0x7222, 0x7814, 0x7026,
+	0x2071, 0x024c, 0x002e, 0x0005, 0x00b6, 0x00c6, 0x00d6, 0x00e6,
+	0x00f6, 0x2069, 0x0200, 0x2071, 0x0240, 0x6004, 0x908a, 0x0085,
+	0x0a0c, 0x0db2, 0x908a, 0x0092, 0x1a0c, 0x0db2, 0x6110, 0x2158,
+	0xb9b0, 0x2c78, 0x2061, 0x0100, 0x619a, 0x9082, 0x0085, 0x0033,
+	0x00fe, 0x00ee, 0x00de, 0x00ce, 0x00be, 0x0005, 0x8b5d, 0x8b6c,
+	0x8b77, 0x8b5b, 0x8b5b, 0x8b5b, 0x8b5d, 0x8b5b, 0x8b5b, 0x8b5b,
+	0x8b5b, 0x8b5b, 0x8b5b, 0x080c, 0x0db2, 0x0411, 0x60c3, 0x0000,
+	0x0026, 0x080c, 0x283d, 0x0228, 0x2011, 0x0101, 0x2204, 0xc0c5,
+	0x2012, 0x002e, 0x0804, 0x8f8f, 0x0431, 0x7808, 0x700a, 0x7814,
+	0x700e, 0x7017, 0xffff, 0x60c3, 0x000c, 0x0804, 0x8f8f, 0x0479,
+	0x7003, 0x0003, 0x7007, 0x0300, 0x60c3, 0x0004, 0x0804, 0x8f8f,
+	0x0026, 0x080c, 0x97ce, 0xb810, 0x9085, 0x8100, 0x7002, 0xb814,
+	0x7006, 0x2069, 0x1800, 0x6874, 0x700a, 0x6878, 0x700e, 0x7013,
+	0x0009, 0x0804, 0x8abf, 0x0026, 0x080c, 0x97ce, 0xb810, 0x9085,
+	0x8400, 0x7002, 0xb814, 0x7006, 0x2069, 0x1800, 0x6874, 0x700a,
+	0x6878, 0x700e, 0x2001, 0x0099, 0x7012, 0x0804, 0x8b21, 0x0026,
+	0x080c, 0x97ce, 0xb810, 0x9085, 0x8500, 0x7002, 0xb814, 0x7006,
+	0x2069, 0x1800, 0x6874, 0x700a, 0x6878, 0x700e, 0x2001, 0x0099,
+	0x7012, 0x0804, 0x8b21, 0x00b6, 0x00c6, 0x00d6, 0x00e6, 0x00f6,
+	0x2c78, 0x2069, 0x0200, 0x2071, 0x0240, 0x7804, 0x908a, 0x0040,
+	0x0a0c, 0x0db2, 0x908a, 0x0054, 0x1a0c, 0x0db2, 0x7910, 0x2158,
+	0xb9b0, 0x2061, 0x0100, 0x619a, 0x9082, 0x0040, 0x0033, 0x00fe,
+	0x00ee, 0x00de, 0x00ce, 0x00be, 0x0005, 0x8bf2, 0x8c99, 0x8c6c,
+	0x8dbb, 0x8bf0, 0x8bf0, 0x8bf0, 0x8bf0, 0x8bf0, 0x8bf0, 0x8bf0,
+	0x930c, 0x9318, 0x9324, 0x9330, 0x8bf0, 0x9716, 0x8bf0, 0x9300,
+	0x080c, 0x0db2, 0x0096, 0x780b, 0xffff, 0x080c, 0x8c48, 0x7914,
+	0x2148, 0xa978, 0x7956, 0x7132, 0xa97c, 0x9184, 0x000f, 0x1118,
+	0x2001, 0x0005, 0x0040, 0xd184, 0x0118, 0x2001, 0x0004, 0x0018,
+	0x9084, 0x0006, 0x8004, 0x2010, 0x785c, 0x9084, 0x00ff, 0x8007,
+	0x9205, 0x7042, 0xd1ac, 0x0128, 0x7047, 0x0002, 0x080c, 0x1582,
+	0x0050, 0xd1b4, 0x0118, 0x7047, 0x0001, 0x0028, 0x7047, 0x0000,
+	0x9016, 0x2230, 0x0010, 0xaab0, 0xaeac, 0x726a, 0x766e, 0x20a9,
+	0x0008, 0x20e9, 0x0000, 0xa860, 0x20e0, 0xa85c, 0x9080, 0x0023,
+	0x2098, 0x20a1, 0x0252, 0x2069, 0x0200, 0x6813, 0x0018, 0x4003,
+	0x6813, 0x0008, 0x60c3, 0x0020, 0x6017, 0x0009, 0x2001, 0x19d2,
+	0x2003, 0x07d0, 0x2001, 0x19d1, 0x2003, 0x0009, 0x009e, 0x0005,
+	0x6813, 0x0008, 0xba8c, 0x8210, 0xb8bc, 0xd084, 0x0128, 0x7a46,
+	0x7b14, 0x7b4a, 0x722e, 0x732a, 0x9294, 0x00ff, 0xba8e, 0x8217,
+	0x721a, 0xba10, 0x9295, 0x0600, 0x7202, 0xba14, 0x7206, 0x2069,
+	0x1800, 0x6a74, 0x720a, 0x6a78, 0x720e, 0x7013, 0x0829, 0x2f10,
+	0x7222, 0x7027, 0xffff, 0x0005, 0x00d6, 0x0096, 0x0081, 0x7814,
+	0x2048, 0xa890, 0x7002, 0xa88c, 0x7006, 0xa8b0, 0x700a, 0xa8ac,
+	0x700e, 0x60c3, 0x000c, 0x009e, 0x00de, 0x0804, 0x8f8f, 0x6813,
+	0x0008, 0xb810, 0x9085, 0x0500, 0x7002, 0xb814, 0x7006, 0x2069,
+	0x1800, 0x6874, 0x700a, 0x6878, 0x700e, 0x7013, 0x0889, 0x080c,
+	0x8f7d, 0x721a, 0x7a08, 0x7222, 0x2f10, 0x7226, 0x2071, 0x024c,
+	0x0005, 0x00d6, 0x0096, 0x080c, 0x8d99, 0x7814, 0x2048, 0x080c,
+	0xb5f9, 0x1130, 0x7814, 0x9084, 0x0700, 0x8007, 0x0033, 0x0010,
+	0x9006, 0x001b, 0x009e, 0x00de, 0x0005, 0x8cb7, 0x8d20, 0x8d30,
+	0x8d56, 0x8d62, 0x8d73, 0x8d7b, 0x8cb5, 0x080c, 0x0db2, 0x0016,
+	0x0036, 0xa97c, 0x918c, 0x0003, 0x0118, 0x9186, 0x0003, 0x1198,
+	0xaba8, 0x7824, 0xd0cc, 0x1168, 0x7316, 0xa898, 0x701a, 0xa894,
+	0x701e, 0x003e, 0x001e, 0x2001, 0x1980, 0x2004, 0x60c2, 0x0804,
+	0x8f8f, 0xc3e5, 0x0c88, 0x9186, 0x0001, 0x190c, 0x0db2, 0xaba8,
+	0x7824, 0xd0cc, 0x1904, 0x8d1d, 0x7316, 0xa898, 0x701a, 0xa894,
+	0x701e, 0xa8a4, 0x7026, 0xa8ac, 0x702e, 0x2009, 0x0018, 0x9384,
+	0x0300, 0x0570, 0xd3c4, 0x0110, 0xa8ac, 0x9108, 0xd3cc, 0x0110,
+	0xa8a4, 0x9108, 0x6810, 0x9085, 0x0010, 0x6812, 0x2011, 0x0258,
+	0x20e9, 0x0000, 0x22a0, 0x0156, 0x20a9, 0x0008, 0xa860, 0x20e0,
+	0xa85c, 0x9080, 0x002c, 0x2098, 0x4003, 0x6810, 0x8000, 0x6812,
+	0x2011, 0x0240, 0x22a0, 0x20a9, 0x0005, 0x4003, 0x6810, 0xc084,
+	0x6812, 0x015e, 0x9184, 0x0003, 0x0118, 0x2019, 0x0245, 0x201a,
+	0x61c2, 0x003e, 0x001e, 0x0804, 0x8f8f, 0xc3e5, 0x0804, 0x8cdc,
+	0x2011, 0x0008, 0x2001, 0x180e, 0x2004, 0xd0a4, 0x0110, 0x2011,
+	0x0028, 0x7824, 0xd0cc, 0x1110, 0x7216, 0x0470, 0x0ce8, 0xc2e5,
+	0x2011, 0x0302, 0x0016, 0x782c, 0x701a, 0x7930, 0x711e, 0x9105,
+	0x0108, 0xc2dd, 0x001e, 0x7824, 0xd0cc, 0x0108, 0xc2e5, 0x7216,
+	0x7027, 0x0012, 0x702f, 0x0008, 0x7043, 0x7000, 0x7047, 0x0500,
+	0x704f, 0x000a, 0x2069, 0x0200, 0x6813, 0x0009, 0x2071, 0x0240,
+	0x700b, 0x2500, 0x60c3, 0x0032, 0x0804, 0x8f8f, 0x2011, 0x0028,
+	0x7824, 0xd0cc, 0x1128, 0x7216, 0x60c3, 0x0018, 0x0804, 0x8f8f,
+	0x0cd0, 0xc2e5, 0x2011, 0x0100, 0x7824, 0xd0cc, 0x0108, 0xc2e5,
+	0x7216, 0x702f, 0x0008, 0x7858, 0x9084, 0x00ff, 0x7036, 0x60c3,
+	0x0020, 0x0804, 0x8f8f, 0x2011, 0x0008, 0x7824, 0xd0cc, 0x0108,
+	0xc2e5, 0x7216, 0x0c08, 0x0036, 0x7b14, 0x9384, 0xff00, 0x7816,
+	0x9384, 0x00ff, 0x8001, 0x1138, 0x7824, 0xd0cc, 0x0108, 0xc2e5,
+	0x7216, 0x003e, 0x0888, 0x0046, 0x2021, 0x0800, 0x0006, 0x7824,
+	0xd0cc, 0x000e, 0x0108, 0xc4e5, 0x7416, 0x004e, 0x701e, 0x003e,
+	0x0818, 0x00d6, 0x6813, 0x0008, 0xb810, 0x9085, 0x0700, 0x7002,
+	0xb814, 0x7006, 0x2069, 0x1800, 0x6874, 0x700a, 0x6878, 0x700e,
+	0x7824, 0xd0cc, 0x1168, 0x7013, 0x0898, 0x080c, 0x8f7d, 0x721a,
+	0x7a08, 0x7222, 0x2f10, 0x7226, 0x2071, 0x024c, 0x00de, 0x0005,
+	0x7013, 0x0889, 0x0c90, 0x0016, 0x7814, 0x9084, 0x0700, 0x8007,
+	0x0013, 0x001e, 0x0005, 0x8dcb, 0x8dcb, 0x8dcd, 0x8dcb, 0x8dcb,
+	0x8dcb, 0x8de7, 0x8dcb, 0x080c, 0x0db2, 0x7914, 0x918c, 0x08ff,
+	0x918d, 0xf600, 0x7916, 0x2009, 0x0003, 0x00b9, 0x2069, 0x1853,
+	0x6804, 0xd0bc, 0x0130, 0x682c, 0x9084, 0x00ff, 0x8007, 0x7032,
+	0x0010, 0x7033, 0x3f00, 0x60c3, 0x0001, 0x0804, 0x8f8f, 0x2009,
+	0x0003, 0x0019, 0x7033, 0x7f00, 0x0cb0, 0x0016, 0x080c, 0x97ce,
+	0x001e, 0xb810, 0x9085, 0x0100, 0x7002, 0xb814, 0x7006, 0x2069,
+	0x1800, 0x6a74, 0x720a, 0x6a78, 0x720e, 0x7013, 0x0888, 0x918d,
+	0x0008, 0x7116, 0x080c, 0x8f7d, 0x721a, 0x7a08, 0x7222, 0x2f10,
+	0x7226, 0x0005, 0x00b6, 0x0096, 0x00e6, 0x00d6, 0x00c6, 0x0056,
+	0x0046, 0x0036, 0x2061, 0x0100, 0x2071, 0x1800, 0x7810, 0x2058,
+	0xb8a0, 0x2028, 0xb910, 0xba14, 0x7374, 0x7478, 0x7820, 0x90be,
+	0x0006, 0x0904, 0x8eec, 0x90be, 0x000a, 0x1904, 0x8ea8, 0x609f,
+	0x0000, 0x7814, 0x2048, 0xa87c, 0xd0fc, 0x05c8, 0xaf90, 0x9784,
+	0xff00, 0x9105, 0x6062, 0x873f, 0x9784, 0xff00, 0x0006, 0x7814,
+	0x2048, 0xa878, 0x9005, 0x000e, 0x1160, 0xaf94, 0x87ff, 0x0510,
+	0x2039, 0x0098, 0x9705, 0x6072, 0x7808, 0x6082, 0x2f00, 0x6086,
+	0x0038, 0x9185, 0x2200, 0x6062, 0x6073, 0x0129, 0x6077, 0x0000,
+	0x609f, 0x0000, 0x2001, 0x1835, 0x2004, 0xd0ac, 0x11a8, 0xd09c,
+	0x0130, 0x7814, 0x2048, 0xa874, 0x9082, 0x0080, 0x1268, 0xb814,
+	0x609e, 0x0050, 0x2039, 0x0029, 0x9705, 0x6072, 0x0c48, 0x9185,
+	0x0200, 0x6062, 0x6073, 0x2029, 0xa87c, 0xd0fc, 0x0118, 0xaf94,
+	0x87ff, 0x1120, 0x2f00, 0x6082, 0x7808, 0x6086, 0x6266, 0x636a,
+	0x646e, 0x6077, 0x0000, 0xb88c, 0x8000, 0x9084, 0x00ff, 0xb88e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0xa838, 0x608a, 0xa834, 0x608e,
+	0xa848, 0x60c6, 0xa844, 0x60ca, 0xb86c, 0x60ce, 0x60af, 0x95d5,
+	0x60d7, 0x0000, 0x080c, 0x97b3, 0x2009, 0x07d0, 0x60c4, 0x9084,
+	0xfff0, 0x9005, 0x0110, 0x2009, 0x1b58, 0x080c, 0x7ccc, 0x003e,
+	0x004e, 0x005e, 0x00ce, 0x00de, 0x00ee, 0x009e, 0x00be, 0x0005,
+	0x7804, 0x9086, 0x0040, 0x0904, 0x8f28, 0x9185, 0x0100, 0x6062,
+	0x6266, 0x636a, 0x646e, 0x6073, 0x0809, 0x6077, 0x0008, 0x60af,
+	0x95d5, 0x60d7, 0x0000, 0xb88c, 0x8000, 0x9084, 0x00ff, 0xb88e,
+	0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6082, 0x7808, 0x6086,
+	0x7814, 0x2048, 0xa838, 0x608a, 0xa834, 0x608e, 0xa848, 0x60c6,
+	0xa844, 0x60ca, 0xb86c, 0x60ce, 0xbab0, 0x629e, 0x080c, 0x97b3,
+	0x2009, 0x07d0, 0x60c4, 0x9084, 0xfff0, 0x9005, 0x0110, 0x2009,
+	0x1b58, 0x080c, 0x7ccc, 0x003e, 0x004e, 0x005e, 0x00ce, 0x00de,
+	0x00ee, 0x009e, 0x00be, 0x0005, 0x7814, 0x2048, 0xa87c, 0x9084,
+	0x0003, 0x9086, 0x0002, 0x0904, 0x8f44, 0x9185, 0x0100, 0x6062,
+	0x6266, 0x636a, 0x646e, 0x6073, 0x0880, 0x6077, 0x0008, 0xb88c,
+	0x8000, 0x9084, 0x00ff, 0xb88e, 0x8007, 0x607a, 0x7838, 0x607e,
+	0x2f00, 0x6086, 0x7808, 0x6082, 0xa890, 0x608a, 0xa88c, 0x608e,
+	0xa8b0, 0x60c6, 0xa8ac, 0x60ca, 0xa8ac, 0x7930, 0x9108, 0x7932,
+	0xa8b0, 0x792c, 0x9109, 0x792e, 0xb86c, 0x60ce, 0x60af, 0x95d5,
+	0x60d7, 0x0000, 0xbab0, 0x629e, 0x080c, 0x9790, 0x0804, 0x8ed8,
+	0xb8bc, 0xd084, 0x0148, 0xb88c, 0x7814, 0x2048, 0xb88c, 0x7846,
+	0xa836, 0x2900, 0xa83a, 0xb04a, 0x9185, 0x0600, 0x6062, 0x6266,
+	0x636a, 0x646e, 0x6073, 0x0829, 0x6077, 0x0000, 0x60af, 0x9575,
+	0x60d7, 0x0000, 0x0804, 0x8ebb, 0x9185, 0x0700, 0x6062, 0x6266,
+	0x636a, 0x646e, 0x7824, 0xd0cc, 0x7826, 0x0118, 0x6073, 0x0889,
+	0x0010, 0x6073, 0x0898, 0x6077, 0x0000, 0xb88c, 0x8000, 0x9084,
+	0x00ff, 0xb88e, 0x8007, 0x607a, 0x607f, 0x0000, 0x2f00, 0x6086,
+	0x7808, 0x6082, 0xa838, 0x608a, 0xa834, 0x608e, 0xa848, 0x60c6,
+	0xa844, 0x60ca, 0xb86c, 0x60ce, 0x60af, 0x95d5, 0x60d7, 0x0000,
+	0xbab0, 0x629e, 0x7824, 0xd0cc, 0x0120, 0x080c, 0x97b3, 0x0804,
+	0x8ed8, 0x080c, 0x9790, 0x0804, 0x8ed8, 0x7a10, 0x00b6, 0x2258,
+	0xba8c, 0x8210, 0x9294, 0x00ff, 0xba8e, 0x00be, 0x8217, 0x0005,
+	0x00d6, 0x2069, 0x19b6, 0x6843, 0x0001, 0x00de, 0x0005, 0x60a3,
+	0x0056, 0x60a7, 0x9575, 0x00f1, 0x080c, 0x7cbe, 0x0005, 0x0016,
+	0x2001, 0x180c, 0x200c, 0x9184, 0x0600, 0x9086, 0x0600, 0x0128,
+	0x0089, 0x080c, 0x7cbe, 0x001e, 0x0005, 0xc1e5, 0x2001, 0x180c,
+	0x2102, 0x2001, 0x19b7, 0x2003, 0x0000, 0x2001, 0x19bf, 0x2003,
+	0x0000, 0x0c88, 0x0006, 0x6014, 0x9084, 0x1804, 0x9085, 0x0009,
+	0x6016, 0x000e, 0x0005, 0x0016, 0x00c6, 0x0006, 0x2061, 0x0100,
+	0x61a4, 0x60a7, 0x95f5, 0x6014, 0x9084, 0x1804, 0x9085, 0x0008,
+	0x6016, 0x000e, 0xa001, 0xa001, 0xa001, 0x61a6, 0x00ce, 0x001e,
+	0x0005, 0x00c6, 0x00d6, 0x0016, 0x0026, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x6c53, 0x11e8, 0x2001, 0x19d2, 0x2004, 0x9005,
+	0x1904, 0x9021, 0x0066, 0x2031, 0x0001, 0x080c, 0x6d03, 0x006e,
+	0x1160, 0x2061, 0x0100, 0x6020, 0xd0b4, 0x1120, 0x6024, 0xd084,
+	0x090c, 0x0db2, 0x080c, 0x7cbe, 0x0460, 0x00c6, 0x2061, 0x19b6,
+	0x00d0, 0x6904, 0x9194, 0x4000, 0x0548, 0x080c, 0x8fbb, 0x080c,
+	0x2997, 0x00c6, 0x2061, 0x19b6, 0x6128, 0x9192, 0x0008, 0x1258,
+	0x8108, 0x612a, 0x6124, 0x00ce, 0x81ff, 0x0198, 0x080c, 0x7cbe,
+	0x080c, 0x8fb2, 0x0070, 0x6124, 0x91e5, 0x0000, 0x0140, 0x080c,
+	0xd358, 0x080c, 0x7cc7, 0x2009, 0x0014, 0x080c, 0x9a50, 0x00ce,
+	0x0000, 0x002e, 0x001e, 0x00de, 0x00ce, 0x0005, 0x2001, 0x19d2,
+	0x2004, 0x9005, 0x1db0, 0x00c6, 0x2061, 0x19b6, 0x6128, 0x9192,
+	0x0003, 0x1e08, 0x8108, 0x612a, 0x00ce, 0x080c, 0x7cbe, 0x080c,
+	0x58e0, 0x2009, 0x1852, 0x2114, 0x8210, 0x220a, 0x0c10, 0x0096,
+	0x00c6, 0x00d6, 0x00e6, 0x0016, 0x0026, 0x080c, 0x7cd4, 0x2071,
+	0x19b6, 0x713c, 0x81ff, 0x0904, 0x90ad, 0x2061, 0x0100, 0x2069,
+	0x0140, 0x080c, 0x6c53, 0x11b0, 0x0036, 0x2019, 0x0002, 0x080c,
+	0x9254, 0x003e, 0x713c, 0x2160, 0x080c, 0xd358, 0x2009, 0x004a,
+	0x080c, 0x9a50, 0x0066, 0x2031, 0x0001, 0x080c, 0x6d03, 0x006e,
+	0x0804, 0x90ad, 0x6904, 0xd1f4, 0x0904, 0x90b4, 0x080c, 0x2997,
+	0x00c6, 0x703c, 0x9065, 0x090c, 0x0db2, 0x6020, 0x00ce, 0x9086,
+	0x0006, 0x1528, 0x61c8, 0x60c4, 0x9105, 0x1508, 0x2009, 0x180c,
+	0x2104, 0xd0d4, 0x01e0, 0x6214, 0x9294, 0x1800, 0x1128, 0x6224,
+	0x9294, 0x0002, 0x1510, 0x0030, 0xc0d4, 0x200a, 0xd0cc, 0x0110,
+	0x080c, 0x28ea, 0x6014, 0x9084, 0xe7fd, 0x9085, 0x0010, 0x6016,
+	0x703c, 0x2060, 0x2009, 0x0049, 0x080c, 0x9a50, 0x0070, 0x0036,
+	0x2019, 0x0001, 0x080c, 0x9254, 0x003e, 0x713c, 0x2160, 0x080c,
+	0xd358, 0x2009, 0x004a, 0x080c, 0x9a50, 0x002e, 0x001e, 0x00ee,
+	0x00de, 0x00ce, 0x009e, 0x0005, 0xd1ec, 0x1904, 0x906e, 0x0804,
+	0x9070, 0x0026, 0x00e6, 0x2071, 0x19b6, 0x7048, 0xd084, 0x01c0,
+	0x713c, 0x81ff, 0x01a8, 0x2071, 0x0100, 0x9188, 0x0008, 0x2114,
+	0x928e, 0x0006, 0x1138, 0x7014, 0x9084, 0x1984, 0x9085, 0x0012,
+	0x7016, 0x0030, 0x7014, 0x9084, 0x1984, 0x9085, 0x0016, 0x7016,
+	0x00ee, 0x002e, 0x0005, 0x00b6, 0x00e6, 0x00d6, 0x00c6, 0x0066,
+	0x0056, 0x0046, 0x0006, 0x0126, 0x2091, 0x8000, 0x6010, 0x2058,
+	0xbca0, 0x2071, 0x19b6, 0x7018, 0x2058, 0x8bff, 0x0190, 0xb8a0,
+	0x9406, 0x0118, 0xb854, 0x2058, 0x0cc0, 0x6014, 0x0096, 0x2048,
+	0xac6c, 0xad70, 0xae78, 0x009e, 0x080c, 0x60b0, 0x0110, 0x9085,
+	0x0001, 0x012e, 0x000e, 0x004e, 0x005e, 0x006e, 0x00ce, 0x00de,
+	0x00ee, 0x00be, 0x0005, 0x080c, 0x8aa4, 0x7003, 0x1200, 0x7838,
+	0x7012, 0x783c, 0x7016, 0x00c6, 0x7820, 0x9086, 0x0004, 0x1148,
+	0x7810, 0x9005, 0x0130, 0x00b6, 0x2058, 0xb810, 0xb914, 0x00be,
+	0x0020, 0x2061, 0x1800, 0x6074, 0x6178, 0x9084, 0x00ff, 0x700a,
+	0x710e, 0x00ce, 0x60c3, 0x002c, 0x0804, 0x8f8f, 0x080c, 0x8aa4,
+	0x7003, 0x0f00, 0x7808, 0xd09c, 0x0128, 0xb810, 0x9084, 0x00ff,
+	0x700a, 0xb814, 0x700e, 0x60c3, 0x0008, 0x0804, 0x8f8f, 0x0156,
+	0x080c, 0x8aef, 0x7003, 0x0200, 0x2011, 0x1848, 0x63f0, 0x2312,
+	0x20a9, 0x0006, 0x2011, 0x1840, 0x2019, 0x1841, 0x9ef0, 0x0002,
+	0x2376, 0x8e70, 0x2276, 0x8e70, 0x9398, 0x0002, 0x9290, 0x0002,
+	0x1f04, 0x9150, 0x60c3, 0x001c, 0x015e, 0x0804, 0x8f8f, 0x0016,
+	0x0026, 0x080c, 0x8acb, 0x080c, 0x8add, 0x9e80, 0x0004, 0x20e9,
+	0x0000, 0x20a0, 0x7814, 0x0096, 0x2048, 0xa800, 0x2048, 0xa860,
+	0x20e0, 0xa85c, 0x9080, 0x0021, 0x2098, 0x009e, 0x7808, 0x9088,
+	0x0002, 0x21a8, 0x9192, 0x0010, 0x1250, 0x4003, 0x9080, 0x0004,
+	0x8003, 0x60c2, 0x080c, 0x8f8f, 0x002e, 0x001e, 0x0005, 0x20a9,
+	0x0010, 0x4003, 0x080c, 0x97b9, 0x20a1, 0x0240, 0x22a8, 0x4003,
+	0x0c68, 0x080c, 0x8aa4, 0x7003, 0x6200, 0x7808, 0x700e, 0x60c3,
+	0x0008, 0x0804, 0x8f8f, 0x0016, 0x0026, 0x080c, 0x8aa4, 0x20e9,
+	0x0000, 0x20a1, 0x024c, 0x7814, 0x0096, 0x2048, 0xa800, 0x2048,
+	0xa860, 0x20e0, 0xa85c, 0x9080, 0x0023, 0x2098, 0x009e, 0x7808,
+	0x9088, 0x0002, 0x21a8, 0x4003, 0x8003, 0x60c2, 0x080c, 0x8f8f,
+	0x002e, 0x001e, 0x0005, 0x00e6, 0x00c6, 0x0006, 0x0126, 0x2091,
+	0x8000, 0x2071, 0x19b6, 0x700c, 0x2060, 0x8cff, 0x0178, 0x080c,
+	0xb7fa, 0x1110, 0x080c, 0xa364, 0x600c, 0x0006, 0x080c, 0xba61,
+	0x080c, 0x99d6, 0x080c, 0x933f, 0x00ce, 0x0c78, 0x2c00, 0x700e,
+	0x700a, 0x012e, 0x000e, 0x00ce, 0x00ee, 0x0005, 0x0126, 0x0156,
+	0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0066, 0x0026, 0x0016, 0x0006,
+	0x2091, 0x8000, 0x2001, 0x180c, 0x200c, 0x918c, 0xe7ff, 0x2102,
+	0x2069, 0x0100, 0x2079, 0x0140, 0x2071, 0x19b6, 0x7024, 0x2060,
+	0x8cff, 0x01f8, 0x080c, 0x8fbb, 0x6ac0, 0x68c3, 0x0000, 0x080c,
+	0x7cc7, 0x00c6, 0x2061, 0x0100, 0x080c, 0x97d2, 0x00ce, 0x20a9,
+	0x01f4, 0x0461, 0x2009, 0x0013, 0x080c, 0x9a50, 0x000e, 0x001e,
+	0x002e, 0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x015e, 0x012e,
+	0x0005, 0x2001, 0x1800, 0x2004, 0x9096, 0x0001, 0x0d78, 0x9096,
+	0x0004, 0x0d60, 0x080c, 0x7cc7, 0x6814, 0x9084, 0x0001, 0x0110,
+	0x68a7, 0x95f5, 0x6817, 0x0008, 0x68c3, 0x0000, 0x2011, 0x588a,
+	0x080c, 0x7c4a, 0x20a9, 0x01f4, 0x0009, 0x08c0, 0x6824, 0xd094,
+	0x0140, 0x6827, 0x0004, 0x7804, 0x9084, 0x4000, 0x190c, 0x2997,
+	0x0090, 0xd084, 0x0118, 0x6827, 0x0001, 0x0010, 0x1f04, 0x9236,
+	0x7804, 0x9084, 0x1000, 0x0138, 0x2001, 0x0100, 0x080c, 0x2987,
+	0x9006, 0x080c, 0x2987, 0x0005, 0x0126, 0x0156, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0066, 0x0026, 0x0016, 0x0006, 0x2091, 0x8000,
+	0x2001, 0x180c, 0x200c, 0x918c, 0xdbff, 0x2102, 0x2069, 0x0100,
+	0x2079, 0x0140, 0x2071, 0x19b6, 0x703c, 0x2060, 0x8cff, 0x0904,
+	0x92e1, 0x9386, 0x0002, 0x1128, 0x6814, 0x9084, 0x0002, 0x0904,
+	0x92e1, 0x68af, 0x95f5, 0x6817, 0x0010, 0x2009, 0x00fa, 0x8109,
+	0x1df0, 0x69c6, 0x68cb, 0x0008, 0x080c, 0x7cd4, 0x080c, 0x1d14,
+	0x0046, 0x2009, 0x017f, 0x200b, 0x00a5, 0x2021, 0x0169, 0x2404,
+	0x9084, 0x000f, 0x9086, 0x0004, 0x11f8, 0x68af, 0x95f5, 0x68c6,
+	0x68cb, 0x0008, 0x00e6, 0x00f6, 0x2079, 0x0090, 0x2071, 0x1a34,
+	0x6814, 0x9084, 0x1984, 0x9085, 0x0012, 0x6816, 0x782b, 0x0008,
+	0x7003, 0x0000, 0x00fe, 0x00ee, 0x9386, 0x0002, 0x1128, 0x7884,
+	0x9005, 0x1110, 0x7887, 0x0001, 0x2001, 0x1950, 0x2004, 0x200a,
+	0x004e, 0x20a9, 0x03e8, 0x6824, 0xd094, 0x0140, 0x6827, 0x0004,
+	0x7804, 0x9084, 0x4000, 0x190c, 0x2997, 0x0090, 0xd08c, 0x0118,
+	0x6827, 0x0002, 0x0010, 0x1f04, 0x92bb, 0x7804, 0x9084, 0x1000,
+	0x0138, 0x2001, 0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987,
+	0x6827, 0x4000, 0x6824, 0x83ff, 0x1120, 0x2009, 0x0049, 0x080c,
+	0x9a50, 0x000e, 0x001e, 0x002e, 0x006e, 0x00ce, 0x00de, 0x00ee,
+	0x00fe, 0x015e, 0x012e, 0x0005, 0x00d6, 0x0126, 0x2091, 0x8000,
+	0x2069, 0x19b6, 0x6a06, 0x012e, 0x00de, 0x0005, 0x00d6, 0x0126,
+	0x2091, 0x8000, 0x2069, 0x19b6, 0x6a32, 0x012e, 0x00de, 0x0005,
+	0x080c, 0x8c48, 0x7814, 0x080c, 0x511b, 0x0108, 0x782c, 0x7032,
+	0x7042, 0x7047, 0x1000, 0x0478, 0x080c, 0x8c48, 0x7814, 0x080c,
+	0x511b, 0x0108, 0x782c, 0x7032, 0x7042, 0x7047, 0x4000, 0x0418,
+	0x080c, 0x8c48, 0x7814, 0x080c, 0x511b, 0x0108, 0x782c, 0x7032,
+	0x7042, 0x7047, 0x2000, 0x00b8, 0x080c, 0x8c48, 0x7814, 0x080c,
+	0x511b, 0x0108, 0x782c, 0x7032, 0x7042, 0x7047, 0x0400, 0x0058,
+	0x080c, 0x8c48, 0x7814, 0x080c, 0x511b, 0x0108, 0x782c, 0x7032,
+	0x7042, 0x7047, 0x0200, 0x60c3, 0x0020, 0x0804, 0x8f8f, 0x00e6,
+	0x2071, 0x19b6, 0x7020, 0x9005, 0x0110, 0x8001, 0x7022, 0x00ee,
+	0x0005, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x0076, 0x0066, 0x0006,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x19b6, 0x7614, 0x2660, 0x2678,
+	0x2039, 0x0001, 0x87ff, 0x0904, 0x93e4, 0x8cff, 0x0904, 0x93e4,
+	0x6020, 0x9086, 0x0006, 0x1904, 0x93df, 0x88ff, 0x0138, 0x2800,
+	0x9c06, 0x1904, 0x93df, 0x2039, 0x0000, 0x0050, 0x6010, 0x9b06,
+	0x1904, 0x93df, 0x85ff, 0x0120, 0x6054, 0x9106, 0x1904, 0x93df,
+	0x7024, 0x9c06, 0x15b0, 0x2069, 0x0100, 0x68c0, 0x9005, 0x1160,
+	0x6824, 0xd084, 0x0148, 0x6827, 0x0001, 0x080c, 0x7cc7, 0x080c,
+	0x9469, 0x7027, 0x0000, 0x0428, 0x080c, 0x7cc7, 0x6820, 0xd0b4,
+	0x0110, 0x68a7, 0x95f5, 0x6817, 0x0008, 0x68c3, 0x0000, 0x080c,
+	0x9469, 0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384,
+	0x1000, 0x0138, 0x2001, 0x0100, 0x080c, 0x2987, 0x9006, 0x080c,
+	0x2987, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001,
+	0x003e, 0x7014, 0x9c36, 0x1110, 0x660c, 0x7616, 0x7010, 0x9c36,
+	0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7012, 0x0010, 0x7013,
+	0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008,
+	0x2678, 0x89ff, 0x1168, 0x600f, 0x0000, 0x6014, 0x0096, 0x2048,
+	0x080c, 0xb5f9, 0x0110, 0x080c, 0xcf91, 0x009e, 0x080c, 0x9a06,
+	0x080c, 0x933f, 0x88ff, 0x1190, 0x00ce, 0x0804, 0x935a, 0x2c78,
+	0x600c, 0x2060, 0x0804, 0x935a, 0x9006, 0x012e, 0x000e, 0x006e,
+	0x007e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x601b, 0x0000,
+	0x00ce, 0x98c5, 0x0001, 0x0c88, 0x00f6, 0x00e6, 0x00d6, 0x0096,
+	0x00c6, 0x0066, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000, 0x2071,
+	0x19b6, 0x7638, 0x2660, 0x2678, 0x8cff, 0x0904, 0x9458, 0x6020,
+	0x9086, 0x0006, 0x1904, 0x9453, 0x87ff, 0x0128, 0x2700, 0x9c06,
+	0x1904, 0x9453, 0x0040, 0x6010, 0x9b06, 0x15e8, 0x85ff, 0x0118,
+	0x6054, 0x9106, 0x15c0, 0x703c, 0x9c06, 0x1168, 0x0036, 0x2019,
+	0x0001, 0x080c, 0x9254, 0x7033, 0x0000, 0x9006, 0x703e, 0x7042,
+	0x7046, 0x704a, 0x003e, 0x7038, 0x9c36, 0x1110, 0x660c, 0x763a,
+	0x7034, 0x9c36, 0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x7036,
+	0x0010, 0x7037, 0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110,
+	0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x6014, 0x2048, 0x080c,
+	0xb5f9, 0x0110, 0x080c, 0xcf91, 0x080c, 0x9a06, 0x87ff, 0x1198,
+	0x00ce, 0x0804, 0x9404, 0x2c78, 0x600c, 0x2060, 0x0804, 0x9404,
+	0x9006, 0x012e, 0x000e, 0x002e, 0x006e, 0x00ce, 0x009e, 0x00de,
+	0x00ee, 0x00fe, 0x0005, 0x601b, 0x0000, 0x00ce, 0x97bd, 0x0001,
+	0x0c80, 0x00e6, 0x2071, 0x19b6, 0x2001, 0x1800, 0x2004, 0x9086,
+	0x0002, 0x1118, 0x7007, 0x0005, 0x0010, 0x7007, 0x0000, 0x00ee,
+	0x0005, 0x00f6, 0x00e6, 0x00c6, 0x0066, 0x0026, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2071, 0x19b6, 0x2c10, 0x7638, 0x2660, 0x2678,
+	0x8cff, 0x0518, 0x2200, 0x9c06, 0x11e0, 0x7038, 0x9c36, 0x1110,
+	0x660c, 0x763a, 0x7034, 0x9c36, 0x1140, 0x2c00, 0x9f36, 0x0118,
+	0x2f00, 0x7036, 0x0010, 0x7037, 0x0000, 0x660c, 0x2c00, 0x9f06,
+	0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f, 0x0000, 0x9085, 0x0001,
+	0x0020, 0x2c78, 0x600c, 0x2060, 0x08d8, 0x012e, 0x000e, 0x002e,
+	0x006e, 0x00ce, 0x00ee, 0x00fe, 0x0005, 0x0096, 0x00f6, 0x00e6,
+	0x00d6, 0x00c6, 0x0066, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000,
+	0x2071, 0x19b6, 0x760c, 0x2660, 0x2678, 0x8cff, 0x0904, 0x9545,
+	0x6010, 0x00b6, 0x2058, 0xb8a0, 0x00be, 0x9206, 0x1904, 0x9540,
+	0x7024, 0x9c06, 0x1520, 0x2069, 0x0100, 0x68c0, 0x9005, 0x0904,
+	0x951c, 0x080c, 0x8fbb, 0x68c3, 0x0000, 0x080c, 0x9469, 0x7027,
+	0x0000, 0x0036, 0x2069, 0x0140, 0x6b04, 0x9384, 0x1000, 0x0138,
+	0x2001, 0x0100, 0x080c, 0x2987, 0x9006, 0x080c, 0x2987, 0x2069,
+	0x0100, 0x6824, 0xd084, 0x0110, 0x6827, 0x0001, 0x003e, 0x700c,
+	0x9c36, 0x1110, 0x660c, 0x760e, 0x7008, 0x9c36, 0x1140, 0x2c00,
+	0x9f36, 0x0118, 0x2f00, 0x700a, 0x0010, 0x700b, 0x0000, 0x660c,
+	0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e, 0x0008, 0x2678, 0x600f,
+	0x0000, 0x080c, 0xb7e9, 0x1158, 0x080c, 0x2e55, 0x080c, 0xb7fa,
+	0x11f0, 0x080c, 0xa364, 0x00d8, 0x080c, 0x9469, 0x08c0, 0x080c,
+	0xb7fa, 0x1118, 0x080c, 0xa364, 0x0090, 0x6014, 0x2048, 0x080c,
+	0xb5f9, 0x0168, 0x6020, 0x9086, 0x0003, 0x1508, 0xa867, 0x0103,
+	0xab7a, 0xa877, 0x0000, 0x080c, 0x6529, 0x080c, 0xb7dd, 0x080c,
+	0xba61, 0x080c, 0x9a06, 0x080c, 0x933f, 0x00ce, 0x0804, 0x94c5,
+	0x2c78, 0x600c, 0x2060, 0x0804, 0x94c5, 0x012e, 0x000e, 0x002e,
+	0x006e, 0x00ce, 0x00de, 0x00ee, 0x00fe, 0x009e, 0x0005, 0x6020,
+	0x9086, 0x0006, 0x1d20, 0x080c, 0xcf91, 0x0c08, 0x00d6, 0x080c,
+	0x8aef, 0x7003, 0x0200, 0x7007, 0x0014, 0x60c3, 0x0014, 0x20e1,
+	0x0001, 0x2099, 0x1958, 0x20e9, 0x0000, 0x20a1, 0x0250, 0x20a9,
+	0x0004, 0x4003, 0x7023, 0x0004, 0x7027, 0x7878, 0x080c, 0x8f8f,
+	0x00de, 0x0005, 0x080c, 0x8aef, 0x700b, 0x0800, 0x7814, 0x9084,
+	0xff00, 0x700e, 0x7814, 0x9084, 0x00ff, 0x7022, 0x782c, 0x7026,
+	0x7858, 0x9084, 0x00ff, 0x9085, 0x0200, 0x7002, 0x7858, 0x9084,
+	0xff00, 0x8007, 0x7006, 0x60c2, 0x0804, 0x8f8f, 0x00b6, 0x00d6,
+	0x0016, 0x00d6, 0x2f68, 0x2009, 0x0035, 0x080c, 0xbc66, 0x00de,
+	0x1904, 0x95f3, 0x080c, 0x8aa4, 0x7003, 0x1300, 0x782c, 0x080c,
+	0x96f5, 0x2068, 0x6820, 0x9086, 0x0003, 0x0560, 0x7810, 0x2058,
+	0xbaa0, 0x080c, 0x9940, 0x11d8, 0x9286, 0x007e, 0x1128, 0x700b,
+	0x00ff, 0x700f, 0xfffe, 0x0498, 0x9286, 0x007f, 0x1128, 0x700b,
+	0x00ff, 0x700f, 0xfffd, 0x0458, 0x9284, 0xff80, 0x0180, 0x9286,
+	0x0080, 0x1128, 0x700b, 0x00ff, 0x700f, 0xfffc, 0x0400, 0x92d8,
+	0x1000, 0x2b5c, 0xb810, 0x700a, 0xb814, 0x700e, 0x00c0, 0x6098,
+	0x700e, 0x00a8, 0x080c, 0x9940, 0x1130, 0x7810, 0x2058, 0xb8a0,
+	0x9082, 0x007e, 0x0250, 0x00d6, 0x2069, 0x181d, 0x2d04, 0x700a,
+	0x8d68, 0x2d04, 0x700e, 0x00de, 0x0010, 0x6034, 0x700e, 0x7838,
+	0x7012, 0x783c, 0x7016, 0x60c3, 0x000c, 0x001e, 0x00de, 0x080c,
+	0x8f8f, 0x00be, 0x0005, 0x781b, 0x0001, 0x7803, 0x0006, 0x001e,
+	0x00de, 0x00be, 0x0005, 0x792c, 0x9180, 0x0008, 0x200c, 0x9186,
+	0x0006, 0x01c0, 0x9186, 0x0003, 0x0904, 0x966d, 0x9186, 0x0005,
+	0x0904, 0x9656, 0x9186, 0x0004, 0x05d8, 0x9186, 0x0008, 0x0904,
+	0x965e, 0x7807, 0x0037, 0x782f, 0x0003, 0x7817, 0x1700, 0x080c,
+	0x96d2, 0x0005, 0x080c, 0x9693, 0x00d6, 0x0026, 0x792c, 0x2168,
+	0x2009, 0x4000, 0x6800, 0x0002, 0x9637, 0x9642, 0x9639, 0x9642,
+	0x963e, 0x9637, 0x9637, 0x9642, 0x9642, 0x9642, 0x9642, 0x9637,
+	0x9637, 0x9637, 0x9637, 0x9637, 0x9642, 0x9637, 0x9642, 0x080c,
+	0x0db2, 0x6824, 0xd0e4, 0x0110, 0xd0cc, 0x0110, 0x900e, 0x0010,
+	0x2009, 0x2000, 0x682c, 0x7022, 0x6830, 0x7026, 0x0804, 0x968c,
+	0x080c, 0x9693, 0x00d6, 0x0026, 0x792c, 0x2168, 0x2009, 0x4000,
+	0x6a00, 0x9286, 0x0002, 0x1108, 0x900e, 0x04b0, 0x04e1, 0x00d6,
+	0x0026, 0x792c, 0x2168, 0x2009, 0x4000, 0x0470, 0x04a1, 0x00d6,
+	0x0026, 0x792c, 0x2168, 0x2009, 0x4000, 0x9286, 0x0005, 0x0118,
+	0x9286, 0x0002, 0x1108, 0x900e, 0x00f8, 0x0429, 0x00d6, 0x0026,
+	0x792c, 0x2168, 0x6814, 0x0096, 0x2048, 0xa9ac, 0xa834, 0x9112,
+	0xa9b0, 0xa838, 0x009e, 0x9103, 0x7022, 0x7226, 0x792c, 0x9180,
+	0x0000, 0x2004, 0x908e, 0x0002, 0x0130, 0x908e, 0x0004, 0x0118,
+	0x2009, 0x4000, 0x0008, 0x900e, 0x712a, 0x60c3, 0x0018, 0x002e,
+	0x00de, 0x0804, 0x8f8f, 0x00b6, 0x0036, 0x0046, 0x0056, 0x0066,
+	0x080c, 0x8aef, 0x9006, 0x7003, 0x0200, 0x7938, 0x710a, 0x793c,
+	0x710e, 0x7810, 0x2058, 0xb8a0, 0x080c, 0x9940, 0x1118, 0x9092,
+	0x007e, 0x0268, 0x00d6, 0x2069, 0x181d, 0x2d2c, 0x8d68, 0x2d34,
+	0x90d8, 0x1000, 0x2b5c, 0xbb10, 0xbc14, 0x00de, 0x0028, 0x901e,
+	0x6498, 0x2029, 0x0000, 0x6634, 0x782c, 0x9080, 0x0008, 0x2004,
+	0x9086, 0x0003, 0x1128, 0x7512, 0x7616, 0x731a, 0x741e, 0x0020,
+	0x7312, 0x7416, 0x751a, 0x761e, 0x006e, 0x005e, 0x004e, 0x003e,
+	0x00be, 0x0005, 0x080c, 0x8aef, 0x7003, 0x0100, 0x782c, 0x700a,
+	0x7814, 0x700e, 0x700e, 0x60c3, 0x0008, 0x0804, 0x8f8f, 0x080c,
+	0x8a9b, 0x7003, 0x1400, 0x7838, 0x700a, 0x0079, 0x783c, 0x700e,
+	0x782c, 0x7012, 0x7830, 0x7016, 0x7834, 0x9084, 0x00ff, 0x8007,
+	0x701a, 0x60c3, 0x0010, 0x0804, 0x8f8f, 0x00e6, 0x2071, 0x0240,
+	0x0006, 0x00f6, 0x2078, 0x7810, 0x00b6, 0x2058, 0xb8bc, 0xd084,
+	0x0120, 0x7848, 0x702a, 0x7844, 0x702e, 0x00be, 0x00fe, 0x000e,
+	0x00ee, 0x0005, 0x080c, 0x8ae6, 0x7003, 0x0100, 0x782c, 0x700a,
+	0x7814, 0x700e, 0x60c3, 0x0008, 0x0804, 0x8f8f, 0x0021, 0x60c3,
+	0x0000, 0x0804, 0x8f8f, 0x00d6, 0x080c, 0x97ce, 0xb810, 0x9085,
+	0x0300, 0x7002, 0xb814, 0x7006, 0x2069, 0x1800, 0x6874, 0x700a,
+	0x6878, 0x700e, 0x7013, 0x0819, 0x080c, 0x8f7d, 0x721a, 0x2f10,
+	0x7222, 0x7a08, 0x7226, 0x2071, 0x024c, 0x00de, 0x0005, 0x00a9,
+	0x7914, 0x712a, 0x60c3, 0x0000, 0x60a7, 0x9575, 0x0026, 0x080c,
+	0x283d, 0x0228, 0x2011, 0x0101, 0x2204, 0xc0c5, 0x2012, 0x002e,
+	0x080c, 0x8fb2, 0x080c, 0x7cbe, 0x0005, 0x0036, 0x0096, 0x00d6,
+	0x00e6, 0x7858, 0x2048, 0xaa7c, 0x9296, 0x00c0, 0x9294, 0xfffd,
+	0xaa7e, 0xaa80, 0x9294, 0x0300, 0xaa82, 0xa96c, 0x9194, 0x00ff,
+	0xab74, 0x9384, 0x00ff, 0x908d, 0xc200, 0xa96e, 0x9384, 0xff00,
+	0x9215, 0xaa76, 0xa870, 0xaa78, 0xa87a, 0xaa72, 0x00d6, 0x2069,
+	0x0200, 0x080c, 0x97ce, 0x00de, 0x20e9, 0x0000, 0x20a1, 0x0240,
+	0x20a9, 0x000a, 0xa860, 0x20e0, 0xa85c, 0x9080, 0x001b, 0x2098,
+	0x4003, 0x60a3, 0x0035, 0xaa68, 0x9294, 0x7000, 0x9286, 0x3000,
+	0x0110, 0x60a3, 0x0037, 0x00ee, 0x00de, 0x009e, 0x003e, 0x0005,
+	0x900e, 0x7814, 0x0096, 0x2048, 0xa87c, 0xd0fc, 0x01c0, 0x9084,
+	0x0003, 0x11a8, 0x2001, 0x180c, 0x2004, 0xd0bc, 0x0180, 0x7824,
+	0xd0cc, 0x1168, 0xd0c4, 0x1158, 0xa8a8, 0x9005, 0x1140, 0x2001,
+	0x180c, 0x200c, 0xc1d5, 0x2102, 0x2009, 0x1981, 0x210c, 0x009e,
+	0x918d, 0x0092, 0x0010, 0x2009, 0x0096, 0x60ab, 0x0036, 0x6116,
+	0x0005, 0x2009, 0x0009, 0x00a0, 0x2009, 0x000a, 0x0088, 0x2009,
+	0x000b, 0x0070, 0x2009, 0x000c, 0x0058, 0x2009, 0x000d, 0x0040,
+	0x2009, 0x000e, 0x0028, 0x2009, 0x000f, 0x0010, 0x2009, 0x0008,
+	0x6912, 0x0005, 0x00d6, 0x9290, 0x0018, 0x8214, 0x20e9, 0x0000,
+	0x2069, 0x0200, 0x6813, 0x0000, 0x22a8, 0x9284, 0x00e0, 0x0128,
+	0x20a9, 0x0020, 0x9292, 0x0020, 0x0008, 0x9016, 0x20a1, 0x0240,
+	0x9006, 0x4004, 0x82ff, 0x0120, 0x6810, 0x8000, 0x6812, 0x0c60,
+	0x00de, 0x0005, 0x00d6, 0x0096, 0x6014, 0x2048, 0xa878, 0x6056,
+	0x9006, 0xa836, 0xa83a, 0xa99c, 0xa946, 0xa84a, 0x6023, 0x0003,
+	0x6007, 0x0040, 0x6003, 0x0003, 0x600b, 0xffff, 0xa817, 0x0001,
+	0xa842, 0xa83e, 0x2900, 0xa85a, 0xa813, 0x1da0, 0x080c, 0x8065,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x865d, 0x012e, 0x009e, 0x00de,
+	0x0005, 0x00f6, 0x00e6, 0x00d6, 0x00c6, 0x00a6, 0x0096, 0x0066,
+	0x0126, 0x2091, 0x8000, 0x2071, 0x19b6, 0x760c, 0x2660, 0x2678,
+	0x8cff, 0x0904, 0x98a0, 0x7024, 0x9c06, 0x1520, 0x2069, 0x0100,
+	0x68c0, 0x9005, 0x0904, 0x9877, 0x080c, 0x8fbb, 0x68c3, 0x0000,
+	0x080c, 0x9469, 0x7027, 0x0000, 0x0036, 0x2069, 0x0140, 0x6b04,
+	0x9384, 0x1000, 0x0138, 0x2001, 0x0100, 0x080c, 0x2987, 0x9006,
+	0x080c, 0x2987, 0x2069, 0x0100, 0x6824, 0xd084, 0x0110, 0x6827,
+	0x0001, 0x003e, 0x700c, 0x9c36, 0x1110, 0x660c, 0x760e, 0x7008,
+	0x9c36, 0x1140, 0x2c00, 0x9f36, 0x0118, 0x2f00, 0x700a, 0x0010,
+	0x700b, 0x0000, 0x660c, 0x0066, 0x2c00, 0x9f06, 0x0110, 0x7e0e,
+	0x0008, 0x2678, 0x600f, 0x0000, 0x080c, 0xb7e9, 0x1158, 0x080c,
+	0x2e55, 0x080c, 0xb7fa, 0x11f0, 0x080c, 0xa364, 0x00d8, 0x080c,
+	0x9469, 0x08c0, 0x080c, 0xb7fa, 0x1118, 0x080c, 0xa364, 0x0090,
+	0x6014, 0x2048, 0x080c, 0xb5f9, 0x0168, 0x6020, 0x9086, 0x0003,
+	0x1520, 0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x080c, 0x6536,
+	0x080c, 0xb7dd, 0x080c, 0xba61, 0x080c, 0x9a06, 0x080c, 0x933f,
+	0x00ce, 0x0804, 0x9828, 0x2c78, 0x600c, 0x2060, 0x0804, 0x9828,
+	0x700f, 0x0000, 0x700b, 0x0000, 0x012e, 0x006e, 0x009e, 0x00ae,
+	0x00ce, 0x00de, 0x00ee, 0x00fe, 0x0005, 0x6020, 0x9086, 0x0006,
+	0x1d08, 0x080c, 0xcf91, 0x08f0, 0x00d6, 0x0156, 0x080c, 0x8aef,
+	0x7a14, 0x82ff, 0x0138, 0x7003, 0x0100, 0x700b, 0x0003, 0x60c3,
+	0x0008, 0x0490, 0x7003, 0x0200, 0x7007, 0x0000, 0x2069, 0x1800,
+	0x901e, 0x6800, 0x9086, 0x0004, 0x1110, 0xc38d, 0x0060, 0x080c,
+	0x6c53, 0x1110, 0xc3ad, 0x0008, 0xc3a5, 0x6ad4, 0xd29c, 0x1110,
+	0xd2ac, 0x0108, 0xc39d, 0x730e, 0x2011, 0x1848, 0x63f0, 0x2312,
+	0x20a9, 0x0006, 0x2011, 0x1840, 0x2019, 0x1841, 0x2071, 0x0250,
+	0x2376, 0x8e70, 0x2276, 0x8e70, 0x9398, 0x0002, 0x9290, 0x0002,
+	0x1f04, 0x98e8, 0x60c3, 0x0020, 0x080c, 0x8f8f, 0x015e, 0x00de,
+	0x0005, 0x0156, 0x080c, 0x8aef, 0x7a14, 0x82ff, 0x0168, 0x9286,
+	0xffff, 0x0118, 0x9282, 0x000e, 0x1238, 0x7003, 0x0100, 0x700b,
+	0x0003, 0x60c3, 0x0008, 0x0488, 0x7003, 0x0200, 0x7007, 0x001c,
+	0x700f, 0x0001, 0x2011, 0x198c, 0x2204, 0x8007, 0x701a, 0x8210,
+	0x2204, 0x8007, 0x701e, 0x0421, 0x1120, 0xb8a0, 0x9082, 0x007f,
+	0x0248, 0x2001, 0x181d, 0x2004, 0x7022, 0x2001, 0x181e, 0x2004,
+	0x7026, 0x0030, 0x2001, 0x1816, 0x2004, 0x9084, 0x00ff, 0x7026,
+	0x20a9, 0x0004, 0x20e1, 0x0001, 0x2099, 0x1805, 0x20e9, 0x0000,
+	0x20a1, 0x0256, 0x4003, 0x60c3, 0x001c, 0x015e, 0x0804, 0x8f8f,
+	0x0006, 0x2001, 0x1835, 0x2004, 0xd0ac, 0x000e, 0x0005, 0x2011,
+	0x0003, 0x080c, 0x92ec, 0x2011, 0x0002, 0x080c, 0x92f6, 0x080c,
+	0x91de, 0x0036, 0x901e, 0x080c, 0x9254, 0x003e, 0x0005, 0x080c,
+	0x2f8b, 0x0188, 0x0016, 0x00b6, 0x00c6, 0x7010, 0x9085, 0x0020,
+	0x7012, 0x2009, 0x007e, 0x080c, 0x5f7e, 0xb85c, 0xc0ac, 0xb85e,
+	0x00ce, 0x00be, 0x001e, 0x0005, 0x2071, 0x1883, 0x7000, 0x9005,
+	0x0140, 0x2001, 0x0976, 0x2071, 0x1800, 0x706e, 0x7072, 0x7063,
+	0xffe0, 0x2071, 0x1800, 0x706c, 0x704e, 0x7053, 0x1cd0, 0x0005,
+	0x00e6, 0x0126, 0x2071, 0x1800, 0x2091, 0x8000, 0x754c, 0x9582,
+	0x0010, 0x0608, 0x7050, 0x2060, 0x6000, 0x9086, 0x0000, 0x0148,
+	0x9ce0, 0x0018, 0x7060, 0x9c02, 0x1208, 0x0cb0, 0x2061, 0x1cd0,
+	0x0c98, 0x6003, 0x0008, 0x8529, 0x754e, 0x9ca8, 0x0018, 0x7060,
+	0x9502, 0x1230, 0x7552, 0x9085, 0x0001, 0x012e, 0x00ee, 0x0005,
+	0x7053, 0x1cd0, 0x0cc0, 0x9006, 0x0cc0, 0x00e6, 0x2071, 0x1800,
+	0x754c, 0x9582, 0x0010, 0x0600, 0x7050, 0x2060, 0x6000, 0x9086,
+	0x0000, 0x0148, 0x9ce0, 0x0018, 0x7060, 0x9c02, 0x1208, 0x0cb0,
+	0x2061, 0x1cd0, 0x0c98, 0x6003, 0x0008, 0x8529, 0x754e, 0x9ca8,
+	0x0018, 0x7060, 0x9502, 0x1228, 0x7552, 0x9085, 0x0001, 0x00ee,
+	0x0005, 0x7053, 0x1cd0, 0x0cc8, 0x9006, 0x0cc8, 0x9c82, 0x1cd0,
+	0x0a0c, 0x0db2, 0x2001, 0x1818, 0x2004, 0x9c02, 0x1a0c, 0x0db2,
+	0x9006, 0x6006, 0x600a, 0x600e, 0x6016, 0x601a, 0x6012, 0x6023,
+	0x0000, 0x6003, 0x0000, 0x601e, 0x6056, 0x605a, 0x6026, 0x602a,
+	0x602e, 0x6032, 0x6036, 0x603a, 0x603e, 0x6042, 0x2061, 0x1800,
+	0x604c, 0x8000, 0x604e, 0x9086, 0x0001, 0x0108, 0x0005, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x8582, 0x012e, 0x0cc0, 0x0006, 0x6000,
+	0x9086, 0x0000, 0x01b0, 0x601c, 0xd084, 0x190c, 0x1827, 0x6017,
+	0x0000, 0x6023, 0x0007, 0x2001, 0x1955, 0x2004, 0x0006, 0x9082,
+	0x0051, 0x000e, 0x0208, 0x8004, 0x601a, 0x080c, 0xd240, 0x6043,
+	0x0000, 0x000e, 0x0005, 0x00e6, 0x0126, 0x2071, 0x1800, 0x2091,
+	0x8000, 0x754c, 0x9582, 0x0001, 0x0608, 0x7050, 0x2060, 0x6000,
+	0x9086, 0x0000, 0x0148, 0x9ce0, 0x0018, 0x7060, 0x9c02, 0x1208,
+	0x0cb0, 0x2061, 0x1cd0, 0x0c98, 0x6003, 0x0008, 0x8529, 0x754e,
+	0x9ca8, 0x0018, 0x7060, 0x9502, 0x1230, 0x7552, 0x9085, 0x0001,
+	0x012e, 0x00ee, 0x0005, 0x7053, 0x1cd0, 0x0cc0, 0x9006, 0x0cc0,
+	0x6020, 0x9084, 0x000f, 0x0002, 0x9a63, 0x9a6c, 0x9a87, 0x9aa2,
+	0xbd12, 0xbd2f, 0xbd4a, 0x9a63, 0x9a6c, 0x9a63, 0x9abe, 0x9a63,
+	0x9a63, 0x9a63, 0x9a63, 0x9186, 0x0013, 0x1128, 0x080c, 0x847d,
+	0x080c, 0x8582, 0x0005, 0x0005, 0x0066, 0x6000, 0x90b2, 0x0016,
+	0x1a0c, 0x0db2, 0x0013, 0x006e, 0x0005, 0x9a85, 0xa1dd, 0xa3ab,
+	0x9a85, 0xa439, 0x9d9f, 0x9a85, 0x9a85, 0xa15f, 0xa947, 0x9a85,
+	0x9a85, 0x9a85, 0x9a85, 0x9a85, 0x9a85, 0x080c, 0x0db2, 0x0066,
+	0x6000, 0x90b2, 0x0016, 0x1a0c, 0x0db2, 0x0013, 0x006e, 0x0005,
+	0x9aa0, 0xb012, 0x9aa0, 0x9aa0, 0x9aa0, 0x9aa0, 0x9aa0, 0x9aa0,
+	0xafb7, 0xb194, 0x9aa0, 0xb053, 0xb0d2, 0xb053, 0xb0d2, 0x9aa0,
+	0x080c, 0x0db2, 0x6000, 0x9082, 0x0016, 0x1a0c, 0x0db2, 0x6000,
+	0x0002, 0x9abc, 0xa98e, 0xaa73, 0xaba3, 0xad45, 0x9abc, 0x9abc,
+	0x9abc, 0xa962, 0xaf43, 0xaf46, 0x9abc, 0x9abc, 0x9abc, 0x9abc,
+	0xaf75, 0x9abc, 0x9abc, 0x9abc, 0x080c, 0x0db2, 0x0066, 0x6000,
+	0x90b2, 0x0016, 0x1a0c, 0x0db2, 0x0013, 0x006e, 0x0005, 0x9ad7,
+	0x9ad7, 0x9b1a, 0x9bb8, 0x9c4c, 0x9ad7, 0x9ad7, 0x9ad7, 0x9ad9,
+	0x9ad7, 0x9ad7, 0x9ad7, 0x9ad7, 0x9ad7, 0x9ad7, 0x9ad7, 0x080c,
+	0x0db2, 0x9186, 0x004c, 0x0588, 0x9186, 0x0003, 0x190c, 0x0db2,
+	0x0096, 0x601c, 0xc0ed, 0x601e, 0x6003, 0x0003, 0x6106, 0x6014,
+	0x2048, 0xa87c, 0x9084, 0xa000, 0xc0b5, 0xa87e, 0xa8ac, 0xa846,
+	0xa8b0, 0xa84a, 0x9006, 0xa836, 0xa83a, 0xa884, 0x9092, 0x199a,
+	0x0210, 0x2001, 0x1999, 0x8003, 0x8013, 0x8213, 0x9210, 0x621a,
+	0x009e, 0x2c10, 0x080c, 0x1976, 0x080c, 0x8065, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x865d, 0x012e, 0x0005, 0x6010, 0x00b6, 0x2058,
+	0xbca0, 0x00be, 0x2c00, 0x080c, 0x9c6e, 0x080c, 0xbd04, 0x6003,
+	0x0007, 0x0005, 0x00d6, 0x0096, 0x00f6, 0x2079, 0x1800, 0x7a88,
+	0x6014, 0x2048, 0xa87c, 0xd0ec, 0x1110, 0x9290, 0x0018, 0xac78,
+	0x0046, 0xa8e0, 0x9005, 0x1140, 0xa8dc, 0x921a, 0x0140, 0x0220,
+	0xa87b, 0x0007, 0x2010, 0x0028, 0xa87b, 0x0015, 0x0010, 0xa87b,
+	0x0000, 0x8214, 0xa883, 0x0000, 0xaa02, 0x0006, 0x0016, 0x0026,
+	0x00c6, 0x00d6, 0x00e6, 0x00f6, 0x2400, 0x9005, 0x1108, 0x009a,
+	0x2100, 0x9086, 0x0015, 0x1118, 0x2001, 0x0001, 0x0038, 0x2100,
+	0x9086, 0x0016, 0x0118, 0x2001, 0x0001, 0x002a, 0x94a4, 0x0007,
+	0x8423, 0x9405, 0x0002, 0x9b80, 0x9b80, 0x9b7b, 0x9b7e, 0x9b80,
+	0x9b78, 0x9b6b, 0x9b6b, 0x9b6b, 0x9b6b, 0x9b6b, 0x9b6b, 0x9b6b,
+	0x9b6b, 0x9b6b, 0x9b6b, 0x00fe, 0x00ee, 0x00de, 0x00ce, 0x002e,
+	0x001e, 0x000e, 0x004e, 0x00fe, 0x009e, 0x00de, 0x080c, 0x0db2,
+	0x080c, 0xa5d7, 0x0028, 0x080c, 0xa6b5, 0x0010, 0x080c, 0xa7a4,
+	0x00fe, 0x00ee, 0x00de, 0x00ce, 0x002e, 0x001e, 0x2c00, 0xa896,
+	0x000e, 0x080c, 0x9d2c, 0x0530, 0xa804, 0xa80e, 0x00a6, 0x2050,
+	0xb100, 0x00ae, 0x8006, 0x8006, 0x8007, 0x90bc, 0x003f, 0x9084,
+	0xffc0, 0x9080, 0x0002, 0xaacc, 0xabd0, 0xacd4, 0xadd8, 0x2031,
+	0x0000, 0x2041, 0x1226, 0x080c, 0x9ed6, 0x0160, 0x000e, 0x9005,
+	0x0120, 0x00fe, 0x009e, 0x00de, 0x0005, 0x00fe, 0x009e, 0x00de,
+	0x0804, 0x99d6, 0x2001, 0x002c, 0x900e, 0x080c, 0x9d92, 0x0c70,
+	0x91b6, 0x0015, 0x0170, 0x91b6, 0x0016, 0x0158, 0x91b2, 0x0047,
+	0x0a0c, 0x0db2, 0x91b2, 0x0050, 0x1a0c, 0x0db2, 0x9182, 0x0047,
+	0x00ca, 0x2001, 0x0109, 0x2004, 0xd08c, 0x0198, 0x0126, 0x2091,
+	0x2800, 0x0006, 0x0016, 0x0026, 0x080c, 0x7fb9, 0x002e, 0x001e,
+	0x000e, 0x012e, 0xa001, 0x6000, 0x9086, 0x0002, 0x1110, 0x0804,
+	0x9b1a, 0x0005, 0x9beb, 0x9beb, 0x9bed, 0x9c22, 0x9beb, 0x9beb,
+	0x9beb, 0x9beb, 0x9c35, 0x080c, 0x0db2, 0x00d6, 0x0016, 0x0096,
+	0x080c, 0x8532, 0x080c, 0x865d, 0x6003, 0x0004, 0x6114, 0x2148,
+	0xa87c, 0xd0fc, 0x01b8, 0xa878, 0x9005, 0x1158, 0xa894, 0x9005,
+	0x0140, 0x2001, 0x0000, 0x900e, 0x080c, 0x9d92, 0x080c, 0x99d6,
+	0x00a8, 0x6003, 0x0002, 0xa8a4, 0xa9a8, 0x9105, 0x1178, 0xa8ae,
+	0xa8b2, 0x0c78, 0xa87f, 0x0020, 0xa88c, 0xa88a, 0xa8a4, 0xa8ae,
+	0xa8a8, 0xa8b2, 0xa8c7, 0x0000, 0xa8cb, 0x0000, 0x009e, 0x001e,
+	0x00de, 0x0005, 0x080c, 0x8532, 0x00d6, 0x0096, 0x6114, 0x2148,
+	0x080c, 0xb5fb, 0x0120, 0xa87b, 0x0006, 0x080c, 0x6536, 0x009e,
+	0x00de, 0x080c, 0x99d6, 0x0804, 0x865d, 0x080c, 0x8532, 0x080c,
+	0x2e30, 0x080c, 0xbd01, 0x00d6, 0x0096, 0x6114, 0x2148, 0x080c,
+	0xb5fb, 0x0120, 0xa87b, 0x0029, 0x080c, 0x6536, 0x009e, 0x00de,
+	0x080c, 0x99d6, 0x0804, 0x865d, 0x9182, 0x0047, 0x0002, 0x9c5c,
+	0x9c5e, 0x9c5c, 0x9c5c, 0x9c5c, 0x9c5c, 0x9c5c, 0x9c5c, 0x9c5c,
+	0x9c5c, 0x9c5c, 0x9c5c, 0x9c5e, 0x080c, 0x0db2, 0x00d6, 0x0096,
+	0x080c, 0x14c9, 0x6114, 0x2148, 0xa87b, 0x0000, 0xa883, 0x0000,
+	0x080c, 0x6536, 0x009e, 0x00de, 0x0804, 0x99d6, 0x0026, 0x0036,
+	0x0056, 0x0066, 0x0096, 0x00a6, 0x00f6, 0x0006, 0x080c, 0x0fd5,
+	0x000e, 0x090c, 0x0db2, 0xa960, 0x21e8, 0xa95c, 0x9188, 0x0019,
+	0x21a0, 0x900e, 0x20a9, 0x0020, 0x4104, 0xa87a, 0x2079, 0x1800,
+	0x7988, 0x9188, 0x0018, 0x918c, 0x0fff, 0xa972, 0xac76, 0x2950,
+	0x00a6, 0x2001, 0x0205, 0x2003, 0x0000, 0x901e, 0x2029, 0x0001,
+	0x9182, 0x0034, 0x1228, 0x2011, 0x001f, 0x080c, 0xb219, 0x04c0,
+	0x2130, 0x2009, 0x0034, 0x2011, 0x001f, 0x080c, 0xb219, 0x96b2,
+	0x0034, 0xb004, 0x904d, 0x0110, 0x080c, 0x0f87, 0x080c, 0x0fd5,
+	0x01d0, 0x8528, 0xa867, 0x0110, 0xa86b, 0x0000, 0x2920, 0xb406,
+	0x968a, 0x003d, 0x1230, 0x2608, 0x2011, 0x001b, 0x080c, 0xb219,
+	0x00b8, 0x96b2, 0x003c, 0x2009, 0x003c, 0x2950, 0x2011, 0x001b,
+	0x080c, 0xb219, 0x0c18, 0x2001, 0x0205, 0x2003, 0x0000, 0x00ae,
+	0x852f, 0x95ad, 0x0050, 0xb566, 0xb070, 0xc0fd, 0xb072, 0x0048,
+	0x2001, 0x0205, 0x2003, 0x0000, 0x00ae, 0x852f, 0x95ad, 0x0050,
+	0xb566, 0x2a48, 0xa804, 0xa807, 0x0000, 0x0006, 0x080c, 0x6536,
+	0x000e, 0x2048, 0x9005, 0x1db0, 0x00fe, 0x00ae, 0x009e, 0x006e,
+	0x005e, 0x003e, 0x002e, 0x0005, 0x00d6, 0x00f6, 0x0096, 0x0006,
+	0x080c, 0x0fd5, 0x000e, 0x090c, 0x0db2, 0xa960, 0x21e8, 0xa95c,
+	0x9188, 0x0019, 0x21a0, 0x900e, 0x20a9, 0x0020, 0x4104, 0xaa66,
+	0xa87a, 0x2079, 0x1800, 0x7988, 0x810c, 0x9188, 0x000c, 0x9182,
+	0x001a, 0x0210, 0x2009, 0x001a, 0x21a8, 0x810b, 0xa972, 0xac76,
+	0x2e98, 0xa85c, 0x9080, 0x001f, 0x20a0, 0x2001, 0x0205, 0x200c,
+	0x918d, 0x0080, 0x2102, 0x4003, 0x2003, 0x0000, 0x080c, 0x6536,
+	0x009e, 0x00fe, 0x00de, 0x0005, 0x0016, 0x00d6, 0x00f6, 0x0096,
+	0x0016, 0x2001, 0x0205, 0x200c, 0x918d, 0x0080, 0x2102, 0x001e,
+	0x2079, 0x0200, 0x2e98, 0xa87c, 0xd0ec, 0x0118, 0x9e80, 0x000c,
+	0x2098, 0x2021, 0x003e, 0x901e, 0x9282, 0x0020, 0x0218, 0x2011,
+	0x0020, 0x2018, 0x9486, 0x003e, 0x1170, 0x0096, 0x080c, 0x0fd5,
+	0x2900, 0x009e, 0x05c0, 0xa806, 0x2048, 0xa860, 0x20e8, 0xa85c,
+	0x9080, 0x0002, 0x20a0, 0x3300, 0x908e, 0x0260, 0x0140, 0x2009,
+	0x0280, 0x9102, 0x920a, 0x0218, 0x2010, 0x2100, 0x9318, 0x2200,
+	0x9402, 0x1228, 0x2400, 0x9202, 0x2410, 0x9318, 0x9006, 0x2020,
+	0x22a8, 0xa800, 0x9200, 0xa802, 0x20e1, 0x0000, 0x4003, 0x83ff,
+	0x0180, 0x3300, 0x9086, 0x0280, 0x1130, 0x7814, 0x8000, 0x9085,
+	0x0080, 0x7816, 0x2e98, 0x2310, 0x84ff, 0x0904, 0x9d41, 0x0804,
+	0x9d43, 0x9085, 0x0001, 0x7817, 0x0000, 0x009e, 0x00fe, 0x00de,
+	0x001e, 0x0005, 0x00d6, 0x0036, 0x0096, 0x6314, 0x2348, 0xa87a,
+	0xa982, 0x080c, 0x6529, 0x009e, 0x003e, 0x00de, 0x0005, 0x91b6,
+	0x0015, 0x1118, 0x080c, 0x99d6, 0x0030, 0x91b6, 0x0016, 0x190c,
+	0x0db2, 0x080c, 0x99d6, 0x0005, 0x20a9, 0x000e, 0x20e1, 0x0000,
+	0x2e98, 0x6014, 0x0096, 0x2048, 0xa860, 0x20e8, 0xa85c, 0x20a0,
+	0x009e, 0x4003, 0x0136, 0x9080, 0x001b, 0x2011, 0x0006, 0x20a9,
+	0x0001, 0x3418, 0x8318, 0x23a0, 0x4003, 0x3318, 0x8318, 0x2398,
+	0x8211, 0x1db8, 0x2011, 0x0006, 0x013e, 0x20a0, 0x3318, 0x8318,
+	0x2398, 0x4003, 0x3418, 0x8318, 0x23a0, 0x8211, 0x1db8, 0x0096,
+	0x080c, 0xb5fb, 0x0130, 0x6014, 0x2048, 0xa807, 0x0000, 0xa867,
+	0x0103, 0x009e, 0x0804, 0x99d6, 0x0096, 0x00d6, 0x0036, 0x7330,
+	0x9386, 0x0200, 0x11a8, 0x6010, 0x00b6, 0x2058, 0xb8bf, 0x0000,
+	0x00be, 0x6014, 0x9005, 0x0130, 0x2048, 0xa807, 0x0000, 0xa867,
+	0x0103, 0xab32, 0x080c, 0x99d6, 0x003e, 0x00de, 0x009e, 0x0005,
+	0x0011, 0x1d48, 0x0cc8, 0x0006, 0x0016, 0x080c, 0xbcec, 0x0188,
+	0x6014, 0x9005, 0x1170, 0x600b, 0x0003, 0x601b, 0x0000, 0x6043,
+	0x0000, 0x2009, 0x0022, 0x080c, 0xa1b5, 0x9006, 0x001e, 0x000e,
+	0x0005, 0x9085, 0x0001, 0x0cd0, 0x0096, 0x0016, 0x20a9, 0x0014,
+	0x9e80, 0x000c, 0x20e1, 0x0000, 0x2098, 0x6014, 0x2048, 0xa860,
+	0x20e8, 0xa85c, 0x9080, 0x0002, 0x20a0, 0x4003, 0x2001, 0x0205,
+	0x2003, 0x0001, 0x2099, 0x0260, 0x20a9, 0x0016, 0x4003, 0x20a9,
+	0x000a, 0xa804, 0x2048, 0xa860, 0x20e8, 0xa85c, 0x9080, 0x0002,
+	0x20a0, 0x4003, 0x2001, 0x0205, 0x2003, 0x0002, 0x2099, 0x0260,
+	0x20a9, 0x0020, 0x4003, 0x2003, 0x0000, 0x6014, 0x2048, 0xa800,
+	0x2048, 0xa867, 0x0103, 0x080c, 0x99d6, 0x001e, 0x009e, 0x0005,
+	0x0096, 0x0016, 0x900e, 0x7030, 0x9086, 0x0100, 0x0140, 0x7038,
+	0x9084, 0x00ff, 0x800c, 0x703c, 0x9084, 0x00ff, 0x8004, 0x9080,
+	0x0004, 0x9108, 0x810b, 0x2011, 0x0002, 0x2019, 0x000c, 0x6014,
+	0x2048, 0x080c, 0xb219, 0x080c, 0xb5fb, 0x0140, 0x6014, 0x2048,
+	0xa807, 0x0000, 0xa864, 0xa8e2, 0xa867, 0x0103, 0x080c, 0x99d6,
+	0x001e, 0x009e, 0x0005, 0x0016, 0x0096, 0x7030, 0x9086, 0x0100,
+	0x1118, 0x2009, 0x0004, 0x0010, 0x7034, 0x800c, 0x810b, 0x2011,
+	0x000c, 0x2019, 0x000c, 0x6014, 0x2048, 0xa804, 0x0096, 0x9005,
+	0x0108, 0x2048, 0x080c, 0xb219, 0x009e, 0x080c, 0xb5fb, 0x0148,
+	0xa804, 0x9005, 0x1158, 0xa807, 0x0000, 0xa864, 0xa8e2, 0xa867,
+	0x0103, 0x080c, 0x99d6, 0x009e, 0x001e, 0x0005, 0x0086, 0x2040,
+	0xa030, 0x8007, 0x9086, 0x0100, 0x1118, 0x080c, 0xa364, 0x00e0,
+	0xa034, 0x8007, 0x800c, 0x8806, 0x8006, 0x8007, 0x90bc, 0x003f,
+	0x9084, 0xffc0, 0x9080, 0x000c, 0xa87b, 0x0000, 0xa883, 0x0000,
+	0xa897, 0x4000, 0xaaa0, 0xab9c, 0xaca8, 0xada4, 0x2031, 0x0000,
+	0x2041, 0x120c, 0x0019, 0x0d08, 0x008e, 0x0898, 0x0096, 0x0006,
+	0x080c, 0x0fd5, 0x000e, 0x01b0, 0xa8ab, 0x0dcb, 0xa876, 0x000e,
+	0xa8a2, 0x0006, 0xae6a, 0x2800, 0xa89e, 0xa97a, 0xaf72, 0xaa8e,
+	0xab92, 0xac96, 0xad9a, 0x0086, 0x2940, 0x080c, 0x10b5, 0x008e,
+	0x9085, 0x0001, 0x009e, 0x0005, 0x00e6, 0x00d6, 0x0026, 0x7008,
+	0x9084, 0x00ff, 0x6210, 0x00b6, 0x2258, 0xba10, 0x00be, 0x9206,
+	0x1520, 0x700c, 0x6210, 0x00b6, 0x2258, 0xba14, 0x00be, 0x9206,
+	0x11e0, 0x6043, 0x0000, 0x2c68, 0x0016, 0x2009, 0x0035, 0x080c,
+	0xbc66, 0x001e, 0x1158, 0x622c, 0x2268, 0x2071, 0x026c, 0x6b20,
+	0x9386, 0x0003, 0x0130, 0x9386, 0x0006, 0x0128, 0x080c, 0x99d6,
+	0x0020, 0x0039, 0x0010, 0x080c, 0x9fe8, 0x002e, 0x00de, 0x00ee,
+	0x0005, 0x0096, 0x6814, 0x2048, 0x9186, 0x0015, 0x0904, 0x9fd0,
+	0x918e, 0x0016, 0x1904, 0x9fe6, 0x700c, 0x908c, 0xff00, 0x9186,
+	0x1700, 0x0120, 0x9186, 0x0300, 0x1904, 0x9faa, 0x89ff, 0x1138,
+	0x6800, 0x9086, 0x000f, 0x0904, 0x9f8d, 0x0804, 0x9fe4, 0x6808,
+	0x9086, 0xffff, 0x1904, 0x9fd2, 0xa87c, 0x9084, 0x0060, 0x9086,
+	0x0020, 0x1128, 0xa83c, 0xa940, 0x9105, 0x1904, 0x9fd2, 0x6824,
+	0xd0b4, 0x1904, 0x9fd2, 0x080c, 0xb7dd, 0x685c, 0xa882, 0xa87c,
+	0xc0dc, 0xc0f4, 0xc0d4, 0xa87e, 0x0026, 0x900e, 0x6a18, 0x2001,
+	0x000a, 0x080c, 0x7e7f, 0xa884, 0x920a, 0x0208, 0x8011, 0xaa86,
+	0x82ff, 0x002e, 0x1138, 0x00c6, 0x2d60, 0x080c, 0xb33a, 0x00ce,
+	0x0804, 0x9fe4, 0x00c6, 0xa868, 0xd0fc, 0x1118, 0x080c, 0x5a9d,
+	0x0010, 0x080c, 0x5e34, 0x00ce, 0x1904, 0x9fd2, 0x00c6, 0x2d60,
+	0x080c, 0x99d6, 0x00ce, 0x0804, 0x9fe4, 0x00c6, 0x080c, 0x9a23,
+	0x0198, 0x6017, 0x0000, 0x6810, 0x6012, 0x080c, 0xba69, 0x6023,
+	0x0003, 0x6904, 0x00c6, 0x2d60, 0x080c, 0x99d6, 0x00ce, 0x080c,
+	0x9a50, 0x00ce, 0x0804, 0x9fe4, 0x2001, 0x1957, 0x2004, 0x6842,
+	0x00ce, 0x04d0, 0x7008, 0x9086, 0x000b, 0x11c8, 0x6010, 0x00b6,
+	0x2058, 0xb900, 0xc1bc, 0xb902, 0x00be, 0x00c6, 0x2d60, 0xa883,
+	0x0003, 0x080c, 0xbca8, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023,
+	0x0002, 0x080c, 0x8000, 0x080c, 0x8582, 0x00ce, 0x00e8, 0x700c,
+	0x9086, 0x2a00, 0x1138, 0x2001, 0x1957, 0x2004, 0x6842, 0x00a0,
+	0x0479, 0x00a0, 0x89ff, 0x090c, 0x0db2, 0x00c6, 0x00d6, 0x2d60,
+	0xa867, 0x0103, 0xa87b, 0x0003, 0x080c, 0x6351, 0x080c, 0xb7dd,
+	0x080c, 0x9a06, 0x00de, 0x00ce, 0x080c, 0x99d6, 0x009e, 0x0005,
+	0x9186, 0x0015, 0x1128, 0x2001, 0x1957, 0x2004, 0x6842, 0x0068,
+	0x918e, 0x0016, 0x1160, 0x00c6, 0x2d00, 0x2060, 0x080c, 0xd240,
+	0x080c, 0x7e13, 0x080c, 0x99d6, 0x00ce, 0x080c, 0x99d6, 0x0005,
+	0x0026, 0x0036, 0x0046, 0x7228, 0xacb0, 0xabac, 0xd2f4, 0x0130,
+	0x2001, 0x1957, 0x2004, 0x6842, 0x0804, 0xa064, 0x00c6, 0x2d60,
+	0x080c, 0xb244, 0x00ce, 0x6804, 0x9086, 0x0050, 0x1170, 0x00c6,
+	0x2d00, 0x2060, 0x6003, 0x0001, 0x6007, 0x0050, 0x080c, 0x8000,
+	0x080c, 0x8582, 0x00ce, 0x0804, 0xa064, 0x6800, 0x9086, 0x000f,
+	0x01b0, 0x89ff, 0x090c, 0x0db2, 0x6800, 0x9086, 0x0004, 0x1198,
+	0xa87c, 0xd0ac, 0x0180, 0xa843, 0x0fff, 0xa83f, 0x0fff, 0xa880,
+	0xc0f4, 0xc0fc, 0xa882, 0x2001, 0x0001, 0x6832, 0x0400, 0x2001,
+	0x0007, 0x6832, 0x00e0, 0xa87c, 0xd0b4, 0x1150, 0xd0ac, 0x0db8,
+	0x6824, 0xd0f4, 0x1d40, 0xa838, 0xa934, 0x9105, 0x0d80, 0x0c18,
+	0xd2ec, 0x1d68, 0x7024, 0x9306, 0x1118, 0x7020, 0x9406, 0x0d38,
+	0x7020, 0x683e, 0x7024, 0x683a, 0x2001, 0x0005, 0x6832, 0x080c,
+	0xb960, 0x080c, 0x8582, 0x0010, 0x080c, 0x99d6, 0x004e, 0x003e,
+	0x002e, 0x0005, 0x00e6, 0x00d6, 0x0026, 0x7008, 0x9084, 0x00ff,
+	0x6210, 0x00b6, 0x2258, 0xba10, 0x00be, 0x9206, 0x1904, 0xa0cf,
+	0x700c, 0x6210, 0x00b6, 0x2258, 0xba14, 0x00be, 0x9206, 0x1904,
+	0xa0cf, 0x6038, 0x2068, 0x6824, 0xc0dc, 0x6826, 0x6a20, 0x9286,
+	0x0007, 0x0904, 0xa0cf, 0x9286, 0x0002, 0x0904, 0xa0cf, 0x9286,
+	0x0000, 0x05e8, 0x6808, 0x633c, 0x9306, 0x15c8, 0x2071, 0x026c,
+	0x9186, 0x0015, 0x0570, 0x918e, 0x0016, 0x1100, 0x00c6, 0x6038,
+	0x2060, 0x6104, 0x9186, 0x004b, 0x01c0, 0x9186, 0x004c, 0x01a8,
+	0x9186, 0x004d, 0x0190, 0x9186, 0x004e, 0x0178, 0x9186, 0x0052,
+	0x0160, 0x6014, 0x0096, 0x2048, 0x080c, 0xb5fb, 0x090c, 0x0db2,
+	0xa883, 0x0003, 0x009e, 0x080c, 0xbca8, 0x6007, 0x0085, 0x6003,
+	0x000b, 0x6023, 0x0002, 0x080c, 0x8000, 0x080c, 0x8582, 0x00ce,
+	0x0030, 0x6038, 0x2070, 0x2001, 0x1957, 0x2004, 0x7042, 0x080c,
+	0x99d6, 0x002e, 0x00de, 0x00ee, 0x0005, 0x00b6, 0x0096, 0x00f6,
+	0x6014, 0x2048, 0x6010, 0x2058, 0x91b6, 0x0015, 0x0130, 0xba08,
+	0xbb0c, 0xbc00, 0xc48c, 0xbc02, 0x0460, 0x0096, 0x0156, 0x0036,
+	0x0026, 0x2b48, 0x9e90, 0x0010, 0x2019, 0x000a, 0x20a9, 0x0004,
+	0x080c, 0xa91d, 0x002e, 0x003e, 0x015e, 0x009e, 0x1904, 0xa13e,
+	0x0096, 0x0156, 0x0036, 0x0026, 0x2b48, 0x9e90, 0x0014, 0x2019,
+	0x0006, 0x20a9, 0x0004, 0x080c, 0xa91d, 0x002e, 0x003e, 0x015e,
+	0x009e, 0x15a0, 0x7238, 0xba0a, 0x733c, 0xbb0e, 0xbc00, 0xc48d,
+	0xbc02, 0xa804, 0x9005, 0x1128, 0x00fe, 0x009e, 0x00be, 0x0804,
+	0x9dd7, 0x0096, 0x2048, 0xaa12, 0xab16, 0xac0a, 0x009e, 0x8006,
+	0x8006, 0x8007, 0x90bc, 0x003f, 0x9084, 0xffc0, 0x9080, 0x0002,
+	0x2009, 0x002b, 0xaaa0, 0xab9c, 0xaca8, 0xada4, 0x2031, 0x0000,
+	0x2041, 0x120c, 0x080c, 0x9ed6, 0x0130, 0x00fe, 0x009e, 0x080c,
+	0x99d6, 0x00be, 0x0005, 0x080c, 0xa364, 0x0cb8, 0x2b78, 0x00f6,
+	0x080c, 0x2e30, 0x080c, 0xbd01, 0x00fe, 0x00c6, 0x080c, 0x9980,
+	0x2f00, 0x6012, 0x6017, 0x0000, 0x6023, 0x0001, 0x6007, 0x0001,
+	0x6003, 0x0001, 0x2001, 0x0007, 0x080c, 0x5ecf, 0x080c, 0x5efb,
+	0x080c, 0x8048, 0x080c, 0x8582, 0x00ce, 0x0804, 0xa111, 0x2100,
+	0x91b2, 0x0053, 0x1a0c, 0x0db2, 0x91b2, 0x0040, 0x1a04, 0xa1c7,
+	0x0002, 0xa1b5, 0xa1b5, 0xa1ab, 0xa1b5, 0xa1b5, 0xa1b5, 0xa1a9,
+	0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1b5, 0xa1a9, 0xa1b5, 0xa1b5, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1a9, 0xa1ab, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1a9, 0xa1a9, 0xa1a9, 0xa1b5, 0xa1b5, 0xa1a9, 0xa1a9, 0xa1a9,
+	0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1a9, 0xa1b5, 0xa1a9,
+	0xa1a9, 0x080c, 0x0db2, 0x0066, 0x00b6, 0x6610, 0x2658, 0xb8bc,
+	0xc08c, 0xb8be, 0x00be, 0x006e, 0x0000, 0x6003, 0x0001, 0x6106,
+	0x9186, 0x0032, 0x0118, 0x080c, 0x8048, 0x0010, 0x080c, 0x8000,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x8582, 0x012e, 0x0005, 0x2600,
+	0x0002, 0xa1db, 0xa1db, 0xa1db, 0xa1b5, 0xa1b5, 0xa1db, 0xa1db,
+	0xa1db, 0xa1db, 0xa1b5, 0xa1db, 0xa1b5, 0xa1db, 0xa1b5, 0xa1db,
+	0xa1db, 0xa1db, 0xa1db, 0x080c, 0x0db2, 0x6004, 0x90b2, 0x0053,
+	0x1a0c, 0x0db2, 0x91b6, 0x0013, 0x0904, 0xa29f, 0x91b6, 0x0027,
+	0x1904, 0xa25a, 0x080c, 0x847d, 0x6004, 0x080c, 0xb7e9, 0x01b0,
+	0x080c, 0xb7fa, 0x01a8, 0x908e, 0x0021, 0x0904, 0xa257, 0x908e,
+	0x0022, 0x1130, 0x080c, 0x9e03, 0x0904, 0xa253, 0x0804, 0xa254,
+	0x908e, 0x003d, 0x0904, 0xa257, 0x0804, 0xa24d, 0x080c, 0x2e55,
+	0x2001, 0x0007, 0x080c, 0x5ecf, 0x6010, 0x00b6, 0x2058, 0xb9a0,
+	0x00be, 0x080c, 0xa364, 0x9186, 0x007e, 0x1148, 0x2001, 0x1835,
+	0x2014, 0xc285, 0x080c, 0x6c53, 0x1108, 0xc2ad, 0x2202, 0x0036,
+	0x0026, 0x2019, 0x0028, 0x2110, 0x080c, 0xd29b, 0x002e, 0x003e,
+	0x0016, 0x0026, 0x0036, 0x2110, 0x2019, 0x0028, 0x080c, 0x8180,
+	0x0076, 0x903e, 0x080c, 0x8078, 0x6010, 0x00b6, 0x905d, 0x0100,
+	0x00be, 0x2c08, 0x080c, 0xcd62, 0x007e, 0x003e, 0x002e, 0x001e,
+	0x080c, 0xbd01, 0x0016, 0x080c, 0xba61, 0x080c, 0x99d6, 0x001e,
+	0x080c, 0x2f28, 0x080c, 0x8582, 0x0030, 0x080c, 0xba61, 0x080c,
+	0x99d6, 0x080c, 0x8582, 0x0005, 0x080c, 0xa364, 0x0cb0, 0x080c,
+	0xa3a0, 0x0c98, 0x9186, 0x0014, 0x1db0, 0x080c, 0x847d, 0x6004,
+	0x908e, 0x0022, 0x1118, 0x080c, 0x9e03, 0x0d68, 0x080c, 0x2e30,
+	0x080c, 0xbd01, 0x080c, 0xb7e9, 0x1190, 0x080c, 0x2e55, 0x6010,
+	0x00b6, 0x2058, 0xb9a0, 0x00be, 0x080c, 0xa364, 0x9186, 0x007e,
+	0x1128, 0x2001, 0x1835, 0x200c, 0xc185, 0x2102, 0x0870, 0x080c,
+	0xb7fa, 0x1118, 0x080c, 0xa364, 0x0840, 0x6004, 0x908e, 0x0032,
+	0x1160, 0x00e6, 0x00f6, 0x2071, 0x1894, 0x2079, 0x0000, 0x080c,
+	0x31c3, 0x00fe, 0x00ee, 0x0804, 0xa24d, 0x6004, 0x908e, 0x0021,
+	0x0d48, 0x908e, 0x0022, 0x090c, 0xa364, 0x0804, 0xa24d, 0x90b2,
+	0x0040, 0x1a04, 0xa34d, 0x2008, 0x0002, 0xa2e7, 0xa2e8, 0xa2eb,
+	0xa2ee, 0xa2f1, 0xa2f4, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5,
+	0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5,
+	0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5,
+	0xa2e5, 0xa2e5, 0xa2e5, 0xa2f7, 0xa302, 0xa2e5, 0xa304, 0xa302,
+	0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa302, 0xa302, 0xa2e5,
+	0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2e5, 0xa334,
+	0xa302, 0xa2e5, 0xa2fe, 0xa2e5, 0xa2e5, 0xa2e5, 0xa2ff, 0xa2e5,
+	0xa2e5, 0xa2e5, 0xa302, 0xa32b, 0xa2e5, 0x080c, 0x0db2, 0x00d0,
+	0x2001, 0x000b, 0x0410, 0x2001, 0x0003, 0x00f8, 0x2001, 0x0005,
+	0x00e0, 0x2001, 0x0001, 0x00c8, 0x2001, 0x0009, 0x00b0, 0x080c,
+	0x847d, 0x6003, 0x0005, 0x080c, 0x8582, 0x0070, 0x0018, 0x0010,
+	0x080c, 0x5ecf, 0x0804, 0xa345, 0x080c, 0x847d, 0x080c, 0xbd04,
+	0x6003, 0x0004, 0x080c, 0x8582, 0x0005, 0x080c, 0x5ecf, 0x080c,
+	0x847d, 0x6003, 0x0002, 0x0036, 0x2019, 0x185e, 0x2304, 0x9084,
+	0xff00, 0x1120, 0x2001, 0x1955, 0x201c, 0x0040, 0x8007, 0x909a,
+	0x0004, 0x0ec0, 0x8003, 0x801b, 0x831b, 0x9318, 0x631a, 0x003e,
+	0x080c, 0x8582, 0x0c08, 0x080c, 0x847d, 0x080c, 0xba61, 0x080c,
+	0x99d6, 0x080c, 0x8582, 0x08c0, 0x00e6, 0x00f6, 0x2071, 0x1894,
+	0x2079, 0x0000, 0x080c, 0x31c3, 0x00fe, 0x00ee, 0x080c, 0x847d,
+	0x080c, 0x99d6, 0x080c, 0x8582, 0x0838, 0x080c, 0x847d, 0x6003,
+	0x0002, 0x080c, 0xbd04, 0x0804, 0x8582, 0x2600, 0x2008, 0x0002,
+	0xa362, 0xa362, 0xa362, 0xa345, 0xa345, 0xa362, 0xa362, 0xa362,
+	0xa362, 0xa345, 0xa362, 0xa345, 0xa362, 0xa345, 0xa362, 0xa362,
+	0xa362, 0xa362, 0x080c, 0x0db2, 0x00e6, 0x0096, 0x0026, 0x0016,
+	0x080c, 0xb5fb, 0x0568, 0x6014, 0x2048, 0xa864, 0x9086, 0x0139,
+	0x11a8, 0xa894, 0x9086, 0x0056, 0x1148, 0x080c, 0x4ebc, 0x0130,
+	0x2001, 0x0000, 0x900e, 0x2011, 0x4000, 0x0028, 0x2001, 0x0030,
+	0x900e, 0x2011, 0x4005, 0x080c, 0xbbcd, 0x0090, 0xa868, 0xd0fc,
+	0x0178, 0xa807, 0x0000, 0x0016, 0x6004, 0x908e, 0x0021, 0x0168,
+	0x908e, 0x003d, 0x0150, 0x001e, 0xa867, 0x0103, 0xa833, 0x0100,
+	0x001e, 0x002e, 0x009e, 0x00ee, 0x0005, 0x001e, 0x0009, 0x0cc0,
+	0x0096, 0x6014, 0x2048, 0xa800, 0x2048, 0xa867, 0x0103, 0xa823,
+	0x8001, 0x009e, 0x0005, 0x00b6, 0x6610, 0x2658, 0xb804, 0x9084,
+	0x00ff, 0x90b2, 0x000c, 0x1a0c, 0x0db2, 0x6604, 0x96b6, 0x004d,
+	0x1120, 0x080c, 0xbaed, 0x0804, 0xa428, 0x6604, 0x96b6, 0x0043,
+	0x1120, 0x080c, 0xbb36, 0x0804, 0xa428, 0x6604, 0x96b6, 0x004b,
+	0x1120, 0x080c, 0xbb62, 0x0804, 0xa428, 0x6604, 0x96b6, 0x0033,
+	0x1120, 0x080c, 0xba83, 0x0804, 0xa428, 0x6604, 0x96b6, 0x0028,
+	0x1120, 0x080c, 0xb833, 0x0804, 0xa428, 0x6604, 0x96b6, 0x0029,
+	0x1120, 0x080c, 0xb874, 0x0804, 0xa428, 0x6604, 0x96b6, 0x001f,
+	0x1118, 0x080c, 0x9dac, 0x04e0, 0x6604, 0x96b6, 0x0000, 0x1118,
+	0x080c, 0xa0d5, 0x04a8, 0x6604, 0x96b6, 0x0022, 0x1118, 0x080c,
+	0x9de4, 0x0470, 0x6604, 0x96b6, 0x0035, 0x1118, 0x080c, 0x9ef4,
+	0x0438, 0x6604, 0x96b6, 0x0039, 0x1118, 0x080c, 0xa06a, 0x0400,
+	0x6604, 0x96b6, 0x003d, 0x1118, 0x080c, 0x9e1c, 0x00c8, 0x6604,
+	0x96b6, 0x0044, 0x1118, 0x080c, 0x9e58, 0x0090, 0x6604, 0x96b6,
+	0x0049, 0x1118, 0x080c, 0x9e83, 0x0058, 0x91b6, 0x0015, 0x1110,
+	0x0063, 0x0030, 0x91b6, 0x0016, 0x1128, 0x00be, 0x0804, 0xa65e,
+	0x00be, 0x0005, 0x080c, 0x9a6b, 0x0cd8, 0xa445, 0xa448, 0xa445,
+	0xa48d, 0xa445, 0xa5d7, 0xa66b, 0xa445, 0xa445, 0xa638, 0xa445,
+	0xa64c, 0x0096, 0x080c, 0x14c9, 0x6014, 0x2048, 0xa800, 0x2048,
+	0xa867, 0x0103, 0x009e, 0x0804, 0x99d6, 0xa001, 0xa001, 0x0005,
+	0x00e6, 0x2071, 0x1800, 0x7088, 0x9086, 0x0074, 0x1540, 0x080c,
+	0xcd33, 0x11b0, 0x6010, 0x00b6, 0x2058, 0x7030, 0xd08c, 0x0128,
+	0xb800, 0xd0bc, 0x0110, 0xc0c5, 0xb802, 0x00e9, 0x00be, 0x2001,
+	0x0006, 0x080c, 0x5ecf, 0x080c, 0x2e55, 0x080c, 0x99d6, 0x0088,
+	0x2001, 0x000a, 0x080c, 0x5ecf, 0x080c, 0x2e55, 0x6003, 0x0001,
+	0x6007, 0x0001, 0x080c, 0x8048, 0x080c, 0x8582, 0x0010, 0x080c,
+	0xa5c2, 0x00ee, 0x0005, 0x00d6, 0xb800, 0xd084, 0x0160, 0x9006,
+	0x080c, 0x5ebb, 0x2069, 0x1853, 0x6804, 0xd0a4, 0x0120, 0x2001,
+	0x0006, 0x080c, 0x5efb, 0x00de, 0x0005, 0x00b6, 0x0096, 0x00d6,
+	0x2011, 0x1822, 0x2204, 0x9086, 0x0074, 0x1904, 0xa59b, 0x6010,
+	0x2058, 0xbaa0, 0x9286, 0x007e, 0x1120, 0x080c, 0xa7af, 0x0804,
+	0xa4ff, 0x080c, 0xa7a4, 0x6010, 0x2058, 0xbaa0, 0x9286, 0x0080,
+	0x1510, 0x6014, 0x9005, 0x01a8, 0x2048, 0xa864, 0x9084, 0x00ff,
+	0x9086, 0x0039, 0x1140, 0x2001, 0x0000, 0x900e, 0x2011, 0x4000,
+	0x080c, 0xbbcd, 0x0030, 0xa807, 0x0000, 0xa867, 0x0103, 0xa833,
+	0x0200, 0x2001, 0x0006, 0x080c, 0x5ecf, 0x080c, 0x2e55, 0x080c,
+	0x99d6, 0x0804, 0xa59c, 0x080c, 0xa5aa, 0x6014, 0x9005, 0x0190,
+	0x2048, 0xa868, 0xd0f4, 0x01e8, 0xa864, 0x9084, 0x00ff, 0x9086,
+	0x0039, 0x1d08, 0x2001, 0x0000, 0x900e, 0x2011, 0x4000, 0x080c,
+	0xbbcd, 0x08f8, 0x080c, 0xa5a0, 0x0160, 0x9006, 0x080c, 0x5ebb,
+	0x2001, 0x0004, 0x080c, 0x5efb, 0x2001, 0x0007, 0x080c, 0x5ecf,
+	0x08a0, 0x2001, 0x0004, 0x080c, 0x5ecf, 0x6003, 0x0001, 0x6007,
+	0x0003, 0x080c, 0x8048, 0x080c, 0x8582, 0x0804, 0xa59c, 0xb85c,
+	0xd0e4, 0x01d8, 0x080c, 0xba03, 0x080c, 0x6c53, 0x0118, 0xd0dc,
+	0x1904, 0xa4c1, 0x2011, 0x1835, 0x2204, 0xc0ad, 0x2012, 0x2001,
+	0x193e, 0x2004, 0x00f6, 0x2079, 0x0100, 0x78e3, 0x0000, 0x080c,
+	0x254a, 0x78e2, 0x00fe, 0x0804, 0xa4c1, 0x080c, 0xba40, 0x2011,
+	0x1835, 0x2204, 0xc0a5, 0x2012, 0x0006, 0x080c, 0xce81, 0x000e,
+	0x1904, 0xa4c1, 0xc0b5, 0x2012, 0x2001, 0x0006, 0x080c, 0x5ecf,
+	0x9006, 0x080c, 0x5ebb, 0x00c6, 0x2001, 0x180e, 0x2004, 0xd09c,
+	0x0520, 0x00f6, 0x2079, 0x0100, 0x00e6, 0x2071, 0x1800, 0x700c,
+	0x9084, 0x00ff, 0x78e6, 0x7076, 0x7010, 0x78ea, 0x707a, 0x908c,
+	0x00ff, 0x00ee, 0x780c, 0xc0b5, 0x780e, 0x00fe, 0x080c, 0x251f,
+	0x00f6, 0x2100, 0x900e, 0x080c, 0x24d6, 0x7956, 0x00fe, 0x9186,
+	0x0081, 0x01d8, 0x2009, 0x0081, 0x00c8, 0x2009, 0x00ef, 0x00f6,
+	0x2079, 0x0100, 0x79ea, 0x7932, 0x7936, 0x780c, 0xc0b5, 0x780e,
+	0x00fe, 0x080c, 0x251f, 0x00f6, 0x2079, 0x1800, 0x797a, 0x2100,
+	0x900e, 0x080c, 0x24d6, 0x7956, 0x00fe, 0x8108, 0x080c, 0x5f1e,
+	0x2b00, 0x00ce, 0x1904, 0xa4c1, 0x6012, 0x2009, 0x180e, 0x210c,
+	0xd19c, 0x0150, 0x2009, 0x027c, 0x210c, 0x918c, 0x00ff, 0xb912,
+	0x2009, 0x027d, 0x210c, 0xb916, 0x2001, 0x0002, 0x080c, 0x5ecf,
+	0x6023, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x8048,
+	0x080c, 0x8582, 0x0008, 0x0431, 0x00de, 0x009e, 0x00be, 0x0005,
+	0x2001, 0x180f, 0x2004, 0xd0a4, 0x0120, 0x2001, 0x1854, 0x2004,
+	0xd0ac, 0x0005, 0x00e6, 0x080c, 0xd2f4, 0x0190, 0x2071, 0x0260,
+	0x7108, 0x720c, 0x918c, 0x00ff, 0x1118, 0x9284, 0xff00, 0x0140,
+	0x6010, 0x2058, 0xb8a0, 0x9084, 0xff80, 0x1110, 0xb912, 0xba16,
+	0x00ee, 0x0005, 0x2030, 0x2001, 0x0007, 0x080c, 0x5ecf, 0x080c,
+	0x5127, 0x1120, 0x2001, 0x0007, 0x080c, 0x5efb, 0x080c, 0x2e55,
+	0x6020, 0x9086, 0x000a, 0x1108, 0x0005, 0x0804, 0x99d6, 0x00b6,
+	0x00e6, 0x0026, 0x0016, 0x2071, 0x1800, 0x7088, 0x9086, 0x0014,
+	0x1904, 0xa62f, 0x080c, 0x5127, 0x1170, 0x6014, 0x9005, 0x1158,
+	0x0036, 0x0046, 0x6010, 0x2058, 0xbba0, 0x2021, 0x0006, 0x080c,
+	0x4829, 0x004e, 0x003e, 0x00d6, 0x6010, 0x2058, 0x080c, 0x6019,
+	0x080c, 0xa47b, 0x00de, 0x080c, 0xa875, 0x1588, 0x6010, 0x2058,
+	0xb890, 0x9005, 0x0560, 0x2001, 0x0006, 0x080c, 0x5ecf, 0x0096,
+	0x6014, 0x904d, 0x01d0, 0xa864, 0x9084, 0x00ff, 0x9086, 0x0039,
+	0x1140, 0x2001, 0x0000, 0x900e, 0x2011, 0x4000, 0x080c, 0xbbcd,
+	0x0060, 0xa864, 0x9084, 0x00ff, 0x9086, 0x0029, 0x0130, 0xa807,
+	0x0000, 0xa867, 0x0103, 0xa833, 0x0200, 0x009e, 0x080c, 0x2e55,
+	0x6020, 0x9086, 0x000a, 0x0138, 0x080c, 0x99d6, 0x0020, 0x080c,
+	0xa364, 0x080c, 0xa5c2, 0x001e, 0x002e, 0x00ee, 0x00be, 0x0005,
+	0x2011, 0x1822, 0x2204, 0x9086, 0x0014, 0x1160, 0x2001, 0x0002,
+	0x080c, 0x5ecf, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x8048,
+	0x0804, 0x8582, 0x0804, 0xa5c2, 0x2030, 0x2011, 0x1822, 0x2204,
+	0x9086, 0x0004, 0x1148, 0x96b6, 0x000b, 0x1120, 0x2001, 0x0007,
+	0x080c, 0x5ecf, 0x0804, 0x99d6, 0x0804, 0xa5c2, 0x0002, 0xa445,
+	0xa676, 0xa445, 0xa6b5, 0xa445, 0xa760, 0xa66b, 0xa445, 0xa445,
+	0xa773, 0xa445, 0xa783, 0x6604, 0x9686, 0x0003, 0x0904, 0xa5d7,
+	0x96b6, 0x001e, 0x1110, 0x080c, 0x99d6, 0x0005, 0x00b6, 0x00d6,
+	0x00c6, 0x080c, 0xa793, 0x11a0, 0x9006, 0x080c, 0x5ebb, 0x080c,
+	0x2e30, 0x080c, 0xbd01, 0x2001, 0x0002, 0x080c, 0x5ecf, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x8048, 0x080c, 0x8582, 0x0408,
+	0x2009, 0x026e, 0x2104, 0x9086, 0x0009, 0x1160, 0x6010, 0x2058,
+	0xb840, 0x9084, 0x00ff, 0x9005, 0x0170, 0x8001, 0xb842, 0x601b,
+	0x000a, 0x0078, 0x2009, 0x026f, 0x2104, 0x9084, 0xff00, 0x9086,
+	0x1900, 0x1108, 0x08a0, 0x080c, 0x2e30, 0x080c, 0xbd01, 0x080c,
+	0xa5c2, 0x00ce, 0x00de, 0x00be, 0x0005, 0x0096, 0x00b6, 0x0026,
+	0x9016, 0x080c, 0xa7a1, 0x00d6, 0x2069, 0x194d, 0x2d04, 0x9005,
+	0x0168, 0x6010, 0x2058, 0xb8a0, 0x9086, 0x007e, 0x1138, 0x2069,
+	0x181e, 0x2d04, 0x8000, 0x206a, 0x00de, 0x0010, 0x00de, 0x0088,
+	0x9006, 0x080c, 0x5ebb, 0x2001, 0x0002, 0x080c, 0x5ecf, 0x6003,
+	0x0001, 0x6007, 0x0002, 0x080c, 0x8048, 0x080c, 0x8582, 0x0804,
+	0xa730, 0x080c, 0xb5fb, 0x01b0, 0x6014, 0x2048, 0xa864, 0x2010,
+	0x9086, 0x0139, 0x1138, 0x6007, 0x0016, 0x2001, 0x0002, 0x080c,
+	0xbc27, 0x00b0, 0x6014, 0x2048, 0xa864, 0xd0fc, 0x0118, 0x2001,
+	0x0001, 0x0ca8, 0x2001, 0x180d, 0x2004, 0xd0dc, 0x0148, 0x6010,
+	0x2058, 0xb840, 0x9084, 0x00ff, 0x9005, 0x1110, 0x9006, 0x0c38,
+	0x080c, 0xa364, 0x2009, 0x026e, 0x2134, 0x96b4, 0x00ff, 0x9686,
+	0x0005, 0x0510, 0x9686, 0x000b, 0x01c8, 0x2009, 0x026f, 0x2104,
+	0x9084, 0xff00, 0x1118, 0x9686, 0x0009, 0x01b0, 0x9086, 0x1900,
+	0x1168, 0x9686, 0x0009, 0x0180, 0x2001, 0x0004, 0x080c, 0x5ecf,
+	0x2001, 0x0028, 0x601a, 0x6007, 0x0052, 0x0010, 0x080c, 0xa5c2,
+	0x002e, 0x00be, 0x009e, 0x0005, 0x9286, 0x0139, 0x0160, 0x6014,
+	0x2048, 0x080c, 0xb5fb, 0x0140, 0xa864, 0x9086, 0x0139, 0x0118,
+	0xa868, 0xd0fc, 0x0108, 0x0c50, 0x6010, 0x2058, 0xb840, 0x9084,
+	0x00ff, 0x9005, 0x0138, 0x8001, 0xb842, 0x601b, 0x000a, 0x6007,
+	0x0016, 0x08f0, 0xb8a0, 0x9086, 0x007e, 0x1138, 0x00e6, 0x2071,
+	0x1800, 0x080c, 0x59b4, 0x00ee, 0x0010, 0x080c, 0x2e30, 0x0870,
+	0x080c, 0xa7a1, 0x1160, 0x2001, 0x0004, 0x080c, 0x5ecf, 0x6003,
+	0x0001, 0x6007, 0x0003, 0x080c, 0x8048, 0x0804, 0x8582, 0x080c,
+	0xa364, 0x0804, 0xa5c2, 0x0469, 0x1160, 0x2001, 0x0008, 0x080c,
+	0x5ecf, 0x6003, 0x0001, 0x6007, 0x0005, 0x080c, 0x8048, 0x0804,
+	0x8582, 0x0804, 0xa5c2, 0x00e9, 0x1160, 0x2001, 0x000a, 0x080c,
+	0x5ecf, 0x6003, 0x0001, 0x6007, 0x0001, 0x080c, 0x8048, 0x0804,
+	0x8582, 0x0804, 0xa5c2, 0x2009, 0x026e, 0x2104, 0x9086, 0x0003,
+	0x1138, 0x2009, 0x026f, 0x2104, 0x9084, 0xff00, 0x9086, 0x2a00,
+	0x0005, 0x9085, 0x0001, 0x0005, 0x00b6, 0x00c6, 0x0016, 0x6110,
+	0x2158, 0x080c, 0x5f8d, 0x001e, 0x00ce, 0x00be, 0x0005, 0x00b6,
+	0x00f6, 0x00e6, 0x00d6, 0x0036, 0x0016, 0x6010, 0x2058, 0x2009,
+	0x1835, 0x2104, 0x9085, 0x0003, 0x200a, 0x080c, 0xa847, 0x0560,
+	0x2009, 0x1835, 0x2104, 0xc0cd, 0x200a, 0x080c, 0x62a0, 0x0158,
+	0x9006, 0x2020, 0x2009, 0x002a, 0x080c, 0xcfe6, 0x2001, 0x180c,
+	0x200c, 0xc195, 0x2102, 0x2019, 0x002a, 0x2009, 0x0001, 0x080c,
+	0x2dfb, 0x00e6, 0x2071, 0x1800, 0x080c, 0x2c2b, 0x00ee, 0x00c6,
+	0x0156, 0x20a9, 0x0781, 0x2009, 0x007f, 0x080c, 0x2f28, 0x8108,
+	0x1f04, 0xa7e5, 0x015e, 0x00ce, 0x080c, 0xa7a4, 0x2071, 0x0260,
+	0x2079, 0x0200, 0x7817, 0x0001, 0x2001, 0x1835, 0x200c, 0xc1c5,
+	0x7018, 0xd0fc, 0x0110, 0xd0dc, 0x0118, 0x7038, 0xd0dc, 0x1108,
+	0xc1c4, 0x7817, 0x0000, 0x2001, 0x1835, 0x2102, 0x2079, 0x0100,
+	0x2e04, 0x9084, 0x00ff, 0x2069, 0x181d, 0x206a, 0x78e6, 0x0006,
+	0x8e70, 0x2e04, 0x2069, 0x181e, 0x206a, 0x78ea, 0x7832, 0x7836,
+	0x2010, 0x9084, 0xff00, 0x001e, 0x9105, 0x2009, 0x182a, 0x200a,
+	0x2200, 0x9084, 0x00ff, 0x2008, 0x080c, 0x251f, 0x080c, 0x6c53,
+	0x0170, 0x2071, 0x0260, 0x2069, 0x1951, 0x7048, 0x206a, 0x704c,
+	0x6806, 0x7050, 0x680a, 0x7054, 0x680e, 0x080c, 0xba03, 0x0040,
+	0x2001, 0x0006, 0x080c, 0x5ecf, 0x080c, 0x2e55, 0x080c, 0x99d6,
+	0x001e, 0x003e, 0x00de, 0x00ee, 0x00fe, 0x00be, 0x0005, 0x0096,
+	0x0026, 0x0036, 0x00e6, 0x0156, 0x2019, 0x182a, 0x231c, 0x83ff,
+	0x01f0, 0x2071, 0x0260, 0x7200, 0x9294, 0x00ff, 0x7004, 0x9084,
+	0xff00, 0x9205, 0x9306, 0x1198, 0x2011, 0x0276, 0x20a9, 0x0004,
+	0x2b48, 0x2019, 0x000a, 0x080c, 0xa91d, 0x1148, 0x2011, 0x027a,
+	0x20a9, 0x0004, 0x2019, 0x0006, 0x080c, 0xa91d, 0x1100, 0x015e,
+	0x00ee, 0x003e, 0x002e, 0x009e, 0x0005, 0x00e6, 0x2071, 0x0260,
+	0x7034, 0x9086, 0x0014, 0x11a8, 0x7038, 0x9086, 0x0800, 0x1188,
+	0x703c, 0xd0ec, 0x0160, 0x9084, 0x0f00, 0x9086, 0x0100, 0x1138,
+	0x7054, 0xd0a4, 0x1110, 0xd0ac, 0x0110, 0x9006, 0x0010, 0x9085,
+	0x0001, 0x00ee, 0x0005, 0x00e6, 0x0096, 0x00c6, 0x0076, 0x0056,
+	0x0046, 0x0026, 0x0006, 0x0126, 0x2091, 0x8000, 0x2029, 0x19bf,
+	0x252c, 0x2021, 0x19c5, 0x2424, 0x2061, 0x1cd0, 0x2071, 0x1800,
+	0x724c, 0x706c, 0x9202, 0x1a04, 0xa8f5, 0x080c, 0xd012, 0x05f0,
+	0x6720, 0x9786, 0x0007, 0x05d0, 0x2500, 0x9c06, 0x05b8, 0x2400,
+	0x9c06, 0x05a0, 0x3e08, 0x9186, 0x0002, 0x1148, 0x6010, 0x9005,
+	0x0130, 0x00b6, 0x2058, 0xb800, 0x00be, 0xd0bc, 0x1538, 0x00c6,
+	0x6000, 0x9086, 0x0004, 0x1110, 0x080c, 0x1827, 0x9786, 0x000a,
+	0x0148, 0x080c, 0xb7fa, 0x1130, 0x00ce, 0x080c, 0xa364, 0x080c,
+	0x9a06, 0x00a0, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x0160, 0x9786,
+	0x0003, 0x11e8, 0xa867, 0x0103, 0xab7a, 0xa877, 0x0000, 0x080c,
+	0x6529, 0x080c, 0xb7dd, 0x080c, 0x9a06, 0x00ce, 0x9ce0, 0x0018,
+	0x7060, 0x9c02, 0x1210, 0x0804, 0xa8a8, 0x012e, 0x000e, 0x002e,
+	0x004e, 0x005e, 0x007e, 0x00ce, 0x009e, 0x00ee, 0x0005, 0x9786,
+	0x0006, 0x1118, 0x080c, 0xcf91, 0x0c30, 0x9786, 0x000a, 0x09e0,
+	0x08c8, 0x220c, 0x2304, 0x9106, 0x1130, 0x8210, 0x8318, 0x1f04,
+	0xa909, 0x9006, 0x0005, 0x2304, 0x9102, 0x0218, 0x2001, 0x0001,
+	0x0008, 0x9006, 0x918d, 0x0001, 0x0005, 0x0136, 0x01c6, 0x0016,
+	0x8906, 0x8006, 0x8007, 0x908c, 0x003f, 0x21e0, 0x9084, 0xffc0,
+	0x9300, 0x2098, 0x3518, 0x20a9, 0x0001, 0x220c, 0x4002, 0x910e,
+	0x1140, 0x8210, 0x8319, 0x1dc8, 0x9006, 0x001e, 0x01ce, 0x013e,
+	0x0005, 0x220c, 0x9102, 0x0218, 0x2001, 0x0001, 0x0010, 0x2001,
+	0x0000, 0x918d, 0x0001, 0x001e, 0x01ce, 0x013e, 0x0005, 0x6004,
+	0x908a, 0x0053, 0x1a0c, 0x0db2, 0x080c, 0xb7e9, 0x0120, 0x080c,
+	0xb7fa, 0x0168, 0x0028, 0x080c, 0x2e55, 0x080c, 0xb7fa, 0x0138,
+	0x080c, 0x847d, 0x080c, 0x99d6, 0x080c, 0x8582, 0x0005, 0x080c,
+	0xa364, 0x0cb0, 0x9182, 0x0054, 0x1220, 0x9182, 0x0040, 0x0208,
+	0x000a, 0x0005, 0xa97e, 0xa97e, 0xa97e, 0xa97e, 0xa97e, 0xa97e,
+	0xa97e, 0xa97e, 0xa97e, 0xa97e, 0xa97e, 0xa980, 0xa980, 0xa980,
+	0xa980, 0xa97e, 0xa97e, 0xa97e, 0xa980, 0xa97e, 0x080c, 0x0db2,
+	0x600b, 0xffff, 0x6003, 0x0001, 0x6106, 0x080c, 0x8000, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x8582, 0x012e, 0x0005, 0x9186, 0x0013,
+	0x1128, 0x6004, 0x9082, 0x0040, 0x0804, 0xaa35, 0x9186, 0x0027,
+	0x1520, 0x080c, 0x847d, 0x080c, 0x2e30, 0x080c, 0xbd01, 0x0096,
+	0x6114, 0x2148, 0x080c, 0xb5fb, 0x0198, 0x080c, 0xb7fa, 0x1118,
+	0x080c, 0xa364, 0x0068, 0xa867, 0x0103, 0xa87b, 0x0029, 0xa877,
+	0x0000, 0xa97c, 0xc1c5, 0xa97e, 0x080c, 0x6536, 0x080c, 0xb7dd,
+	0x009e, 0x080c, 0x99d6, 0x0804, 0x8582, 0x9186, 0x0014, 0x1120,
+	0x6004, 0x9082, 0x0040, 0x04a0, 0x9186, 0x0046, 0x0150, 0x9186,
+	0x0045, 0x0138, 0x9186, 0x0053, 0x0120, 0x9186, 0x0048, 0x190c,
+	0x0db2, 0x2001, 0x0109, 0x2004, 0xd084, 0x0508, 0x0126, 0x2091,
+	0x2800, 0x0006, 0x0016, 0x0026, 0x0036, 0x00f6, 0x00e6, 0x00c6,
+	0x2079, 0x19b6, 0x2071, 0x1800, 0x2061, 0x0100, 0x080c, 0x7eec,
+	0x00ce, 0x00ee, 0x00fe, 0x003e, 0x002e, 0x001e, 0x000e, 0x012e,
+	0xa001, 0x6000, 0x9086, 0x0002, 0x1110, 0x0804, 0xaa73, 0x0005,
+	0x0002, 0xaa0f, 0xaa0d, 0xaa0d, 0xaa0d, 0xaa0d, 0xaa0d, 0xaa0d,
+	0xaa0d, 0xaa0d, 0xaa0d, 0xaa0d, 0xaa2a, 0xaa2a, 0xaa2a, 0xaa2a,
+	0xaa0d, 0xaa2a, 0xaa0d, 0xaa2a, 0xaa0d, 0x080c, 0x0db2, 0x080c,
+	0x847d, 0x0096, 0x6114, 0x2148, 0x080c, 0xb5fb, 0x0168, 0xa867,
+	0x0103, 0xa87b, 0x0006, 0xa877, 0x0000, 0xa880, 0xc0ec, 0xa882,
+	0x080c, 0x6536, 0x080c, 0xb7dd, 0x009e, 0x080c, 0x99d6, 0x080c,
+	0x8582, 0x0005, 0x080c, 0x847d, 0x080c, 0xb7fa, 0x090c, 0xa364,
+	0x080c, 0x99d6, 0x080c, 0x8582, 0x0005, 0x0002, 0xaa4c, 0xaa4a,
+	0xaa4a, 0xaa4a, 0xaa4a, 0xaa4a, 0xaa4a, 0xaa4a, 0xaa4a, 0xaa4a,
+	0xaa4a, 0xaa63, 0xaa63, 0xaa63, 0xaa63, 0xaa4a, 0xaa6d, 0xaa4a,
+	0xaa63, 0xaa4a, 0x080c, 0x0db2, 0x0096, 0x080c, 0x847d, 0x6014,
+	0x2048, 0x2001, 0x1957, 0x2004, 0x6042, 0xa97c, 0xd1ac, 0x0140,
+	0x6003, 0x0004, 0xa87c, 0x9085, 0x0400, 0xa87e, 0x009e, 0x0005,
+	0x6003, 0x0002, 0x0cb8, 0x080c, 0x847d, 0x080c, 0xbd04, 0x080c,
+	0xbd09, 0x6003, 0x000f, 0x0804, 0x8582, 0x080c, 0x847d, 0x080c,
+	0x99d6, 0x0804, 0x8582, 0x9182, 0x0054, 0x1220, 0x9182, 0x0040,
+	0x0208, 0x000a, 0x0005, 0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f,
+	0xaa91, 0xab6e, 0xaa8f, 0xaba2, 0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f,
+	0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f, 0xaa8f, 0xaba2, 0x080c,
+	0x0db2, 0x00b6, 0x0096, 0x6114, 0x2148, 0x7644, 0x96b4, 0x0fff,
+	0x86ff, 0x1528, 0x6010, 0x2058, 0xb800, 0xd0bc, 0x1904, 0xab5d,
+	0xa87b, 0x0000, 0xa867, 0x0103, 0xae76, 0xa87c, 0xd0ac, 0x0128,
+	0xa834, 0xa938, 0x9115, 0x190c, 0xad37, 0x080c, 0x6351, 0x6210,
+	0x2258, 0xba3c, 0x82ff, 0x0110, 0x8211, 0xba3e, 0x7044, 0xd0e4,
+	0x1904, 0xab41, 0x080c, 0x99d6, 0x009e, 0x00be, 0x0005, 0x968c,
+	0x0c00, 0x0150, 0x6010, 0x2058, 0xb800, 0xd0bc, 0x1904, 0xab45,
+	0x7348, 0xab92, 0x734c, 0xab8e, 0x968c, 0x00ff, 0x9186, 0x0002,
+	0x0508, 0x9186, 0x0028, 0x1118, 0xa87b, 0x001c, 0x00e8, 0xd6dc,
+	0x01a0, 0xa87b, 0x0015, 0xa87c, 0xd0ac, 0x0170, 0xa938, 0xaa34,
+	0x2100, 0x9205, 0x0148, 0x7048, 0x9106, 0x1118, 0x704c, 0x9206,
+	0x0118, 0xa992, 0xaa8e, 0xc6dc, 0x0038, 0xd6d4, 0x0118, 0xa87b,
+	0x0007, 0x0010, 0xa87b, 0x0000, 0xa867, 0x0103, 0xae76, 0x901e,
+	0xd6c4, 0x01d8, 0x9686, 0x0100, 0x1130, 0x7064, 0x9005, 0x1118,
+	0xc6c4, 0x0804, 0xaa98, 0x735c, 0xab86, 0x83ff, 0x0170, 0x938a,
+	0x0009, 0x0210, 0x2019, 0x0008, 0x0036, 0x2308, 0x2019, 0x0018,
+	0x2011, 0x0025, 0x080c, 0xb219, 0x003e, 0xd6cc, 0x0904, 0xaaad,
+	0x7154, 0xa98a, 0x81ff, 0x0904, 0xaaad, 0x9192, 0x0021, 0x1278,
+	0x8304, 0x9098, 0x0018, 0x2011, 0x0029, 0x080c, 0xb219, 0x2011,
+	0x0205, 0x2013, 0x0000, 0x080c, 0xbc93, 0x0804, 0xaaad, 0xa868,
+	0xd0fc, 0x0120, 0x2009, 0x0020, 0xa98a, 0x0c50, 0x00a6, 0x2950,
+	0x080c, 0xb1b8, 0x00ae, 0x080c, 0xbc93, 0x080c, 0xb209, 0x0804,
+	0xaaaf, 0x080c, 0xb8ed, 0x0804, 0xaabc, 0xa87c, 0xd0ac, 0x0904,
+	0xaac8, 0xa880, 0xd0bc, 0x1904, 0xaac8, 0x7348, 0xa838, 0x9306,
+	0x11c8, 0x734c, 0xa834, 0x931e, 0x0904, 0xaac8, 0xd6d4, 0x0190,
+	0xab38, 0x9305, 0x0904, 0xaac8, 0x0068, 0xa87c, 0xd0ac, 0x0904,
+	0xaaa0, 0xa838, 0xa934, 0x9105, 0x0904, 0xaaa0, 0xa880, 0xd0bc,
+	0x1904, 0xaaa0, 0x080c, 0xb927, 0x0804, 0xaabc, 0x0096, 0x00f6,
+	0x6003, 0x0003, 0x6007, 0x0043, 0x2079, 0x026c, 0x7c04, 0x7b00,
+	0x7e0c, 0x7d08, 0x6014, 0x2048, 0xa87c, 0xd0ac, 0x0140, 0x6003,
+	0x0002, 0x00fe, 0x009e, 0x0005, 0x2130, 0x2228, 0x0058, 0x2400,
+	0xa9ac, 0x910a, 0x2300, 0xaab0, 0x9213, 0x2600, 0x9102, 0x2500,
+	0x9203, 0x0e90, 0xac36, 0xab3a, 0xae46, 0xad4a, 0x00fe, 0x6043,
+	0x0000, 0x2c10, 0x080c, 0x1976, 0x080c, 0x8065, 0x080c, 0x865d,
+	0x009e, 0x0005, 0x0005, 0x9182, 0x0054, 0x1220, 0x9182, 0x0040,
+	0x0208, 0x000a, 0x0005, 0xabbf, 0xabbf, 0xabbf, 0xabbf, 0xabbf,
+	0xabc1, 0xac57, 0xabbf, 0xabbf, 0xac6e, 0xacfa, 0xabbf, 0xabbf,
+	0xabbf, 0xabbf, 0xad0f, 0xabbf, 0xabbf, 0xabbf, 0xabbf, 0x080c,
+	0x0db2, 0x0076, 0x00a6, 0x00e6, 0x0096, 0x2071, 0x0260, 0x6114,
+	0x2150, 0x7644, 0xb676, 0x96b4, 0x0fff, 0xb77c, 0xc7e5, 0xb77e,
+	0x6210, 0x00b6, 0x2258, 0xba3c, 0x82ff, 0x0110, 0x8211, 0xba3e,
+	0x00be, 0x86ff, 0x0904, 0xac52, 0x9694, 0xff00, 0x9284, 0x0c00,
+	0x0120, 0x7048, 0xb092, 0x704c, 0xb08e, 0x9284, 0x0300, 0x0904,
+	0xac52, 0x080c, 0x0fd5, 0x090c, 0x0db2, 0x2900, 0xb07a, 0xb77c,
+	0xc7cd, 0xb77e, 0xa867, 0x0103, 0xb068, 0xa86a, 0xb06c, 0xa86e,
+	0xb070, 0xa872, 0xae76, 0x968c, 0x0c00, 0x0120, 0x7348, 0xab92,
+	0x734c, 0xab8e, 0x968c, 0x00ff, 0x9186, 0x0002, 0x0180, 0x9186,
+	0x0028, 0x1118, 0xa87b, 0x001c, 0x0060, 0xd6dc, 0x0118, 0xa87b,
+	0x0015, 0x0038, 0xd6d4, 0x0118, 0xa87b, 0x0007, 0x0010, 0xa87b,
+	0x0000, 0xaf7e, 0xb080, 0xa882, 0xb084, 0xa886, 0x901e, 0xd6c4,
+	0x0190, 0x735c, 0xab86, 0x83ff, 0x0170, 0x938a, 0x0009, 0x0210,
+	0x2019, 0x0008, 0x0036, 0x2308, 0x2019, 0x0018, 0x2011, 0x0025,
+	0x080c, 0xb219, 0x003e, 0xd6cc, 0x01e8, 0x7154, 0xa98a, 0x81ff,
+	0x01c8, 0x9192, 0x0021, 0x1260, 0x8304, 0x9098, 0x0018, 0x2011,
+	0x0029, 0x080c, 0xb219, 0x2011, 0x0205, 0x2013, 0x0000, 0x0050,
+	0xb068, 0xd0fc, 0x0120, 0x2009, 0x0020, 0xa98a, 0x0c68, 0x2950,
+	0x080c, 0xb1b8, 0x009e, 0x00ee, 0x00ae, 0x007e, 0x0005, 0x00f6,
+	0x00a6, 0x6003, 0x0003, 0x2079, 0x026c, 0x7c04, 0x7b00, 0x7e0c,
+	0x7d08, 0x6014, 0x2050, 0xb436, 0xb33a, 0xb646, 0xb54a, 0x00ae,
+	0x00fe, 0x2c10, 0x080c, 0x1976, 0x0804, 0x8f88, 0x6003, 0x0002,
+	0x6004, 0x9086, 0x0040, 0x11c8, 0x0096, 0x6014, 0x2048, 0xa87c,
+	0xd0ac, 0x0160, 0x601c, 0xd084, 0x1130, 0x00f6, 0x2c00, 0x2078,
+	0x080c, 0x1582, 0x00fe, 0x6003, 0x0004, 0x0010, 0x6003, 0x0002,
+	0x009e, 0x080c, 0x847d, 0x080c, 0x8582, 0x0096, 0x2001, 0x1957,
+	0x2004, 0x6042, 0x080c, 0x8532, 0x080c, 0x865d, 0x6114, 0x2148,
+	0xa97c, 0xd1e4, 0x0904, 0xacf5, 0xd1cc, 0x05a8, 0xa978, 0xa868,
+	0xd0fc, 0x0538, 0x0016, 0xa87c, 0x0006, 0xa880, 0x0006, 0xa860,
+	0x20e8, 0xa85c, 0x9080, 0x0019, 0x20a0, 0x810e, 0x810e, 0x810f,
+	0x9184, 0x003f, 0x20e0, 0x9184, 0xffc0, 0x9080, 0x0019, 0x2098,
+	0x0156, 0x20a9, 0x0020, 0x4003, 0x015e, 0x000e, 0xa882, 0x000e,
+	0xa87e, 0x001e, 0xa874, 0x0006, 0x2148, 0x080c, 0x0f87, 0x001e,
+	0x0440, 0x0016, 0x080c, 0x0f87, 0x009e, 0xa974, 0x0016, 0x080c,
+	0xb209, 0x001e, 0x00f0, 0xa867, 0x0103, 0xa974, 0x9184, 0x00ff,
+	0x90b6, 0x0002, 0x0180, 0x9086, 0x0028, 0x1118, 0xa87b, 0x001c,
+	0x0060, 0xd1dc, 0x0118, 0xa87b, 0x0015, 0x0038, 0xd1d4, 0x0118,
+	0xa87b, 0x0007, 0x0010, 0xa87b, 0x0000, 0x0016, 0x080c, 0x6351,
+	0x001e, 0xd1e4, 0x1120, 0x080c, 0x99d6, 0x009e, 0x0005, 0x080c,
+	0xb8ed, 0x0cd8, 0x6004, 0x9086, 0x0040, 0x1120, 0x080c, 0x847d,
+	0x080c, 0x8582, 0x2019, 0x0001, 0x080c, 0x9254, 0x6003, 0x0002,
+	0x080c, 0xbd09, 0x080c, 0x8532, 0x080c, 0x865d, 0x0005, 0x6004,
+	0x9086, 0x0040, 0x1120, 0x080c, 0x847d, 0x080c, 0x8582, 0x2019,
+	0x0001, 0x080c, 0x9254, 0x080c, 0x8532, 0x080c, 0x2e30, 0x080c,
+	0xbd01, 0x0096, 0x6114, 0x2148, 0x080c, 0xb5fb, 0x0150, 0xa867,
+	0x0103, 0xa87b, 0x0029, 0xa877, 0x0000, 0x080c, 0x6536, 0x080c,
+	0xb7dd, 0x009e, 0x080c, 0x99d6, 0x080c, 0x865d, 0x0005, 0xa87b,
+	0x0015, 0xd1fc, 0x0138, 0xa87b, 0x0007, 0x8002, 0x8000, 0x810a,
+	0x9189, 0x0000, 0xa992, 0xa88e, 0x0005, 0x9182, 0x0054, 0x1220,
+	0x9182, 0x0040, 0x0208, 0x000a, 0x0005, 0xad61, 0xad61, 0xad61,
+	0xad61, 0xad61, 0xad63, 0xad61, 0xad61, 0xae09, 0xad61, 0xad61,
+	0xad61, 0xad61, 0xad61, 0xad61, 0xad61, 0xad61, 0xad61, 0xad61,
+	0xaf3a, 0x080c, 0x0db2, 0x0076, 0x00a6, 0x00e6, 0x0096, 0x2071,
+	0x0260, 0x6114, 0x2150, 0x7644, 0xb676, 0x96b4, 0x0fff, 0xb77c,
+	0xc7e5, 0xb77e, 0x6210, 0x00b6, 0x2258, 0xba3c, 0x82ff, 0x0110,
+	0x8211, 0xba3e, 0x00be, 0x86ff, 0x0904, 0xae02, 0x9694, 0xff00,
+	0x9284, 0x0c00, 0x0120, 0x7048, 0xb092, 0x704c, 0xb08e, 0x9284,
+	0x0300, 0x0904, 0xae02, 0x9686, 0x0100, 0x1130, 0x7064, 0x9005,
+	0x1118, 0xc6c4, 0xb676, 0x0c38, 0x080c, 0x0fd5, 0x090c, 0x0db2,
+	0x2900, 0xb07a, 0xb77c, 0x97bd, 0x0200, 0xb77e, 0xa867, 0x0103,
+	0xb068, 0xa86a, 0xb06c, 0xa86e, 0xb070, 0xa872, 0x7044, 0x9084,
+	0xf000, 0x9635, 0xae76, 0x968c, 0x0c00, 0x0120, 0x7348, 0xab92,
+	0x734c, 0xab8e, 0x968c, 0x00ff, 0x9186, 0x0002, 0x0180, 0x9186,
+	0x0028, 0x1118, 0xa87b, 0x001c, 0x0060, 0xd6dc, 0x0118, 0xa87b,
+	0x0015, 0x0038, 0xd6d4, 0x0118, 0xa87b, 0x0007, 0x0010, 0xa87b,
+	0x0000, 0xaf7e, 0xb080, 0xa882, 0xb084, 0xa886, 0x901e, 0xd6c4,
+	0x0190, 0x735c, 0xab86, 0x83ff, 0x0170, 0x938a, 0x0009, 0x0210,
+	0x2019, 0x0008, 0x0036, 0x2308, 0x2019, 0x0018, 0x2011, 0x0025,
+	0x080c, 0xb219, 0x003e, 0xd6cc, 0x01e8, 0x7154, 0xa98a, 0x81ff,
+	0x01c8, 0x9192, 0x0021, 0x1260, 0x8304, 0x9098, 0x0018, 0x2011,
+	0x0029, 0x080c, 0xb219, 0x2011, 0x0205, 0x2013, 0x0000, 0x0050,
+	0xb068, 0xd0fc, 0x0120, 0x2009, 0x0020, 0xa98a, 0x0c68, 0x2950,
+	0x080c, 0xb1b8, 0x080c, 0x1805, 0x009e, 0x00ee, 0x00ae, 0x007e,
+	0x0005, 0x2001, 0x1957, 0x2004, 0x6042, 0x0096, 0x6114, 0x2148,
+	0xa83c, 0xa940, 0x9105, 0x1118, 0xa87c, 0xc0dc, 0xa87e, 0x6003,
+	0x0002, 0xa97c, 0xd1e4, 0x0904, 0xaf35, 0x6043, 0x0000, 0x6010,
+	0x00b6, 0x2058, 0xb800, 0x00be, 0xd0bc, 0x1500, 0xd1cc, 0x0904,
+	0xaf04, 0xa978, 0xa868, 0xd0fc, 0x0904, 0xaec5, 0x0016, 0xa87c,
+	0x0006, 0xa880, 0x0006, 0x00a6, 0x2150, 0xb174, 0x9184, 0x00ff,
+	0x90b6, 0x0002, 0x0904, 0xae93, 0x9086, 0x0028, 0x1904, 0xae7f,
+	0xa87b, 0x001c, 0xb07b, 0x001c, 0x0804, 0xae9b, 0x6024, 0xd0f4,
+	0x11d0, 0xa838, 0xaa34, 0x9205, 0x09c8, 0xa838, 0xaa90, 0x9206,
+	0x1120, 0xa88c, 0xaa34, 0x9206, 0x0988, 0x6024, 0xd0d4, 0x1148,
+	0xa9ac, 0xa834, 0x9102, 0x603a, 0xa9b0, 0xa838, 0x9103, 0x603e,
+	0x6024, 0xc0f5, 0x6026, 0x6010, 0x00b6, 0x2058, 0xb83c, 0x8000,
+	0xb83e, 0x00be, 0x9006, 0xa876, 0xa892, 0xa88e, 0xa87c, 0xc0e4,
+	0xa87e, 0xd0cc, 0x0140, 0xc0cc, 0xa87e, 0x0096, 0xa878, 0x2048,
+	0x080c, 0x0f87, 0x009e, 0x080c, 0xb927, 0x0804, 0xaf35, 0xd1dc,
+	0x0158, 0xa87b, 0x0015, 0xb07b, 0x0015, 0x080c, 0xbbb6, 0x0118,
+	0xb174, 0xc1dc, 0xb176, 0x0078, 0xd1d4, 0x0128, 0xa87b, 0x0007,
+	0xb07b, 0x0007, 0x0040, 0xa87c, 0xd0ac, 0x0128, 0xa834, 0xa938,
+	0x9115, 0x190c, 0xad37, 0xa87c, 0xb07e, 0xa890, 0xb092, 0xa88c,
+	0xb08e, 0xa860, 0x20e8, 0xa85c, 0x9080, 0x0019, 0x20a0, 0x20a9,
+	0x0020, 0x8a06, 0x8006, 0x8007, 0x9094, 0x003f, 0x22e0, 0x9084,
+	0xffc0, 0x9080, 0x0019, 0x2098, 0x4003, 0x00ae, 0x000e, 0xa882,
+	0x000e, 0xa87e, 0x080c, 0xbc93, 0x001e, 0xa874, 0x0006, 0x2148,
+	0x080c, 0x0f87, 0x001e, 0x0804, 0xaf31, 0x0016, 0x00a6, 0x2150,
+	0xb174, 0x9184, 0x00ff, 0x90b6, 0x0002, 0x01e0, 0x9086, 0x0028,
+	0x1128, 0xa87b, 0x001c, 0xb07b, 0x001c, 0x00e0, 0xd1dc, 0x0158,
+	0xa87b, 0x0015, 0xb07b, 0x0015, 0x080c, 0xbbb6, 0x0118, 0xb174,
+	0xc1dc, 0xb176, 0x0078, 0xd1d4, 0x0128, 0xa87b, 0x0007, 0xb07b,
+	0x0007, 0x0040, 0xa87c, 0xd0ac, 0x0128, 0xa834, 0xa938, 0x9115,
+	0x190c, 0xad37, 0xa890, 0xb092, 0xa88c, 0xb08e, 0xa87c, 0xb07e,
+	0x00ae, 0x080c, 0x0f87, 0x009e, 0x080c, 0xbc93, 0xa974, 0x0016,
+	0x080c, 0xb209, 0x001e, 0x0468, 0xa867, 0x0103, 0xa974, 0x9184,
+	0x00ff, 0x90b6, 0x0002, 0x01b0, 0x9086, 0x0028, 0x1118, 0xa87b,
+	0x001c, 0x00d0, 0xd1dc, 0x0148, 0xa87b, 0x0015, 0x080c, 0xbbb6,
+	0x0118, 0xa974, 0xc1dc, 0xa976, 0x0078, 0xd1d4, 0x0118, 0xa87b,
+	0x0007, 0x0050, 0xa87b, 0x0000, 0xa87c, 0xd0ac, 0x0128, 0xa834,
+	0xa938, 0x9115, 0x190c, 0xad37, 0xa974, 0x0016, 0x080c, 0x6351,
+	0x001e, 0xd1e4, 0x1120, 0x080c, 0x99d6, 0x009e, 0x0005, 0x080c,
+	0xb8ed, 0x0cd8, 0x6114, 0x0096, 0x2148, 0xa97c, 0xd1e4, 0x190c,
+	0x1813, 0x009e, 0x0005, 0x080c, 0x847d, 0x0010, 0x080c, 0x8532,
+	0x080c, 0xb5fb, 0x01f0, 0x0096, 0x6114, 0x2148, 0x080c, 0xb7fa,
+	0x1118, 0x080c, 0xa364, 0x00a0, 0xa867, 0x0103, 0x2009, 0x180c,
+	0x210c, 0xd18c, 0x11b8, 0xd184, 0x1190, 0x6108, 0xa97a, 0x918e,
+	0x0029, 0x1110, 0x080c, 0xd28c, 0xa877, 0x0000, 0x080c, 0x6536,
+	0x009e, 0x080c, 0x99d6, 0x080c, 0x8582, 0x0804, 0x865d, 0xa87b,
+	0x0004, 0x0c90, 0xa87b, 0x0004, 0x0c78, 0x9182, 0x0054, 0x1220,
+	0x9182, 0x0040, 0x0208, 0x000a, 0x0005, 0xaf91, 0xaf91, 0xaf91,
+	0xaf91, 0xaf91, 0xaf93, 0xaf91, 0xaf91, 0xaf91, 0xaf91, 0xaf91,
+	0xaf91, 0xaf91, 0xaf91, 0xaf91, 0xaf91, 0xaf91, 0xaf91, 0xaf91,
+	0xaf91, 0x080c, 0x0db2, 0x080c, 0x511b, 0x01f8, 0x6014, 0x7144,
+	0x918c, 0x0fff, 0x9016, 0xd1c4, 0x0118, 0x7264, 0x9294, 0x00ff,
+	0x0096, 0x904d, 0x0188, 0xa87b, 0x0000, 0xa864, 0x9086, 0x0139,
+	0x0128, 0xa867, 0x0103, 0xa976, 0xaa96, 0x0030, 0xa897, 0x4000,
+	0xa99a, 0xaa9e, 0x080c, 0x6536, 0x009e, 0x0804, 0x99d6, 0x9182,
+	0x0085, 0x0002, 0xafc9, 0xafc7, 0xafc7, 0xafd5, 0xafc7, 0xafc7,
+	0xafc7, 0xafc7, 0xafc7, 0xafc7, 0xafc7, 0xafc7, 0xafc7, 0x080c,
+	0x0db2, 0x6003, 0x0001, 0x6106, 0x080c, 0x8000, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x8582, 0x012e, 0x0005, 0x0026, 0x0056, 0x00d6,
+	0x00e6, 0x2071, 0x0260, 0x7224, 0x6216, 0x7220, 0x080c, 0xb5e9,
+	0x01a0, 0x2268, 0x6800, 0x9086, 0x0000, 0x0178, 0x6010, 0x6d10,
+	0x952e, 0x1158, 0x00c6, 0x2d60, 0x080c, 0xb244, 0x00ce, 0x0128,
+	0x6803, 0x0002, 0x6007, 0x0086, 0x0010, 0x6007, 0x0087, 0x6003,
+	0x0001, 0x080c, 0x8000, 0x080c, 0x8582, 0x9280, 0x0004, 0x00b6,
+	0x2058, 0xb800, 0x00be, 0xd0bc, 0x0140, 0x6824, 0xd0ec, 0x0128,
+	0x00c6, 0x2260, 0x080c, 0xb927, 0x00ce, 0x00ee, 0x00de, 0x005e,
+	0x002e, 0x0005, 0x9186, 0x0013, 0x1160, 0x6004, 0x908a, 0x0085,
+	0x0a0c, 0x0db2, 0x908a, 0x0092, 0x1a0c, 0x0db2, 0x9082, 0x0085,
+	0x00e2, 0x9186, 0x0027, 0x0120, 0x9186, 0x0014, 0x190c, 0x0db2,
+	0x080c, 0x847d, 0x0096, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x0140,
+	0xa867, 0x0103, 0xa877, 0x0000, 0xa87b, 0x0029, 0x080c, 0x6536,
+	0x009e, 0x080c, 0x9a06, 0x0804, 0x8582, 0xb04a, 0xb04c, 0xb04c,
+	0xb04a, 0xb04a, 0xb04a, 0xb04a, 0xb04a, 0xb04a, 0xb04a, 0xb04a,
+	0xb04a, 0xb04a, 0x080c, 0x0db2, 0x080c, 0x847d, 0x080c, 0x9a06,
+	0x080c, 0x8582, 0x0005, 0x9186, 0x0013, 0x1128, 0x6004, 0x9082,
+	0x0085, 0x2008, 0x04b8, 0x9186, 0x0027, 0x11f8, 0x080c, 0x847d,
+	0x080c, 0x2e30, 0x080c, 0xbd01, 0x0096, 0x6014, 0x2048, 0x080c,
+	0xb5fb, 0x0150, 0xa867, 0x0103, 0xa877, 0x0000, 0xa87b, 0x0029,
+	0x080c, 0x6536, 0x080c, 0xb7dd, 0x009e, 0x080c, 0x99d6, 0x080c,
+	0x8582, 0x0005, 0x080c, 0x9a6b, 0x0ce0, 0x9186, 0x0014, 0x1dd0,
+	0x080c, 0x847d, 0x0096, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x0d60,
+	0xa867, 0x0103, 0xa877, 0x0000, 0xa87b, 0x0006, 0xa880, 0xc0ec,
+	0xa882, 0x08f0, 0x0002, 0xb0a2, 0xb0a0, 0xb0a0, 0xb0a0, 0xb0a0,
+	0xb0a0, 0xb0ba, 0xb0a0, 0xb0a0, 0xb0a0, 0xb0a0, 0xb0a0, 0xb0a0,
+	0x080c, 0x0db2, 0x080c, 0x847d, 0x6034, 0x908c, 0xff00, 0x810f,
+	0x9186, 0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x2001, 0x1955,
+	0x0010, 0x2001, 0x1956, 0x2004, 0x601a, 0x6003, 0x000c, 0x080c,
+	0x8582, 0x0005, 0x080c, 0x847d, 0x6034, 0x908c, 0xff00, 0x810f,
+	0x9186, 0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x2001, 0x1955,
+	0x0010, 0x2001, 0x1956, 0x2004, 0x601a, 0x6003, 0x000e, 0x080c,
+	0x8582, 0x0005, 0x9182, 0x0092, 0x1220, 0x9182, 0x0085, 0x0208,
+	0x0012, 0x0804, 0x9a6b, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0ea,
+	0xb137, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0e8, 0xb0e8,
+	0x080c, 0x0db2, 0x0096, 0x6010, 0x00b6, 0x2058, 0xb800, 0x00be,
+	0xd0bc, 0x0168, 0x6034, 0x908c, 0xff00, 0x810f, 0x9186, 0x0039,
+	0x0118, 0x9186, 0x0035, 0x1118, 0x009e, 0x0804, 0xb14b, 0x080c,
+	0xb5fb, 0x1118, 0x080c, 0xb7dd, 0x0068, 0x6014, 0x2048, 0xa87c,
+	0xd0e4, 0x1110, 0x080c, 0xb7dd, 0xa867, 0x0103, 0x080c, 0xbccc,
+	0x080c, 0x6536, 0x00d6, 0x2c68, 0x080c, 0x9980, 0x01d0, 0x6003,
+	0x0001, 0x6007, 0x001e, 0x600b, 0xffff, 0x2009, 0x026e, 0x210c,
+	0x613a, 0x2009, 0x026f, 0x210c, 0x613e, 0x6910, 0x6112, 0x080c,
+	0xba69, 0x6954, 0x6156, 0x6023, 0x0001, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x2d60, 0x00de, 0x080c, 0x99d6, 0x009e, 0x0005, 0x6010,
+	0x00b6, 0x2058, 0xb800, 0x00be, 0xd0bc, 0x05a0, 0x6034, 0x908c,
+	0xff00, 0x810f, 0x9186, 0x0035, 0x0130, 0x9186, 0x001e, 0x0118,
+	0x9186, 0x0039, 0x1538, 0x00d6, 0x2c68, 0x080c, 0xbc66, 0x11f0,
+	0x080c, 0x9980, 0x01d8, 0x6106, 0x6003, 0x0001, 0x6023, 0x0001,
+	0x6910, 0x6112, 0x692c, 0x612e, 0x6930, 0x6132, 0x6934, 0x918c,
+	0x00ff, 0x6136, 0x6938, 0x613a, 0x693c, 0x613e, 0x6954, 0x6156,
+	0x080c, 0xba69, 0x080c, 0x8000, 0x080c, 0x8582, 0x2d60, 0x00de,
+	0x0804, 0x99d6, 0x0096, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x01c8,
+	0xa867, 0x0103, 0xa880, 0xd0b4, 0x0128, 0xc0ec, 0xa882, 0xa87b,
+	0x0006, 0x0048, 0xd0bc, 0x0118, 0xa87b, 0x0002, 0x0020, 0xa87b,
+	0x0005, 0x080c, 0xb8e9, 0xa877, 0x0000, 0x080c, 0x6536, 0x080c,
+	0xb7dd, 0x009e, 0x0804, 0x99d6, 0x0016, 0x0096, 0x6014, 0x2048,
+	0x080c, 0xb5fb, 0x0140, 0xa867, 0x0103, 0xa87b, 0x0028, 0xa877,
+	0x0000, 0x080c, 0x6536, 0x009e, 0x001e, 0x9186, 0x0013, 0x0148,
+	0x9186, 0x0014, 0x0130, 0x9186, 0x0027, 0x0118, 0x080c, 0x9a6b,
+	0x0030, 0x080c, 0x847d, 0x080c, 0x9a06, 0x080c, 0x8582, 0x0005,
+	0x0056, 0x0066, 0x0096, 0x00a6, 0x2029, 0x0001, 0x9182, 0x0101,
+	0x1208, 0x0010, 0x2009, 0x0100, 0x2130, 0x8304, 0x9098, 0x0018,
+	0x2009, 0x0020, 0x2011, 0x0029, 0x080c, 0xb219, 0x96b2, 0x0020,
+	0xb004, 0x904d, 0x0110, 0x080c, 0x0f87, 0x080c, 0x0fd5, 0x0520,
+	0x8528, 0xa867, 0x0110, 0xa86b, 0x0000, 0x2920, 0xb406, 0x968a,
+	0x003d, 0x1228, 0x2608, 0x2011, 0x001b, 0x0499, 0x00a8, 0x96b2,
+	0x003c, 0x2009, 0x003c, 0x2950, 0x2011, 0x001b, 0x0451, 0x0c28,
+	0x2001, 0x0205, 0x2003, 0x0000, 0x00ae, 0x852f, 0x95ad, 0x0003,
+	0xb566, 0x95ac, 0x0000, 0x0048, 0x2001, 0x0205, 0x2003, 0x0000,
+	0x00ae, 0x852f, 0x95ad, 0x0003, 0xb566, 0x009e, 0x006e, 0x005e,
+	0x0005, 0x00a6, 0x89ff, 0x0158, 0xa804, 0x9055, 0x0130, 0xa807,
+	0x0000, 0x080c, 0x6536, 0x2a48, 0x0cb8, 0x080c, 0x6536, 0x00ae,
+	0x0005, 0x00f6, 0x2079, 0x0200, 0x7814, 0x9085, 0x0080, 0x7816,
+	0xd184, 0x0108, 0x8108, 0x810c, 0x20a9, 0x0001, 0xa860, 0x20e8,
+	0xa85c, 0x9200, 0x20a0, 0x20e1, 0x0000, 0x2300, 0x9e00, 0x2098,
+	0x4003, 0x8318, 0x9386, 0x0020, 0x1148, 0x2018, 0x2300, 0x9e00,
+	0x2098, 0x7814, 0x8000, 0x9085, 0x0080, 0x7816, 0x8109, 0x1d80,
+	0x7817, 0x0000, 0x00fe, 0x0005, 0x0066, 0x0126, 0x2091, 0x8000,
+	0x2031, 0x0001, 0x6020, 0x9084, 0x000f, 0x0083, 0x012e, 0x006e,
+	0x0005, 0x0126, 0x2091, 0x8000, 0x0066, 0x2031, 0x0000, 0x6020,
+	0x9084, 0x000f, 0x001b, 0x006e, 0x012e, 0x0005, 0xb27f, 0xb27f,
+	0xb27a, 0xb2a1, 0xb26d, 0xb27a, 0xb2a1, 0xb27a, 0xb26d, 0xb26d,
+	0xb27a, 0xb27a, 0xb27a, 0xb26d, 0xb26d, 0x080c, 0x0db2, 0x0036,
+	0x2019, 0x0010, 0x080c, 0xcbad, 0x6023, 0x0006, 0x6003, 0x0007,
+	0x003e, 0x0005, 0x9006, 0x0005, 0x9085, 0x0001, 0x0005, 0x0096,
+	0x86ff, 0x11d8, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x01c0, 0xa864,
+	0x9086, 0x0139, 0x1128, 0xa87b, 0x0005, 0xa883, 0x0000, 0x0028,
+	0x900e, 0x2001, 0x0005, 0x080c, 0x6770, 0x080c, 0xb8e9, 0x080c,
+	0x6529, 0x080c, 0x9a06, 0x9085, 0x0001, 0x009e, 0x0005, 0x9006,
+	0x0ce0, 0x6000, 0x908a, 0x0016, 0x1a0c, 0x0db2, 0x0002, 0xb2b7,
+	0xb2dc, 0xb2b9, 0xb2fd, 0xb2d7, 0xb2b7, 0xb27a, 0xb27f, 0xb27f,
+	0xb27a, 0xb27a, 0xb27a, 0xb27a, 0xb27a, 0xb27a, 0xb27a, 0x080c,
+	0x0db2, 0x86ff, 0x11c8, 0x6020, 0x9086, 0x0006, 0x01a8, 0x0096,
+	0x6014, 0x2048, 0x080c, 0xb5fb, 0x0110, 0x080c, 0xb8e9, 0x009e,
+	0x080c, 0xbca8, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023, 0x0002,
+	0x080c, 0x8000, 0x080c, 0x8582, 0x9085, 0x0001, 0x0005, 0x0066,
+	0x080c, 0x1827, 0x006e, 0x08e8, 0x00e6, 0x2071, 0x19b6, 0x7024,
+	0x9c06, 0x1120, 0x080c, 0x91de, 0x00ee, 0x0898, 0x6020, 0x9084,
+	0x000f, 0x9086, 0x0006, 0x1150, 0x0086, 0x0096, 0x2049, 0x0001,
+	0x2c40, 0x080c, 0x9349, 0x009e, 0x008e, 0x0010, 0x080c, 0x90db,
+	0x00ee, 0x1904, 0xb2b9, 0x0804, 0xb27a, 0x0036, 0x00e6, 0x2071,
+	0x19b6, 0x703c, 0x9c06, 0x1138, 0x901e, 0x080c, 0x9254, 0x00ee,
+	0x003e, 0x0804, 0xb2b9, 0x080c, 0x9479, 0x00ee, 0x003e, 0x1904,
+	0xb2b9, 0x0804, 0xb27a, 0x00c6, 0x6020, 0x9084, 0x000f, 0x0013,
+	0x00ce, 0x0005, 0xb330, 0xb3df, 0xb546, 0xb33a, 0x9a06, 0xb330,
+	0xcb9f, 0xbd0e, 0xb3df, 0xb329, 0xb5c5, 0xb329, 0xb329, 0xb329,
+	0xb329, 0x080c, 0x0db2, 0x080c, 0xb7fa, 0x1110, 0x080c, 0xa364,
+	0x0005, 0x080c, 0x847d, 0x080c, 0x8582, 0x0804, 0x99d6, 0x601b,
+	0x0001, 0x0005, 0x080c, 0xb5fb, 0x0130, 0x6014, 0x0096, 0x2048,
+	0x2c00, 0xa896, 0x009e, 0x6000, 0x908a, 0x0016, 0x1a0c, 0x0db2,
+	0x0002, 0xb359, 0xb35b, 0xb37f, 0xb393, 0xb3b7, 0xb359, 0xb330,
+	0xb330, 0xb330, 0xb393, 0xb393, 0xb359, 0xb359, 0xb359, 0xb359,
+	0xb39d, 0x080c, 0x0db2, 0x00e6, 0x6014, 0x0096, 0x2048, 0xa880,
+	0xc0b5, 0xa882, 0x009e, 0x2071, 0x19b6, 0x7024, 0x9c06, 0x01a0,
+	0x080c, 0x90db, 0x080c, 0xbca8, 0x6007, 0x0085, 0x6003, 0x000b,
+	0x6023, 0x0002, 0x2001, 0x1956, 0x2004, 0x601a, 0x080c, 0x8000,
+	0x080c, 0x8582, 0x00ee, 0x0005, 0x601b, 0x0001, 0x0cd8, 0x0096,
+	0x6014, 0x2048, 0xa880, 0xc0b5, 0xa882, 0x009e, 0x080c, 0xbca8,
+	0x6007, 0x0085, 0x6003, 0x000b, 0x6023, 0x0002, 0x080c, 0x8000,
+	0x080c, 0x8582, 0x0005, 0x0096, 0x601b, 0x0001, 0x6014, 0x2048,
+	0xa880, 0xc0b5, 0xa882, 0x009e, 0x0005, 0x080c, 0x511b, 0x01a8,
+	0x6014, 0x0096, 0x904d, 0x0180, 0xa864, 0xa867, 0x0103, 0xa87b,
+	0x0006, 0x9086, 0x0139, 0x1140, 0xa867, 0x0139, 0xa897, 0x4005,
+	0xa89b, 0x0004, 0x080c, 0x6536, 0x009e, 0x0804, 0x99d6, 0x6014,
+	0x0096, 0x904d, 0x01f8, 0xa97c, 0xd1e4, 0x01e0, 0x2001, 0x180e,
+	0x2004, 0xd0c4, 0x0110, 0x009e, 0x0005, 0xa884, 0x009e, 0x8003,
+	0x800b, 0x810b, 0x9108, 0x611a, 0x2001, 0x0037, 0x2c08, 0x080c,
+	0x14d2, 0x6000, 0x9086, 0x0004, 0x1120, 0x2009, 0x0048, 0x080c,
+	0x9a50, 0x0005, 0x009e, 0x080c, 0x1827, 0x0804, 0xb37f, 0x6000,
+	0x908a, 0x0016, 0x1a0c, 0x0db2, 0x000b, 0x0005, 0xb3f6, 0xb337,
+	0xb3f8, 0xb3f6, 0xb3f8, 0xb3f8, 0xb331, 0xb3f6, 0xb32b, 0xb32b,
+	0xb3f6, 0xb3f6, 0xb3f6, 0xb3f6, 0xb3f6, 0xb3f6, 0x080c, 0x0db2,
+	0x6010, 0x00b6, 0x2058, 0xb804, 0x9084, 0x00ff, 0x00be, 0x908a,
+	0x000c, 0x1a0c, 0x0db2, 0x00b6, 0x0013, 0x00be, 0x0005, 0xb413,
+	0xb4e0, 0xb415, 0xb455, 0xb415, 0xb455, 0xb415, 0xb423, 0xb413,
+	0xb455, 0xb413, 0xb444, 0x080c, 0x0db2, 0x6004, 0x908e, 0x0016,
+	0x05c0, 0x908e, 0x0004, 0x05a8, 0x908e, 0x0002, 0x0590, 0x908e,
+	0x0052, 0x0904, 0xb4dc, 0x6004, 0x080c, 0xb7fa, 0x0904, 0xb4f9,
+	0x908e, 0x0004, 0x1110, 0x080c, 0x2e55, 0x908e, 0x0021, 0x0904,
+	0xb4fd, 0x908e, 0x0022, 0x0904, 0xb541, 0x908e, 0x003d, 0x0904,
+	0xb4fd, 0x908e, 0x0039, 0x0904, 0xb501, 0x908e, 0x0035, 0x0904,
+	0xb501, 0x908e, 0x001e, 0x0178, 0x908e, 0x0001, 0x1140, 0x6010,
+	0x2058, 0xb804, 0x9084, 0x00ff, 0x9086, 0x0006, 0x0110, 0x080c,
+	0x2e30, 0x080c, 0xa364, 0x0804, 0x9a06, 0x00c6, 0x00d6, 0x6104,
+	0x9186, 0x0016, 0x0904, 0xb4cd, 0x9186, 0x0002, 0x1904, 0xb4a2,
+	0x2001, 0x1835, 0x2004, 0xd08c, 0x11c8, 0x080c, 0x6c53, 0x11b0,
+	0x080c, 0xbcec, 0x0138, 0x080c, 0x6c76, 0x1120, 0x080c, 0x6b68,
+	0x0804, 0xb52a, 0x2001, 0x194e, 0x2003, 0x0001, 0x2001, 0x1800,
+	0x2003, 0x0001, 0x080c, 0x6b8a, 0x0804, 0xb52a, 0x6010, 0x2058,
+	0x2001, 0x1835, 0x2004, 0xd0ac, 0x1904, 0xb52a, 0xb8a0, 0x9084,
+	0xff80, 0x1904, 0xb52a, 0xb840, 0x9084, 0x00ff, 0x9005, 0x0190,
+	0x8001, 0xb842, 0x6017, 0x0000, 0x6023, 0x0007, 0x601b, 0x0398,
+	0x6043, 0x0000, 0x080c, 0x9980, 0x0128, 0x2b00, 0x6012, 0x6023,
+	0x0001, 0x0458, 0x00de, 0x00ce, 0x6004, 0x908e, 0x0002, 0x11a0,
+	0x6010, 0x2058, 0xb8a0, 0x9086, 0x007e, 0x1170, 0x2009, 0x1835,
+	0x2104, 0xc085, 0x200a, 0x00e6, 0x2071, 0x1800, 0x080c, 0x59b4,
+	0x00ee, 0x080c, 0xa364, 0x0030, 0x080c, 0xa364, 0x080c, 0x2e30,
+	0x080c, 0xbd01, 0x00e6, 0x0126, 0x2091, 0x8000, 0x080c, 0x2e55,
+	0x012e, 0x00ee, 0x080c, 0x9a06, 0x0005, 0x2001, 0x0002, 0x080c,
+	0x5ecf, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x8048, 0x080c,
+	0x8582, 0x00de, 0x00ce, 0x0c80, 0x080c, 0x2e55, 0x0804, 0xb451,
+	0x00c6, 0x00d6, 0x6104, 0x9186, 0x0016, 0x0d38, 0x6010, 0x2058,
+	0xb840, 0x9084, 0x00ff, 0x9005, 0x0904, 0xb4a2, 0x8001, 0xb842,
+	0x6003, 0x0001, 0x080c, 0x8048, 0x080c, 0x8582, 0x00de, 0x00ce,
+	0x0898, 0x080c, 0xa364, 0x0804, 0xb453, 0x080c, 0xa3a0, 0x0804,
+	0xb453, 0x00d6, 0x2c68, 0x6104, 0x080c, 0xbc66, 0x00de, 0x0118,
+	0x080c, 0x99d6, 0x00f0, 0x6004, 0x8007, 0x6134, 0x918c, 0x00ff,
+	0x9105, 0x6036, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023, 0x0002,
+	0x603c, 0x600a, 0x2001, 0x1956, 0x2004, 0x601a, 0x602c, 0x2c08,
+	0x2060, 0x6024, 0xc0b5, 0x6026, 0x2160, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x0005, 0x00de, 0x00ce, 0x080c, 0xa364, 0x080c, 0x2e30,
+	0x00e6, 0x0126, 0x2091, 0x8000, 0x080c, 0x2e55, 0x6017, 0x0000,
+	0x6023, 0x0007, 0x601b, 0x0398, 0x6043, 0x0000, 0x012e, 0x00ee,
+	0x0005, 0x080c, 0x9e03, 0x1904, 0xb4f9, 0x0005, 0x6000, 0x908a,
+	0x0016, 0x1a0c, 0x0db2, 0x0096, 0x00d6, 0x001b, 0x00de, 0x009e,
+	0x0005, 0xb561, 0xb561, 0xb561, 0xb561, 0xb561, 0xb561, 0xb561,
+	0xb561, 0xb561, 0xb330, 0xb561, 0xb337, 0xb563, 0xb337, 0xb570,
+	0xb561, 0x080c, 0x0db2, 0x6004, 0x9086, 0x008b, 0x0148, 0x6007,
+	0x008b, 0x6003, 0x000d, 0x080c, 0x8000, 0x080c, 0x8582, 0x0005,
+	0x080c, 0xbce0, 0x0118, 0x080c, 0xbcf3, 0x0010, 0x080c, 0xbd01,
+	0x080c, 0xb7dd, 0x080c, 0xb5fb, 0x0570, 0x080c, 0x2e30, 0x080c,
+	0xb5fb, 0x0168, 0x6014, 0x2048, 0xa867, 0x0103, 0xa87b, 0x0006,
+	0xa877, 0x0000, 0xa880, 0xc0ed, 0xa882, 0x080c, 0x6536, 0x2c68,
+	0x080c, 0x9980, 0x0150, 0x6810, 0x6012, 0x080c, 0xba69, 0x00c6,
+	0x2d60, 0x080c, 0x9a06, 0x00ce, 0x0008, 0x2d60, 0x6017, 0x0000,
+	0x6023, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c, 0x8048,
+	0x080c, 0x8582, 0x00c8, 0x080c, 0xbce0, 0x0138, 0x6034, 0x9086,
+	0x4000, 0x1118, 0x080c, 0x2e30, 0x08d0, 0x6034, 0x908c, 0xff00,
+	0x810f, 0x9186, 0x0039, 0x0118, 0x9186, 0x0035, 0x1118, 0x080c,
+	0x2e30, 0x0868, 0x080c, 0x9a06, 0x0005, 0x6000, 0x908a, 0x0016,
+	0x1a0c, 0x0db2, 0x0002, 0xb5db, 0xb5db, 0xb5dd, 0xb5dd, 0xb5dd,
+	0xb5db, 0xb5db, 0x9a06, 0xb5db, 0xb5db, 0xb5db, 0xb5db, 0xb5db,
+	0xb5db, 0xb5db, 0xb5db, 0x080c, 0x0db2, 0x080c, 0x9479, 0x6114,
+	0x0096, 0x2148, 0xa87b, 0x0006, 0x080c, 0x6536, 0x009e, 0x0804,
+	0x99d6, 0x9284, 0x0007, 0x1158, 0x9282, 0x1cd0, 0x0240, 0x2001,
+	0x1818, 0x2004, 0x9202, 0x1218, 0x9085, 0x0001, 0x0005, 0x9006,
+	0x0ce8, 0x0096, 0x0028, 0x0096, 0x0006, 0x6014, 0x2048, 0x000e,
+	0x0006, 0x9984, 0xf000, 0x9086, 0xf000, 0x0110, 0x080c, 0x1080,
+	0x000e, 0x009e, 0x0005, 0x00e6, 0x00c6, 0x0036, 0x0006, 0x0126,
+	0x2091, 0x8000, 0x2061, 0x1cd0, 0x2071, 0x1800, 0x734c, 0x706c,
+	0x9302, 0x1640, 0x6020, 0x9206, 0x11f8, 0x080c, 0xbcec, 0x0180,
+	0x9286, 0x0001, 0x1168, 0x6004, 0x9086, 0x0004, 0x1148, 0x080c,
+	0x2e30, 0x080c, 0xbd01, 0x00c6, 0x080c, 0x9a06, 0x00ce, 0x0060,
+	0x080c, 0xb9e3, 0x0148, 0x080c, 0xb7fa, 0x1110, 0x080c, 0xa364,
+	0x00c6, 0x080c, 0x99d6, 0x00ce, 0x9ce0, 0x0018, 0x7060, 0x9c02,
+	0x1208, 0x08a0, 0x012e, 0x000e, 0x003e, 0x00ce, 0x00ee, 0x0005,
+	0x00e6, 0x00c6, 0x0016, 0x9188, 0x1000, 0x210c, 0x81ff, 0x0128,
+	0x2061, 0x1a73, 0x6112, 0x080c, 0x2e30, 0x9006, 0x0010, 0x9085,
+	0x0001, 0x001e, 0x00ce, 0x00ee, 0x0005, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x9980, 0x01d8, 0x080c, 0x511b, 0x0110, 0x662e,
+	0x0008, 0x6616, 0x2b00, 0x6012, 0x080c, 0x511b, 0x0118, 0x080c,
+	0xb721, 0x0168, 0x080c, 0xba69, 0x6023, 0x0003, 0x2009, 0x004b,
+	0x080c, 0x9a50, 0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006,
+	0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0xbaa0, 0x080c, 0x9a23,
+	0x0590, 0x080c, 0x511b, 0x0118, 0x602f, 0x0000, 0x0010, 0x6017,
+	0x0000, 0x2b00, 0x6012, 0x080c, 0xba69, 0x6023, 0x0003, 0x0016,
+	0x080c, 0x8180, 0x0076, 0x903e, 0x080c, 0x8078, 0x2c08, 0x080c,
+	0xcd62, 0x007e, 0x001e, 0xd184, 0x0128, 0x080c, 0x99d6, 0x9085,
+	0x0001, 0x0070, 0x080c, 0x511b, 0x0128, 0xd18c, 0x1170, 0x080c,
+	0xb721, 0x0148, 0x2009, 0x004c, 0x080c, 0x9a50, 0x9085, 0x0001,
+	0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x2900, 0x6016, 0x0c90,
+	0x2009, 0x004d, 0x0010, 0x2009, 0x004e, 0x00f6, 0x00c6, 0x0046,
+	0x0016, 0x080c, 0x9980, 0x2c78, 0x01d8, 0x080c, 0x511b, 0x0110,
+	0x7e2e, 0x0008, 0x7e16, 0x2b00, 0x7812, 0x7823, 0x0003, 0x2021,
+	0x0005, 0x080c, 0xb733, 0x2f60, 0x080c, 0x511b, 0x0118, 0x080c,
+	0xb721, 0x0130, 0x001e, 0x0016, 0x080c, 0x9a50, 0x9085, 0x0001,
+	0x001e, 0x004e, 0x00ce, 0x00fe, 0x0005, 0x00f6, 0x00c6, 0x0046,
+	0x080c, 0x9980, 0x2c78, 0x0530, 0x080c, 0x511b, 0x0110, 0x7e2e,
+	0x0008, 0x7e16, 0x2b00, 0x7812, 0x7823, 0x0003, 0x0096, 0x2021,
+	0x0004, 0x0489, 0x009e, 0x2001, 0x194f, 0x200c, 0xd1fc, 0x0120,
+	0x2f60, 0x080c, 0x99d6, 0x0060, 0x2f60, 0x080c, 0x511b, 0x0120,
+	0xd18c, 0x1160, 0x0071, 0x0130, 0x2009, 0x0052, 0x080c, 0x9a50,
+	0x9085, 0x0001, 0x004e, 0x00ce, 0x00fe, 0x0005, 0x2900, 0x7816,
+	0x0c98, 0x00c6, 0x080c, 0x4612, 0x00ce, 0x1120, 0x080c, 0x99d6,
+	0x9006, 0x0005, 0xa867, 0x0000, 0xa86b, 0x8000, 0x2900, 0x6016,
+	0x9085, 0x0001, 0x0005, 0x0096, 0x0076, 0x0126, 0x2091, 0x8000,
+	0x080c, 0x60b2, 0x0158, 0x2001, 0xb738, 0x0006, 0x900e, 0x2400,
+	0x080c, 0x6770, 0x080c, 0x6536, 0x000e, 0x0807, 0x2418, 0x080c,
+	0x8417, 0xbaa0, 0x0086, 0x2041, 0x0001, 0x2039, 0x0001, 0x2608,
+	0x080c, 0x8198, 0x008e, 0x080c, 0x8078, 0x2f08, 0x2648, 0x080c,
+	0xcd62, 0xb93c, 0x81ff, 0x090c, 0x8269, 0x080c, 0x8582, 0x012e,
+	0x007e, 0x009e, 0x0005, 0x00c6, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x9980, 0x0190, 0x660a, 0x2b08, 0x6112, 0x080c, 0xba69, 0x6023,
+	0x0001, 0x2900, 0x6016, 0x2009, 0x001f, 0x080c, 0x9a50, 0x9085,
+	0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x00c6, 0x0126,
+	0x2091, 0x8000, 0x080c, 0x9a23, 0x01b8, 0x660a, 0x2b08, 0x6112,
+	0x080c, 0xba69, 0x6023, 0x0008, 0x2900, 0x6016, 0x00f6, 0x2c78,
+	0x080c, 0x1582, 0x00fe, 0x2009, 0x0021, 0x080c, 0x9a50, 0x9085,
+	0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x2009, 0x003d,
+	0x00c6, 0x0126, 0x0016, 0x2091, 0x8000, 0x080c, 0x9980, 0x0198,
+	0x660a, 0x2b08, 0x6112, 0x080c, 0xba69, 0x6023, 0x0001, 0x2900,
+	0x6016, 0x001e, 0x0016, 0x080c, 0x9a50, 0x9085, 0x0001, 0x001e,
+	0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd0, 0x00c6, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x9a23, 0x0188, 0x2b08, 0x6112, 0x080c, 0xba69,
+	0x6023, 0x0001, 0x2900, 0x6016, 0x2009, 0x0000, 0x080c, 0x9a50,
+	0x9085, 0x0001, 0x012e, 0x00ce, 0x0005, 0x9006, 0x0cd8, 0x2009,
+	0x0044, 0x0830, 0x2009, 0x0049, 0x0818, 0x0026, 0x00b6, 0x6210,
+	0x2258, 0xba3c, 0x82ff, 0x0110, 0x8211, 0xba3e, 0x00be, 0x002e,
+	0x0005, 0x0006, 0x0016, 0x6004, 0x908e, 0x0002, 0x0140, 0x908e,
+	0x0003, 0x0128, 0x908e, 0x0004, 0x0110, 0x9085, 0x0001, 0x001e,
+	0x000e, 0x0005, 0x0006, 0x0096, 0x6020, 0x9086, 0x0004, 0x0190,
+	0x6014, 0x904d, 0x080c, 0xb5fb, 0x0168, 0xa864, 0x9086, 0x0139,
+	0x0158, 0x6020, 0x9086, 0x0003, 0x0128, 0xa868, 0xd0fc, 0x0110,
+	0x9006, 0x0010, 0x9085, 0x0001, 0x009e, 0x000e, 0x0005, 0x00c6,
+	0x0126, 0x2091, 0x8000, 0x080c, 0x9a23, 0x0198, 0x2b08, 0x6112,
+	0x080c, 0xba69, 0x6023, 0x0001, 0x2900, 0x6016, 0x080c, 0x2e30,
+	0x2009, 0x0028, 0x080c, 0x9a50, 0x9085, 0x0001, 0x012e, 0x00ce,
+	0x0005, 0x9006, 0x0cd8, 0x9186, 0x0015, 0x11a8, 0x2011, 0x1822,
+	0x2204, 0x9086, 0x0074, 0x1178, 0x00b6, 0x080c, 0xa5aa, 0x00be,
+	0x080c, 0xa7a4, 0x6003, 0x0001, 0x6007, 0x0029, 0x080c, 0x8048,
+	0x080c, 0x8582, 0x0078, 0x6014, 0x0096, 0x2048, 0xa868, 0x009e,
+	0xd0fc, 0x0148, 0x2001, 0x0001, 0x080c, 0xbc27, 0x080c, 0xa364,
+	0x080c, 0x99d6, 0x0005, 0x0096, 0x6014, 0x904d, 0x090c, 0x0db2,
+	0xa87b, 0x0030, 0xa883, 0x0000, 0xa897, 0x4005, 0xa89b, 0x0004,
+	0xa867, 0x0139, 0x0126, 0x2091, 0x8000, 0x080c, 0x6536, 0x012e,
+	0x009e, 0x080c, 0x99d6, 0x0c30, 0x0096, 0x9186, 0x0016, 0x1128,
+	0x2001, 0x0004, 0x080c, 0x5ecf, 0x00e8, 0x9186, 0x0015, 0x1510,
+	0x2011, 0x1822, 0x2204, 0x9086, 0x0014, 0x11e0, 0x6010, 0x00b6,
+	0x2058, 0x080c, 0x6019, 0x00be, 0x080c, 0xa875, 0x1198, 0x6010,
+	0x00b6, 0x2058, 0xb890, 0x00be, 0x9005, 0x0160, 0x2001, 0x0006,
+	0x080c, 0x5ecf, 0x6014, 0x2048, 0xa868, 0xd0fc, 0x0170, 0x080c,
+	0x9dd7, 0x0048, 0x6014, 0x2048, 0xa868, 0xd0fc, 0x0528, 0x080c,
+	0xa364, 0x080c, 0x99d6, 0x009e, 0x0005, 0x6014, 0x6310, 0x2358,
+	0x904d, 0x090c, 0x0db2, 0xa87b, 0x0000, 0xa883, 0x0000, 0xa897,
+	0x4000, 0x900e, 0x080c, 0x619e, 0x1108, 0xc185, 0xb800, 0xd0bc,
+	0x0108, 0xc18d, 0xa99a, 0x0126, 0x2091, 0x8000, 0x080c, 0x6536,
+	0x012e, 0x080c, 0x99d6, 0x08f8, 0x6014, 0x904d, 0x090c, 0x0db2,
+	0xa87b, 0x0030, 0xa883, 0x0000, 0xa897, 0x4005, 0xa89b, 0x0004,
+	0xa867, 0x0139, 0x0126, 0x2091, 0x8000, 0x080c, 0x6536, 0x012e,
+	0x080c, 0x99d6, 0x0840, 0xa878, 0x9086, 0x0005, 0x1108, 0x0009,
+	0x0005, 0xa880, 0xc0ad, 0xa882, 0x0005, 0x6043, 0x0000, 0x6017,
+	0x0000, 0x6003, 0x0001, 0x6007, 0x0050, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x0005, 0x00c6, 0x6010, 0x00b6, 0x2058, 0xb800, 0x00be,
+	0xd0bc, 0x0120, 0x6020, 0x9084, 0x000f, 0x0013, 0x00ce, 0x0005,
+	0xb330, 0xb919, 0xb919, 0xb91c, 0xd030, 0xd04b, 0xd04e, 0xb330,
+	0xb330, 0xb330, 0xb330, 0xb330, 0xb330, 0xb330, 0xb330, 0x080c,
+	0x0db2, 0xa001, 0xa001, 0x0005, 0x0096, 0x6014, 0x904d, 0x0118,
+	0xa87c, 0xd0e4, 0x1110, 0x009e, 0x0010, 0x009e, 0x0005, 0x6010,
+	0x00b6, 0x2058, 0xb800, 0x00be, 0xd0bc, 0x0550, 0x2001, 0x1832,
+	0x2004, 0x9005, 0x1540, 0x00f6, 0x2c78, 0x080c, 0x9980, 0x0508,
+	0x7810, 0x6012, 0x080c, 0xba69, 0x7820, 0x9086, 0x0003, 0x0128,
+	0x7808, 0x603a, 0x2f00, 0x603e, 0x0020, 0x7808, 0x603e, 0x2f00,
+	0x603a, 0x602e, 0x6023, 0x0001, 0x6007, 0x0035, 0x6003, 0x0001,
+	0x7954, 0x6156, 0x080c, 0x8000, 0x080c, 0x8582, 0x2f60, 0x00fe,
+	0x0005, 0x2f60, 0x00fe, 0x2001, 0x1957, 0x2004, 0x6042, 0x0005,
+	0x0016, 0x0096, 0x6814, 0x2048, 0xa87c, 0xd0e4, 0x0180, 0xc0e4,
+	0xa87e, 0xa877, 0x0000, 0xa893, 0x0000, 0xa88f, 0x0000, 0xd0cc,
+	0x0130, 0xc0cc, 0xa87e, 0xa878, 0x2048, 0x080c, 0x0f87, 0x6830,
+	0x6036, 0x908e, 0x0001, 0x0148, 0x6803, 0x0002, 0x9086, 0x0005,
+	0x0170, 0x9006, 0x602e, 0x6032, 0x00d0, 0x681c, 0xc085, 0x681e,
+	0x6803, 0x0004, 0x6824, 0xc0f4, 0x9085, 0x0c00, 0x6826, 0x6814,
+	0x2048, 0xa8ac, 0x6938, 0x9102, 0xa8b0, 0x693c, 0x9103, 0x1e48,
+	0x683c, 0x602e, 0x6838, 0x9084, 0xfffc, 0x683a, 0x6032, 0x2d00,
+	0x603a, 0x6808, 0x603e, 0x6910, 0x6112, 0x6954, 0x6156, 0x6023,
+	0x0001, 0x6007, 0x0039, 0x6003, 0x0001, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x009e, 0x001e, 0x0005, 0x6024, 0xd0d4, 0x0510, 0xd0f4,
+	0x11f8, 0x6038, 0x940a, 0x603c, 0x9303, 0x0230, 0x9105, 0x0120,
+	0x6024, 0xc0d4, 0xc0f5, 0x0098, 0x643a, 0x633e, 0xac3e, 0xab42,
+	0x0046, 0x0036, 0x2400, 0xacac, 0x9402, 0xa836, 0x2300, 0xabb0,
+	0x9303, 0xa83a, 0x003e, 0x004e, 0x6024, 0xc0d4, 0x0000, 0x6026,
+	0x0005, 0xd0f4, 0x1138, 0xa83c, 0x603a, 0xa840, 0x603e, 0x6024,
+	0xc0f5, 0x6026, 0x0005, 0x0006, 0x0016, 0x6004, 0x908e, 0x0034,
+	0x01b8, 0x908e, 0x0035, 0x01a0, 0x908e, 0x0036, 0x0188, 0x908e,
+	0x0037, 0x0170, 0x908e, 0x0038, 0x0158, 0x908e, 0x0039, 0x0140,
+	0x908e, 0x003a, 0x0128, 0x908e, 0x003b, 0x0110, 0x9085, 0x0001,
+	0x001e, 0x000e, 0x0005, 0x0006, 0x0016, 0x0026, 0x0036, 0x00e6,
+	0x2001, 0x1951, 0x200c, 0x8000, 0x2014, 0x2001, 0x0032, 0x080c,
+	0x7e7f, 0x2001, 0x1955, 0x82ff, 0x1110, 0x2011, 0x0014, 0x2202,
+	0x2001, 0x1953, 0x200c, 0x8000, 0x2014, 0x2071, 0x193d, 0x711a,
+	0x721e, 0x2001, 0x0064, 0x080c, 0x7e7f, 0x2001, 0x1956, 0x82ff,
+	0x1110, 0x2011, 0x0014, 0x2202, 0x2001, 0x1957, 0x9288, 0x000a,
+	0x2102, 0x2001, 0x1a55, 0x2102, 0x2001, 0x0032, 0x080c, 0x14d2,
+	0x080c, 0x6285, 0x00ee, 0x003e, 0x002e, 0x001e, 0x000e, 0x0005,
+	0x0006, 0x0016, 0x00e6, 0x2001, 0x1955, 0x2003, 0x0028, 0x2001,
+	0x1956, 0x2003, 0x0014, 0x2071, 0x193d, 0x701b, 0x0000, 0x701f,
+	0x07d0, 0x2001, 0x1957, 0x2009, 0x001e, 0x2102, 0x2001, 0x1a55,
+	0x2102, 0x2001, 0x0032, 0x080c, 0x14d2, 0x00ee, 0x001e, 0x000e,
+	0x0005, 0x0096, 0x6058, 0x904d, 0x0110, 0x080c, 0x1007, 0x009e,
+	0x0005, 0x0005, 0x00c6, 0x0126, 0x2091, 0x8000, 0x080c, 0x9980,
+	0x0180, 0x2b08, 0x6112, 0x0ca9, 0x6023, 0x0001, 0x2900, 0x6016,
+	0x2009, 0x0033, 0x080c, 0x9a50, 0x9085, 0x0001, 0x012e, 0x00ce,
+	0x0005, 0x9006, 0x0cd8, 0x0096, 0x00e6, 0x00f6, 0x2071, 0x1800,
+	0x9186, 0x0015, 0x1500, 0x7088, 0x9086, 0x0018, 0x11e0, 0x6014,
+	0x2048, 0xaa3c, 0xd2e4, 0x1160, 0x2c78, 0x080c, 0x8772, 0x01d8,
+	0x7074, 0xaa50, 0x9206, 0x1160, 0x7078, 0xaa54, 0x9206, 0x1140,
+	0x6210, 0x00b6, 0x2258, 0xbaa0, 0x00be, 0x900e, 0x080c, 0x2e75,
+	0x080c, 0x9dd7, 0x0020, 0x080c, 0xa364, 0x080c, 0x99d6, 0x00fe,
+	0x00ee, 0x009e, 0x0005, 0x7058, 0xaa54, 0x9206, 0x0d48, 0x0c80,
+	0x00c6, 0x0126, 0x2091, 0x8000, 0x080c, 0x9980, 0x0188, 0x2b08,
+	0x6112, 0x080c, 0xba69, 0x6023, 0x0001, 0x2900, 0x6016, 0x2009,
+	0x004d, 0x080c, 0x9a50, 0x9085, 0x0001, 0x012e, 0x00ce, 0x0005,
+	0x9006, 0x0cd8, 0x00c6, 0x0126, 0x2091, 0x8000, 0x0016, 0x080c,
+	0x9980, 0x0180, 0x2b08, 0x6112, 0x080c, 0xba69, 0x6023, 0x0001,
+	0x2900, 0x6016, 0x001e, 0x080c, 0x9a50, 0x9085, 0x0001, 0x012e,
+	0x00ce, 0x0005, 0x001e, 0x9006, 0x0cd0, 0x0016, 0x0026, 0x0036,
+	0x0046, 0x0056, 0x0066, 0x0096, 0x00e6, 0x00f6, 0x2071, 0x1800,
+	0x9186, 0x0015, 0x1568, 0x7188, 0x6014, 0x2048, 0xa814, 0x8003,
+	0x9106, 0x1530, 0x20e1, 0x0000, 0x2001, 0x196f, 0x2003, 0x0000,
+	0x6014, 0x2048, 0xa830, 0x20a8, 0x8906, 0x8006, 0x8007, 0x9094,
+	0x003f, 0x22e8, 0x9084, 0xffc0, 0x9080, 0x001b, 0x20a0, 0x2001,
+	0x196f, 0x0016, 0x200c, 0x080c, 0xc29a, 0x001e, 0xa804, 0x9005,
+	0x0110, 0x2048, 0x0c38, 0x6014, 0x2048, 0xa867, 0x0103, 0x0010,
+	0x080c, 0xa364, 0x080c, 0x99d6, 0x00fe, 0x00ee, 0x009e, 0x006e,
+	0x005e, 0x004e, 0x003e, 0x002e, 0x001e, 0x0005, 0x0096, 0x00e6,
+	0x00f6, 0x2071, 0x1800, 0x9186, 0x0015, 0x11b8, 0x7088, 0x9086,
+	0x0004, 0x1198, 0x6014, 0x2048, 0x2c78, 0x080c, 0x8772, 0x01a8,
+	0x7074, 0xaa74, 0x9206, 0x1130, 0x7078, 0xaa78, 0x9206, 0x1110,
+	0x080c, 0x2e30, 0x080c, 0x9dd7, 0x0020, 0x080c, 0xa364, 0x080c,
+	0x99d6, 0x00fe, 0x00ee, 0x009e, 0x0005, 0x7058, 0xaa78, 0x9206,
+	0x0d78, 0x0c80, 0x0096, 0x00e6, 0x00f6, 0x2071, 0x1800, 0x9186,
+	0x0015, 0x1550, 0x7088, 0x9086, 0x0004, 0x1530, 0x6014, 0x2048,
+	0x2c78, 0x080c, 0x8772, 0x05e8, 0x7074, 0xaacc, 0x9206, 0x1180,
+	0x7078, 0xaad0, 0x9206, 0x1160, 0x080c, 0x2e30, 0x0016, 0xa998,
+	0xaab0, 0x9284, 0x1000, 0xc0fd, 0x080c, 0x50cb, 0x001e, 0x0010,
+	0x080c, 0x4ebc, 0x080c, 0xb5fb, 0x0500, 0xa87b, 0x0000, 0xa883,
+	0x0000, 0xa897, 0x4000, 0x0078, 0x080c, 0x4ebc, 0x080c, 0xb5fb,
+	0x01a0, 0x6014, 0x2048, 0xa87b, 0x0030, 0xa883, 0x0000, 0xa897,
+	0x4005, 0xa89b, 0x0004, 0x0126, 0x2091, 0x8000, 0xa867, 0x0139,
+	0x080c, 0x6536, 0x012e, 0x080c, 0x99d6, 0x00fe, 0x00ee, 0x009e,
+	0x0005, 0x7058, 0xaad0, 0x9206, 0x0938, 0x0890, 0x0016, 0x0026,
+	0xa87c, 0xd0ac, 0x0178, 0xa938, 0xaa34, 0x2100, 0x9205, 0x0150,
+	0xa890, 0x9106, 0x1118, 0xa88c, 0x9206, 0x0120, 0xa992, 0xaa8e,
+	0x9085, 0x0001, 0x002e, 0x001e, 0x0005, 0x00b6, 0x00d6, 0x0036,
+	0x080c, 0xb5fb, 0x0904, 0xbc23, 0x0096, 0x6314, 0x2348, 0xa87a,
+	0xa982, 0x929e, 0x4000, 0x1580, 0x6310, 0x00c6, 0x2358, 0x2009,
+	0x0000, 0xa868, 0xd0f4, 0x1140, 0x080c, 0x619e, 0x1108, 0xc185,
+	0xb800, 0xd0bc, 0x0108, 0xc18d, 0xaa96, 0xa99a, 0x20a9, 0x0004,
+	0xa860, 0x20e8, 0xa85c, 0x9080, 0x0031, 0x20a0, 0xb8b4, 0x20e0,
+	0xb8b8, 0x9080, 0x0006, 0x2098, 0x080c, 0x0f52, 0x20a9, 0x0004,
+	0xa85c, 0x9080, 0x0035, 0x20a0, 0xb8b8, 0x9080, 0x000a, 0x2098,
+	0x080c, 0x0f52, 0x00ce, 0x0090, 0xaa96, 0x3918, 0x9398, 0x0007,
+	0x231c, 0x6004, 0x9086, 0x0016, 0x0110, 0xa89b, 0x0004, 0xaba2,
+	0x6310, 0x2358, 0xb804, 0x9084, 0x00ff, 0xa89e, 0x080c, 0x6529,
+	0x6017, 0x0000, 0x009e, 0x003e, 0x00de, 0x00be, 0x0005, 0x0026,
+	0x0036, 0x0046, 0x00b6, 0x0096, 0x00f6, 0x6214, 0x2248, 0x6210,
+	0x2258, 0x2079, 0x0260, 0x9096, 0x0000, 0x11a0, 0xb814, 0x9084,
+	0x00ff, 0x900e, 0x080c, 0x24d6, 0x2118, 0x831f, 0x939c, 0xff00,
+	0x7838, 0x9084, 0x00ff, 0x931d, 0x7c3c, 0x2011, 0x8018, 0x080c,
+	0x4672, 0x00a8, 0x9096, 0x0001, 0x1148, 0x89ff, 0x0180, 0xa89b,
+	0x000d, 0x7838, 0xa8a6, 0x783c, 0xa8aa, 0x0048, 0x9096, 0x0002,
+	0x1130, 0xa89b, 0x000d, 0x7838, 0xa8a6, 0x783c, 0xa8aa, 0x00fe,
+	0x009e, 0x00be, 0x004e, 0x003e, 0x002e, 0x0005, 0x00c6, 0x0026,
+	0x0016, 0x9186, 0x0035, 0x0110, 0x6a38, 0x0008, 0x6a2c, 0x080c,
+	0xb5e9, 0x01f0, 0x2260, 0x6120, 0x9186, 0x0003, 0x0118, 0x9186,
+	0x0006, 0x1190, 0x6838, 0x9206, 0x0140, 0x683c, 0x9206, 0x1160,
+	0x6108, 0x6838, 0x9106, 0x1140, 0x0020, 0x6008, 0x693c, 0x9106,
+	0x1118, 0x6010, 0x6910, 0x9106, 0x001e, 0x002e, 0x00ce, 0x0005,
+	0x9085, 0x0001, 0x0cc8, 0xa974, 0xd1cc, 0x0188, 0x918c, 0x00ff,
+	0x918e, 0x0002, 0x1160, 0xa9a8, 0x918c, 0x0f00, 0x810f, 0x918e,
+	0x0001, 0x1128, 0xa834, 0xa938, 0x9115, 0x190c, 0xad37, 0x0005,
+	0x0036, 0x2019, 0x0001, 0x0010, 0x0036, 0x901e, 0x0489, 0x01d0,
+	0x080c, 0xb5fb, 0x01b8, 0x6037, 0x4000, 0x6014, 0x6017, 0x0000,
+	0x0096, 0x2048, 0xa87c, 0x080c, 0xb7fa, 0x1118, 0x080c, 0xa364,
+	0x0040, 0xa867, 0x0103, 0xa877, 0x0000, 0x83ff, 0x1129, 0x080c,
+	0x6536, 0x009e, 0x003e, 0x0005, 0xa880, 0xd0b4, 0x0128, 0xa87b,
+	0x0006, 0xc0ec, 0xa882, 0x0048, 0xd0bc, 0x0118, 0xa87b, 0x0002,
+	0x0020, 0xa87b, 0x0005, 0x080c, 0xb8e9, 0xa877, 0x0000, 0x0005,
+	0x2001, 0x180f, 0x2004, 0xd0ec, 0x0005, 0x0006, 0x2001, 0x180f,
+	0x2004, 0xd0f4, 0x000e, 0x0005, 0x0006, 0x2001, 0x180f, 0x2004,
+	0xd0e4, 0x000e, 0x0005, 0x0036, 0x0046, 0x6010, 0x00b6, 0x2058,
+	0xbba0, 0x00be, 0x2021, 0x0007, 0x080c, 0x4829, 0x004e, 0x003e,
+	0x0005, 0x0c51, 0x1d81, 0x0005, 0x2001, 0x1955, 0x2004, 0x601a,
+	0x0005, 0x2001, 0x1957, 0x2004, 0x6042, 0x0005, 0x080c, 0x99d6,
+	0x0804, 0x8582, 0x00b6, 0x0066, 0x6000, 0x90b2, 0x0016, 0x1a0c,
+	0x0db2, 0x001b, 0x006e, 0x00be, 0x0005, 0xbd2d, 0xc3f7, 0xc552,
+	0xbd2d, 0xbd2d, 0xbd2d, 0xbd2d, 0xbd2d, 0xbd64, 0xc5d0, 0xbd2d,
+	0xbd2d, 0xbd2d, 0xbd2d, 0xbd2d, 0xbd2d, 0x080c, 0x0db2, 0x0066,
+	0x6000, 0x90b2, 0x0016, 0x1a0c, 0x0db2, 0x0013, 0x006e, 0x0005,
+	0xbd48, 0xcb38, 0xbd48, 0xbd48, 0xbd48, 0xbd48, 0xbd48, 0xbd48,
+	0xcae5, 0xcb8c, 0xbd48, 0xd16d, 0xd1a3, 0xd16d, 0xd1a3, 0xbd48,
+	0x080c, 0x0db2, 0x6000, 0x9082, 0x0016, 0x1a0c, 0x0db2, 0x6000,
+	0x000a, 0x0005, 0xbd62, 0xc7ad, 0xc89d, 0xc8bf, 0xc97e, 0xbd62,
+	0xca5c, 0xca06, 0xc5dc, 0xcabb, 0xcad0, 0xbd62, 0xbd62, 0xbd62,
+	0xbd62, 0xbd62, 0x080c, 0x0db2, 0x91b2, 0x0053, 0x1a0c, 0x0db2,
+	0x2100, 0x91b2, 0x0040, 0x1a04, 0xc19a, 0x0002, 0xbdae, 0xbf8b,
+	0xbdae, 0xbdae, 0xbdae, 0xbf94, 0xbdae, 0xbdae, 0xbdae, 0xbdae,
+	0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae,
+	0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdb0, 0xbe06, 0xbe15,
+	0xbe79, 0xbea4, 0xbf1d, 0xbf76, 0xbdae, 0xbdae, 0xbf97, 0xbdae,
+	0xbdae, 0xbfac, 0xbfb9, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae,
+	0xc03c, 0xbdae, 0xbdae, 0xc050, 0xbdae, 0xbdae, 0xc00b, 0xbdae,
+	0xbdae, 0xbdae, 0xc068, 0xbdae, 0xbdae, 0xbdae, 0xc0e5, 0xbdae,
+	0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xbdae, 0xc162, 0x080c, 0x0db2,
+	0x080c, 0x6262, 0x1150, 0x2001, 0x1835, 0x2004, 0xd0cc, 0x1128,
+	0x9084, 0x0009, 0x9086, 0x0008, 0x1140, 0x6007, 0x0009, 0x602f,
+	0x0009, 0x6017, 0x0000, 0x0804, 0xbf84, 0x080c, 0x624b, 0x00e6,
+	0x00c6, 0x0036, 0x0026, 0x0016, 0x6210, 0x2258, 0xbaa0, 0x0026,
+	0x2019, 0x0029, 0x080c, 0x8180, 0x0076, 0x903e, 0x080c, 0x8078,
+	0x2c08, 0x080c, 0xcd62, 0x007e, 0x001e, 0x001e, 0x002e, 0x003e,
+	0x00ce, 0x00ee, 0x6610, 0x2658, 0x080c, 0x5f8d, 0xbe04, 0x9684,
+	0x00ff, 0x9082, 0x0006, 0x0278, 0x080c, 0xcc94, 0x1904, 0xbe71,
+	0x080c, 0xcc30, 0x1120, 0x6007, 0x0008, 0x0804, 0xbf84, 0x6007,
+	0x0009, 0x0804, 0xbf84, 0x080c, 0xce81, 0x0128, 0x080c, 0xcc94,
+	0x0d78, 0x0804, 0xbe71, 0x6017, 0x1900, 0x0c88, 0x080c, 0x2f50,
+	0x1904, 0xc197, 0x6106, 0x080c, 0xcbe7, 0x6007, 0x0006, 0x0804,
+	0xbf84, 0x6007, 0x0007, 0x0804, 0xbf84, 0x080c, 0xd1df, 0x1904,
+	0xc197, 0x080c, 0x2f50, 0x1904, 0xc197, 0x00d6, 0x6610, 0x2658,
+	0xbe04, 0x9684, 0x00ff, 0x9082, 0x0006, 0x1220, 0x2001, 0x0001,
+	0x080c, 0x5ebb, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0006, 0x0188,
+	0x9686, 0x0004, 0x0170, 0xbe04, 0x96b4, 0x00ff, 0x9686, 0x0006,
+	0x0140, 0x9686, 0x0004, 0x0128, 0x9686, 0x0005, 0x0110, 0x00de,
+	0x0480, 0x00e6, 0x2071, 0x0260, 0x7034, 0x9084, 0x0003, 0x1140,
+	0x7034, 0x9082, 0x0014, 0x0220, 0x7030, 0x9084, 0x0003, 0x0130,
+	0x00ee, 0x6017, 0x0000, 0x602f, 0x0007, 0x00b0, 0x00ee, 0x080c,
+	0xccf8, 0x1190, 0x9686, 0x0006, 0x1140, 0x0026, 0x6210, 0x2258,
+	0xbaa0, 0x900e, 0x080c, 0x2e75, 0x002e, 0x080c, 0x6019, 0x6007,
+	0x000a, 0x00de, 0x0804, 0xbf84, 0x6007, 0x000b, 0x00de, 0x0804,
+	0xbf84, 0x080c, 0x2e30, 0x080c, 0xbd01, 0x6007, 0x0001, 0x0804,
+	0xbf84, 0x080c, 0xd1df, 0x1904, 0xc197, 0x080c, 0x2f50, 0x1904,
+	0xc197, 0x2071, 0x0260, 0x7034, 0x90b4, 0x0003, 0x1948, 0x90b2,
+	0x0014, 0x0a30, 0x7030, 0x9084, 0x0003, 0x1910, 0x6610, 0x2658,
+	0xbe04, 0x9686, 0x0707, 0x09e8, 0x0026, 0x6210, 0x2258, 0xbaa0,
+	0x900e, 0x080c, 0x2e75, 0x002e, 0x6007, 0x000c, 0x2001, 0x0001,
+	0x080c, 0xd2fb, 0x0804, 0xbf84, 0x080c, 0x6262, 0x1140, 0x2001,
+	0x1835, 0x2004, 0x9084, 0x0009, 0x9086, 0x0008, 0x1110, 0x0804,
+	0xbdbd, 0x080c, 0x624b, 0x6610, 0x2658, 0xbe04, 0x9684, 0x00ff,
+	0x9082, 0x0006, 0x06c8, 0x1138, 0x0026, 0x2001, 0x0006, 0x080c,
+	0x5efb, 0x002e, 0x0050, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0004,
+	0x0120, 0x9686, 0x0006, 0x1904, 0xbe71, 0x080c, 0xcd05, 0x1120,
+	0x6007, 0x000e, 0x0804, 0xbf84, 0x0046, 0x6410, 0x2458, 0xbca0,
+	0x0046, 0x080c, 0x2e30, 0x080c, 0xbd01, 0x004e, 0x0016, 0x9006,
+	0x2009, 0x1854, 0x210c, 0xd1a4, 0x0148, 0x2009, 0x0029, 0x080c,
+	0xcfe6, 0x6010, 0x2058, 0xb800, 0xc0e5, 0xb802, 0x001e, 0x004e,
+	0x6007, 0x0001, 0x0804, 0xbf84, 0x2001, 0x0001, 0x080c, 0x5ebb,
+	0x0156, 0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0x1805,
+	0x2011, 0x0270, 0x080c, 0xa909, 0x003e, 0x002e, 0x001e, 0x015e,
+	0x9005, 0x0168, 0x96b4, 0xff00, 0x8637, 0x9682, 0x0004, 0x0a04,
+	0xbe71, 0x9682, 0x0007, 0x0a04, 0xbecd, 0x0804, 0xbe71, 0x6017,
+	0x1900, 0x6007, 0x0009, 0x0804, 0xbf84, 0x080c, 0x6262, 0x1140,
+	0x2001, 0x1835, 0x2004, 0x9084, 0x0009, 0x9086, 0x0008, 0x1110,
+	0x0804, 0xbdbd, 0x080c, 0x624b, 0x6610, 0x2658, 0xbe04, 0x9684,
+	0x00ff, 0x9082, 0x0006, 0x0690, 0x96b4, 0xff00, 0x8637, 0x9686,
+	0x0004, 0x0120, 0x9686, 0x0006, 0x1904, 0xbe71, 0x080c, 0xcd33,
+	0x1130, 0x080c, 0xcc30, 0x1118, 0x6007, 0x0010, 0x04e8, 0x0046,
+	0x6410, 0x2458, 0xbca0, 0x0046, 0x080c, 0x2e30, 0x080c, 0xbd01,
+	0x004e, 0x0016, 0x9006, 0x2009, 0x1854, 0x210c, 0xd1a4, 0x0148,
+	0x2009, 0x0029, 0x080c, 0xcfe6, 0x6010, 0x2058, 0xb800, 0xc0e5,
+	0xb802, 0x001e, 0x004e, 0x6007, 0x0001, 0x00f0, 0x080c, 0xce81,
+	0x0140, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0006, 0x0978, 0x0804,
+	0xbe71, 0x6017, 0x1900, 0x6007, 0x0009, 0x0070, 0x080c, 0x2f50,
+	0x1904, 0xc197, 0x080c, 0xd1df, 0x1904, 0xc197, 0x080c, 0xc335,
+	0x1904, 0xbe71, 0x6007, 0x0012, 0x6003, 0x0001, 0x080c, 0x8048,
+	0x080c, 0x8582, 0x0005, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x080c, 0x8582, 0x0cb0, 0x6007, 0x0005, 0x0c68, 0x080c,
+	0xd1df, 0x1904, 0xc197, 0x080c, 0x2f50, 0x1904, 0xc197, 0x080c,
+	0xc335, 0x1904, 0xbe71, 0x6007, 0x0020, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x080c, 0x8582, 0x0005, 0x080c, 0x2f50, 0x1904, 0xc197,
+	0x6007, 0x0023, 0x6003, 0x0001, 0x080c, 0x8048, 0x080c, 0x8582,
+	0x0005, 0x080c, 0xd1df, 0x1904, 0xc197, 0x080c, 0x2f50, 0x1904,
+	0xc197, 0x080c, 0xc335, 0x1904, 0xbe71, 0x0016, 0x0026, 0x00e6,
+	0x2071, 0x0260, 0x7244, 0x9286, 0xffff, 0x0180, 0x2c08, 0x080c,
+	0xb5e9, 0x01b0, 0x2260, 0x7240, 0x6008, 0x9206, 0x1188, 0x6010,
+	0x9190, 0x0004, 0x2214, 0x9206, 0x01b8, 0x0050, 0x7240, 0x2c08,
+	0x9006, 0x080c, 0xcfb8, 0x1180, 0x7244, 0x9286, 0xffff, 0x01b0,
+	0x2160, 0x6007, 0x0026, 0x6017, 0x1700, 0x7214, 0x9296, 0xffff,
+	0x1180, 0x6007, 0x0025, 0x0068, 0x6020, 0x9086, 0x0007, 0x1d80,
+	0x6004, 0x9086, 0x0024, 0x1110, 0x080c, 0x99d6, 0x2160, 0x6007,
+	0x0025, 0x6003, 0x0001, 0x080c, 0x8048, 0x080c, 0x8582, 0x00ee,
+	0x002e, 0x001e, 0x0005, 0x2001, 0x0001, 0x080c, 0x5ebb, 0x0156,
+	0x0016, 0x0026, 0x0036, 0x20a9, 0x0004, 0x2019, 0x1805, 0x2011,
+	0x0276, 0x080c, 0xa909, 0x003e, 0x002e, 0x001e, 0x015e, 0x0120,
+	0x6007, 0x0031, 0x0804, 0xbf84, 0x080c, 0xa5c2, 0x080c, 0x6c53,
+	0x1190, 0x0006, 0x0026, 0x0036, 0x080c, 0x6c6d, 0x1138, 0x080c,
+	0x6f2a, 0x080c, 0x5a21, 0x080c, 0x6b8a, 0x0010, 0x080c, 0x6c2d,
+	0x003e, 0x002e, 0x000e, 0x0005, 0x080c, 0x2f50, 0x1904, 0xc197,
+	0x080c, 0xc335, 0x1904, 0xbe71, 0x6106, 0x080c, 0xc351, 0x1120,
+	0x6007, 0x002b, 0x0804, 0xbf84, 0x6007, 0x002c, 0x0804, 0xbf84,
+	0x080c, 0xd1df, 0x1904, 0xc197, 0x080c, 0x2f50, 0x1904, 0xc197,
+	0x080c, 0xc335, 0x1904, 0xbe71, 0x6106, 0x080c, 0xc356, 0x1120,
+	0x6007, 0x002e, 0x0804, 0xbf84, 0x6007, 0x002f, 0x0804, 0xbf84,
+	0x080c, 0x2f50, 0x1904, 0xc197, 0x00e6, 0x00d6, 0x00c6, 0x6010,
+	0x2058, 0xb904, 0x9184, 0x00ff, 0x9086, 0x0006, 0x0158, 0x9184,
+	0xff00, 0x8007, 0x9086, 0x0006, 0x0128, 0x00ce, 0x00de, 0x00ee,
+	0x0804, 0xbf8b, 0x080c, 0x5117, 0xd0e4, 0x0904, 0xc0e2, 0x2071,
+	0x026c, 0x7010, 0x603a, 0x7014, 0x603e, 0x7108, 0x720c, 0x080c,
+	0x62a0, 0x0140, 0x6010, 0x2058, 0xb810, 0x9106, 0x1118, 0xb814,
+	0x9206, 0x0510, 0x080c, 0x629c, 0x15b8, 0x2069, 0x1800, 0x6878,
+	0x9206, 0x1590, 0x6874, 0x9106, 0x1578, 0x7210, 0x080c, 0xb5e9,
+	0x0590, 0x080c, 0xc222, 0x0578, 0x080c, 0xd05d, 0x0560, 0x622e,
+	0x6007, 0x0036, 0x6003, 0x0001, 0x080c, 0x8000, 0x080c, 0x8582,
+	0x00ce, 0x00de, 0x00ee, 0x0005, 0x7214, 0x9286, 0xffff, 0x0150,
+	0x080c, 0xb5e9, 0x01c0, 0x9280, 0x0002, 0x2004, 0x7110, 0x9106,
+	0x1190, 0x08e0, 0x7210, 0x2c08, 0x9085, 0x0001, 0x080c, 0xcfb8,
+	0x2c10, 0x2160, 0x0140, 0x0890, 0x6007, 0x0037, 0x602f, 0x0009,
+	0x6017, 0x1500, 0x08b8, 0x6007, 0x0037, 0x602f, 0x0003, 0x6017,
+	0x1700, 0x0880, 0x6007, 0x0012, 0x0868, 0x080c, 0x2f50, 0x1904,
+	0xc197, 0x6010, 0x2058, 0xb804, 0x9084, 0xff00, 0x8007, 0x9086,
+	0x0006, 0x1904, 0xbf8b, 0x00e6, 0x00d6, 0x00c6, 0x080c, 0x5117,
+	0xd0e4, 0x0904, 0xc15a, 0x2069, 0x1800, 0x2071, 0x026c, 0x7008,
+	0x603a, 0x720c, 0x623e, 0x9286, 0xffff, 0x1150, 0x7208, 0x00c6,
+	0x2c08, 0x9085, 0x0001, 0x080c, 0xcfb8, 0x2c10, 0x00ce, 0x05e8,
+	0x080c, 0xb5e9, 0x05d0, 0x7108, 0x9280, 0x0002, 0x2004, 0x9106,
+	0x15a0, 0x00c6, 0x0026, 0x2260, 0x080c, 0xb244, 0x002e, 0x00ce,
+	0x7118, 0x918c, 0xff00, 0x810f, 0x9186, 0x0001, 0x0178, 0x9186,
+	0x0005, 0x0118, 0x9186, 0x0007, 0x1198, 0x9280, 0x0005, 0x2004,
+	0x9005, 0x0170, 0x080c, 0xc222, 0x0904, 0xc0db, 0x0056, 0x7510,
+	0x7614, 0x080c, 0xd076, 0x005e, 0x00ce, 0x00de, 0x00ee, 0x0005,
+	0x6007, 0x003b, 0x602f, 0x0009, 0x6017, 0x2a00, 0x6003, 0x0001,
+	0x080c, 0x8000, 0x080c, 0x8582, 0x0c78, 0x6007, 0x003b, 0x602f,
+	0x0003, 0x6017, 0x0300, 0x6003, 0x0001, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x0c10, 0x6007, 0x003b, 0x602f, 0x000b, 0x6017, 0x0000,
+	0x0804, 0xc0b2, 0x00e6, 0x0026, 0x080c, 0x6262, 0x0550, 0x080c,
+	0x624b, 0x080c, 0xd251, 0x1518, 0x2071, 0x1800, 0x70d4, 0x9085,
+	0x0003, 0x70d6, 0x00f6, 0x2079, 0x0100, 0x72a8, 0x9284, 0x00ff,
+	0x7076, 0x78e6, 0x9284, 0xff00, 0x7278, 0x9205, 0x707a, 0x78ea,
+	0x00fe, 0x70df, 0x0000, 0x080c, 0x62a0, 0x0120, 0x2011, 0x19cf,
+	0x2013, 0x07d0, 0xd0ac, 0x1128, 0x080c, 0x2c2b, 0x0010, 0x080c,
+	0xd283, 0x002e, 0x00ee, 0x080c, 0x99d6, 0x0804, 0xbf8a, 0x080c,
+	0x99d6, 0x0005, 0x2600, 0x0002, 0xc1ae, 0xc1ae, 0xc1ae, 0xc1ae,
+	0xc1ae, 0xc1b0, 0xc1ae, 0xc1ae, 0xc1ae, 0xc1ae, 0xc1cd, 0xc1ae,
+	0xc1ae, 0xc1ae, 0xc1df, 0xc1ec, 0xc21d, 0xc1ae, 0x080c, 0x0db2,
+	0x080c, 0xd1df, 0x1d20, 0x080c, 0x2f50, 0x1d08, 0x080c, 0xc335,
+	0x1148, 0x7038, 0x6016, 0x6007, 0x0045, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x0005, 0x080c, 0x2e30, 0x080c, 0xbd01, 0x6007, 0x0001,
+	0x6003, 0x0001, 0x080c, 0x8048, 0x0005, 0x080c, 0xd1df, 0x1938,
+	0x080c, 0x2f50, 0x1920, 0x080c, 0xc335, 0x1d60, 0x703c, 0x6016,
+	0x6007, 0x004a, 0x6003, 0x0001, 0x080c, 0x8048, 0x0005, 0x080c,
+	0xc23d, 0x0904, 0xc197, 0x6007, 0x004e, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x080c, 0x8582, 0x0005, 0x6007, 0x004f, 0x6017, 0x0000,
+	0x7134, 0x918c, 0x00ff, 0x81ff, 0x0508, 0x9186, 0x0001, 0x1160,
+	0x7140, 0x2001, 0x198c, 0x2004, 0x9106, 0x11b0, 0x7144, 0x2001,
+	0x198d, 0x2004, 0x9106, 0x0190, 0x9186, 0x0002, 0x1168, 0x2011,
+	0x0276, 0x20a9, 0x0004, 0x6010, 0x0096, 0x2048, 0x2019, 0x000a,
+	0x080c, 0xa91d, 0x009e, 0x0110, 0x6017, 0x0001, 0x6003, 0x0001,
+	0x080c, 0x8048, 0x080c, 0x8582, 0x0005, 0x6007, 0x0050, 0x703c,
+	0x6016, 0x0ca0, 0x00e6, 0x2071, 0x0260, 0x00b6, 0x00c6, 0x2260,
+	0x6010, 0x2058, 0xb8bc, 0xd084, 0x0150, 0x7128, 0x6048, 0x9106,
+	0x1120, 0x712c, 0x6044, 0x9106, 0x0110, 0x9006, 0x0010, 0x9085,
+	0x0001, 0x00ce, 0x00be, 0x00ee, 0x0005, 0x0016, 0x0096, 0x0086,
+	0x00e6, 0x01c6, 0x01d6, 0x0126, 0x2091, 0x8000, 0x2071, 0x1800,
+	0x7088, 0x908a, 0x00f9, 0x16e8, 0x20e1, 0x0000, 0x2001, 0x196f,
+	0x2003, 0x0000, 0x080c, 0x0fee, 0x05a0, 0x2900, 0x6016, 0x7088,
+	0x8004, 0xa816, 0x908a, 0x001e, 0x02d0, 0xa833, 0x001e, 0x20a9,
+	0x001e, 0xa860, 0x20e8, 0xa85c, 0x9080, 0x001b, 0x20a0, 0x2001,
+	0x196f, 0x0016, 0x200c, 0x0471, 0x001e, 0x2940, 0x080c, 0x0fee,
+	0x01c0, 0x2900, 0xa006, 0x2100, 0x81ff, 0x0180, 0x0c18, 0xa832,
+	0x20a8, 0xa860, 0x20e8, 0xa85c, 0x9080, 0x001b, 0x20a0, 0x2001,
+	0x196f, 0x0016, 0x200c, 0x00b1, 0x001e, 0x0000, 0x9085, 0x0001,
+	0x0048, 0x2071, 0x1800, 0x708b, 0x0000, 0x6014, 0x2048, 0x080c,
+	0x0f87, 0x9006, 0x012e, 0x01de, 0x01ce, 0x00ee, 0x008e, 0x009e,
+	0x001e, 0x0005, 0x0006, 0x0016, 0x0026, 0x0036, 0x00c6, 0x918c,
+	0xffff, 0x11a8, 0x080c, 0x20b2, 0x2099, 0x026c, 0x2001, 0x0014,
+	0x3518, 0x9312, 0x1218, 0x23a8, 0x4003, 0x00f8, 0x20a8, 0x4003,
+	0x22a8, 0x8108, 0x080c, 0x20b2, 0x2099, 0x0260, 0x0ca8, 0x080c,
+	0x20b2, 0x2061, 0x196f, 0x6004, 0x2098, 0x6008, 0x3518, 0x9312,
+	0x1218, 0x23a8, 0x4003, 0x0048, 0x20a8, 0x4003, 0x22a8, 0x8108,
+	0x080c, 0x20b2, 0x2099, 0x0260, 0x0ca8, 0x2061, 0x196f, 0x2019,
+	0x0280, 0x3300, 0x931e, 0x0110, 0x6006, 0x0020, 0x2001, 0x0260,
+	0x6006, 0x8108, 0x2162, 0x9292, 0x0021, 0x9296, 0xffff, 0x620a,
+	0x00ce, 0x003e, 0x002e, 0x001e, 0x000e, 0x0005, 0x0006, 0x0016,
+	0x0026, 0x0036, 0x00c6, 0x81ff, 0x11b8, 0x080c, 0x20ca, 0x20a1,
+	0x024c, 0x2001, 0x0014, 0x3518, 0x9312, 0x1218, 0x23a8, 0x4003,
+	0x0418, 0x20a8, 0x4003, 0x82ff, 0x01f8, 0x22a8, 0x8108, 0x080c,
+	0x20ca, 0x20a1, 0x0240, 0x0c98, 0x080c, 0x20ca, 0x2061, 0x1972,
+	0x6004, 0x20a0, 0x6008, 0x3518, 0x9312, 0x1218, 0x23a8, 0x4003,
+	0x0058, 0x20a8, 0x4003, 0x82ff, 0x0138, 0x22a8, 0x8108, 0x080c,
+	0x20ca, 0x20a1, 0x0240, 0x0c98, 0x2061, 0x1972, 0x2019, 0x0260,
+	0x3400, 0x931e, 0x0110, 0x6006, 0x0020, 0x2001, 0x0240, 0x6006,
+	0x8108, 0x2162, 0x9292, 0x0021, 0x9296, 0xffff, 0x620a, 0x00ce,
+	0x003e, 0x002e, 0x001e, 0x000e, 0x0005, 0x00b6, 0x0066, 0x6610,
+	0x2658, 0xbe04, 0x96b4, 0xff00, 0x8637, 0x9686, 0x0006, 0x0170,
+	0x9686, 0x0004, 0x0158, 0xbe04, 0x96b4, 0x00ff, 0x9686, 0x0006,
+	0x0128, 0x9686, 0x0004, 0x0110, 0x9085, 0x0001, 0x006e, 0x00be,
+	0x0005, 0x00d6, 0x080c, 0xc3cd, 0x00de, 0x0005, 0x00d6, 0x080c,
+	0xc3da, 0x1520, 0x680c, 0x908c, 0xff00, 0x6820, 0x9084, 0x00ff,
+	0x9115, 0x6216, 0x6824, 0x602e, 0xd1e4, 0x0130, 0x9006, 0x080c,
+	0xd2fb, 0x2009, 0x0001, 0x0078, 0xd1ec, 0x0180, 0x6920, 0x918c,
+	0x00ff, 0x6824, 0x080c, 0x24d6, 0x1148, 0x2001, 0x0001, 0x080c,
+	0xd2fb, 0x2110, 0x900e, 0x080c, 0x2e75, 0x0018, 0x9085, 0x0001,
+	0x0008, 0x9006, 0x00de, 0x0005, 0x00b6, 0x00c6, 0x080c, 0x9a23,
+	0x05a8, 0x0016, 0x0026, 0x00c6, 0x2011, 0x0263, 0x2204, 0x8211,
+	0x220c, 0x080c, 0x24d6, 0x1578, 0x080c, 0x5f1e, 0x1560, 0xbe12,
+	0xbd16, 0x00ce, 0x002e, 0x001e, 0x2b00, 0x6012, 0x080c, 0xd1df,
+	0x11d8, 0x080c, 0x2f50, 0x11c0, 0x080c, 0xc335, 0x0510, 0x2001,
+	0x0007, 0x080c, 0x5ecf, 0x2001, 0x0007, 0x080c, 0x5efb, 0x6017,
+	0x0000, 0x6023, 0x0001, 0x6007, 0x0001, 0x6003, 0x0001, 0x080c,
+	0x8048, 0x080c, 0x8582, 0x0010, 0x080c, 0x99d6, 0x9085, 0x0001,
+	0x00ce, 0x00be, 0x0005, 0x080c, 0x99d6, 0x00ce, 0x002e, 0x001e,
+	0x0ca8, 0x080c, 0x99d6, 0x9006, 0x0c98, 0x2069, 0x026d, 0x6800,
+	0x9082, 0x0010, 0x1228, 0x6017, 0x0000, 0x9085, 0x0001, 0x0008,
+	0x9006, 0x0005, 0x6017, 0x0000, 0x2069, 0x026c, 0x6808, 0x9084,
+	0xff00, 0x9086, 0x0800, 0x1190, 0x6904, 0x9186, 0x0018, 0x0118,
+	0x9186, 0x0014, 0x1158, 0x810f, 0x6800, 0x9084, 0x00ff, 0x910d,
+	0x615a, 0x908e, 0x0014, 0x0110, 0x908e, 0x0010, 0x0005, 0x6004,
+	0x90b2, 0x0053, 0x1a0c, 0x0db2, 0x91b6, 0x0013, 0x1130, 0x2008,
+	0x91b2, 0x0040, 0x1a04, 0xc522, 0x0092, 0x91b6, 0x0027, 0x0120,
+	0x91b6, 0x0014, 0x190c, 0x0db2, 0x2001, 0x0007, 0x080c, 0x5efb,
+	0x080c, 0x847d, 0x080c, 0x9a06, 0x080c, 0x8582, 0x0005, 0xc457,
+	0xc459, 0xc457, 0xc457, 0xc457, 0xc459, 0xc468, 0xc51b, 0xc4ba,
+	0xc51b, 0xc4cc, 0xc51b, 0xc468, 0xc51b, 0xc513, 0xc51b, 0xc513,
+	0xc51b, 0xc51b, 0xc457, 0xc457, 0xc457, 0xc457, 0xc457, 0xc457,
+	0xc457, 0xc457, 0xc457, 0xc457, 0xc457, 0xc459, 0xc457, 0xc51b,
+	0xc457, 0xc457, 0xc51b, 0xc457, 0xc518, 0xc51b, 0xc457, 0xc457,
+	0xc457, 0xc457, 0xc51b, 0xc51b, 0xc457, 0xc51b, 0xc51b, 0xc457,
+	0xc463, 0xc457, 0xc457, 0xc457, 0xc457, 0xc517, 0xc51b, 0xc457,
+	0xc457, 0xc51b, 0xc51b, 0xc457, 0xc457, 0xc457, 0xc457, 0x080c,
+	0x0db2, 0x080c, 0x847d, 0x080c, 0xbd04, 0x6003, 0x0002, 0x080c,
+	0x8582, 0x0804, 0xc521, 0x9006, 0x080c, 0x5ebb, 0x0804, 0xc51b,
+	0x080c, 0x629c, 0x1904, 0xc51b, 0x9006, 0x080c, 0x5ebb, 0x6010,
+	0x2058, 0xb810, 0x9086, 0x00ff, 0x1140, 0x00f6, 0x2079, 0x1800,
+	0x78a0, 0x8000, 0x78a2, 0x00fe, 0x0428, 0x6010, 0x2058, 0xb8b0,
+	0x9005, 0x1178, 0x080c, 0xbcec, 0x1904, 0xc51b, 0x0036, 0x0046,
+	0xbba0, 0x2021, 0x0007, 0x080c, 0x4829, 0x004e, 0x003e, 0x0804,
+	0xc51b, 0x080c, 0x2f81, 0x1904, 0xc51b, 0x2001, 0x1800, 0x2004,
+	0x9086, 0x0002, 0x1138, 0x00f6, 0x2079, 0x1800, 0x78a0, 0x8000,
+	0x78a2, 0x00fe, 0x2001, 0x0002, 0x080c, 0x5ecf, 0x080c, 0x847d,
+	0x6023, 0x0001, 0x6003, 0x0001, 0x6007, 0x0002, 0x080c, 0x8048,
+	0x080c, 0x8582, 0x6110, 0x2158, 0x2009, 0x0001, 0x080c, 0x7c58,
+	0x0804, 0xc521, 0x6610, 0x2658, 0xbe04, 0x96b4, 0xff00, 0x8637,
+	0x9686, 0x0006, 0x0904, 0xc51b, 0x9686, 0x0004, 0x0904, 0xc51b,
+	0x2001, 0x0004, 0x0804, 0xc519, 0x2001, 0x1800, 0x2004, 0x9086,
+	0x0003, 0x1158, 0x0036, 0x0046, 0x6010, 0x2058, 0xbba0, 0x2021,
+	0x0006, 0x080c, 0x4829, 0x004e, 0x003e, 0x2001, 0x0006, 0x080c,
+	0xc53f, 0x6610, 0x2658, 0xbe04, 0x0066, 0x96b4, 0xff00, 0x8637,
+	0x9686, 0x0006, 0x006e, 0x0168, 0x2001, 0x0006, 0x080c, 0x5efb,
+	0x9284, 0x00ff, 0x908e, 0x0007, 0x1120, 0x2001, 0x0006, 0x080c,
+	0x5ecf, 0x080c, 0x629c, 0x11f8, 0x2001, 0x1835, 0x2004, 0xd0a4,
+	0x01d0, 0xbe04, 0x96b4, 0x00ff, 0x9686, 0x0006, 0x01a0, 0x00f6,
+	0x2079, 0x1800, 0x78a0, 0x8000, 0x78a2, 0x00fe, 0x0804, 0xc4a2,
+	0x2001, 0x0004, 0x0030, 0x2001, 0x0006, 0x0449, 0x0020, 0x0018,
+	0x0010, 0x080c, 0x5efb, 0x080c, 0x847d, 0x080c, 0x99d6, 0x080c,
+	0x8582, 0x0005, 0x2600, 0x0002, 0xc536, 0xc536, 0xc536, 0xc536,
+	0xc536, 0xc538, 0xc536, 0xc536, 0xc536, 0xc536, 0xc538, 0xc536,
+	0xc536, 0xc536, 0xc538, 0xc538, 0xc538, 0xc538, 0x080c, 0x0db2,
+	0x080c, 0x847d, 0x080c, 0x99d6, 0x080c, 0x8582, 0x0005, 0x0016,
+	0x00b6, 0x00d6, 0x6110, 0x2158, 0xb900, 0xd184, 0x0138, 0x080c,
+	0x5ecf, 0x9006, 0x080c, 0x5ebb, 0x080c, 0x2e55, 0x00de, 0x00be,
+	0x001e, 0x0005, 0x6610, 0x2658, 0xb804, 0x9084, 0xff00, 0x8007,
+	0x90b2, 0x000c, 0x1a0c, 0x0db2, 0x91b6, 0x0015, 0x1110, 0x003b,
+	0x0028, 0x91b6, 0x0016, 0x190c, 0x0db2, 0x006b, 0x0005, 0xa445,
+	0xa445, 0xa445, 0xa445, 0xa445, 0xa445, 0xc5ba, 0xc57f, 0xa445,
+	0xa445, 0xa445, 0xa445, 0xa445, 0xa445, 0xa445, 0xa445, 0xa445,
+	0xa445, 0xc5ba, 0xc5c1, 0xa445, 0xa445, 0xa445, 0xa445, 0x00f6,
+	0x080c, 0x629c, 0x11d8, 0x080c, 0xbcec, 0x11c0, 0x6010, 0x905d,
+	0x01a8, 0xb8b0, 0x9005, 0x0190, 0x9006, 0x080c, 0x5ebb, 0x2001,
+	0x0002, 0x080c, 0x5ecf, 0x6023, 0x0001, 0x6003, 0x0001, 0x6007,
+	0x0002, 0x080c, 0x8048, 0x080c, 0x8582, 0x00d0, 0x2011, 0x0263,
+	0x2204, 0x8211, 0x220c, 0x080c, 0x24d6, 0x1190, 0x080c, 0x5f7e,
+	0x0118, 0x080c, 0x99d6, 0x0060, 0xb810, 0x0006, 0xb814, 0x0006,
+	0x080c, 0x5a3b, 0x000e, 0xb816, 0x000e, 0xb812, 0x080c, 0x99d6,
+	0x00fe, 0x0005, 0x6604, 0x96b6, 0x001e, 0x1110, 0x080c, 0x99d6,
+	0x0005, 0x080c, 0xa7a1, 0x1148, 0x6003, 0x0001, 0x6007, 0x0001,
+	0x080c, 0x8048, 0x080c, 0x8582, 0x0010, 0x080c, 0x99d6, 0x0005,
+	0x6004, 0x908a, 0x0053, 0x1a0c, 0x0db2, 0x080c, 0x847d, 0x080c,
+	0x9a06, 0x080c, 0x8582, 0x0005, 0x9182, 0x0040, 0x0002, 0xc5f2,
+	0xc5f2, 0xc5f2, 0xc5f2, 0xc5f4, 0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2,
+	0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2, 0xc5f2,
+	0xc5f2, 0xc5f2, 0x080c, 0x0db2, 0x0096, 0x00b6, 0x00d6, 0x00e6,
+	0x00f6, 0x0046, 0x0026, 0x6210, 0x2258, 0xb8ac, 0x9005, 0x11a8,
+	0x6106, 0x2071, 0x0260, 0x7444, 0x94a4, 0xff00, 0x0904, 0xc65a,
+	0x080c, 0xd2ef, 0x1170, 0x9486, 0x2000, 0x1158, 0x2009, 0x0001,
+	0x2011, 0x0200, 0x080c, 0x7e3e, 0x0020, 0x9026, 0x080c, 0xd224,
+	0x0c38, 0x080c, 0x0fd5, 0x090c, 0x0db2, 0x6003, 0x0007, 0xa867,
+	0x010d, 0x9006, 0xa802, 0xa86a, 0xac8a, 0x2c00, 0xa88e, 0x6008,
+	0xa8e2, 0x6010, 0x2058, 0xb8a0, 0x7130, 0xa97a, 0x0016, 0xa876,
+	0xa87f, 0x0000, 0xa883, 0x0000, 0xa887, 0x0036, 0x080c, 0x6536,
+	0x001e, 0x080c, 0xd2ef, 0x1904, 0xc6ba, 0x9486, 0x2000, 0x1130,
+	0x2019, 0x0017, 0x080c, 0xcf62, 0x0804, 0xc6ba, 0x9486, 0x0200,
+	0x1120, 0x080c, 0xcefe, 0x0804, 0xc6ba, 0x9486, 0x0400, 0x0120,
+	0x9486, 0x1000, 0x1904, 0xc6ba, 0x2019, 0x0002, 0x080c, 0xcf19,
+	0x0804, 0xc6ba, 0x2069, 0x1a3e, 0x6a00, 0xd284, 0x0904, 0xc724,
+	0x9284, 0x0300, 0x1904, 0xc71d, 0x6804, 0x9005, 0x0904, 0xc705,
+	0x2d78, 0x6003, 0x0007, 0x080c, 0x0fee, 0x0904, 0xc6c6, 0x7800,
+	0xd08c, 0x1118, 0x7804, 0x8001, 0x7806, 0x6017, 0x0000, 0x2001,
+	0x180e, 0x2004, 0xd084, 0x1904, 0xc728, 0x9006, 0xa802, 0xa867,
+	0x0116, 0xa86a, 0x6008, 0xa8e2, 0x2c00, 0xa87a, 0x6010, 0x2058,
+	0xb8a0, 0x7130, 0xa9b6, 0xa876, 0xb928, 0xa9ba, 0xb92c, 0xa9be,
+	0xb930, 0xa9c2, 0xb934, 0xa9c6, 0xa883, 0x003d, 0x7044, 0x9084,
+	0x0003, 0x9080, 0xc6c2, 0x2005, 0xa87e, 0x20a9, 0x000a, 0x2001,
+	0x0270, 0xaa5c, 0x9290, 0x0021, 0x2009, 0x0205, 0x200b, 0x0080,
+	0x20e1, 0x0000, 0xab60, 0x23e8, 0x2098, 0x22a0, 0x4003, 0x200b,
+	0x0000, 0x2001, 0x027a, 0x200c, 0xa9b2, 0x8000, 0x200c, 0xa9ae,
+	0x080c, 0x6536, 0x002e, 0x004e, 0x00fe, 0x00ee, 0x00de, 0x00be,
+	0x009e, 0x0005, 0x0000, 0x0080, 0x0040, 0x0000, 0x2001, 0x180f,
+	0x2004, 0xd084, 0x0120, 0x080c, 0x0fd5, 0x1904, 0xc66f, 0x6017,
+	0xf100, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x0c00, 0x2069, 0x0260, 0x6848, 0x9084, 0xff00, 0x9086,
+	0x1200, 0x1198, 0x686c, 0x9084, 0x00ff, 0x0016, 0x6114, 0x918c,
+	0xf700, 0x910d, 0x6116, 0x001e, 0x6003, 0x0001, 0x6007, 0x0043,
+	0x080c, 0x8000, 0x080c, 0x8582, 0x0828, 0x6868, 0x602e, 0x686c,
+	0x6032, 0x6017, 0xf200, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c,
+	0x8000, 0x080c, 0x8582, 0x0804, 0xc6ba, 0x2001, 0x180d, 0x2004,
+	0xd0ec, 0x0120, 0x2011, 0x8049, 0x080c, 0x4672, 0x6017, 0xf300,
+	0x0010, 0x6017, 0xf100, 0x6003, 0x0001, 0x6007, 0x0041, 0x080c,
+	0x8000, 0x080c, 0x8582, 0x0804, 0xc6ba, 0x6017, 0xf500, 0x0c98,
+	0x6017, 0xf600, 0x0804, 0xc6da, 0x6017, 0xf200, 0x0804, 0xc6da,
+	0xa867, 0x0146, 0xa86b, 0x0000, 0x6008, 0xa886, 0x2c00, 0xa87a,
+	0x7044, 0x9084, 0x0003, 0x9080, 0xc6c2, 0x2005, 0xa87e, 0x2928,
+	0x6010, 0x2058, 0xb8a0, 0xa876, 0xb828, 0xa88a, 0xb82c, 0xa88e,
+	0xb830, 0xa892, 0xb834, 0xa896, 0xa883, 0x003d, 0x2009, 0x0205,
+	0x2104, 0x9085, 0x0080, 0x200a, 0x20e1, 0x0000, 0x2011, 0x0210,
+	0x2214, 0x9294, 0x0fff, 0xaaa2, 0x9282, 0x0111, 0x1a0c, 0x0db2,
+	0x8210, 0x821c, 0x2001, 0x026c, 0x2098, 0xa860, 0x20e8, 0xa85c,
+	0x9080, 0x0029, 0x20a0, 0x2011, 0xc7a4, 0x2041, 0x0001, 0x223d,
+	0x9784, 0x00ff, 0x9322, 0x1208, 0x2300, 0x20a8, 0x4003, 0x931a,
+	0x0530, 0x8210, 0xd7fc, 0x1130, 0x8d68, 0x2d0a, 0x2001, 0x0260,
+	0x2098, 0x0c68, 0x2950, 0x080c, 0x0fee, 0x0170, 0x2900, 0xb002,
+	0xa867, 0x0147, 0xa86b, 0x0000, 0xa860, 0x20e8, 0xa85c, 0x9080,
+	0x001b, 0x20a0, 0x8840, 0x08d8, 0x2548, 0xa800, 0x902d, 0x0118,
+	0x080c, 0x1007, 0x0cc8, 0x080c, 0x1007, 0x0804, 0xc6c6, 0x2548,
+	0x8847, 0x9885, 0x0046, 0xa866, 0x2009, 0x0205, 0x200b, 0x0000,
+	0x080c, 0xcf91, 0x0804, 0xc6ba, 0x8010, 0x0004, 0x801a, 0x0006,
+	0x8018, 0x0008, 0x8016, 0x000a, 0x8014, 0x9186, 0x0013, 0x1160,
+	0x6004, 0x908a, 0x0054, 0x1a0c, 0x0db2, 0x9082, 0x0040, 0x0a0c,
+	0x0db2, 0x2008, 0x0804, 0xc855, 0x9186, 0x0051, 0x0108, 0x00c0,
+	0x2001, 0x0109, 0x2004, 0xd084, 0x0904, 0xc806, 0x0126, 0x2091,
+	0x2800, 0x0006, 0x0016, 0x0026, 0x080c, 0x7eec, 0x002e, 0x001e,
+	0x000e, 0x012e, 0x6000, 0x9086, 0x0002, 0x1580, 0x0804, 0xc89d,
+	0x9186, 0x0027, 0x0530, 0x9186, 0x0048, 0x0128, 0x9186, 0x0014,
+	0x0500, 0x190c, 0x0db2, 0x2001, 0x0109, 0x2004, 0xd084, 0x01f0,
+	0x00c6, 0x0126, 0x2091, 0x2800, 0x00c6, 0x2061, 0x0100, 0x0006,
+	0x0016, 0x0026, 0x080c, 0x7eec, 0x002e, 0x001e, 0x000e, 0x00ce,
+	0x012e, 0x00ce, 0x6000, 0x9086, 0x0004, 0x190c, 0x0db2, 0x0804,
+	0xc97e, 0x6004, 0x9082, 0x0040, 0x2008, 0x001a, 0x080c, 0x9a6b,
+	0x0005, 0xc81c, 0xc81e, 0xc81e, 0xc845, 0xc81c, 0xc81c, 0xc81c,
+	0xc81c, 0xc81c, 0xc81c, 0xc81c, 0xc81c, 0xc81c, 0xc81c, 0xc81c,
+	0xc81c, 0xc81c, 0xc81c, 0xc81c, 0x080c, 0x0db2, 0x080c, 0x847d,
+	0x080c, 0x8582, 0x0036, 0x0096, 0x6014, 0x904d, 0x01d8, 0x080c,
+	0xb5fb, 0x01c0, 0x6003, 0x0002, 0x6010, 0x00b6, 0x2058, 0xb800,
+	0x00be, 0xd0bc, 0x1178, 0x2019, 0x0004, 0x080c, 0xcf91, 0x6017,
+	0x0000, 0x6018, 0x9005, 0x1120, 0x2001, 0x1956, 0x2004, 0x601a,
+	0x6003, 0x0007, 0x009e, 0x003e, 0x0005, 0x0096, 0x080c, 0x847d,
+	0x080c, 0x8582, 0x080c, 0xb5fb, 0x0120, 0x6014, 0x2048, 0x080c,
+	0x1007, 0x080c, 0x9a06, 0x009e, 0x0005, 0x0002, 0xc869, 0xc880,
+	0xc86b, 0xc897, 0xc869, 0xc869, 0xc869, 0xc869, 0xc869, 0xc869,
+	0xc869, 0xc869, 0xc869, 0xc869, 0xc869, 0xc869, 0xc869, 0xc869,
+	0xc869, 0x080c, 0x0db2, 0x0096, 0x080c, 0x847d, 0x6014, 0x2048,
+	0xa87c, 0xd0b4, 0x0138, 0x6003, 0x0007, 0x2009, 0x0043, 0x080c,
+	0x9a50, 0x0010, 0x6003, 0x0004, 0x080c, 0x8582, 0x009e, 0x0005,
+	0x080c, 0x847d, 0x080c, 0xb5fb, 0x0138, 0x6114, 0x0096, 0x2148,
+	0xa97c, 0x009e, 0xd1ec, 0x1138, 0x080c, 0x7e13, 0x080c, 0x99d6,
+	0x080c, 0x8582, 0x0005, 0x080c, 0xd1e8, 0x0db0, 0x0cc8, 0x080c,
+	0x847d, 0x2009, 0x0041, 0x0804, 0xca06, 0x9182, 0x0040, 0x0002,
+	0xc8b3, 0xc8b5, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3,
+	0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3, 0xc8b3,
+	0xc8b3, 0xc8b6, 0xc8b3, 0x080c, 0x0db2, 0x0005, 0x00d6, 0x080c,
+	0x7e13, 0x00de, 0x080c, 0xd240, 0x080c, 0x99d6, 0x0005, 0x9182,
+	0x0040, 0x0002, 0xc8d5, 0xc8d5, 0xc8d5, 0xc8d5, 0xc8d5, 0xc8d5,
+	0xc8d5, 0xc8d5, 0xc8d5, 0xc8d7, 0xc946, 0xc8d5, 0xc8d5, 0xc8d5,
+	0xc8d5, 0xc946, 0xc8d5, 0xc8d5, 0xc8d5, 0x080c, 0x0db2, 0x2001,
+	0x0105, 0x2004, 0x9084, 0x1800, 0x01c8, 0x2001, 0x0132, 0x200c,
+	0x2001, 0x0131, 0x2004, 0x9105, 0x1904, 0xc946, 0x2009, 0x180c,
+	0x2104, 0xd0d4, 0x0904, 0xc946, 0xc0d4, 0x200a, 0x2009, 0x0105,
+	0x2104, 0x9084, 0xe7fd, 0x9085, 0x0010, 0x200a, 0x2001, 0x1873,
+	0x2004, 0xd0e4, 0x1528, 0x603b, 0x0000, 0x080c, 0x8532, 0x6014,
+	0x0096, 0x2048, 0xa87c, 0xd0fc, 0x0188, 0x908c, 0x0003, 0x918e,
+	0x0002, 0x0508, 0x2001, 0x180c, 0x2004, 0xd0d4, 0x11e0, 0x080c,
+	0x865d, 0x2009, 0x0041, 0x009e, 0x0804, 0xca06, 0x080c, 0x865d,
+	0x6003, 0x0007, 0x601b, 0x0000, 0x080c, 0x7e13, 0x009e, 0x0005,
+	0x2001, 0x0100, 0x2004, 0x9082, 0x0005, 0x0aa8, 0x2001, 0x011f,
+	0x2004, 0x603a, 0x0890, 0x2001, 0x180c, 0x200c, 0xc1d4, 0x2102,
+	0xd1cc, 0x0110, 0x080c, 0x28ea, 0x080c, 0x865d, 0x6014, 0x2048,
+	0xa97c, 0xd1ec, 0x1130, 0x080c, 0x7e13, 0x080c, 0x99d6, 0x009e,
+	0x0005, 0x080c, 0xd1e8, 0x0db8, 0x009e, 0x0005, 0x2001, 0x180c,
+	0x200c, 0xc1d4, 0x2102, 0x0036, 0x080c, 0x8532, 0x080c, 0x865d,
+	0x6014, 0x0096, 0x2048, 0x6010, 0x00b6, 0x2058, 0xb800, 0x00be,
+	0xd0bc, 0x0188, 0xa87c, 0x9084, 0x0003, 0x9086, 0x0002, 0x0140,
+	0xa8ac, 0x6330, 0x931a, 0x6332, 0xa8b0, 0x632c, 0x931b, 0x632e,
+	0x6003, 0x0002, 0x0080, 0x2019, 0x0004, 0x080c, 0xcf91, 0x6018,
+	0x9005, 0x1128, 0x2001, 0x1956, 0x2004, 0x8003, 0x601a, 0x6017,
+	0x0000, 0x6003, 0x0007, 0x009e, 0x003e, 0x0005, 0x9182, 0x0040,
+	0x0002, 0xc995, 0xc995, 0xc995, 0xc995, 0xc995, 0xc995, 0xc995,
+	0xc995, 0xc997, 0xc995, 0xc995, 0xc995, 0xc995, 0xc995, 0xc995,
+	0xc995, 0xc995, 0xc995, 0xc995, 0xc9e2, 0x080c, 0x0db2, 0x6014,
+	0x0096, 0x2048, 0xa834, 0xaa38, 0x6110, 0x00b6, 0x2058, 0xb900,
+	0x00be, 0xd1bc, 0x1190, 0x920d, 0x1518, 0xa87c, 0xd0fc, 0x0128,
+	0x2009, 0x0041, 0x009e, 0x0804, 0xca06, 0x6003, 0x0007, 0x601b,
+	0x0000, 0x080c, 0x7e13, 0x009e, 0x0005, 0x6124, 0xd1f4, 0x1d58,
+	0x0006, 0x0046, 0xacac, 0x9422, 0xa9b0, 0x2200, 0x910b, 0x6030,
+	0x9420, 0x6432, 0x602c, 0x9109, 0x612e, 0x004e, 0x000e, 0x08d8,
+	0x6110, 0x00b6, 0x2158, 0xb900, 0x00be, 0xd1bc, 0x1178, 0x2009,
+	0x180d, 0x210c, 0xd19c, 0x0118, 0x6003, 0x0007, 0x0010, 0x6003,
+	0x0006, 0x00e9, 0x080c, 0x7e15, 0x009e, 0x0005, 0x6003, 0x0002,
+	0x009e, 0x0005, 0x6024, 0xd0f4, 0x0128, 0x080c, 0x14c9, 0x1904,
+	0xc997, 0x0005, 0x6014, 0x0096, 0x2048, 0xa834, 0xa938, 0x009e,
+	0x9105, 0x1120, 0x080c, 0x14c9, 0x1904, 0xc997, 0x0005, 0xd2fc,
+	0x0140, 0x8002, 0x8000, 0x8212, 0x9291, 0x0000, 0x2009, 0x0009,
+	0x0010, 0x2009, 0x0015, 0xaa9a, 0xa896, 0x0005, 0x9182, 0x0040,
+	0x0208, 0x0062, 0x9186, 0x0013, 0x0120, 0x9186, 0x0014, 0x190c,
+	0x0db2, 0x6024, 0xd0dc, 0x090c, 0x0db2, 0x0005, 0xca29, 0xca35,
+	0xca41, 0xca4d, 0xca29, 0xca29, 0xca29, 0xca29, 0xca30, 0xca2b,
+	0xca2b, 0xca29, 0xca29, 0xca29, 0xca29, 0xca2b, 0xca29, 0xca2b,
+	0xca29, 0x080c, 0x0db2, 0x6024, 0xd0dc, 0x090c, 0x0db2, 0x0005,
+	0x6014, 0x9005, 0x190c, 0x0db2, 0x0005, 0x6003, 0x0001, 0x6106,
+	0x080c, 0x8000, 0x0126, 0x2091, 0x8000, 0x080c, 0x8582, 0x012e,
+	0x0005, 0x6003, 0x0001, 0x6106, 0x080c, 0x8000, 0x0126, 0x2091,
+	0x8000, 0x080c, 0x8582, 0x012e, 0x0005, 0x6003, 0x0003, 0x6106,
+	0x2c10, 0x080c, 0x1976, 0x0126, 0x2091, 0x8000, 0x080c, 0x8065,
+	0x080c, 0x865d, 0x012e, 0x0005, 0x0126, 0x2091, 0x8000, 0x0036,
+	0x0096, 0x9182, 0x0040, 0x0023, 0x009e, 0x003e, 0x012e, 0x0005,
+	0xca78, 0xca7a, 0xca8c, 0xcaa6, 0xca78, 0xca78, 0xca78, 0xca78,
+	0xca78, 0xca78, 0xca78, 0xca78, 0xca78, 0xca78, 0xca78, 0xca78,
+	0x080c, 0x0db2, 0x6014, 0x2048, 0xa87c, 0xd0fc, 0x01f8, 0x909c,
+	0x0003, 0x939e, 0x0003, 0x01d0, 0x6003, 0x0001, 0x6106, 0x080c,
+	0x8000, 0x080c, 0x8582, 0x0470, 0x6014, 0x2048, 0xa87c, 0xd0fc,
+	0x0168, 0x909c, 0x0003, 0x939e, 0x0003, 0x0140, 0x6003, 0x0001,
+	0x6106, 0x080c, 0x8000, 0x080c, 0x8582, 0x00e0, 0x901e, 0x6316,
+	0x631a, 0x2019, 0x0004, 0x080c, 0xcf91, 0x00a0, 0x6014, 0x2048,
+	0xa87c, 0xd0fc, 0x0d98, 0x909c, 0x0003, 0x939e, 0x0003, 0x0d70,
+	0x6003, 0x0003, 0x6106, 0x2c10, 0x080c, 0x1976, 0x080c, 0x8065,
+	0x080c, 0x865d, 0x0005, 0x080c, 0x847d, 0x6114, 0x81ff, 0x0158,
+	0x0096, 0x2148, 0x080c, 0xd28c, 0x0036, 0x2019, 0x0029, 0x080c,
+	0xcf91, 0x003e, 0x009e, 0x080c, 0x9a06, 0x080c, 0x8582, 0x0005,
+	0x080c, 0x8532, 0x6114, 0x81ff, 0x0158, 0x0096, 0x2148, 0x080c,
+	0xd28c, 0x0036, 0x2019, 0x0029, 0x080c, 0xcf91, 0x003e, 0x009e,
+	0x080c, 0x9a06, 0x080c, 0x865d, 0x0005, 0x9182, 0x0085, 0x0002,
+	0xcaf7, 0xcaf5, 0xcaf5, 0xcb03, 0xcaf5, 0xcaf5, 0xcaf5, 0xcaf5,
+	0xcaf5, 0xcaf5, 0xcaf5, 0xcaf5, 0xcaf5, 0x080c, 0x0db2, 0x6003,
+	0x000b, 0x6106, 0x080c, 0x8000, 0x0126, 0x2091, 0x8000, 0x080c,
+	0x8582, 0x012e, 0x0005, 0x0026, 0x00e6, 0x080c, 0xd1df, 0x0118,
+	0x080c, 0x99d6, 0x0450, 0x2071, 0x0260, 0x7224, 0x6216, 0x2001,
+	0x180d, 0x2004, 0xd0e4, 0x0150, 0x6010, 0x00b6, 0x2058, 0xbca0,
+	0x00be, 0x2c00, 0x2011, 0x014e, 0x080c, 0x9cf4, 0x7220, 0x080c,
+	0xce37, 0x0118, 0x6007, 0x0086, 0x0040, 0x6007, 0x0087, 0x7224,
+	0x9296, 0xffff, 0x1110, 0x6007, 0x0086, 0x6003, 0x0001, 0x080c,
+	0x8000, 0x080c, 0x8582, 0x080c, 0x865d, 0x00ee, 0x002e, 0x0005,
+	0x9186, 0x0013, 0x1160, 0x6004, 0x908a, 0x0085, 0x0a0c, 0x0db2,
+	0x908a, 0x0092, 0x1a0c, 0x0db2, 0x9082, 0x0085, 0x00a2, 0x9186,
+	0x0027, 0x0130, 0x9186, 0x0014, 0x0118, 0x080c, 0x9a6b, 0x0050,
+	0x2001, 0x0007, 0x080c, 0x5efb, 0x080c, 0x847d, 0x080c, 0x9a06,
+	0x080c, 0x8582, 0x0005, 0xcb68, 0xcb6a, 0xcb6a, 0xcb68, 0xcb68,
+	0xcb68, 0xcb68, 0xcb68, 0xcb68, 0xcb68, 0xcb68, 0xcb68, 0xcb68,
+	0x080c, 0x0db2, 0x080c, 0x847d, 0x080c, 0x9a06, 0x080c, 0x8582,
+	0x0005, 0x9182, 0x0085, 0x0a0c, 0x0db2, 0x9182, 0x0092, 0x1a0c,
+	0x0db2, 0x9182, 0x0085, 0x0002, 0xcb89, 0xcb89, 0xcb89, 0xcb8b,
+	0xcb89, 0xcb89, 0xcb89, 0xcb89, 0xcb89, 0xcb89, 0xcb89, 0xcb89,
+	0xcb89, 0x080c, 0x0db2, 0x0005, 0x9186, 0x0013, 0x0148, 0x9186,
+	0x0014, 0x0130, 0x9186, 0x0027, 0x0118, 0x080c, 0x9a6b, 0x0030,
+	0x080c, 0x847d, 0x080c, 0x9a06, 0x080c, 0x8582, 0x0005, 0x0036,
+	0x080c, 0xd240, 0x6043, 0x0000, 0x2019, 0x000b, 0x0031, 0x6023,
+	0x0006, 0x6003, 0x0007, 0x003e, 0x0005, 0x0126, 0x0036, 0x2091,
+	0x8000, 0x0086, 0x2c40, 0x0096, 0x904e, 0x080c, 0x9349, 0x009e,
+	0x008e, 0x1550, 0x0076, 0x2c38, 0x080c, 0x93f4, 0x007e, 0x1520,
+	0x6000, 0x9086, 0x0000, 0x0500, 0x6020, 0x9086, 0x0007, 0x01e0,
+	0x0096, 0x601c, 0xd084, 0x0140, 0x080c, 0xd240, 0x080c, 0xbd04,
+	0x080c, 0x1827, 0x6023, 0x0007, 0x6014, 0x2048, 0x080c, 0xb5fb,
+	0x0110, 0x080c, 0xcf91, 0x009e, 0x6017, 0x0000, 0x080c, 0xd240,
+	0x6023, 0x0007, 0x080c, 0xbd04, 0x003e, 0x012e, 0x0005, 0x00f6,
+	0x00c6, 0x00b6, 0x0036, 0x0156, 0x2079, 0x0260, 0x7938, 0x783c,
+	0x080c, 0x24d6, 0x15b8, 0x0016, 0x00c6, 0x080c, 0x5f7e, 0x1580,
+	0x001e, 0x00c6, 0x2160, 0x080c, 0xbd01, 0x00ce, 0x002e, 0x0026,
+	0x0016, 0x2019, 0x0029, 0x080c, 0x94b5, 0x080c, 0x8180, 0x0076,
+	0x903e, 0x080c, 0x8078, 0x007e, 0x001e, 0x0076, 0x903e, 0x080c,
+	0xcd62, 0x007e, 0x0026, 0xba04, 0x9294, 0xff00, 0x8217, 0x9286,
+	0x0006, 0x0118, 0x9286, 0x0004, 0x1118, 0xbaa0, 0x080c, 0x2eea,
+	0x002e, 0x001e, 0x080c, 0x5a3b, 0xbe12, 0xbd16, 0x9006, 0x0010,
+	0x00ce, 0x001e, 0x015e, 0x003e, 0x00be, 0x00ce, 0x00fe, 0x0005,
+	0x00c6, 0x00d6, 0x00b6, 0x0016, 0x2009, 0x1822, 0x2104, 0x9086,
+	0x0074, 0x1904, 0xcc89, 0x2069, 0x0260, 0x6944, 0x9182, 0x0100,
+	0x06e0, 0x6940, 0x9184, 0x8000, 0x0904, 0xcc86, 0x2001, 0x194d,
+	0x2004, 0x9005, 0x1140, 0x6010, 0x2058, 0xb8b0, 0x9005, 0x0118,
+	0x9184, 0x0800, 0x0598, 0x6948, 0x918a, 0x0001, 0x0648, 0x080c,
+	0xd2f4, 0x0118, 0x6978, 0xd1fc, 0x11b8, 0x2009, 0x0205, 0x200b,
+	0x0001, 0x693c, 0x81ff, 0x1198, 0x6944, 0x9182, 0x0100, 0x02a8,
+	0x6940, 0x81ff, 0x1178, 0x6948, 0x918a, 0x0001, 0x0288, 0x6950,
+	0x918a, 0x0001, 0x0298, 0x00d0, 0x6017, 0x0100, 0x00a0, 0x6017,
+	0x0300, 0x0088, 0x6017, 0x0500, 0x0070, 0x6017, 0x0700, 0x0058,
+	0x6017, 0x0900, 0x0040, 0x6017, 0x0b00, 0x0028, 0x6017, 0x0f00,
+	0x0010, 0x6017, 0x2d00, 0x9085, 0x0001, 0x0008, 0x9006, 0x001e,
+	0x00be, 0x00de, 0x00ce, 0x0005, 0x00c6, 0x00b6, 0x0026, 0x0036,
+	0x0156, 0x6210, 0x2258, 0xbb04, 0x9394, 0x00ff, 0x9286, 0x0006,
+	0x0180, 0x9286, 0x0004, 0x0168, 0x9394, 0xff00, 0x8217, 0x9286,
+	0x0006, 0x0138, 0x9286, 0x0004, 0x0120, 0x080c, 0x5f8d, 0x0804,
+	0xccf1, 0x2011, 0x0276, 0x20a9, 0x0004, 0x0096, 0x2b48, 0x2019,
+	0x000a, 0x080c, 0xa91d, 0x009e, 0x15a8, 0x2011, 0x027a, 0x20a9,
+	0x0004, 0x0096, 0x2b48, 0x2019, 0x0006, 0x080c, 0xa91d, 0x009e,
+	0x1548, 0x0046, 0x0016, 0xbaa0, 0x2220, 0x9006, 0x2009, 0x1854,
+	0x210c, 0xd1a4, 0x0138, 0x2009, 0x0029, 0x080c, 0xcfe6, 0xb800,
+	0xc0e5, 0xb802, 0x2019, 0x0029, 0x080c, 0x8180, 0x0076, 0x2039,
+	0x0000, 0x080c, 0x8078, 0x2c08, 0x080c, 0xcd62, 0x007e, 0x2001,
+	0x0007, 0x080c, 0x5efb, 0x2001, 0x0007, 0x080c, 0x5ecf, 0x001e,
+	0x004e, 0x9006, 0x015e, 0x003e, 0x002e, 0x00be, 0x00ce, 0x0005,
+	0x00d6, 0x2069, 0x026e, 0x6800, 0x9086, 0x0800, 0x0118, 0x6017,
+	0x0000, 0x0008, 0x9006, 0x00de, 0x0005, 0x00b6, 0x00f6, 0x0016,
+	0x0026, 0x0036, 0x0156, 0x2079, 0x026c, 0x7930, 0x7834, 0x080c,
+	0x24d6, 0x11d0, 0x080c, 0x5f7e, 0x11b8, 0x2011, 0x0270, 0x20a9,
+	0x0004, 0x0096, 0x2b48, 0x2019, 0x000a, 0x080c, 0xa91d, 0x009e,
+	0x1158, 0x2011, 0x0274, 0x20a9, 0x0004, 0x0096, 0x2b48, 0x2019,
+	0x0006, 0x080c, 0xa91d, 0x009e, 0x015e, 0x003e, 0x002e, 0x001e,
+	0x00fe, 0x00be, 0x0005, 0x00b6, 0x0006, 0x0016, 0x0026, 0x0036,
+	0x0156, 0x2011, 0x0263, 0x2204, 0x8211, 0x220c, 0x080c, 0x24d6,
+	0x11d0, 0x080c, 0x5f7e, 0x11b8, 0x2011, 0x0276, 0x20a9, 0x0004,
+	0x0096, 0x2b48, 0x2019, 0x000a, 0x080c, 0xa91d, 0x009e, 0x1158,
+	0x2011, 0x027a, 0x20a9, 0x0004, 0x0096, 0x2b48, 0x2019, 0x0006,
+	0x080c, 0xa91d, 0x009e, 0x015e, 0x003e, 0x002e, 0x001e, 0x000e,
+	0x00be, 0x0005, 0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x0056,
+	0x0046, 0x0026, 0x0126, 0x2091, 0x8000, 0x2740, 0x2029, 0x19bf,
+	0x252c, 0x2021, 0x19c5, 0x2424, 0x2061, 0x1cd0, 0x2071, 0x1800,
+	0x764c, 0x706c, 0x81ff, 0x0150, 0x0006, 0x9186, 0x1a73, 0x000e,
+	0x0128, 0x8001, 0x9602, 0x1a04, 0xcdf0, 0x0018, 0x9606, 0x0904,
+	0xcdf0, 0x2100, 0x9c06, 0x0904, 0xcde7, 0x080c, 0xd022, 0x1904,
+	0xcde7, 0x080c, 0xd311, 0x0904, 0xcde7, 0x080c, 0xd012, 0x0904,
+	0xcde7, 0x6720, 0x9786, 0x0001, 0x1148, 0x080c, 0x2f81, 0x0904,
+	0xce0b, 0x6004, 0x9086, 0x0000, 0x1904, 0xce0b, 0x9786, 0x0004,
+	0x0904, 0xce0b, 0x9786, 0x0007, 0x05d0, 0x2500, 0x9c06, 0x05b8,
+	0x2400, 0x9c06, 0x05a0, 0x88ff, 0x0118, 0x6054, 0x9906, 0x1578,
+	0x0096, 0x6000, 0x9086, 0x0004, 0x1120, 0x0016, 0x080c, 0x1827,
+	0x001e, 0x9786, 0x000a, 0x0148, 0x080c, 0xb7fa, 0x1130, 0x080c,
+	0xa364, 0x009e, 0x080c, 0x9a06, 0x00d0, 0x6014, 0x2048, 0x080c,
+	0xb5fb, 0x0190, 0x9786, 0x0003, 0x1528, 0xa867, 0x0103, 0xab7a,
+	0xa877, 0x0000, 0x080c, 0xd28c, 0x0016, 0x080c, 0xb8e3, 0x080c,
+	0x6529, 0x001e, 0x080c, 0xb7dd, 0x009e, 0x080c, 0x9a06, 0x9ce0,
+	0x0018, 0x2001, 0x1818, 0x2004, 0x9c02, 0x1210, 0x0804, 0xcd76,
+	0x012e, 0x002e, 0x004e, 0x005e, 0x006e, 0x007e, 0x008e, 0x00ce,
+	0x00ee, 0x0005, 0x9786, 0x0006, 0x1150, 0x9386, 0x0005, 0x0128,
+	0x080c, 0xd28c, 0x080c, 0xcf91, 0x08f8, 0x009e, 0x0c00, 0x9786,
+	0x000a, 0x0968, 0x0850, 0x81ff, 0x09d0, 0x9180, 0x0001, 0x2004,
+	0x9086, 0x0018, 0x0130, 0x9180, 0x0001, 0x2004, 0x9086, 0x002d,
+	0x1970, 0x6000, 0x9086, 0x0002, 0x1950, 0x080c, 0xb7e9, 0x0130,
+	0x080c, 0xb7fa, 0x1920, 0x080c, 0xa364, 0x0038, 0x080c, 0x2e55,
+	0x080c, 0xb7fa, 0x1110, 0x080c, 0xa364, 0x080c, 0x9a06, 0x0804,
+	0xcde7, 0xa864, 0x9084, 0x00ff, 0x9086, 0x0039, 0x0005, 0x00c6,
+	0x00e6, 0x0016, 0x2c08, 0x2170, 0x9006, 0x080c, 0xcfb8, 0x001e,
+	0x0120, 0x6020, 0x9084, 0x000f, 0x001b, 0x00ee, 0x00ce, 0x0005,
+	0xce56, 0xce56, 0xce56, 0xce56, 0xce56, 0xce56, 0xce58, 0xce56,
+	0xce56, 0xce56, 0xce56, 0x9a06, 0x9a06, 0xce56, 0x9006, 0x0005,
+	0x0036, 0x0046, 0x0016, 0x7010, 0x00b6, 0x2058, 0xbca0, 0x00be,
+	0x2c00, 0x2009, 0x0020, 0x080c, 0xcfe6, 0x001e, 0x004e, 0x2019,
+	0x0002, 0x080c, 0xcbad, 0x003e, 0x9085, 0x0001, 0x0005, 0x0096,
+	0x080c, 0xb5fb, 0x0140, 0x6014, 0x904d, 0x080c, 0xb251, 0x687b,
+	0x0005, 0x080c, 0x6536, 0x009e, 0x080c, 0x9a06, 0x9085, 0x0001,
+	0x0005, 0x2001, 0x0001, 0x080c, 0x5ebb, 0x0156, 0x0016, 0x0026,
+	0x0036, 0x20a9, 0x0004, 0x2019, 0x1805, 0x2011, 0x0276, 0x080c,
+	0xa909, 0x003e, 0x002e, 0x001e, 0x015e, 0x9005, 0x0005, 0x00f6,
+	0x00e6, 0x00c6, 0x0086, 0x0076, 0x0066, 0x00b6, 0x0126, 0x2091,
+	0x8000, 0x2740, 0x2061, 0x1cd0, 0x2079, 0x0001, 0x8fff, 0x0904,
+	0xcef1, 0x2071, 0x1800, 0x764c, 0x706c, 0x8001, 0x9602, 0x1a04,
+	0xcef1, 0x88ff, 0x0120, 0x2800, 0x9c06, 0x1590, 0x2078, 0x080c,
+	0xd012, 0x0570, 0x2400, 0x9c06, 0x0558, 0x6720, 0x9786, 0x0006,
+	0x1538, 0x9786, 0x0007, 0x0520, 0x88ff, 0x1140, 0x6010, 0x9b06,
+	0x11f8, 0x85ff, 0x0118, 0x6054, 0x9106, 0x11d0, 0x0096, 0x601c,
+	0xd084, 0x0140, 0x080c, 0xd240, 0x080c, 0xbd04, 0x080c, 0x1827,
+	0x6023, 0x0007, 0x6014, 0x2048, 0x080c, 0xb5fb, 0x0120, 0x0046,
+	0x080c, 0xcf91, 0x004e, 0x009e, 0x080c, 0x9a06, 0x88ff, 0x1198,
+	0x9ce0, 0x0018, 0x2001, 0x1818, 0x2004, 0x9c02, 0x1210, 0x0804,
+	0xcea6, 0x9006, 0x012e, 0x00be, 0x006e, 0x007e, 0x008e, 0x00ce,
+	0x00ee, 0x00fe, 0x0005, 0x98c5, 0x0001, 0x0ca0, 0x00b6, 0x0076,
+	0x0056, 0x0086, 0x9046, 0x2029, 0x0001, 0x2c20, 0x2019, 0x0002,
+	0x6210, 0x2258, 0x0096, 0x904e, 0x080c, 0x9349, 0x009e, 0x008e,
+	0x903e, 0x080c, 0x93f4, 0x080c, 0xce97, 0x005e, 0x007e, 0x00be,
+	0x0005, 0x00b6, 0x0046, 0x0056, 0x0076, 0x00c6, 0x0156, 0x2c20,
+	0x2128, 0x20a9, 0x007f, 0x900e, 0x0016, 0x0036, 0x080c, 0x5f7e,
+	0x1190, 0x0056, 0x0086, 0x9046, 0x2508, 0x2029, 0x0001, 0x0096,
+	0x904e, 0x080c, 0x9349, 0x009e, 0x008e, 0x903e, 0x080c, 0x93f4,
+	0x080c, 0xce97, 0x005e, 0x003e, 0x001e, 0x8108, 0x1f04, 0xcf24,
+	0x015e, 0x00ce, 0x007e, 0x005e, 0x004e, 0x00be, 0x0005, 0x00b6,
+	0x0076, 0x0056, 0x6210, 0x2258, 0x0086, 0x9046, 0x2029, 0x0001,
+	0x2019, 0x0048, 0x0096, 0x904e, 0x080c, 0x9349, 0x009e, 0x008e,
+	0x903e, 0x080c, 0x93f4, 0x2c20, 0x080c, 0xce97, 0x005e, 0x007e,
+	0x00be, 0x0005, 0x00b6, 0x0046, 0x0056, 0x0076, 0x00c6, 0x0156,
+	0x2c20, 0x20a9, 0x0800, 0x900e, 0x0016, 0x0036, 0x080c, 0x5f7e,
+	0x11a0, 0x0086, 0x9046, 0x2828, 0x0046, 0x2021, 0x0001, 0x080c,
+	0xd224, 0x004e, 0x0096, 0x904e, 0x080c, 0x9349, 0x009e, 0x008e,
+	0x903e, 0x080c, 0x93f4, 0x080c, 0xce97, 0x003e, 0x001e, 0x8108,
+	0x1f04, 0xcf6c, 0x015e, 0x00ce, 0x007e, 0x005e, 0x004e, 0x00be,
+	0x0005, 0x0016, 0x00f6, 0x080c, 0xb5f9, 0x0198, 0xa864, 0x9084,
+	0x00ff, 0x9086, 0x0046, 0x0180, 0xa800, 0x907d, 0x0138, 0xa803,
+	0x0000, 0xab82, 0x080c, 0x6536, 0x2f48, 0x0cb0, 0xab82, 0x080c,
+	0x6536, 0x00fe, 0x001e, 0x0005, 0xa800, 0x907d, 0x0130, 0xa803,
+	0x0000, 0x080c, 0x6536, 0x2f48, 0x0cb8, 0x080c, 0x6536, 0x0c88,
+	0x00e6, 0x0046, 0x0036, 0x2061, 0x1cd0, 0x9005, 0x1138, 0x2071,
+	0x1800, 0x744c, 0x706c, 0x8001, 0x9402, 0x12d8, 0x2100, 0x9c06,
+	0x0168, 0x6000, 0x9086, 0x0000, 0x0148, 0x6008, 0x9206, 0x1130,
+	0x6010, 0x91a0, 0x0004, 0x2424, 0x9406, 0x0140, 0x9ce0, 0x0018,
+	0x2001, 0x1818, 0x2004, 0x9c02, 0x1220, 0x0c40, 0x9085, 0x0001,
+	0x0008, 0x9006, 0x003e, 0x004e, 0x00ee, 0x0005, 0x0096, 0x0006,
+	0x080c, 0x0fd5, 0x000e, 0x090c, 0x0db2, 0xa867, 0x010d, 0xa88e,
+	0x0026, 0x2010, 0x080c, 0xb5e9, 0x2001, 0x0000, 0x0120, 0x2200,
+	0x9080, 0x0015, 0x2004, 0x002e, 0xa87a, 0xa986, 0xac76, 0xa87f,
+	0x0000, 0x2001, 0x195d, 0x2004, 0xa882, 0x9006, 0xa8e2, 0xa802,
+	0xa86a, 0xa88a, 0x0126, 0x2091, 0x8000, 0x080c, 0x6536, 0x012e,
+	0x009e, 0x0005, 0x6700, 0x9786, 0x0000, 0x0158, 0x9786, 0x0001,
+	0x0140, 0x9786, 0x000a, 0x0128, 0x9786, 0x0009, 0x0110, 0x9085,
+	0x0001, 0x0005, 0x00e6, 0x6010, 0x9075, 0x0138, 0x00b6, 0x2058,
+	0xb8a0, 0x00be, 0x9206, 0x00ee, 0x0005, 0x9085, 0x0001, 0x0cd8,
+	0x0016, 0x6004, 0x908e, 0x001e, 0x11a0, 0x8007, 0x6134, 0x918c,
+	0x00ff, 0x9105, 0x6036, 0x6007, 0x0085, 0x6003, 0x000b, 0x6023,
+	0x0005, 0x2001, 0x1956, 0x2004, 0x601a, 0x080c, 0x8000, 0x080c,
+	0x8582, 0x001e, 0x0005, 0xa001, 0xa001, 0x0005, 0x6024, 0xd0e4,
+	0x0158, 0xd0cc, 0x0118, 0x080c, 0xb927, 0x0030, 0x080c, 0xd240,
+	0x080c, 0x7e13, 0x080c, 0x99d6, 0x0005, 0x9280, 0x0008, 0x2004,
+	0x9084, 0x000f, 0x0002, 0xd071, 0xd071, 0xd071, 0xd073, 0xd071,
+	0xd073, 0xd073, 0xd071, 0xd073, 0xd071, 0xd071, 0xd071, 0xd071,
+	0xd071, 0x9006, 0x0005, 0x9085, 0x0001, 0x0005, 0x9280, 0x0008,
+	0x2004, 0x9084, 0x000f, 0x0002, 0xd08a, 0xd08a, 0xd08a, 0xd08a,
+	0xd08a, 0xd08a, 0xd097, 0xd08a, 0xd08a, 0xd08a, 0xd08a, 0xd08a,
+	0xd08a, 0xd08a, 0x6007, 0x003b, 0x602f, 0x0009, 0x6017, 0x2a00,
+	0x6003, 0x0001, 0x080c, 0x8000, 0x080c, 0x8582, 0x0005, 0x0096,
+	0x00c6, 0x2260, 0x080c, 0xd240, 0x6043, 0x0000, 0x6024, 0xc0f4,
+	0xc0e4, 0x6026, 0x603b, 0x0000, 0x00ce, 0x00d6, 0x2268, 0x9186,
+	0x0007, 0x1904, 0xd0f1, 0x6814, 0x9005, 0x0138, 0x2048, 0xa87c,
+	0xd0fc, 0x1118, 0x00de, 0x009e, 0x08a8, 0x6007, 0x003a, 0x6003,
+	0x0001, 0x080c, 0x8000, 0x080c, 0x8582, 0x00c6, 0x2d60, 0x6100,
+	0x9186, 0x0002, 0x1904, 0xd169, 0x6014, 0x9005, 0x1138, 0x6000,
+	0x9086, 0x0007, 0x190c, 0x0db2, 0x0804, 0xd169, 0x2048, 0x080c,
+	0xb5fb, 0x1130, 0x0028, 0x2048, 0xa800, 0x9005, 0x1de0, 0x2900,
+	0x2048, 0xa87c, 0x9084, 0x0003, 0x9086, 0x0002, 0x1170, 0xa87c,
+	0xc0dc, 0xc0f4, 0xa87e, 0xa880, 0xc0f4, 0xc0fc, 0xa882, 0x2009,
+	0x0043, 0x080c, 0xca06, 0x0804, 0xd169, 0x2009, 0x0041, 0x0804,
+	0xd163, 0x9186, 0x0005, 0x15a8, 0x6814, 0x2048, 0xa87c, 0xd0bc,
+	0x1120, 0x00de, 0x009e, 0x0804, 0xd08a, 0xd0b4, 0x0128, 0xd0fc,
+	0x090c, 0x0db2, 0x0804, 0xd0ab, 0x6007, 0x003a, 0x6003, 0x0001,
+	0x080c, 0x8000, 0x080c, 0x8582, 0x00c6, 0x2d60, 0x6100, 0x9186,
+	0x0002, 0x0120, 0x9186, 0x0004, 0x1904, 0xd169, 0x6814, 0x2048,
+	0xa97c, 0xc1f4, 0xc1dc, 0xa97e, 0xa980, 0xc1f4, 0xc1fc, 0xc1bc,
+	0xa982, 0x00f6, 0x2c78, 0x080c, 0x1582, 0x00fe, 0x2009, 0x0042,
+	0x04d0, 0x0036, 0x080c, 0x0fd5, 0x090c, 0x0db2, 0xa867, 0x010d,
+	0x9006, 0xa802, 0xa86a, 0xa88a, 0x2d18, 0xab8e, 0xa887, 0x0045,
+	0x2c00, 0xa892, 0x6038, 0xa8a2, 0x2360, 0x6024, 0xc0dd, 0x6026,
+	0x6010, 0x00b6, 0x2058, 0xb8a0, 0x00be, 0x2004, 0x6354, 0xab7a,
+	0xa876, 0x9006, 0xa87e, 0xa882, 0xad9a, 0xae96, 0xa89f, 0x0001,
+	0x080c, 0x6536, 0x2019, 0x0045, 0x6008, 0x2068, 0x080c, 0xcbad,
+	0x2d00, 0x600a, 0x6023, 0x0006, 0x6003, 0x0007, 0x901e, 0x631a,
+	0x6342, 0x003e, 0x0038, 0x6043, 0x0000, 0x6003, 0x0007, 0x080c,
+	0xca06, 0x00ce, 0x00de, 0x009e, 0x0005, 0x9186, 0x0013, 0x1128,
+	0x6004, 0x9082, 0x0085, 0x2008, 0x00c2, 0x9186, 0x0027, 0x1178,
+	0x080c, 0x847d, 0x0036, 0x0096, 0x6014, 0x2048, 0x2019, 0x0004,
+	0x080c, 0xcf91, 0x009e, 0x003e, 0x080c, 0x8582, 0x0005, 0x9186,
+	0x0014, 0x0d70, 0x080c, 0x9a6b, 0x0005, 0xd19c, 0xd19a, 0xd19a,
+	0xd19a, 0xd19a, 0xd19a, 0xd19c, 0xd19a, 0xd19a, 0xd19a, 0xd19a,
+	0xd19a, 0xd19a, 0x080c, 0x0db2, 0x080c, 0x847d, 0x6003, 0x000c,
+	0x080c, 0x8582, 0x0005, 0x9182, 0x0092, 0x1220, 0x9182, 0x0085,
+	0x0208, 0x001a, 0x080c, 0x9a6b, 0x0005, 0xd1ba, 0xd1ba, 0xd1ba,
+	0xd1ba, 0xd1bc, 0xd1dc, 0xd1ba, 0xd1ba, 0xd1ba, 0xd1ba, 0xd1ba,
+	0xd1ba, 0xd1ba, 0x080c, 0x0db2, 0x00d6, 0x2c68, 0x080c, 0x9980,
+	0x01b0, 0x6003, 0x0001, 0x6007, 0x001e, 0x2009, 0x026e, 0x210c,
+	0x613a, 0x2009, 0x026f, 0x210c, 0x613e, 0x600b, 0xffff, 0x6910,
+	0x6112, 0x6023, 0x0004, 0x080c, 0x8000, 0x080c, 0x8582, 0x2d60,
+	0x080c, 0x99d6, 0x00de, 0x0005, 0x080c, 0x99d6, 0x0005, 0x00e6,
+	0x6010, 0x00b6, 0x2058, 0xb800, 0x00be, 0xd0ec, 0x00ee, 0x0005,
+	0x2009, 0x1873, 0x210c, 0xd1ec, 0x05b0, 0x6003, 0x0002, 0x6024,
+	0xc0e5, 0x6026, 0xd0cc, 0x0150, 0x2001, 0x1957, 0x2004, 0x6042,
+	0x2009, 0x1873, 0x210c, 0xd1f4, 0x1520, 0x00a0, 0x2009, 0x1873,
+	0x210c, 0xd1f4, 0x0128, 0x6024, 0xc0e4, 0x6026, 0x9006, 0x00d8,
+	0x2001, 0x1957, 0x200c, 0x2001, 0x1955, 0x2004, 0x9100, 0x9080,
+	0x000a, 0x6042, 0x6010, 0x00b6, 0x2058, 0xb8ac, 0x00be, 0x0008,
+	0x2104, 0x9005, 0x0118, 0x9088, 0x0003, 0x0cd0, 0x2c0a, 0x600f,
+	0x0000, 0x9085, 0x0001, 0x0005, 0x0016, 0x00c6, 0x00e6, 0x6154,
+	0xb8ac, 0x2060, 0x8cff, 0x0180, 0x84ff, 0x1118, 0x6054, 0x9106,
+	0x1138, 0x600c, 0x2072, 0x080c, 0x7e13, 0x080c, 0x99d6, 0x0010,
+	0x9cf0, 0x0003, 0x2e64, 0x0c70, 0x00ee, 0x00ce, 0x001e, 0x0005,
+	0x00d6, 0x00b6, 0x6010, 0x2058, 0xb8ac, 0x2068, 0x9005, 0x0130,
+	0x9c06, 0x0110, 0x680c, 0x0cd0, 0x600c, 0x680e, 0x00be, 0x00de,
+	0x0005, 0x0026, 0x0036, 0x0156, 0x2011, 0x182a, 0x2204, 0x9084,
+	0x00ff, 0x2019, 0x026e, 0x2334, 0x9636, 0x1508, 0x8318, 0x2334,
+	0x2204, 0x9084, 0xff00, 0x9636, 0x11d0, 0x2011, 0x0270, 0x20a9,
+	0x0004, 0x6010, 0x0096, 0x2048, 0x2019, 0x000a, 0x080c, 0xa91d,
+	0x009e, 0x1168, 0x2011, 0x0274, 0x20a9, 0x0004, 0x6010, 0x0096,
+	0x2048, 0x2019, 0x0006, 0x080c, 0xa91d, 0x009e, 0x1100, 0x015e,
+	0x003e, 0x002e, 0x0005, 0x00e6, 0x2071, 0x1800, 0x080c, 0x59b4,
+	0x080c, 0x2c2b, 0x00ee, 0x0005, 0x00e6, 0x6010, 0x00b6, 0x2058,
+	0xb800, 0x00be, 0xd0fc, 0x0108, 0x0011, 0x00ee, 0x0005, 0xa880,
+	0xc0e5, 0xa882, 0x0005, 0x00e6, 0x00d6, 0x00c6, 0x0076, 0x0066,
+	0x0056, 0x0046, 0x0026, 0x0016, 0x0126, 0x2091, 0x8000, 0x2029,
+	0x19bf, 0x252c, 0x2021, 0x19c5, 0x2424, 0x2061, 0x1cd0, 0x2071,
+	0x1800, 0x764c, 0x706c, 0x9606, 0x0578, 0x6720, 0x9786, 0x0001,
+	0x0118, 0x9786, 0x0008, 0x1500, 0x2500, 0x9c06, 0x01e8, 0x2400,
+	0x9c06, 0x01d0, 0x080c, 0xd012, 0x01b8, 0x080c, 0xd022, 0x11a0,
+	0x6000, 0x9086, 0x0004, 0x1120, 0x0016, 0x080c, 0x1827, 0x001e,
+	0x080c, 0xb7e9, 0x1110, 0x080c, 0x2e55, 0x080c, 0xb7fa, 0x1110,
+	0x080c, 0xa364, 0x080c, 0x9a06, 0x9ce0, 0x0018, 0x2001, 0x1818,
+	0x2004, 0x9c02, 0x1208, 0x0858, 0x012e, 0x001e, 0x002e, 0x004e,
+	0x005e, 0x006e, 0x007e, 0x00ce, 0x00de, 0x00ee, 0x0005, 0x2001,
+	0x180f, 0x2004, 0xd0dc, 0x0005, 0x0006, 0x2001, 0x1835, 0x2004,
+	0xd09c, 0x000e, 0x0005, 0x0006, 0x0036, 0x0046, 0x080c, 0xbcec,
+	0x0168, 0x2019, 0xffff, 0x9005, 0x0128, 0x6010, 0x00b6, 0x2058,
+	0xbba0, 0x00be, 0x2021, 0x0004, 0x080c, 0x4829, 0x004e, 0x003e,
+	0x000e, 0x6004, 0x9086, 0x0001, 0x1128, 0x080c, 0x94b5, 0x080c,
+	0x9a06, 0x9006, 0x0005, 0x0126, 0x0006, 0x00e6, 0x0016, 0x2091,
+	0x8000, 0x2071, 0x1840, 0xd5a4, 0x0118, 0x7034, 0x8000, 0x7036,
+	0xd5b4, 0x0118, 0x7030, 0x8000, 0x7032, 0xd5ac, 0x0178, 0x2500,
+	0x9084, 0x0007, 0x908e, 0x0003, 0x0148, 0x908e, 0x0004, 0x0130,
+	0x908e, 0x0005, 0x0118, 0x2071, 0x184a, 0x0089, 0x001e, 0x00ee,
+	0x000e, 0x012e, 0x0005, 0x0126, 0x0006, 0x00e6, 0x2091, 0x8000,
+	0x2071, 0x1842, 0x0021, 0x00ee, 0x000e, 0x012e, 0x0005, 0x2e04,
+	0x8000, 0x2072, 0x1220, 0x8e70, 0x2e04, 0x8000, 0x2072, 0x0005,
+	0x00e6, 0x2071, 0x1840, 0x0c99, 0x00ee, 0x0005, 0x00e6, 0x2071,
+	0x1844, 0x0c69, 0x00ee, 0x0005, 0x0126, 0x0006, 0x00e6, 0x2091,
+	0x8000, 0x2071, 0x1840, 0x7044, 0x8000, 0x7046, 0x00ee, 0x000e,
+	0x012e, 0x0005, 0x0002, 0x0003, 0x03d8, 0x0000, 0x8064, 0x0008,
+	0x0010, 0x0000, 0x8066, 0x0000, 0x0101, 0x0008, 0x4406, 0x000b,
+	0x8060, 0x0000, 0x0400, 0x0000, 0x580c, 0x0003, 0x7933, 0x0003,
+	0x5090, 0x000b, 0x4c09, 0x0003, 0xbac0, 0x0009, 0x008a, 0x0000,
+	0x0c09, 0x000b, 0x15fe, 0x0008, 0x3409, 0x0003, 0x808c, 0x0008,
+	0x0001, 0x0000, 0x0000, 0x0007, 0x4047, 0x000a, 0x808c, 0x0008,
+	0x0002, 0x0000, 0x081b, 0x0003, 0x4022, 0x0000, 0x001c, 0x0003,
+	0x4122, 0x0008, 0x4447, 0x0002, 0x0de8, 0x0003, 0x0bfe, 0x0008,
+	0x11a0, 0x0001, 0x11ca, 0x000b, 0x0ca0, 0x0001, 0x11ca, 0x000b,
+	0x9180, 0x0001, 0x0004, 0x0000, 0x8060, 0x0000, 0x0400, 0x0000,
+	0x7f62, 0x0008, 0x8066, 0x0000, 0x0009, 0x0008, 0x442a, 0x0003,
+	0x808c, 0x0008, 0x0000, 0x0008, 0x0060, 0x0008, 0x8062, 0x0008,
+	0x0004, 0x0000, 0x8066, 0x0000, 0x0411, 0x0000, 0x4432, 0x0003,
+	0x03fe, 0x0000, 0x43e0, 0x0001, 0x0dc7, 0x000b, 0xc2c0, 0x0009,
+	0x00ff, 0x0008, 0x02e0, 0x0001, 0x0dc7, 0x000b, 0x9180, 0x0001,
+	0x0005, 0x0008, 0x8060, 0x0000, 0x0400, 0x0000, 0x7f62, 0x0008,
+	0x8066, 0x0000, 0x0019, 0x0000, 0x4441, 0x000b, 0x0240, 0x0002,
+	0x09c4, 0x0003, 0x00fe, 0x0000, 0x31c7, 0x000b, 0x112a, 0x0000,
+	0x002e, 0x0008, 0x022c, 0x0008, 0x3a44, 0x0002, 0x0c09, 0x000b,
+	0x808c, 0x0008, 0x0002, 0x0000, 0x1760, 0x0008, 0x8062, 0x0008,
+	0x000f, 0x0008, 0x8066, 0x0000, 0x0011, 0x0008, 0x4452, 0x0003,
+	0x01fe, 0x0008, 0x42e0, 0x0009, 0x0dba, 0x000b, 0x00fe, 0x0000,
+	0x43e0, 0x0001, 0x0dba, 0x000b, 0x1734, 0x0000, 0x1530, 0x0000,
+	0x1632, 0x0008, 0x0d2a, 0x0008, 0x9880, 0x0001, 0x0010, 0x0000,
+	0x8060, 0x0000, 0x0400, 0x0000, 0x7f62, 0x0008, 0x8066, 0x0000,
+	0x1e0a, 0x0008, 0x4464, 0x0003, 0x808a, 0x0008, 0x0003, 0x0008,
+	0x1a60, 0x0000, 0x8062, 0x0008, 0x0002, 0x0000, 0x586a, 0x0003,
+	0x8066, 0x0000, 0x3679, 0x0000, 0x446d, 0x0003, 0x586e, 0x000b,
+	0x8054, 0x0008, 0x0011, 0x0008, 0x8074, 0x0000, 0x1010, 0x0008,
+	0x1efe, 0x0000, 0x3009, 0x000b, 0x0077, 0x0004, 0x0009, 0x000b,
+	0x1c60, 0x0000, 0x1b62, 0x0000, 0x8066, 0x0000, 0x0231, 0x0008,
+	0x447b, 0x000b, 0x587c, 0x000b, 0x0140, 0x0008, 0x0242, 0x0000,
+	0x1f43, 0x0002, 0x0c86, 0x0003, 0x0d44, 0x0000, 0x0d46, 0x0008,
+	0x0348, 0x0008, 0x044a, 0x0008, 0x008a, 0x0003, 0x0344, 0x0008,
+	0x0446, 0x0008, 0x0548, 0x0008, 0x064a, 0x0000, 0x588a, 0x000b,
+	0x8054, 0x0008, 0x0001, 0x0000, 0x8074, 0x0000, 0x2020, 0x0008,
+	0x4000, 0x000f, 0x3a40, 0x000a, 0x0c0c, 0x000b, 0x2b24, 0x0008,
+	0x2b24, 0x0008, 0x5894, 0x000b, 0x8054, 0x0008, 0x0002, 0x0000,
+	0x1242, 0x0002, 0x08d8, 0x0003, 0x3a45, 0x000a, 0x08c9, 0x0003,
+	0x1e10, 0x000a, 0x7f3c, 0x0000, 0x08c6, 0x0003, 0x1d00, 0x0002,
+	0x7f3a, 0x0000, 0x0d60, 0x0000, 0x7f62, 0x0008, 0x8066, 0x0000,
+	0x0009, 0x0008, 0x44a4, 0x0003, 0x00fe, 0x0000, 0x34c3, 0x0003,
+	0x1c60, 0x0000, 0x8062, 0x0008, 0x0001, 0x0000, 0x8066, 0x0000,
+	0x0009, 0x0008, 0x44ac, 0x000b, 0x00fe, 0x0000, 0x31a3, 0x0003,
+	0x0038, 0x0000, 0x0060, 0x0008, 0x8062, 0x0008, 0x0019, 0x0000,
+	0x8066, 0x0000, 0x0009, 0x0008, 0x44b5, 0x0003, 0x80c0, 0x0009,
+	0x00ff, 0x0008, 0x7f3e, 0x0008, 0x0d60, 0x0000, 0x0efe, 0x0008,
+	0x1f80, 0x0001, 0x7f62, 0x0008, 0x8066, 0x0000, 0x0009, 0x0008,
+	0x44bf, 0x0003, 0x003a, 0x0008, 0x1dfe, 0x0000, 0x00a0, 0x000b,
+	0x0036, 0x0008, 0x0077, 0x0004, 0x00d8, 0x000b, 0x8074, 0x0000,
+	0x2000, 0x0000, 0x00d8, 0x000b, 0x3a44, 0x0002, 0x09cd, 0x0003,
+	0x8074, 0x0000, 0x1000, 0x0000, 0x2d0e, 0x0000, 0x2d0e, 0x0000,
+	0x35a3, 0x000b, 0x26fe, 0x0008, 0x26fe, 0x0008, 0x2700, 0x0008,
+	0x2700, 0x0008, 0x00d0, 0x0009, 0x0ce6, 0x0003, 0x8074, 0x0000,
+	0x4040, 0x0008, 0x58d8, 0x0003, 0x5090, 0x000b, 0x3a46, 0x000a,
+	0x0ce6, 0x0003, 0x3a47, 0x0002, 0x08e3, 0x000b, 0x8054, 0x0008,
+	0x0004, 0x0000, 0x8074, 0x0000, 0x8000, 0x0000, 0x0127, 0x0003,
+	0x92c0, 0x0009, 0x0f88, 0x0008, 0x0809, 0x0003, 0x1a60, 0x0000,
+	0x8062, 0x0008, 0x0002, 0x0000, 0x8066, 0x0000, 0x362a, 0x0000,
+	0x44eb, 0x000b, 0x2000, 0x0000, 0x2000, 0x0000, 0x2102, 0x0000,
+	0x2102, 0x0000, 0x2204, 0x0000, 0x2204, 0x0000, 0x2306, 0x0000,
+	0x2306, 0x0000, 0x2408, 0x0000, 0x2408, 0x0000, 0x250a, 0x0000,
+	0x250a, 0x0000, 0x260c, 0x0000, 0x260c, 0x0000, 0x270e, 0x0000,
+	0x270e, 0x0000, 0x2810, 0x0000, 0x2810, 0x0000, 0x2912, 0x0000,
+	0x2912, 0x0000, 0x1a60, 0x0000, 0x8062, 0x0008, 0x0007, 0x0000,
+	0x8066, 0x0000, 0x0052, 0x0000, 0x4505, 0x0003, 0x92c0, 0x0009,
+	0x0780, 0x0008, 0x0db4, 0x0003, 0x124b, 0x0002, 0x090e, 0x0003,
+	0x2e4d, 0x0002, 0x2e4d, 0x0002, 0x09a3, 0x000b, 0x3a46, 0x000a,
+	0x0d1b, 0x0003, 0x5910, 0x0003, 0x8054, 0x0008, 0x0004, 0x0000,
+	0x1243, 0x000a, 0x0925, 0x0003, 0x8010, 0x0008, 0x000d, 0x0000,
+	0x0194, 0x0004, 0x1810, 0x0000, 0x0194, 0x0004, 0x0125, 0x000b,
+	0x194d, 0x000a, 0x091f, 0x0003, 0x1243, 0x000a, 0x09aa, 0x000b,
+	0x591f, 0x0003, 0x8054, 0x0008, 0x0004, 0x0000, 0x0189, 0x0004,
+	0x1810, 0x0000, 0x0194, 0x0004, 0x8074, 0x0000, 0xf000, 0x0008,
+	0x0d30, 0x0000, 0x3a42, 0x0002, 0x0d2d, 0x0003, 0x15fe, 0x0008,
+	0x344b, 0x0003, 0x0009, 0x000b, 0x8074, 0x0000, 0x0501, 0x0000,
+	0x8010, 0x0008, 0x000c, 0x0008, 0x0194, 0x0004, 0x0009, 0x000b,
+	0xbbe0, 0x0009, 0x0030, 0x0008, 0x0d43, 0x000b, 0x18fe, 0x0000,
+	0x3ce0, 0x0009, 0x0940, 0x0003, 0x15fe, 0x0008, 0x3ce0, 0x0009,
+	0x0940, 0x0003, 0x0184, 0x000c, 0x8076, 0x0008, 0x0040, 0x0000,
+	0x0181, 0x0003, 0x8076, 0x0008, 0x0041, 0x0008, 0x0181, 0x0003,
+	0xbbe0, 0x0009, 0x0032, 0x0000, 0x0d48, 0x0003, 0x3c1e, 0x0008,
+	0x0181, 0x0003, 0xbbe0, 0x0009, 0x0037, 0x0000, 0x0d66, 0x0003,
+	0x18fe, 0x0000, 0x3ce0, 0x0009, 0x0d40, 0x000b, 0x8076, 0x0008,
+	0x0040, 0x0000, 0x1a60, 0x0000, 0x8062, 0x0008, 0x000d, 0x0000,
+	0x2604, 0x0008, 0x2604, 0x0008, 0x2706, 0x0008, 0x2706, 0x0008,
+	0x2808, 0x0000, 0x2808, 0x0000, 0x290a, 0x0000, 0x290a, 0x0000,
+	0x8066, 0x0000, 0x0422, 0x0000, 0x455d, 0x000b, 0x0189, 0x0004,
+	0x8054, 0x0008, 0x0004, 0x0000, 0x8074, 0x0000, 0xf000, 0x0008,
+	0x8072, 0x0000, 0x8000, 0x0000, 0x0127, 0x0003, 0xbbe0, 0x0009,
+	0x0038, 0x0000, 0x0d78, 0x0003, 0x18fe, 0x0000, 0x3ce0, 0x0009,
+	0x0975, 0x0003, 0x15fe, 0x0008, 0x3ce0, 0x0009, 0x0d3c, 0x0003,
+	0x0184, 0x000c, 0x8076, 0x0008, 0x0040, 0x0000, 0x8072, 0x0000,
+	0x8000, 0x0000, 0x01c4, 0x000b, 0x8076, 0x0008, 0x0042, 0x0008,
+	0x0181, 0x0003, 0xbbe0, 0x0009, 0x0016, 0x0000, 0x0d81, 0x0003,
+	0x3a44, 0x0002, 0x0c0b, 0x0003, 0x8072, 0x0000, 0x8000, 0x0000,
+	0x8000, 0x000f, 0x0009, 0x000b, 0x8072, 0x0000, 0x8000, 0x0000,
+	0x0009, 0x000b, 0x3d30, 0x000a, 0x7f00, 0x0000, 0xbc80, 0x0001,
+	0x0007, 0x0000, 0x018d, 0x0003, 0x1930, 0x000a, 0x7f00, 0x0000,
+	0x9880, 0x0001, 0x0007, 0x0000, 0x8060, 0x0000, 0x0400, 0x0000,
+	0x7f62, 0x0008, 0x8066, 0x0000, 0x000a, 0x0008, 0x4592, 0x000b,
+	0x4000, 0x000f, 0x2194, 0x0003, 0x0870, 0x0008, 0x4000, 0x000f,
+	0xbac0, 0x0009, 0x0090, 0x0008, 0x099d, 0x0003, 0x8074, 0x0000,
+	0x0706, 0x0000, 0x019f, 0x0003, 0x8074, 0x0000, 0x0703, 0x0000,
+	0x4000, 0x000f, 0x8010, 0x0008, 0x0008, 0x0000, 0x01d2, 0x0003,
+	0x0189, 0x0004, 0x8010, 0x0008, 0x0007, 0x0000, 0x0194, 0x0004,
+	0x1810, 0x0000, 0x0194, 0x0004, 0x01dc, 0x000b, 0x0189, 0x0004,
+	0x8010, 0x0008, 0x001b, 0x0008, 0x0194, 0x0004, 0x1810, 0x0000,
+	0x0194, 0x0004, 0x8074, 0x0000, 0xf080, 0x0000, 0x0d30, 0x0000,
+	0x0009, 0x000b, 0x8010, 0x0008, 0x0009, 0x0008, 0x01d2, 0x0003,
+	0x8010, 0x0008, 0x0005, 0x0008, 0x01d2, 0x0003, 0x808c, 0x0008,
+	0x0001, 0x0000, 0x8010, 0x0008, 0x0004, 0x0000, 0x4143, 0x000a,
+	0x0859, 0x0003, 0x3a44, 0x0002, 0x0c09, 0x000b, 0x0d2a, 0x0008,
+	0x01d2, 0x0003, 0x8010, 0x0008, 0x0003, 0x0008, 0x01d4, 0x0003,
+	0x8010, 0x0008, 0x000b, 0x0000, 0x01d4, 0x0003, 0x8010, 0x0008,
+	0x0002, 0x0000, 0x01d4, 0x0003, 0x3a47, 0x0002, 0x0cd8, 0x000b,
+	0x8010, 0x0008, 0x0006, 0x0008, 0x01d4, 0x0003, 0x8074, 0x0000,
+	0xf000, 0x0008, 0x0194, 0x0004, 0x0197, 0x0004, 0x3a40, 0x000a,
+	0x0809, 0x0003, 0x8010, 0x0008, 0x000c, 0x0008, 0x0194, 0x0004,
+	0x0009, 0x000b, 0x8074, 0x0000, 0xf080, 0x0000, 0x0d30, 0x0000,
+	0x2e4d, 0x0002, 0x2e4d, 0x0002, 0x09e5, 0x0003, 0x8054, 0x0008,
+	0x0019, 0x0000, 0x0009, 0x000b, 0x8054, 0x0008, 0x0009, 0x0008,
+	0x0009, 0x000b, 0x3a44, 0x0002, 0x0c09, 0x000b, 0x01c7, 0x000b,
+	0x55d0, 0xf6d9, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020,
+	0x0040, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000,
+	0x4000, 0x8000, 0xac74
+};
+#ifdef UNIQUE_FW_NAME
+unsigned short fw2300tpx_length01 = 0xcf5b;
+#else
+unsigned short risc_code_length01 = 0xcf5b;
+#endif
+
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_dbg.c linux-2.5/drivers/scsi/qla2xxx/qla_dbg.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_dbg.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_dbg.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,1229 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#include "qla_os.h"
+
+#include "qla_def.h"
+
+static int qla_uprintf(char **, char *, ...);
+
+/**
+ * qla2300_fw_dump() - Dumps binary data from the 2300 firmware.
+ * @ha: HA context
+ * @hardware_locked: Called with the hardware_lock
+ */
+void
+qla2300_fw_dump(scsi_qla_host_t *ha, int hardware_locked)
+{
+	int		rval;
+	uint32_t	cnt, timer;
+	uint32_t	risc_address;
+	uint16_t	mb0, mb2;
+
+	uint32_t	stat;
+	device_reg_t	*reg;
+	uint16_t	*dmp_reg;
+	unsigned long	flags;
+	struct qla2300_fw_dump	*fw;
+
+	reg = ha->iobase;
+	risc_address = 0;
+	mb0 = mb2 = 0;
+	flags = 0;
+
+	if (!hardware_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if (ha->fw_dump != NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Firmware has been previously dumped (%p) -- ignoring "
+		    "request...\n", ha->fw_dump);
+		return;
+	}
+
+	/* Allocate (large) dump buffer. */
+	ha->fw_dump_order = get_order(sizeof(struct qla2300_fw_dump));
+	ha->fw_dump = (struct qla2300_fw_dump *) __get_free_pages(GFP_ATOMIC,
+	    ha->fw_dump_order);
+	if (ha->fw_dump == NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to allocated memory for firmware dump (%d/%d).\n",
+		    ha->fw_dump_order, sizeof(struct qla2300_fw_dump));
+		return;
+	}
+	fw = ha->fw_dump;
+
+	rval = QLA_SUCCESS;
+	fw->hccr = RD_REG_WORD(&reg->hccr);
+
+	/* Pause RISC. */
+	WRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC); 
+	if (!IS_QLA2312(ha) && !IS_QLA2322(ha)) {
+		for (cnt = 30000;
+		    (RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) == 0 &&
+			rval == QLA_SUCCESS; cnt--) {
+			if (cnt)
+				udelay(100);
+			else
+				rval = QLA_FUNCTION_TIMEOUT;
+		}
+	} else {
+		udelay(10);
+	}
+
+	if (rval == QLA_SUCCESS) {
+		dmp_reg = (uint16_t *)(reg + 0);
+		for (cnt = 0; cnt < sizeof(fw->pbiu_reg) / 2; cnt++) 
+			fw->pbiu_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x10);
+		for (cnt = 0; cnt < sizeof(fw->risc_host_reg) / 2; cnt++) 
+			fw->risc_host_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x40);
+		for (cnt = 0; cnt < sizeof(fw->mailbox_reg) / 2; cnt++) 
+			fw->mailbox_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x40);
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->resp_dma_reg) / 2; cnt++) 
+			fw->resp_dma_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x50);
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->dma_reg) / 2; cnt++) 
+			fw->dma_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x00);
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0xA0);
+		for (cnt = 0; cnt < sizeof(fw->risc_hdw_reg) / 2; cnt++) 
+			fw->risc_hdw_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2000); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp0_reg) / 2; cnt++) 
+			fw->risc_gp0_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2200); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp1_reg) / 2; cnt++) 
+			fw->risc_gp1_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2400); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp2_reg) / 2; cnt++) 
+			fw->risc_gp2_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2600); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp3_reg) / 2; cnt++) 
+			fw->risc_gp3_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2800); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp4_reg) / 2; cnt++) 
+			fw->risc_gp4_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2A00); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp5_reg) / 2; cnt++) 
+			fw->risc_gp5_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2C00); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp6_reg) / 2; cnt++) 
+			fw->risc_gp6_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2E00); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp7_reg) / 2; cnt++) 
+			fw->risc_gp7_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x10); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->frame_buf_hdw_reg) / 2; cnt++) 
+			fw->frame_buf_hdw_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x20); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->fpm_b0_reg) / 2; cnt++) 
+			fw->fpm_b0_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x30); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->fpm_b1_reg) / 2; cnt++) 
+			fw->fpm_b1_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		/* Reset RISC. */
+		WRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);
+		for (cnt = 0; cnt < 30000; cnt++) {
+			if ((RD_REG_WORD(&reg->ctrl_status) &
+			    CSR_ISP_SOFT_RESET) == 0)
+				break;
+
+			udelay(10);
+		}
+	}
+
+	if (IS_QLA2312(ha) || IS_QLA2322(ha)) {
+		for (cnt = 30000; RD_MAILBOX_REG(ha, reg, 0) != 0 &&
+		    rval == QLA_SUCCESS; cnt--) {
+			if (cnt)
+				udelay(100);
+			else
+				rval = QLA_FUNCTION_TIMEOUT;
+		}
+	}
+
+	if (rval == QLA_SUCCESS) {
+		/* Get RISC SRAM. */
+		risc_address = 0x800;
+ 		WRT_MAILBOX_REG(ha, reg, 0, MBC_READ_RAM_WORD);
+		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+	}
+	for (cnt = 0; cnt < sizeof(fw->risc_ram) / 2 && rval == QLA_SUCCESS;
+	    cnt++, risc_address++) {
+ 		WRT_MAILBOX_REG(ha, reg, 1, (uint16_t)risc_address);
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+
+		for (timer = 6000000; timer; timer--) {
+			/* Check for pending interrupts. */
+ 			stat = RD_REG_DWORD(&reg->u.isp2300.host_status);
+			if (stat & HSR_RISC_INT) {
+				stat &= 0xff;
+
+				if (stat == 0x1 || stat == 0x2) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					/* Release mailbox registers. */
+					WRT_REG_WORD(&reg->semaphore, 0);
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				} else if (stat == 0x10 || stat == 0x11) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				}
+
+				/* clear this intr; it wasn't a mailbox intr */
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+			}
+			udelay(5);
+		}
+
+		if (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags)) {
+			rval = mb0 & MBS_MASK;
+			fw->risc_ram[cnt] = mb2;
+		} else {
+			rval = QLA_FUNCTION_FAILED;
+		}
+	}
+
+	if (rval == QLA_SUCCESS) {
+		/* Get stack SRAM. */
+		risc_address = 0x10000;
+ 		WRT_MAILBOX_REG(ha, reg, 0, MBC_READ_RAM_EXTENDED);
+		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+	}
+	for (cnt = 0; cnt < sizeof(fw->stack_ram) / 2 && rval == QLA_SUCCESS;
+	    cnt++, risc_address++) {
+ 		WRT_MAILBOX_REG(ha, reg, 1, LSW(risc_address));
+ 		WRT_MAILBOX_REG(ha, reg, 8, MSW(risc_address));
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+
+		for (timer = 6000000; timer; timer--) {
+			/* Check for pending interrupts. */
+ 			stat = RD_REG_DWORD(&reg->u.isp2300.host_status);
+			if (stat & HSR_RISC_INT) {
+				stat &= 0xff;
+
+				if (stat == 0x1 || stat == 0x2) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					/* Release mailbox registers. */
+					WRT_REG_WORD(&reg->semaphore, 0);
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				} else if (stat == 0x10 || stat == 0x11) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				}
+
+				/* clear this intr; it wasn't a mailbox intr */
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+			}
+			udelay(5);
+		}
+
+		if (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags)) {
+			rval = mb0 & MBS_MASK;
+			fw->stack_ram[cnt] = mb2;
+		} else {
+			rval = QLA_FUNCTION_FAILED;
+		}
+	}
+
+	if (rval == QLA_SUCCESS) {
+		/* Get data SRAM. */
+		risc_address = 0x11000;
+ 		WRT_MAILBOX_REG(ha, reg, 0, MBC_READ_RAM_EXTENDED);
+		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+	}
+	for (cnt = 0; cnt < sizeof(fw->data_ram) / 2 && rval == QLA_SUCCESS;
+	    cnt++, risc_address++) {
+ 		WRT_MAILBOX_REG(ha, reg, 1, LSW(risc_address));
+ 		WRT_MAILBOX_REG(ha, reg, 8, MSW(risc_address));
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+
+		for (timer = 6000000; timer; timer--) {
+			/* Check for pending interrupts. */
+ 			stat = RD_REG_DWORD(&reg->u.isp2300.host_status);
+			if (stat & HSR_RISC_INT) {
+				stat &= 0xff;
+
+				if (stat == 0x1 || stat == 0x2) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					/* Release mailbox registers. */
+					WRT_REG_WORD(&reg->semaphore, 0);
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				} else if (stat == 0x10 || stat == 0x11) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				}
+
+				/* clear this intr; it wasn't a mailbox intr */
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+			}
+			udelay(5);
+		}
+
+		if (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags)) {
+			rval = mb0 & MBS_MASK;
+			fw->data_ram[cnt] = mb2;
+		} else {
+			rval = QLA_FUNCTION_FAILED;
+		}
+	}
+
+
+	if (rval != QLA_SUCCESS) {
+		qla_printk(KERN_WARNING, ha,
+		    "Failed to dump firmware (%d)!!!\n", rval);
+
+		free_pages((unsigned long)ha->fw_dump, ha->fw_dump_order);
+		ha->fw_dump = NULL;
+	} else {
+		qla_printk(KERN_INFO, ha,
+		    "Firmware dump saved to temp buffer (%ld/%p).\n",
+		    ha->host_no, ha->fw_dump);
+	}
+
+	if (!hardware_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+/**
+ * qla2300_ascii_fw_dump() - Converts a binary firmware dump to ASCII.
+ * @ha: HA context
+ */
+void
+qla2300_ascii_fw_dump(scsi_qla_host_t *ha)
+{
+	uint32_t cnt;
+	char *uiter;
+	char fw_info[30];
+	struct qla2300_fw_dump *fw;
+
+	uiter = ha->fw_dump_buffer;
+	fw = ha->fw_dump;
+
+	qla_uprintf(&uiter, "%s Firmware Version %s\n", ha->model_number,
+	    qla2x00_get_fw_version_str(ha, fw_info));
+
+	qla_uprintf(&uiter, "\n[==>BEG]\n");
+
+	qla_uprintf(&uiter, "HCCR Register:\n%04x\n\n", fw->hccr);
+
+	qla_uprintf(&uiter, "PBIU Registers:");
+	for (cnt = 0; cnt < sizeof (fw->pbiu_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->pbiu_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nReqQ-RspQ-Risc2Host Status registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_host_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_host_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nMailbox Registers:");
+	for (cnt = 0; cnt < sizeof (fw->mailbox_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->mailbox_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nAuto Request Response DMA Registers:");
+	for (cnt = 0; cnt < sizeof (fw->resp_dma_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->resp_dma_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nDMA Registers:");
+	for (cnt = 0; cnt < sizeof (fw->dma_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->dma_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC Hardware Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_hdw_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_hdw_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP0 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp0_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp0_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP1 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp1_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp1_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP2 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp2_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp2_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP3 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp3_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp3_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP4 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp4_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp4_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP5 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp5_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp5_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP6 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp6_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp6_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP7 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp7_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp7_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFrame Buffer Hardware Registers:");
+	for (cnt = 0; cnt < sizeof (fw->frame_buf_hdw_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->frame_buf_hdw_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFPM B0 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->fpm_b0_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->fpm_b0_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFPM B1 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->fpm_b1_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->fpm_b1_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nCode RAM Dump:");
+	for (cnt = 0; cnt < sizeof (fw->risc_ram) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n%04x: ", cnt + 0x0800);
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_ram[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nStack RAM Dump:");
+	for (cnt = 0; cnt < sizeof (fw->stack_ram) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n%05x: ", cnt + 0x10000);
+		}
+		qla_uprintf(&uiter, "%04x ", fw->stack_ram[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nData RAM Dump:");
+	for (cnt = 0; cnt < sizeof (fw->data_ram) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n%05x: ", cnt + 0x11000);
+		}
+		qla_uprintf(&uiter, "%04x ", fw->data_ram[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\n[<==END] ISP Debug Dump.");
+}
+
+/**
+ * qla2100_fw_dump() - Dumps binary data from the 2100/2200 firmware.
+ * @ha: HA context
+ * @hardware_locked: Called with the hardware_lock
+ */
+void
+qla2100_fw_dump(scsi_qla_host_t *ha, int hardware_locked)
+{
+	int		rval;
+	uint32_t	cnt, timer;
+	uint32_t	risc_address;
+	uint16_t	mb0, mb2;
+
+	device_reg_t	*reg;
+	uint16_t	*dmp_reg;
+	unsigned long	flags;
+	struct qla2100_fw_dump	*fw;
+
+	reg = ha->iobase;
+	risc_address = 0;
+	mb0 = mb2 = 0;
+	flags = 0;
+
+	if (!hardware_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if (ha->fw_dump != NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Firmware has been previously dumped (%p) -- ignoring "
+		    "request...\n", ha->fw_dump);
+		return;
+	}
+
+	/* Allocate (large) dump buffer. */
+	ha->fw_dump_order = get_order(sizeof(struct qla2100_fw_dump));
+	ha->fw_dump = (struct qla2100_fw_dump *) __get_free_pages(GFP_ATOMIC,
+	    ha->fw_dump_order);
+	if (ha->fw_dump == NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to allocated memory for firmware dump (%d/%d).\n",
+		    ha->fw_dump_order, sizeof(struct qla2100_fw_dump));
+		return;
+	}
+	fw = ha->fw_dump;
+
+	rval = QLA_SUCCESS;
+	fw->hccr = RD_REG_WORD(&reg->hccr);
+
+	/* Pause RISC. */
+	WRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC); 
+	for (cnt = 30000; (RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) == 0 &&
+	    rval == QLA_SUCCESS; cnt--) {
+		if (cnt)
+			udelay(100);
+		else
+			rval = QLA_FUNCTION_TIMEOUT;
+	}
+
+	if (rval == QLA_SUCCESS) {
+		dmp_reg = (uint16_t *)(reg + 0);
+		for (cnt = 0; cnt < sizeof(fw->pbiu_reg) / 2; cnt++) 
+			fw->pbiu_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x10);
+		for (cnt = 0; cnt < ha->mbx_count; cnt++) {
+			if (cnt == 8) {
+				dmp_reg = (uint16_t *)((uint8_t *)reg + 0xe0);
+			}
+			fw->mailbox_reg[cnt] = RD_REG_WORD(dmp_reg++);
+		}
+
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x20);
+		for (cnt = 0; cnt < sizeof(fw->dma_reg) / 2; cnt++) 
+			fw->dma_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x00);
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0xA0);
+		for (cnt = 0; cnt < sizeof(fw->risc_hdw_reg) / 2; cnt++) 
+			fw->risc_hdw_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2000); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp0_reg) / 2; cnt++) 
+			fw->risc_gp0_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2100); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp1_reg) / 2; cnt++) 
+			fw->risc_gp1_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2200); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp2_reg) / 2; cnt++) 
+			fw->risc_gp2_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2300); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp3_reg) / 2; cnt++) 
+			fw->risc_gp3_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2400); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp4_reg) / 2; cnt++) 
+			fw->risc_gp4_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2500); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp5_reg) / 2; cnt++) 
+			fw->risc_gp5_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2600); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp6_reg) / 2; cnt++) 
+			fw->risc_gp6_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->pcr, 0x2700); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->risc_gp7_reg) / 2; cnt++) 
+			fw->risc_gp7_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x10); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->frame_buf_hdw_reg) / 2; cnt++) 
+			fw->frame_buf_hdw_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x20); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->fpm_b0_reg) / 2; cnt++) 
+			fw->fpm_b0_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		WRT_REG_WORD(&reg->ctrl_status, 0x30); 
+		dmp_reg = (uint16_t *)((uint8_t *)reg + 0x80);
+		for (cnt = 0; cnt < sizeof(fw->fpm_b1_reg) / 2; cnt++) 
+			fw->fpm_b1_reg[cnt] = RD_REG_WORD(dmp_reg++);
+
+		/* Disable ISP interrupts. */
+		WRT_REG_WORD(&reg->ictrl, 0);
+
+		/* Reset RISC module. */
+		WRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);
+
+		/* Release RISC module. */
+		WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC); 
+
+		/* Insure mailbox registers are free. */
+		WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT); 
+		WRT_REG_WORD(&reg->hccr, HCCR_CLR_HOST_INT); 
+	}
+
+	for (cnt = 30000; RD_MAILBOX_REG(ha, reg, 0) != 0 &&
+	    rval == QLA_SUCCESS; cnt--) {
+		if (cnt)
+			udelay(100);
+		else
+			rval = QLA_FUNCTION_TIMEOUT;
+	}
+
+	/* Pause RISC. */
+	if (rval == QLA_SUCCESS && (IS_QLA2200(ha) || (IS_QLA2100(ha) &&
+	    (RD_REG_WORD(&reg->mctr) & (BIT_1 | BIT_0)) != 0))) {
+
+		WRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC); 
+		for (cnt = 30000;
+		    (RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) == 0 &&
+		    rval == QLA_SUCCESS; cnt--) {
+			if (cnt)
+				udelay(100);
+			else
+				rval = QLA_FUNCTION_TIMEOUT;
+		}
+
+		if (rval == QLA_SUCCESS) {
+			/* Set memory configuration and timing. */
+			if (IS_QLA2100(ha))
+				WRT_REG_WORD(&reg->mctr, 0xf1);
+			else
+				WRT_REG_WORD(&reg->mctr, 0xf2);
+
+			/* Release RISC. */
+			WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);
+		}
+	}
+
+	if (rval == QLA_SUCCESS) {
+		/* Get RISC SRAM. */
+		risc_address = 0x1000;
+ 		WRT_MAILBOX_REG(ha, reg, 0, MBC_READ_RAM_WORD);
+		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+	}
+	for (cnt = 0; cnt < sizeof(fw->risc_ram) / 2 && rval == QLA_SUCCESS;
+	    cnt++, risc_address++) {
+ 		WRT_MAILBOX_REG(ha, reg, 1, (uint16_t)risc_address);
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+
+		for (timer = 6000000; timer != 0; timer--) {
+			/* Check for pending interrupts. */
+			if (RD_REG_WORD(&reg->istatus) & ISR_RISC_INT) {
+				if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
+					set_bit(MBX_INTERRUPT,
+					    &ha->mbx_cmd_flags);
+
+					mb0 = RD_MAILBOX_REG(ha, reg, 0);
+					mb2 = RD_MAILBOX_REG(ha, reg, 2);
+
+					WRT_REG_WORD(&reg->semaphore, 0);
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_CLR_RISC_INT);
+					break;
+				}
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+			}
+			udelay(5);
+		}
+
+		if (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags)) {
+			rval = mb0 & MBS_MASK;
+			fw->risc_ram[cnt] = mb2;
+		} else {
+			rval = QLA_FUNCTION_FAILED;
+		}
+	}
+
+	if (rval != QLA_SUCCESS) {
+		qla_printk(KERN_WARNING, ha,
+		    "Failed to dump firmware (%d)!!!\n", rval);
+
+		free_pages((unsigned long)ha->fw_dump, ha->fw_dump_order);
+		ha->fw_dump = NULL;
+	} else {
+		qla_printk(KERN_INFO, ha,
+		    "Firmware dump saved to temp buffer (%ld/%p).\n",
+		    ha->host_no, ha->fw_dump);
+	}
+
+	if (!hardware_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+/**
+ * qla2100_ascii_fw_dump() - Converts a binary firmware dump to ASCII.
+ * @ha: HA context
+ */
+void
+qla2100_ascii_fw_dump(scsi_qla_host_t *ha)
+{
+	uint32_t cnt;
+	char *uiter;
+	char fw_info[30];
+	struct qla2100_fw_dump *fw;
+
+	uiter = ha->fw_dump_buffer;
+	fw = ha->fw_dump;
+
+	qla_uprintf(&uiter, "%s Firmware Version %s\n", ha->model_number,
+	    qla2x00_get_fw_version_str(ha, fw_info));
+
+	qla_uprintf(&uiter, "\n[==>BEG]\n");
+
+	qla_uprintf(&uiter, "HCCR Register:\n%04x\n\n", fw->hccr);
+
+	qla_uprintf(&uiter, "PBIU Registers:");
+	for (cnt = 0; cnt < sizeof (fw->pbiu_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->pbiu_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nMailbox Registers:");
+	for (cnt = 0; cnt < sizeof (fw->mailbox_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->mailbox_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nDMA Registers:");
+	for (cnt = 0; cnt < sizeof (fw->dma_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->dma_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC Hardware Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_hdw_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_hdw_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP0 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp0_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp0_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP1 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp1_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp1_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP2 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp2_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp2_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP3 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp3_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp3_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP4 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp4_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp4_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP5 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp5_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp5_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP6 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp6_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp6_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC GP7 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->risc_gp7_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_gp7_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFrame Buffer Hardware Registers:");
+	for (cnt = 0; cnt < sizeof (fw->frame_buf_hdw_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->frame_buf_hdw_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFPM B0 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->fpm_b0_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->fpm_b0_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nFPM B1 Registers:");
+	for (cnt = 0; cnt < sizeof (fw->fpm_b1_reg) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n");
+		}
+		qla_uprintf(&uiter, "%04x ", fw->fpm_b1_reg[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\nRISC SRAM:");
+	for (cnt = 0; cnt < sizeof (fw->risc_ram) / 2; cnt++) {
+		if (cnt % 8 == 0) {
+			qla_uprintf(&uiter, "\n%04x: ", cnt + 0x1000);
+		}
+		qla_uprintf(&uiter, "%04x ", fw->risc_ram[cnt]);
+	}
+
+	qla_uprintf(&uiter, "\n\n[<==END] ISP Debug Dump.");
+
+	return;
+}
+
+static int
+qla_uprintf(char **uiter, char *fmt, ...)
+{
+	int	iter, len;
+	char	buf[128];
+	va_list	args;
+ 
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	for (iter = 0; iter < len; iter++, *uiter += 1)
+		*uiter[0] = buf[iter];
+
+	return (len);
+}
+
+//FIXME
+
+/****************************************************************************/
+/*                         Driver Debug Functions.                          */
+/****************************************************************************/
+
+void 
+qla2x00_dump_regs(scsi_qla_host_t *ha) 
+{
+	device_reg_t	*reg;
+
+	reg = ha->iobase;
+
+	printk("Mailbox registers:\n");
+	printk("scsi(%ld): mbox 0 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 0));
+	printk("scsi(%ld): mbox 1 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 1));
+	printk("scsi(%ld): mbox 2 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 2));
+	printk("scsi(%ld): mbox 3 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 3));
+	printk("scsi(%ld): mbox 4 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 4));
+	printk("scsi(%ld): mbox 5 0x%04x \n",
+	    ha->host_no, RD_MAILBOX_REG(ha, reg, 5));
+}
+
+
+void
+qla2x00_dump_buffer(uint8_t * b, uint32_t size) 
+{
+	uint32_t cnt;
+	uint8_t c;
+
+	printk(" 0   1   2   3   4   5   6   7   8   9  "
+	    "Ah  Bh  Ch  Dh  Eh  Fh\n");
+	printk("----------------------------------------"
+	    "----------------------\n");
+
+	for (cnt = 0; cnt < size;) {
+		c = *b++;
+		printk("%02x",(uint32_t) c);
+		cnt++;
+		if (!(cnt % 16))
+			printk("\n");
+		else
+			printk("  ");
+	}
+	if (cnt % 16)
+		printk("\n");
+}
+
+/**************************************************************************
+ *   qla2x00_print_scsi_cmd
+ *	 Dumps out info about the scsi cmd and srb.
+ *   Input	 
+ *	 cmd : struct scsi_cmnd
+ **************************************************************************/
+void
+qla2x00_print_scsi_cmd(struct scsi_cmnd * cmd) 
+{
+	int i;
+	struct scsi_qla_host *ha;
+	srb_t *sp;
+
+	ha = (struct scsi_qla_host *)cmd->device->host->hostdata;
+
+	sp = (srb_t *) cmd->SCp.ptr;
+	printk("SCSI Command @=0x%p, Handle=0x%p\n", cmd, cmd->host_scribble);
+	printk("  chan=0x%02x, target=0x%02x, lun=0x%02x, cmd_len=0x%02x\n",
+	    cmd->device->channel, cmd->device->id, cmd->device->lun,
+	    cmd->cmd_len);
+	printk(" CDB: ");
+	for (i = 0; i < cmd->cmd_len; i++) {
+		printk("0x%02x ", cmd->cmnd[i]);
+	}
+	printk("\n  seg_cnt=%d, allowed=%d, retries=%d, "
+	    "serial_number_at_timeout=0x%lx\n",
+	    cmd->use_sg, cmd->allowed, cmd->retries,
+	    cmd->serial_number_at_timeout);
+	printk("  request buffer=0x%p, request buffer len=0x%x\n",
+	    cmd->request_buffer, cmd->request_bufflen);
+	printk("  tag=%d, transfersize=0x%x\n",
+	    cmd->tag, cmd->transfersize);
+	printk("  serial_number=%lx, SP=%p\n", cmd->serial_number, sp); 
+	printk("  data direction=%d\n", cmd->sc_data_direction);
+
+	if (!sp)
+		return;
+
+	printk("  sp flags=0x%x\n", sp->flags);
+	printk("  r_start=0x%lx, u_start=0x%lx, f_start=0x%lx, state=%d\n",
+	    sp->r_start, sp->u_start, sp->f_start, sp->state);
+
+	printk(" e_start= 0x%lx, ext_history=%d, fo retry=%d, loopid=%x, "
+	    "port path=%d\n", sp->e_start, sp->ext_history, sp->fo_retry_cnt,
+	    sp->lun_queue->fclun->fcport->loop_id,
+	    sp->lun_queue->fclun->fcport->cur_path);
+}
+
+/*
+ * qla2x00_print_q_info
+ * 	 Prints queue info
+ * Input
+ *      q: lun queue	 
+ */ 
+void 
+qla2x00_print_q_info(struct os_lun *q) 
+{
+	printk("Queue info: flags=0x%lx\n", q->q_flag);
+}
+
+#if defined(QL_DEBUG_ROUTINES)
+/*
+ * qla2x00_formatted_dump_buffer
+ *       Prints string plus buffer.
+ *
+ * Input:
+ *       string  = Null terminated string (no newline at end).
+ *       buffer  = buffer address.
+ *       wd_size = word size 8, 16, 32 or 64 bits
+ *       count   = number of words.
+ */
+void
+qla2x00_formatted_dump_buffer(char *string, uint8_t * buffer, 
+				uint8_t wd_size, uint32_t count) 
+{
+	uint32_t cnt;
+	uint16_t *buf16;
+	uint32_t *buf32;
+
+	if (strcmp(string, "") != 0)
+		printk("%s\n",string);
+
+	switch (wd_size) {
+		case 8:
+			printk(" 0    1    2    3    4    5    6    7    "
+				"8    9    Ah   Bh   Ch   Dh   Eh   Fh\n");
+			printk("-----------------------------------------"
+				"-------------------------------------\n");
+
+			for (cnt = 1; cnt <= count; cnt++, buffer++) {
+				printk("%02x",*buffer);
+				if (cnt % 16 == 0)
+					printk("\n");
+				else
+					printk("  ");
+			}
+			if (cnt % 16 != 0)
+				printk("\n");
+			break;
+		case 16:
+			printk("   0      2      4      6      8      Ah "
+				"	Ch     Eh\n");
+			printk("-----------------------------------------"
+				"-------------\n");
+
+			buf16 = (uint16_t *) buffer;
+			for (cnt = 1; cnt <= count; cnt++, buf16++) {
+				printk("%4x",*buf16);
+
+				if (cnt % 8 == 0)
+					printk("\n");
+				else if (*buf16 < 10)
+					printk("   ");
+				else
+					printk("  ");
+			}
+			if (cnt % 8 != 0)
+				printk("\n");
+			break;
+		case 32:
+			printk("       0          4          8          Ch\n");
+			printk("------------------------------------------\n");
+
+			buf32 = (uint32_t *) buffer;
+			for (cnt = 1; cnt <= count; cnt++, buf32++) {
+				printk("%8x", *buf32);
+
+				if (cnt % 4 == 0)
+					printk("\n");
+				else if (*buf32 < 10)
+					printk("   ");
+				else
+					printk("  ");
+			}
+			if (cnt % 4 != 0)
+				printk("\n");
+			break;
+		default:
+			break;
+	}
+}
+
+#endif
+
+
+#if STOP_ON_ERROR
+/**************************************************************************
+*   qla2x00_panic
+*
+**************************************************************************/
+static void 
+qla2x00_panic(char *cp, struct Scsi_Host *host) 
+{
+	struct scsi_qla_host *ha;
+	long *fp;
+
+	ha = (struct scsi_qla_host *) host->hostdata;
+	DEBUG2(ql2x_debug_print = 1;);
+	printk("qla2100 - PANIC:  %s\n", cp);
+	printk("Current time=0x%lx\n", jiffies);
+	printk("Number of pending commands =0x%lx\n", ha->actthreads);
+	printk("Number of queued commands =0x%lx\n", ha->qthreads);
+	printk("Number of free entries = (%d)\n", ha->req_q_cnt);
+	printk("Request Queue @ 0x%lx, Response Queue @ 0x%lx\n",
+			       ha->request_dma, ha->response_dma);
+	printk("Request In Ptr %d\n", ha->req_ring_index);
+	fp = (long *) &ha->flags;
+	printk("HA flags =0x%lx\n", *fp);
+	qla2x00_dump_requests(ha);
+	qla2x00_dump_regs(ha);
+	cli();
+	for (;;) {
+		udelay(2);
+		barrier();
+		/* cpu_relax();*/
+	}
+	sti();
+}
+
+#endif
+
+/**************************************************************************
+*   qla2x00_dump_requests
+*
+**************************************************************************/
+void
+qla2x00_dump_requests(scsi_qla_host_t *ha) 
+{
+
+	struct scsi_cmnd       *cp;
+	srb_t           *sp;
+	int i;
+
+	printk("Outstanding Commands on controller:\n");
+
+	for (i = 1; i < MAX_OUTSTANDING_COMMANDS; i++) {
+		if ((sp = ha->outstanding_cmds[i]) == NULL)
+			continue;
+		if ((cp = sp->cmd) == NULL)
+			continue;
+
+		printk("(%d): Pid=%ld, sp flags=0x%x, cmd=0x%p\n",
+		    i, sp->cmd->serial_number, sp->flags, CMD_SP(sp->cmd));
+	}
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_dbg.h linux-2.5/drivers/scsi/qla2xxx/qla_dbg.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_dbg.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_dbg.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,229 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/*
+ * Firmware Dump structure definition
+ */
+#define FW_DUMP_SIZE	0xBC000		/* bytes */
+
+struct qla2300_fw_dump {
+	uint16_t hccr;
+	uint16_t pbiu_reg[8];
+	uint16_t risc_host_reg[8];
+	uint16_t mailbox_reg[32];
+	uint16_t resp_dma_reg[32];
+	uint16_t dma_reg[48];
+	uint16_t risc_hdw_reg[16];
+	uint16_t risc_gp0_reg[16];
+	uint16_t risc_gp1_reg[16];
+	uint16_t risc_gp2_reg[16];
+	uint16_t risc_gp3_reg[16];
+	uint16_t risc_gp4_reg[16];
+	uint16_t risc_gp5_reg[16];
+	uint16_t risc_gp6_reg[16];
+	uint16_t risc_gp7_reg[16];
+	uint16_t frame_buf_hdw_reg[64];
+	uint16_t fpm_b0_reg[64];
+	uint16_t fpm_b1_reg[64];
+	uint16_t risc_ram[0xf800];
+	uint16_t stack_ram[0x1000];
+	uint16_t data_ram[0xF000];
+};
+
+struct qla2100_fw_dump {
+	uint16_t hccr;
+	uint16_t pbiu_reg[8];
+	uint16_t mailbox_reg[32];
+	uint16_t dma_reg[48];
+	uint16_t risc_hdw_reg[16];
+	uint16_t risc_gp0_reg[16];
+	uint16_t risc_gp1_reg[16];
+	uint16_t risc_gp2_reg[16];
+	uint16_t risc_gp3_reg[16];
+	uint16_t risc_gp4_reg[16];
+	uint16_t risc_gp5_reg[16];
+	uint16_t risc_gp6_reg[16];
+	uint16_t risc_gp7_reg[16];
+	uint16_t frame_buf_hdw_reg[16];
+	uint16_t fpm_b0_reg[64];
+	uint16_t fpm_b1_reg[64];
+	uint16_t risc_ram[0xf000];
+};
+
+/*
+ * Driver debug definitions.
+ */
+/* #define QL_DEBUG_LEVEL_1  */ /* Output register accesses to COM1 */
+/* #define QL_DEBUG_LEVEL_2  */ /* Output error msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_3  */ /* Output function trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_4  */ /* Output NVRAM trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_5  */ /* Output ring trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_6  */ /* Output WATCHDOG timer trace to COM1 */
+/* #define QL_DEBUG_LEVEL_7  */ /* Output RISC load trace msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_8  */ /* Output ring saturation msgs to COM1 */
+/* #define QL_DEBUG_LEVEL_9  */ /* Output IOCTL trace msgs */
+/* #define QL_DEBUG_LEVEL_10 */ /* Output IOCTL error msgs */
+/* #define QL_DEBUG_LEVEL_11 */ /* Output Mbx Cmd trace msgs */
+/* #define QL_DEBUG_LEVEL_12 */ /* Output IP trace msgs */
+/* #define QL_DEBUG_LEVEL_13 */ /* Output fdmi function trace msgs */
+/* #define QL_DEBUG_LEVEL_14 */ /* Output RSCN trace msgs */
+/*
+ *  Local Macro Definitions.
+ */
+#if defined(QL_DEBUG_LEVEL_1)  || defined(QL_DEBUG_LEVEL_2) || \
+    defined(QL_DEBUG_LEVEL_3)  || defined(QL_DEBUG_LEVEL_4) || \
+    defined(QL_DEBUG_LEVEL_5)  || defined(QL_DEBUG_LEVEL_6) || \
+    defined(QL_DEBUG_LEVEL_7)  || defined(QL_DEBUG_LEVEL_8) || \
+    defined(QL_DEBUG_LEVEL_9)  || defined(QL_DEBUG_LEVEL_10) || \
+    defined(QL_DEBUG_LEVEL_11) || defined(QL_DEBUG_LEVEL_12) || \
+    defined(QL_DEBUG_LEVEL_13) || defined(QL_DEBUG_LEVEL_14)
+    #define QL_DEBUG_ROUTINES
+#endif
+
+/*
+* Macros use for debugging the driver.
+*/
+#undef ENTER_TRACE
+#if defined(ENTER_TRACE)
+#define ENTER(x)	do { printk("qla2100 : Entering %s()\n", x); } while (0)
+#define LEAVE(x)	do { printk("qla2100 : Leaving %s()\n", x);  } while (0)
+#define ENTER_INTR(x)	do { printk("qla2100 : Entering %s()\n", x); } while (0)
+#define LEAVE_INTR(x)	do { printk("qla2100 : Leaving %s()\n", x);  } while (0)
+#else
+#define ENTER(x)	do {} while (0)
+#define LEAVE(x)	do {} while (0)
+#define ENTER_INTR(x) 	do {} while (0)
+#define LEAVE_INTR(x)   do {} while (0)
+#endif
+
+#if  DEBUG_QLA2100
+#define DEBUG(x)	do {x;} while (0);
+#else
+#define DEBUG(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_1)
+#define DEBUG1(x)	do {x;} while (0);
+#else
+#define DEBUG1(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_2)
+#define DEBUG2(x)       do {x;} while (0);
+#define DEBUG2_3(x)     do {x;} while (0);
+#define DEBUG2_3_11(x)  do {x;} while (0);
+#define DEBUG2_9_10(x)    do {x;} while (0);
+#define DEBUG2_11(x)    do {x;} while (0);
+#else
+#define DEBUG2(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_3)
+#define DEBUG3(x)	do {x;} while (0);
+#define DEBUG2_3(x)	do {x;} while (0);
+#define DEBUG2_3_11(x)	do {x;} while (0);
+#define DEBUG3_11(x)	do {x;} while (0);
+#else
+#define DEBUG3(x)	do {} while (0);
+  #if !defined(QL_DEBUG_LEVEL_2)
+  #define DEBUG2_3(x)	do {} while (0);
+  #endif
+#endif
+
+#if defined(QL_DEBUG_LEVEL_4)
+#define DEBUG4(x)	do {x;} while (0);
+#else
+#define DEBUG4(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_5)
+#define DEBUG5(x)          do {x;} while (0);
+#else
+#define DEBUG5(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_7)
+#define DEBUG7(x)          do {x;} while (0);
+#else
+#define DEBUG7(x)	   do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_9)
+#define DEBUG9(x)       do {x;} while (0);
+#define DEBUG9_10(x)    do {x;} while (0);
+#define DEBUG2_9_10(x)	do {x;} while (0);
+#else
+#define DEBUG9(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_10)
+#define DEBUG10(x)      do {x;} while (0);
+#define DEBUG2_9_10(x)	do {x;} while (0);
+#define DEBUG9_10(x)	do {x;} while (0);
+#else
+#define DEBUG10(x)	do {} while (0);
+  #if !defined(DEBUG2_9_10)
+  #define DEBUG2_9_10(x)	do {} while (0);
+  #endif
+  #if !defined(DEBUG9_10)
+  #define DEBUG9_10(x)	do {} while (0);
+  #endif
+#endif
+
+#if defined(QL_DEBUG_LEVEL_11)
+#define DEBUG11(x)      do{x;} while(0);
+#if !defined(DEBUG2_11)
+#define DEBUG2_11(x)    do{x;} while(0);
+#endif
+#if !defined(DEBUG2_3_11)
+#define DEBUG2_3_11(x)  do{x;} while(0);
+#endif
+#if !defined(DEBUG3_11)
+#define DEBUG3_11(x)    do{x;} while(0);
+#endif
+#else
+#define DEBUG11(x)	do{} while(0);
+  #if !defined(QL_DEBUG_LEVEL_2)
+  #define DEBUG2_11(x)	do{} while(0);
+    #if !defined(QL_DEBUG_LEVEL_3)
+    #define DEBUG2_3_11(x) do{} while(0);
+    #endif
+  #endif
+  #if !defined(QL_DEBUG_LEVEL_3)
+  #define DEBUG3_11(x)	do{} while(0);
+  #endif
+#endif
+
+#if defined(QL_DEBUG_LEVEL_12)
+#define DEBUG12(x)      do {x;} while (0);
+#else
+#define DEBUG12(x)	do {} while (0);
+#endif
+
+#if defined(QL_DEBUG_LEVEL_13)
+#define DEBUG13(x)      do {x;} while (0)
+#else
+#define DEBUG13(x)	do {} while (0)
+#endif
+
+#if defined(QL_DEBUG_LEVEL_14)
+#define DEBUG14(x)      do {x;} while (0)
+#else
+#define DEBUG14(x)	do {} while (0)
+#endif
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_def.h linux-2.5/drivers/scsi/qla2xxx/qla_def.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_def.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_def.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,2371 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP2x00 device driver for Linux 2.6.x
+* Copyright (C) 2003 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+**
+******************************************************************************/
+
+#ifndef __QLA_DEF_H
+#define __QLA_DEF_H
+
+/* XXX(hch): move to pci_ids.h */
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP2300
+#define PCI_DEVICE_ID_QLOGIC_ISP2300	0x2300
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP2312
+#define PCI_DEVICE_ID_QLOGIC_ISP2312	0x2312
+#endif
+
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP2322
+#define PCI_DEVICE_ID_QLOGIC_ISP2322	0x2322
+#endif
+
+#if defined(CONFIG_SCSI_QLA21XX) || defined(CONFIG_SCSI_QLA21XX_MODULE)
+#define IS_QLA2100(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2100)
+#else
+#define IS_QLA2100(ha)	0
+#endif
+
+#if defined(CONFIG_SCSI_QLA22XX) || defined(CONFIG_SCSI_QLA22XX_MODULE)
+#define IS_QLA2200(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2200)
+#else
+#define IS_QLA2200(ha)	0
+#endif
+
+#if defined(CONFIG_SCSI_QLA23XX) || defined(CONFIG_SCSI_QLA23XX_MODULE)
+#define IS_QLA2300(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2300)
+#define IS_QLA2312(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2312)
+#define IS_QLA2322(ha)	((ha)->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2322)
+#define IS_QLA23XX(ha)	(IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA2322(ha))
+#else
+#define IS_QLA2300(ha)	0
+#define IS_QLA2312(ha)	0
+#define IS_QLA2322(ha)	0
+#define IS_QLA23XX(ha)	0
+#endif
+
+/*
+ * Only ISP23XX has extended addressing support in the firmware.
+ */
+#define HAS_EXTENDED_IDS(ha)	IS_QLA23XX(ha)
+
+/*
+ * We have MAILBOX_REGISTER_COUNT sized arrays in a few places,
+ * but that's fine as we don't look at the last 24 ones for
+ * ISP2100 HBAs.
+ */
+#define MAILBOX_REGISTER_COUNT_2100	8
+#define MAILBOX_REGISTER_COUNT		32
+
+#define QLA2200A_RISC_ROM_VER	4
+#define FPM_2300		6
+#define FPM_2310		7
+
+#include "qla_settings.h"
+
+/* 
+ * Data bit definitions
+ */
+#define BIT_0	0x1
+#define BIT_1	0x2
+#define BIT_2	0x4
+#define BIT_3	0x8
+#define BIT_4	0x10
+#define BIT_5	0x20
+#define BIT_6	0x40
+#define BIT_7	0x80
+#define BIT_8	0x100
+#define BIT_9	0x200
+#define BIT_10	0x400
+#define BIT_11	0x800
+#define BIT_12	0x1000
+#define BIT_13	0x2000
+#define BIT_14	0x4000
+#define BIT_15	0x8000
+#define BIT_16	0x10000
+#define BIT_17	0x20000
+#define BIT_18	0x40000
+#define BIT_19	0x80000
+#define BIT_20	0x100000
+#define BIT_21	0x200000
+#define BIT_22	0x400000
+#define BIT_23	0x800000
+#define BIT_24	0x1000000
+#define BIT_25	0x2000000
+#define BIT_26	0x4000000
+#define BIT_27	0x8000000
+#define BIT_28	0x10000000
+#define BIT_29	0x20000000
+#define BIT_30	0x40000000
+#define BIT_31	0x80000000
+
+#define LSB(x)	((uint8_t)(x))
+#define MSB(x)	((uint8_t)((uint16_t)(x) >> 8))
+
+#define LSW(x)	((uint16_t)(x))
+#define MSW(x)	((uint16_t)((uint32_t)(x) >> 16))
+
+#define LSD(x)	((uint32_t)((uint64_t)(x)))
+#define MSD(x)	((uint32_t)((((uint64_t)(x)) >> 16) >> 16))
+
+
+/*
+ * I/O register
+*/
+
+#if MEMORY_MAPPED_IO
+#define RD_REG_BYTE(addr)		readb(addr)
+#define RD_REG_WORD(addr)		readw(addr)
+#define RD_REG_DWORD(addr)		readl(addr)
+#define WRT_REG_BYTE(addr, data)	writeb(data,addr)
+#define WRT_REG_WORD(addr, data)	writew(data,addr)
+#define WRT_REG_DWORD(addr, data)	writel(data,addr)
+#else   /* MEMORY_MAPPED_IO */
+#define RD_REG_BYTE(addr)		(inb((unsigned long)addr))
+#define RD_REG_WORD(addr)		(inw((unsigned long)addr))
+#define RD_REG_DWORD(addr)		(inl((unsigned long)addr))
+#define WRT_REG_BYTE(addr, data)	(outb(data,(unsigned long)addr))
+#define WRT_REG_WORD(addr, data)	(outw(data,(unsigned long)addr))
+#define WRT_REG_DWORD(addr, data)	(outl(data,(unsigned long)addr))
+#endif  /* MEMORY_MAPPED_IO */
+
+/*
+ * Fibre Channel device definitions.
+ */
+#define WWN_SIZE		8	/* Size of WWPN, WWN & WWNN */
+#define MAX_FIBRE_DEVICES	512
+#define MAX_FIBRE_LUNS  	256
+#define	MAX_RSCN_COUNT		32
+#define	MAX_HOST_COUNT		16
+
+/*
+ * Host adapter default definitions.
+ */
+#define MAX_BUSES		1  /* We only have one bus today */
+#define MAX_TARGETS_2100	MAX_FIBRE_DEVICES
+#define MAX_TARGETS_2200	MAX_FIBRE_DEVICES
+#define MAX_TARGETS		MAX_FIBRE_DEVICES
+#define MIN_LUNS		8
+#define MAX_LUNS		MAX_FIBRE_LUNS
+#define MAX_CMDS_PER_LUN	255 
+                                    
+/*
+ * Fibre Channel device definitions.
+ */
+#define SNS_LAST_LOOP_ID_2100	0xfe
+#define SNS_LAST_LOOP_ID_2300	0x7ff
+
+#define LAST_LOCAL_LOOP_ID	0x7d
+#define SNS_FL_PORT		0x7e
+#define FABRIC_CONTROLLER	0x7f
+#define SIMPLE_NAME_SERVER	0x80
+#define SNS_FIRST_LOOP_ID	0x81
+#define MANAGEMENT_SERVER	0xfe
+#define BROADCAST		0xff
+
+#define RESERVED_LOOP_ID(x)	((x > LAST_LOCAL_LOOP_ID && \
+				 x < SNS_FIRST_LOOP_ID) || \
+				 x == MANAGEMENT_SERVER || \
+				 x == BROADCAST)
+
+/*
+ * Timeout timer counts in seconds
+ */
+#define PORT_RETRY_TIME			2
+#define LOOP_DOWN_TIMEOUT		60
+#define LOOP_DOWN_TIME			255	/* 240 */
+#define	LOOP_DOWN_RESET			(LOOP_DOWN_TIME - 30)
+
+/* Maximum outstanding commands in ISP queues (1-65535) */
+#define MAX_OUTSTANDING_COMMANDS	1024
+
+/* ISP request and response entry counts (37-65535) */
+#define REQUEST_ENTRY_CNT		1024	/* Number of request entries. */
+#define RESPONSE_ENTRY_CNT_2100		64	/* Number of response entries.*/
+#define RESPONSE_ENTRY_CNT_2300		512	/* Number of response entries.*/
+
+/* Calculations for SG segments */
+#define SEGS_PER_REQUEST_32	3 
+#define SEGS_PER_CONT_32	7
+#define SG_SEGMENTS_32 (SEGS_PER_REQUEST_32 + \
+    (SEGS_PER_CONT_32 * (REQUEST_ENTRY_CNT - 2)))     
+#define SEGS_PER_REQUEST_64	2 
+#define SEGS_PER_CONT_64	5
+#define SG_SEGMENTS_64 (SEGS_PER_REQUEST_64 + \
+    (SEGS_PER_CONT_64 * (REQUEST_ENTRY_CNT - 2)))     
+
+/*
+ * SCSI Request Block 
+ */
+typedef struct srb {
+	struct list_head list;
+
+	struct scsi_qla_host *ha;	/* HA the SP is queued on */
+
+	struct scsi_cmnd *cmd;		/* Linux SCSI command pkt */
+
+	struct timer_list timer;	/* Command timer */
+	atomic_t ref_count;	/* Reference count for this structure */			
+	uint16_t flags;
+
+	/* Request state */
+	uint16_t state;
+
+	/* Target/LUN queue pointers. */
+	struct os_tgt *tgt_queue;	/* ptr to visible ha's target */
+	struct os_lun *lun_queue;	/* ptr to visible ha's lun */
+	struct fc_lun *fclun;		/* FC LUN context pointer. */
+
+	/* Timing counts. */
+	unsigned long e_start;		/* Start of extend timeout */
+	unsigned long r_start;		/* Start of request */
+	unsigned long u_start;		/* When sent to RISC */
+	unsigned long f_start;		/* When placed in FO queue*/
+
+	/* Single transfer DMA context */
+	dma_addr_t dma_handle;
+
+	uint32_t request_sense_length;
+	uint8_t *request_sense_ptr;
+
+	int ext_history;
+
+	/* Suspend delay */
+	int delay;
+
+	/* Raw completion info for use by failover ? */
+	uint8_t	fo_retry_cnt;		/* Retry count this request */
+	uint8_t	err_id;			/* error id */
+
+	/* SRB magic number */
+	uint16_t magic;
+#define SRB_MAGIC       0x10CB
+} srb_t;
+
+/*
+ * SRB flag definitions
+ */
+#define SRB_TIMEOUT		BIT_0	/* Command timed out */
+#define SRB_DMA_VALID		BIT_1	/* Command sent to ISP */
+#define SRB_WATCHDOG		BIT_2	/* Command on watchdog list */
+#define SRB_ABORT_PENDING	BIT_3	/* Command abort sent to device */
+
+#define SRB_ABORTED		BIT_4	/* Command aborted command already */
+#define SRB_RETRY		BIT_5	/* Command needs retrying */
+#define SRB_GOT_SENSE		BIT_6	/* Command has sense data */
+#define SRB_FAILOVER		BIT_7	/* Command in failover state */
+
+#define SRB_BUSY		BIT_8	/* Command is in busy retry state */
+#define SRB_FO_CANCEL		BIT_9	/* Command don't need to do failover */
+#define	SRB_IOCTL		BIT_10	/* IOCTL command. */
+
+/*
+ * SRB state definitions
+ */
+#define SRB_FREE_STATE		0	/*   returned back */
+#define SRB_PENDING_STATE	1	/*   queued in LUN Q */
+#define SRB_ACTIVE_STATE	2	/*   in Active Array */
+#define SRB_DONE_STATE		3	/*   queued in Done Queue */
+#define SRB_RETRY_STATE		4	/*   in Retry Queue */
+#define SRB_SUSPENDED_STATE	5	/*   in suspended state */
+#define SRB_NO_QUEUE_STATE	6	/*   is in between states */
+#define SRB_ACTIVE_TIMEOUT_STATE 7	/*   in Active Array but timed out */
+#define SRB_FAILOVER_STATE	8	/*   in Failover Queue */
+#define SRB_SCSI_RETRY_STATE	9	/*   in Scsi Retry Queue */
+
+
+/*
+ * ISP I/O Register Set structure definitions.
+ */
+typedef volatile struct {
+	volatile uint16_t flash_address; /* Flash BIOS address */
+	volatile uint16_t flash_data;	/* Flash BIOS data */
+	uint16_t unused_1[1];		/* Gap */
+	volatile uint16_t ctrl_status;	/* Control/Status */
+#define CSR_FLASH_64K_BANK	BIT_3	/* Flash upper 64K bank select */ 
+#define CSR_FLASH_ENABLE	BIT_1	/* Flash BIOS Read/Write enable */
+#define CSR_ISP_SOFT_RESET	BIT_0	/* ISP soft reset */
+
+	volatile uint16_t ictrl;	/* Interrupt control */
+#define ICR_EN_INT		BIT_15	/* ISP enable interrupts. */
+#define ICR_EN_RISC		BIT_3	/* ISP enable RISC interrupts. */
+
+	volatile uint16_t istatus;	/* Interrupt status */
+#define ISR_RISC_INT		BIT_3	/* RISC interrupt */
+
+	volatile uint16_t semaphore;	/* Semaphore */
+	volatile uint16_t nvram;	/* NVRAM register. */
+#define NVR_DESELECT		0
+#define NVR_BUSY		BIT_15
+#define NVR_DATA_IN		BIT_3
+#define NVR_DATA_OUT		BIT_2
+#define NVR_SELECT		BIT_1
+#define NVR_CLOCK		BIT_0
+
+	union {
+		struct {
+			volatile uint16_t mailbox0;
+			volatile uint16_t mailbox1;
+			volatile uint16_t mailbox2;
+			volatile uint16_t mailbox3;
+			volatile uint16_t mailbox4;
+			volatile uint16_t mailbox5;
+			volatile uint16_t mailbox6;
+			volatile uint16_t mailbox7;
+			uint16_t unused_2[59];		/* Gap */
+		} __attribute__((packed)) isp2100;
+		struct {
+							/* Request Queue */
+			volatile uint16_t req_q_in;	/*  In-Pointer */
+			volatile uint16_t req_q_out;	/*  Out-Pointer */
+							/* Response Queue */
+			volatile uint16_t rsp_q_in;	/*  In-Pointer */
+			volatile uint16_t rsp_q_out;	/*  Out-Pointer */
+
+						/* RISC to Host Status */
+			volatile uint32_t host_status;	
+#define HSR_RISC_INT		BIT_15	/* RISC interrupt */
+#define HSR_RISC_PAUSED		BIT_8	/* RISC Paused */
+
+					/* Host to Host Semaphore */
+			volatile uint16_t host_semaphore; 
+			uint16_t unused_3[17];		/* Gap */
+			volatile uint16_t mailbox0;
+			volatile uint16_t mailbox1;
+			volatile uint16_t mailbox2;
+			volatile uint16_t mailbox3;
+			volatile uint16_t mailbox4;
+			volatile uint16_t mailbox5;
+			volatile uint16_t mailbox6;
+			volatile uint16_t mailbox7;
+			volatile uint16_t mailbox8;
+			volatile uint16_t mailbox9;
+			volatile uint16_t mailbox10;
+			volatile uint16_t mailbox11;
+			volatile uint16_t mailbox12;
+			volatile uint16_t mailbox13;
+			volatile uint16_t mailbox14;
+			volatile uint16_t mailbox15;
+			volatile uint16_t mailbox16;
+			volatile uint16_t mailbox17;
+			volatile uint16_t mailbox18;
+			volatile uint16_t mailbox19;
+			volatile uint16_t mailbox20;
+			volatile uint16_t mailbox21;
+			volatile uint16_t mailbox22;
+			volatile uint16_t mailbox23;
+			volatile uint16_t mailbox24;
+			volatile uint16_t mailbox25;
+			volatile uint16_t mailbox26;
+			volatile uint16_t mailbox27;
+			volatile uint16_t mailbox28;
+			volatile uint16_t mailbox29;
+			volatile uint16_t mailbox30;
+			volatile uint16_t mailbox31;
+			volatile uint16_t fb_cmd;
+			uint16_t unused_4[10];		/* Gap */
+		} __attribute__((packed)) isp2300;
+	} u;
+
+	volatile uint16_t fpm_diag_config;
+	uint16_t unused_5[0x6];		/* Gap */
+	volatile uint16_t pcr;		/* Processor Control Register. */
+	uint16_t unused_6[0x5];		/* Gap */
+	volatile uint16_t mctr;		/* Memory Configuration and Timing. */
+	uint16_t unused_7[0x3];		/* Gap */
+	volatile uint16_t fb_cmd_2100;	/* Unused on 23XX */
+	uint16_t unused_8[0x3];		/* Gap */
+	volatile uint16_t hccr;		/* Host command & control register. */
+#define HCCR_HOST_INT		BIT_7	/* Host interrupt bit */
+#define HCCR_RISC_PAUSE		BIT_5	/* Pause mode bit */
+					/* HCCR commands */
+#define HCCR_RESET_RISC		0x1000	/* Reset RISC */
+#define HCCR_PAUSE_RISC		0x2000	/* Pause RISC */
+#define HCCR_RELEASE_RISC	0x3000	/* Release RISC from reset. */
+#define HCCR_SET_HOST_INT	0x5000	/* Set host interrupt */
+#define HCCR_CLR_HOST_INT	0x6000	/* Clear HOST interrupt */
+#define HCCR_CLR_RISC_INT	0x7000	/* Clear RISC interrupt */
+#define	HCCR_DISABLE_PARITY_PAUSE 0x4001 /* Disable parity error RISC pause. */
+#define HCCR_ENABLE_PARITY	0xA000	/* Enable PARITY interrupt */
+
+	uint16_t unused_9[5];		/* Gap */
+	volatile uint16_t gpiod;	/* GPIO Data register. */
+	volatile uint16_t gpioe;	/* GPIO Enable register. */
+#define GPIO_LED_MASK			0x00C0
+#define GPIO_LED_GREEN_OFF_AMBER_OFF	0x0000
+#define GPIO_LED_GREEN_ON_AMBER_OFF	0x0040
+#define GPIO_LED_GREEN_OFF_AMBER_ON	0x0080
+#define GPIO_LED_GREEN_ON_AMBER_ON	0x00C0
+
+	union {
+		struct {
+			uint16_t unused_10[8];		/* Gap */
+			volatile uint16_t mailbox8;
+			volatile uint16_t mailbox9;
+			volatile uint16_t mailbox10;
+			volatile uint16_t mailbox11;
+			volatile uint16_t mailbox12;
+			volatile uint16_t mailbox13;
+			volatile uint16_t mailbox14;
+			volatile uint16_t mailbox15;
+			volatile uint16_t mailbox16;
+			volatile uint16_t mailbox17;
+			volatile uint16_t mailbox18;
+			volatile uint16_t mailbox19;
+			volatile uint16_t mailbox20;
+			volatile uint16_t mailbox21;
+			volatile uint16_t mailbox22;
+			volatile uint16_t mailbox23;	/* Also probe reg. */
+		} __attribute__((packed)) isp2200;
+	} u_end;
+} device_reg_t;
+
+#define	ISP_REQ_Q_IN(ha, reg) \
+	(IS_QLA23XX(ha) ? \
+	 &(reg)->u.isp2300.req_q_in : \
+	 &(reg)->u.isp2100.mailbox4)
+#define	ISP_REQ_Q_OUT(ha, reg) \
+	(IS_QLA23XX(ha) ? \
+	 &(reg)->u.isp2300.req_q_out : \
+	 &(reg)->u.isp2100.mailbox4)
+#define	ISP_RSP_Q_IN(ha, reg) \
+	(IS_QLA23XX(ha) ? \
+	 &(reg)->u.isp2300.rsp_q_in : \
+	 &(reg)->u.isp2100.mailbox5)
+#define	ISP_RSP_Q_OUT(ha, reg) \
+	(IS_QLA23XX(ha) ? \
+	 &(reg)->u.isp2300.rsp_q_out : \
+	 &(reg)->u.isp2100.mailbox5)
+
+#define MAILBOX_REG(ha, reg, num) \
+	(IS_QLA23XX(ha) ? \
+	 &(reg)->u.isp2300.mailbox0 + (num) : \
+	 ((num < 8) ? \
+	  &(reg)->u.isp2100.mailbox0 + (num) : \
+	  &(reg)->u_end.isp2200.mailbox8 + (num) - 8))	/* only for isp2200 */
+#define RD_MAILBOX_REG(ha, reg, num) \
+	RD_REG_WORD(MAILBOX_REG(ha, reg, num))
+#define WRT_MAILBOX_REG(ha, reg, num, data) \
+	WRT_REG_WORD(MAILBOX_REG(ha, reg, num), data)
+
+#define FB_CMD_REG(ha, reg) \
+	(IS_QLA23XX(ha) ? &(reg)->u.isp2300.fb_cmd : &(reg)->fb_cmd_2100)
+#define RD_FB_CMD_REG(ha, reg) \
+	RD_REG_WORD(FB_CMD_REG(ha, reg))
+#define WRT_FB_CMD_REG(ha, reg, data) \
+	WRT_REG_WORD(FB_CMD_REG(ha, reg), data)
+
+
+typedef struct {
+	uint32_t	out_mb;		/* outbound from driver */
+	uint32_t	in_mb;			/* Incoming from RISC */
+	uint16_t	mb[MAILBOX_REGISTER_COUNT];
+	long		buf_size;
+	void		*bufp;
+	uint32_t	tov;
+	uint8_t		flags;
+#define MBX_DMA_IN	BIT_0
+#define	MBX_DMA_OUT	BIT_1
+#define IOCTL_CMD	BIT_2
+} mbx_cmd_t;
+
+#define	MBX_TOV_SECONDS	30
+
+/*
+ *  ISP product identification definitions in mailboxes after reset.
+ */
+#define PROD_ID_1		0x4953
+#define PROD_ID_2		0x0000
+#define PROD_ID_2a		0x5020
+#define PROD_ID_3		0x2020
+
+/*
+ * ISP mailbox Self-Test status codes
+ */
+#define MBS_FRM_ALIVE		0	/* Firmware Alive. */
+#define MBS_CHKSUM_ERR		1	/* Checksum Error. */
+#define MBS_BUSY		4	/* Busy. */
+
+/*
+ * ISP mailbox command complete status codes
+ */
+#define MBS_COMMAND_COMPLETE		0x4000
+#define MBS_INVALID_COMMAND		0x4001
+#define MBS_HOST_INTERFACE_ERROR	0x4002
+#define MBS_TEST_FAILED			0x4003
+#define MBS_COMMAND_ERROR		0x4005
+#define MBS_COMMAND_PARAMETER_ERROR	0x4006
+#define MBS_PORT_ID_USED		0x4007
+#define MBS_LOOP_ID_USED		0x4008
+#define MBS_ALL_IDS_IN_USE		0x4009
+#define MBS_NOT_LOGGED_IN		0x400A
+
+/*
+ * ISP mailbox asynchronous event status codes
+ */
+#define MBA_ASYNC_EVENT		0x8000	/* Asynchronous event. */
+#define MBA_RESET		0x8001	/* Reset Detected. */
+#define MBA_SYSTEM_ERR		0x8002	/* System Error. */
+#define MBA_REQ_TRANSFER_ERR	0x8003	/* Request Transfer Error. */
+#define MBA_RSP_TRANSFER_ERR	0x8004	/* Response Transfer Error. */
+#define MBA_WAKEUP_THRES	0x8005	/* Request Queue Wake-up. */
+#define MBA_LIP_OCCURRED	0x8010	/* Loop Initialization Procedure */
+					/* occurred. */
+#define MBA_LOOP_UP		0x8011	/* FC Loop UP. */
+#define MBA_LOOP_DOWN		0x8012	/* FC Loop Down. */
+#define MBA_LIP_RESET		0x8013	/* LIP reset occurred. */
+#define MBA_PORT_UPDATE		0x8014	/* Port Database update. */
+#define MBA_RSCN_UPDATE		0x8015	/* Register State Chg Notification. */
+#define MBA_LIP_F8		0x8016	/* Received a LIP F8. */
+#define MBA_LOOP_INIT_ERR	0x8017	/* Loop Initialization Error. */
+#define MBA_FABRIC_AUTH_REQ	0x801b	/* Fabric Authentication Required. */
+#define MBA_SCSI_COMPLETION	0x8020	/* SCSI Command Complete. */
+#define MBA_CTIO_COMPLETION	0x8021	/* CTIO Complete. */
+#define MBA_IP_COMPLETION	0x8022	/* IP Transmit Command Complete. */
+#define MBA_IP_RECEIVE		0x8023	/* IP Received. */
+#define MBA_IP_BROADCAST	0x8024	/* IP Broadcast Received. */
+#define MBA_IP_LOW_WATER_MARK	0x8025	/* IP Low Water Mark reached. */
+#define MBA_IP_RCV_BUFFER_EMPTY 0x8026	/* IP receive buffer queue empty. */
+#define MBA_IP_HDR_DATA_SPLIT	0x8027	/* IP header/data splitting feature */
+					/* used. */
+#define MBA_POINT_TO_POINT	0x8030	/* Point to point mode. */
+#define MBA_CMPLT_1_16BIT	0x8031	/* Completion 1 16bit IOSB. */
+#define MBA_CMPLT_2_16BIT	0x8032	/* Completion 2 16bit IOSB. */
+#define MBA_CMPLT_3_16BIT	0x8033	/* Completion 3 16bit IOSB. */
+#define MBA_CMPLT_4_16BIT	0x8034	/* Completion 4 16bit IOSB. */
+#define MBA_CMPLT_5_16BIT	0x8035	/* Completion 5 16bit IOSB. */
+#define MBA_CHG_IN_CONNECTION	0x8036	/* Change in connection mode. */
+#define MBA_RIO_RESPONSE	0x8040	/* RIO response queue update. */
+#define MBA_ZIO_RESPONSE	0x8040	/* ZIO response queue update. */
+#define MBA_CMPLT_2_32BIT	0x8042	/* Completion 2 32bit IOSB. */
+#define MBA_BYPASS_NOTIFICATION	0x8043	/* Auto bypass notification. */
+#define MBA_DISCARD_RND_FRAME	0x8048	/* discard RND frame due to error. */
+#define MBA_REJECTED_FCP_CMD	0x8049	/* rejected FCP_CMD. */
+
+/*
+ * Firmware options 1, 2, 3.
+ */
+#define FO1_AE_ON_LIPF8			BIT_0
+#define FO1_AE_ALL_LIP_RESET		BIT_1
+#define FO1_CTIO_RETRY			BIT_3
+#define FO1_DISABLE_LIP_F7_SW		BIT_4
+#define FO1_DISABLE_100MS_LOS_WAIT	BIT_5
+#define FO1_DISABLE_GPIO6_7		BIT_6
+#define FO1_AE_ON_LOOP_INIT_ERR		BIT_7
+#define FO1_SET_EMPHASIS_SWING		BIT_8
+#define FO1_AE_AUTO_BYPASS		BIT_9
+#define FO1_ENABLE_PURE_IOCB		BIT_10
+#define FO1_AE_PLOGI_RJT		BIT_11
+#define FO1_ENABLE_ABORT_SEQUENCE	BIT_12
+#define FO1_AE_QUEUE_FULL		BIT_13
+
+#define FO2_ENABLE_ATIO_TYPE_3		BIT_0
+#define FO2_REV_LOOPBACK		BIT_1
+
+#define FO3_ENABLE_EMERG_IOCB		BIT_0
+#define FO3_AE_RND_ERROR		BIT_1
+
+/*
+ * ISP mailbox commands
+ */
+#define MBC_LOAD_RAM			1	/* Load RAM. */
+#define MBC_EXECUTE_FIRMWARE		2	/* Execute firmware. */
+#define MBC_WRITE_RAM_WORD		4	/* Write RAM word. */
+#define MBC_READ_RAM_WORD		5	/* Read RAM word. */
+#define MBC_MAILBOX_REGISTER_TEST	6	/* Wrap incoming mailboxes */
+#define MBC_VERIFY_CHECKSUM		7	/* Verify checksum. */
+#define MBC_GET_FIRMWARE_VERSION	8	/* Get firmware revision. */
+#define MBC_LOAD_RISC_RAM		9	/* Load RAM command. */
+#define MBC_DUMP_RISC_RAM		0xa	/* Dump RAM command. */
+#define MBC_LOAD_RISC_RAM_EXTENDED	0xb	/* Load RAM extended. */
+#define MBC_DUMP_RISC_RAM_EXTENDED	0xc	/* Dump RAM extended. */
+#define MBC_WRITE_RAM_WORD_EXTENDED	0xd	/* Write RAM word extended */
+#define MBC_READ_RAM_EXTENDED		0xf	/* Read RAM extended. */
+#define MBC_IOCB_COMMAND		0x12	/* Execute IOCB command. */
+#define MBC_ABORT_COMMAND		0x15	/* Abort IOCB command. */
+#define MBC_ABORT_DEVICE		0x16	/* Abort device (ID/LUN). */
+#define MBC_ABORT_TARGET		0x17	/* Abort target (ID). */
+#define MBC_RESET			0x18	/* Reset. */
+#define MBC_GET_ADAPTER_LOOP_ID		0x20	/* Get loop id of ISP2200. */
+#define MBC_GET_RETRY_COUNT		0x22	/* Get f/w retry cnt/delay. */
+#define MBC_DISABLE_VI			0x24	/* Disable VI operation. */
+#define MBC_ENABLE_VI			0x25	/* Enable VI operation. */
+#define MBC_GET_FIRMWARE_OPTION		0x28	/* Get Firmware Options. */
+#define MBC_SET_FIRMWARE_OPTION		0x38	/* Set Firmware Options. */
+#define MBC_LOOP_PORT_BYPASS		0x40	/* Loop Port Bypass. */
+#define MBC_LOOP_PORT_ENABLE		0x41	/* Loop Port Enable. */
+#define MBC_GET_RESOURCE_COUNTS		0x42	/* Get Resource Counts. */
+#define MBC_NON_PARTICIPATE		0x43	/* Non-Participating Mode. */
+#define MBC_DIAGNOSTIC_ECHO		0x44	/* Diagnostic echo. */
+#define MBC_DIAGNOSTIC_LOOP_BACK	0x45	/* Diagnostic loop back. */
+#define MBC_ONLINE_SELF_TEST		0x46	/* Online self-test. */
+#define MBC_ENHANCED_GET_PORT_DATABASE	0x47	/* Get port database + login */
+#define MBC_RESET_LINK_STATUS		0x52	/* Reset Link Error Status */
+#define MBC_IOCB_COMMAND_A64		0x54	/* Execute IOCB command (64) */
+#define MBC_SEND_RNID_ELS		0x57	/* Send RNID ELS request */
+#define MBC_SET_RNID_PARAMS		0x59	/* Set RNID parameters */
+#define MBC_GET_RNID_PARAMS		0x5a	/* Data Rate */
+#define MBC_DATA_RATE			0x5d	/* Get RNID parameters */
+#define MBC_INITIALIZE_FIRMWARE		0x60	/* Initialize firmware */
+#define MBC_INITIATE_LIP		0x62	/* Initiate Loop */
+						/* Initialization Procedure */
+#define MBC_GET_FC_AL_POSITION_MAP	0x63	/* Get FC_AL Position Map. */
+#define MBC_GET_PORT_DATABASE		0x64	/* Get Port Database. */
+#define MBC_CLEAR_ACA			0x65	/* Clear ACA. */
+#define MBC_TARGET_RESET		0x66	/* Target Reset. */
+#define MBC_CLEAR_TASK_SET		0x67	/* Clear Task Set. */
+#define MBC_ABORT_TASK_SET		0x68	/* Abort Task Set. */
+#define MBC_GET_FIRMWARE_STATE		0x69	/* Get firmware state. */
+#define MBC_GET_PORT_NAME		0x6a	/* Get port name. */
+#define MBC_GET_LINK_STATUS		0x6b	/* Get port link status. */
+#define MBC_LIP_RESET			0x6c	/* LIP reset. */
+#define MBC_SEND_SNS_COMMAND		0x6e	/* Send Simple Name Server */
+						/* commandd. */
+#define MBC_LOGIN_FABRIC_PORT		0x6f	/* Login fabric port. */
+#define MBC_SEND_CHANGE_REQUEST		0x70	/* Send Change Request. */
+#define MBC_LOGOUT_FABRIC_PORT		0x71	/* Logout fabric port. */
+#define MBC_LIP_FULL_LOGIN		0x72	/* Full login LIP. */
+#define MBC_LOGIN_LOOP_PORT		0x74	/* Login Loop Port. */
+#define MBC_PORT_NODE_NAME_LIST		0x75	/* Get port/node name list. */
+#define MBC_INITIALIZE_RECEIVE_QUEUE	0x77	/* Initialize receive queue */
+#define MBC_UNLOAD_IP			0x79	/* Shutdown IP */
+#define MBC_GET_ID_LIST			0x7C	/* Get Port ID list. */
+#define MBC_SEND_LFA_COMMAND		0x7D	/* Send Loop Fabric Address */
+#define MBC_LUN_RESET			0x7E	/* Send LUN reset */
+
+/* Firmware return data sizes */
+#define FCAL_MAP_SIZE	128
+
+/* Mailbox bit definitions for out_mb and in_mb */
+#define	MBX_31		BIT_31
+#define	MBX_30		BIT_30
+#define	MBX_29		BIT_29
+#define	MBX_28		BIT_28
+#define	MBX_27		BIT_27
+#define	MBX_26		BIT_26
+#define	MBX_25		BIT_25
+#define	MBX_24		BIT_24
+#define	MBX_23		BIT_23
+#define	MBX_22		BIT_22
+#define	MBX_21		BIT_21
+#define	MBX_20		BIT_20
+#define	MBX_19		BIT_19
+#define	MBX_18		BIT_18
+#define	MBX_17		BIT_17
+#define	MBX_16		BIT_16
+#define	MBX_15		BIT_15
+#define	MBX_14		BIT_14
+#define	MBX_13		BIT_13
+#define	MBX_12		BIT_12
+#define	MBX_11		BIT_11
+#define	MBX_10		BIT_10
+#define	MBX_9		BIT_9
+#define	MBX_8		BIT_8
+#define	MBX_7		BIT_7
+#define	MBX_6		BIT_6
+#define	MBX_5		BIT_5
+#define	MBX_4		BIT_4
+#define	MBX_3		BIT_3
+#define	MBX_2		BIT_2
+#define	MBX_1		BIT_1
+#define	MBX_0		BIT_0
+
+/*
+ * Firmware state codes from get firmware state mailbox command
+ */
+#define FSTATE_CONFIG_WAIT      0
+#define FSTATE_WAIT_AL_PA       1
+#define FSTATE_WAIT_LOGIN       2
+#define FSTATE_READY            3
+#define FSTATE_LOSS_OF_SYNC     4
+#define FSTATE_ERROR            5
+#define FSTATE_REINIT           6
+#define FSTATE_NON_PART         7
+
+#define FSTATE_CONFIG_CORRECT      0
+#define FSTATE_P2P_RCV_LIP         1
+#define FSTATE_P2P_CHOOSE_LOOP     2
+#define FSTATE_P2P_RCV_UNIDEN_LIP  3
+#define FSTATE_FATAL_ERROR         4
+#define FSTATE_LOOP_BACK_CONN      5
+
+/*
+ * Port Database structure definition
+ * Little endian except where noted.
+ */
+#define	PORT_DATABASE_SIZE	128	/* bytes */
+typedef struct {
+	uint8_t options;
+	uint8_t control;
+	uint8_t master_state;
+	uint8_t slave_state;
+	uint8_t reserved[2];
+	uint8_t hard_address;
+	uint8_t reserved_1;
+	uint8_t port_id[4];
+	uint8_t node_name[WWN_SIZE];		/* Big endian. */
+	uint8_t port_name[WWN_SIZE];		/* Big endian. */
+	uint16_t execution_throttle;
+	uint16_t execution_count;
+	uint8_t reset_count;
+	uint8_t reserved_2;
+	uint16_t resource_allocation;
+	uint16_t current_allocation;
+	uint16_t queue_head;
+	uint16_t queue_tail;
+	uint16_t transmit_execution_list_next;
+	uint16_t transmit_execution_list_previous;
+	uint16_t common_features;
+	uint16_t total_concurrent_sequences;
+	uint16_t RO_by_information_category;
+	uint8_t recipient;
+	uint8_t initiator;
+	uint16_t receive_data_size;
+	uint16_t concurrent_sequences;
+	uint16_t open_sequences_per_exchange;
+	uint16_t lun_abort_flags;
+	uint16_t lun_stop_flags;
+	uint16_t stop_queue_head;
+	uint16_t stop_queue_tail;
+	uint16_t port_retry_timer;
+	uint16_t next_sequence_id;
+	uint16_t frame_count;
+	uint16_t PRLI_payload_length;
+	uint8_t prli_svc_param_word_0[2];	/* Big endian */
+						/* Bits 15-0 of word 0 */
+	uint8_t prli_svc_param_word_3[2];	/* Big endian */
+						/* Bits 15-0 of word 3 */
+	uint16_t loop_id;
+	uint16_t extended_lun_info_list_pointer;
+	uint16_t extended_lun_stop_list_pointer;
+} port_database_t;
+
+/*
+ * Port database slave/master states
+ */
+#define PD_STATE_DISCOVERY			0
+#define PD_STATE_WAIT_DISCOVERY_ACK		1
+#define PD_STATE_PORT_LOGIN			2
+#define PD_STATE_WAIT_PORT_LOGIN_ACK		3
+#define PD_STATE_PROCESS_LOGIN			4
+#define PD_STATE_WAIT_PROCESS_LOGIN_ACK		5
+#define PD_STATE_PORT_LOGGED_IN			6
+#define PD_STATE_PORT_UNAVAILABLE		7
+#define PD_STATE_PROCESS_LOGOUT			8
+#define PD_STATE_WAIT_PROCESS_LOGOUT_ACK	9
+#define PD_STATE_PORT_LOGOUT			10
+#define PD_STATE_WAIT_PORT_LOGOUT_ACK		11
+
+
+/*
+ * ISP Initialization Control Block.
+ * Little endian except where noted.
+ */
+#define	ICB_VERSION 1
+typedef struct {
+	uint8_t  version;
+	uint8_t  reserved_1;
+
+	/*
+	 * LSB BIT 0  = Enable Hard Loop Id
+	 * LSB BIT 1  = Enable Fairness
+	 * LSB BIT 2  = Enable Full-Duplex
+	 * LSB BIT 3  = Enable Fast Posting
+	 * LSB BIT 4  = Enable Target Mode
+	 * LSB BIT 5  = Disable Initiator Mode
+	 * LSB BIT 6  = Enable ADISC
+	 * LSB BIT 7  = Enable Target Inquiry Data
+	 *
+	 * MSB BIT 0  = Enable PDBC Notify
+	 * MSB BIT 1  = Non Participating LIP
+	 * MSB BIT 2  = Descending Loop ID Search
+	 * MSB BIT 3  = Acquire Loop ID in LIPA
+	 * MSB BIT 4  = Stop PortQ on Full Status
+	 * MSB BIT 5  = Full Login after LIP
+	 * MSB BIT 6  = Node Name Option
+	 * MSB BIT 7  = Ext IFWCB enable bit
+	 */
+	uint8_t  firmware_options[2];
+
+	uint16_t frame_payload_size;
+	uint16_t max_iocb_allocation;
+	uint16_t execution_throttle;
+	uint8_t  retry_count;
+	uint8_t	 retry_delay;			/* unused */
+	uint8_t	 port_name[WWN_SIZE];		/* Big endian. */
+	uint16_t hard_address;
+	uint8_t	 inquiry_data;
+	uint8_t	 login_timeout;
+	uint8_t	 node_name[WWN_SIZE];		/* Big endian. */
+
+	uint16_t request_q_outpointer;
+	uint16_t response_q_inpointer;
+	uint16_t request_q_length;
+	uint16_t response_q_length;
+	uint32_t request_q_address[2];
+	uint32_t response_q_address[2];
+
+	uint16_t lun_enables;
+	uint8_t  command_resource_count;
+	uint8_t  immediate_notify_resource_count;
+	uint16_t timeout;
+	uint8_t  reserved_2[2];
+
+	/*
+	 * LSB BIT 0 = Timer Operation mode bit 0
+	 * LSB BIT 1 = Timer Operation mode bit 1
+	 * LSB BIT 2 = Timer Operation mode bit 2
+	 * LSB BIT 3 = Timer Operation mode bit 3
+	 * LSB BIT 4 = Init Config Mode bit 0
+	 * LSB BIT 5 = Init Config Mode bit 1
+	 * LSB BIT 6 = Init Config Mode bit 2
+	 * LSB BIT 7 = Enable Non part on LIHA failure
+	 *
+	 * MSB BIT 0 = Enable class 2
+	 * MSB BIT 1 = Enable ACK0
+	 * MSB BIT 2 =
+	 * MSB BIT 3 =
+	 * MSB BIT 4 = FC Tape Enable
+	 * MSB BIT 5 = Enable FC Confirm
+	 * MSB BIT 6 = Enable command queuing in target mode
+	 * MSB BIT 7 = No Logo On Link Down
+	 */
+	uint8_t	 add_firmware_options[2];
+
+	uint8_t	 response_accumulation_timer;
+	uint8_t	 interrupt_delay_timer;
+
+	/*
+	 * LSB BIT 0 = Enable Read xfr_rdy
+	 * LSB BIT 1 = Soft ID only
+	 * LSB BIT 2 =
+	 * LSB BIT 3 =
+	 * LSB BIT 4 = FCP RSP Payload [0]
+	 * LSB BIT 5 = FCP RSP Payload [1] / Sbus enable - 2200
+	 * LSB BIT 6 = Enable Out-of-Order frame handling
+	 * LSB BIT 7 = Disable Automatic PLOGI on Local Loop
+	 *
+	 * MSB BIT 0 = Sbus enable - 2300
+	 * MSB BIT 1 =
+	 * MSB BIT 2 =
+	 * MSB BIT 3 =
+	 * MSB BIT 4 =
+	 * MSB BIT 5 = enable 50 ohm termination
+	 * MSB BIT 6 = Data Rate (2300 only)
+	 * MSB BIT 7 = Data Rate (2300 only)
+	 */
+	uint8_t	 special_options[2];
+
+	uint8_t  reserved_3[26];
+} init_cb_t;
+
+/*
+ * Get Link Status mailbox command return buffer.
+ */
+typedef struct {
+	uint32_t	link_fail_cnt;
+	uint32_t	loss_sync_cnt;
+	uint32_t	loss_sig_cnt;
+	uint32_t	prim_seq_err_cnt;
+	uint32_t	inval_xmit_word_cnt;
+	uint32_t	inval_crc_cnt;
+} link_stat_t;
+
+/*
+ * NVRAM Command values.
+ */
+#define NV_START_BIT            BIT_2
+#define NV_WRITE_OP             (BIT_26+BIT_24)
+#define NV_READ_OP              (BIT_26+BIT_25)
+#define NV_ERASE_OP             (BIT_26+BIT_25+BIT_24)
+#define NV_MASK_OP              (BIT_26+BIT_25+BIT_24)
+#define NV_DELAY_COUNT          10
+
+/*
+ * QLogic ISP2100, ISP2200 and ISP2300 NVRAM structure definition.
+ */
+typedef struct {
+	/*
+	 * NVRAM header
+	 */
+	uint8_t	id[4];
+	uint8_t	nvram_version;
+	uint8_t	reserved_0;
+
+	/*
+	 * NVRAM RISC parameter block
+	 */
+	uint8_t	parameter_block_version;
+	uint8_t	reserved_1;
+
+	/*
+	 * LSB BIT 0  = Enable Hard Loop Id
+	 * LSB BIT 1  = Enable Fairness
+	 * LSB BIT 2  = Enable Full-Duplex
+	 * LSB BIT 3  = Enable Fast Posting
+	 * LSB BIT 4  = Enable Target Mode
+	 * LSB BIT 5  = Disable Initiator Mode
+	 * LSB BIT 6  = Enable ADISC
+	 * LSB BIT 7  = Enable Target Inquiry Data
+	 *
+	 * MSB BIT 0  = Enable PDBC Notify
+	 * MSB BIT 1  = Non Participating LIP
+	 * MSB BIT 2  = Descending Loop ID Search
+	 * MSB BIT 3  = Acquire Loop ID in LIPA
+	 * MSB BIT 4  = Stop PortQ on Full Status
+	 * MSB BIT 5  = Full Login after LIP
+	 * MSB BIT 6  = Node Name Option
+	 * MSB BIT 7  = Ext IFWCB enable bit
+	 */
+	uint8_t	 firmware_options[2];
+
+	uint16_t frame_payload_size;
+	uint16_t max_iocb_allocation;
+	uint16_t execution_throttle;
+	uint8_t	 retry_count;
+	uint8_t	 retry_delay;			/* unused */
+	uint8_t	 port_name[WWN_SIZE];		/* Big endian. */
+	uint16_t hard_address;
+	uint8_t	 inquiry_data;
+	uint8_t	 login_timeout;
+	uint8_t	 node_name[WWN_SIZE];		/* Big endian. */
+
+	/*
+	 * LSB BIT 0 = Timer Operation mode bit 0
+	 * LSB BIT 1 = Timer Operation mode bit 1
+	 * LSB BIT 2 = Timer Operation mode bit 2
+	 * LSB BIT 3 = Timer Operation mode bit 3
+	 * LSB BIT 4 = Init Config Mode bit 0
+	 * LSB BIT 5 = Init Config Mode bit 1
+	 * LSB BIT 6 = Init Config Mode bit 2
+	 * LSB BIT 7 = Enable Non part on LIHA failure
+	 *
+	 * MSB BIT 0 = Enable class 2
+	 * MSB BIT 1 = Enable ACK0
+	 * MSB BIT 2 =
+	 * MSB BIT 3 =
+	 * MSB BIT 4 = FC Tape Enable
+	 * MSB BIT 5 = Enable FC Confirm
+	 * MSB BIT 6 = Enable command queuing in target mode
+	 * MSB BIT 7 = No Logo On Link Down
+	 */
+	uint8_t	 add_firmware_options[2];
+
+	uint8_t	 response_accumulation_timer;
+	uint8_t	 interrupt_delay_timer;
+
+	/*
+	 * LSB BIT 0 = Enable Read xfr_rdy
+	 * LSB BIT 1 = Soft ID only
+	 * LSB BIT 2 =
+	 * LSB BIT 3 =
+	 * LSB BIT 4 = FCP RSP Payload [0]
+	 * LSB BIT 5 = FCP RSP Payload [1] / Sbus enable - 2200
+	 * LSB BIT 6 = Enable Out-of-Order frame handling
+	 * LSB BIT 7 = Disable Automatic PLOGI on Local Loop
+	 *
+	 * MSB BIT 0 = Sbus enable - 2300
+	 * MSB BIT 1 =
+	 * MSB BIT 2 =
+	 * MSB BIT 3 =
+	 * MSB BIT 4 =
+	 * MSB BIT 5 = enable 50 ohm termination
+	 * MSB BIT 6 = Data Rate (2300 only)
+	 * MSB BIT 7 = Data Rate (2300 only)
+	 */
+	uint8_t	 special_options[2];
+
+	/* Reserved for expanded RISC parameter block */
+	uint8_t reserved_2[24];
+
+	/*
+	 * LSB BIT 0 = Output Swing 1G bit 0
+	 * LSB BIT 1 = Output Swing 1G bit 1
+	 * LSB BIT 2 = Output Swing 1G bit 2
+	 * LSB BIT 3 = Output Emphasis 1G bit 0
+	 * LSB BIT 4 = Output Emphasis 1G bit 1
+	 * LSB BIT 5 = Output Swing 2G bit 0
+	 * LSB BIT 6 = Output Swing 2G bit 1
+	 * LSB BIT 7 = Output Swing 2G bit 2
+	 *            
+	 * MSB BIT 0 = Output Emphasis 2G bit 0
+	 * MSB BIT 1 = Output Emphasis 2G bit 1
+	 * MSB BIT 2 = Output Enable
+	 * MSB BIT 3 =
+	 * MSB BIT 4 =
+	 * MSB BIT 5 =
+	 * MSB BIT 6 =
+	 * MSB BIT 7 =
+	 */
+	uint8_t seriallink_options[2];
+
+	/*
+	 * NVRAM host parameter block
+	 *
+	 * LSB BIT 0 = Enable spinup delay
+	 * LSB BIT 1 = Disable BIOS
+	 * LSB BIT 2 = Enable Memory Map BIOS
+	 * LSB BIT 3 = Enable Selectable Boot
+	 * LSB BIT 4 = Disable RISC code load
+	 * LSB BIT 5 = Set cache line size 1
+	 * LSB BIT 6 = PCI Parity Disable
+	 * LSB BIT 7 = Enable extended logging
+	 *
+	 * MSB BIT 0 = Enable 64bit addressing
+	 * MSB BIT 1 = Enable lip reset
+	 * MSB BIT 2 = Enable lip full login
+	 * MSB BIT 3 = Enable target reset
+	 * MSB BIT 4 = Enable database storage
+	 * MSB BIT 5 = Enable cache flush read
+	 * MSB BIT 6 = Enable database load
+	 * MSB BIT 7 = Enable alternate WWN
+	 */
+	uint8_t host_p[2];
+
+	uint8_t boot_node_name[WWN_SIZE];
+	uint8_t boot_lun_number;
+	uint8_t reset_delay;
+	uint8_t port_down_retry_count;
+	uint8_t boot_id_number;
+	uint16_t max_luns_per_target;
+	uint8_t fcode_boot_port_name[WWN_SIZE];
+	uint8_t alternate_port_name[WWN_SIZE];
+	uint8_t alternate_node_name[WWN_SIZE];
+
+	/*
+	 * BIT 0 = Boot Zoning
+	 * BIT 1 = Alt-Boot Enable
+	 * BIT 2 = Report SCSI Path
+	 * BIT 3 = unused
+	 * BIT 4 = unused
+	 * BIT 5 = unused
+	 * BIT 6 = unused
+	 * BIT 7 = unused
+	 */
+	uint8_t efi_parameters;
+
+	uint8_t link_down_timeout;
+
+	uint8_t adapter_id_0[4];
+	uint8_t adapter_id_1[4];
+	uint8_t adapter_id_2[4];
+	uint8_t adapter_id_3[4];
+
+	uint8_t alt1_boot_node_name[WWN_SIZE];
+	uint16_t alt1_boot_lun_number;
+	uint8_t alt2_boot_node_name[WWN_SIZE];
+	uint16_t alt2_boot_lun_number;
+	uint8_t alt3_boot_node_name[WWN_SIZE];
+	uint16_t alt3_boot_lun_number;
+	uint8_t alt4_boot_node_name[WWN_SIZE];
+	uint16_t alt4_boot_lun_number;
+	uint8_t alt5_boot_node_name[WWN_SIZE];
+	uint16_t alt5_boot_lun_number;
+	uint8_t alt6_boot_node_name[WWN_SIZE];
+	uint16_t alt6_boot_lun_number;
+	uint8_t alt7_boot_node_name[WWN_SIZE];
+	uint16_t alt7_boot_lun_number;
+
+	uint8_t reserved_3[2];
+
+	/* Offset 200-215 : Model Number */
+	uint8_t model_number[16];
+
+	/* OEM related items */
+	uint8_t oem_specific[16];
+
+	/*
+	 * NVRAM Adapter Features offset 232-239
+	 *
+	 * LSB BIT 0 = External GBIC
+	 * LSB BIT 1 = Risc RAM parity
+	 * LSB BIT 2 = Buffer Plus Module
+	 * LSB BIT 3 = Multi Chip Adapter
+	 * LSB BIT 4 = Internal connector
+	 * LSB BIT 5 =
+	 * LSB BIT 6 =
+	 * LSB BIT 7 =
+	 *
+	 * MSB BIT 0 =
+	 * MSB BIT 1 =
+	 * MSB BIT 2 =
+	 * MSB BIT 3 =
+	 * MSB BIT 4 =
+	 * MSB BIT 5 =
+	 * MSB BIT 6 =
+	 * MSB BIT 7 =
+	 */
+	uint8_t	adapter_features[2];
+
+	uint8_t reserved_4[16];
+
+	/* Subsystem vendor ID for ISP2200 */
+	uint16_t subsystem_vendor_id_2200;
+
+	/* Subsystem device ID for ISP2200 */
+	uint16_t subsystem_device_id_2200;
+
+	uint8_t	 reserved_5;
+	uint8_t	 checksum;
+} nvram_t;
+
+/*
+ * ISP queue - response queue entry definition.
+ */
+typedef struct {
+	uint8_t		data[60];
+	uint32_t	signature;
+#define RESPONSE_PROCESSED	0xDEADDEAD	/* Signature */
+} response_t;
+
+typedef union {
+	uint16_t extended;
+	struct {
+		uint8_t reserved;
+		uint8_t standard;;
+	};
+} target_id_t;
+
+#define SET_TARGET_ID(ha, to, from)			\
+do {							\
+	if (HAS_EXTENDED_IDS(ha))			\
+		to.extended = cpu_to_le16(from);	\
+	else						\
+		to.standard = (uint8_t)from;		\
+} while (0)
+
+/*
+ * ISP queue - command entry structure definition.
+ */
+#define COMMAND_TYPE	0x11		/* Command entry */
+#define MAX_CMDSZ	16		/* SCSI maximum CDB size. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t handle;		/* System handle. */
+	target_id_t target;		/* SCSI ID */
+	uint16_t lun;			/* SCSI LUN */
+	uint16_t control_flags;		/* Control flags. */
+#define CF_WRITE	BIT_6
+#define CF_READ		BIT_5
+#define CF_SIMPLE_TAG	BIT_3
+#define CF_ORDERED_TAG	BIT_2
+#define CF_HEAD_TAG	BIT_1
+	uint16_t reserved_1;
+	uint16_t timeout;		/* Command timeout. */
+	uint16_t dseg_count;		/* Data segment count. */
+	uint8_t scsi_cdb[MAX_CMDSZ]; 	/* SCSI command words. */
+	uint32_t byte_count;		/* Total byte count. */
+	uint32_t dseg_0_address;	/* Data segment 0 address. */
+	uint32_t dseg_0_length;		/* Data segment 0 length. */
+	uint32_t dseg_1_address;	/* Data segment 1 address. */
+	uint32_t dseg_1_length;		/* Data segment 1 length. */
+	uint32_t dseg_2_address;	/* Data segment 2 address. */
+	uint32_t dseg_2_length;		/* Data segment 2 length. */
+} cmd_entry_t;
+
+/*
+ * ISP queue - 64-Bit addressing, command entry structure definition.
+ */
+#define COMMAND_A64_TYPE	0x19	/* Command A64 entry */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t handle;		/* System handle. */
+	target_id_t target;		/* SCSI ID */
+	uint16_t lun;			/* SCSI LUN */
+	uint16_t control_flags;		/* Control flags. */
+	uint16_t reserved_1;
+	uint16_t timeout;		/* Command timeout. */
+	uint16_t dseg_count;		/* Data segment count. */
+	uint8_t scsi_cdb[MAX_CMDSZ];	/* SCSI command words. */
+	uint32_t byte_count;		/* Total byte count. */
+	uint32_t dseg_0_address[2];	/* Data segment 0 address. */
+	uint32_t dseg_0_length;		/* Data segment 0 length. */
+	uint32_t dseg_1_address[2];	/* Data segment 1 address. */
+	uint32_t dseg_1_length;		/* Data segment 1 length. */
+} cmd_a64_entry_t, request_t;
+
+/*
+ * ISP queue - continuation entry structure definition.
+ */
+#define CONTINUE_TYPE		0x02	/* Continuation entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t reserved;
+	uint32_t dseg_0_address;	/* Data segment 0 address. */
+	uint32_t dseg_0_length;		/* Data segment 0 length. */
+	uint32_t dseg_1_address;	/* Data segment 1 address. */
+	uint32_t dseg_1_length;		/* Data segment 1 length. */
+	uint32_t dseg_2_address;	/* Data segment 2 address. */
+	uint32_t dseg_2_length;		/* Data segment 2 length. */
+	uint32_t dseg_3_address;	/* Data segment 3 address. */
+	uint32_t dseg_3_length;		/* Data segment 3 length. */
+	uint32_t dseg_4_address;	/* Data segment 4 address. */
+	uint32_t dseg_4_length;		/* Data segment 4 length. */
+	uint32_t dseg_5_address;	/* Data segment 5 address. */
+	uint32_t dseg_5_length;		/* Data segment 5 length. */
+	uint32_t dseg_6_address;	/* Data segment 6 address. */
+	uint32_t dseg_6_length;		/* Data segment 6 length. */
+} cont_entry_t;
+
+/*
+ * ISP queue - 64-Bit addressing, continuation entry structure definition.
+ */
+#define CONTINUE_A64_TYPE	0x0A	/* Continuation A64 entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t dseg_0_address[2];	/* Data segment 0 address. */
+	uint32_t dseg_0_length;		/* Data segment 0 length. */
+	uint32_t dseg_1_address[2];	/* Data segment 1 address. */
+	uint32_t dseg_1_length;		/* Data segment 1 length. */
+	uint32_t dseg_2_address	[2];	/* Data segment 2 address. */
+	uint32_t dseg_2_length;		/* Data segment 2 length. */
+	uint32_t dseg_3_address[2];	/* Data segment 3 address. */
+	uint32_t dseg_3_length;		/* Data segment 3 length. */
+	uint32_t dseg_4_address[2];	/* Data segment 4 address. */
+	uint32_t dseg_4_length;		/* Data segment 4 length. */
+} cont_a64_entry_t;
+
+/*
+ * ISP queue - status entry structure definition.
+ */
+#define	STATUS_TYPE	0x03		/* Status entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t handle;		/* System handle. */
+	uint16_t scsi_status;		/* SCSI status. */
+	uint16_t comp_status;		/* Completion status. */
+	uint16_t state_flags;		/* State flags. */
+	uint16_t status_flags;		/* Status flags. */
+	uint16_t rsp_info_len;		/* Response Info Length. */
+	uint16_t req_sense_length;	/* Request sense data length. */
+	uint32_t residual_length;	/* Residual transfer length. */
+	uint8_t rsp_info[8];		/* FCP response information. */
+	uint8_t req_sense_data[32];	/* Request sense data. */
+} sts_entry_t;
+
+/*
+ * Status entry entry status
+ */
+#define RF_INV_E_ORDER	BIT_5		/* Invalid entry order. */
+#define RF_INV_E_COUNT	BIT_4		/* Invalid entry count. */
+#define RF_INV_E_PARAM	BIT_3		/* Invalid entry parameter. */
+#define RF_INV_E_TYPE	BIT_2		/* Invalid entry type. */
+#define RF_BUSY		BIT_1		/* Busy */
+
+/*
+ * Status entry SCSI status bit definitions.
+ */
+#define SS_MASK				0xfff	/* Reserved bits BIT_12-BIT_15*/
+#define SS_RESIDUAL_UNDER		BIT_11
+#define SS_RESIDUAL_OVER		BIT_10
+#define SS_SENSE_LEN_VALID		BIT_9
+#define SS_RESIDUAL_LEN_VALID		BIT_8	/* ISP2100 only */
+#define SS_RESPONSE_INFO_LEN_VALID	BIT_8	/* ISP2200 and 23xx */
+
+#define SS_RESERVE_CONFLICT		(BIT_4 | BIT_3)
+#define SS_BUSY_CONDITION		BIT_3
+#define SS_CONDITION_MET		BIT_2
+#define SS_CHECK_CONDITION		BIT_1
+
+/*
+ * Status entry completion status
+ */
+#define CS_COMPLETE		0x0	/* No errors */
+#define CS_INCOMPLETE		0x1	/* Incomplete transfer of cmd. */
+#define CS_DMA			0x2	/* A DMA direction error. */
+#define CS_TRANSPORT		0x3	/* Transport error. */
+#define CS_RESET		0x4	/* SCSI bus reset occurred */
+#define CS_ABORTED		0x5	/* System aborted command. */
+#define CS_TIMEOUT		0x6	/* Timeout error. */
+#define CS_DATA_OVERRUN		0x7	/* Data overrun. */
+
+#define CS_DATA_UNDERRUN	0x15	/* Data Underrun. */
+#define CS_QUEUE_FULL		0x1C	/* Queue Full. */
+#define CS_PORT_UNAVAILABLE	0x28	/* Port unavailable */
+					/* (selection timeout) */
+#define CS_PORT_LOGGED_OUT	0x29	/* Port Logged Out */
+#define CS_PORT_CONFIG_CHG	0x2A	/* Port Configuration Changed */
+#define CS_PORT_BUSY		0x2B	/* Port Busy */
+#define CS_COMPLETE_CHKCOND	0x30	/* Error? */
+#define CS_BAD_PAYLOAD		0x80	/* Driver defined */
+#define CS_UNKNOWN		0x81	/* Driver defined */
+#define CS_RETRY		0x82	/* Driver defined */
+#define CS_LOOP_DOWN_ABORT	0x83	/* Driver defined */
+
+/*
+ * Status entry status flags
+ */
+#define SF_LOGOUT_SENT		BIT_13
+
+/*
+ * ISP queue - status continuation entry structure definition.
+ */
+#define	STATUS_CONT_TYPE	0x10	/* Status continuation entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t sys_define;		/* System defined. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint8_t data[60];		/* data */
+} sts_cont_entry_t;
+
+/*
+ * ISP queue -	RIO Type 1 status entry (32 bit I/O entry handles)
+ *		structure definition.
+ */
+#define	STATUS_TYPE_21 0x21		/* Status entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t handle_count;		/* Handle count. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t handle[15];		/* System handles. */
+} sts21_entry_t;
+
+/*
+ * ISP queue -	RIO Type 2 status entry (16 bit I/O entry handles)
+ *		structure definition.
+ */
+#define	STATUS_TYPE_22	0x22		/* Status entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t handle_count;		/* Handle count. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint16_t handle[30];		/* System handles. */
+} sts22_entry_t;
+
+/*
+ * ISP queue - marker entry structure definition.
+ */
+#define MARKER_TYPE	0x04		/* Marker entry. */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t handle_count;		/* Handle count. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t sys_define_2;		/* System defined. */
+	target_id_t target;		/* SCSI ID */
+	uint8_t modifier;		/* Modifier (7-0). */
+#define MK_SYNC_ID_LUN	0		/* Synchronize ID/LUN */
+#define MK_SYNC_ID	1		/* Synchronize ID */
+#define MK_SYNC_ALL	2		/* Synchronize all ID/LUN */
+#define MK_SYNC_LIP	3		/* Synchronize all ID/LUN, */
+					/* clear port changed, */
+					/* use sequence number. */
+	uint8_t reserved_1;
+	uint16_t sequence_number;	/* Sequence number of event */
+	uint16_t lun;			/* SCSI LUN */
+	uint8_t reserved_2[48];
+} mrk_entry_t;
+
+/*
+ * ISP queue - Management Server entry structure definition.
+ */
+#define MS_IOCB_TYPE		0x29	/* Management Server IOCB entry */
+typedef struct {
+	uint8_t entry_type;		/* Entry type. */
+	uint8_t entry_count;		/* Entry count. */
+	uint8_t handle_count;		/* Handle count. */
+	uint8_t entry_status;		/* Entry Status. */
+	uint32_t handle1;		/* System handle. */
+	target_id_t loop_id;
+	uint16_t status;
+	uint16_t control_flags;		/* Control flags. */
+	uint16_t reserved2;
+	uint16_t timeout;
+	uint16_t cmd_dsd_count;
+	uint16_t total_dsd_count;
+	uint8_t type;
+	uint8_t r_ctl;
+	uint16_t rx_id;
+	uint16_t reserved3;
+	uint32_t handle2;
+	uint32_t rsp_bytecount;
+	uint32_t req_bytecount;
+	uint32_t dseg_req_address[2];	/* Data segment 0 address. */
+	uint32_t dseg_req_length;	/* Data segment 0 length. */
+	uint32_t dseg_rsp_address[2];	/* Data segment 1 address. */
+	uint32_t dseg_rsp_length;	/* Data segment 1 length. */
+} ms_iocb_entry_t;
+
+
+/*
+ * ISP queue - Mailbox Command entry structure definition.
+ */
+#define MBX_IOCB_TYPE	0x39
+struct mbx_entry {
+	uint8_t entry_type;
+	uint8_t entry_count;
+	uint8_t sys_define1;
+	/* Use sys_define1 for source type */
+#define SOURCE_SCSI	0x00
+#define SOURCE_IP	0x01
+#define SOURCE_VI	0x02
+#define SOURCE_SCTP	0x03
+#define SOURCE_MP	0x04
+#define SOURCE_MPIOCTL	0x05
+#define SOURCE_ASYNC_IOCB 0x07
+
+	uint8_t entry_status;
+
+	uint32_t handle;
+	target_id_t loop_id;
+
+	uint16_t status;
+	uint16_t state_flags;
+	uint16_t status_flags;
+
+	uint32_t sys_define2[2];
+
+	uint16_t mb0;
+	uint16_t mb1;
+	uint16_t mb2;
+	uint16_t mb3;
+	uint16_t mb6;
+	uint16_t mb7;
+	uint16_t mb9;
+	uint16_t mb10;
+	uint32_t reserved_2[2];
+	uint8_t node_name[WWN_SIZE];
+	uint8_t port_name[WWN_SIZE];
+};
+
+/*
+ * ISP request and response queue entry sizes
+ */
+#define RESPONSE_ENTRY_SIZE	(sizeof(response_t))
+#define REQUEST_ENTRY_SIZE	(sizeof(request_t))
+
+
+/*
+ * 24 bit port ID type definition.
+ */
+typedef union {
+	uint32_t b24 : 24;
+
+	struct {
+		uint8_t d_id[3];
+		uint8_t rsvd_1;
+	} r;
+
+	struct {
+		uint8_t al_pa;
+		uint8_t area;
+		uint8_t domain;
+		uint8_t rsvd_1;
+	} b;
+} port_id_t;
+#define INVALID_PORT_ID	0xFFFFFF
+
+/*
+ * Switch info gathering structure.
+ */
+typedef struct {
+	port_id_t d_id;
+	uint8_t node_name[WWN_SIZE];
+	uint8_t port_name[WWN_SIZE];
+	uint32_t type;
+#define SW_TYPE_IP	BIT_1
+#define SW_TYPE_SCSI	BIT_0
+} sw_info_t;
+
+/*
+ * Inquiry command structure.
+ */
+#define INQ_DATA_SIZE	8
+
+/*
+ * Inquiry mailbox IOCB packet definition.
+ */
+typedef struct {
+	union {
+		cmd_a64_entry_t cmd;
+		sts_entry_t rsp;
+	} p;
+	uint8_t inq[INQ_DATA_SIZE];
+} inq_cmd_rsp_t;
+
+/*
+ * Report LUN command structure.
+ */
+#define CHAR_TO_SHORT(a, b)	(uint16_t)((uint8_t)b << 8 | (uint8_t)a)
+
+typedef struct {
+	uint32_t len;
+	uint32_t rsrv;
+} rpt_hdr_t;
+
+typedef struct {
+	struct {
+		uint8_t b : 6;
+		uint8_t address_method : 2;
+	} msb;
+	uint8_t lsb;
+	uint8_t unused[6];
+} rpt_lun_t;
+
+typedef struct {
+	rpt_hdr_t hdr;
+	rpt_lun_t lst[MAX_LUNS];
+} rpt_lun_lst_t;
+
+/*
+ * Report Lun mailbox IOCB packet definition.
+ */
+typedef struct {
+	union {
+		cmd_a64_entry_t cmd;
+		sts_entry_t rsp;
+	} p;
+	rpt_lun_lst_t list;
+} rpt_lun_cmd_rsp_t;
+
+/*
+ * SCSI Target Queue structure
+ */
+typedef struct os_tgt {
+	struct os_lun *olun[MAX_LUNS]; /* LUN context pointer. */
+	struct fc_port *fcport;
+	uint32_t flags;
+	uint8_t port_down_retry_count;
+    	uint32_t down_timer;
+	struct scsi_qla_host *ha;
+
+	/* Persistent binding information */
+	port_id_t d_id;
+	uint8_t node_name[WWN_SIZE];
+	uint8_t port_name[WWN_SIZE];
+} os_tgt_t;
+
+/*
+ * SCSI Target Queue flags
+ */
+#define TQF_QUEUE_SUSPENDED	BIT_0		/* Queue suspended. */
+#define TQF_BOOT_DEVICE		BIT_1		/* Boot device. */
+#define TQF_ONLINE		BIT_2		/* Device online to OS. */
+#define TQF_TGT_RST_NEEDED	BIT_3
+
+/*
+ * SCSI LUN Queue structure
+ */
+typedef struct os_lun {
+	struct fc_lun *fclun;		/* FC LUN context pointer. */
+    	spinlock_t q_lock;		/* Lun Lock */
+
+	unsigned long q_flag;
+#define LUN_MPIO_BUSY		2	/* Lun is changing paths  */
+#define LUN_EXEC_DELAYED	7	/* Lun execution is delayed */
+
+	u_long q_timeout;		/* total command timeouts */
+	atomic_t q_timer;		/* suspend timer */
+	uint32_t q_count;		/* current count */
+	uint32_t q_max;			/* maxmum count lun can be suspended */
+	uint8_t q_state;		/* lun State */
+#define LUN_STATE_READY		1	/* lun is ready for i/o */
+#define LUN_STATE_RUN		2	/* lun has a timer running */
+#define LUN_STATE_WAIT		3	/* lun is suspended */
+#define LUN_STATE_TIMEOUT	4	/* lun has timed out */
+
+	u_long io_cnt;			/* total xfer count since boot */
+	u_long out_cnt;			/* total outstanding IO count */
+	u_long w_cnt;			/* total writes */
+	u_long r_cnt;			/* total reads */
+	u_long avg_time;		/*  */
+} os_lun_t;
+
+
+/* LUN BitMask structure definition, array of 32bit words,
+ * 1 bit per lun.  When bit == 1, the lun is masked.
+ * Most significant bit of mask[0] is lun 0, bit 24 is lun 7.
+ */
+typedef struct lun_bit_mask {
+	/* Must allocate at least enough bits to accomodate all LUNs */
+#if ((MAX_FIBRE_LUNS & 0x7) == 0)
+	uint8_t mask[MAX_FIBRE_LUNS >> 3];
+#else
+	uint8_t mask[(MAX_FIBRE_LUNS + 8) >> 3];
+#endif
+} lun_bit_mask_t;
+
+/*
+ * Fibre channel port type.
+ */
+ typedef enum {
+	FCT_UNKNOWN,
+	FCT_RSCN,
+	FCT_SWITCH,
+	FCT_BROADCAST,
+	FCT_INITIATOR,
+	FCT_TARGET
+} fc_port_type_t;
+
+/*
+ * Fibre channel port structure.
+ */
+typedef struct fc_port {
+	struct list_head list;
+	struct list_head fcluns;
+
+	struct scsi_qla_host *ha;
+	struct scsi_qla_host *vis_ha;	/* only used when suspending lun */
+
+	uint8_t node_name[WWN_SIZE];
+	uint8_t port_name[WWN_SIZE];
+	port_id_t d_id;
+	uint16_t loop_id;
+	uint16_t old_loop_id;
+
+	fc_port_type_t port_type;
+
+	atomic_t state;
+	uint32_t flags;
+
+	os_tgt_t *tgt_queue;
+	uint16_t os_target_id;
+
+	uint16_t iodesc_idx_sent;
+
+	int port_login_retry_count;
+	int login_retry;
+	atomic_t port_down_timer;
+
+	uint8_t device_type;
+	uint8_t unused;
+
+	uint8_t mp_byte;		/* multi-path byte (not used) */
+    	uint8_t cur_path;		/* current path id */
+
+	lun_bit_mask_t lun_mask;
+} fc_port_t;
+
+/*
+ * Fibre channel port/lun states.
+ */
+#define FCS_UNCONFIGURED	1
+#define FCS_DEVICE_DEAD		2
+#define FCS_DEVICE_LOST		3
+#define FCS_ONLINE		4
+#define FCS_NOT_SUPPORTED	5
+#define FCS_FAILOVER		6
+#define FCS_FAILOVER_FAILED	7
+
+/*
+ * FC port flags.
+ */
+#define FCF_FABRIC_DEVICE	BIT_0
+#define FCF_LOGIN_NEEDED	BIT_1
+#define FCF_FO_MASKED		BIT_2
+#define FCF_FAILOVER_NEEDED	BIT_3
+#define FCF_RESET_NEEDED	BIT_4
+#define FCF_PERSISTENT_BOUND	BIT_5
+#define FCF_TAPE_PRESENT	BIT_6
+#define FCF_FARP_DONE		BIT_7
+#define FCF_FARP_FAILED		BIT_8
+#define FCF_FARP_REPLY_NEEDED	BIT_9
+#define FCF_AUTH_REQ		BIT_10
+#define FCF_SEND_AUTH_REQ	BIT_11
+#define FCF_RECEIVE_AUTH_REQ	BIT_12
+#define FCF_AUTH_SUCCESS	BIT_13
+#define FCF_RLC_SUPPORT		BIT_14
+#define FCF_CONFIG		BIT_15	/* Needed? */
+#define FCF_RESCAN_NEEDED	BIT_16
+
+/* No loop ID flag. */
+#define FC_NO_LOOP_ID		0x1000
+
+/*
+ * Fibre channel LUN structure.
+ */
+typedef struct fc_lun {
+        struct list_head list;
+
+	fc_port_t *fcport;
+	fc_port_t *o_fcport;
+	uint16_t lun;
+	atomic_t state;
+	uint8_t device_type;
+	uint8_t max_path_retries;
+} fc_lun_t;
+
+
+/*
+ * FC-CT interface
+ *
+ * NOTE: All structures are big-endian in form.
+ */
+
+#define CT_REJECT_RESPONSE	0x8001
+#define CT_ACCEPT_RESPONSE	0x8002
+
+#define NS_N_PORT_TYPE	0x01
+#define NS_NL_PORT_TYPE	0x02
+#define NS_NX_PORT_TYPE	0x7F
+
+#define	GA_NXT_CMD	0x100
+#define	GA_NXT_REQ_SIZE	(16 + 4)
+#define	GA_NXT_RSP_SIZE	(16 + 620)
+
+#define	GID_PT_CMD	0x1A1
+#define	GID_PT_REQ_SIZE	(16 + 4)
+#define	GID_PT_RSP_SIZE	(16 + (MAX_FIBRE_DEVICES * 4))
+
+#define	GPN_ID_CMD	0x112
+#define	GPN_ID_REQ_SIZE	(16 + 4)
+#define	GPN_ID_RSP_SIZE	(16 + 8)
+
+#define	GNN_ID_CMD	0x113
+#define	GNN_ID_REQ_SIZE	(16 + 4)
+#define	GNN_ID_RSP_SIZE	(16 + 8)
+
+#define	GFT_ID_CMD	0x117
+#define	GFT_ID_REQ_SIZE	(16 + 4)
+#define	GFT_ID_RSP_SIZE	(16 + 32)
+
+#define	RFT_ID_CMD	0x217
+#define	RFT_ID_REQ_SIZE	(16 + 4 + 32)
+#define	RFT_ID_RSP_SIZE	16
+
+#define	RFF_ID_CMD	0x21F
+#define	RFF_ID_REQ_SIZE	(16 + 4 + 2 + 1 + 1)
+#define	RFF_ID_RSP_SIZE	16
+
+#define	RNN_ID_CMD	0x213
+#define	RNN_ID_REQ_SIZE	(16 + 4 + 8)
+#define	RNN_ID_RSP_SIZE	16
+
+#define	RSNN_NN_CMD	 0x239
+#define	RSNN_NN_REQ_SIZE (16 + 8 + 1 + 255)
+#define	RSNN_NN_RSP_SIZE 16
+
+/* CT command header -- request/response common fields */
+struct ct_cmd_hdr {
+	uint8_t revision;
+	uint8_t in_id[3];
+	uint8_t gs_type;
+	uint8_t gs_subtype;
+	uint8_t options;
+	uint8_t reserved;
+};
+
+/* CT command request */
+struct ct_sns_req {
+	struct ct_cmd_hdr header;
+	uint16_t command;
+	uint16_t max_rsp_size;
+	uint8_t fragment_id;
+	uint8_t reserved[3];
+
+	union {
+		/* GA_NXT, GPN_ID, GNN_ID, GFT_ID */
+		struct {
+			uint8_t reserved;
+			uint8_t port_id[3];
+		} port_id;
+
+		struct {
+			uint8_t port_type;
+			uint8_t domain;
+			uint8_t area;
+			uint8_t reserved;
+		} gid_pt;
+
+		struct {
+			uint8_t reserved;
+			uint8_t port_id[3];
+			uint8_t fc4_types[32];
+		} rft_id;
+
+		struct {
+			uint8_t reserved;
+			uint8_t port_id[3];
+			uint16_t reserved2;
+			uint8_t fc4_feature;
+			uint8_t fc4_type;
+		} rff_id;
+
+		struct {
+			uint8_t reserved;
+			uint8_t port_id[3];
+			uint8_t node_name[8];
+		} rnn_id;
+
+		struct {
+			uint8_t node_name[8];
+			uint8_t name_len;
+			uint8_t sym_node_name[255];
+		} rsnn_nn;
+	} req;
+};
+
+/* CT command response header */
+struct ct_rsp_hdr {
+	struct ct_cmd_hdr header;
+	uint16_t response;
+	uint16_t residual;
+	uint8_t fragment_id;
+	uint8_t reason_code;
+	uint8_t explanation_code;
+	uint8_t vendor_unique;
+};
+
+struct ct_sns_gid_pt_data {
+	uint8_t control_byte;
+	uint8_t port_id[3];
+};
+
+struct ct_sns_rsp {
+	struct ct_rsp_hdr header;
+
+	union {
+		struct {
+			uint8_t port_type;
+			uint8_t port_id[3];
+			uint8_t port_name[8];
+			uint8_t sym_port_name_len;
+			uint8_t sym_port_name[255];
+			uint8_t node_name[8];
+			uint8_t sym_node_name_len;
+			uint8_t sym_node_name[255];
+			uint8_t init_proc_assoc[8];
+			uint8_t node_ip_addr[16];
+			uint8_t class_of_service[4];
+			uint8_t fc4_types[32];
+			uint8_t ip_address[16];
+			uint8_t fabric_port_name[8];
+			uint8_t reserved;
+			uint8_t hard_address[3];
+		} ga_nxt;
+
+		struct {
+			struct ct_sns_gid_pt_data entries[MAX_FIBRE_DEVICES];
+		} gid_pt;
+
+		struct {
+			uint8_t port_name[8];
+		} gpn_id;
+
+		struct {
+			uint8_t node_name[8];
+		} gnn_id;
+
+		struct {
+			uint8_t fc4_types[32];
+		} gft_id;
+	} rsp;
+};
+
+struct ct_sns_pkt {
+	union {
+		struct ct_sns_req req;
+		struct ct_sns_rsp rsp;
+	} p;
+};
+
+
+/* IO descriptors */
+#define MAX_IO_DESCRIPTORS	32
+
+#define ABORT_IOCB_CB		0
+#define ADISC_PORT_IOCB_CB	1
+#define LOGOUT_PORT_IOCB_CB	2
+#define LOGIN_PORT_IOCB_CB	3
+#define LAST_IOCB_CB		4
+
+#define IODESC_INVALID_INDEX	0xFFFF
+#define IODESC_ADISC_NEEDED	0xFFFE
+#define IODESC_LOGIN_NEEDED	0xFFFD
+
+struct io_descriptor {
+	uint16_t used:1;
+	uint16_t idx:11;
+	uint16_t cb_idx:4;
+
+	struct timer_list timer;
+
+	struct scsi_qla_host *ha;
+
+	port_id_t d_id;
+	fc_port_t *remote_fcport;
+
+	uint32_t signature;
+};
+
+/* Mailbox command semaphore queue for command serialization */
+typedef struct _mbx_cmdq_t {
+	struct semaphore	cmd_sem;
+	struct _mbx_cmdq_t	*pnext;
+} mbx_cmdq_t;
+
+struct qla_fw_info {
+	unsigned short addressing;	/* addressing method used to load fw */
+#define FW_INFO_ADDR_NORMAL	0
+#define FW_INFO_ADDR_EXTENDED	1
+#define FW_INFO_ADDR_NOMORE	0xffff
+	unsigned short *fwcode;		/* pointer to FW array */
+	unsigned short *fwlen;		/* number of words in array */
+	unsigned short *fwstart;	/* start address for F/W */
+	unsigned long *lfwstart;	/* start address (long) for F/W */
+};
+
+struct qla_board_info {
+	char *drv_name;
+
+	char isp_name[8];
+	struct qla_fw_info *fw_info;
+};
+
+/*
+ * Linux Host Adapter structure
+ */
+typedef struct scsi_qla_host {
+	struct list_head list;
+
+	/* Commonly used flags and state information. */
+	struct Scsi_Host *host;
+	struct pci_dev	*pdev;
+
+	unsigned long	host_no;
+	unsigned long	instance;
+
+	volatile struct {
+		uint32_t	init_done		:1;
+		uint32_t	online			:1;
+		uint32_t	mbox_int		:1;
+		uint32_t	mbox_busy		:1;
+		uint32_t	rscn_queue_overflow	:1;
+		uint32_t	reset_active		:1;
+
+		uint32_t	management_server_logged_in :1;
+                uint32_t	process_response_queue	:1;
+
+		uint32_t	disable_risc_code_load	:1;
+		uint32_t	enable_64bit_addressing	:1;
+		uint32_t	enable_lip_reset	:1;
+		uint32_t	enable_lip_full_login	:1;
+		uint32_t	enable_target_reset	:1;
+	} flags;
+
+	atomic_t	loop_state;
+#define LOOP_TIMEOUT	1
+#define LOOP_DOWN	2
+#define LOOP_UP		3
+#define LOOP_UPDATE	4
+#define LOOP_READY	5
+#define LOOP_DEAD	6
+
+	unsigned long   dpc_flags;
+#define	RESET_MARKER_NEEDED	0	/* Send marker to ISP. */
+#define	RESET_ACTIVE		1
+#define	ISP_ABORT_NEEDED	2	/* Initiate ISP abort. */
+#define	ABORT_ISP_ACTIVE	3	/* ISP abort in progress. */
+#define	LOOP_RESYNC_NEEDED	4	/* Device Resync needed. */
+#define	LOOP_RESYNC_ACTIVE	5
+#define LOCAL_LOOP_UPDATE       6	/* Perform a local loop update. */
+#define RSCN_UPDATE             7	/* Perform an RSCN update. */
+#define MAILBOX_RETRY           8
+#define ISP_RESET_NEEDED        9	/* Initiate a ISP reset. */
+#define FAILOVER_EVENT_NEEDED   10
+#define FAILOVER_EVENT		11
+#define FAILOVER_NEEDED   	12
+#define SCSI_RESTART_NEEDED	13	/* Processes SCSI retry queue. */
+#define PORT_RESTART_NEEDED	14	/* Processes Retry queue. */
+#define RESTART_QUEUES_NEEDED	15	/* Restarts the Lun queue. */
+#define ABORT_QUEUES_NEEDED	16
+#define RELOGIN_NEEDED	        17
+#define LOGIN_RETRY_NEEDED	18	/* Initiate required fabric logins. */
+#define REGISTER_FC4_NEEDED	19	/* SNS FC4 registration required. */
+#define ISP_ABORT_RETRY         20      /* ISP aborted. */
+#define FCPORT_RESCAN_NEEDED	21      /* IO descriptor processing needed */
+#define IODESC_PROCESS_NEEDED	22      /* IO descriptor processing needed */
+
+	uint32_t	device_flags;
+#define DFLG_LOCAL_DEVICES		BIT_0
+#define DFLG_RETRY_LOCAL_DEVICES	BIT_1
+#define DFLG_FABRIC_DEVICES		BIT_2
+#define	SWITCH_FOUND			BIT_3
+#define	DFLG_NO_CABLE			BIT_4
+
+	/* SRB cache. */
+#define SRB_MIN_REQ	128
+	mempool_t	*srb_mempool;
+
+	/* This spinlock is used to protect "io transactions", you must	
+	 * aquire it before doing any IO to the card, eg with RD_REG*() and
+	 * WRT_REG*() for the duration of your entire commandtransaction.
+	 *
+	 * This spinlock is of lower priority than the io request lock.
+	 */
+
+	spinlock_t		hardware_lock ____cacheline_aligned;
+
+	device_reg_t	*iobase;		/* Base I/O address */
+	unsigned long	pio_address;
+	unsigned long	pio_length;
+	void *		mmio_address;
+	unsigned long	mmio_length;
+#define MIN_IOBASE_LEN		0x100
+
+	/* ISP ring lock, rings, and indexes */
+	dma_addr_t	request_dma;        /* Physical address. */
+	request_t       *request_ring;      /* Base virtual address */
+	request_t       *request_ring_ptr;  /* Current address. */
+	uint16_t        req_ring_index;     /* Current index. */
+	uint16_t        req_q_cnt;          /* Number of available entries. */
+
+	dma_addr_t	response_dma;       /* Physical address. */
+	response_t      *response_ring;     /* Base virtual address */
+	response_t      *response_ring_ptr; /* Current address. */
+	uint16_t        rsp_ring_index;     /* Current index. */
+	uint16_t	response_q_length;
+    
+	uint16_t	(*calc_request_entries)(uint16_t);
+	void		(*build_scsi_iocbs)(srb_t *, cmd_entry_t *, uint16_t);
+
+	/* Outstandings ISP commands. */
+	srb_t		*outstanding_cmds[MAX_OUTSTANDING_COMMANDS];
+	uint32_t	current_outstanding_cmd; 
+	srb_t		*status_srb;	/* Status continuation entry. */
+
+	/*
+	 * Need to hold the list_lock with irq's disabled in order to access
+	 * the following list.
+	 *
+	 * This list_lock is of lower priority than the host_lock.
+	 */
+	spinlock_t		list_lock ____cacheline_aligned;
+						/* lock to guard lists which
+						 * hold srb_t's */
+        struct list_head        retry_queue;    /* watchdog queue */
+        struct list_head        done_queue;     /* job on done queue */
+        struct list_head        failover_queue; /* failover list link. */
+	struct list_head        scsi_retry_queue;     /* SCSI retry queue */
+	struct list_head        pending_queue;	/* SCSI command pending queue */
+
+	unsigned long    done_q_cnt;
+	unsigned long    pending_in_q;
+        uint32_t	retry_q_cnt; 
+        uint32_t	scsi_retry_q_cnt; 
+        uint32_t	failover_cnt; 
+
+	unsigned long	last_irq_cpu;	/* cpu where we got our last irq */
+
+	uint16_t           revision;
+	uint8_t           ports;
+	u_long            actthreads;
+	u_long            ipreq_cnt;
+	u_long            qthreads;
+
+	uint32_t        total_isr_cnt;		/* Interrupt count */
+	uint32_t        total_isp_aborts;	/* controller err cnt */
+	uint32_t        total_lip_cnt;		/* LIP cnt */
+	uint32_t	total_dev_errs;		/* device error cnt */
+	uint32_t	total_ios;		/* IO cnt */
+	uint64_t	total_bytes;		/* xfr byte cnt */
+	uint32_t	total_mbx_timeout;	/* mailbox timeout cnt */
+	uint32_t 	total_loop_resync; 	/* loop resyn cnt */
+	uint32_t	dropped_frame_error_cnt;
+
+	/* ISP configuration data. */
+	uint16_t	loop_id;		/* Host adapter loop id */
+	uint16_t	fb_rev;
+
+	port_id_t	d_id;			/* Host adapter port id */
+	uint16_t	max_public_loop_ids;
+	uint16_t	min_external_loopid;	/* First external loop Id */
+
+	uint8_t		current_topology;
+	uint8_t		prev_topology;
+#define ISP_CFG_NL	1
+#define ISP_CFG_N	2
+#define ISP_CFG_FL	4
+#define ISP_CFG_F	8
+
+	uint8_t		operating_mode;		/* F/W operating mode */
+#define LOOP      0
+#define P2P       1
+#define LOOP_P2P  2
+#define P2P_LOOP  3
+
+	uint8_t		active_fc4_types;	/* Active fc4 types */
+
+	uint8_t		current_speed;		/* F/W operating speed */
+        uint8_t		marker_needed; 
+	uint8_t		sns_retry_cnt;
+	uint8_t		mem_err;
+
+	uint8_t		interrupts_on;
+
+	/* HBA serial number */
+	uint8_t		serial0;
+	uint8_t		serial1;
+	uint8_t		serial2;
+
+	/* NVRAM configuration data */
+	uint16_t	nvram_base;
+
+	uint16_t	loop_reset_delay;
+	uint16_t	minimum_timeout;
+	uint8_t		retry_count;
+	uint8_t		login_timeout;
+	uint16_t	r_a_tov;
+	int		port_down_retry_count;
+	uint8_t		loop_down_timeout;
+	uint8_t		mbx_count;
+	uint16_t	max_probe_luns;
+	uint16_t	max_luns;
+	uint16_t	max_targets;
+	uint16_t	last_loop_id;
+
+        uint32_t	login_retry_count; 
+
+	/* Fibre Channel Device List. */
+	struct list_head	fcports;
+	struct list_head	rscn_fcports;
+
+	struct io_descriptor	io_descriptors[MAX_IO_DESCRIPTORS];
+	uint16_t		iodesc_signature;
+	port_database_t		*iodesc_pd;
+	dma_addr_t		iodesc_pd_dma;
+
+	/* OS target queue pointers. */
+	os_tgt_t		*otgt[MAX_FIBRE_DEVICES];
+
+	/* RSCN queue. */
+	uint32_t rscn_queue[MAX_RSCN_COUNT];
+	uint8_t rscn_in_ptr;
+	uint8_t rscn_out_ptr;
+
+	ms_iocb_entry_t		*ms_iocb;
+	dma_addr_t		ms_iocb_dma;
+	struct ct_sns_pkt	*ct_sns;
+	dma_addr_t		ct_sns_dma;
+
+	pid_t			dpc_pid;
+	int			dpc_should_die;
+	struct completion	dpc_inited;
+	struct completion	dpc_exited;
+	struct semaphore	*dpc_wait;
+	uint8_t dpc_active;                  /* DPC routine is active */
+
+	/* Timeout timers. */
+	uint8_t         queue_restart_timer;   
+	uint8_t         loop_down_abort_time;    /* port down timer */
+	atomic_t        loop_down_timer;         /* loop down timer */
+	uint8_t         link_down_timeout;       /* link down timeout */
+
+	uint32_t        timer_active;
+	struct timer_list        timer;
+
+	/* Firmware Initialization Control Block data */
+	dma_addr_t	init_cb_dma;         /* Physical address. */
+	init_cb_t       *init_cb;
+  
+	/* These are used by mailbox operations. */
+	volatile uint16_t mailbox_out[MAILBOX_REGISTER_COUNT];
+
+	mbx_cmd_t	*mcp;
+	unsigned long	mbx_cmd_flags;
+#define MBX_CMD_ACTIVE	1
+#define MBX_CMD_WANT	2
+#define MBX_INTERRUPT	3
+#define MBX_INTR_WAIT   4
+
+	spinlock_t	mbx_reg_lock;   /* Mbx Cmd Register Lock */
+	spinlock_t	mbx_q_lock;     /* Mbx Active Cmd Queue Lock */
+	spinlock_t	mbx_bits_lock;  /* Mailbox access bits Lock */
+
+	struct semaphore  mbx_intr_sem;  /* Used for completion notification */
+
+	mbx_cmdq_t	*mbx_sem_pool_head;  /* Head Pointer to a list of
+			                      * recyclable mbx semaphore pool
+			                      * to be used during run time.
+			                      */
+	mbx_cmdq_t	*mbx_sem_pool_tail;  /* Tail Pointer to semaphore pool*/
+#define MBQ_INIT_LEN	16 /* initial mbx sem pool q len. actual len may vary */
+
+	mbx_cmdq_t	*mbx_q_head; /* Head Pointer to sem q for active cmds */
+	mbx_cmdq_t	*mbx_q_tail; /* Tail Pointer to sem q for active cmds */
+
+	uint32_t	mbx_flags;
+#define  MBX_IN_PROGRESS	BIT_0
+#define  MBX_BUSY		BIT_1	/* Got the Access */
+#define  MBX_SLEEPING_ON_SEM	BIT_2 
+#define  MBX_POLLING_FOR_COMP	BIT_3
+#define  MBX_COMPLETED		BIT_4
+#define  MBX_TIMEDOUT		BIT_5 
+#define  MBX_ACCESS_TIMEDOUT	BIT_6
+
+	mbx_cmd_t 	mc;
+
+	uint8_t	*cmdline;
+
+	uint32_t failover_type;
+	uint32_t failback_delay;
+	unsigned long   cfg_flags;
+#define	CFG_ACTIVE	0	/* CFG during a failover, event update, or ioctl */
+
+	uint32_t	binding_type;
+#define BIND_BY_PORT_NAME	0
+#define BIND_BY_PORT_ID		1
+
+	/* Basic firmware related information. */
+	struct qla_board_info	*brd_info;
+	uint16_t	fw_major_version;
+	uint16_t	fw_minor_version;
+	uint16_t	fw_subminor_version;
+	uint16_t	fw_attributes;
+	uint32_t	fw_transfer_size;
+
+	uint16_t	fw_options[16];		/* slots: 1,2,3,10,11 */
+	uint8_t		fw_seriallink_options[2];
+
+	/* Firmware dump information. */
+	void		*fw_dump;
+	int		fw_dump_order;
+	int		fw_dump_reading;
+	char		*fw_dump_buffer;
+	int		fw_dump_buffer_len;
+
+	uint8_t		host_str[16];
+	uint16_t	pci_attr;
+	uint16_t	xchg_buf_cnt;
+	uint16_t	iocb_buf_cnt;
+
+	uint8_t model_number[16+1];
+#define BINZERO		"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+	char *model_desc;
+
+/* following are new and needed for IOCTL support */
+#ifdef CONFIG_SCSI_QLA2XXX_IOCTL
+	struct hba_ioctl *ioctl;
+
+	void        *ioctl_mem;
+	dma_addr_t  ioctl_mem_phys;
+	uint32_t    ioctl_mem_size;
+#endif
+	uint8_t     node_name[WWN_SIZE];
+	uint8_t     nvram_version; 
+	uint8_t     optrom_major; 
+	uint8_t     optrom_minor; 
+	uint32_t    isp_abort_cnt;
+
+	/* Adapter I/O statistics for failover */
+	uint64_t	IosRequested;
+	uint64_t	BytesRequested;
+	uint64_t	IosExecuted;
+	uint64_t	BytesExecuted;
+
+	/* Needed for BEACON */
+	uint16_t	beacon_blink_led;
+	uint16_t	beacon_green_on;
+} scsi_qla_host_t;
+
+
+/*
+ * Macros to help code, maintain, etc.
+ */
+#define LOOP_TRANSITION(ha) \
+	(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
+	 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+
+#define LOOP_NOT_READY(ha) \
+	((test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
+	  test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags) || \
+	  test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) || \
+	  test_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) || \
+	 atomic_read(&ha->loop_state) == LOOP_DOWN)
+				 
+#define LOOP_RDY(ha)	(!LOOP_NOT_READY(ha))
+
+#define TGT_Q(ha, t) (ha->otgt[t])
+#define LUN_Q(ha, t, l)	(TGT_Q(ha, t)->olun[l])
+#define GET_LU_Q(ha, t, l) ((TGT_Q(ha,t) != NULL)? TGT_Q(ha, t)->olun[l] : NULL)
+
+#define to_qla_host(x)		((scsi_qla_host_t *) (x)->hostdata)
+
+#define qla_printk(level, ha, format, arg...) \
+	dev_printk(level , &((ha)->pdev->dev) , format , ## arg)
+
+/*
+ * qla2x00 local function return status codes
+ */
+#define MBS_MASK		0x3fff
+
+#define QLA_SUCCESS		(MBS_COMMAND_COMPLETE & MBS_MASK)
+#define QLA_INVALID_COMMAND	(MBS_INVALID_COMMAND & MBS_MASK)
+#define QLA_INTERFACE_ERROR	(MBS_HOST_INTERFACE_ERROR & MBS_MASK)
+#define QLA_TEST_FAILED		(MBS_TEST_FAILED & MBS_MASK)
+#define QLA_COMMAND_ERROR	(MBS_COMMAND_ERROR & MBS_MASK)
+#define QLA_PARAMETER_ERROR	(MBS_COMMAND_PARAMETER_ERROR & MBS_MASK)
+#define QLA_PORT_ID_USED	(MBS_PORT_ID_USED & MBS_MASK)
+#define QLA_LOOP_ID_USED	(MBS_LOOP_ID_USED & MBS_MASK)
+#define QLA_ALL_IDS_IN_USE	(MBS_ALL_IDS_IN_USE & MBS_MASK)
+#define QLA_NOT_LOGGED_IN	(MBS_NOT_LOGGED_IN & MBS_MASK)
+
+#define QLA_FUNCTION_TIMEOUT		0x100
+#define QLA_FUNCTION_PARAMETER_ERROR	0x101
+#define QLA_FUNCTION_FAILED		0x102
+#define QLA_MEMORY_ALLOC_FAILED		0x103
+#define QLA_LOCK_TIMEOUT		0x104
+#define QLA_ABORTED			0x105
+#define QLA_SUSPENDED			0x106
+#define QLA_BUSY			0x107
+#define QLA_RSCNS_HANDLED		0x108
+
+/*
+* Stat info for all adpaters
+*/
+struct _qla2x00stats  {
+        unsigned long   mboxtout;            /* mailbox timeouts */
+        unsigned long   mboxerr;             /* mailbox errors */
+        unsigned long   ispAbort;            /* ISP aborts */
+        unsigned long   debugNo;
+        unsigned long   loop_resync;
+        unsigned long   outarray_full;
+        unsigned long   retry_q_cnt;
+};
+
+#define NVRAM_DELAY()		udelay(10)
+
+#define INVALID_HANDLE	(MAX_OUTSTANDING_COMMANDS+1)
+
+/*
+ * Flash support definitions
+ */
+#define FLASH_IMAGE_SIZE	131072
+
+#include "qla_gbl.h"
+#include "qla_dbg.h"
+#include "qla_inline.h"
+#include "qla_listops.h"
+
+#endif
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_devtbl.h linux-2.5/drivers/scsi/qla2xxx/qla_devtbl.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_devtbl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_devtbl.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,65 @@
+#define QLA_MODEL_NAMES         0x1B
+
+/*
+ * Adapter model names.
+ */
+char	*qla2x00_model_name[QLA_MODEL_NAMES] = {
+	"QLA2340",	/* 0x100 */
+	"QLA2342",	/* 0x101 */
+	"QLA2344",	/* 0x102 */
+	"QCP2342",	/* 0x103 */
+	"QSB2340",	/* 0x104 */
+	"QSB2342",	/* 0x105 */
+	"QLA2310",	/* 0x106 */
+	"QLA2332",	/* 0x107 */
+	"QCP2332",	/* 0x108 */
+	"QCP2340",	/* 0x109 */
+	"QLA2342",	/* 0x10a */
+	"QCP2342",	/* 0x10b */
+	"QLA2350",	/* 0x10c */
+	"QLA2352",	/* 0x10d */
+	"QLA2352",	/* 0x10e */
+	"HPQSVS ",	/* 0x10f */
+	"HPQSVS ",	/* 0x110 */
+	"QLA4010",	/* 0x111 */
+	"QLA4010",	/* 0x112 */
+	"QLA4010C",	/* 0x113 */
+	"QLA4010C",	/* 0x114 */
+	"QLA2360",	/* 0x115 */
+	"QLA2362",	/* 0x116 */
+	" ",		/* 0x117 */
+	" ",		/* 0x118 */
+	"QLA200",	/* 0x119 */
+	"QLA200C"	/* 0x11A */
+};
+
+char	*qla2x00_model_desc[QLA_MODEL_NAMES] = {
+	"133MHz PCI-X to 2Gb FC, Single Channel",	/* 0x100 */
+	"133MHz PCI-X to 2Gb FC, Dual Channel",		/* 0x101 */
+	"133MHz PCI-X to 2Gb FC, Quad Channel",		/* 0x102 */
+	" ",						/* 0x103 */
+	" ",						/* 0x104 */
+	" ",						/* 0x105 */
+	" ",						/* 0x106 */
+	" ",						/* 0x107 */
+	" ",						/* 0x108 */
+	" ",						/* 0x109 */
+	" ",						/* 0x10a */
+	" ",						/* 0x10b */
+	"133MHz PCI-X to 2Gb FC, Single Channel",	/* 0x10c */
+	"133MHz PCI-X to 2Gb FC, Dual Channel",		/* 0x10d */
+	" ",						/* 0x10e */
+	"HPQ SVS HBA- Initiator device",		/* 0x10f */
+	"HPQ SVS HBA- Target device",			/* 0x110 */
+	"Optical- 133MHz to 1Gb iSCSI- networking",	/* 0x111 */
+	"Optical- 133MHz to 1Gb iSCSI- storage",	/* 0x112 */
+	"Copper- 133MHz to 1Gb iSCSI- networking",	/* 0x113 */
+	"Copper- 133MHz to 1Gb iSCSI- storage",		/* 0x114 */
+	"133MHz PCI-X to 2Gb FC Single Channel",	/* 0x115 */
+	"133MHz PCI-X to 2Gb FC Dual Channel",		/* 0x116 */
+	" ",						/* 0x117 */
+	" ",						/* 0x118 */
+	"133MHz PCI-X to 2Gb FC Optical",		/* 0x119 */
+	"133MHz PCI-X to 2Gb FC Copper"			/* 0x11A */
+};
+
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_gbl.h linux-2.5/drivers/scsi/qla2xxx/qla_gbl.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_gbl.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_gbl.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,327 @@
+/********************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic ISP2x00 device driver for Linux 2.6.x
+* Copyright (C) 2003 QLogic Corporation
+* (www.qlogic.com)
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************
+* Global include file.
+******************************************************************************/
+
+
+#ifndef __QLA_GBL_H
+#define	__QLA_GBL_H
+
+extern void qla2x00_remove_one(struct pci_dev *);
+extern int qla2x00_probe_one(struct pci_dev *, struct qla_board_info *);
+
+/*
+ * Global Function Prototypes in qla_init.c source file.
+ */
+extern int qla2x00_initialize_adapter(scsi_qla_host_t *);
+extern fc_port_t *qla2x00_alloc_fcport(scsi_qla_host_t *, int);
+
+extern int qla2x00_loop_resync(scsi_qla_host_t *);
+
+extern int qla2x00_find_new_loop_id(scsi_qla_host_t *, fc_port_t *);
+extern int qla2x00_fabric_login(scsi_qla_host_t *, fc_port_t *, uint16_t *);
+extern int qla2x00_local_device_login(scsi_qla_host_t *, uint16_t);
+
+extern void qla2x00_restart_queues(scsi_qla_host_t *, uint8_t);
+
+extern void qla2x00_rescan_fcports(scsi_qla_host_t *);
+
+extern void qla2x00_tgt_free(scsi_qla_host_t *ha, uint16_t t);
+extern os_tgt_t *qla2x00_tgt_alloc(scsi_qla_host_t *, uint16_t);
+extern os_lun_t * qla2x00_lun_alloc(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern int qla2x00_abort_isp(scsi_qla_host_t *);
+
+
+/*
+ * Global Data in qla_os.c source file.
+ */
+extern char qla2x00_version_str[];
+
+extern int num_hosts;
+extern int apiHBAInstance;
+
+extern struct _qla2x00stats qla2x00_stats;
+extern int ql2xretrycount;
+extern int ql2xlogintimeout;
+extern int qlport_down_retry;
+extern int ql2xmaxqdepth;
+extern int displayConfig;
+extern int ql2xplogiabsentdevice;
+extern int ql2xintrdelaytimer;
+
+extern int ConfigRequired;
+
+extern int Bind;
+extern int ql2xsuspendcount;
+#if defined(MODULE)
+extern char *ql2xopts;
+#endif
+extern struct list_head qla_hostlist;
+extern rwlock_t qla_hostlist_lock;
+
+extern char *qla2x00_get_fw_version_str(struct scsi_qla_host *, char *);
+
+extern int qla2x00_queuecommand(struct scsi_cmnd *,
+    void (*)(struct scsi_cmnd *));
+
+extern int __qla2x00_suspend_lun(scsi_qla_host_t *, os_lun_t *, int, int, int);
+
+extern void qla2x00_done(scsi_qla_host_t *);
+extern void qla2x00_next(scsi_qla_host_t *);
+extern void qla2x00_flush_failover_q(scsi_qla_host_t *, os_lun_t *);
+extern void qla2x00_reset_lun_fo_counts(scsi_qla_host_t *, os_lun_t *);
+
+extern int qla2x00_check_tgt_status(scsi_qla_host_t *, struct scsi_cmnd *);
+extern int qla2x00_check_port_status(scsi_qla_host_t *, fc_port_t *);
+
+extern void qla2x00_extend_timeout(struct scsi_cmnd *, int);
+extern srb_t * qla2x00_get_new_sp (scsi_qla_host_t *ha);
+
+extern void qla2x00_mark_device_lost(scsi_qla_host_t *, fc_port_t *, int);
+extern void qla2x00_mark_all_devices_lost(scsi_qla_host_t *);
+
+extern int qla2x00_get_prop_xstr(scsi_qla_host_t *, char *, uint8_t *, int);
+
+extern void qla2x00_abort_queues(scsi_qla_host_t *, uint8_t);
+
+extern void qla2x00_blink_led(scsi_qla_host_t *);
+
+/*
+ * Global Function Prototypes in qla_iocb.c source file.
+ */
+extern request_t *qla2x00_req_pkt(scsi_qla_host_t *);
+extern request_t *qla2x00_ms_req_pkt(scsi_qla_host_t *, srb_t *);
+extern void qla2x00_isp_cmd(scsi_qla_host_t *);
+
+extern uint16_t qla2x00_calc_iocbs_32(uint16_t);
+extern uint16_t qla2x00_calc_iocbs_64(uint16_t);
+extern void qla2x00_build_scsi_iocbs_32(srb_t *, cmd_entry_t *, uint16_t);
+extern void qla2x00_build_scsi_iocbs_64(srb_t *, cmd_entry_t *, uint16_t);
+extern int qla2x00_start_scsi(srb_t *sp);
+int qla2x00_marker(scsi_qla_host_t *, uint16_t, uint16_t, uint8_t);
+int __qla2x00_marker(scsi_qla_host_t *, uint16_t, uint16_t, uint8_t);
+
+/*
+ * Global Function Prototypes in qla_mbx.c source file.
+ */
+extern int
+qla2x00_mailbox_command(scsi_qla_host_t *, mbx_cmd_t *);
+
+extern int
+qla2x00_load_ram(scsi_qla_host_t *, dma_addr_t, uint16_t, uint16_t);
+
+extern int
+qla2x00_load_ram_ext(scsi_qla_host_t *, dma_addr_t, uint32_t, uint16_t);
+
+extern int
+qla2x00_execute_fw(scsi_qla_host_t *);
+
+extern void
+qla2x00_get_fw_version(scsi_qla_host_t *, uint16_t *,
+    uint16_t *, uint16_t *, uint16_t *);
+
+extern int
+qla2x00_get_fw_options(scsi_qla_host_t *, uint16_t *);
+
+extern int
+qla2x00_set_fw_options(scsi_qla_host_t *, uint16_t *);
+
+extern int
+qla2x00_read_ram_word(scsi_qla_host_t *, uint16_t, uint16_t *);
+extern int
+qla2x00_write_ram_word(scsi_qla_host_t *, uint16_t, uint16_t);
+extern int
+qla2x00_write_ram_word_ext(scsi_qla_host_t *, uint32_t, uint16_t);
+
+extern int
+qla2x00_mbx_reg_test(scsi_qla_host_t *);
+
+extern int
+qla2x00_verify_checksum(scsi_qla_host_t *);
+
+extern int
+qla2x00_issue_iocb(scsi_qla_host_t *, void *, dma_addr_t, size_t);
+
+extern int
+qla2x00_abort_command(scsi_qla_host_t *, srb_t *);
+
+extern int
+qla2x00_abort_device(scsi_qla_host_t *, uint16_t, uint16_t);
+
+#if USE_ABORT_TGT
+extern int
+qla2x00_abort_target(fc_port_t *fcport);
+#endif
+
+extern int
+qla2x00_target_reset(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern int
+qla2x00_get_adapter_id(scsi_qla_host_t *, uint16_t *, uint8_t *, uint8_t *,
+    uint8_t *, uint16_t *);
+
+extern int
+qla2x00_get_retry_cnt(scsi_qla_host_t *, uint8_t *, uint8_t *, uint16_t *);
+
+extern int
+qla2x00_init_firmware(scsi_qla_host_t *, uint16_t);
+
+extern int
+qla2x00_get_port_database(scsi_qla_host_t *, fc_port_t *, uint8_t);
+
+extern int
+qla2x00_get_firmware_state(scsi_qla_host_t *, uint16_t *);
+
+extern int
+qla2x00_get_port_name(scsi_qla_host_t *, uint16_t, uint8_t *, uint8_t);
+
+extern uint8_t
+qla2x00_get_link_status(scsi_qla_host_t *, uint8_t, void *, uint16_t *);
+
+extern int
+qla2x00_lip_reset(scsi_qla_host_t *);
+
+extern int
+qla2x00_send_sns(scsi_qla_host_t *, dma_addr_t, uint16_t, size_t);
+
+extern int
+qla2x00_login_fabric(scsi_qla_host_t *, uint16_t, uint8_t, uint8_t, uint8_t,
+    uint16_t *, uint8_t);
+
+extern int
+qla2x00_login_local_device(scsi_qla_host_t *, uint16_t, uint16_t *, uint8_t);
+
+extern int
+qla2x00_fabric_logout(scsi_qla_host_t *ha, uint16_t loop_id);
+
+extern int
+qla2x00_full_login_lip(scsi_qla_host_t *ha);
+
+extern int
+qla2x00_get_id_list(scsi_qla_host_t *, void *, dma_addr_t, uint16_t *);
+
+#if 0 /* not yet needed */
+extern int
+qla2x00_dump_ram(scsi_qla_host_t *, uint32_t, dma_addr_t, uint32_t);
+#endif
+
+extern int
+qla2x00_lun_reset(scsi_qla_host_t *, uint16_t, uint16_t);
+
+extern int
+qla2x00_send_rnid_mbx(scsi_qla_host_t *, uint16_t, uint8_t, dma_addr_t,
+    size_t, uint16_t *);
+
+extern int
+qla2x00_set_rnid_params_mbx(scsi_qla_host_t *, dma_addr_t, size_t, uint16_t *);
+
+extern int
+qla2x00_get_rnid_params_mbx(scsi_qla_host_t *, dma_addr_t, size_t, uint16_t *);
+
+extern int
+qla2x00_get_resource_cnts(scsi_qla_host_t *, uint16_t *, uint16_t *, uint16_t *,
+    uint16_t *);
+
+#if defined(QL_DEBUG_LEVEL_3)
+extern int
+qla2x00_get_fcal_position_map(scsi_qla_host_t *ha, char *pos_map);
+#endif
+
+/*
+ * Global Function Prototypes in qla_isr.c source file.
+ */
+extern irqreturn_t qla2x00_intr_handler(int, void *, struct pt_regs *);
+extern void qla2x00_process_response_queue(struct scsi_qla_host *);
+
+/*
+ * Global Function Prototypes in qla_sup.c source file.
+ */
+extern void qla2x00_lock_nvram_access(scsi_qla_host_t *);
+extern void qla2x00_unlock_nvram_access(scsi_qla_host_t *);
+extern uint16_t qla2x00_get_nvram_word(scsi_qla_host_t *, uint32_t);
+extern void qla2x00_write_nvram_word(scsi_qla_host_t *, uint32_t, uint16_t);
+extern void qla2x00_flash_enable(scsi_qla_host_t *);
+extern void qla2x00_flash_disable(scsi_qla_host_t *);
+extern uint8_t qla2x00_read_flash_byte(scsi_qla_host_t *, uint32_t);
+extern uint8_t qla2x00_get_flash_manufacturer(scsi_qla_host_t *);
+extern uint16_t qla2x00_get_flash_version(scsi_qla_host_t *);
+extern uint16_t qla2x00_get_flash_image(scsi_qla_host_t *, uint8_t *);
+extern uint16_t qla2x00_set_flash_image(scsi_qla_host_t *, uint8_t *);
+
+/*
+ * Global Function Prototypes in qla_dbg.c source file.
+ */
+extern void qla2100_fw_dump(scsi_qla_host_t *, int);
+extern void qla2300_fw_dump(scsi_qla_host_t *, int);
+extern void qla2100_ascii_fw_dump(scsi_qla_host_t *);
+extern void qla2300_ascii_fw_dump(scsi_qla_host_t *);
+extern void qla2x00_dump_regs(scsi_qla_host_t *);
+extern void qla2x00_dump_buffer(uint8_t *, uint32_t);
+extern void qla2x00_print_scsi_cmd(struct scsi_cmnd *);
+extern void qla2x00_print_q_info(struct os_lun *);
+
+/*
+ * Global Function Prototypes in qla_ip.c source file.
+ */
+extern int qla2x00_ip_initialize(scsi_qla_host_t *);
+extern int qla2x00_update_ip_device_data(scsi_qla_host_t *, fc_port_t *);
+extern void qla2x00_ip_send_complete(scsi_qla_host_t *, uint32_t, uint16_t);
+extern void qla2x00_ip_receive(scsi_qla_host_t *, sts_entry_t *);
+extern void qla2x00_ip_receive_fastpost(scsi_qla_host_t *, uint16_t);
+extern void qla2x00_ip_mailbox_iocb_done(scsi_qla_host_t *, struct mbx_entry *);
+
+/*
+ * Global Function Prototypes in qla_gs.c source file.
+ */
+extern int qla2x00_ga_nxt(scsi_qla_host_t *, fc_port_t *);
+extern int qla2x00_gid_pt(scsi_qla_host_t *, sw_info_t *);
+extern int qla2x00_gpn_id(scsi_qla_host_t *, sw_info_t *);
+extern int qla2x00_gnn_id(scsi_qla_host_t *, sw_info_t *);
+extern int qla2x00_gft_id(scsi_qla_host_t *, sw_info_t *);
+extern int qla2x00_rft_id(scsi_qla_host_t *);
+extern int qla2x00_rff_id(scsi_qla_host_t *);
+extern int qla2x00_rnn_id(scsi_qla_host_t *);
+extern int qla2x00_rsnn_nn(scsi_qla_host_t *);
+
+/*
+ * Global Function Prototypes in qla_rscn.c source file.
+ */
+extern fc_port_t *qla2x00_alloc_rscn_fcport(scsi_qla_host_t *, int);
+extern int qla2x00_handle_port_rscn(scsi_qla_host_t *, uint32_t, fc_port_t *,
+    int);
+extern void qla2x00_process_iodesc(scsi_qla_host_t *, struct mbx_entry *);
+extern void qla2x00_cancel_io_descriptors(scsi_qla_host_t *);
+
+/*
+ * Global Function Prototypes in qla_xioctl.c source file.
+ */
+#ifdef CONFIG_SCSI_QLA2XXX_IOCTL
+extern void qla2x00_enqueue_aen(scsi_qla_host_t *, uint16_t, void *);
+extern int qla2x00_alloc_ioctl_mem(scsi_qla_host_t *);
+extern void qla2x00_free_ioctl_mem(scsi_qla_host_t *);
+extern int qla2x00_get_ioctl_scrap_mem(scsi_qla_host_t *, void **, uint32_t);
+extern void qla2x00_free_ioctl_scrap_mem(scsi_qla_host_t *);
+#else
+#define qla2x00_enqueue_aen(ha, cmd, mode)	do { } while (0)
+#define qla2x00_alloc_ioctl_mem(ha)		(0)
+#define qla2x00_free_ioctl_mem(ha)		do { } while (0)
+#endif
+
+#endif /* _QLA_GBL_H */
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_gs.c linux-2.5/drivers/scsi/qla2xxx/qla_gs.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_gs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_gs.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,681 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#include "qla_os.h"
+
+#include "qla_def.h"
+
+/* XXX(hch): this is ugly, but we don't want to pull in exioctl.h */
+#ifndef EXT_DEF_FC4_TYPE_SCSI
+#define EXT_DEF_FC4_TYPE_SCSI		0x1
+#endif
+
+static inline ms_iocb_entry_t *
+qla2x00_prep_ms_iocb(scsi_qla_host_t *, uint32_t, uint32_t);
+
+static inline struct ct_sns_req *
+qla2x00_prep_ct_req(struct ct_sns_req *, uint16_t, uint16_t);
+
+/**
+ * qla2x00_prep_ms_iocb() - Prepare common MS IOCB fields for SNS CT query.
+ * @ha: HA context
+ * @req_size: request size in bytes
+ * @rsp_size: response size in bytes
+ *
+ * Returns a pointer to the @ha's ms_iocb.
+ */
+static inline ms_iocb_entry_t *
+qla2x00_prep_ms_iocb(scsi_qla_host_t *ha, uint32_t req_size, uint32_t rsp_size)
+{
+	ms_iocb_entry_t *ms_pkt;
+
+	ms_pkt = ha->ms_iocb;
+	memset(ms_pkt, 0, sizeof(ms_iocb_entry_t));
+
+	ms_pkt->entry_type = MS_IOCB_TYPE;
+	ms_pkt->entry_count = 1;
+	SET_TARGET_ID(ha, ms_pkt->loop_id, SIMPLE_NAME_SERVER);
+	ms_pkt->control_flags = __constant_cpu_to_le16(CF_READ | CF_HEAD_TAG);
+	ms_pkt->timeout = __constant_cpu_to_le16(25);
+	ms_pkt->cmd_dsd_count = __constant_cpu_to_le16(1);
+	ms_pkt->total_dsd_count = __constant_cpu_to_le16(2);
+	ms_pkt->rsp_bytecount = cpu_to_le32(rsp_size);
+	ms_pkt->req_bytecount = cpu_to_le32(req_size);
+
+	ms_pkt->dseg_req_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));
+	ms_pkt->dseg_req_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));
+	ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
+
+	ms_pkt->dseg_rsp_address[0] = cpu_to_le32(LSD(ha->ct_sns_dma));
+	ms_pkt->dseg_rsp_address[1] = cpu_to_le32(MSD(ha->ct_sns_dma));
+	ms_pkt->dseg_rsp_length = ms_pkt->rsp_bytecount;
+
+	return (ms_pkt);
+}
+
+/**
+ * qla2x00_prep_ct_req() - Prepare common CT request fields for SNS query.
+ * @ct_req: CT request buffer
+ * @cmd: GS command
+ * @rsp_size: response size in bytes
+ *
+ * Returns a pointer to the intitialized @ct_req.
+ */
+static inline struct ct_sns_req *
+qla2x00_prep_ct_req(struct ct_sns_req *ct_req, uint16_t cmd, uint16_t rsp_size)
+{
+	memset(ct_req, 0, sizeof(struct ct_sns_pkt));
+
+	ct_req->header.revision = 0x01;
+	ct_req->header.gs_type = 0xFC;
+	ct_req->header.gs_subtype = 0x02;
+	ct_req->command = cpu_to_be16(cmd);
+	ct_req->max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);
+
+	return (ct_req);
+}
+
+/**
+ * qla2x00_ga_nxt() - SNS scan for fabric devices via GA_NXT command.
+ * @ha: HA context
+ * @fcport: fcport entry to updated
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_ga_nxt(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	int		rval;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	/* Issue GA_NXT */
+	/* Prepare common MS IOCB */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, GA_NXT_REQ_SIZE, GA_NXT_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, GA_NXT_CMD,
+	    GA_NXT_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- port_id */
+	ct_req->req.port_id.port_id[0] = fcport->d_id.b.domain;
+	ct_req->req.port_id.port_id[1] = fcport->d_id.b.area;
+	ct_req->req.port_id.port_id[2] = fcport->d_id.b.al_pa;
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): GA_NXT issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): GA_NXT failed, rejected request, "
+		    "ga_nxt_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		/* Populate fc_port_t entry. */
+		fcport->d_id.b.domain = ct_rsp->rsp.ga_nxt.port_id[0];
+		fcport->d_id.b.area = ct_rsp->rsp.ga_nxt.port_id[1];
+		fcport->d_id.b.al_pa = ct_rsp->rsp.ga_nxt.port_id[2];
+
+		memcpy(fcport->node_name, ct_rsp->rsp.ga_nxt.node_name,
+		    WWN_SIZE);
+		memcpy(fcport->port_name, ct_rsp->rsp.ga_nxt.port_name,
+		    WWN_SIZE);
+
+		if (ct_rsp->rsp.ga_nxt.port_type != NS_N_PORT_TYPE &&
+		    ct_rsp->rsp.ga_nxt.port_type != NS_NL_PORT_TYPE)
+			fcport->d_id.b.domain = 0xf0;
+
+		DEBUG2_3(printk("scsi(%ld): GA_NXT entry - "
+		    "nn %02x%02x%02x%02x%02x%02x%02x%02x "
+		    "pn %02x%02x%02x%02x%02x%02x%02x%02x "
+		    "portid=%02x%02x%02x.\n",
+		    ha->host_no,
+		    fcport->node_name[0], fcport->node_name[1],
+		    fcport->node_name[2], fcport->node_name[3],
+		    fcport->node_name[4], fcport->node_name[5],
+		    fcport->node_name[6], fcport->node_name[7],
+		    fcport->port_name[0], fcport->port_name[1],
+		    fcport->port_name[2], fcport->port_name[3],
+		    fcport->port_name[4], fcport->port_name[5],
+		    fcport->port_name[6], fcport->port_name[7],
+		    fcport->d_id.b.domain, fcport->d_id.b.area,
+		    fcport->d_id.b.al_pa));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_gid_pt() - SNS scan for fabric devices via GID_PT command.
+ * @ha: HA context
+ * @list: switch info entries to populate
+ *
+ * NOTE: Non-Nx_Ports are not requested.
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_gid_pt(scsi_qla_host_t *ha, sw_info_t *list)
+{
+	int		rval;
+	uint16_t	i;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	struct ct_sns_gid_pt_data *gid_data;
+
+	gid_data = NULL;
+
+	/* Issue GID_PT */
+	/* Prepare common MS IOCB */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, GID_PT_REQ_SIZE, GID_PT_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, GID_PT_CMD,
+	    GID_PT_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- port_type */
+	ct_req->req.gid_pt.port_type = NS_NX_PORT_TYPE;
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): GID_PT issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): GID_PT failed, rejected request, "
+		    "gid_pt_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		/* Set port IDs in switch info list. */
+		for (i = 0; i < MAX_FIBRE_DEVICES; i++) {
+			gid_data = &ct_rsp->rsp.gid_pt.entries[i];
+			list[i].d_id.b.domain = gid_data->port_id[0];
+			list[i].d_id.b.area = gid_data->port_id[1];
+			list[i].d_id.b.al_pa = gid_data->port_id[2];
+
+			/* Last one exit. */
+			if (gid_data->control_byte & BIT_7) {
+				list[i].d_id.b.rsvd_1 = gid_data->control_byte;
+				break;
+			}
+		}
+
+		/*
+		 * If we've used all available slots, then the switch is
+		 * reporting back more devices that we can handle with this
+		 * single call.  Return a failed status, and let GA_NXT handle
+		 * the overload.
+		 */
+		if (i == MAX_FIBRE_DEVICES) 
+			rval = QLA_FUNCTION_FAILED;
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_gpn_id() - SNS Get Port Name (GPN_ID) query.
+ * @ha: HA context
+ * @list: switch info entries to populate
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_gpn_id(scsi_qla_host_t *ha, sw_info_t *list)
+{
+	int		rval;
+	uint16_t	i;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	for (i = 0; i < MAX_FIBRE_DEVICES; i++) {
+		/* Issue GPN_ID */
+		/* Prepare common MS IOCB */
+		ms_pkt = qla2x00_prep_ms_iocb(ha, GPN_ID_REQ_SIZE,
+		    GPN_ID_RSP_SIZE);
+
+		/* Prepare CT request */
+		ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, GPN_ID_CMD,
+		    GPN_ID_RSP_SIZE);
+		ct_rsp = &ha->ct_sns->p.rsp;
+
+		/* Prepare CT arguments -- port_id */
+		ct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;
+		ct_req->req.port_id.port_id[1] = list[i].d_id.b.area;
+		ct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;
+
+		/* Execute MS IOCB */
+		rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+		    sizeof(ms_iocb_entry_t));
+		if (rval != QLA_SUCCESS) {
+			/*EMPTY*/
+			DEBUG2_3(printk("scsi(%ld): GPN_ID issue IOCB failed "
+			    "(%d).\n", ha->host_no, rval));
+		} else if (ct_rsp->header.response !=
+		    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+			DEBUG2_3(printk("scsi(%ld): GPN_ID failed, rejected "
+			    "request, gpn_id_rsp:\n", ha->host_no));
+			DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+			    sizeof(struct ct_rsp_hdr)));
+			rval = QLA_FUNCTION_FAILED;
+		} else {
+			/* Save portname */
+			memcpy(list[i].port_name,
+			    ct_rsp->rsp.gpn_id.port_name, WWN_SIZE);
+		}
+
+		/* Last device exit. */
+		if (list[i].d_id.b.rsvd_1 != 0)
+			break;
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_gnn_id() - SNS Get Node Name (GPN_ID) query.
+ * @ha: HA context
+ * @list: switch info entries to populate
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_gnn_id(scsi_qla_host_t *ha, sw_info_t *list)
+{
+	int		rval;
+	uint16_t	i;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	for (i = 0; i < MAX_FIBRE_DEVICES; i++) {
+		/* Issue GNN_ID */
+		/* Prepare common MS IOCB */
+		ms_pkt = qla2x00_prep_ms_iocb(ha, GNN_ID_REQ_SIZE,
+		    GNN_ID_RSP_SIZE);
+
+		/* Prepare CT request */
+		ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, GNN_ID_CMD,
+		    GNN_ID_RSP_SIZE);
+		ct_rsp = &ha->ct_sns->p.rsp;
+
+		/* Prepare CT arguments -- port_id */
+		ct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;
+		ct_req->req.port_id.port_id[1] = list[i].d_id.b.area;
+		ct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;
+
+		/* Execute MS IOCB */
+		rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+		    sizeof(ms_iocb_entry_t));
+		if (rval != QLA_SUCCESS) {
+			/*EMPTY*/
+			DEBUG2_3(printk("scsi(%ld): GNN_ID issue IOCB failed "
+			    "(%d).\n", ha->host_no, rval));
+		} else if (ct_rsp->header.response !=
+		    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+			DEBUG2_3(printk("scsi(%ld): GNN_ID failed, rejected "
+			    "request, gnn_id_rsp:\n", ha->host_no));
+			DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+			    sizeof(struct ct_rsp_hdr)));
+			rval = QLA_FUNCTION_FAILED;
+		} else {
+			/* Save nodename */
+			memcpy(list[i].node_name,
+			    ct_rsp->rsp.gnn_id.node_name, WWN_SIZE);
+
+			DEBUG2_3(printk("scsi(%ld): GID_PT entry - "
+			    "nn %02x%02x%02x%02x%02x%02x%02x%02x "
+			    "pn %02x%02x%02x%02x%02x%02x%02x%02x "
+			    "portid=%02x%02x%02x.\n",
+			    ha->host_no,
+			    list[i].node_name[0], list[i].node_name[1],
+			    list[i].node_name[2], list[i].node_name[3],
+			    list[i].node_name[4], list[i].node_name[5],
+			    list[i].node_name[6], list[i].node_name[7],
+			    list[i].port_name[0], list[i].port_name[1],
+			    list[i].port_name[2], list[i].port_name[3],
+			    list[i].port_name[4], list[i].port_name[5],
+			    list[i].port_name[6], list[i].port_name[7],
+			    list[i].d_id.b.domain, list[i].d_id.b.area,
+			    list[i].d_id.b.al_pa));
+		}
+
+		/* Last device exit. */
+		if (list[i].d_id.b.rsvd_1 != 0)
+			break;
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_gft_id() - SNS Get FC-4 TYPEs (GFT_ID) query.
+ * @ha: HA context
+ * @list: switch info entries to populate
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_gft_id(scsi_qla_host_t *ha, sw_info_t *list)
+{
+	int		rval;
+	uint16_t	i;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	for (i = 0; i < MAX_FIBRE_DEVICES; i++) {
+		/* Issue GFT_ID */
+		/* Prepare common MS IOCB */
+		ms_pkt = qla2x00_prep_ms_iocb(ha, GFT_ID_REQ_SIZE,
+		    GFT_ID_RSP_SIZE);
+
+		/* Prepare CT request */
+		ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, GFT_ID_CMD,
+		    GFT_ID_RSP_SIZE);
+		ct_rsp = &ha->ct_sns->p.rsp;
+
+		/* Prepare CT arguments -- port_id */
+		ct_req->req.port_id.port_id[0] = list[i].d_id.b.domain;
+		ct_req->req.port_id.port_id[1] = list[i].d_id.b.area;
+		ct_req->req.port_id.port_id[2] = list[i].d_id.b.al_pa;
+
+		/* Execute MS IOCB */
+		rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+		    sizeof(ms_iocb_entry_t));
+		if (rval != QLA_SUCCESS) {
+			/*EMPTY*/
+			DEBUG2_3(printk("scsi(%ld): GFT_ID issue IOCB failed "
+			    "(%d).\n", ha->host_no, rval));
+		} else if (ct_rsp->header.response !=
+		    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+			DEBUG2_3(printk("scsi(%ld): GFT_ID failed, rejected "
+			    "request, gft_id_rsp:\n", ha->host_no));
+			DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+			    sizeof(struct ct_rsp_hdr)));
+			rval = QLA_FUNCTION_FAILED;
+		} else {
+			/* FCP-3 check necessary?  No, assume FCP-3 */
+			/*if (ct_rsp->rsp.gft_id.fc4_types[2] & 0x01)*/
+			list[i].type = SW_TYPE_SCSI;
+			if (ct_rsp->rsp.gft_id.fc4_types[3] & 0x20)
+				list[i].type |= SW_TYPE_IP;
+		}
+
+		/* Last device exit. */
+		if (list[i].d_id.b.rsvd_1 != 0)
+			break;
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_rft_id() - SNS Register FC-4 TYPEs (RFT_ID) supported by the HBA.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_rft_id(scsi_qla_host_t *ha)
+{
+	int		rval;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	/* Issue RFT_ID */
+	/* Prepare common MS IOCB */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, RFT_ID_REQ_SIZE, RFT_ID_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, RFT_ID_CMD,
+	    RFT_ID_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- port_id, FC-4 types */
+	ct_req->req.rft_id.port_id[0] = ha->d_id.b.domain;
+	ct_req->req.rft_id.port_id[1] = ha->d_id.b.area;
+	ct_req->req.rft_id.port_id[2] = ha->d_id.b.al_pa;
+
+	ct_req->req.rft_id.fc4_types[2] = 0x01;		/* FCP-3 */
+	ha->active_fc4_types = EXT_DEF_FC4_TYPE_SCSI;
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): RFT_ID issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): RFT_ID failed, rejected "
+		    "request, rft_id_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		DEBUG2(printk("scsi(%ld): RFT_ID exiting normally.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_rff_id() - SNS Register FC-4 Features (RFF_ID) supported by the HBA.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_rff_id(scsi_qla_host_t *ha)
+{
+	int		rval;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	/* Issue RFF_ID */
+	/* Prepare common MS IOCB */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, RFF_ID_REQ_SIZE, RFF_ID_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, RFF_ID_CMD,
+	    RFF_ID_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- port_id, FC-4 feature, FC-4 type */
+	ct_req->req.rff_id.port_id[0] = ha->d_id.b.domain;
+	ct_req->req.rff_id.port_id[1] = ha->d_id.b.area;
+	ct_req->req.rff_id.port_id[2] = ha->d_id.b.al_pa;
+
+	ct_req->req.rff_id.fc4_type = 0x08;		/* SCSI - FCP */
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): RFF_ID issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): RFF_ID failed, rejected "
+		    "request, rff_id_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		DEBUG2(printk("scsi(%ld): RFF_ID exiting normally.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_rnn_id() - SNS Register Node Name (RNN_ID) of the HBA.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_rnn_id(scsi_qla_host_t *ha)
+{
+	int		rval;
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	/* Issue RNN_ID */
+	/* Prepare common MS IOCB */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, RNN_ID_REQ_SIZE, RNN_ID_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, RNN_ID_CMD,
+	    RNN_ID_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- port_id, node_name */
+	ct_req->req.rnn_id.port_id[0] = ha->d_id.b.domain;
+	ct_req->req.rnn_id.port_id[1] = ha->d_id.b.area;
+	ct_req->req.rnn_id.port_id[2] = ha->d_id.b.al_pa;
+
+	memcpy(ct_req->req.rnn_id.node_name, ha->init_cb->node_name, WWN_SIZE);
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): RNN_ID issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): RNN_ID failed, rejected "
+		    "request, rnn_id_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		DEBUG2(printk("scsi(%ld): RNN_ID exiting normally.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_rsnn_nn() - SNS Register Symbolic Node Name (RSNN_NN) of the HBA.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+int
+qla2x00_rsnn_nn(scsi_qla_host_t *ha)
+{
+	int		rval;
+	uint8_t		*snn;
+	uint8_t		version[20];
+
+	ms_iocb_entry_t	*ms_pkt;
+	struct ct_sns_req	*ct_req;
+	struct ct_sns_rsp	*ct_rsp;
+
+	/* Issue RSNN_NN */
+	/* Prepare common MS IOCB */
+	/*   Request size adjusted after CT preparation */
+	ms_pkt = qla2x00_prep_ms_iocb(ha, 0, RSNN_NN_RSP_SIZE);
+
+	/* Prepare CT request */
+	ct_req = qla2x00_prep_ct_req(&ha->ct_sns->p.req, RSNN_NN_CMD,
+	    RSNN_NN_RSP_SIZE);
+	ct_rsp = &ha->ct_sns->p.rsp;
+
+	/* Prepare CT arguments -- node_name, symbolic node_name, size */
+	memcpy(ct_req->req.rsnn_nn.node_name, ha->init_cb->node_name, WWN_SIZE);
+	
+	/* Prepare the Symbolic Node Name */
+	/* Board type */
+	snn = ct_req->req.rsnn_nn.sym_node_name;
+	strcpy(snn, ha->model_number);
+	/* Firmware version */
+	strcat(snn, " FW:v");
+	sprintf(version, "%d.%02d.%02d", ha->fw_major_version,
+	    ha->fw_minor_version, ha->fw_subminor_version);
+	strcat(snn, version);
+	/* Driver version */
+	strcat(snn, " DVR:v");
+	strcat(snn, qla2x00_version_str);
+
+	/* Calculate SNN length */
+	ct_req->req.rsnn_nn.name_len = (uint8_t)strlen(snn);
+
+	/* Update MS IOCB request */
+	ms_pkt->req_bytecount =
+	    cpu_to_le32(24 + 1 + ct_req->req.rsnn_nn.name_len);
+	ms_pkt->dseg_req_length = ms_pkt->req_bytecount;
+
+	/* Execute MS IOCB */
+	rval = qla2x00_issue_iocb(ha, ha->ms_iocb, ha->ms_iocb_dma,
+	    sizeof(ms_iocb_entry_t));
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3(printk("scsi(%ld): RSNN_NN issue IOCB failed (%d).\n",
+		    ha->host_no, rval));
+	} else if (ct_rsp->header.response !=
+	    __constant_cpu_to_be16(CT_ACCEPT_RESPONSE)) {
+		DEBUG2_3(printk("scsi(%ld): RSNN_NN failed, rejected "
+		    "request, rsnn_id_rsp:\n", ha->host_no));
+		DEBUG2_3(qla2x00_dump_buffer((uint8_t *)&ct_rsp->header,
+		    sizeof(struct ct_rsp_hdr)));
+		rval = QLA_FUNCTION_FAILED;
+	} else {
+		DEBUG2(printk("scsi(%ld): RSNN_NN exiting normally.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_init.c linux-2.5/drivers/scsi/qla2xxx/qla_init.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_init.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_init.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,4258 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#include "qla_os.h"
+#include "qla_def.h"
+#include "qla_devtbl.h"
+
+/* XXX(hch): this is ugly, but we don't want to pull in exioctl.h */
+#ifndef EXT_IS_LUN_BIT_SET
+#define EXT_IS_LUN_BIT_SET(P,L) \
+    (((P)->mask[L/8] & (0x80 >> (L%8)))?1:0)
+#define EXT_SET_LUN_BIT(P,L) \
+    ((P)->mask[L/8] |= (0x80 >> (L%8)))
+#endif
+
+/*
+*  QLogic ISP2x00 Hardware Support Function Prototypes.
+*/
+static int qla2x00_pci_config(scsi_qla_host_t *);
+static int qla2x00_isp_firmware(scsi_qla_host_t *);
+static void qla2x00_reset_chip(scsi_qla_host_t *);
+static int qla2x00_chip_diag(scsi_qla_host_t *);
+static int qla2x00_setup_chip(scsi_qla_host_t *);
+static void qla2x00_init_response_q_entries(scsi_qla_host_t *);
+static int qla2x00_init_rings(scsi_qla_host_t *);
+static int qla2x00_fw_ready(scsi_qla_host_t *);
+static int qla2x00_configure_hba(scsi_qla_host_t *);
+static int qla2x00_nvram_config(scsi_qla_host_t *);
+static void qla2x00_init_tgt_map(scsi_qla_host_t *);
+static int qla2x00_configure_loop(scsi_qla_host_t *);
+static int qla2x00_configure_local_loop(scsi_qla_host_t *);
+static void qla2x00_update_fcport(scsi_qla_host_t *, fc_port_t *);
+static void qla2x00_lun_discovery(scsi_qla_host_t *, fc_port_t *);
+static int qla2x00_rpt_lun_discovery(scsi_qla_host_t *, fc_port_t *,
+    inq_cmd_rsp_t *, dma_addr_t);
+static int qla2x00_report_lun(scsi_qla_host_t *, fc_port_t *,
+    rpt_lun_cmd_rsp_t *, dma_addr_t);
+static fc_lun_t *qla2x00_cfg_lun(scsi_qla_host_t *, fc_port_t *, uint16_t,
+    inq_cmd_rsp_t *, dma_addr_t);
+static fc_lun_t * qla2x00_add_lun(fc_port_t *, uint16_t);
+static int qla2x00_inquiry(scsi_qla_host_t *, fc_port_t *, uint16_t,
+    inq_cmd_rsp_t *, dma_addr_t);
+static int qla2x00_configure_fabric(scsi_qla_host_t *);
+static int qla2x00_find_all_fabric_devs(scsi_qla_host_t *, struct list_head *);
+static int qla2x00_device_resync(scsi_qla_host_t *);
+static int qla2x00_fabric_dev_login(scsi_qla_host_t *, fc_port_t *,
+    uint16_t *);
+static void qla2x00_config_os(scsi_qla_host_t *ha);
+static uint16_t qla2x00_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport);
+static os_lun_t * qla2x00_fclun_bind(scsi_qla_host_t *, fc_port_t *,
+    fc_lun_t *);
+static void qla2x00_lun_free(scsi_qla_host_t *, uint16_t, uint16_t);
+static int qla2x00_bstr_to_hex(char *, uint8_t *, int);
+static int qla2x00_find_propname(scsi_qla_host_t *,
+    char *, char *, char *, int);
+#if 0
+static int qla2x00_get_prop_16chars(scsi_qla_host_t *,
+    char *, char *, char *);
+static void qla2x00_get_properties(scsi_qla_host_t *, char *);
+
+static void qla2x00_cfg_persistent_binding(scsi_qla_host_t *);
+static os_tgt_t *qla2x00_persistent_bind(scsi_qla_host_t *, uint8_t *,
+    uint8_t *, port_id_t *, uint16_t);
+#endif
+
+static int qla2x00_restart_isp(scsi_qla_host_t *);
+static void qla2x00_reset_adapter(scsi_qla_host_t *);
+
+/****************************************************************************/
+/*                QLogic ISP2x00 Hardware Support Functions.                */
+/****************************************************************************/
+
+/*
+* qla2x00_initialize_adapter
+*      Initialize board.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+int
+qla2x00_initialize_adapter(scsi_qla_host_t *ha)
+{
+	int	rval;
+	uint8_t	isp_init = 0;
+	uint8_t	restart_risc = 0;
+	uint8_t	retry;
+
+	/* Clear adapter flags. */
+	ha->flags.online = FALSE;
+	ha->flags.reset_active = FALSE;
+	atomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);
+	atomic_set(&ha->loop_state, LOOP_DOWN);
+	ha->device_flags = 0;
+	ha->sns_retry_cnt = 0;
+	ha->dpc_flags = 0;
+	ha->failback_delay = 0;
+	ha->flags.management_server_logged_in = 0;
+	ha->marker_needed = 0;
+	ha->mbx_flags = 0;
+	ha->isp_abort_cnt = 0;
+	ha->beacon_blink_led = 0;
+
+	rval = qla2x00_pci_config(ha);
+	if (rval) {
+		DEBUG2(printk("scsi(%ld): Unable to configure PCI space=n",
+		    ha->host_no));
+		return (rval);
+	}
+
+	qla2x00_reset_chip(ha);
+
+	/* Initialize target map database. */
+	qla2x00_init_tgt_map(ha);
+
+	/* Get Flash Version */
+	qla2x00_get_flash_version(ha);
+
+	qla_printk(KERN_INFO, ha, "Configure NVRAM parameters...\n");
+	qla2x00_nvram_config(ha);
+
+	ha->retry_count = ql2xretrycount;
+
+	qla_printk(KERN_INFO, ha, "Verifying loaded RISC code...\n");
+
+#if 0
+	/*
+	 * If the user specified a device configuration on the command line
+	 * then use it as the configuration.  Otherwise, we scan for all
+	 * devices.
+	 */
+	if (ql2xdevconf) {
+		ha->cmdline = ql2xdevconf;
+	}
+#endif
+
+	retry = 10;
+	/*
+	 * Try to configure the loop.
+	 */
+	do {
+		restart_risc = 0;
+		isp_init = 0;
+
+		/* If firmware needs to be loaded */
+		if (qla2x00_isp_firmware(ha) != QLA_SUCCESS) {
+			if ((rval = qla2x00_chip_diag(ha)) == QLA_SUCCESS) {
+				rval = qla2x00_setup_chip(ha);
+			}
+		}
+
+		/* Retrieve firmware information */
+		qla2x00_get_fw_version(ha, &ha->fw_major_version,
+		    &ha->fw_minor_version, &ha->fw_subminor_version,
+		    &ha->fw_attributes);
+		qla2x00_get_resource_cnts(ha, NULL, &ha->xchg_buf_cnt,
+		    &ha->iocb_buf_cnt, NULL);
+
+		if (rval == QLA_SUCCESS &&
+		    (rval = qla2x00_init_rings(ha)) == QLA_SUCCESS) {
+check_fw_ready_again:
+			/*
+			 * Wait for a successful LIP up to a maximum 
+			 * of (in seconds): RISC login timeout value,
+			 * RISC retry count value, and port down retry
+			 * value OR a minimum of 4 seconds OR If no 
+			 * cable, only 5 seconds.
+			 */
+			if (!qla2x00_fw_ready(ha)) {
+				clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+
+				/*
+				 * Go setup flash database devices with proper
+				 * Loop ID's.
+				 */
+				do {
+					clear_bit(LOOP_RESYNC_NEEDED,
+					    &ha->dpc_flags);
+					rval = qla2x00_configure_loop(ha);
+
+					if (test_bit(ISP_ABORT_NEEDED,
+					    &ha->dpc_flags)) {
+
+						restart_risc = 1;
+						break;
+					}
+
+					/*
+					 * If loop state change while we were
+					 * discoverying devices then wait for
+					 * LIP to complete
+					 */
+
+					if (atomic_read(&ha->loop_state) ==
+					    LOOP_DOWN && retry--) {
+						goto check_fw_ready_again;
+					}
+				} while (!atomic_read(&ha->loop_down_timer) &&
+				    retry &&
+				    (test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags)));
+			}
+
+			if (ha->mem_err) {
+				restart_risc = 1;
+			}
+			isp_init = 1;
+
+		}
+	} while (restart_risc && retry--);
+
+	if (isp_init) {
+		clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+		ha->marker_needed = 1;
+		qla2x00_marker(ha, 0, 0, MK_SYNC_ALL);
+		ha->marker_needed = 0;
+
+		ha->flags.online = TRUE;
+	}
+
+	if (rval) {
+		DEBUG2_3(printk("%s(): **** FAILED ****\n", __func__));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_pci_config() - Setup device PCI configuration registers.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_pci_config(scsi_qla_host_t *ha)
+{
+	uint16_t	w, mwi;
+	unsigned long   flags = 0;
+	uint32_t	cnt;
+
+	qla_printk(KERN_INFO, ha, "Configuring PCI space...\n");
+
+	/* 
+	 * Turn on PCI master; for system BIOSes that don't turn it on by
+	 * default.
+	 */
+	pci_set_master(ha->pdev);
+	mwi = 0;
+	if (pci_set_mwi(ha->pdev))
+		mwi = PCI_COMMAND_INVALIDATE;
+	pci_read_config_word(ha->pdev, PCI_REVISION_ID, &ha->revision);
+
+	if (!ha->iobase)
+		return (QLA_FUNCTION_FAILED);
+
+	/*
+	 * We want to respect framework's setting of PCI configuration space
+	 * command register and also want to make sure that all bits of
+	 * interest to us are properly set in command register.
+	 */
+	pci_read_config_word(ha->pdev, PCI_COMMAND, &w);
+	w |= mwi | (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+
+	/* Get PCI bus information. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ha->pci_attr = RD_REG_WORD(&ha->iobase->ctrl_status);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (IS_QLA23XX(ha)) {
+		pci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);
+
+		/* PCI Specification Revision 2.3 changes */
+		if (IS_QLA2322(ha))
+			/* Command Register - Reset Interrupt Disable. */
+			w &= ~BIT_10;
+
+		/*
+		 * If this is a 2300 card and not 2312, reset the
+		 * COMMAND_INVALIDATE due to a bug in the 2300. Unfortunately,
+		 * the 2310 also reports itself as a 2300 so we need to get the
+		 * fb revision level -- a 6 indicates it really is a 2300 and
+		 * not a 2310.
+		 */
+		if (IS_QLA2300(ha)) {
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+
+			/* Pause RISC. */
+			WRT_REG_WORD(&ha->iobase->hccr, HCCR_PAUSE_RISC);
+			for (cnt = 0; cnt < 30000; cnt++) {
+				if ((RD_REG_WORD(&ha->iobase->hccr) &
+				    HCCR_RISC_PAUSE) != 0)
+					break;
+	
+				udelay(10);
+			}
+
+			/* Select FPM registers. */
+			WRT_REG_WORD(&ha->iobase->ctrl_status, 0x20);
+
+			/* Get the fb rev level */
+			ha->fb_rev = RD_FB_CMD_REG(ha, ha->iobase);
+
+			if (ha->fb_rev == FPM_2300)
+				w &= ~PCI_COMMAND_INVALIDATE;
+
+			/* Deselect FPM registers. */
+			WRT_REG_WORD(&ha->iobase->ctrl_status, 0x0);
+
+			/* Release RISC module. */
+			WRT_REG_WORD(&ha->iobase->hccr, HCCR_RELEASE_RISC);
+			for (cnt = 0; cnt < 30000; cnt++) {
+				if ((RD_REG_WORD(&ha->iobase->hccr) &
+				    HCCR_RISC_PAUSE) == 0)
+					break;
+	
+				udelay(10);
+			}
+
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+
+	pci_write_config_word(ha->pdev, PCI_COMMAND, w);
+
+	/* Reset expansion ROM address decode enable */
+	pci_read_config_word(ha->pdev, PCI_ROM_ADDRESS, &w);
+	w &= ~PCI_ROM_ADDRESS_ENABLE;
+	pci_write_config_word(ha->pdev, PCI_ROM_ADDRESS, w);
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_isp_firmware() - Choose firmware image.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_isp_firmware(scsi_qla_host_t *ha)
+{
+	int  rval;
+
+	/* Assume loading risc code */
+	rval = QLA_FUNCTION_FAILED; 
+
+	if (ha->flags.disable_risc_code_load) {
+		DEBUG2(printk("scsi(%ld): RISC CODE NOT loaded\n",
+		    ha->host_no));
+		qla_printk(KERN_INFO, ha, "RISC CODE NOT loaded\n");
+
+		/* Verify checksum of loaded RISC code. */
+		rval = qla2x00_verify_checksum(ha);
+	}
+
+	if (rval) {
+		DEBUG2_3(printk("scsi(%ld): **** Load RISC code ****\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_reset_chip() - Reset ISP chip.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static void
+qla2x00_reset_chip(scsi_qla_host_t *ha) 
+{
+	unsigned long   flags = 0;
+	device_reg_t	*reg = ha->iobase;
+	uint32_t	cnt;
+	unsigned long	mbx_flags = 0;
+	uint16_t	cmd;
+
+	/* Disable ISP interrupts. */
+	qla2x00_disable_intrs(ha);
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Turn off master enable */
+	cmd = 0;
+	pci_read_config_word(ha->pdev, PCI_COMMAND, &cmd);
+	cmd &= ~PCI_COMMAND_MASTER;
+	pci_write_config_word(ha->pdev, PCI_COMMAND, cmd);
+
+	if (!IS_QLA2100(ha)) {
+		/* Pause RISC. */
+		WRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC);
+		if (!IS_QLA2312(ha) && !IS_QLA2322(ha)) {
+			for (cnt = 0; cnt < 30000; cnt++) {
+				if ((RD_REG_WORD(&reg->hccr) &
+				    HCCR_RISC_PAUSE) != 0)
+					break;
+				udelay(100);
+			}
+		} else {
+			udelay(10);
+		}
+
+		/* Select FPM registers. */
+		WRT_REG_WORD(&reg->ctrl_status, 0x20);
+
+		/* FPM Soft Reset. */
+		WRT_REG_WORD(&reg->fpm_diag_config, 0x100);
+
+		/* Toggle Fpm Reset. */
+		if (IS_QLA23XX(ha))
+			WRT_REG_WORD(&reg->fpm_diag_config, 0x0);
+
+		/* Select frame buffer registers. */
+		WRT_REG_WORD(&reg->ctrl_status, 0x10);
+
+		/* Reset frame buffer FIFOs. */
+		if (IS_QLA2200(ha)) {
+			WRT_FB_CMD_REG(ha, reg, 0xa000);
+		} else {
+			WRT_FB_CMD_REG(ha, reg, 0x00fc);
+
+			/* Read back fb_cmd until zero or 3 seconds max */
+			for (cnt = 0; cnt < 3000; cnt++) {
+				if ((RD_FB_CMD_REG(ha, reg) & 0xff) == 0)
+					break;
+				udelay(100);
+			}
+		}
+
+		/* Select RISC module registers. */
+		WRT_REG_WORD(&reg->ctrl_status, 0);
+
+		/* Reset RISC processor. */
+		WRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);
+
+		/* Release RISC processor. */
+		WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);
+	}
+
+	WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+	WRT_REG_WORD(&reg->hccr, HCCR_CLR_HOST_INT);
+
+	/* Reset ISP chip. */
+	WRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);
+
+	/* Wait for RISC to recover from reset. */
+	if (IS_QLA2312(ha) || IS_QLA2322(ha)) {
+		udelay(10);
+	} else {
+		/*
+		 * It is necessary to for a delay here since the card doesn't
+		 * respond to PCI reads during a reset. On some architectures
+		 * this will result in an MCA.
+		 */
+		udelay(20);
+		for (cnt = 30000; cnt; cnt--) {
+			if ((RD_REG_WORD(&reg->ctrl_status) &
+			    CSR_ISP_SOFT_RESET) == 0)
+				break;
+			udelay(100);
+		}
+	}
+
+	/* Reset RISC processor. */
+	WRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);
+
+	WRT_REG_WORD(&reg->semaphore, 0);
+
+	/* Release RISC processor. */
+	WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);
+	RD_REG_WORD(&reg->hccr);		/* PCI Posting. */
+
+	if (IS_QLA2312(ha) || IS_QLA2322(ha))
+		udelay(100);
+	else {
+		for (cnt = 0; cnt < 30000; cnt++) {
+			if (!(test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags)))
+				spin_lock_irqsave(&ha->mbx_reg_lock, mbx_flags);
+
+			if (RD_MAILBOX_REG(ha, reg, 0) != MBS_BUSY) {
+				if (!(test_bit(ABORT_ISP_ACTIVE,
+				    &ha->dpc_flags)))
+					spin_unlock_irqrestore(
+					    &ha->mbx_reg_lock, mbx_flags);
+				break;
+			}
+
+			if (!(test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags)))
+				spin_unlock_irqrestore(&ha->mbx_reg_lock,
+				    mbx_flags);
+
+			udelay(100);
+		}
+	}
+
+	/* Turn on master enable */
+	cmd |= PCI_COMMAND_MASTER;
+	pci_write_config_word(ha->pdev, PCI_COMMAND, cmd);
+
+	/* Disable RISC pause on FPM parity error. */
+	if (!IS_QLA2100(ha))
+		WRT_REG_WORD(&reg->hccr, HCCR_DISABLE_PARITY_PAUSE);
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+/**
+ * qla2x00_chip_diag() - Test chip for proper operation.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_chip_diag(scsi_qla_host_t *ha)
+{
+	int		rval;
+	device_reg_t	*reg = ha->iobase;
+	unsigned long	flags = 0;
+	uint16_t	data;
+	uint32_t	cnt;
+	uint16_t	mb[5];
+
+	/* Assume a failed state */
+	rval = QLA_FUNCTION_FAILED;
+
+	DEBUG3(printk("scsi(%ld): Testing device at %lx.\n",
+	    ha->host_no, (u_long)&reg->flash_address));
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Reset ISP chip. */
+	WRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);
+	/*
+	 * We need to have a delay here since the card will not respond while
+	 * in reset causing an MCA on some architectures.
+	 */
+	udelay(20);
+	data = qla2x00_debounce_register(&reg->ctrl_status);
+	for (cnt = 6000000 ; cnt && (data & CSR_ISP_SOFT_RESET); cnt--) {
+		udelay(5);
+		data = RD_REG_WORD(&reg->ctrl_status);
+		barrier();
+	}
+
+	if (!cnt)
+		goto chip_diag_failed;
+
+	DEBUG3(printk("scsi(%ld): Reset register cleared by chip reset\n",
+	    ha->host_no));
+
+	/* Reset RISC processor. */
+	WRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);
+	WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);
+
+	/* Workaround for QLA2312 PCI parity error */
+	if (IS_QLA2312(ha) || IS_QLA2322(ha))
+		udelay(10);
+	else {
+		data = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 0));
+		for (cnt = 6000000; cnt && (data == MBS_BUSY); cnt--) {
+			udelay(5);
+			data = RD_MAILBOX_REG(ha, reg, 0);
+			barrier(); 
+		}
+	}
+
+	if (!cnt)
+		goto chip_diag_failed;
+
+	/* Check product ID of chip */
+	DEBUG3(printk("scsi(%ld): Checking product ID of chip\n", ha->host_no));
+
+	mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+	mb[2] = RD_MAILBOX_REG(ha, reg, 2);
+	mb[3] = RD_MAILBOX_REG(ha, reg, 3);
+
+	if (mb[1] != PROD_ID_1 || (mb[2] != PROD_ID_2 && mb[2] != PROD_ID_2a) ||
+	    mb[3] != PROD_ID_3) {
+		qla_printk(KERN_WARNING, ha,
+		    "Wrong product ID = 0x%x,0x%x,0x%x\n", mb[1], mb[2], mb[3]);
+
+		goto chip_diag_failed;
+	}
+
+	/* Adjust fw RISC transfer size */
+	ha->fw_transfer_size = REQUEST_ENTRY_SIZE * REQUEST_ENTRY_CNT;
+
+	if (IS_QLA2200(ha) &&
+	    RD_MAILBOX_REG(ha, reg, 7) == QLA2200A_RISC_ROM_VER) {
+		/* Limit firmware transfer size with a 2200A */
+		DEBUG3(printk("scsi(%ld): Found QLA2200A chip.\n",
+		    ha->host_no));
+
+		ha->fw_transfer_size = 128;
+	}
+
+	/* Wrap Incoming Mailboxes Test. */
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG3(printk("scsi(%ld): Checking mailboxes.\n", ha->host_no));
+	rval = qla2x00_mbx_reg_test(ha);
+	if (rval) {
+		DEBUG(printk("scsi(%ld): Failed mailbox send register test\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha,
+		    "Failed mailbox send register test\n");
+	}
+	else {
+		/* Flag a successful rval */
+		rval = QLA_SUCCESS;
+	}
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+chip_diag_failed:
+	if (rval)
+		DEBUG2_3(printk("scsi(%ld): Chip diagnostics **** FAILED "
+		    "****\n", ha->host_no));
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (rval);
+}
+
+/**
+ * qla2x00_setup_chip() - Load and start RISC firmware.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_setup_chip(scsi_qla_host_t *ha)
+{
+	int		rval;
+	uint16_t	cnt;
+	uint16_t	*risc_code;
+	unsigned long	risc_address;
+	unsigned long	risc_code_size;
+	int		num;
+	int		i;
+	uint16_t	*req_ring;
+	struct qla_fw_info *fw_iter;
+
+	rval = QLA_SUCCESS;
+
+	/* Load firmware sequences */
+	fw_iter = ha->brd_info->fw_info;
+	while (fw_iter->addressing != FW_INFO_ADDR_NOMORE) {
+		risc_code = fw_iter->fwcode;
+		risc_code_size = *fw_iter->fwlen;
+
+		if (fw_iter->addressing == FW_INFO_ADDR_NORMAL) {
+			risc_address = *fw_iter->fwstart;
+		} else {
+			/* Extended address */
+			risc_address = *fw_iter->lfwstart;
+		}
+
+		num = 0;
+		rval = 0;
+		while (risc_code_size > 0 && !rval) {
+			cnt = (uint16_t)(ha->fw_transfer_size >> 1);
+			if (cnt > risc_code_size)
+				cnt = risc_code_size;
+
+			DEBUG7(printk("scsi(%ld): Loading risc segment@ "
+			    "addr %p, number of bytes 0x%x, offset 0x%lx.\n",
+			    ha->host_no, risc_code, cnt, risc_address));
+
+			req_ring = (uint16_t *)ha->request_ring;
+			for (i = 0; i < cnt; i++)
+				req_ring[i] = cpu_to_le16(risc_code[i]);
+
+			/*
+			 * Flush written firmware to the ha->request_ring buffer
+			 * before DMA.
+			 */
+			flush_cache_all();
+
+			if (fw_iter->addressing == FW_INFO_ADDR_NORMAL) {
+				rval = qla2x00_load_ram(ha,
+				    ha->request_dma, risc_address, cnt);
+			} else {
+				rval = qla2x00_load_ram_ext(ha,
+				    ha->request_dma, risc_address, cnt);
+			}
+			if (rval) {
+				DEBUG(printk("scsi(%ld): [ERROR] Failed to "
+				    "load segment %d of firmware\n",
+				    ha->host_no, num));
+				qla_printk(KERN_WARNING, ha,
+				    "[ERROR] Failed to load "
+				    "segment %d of firmware\n", num);
+
+				qla2x00_dump_regs(ha);
+				break;
+			}
+
+			risc_code += cnt;
+			risc_address += cnt;
+			risc_code_size -= cnt;
+			num++;
+		}
+
+		/* Next firmware sequence */
+		fw_iter++;
+	}
+
+	/* Verify checksum of loaded RISC code. */
+	if (!rval) {
+		DEBUG(printk("scsi(%ld): Verifying Checksum of loaded RISC "
+		    "code.\n", ha->host_no));
+
+		rval = qla2x00_verify_checksum(ha);
+		if (rval == QLA_SUCCESS) {
+			/* Start firmware execution. */
+			DEBUG(printk("scsi(%ld): Checksum OK, start "
+			    "firmware.\n", ha->host_no));
+
+			rval = qla2x00_execute_fw(ha);
+		}
+		else {
+			DEBUG2(printk(KERN_INFO
+			    "scsi(%ld): ISP Firmware failed checksum.\n",
+			    ha->host_no));
+		}
+	}
+
+	if (rval) {
+		DEBUG2_3(printk("scsi(%ld): Setup chip **** FAILED ****.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_init_response_q_entries() - Initializes response queue entries.
+ * @ha: HA context
+ *
+ * Beginning of request ring has initialization control block already built
+ * by nvram config routine.
+ *
+ * Returns 0 on success.
+ */
+static void
+qla2x00_init_response_q_entries(scsi_qla_host_t *ha)
+{
+	uint16_t cnt;
+	response_t *pkt;
+
+	pkt = ha->response_ring_ptr;
+	for (cnt = 0; cnt < ha->response_q_length; cnt++) {
+		pkt->signature = RESPONSE_PROCESSED;
+		pkt++;
+	}
+
+}
+
+/**
+ * qla2x00_init_rings() - Initializes firmware.
+ * @ha: HA context
+ *
+ * Beginning of request ring has initialization control block already built
+ * by nvram config routine.
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_init_rings(scsi_qla_host_t *ha)
+{
+	int	rval;
+	unsigned long flags = 0;
+	int cnt;
+	device_reg_t *reg = ha->iobase;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Clear outstanding commands array. */
+	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++)
+		ha->outstanding_cmds[cnt] = 0;
+
+	ha->current_outstanding_cmd = 0;
+
+	/* Clear RSCN queue. */
+	ha->rscn_in_ptr = 0;
+	ha->rscn_out_ptr = 0;
+
+	/* Initialize firmware. */
+	ha->request_ring_ptr  = ha->request_ring;
+	ha->req_ring_index    = 0;
+	ha->req_q_cnt         = REQUEST_ENTRY_CNT;
+	ha->response_ring_ptr = ha->response_ring;
+	ha->rsp_ring_index    = 0;
+
+	/* Initialize response queue entries */
+	qla2x00_init_response_q_entries(ha);
+
+ 	WRT_REG_WORD(ISP_REQ_Q_IN(ha, reg), 0);
+ 	WRT_REG_WORD(ISP_REQ_Q_OUT(ha, reg), 0);
+ 	WRT_REG_WORD(ISP_RSP_Q_IN(ha, reg), 0);
+ 	WRT_REG_WORD(ISP_RSP_Q_OUT(ha, reg), 0);
+	RD_REG_WORD(ISP_RSP_Q_OUT(ha, reg));
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG(printk("scsi(%ld): Issue init firmware.\n", ha->host_no));
+	rval = qla2x00_init_firmware(ha, sizeof(init_cb_t));
+	if (rval) {
+		DEBUG2_3(printk("scsi(%ld): Init firmware **** FAILED ****.\n",
+		    ha->host_no));
+	} else {
+		/* Setup seriallink options */
+		uint16_t swing, emphasis;
+
+		DEBUG3(printk("scsi(%ld): Serial link options:\n",
+		    ha->host_no));
+		DEBUG3(qla2x00_dump_buffer(
+		    (uint8_t *)&ha->fw_seriallink_options,
+		    sizeof(ha->fw_seriallink_options)));
+
+		memset(ha->fw_options, 0, sizeof(ha->fw_options));
+		qla2x00_get_fw_options(ha, ha->fw_options);
+
+		ha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;
+		if (ha->fw_seriallink_options[1] & BIT_2)
+			ha->fw_options[1] |= FO1_SET_EMPHASIS_SWING;
+
+		/* 1G settings */
+		swing = ha->fw_seriallink_options[0] & (BIT_2 | BIT_1 | BIT_0);
+		emphasis = ha->fw_seriallink_options[0] & (BIT_4 | BIT_3);
+		emphasis >>= 3;
+		ha->fw_options[10] = (emphasis << 14) | (swing << 8) | 0x3;
+
+		/* 2G settings */
+		swing = ha->fw_seriallink_options[0] & (BIT_7 | BIT_6 | BIT_5);
+		swing >>= 5;
+		emphasis = ha->fw_seriallink_options[1] & (BIT_1 | BIT_0);
+		ha->fw_options[11] = (emphasis << 14) | (swing << 8) | 0x3;
+
+		qla2x00_set_fw_options(ha, ha->fw_options);
+
+		DEBUG3(printk("scsi(%ld): Init firmware -- success.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/**
+ * qla2x00_fw_ready() - Waits for firmware ready.
+ * @ha: HA context
+ *
+ * Returns 0 on success.
+ */
+static int
+qla2x00_fw_ready(scsi_qla_host_t *ha)
+{
+	int		rval;
+	unsigned long	wtime, mtime;
+	uint16_t	min_wait;	/* Minimum wait time if loop is down */
+	uint16_t	wait_time;	/* Wait time if loop is coming ready */
+	uint16_t	fw_state;
+
+	rval = QLA_SUCCESS;
+
+	/* 20 seconds for loop down. */
+	min_wait = 20;		
+
+	/*
+	 * Firmware should take at most one RATOV to login, plus 5 seconds for
+	 * our own processing.
+	 */
+	if ((wait_time = (ha->retry_count*ha->login_timeout) + 5) < min_wait) {
+		wait_time = min_wait;
+	}
+
+	/* Min wait time if loop down */
+	mtime = jiffies + (min_wait * HZ);
+
+	/* wait time before firmware ready */
+	wtime = jiffies + (wait_time * HZ);
+
+	/* Wait for ISP to finish LIP */
+	if (!ha->flags.init_done)
+ 		qla_printk(KERN_INFO, ha, "Waiting for LIP to complete...\n");
+
+	DEBUG3(printk("scsi(%ld): Waiting for LIP to complete...\n",
+	    ha->host_no));
+
+	do {
+		rval = qla2x00_get_firmware_state(ha, &fw_state);
+		if (rval == QLA_SUCCESS) {
+			if (fw_state < FSTATE_LOSS_OF_SYNC) {
+				ha->device_flags &= ~DFLG_NO_CABLE;
+			}
+			if (fw_state == FSTATE_READY) {
+				DEBUG(printk("scsi(%ld): F/W Ready - OK \n",
+				    ha->host_no));
+
+				qla2x00_get_retry_cnt(ha, &ha->retry_count,
+				    &ha->login_timeout, &ha->r_a_tov);
+
+				rval = QLA_SUCCESS;
+				break;
+			}
+
+			rval = QLA_FUNCTION_FAILED;
+
+			if (atomic_read(&ha->loop_down_timer) &&
+			    fw_state >= FSTATE_LOSS_OF_SYNC) {
+				/* Loop down. Timeout on min_wait for states
+				 * other than Wait for Login. 
+				 */	
+				if (time_after_eq(jiffies, mtime)) {
+					qla_printk(KERN_INFO, ha,
+					    "Cable is unplugged...\n");
+
+					ha->device_flags |= DFLG_NO_CABLE;
+					break;
+				}
+			}
+		} else {
+			/* Mailbox cmd failed. Timeout on min_wait. */
+			if (time_after_eq(jiffies, mtime))
+				break;
+		}
+
+		if (time_after_eq(jiffies, wtime))
+			break;
+
+		/* Delay for a while */
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 2);
+
+		DEBUG3(printk("scsi(%ld): fw_state=%x curr time=%lx.\n",
+		    ha->host_no, fw_state, jiffies));
+	} while (1);
+
+	DEBUG(printk("scsi(%ld): fw_state=%x curr time=%lx.\n",
+	    ha->host_no, fw_state, jiffies));
+
+	if (rval) {
+		DEBUG2_3(printk("scsi(%ld): Firmware ready **** FAILED ****.\n",
+		    ha->host_no));
+	}
+
+	return (rval);
+}
+
+/*
+*  qla2x00_configure_hba
+*      Setup adapter context.
+*
+* Input:
+*      ha = adapter state pointer.
+*
+* Returns:
+*      0 = success
+*
+* Context:
+*      Kernel context.
+*/
+static int
+qla2x00_configure_hba(scsi_qla_host_t *ha)
+{
+	int       rval;
+	uint16_t      loop_id;
+	uint16_t      topo;
+	uint8_t       al_pa;
+	uint8_t       area;
+	uint8_t       domain;
+	char		connect_type[22];
+
+	/* Get host addresses. */
+	rval = qla2x00_get_adapter_id(ha,
+	    &loop_id, &al_pa, &area, &domain, &topo);
+	if (rval != QLA_SUCCESS) {
+		qla_printk(KERN_WARNING, ha,
+		    "ERROR -- Unable to get host loop ID.\n");
+		return (rval);
+	}
+
+	if (topo == 4) {
+		qla_printk(KERN_INFO, ha,
+			"Cannot get topology - retrying.\n");
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	ha->loop_id = loop_id;
+
+	/* Make sure 2100 only has loop, in case of any firmware bug. */
+	if (IS_QLA2100(ha))
+		topo = 0;
+
+	/* initialize */
+	ha->min_external_loopid = SNS_FIRST_LOOP_ID;
+	ha->operating_mode = LOOP;
+
+	switch (topo) {
+	case 0:
+		DEBUG3(printk("scsi(%ld): HBA in NL topology.\n",
+		    ha->host_no));
+		ha->current_topology = ISP_CFG_NL;
+		strcpy(connect_type, "(Loop)");
+		break;
+
+	case 1:
+		DEBUG3(printk("scsi(%ld): HBA in FL topology.\n",
+		    ha->host_no));
+		ha->current_topology = ISP_CFG_FL;
+		strcpy(connect_type, "(FL_Port)");
+		break;
+
+	case 2:
+		DEBUG3(printk("scsi(%ld): HBA in N P2P topology.\n",
+		    ha->host_no));
+		ha->operating_mode = P2P;
+		ha->current_topology = ISP_CFG_N;
+		strcpy(connect_type, "(N_Port-to-N_Port)");
+		break;
+
+	case 3:
+		DEBUG3(printk("scsi(%ld): HBA in F P2P topology.\n",
+		    ha->host_no));
+		ha->operating_mode = P2P;
+		ha->current_topology = ISP_CFG_F;
+		strcpy(connect_type, "(F_Port)");
+		break;
+
+	default:
+		DEBUG3(printk("scsi(%ld): HBA in unknown topology %x. "
+		    "Using NL.\n",
+		    ha->host_no, topo));
+		ha->current_topology = ISP_CFG_NL;
+		strcpy(connect_type, "(Loop)");
+		break;
+	}
+
+	/* Save Host port and loop ID. */
+	/* byte order - Big Endian */
+	ha->d_id.b.domain = domain;
+	ha->d_id.b.area = area;
+	ha->d_id.b.al_pa = al_pa;
+
+	if (!ha->flags.init_done)
+ 		qla_printk(KERN_INFO, ha,
+		    "Topology - %s, Host Loop address 0x%x\n",
+ 		    connect_type, ha->loop_id);
+
+	if (rval) {
+		DEBUG2_3(printk("scsi(%ld): FAILED.\n", ha->host_no));
+	} else {
+		DEBUG3(printk("scsi(%ld): exiting normally.\n", ha->host_no));
+	}
+
+	return(rval);
+}
+
+/*
+* NVRAM configuration for ISP 2xxx
+*
+* Input:
+*      ha                = adapter block pointer.
+*
+* Output:
+*      initialization control block in response_ring
+*      host adapters parameters in host adapter block
+*
+* Returns:
+*      0 = success.
+*/
+static int
+qla2x00_nvram_config(scsi_qla_host_t *ha)
+{
+	int   rval;
+	uint8_t   chksum = 0;
+	uint16_t  cnt;
+	uint8_t   *dptr1, *dptr2;
+	init_cb_t *icb   = ha->init_cb;
+	nvram_t *nv    = (nvram_t *)ha->request_ring;
+	uint16_t  *wptr  = (uint16_t *)ha->request_ring;
+	device_reg_t *reg = ha->iobase;
+	uint16_t  timer_mode;
+
+	rval = QLA_SUCCESS;
+
+	if (ha->flags.init_done)
+		return (rval);
+
+	/* Determine NVRAM starting address. */
+	ha->nvram_base = 0;
+	if (IS_QLA2312(ha) || IS_QLA2322(ha))
+		if ((RD_REG_WORD(&reg->ctrl_status) >> 14) == 1)
+			ha->nvram_base = 0x80;
+
+	/* Get NVRAM data and calculate checksum. */
+	qla2x00_lock_nvram_access(ha);
+	for (cnt = 0; cnt < sizeof(nvram_t)/2; cnt++) {
+		*wptr = cpu_to_le16(qla2x00_get_nvram_word(ha,
+		    (cnt+ha->nvram_base)));
+		chksum += (uint8_t)*wptr;
+		chksum += (uint8_t)(*wptr >> 8);
+		wptr++;
+	}
+	qla2x00_unlock_nvram_access(ha);
+
+	DEBUG5(printk("scsi(%ld): Contents of NVRAM\n", ha->host_no));
+	DEBUG5(qla2x00_dump_buffer((uint8_t *)ha->request_ring,
+	    sizeof(nvram_t)));
+
+	/* Bad NVRAM data, set defaults parameters. */
+	if (chksum || nv->id[0] != 'I' || nv->id[1] != 'S' ||
+	    nv->id[2] != 'P' || nv->id[3] != ' ' || nv->nvram_version < 1) {
+		/* Reset NVRAM data. */
+		qla_printk(KERN_WARNING, ha, "Inconsistent NVRAM detected: "
+		    "checksum=0x%x id=%c version=0x%x.\n", chksum, nv->id[0],
+		    nv->nvram_version);
+		qla_printk(KERN_WARNING, ha, "Falling back to functioning (yet "
+		    "invalid -- WWPN) defaults.\n");
+
+		/*
+		 * Set default initialization control block.
+		 */
+		memset(nv, 0, sizeof(nvram_t));
+		nv->parameter_block_version = ICB_VERSION;
+
+		if (IS_QLA23XX(ha)) {
+			nv->firmware_options[0] = BIT_2 | BIT_1;
+			nv->firmware_options[1] = BIT_7 | BIT_5;
+			nv->add_firmware_options[0] = BIT_5;
+			nv->add_firmware_options[1] = BIT_5 | BIT_4;
+			nv->frame_payload_size = __constant_cpu_to_le16(2048);
+			nv->special_options[1] = BIT_7;
+		} else if (IS_QLA2200(ha)) {
+			nv->firmware_options[0] = BIT_2 | BIT_1;
+			nv->firmware_options[1] = BIT_7 | BIT_5;
+			nv->add_firmware_options[0] = BIT_5 | BIT_4;
+			nv->add_firmware_options[1] = BIT_5 | BIT_4;
+			nv->frame_payload_size = __constant_cpu_to_le16(1024);
+		} else if (IS_QLA2100(ha)) {
+			nv->firmware_options[0] = BIT_3 | BIT_1;
+			nv->firmware_options[1] = BIT_5;
+			nv->frame_payload_size = __constant_cpu_to_le16(1024);
+		}
+
+		nv->max_iocb_allocation = __constant_cpu_to_le16(256);
+		nv->execution_throttle = __constant_cpu_to_le16(16);
+		nv->retry_count = 8;
+		nv->retry_delay = 1;
+
+		nv->port_name[0] = 33;
+		nv->port_name[3] = 224;
+		nv->port_name[4] = 139;
+
+		nv->login_timeout = 4;
+
+		/*
+		 * Set default host adapter parameters
+		 */
+		nv->host_p[1] = BIT_2;
+		nv->reset_delay = 5;
+		nv->port_down_retry_count = 8;
+		nv->max_luns_per_target = __constant_cpu_to_le16(8);
+		nv->link_down_timeout = 60;
+
+		rval = 1;
+	}
+
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+	/*
+	 * The SN2 does not provide BIOS emulation which means you can't change
+	 * potentially bogus BIOS settings. Force the use of default settings
+	 * for link rate and frame size.  Hope that the rest of the settings
+	 * are valid.
+	 */
+	if (ia64_platform_is("sn2")) {
+		nv->frame_payload_size = __constant_cpu_to_le16(2048);
+		if (IS_QLA23XX(ha))
+			nv->special_options[1] = BIT_7;
+	}
+#endif
+
+	/* Reset Initialization control block */
+	memset(icb, 0, sizeof(init_cb_t));
+
+	/*
+	 * Setup driver NVRAM options.
+	 */
+	nv->firmware_options[0] |= (BIT_6 | BIT_1);
+	nv->firmware_options[0] &= ~(BIT_5 | BIT_4);
+	nv->firmware_options[1] |= (BIT_5 | BIT_0);
+	nv->firmware_options[1] &= ~BIT_4;
+
+	if (IS_QLA23XX(ha)) {
+		nv->firmware_options[0] |= BIT_2;
+		nv->firmware_options[0] &= ~BIT_3;
+
+		if (IS_QLA2300(ha)) {
+			if (ha->fb_rev == FPM_2310) {
+				strcpy(ha->model_number, "QLA2310");
+			} else {
+				strcpy(ha->model_number, "QLA2300");
+			}
+		} else if (IS_QLA2312(ha) || IS_QLA2322(ha)) {
+			if (rval == 0 &&
+			    memcmp(nv->model_number, BINZERO,
+				    sizeof(nv->model_number)) != 0) {
+				char *st, *en;
+
+				strncpy(ha->model_number, nv->model_number,
+				    sizeof(nv->model_number));
+				st = en = ha->model_number;
+				en += sizeof(nv->model_number) - 1;
+				while (en > st) {
+					if (*en != 0x20)
+						break;
+					*en-- = '\0';
+				}
+			} else {
+				uint16_t        index;
+
+				index = (ha->pdev->subsystem_device & 0xff);
+				if (index < QLA_MODEL_NAMES) {
+					strcpy(ha->model_number,
+					    qla2x00_model_name[index]);
+					ha->model_desc =
+					    qla2x00_model_desc[index];
+				} else {
+					strcpy(ha->model_number, "QLA23xx");
+				}
+			}
+		} else {
+			strcpy(ha->model_number, "QLA23xx");
+		}
+	} else if (IS_QLA2200(ha)) {
+		nv->firmware_options[0] |= BIT_2;
+		strcpy(ha->model_number, "QLA22xx");
+	} else /*if (IS_QLA2100(ha))*/ {
+		strcpy(ha->model_number, "QLA2100");
+	}
+
+	/*
+	 * Copy over NVRAM RISC parameter block to initialization control block.
+	 */
+	dptr1 = (uint8_t *)icb;
+	dptr2 = (uint8_t *)&nv->parameter_block_version;
+	cnt = (uint8_t *)&icb->request_q_outpointer - (uint8_t *)&icb->version;
+	while (cnt--)
+		*dptr1++ = *dptr2++;
+
+	/* Copy 2nd half. */
+	dptr1 = (uint8_t *)icb->add_firmware_options;
+	cnt = (uint8_t *)icb->reserved_3 - (uint8_t *)icb->add_firmware_options;
+	while (cnt--)
+		*dptr1++ = *dptr2++;
+
+	/* Prepare nodename */
+	if ((icb->firmware_options[1] & BIT_6) == 0) {
+		/*
+		 * Firmware will apply the following mask if the nodename was
+		 * not provided.
+		 */
+		memcpy(icb->node_name, icb->port_name, WWN_SIZE);
+		icb->node_name[0] &= 0xF0;
+	}
+
+	/*
+	 * Set host adapter parameters.
+	 */
+	ha->nvram_version = nv->nvram_version;
+
+	ha->flags.disable_risc_code_load = ((nv->host_p[0] & BIT_4) ? 1 : 0);
+	ha->flags.enable_lip_reset = ((nv->host_p[1] & BIT_1) ? 1 : 0);
+	ha->flags.enable_lip_full_login = ((nv->host_p[1] & BIT_2) ? 1 : 0);
+	ha->flags.enable_target_reset = ((nv->host_p[1] & BIT_3) ? 1 : 0);
+
+	ha->operating_mode =
+	    (icb->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) >> 4;
+
+	ha->fw_seriallink_options[0] = nv->seriallink_options[0];
+	ha->fw_seriallink_options[1] = nv->seriallink_options[1];
+
+	/* save HBA serial number */
+	ha->serial0 = icb->port_name[5];
+	ha->serial1 = icb->port_name[6];
+	ha->serial2 = icb->port_name[7];
+	memcpy(ha->node_name, icb->node_name, WWN_SIZE);
+
+	icb->execution_throttle = __constant_cpu_to_le16(0xFFFF);
+
+	ha->retry_count = nv->retry_count;
+
+	/* Set minimum login_timeout to 4 seconds. */
+	if (nv->login_timeout < ql2xlogintimeout)
+		nv->login_timeout = ql2xlogintimeout;
+	if (nv->login_timeout < 4)
+		nv->login_timeout = 4;
+	ha->login_timeout = nv->login_timeout;
+	icb->login_timeout = nv->login_timeout;
+
+	/* Set minimum RATOV to 200 tenths of a second. */
+	ha->r_a_tov = 200;
+
+/* FIXME
+ *
+ * port_down_retry_count updated twice
+ *
+ */
+	ha->port_down_retry_count = nv->port_down_retry_count;
+	ha->minimum_timeout =
+	    (ha->login_timeout * ha->retry_count) + ha->port_down_retry_count;
+	ha->loop_reset_delay = nv->reset_delay;
+
+	/* Will get the value from NVRAM. */
+	ha->loop_down_timeout = LOOP_DOWN_TIMEOUT;
+
+	/* Link Down Timeout = 0:
+	 *
+	 * 	When Port Down timer expires we will start returning
+	 *	I/O's to OS with "DID_NO_CONNECT".
+	 *
+	 * Link Down Timeout != 0:
+	 *
+	 *	 The driver waits for the link to come up after link down
+	 *	 before returning I/Os to OS with "DID_NO_CONNECT".
+	 */						
+	if (nv->link_down_timeout == 0) {
+		ha->loop_down_abort_time =
+		    (LOOP_DOWN_TIME - ha->loop_down_timeout);
+	} else {
+		ha->link_down_timeout =	 nv->link_down_timeout;
+		ha->loop_down_abort_time =
+		    (LOOP_DOWN_TIME - ha->link_down_timeout);
+	} 
+
+	ha->max_probe_luns = le16_to_cpu(nv->max_luns_per_target);
+	if (ha->max_probe_luns == 0)
+		ha->max_probe_luns = MIN_LUNS;
+
+#if USE_BIOS_MAX_LUNS
+	ha->max_luns = le16_to_cpu(nv->max_luns_per_target);
+	if (ha->max_luns == 0)
+		ha->max_luns = MAX_LUNS;
+	else if (ha->max_luns > MAX_LUNS)
+		ha->max_luns = MAX_LUNS;
+#else
+	ha->max_luns = MAX_LUNS;
+#endif
+
+/* FIXME
+ *
+ * port_down_retry_count updated twice
+ *
+ */
+	/*
+	 * Need enough time to try and get the port back.
+	 */
+	if (qlport_down_retry)
+		ha->port_down_retry_count = qlport_down_retry;
+	/* Set login_retry_count */
+	ha->login_retry_count  = nv->retry_count;
+	if (ha->port_down_retry_count == nv->port_down_retry_count &&
+	    ha->port_down_retry_count > 3)
+		ha->login_retry_count = ha->port_down_retry_count;
+	else if (ha->port_down_retry_count > (int)ha->login_retry_count)
+		ha->login_retry_count = ha->port_down_retry_count;
+
+	ha->binding_type = Bind;
+	if (ha->binding_type != BIND_BY_PORT_NAME &&
+	    ha->binding_type != BIND_BY_PORT_ID) {
+		qla_printk(KERN_WARNING, ha,
+		    "Invalid binding type specified (%d), "
+		    "defaulting to BIND_BY_PORT_NAME!!!\n", ha->binding_type);
+
+		ha->binding_type = BIND_BY_PORT_NAME;
+	}
+
+	/*
+	 * Setup ring parameters in initialization control block
+	 */
+	icb->request_q_outpointer = __constant_cpu_to_le16(0);
+	icb->response_q_inpointer = __constant_cpu_to_le16(0);
+	icb->request_q_length = __constant_cpu_to_le16(REQUEST_ENTRY_CNT);
+	icb->response_q_length = cpu_to_le16(ha->response_q_length);
+	icb->request_q_address[0] = cpu_to_le32(LSD(ha->request_dma));
+	icb->request_q_address[1] = cpu_to_le32(MSD(ha->request_dma));
+	icb->response_q_address[0] = cpu_to_le32(LSD(ha->response_dma));
+	icb->response_q_address[1] = cpu_to_le32(MSD(ha->response_dma));
+
+	icb->lun_enables = __constant_cpu_to_le16(0);
+	icb->command_resource_count = 0;
+	icb->immediate_notify_resource_count = 0;
+	icb->timeout = __constant_cpu_to_le16(0);
+
+	if (IS_QLA2100(ha) || IS_QLA2200(ha)) {
+		/* Enable RIO */
+		icb->firmware_options[0] &= ~BIT_3;
+		icb->add_firmware_options[0] &=
+		    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);
+		icb->add_firmware_options[0] |= (BIT_1 | BIT_0);
+		icb->response_accumulation_timer = 3;
+		icb->interrupt_delay_timer = 5;
+
+		ha->flags.process_response_queue = 1;
+	} else {
+		/* TEST ZIO:
+		 *
+		 * icb->add_firmware_options[0] &=
+		 *    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);
+		 * icb->add_firmware_options[0] |= (BIT_2 | BIT_0);
+		 */
+		timer_mode  = icb->add_firmware_options[0] &
+		    (BIT_3 | BIT_2 | BIT_1 | BIT_0);
+		if (timer_mode == 5) {
+			DEBUG2(printk("scsi(%ld): ZIO enabled; timer delay "
+			    "(%d).\n", ha->host_no, ql2xintrdelaytimer));
+			qla_printk(KERN_INFO, ha,
+			    "ZIO enabled; timer delay (%d).\n",
+			    ql2xintrdelaytimer);
+
+			icb->interrupt_delay_timer = ql2xintrdelaytimer;
+	
+			ha->flags.process_response_queue = 1;
+		}
+	}
+
+	if (rval) {
+		DEBUG2_3(printk(KERN_WARNING
+		    "scsi(%ld): NVRAM configuration failed!\n", ha->host_no));
+	}
+
+	LEAVE(__func__);
+
+	return (rval);
+}
+
+/*
+* qla2x00_init_tgt_map
+*      Initializes target map.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Output:
+*      TGT_Q initialized
+*/
+static void
+qla2x00_init_tgt_map(scsi_qla_host_t *ha)
+{
+	uint32_t t;
+
+	ENTER(__func__);
+
+	for (t = 0; t < MAX_TARGETS; t++)
+		TGT_Q(ha, t) = (os_tgt_t *)NULL;
+
+	LEAVE(__func__);
+}
+
+/**
+ * qla2x00_alloc_fcport() - Allocate a generic fcport.
+ * @ha: HA context
+ * @flags: allocation flags
+ *
+ * Returns a pointer to the allocated fcport, or NULL, if none available.
+ */
+fc_port_t *
+qla2x00_alloc_fcport(scsi_qla_host_t *ha, int flags)
+{
+	fc_port_t *fcport;
+
+	fcport = kmalloc(sizeof(fc_port_t), flags);
+	if (fcport == NULL)
+		return (fcport);
+
+	/* Setup fcport template structure. */
+	memset(fcport, 0, sizeof (fc_port_t));
+	fcport->ha = ha;
+	fcport->port_type = FCT_UNKNOWN;
+	fcport->loop_id = FC_NO_LOOP_ID;
+	fcport->iodesc_idx_sent = IODESC_INVALID_INDEX;
+	atomic_set(&fcport->state, FCS_UNCONFIGURED);
+	fcport->flags = FCF_RLC_SUPPORT;
+	INIT_LIST_HEAD(&fcport->fcluns);
+
+	return (fcport);
+}
+
+/*
+ * qla2x00_configure_loop
+ *      Updates Fibre Channel Device Database with what is actually on loop.
+ *
+ * Input:
+ *      ha                = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success.
+ *      1 = error.
+ *      2 = database was full and device was not configured.
+ */
+static int
+qla2x00_configure_loop(scsi_qla_host_t *ha) 
+{
+	int  rval;
+	uint8_t  rval1 = 0;
+	static unsigned long  flags, save_flags;
+
+	rval = QLA_SUCCESS;
+
+	/* Get Initiator ID */
+	if (qla2x00_configure_hba(ha)) {
+		DEBUG(printk("scsi(%ld): Unable to configure HBA.\n",
+		    ha->host_no));
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	save_flags = flags = ha->dpc_flags;
+	DEBUG(printk("scsi(%ld): Configure loop -- dpc flags =0x%lx\n",
+	    ha->host_no, flags));
+
+	/* dg 02/26/02 ha->dpc_flags &= ~(LOCAL_LOOP_UPDATE | RSCN_UPDATE); */
+
+	/*
+	 * If we have both an RSCN and PORT UPDATE pending then handle them
+	 * both at the same time.
+	 */
+	clear_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);
+	clear_bit(RSCN_UPDATE, &ha->dpc_flags);
+	ha->mem_err = 0 ;
+
+	/* Determine what we need to do */
+	if (ha->current_topology == ISP_CFG_FL &&
+	    (test_bit(LOCAL_LOOP_UPDATE, &flags))) {
+
+		ha->flags.rscn_queue_overflow = TRUE;
+		set_bit(RSCN_UPDATE, &flags);
+
+	} else if (ha->current_topology == ISP_CFG_F &&
+	    (test_bit(LOCAL_LOOP_UPDATE, &flags))) {
+
+		ha->flags.rscn_queue_overflow = TRUE;
+		set_bit(RSCN_UPDATE, &flags);
+		clear_bit(LOCAL_LOOP_UPDATE, &flags);
+
+	} else if (!ha->flags.online ||
+	    (test_bit(ABORT_ISP_ACTIVE, &flags))) {
+
+		ha->flags.rscn_queue_overflow = TRUE;
+		set_bit(RSCN_UPDATE, &flags);
+		set_bit(LOCAL_LOOP_UPDATE, &flags);
+	}
+
+	do {
+		if (test_bit(LOCAL_LOOP_UPDATE, &flags)) {
+			rval = rval | qla2x00_configure_local_loop(ha);
+		}
+
+		if (test_bit(RSCN_UPDATE, &flags)) {
+			rval1 = qla2x00_configure_fabric(ha);
+			if ((rval1 & BIT_0) && ha->sns_retry_cnt < 8) {
+				ha->sns_retry_cnt++;
+				set_bit(LOGIN_RETRY_NEEDED, &ha->dpc_flags);
+			}
+		}
+
+		/* Isolate error status. */
+		if (rval & BIT_0) {
+			rval = 1;
+		} else {
+			rval = QLA_SUCCESS;
+		}
+
+	} while (rval != QLA_SUCCESS);
+
+	if (!atomic_read(&ha->loop_down_timer) &&
+	    !(test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))) {
+
+		/* If we found all devices then go ready */
+		if (!(test_bit(LOGIN_RETRY_NEEDED, &ha->dpc_flags))) {
+			atomic_set(&ha->loop_state, LOOP_READY);
+
+			DEBUG(printk("scsi(%ld): LOOP READY\n", ha->host_no));
+		} else {
+			if (test_bit(LOCAL_LOOP_UPDATE, &save_flags))
+				set_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);
+			if (test_bit(RSCN_UPDATE, &save_flags))
+				set_bit(RSCN_UPDATE, &ha->dpc_flags);
+		}
+	} else {
+		DEBUG(printk("scsi(%ld): Loop down counter running= %d or "
+		    "Resync needed- dpc flags= %ld\n",
+		    ha->host_no,
+		    atomic_read(&ha->loop_down_timer), ha->dpc_flags));
+		/* ???? dg 02/26/02  rval = 1; */
+	}
+
+	if (rval) {
+		DEBUG2_3(printk("%s(%ld): *** FAILED ***\n",
+		    __func__, ha->host_no));
+	} else {
+		DEBUG3(printk("%s: exiting normally\n", __func__));
+	}
+
+	return (rval);
+}
+
+
+
+/*
+ * qla2x00_configure_local_loop
+ *	Updates Fibre Channel Device Database with local loop devices.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	0 = success.
+ *	BIT_0 = error.
+ */
+static int
+qla2x00_configure_local_loop(scsi_qla_host_t *ha) 
+{
+	int		rval, rval2;
+	int		found_devs;
+	int		found;
+	fc_port_t	*fcport, *new_fcport;
+
+	uint16_t	index;
+	uint16_t	entries;
+	struct dev_id {
+		uint8_t	al_pa;
+		uint8_t	area;
+		uint8_t	domain;		
+		uint8_t	loop_id_2100;	/* ISP2100/ISP2200 -- 4 bytes. */
+		uint16_t loop_id;	/* ISP23XX         -- 6 bytes. */
+	} *id_list;
+#define MAX_ID_LIST_SIZE (sizeof(struct dev_id) * MAX_FIBRE_DEVICES)
+	dma_addr_t	id_list_dma;
+	char		*id_iter;
+	uint16_t	loop_id;
+	uint8_t		domain, area, al_pa;
+
+	rval = QLA_SUCCESS;
+	found_devs = 0;
+	new_fcport = NULL;
+
+	/*
+	 * No point in continuing if the loop is in a volatile state -- 
+	 * reschedule LOCAL_LOOP_UPDATE for later processing
+	 */
+	if (test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags)) {
+		set_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);
+		return (rval);
+	}
+
+	entries = MAX_FIBRE_DEVICES;
+	id_list = pci_alloc_consistent(ha->pdev, MAX_ID_LIST_SIZE,
+	    &id_list_dma);
+	if (id_list == NULL) {
+		DEBUG2(printk("scsi(%ld): Failed to allocate memory, No local "
+		    "loop\n", ha->host_no));
+
+		qla_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - port_list");
+
+		ha->mem_err++;
+		return (BIT_0);
+	}
+	memset(id_list, 0, MAX_ID_LIST_SIZE);
+
+	DEBUG3(printk("scsi(%ld): Getting FCAL position map\n", ha->host_no));
+	DEBUG3(qla2x00_get_fcal_position_map(ha, NULL));
+
+	/* Get list of logged in devices. */
+	rval = qla2x00_get_id_list(ha, id_list, id_list_dma, &entries);
+	if (rval) {
+		rval = BIT_0;
+		goto cleanup_allocation;
+	}
+
+	DEBUG3(printk("scsi(%ld): Entries in ID list (%d)\n",
+	    ha->host_no, entries));
+	DEBUG3(qla2x00_dump_buffer((uint8_t *)id_list,
+	    entries * sizeof(struct dev_id)));
+
+	/* Allocate temporary fcport for any new fcports discovered. */
+	new_fcport = qla2x00_alloc_fcport(ha, GFP_KERNEL);
+	if (new_fcport == NULL) {
+		rval = BIT_0;
+		goto cleanup_allocation;
+	}
+	new_fcport->flags &= ~FCF_FABRIC_DEVICE;
+
+	/*
+	 * Mark local devices that were present with FCF_DEVICE_LOST for now.
+	 */
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if (atomic_read(&fcport->state) == FCS_ONLINE &&
+		    fcport->port_type != FCT_BROADCAST &&
+		    (fcport->flags & FCF_FABRIC_DEVICE) == 0) {
+
+			DEBUG(printk("scsi(%ld): Marking port lost, "
+			    "loop_id=0x%04x\n",
+			    ha->host_no, fcport->loop_id));
+
+			atomic_set(&fcport->state, FCS_DEVICE_LOST);
+			fcport->flags &= ~FCF_FARP_DONE;
+		}
+	}
+
+	/* Add devices to port list. */
+	id_iter = (char *)id_list;
+	for (index = 0; index < entries; index++) {
+		domain = ((struct dev_id *)id_iter)->domain;
+		area = ((struct dev_id *)id_iter)->area;
+		al_pa = ((struct dev_id *)id_iter)->al_pa;
+		if (IS_QLA2100(ha) || IS_QLA2200(ha)) {
+			loop_id =
+			    (uint16_t)((struct dev_id *)id_iter)->loop_id_2100;
+			id_iter += 4;
+		} else {
+			loop_id =
+			    le16_to_cpu(((struct dev_id *)id_iter)->loop_id);
+			id_iter += 6;
+		}
+
+		/* Bypass reserved domain fields. */
+		if ((domain & 0xf0) == 0xf0)
+			continue;
+
+		/* Bypass if not same domain and area of adapter. */
+		if (area != ha->d_id.b.area || domain != ha->d_id.b.domain)
+			continue;
+
+		/* Bypass invalid local loop ID. */
+		if (loop_id > LAST_LOCAL_LOOP_ID)
+			continue;
+
+		/* Fill in member data. */
+		new_fcport->d_id.b.domain = domain;
+		new_fcport->d_id.b.area = area;
+		new_fcport->d_id.b.al_pa = al_pa;
+		new_fcport->loop_id = loop_id;
+		rval2 = qla2x00_get_port_database(ha, new_fcport, 0);
+		if (rval2 != QLA_SUCCESS) {
+			DEBUG2(printk("scsi(%ld): Failed to retrieve fcport "
+			    "information -- get_port_database=%x, "
+			    "loop_id=0x%04x\n",
+			    ha->host_no, rval2, new_fcport->loop_id));
+			continue;
+		}
+
+		/* Check for matching device in port list. */
+		found = 0;
+		fcport = NULL;
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (memcmp(new_fcport->port_name, fcport->port_name,
+			    WWN_SIZE))
+				continue;
+
+			fcport->flags &= ~(FCF_FABRIC_DEVICE |
+			    FCF_PERSISTENT_BOUND);
+			fcport->loop_id = new_fcport->loop_id;
+			fcport->port_type = new_fcport->port_type;
+			fcport->d_id.b24 = new_fcport->d_id.b24;
+			memcpy(fcport->node_name, new_fcport->node_name,
+			    WWN_SIZE);
+
+			found++;
+			break;
+		}
+
+		if (!found) {
+			/* New device, add to fcports list. */
+			new_fcport->flags &= ~FCF_PERSISTENT_BOUND;
+			list_add_tail(&new_fcport->list, &ha->fcports);
+
+			/* Allocate a new replacement fcport. */
+			fcport = new_fcport;
+			new_fcport = qla2x00_alloc_fcport(ha, GFP_KERNEL);
+			if (new_fcport == NULL) {
+				rval = BIT_0;
+				goto cleanup_allocation;
+			}
+			new_fcport->flags &= ~FCF_FABRIC_DEVICE;
+		}
+
+		qla2x00_update_fcport(ha, fcport);
+
+		found_devs++;
+	}
+
+cleanup_allocation:
+	pci_free_consistent(ha->pdev, MAX_ID_LIST_SIZE, id_list, id_list_dma);
+
+	if (new_fcport)
+		kfree(new_fcport);
+
+	if (rval & BIT_0) {
+		DEBUG2(printk("scsi(%ld): Configure local loop error exit: "
+		    "rval=%x\n", ha->host_no, rval));
+	}
+
+	if (found_devs) {
+		ha->device_flags |= DFLG_LOCAL_DEVICES;
+		ha->device_flags &= ~DFLG_RETRY_LOCAL_DEVICES;
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_update_fcport
+ *	Updates device on list.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = port structure pointer.
+ *
+ * Return:
+ *	0  - Success
+ *  BIT_0 - error
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla2x00_update_fcport(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	uint16_t	index;
+	unsigned long flags;
+	srb_t *sp;
+
+	fcport->ha = ha;
+	fcport->login_retry = 0;
+	fcport->port_login_retry_count = ha->port_down_retry_count *
+	    PORT_RETRY_TIME;
+	atomic_set(&fcport->port_down_timer, ha->port_down_retry_count *
+	    PORT_RETRY_TIME);
+	fcport->flags &= ~(FCF_LOGIN_NEEDED);
+
+	/*
+	 * Check for outstanding cmd on tape Bypass LUN discovery if active
+	 * command on tape.
+	 */
+	if (fcport->flags & FCF_TAPE_PRESENT) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+			if ((sp = ha->outstanding_cmds[index]) != 0) {
+				if (sp->fclun->fcport == fcport) {
+					atomic_set(&fcport->state, FCS_ONLINE);
+					spin_unlock_irqrestore(
+					    &ha->hardware_lock, flags);
+					return;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	/* Do LUN discovery. */
+	if (fcport->port_type == FCT_INITIATOR ||
+	    fcport->port_type == FCT_BROADCAST) {
+		fcport->device_type = TYPE_PROCESSOR;
+	} else {
+		qla2x00_lun_discovery(ha, fcport);
+	}
+	atomic_set(&fcport->state, FCS_ONLINE);
+}
+
+/*
+ * qla2x00_lun_discovery
+ *	Issue SCSI inquiry command for LUN discovery.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla2x00_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	inq_cmd_rsp_t	*inq;
+	dma_addr_t	inq_dma;
+	uint16_t	lun;
+
+	inq = pci_alloc_consistent(ha->pdev, sizeof(inq_cmd_rsp_t), &inq_dma);
+	if (inq == NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Memory Allocation failed - INQ\n");
+		return;
+	}
+
+	/* If report LUN works, exit. */
+	if (qla2x00_rpt_lun_discovery(ha, fcport, inq, inq_dma) !=
+	    QLA_SUCCESS) {
+		for (lun = 0; lun < ha->max_probe_luns; lun++) {
+			/* Configure LUN. */
+			qla2x00_cfg_lun(ha, fcport, lun, inq, inq_dma);
+		}
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(inq_cmd_rsp_t), inq, inq_dma);
+}
+
+/*
+ * qla2x00_rpt_lun_discovery
+ *	Issue SCSI report LUN command for LUN discovery.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_rpt_lun_discovery(scsi_qla_host_t *ha, fc_port_t *fcport,
+    inq_cmd_rsp_t *inq, dma_addr_t inq_dma)
+{
+	int			rval;
+	uint32_t		len, cnt;
+	uint16_t		lun;
+	rpt_lun_cmd_rsp_t	*rlc;
+	dma_addr_t		rlc_dma;
+
+	/* Assume a failed status */
+	rval = QLA_FUNCTION_FAILED;
+
+	/* No point in continuing if the device doesn't support RLC */
+	if ((fcport->flags & FCF_RLC_SUPPORT) == 0)
+		return (rval);
+
+	rlc = pci_alloc_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t),
+	    &rlc_dma);
+	if (rlc == NULL) {
+		qla_printk(KERN_WARNING, ha,
+			"Memory Allocation failed - RLC");
+		return QLA_MEMORY_ALLOC_FAILED;
+	}
+
+	rval = qla2x00_report_lun(ha, fcport, rlc, rlc_dma);
+	if (rval != QLA_SUCCESS) {
+		pci_free_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t), rlc,
+		    rlc_dma);
+		return (rval);
+	}
+
+	/* Always add a fc_lun_t structure for lun 0 -- mid-layer requirement */
+	qla2x00_add_lun(fcport, 0);
+
+	/* Configure LUN list. */
+	len = be32_to_cpu(rlc->list.hdr.len);
+	len /= 8;
+	for (cnt = 0; cnt < len; cnt++) {
+		lun = CHAR_TO_SHORT(rlc->list.lst[cnt].lsb,
+		    rlc->list.lst[cnt].msb.b);
+
+		DEBUG3(printk("scsi(%ld): RLC lun = (%d)\n", ha->host_no, lun));
+
+		/* We only support 0 through MAX_LUNS-1 range */
+		if (lun < MAX_LUNS) {
+			qla2x00_cfg_lun(ha, fcport, lun, inq, inq_dma);
+		}
+	}
+	atomic_set(&fcport->state, FCS_ONLINE);
+
+	pci_free_consistent(ha->pdev, sizeof(rpt_lun_cmd_rsp_t), rlc, rlc_dma);
+
+	return (rval);
+}
+
+/*
+ * qla2x00_report_lun
+ *	Issue SCSI report LUN command.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *	mem:		pointer to dma memory object for report LUN IOCB
+ *			packet.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_report_lun(scsi_qla_host_t *ha,
+    fc_port_t *fcport, rpt_lun_cmd_rsp_t *rlc, dma_addr_t rlc_dma)
+{
+	int rval;
+	uint16_t retries;
+	uint16_t comp_status;
+	uint16_t scsi_status;
+
+	rval = QLA_FUNCTION_FAILED;
+
+	for (retries = 3; retries; retries--) {
+		memset(rlc, 0, sizeof(rpt_lun_cmd_rsp_t));
+		rlc->p.cmd.entry_type = COMMAND_A64_TYPE;
+		rlc->p.cmd.entry_count = 1;
+		SET_TARGET_ID(ha, rlc->p.cmd.target, fcport->loop_id);
+		rlc->p.cmd.control_flags =
+		    __constant_cpu_to_le16(CF_READ | CF_SIMPLE_TAG);
+		rlc->p.cmd.scsi_cdb[0] = REPORT_LUNS;
+		rlc->p.cmd.scsi_cdb[8] = MSB(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.scsi_cdb[9] = LSB(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.dseg_count = __constant_cpu_to_le16(1);
+		rlc->p.cmd.timeout = __constant_cpu_to_le16(10);
+		rlc->p.cmd.byte_count =
+		    __constant_cpu_to_le32(sizeof(rpt_lun_lst_t));
+		rlc->p.cmd.dseg_0_address[0] = cpu_to_le32(
+		    LSD(rlc_dma + sizeof(sts_entry_t)));
+		rlc->p.cmd.dseg_0_address[1] = cpu_to_le32(
+		    MSD(rlc_dma + sizeof(sts_entry_t)));
+		rlc->p.cmd.dseg_0_length =
+		    __constant_cpu_to_le32(sizeof(rpt_lun_lst_t));
+
+		rval = qla2x00_issue_iocb(ha, rlc, rlc_dma,
+		    sizeof(rpt_lun_cmd_rsp_t));
+
+		comp_status = le16_to_cpu(rlc->p.rsp.comp_status);
+		scsi_status = le16_to_cpu(rlc->p.rsp.scsi_status);
+
+		if (rval != QLA_SUCCESS || comp_status != CS_COMPLETE ||
+		    scsi_status & SS_CHECK_CONDITION) {
+
+			/* Device underrun, treat as OK. */
+			if (rval == QLA_SUCCESS &&
+			    comp_status == CS_DATA_UNDERRUN &&
+			    scsi_status & SS_RESIDUAL_UNDER) {
+
+				rval = QLA_SUCCESS;
+				break;
+			}
+
+			DEBUG(printk("scsi(%ld): RLC failed to issue iocb! "
+			    "fcport=[%04x/%p] rval=%x cs=%x ss=%x\n",
+			    ha->host_no, fcport->loop_id, fcport, rval,
+			    comp_status, scsi_status));
+
+			rval = QLA_FUNCTION_FAILED;
+			if (scsi_status & SS_CHECK_CONDITION) {
+				DEBUG2(printk("scsi(%ld): RLC "
+				    "SS_CHECK_CONDITION Sense Data "
+				    "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				    ha->host_no,
+				    rlc->p.rsp.req_sense_data[0],
+				    rlc->p.rsp.req_sense_data[1],
+				    rlc->p.rsp.req_sense_data[2],
+				    rlc->p.rsp.req_sense_data[3],
+				    rlc->p.rsp.req_sense_data[4],
+				    rlc->p.rsp.req_sense_data[5],
+				    rlc->p.rsp.req_sense_data[6],
+				    rlc->p.rsp.req_sense_data[7]));
+				if (rlc->p.rsp.req_sense_data[2] ==
+				    ILLEGAL_REQUEST) {
+					fcport->flags &= ~(FCF_RLC_SUPPORT);
+					break;
+				}
+			}
+		} else {
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_cfg_lun
+ *	Configures LUN into fcport LUN list.
+ *
+ * Input:
+ *	fcport:		FC port structure pointer.
+ *	lun:		LUN number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static fc_lun_t *
+qla2x00_cfg_lun(scsi_qla_host_t *ha, fc_port_t *fcport, uint16_t lun,
+    inq_cmd_rsp_t *inq, dma_addr_t inq_dma) 
+{
+	fc_lun_t *fclun;
+
+	/* Bypass LUNs that failed. */
+	if (qla2x00_inquiry(ha, fcport, lun, inq, inq_dma) != QLA_SUCCESS) {
+		DEBUG2(printk("scsi(%ld): Failed inquiry - loop id=0x%04x "
+		    "lun=%d\n", ha->host_no, fcport->loop_id, lun));
+
+		return (NULL);
+	}
+
+	switch (inq->inq[0]) {
+	case TYPE_DISK:
+	case TYPE_PROCESSOR:
+	case TYPE_WORM:
+	case TYPE_ROM:
+	case TYPE_SCANNER:
+	case TYPE_MOD:
+	case TYPE_MEDIUM_CHANGER:
+	case TYPE_ENCLOSURE:
+	case 0x20:
+		break;
+	case TYPE_TAPE:
+		fcport->flags |= FCF_TAPE_PRESENT;
+		break;
+	default:
+		DEBUG2(printk("scsi(%ld): Unsupported lun type -- "
+		    "loop id=0x%04x lun=%d type=%x\n",
+		    ha->host_no, fcport->loop_id, lun, inq->inq[0]));
+		return (NULL);
+	}
+
+	fcport->device_type = inq->inq[0];
+	fclun = qla2x00_add_lun(fcport, lun);
+
+	if (fclun != NULL) {
+		atomic_set(&fcport->state, FCS_ONLINE);
+	}
+
+	return (fclun);
+}
+
+/*
+ * qla2x00_add_lun
+ *	Adds LUN to database
+ *
+ * Input:
+ *	fcport:		FC port structure pointer.
+ *	lun:		LUN number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static fc_lun_t *
+qla2x00_add_lun(fc_port_t *fcport, uint16_t lun)
+{
+	int		found;
+	fc_lun_t	*fclun;
+
+	if (fcport == NULL) {
+		DEBUG(printk("scsi: Unable to add lun to NULL port\n"));
+		return (NULL);
+	}
+
+	/* Allocate LUN if not already allocated. */
+	found = 0;
+	list_for_each_entry(fclun, &fcport->fcluns, list) {
+		if (fclun->lun == lun) {
+			found++;
+			break;
+		}
+	}
+	if (found)
+		return (NULL);
+
+	fclun = kmalloc(sizeof(fc_lun_t), GFP_ATOMIC);
+	if (fclun == NULL) {
+		printk(KERN_WARNING
+		    "%s(): Memory Allocation failed - FCLUN\n",
+		    __func__);
+		return (NULL);
+	}
+
+	/* Setup LUN structure. */
+	memset(fclun, 0, sizeof(fc_lun_t));
+	fclun->lun = lun;
+	fclun->fcport = fcport;
+	fclun->o_fcport = fcport;
+	fclun->device_type = fcport->device_type;
+	atomic_set(&fcport->state, FCS_UNCONFIGURED);
+
+	list_add_tail(&fclun->list, &fcport->fcluns);
+
+	return (fclun);
+}
+
+/*
+ * qla2x00_inquiry
+ *	Issue SCSI inquiry command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Return:
+ *	0  - Success
+ *  BIT_0 - error
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_inquiry(scsi_qla_host_t *ha,
+    fc_port_t *fcport, uint16_t lun, inq_cmd_rsp_t *inq, dma_addr_t inq_dma)
+{
+	int rval;
+	uint16_t retries;
+	uint16_t comp_status;
+	uint16_t scsi_status;
+
+	rval = QLA_FUNCTION_FAILED;
+
+	for (retries = 3; retries; retries--) {
+		memset(inq, 0, sizeof(inq_cmd_rsp_t));
+		inq->p.cmd.entry_type = COMMAND_A64_TYPE;
+		inq->p.cmd.entry_count = 1;
+		inq->p.cmd.lun = cpu_to_le16(lun);
+		SET_TARGET_ID(ha, inq->p.cmd.target, fcport->loop_id);
+		inq->p.cmd.control_flags =
+		    __constant_cpu_to_le16(CF_READ | CF_SIMPLE_TAG);
+		inq->p.cmd.scsi_cdb[0] = INQUIRY;
+		inq->p.cmd.scsi_cdb[4] = INQ_DATA_SIZE;
+		inq->p.cmd.dseg_count = __constant_cpu_to_le16(1);
+		inq->p.cmd.timeout = __constant_cpu_to_le16(10);
+		inq->p.cmd.byte_count =
+		    __constant_cpu_to_le32(INQ_DATA_SIZE);
+		inq->p.cmd.dseg_0_address[0] = cpu_to_le32(
+		    LSD(inq_dma + sizeof(sts_entry_t)));
+		inq->p.cmd.dseg_0_address[1] = cpu_to_le32(
+		    MSD(inq_dma + sizeof(sts_entry_t)));
+		inq->p.cmd.dseg_0_length =
+		    __constant_cpu_to_le32(INQ_DATA_SIZE);
+
+		DEBUG5(printk("scsi(%ld): Lun Inquiry - fcport=[%04x/%p],"
+		    " lun (%d)\n",
+		    ha->host_no, fcport->loop_id, fcport, lun));
+
+		rval = qla2x00_issue_iocb(ha, inq, inq_dma,
+		    sizeof(inq_cmd_rsp_t));
+
+		comp_status = le16_to_cpu(inq->p.rsp.comp_status);
+		scsi_status = le16_to_cpu(inq->p.rsp.scsi_status);
+
+		DEBUG5(printk("scsi(%ld): lun (%d) inquiry - "
+		    "inq[0]= 0x%x, comp status 0x%x, scsi status 0x%x, "
+		    "rval=%d\n",
+		    ha->host_no, lun, inq->inq[0], comp_status, scsi_status,
+		    rval));
+
+		if (rval != QLA_SUCCESS || comp_status != CS_COMPLETE ||
+		    scsi_status & SS_CHECK_CONDITION) {
+
+			DEBUG(printk("scsi(%ld): INQ failed to issue iocb! "
+			    "fcport=[%04x/%p] rval=%x cs=%x ss=%x\n",
+			    ha->host_no, fcport->loop_id, fcport, rval,
+			    comp_status, scsi_status));
+
+			if (rval == QLA_SUCCESS)
+				rval = QLA_FUNCTION_FAILED;
+
+			if (scsi_status & SS_CHECK_CONDITION) {
+				DEBUG2(printk("scsi(%ld): INQ "
+				    "SS_CHECK_CONDITION Sense Data "
+				    "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				    ha->host_no,
+				    inq->p.rsp.req_sense_data[0],
+				    inq->p.rsp.req_sense_data[1],
+				    inq->p.rsp.req_sense_data[2],
+				    inq->p.rsp.req_sense_data[3],
+				    inq->p.rsp.req_sense_data[4],
+				    inq->p.rsp.req_sense_data[5],
+				    inq->p.rsp.req_sense_data[6],
+				    inq->p.rsp.req_sense_data[7]));
+			}
+
+			/* Device underrun drop LUN. */
+			if (comp_status == CS_DATA_UNDERRUN &&
+			    scsi_status & SS_RESIDUAL_UNDER) {
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+
+/*
+ * qla2x00_configure_fabric
+ *      Setup SNS devices with loop ID's.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success.
+ *      BIT_0 = error
+ */
+static int
+qla2x00_configure_fabric(scsi_qla_host_t *ha)
+{
+	int	rval, rval2;
+	fc_port_t	*fcport, *fcptemp;
+	uint16_t	next_loopid;
+	LIST_HEAD(new_fcports);
+
+	/* If FL port exists, then SNS is present */
+	rval = qla2x00_get_port_name(ha, SNS_FL_PORT, NULL, 0);
+	if (rval != QLA_SUCCESS) {
+		DEBUG2(printk("scsi(%ld): MBC_GET_PORT_NAME Failed, No FL "
+		    "Port\n", ha->host_no));
+
+		ha->device_flags &= ~SWITCH_FOUND;
+		return (QLA_SUCCESS);
+	}
+
+	/* Mark devices that need re-synchronization. */
+	rval2 = qla2x00_device_resync(ha);
+	if (rval2 == QLA_RSCNS_HANDLED) {
+		/* No, point doing the scan, just continue. */
+		return (QLA_SUCCESS);
+	}
+	do {
+		if (test_and_clear_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags)) {
+			if (qla2x00_rft_id(ha)) {
+				/* EMPTY */
+				DEBUG2(printk("scsi(%ld): Register FC-4 "
+				    "TYPE failed.\n", ha->host_no));
+			}
+			if (qla2x00_rff_id(ha)) {
+				/* EMPTY */
+				DEBUG2(printk("scsi(%ld): Register FC-4 "
+				    "Features failed.\n", ha->host_no));
+			}
+			if (qla2x00_rnn_id(ha)) {
+				/* EMPTY */
+				DEBUG2(printk("scsi(%ld): Register Node Name "
+				    "failed.\n", ha->host_no));
+			} else if (qla2x00_rsnn_nn(ha)) {
+				/* EMPTY */
+				DEBUG2(printk("scsi(%ld): Register Symbolic "
+				    "Node Name failed.\n", ha->host_no));
+			}
+		}
+
+		rval = qla2x00_find_all_fabric_devs(ha, &new_fcports);
+		if (rval != QLA_SUCCESS)
+			break;
+
+		/*
+		 * Logout all previous fabric devices marked lost, except
+		 * tape devices.
+		 */
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+				break;
+
+			if ((fcport->flags & FCF_FABRIC_DEVICE) == 0)
+				continue;
+
+			if (atomic_read(&fcport->state) == FCS_DEVICE_LOST) {
+				qla2x00_mark_device_lost(ha, fcport,
+				    ql2xplogiabsentdevice);
+				if (fcport->loop_id != FC_NO_LOOP_ID &&
+				    (fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+				    fcport->port_type != FCT_INITIATOR &&
+				    fcport->port_type != FCT_BROADCAST) {
+
+					qla2x00_fabric_logout(ha,
+					    fcport->loop_id);
+					fcport->loop_id = FC_NO_LOOP_ID;
+				}
+			}
+		}
+
+		/* Starting free loop ID. */
+		next_loopid = ha->min_external_loopid;
+
+		/*
+		 * Scan through our port list and login entries that need to be
+		 * logged in.
+		 */
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (atomic_read(&ha->loop_down_timer) ||
+			    test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+				break;
+
+			if ((fcport->flags & FCF_FABRIC_DEVICE) == 0 ||
+			    (fcport->flags & FCF_LOGIN_NEEDED) == 0)
+				continue;
+
+			if (fcport->loop_id == FC_NO_LOOP_ID) {
+				fcport->loop_id = next_loopid;
+				rval = qla2x00_find_new_loop_id(ha, fcport);
+				if (rval != QLA_SUCCESS) {
+					/* Ran out of IDs to use */
+					break;
+				}
+			}
+
+			/* Login and update database */
+			qla2x00_fabric_dev_login(ha, fcport, &next_loopid);
+		}
+
+		/* Exit if out of loop IDs. */
+		if (rval != QLA_SUCCESS) {
+			break;
+		}
+
+		/*
+		 * Login and add the new devices to our port list.
+		 */
+		list_for_each_entry_safe(fcport, fcptemp, &new_fcports, list) {
+			if (atomic_read(&ha->loop_down_timer) ||
+			    test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+				break;
+
+			/* Find a new loop ID to use. */
+			fcport->loop_id = next_loopid;
+			rval = qla2x00_find_new_loop_id(ha, fcport);
+			if (rval != QLA_SUCCESS) {
+				/* Ran out of IDs to use */
+				break;
+			}
+
+			/* Login and update database */
+			qla2x00_fabric_dev_login(ha, fcport, &next_loopid);
+
+			/* Remove device from the new list and add it to DB */
+			list_del(&fcport->list);
+			list_add_tail(&fcport->list, &ha->fcports);
+		}
+	} while (0);
+
+	/* Free all new device structures not processed. */
+	list_for_each_entry_safe(fcport, fcptemp, &new_fcports, list) {
+		list_del(&fcport->list);
+		kfree(fcport);
+	}
+
+	if (rval) {
+		DEBUG2(printk("scsi(%ld): Configure fabric error exit: "
+		    "rval=%d\n", ha->host_no, rval));
+	}
+
+	return (rval);
+}
+
+
+/*
+ * qla2x00_find_all_fabric_devs
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	dev = database device entry pointer.
+ *
+ * Returns:
+ *	0 = success.
+ *	BIT_0 = error.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_find_all_fabric_devs(scsi_qla_host_t *ha, struct list_head *new_fcports)
+{
+	int		rval;
+	uint16_t	loop_id;
+	fc_port_t	*fcport, *new_fcport;
+	int		found;
+
+	sw_info_t	*swl;
+	int		swl_idx;
+	int		first_dev, last_dev;
+	port_id_t	wrap, nxt_d_id;
+
+	rval = QLA_SUCCESS;
+
+	/* Try GID_PT to get device list, else GAN. */
+	swl = kmalloc(sizeof(sw_info_t) * MAX_FIBRE_DEVICES, GFP_ATOMIC);
+	if (swl == NULL) {
+		/*EMPTY*/
+		DEBUG2(printk("scsi(%ld): GID_PT allocations failed, fallback "
+		    "on GA_NXT\n", ha->host_no));
+	} else {
+		memset(swl, 0, sizeof(sw_info_t) * MAX_FIBRE_DEVICES);
+		if (qla2x00_gid_pt(ha, swl) != QLA_SUCCESS) {
+			kfree(swl);
+			swl = NULL;
+		} else if (qla2x00_gpn_id(ha, swl) != QLA_SUCCESS) {
+			kfree(swl);
+			swl = NULL;
+		} else if (qla2x00_gnn_id(ha, swl) != QLA_SUCCESS) {
+			kfree(swl);
+			swl = NULL;
+		}
+	}
+	swl_idx = 0;
+
+	/* Allocate temporary fcport for any new fcports discovered. */
+	new_fcport = qla2x00_alloc_fcport(ha, GFP_KERNEL);
+	if (new_fcport == NULL) {
+		if (swl)
+			kfree(swl);
+		return (QLA_MEMORY_ALLOC_FAILED);
+	}
+	new_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);
+
+	/* Set start port ID scan at adapter ID. */
+	first_dev = 1;
+	last_dev = 0;
+
+	/* Starting free loop ID. */
+	loop_id = ha->min_external_loopid;
+
+	for (; loop_id <= ha->last_loop_id; loop_id++) {
+		if (RESERVED_LOOP_ID(loop_id))
+			continue;
+
+		if (atomic_read(&ha->loop_down_timer) ||
+		    test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+			break;
+
+		if (swl != NULL) {
+			if (last_dev) {
+				wrap.b24 = new_fcport->d_id.b24;
+			} else {
+				new_fcport->d_id.b24 = swl[swl_idx].d_id.b24;
+				memcpy(new_fcport->node_name,
+				    swl[swl_idx].node_name, WWN_SIZE);
+				memcpy(new_fcport->port_name,
+				    swl[swl_idx].port_name, WWN_SIZE);
+
+				if (swl[swl_idx].d_id.b.rsvd_1 != 0) {
+					last_dev = 1;
+				}
+				swl_idx++;
+			}
+		} else {
+			/* Send GA_NXT to the switch */
+			rval = qla2x00_ga_nxt(ha, new_fcport);
+			if (rval != QLA_SUCCESS) {
+				break;
+			}
+		}
+
+		/* If wrap on switch device list, exit. */
+		if (first_dev) {
+			wrap.b24 = new_fcport->d_id.b24;
+			first_dev = 0;
+		} else if (new_fcport->d_id.b24 == wrap.b24) {
+			DEBUG2(printk("scsi(%ld): device wrap (%02x%02x%02x)\n",
+			    ha->host_no, new_fcport->d_id.b.domain,
+			    new_fcport->d_id.b.area, new_fcport->d_id.b.al_pa));
+			break;
+		}
+
+		/* Bypass if host adapter. */
+		if (new_fcport->d_id.b24 == ha->d_id.b24)
+			continue;
+
+		/* Bypass reserved domain fields. */
+		if ((new_fcport->d_id.b.domain & 0xf0) == 0xf0)
+			continue;
+
+		/* Bypass if same domain and area of adapter. */
+		if ((new_fcport->d_id.b24 & 0xffff00) ==
+		    (ha->d_id.b24 & 0xffff00))
+			continue;
+
+		/* Locate matching device in database. */
+		found = 0;
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (memcmp(new_fcport->port_name, fcport->port_name,
+			    WWN_SIZE))
+				continue;
+
+			found++;
+
+			/*
+			 * If device was not a fabric device before.
+			 */
+			if ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {
+				fcport->d_id.b24 = new_fcport->d_id.b24;
+				fcport->loop_id = FC_NO_LOOP_ID;
+				fcport->flags |= (FCF_FABRIC_DEVICE |
+				    FCF_LOGIN_NEEDED);
+				fcport->flags &= ~FCF_PERSISTENT_BOUND;
+				break;
+			}
+
+			/*
+			 * If address the same and state FCS_ONLINE, nothing
+			 * changed.
+			 */
+			if (fcport->d_id.b24 == new_fcport->d_id.b24 &&
+			    atomic_read(&fcport->state) == FCS_ONLINE) {
+				break;
+			}
+
+			/*
+			 * Port ID changed or device was marked to be updated;
+			 * Log it out if still logged in and mark it for
+			 * relogin later.
+			 */
+			fcport->d_id.b24 = new_fcport->d_id.b24;
+			fcport->flags |= FCF_LOGIN_NEEDED;
+			if (fcport->loop_id != FC_NO_LOOP_ID &&
+			    (fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+			    fcport->port_type != FCT_INITIATOR &&
+			    fcport->port_type != FCT_BROADCAST) {
+				qla2x00_fabric_logout(ha, fcport->loop_id);
+				fcport->loop_id = FC_NO_LOOP_ID;
+			}
+
+			break;
+		}
+
+		if (found)
+			continue;
+
+		/* If device was not in our fcports list, then add it. */
+		list_add_tail(&new_fcport->list, new_fcports);
+
+		/* Allocate a new replacement fcport. */
+		nxt_d_id.b24 = new_fcport->d_id.b24;
+		new_fcport = qla2x00_alloc_fcport(ha, GFP_KERNEL);
+		if (new_fcport == NULL) {
+			if (swl)
+				kfree(swl);
+			return (QLA_MEMORY_ALLOC_FAILED);
+		}
+		new_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);
+		new_fcport->d_id.b24 = nxt_d_id.b24;
+	}
+
+	if (swl)
+		kfree(swl);
+
+	if (new_fcport)
+		kfree(new_fcport);
+
+	if (!list_empty(new_fcports))
+		ha->device_flags |= DFLG_FABRIC_DEVICES;
+
+	return (rval);
+}
+
+/*
+ * qla2x00_find_new_loop_id
+ *	Scan through our port list and find a new usable loop ID.
+ *
+ * Input:
+ *	ha:	adapter state pointer.
+ *	dev:	port structure pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_find_new_loop_id(scsi_qla_host_t *ha, fc_port_t *dev)
+{
+	int	rval;
+	int	found;
+	fc_port_t *fcport;
+	uint16_t first_loop_id;
+
+	rval = QLA_SUCCESS;
+
+	/* Save starting loop ID. */
+	first_loop_id = dev->loop_id;
+
+	for (;;) {
+		/* Skip loop ID if already used by adapter. */
+		if (dev->loop_id == ha->loop_id) {
+			dev->loop_id++;
+		}
+
+		/* Skip reserved loop IDs. */
+		while (RESERVED_LOOP_ID(dev->loop_id)) {
+			dev->loop_id++;
+		}
+
+		/* Reset loop ID if passed the end. */
+		if (dev->loop_id > ha->last_loop_id) {
+			/* first loop ID. */
+			dev->loop_id = ha->min_external_loopid;
+		}
+
+		/* Check for loop ID being already in use. */
+		found = 0;
+		fcport = NULL;
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (fcport->loop_id == dev->loop_id && fcport != dev) {
+				/* ID possibly in use */
+				found++;
+				break;
+			}
+		}
+
+		/* If not in use then it is free to use. */
+		if (!found) {
+			break;
+		}
+
+		/* ID in use. Try next value. */
+		dev->loop_id++;
+
+		/* If wrap around. No free ID to use. */
+		if (dev->loop_id == first_loop_id) {
+			dev->loop_id = FC_NO_LOOP_ID;
+			rval = QLA_FUNCTION_FAILED;
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_device_resync
+ *	Marks devices in the database that needs resynchronization.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_device_resync(scsi_qla_host_t *ha) 
+{
+	int	rval;
+	int	rval2;
+	uint32_t mask;
+	fc_port_t *fcport;
+	uint32_t rscn_entry;
+	uint8_t rscn_out_iter;
+	uint8_t format;
+	port_id_t d_id;
+
+	rval = QLA_RSCNS_HANDLED;
+
+	while (ha->rscn_out_ptr != ha->rscn_in_ptr ||
+	    ha->flags.rscn_queue_overflow) {
+
+		rscn_entry = ha->rscn_queue[ha->rscn_out_ptr];
+		format = MSB(MSW(rscn_entry));
+		d_id.b.domain = LSB(MSW(rscn_entry));
+		d_id.b.area = MSB(LSW(rscn_entry));
+		d_id.b.al_pa = LSB(LSW(rscn_entry));
+
+		DEBUG(printk("scsi(%ld): RSCN queue entry[%d] = "
+		    "[%02x/%02x%02x%02x].\n",
+		    ha->host_no, ha->rscn_out_ptr, format, d_id.b.domain,
+		    d_id.b.area, d_id.b.al_pa));
+
+		ha->rscn_out_ptr++;
+		if (ha->rscn_out_ptr == MAX_RSCN_COUNT)
+			ha->rscn_out_ptr = 0;
+
+		/* Skip duplicate entries. */
+		for (rscn_out_iter = ha->rscn_out_ptr;
+		    !ha->flags.rscn_queue_overflow &&
+		    rscn_out_iter != ha->rscn_in_ptr;
+		    rscn_out_iter = (rscn_out_iter ==
+			(MAX_RSCN_COUNT - 1)) ? 0: rscn_out_iter + 1) {
+
+			if (rscn_entry != ha->rscn_queue[rscn_out_iter])
+				break;
+
+			DEBUG(printk("scsi(%ld): Skipping duplicate RSCN queue "
+			    "entry found at [%d].\n", ha->host_no,
+			    rscn_out_iter));
+
+			ha->rscn_out_ptr = rscn_out_iter;
+		}
+
+		/* Queue overflow, set switch default case. */
+		if (ha->flags.rscn_queue_overflow) {
+			DEBUG(printk("scsi(%ld): device_resync: rscn "
+			    "overflow.\n", ha->host_no));
+
+			format = 3;
+			ha->flags.rscn_queue_overflow = 0;
+		}
+
+		switch (format) {
+		case 0:
+			if (IS_QLA23XX(ha) && ha->flags.init_done) {
+				/* Handle port RSCN via asyncronous IOCBs */
+				rval2 = qla2x00_handle_port_rscn(ha, rscn_entry,
+				    NULL, 0);
+				if (rval2 == QLA_SUCCESS)
+					continue;
+			}
+			mask = 0xffffff;
+			break;
+		case 1:
+			mask = 0xffff00;
+			break;
+		case 2:
+			mask = 0xff0000;
+			break;
+		default:
+			mask = 0x0;
+			d_id.b24 = 0;
+			ha->rscn_out_ptr = ha->rscn_in_ptr;
+			break;
+		}
+
+		rval = QLA_SUCCESS;
+
+		/* Abort any outstanding IO descriptors. */
+		if (IS_QLA23XX(ha))
+			qla2x00_cancel_io_descriptors(ha);
+
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if ((fcport->flags & FCF_FABRIC_DEVICE) == 0 ||
+			    (fcport->d_id.b24 & mask) != d_id.b24 ||
+			    fcport->port_type == FCT_BROADCAST)
+				continue;
+
+			if (atomic_read(&fcport->state) == FCS_ONLINE) {
+				if (format != 3 ||
+				    fcport->port_type != FCT_INITIATOR) {
+					atomic_set(&fcport->state,
+					    FCS_DEVICE_LOST);
+				}
+			}
+			fcport->flags &= ~FCF_FARP_DONE;
+		}
+	}
+	return (rval);
+}
+
+/*
+ * qla2x00_fabric_dev_login
+ *	Login fabric target device and update FC port database.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		port structure list pointer.
+ *	next_loopid:	contains value of a new loop ID that can be used
+ *			by the next login attempt.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_fabric_dev_login(scsi_qla_host_t *ha, fc_port_t *fcport,
+    uint16_t *next_loopid)
+{
+	int	rval;
+	int	retry;
+
+	rval = QLA_SUCCESS;
+	retry = 0;
+
+	rval = qla2x00_fabric_login(ha, fcport, next_loopid);
+	if (rval == QLA_SUCCESS) {
+		rval = qla2x00_get_port_database(ha, fcport, BIT_1 | BIT_0);
+		if (rval != QLA_SUCCESS) {
+			qla2x00_fabric_logout(ha, fcport->loop_id);
+		} else {
+			qla2x00_update_fcport(ha, fcport);
+		}
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_fabric_login
+ *	Issue fabric login command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	device = pointer to FC device type structure.
+ *
+ * Returns:
+ *      0 - Login successfully
+ *      1 - Login failed
+ *      2 - Initiator device
+ *      3 - Fatal error
+ */
+int
+qla2x00_fabric_login(scsi_qla_host_t *ha, fc_port_t *fcport,
+    uint16_t *next_loopid)
+{
+	int	rval;
+	int	retry;
+	uint16_t tmp_loopid;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+	retry = 0;
+	tmp_loopid = 0;
+
+	for (;;) {
+		DEBUG(printk("scsi(%ld): Trying Fabric Login w/loop id 0x%04x "
+ 		    "for port %02x%02x%02x.\n",
+ 		    ha->host_no, fcport->loop_id, fcport->d_id.b.domain,
+		    fcport->d_id.b.area, fcport->d_id.b.al_pa));
+
+		/* Login fcport on switch. */
+		qla2x00_login_fabric(ha, fcport->loop_id,
+		    fcport->d_id.b.domain, fcport->d_id.b.area,
+		    fcport->d_id.b.al_pa, mb, BIT_0);
+		if (mb[0] == MBS_PORT_ID_USED) {
+			/*
+			 * Device has another loop ID.  The firmware team
+			 * recommends us to perform an implicit login with the
+			 * specified ID again. The ID we just used is save here
+			 * so we return with an ID that can be tried by the
+			 * next login.
+			 */
+			retry++;
+			tmp_loopid = fcport->loop_id;
+			fcport->loop_id = mb[1];
+
+			DEBUG(printk("Fabric Login: port in use - next "
+ 			    "loop id=0x%04x, port Id=%02x%02x%02x.\n",
+			    fcport->loop_id, fcport->d_id.b.domain,
+			    fcport->d_id.b.area, fcport->d_id.b.al_pa));
+
+		} else if (mb[0] == MBS_COMMAND_COMPLETE) {
+			/*
+			 * Login succeeded.
+			 */
+			if (retry) {
+				/* A retry occurred before. */
+				*next_loopid = tmp_loopid;
+			} else {
+				/*
+				 * No retry occurred before. Just increment the
+				 * ID value for next login.
+				 */
+				*next_loopid = (fcport->loop_id + 1);
+			}
+
+			if (mb[1] & BIT_0) {
+				fcport->port_type = FCT_INITIATOR;
+			} else {
+				fcport->port_type = FCT_TARGET;
+				if (mb[1] & BIT_1) {
+					fcport->flags |= FCF_TAPE_PRESENT;
+				}
+			}
+
+			rval = QLA_SUCCESS;
+			break;
+		} else if (mb[0] == MBS_LOOP_ID_USED) {
+			/*
+			 * Loop ID already used, try next loop ID.
+			 */
+			fcport->loop_id++;
+			rval = qla2x00_find_new_loop_id(ha, fcport);
+			if (rval != QLA_SUCCESS) {
+				/* Ran out of loop IDs to use */
+				break;
+			}
+		} else if (mb[0] == MBS_COMMAND_ERROR) {
+			/*
+			 * Firmware possibly timed out during login. If NO
+			 * retries are left to do then the device is declared
+			 * dead.
+			 */
+			*next_loopid = fcport->loop_id;
+			qla2x00_fabric_logout(ha, fcport->loop_id);
+			fcport->loop_id = FC_NO_LOOP_ID;
+
+			rval = 3;
+			break;
+		} else {
+			/*
+			 * unrecoverable / not handled error
+			 */
+			DEBUG2(printk("%s(%ld): failed=%x port_id=%02x%02x%02x "
+ 			    "loop_id=%x jiffies=%lx.\n", 
+ 			    __func__, ha->host_no, mb[0], 
+			    fcport->d_id.b.domain, fcport->d_id.b.area,
+			    fcport->d_id.b.al_pa, fcport->loop_id, jiffies));
+
+			*next_loopid = fcport->loop_id;
+			qla2x00_fabric_logout(ha, fcport->loop_id);
+			fcport->loop_id = FC_NO_LOOP_ID;
+			atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+
+			rval = 1;
+			break;
+		}
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_local_device_login
+ *	Issue local device login command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = loop id of device to login to.
+ *
+ * Returns (Where's the #define!!!!):
+ *      0 - Login successfully
+ *      1 - Login failed
+ *      3 - Fatal error
+ */
+int
+qla2x00_local_device_login(scsi_qla_host_t *ha, uint16_t loop_id)
+{
+	int		rval;
+	uint16_t	mb[MAILBOX_REGISTER_COUNT];
+
+	memset(mb, 0, sizeof(mb));
+	rval = qla2x00_login_local_device(ha, loop_id, mb, BIT_0);
+	if (rval == QLA_SUCCESS) {
+		/* Interrogate mailbox registers for any errors */
+		if (mb[0] == MBS_COMMAND_ERROR)
+			rval = 1;
+		else if (mb[0] == MBS_COMMAND_PARAMETER_ERROR)
+			/* device not in PCB table */
+			rval = 3;
+	}
+
+	return (rval);
+}
+
+/*
+ *  qla2x00_loop_resync
+ *      Resync with fibre channel devices.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success
+ */
+int
+qla2x00_loop_resync(scsi_qla_host_t *ha) 
+{
+	int   rval;
+
+	rval = QLA_SUCCESS;
+
+	atomic_set(&ha->loop_state, LOOP_UPDATE);
+	qla2x00_stats.loop_resync++;
+	clear_bit(ISP_ABORT_RETRY, &ha->dpc_flags);
+	if (ha->flags.online) {
+		if (!(rval = qla2x00_fw_ready(ha))) {
+			do {
+				/* v2.19.05b6 */
+				atomic_set(&ha->loop_state, LOOP_UPDATE);
+
+				/*
+				 * Issue marker command only when we are going
+				 * to start the I/O .
+				 */
+				ha->marker_needed = 1;
+
+				/* Remap devices on Loop. */
+				clear_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+
+				qla2x00_configure_loop(ha);
+
+			} while (!atomic_read(&ha->loop_down_timer) &&
+				!(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags)) &&
+				(test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags)));
+		}
+		qla2x00_restart_queues(ha,TRUE);
+	}
+
+	if (test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags)) {
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	if (rval) {
+		DEBUG2_3(printk("%s(): **** FAILED ****\n", __func__));
+	}
+
+	return (rval);
+}
+
+/*
+ *  qla2x00_restart_queues
+ *	Restart device queues.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ */
+void
+qla2x00_restart_queues(scsi_qla_host_t *ha, uint8_t flush) 
+{
+	srb_t  		*sp;
+	int		retry_q_cnt = 0;
+	int		pending_q_cnt = 0;
+	struct list_head *list, *temp;
+	unsigned long flags = 0;
+
+	ENTER(__func__);
+
+	clear_bit(RESTART_QUEUES_NEEDED, &ha->dpc_flags);
+
+	/*
+	 * start pending queue
+	 */
+	pending_q_cnt = ha->qthreads;
+	if (flush) {
+		spin_lock_irqsave(&ha->list_lock,flags);
+		list_for_each_safe(list, temp, &ha->pending_queue) {
+			sp = list_entry(list, srb_t, list);
+			/* 
+			 * When time expire return request back to OS as BUSY 
+			 */
+			__del_from_pending_queue(ha, sp);
+			sp->cmd->result = DID_BUS_BUSY << 16;
+			sp->cmd->host_scribble = (unsigned char *)NULL;
+			__add_to_done_queue(ha, sp);
+		}
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+	} else {
+		if (!list_empty(&ha->pending_queue))
+			qla2x00_next(ha);
+	}
+
+	/*
+	 * Clear out our retry queue
+	 */
+	if (flush) {
+		spin_lock_irqsave(&ha->list_lock, flags);
+		retry_q_cnt = ha->retry_q_cnt;
+		list_for_each_safe(list, temp, &ha->retry_queue) {
+			sp = list_entry(list, srb_t, list);
+			/* when time expire return request back to OS as BUSY */
+			__del_from_retry_queue(ha, sp);
+			sp->cmd->result = DID_BUS_BUSY << 16;
+			sp->cmd->host_scribble = (unsigned char *)NULL;
+			__add_to_done_queue(ha, sp);
+		}
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+
+		DEBUG2(printk("%s(%ld): callback %d commands.\n",
+				__func__,
+				ha->host_no,
+				retry_q_cnt);)
+	}
+
+	DEBUG2(printk("%s(%ld): active=%ld, retry=%d, pending=%d, "
+			"done=%ld, scsi retry=%d commands.\n",
+			__func__,
+			ha->host_no,
+			ha->actthreads,
+			ha->retry_q_cnt,
+			pending_q_cnt,
+			ha->done_q_cnt,
+			ha->scsi_retry_q_cnt);)
+
+	if (!list_empty(&ha->done_queue))
+		qla2x00_done(ha);
+
+	LEAVE(__func__);
+}
+
+//FIXME - Document
+void
+qla2x00_rescan_fcports(scsi_qla_host_t *ha)
+{
+	int rescan_done;
+	fc_port_t *fcport;
+
+	rescan_done = 0;
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if ((fcport->flags & FCF_RESCAN_NEEDED) == 0)
+			continue;
+
+		qla2x00_update_fcport(ha, fcport);
+		fcport->flags &= ~FCF_RESCAN_NEEDED;
+
+		rescan_done = 1;
+	}
+
+	/* Update OS target and lun structures if necessary. */
+	if (rescan_done)
+		qla2x00_config_os(ha);
+}
+
+
+/*
+ * qla2x00_config_os
+ *	Setup OS target and LUN structures.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla2x00_config_os(scsi_qla_host_t *ha) 
+{
+	fc_port_t	*fcport;
+	fc_lun_t	*fclun;
+	os_tgt_t	*tq;
+	uint16_t	tgt;
+
+
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		tq->flags &= ~TQF_ONLINE;
+	}
+
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		if (atomic_read(&fcport->state) != FCS_ONLINE ||
+		    fcport->port_type == FCT_INITIATOR ||
+		    fcport->port_type == FCT_BROADCAST) {
+			fcport->os_target_id = MAX_TARGETS;
+			continue;
+		}
+
+		if (fcport->flags & FCF_FO_MASKED) {
+			continue;
+		}
+
+		/* Bind FC port to OS target number. */
+		if (qla2x00_fcport_bind(ha, fcport) == MAX_TARGETS) {
+			continue;
+		}
+
+		/* Bind FC LUN to OS LUN number. */
+		list_for_each_entry(fclun, &fcport->fcluns, list) {
+			qla2x00_fclun_bind(ha, fcport, fclun);
+		}
+	}
+}
+
+/*
+ * qla2x00_fcport_bind
+ *	Locates a target number for FC port.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	fcport = FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+static uint16_t
+qla2x00_fcport_bind(scsi_qla_host_t *ha, fc_port_t *fcport) 
+{
+	uint16_t	tgt;
+	os_tgt_t	*tq;
+
+	/* Check for persistent binding. */
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = TGT_Q(ha, tgt)) == NULL)
+			continue;
+
+		if (ha->binding_type == BIND_BY_PORT_ID &&
+		    fcport->d_id.b24 == tq->d_id.b24) {
+			memcpy(tq->node_name, fcport->node_name, WWN_SIZE);
+			memcpy(tq->port_name, fcport->port_name, WWN_SIZE);
+			break;
+		}
+
+		if (memcmp(fcport->port_name, tq->port_name, WWN_SIZE) == 0) {
+			/* In case of persistent binding, update the WWNN */
+			memcpy(tq->node_name, fcport->node_name, WWN_SIZE);
+			break;
+		}
+	}
+
+	/* TODO: honor the ConfigRequired flag */
+	if (tgt == MAX_TARGETS) {
+		/* Check if targetID 0 available. */
+		tgt = 0;
+
+		if (TGT_Q(ha, tgt) != NULL) {
+			/* Locate first free target for device. */
+			for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+				if (TGT_Q(ha, tgt) == NULL) {
+					break;
+				}
+			}
+		}
+		if (tgt != MAX_TARGETS) {
+			if ((tq = qla2x00_tgt_alloc(ha, tgt)) != NULL) {
+				memcpy(tq->node_name, fcport->node_name,
+				    WWN_SIZE);
+				memcpy(tq->port_name, fcport->port_name,
+				    WWN_SIZE);
+				tq->d_id.b24 = fcport->d_id.b24;
+			}
+		}
+	}
+
+	/* Reset target numbers incase it changed. */
+	fcport->os_target_id = tgt;
+	if (tgt != MAX_TARGETS && tq != NULL) {
+		DEBUG2(printk("scsi(%ld): Assigning target ID=%02d @ %p to "
+		    "loop id=0x%04x, port state=0x%x, port down retry=%d\n",
+		    ha->host_no, tgt, tq, fcport->loop_id,
+		    atomic_read(&fcport->state),
+		    atomic_read(&fcport->port_down_timer)));
+
+		fcport->tgt_queue = tq;
+		fcport->flags |= FCF_PERSISTENT_BOUND;
+		tq->fcport = fcport;
+		tq->flags |= TQF_ONLINE;
+		tq->port_down_retry_count = ha->port_down_retry_count;
+
+	}
+
+	if (tgt == MAX_TARGETS) {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to bind fcport, loop_id=%x\n", fcport->loop_id);
+	}
+
+	return (tgt);
+}
+
+/*
+ * qla2x00_fclun_bind
+ *	Binds all FC device LUNS to OS LUNS.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	fcport:		FC port structure pointer.
+ *
+ * Returns:
+ *	target number
+ *
+ * Context:
+ *	Kernel context.
+ */
+static os_lun_t *
+qla2x00_fclun_bind(scsi_qla_host_t *ha, fc_port_t *fcport, fc_lun_t *fclun)
+{
+	os_lun_t	*lq;
+	uint16_t	tgt;
+	uint16_t	lun;
+
+	tgt = fcport->os_target_id;
+	lun = fclun->lun;
+
+	/* Allocate LUNs */
+	if (lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi(%ld): Unable to bind lun, invalid "
+		    "lun=(%x).\n", ha->host_no, lun));
+		return (NULL);
+	}
+
+	/* Always alloc LUN 0 so kernel will scan past LUN 0. */
+	if (lun != 0 && (EXT_IS_LUN_BIT_SET(&(fcport->lun_mask), lun))) {
+		return (NULL);
+	}
+
+	if ((lq = qla2x00_lun_alloc(ha, tgt, lun)) == NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to bind fclun, loop_id=%x lun=%x\n",
+		    fcport->loop_id, lun);
+		return (NULL);
+	}
+
+	lq->fclun = fclun;
+
+	return (lq);
+}
+
+/*
+ * qla2x00_tgt_alloc
+ *	Allocate and pre-initialize target queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_tgt_t *
+qla2x00_tgt_alloc(scsi_qla_host_t *ha, uint16_t tgt) 
+{
+	os_tgt_t	*tq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi(%ld): Unable to allocate target, invalid "
+		    "target number %d.\n", ha->host_no, tgt));
+		return (NULL);
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq == NULL) {
+		tq = kmalloc(sizeof(os_tgt_t), GFP_ATOMIC);
+		if (tq != NULL) {
+			DEBUG2(printk("scsi(%ld): Alloc Target %d @ %p\n",
+			    ha->host_no, tgt, tq));
+
+			memset(tq, 0, sizeof(os_tgt_t));
+			tq->ha = ha;
+
+			TGT_Q(ha, tgt) = tq;
+		}
+	}
+	if (tq != NULL) {
+		tq->port_down_retry_count = ha->port_down_retry_count;
+	} else {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to allocate target.\n");
+		ha->mem_err++;
+	}
+
+	return (tq);
+}
+
+/*
+ * qla2x00_tgt_free
+ *	Frees target and LUN queues.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla2x00_tgt_free(scsi_qla_host_t *ha, uint16_t tgt) 
+{
+	os_tgt_t	*tq;
+	uint16_t	lun;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS) {
+		DEBUG2(printk("scsi(%ld): Unable to de-allocate target, "
+		    "invalid target number %d.\n", ha->host_no, tgt));
+
+		return;
+	}
+
+	tq = TGT_Q(ha, tgt);
+	if (tq != NULL) {
+		TGT_Q(ha, tgt) = NULL;
+
+		/* Free LUN structures. */
+		for (lun = 0; lun < MAX_LUNS; lun++)
+			qla2x00_lun_free(ha, tgt, lun);
+
+		kfree(tq);
+	}
+
+	return;
+}
+
+/*
+ * qla2x00_lun_alloc
+ *	Allocate and initialize LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *	l = LUN number.
+ *
+ * Returns:
+ *	NULL = failure
+ *
+ * Context:
+ *	Kernel context.
+ */
+os_lun_t *
+qla2x00_lun_alloc(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun) 
+{
+	os_lun_t	*lq;
+
+	/*
+	 * If SCSI addressing OK, allocate LUN queue.
+	 */
+	if (tgt >= MAX_TARGETS || lun >= MAX_LUNS || TGT_Q(ha, tgt) == NULL) {
+		DEBUG2(printk("scsi(%ld): Unable to allocate lun, invalid "
+		    "parameter.\n", ha->host_no));
+
+		return (NULL);
+	}
+
+	lq = LUN_Q(ha, tgt, lun);
+	if (lq == NULL) {
+		lq = kmalloc(sizeof(os_lun_t), GFP_ATOMIC);
+		if (lq != NULL) {
+			DEBUG2(printk("scsi(%ld): Alloc Lun %d @ tgt %d.\n",
+			    ha->host_no, lun, tgt));
+
+			memset(lq, 0, sizeof (os_lun_t));
+			LUN_Q(ha, tgt, lun) = lq;
+
+			/*
+			 * The following lun queue initialization code
+			 * must be duplicated in alloc_ioctl_mem function
+			 * for ioctl_lq.
+			 */
+			lq->q_state = LUN_STATE_READY;
+			spin_lock_init(&lq->q_lock);
+		}
+	}
+
+	if (lq == NULL) {
+		qla_printk(KERN_WARNING, ha, "Unable to allocate lun.\n");
+	}
+
+	return (lq);
+}
+
+/*
+ * qla2x00_lun_free
+ *	Frees LUN queue.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI target number.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla2x00_lun_free(scsi_qla_host_t *ha, uint16_t tgt, uint16_t lun) 
+{
+	os_lun_t	*lq;
+
+	/*
+	 * If SCSI addressing OK, allocate TGT queue and lock.
+	 */
+	if (tgt >= MAX_TARGETS || lun >= MAX_LUNS) {
+		DEBUG2(printk("scsi(%ld): Unable to deallocate lun, invalid "
+		    "parameter.\n", ha->host_no));
+
+		return;
+	}
+
+	if (TGT_Q(ha, tgt) != NULL && (lq = LUN_Q(ha, tgt, lun)) != NULL) {
+		LUN_Q(ha, tgt, lun) = NULL;
+		kfree(lq);
+	}
+
+	return;
+}
+
+
+/*
+ * qla2x00_bstr_to_hex
+ *	Convert hex byte string to number.
+ *
+ * Input:
+ *	s = byte string pointer.
+ *	bp = byte pointer for number.
+ *	size = number of bytes.
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ */
+static int
+qla2x00_bstr_to_hex(char *s, uint8_t *bp, int size) 
+{
+	int		cnt;
+	uint8_t		n;
+
+	for (cnt = 0; *s != '\0' && cnt / 2 < size; cnt++) {
+		if (*s >= 'A' && *s <= 'F') {
+			n = (*s++ - 'A') + 10;
+		} else if (*s >= 'a' && *s <= 'f') {
+			n = (*s++ - 'a') + 10;
+		} else if (*s >= '0' && *s <= '9') {
+			n = *s++ - '0';
+		} else {
+			cnt = 0;
+			break;
+		}
+
+		if (cnt & BIT_0)
+			*bp++ |= n;
+		else
+			*bp = n << 4;
+	}
+
+	/* fixme(dg) Need to swap data little endian */
+
+	return (cnt / 2);
+}
+
+/*
+ * qla2x00_get_prop_xstr
+ *      Get a string property value for the specified property name and
+ *      convert from the property string found in the configuration file,
+ *      which are ASCII characters representing nibbles, 2 characters represent
+ *      the hexdecimal value for a byte in the byte array.
+ *      The byte array is initialized to zero.
+ *      The resulting converted value is in big endian format (MSB at byte0).
+ *
+ * Input:
+ *      ha = adapter state pointer.
+ *      propname = property name pointer.
+ *      propval  = pointer where to store converted property val.
+ *      size = max or expected size of 'propval' array.
+ *
+ * Returns:
+ *      0 = empty value string or invalid character in string
+ *      >0 = count of characters converted
+ *      -1 = property not found
+ *
+ * Context:
+ *      Kernel context.
+ */
+int
+qla2x00_get_prop_xstr(scsi_qla_host_t *ha, 
+		char *propname, uint8_t *propval, int size) 
+{
+	char		*propstr;
+	int		rval = -1;
+	static char	buf[LINESIZE];
+
+	/* Get the requested property string */
+	rval = qla2x00_find_propname(ha, propname, buf, ha->cmdline, size*2);
+	DEBUG3(printk("%s(): Ret rval from find propname = %d\n",
+			__func__,
+			rval);)
+
+	propstr = &buf[0];
+	if (*propstr == '=')
+		propstr++;   /* ignore equal sign */
+
+	if (rval == 0) {  /* not found */
+		LEAVE(__func__);
+		return (-1);
+	}
+
+	rval = qla2x00_bstr_to_hex(propstr, (uint8_t *)propval, size);
+	if (rval == 0) {
+		/* Invalid character in value string */
+		qla_printk(KERN_INFO, ha,
+			"%s(): %s Invalid hex string for property\n",
+			__func__,
+			propname);
+		qla_printk(KERN_INFO, ha,
+			" Invalid string - %s\n", 
+			propstr);
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_find_propname
+ *	Get property in database.
+ *
+ * Input:
+ *	ha = adapter structure pointer.
+ *      db = pointer to database
+ *      propstr = pointer to dest array for string
+ *	propname = name of property to search for.
+ *	siz = size of property
+ *
+ * Returns:
+ *	0 = no property
+ *      size = index of property
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_find_propname(scsi_qla_host_t *ha, 
+			char *propname, char *propstr, 
+			char *db, int siz) 
+{
+	char	*cp;
+
+	/* find the specified string */
+	if (db) {
+		/* find the property name */
+		if ((cp = strstr(db,propname)) != NULL) {
+			while ((*cp)  && *cp != '=')
+				cp++;
+			if (*cp) {
+				strncpy(propstr, cp, siz+1);
+				propstr[siz+1] = '\0';
+				DEBUG(printk("qla2x00_find_propname: found "
+						"property = {%s}\n",
+						propstr);)
+				return (siz);   /* match */
+			}
+		}
+	}
+
+	return (0);
+}
+
+#if 0
+/*
+ * qla2x00_get_prop_16chars
+ *	Get an 8-byte property value for the specified property name by
+ *      converting from the property string found in the configuration file.
+ *      The resulting converted value is in big endian format (MSB at byte0).
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	propname = property name pointer.
+ *	propval  = pointer to location for the converted property val.
+ *      db = pointer to database
+ *
+ * Returns:
+ *	0 = value returned successfully.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_get_prop_16chars(scsi_qla_host_t *ha,
+				char *propname, char *propval, char *db) 
+{
+	char		*propstr;
+	int		i, k;
+	int		rval;
+	uint8_t		nval;
+	uint8_t		*pchar;
+	uint8_t		*ret_byte;
+	uint8_t		*tmp_byte;
+	uint8_t		*retval = (uint8_t*)propval;
+	uint8_t		tmpval[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+	uint16_t	max_byte_cnt = 8; /* 16 chars = 8 bytes */
+	uint16_t	max_strlen = 16;
+	static char	buf[LINESIZE];
+
+	rval = qla2x00_find_propname(ha, propname, buf, db, max_strlen);
+
+	propstr = &buf[0];
+	if (*propstr == '=')
+		propstr++;   /* ignore equal sign */
+
+	if (rval == 0) {
+		return (1);
+	}
+
+	/* Convert string to numbers. */
+	pchar = (uint8_t *)propstr;
+	tmp_byte = (uint8_t *)tmpval;
+
+	rval = 0;
+	for (i = 0; i < max_strlen; i++) {
+		/*
+		 * Check for invalid character, two at a time,
+		 * then convert them starting with first byte.
+		 */
+
+		if ((pchar[i] >= '0') && (pchar[i] <= '9')) {
+			nval = pchar[i] - '0';
+		} else if ((pchar[i] >= 'A') && (pchar[i] <= 'F')) {
+			nval = pchar[i] - 'A' + 10;
+		} else if ((pchar[i] >= 'a') && (pchar[i] <= 'f')) {
+			nval = pchar[i] - 'a' + 10;
+		} else {
+			/* invalid character */
+			rval = 1;
+			break;
+		}
+
+		if (i & BIT_0) {
+			*tmp_byte = *tmp_byte | nval;
+			tmp_byte++;
+		} else {
+			*tmp_byte = *tmp_byte | nval << 4;
+		}
+	}
+
+	if (rval != 0) {
+		/* Encountered invalid character. */
+		return (rval);
+	}
+
+	/* Copy over the converted value. */
+	ret_byte = retval;
+	tmp_byte = tmpval;
+
+	i = max_byte_cnt;
+	k = 0;
+	while (i--) {
+		*ret_byte++ = *tmp_byte++;
+	}
+
+	/* big endian retval[0]; */
+	return (0);
+}
+
+/*
+* qla2x00_get_properties
+*	Find all properties for the specified adapeter in
+*      command line.
+*
+* Input:
+*	ha = adapter block pointer.
+*	cmdline = pointer to command line string
+*
+* Context:
+*	Kernel context.
+*/
+static void
+qla2x00_get_properties(scsi_qla_host_t *ha, char *cmdline) 
+{
+	int	rval;
+	static char propbuf[LINESIZE];
+	uint8_t fc_name[8];
+
+	/* Adapter FC node names. */
+	sprintf(propbuf, "scsi-qla%d-adapter-node", (int) ha->instance);
+	rval = qla2x00_get_prop_16chars(ha, propbuf, fc_name, cmdline);
+	if (rval == QLA_SUCCESS)
+		memcpy(ha->init_cb->node_name, fc_name, WWN_SIZE);
+
+	/* DG 04/07 check portname of adapter */
+	sprintf(propbuf, "scsi-qla%d-adapter-port", (int)ha->instance);
+	rval = qla2x00_get_prop_16chars(ha, propbuf, fc_name, cmdline);
+	if (rval == QLA_SUCCESS &&
+	    memcmp(ha->init_cb->port_name, fc_name, WWN_SIZE)) {
+		/*
+		 * Adapter port name is WWN, and cannot be changed.
+		 * Inform users of the mismatch, then just continue driver
+		 * loading using the original adapter port name in NVRAM.
+		 */
+		qla_printk(KERN_WARNING, ha,
+		    "Found mismatch in adapter port names.\n");
+		qla_printk(KERN_INFO, ha,
+		    "       qla%ld port name found in NVRAM -> "
+		    "%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		    ha->instance,
+		    ha->init_cb->port_name[0],
+		    ha->init_cb->port_name[1],
+		    ha->init_cb->port_name[2],
+		    ha->init_cb->port_name[3],
+		    ha->init_cb->port_name[4],
+		    ha->init_cb->port_name[5],
+		    ha->init_cb->port_name[6],
+		    ha->init_cb->port_name[7]);
+		qla_printk(KERN_INFO, ha,
+		    "      qla%ld port name found on command line -> "
+		    "%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		    ha->instance,
+		    fc_name[0], fc_name[1], fc_name[2], fc_name[3],
+		    fc_name[4], fc_name[5], fc_name[6], fc_name[7]);
+		qla_printk(KERN_INFO, ha,
+		    "      Using port name from NVRAM.\n");
+	}
+
+	qla2x00_cfg_persistent_binding(ha);
+}
+
+/*
+ * qla2x00_cfg_persistent_binding
+ *	Get driver configuration file target persistent binding entries.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static void
+qla2x00_cfg_persistent_binding(scsi_qla_host_t *ha) 
+{
+	int		rval;
+	static char	propbuf[LINESIZE];
+	char		*cmdline = ha->cmdline;
+	uint16_t	tgt;
+	port_id_t	d_id;
+	uint8_t		portid[3];
+	uint8_t		port_name[8];
+
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if (ha->binding_type == BIND_BY_PORT_ID) {
+			sprintf(propbuf, "scsi-qla%d-tgt-%d-di-0-pid",
+			    (int)ha->instance, tgt);
+			rval = qla2x00_get_prop_xstr(ha,
+			    propbuf, portid, sizeof(portid));
+			if (rval != sizeof(portid))
+				continue;
+			
+			memset(&d_id, 0, sizeof(port_id_t));
+			d_id.r.d_id[0] = portid[2];
+			d_id.r.d_id[1] = portid[1];
+			d_id.r.d_id[2] = portid[0];
+		} else {
+			sprintf(propbuf, "scsi-qla%d-tgt-%d-di-0-port",
+			    (int)ha->instance, tgt);
+			rval = qla2x00_get_prop_16chars(ha,
+			    propbuf, port_name, cmdline);
+			if (rval != QLA_SUCCESS)
+				continue;
+
+			/* Fallthru since port_name already populated */
+		}
+
+		/*
+		 * Create target context for device.
+		 */
+		if (ha->binding_type == BIND_BY_PORT_ID) {
+			qla2x00_persistent_bind(ha, NULL, NULL, &d_id, tgt);
+		} else {
+			qla2x00_persistent_bind(ha, NULL, port_name, NULL, tgt);
+		}
+	}
+}
+
+/*
+ * qla2x00_persistent_bind
+ *	Allocates target and fcport.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	node_name:	node name pointer.
+ *	port_name:	port name pointer.
+ *	d_id:		port ID pointer.
+ *	tgt:		OS target number.
+ *
+ * Returns:
+ *	success = target queue pointer.
+ *	failure = NULL.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static os_tgt_t *
+qla2x00_persistent_bind(scsi_qla_host_t *ha, uint8_t *node_name,
+    uint8_t *port_name, port_id_t *d_id, uint16_t tgt)
+{
+	os_tgt_t	*tq;
+	uint16_t	tgt2;
+
+	/*
+	 * Check for duplicates.
+	 */
+	for (tgt2 = 0; tgt2 < MAX_TARGETS; tgt2++) {
+		if ((tq = TGT_Q(ha, tgt2)) == NULL) {
+			continue;
+		}
+
+		if (ha->binding_type == BIND_BY_PORT_ID) {
+			if (tq->d_id.b24 != d_id->b24) {
+				continue;
+			}
+		} else if (memcmp(tq->port_name, port_name, WWN_SIZE) != 0) {
+			continue;
+		}
+
+		qla_printk(KERN_WARNING, ha,
+		    "Duplicate persistent bindings found for "
+		    "WWPN: %02x%02x%02x%02x%02x%02x%02x%02x.\n", 
+		    port_name[0], port_name[1], port_name[2], port_name[3],
+		    port_name[4], port_name[5], port_name[6], port_name[7]);
+
+		return (tq);
+	}
+
+	tq = qla2x00_tgt_alloc(ha, tgt);
+	if (tq == NULL) {
+		return (NULL);
+	}
+
+	if (node_name != NULL) {
+		memcpy(tq->node_name, node_name, WWN_SIZE);
+	}
+	if (port_name != NULL) {
+		memcpy(tq->port_name, port_name, WWN_SIZE);
+	}
+	if (d_id != NULL) {
+		tq->d_id.b24 = d_id->b24;
+	}
+
+	return (tq);
+}
+#endif
+
+/*
+*  qla2x00_abort_isp
+*      Resets ISP and aborts all outstanding commands.
+*
+* Input:
+*      ha           = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+int
+qla2x00_abort_isp(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	uint16_t       cnt;
+	srb_t          *sp;
+	uint8_t        status = 0;
+
+	ENTER("qla2x00_abort_isp");
+
+	if (ha->flags.online) {
+		ha->flags.online = FALSE;
+		clear_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		qla2x00_stats.ispAbort++;
+		ha->total_isp_aborts++;  /* used by ioctl */
+		ha->sns_retry_cnt = 0;
+
+		qla_printk(KERN_INFO, ha,
+		    "Performing ISP error recovery - ha= %p.\n", ha);
+		qla2x00_reset_chip(ha);
+
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);
+			atomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		/* Requeue all commands in outstanding command list. */
+		for (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
+			sp = ha->outstanding_cmds[cnt];
+			if (sp) {
+				ha->outstanding_cmds[cnt] = 0;
+				if (ha->actthreads)
+					ha->actthreads--;
+				sp->lun_queue->out_cnt--;
+				sp->flags = 0;
+
+				/*
+				 * Set the cmd host_byte status depending on
+				 * whether the scsi_error_handler is
+				 * active or not.
+ 				 */
+				if (ha->host->eh_active != EH_ACTIVE) {
+					sp->cmd->result = DID_BUS_BUSY << 16;
+				} else {
+					sp->cmd->result = DID_RESET << 16;
+				}
+				sp->cmd->host_scribble = (unsigned char *)NULL;
+				add_to_done_queue(ha, sp);
+			}
+		}
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		qla2x00_nvram_config(ha);
+
+		if (!qla2x00_restart_isp(ha)) {
+			clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+
+			if (!atomic_read(&ha->loop_down_timer)) {
+				/*
+				 * Issue marker command only when we are going
+				 * to start the I/O .
+				 */
+				ha->marker_needed = 1;
+			}
+
+			ha->flags.online = TRUE;
+
+			/* Enable ISP interrupts. */
+			qla2x00_enable_intrs(ha);
+
+			/* v2.19.5b6 Return all commands */
+			qla2x00_abort_queues(ha, TRUE);
+
+			/* Restart queues that may have been stopped. */
+			qla2x00_restart_queues(ha,TRUE);
+			ha->isp_abort_cnt = 0; 
+			clear_bit(ISP_ABORT_RETRY, &ha->dpc_flags);
+		} else {	/* failed the ISP abort */
+			ha->flags.online = TRUE;
+			if (test_bit(ISP_ABORT_RETRY, &ha->dpc_flags)) {
+				if (ha->isp_abort_cnt == 0) {
+ 					qla_printk(KERN_WARNING, ha,
+					    "ISP error recovery failed - "
+					    "board disabled\n");
+					/* 
+					 * The next call disables the board
+					 * completely.
+					 */
+					qla2x00_reset_adapter(ha);
+					qla2x00_abort_queues(ha, FALSE);
+					ha->flags.online = FALSE;
+					clear_bit(ISP_ABORT_RETRY,
+					    &ha->dpc_flags);
+					status = 0;
+				} else { /* schedule another ISP abort */
+					ha->isp_abort_cnt--;
+					DEBUG(printk("qla%ld: ISP abort - "
+					    "retry remainning %d\n",
+					    ha->host_no, ha->isp_abort_cnt);)
+					status = 1;
+				}
+			} else {
+				ha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;
+				DEBUG(printk("qla2x00(%ld): ISP error recovery "
+				    "- retrying (%d) more times\n",
+				    ha->host_no, ha->isp_abort_cnt);)
+				set_bit(ISP_ABORT_RETRY, &ha->dpc_flags);
+				status = 1;
+			}
+		}
+		       
+	}
+
+	if (status) {
+		qla_printk(KERN_INFO, ha,
+			"qla2x00_abort_isp: **** FAILED ****\n");
+	} else {
+		DEBUG(printk(KERN_INFO
+				"qla2x00_abort_isp(%ld): exiting.\n",
+				ha->host_no);)
+	}
+
+	return(status);
+}
+
+/*
+*  qla2x00_restart_isp
+*      restarts the ISP after a reset
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+static int
+qla2x00_restart_isp(scsi_qla_host_t *ha)
+{
+	uint8_t		status = 0;
+	device_reg_t	*reg;
+	unsigned long	flags = 0;
+
+	/* If firmware needs to be loaded */
+	if (qla2x00_isp_firmware(ha)) {
+		ha->flags.online = FALSE;
+		if (!(status = qla2x00_chip_diag(ha))) {
+			if (!IS_QLA23XX(ha)) {
+				status = qla2x00_setup_chip(ha);
+				goto done;
+			}
+
+			reg = ha->iobase;
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+			/* Disable SRAM, Instruction RAM and GP RAM parity. */
+			WRT_REG_WORD(&reg->hccr, (HCCR_ENABLE_PARITY + 0x0));
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	
+			status = qla2x00_setup_chip(ha);
+
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+ 
+ 			/* Enable proper parity */
+ 			if (IS_QLA2312(ha) || IS_QLA2322(ha))
+ 				/* SRAM, Instruction RAM and GP RAM parity */
+ 				WRT_REG_WORD(&reg->hccr,
+ 				    (HCCR_ENABLE_PARITY + 0x7));
+ 			else
+ 				/* SRAM parity */
+ 				WRT_REG_WORD(&reg->hccr,
+ 				    (HCCR_ENABLE_PARITY + 0x1));
+
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+
+ done:
+	if (!status && !(status = qla2x00_init_rings(ha))) {
+		clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+		if (!(status = qla2x00_fw_ready(ha))) {
+			DEBUG(printk("%s(): Start configure loop, "
+					"status = %d\n",
+					__func__,
+					status);)
+			ha->flags.online = TRUE;
+			do {
+				clear_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+				qla2x00_configure_loop(ha);
+			} while (!atomic_read(&ha->loop_down_timer) &&
+				!(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags)) &&
+				(test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags)));
+		}
+
+		/* if no cable then assume it's good */
+		if ((ha->device_flags & DFLG_NO_CABLE)) 
+			status = 0;
+
+		DEBUG(printk("%s(): Configure loop done, status = 0x%x\n",
+				__func__,
+				status);)
+	}
+	return (status);
+}
+
+/*
+* qla2x00_reset_adapter
+*      Reset adapter.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+static void
+qla2x00_reset_adapter(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	device_reg_t *reg = ha->iobase;
+
+	ENTER(__func__);
+
+	ha->flags.online = FALSE;
+	qla2x00_disable_intrs(ha);
+	/* Reset RISC processor. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_WORD(&reg->hccr, HCCR_RESET_RISC);
+	WRT_REG_WORD(&reg->hccr, HCCR_RELEASE_RISC);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	LEAVE(__func__);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_inline.h linux-2.5/drivers/scsi/qla2xxx/qla_inline.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_inline.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_inline.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,242 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+
+static __inline__ uint16_t qla2x00_debounce_register(volatile uint16_t *);
+/*
+ * qla2x00_debounce_register
+ *      Debounce register.
+ *
+ * Input:
+ *      port = register address.
+ *
+ * Returns:
+ *      register value.
+ */
+static __inline__ uint16_t
+qla2x00_debounce_register(volatile uint16_t *addr) 
+{
+	volatile uint16_t first;
+	volatile uint16_t second;
+
+	do {
+		first = RD_REG_WORD(addr);
+		barrier();
+		cpu_relax();
+		second = RD_REG_WORD(addr);
+	} while (first != second);
+
+	return (first);
+}
+
+static __inline__ int qla2x00_normalize_dma_addr(
+    dma_addr_t *e_addr,  uint32_t *e_len,
+    dma_addr_t *ne_addr, uint32_t *ne_len);
+
+/**
+ * qla2x00_normalize_dma_addr() - Normalize an DMA address.
+ * @e_addr: Raw DMA address
+ * @e_len: Raw DMA length
+ * @ne_addr: Normalized second DMA address
+ * @ne_len: Normalized second DMA length
+ *
+ * If the address does not span a 4GB page boundary, the contents of @ne_addr
+ * and @ne_len are undefined.  @e_len is updated to reflect a normalization.
+ *
+ * Example:
+ *
+ * 	ffffabc0ffffeeee	(e_addr) start of DMA address
+ * 	0000000020000000	(e_len)  length of DMA transfer
+ *	ffffabc11fffeeed	end of DMA transfer
+ *
+ * Is the 4GB boundary crossed?
+ *
+ * 	ffffabc0ffffeeee	(e_addr)
+ *	ffffabc11fffeeed	(e_addr + e_len - 1)
+ *	00000001e0000003	((e_addr ^ (e_addr + e_len - 1))
+ *	0000000100000000	((e_addr ^ (e_addr + e_len - 1)) & ~(0xffffffff)
+ *
+ * Compute start of second DMA segment:
+ *
+ * 	ffffabc0ffffeeee	(e_addr)
+ *	ffffabc1ffffeeee	(0x100000000 + e_addr)
+ *	ffffabc100000000	(0x100000000 + e_addr) & ~(0xffffffff)
+ *	ffffabc100000000	(ne_addr)
+ *	
+ * Compute length of second DMA segment:
+ *
+ *	00000000ffffeeee	(e_addr & 0xffffffff)
+ *	0000000000001112	(0x100000000 - (e_addr & 0xffffffff))
+ *	000000001fffeeee	(e_len - (0x100000000 - (e_addr & 0xffffffff))
+ *	000000001fffeeee	(ne_len)
+ *
+ * Adjust length of first DMA segment
+ *
+ * 	0000000020000000	(e_len)
+ *	0000000000001112	(e_len - ne_len)
+ *	0000000000001112	(e_len)
+ *
+ * Returns non-zero if the specified address was normalized, else zero.
+ */
+static __inline__ int
+qla2x00_normalize_dma_addr(
+    dma_addr_t *e_addr,  uint32_t *e_len,
+    dma_addr_t *ne_addr, uint32_t *ne_len)
+{
+	int normalized;
+
+	normalized = 0;
+	if ((*e_addr ^ (*e_addr + *e_len - 1)) & ~(0xFFFFFFFFULL)) {
+		/* Compute normalized crossed address and len */
+		*ne_addr = (0x100000000ULL + *e_addr) & ~(0xFFFFFFFFULL);
+		*ne_len = *e_len - (0x100000000ULL - (*e_addr & 0xFFFFFFFFULL));
+		*e_len -= *ne_len;
+
+		normalized++;
+	}
+	return (normalized);
+}
+
+static __inline__ void qla2x00_poll(scsi_qla_host_t *);
+static inline void 
+qla2x00_poll(scsi_qla_host_t *ha)
+{
+	qla2x00_intr_handler(0, ha, NULL);
+}
+
+
+static __inline__ void qla2x00_enable_intrs(scsi_qla_host_t *);
+static __inline__ void qla2x00_disable_intrs(scsi_qla_host_t *);
+
+static inline void 
+qla2x00_enable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	device_reg_t *reg;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	reg = ha->iobase;
+	ha->interrupts_on = 1;
+	/* enable risc and host interrupts */
+	WRT_REG_WORD(&reg->ictrl, ICR_EN_INT | ICR_EN_RISC);
+	RD_REG_WORD(&reg->ictrl);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+}
+
+static inline void 
+qla2x00_disable_intrs(scsi_qla_host_t *ha)
+{
+	unsigned long flags = 0;
+	device_reg_t *reg;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	reg = ha->iobase;
+	ha->interrupts_on = 0;
+	/* disable risc and host interrupts */
+	WRT_REG_WORD(&reg->ictrl, 0);
+	RD_REG_WORD(&reg->ictrl);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+}
+
+
+static __inline__ int qla2x00_is_wwn_zero(uint8_t *);
+
+/*
+ * qla2x00_is_wwn_zero - Check for zero node name
+ *
+ * Input:
+ *      wwn = Pointer to WW name to check
+ *
+ * Returns:
+ *      TRUE if name is 0 else FALSE
+ *
+ * Context:
+ *      Kernel context.
+ */
+static __inline__ int
+qla2x00_is_wwn_zero(uint8_t *wwn)
+{
+	int cnt;
+
+	for (cnt = 0; cnt < WWN_SIZE ; cnt++, wwn++) {
+		if (*wwn != 0)
+			break;
+	}
+	/* if zero return TRUE */
+	if (cnt == WWN_SIZE)
+		return (1);
+	else
+		return (0);
+}
+
+static __inline__ uint8_t
+qla2x00_suspend_lun(scsi_qla_host_t *, os_lun_t *, int, int);
+static __inline__ uint8_t
+qla2x00_delay_lun(scsi_qla_host_t *, os_lun_t *, int);
+
+static __inline__ uint8_t
+qla2x00_suspend_lun(scsi_qla_host_t *ha, os_lun_t *lq, int time, int count)
+{
+	return (__qla2x00_suspend_lun(ha, lq, time, count, 0));
+}
+
+static __inline__ uint8_t
+qla2x00_delay_lun(scsi_qla_host_t *ha, os_lun_t *lq, int time)
+{
+	return (__qla2x00_suspend_lun(ha, lq, time, 1, 1));
+}
+
+static __inline__ void qla2x00_check_fabric_devices(scsi_qla_host_t *);
+/*
+ * This routine will wait for fabric devices for
+ * the reset delay.
+ */
+static __inline__ void qla2x00_check_fabric_devices(scsi_qla_host_t *ha) 
+{
+	uint16_t	fw_state;
+
+	qla2x00_get_firmware_state(ha, &fw_state);
+}
+
+/**
+ * qla2x00_issue_marker() - Issue a Marker IOCB if necessary.
+ * @ha: HA context
+ * @ha_locked: is function called with the hardware lock
+ *
+ * Returns non-zero if a failure occured, else zero.
+ */
+static inline int
+qla2x00_issue_marker(scsi_qla_host_t *ha, int ha_locked)
+{
+	/* Send marker if required */
+	if (ha->marker_needed != 0) {
+		if (ha_locked) {
+			if (__qla2x00_marker(ha, 0, 0, MK_SYNC_ALL) !=
+			    QLA_SUCCESS)
+				return (QLA_FUNCTION_FAILED);
+		} else {
+			if (qla2x00_marker(ha, 0, 0, MK_SYNC_ALL) !=
+			    QLA_SUCCESS)
+				return (QLA_FUNCTION_FAILED);
+		}
+		ha->marker_needed = 0;
+	}
+	return (QLA_SUCCESS);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_iocb.c linux-2.5/drivers/scsi/qla2xxx/qla_iocb.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_iocb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_iocb.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,764 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+static inline uint16_t qla2x00_get_cmd_direction(struct scsi_cmnd *cmd);
+static inline cont_entry_t *qla2x00_prep_cont_type0_iocb(scsi_qla_host_t *);
+static inline cont_a64_entry_t *qla2x00_prep_cont_type1_iocb(scsi_qla_host_t *);
+
+/**
+ * qla2x00_get_cmd_direction() - Determine control_flag data direction.
+ * @cmd: SCSI command
+ *
+ * Returns the proper CF_* direction based on CDB.
+ */
+static inline uint16_t
+qla2x00_get_cmd_direction(struct scsi_cmnd *cmd)
+{
+	uint16_t cflags;
+
+	cflags = 0;
+
+	/* Set transfer direction */
+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
+		cflags = CF_WRITE;
+	else if (cmd->sc_data_direction == DMA_FROM_DEVICE)
+		cflags = CF_READ;
+	else {
+		switch (cmd->data_cmnd[0]) {
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_12:
+		case WRITE_BUFFER:
+		case WRITE_LONG:
+		case WRITE_SAME:
+		case WRITE_VERIFY:
+		case WRITE_VERIFY_12:
+		case FORMAT_UNIT:
+		case SEND_VOLUME_TAG:
+		case MODE_SELECT:
+		case SEND_DIAGNOSTIC:
+		case MODE_SELECT_10:
+			cflags = CF_WRITE;
+			break;
+		default:
+			cflags = CF_READ;
+			break;
+		}
+	}
+	return (cflags);
+}
+
+/**
+ * qla2x00_calc_iocbs_32() - Determine number of Command Type 2 and
+ * Continuation Type 0 IOCBs to allocate.
+ *
+ * @dsds: number of data segment decriptors needed
+ *
+ * Returns the number of IOCB entries needed to store @dsds.
+ */
+uint16_t
+qla2x00_calc_iocbs_32(uint16_t dsds)
+{
+	uint16_t iocbs;
+
+	iocbs = 1;
+	if (dsds > 3) {
+		iocbs += (dsds - 3) / 7;
+		if ((dsds - 3) % 7)
+			iocbs++;
+	}
+	return (iocbs);
+}
+
+/**
+ * qla2x00_calc_iocbs_64() - Determine number of Command Type 3 and
+ * Continuation Type 1 IOCBs to allocate.
+ *
+ * @dsds: number of data segment decriptors needed
+ *
+ * Returns the number of IOCB entries needed to store @dsds.
+ */
+uint16_t
+qla2x00_calc_iocbs_64(uint16_t dsds)
+{
+	uint16_t iocbs;
+
+	iocbs = 1;
+	if (dsds > 2) {
+		iocbs += (dsds - 2) / 5;
+		if ((dsds - 2) % 5)
+			iocbs++;
+	}
+	return (iocbs);
+}
+
+/**
+ * qla2x00_prep_cont_type0_iocb() - Initialize a Continuation Type 0 IOCB.
+ * @ha: HA context
+ *
+ * Returns a pointer to the Continuation Type 0 IOCB packet.
+ */
+static inline cont_entry_t *
+qla2x00_prep_cont_type0_iocb(scsi_qla_host_t *ha)
+{
+	cont_entry_t *cont_pkt;
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else {
+		ha->request_ring_ptr++;
+	}
+
+	cont_pkt = (cont_entry_t *)ha->request_ring_ptr;
+
+	/* Load packet defaults. */
+	*((uint32_t *)(&cont_pkt->entry_type)) =
+	    __constant_cpu_to_le32(CONTINUE_TYPE);
+
+	return (cont_pkt);
+}
+
+/**
+ * qla2x00_prep_cont_type1_iocb() - Initialize a Continuation Type 1 IOCB.
+ * @ha: HA context
+ *
+ * Returns a pointer to the continuation type 1 IOCB packet.
+ */
+static inline cont_a64_entry_t *
+qla2x00_prep_cont_type1_iocb(scsi_qla_host_t *ha)
+{
+	cont_a64_entry_t *cont_pkt;
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else {
+		ha->request_ring_ptr++;
+	}
+
+	cont_pkt = (cont_a64_entry_t *)ha->request_ring_ptr;
+
+	/* Load packet defaults. */
+	*((uint32_t *)(&cont_pkt->entry_type)) =
+	    __constant_cpu_to_le32(CONTINUE_A64_TYPE);
+
+	return (cont_pkt);
+}
+
+/**
+ * qla2x00_build_scsi_iocbs_32() - Build IOCB command utilizing 32bit
+ * capable IOCB types.
+ *
+ * @sp: SRB command to process
+ * @cmd_pkt: Command type 2 IOCB
+ * @tot_dsds: Total number of segments to transfer
+ */
+void qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,
+    uint16_t tot_dsds)
+{
+	uint16_t	avail_dsds;
+	uint32_t	*cur_dsd;
+	scsi_qla_host_t	*ha;
+	struct scsi_cmnd *cmd;
+
+	cmd = sp->cmd;
+
+	/* Update entry type to indicate Command Type 2 IOCB */
+	*((uint32_t *)(&cmd_pkt->entry_type)) =
+	    __constant_cpu_to_le32(COMMAND_TYPE);
+
+	/* No data transfer */
+	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+		cmd_pkt->byte_count = __constant_cpu_to_le32(0);
+		return;
+	}
+
+	ha = sp->ha;
+
+	cmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(cmd));
+
+	/* Three DSDs are available in the Command Type 2 IOCB */
+	avail_dsds = 3;
+	cur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;
+
+	/* Load data segments */
+	if (cmd->use_sg != 0) {
+		struct	scatterlist *cur_seg;
+		struct	scatterlist *end_seg;
+
+		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		end_seg = cur_seg + tot_dsds;
+		while (cur_seg < end_seg) {
+			cont_entry_t	*cont_pkt;
+
+			/* Allocate additional continuation packets? */
+			if (avail_dsds == 0) {
+				/*
+				 * Seven DSDs are available in the Continuation
+				 * Type 0 IOCB.
+				 */
+				cont_pkt = qla2x00_prep_cont_type0_iocb(ha);
+				cur_dsd = (uint32_t *)&cont_pkt->dseg_0_address;
+				avail_dsds = 7;
+			}
+
+			*cur_dsd++ = cpu_to_le32(sg_dma_address(cur_seg));
+			*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));
+			avail_dsds--;
+
+			cur_seg++;
+		}
+	} else {
+		dma_addr_t	req_dma;
+		struct page	*page;
+		unsigned long	offset;
+
+		page = virt_to_page(cmd->request_buffer);
+		offset = ((unsigned long)cmd->request_buffer & ~PAGE_MASK);
+		req_dma = pci_map_page(ha->pdev, page, offset,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+
+		sp->dma_handle = req_dma;
+
+		*cur_dsd++ = cpu_to_le32(req_dma);
+		*cur_dsd++ = cpu_to_le32(cmd->request_bufflen);
+	}
+}
+
+/**
+ * qla2x00_build_scsi_iocbs_64() - Build IOCB command utilizing 64bit
+ * capable IOCB types.
+ *
+ * @sp: SRB command to process
+ * @cmd_pkt: Command type 3 IOCB
+ * @tot_dsds: Total number of segments to transfer
+ */
+void qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,
+    uint16_t tot_dsds)
+{
+	uint16_t	avail_dsds;
+	uint32_t	*cur_dsd;
+	scsi_qla_host_t	*ha;
+	struct scsi_cmnd *cmd;
+
+	cmd = sp->cmd;
+
+	/* Update entry type to indicate Command Type 3 IOCB */
+	*((uint32_t *)(&cmd_pkt->entry_type)) =
+	    __constant_cpu_to_le32(COMMAND_A64_TYPE);
+
+	/* No data transfer */
+	if (cmd->request_bufflen == 0 || cmd->sc_data_direction == DMA_NONE) {
+		cmd_pkt->byte_count = __constant_cpu_to_le32(0);
+		return;
+	}
+
+	ha = sp->ha;
+
+	cmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(cmd));
+
+	/* Two DSDs are available in the Command Type 3 IOCB */
+	avail_dsds = 2;
+	cur_dsd = (uint32_t *)&cmd_pkt->dseg_0_address;
+
+	/* Load data segments */
+	if (cmd->use_sg != 0) {
+		struct	scatterlist *cur_seg;
+		struct	scatterlist *end_seg;
+
+		cur_seg = (struct scatterlist *)cmd->request_buffer;
+		end_seg = cur_seg + tot_dsds;
+		while (cur_seg < end_seg) {
+			dma_addr_t	sle_dma;
+			cont_a64_entry_t *cont_pkt;
+
+			/* Allocate additional continuation packets? */
+			if (avail_dsds == 0) {
+				/*
+				 * Five DSDs are available in the Continuation
+				 * Type 1 IOCB.
+				 */
+				cont_pkt = qla2x00_prep_cont_type1_iocb(ha);
+				cur_dsd = (uint32_t *)cont_pkt->dseg_0_address;
+				avail_dsds = 5;
+			}
+
+			sle_dma = sg_dma_address(cur_seg);
+			*cur_dsd++ = cpu_to_le32(LSD(sle_dma));
+			*cur_dsd++ = cpu_to_le32(MSD(sle_dma));
+			*cur_dsd++ = cpu_to_le32(sg_dma_len(cur_seg));
+			avail_dsds--;
+
+			cur_seg++;
+		}
+	} else {
+		dma_addr_t	req_dma;
+		struct page	*page;
+		unsigned long	offset;
+
+		page = virt_to_page(cmd->request_buffer);
+		offset = ((unsigned long)cmd->request_buffer & ~PAGE_MASK);
+		req_dma = pci_map_page(ha->pdev, page, offset,
+		    cmd->request_bufflen, cmd->sc_data_direction);
+
+		sp->dma_handle = req_dma;
+
+		*cur_dsd++ = cpu_to_le32(LSD(req_dma));
+		*cur_dsd++ = cpu_to_le32(MSD(req_dma));
+		*cur_dsd++ = cpu_to_le32(cmd->request_bufflen);
+	}
+}
+
+/**
+ * qla2x00_start_scsi() - Send a SCSI command to the ISP
+ * @sp: command to send to the ISP
+ *
+ * Returns non-zero if a failure occured, else zero.
+ */
+int
+qla2x00_start_scsi(srb_t *sp)
+{
+	int		ret;
+	unsigned long   flags;
+	scsi_qla_host_t	*ha;
+	fc_lun_t	*fclun;
+	struct scsi_cmnd *cmd;
+	uint32_t	*clr_ptr;
+	uint32_t        index;
+	uint32_t	handle;
+	uint16_t	cnt, tot_dsds, req_cnt;
+	cmd_entry_t	*cmd_pkt;
+	uint32_t        timeout;
+	struct scatterlist *sg;
+
+	device_reg_t	*reg;
+
+	/* Setup device pointers. */
+	ret = 0;
+	fclun = sp->lun_queue->fclun;
+	ha = fclun->fcport->ha;
+	cmd = sp->cmd;
+	reg = ha->iobase;
+
+	/* Send marker if required */
+	if (ha->marker_needed != 0) {
+		if (qla2x00_marker(ha, 0, 0, MK_SYNC_ALL) != QLA_SUCCESS) {
+			return (QLA_FUNCTION_FAILED);
+		}
+		ha->marker_needed = 0;
+	}
+
+	/* Calculate number of segments and entries required */
+	tot_dsds = 0;
+	if (cmd->use_sg) {
+		sg = (struct scatterlist *) cmd->request_buffer;
+		tot_dsds = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+		    cmd->sc_data_direction);
+	} else if (cmd->request_bufflen) {   /* Single segment transfer */
+		tot_dsds++;
+	}
+	req_cnt = (ha->calc_request_entries)(tot_dsds);
+
+	/* Acquire ring specific lock */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if (ha->req_q_cnt < (req_cnt + 2)) {
+		/* Calculate number of free request entries */
+		cnt = RD_REG_WORD(ISP_REQ_Q_OUT(ha, reg));
+		if (ha->req_ring_index < cnt)
+			ha->req_q_cnt = cnt - ha->req_ring_index;
+		else
+			ha->req_q_cnt = REQUEST_ENTRY_CNT -
+			    (ha->req_ring_index - cnt);
+	}
+
+	/* If no room for request in request ring */
+	if (ha->req_q_cnt < (req_cnt + 2)) {
+		DEBUG5(printk("scsi(%ld): in-ptr=%x req_q_cnt=%x "
+		    "tot_dsds=%x.\n",
+		    ha->host_no, ha->req_ring_index, ha->req_q_cnt, tot_dsds));
+
+		goto queuing_error;
+	}
+
+	/* Check for room in outstanding command list. */
+	handle = ha->current_outstanding_cmd;
+	for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+		handle++;
+		if (handle == MAX_OUTSTANDING_COMMANDS)
+			handle = 1;
+		if (ha->outstanding_cmds[handle] == 0) {
+			ha->current_outstanding_cmd = handle;
+			break;
+		}
+	}
+	if (index == MAX_OUTSTANDING_COMMANDS) {
+		DEBUG5(printk("scsi(%ld): Unable to queue command -- NO ROOM "
+		    "IN OUTSTANDING ARRAY (req_q_cnt=%x).\n",
+		    ha->host_no, ha->req_q_cnt));
+		goto queuing_error;
+	}
+
+	/* Build command packet */
+	ha->outstanding_cmds[handle] = sp;
+	sp->ha = ha;
+	sp->cmd->host_scribble = (unsigned char *)(unsigned long)handle;
+	ha->req_q_cnt -= req_cnt;
+
+	cmd_pkt = (cmd_entry_t *)ha->request_ring_ptr;
+	cmd_pkt->handle = handle;
+	/* Zero out remaining portion of packet. */
+	clr_ptr = (uint32_t *)cmd_pkt + 2;
+	memset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);
+	cmd_pkt->dseg_count = cpu_to_le16(tot_dsds);
+
+	/* Set target ID */
+	SET_TARGET_ID(ha, cmd_pkt->target, fclun->fcport->loop_id);
+
+	/* Set LUN number*/
+	cmd_pkt->lun = cpu_to_le16(fclun->lun);
+
+	/* Update tagged queuing modifier */
+	cmd_pkt->control_flags = __constant_cpu_to_le16(CF_SIMPLE_TAG);
+	if (cmd->device->tagged_supported) {
+		switch (cmd->tag) {
+		case HEAD_OF_QUEUE_TAG:
+			cmd_pkt->control_flags =
+			    __constant_cpu_to_le16(CF_HEAD_TAG);
+			break;
+		case ORDERED_QUEUE_TAG:
+			cmd_pkt->control_flags =
+			    __constant_cpu_to_le16(CF_ORDERED_TAG);
+			break;
+		}
+	}
+
+	/*
+	 * Allocate at least 5 (+ QLA_CMD_TIMER_DELTA) seconds for RISC timeout.
+	 */
+	timeout = (uint32_t)(cmd->timeout_per_command / HZ);
+	if (timeout > 65535)
+		cmd_pkt->timeout = __constant_cpu_to_le16(0);
+	else if (timeout > 25)
+		cmd_pkt->timeout = cpu_to_le16((uint16_t)timeout -
+		    (5 + QLA_CMD_TIMER_DELTA));
+	else
+		cmd_pkt->timeout = cpu_to_le16((uint16_t)timeout);
+
+	/* Load SCSI command packet. */
+	memcpy(cmd_pkt->scsi_cdb, cmd->cmnd, cmd->cmd_len);
+	cmd_pkt->byte_count = cpu_to_le32((uint32_t)cmd->request_bufflen);
+
+	/* Build IOCB segments */
+	(ha->build_scsi_iocbs)(sp, cmd_pkt, tot_dsds);
+
+	/* Set total data segment count. */
+	cmd_pkt->entry_count = (uint8_t)req_cnt;
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else
+		ha->request_ring_ptr++;
+
+	ha->actthreads++;
+	ha->total_ios++;
+	sp->lun_queue->out_cnt++;
+	sp->flags |= SRB_DMA_VALID;
+	sp->state = SRB_ACTIVE_STATE;
+	sp->u_start = jiffies;
+
+	/* Set chip new ring index. */
+	WRT_REG_WORD(ISP_REQ_Q_IN(ha, reg), ha->req_ring_index);
+	RD_REG_WORD(ISP_REQ_Q_IN(ha, reg));	/* PCI Posting. */
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return (QLA_SUCCESS);
+
+queuing_error:
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (cmd->use_sg)
+		pci_unmap_sg(ha->pdev, sg, cmd->use_sg, cmd->sc_data_direction);
+
+	return (QLA_FUNCTION_FAILED);
+}
+
+/**
+ * qla2x00_marker() - Send a marker IOCB to the firmware.
+ * @ha: HA context
+ * @loop_id: loop ID
+ * @lun: LUN
+ * @type: marker modifier
+ *
+ * Can be called from both normal and interrupt context.
+ *
+ * Returns non-zero if a failure occured, else zero.
+ */
+int
+__qla2x00_marker(scsi_qla_host_t *ha, uint16_t loop_id, uint16_t lun,
+    uint8_t type)
+{
+	mrk_entry_t	*pkt;
+
+	ENTER(__func__);
+
+	pkt = (mrk_entry_t *)qla2x00_req_pkt(ha);
+	if (pkt == NULL) {
+		DEBUG2_3(printk("%s(): **** FAILED ****\n", __func__));
+
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	pkt->entry_type = MARKER_TYPE;
+	pkt->modifier = type;
+
+	if (type != MK_SYNC_ALL) {
+		pkt->lun = cpu_to_le16(lun);
+		SET_TARGET_ID(ha, pkt->target, loop_id);
+	}
+
+	/* Issue command to ISP */
+	qla2x00_isp_cmd(ha);
+
+	LEAVE(__func__);
+
+	return (QLA_SUCCESS);
+}
+
+int 
+qla2x00_marker(scsi_qla_host_t *ha, uint16_t loop_id, uint16_t lun,
+    uint8_t type)
+{
+	int ret;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	ret = __qla2x00_marker(ha, loop_id, lun, type);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (ret);
+}
+
+/**
+ * qla2x00_req_pkt() - Retrieve a request packet from the request ring.
+ * @ha: HA context
+ *
+ * Note: The caller must hold the hardware lock before calling this routine.
+ *
+ * Returns NULL if function failed, else, a pointer to the request packet.
+ */
+request_t *
+qla2x00_req_pkt(scsi_qla_host_t *ha)
+{
+	device_reg_t	*reg = ha->iobase;
+	request_t	*pkt = NULL;
+	uint16_t	cnt;
+	uint32_t	*dword_ptr;
+	uint32_t	timer;
+	uint16_t	req_cnt = 1;
+
+	ENTER(__func__);
+
+	/* Wait 1 second for slot. */
+	for (timer = HZ; timer; timer--) {
+		if ((req_cnt + 2) >= ha->req_q_cnt) {
+			/* Calculate number of free request entries. */
+			cnt = qla2x00_debounce_register(ISP_REQ_Q_OUT(ha, reg));
+			if  (ha->req_ring_index < cnt)
+				ha->req_q_cnt = cnt - ha->req_ring_index;
+			else
+				ha->req_q_cnt = REQUEST_ENTRY_CNT -
+				    (ha->req_ring_index - cnt);
+		}
+		/* If room for request in request ring. */
+		if ((req_cnt + 2) < ha->req_q_cnt) {
+			ha->req_q_cnt--;
+			pkt = ha->request_ring_ptr;
+
+			/* Zero out packet. */
+			dword_ptr = (uint32_t *)pkt;
+			for (cnt = 0; cnt < REQUEST_ENTRY_SIZE / 4; cnt++)
+				*dword_ptr++ = 0;
+
+			/* Set system defined field. */
+			pkt->sys_define = (uint8_t)ha->req_ring_index;
+
+			/* Set entry count. */
+			pkt->entry_count = 1;
+
+			break;
+		}
+
+		/* Release ring specific lock */
+		spin_unlock(&ha->hardware_lock);
+
+		udelay(2);   /* 2 us */
+
+		/* Check for pending interrupts. */
+		/* During init we issue marker directly */
+		if (!ha->marker_needed)
+			qla2x00_poll(ha);
+
+		spin_lock_irq(&ha->hardware_lock);
+	}
+	if (!pkt) {
+		DEBUG2_3(printk("%s(): **** FAILED ****\n", __func__));
+	}
+
+	LEAVE(__func__);
+
+	return (pkt);
+}
+
+/**
+ * qla2x00_ms_req_pkt() - Retrieve a Management Server request packet from
+ * 				the request ring.
+ * @ha: HA context
+ * @sp: pointer to handle post function call
+ *
+ * Note: The caller must hold the hardware lock before calling this routine.
+ *
+ * Returns NULL if function failed, else, a pointer to the request packet.
+ */
+request_t *
+qla2x00_ms_req_pkt(scsi_qla_host_t *ha, srb_t  *sp)
+{
+	device_reg_t	*reg = ha->iobase;
+	request_t	*pkt = NULL;
+	uint16_t	cnt, i, index;
+	uint32_t	*dword_ptr;
+	uint32_t	timer;
+	uint8_t		found = 0;
+	uint16_t	req_cnt = 1;
+
+	ENTER(__func__);
+
+	/* Wait 1 second for slot. */
+	for (timer = HZ; timer; timer--) {
+		if ((req_cnt + 2) >= ha->req_q_cnt) {
+			/* Calculate number of free request entries. */
+			cnt = qla2x00_debounce_register(ISP_REQ_Q_OUT(ha, reg));
+			if (ha->req_ring_index < cnt) {
+				ha->req_q_cnt = cnt - ha->req_ring_index;
+			} else {
+				ha->req_q_cnt = REQUEST_ENTRY_CNT -
+				    (ha->req_ring_index - cnt);
+			}
+		}
+
+		/* Check for room in outstanding command list. */
+		cnt = ha->current_outstanding_cmd;
+		for (index = 1; index < MAX_OUTSTANDING_COMMANDS; index++) {
+			cnt++;
+			if (cnt == MAX_OUTSTANDING_COMMANDS)
+				cnt = 1;
+
+			if (ha->outstanding_cmds[cnt] == 0) {
+				found = 1;
+				ha->current_outstanding_cmd = cnt;
+				break;
+			}
+		}
+
+		/* If room for request in request ring. */
+		if (found && (req_cnt + 2) < ha->req_q_cnt) {
+			pkt = ha->request_ring_ptr;
+
+			/* Zero out packet. */
+			dword_ptr = (uint32_t *)pkt;
+			for (i = 0; i < REQUEST_ENTRY_SIZE / 4; i++ )
+				*dword_ptr++ = 0;
+
+			DEBUG5(printk("%s(): putting sp=%p in "
+			    "outstanding_cmds[%x]\n",
+			    __func__,
+			    sp, cnt));
+
+			ha->outstanding_cmds[cnt] = sp;
+
+			/* save the handle */
+			sp->cmd->host_scribble = (unsigned char *) (u_long) cnt;
+			CMD_SP(sp->cmd) = (void *)sp;
+
+			ha->req_q_cnt--;
+			pkt->handle = (uint32_t)cnt;
+
+			/* Set system defined field. */
+			pkt->sys_define = (uint8_t)ha->req_ring_index;
+			pkt->entry_status = 0;
+
+			break;
+		}
+
+		/* Release ring specific lock */
+		spin_unlock(&ha->hardware_lock);
+		udelay(20);
+
+		/* Check for pending interrupts. */
+		qla2x00_poll(ha);
+
+		spin_lock_irq(&ha->hardware_lock);
+	}
+	if (!pkt) {
+		DEBUG2_3(printk("%s(): **** FAILED ****\n", __func__));
+	}
+
+	LEAVE(__func__);
+
+	return (pkt);
+}
+
+/**
+ * qla2x00_isp_cmd() - Modify the request ring pointer.
+ * @ha: HA context
+ *
+ * Note: The caller must hold the hardware lock before calling this routine.
+ */
+void
+qla2x00_isp_cmd(scsi_qla_host_t *ha)
+{
+	device_reg_t *reg = ha->iobase;
+
+	DEBUG5(printk("%s(): IOCB data:\n", __func__));
+	DEBUG5(qla2x00_dump_buffer(
+	    (uint8_t *)ha->request_ring_ptr, REQUEST_ENTRY_SIZE));
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else
+		ha->request_ring_ptr++;
+
+	/* Set chip new ring index. */
+	WRT_REG_WORD(ISP_REQ_Q_IN(ha, reg), ha->req_ring_index);
+	RD_REG_WORD(ISP_REQ_Q_IN(ha, reg));	/* PCI Posting. */
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_isr.c linux-2.5/drivers/scsi/qla2xxx/qla_isr.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_isr.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_isr.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,1421 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include "qla_os.h"
+
+#include "qla_def.h"
+
+/* XXX(hch): this is ugly, but we don't want to pull in exioctl.h */
+#ifndef EXT_DEF_PORTSPEED_1GBIT
+#define EXT_DEF_PORTSPEED_1GBIT		1
+#define EXT_DEF_PORTSPEED_2GBIT		2
+#endif
+
+static void qla2x00_mbx_completion(scsi_qla_host_t *, uint16_t);
+static void qla2x00_async_event(scsi_qla_host_t *, uint32_t);
+static void qla2x00_process_completed_request(struct scsi_qla_host *, uint32_t);
+void qla2x00_process_response_queue(struct scsi_qla_host *);
+static void qla2x00_status_entry(scsi_qla_host_t *, sts_entry_t *);
+static void qla2x00_status_cont_entry(scsi_qla_host_t *, sts_cont_entry_t *);
+static void qla2x00_error_entry(scsi_qla_host_t *, sts_entry_t *);
+static void qla2x00_ms_entry(scsi_qla_host_t *, ms_iocb_entry_t *);
+
+static int qla2x00_check_sense(struct scsi_cmnd *cp, os_lun_t *);
+
+/**
+ * qla2x00_intr_handler() - Process interrupts for the ISP.
+ * @irq:
+ * @dev_id: SCSI driver HA context
+ * @regs:
+ *
+ * Called by system whenever the host adapter generates an interrupt.
+ *
+ * Returns handled flag.
+ */
+irqreturn_t
+qla2x00_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	scsi_qla_host_t	*ha;
+	device_reg_t	*reg;
+	uint32_t	mbx;
+	int		status = 0;
+	unsigned long	flags = 0;
+	unsigned long	mbx_flags = 0;
+	unsigned long	intr_iter;
+	uint32_t	stat;
+	uint16_t	hccr;
+
+	/* Don't loop forever, interrupt are OFF */
+	intr_iter = 50; 
+
+	ha = (scsi_qla_host_t *) dev_id;
+	if (!ha) {
+		printk(KERN_INFO
+		    "%s(): NULL host pointer\n", __func__);
+		return (IRQ_NONE);
+	}
+
+	reg = ha->iobase;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	for (;;) {
+		/* Relax CPU! */
+		if (!(intr_iter--))
+			break;
+
+		if (IS_QLA2100(ha) || IS_QLA2200(ha)) {
+			if ((RD_REG_WORD(&reg->istatus) & ISR_RISC_INT) == 0)
+				break;
+
+			if (RD_REG_WORD(&reg->semaphore) & BIT_0) {
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+				RD_REG_WORD(&reg->hccr);
+
+				/* Get mailbox data. */
+				mbx = RD_MAILBOX_REG(ha, reg, 0);
+				if (mbx > 0x3fff && mbx < 0x8000) {
+					qla2x00_mbx_completion(ha,
+					    (uint16_t)mbx);
+					status |= MBX_INTERRUPT;
+				} else if (mbx > 0x7fff && mbx < 0xc000) {
+					qla2x00_async_event(ha, mbx);
+				} else {
+					/*EMPTY*/
+					DEBUG2(printk("scsi(%ld): Unrecognized "
+					    "interrupt type (%d)\n",
+					    ha->host_no, mbx));
+				}
+				/* Release mailbox registers. */
+				WRT_REG_WORD(&reg->semaphore, 0);
+				/* Workaround for ISP2100 chip. */
+				if (IS_QLA2100(ha))
+					RD_REG_WORD(&reg->semaphore);
+			} else {
+				qla2x00_process_response_queue(ha);
+	
+				WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+				RD_REG_WORD(&reg->hccr);
+			}
+		} else /* IS_QLA23XX(ha) */ {
+			stat = RD_REG_DWORD(&reg->u.isp2300.host_status);
+			if ((stat & HSR_RISC_INT) == 0)
+				break;
+
+			mbx = MSW(stat);
+			switch (stat & 0xff) {
+			case 0x13:
+				qla2x00_process_response_queue(ha);
+				break;
+			case 0x1:
+			case 0x2:
+			case 0x10:
+			case 0x11:
+				qla2x00_mbx_completion(ha, (uint16_t)mbx);
+				status |= MBX_INTERRUPT;
+
+				/* Release mailbox registers. */
+				WRT_REG_WORD(&reg->semaphore, 0);
+				break;
+			case 0x12:
+				qla2x00_async_event(ha, mbx);
+				break;
+			case 0x15:
+				mbx = mbx << 16 | MBA_CMPLT_1_16BIT;
+				qla2x00_async_event(ha, mbx);
+				break;
+			case 0x16:
+				mbx = mbx << 16 | MBA_SCSI_COMPLETION;
+				qla2x00_async_event(ha, mbx);
+				break;
+			default:
+				hccr = RD_REG_WORD(&reg->hccr);
+				if (hccr & HCCR_RISC_PAUSE) {
+					qla_printk(KERN_INFO, ha,
+					    "RISC paused, dumping HCCR=%x\n",
+					    hccr);
+
+					/*
+					 * Issue a "HARD" reset in order for
+					 * the RISC interrupt bit to be
+					 * cleared.  Schedule a big hammmer to
+					 * get out of the RISC PAUSED state.
+					 */
+					WRT_REG_WORD(&reg->hccr,
+					    HCCR_RESET_RISC);
+					RD_REG_WORD(&reg->hccr);
+					set_bit(ISP_ABORT_NEEDED,
+					    &ha->dpc_flags);
+					break;
+				} else {
+					DEBUG2(printk("scsi(%ld): Unrecognized "
+					    "interrupt type (%d)\n",
+					    ha->host_no, stat & 0xff));
+				}
+				break;
+			}
+			WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+			RD_REG_WORD(&reg->hccr);
+		}
+	}
+
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	qla2x00_next(ha);
+	ha->last_irq_cpu = smp_processor_id();
+	ha->total_isr_cnt++;
+
+	if (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&
+	    (status & MBX_INTERRUPT) && ha->flags.mbox_int) {
+
+		/* There was a mailbox completion */
+		DEBUG3(printk("%s(%ld): Going to get mbx reg lock.\n",
+		    __func__, ha->host_no));
+
+		spin_lock_irqsave(&ha->mbx_reg_lock, mbx_flags);
+
+		if (ha->mcp == NULL) {
+			DEBUG3(printk("%s(%ld): Error mbx pointer.\n",
+			    __func__, ha->host_no));
+		} else {
+			DEBUG3(printk("%s(%ld): Going to set mbx intr flags. "
+			    "cmd=%x.\n",
+			    __func__, ha->host_no, ha->mcp->mb[0]));
+		}
+		set_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+
+		DEBUG3(printk("%s(%ld): Going to wake up mbx function for "
+		    "completion.\n",
+		    __func__, ha->host_no));
+
+		up(&ha->mbx_intr_sem);
+
+		DEBUG3(printk("%s(%ld): Going to release mbx reg lock.\n",
+		    __func__, ha->host_no));
+
+		spin_unlock_irqrestore(&ha->mbx_reg_lock, mbx_flags);
+	}
+
+	if (!list_empty(&ha->done_queue))
+		qla2x00_done(ha);
+
+	/* Wakeup the DPC routine */
+	if ((!ha->flags.mbox_busy &&
+	    (test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) ||
+		test_bit(RESET_MARKER_NEEDED, &ha->dpc_flags) ||
+		test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))) &&
+		    ha->dpc_wait && !ha->dpc_active) {
+
+		up(ha->dpc_wait);
+	}
+
+	return (IRQ_HANDLED);
+}
+
+/**
+ * qla2x00_mbx_completion() - Process mailbox command completions.
+ * @ha: SCSI driver HA context
+ * @mb0: Mailbox0 register
+ */
+static void
+qla2x00_mbx_completion(scsi_qla_host_t *ha, uint16_t mb0)
+{
+	uint16_t	cnt;
+	uint16_t	*wptr;
+	device_reg_t	*reg = ha->iobase;
+
+	/* Load return mailbox registers. */
+	ha->flags.mbox_int = TRUE;
+	ha->mailbox_out[0] = mb0;
+	wptr = (uint16_t *)MAILBOX_REG(ha, reg, 1);
+
+	for (cnt = 1; cnt < ha->mbx_count; cnt++) {
+		if (IS_QLA2200(ha) && cnt == 8) 
+			wptr = (uint16_t *)MAILBOX_REG(ha, reg, 8);
+		if (cnt == 4 || cnt == 5)
+			ha->mailbox_out[cnt] = qla2x00_debounce_register(wptr);
+		else
+			ha->mailbox_out[cnt] = RD_REG_WORD(wptr);
+	
+		wptr++;
+	}
+
+	if (ha->mcp) {
+		DEBUG3(printk("%s(%ld): Got mailbox completion. cmd=%x.\n",
+		    __func__, ha->host_no, ha->mcp->mb[0]));
+	} else {
+		DEBUG2_3(printk("%s(%ld): MBX pointer ERROR!\n",
+		    __func__, ha->host_no));
+	}
+}
+
+/**
+ * qla2x00_async_event() - Process aynchronous events.
+ * @ha: SCSI driver HA context
+ * @mb0: Mailbox0 register
+ */
+static void
+qla2x00_async_event(scsi_qla_host_t *ha, uint32_t mbx)
+{
+	static char	*link_speeds[5] = { "1", "2", "4", "?", "10" };
+	char		*link_speed;
+	uint16_t	mb[4];
+	uint16_t	handle_cnt;
+	uint16_t	cnt;
+	uint32_t	handles[5];
+	device_reg_t	*reg = ha->iobase;
+	uint32_t	rscn_entry, host_pid;
+	uint8_t		rscn_queue_index;
+
+	/* Setup to process RIO completion. */
+	handle_cnt = 0;
+	mb[0] = LSW(mbx);
+	switch (mb[0]) {
+	case MBA_SCSI_COMPLETION:
+		if (IS_QLA2100(ha) || IS_QLA2200(ha))
+			handles[0] = RD_MAILBOX_REG(ha, reg, 1);
+		else
+			handles[0] = MSW(mbx);
+		handles[0] |= (uint32_t)(RD_MAILBOX_REG(ha, reg, 2) << 16);
+		handle_cnt = 1;
+		break;
+	case MBA_CMPLT_1_16BIT:
+		if (IS_QLA2100(ha) || IS_QLA2200(ha))
+			handles[0] = (uint32_t)RD_MAILBOX_REG(ha, reg, 1);
+		else
+			handles[0] = MSW(mbx);
+		handle_cnt = 1;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	case MBA_CMPLT_2_16BIT:
+		handles[0] = (uint32_t)RD_MAILBOX_REG(ha, reg, 1);
+		handles[1] = (uint32_t)RD_MAILBOX_REG(ha, reg, 2);
+		handle_cnt = 2;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	case MBA_CMPLT_3_16BIT:
+		handles[0] = (uint32_t)RD_MAILBOX_REG(ha, reg, 1);
+		handles[1] = (uint32_t)RD_MAILBOX_REG(ha, reg, 2);
+		handles[2] = (uint32_t)RD_MAILBOX_REG(ha, reg, 3);
+		handle_cnt = 3;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	case MBA_CMPLT_4_16BIT:
+		handles[0] = (uint32_t)RD_MAILBOX_REG(ha, reg, 1);
+		handles[1] = (uint32_t)RD_MAILBOX_REG(ha, reg, 2);
+		handles[2] = (uint32_t)RD_MAILBOX_REG(ha, reg, 3);
+		handles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);
+		handle_cnt = 4;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	case MBA_CMPLT_5_16BIT:
+		handles[0] = (uint32_t)RD_MAILBOX_REG(ha, reg, 1);
+		handles[1] = (uint32_t)RD_MAILBOX_REG(ha, reg, 2);
+		handles[2] = (uint32_t)RD_MAILBOX_REG(ha, reg, 3);
+		handles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);
+		handles[4] = (uint32_t)RD_MAILBOX_REG(ha, reg, 7);
+		handle_cnt = 5;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	case MBA_CMPLT_2_32BIT:
+		handles[0] = (uint32_t)((RD_MAILBOX_REG(ha, reg, 2) << 16) |
+		    RD_MAILBOX_REG(ha, reg, 1));
+		handles[1] = (uint32_t)((RD_MAILBOX_REG(ha, reg, 7) << 16) |
+		    RD_MAILBOX_REG(ha, reg, 6));
+		handle_cnt = 2;
+		mb[0] = MBA_SCSI_COMPLETION;
+		break;
+	default:
+		break;
+	}
+
+	mb[0] = LSW(mbx);
+	switch (mb[0]) {
+	case MBA_SCSI_COMPLETION:	/* Fast Post */
+		if (!ha->flags.online)
+			break;
+
+		for (cnt = 0; cnt < handle_cnt; cnt++)
+			qla2x00_process_completed_request(ha, handles[cnt]);
+		break;
+
+	case MBA_RESET:			/* Reset */
+		DEBUG2(printk("scsi(%ld): Asynchronous RESET.\n", ha->host_no));
+
+		set_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+		break;
+
+	case MBA_SYSTEM_ERR:		/* System Error */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+		mb[2] = RD_MAILBOX_REG(ha, reg, 2);
+		mb[3] = RD_MAILBOX_REG(ha, reg, 3);
+
+		qla_printk(KERN_INFO, ha,
+		    "ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh.\n",
+		    mb[1], mb[2], mb[3]);
+
+		if (IS_QLA2100(ha) || IS_QLA2200(ha))
+			qla2100_fw_dump(ha, 1);
+		else
+	    		qla2300_fw_dump(ha, 1);
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		break;
+
+	case MBA_REQ_TRANSFER_ERR:	/* Request Transfer Error */
+		DEBUG2(printk("scsi(%ld): ISP Request Transfer Error.\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha, "ISP Request Transfer Error.\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		break;
+
+	case MBA_RSP_TRANSFER_ERR:	/* Response Transfer Error */
+		DEBUG2(printk("scsi(%ld): ISP Response Transfer Error.\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha, "ISP Response Transfer Error.\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		break;
+
+	case MBA_WAKEUP_THRES:		/* Request Queue Wake-up */
+		DEBUG2(printk("scsi(%ld): Asynchronous WAKEUP_THRES.\n",
+		    ha->host_no));
+		break;
+
+	case MBA_LIP_OCCURRED:		/* Loop Initialization Procedure */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+
+		DEBUG2(printk("scsi(%ld): LIP occured (%x).\n", ha->host_no,
+		    mb[1]));
+		qla_printk(KERN_INFO, ha, "LIP occured (%x).\n", mb[1]);
+
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);
+			atomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		set_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags);
+
+		ha->flags.management_server_logged_in = 0;
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_LIP_OCCURRED, NULL);
+
+		ha->total_lip_cnt++;
+		break;
+
+	case MBA_LOOP_UP:		/* Loop Up Event */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+
+		ha->current_speed = EXT_DEF_PORTSPEED_1GBIT;
+		if (IS_QLA2100(ha) || IS_QLA2200(ha)) {
+			link_speed = link_speeds[0];
+		} else {
+			link_speed = link_speeds[3];
+			if (mb[1] < 5)
+				link_speed = link_speeds[mb[1]];
+			if (mb[1] == 1)
+				ha->current_speed = EXT_DEF_PORTSPEED_2GBIT;
+		}
+
+		DEBUG2(printk("scsi(%ld): Asynchronous LOOP UP (%s Gbps).\n",
+		    ha->host_no, link_speed));
+		qla_printk(KERN_INFO, ha, "LOOP UP detected (%s Gbps).\n",
+		    link_speed);
+
+		ha->flags.management_server_logged_in = 0;
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_LOOP_UP, NULL);
+		break;
+
+	case MBA_LOOP_DOWN:		/* Loop Down Event */
+		DEBUG2(printk("scsi(%ld): Asynchronous LOOP DOWN.\n",
+		    ha->host_no));
+		qla_printk(KERN_INFO, ha, "LOOP DOWN detected.\n");
+
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);
+			atomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		ha->flags.management_server_logged_in = 0;
+		ha->current_speed = 0; /* reset value */
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_LOOP_DOWN, NULL);
+		break;
+
+	case MBA_LIP_RESET:		/* LIP reset occurred */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+
+		DEBUG2(printk("scsi(%ld): Asynchronous LIP RESET (%x).\n",
+		    ha->host_no, mb[1]));
+		qla_printk(KERN_INFO, ha,
+		    "LIP reset occured (%x).\n", mb[1]);
+
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);
+			atomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		set_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+
+		ha->operating_mode = LOOP;
+		ha->flags.management_server_logged_in = 0;
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_LIP_RESET, NULL);
+
+		ha->total_lip_cnt++;
+		break;
+
+	case MBA_POINT_TO_POINT:	/* Point-to-Point */
+		if (IS_QLA2100(ha))
+			break;
+
+		DEBUG2(printk("scsi(%ld): Asynchronous P2P MODE received.\n",
+		    ha->host_no));
+
+		/*
+		 * Until there's a transition from loop down to loop up, treat
+		 * this as loop down only.
+		 */
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);
+			if (!atomic_read(&ha->loop_down_timer))
+				atomic_set(&ha->loop_down_timer,
+				    LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		if (!(test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags))) {
+			set_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+		}
+		set_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags);
+		break;
+
+	case MBA_CHG_IN_CONNECTION:	/* Change in connection mode */
+		if (IS_QLA2100(ha))
+			break;
+
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+
+		DEBUG2(printk("scsi(%ld): Asynchronous Change In Connection "
+		    "received.\n",
+		    ha->host_no));
+		qla_printk(KERN_INFO, ha,
+		    "Configuration change detected: value=%x.\n", mb[1]);
+
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			atomic_set(&ha->loop_state, LOOP_DOWN);  
+			if (!atomic_read(&ha->loop_down_timer))
+				atomic_set(&ha->loop_down_timer,
+				    LOOP_DOWN_TIME);
+			qla2x00_mark_all_devices_lost(ha);
+		}
+
+		set_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+		set_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);
+		break;
+
+	case MBA_PORT_UPDATE:		/* Port database update */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+		mb[2] = RD_MAILBOX_REG(ha, reg, 2);
+
+		/*
+		 * If a single remote port just logged into (or logged out of)
+		 * us, create a new entry in our rscn fcports list and handle
+		 * the event like an RSCN.
+		 */
+		if (IS_QLA23XX(ha) && ha->flags.init_done && mb[1] != 0xffff &&
+		    ((ha->operating_mode == P2P && mb[1] != 0) ||
+		    (ha->operating_mode != P2P && mb[1] !=
+			SNS_FIRST_LOOP_ID)) && (mb[2] == 6 || mb[2] == 7)) {
+			int rval;
+			fc_port_t *rscn_fcport;
+
+			/* Create new fcport for login. */
+			rscn_fcport = qla2x00_alloc_rscn_fcport(ha, GFP_ATOMIC);
+			if (rscn_fcport) {
+				DEBUG14(printk("scsi(%ld): Port Update -- "
+				    "creating RSCN fcport %p for login.\n",
+				    ha->host_no, rscn_fcport));
+
+				rscn_fcport->loop_id = mb[1];
+				rscn_fcport->d_id.b24 = INVALID_PORT_ID;
+				atomic_set(&rscn_fcport->state,
+				    FCS_DEVICE_LOST);
+				list_add_tail(&rscn_fcport->list,
+				    &ha->rscn_fcports);
+
+				rval = qla2x00_handle_port_rscn(ha, 0,
+				    rscn_fcport, 1);
+				if (rval == QLA_SUCCESS)
+					break;
+			} else {
+				DEBUG14(printk("scsi(%ld): Port Update -- "
+				    "-- unable to allocate RSCN fcport "
+				    "login.\n", ha->host_no));
+			}
+		}
+
+		/*
+		 * If PORT UPDATE is global (recieved LIP_OCCURED/LIP_RESET
+		 * event etc. earlier indicating loop is down) then process
+		 * it.  Otherwise ignore it and Wait for RSCN to come in.
+		 */
+		if (atomic_read(&ha->loop_state) != LOOP_DOWN) {
+			DEBUG2(printk("scsi(%ld): Asynchronous PORT UPDATE "
+			    "ignored.\n", ha->host_no));
+			break;
+		}
+
+		DEBUG2(printk("scsi(%ld): Asynchronous PORT UPDATE.\n",
+		    ha->host_no));
+		DEBUG(printk(KERN_INFO
+		    "scsi(%ld): Port database changed %04x %04x.\n",
+		    ha->host_no, mb[1], mb[2]));
+
+		/*
+		 * Mark all devices as missing so we will login again.
+		 */
+		atomic_set(&ha->loop_state, LOOP_UP);
+
+		atomic_set(&ha->loop_down_timer, 0);
+		qla2x00_mark_all_devices_lost(ha);
+
+		ha->flags.rscn_queue_overflow = 1;
+
+		set_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+		set_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_PORT_UPDATE, NULL);
+		break;
+
+	case MBA_RSCN_UPDATE:		/* State Change Registration */
+		mb[1] = RD_MAILBOX_REG(ha, reg, 1);
+		mb[2] = RD_MAILBOX_REG(ha, reg, 2);
+
+		DEBUG2(printk("scsi(%ld): Asynchronous RSCR UPDATE.\n",
+		    ha->host_no));
+		DEBUG(printk(KERN_INFO
+		    "scsi(%ld): RSCN database changed -- %04x %04x.\n",
+		    ha->host_no, mb[1], mb[2]));
+
+		rscn_entry = (mb[1] << 16) | mb[2];
+		host_pid = (ha->d_id.b.domain << 16) | (ha->d_id.b.area << 8) |
+		    ha->d_id.b.al_pa;
+		if (rscn_entry == host_pid) {
+			DEBUG(printk(KERN_INFO
+			    "scsi(%ld): Ignoring RSCN update to local host "
+			    "port ID (%06x)\n",
+			    ha->host_no, host_pid));
+			break;
+		}
+
+		rscn_queue_index = ha->rscn_in_ptr + 1;
+		if (rscn_queue_index == MAX_RSCN_COUNT)
+			rscn_queue_index = 0;
+		if (rscn_queue_index != ha->rscn_out_ptr) {
+			ha->rscn_queue[ha->rscn_in_ptr] = rscn_entry;
+			ha->rscn_in_ptr = rscn_queue_index;
+		} else {
+			ha->flags.rscn_queue_overflow = 1;
+		}
+
+		atomic_set(&ha->loop_state, LOOP_UPDATE);
+		atomic_set(&ha->loop_down_timer, 0);
+		ha->flags.management_server_logged_in = 0;
+
+		set_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+		set_bit(RSCN_UPDATE, &ha->dpc_flags);
+
+		/* Update AEN queue. */
+		qla2x00_enqueue_aen(ha, MBA_RSCN_UPDATE, &mb[0]);
+		break;
+
+	/* case MBA_RIO_RESPONSE: */
+	case MBA_ZIO_RESPONSE:
+		DEBUG2(printk("scsi(%ld): [R|Z]IO update completion.\n",
+		    ha->host_no));
+		DEBUG(printk(KERN_INFO
+		    "scsi(%ld): [R|Z]IO update completion.\n",
+		    ha->host_no));
+
+		qla2x00_process_response_queue(ha);
+		break;
+	}
+}
+
+/**
+ * qla2x00_process_completed_request() - Process a Fast Post response.
+ * @ha: SCSI driver HA context
+ * @index: SRB index
+ */
+static void
+qla2x00_process_completed_request(struct scsi_qla_host *ha, uint32_t index)
+{
+	srb_t *sp;
+
+	/* Validate handle. */
+	if (index >= MAX_OUTSTANDING_COMMANDS) {
+		DEBUG2(printk("scsi(%ld): Invalid SCSI completion handle %d.\n",
+		    ha->host_no, index));
+		qla_printk(KERN_WARNING, ha,
+		    "Invalid SCSI completion handle %d.\n", index);
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		return;
+	}
+
+	sp = ha->outstanding_cmds[index];
+	if (sp) {
+		/* Free outstanding command slot. */
+		ha->outstanding_cmds[index] = 0;
+
+		if (ha->actthreads)
+			ha->actthreads--;
+		sp->lun_queue->out_cnt--;
+		CMD_COMPL_STATUS(sp->cmd) = 0L;
+		CMD_SCSI_STATUS(sp->cmd) = 0L;
+
+		/* Save ISP completion status */
+		sp->cmd->result = DID_OK << 16;
+		sp->fo_retry_cnt = 0;
+		add_to_done_queue(ha, sp);
+	} else {
+		DEBUG2(printk("scsi(%ld): Invalid ISP SCSI completion handle\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha,
+		    "Invalid ISP SCSI completion handle\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+	}
+}
+
+/**
+ * qla2x00_process_response_queue() - Process response queue entries.
+ * @ha: SCSI driver HA context
+ */
+void
+qla2x00_process_response_queue(struct scsi_qla_host *ha)
+{
+	device_reg_t	*reg = ha->iobase;
+	sts_entry_t	*pkt;
+	uint16_t        handle_cnt;
+	uint16_t        cnt;
+
+	if (!ha->flags.online)
+		return;
+
+	while (ha->response_ring_ptr->signature != RESPONSE_PROCESSED) {
+		pkt = (sts_entry_t *)ha->response_ring_ptr;
+
+		ha->rsp_ring_index++;
+		if (ha->rsp_ring_index == ha->response_q_length) {
+			ha->rsp_ring_index = 0;
+			ha->response_ring_ptr = ha->response_ring;
+		} else {
+			ha->response_ring_ptr++;
+		}
+
+		if (pkt->entry_status != 0) {
+			DEBUG3(printk(KERN_INFO
+			    "scsi(%ld): Process error entry.\n", ha->host_no));
+
+			qla2x00_error_entry(ha, pkt);
+			((response_t *)pkt)->signature = RESPONSE_PROCESSED;
+			wmb();
+			continue;
+		}
+
+		switch (pkt->entry_type) {
+		case STATUS_TYPE:
+			qla2x00_status_entry(ha, pkt);
+			break;
+		case STATUS_TYPE_21:
+			handle_cnt = ((sts21_entry_t *)pkt)->handle_count;
+			for (cnt = 0; cnt < handle_cnt; cnt++) {
+				qla2x00_process_completed_request(ha,
+				    ((sts21_entry_t *)pkt)->handle[cnt]);
+			}
+			break;
+		case STATUS_TYPE_22:
+			handle_cnt = ((sts22_entry_t *)pkt)->handle_count;
+			for (cnt = 0; cnt < handle_cnt; cnt++) {
+				qla2x00_process_completed_request(ha,
+				    ((sts22_entry_t *)pkt)->handle[cnt]);
+			}
+			break;
+		case STATUS_CONT_TYPE:
+			qla2x00_status_cont_entry(ha, (sts_cont_entry_t *)pkt);
+			break;
+		case MS_IOCB_TYPE:
+			qla2x00_ms_entry(ha, (ms_iocb_entry_t *)pkt);
+			break;
+		case MBX_IOCB_TYPE:
+			if (IS_QLA23XX(ha)) {
+				if (pkt->sys_define == SOURCE_ASYNC_IOCB) {
+					qla2x00_process_iodesc(ha,
+					    (struct mbx_entry *)pkt);
+				} else {
+					/* MBX IOCB Type Not Supported. */
+					DEBUG4(printk(KERN_WARNING
+					    "scsi(%ld): Received unknown MBX "
+					    "IOCB response pkt type=%x "
+					    "source=%x entry status=%x.\n",
+					    ha->host_no, pkt->entry_type,
+					    pkt->sys_define,
+					    pkt->entry_status));
+				}
+				break;
+			}
+			/* Fallthrough. */
+		default:
+			/* Type Not Supported. */
+			DEBUG4(printk(KERN_WARNING
+			    "scsi(%ld): Received unknown response pkt type %x "
+			    "entry status=%x.\n",
+			    ha->host_no, pkt->entry_type, pkt->entry_status));
+			break;
+		}
+		((response_t *)pkt)->signature = RESPONSE_PROCESSED;
+		wmb();
+	}
+
+	/* Adjust ring index */
+	WRT_REG_WORD(ISP_RSP_Q_OUT(ha, reg), ha->rsp_ring_index);
+}
+
+/**
+ * qla2x00_status_entry() - Process a Status IOCB entry.
+ * @ha: SCSI driver HA context
+ * @pkt: Entry pointer
+ */
+static void
+qla2x00_status_entry(scsi_qla_host_t *ha, sts_entry_t *pkt)
+{
+	int		ret;
+	unsigned	b, t, l;
+	srb_t		*sp;
+	os_lun_t	*lq;
+	os_tgt_t	*tq;
+	fc_port_t	*fcport;
+	struct scsi_cmnd *cp;
+	uint16_t	comp_status;
+	uint16_t	scsi_status;
+	uint8_t		lscsi_status;
+	uint32_t	resid;
+	uint8_t		sense_sz = 0;
+
+	/* Fast path completion. */
+	if (le16_to_cpu(pkt->comp_status) == CS_COMPLETE &&
+	    (le16_to_cpu(pkt->scsi_status) & SS_MASK) == 0) {
+		qla2x00_process_completed_request(ha, pkt->handle);
+
+		return;
+	}
+
+	/* Validate handle. */
+	if (pkt->handle < MAX_OUTSTANDING_COMMANDS) {
+		sp = ha->outstanding_cmds[pkt->handle];
+		ha->outstanding_cmds[pkt->handle] = 0;
+	} else
+		sp = NULL;
+
+	if (sp == NULL) {
+		DEBUG2(printk("scsi(%ld): Status Entry invalid handle.\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha, "Status Entry invalid handle.\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		if (ha->dpc_wait && !ha->dpc_active) 
+			up(ha->dpc_wait);
+
+		return;
+	}
+	cp = sp->cmd;
+	if (cp == NULL) {
+		DEBUG2(printk("scsi(%ld): Command already returned back to OS "
+		    "pkt->handle=%d sp=%p sp->state:%d\n",
+		    ha->host_no, pkt->handle, sp, sp->state));
+		qla_printk(KERN_WARNING, ha,
+		    "Command is NULL: already returned to OS (sp=%p)\n", sp);
+
+		return;
+	}
+
+	if (ha->actthreads)
+		ha->actthreads--;
+
+	if (sp->lun_queue == NULL) {
+		DEBUG2(printk("scsi(%ld): Status Entry invalid lun pointer.\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha,
+		    "Status Entry invalid lun pointer.\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		if (ha->dpc_wait && !ha->dpc_active) 
+			up(ha->dpc_wait);
+
+		return;
+	}
+
+	sp->lun_queue->out_cnt--;
+
+	comp_status = le16_to_cpu(pkt->comp_status);
+	/* Mask of reserved bits 12-15, before we examine the scsi status */
+	scsi_status = le16_to_cpu(pkt->scsi_status) & SS_MASK;
+	lscsi_status = scsi_status & STATUS_MASK;
+
+	CMD_ENTRY_STATUS(cp) = pkt->entry_status;
+	CMD_COMPL_STATUS(cp) = comp_status;
+	CMD_SCSI_STATUS(cp) = scsi_status;
+
+	/* Generate LU queue on cntrl, target, LUN */
+	b = cp->device->channel;
+	t = cp->device->id;
+	l = cp->device->lun,
+
+	tq = sp->tgt_queue;
+	lq = sp->lun_queue;
+
+	/*
+	 * If loop is in transient state Report DID_BUS_BUSY
+	 */
+	if ((comp_status != CS_COMPLETE || scsi_status != 0)) {
+		if (!(sp->flags & SRB_IOCTL) &&
+		    (atomic_read(&ha->loop_down_timer) ||
+			atomic_read(&ha->loop_state) != LOOP_READY)) {
+
+			DEBUG2(printk("scsi(%ld:%d:%d:%d): Loop Not Ready - "
+			    "pid=%lx.\n",
+			    ha->host_no, b, t, l, cp->serial_number));
+
+			qla2x00_extend_timeout(cp, EXTEND_CMD_TIMEOUT);
+			add_to_retry_queue(ha, sp);
+			return;
+		}
+	}
+
+	/*
+	 * Based on Host and scsi status generate status code for Linux
+	 */
+	switch (comp_status) {
+	case CS_COMPLETE:
+		if (scsi_status == 0) {
+			cp->result = DID_OK << 16;
+			break;
+		}
+		if (lscsi_status == SS_BUSY_CONDITION) {
+			cp->result = DID_BUS_BUSY << 16 | lscsi_status;
+			break;
+		}
+
+		cp->result = DID_OK << 16 | lscsi_status;
+
+		if (lscsi_status != SS_CHECK_CONDITION)
+			break;
+
+		/*
+		 * Copy Sense Data into sense buffer
+		 */
+		memset(cp->sense_buffer, 0, sizeof(cp->sense_buffer));
+
+		if (!(scsi_status & SS_SENSE_LEN_VALID))
+			break;
+
+		if (le16_to_cpu(pkt->req_sense_length) <
+		    sizeof(cp->sense_buffer))
+			sense_sz = le16_to_cpu(pkt->req_sense_length);
+		else
+			sense_sz = sizeof(cp->sense_buffer) - 1;
+
+		CMD_ACTUAL_SNSLEN(cp) = sense_sz;
+		sp->request_sense_length = sense_sz;
+		sp->request_sense_ptr = cp->sense_buffer;
+
+		if (sp->request_sense_length > 32)
+			sense_sz = 32;
+
+		memcpy(cp->sense_buffer, pkt->req_sense_data, sense_sz);
+
+		sp->request_sense_ptr += sense_sz;
+		sp->request_sense_length -= sense_sz;
+		if (sp->request_sense_length != 0)
+			ha->status_srb = sp;
+
+		if (!(sp->flags & SRB_IOCTL) &&
+		    qla2x00_check_sense(cp, lq) == QLA_SUCCESS) {
+			/* Throw away status_cont if any */
+			ha->status_srb = NULL;
+			add_to_scsi_retry_queue(ha, sp);
+			return;
+		}
+
+		DEBUG5(printk("%s(): Check condition Sense data, "
+		    "scsi(%ld:%d:%d:%d) cmd=%p pid=%ld\n",
+		    __func__, ha->host_no, b, t, l, cp,
+		    cp->serial_number));
+		if (sense_sz)
+			DEBUG5(qla2x00_dump_buffer(cp->sense_buffer,
+			    CMD_ACTUAL_SNSLEN(cp)));
+		break;
+
+	case CS_DATA_UNDERRUN:
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld:%d:%d) UNDERRUN status detected 0x%x-0x%x.\n",
+		    ha->host_no, t, l, comp_status, scsi_status));
+
+		resid = le32_to_cpu(pkt->residual_length);
+		CMD_RESID_LEN(cp) = resid;
+
+		/*
+		 * Check to see if SCSI Status is non zero. If so report SCSI 
+		 * Status.
+		 */
+		if (lscsi_status != 0) {
+			if (lscsi_status == SS_BUSY_CONDITION) {
+				cp->result = DID_BUS_BUSY << 16 |
+				    lscsi_status;
+				break;
+			}
+
+			cp->result = DID_OK << 16 | lscsi_status;
+
+			if (lscsi_status != SS_CHECK_CONDITION)
+				break;
+
+			/* Copy Sense Data into sense buffer */
+			memset(cp->sense_buffer, 0, sizeof(cp->sense_buffer));
+
+			if (!(scsi_status & SS_SENSE_LEN_VALID))
+				break;
+
+			if (le16_to_cpu(pkt->req_sense_length) <
+			    sizeof(cp->sense_buffer))
+				sense_sz = le16_to_cpu(pkt->req_sense_length);
+			else
+				sense_sz = sizeof(cp->sense_buffer) - 1;
+
+			CMD_ACTUAL_SNSLEN(cp) = sense_sz;
+			sp->request_sense_length = sense_sz;
+			sp->request_sense_ptr = cp->sense_buffer;
+
+			if (sp->request_sense_length > 32) 
+				sense_sz = 32;
+
+			memcpy(cp->sense_buffer, pkt->req_sense_data, sense_sz);
+
+			sp->request_sense_ptr += sense_sz;
+			sp->request_sense_length -= sense_sz;
+			if (sp->request_sense_length != 0)
+				ha->status_srb = sp;
+
+			if (!(sp->flags & SRB_IOCTL) &&
+			    (qla2x00_check_sense(cp, lq) == QLA_SUCCESS)) {
+				ha->status_srb = NULL;
+				add_to_scsi_retry_queue(ha, sp);
+				return;
+			}
+			DEBUG5(printk("%s(): Check condition Sense data, "
+			    "scsi(%ld:%d:%d:%d) cmd=%p pid=%ld\n",
+			    __func__, ha->host_no, b, t, l, cp,
+			    cp->serial_number));
+			if (sense_sz)
+				DEBUG5(qla2x00_dump_buffer(cp->sense_buffer,
+				    CMD_ACTUAL_SNSLEN(cp)));
+		} else {
+			/*
+			 * If RISC reports underrun and target does not report
+			 * it then we must have a lost frame, so tell upper
+			 * layer to retry it by reporting a bus busy.
+			 */
+			if (!(scsi_status & SS_RESIDUAL_UNDER)) {
+				DEBUG2(printk("scsi(%ld:%d:%d:%d) Dropped "
+				    "frame(s) detected (%x of %x bytes)..."
+				    "retrying command.\n",
+				    ha->host_no, b, t, l, resid,
+				    cp->request_bufflen));
+
+				cp->result = DID_BUS_BUSY << 16;
+				ha->dropped_frame_error_cnt++;
+				break;
+			}
+
+			/* Handle mid-layer underflow */
+			cp->resid = resid;
+			if ((unsigned)(cp->request_bufflen - resid) <
+			    cp->underflow) {
+				qla_printk(KERN_INFO, ha,
+				    "scsi(%ld:%d:%d:%d): Mid-layer underflow "
+				    "detected (%x of %x bytes)...returning "
+				    "error status.\n",
+				    ha->host_no, b, t, l, resid,
+				    cp->request_bufflen);
+
+				cp->result = DID_ERROR << 16;
+				break;
+			}
+
+			/* Everybody online, looking good... */
+			cp->result = DID_OK << 16;
+		}
+		break;
+
+	case CS_DATA_OVERRUN:
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld:%d:%d): OVERRUN status detected 0x%x-0x%x\n",
+		    ha->host_no, t, l, comp_status, scsi_status));
+		DEBUG2(printk(KERN_INFO
+		    "CDB: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
+		    cp->cmnd[0], cp->cmnd[1], cp->cmnd[2], cp->cmnd[3],
+		    cp->cmnd[4], cp->cmnd[5]));
+		DEBUG2(printk(KERN_INFO
+		    "PID=0x%lx req=0x%x xtra=0x%x -- returning DID_ERROR "
+		    "status!\n",
+		    cp->serial_number, cp->request_bufflen,
+		    le32_to_cpu(pkt->residual_length)));
+
+		cp->result = DID_ERROR << 16;
+		break;
+
+	case CS_PORT_LOGGED_OUT:
+	case CS_PORT_CONFIG_CHG:
+	case CS_PORT_BUSY:
+	case CS_INCOMPLETE:
+	case CS_PORT_UNAVAILABLE:
+		/*
+		 * If the port is in Target Down state, return all IOs for this
+		 * Target with DID_NO_CONNECT ELSE Queue the IOs in the
+		 * retry_queue.
+		 */
+		fcport = sp->fclun->fcport;
+		DEBUG2(printk("scsi(%ld:%d:%d): status_entry: Port Down "
+		    "pid=%ld, compl status=0x%x, port state=0x%x\n",
+		    ha->host_no, t, l, cp->serial_number, comp_status,
+		    atomic_read(&fcport->state)));
+
+		if ((sp->flags & SRB_IOCTL) ||
+		    atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+			cp->result = DID_NO_CONNECT << 16;
+			add_to_done_queue(ha, sp);
+		} else {
+			qla2x00_extend_timeout(cp, EXTEND_CMD_TIMEOUT);
+			add_to_retry_queue(ha, sp);
+		}
+
+		if (atomic_read(&fcport->state) == FCS_ONLINE) {
+			qla2x00_mark_device_lost(ha, fcport, 1);
+		}
+
+		return;
+		break;
+
+	case CS_RESET:
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld): RESET status detected 0x%x-0x%x.\n",
+		    ha->host_no, comp_status, scsi_status));
+
+		if (sp->flags & SRB_IOCTL) {
+			cp->result = DID_RESET << 16;
+		} else {
+			qla2x00_extend_timeout(cp, EXTEND_CMD_TIMEOUT);
+			add_to_retry_queue(ha, sp);
+			return;
+		}
+		break;
+
+	case CS_ABORTED:
+		/* 
+		 * hv2.19.12 - DID_ABORT does not retry the request if we
+		 * aborted this request then abort otherwise it must be a
+		 * reset.
+		 */
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld): ABORT status detected 0x%x-0x%x.\n",
+		    ha->host_no, comp_status, scsi_status));
+
+		cp->result = DID_RESET << 16;
+		break;
+
+	case CS_TIMEOUT:
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld:%d:%d:%d): TIMEOUT status detected 0x%x-0x%x.\n",
+		    ha->host_no, b, t, l, comp_status, scsi_status));
+
+		cp->result = DID_BUS_BUSY << 16;
+
+		fcport = lq->fclun->fcport;
+
+		/* Check to see if logout occurred */
+		if ((le16_to_cpu(pkt->status_flags) & SF_LOGOUT_SENT)) {
+			qla2x00_mark_device_lost(ha, fcport, 1);
+		}
+		break;
+
+	case CS_QUEUE_FULL:
+		DEBUG2(printk(KERN_INFO
+		    "scsi(%ld): QUEUE FULL status detected 0x%x-0x%x.\n",
+		    ha->host_no, comp_status, scsi_status));
+
+		/* SCSI Mid-Layer handles device queue full */
+
+		cp->result = DID_OK << 16 | lscsi_status; 
+
+		/* TODO: ??? */
+		/* Adjust queue depth */
+		ret = scsi_track_queue_full(cp->device,
+		    sp->lun_queue->out_cnt - 1);
+		if (ret) {
+			qla_printk(KERN_INFO, ha,
+			    "scsi(%ld:%d:%d:%d): Queue depth adjusted to %d.\n",
+			    ha->host_no, cp->device->channel, cp->device->id,
+			    cp->device->lun, ret);
+		}
+		break;
+
+	default:
+		DEBUG3(printk("scsi(%ld): Error detected (unknown status) "
+		    "0x%x-0x%x.\n",
+		    ha->host_no, comp_status, scsi_status));
+		qla_printk(KERN_INFO, ha,
+		    "Unknown status detected 0x%x-0x%x.\n",
+		    comp_status, scsi_status);
+
+		cp->result = DID_ERROR << 16;
+		break;
+	}
+
+	/* Place command on done queue. */
+	if (ha->status_srb == NULL)
+		add_to_done_queue(ha, sp);
+}
+
+/**
+ * qla2x00_status_cont_entry() - Process a Status Continuations entry.
+ * @ha: SCSI driver HA context
+ * @pkt: Entry pointer
+ *
+ * Extended sense data.
+ */
+static void
+qla2x00_status_cont_entry(scsi_qla_host_t *ha, sts_cont_entry_t *pkt)
+{
+	uint8_t		sense_sz = 0;
+	srb_t		*sp = ha->status_srb;
+	struct scsi_cmnd *cp;
+
+	if (sp != NULL && sp->request_sense_length != 0) {
+		cp = sp->cmd;
+		if (cp == NULL) {
+			DEBUG2(printk("%s(): Cmd already returned back to OS "
+			    "sp=%p sp->state:%d\n", __func__, sp, sp->state));
+			qla_printk(KERN_INFO, ha,
+			    "cmd is NULL: already returned to OS (sp=%p)\n",
+			    sp); 
+
+			ha->status_srb = NULL;
+			return;
+		}
+
+		if (sp->request_sense_length > sizeof(pkt->data)) {
+			sense_sz = sizeof(pkt->data);
+		} else {
+			sense_sz = sp->request_sense_length;
+		}
+
+		/* Move sense data. */
+		memcpy(sp->request_sense_ptr, pkt->data, sense_sz);
+		DEBUG5(qla2x00_dump_buffer(sp->request_sense_ptr, sense_sz));
+
+		sp->request_sense_ptr += sense_sz;
+		sp->request_sense_length -= sense_sz;
+
+		/* Place command on done queue. */
+		if (sp->request_sense_length == 0) {
+			add_to_done_queue(ha, sp);
+			ha->status_srb = NULL;
+		}
+	}
+}
+
+/**
+ * qla2x00_error_entry() - Process an error entry.
+ * @ha: SCSI driver HA context
+ * @pkt: Entry pointer
+ */
+static void
+qla2x00_error_entry(scsi_qla_host_t *ha, sts_entry_t *pkt) 
+{
+	srb_t *sp;
+
+#if defined(QL_DEBUG_LEVEL_2)
+	if (pkt->entry_status & RF_INV_E_ORDER)
+		qla_printk(KERN_ERR, ha, "%s: Invalid Entry Order\n", __func__);
+	else if (pkt->entry_status & RF_INV_E_COUNT)
+		qla_printk(KERN_ERR, ha, "%s: Invalid Entry Count\n", __func__);
+	else if (pkt->entry_status & RF_INV_E_PARAM)
+		qla_printk(KERN_ERR, ha, 
+		    "%s: Invalid Entry Parameter\n", __func__);
+	else if (pkt->entry_status & RF_INV_E_TYPE)
+		qla_printk(KERN_ERR, ha, "%s: Invalid Entry Type\n", __func__);
+	else if (pkt->entry_status & RF_BUSY)
+		qla_printk(KERN_ERR, ha, "%s: Busy\n", __func__);
+	else
+		qla_printk(KERN_ERR, ha, "%s: UNKNOWN flag error\n", __func__);
+#endif
+
+	/* Validate handle. */
+	if (pkt->handle < MAX_OUTSTANDING_COMMANDS)
+		sp = ha->outstanding_cmds[pkt->handle];
+	else
+		sp = NULL;
+
+	if (sp) {
+		/* Free outstanding command slot. */
+		ha->outstanding_cmds[pkt->handle] = 0;
+		if (ha->actthreads)
+			ha->actthreads--;
+		sp->lun_queue->out_cnt--;
+
+		/* Bad payload or header */
+		if (pkt->entry_status &
+		    (RF_INV_E_ORDER | RF_INV_E_COUNT |
+		     RF_INV_E_PARAM | RF_INV_E_TYPE)) {
+			sp->cmd->result = DID_ERROR << 16;
+		} else if (pkt->entry_status & RF_BUSY) {
+			sp->cmd->result = DID_BUS_BUSY << 16;
+		} else {
+			sp->cmd->result = DID_ERROR << 16;
+		}
+		/* Place command on done queue. */
+		add_to_done_queue(ha, sp);
+
+	} else if (pkt->entry_type == COMMAND_A64_TYPE ||
+	    pkt->entry_type == COMMAND_TYPE) {
+		DEBUG2(printk("scsi(%ld): Error entry - invalid handle\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha,
+		    "Error entry - invalid handle\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		if (ha->dpc_wait && !ha->dpc_active) 
+			up(ha->dpc_wait);
+	}
+}
+
+/**
+ * qla2x00_ms_entry() - Process a Management Server entry.
+ * @ha: SCSI driver HA context
+ * @index: Response queue out pointer
+ */
+static void
+qla2x00_ms_entry(scsi_qla_host_t *ha, ms_iocb_entry_t *pkt) 
+{
+	srb_t          *sp;
+
+	DEBUG3(printk("%s(%ld): pkt=%p pkthandle=%d.\n",
+	    __func__, ha->host_no, pkt, pkt->handle1));
+
+	/* Validate handle. */
+ 	if (pkt->handle1 < MAX_OUTSTANDING_COMMANDS)
+ 		sp = ha->outstanding_cmds[pkt->handle1];
+	else
+		sp = NULL;
+
+	if (sp == NULL) {
+		DEBUG2(printk("scsi(%ld): MS entry - invalid handle\n",
+		    ha->host_no));
+		qla_printk(KERN_WARNING, ha, "MS entry - invalid handle\n");
+
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		return;
+	}
+
+	CMD_COMPL_STATUS(sp->cmd) = le16_to_cpu(pkt->status);
+	CMD_ENTRY_STATUS(sp->cmd) = pkt->entry_status;
+
+	/* Free outstanding command slot. */
+	ha->outstanding_cmds[pkt->handle1] = 0;
+
+	add_to_done_queue(ha, sp);
+}
+
+/**
+ * qla2x00_check_sense() - Perform any sense data interrogation.
+ * @cp: SCSI Command
+ * @lq: Lun queue
+ *
+ * Returns QLA_SUCCESS if the lun queue is suspended, else
+ * QLA_FUNCTION_FAILED  (lun queue not suspended).
+ */
+static int 
+qla2x00_check_sense(struct scsi_cmnd *cp, os_lun_t *lq)
+{
+	scsi_qla_host_t	*ha;
+	srb_t		*sp;
+	fc_port_t	*fcport;
+
+	ha = (scsi_qla_host_t *) cp->device->host->hostdata;
+	if ((cp->sense_buffer[0] & 0x70) != 0x70) {
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	sp = (srb_t * )CMD_SP(cp);
+	sp->flags |= SRB_GOT_SENSE;
+
+	switch (cp->sense_buffer[2] & 0xf) {
+	case RECOVERED_ERROR:
+		cp->result = DID_OK << 16;
+		cp->sense_buffer[0] = 0;
+		break;
+
+	case NOT_READY:
+		fcport = lq->fclun->fcport;
+
+		/*
+		 * Suspend the lun only for hard disk device type.
+		 */
+		if ((fcport->flags & FCF_TAPE_PRESENT) == 0 &&
+		    lq->q_state != LUN_STATE_TIMEOUT) {
+			/*
+			 * If target is in process of being ready then suspend
+			 * lun for 6 secs and retry all the commands.
+			 */
+			if (cp->sense_buffer[12] == 0x4 &&
+			    cp->sense_buffer[13] == 0x1) {
+
+				/* Suspend the lun for 6 secs */
+				qla2x00_suspend_lun(ha, lq, 6,
+				    ql2xsuspendcount);
+
+				return (QLA_SUCCESS);
+			}
+		}
+		break;
+	}
+
+	return (QLA_FUNCTION_FAILED);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_listops.h linux-2.5/drivers/scsi/qla2xxx/qla_listops.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_listops.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_listops.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,351 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+/* Management functions for various lists */
+
+/* __add_to_done_queue()
+ * 
+ * Place SRB command on done queue.
+ *
+ * Input:
+ *      ha           = host pointer
+ *      sp           = srb pointer.
+ * Locking:
+ * 	this function assumes the ha->list_lock is already taken
+ */
+static inline void 
+__add_to_done_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	/*
+        if (sp->state != SRB_NO_QUEUE_STATE && 
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+        /* Place block on done queue */
+        sp->cmd->host_scribble = (unsigned char *) NULL;
+        sp->state = SRB_DONE_STATE;
+        list_add_tail(&sp->list,&ha->done_queue);
+        ha->done_q_cnt++;
+	sp->ha = ha;
+}
+
+static inline void 
+__add_to_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	/*
+        if( sp->state != SRB_NO_QUEUE_STATE && 
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+        /* Place block on retry queue */
+        list_add_tail(&sp->list,&ha->retry_queue);
+        ha->retry_q_cnt++;
+        sp->flags |= SRB_WATCHDOG;
+        sp->state = SRB_RETRY_STATE;
+	sp->ha = ha;
+}
+
+static inline void 
+__add_to_scsi_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	/*
+        if( sp->state != SRB_NO_QUEUE_STATE && 
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+        /* Place block on retry queue */
+        list_add_tail(&sp->list,&ha->scsi_retry_queue);
+        ha->scsi_retry_q_cnt++;
+        sp->state = SRB_SCSI_RETRY_STATE;
+	sp->ha = ha;
+}
+
+static inline void 
+add_to_done_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+        __add_to_done_queue(ha,sp);
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void 
+add_to_free_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	mempool_free(sp, ha->srb_mempool);
+}
+
+static inline void 
+add_to_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+        __add_to_retry_queue(ha,sp);
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void 
+add_to_scsi_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+        __add_to_scsi_retry_queue(ha,sp);
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/*
+ * __del_from_retry_queue
+ *      Function used to remove a command block from the
+ *      watchdog timer queue.
+ *
+ *      Note: Must insure that command is on watchdog
+ *            list before calling del_from_retry_queue
+ *            if (sp->flags & SRB_WATCHDOG)
+ *
+ * Input: 
+ *      ha = adapter block pointer.
+ *      sp = srb pointer.
+ * Locking:
+ *	this function assumes the list_lock is already taken
+ */
+static inline void 
+__del_from_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        list_del_init(&sp->list);
+
+        sp->flags &= ~(SRB_WATCHDOG | SRB_BUSY);
+        sp->state = SRB_NO_QUEUE_STATE;
+        ha->retry_q_cnt--;
+}
+
+/*
+ * __del_from_scsi_retry_queue
+ *      Function used to remove a command block from the
+ *      scsi retry queue.
+ *
+ * Input: 
+ *      ha = adapter block pointer.
+ *      sp = srb pointer.
+ * Locking:
+ *	this function assumes the list_lock is already taken
+ */
+static inline void 
+__del_from_scsi_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        list_del_init(&sp->list);
+
+        ha->scsi_retry_q_cnt--;
+        sp->state = SRB_NO_QUEUE_STATE;
+}
+
+/*
+ * del_from_retry_queue
+ *      Function used to remove a command block from the
+ *      watchdog timer queue.
+ *
+ *      Note: Must insure that command is on watchdog
+ *            list before calling del_from_retry_queue
+ *            if (sp->flags & SRB_WATCHDOG)
+ *
+ * Input: 
+ *      ha = adapter block pointer.
+ *      sp = srb pointer.
+ * Locking:
+ *	this function takes and releases the list_lock
+ */
+static inline void 
+del_from_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        /*	if (unlikely(!(sp->flags & SRB_WATCHDOG)))
+        		BUG();*/
+        spin_lock_irqsave(&ha->list_lock, flags);
+
+        /*	if (unlikely(list_empty(&ha->retry_queue)))
+        		BUG();*/
+
+        __del_from_retry_queue(ha,sp);
+
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+/*
+ * del_from_scsi_retry_queue
+ *      Function used to remove a command block from the
+ *      scsi retry queue.
+ *
+ * Input: 
+ *      ha = adapter block pointer.
+ *      sp = srb pointer.
+ * Locking:
+ *	this function takes and releases the list_lock
+ */
+static inline void 
+del_from_scsi_retry_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+
+        /*	if (unlikely(list_empty(&ha->scsi_retry_queue)))
+        		BUG();*/
+
+        __del_from_scsi_retry_queue(ha,sp);
+
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/*
+ * __add_to_pending_queue
+ *      Add the standard SCB job to the bottom of standard SCB commands.
+ *
+ * Input:
+ * COMPLETE!!!
+ *      q  = SCSI LU pointer.
+ *      sp = srb pointer.
+ *      SCSI_LU_Q lock must be already obtained.
+ */
+static inline int 
+__add_to_pending_queue(struct scsi_qla_host *ha, srb_t * sp)
+{
+	int	empty;
+	/*
+        if( sp->state != SRB_NO_QUEUE_STATE &&
+        	sp->state != SRB_FREE_STATE &&
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+	empty = list_empty(&ha->pending_queue);
+	list_add_tail(&sp->list, &ha->pending_queue);
+	ha->qthreads++;
+	sp->state = SRB_PENDING_STATE;
+
+	return (empty);
+}
+
+static inline void 
+__add_to_pending_queue_head(struct scsi_qla_host *ha, srb_t * sp)
+{
+	/*
+        if( sp->state != SRB_NO_QUEUE_STATE && 
+        	sp->state != SRB_FREE_STATE &&
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+	list_add(&sp->list, &ha->pending_queue);
+	ha->qthreads++;
+	sp->state = SRB_PENDING_STATE;
+}
+
+static inline int
+add_to_pending_queue(struct scsi_qla_host *ha, srb_t *sp)
+{
+	int	empty;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	empty = __add_to_pending_queue(ha, sp);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	return (empty);
+}
+static inline void
+add_to_pending_queue_head(struct scsi_qla_host *ha, srb_t *sp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	__add_to_pending_queue_head(ha, sp);
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void
+__del_from_pending_queue(struct scsi_qla_host *ha, srb_t *sp)
+{
+	list_del_init(&sp->list);
+	ha->qthreads--;
+	sp->state = SRB_NO_QUEUE_STATE;
+}
+
+/*
+ * Failover Stuff.
+ */
+static inline void
+__add_to_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+	/*
+        if( sp->state != SRB_NO_QUEUE_STATE && 
+        	sp->state != SRB_ACTIVE_STATE)
+		BUG();
+	*/
+
+        list_add_tail(&sp->list,&ha->failover_queue);
+        ha->failover_cnt++;
+        sp->state = SRB_FAILOVER_STATE;
+	sp->ha = ha;
+}
+
+static inline void add_to_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+
+        __add_to_failover_queue(ha,sp);
+
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+static inline void __del_from_failover_queue(struct scsi_qla_host * ha, srb_t *
+                sp)
+{
+        ha->failover_cnt--;
+        list_del_init(&sp->list);
+        sp->state = SRB_NO_QUEUE_STATE;
+}
+
+static inline void del_from_failover_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+
+        __del_from_failover_queue(ha,sp);
+
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+static inline void 
+del_from_pending_queue(struct scsi_qla_host * ha, srb_t * sp)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&ha->list_lock, flags);
+
+        __del_from_pending_queue(ha,sp);
+
+        spin_unlock_irqrestore(&ha->list_lock, flags);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_mbx.c linux-2.5/drivers/scsi/qla2xxx/qla_mbx.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_mbx.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_mbx.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,2778 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include "qla_os.h"
+
+#include "qla_def.h"
+
+/*
+ *  Local Function Prototypes.
+ */
+static void
+qla2x00_mbx_sem_timeout(unsigned long);
+
+static int
+qla2x00_get_mbx_access(scsi_qla_host_t *, uint32_t);
+
+static int
+qla2x00_release_mbx_access(scsi_qla_host_t *, uint32_t);
+
+static int
+qla2x00_mbx_q_add(scsi_qla_host_t *, mbx_cmdq_t **);
+
+static void
+qla2x00_mbx_q_get(scsi_qla_host_t *, mbx_cmdq_t **);
+
+static void
+qla2x00_mbx_q_memb_alloc(scsi_qla_host_t *, mbx_cmdq_t **);
+
+static void
+qla2x00_mbx_q_memb_free(scsi_qla_host_t *, mbx_cmdq_t *);
+
+/***************************/
+/* Function implementation */
+/***************************/
+
+static void
+qla2x00_mbx_sem_timeout(unsigned long data)
+{
+	struct semaphore	*sem_ptr = (struct semaphore *)data;
+
+	DEBUG11(printk("qla2x00_sem_timeout: entered.\n");)
+
+	if (sem_ptr != NULL) {
+		up(sem_ptr);
+	}
+
+	DEBUG11(printk("qla2x00_mbx_sem_timeout: exiting.\n");)
+}
+
+/*
+ *  tov = timeout value in seconds
+ */
+static int
+qla2x00_get_mbx_access(scsi_qla_host_t *ha, uint32_t tov)
+{
+	int		ret;
+	int		prev_val = 1;  /* assume no access yet */
+	mbx_cmdq_t	*ptmp_mbq;
+	struct timer_list	tmp_cmd_timer;
+	unsigned long	cpu_flags;
+
+
+	DEBUG11(printk("qla2x00_get_mbx_access(%ld): entered.\n",
+	    ha->host_no);)
+
+	while (1) {
+		if (test_bit(MBX_CMD_WANT, &ha->mbx_cmd_flags) == 0) {
+
+			DEBUG11(printk("qla2x00_get_mbx_access(%ld): going "
+			    " to test access flags.\n", ha->host_no);)
+
+			/* No one else is waiting. Go ahead and try to
+			 * get access.
+			 */
+			if ((prev_val = test_and_set_bit(MBX_CMD_ACTIVE,
+			    &ha->mbx_cmd_flags)) == 0) {
+				break;
+			}
+		}
+
+		/* wait for previous command to finish */
+		DEBUG(printk("qla2x00_get_mbx_access(%ld): access "
+		    "flags=%lx. busy. Waiting for access. curr time=0x%lx.\n",
+		    ha->host_no, ha->mbx_cmd_flags, jiffies);)
+
+		DEBUG11(printk("qla2x00_get_mbx_access(%ld): access "
+		    "flags=%lx. busy. Waiting for access. curr time=0x%lx.\n",
+		    ha->host_no, ha->mbx_cmd_flags, jiffies);)
+
+		/*
+		 * Init timer and get semaphore from mbx q. After we got valid
+		 * semaphore pointer the MBX_CMD_WANT flag would also had
+		 * been set.
+		 */
+		qla2x00_mbx_q_add(ha, &ptmp_mbq);
+
+		if (ptmp_mbq == NULL) {
+			/* queue full? problem? can't proceed. */
+			DEBUG2_3_11(printk("qla2x00_get_mbx_access(%ld): ERROR "
+			    "no more mbx_q allowed. exiting.\n", ha->host_no);)
+
+			break;
+		}
+
+		/* init timer and semaphore */
+		init_timer(&tmp_cmd_timer);
+		tmp_cmd_timer.data = (unsigned long)&ptmp_mbq->cmd_sem;
+		tmp_cmd_timer.function =
+		    (void (*)(unsigned long))qla2x00_mbx_sem_timeout;
+		tmp_cmd_timer.expires = jiffies + tov * HZ;
+
+		DEBUG11(printk("get_mbx_access(%ld): adding timer. "
+		    "curr time=0x%lx timeoutval=0x%lx.\n",
+		    ha->host_no, jiffies, tmp_cmd_timer.expires);)
+
+			/* wait. */
+/*	 	 add_timer(&tmp_cmd_timer);*/
+		DEBUG11(printk("get_mbx_access(%ld): going to sleep. "
+		    "current time=0x%lx.\n", ha->host_no, jiffies);)
+
+		down_interruptible(&ptmp_mbq->cmd_sem);
+
+		DEBUG11(printk("get_mbx_access(%ld): woke up. current "
+		    "time=0x%lx.\n",
+		    ha->host_no, jiffies);)
+
+/*		del_timer(&tmp_cmd_timer);*/
+
+		/* try to get lock again. we'll test later to see
+		 * if we actually got the lock.
+		 */
+		prev_val = test_and_set_bit(MBX_CMD_ACTIVE,
+		    &ha->mbx_cmd_flags);
+
+		/*
+		 * After we tried to get access then we check to see
+		 * if we need to clear the MBX_CMD_WANT flag. Don't clear
+		 * this flag before trying to get access or else another
+		 * new thread might grab it before we did.
+		 */
+		spin_lock_irqsave(&ha->mbx_q_lock, cpu_flags);
+		if (ha->mbx_q_head == NULL) {
+			/* We're the last thread in queue. */
+			clear_bit(MBX_CMD_WANT, &ha->mbx_cmd_flags);
+		}
+		qla2x00_mbx_q_memb_free(ha, ptmp_mbq);
+		spin_unlock_irqrestore(&ha->mbx_q_lock, cpu_flags);
+
+		break;
+	}
+
+	if (prev_val == 0) {
+		/* We got the lock */
+		DEBUG11(printk("qla2x00_get_mbx_access(%ld): success.\n",
+		    ha->host_no);)
+
+		ret = QLA_SUCCESS;
+	} else {
+		/* Timeout or resource error. */
+		DEBUG2_3_11(printk("qla2x00_get_mbx_access(%ld): timed out.\n",
+		    ha->host_no);)
+
+		ret = QLA_FUNCTION_TIMEOUT;
+	}
+
+	return ret;
+}
+
+static int
+qla2x00_release_mbx_access(scsi_qla_host_t *ha, uint32_t tov)
+{
+	mbx_cmdq_t	*next_thread;
+
+	DEBUG11(printk("qla2x00_release_mbx_access:(%ld): entered.\n",
+	    ha->host_no);)
+
+	clear_bit(MBX_CMD_ACTIVE, &ha->mbx_cmd_flags);
+
+	/* Wake up one pending mailbox cmd thread in queue. */
+	qla2x00_mbx_q_get(ha, &next_thread);
+	if (next_thread) {
+		DEBUG11(printk("qla2x00_release_mbx_access: found pending "
+		    "mbx cmd. Waking up sem in %p.\n", &next_thread);)
+		up(&next_thread->cmd_sem);
+	}
+
+	DEBUG11(printk("qla2x00_release_mbx_access:(%ld): exiting.\n",
+	    ha->host_no);)
+
+	return QLA_SUCCESS;
+}
+
+/* Allocates a mbx_cmdq_t struct and add to the mbx_q list. */
+static int
+qla2x00_mbx_q_add(scsi_qla_host_t *ha, mbx_cmdq_t **ret_mbq)
+{
+	int		ret;
+	unsigned long	cpu_flags;
+	mbx_cmdq_t	*ptmp = NULL;
+
+	spin_lock_irqsave(&ha->mbx_q_lock, cpu_flags);
+
+	DEBUG11(printk("qla2x00_mbx_q_add: got mbx_q spinlock. "
+	    "Inst=%d.\n", apiHBAInstance);)
+
+	qla2x00_mbx_q_memb_alloc(ha, &ptmp);
+	if (ptmp == NULL) {
+		/* can't add any more threads */
+		DEBUG2_3_11(printk("qla2x00_mbx_q_add: ERROR no more "
+		    "ioctl threads allowed. Inst=%d.\n", apiHBAInstance);)
+
+		ret = QLA_MEMORY_ALLOC_FAILED;
+	} else {
+		if (ha->mbx_q_tail == NULL) {
+			/* First thread to queue. */
+			set_bit(MBX_CMD_WANT, &ha->mbx_cmd_flags);
+
+			ha->mbx_q_head = ptmp;
+		} else {
+			ha->mbx_q_tail->pnext = ptmp;
+		}
+		ha->mbx_q_tail = ptmp;
+
+		/* Now init the semaphore */
+		init_MUTEX_LOCKED(&ptmp->cmd_sem);
+		ret = QLA_SUCCESS;
+	}
+
+	*ret_mbq = ptmp;
+
+	DEBUG11(printk("qla2x00_mbx_q_add: going to release spinlock. "
+	    "ret_mbq=%p, ret=%d. Inst=%d.\n", *ret_mbq, ret, apiHBAInstance);)
+
+	spin_unlock_irqrestore(&ha->mbx_q_lock, cpu_flags);
+
+	return ret;
+}
+
+/* Just remove and return first member from mbx_cmdq.  Don't free anything. */
+static void
+qla2x00_mbx_q_get(scsi_qla_host_t *ha, mbx_cmdq_t **ret_mbq)
+{
+	unsigned long	cpu_flags;
+
+	spin_lock_irqsave(&ha->mbx_q_lock, cpu_flags);
+
+	DEBUG11(printk("qla2x00_mbx_q_get: got mbx_q spinlock. "
+	    "Inst=%d.\n", apiHBAInstance);)
+
+	/* Remove from head */
+	*ret_mbq = ha->mbx_q_head;
+	if (ha->mbx_q_head != NULL) {
+		ha->mbx_q_head = ha->mbx_q_head->pnext;
+		if (ha->mbx_q_head == NULL) {
+			/* That's the last one in queue. */
+			ha->mbx_q_tail = NULL;
+		}
+		(*ret_mbq)->pnext = NULL;
+	}
+
+	DEBUG11(printk("qla2x00_mbx_q_remove: return ret_mbq=%p. Going to "
+	    "release spinlock. Inst=%d.\n", *ret_mbq, apiHBAInstance);)
+
+	spin_unlock_irqrestore(&ha->mbx_q_lock, cpu_flags);
+}
+
+/* Find a free mbx_q member from the array. Must already got the
+ * mbx_q_lock spinlock.
+ */
+static void
+qla2x00_mbx_q_memb_alloc(scsi_qla_host_t *ha, mbx_cmdq_t **ret_mbx_q_memb)
+{
+	mbx_cmdq_t	*ptmp = NULL;
+
+	DEBUG11(printk("qla2x00_mbx_q_memb_alloc: entered. "
+	    "Inst=%d.\n", apiHBAInstance);)
+
+	ptmp = ha->mbx_sem_pool_head;
+	if (ptmp != NULL) {
+		ha->mbx_sem_pool_head = ptmp->pnext;
+		ptmp->pnext = NULL;
+		if (ha->mbx_sem_pool_head == NULL) {
+			ha->mbx_sem_pool_tail = NULL;
+		}
+	} else {
+		/* We ran out of pre-allocated semaphores.  Try to allocate
+		 * a new one.
+		 */
+		ptmp = kmalloc(sizeof(mbx_cmdq_t), GFP_ATOMIC);
+		if(ptmp)
+			memset(ptmp, 0, sizeof(mbx_cmdq_t));
+	}
+
+	*ret_mbx_q_memb = ptmp;
+
+	DEBUG11(printk("qla2x00_mbx_q_memb_alloc: return waitq_memb=%p. "
+	    "Inst=%d.\n", *ret_mbx_q_memb, apiHBAInstance);)
+}
+
+/* Add the specified mbx_q member back to the free semaphore pool. Must
+ * already got the mbx_q_lock spinlock.
+ */
+static void
+qla2x00_mbx_q_memb_free(scsi_qla_host_t *ha, mbx_cmdq_t *pfree_mbx_q_memb)
+{
+	DEBUG11(printk("qla2x00_mbx_q_memb_free: entered. Inst=%d.\n",
+	    apiHBAInstance);)
+
+	if (pfree_mbx_q_memb != NULL) {
+		if (ha->mbx_sem_pool_tail != NULL) {
+			/* Add to tail */
+			ha->mbx_sem_pool_tail->pnext = pfree_mbx_q_memb;
+		} else {
+			ha->mbx_sem_pool_head = pfree_mbx_q_memb;
+		}
+		ha->mbx_sem_pool_tail = pfree_mbx_q_memb;
+	}
+
+	/* put it back to the free pool. */
+
+	DEBUG11(printk("qla2x00_mbx_q_memb_free: exiting. "
+	    "Inst=%d.\n", apiHBAInstance);)
+}
+
+/*
+ * qla2x00_mailbox_command
+ *	Issue mailbox command and waits for completion.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	mcp = driver internal mbx struct pointer.
+ *
+ * Output:
+ *	mb[MAX_MAILBOX_REGISTER_COUNT] = returned mailbox data.
+ *
+ * Returns:
+ *	0 : QLA_SUCCESS = cmd performed success
+ *	1 : QLA_FUNCTION_FAILED   (error encountered)
+ *	6 : QLA_FUNCTION_TIMEOUT (timeout condition encountered)
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_mailbox_command(scsi_qla_host_t *ha, mbx_cmd_t *mcp)
+{
+	int		rval;
+	unsigned long    flags = 0;
+	device_reg_t     *reg       = ha->iobase;
+	struct timer_list	tmp_intr_timer;
+	uint8_t		abort_active = test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+	uint8_t		io_lock_on = ha->flags.init_done;
+	uint8_t		tmp_stat = 0;
+	uint16_t	command;
+	uint16_t	*iptr, *optr;
+	uint32_t	cnt;
+	uint32_t	mboxes;
+	unsigned long	mbx_flags = 0;
+	unsigned long	wait_time;
+
+	rval = QLA_SUCCESS;
+
+	DEBUG11(printk("qla2x00_mailbox_command(%ld): entered.\n",
+	    ha->host_no);)
+	/*
+	 * Wait for active mailbox commands to finish by waiting at most
+	 * tov seconds. This is to serialize actual issuing of mailbox cmds
+	 * during non ISP abort time.
+	 */
+	if (!abort_active) {
+		tmp_stat = qla2x00_get_mbx_access(ha, mcp->tov);
+		if (tmp_stat != QLA_SUCCESS) {
+			/* Timeout occurred. Return error. */
+			DEBUG2_3_11(printk("qla2x00_mailbox_command(%ld): cmd "
+			    "access timeout. Exiting.\n", ha->host_no);)
+			return QLA_FUNCTION_TIMEOUT;
+		}
+	}
+
+	ha->flags.mbox_busy = TRUE;
+	/* Save mailbox command for debug */
+	ha->mcp = mcp;
+
+	/* Try to get mailbox register access */
+	if (!abort_active)
+		spin_lock_irqsave(&ha->mbx_reg_lock, mbx_flags);
+
+	DEBUG11(printk("scsi%d: prepare to issue mbox cmd=0x%x.\n",
+	    (int)ha->host_no, mcp->mb[0]);)
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Load mailbox registers. */
+	optr = (uint16_t *)MAILBOX_REG(ha, reg, 0);
+
+	iptr = mcp->mb;
+	command = mcp->mb[0];
+	mboxes = mcp->out_mb;
+
+	for (cnt = 0; cnt < ha->mbx_count; cnt++) {
+		if (IS_QLA2200(ha) && cnt == 8)
+			optr = (uint16_t *)MAILBOX_REG(ha, reg, 8);
+		if (mboxes & BIT_0)
+			WRT_REG_WORD(optr, *iptr);
+
+		mboxes >>= 1;
+		optr++;
+		iptr++;
+	}
+
+#if defined(QL_DEBUG_LEVEL_1)
+	printk("qla2x00_mailbox_command: Loaded MBX registers "
+	    "(displayed in bytes) = \n");
+	qla2x00_dump_buffer((uint8_t *)mcp->mb, 16);
+	printk("\n");
+	qla2x00_dump_buffer(((uint8_t *)mcp->mb + 0x10), 16);
+	printk("\n");
+	qla2x00_dump_buffer(((uint8_t *)mcp->mb + 0x20), 8);
+	printk("\n");
+	printk("qla2x00_mailbox_command: I/O address = %lx.\n",
+	    (u_long)optr);
+	qla2x00_dump_regs(ha);
+#endif
+
+	/* Issue set host interrupt command to send cmd out. */
+	ha->flags.mbox_int = FALSE;
+	clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+
+	/* Unlock mbx registers and wait for interrupt */
+
+	DEBUG11(printk("qla2x00_mailbox_command: going to unlock irq & "
+	    "waiting for interrupt. jiffies=%lx.\n", jiffies);)
+
+	/* Wait for mbx cmd completion until timeout */
+
+	if (!abort_active && io_lock_on) {
+		/* sleep on completion semaphore */
+		DEBUG11(printk("qla2x00_mailbox_command(%ld): "
+		    "INTERRUPT MODE. Initializing timer.\n",
+		    ha->host_no);)
+
+		init_timer(&tmp_intr_timer);
+		tmp_intr_timer.data = (unsigned long)&ha->mbx_intr_sem;
+		tmp_intr_timer.expires = jiffies + mcp->tov * HZ;
+		tmp_intr_timer.function =
+		    (void (*)(unsigned long))qla2x00_mbx_sem_timeout;
+
+		DEBUG11(printk("qla2x00_mailbox_command(%ld): "
+		    "Adding timer.\n", ha->host_no);)
+		add_timer(&tmp_intr_timer);
+
+		DEBUG11(printk("qla2x00_mailbox_command: going to "
+		    "unlock & sleep. time=0x%lx.\n", jiffies);)
+
+		set_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);
+
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		if (!abort_active)
+			spin_unlock_irqrestore(&ha->mbx_reg_lock, mbx_flags);
+
+		/* Wait for either the timer to expire
+		 * or the mbox completion interrupt
+		 */
+		down(&ha->mbx_intr_sem);
+
+		DEBUG11(printk("qla2x00_mailbox_command:"
+		    "waking up."
+		    "time=0x%lx\n", jiffies);)
+		clear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);
+
+		/* delete the timer */
+		del_timer(&tmp_intr_timer);
+	} else {
+
+		DEBUG3_11(printk("qla2x00_mailbox_command(%ld): cmd=%x "
+			"POLLING MODE.\n", ha->host_no, command);)
+
+		WRT_REG_WORD(&reg->hccr, HCCR_SET_HOST_INT);
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		if (!abort_active)
+			spin_unlock_irqrestore(&ha->mbx_reg_lock, mbx_flags);
+
+		wait_time = jiffies + mcp->tov * HZ; /* wait at most tov secs */
+		while (!ha->flags.mbox_int) {
+			if (time_after(jiffies, wait_time))
+				break;
+
+			/* Check for pending interrupts. */
+			qla2x00_poll(ha);
+
+			udelay(10); /* v4.27 */
+		} /* while */
+	}
+
+	if (!abort_active)
+		spin_lock_irqsave(&ha->mbx_reg_lock, mbx_flags);
+
+	/* Check whether we timed out */
+	if (ha->flags.mbox_int) {
+
+		DEBUG3_11(printk("qla2x00_mailbox_cmd: cmd %x completed.\n",
+		    command);)
+
+		/* Got interrupt. Clear the flag. */
+		ha->flags.mbox_int = FALSE;
+		clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);
+
+		if (ha->mailbox_out[0] != MBS_COMMAND_COMPLETE) {
+			qla2x00_stats.mboxerr++;
+			rval = QLA_FUNCTION_FAILED;
+		}
+
+		/* Load return mailbox registers. */
+		optr = mcp->mb;
+		iptr = (uint16_t *)&ha->mailbox_out[0];
+		mboxes = mcp->in_mb;
+		for (cnt = 0; cnt < ha->mbx_count; cnt++) {
+			if (mboxes & BIT_0)
+				*optr = *iptr;
+
+			mboxes >>= 1;
+			optr++;
+			iptr++;
+		}
+	} else {
+
+#if defined(QL_DEBUG_LEVEL_2) || defined(QL_DEBUG_LEVEL_3) || \
+		defined(QL_DEBUG_LEVEL_11)
+		printk("qla2x00_mailbox_command(%ld): **** MB Command Timeout "
+		    "for cmd %x ****\n", ha->host_no, command);
+		printk("qla2x00_mailbox_command: icontrol=%x jiffies=%lx\n",
+		    RD_REG_WORD(&reg->ictrl), jiffies);
+		printk("qla2x00_mailbox_command: *** mailbox[0] = 0x%x ***\n",
+		    RD_REG_WORD(optr));
+		qla2x00_dump_regs(ha);
+#endif
+
+		qla2x00_stats.mboxtout++;
+		ha->total_mbx_timeout++;
+		rval = QLA_FUNCTION_TIMEOUT;
+	}
+
+	if (!abort_active)
+		spin_unlock_irqrestore(&ha->mbx_reg_lock, mbx_flags);
+
+	ha->flags.mbox_busy = FALSE;
+
+	/* Clean up */
+	ha->mcp = NULL;
+
+	if (!abort_active) {
+		DEBUG11(printk("qla2x00_mailbox_cmd: checking for additional "
+		    "resp interrupt.\n");)
+
+		/* polling mode for non isp_abort commands. */
+		qla2x00_poll(ha);
+	}
+
+	if (rval == QLA_FUNCTION_TIMEOUT) {
+		if (!io_lock_on || (mcp->flags & IOCTL_CMD)) {
+			/* not in dpc. schedule it for dpc to take over. */
+			DEBUG(printk("qla2x00_mailbox_command(%ld): timeout "
+			    "schedule isp_abort_needed.\n",
+			    ha->host_no);)
+			DEBUG2_3_11(printk("qla2x00_mailbox_command(%ld): "
+			    "timeout schedule isp_abort_needed.\n",
+			    ha->host_no);)
+			set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+			if (ha->dpc_wait && !ha->dpc_active) 
+				up(ha->dpc_wait);
+
+		} else if (!abort_active) {
+
+			/* call abort directly since we are in the DPC thread */
+			DEBUG(printk("qla2x00_mailbox_command(%ld): timeout "
+			    "calling abort_isp\n", ha->host_no);)
+			DEBUG2_3_11(printk("qla2x00_mailbox_command(%ld): "
+			    "timeout calling abort_isp\n", ha->host_no);)
+
+			set_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+			clear_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+			if (qla2x00_abort_isp(ha)) {
+				/* failed. retry later. */
+				set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+			}
+			clear_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+
+			DEBUG(printk("qla2x00_mailbox_command: finished "
+			    "abort_isp\n");)
+			DEBUG2_3_11(printk("qla2x00_mailbox_command: finished "
+			    "abort_isp\n");)
+		}
+	}
+
+	/* Allow next mbx cmd to come in. */
+	if (!abort_active) {
+		tmp_stat = qla2x00_release_mbx_access(ha, mcp->tov);
+
+		if (rval == 0)
+			rval = tmp_stat;
+	}
+
+	if (rval) {
+		DEBUG2_3_11(printk("qla2x00_mailbox_command(%ld): **** FAILED. "
+		    "mbx0=%x, mbx1=%x, mbx2=%x, cmd=%x ****\n",
+		ha->host_no, mcp->mb[0], mcp->mb[1], mcp->mb[2], command);)
+	} else {
+		DEBUG11(printk("qla2x00_mailbox_command(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	DEBUG11(printk("qla2x00_mailbox_command(%ld): exiting.\n",
+	    ha->host_no);)
+
+	return rval;
+}
+
+/*
+ * qla2x00_load_ram
+ *	Load adapter RAM using DMA.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_load_ram(scsi_qla_host_t *ha, dma_addr_t req_dma, uint16_t risc_addr,
+    uint16_t risc_code_size)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	uint32_t	req_len;
+	dma_addr_t	nml_dma;
+	uint32_t	nml_len;
+	uint32_t	normalized;
+
+	DEBUG11(printk("qla2x00_load_ram(%ld): entered.\n",
+	    ha->host_no);)
+
+	req_len = risc_code_size;
+	nml_dma = 0;
+	nml_len = 0;
+
+	normalized = qla2x00_normalize_dma_addr(&req_dma, &req_len, &nml_dma,
+	    &nml_len);
+
+	/* Load first segment */
+	mcp->mb[0] = MBC_LOAD_RISC_RAM;
+	mcp->mb[1] = risc_addr;
+	mcp->mb[2] = MSW(req_dma);
+	mcp->mb[3] = LSW(req_dma);
+	mcp->mb[4] = (uint16_t)req_len;
+	mcp->mb[6] = MSW(MSD(req_dma));
+	mcp->mb[7] = LSW(MSD(req_dma));
+	mcp->out_mb = MBX_7|MBX_6|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Load second segment - if necessary */
+	if (normalized && (rval == QLA_SUCCESS)) {
+		mcp->mb[0] = MBC_LOAD_RISC_RAM;
+		mcp->mb[1] = risc_addr + (uint16_t)req_len;
+		mcp->mb[2] = MSW(nml_dma);
+		mcp->mb[3] = LSW(nml_dma);
+		mcp->mb[4] = (uint16_t)nml_len;
+		mcp->mb[6] = MSW(MSD(nml_dma));
+		mcp->mb[7] = LSW(MSD(nml_dma));
+		mcp->out_mb = MBX_7|MBX_6|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+		mcp->in_mb = MBX_0;
+		mcp->tov = 30;
+		mcp->flags = 0;
+		rval = qla2x00_mailbox_command(ha, mcp);
+	}
+
+	if (rval == QLA_SUCCESS) {
+		/* Empty */
+		DEBUG11(printk("qla2x00_load_ram(%ld): done.\n", ha->host_no);)
+	} else {
+		/* Empty */
+		DEBUG2_3_11(printk("qla2x00_load_ram(%ld): failed. rval=%x "
+		    "mb[0]=%x.\n", ha->host_no, rval, mcp->mb[0]);)
+	}
+	return rval;
+}
+
+/*
+ * qla2x00_load_ram_ext
+ *	Load adapter extended RAM using DMA.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_load_ram_ext(scsi_qla_host_t *ha, dma_addr_t req_dma,
+    uint32_t risc_addr, uint16_t risc_code_size)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	uint32_t	req_len;
+	dma_addr_t	nml_dma;
+	uint32_t	nml_len;
+	uint32_t	normalized;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	req_len = risc_code_size;
+	nml_dma = 0;
+	nml_len = 0;
+
+	normalized = qla2x00_normalize_dma_addr(&req_dma, &req_len, &nml_dma,
+	    &nml_len);
+
+	/* Load first segment */
+	mcp->mb[0] = MBC_LOAD_RISC_RAM_EXTENDED;
+	mcp->mb[1] = LSW(risc_addr);
+	mcp->mb[2] = MSW(req_dma);
+	mcp->mb[3] = LSW(req_dma);
+	mcp->mb[4] = (uint16_t)req_len;
+	mcp->mb[6] = MSW(MSD(req_dma));
+	mcp->mb[7] = LSW(MSD(req_dma));
+	mcp->mb[8] = MSW(risc_addr);
+	mcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Load second segment - if necessary */
+	if (normalized && (rval == QLA_SUCCESS)) {
+		risc_addr += req_len;
+		mcp->mb[0] = MBC_LOAD_RISC_RAM_EXTENDED;
+		mcp->mb[1] = LSW(risc_addr);
+		mcp->mb[2] = MSW(nml_dma);
+		mcp->mb[3] = LSW(nml_dma);
+		mcp->mb[4] = (uint16_t)nml_len;
+		mcp->mb[6] = MSW(MSD(nml_dma));
+		mcp->mb[7] = LSW(MSD(nml_dma));
+		mcp->mb[8] = MSW(risc_addr);
+		mcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+		mcp->in_mb = MBX_0;
+		mcp->tov = 30;
+		mcp->flags = 0;
+		rval = qla2x00_mailbox_command(ha, mcp);
+	}
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed=%x mb[0]=%x.\n",
+		    __func__, ha->host_no, rval, mcp->mb[0]));
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_execute_fw
+ *	Start adapter firmware.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_execute_fw(scsi_qla_host_t *ha)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_execute_fw(%ld): entered.\n", ha->host_no);)
+
+	mcp->mb[0] = MBC_EXECUTE_FIRMWARE;
+	mcp->mb[1] = *ha->brd_info->fw_info[0].fwstart;
+	mcp->out_mb = MBX_1|MBX_0;
+	if (IS_QLA2322(ha)) {
+		mcp->mb[2] = 0;
+		mcp->out_mb |= MBX_2;
+	}
+
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	DEBUG11(printk("qla2x00_execute_fw(%ld): done.\n", ha->host_no);)
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_fw_version
+ *	Get firmware version.
+ *
+ * Input:
+ *	ha:		adapter state pointer.
+ *	major:		pointer for major number.
+ *	minor:		pointer for minor number.
+ *	subminor:	pointer for subminor number.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+void
+qla2x00_get_fw_version(scsi_qla_host_t *ha, uint16_t *major, uint16_t *minor,
+    uint16_t *subminor, uint16_t *attributes)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	mcp->mb[0] = MBC_GET_FIRMWARE_VERSION;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->flags = 0;
+	mcp->tov = 30;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Return mailbox data. */
+	*major = mcp->mb[1];
+	*minor = mcp->mb[2];
+	*subminor = mcp->mb[3];
+	*attributes = mcp->mb[6];
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed=%x.\n", __func__,
+		    ha->host_no, rval));
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+}
+
+/*
+ * qla2x00_get_fw_options
+ *	Set firmware options.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fwopt = pointer for firmware options.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_fw_options(scsi_qla_host_t *ha, uint16_t *fwopts)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	mcp->mb[0] = MBC_GET_FIRMWARE_OPTION;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed=%x.\n", __func__,
+		    ha->host_no, rval));
+	} else {
+		fwopts[1] = mcp->mb[1];
+		fwopts[2] = mcp->mb[2];
+		fwopts[3] = mcp->mb[3];
+
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+
+	return rval;
+}
+
+
+/*
+ * qla2x00_set_fw_options
+ *	Set firmware options.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fwopt = pointer for firmware options.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_set_fw_options(scsi_qla_host_t *ha, uint16_t *fwopts)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	mcp->mb[0] = MBC_SET_FIRMWARE_OPTION;
+	mcp->mb[1] = fwopts[1];
+	mcp->mb[2] = fwopts[2];
+	mcp->mb[3] = fwopts[3];
+	mcp->mb[10] = fwopts[10];
+	mcp->mb[11] = fwopts[11];
+	mcp->mb[12] = 0;	/* Undocumented, but used */
+	mcp->out_mb = MBX_12|MBX_11|MBX_10|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed=%x.\n", __func__,
+		    ha->host_no, rval));
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_read_ram_word
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_read_ram_word(scsi_qla_host_t *ha, uint16_t addr, uint16_t *data)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_read_ram_word(%ld): entered.\n", ha->host_no);)
+
+	mcp->mb[0] = MBC_READ_RAM_WORD;
+	mcp->mb[1] = addr;
+	mcp->out_mb = MBX_1|MBX_0;
+	mcp->in_mb = MBX_0|MBX_2;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_read_ram_word(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		*data = mcp->mb[2];
+		DEBUG11(printk("qla2x00_read_ram_word(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_write_ram_word
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_write_ram_word(scsi_qla_host_t *ha, uint16_t addr, uint16_t data)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_write_ram_word(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_WRITE_RAM_WORD;
+	mcp->mb[1] = addr;
+	mcp->mb[2] = data;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_write_ram_word(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_write_ram_word(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_write_ram_word_ext
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_write_ram_word_ext(scsi_qla_host_t *ha, uint32_t addr, uint16_t data)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	mcp->mb[0] = MBC_WRITE_RAM_WORD_EXTENDED;
+	mcp->mb[1] = LSW(addr);
+	mcp->mb[2] = data;
+	mcp->mb[8] = MSW(addr);
+	mcp->out_mb = MBX_8|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed=%x.\n", __func__,
+		    ha->host_no, rval));
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_mbx_reg_test
+ *	Mailbox register wrap test.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_mbx_reg_test(scsi_qla_host_t *ha)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_mbx_reg_test(%ld): entered.\n", ha->host_no);)
+
+	mcp->mb[0] = MBC_MAILBOX_REGISTER_TEST;
+	mcp->mb[1] = 0xAAAA;
+	mcp->mb[2] = 0x5555;
+	mcp->mb[3] = 0xAA55;
+	mcp->mb[4] = 0x55AA;
+	mcp->mb[5] = 0xA5A5;
+	mcp->mb[6] = 0x5A5A;
+	mcp->mb[7] = 0x2525;
+	mcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval == QLA_SUCCESS) {
+		if (mcp->mb[1] != 0xAAAA || mcp->mb[2] != 0x5555 ||
+		    mcp->mb[3] != 0xAA55 || mcp->mb[4] != 0x55AA)
+			rval = QLA_FUNCTION_FAILED;
+		if (mcp->mb[5] != 0xA5A5 || mcp->mb[6] != 0x5A5A ||
+		    mcp->mb[7] != 0x2525)
+			rval = QLA_FUNCTION_FAILED;
+	}
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_mbx_reg_test(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_mbx_reg_test(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_verify_checksum
+ *	Verify firmware checksum.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_verify_checksum(scsi_qla_host_t *ha)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_verify_checksum(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_VERIFY_CHECKSUM;
+	mcp->mb[1] = *ha->brd_info->fw_info[0].fwstart;
+	mcp->out_mb = MBX_1|MBX_0;
+	mcp->in_mb = MBX_2|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_verify_checksum(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_verify_checksum(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_issue_iocb
+ *	Issue IOCB using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	phys_addr = physical address of buffer.
+ *	size = size of buffer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_issue_iocb(scsi_qla_host_t *ha, void*  buffer, dma_addr_t phys_addr,
+    size_t size)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	ENTER("qla2x00_issue_iocb: started");
+
+	mcp->mb[0] = MBC_IOCB_COMMAND_A64;
+	mcp->mb[1] = 0;
+	mcp->mb[2] = MSW(phys_addr);
+	mcp->mb[3] = LSW(phys_addr);
+	mcp->mb[6] = MSW(MSD(phys_addr));
+	mcp->mb[7] = LSW(MSD(phys_addr));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_2|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG(printk("qla2x00_issue_iocb(%ld): failed rval 0x%x",
+		    ha->host_no,rval);)
+		DEBUG2(printk("qla2x00_issue_iocb(%ld): failed rval 0x%x",
+		    ha->host_no,rval);)
+	} else {
+		/*EMPTY*/
+		LEAVE("qla2x00_issue_iocb: exiting normally");
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_abort_command
+ *	Abort command aborts a specified IOCB.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	sp = SB structure pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_abort_command(scsi_qla_host_t *ha, srb_t *sp)
+{
+	unsigned long   flags = 0;
+	fc_port_t	*fcport;
+	int		rval;
+	uint32_t	handle;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	DEBUG11(printk("qla2x00_abort_command(%ld): entered.\n", ha->host_no);)
+
+	fcport = sp->fclun->fcport;
+
+	if (atomic_read(&ha->loop_state) == LOOP_DOWN ||
+	    atomic_read(&fcport->state) == FCS_DEVICE_LOST) {
+		/* v2.19.8 Ignore abort request if port is down */
+		return 1;
+	}
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (handle = 1; handle < MAX_OUTSTANDING_COMMANDS; handle++) {
+		if (ha->outstanding_cmds[handle] == sp)
+			break;
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (handle == MAX_OUTSTANDING_COMMANDS) {
+		/* command not found */
+		return QLA_FUNCTION_FAILED;
+	}
+
+	mcp->mb[0] = MBC_ABORT_COMMAND;
+	if (HAS_EXTENDED_IDS(ha))
+		mcp->mb[1] = fcport->loop_id;
+	else
+		mcp->mb[1] = fcport->loop_id << 8;
+	mcp->mb[2] = (uint16_t)handle;
+	mcp->mb[3] = (uint16_t)(handle >> 16);
+	mcp->mb[6] = (uint16_t)sp->fclun->lun;
+	mcp->out_mb = MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		DEBUG2_3_11(printk("qla2x00_abort_command(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		sp->flags |= SRB_ABORT_PENDING;
+		DEBUG11(printk("qla2x00_abort_command(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_abort_device
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *      loop_id  = FC loop ID
+ *      lun  = SCSI LUN.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_abort_device(scsi_qla_host_t *ha, uint16_t loop_id, uint16_t lun)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_abort_device(%ld): entered.\n", ha->host_no);)
+
+	mcp->mb[0] = MBC_ABORT_DEVICE;
+	if (HAS_EXTENDED_IDS(ha))
+		mcp->mb[1] = loop_id;
+	else
+		mcp->mb[1] = loop_id << 8;
+	mcp->mb[2] = lun;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Issue marker command. */
+	qla2x00_marker(ha, loop_id, lun, MK_SYNC_ID_LUN);
+
+	if (rval != QLA_SUCCESS) {
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+		if (ha->dpc_wait && !ha->dpc_active) 
+			up(ha->dpc_wait);
+		DEBUG2_3_11(printk("qla2x00_abort_device(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_abort_device(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+#if USE_ABORT_TGT
+/*
+ * qla2x00_abort_target
+ *	Issue abort target mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_abort_target(fc_port_t *fcport)
+{
+	int        rval;
+	mbx_cmd_t  mc;
+	mbx_cmd_t  *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_abort_target(%ld): entered.\n",
+	    fcport->ha->host_no);)
+
+	if (fcport == NULL) {
+		/* no target to abort */
+		return 0;
+	}
+
+	mcp->mb[0] = MBC_ABORT_TARGET;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(fcport->ha)) {
+		mcp->mb[1] = fcport->loop_id;
+		mcp->mb[10] = 0;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = fcport->loop_id << 8;
+	}
+	mcp->mb[2] = fcport->ha->loop_reset_delay;
+
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(fcport->ha, mcp);
+
+	/* Issue marker command. */
+	fcport->ha->marker_needed = 1;
+
+	if (rval != QLA_SUCCESS) {
+		DEBUG2_3_11(printk("qla2x00_abort_target(%ld): failed=%x.\n",
+		    fcport->ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_abort_target(%ld): done.\n",
+		    fcport->ha->host_no);)
+	}
+
+	return rval;
+}
+#endif
+
+/*
+ * qla2x00_target_reset
+ *	Issue target reset mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_target_reset(scsi_qla_host_t *ha, uint16_t b, uint16_t t)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	os_tgt_t *tgt;
+
+	DEBUG11(printk("qla2x00_target_reset(%ld): entered.\n", ha->host_no);)
+
+	tgt = TGT_Q(ha, t);
+	if (tgt->fcport == NULL) {
+		/* no target to abort */
+		return 0;
+	}
+	if (atomic_read(&tgt->fcport->state) != FCS_ONLINE) {
+		/* target not online */
+		return 0;
+	}
+
+	mcp->mb[0] = MBC_TARGET_RESET;
+	if (HAS_EXTENDED_IDS(ha))
+		mcp->mb[1] = tgt->fcport->loop_id;
+	else
+		mcp->mb[1] = tgt->fcport->loop_id << 8;
+	mcp->mb[2] = ha->loop_reset_delay;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_target_reset(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_target_reset(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_adapter_id
+ *	Get adapter ID and topology.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	id = pointer for loop ID.
+ *	al_pa = pointer for AL_PA.
+ *	area = pointer for area.
+ *	domain = pointer for domain.
+ *	top = pointer for topology.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_adapter_id(scsi_qla_host_t *ha, uint16_t *id, uint8_t *al_pa,
+    uint8_t *area, uint8_t *domain, uint16_t *top)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_adapter_id(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_GET_ADAPTER_LOOP_ID;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Return data. */
+	*id = mcp->mb[1];
+	*al_pa = LSB(mcp->mb[2]);
+	*area = MSB(mcp->mb[2]);
+	*domain	= LSB(mcp->mb[3]);
+	*top = mcp->mb[6];
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_adapter_id(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_get_adapter_id(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_retry_cnt
+ *	Get current firmware login retry count and delay.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	retry_cnt = pointer to login retry count.
+ *	tov = pointer to login timeout value.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_retry_cnt(scsi_qla_host_t *ha, uint8_t *retry_cnt, uint8_t *tov,
+    uint16_t *r_a_tov)
+{
+	int rval;
+	uint16_t ratov;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_retry_cnt(%ld): entered.\n",
+			ha->host_no);)
+
+	mcp->mb[0] = MBC_GET_RETRY_COUNT;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_retry_cnt(%ld): failed = %x.\n",
+		    ha->host_no, mcp->mb[0]);)
+	} else {
+		/* Convert returned data and check our values. */
+		*r_a_tov = mcp->mb[3] / 2;
+		ratov = (mcp->mb[3]/2) / 10;  /* mb[3] value is in 100ms */
+		if (mcp->mb[1] * ratov > (*retry_cnt) * (*tov)) {
+			/* Update to the larger values */
+			*retry_cnt = (uint8_t)mcp->mb[1];
+			*tov = ratov;
+		}
+
+		DEBUG11(printk("qla2x00_get_retry_cnt(%ld): done. mb3=%d "
+		    "ratov=%d.\n", ha->host_no, mcp->mb[3], ratov);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_init_firmware
+ *	Initialize adapter firmware.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	dptr = Initialization control block pointer.
+ *	size = size of initialization control block.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_init_firmware(scsi_qla_host_t *ha, uint16_t size)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_init_firmware(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_INITIALIZE_FIRMWARE;
+	mcp->mb[2] = MSW(ha->init_cb_dma);
+	mcp->mb[3] = LSW(ha->init_cb_dma);
+	mcp->mb[4] = 0;
+	mcp->mb[5] = 0;
+	mcp->mb[6] = MSW(MSD(ha->init_cb_dma));
+	mcp->mb[7] = LSW(MSD(ha->init_cb_dma));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;
+	mcp->in_mb = MBX_5|MBX_4|MBX_0;
+	mcp->buf_size = size;
+	mcp->flags = MBX_DMA_OUT;
+	mcp->tov = 30;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_init_firmware(%ld): failed=%x "
+		    "mb0=%x.\n",
+		    ha->host_no, rval, mcp->mb[0]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_init_firmware(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_port_database
+ *	Issue normal/enhanced get port database mailbox command
+ *	and copy device name as necessary.
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	dev = structure pointer.
+ *	opt = enhanced cmd option byte.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_port_database(scsi_qla_host_t *ha, fc_port_t *fcport, uint8_t opt)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	port_database_t *pd;
+	dma_addr_t pd_dma;
+
+	DEBUG11(printk("qla2x00_get_port_database(%ld): entered.\n",
+	    ha->host_no);)
+
+	pd = pci_alloc_consistent(ha->pdev, PORT_DATABASE_SIZE, &pd_dma);
+	if (pd  == NULL) {
+		DEBUG2_3_11(printk("qla2x00_get_port_database(%ld): **** "
+		    "Mem Alloc Failed ****", ha->host_no);)
+		return QLA_MEMORY_ALLOC_FAILED;
+	}
+	memset(pd, 0, PORT_DATABASE_SIZE);
+
+	if (opt != 0)
+		mcp->mb[0] = MBC_ENHANCED_GET_PORT_DATABASE;
+	else
+		mcp->mb[0] = MBC_GET_PORT_DATABASE;
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = fcport->loop_id;
+		mcp->mb[10] = opt;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = fcport->loop_id << 8 | opt;
+	}
+	mcp->mb[2] = MSW(pd_dma);
+	mcp->mb[3] = LSW(pd_dma);
+	mcp->mb[6] = MSW(MSD(pd_dma));
+	mcp->mb[7] = LSW(MSD(pd_dma));
+
+	mcp->in_mb = MBX_0;
+	mcp->buf_size = PORT_DATABASE_SIZE;
+	mcp->flags = MBX_DMA_IN;
+	mcp->tov =  ha->login_timeout * 2;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval == QLA_SUCCESS) {
+		/* Names are little-endian. */
+		memcpy(fcport->node_name, pd->node_name, WWN_SIZE);
+		memcpy(fcport->port_name, pd->port_name, WWN_SIZE);
+
+		/* Get port_id of device. */
+		fcport->d_id.b.al_pa = pd->port_id[2];
+		fcport->d_id.b.area = pd->port_id[3];
+		fcport->d_id.b.domain = pd->port_id[0];
+		fcport->d_id.b.rsvd_1 = 0;
+
+		/* Check for device require authentication. */
+		pd->common_features & BIT_5 ? (fcport->flags |= FCF_AUTH_REQ) :
+		    (fcport->flags &= ~FCF_AUTH_REQ);
+
+		/* If not target must be initiator or unknown type. */
+		if ((pd->prli_svc_param_word_3[0] & BIT_4) == 0) {
+			fcport->port_type = FCT_INITIATOR;
+		} else {
+			fcport->port_type = FCT_TARGET;
+
+			/* Check for logged in. */
+			if (pd->master_state != PD_STATE_PORT_LOGGED_IN &&
+			    pd->slave_state != PD_STATE_PORT_LOGGED_IN)
+				rval = QLA_FUNCTION_FAILED;
+		}
+	}
+
+	pci_free_consistent(ha->pdev, PORT_DATABASE_SIZE, pd, pd_dma);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_port_database(%ld): "
+		    "failed=%x.\n", ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_get_port_database(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_firmware_state
+ *	Get adapter firmware state.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	dptr = pointer for firmware state.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_firmware_state(scsi_qla_host_t *ha, uint16_t *dptr)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_firmware_state(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_GET_FIRMWARE_STATE;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Return firmware state. */
+	*dptr = mcp->mb[1];
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_firmware_state(%ld): "
+		    "failed=%x.\n", ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_get_firmware_state(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_port_name
+ *	Issue get port name mailbox command.
+ *	Returned name is in big endian format.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = loop ID of device.
+ *	name = pointer for name.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_port_name(scsi_qla_host_t *ha, uint16_t loop_id, uint8_t *name,
+    uint8_t opt)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_port_name(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_GET_PORT_NAME;
+	mcp->out_mb = MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = loop_id;
+		mcp->mb[10] = opt;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = loop_id << 8 | opt;
+	}
+
+	mcp->in_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_port_name(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		if (name != NULL) {
+			/* This function returns name in big endian. */
+			name[0] = LSB(mcp->mb[2]);
+			name[1] = MSB(mcp->mb[2]);
+			name[2] = LSB(mcp->mb[3]);
+			name[3] = MSB(mcp->mb[3]);
+			name[4] = LSB(mcp->mb[6]);
+			name[5] = MSB(mcp->mb[6]);
+			name[6] = LSB(mcp->mb[7]);
+			name[7] = MSB(mcp->mb[7]);
+		}
+
+		DEBUG11(printk("qla2x00_get_port_name(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_link_status
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = device loop ID.
+ *	ret_buf = pointer to link status return buffer.
+ *
+ * Returns:
+ *	0 = success.
+ *	BIT_0 = mem alloc error.
+ *	BIT_1 = mailbox error.
+ */
+uint8_t
+qla2x00_get_link_status(scsi_qla_host_t *ha, uint8_t loop_id, void *ret_buf,
+    uint16_t *status)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	link_stat_t *stat_buf;
+	dma_addr_t phys_address = 0;
+
+
+	DEBUG11(printk("qla2x00_get_link_status(%ld): entered.\n",
+	    ha->host_no);)
+
+	stat_buf = pci_alloc_consistent(ha->pdev, sizeof(link_stat_t),
+	    &phys_address);
+	if (stat_buf == NULL) {
+		DEBUG2_3_11(printk("qla2x00_get_link_status(%ld): Failed to "
+		    "allocate memory.\n", ha->host_no));
+		return BIT_0;
+	}
+	memset(stat_buf, 0, sizeof(link_stat_t));
+
+	mcp->mb[0] = MBC_GET_LINK_STATUS;
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = loop_id;
+		mcp->mb[10] = 0;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = loop_id << 8;
+	}
+	mcp->mb[2] = MSW(phys_address);
+	mcp->mb[3] = LSW(phys_address);
+	mcp->mb[6] = MSW(MSD(phys_address));
+	mcp->mb[7] = LSW(MSD(phys_address));
+
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = IOCTL_CMD;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval == QLA_SUCCESS) {
+		if (mcp->mb[0] != MBS_COMMAND_COMPLETE) {
+			DEBUG2_3_11(printk("qla2x00_get_link_status(%ld): cmd "
+			    "failed. mbx0=%x.\n", ha->host_no, mcp->mb[0]);)
+			status[0] = mcp->mb[0];
+			rval = BIT_1;
+		} else {
+			/* copy over data */
+			memcpy(ret_buf, stat_buf,sizeof(link_stat_t));
+			DEBUG(printk("qla2x00_get_link_status(%ld): stat dump: "
+			    "fail_cnt=%d loss_sync=%d loss_sig=%d seq_err=%d "
+			    "inval_xmt_word=%d inval_crc=%d.\n",
+			    ha->host_no,
+			    stat_buf->link_fail_cnt, stat_buf->loss_sync_cnt,
+			    stat_buf->loss_sig_cnt, stat_buf->prim_seq_err_cnt,
+			    stat_buf->inval_xmit_word_cnt,
+			    stat_buf->inval_crc_cnt);)
+			DEBUG11(printk("qla2x00_get_link_status(%ld): stat "
+			    "dump: fail_cnt=%d loss_sync=%d loss_sig=%d "
+			    "seq_err=%d inval_xmt_word=%d inval_crc=%d.\n",
+			    ha->host_no,
+			    stat_buf->link_fail_cnt, stat_buf->loss_sync_cnt,
+			    stat_buf->loss_sig_cnt, stat_buf->prim_seq_err_cnt,
+			    stat_buf->inval_xmit_word_cnt,
+			    stat_buf->inval_crc_cnt);)
+		}
+	} else {
+		/* Failed. */
+		DEBUG2_3_11(printk("qla2x00_get_link_status(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+		rval = BIT_1;
+	}
+
+	pci_free_consistent(ha->pdev, sizeof(link_stat_t),
+	    stat_buf, phys_address);
+
+	return rval;
+}
+
+/*
+ * qla2x00_lip_reset
+ *	Issue LIP reset mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_lip_reset(scsi_qla_host_t *ha)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_lip_reset(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_LIP_RESET;
+	mcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = 0x00ff;
+		mcp->mb[10] = 0;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = 0xff00;
+	}
+	mcp->mb[2] = ha->loop_reset_delay;
+	mcp->mb[3] = 0;
+
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_lip_reset(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_lip_reset(%ld): done.\n", ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_send_sns
+ *	Send SNS command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	sns = pointer for command.
+ *	cmd_size = command size.
+ *	buf_size = response/command size.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_send_sns(scsi_qla_host_t *ha, dma_addr_t sns_phys_address,
+    uint16_t cmd_size, size_t buf_size)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_send_sns(%ld): entered.\n",
+	    ha->host_no);)
+
+	DEBUG11(printk("qla2x00_send_sns: retry cnt=%d ratov=%d total "
+	    "tov=%d.\n", ha->retry_count, ha->login_timeout, mcp->tov);)
+
+	mcp->mb[0] = MBC_SEND_SNS_COMMAND;
+	mcp->mb[1] = cmd_size;
+	mcp->mb[2] = MSW(sns_phys_address);
+	mcp->mb[3] = LSW(sns_phys_address);
+	mcp->mb[6] = MSW(MSD(sns_phys_address));
+	mcp->mb[7] = LSW(MSD(sns_phys_address));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0|MBX_1;
+	mcp->buf_size = buf_size;
+	mcp->flags = MBX_DMA_OUT|MBX_DMA_IN;
+	/*mcp->tov = ha->retry_count * ha->login_timeout * 2;*/
+	mcp->tov =  ha->login_timeout * 2;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG(printk("qla2x00_send_sns(%ld): failed=%x mb[0]=%x "
+		    "mb[1]=%x.\n", ha->host_no, rval, mcp->mb[0], mcp->mb[1]);)
+		DEBUG2_3_11(printk("qla2x00_send_sns(%ld): failed=%x mb[0]=%x "
+		    "mb[1]=%x.\n", ha->host_no, rval, mcp->mb[0], mcp->mb[1]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_send_sns(%ld): done.\n", ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_login_fabric
+ *	Issue login fabric port mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = device loop ID.
+ *	domain = device domain.
+ *	area = device area.
+ *	al_pa = device AL_PA.
+ *	status = pointer for return status.
+ *	opt = command options.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_login_fabric(scsi_qla_host_t *ha, uint16_t loop_id, uint8_t domain,
+    uint8_t area, uint8_t al_pa, uint16_t *mb, uint8_t opt)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_login_fabric(%ld): entered.\n", ha->host_no);)
+
+	mcp->mb[0] = MBC_LOGIN_FABRIC_PORT;
+	mcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = loop_id;
+		mcp->mb[10] = opt;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = (loop_id << 8) | opt;
+	}
+	mcp->mb[2] = domain;
+	mcp->mb[3] = area << 8 | al_pa;
+
+	mcp->in_mb = MBX_7|MBX_6|MBX_2|MBX_1|MBX_0;
+	/*mcp->tov = ha->retry_count * ha->login_timeout * 2;*/
+	mcp->tov = ha->login_timeout * 2;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	/* Return mailbox statuses. */
+	if (mb != NULL) {
+		mb[0] = mcp->mb[0];
+		mb[1] = mcp->mb[1];
+		mb[2] = mcp->mb[2];
+		mb[6] = mcp->mb[6];
+		mb[7] = mcp->mb[7];
+	}
+
+	if (rval != QLA_SUCCESS) {
+		/* RLU tmp code: need to change main mailbox_command function to
+		 * return ok even when the mailbox completion value is not
+		 * SUCCESS. The caller needs to be responsible to interpret
+		 * the return values of this mailbox command if we're not
+		 * to change too much of the existing code.
+		 */
+		if (mcp->mb[0] == 0x4001 || mcp->mb[0] == 0x4002 ||
+		    mcp->mb[0] == 0x4003 || mcp->mb[0] == 0x4005 ||
+		    mcp->mb[0] == 0x4006)
+			rval = QLA_SUCCESS;
+
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_login_fabric(%ld): failed=%x "
+		    "mb[0]=%x mb[1]=%x mb[2]=%x.\n", ha->host_no, rval,
+		    mcp->mb[0], mcp->mb[1], mcp->mb[2]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_login_fabric(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_login_local_device
+ *           Issue login loop port mailbox command.
+ *    
+ * Input:
+ *           ha = adapter block pointer.
+ *           loop_id = device loop ID.
+ *           opt = command options.
+ *          
+ * Returns:
+ *            Return status code.
+ *             
+ * Context:
+ *            Kernel context.
+ *             
+ */
+int
+qla2x00_login_local_device(scsi_qla_host_t *ha, uint16_t loop_id,
+    uint16_t *mb_ret, uint8_t opt)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG3(printk("%s(%ld): entered.\n", __func__, ha->host_no);)
+
+	mcp->mb[0] = MBC_LOGIN_LOOP_PORT;
+	if (HAS_EXTENDED_IDS(ha))
+		mcp->mb[1] = loop_id;
+	else
+		mcp->mb[1] = loop_id << 8;
+	mcp->mb[2] = opt;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+ 	mcp->in_mb = MBX_7|MBX_6|MBX_1|MBX_0;
+	mcp->tov =  ha->login_timeout * 2;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+ 	/* Return mailbox statuses. */
+ 	if (mb_ret != NULL) {
+ 		mb_ret[0] = mcp->mb[0];
+ 		mb_ret[1] = mcp->mb[1];
+ 		mb_ret[6] = mcp->mb[6];
+ 		mb_ret[7] = mcp->mb[7];
+ 	}
+
+	if (rval != QLA_SUCCESS) {
+ 		/* AV tmp code: need to change main mailbox_command function to
+ 		 * return ok even when the mailbox completion value is not
+ 		 * SUCCESS. The caller needs to be responsible to interpret
+ 		 * the return values of this mailbox command if we're not
+ 		 * to change too much of the existing code.
+ 		 */
+ 		if (mcp->mb[0] == 0x4005 || mcp->mb[0] == 0x4006)
+ 			rval = QLA_SUCCESS;
+
+		DEBUG(printk("%s(%ld): failed=%x mb[0]=%x mb[1]=%x "
+		    "mb[6]=%x mb[7]=%x.\n", __func__, ha->host_no, rval,
+		    mcp->mb[0], mcp->mb[1], mcp->mb[6], mcp->mb[7]);)
+		DEBUG2_3(printk("%s(%ld): failed=%x mb[0]=%x mb[1]=%x "
+		    "mb[6]=%x mb[7]=%x.\n", __func__, ha->host_no, rval,
+		    mcp->mb[0], mcp->mb[1], mcp->mb[6], mcp->mb[7]);)
+	} else {
+		/*EMPTY*/
+		DEBUG3(printk("%s(%ld): done.\n", __func__, ha->host_no);)
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_fabric_logout
+ *	Issue logout fabric port mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = device loop ID.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_fabric_logout(scsi_qla_host_t *ha, uint16_t loop_id)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_fabric_logout(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_LOGOUT_FABRIC_PORT;
+	mcp->out_mb = MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = loop_id;
+		mcp->mb[10] = 0;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = loop_id << 8;
+	}
+
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_fabric_logout(%ld): failed=%x "
+		    "mbx1=%x.\n", ha->host_no, rval, mcp->mb[1]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_fabric_logout(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_full_login_lip
+ *	Issue full login LIP mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_full_login_lip(scsi_qla_host_t *ha)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_full_login_lip(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_LIP_FULL_LOGIN;
+	mcp->mb[1] = 0;
+	mcp->mb[2] = 0;
+	mcp->mb[3] = 0;
+	mcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_full_login_lip(%ld): failed=%x.\n",
+		    ha->instance, rval);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_full_login_lip(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_get_id_list
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_id_list(scsi_qla_host_t *ha, void *id_list, dma_addr_t id_list_dma,
+    uint16_t *entries)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_id_list(%ld): entered.\n",
+	    ha->host_no);)
+
+	if (id_list == NULL)
+		return QLA_FUNCTION_FAILED;
+
+	mcp->mb[0] = MBC_GET_ID_LIST;
+	mcp->mb[1] = MSW(id_list_dma);
+	mcp->mb[2] = LSW(id_list_dma);
+	mcp->mb[3] = MSW(MSD(id_list_dma));
+	mcp->mb[6] = LSW(MSD(id_list_dma));
+	mcp->out_mb = MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("qla2x00_get_id_list(%ld): failed=%x.\n",
+		    ha->host_no, rval);)
+	} else {
+		*entries = mcp->mb[1];
+		DEBUG11(printk("qla2x00_get_id_list(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return rval;
+}
+
+#if 0 /* not yet needed */
+int
+qla2x00_dump_ram(scsi_qla_host_t *ha, uint32_t risc_address,
+    dma_addr_t ispdump_dma, uint32_t size)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	mcp->mb[0] = MBC_DUMP_RAM;
+	mcp->mb[1] = risc_address & 0xffff;
+	mcp->mb[2] = MSW(ispdump_dma);
+	mcp->mb[3] = LSW(ispdump_dma);
+	mcp->mb[4] = 0;
+	mcp->mb[6] = MSW(MSD(ispdump_dma));
+	mcp->mb[7] = LSW(MSD(ispdump_dma));
+	mcp->out_mb = MBX_7|MBX_6|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	return rval;
+}
+#endif
+
+/*
+ * qla2x00_lun_reset
+ *	Issue lun reset mailbox command.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	loop_id = device loop ID.
+ *      lun = lun to be reset.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_lun_reset(scsi_qla_host_t *ha, uint16_t loop_id, uint16_t lun)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	ENTER("qla2x00_lun_reset");
+
+	mcp->mb[0] = MBC_LUN_RESET;
+	if (HAS_EXTENDED_IDS(ha))
+		mcp->mb[1] = loop_id;
+	else
+		mcp->mb[1] = loop_id << 8;
+	mcp->mb[2] = lun;
+	mcp->out_mb = MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		printk(KERN_WARNING "qla2x00_lun_reset(%d): failed = %d",
+		    (int)ha->instance, rval);
+	} else {
+		/*EMPTY*/
+		LEAVE("qla2x00_lun_reset: exiting normally");
+	}
+
+	return rval;
+}
+
+/*
+ * qla2x00_send_rnid_mbx
+ *	Issue RNID ELS using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	loop_id = loop ID of the target device.
+ *	data_fmt = currently supports only 0xDF.
+ *	buffer = buffer pointer.
+ *	buf_size = size of buffer.
+ *	mb_reg = pointer to return mailbox registers.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_send_rnid_mbx(scsi_qla_host_t *ha, uint16_t loop_id, uint8_t data_fmt,
+    dma_addr_t buf_phys_addr, size_t buf_size, uint16_t *mb_reg)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	DEBUG11(printk("qla2x00_send_rnid_mbx(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_SEND_RNID_ELS;
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	if (HAS_EXTENDED_IDS(ha)) {
+		mcp->mb[1] = loop_id;
+		mcp->mb[10] = data_fmt;
+		mcp->out_mb |= MBX_10;
+	} else {
+		mcp->mb[1] = (loop_id << 8) | data_fmt;
+	}
+	mcp->mb[2] = MSW(buf_phys_addr);
+	mcp->mb[3] = LSW(buf_phys_addr);
+	mcp->mb[6] = MSW(MSD(buf_phys_addr));
+	mcp->mb[7] = LSW(MSD(buf_phys_addr));
+
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->buf_size = buf_size;
+	mcp->flags = MBX_DMA_IN;
+	mcp->tov = 30;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		memcpy(mb_reg, mcp->mb, 2 * 2); /* 2 status regs */
+
+		DEBUG2_3_11(printk("qla2x00_send_rnid_mbx(%ld): failed=%x "
+		    "mb[1]=%x.\n",
+		    ha->host_no, mcp->mb[0], mcp->mb[1]);)
+	} else {
+		/*EMPTY*/
+	 	DEBUG11(printk("qla2x00_send_rnid_mbx(%ld): done.\n",
+		     ha->host_no);)
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_set_rnid_params_mbx
+ *	Set RNID parameters using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	buf_size = size of buffer.
+ *	mb_reg = pointer to return mailbox registers.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_set_rnid_params_mbx(scsi_qla_host_t *ha, dma_addr_t buf_phys_addr,
+    size_t buf_size, uint16_t *mb_reg)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	DEBUG11(printk("qla2x00_set_rnid_params_mbx(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_SET_RNID_PARAMS;
+	mcp->mb[1] = 0;
+	mcp->mb[2] = MSW(buf_phys_addr);
+	mcp->mb[3] = LSW(buf_phys_addr);
+	mcp->mb[6] = MSW(MSD(buf_phys_addr));
+	mcp->mb[7] = LSW(MSD(buf_phys_addr));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->buf_size = buf_size;
+	mcp->flags = MBX_DMA_OUT;
+	mcp->tov = 30;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		memcpy(mb_reg, mcp->mb, 2 * 2); /* 2 status regs */
+
+		DEBUG2_3_11(printk("qla2x00_set_rnid_params_mbx(%ld): "
+		    "failed=%x mb[1]=%x.\n", ha->host_no, mcp->mb[0],
+		    mcp->mb[1]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_set_rnid_params_mbx(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_get_rnid_params_mbx
+ *	Get RNID parameters using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	buffer = buffer pointer.
+ *	buf_size = size of buffer.
+ *	mb_reg = pointer to return mailbox registers.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_rnid_params_mbx(scsi_qla_host_t *ha, dma_addr_t buf_phys_addr,
+    size_t buf_size, uint16_t *mb_reg)
+{
+	int		rval;
+	mbx_cmd_t	mc;
+	mbx_cmd_t	*mcp = &mc;
+
+	DEBUG11(printk("qla2x00_get_rnid_params_mbx(%ld): entered.\n",
+	    ha->host_no);)
+
+	mcp->mb[0] = MBC_GET_RNID_PARAMS;
+	mcp->mb[1] = 0;
+	mcp->mb[2] = MSW(buf_phys_addr);
+	mcp->mb[3] = LSW(buf_phys_addr);
+	mcp->mb[6] = MSW(MSD(buf_phys_addr));
+	mcp->mb[7] = LSW(MSD(buf_phys_addr));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->buf_size = buf_size;
+	mcp->flags = MBX_DMA_IN;
+	mcp->tov = 30;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		memcpy(mb_reg, mcp->mb, 2 * 2); /* 2 status regs */
+
+		DEBUG2_3_11(printk("qla2x00_get_rnid_params_mbx(%ld): "
+		    "failed=%x mb[1]=%x.\n", ha->host_no, mcp->mb[0],
+		    mcp->mb[1]);)
+	} else {
+		/*EMPTY*/
+		DEBUG11(printk("qla2x00_get_rnid_params_mbx(%ld): done.\n",
+		    ha->host_no);)
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_get_resource_cnts
+ *	Get current firmware resource counts.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_resource_cnts(scsi_qla_host_t *ha, uint16_t *cur_xchg_cnt,
+    uint16_t *orig_xchg_cnt, uint16_t *cur_iocb_cnt, uint16_t *orig_iocb_cnt)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+
+	DEBUG11(printk("%s(%ld): entered.\n", __func__, ha->host_no));
+
+	mcp->mb[0] = MBC_GET_RESOURCE_COUNTS;
+	mcp->out_mb = MBX_0;
+	mcp->in_mb = MBX_10|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;
+	mcp->tov = 30;
+	mcp->flags = 0;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval != QLA_SUCCESS) {
+		/*EMPTY*/
+		DEBUG2_3_11(printk("%s(%ld): failed = %x.\n", __func__,
+		    ha->host_no, mcp->mb[0]);)
+	} else {
+		DEBUG11(printk("%s(%ld): done. mb1=%x mb2=%x mb3=%x mb6=%x "
+		    "mb7=%x mb10=%x.\n", __func__, ha->host_no,
+		    mcp->mb[1], mcp->mb[2], mcp->mb[3], mcp->mb[6], mcp->mb[7], 
+		    mcp->mb[10]));
+
+		if (cur_xchg_cnt)
+			*cur_xchg_cnt = mcp->mb[3];
+		if (orig_xchg_cnt)
+			*orig_xchg_cnt = mcp->mb[6];
+		if (cur_iocb_cnt)
+			*cur_iocb_cnt = mcp->mb[7];
+		if (orig_iocb_cnt)
+			*orig_iocb_cnt = mcp->mb[10];
+	}
+
+	return (rval);
+}
+
+#if defined(QL_DEBUG_LEVEL_3)
+/*
+ * qla2x00_get_fcal_position_map
+ *	Get FCAL (LILP) position map using mailbox command
+ *
+ * Input:
+ *	ha = adapter state pointer.
+ *	pos_map = buffer pointer (can be NULL).
+ *
+ * Returns:
+ *	qla2x00 local function return status code.
+ *
+ * Context:
+ *	Kernel context.
+ */
+int
+qla2x00_get_fcal_position_map(scsi_qla_host_t *ha, char *pos_map)
+{
+	int rval;
+	mbx_cmd_t mc;
+	mbx_cmd_t *mcp = &mc;
+	char *pmap;
+	dma_addr_t pmap_dma;
+
+	pmap = pci_alloc_consistent(ha->pdev, FCAL_MAP_SIZE, &pmap_dma);
+	if (pmap  == NULL) {
+		DEBUG2_3_11(printk("%s(%ld): **** Mem Alloc Failed ****",
+		    __func__, ha->host_no));
+		return QLA_MEMORY_ALLOC_FAILED;
+	}
+	memset(pmap, 0, FCAL_MAP_SIZE);
+
+	mcp->mb[0] = MBC_GET_FC_AL_POSITION_MAP;
+	mcp->mb[2] = MSW(pmap_dma);
+	mcp->mb[3] = LSW(pmap_dma);
+	mcp->mb[6] = MSW(MSD(pmap_dma));
+	mcp->mb[7] = LSW(MSD(pmap_dma));
+	mcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;
+	mcp->in_mb = MBX_1|MBX_0;
+	mcp->buf_size = FCAL_MAP_SIZE;
+	mcp->flags = MBX_DMA_IN;
+	mcp->tov =  ha->login_timeout * 2;
+	rval = qla2x00_mailbox_command(ha, mcp);
+
+	if (rval == QLA_SUCCESS) {
+		DEBUG11(printk("%s(%ld): (mb0=%x/mb1=%x) FC/AL Position Map "
+		    "size (%x)\n", __func__, ha->host_no, mcp->mb[0],
+		    mcp->mb[1], (unsigned)pmap[0]));
+		DEBUG11(qla2x00_dump_buffer(pmap, pmap[0] + 1));
+
+		if (pos_map)
+			memcpy(pos_map, pmap, FCAL_MAP_SIZE);
+	}
+	pci_free_consistent(ha->pdev, FCAL_MAP_SIZE, pmap, pmap_dma);
+
+	if (rval != QLA_SUCCESS) {
+		DEBUG2_3_11(printk("%s(%ld): failed=%x.\n", __func__,
+		    ha->host_no, rval));
+	} else {
+		DEBUG11(printk("%s(%ld): done.\n", __func__, ha->host_no));
+	}
+
+	return rval;
+}
+#endif
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_os.c linux-2.5/drivers/scsi/qla2xxx/qla_os.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_os.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_os.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,4602 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+/*
+ * Driver version
+ */
+char qla2x00_version_str[40];
+
+/*
+ * SRB allocation cache
+ */
+char srb_cachep_name[16];
+kmem_cache_t *srb_cachep;
+
+/*
+ * Stats for all adpaters.
+ */
+struct _qla2x00stats qla2x00_stats;
+
+/*
+ * Ioctl related information.
+ */
+int num_hosts;
+int apiHBAInstance;
+
+/*
+ * Module parameter information and variables
+ */
+int ql2xmaxqdepth;
+module_param(ql2xmaxqdepth, int, 0);
+MODULE_PARM_DESC(ql2xmaxqdepth,
+		"Maximum queue depth to report for target devices.");
+
+int ql2xlogintimeout = 20;
+module_param(ql2xlogintimeout, int, 0);
+MODULE_PARM_DESC(ql2xlogintimeout,
+		"Login timeout value in seconds.");
+
+int qlport_down_retry;
+module_param(qlport_down_retry, int, 0);
+MODULE_PARM_DESC(qlport_down_retry,
+		"Maximum number of command retries to a port that returns"
+		"a PORT-DOWN status.");
+
+int ql2xretrycount = 20;
+module_param(ql2xretrycount, int, 0);
+MODULE_PARM_DESC(ql2xretrycount,
+		"Maximum number of mid-layer retries allowed for a command.  "
+		"Default value is 20, ");
+
+int displayConfig;
+module_param(displayConfig, int, 0);
+MODULE_PARM_DESC(displayConfig,
+		"If 1 then display the configuration used in /etc/modules.conf.");
+
+int ql2xplogiabsentdevice;
+module_param(ql2xplogiabsentdevice, int, 0);
+MODULE_PARM_DESC(ql2xplogiabsentdevice,
+		"Option to enable PLOGI to devices that are not present after "
+		"a Fabric scan.  This is needed for several broken switches."
+		"Default is 0 - no PLOGI. 1 - perfom PLOGI.");
+
+int ql2xintrdelaytimer = 10;
+module_param(ql2xintrdelaytimer, int, 0);
+MODULE_PARM_DESC(ql2xintrdelaytimer,
+		"ZIO: Waiting time for Firmware before it generates an "
+		"interrupt to the host to notify completion of request.");
+
+int ConfigRequired;
+module_param(ConfigRequired, int, 0);
+MODULE_PARM_DESC(ConfigRequired,
+		"If 1, then only configured devices passed in through the"
+		"ql2xopts parameter will be presented to the OS");
+
+int Bind = BIND_BY_PORT_NAME;
+module_param(Bind, int, 0);
+MODULE_PARM_DESC(Bind,
+		"Target persistent binding method: "
+		"0 by Portname (default); 1 by PortID; 2 by Nodename. ");
+
+int ql2xsuspendcount = SUSPEND_COUNT;
+module_param(ql2xsuspendcount, int, 0);
+MODULE_PARM_DESC(ql2xsuspendcount,
+		"Number of 6-second suspend iterations to perform while a "
+		"target returns a <NOT READY> status.  Default is 10 "
+		"iterations.");
+
+int ql2xdoinitscan = 1;
+module_param(ql2xdoinitscan, int, 0);
+MODULE_PARM_DESC(ql2xdoinitscan,
+		"Signal mid-layer to perform scan after driver load: 0 -- no "
+		"signal sent to mid-layer.");
+
+/*
+ * Proc structures and functions
+ */
+struct info_str {
+	char	*buffer;
+	int	length;
+	off_t	offset;
+	int	pos;
+};
+
+static void copy_mem_info(struct info_str *, char *, int);
+static int copy_info(struct info_str *, char *, ...);
+
+
+/*
+ * List of host adapters
+ */
+LIST_HEAD(qla_hostlist);
+rwlock_t qla_hostlist_lock = RW_LOCK_UNLOCKED;
+
+static void qla2x00_free_device(scsi_qla_host_t *);
+
+static void qla2x00_config_dma_addressing(scsi_qla_host_t *ha);
+
+/*
+ * SCSI host template entry points 
+ */
+static int qla2xxx_slave_configure(struct scsi_device * device);
+extern int qla2x00_ioctl(struct scsi_device *, int , void *);
+static int qla2xxx_eh_abort(struct scsi_cmnd *);
+static int qla2xxx_eh_device_reset(struct scsi_cmnd *);
+static int qla2xxx_eh_bus_reset(struct scsi_cmnd *);
+static int qla2xxx_eh_host_reset(struct scsi_cmnd *);
+static uint8_t qla2x00_loop_reset(scsi_qla_host_t *ha);
+static int qla2x00_device_reset(scsi_qla_host_t *, fc_port_t *);
+
+static int qla2x00_proc_info(struct Scsi_Host *, char *, char **,
+    off_t, int, int);
+
+static struct scsi_host_template qla2x00_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "qla2xxx",
+	.proc_name		= "qla2xxx",
+	.proc_info		= qla2x00_proc_info,
+	.queuecommand		= qla2x00_queuecommand,
+
+	.eh_abort_handler	= qla2xxx_eh_abort,
+	.eh_device_reset_handler = qla2xxx_eh_device_reset,
+	.eh_bus_reset_handler	= qla2xxx_eh_bus_reset,
+	.eh_host_reset_handler	= qla2xxx_eh_host_reset,
+
+	.slave_configure	= qla2xxx_slave_configure,
+
+	.this_id		= -1,
+	.can_queue		= REQUEST_ENTRY_CNT+128,
+	.cmd_per_lun		= 3,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.sg_tablesize		= SG_ALL,
+
+	/*
+	 * The RISC allows for each command to transfer (2^32-1) bytes of data,
+	 * which equates to 0x800000 sectors.
+	 */
+	.max_sectors		= 0xFFFF,
+};
+
+static void qla2x00_display_fc_names(scsi_qla_host_t *);
+
+void qla2x00_blink_led(scsi_qla_host_t *);
+
+/* TODO Convert to inlines
+ *
+ * Timer routines
+ */
+#define	WATCH_INTERVAL		1       /* number of seconds */
+
+static void qla2x00_timer(scsi_qla_host_t *);
+
+static __inline__ void qla2x00_start_timer(scsi_qla_host_t *,
+    void *, unsigned long);
+static __inline__ void qla2x00_restart_timer(scsi_qla_host_t *, unsigned long);
+static __inline__ void qla2x00_stop_timer(scsi_qla_host_t *);
+
+static inline void
+qla2x00_start_timer(scsi_qla_host_t *ha, void *func, unsigned long interval)
+{
+	init_timer(&ha->timer);
+	ha->timer.expires = jiffies + interval * HZ;
+	ha->timer.data = (unsigned long)ha;
+	ha->timer.function = (void (*)(unsigned long))func;
+	add_timer(&ha->timer);
+	ha->timer_active = 1;
+}
+
+static inline void
+qla2x00_restart_timer(scsi_qla_host_t *ha, unsigned long interval)
+{
+	mod_timer(&ha->timer, jiffies + interval * HZ);
+}
+
+static __inline__ void
+qla2x00_stop_timer(scsi_qla_host_t *ha)
+{
+	del_timer_sync(&ha->timer);
+	ha->timer_active = 0;
+}
+
+
+static void qla2x00_cmd_timeout(srb_t *sp);
+static __inline__ void qla2x00_add_timer_to_cmd(srb_t *sp, int timeout);
+static __inline__ void qla2x00_delete_timer_from_cmd(srb_t *sp);
+
+/**************************************************************************
+*   qla2x00_add_timer_to_cmd
+*
+* Description:
+*       Creates a timer for the specified command. The timeout is usually
+*       the command time from kernel minus 2 secs.
+*
+* Input:
+*     sp - pointer to validate
+*
+* Returns:
+*     None.
+**************************************************************************/
+static inline void
+qla2x00_add_timer_to_cmd(srb_t *sp, int timeout)
+{
+	init_timer(&sp->timer);
+	sp->timer.expires = jiffies + timeout * HZ;
+	sp->timer.data = (unsigned long) sp;
+	sp->timer.function = (void (*) (unsigned long))qla2x00_cmd_timeout;
+	add_timer(&sp->timer);
+}
+
+/**************************************************************************
+*   qla2x00_delete_timer_from_cmd
+*
+* Description:
+*       Delete the timer for the specified command.
+*
+* Input:
+*     sp - pointer to validate
+*
+* Returns:
+*     None.
+**************************************************************************/
+static inline void 
+qla2x00_delete_timer_from_cmd(srb_t *sp)
+{
+	if (sp->timer.function != NULL) {
+		del_timer(&sp->timer);
+		sp->timer.function =  NULL;
+		sp->timer.data = (unsigned long) NULL;
+	}
+}
+
+static __inline__ void qla2x00_callback(scsi_qla_host_t *, struct scsi_cmnd *);
+static __inline__ void sp_put(struct scsi_qla_host * ha, srb_t *sp);
+static __inline__ void sp_get(struct scsi_qla_host * ha, srb_t *sp);
+static __inline__ void
+qla2x00_delete_from_done_queue(scsi_qla_host_t *, srb_t *); 
+
+/**************************************************************************
+* sp_put
+*
+* Description:
+*   Decrement reference count and call the callback if we're the last
+*   owner of the specified sp. Will get the host_lock before calling
+*   the callback.
+*
+* Input:
+*   ha - pointer to the scsi_qla_host_t where the callback is to occur.
+*   sp - pointer to srb_t structure to use.
+*
+* Returns:
+*
+**************************************************************************/
+static inline void
+sp_put(struct scsi_qla_host * ha, srb_t *sp)
+{
+        if (atomic_read(&sp->ref_count) == 0) {
+		qla_printk(KERN_INFO, ha,
+			"%s(): **** SP->ref_count not zero\n",
+			__func__);
+                DEBUG2(BUG();)
+
+                return;
+	}
+
+        if (!atomic_dec_and_test(&sp->ref_count)) {
+                return;
+        }
+
+        qla2x00_callback(ha, sp->cmd);
+}
+
+/**************************************************************************
+* sp_get
+*
+* Description:
+*   Increment reference count of the specified sp.
+*
+* Input:
+*   sp - pointer to srb_t structure to use.
+*
+* Returns:
+*
+**************************************************************************/
+static inline void
+sp_get(struct scsi_qla_host * ha, srb_t *sp)
+{
+        atomic_inc(&sp->ref_count);
+
+        if (atomic_read(&sp->ref_count) > 2) {
+		qla_printk(KERN_INFO, ha,
+			"%s(): **** SP->ref_count greater than two\n",
+			__func__);
+                DEBUG2(BUG();)
+
+		return;
+	}
+}
+
+/*
+* qla2x00_callback
+*      Returns the completed SCSI command to LINUX.
+*
+* Input:
+*	ha -- Host adapter structure
+*	cmd -- SCSI mid-level command structure.
+* Returns:
+*      None
+* Note:From failover point of view we always get the sp
+*      from vis_ha pool in queuecommand.So when we put it 
+*      back to the pool it has to be the vis_ha.	 
+*      So rely on struct scsi_cmnd to get the vis_ha and not on sp. 		 	
+*/
+static inline void
+qla2x00_callback(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
+{
+	srb_t *sp = (srb_t *) CMD_SP(cmd);
+	scsi_qla_host_t *vis_ha;
+	os_lun_t *lq;
+	int got_sense;
+	unsigned long	cpu_flags = 0;
+
+	ENTER(__func__);
+
+	cmd->host_scribble = (unsigned char *) NULL;
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+
+	if (sp == NULL) {
+		qla_printk(KERN_INFO, ha,
+			"%s(): **** CMD derives a NULL SP\n",
+			__func__);
+                DEBUG2(BUG();)
+		return;
+	}
+
+	/*
+	 * If command status is not DID_BUS_BUSY then go ahead and freed sp.
+	 */
+	/*
+	 * Cancel command timeout
+	 */
+	qla2x00_delete_timer_from_cmd(sp);
+
+	/*
+	 * Put SP back in the free queue
+	 */
+	sp->cmd   = NULL;
+	CMD_SP(cmd) = NULL;
+	lq = sp->lun_queue;
+	got_sense = (sp->flags & SRB_GOT_SENSE)? 1: 0;
+	add_to_free_queue(vis_ha, sp);
+
+	if (host_byte(cmd->result) == DID_OK) {
+		/* device ok */
+		ha->total_bytes += cmd->bufflen;
+		if (!got_sense) {
+			/* If lun was suspended then clear retry count */
+			spin_lock_irqsave(&lq->q_lock, cpu_flags);
+			if (!test_bit(LUN_EXEC_DELAYED, &lq->q_flag))
+				lq->q_state = LUN_STATE_READY;
+			spin_unlock_irqrestore(&lq->q_lock, cpu_flags);
+		}
+	} else if (host_byte(cmd->result) == DID_ERROR) {
+		/* device error */
+		ha->total_dev_errs++;
+	}
+
+	/* Call the mid-level driver interrupt handler */
+	(*(cmd)->scsi_done)(cmd);
+
+	LEAVE(__func__);
+}
+
+static inline void 
+qla2x00_delete_from_done_queue(scsi_qla_host_t *dest_ha, srb_t *sp) 
+{
+	/* remove command from done list */
+	list_del_init(&sp->list);
+	dest_ha->done_q_cnt--;
+	sp->state = SRB_NO_QUEUE_STATE;
+
+	if (sp->flags & SRB_DMA_VALID) {
+		sp->flags &= ~SRB_DMA_VALID;
+
+		/* Release memory used for this I/O */
+		if (sp->cmd->use_sg) {
+			pci_unmap_sg(dest_ha->pdev, sp->cmd->request_buffer,
+			    sp->cmd->use_sg, sp->cmd->sc_data_direction);
+		} else if (sp->cmd->request_bufflen) {
+			pci_unmap_page(dest_ha->pdev, sp->dma_handle,
+			    sp->cmd->request_bufflen,
+			    sp->cmd->sc_data_direction);
+		}
+	}
+}
+
+static int qla2x00_do_dpc(void *data);
+
+static void qla2x00_rst_aen(scsi_qla_host_t *);
+
+static uint8_t qla2x00_mem_alloc(scsi_qla_host_t *);
+static void qla2x00_mem_free(scsi_qla_host_t *ha);
+int qla2x00_allocate_sp_pool( scsi_qla_host_t *ha);
+void qla2x00_free_sp_pool(scsi_qla_host_t *ha);
+
+static ssize_t qla2x00_sysfs_read_fw_dump(struct kobject *, char *, loff_t,
+    size_t);
+static ssize_t qla2x00_sysfs_write_fw_dump(struct kobject *, char *, loff_t,
+    size_t);
+static struct bin_attribute sysfs_fw_dump_attr = {
+	.attr = {
+		.name = "fw_dump",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.size = 0,
+	.read = qla2x00_sysfs_read_fw_dump,
+	.write = qla2x00_sysfs_write_fw_dump,
+};
+static ssize_t qla2x00_sysfs_read_nvram(struct kobject *, char *, loff_t,
+    size_t);
+static ssize_t qla2x00_sysfs_write_nvram(struct kobject *, char *, loff_t,
+    size_t);
+static struct bin_attribute sysfs_nvram_attr = {
+	.attr = {
+		.name = "nvram",
+		.mode = S_IRUSR | S_IWUSR,
+	},
+	.size = sizeof(nvram_t),
+	.read = qla2x00_sysfs_read_nvram,
+	.write = qla2x00_sysfs_write_nvram,
+};
+
+
+int
+qla2x00_set_info(char *buffer, int length, struct Scsi_Host *shost)
+{
+	return (-ENOSYS);  /* Currently this is a no-op */
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+/* SysFS attributes. */
+static ssize_t qla2x00_sysfs_read_fw_dump(struct kobject *kobj, char *buf,
+    loff_t off, size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+
+	if (ha->fw_dump_reading == 0)
+		return 0;
+	if (off > ha->fw_dump_buffer_len)
+		return 0;
+	if (off + count > ha->fw_dump_buffer_len)
+		count = ha->fw_dump_buffer_len - off;
+
+	memcpy(buf, &ha->fw_dump_buffer[off], count);
+
+	return (count);
+}
+
+static ssize_t qla2x00_sysfs_write_fw_dump(struct kobject *kobj, char *buf,
+    loff_t off, size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+	int reading;
+
+	if (off != 0)
+		return (0);
+
+	reading = simple_strtol(buf, NULL, 10);
+	switch (reading) {
+	case 0:
+		if (ha->fw_dump_reading == 1) {
+			qla_printk(KERN_INFO, ha,
+			    "Firmware dump cleared on (%ld).\n",
+			    ha->host_no);
+
+			vfree(ha->fw_dump_buffer);
+			free_pages((unsigned long)ha->fw_dump,
+			    ha->fw_dump_order);
+
+			ha->fw_dump_reading = 0;
+			ha->fw_dump_buffer = NULL;
+			ha->fw_dump = NULL;
+		}
+		break;
+	case 1:
+		if (ha->fw_dump != NULL && !ha->fw_dump_reading) {
+			ha->fw_dump_reading = 1;
+
+			ha->fw_dump_buffer = (char *)vmalloc(FW_DUMP_SIZE);
+			if (ha->fw_dump_buffer == NULL) {
+				qla_printk(KERN_WARNING, ha,
+				    "Unable to allocate memory for firmware "
+				    "dump buffer (%d).\n", FW_DUMP_SIZE);
+
+				ha->fw_dump_reading = 0;
+				return (count);
+			}
+			qla_printk(KERN_INFO, ha,
+			    "Firmware dump ready for read on (%ld).\n",
+			    ha->host_no);
+			memset(ha->fw_dump_buffer, 0, FW_DUMP_SIZE);
+			if (IS_QLA2100(ha) || IS_QLA2200(ha))
+ 				qla2100_ascii_fw_dump(ha);
+ 			else
+ 				qla2300_ascii_fw_dump(ha);
+			ha->fw_dump_buffer_len = strlen(ha->fw_dump_buffer);
+		}
+		break;
+	}
+	return (count);
+}
+
+static ssize_t qla2x00_sysfs_read_nvram(struct kobject *kobj, char *buf,
+    loff_t off, size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+	uint16_t	*witer;
+	unsigned long	flags;
+	uint16_t	cnt;
+
+	if (!capable(CAP_SYS_ADMIN) || off != 0 || count != sizeof(nvram_t))
+		return 0;
+
+	/* Read NVRAM. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	qla2x00_lock_nvram_access(ha);
+ 	witer = (uint16_t *)buf;
+ 	for (cnt = 0; cnt < count / 2; cnt++) {
+		*witer = cpu_to_le16(qla2x00_get_nvram_word(ha,
+		    cnt+ha->nvram_base));
+		witer++;
+ 	}
+	qla2x00_unlock_nvram_access(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (count);
+}
+
+static ssize_t qla2x00_sysfs_write_nvram(struct kobject *kobj, char *buf,
+    loff_t off, size_t count)
+{
+	struct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,
+	    struct device, kobj)));
+	uint8_t		*iter;
+	uint16_t	*witer;
+	unsigned long	flags;
+	uint16_t	cnt;
+	uint8_t		chksum;
+
+	if (!capable(CAP_SYS_ADMIN) || off != 0 || count != sizeof(nvram_t))
+		return 0;
+
+	/* Checksum NVRAM. */
+	iter = (uint8_t *)buf;
+	chksum = 0;
+	for (cnt = 0; cnt < count - 1; cnt++)
+		chksum += *iter++;
+	chksum = ~chksum + 1;
+	*iter = chksum;
+
+	/* Write NVRAM. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	qla2x00_lock_nvram_access(ha);
+ 	witer = (uint16_t *)buf;
+	for (cnt = 0; cnt < count / 2; cnt++) {
+		qla2x00_write_nvram_word(ha, cnt+ha->nvram_base,
+		    cpu_to_le16(*witer));
+		witer++;
+	}
+	qla2x00_unlock_nvram_access(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return (count);
+}
+
+/* -------------------------------------------------------------------------- */
+char *
+qla2x00_get_pci_info_str(struct scsi_qla_host *ha, char *str)
+{
+	static char *pci_bus_modes[] = {
+		"33", "66", "100", "133",
+	};
+	uint16_t pci_bus;
+
+	strcpy(str, "PCI");
+	pci_bus = (ha->pci_attr & (BIT_9 | BIT_10)) >> 9;
+	if (pci_bus) {
+		strcat(str, "-X (");
+		strcat(str, pci_bus_modes[pci_bus]);
+	} else {
+		pci_bus = (ha->pci_attr & BIT_8) >> 8;
+		strcat(str, " (");
+		strcat(str, pci_bus_modes[pci_bus]);
+	}
+	strcat(str, " MHz)");
+
+	return (str);
+}
+
+char *
+qla2x00_get_fw_version_str(struct scsi_qla_host *ha, char *str)
+{
+	char un_str[10];
+	
+	sprintf(str, "%d.%02d.%02d ", ha->fw_major_version,
+	    ha->fw_minor_version,
+	    ha->fw_subminor_version);
+
+	switch (ha->fw_attributes & 0xFF) {
+	case 0x7:
+		strcat(str, "EF");
+		break;
+	case 0x17:
+		strcat(str, "TP");
+		break;
+	case 0x37:
+		strcat(str, "IP");
+		break;
+	case 0x77:
+		strcat(str, "VI");
+		break;
+	default:
+		sprintf(un_str, "(%x)", ha->fw_attributes);
+		strcat(str, un_str);
+		break;
+	}
+	if (ha->fw_attributes & 0x100)
+		strcat(str, "X");
+
+	return (str);
+}
+
+/**************************************************************************
+* qla2x00_queuecommand
+*
+* Description:
+*     Queue a command to the controller.
+*
+* Input:
+*     cmd - pointer to Scsi cmd structure
+*     fn - pointer to Scsi done function
+*
+* Returns:
+*   0 - Always
+*
+* Note:
+* The mid-level driver tries to ensures that queuecommand never gets invoked
+* concurrently with itself or the interrupt handler (although the
+* interrupt handler may call this routine as part of request-completion
+* handling).
+**************************************************************************/
+int
+qla2x00_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
+{
+	fc_port_t	*fcport;
+	os_lun_t	*lq;
+	os_tgt_t	*tq;
+	scsi_qla_host_t	*ha, *ha2;
+	srb_t		*sp;
+	struct Scsi_Host *host;
+	unsigned int	b, t, l;
+	unsigned long	handle;
+	int		was_empty;
+
+
+	host = cmd->device->host;
+	ha = (scsi_qla_host_t *) host->hostdata;
+
+	cmd->scsi_done = fn;
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	/*
+	 * Allocate a command packet from the "sp" pool.  If we cant get back
+	 * one then let scsi layer come back later.
+	 */
+	if ((sp = qla2x00_get_new_sp(ha)) == NULL) {
+		qla_printk(KERN_WARNING, ha,
+		    "Couldn't allocate memory for sp - retried.\n");
+
+		spin_lock_irq(ha->host->host_lock);
+
+		return (1);
+	}
+
+	sp->cmd = cmd;
+	CMD_SP(cmd) = (void *)sp;
+
+	sp->flags = 0;
+	if (CMD_RESID_LEN(cmd) & SRB_IOCTL) {
+		/* Need to set sp->flags */
+		sp->flags |= SRB_IOCTL;
+		CMD_RESID_LEN(cmd) = 0; /* Clear it since no more use. */
+	}
+
+	sp->fo_retry_cnt = 0;
+
+	/* Generate LU queue on bus, target, LUN */
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+
+	/*
+	 * Start Command Timer. Typically it will be 2 seconds less than what
+	 * is requested by the Host such that we can return the IO before
+	 * aborts are called.
+	 */
+	if ((cmd->timeout_per_command / HZ) > QLA_CMD_TIMER_DELTA)
+		qla2x00_add_timer_to_cmd(sp,
+		    (cmd->timeout_per_command / HZ) - QLA_CMD_TIMER_DELTA);
+	else
+		qla2x00_add_timer_to_cmd(sp, cmd->timeout_per_command / HZ);
+
+	if (l >= ha->max_luns) {
+		cmd->result = DID_NO_CONNECT << 16;
+
+		spin_lock_irq(ha->host->host_lock);
+
+		sp_put(ha, sp);
+
+		return (0);
+	}
+
+	if ((tq = (os_tgt_t *) TGT_Q(ha, t)) != NULL &&
+	    (lq = (os_lun_t *) LUN_Q(ha, t, l)) != NULL) {
+		fcport = lq->fclun->fcport;
+		ha2 = fcport->ha;
+	} else {
+		lq = NULL;
+		fcport = NULL;
+		ha2 = ha;
+	}
+
+	/* Set an invalid handle until we issue the command to ISP */
+	/* then we will set the real handle value.                 */
+	handle = INVALID_HANDLE;
+	cmd->host_scribble = (unsigned char *)handle;
+
+	/* Bookkeeping information */
+	sp->r_start = jiffies;       /* time the request was recieved */
+	sp->u_start = 0;
+
+	/* Setup device queue pointers. */
+	sp->tgt_queue = tq;
+	sp->lun_queue = lq;
+
+	/*
+	 * NOTE : q is NULL
+	 *
+	 * 1. When device is added from persistent binding but has not been
+	 *    discovered yet.The state of loopid == PORT_AVAIL.
+	 * 2. When device is never found on the bus.(loopid == UNUSED)
+	 *
+	 * IF Device Queue is not created, or device is not in a valid state
+	 * and link down error reporting is enabled, reject IO.
+	 */
+	if (fcport == NULL) {
+		DEBUG3(printk("scsi(%ld:%2d:%2d): port unavailable\n",
+		    ha->host_no,t,l));
+
+		cmd->result = DID_NO_CONNECT << 16;
+
+		spin_lock_irq(ha->host->host_lock);
+
+		sp_put(ha, sp);
+
+		return (0);
+	}
+
+	/* Only modify the allowed count if the target is a *non* tape device */
+	if ((fcport->flags & FCF_TAPE_PRESENT) == 0) {
+		if (cmd->allowed < ql2xretrycount) {
+			cmd->allowed = ql2xretrycount;
+		}
+	}
+
+	DEBUG5(printk("scsi(%ld:%2d:%2d): (queuecmd) queue sp = %p, "
+	    "flags=0x%x fo retry=%d, pid=%ld\n",
+	    ha->host_no, t, l, sp, sp->flags, sp->fo_retry_cnt,
+	    cmd->serial_number));
+	DEBUG5(qla2x00_print_scsi_cmd(cmd));
+
+	sp->fclun = lq->fclun;
+	sp->ha = ha2;
+
+	if (cmd->sc_data_direction == DMA_BIDIRECTIONAL &&
+	    cmd->request_bufflen != 0) {
+
+		DEBUG2(printk(KERN_WARNING
+		    "scsi(%ld): Incorrect data direction - transfer "
+		    "length=%d, direction=%d, pid=%ld, opcode=%x\n",
+		    ha->host_no, cmd->request_bufflen, cmd->sc_data_direction,
+		    cmd->serial_number, cmd->cmnd[0]));
+	}
+
+	/* Final pre-check :
+	 *
+	 *	Either PORT_DOWN_TIMER OR LINK_DOWN_TIMER Expired.
+	 */
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||
+	    atomic_read(&ha->loop_state) == LOOP_DEAD) {
+		/*
+		 * Add the command to the done-queue for later failover
+		 * processing
+		 */
+		cmd->result = DID_NO_CONNECT << 16;
+		add_to_done_queue(ha, sp);
+		if (!list_empty(&ha->done_queue))
+			qla2x00_done(ha);
+
+		spin_lock_irq(ha->host->host_lock);
+		return (0);
+	}
+	was_empty = add_to_pending_queue(ha, sp);
+
+	if ((IS_QLA2100(ha) || IS_QLA2200(ha)) && ha->flags.online) {
+		unsigned long flags;
+		device_reg_t *reg;
+		reg = ha->iobase;
+		
+		if (RD_REG_WORD(ISP_RSP_Q_IN(ha, reg)) != ha->rsp_ring_index) {
+			spin_lock_irqsave(&ha->hardware_lock, flags);	
+			qla2x00_process_response_queue(ha);
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+
+	/* We submit to the hardware if:
+	 *
+	 *	1) we're on the cpu the irq's arrive on or
+	 *	2) there are very few io's outstanding.
+	 *
+	 * In all other cases we'll let an irq pick up our IO and submit it
+	 * to the controller to improve affinity.
+	 */
+	if (smp_processor_id() == ha->last_irq_cpu || was_empty)
+		qla2x00_next(ha);
+
+	spin_lock_irq(ha->host->host_lock);
+
+	return (0);
+}
+
+/*
+ * qla2x00_eh_wait_on_command
+ *    Waits for the command to be returned by the Firmware for some
+ *    max time.
+ *
+ * Input:
+ *    ha = actual ha whose done queue will contain the command
+ *	      returned by firmware.
+ *    cmd = Scsi Command to wait on.
+ *    flag = Abort/Reset(Bus or Device Reset)
+ *
+ * Return:
+ *    Not Found : 0
+ *    Found : 1
+ */
+static int
+qla2x00_eh_wait_on_command(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
+{
+#define ABORT_WAIT_TIME	10 /* seconds */
+
+	int		found = 0;
+	int		done = 0;
+	srb_t		*rp;
+	struct list_head *list, *temp;
+	u_long		cpu_flags = 0;
+	u_long		max_wait_time = ABORT_WAIT_TIME;
+
+	ENTER(__func__);
+
+	do {
+		/* Check on done queue */
+		if (!found) {
+			spin_lock_irqsave(&ha->list_lock, cpu_flags);
+			list_for_each_safe(list, temp, &ha->done_queue) {
+				rp = list_entry(list, srb_t, list);
+
+				/*
+				* Found command.  Just exit and wait for the
+				* cmd sent to OS.
+			 	*/
+				if (cmd == rp->cmd) {
+					found++;
+					DEBUG3(printk("%s: found in done "
+							"queue.\n", __func__);)
+					break;
+				}
+			}
+			spin_unlock_irqrestore(&ha->list_lock, cpu_flags);
+		}
+
+		/* Checking to see if its returned to OS */
+		rp = (srb_t *) CMD_SP(cmd);
+		if (rp == NULL ) {
+			done++;
+			break;
+		}
+
+		spin_unlock_irq(ha->host->host_lock);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(2*HZ);
+
+		spin_lock_irq(ha->host->host_lock);
+
+	} while ((max_wait_time--));
+
+	if (done) {
+		DEBUG2(printk(KERN_INFO "%s: found cmd=%p.\n", __func__, cmd));
+	} else if (found) {
+		/* Immediately return command to the mid-layer */
+		qla2x00_delete_from_done_queue(ha, rp);
+		sp_put(ha, rp);
+		done++;
+	}
+
+	LEAVE(__func__);
+
+	return (done);
+}
+
+/*
+ * qla2x00_wait_for_hba_online
+ *    Wait till the HBA is online after going through 
+ *    <= MAX_RETRIES_OF_ISP_ABORT  or
+ *    finally HBA is disabled ie marked offline
+ *
+ * Input:
+ *     ha - pointer to host adapter structure
+ * 
+ * Note:    
+ *    Does context switching-Release SPIN_LOCK
+ *    (if any) before calling this routine.
+ *
+ * Return:
+ *    Success (Adapter is online) : 0
+ *    Failed  (Adapter is offline/disabled) : 1
+ */
+static inline int 
+qla2x00_wait_for_hba_online(scsi_qla_host_t *ha)
+{
+	int 	 return_status ;
+
+	while ((test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags)) ||
+	    test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags) ||
+	    test_bit(ISP_ABORT_RETRY, &ha->dpc_flags)) {
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(3 * HZ);
+	}
+	if (ha->flags.online == TRUE) 
+		return_status = QLA_SUCCESS; 
+	else
+		/* Adapter is disabled/offline */
+		return_status = QLA_FUNCTION_FAILED;
+
+	DEBUG2(printk("%s return_status=%d\n",__func__,return_status));
+
+	return (return_status);
+}
+
+/*
+ * qla2x00_wait_for_loop_ready
+ *    Wait for MAX_LOOP_TIMEOUT(5 min) value for loop
+ *    to be in LOOP_READY state.	 
+ * Input:
+ *     ha - pointer to host adapter structure
+ * 
+ * Note:    
+ *    Does context switching-Release SPIN_LOCK
+ *    (if any) before calling this routine.
+ *    
+ *
+ * Return:
+ *    Success (LOOP_READY) : 0
+ *    Failed  (LOOP_NOT_READY) : 1
+ */
+static inline int 
+qla2x00_wait_for_loop_ready(scsi_qla_host_t *ha)
+{
+	int 	 return_status = QLA_SUCCESS;
+	unsigned long loop_timeout ;
+
+	/* wait for 5 min at the max for loop to be ready */
+	loop_timeout = jiffies + (MAX_LOOP_TIMEOUT * HZ); 
+
+	while ((!atomic_read(&ha->loop_down_timer) &&
+	    atomic_read(&ha->loop_state) == LOOP_DOWN) ||
+	    test_bit(CFG_ACTIVE, &ha->cfg_flags) ||
+	    atomic_read(&ha->loop_state) != LOOP_READY) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(3 * HZ);
+		if (time_after_eq(jiffies, loop_timeout)) {
+			return_status = QLA_FUNCTION_FAILED;
+			break;
+		}
+	}
+	return (return_status);	
+}
+
+/**************************************************************************
+* qla2xxx_eh_abort
+*
+* Description:
+*    The abort function will abort the specified command.
+*
+* Input:
+*    cmd = Linux SCSI command packet to be aborted.
+*
+* Returns:
+*    Either SUCCESS or FAILED.
+*
+* Note:
+**************************************************************************/
+int
+qla2xxx_eh_abort(struct scsi_cmnd *cmd)
+{
+	int		i;
+	int		return_status = FAILED;
+	os_lun_t	*q;
+	scsi_qla_host_t *ha;
+	scsi_qla_host_t *vis_ha;
+	srb_t		*sp;
+	srb_t		*rp;
+	struct list_head *list, *temp;
+	struct Scsi_Host *host;
+	uint8_t		found = 0;
+	unsigned int	b, t, l;
+	unsigned long	flags;
+
+
+	ENTER(__func__);
+
+	/* Get the SCSI request ptr */
+	sp = (srb_t *) CMD_SP(cmd);
+
+	/*
+	 * If sp is NULL, command is already returned.
+	 * sp is NULLED just before we call back scsi_done
+	 *
+	 */
+	if ((sp == NULL)) {
+		/* no action - we don't have command */
+		qla_printk(KERN_INFO, to_qla_host(cmd->device->host),
+		    "qla2xxx_eh_abort: cmd already done sp=%p\n", sp);
+		DEBUG(printk("qla2xxx_eh_abort: cmd already done sp=%p\n", sp);)
+		return(SUCCESS);
+	}
+	if (sp) {
+		DEBUG(printk("qla2xxx_eh_abort: refcount %i \n",
+		    atomic_read(&sp->ref_count));)
+	}
+
+	vis_ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+
+	host = ha->host;
+
+	/* Generate LU queue on bus, target, LUN */
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	q = GET_LU_Q(vis_ha, t, l);
+
+	qla_printk(KERN_INFO, ha, 
+	    "%s scsi(%ld:%d:%d:%d): cmd_timeout_in_sec=0x%x.\n", __func__,
+	    ha->host_no, (int)b, (int)t, (int)l,
+	    cmd->timeout_per_command / HZ);
+
+	/*
+	 * if no LUN queue then something is very wrong!!!
+	 */
+	if (q == NULL) {
+		qla_printk(KERN_WARNING, ha,
+			"qla2x00: (%x:%x:%x) No LUN queue.\n", b, t, l);
+
+		/* no action - we don't have command */
+		return(FAILED);
+	}
+
+	DEBUG2(printk("scsi(%ld): ABORTing cmd=%p sp=%p jiffies = 0x%lx, "
+	    "timeout=%x, dpc_flags=%lx, vis_ha->dpc_flags=%lx\n",
+	    ha->host_no, cmd, sp, jiffies, cmd->timeout_per_command / HZ,
+	    ha->dpc_flags, vis_ha->dpc_flags));
+	DEBUG2(qla2x00_print_scsi_cmd(cmd));
+	DEBUG2(qla2x00_print_q_info(q);)
+
+	spin_unlock_irq(ha->host->host_lock);
+	/* Blocking call-Does context switching if abort isp is active etc */  
+	if (qla2x00_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk("%s failed:board disabled\n", __func__);)
+		spin_lock_irq(ha->host->host_lock);
+		return (FAILED);
+	}
+	spin_lock_irq(ha->host->host_lock);
+
+	/* Search done queue */
+	spin_lock_irqsave(&ha->list_lock,flags);
+	list_for_each_safe(list, temp, &ha->done_queue) {
+		rp = list_entry(list, srb_t, list);
+
+		if (cmd != rp->cmd)
+			continue;
+
+		/*
+		 * Found command.Remove it from done list.
+		 * And proceed to post completion to scsi mid layer.
+		 */
+		return_status = SUCCESS;
+		found++;
+		qla2x00_delete_from_done_queue(ha, sp);
+
+		break;
+	} /* list_for_each_safe() */
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	/*
+	 * Return immediately if the aborted command was already in the done
+	 * queue
+	 */
+	if (found) {
+		qla_printk(KERN_INFO, ha,
+		    "qla2xxx_eh_abort: Returning completed command=%p sp=%p\n",
+		    cmd, sp);
+		sp_put(ha, sp);
+		return (return_status);
+	}
+	
+
+	/*
+	 * See if this command is in the retry queue
+	 */
+	DEBUG3(printk("qla2xxx_eh_abort: searching sp %p in retry "
+		    "queue.\n", sp);)
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	list_for_each_safe(list, temp, &ha->retry_queue) {
+		rp = list_entry(list, srb_t, list);
+
+		if (cmd != rp->cmd)
+			continue;
+
+
+		DEBUG2(printk("qla2xxx_eh_abort: found "
+		    "in retry queue. SP=%p\n", sp);)
+
+		__del_from_retry_queue(ha, rp);
+		cmd->result = DID_ABORT << 16;
+		__add_to_done_queue(ha, rp);
+
+		return_status = SUCCESS;
+		found++;
+
+		break;
+
+	} 
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	/*
+	 * Our SP pointer points at the command we want to remove from the
+	 * pending queue providing we haven't already sent it to the adapter.
+	 */
+	if (!found) {
+		DEBUG3(printk("qla2xxx_eh_abort: searching sp %p "
+		    "in pending queue.\n", sp);)
+
+		spin_lock_irqsave(&vis_ha->list_lock, flags);
+		list_for_each_safe(list, temp, &vis_ha->pending_queue) {
+			rp = list_entry(list, srb_t, list);
+
+			if (rp->cmd != cmd)
+				continue;
+
+			/* Remove srb from LUN queue. */
+			rp->flags |=  SRB_ABORTED;
+
+			DEBUG2(printk("qla2xxx_eh_abort: Cmd in pending queue."
+			    " serial_number %ld.\n",
+			    sp->cmd->serial_number);)
+
+			__del_from_pending_queue(vis_ha, rp);
+			cmd->result = DID_ABORT << 16;
+
+			__add_to_done_queue(vis_ha, rp);
+
+			return_status = SUCCESS;
+
+			found++;
+			break;
+		} /* list_for_each_safe() */
+		spin_unlock_irqrestore(&vis_ha->list_lock, flags);
+	} /*End of if !found */
+
+	if (!found) {  /* find the command in our active list */
+		DEBUG3(printk("qla2xxx_eh_abort: searching sp %p "
+		    "in outstanding queue.\n", sp);)
+
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		for (i = 1; i < MAX_OUTSTANDING_COMMANDS; i++) {
+			sp = ha->outstanding_cmds[i];
+
+			if (sp == NULL)
+				continue;
+
+			if (sp->cmd != cmd)
+				continue;
+
+			DEBUG2(printk("qla2xxx_eh_abort(%ld): aborting sp %p "
+			    "from RISC. pid=%ld sp->state=%x\n",
+			    ha->host_no, sp, sp->cmd->serial_number,
+			    sp->state);)
+			DEBUG(qla2x00_print_scsi_cmd(cmd);)
+			DEBUG(qla2x00_print_q_info(q);)
+
+			/* Get a reference to the sp and drop the lock.*/
+			sp_get(ha, sp);
+
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			spin_unlock(ha->host->host_lock);
+
+			if (qla2x00_abort_command(ha, sp)) {
+				DEBUG2(printk("qla2xxx_eh_abort: abort_command "
+				    "mbx failed.\n");)
+				return_status = FAILED;
+			} else {
+				DEBUG3(printk("qla2xxx_eh_abort: abort_command "
+				    " mbx success.\n");)
+				return_status = SUCCESS;
+			}
+
+			sp_put(ha,sp);
+
+			spin_lock_irq(ha->host->host_lock);
+			spin_lock_irqsave(&ha->hardware_lock, flags);
+
+			/*
+			 * Regardless of mailbox command status, go check on
+			 * done queue just in case the sp is already done.
+			 */
+			break;
+
+		}/*End of for loop */
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	} /*End of if !found */
+
+	  /*Waiting for our command in done_queue to be returned to OS.*/
+	if (qla2x00_eh_wait_on_command(ha, cmd) != 0) {
+		DEBUG2(printk("qla2xxx_eh_abort: cmd returned back to OS.\n");)
+		return_status = SUCCESS;
+	}
+
+	if (return_status == FAILED) {
+		qla_printk(KERN_INFO, ha, 
+			"qla2xxx_eh_abort Exiting: status=Failed\n");
+		return FAILED;
+	}
+
+	DEBUG2(printk("qla2xxx_eh_abort: Exiting. return_status=0x%x.\n",
+	    return_status));
+
+	LEAVE("qla2xxx_eh_abort");
+
+	return(return_status);
+}
+
+/**************************************************************************
+* qla2x00_eh_wait_for_pending_target_commands
+*
+* Description:
+*    Waits for all the commands to come back from the specified target.
+*
+* Input:
+*    ha - pointer to scsi_qla_host structure.
+*    t  - target 	
+* Returns:
+*    Either SUCCESS or FAILED.
+*
+* Note:
+**************************************************************************/
+int
+qla2x00_eh_wait_for_pending_target_commands(scsi_qla_host_t *ha, unsigned int t)
+{
+	int	cnt;
+	int	status;
+	unsigned long	flags;
+	srb_t		*sp;
+	struct scsi_cmnd *cmd;
+
+	status = 0;
+
+	/*
+	 * Waiting for all commands for the designated target in the active
+	 * array
+	 */
+	for (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		sp = ha->outstanding_cmds[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			if (cmd->device->id == t) {
+				if (!qla2x00_eh_wait_on_command(ha, cmd)) {
+					status = 1;
+					break;
+				}
+			}
+		}
+		else {
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+	return (status);
+}
+
+
+/**************************************************************************
+* qla2xxx_eh_device_reset
+*
+* Description:
+*    The device reset function will reset the target and abort any
+*    executing commands.
+*
+*    NOTE: The use of SP is undefined within this context.  Do *NOT*
+*          attempt to use this value, even if you determine it is 
+*          non-null.
+*
+* Input:
+*    cmd = Linux SCSI command packet of the command that cause the
+*          bus device reset.
+*
+* Returns:
+*    SUCCESS/FAILURE (defined as macro in scsi.h).
+*
+**************************************************************************/
+int
+qla2xxx_eh_device_reset(struct scsi_cmnd *cmd)
+{
+	int		return_status;
+	unsigned int	b, t, l;
+	scsi_qla_host_t	*ha;
+	os_tgt_t	*tq;
+	os_lun_t	*lq;
+	fc_port_t	*fcport_to_reset;
+
+	return_status = FAILED;
+	if (cmd == NULL) {
+		printk(KERN_INFO
+		    "%s(): **** SCSI mid-layer passing in NULL cmd\n",
+		    __func__);
+
+		return (return_status);
+	}
+
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+
+	tq = TGT_Q(ha, t);
+	if (tq == NULL) {
+		qla_printk(KERN_INFO, ha,
+		    "%s(): **** CMD derives a NULL TGT_Q\n", __func__);
+
+		return (return_status);
+	}
+	lq = (os_lun_t *)LUN_Q(ha, t, l);
+	if (lq == NULL) {
+		printk(KERN_INFO
+		    "%s(): **** CMD derives a NULL LUN_Q\n", __func__);
+
+		return (return_status);
+	}
+	fcport_to_reset = lq->fclun->fcport;
+
+#if STOP_ON_RESET
+	qla2x00_panic(__func__, ha->host);
+#endif
+
+	qla_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): DEVICE RESET ISSUED.\n", ha->host_no, b, t, l);
+
+	DEBUG2(printk(KERN_INFO
+	    "scsi(%ld): DEVICE_RESET cmd=%p jiffies = 0x%lx, timeout=%x, "
+	    "dpc_flags=%lx, status=%x allowed=%d cmd.state=%x\n",
+	    ha->host_no, cmd, jiffies, cmd->timeout_per_command / HZ,
+	    ha->dpc_flags, cmd->result, cmd->allowed, cmd->state));
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	/* Blocking call-Does context switching if abort isp is active etc */  
+	if (qla2x00_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk(KERN_INFO
+		    "%s failed:board disabled\n",__func__));
+
+		spin_lock_irq(ha->host->host_lock);
+		goto eh_dev_reset_done;
+	}
+
+	/* Blocking call-Does context switching if loop is Not Ready */
+	if (qla2x00_wait_for_loop_ready(ha) == QLA_SUCCESS) {
+		if (qla2x00_device_reset(ha, fcport_to_reset) == 0) {
+			return_status = SUCCESS;
+		}
+
+#if defined(LOGOUT_AFTER_DEVICE_RESET)
+		if (return_status == SUCCESS) {
+			if (fcport_to_reset->flags & FC_FABRIC_DEVICE) {
+				qla2x00_fabric_logout(ha,
+				    fcport_to_reset->loop_id);
+				qla2x00_mark_device_lost(ha, fcport_to_reset);
+			}
+		}
+#endif
+	} else {
+		DEBUG2(printk(KERN_INFO
+		    "%s failed: loop not ready\n",__func__);)
+	}
+
+	spin_lock_irq(ha->host->host_lock);
+
+	if (return_status == FAILED) {
+		DEBUG3(printk("%s(%ld): device reset failed\n",
+		    __func__,ha->host_no));
+		qla_printk(KERN_INFO, ha, "%s: device reset failed\n",
+		    __func__);
+
+		goto eh_dev_reset_done;
+	}
+
+	/*
+	 * If we are coming down the EH path, wait for all commands to
+	 * complete for the device.
+	 */
+	if (cmd->device->host->eh_active) {
+		if (qla2x00_eh_wait_for_pending_target_commands(ha, t))
+			return_status = FAILED;
+
+		if (return_status == FAILED) {
+			DEBUG3(printk("%s(%ld): failed while waiting for "
+			    "commands\n", __func__, ha->host_no));
+			qla_printk(KERN_INFO, ha,
+			    "%s: failed while waiting for commands\n",
+			    __func__); 
+
+			goto eh_dev_reset_done;
+		}
+	}
+
+	qla_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): DEVICE RESET SUCCEEDED.\n",
+	    ha->host_no, b, t, l);
+
+eh_dev_reset_done:
+
+	return (return_status);
+}
+
+/**************************************************************************
+* qla2x00_eh_wait_for_pending_commands
+*
+* Description:
+*    Waits for all the commands to come back from the specified host.
+*
+* Input:
+*    ha - pointer to scsi_qla_host structure.
+*
+* Returns:
+*    1 : SUCCESS
+*    0 : FAILED
+*
+* Note:
+**************************************************************************/
+int
+qla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *ha)
+{
+	int	cnt;
+	int	status;
+	unsigned long	flags;
+	srb_t		*sp;
+	struct scsi_cmnd *cmd;
+
+	status = 1;
+
+	/*
+	 * Waiting for all commands for the designated target in the active
+	 * array
+	 */
+	for (cnt = 1; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		sp = ha->outstanding_cmds[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+			status = qla2x00_eh_wait_on_command(ha, cmd);
+			if (status == 0)
+				break;
+		}
+		else {
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		}
+	}
+	return (status);
+}
+
+
+/**************************************************************************
+* qla2xxx_eh_bus_reset
+*
+* Description:
+*    The bus reset function will reset the bus and abort any executing
+*    commands.
+*
+* Input:
+*    cmd = Linux SCSI command packet of the command that cause the
+*          bus reset.
+*
+* Returns:
+*    SUCCESS/FAILURE (defined as macro in scsi.h).
+*
+**************************************************************************/
+int
+qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd)
+{
+	scsi_qla_host_t *ha;
+	srb_t *sp;
+	int rval = FAILED;
+
+
+	ENTER("qla2xxx_eh_bus_reset");
+
+	ha = (scsi_qla_host_t *) cmd->device->host->hostdata;
+	sp = (srb_t *) CMD_SP(cmd);
+
+#if  STOP_ON_RESET
+	printk("Resetting the Bus= 0x%x\n", (int)cmd);
+	qla2x00_print_scsi_cmd(cmd);
+	qla2x00_panic("qla2100_reset", ha->host);
+#endif
+
+	qla_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): LOOP RESET ISSUED.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	/* Blocking call-Does context switching if abort isp is active etc*/  
+	if (qla2x00_wait_for_hba_online(ha) != QLA_SUCCESS) {
+		DEBUG2(printk("%s failed:board disabled\n",__func__));
+		spin_lock_irq(ha->host->host_lock);
+		return FAILED;
+	}
+
+	/* Blocking call-Does context switching if loop is Not Ready */ 
+	if (qla2x00_wait_for_loop_ready(ha) == QLA_SUCCESS) {
+		if (qla2x00_loop_reset(ha)) 
+			rval = SUCCESS;
+	}
+
+	spin_lock_irq(ha->host->host_lock);
+	if (rval == FAILED)
+		goto out;
+
+	/*
+	 * Blocking Call. It goes to sleep waiting for cmd to get to done q
+	 *
+	 * XXX(hch): really?  We're under host_lock here..
+	 */
+	/* Waiting for our command in done_queue to be returned to OS.*/
+	if (!qla2x00_eh_wait_for_pending_commands(ha))
+		rval = FAILED;
+
+ out:
+	qla_printk(KERN_INFO, ha, "%s: reset %s\n", __func__,
+			(rval == FAILED) ? "failed" : "succeded");
+
+	LEAVE("qla2xxx_eh_bus_reset");
+	return rval;
+}
+
+/**************************************************************************
+* qla2xxx_eh_host_reset
+*
+* Description:
+*    The reset function will reset the Adapter.
+*
+* Input:
+*      cmd = Linux SCSI command packet of the command that cause the
+*            adapter reset.
+*
+* Returns:
+*      Either SUCCESS or FAILED.
+*
+* Note:
+**************************************************************************/
+int
+qla2xxx_eh_host_reset(struct scsi_cmnd *cmd)
+{
+	scsi_qla_host_t *ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+	int		rval = SUCCESS;
+
+	ENTER("qla2xxx_eh_host_reset");
+
+	/* Display which one we're actually resetting for debug. */
+	DEBUG(printk("qla2xxx_eh_host_reset:Resetting scsi(%ld).\n",
+	    ha->host_no));
+
+#if  STOP_ON_RESET
+	qla_printk(KERN_INFO, ha, "Host Reset...  Command=\n");
+	qla2x00_print_scsi_cmd(cmd);
+	qla2x00_panic("qla2xxx_eh_host_reset", ha->host);
+#endif
+
+	/*
+	 *  Now issue reset.
+	 */
+	qla_printk(KERN_INFO, ha,
+	    "scsi(%ld:%d:%d:%d): ADAPTER RESET issued.\n", ha->host_no,
+	    cmd->device->channel, cmd->device->id, cmd->device->lun);
+
+	spin_unlock_irq(ha->host->host_lock);
+
+	/* Blocking call-Does context switching if abort isp is active etc*/  
+	if (qla2x00_wait_for_hba_online(ha) != QLA_SUCCESS)
+		goto board_disabled;
+
+	/*
+	 * Fixme-may be dpc thread is active and processing
+	 * loop_resync,so wait a while for it to 
+	 * be completed and then issue big hammer.Otherwise
+	 * it may cause I/O failure as big hammer marks the
+	 * devices as lost kicking of the port_down_timer
+	 * while dpc is stuck for the mailbox to complete.
+	 */
+	/* Blocking call-Does context switching if loop is Not Ready */
+	qla2x00_wait_for_loop_ready(ha);
+	set_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+	if (qla2x00_abort_isp(ha)) {
+		clear_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+		/* failed. schedule dpc to try */
+		set_bit(ISP_ABORT_NEEDED, &ha->dpc_flags);
+
+		if (qla2x00_wait_for_hba_online(ha) != QLA_SUCCESS)
+			goto board_disabled;
+	} 
+
+	clear_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+
+	spin_lock_irq(ha->host->host_lock);
+	if (rval == FAILED)
+		goto out;
+
+	/* Waiting for our command in done_queue to be returned to OS.*/
+	if (qla2x00_eh_wait_for_pending_commands(ha))
+		rval = FAILED;
+
+ out:
+	qla_printk(KERN_INFO, ha, "%s: reset %s\n", __func__,
+			(rval == FAILED) ? "failed" : "succeded");
+
+	LEAVE("qla2xxx_eh_host_reset");
+	return rval;
+
+ board_disabled:
+	spin_lock_irq(ha->host->host_lock);
+
+	qla_printk(KERN_INFO, ha, "%s: failed:board disabled\n", __func__);
+	return FAILED;
+}
+
+
+/*
+* qla2x00_loop_reset
+*      Issue loop reset.
+*
+* Input:
+*      ha = adapter block pointer.
+*
+* Returns:
+*      0 = success
+*/
+static uint8_t
+qla2x00_loop_reset(scsi_qla_host_t *ha)
+{
+	uint8_t  status = QLA_SUCCESS;
+	uint16_t t;
+	os_tgt_t        *tq;
+
+	ENTER(__func__);
+
+	if (ha->flags.enable_lip_reset) {
+		status = qla2x00_lip_reset(ha);
+	}
+
+	if (status == QLA_SUCCESS && ha->flags.enable_target_reset) {
+		for (t = 0; t < MAX_FIBRE_DEVICES; t++) {
+			if ((tq = TGT_Q(ha, t)) == NULL)
+				continue;
+
+			if (tq->fcport == NULL)
+				continue;
+
+			status = qla2x00_target_reset(ha, 0, t);
+			if (status != QLA_SUCCESS) {
+				break;
+			}
+		}
+	}
+
+	if (status == QLA_SUCCESS &&
+		((!ha->flags.enable_target_reset && 
+		  !ha->flags.enable_lip_reset) ||
+		ha->flags.enable_lip_full_login)) {
+
+		status = qla2x00_full_login_lip(ha);
+	}
+
+	/* Issue marker command only when we are going to start the I/O */
+	ha->marker_needed = 1;
+
+	if (status) {
+		/* Empty */
+		DEBUG2_3(printk("%s(%ld): **** FAILED ****\n",
+				__func__,
+				ha->host_no);)
+	} else {
+		/* Empty */
+		DEBUG3(printk("%s(%ld): exiting normally.\n",
+				__func__,
+				ha->host_no);)
+	}
+
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/*
+ * qla2x00_device_reset
+ *	Issue bus device reset message to the target.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	t = SCSI ID.
+ *	TARGET_QUEUE_LOCK must be released.
+ *	ADAPTER_STATE_LOCK must be released.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static int
+qla2x00_device_reset(scsi_qla_host_t *ha, fc_port_t *reset_fcport)
+{
+	/* Abort Target command will clear Reservation */
+	return qla2x00_abort_target(reset_fcport);
+}
+
+/**************************************************************************
+* qla2x00_slave_configure
+*
+* Description:
+**************************************************************************/
+int
+qla2xxx_slave_configure(struct scsi_device *sdev)
+{
+	scsi_qla_host_t *ha = to_qla_host(sdev->host);
+	int queue_depth;
+
+	if (IS_QLA2100(ha) || IS_QLA2200(ha))
+		queue_depth = 16;
+	else
+		queue_depth = 32;
+
+	if (sdev->tagged_supported) {
+#if defined(MODULE)
+		if (!(ql2xmaxqdepth == 0 || ql2xmaxqdepth > 256))
+			queue_depth = ql2xmaxqdepth;
+#endif 
+		ql2xmaxqdepth = queue_depth;
+
+		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, queue_depth);
+
+		qla_printk(KERN_INFO, ha,
+		    "scsi(%d:%d:%d:%d): Enabled tagged queuing, queue "
+		    "depth %d.\n",
+		    sdev->host->host_no, sdev->channel, sdev->id, sdev->lun,
+		    sdev->queue_depth);
+	} else {
+		 scsi_adjust_queue_depth(sdev, 0 /* TCQ off */,
+		     sdev->host->hostt->cmd_per_lun /* 3 */);
+	}
+
+	return (0);
+}
+
+/**
+ * qla2x00_config_dma_addressing() - Configure OS DMA addressing method.
+ * @ha: HA context
+ *
+ * At exit, the @ha's flags.enable_64bit_addressing set to indicated
+ * supported addressing method.
+ */
+static void
+qla2x00_config_dma_addressing(scsi_qla_host_t *ha)
+{
+	/* Assume 32bit DMA address */
+	ha->flags.enable_64bit_addressing = 0;
+	ha->calc_request_entries = qla2x00_calc_iocbs_32;
+	ha->build_scsi_iocbs = qla2x00_build_scsi_iocbs_32;
+
+	/*
+	 * Given the two variants pci_set_dma_mask(), allow the compiler to
+	 * assist in setting the proper dma mask.
+	 */
+	if (sizeof(dma_addr_t) > 4) {
+		/* Update our PCI device dma_mask for full 64 bits */
+		if (pci_set_dma_mask(ha->pdev, 0xffffffffffffffffULL) == 0) {
+			ha->flags.enable_64bit_addressing = 1;
+			ha->calc_request_entries = qla2x00_calc_iocbs_64;
+			ha->build_scsi_iocbs = qla2x00_build_scsi_iocbs_64;
+
+			if (pci_set_consistent_dma_mask(ha->pdev,
+			    0xffffffffffffffffULL)) {
+				qla_printk(KERN_DEBUG, ha, 
+				    "Failed to set 64 bit PCI consistent mask; "
+				    "using 32 bit.\n");
+				pci_set_consistent_dma_mask(ha->pdev,
+				    0xffffffffULL);
+			}
+		} else {
+			qla_printk(KERN_DEBUG, ha,
+			    "Failed to set 64 bit PCI DMA mask, falling back "
+			    "to 32 bit MASK.\n");
+			pci_set_dma_mask(ha->pdev, 0xffffffff);
+		}
+	} else {
+		pci_set_dma_mask(ha->pdev, 0xffffffff);
+	}
+}
+
+static int
+qla2x00_iospace_config(scsi_qla_host_t *ha)
+{
+	unsigned long	pio, pio_len, pio_flags;
+	unsigned long	mmio, mmio_len, mmio_flags;
+
+	pio = pci_resource_start(ha->pdev, 0);
+	pio_len = pci_resource_len(ha->pdev, 0);
+	pio_flags = pci_resource_flags(ha->pdev, 0);
+
+	mmio = pci_resource_start(ha->pdev, 1);
+	mmio_len = pci_resource_len(ha->pdev, 1);
+	mmio_flags = pci_resource_flags(ha->pdev, 1);
+
+#if MEMORY_MAPPED_IO
+	if (!(mmio_flags & IORESOURCE_MEM)) {
+		qla_printk(KERN_ERR, ha,
+		    "region #0 not an MMIO resource (%s), aborting\n",
+		    ha->pdev->slot_name);
+		goto iospace_error_exit;
+	}
+	if (mmio_len < MIN_IOBASE_LEN) {
+		qla_printk(KERN_ERR, ha,
+		    "Invalid PCI mem region size (%s), aborting\n",
+		    ha->pdev->slot_name);
+		goto iospace_error_exit;
+	}
+#else
+	if (!(pio_flags & IORESOURCE_IO)) {
+		qla_printk(KERN_ERR, ha,
+		    "region #0 not a PIO resource (%s), aborting\n",
+		    ha->pdev->slot_name);
+		goto iospace_error_exit;
+	}
+	if (pio_len < MIN_IOBASE_LEN) {
+		qla_printk(KERN_ERR, ha,
+		    "Invalid PCI I/O region size (%s), aborting\n",
+		    ha->pdev->slot_name);
+		goto iospace_error_exit;
+	}
+#endif
+
+	if (pci_request_regions(ha->pdev, ha->brd_info->drv_name)) {
+		qla_printk(KERN_WARNING, ha,
+		    "Failed to reserve PIO/MMIO regions (%s)\n", 
+		    ha->pdev->slot_name);
+
+		goto iospace_error_exit;
+	}
+
+	/* Assume PIO */
+	ha->iobase = (device_reg_t *) pio;
+	ha->pio_address = pio;
+	ha->pio_length = pio_len;
+	ha->mmio_address = NULL;
+#if MEMORY_MAPPED_IO
+	ha->mmio_address = ioremap(mmio, MIN_IOBASE_LEN);
+	if (!ha->mmio_address) {
+		qla_printk(KERN_ERR, ha,
+		    "cannot remap MMIO (%s), aborting\n", ha->pdev->slot_name);
+
+		goto iospace_error_exit;
+	}
+	ha->iobase = (device_reg_t *) ha->mmio_address;
+	ha->mmio_length = mmio_len;
+#endif
+
+	return (0);
+
+iospace_error_exit:
+	return (-ENOMEM);
+}
+
+/*
+ * PCI driver interface
+ */
+int qla2x00_probe_one(struct pci_dev *pdev, struct qla_board_info *brd_info)
+{
+	int	ret;
+	device_reg_t *reg;
+	struct Scsi_Host *host;
+	scsi_qla_host_t *ha;
+	unsigned long	flags = 0;
+	unsigned long	wait_switch = 0;
+	char pci_info[20];
+	char fw_str[30];
+
+	if (pci_enable_device(pdev))
+		return -1;
+
+	host = scsi_host_alloc(&qla2x00_driver_template,
+	    sizeof(scsi_qla_host_t));
+	if (host == NULL) {
+		printk(KERN_WARNING
+		    "qla2xxx: Couldn't allocate host from scsi layer!\n");
+		return -1;
+	}
+
+	/* Clear our data area */
+	ha = (scsi_qla_host_t *)host->hostdata;
+	memset(ha, 0, sizeof(scsi_qla_host_t));
+
+	ha->pdev = pdev;
+	ha->host = host;
+	ha->host_no = host->host_no;
+	ha->brd_info = brd_info;
+	sprintf(ha->host_str, "%s_%ld", ha->brd_info->drv_name, ha->host_no);
+
+	/* Configure PCI I/O space */
+	ret = qla2x00_iospace_config(ha);
+	if (ret != 0) {
+		goto probe_failed;
+	}
+
+	/* Sanitize the information from PCI BIOS. */
+	host->irq = pdev->irq;
+
+	qla_printk(KERN_INFO, ha,
+	    "Found an %s, irq %d, iobase 0x%p\n", ha->brd_info->isp_name,
+	    host->irq, ha->iobase);
+
+	spin_lock_init(&ha->hardware_lock);
+
+	/* 4.23 Initialize /proc/scsi/qla2x00 counters */
+	ha->actthreads = 0;
+	ha->qthreads   = 0;
+	ha->total_isr_cnt = 0;
+	ha->total_isp_aborts = 0;
+	ha->total_lip_cnt = 0;
+	ha->total_dev_errs = 0;
+	ha->total_ios = 0;
+	ha->total_bytes = 0;
+
+	ha->prev_topology = 0;
+	ha->ports = MAX_BUSES;
+
+	if (IS_QLA2100(ha)) {
+		ha->max_targets = MAX_TARGETS_2100;
+		ha->mbx_count = MAILBOX_REGISTER_COUNT_2100;
+		ha->response_q_length = RESPONSE_ENTRY_CNT_2100;
+		ha->last_loop_id = SNS_LAST_LOOP_ID_2100;
+	} else if (IS_QLA2200(ha)) {
+		ha->max_targets = MAX_TARGETS_2200;
+		ha->mbx_count = MAILBOX_REGISTER_COUNT;
+		ha->response_q_length = RESPONSE_ENTRY_CNT_2100;
+		ha->last_loop_id = SNS_LAST_LOOP_ID_2100;
+	} else /*if (IS_QLA2300(ha))*/ {
+		ha->max_targets = MAX_TARGETS_2200;
+		ha->mbx_count = MAILBOX_REGISTER_COUNT;
+		ha->response_q_length = RESPONSE_ENTRY_CNT_2300;
+		ha->last_loop_id = SNS_LAST_LOOP_ID_2300;
+	}
+
+	/* load the F/W, read paramaters, and init the H/W */
+	ha->instance = num_hosts;
+
+	init_MUTEX_LOCKED(&ha->mbx_intr_sem);
+
+	INIT_LIST_HEAD(&ha->list);
+	INIT_LIST_HEAD(&ha->fcports);
+	INIT_LIST_HEAD(&ha->rscn_fcports);
+	INIT_LIST_HEAD(&ha->done_queue);
+	INIT_LIST_HEAD(&ha->retry_queue);
+	INIT_LIST_HEAD(&ha->scsi_retry_queue);
+	INIT_LIST_HEAD(&ha->pending_queue);
+
+	/*
+	 * These locks are used to prevent more than one CPU
+	 * from modifying the queue at the same time. The
+	 * higher level "host_lock" will reduce most
+	 * contention for these locks.
+	 */
+	spin_lock_init(&ha->mbx_bits_lock);
+	spin_lock_init(&ha->mbx_reg_lock);
+	spin_lock_init(&ha->mbx_q_lock);
+	spin_lock_init(&ha->list_lock);
+
+	init_completion(&ha->dpc_inited);
+	init_completion(&ha->dpc_exited);
+
+	qla2x00_config_dma_addressing(ha);
+	if (qla2x00_mem_alloc(ha)) {
+		qla_printk(KERN_WARNING, ha,
+		    "[ERROR] Failed to allocate memory for adapter\n");
+
+		goto probe_failed;
+	}
+
+	if (qla2x00_initialize_adapter(ha) &&
+	    !(ha->device_flags & DFLG_NO_CABLE)) {
+
+		qla_printk(KERN_WARNING, ha,
+		    "Failed to initialize adapter\n");
+
+		DEBUG2(printk("scsi(%ld): Failed to initialize adapter - "
+		    "Adapter flags %x.\n",
+		    ha->host_no, ha->device_flags));
+
+		goto probe_failed;
+	}
+
+	/*
+	 * Startup the kernel thread for this host adapter
+	 */
+	ha->dpc_should_die = 0;
+	ha->dpc_pid = kernel_thread(qla2x00_do_dpc, ha, 0);
+	if (ha->dpc_pid < 0) {
+		qla_printk(KERN_WARNING, ha,
+		    "Unable to start DPC thread!\n");
+
+		goto probe_failed;
+	}
+	wait_for_completion(&ha->dpc_inited);
+
+	host->this_id = 255;
+	host->cmd_per_lun = 3;
+	host->max_cmd_len = MAX_CMDSZ;
+	host->max_channel = ha->ports - 1;
+	host->max_lun = ha->max_luns;
+	host->unique_id = ha->instance;
+	host->max_id = ha->max_targets;
+
+	if (request_irq(host->irq, qla2x00_intr_handler, SA_INTERRUPT|SA_SHIRQ,
+	    ha->brd_info->drv_name, ha)) {
+		qla_printk(KERN_WARNING, ha,
+		    "Failed to reserve interrupt %d already in use.\n",
+		    host->irq);
+		goto probe_failed;
+	}
+
+	/* Initialized the timer */
+	qla2x00_start_timer(ha, qla2x00_timer, WATCH_INTERVAL);
+
+	DEBUG2(printk("DEBUG: detect hba %ld at address = %p\n",
+	    ha->host_no, ha));
+
+	reg = ha->iobase;
+
+	/* Disable ISP interrupts. */
+	qla2x00_disable_intrs(ha);
+
+	/* Ensure mailbox registers are free. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_WORD(&reg->semaphore, 0);
+	WRT_REG_WORD(&reg->hccr, HCCR_CLR_RISC_INT);
+	WRT_REG_WORD(&reg->hccr, HCCR_CLR_HOST_INT);
+
+	/* Enable proper parity */
+	if (IS_QLA23XX(ha)) {
+		if (IS_QLA2312(ha) || IS_QLA2322(ha))
+			/* SRAM, Instruction RAM and GP RAM parity */
+			WRT_REG_WORD(&reg->hccr, (HCCR_ENABLE_PARITY + 0x7));
+		else
+			/* SRAM parity */
+			WRT_REG_WORD(&reg->hccr, (HCCR_ENABLE_PARITY + 0x1));
+	}
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	/* Enable chip interrupts. */
+	qla2x00_enable_intrs(ha);
+
+	/* Insert new entry into the list of adapters */
+	write_lock(&qla_hostlist_lock);
+	list_add_tail(&ha->list, &qla_hostlist);
+	write_unlock(&qla_hostlist_lock);
+
+	/* v2.19.5b6 */
+	/*
+	 * Wait around max loop_reset_delay secs for the devices to come
+	 * on-line. We don't want Linux scanning before we are ready.
+	 *
+	 */
+	for (wait_switch = jiffies + (ha->loop_reset_delay * HZ);
+	    time_before(jiffies,wait_switch) &&
+	     !(ha->device_flags & (DFLG_NO_CABLE | DFLG_FABRIC_DEVICES))
+	     && (ha->device_flags & SWITCH_FOUND) ;) {
+
+		qla2x00_check_fabric_devices(ha);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(5);
+	}
+
+	pci_set_drvdata(pdev, ha);
+	ha->flags.init_done = 1;
+	num_hosts++;
+
+	/* List the target we have found */
+	if (displayConfig) {
+		qla2x00_display_fc_names(ha);
+	}
+
+	if (scsi_add_host(host, &pdev->dev))
+		goto probe_failed;
+
+	sysfs_create_bin_file(&host->shost_gendev.kobj, &sysfs_fw_dump_attr);
+	sysfs_create_bin_file(&host->shost_gendev.kobj, &sysfs_nvram_attr);
+
+	qla_printk(KERN_INFO, ha, "\n"
+	    " QLogic ISP2xxx PCI/PCI-X Fibre Channel HBA Driver: %s\n"
+	    "  QLogic %s - %s\n"
+	    "  %s: %s @ %s hdma%c, host#=%ld, fw=%s\n", qla2x00_version_str,
+	    ha->model_number, ha->model_desc ? ha->model_desc: "",
+	    ha->brd_info->isp_name, qla2x00_get_pci_info_str(ha, pci_info),
+	    pci_name(ha->pdev), ha->flags.enable_64bit_addressing ? '+': '-',
+	    ha->host_no, qla2x00_get_fw_version_str(ha, fw_str));
+
+	if (ql2xdoinitscan)
+		scsi_scan_host(host);
+
+	return 0;
+
+probe_failed:
+	qla2x00_free_device(ha);
+
+	scsi_host_put(host);
+
+	return -1;
+}
+EXPORT_SYMBOL_GPL(qla2x00_probe_one);
+
+void qla2x00_remove_one(struct pci_dev *pdev)
+{
+	scsi_qla_host_t *ha;
+
+	ha = pci_get_drvdata(pdev);
+
+	write_lock(&qla_hostlist_lock);
+	list_del(&ha->list);
+	write_unlock(&qla_hostlist_lock);
+
+	sysfs_remove_bin_file(&ha->host->shost_gendev.kobj,
+	    &sysfs_fw_dump_attr);
+	sysfs_remove_bin_file(&ha->host->shost_gendev.kobj, &sysfs_nvram_attr);
+
+	scsi_remove_host(ha->host);
+
+	qla2x00_free_device(ha);
+
+	scsi_host_put(ha->host);
+
+	pci_set_drvdata(pdev, NULL);
+}
+EXPORT_SYMBOL_GPL(qla2x00_remove_one);
+
+static void
+qla2x00_free_device(scsi_qla_host_t *ha)
+{
+	int ret;
+
+	/* Abort any outstanding IO descriptors. */
+	if (IS_QLA23XX(ha))
+		qla2x00_cancel_io_descriptors(ha);
+
+	/* turn-off interrupts on the card */
+	if (ha->interrupts_on)
+		qla2x00_disable_intrs(ha);
+
+	/* Disable timer */
+	if (ha->timer_active)
+		qla2x00_stop_timer(ha);
+
+	/* Kill the kernel thread for this host */
+	if (ha->dpc_pid >= 0) {
+		ha->dpc_should_die = 1;
+		wmb();
+		ret = kill_proc(ha->dpc_pid, SIGHUP, 1);
+		if (ret) {
+			qla_printk(KERN_ERR, ha,
+			    "Unable to signal DPC thread -- (%d)\n", ret);
+
+			/* TODO: SOMETHING MORE??? */
+		} else {
+			wait_for_completion(&ha->dpc_exited);
+		}
+	}
+
+	qla2x00_mem_free(ha);
+
+	ha->flags.online = FALSE;
+
+	/* Detach interrupts */
+	if (ha->pdev->irq)
+		free_irq(ha->pdev->irq, ha);
+
+	/* release io space registers  */
+	pci_release_regions(ha->pdev);
+
+#if MEMORY_MAPPED_IO
+	if (ha->mmio_address)
+		iounmap(ha->mmio_address);
+#endif
+}
+
+
+/*
+ * The following support functions are adopted to handle
+ * the re-entrant qla2x00_proc_info correctly.
+ */
+static void
+copy_mem_info(struct info_str *info, char *data, int len)
+{
+	if (info->pos + len > info->offset + info->length)
+		len = info->offset + info->length - info->pos;
+
+	if (info->pos + len < info->offset) {
+		info->pos += len;
+		return;
+	}
+ 
+	if (info->pos < info->offset) {
+		off_t partial;
+ 
+		partial = info->offset - info->pos;
+		data += partial;
+		info->pos += partial;
+		len  -= partial;
+	}
+ 
+	if (len > 0) {
+		memcpy(info->buffer, data, len);
+		info->pos += len;
+		info->buffer += len;
+	}
+}
+
+static int
+copy_info(struct info_str *info, char *fmt, ...)
+{
+	va_list args;
+	char buf[256];
+	int len;
+ 
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+ 
+	copy_mem_info(info, buf, len);
+
+	return (len);
+}
+
+/*************************************************************************
+* qla2x00_proc_info
+*
+* Description:
+*   Return information to handle /proc support for the driver.
+*
+* inout : decides the direction of the dataflow and the meaning of the
+*         variables
+* buffer: If inout==FALSE data is being written to it else read from it
+*         (ptr to a page buffer)
+* *start: If inout==FALSE start of the valid data in the buffer
+* offset: If inout==FALSE starting offset from the beginning of all
+*         possible data to return.
+* length: If inout==FALSE max number of bytes to be written into the buffer
+*         else number of bytes in "buffer"
+* Returns:
+*         < 0:  error. errno value.
+*         >= 0: sizeof data returned.
+*************************************************************************/
+int
+qla2x00_proc_info(struct Scsi_Host *shost, char *buffer,
+    char **start, off_t offset, int length, int inout)
+{
+	struct info_str	info;
+	int             i;
+	int             retval = -EINVAL;
+	os_lun_t	*up;
+	os_tgt_t	*tq;
+	unsigned int	t, l;
+	uint32_t        tmp_sn;
+	unsigned long   *flags;
+	uint8_t		*loop_state;
+	int	found;
+	scsi_qla_host_t *ha;
+	char fw_info[30];
+
+	DEBUG3(printk(KERN_INFO
+	    "Entering proc_info buff_in=%p, offset=0x%lx, length=0x%x\n",
+	    buffer, offset, length);)
+
+	ha = NULL;
+
+	/* Find the host that was specified */
+	found = 0;
+	read_lock(&qla_hostlist_lock);
+	list_for_each_entry(ha, &qla_hostlist, list) {
+		if (ha->host == shost) {
+			found++;
+			break;
+		}
+	}
+	read_unlock(&qla_hostlist_lock);
+
+	/* if host wasn't found then exit */
+	if (!found) {
+		DEBUG2_3(printk(KERN_WARNING
+		    "%s: Can't find adapter for host %p\n", 
+		    __func__, shost);)
+
+		return (retval);
+	}
+
+	if (inout == TRUE) {
+		/* Has data been written to the file? */
+		DEBUG3(printk(
+		    "%s: has data been written to the file. \n",
+		    __func__);)
+
+		return (qla2x00_set_info(buffer, length, shost));
+	}
+
+	if (start) {
+		*start = buffer;
+	}
+
+	info.buffer = buffer;
+	info.length = length;
+	info.offset = offset;
+	info.pos    = 0;
+
+	/* start building the print buffer */
+	copy_info(&info,
+	    "QLogic PCI to Fibre Channel Host Adapter for %s:\n"
+	    "        Firmware version %s, ",
+	    ha->model_number, qla2x00_get_fw_version_str(ha, fw_info));
+
+	copy_info(&info, "Driver version %s\n", qla2x00_version_str);
+
+	copy_info(&info, "Entry address = %p\n", qla2x00_set_info);
+
+	tmp_sn = ((ha->serial0 & 0x1f) << 16) | (ha->serial2 << 8) | 
+	    ha->serial1;
+	copy_info(&info, "ISP: %s, Serial# %c%05d\n",
+	    ha->brd_info->isp_name, ('A' + tmp_sn/100000), (tmp_sn%100000));
+
+	copy_info(&info,
+	    "Request Queue = 0x%p, Response Queue = 0x%p\n",
+	    (void *)ha->request_dma, (void *)ha->response_dma);
+
+	copy_info(&info,
+	    "Request Queue count = %ld, Response Queue count = %ld\n",
+	    (long)REQUEST_ENTRY_CNT, (long)ha->response_q_length);
+
+	copy_info(&info,
+	    "Total number of active commands = %ld\n",
+	    ha->actthreads);
+
+	copy_info(&info,
+	    "Total number of interrupts = %ld\n",
+	    (long)ha->total_isr_cnt);
+
+	copy_info(&info,
+	    "    Device queue depth = 0x%x\n",
+	    (ql2xmaxqdepth == 0) ? 16 : ql2xmaxqdepth);
+
+	copy_info(&info,
+	    "Number of free request entries = %d\n", ha->req_q_cnt);
+
+	copy_info(&info,
+	    "Number of mailbox timeouts = %ld\n", ha->total_mbx_timeout);
+
+	copy_info(&info,
+	    "Number of ISP aborts = %ld\n", ha->total_isp_aborts);
+
+	copy_info(&info,
+	    "Number of loop resyncs = %ld\n", ha->total_loop_resync);
+
+	copy_info(&info,
+	    "Number of retries for empty slots = %ld\n",
+	    qla2x00_stats.outarray_full);
+
+	copy_info(&info,
+	    "Number of reqs in pending_q= %ld, retry_q= %d, "
+	    "done_q= %ld, scsi_retry_q= %d\n",
+	    ha->qthreads, ha->retry_q_cnt,
+	    ha->done_q_cnt, ha->scsi_retry_q_cnt);
+
+	flags = (unsigned long *) &ha->flags;
+
+	if (atomic_read(&ha->loop_state) == LOOP_DOWN) {
+		loop_state = "DOWN";
+	} else if (atomic_read(&ha->loop_state) == LOOP_UP) {
+		loop_state = "UP";
+	} else if (atomic_read(&ha->loop_state) == LOOP_READY) {
+		loop_state = "READY";
+	} else if (atomic_read(&ha->loop_state) == LOOP_TIMEOUT) {
+		loop_state = "TIMEOUT";
+	} else if (atomic_read(&ha->loop_state) == LOOP_UPDATE) {
+		loop_state = "UPDATE";
+	} else {
+		loop_state = "UNKNOWN";
+	}
+
+	copy_info(&info, 
+	    "Host adapter:loop state = <%s>, flags = 0x%lx\n",
+	    loop_state , *flags);
+
+	copy_info(&info, "Dpc flags = 0x%lx\n", ha->dpc_flags);
+
+	copy_info(&info, "MBX flags = 0x%x\n", ha->mbx_flags);
+
+	copy_info(&info, "Link down Timeout = %3.3d\n",
+	    ha->link_down_timeout);
+
+	copy_info(&info, "Port down retry = %3.3d\n",
+	    ha->port_down_retry_count);
+
+	copy_info(&info, "Login retry count = %3.3d\n",
+	    ha->login_retry_count);
+
+	copy_info(&info,
+	    "Commands retried with dropped frame(s) = %d\n",
+	    ha->dropped_frame_error_cnt);
+
+	copy_info(&info,
+	    "Info -- pci=%x xchgs=0x%x iocbs=0x%x\n", ha->pci_attr,
+	    ha->xchg_buf_cnt, ha->iocb_buf_cnt);
+
+	copy_info(&info, "\n");
+
+	/* 2.25 node/port display to proc */
+	/* Display the node name for adapter */
+	copy_info(&info, "\nSCSI Device Information:\n");
+	copy_info(&info,
+	    "scsi-qla%d-adapter-node="
+	    "%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+	    (int)ha->instance,
+	    ha->init_cb->node_name[0],
+	    ha->init_cb->node_name[1],
+	    ha->init_cb->node_name[2],
+	    ha->init_cb->node_name[3],
+	    ha->init_cb->node_name[4],
+	    ha->init_cb->node_name[5],
+	    ha->init_cb->node_name[6],
+	    ha->init_cb->node_name[7]);
+
+	/* display the port name for adapter */
+	copy_info(&info,
+	    "scsi-qla%d-adapter-port="
+	    "%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+	    (int)ha->instance,
+	    ha->init_cb->port_name[0],
+	    ha->init_cb->port_name[1],
+	    ha->init_cb->port_name[2],
+	    ha->init_cb->port_name[3],
+	    ha->init_cb->port_name[4],
+	    ha->init_cb->port_name[5],
+	    ha->init_cb->port_name[6],
+	    ha->init_cb->port_name[7]);
+
+	/* Print out device port names */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if ((tq = TGT_Q(ha, i)) == NULL)
+			continue;
+
+		copy_info(&info,
+			  "scsi-qla%d-target-%d="
+			  "%02x%02x%02x%02x%02x%02x%02x%02x;\n",
+			  (int)ha->instance, i,
+			  tq->port_name[0], tq->port_name[1],
+			  tq->port_name[2], tq->port_name[3],
+			  tq->port_name[4], tq->port_name[5],
+			  tq->port_name[6], tq->port_name[7]);
+	} /* 2.25 node/port display to proc */
+
+	copy_info(&info, "\nSCSI LUN Information:\n");
+	copy_info(&info,
+	    "(Id:Lun)  * - indicates lun is not registered with the OS.\n");
+
+	/* scan for all equipment stats */
+	for (t = 0; t < MAX_FIBRE_DEVICES; t++) {
+		/* scan all luns */
+		for (l = 0; l < ha->max_luns; l++) {
+			up = (os_lun_t *) GET_LU_Q(ha, t, l);
+
+			if (up == NULL) {
+				continue;
+			}
+			if (up->fclun == NULL) {
+				continue;
+			}
+
+			copy_info(&info,
+			    "(%2d:%2d): Total reqs %ld,",
+			    t,l,up->io_cnt);
+
+			copy_info(&info,
+			    " Pending reqs %ld,",
+			    up->out_cnt);
+
+			if (up->io_cnt < 4) {
+				copy_info(&info,
+				    " flags 0x%x*,",
+				    (int)up->q_flag);
+			} else {
+				copy_info(&info,
+				    " flags 0x%x,",
+				    (int)up->q_flag);
+			}
+
+			copy_info(&info, 
+			    " %ld:%d:%02x %02x",
+			    up->fclun->fcport->ha->instance,
+			    up->fclun->fcport->cur_path,
+			    up->fclun->fcport->loop_id,
+			    up->fclun->device_type);
+
+			copy_info(&info, "\n");
+
+			if (info.pos >= info.offset + info.length) {
+				/* No need to continue */
+				goto profile_stop;
+			}
+		}
+
+		if (info.pos >= info.offset + info.length) {
+			/* No need to continue */
+			break;
+		}
+	}
+
+profile_stop:
+
+	retval = info.pos > info.offset ? info.pos - info.offset : 0;
+
+	DEBUG3(printk(KERN_INFO 
+	    "Exiting proc_info: info.pos=%d, offset=0x%lx, "
+	    "length=0x%x\n", info.pos, offset, length);)
+
+	return (retval);
+}
+
+/*
+* qla2x00_display_fc_names
+*      This routine will the node names of the different devices found
+*      after port inquiry.
+*
+* Input:
+*      cmd = SCSI command structure
+*
+* Returns:
+*      None.
+*/
+static void
+qla2x00_display_fc_names(scsi_qla_host_t *ha) 
+{
+	uint16_t	tgt;
+	os_tgt_t	*tq;
+
+	/* Display the node name for adapter */
+	qla_printk(KERN_INFO, ha,
+	    "scsi-qla%d-adapter-node=%02x%02x%02x%02x%02x%02x%02x%02x\\;\n",
+	    (int)ha->instance,
+	    ha->init_cb->node_name[0],
+	    ha->init_cb->node_name[1],
+	    ha->init_cb->node_name[2],
+	    ha->init_cb->node_name[3],
+	    ha->init_cb->node_name[4],
+	    ha->init_cb->node_name[5],
+	    ha->init_cb->node_name[6],
+	    ha->init_cb->node_name[7]);
+
+	/* display the port name for adapter */
+	qla_printk(KERN_INFO, ha,
+	    "scsi-qla%d-adapter-port=%02x%02x%02x%02x%02x%02x%02x%02x\\;\n",
+	    (int)ha->instance,
+	    ha->init_cb->port_name[0],
+	    ha->init_cb->port_name[1],
+	    ha->init_cb->port_name[2],
+	    ha->init_cb->port_name[3],
+	    ha->init_cb->port_name[4],
+	    ha->init_cb->port_name[5],
+	    ha->init_cb->port_name[6],
+	    ha->init_cb->port_name[7]);
+
+	/* Print out device port names */
+	for (tgt = 0; tgt < MAX_TARGETS; tgt++) {
+		if ((tq = ha->otgt[tgt]) == NULL)
+			continue;
+
+		if (tq->fcport == NULL)
+			continue;
+
+		switch (ha->binding_type) {
+			case BIND_BY_PORT_NAME:
+				qla_printk(KERN_INFO, ha,
+				    "scsi-qla%d-tgt-%d-di-0-port="
+				    "%02x%02x%02x%02x%02x%02x%02x%02x\\;\n",
+				    (int)ha->instance, 
+				    tgt,
+				    tq->port_name[0], 
+				    tq->port_name[1],
+				    tq->port_name[2], 
+				    tq->port_name[3],
+				    tq->port_name[4], 
+				    tq->port_name[5],
+				    tq->port_name[6], 
+				    tq->port_name[7]);
+
+				break;
+
+			case BIND_BY_PORT_ID:
+				qla_printk(KERN_INFO, ha,
+				    "scsi-qla%d-tgt-%d-di-0-pid="
+				    "%02x%02x%02x\\;\n",
+				    (int)ha->instance,
+				    tgt,
+				    tq->d_id.b.domain,
+				    tq->d_id.b.area,
+				    tq->d_id.b.al_pa);
+				break;
+		}
+
+#if VSA
+		qla_printk(KERN_INFO, ha,
+		    "scsi-qla%d-target-%d-vsa=01;\n", (int)ha->instance, tgt);
+#endif
+	}
+}
+
+/*
+ *  qla2x00_suspend_lun
+ *	Suspend lun and start port down timer
+ *
+ * Input:
+ *	ha = visable adapter block pointer.
+ *  lq = lun queue
+ *  cp = Scsi command pointer 
+ *  time = time in seconds
+ *  count = number of times to let time expire
+ *  delay_lun = non-zero, if lun should be delayed rather than suspended
+ *
+ * Return:
+ *     QLA_SUCCESS  -- suspended lun 
+ *     QLA_FUNCTION_FAILED  -- Didn't suspend lun
+ *
+ * Context:
+ *	Interrupt context.
+ */
+int
+__qla2x00_suspend_lun(scsi_qla_host_t *ha,
+		os_lun_t *lq, int time, int count, int delay_lun)
+{
+	int	rval;
+	srb_t *sp;
+	struct list_head *list, *temp;
+	unsigned long flags;
+
+	rval = QLA_SUCCESS;
+
+	/* if the lun_q is already suspended then don't do it again */
+	if (lq->q_state == LUN_STATE_READY ||lq->q_state == LUN_STATE_RUN) {
+
+		spin_lock_irqsave(&lq->q_lock, flags);
+		if (lq->q_state == LUN_STATE_READY) {
+			lq->q_max = count;
+			lq->q_count = 0;
+		}
+		/* Set the suspend time usually 6 secs */
+		atomic_set(&lq->q_timer, time);
+
+		/* now suspend the lun */
+		lq->q_state = LUN_STATE_WAIT;
+
+		if (delay_lun) {
+			set_bit(LUN_EXEC_DELAYED, &lq->q_flag);
+			DEBUG(printk(KERN_INFO
+			    "scsi(%ld): Delay lun execution for %d secs, "
+			    "count=%d, max count=%d, state=%d\n",
+			    ha->host_no,
+			    time,
+			    lq->q_count, lq->q_max, lq->q_state));
+		} else {
+			DEBUG(printk(KERN_INFO
+			    "scsi(%ld): Suspend lun for %d secs, count=%d, "
+			    "max count=%d, state=%d\n",
+			    ha->host_no,
+			    time,
+			    lq->q_count, lq->q_max, lq->q_state));
+		}
+		spin_unlock_irqrestore(&lq->q_lock, flags);
+
+		/*
+		 * Remove all pending commands from request queue and  put them
+		 * in the scsi_retry queue.
+		 */
+		spin_lock_irqsave(&ha->list_lock, flags);
+		list_for_each_safe(list, temp, &ha->pending_queue) {
+			sp = list_entry(list, srb_t, list);
+			if (sp->lun_queue != lq)
+				continue;
+
+			__del_from_pending_queue(ha, sp);
+
+			if (sp->cmd->allowed < count)
+				sp->cmd->allowed = count;
+			__add_to_scsi_retry_queue(ha, sp);
+
+		} /* list_for_each_safe */
+		spin_unlock_irqrestore(&ha->list_lock, flags);
+		rval = QLA_SUCCESS;
+	} else {
+		rval = QLA_FUNCTION_FAILED;
+	}
+
+	return (rval);
+}
+
+/*
+ * qla2x00_mark_device_lost Updates fcport state when device goes offline.
+ *
+ * Input: ha = adapter block pointer.  fcport = port structure pointer.
+ *
+ * Return: None.
+ *
+ * Context:
+ */
+void qla2x00_mark_device_lost(scsi_qla_host_t *ha, fc_port_t *fcport,
+    int do_login)
+{
+	/* 
+	 * We may need to retry the login, so don't change the state of the
+	 * port but do the retries.
+	 */
+	if (atomic_read(&fcport->state) != FCS_DEVICE_DEAD)
+		atomic_set(&fcport->state, FCS_DEVICE_LOST);
+
+	if (!do_login)
+		return;
+
+	if (fcport->login_retry == 0) {
+		fcport->login_retry = ha->login_retry_count;
+		set_bit(RELOGIN_NEEDED, &ha->dpc_flags);
+
+		DEBUG(printk("scsi(%ld): Port login retry: "
+		    "%02x%02x%02x%02x%02x%02x%02x%02x, "
+		    "id = 0x%04x retry cnt=%d\n",
+		    ha->host_no,
+		    fcport->port_name[0],
+		    fcport->port_name[1],
+		    fcport->port_name[2],
+		    fcport->port_name[3],
+		    fcport->port_name[4],
+		    fcport->port_name[5],
+		    fcport->port_name[6],
+		    fcport->port_name[7],
+		    fcport->loop_id,
+		    fcport->login_retry));
+	}
+}
+
+/*
+ * qla2x00_mark_all_devices_lost
+ *	Updates fcport state when device goes offline.
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *	fcport = port structure pointer.
+ *
+ * Return:
+ *	None.
+ *
+ * Context:
+ */
+void
+qla2x00_mark_all_devices_lost(scsi_qla_host_t *ha) 
+{
+	struct list_head	*fcpl;
+	fc_port_t		*fcport;
+
+	list_for_each(fcpl, &ha->fcports) {
+		fcport = list_entry(fcpl, fc_port_t, list);
+
+		/*
+		 * No point in marking the device as lost, if the device is
+		 * already DEAD.
+		 */
+		if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD)
+			continue;
+
+		atomic_set(&fcport->state, FCS_DEVICE_LOST);
+	}
+}
+
+/*
+* qla2x00_mem_alloc
+*      Allocates adapter memory.
+*
+* Returns:
+*      0  = success.
+*      1  = failure.
+*/
+static uint8_t
+qla2x00_mem_alloc(scsi_qla_host_t *ha)
+{
+	uint8_t   status = 1;
+	uint8_t   i;
+	int	retry= 10;
+	mbx_cmdq_t	*ptmp;
+	mbx_cmdq_t	*tmp_q_head;
+	mbx_cmdq_t	*tmp_q_tail;
+
+	ENTER(__func__);
+
+	do {
+		/*
+		 * This will loop only once if everything goes well, else some
+		 * number of retries will be performed to get around a kernel
+		 * bug where available mem is not allocated until after a
+		 * little delay and a retry.
+		 */
+		ha->request_ring = pci_alloc_consistent(ha->pdev,
+		    ((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+		    &ha->request_dma);
+		if (ha->request_ring == NULL) {
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - request_ring\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+
+		ha->response_ring = pci_alloc_consistent(ha->pdev,
+		    ((ha->response_q_length + 1) * (sizeof(response_t))),
+		    &ha->response_dma);
+		if (ha->response_ring == NULL) {
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - response_ring\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+
+		/* get consistent memory allocated for init control block */
+		ha->init_cb = pci_alloc_consistent(ha->pdev,
+		    sizeof(init_cb_t), &ha->init_cb_dma);
+		if (ha->init_cb == NULL) {
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - init_cb\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+		memset(ha->init_cb, 0, sizeof(init_cb_t));
+
+		/* Allocate ioctl related memory. */
+		if (qla2x00_alloc_ioctl_mem(ha)) {
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - ioctl_mem\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+
+		if (qla2x00_allocate_sp_pool(ha)) {
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - "
+			    "qla2x00_allocate_sp_pool()\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+
+		/*
+		 * Allocate an initial list of mailbox semaphore queue to be
+		 * used for serialization of the mailbox commands.
+		 */
+		tmp_q_head = kmalloc(sizeof(mbx_cmdq_t), GFP_KERNEL);
+		if (tmp_q_head == NULL) {
+			/* error */
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - mbx_cmd_q");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+		memset(tmp_q_head, 0, sizeof(mbx_cmdq_t));
+		ha->mbx_sem_pool_head = tmp_q_head;
+		tmp_q_tail = tmp_q_head;
+
+		/* Now try to allocate more */
+		for (i = 1; i < MBQ_INIT_LEN; i++) {
+			ptmp = kmalloc(sizeof(mbx_cmdq_t), GFP_KERNEL);
+			if (ptmp == NULL) {
+				/*
+				 * Error. Just exit. If more is needed later
+				 * they will be allocated at that time.
+				 */
+				break;
+			}
+			memset(ptmp, 0, sizeof(mbx_cmdq_t));
+			tmp_q_tail->pnext = ptmp;
+			tmp_q_tail = ptmp;
+		}
+		ha->mbx_sem_pool_tail = tmp_q_tail;
+
+		/* Get consistent memory allocated for MS IOCB */
+		ha->ms_iocb = pci_alloc_consistent(ha->pdev,
+		    sizeof(ms_iocb_entry_t), &ha->ms_iocb_dma);
+		if (ha->ms_iocb == NULL) {
+			/* error */
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - ms_iocb\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+		memset(ha->ms_iocb, 0, sizeof(ms_iocb_entry_t));
+
+		/* Get consistent memory allocated for CT SNS commands */
+		ha->ct_sns = pci_alloc_consistent(ha->pdev,
+		    sizeof(struct ct_sns_pkt), &ha->ct_sns_dma);
+		if (ha->ct_sns == NULL) {
+			/* error */
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - ct_sns\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+		memset(ha->ct_sns, 0, sizeof(struct ct_sns_pkt));
+
+		/* Get consistent memory allocated for Get Port Database cmd */
+		ha->iodesc_pd = pci_alloc_consistent(ha->pdev,
+		    PORT_DATABASE_SIZE, &ha->iodesc_pd_dma);
+		if (ha->iodesc_pd == NULL) {
+			/* error */
+			qla_printk(KERN_WARNING, ha,
+			    "Memory Allocation failed - iodesc_pd\n");
+
+			qla2x00_mem_free(ha);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ/10);
+
+			continue;
+		}
+		memset(ha->iodesc_pd, 0, PORT_DATABASE_SIZE);
+
+		/* Done all allocations without any error. */
+		status = 0;
+
+	} while (retry-- && status != 0);
+
+	if (status) {
+		printk(KERN_WARNING
+			"%s(): **** FAILED ****\n", __func__);
+	}
+
+	LEAVE(__func__);
+
+	return(status);
+}
+
+/*
+* qla2x00_mem_free
+*      Frees all adapter allocated memory.
+*
+* Input:
+*      ha = adapter block pointer.
+*/
+static void
+qla2x00_mem_free(scsi_qla_host_t *ha)
+{
+	uint32_t	t;
+	struct list_head	*fcpl, *fcptemp;
+	fc_port_t	*fcport;
+	struct list_head	*fcll, *fcltemp;
+	fc_lun_t	*fclun;
+	mbx_cmdq_t	*ptmp;
+	mbx_cmdq_t	*tmp_q_head;
+	unsigned long	wtime;/* max wait time if mbx cmd is busy. */
+
+	ENTER(__func__);
+
+	if (ha == NULL) {
+		/* error */
+		DEBUG2(printk("%s(): ERROR invalid ha pointer.\n", __func__));
+		return;
+	}
+
+	/* Free the target queues */
+	for (t = 0; t < MAX_TARGETS; t++) {
+		qla2x00_tgt_free(ha, t);
+	}
+
+	/* Make sure all other threads are stopped. */
+	wtime = 60 * HZ;
+	while ((ha->dpc_wait != NULL || ha->mbx_q_head != NULL) && wtime) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		wtime = schedule_timeout(wtime);
+	}
+
+	/* Now free the mbx sem pool */
+	tmp_q_head = ha->mbx_sem_pool_head;
+	while (tmp_q_head != NULL) {
+		ptmp = tmp_q_head->pnext;
+		kfree(tmp_q_head);
+		tmp_q_head = ptmp;
+	}
+	ha->mbx_sem_pool_head = NULL;
+
+	/* free ioctl memory */
+	qla2x00_free_ioctl_mem(ha);
+
+	/* free sp pool */
+	qla2x00_free_sp_pool(ha);
+
+	if (ha->iodesc_pd) {
+		pci_free_consistent(ha->pdev, PORT_DATABASE_SIZE,
+		    ha->iodesc_pd, ha->iodesc_pd_dma);
+	}
+	if (ha->ct_sns) {
+		pci_free_consistent(ha->pdev,
+		    sizeof(struct ct_sns_pkt), ha->ct_sns, ha->ct_sns_dma);
+	}
+	if (ha->ms_iocb) {
+		pci_free_consistent(ha->pdev,
+		    sizeof(ms_iocb_entry_t), ha->ms_iocb, ha->ms_iocb_dma);
+	}
+
+	if (ha->init_cb) {
+		pci_free_consistent(ha->pdev,
+		    sizeof(init_cb_t), ha->init_cb, ha->init_cb_dma);
+	}
+
+	if (ha->request_ring) {
+		pci_free_consistent(ha->pdev,
+		    ((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+		    ha->request_ring, ha->request_dma);
+	}
+
+	if (ha->response_ring) {
+		pci_free_consistent(ha->pdev,
+		    ((ha->response_q_length + 1) * (sizeof(response_t))),
+		    ha->response_ring, ha->response_dma);
+	}
+
+	ha->iodesc_pd = NULL;
+	ha->iodesc_pd_dma = 0;
+	ha->ct_sns = NULL;
+	ha->ms_iocb = NULL;
+
+	ha->init_cb = NULL;
+	ha->request_ring = NULL;
+	ha->request_dma = 0;
+	ha->response_ring = NULL;
+	ha->response_dma = 0;
+
+	list_for_each_safe(fcpl, fcptemp, &ha->fcports) {
+		fcport = list_entry(fcpl, fc_port_t, list);
+
+		/* fc luns */
+		list_for_each_safe(fcll, fcltemp, &fcport->fcluns) {
+			fclun = list_entry(fcll, fc_lun_t, list);
+
+			list_del_init(&fclun->list);
+			kfree(fclun);
+		}
+
+		/* fc ports */
+		list_del_init(&fcport->list);
+		kfree(fcport);
+	}
+	INIT_LIST_HEAD(&ha->fcports);
+
+	if (ha->fw_dump) {
+		free_pages((unsigned long)ha->fw_dump, ha->fw_dump_order);
+		ha->fw_dump = NULL;
+	}
+
+	if (ha->fw_dump_buffer) {
+		vfree(ha->fw_dump_buffer);
+		ha->fw_dump_reading = 0;
+		ha->fw_dump_buffer = NULL;
+	}
+
+	LEAVE(__func__);
+}
+
+/*
+ * qla2x00_allocate_sp_pool
+ * 	 This routine is called during initialization to allocate
+ *  	 memory for local srb_t.
+ *
+ * Input:
+ *	 ha   = adapter block pointer.
+ *
+ * Context:
+ *      Kernel context.
+ * 
+ * Note: Sets the ref_count for non Null sp to one.
+ */
+int
+qla2x00_allocate_sp_pool(scsi_qla_host_t *ha) 
+{
+	int      rval;
+
+	rval = QLA_SUCCESS;
+	ha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,
+	    mempool_free_slab, srb_cachep);
+	if (ha->srb_mempool == NULL) {
+		qla_printk(KERN_INFO, ha, "Unable to allocate SRB mempool.\n");
+		rval = QLA_FUNCTION_FAILED;
+	}
+	return (rval);
+}
+
+/*
+ *  This routine frees all adapter allocated memory.
+ *  
+ */
+void
+qla2x00_free_sp_pool( scsi_qla_host_t *ha) 
+{
+	if (ha->srb_mempool) {
+		mempool_destroy(ha->srb_mempool);
+		ha->srb_mempool = NULL;
+	}
+}
+
+/**************************************************************************
+* qla2x00_do_dpc
+*   This kernel thread is a task that is schedule by the interrupt handler
+*   to perform the background processing for interrupts.
+*
+* Notes:
+* This task always run in the context of a kernel thread.  It
+* is kick-off by the driver's detect code and starts up
+* up one per adapter. It immediately goes to sleep and waits for
+* some fibre event.  When either the interrupt handler or
+* the timer routine detects a event it will one of the task
+* bits then wake us up.
+**************************************************************************/
+static int
+qla2x00_do_dpc(void *data)
+{
+	DECLARE_MUTEX_LOCKED(sem);
+	scsi_qla_host_t *ha;
+	struct list_head *fcpl;
+	fc_port_t	*fcport;
+	os_lun_t        *q;
+	srb_t           *sp;
+	uint8_t		status;
+	unsigned long	flags = 0;
+	struct list_head *list, *templist;
+	int	dead_cnt, online_cnt;
+	uint16_t	next_loopid;
+
+	ha = (scsi_qla_host_t *)data;
+
+	lock_kernel();
+
+	daemonize("%s_dpc", ha->host_str);
+	allow_signal(SIGHUP);
+
+	ha->dpc_wait = &sem;
+
+	set_user_nice(current, -20);
+
+	unlock_kernel();
+
+	complete(&ha->dpc_inited);
+
+	while (1) {
+		DEBUG3(printk("qla2x00: DPC handler sleeping\n"));
+
+		if (down_interruptible(&sem))
+			break;
+
+		if (ha->dpc_should_die)
+			break;
+
+		if (!list_empty(&ha->done_queue))
+			qla2x00_done(ha);
+
+		DEBUG3(printk("qla2x00: DPC handler waking up\n"));
+
+		/* Initialization not yet finished. Don't do anything yet. */
+		if (!ha->flags.init_done || ha->dpc_active)
+			continue;
+
+		DEBUG3(printk("scsi(%ld): DPC handler\n", ha->host_no));
+
+		ha->dpc_active = 1;
+
+		/* Process commands in retry queue */
+		if (test_and_clear_bit(PORT_RESTART_NEEDED, &ha->dpc_flags)) {
+			DEBUG(printk("scsi(%ld): DPC checking retry_q. "
+			    "total=%d\n",
+			    ha->host_no, ha->retry_q_cnt));
+
+			spin_lock_irqsave(&ha->list_lock, flags);
+			dead_cnt = online_cnt = 0;
+			list_for_each_safe(list, templist, &ha->retry_queue) {
+				sp = list_entry(list, srb_t, list);
+				q = sp->lun_queue;
+				DEBUG3(printk("scsi(%ld): pid=%ld sp=%p, "
+				    "spflags=0x%x, q_flag= 0x%lx\n",
+				    ha->host_no, sp->cmd->serial_number, sp,
+				    sp->flags, q->q_flag));
+
+				if (q == NULL)
+					continue;
+				fcport = q->fclun->fcport;
+
+				if (atomic_read(&fcport->state) ==
+				    FCS_DEVICE_DEAD ||
+				    atomic_read(&ha->loop_state) == LOOP_DEAD) {
+
+					__del_from_retry_queue(ha, sp);
+					sp->cmd->result = DID_NO_CONNECT << 16;
+					sp->cmd->host_scribble =
+					    (unsigned char *) NULL;
+					__add_to_done_queue(ha, sp);
+					dead_cnt++;
+				} else if (atomic_read(&fcport->state) !=
+				    FCS_DEVICE_LOST) {
+
+					__del_from_retry_queue(ha, sp);
+					sp->cmd->result = DID_BUS_BUSY << 16;
+					sp->cmd->host_scribble =
+					    (unsigned char *) NULL;
+					__add_to_done_queue(ha, sp);
+					online_cnt++;
+				}
+			} /* list_for_each_safe() */
+			spin_unlock_irqrestore(&ha->list_lock, flags);
+
+			DEBUG(printk("scsi(%ld): done processing retry queue "
+			    "- dead=%d, online=%d\n ",
+			    ha->host_no, dead_cnt, online_cnt));
+		}
+
+		/* Process commands in scsi retry queue */
+		if (test_and_clear_bit(SCSI_RESTART_NEEDED, &ha->dpc_flags)) {
+			/*
+			 * Any requests we want to delay for some period is put
+			 * in the scsi retry queue with a delay added. The
+			 * timer will schedule a "scsi_restart_needed" every 
+			 * second as long as there are requests in the scsi
+			 * queue. 
+			 */
+			DEBUG(printk("scsi(%ld): DPC checking scsi "
+			    "retry_q.total=%d\n",
+			    ha->host_no, ha->scsi_retry_q_cnt));
+
+			online_cnt = 0;
+			spin_lock_irqsave(&ha->list_lock, flags);
+			list_for_each_safe(list, templist,
+			    &ha->scsi_retry_queue) {
+
+				sp = list_entry(list, srb_t, list);
+				q = sp->lun_queue;
+
+				DEBUG3(printk("scsi(%ld): scsi_retry_q: "
+				    "pid=%ld sp=%p, spflags=0x%x, "
+				    "q_flag= 0x%lx,q_state=%d\n",
+				    ha->host_no, sp->cmd->serial_number,
+				    sp, sp->flags, q->q_flag, q->q_state));
+
+				/* Was this lun suspended */
+				if (q->q_state != LUN_STATE_WAIT) {
+					online_cnt++;
+					__del_from_scsi_retry_queue(ha, sp);
+					__add_to_retry_queue(ha,sp);
+				}
+
+				/* Was this command suspended for N secs */
+				if (sp->delay != 0) {
+					sp->delay--;
+					if (sp->delay == 0) {
+						online_cnt++;
+						__del_from_scsi_retry_queue(
+						    ha, sp);
+						__add_to_retry_queue(ha,sp);
+					}
+				}
+			}
+			spin_unlock_irqrestore(&ha->list_lock, flags);
+
+			DEBUG(if (online_cnt > 0))
+			DEBUG(printk("scsi(%ld): dpc() found scsi reqs to "
+			    "restart= %d\n",
+			    ha->host_no, online_cnt));
+		}
+
+		if (ha->flags.mbox_busy) {
+			if (!list_empty(&ha->done_queue))
+				qla2x00_done(ha);
+
+			ha->dpc_active = 0;
+			continue;
+		}
+
+		if (test_and_clear_bit(ISP_ABORT_NEEDED, &ha->dpc_flags)) {
+
+			DEBUG(printk("scsi(%ld): dpc: sched "
+			    "qla2x00_abort_isp ha = %p\n",
+			    ha->host_no, ha));
+			if (!(test_and_set_bit(ABORT_ISP_ACTIVE,
+			    &ha->dpc_flags))) {
+
+				if (qla2x00_abort_isp(ha)) {
+					/* failed. retry later */
+					set_bit(ISP_ABORT_NEEDED,
+					    &ha->dpc_flags);
+				}
+				clear_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags);
+			}
+			DEBUG(printk("scsi(%ld): dpc: qla2x00_abort_isp end\n",
+			    ha->host_no));
+		}
+
+		if (test_and_clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags) &&
+		    (!(test_and_set_bit(RESET_ACTIVE, &ha->dpc_flags)))) {
+
+			DEBUG(printk("scsi(%ld): qla2x00_reset_marker()\n",
+			    ha->host_no));
+
+			qla2x00_rst_aen(ha);
+			clear_bit(RESET_ACTIVE, &ha->dpc_flags);
+		}
+
+		/* Retry each device up to login retry count */
+		if ((test_and_clear_bit(RELOGIN_NEEDED, &ha->dpc_flags)) &&
+		    !test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) &&
+		    atomic_read(&ha->loop_state) != LOOP_DOWN) {
+
+			DEBUG(printk("scsi(%ld): qla2x00_port_login()\n",
+			    ha->host_no));
+
+			next_loopid = 0;
+			list_for_each(fcpl, &ha->fcports) {
+				fcport = list_entry(fcpl, fc_port_t, list);
+				
+				/*
+				 * If the port is not ONLINE then try to login
+				 * to it if we haven't run out of retries.
+				 */
+				if (atomic_read(&fcport->state) != FCS_ONLINE &&
+				    fcport->login_retry) {
+
+					fcport->login_retry--;
+					if (fcport->flags & FCF_FABRIC_DEVICE)
+						status = qla2x00_fabric_login(
+						    ha, fcport, &next_loopid);
+					else 	
+						status =
+						    qla2x00_local_device_login(
+							ha, fcport->loop_id);
+
+					if (status == QLA_SUCCESS) {
+						fcport->old_loop_id = fcport->loop_id;
+
+						DEBUG(printk("scsi(%ld): port login OK: logged in ID 0x%x\n",
+						    ha->host_no, fcport->loop_id));
+						
+						fcport->port_login_retry_count =
+						    ha->port_down_retry_count * PORT_RETRY_TIME;
+						atomic_set(&fcport->state, FCS_ONLINE);
+						atomic_set(&fcport->port_down_timer,
+						    ha->port_down_retry_count * PORT_RETRY_TIME);
+
+						fcport->login_retry = 0;
+					} else if (status == 1) {
+						set_bit(RELOGIN_NEEDED, &ha->dpc_flags);
+						/* retry the login again */
+						DEBUG(printk("scsi(%ld): Retrying %d login again loop_id 0x%x\n",
+						    ha->host_no,
+						    fcport->login_retry, fcport->loop_id));
+					} else {
+						fcport->login_retry = 0;
+					}
+				}
+				if (test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
+					break;
+			}
+			DEBUG(printk("scsi(%ld): qla2x00_port_login - end\n",
+			    ha->host_no));
+		}
+
+		if ((test_bit(LOGIN_RETRY_NEEDED, &ha->dpc_flags)) &&
+		    atomic_read(&ha->loop_state) != LOOP_DOWN) {
+
+			clear_bit(LOGIN_RETRY_NEEDED, &ha->dpc_flags);
+			DEBUG(printk("scsi(%ld): qla2x00_login_retry()\n",
+			    ha->host_no));
+				
+			set_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);
+
+			DEBUG(printk("scsi(%ld): qla2x00_login_retry - end\n",
+			    ha->host_no));
+		}
+
+		if (test_and_clear_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags)) {
+
+			DEBUG(printk("scsi(%ld): qla2x00_loop_resync()\n",
+			    ha->host_no));
+
+			if (!(test_and_set_bit(LOOP_RESYNC_ACTIVE,
+			    &ha->dpc_flags))) {
+
+				qla2x00_loop_resync(ha);
+
+				clear_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags);
+			}
+
+			DEBUG(printk("scsi(%ld): qla2x00_loop_resync - end\n",
+			    ha->host_no));
+		}
+
+		if (test_bit(RESTART_QUEUES_NEEDED, &ha->dpc_flags)) {
+			DEBUG(printk("scsi(%ld): qla2x00_restart_queues()\n",
+			    ha->host_no));
+
+			qla2x00_restart_queues(ha,FALSE);
+
+			DEBUG(printk("scsi(%ld): qla2x00_restart_queues - end\n",
+			    ha->host_no));
+		}
+
+		if (test_bit(ABORT_QUEUES_NEEDED, &ha->dpc_flags)) {
+
+			DEBUG(printk("scsi(%ld): qla2x00_abort_queues()\n",
+			    ha->host_no));
+				
+			qla2x00_abort_queues(ha, FALSE);
+
+			DEBUG(printk("scsi(%ld): qla2x00_abort_queues - end\n",
+			    ha->host_no));
+		}
+
+		if (test_and_clear_bit(FCPORT_RESCAN_NEEDED, &ha->dpc_flags)) {
+
+			DEBUG(printk("scsi(%ld): Rescan flagged fcports...\n",
+			    ha->host_no));
+
+			qla2x00_rescan_fcports(ha);
+
+			DEBUG(printk("scsi(%ld): Rescan flagged fcports..."
+			    "end.\n",
+			    ha->host_no));
+		}
+
+
+		if (!ha->interrupts_on)
+			qla2x00_enable_intrs(ha);
+
+		if (!list_empty(&ha->done_queue))
+			qla2x00_done(ha);
+
+		ha->dpc_active = 0;
+	} /* End of while(1) */
+
+	DEBUG(printk("scsi(%ld): DPC handler exiting\n", ha->host_no));
+
+	/*
+	 * Make sure that nobody tries to wake us up again.
+	 */
+	ha->dpc_wait = NULL;
+	ha->dpc_active = 0;
+
+	complete_and_exit(&ha->dpc_exited, 0);
+}
+
+/*
+ *  qla2x00_abort_queues
+ *	Abort all commands on queues on device
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+void
+qla2x00_abort_queues(scsi_qla_host_t *ha, uint8_t doneqflg) 
+{
+
+	srb_t       *sp;
+	struct list_head *list, *temp;
+	unsigned long flags;
+
+	ENTER(__func__);
+
+	clear_bit(ABORT_QUEUES_NEEDED, &ha->dpc_flags);
+
+	/* Return all commands device queues. */
+	spin_lock_irqsave(&ha->list_lock,flags);
+	list_for_each_safe(list, temp, &ha->pending_queue) {
+		sp = list_entry(list, srb_t, list);
+
+		if (sp->flags & SRB_ABORTED)
+			continue;
+
+		/* Remove srb from LUN queue. */
+		__del_from_pending_queue(ha, sp);
+
+		/* Set ending status. */
+		sp->cmd->result = DID_BUS_BUSY << 16;
+
+		__add_to_done_queue(ha, sp);
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+
+	LEAVE(__func__);
+}
+
+/*
+*  qla2x00_rst_aen
+*      Processes asynchronous reset.
+*
+* Input:
+*      ha  = adapter block pointer.
+*/
+static void
+qla2x00_rst_aen(scsi_qla_host_t *ha) 
+{
+	ENTER(__func__);
+
+	if (ha->flags.online && !ha->flags.reset_active &&
+	    !atomic_read(&ha->loop_down_timer) &&
+	    !(test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags))) {
+
+		/* 10/15 ha->flags.reset_active = TRUE; */
+		do {
+			clear_bit(RESET_MARKER_NEEDED, &ha->dpc_flags);
+
+			/*
+			 * Issue marker command only when we are going to start
+			 * the I/O.
+			 */
+			ha->marker_needed = 1;
+		} while (!atomic_read(&ha->loop_down_timer) &&
+		    (test_bit(RESET_MARKER_NEEDED, &ha->dpc_flags)));
+
+		/* 10/15 ha->flags.reset_active = FALSE; */
+	}
+
+	LEAVE(__func__);
+}
+
+
+/*
+ * This routine will alloacte SP from the free queue
+ * input:
+ *        scsi_qla_host_t *
+ * output:
+ *        srb_t * or NULL
+ */
+srb_t *
+qla2x00_get_new_sp(scsi_qla_host_t *ha)
+{
+	srb_t *sp;
+
+	sp = mempool_alloc(ha->srb_mempool, GFP_KERNEL);
+	if (sp) {
+		atomic_set(&sp->ref_count, 1);
+	}
+	return (sp);
+}
+
+/**************************************************************************
+ * qla2x00_blink_led
+ *
+ * Description:
+ *   This function sets the colour of the LED while preserving the
+ *   unsued GPIO pins every sec.
+ *
+ * Input:
+ *       ha - Host adapter structure
+ *      
+ * Return:
+ * 	None
+ *
+ * Context: qla2x00_timer() Interrupt
+ ***************************************************************************/
+void
+qla2x00_blink_led(scsi_qla_host_t *ha)
+{
+	uint16_t	gpio_enable, gpio_data, led_color;
+	unsigned long	cpu_flags = 0;
+	device_reg_t	*reg = ha->iobase;
+
+	ENTER(__func__);
+
+	/* Save the Original GPIOE */ 
+	spin_lock_irqsave(&ha->hardware_lock, cpu_flags);
+	gpio_enable = RD_REG_WORD(&reg->gpioe);
+	gpio_data = RD_REG_WORD(&reg->gpiod);
+	spin_unlock_irqrestore(&ha->hardware_lock, cpu_flags);
+
+	DEBUG2(printk("%s Original data of gpio_enable_reg=0x%x"
+	    " gpio_data_reg=0x%x\n",
+	    __func__,gpio_enable,gpio_data));
+
+	if (ha->beacon_green_on){
+		led_color = GPIO_LED_GREEN_ON_AMBER_OFF;
+		ha->beacon_green_on = 0;
+	} else {
+		led_color = GPIO_LED_GREEN_OFF_AMBER_OFF;
+		ha->beacon_green_on = 1;
+	}
+
+	/* Set the modified gpio_enable values */
+	gpio_enable |= GPIO_LED_GREEN_ON_AMBER_OFF;
+
+	DEBUG2(printk("%s Before writing enable : gpio_enable_reg=0x%x"
+	    " gpio_data_reg=0x%x led_color=0x%x\n",
+	    __func__, gpio_enable, gpio_data, led_color));
+
+	spin_lock_irqsave(&ha->hardware_lock, cpu_flags);
+	WRT_REG_WORD(&reg->gpioe,gpio_enable);
+	spin_unlock_irqrestore(&ha->hardware_lock, cpu_flags);
+
+	/* Clear out the previously set LED colour */
+	gpio_data &= ~GPIO_LED_GREEN_ON_AMBER_OFF;
+
+	/* Set the new input LED colour to GPIOD */
+	gpio_data |= led_color;
+
+	DEBUG2(printk("%s Before writing data: gpio_enable_reg=0x%x"
+	    " gpio_data_reg=0x%x led_color=0x%x\n",
+	    __func__,gpio_enable,gpio_data,led_color));
+
+	/* Set the modified gpio_data values */
+	spin_lock_irqsave(&ha->hardware_lock, cpu_flags);
+	WRT_REG_WORD(&reg->gpiod,gpio_data);
+	spin_unlock_irqrestore(&ha->hardware_lock, cpu_flags);
+
+	LEAVE(__func__);
+}
+
+/**************************************************************************
+*   qla2x00_timer
+*
+* Description:
+*   One second timer
+*
+* Context: Interrupt
+***************************************************************************/
+static void
+qla2x00_timer(scsi_qla_host_t *ha)
+{
+	int		t,l;
+	unsigned long	cpu_flags = 0;
+	struct list_head	*fcpl;
+	fc_port_t	*fcport;
+	os_lun_t *lq;
+	os_tgt_t *tq;
+	int		start_dpc = 0;
+
+	/*
+	 * We try and restart any request in the retry queue every second.
+	 */
+	if (!list_empty(&ha->retry_queue)) {
+		set_bit(PORT_RESTART_NEEDED, &ha->dpc_flags);
+		start_dpc++;
+	}
+
+	/*
+	 * We try and restart any request in the scsi_retry queue every second.
+	 */
+	if (!list_empty(&ha->scsi_retry_queue)) {
+		set_bit(SCSI_RESTART_NEEDED, &ha->dpc_flags);
+		start_dpc++;
+	}
+
+	/* Check if beacon LED needs to be blinked */
+	if (IS_QLA23XX(ha) && ha->beacon_blink_led)
+		qla2x00_blink_led(ha);
+
+	/*
+	 * Ports - Port down timer.
+	 *
+	 * Whenever, a port is in the LOST state we start decrementing its port
+	 * down timer every second until it reaches zero. Once  it reaches zero
+	 * the port it marked DEAD. 
+	 */
+	t = 0;
+	list_for_each(fcpl, &ha->fcports) {
+		fcport = list_entry(fcpl, fc_port_t, list);
+
+		if (atomic_read(&fcport->state) == FCS_DEVICE_LOST) {
+
+			if (atomic_read(&fcport->port_down_timer) == 0)
+				continue;
+
+			if (atomic_dec_and_test(&fcport->port_down_timer) != 0) 
+				atomic_set(&fcport->state, FCS_DEVICE_DEAD);
+			
+			DEBUG(printk("scsi(%ld): fcport-%d - port retry count: "
+			    "%d remainning\n",
+			    ha->host_no,
+			    t, atomic_read(&fcport->port_down_timer)));
+		}
+		t++;
+	} /* End of for fcport  */
+
+	/*
+	 * LUNS - lun suspend timer.
+	 *
+	 * Whenever, a lun is suspended the timer starts decrementing its
+	 * suspend timer every second until it reaches zero. Once  it reaches
+	 * zero the lun retry count is decremented. 
+	 */
+
+	/*
+	 * FIXME(dg) - Need to convert this linear search of luns into a search
+	 * of a list of suspended luns.
+	 */
+	for (t = 0; t < ha->max_targets; t++) {
+		if ((tq = ha->otgt[t]) == NULL)
+			continue;
+
+		for (l = 0; l < ha->max_luns; l++) {
+			if ((lq = (os_lun_t *) tq->olun[l]) == NULL)
+				continue;
+
+			spin_lock_irqsave(&lq->q_lock, cpu_flags);
+			if (lq->q_state == LUN_STATE_WAIT &&
+				atomic_read(&lq->q_timer) != 0) {
+
+				if (atomic_dec_and_test(&lq->q_timer) != 0) {
+					/*
+					 * A delay should immediately
+					 * transition to a READY state
+					 */
+					if (test_and_clear_bit(LUN_EXEC_DELAYED,
+					    &lq->q_flag)) {
+						lq->q_state = LUN_STATE_READY;
+					}
+					else {
+						lq->q_count++;
+						if (lq->q_count == lq->q_max)
+							lq->q_state =
+							    LUN_STATE_TIMEOUT;
+						else
+							lq->q_state =
+							    LUN_STATE_RUN;
+					}
+				}
+				DEBUG3(printk("scsi(%ld): lun%d - timer %d, "
+				    "count=%d, max=%d, state=%d\n",
+				    ha->host_no,
+				    l,
+				    atomic_read(&lq->q_timer),
+				    lq->q_count, lq->q_max, lq->q_state));
+			}
+			spin_unlock_irqrestore(&lq->q_lock, cpu_flags);
+		} /* End of for luns  */
+	} /* End of for targets  */
+
+	/* Loop down handler. */
+	if (atomic_read(&ha->loop_down_timer) > 0 &&
+	    !(test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags)) && ha->flags.online) {
+
+		/* dg 10/30 if (atomic_read(&ha->loop_down_timer) == LOOP_DOWN_TIME) { */
+		if (atomic_read(&ha->loop_down_timer) ==
+		    ha->loop_down_abort_time) {
+
+			DEBUG(printk("scsi(%ld): Loop Down - aborting the "
+			    "queues before time expire\n",
+			    ha->host_no));
+
+			if (!IS_QLA2100(ha) && ha->link_down_timeout)
+				atomic_set(&ha->loop_state, LOOP_DEAD); 
+
+			set_bit(ABORT_QUEUES_NEEDED, &ha->dpc_flags);
+			start_dpc++;
+		}
+
+		/* if the loop has been down for 4 minutes, reinit adapter */
+		if (atomic_dec_and_test(&ha->loop_down_timer) != 0) {
+			DEBUG(printk("scsi(%ld): Loop down exceed 4 mins - "
+			    "restarting queues.\n",
+			    ha->host_no));
+
+			set_bit(RESTART_QUEUES_NEEDED, &ha->dpc_flags);
+			start_dpc++;
+
+		}
+		DEBUG3(printk("scsi(%ld): Loop Down - seconds remainning %d\n",
+		    ha->host_no,
+		    atomic_read(&ha->loop_down_timer)));
+	}
+
+	/*
+	 * Done Q Handler -- dgFIXME This handler will kick off doneq if we
+	 * haven't process it in 2 seconds.
+	 */
+	if (!list_empty(&ha->done_queue))
+		qla2x00_done(ha);
+
+	/* Schedule the DPC routine if needed */
+	if ((test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) ||
+	    test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags) ||
+	    start_dpc ||
+	    test_bit(LOGIN_RETRY_NEEDED, &ha->dpc_flags) ||
+	    test_bit(RELOGIN_NEEDED, &ha->dpc_flags)) &&
+	    ha->dpc_wait && !ha->dpc_active) {
+
+		up(ha->dpc_wait);
+	}
+
+	qla2x00_restart_timer(ha, WATCH_INTERVAL);
+}
+
+/*
+ * qla2x00_extend_timeout
+ *      This routine will extend the timeout to the specified value.
+ *
+ * Input:
+ *      cmd = SCSI command structure
+ *
+ * Returns:
+ *      None.
+ */
+void 
+qla2x00_extend_timeout(struct scsi_cmnd *cmd, int timeout) 
+{
+	srb_t *sp = (srb_t *) CMD_SP(cmd);
+	u_long our_jiffies = (timeout * HZ) + jiffies;
+
+    	sp->ext_history= 0; 
+	sp->e_start = jiffies;
+	if (cmd->eh_timeout.function) {
+		mod_timer(&cmd->eh_timeout,our_jiffies);
+		sp->ext_history |= 1;
+	}
+	if (sp->timer.function != NULL) {
+		/* 
+		 * Our internal timer should timeout before the midlayer has a
+		 * chance begin the abort process
+		 */
+		mod_timer(&sp->timer,our_jiffies - (QLA_CMD_TIMER_DELTA * HZ));
+
+    	 	sp->ext_history |= 2;
+	}
+}
+
+/**************************************************************************
+*   qla2x00_cmd_timeout
+*
+* Description:
+*       Handles the command if it times out in any state.
+*
+* Input:
+*     sp - pointer to validate
+*
+* Returns:
+* None.
+* Note:Need to add the support for if( sp->state == SRB_FAILOVER_STATE).
+**************************************************************************/
+static void
+qla2x00_cmd_timeout(srb_t *sp)
+{
+	int t, l;
+	int processed;
+	scsi_qla_host_t *vis_ha, *dest_ha;
+	struct scsi_cmnd *cmd;
+	ulong      flags;
+#if defined(QL_DEBUG_LEVEL_3)
+	ulong      cpu_flags;
+#endif
+	fc_port_t	*fcport;
+
+	cmd = sp->cmd;
+	vis_ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+
+	DEBUG3(printk("cmd_timeout: Entering sp->state = %x\n", sp->state));
+
+	t = cmd->device->id;
+	l = cmd->device->lun;
+	fcport = sp->fclun->fcport;
+	dest_ha = sp->ha;
+
+	/*
+	 * If IO is found either in retry Queue 
+	 *    OR in Lun Queue
+	 * Return this IO back to host
+	 */
+	spin_lock_irqsave(&vis_ha->list_lock, flags);
+	processed = 0;
+	if (sp->state == SRB_PENDING_STATE) {
+		__del_from_pending_queue(vis_ha, sp);
+		DEBUG2(printk("scsi(%ld): Found in Pending queue pid %ld, "
+		    "State = %x., fcport state=%d jiffies=%lx\n",
+		    vis_ha->host_no, cmd->serial_number, sp->state,
+		    atomic_read(&fcport->state), jiffies));
+
+		/*
+		 * If FC_DEVICE is marked as dead return the cmd with
+		 * DID_NO_CONNECT status.  Otherwise set the host_byte to
+		 * DID_BUS_BUSY to let the OS  retry this cmd.
+		 */
+		if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||
+		    atomic_read(&vis_ha->loop_state) == LOOP_DEAD) {
+			cmd->result = DID_NO_CONNECT << 16;
+		} else {
+			cmd->result = DID_BUS_BUSY << 16;
+		}
+		__add_to_done_queue(vis_ha, sp);
+		processed++;
+	} 
+	spin_unlock_irqrestore(&vis_ha->list_lock, flags);
+
+	if (processed) {
+		qla2x00_done(vis_ha);
+		return;
+	}
+
+	spin_lock_irqsave(&dest_ha->list_lock, flags);
+	if ((sp->state == SRB_RETRY_STATE) ||
+	    (sp->state == SRB_SCSI_RETRY_STATE)) {
+
+		DEBUG2(printk("scsi(%ld): Found in (Scsi) Retry queue or "
+		    "failover Q pid %ld, State = %x., fcport state=%d "
+		    "jiffies=%lx retried=%d\n",
+		    dest_ha->host_no, cmd->serial_number, sp->state,
+		    atomic_read(&fcport->state), jiffies, cmd->retries));
+
+		if ((sp->state == SRB_RETRY_STATE)) {
+			__del_from_retry_queue(dest_ha, sp);
+		} else if ((sp->state == SRB_SCSI_RETRY_STATE)) {
+			__del_from_scsi_retry_queue(dest_ha, sp);
+		}
+
+		/*
+		 * If FC_DEVICE is marked as dead return the cmd with
+		 * DID_NO_CONNECT status.  Otherwise set the host_byte to
+		 * DID_BUS_BUSY to let the OS  retry this cmd.
+		 */
+
+		if ((atomic_read(&fcport->state) == FCS_DEVICE_DEAD) ||
+		    atomic_read(&dest_ha->loop_state) == LOOP_DEAD) {
+			qla2x00_extend_timeout(cmd, EXTEND_CMD_TIMEOUT);
+			cmd->result = DID_NO_CONNECT << 16;
+		} else {
+			cmd->result = DID_BUS_BUSY << 16;
+		}
+
+		__add_to_done_queue(dest_ha, sp);
+		processed++;
+	} 
+	spin_unlock_irqrestore(&dest_ha->list_lock, flags);
+
+	if (processed) {
+		qla2x00_done(dest_ha);
+
+		 return;
+	}
+/* TODO: Remove this code!!! */
+#if defined(QL_DEBUG_LEVEL_3)
+	spin_lock_irqsave(&dest_ha->list_lock, cpu_flags);
+	if (sp->state == SRB_DONE_STATE) {
+		/* IO in done_q  -- leave it */
+		DEBUG(printk("scsi(%ld): Found in Done queue pid %ld sp=%p.\n",
+		    dest_ha->host_no, cmd->serial_number, sp));
+	} else if (sp->state == SRB_SUSPENDED_STATE) {
+		DEBUG(printk("scsi(%ld): Found SP %p in suspended state  "
+		    "- pid %ld:\n",
+		    dest_ha->host_no, sp, cmd->serial_number));
+		DEBUG(qla2x00_dump_buffer((uint8_t *)sp, sizeof(srb_t));)
+	} else if (sp->state == SRB_ACTIVE_STATE) {
+		/*
+		 * IO is with ISP find the command in our active list.
+		 */
+		spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);
+		spin_lock_irqsave(&dest_ha->hardware_lock, flags);
+		if (sp ==
+		    dest_ha->outstanding_cmds[(u_long)sp->cmd->host_scribble]) {
+
+			DEBUG(printk("cmd_timeout: Found in ISP \n");)
+
+			sp->state = SRB_ACTIVE_TIMEOUT_STATE;
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+		} else {
+			spin_unlock_irqrestore(&dest_ha->hardware_lock, flags);
+			printk(KERN_INFO 
+				"qla_cmd_timeout: State indicates it is with "
+				"ISP, But not in active array\n");
+		}
+		spin_lock_irqsave(&dest_ha->list_lock, cpu_flags); 	/* 01/03 */
+	} else if (sp->state == SRB_ACTIVE_TIMEOUT_STATE) {
+		DEBUG(printk("qla2100%ld: Found in Active timeout state"
+				"pid %ld, State = %x., \n",
+				dest_ha->host_no,
+				sp->cmd->serial_number, sp->state);)
+	} else {
+		/* EMPTY */
+		DEBUG2(printk("cmd_timeout%ld: LOST command state = "
+				"0x%x, sp=%p\n",
+				vis_ha->host_no, sp->state,sp);)
+
+		qla_printk(KERN_INFO, vis_ha,
+			"cmd_timeout: LOST command state = 0x%x\n", sp->state);
+	}
+	spin_unlock_irqrestore(&dest_ha->list_lock, cpu_flags);
+#endif
+	
+	DEBUG3(printk("cmd_timeout: Leaving\n");)
+}
+
+/**************************************************************************
+* qla2x00_done
+*      Process completed commands.
+*
+* Input:
+*      old_ha           = adapter block pointer.
+*
+**************************************************************************/
+void
+qla2x00_done(scsi_qla_host_t *old_ha)
+{
+	os_lun_t	*lq;
+	struct scsi_cmnd *cmd;
+	unsigned long	flags = 0;
+	scsi_qla_host_t	*ha;
+	scsi_qla_host_t	*vis_ha;
+	int	send_marker_once = 0;
+	srb_t           *sp, *sptemp;
+	LIST_HEAD(local_sp_list);
+
+	/*
+	 * Get into local queue such that we do not wind up calling done queue
+	 * tasklet for the same IOs from DPC or any other place.
+	 */
+	spin_lock_irqsave(&old_ha->list_lock, flags);
+	list_splice_init(&old_ha->done_queue, &local_sp_list);
+	spin_unlock_irqrestore(&old_ha->list_lock, flags);
+
+	/*
+	 * All done commands are in the local queue, now do the call back.
+	 */
+	list_for_each_entry_safe(sp, sptemp, &local_sp_list, list) {
+		old_ha->done_q_cnt--;
+        	sp->state = SRB_NO_QUEUE_STATE;
+
+		/* remove command from local list */
+		list_del_init(&sp->list);
+
+		cmd = sp->cmd;
+		if (cmd == NULL)
+		 	continue;
+
+		vis_ha = (scsi_qla_host_t *)cmd->device->host->hostdata;
+		lq = sp->lun_queue;
+		ha = sp->ha;
+
+		if (sp->flags & SRB_DMA_VALID) {
+			sp->flags &= ~SRB_DMA_VALID;
+
+			/* Release memory used for this I/O */
+			if (cmd->use_sg) {
+				pci_unmap_sg(ha->pdev, cmd->request_buffer,
+				    cmd->use_sg, cmd->sc_data_direction);
+			} else if (cmd->request_bufflen) {
+				pci_unmap_page(ha->pdev, sp->dma_handle,
+				    cmd->request_bufflen,
+				    cmd->sc_data_direction);
+			}
+		}
+
+		switch (host_byte(cmd->result)) {
+			case DID_OK:
+			case DID_ERROR:
+				break;
+
+			case DID_RESET:
+				/*
+				 * Set marker needed, so we don't have to
+				 * send multiple markers
+				 */
+				if (!send_marker_once) {
+					ha->marker_needed = 1;
+					send_marker_once++;
+				}
+
+				/*
+				 * WORKAROUND
+				 *
+				 * A backdoor device-reset requires different
+				 * error handling.  This code differentiates
+				 * between normal error handling and the
+				 * backdoor method.
+				 *
+				 */
+				if (ha->host->eh_active != EH_ACTIVE)
+					cmd->result = DID_BUS_BUSY << 16;
+				break;
+
+
+			case DID_ABORT:
+				sp->flags &= ~SRB_ABORT_PENDING;
+				sp->flags |= SRB_ABORTED;
+
+				if (sp->flags & SRB_TIMEOUT)
+					cmd->result = DID_TIME_OUT << 16;
+
+				break;
+
+			default:
+				DEBUG2(printk("scsi(%ld:%d:%d) %s: did_error "
+				    "= %d, comp-scsi= 0x%x-0x%x.\n",
+				    vis_ha->host_no,
+				    cmd->device->id, cmd->device->lun,
+				    __func__,
+				    host_byte(cmd->result),
+				    CMD_COMPL_STATUS(cmd),
+				    CMD_SCSI_STATUS(cmd)));
+				break;
+		}
+
+		/*
+		 * Call the mid-level driver interrupt handler -- via sp_put()
+		 */
+		sp_put(ha, sp);
+	} /* end of while */
+}
+
+/*
+ * qla2x00_process_response_queue_in_zio_mode
+ *	Process response queue completion as fast as possible
+ *	to achieve Zero Interrupt Opertions-ZIO
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Kernel context.
+ */
+static inline void
+qla2x00_process_response_queue_in_zio_mode(scsi_qla_host_t *ha)
+{
+	unsigned long flags;
+
+	/* Check for unprocessed commands in response queue. */
+	if (!ha->flags.process_response_queue)
+		return;
+	if (!ha->flags.online)
+		return;
+	if (ha->response_ring_ptr->signature == RESPONSE_PROCESSED)
+		return;
+	
+	spin_lock_irqsave(&ha->hardware_lock,flags);
+	qla2x00_process_response_queue(ha);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	if (!list_empty(&ha->done_queue))
+		qla2x00_done(ha);
+}
+
+/*
+ * qla2x00_next
+ *	Retrieve and process next job in the LUN queue.
+ *
+ * Input:
+ *	tq = SCSI target queue pointer.
+ *	lq = SCSI LUN queue pointer.
+ *	TGT_LOCK must be already obtained.
+ *
+ * Output:
+ *	Releases TGT_LOCK upon exit.
+ *
+ * Context:
+ *	Kernel/Interrupt context.
+ * 
+ * Note: This routine will always try to start I/O from visible HBA.
+ */
+void
+qla2x00_next(scsi_qla_host_t *vis_ha) 
+{
+	int		rval;
+	unsigned long   flags;
+	scsi_qla_host_t *dest_ha;
+	fc_port_t	*fcport;
+	srb_t           *sp, *sptemp;
+	LIST_HEAD(local_sp_list);
+
+	dest_ha = NULL;
+
+	spin_lock_irqsave(&vis_ha->list_lock, flags);
+	list_splice_init(&vis_ha->pending_queue, &local_sp_list);
+	vis_ha->qthreads = 0;
+	spin_unlock_irqrestore(&vis_ha->list_lock, flags);
+
+	list_for_each_entry_safe(sp, sptemp, &local_sp_list, list) {
+		list_del_init(&sp->list);
+        	sp->state = SRB_NO_QUEUE_STATE;
+
+		fcport = sp->fclun->fcport;
+		dest_ha = fcport->ha;
+
+		/* If device is dead then send request back to OS */
+		if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD) {
+
+			sp->cmd->result = DID_NO_CONNECT << 16;
+
+			if (!atomic_read(&dest_ha->loop_down_timer) &&
+			    atomic_read(&dest_ha->loop_state) == LOOP_DOWN) {
+				sp->err_id = 2;
+			} else {
+				sp->err_id = 1;
+			}
+			DEBUG3(printk("scsi(%ld): loop/port is down - "
+			    "pid=%ld, sp=%p loopid=0x%x queued to dest HBA "
+			    "scsi%ld.\n",
+			    dest_ha->host_no,
+			    sp->cmd->serial_number, sp,
+			    fcport->loop_id, dest_ha->host_no));
+			/* 
+			 * Initiate a failover - done routine will initiate.
+			 */
+			add_to_done_queue(vis_ha, sp);
+
+			continue;
+		}
+
+		/*
+		 * SCSI Kluge: Whenever, we need to wait for an event such as
+		 * loop down (i.e. loop_down_timer ) or port down (i.e.  LUN
+		 * request qeueue is suspended) then we will recycle new
+		 * commands back to the SCSI layer.  We do this because this is
+		 * normally a temporary condition and we don't want the
+		 * mid-level scsi.c driver to get upset and start aborting
+		 * commands.  The timeout value is extracted from the command
+		 * minus 1-second and put on a retry queue (watchdog). Once the
+		 * command timeout it is returned to the mid-level with a BUSY
+		 * status, so the mid-level will retry it. This process
+		 * continues until the LOOP DOWN time expires or the condition
+		 * goes away.
+		 */
+	 	if (!(sp->flags & SRB_IOCTL) &&
+		    (atomic_read(&fcport->state) != FCS_ONLINE ||
+			test_bit(ABORT_ISP_ACTIVE, &dest_ha->dpc_flags) ||
+			atomic_read(&dest_ha->loop_state) != LOOP_READY)) {
+
+			DEBUG3(printk("scsi(%ld): port=(0x%x) retry_q(%d) "
+			    "loop state = %d, loop counter = 0x%x dpc flags "
+			    "= 0x%lx\n",
+			    dest_ha->host_no,
+			    fcport->loop_id,
+			    atomic_read(&fcport->state),
+			    atomic_read(&dest_ha->loop_state),
+			    atomic_read(&dest_ha->loop_down_timer),
+			    dest_ha->dpc_flags));
+
+			qla2x00_extend_timeout(sp->cmd, EXTEND_CMD_TIMEOUT);
+			add_to_retry_queue(vis_ha, sp);
+
+			continue;
+		} 
+
+		/*
+		 * If this request's lun is suspended then put the request on
+		 * the  scsi_retry queue. 
+		 */
+	 	if (!(sp->flags & SRB_IOCTL) &&
+		    sp->lun_queue->q_state == LUN_STATE_WAIT) {
+			DEBUG3(printk("scsi(%ld): lun wait state - pid=%ld, "
+			    "opcode=%d, allowed=%d, retries=%d\n",
+			    dest_ha->host_no,
+			    sp->cmd->serial_number,
+			    sp->cmd->cmnd[0],
+			    sp->cmd->allowed,
+			    sp->cmd->retries));
+				
+			add_to_scsi_retry_queue(vis_ha, sp);
+
+			continue;
+		}
+
+		sp->lun_queue->io_cnt++;
+
+		rval = qla2x00_start_scsi(sp);
+		if (rval != QLA_SUCCESS) {
+			/* Place request back on top of device queue */
+			/* add to the top of queue */
+			add_to_pending_queue_head(vis_ha, sp);
+
+			sp->lun_queue->io_cnt--;
+		}
+	}
+
+	if (IS_QLA23XX(vis_ha)) {
+		/* Process response_queue if ZIO support is enabled*/ 
+		qla2x00_process_response_queue_in_zio_mode(vis_ha);
+
+	}
+}
+
+
+/*
+ * qla2x00_reset_lun_fo_counts
+ *	Reset failover retry counts
+ *
+ * Input:
+ *	ha = adapter block pointer.
+ *
+ * Context:
+ *	Interrupt context.
+ */
+void 
+qla2x00_reset_lun_fo_counts(scsi_qla_host_t *ha, os_lun_t *lq) 
+{
+	srb_t		*tsp;
+	os_lun_t	*orig_lq;
+	struct list_head *list;
+	unsigned long	flags ;
+
+	spin_lock_irqsave(&ha->list_lock, flags);
+	/*
+	 * the pending queue.
+	 */
+	list_for_each(list,&ha->pending_queue) {
+		tsp = list_entry(list, srb_t, list);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+	/*
+	 * the retry queue.
+	 */
+	list_for_each(list,&ha->retry_queue) {
+		tsp = list_entry(list, srb_t, list);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+
+	/*
+	 * the done queue.
+	 */
+	list_for_each(list, &ha->done_queue) {
+		tsp = list_entry(list, srb_t, list);
+		orig_lq = tsp->lun_queue;
+		if (orig_lq == lq)
+			tsp->fo_retry_cnt = 0;
+	}
+	spin_unlock_irqrestore(&ha->list_lock, flags);
+}
+
+/**************************************************************************
+*   qla2x00_check_tgt_status
+*
+* Description:
+*     Checks to see if the target or loop is down.
+*
+* Input:
+*     cmd - pointer to Scsi cmd structure
+*
+* Returns:
+*   1 - if target is present
+*   0 - if target is not present
+*
+**************************************************************************/
+int
+qla2x00_check_tgt_status(scsi_qla_host_t *ha, struct scsi_cmnd *cmd)
+{
+	os_lun_t        *lq;
+	unsigned int	b, t, l;
+	fc_port_t	*fcport;
+
+	/* Generate LU queue on bus, target, LUN */
+	b = cmd->device->channel;
+	t = cmd->device->id;
+	l = cmd->device->lun;
+
+	if ((lq = GET_LU_Q(ha,t,l)) == NULL) {
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	fcport = lq->fclun->fcport;
+
+	if (TGT_Q(ha, t) == NULL ||
+	    l >= ha->max_luns ||
+	    atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||
+	    atomic_read(&ha->loop_state) == LOOP_DEAD ||
+	    (!atomic_read(&ha->loop_down_timer) &&
+		atomic_read(&ha->loop_state) == LOOP_DOWN) ||
+	    test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags) ||
+	    test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) ||
+	    atomic_read(&ha->loop_state) != LOOP_READY) {
+
+		DEBUG(printk(KERN_INFO
+		    "scsi(%ld:%2d:%2d:%2d): %s connection is down\n",
+		    ha->host_no,
+		    b, t, l,
+		    __func__));
+
+		cmd->result = DID_NO_CONNECT << 16;
+		return (QLA_FUNCTION_FAILED);
+	}
+	return (QLA_SUCCESS);
+}
+
+/**************************************************************************
+*   qla2x00_check_port_status
+*
+* Description:
+*     Checks to see if the port or loop is down.
+*
+* Input:
+*     fcport - pointer to fc_port_t structure.
+*
+* Returns:
+*   1 - if port is present
+*   0 - if port is not present
+*
+**************************************************************************/
+int
+qla2x00_check_port_status(scsi_qla_host_t *ha, fc_port_t *fcport)
+{
+	if (fcport == NULL) {
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	if (atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||
+	    atomic_read(&ha->loop_state) == LOOP_DEAD) {
+		return (QLA_FUNCTION_FAILED);
+	}
+
+	if ((atomic_read(&fcport->state) != FCS_ONLINE) || 
+	    (!atomic_read(&ha->loop_down_timer) &&
+		atomic_read(&ha->loop_state) == LOOP_DOWN) ||
+	    (test_bit(ABORT_ISP_ACTIVE, &ha->dpc_flags)) ||
+	    test_bit(CFG_ACTIVE, &ha->cfg_flags) ||
+	    test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) ||
+	    atomic_read(&ha->loop_state) != LOOP_READY) {
+
+		DEBUG(printk(KERN_INFO
+		    "scsi(%ld): Connection is down. fcport=%p.\n",
+		    ha->host_no, fcport));
+
+		return (QLA_BUSY);
+	}
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_module_init - Module initialization.
+ **/
+static int __init
+qla2x00_module_init(void)
+{
+	/* Derive version string. */
+	strcpy(qla2x00_version_str, QLA2XXX_VERSION);
+#if DEBUG_QLA2100
+	strcat(qla2x00_version_str, "-debug");
+#endif
+	/* Allocate cache for SRBs. */
+	sprintf(srb_cachep_name, "qla2xxx_srbs");
+	srb_cachep = kmem_cache_create(srb_cachep_name, sizeof(srb_t), 0,
+	    SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (srb_cachep == NULL) {
+		printk(KERN_ERR
+		    "qla2xxx: Unable to allocate SRB cache...Failing load!\n");
+		return -ENOMEM;
+	}
+
+	printk(KERN_INFO
+	    "QLogic ISP2xxx PCI/PCI-X Fibre Channel HBA Driver (%p)\n",
+	    qla2x00_set_info);
+
+	return 0;
+}
+
+/**
+ * qla2x00_module_exit - Module cleanup.
+ **/
+static void __exit
+qla2x00_module_exit(void)
+{
+	/* Free SRBs cache. */
+	if (srb_cachep != NULL) {
+		if (kmem_cache_destroy(srb_cachep) != 0) {
+			printk(KERN_ERR
+			    "qla2xxx: Unable to free SRB cache...Memory pools "
+			    "still active?\n");
+		}
+		srb_cachep = NULL;
+	}
+}
+
+module_init(qla2x00_module_init);
+module_exit(qla2x00_module_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic ISP2xxx FC-SCSI Host Bus Adapter driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_os.h linux-2.5/drivers/scsi/qla2xxx/qla_os.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_os.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_os.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * Portions (C) Arjan van de Ven <arjanv@redhat.com> for Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+#ifndef __QLA_OS_H
+#define __QLA_OS_H
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/blkdev.h>
+#include <linux/interrupt.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/mempool.h>
+#include <linux/vmalloc.h>
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <linux/smp_lock.h>
+#include <linux/bio.h>
+#include <linux/moduleparam.h>
+#include <linux/capability.h>
+
+#include <asm/system.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/segment.h>
+#include <asm/byteorder.h>
+#include <asm/pgtable.h>
+
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+
+#include "scsi.h"
+#include "hosts.h"
+
+#include <scsi/scsicam.h>
+#include <scsi/scsi_ioctl.h>
+
+//TODO Fix this!!!
+/*
+* String arrays
+*/
+#define LINESIZE    256
+#define MAXARGS      26
+
+/***********************************************************************
+* We use the struct scsi_pointer structure that's included with each 
+* command SCSI_Cmnd as a scratchpad. 
+*
+* SCp is defined as follows:
+*  - SCp.ptr  -- > pointer to the SRB
+*  - SCp.this_residual  -- > HBA completion status for ioctl code. 
+*
+* Cmnd->host_scribble --> Used to hold the hba actived handle (1..255).
+***********************************************************************/
+#define	CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
+#define CMD_COMPL_STATUS(Cmnd)  ((Cmnd)->SCp.this_residual)
+/* Additional fields used by ioctl passthru */
+#define CMD_RESID_LEN(Cmnd)	((Cmnd)->SCp.buffers_residual)
+#define CMD_SCSI_STATUS(Cmnd)	((Cmnd)->SCp.Status)
+#define CMD_ACTUAL_SNSLEN(Cmnd)	((Cmnd)->SCp.Message)
+#define CMD_ENTRY_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
+
+#endif
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_rscn.c linux-2.5/drivers/scsi/qla2xxx/qla_rscn.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_rscn.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_rscn.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,1458 @@
+/*
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+#include "qla_os.h"
+
+#include "qla_def.h"
+
+/**
+ * IO descriptor handle definitions.
+ *
+ * Signature form:
+ *
+ *	|31------28|27-------------------12|11-------0|
+ *	|   Type   |   Rolling Signature   |   Index  |
+ *	|----------|-----------------------|----------|
+ *
+ **/
+
+#define HDL_TYPE_SCSI		0
+#define HDL_TYPE_ASYNC_IOCB	0x0A
+
+#define HDL_INDEX_BITS	12
+#define HDL_ITER_BITS	16
+#define HDL_TYPE_BITS	4
+
+#define HDL_INDEX_MASK	((1UL << HDL_INDEX_BITS) - 1)
+#define HDL_ITER_MASK	((1UL << HDL_ITER_BITS) - 1)
+#define HDL_TYPE_MASK	((1UL << HDL_TYPE_BITS) - 1)
+
+#define HDL_INDEX_SHIFT	0
+#define HDL_ITER_SHIFT	(HDL_INDEX_SHIFT + HDL_INDEX_BITS)
+#define HDL_TYPE_SHIFT	(HDL_ITER_SHIFT + HDL_ITER_BITS)
+
+/* Local Prototypes. */
+static inline uint32_t qla2x00_to_handle(uint16_t, uint16_t, uint16_t);
+static inline uint16_t qla2x00_handle_to_idx(uint32_t);
+static inline uint16_t qla2x00_handle_to_iter(uint32_t);
+static inline uint16_t qla2x00_handle_to_type(uint32_t);
+static inline uint32_t qla2x00_iodesc_to_handle(struct io_descriptor *);
+static inline struct io_descriptor *qla2x00_handle_to_iodesc(scsi_qla_host_t *,
+    uint32_t);
+
+static inline struct io_descriptor *qla2x00_alloc_iodesc(scsi_qla_host_t *);
+static inline void qla2x00_free_iodesc(struct io_descriptor *);
+static inline void qla2x00_init_io_descriptors(scsi_qla_host_t *);
+
+static void qla2x00_iodesc_timeout(unsigned long);
+static inline void qla2x00_add_iodesc_timer(struct io_descriptor *);
+static inline void qla2x00_remove_iodesc_timer(struct io_descriptor *);
+
+static inline void qla2x00_update_login_fcport(scsi_qla_host_t *,
+    struct mbx_entry *, fc_port_t *);
+
+static int qla2x00_send_abort_iocb(scsi_qla_host_t *, struct io_descriptor *,
+    uint32_t, int);
+static int qla2x00_send_abort_iocb_cb(scsi_qla_host_t *, struct io_descriptor *,
+    struct mbx_entry *);
+
+static int qla2x00_send_adisc_iocb(scsi_qla_host_t *, struct io_descriptor *,
+    int);
+static int qla2x00_send_adisc_iocb_cb(scsi_qla_host_t *, struct io_descriptor *,
+    struct mbx_entry *);
+
+static int qla2x00_send_logout_iocb(scsi_qla_host_t *, struct io_descriptor *,
+    int);
+static int qla2x00_send_logout_iocb_cb(scsi_qla_host_t *,
+    struct io_descriptor *, struct mbx_entry *);
+
+static int qla2x00_send_login_iocb(scsi_qla_host_t *, struct io_descriptor *,
+    port_id_t *, int);
+static int qla2x00_send_login_iocb_cb(scsi_qla_host_t *, struct io_descriptor *,
+    struct mbx_entry *);
+
+/** 
+ * Mailbox IOCB callback array.
+ **/
+int (*iocb_function_cb_list[LAST_IOCB_CB])
+	(scsi_qla_host_t *, struct io_descriptor *, struct mbx_entry *) = {
+
+	qla2x00_send_abort_iocb_cb,
+	qla2x00_send_adisc_iocb_cb,
+	qla2x00_send_logout_iocb_cb,
+	qla2x00_send_login_iocb_cb,
+};
+
+
+/** 
+ * Generic IO descriptor handle routines.
+ **/
+
+/**
+ * qla2x00_to_handle() - Create a descriptor handle.
+ * @type: descriptor type
+ * @iter: descriptor rolling signature
+ * @idx: index to the descriptor array
+ *
+ * Returns a composite handle based in the @type, @iter, and @idx.
+ */
+static inline uint32_t
+qla2x00_to_handle(uint16_t type, uint16_t iter, uint16_t idx)
+{
+	return ((uint32_t)(((uint32_t)type << HDL_TYPE_SHIFT) |
+	    ((uint32_t)iter << HDL_ITER_SHIFT) |
+	    ((uint32_t)idx << HDL_INDEX_SHIFT)));
+}
+
+/**
+ * qla2x00_handle_to_idx() - Retrive the index for a given handle.
+ * @handle: descriptor handle
+ *
+ * Returns the index specified by the @handle.
+ */
+static inline uint16_t
+qla2x00_handle_to_idx(uint32_t handle)
+{
+	return ((uint16_t)(((handle) >> HDL_INDEX_SHIFT) & HDL_INDEX_MASK));
+}
+
+/**
+ * qla2x00_handle_to_type() - Retrive the descriptor type for a given handle.
+ * @handle: descriptor handle
+ *
+ * Returns the descriptor type specified by the @handle.
+ */
+static inline uint16_t
+qla2x00_handle_to_type(uint32_t handle)
+{
+	return ((uint16_t)(((handle) >> HDL_TYPE_SHIFT) & HDL_TYPE_MASK));
+}
+
+/**
+ * qla2x00_handle_to_iter() - Retrive the rolling signature for a given handle.
+ * @handle: descriptor handle
+ *
+ * Returns the signature specified by the @handle.
+ */
+static inline uint16_t
+qla2x00_handle_to_iter(uint32_t handle)
+{
+	return ((uint16_t)(((handle) >> HDL_ITER_SHIFT) & HDL_ITER_MASK));
+}
+
+/**
+ * qla2x00_iodesc_to_handle() - Convert an IO descriptor to a unique handle.
+ * @iodesc: io descriptor
+ *
+ * Returns a unique handle for @iodesc.
+ */
+static inline uint32_t
+qla2x00_iodesc_to_handle(struct io_descriptor *iodesc)
+{
+	uint32_t handle;
+
+	handle = qla2x00_to_handle(HDL_TYPE_ASYNC_IOCB,
+	    ++iodesc->ha->iodesc_signature, iodesc->idx);
+	iodesc->signature = handle;
+
+	return (handle);
+}
+
+/**
+ * qla2x00_handle_to_iodesc() - Retrieve an IO descriptor given a unique handle.
+ * @ha: HA context
+ * @handle: handle to io descriptor
+ *
+ * Returns a pointer to the io descriptor, or NULL, if the io descriptor does
+ * not exist or the io descriptors signature does not @handle.
+ */
+static inline struct io_descriptor *
+qla2x00_handle_to_iodesc(scsi_qla_host_t *ha, uint32_t handle)
+{
+	uint16_t idx;
+	struct io_descriptor *iodesc;
+
+	idx = qla2x00_handle_to_idx(handle);
+	iodesc = &ha->io_descriptors[idx];
+	if (iodesc)
+		if (iodesc->signature != handle)
+			iodesc = NULL;
+
+	return (iodesc);
+}
+
+
+/** 
+ * IO descriptor allocation routines.
+ **/
+
+/**
+ * qla2x00_alloc_iodesc() - Allocate an IO descriptor from the pool.
+ * @ha: HA context
+ *
+ * Returns a pointer to the allocated io descriptor, or NULL, if none available.
+ */
+static inline struct io_descriptor *
+qla2x00_alloc_iodesc(scsi_qla_host_t *ha)
+{
+	uint16_t iter;
+	struct io_descriptor *iodesc;
+
+	iodesc = NULL;
+	for (iter = 0; iter < MAX_IO_DESCRIPTORS; iter++) {
+		if (ha->io_descriptors[iter].used)
+			continue;
+
+		iodesc = &ha->io_descriptors[iter];
+		iodesc->used = 1;
+		iodesc->idx = iter;
+		init_timer(&iodesc->timer);
+		iodesc->ha = ha;
+		iodesc->signature = qla2x00_iodesc_to_handle(iodesc);
+		break;
+	}
+
+	return (iodesc);
+}
+
+/**
+ * qla2x00_free_iodesc() - Free an IO descriptor.
+ * @iodesc: io descriptor
+ *
+ * NOTE: The io descriptors timer *must* be stopped before it can be free'd.
+ */
+static inline void
+qla2x00_free_iodesc(struct io_descriptor *iodesc)
+{
+	iodesc->used = 0;
+	iodesc->signature = 0;
+}
+
+/**
+ * qla2x00_init_io_descriptors() - Initialize the pool of IO descriptors.
+ * @ha: HA context
+ */
+static inline void
+qla2x00_init_io_descriptors(scsi_qla_host_t *ha)
+{
+	uint16_t iter;
+
+	for (iter = 0; iter < MAX_IO_DESCRIPTORS; iter++) {
+		if (!ha->io_descriptors[iter].used)
+			continue;
+
+		qla2x00_remove_iodesc_timer(&ha->io_descriptors[iter]);
+		qla2x00_free_iodesc(&ha->io_descriptors[iter]);
+	}
+}
+
+
+/** 
+ * IO descriptor timer routines.
+ **/
+
+/**
+ * qla2x00_iodesc_timeout() - Timeout IO descriptor handler.
+ * @data: io descriptor
+ */
+static void
+qla2x00_iodesc_timeout(unsigned long data)
+{
+	struct io_descriptor *iodesc;
+
+	iodesc = (struct io_descriptor *) data;
+
+	DEBUG14(printk("scsi(%ld): IO descriptor timeout, index=%x "
+	    "signature=%08x, scheduling ISP abort.\n", iodesc->ha->host_no,
+	    iodesc->idx, iodesc->signature));
+
+	qla2x00_free_iodesc(iodesc);
+
+	set_bit(ISP_ABORT_NEEDED, &iodesc->ha->dpc_flags);
+}
+
+/**
+ * qla2x00_add_iodesc_timer() - Add and start a timer for an IO descriptor.
+ * @iodesc: io descriptor
+ *
+ * NOTE:
+ * The firmware shall timeout an outstanding mailbox IOCB in 2 * R_A_TOV (in
+ * tenths of a second).  The driver will wait 2.5 * R_A_TOV before scheduling
+ * a recovery (big hammer).
+ */
+static inline void
+qla2x00_add_iodesc_timer(struct io_descriptor *iodesc)
+{
+	unsigned long timeout;
+
+	timeout = ((iodesc->ha->r_a_tov * 2) + (iodesc->ha->r_a_tov / 2)) / 10;
+	init_timer(&iodesc->timer);
+	iodesc->timer.data = (unsigned long) iodesc;
+	iodesc->timer.expires = jiffies + (timeout * HZ);
+	iodesc->timer.function =
+	    (void (*) (unsigned long)) qla2x00_iodesc_timeout;
+	add_timer(&iodesc->timer);
+}
+
+/**
+ * qla2x00_remove_iodesc_timer() - Remove an active timer from an IO descriptor.
+ * @iodesc: io descriptor
+ */
+static inline void
+qla2x00_remove_iodesc_timer(struct io_descriptor *iodesc)
+{
+	if (iodesc->timer.function != NULL) {
+		del_timer_sync(&iodesc->timer);
+		iodesc->timer.data = (unsigned long) NULL;
+		iodesc->timer.function = NULL;
+	}
+}
+
+/** 
+ * IO descriptor support routines.
+ **/
+
+/**
+ * qla2x00_update_login_fcport() - Update fcport data after login processing.
+ * @ha: HA context
+ * @mbxstat: Mailbox command status IOCB
+ * @fcport: port to update
+ */
+static inline void
+qla2x00_update_login_fcport(scsi_qla_host_t *ha, struct mbx_entry *mbxstat,
+    fc_port_t *fcport)
+{
+	if (le16_to_cpu(mbxstat->mb1) & BIT_0) {
+		fcport->port_type = FCT_INITIATOR;
+	} else {
+		fcport->port_type = FCT_TARGET;
+		if (le16_to_cpu(mbxstat->mb1) & BIT_1) {
+			fcport->flags |= FCF_TAPE_PRESENT;
+		}
+	}
+	fcport->login_retry = 0;
+	fcport->port_login_retry_count = ha->port_down_retry_count *
+	    PORT_RETRY_TIME;
+	atomic_set(&fcport->port_down_timer, ha->port_down_retry_count *
+	    PORT_RETRY_TIME);
+	fcport->flags |= FCF_FABRIC_DEVICE;
+	fcport->flags &= ~FCF_FAILOVER_NEEDED;
+	fcport->iodesc_idx_sent = IODESC_INVALID_INDEX;
+	atomic_set(&fcport->state, FCS_ONLINE);
+}
+
+
+/** 
+ * Mailbox IOCB commands.
+ **/
+
+/**
+ * qla2x00_get_mbx_iocb_entry() - Retrieve an IOCB from the request queue.
+ * @ha: HA context
+ * @handle: handle to io descriptor
+ *
+ * Returns a pointer to the reqest entry, or NULL, if none were available.
+ */
+static inline struct mbx_entry *
+qla2x00_get_mbx_iocb_entry(scsi_qla_host_t *ha, uint32_t handle)
+{
+	uint16_t cnt;
+	device_reg_t *reg;
+	struct mbx_entry *mbxentry;
+
+	reg = ha->iobase;
+	mbxentry = NULL;
+
+	if (ha->req_q_cnt < 3) {
+		cnt = qla2x00_debounce_register(ISP_REQ_Q_OUT(ha, reg));
+		if  (ha->req_ring_index < cnt)
+			ha->req_q_cnt = cnt - ha->req_ring_index;
+		else
+			ha->req_q_cnt = REQUEST_ENTRY_CNT -
+			    (ha->req_ring_index - cnt);
+	}
+	if (ha->req_q_cnt >= 3) {
+		mbxentry = (struct mbx_entry *)ha->request_ring_ptr;
+
+		memset(mbxentry, 0, sizeof(struct mbx_entry));
+		mbxentry->entry_type = MBX_IOCB_TYPE;
+		mbxentry->entry_count = 1;
+		mbxentry->sys_define1 = SOURCE_ASYNC_IOCB;
+		mbxentry->handle = handle;
+	}
+	return (mbxentry);
+}
+
+/**
+ * qla2x00_send_abort_iocb() - Issue an abort IOCB to the firmware.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @handle_to_abort: firmware handle to abort
+ * @ha_locked: is function called with the hardware lock
+ *
+ * Returns QLA_SUCCESS if the IOCB was issued.
+ */
+static int
+qla2x00_send_abort_iocb(scsi_qla_host_t *ha, struct io_descriptor *iodesc, 
+    uint32_t handle_to_abort, int ha_locked)
+{
+	unsigned long flags = 0;
+	struct mbx_entry *mbxentry;
+
+	/* Send marker if required. */
+	if (qla2x00_issue_marker(ha, ha_locked) != QLA_SUCCESS)
+		return (QLA_FUNCTION_FAILED);
+
+	if (!ha_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Build abort mailbox IOCB. */
+	mbxentry = qla2x00_get_mbx_iocb_entry(ha, iodesc->signature);
+	if (mbxentry == NULL) {
+		if (!ha_locked)
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		return (QLA_FUNCTION_FAILED);
+	}
+	mbxentry->mb0 = __constant_cpu_to_le16(MBC_ABORT_COMMAND);
+	mbxentry->mb1 = mbxentry->loop_id.extended =
+	    cpu_to_le16(iodesc->remote_fcport->loop_id);
+	mbxentry->mb2 = LSW(handle_to_abort);
+	mbxentry->mb3 = MSW(handle_to_abort);
+
+	qla2x00_add_iodesc_timer(iodesc);
+
+	/* Issue command to ISP. */
+	qla2x00_isp_cmd(ha);
+
+	if (!ha_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG14(printk("scsi(%ld): Sending Abort IOCB (%08x) to [%x], aborting "
+	    "%08x.\n", ha->host_no, iodesc->signature,
+	    iodesc->remote_fcport->loop_id, handle_to_abort));
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_send_abort_iocb_cb() - Abort IOCB callback.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @mbxstat: mailbox status IOCB
+ *
+ * Returns QLA_SUCCESS if @iodesc can be freed by the caller, else, @iodesc
+ * will be used for a retry.
+ */
+static int
+qla2x00_send_abort_iocb_cb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    struct mbx_entry *mbxstat)
+{
+	DEBUG14(printk("scsi(%ld): Abort IOCB -- sent to [%x/%02x%02x%02x], "
+	    "status=%x mb0=%x.\n", ha->host_no, iodesc->remote_fcport->loop_id,
+	    iodesc->d_id.b.domain, iodesc->d_id.b.area, iodesc->d_id.b.al_pa,
+	    le16_to_cpu(mbxstat->status), le16_to_cpu(mbxstat->mb0)));
+
+	return (QLA_SUCCESS);
+}
+
+
+/**
+ * qla2x00_send_adisc_iocb() - Issue a Get Port Database IOCB to the firmware.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @ha_locked: is function called with the hardware lock
+ *
+ * Returns QLA_SUCCESS if the IOCB was issued.
+ */
+static int
+qla2x00_send_adisc_iocb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    int ha_locked)
+{
+	unsigned long flags = 0;
+	struct mbx_entry *mbxentry;
+
+	/* Send marker if required. */
+	if (qla2x00_issue_marker(ha, ha_locked) != QLA_SUCCESS)
+		return (QLA_FUNCTION_FAILED);
+
+	if (!ha_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Build Get Port Database IOCB. */
+	mbxentry = qla2x00_get_mbx_iocb_entry(ha, iodesc->signature);
+	if (mbxentry == NULL) {
+		if (!ha_locked)
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		return (QLA_FUNCTION_FAILED);
+	}
+	mbxentry->mb0 = __constant_cpu_to_le16(MBC_GET_PORT_DATABASE);
+	mbxentry->mb1 = mbxentry->loop_id.extended =
+	    cpu_to_le16(iodesc->remote_fcport->loop_id);
+	mbxentry->mb2 = cpu_to_le16(MSW(LSD(ha->iodesc_pd_dma)));
+	mbxentry->mb3 = cpu_to_le16(LSW(LSD(ha->iodesc_pd_dma)));
+	mbxentry->mb6 = cpu_to_le16(MSW(MSD(ha->iodesc_pd_dma)));
+	mbxentry->mb7 = cpu_to_le16(LSW(MSD(ha->iodesc_pd_dma)));
+	mbxentry->mb10 = __constant_cpu_to_le16(BIT_0);
+
+	qla2x00_add_iodesc_timer(iodesc);
+
+	/* Issue command to ISP. */
+	qla2x00_isp_cmd(ha);
+
+	if (!ha_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG14(printk("scsi(%ld): Sending Adisc IOCB (%08x) to [%x].\n",
+	    ha->host_no, iodesc->signature, iodesc->remote_fcport->loop_id));
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_send_adisc_iocb_cb() - Get Port Database IOCB callback.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @mbxstat: mailbox status IOCB
+ *
+ * Returns QLA_SUCCESS if @iodesc can be freed by the caller, else, @iodesc
+ * will be used for a retry.
+ */
+static int
+qla2x00_send_adisc_iocb_cb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    struct mbx_entry *mbxstat)
+{
+	fc_port_t *remote_fcport;
+
+	remote_fcport = iodesc->remote_fcport;
+
+	/* Ensure the port IDs are consistent. */
+	if (remote_fcport->d_id.b24 != iodesc->d_id.b24) {
+		DEBUG14(printk("scsi(%ld): Adisc IOCB -- ignoring, remote port "
+		    "id changed from [%02x%02x%02x] to [%02x%02x%02x].\n",
+		    ha->host_no, remote_fcport->d_id.b.domain,
+		    remote_fcport->d_id.b.area, remote_fcport->d_id.b.al_pa,
+		    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+		    iodesc->d_id.b.al_pa));
+
+		return (QLA_SUCCESS);
+	}
+
+	/* Only process the last command. */
+	if (remote_fcport->iodesc_idx_sent != iodesc->idx) {
+		DEBUG14(printk("scsi(%ld): Adisc IOCB -- ignoring, sent to "
+		    "[%02x%02x%02x], expected %x, received %x.\n", ha->host_no,
+		    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+		    iodesc->d_id.b.al_pa, remote_fcport->iodesc_idx_sent,
+		    iodesc->idx));
+
+		return (QLA_SUCCESS);
+	}
+
+	if (le16_to_cpu(mbxstat->status) == CS_COMPLETE) {
+		DEBUG14(printk("scsi(%ld): Adisc IOCB -- marking "
+		    "[%x/%02x%02x%02x] online.\n", ha->host_no,
+		    remote_fcport->loop_id, remote_fcport->d_id.b.domain,
+		    remote_fcport->d_id.b.area, remote_fcport->d_id.b.al_pa));
+
+		atomic_set(&remote_fcport->state, FCS_ONLINE);
+	} else {
+		DEBUG14(printk("scsi(%ld): Adisc IOCB -- marking "
+		    "[%x/%02x%02x%02x] lost, status=%x mb0=%x.\n", ha->host_no,
+		    remote_fcport->loop_id, remote_fcport->d_id.b.domain,
+		    remote_fcport->d_id.b.area, remote_fcport->d_id.b.al_pa,
+		    le16_to_cpu(mbxstat->status), le16_to_cpu(mbxstat->mb0)));
+
+		if (atomic_read(&remote_fcport->state) != FCS_DEVICE_DEAD)
+			atomic_set(&remote_fcport->state, FCS_DEVICE_LOST);
+	}
+	remote_fcport->iodesc_idx_sent = IODESC_INVALID_INDEX;
+
+	return (QLA_SUCCESS);
+}
+
+
+/**
+ * qla2x00_send_logout_iocb() - Issue a fabric port logout IOCB to the firmware.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @ha_locked: is function called with the hardware lock
+ *
+ * Returns QLA_SUCCESS if the IOCB was issued.
+ */
+static int
+qla2x00_send_logout_iocb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    int ha_locked)
+{
+	unsigned long flags = 0;
+	struct mbx_entry *mbxentry;
+
+	/* Send marker if required. */
+	if (qla2x00_issue_marker(ha, ha_locked) != QLA_SUCCESS)
+		return (QLA_FUNCTION_FAILED);
+
+	if (!ha_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Build fabric port logout mailbox IOCB. */
+	mbxentry = qla2x00_get_mbx_iocb_entry(ha, iodesc->signature);
+	if (mbxentry == NULL) {
+		if (!ha_locked)
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		return (QLA_FUNCTION_FAILED);
+	}
+	mbxentry->mb0 = __constant_cpu_to_le16(MBC_LOGOUT_FABRIC_PORT);
+	mbxentry->mb1 = mbxentry->loop_id.extended =
+	    cpu_to_le16(iodesc->remote_fcport->loop_id);
+
+	qla2x00_add_iodesc_timer(iodesc);
+
+	/* Issue command to ISP. */
+	qla2x00_isp_cmd(ha);
+
+	if (!ha_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG14(printk("scsi(%ld): Sending Logout IOCB (%08x) to [%x].\n",
+	    ha->host_no, iodesc->signature, iodesc->remote_fcport->loop_id));
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_send_logout_iocb_cb() - Fabric port logout IOCB callback.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @mbxstat: mailbox status IOCB
+ *
+ * Returns QLA_SUCCESS if @iodesc can be freed by the caller, else, @iodesc
+ * will be used for a retry.
+ */
+static int
+qla2x00_send_logout_iocb_cb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    struct mbx_entry *mbxstat)
+{
+	DEBUG14(printk("scsi(%ld): Logout IOCB -- sent to [%x/%02x%02x%02x], "
+	    "status=%x mb0=%x mb1=%x.\n", ha->host_no,
+	    iodesc->remote_fcport->loop_id,
+	    iodesc->remote_fcport->d_id.b.domain,
+	    iodesc->remote_fcport->d_id.b.area,
+	    iodesc->remote_fcport->d_id.b.al_pa, le16_to_cpu(mbxstat->status),
+	    le16_to_cpu(mbxstat->mb0), le16_to_cpu(mbxstat->mb1)));
+
+	return (QLA_SUCCESS);
+}
+
+
+/**
+ * qla2x00_send_login_iocb() - Issue a fabric port login IOCB to the firmware.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @d_id: port id for device
+ * @ha_locked: is function called with the hardware lock
+ *
+ * Returns QLA_SUCCESS if the IOCB was issued.
+ */
+static int
+qla2x00_send_login_iocb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    port_id_t *d_id, int ha_locked)
+{
+	unsigned long flags = 0;
+	struct mbx_entry *mbxentry;
+
+	/* Send marker if required. */
+	if (qla2x00_issue_marker(ha, ha_locked) != QLA_SUCCESS)
+		return (QLA_FUNCTION_FAILED);
+
+	if (!ha_locked)
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	/* Build fabric port login mailbox IOCB. */
+	mbxentry = qla2x00_get_mbx_iocb_entry(ha, iodesc->signature);
+	if (mbxentry == NULL) {
+		if (!ha_locked)
+			spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+		return (QLA_FUNCTION_FAILED);
+	}
+	mbxentry->mb0 = __constant_cpu_to_le16(MBC_LOGIN_FABRIC_PORT);
+	mbxentry->mb1 = mbxentry->loop_id.extended =
+	    cpu_to_le16(iodesc->remote_fcport->loop_id);
+	mbxentry->mb2 = cpu_to_le16(d_id->b.domain);
+	mbxentry->mb3 = cpu_to_le16(d_id->b.area << 8 | d_id->b.al_pa);
+	mbxentry->mb10 = __constant_cpu_to_le16(BIT_0);
+
+	qla2x00_add_iodesc_timer(iodesc);
+
+	/* Issue command to ISP. */
+	qla2x00_isp_cmd(ha);
+
+	if (!ha_locked)
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	DEBUG14(printk("scsi(%ld): Sending Login IOCB (%08x) to "
+	    "[%x/%02x%02x%02x].\n", ha->host_no, iodesc->signature,
+	    iodesc->remote_fcport->loop_id, d_id->b.domain, d_id->b.area,
+	    d_id->b.al_pa));
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_send_login_iocb_cb() - Fabric port logout IOCB callback.
+ * @ha: HA context
+ * @iodesc: io descriptor
+ * @mbxstat: mailbox status IOCB
+ *
+ * Returns QLA_SUCCESS if @iodesc can be freed by the caller, else, @iodesc
+ * will be used for a retry.
+ */
+static int
+qla2x00_send_login_iocb_cb(scsi_qla_host_t *ha, struct io_descriptor *iodesc,
+    struct mbx_entry *mbxstat)
+{
+	int rval;
+	fc_port_t *fcport, *remote_fcport, *exist_fcport;
+	struct io_descriptor *abort_iodesc, *login_iodesc;
+	uint16_t status, mb[8];
+	uint16_t reuse;
+	uint16_t remote_loopid;
+	port_id_t remote_did, inuse_did;
+
+	remote_fcport = iodesc->remote_fcport;
+
+	/* Only process the last command. */
+	if (remote_fcport->iodesc_idx_sent != iodesc->idx) {
+		DEBUG14(printk("scsi(%ld): Login IOCB -- ignoring, sent to "
+		    "[%02x%02x%02x], expected %x, received %x.\n", 
+		    ha->host_no, iodesc->d_id.b.domain, iodesc->d_id.b.area,
+		    iodesc->d_id.b.al_pa, remote_fcport->iodesc_idx_sent,
+		    iodesc->idx));
+
+		/* Free RSCN fcport resources. */
+		if (remote_fcport->port_type == FCT_RSCN) {
+			DEBUG14(printk("scsi(%ld): Login IOCB -- Freeing RSCN "
+			    "fcport %p [%x/%02x%02x%02x] given ignored Login "
+			    "IOCB.\n", ha->host_no, remote_fcport,
+			    remote_fcport->loop_id,
+			    remote_fcport->d_id.b.domain,
+			    remote_fcport->d_id.b.area,
+			    remote_fcport->d_id.b.al_pa));
+
+			list_del(&remote_fcport->list);
+			kfree(remote_fcport);
+		}
+		return (QLA_SUCCESS);
+	}
+
+	status = le16_to_cpu(mbxstat->status);
+	mb[0] = le16_to_cpu(mbxstat->mb0);
+	mb[1] = le16_to_cpu(mbxstat->mb1);
+	mb[2] = le16_to_cpu(mbxstat->mb2);
+	mb[6] = le16_to_cpu(mbxstat->mb6);
+	mb[7] = le16_to_cpu(mbxstat->mb7);
+
+	/* Good status? */
+	if ((status == CS_COMPLETE || status == CS_COMPLETE_CHKCOND) &&
+	    mb[0] == MBS_COMMAND_COMPLETE) {
+
+		DEBUG14(printk("scsi(%ld): Login IOCB -- status=%x mb1=%x pn="
+		    "%02x%02x%02x%02x%02x%02x%02x%02x.\n", ha->host_no, status,
+		    mb[1], mbxstat->port_name[0], mbxstat->port_name[1], 
+		    mbxstat->port_name[2], mbxstat->port_name[3], 
+		    mbxstat->port_name[4], mbxstat->port_name[5], 
+		    mbxstat->port_name[6], mbxstat->port_name[7]));
+
+		memcpy(remote_fcport->node_name, mbxstat->node_name, WWN_SIZE);
+		memcpy(remote_fcport->port_name, mbxstat->port_name, WWN_SIZE);
+
+		/* Is the device already in our fcports list? */
+		if (remote_fcport->port_type != FCT_RSCN) {
+			DEBUG14(printk("scsi(%ld): Login IOCB -- marking "
+			    "[%x/%02x%02x%02x] online.\n", ha->host_no,
+			    remote_fcport->loop_id,
+			    remote_fcport->d_id.b.domain,
+			    remote_fcport->d_id.b.area,
+			    remote_fcport->d_id.b.al_pa));
+
+			qla2x00_update_login_fcport(ha, mbxstat, remote_fcport);
+
+			return (QLA_SUCCESS);
+		}
+
+		/* Does the RSCN portname already exist in our fcports list? */
+		exist_fcport = NULL;
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (memcmp(remote_fcport->port_name, fcport->port_name,
+			    WWN_SIZE) == 0) {
+				exist_fcport = fcport;
+				break;
+			}
+		}
+		if (exist_fcport != NULL) {
+			DEBUG14(printk("scsi(%ld): Login IOCB -- found RSCN "
+			    "fcport in fcports list [%p].\n", ha->host_no,
+			    exist_fcport));
+
+			/* Abort any ADISC that could have been sent. */
+			if (exist_fcport->iodesc_idx_sent != iodesc->idx &&
+			    exist_fcport->iodesc_idx_sent <
+			    MAX_IO_DESCRIPTORS &&
+			    ha->io_descriptors[exist_fcport->iodesc_idx_sent].
+			    cb_idx == ADISC_PORT_IOCB_CB) {
+
+				abort_iodesc = qla2x00_alloc_iodesc(ha);
+				if (abort_iodesc) {
+					DEBUG14(printk("scsi(%ld): Login IOCB "
+					    "-- issuing abort to outstanding "
+					    "Adisc [%x/%02x%02x%02x].\n",
+					    ha->host_no, remote_fcport->loop_id,
+					    exist_fcport->d_id.b.domain,
+					    exist_fcport->d_id.b.area,
+					    exist_fcport->d_id.b.al_pa));
+
+					abort_iodesc->cb_idx = ABORT_IOCB_CB;
+					abort_iodesc->d_id.b24 =
+					    exist_fcport->d_id.b24;
+					abort_iodesc->remote_fcport =
+					    exist_fcport;
+					exist_fcport->iodesc_idx_sent =
+					    abort_iodesc->idx;
+					qla2x00_send_abort_iocb(ha,
+					    abort_iodesc, ha->io_descriptors[
+					     exist_fcport->iodesc_idx_sent].
+					      signature, 1);
+				} else {
+					DEBUG14(printk("scsi(%ld): Login IOCB "
+					    "-- unable to abort outstanding "
+					    "Adisc [%x/%02x%02x%02x].\n",
+					    ha->host_no, remote_fcport->loop_id,
+					    exist_fcport->d_id.b.domain,
+					    exist_fcport->d_id.b.area,
+					    exist_fcport->d_id.b.al_pa));
+				}
+			}
+
+			/*
+			 * If the existing fcport is waiting to send an ADISC
+			 * or LOGIN, then reuse remote fcport (RSCN) to
+			 * continue waiting.
+			 */
+			reuse = 0;
+			remote_loopid = remote_fcport->loop_id;
+			remote_did.b24 = remote_fcport->d_id.b24;
+			if (exist_fcport->iodesc_idx_sent ==
+			    IODESC_ADISC_NEEDED ||
+			    exist_fcport->iodesc_idx_sent ==
+			    IODESC_LOGIN_NEEDED) {
+				DEBUG14(printk("scsi(%ld): Login IOCB -- "
+				    "existing fcport [%x/%02x%02x%02x] "
+				    "waiting for IO descriptor, reuse RSCN "
+				    "fcport.\n", ha->host_no,
+				    exist_fcport->loop_id,
+				    exist_fcport->d_id.b.domain,
+				    exist_fcport->d_id.b.area,
+				    exist_fcport->d_id.b.al_pa));
+
+				reuse++;
+				remote_fcport->iodesc_idx_sent =
+				    exist_fcport->iodesc_idx_sent;
+				exist_fcport->iodesc_idx_sent =
+				    IODESC_INVALID_INDEX;
+				remote_fcport->loop_id = exist_fcport->loop_id;
+				remote_fcport->d_id.b24 =
+				    exist_fcport->d_id.b24;
+			}
+
+			/* Logout the old loopid. */
+			if (!reuse &&
+			    exist_fcport->loop_id != remote_fcport->loop_id &&
+			    exist_fcport->loop_id != FC_NO_LOOP_ID) {
+				login_iodesc = qla2x00_alloc_iodesc(ha);
+				if (login_iodesc) {
+					DEBUG14(printk("scsi(%ld): Login IOCB "
+					    "-- issuing logout to free old "
+					    "loop id [%x/%02x%02x%02x].\n",
+					    ha->host_no, exist_fcport->loop_id,
+					    exist_fcport->d_id.b.domain,
+					    exist_fcport->d_id.b.area,
+					    exist_fcport->d_id.b.al_pa));
+
+					login_iodesc->cb_idx =
+					    LOGOUT_PORT_IOCB_CB;
+					login_iodesc->d_id.b24 =
+					    exist_fcport->d_id.b24;
+					login_iodesc->remote_fcport =
+					    exist_fcport;
+					exist_fcport->iodesc_idx_sent =
+					    login_iodesc->idx;
+					qla2x00_send_logout_iocb(ha,
+					    login_iodesc, 1);
+				} else {
+					/* Ran out of IO descriptiors. */
+					DEBUG14(printk("scsi(%ld): Login IOCB "
+					    "-- unable to logout to free old "
+					    "loop id [%x/%02x%02x%02x].\n",
+					    ha->host_no, exist_fcport->loop_id,
+					    exist_fcport->d_id.b.domain,
+					    exist_fcport->d_id.b.area,
+					    exist_fcport->d_id.b.al_pa));
+
+					exist_fcport->iodesc_idx_sent =
+					    IODESC_INVALID_INDEX;
+				}
+
+			}
+
+			/* Update existing fcport with remote fcport info. */
+			DEBUG14(printk("scsi(%ld): Login IOCB -- marking "
+			    "existing fcport [%x/%02x%02x%02x] online.\n",
+			    ha->host_no, remote_loopid, remote_did.b.domain,
+			    remote_did.b.area, remote_did.b.al_pa));
+
+			memcpy(exist_fcport->node_name,
+			    remote_fcport->node_name, WWN_SIZE);
+			exist_fcport->loop_id = remote_loopid;
+			exist_fcport->d_id.b24 = remote_did.b24;
+			qla2x00_update_login_fcport(ha, mbxstat, exist_fcport);
+
+			/* Finally, free the remote (RSCN) fcport. */
+			if (!reuse) {
+				DEBUG14(printk("scsi(%ld): Login IOCB -- "
+				    "Freeing RSCN fcport %p "
+				    "[%x/%02x%02x%02x].\n", ha->host_no,
+				    remote_fcport, remote_fcport->loop_id,
+				    remote_fcport->d_id.b.domain,
+				    remote_fcport->d_id.b.area,
+				    remote_fcport->d_id.b.al_pa));
+
+				list_del(&remote_fcport->list);
+				kfree(remote_fcport);
+			}
+
+			return (QLA_SUCCESS);
+		}
+
+		/*
+		 * A new device has been added, move the RSCN fcport to our
+		 * fcports list.
+		 */
+		DEBUG14(printk("scsi(%ld): Login IOCB -- adding RSCN fcport "
+		    "[%x/%02x%02x%02x] to fcports list.\n", ha->host_no,
+		    remote_fcport->loop_id, remote_fcport->d_id.b.domain,
+		    remote_fcport->d_id.b.area, remote_fcport->d_id.b.al_pa));
+
+		list_del(&remote_fcport->list);
+		remote_fcport->flags = (FCF_RLC_SUPPORT | FCF_RESCAN_NEEDED);
+		qla2x00_update_login_fcport(ha, mbxstat, remote_fcport);
+		list_add_tail(&remote_fcport->list, &ha->fcports);
+		set_bit(FCPORT_RESCAN_NEEDED, &ha->dpc_flags);
+	} else {
+		/* Handle login failure. */
+		if (remote_fcport->login_retry != 0) {
+			if (mb[0] == MBS_LOOP_ID_USED) {
+				inuse_did.b.domain = LSB(mb[1]);
+				inuse_did.b.area = MSB(mb[2]);
+				inuse_did.b.al_pa = LSB(mb[2]);
+
+				DEBUG14(printk("scsi(%ld): Login IOCB -- loop "
+				    "id [%x] used by port id [%02x%02x%02x].\n",
+				    ha->host_no, remote_fcport->loop_id,
+				    inuse_did.b.domain, inuse_did.b.area,
+				    inuse_did.b.al_pa));
+
+				if (remote_fcport->d_id.b24 ==
+				    INVALID_PORT_ID) {
+					/*
+					 * Invalid port id means we are trying
+					 * to login to a remote port with just
+					 * a loop id without knowing about the
+					 * port id.  Copy the port id and try
+					 * again.
+					 */
+					remote_fcport->d_id.b24 = inuse_did.b24;
+					iodesc->d_id.b24 = inuse_did.b24;
+				} else {
+					remote_fcport->loop_id++;
+					rval = qla2x00_find_new_loop_id(ha,
+					    remote_fcport);
+					if (rval == QLA_FUNCTION_FAILED) {
+						/* No more loop ids. */
+						return (QLA_SUCCESS);
+					}
+				}
+			} else if (mb[0] == MBS_PORT_ID_USED) {
+				/*
+				 * Device has another loop ID.  The firmware
+				 * group recommends the driver perform an
+				 * implicit login with the specified ID.
+				 */
+				DEBUG14(printk("scsi(%ld): Login IOCB -- port "
+				    "id [%02x%02x%02x] already assigned to "
+				    "loop id [%x].\n", ha->host_no,
+				    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+				    iodesc->d_id.b.al_pa, mb[1]));
+
+				remote_fcport->loop_id = mb[1];
+
+			} else {
+				/* Unable to perform login, try again. */
+				DEBUG14(printk("scsi(%ld): Login IOCB -- "
+				    "failed login [%x/%02x%02x%02x], status=%x "
+				    "mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n",
+				    ha->host_no, remote_fcport->loop_id,
+				    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+				    iodesc->d_id.b.al_pa, status, mb[0], mb[1],
+				    mb[2], mb[6], mb[7]));
+			}
+
+			/* Reissue Login with the same IO descriptor. */
+			iodesc->signature =
+			    qla2x00_iodesc_to_handle(iodesc);
+			iodesc->cb_idx = LOGIN_PORT_IOCB_CB;
+			iodesc->d_id.b24 = remote_fcport->d_id.b24;
+			remote_fcport->iodesc_idx_sent = iodesc->idx;
+			remote_fcport->login_retry--;
+
+			DEBUG14(printk("scsi(%ld): Login IOCB -- retrying "
+			    "login to [%x/%02x%02x%02x] (%d).\n", ha->host_no,
+			    remote_fcport->loop_id,
+			    remote_fcport->d_id.b.domain,
+			    remote_fcport->d_id.b.area,
+			    remote_fcport->d_id.b.al_pa,
+			    remote_fcport->login_retry));
+
+			qla2x00_send_login_iocb(ha, iodesc,
+			    &remote_fcport->d_id, 1);
+
+			return (QLA_FUNCTION_FAILED);
+		} else {
+			/* No more logins, mark device dead. */
+			DEBUG14(printk("scsi(%ld): Login IOCB -- failed "
+			    "login [%x/%02x%02x%02x] after retries, status=%x "
+			    "mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n",
+			    ha->host_no, remote_fcport->loop_id,
+			    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+			    iodesc->d_id.b.al_pa, status, mb[0], mb[1],
+			    mb[2], mb[6], mb[7]));
+
+			atomic_set(&remote_fcport->state, FCS_DEVICE_DEAD);
+			if (remote_fcport->port_type == FCT_RSCN) {
+				DEBUG14(printk("scsi(%ld): Login IOCB -- "
+				    "Freeing dead RSCN fcport %p "
+				    "[%x/%02x%02x%02x].\n", ha->host_no,
+				    remote_fcport, remote_fcport->loop_id,
+				    remote_fcport->d_id.b.domain,
+				    remote_fcport->d_id.b.area,
+				    remote_fcport->d_id.b.al_pa));
+
+				list_del(&remote_fcport->list);
+				kfree(remote_fcport);
+			}
+		}
+	}
+
+	return (QLA_SUCCESS);
+}
+
+
+/** 
+ * IO descriptor processing routines.
+ **/
+
+/**
+ * qla2x00_alloc_rscn_fcport() - Allocate an RSCN type fcport.
+ * @ha: HA context
+ * @flags: allocation flags
+ *
+ * Returns a pointer to the allocated RSCN fcport, or NULL, if none available.
+ */
+fc_port_t *
+qla2x00_alloc_rscn_fcport(scsi_qla_host_t *ha, int flags)
+{
+	fc_port_t *fcport;
+
+	fcport = qla2x00_alloc_fcport(ha, flags);
+	if (fcport == NULL)
+		return (fcport);
+
+	/* Setup RSCN fcport structure. */
+	fcport->port_type = FCT_RSCN;
+
+	return (fcport);
+}
+
+/**
+ * qla2x00_handle_port_rscn() - Handle port RSCN.
+ * @ha: HA context
+ * @rscn_entry: RSCN entry
+ * @fcport: fcport entry to updated
+ *
+ * Returns QLA_SUCCESS if the port RSCN was handled.
+ */
+int
+qla2x00_handle_port_rscn(scsi_qla_host_t *ha, uint32_t rscn_entry,
+    fc_port_t *known_fcport, int ha_locked)
+{
+	int	rval;
+	port_id_t rscn_pid;
+	fc_port_t *fcport, *remote_fcport, *rscn_fcport;
+	struct io_descriptor *iodesc;
+
+	remote_fcport = NULL;
+	rscn_fcport = NULL;
+
+	/* Prepare port id based on incoming entries. */
+	if (known_fcport) {
+		rscn_pid.b24 = known_fcport->d_id.b24;
+		remote_fcport = known_fcport;
+
+		DEBUG14(printk("scsi(%ld): Handle RSCN -- process RSCN for "
+		    "fcport [%02x%02x%02x].\n", ha->host_no,
+		    remote_fcport->d_id.b.domain, remote_fcport->d_id.b.area,
+		    remote_fcport->d_id.b.al_pa));
+	} else {
+		rscn_pid.b.domain = LSB(MSW(rscn_entry));
+		rscn_pid.b.area = MSB(LSW(rscn_entry));
+		rscn_pid.b.al_pa = LSB(LSW(rscn_entry));
+
+		DEBUG14(printk("scsi(%ld): Handle RSCN -- process RSCN for "
+		    "port id [%02x%02x%02x].\n", ha->host_no,
+		    rscn_pid.b.domain, rscn_pid.b.area, rscn_pid.b.al_pa));
+
+		/*
+		 * Search fcport lists for a known entry at the specified port
+		 * ID.
+		 */
+		list_for_each_entry(fcport, &ha->fcports, list) {
+		    if (rscn_pid.b24 == fcport->d_id.b24) {
+			    remote_fcport = fcport;
+			    break;
+		    }
+		}
+		list_for_each_entry(fcport, &ha->rscn_fcports, list) {
+		    if (rscn_pid.b24 == fcport->d_id.b24) {
+			    rscn_fcport = fcport;
+			    break;
+		    }
+		}
+		if (remote_fcport == NULL)
+		    remote_fcport = rscn_fcport;
+	}
+
+	/* 
+	 * If the port is already in our fcport list and online, send an ADISC
+	 * to see if it's still alive.  Issue login if a new fcport or the known
+	 * fcport is currently offline.
+	 */
+	if (remote_fcport) {
+		/*
+		 * No need to send request if the remote fcport is currently
+		 * waiting for an available io descriptor.
+		 */
+		if (known_fcport == NULL &&
+		    (remote_fcport->iodesc_idx_sent == IODESC_ADISC_NEEDED ||
+		    remote_fcport->iodesc_idx_sent == IODESC_LOGIN_NEEDED)) {
+			/*
+			 * If previous waiting io descriptor is an ADISC, then
+			 * the new RSCN may come from a new remote fcport being
+			 * plugged into the same location.
+			 */
+			if (remote_fcport->port_type == FCT_RSCN) {
+			    remote_fcport->iodesc_idx_sent =
+				IODESC_LOGIN_NEEDED;
+			} else if (remote_fcport->iodesc_idx_sent ==
+			    IODESC_ADISC_NEEDED) {
+				fc_port_t *new_fcport;
+
+				remote_fcport->iodesc_idx_sent =
+				    IODESC_INVALID_INDEX;
+
+				/* Create new fcport for later login. */
+				new_fcport = qla2x00_alloc_rscn_fcport(ha,
+				    ha_locked ? GFP_ATOMIC: GFP_KERNEL);
+				if (new_fcport) {
+					DEBUG14(printk("scsi(%ld): Handle RSCN "
+					    "-- creating RSCN fcport %p for "
+					    "future login.\n", ha->host_no,
+					    new_fcport));
+
+					new_fcport->d_id.b24 =
+					    remote_fcport->d_id.b24;
+					new_fcport->iodesc_idx_sent =
+					    IODESC_LOGIN_NEEDED;
+
+					list_add_tail(&new_fcport->list,
+					    &ha->rscn_fcports);
+					set_bit(IODESC_PROCESS_NEEDED,
+					    &ha->dpc_flags);
+				} else {
+					DEBUG14(printk("scsi(%ld): Handle RSCN "
+					    "-- unable to allocate RSCN fcport "
+					    "for future login.\n",
+					    ha->host_no));
+				}
+			}
+			return (QLA_SUCCESS);
+		}
+		
+		/* Send ADISC if the fcport is online */
+		if (atomic_read(&remote_fcport->state) == FCS_ONLINE ||
+		    remote_fcport->iodesc_idx_sent == IODESC_ADISC_NEEDED) {
+
+			atomic_set(&remote_fcport->state, FCS_DEVICE_LOST);
+
+			iodesc = qla2x00_alloc_iodesc(ha);
+			if (iodesc == NULL) {
+				/* Mark fcport for later adisc processing */
+				DEBUG14(printk("scsi(%ld): Handle RSCN -- not "
+				    "enough IO descriptors for Adisc, flag "
+				    "for later processing.\n", ha->host_no));
+
+				remote_fcport->iodesc_idx_sent =
+				    IODESC_ADISC_NEEDED;
+				set_bit(IODESC_PROCESS_NEEDED, &ha->dpc_flags);
+
+				return (QLA_SUCCESS);
+			}
+
+			iodesc->cb_idx = ADISC_PORT_IOCB_CB;
+			iodesc->d_id.b24 = rscn_pid.b24;
+			iodesc->remote_fcport = remote_fcport;
+			remote_fcport->iodesc_idx_sent = iodesc->idx;
+			qla2x00_send_adisc_iocb(ha, iodesc, ha_locked);
+
+			return (QLA_SUCCESS);
+		} else if (remote_fcport->iodesc_idx_sent <
+		    MAX_IO_DESCRIPTORS &&
+		    ha->io_descriptors[remote_fcport->iodesc_idx_sent].cb_idx ==
+		    ADISC_PORT_IOCB_CB) {
+			/*
+			 * Receiving another RSCN while an ADISC is pending,
+			 * abort the IOCB.  Use the same descriptor for the
+			 * abort.
+			 */
+			uint32_t handle_to_abort;
+			
+			iodesc = &ha->io_descriptors[
+				remote_fcport->iodesc_idx_sent];
+			qla2x00_remove_iodesc_timer(iodesc);
+			handle_to_abort = iodesc->signature;
+			iodesc->signature = qla2x00_iodesc_to_handle(iodesc);
+			iodesc->cb_idx = ABORT_IOCB_CB;
+			iodesc->d_id.b24 = remote_fcport->d_id.b24;
+			iodesc->remote_fcport = remote_fcport;
+			remote_fcport->iodesc_idx_sent = iodesc->idx;
+
+			DEBUG14(printk("scsi(%ld): Handle RSCN -- issuing "
+			    "abort to outstanding Adisc [%x/%02x%02x%02x].\n",
+			    ha->host_no, remote_fcport->loop_id,
+			    iodesc->d_id.b.domain, iodesc->d_id.b.area,
+			    iodesc->d_id.b.al_pa));
+
+			qla2x00_send_abort_iocb(ha, iodesc, handle_to_abort,
+			    ha_locked);
+		}
+	}
+
+	/* We need to login to the remote port, find it. */
+	if (known_fcport) {
+		remote_fcport = known_fcport;
+	} else if (rscn_fcport && rscn_fcport->d_id.b24 != INVALID_PORT_ID &&
+	    rscn_fcport->iodesc_idx_sent < MAX_IO_DESCRIPTORS &&
+	    ha->io_descriptors[rscn_fcport->iodesc_idx_sent].cb_idx ==
+	    LOGIN_PORT_IOCB_CB) {
+		/*
+		 * Ignore duplicate RSCN on fcport which has already
+		 * initiated a login IOCB.
+		 */
+		DEBUG14(printk("scsi(%ld): Handle RSCN -- ignoring, login "
+		    "already sent to [%02x%02x%02x].\n", ha->host_no,
+		    rscn_fcport->d_id.b.domain, rscn_fcport->d_id.b.area,
+		    rscn_fcport->d_id.b.al_pa));
+
+		return (QLA_SUCCESS);
+	} else if (rscn_fcport && rscn_fcport->d_id.b24 != INVALID_PORT_ID &&
+	    rscn_fcport != remote_fcport) {
+		/* Reuse same rscn fcport. */
+		DEBUG14(printk("scsi(%ld): Handle RSCN -- reusing RSCN fcport "
+		    "[%02x%02x%02x].\n", ha->host_no,
+		    rscn_fcport->d_id.b.domain, rscn_fcport->d_id.b.area,
+		    rscn_fcport->d_id.b.al_pa));
+
+		remote_fcport = rscn_fcport;
+	} else {
+		/* Create new fcport for later login. */
+		remote_fcport = qla2x00_alloc_rscn_fcport(ha,
+		    ha_locked ? GFP_ATOMIC: GFP_KERNEL);
+		list_add_tail(&remote_fcport->list, &ha->rscn_fcports);
+	}
+	if (remote_fcport == NULL)
+		return (QLA_SUCCESS);
+
+	/* Prepare fcport for login. */
+	atomic_set(&remote_fcport->state, FCS_DEVICE_LOST);
+	remote_fcport->login_retry = 3; /* ha->login_retry_count; */
+	remote_fcport->d_id.b24 = rscn_pid.b24;
+
+	iodesc = qla2x00_alloc_iodesc(ha);
+	if (iodesc == NULL) {
+		/* Mark fcport for later adisc processing. */
+		DEBUG14(printk("scsi(%ld): Handle RSCN -- not enough IO "
+		    "descriptors for Login, flag for later processing.\n",
+		    ha->host_no));
+
+		remote_fcport->iodesc_idx_sent = IODESC_LOGIN_NEEDED;
+		set_bit(IODESC_PROCESS_NEEDED, &ha->dpc_flags);
+
+		return (QLA_SUCCESS);
+	}
+
+	if (known_fcport == NULL || rscn_pid.b24 != INVALID_PORT_ID) {
+		remote_fcport->loop_id = ha->min_external_loopid;
+
+		rval = qla2x00_find_new_loop_id(ha, remote_fcport);
+		if (rval == QLA_FUNCTION_FAILED) {
+			/* No more loop ids, failed. */
+			DEBUG14(printk("scsi(%ld): Handle RSCN -- no available "
+			    "loop id to perform Login, failed.\n",
+			    ha->host_no));
+
+			return (rval);
+		}
+	}
+
+	iodesc->cb_idx = LOGIN_PORT_IOCB_CB;
+	iodesc->d_id.b24 = rscn_pid.b24;
+	iodesc->remote_fcport = remote_fcport;
+	remote_fcport->iodesc_idx_sent = iodesc->idx;
+
+	DEBUG14(printk("scsi(%ld): Handle RSCN -- attempting login to "
+	    "[%x/%02x%02x%02x].\n", ha->host_no, remote_fcport->loop_id,
+	    iodesc->d_id.b.domain, iodesc->d_id.b.area, iodesc->d_id.b.al_pa));
+
+	qla2x00_send_login_iocb(ha, iodesc, &rscn_pid, ha_locked);
+
+	return (QLA_SUCCESS);
+}
+
+/**
+ * qla2x00_process_iodesc() - Complete IO descriptor processing.
+ * @ha: HA context
+ * @mbxstat: Mailbox IOCB status
+ */
+void
+qla2x00_process_iodesc(scsi_qla_host_t *ha, struct mbx_entry *mbxstat)
+{
+	int rval;
+	uint32_t signature;
+	fc_port_t *fcport;
+	struct io_descriptor *iodesc;
+
+	signature = mbxstat->handle;
+
+	DEBUG14(printk("scsi(%ld): Process IODesc -- processing %08x.\n",
+	    ha->host_no, signature));
+
+	/* Retrieve proper IO descriptor. */
+	iodesc = qla2x00_handle_to_iodesc(ha, signature);
+	if (iodesc == NULL) {
+		DEBUG14(printk("scsi(%ld): Process IODesc -- ignoring, "
+		    "incorrect signature %08x.\n", ha->host_no, signature));
+
+		return;
+	}
+
+	/* Stop IO descriptor timer. */
+	qla2x00_remove_iodesc_timer(iodesc);
+
+	/* Verify signature match. */
+	if (iodesc->signature != signature) {
+		DEBUG14(printk("scsi(%ld): Process IODesc -- ignoring, "
+		    "signature mismatch, sent %08x, received %08x.\n",
+		    ha->host_no, iodesc->signature, signature));
+
+		return;
+	}
+
+	/* Go with IOCB callback. */
+	rval = iocb_function_cb_list[iodesc->cb_idx](ha, iodesc, mbxstat);
+	if (rval != QLA_SUCCESS) {
+		/* IO descriptor reused by callback. */
+		return;
+	}
+
+	qla2x00_free_iodesc(iodesc);
+
+	if (test_bit(IODESC_PROCESS_NEEDED, &ha->dpc_flags)) {
+		/* Scan our fcports list for any RSCN requests. */
+		list_for_each_entry(fcport, &ha->fcports, list) {
+			if (fcport->iodesc_idx_sent == IODESC_ADISC_NEEDED ||
+			    fcport->iodesc_idx_sent == IODESC_LOGIN_NEEDED) {
+				qla2x00_handle_port_rscn(ha, 0, fcport, 1);
+				return;
+			}
+		}
+
+		/* Scan our RSCN fcports list for any RSCN requests. */
+		list_for_each_entry(fcport, &ha->rscn_fcports, list) {
+			if (fcport->iodesc_idx_sent == IODESC_ADISC_NEEDED ||
+			    fcport->iodesc_idx_sent == IODESC_LOGIN_NEEDED) {
+				qla2x00_handle_port_rscn(ha, 0, fcport, 1);
+				return;
+			}
+		}
+	}
+	clear_bit(IODESC_PROCESS_NEEDED, &ha->dpc_flags);
+}
+
+/**
+ * qla2x00_cancel_io_descriptors() - Cancel all outstanding io descriptors.
+ * @ha: HA context
+ *
+ * This routine will also delete any RSCN entries related to the outstanding
+ * IO descriptors.
+ */
+void
+qla2x00_cancel_io_descriptors(scsi_qla_host_t *ha)
+{
+	fc_port_t *fcport, *fcptemp;
+
+	clear_bit(IODESC_PROCESS_NEEDED, &ha->dpc_flags);
+
+	/* Abort all IO descriptors. */
+	qla2x00_init_io_descriptors(ha);
+
+	/* Reset all pending IO descriptors in fcports list. */
+	list_for_each_entry(fcport, &ha->fcports, list) {
+		fcport->iodesc_idx_sent = IODESC_INVALID_INDEX;
+	}
+
+	/* Reset all pending IO descriptors in rscn fcports list. */
+	list_for_each_entry_safe(fcport, fcptemp, &ha->rscn_fcports, list) {
+		DEBUG14(printk("scsi(%ld): Cancel IOs -- Freeing RSCN fcport "
+		    "%p [%x/%02x%02x%02x].\n", ha->host_no, fcport,
+		    fcport->loop_id, fcport->d_id.b.domain, fcport->d_id.b.area,
+		    fcport->d_id.b.al_pa));
+
+		list_del(&fcport->list);
+		kfree(fcport);
+	}
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_settings.h linux-2.5/drivers/scsi/qla2xxx/qla_settings.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_settings.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_settings.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,66 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * Compile time Options:
+ *     0 - Disable and 1 - Enable
+ */
+#define DEBUG_QLA2100		0	/* For Debug of qla2x00 */
+
+#define MEMORY_MAPPED_IO	1
+#define STOP_ON_ERROR		0	/* Stop on aborts and resets  */
+#define STOP_ON_RESET		0
+#define USE_ABORT_TGT		1	/* Use Abort Target mbx cmd */
+
+#define VSA			0	/* Volume Set Addressing */
+
+/* Failover options */
+#define MAX_RECOVERYTIME	10	/*
+					 * Max suspend time for a lun recovery
+					 * time
+					 */
+#define MAX_FAILBACKTIME	5	/* Max suspend time before fail back */
+
+#define QLA_CMD_TIMER_DELTA	3
+
+/* 
+ * When a lun is suspended for the "Not Ready" condition then it will suspend
+ * the lun for increments of 6 sec delays.  SUSPEND_COUNT is that count.
+ */
+#define SUSPEND_COUNT		10	/* 6 secs * 10 retries = 60 secs */
+
+/*
+ * Defines the time in seconds that the driver extends the command timeout to
+ * get around the problem where the mid-layer only allows 5 retries for
+ * commands that return BUS_BUSY
+ */
+#define EXTEND_CMD_TIMEOUT	60
+
+#define MAX_RETRIES_OF_ISP_ABORT	5
+
+/* Max time to wait for the loop to be in LOOP_READY state */
+#define MAX_LOOP_TIMEOUT	(60 * 5)
+#define EH_ACTIVE		1	/* Error handler active */
+
+/*
+ * Some vendor subsystems do not recover properly after a device reset.  Define
+ * the following to force a logout after a successful device reset.
+ */
+#undef LOGOUT_AFTER_DEVICE_RESET
+
+#include "qla_version.h"
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_sup.c linux-2.5/drivers/scsi/qla2xxx/qla_sup.c
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_sup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_sup.c	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,680 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+
+#include "qla_os.h"
+#include "qla_def.h"
+
+static uint16_t qla2x00_nvram_request(scsi_qla_host_t *, uint32_t);
+static void qla2x00_nv_deselect(scsi_qla_host_t *);
+static void qla2x00_nv_write(scsi_qla_host_t *, uint16_t);
+
+uint8_t qla2x00_read_flash_byte(scsi_qla_host_t *, uint32_t);
+static void qla2x00_write_flash_byte(scsi_qla_host_t *, uint32_t, uint8_t);
+static uint8_t qla2x00_poll_flash(scsi_qla_host_t *ha,
+		uint32_t addr, uint8_t poll_data, uint8_t mid);
+static uint8_t qla2x00_program_flash_address(scsi_qla_host_t *ha,
+		uint32_t addr, uint8_t data, uint8_t mid);
+static uint8_t qla2x00_erase_flash_sector(scsi_qla_host_t *ha,
+		uint32_t addr, uint32_t sec_mask, uint8_t mid);
+
+uint8_t qla2x00_get_flash_manufacturer(scsi_qla_host_t *ha);
+uint16_t qla2x00_get_flash_version(scsi_qla_host_t *);
+uint16_t qla2x00_get_flash_image(scsi_qla_host_t *ha, uint8_t *image);
+uint16_t qla2x00_set_flash_image(scsi_qla_host_t *ha, uint8_t *image);
+
+
+/*
+ * NVRAM support routines
+ */
+
+/**
+ * qla2x00_lock_nvram_access() - 
+ * @ha: HA context
+ */
+void
+qla2x00_lock_nvram_access(scsi_qla_host_t *ha)
+{
+	uint16_t data;
+	device_reg_t *reg;
+
+	reg = ha->iobase;
+
+	if (IS_QLA2312(ha) || IS_QLA2322(ha)) {
+		data = RD_REG_WORD(&reg->nvram);
+		while (data & NVR_BUSY) {
+			udelay(100);
+			data = RD_REG_WORD(&reg->nvram);
+		}
+
+		/* Lock resource */
+		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
+		udelay(5);
+		data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
+		while ((data & BIT_0) == 0) {
+			/* Lock failed */
+			udelay(100);
+			WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);
+			udelay(5);
+			data = RD_REG_WORD(&reg->u.isp2300.host_semaphore);
+		}
+	}
+}
+
+/**
+ * qla2x00_unlock_nvram_access() - 
+ * @ha: HA context
+ */
+void
+qla2x00_unlock_nvram_access(scsi_qla_host_t *ha)
+{
+	device_reg_t *reg;
+
+	reg = ha->iobase;
+
+	if (IS_QLA2312(ha) || IS_QLA2322(ha)) 
+		WRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0);
+}
+
+/**
+ * qla2x00_get_nvram_word() - Calculates word position in NVRAM and calls the
+ *	request routine to get the word from NVRAM.
+ * @ha: HA context
+ * @addr: Address in NVRAM to read
+ *
+ * Returns the word read from nvram @addr.
+ */
+uint16_t
+qla2x00_get_nvram_word(scsi_qla_host_t *ha, uint32_t addr)
+{
+	uint16_t	data;
+	uint32_t	nv_cmd;
+
+	nv_cmd = addr << 16;
+	nv_cmd |= NV_READ_OP;
+	data = qla2x00_nvram_request(ha, nv_cmd);
+
+	return (data);
+}
+
+/**
+ * qla2x00_write_nvram_word() - Write NVRAM data.
+ * @ha: HA context
+ * @addr: Address in NVRAM to write
+ * @data: word to program
+ */
+void
+qla2x00_write_nvram_word(scsi_qla_host_t *ha, uint32_t addr, uint16_t data)
+{
+	int count;
+	uint16_t word;
+	uint32_t nv_cmd;
+	device_reg_t *reg = ha->iobase;
+
+	qla2x00_nv_write(ha, NVR_DATA_OUT);
+	qla2x00_nv_write(ha, 0);
+	qla2x00_nv_write(ha, 0);
+
+	for (word = 0; word < 8; word++)
+		qla2x00_nv_write(ha, NVR_DATA_OUT);
+
+	qla2x00_nv_deselect(ha);
+
+	/* Erase Location */
+	nv_cmd = (addr << 16) | NV_ERASE_OP;
+	nv_cmd <<= 5;
+	for (count = 0; count < 11; count++) {
+		if (nv_cmd & BIT_31)
+			qla2x00_nv_write(ha, NVR_DATA_OUT);
+		else
+			qla2x00_nv_write(ha, 0);
+
+		nv_cmd <<= 1;
+	}
+
+	qla2x00_nv_deselect(ha);
+
+	/* Wait for Erase to Finish */
+	WRT_REG_WORD(&reg->nvram, NVR_SELECT);
+	do {
+		NVRAM_DELAY();
+		word = RD_REG_WORD(&reg->nvram);
+	} while ((word & NVR_DATA_IN) == 0);
+
+	qla2x00_nv_deselect(ha);
+
+	/* Write data */
+	nv_cmd = (addr << 16) | NV_WRITE_OP;
+	nv_cmd |= data;
+	nv_cmd <<= 5;
+	for (count = 0; count < 27; count++) {
+		if (nv_cmd & BIT_31)
+			qla2x00_nv_write(ha, NVR_DATA_OUT);
+		else
+			qla2x00_nv_write(ha, 0);
+
+		nv_cmd <<= 1;
+	}
+
+	qla2x00_nv_deselect(ha);
+
+	/* Wait for NVRAM to become ready */
+	WRT_REG_WORD(&reg->nvram, NVR_SELECT);
+	do {
+		NVRAM_DELAY();
+		word = RD_REG_WORD(&reg->nvram);
+	} while ((word & NVR_DATA_IN) == 0);
+
+	qla2x00_nv_deselect(ha);
+
+	/* Disable writes */
+	qla2x00_nv_write(ha, NVR_DATA_OUT);
+	for (count = 0; count < 10; count++)
+		qla2x00_nv_write(ha, 0);
+
+	qla2x00_nv_deselect(ha);
+}
+
+/**
+ * qla2x00_nvram_request() - Sends read command to NVRAM and gets data from
+ *	NVRAM.
+ * @ha: HA context
+ * @nv_cmd: NVRAM command
+ *
+ * Bit definitions for NVRAM command:
+ *
+ *	Bit 26     = start bit
+ *	Bit 25, 24 = opcode
+ *	Bit 23-16  = address
+ *	Bit 15-0   = write data
+ *
+ * Returns the word read from nvram @addr.
+ */
+static uint16_t
+qla2x00_nvram_request(scsi_qla_host_t *ha, uint32_t nv_cmd)
+{
+	uint8_t		cnt;
+	device_reg_t	*reg = ha->iobase;
+	uint16_t	data = 0;
+	uint16_t	reg_data;
+
+	/* Send command to NVRAM. */
+	nv_cmd <<= 5;
+	for (cnt = 0; cnt < 11; cnt++) {
+		if (nv_cmd & BIT_31)
+			qla2x00_nv_write(ha, NVR_DATA_OUT);
+		else
+			qla2x00_nv_write(ha, 0);
+		nv_cmd <<= 1;
+	}
+
+	/* Read data from NVRAM. */
+	for (cnt = 0; cnt < 16; cnt++) {
+		WRT_REG_WORD(&reg->nvram, NVR_SELECT | NVR_CLOCK);
+		NVRAM_DELAY();
+		data <<= 1;
+		reg_data = RD_REG_WORD(&reg->nvram);
+		if (reg_data & NVR_DATA_IN)
+			data |= BIT_0;
+		WRT_REG_WORD(&reg->nvram, NVR_SELECT);
+		NVRAM_DELAY();
+		RD_REG_WORD(&reg->nvram);	/* PCI Posting. */
+	}
+
+	/* Deselect chip. */
+	WRT_REG_WORD(&reg->nvram, NVR_DESELECT);
+	NVRAM_DELAY();
+	RD_REG_WORD(&reg->nvram);		/* PCI Posting. */
+
+	return (data);
+}
+
+/**
+ * qla2x00_nv_write() - Clean NVRAM operations.
+ * @ha: HA context
+ */
+void
+qla2x00_nv_deselect(scsi_qla_host_t *ha)
+{
+	device_reg_t *reg = ha->iobase;
+
+	WRT_REG_WORD(&reg->nvram, NVR_DESELECT);
+	NVRAM_DELAY();
+	RD_REG_WORD(&reg->nvram);		/* PCI Posting. */
+}
+
+/**
+ * qla2x00_nv_write() - Prepare for NVRAM read/write operation.
+ * @ha: HA context
+ * @data: Serial interface selector
+ */
+void
+qla2x00_nv_write(scsi_qla_host_t *ha, uint16_t data)
+{
+	device_reg_t *reg = ha->iobase;
+
+	WRT_REG_WORD(&reg->nvram, data | NVR_SELECT);
+	NVRAM_DELAY();
+	RD_REG_WORD(&reg->nvram);		/* PCI Posting. */
+	WRT_REG_WORD(&reg->nvram, data | NVR_SELECT | NVR_CLOCK);
+	NVRAM_DELAY();
+	RD_REG_WORD(&reg->nvram);		/* PCI Posting. */
+	WRT_REG_WORD(&reg->nvram, data | NVR_SELECT);
+	NVRAM_DELAY();
+	RD_REG_WORD(&reg->nvram);		/* PCI Posting. */
+}
+
+/*
+ * Flash support routines
+ */
+
+/**
+ * qla2x00_flash_enable() - Setup flash for reading and writing.
+ * @ha: HA context
+ */
+void
+qla2x00_flash_enable(scsi_qla_host_t *ha)
+{
+	uint16_t	data;
+	device_reg_t	*reg = ha->iobase;
+
+	data = RD_REG_WORD(&reg->ctrl_status);
+	data |= CSR_FLASH_ENABLE;
+	WRT_REG_WORD(&reg->ctrl_status, data);
+}
+
+/**
+ * qla2x00_flash_disable() - Disable flash and allow RISC to run.
+ * @ha: HA context
+ */
+void
+qla2x00_flash_disable(scsi_qla_host_t *ha)
+{
+	uint16_t	data;
+	device_reg_t	*reg = ha->iobase;
+
+	data = RD_REG_WORD(&reg->ctrl_status);
+	data &= ~(CSR_FLASH_ENABLE);
+	WRT_REG_WORD(&reg->ctrl_status, data);
+}
+
+/**
+ * qla2x00_read_flash_byte() - Reads a byte from flash
+ * @ha: HA context
+ * @addr: Address in flash to read
+ *
+ * A word is read from the chip, but, only the lower byte is valid.
+ *
+ * Returns the byte read from flash @addr.
+ */
+uint8_t
+qla2x00_read_flash_byte(scsi_qla_host_t *ha, uint32_t addr)
+{
+	uint16_t	data;
+	uint16_t	bank_select;
+	device_reg_t	*reg = ha->iobase;
+
+	/* Setup bit 16 of flash address. */
+	bank_select = RD_REG_WORD(&reg->ctrl_status);
+	if ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {
+		bank_select |= CSR_FLASH_64K_BANK;
+		WRT_REG_WORD(&reg->ctrl_status, bank_select);
+	} else if (((addr & BIT_16) == 0) &&
+	    (bank_select & CSR_FLASH_64K_BANK)) {
+		bank_select &= ~(CSR_FLASH_64K_BANK);
+		WRT_REG_WORD(&reg->ctrl_status, bank_select);
+	}
+	WRT_REG_WORD(&reg->flash_address, (uint16_t)addr);
+	data = qla2x00_debounce_register(&reg->flash_data);
+
+	return ((uint8_t)data);
+}
+
+/**
+ * qla2x00_write_flash_byte() - Write a byte to flash
+ * @ha: HA context
+ * @addr: Address in flash to write
+ * @data: Data to write
+ */
+static void
+qla2x00_write_flash_byte(scsi_qla_host_t *ha, uint32_t addr, uint8_t data)
+{
+	uint16_t	bank_select;
+	device_reg_t	*reg = ha->iobase;
+
+	/* Setup bit 16 of flash address. */
+	bank_select = RD_REG_WORD(&reg->ctrl_status);
+	if ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {
+		bank_select |= CSR_FLASH_64K_BANK;
+		WRT_REG_WORD(&reg->ctrl_status, bank_select);
+	} else if (((addr & BIT_16) == 0) &&
+	    (bank_select & CSR_FLASH_64K_BANK)) {
+		bank_select &= ~(CSR_FLASH_64K_BANK);
+		WRT_REG_WORD(&reg->ctrl_status, bank_select);
+	}
+	WRT_REG_WORD(&reg->flash_address, (uint16_t)addr);
+	WRT_REG_WORD(&reg->flash_data, (uint16_t)data);
+}
+
+/**
+ * qla2x00_poll_flash() - Polls flash for completion.
+ * @ha: HA context
+ * @addr: Address in flash to poll
+ * @poll_data: Data to be polled
+ * @mid: Flash manufacturer ID
+ *
+ * This function polls the device until bit 7 of what is read matches data
+ * bit 7 or until data bit 5 becomes a 1.  If that hapens, the flash ROM timed
+ * out (a fatal error).  The flash book recommeds reading bit 7 again after
+ * reading bit 5 as a 1.
+ *
+ * Returns 0 on success, else non-zero.
+ */
+static uint8_t
+qla2x00_poll_flash(scsi_qla_host_t *ha,
+    uint32_t addr, uint8_t poll_data, uint8_t mid)
+{
+	uint8_t		status;
+	uint8_t		flash_data;
+	uint32_t	cnt;
+	int		failed_pass;
+
+	status = 1;
+	failed_pass = 1;
+
+	/* Wait for 30 seconds for command to finish. */
+	poll_data &= BIT_7;
+	for (cnt = 3000000; cnt; cnt--) {
+		flash_data = qla2x00_read_flash_byte(ha, addr);
+		if ((flash_data & BIT_7) == poll_data) {
+			status = 0;
+			break;
+		}
+
+		if (mid != 0x40 && mid != 0xda) {
+			if (flash_data & BIT_5)
+				failed_pass--;
+			if (failed_pass < 0)
+				break;
+		}
+		udelay(10);
+		barrier();
+	}
+	return (status);
+}
+
+/**
+ * qla2x00_program_flash_address() - Programs a flash address
+ * @ha: HA context
+ * @addr: Address in flash to program
+ * @data: Data to be written in flash
+ * @mid: Flash manufacturer ID
+ *
+ * Returns 0 on success, else non-zero.
+ */
+static uint8_t
+qla2x00_program_flash_address(scsi_qla_host_t *ha,
+    uint32_t addr, uint8_t data, uint8_t mid)
+{
+	/* Write Program Command Sequence */
+	qla2x00_write_flash_byte(ha, 0x5555, 0xaa);
+	qla2x00_write_flash_byte(ha, 0x2aaa, 0x55);
+	qla2x00_write_flash_byte(ha, 0x5555, 0xa0);
+	qla2x00_write_flash_byte(ha, addr, data);
+
+	/* Wait for write to complete. */
+	return (qla2x00_poll_flash(ha, addr, data, mid));
+}
+
+/**
+ * qla2x00_erase_flash_sector() - Erase a flash sector.
+ * @ha: HA context
+ * @addr: Flash sector to erase
+ * @sec_mask: Sector address mask
+ * @mid: Flash manufacturer ID
+ *
+ * Returns 0 on success, else non-zero.
+ */
+static uint8_t
+qla2x00_erase_flash_sector(scsi_qla_host_t *ha,
+    uint32_t addr, uint32_t sec_mask, uint8_t mid)
+{
+	/* Individual Sector Erase Command Sequence */
+	qla2x00_write_flash_byte(ha, 0x5555, 0xaa);
+	qla2x00_write_flash_byte(ha, 0x2aaa, 0x55);
+	qla2x00_write_flash_byte(ha, 0x5555, 0x80);
+	qla2x00_write_flash_byte(ha, 0x5555, 0xaa);
+	qla2x00_write_flash_byte(ha, 0x2aaa, 0x55);
+
+	if (mid == 0xda)
+		qla2x00_write_flash_byte(ha, addr & sec_mask, 0x10);
+	else
+		qla2x00_write_flash_byte(ha, addr & sec_mask, 0x30);
+
+	udelay(150);
+
+	/* Wait for erase to complete. */
+	return (qla2x00_poll_flash(ha, addr, 0x80, mid));
+}
+
+/**
+ * qla2x00_get_flash_manufacturer() - Read manufacturer ID from flash chip.
+ * @ha: HA context
+ *
+ * Returns the manufacturer's ID read from the flash chip.
+ */
+uint8_t
+qla2x00_get_flash_manufacturer(scsi_qla_host_t *ha)
+{
+	uint8_t	manuf_id;
+
+	qla2x00_write_flash_byte(ha, 0x5555, 0xaa);
+	qla2x00_write_flash_byte(ha, 0x2aaa, 0x55);
+	qla2x00_write_flash_byte(ha, 0x5555, 0x90);
+	manuf_id = qla2x00_read_flash_byte(ha, 0x0001);
+
+	return (manuf_id);
+}
+
+/**
+ * qla2x00_get_flash_version() - Read version information from flash.
+ * @ha: HA context
+ *
+ * Returns QLA_SUCCESS on successful retrieval of flash version.
+ */
+uint16_t
+qla2x00_get_flash_version(scsi_qla_host_t *ha)
+{
+	uint16_t	ret = QLA_SUCCESS;
+	uint32_t	loop_cnt = 1;  /* this is for error exit only */
+	uint32_t	pcir_adr;
+
+	ENTER(__func__);
+
+	qla2x00_flash_enable(ha);
+	do {	/* Loop once to provide quick error exit */
+		/* Match signature */
+		if (!(qla2x00_read_flash_byte(ha, 0) == 0x55 &&
+		    qla2x00_read_flash_byte(ha, 1) == 0xaa)) {
+			/* No signature */
+			DEBUG2(printk("scsi(%ld): No matching FLASH "
+			    "signature.\n", ha->host_no));
+			ret = QLA_FUNCTION_FAILED;
+			break;
+		}
+
+		pcir_adr = qla2x00_read_flash_byte(ha, 0x18) & 0xff;
+
+		/* validate signature of PCI data structure */
+		if ((qla2x00_read_flash_byte(ha, pcir_adr)) == 'P' &&
+		    (qla2x00_read_flash_byte(ha, pcir_adr + 1)) == 'C' &&
+		    (qla2x00_read_flash_byte(ha, pcir_adr + 2)) == 'I' &&
+		    (qla2x00_read_flash_byte(ha, pcir_adr + 3)) == 'R') {
+
+			/* Read version */
+			ha->optrom_minor =
+			    qla2x00_read_flash_byte(ha, pcir_adr + 0x12);
+			ha->optrom_major =
+			    qla2x00_read_flash_byte(ha, pcir_adr + 0x13);
+			DEBUG3(printk("%s(): got %d.%d.\n",
+			    __func__, ha->optrom_major, ha->optrom_minor));
+		} else {
+			/* error */
+			DEBUG2(printk("%s(): PCI data struct not found. "
+			    "pcir_adr=%x.\n",
+			    __func__, pcir_adr));
+			ret = QLA_FUNCTION_FAILED;
+			break;
+		}
+
+	} while (--loop_cnt);
+	qla2x00_flash_disable(ha);
+
+	LEAVE(__func__);
+
+	return (ret);
+}
+
+/**
+ * qla2x00_get_flash_image() - Read image from flash chip.
+ * @ha: HA context
+ * @image: Buffer to receive flash image
+ *
+ * Returns 0 on success, else non-zero.
+ */
+uint16_t
+qla2x00_get_flash_image(scsi_qla_host_t *ha, uint8_t *image)
+{
+	uint32_t	addr;
+	uint32_t	midpoint;
+	uint8_t		*data;
+	device_reg_t	*reg = ha->iobase;
+
+	midpoint = FLASH_IMAGE_SIZE / 2;
+
+	qla2x00_flash_enable(ha);
+	WRT_REG_WORD(&reg->nvram, 0);
+	for (addr = 0, data = image; addr < FLASH_IMAGE_SIZE; addr++, data++) {
+		if (addr == midpoint)
+			WRT_REG_WORD(&reg->nvram, NVR_SELECT);
+
+		*data = qla2x00_read_flash_byte(ha, addr);
+	}
+	qla2x00_flash_disable(ha);
+
+	return (0);
+}
+
+/**
+ * qla2x00_set_flash_image() - Write image to flash chip.
+ * @ha: HA context
+ * @image: Source image to write to flash
+ *
+ * Returns 0 on success, else non-zero.
+ */
+uint16_t
+qla2x00_set_flash_image(scsi_qla_host_t *ha, uint8_t *image)
+{
+	uint16_t	status;
+	uint32_t	addr;
+	uint32_t	midpoint;
+	uint32_t	sec_mask;
+	uint32_t	rest_addr;
+	uint8_t		mid;
+	uint8_t		sec_number;
+	uint8_t		data;
+	device_reg_t	*reg = ha->iobase;
+
+	status = 0;
+	sec_number = 0;
+
+	/* Reset ISP chip. */
+	WRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);
+
+	qla2x00_flash_enable(ha);
+	do {	/* Loop once to provide quick error exit */
+		/* Structure of flash memory based on manufacturer */
+		mid = qla2x00_get_flash_manufacturer(ha);
+		if (mid == 0x6d) {
+			// Am29LV001 part
+			rest_addr = 0x1fff;
+			sec_mask = 0x1e000;
+		} else if (mid == 0x40) {
+			// Mostel v29c51001 part
+			rest_addr = 0x1ff;
+			sec_mask = 0x1fe00;
+		} else if (mid == 0xbf) {
+			// SST39sf10 part
+			rest_addr = 0xfff;
+			sec_mask = 0x1f000;
+		} else if (mid == 0xda) {
+			// Winbond W29EE011 part
+			rest_addr = 0x7f;
+			sec_mask = 0x1ff80;
+			addr = 0;
+			if (qla2x00_erase_flash_sector(ha, addr, sec_mask,
+			    mid)) {
+				status = 1;
+				break;
+			}
+		} else {
+			// Am29F010 part
+			rest_addr = 0x3fff;
+			sec_mask = 0x1c000;
+		}
+
+		midpoint = FLASH_IMAGE_SIZE / 2;
+		for (addr = 0; addr < FLASH_IMAGE_SIZE; addr++) {
+			data = *image++;
+			/* Are we at the beginning of a sector? */
+			if (!(addr & rest_addr)) {
+				if (addr == midpoint)
+					WRT_REG_WORD(&reg->nvram, NVR_SELECT);
+
+				/* Then erase it */
+				if (qla2x00_erase_flash_sector(ha, addr,
+				    sec_mask, mid)) {
+					status = 1;
+					break;
+				}
+
+				sec_number++;
+			}
+			if (mid == 0x6d) {
+				if (sec_number == 1 &&
+				    (addr == (rest_addr - 1))) {
+					rest_addr = 0x0fff;
+					sec_mask   = 0x1f000;
+				} else if (sec_number == 3 && (addr & 0x7ffe)) {
+					rest_addr = 0x3fff;
+					sec_mask   = 0x1c000;
+				}
+			}
+
+			if (qla2x00_program_flash_address(ha, addr, data,
+			    mid)) {
+				status = 1;
+				break;
+			}
+		}
+	} while (0);
+
+	qla2x00_flash_disable(ha);
+
+	return (status);
+}
diff -purN linux-2.6.1/drivers/scsi/qla2xxx/qla_version.h linux-2.5/drivers/scsi/qla2xxx/qla_version.h
--- linux-2.6.1/drivers/scsi/qla2xxx/qla_version.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/scsi/qla2xxx/qla_version.h	2004-01-15 10:18:55.000000000 +0000
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *                  QLOGIC LINUX SOFTWARE
+ *
+ * QLogic ISP2x00 device driver for Linux 2.6.x
+ * Copyright (C) 2003 QLogic Corporation
+ * (www.qlogic.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ ******************************************************************************/
+/*
+ * Driver version 
+ */
+#define QLA2XXX_VERSION      "8.00.00b8"
+
+#define QLA_DRIVER_MAJOR_VER	8
+#define QLA_DRIVER_MINOR_VER	0
+#define QLA_DRIVER_PATCH_VER	0
+#define QLA_DRIVER_BETA_VER	8
diff -purN linux-2.6.1/drivers/scsi/scsi.c linux-2.5/drivers/scsi/scsi.c
--- linux-2.6.1/drivers/scsi/scsi.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/drivers/scsi/scsi.c	2004-01-10 20:37:37.000000000 +0000
@@ -142,6 +142,21 @@ struct scsi_request *scsi_allocate_reque
 
 void __scsi_release_request(struct scsi_request *sreq)
 {
+	struct request *req = sreq->sr_request;
+
+	/* unlikely because the tag was usually ended earlier by the
+	 * mid-layer. However, for layering reasons ULD's don't end
+	 * the tag of commands they generate. */
+	if (unlikely(blk_rq_tagged(req))) {
+		unsigned long flags;
+		struct request_queue *q = req->q;
+
+		spin_lock_irqsave(q->queue_lock, flags);
+		blk_queue_end_tag(q, req);
+		spin_unlock_irqrestore(q->queue_lock, flags);
+	}
+
+
 	if (likely(sreq->sr_command != NULL)) {
 		struct scsi_cmnd *cmd = sreq->sr_command;
 
@@ -441,7 +456,7 @@ void scsi_log_completion(struct scsi_cmn
 			case FAILED:
 				printk("FAILED ");
 				break;
-			case TIMEOUT:
+			case TIMEOUT_ERROR:
 				/* 
 				 * If called via scsi_times_out.
 				 */
diff -purN linux-2.6.1/drivers/scsi/scsi_error.c linux-2.5/drivers/scsi/scsi_error.c
--- linux-2.6.1/drivers/scsi/scsi_error.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/drivers/scsi/scsi_error.c	2004-01-10 19:04:26.000000000 +0000
@@ -164,7 +164,7 @@ int scsi_delete_timer(struct scsi_cmnd *
  **/
 void scsi_times_out(struct scsi_cmnd *scmd)
 {
-	scsi_log_completion(scmd, TIMEOUT);
+	scsi_log_completion(scmd, TIMEOUT_ERROR);
 	if (unlikely(!scsi_eh_scmd_add(scmd, SCSI_EH_CANCEL_CMD))) {
 		panic("Error handler thread not present at %p %p %s %d",
 		      scmd, scmd->device->host, __FILE__, __LINE__);
diff -purN linux-2.6.1/drivers/scsi/scsi_scan.c linux-2.5/drivers/scsi/scsi_scan.c
--- linux-2.6.1/drivers/scsi/scsi_scan.c	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/drivers/scsi/scsi_scan.c	2004-01-09 10:20:43.000000000 +0000
@@ -254,7 +254,7 @@ static struct scsi_device *scsi_alloc_sd
 			 "%d:%d:%d:%d", sdev->host->host_no,
 			 sdev->channel, sdev->id, sdev->lun);
 	} else
-		goto out_free_queue;
+		goto out_cleanup_slave;
 
 	/*
 	 * If there are any same target siblings, add this to the
@@ -283,6 +283,9 @@ static struct scsi_device *scsi_alloc_sd
 	spin_unlock_irqrestore(shost->host_lock, flags);
 	return sdev;
 
+out_cleanup_slave:
+	if (shost->hostt->slave_destroy)
+		shost->hostt->slave_destroy(sdev);
 out_free_queue:
 	scsi_free_queue(sdev->request_queue);
 out_free_dev:
diff -purN linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_glue.c linux-2.5/drivers/scsi/sym53c8xx_2/sym_glue.c
--- linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_glue.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/drivers/scsi/sym53c8xx_2/sym_glue.c	2004-01-14 05:43:33.000000000 +0000
@@ -2177,7 +2177,7 @@ sym53c8xx_pci_init(struct pci_dev *pdev,
  *  Detach the host.
  *  We have to free resources and halt the NCR chip.
  */
-static int __devexit sym_detach(struct sym_hcb *np)
+static int sym_detach(struct sym_hcb *np)
 {
 	printk("%s: detaching ...\n", sym_name(np));
 
diff -purN linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_hipd.c linux-2.5/drivers/scsi/sym53c8xx_2/sym_hipd.c
--- linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_hipd.c	2004-01-09 06:59:02.000000000 +0000
+++ linux-2.5/drivers/scsi/sym53c8xx_2/sym_hipd.c	2004-01-11 02:11:47.000000000 +0000
@@ -1058,12 +1058,10 @@ static int sym_prepare_setting(hcb_p np,
 		 *  and BUS width.
 		 */
 		if (np->features & FE_ULTRA3) {
-			if (tp->tinfo.user.period <= 9	&&
-			    tp->tinfo.user.width == BUS_16_BIT) {
-				tp->tinfo.user.options |= PPR_OPT_DT;
-				tp->tinfo.user.offset   = np->maxoffs_dt;
-				tp->tinfo.user.spi_version = 3;
-			}
+			tp->tinfo.user.options |= PPR_OPT_DT;
+			tp->tinfo.user.period = np->minsync_dt;
+			tp->tinfo.user.offset = np->maxoffs_dt;
+			tp->tinfo.user.spi_version = 3;
 		}
 
 		if (!tp->usrtags)
@@ -2126,9 +2124,15 @@ sym_setsync(hcb_p np, int target,
 
 	sym_settrans(np, target, 0, ofs, per, wide, div, fak);
 
-	tp->tinfo.goal.period	= tp->tinfo.curr.period  = per;
-	tp->tinfo.goal.offset	= tp->tinfo.curr.offset  = ofs;
-	tp->tinfo.goal.options	= tp->tinfo.curr.options = 0;
+	tp->tinfo.curr.period  = per;
+	tp->tinfo.curr.offset  = ofs;
+	tp->tinfo.curr.options = 0;
+
+	if (!(tp->tinfo.goal.options & PPR_OPT_MASK)) {
+		tp->tinfo.goal.period	= per;
+		tp->tinfo.goal.offset	= ofs;
+		tp->tinfo.goal.options	= 0;
+	}
 
 	sym_xpt_async_nego_sync(np, target);
 }
diff -purN linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_misc.c linux-2.5/drivers/scsi/sym53c8xx_2/sym_misc.c
--- linux-2.6.1/drivers/scsi/sym53c8xx_2/sym_misc.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/scsi/sym53c8xx_2/sym_misc.c	2004-01-11 02:08:51.000000000 +0000
@@ -328,7 +328,6 @@ printf("XXXXXX [%d] inq_version=%x inq_b
 	    tp->inq_byte56  != inq_byte56) {
 		tp->inq_version = inq_version;
 		tp->inq_byte7   = inq_byte7;
-		tp->inq_byte56  = inq_byte56;
 		return 1;
 	}
 	return 0;
diff -purN linux-2.6.1/drivers/serial/8250_acpi.c linux-2.5/drivers/serial/8250_acpi.c
--- linux-2.6.1/drivers/serial/8250_acpi.c	2004-01-09 07:00:05.000000000 +0000
+++ linux-2.5/drivers/serial/8250_acpi.c	2004-01-16 22:01:45.000000000 +0000
@@ -1,6 +1,7 @@
 /*
- * serial/acpi.c
  * Copyright (c) 2002-2003 Matthew Wilcox for Hewlett-Packard
+ * Copyright (C) 2004 Hewlett-Packard Co
+ *	Bjorn Helgaas <bjorn.helgaas@hp.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -11,13 +12,21 @@
 #include <linux/acpi.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/tty.h>
 #include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial_core.h>
 
 #include <acpi/acpi_bus.h>
 
 #include <asm/io.h>
 #include <asm/serial.h>
 
+struct serial_private {
+	int	line;
+	void	*iomem_base;
+};
+
 static acpi_status acpi_serial_mmio(struct serial_struct *req,
 				    struct acpi_resource_address64 *addr)
 {
@@ -94,38 +103,72 @@ static acpi_status acpi_serial_resource(
 
 static int acpi_serial_add(struct acpi_device *device)
 {
+	struct serial_private *priv;
 	acpi_status status;
 	struct serial_struct serial_req;
-	int line;
+	int result;
 
 	memset(&serial_req, 0, sizeof(serial_req));
 
+	priv = kmalloc(sizeof(struct serial_private), GFP_KERNEL);
+	if (!priv) {
+		result = -ENOMEM;
+		goto fail;
+	}
+	memset(priv, 0, sizeof(*priv));
+
 	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
 				     acpi_serial_resource, &serial_req);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
+	if (ACPI_FAILURE(status)) {
+		result = -ENODEV;
+		goto fail;
+	}
 
-	if (!serial_req.iomem_base && !serial_req.port) {
+	if (serial_req.iomem_base)
+		priv->iomem_base = serial_req.iomem_base;
+	else if (!serial_req.port) {
 		printk(KERN_ERR "%s: no iomem or port address in %s _CRS\n",
 			__FUNCTION__, device->pnp.bus_id);
-		return -ENODEV;
+		result = -ENODEV;
+		goto fail;
 	}
 
 	serial_req.baud_base = BASE_BAUD;
-	serial_req.flags = ASYNC_SKIP_TEST|ASYNC_BOOT_AUTOCONF|ASYNC_AUTO_IRQ;
+	serial_req.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF |
+			   UPF_AUTO_IRQ  | UPF_RESOURCES;
 
-	line = register_serial(&serial_req);
-	if (line < 0) {
-		printk(KERN_WARNING "Couldn't register serial port %s: %d",
-			device->pnp.bus_id, line);
-		return -ENODEV;
+	priv->line = register_serial(&serial_req);
+	if (priv->line < 0) {
+		printk(KERN_WARNING "Couldn't register serial port %s: %d\n",
+			device->pnp.bus_id, priv->line);
+		result = -ENODEV;
+		goto fail;
 	}
 
+	acpi_driver_data(device) = priv;
 	return 0;
+
+fail:
+	if (serial_req.iomem_base)
+		iounmap(serial_req.iomem_base);
+	kfree(priv);
+
+	return result;
 }
 
 static int acpi_serial_remove(struct acpi_device *device, int type)
 {
+	struct serial_private *priv;
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
+	priv = acpi_driver_data(device);
+	unregister_serial(priv->line);
+	if (priv->iomem_base)
+		iounmap(priv->iomem_base);
+	kfree(priv);
+
 	return 0;
 }
 
diff -purN linux-2.6.1/drivers/serial/8250_hcdp.c linux-2.5/drivers/serial/8250_hcdp.c
--- linux-2.6.1/drivers/serial/8250_hcdp.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/serial/8250_hcdp.c	2004-01-11 23:27:13.000000000 +0000
@@ -185,7 +185,7 @@ setup_serial_hcdp(void *tablep)
 #else
 		port.irq = gsi;
 #endif
-		port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
+		port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_RESOURCES;
 		if (gsi)
 			port.flags |= ASYNC_AUTO_IRQ;
 
diff -purN linux-2.6.1/drivers/serial/Kconfig linux-2.5/drivers/serial/Kconfig
--- linux-2.6.1/drivers/serial/Kconfig	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/drivers/serial/Kconfig	2004-01-16 21:54:06.000000000 +0000
@@ -62,6 +62,15 @@ config SERIAL_8250_CONSOLE
 
 	  If unsure, say N.
 
+config SERIAL_8250_HCDP
+	bool "Console device discovery via EFI HCDP table"
+	depends on IA64
+	depends on SERIAL_8250_CONSOLE=y
+	---help---
+	  If you wish to make the serial console port described by the EFI
+	  HCDP table available for use as serial console, say Y here.  See
+	  <http://www.dig64.org/specifications/DIG64_HCDPv10a_01.pdf>.
+
 config SERIAL_8250_CS
 	tristate "8250/16550 PCMCIA device support"
 	depends on PCMCIA && SERIAL_8250
@@ -84,15 +93,6 @@ config SERIAL_8250_ACPI
 	  If you wish to enable serial port discovery via the ACPI
 	  namespace, say Y here.  If unsure, say N.
 
-config SERIAL_8250_HCDP
-	bool "8250/16550 device discovery support via EFI HCDP table"
-	depends on IA64 && SERIAL_8250
-	---help---
-	  If you wish to make the serial console port described by the EFI
-	  HCDP table available for use as serial console or general
-	  purpose port, say Y here. See
-	  <http://www.dig64.org/specifications/DIG64_HCDPv10a_01.pdf>.
-
 config SERIAL_8250_NR_UARTS
 	int "Maximum number of non-legacy 8250/16550 serial ports"
 	depends on SERIAL_8250
diff -purN linux-2.6.1/fs/compat_ioctl.c linux-2.5/fs/compat_ioctl.c
--- linux-2.6.1/fs/compat_ioctl.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/fs/compat_ioctl.c	2004-01-13 23:46:12.000000000 +0000
@@ -65,6 +65,7 @@
 #include <linux/ncp_fs.h>
 #include <linux/i2c.h>
 #include <linux/i2c-dev.h>
+#include <linux/wireless.h>
 
 #include <net/sock.h>          /* siocdevprivate_ioctl */
 #include <net/bluetooth/bluetooth.h>
@@ -2970,6 +2971,48 @@ static int do_i2c_smbus_ioctl(unsigned i
 	return sys_ioctl(fd, cmd, (unsigned long)tdata);
 }
 
+struct compat_iw_point {
+	compat_caddr_t pointer;
+	__u16 length;
+	__u16 flags;
+};
+
+static int do_wireless_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
+{
+	struct iwreq *iwr, *iwr_u;
+	struct iw_point *iwp;
+	struct compat_iw_point *iwp_u;
+	compat_caddr_t pointer;
+	__u16 length, flags;
+
+	iwr_u = (struct iwreq *) compat_ptr(arg);
+	iwp_u = (struct compat_iw_point *) &iwr_u->u.data;
+	iwr = compat_alloc_user_space(sizeof(*iwr));
+	if (iwr == NULL)
+		return -ENOMEM;
+
+	iwp = &iwr->u.data;
+
+	if (verify_area(VERIFY_WRITE, iwr, sizeof(*iwr)))
+		return -EFAULT;
+
+	if (__copy_in_user(&iwr->ifr_ifrn.ifrn_name[0],
+			   &iwr_u->ifr_ifrn.ifrn_name[0],
+			   sizeof(iwr->ifr_ifrn.ifrn_name)))
+		return -EFAULT;
+
+	if (__get_user(pointer, &iwp_u->pointer) ||
+	    __get_user(length, &iwp_u->length) ||
+	    __get_user(flags, &iwp_u->flags))
+		return -EFAULT;
+
+	if (__put_user(compat_ptr(pointer), &iwp->pointer) ||
+	    __put_user(length, &iwp->length) ||
+	    __put_user(flags, &iwp->flags))
+		return -EFAULT;
+
+	return sys_ioctl(fd, cmd, (unsigned long) iwr);
+}
 
 #undef CODE
 #endif
@@ -3133,6 +3176,20 @@ HANDLE_IOCTL(USBDEVFS_DISCSIGNAL32, do_u
 HANDLE_IOCTL(I2C_FUNCS, w_long)
 HANDLE_IOCTL(I2C_RDWR, do_i2c_rdwr_ioctl)
 HANDLE_IOCTL(I2C_SMBUS, do_i2c_smbus_ioctl)
+/* wireless */
+HANDLE_IOCTL(SIOCGIWRANGE, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIWSPY, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWSPY, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIWTHRSPY, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWTHRSPY, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWAPLIST, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWSCAN, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIWESSID, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWESSID, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIWNICKN, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWNICKN, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCSIWENCODE, do_wireless_ioctl)
+HANDLE_IOCTL(SIOCGIWENCODE, do_wireless_ioctl)
 
 #undef DECLARES
 #endif
diff -purN linux-2.6.1/fs/jfs/super.c linux-2.5/fs/jfs/super.c
--- linux-2.6.1/fs/jfs/super.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/fs/jfs/super.c	2004-01-08 16:25:54.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- *   Copyright (C) International Business Machines Corp., 2000-2003
+ *   Copyright (C) International Business Machines Corp., 2000-2004
  *   Portions Copyright (C) Christoph Hellwig, 2001-2002
  *
  *   This program is free software;  you can redistribute it and/or modify
@@ -203,7 +203,7 @@ static void jfs_put_super(struct super_b
 
 enum {
 	Opt_integrity, Opt_nointegrity, Opt_iocharset, Opt_resize,
-	Opt_errors, Opt_ignore, Opt_err,
+	Opt_resize_nosize, Opt_errors, Opt_ignore, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -211,6 +211,7 @@ static match_table_t tokens = {
 	{Opt_nointegrity, "nointegrity"},
 	{Opt_iocharset, "iocharset=%s"},
 	{Opt_resize, "resize=%u"},
+	{Opt_resize_nosize, "resize"},
 	{Opt_errors, "errors=%s"},
 	{Opt_ignore, "noquota"},
 	{Opt_ignore, "quota"},
@@ -261,14 +262,16 @@ static int parse_options(char *options, 
 		case Opt_resize:
 		{
 			char *resize = args[0].from;
-			if (!resize || !*resize) {
-				*newLVSize = sb->s_bdev->bd_inode->i_size >>
-					sb->s_blocksize_bits;
-				if (*newLVSize == 0)
-					printk(KERN_ERR
-					"JFS: Cannot determine volume size\n");
-			} else
-				*newLVSize = simple_strtoull(resize, &resize, 0);
+			*newLVSize = simple_strtoull(resize, &resize, 0);
+			break;
+		}
+		case Opt_resize_nosize:
+		{
+			*newLVSize = sb->s_bdev->bd_inode->i_size >>
+				sb->s_blocksize_bits;
+			if (*newLVSize == 0)
+				printk(KERN_ERR
+				       "JFS: Cannot determine volume size\n");
 			break;
 		}
 		case Opt_errors:
diff -purN linux-2.6.1/fs/jfs/xattr.c linux-2.5/fs/jfs/xattr.c
--- linux-2.6.1/fs/jfs/xattr.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/fs/jfs/xattr.c	2004-01-15 23:03:15.000000000 +0000
@@ -499,7 +499,7 @@ static int ea_get(struct inode *inode, s
 		if (ea_buf->xattr == NULL)
 			return -ENOMEM;
 
-		ea_buf->flag |= EA_MALLOC;
+		ea_buf->flag = EA_MALLOC;
 		ea_buf->max_size = (size + sb->s_blocksize - 1) &
 		    ~(sb->s_blocksize - 1);
 
@@ -668,12 +668,13 @@ static int can_set_system_xattr(struct i
 	 */
 	if (strcmp(name, XATTR_NAME_ACL_ACCESS) == 0) {
 		acl = posix_acl_from_xattr(value, value_len);
-		if (acl < 0) {
+		if (IS_ERR(acl)) {
+			rc = PTR_ERR(acl);
 			printk(KERN_ERR "posix_acl_from_xattr returned %d\n",
 			       rc);
 			return rc;
 		}
-		if (acl > 0) {
+		if (acl) {
 			mode_t mode = inode->i_mode;
 			rc = posix_acl_equiv_mode(acl, &mode);
 			posix_acl_release(acl);
diff -purN linux-2.6.1/include/asm-ia64/acpi.h linux-2.5/include/asm-ia64/acpi.h
--- linux-2.6.1/include/asm-ia64/acpi.h	2004-01-09 06:59:57.000000000 +0000
+++ linux-2.5/include/asm-ia64/acpi.h	2004-01-12 07:20:13.000000000 +0000
@@ -30,6 +30,8 @@
 
 #ifdef __KERNEL__
 
+#include <linux/init.h>
+#include <linux/numa.h>
 #include <asm/system.h>
 
 #define COMPILER_DEPENDENT_INT64	long
@@ -92,7 +94,6 @@ int acpi_register_irq (u32 gsi, u32 pola
 int acpi_irq_to_vector (u32 irq);
 
 #ifdef CONFIG_ACPI_NUMA
-#include <asm/numa.h>
 /* Proximity bitmap length; _PXM is at most 255 (8 bit)*/
 #define MAX_PXM_DOMAINS (256)
 extern int __initdata pxm_to_nid_map[MAX_PXM_DOMAINS];
diff -purN linux-2.6.1/include/asm-ia64/asmmacro.h linux-2.5/include/asm-ia64/asmmacro.h
--- linux-2.6.1/include/asm-ia64/asmmacro.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/include/asm-ia64/asmmacro.h	2004-01-16 01:51:26.000000000 +0000
@@ -2,7 +2,7 @@
 #define _ASM_IA64_ASMMACRO_H
 
 /*
- * Copyright (C) 2000-2001, 2003 Hewlett-Packard Co
+ * Copyright (C) 2000-2001, 2003-2004 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
@@ -89,4 +89,15 @@ name:
 # define FSYS_RETURN	br.ret.sptk.many b6
 #endif
 
+/*
+ * Up until early 2004, use of .align within a function caused bad unwind info.
+ * TEXT_ALIGN(n) expands into ".align n" if a fixed GAS is available or into nothing
+ * otherwise.
+ */
+#ifdef HAVE_WORKING_TEXT_ALIGN
+# define TEXT_ALIGN(n)	.align n
+#else
+# define TEXT_ALIGN(n)
+#endif
+
 #endif /* _ASM_IA64_ASMMACRO_H */
diff -purN linux-2.6.1/include/asm-ia64/mmzone.h linux-2.5/include/asm-ia64/mmzone.h
--- linux-2.6.1/include/asm-ia64/mmzone.h	2004-01-09 07:00:13.000000000 +0000
+++ linux-2.5/include/asm-ia64/mmzone.h	2004-01-12 07:09:14.000000000 +0000
@@ -33,5 +33,7 @@ extern unsigned long max_low_pfn;
 #define page_to_pfn(page)	((unsigned long) (page - vmem_map))
 #define pfn_to_page(pfn)	(vmem_map + (pfn))
 
+#else /* CONFIG_DISCONTIGMEM */
+# define NR_MEMBLKS		1
 #endif /* CONFIG_DISCONTIGMEM */
 #endif /* _ASM_IA64_MMZONE_H */
diff -purN linux-2.6.1/include/asm-ia64/numa.h linux-2.5/include/asm-ia64/numa.h
--- linux-2.6.1/include/asm-ia64/numa.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/asm-ia64/numa.h	2004-01-12 06:56:51.000000000 +0000
@@ -16,7 +16,6 @@
 #ifdef CONFIG_NUMA
 
 #include <linux/cache.h>
-#include <linux/cache.h>
 #include <linux/cpumask.h>
 #include <linux/numa.h>
 #include <linux/smp.h>
diff -purN linux-2.6.1/include/asm-ia64/page.h linux-2.5/include/asm-ia64/page.h
--- linux-2.6.1/include/asm-ia64/page.h	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/include/asm-ia64/page.h	2004-01-12 22:31:00.000000000 +0000
@@ -145,7 +145,7 @@ typedef union ia64_va {
 static __inline__ int
 get_order (unsigned long size)
 {
-	double d = size - 1;
+	long double d = size - 1;
 	long order;
 
 	order = ia64_getf_exp(d);
diff -purN linux-2.6.1/include/linux/compat_ioctl.h linux-2.5/include/linux/compat_ioctl.h
--- linux-2.6.1/include/linux/compat_ioctl.h	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/include/linux/compat_ioctl.h	2004-01-13 23:46:12.000000000 +0000
@@ -260,6 +260,7 @@ COMPATIBLE_IOCTL(SIOCATMARK)
 COMPATIBLE_IOCTL(SIOCSIFLINK)
 COMPATIBLE_IOCTL(SIOCSIFENCAP)
 COMPATIBLE_IOCTL(SIOCGIFENCAP)
+COMPATIBLE_IOCTL(SIOCSIFNAME)
 COMPATIBLE_IOCTL(SIOCSIFBR)
 COMPATIBLE_IOCTL(SIOCGIFBR)
 COMPATIBLE_IOCTL(SIOCSARP)
@@ -685,3 +686,34 @@ COMPATIBLE_IOCTL(I2C_TENBIT)
 COMPATIBLE_IOCTL(I2C_PEC)
 COMPATIBLE_IOCTL(I2C_RETRIES)
 COMPATIBLE_IOCTL(I2C_TIMEOUT)
+/* wireless */
+COMPATIBLE_IOCTL(SIOCSIWCOMMIT)
+COMPATIBLE_IOCTL(SIOCGIWNAME)
+COMPATIBLE_IOCTL(SIOCSIWNWID)
+COMPATIBLE_IOCTL(SIOCGIWNWID)
+COMPATIBLE_IOCTL(SIOCSIWFREQ)
+COMPATIBLE_IOCTL(SIOCGIWFREQ)
+COMPATIBLE_IOCTL(SIOCSIWMODE)
+COMPATIBLE_IOCTL(SIOCGIWMODE)
+COMPATIBLE_IOCTL(SIOCSIWSENS)
+COMPATIBLE_IOCTL(SIOCGIWSENS)
+COMPATIBLE_IOCTL(SIOCSIWRANGE)
+COMPATIBLE_IOCTL(SIOCSIWPRIV)
+COMPATIBLE_IOCTL(SIOCGIWPRIV)
+COMPATIBLE_IOCTL(SIOCSIWSTATS)
+COMPATIBLE_IOCTL(SIOCGIWSTATS)
+COMPATIBLE_IOCTL(SIOCSIWAP)
+COMPATIBLE_IOCTL(SIOCGIWAP)
+COMPATIBLE_IOCTL(SIOCSIWSCAN)
+COMPATIBLE_IOCTL(SIOCSIWRATE)
+COMPATIBLE_IOCTL(SIOCGIWRATE)
+COMPATIBLE_IOCTL(SIOCSIWRTS)
+COMPATIBLE_IOCTL(SIOCGIWRTS)
+COMPATIBLE_IOCTL(SIOCSIWFRAG)
+COMPATIBLE_IOCTL(SIOCGIWFRAG)
+COMPATIBLE_IOCTL(SIOCSIWTXPOW)
+COMPATIBLE_IOCTL(SIOCGIWTXPOW)
+COMPATIBLE_IOCTL(SIOCSIWRETRY)
+COMPATIBLE_IOCTL(SIOCGIWRETRY)
+COMPATIBLE_IOCTL(SIOCSIWPOWER)
+COMPATIBLE_IOCTL(SIOCGIWPOWER)
diff -purN linux-2.6.1/include/linux/ide.h linux-2.5/include/linux/ide.h
--- linux-2.6.1/include/linux/ide.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/linux/ide.h	2004-01-16 18:38:19.000000000 +0000
@@ -1513,64 +1513,6 @@ int ide_taskfile_ioctl(ide_drive_t *, un
 int ide_cmd_ioctl(ide_drive_t *, unsigned int, unsigned long);
 int ide_task_ioctl(ide_drive_t *, unsigned int, unsigned long);
 
-#if 0
-
-#define IDEFLOPPY_PC_BUFFER_SIZE        256
-#define IDETAPE_PC_BUFFER_SIZE          256
-#define IDE_PC_BUFFER_SIZE          256
-
-typedef struct ide_packet_command_s {
-		/* Actual packet bytes */
-	u8 c[12];
-		/* On each retry, we increment retries */
-	int retries;
-		/* Error code */
-	int error;
-		/* Bytes to transfer */
-	int request_transfer;
-		/* Bytes actually transferred */
-	int actually_transferred;
-		/* Size of our data buffer */
-	int buffer_size;
-
-	struct buffer_head *bh;
-	u8 *b_data;
-		/* The corresponding request */
-	struct request *rq;
-# if 0
-		/* Scatter gather table */
-	struct scatterlist *sg;
-# endif
-	int b_count;
-		/* Data buffer */
-	u8 *buffer;
-		/* Pointer into the above buffer */
-	u8 *current_position;
-		/* Called when this packet command is completed */
-	ide_startstop_t (*callback) (ide_drive_t *);
-		/* Temporary buffer */
-	u8 pc_buffer[IDE_PC_BUFFER_SIZE];
-		/* Status/Action bit flags: long for set_bit */
-	unsigned long flags;
-} ide_pc_t;
-
-ide-cd orthoginal :-/
-struct packet_command {
-        char *buffer;
-        int buflen;
-        int stat;
-        int quiet;
-        int timeout;
-        struct request_sense *sense;
-        unsigned char c[12];
-};
-
-#endif
-
-#ifdef CONFIG_PKT_TASK_IOCTL
-extern int pkt_taskfile_ioctl(ide_drive_t *, struct inode *, struct file *, unsigned int, unsigned long);
-#endif /* CONFIG_PKT_TASK_IOCTL */
-
 extern void ide_delay_50ms(void);
 extern int system_bus_clock(void);
 
diff -purN linux-2.6.1/include/linux/ipv6.h linux-2.5/include/linux/ipv6.h
--- linux-2.6.1/include/linux/ipv6.h	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/include/linux/ipv6.h	2004-01-15 22:15:33.000000000 +0000
@@ -143,6 +143,7 @@ struct ipv6_devconf {
 	__s32		regen_max_retry;
 	__s32		max_desync_factor;
 #endif
+	__s32		max_addresses;
 	void		*sysctl;
 };
 
@@ -158,13 +159,12 @@ enum {
 	DEVCONF_RTR_SOLICITS,
 	DEVCONF_RTR_SOLICIT_INTERVAL,
 	DEVCONF_RTR_SOLICIT_DELAY,
-#ifdef CONFIG_IPV6_PRIVACY
 	DEVCONF_USE_TEMPADDR,
 	DEVCONF_TEMP_VALID_LFT,
 	DEVCONF_TEMP_PREFERED_LFT,
 	DEVCONF_REGEN_MAX_RETRY,
 	DEVCONF_MAX_DESYNC_FACTOR,
-#endif
+	DEVCONF_MAX_ADDRESSES,
 	DEVCONF_MAX
 };
 
diff -purN linux-2.6.1/include/linux/net.h linux-2.5/include/linux/net.h
--- linux-2.6.1/include/linux/net.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/linux/net.h	2004-01-09 09:46:38.000000000 +0000
@@ -120,9 +120,9 @@ struct proto_ops {
 	int		(*getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, int total_len);
+				      struct msghdr *m, size_t total_len);
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, int total_len,
+				      struct msghdr *m, size_t total_len,
 				      int flags);
 	int		(*mmap)	     (struct file *file, struct socket *sock,
 				      struct vm_area_struct * vma);
@@ -151,13 +151,13 @@ extern int	     sock_create(int family, 
 				 struct socket **res);
 extern void	     sock_release(struct socket *sock);
 extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
-				  int len);
+				  size_t len);
 extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
-				  int size, int flags);
+				  size_t size, int flags);
 extern int	     sock_readv_writev(int type, struct inode *inode,
 				       struct file *file,
 				       const struct iovec *iov, long count,
-				       long size);
+				       size_t size);
 extern int 	     sock_map_fd(struct socket *sock);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
@@ -216,9 +216,9 @@ SOCKCALL_WRAP(name, setsockopt, (struct 
 			 char *optval, int optlen), (sock, level, optname, optval, optlen)) \
 SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
 			 char *optval, int *optlen), (sock, level, optname, optval, optlen)) \
-SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, int len), \
+SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \
 	      (iocb, sock, m, len)) \
-SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, int len, int flags), \
+SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len, int flags), \
 	      (iocb, sock, m, len, flags)) \
 SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
 	      (file, sock, vma)) \
diff -purN linux-2.6.1/include/linux/pci_ids.h linux-2.5/include/linux/pci_ids.h
--- linux-2.6.1/include/linux/pci_ids.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/linux/pci_ids.h	2004-01-09 19:07:37.000000000 +0000
@@ -325,7 +325,7 @@
 /* RadeonIGP */
 #define PCI_DEVICE_ID_ATI_RS100		0xcab0
 #define PCI_DEVICE_ID_ATI_RS200		0xcab2
-#define PCI_DEVICE_ID_ATI_RS200_B	0xcbb3
+#define PCI_DEVICE_ID_ATI_RS200_B	0xcbb2
 #define PCI_DEVICE_ID_ATI_RS250		0xcab3
 #define PCI_DEVICE_ID_ATI_RS300_100	0x5830
 #define PCI_DEVICE_ID_ATI_RS300_133	0x5831
diff -purN linux-2.6.1/include/linux/rtnetlink.h linux-2.5/include/linux/rtnetlink.h
--- linux-2.6.1/include/linux/rtnetlink.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/linux/rtnetlink.h	2004-01-16 10:05:24.000000000 +0000
@@ -44,7 +44,10 @@
 #define	RTM_DELTFILTER	(RTM_BASE+29)
 #define	RTM_GETTFILTER	(RTM_BASE+30)
 
-#define	RTM_MAX		(RTM_BASE+31)
+#define RTM_NEWPREFIX	(RTM_BASE+36)
+#define RTM_GETPREFIX	(RTM_BASE+38)
+
+#define	RTM_MAX		(RTM_BASE+39)
 
 /* 
    Generic structure for encapsulation of optional route information.
@@ -459,6 +462,34 @@ struct ifinfomsg
 	unsigned	ifi_change;		/* IFF_* change mask */
 };
 
+/********************************************************************
+ *		prefix information 
+ ****/
+
+struct prefixmsg
+{
+	unsigned char	prefix_family;
+	int		prefix_ifindex;
+	unsigned char	prefix_type;
+	unsigned char	prefix_len;
+	unsigned char	prefix_flags;
+};
+
+enum 
+{
+	PREFIX_UNSPEC,
+	PREFIX_ADDRESS,
+	PREFIX_CACHEINFO,
+};
+
+#define PREFIX_MAX	PREFIX_CACHEINFO
+
+struct prefix_cacheinfo
+{
+	__u32	preferred_time;
+	__u32	valid_time;
+};
+
 /* The struct should be in sync with struct net_device_stats */
 struct rtnl_link_stats
 {
@@ -558,9 +589,18 @@ enum
 	IFLA_INET6_CONF,	/* sysctl parameters		*/
 	IFLA_INET6_STATS,	/* statistics			*/
 	IFLA_INET6_MCAST,	/* MC things. What of them?	*/
+	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
 };
 
-#define IFLA_INET6_MAX	IFLA_INET6_MCAST
+struct ifla_cacheinfo
+{
+	__u32	max_reasm_len;
+	__u32	tstamp;		/* ipv6InterfaceTable updated timestamp */
+	__u32	reachable_time;
+	__u32	retrans_time;
+};
+
+#define IFLA_INET6_MAX	IFLA_INET6_CACHEINFO
 
 /*****************************************************************
  *		Traffic control messages.
@@ -611,10 +651,13 @@ enum
 #define RTMGRP_IPV6_IFADDR	0x100
 #define RTMGRP_IPV6_MROUTE	0x200
 #define RTMGRP_IPV6_ROUTE	0x400
+#define RTMGRP_IPV6_IFINFO	0x800
 
 #define RTMGRP_DECnet_IFADDR    0x1000
 #define RTMGRP_DECnet_ROUTE     0x4000
 
+#define RTMGRP_IPV6_PREFIX	0x20000
+
 /* End of information exported to user level */
 
 #ifdef __KERNEL__
diff -purN linux-2.6.1/include/linux/signal.h linux-2.5/include/linux/signal.h
--- linux-2.6.1/include/linux/signal.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/include/linux/signal.h	2004-01-15 20:40:33.000000000 +0000
@@ -207,6 +207,7 @@ static inline void init_sigpending(struc
 	INIT_LIST_HEAD(&sig->list);
 }
 
+extern int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p);
 extern long do_sigpending(void __user *, unsigned long);
 extern int sigprocmask(int, sigset_t *, sigset_t *);
 
diff -purN linux-2.6.1/include/linux/sysctl.h linux-2.5/include/linux/sysctl.h
--- linux-2.6.1/include/linux/sysctl.h	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/include/linux/sysctl.h	2004-01-15 22:15:12.000000000 +0000
@@ -418,7 +418,8 @@ enum {
 	NET_IPV6_TEMP_VALID_LFT=12,
 	NET_IPV6_TEMP_PREFERED_LFT=13,
 	NET_IPV6_REGEN_MAX_RETRY=14,
-	NET_IPV6_MAX_DESYNC_FACTOR=15
+	NET_IPV6_MAX_DESYNC_FACTOR=15,
+	NET_IPV6_MAX_ADDRESSES=16
 };
 
 /* /proc/sys/net/ipv6/icmp */
diff -purN linux-2.6.1/include/net/addrconf.h linux-2.5/include/net/addrconf.h
--- linux-2.6.1/include/net/addrconf.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/net/addrconf.h	2004-01-15 22:15:12.000000000 +0000
@@ -15,6 +15,8 @@
 
 #define ADDR_CHECK_FREQUENCY		(120*HZ)
 
+#define IPV6_MAX_ADDRESSES		16
+
 struct prefix_info {
 	__u8			type;
 	__u8			length;
@@ -50,10 +52,6 @@ struct prefix_info {
 extern void			addrconf_init(void);
 extern void			addrconf_cleanup(void);
 
-extern int		        addrconf_notify(struct notifier_block *this, 
-						unsigned long event, 
-						void * data);
-
 extern int			addrconf_add_ifaddr(void *arg);
 extern int			addrconf_del_ifaddr(void *arg);
 extern int			addrconf_set_dstaddr(void *arg);
diff -purN linux-2.6.1/include/net/bluetooth/bluetooth.h linux-2.5/include/net/bluetooth/bluetooth.h
--- linux-2.6.1/include/net/bluetooth/bluetooth.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/net/bluetooth/bluetooth.h	2004-01-14 20:56:53.000000000 +0000
@@ -47,7 +47,8 @@
 #define BTPROTO_HCI     1
 #define BTPROTO_SCO   	2
 #define BTPROTO_RFCOMM	3
-#define BTPROTO_BNEP    4
+#define BTPROTO_BNEP	4
+#define BTPROTO_CMTP	5
 
 #define SOL_HCI     0
 #define SOL_L2CAP   6
@@ -129,7 +130,7 @@ int  bt_sock_unregister(int proto);
 struct sock *bt_sock_alloc(struct socket *sock, int proto, int pi_size, int prio);
 void bt_sock_link(struct bt_sock_list *l, struct sock *s);
 void bt_sock_unlink(struct bt_sock_list *l, struct sock *s);
-int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len, int flags);
+int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags);
 uint bt_sock_poll(struct file * file, struct socket *sock, poll_table *wait);
 int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
 
diff -purN linux-2.6.1/include/net/bluetooth/hci.h linux-2.5/include/net/bluetooth/hci.h
--- linux-2.6.1/include/net/bluetooth/hci.h	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/include/net/bluetooth/hci.h	2003-12-18 11:49:56.000000000 +0000
@@ -408,6 +408,16 @@ struct inquiry_info {
 	__u16    clock_offset;
 } __attribute__ ((packed));
 
+#define HCI_EV_INQUIRY_RESULT_WITH_RSSI	0x22
+struct inquiry_info_with_rssi {
+	bdaddr_t bdaddr;
+	__u8     pscan_rep_mode;
+	__u8     pscan_period_mode;
+	__u8     dev_class[3];
+	__u16    clock_offset;
+	__u8     rssi;
+} __attribute__ ((packed));
+
 #define HCI_EV_CONN_COMPLETE 	0x03
 struct hci_ev_conn_complete {
 	__u8     status;
diff -purN linux-2.6.1/include/net/bluetooth/hci_core.h linux-2.5/include/net/bluetooth/hci_core.h
--- linux-2.6.1/include/net/bluetooth/hci_core.h	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/include/net/bluetooth/hci_core.h	2004-01-14 18:56:00.000000000 +0000
@@ -176,6 +176,12 @@ static inline void inquiry_cache_init(st
 	c->list = NULL;
 }
 
+static inline int inquiry_cache_empty(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return (c->list == NULL);
+}
+
 static inline long inquiry_cache_age(struct hci_dev *hdev)
 {
 	struct inquiry_cache *c = &hdev->inq_cache;
@@ -281,10 +287,12 @@ static inline void hci_conn_hold(struct 
 static inline void hci_conn_put(struct hci_conn *conn)
 {
 	if (atomic_dec_and_test(&conn->refcnt)) {
-		if (conn->type == SCO_LINK)
+		if (conn->type == ACL_LINK) {
+			unsigned long timeo = (conn->out) ?
+				HCI_DISCONN_TIMEOUT : HCI_DISCONN_TIMEOUT * 2;
+			hci_conn_set_timer(conn, timeo);
+		} else
 			hci_conn_set_timer(conn, HZ / 100);
-		else if (conn->out)
-			hci_conn_set_timer(conn, HCI_DISCONN_TIMEOUT);
 	}
 }
 
diff -purN linux-2.6.1/include/net/bluetooth/rfcomm.h linux-2.5/include/net/bluetooth/rfcomm.h
--- linux-2.6.1/include/net/bluetooth/rfcomm.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/net/bluetooth/rfcomm.h	2003-12-18 10:57:17.000000000 +0000
@@ -167,8 +167,8 @@ struct rfcomm_session {
 	int              initiator;
 
 	/* Default DLC parameters */
+	int    cfc;
 	uint   mtu;
-	uint   credits;
 
 	struct list_head dlcs;
 };
@@ -190,7 +190,7 @@ struct rfcomm_dlc {
 	u8            mscex;
 
 	uint          mtu;
-	uint          credits;
+	uint          cfc;
 	uint          rx_credits;
 	uint          tx_credits;
 
@@ -219,6 +219,11 @@ struct rfcomm_dlc {
 #define RFCOMM_MSCEX_RX     2
 #define RFCOMM_MSCEX_OK     (RFCOMM_MSCEX_TX + RFCOMM_MSCEX_RX)
 
+/* CFC states */
+#define RFCOMM_CFC_UNKNOWN  -1
+#define RFCOMM_CFC_DISABLED 0
+#define RFCOMM_CFC_ENABLED  RFCOMM_MAX_CREDITS
+
 extern struct task_struct *rfcomm_thread;
 extern unsigned long rfcomm_event;
 
diff -purN linux-2.6.1/include/net/flow.h linux-2.5/include/net/flow.h
--- linux-2.6.1/include/net/flow.h	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/include/net/flow.h	2004-01-15 08:18:43.000000000 +0000
@@ -8,6 +8,7 @@
 #define _NET_FLOW_H
 
 #include <linux/in6.h>
+#include <asm/atomic.h>
 
 struct flowi {
 	int	oif;
diff -purN linux-2.6.1/include/net/if_inet6.h linux-2.5/include/net/if_inet6.h
--- linux-2.6.1/include/net/if_inet6.h	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/include/net/if_inet6.h	2004-01-15 09:01:34.000000000 +0000
@@ -25,6 +25,10 @@
 #define IF_RA_RCVD	0x20
 #define IF_RS_SENT	0x10
 
+/* prefix flags */
+#define IF_PREFIX_ONLINK	0x01
+#define IF_PREFIX_AUTOCONF	0x02
+
 #ifdef __KERNEL__
 
 struct inet6_ifaddr 
@@ -183,6 +187,7 @@ struct inet6_dev 
 	struct inet6_dev	*next;
 	struct ipv6_devconf	cnf;
 	struct ipv6_devstat	stats;
+	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
 };
 
 extern struct ipv6_devconf ipv6_devconf;
diff -purN linux-2.6.1/include/net/inet_common.h linux-2.5/include/net/inet_common.h
--- linux-2.6.1/include/net/inet_common.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/include/net/inet_common.h	2004-01-09 09:50:23.000000000 +0000
@@ -23,11 +23,11 @@ extern int			inet_accept(struct socket *
 extern int			inet_recvmsg(struct kiocb *iocb,
 					     struct socket *sock, 
 					     struct msghdr *ubuf, 
-					     int size, int flags);
+					     size_t size, int flags);
 extern int			inet_sendmsg(struct kiocb *iocb,
 					     struct socket *sock, 
 					     struct msghdr *msg, 
-					     int size);
+					     size_t size);
 extern int			inet_shutdown(struct socket *sock, int how);
 extern unsigned int		inet_poll(struct file * file, struct socket *sock, struct poll_table_struct *wait);
 extern int			inet_setsockopt(struct socket *sock, int level,
diff -purN linux-2.6.1/include/net/ipv6.h linux-2.5/include/net/ipv6.h
--- linux-2.6.1/include/net/ipv6.h	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/include/net/ipv6.h	2004-01-14 00:36:24.000000000 +0000
@@ -401,12 +401,8 @@ extern int			ipv6_getsockopt(struct sock
 
 extern void			ipv6_packet_init(void);
 
-extern void			ipv6_netdev_notif_init(void);
-
 extern void			ipv6_packet_cleanup(void);
 
-extern void			ipv6_netdev_notif_cleanup(void);
-
 extern int 			ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len);
 extern void			ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, u16 port,
 						u32 info, u8 *payload);
diff -purN linux-2.6.1/include/net/irda/ircomm_tty.h linux-2.5/include/net/irda/ircomm_tty.h
--- linux-2.6.1/include/net/irda/ircomm_tty.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/net/irda/ircomm_tty.h	2004-01-15 08:24:20.000000000 +0000
@@ -122,6 +122,9 @@ void ircomm_tty_stop(struct tty_struct *
 void ircomm_tty_check_modem_status(struct ircomm_tty_cb *self);
 
 extern void ircomm_tty_change_speed(struct ircomm_tty_cb *self);
+extern int ircomm_tty_tiocmget(struct tty_struct *tty, struct file *file);
+extern int ircomm_tty_tiocmset(struct tty_struct *tty, struct file *file,
+			       unsigned int set, unsigned int clear);
 extern int ircomm_tty_ioctl(struct tty_struct *tty, struct file *file, 
 			    unsigned int cmd, unsigned long arg);
 extern void ircomm_tty_set_termios(struct tty_struct *tty, 
diff -purN linux-2.6.1/include/net/irda/timer.h linux-2.5/include/net/irda/timer.h
--- linux-2.6.1/include/net/irda/timer.h	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/include/net/irda/timer.h	2004-01-09 10:08:28.000000000 +0000
@@ -40,14 +40,14 @@ struct lsap_cb;
 struct lap_cb;
 
 /* 
- *  Timeout definitions, some defined in IrLAP p. 92
+ *  Timeout definitions, some defined in IrLAP 6.13.5 - p. 92
  */
 #define POLL_TIMEOUT        (450*HZ/1000)    /* Must never exceed 500 ms */
 #define FINAL_TIMEOUT       (500*HZ/1000)    /* Must never exceed 500 ms */
 
 /* 
- *  Normally twice of p-timer. Note 3, IrLAP p. 60 suggests at least twice 
- *  duration of the P-timer.
+ *  Normally twice of p-timer. Note 3, IrLAP 6.3.11.2 - p. 60 suggests
+ *  at least twice duration of the P-timer.
  */
 #define WD_TIMEOUT          (POLL_TIMEOUT*2)
 
diff -purN linux-2.6.1/include/net/ndisc.h linux-2.5/include/net/ndisc.h
--- linux-2.6.1/include/net/ndisc.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/net/ndisc.h	2004-01-16 10:05:24.000000000 +0000
@@ -98,6 +98,17 @@ extern int			igmp6_event_report(struct s
 
 extern void			igmp6_cleanup(void);
 
+#ifdef CONFIG_SYSCTL
+extern int 			ndisc_ifinfo_sysctl_change(ctl_table *ctl,
+							   int write,
+							   struct file * filp,
+							   void __user *buffer,
+							   size_t *lenp);
+#endif
+
+extern void 			inet6_ifinfo_notify(int event,
+						    struct inet6_dev *idev);
+
 static inline struct neighbour * ndisc_get_neigh(struct net_device *dev, struct in6_addr *addr)
 {
 
diff -purN linux-2.6.1/include/net/neighbour.h linux-2.5/include/net/neighbour.h
--- linux-2.6.1/include/net/neighbour.h	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/include/net/neighbour.h	2004-01-15 08:58:09.000000000 +0000
@@ -47,6 +47,9 @@
 #include <linux/skbuff.h>
 
 #include <linux/err.h>
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+#endif
 
 #define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_DELAY|NUD_PROBE)
 #define NUD_VALID	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)
@@ -206,8 +209,11 @@ extern int neigh_add(struct sk_buff *skb
 extern int neigh_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 extern void neigh_app_ns(struct neighbour *n);
 
-extern int			neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,
-						      int p_id, int pdev_id, char *p_name);
+extern int			neigh_sysctl_register(struct net_device *dev, 
+						      struct neigh_parms *p,
+						      int p_id, int pdev_id,
+						      char *p_name,
+						      proc_handler *proc_handler);
 extern void			neigh_sysctl_unregister(struct neigh_parms *p);
 
 /*
diff -purN linux-2.6.1/include/net/sock.h linux-2.5/include/net/sock.h
--- linux-2.6.1/include/net/sock.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/include/net/sock.h	2004-01-15 09:21:55.000000000 +0000
@@ -304,7 +304,24 @@ static __inline__ int __sk_del_node_init
 	return 0;
 }
 
-static inline void __sock_put(struct sock *sk);
+/* Grab socket reference count. This operation is valid only
+   when sk is ALREADY grabbed f.e. it is found in hash table
+   or a list and the lookup is made under lock preventing hash table
+   modifications.
+ */
+
+static inline void sock_hold(struct sock *sk)
+{
+	atomic_inc(&sk->sk_refcnt);
+}
+
+/* Ungrab socket in the context, which assumes that socket refcnt
+   cannot hit zero, f.e. it is true in context of any socketcall.
+ */
+static inline void __sock_put(struct sock *sk)
+{
+	atomic_dec(&sk->sk_refcnt);
+}
 
 static __inline__ int sk_del_node_init(struct sock *sk)
 {
@@ -418,10 +435,10 @@ struct proto {
 					int optname, char *optval, 
 					int *option);  	 
 	int			(*sendmsg)(struct kiocb *iocb, struct sock *sk,
-					   struct msghdr *msg, int len);
+					   struct msghdr *msg, size_t len);
 	int			(*recvmsg)(struct kiocb *iocb, struct sock *sk,
 					   struct msghdr *msg,
-					int len, int noblock, int flags, 
+					size_t len, int noblock, int flags, 
 					int *addr_len);
 	int			(*sendpage)(struct sock *sk, struct page *page,
 					int offset, size_t size, int flags);
@@ -609,9 +626,9 @@ extern int			sock_no_getsockopt(struct s
 extern int			sock_no_setsockopt(struct socket *, int, int,
 						   char *, int);
 extern int                      sock_no_sendmsg(struct kiocb *, struct socket *,
-						struct msghdr *, int);
+						struct msghdr *, size_t);
 extern int                      sock_no_recvmsg(struct kiocb *, struct socket *,
-						struct msghdr *, int, int);
+						struct msghdr *, size_t, int);
 extern int			sock_no_mmap(struct file *file,
 					     struct socket *sock,
 					     struct vm_area_struct *vma);
@@ -722,25 +739,6 @@ static inline void sk_filter_charge(stru
  *   use separate SMP lock, so that they are prone too.
  */
 
-/* Grab socket reference count. This operation is valid only
-   when sk is ALREADY grabbed f.e. it is found in hash table
-   or a list and the lookup is made under lock preventing hash table
-   modifications.
- */
-
-static inline void sock_hold(struct sock *sk)
-{
-	atomic_inc(&sk->sk_refcnt);
-}
-
-/* Ungrab socket in the context, which assumes that socket refcnt
-   cannot hit zero, f.e. it is true in context of any socketcall.
- */
-static inline void __sock_put(struct sock *sk)
-{
-	atomic_dec(&sk->sk_refcnt);
-}
-
 /* Ungrab socket and destroy it, if it was the last reference. */
 static inline void sock_put(struct sock *sk)
 {
diff -purN linux-2.6.1/include/net/tcp.h linux-2.5/include/net/tcp.h
--- linux-2.6.1/include/net/tcp.h	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/include/net/tcp.h	2004-01-09 09:50:23.000000000 +0000
@@ -752,7 +752,7 @@ extern int			tcp_v4_remember_stamp(struc
 extern int		    	tcp_v4_tw_remember_stamp(struct tcp_tw_bucket *tw);
 
 extern int			tcp_sendmsg(struct kiocb *iocb, struct sock *sk,
-					    struct msghdr *msg, int size);
+					    struct msghdr *msg, size_t size);
 extern ssize_t			tcp_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags);
 
 extern int			tcp_ioctl(struct sock *sk, 
@@ -846,7 +846,7 @@ extern int			tcp_setsockopt(struct sock 
 extern void			tcp_set_keepalive(struct sock *sk, int val);
 extern int			tcp_recvmsg(struct kiocb *iocb, struct sock *sk,
 					    struct msghdr *msg,
-					    int len, int nonblock, 
+					    size_t len, int nonblock, 
 					    int flags, int *addr_len);
 
 extern int			tcp_listen_start(struct sock *sk);
diff -purN linux-2.6.1/include/net/udp.h linux-2.5/include/net/udp.h
--- linux-2.6.1/include/net/udp.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/net/udp.h	2004-01-09 09:50:23.000000000 +0000
@@ -68,7 +68,7 @@ extern int	udp_connect(struct sock *sk,
 			    struct sockaddr *usin, int addr_len);
 
 extern int	udp_sendmsg(struct kiocb *iocb, struct sock *sk,
-			    struct msghdr *msg, int len);
+			    struct msghdr *msg, size_t len);
 
 extern int	udp_rcv(struct sk_buff *skb);
 extern int	udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
diff -purN linux-2.6.1/include/scsi/scsi.h linux-2.5/include/scsi/scsi.h
--- linux-2.6.1/include/scsi/scsi.h	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/include/scsi/scsi.h	2004-01-10 19:04:26.000000000 +0000
@@ -302,7 +302,7 @@ struct scsi_lun {
 #define QUEUED          0x2004
 #define SOFT_ERROR      0x2005
 #define ADD_TO_MLQUEUE  0x2006
-#define TIMEOUT         0x2007
+#define TIMEOUT_ERROR   0x2007
 
 /*
  * Midlevel queue return values.
diff -purN linux-2.6.1/kernel/exit.c linux-2.5/kernel/exit.c
--- linux-2.6.1/kernel/exit.c	2004-01-09 06:59:57.000000000 +0000
+++ linux-2.5/kernel/exit.c	2004-01-15 20:38:35.000000000 +0000
@@ -529,7 +529,8 @@ static inline void reparent_thread(task_
 	p->self_exec_id++;
 
 	if (p->pdeath_signal)
-		send_group_sig_info(p->pdeath_signal, 0, p);
+		/* We already hold the tasklist_lock here.  */
+		group_send_sig_info(p->pdeath_signal, (void *) 0, p);
 
 	/* Move the child from its dying parent to the new one.  */
 	if (unlikely(traced)) {
diff -purN linux-2.6.1/mm/mremap.c linux-2.5/mm/mremap.c
--- linux-2.6.1/mm/mremap.c	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/mm/mremap.c	2004-01-13 01:11:25.000000000 +0000
@@ -315,8 +315,12 @@ unsigned long do_mremap(unsigned long ad
 	old_len = PAGE_ALIGN(old_len);
 	new_len = PAGE_ALIGN(new_len);
 
-	/* Don't allow the degenerate cases */
-	if (!old_len || !new_len)
+	/*
+	 * We allow a zero old-len as a special case
+	 * for DOS-emu "duplicate shm area" thing. But
+	 * a zero new-len is nonsensical.
+	 */
+	if (!new_len)
 		goto out;
 
 	/* new_addr is only valid if MREMAP_FIXED is specified */
diff -purN linux-2.6.1/net/appletalk/ddp.c linux-2.5/net/appletalk/ddp.c
--- linux-2.6.1/net/appletalk/ddp.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/net/appletalk/ddp.c	2004-01-09 09:52:10.000000000 +0000
@@ -1552,7 +1552,7 @@ freeit:
 }
 
 static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-			 int len)
+			 size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct atalk_sock *at = at_sk(sk);
@@ -1712,7 +1712,7 @@ static int atalk_sendmsg(struct kiocb *i
 }
 
 static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-			 int size, int flags)
+			 size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;
diff -purN linux-2.6.1/net/atm/br2684.c linux-2.5/net/atm/br2684.c
--- linux-2.6.1/net/atm/br2684.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/atm/br2684.c	2004-01-09 10:00:03.000000000 +0000
@@ -437,6 +437,10 @@ static void br2684_push(struct atm_vcc *
 			dev_kfree_skb(skb);
 			return;
 		}
+
+		/* Strip FCS if present */
+		if (skb->len > 7 && skb->data[7] == 0x01)
+			__skb_trim(skb, skb->len - 4);
 	} else {
 		plen = PADLEN + ETH_HLEN;	/* pad, dstmac,srcmac, ethtype */
 		/* first 2 chars should be 0 */
diff -purN linux-2.6.1/net/atm/clip.c linux-2.5/net/atm/clip.c
--- linux-2.6.1/net/atm/clip.c	2004-01-09 07:00:04.000000000 +0000
+++ linux-2.5/net/atm/clip.c	2004-01-15 23:03:38.000000000 +0000
@@ -731,8 +731,6 @@ static struct atm_dev atmarpd_dev = {
 
 static int atm_init_atmarp(struct atm_vcc *vcc)
 {
-	struct net_device *dev;
-
 	if (atmarpd) return -EADDRINUSE;
 	if (start_timer) {
 		start_timer = 0;
@@ -754,9 +752,6 @@ static int atm_init_atmarp(struct atm_vc
 		printk(KERN_ERR "register_netdevice_notifier failed\n");
 	if (register_inetaddr_notifier(&clip_inet_notifier))
 		printk(KERN_ERR "register_inetaddr_notifier failed\n");
-	for (dev = clip_devs; dev; dev = PRIV(dev)->next)
-		if (dev->flags & IFF_UP)
-			(void) to_atmarpd(act_up,PRIV(dev)->number,0);
 	return 0;
 }
 
diff -purN linux-2.6.1/net/atm/common.c linux-2.5/net/atm/common.c
--- linux-2.6.1/net/atm/common.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/net/atm/common.c	2004-01-15 08:21:08.000000000 +0000
@@ -463,7 +463,7 @@ int vcc_connect(struct socket *sock, int
 
 
 int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		int size, int flags)
+		size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct atm_vcc *vcc;
@@ -476,9 +476,8 @@ int vcc_recvmsg(struct kiocb *iocb, stru
 		return -EOPNOTSUPP;
 	vcc = ATM_SD(sock);
 	if (test_bit(ATM_VF_RELEASED,&vcc->flags) ||
-	    test_bit(ATM_VF_CLOSE,&vcc->flags))
-		return -sk->sk_err;
-	if (!test_bit(ATM_VF_READY, &vcc->flags))
+	    test_bit(ATM_VF_CLOSE,&vcc->flags) ||
+	    !test_bit(ATM_VF_READY, &vcc->flags))
 		return 0;
 
 	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);
@@ -503,7 +502,7 @@ int vcc_recvmsg(struct kiocb *iocb, stru
 
 
 int vcc_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		int total_len)
+		size_t total_len)
 {
 	struct sock *sk = sock->sk;
 	DEFINE_WAIT(wait);
@@ -530,12 +529,10 @@ int vcc_sendmsg(struct kiocb *iocb, stru
 	size = m->msg_iov->iov_len;
 	vcc = ATM_SD(sock);
 	if (test_bit(ATM_VF_RELEASED, &vcc->flags) ||
-	    test_bit(ATM_VF_CLOSE, &vcc->flags)) {
-		error = -sk->sk_err;
-		goto out;
-	}
-	if (!test_bit(ATM_VF_READY, &vcc->flags)) {
+	    test_bit(ATM_VF_CLOSE, &vcc->flags) ||
+	    !test_bit(ATM_VF_READY, &vcc->flags)) {
 		error = -EPIPE;
+		send_sig(SIGPIPE, current, 0);
 		goto out;
 	}
 	if (!size) {
@@ -561,12 +558,10 @@ int vcc_sendmsg(struct kiocb *iocb, stru
 			break;
 		}
 		if (test_bit(ATM_VF_RELEASED,&vcc->flags) ||
-		    test_bit(ATM_VF_CLOSE,&vcc->flags)) {
-			error = -sk->sk_err;
-			break;
-		}
-		if (!test_bit(ATM_VF_READY,&vcc->flags)) {
+		    test_bit(ATM_VF_CLOSE,&vcc->flags) ||
+		    !test_bit(ATM_VF_READY,&vcc->flags)) {
 			error = -EPIPE;
+			send_sig(SIGPIPE, current, 0);
 			break;
 		}
 		prepare_to_wait(sk->sk_sleep, &wait, TASK_INTERRUPTIBLE);
diff -purN linux-2.6.1/net/atm/common.h linux-2.5/net/atm/common.h
--- linux-2.6.1/net/atm/common.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/net/atm/common.h	2004-01-09 09:52:41.000000000 +0000
@@ -14,9 +14,9 @@ int vcc_create(struct socket *sock, int 
 int vcc_release(struct socket *sock);
 int vcc_connect(struct socket *sock, int itf, short vpi, int vci);
 int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		int size, int flags);
+		size_t size, int flags);
 int vcc_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		int total_len);
+		size_t total_len);
 unsigned int vcc_poll(struct file *file, struct socket *sock, poll_table *wait);
 int vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 int vcc_setsockopt(struct socket *sock, int level, int optname, char *optval,
diff -purN linux-2.6.1/net/ax25/af_ax25.c linux-2.5/net/ax25/af_ax25.c
--- linux-2.6.1/net/ax25/af_ax25.c	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/net/ax25/af_ax25.c	2004-01-09 09:53:04.000000000 +0000
@@ -1401,7 +1401,7 @@ out:
 }
 
 static int ax25_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sockaddr_ax25 *usax = (struct sockaddr_ax25 *)msg->msg_name;
 	struct sock *sk = sock->sk;
@@ -1410,7 +1410,8 @@ static int ax25_sendmsg(struct kiocb *io
 	ax25_digi dtmp, *dp;
 	unsigned char *asmptr;
 	ax25_cb *ax25;
-	int lv, size, err, addr_len = msg->msg_namelen;
+	size_t size;
+	int lv, err, addr_len = msg->msg_namelen;
 
 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR)) {
 		return -EINVAL;
@@ -1435,6 +1436,11 @@ static int ax25_sendmsg(struct kiocb *io
 		goto out;
 	}
 
+	if (len > ax25->ax25_dev->dev->mtu) {
+		err = -EMSGSIZE;
+		goto out;
+	}
+		
 	if (usax != NULL) {
 		if (usax->sax25_family != AF_AX25) {
 			err = -EINVAL;
@@ -1580,7 +1586,7 @@ out:
 }
 
 static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int size, int flags)
+	struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
diff -purN linux-2.6.1/net/bluetooth/Kconfig linux-2.5/net/bluetooth/Kconfig
--- linux-2.6.1/net/bluetooth/Kconfig	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/bluetooth/Kconfig	2003-12-20 00:10:33.000000000 +0000
@@ -21,6 +21,7 @@ config BT
 	     SCO Module (SCO links)
 	     RFCOMM Module (RFCOMM protocol)  
 	     BNEP Module (BNEP protocol)
+	     CMTP Module (CMTP protocol)
 
 	  Say Y here to enable Linux Bluetooth support and to build Bluetooth Core
 	  layer.
@@ -57,6 +58,8 @@ source "net/bluetooth/rfcomm/Kconfig"
 
 source "net/bluetooth/bnep/Kconfig"
 
+source "net/bluetooth/cmtp/Kconfig"
+
 source "drivers/bluetooth/Kconfig"
 
 endmenu
diff -purN linux-2.6.1/net/bluetooth/Makefile linux-2.5/net/bluetooth/Makefile
--- linux-2.6.1/net/bluetooth/Makefile	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/bluetooth/Makefile	2003-12-20 00:10:34.000000000 +0000
@@ -7,5 +7,6 @@ obj-$(CONFIG_BT_L2CAP)	+= l2cap.o
 obj-$(CONFIG_BT_SCO)	+= sco.o
 obj-$(CONFIG_BT_RFCOMM)	+= rfcomm/
 obj-$(CONFIG_BT_BNEP)	+= bnep/
+obj-$(CONFIG_BT_CMTP)	+= cmtp/
 
 bluetooth-objs := af_bluetooth.o hci_core.o hci_conn.o hci_event.o hci_sock.o hci_proc.o lib.o syms.o
diff -purN linux-2.6.1/net/bluetooth/af_bluetooth.c linux-2.5/net/bluetooth/af_bluetooth.c
--- linux-2.6.1/net/bluetooth/af_bluetooth.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/bluetooth/af_bluetooth.c	2004-01-14 20:56:53.000000000 +0000
@@ -59,7 +59,7 @@
 struct proc_dir_entry *proc_bt;
 
 /* Bluetooth sockets */
-#define BT_MAX_PROTO	5
+#define BT_MAX_PROTO	6
 static struct net_proto_family *bt_proto[BT_MAX_PROTO];
 
 static kmem_cache_t *bt_sock_cache;
@@ -201,12 +201,13 @@ struct sock *bt_accept_dequeue(struct so
 }
 
 int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int len, int flags)
+	struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	BT_DBG("sock %p sk %p len %d", sock, sk, len);
 
diff -purN linux-2.6.1/net/bluetooth/bnep/core.c linux-2.5/net/bluetooth/bnep/core.c
--- linux-2.6.1/net/bluetooth/bnep/core.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/net/bluetooth/bnep/core.c	2004-01-14 21:01:55.000000000 +0000
@@ -707,3 +707,4 @@ module_exit(bnep_cleanup_module);
 MODULE_DESCRIPTION("Bluetooth BNEP ver " VERSION);
 MODULE_AUTHOR("David Libault <david.libault@inventel.fr>, Maxim Krasnyanskiy <maxk@qualcomm.com>");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("bt-proto-4");
diff -purN linux-2.6.1/net/bluetooth/cmtp/Kconfig linux-2.5/net/bluetooth/cmtp/Kconfig
--- linux-2.6.1/net/bluetooth/cmtp/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/Kconfig	2003-12-20 00:10:33.000000000 +0000
@@ -0,0 +1,11 @@
+config BT_CMTP
+	tristate "CMTP protocol support"
+	depends on BT && BT_L2CAP && ISDN_CAPI
+	help
+	  CMTP (CAPI Message Transport Protocol) is a transport layer
+	  for CAPI messages. CMTP is required for the Bluetooth Common
+	  ISDN Access Profile.
+
+	  Say Y here to compile CMTP support into the kernel or say M to
+	  compile it as module (cmtp).
+
diff -purN linux-2.6.1/net/bluetooth/cmtp/Makefile linux-2.5/net/bluetooth/cmtp/Makefile
--- linux-2.6.1/net/bluetooth/cmtp/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/Makefile	2003-12-20 00:10:33.000000000 +0000
@@ -0,0 +1,7 @@
+#
+# Makefile for the Linux Bluetooth CMTP layer
+#
+
+obj-$(CONFIG_BT_CMTP) += cmtp.o
+
+cmtp-objs := core.o sock.o capi.o
diff -purN linux-2.6.1/net/bluetooth/cmtp/capi.c linux-2.5/net/bluetooth/cmtp/capi.c
--- linux-2.6.1/net/bluetooth/cmtp/capi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/capi.c	2003-12-22 11:00:47.000000000 +0000
@@ -0,0 +1,630 @@
+/* 
+   CMTP implementation for Linux Bluetooth stack (BlueZ).
+   Copyright (C) 2002-2003 Marcel Holtmann <marcel@holtmann.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/fcntl.h>
+#include <linux/skbuff.h>
+#include <linux/socket.h>
+#include <linux/ioctl.h>
+#include <linux/file.h>
+#include <net/sock.h>
+
+#include <linux/isdn/capilli.h>
+#include <linux/isdn/capicmd.h>
+#include <linux/isdn/capiutil.h>
+
+#include "cmtp.h"
+
+#ifndef CONFIG_BT_CMTP_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define CAPI_INTEROPERABILITY		0x20
+
+#define CAPI_INTEROPERABILITY_REQ	CAPICMD(CAPI_INTEROPERABILITY, CAPI_REQ)
+#define CAPI_INTEROPERABILITY_CONF	CAPICMD(CAPI_INTEROPERABILITY, CAPI_CONF)
+#define CAPI_INTEROPERABILITY_IND	CAPICMD(CAPI_INTEROPERABILITY, CAPI_IND)
+#define CAPI_INTEROPERABILITY_RESP	CAPICMD(CAPI_INTEROPERABILITY, CAPI_RESP)
+
+#define CAPI_INTEROPERABILITY_REQ_LEN	(CAPI_MSG_BASELEN + 2)
+#define CAPI_INTEROPERABILITY_CONF_LEN	(CAPI_MSG_BASELEN + 4)
+#define CAPI_INTEROPERABILITY_IND_LEN	(CAPI_MSG_BASELEN + 2)
+#define CAPI_INTEROPERABILITY_RESP_LEN	(CAPI_MSG_BASELEN + 2)
+
+#define CAPI_FUNCTION_REGISTER		0
+#define CAPI_FUNCTION_RELEASE		1
+#define CAPI_FUNCTION_GET_PROFILE	2
+#define CAPI_FUNCTION_GET_MANUFACTURER	3
+#define CAPI_FUNCTION_GET_VERSION	4
+#define CAPI_FUNCTION_GET_SERIAL_NUMBER	5
+#define CAPI_FUNCTION_MANUFACTURER	6
+#define CAPI_FUNCTION_LOOPBACK		7
+
+
+#define CMTP_MSGNUM	1
+#define CMTP_APPLID	2
+#define CMTP_MAPPING	3
+
+static struct cmtp_application *cmtp_application_add(struct cmtp_session *session, __u16 appl)
+{
+	struct cmtp_application *app = kmalloc(sizeof(*app), GFP_KERNEL);
+
+	BT_DBG("session %p application %p appl %d", session, app, appl);
+
+	if (!app)
+		return NULL;
+
+	memset(app, 0, sizeof(*app));
+
+	app->state = BT_OPEN;
+	app->appl = appl;
+
+	list_add_tail(&app->list, &session->applications);
+
+	return app;
+}
+
+static void cmtp_application_del(struct cmtp_session *session, struct cmtp_application *app)
+{
+	BT_DBG("session %p application %p", session, app);
+
+	if (app) {
+		list_del(&app->list);
+		kfree(app);
+	}
+}
+
+static struct cmtp_application *cmtp_application_get(struct cmtp_session *session, int pattern, __u16 value)
+{
+	struct cmtp_application *app;
+	struct list_head *p, *n;
+
+	list_for_each_safe(p, n, &session->applications) {
+		app = list_entry(p, struct cmtp_application, list);
+		switch (pattern) {
+		case CMTP_MSGNUM:
+			if (app->msgnum == value)
+				return app;
+			break;
+		case CMTP_APPLID:
+			if (app->appl == value)
+				return app;
+			break;
+		case CMTP_MAPPING:
+			if (app->mapping == value)
+				return app;
+			break;
+		}
+	}
+
+	return NULL;
+}
+
+static int cmtp_msgnum_get(struct cmtp_session *session)
+{
+	session->msgnum++;
+
+	if ((session->msgnum & 0xff) > 200)
+		session->msgnum = CMTP_INITIAL_MSGNUM + 1;
+
+	return session->msgnum;
+}
+
+
+static void cmtp_send_interopmsg(struct cmtp_session *session,
+					__u8 subcmd, __u16 appl, __u16 msgnum,
+					__u16 function, unsigned char *buf, int len)
+{
+	struct sk_buff *skb;
+	unsigned char *s;
+
+	BT_DBG("session %p subcmd 0x%02x appl %d msgnum %d", session, subcmd, appl, msgnum);
+
+	if (!(skb = alloc_skb(CAPI_MSG_BASELEN + 6 + len, GFP_ATOMIC))) {
+		BT_ERR("Can't allocate memory for interoperability packet");
+		return;
+	}
+
+	s = skb_put(skb, CAPI_MSG_BASELEN + 6 + len);
+
+	capimsg_setu16(s, 0, CAPI_MSG_BASELEN + 6 + len);
+	capimsg_setu16(s, 2, appl);
+	capimsg_setu8 (s, 4, CAPI_INTEROPERABILITY);
+	capimsg_setu8 (s, 5, subcmd);
+	capimsg_setu16(s, 6, msgnum);
+
+	/* Interoperability selector (Bluetooth Device Management) */
+	capimsg_setu16(s, 8, 0x0001);
+
+	capimsg_setu8 (s, 10, 3 + len);
+	capimsg_setu16(s, 11, function);
+	capimsg_setu8 (s, 13, len);
+
+	if (len > 0)
+		memcpy(s + 14, buf, len);
+
+	cmtp_send_capimsg(session, skb);
+}
+
+static void cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb)
+{
+	struct capi_ctr *ctrl = &session->ctrl;
+	struct cmtp_application *application;
+	__u16 appl, msgnum, func, info;
+	__u32 controller;
+
+	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
+
+	switch (CAPIMSG_SUBCOMMAND(skb->data)) {
+	case CAPI_CONF:
+		func = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 5);
+		info = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 8);
+
+		switch (func) {
+		case CAPI_FUNCTION_REGISTER:
+			msgnum = CAPIMSG_MSGID(skb->data);
+
+			application = cmtp_application_get(session, CMTP_MSGNUM, msgnum);
+			if (application) {
+				application->state = BT_CONNECTED;
+				application->msgnum = 0;
+				application->mapping = CAPIMSG_APPID(skb->data);
+				wake_up_interruptible(&session->wait);
+			}
+
+			break;
+
+		case CAPI_FUNCTION_RELEASE:
+			appl = CAPIMSG_APPID(skb->data);
+
+			application = cmtp_application_get(session, CMTP_MAPPING, appl);
+			if (application) {
+				application->state = BT_CLOSED;
+				application->msgnum = 0;
+				wake_up_interruptible(&session->wait);
+			}
+
+			break;
+
+		case CAPI_FUNCTION_GET_PROFILE:
+			controller = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 11);
+			msgnum = CAPIMSG_MSGID(skb->data);
+
+			if (!info && (msgnum == CMTP_INITIAL_MSGNUM)) {
+				session->ncontroller = controller;
+				wake_up_interruptible(&session->wait);
+				break;
+			}
+
+			if (!info && ctrl) {
+				memcpy(&ctrl->profile,
+					skb->data + CAPI_MSG_BASELEN + 11,
+					sizeof(capi_profile));
+				session->state = BT_CONNECTED;
+				capi_ctr_ready(ctrl);
+			}
+
+			break;
+
+		case CAPI_FUNCTION_GET_MANUFACTURER:
+			controller = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 10);
+
+			if (!info && ctrl) {
+				strncpy(ctrl->manu,
+					skb->data + CAPI_MSG_BASELEN + 15,
+					skb->data[CAPI_MSG_BASELEN + 14]);
+			}
+
+			break;
+
+		case CAPI_FUNCTION_GET_VERSION:
+			controller = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 12);
+
+			if (!info && ctrl) {
+				ctrl->version.majorversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 16);
+				ctrl->version.minorversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 20);
+				ctrl->version.majormanuversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 24);
+				ctrl->version.minormanuversion = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 28);
+			}
+
+			break;
+
+		case CAPI_FUNCTION_GET_SERIAL_NUMBER:
+			controller = CAPIMSG_U32(skb->data, CAPI_MSG_BASELEN + 12);
+
+			if (!info && ctrl) {
+				memset(ctrl->serial, 0, CAPI_SERIAL_LEN);
+				strncpy(ctrl->serial,
+					skb->data + CAPI_MSG_BASELEN + 17,
+					skb->data[CAPI_MSG_BASELEN + 16]);
+			}
+
+			break;
+		}
+
+		break;
+
+	case CAPI_IND:
+		func = CAPIMSG_U16(skb->data, CAPI_MSG_BASELEN + 3);
+
+		if (func == CAPI_FUNCTION_LOOPBACK) {
+			appl = CAPIMSG_APPID(skb->data);
+			msgnum = CAPIMSG_MSGID(skb->data);
+			cmtp_send_interopmsg(session, CAPI_RESP, appl, msgnum, func,
+						skb->data + CAPI_MSG_BASELEN + 6,
+						skb->data[CAPI_MSG_BASELEN + 5]);
+		}
+
+		break;
+	}
+
+	kfree_skb(skb);
+}
+
+void cmtp_recv_capimsg(struct cmtp_session *session, struct sk_buff *skb)
+{
+	struct capi_ctr *ctrl = &session->ctrl;
+	struct cmtp_application *application;
+	__u16 cmd, appl;
+	__u32 contr;
+
+	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
+
+	if (CAPIMSG_COMMAND(skb->data) == CAPI_INTEROPERABILITY) {
+		cmtp_recv_interopmsg(session, skb);
+		return;
+	}
+
+	if (session->flags & (1 << CMTP_LOOPBACK)) {
+		kfree_skb(skb);
+		return;
+	}
+
+	cmd = CAPICMD(CAPIMSG_COMMAND(skb->data), CAPIMSG_SUBCOMMAND(skb->data));
+	appl = CAPIMSG_APPID(skb->data);
+	contr = CAPIMSG_CONTROL(skb->data);
+
+	application = cmtp_application_get(session, CMTP_MAPPING, appl);
+	if (application) {
+		appl = application->appl;
+		CAPIMSG_SETAPPID(skb->data, appl);
+	} else {
+		BT_ERR("Can't find application with id %d", appl);
+		kfree_skb(skb);
+		return;
+	}
+
+	if ((contr & 0x7f) == 0x01) {
+		contr = (contr & 0xffffff80) | session->num;
+		CAPIMSG_SETCONTROL(skb->data, contr);
+	}
+
+	if (!ctrl) {
+		BT_ERR("Can't find controller %d for message", session->num);
+		kfree_skb(skb);
+		return;
+	}
+
+	capi_ctr_handle_message(ctrl, appl, skb);
+}
+
+void cmtp_send_capimsg(struct cmtp_session *session, struct sk_buff *skb)
+{
+	struct cmtp_scb *scb = (void *) skb->cb;
+
+	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
+
+	scb->id = -1;
+	scb->data = (CAPIMSG_COMMAND(skb->data) == CAPI_DATA_B3);
+
+	skb_queue_tail(&session->transmit, skb);
+
+	cmtp_schedule(session);
+}
+
+
+static int cmtp_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)
+{
+	BT_DBG("ctrl %p data %p", ctrl, data);
+
+	return 0;
+}
+
+static void cmtp_reset_ctr(struct capi_ctr *ctrl)
+{
+	struct cmtp_session *session = ctrl->driverdata;
+
+	BT_DBG("ctrl %p", ctrl);
+
+	capi_ctr_reseted(ctrl);
+
+	atomic_inc(&session->terminate);
+	cmtp_schedule(session);
+}
+
+static void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_params *rp)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct cmtp_session *session = ctrl->driverdata;
+	struct cmtp_application *application;
+	unsigned long timeo = CMTP_INTEROP_TIMEOUT;
+	unsigned char buf[8];
+	int err = 0, nconn, want = rp->level3cnt;
+
+	BT_DBG("ctrl %p appl %d level3cnt %d datablkcnt %d datablklen %d",
+		ctrl, appl, rp->level3cnt, rp->datablkcnt, rp->datablklen);
+
+	application = cmtp_application_add(session, appl);
+	if (!application) {
+		BT_ERR("Can't allocate memory for new application");
+		return;
+	}
+
+	if (want < 0)
+		nconn = ctrl->profile.nbchannel * -want;
+	else
+		nconn = want;
+
+	if (nconn == 0)
+		nconn = ctrl->profile.nbchannel;
+
+	capimsg_setu16(buf, 0, nconn);
+	capimsg_setu16(buf, 2, rp->datablkcnt);
+	capimsg_setu16(buf, 4, rp->datablklen);
+
+	application->state = BT_CONFIG;
+	application->msgnum = cmtp_msgnum_get(session);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0x0000, application->msgnum,
+				CAPI_FUNCTION_REGISTER, buf, 6);
+
+	add_wait_queue(&session->wait, &wait);
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (!timeo) {
+			err = -EAGAIN;
+			break;
+		}
+
+		if (application->state == BT_CLOSED) {
+			err = -application->err;
+			break;
+		}
+
+		if (application->state == BT_CONNECTED)
+			break;
+
+		if (signal_pending(current)) {
+			err = -EINTR;
+			break;
+		}
+
+		timeo = schedule_timeout(timeo);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&session->wait, &wait);
+
+	if (err) {
+		cmtp_application_del(session, application);
+		return;
+	}
+}
+
+static void cmtp_release_appl(struct capi_ctr *ctrl, __u16 appl)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct cmtp_session *session = ctrl->driverdata;
+	struct cmtp_application *application;
+	unsigned long timeo = CMTP_INTEROP_TIMEOUT;
+
+	BT_DBG("ctrl %p appl %d", ctrl, appl);
+
+	application = cmtp_application_get(session, CMTP_APPLID, appl);
+	if (!application) {
+		BT_ERR("Can't find application");
+		return;
+	}
+
+	application->msgnum = cmtp_msgnum_get(session);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, application->mapping, application->msgnum,
+				CAPI_FUNCTION_RELEASE, NULL, 0);
+
+	add_wait_queue(&session->wait, &wait);
+	while (timeo) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (application->state == BT_CLOSED)
+			break;
+
+		if (signal_pending(current))
+			break;
+
+		timeo = schedule_timeout(timeo);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&session->wait, &wait);
+
+	cmtp_application_del(session, application);
+}
+
+static u16 cmtp_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)
+{
+	struct cmtp_session *session = ctrl->driverdata;
+	struct cmtp_application *application;
+	__u16 appl;
+	__u32 contr;
+
+	BT_DBG("ctrl %p skb %p", ctrl, skb);
+
+	appl = CAPIMSG_APPID(skb->data);
+	contr = CAPIMSG_CONTROL(skb->data);
+
+	application = cmtp_application_get(session, CMTP_APPLID, appl);
+	if ((!application) || (application->state != BT_CONNECTED)) {
+		BT_ERR("Can't find application with id %d", appl);
+		kfree_skb(skb);
+		return CAPI_ILLAPPNR;
+	}
+
+	CAPIMSG_SETAPPID(skb->data, application->mapping);
+
+	if ((contr & 0x7f) == session->num) {
+		contr = (contr & 0xffffff80) | 0x01;
+		CAPIMSG_SETCONTROL(skb->data, contr);
+	}
+
+	cmtp_send_capimsg(session, skb);
+
+	return CAPI_NOERROR;
+}
+
+static char *cmtp_procinfo(struct capi_ctr *ctrl)
+{
+	return "CAPI Message Transport Protocol";
+}
+
+static int cmtp_ctr_read_proc(char *page, char **start, off_t off, int count, int *eof, struct capi_ctr *ctrl)
+{
+	struct cmtp_session *session = ctrl->driverdata;
+	struct cmtp_application *app;
+	struct list_head *p, *n;
+	int len = 0;
+
+	len += sprintf(page + len, "%s\n\n", cmtp_procinfo(ctrl));
+	len += sprintf(page + len, "addr %s\n", session->name);
+	len += sprintf(page + len, "ctrl %d\n", session->num);
+
+	list_for_each_safe(p, n, &session->applications) {
+		app = list_entry(p, struct cmtp_application, list);
+		len += sprintf(page + len, "appl %d -> %d\n", app->appl, app->mapping);
+	}
+
+	if (off + count >= len)
+		*eof = 1;
+
+	if (len < off)
+		return 0;
+
+	*start = page + off;
+
+	return ((count < len - off) ? count : len - off);
+}
+
+
+int cmtp_attach_device(struct cmtp_session *session)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long timeo = CMTP_INTEROP_TIMEOUT;
+	unsigned char buf[4];
+
+	BT_DBG("session %p", session);
+
+	capimsg_setu32(buf, 0, 0);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0xffff, CMTP_INITIAL_MSGNUM,
+				CAPI_FUNCTION_GET_PROFILE, buf, 4);
+
+	add_wait_queue(&session->wait, &wait);
+	while (timeo) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (session->ncontroller)
+			break;
+
+		if (signal_pending(current))
+			break;
+
+		timeo = schedule_timeout(timeo);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&session->wait, &wait);
+
+	BT_INFO("Found %d CAPI controller(s) on device %s", session->ncontroller, session->name);
+
+	if (!timeo)
+		return -ETIMEDOUT;
+
+	if (!session->ncontroller)
+		return -ENODEV;
+
+
+	if (session->ncontroller > 1)
+		BT_INFO("Setting up only CAPI controller 1");
+
+	session->ctrl.owner      = THIS_MODULE;
+	session->ctrl.driverdata = session;
+	strcpy(session->ctrl.name, session->name);
+
+	session->ctrl.driver_name   = "cmtp";
+	session->ctrl.load_firmware = cmtp_load_firmware;
+	session->ctrl.reset_ctr     = cmtp_reset_ctr;
+	session->ctrl.register_appl = cmtp_register_appl;
+	session->ctrl.release_appl  = cmtp_release_appl;
+	session->ctrl.send_message  = cmtp_send_message;
+
+	session->ctrl.procinfo      = cmtp_procinfo;
+	session->ctrl.ctr_read_proc = cmtp_ctr_read_proc;
+
+	if (attach_capi_ctr(&session->ctrl) < 0) {
+		BT_ERR("Can't attach new controller");
+		return -EBUSY;
+	}
+
+	session->num = session->ctrl.cnr;
+
+	BT_DBG("session %p num %d", session, session->num);
+
+	capimsg_setu32(buf, 0, 1);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),
+				CAPI_FUNCTION_GET_MANUFACTURER, buf, 4);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),
+				CAPI_FUNCTION_GET_VERSION, buf, 4);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),
+				CAPI_FUNCTION_GET_SERIAL_NUMBER, buf, 4);
+
+	cmtp_send_interopmsg(session, CAPI_REQ, 0xffff, cmtp_msgnum_get(session),
+				CAPI_FUNCTION_GET_PROFILE, buf, 4);
+
+	return 0;
+}
+
+void cmtp_detach_device(struct cmtp_session *session)
+{
+	BT_DBG("session %p", session);
+
+	detach_capi_ctr(&session->ctrl);
+}
diff -purN linux-2.6.1/net/bluetooth/cmtp/cmtp.h linux-2.5/net/bluetooth/cmtp/cmtp.h
--- linux-2.6.1/net/bluetooth/cmtp/cmtp.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/cmtp.h	2003-12-22 11:01:02.000000000 +0000
@@ -0,0 +1,136 @@
+/* 
+   CMTP implementation for Linux Bluetooth stack (BlueZ).
+   Copyright (C) 2002-2003 Marcel Holtmann <marcel@holtmann.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __CMTP_H
+#define __CMTP_H
+
+#include <linux/types.h>
+#include <net/bluetooth/bluetooth.h>
+
+#define BTNAMSIZ 18
+
+/* CMTP ioctl defines */
+#define CMTPCONNADD	_IOW('C', 200, int)
+#define CMTPCONNDEL	_IOW('C', 201, int)
+#define CMTPGETCONNLIST	_IOR('C', 210, int)
+#define CMTPGETCONNINFO	_IOR('C', 211, int)
+
+#define CMTP_LOOPBACK	0
+
+struct cmtp_connadd_req {
+	int   sock;	// Connected socket
+	__u32 flags;
+};
+
+struct cmtp_conndel_req {
+	bdaddr_t bdaddr;
+	__u32    flags;
+};
+
+struct cmtp_conninfo {
+	bdaddr_t bdaddr;
+	__u32    flags;
+	__u16    state;
+	int      num;
+};
+
+struct cmtp_connlist_req {
+	__u32  cnum;
+	struct cmtp_conninfo *ci;
+};
+
+int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock);
+int cmtp_del_connection(struct cmtp_conndel_req *req);
+int cmtp_get_connlist(struct cmtp_connlist_req *req);
+int cmtp_get_conninfo(struct cmtp_conninfo *ci);
+
+/* CMTP session defines */
+#define CMTP_INTEROP_TIMEOUT	(HZ * 5)
+#define CMTP_INITIAL_MSGNUM	0xff00
+
+struct cmtp_session {
+	struct list_head list;
+
+	struct socket *sock;
+
+	bdaddr_t bdaddr;
+
+	unsigned long state;
+	unsigned long flags;
+
+	uint mtu;
+
+	char name[BTNAMSIZ];
+
+	atomic_t terminate;
+
+	wait_queue_head_t wait;
+
+	int ncontroller;
+	int num;
+	struct capi_ctr ctrl;
+
+	struct list_head applications;
+
+	unsigned long blockids;
+	int msgnum;
+
+	struct sk_buff_head transmit;
+
+	struct sk_buff *reassembly[16];
+};
+
+struct cmtp_application {
+	struct list_head list;
+
+	unsigned long state;
+	int err;
+
+	__u16 appl;
+	__u16 mapping;
+
+	__u16 msgnum;
+};
+
+struct cmtp_scb {
+	int id;
+	int data;
+};
+
+int  cmtp_attach_device(struct cmtp_session *session);
+void cmtp_detach_device(struct cmtp_session *session);
+
+void cmtp_recv_capimsg(struct cmtp_session *session, struct sk_buff *skb);
+void cmtp_send_capimsg(struct cmtp_session *session, struct sk_buff *skb);
+
+static inline void cmtp_schedule(struct cmtp_session *session)
+{
+	struct sock *sk = session->sock->sk;
+
+	wake_up_interruptible(sk->sk_sleep);
+}
+
+/* CMTP init defines */
+int cmtp_init_sockets(void);
+void cmtp_cleanup_sockets(void);
+
+#endif /* __CMTP_H */
diff -purN linux-2.6.1/net/bluetooth/cmtp/core.c linux-2.5/net/bluetooth/cmtp/core.c
--- linux-2.6.1/net/bluetooth/cmtp/core.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/core.c	2003-12-22 11:01:16.000000000 +0000
@@ -0,0 +1,507 @@
+/* 
+   CMTP implementation for Linux Bluetooth stack (BlueZ).
+   Copyright (C) 2002-2003 Marcel Holtmann <marcel@holtmann.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/fcntl.h>
+#include <linux/skbuff.h>
+#include <linux/socket.h>
+#include <linux/ioctl.h>
+#include <linux/file.h>
+#include <linux/init.h>
+#include <net/sock.h>
+
+#include <linux/isdn/capilli.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/l2cap.h>
+
+#include "cmtp.h"
+
+#ifndef CONFIG_BT_CMTP_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+#define VERSION "1.0"
+
+static DECLARE_RWSEM(cmtp_session_sem);
+static LIST_HEAD(cmtp_session_list);
+
+static struct cmtp_session *__cmtp_get_session(bdaddr_t *bdaddr)
+{
+	struct cmtp_session *session;
+	struct list_head *p;
+
+	BT_DBG("");
+
+	list_for_each(p, &cmtp_session_list) {
+		session = list_entry(p, struct cmtp_session, list);
+		if (!bacmp(bdaddr, &session->bdaddr))
+			return session;
+	}
+	return NULL;
+}
+
+static void __cmtp_link_session(struct cmtp_session *session)
+{
+	__module_get(THIS_MODULE);
+	list_add(&session->list, &cmtp_session_list);
+}
+
+static void __cmtp_unlink_session(struct cmtp_session *session)
+{
+	list_del(&session->list);
+	module_put(THIS_MODULE);
+}
+
+static void __cmtp_copy_session(struct cmtp_session *session, struct cmtp_conninfo *ci)
+{
+	bacpy(&ci->bdaddr, &session->bdaddr);
+
+	ci->flags = session->flags;
+	ci->state = session->state;
+
+	ci->num = session->num;
+}
+
+
+static inline int cmtp_alloc_block_id(struct cmtp_session *session)
+{
+	int i, id = -1;
+
+	for (i = 0; i < 16; i++)
+		if (!test_and_set_bit(i, &session->blockids)) {
+			id = i;
+			break;
+		}
+
+	return id;
+}
+
+static inline void cmtp_free_block_id(struct cmtp_session *session, int id)
+{
+	clear_bit(id, &session->blockids);
+}
+
+static inline void cmtp_add_msgpart(struct cmtp_session *session, int id, const unsigned char *buf, int count)
+{
+	struct sk_buff *skb = session->reassembly[id], *nskb;
+	int size;
+
+	BT_DBG("session %p buf %p count %d", session, buf, count);
+
+	size = (skb) ? skb->len + count : count;
+
+	if (!(nskb = alloc_skb(size, GFP_ATOMIC))) {
+		BT_ERR("Can't allocate memory for CAPI message");
+		return;
+	}
+
+	if (skb && (skb->len > 0))
+		memcpy(skb_put(nskb, skb->len), skb->data, skb->len);
+
+	memcpy(skb_put(nskb, count), buf, count);
+
+	session->reassembly[id] = nskb;
+
+	if (skb)
+		kfree_skb(skb);
+}
+
+static inline int cmtp_recv_frame(struct cmtp_session *session, struct sk_buff *skb)
+{
+	__u8 hdr, hdrlen, id;
+	__u16 len;
+
+	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
+
+	while (skb->len > 0) {
+		hdr = skb->data[0];
+
+		switch (hdr & 0xc0) {
+		case 0x40:
+			hdrlen = 2;
+			len = skb->data[1];
+			break;
+		case 0x80:
+			hdrlen = 3;
+			len = skb->data[1] | (skb->data[2] << 8);
+			break;
+		default:
+			hdrlen = 1;
+			len = 0;
+			break;
+		}
+
+		id = (hdr & 0x3c) >> 2;
+
+		BT_DBG("hdr 0x%02x hdrlen %d len %d id %d", hdr, hdrlen, len, id);
+
+		if (hdrlen + len > skb->len) {
+			BT_ERR("Wrong size or header information in CMTP frame");
+			break;
+		}
+
+		if (len == 0) {
+			skb_pull(skb, hdrlen);
+			continue;
+		}
+
+		switch (hdr & 0x03) {
+		case 0x00:
+			cmtp_add_msgpart(session, id, skb->data + hdrlen, len);
+			cmtp_recv_capimsg(session, session->reassembly[id]);
+			session->reassembly[id] = NULL;
+			break;
+		case 0x01:
+			cmtp_add_msgpart(session, id, skb->data + hdrlen, len);
+			break;
+		default:
+			if (session->reassembly[id] != NULL)
+				kfree_skb(session->reassembly[id]);
+			session->reassembly[id] = NULL;
+			break;
+		}
+
+		skb_pull(skb, hdrlen + len);
+	}
+
+	kfree_skb(skb);
+	return 0;
+}
+
+static int cmtp_send_frame(struct cmtp_session *session, unsigned char *data, int len)
+{
+	struct socket *sock = session->sock;
+	struct iovec iv = { data, len };
+	struct msghdr msg;
+
+	BT_DBG("session %p data %p len %d", session, data, len);
+
+	if (!len)
+		return 0;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iovlen = 1;
+	msg.msg_iov = &iv;
+
+	return sock_sendmsg(sock, &msg, len);
+}
+
+static int cmtp_process_transmit(struct cmtp_session *session)
+{
+	struct sk_buff *skb, *nskb;
+	unsigned char *hdr;
+	unsigned int size, tail;
+
+	BT_DBG("session %p", session);
+
+	if (!(nskb = alloc_skb(session->mtu, GFP_ATOMIC))) {
+		BT_ERR("Can't allocate memory for new frame");
+		return -ENOMEM;
+	}
+
+	while ((skb = skb_dequeue(&session->transmit))) {
+		struct cmtp_scb *scb = (void *) skb->cb;
+
+		if ((tail = (session->mtu - nskb->len)) < 5) {
+			cmtp_send_frame(session, nskb->data, nskb->len);
+			skb_trim(nskb, 0);
+			tail = session->mtu;
+		}
+
+		size = min_t(uint, ((tail < 258) ? (tail - 2) : (tail - 3)), skb->len);
+
+		if ((scb->id < 0) && ((scb->id = cmtp_alloc_block_id(session)) < 0)) {
+			skb_queue_head(&session->transmit, skb);
+			break;
+		}
+
+		if (size < 256) {
+			hdr = skb_put(nskb, 2);
+			hdr[0] = 0x40
+				| ((scb->id << 2) & 0x3c)
+				| ((skb->len == size) ? 0x00 : 0x01);
+			hdr[1] = size;
+		} else {
+			hdr = skb_put(nskb, 3);
+			hdr[0] = 0x80
+				| ((scb->id << 2) & 0x3c)
+				| ((skb->len == size) ? 0x00 : 0x01);
+			hdr[1] = size & 0xff;
+			hdr[2] = size >> 8;
+		}
+
+		memcpy(skb_put(nskb, size), skb->data, size);
+		skb_pull(skb, size);
+
+		if (skb->len > 0) {
+			skb_queue_head(&session->transmit, skb);
+		} else {
+			cmtp_free_block_id(session, scb->id);
+			if (scb->data) {
+				cmtp_send_frame(session, nskb->data, nskb->len);
+				skb_trim(nskb, 0);
+			}
+			kfree_skb(skb);
+		}
+	}
+
+	cmtp_send_frame(session, nskb->data, nskb->len);
+
+	kfree_skb(nskb);
+
+	return skb_queue_len(&session->transmit);
+}
+
+static int cmtp_session(void *arg)
+{
+	struct cmtp_session *session = arg;
+	struct sock *sk = session->sock->sk;
+	struct sk_buff *skb;
+	wait_queue_t wait;
+
+	BT_DBG("session %p", session);
+
+	daemonize("kcmtpd_ctr_%d", session->num);
+	set_user_nice(current, -15);
+	current->flags |= PF_IOTHREAD;
+
+	set_fs(KERNEL_DS);
+
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(sk->sk_sleep, &wait);
+	while (!atomic_read(&session->terminate)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (sk->sk_state != BT_CONNECTED)
+			break;
+
+		while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+			skb_orphan(skb);
+			cmtp_recv_frame(session, skb);
+		}
+
+		cmtp_process_transmit(session);
+
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(sk->sk_sleep, &wait);
+
+	down_write(&cmtp_session_sem);
+
+	if (!(session->flags & (1 << CMTP_LOOPBACK)))
+		cmtp_detach_device(session);
+
+	fput(session->sock->file);
+
+	__cmtp_unlink_session(session);
+
+	up_write(&cmtp_session_sem);
+
+	kfree(session);
+	return 0;
+}
+
+int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)
+{
+	struct cmtp_session *session, *s;
+	bdaddr_t src, dst;
+	int i, err;
+
+	BT_DBG("");
+
+	baswap(&src, &bt_sk(sock->sk)->src);
+	baswap(&dst, &bt_sk(sock->sk)->dst);
+
+	session = kmalloc(sizeof(struct cmtp_session), GFP_KERNEL);
+	if (!session) 
+		return -ENOMEM;
+	memset(session, 0, sizeof(struct cmtp_session));
+
+	down_write(&cmtp_session_sem);
+
+	s = __cmtp_get_session(&bt_sk(sock->sk)->dst);
+	if (s && s->state == BT_CONNECTED) {
+		err = -EEXIST;
+		goto failed;
+	}
+
+	bacpy(&session->bdaddr, &bt_sk(sock->sk)->dst);
+
+	session->mtu = min_t(uint, l2cap_pi(sock->sk)->omtu, l2cap_pi(sock->sk)->imtu);
+
+	BT_DBG("mtu %d", session->mtu);
+
+	sprintf(session->name, "%s", batostr(&dst));
+
+	session->sock  = sock;
+	session->state = BT_CONFIG;
+
+	init_waitqueue_head(&session->wait);
+
+	session->msgnum = CMTP_INITIAL_MSGNUM;
+
+	INIT_LIST_HEAD(&session->applications);
+
+	skb_queue_head_init(&session->transmit);
+
+	for (i = 0; i < 16; i++)
+		session->reassembly[i] = NULL;
+
+	session->flags = req->flags;
+
+	__cmtp_link_session(session);
+
+	err = kernel_thread(cmtp_session, session, CLONE_KERNEL);
+	if (err < 0)
+		goto unlink;
+
+	if (!(session->flags & (1 << CMTP_LOOPBACK))) {
+		err = cmtp_attach_device(session);
+		if (err < 0)
+			goto detach;
+	}
+
+	up_write(&cmtp_session_sem);
+	return 0;
+
+detach:
+	cmtp_detach_device(session);
+
+unlink:
+	__cmtp_unlink_session(session);
+
+failed:
+	up_write(&cmtp_session_sem);
+	kfree(session);
+	return err;
+}
+
+int cmtp_del_connection(struct cmtp_conndel_req *req)
+{
+	struct cmtp_session *session;
+	int err = 0;
+
+	BT_DBG("");
+
+	down_read(&cmtp_session_sem);
+
+	session = __cmtp_get_session(&req->bdaddr);
+	if (session) {
+		/* Flush the transmit queue */
+		skb_queue_purge(&session->transmit);
+
+		/* Kill session thread */
+		atomic_inc(&session->terminate);
+		cmtp_schedule(session);
+	} else
+		err = -ENOENT;
+
+	up_read(&cmtp_session_sem);
+	return err;
+}
+
+int cmtp_get_connlist(struct cmtp_connlist_req *req)
+{
+	struct list_head *p;
+	int err = 0, n = 0;
+
+	BT_DBG("");
+
+	down_read(&cmtp_session_sem);
+
+	list_for_each(p, &cmtp_session_list) {
+		struct cmtp_session *session;
+		struct cmtp_conninfo ci;
+
+		session = list_entry(p, struct cmtp_session, list);
+
+		__cmtp_copy_session(session, &ci);
+
+		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
+			err = -EFAULT;
+			break;
+		}
+
+		if (++n >= req->cnum)
+			break;
+
+		req->ci++;
+	}
+	req->cnum = n;
+
+	up_read(&cmtp_session_sem);
+	return err;
+}
+
+int cmtp_get_conninfo(struct cmtp_conninfo *ci)
+{
+	struct cmtp_session *session;
+	int err = 0;
+
+	down_read(&cmtp_session_sem);
+
+	session = __cmtp_get_session(&ci->bdaddr);
+	if (session)
+		__cmtp_copy_session(session, ci);
+	else
+		err = -ENOENT;
+
+	up_read(&cmtp_session_sem);
+	return err;
+}
+
+
+int __init init_cmtp(void)
+{
+	l2cap_load();
+
+	BT_INFO("CMTP (CAPI Emulation) ver %s", VERSION);
+
+	cmtp_init_sockets();
+
+	return 0;
+}
+
+void __exit exit_cmtp(void)
+{
+	cmtp_cleanup_sockets();
+}
+
+module_init(init_cmtp);
+module_exit(exit_cmtp);
+
+MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
+MODULE_DESCRIPTION("Bluetooth CMTP ver " VERSION);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bt-proto-5");
diff -purN linux-2.6.1/net/bluetooth/cmtp/sock.c linux-2.5/net/bluetooth/cmtp/sock.c
--- linux-2.6.1/net/bluetooth/cmtp/sock.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/net/bluetooth/cmtp/sock.c	2004-01-13 02:37:40.000000000 +0000
@@ -0,0 +1,199 @@
+/* 
+   CMTP implementation for Linux Bluetooth stack (BlueZ).
+   Copyright (C) 2002-2003 Marcel Holtmann <marcel@holtmann.org>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/fcntl.h>
+#include <linux/skbuff.h>
+#include <linux/socket.h>
+#include <linux/ioctl.h>
+#include <linux/file.h>
+#include <net/sock.h>
+
+#include <linux/isdn/capilli.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include "cmtp.h"
+
+#ifndef CONFIG_BT_CMTP_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+static int cmtp_sock_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	BT_DBG("sock %p sk %p", sock, sk);
+
+	if (!sk)
+		return 0;
+
+	sock_orphan(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int cmtp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	struct cmtp_connadd_req ca;
+	struct cmtp_conndel_req cd;
+	struct cmtp_connlist_req cl;
+	struct cmtp_conninfo ci;
+	struct socket *nsock;
+	int err;
+
+	BT_DBG("cmd %x arg %lx", cmd, arg);
+
+	switch (cmd) {
+	case CMTPCONNADD:
+		if (!capable(CAP_NET_ADMIN))
+			return -EACCES;
+
+		if (copy_from_user(&ca, (void *) arg, sizeof(ca)))
+			return -EFAULT;
+
+		nsock = sockfd_lookup(ca.sock, &err);
+		if (!nsock)
+			return err;
+
+		if (nsock->sk->sk_state != BT_CONNECTED)
+			return -EBADFD;
+
+		err = cmtp_add_connection(&ca, nsock);
+		if (!err) {
+			if (copy_to_user((void *) arg, &ca, sizeof(ca)))
+				err = -EFAULT;
+		} else
+			fput(nsock->file);
+
+		return err;
+
+	case CMTPCONNDEL:
+		if (!capable(CAP_NET_ADMIN))
+			return -EACCES;
+
+		if (copy_from_user(&cd, (void *) arg, sizeof(cd)))
+			return -EFAULT;
+
+		return cmtp_del_connection(&cd);
+
+	case CMTPGETCONNLIST:
+		if (copy_from_user(&cl, (void *) arg, sizeof(cl)))
+			return -EFAULT;
+
+		if (cl.cnum <= 0)
+			return -EINVAL;
+
+		err = cmtp_get_connlist(&cl);
+		if (!err && copy_to_user((void *) arg, &cl, sizeof(cl)))
+			return -EFAULT;
+
+		return err;
+
+	case CMTPGETCONNINFO:
+		if (copy_from_user(&ci, (void *) arg, sizeof(ci)))
+			return -EFAULT;
+
+		err = cmtp_get_conninfo(&ci);
+		if (!err && copy_to_user((void *) arg, &ci, sizeof(ci)))
+			return -EFAULT;
+
+		return err;
+	}
+
+	return -EINVAL;
+}
+
+static struct proto_ops cmtp_sock_ops = {
+	.family		= PF_BLUETOOTH,
+	.owner		= THIS_MODULE,
+	.release	= cmtp_sock_release,
+	.ioctl		= cmtp_sock_ioctl,
+	.bind		= sock_no_bind,
+	.getname	= sock_no_getname,
+	.sendmsg	= sock_no_sendmsg,
+	.recvmsg	= sock_no_recvmsg,
+	.poll		= sock_no_poll,
+	.listen		= sock_no_listen,
+	.shutdown	= sock_no_shutdown,
+	.setsockopt	= sock_no_setsockopt,
+	.getsockopt	= sock_no_getsockopt,
+	.connect	= sock_no_connect,
+	.socketpair	= sock_no_socketpair,
+	.accept		= sock_no_accept,
+	.mmap		= sock_no_mmap
+};
+
+static int cmtp_sock_create(struct socket *sock, int protocol)
+{
+	struct sock *sk;
+
+	BT_DBG("sock %p", sock);
+
+	if (sock->type != SOCK_RAW)
+		return -ESOCKTNOSUPPORT;
+
+	if (!(sk = bt_sock_alloc(sock, PF_BLUETOOTH, 0, GFP_KERNEL)))
+		return -ENOMEM;
+
+	sk_set_owner(sk, THIS_MODULE);
+
+	sock->ops = &cmtp_sock_ops;
+
+	sock->state = SS_UNCONNECTED;
+
+	sk->sk_destruct = NULL;
+	sk->sk_protocol = protocol;
+
+	return 0;
+}
+
+static struct net_proto_family cmtp_sock_family_ops = {
+	.family	= PF_BLUETOOTH,
+	.owner	= THIS_MODULE,
+	.create	= cmtp_sock_create
+};
+
+int cmtp_init_sockets(void)
+{
+	bt_sock_register(BTPROTO_CMTP, &cmtp_sock_family_ops);
+
+	return 0;
+}
+
+void cmtp_cleanup_sockets(void)
+{
+	if (bt_sock_unregister(BTPROTO_CMTP))
+		BT_ERR("Can't unregister CMTP socket");
+}
diff -purN linux-2.6.1/net/bluetooth/hci_conn.c linux-2.5/net/bluetooth/hci_conn.c
--- linux-2.6.1/net/bluetooth/hci_conn.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/net/bluetooth/hci_conn.c	2004-01-13 02:50:09.000000000 +0000
@@ -71,7 +71,7 @@ void hci_acl_connect(struct hci_conn *co
 
 	memset(&cp, 0, sizeof(cp));
 	bacpy(&cp.bdaddr, &conn->dst);
-	cp.pscan_rep_mode = 0x01;
+	cp.pscan_rep_mode = 0x02;
 
 	if ((ie = inquiry_cache_lookup(hdev, &conn->dst)) &&
 			inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
diff -purN linux-2.6.1/net/bluetooth/hci_core.c linux-2.5/net/bluetooth/hci_core.c
--- linux-2.6.1/net/bluetooth/hci_core.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/bluetooth/hci_core.c	2004-01-14 18:56:21.000000000 +0000
@@ -406,6 +406,7 @@ int hci_inquiry(unsigned long arg)
 
 	hci_dev_lock_bh(hdev);
 	if (inquiry_cache_age(hdev) > INQUIRY_CACHE_AGE_MAX || 
+					inquiry_cache_empty(hdev) ||
 					ir.flags & IREQ_CACHE_FLUSH) {
 		inquiry_cache_flush(hdev);
 		do_inquiry = 1;
diff -purN linux-2.6.1/net/bluetooth/hci_event.c linux-2.5/net/bluetooth/hci_event.c
--- linux-2.6.1/net/bluetooth/hci_event.c	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/net/bluetooth/hci_event.c	2003-12-18 11:50:05.000000000 +0000
@@ -452,6 +452,29 @@ static inline void hci_inquiry_result_ev
 	hci_dev_unlock(hdev);
 }
 
+/* Inquiry Result With RSSI */
+static inline void hci_inquiry_result_with_rssi_evt(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	struct inquiry_info_with_rssi *info = (struct inquiry_info_with_rssi *) (skb->data + 1);
+	int num_rsp = *((__u8 *) skb->data);
+
+	BT_DBG("%s num_rsp %d", hdev->name, num_rsp);
+
+	hci_dev_lock(hdev);
+	for (; num_rsp; num_rsp--) {
+		struct inquiry_info tmp;
+		bacpy(&tmp.bdaddr, &info->bdaddr);
+		tmp.pscan_rep_mode    = info->pscan_rep_mode;
+		tmp.pscan_period_mode = info->pscan_period_mode;
+		tmp.pscan_mode        = 0x00;
+		memcpy(tmp.dev_class, &info->dev_class, 3);
+		tmp.clock_offset      = info->clock_offset;
+		info++;
+		inquiry_cache_update(hdev, &tmp);
+	}
+	hci_dev_unlock(hdev);
+}
+
 /* Connect Request */
 static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
@@ -744,6 +767,10 @@ void hci_event_packet(struct hci_dev *hd
 		hci_inquiry_result_evt(hdev, skb);
 		break;
 
+	case HCI_EV_INQUIRY_RESULT_WITH_RSSI:
+		hci_inquiry_result_with_rssi_evt(hdev, skb);
+		break;
+
 	case HCI_EV_CONN_REQUEST:
 		hci_conn_request_evt(hdev, skb);
 		break;
diff -purN linux-2.6.1/net/bluetooth/hci_sock.c linux-2.5/net/bluetooth/hci_sock.c
--- linux-2.6.1/net/bluetooth/hci_sock.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/bluetooth/hci_sock.c	2004-01-14 20:56:53.000000000 +0000
@@ -66,20 +66,20 @@ static struct hci_sec_filter hci_sec_fil
 	/* Packet types */
 	0x10,
 	/* Events */
-	{ 0xd9fe, 0x0 },
+	{ 0x1000d9fe, 0x0000300c },
 	/* Commands */
 	{
 		{ 0x0 },
 		/* OGF_LINK_CTL */
-		{ 0x2a000002, 0x0, 0x0, 0x0  },
+		{ 0xbe000006, 0x00000001, 0x0000, 0x00 },
 		/* OGF_LINK_POLICY */
-		{ 0x1200, 0x0, 0x0, 0x0      },
+		{ 0x00005200, 0x00000000, 0x0000, 0x00 },
 		/* OGF_HOST_CTL */
-		{ 0x80100000, 0x202a, 0x0, 0x0 },
+		{ 0xaab00200, 0x2b402aaa, 0x0154, 0x00 },
 		/* OGF_INFO_PARAM */
-		{ 0x22a, 0x0, 0x0, 0x0       },
+		{ 0x000002be, 0x00000000, 0x0000, 0x00 },
 		/* OGF_STATUS_PARAM */
-		{ 0x2e, 0x0, 0x0, 0x0        }
+		{ 0x000000ea, 0x00000000, 0x0000, 0x00 }
 	}
 };
 
@@ -319,7 +319,8 @@ static inline void hci_sock_cmsg(struct 
         	put_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, sizeof(skb->stamp), &skb->stamp);
 }
  
-static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len, int flags)
+static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
@@ -355,7 +356,8 @@ static int hci_sock_recvmsg(struct kiocb
 	return err ? : copied;
 }
 
-static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct hci_dev *hdev;
@@ -370,9 +372,9 @@ static int hci_sock_sendmsg(struct kiocb
 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))
 		return -EINVAL;
 
-	if (len < 4)
+	if (len < 4 || len > HCI_MAX_FRAME_SIZE)
 		return -EINVAL;
-	
+
 	lock_sock(sk);
 
 	if (!(hdev = hci_pi(sk)->hdev)) {
diff -purN linux-2.6.1/net/bluetooth/l2cap.c linux-2.5/net/bluetooth/l2cap.c
--- linux-2.6.1/net/bluetooth/l2cap.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/net/bluetooth/l2cap.c	2004-01-14 20:56:53.000000000 +0000
@@ -706,7 +706,8 @@ fail:
 	return err;
 }
 
-static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
@@ -2201,3 +2202,4 @@ module_exit(l2cap_cleanup);
 MODULE_AUTHOR("Maxim Krasnyansky <maxk@qualcomm.com>");
 MODULE_DESCRIPTION("Bluetooth L2CAP ver " VERSION);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("bt-proto-0");
diff -purN linux-2.6.1/net/bluetooth/rfcomm/core.c linux-2.5/net/bluetooth/rfcomm/core.c
--- linux-2.6.1/net/bluetooth/rfcomm/core.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/net/bluetooth/rfcomm/core.c	2004-01-13 23:32:39.000000000 +0000
@@ -52,7 +52,7 @@
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/rfcomm.h>
 
-#define VERSION "1.0"
+#define VERSION "1.1"
 
 #ifndef CONFIG_BT_RFCOMM_DEBUG
 #undef  BT_DBG
@@ -207,7 +207,7 @@ static void rfcomm_dlc_clear_state(struc
 	d->mtu        = RFCOMM_DEFAULT_MTU;
 	d->v24_sig    = RFCOMM_V24_RTC | RFCOMM_V24_RTR | RFCOMM_V24_DV;
 
-	d->credits    = RFCOMM_MAX_CREDITS;
+	d->cfc        = RFCOMM_CFC_DISABLED;
 	d->rx_credits = RFCOMM_DEFAULT_CREDITS;
 }
 
@@ -314,8 +314,8 @@ static int __rfcomm_dlc_open(struct rfco
 	d->state    = BT_CONFIG;
 	rfcomm_dlc_link(s, d);
 
-	d->mtu     = s->mtu;
-	d->credits = s->credits;
+	d->mtu = s->mtu;
+	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 
 	if (s->state == BT_CONNECTED)
 		rfcomm_send_pn(s, 1, d);
@@ -415,7 +415,7 @@ void __rfcomm_dlc_throttle(struct rfcomm
 {
 	BT_DBG("dlc %p state %ld", d, d->state);
 
-	if (!d->credits) {
+	if (!d->cfc) {
 		d->v24_sig |= RFCOMM_V24_FC;
 		set_bit(RFCOMM_MSC_PENDING, &d->flags);
 	}
@@ -426,7 +426,7 @@ void __rfcomm_dlc_unthrottle(struct rfco
 {
 	BT_DBG("dlc %p state %ld", d, d->state);
 
-	if (!d->credits) {
+	if (!d->cfc) {
 		d->v24_sig &= ~RFCOMM_V24_FC;
 		set_bit(RFCOMM_MSC_PENDING, &d->flags);
 	}
@@ -479,8 +479,8 @@ struct rfcomm_session *rfcomm_session_ad
 	s->state = state;
 	s->sock  = sock;
 
-	s->mtu     = RFCOMM_DEFAULT_MTU;
-	s->credits = RFCOMM_MAX_CREDITS;
+	s->mtu   = RFCOMM_DEFAULT_MTU;
+	s->cfc   = RFCOMM_CFC_UNKNOWN;
 	
 	list_add(&s->list, &session_list);
 
@@ -752,7 +752,7 @@ static int rfcomm_send_pn(struct rfcomm_
 	pn->ack_timer   = 0;
 	pn->max_retrans = 0;
 
-	if (d->credits) {
+	if (s->cfc) {
 		pn->flow_ctrl = cr ? 0xf0 : 0xe0;
 		pn->credits = RFCOMM_DEFAULT_CREDITS;
 	} else {
@@ -1142,28 +1142,22 @@ static int rfcomm_recv_sabm(struct rfcom
 
 static int rfcomm_apply_pn(struct rfcomm_dlc *d, int cr, struct rfcomm_pn *pn)
 {
+	struct rfcomm_session *s = d->session;
+
 	BT_DBG("dlc %p state %ld dlci %d mtu %d fc 0x%x credits %d", 
 			d, d->state, d->dlci, pn->mtu, pn->flow_ctrl, pn->credits);
 
-	if (cr) {
-		if (pn->flow_ctrl == 0xf0) {
-			d->tx_credits = pn->credits;
-		} else {
-			set_bit(RFCOMM_TX_THROTTLED, &d->flags);
-			d->credits = 0;
-		}
+	if (pn->flow_ctrl == 0xf0 || pn->flow_ctrl == 0xe0) {
+		d->cfc = s->cfc = RFCOMM_CFC_ENABLED;
+		d->tx_credits = pn->credits;
 	} else {
-		if (pn->flow_ctrl == 0xe0) {
-			d->tx_credits = pn->credits;
-		} else {
-			set_bit(RFCOMM_TX_THROTTLED, &d->flags);
-			d->credits = 0;
-		}
+		d->cfc = s->cfc = RFCOMM_CFC_DISABLED;
+		set_bit(RFCOMM_TX_THROTTLED, &d->flags);
 	}
 
 	d->priority = pn->priority;
 
-	d->mtu = btohs(pn->mtu);
+	d->mtu = s->mtu = btohs(pn->mtu);
 
 	return 0;
 }
@@ -1353,7 +1347,7 @@ static int rfcomm_recv_msc(struct rfcomm
 		return 0;
 
 	if (cr) {
-		if (msc->v24_sig & RFCOMM_V24_FC && !d->credits)
+		if (msc->v24_sig & RFCOMM_V24_FC && !d->cfc)
 			set_bit(RFCOMM_TX_THROTTLED, &d->flags);
 		else
 			clear_bit(RFCOMM_TX_THROTTLED, &d->flags);
@@ -1444,7 +1438,7 @@ static int rfcomm_recv_data(struct rfcom
 		goto drop;
 	}
 
-	if (pf && d->credits) {
+	if (pf && d->cfc) {
 		u8 credits = *(u8 *) skb->data; skb_pull(skb, 1);
 
 		d->tx_credits += credits;
@@ -1549,20 +1543,20 @@ static inline int rfcomm_process_tx(stru
 	struct sk_buff *skb;
 	int err;
 
-	BT_DBG("dlc %p state %ld credits %d rx_credits %d tx_credits %d", 
-			d, d->state, d->credits, d->rx_credits, d->tx_credits);
+	BT_DBG("dlc %p state %ld cfc %d rx_credits %d tx_credits %d", 
+			d, d->state, d->cfc, d->rx_credits, d->tx_credits);
 
 	/* Send pending MSC */
 	if (test_and_clear_bit(RFCOMM_MSC_PENDING, &d->flags))
 		rfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig); 
 	
-	if (d->credits) {
+	if (d->cfc) {
 		/* CFC enabled. 
 		 * Give them some credits */
 		if (!test_bit(RFCOMM_RX_THROTTLED, &d->flags) &&
-			       	d->rx_credits <= (d->credits >> 2)) {
-			rfcomm_send_credits(d->session, d->addr, d->credits - d->rx_credits);
-			d->rx_credits = d->credits;
+			       	d->rx_credits <= (d->cfc >> 2)) {
+			rfcomm_send_credits(d->session, d->addr, d->cfc - d->rx_credits);
+			d->rx_credits = d->cfc;
 		}
 	} else {
 		/* CFC disabled.
@@ -1583,7 +1577,7 @@ static inline int rfcomm_process_tx(stru
 		d->tx_credits--;
 	}
 
-	if (d->credits && !d->tx_credits) {
+	if (d->cfc && !d->tx_credits) {
 		/* We're out of TX credits.
 		 * Set TX_THROTTLED flag to avoid unnesary wakeups by dlc_send. */
 		set_bit(RFCOMM_TX_THROTTLED, &d->flags);
@@ -1655,7 +1649,9 @@ static inline void rfcomm_accept_connect
 
 	nsock->type = sock->type;
 	nsock->ops  = sock->ops;
-	
+
+	__module_get(nsock->ops->owner);
+
 	err = sock->ops->accept(sock, nsock, O_NONBLOCK);
 	if (err < 0) {
 		sock_release(nsock);
@@ -1998,3 +1994,4 @@ module_exit(rfcomm_cleanup);
 MODULE_AUTHOR("Maxim Krasnyansky <maxk@qualcomm.com>, Marcel Holtmann <marcel@holtmann.org>");
 MODULE_DESCRIPTION("Bluetooth RFCOMM ver " VERSION);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("bt-proto-3");
diff -purN linux-2.6.1/net/bluetooth/rfcomm/sock.c linux-2.5/net/bluetooth/rfcomm/sock.c
--- linux-2.6.1/net/bluetooth/rfcomm/sock.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/bluetooth/rfcomm/sock.c	2004-01-09 09:51:18.000000000 +0000
@@ -482,12 +482,12 @@ static int rfcomm_sock_getname(struct so
 }
 
 static int rfcomm_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;
 	struct sk_buff *skb;
-	int err, size;
+	int err;
 	int sent = 0;
 
 	if (msg->msg_flags & MSG_OOB)
@@ -501,7 +501,7 @@ static int rfcomm_sock_sendmsg(struct ki
 	lock_sock(sk);
 
 	while (len) {
-		size = min_t(uint, len, d->mtu);
+		size_t size = min(len, d->mtu);
 		
 		skb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,
 				msg->msg_flags & MSG_DONTWAIT, &err);
@@ -556,10 +556,11 @@ static long rfcomm_sock_data_wait(struct
 }
 
 static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size, int flags)
+			       struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
-	int target, err = 0, copied = 0;
+	int err = 0;
+	size_t target, copied = 0;
 	long timeo;
 
 	if (flags & MSG_OOB)
diff -purN linux-2.6.1/net/bluetooth/sco.c linux-2.5/net/bluetooth/sco.c
--- linux-2.6.1/net/bluetooth/sco.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/bluetooth/sco.c	2004-01-14 20:56:53.000000000 +0000
@@ -630,7 +630,8 @@ static int sco_sock_getname(struct socke
 	return 0;
 }
 
-static int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
@@ -1054,3 +1055,4 @@ module_exit(sco_cleanup);
 MODULE_AUTHOR("Maxim Krasnyansky <maxk@qualcomm.com>");
 MODULE_DESCRIPTION("Bluetooth SCO ver " VERSION);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("bt-proto-2");
diff -purN linux-2.6.1/net/bridge/br_if.c linux-2.5/net/bridge/br_if.c
--- linux-2.6.1/net/bridge/br_if.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/net/bridge/br_if.c	2004-01-14 00:21:58.000000000 +0000
@@ -252,12 +252,12 @@ int br_get_bridge_ifindices(int *indices
 	struct net_device *dev;
 	int i = 0;
 
-	rtnl_shlock();
+	read_lock(&dev_base_lock);
 	for (dev = dev_base; dev && i < num; dev = dev->next) {
 		if (dev->priv_flags & IFF_EBRIDGE) 
 			indices[i++] = dev->ifindex;
 	}
-	rtnl_shunlock();
+	read_unlock(&dev_base_lock);
 
 	return i;
 }
diff -purN linux-2.6.1/net/core/dev.c linux-2.5/net/core/dev.c
--- linux-2.6.1/net/core/dev.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/net/core/dev.c	2004-01-15 08:52:34.000000000 +0000
@@ -621,6 +621,21 @@ struct net_device *__dev_get_by_flags(un
 }
 
 /**
+ *	dev_valid_name - check if name is okay for network device
+ *	@name: name string
+ *
+ *	Network device names need to be valid file names to
+ *	to allow sysfs to work
+ */
+int dev_valid_name(const char *name)
+{
+	return !(*name == '\0' 
+		 || !strcmp(name, ".")
+		 || !strcmp(name, "..")
+		 || strchr(name, '/'));
+}
+
+/**
  *	dev_alloc_name - allocate a name for a device
  *	@dev: device
  *	@name: name format string
@@ -660,6 +675,41 @@ int dev_alloc_name(struct net_device *de
 	return -ENFILE;	/* Over 100 of the things .. bail out! */
 }
 
+
+/**
+ *	dev_change_name - change name of a device
+ *	@dev: device
+ *	@name: name (or format string) must be at least IFNAMSIZ
+ *
+ *	Change name of a device, can pass format strings "eth%d".
+ *	for wildcarding.
+ */
+int dev_change_name(struct net_device *dev, char *newname)
+{
+	ASSERT_RTNL();
+
+	if (dev->flags & IFF_UP)
+		return -EBUSY;
+
+	if (!dev_valid_name(newname))
+		return -EINVAL;
+
+	if (strchr(newname, '%')) {
+		int err = dev_alloc_name(dev, newname);
+		if (err < 0)
+			return err;
+		strcpy(newname, dev->name);
+	}
+	else if (__dev_get_by_name(newname))
+		return -EEXIST;
+	else
+		strlcpy(dev->name, newname, IFNAMSIZ);
+
+	class_device_rename(&dev->class_dev, dev->name);
+	notifier_call_chain(&netdev_chain, NETDEV_CHANGENAME, dev);
+	return 0;
+}
+
 /**
  *	dev_alloc - allocate a network device and name
  *	@name: name format string
@@ -946,11 +996,29 @@ int dev_close(struct net_device *dev)
  *	The notifier passed is linked into the kernel structures and must
  *	not be reused until it has been unregistered. A negative errno code
  *	is returned on a failure.
+ *
+ * 	When registered all registration and up events are replayed
+ *	to the new notifier to allow device to have a race free 
+ *	view of the network device list.
  */
 
 int register_netdevice_notifier(struct notifier_block *nb)
 {
-	return notifier_chain_register(&netdev_chain, nb);
+	struct net_device *dev;
+	int err;
+
+	rtnl_lock();
+	err = notifier_chain_register(&netdev_chain, nb);
+	if (!err) {
+		for (dev = dev_base; dev; dev = dev->next) {
+			nb->notifier_call(nb, NETDEV_REGISTER, dev);
+
+			if (dev->flags & IFF_UP) 
+				nb->notifier_call(nb, NETDEV_UP, dev);
+		}
+	}
+	rtnl_unlock();
+	return err;
 }
 
 /**
@@ -2341,20 +2409,8 @@ static int dev_ifsioc(struct ifreq *ifr,
 			return 0;
 
 		case SIOCSIFNAME:
-			if (dev->flags & IFF_UP)
-				return -EBUSY;
 			ifr->ifr_newname[IFNAMSIZ-1] = '\0';
-			if (__dev_get_by_name(ifr->ifr_newname))
-				return -EEXIST;
-			err = class_device_rename(&dev->class_dev, 
-						  ifr->ifr_newname);
-			if (!err) {
-				strlcpy(dev->name, ifr->ifr_newname, IFNAMSIZ);
-
-				notifier_call_chain(&netdev_chain,
-						    NETDEV_CHANGENAME, dev);
-			}
-			return err;
+			return dev_change_name(dev, ifr->ifr_newname);
 
 		/*
 		 *	Unknown or private ioctl
@@ -2487,6 +2543,7 @@ int dev_ioctl(unsigned int cmd, void *ar
 		 */
 		case SIOCGMIIPHY:
 		case SIOCGMIIREG:
+		case SIOCSIFNAME:
 			if (!capable(CAP_NET_ADMIN))
 				return -EPERM;
 			dev_load(ifr.ifr_name);
@@ -2518,7 +2575,6 @@ int dev_ioctl(unsigned int cmd, void *ar
 		case SIOCDELMULTI:
 		case SIOCSIFHWBROADCAST:
 		case SIOCSIFTXQLEN:
-		case SIOCSIFNAME:
 		case SIOCSMIIREG:
 		case SIOCBONDENSLAVE:
 		case SIOCBONDRELEASE:
@@ -2668,6 +2724,11 @@ int register_netdevice(struct net_device
 			goto out_err;
 		}
 	}
+ 
+	if (!dev_valid_name(dev->name)) {
+		ret = -EINVAL;
+		goto out_err;
+	}
 
 	dev->ifindex = dev_new_index();
 	if (dev->iflink == -1)
diff -purN linux-2.6.1/net/core/dev_mcast.c linux-2.5/net/core/dev_mcast.c
--- linux-2.6.1/net/core/dev_mcast.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/core/dev_mcast.c	2004-01-14 00:22:53.000000000 +0000
@@ -41,6 +41,7 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <linux/init.h>
 #include <net/ip.h>
 #include <net/route.h>
@@ -219,59 +220,78 @@ void dev_mc_discard(struct net_device *d
 }
 
 #ifdef CONFIG_PROC_FS
-static int dev_mc_read_proc(char *buffer, char **start, off_t offset,
-			    int length, int *eof, void *data)
+static void *dev_mc_seq_start(struct seq_file *seq, loff_t *pos)
 {
-	off_t pos = 0, begin = 0;
-	struct dev_mc_list *m;
-	int len = 0;
 	struct net_device *dev;
+	loff_t off = 0;
 
 	read_lock(&dev_base_lock);
 	for (dev = dev_base; dev; dev = dev->next) {
-		spin_lock_bh(&dev->xmit_lock);
-		for (m = dev->mc_list; m; m = m->next) {
-			int i;
-
-			len += sprintf(buffer+len,"%-4d %-15s %-5d %-5d ", dev->ifindex,
-				       dev->name, m->dmi_users, m->dmi_gusers);
-
-			for (i = 0; i < m->dmi_addrlen; i++)
-				len += sprintf(buffer+len, "%02x", m->dmi_addr[i]);
-
-			len += sprintf(buffer+len, "\n");
-
-			pos = begin + len;
-			if (pos < offset) {
-				len = 0;
-				begin = pos;
-			}
-			if (pos > offset + length) {
-				spin_unlock_bh(&dev->xmit_lock);
-				goto done;
-			}
-		}
-		spin_unlock_bh(&dev->xmit_lock);
+		if (off++ == *pos) 
+			return dev;
 	}
-	*eof = 1;
+	return NULL;
+}
 
-done:
+static void *dev_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct net_device *dev = v;
+	++*pos;
+	return dev->next;
+}
+
+static void dev_mc_seq_stop(struct seq_file *seq, void *v)
+{
 	read_unlock(&dev_base_lock);
-	*start = buffer + (offset - begin);
-	len -= (offset - begin);
-	if (len > length)
-		len = length;
-	if (len < 0)
-		len = 0;
-	return len;
 }
+
+
+static int dev_mc_seq_show(struct seq_file *seq, void *v)
+{
+	struct dev_mc_list *m;
+	struct net_device *dev = v;
+
+	spin_lock_bh(&dev->xmit_lock);
+	for (m = dev->mc_list; m; m = m->next) {
+		int i;
+
+		seq_printf(seq, "%-4d %-15s %-5d %-5d ", dev->ifindex,
+			   dev->name, m->dmi_users, m->dmi_gusers);
+
+		for (i = 0; i < m->dmi_addrlen; i++)
+			seq_printf(seq, "%02x", m->dmi_addr[i]);
+
+		seq_putc(seq, '\n');
+	}
+	spin_unlock_bh(&dev->xmit_lock);
+	return 0;
+}
+
+static struct seq_operations dev_mc_seq_ops = {
+	.start = dev_mc_seq_start,
+	.next  = dev_mc_seq_next,
+	.stop  = dev_mc_seq_stop,
+	.show  = dev_mc_seq_show,
+};
+
+static int dev_mc_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &dev_mc_seq_ops);
+}
+
+static struct file_operations dev_mc_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open    = dev_mc_seq_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = seq_release,
+};
+
 #endif
 
 void __init dev_mcast_init(void)
 {
-#ifdef CONFIG_PROC_FS
-	create_proc_read_entry("net/dev_mcast", 0, 0, dev_mc_read_proc, NULL);
-#endif
+	proc_net_fops_create("dev_mcast", 0, &dev_mc_seq_fops);
 }
 
 EXPORT_SYMBOL(dev_mc_add);
diff -purN linux-2.6.1/net/core/neighbour.c linux-2.5/net/core/neighbour.c
--- linux-2.6.1/net/core/neighbour.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/net/core/neighbour.c	2004-01-15 08:58:09.000000000 +0000
@@ -1629,7 +1629,8 @@ struct neigh_sysctl_table {
 };
 
 int neigh_sysctl_register(struct net_device *dev, struct neigh_parms *p,
-			  int p_id, int pdev_id, char *p_name)
+			  int p_id, int pdev_id, char *p_name, 
+			  proc_handler *handler)
 {
 	struct neigh_sysctl_table *t = kmalloc(sizeof(*t), GFP_KERNEL);
 	const char *dev_name_source = NULL;
@@ -1643,6 +1644,10 @@ int neigh_sysctl_register(struct net_dev
 	t->neigh_vars[1].data  = &p->ucast_probes;
 	t->neigh_vars[2].data  = &p->app_probes;
 	t->neigh_vars[3].data  = &p->retrans_time;
+	if (handler) {
+		t->neigh_vars[3].proc_handler = handler;
+		t->neigh_vars[3].extra1 = dev;
+	}
 	t->neigh_vars[4].data  = &p->base_reachable_time;
 	t->neigh_vars[5].data  = &p->delay_probe_time;
 	t->neigh_vars[6].data  = &p->gc_staletime;
diff -purN linux-2.6.1/net/core/sock.c linux-2.5/net/core/sock.c
--- linux-2.6.1/net/core/sock.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/net/core/sock.c	2004-01-09 09:46:38.000000000 +0000
@@ -966,13 +966,13 @@ int sock_no_getsockopt(struct socket *so
 }
 
 int sock_no_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		    int flags)
+		    size_t len)
 {
 	return -EOPNOTSUPP;
 }
 
 int sock_no_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		    int len, int flags)
+		    size_t len, int flags)
 {
 	return -EOPNOTSUPP;
 }
diff -purN linux-2.6.1/net/decnet/af_decnet.c linux-2.5/net/decnet/af_decnet.c
--- linux-2.6.1/net/decnet/af_decnet.c	2004-01-09 06:59:42.000000000 +0000
+++ linux-2.5/net/decnet/af_decnet.c	2004-01-15 08:48:13.000000000 +0000
@@ -1659,13 +1659,13 @@ static int dn_data_ready(struct sock *sk
 
 
 static int dn_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int size, int flags)
+	struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct dn_scp *scp = DN_SK(sk);
 	struct sk_buff_head *queue = &sk->sk_receive_queue;
-	int target = size > 1 ? 1 : 0;
-	int copied = 0;
+	size_t target = size > 1 ? 1 : 0;
+	size_t copied = 0;
 	int rv = 0;
 	struct sk_buff *skb, *nskb;
 	struct dn_skb_cb *cb = NULL;
@@ -1746,7 +1746,7 @@ static int dn_recvmsg(struct kiocb *iocb
 	}
 
 	for(skb = queue->next; skb != (struct sk_buff *)queue; skb = nskb) {
-		int chunk = skb->len;
+		unsigned int chunk = skb->len;
 		cb = DN_SKB_CB(skb);
 
 		if ((chunk + copied) > size)
@@ -1888,20 +1888,20 @@ static int dn_error(struct sock *sk, int
 }
 
 static int dn_sendmsg(struct kiocb *iocb, struct socket *sock,
-	   struct msghdr *msg, int size)
+	   struct msghdr *msg, size_t size)
 {
 	struct sock *sk = sock->sk;
 	struct dn_scp *scp = DN_SK(sk);
-	int mss;
+	size_t mss;
 	struct sk_buff_head *queue = &scp->data_xmit_queue;
 	int flags = msg->msg_flags;
 	int err = 0;
-	int sent = 0;
+	size_t sent = 0;
 	int addr_len = msg->msg_namelen;
 	struct sockaddr_dn *addr = (struct sockaddr_dn *)msg->msg_name;
 	struct sk_buff *skb = NULL;
 	struct dn_skb_cb *cb;
-	int len;
+	size_t len;
 	unsigned char fctype;
 	long timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
 
@@ -2363,17 +2363,16 @@ static int __init decnet_init(void)
 	if (!dn_sk_cachep)
 		return -ENOMEM;
 
-	sock_register(&dn_family_ops);
-	dev_add_pack(&dn_dix_packet_type);
-	register_netdevice_notifier(&dn_dev_notifier);
-
-	proc_net_fops_create("decnet", S_IRUGO, &dn_socket_seq_fops);
-
 	dn_neigh_init();
 	dn_dev_init();
 	dn_route_init();
 	dn_fib_init();
 
+	sock_register(&dn_family_ops);
+	dev_add_pack(&dn_dix_packet_type);
+	register_netdevice_notifier(&dn_dev_notifier);
+
+	proc_net_fops_create("decnet", S_IRUGO, &dn_socket_seq_fops);
 	dn_register_sysctl();
 
 	return 0;
diff -purN linux-2.6.1/net/econet/af_econet.c linux-2.5/net/econet/af_econet.c
--- linux-2.6.1/net/econet/af_econet.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/econet/af_econet.c	2004-01-09 09:54:49.000000000 +0000
@@ -113,11 +113,12 @@ static void econet_insert_socket(struct 
  */
 
 static int econet_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len, int flags)
+			  struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	msg->msg_namelen = sizeof(struct sockaddr_ec);
 
@@ -246,7 +247,7 @@ static void ec_tx_done(struct sk_buff *s
  */
 
 static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ec *saddr=(struct sockaddr_ec *)msg->msg_name;
@@ -308,6 +309,9 @@ static int econet_sendmsg(struct kiocb *
 			return -ENETDOWN;
 	}
 
+	if (len + 15 > dev->mtu)
+		return -EMSGSIZE;
+
 	if (dev->type == ARPHRD_ECONET)
 	{
 		/* Real hardware Econet.  We're not worthy etc. */
diff -purN linux-2.6.1/net/ipv4/af_inet.c linux-2.5/net/ipv4/af_inet.c
--- linux-2.6.1/net/ipv4/af_inet.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/net/ipv4/af_inet.c	2004-01-09 09:50:23.000000000 +0000
@@ -731,7 +731,7 @@ int inet_getname(struct socket *sock, st
 
 
 int inet_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		 int size, int flags)
+		 size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	int addr_len = 0;
@@ -746,7 +746,7 @@ int inet_recvmsg(struct kiocb *iocb, str
 
 
 int inet_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		 int size)
+		 size_t size)
 {
 	struct sock *sk = sock->sk;
 
diff -purN linux-2.6.1/net/ipv4/arp.c linux-2.5/net/ipv4/arp.c
--- linux-2.6.1/net/ipv4/arp.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv4/arp.c	2004-01-15 08:58:09.000000000 +0000
@@ -1122,7 +1122,7 @@ void __init arp_init(void)
 	arp_proc_init();
 #ifdef CONFIG_SYSCTL
 	neigh_sysctl_register(NULL, &arp_tbl.parms, NET_IPV4,
-			      NET_IPV4_NEIGH, "ipv4");
+			      NET_IPV4_NEIGH, "ipv4", NULL);
 #endif
 	register_netdevice_notifier(&arp_netdev_notifier);
 }
diff -purN linux-2.6.1/net/ipv4/devinet.c linux-2.5/net/ipv4/devinet.c
--- linux-2.6.1/net/ipv4/devinet.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/ipv4/devinet.c	2004-01-15 08:58:09.000000000 +0000
@@ -155,7 +155,7 @@ struct in_device *inetdev_init(struct ne
 	dev_hold(dev);
 #ifdef CONFIG_SYSCTL
 	neigh_sysctl_register(dev, in_dev->arp_parms, NET_IPV4,
-			      NET_IPV4_NEIGH, "ipv4");
+			      NET_IPV4_NEIGH, "ipv4", NULL);
 #endif
 	write_lock_bh(&inetdev_lock);
 	dev->ip_ptr = in_dev;
@@ -910,7 +910,7 @@ static int inetdev_event(struct notifier
 		devinet_sysctl_unregister(&in_dev->cnf);
 		neigh_sysctl_unregister(in_dev->arp_parms);
 		neigh_sysctl_register(dev, in_dev->arp_parms, NET_IPV4,
-				      NET_IPV4_NEIGH, "ipv4");
+				      NET_IPV4_NEIGH, "ipv4", NULL);
 		devinet_sysctl_register(in_dev, &in_dev->cnf);
 #endif
 		break;
diff -purN linux-2.6.1/net/ipv4/igmp.c linux-2.5/net/ipv4/igmp.c
--- linux-2.6.1/net/ipv4/igmp.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/net/ipv4/igmp.c	2004-01-14 00:17:54.000000000 +0000
@@ -1749,11 +1749,10 @@ int ip_mc_source(int add, int omode, str
 			goto done;
 	} else if (pmc->sfmode != omode) {
 		/* allow mode switches for empty-set filters */
+		ip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, 0, 0);
 		ip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0, 
 			0, 0);
 		pmc->sfmode = omode;
-		ip_mc_add_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0, 
-			0, 0);
 	}
 
 	psl = pmc->sflist;
diff -purN linux-2.6.1/net/ipv4/ipcomp.c linux-2.5/net/ipv4/ipcomp.c
--- linux-2.6.1/net/ipv4/ipcomp.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv4/ipcomp.c	2004-01-14 07:23:05.000000000 +0000
@@ -294,6 +294,7 @@ out:
 	return t;
 
 error:
+	t->km.state = XFRM_STATE_DEAD;
 	xfrm_state_put(t);
 	t = NULL;
 	goto out;
diff -purN linux-2.6.1/net/ipv4/ipmr.c linux-2.5/net/ipv4/ipmr.c
--- linux-2.6.1/net/ipv4/ipmr.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/ipv4/ipmr.c	2004-01-14 00:06:09.000000000 +0000
@@ -205,6 +205,9 @@ static struct net_device *ipmr_reg_vif(v
 	dev = alloc_netdev(sizeof(struct net_device_stats), "pimreg",
 			   reg_vif_setup);
 
+	if (dev == NULL)
+		return NULL;
+
 	if (register_netdevice(dev)) {
 		kfree(dev);
 		return NULL;
diff -purN linux-2.6.1/net/ipv4/netfilter/Kconfig linux-2.5/net/ipv4/netfilter/Kconfig
--- linux-2.6.1/net/ipv4/netfilter/Kconfig	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/Kconfig	2004-01-14 00:26:15.000000000 +0000
@@ -529,10 +529,23 @@ config IP_NF_TARGET_TCPMSS
 
 config IP_NF_ARPTABLES
 	tristate "ARP tables support"
+	help
+	  arptables is a general, extensible packet identification framework.
+	  The ARP packet filtering and mangling (manipulation)subsystems
+	  use this: say Y or M here if you want to use either of those.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
 
 config IP_NF_ARPFILTER
 	tristate "ARP packet filtering"
 	depends on IP_NF_ARPTABLES
+	help
+	  ARP packet filtering defines a table `filter', which has a series of
+	  rules for simple ARP packet filtering at local input and
+	  local output.  On a bridge, you can also specify filtering rules
+	  for forwarded ARP packets. See the man page for arptables(8).
+
+	  To compile it as a module, choose M here.  If unsure, say N.
 
 config IP_NF_ARP_MANGLE
 	tristate "ARP payload mangling"
diff -purN linux-2.6.1/net/ipv4/netfilter/ip_tables.c linux-2.5/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.1/net/ipv4/netfilter/ip_tables.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_tables.c	2004-01-09 10:05:16.000000000 +0000
@@ -260,7 +260,7 @@ ipt_do_table(struct sk_buff **pskb,
 	     struct ipt_table *table,
 	     void *userdata)
 {
-	static const char nulldevname[IFNAMSIZ];
+	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
 	u_int16_t offset;
 	struct iphdr *ip;
 	u_int16_t datalen;
diff -purN linux-2.6.1/net/ipv4/raw.c linux-2.5/net/ipv4/raw.c
--- linux-2.6.1/net/ipv4/raw.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/ipv4/raw.c	2004-01-09 09:50:23.000000000 +0000
@@ -324,7 +324,7 @@ error:
 }
 
 static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		       int len)
+		       size_t len)
 {
 	struct inet_opt *inet = inet_sk(sk);
 	struct ipcm_cookie ipc;
@@ -335,17 +335,6 @@ static int raw_sendmsg(struct kiocb *ioc
 	u8  tos;
 	int err;
 
-	/* This check is ONLY to check for arithmetic overflow
-	   on integer(!) len. Not more! Real check will be made
-	   in ip_build_xmit --ANK
-
-	   BTW socket.c -> af_*.c -> ... make multiple
-	   invalid conversions size_t -> int. We MUST repair it f.e.
-	   by replacing all of them with size_t and revise all
-	   the places sort of len += sizeof(struct iphdr)
-	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
-	 */
-
 	err = -EMSGSIZE;
 	if (len < 0 || len > 0xFFFF)
 		goto out;
@@ -523,10 +512,10 @@ out:	return ret;
  */
 
 int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int noblock, int flags, int *addr_len)
+		size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_opt *inet = inet_sk(sk);
-	int copied = 0;
+	size_t copied = 0;
 	int err = -EOPNOTSUPP;
 	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 	struct sk_buff *skb;
diff -purN linux-2.6.1/net/ipv4/tcp.c linux-2.5/net/ipv4/tcp.c
--- linux-2.6.1/net/ipv4/tcp.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/ipv4/tcp.c	2004-01-09 09:50:23.000000000 +0000
@@ -1029,7 +1029,7 @@ static inline int select_size(struct soc
 }
 
 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int size)
+		size_t size)
 {
 	struct iovec *iov;
 	struct tcp_opt *tp = tcp_sk(sk);
@@ -1498,7 +1498,7 @@ int tcp_read_sock(struct sock *sk, read_
  */
 
 int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int nonblock, int flags, int *addr_len)
+		size_t len, int nonblock, int flags, int *addr_len)
 {
 	struct tcp_opt *tp = tcp_sk(sk);
 	int copied = 0;
diff -purN linux-2.6.1/net/ipv4/udp.c linux-2.5/net/ipv4/udp.c
--- linux-2.6.1/net/ipv4/udp.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/ipv4/udp.c	2004-01-09 09:50:23.000000000 +0000
@@ -478,7 +478,7 @@ static unsigned short udp_check(struct u
 }
 
 int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len)
+		size_t len)
 {
 	struct inet_opt *inet = inet_sk(sk);
 	struct udp_opt *up = udp_sk(sk);
@@ -493,18 +493,7 @@ int udp_sendmsg(struct kiocb *iocb, stru
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
 
-	/* This check is ONLY to check for arithmetic overflow
-	   on integer(!) len. Not more! Real check will be made
-	   in ip_append_* --ANK
-
-	   BTW socket.c -> af_*.c -> ... make multiple
-	   invalid conversions size_t -> int. We MUST repair it f.e.
-	   by replacing all of them with size_t and revise all
-	   the places sort of len += sizeof(struct iphdr)
-	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
-	 */
-
-	if (len < 0 || len > 0xFFFF)
+	if (len > 0xFFFF)
 		return -EMSGSIZE;
 
 	/* 
@@ -782,7 +771,7 @@ static __inline__ int udp_checksum_compl
  */
 
 int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int noblock, int flags, int *addr_len)
+		size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_opt *inet = inet_sk(sk);
   	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
diff -purN linux-2.6.1/net/ipv6/addrconf.c linux-2.5/net/ipv6/addrconf.c
--- linux-2.6.1/net/ipv6/addrconf.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/net/ipv6/addrconf.c	2004-01-16 10:05:24.000000000 +0000
@@ -81,8 +81,6 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 
-#define IPV6_MAX_ADDRESSES 16
-
 /* Set to 3 to get tracing... */
 #define ACONF_DEBUG 2
 
@@ -138,6 +136,8 @@ static void addrconf_dad_completed(struc
 static void addrconf_rs_timer(unsigned long data);
 static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
 
+static void inet6_prefix_notify(int event, struct inet6_dev *idev, 
+				struct prefix_info *pinfo);
 static int ipv6_chk_same_addr(const struct in6_addr *addr, struct net_device *dev);
 
 static struct notifier_block *inet6addr_chain;
@@ -160,6 +160,7 @@ struct ipv6_devconf ipv6_devconf = {
 	.regen_max_retry	= REGEN_MAX_RETRY,
 	.max_desync_factor	= MAX_DESYNC_FACTOR,
 #endif
+	.max_addresses		= IPV6_MAX_ADDRESSES,
 };
 
 static struct ipv6_devconf ipv6_devconf_dflt = {
@@ -180,6 +181,7 @@ static struct ipv6_devconf ipv6_devconf_
 	.regen_max_retry	= REGEN_MAX_RETRY,
 	.max_desync_factor	= MAX_DESYNC_FACTOR,
 #endif
+	.max_addresses		= IPV6_MAX_ADDRESSES,
 };
 
 /* IPv6 Wildcard Address and Loopback Address defined by RFC2553 */
@@ -373,9 +375,10 @@ static struct inet6_dev * ipv6_add_dev(s
 		write_unlock_bh(&addrconf_lock);
 
 		ipv6_mc_init_dev(ndev);
-
+		ndev->tstamp = jiffies;
 #ifdef CONFIG_SYSCTL
-		neigh_sysctl_register(dev, ndev->nd_parms, NET_IPV6, NET_IPV6_NEIGH, "ipv6");
+		neigh_sysctl_register(dev, ndev->nd_parms, NET_IPV6, 
+			NET_IPV6_NEIGH, "ipv6", &ndisc_ifinfo_sysctl_change);
 		addrconf_sysctl_register(ndev, &ndev->cnf);
 #endif
 	}
@@ -630,6 +633,7 @@ static int ipv6_create_tempaddr(struct i
 	unsigned long tmp_prefered_lft, tmp_valid_lft;
 	int tmp_plen;
 	int ret = 0;
+	int max_addresses;
 
 	if (ift) {
 		spin_lock_bh(&ift->lock);
@@ -685,9 +689,11 @@ retry:
 				 ifp->prefered_lft, 
 				 idev->cnf.temp_prefered_lft - desync_factor / HZ);
 	tmp_plen = ifp->prefix_len;
+	max_addresses = idev->cnf.max_addresses;
 	write_unlock(&idev->lock);
 	spin_unlock_bh(&ifp->lock);
-	ift = ipv6_count_addresses(idev) < IPV6_MAX_ADDRESSES ?
+	ift = !max_addresses ||
+	      ipv6_count_addresses(idev) < max_addresses ? 
 		ipv6_add_addr(idev, &addr, tmp_plen,
 			      ipv6_addr_type(&addr)&IPV6_ADDR_SCOPE_MASK, IFA_F_TEMPORARY) : 0;
 	if (!ift || IS_ERR(ift)) {
@@ -1390,10 +1396,13 @@ ok:
 		ifp = ipv6_get_ifaddr(&addr, dev);
 
 		if (ifp == NULL && valid_lft) {
+			int max_addresses = in6_dev->cnf.max_addresses;
+
 			/* Do not allow to create too much of autoconfigured
 			 * addresses; this would be too easy way to crash kernel.
 			 */
-			if (ipv6_count_addresses(in6_dev) < IPV6_MAX_ADDRESSES)
+			if (!max_addresses ||
+			    ipv6_count_addresses(in6_dev) < max_addresses)
 				ifp = ipv6_add_addr(in6_dev, &addr, pinfo->prefix_len,
 						    addr_type&IPV6_ADDR_SCOPE_MASK, 0);
 
@@ -1491,6 +1500,7 @@ ok:
 			addrconf_verify(0);
 		}
 	}
+	inet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);
 	in6_dev_put(in6_dev);
 }
 
@@ -1858,8 +1868,8 @@ static void addrconf_ip6_tnl_config(stru
 	addrconf_add_mroute(dev);
 }
 
-int addrconf_notify(struct notifier_block *this, unsigned long event, 
-		    void * data)
+static int addrconf_notify(struct notifier_block *this, unsigned long event, 
+			   void * data)
 {
 	struct net_device *dev = (struct net_device *) data;
 	struct inet6_dev *idev = __in6_dev_get(dev);
@@ -1890,6 +1900,8 @@ int addrconf_notify(struct notifier_bloc
 				rt6_mtu_change(dev, dev->mtu);
 				idev->cnf.mtu6 = dev->mtu;
 			}
+			idev->tstamp = jiffies;
+			inet6_ifinfo_notify(RTM_NEWLINK, idev);
 			/* If the changed mtu during down is lower than IPV6_MIN_MTU
 			   stop IPv6 on this interface.
 			 */
@@ -1921,7 +1933,7 @@ int addrconf_notify(struct notifier_bloc
 		if (idev) {
 			addrconf_sysctl_unregister(&idev->cnf);
 			neigh_sysctl_unregister(idev->nd_parms);
-			neigh_sysctl_register(dev, idev->nd_parms, NET_IPV6, NET_IPV6_NEIGH, "ipv6");
+			neigh_sysctl_register(dev, idev->nd_parms, NET_IPV6, NET_IPV6_NEIGH, "ipv6", &ndisc_ifinfo_sysctl_change);
 			addrconf_sysctl_register(idev, &idev->cnf);
 		}
 #endif
@@ -1931,6 +1943,14 @@ int addrconf_notify(struct notifier_bloc
 	return NOTIFY_OK;
 }
 
+/*
+ *	addrconf module should be notified of a device going up
+ */
+static struct notifier_block ipv6_dev_notf = {
+	.notifier_call = addrconf_notify,
+	.priority = 0
+};
+
 static int addrconf_ifdown(struct net_device *dev, int how)
 {
 	struct inet6_dev *idev;
@@ -2023,6 +2043,10 @@ static int addrconf_ifdown(struct net_de
 	else
 		ipv6_mc_down(idev);
 
+	/* Step 5: netlink notification of this interface */
+	idev->tstamp = jiffies;
+	inet6_ifinfo_notify(RTM_NEWLINK, idev);
+	
 	/* Shot the device (if unregistered) */
 
 	if (how == 1) {
@@ -2722,19 +2746,22 @@ static void inline ipv6_store_devconf(st
 	array[DEVCONF_REGEN_MAX_RETRY] = cnf->regen_max_retry;
 	array[DEVCONF_MAX_DESYNC_FACTOR] = cnf->max_desync_factor;
 #endif
+	array[DEVCONF_MAX_ADDRESSES] = cnf->max_addresses;
 }
 
-static int inet6_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
-			    struct inet6_dev *idev,
-			    int type, u32 pid, u32 seq)
+static int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev, 
+			     u32 pid, u32 seq, int event)
 {
+	struct net_device	*dev = idev->dev;
 	__s32			*array = NULL;
 	struct ifinfomsg	*r;
 	struct nlmsghdr 	*nlh;
 	unsigned char		*b = skb->tail;
 	struct rtattr		*subattr;
+	__u32			mtu = dev->mtu;
+	struct ifla_cacheinfo	ci;
 
-	nlh = NLMSG_PUT(skb, pid, seq, type, sizeof(*r));
+	nlh = NLMSG_PUT(skb, pid, seq, event, sizeof(*r));
 	if (pid) nlh->nlmsg_flags |= NLM_F_MULTI;
 	r = NLMSG_DATA(nlh);
 	r->ifi_family = AF_INET6;
@@ -2749,6 +2776,13 @@ static int inet6_fill_ifinfo(struct sk_b
 
 	RTA_PUT(skb, IFLA_IFNAME, strlen(dev->name)+1, dev->name);
 
+	if (dev->addr_len)
+		RTA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);
+
+	RTA_PUT(skb, IFLA_MTU, sizeof(mtu), &mtu);
+	if (dev->ifindex != dev->iflink)
+		RTA_PUT(skb, IFLA_LINK, sizeof(int), &dev->iflink);
+			
 	subattr = (struct rtattr*)skb->tail;
 
 	RTA_PUT(skb, IFLA_PROTINFO, 0, NULL);
@@ -2756,6 +2790,14 @@ static int inet6_fill_ifinfo(struct sk_b
 	/* return the device flags */
 	RTA_PUT(skb, IFLA_INET6_FLAGS, sizeof(__u32), &idev->if_flags);
 
+	/* return interface cacheinfo */
+	ci.max_reasm_len = IPV6_MAXPLEN;
+	ci.tstamp = (__u32)(TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) / HZ * 100
+		    + TIME_DELTA(idev->tstamp, INITIAL_JIFFIES) % HZ * 100 / HZ);
+	ci.reachable_time = idev->nd_parms->reachable_time;
+	ci.retrans_time = idev->nd_parms->retrans_time;
+	RTA_PUT(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci);
+	
 	/* return the device sysctl params */
 	if ((array = kmalloc(DEVCONF_MAX * sizeof(*array), GFP_ATOMIC)) == NULL)
 		goto rtattr_failure;
@@ -2790,8 +2832,8 @@ static int inet6_dump_ifinfo(struct sk_b
 			continue;
 		if ((idev = in6_dev_get(dev)) == NULL)
 			continue;
-		err = inet6_fill_ifinfo(skb, dev, idev, RTM_NEWLINK,
-				NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq);
+		err = inet6_fill_ifinfo(skb, idev, NETLINK_CB(cb->skb).pid, 
+				cb->nlh->nlmsg_seq, RTM_NEWLINK);
 		in6_dev_put(idev);
 		if (err <= 0)
 			break;
@@ -2802,6 +2844,86 @@ static int inet6_dump_ifinfo(struct sk_b
 	return skb->len;
 }
 
+void inet6_ifinfo_notify(int event, struct inet6_dev *idev)
+{
+	struct sk_buff *skb;
+	/* 128 bytes ?? */
+	int size = NLMSG_SPACE(sizeof(struct ifinfomsg)+128);
+	
+	skb = alloc_skb(size, GFP_ATOMIC);
+	if (!skb) {
+		netlink_set_err(rtnl, 0, RTMGRP_IPV6_IFINFO, ENOBUFS);
+		return;
+	}
+	if (inet6_fill_ifinfo(skb, idev, 0, 0, event) < 0) {
+		kfree_skb(skb);
+		netlink_set_err(rtnl, 0, RTMGRP_IPV6_IFINFO, EINVAL);
+		return;
+	}
+	NETLINK_CB(skb).dst_groups = RTMGRP_IPV6_IFINFO;
+	netlink_broadcast(rtnl, skb, 0, RTMGRP_IPV6_IFINFO, GFP_ATOMIC);
+}
+
+static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
+			struct prefix_info *pinfo, u32 pid, u32 seq, int event)
+{
+	struct prefixmsg	*pmsg;
+	struct nlmsghdr 	*nlh;
+	unsigned char		*b = skb->tail;
+	struct prefix_cacheinfo	ci;
+
+	nlh = NLMSG_PUT(skb, pid, seq, event, sizeof(*pmsg));
+	
+	if (pid) 
+		nlh->nlmsg_flags |= NLM_F_MULTI;
+	
+	pmsg = NLMSG_DATA(nlh);
+	pmsg->prefix_family = AF_INET6;
+	pmsg->prefix_ifindex = idev->dev->ifindex;
+	pmsg->prefix_len = pinfo->prefix_len;
+	pmsg->prefix_type = pinfo->type;
+	
+	pmsg->prefix_flags = 0;
+	if (pinfo->onlink)
+		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
+	if (pinfo->autoconf)
+		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;
+
+	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);
+
+	ci.preferred_time = ntohl(pinfo->prefered);
+	ci.valid_time = ntohl(pinfo->valid);
+	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);
+
+	nlh->nlmsg_len = skb->tail - b;
+	return skb->len;
+
+nlmsg_failure:
+rtattr_failure:
+	skb_trim(skb, b - skb->data);
+	return -1;
+}
+
+static void inet6_prefix_notify(int event, struct inet6_dev *idev, 
+			 struct prefix_info *pinfo)
+{
+	struct sk_buff *skb;
+	int size = NLMSG_SPACE(sizeof(struct prefixmsg)+128);
+
+	skb = alloc_skb(size, GFP_ATOMIC);
+	if (!skb) {
+		netlink_set_err(rtnl, 0, RTMGRP_IPV6_PREFIX, ENOBUFS);
+		return;
+	}
+	if (inet6_fill_prefix(skb, idev, pinfo, 0, 0, event) < 0) {
+		kfree_skb(skb);
+		netlink_set_err(rtnl, 0, RTMGRP_IPV6_PREFIX, EINVAL);
+		return;
+	}
+	NETLINK_CB(skb).dst_groups = RTMGRP_IPV6_PREFIX;
+	netlink_broadcast(rtnl, skb, 0, RTMGRP_IPV6_PREFIX, GFP_ATOMIC);
+}
+
 static struct rtnetlink_link inet6_rtnetlink_table[RTM_MAX - RTM_BASE + 1] = {
 	[RTM_GETLINK - RTM_BASE] = { .dumpit	= inet6_dump_ifinfo, },
 	[RTM_NEWADDR - RTM_BASE] = { .doit	= inet6_rtm_newaddr, },
@@ -3050,6 +3172,14 @@ static struct addrconf_sysctl_table
 	 		.proc_handler	=	&proc_dointvec,
 		},
 #endif
+		{
+			.ctl_name	=	NET_IPV6_MAX_ADDRESSES,
+			.procname	=	"max_addresses",
+			.data		=	&ipv6_devconf.max_addresses,
+			.maxlen		=	sizeof(int),
+			.mode		=	0644,
+			.proc_handler	=	&proc_dointvec,
+		},
 	},
 	.addrconf_dev = {
 		{
@@ -3179,9 +3309,7 @@ int unregister_inet6addr_notifier(struct
 
 void __init addrconf_init(void)
 {
-#ifdef MODULE
-	struct net_device *dev;
-#endif
+	register_netdevice_notifier(&ipv6_dev_notf);
 
 #ifdef CONFIG_IPV6_PRIVACY
 	md5_tfm = crypto_alloc_tfm("md5", 0);
@@ -3190,30 +3318,6 @@ void __init addrconf_init(void)
 			"failed to load transform for md5\n");
 #endif
 
-#ifdef MODULE
-	/* This takes sense only during module load. */
-	rtnl_lock();
-	for (dev = dev_base; dev; dev = dev->next) {
-		if (!(dev->flags&IFF_UP))
-			continue;
-
-		switch (dev->type) {
-		case ARPHRD_LOOPBACK:	
-			init_loopback(dev);
-			break;
-		case ARPHRD_ETHER:
-		case ARPHRD_FDDI:
-		case ARPHRD_IEEE802_TR:	
-		case ARPHRD_ARCNET:
-			addrconf_dev_config(dev);
-			break;
-		default:;
-			/* Ignore all other */
-		}
-	}
-	rtnl_unlock();
-#endif
-
 	addrconf_verify(0);
 	rtnetlink_links[PF_INET6] = inet6_rtnetlink_table;
 #ifdef CONFIG_SYSCTL
@@ -3231,6 +3335,8 @@ void addrconf_cleanup(void)
  	struct inet6_ifaddr *ifa;
 	int i;
 
+	unregister_netdevice_notifier(&ipv6_dev_notf);
+
 	rtnetlink_links[PF_INET6] = NULL;
 #ifdef CONFIG_SYSCTL
 	addrconf_sysctl_unregister(&ipv6_devconf_dflt);
@@ -3284,3 +3390,4 @@ void addrconf_cleanup(void)
 #endif
 }
 #endif	/* MODULE */
+
diff -purN linux-2.6.1/net/ipv6/af_inet6.c linux-2.5/net/ipv6/af_inet6.c
--- linux-2.6.1/net/ipv6/af_inet6.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/ipv6/af_inet6.c	2004-01-14 00:36:24.000000000 +0000
@@ -802,7 +802,6 @@ static int __init inet6_init(void)
 	if (if6_proc_init())
 		goto proc_if6_fail;
 #endif
-	ipv6_netdev_notif_init();
 	ipv6_packet_init();
 	ip6_route_init();
 	ip6_flowlabel_init();
@@ -869,7 +868,6 @@ static void inet6_exit(void)
 #endif
 	/* Cleanup code parts. */
 	sit_cleanup();
-	ipv6_netdev_notif_cleanup();
 	ip6_flowlabel_cleanup();
 	addrconf_cleanup();
 	ip6_route_cleanup();
diff -purN linux-2.6.1/net/ipv6/ipv6_sockglue.c linux-2.5/net/ipv6/ipv6_sockglue.c
--- linux-2.6.1/net/ipv6/ipv6_sockglue.c	2004-01-09 06:59:07.000000000 +0000
+++ linux-2.5/net/ipv6/ipv6_sockglue.c	2004-01-14 00:36:24.000000000 +0000
@@ -62,14 +62,6 @@ static struct packet_type ipv6_packet_ty
 	.func = ipv6_rcv,
 };
 
-/*
- *	addrconf module should be notified of a device going up
- */
-static struct notifier_block ipv6_dev_notf = {
-	.notifier_call = addrconf_notify,
-	.priority = 0
-};
-
 struct ip6_ra_chain *ip6_ra_chain;
 rwlock_t ip6_ra_lock = RW_LOCK_UNLOCKED;
 
@@ -707,19 +699,9 @@ void __init ipv6_packet_init(void)
 	dev_add_pack(&ipv6_packet_type);
 }
 
-void __init ipv6_netdev_notif_init(void)
-{
-	register_netdevice_notifier(&ipv6_dev_notf);
-}
-
 #ifdef MODULE
 void ipv6_packet_cleanup(void)
 {
 	dev_remove_pack(&ipv6_packet_type);
 }
-
-void ipv6_netdev_notif_cleanup(void)
-{
-	unregister_netdevice_notifier(&ipv6_dev_notf);
-}
 #endif
diff -purN linux-2.6.1/net/ipv6/mcast.c linux-2.5/net/ipv6/mcast.c
--- linux-2.6.1/net/ipv6/mcast.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv6/mcast.c	2004-01-14 00:17:54.000000000 +0000
@@ -372,9 +372,9 @@ int ip6_mc_source(int add, int omode, st
 			goto done;
 	} else if (pmc->sfmode != omode) {
 		/* allow mode switches for empty-set filters */
+		ip6_mc_add_src(idev, group, omode, 0, 0, 0);
 		ip6_mc_del_src(idev, group, pmc->sfmode, 0, 0, 0);
 		pmc->sfmode = omode;
-		ip6_mc_del_src(idev, group, pmc->sfmode, 0, 0, 0);
 	}
 
 	psl = pmc->sflist;
diff -purN linux-2.6.1/net/ipv6/ndisc.c linux-2.5/net/ipv6/ndisc.c
--- linux-2.6.1/net/ipv6/ndisc.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/ipv6/ndisc.c	2004-01-16 10:05:24.000000000 +0000
@@ -1115,6 +1115,8 @@ static void ndisc_router_discovery(struc
 			if (rtime < HZ/10)
 				rtime = HZ/10;
 			in6_dev->nd_parms->retrans_time = rtime;
+			in6_dev->tstamp = jiffies;
+			inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
 		}
 
 		rtime = ntohl(ra_msg->reachable_time);
@@ -1128,6 +1130,8 @@ static void ndisc_router_discovery(struc
 				in6_dev->nd_parms->base_reachable_time = rtime;
 				in6_dev->nd_parms->gc_staletime = 3 * rtime;
 				in6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);
+				in6_dev->tstamp = jiffies;
+				inet6_ifinfo_notify(RTM_NEWLINK, in6_dev);
 			}
 		}
 	}
@@ -1492,6 +1496,21 @@ struct notifier_block ndisc_netdev_notif
 	.notifier_call = ndisc_netdev_event,
 };
 
+#ifdef CONFIG_SYSCTL
+int ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, struct file * filp, void __user *buffer, size_t *lenp)
+{
+	struct net_device *dev = ctl->extra1;
+	struct inet6_dev *idev;
+
+	if (write && dev && (idev = in6_dev_get(dev)) != NULL) {
+		idev->tstamp = jiffies;
+		inet6_ifinfo_notify(RTM_NEWLINK, idev);
+		in6_dev_put(idev);
+	}
+	return proc_dointvec(ctl, write, filp, buffer, lenp);
+}
+#endif
+
 int __init ndisc_init(struct net_proto_family *ops)
 {
 	struct ipv6_pinfo *np;
@@ -1522,7 +1541,8 @@ int __init ndisc_init(struct net_proto_f
 	neigh_table_init(&nd_tbl);
 
 #ifdef CONFIG_SYSCTL
-	neigh_sysctl_register(NULL, &nd_tbl.parms, NET_IPV6, NET_IPV6_NEIGH, "ipv6");
+	neigh_sysctl_register(NULL, &nd_tbl.parms, NET_IPV6, NET_IPV6_NEIGH, 
+			      "ipv6", &ndisc_ifinfo_sysctl_change);
 #endif
 
 	register_netdevice_notifier(&ndisc_netdev_notifier);
diff -purN linux-2.6.1/net/ipv6/raw.c linux-2.5/net/ipv6/raw.c
--- linux-2.6.1/net/ipv6/raw.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/ipv6/raw.c	2004-01-09 09:50:23.000000000 +0000
@@ -345,13 +345,15 @@ int rawv6_rcv(struct sock *sk, struct sk
  *	we return it, otherwise we block.
  */
 
-static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len,
+static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,
+		  struct msghdr *msg, size_t len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
@@ -527,7 +529,8 @@ error:
 	IP6_INC_STATS(Ip6OutDiscards);
 	return err; 
 }
-static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len)
+static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
+		   struct msghdr *msg, size_t len)
 {
 	struct ipv6_txoptions opt_space;
 	struct sockaddr_in6 * sin6 = (struct sockaddr_in6 *) msg->msg_name;
diff -purN linux-2.6.1/net/ipv6/udp.c linux-2.5/net/ipv6/udp.c
--- linux-2.6.1/net/ipv6/udp.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv6/udp.c	2004-01-09 09:50:23.000000000 +0000
@@ -366,12 +366,14 @@ static void udpv6_close(struct sock *sk,
  * 	return it, otherwise we block.
  */
 
-static int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len,
+static int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk, 
+		  struct msghdr *msg, size_t len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
   	struct sk_buff *skb;
-  	int copied, err;
+	size_t copied;
+  	int err;
 
   	if (addr_len)
   		*addr_len=sizeof(struct sockaddr_in6);
@@ -774,7 +776,8 @@ out:
 	return err;
 }
 
-static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len)
+static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, 
+		  struct msghdr *msg, size_t len)
 {
 	struct ipv6_txoptions opt_space;
 	struct udp_opt *up = udp_sk(sk);
@@ -841,7 +844,7 @@ do_udp_sendmsg:
 	/* Rough check on arithmetic overflow,
 	   better check is made in ip6_build_xmit
 	   */
-	if (len < 0 || len > INT_MAX - sizeof(struct udphdr))
+	if (len > INT_MAX - sizeof(struct udphdr))
 		return -EMSGSIZE;
 	
 	if (up->pending) {
diff -purN linux-2.6.1/net/ipx/af_ipx.c linux-2.5/net/ipx/af_ipx.c
--- linux-2.6.1/net/ipx/af_ipx.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/ipx/af_ipx.c	2004-01-09 09:53:38.000000000 +0000
@@ -1683,7 +1683,7 @@ out:
 }
 
 static int ipx_sendmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int len)
+	struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct ipx_opt *ipxs = ipx_sk(sk);
@@ -1698,6 +1698,10 @@ static int ipx_sendmsg(struct kiocb *ioc
 	if (flags & ~MSG_DONTWAIT)
 		goto out;
 
+	/* Max possible packet size limited by 16 bit pktsize in header */
+	if (len >= 65535 - sizeof(struct ipxhdr))
+		goto out;
+
 	if (usipx) {
 		if (!ipxs->port) {
 			struct sockaddr_ipx uaddr;
@@ -1744,7 +1748,7 @@ out:
 
 
 static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
-		struct msghdr *msg, int size, int flags)
+		struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct ipx_opt *ipxs = ipx_sk(sk);
diff -purN linux-2.6.1/net/ipx/ipx_route.c linux-2.5/net/ipx/ipx_route.c
--- linux-2.6.1/net/ipx/ipx_route.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/ipx/ipx_route.c	2004-01-09 09:53:38.000000000 +0000
@@ -169,13 +169,13 @@ int ipxrtr_route_skb(struct sk_buff *skb
  * Route an outgoing frame from a socket.
  */
 int ipxrtr_route_packet(struct sock *sk, struct sockaddr_ipx *usipx,
-			struct iovec *iov, int len, int noblock)
+			struct iovec *iov, size_t len, int noblock)
 {
 	struct sk_buff *skb;
 	struct ipx_opt *ipxs = ipx_sk(sk);
 	struct ipx_interface *intrfc;
 	struct ipxhdr *ipx;
-	int size;
+	size_t size;
 	int ipx_offset;
 	struct ipx_route *rt = NULL;
 	int rc;
diff -purN linux-2.6.1/net/irda/af_irda.c linux-2.5/net/irda/af_irda.c
--- linux-2.6.1/net/irda/af_irda.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/af_irda.c	2004-01-09 10:10:53.000000000 +0000
@@ -1257,7 +1257,7 @@ static int irda_release(struct socket *s
  *    fragment the message if necessary
  */
 static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1329,12 +1329,13 @@ static int irda_sendmsg(struct kiocb *io
  *    after being read, regardless of how much the user actually read
  */
 static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int size, int flags)
+			      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self = irda_sk(sk);
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	IRDA_DEBUG(4, "%s()\n", __FUNCTION__);
 
@@ -1379,12 +1380,12 @@ static int irda_recvmsg_dgram(struct kio
  * Function irda_recvmsg_stream (iocb, sock, msg, size, flags)
  */
 static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size, int flags)
+			       struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self = irda_sk(sk);
 	int noblock = flags & MSG_DONTWAIT;
-	int copied = 0;
+	size_t copied = 0;
 	int target = 1;
 	DECLARE_WAITQUEUE(waitq, current);
 
@@ -1505,7 +1506,7 @@ static int irda_recvmsg_stream(struct ki
  *
  */
 static int irda_sendmsg_dgram(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1571,7 +1572,7 @@ static int irda_sendmsg_dgram(struct kio
  */
 #ifdef CONFIG_IRDA_ULTRA
 static int irda_sendmsg_ultra(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1890,11 +1891,10 @@ static int irda_setsockopt(struct socket
 		case IAS_STRING:
 			/* Should check charset & co */
 			/* Check length */
-			if(ias_opt->attribute.irda_attrib_string.len >
-			   IAS_MAX_STRING) {
-				kfree(ias_opt);
-				return -EINVAL;
-			}
+			/* The length is encoded in a __u8, and
+			 * IAS_MAX_STRING == 256, so there is no way
+			 * userspace can pass us a string too large.
+			 * Jean II */
 			/* NULL terminate the string (avoid troubles) */
 			ias_opt->attribute.irda_attrib_string.string[ias_opt->attribute.irda_attrib_string.len] = '\0';
 			/* Add a string attribute */
diff -purN linux-2.6.1/net/irda/ircomm/ircomm_tty.c linux-2.5/net/irda/ircomm/ircomm_tty.c
--- linux-2.6.1/net/irda/ircomm/ircomm_tty.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/ircomm/ircomm_tty.c	2004-01-15 08:24:20.000000000 +0000
@@ -38,6 +38,7 @@
 #include <linux/termios.h>
 #include <linux/tty.h>
 #include <linux/interrupt.h>
+#include <linux/device.h>		/* for MODULE_ALIAS_CHARDEV_MAJOR */
 
 #include <asm/uaccess.h>
 
@@ -85,7 +86,9 @@ static struct tty_operations ops = {
 	.write_room      = ircomm_tty_write_room,
 	.chars_in_buffer = ircomm_tty_chars_in_buffer,
 	.flush_buffer    = ircomm_tty_flush_buffer,
-	.ioctl           = ircomm_tty_ioctl,
+	.ioctl           = ircomm_tty_ioctl,	/* ircomm_tty_ioctl.c */
+	.tiocmget        = ircomm_tty_tiocmget,	/* ircomm_tty_ioctl.c */
+	.tiocmset        = ircomm_tty_tiocmset,	/* ircomm_tty_ioctl.c */
 	.throttle        = ircomm_tty_throttle,
 	.unthrottle      = ircomm_tty_unthrottle,
 	.send_xchar      = ircomm_tty_send_xchar,
@@ -1411,6 +1414,7 @@ done:
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("IrCOMM serial TTY driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(IRCOMM_TTY_MAJOR);
 
 module_init(ircomm_tty_init);
 module_exit(ircomm_tty_cleanup);
diff -purN linux-2.6.1/net/irda/ircomm/ircomm_tty_ioctl.c linux-2.5/net/irda/ircomm/ircomm_tty_ioctl.c
--- linux-2.6.1/net/irda/ircomm/ircomm_tty_ioctl.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/net/irda/ircomm/ircomm_tty_ioctl.c	2004-01-15 08:24:20.000000000 +0000
@@ -190,81 +190,62 @@ void ircomm_tty_set_termios(struct tty_s
 }
 
 /*
- * Function ircomm_tty_get_modem_info (self, value)
+ * Function ircomm_tty_tiocmget (tty, file)
  *
  *    
  *
  */
-static int ircomm_tty_get_modem_info(struct ircomm_tty_cb *self, 
-				     unsigned int *value)
+int ircomm_tty_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;
 	unsigned int result;
 
 	IRDA_DEBUG(2, "%s()\n", __FUNCTION__ );
 
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
 	result =  ((self->settings.dte & IRCOMM_RTS) ? TIOCM_RTS : 0)
 		| ((self->settings.dte & IRCOMM_DTR) ? TIOCM_DTR : 0)
 		| ((self->settings.dce & IRCOMM_CD)  ? TIOCM_CAR : 0)
 		| ((self->settings.dce & IRCOMM_RI)  ? TIOCM_RNG : 0)
 		| ((self->settings.dce & IRCOMM_DSR) ? TIOCM_DSR : 0)
 		| ((self->settings.dce & IRCOMM_CTS) ? TIOCM_CTS : 0);
-
-	return put_user(result, value);
+	return result;
 }
 
 /*
- * Function set_modem_info (driver, cmd, value)
+ * Function ircomm_tty_tiocmset (tty, file, set, clear)
  *
  *    
  *
  */
-static int ircomm_tty_set_modem_info(struct ircomm_tty_cb *self, 
-				     unsigned int cmd, unsigned int *value)
+int ircomm_tty_tiocmset(struct tty_struct *tty, struct file *file,
+			unsigned int set, unsigned int clear)
 { 
-	unsigned int arg;
-	__u8 old_rts, old_dtr;
+	struct ircomm_tty_cb *self = (struct ircomm_tty_cb *) tty->driver_data;
 
 	IRDA_DEBUG(2, "%s()\n", __FUNCTION__ );
 
+	if (tty->flags & (1 << TTY_IO_ERROR))
+		return -EIO;
+
 	ASSERT(self != NULL, return -1;);
 	ASSERT(self->magic == IRCOMM_TTY_MAGIC, return -1;);
 
-	if (get_user(arg, value))
-		return -EFAULT;
-
-	old_rts = self->settings.dte & IRCOMM_RTS;
-	old_dtr = self->settings.dte & IRCOMM_DTR;
+	if (set & TIOCM_RTS)
+		self->settings.dte |= IRCOMM_RTS;
+	if (set & TIOCM_DTR)
+		self->settings.dte |= IRCOMM_DTR;
+
+	if (clear & TIOCM_RTS)
+		self->settings.dte &= ~IRCOMM_RTS;
+	if (clear & TIOCM_DTR)
+		self->settings.dte &= ~IRCOMM_DTR;
 
-	switch (cmd) {
-	case TIOCMBIS: 
-		if (arg & TIOCM_RTS) 
-			self->settings.dte |= IRCOMM_RTS;
-		if (arg & TIOCM_DTR)
-			self->settings.dte |= IRCOMM_DTR;
-		break;
-		
-	case TIOCMBIC:
-		if (arg & TIOCM_RTS)
-			self->settings.dte &= ~IRCOMM_RTS;
-		if (arg & TIOCM_DTR)
- 			self->settings.dte &= ~IRCOMM_DTR;
- 		break;
-		
-	case TIOCMSET:
- 		self->settings.dte = 
-			((self->settings.dte & ~(IRCOMM_RTS | IRCOMM_DTR))
-			 | ((arg & TIOCM_RTS) ? IRCOMM_RTS : 0)
-			 | ((arg & TIOCM_DTR) ? IRCOMM_DTR : 0));
-		break;
-		
-	default:
-		return -EINVAL;
-	}
-	
-	if ((self->settings.dte & IRCOMM_RTS) != old_rts)
+	if ((set|clear) & TIOCM_RTS)
 		self->settings.dte |= IRCOMM_DELTA_RTS;
-
-	if ((self->settings.dte & IRCOMM_DTR) != old_dtr)
+	if ((set|clear) & TIOCM_DTR)
 		self->settings.dte |= IRCOMM_DELTA_DTR;
 
 	ircomm_param_request(self, IRCOMM_DTE, TRUE);
@@ -406,14 +387,6 @@ int ircomm_tty_ioctl(struct tty_struct *
 	}
 
 	switch (cmd) {
-	case TIOCMGET:
-		ret = ircomm_tty_get_modem_info(self, (unsigned int *) arg);
-		break;
-	case TIOCMBIS:
-	case TIOCMBIC:
-	case TIOCMSET:
-		ret = ircomm_tty_set_modem_info(self, cmd, (unsigned int *) arg);
-		break;
 	case TIOCGSERIAL:
 		ret = ircomm_tty_get_serial_info(self, (struct serial_struct *) arg);
 		break;
diff -purN linux-2.6.1/net/irda/irlap_event.c linux-2.5/net/irda/irlap_event.c
--- linux-2.6.1/net/irda/irlap_event.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/irda/irlap_event.c	2004-01-09 10:08:28.000000000 +0000
@@ -932,6 +932,12 @@ static int irlap_state_setup(struct irla
 		/* This frame will actually be sent at the new speed */
 		irlap_send_rr_frame(self, CMD_FRAME);
 
+		/* The timer is set to half the normal timer to quickly
+		 * detect a failure to negociate the new connection
+		 * parameters. IrLAP 6.11.3.2, note 3.
+		 * Note that currently we don't process this failure
+		 * properly, as we should do a quick disconnect.
+		 * Jean II */
 		irlap_start_final_timer(self, self->final_timeout/2);
 		irlap_next_state(self, LAP_NRM_P);
 
@@ -1312,7 +1318,12 @@ static int irlap_state_nrm_p(struct irla
 				irlap_resend_rejected_frames(self, CMD_FRAME);
 
 				self->ack_required = FALSE;
-				irlap_start_final_timer(self, self->final_timeout);
+
+				/* Make sure we account for the time
+				 * to transmit our frames. See comemnts
+				 * in irlap_send_data_primary_poll().
+				 * Jean II */
+				irlap_start_final_timer(self, 2 * self->final_timeout);
 
 				/* Keep state, do not move this line */
 				irlap_next_state(self, LAP_NRM_P);
@@ -1352,8 +1363,9 @@ static int irlap_state_nrm_p(struct irla
 				/* Resend rejected frames */
 				irlap_resend_rejected_frames(self, CMD_FRAME);
 
-				/* Give peer some time to retransmit! */
-				irlap_start_final_timer(self, self->final_timeout);
+				/* Give peer some time to retransmit! 
+				 * But account for our own Tx. */
+				irlap_start_final_timer(self, 2 * self->final_timeout);
 
 				/* Keep state, do not move this line */
 				irlap_next_state(self, LAP_NRM_P);
@@ -1450,6 +1462,8 @@ static int irlap_state_nrm_p(struct irla
 			/* Resend rejected frames */
 			irlap_resend_rejected_frames(self, CMD_FRAME);
 
+			/* Final timer ??? Jean II */
+
 			irlap_next_state(self, LAP_NRM_P);
 		} else if (ret == NR_INVALID) {
 			IRDA_DEBUG(1, "%s(), Received RR with "
@@ -1541,7 +1555,7 @@ static int irlap_state_nrm_p(struct irla
 			irlap_send_rr_frame(self, CMD_FRAME);
 		} else
 			irlap_resend_rejected_frames(self, CMD_FRAME);
-		irlap_start_final_timer(self, self->final_timeout);
+		irlap_start_final_timer(self, 2 * self->final_timeout);
 		break;
 	case RECV_SREJ_RSP:
 		irlap_update_nr_received(self, info->nr);
@@ -1550,7 +1564,7 @@ static int irlap_state_nrm_p(struct irla
 			irlap_send_rr_frame(self, CMD_FRAME);
 		} else
 			irlap_resend_rejected_frame(self, CMD_FRAME);
-		irlap_start_final_timer(self, self->final_timeout);
+		irlap_start_final_timer(self, 2 * self->final_timeout);
 		break;
 	case RECV_RD_RSP:
 		IRDA_DEBUG(1, "%s(), RECV_RD_RSP\n", __FUNCTION__);
diff -purN linux-2.6.1/net/irda/irlap_frame.c linux-2.5/net/irda/irlap_frame.c
--- linux-2.6.1/net/irda/irlap_frame.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/irlap_frame.c	2004-01-09 10:08:28.000000000 +0000
@@ -779,6 +779,7 @@ void irlap_send_data_primary(struct irla
 void irlap_send_data_primary_poll(struct irlap_cb *self, struct sk_buff *skb)
 {
 	struct sk_buff *tx_skb;
+	int transmission_time;
 
 	/* Stop P timer */
 	del_timer(&self->poll_timer);
@@ -829,13 +830,49 @@ void irlap_send_data_primary_poll(struct
 		}
 	}
 
+	/* How much time we took for transmission of all frames.
+	 * We don't know, so let assume we used the full window. Jean II */
+	transmission_time = self->final_timeout;
+
+	/* Reset parameter so that we can fill next window */
 	self->window = self->window_size;
+
 #ifdef CONFIG_IRDA_DYNAMIC_WINDOW
+	/* Remove what we have not used. Just do a prorata of the
+	 * bytes left in window to window capacity.
+	 * See max_line_capacities[][] in qos.c for details. Jean II */
+	transmission_time -= (self->final_timeout * self->bytes_left
+			      / self->line_capacity);
+	IRDA_DEBUG(4, "%s() adjusting transmission_time : ft=%d, bl=%d, lc=%d -> tt=%d\n", __FUNCTION__, self->final_timeout, self->bytes_left, self->line_capacity, transmission_time);
+
 	/* We are allowed to transmit a maximum number of bytes again. */
 	self->bytes_left = self->line_capacity;
 #endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
 
-	irlap_start_final_timer(self, self->final_timeout);
+	/*
+	 * The network layer has a intermediate buffer between IrLAP
+	 * and the IrDA driver which can contain 8 frames. So, even
+	 * though IrLAP is currently sending the *last* frame of the
+	 * tx-window, the driver most likely has only just started
+	 * sending the *first* frame of the same tx-window.
+	 * I.e. we are always at the very begining of or Tx window.
+	 * Now, we are supposed to set the final timer from the end
+	 * of our tx-window to let the other peer reply. So, we need
+	 * to add extra time to compensate for the fact that we
+	 * are really at the start of tx-window, otherwise the final timer
+	 * might expire before he can answer...
+	 * Jean II
+	 */
+	irlap_start_final_timer(self, self->final_timeout + transmission_time);
+
+	/*
+	 * The clever amongst you might ask why we do this adjustement
+	 * only here, and not in all the other cases in irlap_event.c.
+	 * In all those other case, we only send a very short management
+	 * frame (few bytes), so the adjustement would be lost in the
+	 * noise...
+	 * The exception of course is irlap_resend_rejected_frame().
+	 * Jean II */
 }
 
 /*
@@ -1003,7 +1040,7 @@ void irlap_resend_rejected_frames(struct
 	}
 #if 0 /* Not yet */
 	/*
-	 *  We can now fill the window with additinal data frames
+	 *  We can now fill the window with additional data frames
 	 */
 	while (skb_queue_len( &self->txq) > 0) {
 
diff -purN linux-2.6.1/net/key/af_key.c linux-2.5/net/key/af_key.c
--- linux-2.6.1/net/key/af_key.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/key/af_key.c	2004-01-14 07:24:28.000000000 +0000
@@ -1283,6 +1283,7 @@ static int pfkey_delete(struct sock *sk,
 
 static int pfkey_get(struct sock *sk, struct sk_buff *skb, struct sadb_msg *hdr, void **ext_hdrs)
 {
+	__u8 proto;
 	struct sk_buff *out_skb;
 	struct sadb_msg *out_hdr;
 	struct xfrm_state *x;
@@ -1297,6 +1298,7 @@ static int pfkey_get(struct sock *sk, st
 		return -ESRCH;
 
 	out_skb = pfkey_xfrm_state2msg(x, 1, 3);
+	proto = x->id.proto;
 	xfrm_state_put(x);
 	if (IS_ERR(out_skb))
 		return  PTR_ERR(out_skb);
@@ -1304,7 +1306,7 @@ static int pfkey_get(struct sock *sk, st
 	out_hdr = (struct sadb_msg *) out_skb->data;
 	out_hdr->sadb_msg_version = hdr->sadb_msg_version;
 	out_hdr->sadb_msg_type = SADB_DUMP;
-	out_hdr->sadb_msg_satype = pfkey_proto2satype(x->id.proto);
+	out_hdr->sadb_msg_satype = pfkey_proto2satype(proto);
 	out_hdr->sadb_msg_errno = 0;
 	out_hdr->sadb_msg_reserved = 0;
 	out_hdr->sadb_msg_seq = hdr->sadb_msg_seq;
@@ -2655,7 +2657,7 @@ static int pfkey_send_new_mapping(struct
 }
 
 static int pfkey_sendmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, int len)
+			 struct socket *sock, struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb = NULL;
@@ -2697,7 +2699,7 @@ out:
 }
 
 static int pfkey_recvmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, int len,
+			 struct socket *sock, struct msghdr *msg, size_t len,
 			 int flags)
 {
 	struct sock *sk = sock->sk;
diff -purN linux-2.6.1/net/llc/af_llc.c linux-2.5/net/llc/af_llc.c
--- linux-2.6.1/net/llc/af_llc.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/net/llc/af_llc.c	2004-01-09 09:55:43.000000000 +0000
@@ -671,12 +671,13 @@ out:
  *	Returns non-negative upon success, negative otherwise.
  */
 static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int size, int flags)
+			  struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;
 	struct sk_buff *skb;
-	int rc = -ENOMEM, copied = 0, timeout;
+	size_t copied = 0;
+	int rc = -ENOMEM, timeout;
 	int noblock = flags & MSG_DONTWAIT;
 
 	dprintk("%s: receiving in %02X from %02X\n", __FUNCTION__,
@@ -725,7 +726,7 @@ out:
  *	Returns non-negative upon success, negative otherwise.
  */
 static int llc_ui_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct llc_opt *llc = llc_sk(sk);
@@ -734,7 +735,8 @@ static int llc_ui_sendmsg(struct kiocb *
 	int noblock = flags & MSG_DONTWAIT;
 	struct net_device *dev;
 	struct sk_buff *skb;
-	int rc = -EINVAL, size = 0, copied = 0, hdrlen;
+	size_t size = 0;
+	int rc = -EINVAL, copied = 0, hdrlen;
 
 	dprintk("%s: sending from %02X to %02X\n", __FUNCTION__,
 		llc->laddr.lsap, llc->daddr.lsap);
diff -purN linux-2.6.1/net/netlink/af_netlink.c linux-2.5/net/netlink/af_netlink.c
--- linux-2.6.1/net/netlink/af_netlink.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/net/netlink/af_netlink.c	2004-01-09 09:54:26.000000000 +0000
@@ -601,7 +601,7 @@ static inline void netlink_rcv_wake(stru
 }
 
 static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			   struct msghdr *msg, int len)
+			   struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -641,7 +641,7 @@ static int netlink_sendmsg(struct kiocb 
 	}
 
 	err = -EMSGSIZE;
-	if ((unsigned)len > sk->sk_sndbuf - 32)
+	if (len > sk->sk_sndbuf - 32)
 		goto out;
 	err = -ENOBUFS;
 	skb = alloc_skb(len, GFP_KERNEL);
@@ -683,7 +683,7 @@ out:
 }
 
 static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
-			   struct msghdr *msg, int len,
+			   struct msghdr *msg, size_t len,
 			   int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
@@ -691,7 +691,7 @@ static int netlink_recvmsg(struct kiocb 
 	struct sock *sk = sock->sk;
 	struct netlink_opt *nlk = nlk_sk(sk);
 	int noblock = flags&MSG_DONTWAIT;
-	int copied;
+	size_t copied;
 	struct sk_buff *skb;
 	int err;
 
diff -purN linux-2.6.1/net/netrom/af_netrom.c linux-2.5/net/netrom/af_netrom.c
--- linux-2.6.1/net/netrom/af_netrom.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/netrom/af_netrom.c	2004-01-09 09:56:08.000000000 +0000
@@ -1010,7 +1010,7 @@ int nr_rx_frame(struct sk_buff *skb, str
 }
 
 static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,
-		      struct msghdr *msg, int len)
+		      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	nr_cb *nr = nr_sk(sk);
@@ -1119,11 +1119,11 @@ out:
 }
 
 static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
-		      struct msghdr *msg, int size, int flags)
+		      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;
-	int copied;
+	size_t copied;
 	struct sk_buff *skb;
 	int er;
 
diff -purN linux-2.6.1/net/packet/af_packet.c linux-2.5/net/packet/af_packet.c
--- linux-2.6.1/net/packet/af_packet.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/net/packet/af_packet.c	2004-01-15 20:00:08.000000000 +0000
@@ -284,7 +284,7 @@ oom:
  */
  
 static int packet_sendmsg_spkt(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_pkt *saddr=(struct sockaddr_pkt *)msg->msg_name;
@@ -659,7 +659,7 @@ ring_is_full:
 
 
 static int packet_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ll *saddr=(struct sockaddr_ll *)msg->msg_name;
@@ -1007,7 +1007,7 @@ out:
  */
 
 static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len, int flags)
+			  struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
@@ -1550,7 +1550,7 @@ static int packet_set_ring(struct sock *
 	unsigned long *pg_vec = NULL;
 	struct tpacket_hdr **io_vec = NULL;
 	struct packet_opt *po = pkt_sk(sk);
-	int order = 0;
+	int was_running, num, order = 0;
 	int err = 0;
 
 	if (req->tp_block_nr) {
@@ -1623,10 +1623,13 @@ static int packet_set_ring(struct sock *
 
 	/* Detach socket from network */
 	spin_lock(&po->bind_lock);
-	if (po->running) {
+	was_running = po->running;
+	num = po->num;
+	if (was_running) {
 		__dev_remove_pack(&po->prot_hook);
 		po->num = 0;
 		po->running = 0;
+		__sock_put(sk);
 	}
 	spin_unlock(&po->bind_lock);
 		
@@ -1657,8 +1660,12 @@ static int packet_set_ring(struct sock *
 	}
 
 	spin_lock(&po->bind_lock);
-	if (po->running)
+	if (was_running && !po->running) {
+		sock_hold(sk);
+		po->running = 1;
+		po->num = num;
 		dev_add_pack(&po->prot_hook);
+	}
 	spin_unlock(&po->bind_lock);
 
 	release_sock(sk);
diff -purN linux-2.6.1/net/rose/af_rose.c linux-2.5/net/rose/af_rose.c
--- linux-2.6.1/net/rose/af_rose.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/rose/af_rose.c	2004-01-09 09:56:39.000000000 +0000
@@ -1010,7 +1010,7 @@ int rose_rx_call_request(struct sk_buff 
 }
 
 static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	rose_cb *rose = rose_sk(sk);
@@ -1174,15 +1174,15 @@ static int rose_sendmsg(struct kiocb *io
 
 
 static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int size, int flags)
+			struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	rose_cb *rose = rose_sk(sk);
 	struct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;
-	int copied, qbit;
+	size_t copied;
 	unsigned char *asmptr;
 	struct sk_buff *skb;
-	int n, er;
+	int n, er, qbit;
 
 	/*
 	 * This works for seqpacket too. The receiver has ordered the queue for
diff -purN linux-2.6.1/net/sched/sch_teql.c linux-2.5/net/sched/sch_teql.c
--- linux-2.6.1/net/sched/sch_teql.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/sched/sch_teql.c	2004-01-15 22:20:23.000000000 +0000
@@ -456,7 +456,6 @@ static __init void teql_master_setup(str
 }
 
 static LIST_HEAD(master_dev_list);
-static spinlock_t master_dev_lock = SPIN_LOCK_UNLOCKED;
 static int max_equalizers = 1;
 MODULE_PARM(max_equalizers, "i");
 MODULE_PARM_DESC(max_equalizers, "Max number of link equalizers");
@@ -475,13 +474,13 @@ int __init teql_init(void)
 		if (!dev)
 			return -ENOMEM;
 
-		if ((err = register_netdev(dev)))
+		if ((err = register_netdev(dev))) {
+			free_netdev(dev);
 			goto out;
+		}
 
 		master = dev->priv;
-		spin_lock(&master_dev_lock);
 		list_add_tail(&master->master_list, &master_dev_list);
-		spin_unlock(&master_dev_lock);
 	}
  out:
 	return err;
@@ -491,7 +490,6 @@ static void __exit teql_exit(void) 
 {
 	struct teql_master *master, *nxt;
 
-	spin_lock(&master_dev_lock);
 	list_for_each_entry_safe(master, nxt, &master_dev_list, master_list) {
 
 		list_del(&master->master_list);
@@ -500,7 +498,6 @@ static void __exit teql_exit(void) 
 		unregister_netdev(master->dev);
 		free_netdev(master->dev);
 	}
-	spin_unlock(&master_dev_lock);
 }
 
 module_init(teql_init);
diff -purN linux-2.6.1/net/sctp/socket.c linux-2.5/net/sctp/socket.c
--- linux-2.6.1/net/sctp/socket.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/net/sctp/socket.c	2004-01-09 09:50:23.000000000 +0000
@@ -90,7 +90,7 @@ static inline int sctp_wspace(struct sct
 static inline void sctp_set_owner_w(struct sctp_chunk *chunk);
 static void sctp_wfree(struct sk_buff *skb);
 static int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,
-				int msg_len);
+				size_t msg_len);
 static int sctp_wait_for_packet(struct sock * sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
@@ -943,7 +943,7 @@ static int sctp_error(struct sock *sk, i
 SCTP_STATIC int sctp_msghdr_parse(const struct msghdr *, sctp_cmsgs_t *);
 
 SCTP_STATIC int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
-			     struct msghdr *msg, int msg_len)
+			     struct msghdr *msg, size_t msg_len)
 {
 	struct sctp_opt *sp;
 	struct sctp_endpoint *ep;
@@ -965,7 +965,7 @@ SCTP_STATIC int sctp_sendmsg(struct kioc
 	struct list_head *pos;
 	int msg_flags = msg->msg_flags;
 
-	SCTP_DEBUG_PRINTK("sctp_sendmsg(sk: %p, msg: %p, msg_len: %d)\n",
+	SCTP_DEBUG_PRINTK("sctp_sendmsg(sk: %p, msg: %p, msg_len: %u)\n",
 			  sk, msg, msg_len);
 
 	err = 0;
@@ -1021,7 +1021,7 @@ SCTP_STATIC int sctp_sendmsg(struct kioc
 		associd = sinfo->sinfo_assoc_id;
 	}
 
-	SCTP_DEBUG_PRINTK("msg_len: %d, sinfo_flags: 0x%x\n",
+	SCTP_DEBUG_PRINTK("msg_len: %u, sinfo_flags: 0x%x\n",
 			  msg_len, sinfo_flags);
 
 	/* MSG_EOF or MSG_ABORT cannot be set on a TCP-style socket. */
@@ -1377,7 +1377,7 @@ static int sctp_skb_pull(struct sk_buff 
 static struct sk_buff *sctp_skb_recv_datagram(struct sock *, int, int, int *);
 
 SCTP_STATIC int sctp_recvmsg(struct kiocb *iocb, struct sock *sk,
-			     struct msghdr *msg, int len, int noblock,
+			     struct msghdr *msg, size_t len, int noblock,
 			     int flags, int *addr_len)
 {
 	struct sctp_ulpevent *event = NULL;
@@ -4157,14 +4157,14 @@ static void sctp_wfree(struct sk_buff *s
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
-				int msg_len)
+				size_t msg_len)
 {
 	struct sock *sk = asoc->base.sk;
 	int err = 0;
 	long current_timeo = *timeo_p;
 	DEFINE_WAIT(wait);
 
-	SCTP_DEBUG_PRINTK("wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%d\n",
+	SCTP_DEBUG_PRINTK("wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%u\n",
 	                  asoc, (long)(*timeo_p), msg_len);
 
 	/* Increment the association's refcnt.  */
diff -purN linux-2.6.1/net/socket.c linux-2.5/net/socket.c
--- linux-2.6.1/net/socket.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/socket.c	2004-01-09 09:46:38.000000000 +0000
@@ -523,7 +523,8 @@ void sock_release(struct socket *sock)
 	sock->file=NULL;
 }
 
-static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int size)
+static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+				 struct msghdr *msg, size_t size)
 {
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 	int err;
@@ -540,7 +541,7 @@ static inline int __sock_sendmsg(struct 
 	return sock->ops->sendmsg(iocb, sock, msg, size);
 }
 
-int sock_sendmsg(struct socket *sock, struct msghdr *msg, int size)
+int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 {
 	struct kiocb iocb;
 	int ret;
@@ -553,7 +554,8 @@ int sock_sendmsg(struct socket *sock, st
 }
 
 
-static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int size, int flags)
+static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock, 
+				 struct msghdr *msg, size_t size, int flags)
 {
 	int err;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
@@ -571,7 +573,8 @@ static inline int __sock_recvmsg(struct 
 	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
 }
 
-int sock_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags)
+int sock_recvmsg(struct socket *sock, struct msghdr *msg, 
+		 size_t size, int flags)
 {
 	struct kiocb iocb;
 	int ret;
@@ -668,7 +671,7 @@ ssize_t sock_sendpage(struct file *file,
 }
 
 int sock_readv_writev(int type, struct inode * inode, struct file * file,
-		      const struct iovec * iov, long count, long size)
+		      const struct iovec * iov, long count, size_t size)
 {
 	struct msghdr msg;
 	struct socket *sock;
diff -purN linux-2.6.1/net/unix/af_unix.c linux-2.5/net/unix/af_unix.c
--- linux-2.6.1/net/unix/af_unix.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/unix/af_unix.c	2004-01-09 09:57:02.000000000 +0000
@@ -1176,7 +1176,7 @@ static void unix_attach_fds(struct scm_c
  */
 
 static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -1217,7 +1217,7 @@ static int unix_dgram_sendmsg(struct kio
 		goto out;
 
 	err = -EMSGSIZE;
-	if ((unsigned)len > sk->sk_sndbuf - 32)
+	if (len > sk->sk_sndbuf - 32)
 		goto out;
 
 	skb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);
@@ -1324,7 +1324,7 @@ out:
 
 		
 static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -1447,7 +1447,7 @@ static void unix_copy_addr(struct msghdr
 }
 
 static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int size,
+			      struct msghdr *msg, size_t size,
 			      int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
@@ -1555,7 +1555,7 @@ static long unix_stream_data_wait(struct
 
 
 static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size,
+			       struct msghdr *msg, size_t size,
 			       int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
diff -purN linux-2.6.1/net/x25/af_x25.c linux-2.5/net/x25/af_x25.c
--- linux-2.6.1/net/x25/af_x25.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/net/x25/af_x25.c	2004-01-14 00:37:15.000000000 +0000
@@ -910,7 +910,7 @@ out_clear_request:
 }
 
 static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *msg, int len)
+		       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct x25_opt *x25 = x25_sk(sk);
@@ -919,7 +919,8 @@ static int x25_sendmsg(struct kiocb *ioc
 	struct sk_buff *skb;
 	unsigned char *asmptr;
 	int noblock = msg->msg_flags & MSG_DONTWAIT;
-	int size, qbit = 0, rc = -EINVAL;
+	size_t size;
+	int qbit = 0, rc = -EINVAL;
 
 	if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_OOB | MSG_EOR))
 		goto out;
@@ -1085,13 +1086,14 @@ out_kfree_skb:
 
 
 static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *msg, int size,
+		       struct msghdr *msg, size_t size,
 		       int flags)
 {
 	struct sock *sk = sock->sk;
 	struct x25_opt *x25 = x25_sk(sk);
 	struct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;
-	int copied, qbit;
+	size_t copied;
+	int qbit;
 	struct sk_buff *skb;
 	unsigned char *asmptr;
 	int rc = -ENOTCONN;
@@ -1370,9 +1372,6 @@ void x25_kill_by_neigh(struct x25_neigh 
 
 static int __init x25_init(void)
 {
-#ifdef MODULE
-	struct net_device *dev;
-#endif /* MODULE */
 	sock_register(&x25_family_ops);
 
 	dev_add_pack(&x25_packet_type);
@@ -1384,23 +1383,7 @@ static int __init x25_init(void)
 #ifdef CONFIG_SYSCTL
 	x25_register_sysctl();
 #endif
-
 	x25_proc_init();
-#ifdef MODULE
-	/*
-	 *	Register any pre existing devices.
-	 */
-	read_lock(&dev_base_lock);
-	for (dev = dev_base; dev; dev = dev->next) {
-		if ((dev->flags & IFF_UP) && (dev->type == ARPHRD_X25
-#if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)
-					   || dev->type == ARPHRD_ETHER
-#endif
-			))
-			x25_link_device_up(dev);
-	}
-	read_unlock(&dev_base_lock);
-#endif /* MODULE */
 	return 0;
 }
 module_init(x25_init);
diff -purN linux-2.6.1/net/xfrm/xfrm_algo.c linux-2.5/net/xfrm/xfrm_algo.c
--- linux-2.6.1/net/xfrm/xfrm_algo.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/xfrm/xfrm_algo.c	2004-01-10 04:53:40.000000000 +0000
@@ -85,7 +85,7 @@ static struct xfrm_algo_desc aalg_list[]
 
 	.uinfo = {
 		.auth = {
-			.icv_truncbits = 128,
+			.icv_truncbits = 96,
 			.icv_fullbits = 256,
 		}
 	},
diff -purN linux-2.6.1/net/xfrm/xfrm_policy.c linux-2.5/net/xfrm/xfrm_policy.c
--- linux-2.6.1/net/xfrm/xfrm_policy.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/net/xfrm/xfrm_policy.c	2004-01-14 07:30:19.000000000 +0000
@@ -775,33 +775,32 @@ restart:
 
 		if (unlikely(nx<0)) {
 			err = nx;
-			if (err == -EAGAIN) {
-				struct task_struct *tsk = current;
-				DECLARE_WAITQUEUE(wait, tsk);
-				if (!flags)
-					goto error;
+			if (err == -EAGAIN && !flags) {
+				DECLARE_WAITQUEUE(wait, current);
 
-				__set_task_state(tsk, TASK_INTERRUPTIBLE);
 				add_wait_queue(&km_waitq, &wait);
-				err = xfrm_tmpl_resolve(policy, fl, xfrm, family);
-				if (err == -EAGAIN)
-					schedule();
-				__set_task_state(tsk, TASK_RUNNING);
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule();
+				set_current_state(TASK_RUNNING);
 				remove_wait_queue(&km_waitq, &wait);
 
-				if (err == -EAGAIN && signal_pending(current)) {
+				nx = xfrm_tmpl_resolve(policy, fl, xfrm, family);
+
+				if (nx == -EAGAIN && signal_pending(current)) {
 					err = -ERESTART;
 					goto error;
 				}
-				if (err == -EAGAIN ||
+				if (nx == -EAGAIN ||
 				    genid != atomic_read(&flow_cache_genid)) {
 					xfrm_pol_put(policy);
 					goto restart;
 				}
+				err = nx;
 			}
-			if (err)
+			if (err < 0)
 				goto error;
-		} else if (nx == 0) {
+		}
+		if (nx == 0) {
 			/* Flow passes not transformed. */
 			xfrm_pol_put(policy);
 			return 0;
diff -purN linux-2.6.1/net/xfrm/xfrm_user.c linux-2.5/net/xfrm/xfrm_user.c
--- linux-2.6.1/net/xfrm/xfrm_user.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/xfrm/xfrm_user.c	2004-01-14 07:28:11.000000000 +0000
@@ -241,6 +241,7 @@ static struct xfrm_state *xfrm_state_con
 	return x;
 
 error:
+	x->km.state = XFRM_STATE_DEAD;
 	xfrm_state_put(x);
 error_no_put:
 	*errp = err;

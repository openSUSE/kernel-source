diff -purN linux-2.6.1/arch/sparc/kernel/irq.c linux-2.5/arch/sparc/kernel/irq.c
--- linux-2.6.1/arch/sparc/kernel/irq.c	2004-01-09 06:59:06.000000000 +0000
+++ linux-2.5/arch/sparc/kernel/irq.c	2004-01-09 09:40:53.000000000 +0000
@@ -49,6 +49,9 @@
 #include <asm/pcic.h>
 #include <asm/cacheflush.h>
 
+/* Used to protect the IRQ action lists */
+spinlock_t irq_action_lock = SPIN_LOCK_UNLOCKED;
+
 /*
  * Dave Redman (djhr@tadpole.co.uk)
  *
@@ -492,7 +495,7 @@ int request_fast_irq(unsigned int irq,
 		return -EBUSY;
 	}
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&irq_action_lock, flags);
 
 	/* If this is flagged as statically allocated then we use our
 	 * private struct which is never freed.
@@ -507,10 +510,10 @@ int request_fast_irq(unsigned int irq,
 	
 	if (action == NULL)
 	    action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
-						 GFP_KERNEL);
+						 GFP_ATOMIC);
 	
 	if (!action) { 
-		restore_flags(flags);
+		spin_unlock_irqrestore(&irq_action_lock, flags);
 		return -ENOMEM;
 	}
 
@@ -547,7 +550,7 @@ int request_fast_irq(unsigned int irq,
 	*(cpu_irq + irq_action) = action;
 
 	enable_irq(irq);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&irq_action_lock, flags);
 	return 0;
 }
 
@@ -586,7 +589,7 @@ int request_irq(unsigned int irq,
 		action = NULL;		/* Or else! */
 	}
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&irq_action_lock, flags);
 
 	/* If this is flagged as statically allocated then we use our
 	 * private struct which is never freed.
@@ -600,10 +603,10 @@ int request_irq(unsigned int irq,
 	
 	if (action == NULL)
 	    action = (struct irqaction *)kmalloc(sizeof(struct irqaction),
-						 GFP_KERNEL);
+						 GFP_ATOMIC);
 	
 	if (!action) { 
-		restore_flags(flags);
+		spin_unlock_irqrestore(&irq_action_lock, flags);
 		return -ENOMEM;
 	}
 
@@ -620,7 +623,7 @@ int request_irq(unsigned int irq,
 		*(cpu_irq + irq_action) = action;
 
 	enable_irq(irq);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&irq_action_lock, flags);
 	return 0;
 }
 
diff -purN linux-2.6.1/arch/sparc/mm/fault.c linux-2.5/arch/sparc/mm/fault.c
--- linux-2.6.1/arch/sparc/mm/fault.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/sparc/mm/fault.c	2004-01-09 09:39:38.000000000 +0000
@@ -36,7 +36,6 @@
 
 #define ELEMENTS(arr) (sizeof (arr)/sizeof (arr[0]))
 
-extern struct sparc_phys_banks sp_banks[SPARC_PHYS_BANKS+1];
 extern int prom_node_root;
 
 /* At boot time we determine these two values necessary for setting
diff -purN linux-2.6.1/arch/sparc/mm/srmmu.c linux-2.5/arch/sparc/mm/srmmu.c
--- linux-2.6.1/arch/sparc/mm/srmmu.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/arch/sparc/mm/srmmu.c	2004-01-09 09:39:38.000000000 +0000
@@ -349,7 +349,7 @@ void srmmu_free_nocache(unsigned long va
 		    vaddr, (unsigned long)SRMMU_NOCACHE_VADDR);
 		BUG();
 	}
-	if (vaddr+size >= srmmu_nocache_end) {
+	if (vaddr+size > srmmu_nocache_end) {
 		printk("Vaddr %lx is bigger than nocache end 0x%lx\n",
 		    vaddr, srmmu_nocache_end);
 		BUG();
@@ -1071,7 +1071,7 @@ void __init srmmu_early_allocate_ptable_
 		}
 		if (start > (0xffffffffUL - SRMMU_PMD_SIZE_SOFT))
 			break;
-		start = (start + SRMMU_PMD_SIZE) & SRMMU_PMD_MASK;
+		start = (start + SRMMU_PMD_SIZE_SOFT) & SRMMU_PMD_MASK_SOFT;
 	}
 }
 
@@ -1101,7 +1101,7 @@ void __init srmmu_allocate_ptable_skelet
 		}
 		if (start > (0xffffffffUL - SRMMU_PMD_SIZE_SOFT))
 			break;
-		start = (start + SRMMU_PMD_SIZE) & SRMMU_PMD_MASK;
+		start = (start + SRMMU_PMD_SIZE_SOFT) & SRMMU_PMD_MASK_SOFT;
 	}
 }
 
diff -purN linux-2.6.1/arch/sparc64/Kconfig linux-2.5/arch/sparc64/Kconfig
--- linux-2.6.1/arch/sparc64/Kconfig	2004-01-09 06:59:57.000000000 +0000
+++ linux-2.5/arch/sparc64/Kconfig	2004-01-09 10:13:59.000000000 +0000
@@ -489,6 +489,22 @@ config WATCHDOG_RIO
 	  machines.  The watchdog timeout period is normally one minute but
 	  can be changed with a boot-time parameter.
 
+config CMDLINE_BOOL
+	bool "Default bootloader kernel arguments"
+
+config CMDLINE
+	string "Initial kernel command string"
+	depends on CMDLINE_BOOL
+	default "console=ttyS0,9600 root=/dev/sda1"
+	help
+	  Say Y here if you want to be able to pass default arguments to
+	  the kernel. This will be overridden by the bootloader, if you
+	  use one (such as SILO). This is most useful if you want to boot
+	  a kernel from TFTP, and want default options to be available
+	  with having them passed on the command line.
+
+	  NOTE: This option WILL override the PROM bootargs setting!
+
 endmenu
 
 source "drivers/base/Kconfig"
diff -purN linux-2.6.1/arch/sparc64/defconfig linux-2.5/arch/sparc64/defconfig
--- linux-2.6.1/arch/sparc64/defconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/arch/sparc64/defconfig	2004-01-09 10:14:39.000000000 +0000
@@ -102,6 +102,7 @@ CONFIG_ENVCTRL=m
 CONFIG_DISPLAY7SEG=m
 CONFIG_WATCHDOG_CP1XXX=m
 CONFIG_WATCHDOG_RIO=m
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Generic Driver Options
@@ -1286,6 +1287,7 @@ CONFIG_DVB_CORE=m
 CONFIG_DVB_TWINHAN_DST=m
 CONFIG_DVB_STV0299=m
 CONFIG_DVB_SP887X=m
+CONFIG_DVB_SP887X_FIRMWARE_FILE="/etc/dvb/sc_main.mc"
 CONFIG_DVB_ALPS_TDLB7=m
 CONFIG_DVB_ALPS_TDMB7=m
 CONFIG_DVB_ATMEL_AT76C651=m
@@ -1295,12 +1297,12 @@ CONFIG_DVB_GRUNDIG_29504_401=m
 CONFIG_DVB_MT312=m
 CONFIG_DVB_VES1820=m
 CONFIG_DVB_VES1X93=m
-CONFIG_DVB_SP887X_FIRMWARE_FILE="/etc/dvb/sc_main.mc"
 
 #
 # Supported SAA7146 based PCI Adapters
 #
-# CONFIG_DVB_AV7110 is not set
+CONFIG_DVB_AV7110=m
+# CONFIG_DVB_AV7110_OSD is not set
 CONFIG_DVB_BUDGET=m
 CONFIG_DVB_BUDGET_CI=m
 CONFIG_DVB_BUDGET_AV=m
diff -purN linux-2.6.1/arch/sparc64/kernel/head.S linux-2.5/arch/sparc64/kernel/head.S
--- linux-2.6.1/arch/sparc64/kernel/head.S	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/arch/sparc64/kernel/head.S	2004-01-09 09:31:50.000000000 +0000
@@ -151,6 +151,9 @@ cheetah_generic_boot:
 	blu,pt	%xcc, 1b
 	 add	%l0, (1 << 3), %l0
 
+	/* BUG() if we get here... */
+	ta	0x5
+
 cheetah_got_tlbentry:
 	ldxa	[%l0] ASI_ITLB_DATA_ACCESS, %g0
 	ldxa	[%l0] ASI_ITLB_DATA_ACCESS, %g1
@@ -333,6 +336,9 @@ spitfire_create_mappings:
 	blu,pt	%xcc, 1b
 	 add	%l0, (1 << 3), %l0
 
+	/* BUG() if we get here... */
+	ta	0x5
+
 spitfire_got_tlbentry:
 	/* Nops here again, perhaps Cheetah/Blackbird are better behaved... */
 	nop
diff -purN linux-2.6.1/arch/sparc64/prom/bootstr.c linux-2.5/arch/sparc64/prom/bootstr.c
--- linux-2.6.1/arch/sparc64/prom/bootstr.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/arch/sparc64/prom/bootstr.c	2004-01-09 10:13:59.000000000 +0000
@@ -21,6 +21,10 @@ struct {
 	char bootstr_buf[BARG_LEN];
 } bootstr_info = {
 	.bootstr_len = BARG_LEN,
+#ifdef CONFIG_CMDLINE
+	.bootstr_valid = 1,
+	.bootstr_buf = CONFIG_CMDLINE,
+#endif
 };
 
 char * __init
diff -purN linux-2.6.1/drivers/ieee1394/Kconfig linux-2.5/drivers/ieee1394/Kconfig
--- linux-2.6.1/drivers/ieee1394/Kconfig	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/ieee1394/Kconfig	2004-01-14 23:05:36.000000000 +0000
@@ -40,7 +40,7 @@ config IEEE1394_OUI_DB
 	help
 	  If you say Y here, then an OUI list (vendor unique ID's) will be
 	  compiled into the ieee1394 module. This doesn't really do much
-	  accept being able to display the vendor of a hardware node. The
+	  except being able to display the vendor of a hardware node. The
 	  downside is that it adds about 300k to the size of the module,
 	  or kernel (depending on whether you compile ieee1394 as a
 	  module, or static in the kernel).
diff -purN linux-2.6.1/drivers/ieee1394/amdtp.c linux-2.5/drivers/ieee1394/amdtp.c
--- linux-2.6.1/drivers/ieee1394/amdtp.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/ieee1394/amdtp.c	2004-01-14 23:10:07.000000000 +0000
@@ -82,6 +82,7 @@
 #include <linux/poll.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 
@@ -1196,6 +1197,7 @@ static int amdtp_release(struct inode *i
 	return 0;
 }
 
+static struct cdev amdtp_cdev;
 static struct file_operations amdtp_fops =
 {
 	.owner =	THIS_MODULE,
@@ -1262,12 +1264,11 @@ MODULE_LICENSE("GPL");
 
 static int __init amdtp_init_module (void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_AMDTP,
-					THIS_MODULE, &amdtp_fops);
-	if (ret) {
-		HPSB_ERR("amdtp: unable to get minor device block");
+	cdev_init(&amdtp_cdev, &amdtp_fops);
+	amdtp_cdev.owner = THIS_MODULE;
+	kobject_set_name(&amdtp_cdev.kobj, "amdtp");
+	if (cdev_add(&amdtp_cdev, IEEE1394_AMDTP_DEV, 16)) {
+		HPSB_ERR("amdtp: unable to add char device");
  		return -EIO;
  	}
 
@@ -1276,12 +1277,15 @@ static int __init amdtp_init_module (voi
 	hpsb_register_highlevel(&amdtp_highlevel);
 
 #ifdef CONFIG_COMPAT
-	ret = register_ioctl32_conversion(AMDTP_IOC_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_PLUG, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_PING, NULL);
-	ret |= register_ioctl32_conversion(AMDTP_IOC_ZAP, NULL);
-	if (ret)
-		HPSB_ERR("amdtp: Error registering ioctl32 translations");
+	{
+		int ret;
+		ret = register_ioctl32_conversion(AMDTP_IOC_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_PLUG, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_PING, NULL);
+		ret |= register_ioctl32_conversion(AMDTP_IOC_ZAP, NULL);
+		if (ret)
+			HPSB_ERR("amdtp: Error registering ioctl32 translations");
+	}
 #endif
 
 	HPSB_INFO("Loaded AMDTP driver");
@@ -1304,10 +1308,12 @@ static void __exit amdtp_exit_module (vo
 
         hpsb_unregister_highlevel(&amdtp_highlevel);
 	devfs_remove("amdtp");
-        ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_AMDTP);
+	cdev_unmap(IEEE1394_AMDTP_DEV, 16);
+	cdev_del(&amdtp_cdev);
 
 	HPSB_INFO("Unloaded AMDTP driver");
 }
 
 module_init(amdtp_init_module);
 module_exit(amdtp_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_AMDTP * 16);
diff -purN linux-2.6.1/drivers/ieee1394/cmp.c linux-2.5/drivers/ieee1394/cmp.c
--- linux-2.6.1/drivers/ieee1394/cmp.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/ieee1394/cmp.c	2004-01-14 23:11:56.000000000 +0000
@@ -77,6 +77,25 @@ enum {
 
 static struct hpsb_highlevel cmp_highlevel;
 
+static void cmp_add_host(struct hpsb_host *host);
+static void cmp_host_reset(struct hpsb_host *host);
+static int pcr_read(struct hpsb_host *host, int nodeid, quadlet_t *buf,
+		    u64 addr, size_t length, u16 flags);
+static int pcr_lock(struct hpsb_host *host, int nodeid, quadlet_t *store,
+		    u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 flags);
+
+static struct hpsb_highlevel cmp_highlevel = {
+	.name =		"cmp",
+	.add_host =	cmp_add_host,
+	.host_reset =	cmp_host_reset,
+};
+
+static struct hpsb_address_ops pcr_ops = {
+	.read =	pcr_read,
+	.lock =	pcr_lock,
+};
+
+
 struct cmp_pcr *
 cmp_register_opcr(struct hpsb_host *host, int opcr_number, int payload,
 		  void (*update)(struct cmp_pcr *pcr, void *data),
@@ -137,6 +156,10 @@ static void cmp_add_host(struct hpsb_hos
 		return;
 	}
 
+	hpsb_register_addrspace(&cmp_highlevel, host, &pcr_ops,
+				CSR_REGISTER_BASE + CSR_PCR_MAP,
+				CSR_REGISTER_BASE + CSR_PCR_MAP_END);
+
 	ch->host = host;
 	ch->u.ompr.rate = IEEE1394_SPEED_100;
 	ch->u.ompr.bcast_channel_base = 63;
@@ -258,17 +281,6 @@ static int pcr_lock(struct hpsb_host *ho
 }
 
 
-static struct hpsb_highlevel cmp_highlevel = {
-	.name =		"cmp",
-	.add_host =	cmp_add_host,
-        .host_reset =	cmp_host_reset,
-};
-
-static struct hpsb_address_ops pcr_ops = {
-	.read =	pcr_read,
-        .lock =	pcr_lock,
-};
-
 /* Module interface */
 
 MODULE_AUTHOR("Kristian Hogsberg <hogsberg@users.sf.net>");
@@ -283,10 +295,6 @@ static int __init cmp_init_module (void)
 {
 	hpsb_register_highlevel (&cmp_highlevel);
 
-	hpsb_register_addrspace(&cmp_highlevel, &pcr_ops,
-				CSR_REGISTER_BASE + CSR_PCR_MAP,
-				CSR_REGISTER_BASE + CSR_PCR_MAP_END);
-
 	HPSB_INFO("Loaded CMP driver");
 
 	return 0;
diff -purN linux-2.6.1/drivers/ieee1394/csr.c linux-2.5/drivers/ieee1394/csr.c
--- linux-2.6.1/drivers/ieee1394/csr.c	2004-01-09 06:59:18.000000000 +0000
+++ linux-2.5/drivers/ieee1394/csr.c	2004-01-14 23:11:58.000000000 +0000
@@ -35,6 +35,43 @@ static int fcp = 1;
 module_param(fcp, int, 0444);
 MODULE_PARM_DESC(fcp, "Map FCP registers (default = 1, disable = 0).");
 
+static void add_host(struct hpsb_host *host);
+static void host_reset(struct hpsb_host *host);
+static int read_maps(struct hpsb_host *host, int nodeid, quadlet_t *buffer,
+		     u64 addr, size_t length, u16 fl);
+static int write_fcp(struct hpsb_host *host, int nodeid, int dest,
+		     quadlet_t *data, u64 addr, size_t length, u16 flags);
+static int read_regs(struct hpsb_host *host, int nodeid, quadlet_t *buf,
+		     u64 addr, size_t length, u16 flags);
+static int write_regs(struct hpsb_host *host, int nodeid, int destid,
+		      quadlet_t *data, u64 addr, size_t length, u16 flags);
+static int lock_regs(struct hpsb_host *host, int nodeid, quadlet_t *store,
+		     u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 fl);
+static int lock64_regs(struct hpsb_host *host, int nodeid, octlet_t * store,
+		       u64 addr, octlet_t data, octlet_t arg, int extcode, u16 fl);
+
+static struct hpsb_highlevel csr_highlevel = {
+	.name =		"standard registers",
+	.add_host =	add_host,
+	.host_reset =	host_reset,
+};
+
+static struct hpsb_address_ops map_ops = {
+	.read = read_maps,
+};
+
+static struct hpsb_address_ops fcp_ops = {
+	.write = write_fcp,
+};
+
+static struct hpsb_address_ops reg_ops = {
+	.read = read_regs,
+	.write = write_regs,
+	.lock = lock_regs,
+	.lock64 = lock64_regs,
+};
+
+
 static u16 csr_crc16(unsigned *data, int length)
 {
         int check=0, i;
@@ -125,6 +162,24 @@ static inline void calculate_expire(stru
 
 static void add_host(struct hpsb_host *host)
 {
+	hpsb_register_addrspace(&csr_highlevel, host, &reg_ops,
+				CSR_REGISTER_BASE,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM);
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM,
+				CSR_REGISTER_BASE + CSR_CONFIG_ROM_END);
+	if (fcp) {
+		hpsb_register_addrspace(&csr_highlevel, host, &fcp_ops,
+					CSR_REGISTER_BASE + CSR_FCP_COMMAND,
+					CSR_REGISTER_BASE + CSR_FCP_END);
+	}
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP,
+				CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP_END);
+	hpsb_register_addrspace(&csr_highlevel, host, &map_ops,
+				CSR_REGISTER_BASE + CSR_SPEED_MAP,
+				CSR_REGISTER_BASE + CSR_SPEED_MAP_END);
+
         host->csr.lock = SPIN_LOCK_UNLOCKED;
 
         host->csr.rom_size = host->driver->get_rom(host, &host->csr.rom);
@@ -684,48 +739,10 @@ static int write_fcp(struct hpsb_host *h
 }
 
 
-static struct hpsb_highlevel csr_highlevel = {
-	.name =		"standard registers",
-	.add_host =	add_host,
-        .host_reset =	host_reset,
-};
-
-
-static struct hpsb_address_ops map_ops = {
-        .read = read_maps,
-};
-
-static struct hpsb_address_ops fcp_ops = {
-        .write = write_fcp,
-};
-
-static struct hpsb_address_ops reg_ops = {
-        .read = read_regs,
-        .write = write_regs,
-        .lock = lock_regs,
-	.lock64 = lock64_regs,
-};
 
 void init_csr(void)
 {
 	hpsb_register_highlevel(&csr_highlevel);
-
-        hpsb_register_addrspace(&csr_highlevel, &reg_ops, CSR_REGISTER_BASE,
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM);
-        hpsb_register_addrspace(&csr_highlevel, &map_ops, 
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM,
-                                CSR_REGISTER_BASE + CSR_CONFIG_ROM_END);
-        if (fcp) {
-		hpsb_register_addrspace(&csr_highlevel, &fcp_ops,
-                                CSR_REGISTER_BASE + CSR_FCP_COMMAND,
-                                CSR_REGISTER_BASE + CSR_FCP_END);
-	}
-        hpsb_register_addrspace(&csr_highlevel, &map_ops,
-                                CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP,
-                                CSR_REGISTER_BASE + CSR_TOPOLOGY_MAP_END);
-        hpsb_register_addrspace(&csr_highlevel, &map_ops,
-                                CSR_REGISTER_BASE + CSR_SPEED_MAP,
-                                CSR_REGISTER_BASE + CSR_SPEED_MAP_END);
 }
 
 void cleanup_csr(void)
diff -purN linux-2.6.1/drivers/ieee1394/dv1394.c linux-2.5/drivers/ieee1394/dv1394.c
--- linux-2.6.1/drivers/ieee1394/dv1394.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/drivers/ieee1394/dv1394.c	2004-01-14 23:10:12.000000000 +0000
@@ -110,6 +110,7 @@
 #include <linux/string.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 
 #include "ieee1394.h"
 #include "ieee1394_types.h"
@@ -2165,6 +2166,7 @@ out:
 	spin_unlock(&video->spinlock);
 }
 
+static struct cdev dv1394_cdev;
 static struct file_operations dv1394_fops=
 {
 	.owner =	THIS_MODULE,
@@ -2607,17 +2609,17 @@ static void __exit dv1394_exit_module(vo
 	hpsb_unregister_protocol(&dv1394_driver);
 
 	hpsb_unregister_highlevel(&dv1394_highlevel);
-	ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_DV1394);
+	cdev_unmap(IEEE1394_DV1394_DEV, 16);
+	cdev_del(&dv1394_cdev);
 	devfs_remove("ieee1394/dv");
 }
 
 static int __init dv1394_init_module(void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_DV1394,
-					THIS_MODULE, &dv1394_fops);
-	if (ret) {
+	cdev_init(&dv1394_cdev, &dv1394_fops);
+	dv1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&dv1394_cdev.kobj, "dv1394");
+	if (cdev_add(&dv1394_cdev, IEEE1394_DV1394_DEV, 16)) {
 		printk(KERN_ERR "dv1394: unable to register character device\n");
 		return -EIO;
 	}
@@ -2629,18 +2631,22 @@ static int __init dv1394_init_module(voi
 	hpsb_register_protocol(&dv1394_driver);
 
 #ifdef CONFIG_COMPAT
-	/* First compatible ones */
-	ret = register_ioctl32_conversion(DV1394_IOC_SHUTDOWN, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_SUBMIT_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_WAIT_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_RECEIVE_FRAMES, NULL);
-	ret |= register_ioctl32_conversion(DV1394_IOC_START_RECEIVE, NULL);
-
-	/* These need to be handled by translation */
-	ret |= register_ioctl32_conversion(DV1394_IOC32_INIT, handle_dv1394_init);
-	ret |= register_ioctl32_conversion(DV1394_IOC32_GET_STATUS, handle_dv1394_get_status);
-	if (ret)
-		printk(KERN_ERR "dv1394: Error registering ioctl32 translations\n");
+	{
+		int ret;
+
+		/* First compatible ones */
+		ret = register_ioctl32_conversion(DV1394_IOC_SHUTDOWN, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_SUBMIT_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_WAIT_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_RECEIVE_FRAMES, NULL);
+		ret |= register_ioctl32_conversion(DV1394_IOC_START_RECEIVE, NULL);
+
+		/* These need to be handled by translation */
+		ret |= register_ioctl32_conversion(DV1394_IOC32_INIT, handle_dv1394_init);
+		ret |= register_ioctl32_conversion(DV1394_IOC32_GET_STATUS, handle_dv1394_get_status);
+		if (ret)
+			printk(KERN_ERR "dv1394: Error registering ioctl32 translations\n");
+	}
 #endif
 
 	return 0;
@@ -2648,3 +2654,4 @@ static int __init dv1394_init_module(voi
 
 module_init(dv1394_init_module);
 module_exit(dv1394_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_DV1394 * 16);
diff -purN linux-2.6.1/drivers/ieee1394/eth1394.c linux-2.5/drivers/ieee1394/eth1394.c
--- linux-2.6.1/drivers/ieee1394/eth1394.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/ieee1394/eth1394.c	2004-01-14 23:20:23.000000000 +0000
@@ -89,7 +89,7 @@
 #define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 1079 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1096 $ Ben Collins <bcollins@debian.org>";
 
 struct fragment_info {
 	struct list_head list;
@@ -168,6 +168,26 @@ static void ether1394_iso(struct hpsb_is
 static int ether1394_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 static int ether1394_ethtool_ioctl(struct net_device *dev, void *useraddr);
 
+static int ether1394_write(struct hpsb_host *host, int srcid, int destid,
+			   quadlet_t *data, u64 addr, size_t len, u16 flags);
+static void ether1394_add_host (struct hpsb_host *host);
+static void ether1394_remove_host (struct hpsb_host *host);
+static void ether1394_host_reset (struct hpsb_host *host);
+
+/* Function for incoming 1394 packets */
+static struct hpsb_address_ops addr_ops = {
+	.write =	ether1394_write,
+};
+
+/* Ieee1394 highlevel driver functions */
+static struct hpsb_highlevel eth1394_highlevel = {
+	.name =		driver_name,
+	.add_host =	ether1394_add_host,
+	.remove_host =	ether1394_remove_host,
+	.host_reset =	ether1394_host_reset,
+};
+
+
 static void eth1394_iso_shutdown(struct eth1394_priv *priv)
 {
 	priv->bc_state = ETHER1394_BC_CLOSED;
@@ -420,6 +440,10 @@ static void ether1394_add_host (struct h
 	struct eth1394_priv *priv;
 	static int version_printed = 0;
 
+	hpsb_register_addrspace(&eth1394_highlevel, host, &addr_ops,
+				ETHER1394_REGION_ADDR,
+				ETHER1394_REGION_ADDR_END);
+
 	if (version_printed++ == 0)
 		ETH1394_PRINT_G (KERN_INFO, "%s\n", version);
 
@@ -1599,7 +1623,7 @@ static int ether1394_ethtool_ioctl(struc
 		case ETHTOOL_GDRVINFO: {
 			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
 			strcpy (info.driver, driver_name);
-			strcpy (info.version, "$Rev: 1079 $");
+			strcpy (info.version, "$Rev: 1096 $");
 			/* FIXME XXX provide sane businfo */
 			strcpy (info.bus_info, "ieee1394");
 			if (copy_to_user (useraddr, &info, sizeof (info)))
@@ -1619,18 +1643,6 @@ static int ether1394_ethtool_ioctl(struc
 	return 0;
 }
 
-/* Function for incoming 1394 packets */
-static struct hpsb_address_ops addr_ops = {
-	.write =	ether1394_write,
-};
-
-/* Ieee1394 highlevel driver functions */
-static struct hpsb_highlevel eth1394_highlevel = {
-	.name =		driver_name,
-	.add_host =	ether1394_add_host,
-	.remove_host =	ether1394_remove_host,
-	.host_reset =	ether1394_host_reset,
-};
 
 static int __init ether1394_init_module (void)
 {
@@ -1640,9 +1652,6 @@ static int __init ether1394_init_module 
 	/* Register ourselves as a highlevel driver */
 	hpsb_register_highlevel(&eth1394_highlevel);
 
-	hpsb_register_addrspace(&eth1394_highlevel, &addr_ops, ETHER1394_REGION_ADDR,
-				 ETHER1394_REGION_ADDR_END);
-
 	return 0;
 }
 
diff -purN linux-2.6.1/drivers/ieee1394/highlevel.c linux-2.5/drivers/ieee1394/highlevel.c
--- linux-2.6.1/drivers/ieee1394/highlevel.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/ieee1394/highlevel.c	2004-01-14 23:15:08.000000000 +0000
@@ -39,7 +39,10 @@ struct hl_host_info {
 
 
 static LIST_HEAD(hl_drivers);
-static rwlock_t hl_drivers_lock = RW_LOCK_UNLOCKED;
+static DECLARE_RWSEM(hl_drivers_sem);
+
+static LIST_HEAD(hl_irqs);
+static rwlock_t hl_irqs_lock = RW_LOCK_UNLOCKED;
 
 static LIST_HEAD(addr_space);
 static rwlock_t addr_space_lock = RW_LOCK_UNLOCKED;
@@ -239,20 +242,22 @@ static int highlevel_for_each_host_reg(s
 
 void hpsb_register_highlevel(struct hpsb_highlevel *hl)
 {
-	unsigned long flags;
-
         INIT_LIST_HEAD(&hl->addr_list);
 	INIT_LIST_HEAD(&hl->host_info_list);
 
 	rwlock_init(&hl->host_info_lock);
 
-	write_lock_irqsave(&hl_drivers_lock, flags);
+	down_write(&hl_drivers_sem);
         list_add_tail(&hl->hl_list, &hl_drivers);
-	write_unlock_irqrestore(&hl_drivers_lock, flags);
+	up_write(&hl_drivers_sem);
 
 	if (hl->add_host)
 		nodemgr_for_each_host(hl, highlevel_for_each_host_reg);
 
+	write_lock(&hl_irqs_lock);
+	list_add_tail(&hl->irq_list, &hl_irqs);
+	write_unlock(&hl_irqs_lock);
+
         return;
 }
 
@@ -280,15 +285,19 @@ void hpsb_unregister_highlevel(struct hp
         }
 	write_unlock_irqrestore(&addr_space_lock, flags);
 
-	write_lock_irqsave(&hl_drivers_lock, flags);
+	write_lock(&hl_irqs_lock);
+	list_del(&hl->irq_list);
+	write_unlock(&hl_irqs_lock);
+
+	down_write(&hl_drivers_sem);
         list_del(&hl->hl_list);
-	write_unlock_irqrestore(&hl_drivers_lock, flags);
+	up_write(&hl_drivers_sem);
 
         if (hl->remove_host)
 		nodemgr_for_each_host(hl, highlevel_for_each_host_unreg);
 }
 
-int hpsb_register_addrspace(struct hpsb_highlevel *hl,
+int hpsb_register_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
                             struct hpsb_address_ops *ops, u64 start, u64 end)
 {
         struct hpsb_address_serve *as;
@@ -314,7 +323,7 @@ int hpsb_register_addrspace(struct hpsb_
         as->end = end;
 
         write_lock_irqsave(&addr_space_lock, flags);
-        entry = addr_space.next;
+        entry = host->addr_space.next;
 
         while (list_entry(entry, struct hpsb_address_serve, as_list)->end
                <= start) {
@@ -336,7 +345,8 @@ int hpsb_register_addrspace(struct hpsb_
         return retval;
 }
 
-int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, u64 start)
+int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
+                              u64 start)
 {
         int retval = 0;
         struct hpsb_address_serve *as;
@@ -350,7 +360,7 @@ int hpsb_unregister_addrspace(struct hps
         while (entry != &hl->addr_list) {
                 as = list_entry(entry, struct hpsb_address_serve, addr_list);
                 entry = entry->next;
-                if (as->start == start) {
+                if (as->start == start && as->host == host) {
                         list_del(&as->as_list);
                         list_del(&as->addr_list);
                         kfree(as);
@@ -395,89 +405,82 @@ void hpsb_unlisten_channel(struct hpsb_h
 
 void highlevel_add_host(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
 
-        read_lock(&hl_drivers_lock);
-        list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
+	down_read(&hl_drivers_sem);
+        list_for_each_entry(hl, &hl_drivers, hl_list) {
 		if (hl->add_host)
 			hl->add_host(host);
         }
-        read_unlock(&hl_drivers_lock);
+	up_read(&hl_drivers_sem);
 }
 
 void highlevel_remove_host(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
+	struct list_head *lh, *next;
+	struct hpsb_address_serve *as;
+	unsigned long flags;
 
-	read_lock(&hl_drivers_lock);
-	list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-
+	down_read(&hl_drivers_sem);
+	list_for_each_entry(hl, &hl_drivers, hl_list) {
 		if (hl->remove_host) {
 			hl->remove_host(host);
 			hpsb_destroy_hostinfo(hl, host);
 		}
         }
-	read_unlock(&hl_drivers_lock);
+	up_read(&hl_drivers_sem);
+
+	/* Free up 1394 address space left behind by high level drivers. */
+	write_lock_irqsave(&addr_space_lock, flags);
+	list_for_each_safe (lh, next, &host->addr_space) {
+		as = list_entry(lh, struct hpsb_address_serve, as_list);
+		if (!list_empty(&as->addr_list)) {
+			list_del(&as->addr_list);
+			kfree(as);
+		}
+	}
+	write_unlock_irqrestore(&addr_space_lock, flags);
 }
 
 void highlevel_host_reset(struct hpsb_host *host)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
 
-	read_lock(&hl_drivers_lock);
-	list_for_each(entry, &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-
+	read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, hl_list) {
                 if (hl->host_reset)
                         hl->host_reset(host);
         }
-	read_unlock(&hl_drivers_lock);
+	read_unlock(&hl_irqs_lock);
 }
 
-void highlevel_iso_receive(struct hpsb_host *host, void *data,
-			   size_t length)
+void highlevel_iso_receive(struct hpsb_host *host, void *data, size_t length)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
         int channel = (((quadlet_t *)data)[0] >> 8) & 0x3f;
 
-        read_lock(&hl_drivers_lock);
-        entry = hl_drivers.next;
-
-        while (entry != &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-                if (hl->iso_receive) {
+        read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, irq_list) {
+                if (hl->iso_receive)
                         hl->iso_receive(host, channel, data, length);
-                }
-                entry = entry->next;
         }
-        read_unlock(&hl_drivers_lock);
+        read_unlock(&hl_irqs_lock);
 }
 
 void highlevel_fcp_request(struct hpsb_host *host, int nodeid, int direction,
 			   void *data, size_t length)
 {
-        struct list_head *entry;
         struct hpsb_highlevel *hl;
         int cts = ((quadlet_t *)data)[0] >> 4;
 
-        read_lock(&hl_drivers_lock);
-        entry = hl_drivers.next;
-
-        while (entry != &hl_drivers) {
-                hl = list_entry(entry, struct hpsb_highlevel, hl_list);
-                if (hl->fcp_request) {
+        read_lock(&hl_irqs_lock);
+	list_for_each_entry(hl, &hl_irqs, irq_list) {
+                if (hl->fcp_request)
                         hl->fcp_request(host, nodeid, direction, cts, data,
-                                            length);
-                }
-                entry = entry->next;
+					length);
         }
-        read_unlock(&hl_drivers_lock);
+        read_unlock(&hl_irqs_lock);
 }
 
 int highlevel_read(struct hpsb_host *host, int nodeid, void *data,
@@ -490,7 +493,7 @@ int highlevel_read(struct hpsb_host *hos
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -536,7 +539,7 @@ int highlevel_write(struct hpsb_host *ho
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -582,7 +585,7 @@ int highlevel_lock(struct hpsb_host *hos
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -615,7 +618,7 @@ int highlevel_lock64(struct hpsb_host *h
 
         read_lock(&addr_space_lock);
 
-        entry = addr_space.next;
+        entry = host->addr_space.next;
         as = list_entry(entry, struct hpsb_address_serve, as_list);
 
         while (as->start <= addr) {
@@ -640,7 +643,7 @@ int highlevel_lock64(struct hpsb_host *h
         return rcode;
 }
 
-void init_hpsb_highlevel(void)
+void init_hpsb_highlevel(struct hpsb_host *host)
 {
         INIT_LIST_HEAD(&dummy_zero_addr.as_list);
         INIT_LIST_HEAD(&dummy_zero_addr.addr_list);
@@ -652,6 +655,6 @@ void init_hpsb_highlevel(void)
         dummy_zero_addr.start = dummy_zero_addr.end = 0;
         dummy_max_addr.start = dummy_max_addr.end = ((u64) 1) << 48;
 
-        list_add_tail(&dummy_zero_addr.as_list, &addr_space);
-        list_add_tail(&dummy_max_addr.as_list, &addr_space);
+        list_add_tail(&dummy_zero_addr.as_list, &host->addr_space);
+        list_add_tail(&dummy_max_addr.as_list, &host->addr_space);
 }
diff -purN linux-2.6.1/drivers/ieee1394/highlevel.h linux-2.5/drivers/ieee1394/highlevel.h
--- linux-2.6.1/drivers/ieee1394/highlevel.h	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/ieee1394/highlevel.h	2004-01-14 23:15:11.000000000 +0000
@@ -10,6 +10,8 @@ struct hpsb_address_serve {
 
         struct hpsb_address_ops *op;
 
+	struct hpsb_host *host;
+
         /* first address handled and first address behind, quadlet aligned */
         u64 start, end;
 };
@@ -36,9 +38,9 @@ struct hpsb_highlevel {
          * hpsb_unregister_highlevel once for each host. */
         void (*remove_host) (struct hpsb_host *host);
 
-        /* Host experienced bus reset with possible configuration changes.  Note
-         * that this one may occur during interrupt/bottom half handling.  You
-         * can not expect to be able to do stock hpsb_reads. */
+        /* Host experienced bus reset with possible configuration changes.
+	 * Note that this one may occur during interrupt/bottom half handling.
+	 * You can not expect to be able to do stock hpsb_reads. */
         void (*host_reset) (struct hpsb_host *host);
 
         /* An isochronous packet was received.  Channel contains the channel
@@ -50,13 +52,14 @@ struct hpsb_highlevel {
 
         /* A write request was received on either the FCP_COMMAND (direction =
          * 0) or the FCP_RESPONSE (direction = 1) register.  The cts arg
-         * contains the cts field (first byte of data).
-         */
+         * contains the cts field (first byte of data). */
         void (*fcp_request) (struct hpsb_host *host, int nodeid, int direction,
                              int cts, u8 *data, size_t length);
 
-
+	/* These are initialized by the subsystem when the
+	 * hpsb_higlevel is registered. */
 	struct list_head hl_list;
+	struct list_head irq_list;
 	struct list_head addr_list;
 
 	struct list_head host_info_list;
@@ -137,10 +140,11 @@ void hpsb_unregister_highlevel(struct hp
  * It returns true for successful allocation.  There is no unregister function,
  * all address spaces are deallocated together with the hpsb_highlevel.
  */
-int hpsb_register_addrspace(struct hpsb_highlevel *hl,
+int hpsb_register_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
                             struct hpsb_address_ops *ops, u64 start, u64 end);
 
-int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, u64 start);
+int hpsb_unregister_addrspace(struct hpsb_highlevel *hl, struct hpsb_host *host,
+                              u64 start);
 
 /*
  * Enable or disable receving a certain isochronous channel through the
@@ -179,6 +183,6 @@ int hpsb_set_hostinfo(struct hpsb_highle
 struct hpsb_host *hpsb_get_host_bykey(struct hpsb_highlevel *hl, unsigned long key);
 
 /* Initialize the highlevel system */
-void init_hpsb_highlevel(void);
+void init_hpsb_highlevel(struct hpsb_host *host);
 
 #endif /* IEEE1394_HIGHLEVEL_H */
diff -purN linux-2.6.1/drivers/ieee1394/hosts.c linux-2.5/drivers/ieee1394/hosts.c
--- linux-2.6.1/drivers/ieee1394/hosts.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/drivers/ieee1394/hosts.c	2004-01-14 23:12:02.000000000 +0000
@@ -89,6 +89,8 @@ struct hpsb_host *hpsb_alloc_host(struct
         INIT_LIST_HEAD(&h->pending_packets);
         spin_lock_init(&h->pending_pkt_lock);
 
+	INIT_LIST_HEAD(&h->addr_space);
+
 	for (i = 0; i < ARRAY_SIZE(h->tpool); i++)
 		HPSB_TPOOL_INIT(&h->tpool[i]);
 
diff -purN linux-2.6.1/drivers/ieee1394/hosts.h linux-2.5/drivers/ieee1394/hosts.h
--- linux-2.6.1/drivers/ieee1394/hosts.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/hosts.h	2004-01-14 23:12:03.000000000 +0000
@@ -69,6 +69,8 @@ struct hpsb_host {
 	int id;
 
 	struct device device;
+
+	struct list_head addr_space;
 };
 
 
diff -purN linux-2.6.1/drivers/ieee1394/ieee1394_core.c linux-2.5/drivers/ieee1394/ieee1394_core.c
--- linux-2.6.1/drivers/ieee1394/ieee1394_core.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ieee1394_core.c	2004-01-14 23:12:04.000000000 +0000
@@ -993,186 +993,11 @@ void abort_timedouts(unsigned long __opa
 }
 
 
-/*
- * character device dispatching (see ieee1394_core.h)
- * Dan Maas <dmaas@dcine.com>
- */
-
-static struct {
-	struct file_operations *file_ops;
-	struct module *module;
-} ieee1394_chardevs[16];
-
-static rwlock_t ieee1394_chardevs_lock = RW_LOCK_UNLOCKED;
-
-static int ieee1394_dispatch_open(struct inode *inode, struct file *file);
-
-static struct file_operations ieee1394_chardev_ops = {
-	.owner =THIS_MODULE,
-	.open =	ieee1394_dispatch_open,
-};
-
-/* claim a block of minor numbers */
-int ieee1394_register_chardev(int blocknum,
-			      struct module *module,
-			      struct file_operations *file_ops)
-{
-	int retval;
-
-	if ( (blocknum < 0) || (blocknum > 15) )
-		return -EINVAL;
-
-	write_lock(&ieee1394_chardevs_lock);
-
-	if (ieee1394_chardevs[blocknum].file_ops == NULL) {
-		/* grab the minor block */
-		ieee1394_chardevs[blocknum].file_ops = file_ops;
-		ieee1394_chardevs[blocknum].module = module;
-		
-		retval = 0;
-	} else {
-		/* block already taken */
-		retval = -EBUSY;
-	}
-
-	write_unlock(&ieee1394_chardevs_lock);
-
-	return retval;
-}
-
-/* release a block of minor numbers */
-void ieee1394_unregister_chardev(int blocknum)
-{
-	if ( (blocknum < 0) || (blocknum > 15) )
-		return;
-
-	write_lock(&ieee1394_chardevs_lock);
-
-	if (ieee1394_chardevs[blocknum].file_ops) {
-		ieee1394_chardevs[blocknum].file_ops = NULL;
-		ieee1394_chardevs[blocknum].module = NULL;
-	}
-
-	write_unlock(&ieee1394_chardevs_lock);
-}
-
-/*
-  ieee1394_get_chardev() - look up and acquire a character device
-  driver that has previously registered using ieee1394_register_chardev()
-  
-  On success, returns 1 and sets module and file_ops to the driver.
-  The module will have an incremented reference count.
-   
-  On failure, returns 0.
-  The module will NOT have an incremented reference count.
-*/
-
-static int ieee1394_get_chardev(int blocknum,
-				struct module **module,
-				struct file_operations **file_ops)
-{
-	int ret = 0;
-       
-	if ((blocknum < 0) || (blocknum > 15))
-		return ret;
-
-	read_lock(&ieee1394_chardevs_lock);
-
-	*module = ieee1394_chardevs[blocknum].module;
-	*file_ops = ieee1394_chardevs[blocknum].file_ops;
-
-	if (*file_ops == NULL)
-		goto out;
-
-	if (!try_module_get(*module))
-		goto out;
-
-	/* success! */
-	ret = 1;
-
-out:
-	read_unlock(&ieee1394_chardevs_lock);
-	return ret;
-}
-
-/* the point of entry for open() on any ieee1394 character device */
-static int ieee1394_dispatch_open(struct inode *inode, struct file *file)
-{
-	struct file_operations *file_ops;
-	struct module *module;
-	int blocknum;
-	int retval;
-
-	/*
-	  Maintaining correct module reference counts is tricky here!
-
-	  The key thing to remember is that the VFS increments the
-	  reference count of ieee1394 before it calls
-	  ieee1394_dispatch_open().
-
-	  If the open() succeeds, then we need to transfer this extra
-	  reference to the task-specific driver module (e.g. raw1394).
-	  The VFS will deref the driver module automatically when the
-	  file is later released.
-
-	  If the open() fails, then the VFS will drop the
-	  reference count of whatever module file->f_op->owner points
-	  to, immediately after this function returns.
-	*/
-
-        /* shift away lower four bits of the minor
-	   to get the index of the ieee1394_driver
-	   we want */
-
-	blocknum = (iminor(inode) >> 4) & 0xF;
-
-	/* look up the driver */
-
-	if (ieee1394_get_chardev(blocknum, &module, &file_ops) == 0)
-		return -ENODEV;
-
-	/* redirect all subsequent requests to the driver's
-	   own file_operations */
-	file->f_op = file_ops;
-
-	/* at this point BOTH ieee1394 and the task-specific driver have
-	   an extra reference */
-
-	/* follow through with the open() */
-	retval = file_ops->open(inode, file);
-
-	if (retval == 0) {
-		
-		/* If the open() succeeded, then ieee1394 will be left
-		 * with an extra module reference, so we discard it here.
-		 *
-		 * The task-specific driver still has the extra reference
-		 * given to it by ieee1394_get_chardev(). This extra
-		 * reference prevents the module from unloading while the
-		 * file is open, and will be dropped by the VFS when the
-		 * file is released. */
-
-		module_put(THIS_MODULE);
-	} else {
-		/* point the file's f_ops back to ieee1394. The VFS will then
-		   decrement ieee1394's reference count immediately after this
-		   function returns. */
-		
-		file->f_op = &ieee1394_chardev_ops;
-
-		/* If the open() failed, then we need to drop the extra
-		 * reference we gave to the task-specific driver. */
-
-		module_put(module);
-	}
-
-	return retval;
-}
-
 static int __init ieee1394_init(void)
 {
 	devfs_mk_dir("ieee1394");
-	if (register_chrdev(IEEE1394_MAJOR, "ieee1394", &ieee1394_chardev_ops)) {
+
+	if (register_chrdev_region(IEEE1394_CORE_DEV, 256, "ieee1394")) {
 		HPSB_ERR("unable to register character device major %d!\n", IEEE1394_MAJOR);
 		return -ENODEV;
 	}
@@ -1184,7 +1009,6 @@ static int __init ieee1394_init(void)
 
 	bus_register(&ieee1394_bus_type);
 
-	init_hpsb_highlevel();
 	init_csr();
 
 	if (!disable_nodemgr)
@@ -1206,7 +1030,7 @@ static void __exit ieee1394_cleanup(void
 
 	kmem_cache_destroy(hpsb_packet_cache);
 
-	unregister_chrdev(IEEE1394_MAJOR, "ieee1394");
+	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
 	devfs_remove("ieee1394");
 }
 
@@ -1234,8 +1058,6 @@ EXPORT_SYMBOL(hpsb_selfid_received);
 EXPORT_SYMBOL(hpsb_selfid_complete);
 EXPORT_SYMBOL(hpsb_packet_sent);
 EXPORT_SYMBOL(hpsb_packet_received);
-EXPORT_SYMBOL(ieee1394_register_chardev);
-EXPORT_SYMBOL(ieee1394_unregister_chardev);
 
 /** ieee1394_transactions.c **/
 EXPORT_SYMBOL(hpsb_get_tlabel);
diff -purN linux-2.6.1/drivers/ieee1394/ieee1394_core.h linux-2.5/drivers/ieee1394/ieee1394_core.h
--- linux-2.6.1/drivers/ieee1394/ieee1394_core.h	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ieee1394_core.h	2004-01-14 23:07:21.000000000 +0000
@@ -176,9 +176,9 @@ void hpsb_packet_received(struct hpsb_ho
  * task-specific interfaces (raw1394, video1394, dv1394, etc) in
  * blocks of 16.
  *
- * The core ieee1394.o modules handles the initial open() for all
- * character devices on major 171; it then dispatches to the
- * appropriate task-specific driver.
+ * The core ieee1394.o module allocates the device number region
+ * 171:0-255, the various drivers must then cdev_add() their cdev
+ * objects to handle their respective sub-regions.
  *
  * Minor device number block allocations:
  *
@@ -199,29 +199,19 @@ void hpsb_packet_received(struct hpsb_ho
 #define IEEE1394_MINOR_BLOCK_AMDTP         3
 #define IEEE1394_MINOR_BLOCK_EXPERIMENTAL 15
 
+#define IEEE1394_CORE_DEV		MKDEV(IEEE1394_MAJOR, 0)
+#define IEEE1394_RAW1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16)
+#define IEEE1394_VIDEO1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_VIDEO1394 * 16)
+#define IEEE1394_DV1394_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_DV1394 * 16)
+#define IEEE1394_AMDTP_DEV		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_AMDTP * 16)
+#define IEEE1394_EXPERIMENTAL_DEV	MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_EXPERIMENTAL * 16)
+
 /* return the index (within a minor number block) of a file */
 static inline unsigned char ieee1394_file_to_instance(struct file *file)
 {
-	unsigned char minor = iminor(file->f_dentry->d_inode);
-	
-	/* return lower 4 bits */
-	return minor & 0xF;
+	return file->f_dentry->d_inode->i_cindex;
 }
 
-/* 
- * Task-specific drivers should call ieee1394_register_chardev() to
- * request a block of 16 minor numbers.
- *
- * Returns 0 if the request was successful, -EBUSY if the block was
- * already taken.
- */
-
-int  ieee1394_register_chardev(int blocknum,           /* 0-15 */
-			       struct module *module,  /* THIS_MODULE */
-			       struct file_operations *file_ops);
-
-/* release a block of minor numbers */
-void ieee1394_unregister_chardev(int blocknum);
 
 /* Our sysfs bus entry */
 extern struct bus_type ieee1394_bus_type;
diff -purN linux-2.6.1/drivers/ieee1394/ohci1394.c linux-2.5/drivers/ieee1394/ohci1394.c
--- linux-2.6.1/drivers/ieee1394/ohci1394.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/ieee1394/ohci1394.c	2004-01-14 23:20:31.000000000 +0000
@@ -161,7 +161,7 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, card , ## args)
 
 static char version[] __devinitdata =
-	"$Rev: 1087 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1097 $ Ben Collins <bcollins@debian.org>";
 
 /* Module Parameters */
 static int phys_dma = 1;
@@ -174,6 +174,7 @@ static void dma_trm_reset(struct dma_trm
 static int alloc_dma_rcv_ctx(struct ti_ohci *ohci, struct dma_rcv_ctx *d,
 			     enum context_type type, int ctx, int num_desc,
 			     int buf_size, int split_buf_size, int context_base);
+static void stop_dma_rcv_ctx(struct dma_rcv_ctx *d);
 static void free_dma_rcv_ctx(struct dma_rcv_ctx *d);
 
 static int alloc_dma_trm_ctx(struct ti_ohci *ohci, struct dma_trm_ctx *d,
@@ -358,7 +359,7 @@ static void ohci_soft_reset(struct ti_oh
 	reg_write(ohci, OHCI1394_HCControlSet, OHCI1394_HCControl_softReset);
   
 	for (i = 0; i < OHCI_LOOP_COUNT; i++) {
-		if (!reg_read(ohci, OHCI1394_HCControlSet) & OHCI1394_HCControl_softReset)
+		if (!(reg_read(ohci, OHCI1394_HCControlSet) & OHCI1394_HCControl_softReset))
 			break;
 		mdelay(1);
 	}
@@ -1077,6 +1078,7 @@ static int ohci_devctl(struct hpsb_host 
                 DBGMSG(ohci->id, "Listening disabled on channel %d", arg);
 
 		if (ohci->ir_legacy_channels == 0) {
+			stop_dma_rcv_ctx(&ohci->ir_legacy_context);
 			free_dma_rcv_ctx(&ohci->ir_legacy_context);
 			DBGMSG(ohci->id, "ISO receive legacy context deactivated");
 		}
@@ -2249,6 +2251,14 @@ static irqreturn_t ohci_irq_handler(int 
 	if (!event)
 		return IRQ_NONE;
 
+	/* If event is ~(u32)0 cardbus card was ejected.  In this case
+	 * we just return, and clean up in the ohci1394_pci_remove
+	 * function. */
+	if (event == ~(u32) 0) {
+		DBGMSG(ohci->id, "Device removed.");
+		return IRQ_NONE;
+	}
+
 	DBGMSG(ohci->id, "IntEvent: %08x", event);
 
 	if (event & OHCI1394_unrecoverableError) {
@@ -2811,15 +2821,8 @@ static void dma_trm_tasklet (unsigned lo
 	spin_unlock_irqrestore(&d->lock, flags);
 }
 
-static void free_dma_rcv_ctx(struct dma_rcv_ctx *d)
+static void stop_dma_rcv_ctx(struct dma_rcv_ctx *d)
 {
-	int i;
-
-	if (d->ohci == NULL)
-		return;
-
-	DBGMSG(d->ohci->id, "Freeing dma_rcv_ctx %d", d->ctx);
-
 	if (d->ctrlClear) {
 		ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
 
@@ -2831,6 +2834,17 @@ static void free_dma_rcv_ctx(struct dma_
 			tasklet_kill(&d->task);
 		}
 	}
+}
+
+
+static void free_dma_rcv_ctx(struct dma_rcv_ctx *d)
+{
+	int i;
+
+	if (d->ohci == NULL)
+		return;
+
+	DBGMSG(d->ohci->id, "Freeing dma_rcv_ctx %d", d->ctx);
 
 	if (d->buf_cpu) {
 		for (i=0; i<d->num_desc; i++)
@@ -2982,19 +2996,6 @@ static void free_dma_trm_ctx(struct dma_
 
 	DBGMSG(d->ohci->id, "Freeing dma_trm_ctx %d", d->ctx);
 
-	if (d->ctrlClear) {
-		ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
-
-		if (d->type == DMA_CTX_ISO) {
-			/* disable interrupts */
-			reg_write(d->ohci, OHCI1394_IsoXmitIntMaskClear, 1 << d->ctx);
-			ohci1394_unregister_iso_tasklet(d->ohci,
-							&d->ohci->it_legacy_tasklet);
-		} else {
-			tasklet_kill(&d->task);
-		}
-	}
-
 	if (d->prg_cpu) {
 		for (i=0; i<d->num_desc; i++) 
 			if (d->prg_cpu[i] && d->prg_bus[i]) {
@@ -3511,6 +3512,8 @@ static void ohci1394_pci_remove(struct p
 		free_irq(ohci->dev->irq, ohci);
 
 	case OHCI_INIT_HAVE_TXRX_BUFFERS__MAYBE:
+		/* The ohci_soft_reset() stops all DMA contexts, so we
+		 * dont need to do this.  */
 		/* Free AR dma */
 		free_dma_rcv_ctx(&ohci->ar_req_context);
 		free_dma_rcv_ctx(&ohci->ar_resp_context);
diff -purN linux-2.6.1/drivers/ieee1394/oui.db linux-2.5/drivers/ieee1394/oui.db
--- linux-2.6.1/drivers/ieee1394/oui.db	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/oui.db	2004-01-14 22:57:14.000000000 +0000
@@ -108,7 +108,7 @@
 00006B SILICON GRAPHICS INC./MIPS
 00006D CRAY COMMUNICATIONS, LTD.
 00006E ARTISOFT, INC.
-00006F MADGE NETWORKS LTD.
+00006F Madge Ltd.
 000070 HCL LIMITED
 000071 ADRA SYSTEMS INC.
 000072 MINIWARE TECHNOLOGY
@@ -137,7 +137,7 @@
 000089 CAYMAN SYSTEMS INC.
 00008A DATAHOUSE INFORMATION SYSTEMS
 00008B INFOTRON
-00008C ALLOY COMPUTER PRODUCTS, INC.
+00008C Alloy Computer Products (Australia) Pty Ltd
 00008D VERDIX CORPORATION
 00008E SOLBOURNE COMPUTER, INC.
 00008F RAYTHEON COMPANY
@@ -190,7 +190,7 @@
 0000BE THE NTI GROUP
 0000BF SYMMETRIC COMPUTER SYSTEMS
 0000C0 WESTERN DIGITAL CORPORATION
-0000C1 Madge Networks Ltd.
+0000C1 Madge Ltd.
 0000C2 INFORMATION PRESENTATION TECH.
 0000C3 HARRIS CORP COMPUTER SYS DIV
 0000C4 WATERS DIV. OF MILLIPORE
@@ -202,7 +202,7 @@
 0000CA APPLITEK
 0000CB COMPU-SHACK ELECTRONIC GMBH
 0000CC DENSAN CO., LTD.
-0000CD Centrecom Systems, Ltd.
+0000CD Allied Telesyn Research Ltd.
 0000CE MEGADATA CORP.
 0000CF HAYES MICROCOMPUTER PRODUCTS
 0000D0 DEVELCON ELECTRONICS LTD.
@@ -271,7 +271,7 @@
 000110 Gotham Networks
 000111 iDigm Inc.
 000112 Shark Multimedia Inc.
-000113 OLYMPUS OPTICAL CO., LTD.
+000113 OLYMPUS CORPORATION
 000114 KANDA TSUSHIN KOGYO CO., LTD.
 000115 EXTRATECH CORPORATION
 000116 Netspect Technologies, Inc.
@@ -345,7 +345,7 @@
 00015A Digital Video Broadcasting
 00015B ITALTEL S.p.A/RF-UP-I
 00015C CADANT INC.
-00015D Pirus Networks
+00015D Sun Microsystems, Inc
 00015E BEST TECHNOLOGY CO., LTD.
 00015F DIGITAL DESIGN GmbH
 000160 ELMEX Co., LTD.
@@ -361,7 +361,7 @@
 00016A ALITEC
 00016B LightChip, Inc.
 00016C FOXCONN
-00016D Triton Network Systems
+00016D CarrierComm Inc.
 00016E Conklin Corporation
 00016F HAITAI ELECTRONICS CO., LTD.
 000170 ESE Embedded System Engineer'g
@@ -445,7 +445,7 @@
 0001BE Gigalink Co., Ltd.
 0001BF Teleforce Co., Ltd.
 0001C0 CompuLab, Ltd.
-0001C1 Exbit Technology
+0001C1 Vitesse Semiconductor Corporation
 0001C2 ARK Research Corp.
 0001C3 Acromag, Inc.
 0001C4 NeoWave, Inc.
@@ -495,6 +495,7 @@
 0001EF Camtel Technology Corp.
 0001F0 Tridium, Inc.
 0001F1 Innovative Concepts, Inc.
+0001F2 Mark of the Unicorn, Inc.
 0001F3 QPS, Inc.
 0001F4 Enterasys Networks
 0001F5 ERIM S.A.
@@ -515,6 +516,7 @@
 000204 Bodmann Industries Elektronik GmbH
 000205 Hitachi Denshi, Ltd.
 000206 Telital R&D Denmark A/S
+000207 VisionGlobal Network Corp.
 000208 Unify Networks, Inc.
 000209 Shenzhen SED Information Technology Co., Ltd.
 00020A Gefran Spa
@@ -579,7 +581,7 @@
 000245 Lampus Co, Ltd.
 000246 All-Win Tech Co., Ltd.
 000247 Great Dragon Information Technology (Group) Co., Ltd.
-000248 Pila GmbH & Co.
+000248 Pilz GmbH & Co.
 000249 Aviv Infocom Co, Ltd.
 00024A Cisco Systems, Inc.
 00024B Cisco Systems, Inc.
@@ -600,6 +602,7 @@
 00025A Catena Networks
 00025B Cambridge Silicon Radio
 00025C SCI Systems (Kunshan) Co., Ltd.
+00025D Calix Networks
 00025E High Technology Ltd
 00025F Nortel Networks
 000260 Accordion Networks, Inc.
@@ -635,7 +638,7 @@
 00027E Cisco Systems, Inc.
 00027F ask-technologies.com
 000280 Mu Net, Inc.
-000281 Red-M (Communications) Ltd.
+000281 Madge Ltd.
 000282 ViaClix, Inc.
 000283 Spectrum Controls, Inc.
 000284 Alstom T&D P&C
@@ -662,6 +665,7 @@
 000299 Apex, Inc.
 00029A Storage Apps
 00029B Kreatel Communications AB
+00029C 3COM
 00029D Merix Corp.
 00029E Information Equipment Co., Ltd.
 00029F L-3 Communication Aviation Recorders
@@ -678,7 +682,7 @@
 0002AA PLcom Co., Ltd.
 0002AB CTC Union Technologies Co., Ltd.
 0002AC 3PAR data
-0002AD Asahi Optical Co., Ltd.
+0002AD Pentax Corpotation
 0002AE Scannex Electronics Ltd.
 0002AF TeleCruz Technology, Inc.
 0002B0 Hokubu Communication & Industrial Co., Ltd.
@@ -740,7 +744,7 @@
 0002E8 E.D.&A.
 0002E9 CS Systemes De Securite - C3S
 0002EA Videonics, Inc.
-0002EB Easent Communications
+0002EB Pico Communications
 0002EC Maschoff Design Engineering
 0002ED DXO Telecom Co., Ltd.
 0002EE Nokia Danmark A/S
@@ -760,7 +764,7 @@
 0002FC Cisco Systems, Inc.
 0002FD Cisco Systems, Inc.
 0002FE Viditec, Inc.
-0002FF Handan Broad InfoCom
+0002FF Handan BroadInfoCom
 000300 NetContinuum, Inc.
 000301 Avantas Networks Corporation
 000302 Oasys Telecom, Inc.
@@ -776,7 +780,7 @@
 00030C Telesoft Technologies Ltd.
 00030D Uniwill Computer Corp.
 00030E Core Communications Co., Ltd.
-00030F Legend Digital China Ltd.
+00030F Digital China (Shanghai) Networks Ltd.
 000310 Link Evolution Corp.
 000311 Micro Technology Co., Ltd.
 000312 TR-Systemtechnik GmbH
@@ -797,7 +801,7 @@
 000321 Reco Research Co., Ltd.
 000322 IDIS Co., Ltd.
 000323 Cornet Technology, Inc.
-000324 Tottori SANYO Electric Co., Ltd.
+000324 SANYO Multimedia Tottori Co., Ltd.
 000325 Arima Computer Corp.
 000326 Iwasaki Information Systems Co., Ltd.
 000327 ACT'L
@@ -851,12 +855,12 @@
 000357 Intervoice-Brite, Inc.
 000358 iCable System Co., Ltd.
 000359 DigitalSis
-00035A Phototron Limited
+00035A Photron Limited
 00035B BridgeWave Communications
 00035C Saint Song Corp.
 00035D Bosung Hi-Net Co., Ltd.
 00035E Metropolitan Area Networks, Inc.
-00035F Schuehle Mess - und. Kontrollsysteme
+00035F Prueftechnik Condition Monitoring GmbH & Co. KG
 000360 PAC Interactive Technology, Inc.
 000361 Widcomm, Inc.
 000362 Vodtel Communications, Inc.
@@ -889,6 +893,7 @@
 00037D Stellcom
 00037E PORTech Communications, Inc.
 00037F Atheros Communications, Inc.
+000380 SSH Communications Security Corp.
 000381 Ingenico International
 000382 A-One Co., Ltd.
 000383 Metera Networks, Inc.
@@ -916,7 +921,7 @@
 00039A nSine, Ltd.
 00039B NetChip Technology, Inc.
 00039C OptiMight Communications, Inc.
-00039D Acer Communications & Multimedia, Inc.
+00039D BENQ CORPORATION
 00039E Tera System Co., Ltd.
 00039F Cisco Systems, Inc.
 0003A0 Cisco Systems, Inc.
@@ -1063,7 +1068,7 @@
 00042E Netous Technologies, Ltd.
 00042F International Communications Products, Inc.
 000430 Netgem
-000431 Play Industries
+000431 GlobalStreams, Inc.
 000432 Voyetra Turtle Beach, Inc.
 000433 Cyberboard A/S
 000434 Accelent Systems, Inc.
@@ -1082,7 +1087,7 @@
 000441 Half Dome Systems, Inc.
 000442 NACT
 000443 Agilent Technologies, Inc.
-000444 Wireless Home
+000444 Western Multiplex Corporation
 000445 LMS Skalar Instruments GmbH
 000446 CYZENTECH Co., Ltd.
 000447 Acrowave Systems Co., Ltd.
@@ -1097,7 +1102,7 @@
 000450 DMD Computers SRL
 000451 Medrad, Inc.
 000452 RocketLogix, Inc.
-000453 Yotta Yotta, Inc.
+000453 YottaYotta, Inc.
 000454 Quadriga UK
 000455 ANTARA.net
 000456 PipingHot Networks
@@ -1108,16 +1113,16 @@
 00045B Techsan Electronics Co., Ltd.
 00045C Mobiwave Pte Ltd
 00045D BEKA Elektronik
-00045E Poly Trax Information Technology AG
+00045E PolyTrax Information Technology AG
 00045F Evalue Technology, Inc.
 000460 Knilink Technology, Inc.
 000461 EPOX Computer Co., Ltd.
 000462 DAKOS Data & Communication Co., Ltd.
-000463 Philips Communication Security & Imaging
+000463 Bosch Security Systems
 000464 Fantasma Networks, Inc.
-000465 ist isdn support tecknik GmbH
+000465 i.s.t isdn-support technik GmbH
 000466 ARMITEL Co.
-000467 Wuhan Research Institute
+000467 Wuhan Research Institute of MII
 000468 Vivity, Inc.
 000469 Innocom, Inc.
 00046A Navini Networks
@@ -1133,7 +1138,7 @@
 000474 LEGRAND
 000475 3 Com Corporation
 000476 3 Com Corporation
-000477 e-Appliance Corp.
+000477 Scalant Systems, Inc.
 000478 G. Star Technology Corporation
 000479 Radius Co., Ltd.
 00047A AXXESSIT ASA
@@ -1144,7 +1149,7 @@
 00047F Chr. Mayr GmbH & Co. KG
 000480 Foundry Networks, Inc.
 000481 Econolite Control Products, Inc.
-000482 MediaLogic Corp.
+000482 Medialogic Corp.
 000483 Deltron Technology, Inc.
 000484 Amann GmbH
 000485 PicoLight
@@ -1195,7 +1200,7 @@
 0004B3 Videotek, Inc.
 0004B4 CIAC
 0004B5 Equitrac Corporation
-0004B6 Tellumat (Pty) Ltd.
+0004B6 Stratex Networks, Inc.
 0004B7 AMB i.t. Holding
 0004B8 Kumahira Co., Ltd.
 0004B9 S.I. Soubou, Inc.
@@ -1204,20 +1209,20 @@
 0004BC Giantec, Inc.
 0004BD Motorola BCS
 0004BE OptXCon, Inc.
-0004BF Versa Logic Corp.
+0004BF VersaLogic Corp.
 0004C0 Cisco Systems, Inc.
 0004C1 Cisco Systems, Inc.
 0004C2 Magnipix, Inc.
 0004C3 CASTOR Informatique
-0004C4 Allen & Health
+0004C4 Allen & Heath Limited
 0004C5 ASE Technologies, USA
 0004C6 Yamaha Motor Co., Ltd.
 0004C7 NetMount
-0004C8 LIBA Maschinefabrik GmbH
+0004C8 LIBA Maschinenfabrik GmbH
 0004C9 Micro Electron Co., Ltd.
 0004CA FreeMs Corp.
 0004CB Tdsoft Communication, Ltd.
-0004CC Peek Traffic BV.
+0004CC Peek Traffic B.V.
 0004CD Informedia Research Group
 0004CE Patria Ailon
 0004CF Seagate Technology
@@ -1286,7 +1291,7 @@
 00050E 3ware, Inc.
 00050F Tanaka S/S Ltd.
 000510 Infinite Shanghai Communication Terminals Ltd.
-000511 Complementaty Technologies Ltd
+000511 Complementary Technologies Ltd
 000512 MeshNetworks, Inc.
 000513 VTLinx Multimedia Systems, Inc.
 000514 KDT Systems Co., Ltd.
@@ -1299,7 +1304,7 @@
 00051B Magic Control Technology Corporation
 00051C Xnet Technology Corp.
 00051D Airocon, Inc.
-00051E Rhapsody Networks
+00051E Brocade Communications Systems, Inc.
 00051F Taijin Media Co., Ltd.
 000520 Smartronix, Inc.
 000521 Control Microsystems
@@ -1339,7 +1344,7 @@
 000543 IQ Wireless GmbH
 000544 Valley Technologies, Inc.
 000545 Internet Photonics
-000546 KDD Network Systems Co., Ltd.
+000546 K-Solutions Inc.
 000547 Starent Networks
 000548 Disco Corporation
 000549 Salira Optical Network Systems
@@ -1374,6 +1379,7 @@
 000567 Etymonic Design, Inc.
 000568 Piltofish Networks AB
 000569 VMWARE, Inc.
+00056A Heuft Systemtechnik GmbH
 00056B C.P. Technology Co., Ltd.
 00056C Hung Chang Co., Ltd.
 00056D Pacific Corporation
@@ -1408,18 +1414,18 @@
 00058B IPmental, Inc.
 00058C Opentech Inc.
 00058D Lynx Photonic Networks, Inc.
-00058E Ahead Communications System GmbH
+00058E Flextronics International GmbH & Co. Nfg. KG
 00058F CLCsoft co.
-000590 Ascom Business Systems
+000590 Swissvoice Ltd.
 000591 Active Silicon Ltd.
-000592 Pultex Corp.
+000592 Pultek Corp.
 000593 Grammar Engine Inc.
 000594 IXXAT Automation GmbH
 000595 Alesis Corporation
 000596 Genotech Co., Ltd.
 000597 Eagle Traffic Control Systems
 000598 CRONOS S.r.l.
-000599 PEI Electronics, Inc.
+000599 DRS Test and Energy Management or DRS-TEM
 00059A Cisco Systems, Inc.
 00059B Cisco Systems, Inc.
 00059C Kleinknecht GmbH, Ing. Buero
@@ -1436,7 +1442,7 @@
 0005A7 Hyperchip, Inc.
 0005A8 WYLE ELECTRONICS
 0005A9 Princeton Networks, Inc.
-0005AA Moore Industries Int.
+0005AA Moore Industries International Inc.
 0005AB Cyber Fone, Inc.
 0005AC Northern Digital, Inc.
 0005AD Topspin Communications, Inc.
@@ -1453,13 +1459,14 @@
 0005B8 Electronic Design Associates, Inc.
 0005B9 Airvana, Inc.
 0005BA Area Netwoeks, Inc.
+0005BB Myspace AB
 0005BC Resorsys Ltd.
 0005BD ROAX BV
 0005BE Kongsberg Seatex AS
 0005BF JustEzy Technology, Inc.
 0005C0 Digital Network Alacarte Co., Ltd.
 0005C1 A-Kyung Motion, Inc.
-0005C2 Digital Archway, Inc.
+0005C2 Soronti, Inc.
 0005C3 Pacific Instruments, Inc.
 0005C4 Telect, Inc.
 0005C5 Flaga HF
@@ -1470,13 +1477,13 @@
 0005CA Hitron Technology, Inc.
 0005CB ROIS Technologies, Inc.
 0005CC Sumtel Communications, Inc.
-0005CD Nippon Columbia
+0005CD Denon, Ltd.
 0005CE Prolink Microsystems Corporation
 0005CF Thunder River Technologies, Inc.
 0005D0 Solinet Systems
 0005D1 Metavector Technologies
 0005D2 DAP Technologies
-0005D3 CAC, Inc.
+0005D3 eProduction Solutions, Inc.
 0005D4 FutureSmart Networks, Inc.
 0005D5 Speedcom Wireless
 0005D6 Titan Wireless
@@ -1496,27 +1503,27 @@
 0005E4 Red Lion Controls L.P.
 0005E5 Renishaw PLC
 0005E6 Egenera, Inc.
-0005E7 Netrake
+0005E7 Netrake Corp.
 0005E8 TurboWave, Inc.
-0005E9 Unicess Networks, Inc.
-0005EA Viewcast Corporation
+0005E9 Unicess Network, Inc.
+0005EA Rednix
 0005EB Blue Ridge Networks, Inc.
 0005EC Mosaic Systems Inc.
-0005ED Technikum Joanneaum GmbH
+0005ED Technikum Joanneum GmbH
 0005EE BEWATOR Group
 0005EF ADOIR Digital Technology
 0005F0 SATEC
-0005F1 VRcom, Inc.
+0005F1 Vrcom, Inc.
 0005F2 Power R, Inc.
 0005F3 Weboyn
-0005F4 SystemBase Co., Ltd.
+0005F4 System Base Co., Ltd.
 0005F5 OYO Geospace Corp.
 0005F6 Young Chang Co. Ltd.
 0005F7 Analog Devices, Inc.
 0005F8 Real Time Access, Inc.
-0005F9 Diva Systems
+0005F9 TOA Corporation
 0005FA IPOptical, Inc.
-0005FB Sharegate
+0005FB ShareGate, Inc.
 0005FC Schenck Pegasus Corp.
 0005FD PacketLight Networks Ltd.
 0005FE Traficon N.V.
@@ -1524,23 +1531,23 @@
 000600 Tokyo Electronic Industry Co., Ltd.
 000601 Otanikeiki Co., Ltd.
 000602 Cirkitech Electronics Co.
-000603 Baker Hughes
+000603 Baker Hughes Inc.
 000604 @Track Communications, Inc.
 000605 Inncom International, Inc.
-000606 RapidWan, Inc.
-000607 Omni-Directional Control Technology Inc.
+000606 RapidWAN, Inc.
+000607 Omni Directional Control Technology Inc.
 000608 At-Sky SAS
 000609 Crossport Systems
-00060A Blue2space.com
+00060A Blue2space
 00060B Paceline Systems Corporation
 00060C Melco Industries, Inc.
 00060D Wave7 Optics
-00060E IGSYS Systems, Inc.
+00060E IGYS Systems, Inc.
 00060F Narad Networks Inc
 000610 Abeona Networks Inc
 000611 Zeus Wireless, Inc.
 000612 Accusys, Inc.
-000613 Kawasaki Steel Corporation
+000613 Kawasaki Microelectronics Incorporated
 000614 Prism Holdings
 000615 Kimoto Electric Co., Ltd.
 000616 Tel Net Co., Ltd.
@@ -1557,7 +1564,7 @@
 000621 Hinox, Co., Ltd.
 000622 Chung Fu Chen Yeh Enterprise Corp.
 000623 MGE UPS Systems France
-000624 Gentner Communications
+000624 Gentner Communications Corp.
 000625 The Linksys Group, Inc.
 000626 MWE GmbH
 000627 Uniwide Technologies, Inc.
@@ -1580,7 +1587,7 @@
 000638 Sungjin C&C Co., Ltd.
 000639 Newtec
 00063A Dura Micro, Inc.
-00063B Lineo Canada Corp.
+00063B Arcturus Networks, Inc.
 00063C NMI Electronics Ltd
 00063D Microwave Data Systems Inc.
 00063E Opthos Inc.
@@ -1622,7 +1629,7 @@
 000662 MBM Technology Ltd.
 000663 Human Technology Co., Ltd.
 000664 Fostex Corporation
-000665 Summy Gikem, Inc.
+000665 Sunny Giken, Inc.
 000666 Roving Networks
 000667 Tripp Lite
 000668 Vicon Industries Inc.
@@ -1639,7 +1646,7 @@
 000673 Optelecom, Inc.
 000674 Spectrum Control, Inc.
 000675 Banderacom, Inc.
-000676 Novra Technologies, Inc.
+000676 Novra Technologies Inc.
 000677 SICK AG
 000678 Marantz Japan, Inc.
 000679 Konami Corporation
@@ -1647,18 +1654,2125 @@
 00067B Toplink C&C Corporation
 00067C CISCO SYSTEMS, INC.
 00067D Takasago Ltd.
+00067E WinCom Systems, Inc.
+00067F Rearden Steel Technologies
+000680 Card Access, Inc.
+000681 Goepel Electronic GmbH
+000682 Convedia
+000683 Bravara Communications, Inc.
+000684 Biacore AB
+000685 NetNearU Corporation
+000686 ZARDCOM Co., Ltd.
+000687 Omnitron Systems Technology, Inc.
+000688 Telways Communication Co., Ltd.
+000689 yLez Technologies Pte Ltd
+00068A NeuronNet Co. Ltd. R&D Center
+00068B AirRunner Technologies, Inc.
+00068C 3Com Corporation
+00068D SANgate Systems
+00068E HID Corporation
+00068F Telemonitor, Inc.
+000690 Euracom Communication GmbH
+000691 PT Inovacao
+000692 Intruvert Networks, Inc.
+000693 Flexus Computer Technology, Inc.
+000694 Mobillian Corporation
+000695 Ensure Technologies, Inc.
+000696 Advent Networks
+000697 R & D Center
+000698 egnite Software GmbH
+000699 Vida Design Co.
+00069A e & Tel
+00069B AVT Audio Video Technologies GmbH
+00069C Transmode Systems AB
+00069D Petards Mobile Intelligence
+00069E UNIQA, Inc.
+00069F Kuokoa Networks
+0006A0 Mx Imaging
+0006A1 Celsian Technologies, Inc.
+0006A2 Microtune, Inc.
+0006A3 Bitran Corporation
+0006A4 INNOWELL Corp.
+0006A5 PINON Corp.
+0006A6 Artistic Licence (UK) Ltd
+0006A7 Primarion
+0006A8 KC Technology, Inc.
+0006A9 Universal Instruments Corp.
+0006AA Miltope Corporation
+0006AB W-Link Systems, Inc.
+0006AC Intersoft Co.
+0006AD KB Electronics Ltd.
+0006AE Himachal Futuristic Communications Ltd
+0006B0 Comtech EF Data Corp.
+0006B1 Sonicwall
+0006B2 Linxtek Co.
+0006B3 Diagraph Corporation
+0006B4 Vorne Industries, Inc.
+0006B5 Luminent, Inc.
+0006B6 Nir-Or Israel Ltd.
+0006B7 TELEM GmbH
+0006B8 Bandspeed Pty Ltd
+0006B9 A5TEK Corp.
+0006BA Westwave Communications
+0006BB ATI Technologies Inc.
+0006BC Macrolink, Inc.
+0006BD BNTECHNOLOGY Co., Ltd.
+0006BE Baumer Optronic GmbH
+0006BF Accella Technologies Co., Ltd.
+0006C0 United Internetworks, Inc.
 0006C1 CISCO SYSTEMS, INC.
+0006C2 Smartmatic Corporation
+0006C3 Schindler Elevators Ltd.
+0006C4 Piolink Inc.
+0006C5 INNOVI Technologies Limited
+0006C6 lesswire AG
+0006C7 RFNET Technologies Pte Ltd (S)
+0006C8 Sumitomo Metal Micro Devices, Inc.
+0006C9 Technical Marketing Research, Inc.
+0006CA American Computer & Digital Components, Inc. (ACDC)
+0006CB Jotron Electronics A/S
+0006CC JMI Electronics Co., Ltd.
+0006CD CreoScitex Corporation Ltd.
+0006CE DATENO
+0006CF Thales Avionics In-Flight Systems, LLC
+0006D0 Elgar Electronics Corp.
+0006D1 Tahoe Networks, Inc.
+0006D2 Tundra Semiconductor Corp.
+0006D3 Alpha Telecom, Inc. U.S.A.
+0006D4 Interactive Objects, Inc.
+0006D5 Diamond Systems Corp.
+0006D6 Cisco Systems, Inc.
+0006D7 Cisco Systems, Inc.
+0006D8 Maple Optical Systems
+0006D9 IPM-Net S.p.A.
+0006DA ITRAN Communications Ltd.
+0006DB ICHIPS Co., Ltd.
+0006DC Syabas Technology (Amquest)
+0006DD AT & T Laboratories - Cambridge Ltd
+0006DE Flash Technology
+0006DF AIDONIC Corporation
+0006E0 MAT Co., Ltd.
+0006E1 Techno Trade s.a
+0006E2 Ceemax Technology Co., Ltd.
+0006E3 Quantitative Imaging Corporation
+0006E4 Citel Technologies Ltd.
+0006E5 Fujian Newland Computer Ltd. Co.
+0006E6 DongYang Telecom Co., Ltd.
+0006E7 Bit Blitz Communications Inc.
+0006E8 Optical Network Testing, Inc.
+0006E9 Intime Corp.
+0006EA ELZET80 Mikrocomputer GmbH&Co. KG
+0006EB Global Data
+0006EC M/A COM Private Radio System Inc.
+0006ED Inara Networks
+0006EE Shenyang Neu-era Information & Technology Stock Co., Ltd
+0006EF Maxxan Systems, Inc.
+0006F0 Digeo, Inc.
+0006F1 Optillion
+0006F2 Platys Communications
+0006F3 AcceLight Networks
+0006F4 Prime Electronics & Satellitics Inc.
+0006F9 Mitsui Zosen Systems Research Inc.
+0006FA IP SQUARE Co, Ltd.
+0006FB Hitachi Printing Solutions, Ltd.
+0006FC Fnet Co., Ltd.
+0006FD Comjet Information Systems Corp.
+0006FE Celion Networks, Inc.
+0006FF Sheba Systems Co., Ltd.
+000700 Zettamedia Korea
 000701 RACAL-DATACOM
+000702 Varian Medical Systems
+000703 CSEE Transport
+000705 Endress & Hauser GmbH & Co
+000706 Sanritz Corporation
+000707 Interalia Inc.
+000708 Bitrage Inc.
+000709 Westerstrand Urfabrik AB
+00070A Unicom Automation Co., Ltd.
+00070B Octal, SA
+00070C SVA-Intrusion.com Co. Ltd.
+00070D Cisco Systems Inc.
+00070E Cisco Systems Inc.
+00070F Fujant, Inc.
+000710 Adax, Inc.
+000711 Acterna
+000712 JAL Information Technology
+000713 IP One, Inc.
+000714 Brightcom
+000715 General Research of Electronics, Inc.
+000716 J & S Marine Ltd.
+000717 Wieland Electric GmbH
+000718 iCanTek Co., Ltd.
+000719 Mobiis Co., Ltd.
+00071A Finedigital Inc.
+00071B Position Technology Inc.
+00071C AT&T Fixed Wireless Services
+00071D Satelsa Sistemas Y Aplicaciones De Telecomunicaciones, S.A.
+00071E Tri-M Engineering / Nupak Dev. Corp.
+00071F European Systems Integration
+000720 Trutzschler GmbH & Co. KG
+000721 Formac Elektronik GmbH
+000722 Nielsen Media Research
+000723 ELCON Systemtechnik GmbH
+000724 Telemax Co., Ltd.
+000725 Bematech International Corp.
+000727 Zi Corporation (HK) Ltd.
+000728 Neo Telecom
+000729 Kistler Instrumente AG
+00072A Innovance Networks
+00072B Jung Myung Telecom Co., Ltd.
+00072C Fabricom
+00072D CNSystems
+00072E North Node AB
+00072F Instransa, Inc.
+000730 Hutchison OPTEL Telecom Technology Co., Ltd.
+000731 Spiricon, Inc.
+000732 AAEON Technology Inc.
+000733 DANCONTROL Engineering
+000734 ONStor, Inc.
+000735 Flarion Technologies, Inc.
+000736 Data Video Technologies Co., Ltd.
+000737 Soriya Co. Ltd.
+000738 Young Technology Co., Ltd.
+000739 Motion Media Technology Ltd.
+00073A Inventel Systemes
+00073B Tenovis GmbH & Co KG
+00073C Telecom Design
+00073D Nanjing Postel Telecommunications Co., Ltd.
+00073E China Great-Wall Computer Shenzhen Co., Ltd.
+00073F Woojyun Systec Co., Ltd.
+000740 Melco Inc.
+000741 Sierra Automated Systems
+000742 Current Technologies
+000743 Chelsio Communications
+000744 Unico, Inc.
+000745 Radlan Computer Communications Ltd.
+000746 Interlink BT, LLC
+000747 Mecalc
+000748 The Imaging Source Europe
+000749 CENiX Inc.
+00074A Carl Valentin GmbH
+00074B Daihen Corporation
+00074C Beicom Inc.
+00074D Zebra Technologies Corp.
+00074E Naughty boy co., Ltd.
+00074F Cisco Systems, Inc.
+000750 Cisco Systems, Inc.
+000751 m.u.t. - GmbH
+000752 Rhythm Watch Co., Ltd.
+000753 Beijing Qxcomm Technology Co., Ltd.
+000754 Xyterra Computing, Inc.
+000755 Lafon SA
+000756 Juyoung Telecom
+000757 Topcall International AG
+000758 Dragonwave
+000759 Boris Manufacturing Corp.
+00075A Air Products and Chemicals, Inc.
+00075B Gibson Guitars
+00075C ENCAD, Inc.
+00075D Celleritas Inc.
+00075E Pulsar Technologies, Inc.
+00075F VCS Video Communication Systems AG
+000760 TOMIS Information & Telecom Corp.
+000761 Logitech SA
+000762 Group Sense Limited
+000763 Sunniwell Cyber Tech. Co., Ltd.
+000764 YoungWoo Telecom Co. Ltd.
+000765 Jade Quantum Technologies, Inc.
+000766 Chou Chin Industrial Co., Ltd.
+000767 Yuxing Electronics Company Limited
+000768 Danfoss A/S
+000769 Italiana Macchi SpA
+00076A NEXTEYE Co., Ltd.
+00076B Stralfors AB
+00076C Daehanet, Inc.
+00076D Flexlight Networks
+00076E Sinetica Corporation Ltd.
+00076F Synoptics Limited
+000770 Locusnetworks Corporation
+000771 Embedded System Corporation
+000772 Alcatel Shanghai Bell Co., Ltd.
+000773 Ascom Powerline Communications Ltd.
+000774 GuangZhou Thinker Technology Co. Ltd.
+000775 Valence Semiconductor, Inc.
+000776 Federal APD
+000777 Motah Ltd.
+000778 GERSTEL GmbH & Co. KG
+000779 Sungil Telecom Co., Ltd.
+00077A Infoware System Co., Ltd.
+00077B Millimetrix Broadband Networks
+00077C OnTime Networks
+00077E Elrest GmbH
+00077F J Communications Co., Ltd.
+000780 Bluegiga Technologies OY
+000781 Itron Inc.
+000782 Nauticus Networks, Inc.
+000783 SynCom Network, Inc.
+000784 Cisco Systems Inc.
+000785 Cisco Systems Inc.
+000786 Wireless Networks Inc.
+000787 Idea System Co., Ltd.
+000788 Clipcomm, Inc.
+000789 Eastel Systems Corporation
+00078A Mentor Data System Inc.
+00078B Wegener Communications, Inc.
+00078C Elektronikspecialisten i Borlange AB
+00078D NetEngines Ltd.
+00078E Garz & Friche GmbH
+00078F Emkay Innovative Products
+000790 Tri-M Technologies (s) Limited
+000791 International Data Communications, Inc.
+000792 Suetron Electronic GmbH
+000794 Simple Devices, Inc.
+000795 Elitegroup Computer System Co. (ECS)
+000796 LSI Systems, Inc.
+000797 Netpower Co., Ltd.
+000798 Selea SRL
+000799 Tipping Point Technologies, Inc.
+00079A SmartSight Networks Inc.
+00079B Aurora Networks
+00079C Golden Electronics Technology Co., Ltd.
+00079D Musashi Co., Ltd.
+00079E Ilinx Co., Ltd.
+00079F Action Digital Inc.
+0007A0 e-Watch Inc.
+0007A1 VIASYS Healthcare GmbH
+0007A2 Opteon Corporation
+0007A3 Ositis Software, Inc.
+0007A4 GN Netcom Ltd.
+0007A5 Y.D.K Co. Ltd.
+0007A6 Home Automation, Inc.
+0007A7 A-Z Inc.
+0007A8 Haier Group Technologies Ltd.
+0007A9 Novasonics
+0007AA Quantum Data Inc.
+0007AC Eolring
+0007AD Pentacon GmbH Foto-und Feinwerktechnik
+0007AE Layer N Networks
+0007AF N-Tron Corp.
+0007B0 Office Details, Inc.
+0007B1 Equator Technologies
+0007B2 Transaccess S.A.
+0007B3 Cisco Systems Inc.
+0007B4 Cisco Systems Inc.
+0007B5 Any One Wireless Ltd.
+0007B6 Telecom Technology Ltd.
+0007B7 Samurai Ind. Prods Eletronicos Ltda
+0007B8 American Predator Corp.
+0007B9 Ginganet Corporation
+0007BA Xebeo Communications, Inc.
+0007BB Candera Inc.
+0007BC Identix Inc.
+0007BD Radionet Ltd.
+0007BE DataLogic SpA
+0007BF Armillaire Technologies, Inc.
+0007C0 NetZerver Inc.
+0007C1 Overture Networks, Inc.
+0007C2 Netsys Telecom
+0007C3 Cirpack
+0007C4 JEAN Co. Ltd.
+0007C5 Gcom, Inc.
+0007C6 VDS Vosskuhler GmbH
+0007C7 Synectics Systems Limited
+0007C8 Brain21, Inc.
+0007C9 Technol Seven Co., Ltd.
+0007CA Creatix Polymedia Ges Fur Kommunikaitonssysteme
+0007CB Freebox SA
+0007CC Kaba Benzing GmbH
+0007CD NMTEL Co., Ltd.
+0007CE Cabletime Limited
+0007CF Anoto AB
+0007D0 Automat Engenharia de Automaoa Ltda.
+0007D1 Spectrum Signal Processing Inc.
+0007D2 Logopak Systeme
+0007D3 Stork Digital Imaging B.V.
+0007D4 Zhejiang Yutong Network Communication Co Ltd.
+0007D5 3e Technologies Int;., Inc.
+0007D6 Commil Ltd.
+0007D7 Caporis Networks AG
+0007D8 Hitron Systems Inc.
+0007D9 Splicecom
+0007DA Neuro Telecom Co., Ltd.
+0007DB Kirana Networks, Inc.
+0007DC Atek Co, Ltd.
+0007DD Cradle Technologies
+0007DE eCopilt AB
+0007DF Vbrick Systems Inc.
+0007E0 Palm Inc.
+0007E1 WIS Communications Co. Ltd.
+0007E2 Bitworks, Inc.
+0007E3 Navcom Technology, Inc.
+0007E4 SoftRadio Co., Ltd.
+0007E5 Coup Corporation
+0007E6 edgeflow Canada Inc.
+0007E7 FreeWave Technologies
+0007E8 St. Bernard Software
+0007E9 Intel Corporation
+0007EA Massana, Inc.
+0007EB Cisco Systems Inc.
+0007EC Cisco Systems Inc.
+0007ED Altera Corporation
+0007EE telco Informationssysteme GmbH
+0007EF Lockheed Martin Tactical Systems
+0007F0 LogiSync Corporation
+0007F1 TeraBurst Networks Inc.
+0007F2 IOA Corporation
+0007F3 Think Engine Networks
+0007F4 Eletex Co., Ltd.
+0007F5 Bridgeco Co AG
+0007F6 Qqest Software Systems
+0007F7 Galtronics
+0007F8 ITDevices, Inc.
+0007F9 Phonetics, Inc.
+0007FA ITT Co., Ltd.
+0007FB Giga Stream UMTS Technologies GmbH
+0007FC Adept Systems Inc.
+0007FD LANergy Ltd.
+0007FE Rigaku Corporation
+0007FF Gluon Networks
 000800 MULTITECH SYSTEMS, INC.
+000801 HighSpeed Surfing Inc.
+000802 Compaq Computer Corporation
+000803 Cos Tron
+000804 ICA Inc.
+000805 Techno-Holon Corporation
+000806 Raonet Systems, Inc.
+000807 Access Devices Limited
+000808 PPT Vision, Inc.
+000809 Systemonic AG
+00080A Espera-Werke GmbH
+00080B Birka BPA Informationssystem AB
+00080C VDA elettronica SrL
+00080D Toshiba
+00080E Motorola, BCS
+00080F Proximion Fiber Optics AB
+000810 Key Technology, Inc.
+000811 VOIX Corporation
+000812 GM-2 Corporation
+000813 Diskbank, Inc.
+000814 TIL Technologies
+000815 CATS Co., Ltd.
+000816 Bluetags A/S
+000817 EmergeCore Networks LLC
+000818 Pixelworks, Inc.
+000819 Banksys
+00081A Sanrad Intelligence Storage Communications (2000) Ltd.
+00081B Windigo Systems
+00081C @pos.com
+00081D Ipsil, Incorporated
+00081E Repeatit AB
+00081F Pou Yuen Tech Corp. Ltd.
+000820 Cisco Systems Inc.
+000821 Cisco Systems Inc.
+000822 InPro Comm
+000823 Texa Corp.
+000824 Promatek Industries Ltd.
+000825 Acme Packet
+000826 Colorado Med Tech
+000827 Pirelli Cables & Systems
+000828 Koei Engineering Ltd.
+000829 Aval Nagasaki Corporation
+00082A Powerwallz Network Security
+00082B Wooksung Electronics, Inc.
+00082C Homag AG
+00082D Indus Teqsite Private Limited
+00082E Multitone Electronics PLC
+00084E DivergeNet, Inc.
+00084F Qualstar Corporation
+000850 Arizona Instrument Corp.
+000851 Canadian Bank Note Company, Ltd.
+000852 Davolink Co. Inc.
+000853 Schleicher GmbH & Co. Relaiswerke KG
+000854 Netronix, Inc.
+000855 NASA-Goddard Space Flight Center
+000856 Gamatronic Electronic Industries Ltd.
+000857 Polaris Networks, Inc.
+000858 Novatechnology Inc.
+000859 ShenZhen Unitone Electronics Co., Ltd.
+00085A IntiGate Inc.
+00085B Hanbit Electronics Co., Ltd.
+00085C Shanghai Dare Technologies Co. Ltd.
+00085D Aastra
+00085E PCO AG
+00085F Picanol N.V.
+000860 LodgeNet Entertainment Corp.
+000861 SoftEnergy Co., Ltd.
+000862 NEC Eluminant Technologies, Inc.
+000863 Entrisphere Inc.
+000864 Fasy S.p.A.
+000865 JASCOM CO., LTD
+000866 DSX Access Systems, Inc.
+000867 Uptime Devices
+000868 PurOptix
+000869 Command-e Technology Co.,Ltd.
+00086A Industrie Technik IPS GmbH
+00086B MIPSYS
+00086C Plasmon LMS
+00086D Missouri FreeNet
+00086E Hyglo AB
+00086F Resources Computer Network Ltd.
+000870 Rasvia Systems, Inc.
+000871 NORTHDATA Co., Ltd.
+000872 Sorenson Technologies, Inc.
+000873 DAP Design B.V.
+000874 Dell Computer Corp.
+000875 Acorp Electronics Corp.
+000876 SDSystem
+000877 Liebert HIROSS S.p.A.
+000878 Benchmark Storage Innovations
+000879 CEM Corporation
+00087A Wipotec GmbH
+00087B RTX Telecom A/S
+00087C Cisco Systems, Inc.
+00087D Cisco Systems Inc.
+00087E Bon Electro-Telecom Inc.
+00087F SPAUN electronic GmbH & Co. KG
+000880 BroadTel Canada Communications inc.
+000881 DIGITAL HANDS CO.,LTD.
+000882 SIGMA CORPORATION
+000883 Hewlett-Packard Company
+000884 Index Braille AB
+000885 EMS Dr. Thomas Wuensche
+000886 Hansung Teliann, Inc.
+000887 Maschinenfabrik Reinhausen GmbH
+000888 OULLIM Information Technology Inc,.
+000889 Echostar Technologies Corp
+00088A Minds@Work
+00088B Tropic Networks Inc.
+00088C Quanta Network Systems Inc.
+00088D Sigma-Links Inc.
+00088E Nihon Computer Co., Ltd.
+00088F ADVANCED DIGITAL TECHNOLOGY
+000890 AVILINKS SA
+000891 Lyan Inc.
+000892 EM Solutions
+000894 InnoVISION Multimedia Ltd.
+000895 DIRC Technologie GmbH & Co.KG
+000896 Printronix, Inc.
+000897 Quake Technologies
+000898 Gigabit Optics Corporation
+000899 Netbind, Inc.
+00089A Alcatel Microelectronics
+00089B ICP Electronics Inc.
+00089C Elecs Industry Co., Ltd.
+00089D UHD-Elektronik
+00089E Beijing Enter-Net co.LTD
+00089F EFM Networks
+0008A0 Stotz Feinmesstechnik GmbH
+0008A1 CNet Technology Inc.
+0008A2 ADI Engineering, Inc.
+0008A3 Cisco Systems
+0008A4 Cisco Systems
+0008A5 Peninsula Systems Inc.
+0008A6 Multiware & Image Co., Ltd.
+0008A7 iLogic Inc.
+0008A8 Systec Co., Ltd.
+0008A9 SangSang Technology, Inc.
+0008AA KARAM
+0008AB EnerLinx.com, Inc.
+0008AD Toyo-Linx Co., Ltd.
+0008AE Packetfront
+0008AF Novatec Corporation
+0008B0 BKtel communications GmbH
+0008B1 ProQuent Systems
+0008B2 SHENZHEN COMPASS TECHNOLOGY DEVELOPMENT CO.,LTD
+0008B3 Fastwel
+0008B4 SYSPOL
+0008B5 TAI GUEN ENTERPRISE CO., LTD
+0008B6 RouteFree, Inc.
+0008B7 HIT Incorporated
+0008B8 E.F. Johnson
+0008B9 KAON MEDIA Co., Ltd.
+0008BA Erskine Systems Ltd
+0008BB NetExcell
+0008BC Ilevo AB
+0008BD TEPG-US
+0008BE XENPAK MSA Group
+0008BF Aptus Elektronik AB
+0008C0 ASA SYSTEMS
+0008C1 Avistar Communications Corporation
+0008C2 Cisco Systems
+0008C3 Contex A/S
+0008C4 Hikari Co.,Ltd.
+0008C5 Liontech Co., Ltd.
+0008C6 Philips Consumer Communications
 0008C7 COMPAQ COMPUTER CORPORATION
+0008C8 Soneticom, Inc.
+0008C9 TechniSat Digital GmbH
+0008CA TwinHan Technology Co.,Ltd
+0008CB Zeta Broadband Inc.
+0008CC Remotec, Inc.
+0008CD With-Net Inc
+0008CF Nippon Koei Power Systems Co., Ltd.
+0008D0 Musashi Engineering Co., LTD.
+0008D1 KAREL INC.
+0008D2 ZOOM Networks Inc.
+0008D3 Hercules Technologies S.A.
+0008D4 IneoQuest Technologies, Inc
+0008D5 Vanguard Managed Solutions
+0008D6 HASSNET Inc.
+0008D7 HOW CORPORATION
+0008D8 Dowkey Microwave
+0008D9 Mitadenshi Co.,LTD
+0008DA SofaWare Technologies Ltd.
+0008DB Corrigent Systems
+0008DC Wiznet
+0008DD Telena Communications, Inc.
+0008DE 3UP Systems
+0008DF Alistel Inc.
+0008E0 ATO Technology Ltd.
+0008E1 Barix AG
+0008E2 Cisco Systems
+0008E3 Cisco Systems
+0008E4 Envenergy Inc
+0008E5 IDK Corporation
+0008E6 Littlefeet
+0008E7 SHI ControlSystems,Ltd.
+0008E8 Excel Master Ltd.
+0008E9 NextGig
+0008EA Motion Control Engineering, Inc
+0008EB ROMWin Co.,Ltd.
+0008EC Zonu, Inc.
+0008ED ST&T Instrument Corp.
+0008EE Logic Product Development
+0008EF DIBAL,S.A.
+0008F0 Next Generation Systems, Inc.
+0008F1 Voltaire
+0008F2 C&S Technology
+0008F3 WANY
+0008F4 Bluetake Technology Co., Ltd.
+0008F5 YESTECHNOLOGY Co.,Ltd.
+0008F6 SUMITOMO ELECTRIC HIGHTECHS.co.,ltd.
+0008F7 Hitachi Ltd, Semiconductor &amp; Integrated Circuits Gr
+0008F8 Guardall Ltd
+0008F9 Padcom, Inc.
+0008FA Karl E.Brinkmann GmbH
+0008FB SonoSite, Inc.
+0008FC Gigaphoton Inc.
+0008FD BlueKorea Co., Ltd.
+0008FE UNIK C&C Co.,Ltd.
+0008FF Trilogy Broadcast (Holdings) Ltd
+000900 TMT
+000901 Shenzhen Shixuntong Information & Technoligy Co
+000902 Redline Communications Inc.
+000903 Panasas, Inc
+000904 MONDIAL electronic
+000905 iTEC Technologies Ltd.
+000906 Esteem Networks
+000907 Chrysalis Development
+000908 VTech Technology Corp.
+000909 Telenor Connect A/S
+00090A SnedFar Technology Co., Ltd.
+00090B MTL  Instruments PLC
+00090C Mayekawa Mfg. Co. Ltd.
+00090D LEADER ELECTRONICS CORP.
+00090E Helix Technology Inc.
+00090F Fortinet Inc.
+000910 Simple Access Inc.
+000911 Cisco Systems
+000912 Cisco Systems
+000914 COMPUTROLS INC.
+000915 CAS Corp.
+000916 Listman Home Technologies, Inc.
+000917 WEM Technology Inc
+000918 SAMSUNG TECHWIN CO.,LTD
+000919 MDS Gateways
+00091A Macat Optics & Electronics Co., Ltd.
+00091B Digital Generation Inc.
+00091C CacheVision, Inc
+00091D Proteam Computer Corporation
+00091E Firstech Technology Corp.
+00091F A&amp;D Co., Ltd.
+000920 EpoX COMPUTER CO.,LTD.
+000921 Planmeca Oy
+000922 Touchless Sensor Technology AG
+000923 Heaman System Co., Ltd
+000924 Telebau GmbH
+000925 VSN Systemen BV
+000926 YODA COMMUNICATIONS, INC.
+000927 TOYOKEIKI CO.,LTD.
+000928 Telecore Inc
+000929 Sanyo Industries (UK) Limited
+00092A MYTECS Co.,Ltd.
+00092B iQstor Networks, Inc.
+00092C Hitpoint Inc.
+00092D High Tech Computer, Corp.
+00092E B&Tech System Inc.
+00092F Akom Technology Corporation
+000930 AeroConcierge Inc.
+000931 Future Internet, Inc.
+000932 Omnilux
+000933 OPTOVALLEY Co. Ltd.
+000934 Dream-Multimedia-Tv GmbH
+000935 Sandvine Incorporated
+000936 Ipetronik GmbH & Co.KG
+000937 Inventec Appliance Corp
+000938 Allot Communications
+000939 ShibaSoku Co.,Ltd.
+00093A Molex Fiber Optics
+00093B HYUNDAI NETWORKS INC.
+00093C Jacques Technologies P/L
+00093D Newisys,Inc.
+00093E C&I Technologies
+00093F Double-Win Enterpirse CO., LTD
+000940 AGFEO GmbH & Co. KG
+000941 Allied Telesis K.K.
+000942 CRESCO, LTD.
+000943 Cisco Systems
+000944 Cisco Systems
+000945 Palmmicro Communications Inc
+000946 Cluster Labs GmbH
+000947 Aztek, Inc.
+000948 Vista Control Systems, Corp.
+000949 Glyph Technologies Inc.
+00094A Homenet Communications
+00094B FillFactory NV
+00094C Communication Weaver Co.,Ltd.
+00094D Braintree Communications Pty Ltd
+00094E BARTECH SYSTEMS INTERNATIONAL, INC
+00094F elmegt GmbH & Co. KG
+000950 Independent Storage Corporation
+000951 Apogee Instruments, Inc
+000952 Auerswald GmbH & Co. KG
+000953 Linkage System Integration Co.Ltd.
+000954 AMiT spol. s. r. o.
+000955 Young Generation International Corp.
+000956 Network Systems Group, Ltd. (NSG)
+000957 Supercaller, Inc.
+000958 INTELNET S.A.
+000959 Sitecsoft
+00095A RACEWOOD TECHNOLOGY
+00095B Netgear, Inc.
+00095C Philips Medical Systems - Cardiac and Monitoring Systems (CM
+00095D Dialogue Technology Corp.
+00095E Masstech Group Inc.
+00095F Telebyte, Inc.
+000960 YOZAN Inc.
+000961 Switchgear and Instrumentation Ltd
+000962 Filetrac AS
+000963 Dominion Lasercom Inc.
+000964 Hi-Techniques
+000966 Thales Navigation
+000967 Tachyon, Inc
+000968 TECHNOVENTURE, INC.
+000969 Meret Optical Communications
+00096A Cloverleaf Communications Inc.
+00096B IBM Corporation
+00096C Imedia Semiconductor Corp.
+00096D Powernet Technologies Corp.
+00096E GIANT ELECTRONICS LTD.
+00096F Beijing Zhongqing Elegant Tech. Corp.,Limited
+000970 Vibration Research Corporation
+000971 Time Management, Inc.
+000972 Securebase,Inc
+000973 Lenten Technology Co., Ltd.
+000974 Innopia Technologies, Inc.
+000975 fSONA Communications Corporation
+000976 Datasoft ISDN Systems GmbH
+000977 Brunner Elektronik AG
+000978 AIJI System Co., Ltd.
+000979 Advanced Television Systems Committee, Inc.
+00097A Louis Design Labs.
+00097B Cisco Systems
+00097C Cisco Systems
+00097D SecWell Networks Oy
+00097E IMI TECHNOLOGY CO., LTD
+00097F Vsecure 2000 LTD.
+000980 Power Zenith Inc.
+000981 Newport Networks
+000982 Loewe Opta GmbH
+000983 Gvision Incorporated
+000984 MyCasa Network Inc.
+000985 Auto Telecom Company
+000986 Metalink LTD.
+000987 NISHI NIPPON ELECTRIC WIRE & CABLE CO.,LTD.
+000988 Nudian Electron Co., Ltd.
+000989 VividLogic Inc.
+00098A EqualLogic Inc
+00098B Entropic Communications, Inc.
+00098C Possio AB
+00098D DCT Ltd (Digital Communication Technologies Ltd)
+00098E ipcas GmbH
+00098F Cetacean Networks
+000990 ACKSYS Communications & systems
+000991 GE Fanuc Automation Manufacturing, Inc.
+000992 InterEpoch Technology,INC.
+000993 Visteon Corporation
+000994 Cronyx Engineering
+000995 Castle Technology Ltd
+000996 RDI
+000997 Nortel Networks
+000998 Capinfo Company Limited
+000999 CP GEORGES RENAULT
+00099A ELMO COMPANY, LIMITED
+00099B Western Telematic Inc.
+00099C Naval Research Laboratory
+00099D Haliplex Communications
+00099E Testech, Inc.
+00099F VIDEX INC.
+0009A0 Microtechno Corporation
+0009A1 Telewise Communications, Inc.
+0009A2 Interface Co., Ltd.
+0009A3 Leadfly Techologies Corp. Ltd.
+0009A4 HARTEC Corporation
+0009A5 HANSUNG ELETRONIC INDUSTRIES DEVELOPMENT CO., LTD
+0009A6 Ignis Optics, Inc.
+0009A7 Bang & Olufsen A/S
+0009A8 Eastmode Pte Ltd
+0009A9 Ikanos Communications
+0009AA Data Comm for Business, Inc.
+0009AB Netcontrol Oy
+0009AC LANVOICE
+0009AD HYUNDAI SYSCOMM, INC.
+0009AE OKANO ELECTRIC CO.,LTD
+0009AF e-generis
+0009B0 Onkyo Corporation
+0009B1 Kanematsu Electronics, Ltd.
+0009B2 L&F Inc.
+0009B3 MCM Systems Ltd
+0009B4 KISAN TELECOM CO., LTD.
+0009B5 3J Tech. Co., Ltd.
+0009B6 Cisco Systems
+0009B7 Cisco Systems
+0009B8 Entise Systems
+0009B9 Action Imaging Solutions
+0009BA MAKU Informationstechik GmbH
+0009BB MathStar, Inc.
+0009BC Digital Safety Technologies Inc.
+0009BD Epygi Technologies, Ltd.
+0009BE Mamiya-OP Co.,Ltd.
+0009BF Nintendo Co.,Ltd.
+0009C0 6WIND
+0009C1 PROCES-DATA A/S
+0009C3 NETAS
+0009C4 Medicore Co., Ltd
+0009C5 KINGENE Technology Corporation
+0009C6 Visionics Corporation
+0009C7 Movistec
+0009C8 SINAGAWA TSUSHIN KEISOU SERVICE
+0009C9 BlueWINC Co., Ltd.
+0009CA iMaxNetworks(Shenzhen)Limited.
+0009CB HBrain
+0009CC Moog GmbH
+0009CD HUDSON SOFT CO.,LTD.
+0009CE SpaceBridge Semiconductor Corp.
+0009CF iAd GmbH
+0009D0 Versatel Networks
+0009D1 SERANOA NETWORKS INC
+0009D2 Mai Logic Inc.
+0009D3 Western DataCom Co., Inc.
+0009D4 Transtech Networks
+0009D5 Signal Communication, Inc.
+0009D6 KNC One GmbH
+0009D7 DC Security Products
+0009D9 Neoscale Systems, Inc
+0009DA Control Module Inc.
+0009DB eSpace
+0009DC Galaxis Technology AG
+0009DD Mavin Technology Inc.
+0009DE Samjin Information & Communications Co., Ltd.
+0009DF Vestel Komunikasyon Sanayi ve Ticaret A.S.
+0009E0 XEMICS S.A.
+0009E1 Gemtek Technology Co., Ltd.
+0009E2 Sinbon Electronics Co., Ltd.
+0009E3 Angel Iglesias S.A.
+0009E4 K Tech Infosystem Inc.
+0009E5 Hottinger Baldwin Messtechnik GmbH
+0009E6 Cyber Switching Inc.
+0009E7 ADC Techonology
+0009E8 Cisco Systems
+0009E9 Cisco Systems
+0009EA YEM Inc.
+0009EB HuMANDATA LTD.
+0009EC Daktronics, Inc.
+0009ED CipherOptics
+0009EE MEIKYO ELECTRIC CO.,LTD
+0009EF Vocera Communications
+0009F0 Shimizu Technology Inc.
+0009F1 Yamaki Electric Corporation
+0009F2 Cohu, Inc., Electronics Division
+0009F3 WELL Communication Corp.
+0009F4 Alcon Laboratories, Inc.
+0009F5 Emerson Network Power Co.,Ltd
+0009F6 Shenzhen Eastern Digital Tech Ltd.
+0009F7 SED, a division of Calian
+0009F8 UNIMO TECHNOLOGY CO., LTD.
+0009F9 ART JAPAN CO., LTD.
+0009FB Philips Medizinsysteme Boeblingen GmbH
+0009FC IPFLEX Inc.
+0009FD Ubinetics Limited
+0009FE Daisy Technologies, Inc.
+0009FF X.net 2000 GmbH
+000A00 Mediatek Corp.
+000A01 SOHOware, Inc.
+000A02 ANNSO CO., LTD.
+000A03 ENDESA SERVICIOS, S.L.
+000A04 3Com Europe Ltd
+000A05 Widax Corp.
+000A06 Teledex LLC
+000A07 WebWayOne Ltd
+000A08 ALPINE ELECTRONICS, INC.
+000A09 TaraCom Integrated Products, Inc.
+000A0A SUNIX Co., Ltd.
+000A0B Sealevel Systems, Inc.
+000A0C Scientific Research Corporation
+000A0D MergeOptics GmbH
+000A0E Invivo Research Inc.
+000A0F Ilryung Telesys, Inc
+000A10 FAST media integrations AG
+000A11 ExPet Technologies, Inc
+000A12 Azylex Technology, Inc
+000A13 Silent Witness
+000A14 TECO a.s.
+000A15 Silicon Data, Inc
+000A16 Lassen Research
+000A17 NESTAR COMMUNICATIONS, INC
+000A18 Vichel Inc.
+000A19 Valere Power, Inc.
+000A1A Imerge Ltd
+000A1B Stream Labs
+000A1C Bridge Information Co., Ltd.
+000A1D Optical Communications Products Inc.
+000A1E Red-M (Communications) Limited
+000A1F ART WARE Telecommunication Co., Ltd.
+000A20 SVA Networks, Inc.
+000A21 Integra Telecom Co. Ltd
+000A22 Amperion Inc
+000A23 Parama Networks Inc
+000A24 Octave Communications
+000A25 CERAGON NETWORKS
+000A26 CEIA S.p.A.
 000A27 Apple Computer, Inc.
-001000 CABLE TELEVISION
+000A28 Motorola
+000A29 Pan Dacom Networking AG
+000A2A QSI Systems Inc.
+000A2B Etherstuff
+000A2C Active Tchnology Corporation
+000A2E MAPLE NETWORKS CO., LTD
+000A2F Artnix Inc.
+000A30 Johnson Controls-ASG
+000A31 HCV Wireless
+000A32 Xsido Corporation
+000A33 Sierra Logic, Inc.
+000A34 Identicard Systems Incorporated
+000A35 Xilinx
+000A36 Synelec Telecom Multimedia
+000A37 Procera Networks, Inc.
+000A38 Netlock Technologies, Inc.
+000A39 LoPA Information Technology
+000A3A J-THREE INTERNATIONAL Holding Co., Ltd.
+000A3B GCT Semiconductor, Inc
+000A3C Enerpoint Ltd.
+000A3D Elo Sistemas Eletronicos S.A.
+000A3E EADS Telecom
+000A3F Data East Corporation
+000A40 Crown Audio
+000A41 Cisco Systems
+000A42 Cisco Systems
+000A43 Chunghwa Telecom Co., Ltd.
+000A44 Avery Dennison Deutschland GmbH
+000A45 Audio-Technica Corp.
+000A46 ARO Controls SAS
+000A47 Allied Vision Technologies
+000A48 Albatron Technology
+000A49 Acopia Networks
+000A4A Targa Systems Ltd.
+000A4B DataPower Technology, Inc.
+000A4C Molecular Devices Corporation
+000A4D Noritz Corporation
+000A4E UNITEK Electronics INC.
+000A4F Brain Boxes Limited
+000A50 REMOTEK CORPORATION
+000A51 GyroSignal Technology Co., Ltd.
+000A52 Venitek Co. Ltd.
+000A53 Intronics, Incorporated
+000A54 Laguna Hills, Inc.
+000A55 MARKEM Corporation
+000A56 HITACHI Maxell Ltd.
+000A57 Hewlett-Packard Company - Standards
+000A58 Ingenieur-Buero Freyer & Siegel
+000A59 HW server
+000A5A GreenNET Technologies Co.,Ltd.
+000A5B Power-One as
+000A5C Carel s.p.a.
+000A5D PUC Founder (MSC) Berhad
+000A5E 3COM Corporation
+000A5F almedio inc.
+000A60 Autostar Technology Pte Ltd
+000A61 Cellinx Systems Inc.
+000A62 Crinis Networks, Inc.
+000A63 DHD GmbH
+000A64 Eracom Technologies
+000A65 GentechMedia.co.,ltd.
+000A66 MITSUBISHI ELECTRIC SYSTEM & SERVICE CO.,LTD.
+000A67 OngCorp
+000A68 SolarFlare Communications, Inc.
+000A69 SUNNY bell Technology Co., Ltd.
+000A6A SVM Microwaves s.r.o.
+000A6B Tadiran Telecom Business Systems LTD
+000A6C Walchem Corporation
+000A6D EKS Elektronikservice GmbH
+000A6E Broadcast Technology Limited
+000A6F ZyTera Technologies Inc.
+000A70 MPLS Forum
+000A71 Avrio Technologies, Inc
+000A72 SimpleTech, Inc.
+000A73 Scientific Atlanta
+000A74 Manticom Networks Inc.
+000A75 Cat Electronics
+000A76 Beida Jade Bird Huaguang Technology Co.,Ltd
+000A77 Bluewire Technologies LLC
+000A78 OLITEC
+000A79 corega K.K.
+000A7A Kyoritsu Electric Co., Ltd.
+000A7B Cornelius Consult
+000A7C Tecton Ltd
+000A7D Valo, Inc.
+000A7E The Advantage Group
+000A7F Teradon Industries, Inc
+000A80 Telkonet Inc.
+000A81 TEIMA Audiotex S.L.
+000A82 TATSUTA SYSTEM ELECTRONICS CO.,LTD.
+000A83 SALTO SYSTEMS S.L.
+000A84 Rainsun Enterprise Co., Ltd.
+000A85 PLAT'C2,Inc
+000A86 Lenze
+000A87 Integrated Micromachines Inc.
+000A88 InCypher S.A.
+000A89 Creval Systems, Inc.
+000A8A Cisco Systems
+000A8B Cisco Systems
+000A8C Guardware Systems Ltd.
+000A8D EUROTHERM LIMITED
+000A8E Invacom Ltd
+000A8F Aska International Inc.
+000A90 Bayside Interactive, Inc.
+000A91 HemoCue AB
+000A92 Presonus Corporation
+000A93 W2 Networks, Inc.
+000A94 ShangHai cellink CO., LTD
+000A95 Apple Computer, Inc.
+000A96 MEWTEL TECHNOLOGY INC.
+000A97 SONICblue, Inc.
+000A98 M+F Gwinner GmbH & Co
+000A99 Dataradio Inc.
+000A9A Aiptek International Inc
+000A9B Towa Meccs Corporation
+000A9C Server Technology, Inc.
+000A9D King Young Technology Co. Ltd.
+000A9E BroadWeb Corportation
+000A9F Pannaway Technologies, Inc.
+000AA0 Cedar Point Communications
+000AA1 V V S Limited
+000AA2 SYSTEK INC.
+000AA3 SHIMAFUJI ELECTRIC CO.,LTD.
+000AA4 SHANGHAI SURVEILLANCE TECHNOLOGY CO,LTD
+000AA5 MAXLINK INDUSTRIES LIMITED
+000AA6 Hochiki Corporation
+000AA7 FEI Company
+000AA8 ePipe Pty. Ltd.
+000AA9 Brooks Automation GmbH
+000AAA AltiGen Communications Inc.
+000AAB TOYOTA MACS, INC.
+000AAC TerraTec Electronic GmbH
+000AAD Stargames Corporation
+000AAE Rosemount Process Analytical
+000AAF Pipal Systems
+000AB0 LOYTEC electronics GmbH
+000AB1 GENETEC Corporation
+000AB2 Fresnel Wireless Systems
+000AB3 Fa. GIRA
+000AB4 ETIC Telecommunications
+000AB5 Digital Electronic Network
+000AB6 COMPUNETIX, INC
+000AB7 Cisco Systems
+000AB8 Cisco Systems
+000AB9 Astera Technologies Corp.
+000ABA Arcon Technology Limited
+000ABB Taiwan Secom Co,. Ltd
+000ABC Seabridge Ltd.
+000ABD Rupprecht & Patashnick Co.
+000ABE OPNET Technologies CO., LTD.
+000ABF HIROTA SS
+000AC0 Fuyoh Video Industry CO., LTD.
+000AC1 Futuretel
+000AC2 FiberHome Telecommunication Technologies CO.,LTD
+000AC3 eM Technics Co., Ltd.
+000AC4 Daewoo Teletech Co., Ltd
+000AC5 Color Kinetics
+000AC7 Unication Group
+000AC8 ZPSYS CO.,LTD. (Planning&Management)
+000AC9 Zambeel Inc
+000ACA YOKOYAMA SHOKAI CO.,Ltd.
+000ACB XPAK MSA Group
+000ACC Winnow Networks, Inc.
+000ACD Sunrich Technology Limited
+000ACE RADIANTECH, INC.
+000ACF PROVIDEO Multimedia Co. Ltd.
+000AD0 Niigata Develoment Center,  F.I.T. Co., Ltd.
+000AD1 MWS
+000AD2 JEPICO Corporation
+000AD3 INITECH Co., Ltd
+000AD4 CoreBell Systems Inc.
+000AD5 Brainchild Electronic Co., Ltd.
+000AD6 BeamReach Networks
+000AD8 IPCserv Technology Corp.
+000AD9 Sony Ericsson Mobile Communications AB
+000ADB SkyPilot Network, Inc
+000ADC RuggedCom Inc.
+000ADD InSciTek Microsystems, Inc.
+000ADE Happy Communication Co., Ltd.
+000ADF Gennum Corporation
+000AE0 Fujitsu Softek
+000AE1 EG Technology
+000AE2 Binatone Electronics International, Ltd
+000AE3 YANG MEI TECHNOLOGY CO., LTD
+000AE4 Wistron Corp.
+000AE5 ScottCare Corporation
+000AE6 Elitegroup Computer System Co. (ECS)
+000AE7 ELIOP S.A.
+000AE8 Cathay Roxus Information Technology Co. LTD
+000AE9 AirVast Technology Inc.
+000AEA ADAM ELEKTRONIK LTD.STI.
+000AEB Shenzhen Tp-link Technology Co; Ltd.
+000AEC Koatsu Gas Kogyo Co., Ltd.
+000AED HARTING Vending G.m.b.H. & CO KG
+000AEE GCD Hard- & Software GmbH
+000AEF OTRUM ASA
+000AF0 SHIN-OH ELECTRONICS CO., LTD. R&D
+000AF1 Clarity Design, Inc.
+000AF2 NeoAxiom Corp.
+000AF3 Cisco Systems
+000AF4 Cisco Systems
+000AF5 Airgo Networks, Inc.
+000AF6 Computer Process Controls
+000AF7 Broadcom Corp.
+000AF8 American Telecare Inc.
+000AFA Traverse Technologies Australia
+000AFB Ambri Limited
+000AFC Core Tec Communications, LLC
+000AFD Viking Electronic Services
+000AFE NovaPal Ltd
+000AFF Kilchherr Elektronik AG
+000B00 FUJIAN START COMPUTER EQUIPMENT CO.,LTD
+000B01 DAIICHI ELECTRONICS CO., LTD.
+000B02 Dallmeier electronic
+000B03 Taekwang Industrial Co., Ltd
+000B04 Volktek Corporation
+000B05 Pacific Broadband Networks
+000B06 Motorola BCS
+000B07 Voxpath Networks
+000B08 Pillar Data Systems
+000B09 Ifoundry Systems Singapore
+000B0A dBm Optics
+000B0B Corrent Corporation
+000B0C Agile Systems Inc.
+000B0D Air2U, Inc.
+000B0E Trapeze Networks
+000B0F Nyquist Industrial Control BV
+000B10 11wave Technonlogy Co.,Ltd
+000B11 HIMEJI ABC TRADING CO.,LTD.
+000B13 ZETRON INC
+000B14 ViewSonic Corporation
+000B15 Platypus Technology
+000B16 Communication Machinery Corporation
+000B17 MKS Instruments
+000B19 Vernier Networks, Inc.
+000B1A Teltone Corporation
+000B1B Systronix, Inc.
+000B1D LayerZero Power Systems, Inc.
+000B1E KAPPA opto-electronics GmbH
+000B1F I CON Computer Co.
+000B20 Hirata corporation
+000B21 G-Star Communications Inc.
+000B22 Environmental Systems and Services
+000B23 Efficient Networks, Inc.
+000B24 AirLogic
+000B25 Aeluros
+000B26 Wetek Corporation
+000B27 Scion Corporation
+000B28 Quatech Inc.
+000B29 LG Industrial Systems Co.,Ltd.
+000B2A HOWTEL Co., Ltd.
+000B2B HOSTNET CORPORATION
+000B2C Eiki Industrial Co. Ltd.
+000B2D Danfoss Inc.
+000B2E Cal-Comp Electronics (Thailand) Public Company Limited Taipe
+000B2F bplan GmbH
+000B30 Beijing Gongye Science & Technology Co.,Ltd
+000B31 Yantai ZhiYang Scientific and technology industry CO., LTD
+000B32 VORMETRIC, INC.
+000B33 Vivato
+000B34 ShangHai Broadband Technologies CO.LTD
+000B35 Quad Bit System co., Ltd.
+000B36 Productivity Systems, Inc.
+000B37 MANUFACTURE DES MONTRES ROLEX SA
+000B38 Knuerr AG
+000B39 Keisoku Giken Co.,Ltd.
+000B3A Fortel DTV, Inc.
+000B3B devolo AG
+000B3C Cygnal Integrated Products, Inc.
+000B3D CONTAL OK Ltd.
+000B3E BittWare, Inc
+000B3F Anthology Solutions Inc.
+000B40 OpNext Inc.
+000B41 Ing. Buero Dr. Beutlhauser
+000B42 commax Co., Ltd.
+000B43 Microscan Systems, Inc.
+000B44 Concord IDea Corp.
+000B45 Cisco
+000B46 Cisco
+000B47 Advanced Energy
+000B48 sofrel
+000B49 RF-Link System Inc.
+000B4A Visimetrics (UK) Ltd
+000B4B VISIOWAVE SA
+000B4C Clarion (M) Sdn Bhd
+000B4D Emuzed
+000B4E VertexRSI Antenna Products Division
+000B4F Verifone, INC.
+000B50 Oxygnet
+000B51 Micetek International Inc.
+000B52 JOYMAX ELECTRONICS CORP.
+000B53 INITIUM Co., Ltd.
+000B54 BiTMICRO Networks, Inc.
+000B55 ADInstruments
+000B56 Cybernetics
+000B57 Silicon Laboratories
+000B58 Astronautics C.A  LTD
+000B59 ScriptPro, LLC
+000B5A HyperEdge
+000B5B Rincon Research Corporation
+000B5C Newtech Co.,Ltd
+000B5D FUJITSU LIMITED
+000B5E ATMAVA Ltd
+000B5F Cisco Systems
+000B60 Cisco Systems
+000B61 Friedrich Ltze GmbH &Co.
+000B62 Ingenieurbro Ingo Mohnen
+000B64 Kieback & Peter GmbH & Co KG
+000B65 Sy.A.C. srl
+000B66 Teralink Communications
+000B67 Topview Technology Corporation
+000B68 Addvalue Communications Pte Ltd
+000B69 Franke Finland Oy
+000B6A Asiarock Incorporation
+000B6B Wistron Neweb Corp.
+000B6C Sychip Inc.
+000B6D SOLECTRON JAPAN NAKANIIDA
+000B6E Neff Instrument Corp.
+000B6F Media Streaming Networks Inc
+000B70 Load Technology, Inc.
+000B71 Litchfield Communications Inc.
+000B72 Lawo AG
+000B73 Kodeos Communications
+000B74 Kingwave Technology Co., Ltd.
+000B75 Iosoft Ltd.
+000B76 ET&T Co. Ltd.
+000B77 Cogent Systems, Inc.
+000B78 TAIFATECH INC.
+000B79 X-COM, Inc.
+000B7B Test-Um Inc.
+000B7C Telex Communications
+000B7D SOLOMON EXTREME INTERNATIONAL LTD.
+000B7E SAGINOMIYA Seisakusho Inc.
+000B7F OmniWerks
+000B81 Kaparel Corporation
+000B82 Grandstream Networks, Inc.
+000B83 DATAWATT B.V.
+000B84 BODET
+000B85 Airespace, Inc.
+000B86 Aruba Networks
+000B87 American Reliance Inc.
+000B88 Vidisco ltd.
+000B89 Top Global Technology, Ltd.
+000B8A MITEQ Inc.
+000B8B KERAJET, S.A.
+000B8C flextronics israel
+000B8D Avvio Networks
+000B8E Ascent Corporation
+000B8F AKITA ELECTRONICS SYSTEMS CO.,LTD.
+000B90 Covaro Networks, Inc.
+000B91 Aglaia Gesellschaft fr Bildverarbeitung und Kommunikation m
+000B92 Ascom Danmark A/S
+000B93 Barmag Electronic
+000B94 Digital Monitoring Products, Inc.
+000B95 eBet Gaming Systems Pty Ltd
+000B96 Innotrac Diagnostics Oy
+000B97 Matsushita Electric Industrial Co.,Ltd.
+000B98 NiceTechVision
+000B99 SensAble Technologies, Inc.
+000B9A Shanghai Ulink Telecom Equipment Co. Ltd.
+000B9B Sirius System Co, Ltd.
+000B9C TriBeam Technologies, Inc.
+000B9D TwinMOS Technologies Inc.
+000B9E Yasing Technology Corp.
+000B9F Neue ELSA GmbH
+000BA0 T&L Information Inc.
+000BA1 SYSCOM Ltd.
+000BA2 Sumitomo Electric Networks, Inc
+000BA3 Siemens AG, I&S
+000BA4 Shiron Satellite Communications Ltd. (1996)
+000BA5 Quasar Cipta Mandiri, PT
+000BA6 Miyakawa Electric Works Ltd.
+000BA7 Maranti Networks
+000BA8 HANBACK ELECTRONICS CO., LTD.
+000BAA Aiphone co.,Ltd
+000BAB Advantech Technology (CHINA) Co., Ltd.
+000BAC 3Com Europe Ltd.
+000BAD PC-PoS Inc.
+000BAE Vitals System Inc.
+000BB0 Sysnet Telematica srl
+000BB1 Super Star Technology Co., Ltd.
+000BB2 SMALLBIG TECHNOLOGY
+000BB3 RiT technologies Ltd.
+000BB4 RDC Semiconductor Inc.,
+000BB5 nStor Technologies, Inc.
+000BB6 Mototech Inc.
+000BB7 Micro Systems Co.,Ltd.
+000BB8 Kihoku Electronic Co.
+000BB9 Imsys AB
+000BBA Harmonic Broadband Access Networks
+000BBB Etin Systems Co., Ltd
+000BBC En Garde Systems, Inc.
+000BBD Connexionz Limited
+000BBE Cisco Systems
+000BBF Cisco Systems
+000BC0 China IWNComm Co., Ltd.
+000BC1 Bay Microsystems, Inc.
+000BC2 Corinex Communication Corp.
+000BC3 Multiplex, Inc.
+000BC4 BIOTRONIK GmbH & Co
+000BC5 SMC Networks, Inc.
+000BC6 ISAC, Inc.
+000BC7 ICET S.p.A.
+000BC8 AirFlow Networks
+000BC9 Electroline Equipment
+000BCA DATAVAN International Corporation
+000BCB Fagor Automation , S. Coop
+000BCC JUSAN, S.A.
+000BCD Compaq (HP)
+000BCE Free2move AB
+000BCF AGFA NDT INC.
+000BD0 XiMeta Technology Americas Inc.
+000BD1 Aeronix, Inc.
+000BD2 Remopro Technology Inc.
+000BD3 cd3o
+000BD4 Beijing Wise Technology & Science Development Co.Ltd
+000BD5 Nvergence, Inc.
+000BD6 Paxton Access Ltd
+000BD7 MBB Gelma GmbH
+000BD8 Industrial Scientific Corp.
+000BD9 General Hydrogen
+000BDA EyeCross Co.,Inc.
+000BDB Dell ESG PCBA Test
+000BDC AKCP
+000BDD TOHOKU RICOH Co., LTD.
+000BDF Shenzhen RouterD Networks Limited
+000BE0 SercoNet Ltd.
+000BE2 Lumenera Corporation
+000BE3 Key Stream Co., Ltd.
+000BE4 Hosiden Corporation
+000BE5 HIMS Korea Co., Ltd.
+000BE6 Datel Electronics
+000BE7 COMFLUX TECHNOLOGY INC.
+000BE8 AOIP
+000BEA Zultys Technologies
+000BEB Systegra AG
+000BEC NIPPON ELECTRIC INSTRUMENT, INC.
+000BED ELM Inc.
+000BEE inc.jet, Incorporated
+000BEF Code Corporation
+000BF0 MoTEX Products Co., Ltd.
+000BF1 LAP Laser Applikations
+000BF2 Chih-Kan Technology Co., Ltd.
+000BF3 BAE SYSTEMS
+000BF5 Shanghai Sibo Telecom Technology Co.,Ltd
+000BF6 Nitgen Co., Ltd
+000BF7 NIDEK CO.,LTD
+000BF8 Infinera
+000BF9 Gemstone communications, Inc.
+000BFB D-NET International Corporation
+000BFC Cisco Systems
+000BFD Cisco Systems
+000BFE CASTEL Broadband Limited
+000BFF Berkeley Camera Engineering
+000C00 BEB Industrie-Elektronik AG
+000C01 Abatron AG
+000C02 ABB Oy
+000C03 HDMI Licensing, LLC
+000C04 Tecnova
+000C05 RPA Reserch Co., Ltd.
+000C06 Nixvue Systems  Pte Ltd
+000C07 Iftest AG
+000C08 HUMEX Technologies Corp.
+000C09 Hitachi IE Systems Co., Ltd
+000C0A Guangdong Province Electronic Technology Research Institute
+000C0B Broadbus Technologies
+000C0C APPRO TECHNOLOGY INC.
+000C0D Communications & Power Industries / Satcom Division
+000C0E XtremeSpectrum, Inc.
+000C0F Techno-One Co., Ltd
+000C10 PNI Corporation
+000C11 NIPPON DEMPA CO.,LTD.
+000C12 Micro-Optronic-Messtechnik GmbH
+000C13 MediaQ
+000C14 Diagnostic Instruments, Inc.
+000C15 CyberPower Systems, Inc.
+000C16 Concorde Microsystems Inc.
+000C17 AJA Video Systems Inc
+000C18 Zenisu Keisoku Inc.
+000C19 Telio Communications GmbH
+000C1A Quest Technical Solutions Inc.
+000C1B ORACOM Co, Ltd.
+000C1C MicroWeb Co., Ltd.
+000C1D Mettler & Fuchs AG
+000C1E Global Cache
+000C1F Glimmerglass Networks
+000C20 Fi WIn, Inc.
+000C21 Faculty of Science and Technology, Keio University
+000C22 Double D Electronics Ltd
+000C23 Beijing Lanchuan Tech. Co., Ltd.
+000C25 Allied Telesyn Networks
+000C26 Weintek Labs. Inc.
+000C27 Sammy Corporation
+000C28 RIFATRON
+000C29 VMware, Inc.
+000C2A OCTTEL Communication Co., Ltd.
+000C2B ELIAS Technology, Inc.
+000C2C Enwiser Inc.
+000C2D FullWave Technology Co., Ltd.
+000C2E Openet information technology(shenzhen) Co., Ltd.
+000C2F SeorimTechnology Co.,Ltd.
+000C30 Cisco
+000C31 Cisco
+000C32 Avionic Design Development GmbH
+000C33 Compucase Enterprise Co. Ltd.
+000C34 Vixen Co., Ltd.
+000C35 KaVo Dental GmbH & Co. KG
+000C36 SHARP TAKAYA ELECTRONICS INDUSTRY CO.,LTD.
+000C37 Geomation, Inc.
+000C38 TelcoBridges Inc.
+000C39 Sentinel Wireless Inc.
+000C3A Oxance
+000C3B Orion Electric Co., Ltd.
+000C3C MediaChorus, Inc.
+000C3D Glsystech Co., Ltd.
+000C3E Crest Audio
+000C3F Cogent Defence & Security Networks,
+000C40 Altech Controls
+000C41 The Linksys Group, Inc.
+000C42 Routerboard.com
+000C43 Ralink Technology, Corp.
+000C44 Automated Interfaces, Inc.
+000C45 Animation Technologies Inc.
+000C46 Allied Telesyn Inc.
+000C47 SK Teletech(R&D Planning Team)
+000C48 QoStek Corporation
+000C49 Dangaard Telecom RTC Division A/S
+000C4A Cygnus Microsystems Private Limited
+000C4B Cheops Elektronik
+000C4C Arcor AG&Co.
+000C4D ACRA CONTROL
+000C4E Winbest Technology CO,LT
+000C4F UDTech Japan Corporation
+000C50 Seagate Technology
+000C51 Scientific Technologies Inc.
+000C52 Roll Systems Inc.
+000C54 Pedestal Networks, Inc
+000C55 Microlink Communications Inc.
+000C56 Megatel Computer (1986) Corp.
+000C57 MACKIE Engineering Services Belgium BVBA
+000C58 M&S Systems
+000C59 Indyme Electronics, Inc.
+000C5A IBSmm Industrieelektronik Multimedia
+000C5B HANWANG TECHNOLOGY CO.,LTD
+000C5C GTN Systems B.V.
+000C5D CHIC TECHNOLOGY (CHINA) CORP.
+000C5F Avtec, Inc.
+000C60 ACM Systems
+000C61 AC Tech corporation DBA Advanced Digital
+000C62 ABB Automation Technology Products AB, Control
+000C63 Zenith Electronics Corporation
+000C64 X2 MSA Group
+000C65 Sunin Telecom
+000C66 Pronto Networks Inc
+000C67 OYO ELECTRIC CO.,LTD
+000C68 Oasis Semiconductor, Inc.
+000C69 National Radio Astronomy Observatory
+000C6A MBARI
+000C6B Kurz Industrie-Elektronik GmbH
+000C6C Elgato Systems LLC
+000C6D BOC Edwards
+000C6E ASUSTEK COMPUTER INC.
+000C6F Amtek system co.,LTD.
+000C70 ACC GmbH
+000C71 Wybron, Inc
+000C72 Tempearl Industrial Co., Ltd.
+000C73 TELSON ELECTRONICS CO., LTD
+000C74 RIVERTEC CORPORATION
+000C75 Oriental integrated electronics. LTD
+000C76 MICRO-STAR INTERNATIONAL CO., LTD.
+000C77 Life Racing Ltd
+000C78 In-Tech Electronics Limited
+000C79 Extel Communications P/L
+000C7A DaTARIUS Technologies GmbH
+000C7B ALPHA PROJECT Co.,Ltd.
+000C7C Internet Information Image Inc.
+000C7D TEIKOKU ELECTRIC MFG. CO., LTD
+000C7E Tellium Incorporated
+000C7F synertronixx GmbH
+000C80 Opelcomm Inc.
+000C81 Nulec Industries Pty Ltd
+000C82 NETWORK TECHNOLOGIES INC
+000C83 Logical Solutions
+000C84 Eazix, Inc.
+000C85 Cisco Systems
+000C86 Cisco Systems
+000C87 ATI
+000C88 Apache Micro Peripherals, Inc.
+000C89 AC Electric Vehicles, Ltd.
+000C8A Bose Corporation
+000C8B Connect Tech Inc
+000C8C KODICOM CO.,LTD.
+000C8D MATRIX VISION GmbH
+000C8E Mentor Engineering Inc
+000C8F Nergal s.r.l.
+000C90 Octasic Inc.
+000C91 Riverhead Networks Inc.
+000C92 WolfVision Gmbh
+000C93 Xeline Co., Ltd.
+000C94 United Electronic Industries, Inc.
+000C95 PrimeNet
+000C96 OQO, Inc.
+000C97 NV ADB TTV Technologies SA
+000C98 LETEK Communications Inc.
+000C99 HITEL LINK Co.,Ltd
+000C9A Hitech Electronics Corp.
+000C9B EE Solutions, Inc
+000C9C Chongho information & communications
+000C9D AirWalk Communications, Inc.
+000C9E MemoryLink Corp.
+000C9F NKE Corporation
+000CA0 StorCase Technology, Inc.
+000CA1 SIGMACOM Co., LTD.
+000CA2 Scopus Network Technologies Ltd
+000CA3 Rancho Technology, Inc.
+000CA4 Prompttec Product Management GmbH
+000CA6 Mintera Corporation
+000CA7 Metro (Suzhou) Technologies Co., Ltd.
+000CA8 Garuda Networks Corporation
+000CA9 Ebtron Inc.
+000CAA Cubic Transportation Systems Inc
+000CAB COMMEND International
+000CAC Citizen Watch Co., Ltd.
+000CAD BTU International
+000CAE Ailocom Oy
+000CAF TRI TERM CO.,LTD.
+000CB0 Star Semiconductor Corporation
+000CB1 Salland Engineering (Europe) BV
+000CB2 safei Co., Ltd.
+000CB3 ROUND Co.,Ltd.
+000CB4 Propagate Networks, Inc
+000CB5 Premier Technolgies, Inc
+000CB6 NANJING SEU MOBILE & INTERNET TECHNOLOGY CO.,LTD
+000CB7 Nanjing Huazhuo Electronics Co., Ltd.
+000CB8 MEDION AG
+000CB9 LEA
+000CBA Jamex
+000CBB ISKRAEMECO
+000CBC Iscutum
+000CBD Interface Masters, Inc
+000CBF Holy Stone Ent. Co., Ltd.
+000CC0 Genera Oy
+000CC1 Cooper Industries Inc.
+000CC3 BeWAN systems
+000CC4 Tiptel AG
+000CC5 Nextlink Co., Ltd.
+000CC6 Ka-Ro electronics GmbH
+000CC7 Intelligent Computer Solutions Inc.
+000CC8 Integrated Digital Systems, Inc.
+000CC9 ILWOO DATA & TECHNOLOGY CO.,LTD
+000CCA Hitachi Global Storage Technologies
+000CCB Design Combus Ltd
+000CCC Bluesoft Ltd.
+000CCD IEC - TC57
+000CCE Cisco Systems
+000CCF Cisco Systems
+000CD0 Symetrix
+000CD1 SFOM Technology Corp.
+000CD2 Schaffner EMV AG
+000CD3 Prettl Elektronik Radeberg GmbH
+000CD4 Positron Public Safety Systems inc.
+000CD5 Passave Inc.
+000CD6 PARTNER TECH
+000CD7 Nallatech Ltd
+000CD8 M. K. Juchheim GmbH & Co
+000CD9 Itcare Co., Ltd
+000CDA FreeHand Systems, Inc.
+000CDB Foundry Networks
+000CDC BECS Technology, Inc
+000CDD AOS Technologies AG
+000CDE ABB STOTZ-KONTAKT GmbH
+000CDF PULNiX America, Inc
+000CE0 Trek Diagnostics Inc.
+000CE1 The Open Group
+000CE2 Rolls-Royce
+000CE3 Option International N.V.
+000CE4 NeuroCom International, Inc.
+000CE5 Motorola BCS
+000CE6 Meru Networks Inc
+000CE7 MediaTek Inc.
+000CE8 GuangZhou AnJuBao Co., Ltd
+000CE9 BLOOMBERG L.P.
+000CEA aphona Kommunikationssysteme
+000CEB CNMP Networks, Inc.
+000CEC Spectracom Corp.
+000CED Real Digital Media
+000CEE Q-Networks
+000CEF Open Networks Engineering Ltd
+000CF0 M & N GmbH
+000CF1 Intel Corporation
+000CF2 GAMESA ELICA
+000CF3 CALL IMAGE SA
+000CF4 AKATSUKI ELECTRIC MFG.CO.,LTD.
+000CF5 InfoExpress
+000CF6 Sitecom Europe BV
+000CF7 Nortel Networks
+000CF8 Nortel Networks
+000CF9 ITT Flygt AB
+000CFA Digital Systems Corp
+000CFB Korea Network Systems
+000CFC S2io Technologies Corp
+000CFE Grand Electronic Co., Ltd
+000CFF MRO-TEK LIMITED
+000D00 Seaway Networks Inc.
+000D01 P&E Microcomputer Systems, Inc.
+000D02 NEC Access Technica,Ltd
+000D03 Matrics, Inc.
+000D04 Foxboro Eckardt Development GmbH
+000D05 cybernet manufacturing inc.
+000D06 Compulogic Limited
+000D07 Calrec Audio Ltd
+000D08 AboveCable, Inc.
+000D09 Yuehua(Zhuhai) Electronic CO. LTD
+000D0A Projectiondesign as
+000D0B Melco Inc.
+000D0C MDI Security Systems
+000D0D ITSupported, LLC
+000D0E Inqnet Systems, Inc.
+000D0F Finlux Ltd
+000D10 Embedtronics Oy
+000D11 DENTSPLY - Gendex
+000D12 AXELL Corporation
+000D13 Wilhelm Rutenbeck GmbH&Co.
+000D14 Vtech Innovation LP dba Advanced American Telephones
+000D15 Voipac s.r.o.
+000D16 UHS Systems Pty Ltd
+000D17 Turbo Networks Co.Ltd
+000D18 Sunitec Enterprise Co., Ltd.
+000D19 ROBE Show lighting
+000D1A Mustek System Inc.
+000D1B Kyoto Electronics Manufacturing Co., Ltd.
+000D1C I2E TELECOM
+000D1D HIGH-TEK HARNESS ENT. CO., LTD.
+000D1E Control Techniques
+000D1F AV Digital
+000D20 ASAHIKASEI TECHNOSYSTEM CO.,LTD.
+000D21 WISCORE Inc.
+000D22 Unitronics
+000D23 Smart Solution, Inc
+000D24 SENTEC E&E CO., LTD.
+000D25 SANDEN CORPORATION
+000D26 Primagraphics Limited
+000D27 MICROPLEX Printware AG
+000D28 Cisco
+000D29 Cisco
+000D2A Scanmatic AS
+000D2B Racal Instruments
+000D2C Patapsco Designs Ltd
+000D2D NCT Deutschland GmbH
+000D2E Matsushita Avionics Systems Corporation
+000D2F AIN Comm.Tech.Co., LTD
+000D30 IceFyre Semiconductor
+000D31 Compellent Technologies, Inc.
+000D32 DispenseSource, Inc.
+000D33 Prediwave Corp.
+000D34 Shell International Exploration and Production, Inc.
+000D35 PAC International Ltd
+000D36 Wu Han Routon Electronic Co., Ltd
+000D37 WIPLUG
+000D38 NISSIN INC.
+000D39 Network Electronics
+000D3A Microsoft Corp.
+000D3B Microelectronics Technology Inc.
+000D3C i.Tech Dynamic Ltd
+000D3E APLUX Communications Ltd.
+000D3F VXI Technology
+000D40 Verint Loronix Video Solutions
+000D41 Siemens AG ICM MP UC RD IT KLF1
+000D42 Newbest Development Limited
+000D43 DRS Tactical Systems Inc.
+000D45 Tottori SANYO Electric Co., Ltd.
+000D46 Eurotherm Drives, Ltd.
+000D47 Collex
+000D48 AEWIN Technologies Co., Ltd.
+000D49 Triton Systems of Delaware, Inc.
+000D4A Steag ETA-Optik
+000D4B Roku, LLC
+000D4C Outline Electronics Ltd.
+000D4D Ninelanes
+000D4E NDR Co.,LTD.
+000D4F Kenwood Corporation
+000D50 Galazar Networks
+000D51 DIVR Systems, Inc.
+000D52 Comart system
+000D53 Beijing 5w Communication Corp.
+000D54 3Com Europe Ltd
+000D55 SANYCOM Technology Co.,Ltd
+000D56 Dell PCBA Test
+000D57 Fujitsu I-Network Systems Limited.
+000D59 Amity Systems, Inc.
+000D5A Tiesse SpA
+000D5B Smart Empire Investments Limited
+000D5C Robert Bosch GmbH, VT-ATMO
+000D5D Raritan Computer, Inc
+000D5E NEC CustomTechnica, Ltd.
+000D5F Minds Inc
+000D60 IBM Corporation
+000D61 Giga-Byte Technology Co., Ltd.
+000D62 Funkwerk Dabendorf GmbH
+000D63 DENT Instruments, Inc.
+000D64 COMAG Handels AG
+000D65 Cisco Systems
+000D66 Cisco Systems
+000D67 BelAir Networks Inc.
+000D68 Vinci Systems, Inc.
+000D69 TMT&D Corporation
+000D6A Redwood Technologies LTD
+000D6B Mita-Teknik A/S
+000D6C M-Audio
+000D6D K-Tech Devices Corp.
+000D6E K-Patents Oy
+000D6F Ember Corporation
+000D70 Datamax Corporation
+000D71 boca systems
+000D72 2Wire, Inc
+000D73 Technical Support, Inc.
+000D74 Sand Network Systems, Inc.
+000D75 Kobian Pte Ltd - Taiwan Branch
+000D76 Hokuto Denshi Co,. Ltd.
+000D77 FalconStor Software
+000D78 Engineering & Security
+000D79 Dynamic Solutions Co,.Ltd.
+000D7A DiGATTO Asia Pacific Pte Ltd
+000D7B Consensys Computers Inc.
+000D7C Codian Ltd
+000D7D Afco Systems
+000D7E Axiowave Networks, Inc.
+000D7F MIDAS  COMMUNICATION TECHNOLOGIES PTE LTD ( Foreign Branch)
+000D80 Online Development Inc
+000D81 Pepperl+Fuchs GmbH
+000D82 PHS srl
+000D83 Sanmina-SCI Hungary  Ltd.
+000D84 Seodu Inchip, Inc.
+000D85 Tapwave, Inc.
+000D86 Huber + Suhner AG
+000D87 Elitegroup Computer System Co. (ECS)
+000D88 D-Link Corporation
+000D89 Bils Technology Inc
+000D8A Winners Electronics Co., Ltd.
+000D8B T&D Corporation
+000D8C Shanghai Wedone Digital Ltd. CO.
+000D8D ProLinx Communication Gateways, Inc.
+000D8E Koden Electronics Co., Ltd.
+000D8F King Tsushin Kogyo Co., LTD.
+000D90 Factum Electronics AB
+000D91 Eclipse (HQ Espana) S.L.
+000D92 Arima Communication Corporation
+000D93 Apple Computer
+000D94 AFAR Communications,Inc
+000D96 Vtera Technology Inc.
+000D97 Tropos Networks, Inc.
+000D98 S.W.A.C. Schmitt-Walter Automation Consult GmbH
+000D99 Orbital Sciences Corp.; Launch Systems Group
+000D9A INFOTEC LTD
+000D9C Elan GmbH & Co KG
+000D9D Hewlett Packard
+000D9E TOKUDEN OHIZUMI SEISAKUSYO Co.,Ltd.
+000D9F RF Micro Devices
+000DA0 NEDAP N.V.
+000DA1 MIRAE ITS Co.,LTD.
+000DA2 Infrant Technologies, Inc.
+000DA3 Emerging Technologies Limited
+000DA4 DOSCH & AMAND SYSTEMS AG
+000DA5 Fabric7 Systems, Inc
+000DA6 Universal Switching Corporation
+000DA8 Teletronics Technology Corporation
+000DA9 T.E.A.M. S.L.
+000DAA S.A.Tehnology co.,Ltd.
+000DAB Parker Hannifin GmbH Electromechanical Division Europe
+000DAC Japan CBM Corporation
+000DAD Dataprobe Inc
+000DAE SAMSUNG HEAVY INDUSTRIES CO., LTD.
+000DAF Plexus Corp (UK) Ltd
+000DB0 Olym-tech Co.,Ltd.
+000DB1 Japan Network Service Co., Ltd.
+000DB2 Ammasso, Inc.
+000DB3 SDO Communication Corperation
+000DB4 NETASQ
+000DB5 GLOBALSAT TECHNOLOGY CORPORATION
+000DB6 Teknovus, Inc.
+000DB7 SANKO ELECTRIC CO,.LTD
+000DB8 SCHILLER AG
+000DB9 PC Engines GmbH
+000DBA Oc Document Technologies GmbH
+000DBB Nippon Dentsu Co.,Ltd.
+000DBC Cisco Systems
+000DBD Cisco Systems
+000DBE Bel Fuse Europe Ltd.,UK
+000DBF TekTone Sound & Signal Mfg., Inc.
+000DC0 Spagat AS
+000DC1 SafeWeb Inc
+000DC3 First Communication, Inc.
+000DC4 Emcore Corporation
+000DC5 EchoStar International Corporation
+000DC6 DigiRose Technology Co., Ltd.
+000DC7 COSMIC ENGINEERING INC.
+000DC8 AirMagnet, Inc
+000DC9 THALES Elektronik Systeme GmbH
+000DCA Tait Electronics
+000DCB Petcomkorea Co., Ltd.
+000DCC NEOSMART Corp.
+000DCD GROUPE TXCOM
+000DCE Dynavac Technology Pte Ltd
+000DCF Cidra Corp.
+000DD0 TetraTec Instruments GmbH
+000DD1 Stryker Corporation
+000DD2 Simrad Optronics ASA
+000DD3 SAMWOO Telecommunication Co.,Ltd.
+000DD4 Revivio Inc.
+000DD5 O'RITE TECHNOLOGY CO.,LTD
+000DD7 Bright
+000DD8 BBN
+000DD9 Anton Paar GmbH
+000DDA ALLIED TELESIS K.K.
+000DDB AIRWAVE TECHNOLOGIES INC.
+000DDC VAC
+000DDD PROFLO TELRA ELEKTRONK SANAY VE TCARET A..
+000DDE Joyteck Co., Ltd.
+000DDF Japan Image & Network Inc.
+000DE0 ICPDAS Co.,LTD
+000DE1 Control Products, Inc.
+000DE2 CMZ Sistemi Elettronici
+000DE3 AT Sweden AB
+000DE4 DIGINICS, Inc.
+000DE5 Samsung Thales
+000DE6 YOUNGBO ENGINEERING CO.,LTD
+000DE7 Snap-on OEM Group
+000DE8 Nasaco Electronics Pte. Ltd
+000DE9 Napatech Aps
+000DEA Kingtel Telecommunication Corp.
+000DEB CompXs Limited
+000DEC Cisco Systems
+000DED Cisco Systems
+000DEF Soc. Coop. Bilanciai
+000DF0 QCOM TECHNOLOGY INC.
+000DF1 IONIX INC.
+000DF3 Asmax Solutions
+000DF4 Watertek Co.
+000DF5 Teletronics International Inc.
+000DF6 Technology Thesaurus Corp.
+000DF7 Space Dynamics Lab
+000DF8 ORGA Kartensysteme GmbH
+000DF9 NDS Limited
+000DFA Micro Control Systems Ltd.
+000DFB Komax AG
+000DFC ITFOR Inc. resarch and development
+000DFD Huges Hi-Tech Inc.,
+000DFE Hauppauge Computer Works, Inc.
+000DFF CHENMING MOLD INDUSTRY CORP.
+000E01 ASIP Technologies Inc.
+000E02 Advantech AMT Inc.
+000E03 Aarohi Communications, Inc.
+000E05 WIRELESS MATRIX CORP.
+000E06 Team Simoco Ltd
+000E07 Sony Ericsson Mobile Communications AB
+000E08 Sipura Technology, Inc.
+000E09 Shenzhen Coship Software Co.,LTD.
+000E0B Netac Technology Co., Ltd.
+000E0C Intel Corporation
+000E0D HESCH Schrder GmbH
+000E0E ESA elettronica S.P.A.
+000E0F ERMME
+000E11 BDT Bro- und Datentechnik GmbH & Co. KG
+000E12 Adaptive Micro Systems Inc.
+000E13 Accu-Sort Systems inc.
+000E14 Visionary Solutions, Inc.
+000E15 Tadlys LTD
+000E16 SouthWing
+000E18 MyA Technology
+000E19 LogicaCMG Pty Ltd
+000E1B IAV GmbH
+000E1C Hach Company
+000E1F TCL Networks Equipment Co., Ltd.
+000E20 PalmSource, Inc.
+000E21 MTU Friedrichshafen GmbH
+000E23 Incipient, Inc.
+000E25 Hannae Technology Co., Ltd
+000E26 Gincom Technology Corp.
+000E27 Crere Networks, Inc.
+000E28 Dynamic Ratings P/L
+000E29 Shester Communications Inc
+000E2B Safari Technologies
+000E2C Netcodec co.
+000E2D Hyundai Digital Technology Co.,Ltd.
+000E2E Edimax Technology Co., Ltd.
+000E2F Disetronic Medical Systems AG
+000E30 AERAS Networks, Inc.
+000E31 Olympus BioSystems GmbH
+000E32 Kontron Medical
+000E33 Shuko Electronics Co.,Ltd
+000E34 NexxGenCity
+000E35 Intel Corp
+000E36 HEINESYS, Inc.
+000E37 Harms & Wende GmbH & Co.KG
+000E38 Cisco Systems
+000E39 Cisco Systems
+000E3A Cirrus Logic
+000E3B Hawking Technologies, Inc.
+000E3C TransAct Technoloiges Inc.
+000E3D Televic N.V.
+000E3E Sun Optronics Inc
+000E3F Soronti, Inc.
+000E40 Nortel Networks
+000E41 NIHON MECHATRONICS CO.,LTD.
+000E42 Motic Incoporation Ltd.
+000E43 G-Tek Electronics Sdn. Bhd.
+000E44 Digital 5, Inc.
+000E45 Beijing Newtry Electronic Technology Ltd
+000E46 Niigata Seimitsu Co.,Ltd.
+000E47 NCI System Co.,Ltd.
+000E48 Lipman TransAction Solutions
+000E49 Forsway Scandinavia AB
+000E4A Changchun Huayu WEBPAD Co.,LTD
+000E4B atrium c and i
+000E4C Bermai Inc.
+000E4D Numesa Inc.
+000E4E Waveplus Technology Co., Ltd.
+000E4F Trajet GmbH
+000E50 Thomson Multi Media
+000E51 tecna elettronica srl
+000E52 Optium Corporation
+000E53 AV TECH CORPORATION
+000E54 AlphaCell Wireless Ltd.
+000E55 AUVITRAN
+000E56 4G Systems GmbH
+000E57 Iworld Networking, Inc.
+000E58 Rincon Networks
+000E5A TELEFIELD inc.
+000E5B ParkerVision - Direct2Data
+000E5C Motorola BCS
+000E5D Com-X Networks
+000E5E Beijing Raisecom Science & Technology Development Co.,Ltd
+000E5F activ-net GmbH & Co. KG
+000E60 360SUN Digital Broadband Corporation
+000E61 MICROTROL LIMITED
+000E62 Nortel Networks
+000E63 Lemke Diagnostics GmbH
+000E64 Elphel, Inc
+000E65 TransCore
+000E66 Hitachi Advanced Digital, Inc.
+000E67 Eltis Microelectronics Ltd.
+000E68 E-TOP Network Technology Inc.
+000E69 China Electric Power Research Institute
+000E6A 3COM EUROPE LTD
+000E6B Janitza electronics GmbH
+000E6C Device Drivers Limited
+000E6D Murata Manufacturing Co., Ltd.
+000E6E MICRELEC  ELECTRONICS S.A
+000E6F IRIS Corporation Berhad
+000E70 in2 Networks
+000E71 Gemstar Technology Development Ltd.
+000E72 CTS electronics
+000E73 Tpack A/S
+000E74 Solar Telecom. Tech
+000E75 New York Air Brake Corp.
+000E76 GEMSOC INNOVISION INC.
+000E77 Decru, Inc.
+000E78 Amtelco
+000E79 Ample Communications Inc.
+000E7B Toshiba
+000E7D Electronics Line 3000 Ltd.
+000E7E Comprog Oy
+000E7F Hewlett Packard
+000E81 Instant802 Networks Inc.
+000E82 Commtech Wireless
+000E83 Cisco Systems
+000E84 Cisco Systems
+000E85 Catalyst Enterprises, Inc.
+000E86 Alcatel North America
+000E87 adp Gauselmann GmbH
+000E88 VIDEOTRON CORP.
+000E89 CLEMATIC
+000E8A Avara Technologies Pty. Ltd.
+000E8B Astarte Technology Co, Ltd.
+000E8C Siemens AG A&D ET
+000E8D Systems in Progress Holding GmbH
+000E8E SparkLAN Communications, Inc.
+000E8F Sercomm Corp.
+000E90 PONICO CORP.
+000E92 Millinet Co., Ltd.
+000E93 Milnio 3 Sistemas Electrnicos, Lda.
+000E94 Maas International BV
+000E95 Fujiya Denki Seisakusho Co.,Ltd.
+000E96 Cubic Defense Applications, Inc.
+000E97 Ultracker Technology CO., Inc
+000E98 Vitec CC, INC.
+000E99 Spectrum Digital, Inc
+000E9A BOE TECHNOLOGY GROUP CO.,LTD
+000E9C Pemstar
+000E9D Video Networks Ltd
+000E9E Topfield Co., Ltd
+000E9F TEMIC SDS GmbH
+000EA0 NetKlass Technology Inc.
+000EA1 Formosa Teletek Corporation
+000EA2 CyberGuard Corporation
+000EA3 CNCR-IT CO.,LTD,HangZhou P.R.CHINA
+000EA4 Certance Inc.
+000EA5 BLIP Systems
+000EA6 ASUSTEK COMPUTER INC.
+000EA7 Endace Inc Ltd.
+000EA8 United Technologists Europe Limited
+000EA9 Shanghai Xun Shi Communications Equipment Ltd. Co.
+000EAC MINTRON ENTERPRISE CO., LTD.
+000EAD Metanoia Technologies, Inc.
+000EAE GAWELL TECHNOLOGIES CORP.
+000EAF CASTEL
+000EB0 Solutions Radio BV
+000EB1 Newcotech,Ltd
+000EB2 Micro-Research Finland Oy
+000EB3 LeftHand Networks
+000EB4 GUANGZHOU GAOKE COMMUNICATIONS TECHNOLOGY CO.LTD.
+000EB5 Ecastle Electronics Co., Ltd.
+000EB6 Riverbed Technology, Inc.
+000EB7 Knovative, Inc.
+000EB8 Iiga co.,Ltd
+000EB9 HASHIMOTO Electronics Industry Co.,Ltd.
+000EBA HANMI SEMICONDUCTOR CO., LTD.
+000EBB Everbee Networks
+000EBC Cullmann GmbH
+000EBD Burdick, a Quinton Compny
+000EBE B&B Electronics Manufacturing Co.
+000EC0 Nortel Networks
+000EC1 MYNAH Technologies
+000EC2 Lowrance Electronics, Inc.
+000EC3 Logic Controls, Inc.
+000EC4 Iskra Transmission d.d.
+000EC6 ASIX ELECTRONICS CORP.
+000EC7 Appeal Telecom Co.,Ltd.
+000EC8 Zoran Corporation
+000EC9 YOKO Technology Corp.
+000ECB VineSys Technology
+000ECC Tableau
+000ECD SKOV A/S
+000ECE S.I.T.T.I. S.p.A.
+000ECF PROFIBUS Nutzerorganisation e.V.
+000ED0 Privaris, Inc.
+000ED1 Osaka Micro Computer.
+000ED2 Filtronic plc
+000ED3 Epicenter, Inc.
+000ED4 CRESITT INDUSTRIE
+000ED5 COPAN Systems Inc.
+000ED6 Cisco Systems
+000ED7 Cisco Systems
+000ED8 Aktino, Inc.
+000ED9 Aksys, Ltd.
+000EDA C-TECH UNITED CORP.
+000EDB XiNCOM Corp.
+000EDC Tellion INC.
+000EDD SHURE INCORPORATED
+000EDE REMEC, Inc.
+000EDF PLX Technology
+000EE0 Mcharge
+000EE1 ExtremeSpeed Inc.
+000EE2 Custom Engineering S.p.A.
+000EE3 Chiyu Technology Co.,Ltd
+000EE5 bitWallet, Inc.
+000EE6 Adimos Systems LTD
+000EE7 AAC ELECTRONICS CORP.
+000EE8 zioncom
+000EE9 WayTech Development, Inc.
+000EEA Shadong Luneng Jicheng Electronics,Co.,Ltd
+000EEB Sandmartin(zhong shan)Electronics Co.,Ltd
+000EEC Orban
+000EED Nokia Danmark A/S
+000EEE Muco Industrie BV
+000EF0 Festo AG & Co. KG
+000EF1 EZQUEST INC.
+000EF3 Smarthome
+000EF4 Shenzhen Kasda Digital Technology Co.,Ltd
+000EF5 iPAC Technology Co., Ltd.
+000EF6 E-TEN Information Systems Co., Ltd.
+000EF7 Vulcan Portals Inc
+000EF8 SBC ASI
+000EF9 REA Elektronik GmbH
+000EFA Optoway Technology Incorporation
+000EFB Macey Enterprises
+000EFC JTAG Technologies B.V.
+000EFD FUJI PHOTO OPTICAL CO., LTD.
+000EFE EndRun Technologies LLC
+000EFF Megasolution,Inc.
+000F00 Legra Systems, Inc.
+000F01 DIGITALKS INC
+000F02 Digicube Technology Co., Ltd
+000F03 COM&C CO., LTD
+000F04 cim-usa inc
+000F05 3B SYSTEM INC.
+000F06 Nortel Networks
+000F07 Mangrove Systems, Inc.
+000F08 Indagon Oy
+000F0B Kentima Technologies AB
+000F0C SYNCHRONIC ENGINEERING
+000F0D Hunt Electronic Co., Ltd.
+000F0E WaveSplitter Technologies, Inc.
+000F0F Real ID Technology Co., Ltd.
+000F10 RDM Corporation
+000F11 Prodrive B.V.
+000F12 Panasonic AVC Networks Germany GmbH
+000F13 Nisca corporation
+000F14 Mindray Co., Ltd.
+000F15 Kjaerulff1 A/S
+000F16 JAY HOW TECHNOLOGY CO.,
+000F17 Insta Elektro GmbH
+000F18 Industrial Control Systems
+000F19 Guidant Corporation
+000F1A Gaming Support B.V.
+000F1B Ego Systems Inc.
+000F1C DigitAll World Co., Ltd
+000F1D Cosmo Techs Co., Ltd.
+000F1E Chengdu KT Electric Co.of High & New Technology
+000F1F WW PCBA Test
+000F20 WW Ops
+000F21 Scientific Atlanta, Inc
+000F22 Helius, Inc.
+000F23 Cisco Systems
+000F24 Cisco Systems
+000F25 AimValley B.V.
+000F26 WorldAccxx  LLC
+000F27 TEAL Electronics, Inc.
+000F28 Itronix Corporation
+000F29 Augmentix Corporation
+000F2A Cableware Electronics
+000F2B GREENBELL SYSTEMS
+000F2C Uplogix, Inc.
+001000 CABLE TELEVISION LABORATORIES, INC.
 001001 MCK COMMUNICATIONS
 001002 ACTIA
 001003 IMATRON, INC.
 001004 THE BRANTLEY COILE COMPANY,INC
 001005 UEC COMMERCIAL
-001006 RACAL RECORDERS LTD.
+001006 Thales Contact Solutions Ltd.
 001007 CISCO SYSTEMS, INC.
 001008 VIENNA SYSTEMS CORPORATION
 001009 HORO QUARTZ
@@ -1673,20 +3787,20 @@
 001012 PROCESSOR SYSTEMS (I) PVT LTD
 001013 INDUSTRIAL COMPUTER SOURCE
 001014 CISCO SYSTEMS, INC.
-001015 OOMON INC.
+001015 OOmon Inc.
 001016 T.SQWARE
-001017 MICOS GMBH
+001017 MICOS GmbH
 001018 BROADCOM CORPORATION
-001019 SIRONA DENTAL SYSTEMS
-00101A PICTURETEL CORP.
+001019 SIRONA DENTAL SYSTEMS GmbH & Co. KG
+00101A PictureTel Corp.
 00101B CORNET TECHNOLOGY, INC.
 00101C OHM TECHNOLOGIES INTL, LLC
 00101D WINBOND ELECTRONICS CORP.
-00101E MATSUSHITA ELECTRONIC
+00101E MATSUSHITA ELECTRONIC INSTRUMENTS CORP.
 00101F CISCO SYSTEMS, INC.
 001020 WELCH ALLYN, DATA COLLECTION
 001021 ENCANTO NETWORKS, INC.
-001022 SATCOM MEDIA CORPORATION
+001022 SatCom Media Corporation
 001023 FLOWWISE NETWORKS, INC.
 001024 NAGOYA ELECTRIC WORKS CO., LTD
 001025 GRAYHILL INC.
@@ -1698,18 +3812,18 @@
 00102B UMAX DATA SYSTEMS, INC.
 00102C Lasat Networks A/S
 00102D HITACHI SOFTWARE ENGINEERING
-00102E NETWORK SYSTEMS & TECHNOLOGIES
+00102E NETWORK SYSTEMS & TECHNOLOGIES PVT. LTD.
 00102F CISCO SYSTEMS, INC.
-001030 WI-LAN, INC.
+001030 Wi-LAN, Inc.
 001031 OBJECTIVE COMMUNICATIONS, INC.
 001032 ALTA TECHNOLOGY
 001033 ACCESSLAN COMMUNICATIONS, INC.
-001034 GNP COMPUTERS
-001035 ELITEGROUP COMPUTER
+001034 GNP Computers
+001035 ELITEGROUP COMPUTER SYSTEMS CO., LTD
 001036 INTER-TEL INTEGRATED SYSTEMS
-001037 CYQ'VE TECHNOLOGY CO., LTD.
+001037 CYQ've Technology Co., Ltd.
 001038 MICRO RESEARCH INSTITUTE, INC.
-001039 VECTRON SYSTEMS GMBH
+001039 Vectron Systems AG
 00103A DIAMOND NETWORK TECH
 00103B HIPPI NETWORKING FORUM
 00103C IC ENSEMBLE, INC.
@@ -1718,9 +3832,9 @@
 00103F TOLLGRADE COMMUNICATIONS, INC.
 001040 INTERMEC CORPORATION
 001041 BRISTOL BABCOCK, INC.
-001042 ALACRITECH
+001042 AlacriTech
 001043 A2 CORPORATION
-001044 INNOLABS CORPORATION
+001044 InnoLabs Corporation
 001045 Nortel Networks
 001046 ALCORN MCBRIDE INC.
 001047 ECHO ELETRIC CO. LTD.
@@ -1740,12 +3854,12 @@
 001055 FUJITSU MICROELECTRONICS, INC.
 001056 SODICK CO., LTD.
 001057 Rebel.com, Inc.
-001058 ARROWPOINT COMMUNICATIONS,INC.
+001058 ArrowPoint Communications
 001059 DIABLO RESEARCH CO. LLC
 00105A 3COM CORPORATION
 00105B NET INSIGHT AB
 00105C QUANTUM DESIGNS (H.K.) LTD.
-00105D DRAGER, BUSINESS UNIT
+00105D Draeger Medical
 00105E HEKIMIAN LABORATORIES, INC.
 00105F IN-SNEC
 001060 BILLIONTON SYSTEMS, INC.
@@ -1760,7 +3874,7 @@
 001069 HELIOSS COMMUNICATIONS, INC.
 00106A DIGITAL MICROWAVE CORPORATION
 00106B SONUS NETWORKS, INC.
-00106C INFRATEC PLUS GMBH
+00106C INFRATEC PLUS GmbH
 00106D INTEGRITY COMMUNICATIONS, INC.
 00106E TADIRAN COM. LTD.
 00106F TRENTON TECHNOLOGY INC.
@@ -1770,15 +3884,15 @@
 001073 TECHNOBOX, INC.
 001074 ATEN INTERNATIONAL CO., LTD.
 001075 Maxtor Corporation
-001076 EUREM GMBH
+001076 EUREM GmbH
 001077 SAF DRIVE SYSTEMS, LTD.
 001078 NUERA COMMUNICATIONS, INC.
 001079 CISCO SYSTEMS, INC.
-00107A AMBICOM, INC.
+00107A AmbiCom, Inc.
 00107B CISCO SYSTEMS, INC.
 00107C P-COM, INC.
 00107D AURORA COMMUNICATIONS, LTD.
-00107E BACHMANN ELECTRONIC GMBH
+00107E BACHMANN ELECTRONIC GmbH
 00107F CRESTRON ELECTRONICS, INC.
 001080 METAWAVE COMMUNICATIONS
 001081 DPS, INC.
@@ -1789,23 +3903,23 @@
 001086 ATTO TECHNOLOGY, INC.
 001087 Xstreamis PLC
 001088 AMERICAN NETWORKS INC.
-001089 WEBSONIC
-00108A TERALOGIC, INC.
-00108B LASERANIMATION SOLLINGER GMBH
-00108C FUJITSU TELECOMMUNICATIONS
+001089 WebSonic
+00108A TeraLogic, Inc.
+00108B LASERANIMATION SOLLINGER GmbH
+00108C FUJITSU TELECOMMUNICATIONS EUROPE, LTD.
 00108D JOHNSON CONTROLS, INC.
-00108E HUGH SYMONS CONCEPT
+00108E HUGH SYMONS CONCEPT Technologies Ltd.
 00108F RAPTOR SYSTEMS
 001090 CIMETRICS, INC.
 001091 NO WIRES NEEDED BV
 001092 NETCORE INC.
 001093 CMS COMPUTERS, LTD.
-001094 ADTECH, INC.
-001095 THOMSON CONSUMER ELECTRONICS
+001094 Performance Analysis Broadband, Spirent plc
+001095 Thomson Multimedia, Inc.
 001096 TRACEWELL SYSTEMS, INC.
-001097 WINNET METROPOLITAN
+001097 WinNet Metropolitan Communications Systems, Inc.
 001098 STARNET TECHNOLOGIES, INC.
-001099 INNOMEDIA, INC.
+001099 InnoMedia, Inc.
 00109A NETLINE
 00109B VIXEL CORPORATION
 00109C M-SYSTEM CO., LTD.
@@ -1840,10 +3954,10 @@
 0010B9 MAXTOR CORP.
 0010BA MARTINHO-DAVIS SYSTEMS, INC.
 0010BB DATA & INFORMATION TECHNOLOGY
-0010BC Nortel Networks
-0010BD THE TELECOMMUNICATION
+0010BC Aastra Telecom
+0010BD THE TELECOMMUNICATION TECHNOLOGY COMMITTEE
 0010BE TELEXIS CORP.
-0010BF INTER AIR WIRELESS
+0010BF InterAir Wireless
 0010C0 ARMA, INC.
 0010C1 OI ELECTRIC CO., LTD.
 0010C2 WILLNET, INC.
@@ -1852,11 +3966,11 @@
 0010C5 PROTOCOL TECHNOLOGIES, INC.
 0010C6 USI
 0010C7 DATA TRANSMISSION NETWORK
-0010C8 COMMUNICATIONS ELECTRONICS
-0010C9 MITSUBISHI ELECTRONICS
+0010C8 COMMUNICATIONS ELECTRONICS SECURITY GROUP
+0010C9 MITSUBISHI ELECTRONICS LOGISTIC SUPPORT CO.
 0010CA INTEGRAL ACCESS
 0010CB FACIT K.K.
-0010CC CLP COMPUTER LOGISTIK
+0010CC CLP COMPUTER LOGISTIK PLANUNG GmbH
 0010CD INTERFACE CONCEPT
 0010CE VOLAMP, LTD.
 0010CF FIBERLANE COMMUNICATIONS
@@ -1866,40 +3980,39 @@
 0010D3 GRIPS ELECTRONIC GMBH
 0010D4 STORAGE COMPUTER CORPORATION
 0010D5 IMASDE CANARIAS, S.A.
-0010D6 ITT A/CD
+0010D6 ITT - A/CD
 0010D7 ARGOSY RESEARCH INC.
 0010D8 CALISTA
 0010D9 IBM JAPAN, FUJISAWA MT+D
 0010DA MOTION ENGINEERING, INC.
-0010DB NETSCREEN TECHNOLOGIES, INC.
-0010DC MICRO-STAR INTERNATIONAL
+0010DB NetScreen Technologies, Inc.
+0010DC MICRO-STAR INTERNATIONAL CO., LTD.
 0010DD ENABLE SEMICONDUCTOR, INC.
-0010DE INTERNATIONAL DATACASTING
+0010DE INTERNATIONAL DATACASTING CORPORATION
 0010DF RISE COMPUTER INC.
 0010E0 COBALT MICROSERVER, INC.
 0010E1 S.I. TECH, INC.
-0010E2 ARRAYCOMM, INC.
+0010E2 ArrayComm, Inc.
 0010E3 COMPAQ COMPUTER CORPORATION
 0010E4 NSI CORPORATION
 0010E5 SOLECTRON TEXAS
-0010E6 APPLIED INTELLIGENT
-0010E7 BREEZECOM
+0010E6 APPLIED INTELLIGENT SYSTEMS, INC.
+0010E7 BreezeCom
 0010E8 TELOCITY, INCORPORATED
 0010E9 RAIDTEC LTD.
 0010EA ADEPT TECHNOLOGY
-0010EB SELSIUS SYSTEMS, ILNC.
+0010EB SELSIUS SYSTEMS, INC.
 0010EC RPCG, LLC
 0010ED SUNDANCE TECHNOLOGY, INC.
 0010EE CTI PRODUCTS, INC.
-0010EF DB NETWORKS, INC.
-0010F0 RITTAL-WERK RUDOLF LOH
+0010EF DBTEL INCORPORATED
 0010F1 I-O CORPORATION
 0010F2 ANTEC
-0010F3 NEXCOM INTERNATIONAL CO., LTD.
+0010F3 Nexcom International Co., Ltd.
 0010F4 VERTICAL NETWORKS, INC.
 0010F5 AMHERST SYSTEMS, INC.
 0010F6 CISCO SYSTEMS, INC.
-0010F7 IRIICHI TECHNOLOGIES
+0010F7 IRIICHI TECHNOLOGIES Inc.
 0010F8 KENWOOD TMI CORPORATION
 0010F9 UNIQUE SYSTEMS, INC.
 0010FA ZAYANTE, INC.
@@ -1934,14 +4047,14 @@
 002016 SHOWA ELECTRIC WIRE & CABLE CO
 002017 ORBOTECH
 002018 CIS TECHNOLOGY INC.
-002019 OHLER GMBH
+002019 OHLER GmbH
 00201A N-BASE SWITCH COMMUNICATIONS
 00201B NORTHERN TELECOM/NETWORK
 00201C EXCEL, INC.
 00201D KATANA PRODUCTS
 00201E NETQUEST CORPORATION
 00201F BEST POWER TECHNOLOGY, INC.
-002020 MEGATRON COMPUTER INDUSTRIES
+002020 MEGATRON COMPUTER INDUSTRIES PTY, LTD.
 002021 ALGORITHMS SOFTWARE PVT. LTD.
 002022 TEKNIQUE, INC.
 002023 T.C. TECHNOLOGIES PTY. LTD
@@ -1952,26 +4065,26 @@
 002028 WEST EGG SYSTEMS, INC.
 002029 TELEPROCESSING PRODUCTS, INC.
 00202A N.V. DZINE
-00202B ADVANCED TELECOMMUNICATIONS
+00202B ADVANCED TELECOMMUNICATIONS MODULES, LTD.
 00202C WELLTRONIX CO., LTD.
 00202D TAIYO CORPORATION
 00202E DAYSTAR DIGITAL
 00202F ZETA COMMUNICATIONS, LTD.
 002030 ANALOG & DIGITAL SYSTEMS
-002031 ERTEC GMBH
+002031 ERTEC GmbH
 002032 ALCATEL TAISEL
 002033 SYNAPSE TECHNOLOGIES, INC.
 002034 ROTEC INDUSTRIEAUTOMATION GMBH
 002035 IBM CORPORATION
 002036 BMC SOFTWARE
 002037 SEAGATE TECHNOLOGY
-002038 VME MICROSYSTEMS INTERNATIONAL
+002038 VME MICROSYSTEMS INTERNATIONAL CORPORATION
 002039 SCINETS
 00203A DIGITAL BI0METRICS INC.
 00203B WISDM LTD.
 00203C EUROTIME AB
 00203D NOVAR ELECTRONICS CORPORATION
-00203E LOGICAN TECHNOLOGIES, INC.
+00203E LogiCan Technologies, Inc.
 00203F JUKI CORPORATION
 002040 Motorola Broadband Communications Sector
 002041 DATA NET
@@ -1990,22 +4103,22 @@
 00204E NETWORK SECURITY SYSTEMS, INC.
 00204F DEUTSCHE AEROSPACE AG
 002050 KOREA COMPUTER INC.
-002051 PHOENIX DATA COMMUNUNICATIONS
+002051 Verilink Corporation
 002052 RAGULA SYSTEMS
 002053 HUNTSVILLE MICROSYSTEMS, INC.
 002054 EASTERN RESEARCH, INC.
 002055 ALTECH CO., LTD.
 002056 NEOPRODUCTS
-002057 TITZE DATENTECHNIK GMBH
+002057 TITZE DATENTECHNIK GmbH
 002058 ALLIED SIGNAL INC.
 002059 MIRO COMPUTER PRODUCTS AG
 00205A COMPUTER IDENTICS
 00205B SKYLINE TECHNOLOGY
-00205C INTERNET SYSTEMS/ FLORIDA INC.
+00205C InterNet Systems of Florida, Inc.
 00205D NANOMATIC OY
 00205E CASTLE ROCK, INC.
 00205F GAMMADATA COMPUTER GMBH
-002060 ALCATEL ITALIA S.P.A.
+002060 ALCATEL ITALIA S.p.A.
 002061 DYNATECH COMMUNICATIONS, INC.
 002062 SCORPION LOGIC, LTD.
 002063 WIPRO INFOTECH LTD.
@@ -2015,7 +4128,7 @@
 002068 ISDYNE
 002069 ISDN SYSTEMS CORPORATION
 00206A OSAKA COMPUTER CORP.
-00206B MINOLTA CO., LTD.
+00206B KONICA MINOLTA HOLDINGS, INC.
 00206C EVERGREEN TECHNOLOGY CORP.
 00206D DATA RACE, INC.
 00206E XACT, INC.
@@ -2030,11 +4143,11 @@
 002077 KARDIOS SYSTEMS CORP.
 002078 RUNTOP, INC.
 002079 MIKRON GMBH
-00207A WISE COMMUNICATIONS, INC.
-00207B LEVEL ONE COMMUNICATIONS
-00207C AUTEC GMBH
+00207A WiSE Communications, Inc.
+00207B Intel Corporation
+00207C AUTEC GmbH
 00207D ADVANCED COMPUTER APPLICATIONS
-00207E FINECOM CO., LTD.
+00207E FINECOM Co., Ltd.
 00207F KYOEI SANGYO CO., LTD.
 002080 SYNERGY (UK) LTD.
 002081 TITAN ELECTRONICS
@@ -2052,13 +4165,13 @@
 00208D CMD TECHNOLOGY
 00208E CHEVIN SOFTWARE ENG. LTD.
 00208F ECI TELECOM LTD.
-002090 ADVANCED COMPRESSION
+002090 ADVANCED COMPRESSION TECHNOLOGY, INC.
 002091 J125, NATIONAL SECURITY AGENCY
 002092 CHESS ENGINEERING B.V.
 002093 LANDINGS TECHNOLOGY CORP.
 002094 CUBIX CORPORATION
 002095 RIVA ELECTRONICS
-002096 SIEBE ENVIRONMENTAL CONTROLS
+002096 Invensys
 002097 APPLIED SIGNAL TECHNOLOGY
 002098 HECTRONIC AB
 002099 BON ELECTRIC CO., LTD.
@@ -2066,7 +4179,7 @@
 00209B ERSAT ELECTRONIC GMBH
 00209C PRIMARY ACCESS CORP.
 00209D LIPPERT AUTOMATIONSTECHNIK
-00209E BROWN'S OPERATING SYSTEM
+00209E BROWN'S OPERATING SYSTEM SERVICES, LTD.
 00209F MERCURY COMPUTER SYSTEMS, INC.
 0020A0 OA LABORATORY CO., LTD.
 0020A1 DOVATRON
@@ -2086,7 +4199,7 @@
 0020AF 3COM CORPORATION
 0020B0 GATEWAY DEVICES, INC.
 0020B1 COMTECH RESEARCH INC.
-0020B2 GKD GESELLSCHAFT FUR
+0020B2 GKD Gesellschaft Fur Kommunikation Und Datentechnik
 0020B3 SCLTEC COMMUNICATIONS SYSTEMS
 0020B4 TERMA ELEKTRONIK AS
 0020B5 YASKAWA ELECTRIC CORPORATION
@@ -2123,18 +4236,18 @@
 0020D4 CABLETRON - ZEITTNET INC.
 0020D5 VIPA GMBH
 0020D6 BREEZECOM
-0020D7 JAPAN MINICOMPUTER SYSTEMS CO.
-0020D8 NETWAVE TECHNOLOGIES, INC.
-0020D9 PANASONIC TECHNOLOGIES, INC./
+0020D7 JAPAN MINICOMPUTER SYSTEMS CO., Ltd.
+0020D8 Nortel Networks
+0020D9 PANASONIC TECHNOLOGIES, INC./MIECO-US
 0020DA XYLAN CORPORATION
 0020DB XNET TECHNOLOGY, INC.
 0020DC DENSITRON TAIWAN LTD.
-0020DD AWA LTD.
+0020DD Cybertec Pty Ltd
 0020DE JAPAN DIGITAL LABORAT'Y CO.LTD
 0020DF KYOSAN ELECTRIC MFG. CO., LTD.
 0020E0 PREMAX ELECTRONICS, INC.
 0020E1 ALAMAR ELECTRONICS
-0020E2 INFORMATION RESOURCE
+0020E2 INFORMATION RESOURCE ENGINEERING
 0020E3 MCD KENCOM CORPORATION
 0020E4 HSING TECH ENTERPRISE CO., LTD
 0020E5 APEX DATA, INC.
@@ -2214,7 +4327,7 @@
 00302F Smiths Industries
 003030 HARMONIX CORPORATION
 003031 LIGHTWAVE COMMUNICATIONS, INC.
-003032 MAGICRAM, INC.
+003032 MagicRam, Inc.
 003033 ORIENT TELECOM CO., LTD.
 003036 RMP ELEKTRONIKSYSTEME GMBH
 003037 Packard Bell Nec Services
@@ -2323,7 +4436,7 @@
 00309E WORKBIT CORPORATION.
 00309F AMBER NETWORKS
 0030A0 TYCO SUBMARINE SYSTEMS, LTD.
-0030A1 OPTI TECH CO., LTD.
+0030A1 WEBGATE Inc.
 0030A2 Lightner Engineering
 0030A3 CISCO SYSTEMS, INC.
 0030A4 Woodwind Communications System
@@ -2337,7 +4450,7 @@
 0030AC Systeme Lauer GmbH & Co., Ltd.
 0030AD SHANGHAI COMMUNICATION
 0030AE Times N System, Inc.
-0030AF Honeywell Reqelsysteme GmbH
+0030AF Honeywell GmbH
 0030B0 Convergenet Technologies
 0030B1 GOC GESELLSCHAFT FUR OPTISCHE
 0030B2 WESCAM - HEALDSBURG
@@ -2531,7 +4644,7 @@
 00406F SYNC RESEARCH INC.
 004070 INTERWARE CO., LTD.
 004071 ATM COMPUTER GMBH
-004072 APPLIED INNOVATION, INC.
+004072 Applied Innovation Inc.
 004073 BASS ASSOCIATES
 004074 CABLE AND WIRELESS
 004075 M-TRADE (UK) LTD
@@ -2544,7 +4657,7 @@
 00407C QUME CORPORATION
 00407D EXTENSION TECHNOLOGY CORP.
 00407E EVERGREEN SYSTEMS, INC.
-00407F AGEMA INFRARED SYSTEMS AB
+00407F FLIR Systems
 004080 ATHENIX CORPORATION
 004081 MANNESMANN SCANGRAPHIC GMBH
 004082 LABORATORY EQUIPMENT CORP.
@@ -2673,34 +4786,35 @@
 0040FD LXE
 0040FE SYMPLEX COMMUNICATIONS
 0040FF TELEBIT CORPORATION
+004252 RLX Technologies
 005000 NEXO COMMUNICATIONS, INC.
 005001 YAMASHITA SYSTEMS CORP.
 005002 OMNISEC AG
 005003 GRETAG MACBETH AG
 005004 3COM CORPORATION
 005006 TAC AB
-005007 SIEMENS TELECOMMUNICATION
+005007 SIEMENS TELECOMMUNICATION SYSTEMS LIMITED
 005008 TIVA MICROCOMPUTER CORP. (TMC)
 005009 PHILIPS BROADBAND NETWORKS
 00500A IRIS TECHNOLOGIES, INC.
 00500B CISCO SYSTEMS, INC.
-00500C ETEK LABS, INC.
+00500C e-Tek Labs, Inc.
 00500D SATORI ELECTORIC CO., LTD.
-00500E CHROMATIS NETWORKS,INC.
+00500E CHROMATIS NETWORKS, INC.
 00500F CISCO SYSTEMS, INC.
-005010 NOVANET LEARNING, INC.
+005010 NovaNET Learning, Inc.
 005012 CBL - GMBH
-005013 Chaparral Technologies, Inc.
+005013 Chaparral Network Storage
 005014 CISCO SYSTEMS, INC.
 005015 BRIGHT STAR ENGINEERING
 005016 SST/WOODHEAD INDUSTRIES
 005017 RSR S.R.L.
-005018 ADVANCED MULTIMEDIA INTERNET
+005018 ADVANCED MULTIMEDIA INTERNET TECHNOLOGY INC.
 005019 SPRING TIDE NETWORKS, INC.
 00501A UISIQN
 00501B ABL CANADA, INC.
 00501C JATOM SYSTEMS, INC.
-00501E MIRANDA TECHNOLOGIES, INC.
+00501E Miranda Technologies, Inc.
 00501F MRG SYSTEMS, LTD.
 005020 MEDIASTAR CO., LTD.
 005021 EIS INTERNATIONAL, INC.
@@ -2716,7 +4830,7 @@
 00502C SOYO COMPUTER, INC.
 00502D ACCEL, INC.
 00502E CAMBEX CORPORATION
-00502F TOLLBRIDGE TECHNOLOGIES, INC.
+00502F TollBridge Technologies, Inc.
 005030 FUTURE PLUS SYSTEMS
 005031 AEROFLEX LABORATORIES, INC.
 005032 PICAZO COMMUNICATIONS, INC.
@@ -2732,7 +4846,7 @@
 00503F ANCHOR GAMES
 005040 EMWARE, INC.
 005041 CTX OPTO ELECTRONIC CORP.
-005042 SCI MANUFACTURING
+005042 SCI MANUFACTURING SINGAPORE PTE, LTD.
 005043 MARVELL SEMICONDUCTOR, INC.
 005044 ASACA CORPORATION
 005045 RIOWORKS SOLUTIONS, INC.
@@ -2751,10 +4865,10 @@
 005053 CISCO SYSTEMS, INC.
 005054 CISCO SYSTEMS, INC.
 005055 DOMS A/S
-005056 VMWARE, INC.
+005056 VMWare, Inc.
 005057 BROADBAND ACCESS SYSTEMS
 005058 VEGASTREAM LIMITED
-005059 SUITE TECHNOLOGY SYSTEMS
+005059 SUITE TECHNOLOGY SYSTEMS NETWORK
 00505A NETWORK ALCHEMY, INC.
 00505B KAWASAKI LSI U.S.A., INC.
 00505C TUNDO CORPORATION
@@ -2765,10 +4879,10 @@
 005063 OY COMSEL SYSTEM AB
 005064 CAE ELECTRONICS
 005065 DENSEI-LAMBAD Co., Ltd.
-005066 ATECOM GMBH ADVANCED
+005066 AtecoM GmbH advanced telecomunication modules
 005067 AEROCOMM, INC.
-005068 ELECTRONIC INDUSTRIES
-005069 PIXSTREAM INCORPORATED
+005068 ELECTRONIC INDUSTRIES ASSOCIATION
+005069 PixStream Incorporated
 00506A EDEVA, INC.
 00506B SPX-ATEG
 00506C G & L BEIJER ELECTRONICS AB
@@ -2789,7 +4903,7 @@
 00507C VIDEOCON AG
 00507D IFP
 00507E NEWER TECHNOLOGY
-00507F DRAYTEK CORP.
+00507F DrayTek Corp.
 005080 CISCO SYSTEMS, INC.
 005081 MURATA MACHINERY, LTD.
 005082 FORESSON CORPORATION
@@ -2811,29 +4925,29 @@
 005094 PACE MICRO TECHNOLOGY PLC
 005095 PERACOM NETWORKS
 005096 SALIX TECHNOLOGIES, INC.
-005097 MMC-EMBEDDED
+005097 MMC-EMBEDDED COMPUTERTECHNIK GmbH
 005098 GLOBALOOP, LTD.
 005099 3COM EUROPE, LTD.
 00509A TAG ELECTRONIC SYSTEMS
 00509B SWITCHCORE AB
 00509C BETA RESEARCH
 00509D THE INDUSTREE B.V.
-00509E LES TECHNOLOGIES
+00509E Les Technologies SoftAcoustik Inc.
 00509F HORIZON COMPUTER
 0050A0 DELTA COMPUTER SYSTEMS, INC.
 0050A1 CARLO GAVAZZI, INC.
 0050A2 CISCO SYSTEMS, INC.
-0050A3 TRANSMEDIA COMMUNICATIONS, INC
+0050A3 TransMedia Communications, Inc.
 0050A4 IO TECH, INC.
 0050A5 CAPITOL BUSINESS SYSTEMS, LTD.
 0050A6 OPTRONICS
 0050A7 CISCO SYSTEMS, INC.
-0050A8 OPENCON SYSTEMS, INC.
+0050A8 OpenCon Systems, Inc.
 0050A9 MOLDAT WIRELESS TECHNOLGIES
-0050AA KONICA CORPORATION
+0050AA KONICA MINOLTA HOLDINGS, INC.
 0050AB NALTEC, INC.
 0050AC MAPLE COMPUTER CORPORATION
-0050AD COMMUNIQUE WIRELESS CORP.
+0050AD CommUnique Wireless Corp.
 0050AE IWAKI ELECTRONICS CO., LTD.
 0050AF INTERGON, INC.
 0050B0 TECHNOLOGY ATLANTA CORPORATION
@@ -2857,7 +4971,7 @@
 0050C2 IEEE REGISTRATION AUTHORITY
 0050C4 IMD
 0050C5 ADS TECHNOLOGIES, INC.
-0050C6 LOOP TELECOMMUNICATION
+0050C6 LOOP TELECOMMUNICATION INTERNATIONAL, INC.
 0050C8 ADDONICS COMMUNICATIONS, INC.
 0050C9 MASPRO DENKOH CORP.
 0050CA NET TO NET TECHNOLOGIES
@@ -2865,52 +4979,52 @@
 0050CC XYRATEX
 0050CD DIGIANSWER A/S
 0050CE LG INTERNATIONAL CORP.
-0050CF VANLINK COMMUNICATION
+0050CF VANLINK COMMUNICATION TECHNOLOGY RESEARCH INSTITUTE
 0050D0 MINERVA SYSTEMS
 0050D1 CISCO SYSTEMS, INC.
 0050D2 BAE Systems Canada, Inc.
-0050D3 DIGITAL AUDIO
+0050D3 DIGITAL AUDIO PROCESSING PTY. LTD.
 0050D4 JOOHONG INFORMATION &
 0050D5 AD SYSTEMS CORP.
 0050D6 ATLAS COPCO TOOLS AB
 0050D7 TELSTRAT
 0050D8 UNICORN COMPUTER CORP.
-0050D9 ENGETRON-ENGENHARIA ELETRONICA
+0050D9 ENGETRON-ENGENHARIA ELETRONICA IND. e COM. LTDA
 0050DA 3COM CORPORATION
 0050DB CONTEMPORARY CONTROL
-0050DC TAS TELEFONBAU A. SCHWABE
+0050DC TAS TELEFONBAU A. SCHWABE GMBH & CO. KG
 0050DD SERRA SOLDADURA, S.A.
 0050DE SIGNUM SYSTEMS CORP.
-0050DF AIRFIBER, INC.
+0050DF AirFiber, Inc.
 0050E1 NS TECH ELECTRONICS SDN BHD
 0050E2 CISCO SYSTEMS, INC.
-0050E3 TELEGATE
+0050E3 Terayon Communications Systems
 0050E4 APPLE COMPUTER, INC.
 0050E6 HAKUSAN CORPORATION
 0050E7 PARADISE INNOVATIONS (ASIA)
 0050E8 NOMADIX INC.
-0050EA XEL COMMUNICTIONS, INC.
+0050EA XEL COMMUNICATIONS, INC.
 0050EB ALPHA-TOP CORPORATION
 0050EC OLICOM A/S
 0050ED ANDA NETWORKS
 0050EE TEK DIGITEL CORPORATION
-0050EF SPE SYSTEMHAUS GMBH
+0050EF SPE Systemhaus GmbH
 0050F0 CISCO SYSTEMS, INC.
 0050F1 LIBIT SIGNAL PROCESSING, LTD.
 0050F2 MICROSOFT CORP.
-0050F3 GLOBAL NET INFORMATION CO.,LTD
+0050F3 GLOBAL NET INFORMATION CO., Ltd.
 0050F4 SIGMATEK GMBH & CO. KG
-0050F6 PAN-INTERNATIONAL
-0050F7 VENTURE MANUFACTURING
+0050F6 PAN-INTERNATIONAL INDUSTRIAL CORP.
+0050F7 VENTURE MANUFACTURING (SINGAPORE) LTD.
 0050F8 ENTREGA TECHNOLOGIES, INC.
 0050FA OXTEL, LTD.
 0050FB VSK ELECTRONICS
 0050FC EDIMAX TECHNOLOGY CO., LTD.
-0050FD ISIONCOMM CO., LTD.
-0050FE PCTVNET ASA
+0050FD VISIONCOMM CO., LTD.
+0050FE PCTVnet ASA
 0050FF HAKKO ELECTRONICS CO., LTD.
 006000 XYCOM INC.
-006001 INNOSYS, INC.
+006001 InnoSys, Inc.
 006002 SCREEN SUBTITLING SYSTEMS, LTD
 006003 TERAOKA WEIGH SYSTEM PTE, LTD.
 006004 COMPUTADORES MODULARES SA
@@ -2920,9 +5034,9 @@
 006008 3COM CORPORATION
 006009 CISCO SYSTEMS, INC.
 00600A SORD COMPUTER CORPORATION
-00600B LOGWARE GMBH
+00600B LOGWARE GmbH
 00600C APPLIED DATA SYSTEMS, INC.
-00600D MICRODESIGN GMBH
+00600D Digital Logic GmbH
 00600E WAVENET INTERNATIONAL, INC.
 00600F WESTELL, INC.
 006010 NETWORK MACHINES, INC.
@@ -2934,7 +5048,7 @@
 006016 CLARIION
 006017 TOKIMEC INC.
 006018 STELLAR ONE CORPORATION
-006019 BOEHRINGER MANNHEIM CORP.
+006019 Roche Diagnostics
 00601A KEITHLEY INSTRUMENTS
 00601B MESA ELECTRONICS
 00601C TELXON CORPORATION
@@ -2951,24 +5065,24 @@
 006027 Superior Modular Products
 006028 MACROVISION CORPORATION
 006029 CARY PERIPHERALS INC.
-00602A SYMICRON COMPUTER
+00602A SYMICRON COMPUTER COMMUNICATIONS, LTD.
 00602B PEAK AUDIO
-00602C LINX DATA TERMINALS, INC.
+00602C LINX Data Terminals, Inc.
 00602D ALERTON TECHNOLOGIES, INC.
 00602E CYCLADES CORPORATION
 00602F CISCO SYSTEMS, INC.
-006030 VILLAGE TRONIC
+006030 VILLAGE TRONIC ENTWICKLUNG
 006031 HRK SYSTEMS
 006032 I-CUBE, INC.
 006033 ACUITY IMAGING, INC.
-006034 ROBERT BOSCH GMBH
+006034 ROBERT BOSCH GmbH
 006035 DALLAS SEMICONDUCTOR, INC.
-006036 AUSTRIAN RESEARCH CENTER
+006036 AUSTRIAN RESEARCH CENTER SEIBERSDORF
 006037 PHILIPS SEMICONDUCTORS
 006038 Nortel Networks
-006039 SANCOM TECHNOLOGY, INC.
+006039 SanCom Technology, Inc.
 00603A QUICK CONTROLS LTD.
-00603B AMTEC SPA
+00603B AMTEC spa
 00603C HAGIWARA SYS-COM CO., LTD.
 00603D 3CX
 00603E CISCO SYSTEMS, INC.
@@ -2976,7 +5090,7 @@
 006040 NETRO CORP.
 006041 Yokogawa Electric Corporation
 006042 TKS (USA), INC.
-006043 COMSOFT SYSTEMS, INC.
+006043 ComSoft Systems, Inc.
 006044 LITTON/POLY-SCIENTIFIC
 006045 PATHLIGHT TECHNOLOGIES
 006046 VMETRO, INC.
@@ -2984,23 +5098,23 @@
 006048 EMC CORPORATION
 006049 VINA TECHNOLOGIES
 00604A SAIC IDEAS GROUP
-00604B BIODATA GMBH
+00604B BIODATA GmbH
 00604C SAT
 00604D MMC NETWORKS, INC.
 00604E CYCLE COMPUTER CORPORATION, INC.
 00604F SUZUKI MFG. CO., LTD.
 006050 INTERNIX INC.
 006051 QUALITY SEMICONDUCTOR
-006052 PERIPHERALS ENTERPRISE CO., L.
+006052 PERIPHERALS ENTERPRISE CO., Ltd.
 006053 TOYODA MACHINE WORKS, LTD.
 006054 CONTROLWARE GMBH
 006055 CORNELL UNIVERSITY
 006056 NETWORK TOOLS, INC.
 006057 MURATA MANUFACTURING CO., LTD.
-006058 COPPER MOUNTAIN
+006058 COPPER MOUNTAIN COMMUNICATIONS, INC.
 006059 TECHNICAL COMMUNICATIONS CORP.
 00605A CELCORE, INC.
-00605B INTRASERVER TECHNOLOGY INC.
+00605B IntraServer Technology, Inc.
 00605C CISCO SYSTEMS, INC.
 00605D SCANIVALVE CORP.
 00605E LIBERTY TECHNOLOGY NETWORKING
@@ -3010,13 +5124,13 @@
 006062 TELESYNC, INC.
 006063 PSION DACOM PLC.
 006064 NETCOMM LIMITED
-006065 BERNECKER & RAINER
+006065 BERNECKER & RAINER INDUSTRIE-ELEKTRONIC GmbH
 006066 LACROIX TECHNOLGIE
 006067 ACER NETXUS INC.
 006068 EICON TECHNOLOGY CORPORATION
-006069 BROCADE COMMUNICATIONS SYSTEMS
-00606A MITSUBISHI WIRELESS COMM. INC.
-00606B AICHI ELECTRONICS CO.,LTD.
+006069 BROCADE COMMUNICATIONS SYSTEMS, Inc.
+00606A MITSUBISHI WIRELESS COMMUNICATIONS. INC.
+00606B Synclayer Inc.
 00606C ARESCOM
 00606D DIGITAL EQUIPMENT CORP.
 00606E DAVICOM SEMICONDUCTOR, INC.
@@ -3027,13 +5141,13 @@
 006073 REDCREEK COMMUNICATIONS, INC.
 006074 QSC AUDIO PRODUCTS
 006075 PENTEK, INC.
-006076 SCHLUMBERGER TECHNOLOGIES
+006076 SCHLUMBERGER TECHNOLOGIES RETAIL PETROLEUM SYSTEMS
 006077 PRISA NETWORKS
 006078 POWER MEASUREMENT LTD.
-006079 WAVEPHORE NETWORKS, INC.
-00607A DVS GMBH
+006079 Mainstream Data, Inc.
+00607A DVS GmbH
 00607B FORE SYSTEMS, INC.
-00607C WAVEACCESS, LTD.
+00607C WaveAccess, Ltd.
 00607D SENTIENT NETWORKS INC.
 00607E GIGALABS, INC.
 00607F AURORA TECHNOLOGIES, INC.
@@ -3042,16 +5156,16 @@
 006082 NOVALINK TECHNOLOGIES, INC.
 006083 CISCO SYSTEMS, INC.
 006084 DIGITAL VIDEO
-006085 STORAGE CONCEPTS
+006085 Storage Concepts
 006086 LOGIC REPLACEMENT TECH. LTD.
 006087 KANSAI ELECTRIC CO., LTD.
 006088 WHITE MOUNTAIN DSP, INC.
 006089 XATA
 00608A CITADEL COMPUTER
-00608B CONFERTECH INTERNATIONAL
+00608B ConferTech International
 00608C 3COM CORPORATION
 00608D UNIPULSE CORP.
-00608E HE ELECTRONICS, TECHNOLOGIE &
+00608E HE ELECTRONICS, TECHNOLOGIE & SYSTEMTECHNIK GmbH
 00608F TEKRAM TECHNOLOGY CO., LTD.
 006090 ABLE COMMUNICATIONS, INC.
 006091 FIRST PACIFIC NETWORKS, INC.
@@ -3065,24 +5179,24 @@
 006099 LAN MEDIA CORPORATION
 00609A NJK TECHNO CO.
 00609B ASTRO-MED, INC.
-00609C PERKIN-ELMER CORPORATION
+00609C Perkin-Elmer Incorporated
 00609D PMI FOOD EQUIPMENT GROUP
-00609E X3 - INFORMATION TECHNOLOGY
+00609E ASC X3 - INFORMATION TECHNOLOGY STANDARDS SECRETARIATS
 00609F PHAST CORPORATION
-0060A0 SWITCHED NETWORK
-0060A1 VPNET
+0060A0 SWITCHED NETWORK TECHNOLOGIES, INC.
+0060A1 VPNet, Inc.
 0060A2 NIHON UNISYS LIMITED CO.
 0060A3 CONTINUUM TECHNOLOGY CORP.
 0060A4 GRINAKER SYSTEM TECHNOLOGIES
 0060A5 PERFORMANCE TELECOM CORP.
 0060A6 PARTICLE MEASURING SYSTEMS
-0060A7 MICROSENS GMBH & CO. KG
+0060A7 MICROSENS GmbH & CO. KG
 0060A8 TIDOMAT AB
-0060A9 GESYTEC MBH
+0060A9 GESYTEC MbH
 0060AA INTELLIGENT DEVICES INC. (IDI)
 0060AB LARSCOM INCORPORATED
 0060AC RESILIENCE CORPORATION
-0060AD MEGACHIPS CORPORATION
+0060AD MegaChips Corporation
 0060AE TRIO INFORMATION SYSTEMS AB
 0060AF PACIFIC MICRO DATA, INC.
 0060B0 HEWLETT-PACKARD CO.
@@ -3090,19 +5204,19 @@
 0060B2 PROCESS CONTROL CORP.
 0060B3 Z-COM, INC.
 0060B4 GLENAYRE R&D INC.
-0060B5 KEBA GMBH
+0060B5 KEBA GmbH
 0060B6 LAND COMPUTER CO., LTD.
 0060B7 CHANNELMATIC, INC.
 0060B8 CORELIS INC.
 0060B9 NITSUKO CORPORATION
 0060BA SAHARA NETWORKS, INC.
 0060BB CABLETRON - NETLINK, INC.
-0060BC KEUNYOUNG ELECTRONICS &
+0060BC KeunYoung Electronics & Communication Co., Ltd.
 0060BD HUBBELL-PULSECOM
 0060BE WEBTRONICS
 0060BF MACRAIGOR SYSTEMS, INC.
 0060C0 NERA AS
-0060C1 WAVESPAN CORPORATION
+0060C1 WaveSpan Corporation
 0060C2 MPL AG
 0060C3 NETVISION CORPORATION
 0060C4 SOLITON SYSTEMS K.K.
@@ -3110,40 +5224,40 @@
 0060C6 DCS AG
 0060C7 AMATI COMMUNICATIONS CORP.
 0060C8 KUKA WELDING SYSTEMS & ROBOTS
-0060C9 CONTROLNET, INC.
+0060C9 ControlNet, Inc.
 0060CA HARMONIC SYSTEMS INCORPORATED
 0060CB HITACHI ZOSEN CORPORATION
 0060CC EMTRAK, INCORPORATED
-0060CD VIDEOSERVER, INC.
+0060CD VideoServer, Inc.
 0060CE ACCLAIM COMMUNICATIONS
 0060CF ALTEON NETWORKS, INC.
 0060D0 SNMP RESEARCH INCORPORATED
 0060D1 CASCADE COMMUNICATIONS
-0060D2 LUCENT TECHNOLOGIES TAIWAN
+0060D2 LUCENT TECHNOLOGIES TAIWAN TELECOMMUNICATIONS CO., LTD.
 0060D3 AT&T
 0060D4 ELDAT COMMUNICATION LTD.
 0060D5 MIYACHI TECHNOS CORP.
-0060D6 NOVATEL WIRELESS TECHNOLOGIES
-0060D7 ECOLE POLYTECHNIQUE FEDERALE
+0060D6 NovAtel Wireless Technologies Ltd.
+0060D7 ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (EPFL)
 0060D8 ELMIC SYSTEMS, INC.
 0060D9 TRANSYS NETWORKS INC.
 0060DA JBM ELECTRONICS CO.
 0060DB NTP ELEKTRONIK A/S
-0060DC TOYO COMMUNICATION EQUIPMENT
+0060DC TOYO COMMUNICATION EQUIPMENT Co., Ltd.
 0060DD MYRICOM, INC.
-0060DE KAYSER-THREDE GMBH
-0060DF INRANGE TECHNOLOGIES CORP.
+0060DE KAYSER-THREDE GmbH
+0060DF CNT Corporation
 0060E0 AXIOM TECHNOLOGY CO., LTD.
 0060E1 ORCKIT COMMUNICATIONS LTD.
-0060E2 QUEST ENGINEERING & DEV.
+0060E2 QUEST ENGINEERING & DEVELOPMENT
 0060E3 ARBIN INSTRUMENTS
 0060E4 COMPUSERVE, INC.
 0060E5 FUJI AUTOMATION CO., LTD.
 0060E6 SHOMITI SYSTEMS INCORPORATED
 0060E7 RANDATA
-0060E8 HITACHI COMPUTER PRODUCTS
+0060E8 HITACHI COMPUTER PRODUCTS (AMERICA), INC.
 0060E9 ATOP TECHNOLOGIES, INC.
-0060EA STREAMLOGIC
+0060EA StreamLogic
 0060EB FOURTHTRACK SYSTEMS
 0060EC HERMARY OPTO ELECTRONICS INC.
 0060ED RICARDO TEST AUTOMATION LTD.
@@ -3152,19 +5266,19 @@
 0060F0 JOHNSON & JOHNSON MEDICAL, INC
 0060F1 EXP COMPUTER, INC.
 0060F2 LASERGRAPHICS, INC.
-0060F3 NETCOM SYSTEMS, INC.
-0060F4 ADVANCED COMPUTER SOLUTIONS,
+0060F3 Performance Analysis Broadband, Spirent plc
+0060F4 ADVANCED COMPUTER SOLUTIONS, Inc.
 0060F5 ICON WEST, INC.
-0060F6 NEXTEST COMMUNICATION
+0060F6 NEXTEST COMMUNICATIONS PRODUCTS, INC.
 0060F7 DATAFUSION SYSTEMS
-0060F8 LORAN INTERNATIONAL TECHN. INC
+0060F8 Loran International Technologies Inc.
 0060F9 DIAMOND LANE COMMUNICATIONS
-0060FA EDUCATIONAL TECHNOLOGY
+0060FA EDUCATIONAL TECHNOLOGY RESOURCES, INC.
 0060FB PACKETEER, INC.
-0060FC CONSERVATION THROUGH
-0060FD NETICS, INC.
+0060FC CONSERVATION THROUGH INNOVATION LTD.
+0060FD NetICs, Inc.
 0060FE LYNX SYSTEM DEVELOPERS, INC.
-0060FF QUVIS, INC.
+0060FF QuVis, Inc.
 0070B0 M/A-COM INC. COMPANIES
 0070B3 DATA RECALL LTD.
 008000 MULTITECH SYSTEMS, INC.
@@ -3200,7 +5314,7 @@
 00801E XINETRON, INC.
 00801F KRUPP ATLAS ELECTRONIK GMBH
 008020 NETWORK PRODUCTS
-008021 NEWBRIDGE RESEARCH CORP.
+008021 Alcatel Canada Inc.
 008022 SCAN-OPTICS
 008023 INTEGRATED BUSINESS NETWORKS
 008024 KALPANA, INC.
@@ -3361,7 +5475,7 @@
 0080BF TAKAOKA ELECTRIC MFG. CO. LTD.
 0080C0 PENRIL DATACOMM
 0080C1 LANEX CORPORATION
-0080C2 IEEE 802 COMMITTEE
+0080C2 IEEE 802.1 COMMITTEE
 0080C3 BICC INFORMATION SYSTEMS & SVC
 0080C4 DOCUMENT TECHNOLOGIES, INC.
 0080C5 NOVELLCO DE MEXICO
@@ -3382,7 +5496,7 @@
 0080D4 CHASE RESEARCH LTD.
 0080D5 CADRE TECHNOLOGIES
 0080D6 NUVOTECH, INC.
-0080D7 FANTUM ENGINEERING, INC.
+0080D7 Fantum Engineering
 0080D8 NETWORK PERIPHERALS INC.
 0080D9 EMK ELEKTRONIK
 0080DA BRUEL & KJAER
@@ -3400,14 +5514,14 @@
 0080E6 PEER NETWORKS, INC.
 0080E7 LYNWOOD SCIENTIFIC DEV. LTD.
 0080E8 CUMULUS CORPORATIION
-0080E9 MADGE NETWORKS
+0080E9 Madge Ltd.
 0080EA ADVA Optical Networking Ltd.
 0080EB COMPCONTROL B.V.
 0080EC SUPERCOMPUTING SOLUTIONS, INC.
 0080ED IQ TECHNOLOGIES, INC.
 0080EE THOMSON CSF
 0080EF RATIONAL
-0080F0 KYUSHU MATSUSHITA ELECTRIC CO.
+0080F0 Panasonic Communications Co., Ltd.
 0080F1 OPUS SYSTEMS
 0080F2 RAYCOM SYSTEMS INC
 0080F3 SUN ELECTRONICS CORP.
@@ -3424,23 +5538,23 @@
 0080FE AZURE TECHNOLOGIES, INC.
 0080FF SOC. DE TELEINFORMATIQUE RTC
 009000 DIAMOND MULTIMEDIA
-009001 NISHIMU ELCTRONICS INDUSTRIES
+009001 NISHIMU ELECTRONICS INDUSTRIES CO., LTD.
 009002 ALLGON AB
 009003 APLIO
 009004 3COM EUROPE LTD.
 009005 PROTECH SYSTEMS CO., LTD.
 009006 HAMAMATSU PHOTONICS K.K.
 009007 DOMEX TECHNOLOGY CORP.
-009008 HAN A SYSTEMS, INC.
+009008 HanA Systems Inc.
 009009 i Controls, Inc.
-00900A PROTON ELECTRONIC INDUSTRIAL
+00900A PROTON ELECTRONIC INDUSTRIAL CO., LTD.
 00900B LANNER ELECTRONICS, INC.
 00900C CISCO SYSTEMS, INC.
 00900D OVERLAND DATA INC.
 00900E HANDLINK TECHNOLOGIES, INC.
 00900F KAWASAKI HEAVY INDUSTRIES, LTD
 009010 SIMULATION LABORATORIES, INC.
-009011 WAVTRACE, INC.
+009011 WAVTrace, Inc.
 009012 GLOBESPAN SEMICONDUCTOR, INC.
 009013 SAMSAN CORP.
 009014 ROTORK INSTRUMENTS, LTD.
@@ -3451,7 +5565,7 @@
 009019 HERMES ELECTRONICS CO., LTD.
 00901A UNISPHERE SOLUTIONS
 00901B DIGITAL CONTROLS
-00901C MPS SOFTWARE GMBH
+00901C mps Software Gmbh
 00901D PEC (NZ) LTD.
 00901E SELESTA INGEGNE RIA S.P.A.
 00901F ADTEC PRODUCTIONS, INC.
@@ -3461,44 +5575,44 @@
 009023 ZILOG INC.
 009024 PIPELINKS, INC.
 009025 VISION SYSTEMS LTD. PTY
-009026 ADVANCED SWITCHING
+009026 ADVANCED SWITCHING COMMUNICATIONS, INC.
 009027 INTEL CORPORATION
 009028 NIPPON SIGNAL CO., LTD.
 009029 CRYPTO AG
 00902A COMMUNICATION DEVICES, INC.
 00902B CISCO SYSTEMS, INC.
 00902C DATA & CONTROL EQUIPMENT LTD.
-00902D DATA ELECTRONICS
+00902D DATA ELECTRONICS (AUST.) PTY, LTD.
 00902E NAMCO LIMITED
 00902F NETCORE SYSTEMS, INC.
 009030 HONEYWELL-DATING
 009031 MYSTICOM, LTD.
 009032 PELCOMBE GROUP LTD.
-009033 INNOVAPHONE GMBH
+009033 INNOVAPHONE GmbH
 009034 IMAGIC, INC.
 009035 ALPHA TELECOM, INC.
-009036 ENS, INC.
+009036 ens, inc.
 009037 ACUCOMM, INC.
 009038 FOUNTAIN TECHNOLOGIES, INC.
 009039 SHASTA NETWORKS
 00903A NIHON MEDIA TOOL INC.
-00903B TRIEMS RESEARCH LAB, INC.
+00903B TriEMS Research Lab, Inc.
 00903C ATLANTIC NETWORK SYSTEMS
 00903D BIOPAC SYSTEMS, INC.
-00903E N.V. PHILIPS INDUSTRIAL
+00903E N.V. PHILIPS INDUSTRIAL ACTIVITIES
 00903F AZTEC RADIOMEDIA
-009040 CASTLE NETWORKS, INC.
+009040 Siemens Network Convergence LLC
 009041 APPLIED DIGITAL ACCESS
-009042 ECCS
+009042 ECCS, Inc.
 009043 NICHIBEI DENSHI CO., LTD.
 009044 ASSURED DIGITAL, INC.
-009045 MARIPOSA TECHNOLOGY
+009045 Marconi Communications
 009046 DEXDYNE, LTD.
 009047 GIGA FAST E. LTD.
 009048 ZEAL CORPORATION
 009049 ENTRIDIA CORPORATION
 00904A CONCUR SYSTEM TECHNOLOGIES
-00904B GEMTEK TECHNOLOGY CO., LTD.
+00904B GemTek Technology Co., Ltd.
 00904C EPIGRAM, INC.
 00904D SPEC S.A.
 00904E DELEM BV
@@ -3508,49 +5622,49 @@
 009052 SELCOM ELETTRONICA S.R.L.
 009053 DAEWOO ELECTRONICS CO., LTD.
 009054 INNOVATIVE SEMICONDUCTORS, INC
-009055 PARKER HANNIFIN CORPORATION
+009055 PARKER HANNIFIN CORPORATION COMPUMOTOR DIVISION
 009056 TELESTREAM, INC.
-009057 AANETCOM, INC.
-009058 ULTRA ELECTRONICS LTD.
+009057 AANetcom, Inc.
+009058 Ultra Electronics Ltd., Command and Control Systems
 009059 TELECOM DEVICE K.K.
 00905A DEARBORN GROUP, INC.
 00905B RAYMOND AND LAE ENGINEERING
 00905C EDMI
-00905D NETCOM SICHERHEITSTECHNIK GMBH
+00905D NETCOM SICHERHEITSTECHNIK GmbH
 00905E RAULAND-BORG CORPORATION
 00905F CISCO SYSTEMS, INC.
 009060 SYSTEM CREATE CORP.
-009061 PACIFIC RESEARCH & ENGINEERING
-009062 ICP VORTEX COMPUTERSYSTEME
-009063 COHERENT COMMUNICATIONS
+009061 PACIFIC RESEARCH & ENGINEERING CORPORATION
+009062 ICP VORTEX COMPUTERSYSTEME GmbH
+009063 COHERENT COMMUNICATIONS SYSTEMS CORPORATION
 009064 THOMSON BROADCAST SYSTEMS
 009065 FINISAR CORPORATION
 009066 Troika Networks, Inc.
-009067 WALKABOUT COMPUTERS, INC.
+009067 WalkAbout Computers, Inc.
 009068 DVT CORP.
 009069 JUNIPER NETWORKS, INC.
 00906A TURNSTONE SYSTEMS, INC.
 00906B APPLIED RESOURCES, INC.
-00906C GWT GLOBAL WEIGHING
+00906C GWT GLOBAL WEIGHING TECHNOLOGIES GmbH
 00906D CISCO SYSTEMS, INC.
 00906E PRAXON, INC.
 00906F CISCO SYSTEMS, INC.
 009070 NEO NETWORKS, INC.
-009071 BADGER TECHNOLOGY, INC.
+009071 Applied Innovation Inc.
 009072 SIMRAD AS
 009073 GAIO TECHNOLOGY
 009074 ARGON NETWORKS, INC.
 009075 NEC DO BRASIL S.A.
-009076 FMT AIRCRAFT GATE SUPPORT
+009076 FMT AIRCRAFT GATE SUPPORT SYSTEMS AB
 009077 ADVANCED FIBRE COMMUNICATIONS
-009078 MER TELEMANAGEMENT
-009079 CLEARONE INC.
+009078 MER TELEMANAGEMENT SOLUTIONS, LTD.
+009079 ClearOne, Inc.
 00907A SPECTRALINK CORP.
 00907B E-TECH, INC.
 00907C DIGITALCAST, INC.
-00907D HOME WIRELESS NETWORKS
+00907D Lake Communications
 00907E VETRONIX CORP.
-00907F WATCHGUARD TECHNOLOGIES, INC.
+00907F WatchGuard Technologies, Inc.
 009080 NOT LIMITED, INC.
 009081 ALOHA NETWORKS, INC.
 009082 FORCE INSTITUTE
@@ -3566,9 +5680,9 @@
 00908C ETREND ELECTRONICS, INC.
 00908D VICKERS ELECTRONICS SYSTEMS
 00908E Nortel Networks Broadband Access
-00908F AUDIOCODES LTD.
+00908F AUDIO CODES LTD.
 009090 I-BUS
-009091 DIGITALSCAPE, INC.
+009091 DigitalScape, Inc.
 009092 CISCO SYSTEMS, INC.
 009093 NANAO CORPORATION
 009094 OSPREY TECHNOLOGIES, INC.
@@ -3576,28 +5690,28 @@
 009096 ASKEY COMPUTER CORP.
 009097 SYCAMORE NETWORKS
 009098 SBC DESIGNS, INC.
-009099 ALLIED TELESIS,K.K.
+009099 ALLIED TELESIS, K.K.
 00909A ONE WORLD SYSTEMS, INC.
 00909B MARKPOINT AB
-00909C COMBOX, LTD.
+00909C Terayon Communications Systems
 00909D GSE SYSTEMS, INC.
-00909E DELPHI ENGINEERING GROUP
+00909E Critical IO, LLC
 00909F DIGI-DATA CORPORATION
 0090A0 8X8 INC.
 0090A1 FLYING PIG SYSTEMS, LTD.
 0090A2 CYBERTAN TECHNOLOGY, INC.
-0090A3 MEDIALINCS CO., LTD.
+0090A3 Corecess Inc.
 0090A4 ALTIGA NETWORKS
 0090A5 SPECTRA LOGIC
 0090A6 CISCO SYSTEMS, INC.
 0090A7 CLIENTEC CORPORATION
-0090A8 NINETILES NETWORKS LTD.
+0090A8 NineTiles Networks, Ltd.
 0090A9 WESTERN DIGITAL
-0090AA INDIGO ACTIVE VISION
+0090AA INDIGO ACTIVE VISION SYSTEMS LIMITED
 0090AB CISCO SYSTEMS, INC.
 0090AC OPTIVISION, INC.
 0090AD ASPECT ELECTRONICS, INC.
-0090AE ITALTEL SPA
+0090AE ITALTEL S.p.A.
 0090AF J. MORITA MFG. CORP.
 0090B0 VADEM
 0090B1 CISCO SYSTEMS, INC.
@@ -3610,46 +5724,46 @@
 0090B8 ROHDE & SCHWARZ GMBH & CO. KG
 0090B9 BERAN INSTRUMENTS LTD.
 0090BA VALID NETWORKS, INC.
-0090BB TAINET COMMUNICATION SYSTEM
+0090BB TAINET COMMUNICATION SYSTEM Corp.
 0090BC TELEMANN CO., LTD.
 0090BD OMNIA COMMUNICATIONS, INC.
-0090BE IBC/INTEGRATED BUSINESS
+0090BE IBC/INTEGRATED BUSINESS COMPUTERS
 0090BF CISCO SYSTEMS, INC.
 0090C0 K.J. LAW ENGINEERS, INC.
-0090C1 EDA INDUSTRIES
-0090C2 JK MICROSYSTEMS, INC.
+0090C1 Peco II, Inc.
+0090C2 JK microsystems, Inc.
 0090C3 TOPIC SEMICONDUCTOR CORP.
 0090C4 JAVELIN SYSTEMS, INC.
 0090C5 INTERNET MAGIC, INC.
 0090C6 OPTIM SYSTEMS, INC.
 0090C7 ICOM INC.
-0090C8 WAVERIDER COMMUNICATIONS
-0090C9 PRODUCTIVITY ENHANCEMENT
-0090CA ACCORD VIDEO
-0090CB WIRELESS ONLINE, INC.
-0090CC PLANEX COMMUNICATIONS, INC.
-0090CD ENT-EMPRESA NACIONAL
-0090CE TETRA GMBH
+0090C8 WAVERIDER COMMUNICATIONS (CANADA) INC.
+0090C9 DPAC Technologies
+0090CA ACCORD VIDEO TELECOMMUNICATIONS, LTD.
+0090CB Wireless OnLine, Inc.
+0090CC PLANET COMMUNICATIONS, INC.
+0090CD ENT-EMPRESA NACIONAL DE TELECOMMUNICACOES, S.A.
+0090CE TETRA GmbH
 0090CF NORTEL
-0090D0 ALCATEL BELL
+0090D0 Thomson Belgium
 0090D1 LEICHU ENTERPRISE CO., LTD.
 0090D2 ARTEL VIDEO SYSTEMS
-0090D3 GIESECKE & DEVRIENT GMBH
-0090D4 BINDVIEW DEVELOPMENT CORP.
+0090D3 GIESECKE & DEVRIENT GmbH
+0090D4 BindView Development Corp.
 0090D5 EUPHONIX, INC.
 0090D6 CRYSTAL GROUP
-0090D7 NETBOOST CORP.
+0090D7 NetBoost Corp.
 0090D8 WHITECROSS SYSTEMS
 0090D9 CISCO SYSTEMS, INC.
 0090DA DYNARC, INC.
 0090DB NEXT LEVEL COMMUNICATIONS
 0090DC TECO INFORMATION SYSTEMS
-0090DD THE MIHARU COMMUNICATIONS
+0090DD THE MIHARU COMMUNICATIONS CO., LTD.
 0090DE CARDKEY SYSTEMS, INC.
-0090DF MITSUBISHI CHEMICAL
+0090DF MITSUBISHI CHEMICAL AMERICA, INC.
 0090E0 SYSTRAN CORP.
 0090E1 TELENA S.P.A.
-0090E2 DISTRIBUTED PROCESSING
+0090E2 DISTRIBUTED PROCESSING TECHNOLOGY
 0090E3 AVEX ELECTRONICS INC.
 0090E4 NEC AMERICA, INC.
 0090E5 TEKNEMA, INC.
@@ -3660,8 +5774,8 @@
 0090EA ALPHA TECHNOLOGIES, INC.
 0090EB SENTRY TELECOM SYSTEMS
 0090EC PYRESCOM
-0090ED CENTRAL SYSTEM RESEARCH
-0090EE PERSONAL COMMUNICATIONS
+0090ED CENTRAL SYSTEM RESEARCH CO., LTD.
+0090EE PERSONAL COMMUNICATIONS TECHNOLOGIES
 0090EF INTEGRIX, INC.
 0090F0 HARMONIC LIGHTWAVES, LTD.
 0090F1 DOT HILL SYSTEMS CORPORATION
@@ -3673,20 +5787,21 @@
 0090F7 NBASE COMMUNICATIONS LTD.
 0090F8 MEDIATRIX TELECOM
 0090F9 LEITCH
-0090FA GIGANET, INC.
+0090FA GigaNet, Inc.
 0090FB PORTWELL, INC.
 0090FC NETWORK COMPUTING DEVICES
-0090FD COPPERCOM, INC.
-0090FE ELECOM CO., LTD.  (LANEED DIV.
+0090FD CopperCom, Inc.
+0090FE ELECOM CO., LTD.  (LANEED DIV.)
 0090FF TELLUS TECHNOLOGY INC.
+0091D6 Crystal Group, Inc.
 009D8E CARDIAC RECORDERS, INC.
 00A000 CENTILLION NETWORKS, INC.
 00A001 WATKINS-JOHNSON COMPANY
-00A002 LEEDS & NORTHRUP AUSTRALIA
+00A002 LEEDS & NORTHRUP AUSTRALIA PTY LTD
 00A003 STAEFA CONTROL SYSTEM
 00A004 NETPOWER, INC.
 00A005 DANIEL INSTRUMENTS, LTD.
-00A006 IMAGE DATA PROCESSING
+00A006 IMAGE DATA PROCESSING SYSTEM GROUP
 00A007 APEXX TECHNOLOGY, INC.
 00A008 NETCORP
 00A009 WHITETREE NETWORK
@@ -3714,8 +5829,8 @@
 00A01F TRICORD SYSTEMS, INC.
 00A020 CITICORP/TTI
 00A021 GENERAL DYNAMICS-
-00A022 CENTRE FOR DEVELOPMENT OF
-00A023 APPLIED CREATIVE TECHNOLOGY,
+00A022 CENTRE FOR DEVELOPMENT OF ADVANCED COMPUTING
+00A023 APPLIED CREATIVE TECHNOLOGY, INC.
 00A024 3COM CORPORATION
 00A025 REDCOM LABS INC.
 00A026 TELDAT, S.A.
@@ -3724,14 +5839,14 @@
 00A029 COULTER CORPORATION
 00A02A TRANCELL SYSTEMS
 00A02B TRANSITIONS RESEARCH CORP.
-00A02C INTERWAVE COMMUNICATIONS
+00A02C interWAVE Communications
 00A02D 1394 Trade Association
 00A02E BRAND COMMUNICATIONS, LTD.
 00A02F PIRELLI CAVI
 00A030 CAPTOR NV/SA
 00A031 HAZELTINE CORPORATION, MS 1-17
 00A032 GES SINGAPORE PTE. LTD.
-00A033 IMC MESS-SYSTEME GMBH
+00A033 imc MeBsysteme GmbH
 00A034 AXEL
 00A035 CYLINK CORPORATION
 00A036 APPLIED NETWORK TECHNOLOGY
@@ -3741,14 +5856,14 @@
 00A03A KUBOTEK CORPORATION
 00A03B TOSHIN ELECTRIC CO., LTD.
 00A03C EG&G NUCLEAR INSTRUMENTS
-00A03D OPTO - 22
+00A03D OPTO-22
 00A03E ATM FORUM
-00A03F COMPUTER SOCIETY MICROPROCES'R
+00A03F COMPUTER SOCIETY MICROPROCESSOR & MICROPROCESSOR STANDARDS C
 00A040 APPLE COMPUTER
 00A041 LEYBOLD-INFICON
 00A042 SPUR PRODUCTS CORP.
 00A043 AMERICAN TECHNOLOGY LABS, INC.
-00A044 NTT INTELLIGENT TECHNOLOGY
+00A044 NTT IT CO., LTD.
 00A045 PHOENIX CONTACT GMBH & CO.
 00A046 SCITEX CORP. LTD.
 00A047 INTEGRATED FITNESS CORP.
@@ -3756,7 +5871,7 @@
 00A049 DIGITECH INDUSTRIES, INC.
 00A04A NISSHIN ELECTRIC CO., LTD.
 00A04B TFL LAN INC.
-00A04C INNOVATIVE SYSTEMS & TECH. INC
+00A04C INNOVATIVE SYSTEMS & TECHNOLOGIES, INC.
 00A04D EDA INSTRUMENTS, INC.
 00A04E VOELKER TECHNOLOGIES, INC.
 00A04F AMERITEC CORP.
@@ -3764,15 +5879,15 @@
 00A051 ANGIA COMMUNICATIONS. INC.
 00A052 STANILITE ELECTRONICS PTY. LTD
 00A053 COMPACT DEVICES, INC.
-00A055 LINKTECH, INC.
+00A055 Data Device Corporation
 00A056 MICROPROSS
-00A057 ELSA AG
+00A057 LANCOM Systems GmbH
 00A058 GLORY, LTD.
 00A059 HAMILTON HALLMARK
 00A05A KOFAX IMAGE PRODUCTS
 00A05B MARQUIP, INC.
 00A05C INVENTORY CONVERSION, INC./
-00A05D CS COMPUTER SYSTEME GMBH
+00A05D CS COMPUTER SYSTEME GmbH
 00A05E MYRIAD LOGIC INC.
 00A05F BTG ENGINEERING BV
 00A060 ACER PERIPHERALS, INC.
@@ -3784,10 +5899,10 @@
 00A066 ISA CO., LTD.
 00A067 NETWORK SERVICES GROUP
 00A068 BHP LIMITED
-00A069 TrueTime
-00A06A VERILINK CORP.
+00A069 Symmetricom, Inc.
+00A06A Verilink Corporation
 00A06B DMS DORSCH MIKROSYSTEM GMBH
-00A06C SHINDENGEN ELECTRIC MFG.
+00A06C SHINDENGEN ELECTRIC MFG. CO., LTD.
 00A06D MANNESMANN TALLY CORPORATION
 00A06E AUSTRON, INC.
 00A06F THE APPCON GROUP, INC.
@@ -3801,7 +5916,7 @@
 00A077 FUJITSU NEXION, INC.
 00A078 Marconi Communications
 00A079 ALPS ELECTRIC (USA), INC.
-00A07A ADVANCED PERIPHERALS
+00A07A ADVANCED PERIPHERALS TECHNOLOGIES, INC.
 00A07B DAWN COMPUTER INCORPORATION
 00A07C TONYANG NYLON CO., LTD.
 00A07D SEEQ TECHNOLOGY, INC.
@@ -3813,28 +5928,28 @@
 00A083 ASIMMPHONY TURKEY
 00A084 DATAPLEX PTY. LTD.
 00A086 AMBER WAVE SYSTEMS, INC.
-00A087 MITEL SEMICONDUCTOR, LTD.
+00A087 Zarlink Semiconductor Ltd.
 00A088 ESSENTIAL COMMUNICATIONS
 00A089 XPOINT TECHNOLOGIES, INC.
 00A08A BROOKTROUT TECHNOLOGY, INC.
 00A08B ASTON ELECTRONIC DESIGNS LTD.
-00A08C MULTIMEDIA LANS, INC.
+00A08C MultiMedia LANs, Inc.
 00A08D JACOMO CORPORATION
 00A08E Nokia Internet Communications
 00A08F DESKNET SYSTEMS, INC.
-00A090 TIMESTEP CORPORATION
+00A090 TimeStep Corporation
 00A091 APPLICOM INTERNATIONAL
 00A092 H. BOLLMANN MANUFACTURERS, LTD
-00A093 B/E AEROSPACE
+00A093 B/E AEROSPACE, Inc.
 00A094 COMSAT CORPORATION
 00A095 ACACIA NETWORKS, INC.
-00A096 MITSUMI ELECTRIC CO., LTD.
+00A096 MITUMI ELECTRIC CO., LTD.
 00A097 JC INFORMATION SYSTEMS
 00A098 NETWORK APPLIANCE CORP.
 00A099 K-NET LTD.
 00A09A NIHON KOHDEN AMERICA
 00A09B QPSX COMMUNICATIONS, LTD.
-00A09C XYPLEX, INC.
+00A09C Xyplex, Inc.
 00A09D JOHNATHON FREEMAN TECHNOLOGIES
 00A09E ICTV
 00A09F COMMVISION CORP.
@@ -3847,7 +5962,7 @@
 00A0A6 M.I. SYSTEMS, K.K.
 00A0A7 VORAX CORPORATION
 00A0A8 RENEX CORPORATION
-00A0A9 GN NETTEST (CANADA) INC.
+00A0A9 GN NETTEST (CANADA) NAVTEL DIVISION
 00A0AA SPACELABS MEDICAL
 00A0AB NETCS INFORMATIONSTECHNIK GMBH
 00A0AC GILAT SATELLITE NETWORKS, LTD.
@@ -3868,7 +5983,7 @@
 00A0BB HILAN GMBH
 00A0BC VIASAT, INCORPORATED
 00A0BD I-TECH CORP.
-00A0BE INTEGRATED CIRCUIT SYSTEMS,INC
+00A0BE INTEGRATED CIRCUIT SYSTEMS, INC. COMMUNICATIONS GROUP
 00A0BF WIRELESS DATA GROUP MOTOROLA
 00A0C0 DIGITAL LINK CORP.
 00A0C1 ORTIVUS MEDICAL AB
@@ -3883,12 +5998,12 @@
 00A0CA FUJITSU DENSO LTD.
 00A0CB ARK TELECOMMUNICATIONS, INC.
 00A0CC LITE-ON COMMUNICATIONS, INC.
-00A0CD DR. JOHANNES HEIDENHAIN GMBH
+00A0CD DR. JOHANNES HEIDENHAIN GmbH
 00A0CE ASTROCOM CORPORATION
 00A0CF SOTAS, INC.
 00A0D0 TEN X TECHNOLOGY, INC.
 00A0D1 INVENTEC CORPORATION
-00A0D2 ALLIED TELESIS INTERNATIONAL
+00A0D2 ALLIED TELESIS INTERNATIONAL CORPORATION
 00A0D3 INSTEM COMPUTER SYSTEMS, LTD.
 00A0D4 RADIOLAN,  INC.
 00A0D5 SIERRA WIRELESS INC.
@@ -3896,14 +6011,14 @@
 00A0D7 KASTEN CHASE APPLIED RESEARCH
 00A0D8 SPECTRA - TEK
 00A0D9 CONVEX COMPUTER CORPORATION
-00A0DA INTEGRATED SYSTEMS
+00A0DA INTEGRATED SYSTEMS Technology, Inc.
 00A0DB FISHER & PAYKEL PRODUCTION
 00A0DC O.N. ELECTRONIC CO., LTD.
 00A0DD AZONIX CORPORATION
 00A0DE YAMAHA CORPORATION
 00A0DF STS TECHNOLOGIES, INC.
 00A0E0 TENNYSON TECHNOLOGIES PTY LTD
-00A0E1 WESTPORT RESEARCH
+00A0E1 WESTPORT RESEARCH ASSOCIATES, INC.
 00A0E2 KEISOKU GIKEN CORP.
 00A0E3 XKL SYSTEMS CORP.
 00A0E4 OPTIQUEST
@@ -3911,9 +6026,9 @@
 00A0E6 DIALOGIC CORPORATION
 00A0E7 CENTRAL DATA CORPORATION
 00A0E8 REUTERS HOLDINGS PLC
-00A0E9 ELECTRONIC RETAILING SYSTEMS
+00A0E9 ELECTRONIC RETAILING SYSTEMS INTERNATIONAL
 00A0EA ETHERCOM CORP.
-00A0EB FASTCOMM COMMUNICATIONS CORP.
+00A0EB Encore Networks
 00A0EC TRANSMITTON LTD.
 00A0ED PRI AUTOMATION
 00A0EE NASHOBA NETWORKS
@@ -3924,7 +6039,7 @@
 00A0F3 STAUBLI
 00A0F4 GE
 00A0F5 RADGUARD LTD.
-00A0F6 AUTOGAS SYSTEMS, INC.
+00A0F6 AutoGas Systems Inc.
 00A0F7 V.I COMPUTER CORP.
 00A0F8 SYMBOL TECHNOLOGIES, INC.
 00A0F9 BINTEC COMMUNICATIONS GMBH
@@ -4016,7 +6131,7 @@
 00C026 LANS TECHNOLOGY CO., LTD.
 00C027 CIPHER SYSTEMS, INC.
 00C028 JASCO CORPORATION
-00C029 KABEL RHEYDT AG
+00C029 Nexans Deutschland AG - ANS
 00C02A OHKURA ELECTRIC CO., LTD.
 00C02B GERLOFF GESELLSCHAFT FUR
 00C02C CENTRUM COMMUNICATIONS, INC.
@@ -4080,7 +6195,7 @@
 00C066 DOCUPOINT, INC.
 00C067 UNITED BARCODE INDUSTRIES
 00C068 PHILIP DRAKE ELECTRONICS LTD.
-00C069 ADAPTIVE BROADBAND CORPORATION
+00C069 Axxcelera Broadband Wireless
 00C06A ZAHNER-ELEKTRIK GMBH & CO. KG
 00C06B OSI PLUS CORPORATION
 00C06C SVEC COMPUTER CORP.
@@ -4157,7 +6272,7 @@
 00C0B3 COMSTAT DATACOMM CORPORATION
 00C0B4 MYSON TECHNOLOGY, INC.
 00C0B5 CORPORATE NETWORK SYSTEMS,INC.
-00C0B6 MERIDIAN DATA, INC.
+00C0B6 Snap Appliance, Inc.
 00C0B7 AMERICAN POWER CONVERSION CORP
 00C0B8 FRASER'S HILL LTD.
 00C0B9 FUNK SOFTWARE, INC.
@@ -4198,7 +6313,7 @@
 00C0DC EOS TECHNOLOGIES, INC.
 00C0DD QLogic Corporation
 00C0DE ZCOMM, INC.
-00C0DF KYE SYSTEMS CORP.
+00C0DF KYE Systems Corp.
 00C0E0 DSC COMMUNICATION CORP.
 00C0E1 SONIC SOLUTIONS
 00C0E2 CALCOMP, INC.
@@ -4275,7 +6390,7 @@
 00D027 APPLIED AUTOMATION, INC.
 00D028 OMNEON VIDEO NETWORKS
 00D029 WAKEFERN FOOD CORPORATION
-00D02A FLEXION SYSTEMS
+00D02A Voxent Systems Ltd.
 00D02B JETCELL, INC.
 00D02C CAMPBELL SCIENTIFIC, INC.
 00D02D ADEMCO
@@ -4294,6 +6409,7 @@
 00D03A ZONEWORX, INC.
 00D03B VISION PRODUCTS PTY. LTD.
 00D03C Vieo, Inc.
+00D03D GALILEO TECHNOLOGY, LTD.
 00D03E ROCKETCHIPS, INC.
 00D03F AMERICAN COMMUNICATION
 00D040 SYSMATE CO., LTD.
@@ -4368,7 +6484,7 @@
 00D085 OTIS ELEVATOR COMPANY
 00D086 FOVEON, INC.
 00D087 MICROFIRST INC.
-00D088 MAINSAIL NETWORKS, INC.
+00D088 Terayon Communications Systems
 00D089 DYNACOLOR, INC.
 00D08A PHOTRON USA
 00D08B ADVA Limited
@@ -4384,7 +6500,7 @@
 00D095 XYLAN CORPORATION
 00D096 3COM EUROPE LTD.
 00D097 CISCO SYSTEMS, INC.
-00D098 IPS AUTOMATION
+00D098 Photon Dynamics Canada Inc.
 00D099 ELCARD OY
 00D09A FILANET CORPORATION
 00D09B SPECTEL LTD.
@@ -4413,9 +6529,9 @@
 00D0B2 XIOTECH CORPORATION
 00D0B3 DRS FLIGHT SAFETY AND
 00D0B4 KATSUJIMA CO., LTD.
-00D0B5 DOTCOM
+00D0B5 IPricot formerly DotCom
 00D0B6 CRESCENT NETWORKS, INC.
-00D0B7 INTEL CORPOTATION
+00D0B7 INTEL CORPORATION
 00D0B8 IOMEGA CORP.
 00D0B9 MICROTEK INTERNATIONAL, INC.
 00D0BA CISCO SYSTEMS, INC.
@@ -4478,7 +6594,7 @@
 00D0F3 SOLARI DI UDINE SPA
 00D0F4 CARINTHIAN TECH INSTITUTE
 00D0F5 ORANGE MICRO, INC.
-00D0F6 NORTHCHURCH COMMUNICATIONS INC
+00D0F6 Alcatel Canada
 00D0F7 NEXT NETS CORPORATION
 00D0F8 FUJIAN STAR TERMINAL
 00D0F9 ACUTE COMMUNICATIONS CORP.
@@ -4520,28 +6636,28 @@
 00E00D RADIANT SYSTEMS
 00E00E AVALON IMAGING SYSTEMS, INC.
 00E00F SHANGHAI BAUD DATA
-00E010 HESS SB-AUTOMATENBAU GMBH
-00E011 UNIDEN SAN DIEGO
-00E012 PLUTO TECHNOLOGIES
+00E010 HESS SB-AUTOMATENBAU GmbH
+00E011 UNIDEN SAN DIEGO R&D CENTER, INC.
+00E012 PLUTO TECHNOLOGIES INTERNATIONAL INC.
 00E013 EASTERN ELECTRONIC CO., LTD.
 00E014 CISCO SYSTEMS, INC.
 00E015 HEIWA CORPORATION
 00E016 RAPID CITY COMMUNICATIONS
-00E017 EXXACT GMBH
+00E017 EXXACT GmbH
 00E018 ASUSTEK COMPUTER INC.
 00E019 ING. GIORDANO ELETTRONICA
 00E01A COMTEC SYSTEMS. CO., LTD.
 00E01B SPHERE COMMUNICATIONS, INC.
 00E01C MOBILITY ELECTRONICSY
-00E01D WEBTV NETWORKS, INC.
+00E01D WebTV NETWORKS, INC.
 00E01E CISCO SYSTEMS, INC.
-00E01F AVIDIA SYSTEMS, INC.
+00E01F AVIDIA Systems, Inc.
 00E020 TECNOMEN OY
 00E021 FREEGATE CORP.
-00E022 MEDIALIGHT INC.
+00E022 MediaLight, Inc.
 00E023 TELRAD
 00E024 GADZOOX NETWORKS
-00E025 DIT CO., LTD.
+00E025 dit CO., LTD.
 00E026 EASTMAN KODAK CO.
 00E027 DUX, INC.
 00E028 APTIX CORPORATION
@@ -4549,13 +6665,13 @@
 00E02A TANDBERG TELEVISION AS
 00E02B EXTREME NETWORKS
 00E02C AST COMPUTER
-00E02D INNOMEDIALOGIC, INC.
+00E02D InnoMediaLogic, Inc.
 00E02E SPC ELECTRONICS CORPORATION
 00E02F MCNS HOLDINGS, L.P.
 00E030 MELITA INTERNATIONAL CORP.
 00E031 HAGIWARA ELECTRIC CO., LTD.
 00E032 MISYS FINANCIAL SYSTEMS, LTD.
-00E033 E.E.P.D. GMBH
+00E033 E.E.P.D. GmbH
 00E034 CISCO SYSTEMS, INC.
 00E035 LOUGHBOROUGH SOUND IMAGES, PLC
 00E036 PIONEER CORPORATION
@@ -4564,64 +6680,64 @@
 00E039 PARADYNE CORP.
 00E03A CABLETRON SYSTEMS, INC.
 00E03B PROMINET CORPORATION
-00E03C ADVANSYS
+00E03C AdvanSys
 00E03D FOCON ELECTRONIC SYSTEMS A/S
 00E03E ALFATECH, INC.
 00E03F JATON CORPORATION
-00E040 DESKSTATION TECHNOLOGY, INC.
+00E040 DeskStation Technology, Inc.
 00E041 CSPI
-00E042 PACOM DATA LTD.
-00E043 VITALCOM
+00E042 Pacom Systems Ltd.
+00E043 VitalCom
 00E044 LSICS CORPORATION
 00E045 TOUCHWAVE, INC.
 00E046 BENTLY NEVADA CORP.
 00E047 INFOCUS SYSTEMS
 00E048 SDL COMMUNICATIONS, INC.
-00E049 MICROWI ELECTRONIC GMBH
-00E04A ENHANCED MESSAGING SYSTEMS,INC
-00E04B JUMP INDUSTRIELLE
+00E049 MICROWI ELECTRONIC GmbH
+00E04A ENHANCED MESSAGING SYSTEMS, INC
+00E04B JUMP INDUSTRIELLE COMPUTERTECHNIK GmbH
 00E04C REALTEK SEMICONDUCTOR CORP.
 00E04D INTERNET INITIATIVE JAPAN, INC
 00E04E SANYO DENKI CO., LTD.
 00E04F CISCO SYSTEMS, INC.
-00E050 EXECUTONE INFORMATION
+00E050 EXECUTONE INFORMATION SYSTEMS, INC.
 00E051 TALX CORPORATION
 00E052 FOUNDRY NETWORKS, INC.
 00E053 CELLPORT LABS, INC.
 00E054 KODAI HITEC CO., LTD.
-00E055 INGENIERIA ELECTRONICA
+00E055 INGENIERIA ELECTRONICA COMERCIAL INELCOM S.A.
 00E056 HOLONTECH CORPORATION
 00E057 HAN MICROTELECOM. CO., LTD.
 00E058 PHASE ONE DENMARK A/S
 00E059 CONTROLLED ENVIRONMENTS, LTD.
 00E05A GALEA NETWORK SECURITY
 00E05B WEST END SYSTEMS CORP.
-00E05C MATSUSHITA KOTOBUKI
+00E05C MATSUSHITA KOTOBUKI ELECTRONICS INDUSTRIES, LTD.
 00E05D UNITEC CO., LTD.
-00E05E JAPAN AVIATION ELECTRONICS
-00E05F E-NET, INC.
+00E05E JAPAN AVIATION ELECTRONICS INDUSTRY, LTD.
+00E05F e-Net, Inc.
 00E060 SHERWOOD
-00E061 EDGEPOINT NETWORKS, INC.
+00E061 EdgePoint Networks, Inc.
 00E062 HOST ENGINEERING
 00E063 CABLETRON - YAGO SYSTEMS, INC.
 00E064 SAMSUNG ELECTRONICS
 00E065 OPTICAL ACCESS INTERNATIONAL
-00E066 PROMAX SYSTEMS, INC.
-00E067 EAC AUTOMATION-CONSULTING GMBH
+00E066 ProMax Systems, Inc.
+00E067 eac AUTOMATION-CONSULTING GmbH
 00E068 MERRIMAC SYSTEMS INC.
-00E069 JAYCOR NETWORKS, INC.
+00E069 JAYCOR
 00E06A KAPSCH AG
 00E06B W&G SPECIAL PRODUCTS
-00E06C BALTIMORE TECHNOLOGIES, LTD.
+00E06C AEP Systems International Ltd
 00E06D COMPUWARE CORPORATION
-00E06E FAR SYSTEMS SPA
-00E06F TERAYON CORP.
+00E06E FAR SYSTEMS S.p.A.
+00E06F Terayon Communications Systems
 00E070 DH TECHNOLOGY
 00E071 EPIS MICROCOMPUTER
 00E072 LYNK
-00E073 NATIONAL AMUSEMENT
+00E073 NATIONAL AMUSEMENT NETWORK, INC.
 00E074 TIERNAN COMMUNICATIONS, INC.
-00E075 ATLAS COMPUTER EQUIPMENT, INC.
+00E075 Verilink Corporation
 00E076 DEVELOPMENT CONCEPTS, INC.
 00E077 WEBGEAR, INC.
 00E078 BERKELEY NETWORKS
@@ -4631,7 +6747,7 @@
 00E07C METTLER-TOLEDO, INC.
 00E07D NETRONIX, INC.
 00E07E WALT DISNEY IMAGINEERING
-00E07F LOGISTISTEM SRL
+00E07F LOGISTISTEM s.r.l.
 00E080 CONTROL RESOURCES CORPORATION
 00E081 TYAN COMPUTER CORP.
 00E082 ANERMA
@@ -4639,11 +6755,11 @@
 00E084 COMPULITE R&D
 00E085 GLOBAL MAINTECH, INC.
 00E086 CYBEX COMPUTER PRODUCTS
-00E087 LECROY
+00E087 LeCroy - Networking Productions Division
 00E088 LTX CORPORATION
 00E089 ION Networks, Inc.
 00E08A GEC AVERY, LTD.
-00E08B QLOGIC CORP.
+00E08B QLogic Corp.
 00E08C NEOPARADIGM LABS, INC.
 00E08D PRESSURE SYSTEMS, INC.
 00E08E UTSTARCOM
@@ -4653,10 +6769,10 @@
 00E092 ADMTEK INCORPORATED
 00E093 ACKFIN NETWORKS
 00E094 OSAI SRL
-00E095 ADVANCED-VISION TECHNOLGIES
+00E095 ADVANCED-VISION TECHNOLGIES CORP.
 00E096 SHIMADZU CORPORATION
 00E097 CARRIER ACCESS CORPORATION
-00E098 ABOCOM SYSTEMS, INC.
+00E098 AboCom Systems, Inc.
 00E099 SAMSON AG
 00E09A POSITRON INDUSTRIES, INC.
 00E09B ENGAGE NETWORKS, INC.
@@ -4665,78 +6781,78 @@
 00E09E QUANTUM CORPORATION
 00E09F PIXEL VISION
 00E0A0 WILTRON CO.
-00E0A1 HIMA PAUL HILDEBRANDT
+00E0A1 HIMA PAUL HILDEBRANDT GmbH Co. KG
 00E0A2 MICROSLATE INC.
 00E0A3 CISCO SYSTEMS, INC.
-00E0A4 ESAOTE S.P.A.
-00E0A5 COMCORE SEMICONDUCTOR, INC.
+00E0A4 ESAOTE S.p.A.
+00E0A5 ComCore Semiconductor, Inc.
 00E0A6 TELOGY NETWORKS, INC.
 00E0A7 IPC INFORMATION SYSTEMS, INC.
-00E0A8 SAT GMBH&CO
+00E0A8 SAT GmbH & Co.
 00E0A9 FUNAI ELECTRIC CO., LTD.
 00E0AA ELECTROSONIC LTD.
 00E0AB DIMAT S.A.
 00E0AC MIDSCO, INC.
 00E0AD EES TECHNOLOGY, LTD.
 00E0AE XAQTI CORPORATION
-00E0AF GENERAL DYNAMICS INFORMATION
+00E0AF GENERAL DYNAMICS INFORMATION SYSTEMS
 00E0B0 CISCO SYSTEMS, INC.
 00E0B1 PACKET ENGINES, INC.
 00E0B2 TELMAX COMMUNICATIONS CORP.
-00E0B3 ETHERWAN SYSTEMS, INC.
+00E0B3 EtherWAN Systems, Inc.
 00E0B4 TECHNO SCOPE CO., LTD.
 00E0B5 ARDENT COMMUNICATIONS CORP.
 00E0B6 Entrada Networks
 00E0B7 PI GROUP, LTD.
 00E0B8 GATEWAY 2000
 00E0B9 BYAS SYSTEMS
-00E0BA BERGHOF AUTOMATIONSTECHNIK
+00E0BA BERGHOF AUTOMATIONSTECHNIK GmbH
 00E0BB NBX CORPORATION
 00E0BC SYMON COMMUNICATIONS, INC.
 00E0BD INTERFACE SYSTEMS, INC.
 00E0BE GENROCO INTERNATIONAL, INC.
-00E0BF TORRENT NETWORKING
-00E0C0 SEIWA ERECTRIC MFG. CO., LTD.
+00E0BF TORRENT NETWORKING TECHNOLOGIES CORP.
+00E0C0 SEIWA ELECTRIC MFG. CO., LTD.
 00E0C1 MEMOREX TELEX JAPAN, LTD.
-00E0C2 NECSY SPA
+00E0C2 NECSY S.p.A.
 00E0C3 SAKAI SYSTEM DEVELOPMENT CORP.
 00E0C4 HORNER ELECTRIC, INC.
 00E0C5 BCOM ELECTRONICS INC.
 00E0C6 LINK2IT, L.L.C.
 00E0C7 EUROTECH SRL
 00E0C8 VIRTUAL ACCESS, LTD.
-00E0C9 AUTOMATEDLOGIC CORPORATION
+00E0C9 AutomatedLogic Corporation
 00E0CA BEST DATA PRODUCTS
 00E0CB RESON, INC.
 00E0CC HERO SYSTEMS, LTD.
 00E0CD SENSIS CORPORATION
 00E0CE ARN
-00E0CF INTEGRATED DEVICE
+00E0CF INTEGRATED DEVICE TECHNOLOGY, INC.
 00E0D0 NETSPEED, INC.
 00E0D1 TELSIS LIMITED
 00E0D2 VERSANET COMMUNICATIONS, INC.
-00E0D3 DATENTECHNIK GMBH
+00E0D3 DATENTECHNIK GmbH
 00E0D4 EXCELLENT COMPUTER
 00E0D5 ARCXEL TECHNOLOGIES, INC.
-00E0D6 COMPUTER & COMMUNICATION
+00E0D6 COMPUTER & COMMUNICATION RESEARCH LAB.
 00E0D7 SUNSHINE ELECTRONICS, INC.
-00E0D8 LANBIT COMPUTER, INC.
+00E0D8 LANBit Computer, Inc.
 00E0D9 TAZMO CO., LTD.
-00E0DA ASSURED ACCESS
-00E0DB VIAVIDEO COMMUNICATIONS
+00E0DA ASSURED ACCESS TECHNOLOGY, INC.
+00E0DB ViaVideo Communications, Inc.
 00E0DC NEXWARE CORP.
 00E0DD ZENITH ELECTRONICS CORPORATION
 00E0DE DATAX NV
 00E0DF KE KOMMUNIKATIONS-ELECTRONIK
 00E0E0 SI ELECTRONICS, LTD.
-00E0E1 G2 NETWORKS, ILNC.
+00E0E1 G2 NETWORKS, INC.
 00E0E2 INNOVA CORP.
-00E0E3 SK-ELEKTRONIK GMBH
-00E0E4 FANUC ROBOTICS NORTH AMERICA,
+00E0E3 SK-ELEKTRONIK GmbH
+00E0E4 FANUC ROBOTICS NORTH AMERICA, Inc.
 00E0E5 CINCO NETWORKS, INC.
 00E0E6 INCAA DATACOM B.V.
 00E0E7 RAYTHEON E-SYSTEMS, INC.
-00E0E8 GRETACODER DATA SYSTEMS AG
+00E0E8 GRETACODER Data Systems AG
 00E0E9 DATA LABS, INC.
 00E0EA INNOVAT COMMUNICATIONS, INC.
 00E0EB DIGICOM SYSTEMS, INCORPORATED
@@ -4747,19 +6863,19 @@
 00E0F0 ABLER TECHNOLOGY, INC.
 00E0F1 THAT CORPORATION
 00E0F2 ARLOTTO COMNET, INC.
-00E0F3 WEBSPRINT COMMUNICATIONS, INC.
-00E0F4 INSIDE TECHNOLOGY A/S
+00E0F3 WebSprint Communications, Inc.
+00E0F4 INSIDE Technology A/S
 00E0F5 TELES AG
 00E0F6 DECISION EUROPE
 00E0F7 CISCO SYSTEMS, INC.
-00E0F8 DIANA CONTROL AB
+00E0F8 DICNA CONTROL AB
 00E0F9 CISCO SYSTEMS, INC.
 00E0FA TRL TECHNOLOGY, LTD.
 00E0FB LEIGHTRONIX, INC.
 00E0FC HUAWEI TECHNOLOGIES CO., LTD.
 00E0FD A-TREND TECHNOLOGY CO., LTD.
 00E0FE CISCO SYSTEMS, INC.
-00E0FF SECURITY DYNAMICS TECHNOLOGIES
+00E0FF SECURITY DYNAMICS TECHNOLOGIES, Inc.
 00E6D3 NIXDORF COMPUTER CORP.
 020701 RACAL-DATACOM
 021C7C PERQ SYSTEMS CORPORATION
@@ -4809,12 +6925,12 @@
 080020 SUN MICROSYSTEMS INC.
 080021 3M COMPANY
 080022 NBI INC.
-080023 MATSUHITA GRAPHIC COMM SYS INC
+080023 Panasonic Communications Co., Ltd.
 080024 10NET COMMUNICATIONS/DCA
 080025 CONTROL DATA
 080026 NORSK DATA A.S.
 080027 CADMUS COMPUTER SYSTEMS
-080028 TEXAS INSTRUMENTS
+080028 Texas Instruments
 080029 MEGATEK CORPORATION
 08002A MOSAIC TECHNOLOGIES INC.
 08002B DIGITAL EQUIPMENT CORPORATION
@@ -4905,10 +7021,10 @@
 080080 AES DATA INC.
 080081 ,ASTECH INC.
 080082 VERITAS SOFTWARE
-080083 SEIKO INSTRUM. AND ELECTRONICS
+080083 Seiko Instruments Inc.
 080084 TOMEN ELECTRONICS CORP.
 080085 ELXSI
-080086 IMAGEN CORPORATION
+080086 KONICA MINOLTA HOLDINGS, INC.
 080087 XYPLEX
 080088 MCDATA CORPORATION
 080089 KINETICS
@@ -4919,7 +7035,8 @@
 08008E TANDEM COMPUTERS
 08008F CHIPCOM CORPORATION
 080090 SONOMA SYSTEMS
-08BBCC AK-NORD EDV VERTRIEBSGES. MBH
+081443 UNIBRAIN S.A.
+08BBCC AK-NORD EDV VERTRIEBSGES. mbH
 10005A IBM CORPORATION
 1000E8 NATIONAL SEMICONDUCTOR
 800010 ATT BELL LABORATORIES
diff -purN linux-2.6.1/drivers/ieee1394/raw1394.c linux-2.5/drivers/ieee1394/raw1394.c
--- linux-2.6.1/drivers/ieee1394/raw1394.c	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/drivers/ieee1394/raw1394.c	2004-01-14 23:12:05.000000000 +0000
@@ -38,6 +38,7 @@
 #include <linux/smp_lock.h>
 #include <linux/interrupt.h>
 #include <linux/vmalloc.h>
+#include <linux/cdev.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <linux/devfs_fs_kernel.h>
@@ -1695,7 +1696,7 @@ static int arm_register(struct file_info
                 spin_unlock_irqrestore(&host_info_lock, flags);
                 return sizeof(struct raw1394_request);
         }
-        retval = hpsb_register_addrspace(&raw1394_highlevel, &arm_ops, req->req.address,
+        retval = hpsb_register_addrspace(&raw1394_highlevel, fi->host, &arm_ops, req->req.address,
                 req->req.address + req->req.length);
         if (retval) {
                /* INSERT ENTRY */
@@ -1782,7 +1783,7 @@ static int arm_unregister(struct file_in
                 spin_unlock_irqrestore(&host_info_lock, flags);
                 return sizeof(struct raw1394_request);
         } 
-        retval = hpsb_unregister_addrspace(&raw1394_highlevel, addr->start);
+        retval = hpsb_unregister_addrspace(&raw1394_highlevel, fi->host, addr->start);
         if (!retval) {
                 printk(KERN_ERR "raw1394: arm_Unregister failed -> EINVAL\n");
                 spin_unlock_irqrestore(&host_info_lock, flags);
@@ -2464,10 +2465,6 @@ static int raw1394_open(struct inode *in
 {
         struct file_info *fi;
 
-        if (ieee1394_file_to_instance(file) > 0) {
-                return -ENXIO;
-        }
-
         fi = kmalloc(sizeof(struct file_info), SLAB_KERNEL);
         if (fi == NULL)
                 return -ENOMEM;
@@ -2554,7 +2551,7 @@ static int raw1394_release(struct inode 
                 }
                 if (!another_host) {
                         DBGMSG("raw1394_release: call hpsb_arm_unregister");
-                        retval = hpsb_unregister_addrspace(&raw1394_highlevel, addr->start);
+                        retval = hpsb_unregister_addrspace(&raw1394_highlevel, fi->host, addr->start);
                         if (!retval) {
                                 ++fail;
                                 printk(KERN_ERR "raw1394_release arm_Unregister failed\n");
@@ -2646,7 +2643,8 @@ static struct hpsb_highlevel raw1394_hig
         .fcp_request = fcp_request,
 };
 
-static struct file_operations file_ops = {
+static struct cdev raw1394_cdev;
+static struct file_operations raw1394_fops = {
 	.owner =	THIS_MODULE,
         .read =		raw1394_read, 
         .write =	raw1394_write,
@@ -2664,8 +2662,10 @@ static int __init init_raw1394(void)
         devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16),
 			S_IFCHR | S_IRUSR | S_IWUSR, RAW1394_DEVICE_NAME);
 
-        if (ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_RAW1394,
-                                      THIS_MODULE, &file_ops)) {
+	cdev_init(&raw1394_cdev, &raw1394_fops);
+	raw1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&raw1394_cdev.kobj, RAW1394_DEVICE_NAME);
+	if (cdev_add(&raw1394_cdev, IEEE1394_RAW1394_DEV, 1)) {
                 HPSB_ERR("raw1394 failed to register minor device block");
                 devfs_remove(RAW1394_DEVICE_NAME);
                 hpsb_unregister_highlevel(&raw1394_highlevel);
@@ -2682,7 +2682,8 @@ static int __init init_raw1394(void)
 static void __exit cleanup_raw1394(void)
 {
 	hpsb_unregister_protocol(&raw1394_driver);
-        ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_RAW1394);
+	cdev_unmap(IEEE1394_RAW1394_DEV, 1);
+	cdev_del(&raw1394_cdev);
         devfs_remove(RAW1394_DEVICE_NAME);
         hpsb_unregister_highlevel(&raw1394_highlevel);
 }
@@ -2690,3 +2691,4 @@ static void __exit cleanup_raw1394(void)
 module_init(init_raw1394);
 module_exit(cleanup_raw1394);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16);
diff -purN linux-2.6.1/drivers/ieee1394/sbp2.c linux-2.5/drivers/ieee1394/sbp2.c
--- linux-2.6.1/drivers/ieee1394/sbp2.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/ieee1394/sbp2.c	2004-01-14 23:20:31.000000000 +0000
@@ -77,7 +77,7 @@
 #include "sbp2.h"
 
 static char version[] __devinitdata =
-	"$Rev: 1082 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1096 $ Ben Collins <bcollins@debian.org>";
 
 /*
  * Module load parameter definitions
@@ -712,6 +712,18 @@ static struct sbp2scsi_host_info *sbp2_a
 		return NULL;
 	}
 
+	/* Register our sbp2 status address space... */
+	hpsb_register_addrspace(&sbp2_highlevel, host, &sbp2_ops,
+				SBP2_STATUS_FIFO_ADDRESS,
+				SBP2_STATUS_FIFO_ADDRESS +
+				SBP2_STATUS_FIFO_ENTRY_TO_OFFSET(SBP2SCSI_MAX_SCSI_IDS+1));
+
+	/* Handle data movement if physical dma is not enabled/supported
+	 * on host controller */
+#ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
+	hpsb_register_addrspace(&sbp2_highlevel, host, &sbp2_physdma_ops, 0x0ULL, 0xfffffffcULL);
+#endif
+
 	hi = hpsb_create_hostinfo(&sbp2_highlevel, host, sizeof(*hi));
 	if (!hi) {
 		SBP2_ERR("failed to allocate hostinfo");
@@ -2881,17 +2893,6 @@ static int sbp2_module_init(void)
 	/* Register our high level driver with 1394 stack */
 	hpsb_register_highlevel(&sbp2_highlevel);
 
-	/* Register our sbp2 status address space... */
-	hpsb_register_addrspace(&sbp2_highlevel, &sbp2_ops, SBP2_STATUS_FIFO_ADDRESS,
-				SBP2_STATUS_FIFO_ADDRESS + 
-				SBP2_STATUS_FIFO_ENTRY_TO_OFFSET(SBP2SCSI_MAX_SCSI_IDS+1));
-
-	/* Handle data movement if physical dma is not enabled/supported
-	 * on host controller */
-#ifdef CONFIG_IEEE1394_SBP2_PHYS_DMA
-	hpsb_register_addrspace(&sbp2_highlevel, &sbp2_physdma_ops, 0x0ULL, 0xfffffffcULL);
-#endif
-
 	hpsb_register_protocol(&sbp2_driver);
 
 	return 0;
diff -purN linux-2.6.1/drivers/ieee1394/video1394.c linux-2.5/drivers/ieee1394/video1394.c
--- linux-2.6.1/drivers/ieee1394/video1394.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/drivers/ieee1394/video1394.c	2004-01-14 23:10:13.000000000 +0000
@@ -46,6 +46,7 @@
 #include <linux/mm.h>
 #include <linux/ioctl32.h>
 #include <linux/compat.h>
+#include <linux/cdev.h>
 
 #include "ieee1394.h"
 #include "ieee1394_types.h"
@@ -1231,6 +1232,7 @@ static int video1394_release(struct inod
 	return 0;
 }
 
+static struct cdev video1394_cdev;
 static struct file_operations video1394_fops=
 {
 	.owner =	THIS_MODULE,
@@ -1445,18 +1447,18 @@ static void __exit video1394_exit_module
 	hpsb_unregister_highlevel(&video1394_highlevel);
 
 	devfs_remove(VIDEO1394_DRIVER_NAME);
-	ieee1394_unregister_chardev(IEEE1394_MINOR_BLOCK_VIDEO1394);
+	cdev_unmap(IEEE1394_VIDEO1394_DEV, 16);
+	cdev_del(&video1394_cdev);
 
 	PRINT_G(KERN_INFO, "Removed " VIDEO1394_DRIVER_NAME " module");
 }
 
 static int __init video1394_init_module (void)
 {
-	int ret;
-
-	ret = ieee1394_register_chardev(IEEE1394_MINOR_BLOCK_VIDEO1394,
-					THIS_MODULE, &video1394_fops);
-	if (ret) {
+	cdev_init(&video1394_cdev, &video1394_fops);
+	video1394_cdev.owner = THIS_MODULE;
+	kobject_set_name(&video1394_cdev.kobj, VIDEO1394_DRIVER_NAME);
+	if (cdev_add(&video1394_cdev, IEEE1394_VIDEO1394_DEV, 16)) {
 		PRINT_G(KERN_ERR, "video1394: unable to get minor device block");
 		return -EIO;
         }
@@ -1468,25 +1470,29 @@ static int __init video1394_init_module 
 	hpsb_register_protocol(&video1394_driver);
 
 #ifdef CONFIG_COMPAT
-	/* First the compatible ones */
-	ret = register_ioctl32_conversion(VIDEO1394_IOC_LISTEN_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNLISTEN_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_CHANNEL, NULL);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNTALK_CHANNEL, NULL);
-
-	/* These need translation */
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_QUEUE_BUFFER,
-				    video1394_w_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_WAIT_BUFFER,
-				    video1394_wr_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_QUEUE_BUFFER,
-				    video1394_queue_buf32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_TALK_WAIT_BUFFER,
-				    video1394_w_wait32);
-	ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_POLL_BUFFER,
-				    video1394_wr_wait32);
-	if (ret)
-		PRINT_G(KERN_INFO, "Error registering ioctl32 translations");
+	{
+		int ret;
+
+		/* First the compatible ones */
+		ret = register_ioctl32_conversion(VIDEO1394_IOC_LISTEN_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNLISTEN_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_CHANNEL, NULL);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_UNTALK_CHANNEL, NULL);
+
+		/* These need translation */
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_QUEUE_BUFFER,
+					    video1394_w_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_WAIT_BUFFER,
+					    video1394_wr_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC_TALK_QUEUE_BUFFER,
+					    video1394_queue_buf32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_TALK_WAIT_BUFFER,
+					    video1394_w_wait32);
+		ret |= register_ioctl32_conversion(VIDEO1394_IOC32_LISTEN_POLL_BUFFER,
+					    video1394_wr_wait32);
+		if (ret)
+			PRINT_G(KERN_INFO, "Error registering ioctl32 translations");
+	}
 #endif
 
 	PRINT_G(KERN_INFO, "Installed " VIDEO1394_DRIVER_NAME " module");
@@ -1496,3 +1502,4 @@ static int __init video1394_init_module 
 
 module_init(video1394_init_module);
 module_exit(video1394_exit_module);
+MODULE_ALIAS_CHARDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_VIDEO1394 * 16);
diff -purN linux-2.6.1/drivers/net/Kconfig linux-2.5/drivers/net/Kconfig
--- linux-2.6.1/drivers/net/Kconfig	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/Kconfig	2004-01-10 15:59:02.000000000 +0000
@@ -1283,6 +1283,19 @@ config B44
 	  <file:Documentation/networking/net-modules.txt>.  The module will be
 	  called b44.
 
+config FORCEDETH
+	tristate "Reverse Engineered nForce Ethernet support (EXPERIMENTAL)"
+	depends on NET_PCI && PCI && EXPERIMENTAL
+	help
+	  If you have a network (Ethernet) controller of this type, say Y and
+	  read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  To compile this driver as a module, choose M here and read
+	  <file:Documentation/networking/net-modules.txt>.  The module will be
+	  called forcedeth.
+
+
 config CS89x0
 	tristate "CS89x0 support"
 	depends on NET_PCI && ISA
diff -purN linux-2.6.1/drivers/net/Makefile linux-2.5/drivers/net/Makefile
--- linux-2.6.1/drivers/net/Makefile	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/Makefile	2004-01-10 15:59:02.000000000 +0000
@@ -95,6 +95,7 @@ obj-$(CONFIG_LNE390) += lne390.o 8390.o
 obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_NET_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
+obj-$(CONFIG_FORCEDETH) += forcedeth.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
diff -purN linux-2.6.1/drivers/net/forcedeth.c linux-2.5/drivers/net/forcedeth.c
--- linux-2.6.1/drivers/net/forcedeth.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/net/forcedeth.c	2004-01-11 06:09:27.000000000 +0000
@@ -0,0 +1,1499 @@
+/*
+ * forcedeth: Ethernet driver for NVIDIA nForce media access controllers.
+ *
+ * Note: This driver is a cleanroom reimplementation based on reverse
+ *      engineered documentation written by Carl-Daniel Hailfinger
+ *      and Andrew de Quincey. It's neither supported nor endorsed
+ *      by NVIDIA Corp. Use at your own risk.
+ *
+ * NVIDIA, nForce and other NVIDIA marks are trademarks or registered
+ * trademarks of NVIDIA Corporation in the United States and other
+ * countries.
+ *
+ * Copyright (C) 2003 Manfred Spraul
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Changelog:
+ * 	0.01: 05 Oct 2003: First release that compiles without warnings.
+ * 	0.02: 05 Oct 2003: Fix bug for drain_tx: do not try to free NULL skbs.
+ * 			   Check all PCI BARs for the register window.
+ * 			   udelay added to mii_rw.
+ * 	0.03: 06 Oct 2003: Initialize dev->irq.
+ * 	0.04: 07 Oct 2003: Initialize np->lock, reduce handled irqs, add printks.
+ * 	0.05: 09 Oct 2003: printk removed again, irq status print tx_timeout.
+ * 	0.06: 10 Oct 2003: MAC Address read updated, pff flag generation updated,
+ * 			   irq mask updated
+ * 	0.07: 14 Oct 2003: Further irq mask updates.
+ * 	0.08: 20 Oct 2003: rx_desc.Length initialization added, alloc_rx refill
+ * 			   added into irq handler, NULL check for drain_ring.
+ * 	0.09: 20 Oct 2003: Basic link speed irq implementation. Only handle the
+ * 			   requested interrupt sources.
+ * 	0.10: 20 Oct 2003: First cleanup for release.
+ * 	0.11: 21 Oct 2003: hexdump for tx added, rx buffer sizes increased.
+ * 			   MAC Address init fix, set_multicast cleanup.
+ * 	0.12: 23 Oct 2003: Cleanups for release.
+ * 	0.13: 25 Oct 2003: Limit for concurrent tx packets increased to 10.
+ * 			   Set link speed correctly. start rx before starting
+ * 			   tx (start_rx sets the link speed).
+ * 	0.14: 25 Oct 2003: Nic dependant irq mask.
+ * 	0.15: 08 Nov 2003: fix smp deadlock with set_multicast_list during
+ * 			   open.
+ * 	0.16: 15 Nov 2003: include file cleanup for ppc64, rx buffer size
+ * 			   increased to 1628 bytes.
+ * 	0.17: 16 Nov 2003: undo rx buffer size increase. Substract 1 from
+ * 			   the tx length.
+ * 	0.18: 17 Nov 2003: fix oops due to late initialization of dev_stats
+ * 	0.19: 29 Nov 2003: Handle RxNoBuf, detect & handle invalid mac
+ * 			   addresses, really stop rx if already running
+ * 			   in start_rx, clean up a bit.
+ * 				(C) Carl-Daniel Hailfinger
+ * 	0.20: 07 Dev 2003: alloc fixes
+ *
+ * Known bugs:
+ * The irq handling is wrong - no tx done interrupts are generated.
+ * This means recovery from netif_stop_queue only happens in the hw timer
+ * interrupt (1/2 second on nForce2, 1/100 second on nForce3), or if an
+ * rx packet arrives by chance.
+ */
+#define FORCEDETH_VERSION		"0.19"
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/random.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+
+#if 0
+#define dprintk			printk
+#else
+#define dprintk(x...)		do { } while (0)
+#endif
+
+
+/*
+ * Hardware access:
+ */
+
+#define DEV_NEED_LASTPACKET1	0x0001
+#define DEV_IRQMASK_1		0x0002
+#define DEV_IRQMASK_2		0x0004
+
+enum {
+	NvRegIrqStatus = 0x000,
+#define NVREG_IRQSTAT_MIIEVENT	0x040
+#define NVREG_IRQSTAT_MASK		0x1ff
+	NvRegIrqMask = 0x004,
+#define NVREG_IRQ_RX			0x0002
+#define NVREG_IRQ_RX_NOBUF		0x0004
+#define NVREG_IRQ_TX_ERR		0x0008
+#define NVREG_IRQ_TX2			0x0010
+#define NVREG_IRQ_TIMER			0x0020
+#define NVREG_IRQ_LINK			0x0040
+#define NVREG_IRQ_TX1			0x0100
+#define NVREG_IRQMASK_WANTED_1		0x005f
+#define NVREG_IRQMASK_WANTED_2		0x0147
+#define NVREG_IRQ_UNKNOWN		(~(NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF|NVREG_IRQ_TX_ERR|NVREG_IRQ_TX2|NVREG_IRQ_TIMER|NVREG_IRQ_LINK|NVREG_IRQ_TX1))
+
+	NvRegUnknownSetupReg6 = 0x008,
+#define NVREG_UNKSETUP6_VAL		3
+
+	NvRegPollingInterval = 0x00c,
+	NvRegMisc1 = 0x080,
+#define NVREG_MISC1_HD		0x02
+#define NVREG_MISC1_FORCE	0x3b0f3c
+
+	NvRegTransmitterControl = 0x084,
+#define NVREG_XMITCTL_START	0x01
+	NvRegTransmitterStatus = 0x088,
+#define NVREG_XMITSTAT_BUSY	0x01
+
+	NvRegPacketFilterFlags = 0x8c,
+#define NVREG_PFF_ALWAYS	0x7F0008
+#define NVREG_PFF_PROMISC	0x80
+#define NVREG_PFF_MYADDR	0x20
+
+	NvRegOffloadConfig = 0x90,
+#define NVREG_OFFLOAD_HOMEPHY	0x601
+#define NVREG_OFFLOAD_NORMAL	0x5ee
+	NvRegReceiverControl = 0x094,
+#define NVREG_RCVCTL_START	0x01
+	NvRegReceiverStatus = 0x98,
+#define NVREG_RCVSTAT_BUSY	0x01
+
+	NvRegRandomSeed = 0x9c,
+#define NVREG_RNDSEED_MASK	0x00ff
+#define NVREG_RNDSEED_FORCE	0x7f00
+
+	NvRegUnknownSetupReg1 = 0xA0,
+#define NVREG_UNKSETUP1_VAL	0x16070f
+	NvRegUnknownSetupReg2 = 0xA4,
+#define NVREG_UNKSETUP2_VAL	0x16
+	NvRegMacAddrA = 0xA8,
+	NvRegMacAddrB = 0xAC,
+	NvRegMulticastAddrA = 0xB0,
+#define NVREG_MCASTADDRA_FORCE	0x01
+	NvRegMulticastAddrB = 0xB4,
+	NvRegMulticastMaskA = 0xB8,
+	NvRegMulticastMaskB = 0xBC,
+
+	NvRegTxRingPhysAddr = 0x100,
+	NvRegRxRingPhysAddr = 0x104,
+	NvRegRingSizes = 0x108,
+#define NVREG_RINGSZ_TXSHIFT 0
+#define NVREG_RINGSZ_RXSHIFT 16
+	NvRegUnknownTransmitterReg = 0x10c,
+	NvRegLinkSpeed = 0x110,
+#define NVREG_LINKSPEED_FORCE 0x10000
+#define NVREG_LINKSPEED_10	10
+#define NVREG_LINKSPEED_100	100
+#define NVREG_LINKSPEED_1000	1000
+	NvRegUnknownSetupReg5 = 0x130,
+#define NVREG_UNKSETUP5_BIT31	(1<<31)
+	NvRegUnknownSetupReg3 = 0x134,
+#define NVREG_UNKSETUP3_VAL1	0x200010
+	NvRegTxRxControl = 0x144,
+#define NVREG_TXRXCTL_KICK	0x0001
+#define NVREG_TXRXCTL_BIT1	0x0002
+#define NVREG_TXRXCTL_BIT2	0x0004
+#define NVREG_TXRXCTL_IDLE	0x0008
+#define NVREG_TXRXCTL_RESET	0x0010
+	NvRegMIIStatus = 0x180,
+#define NVREG_MIISTAT_ERROR		0x0001
+#define NVREG_MIISTAT_LINKCHANGE	0x0008
+#define NVREG_MIISTAT_MASK		0x000f
+#define NVREG_MIISTAT_MASK2		0x000f
+	NvRegUnknownSetupReg4 = 0x184,
+#define NVREG_UNKSETUP4_VAL	8
+
+	NvRegAdapterControl = 0x188,
+#define NVREG_ADAPTCTL_START	0x02
+#define NVREG_ADAPTCTL_LINKUP	0x04
+#define NVREG_ADAPTCTL_PHYVALID	0x4000
+#define NVREG_ADAPTCTL_RUNNING	0x100000
+#define NVREG_ADAPTCTL_PHYSHIFT	24
+	NvRegMIISpeed = 0x18c,
+#define NVREG_MIISPEED_BIT8	(1<<8)
+#define NVREG_MIIDELAY	5
+	NvRegMIIControl = 0x190,
+#define NVREG_MIICTL_INUSE	0x10000
+#define NVREG_MIICTL_WRITE	0x08000
+#define NVREG_MIICTL_ADDRSHIFT	5
+	NvRegMIIData = 0x194,
+	NvRegWakeUpFlags = 0x200,
+#define NVREG_WAKEUPFLAGS_VAL		0x7770
+#define NVREG_WAKEUPFLAGS_BUSYSHIFT	24
+#define NVREG_WAKEUPFLAGS_ENABLESHIFT	16
+#define NVREG_WAKEUPFLAGS_D3SHIFT	12
+#define NVREG_WAKEUPFLAGS_D2SHIFT	8
+#define NVREG_WAKEUPFLAGS_D1SHIFT	4
+#define NVREG_WAKEUPFLAGS_D0SHIFT	0
+#define NVREG_WAKEUPFLAGS_ACCEPT_MAGPAT		0x01
+#define NVREG_WAKEUPFLAGS_ACCEPT_WAKEUPPAT	0x02
+#define NVREG_WAKEUPFLAGS_ACCEPT_LINKCHANGE	0x04
+
+	NvRegPatternCRC = 0x204,
+	NvRegPatternMask = 0x208,
+	NvRegPowerCap = 0x268,
+#define NVREG_POWERCAP_D3SUPP	(1<<30)
+#define NVREG_POWERCAP_D2SUPP	(1<<26)
+#define NVREG_POWERCAP_D1SUPP	(1<<25)
+	NvRegPowerState = 0x26c,
+#define NVREG_POWERSTATE_POWEREDUP	0x8000
+#define NVREG_POWERSTATE_VALID		0x0100
+#define NVREG_POWERSTATE_MASK		0x0003
+#define NVREG_POWERSTATE_D0		0x0000
+#define NVREG_POWERSTATE_D1		0x0001
+#define NVREG_POWERSTATE_D2		0x0002
+#define NVREG_POWERSTATE_D3		0x0003
+};
+
+struct ring_desc {
+	u32 PacketBuffer;
+	u16 Length;
+	u16 Flags;
+};
+
+#define NV_TX_LASTPACKET	(1<<0)
+#define NV_TX_RETRYERROR	(1<<3)
+#define NV_TX_LASTPACKET1	(1<<8)
+#define NV_TX_DEFERRED		(1<<10)
+#define NV_TX_CARRIERLOST	(1<<11)
+#define NV_TX_LATECOLLISION	(1<<12)
+#define NV_TX_UNDERFLOW		(1<<13)
+#define NV_TX_ERROR		(1<<14)
+#define NV_TX_VALID		(1<<15)
+
+#define NV_RX_DESCRIPTORVALID	(1<<0)
+#define NV_RX_MISSEDFRAME	(1<<1)
+#define NV_RX_SUBSTRACT1	(1<<3)
+#define NV_RX_ERROR1		(1<<7)
+#define NV_RX_ERROR2		(1<<8)
+#define NV_RX_ERROR3		(1<<9)
+#define NV_RX_ERROR4		(1<<10)
+#define NV_RX_CRCERR		(1<<11)
+#define NV_RX_OVERFLOW		(1<<12)
+#define NV_RX_FRAMINGERR	(1<<13)
+#define NV_RX_ERROR		(1<<14)
+#define NV_RX_AVAIL		(1<<15)
+
+/* Miscelaneous hardware related defines: */
+#define NV_PCI_REGSZ		0x270
+
+/* various timeout delays: all in usec */
+#define NV_TXRX_RESET_DELAY	4
+#define NV_TXSTOP_DELAY1	10
+#define NV_TXSTOP_DELAY1MAX	500000
+#define NV_TXSTOP_DELAY2	100
+#define NV_RXSTOP_DELAY1	10
+#define NV_RXSTOP_DELAY1MAX	500000
+#define NV_RXSTOP_DELAY2	100
+#define NV_SETUP5_DELAY		5
+#define NV_SETUP5_DELAYMAX	50000
+#define NV_POWERUP_DELAY	5
+#define NV_POWERUP_DELAYMAX	5000
+#define NV_MIIBUSY_DELAY	50
+#define NV_MIIPHY_DELAY	10
+#define NV_MIIPHY_DELAYMAX	10000
+
+#define NV_WAKEUPPATTERNS	5
+#define NV_WAKEUPMASKENTRIES	4
+
+/* General driver defaults */
+#define NV_WATCHDOG_TIMEO	(2*HZ)
+#define DEFAULT_MTU		1500	/* also maximum supported, at least for now */
+
+#define RX_RING		128
+#define TX_RING		16
+/* limited to 1 packet until we understand NV_TX_LASTPACKET */
+#define TX_LIMIT_STOP	10
+#define TX_LIMIT_START	5
+
+/* rx/tx mac addr + type + vlan + align + slack*/
+#define RX_NIC_BUFSIZE		(DEFAULT_MTU + 64)
+/* even more slack */
+#define RX_ALLOC_BUFSIZE	(DEFAULT_MTU + 128)
+
+#define OOM_REFILL	(1+HZ/20)
+#define POLL_WAIT	(1+HZ/100)
+
+/*
+ * SMP locking:
+ * All hardware access under dev->priv->lock, except the performance
+ * critical parts:
+ * - rx is (pseudo-) lockless: it relies on the single-threading provided
+ * 	by the arch code for interrupts.
+ * - tx setup is lockless: it relies on dev->xmit_lock. Actual submission
+ *	needs dev->priv->lock :-(
+ * - set_multicast_list: preparation lockless, relies on dev->xmit_lock.
+ */
+
+/* in dev: base, irq */
+struct fe_priv {
+	spinlock_t lock;
+
+	/* General data:
+	 * Locking: spin_lock(&np->lock); */
+	struct net_device_stats stats;
+	int in_shutdown;
+	u32 linkspeed;
+	int duplex;
+	int phyaddr;
+
+	/* General data: RO fields */
+	dma_addr_t ring_addr;
+	struct pci_dev *pci_dev;
+	u32 orig_mac[2];
+	u32 irqmask;
+
+	/* rx specific fields.
+	 * Locking: Within irq hander or disable_irq+spin_lock(&np->lock);
+	 */
+	struct ring_desc *rx_ring;
+	unsigned int cur_rx, refill_rx;
+	struct sk_buff *rx_skbuff[RX_RING];
+	dma_addr_t rx_dma[RX_RING];
+	unsigned int rx_buf_sz;
+	struct timer_list oom_kick;
+	struct timer_list nic_poll;
+
+	/*
+	 * tx specific fields.
+	 */
+	struct ring_desc *tx_ring;
+	unsigned int next_tx, nic_tx;
+	struct sk_buff *tx_skbuff[TX_RING];
+	dma_addr_t tx_dma[TX_RING];
+	u16 tx_flags;
+};
+
+/*
+ * Maximum number of loops until we assume that a bit in the irq mask
+ * is stuck. Overridable with module param.
+ */
+static int max_interrupt_work = 5;
+
+static inline struct fe_priv *get_nvpriv(struct net_device *dev)
+{
+	return (struct fe_priv *) dev->priv;
+}
+
+static inline u8 *get_hwbase(struct net_device *dev)
+{
+	return (u8 *) dev->base_addr;
+}
+
+static inline void pci_push(u8 * base)
+{
+	/* force out pending posted writes */
+	readl(base);
+}
+
+static int reg_delay(struct net_device *dev, int offset, u32 mask, u32 target,
+				int delay, int delaymax, const char *msg)
+{
+	u8 *base = get_hwbase(dev);
+
+	pci_push(base);
+	do {
+		udelay(delay);
+		delaymax -= delay;
+		if (delaymax < 0) {
+			if (msg)
+				printk(msg);
+			return 1;
+		}
+	} while ((readl(base + offset) & mask) != target);
+	return 0;
+}
+
+#define MII_READ	(-1)
+/* mii_rw: read/write a register on the PHY.
+ *
+ * Caller must guarantee serialization
+ */
+static int mii_rw(struct net_device *dev, int addr, int miireg, int value)
+{
+	u8 *base = get_hwbase(dev);
+	int was_running;
+	u32 reg;
+	int retval;
+
+	writel(NVREG_MIISTAT_MASK, base + NvRegMIIStatus);
+	was_running = 0;
+	reg = readl(base + NvRegAdapterControl);
+	if (reg & NVREG_ADAPTCTL_RUNNING) {
+		was_running = 1;
+		writel(reg & ~NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+	}
+	reg = readl(base + NvRegMIIControl);
+	if (reg & NVREG_MIICTL_INUSE) {
+		writel(NVREG_MIICTL_INUSE, base + NvRegMIIControl);
+		udelay(NV_MIIBUSY_DELAY);
+	}
+
+	reg = NVREG_MIICTL_INUSE | (addr << NVREG_MIICTL_ADDRSHIFT) | miireg;
+	if (value != MII_READ) {
+		writel(value, base + NvRegMIIData);
+		reg |= NVREG_MIICTL_WRITE;
+	}
+	writel(reg, base + NvRegMIIControl);
+
+	if (reg_delay(dev, NvRegMIIControl, NVREG_MIICTL_INUSE, 0,
+			NV_MIIPHY_DELAY, NV_MIIPHY_DELAYMAX, NULL)) {
+		dprintk(KERN_DEBUG "%s: mii_rw of reg %d at PHY %d timed out.\n",
+				dev->name, miireg, addr);
+		retval = -1;
+	} else if (value != MII_READ) {
+		/* it was a write operation - fewer failures are detectable */
+		dprintk(KERN_DEBUG "%s: mii_rw wrote 0x%x to reg %d at PHY %d\n",
+				dev->name, value, miireg, addr);
+		retval = 0;
+	} else if (readl(base + NvRegMIIStatus) & NVREG_MIISTAT_ERROR) {
+		dprintk(KERN_DEBUG "%s: mii_rw of reg %d at PHY %d failed.\n",
+				dev->name, miireg, addr);
+		retval = -1;
+	} else {
+		/* FIXME: why is that required? */
+		udelay(50);
+		retval = readl(base + NvRegMIIData);
+		dprintk(KERN_DEBUG "%s: mii_rw read from reg %d at PHY %d: 0x%x.\n",
+				dev->name, miireg, addr, retval);
+	}
+	if (was_running) {
+		reg = readl(base + NvRegAdapterControl);
+		writel(reg | NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+	}
+	return retval;
+}
+
+static void start_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: start_rx\n", dev->name);
+	/* Already running? Stop it. */
+	if (readl(base + NvRegReceiverControl) & NVREG_RCVCTL_START) {
+		writel(0, base + NvRegReceiverControl);
+		pci_push(base);
+	}
+	writel(np->linkspeed, base + NvRegLinkSpeed);
+	pci_push(base);
+	writel(NVREG_RCVCTL_START, base + NvRegReceiverControl);
+	pci_push(base);
+}
+
+static void stop_rx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: stop_rx\n", dev->name);
+	writel(0, base + NvRegReceiverControl);
+	reg_delay(dev, NvRegReceiverStatus, NVREG_RCVSTAT_BUSY, 0,
+		       NV_RXSTOP_DELAY1, NV_RXSTOP_DELAY1MAX,
+		       KERN_INFO "stop_rx: ReceiverStatus remained busy");
+
+	udelay(NV_RXSTOP_DELAY2);
+	writel(0, base + NvRegLinkSpeed);
+}
+
+static void start_tx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: start_tx\n", dev->name);
+	writel(NVREG_XMITCTL_START, base + NvRegTransmitterControl);
+	pci_push(base);
+}
+
+static void stop_tx(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: stop_tx\n", dev->name);
+	writel(0, base + NvRegTransmitterControl);
+	reg_delay(dev, NvRegTransmitterStatus, NVREG_XMITSTAT_BUSY, 0,
+		       NV_TXSTOP_DELAY1, NV_TXSTOP_DELAY1MAX,
+		       KERN_INFO "stop_tx: TransmitterStatus remained busy");
+
+	udelay(NV_TXSTOP_DELAY2);
+	writel(0, base + NvRegUnknownTransmitterReg);
+}
+
+static void txrx_reset(struct net_device *dev)
+{
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: txrx_reset\n", dev->name);
+	writel(NVREG_TXRXCTL_BIT2 | NVREG_TXRXCTL_RESET, base + NvRegTxRxControl);
+	pci_push(base);
+	udelay(NV_TXRX_RESET_DELAY);
+	writel(NVREG_TXRXCTL_BIT2, base + NvRegTxRxControl);
+	pci_push(base);
+}
+
+/*
+ * get_stats: dev->get_stats function
+ * Get latest stats value from the nic.
+ * Called with read_lock(&dev_base_lock) held for read -
+ * only synchronized against unregister_netdevice.
+ */
+static struct net_device_stats *get_stats(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	/* It seems that the nic always generates interrupts and doesn't
+	 * accumulate errors internally. Thus the current values in np->stats
+	 * are already up to date.
+	 */
+	return &np->stats;
+}
+
+
+/*
+ * nic_ioctl: dev->do_ioctl function
+ * Called with rtnl_lock held.
+ */
+static int nic_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+/*
+ * alloc_rx: fill rx ring entries.
+ * Return 1 if the allocations for the skbs failed and the
+ * rx engine is without Available descriptors
+ */
+static int alloc_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	unsigned int refill_rx = np->refill_rx;
+
+	while (np->cur_rx != refill_rx) {
+		int nr = refill_rx % RX_RING;
+		struct sk_buff *skb;
+
+		if (np->rx_skbuff[nr] == NULL) {
+
+			skb = dev_alloc_skb(RX_ALLOC_BUFSIZE);
+			if (!skb)
+				break;
+
+			skb->dev = dev;
+			np->rx_skbuff[nr] = skb;
+		} else {
+			skb = np->rx_skbuff[nr];
+		}
+		np->rx_dma[nr] = pci_map_single(np->pci_dev, skb->data, skb->len,
+						PCI_DMA_FROMDEVICE);
+		np->rx_ring[nr].PacketBuffer = cpu_to_le32(np->rx_dma[nr]);
+		np->rx_ring[nr].Length = cpu_to_le16(RX_NIC_BUFSIZE);
+		wmb();
+		np->rx_ring[nr].Flags = cpu_to_le16(NV_RX_AVAIL);
+		dprintk(KERN_DEBUG "%s: alloc_rx: Packet  %d marked as Available\n",
+					dev->name, refill_rx);
+		refill_rx++;
+	}
+	np->refill_rx = refill_rx;
+	if (np->cur_rx - refill_rx == RX_RING)
+		return 1;
+	return 0;
+}
+
+static void do_rx_refill(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+
+	disable_irq(dev->irq);
+	if (alloc_rx(dev)) {
+		spin_lock(&np->lock);
+		if (!np->in_shutdown)
+			mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+		spin_unlock(&np->lock);
+	}
+	enable_irq(dev->irq);
+}
+
+static int init_ring(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+
+	np->next_tx = np->nic_tx = 0;
+	for (i = 0; i < TX_RING; i++) {
+		np->tx_ring[i].Flags = 0;
+	}
+
+	np->cur_rx = RX_RING;
+	np->refill_rx = 0;
+	for (i = 0; i < RX_RING; i++) {
+		np->rx_ring[i].Flags = 0;
+	}
+	return alloc_rx(dev);
+}
+
+static void drain_tx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+	for (i = 0; i < TX_RING; i++) {
+		np->tx_ring[i].Flags = 0;
+		if (np->tx_skbuff[i]) {
+			pci_unmap_single(np->pci_dev, np->tx_dma[i],
+						np->tx_skbuff[i]->len,
+						PCI_DMA_TODEVICE);
+			dev_kfree_skb(np->tx_skbuff[i]);
+			np->tx_skbuff[i] = NULL;
+			np->stats.tx_dropped++;
+		}
+	}
+}
+
+static void drain_rx(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int i;
+	for (i = 0; i < RX_RING; i++) {
+		np->rx_ring[i].Flags = 0;
+		wmb();
+		if (np->rx_skbuff[i]) {
+			pci_unmap_single(np->pci_dev, np->rx_dma[i],
+						np->rx_skbuff[i]->len,
+						PCI_DMA_FROMDEVICE);
+			dev_kfree_skb(np->rx_skbuff[i]);
+			np->rx_skbuff[i] = NULL;
+		}
+	}
+}
+
+static void drain_ring(struct net_device *dev)
+{
+	drain_tx(dev);
+	drain_rx(dev);
+}
+
+/*
+ * start_xmit: dev->hard_start_xmit function
+ * Called with dev->xmit_lock held.
+ */
+static int start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int nr = np->next_tx % TX_RING;
+
+	np->tx_skbuff[nr] = skb;
+	np->tx_dma[nr] = pci_map_single(np->pci_dev, skb->data,skb->len,
+					PCI_DMA_TODEVICE);
+
+	np->tx_ring[nr].PacketBuffer = cpu_to_le32(np->tx_dma[nr]);
+	np->tx_ring[nr].Length = cpu_to_le16(skb->len-1);
+
+	spin_lock_irq(&np->lock);
+	wmb();
+	np->tx_ring[nr].Flags = np->tx_flags;
+	dprintk(KERN_DEBUG "%s: start_xmit: packet packet %d queued for transmission.\n",
+				dev->name, np->next_tx);
+	{
+		int j;
+		for (j=0; j<64; j++) {
+			if ((j%16) == 0)
+				dprintk("\n%03x:", j);
+			dprintk(" %02x", ((unsigned char*)skb->data)[j]);
+		}
+		dprintk("\n");
+	}
+
+	np->next_tx++;
+
+	dev->trans_start = jiffies;
+	if (np->next_tx - np->nic_tx >= TX_LIMIT_STOP)
+		netif_stop_queue(dev);
+	spin_unlock_irq(&np->lock);
+	writel(NVREG_TXRXCTL_KICK, get_hwbase(dev) + NvRegTxRxControl);
+	return 0;
+}
+
+/*
+ * tx_done: check for completed packets, release the skbs.
+ *
+ * Caller must own np->lock.
+ */
+static void tx_done(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	while (np->nic_tx < np->next_tx) {
+		struct ring_desc *prd;
+		int i = np->nic_tx % TX_RING;
+
+		prd = &np->tx_ring[i];
+
+		dprintk(KERN_DEBUG "%s: tx_done: looking at packet %d, Flags 0x%x.\n",
+					dev->name, np->nic_tx, prd->Flags);
+		if (prd->Flags & cpu_to_le16(NV_TX_VALID))
+			break;
+		if (prd->Flags & cpu_to_le16(NV_TX_RETRYERROR|NV_TX_CARRIERLOST|NV_TX_LATECOLLISION|
+						NV_TX_UNDERFLOW|NV_TX_ERROR)) {
+			if (prd->Flags & cpu_to_le16(NV_TX_UNDERFLOW))
+				np->stats.tx_fifo_errors++;
+			if (prd->Flags & cpu_to_le16(NV_TX_CARRIERLOST))
+				np->stats.tx_carrier_errors++;
+			np->stats.tx_errors++;
+		} else {
+			np->stats.tx_packets++;
+			np->stats.tx_bytes += np->tx_skbuff[i]->len;
+		}
+		pci_unmap_single(np->pci_dev, np->tx_dma[i],
+					np->tx_skbuff[i]->len,
+					PCI_DMA_TODEVICE);
+		dev_kfree_skb_irq(np->tx_skbuff[i]);
+		np->tx_skbuff[i] = NULL;
+		np->nic_tx++;
+	}
+	if (np->next_tx - np->nic_tx < TX_LIMIT_START)
+		netif_wake_queue(dev);
+}
+
+/*
+ * tx_timeout: dev->tx_timeout function
+ * Called with dev->xmit_lock held.
+ */
+static void tx_timeout(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	dprintk(KERN_DEBUG "%s: Got tx_timeout. irq: %08x\n", dev->name,
+			readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK);
+
+	spin_lock_irq(&np->lock);
+
+	/* 1) stop tx engine */
+	stop_tx(dev);
+
+	/* 2) check that the packets were not sent already: */
+	tx_done(dev);
+
+	/* 3) if there are dead entries: clear everything */
+	if (np->next_tx != np->nic_tx) {
+		printk(KERN_DEBUG "%s: tx_timeout: dead entries!\n", dev->name);
+		drain_tx(dev);
+		np->next_tx = np->nic_tx = 0;
+		writel((u32) (np->ring_addr + RX_RING*sizeof(struct ring_desc)), base + NvRegTxRingPhysAddr);
+		netif_wake_queue(dev);
+	}
+
+	/* 4) restart tx engine */
+	start_tx(dev);
+	spin_unlock_irq(&np->lock);
+}
+
+static void rx_process(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	for (;;) {
+		struct ring_desc *prd;
+		struct sk_buff *skb;
+		int len;
+		int i;
+		if (np->cur_rx - np->refill_rx >= RX_RING)
+			break;	/* we scanned the whole ring - do not continue */
+
+		i = np->cur_rx % RX_RING;
+		prd = &np->rx_ring[i];
+		dprintk(KERN_DEBUG "%s: rx_process: looking at packet %d, Flags 0x%x.\n",
+					dev->name, np->cur_rx, prd->Flags);
+
+		if (prd->Flags & cpu_to_le16(NV_RX_AVAIL))
+			break;	/* still owned by hardware, */
+
+		/*
+		 * the packet is for us - immediately tear down the pci mapping, and
+		 * prefetch the first cacheline of the packet.
+		 */
+		pci_unmap_single(np->pci_dev, np->rx_dma[i],
+				np->rx_skbuff[i]->len,
+				PCI_DMA_FROMDEVICE);
+		prefetch(np->rx_skbuff[i]->data);
+
+		{
+			int j;
+			dprintk(KERN_DEBUG "Dumping packet (flags 0x%x).",prd->Flags);
+			for (j=0; j<64; j++) {
+				if ((j%16) == 0)
+					dprintk("\n%03x:", j);
+				dprintk(" %02x", ((unsigned char*)np->rx_skbuff[i]->data)[j]);
+			}
+			dprintk("\n");
+		}
+		/* look at what we actually got: */
+		if (!(prd->Flags & cpu_to_le16(NV_RX_DESCRIPTORVALID)))
+			goto next_pkt;
+
+
+		len = le16_to_cpu(prd->Length);
+
+		if (prd->Flags & cpu_to_le16(NV_RX_MISSEDFRAME)) {
+			np->stats.rx_missed_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_ERROR1|NV_RX_ERROR2|NV_RX_ERROR3|NV_RX_ERROR4)) {
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_CRCERR)) {
+			np->stats.rx_crc_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_OVERFLOW)) {
+			np->stats.rx_over_errors++;
+			np->stats.rx_errors++;
+			goto next_pkt;
+		}
+		if (prd->Flags & cpu_to_le16(NV_RX_ERROR)) {
+			/* framing errors are soft errors, the rest is fatal. */
+			if (prd->Flags & cpu_to_le16(NV_RX_FRAMINGERR)) {
+				if (prd->Flags & cpu_to_le16(NV_RX_SUBSTRACT1)) {
+					len--;
+				}
+			} else {
+				np->stats.rx_errors++;
+				goto next_pkt;
+			}
+		}
+		/* got a valid packet - forward it to the network core */
+		skb = np->rx_skbuff[i];
+		np->rx_skbuff[i] = NULL;
+
+		skb_put(skb, len);
+		skb->protocol = eth_type_trans(skb, dev);
+		dprintk(KERN_DEBUG "%s: rx_process: packet %d with %d bytes, proto %d accepted.\n",
+					dev->name, np->cur_rx, len, skb->protocol);
+		netif_rx(skb);
+		dev->last_rx = jiffies;
+		np->stats.rx_packets++;
+		np->stats.rx_bytes += len;
+next_pkt:
+		np->cur_rx++;
+	}
+}
+
+/*
+ * change_mtu: dev->change_mtu function
+ * Called with dev_base_lock held for read.
+ */
+static int change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu > DEFAULT_MTU)
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+/*
+ * change_mtu: dev->change_mtu function
+ * Called with dev->xmit_lock held.
+ */
+static void set_multicast(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 addr[2];
+	u32 mask[2];
+	u32 pff;
+
+	memset(addr, 0, sizeof(addr));
+	memset(mask, 0, sizeof(mask));
+
+	if (dev->flags & IFF_PROMISC) {
+		printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);
+		pff = NVREG_PFF_PROMISC;
+	} else {
+		pff = NVREG_PFF_MYADDR;
+
+		if (dev->flags & IFF_ALLMULTI || dev->mc_list) {
+			u32 alwaysOff[2];
+			u32 alwaysOn[2];
+
+			alwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0xffffffff;
+			if (dev->flags & IFF_ALLMULTI) {
+				alwaysOn[0] = alwaysOn[1] = alwaysOff[0] = alwaysOff[1] = 0;
+			} else {
+				struct dev_mc_list *walk;
+
+				walk = dev->mc_list;
+				while (walk != NULL) {
+					u32 a, b;
+					a = le32_to_cpu(*(u32 *) walk->dmi_addr);
+					b = le16_to_cpu(*(u16 *) (&walk->dmi_addr[4]));
+					alwaysOn[0] &= a;
+					alwaysOff[0] &= ~a;
+					alwaysOn[1] &= b;
+					alwaysOff[1] &= ~b;
+					walk = walk->next;
+				}
+			}
+			addr[0] = alwaysOn[0];
+			addr[1] = alwaysOn[1];
+			mask[0] = alwaysOn[0] | alwaysOff[0];
+			mask[1] = alwaysOn[1] | alwaysOff[1];
+		}
+	}
+	addr[0] |= NVREG_MCASTADDRA_FORCE;
+	pff |= NVREG_PFF_ALWAYS;
+	spin_lock_irq(&np->lock);
+	stop_rx(dev);
+	writel(addr[0], base + NvRegMulticastAddrA);
+	writel(addr[1], base + NvRegMulticastAddrB);
+	writel(mask[0], base + NvRegMulticastMaskA);
+	writel(mask[1], base + NvRegMulticastMaskB);
+	writel(pff, base + NvRegPacketFilterFlags);
+	start_rx(dev);
+	spin_unlock_irq(&np->lock);
+}
+
+static int update_linkspeed(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	int adv, lpa, newls, newdup;
+
+	adv = mii_rw(dev, np->phyaddr, MII_ADVERTISE, MII_READ);
+	lpa = mii_rw(dev, np->phyaddr, MII_LPA, MII_READ);
+	dprintk(KERN_DEBUG "%s: update_linkspeed: PHY advertises 0x%04x, lpa 0x%04x.\n",
+				dev->name, adv, lpa);
+
+	/* FIXME: handle parallel detection properly, handle gigabit ethernet */
+	lpa = lpa & adv;
+	if (lpa  & LPA_100FULL) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;
+		newdup = 1;
+	} else if (lpa & LPA_100HALF) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_100;
+		newdup = 0;
+	} else if (lpa & LPA_10FULL) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 1;
+	} else if (lpa & LPA_10HALF) {
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 0;
+	} else {
+		dprintk(KERN_DEBUG "%s: bad ability %04x - falling back to 10HD.\n", dev->name, lpa);
+		newls = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+		newdup = 0;
+	}
+	if (np->duplex != newdup || np->linkspeed != newls) {
+		np->duplex = newdup;
+		np->linkspeed = newls;
+		return 1;
+	}
+	return 0;
+}
+
+static void link_irq(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 miistat;
+	int miival;
+
+	miistat = readl(base + NvRegMIIStatus);
+	writel(NVREG_MIISTAT_MASK, base + NvRegMIIStatus);
+	printk(KERN_DEBUG "%s: link change notification, status 0x%x.\n", dev->name, miistat);
+
+	miival = mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ);
+	if (miival & BMSR_ANEGCOMPLETE) {
+		update_linkspeed(dev);
+
+		if (netif_carrier_ok(dev)) {
+			stop_rx(dev);
+		} else {
+			netif_carrier_on(dev);
+			printk(KERN_INFO "%s: link up.\n", dev->name);
+		}
+		writel(NVREG_MISC1_FORCE | ( np->duplex ? 0 : NVREG_MISC1_HD),
+					base + NvRegMisc1);
+		start_rx(dev);
+	} else {
+		if (netif_carrier_ok(dev)) {
+			netif_carrier_off(dev);
+			printk(KERN_INFO "%s: link down.\n", dev->name);
+			stop_rx(dev);
+		}
+		writel(np->linkspeed, base + NvRegLinkSpeed);
+		pci_push(base);
+	}
+}
+
+static irqreturn_t nic_irq(int foo, void *data, struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	u32 events;
+	int i;
+
+	dprintk(KERN_DEBUG "%s: nic_irq\n", dev->name);
+
+	for (i=0; ; i++) {
+		events = readl(base + NvRegIrqStatus) & NVREG_IRQSTAT_MASK;
+		writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+		pci_push(base);
+		dprintk(KERN_DEBUG "%s: irq: %08x\n", dev->name, events);
+		if (!(events & np->irqmask))
+			break;
+
+		if (events & (NVREG_IRQ_TX1|NVREG_IRQ_TX2|NVREG_IRQ_TX_ERR)) {
+			spin_lock(&np->lock);
+			tx_done(dev);
+			spin_unlock(&np->lock);
+		}
+
+		if (events & (NVREG_IRQ_RX|NVREG_IRQ_RX_NOBUF)) {
+			rx_process(dev);
+			if (alloc_rx(dev)) {
+				spin_lock(&np->lock);
+				if (!np->in_shutdown)
+					mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+				spin_unlock(&np->lock);
+			}
+		}
+
+		if (events & NVREG_IRQ_LINK) {
+			spin_lock(&np->lock);
+			link_irq(dev);
+			spin_unlock(&np->lock);
+		}
+		if (events & (NVREG_IRQ_TX_ERR)) {
+			dprintk(KERN_DEBUG "%s: received irq with events 0x%x. Probably TX fail.\n",
+						dev->name, events);
+		}
+		if (events & (NVREG_IRQ_UNKNOWN)) {
+			printk(KERN_DEBUG "%s: received irq with unknown events 0x%x. Please report\n",
+						dev->name, events);
+ 		}
+		if (i > max_interrupt_work) {
+			spin_lock(&np->lock);
+			/* disable interrupts on the nic */
+			writel(0, base + NvRegIrqMask);
+			pci_push(base);
+
+			if (!np->in_shutdown)
+				mod_timer(&np->nic_poll, jiffies + POLL_WAIT);
+			printk(KERN_DEBUG "%s: too many iterations (%d) in nic_irq.\n", dev->name, i);
+			spin_unlock(&np->lock);
+			break;
+		}
+
+	}
+	dprintk(KERN_DEBUG "%s: nic_irq completed\n", dev->name);
+
+	return IRQ_RETVAL(i);
+}
+
+static void do_nic_poll(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	disable_irq(dev->irq);
+	/*
+	 * reenable interrupts on the nic, we have to do this before calling
+	 * nic_irq because that may decide to do otherwise
+	 */
+	writel(np->irqmask, base + NvRegIrqMask);
+	pci_push(base);
+	nic_irq((int) 0, (void *) data, (struct pt_regs *) NULL);
+	enable_irq(dev->irq);
+}
+
+static int open(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+	int ret, oom, i;
+
+	dprintk(KERN_DEBUG "forcedeth: open\n");
+
+	/* 1) erase previous misconfiguration */
+	/* 4.1-1: stop adapter: ignored, 4.3 seems to be overkill */
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(0, base + NvRegPacketFilterFlags);
+	writel(0, base + NvRegAdapterControl);
+	writel(0, base + NvRegLinkSpeed);
+	writel(0, base + NvRegUnknownTransmitterReg);
+	txrx_reset(dev);
+	writel(0, base + NvRegUnknownSetupReg6);
+
+	/* 2) initialize descriptor rings */
+	np->in_shutdown = 0;
+	oom = init_ring(dev);
+
+	/* 3) set mac address */
+	{
+		u32 mac[2];
+
+		mac[0] = (dev->dev_addr[0] <<  0) + (dev->dev_addr[1] <<  8) +
+				(dev->dev_addr[2] << 16) + (dev->dev_addr[3] << 24);
+		mac[1] = (dev->dev_addr[4] << 0) + (dev->dev_addr[5] << 8);
+
+		writel(mac[0], base + NvRegMacAddrA);
+		writel(mac[1], base + NvRegMacAddrB);
+	}
+
+	/* 4) continue setup */
+	np->linkspeed = NVREG_LINKSPEED_FORCE|NVREG_LINKSPEED_10;
+	np->duplex = 0;
+	writel(NVREG_UNKSETUP3_VAL1, base + NvRegUnknownSetupReg3);
+	writel(0, base + NvRegTxRxControl);
+	pci_push(base);
+	writel(NVREG_TXRXCTL_BIT1, base + NvRegTxRxControl);
+	reg_delay(dev, NvRegUnknownSetupReg5, NVREG_UNKSETUP5_BIT31, NVREG_UNKSETUP5_BIT31,
+			NV_SETUP5_DELAY, NV_SETUP5_DELAYMAX,
+			KERN_INFO "open: SetupReg5, Bit 31 remained off\n");
+	writel(0, base + NvRegUnknownSetupReg4);
+
+	/* 5) Find a suitable PHY */
+	writel(NVREG_MIISPEED_BIT8|NVREG_MIIDELAY, base + NvRegMIISpeed);
+	for (i = 1; i < 32; i++) {
+		int id1, id2;
+
+		id1 = mii_rw(dev, i, MII_PHYSID1, MII_READ);
+		if (id1 < 0)
+			continue;
+		id2 = mii_rw(dev, i, MII_PHYSID2, MII_READ);
+		if (id2 < 0)
+			continue;
+		dprintk(KERN_DEBUG "%s: open: Found PHY %04x:%04x at address %d.\n",
+				dev->name, id1, id2, i);
+		np->phyaddr = i;
+
+		update_linkspeed(dev);
+
+		break;
+	}
+	if (i == 32) {
+		printk(KERN_INFO "%s: open: failing due to lack of suitable PHY.\n",
+				dev->name);
+		ret = -EINVAL;
+		goto out_drain;
+	}
+
+	/* 6) continue setup */
+	writel(NVREG_MISC1_FORCE | ( np->duplex ? 0 : NVREG_MISC1_HD),
+				base + NvRegMisc1);
+	writel(readl(base + NvRegTransmitterStatus), base + NvRegTransmitterStatus);
+	writel(NVREG_PFF_ALWAYS, base + NvRegPacketFilterFlags);
+	writel(NVREG_OFFLOAD_NORMAL, base + NvRegOffloadConfig);
+
+	writel(readl(base + NvRegReceiverStatus), base + NvRegReceiverStatus);
+	get_random_bytes(&i, sizeof(i));
+	writel(NVREG_RNDSEED_FORCE | (i&NVREG_RNDSEED_MASK), base + NvRegRandomSeed);
+	writel(NVREG_UNKSETUP1_VAL, base + NvRegUnknownSetupReg1);
+	writel(NVREG_UNKSETUP2_VAL, base + NvRegUnknownSetupReg2);
+	writel(NVREG_UNKSETUP6_VAL, base + NvRegUnknownSetupReg6);
+	writel((np->phyaddr << NVREG_ADAPTCTL_PHYSHIFT)|NVREG_ADAPTCTL_PHYVALID,
+			base + NvRegAdapterControl);
+	writel(NVREG_UNKSETUP4_VAL, base + NvRegUnknownSetupReg4);
+	writel(NVREG_WAKEUPFLAGS_VAL, base + NvRegWakeUpFlags);
+
+	/* 7) start packet processing */
+	writel((u32) np->ring_addr, base + NvRegRxRingPhysAddr);
+	writel((u32) (np->ring_addr + RX_RING*sizeof(struct ring_desc)), base + NvRegTxRingPhysAddr);
+	writel( ((RX_RING-1) << NVREG_RINGSZ_RXSHIFT) + ((TX_RING-1) << NVREG_RINGSZ_TXSHIFT),
+			base + NvRegRingSizes);
+
+	i = readl(base + NvRegPowerState);
+	if ( (i & NVREG_POWERSTATE_POWEREDUP) == 0) {
+		writel(NVREG_POWERSTATE_POWEREDUP|i, base + NvRegPowerState);
+	}
+	pci_push(base);
+	udelay(10);
+	writel(readl(base + NvRegPowerState) | NVREG_POWERSTATE_VALID, base + NvRegPowerState);
+	writel(NVREG_ADAPTCTL_RUNNING, base + NvRegAdapterControl);
+
+
+	writel(0, base + NvRegIrqMask);
+	pci_push(base);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+	writel(NVREG_MIISTAT_MASK2, base + NvRegMIIStatus);
+	writel(NVREG_IRQSTAT_MASK, base + NvRegIrqStatus);
+	pci_push(base);
+
+	ret = request_irq(dev->irq, &nic_irq, SA_SHIRQ, dev->name, dev);
+	if (ret)
+		goto out_drain;
+
+	writel(np->irqmask, base + NvRegIrqMask);
+
+	spin_lock_irq(&np->lock);
+	writel(NVREG_MCASTADDRA_FORCE, base + NvRegMulticastAddrA);
+	writel(0, base + NvRegMulticastAddrB);
+	writel(0, base + NvRegMulticastMaskA);
+	writel(0, base + NvRegMulticastMaskB);
+	writel(NVREG_PFF_ALWAYS|NVREG_PFF_MYADDR, base + NvRegPacketFilterFlags);
+	start_rx(dev);
+	start_tx(dev);
+	netif_start_queue(dev);
+	if (oom)
+		mod_timer(&np->oom_kick, jiffies + OOM_REFILL);
+	if (!(mii_rw(dev, np->phyaddr, MII_BMSR, MII_READ) & BMSR_ANEGCOMPLETE)) {
+		printk("%s: no link during initialization.\n", dev->name);
+		netif_carrier_off(dev);
+	}
+
+	spin_unlock_irq(&np->lock);
+
+	return 0;
+out_drain:
+	drain_ring(dev);
+	return ret;
+}
+
+static int close(struct net_device *dev)
+{
+	struct fe_priv *np = get_nvpriv(dev);
+
+	spin_lock_irq(&np->lock);
+	np->in_shutdown = 1;
+	spin_unlock_irq(&np->lock);
+	synchronize_irq(dev->irq);
+
+	del_timer_sync(&np->oom_kick);
+	del_timer_sync(&np->nic_poll);
+
+	netif_stop_queue(dev);
+	spin_lock_irq(&np->lock);
+	stop_tx(dev);
+	stop_rx(dev);
+	spin_unlock_irq(&np->lock);
+
+	free_irq(dev->irq, dev);
+
+	drain_ring(dev);
+
+	/* FIXME: power down nic */
+
+	return 0;
+}
+
+static int __devinit probe_nic(struct pci_dev *pci_dev, const struct pci_device_id *id)
+{
+	struct net_device *dev;
+	struct fe_priv *np;
+	unsigned long addr;
+	u8 *base;
+	int err, i;
+
+	dev = alloc_etherdev(sizeof(struct fe_priv));
+	np = get_nvpriv(dev);
+	err = -ENOMEM;
+	if (!dev)
+		goto out;
+
+	np->pci_dev = pci_dev;
+	spin_lock_init(&np->lock);
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pci_dev->dev);
+
+	init_timer(&np->oom_kick);
+	np->oom_kick.data = (unsigned long) dev;
+	np->oom_kick.function = &do_rx_refill;	/* timer handler */
+	init_timer(&np->nic_poll);
+	np->nic_poll.data = (unsigned long) dev;
+	np->nic_poll.function = &do_nic_poll;	/* timer handler */
+
+	err = pci_enable_device(pci_dev);
+	if (err) {
+		printk(KERN_INFO "forcedeth: pci_enable_dev failed (%d) for device %s\n",
+				err, pci_name(pci_dev));
+		goto out_free;
+	}
+
+	pci_set_master(pci_dev);
+
+	err = pci_request_regions(pci_dev, dev->name);
+	if (err < 0)
+		goto out_disable;
+
+	err = -EINVAL;
+	addr = 0;
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		dprintk(KERN_DEBUG "%s: resource %d start %p len %ld flags 0x%08lx.\n",
+				pci_name(pci_dev), i, (void*)pci_resource_start(pci_dev, i),
+				pci_resource_len(pci_dev, i),
+				pci_resource_flags(pci_dev, i));
+		if (pci_resource_flags(pci_dev, i) & IORESOURCE_MEM &&
+				pci_resource_len(pci_dev, i) >= NV_PCI_REGSZ) {
+			addr = pci_resource_start(pci_dev, i);
+			break;
+		}
+	}
+	if (i == DEVICE_COUNT_RESOURCE) {
+		printk(KERN_INFO "forcedeth: Couldn't find register window for device %s.\n",
+					pci_name(pci_dev));
+		goto out_relreg;
+	}
+
+	err = -ENOMEM;
+	dev->base_addr = (unsigned long) ioremap(addr, NV_PCI_REGSZ);
+	if (!dev->base_addr)
+		goto out_disable;
+	dev->irq = pci_dev->irq;
+	np->rx_ring = pci_alloc_consistent(pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING),
+						&np->ring_addr);
+	if (!np->rx_ring)
+		goto out_unmap;
+	np->tx_ring = &np->rx_ring[RX_RING];
+
+	dev->open = open;
+	dev->stop = close;
+	dev->hard_start_xmit = start_xmit;
+	dev->get_stats = get_stats;
+	dev->change_mtu = change_mtu;
+	dev->set_multicast_list = set_multicast;
+	dev->do_ioctl = nic_ioctl;
+	dev->tx_timeout = tx_timeout;
+	dev->watchdog_timeo = NV_WATCHDOG_TIMEO;
+
+	pci_set_drvdata(pci_dev, dev);
+
+
+	/* read the mac address */
+	base = get_hwbase(dev);
+	np->orig_mac[0] = readl(base + NvRegMacAddrA);
+	np->orig_mac[1] = readl(base + NvRegMacAddrB);
+
+	dev->dev_addr[0] = (np->orig_mac[1] >>  8) & 0xff;
+	dev->dev_addr[1] = (np->orig_mac[1] >>  0) & 0xff;
+	dev->dev_addr[2] = (np->orig_mac[0] >> 24) & 0xff;
+	dev->dev_addr[3] = (np->orig_mac[0] >> 16) & 0xff;
+	dev->dev_addr[4] = (np->orig_mac[0] >>  8) & 0xff;
+	dev->dev_addr[5] = (np->orig_mac[0] >>  0) & 0xff;
+
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		/*
+		 * Bad mac address. At least one bios sets the mac address
+		 * to 01:23:45:67:89:ab
+		 */
+		printk(KERN_ERR "%s: Invalid Mac address detected: %02x:%02x:%02x:%02x:%02x:%02x\n",
+			pci_name(pci_dev),
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+		printk(KERN_ERR "Please complain to your hardware vendor. Switching to a random MAC.\n");
+		dev->dev_addr[0] = 0x00;
+		dev->dev_addr[1] = 0x00;
+		dev->dev_addr[2] = 0x6c;
+		get_random_bytes(&dev->dev_addr[3], 3);
+	}
+
+	dprintk(KERN_DEBUG "%s: MAC Address %02x:%02x:%02x:%02x:%02x:%02x\n", pci_name(pci_dev),
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	np->tx_flags = cpu_to_le16(NV_TX_LASTPACKET|NV_TX_LASTPACKET1|NV_TX_VALID);
+	if (id->driver_data & DEV_NEED_LASTPACKET1)
+		np->tx_flags |= cpu_to_le16(NV_TX_LASTPACKET1);
+	if (id->driver_data & DEV_IRQMASK_1)
+		np->irqmask = NVREG_IRQMASK_WANTED_1;
+	if (id->driver_data & DEV_IRQMASK_2)
+		np->irqmask = NVREG_IRQMASK_WANTED_2;
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_INFO "forcedeth: unable to register netdev: %d\n", err);
+		goto out_freering;
+	}
+	printk(KERN_INFO "%s: forcedeth.c: subsystem: %05x:%04x bound to %s\n",
+			dev->name, pci_dev->subsystem_vendor, pci_dev->subsystem_device,
+			pci_name(pci_dev));
+
+	return 0;
+
+out_freering:
+	pci_free_consistent(np->pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING),
+				np->rx_ring, np->ring_addr);
+out_unmap:
+	iounmap(get_hwbase(dev));
+out_relreg:
+	pci_release_regions(pci_dev);
+out_disable:
+	pci_disable_device(pci_dev);
+out_free:
+	free_netdev(dev);
+	pci_set_drvdata(pci_dev, NULL);
+out:
+	return err;
+}
+
+static void __devexit remove_nic(struct pci_dev *pci_dev)
+{
+	struct net_device *dev = pci_get_drvdata(pci_dev);
+	struct fe_priv *np = get_nvpriv(dev);
+	u8 *base = get_hwbase(dev);
+
+	unregister_netdev(dev);
+
+	/* special op: write back the misordered MAC address - otherwise
+	 * the next probe_nic would see a wrong address.
+	 */
+	writel(np->orig_mac[0], base + NvRegMacAddrA);
+	writel(np->orig_mac[1], base + NvRegMacAddrB);
+
+	/* free all structures */
+	pci_free_consistent(np->pci_dev, sizeof(struct ring_desc) * (RX_RING + TX_RING), np->rx_ring, np->ring_addr);
+	iounmap(get_hwbase(dev));
+	pci_release_regions(pci_dev);
+	pci_disable_device(pci_dev);
+	free_netdev(dev);
+	pci_set_drvdata(pci_dev, NULL);
+}
+
+static struct pci_device_id pci_tbl[] = {
+	{	/* nForce Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x1C3,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_IRQMASK_1,
+	},
+	{	/* nForce2 Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x0066,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_NEED_LASTPACKET1|DEV_IRQMASK_2,
+	},
+	{	/* nForce3 Ethernet Controller */
+		.vendor = PCI_VENDOR_ID_NVIDIA,
+		.device = 0x00D6,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.driver_data = DEV_NEED_LASTPACKET1|DEV_IRQMASK_2,
+	},
+	{0,},
+};
+
+static struct pci_driver driver = {
+	.name = "forcedeth",
+	.id_table = pci_tbl,
+	.probe = probe_nic,
+	.remove = __devexit_p(remove_nic),
+};
+
+
+static int __init init_nic(void)
+{
+	printk(KERN_INFO "forcedeth.c: Reverse Engineered nForce ethernet driver. Version %s.\n", FORCEDETH_VERSION);
+	return pci_module_init(&driver);
+}
+
+static void __exit exit_nic(void)
+{
+	pci_unregister_driver(&driver);
+}
+
+MODULE_PARM(max_interrupt_work, "i");
+MODULE_PARM_DESC(max_interrupt_work, "forcedeth maximum events handled per interrupt");
+ 
+MODULE_AUTHOR("Manfred Spraul <manfred@colorfullife.com>");
+MODULE_DESCRIPTION("Reverse Engineered nForce ethernet driver");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(pci, pci_tbl);
+
+module_init(init_nic);
+module_exit(exit_nic);
diff -purN linux-2.6.1/drivers/net/irda/sir-dev.h linux-2.5/drivers/net/irda/sir-dev.h
--- linux-2.6.1/drivers/net/irda/sir-dev.h	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir-dev.h	2004-01-09 10:09:46.000000000 +0000
@@ -179,6 +179,7 @@ struct sir_dev {
 
 	struct sir_fsm fsm;
 	atomic_t enable_rx;
+	int raw_tx;
 	spinlock_t tx_lock;
 
 	u32 new_speed;
diff -purN linux-2.6.1/drivers/net/irda/sir_dev.c linux-2.5/drivers/net/irda/sir_dev.c
--- linux-2.6.1/drivers/net/irda/sir_dev.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir_dev.c	2004-01-09 10:09:46.000000000 +0000
@@ -31,7 +31,9 @@ void sirdev_enable_rx(struct sir_dev *de
 
 	/* flush rx-buffer - should also help in case of problems with echo cancelation */
 	dev->rx_buff.data = dev->rx_buff.head;
-	dev->tx_buff.len = 0;
+	dev->rx_buff.len = 0;
+	dev->rx_buff.in_frame = FALSE;
+	dev->rx_buff.state = OUTSIDE_FRAME;
 	atomic_set(&dev->enable_rx, 1);
 }
 
@@ -62,24 +64,34 @@ int sirdev_set_dongle(struct sir_dev *de
 
 int sirdev_raw_write(struct sir_dev *dev, const char *buf, int len)
 {
+	unsigned long flags;
 	int ret;
 
 	if (unlikely(len > dev->tx_buff.truesize))
 		return -ENOSPC;
 
-	spin_lock_bh(&dev->tx_lock);		/* serialize with other tx operations */
-	while (dev->tx_buff.len > 0) {		/* wait until tx idle */
-		spin_unlock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);	/* serialize with other tx operations */
+	while (dev->tx_buff.len > 0) {			/* wait until tx idle */
+		spin_unlock_irqrestore(&dev->tx_lock, flags);
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(MSECS_TO_JIFFIES(10));
-		spin_lock_bh(&dev->tx_lock);
+		spin_lock_irqsave(&dev->tx_lock, flags);
 	}
 
 	dev->tx_buff.data = dev->tx_buff.head;
 	memcpy(dev->tx_buff.data, buf, len);	
+	dev->tx_buff.len = len;
 
 	ret = dev->drv->do_write(dev, dev->tx_buff.data, dev->tx_buff.len);
-	spin_unlock_bh(&dev->tx_lock);
+	if (ret > 0) {
+		IRDA_DEBUG(3, "%s(), raw-tx started\n", __FUNCTION__);
+
+		dev->tx_buff.data += ret;
+		dev->tx_buff.len -= ret;
+		dev->raw_tx = 1;
+		ret = len;		/* all data is going to be sent */
+	}
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 	return ret;
 }
 
@@ -94,13 +106,13 @@ int sirdev_raw_read(struct sir_dev *dev,
 
 	count = (len < dev->rx_buff.len) ? len : dev->rx_buff.len;
 
-	if (count > 0)
-		memcpy(buf, dev->rx_buff.head, count);
+	if (count > 0) {
+		memcpy(buf, dev->rx_buff.data, count);
+		dev->rx_buff.data += count;
+		dev->rx_buff.len -= count;
+	}
 
-	/* forget trailing stuff */
-	dev->rx_buff.data = dev->rx_buff.head;
-	dev->rx_buff.len = 0;
-	dev->rx_buff.state = OUTSIDE_FRAME;
+	/* remaining stuff gets flushed when re-enabling normal rx */
 
 	return count;
 }
@@ -114,11 +126,12 @@ int sirdev_raw_read(struct sir_dev *dev,
 
 void sirdev_write_complete(struct sir_dev *dev)
 {
+	unsigned long flags;
 	struct sk_buff *skb;
 	int actual = 0;
 	int err;
 	
-	spin_lock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);
 
 	IRDA_DEBUG(3, "%s() - dev->tx_buff.len = %d\n",
 		   __FUNCTION__, dev->tx_buff.len);
@@ -143,11 +156,24 @@ void sirdev_write_complete(struct sir_de
 			dev->tx_buff.len = 0;
 		}
 		if (dev->tx_buff.len > 0) {
-			spin_unlock_bh(&dev->tx_lock);
+			spin_unlock_irqrestore(&dev->tx_lock, flags);
 			return;
 		}
 	}
 
+	if (unlikely(dev->raw_tx != 0)) {
+		/* in raw mode we are just done now after the buffer was sent
+		 * completely. Since this was requested by some dongle driver
+		 * running under the control of the irda-thread we must take
+		 * care here not to re-enable the queue. The queue will be
+		 * restarted when the irda-thread has completed the request.
+		 */
+
+		IRDA_DEBUG(3, "%s(), raw-tx done\n", __FUNCTION__);
+		dev->raw_tx = 0;
+		return;
+	}
+
 	/* we have finished now sending this skb.
 	 * update statistics and free the skb.
 	 * finally we check and trigger a pending speed change, if any.
@@ -190,7 +216,7 @@ void sirdev_write_complete(struct sir_de
 		netif_wake_queue(dev->netdev);
 	}
 
-	spin_unlock_bh(&dev->tx_lock);
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 }
 
 /* called from client driver - likely with bh-context - to give us
@@ -258,6 +284,7 @@ static struct net_device_stats *sirdev_g
 static int sirdev_hard_xmit(struct sk_buff *skb, struct net_device *ndev)
 {
 	struct sir_dev *dev = ndev->priv;
+	unsigned long flags;
 	int actual = 0;
 	int err;
 	s32 speed;
@@ -307,7 +334,7 @@ static int sirdev_hard_xmit(struct sk_bu
 	}
 
 	/* serialize with write completion */
-	spin_lock_bh(&dev->tx_lock);
+	spin_lock_irqsave(&dev->tx_lock, flags);
 
         /* Copy skb to tx_buff while wrapping, stuffing and making CRC */
 	dev->tx_buff.len = async_wrap_skb(skb, dev->tx_buff.data, dev->tx_buff.truesize); 
@@ -337,7 +364,7 @@ static int sirdev_hard_xmit(struct sk_bu
 		dev->stats.tx_dropped++;		      
 		netif_wake_queue(ndev);
 	}
-	spin_unlock_bh(&dev->tx_lock);
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
 
 	return 0;
 }
@@ -479,6 +506,7 @@ static int sirdev_open(struct net_device
 		goto errout_free;
 
 	sirdev_enable_rx(dev);
+	dev->raw_tx = 0;
 
 	netif_start_queue(ndev);
 	dev->irlap = irlap_open(ndev, &dev->qos, dev->hwname);
diff -purN linux-2.6.1/drivers/net/irda/sir_kthread.c linux-2.5/drivers/net/irda/sir_kthread.c
--- linux-2.6.1/drivers/net/irda/sir_kthread.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/drivers/net/irda/sir_kthread.c	2004-01-09 10:09:12.000000000 +0000
@@ -436,14 +436,13 @@ int sirdev_schedule_request(struct sir_d
 
 	IRDA_DEBUG(2, "%s - state=0x%04x / param=%u\n", __FUNCTION__, initial_state, param);
 
-	if (in_interrupt()) {
-		if (down_trylock(&fsm->sem)) {
+	if (down_trylock(&fsm->sem)) {
+		if (in_interrupt()  ||  in_atomic()  ||  irqs_disabled()) {
 			IRDA_DEBUG(1, "%s(), state machine busy!\n", __FUNCTION__);
 			return -EWOULDBLOCK;
-		}
+		} else
+			down(&fsm->sem);
 	}
-	else
-		down(&fsm->sem);
 
 	if (fsm->state == SIRDEV_STATE_DEAD) {
 		/* race with sirdev_close should never happen */
diff -purN linux-2.6.1/drivers/net/pppoe.c linux-2.5/drivers/net/pppoe.c
--- linux-2.6.1/drivers/net/pppoe.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/drivers/net/pppoe.c	2004-01-09 09:51:46.000000000 +0000
@@ -775,8 +775,8 @@ static int pppoe_ioctl(struct socket *so
 }
 
 
-static int pppoe_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		  int total_len)
+static int pppoe_sendmsg(struct kiocb *iocb, struct socket *sock, 
+		  struct msghdr *m, size_t total_len)
 {
 	struct sk_buff *skb = NULL;
 	struct sock *sk = sock->sk;
@@ -939,7 +939,7 @@ static struct ppp_channel_ops pppoe_chan
 };
 
 static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,
-		  struct msghdr *m, int total_len, int flags)
+		  struct msghdr *m, size_t total_len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb = NULL;
diff -purN linux-2.6.1/drivers/net/wan/Kconfig linux-2.5/drivers/net/wan/Kconfig
--- linux-2.6.1/drivers/net/wan/Kconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wan/Kconfig	2004-01-10 16:14:26.000000000 +0000
@@ -325,6 +325,21 @@ config HDLC_X25
 comment "X.25/LAPB support is disabled"
 	depends on WAN && HDLC && (LAPB!=m || HDLC!=m) && LAPB!=y
 
+config PCI200SYN
+	tristate "Goramo PCI200SYN support"
+	depends on HDLC && PCI
+	help
+	  This driver is for PCI200SYN cards made by Goramo sp. j.
+	  If you have such a card, say Y here and see
+	  <http://hq.pm.waw.pl/pub/hdlc/>
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called pci200syn.
+
+	  If unsure, say N here.
+
 config WANXL
 	tristate "SBE Inc. wanXL support"
 	depends on HDLC && PCI
diff -purN linux-2.6.1/drivers/net/wan/Makefile linux-2.5/drivers/net/wan/Makefile
--- linux-2.6.1/drivers/net/wan/Makefile	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/drivers/net/wan/Makefile	2004-01-10 16:14:26.000000000 +0000
@@ -67,6 +67,7 @@ endif
 obj-$(CONFIG_N2)		+= n2.o
 obj-$(CONFIG_C101)		+= c101.o
 obj-$(CONFIG_WANXL)		+= wanxl.o
+obj-$(CONFIG_PCI200SYN)		+= pci200syn.o
 
 ifeq ($(CONFIG_WANXL_BUILD_FIRMWARE),y)
 ifeq ($(ARCH),m68k)
diff -purN linux-2.6.1/drivers/net/wan/hd64572.h linux-2.5/drivers/net/wan/hd64572.h
--- linux-2.6.1/drivers/net/wan/hd64572.h	2004-01-09 06:59:47.000000000 +0000
+++ linux-2.5/drivers/net/wan/hd64572.h	2004-01-10 16:14:26.000000000 +0000
@@ -23,8 +23,8 @@
  *
  */
 
-#ifndef _HD64572_H
-#define _HD64572_H
+#ifndef __HD64572_H
+#define __HD64572_H
 
 /* Illegal Access Register */
 #define	ILAR	0x00
@@ -59,6 +59,9 @@
 #define IR0_M(val, chan)	((val)<<(8*(chan)))		/* Int MSCI */
 
 /* MSCI Channel Registers */
+#define MSCI0_OFFSET 0x00
+#define MSCI1_OFFSET 0x80
+
 #define MD0	0x138	/* Mode reg 0 */
 #define MD1	0x139	/* Mode reg 1 */
 #define MD2	0x13a	/* Mode reg 2 */
@@ -107,6 +110,11 @@
 #define RCR	0x156	/* Rx DMA Critical Request Reg */
 
 /* Timer Registers */
+#define TIMER0RX_OFFSET 0x00
+#define TIMER0TX_OFFSET 0x10
+#define TIMER1RX_OFFSET 0x20
+#define TIMER1TX_OFFSET 0x30
+
 #define TCNTL	0x200	/* Timer Upcounter L */
 #define TCNTH	0x201	/* Timer Upcounter H */
 #define TCONRL	0x204	/* Timer Constant Register L */
@@ -132,6 +140,11 @@
 #define DCR_TX(chan)	(0x59 + 2*chan)	/* DMA Command Reg (Tx) */
 
 /* DMA Channel Registers */
+#define DMAC0RX_OFFSET 0x00
+#define DMAC0TX_OFFSET 0x20
+#define DMAC1RX_OFFSET 0x40
+#define DMAC1TX_OFFSET 0x60
+
 #define DARL	0x80	/* Dest Addr Register L (single-block, RX only) */
 #define DARH	0x81	/* Dest Addr Register H (single-block, RX only) */
 #define DARB	0x82	/* Dest Addr Register B (single-block, RX only) */
@@ -166,7 +179,17 @@ typedef struct {
 	unsigned char	filler[5];	/* alignment filler (16 bytes) */ 
 } pcsca_bd_t;
 
-/* 
+/* Block Descriptor Structure */
+typedef struct {
+	u32 cp;			/* pointer to next block descriptor */
+	u32 bp;			/* buffer pointer */
+	u16 len;		/* data length */
+	u8 stat;		/* status */
+	u8 unused;		/* pads to 4-byte boundary */
+}pkt_desc;
+
+
+/*
 	Descriptor Status definitions:
 
 	Bit	Transmission	Reception
@@ -190,6 +213,23 @@ typedef struct {
 #define DST_SHRT	0x40	/* Short Frame  */
 #define DST_EOM		0x80	/* End of Message  */
 
+/* Packet Descriptor Status bits */
+
+#define ST_TX_EOM     0x80	/* End of frame */
+#define ST_TX_UNDRRUN 0x08
+#define ST_TX_OWNRSHP 0x02
+#define ST_TX_EOT     0x01	/* End of transmition */
+
+#define ST_RX_EOM     0x80	/* End of frame */
+#define ST_RX_SHORT   0x40	/* Short frame */
+#define ST_RX_ABORT   0x20	/* Abort */
+#define ST_RX_RESBIT  0x10	/* Residual bit */
+#define ST_RX_OVERRUN 0x08	/* Overrun */
+#define ST_RX_CRC     0x04	/* CRC */
+#define ST_RX_OWNRSHP 0x02
+
+#define ST_ERROR_MASK 0x7C
+
 /* Status Counter Registers */
 #define CMCR	0x158	/* Counter Master Ctl Reg */
 #define TECNTL	0x160	/* Tx EOM Counter L */
@@ -246,11 +286,25 @@ typedef struct {
 #define MD0_BIT_SYNC	0x80
 #define MD0_TRANSP	0xc0
 
+#define MD0_HDLC        0x80	/* Bit-sync HDLC mode */
+
+#define MD0_CRC_NONE	0x00
+#define MD0_CRC_16_0	0x04
+#define MD0_CRC_16	0x05
+#define MD0_CRC_ITU32	0x06
+#define MD0_CRC_ITU	0x07
+
 #define MD1_NOADDR	0x00
 #define MD1_SADDR1	0x40
 #define MD1_SADDR2	0x80
 #define MD1_DADDR	0xc0
 
+#define MD2_NRZI_IEEE	0x40
+#define MD2_MANCHESTER	0x80
+#define MD2_FM_MARK	0xA0
+#define MD2_FM_SPACE	0xC0
+#define MD2_LOOPBACK	0x03	/* Local data Loopback */
+
 #define MD2_F_DUPLEX	0x00
 #define MD2_AUTO_ECHO	0x01
 #define MD2_LOOP_HI_Z	0x02
@@ -274,6 +328,10 @@ typedef struct {
 #define CTL_URSKP	0x40
 #define CTL_URCT	0x80
 
+#define CTL_NORTS	0x01
+#define CTL_NODTR	0x02
+#define CTL_IDLE	0x10
+
 #define	RXS_BR0		0x01
 #define	RXS_BR1		0x02
 #define	RXS_BR2		0x04
@@ -302,6 +360,12 @@ typedef struct {
 #define	EXS_TES1	0x20
 #define	EXS_TES2	0x40
 
+#define CLK_BRG_MASK	0x0F
+#define CLK_PIN_OUT	0x80
+#define CLK_LINE    	0x00	/* clock line input */
+#define CLK_BRG     	0x40	/* internal baud rate generator */
+#define CLK_TX_RXCLK	0x60	/* TX clock from RX clock */
+
 #define CMD_RX_RST	0x11
 #define CMD_RX_ENA	0x12
 #define CMD_RX_DIS	0x13
@@ -324,6 +388,10 @@ typedef struct {
 #define CMD_SRCH_MODE	0x31
 #define CMD_NOP		0x00
 
+#define CMD_RESET	0x21
+#define CMD_TX_ENABLE	0x02
+#define CMD_RX_ENABLE	0x12
+
 #define ST0_RXRDY	0x01
 #define ST0_TXRDY	0x02
 #define ST0_RXINTB	0x20
@@ -374,6 +442,8 @@ typedef struct {
 #define IE0_RXINTB	0x20
 #define IE0_RXINTA	0x40
 #define IE0_TXINT	0x80
+#define IE0_UDRN	0x00008000 /* TX underrun MSCI interrupt enable */
+#define IE0_CDCD	0x00000400 /* CD level change interrupt enable */
 
 #define IE1_IDLD	0x01
 #define IE1_ABTD	0x02
@@ -424,14 +494,28 @@ typedef struct {
 #define DIR_EOM		0x40
 #define DIR_EOT		0x80
 
+#define DIR_REFE	0x04
+#define DIR_UDRFE	0x04
+#define DIR_COAE	0x08
+#define DIR_COFE	0x10
+#define DIR_BOFE	0x20
+#define DIR_EOME	0x40
+#define DIR_EOTE	0x80
+
 #define DMR_CNTE	0x02
 #define DMR_NF		0x04
 #define DMR_SEOME	0x08
 #define DMR_TMOD	0x10
 
+#define DMER_DME        0x80	/* DMA Master Enable */
+
 #define DCR_SW_ABT	0x01
 #define DCR_FCT_CLR	0x02
 
+#define DCR_ABORT	0x01
+#define DCR_CLEAR_EOF	0x02
+
+#define PCR_COTE	0x80
 #define PCR_PR0		0x01
 #define PCR_PR1		0x02
 #define PCR_PR2		0x04
@@ -440,4 +524,4 @@ typedef struct {
 #define PCR_OSB		0x40
 #define PCR_BURST	0x80
 
-#endif /* (_HD64572_H) */
+#endif /* (__HD64572_H) */
diff -purN linux-2.6.1/drivers/net/wan/pci200syn.c linux-2.5/drivers/net/wan/pci200syn.c
--- linux-2.6.1/drivers/net/wan/pci200syn.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.5/drivers/net/wan/pci200syn.c	2004-01-10 16:14:26.000000000 +0000
@@ -0,0 +1,475 @@
+/*
+ * Goramo PCI200SYN synchronous serial card driver for Linux
+ *
+ * Copyright (C) 2002-2003 Krzysztof Halasa <khc@pm.waw.pl>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License
+ * as published by the Free Software Foundation.
+ *
+ * For information see http://hq.pm.waw.pl/hdlc/
+ *
+ * Sources of information:
+ *    Hitachi HD64572 SCA-II User's Manual
+ *    PLX Technology Inc. PCI9052 Data Book
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/in.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/moduleparam.h>
+#include <linux/netdevice.h>
+#include <linux/hdlc.h>
+#include <linux/pci.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+
+#include "hd64572.h"
+
+static const char* version = "Goramo PCI200SYN driver version: 1.16";
+static const char* devname = "PCI200SYN";
+
+#undef DEBUG_PKT
+#define DEBUG_RINGS
+
+#define PCI200SYN_PLX_SIZE	0x80	/* PLX control window size (128b) */
+#define PCI200SYN_SCA_SIZE	0x400	/* SCA window size (1Kb) */
+#define ALL_PAGES_ALWAYS_MAPPED
+#define NEED_DETECT_RAM
+#define NEED_SCA_MSCI_INTR
+#define MAX_TX_BUFFERS		10
+
+static int pci_clock_freq = 33000000;
+#define CLOCK_BASE pci_clock_freq
+
+#define PCI_VENDOR_ID_GORAMO	0x10B5	/* uses PLX:9050 ID - this card	*/
+#define PCI_DEVICE_ID_PCI200SYN	0x9050	/* doesn't have its own ID	*/
+
+
+/*
+ *      PLX PCI9052 local configuration and shared runtime registers.
+ *      This structure can be used to access 9052 registers (memory mapped).
+ */
+typedef struct {
+	u32 loc_addr_range[4];	/* 00-0Ch : Local Address Ranges */
+	u32 loc_rom_range;	/* 10h : Local ROM Range */
+	u32 loc_addr_base[4];	/* 14-20h : Local Address Base Addrs */
+	u32 loc_rom_base;	/* 24h : Local ROM Base */
+	u32 loc_bus_descr[4];	/* 28-34h : Local Bus Descriptors */
+	u32 rom_bus_descr;	/* 38h : ROM Bus Descriptor */
+	u32 cs_base[4];		/* 3C-48h : Chip Select Base Addrs */
+	u32 intr_ctrl_stat;	/* 4Ch : Interrupt Control/Status */
+	u32 init_ctrl;		/* 50h : EEPROM ctrl, Init Ctrl, etc */
+}plx9052;
+
+
+
+typedef struct port_s {
+	hdlc_device hdlc;	/* HDLC device struct - must be first */
+	struct card_s *card;
+	spinlock_t lock;	/* TX lock */
+	sync_serial_settings settings;
+	int rxpart;		/* partial frame received, next frame invalid*/
+	unsigned short encoding;
+	unsigned short parity;
+	u16 rxin;		/* rx ring buffer 'in' pointer */
+	u16 txin;		/* tx ring buffer 'in' and 'last' pointers */
+	u16 txlast;
+	u8 rxs, txs, tmc;	/* SCA registers */
+	u8 phy_node;		/* physical port # - 0 or 1 */
+}port_t;
+
+
+
+typedef struct card_s {
+	u8* rambase;		/* buffer memory base (virtual) */
+	u8* scabase;		/* SCA memory base (virtual) */
+	plx9052* plxbase;	/* PLX registers memory base (virtual) */
+	u16 rx_ring_buffers;	/* number of buffers in a ring */
+	u16 tx_ring_buffers;
+	u16 buff_offset;	/* offset of first buffer of first channel */
+	u8 irq;			/* interrupt request level */
+
+	port_t ports[2];
+}card_t;
+
+
+#define sca_in(reg, card)	     readb(card->scabase + (reg))
+#define sca_out(value, reg, card)    writeb(value, card->scabase + (reg))
+#define sca_inw(reg, card)	     readw(card->scabase + (reg))
+#define sca_outw(value, reg, card)   writew(value, card->scabase + (reg))
+#define sca_inl(reg, card)	     readl(card->scabase + (reg))
+#define sca_outl(value, reg, card)   writel(value, card->scabase + (reg))
+
+#define port_to_card(port)	     (port->card)
+#define log_node(port)		     (port->phy_node)
+#define phy_node(port)		     (port->phy_node)
+#define winbase(card)		     (card->rambase)
+#define get_port(card, port)	     (&card->ports[port])
+#define sca_flush(card)		     (sca_in(IER0, card));
+
+static inline void new_memcpy_toio(char *dest, char *src, int length)
+{
+	int len;
+	do {
+		len = length > 256 ? 256 : length;
+		memcpy_toio(dest, src, len);
+		dest += len;
+		src += len;
+		length -= len;
+		readb(dest);
+	} while (len);
+}
+
+#undef memcpy_toio
+#define memcpy_toio new_memcpy_toio
+
+#include "hd6457x.c"
+
+
+static void pci200_set_iface(port_t *port)
+{
+	card_t *card = port->card;
+	u16 msci = get_msci(port);
+	u8 rxs = port->rxs & CLK_BRG_MASK;
+	u8 txs = port->txs & CLK_BRG_MASK;
+
+	sca_out(EXS_TES1, (phy_node(port) ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,
+		port_to_card(port));
+	switch(port->settings.clock_type) {
+	case CLOCK_INT:
+		rxs |= CLK_BRG; /* BRG output */
+		txs |= CLK_PIN_OUT | CLK_TX_RXCLK; /* RX clock */
+		break;
+
+	case CLOCK_TXINT:
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_BRG; /* BRG output */
+		break;
+
+	case CLOCK_TXFROMRX:
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_TX_RXCLK; /* RX clock */
+		break;
+
+	default:		/* EXTernal clock */
+		rxs |= CLK_LINE; /* RXC input */
+		txs |= CLK_PIN_OUT | CLK_LINE; /* TXC input */
+		break;
+	}
+
+	port->rxs = rxs;
+	port->txs = txs;
+	sca_out(rxs, msci + RXS, card);
+	sca_out(txs, msci + TXS, card);
+	sca_set_port(port);
+}
+
+
+
+static int pci200_open(struct net_device *dev)
+{
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	port_t *port = hdlc_to_port(hdlc);
+
+	int result = hdlc_open(hdlc);
+	if (result)
+		return result;
+
+	sca_open(hdlc);
+	pci200_set_iface(port);
+	sca_flush(port_to_card(port));
+	return 0;
+}
+
+
+
+static int pci200_close(struct net_device *dev)
+{
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	sca_close(hdlc);
+	sca_flush(port_to_card(dev_to_port(dev)));
+	hdlc_close(hdlc);
+	return 0;
+}
+
+
+
+static int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	const size_t size = sizeof(sync_serial_settings);
+	sync_serial_settings new_line, *line = ifr->ifr_settings.ifs_ifsu.sync;
+	hdlc_device *hdlc = dev_to_hdlc(dev);
+	port_t *port = hdlc_to_port(hdlc);
+
+#ifdef DEBUG_RINGS
+	if (cmd == SIOCDEVPRIVATE) {
+		sca_dump_rings(hdlc);
+		return 0;
+	}
+#endif
+	if (cmd != SIOCWANDEV)
+		return hdlc_ioctl(dev, ifr, cmd);
+
+	switch(ifr->ifr_settings.type) {
+	case IF_GET_IFACE:
+		ifr->ifr_settings.type = IF_IFACE_V35;
+		if (ifr->ifr_settings.size < size) {
+			ifr->ifr_settings.size = size; /* data size wanted */
+			return -ENOBUFS;
+		}
+		if (copy_to_user(line, &port->settings, size))
+			return -EFAULT;
+		return 0;
+
+	case IF_IFACE_V35:
+	case IF_IFACE_SYNC_SERIAL:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		if (copy_from_user(&new_line, line, size))
+			return -EFAULT;
+
+		if (new_line.clock_type != CLOCK_EXT &&
+		    new_line.clock_type != CLOCK_TXFROMRX &&
+		    new_line.clock_type != CLOCK_INT &&
+		    new_line.clock_type != CLOCK_TXINT)
+		return -EINVAL;	/* No such clock setting */
+
+		if (new_line.loopback != 0 && new_line.loopback != 1)
+			return -EINVAL;
+
+		memcpy(&port->settings, &new_line, size); /* Update settings */
+		pci200_set_iface(port);
+		sca_flush(port_to_card(port));
+		return 0;
+
+	default:
+		return hdlc_ioctl(dev, ifr, cmd);
+	}
+}
+
+
+
+static void pci200_pci_remove_one(struct pci_dev *pdev)
+{
+	int i;
+	card_t *card = pci_get_drvdata(pdev);
+
+	for(i = 0; i < 2; i++)
+		if (card->ports[i].card)
+			unregister_hdlc_device(&card->ports[i].hdlc);
+
+	if (card->irq)
+		free_irq(card->irq, card);
+
+	if (card->rambase)
+		iounmap(card->rambase);
+	if (card->scabase)
+		iounmap(card->scabase);
+	if (card->plxbase)
+		iounmap(card->plxbase);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+	kfree(card);
+}
+
+
+
+static int __devinit pci200_pci_init_one(struct pci_dev *pdev,
+					 const struct pci_device_id *ent)
+{
+	card_t *card;
+	u8 rev_id;
+	u32 *p;
+	int i;
+	u32 ramsize;
+	u32 ramphys;		/* buffer memory base */
+	u32 scaphys;		/* SCA memory base */
+	u32 plxphys;		/* PLX registers memory base */
+
+#ifndef MODULE
+	static int printed_version;
+	if (!printed_version++)
+		printk(KERN_INFO "%s\n", version);
+#endif
+
+	i = pci_enable_device(pdev);
+	if (i)
+		return i;
+
+	i = pci_request_regions(pdev, "PCI200SYN");
+	if (i) {
+		pci_disable_device(pdev);
+		return i;
+	}
+
+	card = kmalloc(sizeof(card_t), GFP_KERNEL);
+	if (card == NULL) {
+		printk(KERN_ERR "pci200syn: unable to allocate memory\n");
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		return -ENOBUFS;
+	}
+	memset(card, 0, sizeof(card_t));
+	pci_set_drvdata(pdev, card);
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	if (pci_resource_len(pdev, 0) != PCI200SYN_PLX_SIZE ||
+	    pci_resource_len(pdev, 2) != PCI200SYN_SCA_SIZE ||
+	    pci_resource_len(pdev, 3) < 16384) {
+		printk(KERN_ERR "pci200syn: invalid card EEPROM parameters\n");
+		pci200_pci_remove_one(pdev);
+		return -EFAULT;
+	}
+
+	plxphys = pci_resource_start(pdev,0) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);
+
+	scaphys = pci_resource_start(pdev,2) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);
+
+	ramphys = pci_resource_start(pdev,3) & PCI_BASE_ADDRESS_MEM_MASK;
+	card->rambase = ioremap(ramphys, pci_resource_len(pdev,3));
+
+	if (card->plxbase == NULL ||
+	    card->scabase == NULL ||
+	    card->rambase == NULL) {
+		printk(KERN_ERR "pci200syn: ioremap() failed\n");
+		pci200_pci_remove_one(pdev);
+	}
+
+	/* Reset PLX */
+	p = &card->plxbase->init_ctrl;
+	writel(readl(p) | 0x40000000, p);
+	readl(p);		/* Flush the write - do not use sca_flush */
+	udelay(1);
+
+	writel(readl(p) & ~0x40000000, p);
+	readl(p);		/* Flush the write - do not use sca_flush */
+	udelay(1);
+
+	ramsize = sca_detect_ram(card, card->rambase,
+				 pci_resource_len(pdev, 3));
+
+	/* number of TX + RX buffers for one port - this is dual port card */
+	i = ramsize / (2 * (sizeof(pkt_desc) + HDLC_MAX_MRU));
+	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
+	card->rx_ring_buffers = i - card->tx_ring_buffers;
+
+	card->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +
+						    card->rx_ring_buffers);
+
+	printk(KERN_INFO "pci200syn: %u KB RAM at 0x%x, IRQ%u, using %u TX +"
+	       " %u RX packets rings\n", ramsize / 1024, ramphys,
+	       pdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);
+
+	if (card->tx_ring_buffers < 1) {
+		printk(KERN_ERR "pci200syn: RAM test failed\n");
+		pci200_pci_remove_one(pdev);
+		return -EFAULT;
+	}
+
+	/* Enable interrupts on the PCI bridge */
+	p = &card->plxbase->intr_ctrl_stat;
+	writew(readw(p) | 0x0040, p);
+
+	/* Allocate IRQ */
+	if(request_irq(pdev->irq, sca_intr, SA_SHIRQ, devname, card)) {
+		printk(KERN_WARNING "pci200syn: could not allocate IRQ%d.\n",
+		       pdev->irq);
+		pci200_pci_remove_one(pdev);
+		return -EBUSY;
+	}
+	card->irq = pdev->irq;
+
+	sca_init(card, 0);
+
+	for(i = 0; i < 2; i++) {
+		port_t *port = &card->ports[i];
+		struct net_device *dev = hdlc_to_dev(&port->hdlc);
+		port->phy_node = i;
+
+		spin_lock_init(&port->lock);
+		SET_MODULE_OWNER(dev);
+		dev->irq = card->irq;
+		dev->mem_start = ramphys;
+		dev->mem_end = ramphys + ramsize - 1;
+		dev->tx_queue_len = 50;
+		dev->do_ioctl = pci200_ioctl;
+		dev->open = pci200_open;
+		dev->stop = pci200_close;
+		port->hdlc.attach = sca_attach;
+		port->hdlc.xmit = sca_xmit;
+		port->settings.clock_type = CLOCK_EXT;
+		if(register_hdlc_device(&port->hdlc)) {
+			printk(KERN_ERR "pci200syn: unable to register hdlc "
+			       "device\n");
+			pci200_pci_remove_one(pdev);
+			return -ENOBUFS;
+		}
+		port->card = card;
+		sca_init_sync_port(port);	/* Set up SCA memory */
+
+		printk(KERN_INFO "%s: PCI200SYN node %d\n",
+		       hdlc_to_name(&port->hdlc), port->phy_node);
+	}
+
+	sca_flush(card);
+	return 0;
+}
+
+
+
+static struct pci_device_id pci200_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_GORAMO, PCI_DEVICE_ID_PCI200SYN, PCI_ANY_ID,
+	  PCI_ANY_ID, 0, 0, 0 },
+	{ 0, }
+};
+
+
+static struct pci_driver pci200_pci_driver = {
+	name:	  "PCI200SYN",
+	id_table: pci200_pci_tbl,
+	probe:	  pci200_pci_init_one,
+	remove:	  pci200_pci_remove_one,
+};
+
+
+static int __init pci200_init_module(void)
+{
+#ifdef MODULE
+	printk(KERN_INFO "%s\n", version);
+#endif
+	if (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {
+		printk(KERN_ERR "pci200syn: Invalid PCI clock frequency\n");
+		return -EINVAL;
+	}
+	return pci_module_init(&pci200_pci_driver);
+}
+
+
+
+static void __exit pci200_cleanup_module(void)
+{
+	pci_unregister_driver(&pci200_pci_driver);
+}
+
+MODULE_AUTHOR("Krzysztof Halasa <khc@pm.waw.pl>");
+MODULE_DESCRIPTION("Goramo PCI200SYN serial port driver");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(pci, pci200_pci_tbl);
+module_param(pci_clock_freq, int, 0444);
+MODULE_PARM_DESC(pci_clock_freq, "System PCI clock frequency in Hz");
+module_init(pci200_init_module);
+module_exit(pci200_cleanup_module);
diff -purN linux-2.6.1/drivers/net/wireless/Kconfig linux-2.5/drivers/net/wireless/Kconfig
--- linux-2.6.1/drivers/net/wireless/Kconfig	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wireless/Kconfig	2004-01-11 00:57:32.000000000 +0000
@@ -282,7 +282,7 @@ config PCMCIA_ATMEL
          one of these, you will need to provide a firmware image
 	 to be loaded into the card by the driver. The Atmel
 	 firmware package can be downloaded from
-	 http://www.thekelleys.org.uk/atmel/atmel_firmware.tar.gz
+	 http://www.thekelleys.org.uk/atmel
 
 config PCMCIA_WL3501
       tristate "Planet WL3501 PCMCIA cards"
diff -purN linux-2.6.1/drivers/net/wireless/airo.c linux-2.5/drivers/net/wireless/airo.c
--- linux-2.6.1/drivers/net/wireless/airo.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/drivers/net/wireless/airo.c	2004-01-10 16:04:13.000000000 +0000
@@ -1027,7 +1027,6 @@ struct airo_info {
 #define FLAG_802_11	7
 #define FLAG_PENDING_XMIT 9
 #define FLAG_PENDING_XMIT11 10
-#define FLAG_PCI	11
 #define JOB_MASK	0x1ff0000
 #define JOB_DIE		16
 #define JOB_XMIT	17
@@ -4623,7 +4622,6 @@ static int __devinit airo_pci_probe(stru
 		return -ENODEV;
 
 	pci_set_drvdata(pdev, dev);
-	set_bit (FLAG_PCI, &((struct airo_info *)dev->priv)->flags);
 	return 0;
 }
 
@@ -4653,7 +4651,7 @@ static int __init airo_init_module( void
 
 #ifdef CONFIG_PCI
 	printk( KERN_INFO "airo:  Probing for PCI adapters\n" );
-	pci_module_init(&airo_driver);
+	pci_register_driver(&airo_driver);
 	printk( KERN_INFO "airo:  Finished probing for PCI adapters\n" );
 #endif
 
@@ -4665,22 +4663,15 @@ static int __init airo_init_module( void
 
 static void __exit airo_cleanup_module( void )
 {
-	int is_pci = 0;
 	while( airo_devices ) {
 		printk( KERN_INFO "airo: Unregistering %s\n", airo_devices->dev->name );
-#ifdef CONFIG_PCI
-		if (test_bit(FLAG_PCI, &((struct airo_info *)airo_devices->dev->priv)->flags))
-			is_pci = 1;
-#endif
 		stop_airo_card( airo_devices->dev, 1 );
 	}
 	remove_proc_entry("aironet", proc_root_driver);
 
-	if (is_pci) {
 #ifdef CONFIG_PCI
-		pci_unregister_driver(&airo_driver);
+	pci_unregister_driver(&airo_driver);
 #endif
-	}
 }
 
 #ifdef WIRELESS_EXT
diff -purN linux-2.6.1/drivers/net/wireless/atmel.c linux-2.5/drivers/net/wireless/atmel.c
--- linux-2.6.1/drivers/net/wireless/atmel.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/drivers/net/wireless/atmel.c	2004-01-11 00:57:32.000000000 +0000
@@ -67,7 +67,7 @@
 #include "ieee802_11.h"
 
 #define DRIVER_MAJOR 0
-#define DRIVER_MINOR 8
+#define DRIVER_MINOR 9
 
 MODULE_AUTHOR("Simon Kelley");
 MODULE_DESCRIPTION("Support for Atmel at76c50x 802.11 wireless ethernet cards.");
@@ -153,12 +153,15 @@ module_param(firmware, charp, 0);
 #define C80211_MGMT_ElementID_ChallengeText     16
 #define C80211_MGMT_CAPABILITY_ShortPreamble    0x0020
 
+#define MIB_MAX_DATA_BYTES    212
+#define MIB_HEADER_SIZE       4    /* first four fields */
+
 struct get_set_mib {
         u8 type;
         u8 size;
         u8 index;
         u8 reserved;
-        u8 data[72];
+        u8 data[MIB_MAX_DATA_BYTES];
 };
 
 struct rx_desc {
@@ -195,32 +198,40 @@ struct rx_desc {
 
 
 struct tx_desc {
-   u32       NextDescriptor;
-   u16       TxStartOfFrame;
-   u16       TxLength;
-   
-   u8        TxState;
-   u8        TxStatus;
-   u8        RetryCount;
-
-   u8        TxRate;
-   u32       TxTime;
-   u8        Reserved;
-   u8        PacketType;
-   u16       HostTxLength;
-
+	u32       NextDescriptor;
+	u16       TxStartOfFrame;
+	u16       TxLength;
+	
+	u8        TxState;
+	u8        TxStatus;
+	u8        RetryCount;
+	
+	u8        TxRate;
+
+	u8        KeyIndex;
+	u8        ChiperType;
+	u8        ChipreLength;
+        u8        Reserved1;
+
+	u8        Reserved;
+	u8        PacketType;
+	u16       HostTxLength;
+	
 };
 
 
-#define TX_DESC_NEXT_OFFSET        0
-#define TX_DESC_POS_OFFSET         4
-#define TX_DESC_SIZE_OFFSET        6
-#define TX_DESC_FLAGS_OFFSET       8
-#define TX_DESC_STATUS_OFFSET      9
-#define TX_DESC_RETRY_OFFSET       10
-#define TX_DESC_RATE_OFFSET        11
-#define TX_DESC_PACKET_TYPE_OFFSET 17
-#define TX_DESC_HOST_LENGTH_OFFSET 18
+#define TX_DESC_NEXT_OFFSET          0
+#define TX_DESC_POS_OFFSET           4
+#define TX_DESC_SIZE_OFFSET          6
+#define TX_DESC_FLAGS_OFFSET         8
+#define TX_DESC_STATUS_OFFSET        9
+#define TX_DESC_RETRY_OFFSET         10
+#define TX_DESC_RATE_OFFSET          11
+#define TX_DESC_KEY_INDEX_OFFSET     12
+#define TX_DESC_CIPHER_TYPE_OFFSET   13
+#define TX_DESC_CIPHER_LENGTH_OFFSET 14
+#define TX_DESC_PACKET_TYPE_OFFSET   17
+#define TX_DESC_HOST_LENGTH_OFFSET   18
 
 
 
@@ -324,6 +335,9 @@ struct tx_desc {
 #define ACTIVE_MODE 	1
 #define PS_MODE 	2
 
+#define MAX_ENCRYPTION_KEYS 4
+#define MAX_ENCRYPTION_KEY_SIZE 40
+
 ///////////////////////////////////////////////////////////////////////////
 // 802.11 related definitions
 ///////////////////////////////////////////////////////////////////////////
@@ -370,6 +384,14 @@ struct tx_desc {
 #define IFACE_FUNC_CTRL_OFFSET		28
 #define IFACE_MAC_STAT_OFFSET		30
 #define IFACE_GENERIC_INT_TYPE_OFFSET	32
+
+#define CIPHER_SUITE_NONE     0 
+#define CIPHER_SUITE_WEP_64   1
+#define CIPHER_SUITE_TKIP     2
+#define CIPHER_SUITE_AES      3
+#define CIPHER_SUITE_CCX      4
+#define CIPHER_SUITE_WEP_128  5
+
 //
 // IFACE MACROS & definitions
 //
@@ -432,6 +454,7 @@ struct atmel_private {
 	void *card; /* Bus dependent stucture varies for PCcard */
 	int (*present_callback)(void *); /* And callback which uses it */
 	char firmware_id[32];
+	char firmware_template[32];
 	unsigned char *firmware;
 	int firmware_length;
 	struct timer_list management_timer;
@@ -457,20 +480,11 @@ struct atmel_private {
 	u16 frag_seq, frag_len, frag_no;
 	u8 frag_source[6]; 
 	
-	int wep_key_len[4]; /* need to know these and not stored in Mib. */
-	struct { /* NB this is matched to the hardware, don't change. */
-		u8 wep_is_on;                 
-		u8 default_key; /* 0..3 */
-		u8 reserved;
-		u8 exclude_unencrypted;
-		
-		u32 WEPICV_error_count;
-		u32 WEP_excluded_count;
-		
-		u8 wep_keys[4][13];
-		u8 encryption_level; /* 0, 1, 2 */
-		u8 reserved2[3];
-	} wep;
+	u8 wep_is_on, default_key, exclude_unencrypted, encryption_level;
+	u8 group_cipher_suite, pairwise_cipher_suite;
+	u8 wep_keys[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];
+	int wep_key_len[MAX_ENCRYPTION_KEYS]; 
+	int use_wpa;
 
 	u16 host_info_base;
 	struct host_info_struct { 
@@ -510,8 +524,6 @@ struct atmel_private {
 		STATION_STATE_ASSOCIATING,
 		STATION_STATE_READY,
 		STATION_STATE_REASSOCIATING,
-		STATION_STATE_FORCED_JOINNING,
-		STATION_STATE_FORCED_JOIN_FAILURE,
 		STATION_STATE_DOWN,
 		STATION_STATE_NO_CARD,
 		STATION_STATE_MGMT_ERROR 
@@ -564,6 +576,7 @@ struct atmel_private {
 
 static u8 atmel_basic_rates[4] = {0x82,0x84,0x0b,0x16};
 
+static void build_wpa_mib(struct atmel_private *priv);
 static int atmel_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void atmel_copy_to_card(struct net_device *dev, u16 dest, unsigned char *src, u16 len);
 static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest, u16 src, u16 len);
@@ -717,14 +730,54 @@ static u16 find_tx_buff(struct atmel_pri
 	return 0;
 }
 
-static void tx_update_descriptor(struct atmel_private *priv, u16 len, u16 buff, u8 type)
+static void tx_update_descriptor(struct atmel_private *priv, int is_bcast, u16 len, u16 buff, u8 type)
 {
 	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, priv->tx_desc_tail), buff);
 	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_tail), len);
-	atmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);
+	if (!priv->use_wpa)
+		atmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_tail), type);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_RATE_OFFSET, priv->tx_desc_tail), priv->tx_rate);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_RETRY_OFFSET, priv->tx_desc_tail), 0);
+	if (priv->use_wpa) {
+		int cipher_type, cipher_length;
+		if (is_bcast) {
+			cipher_type = priv->group_cipher_suite;
+			if (cipher_type == CIPHER_SUITE_WEP_64 || 
+			    cipher_type == CIPHER_SUITE_WEP_128 )
+				cipher_length = 8;
+			else if (cipher_type == CIPHER_SUITE_TKIP)
+				cipher_length = 12;
+			else if (priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_64 ||
+				 priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_128) {
+				cipher_type = priv->pairwise_cipher_suite;
+				cipher_length = 8;
+			} else {
+				cipher_type = CIPHER_SUITE_NONE;
+				cipher_length = 0;
+			}
+		} else {
+			cipher_type = priv->pairwise_cipher_suite;
+			if (cipher_type == CIPHER_SUITE_WEP_64 || 
+			    cipher_type == CIPHER_SUITE_WEP_128 )
+				cipher_length = 8;
+			else if (cipher_type == CIPHER_SUITE_TKIP)
+				cipher_length = 12;
+			else if (priv->group_cipher_suite == CIPHER_SUITE_WEP_64 ||
+				 priv->group_cipher_suite == CIPHER_SUITE_WEP_128) {
+				cipher_type = priv->group_cipher_suite;
+				cipher_length = 8;
+			} else {
+				cipher_type = CIPHER_SUITE_NONE;
+				cipher_length = 0;
+			}
+		}
+		
+		atmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_TYPE_OFFSET, priv->tx_desc_tail),
+			    cipher_type);	
+		atmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_LENGTH_OFFSET, priv->tx_desc_tail),
+			    cipher_length);
+	}
 	atmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_tail), 0x80000000L);
 	atmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_tail), TX_FIRM_OWN);
 	if (priv->tx_desc_previous != priv->tx_desc_tail)
@@ -745,16 +798,19 @@ static int start_tx (struct sk_buff *skb
 	struct ieee802_11_hdr header;
 	unsigned long flags;
 	u16 buff, frame_ctl, len = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;
-	
-	if(priv->station_state != STATION_STATE_READY) {
+	u8 SNAP_RFC1024[6] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+ 
+	if (priv->station_state != STATION_STATE_READY) {
 		priv->stats.tx_errors++;
-		goto done;
+		dev_kfree_skb(skb);
+		return 0;
 	}
 	
 	if (priv->card && priv->present_callback && 
 	    !(*priv->present_callback)(priv->card)) {
 		priv->stats.tx_errors++;
-		goto done;
+		dev_kfree_skb(skb);
+		return 0;
 	}
 	
 	/* first ensure the timer func cannot run */
@@ -778,7 +834,7 @@ static int start_tx (struct sk_buff *skb
 	frame_ctl = IEEE802_11_FTYPE_DATA;
 	header.duration_id = 0;
 	header.seq_ctl = 0;
-	if (priv->wep.wep_is_on)
+	if (priv->wep_is_on)
 		frame_ctl |= IEEE802_11_FCTL_WEP;
 	if (priv->operating_mode == IW_MODE_ADHOC) {
 		memcpy(&header.addr1, skb->data, 6);
@@ -791,6 +847,9 @@ static int start_tx (struct sk_buff *skb
 		memcpy(&header.addr3, skb->data, 6);
 	}
 	
+	if (priv->use_wpa)
+		memcpy(&header.addr4, SNAP_RFC1024, 6);
+
 	header.frame_ctl = cpu_to_le16(frame_ctl);
 	/* Copy the wireless header into the card */
 	atmel_copy_to_card(dev, buff, (unsigned char *)&header, DATA_FRAME_WS_HEADER_SIZE);
@@ -798,14 +857,13 @@ static int start_tx (struct sk_buff *skb
 	atmel_copy_to_card(dev, buff + DATA_FRAME_WS_HEADER_SIZE, skb->data + 12, len - 12);
 	priv->tx_buff_tail += len - 12 + DATA_FRAME_WS_HEADER_SIZE;
 	
-	tx_update_descriptor(priv, len + 18, buff, TX_PACKET_TYPE_DATA);
+	/* low bit of first byte of destination tells us if broadcast */
+	tx_update_descriptor(priv, *(skb->data) & 0x01, len + 18, buff, TX_PACKET_TYPE_DATA);
 	dev->trans_start = jiffies;
 	priv->stats.tx_bytes += len;
 	
 	spin_unlock_irqrestore(&priv->irqlock, flags);
 	spin_unlock_bh(&priv->timerlock);
-
-done:
 	dev_kfree_skb(skb);
 	
 	return 0;	
@@ -824,7 +882,7 @@ static void atmel_transmit_management_fr
 	atmel_copy_to_card(priv->dev, buff, (u8 *)header, MGMT_FRAME_BODY_OFFSET);
 	atmel_copy_to_card(priv->dev, buff + MGMT_FRAME_BODY_OFFSET, body, body_len);
 	priv->tx_buff_tail += len;
-	tx_update_descriptor(priv, len, buff, TX_PACKET_TYPE_MGMT);
+	tx_update_descriptor(priv, header->addr1[0] & 0x01, len, buff, TX_PACKET_TYPE_MGMT);
 }
 	
 static void fast_rx_path(struct atmel_private *priv, struct ieee802_11_hdr *header, 
@@ -1027,7 +1085,7 @@ static void rx_done_irq(struct atmel_pri
 		/* probe for CRC use here if needed  once five packets have arrived with
 		   the same crc status, we assume we know what's happening and stop probing */
 		if (priv->probe_crc) {
-			if (!priv->wep.wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP)) {
+			if (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP)) {
 				priv->do_rx_crc = probe_crc(priv, rx_packet_loc, msdu_size);
 			} else {
 				priv->do_rx_crc = probe_crc(priv, rx_packet_loc + 24, msdu_size - 24);
@@ -1042,7 +1100,7 @@ static void rx_done_irq(struct atmel_pri
 		}
 		    
 		/* don't CRC header when WEP in use */
-		if (priv->do_rx_crc && (!priv->wep.wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP))) {
+		if (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP))) {
 			crc = crc32_le(0xffffffff, (unsigned char *)&header, 24);
 		}
 		msdu_size -= 24; /* header */
@@ -1158,6 +1216,9 @@ static irqreturn_t service_interrupt(int
 			reset_irq_status(priv, ISR_IBSS_MERGE);
 			atmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS, 
 				      priv->CurrentBSSID, 6);
+			/* The WPA stuff cares about the current AP address */
+			if (priv->use_wpa)
+				build_wpa_mib(priv);
 		} else if (isr & ISR_GENERIC_IRQ) {
 			reset_irq_status(priv, ISR_GENERIC_IRQ);
 			printk(KERN_INFO "%s: Generic_irq recieved.\n", dev->name);
@@ -1237,6 +1298,7 @@ static int atmel_close (struct net_devic
 {
 	struct atmel_private *priv = (struct atmel_private *) dev->priv;
 		
+	netif_carrier_off(dev);	
 	if (netif_running(dev))
 		netif_stop_queue(dev);
 	
@@ -1255,17 +1317,17 @@ static int atmel_proc_output (char *buf,
 	p += sprintf(p, "Driver version:\t\t%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR);
 	
 	if (priv->station_state != STATION_STATE_DOWN) {
-		p += sprintf(p, "Firmware version:\t%d.%d build %d ", 
+		p += sprintf(p, "Firmware version:\t%d.%d build %d\nFirmware location:\t", 
 			     priv->host_info.major_version,
 			     priv->host_info.minor_version,
 			     priv->host_info.build_version);
 		
 		if (priv->card_type != CARD_TYPE_EEPROM) 
-			p += sprintf(p, "[built-in]\n");
+			p += sprintf(p, "on card\n");
 		else if (priv->firmware) 
-			p += sprintf(p, "[%s loaded by host]\n", priv->firmware_id);
+			p += sprintf(p, "%s loaded by host\n", priv->firmware_id);
 		else
-			p += sprintf(p, "[%s loaded by hotplug]\n", priv->firmware_id);
+			p += sprintf(p, "%s loaded by hotplug\n", priv->firmware_id);
 		
 		switch(priv->card_type) {
 		case CARD_TYPE_PARALLEL_FLASH: c = "Parallel flash"; break;
@@ -1289,6 +1351,8 @@ static int atmel_proc_output (char *buf,
 		p += sprintf(p, "Regulatory domain:\t%s\n", r);
 		p += sprintf(p, "Host CRC checking:\t%s\n", 
 			     priv->do_rx_crc ? "On" : "Off");
+		p += sprintf(p, "WPA-capable firmware:\t%s\n",
+			     priv->use_wpa ? "Yes" : "No");
 	}
 	
 	switch(priv->station_state) {
@@ -1299,8 +1363,6 @@ static int atmel_proc_output (char *buf,
 	case STATION_STATE_ASSOCIATING: s = "Associating"; break;
 	case STATION_STATE_READY: s = "Ready"; break;
 	case STATION_STATE_REASSOCIATING: s = "Reassociating"; break;
-	case STATION_STATE_FORCED_JOINNING: s = "Forced joining"; break;
-	case STATION_STATE_FORCED_JOIN_FAILURE: s = "Forced join failure"; break;
 	case STATION_STATE_NO_CARD: s = "No card"; break;
 	case STATION_STATE_MGMT_ERROR: s = "Management error"; break;
 	case STATION_STATE_DOWN: s = "Down"; break;
@@ -1348,12 +1410,12 @@ struct net_device *init_atmel_card( unsi
 	priv->present_callback = card_present;
 	priv->card = card;
 	priv->firmware = NULL;
+	priv->firmware_id[0] = '\0';
+	priv->firmware_template[0] = '\0';
 	if (firmware) /* module parameter */
 		strcpy(priv->firmware_id, firmware);
 	else if (firmware_id) /* from PCMCIA card-matching or PCI */
-		strcpy(priv->firmware_id, firmware_id);
-	else
-		priv->firmware_id[0] = '\0';
+		strcpy(priv->firmware_template, firmware_id);
 	priv->bus_type = card_present ? BUS_TYPE_PCCARD : BUS_TYPE_PCI;
 	priv->station_state = STATION_STATE_DOWN;
 	priv->is3com = is3com;
@@ -1389,9 +1451,16 @@ struct net_device *init_atmel_card( unsi
 	priv->rts_threshold = 2347;
 	priv->short_retry = 7;
 	priv->long_retry = 4;
-	priv->wep.wep_is_on = 0;
-	priv->wep.default_key = 0;
-	priv->wep.encryption_level = 0;
+
+	priv->wep_is_on = 0;
+	priv->default_key = 0;
+	priv->encryption_level = 0;
+	priv->exclude_unencrypted = 0;
+	priv->group_cipher_suite = priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;
+	priv->use_wpa = 0;
+	memset(priv->wep_keys, 0, sizeof(priv->wep_keys));
+	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
+
 	priv->default_beacon_period = priv->beacon_period = 100;
 	priv->listen_interval = 1;
 
@@ -1426,8 +1495,12 @@ struct net_device *init_atmel_card( unsi
 	if (register_netdev(dev))
 		goto err_out_res;
 	
-	if (!probe_atmel_card(dev))
+	if (!probe_atmel_card(dev)){
+		unregister_netdev(dev);
 		goto err_out_res;
+	}
+	
+	netif_carrier_off(dev);
 	
 	create_proc_read_entry ("driver/atmel", 0, 0, atmel_read_proc, priv);	
 	
@@ -1443,7 +1516,7 @@ struct net_device *init_atmel_card( unsi
  err_out_irq:
 	free_irq(dev->irq, dev);
  err_out_free:
-	kfree(dev);
+	free_netdev(dev);
 	return NULL;
 }
 
@@ -1582,7 +1655,7 @@ static int atmel_set_encode(struct net_d
 	 * don't do it. - Jean II */
 	if (dwrq->length > 0) {
 		int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
-		int current_index = priv->wep.default_key;
+		int current_index = priv->default_key;
 		/* Check the size of the key */
 		if (dwrq->length > 13) {
 			return -EINVAL;
@@ -1591,7 +1664,7 @@ static int atmel_set_encode(struct net_d
 		if (index < 0 || index >= 4)
 			index = current_index;
 		else
-			priv->wep.default_key = index;
+			priv->default_key = index;
 		/* Set the length */
 		if (dwrq->length > 5)
 			priv->wep_key_len[index] = 13;
@@ -1604,27 +1677,30 @@ static int atmel_set_encode(struct net_d
 		/* Check if the key is not marked as invalid */
 		if(!(dwrq->flags & IW_ENCODE_NOKEY)) {
 			/* Cleanup */
-			memset(priv->wep.wep_keys[index], 0, 13);
+			memset(priv->wep_keys[index], 0, 13);
 			/* Copy the key in the driver */
-			memcpy(priv->wep.wep_keys[index], extra, dwrq->length);
+			memcpy(priv->wep_keys[index], extra, dwrq->length);
 		}
 		/* WE specify that if a valid key is set, encryption
 		 * should be enabled (user may turn it off later)
 		 * This is also how "iwconfig ethX key on" works */
 		if (index == current_index && 
 		    priv->wep_key_len[index] > 0) {
-			priv->wep.wep_is_on = 1;
-			priv->wep.exclude_unencrypted = 1;
-			if (priv->wep_key_len[index] > 5)
-				priv->wep.encryption_level = 2;
-			else
-				priv->wep.encryption_level = 1;
+			priv->wep_is_on = 1;
+			priv->exclude_unencrypted = 1;
+			if (priv->wep_key_len[index] > 5) {
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+				priv->encryption_level = 2;
+			} else {
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+				priv->encryption_level = 1;
+			}
 		}
 	} else {
 		/* Do we want to just set the transmit key index ? */
 		int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 		if ( index>=0 && index < 4 ) {
-			priv->wep.default_key = index;
+			priv->default_key = index;
 		} else
 			/* Don't complain if only change the mode */
 			if(!dwrq->flags & IW_ENCODE_MODE) {
@@ -1633,19 +1709,23 @@ static int atmel_set_encode(struct net_d
 	}
 	/* Read the flags */
 	if(dwrq->flags & IW_ENCODE_DISABLED) {
-		priv->wep.wep_is_on = 0;
-		priv->wep.encryption_level = 0; 
+		priv->wep_is_on = 0;
+		priv->encryption_level = 0; 	
+		priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;
 	} else {
-		priv->wep.wep_is_on = 1;
-		if (priv->wep_key_len[priv->wep.default_key] > 5)
-			priv->wep.encryption_level = 2;
-		else
-			priv->wep.encryption_level = 1;
+		priv->wep_is_on = 1;
+		if (priv->wep_key_len[priv->default_key] > 5) {
+			priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+			priv->encryption_level = 2;
+		} else {
+			priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+			priv->encryption_level = 1;
+		}
 	}
 	if(dwrq->flags & IW_ENCODE_RESTRICTED)
-		priv->wep.exclude_unencrypted = 1;
+		priv->exclude_unencrypted = 1;
 	if(dwrq->flags & IW_ENCODE_OPEN)
-		priv->wep.exclude_unencrypted = 0;
+		priv->exclude_unencrypted = 0;
 	
 	return -EINPROGRESS;		/* Call commit handler */
 }
@@ -1659,16 +1739,16 @@ static int atmel_get_encode(struct net_d
 	struct atmel_private *priv = dev->priv;
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 	
-	if (!priv->wep.wep_is_on)
+	if (!priv->wep_is_on)
 		dwrq->flags = IW_ENCODE_DISABLED;
-	else if (priv->wep.exclude_unencrypted)
+	else if (priv->exclude_unencrypted)
 		dwrq->flags = IW_ENCODE_RESTRICTED;
 	else
 		dwrq->flags = IW_ENCODE_OPEN;
 		
 		/* Which key do we want ? -1 -> tx index */
 	if (index < 0 || index >= 4)
-		index = priv->wep.default_key;
+		index = priv->default_key;
 	dwrq->flags |= index + 1;
 	/* Copy the key to the user buffer */
 	dwrq->length = priv->wep_key_len[index];
@@ -1676,7 +1756,7 @@ static int atmel_get_encode(struct net_d
 		dwrq->length=0;
 	} else {
 		memset(extra, 0, 16);
-		memcpy(extra, priv->wep.wep_keys[index], dwrq->length);
+		memcpy(extra, priv->wep_keys[index], dwrq->length);
 	}
 	
 	return 0;
@@ -1711,10 +1791,10 @@ static int atmel_set_rate(struct net_dev
 		} else {
 		/* Setting by frequency value */
 			switch (vwrq->value) {
-			case (int)1e6: priv->tx_rate = 0; break;
-			case (int)2e6: priv->tx_rate = 1; break;
-			case (int)5.5e6: priv->tx_rate = 2; break;
-			case (int)11e6:  priv->tx_rate = 3; break;
+			case  1000000: priv->tx_rate = 0; break;
+			case  2000000: priv->tx_rate = 1; break;
+			case  5500000: priv->tx_rate = 2; break;
+			case 11000000: priv->tx_rate = 3; break;
 			default: return -EINVAL;
 			}
 		}
@@ -1757,14 +1837,14 @@ static int atmel_get_rate(struct net_dev
 
 	if (priv->auto_tx_rate) {
 		vwrq->fixed = 0;
-		vwrq->value = 11e6;
+		vwrq->value = 11000000;
 	} else {
 		vwrq->fixed = 1;
 		switch(priv->tx_rate) {
-		case 0: vwrq->value = 1e6; break;
-		case 1: vwrq->value = 2e6; break;
-		case 2: vwrq->value = 5.5e6; break;
-		case 3: vwrq->value = 11e6; break;
+		case 0: vwrq->value =  1000000; break;
+		case 1: vwrq->value =  2000000; break;
+		case 2: vwrq->value =  5500000; break;
+		case 3: vwrq->value = 11000000; break;
 		}
 	}
 	return 0;
@@ -1982,6 +2062,7 @@ static int atmel_set_scan(struct net_dev
 	
 	atmel_clear_gcr(dev, GCR_ENINT); /* disable interrupts */
 	del_timer_sync(&priv->management_timer);
+	priv->fast_scan = 0;
 	atmel_scan(priv, 0);
 	atmel_set_gcr(dev, GCR_ENINT); /* enable interrupts */
 	
@@ -2073,10 +2154,10 @@ static int atmel_get_range(struct net_de
 	range->max_qual.noise = 0;
 	range->sensitivity = 0;
 
-	range->bitrate[0] = 1e6;
-	range->bitrate[1] = 2e6;
-	range->bitrate[2] = 5.5e6;
-	range->bitrate[3] = 11e6;
+	range->bitrate[0] =  1000000;
+	range->bitrate[1] =  2000000;
+	range->bitrate[2] =  5500000;
+	range->bitrate[3] = 11000000;
 	range->num_bitrates = 4;
 
 	range->min_rts = 0;
@@ -2129,9 +2210,9 @@ static int atmel_set_wap(struct net_devi
 	
 	for(i=0; i<priv->BSS_list_entries; i++) {
 		if (memcmp(priv->BSSinfo[i].BSSID, awrq->sa_data, 6) == 0) {
-			if (!priv->wep.wep_is_on && priv->BSSinfo[i].UsingWEP) {
+			if (!priv->wep_is_on && priv->BSSinfo[i].UsingWEP) {
 				return -EINVAL;
-			} else if  (priv->wep.wep_is_on && !priv->BSSinfo[i].UsingWEP) {
+			} else if  (priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) {
 				return -EINVAL;
 			} else 
 				atmel_join_bss(priv, i);  
@@ -2313,10 +2394,13 @@ static void atmel_enter_state(struct atm
 	if (new_state == old_state)
 		return;
 
-	if (new_state == STATION_STATE_READY)
+	if (new_state == STATION_STATE_READY) {
 		netif_start_queue(priv->dev);
+		netif_carrier_on(priv->dev);
+	}
 
 	if (old_state == STATION_STATE_READY) {
+		netif_carrier_off(priv->dev);
 		netif_stop_queue(priv->dev);
 		priv->last_beacon_timestamp = 0;
 	}
@@ -2453,7 +2537,7 @@ static void send_authentication_request(
 	memcpy(header.addr2, priv->dev->dev_addr, 6);
 	memcpy(header.addr3, priv->CurrentBSSID, 6);
 	
-	if (priv->wep.wep_is_on) {
+	if (priv->wep_is_on) {
 		auth.alg = C80211_MGMT_AAN_SHAREDKEY; 
 		/* no WEP for authentication frames with TrSeqNo 1 */
 		if (priv->CurrentAuthentTransactionSeqNum != 1)
@@ -2504,7 +2588,7 @@ static void send_association_request(str
 	memcpy(header.addr3, priv->CurrentBSSID, 6); 
 
 	body.capability = cpu_to_le16(C80211_MGMT_CAPABILITY_ESS);
-	if (priv->wep.wep_is_on)
+	if (priv->wep_is_on)
 		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_Privacy);
 	if (priv->preamble == SHORT_PREAMBLE)
 		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_ShortPreamble);
@@ -2555,8 +2639,8 @@ static int retrieve_bss(struct atmel_pri
 		priv->current_BSS = 0;
 		for(i=0; i<priv->BSS_list_entries; i++) { 
 			if (priv->operating_mode == priv->BSSinfo[i].BSStype &&
-			    ((!priv->wep.wep_is_on && !priv->BSSinfo[i].UsingWEP) || 
-			     (priv->wep.wep_is_on && priv->BSSinfo[i].UsingWEP)) &&
+			    ((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) || 
+			     (priv->wep_is_on && priv->BSSinfo[i].UsingWEP)) &&
 			    !(priv->BSSinfo[i].channel & 0x80)) {
 				max_rssi = priv->BSSinfo[i].RSSI;
 				priv->current_BSS = max_index = i;
@@ -2630,7 +2714,7 @@ static void authenticate(struct atmel_pr
 	u16 status = le16_to_cpu(auth->status);
 	u16 trans_seq_no = le16_to_cpu(auth->trans_seq);
 	
-	if (status == C80211_MGMT_SC_Success && !priv->wep.wep_is_on) { 
+	if (status == C80211_MGMT_SC_Success && !priv->wep_is_on) { 
 		/* no WEP */
 		if (priv->station_was_associated) {
 			atmel_enter_state(priv, STATION_STATE_REASSOCIATING);
@@ -2643,7 +2727,7 @@ static void authenticate(struct atmel_pr
 		} 
 	}
 		
-	if (status == C80211_MGMT_SC_Success && priv->wep.wep_is_on) { 
+	if (status == C80211_MGMT_SC_Success && priv->wep_is_on) { 
 		/* WEP */
 		if (trans_seq_no != priv->ExpectedAuthentTransactionSeqNum)
 			return;
@@ -2765,6 +2849,10 @@ void atmel_join_bss(struct atmel_private
 
 	memcpy(priv->CurrentBSSID, bss->BSSID, 6);
 	memcpy(priv->SSID, bss->SSID, priv->SSID_size = bss->SSIDsize);
+
+	/* The WPA stuff cares about the current AP address */
+	if (priv->use_wpa)
+		build_wpa_mib(priv);
 	
 	/* When switching to AdHoc turn OFF Power Save if needed */
 
@@ -2786,13 +2874,13 @@ void atmel_join_bss(struct atmel_private
 		atmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, bss->preamble);
 	}
 	
-	if (!priv->wep.wep_is_on && bss->UsingWEP) {
+	if (!priv->wep_is_on && bss->UsingWEP) {
 		atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
 		priv->station_is_associated = 0;
 		return;
 	}
 		
-	if (priv->wep.wep_is_on && !bss->UsingWEP) {
+	if (priv->wep_is_on && !bss->UsingWEP) {
 		atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
 		priv->station_is_associated = 0;
 		return;
@@ -3071,6 +3159,7 @@ static void atmel_command_irq(struct atm
 				priv->fast_scan = !fast_scan;
 				atmel_scan(priv, 1);
 			}
+			priv->site_survey_state = SITE_SURVEY_COMPLETED;
 		}
 		break;
 		
@@ -3104,12 +3193,8 @@ static void atmel_command_irq(struct atm
 			return;
 		}
 		
-
-		if (priv->station_state == STATION_STATE_FORCED_JOINNING) {
-			atmel_enter_state(priv, STATION_STATE_FORCED_JOIN_FAILURE); 
-		} else {
-			atmel_scan(priv, 1);
-		}
+		atmel_scan(priv, 1);
+		
 	}
 }
 
@@ -3275,7 +3360,7 @@ static int probe_atmel_card(struct net_d
 			printk(KERN_ALERT "%s: *** Invalid MAC address. UPGRADE Firmware ****\n", dev->name);
 			memcpy(dev->dev_addr, default_mac, 6);
 		}
-		printk(KERN_INFO "%s: MAC address %x:%x:%x:%x:%x:%x\n",
+		printk(KERN_INFO "%s: MAC address %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
 		       dev->name,
 		       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
 		       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
@@ -3285,6 +3370,105 @@ static int probe_atmel_card(struct net_d
 	return rc;
 }
 
+static void build_wep_mib(struct atmel_private *priv)
+/* Move the encyption information on the MIB structure.
+   This routine is for the pre-WPA firmware: later firmware has
+   a different format MIB and a different routine. */
+{
+	struct { /* NB this is matched to the hardware, don't change. */
+		u8 wep_is_on;                 
+		u8 default_key; /* 0..3 */
+		u8 reserved;
+		u8 exclude_unencrypted;
+		
+		u32 WEPICV_error_count;
+		u32 WEP_excluded_count;
+		
+		u8 wep_keys[MAX_ENCRYPTION_KEYS][13];
+ 		u8 encryption_level; /* 0, 1, 2 */
+		u8 reserved2[3]; 
+	} mib;
+	int i;
+
+	mib.wep_is_on = priv->wep_is_on;
+	if (priv->wep_is_on) {
+		if (priv->wep_key_len[priv->default_key] > 5)
+			mib.encryption_level = 2;
+		else
+			mib.encryption_level = 1;	
+	} else {
+		mib.encryption_level = 0;
+	}
+
+	mib.default_key = priv->default_key;
+	mib.exclude_unencrypted = priv->exclude_unencrypted;
+	
+	for(i = 0; i < MAX_ENCRYPTION_KEYS;  i++)
+		memcpy(mib.wep_keys[i], priv->wep_keys[i], 13);
+		
+	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));
+}
+
+static void build_wpa_mib(struct atmel_private *priv)
+{
+	/* This is for the later (WPA enabled) firmware. */	   
+
+	struct { /* NB this is matched to the hardware, don't change. */
+		u8 cipher_default_key_value[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];
+		u8 receiver_address[6];
+		u8 wep_is_on;                 
+		u8 default_key; /* 0..3 */
+		u8 group_key;
+		u8 exclude_unencrypted;
+		u8 encryption_type;
+		u8 reserved;
+		
+		u32 WEPICV_error_count;
+		u32 WEP_excluded_count;
+		
+		u8 key_RSC[4][8];
+	} mib;
+	
+	int i;
+
+	mib.wep_is_on = priv->wep_is_on;
+	mib.exclude_unencrypted = priv->exclude_unencrypted;
+	memcpy(mib.receiver_address, priv->CurrentBSSID, 6);
+	
+	/* zero all the keys before adding in valid ones. */
+	memset(mib.cipher_default_key_value, 0, sizeof(mib.cipher_default_key_value));
+	
+	if (priv->wep_is_on) {
+		/* There's a comment in the Atmel code to the effect that this is only valid
+		   when still using WEP, it may need to be set to something to use WPA */
+		memset(mib.key_RSC, 0, sizeof(mib.key_RSC));
+		
+		mib.default_key = mib.group_key = 255;
+		for (i = 0; i < MAX_ENCRYPTION_KEYS; i++) {
+			if (priv->wep_key_len[i] > 0) {
+				memcpy(mib.cipher_default_key_value[i], priv->wep_keys[i], MAX_ENCRYPTION_KEY_SIZE);
+				if (i == priv->default_key) {
+					mib.default_key = i;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 7;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite; 
+				} else {
+					mib.group_key = i;
+					priv->group_cipher_suite = priv->pairwise_cipher_suite;
+				        mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;	
+				}
+			}
+		}
+		if (mib.default_key == 255)
+			mib.default_key = mib.group_key != 255 ? mib.group_key : 0;
+		if (mib.group_key == 255)
+			mib.group_key = mib.default_key;
+		
+	}
+	
+	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));
+}
+					
 int reset_atmel_card(struct net_device *dev) 
 {
 	/* do everything necessary to wake up the hardware, including
@@ -3305,6 +3489,15 @@ int reset_atmel_card(struct net_device *
 	struct atmel_private *priv = dev->priv;
 	u8 configuration;
 	
+	/* data to add to the firmware names, in priority order
+	   this implemenents firmware versioning */
+	
+	static char *firmware_modifier[] = {
+		"-wpa",
+		"",
+		NULL
+	};
+	
 	if (priv->station_state == STATION_STATE_NO_CARD ||
 	    priv->station_state == STATION_STATE_DOWN)
 		return 0;
@@ -3341,21 +3534,41 @@ int reset_atmel_card(struct net_device *
 		unsigned char *fw;
 		int len = priv->firmware_length;
 		if (!(fw = priv->firmware)) { 
-			if (strlen(priv->firmware_id) == 0) {
-				printk(KERN_INFO
-				       "%s: card type is unknown: assuming at76c502 firmware is OK.\n",
-				       dev->name);
-				printk(KERN_INFO
-				       "%s: if not, use the firmware= module parameter.\n", 
-				       dev->name);
-				strcpy(priv->firmware_id, "atmel_at76c502.bin");
-			}
-			if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) != 0) {
-				printk(KERN_ALERT 
-				       "%s: firmware %s is missing, cannot start.\n", 
-				       dev->name, priv->firmware_id);
-				return 0;
+			if (strlen(priv->firmware_template) == 0) {	
+				if (strlen(priv->firmware_id) == 0) {
+					printk(KERN_INFO
+					       "%s: card type is unknown: assuming at76c502 firmware is OK.\n",
+					       dev->name);
+					printk(KERN_INFO
+					       "%s: if not, use the firmware= module parameter.\n", 
+					       dev->name);
+					strcpy(priv->firmware_id, "atmel_at76c502.bin");
+				}
+				if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) != 0) {
+					printk(KERN_ALERT 
+					       "%s: firmware %s is missing, cannot continue.\n", 
+					       dev->name, priv->firmware_id);
+					return 0;
+					
+				} 
+			} else {
+				int i;
+				
+				for (i = 0; firmware_modifier[i]; i++) {
+					sprintf(priv->firmware_id, priv->firmware_template, firmware_modifier[i]);
+					if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) == 0) 
+						break;
+				}
+				if (!firmware_modifier[i]) {
+					printk(KERN_ALERT 
+					       "%s: firmware %s is missing, cannot start.\n", 
+					       dev->name, priv->firmware_id);
+					priv->firmware_id[0] = '\0';
+					return 0;	
+				}
+				priv->firmware_template[0] = '\0';	
 			}
+			
 			fw = fw_entry->data;
 			len = fw_entry->size;
 		}
@@ -3379,6 +3592,10 @@ int reset_atmel_card(struct net_device *
 
 	if (!atmel_wakeup_firmware(priv))
 		return 0;
+
+	/* Check the version and set the correct flag for wpa stuff,
+	   old and new firmware is incompatible. */
+	priv->use_wpa = (priv->host_info.major_version >= 4);
 	
         /* unmask all irq sources */
 	atmel_wmem8(priv, atmel_hi(priv, IFACE_INT_MASK_OFFSET), 0xff);
@@ -3447,9 +3664,12 @@ int reset_atmel_card(struct net_device *
 	atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
 	atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_BEACON_PER_POS, priv->default_beacon_period);
 	atmel_set_mib(priv, Phy_Mib_Type, PHY_MIB_RATE_SET_POS, atmel_basic_rates, 4);
-	atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep.wep_is_on);
-	atmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&priv->wep, sizeof(priv->wep));
-		
+	atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep_is_on);
+	if (priv->use_wpa)
+		build_wpa_mib(priv);
+	else
+		build_wep_mib(priv);
+	
 	atmel_scan(priv, 1);
 	
 	atmel_set_gcr(priv->dev, GCR_ENINT); /* enable interrupts */
@@ -3500,8 +3720,8 @@ static u8 atmel_get_mib8(struct atmel_pr
 	m.size = 1;
 	m.index = index;
 
-	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, sizeof(m));
-	return atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + 4));
+	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + 1);
+	return atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE));
 }
 
 static void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index, u8 data)
@@ -3512,7 +3732,7 @@ static void atmel_set_mib8(struct atmel_
 	m.index = index;
 	m.data[0] = data;
 
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 1);
 }
 
 static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index, u16 data)
@@ -3524,7 +3744,7 @@ static void atmel_set_mib16(struct atmel
 	m.data[0] = data;
 	m.data[1] = data >> 8;
 
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 2);
 }
 
 static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
@@ -3534,8 +3754,11 @@ static void atmel_set_mib(struct atmel_p
 	m.size = data_len;
 	m.index = index;
 
+	if (data_len > MIB_MAX_DATA_BYTES)
+		printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);
+	
 	memcpy(m.data, data, data_len);
-	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, sizeof(m));
+	atmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
 }
 
 static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
@@ -3545,10 +3768,14 @@ static void atmel_get_mib(struct atmel_p
 	m.size = data_len;
 	m.index = index;
 	
-	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, sizeof(m));
-	atmel_copy_to_host(priv->dev, data, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + 4), data_len);
-}
+	if (data_len > MIB_MAX_DATA_BYTES)
+		printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);
 	
+	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
+	atmel_copy_to_host(priv->dev, data, 
+			   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);
+}
+
 static void atmel_writeAR(struct net_device *dev, u16 data)
 {
 	int i;
diff -purN linux-2.6.1/drivers/net/wireless/atmel_cs.c linux-2.5/drivers/net/wireless/atmel_cs.c
--- linux-2.6.1/drivers/net/wireless/atmel_cs.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/drivers/net/wireless/atmel_cs.c	2004-01-11 00:57:32.000000000 +0000
@@ -330,20 +330,20 @@ static struct { 
 	char *firmware;
 	char *name;
 } card_table[] = {
-	{ 0, 0, "WLAN/802.11b PC CARD", "atmel_at76c502d.bin", "Actiontec 802CAT1" },  
-	{ 0, 0, "ATMEL/AT76C502AR", "atmel_at76c502.bin", "NoName-RFMD" }, 
-	{ 0, 0, "ATMEL/AT76C502AR_D", "atmel_at76c502d.bin", "NoName-revD" }, 
-	{ 0, 0, "ATMEL/AT76C502AR_E", "atmel_at76c502e.bin", "NoName-revE" },
-	{ 0, 0, "ATMEL/AT76C504", "atmel_at76c504.bin", "NoName-504" },
-	{ MANFID_3COM, 0x0620, NULL, "atmel_at76c502_3com.bin", "3com 3CRWE62092B" }, 
-	{ MANFID_3COM, 0x0696, NULL, "atmel_at76c502_3com.bin", "3com 3CRSHPW_96" }, 
-	{ 0, 0, "SMC/2632W-V2", "atmel_at76c502.bin", "SMC 2632W-V2" },
-        { 0, 0, "SMC/2632W", "atmel_at76c502d.bin", "SMC 2632W-V3" },
-	{ 0xd601, 0x0007, NULL, "atmel_at76c502.bin", "Sitecom WLAN-011"}, /* suspect - from a usenet posting. */
-	{ 0x01bf, 0x3302, NULL, "atmel_at76c502d.bin", "Belkin F5D6060u"},  /*    "        "  "    "      "     */
-	{ 0, 0, "BT/Voyager 1020 Laptop Adapter", "atmel_at76c502.bin", "BT Voyager 1020"},
-        { 0, 0, "IEEE 802.11b/Wireless LAN PC Card", "atmel_at76c502.bin", "Siemens Gigaset PC Card II" },
-	{ 0, 0, "CNet/CNWLC 11Mbps Wireless PC Card V-5", "atmel_at76c502e.bin", "CNet CNWLC-811ARL" }
+	{ 0, 0, "WLAN/802.11b PC CARD", "atmel_at76c502d%s.bin", "Actiontec 802CAT1" },  
+	{ 0, 0, "ATMEL/AT76C502AR", "atmel_at76c502%s.bin", "NoName-RFMD" }, 
+	{ 0, 0, "ATMEL/AT76C502AR_D", "atmel_at76c502d%s.bin", "NoName-revD" }, 
+	{ 0, 0, "ATMEL/AT76C502AR_E", "atmel_at76c502e%s.bin", "NoName-revE" },
+	{ 0, 0, "ATMEL/AT76C504", "atmel_at76c504%s.bin", "NoName-504" },
+	{ MANFID_3COM, 0x0620, NULL, "atmel_at76c502_3com%s.bin", "3com 3CRWE62092B" }, 
+	{ MANFID_3COM, 0x0696, NULL, "atmel_at76c502_3com%s.bin", "3com 3CRSHPW_96" }, 
+	{ 0, 0, "SMC/2632W-V2", "atmel_at76c502%s.bin", "SMC 2632W-V2" },
+        { 0, 0, "SMC/2632W", "atmel_at76c502d%s.bin", "SMC 2632W-V3" },
+	{ 0xd601, 0x0007, NULL, "atmel_at76c502%s.bin", "Sitecom WLAN-011"}, /* suspect - from a usenet posting. */
+	{ 0x01bf, 0x3302, NULL, "atmel_at76c502d%s.bin", "Belkin F5D6060u"},  /*    "        "  "    "      "     */
+	{ 0, 0, "BT/Voyager 1020 Laptop Adapter", "atmel_at76c502%s.bin", "BT Voyager 1020"},
+        { 0, 0, "IEEE 802.11b/Wireless LAN PC Card", "atmel_at76c502%s.bin", "Siemens Gigaset PC Card II" },
+	{ 0, 0, "CNet/CNWLC 11Mbps Wireless PC Card V-5", "atmel_at76c502e%s.bin", "CNet CNWLC-811ARL" }
 };
 
 /* This is strictly temporary, until PCMCIA devices get integrated into the device model. */
diff -purN linux-2.6.1/include/linux/net.h linux-2.5/include/linux/net.h
--- linux-2.6.1/include/linux/net.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/linux/net.h	2004-01-09 09:46:38.000000000 +0000
@@ -120,9 +120,9 @@ struct proto_ops {
 	int		(*getsockopt)(struct socket *sock, int level,
 				      int optname, char __user *optval, int __user *optlen);
 	int		(*sendmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, int total_len);
+				      struct msghdr *m, size_t total_len);
 	int		(*recvmsg)   (struct kiocb *iocb, struct socket *sock,
-				      struct msghdr *m, int total_len,
+				      struct msghdr *m, size_t total_len,
 				      int flags);
 	int		(*mmap)	     (struct file *file, struct socket *sock,
 				      struct vm_area_struct * vma);
@@ -151,13 +151,13 @@ extern int	     sock_create(int family, 
 				 struct socket **res);
 extern void	     sock_release(struct socket *sock);
 extern int   	     sock_sendmsg(struct socket *sock, struct msghdr *msg,
-				  int len);
+				  size_t len);
 extern int	     sock_recvmsg(struct socket *sock, struct msghdr *msg,
-				  int size, int flags);
+				  size_t size, int flags);
 extern int	     sock_readv_writev(int type, struct inode *inode,
 				       struct file *file,
 				       const struct iovec *iov, long count,
-				       long size);
+				       size_t size);
 extern int 	     sock_map_fd(struct socket *sock);
 extern struct socket *sockfd_lookup(int fd, int *err);
 #define		     sockfd_put(sock) fput(sock->file)
@@ -216,9 +216,9 @@ SOCKCALL_WRAP(name, setsockopt, (struct 
 			 char *optval, int optlen), (sock, level, optname, optval, optlen)) \
 SOCKCALL_WRAP(name, getsockopt, (struct socket *sock, int level, int optname, \
 			 char *optval, int *optlen), (sock, level, optname, optval, optlen)) \
-SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, int len), \
+SOCKCALL_WRAP(name, sendmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len), \
 	      (iocb, sock, m, len)) \
-SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, int len, int flags), \
+SOCKCALL_WRAP(name, recvmsg, (struct kiocb *iocb, struct socket *sock, struct msghdr *m, size_t len, int flags), \
 	      (iocb, sock, m, len, flags)) \
 SOCKCALL_WRAP(name, mmap, (struct file *file, struct socket *sock, struct vm_area_struct *vma), \
 	      (file, sock, vma)) \
diff -purN linux-2.6.1/include/linux/pci_ids.h linux-2.5/include/linux/pci_ids.h
--- linux-2.6.1/include/linux/pci_ids.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/linux/pci_ids.h	2004-01-09 19:07:37.000000000 +0000
@@ -325,7 +325,7 @@
 /* RadeonIGP */
 #define PCI_DEVICE_ID_ATI_RS100		0xcab0
 #define PCI_DEVICE_ID_ATI_RS200		0xcab2
-#define PCI_DEVICE_ID_ATI_RS200_B	0xcbb3
+#define PCI_DEVICE_ID_ATI_RS200_B	0xcbb2
 #define PCI_DEVICE_ID_ATI_RS250		0xcab3
 #define PCI_DEVICE_ID_ATI_RS300_100	0x5830
 #define PCI_DEVICE_ID_ATI_RS300_133	0x5831
diff -purN linux-2.6.1/include/net/bluetooth/bluetooth.h linux-2.5/include/net/bluetooth/bluetooth.h
--- linux-2.6.1/include/net/bluetooth/bluetooth.h	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/include/net/bluetooth/bluetooth.h	2004-01-09 09:51:18.000000000 +0000
@@ -129,7 +129,7 @@ int  bt_sock_unregister(int proto);
 struct sock *bt_sock_alloc(struct socket *sock, int proto, int pi_size, int prio);
 void bt_sock_link(struct bt_sock_list *l, struct sock *s);
 void bt_sock_unlink(struct bt_sock_list *l, struct sock *s);
-int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len, int flags);
+int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags);
 uint bt_sock_poll(struct file * file, struct socket *sock, poll_table *wait);
 int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
 
diff -purN linux-2.6.1/include/net/inet_common.h linux-2.5/include/net/inet_common.h
--- linux-2.6.1/include/net/inet_common.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/include/net/inet_common.h	2004-01-09 09:50:23.000000000 +0000
@@ -23,11 +23,11 @@ extern int			inet_accept(struct socket *
 extern int			inet_recvmsg(struct kiocb *iocb,
 					     struct socket *sock, 
 					     struct msghdr *ubuf, 
-					     int size, int flags);
+					     size_t size, int flags);
 extern int			inet_sendmsg(struct kiocb *iocb,
 					     struct socket *sock, 
 					     struct msghdr *msg, 
-					     int size);
+					     size_t size);
 extern int			inet_shutdown(struct socket *sock, int how);
 extern unsigned int		inet_poll(struct file * file, struct socket *sock, struct poll_table_struct *wait);
 extern int			inet_setsockopt(struct socket *sock, int level,
diff -purN linux-2.6.1/include/net/irda/timer.h linux-2.5/include/net/irda/timer.h
--- linux-2.6.1/include/net/irda/timer.h	2004-01-09 06:59:04.000000000 +0000
+++ linux-2.5/include/net/irda/timer.h	2004-01-09 10:08:28.000000000 +0000
@@ -40,14 +40,14 @@ struct lsap_cb;
 struct lap_cb;
 
 /* 
- *  Timeout definitions, some defined in IrLAP p. 92
+ *  Timeout definitions, some defined in IrLAP 6.13.5 - p. 92
  */
 #define POLL_TIMEOUT        (450*HZ/1000)    /* Must never exceed 500 ms */
 #define FINAL_TIMEOUT       (500*HZ/1000)    /* Must never exceed 500 ms */
 
 /* 
- *  Normally twice of p-timer. Note 3, IrLAP p. 60 suggests at least twice 
- *  duration of the P-timer.
+ *  Normally twice of p-timer. Note 3, IrLAP 6.3.11.2 - p. 60 suggests
+ *  at least twice duration of the P-timer.
  */
 #define WD_TIMEOUT          (POLL_TIMEOUT*2)
 
diff -purN linux-2.6.1/include/net/sock.h linux-2.5/include/net/sock.h
--- linux-2.6.1/include/net/sock.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/include/net/sock.h	2004-01-09 09:46:38.000000000 +0000
@@ -418,10 +418,10 @@ struct proto {
 					int optname, char *optval, 
 					int *option);  	 
 	int			(*sendmsg)(struct kiocb *iocb, struct sock *sk,
-					   struct msghdr *msg, int len);
+					   struct msghdr *msg, size_t len);
 	int			(*recvmsg)(struct kiocb *iocb, struct sock *sk,
 					   struct msghdr *msg,
-					int len, int noblock, int flags, 
+					size_t len, int noblock, int flags, 
 					int *addr_len);
 	int			(*sendpage)(struct sock *sk, struct page *page,
 					int offset, size_t size, int flags);
@@ -609,9 +609,9 @@ extern int			sock_no_getsockopt(struct s
 extern int			sock_no_setsockopt(struct socket *, int, int,
 						   char *, int);
 extern int                      sock_no_sendmsg(struct kiocb *, struct socket *,
-						struct msghdr *, int);
+						struct msghdr *, size_t);
 extern int                      sock_no_recvmsg(struct kiocb *, struct socket *,
-						struct msghdr *, int, int);
+						struct msghdr *, size_t, int);
 extern int			sock_no_mmap(struct file *file,
 					     struct socket *sock,
 					     struct vm_area_struct *vma);
diff -purN linux-2.6.1/include/net/tcp.h linux-2.5/include/net/tcp.h
--- linux-2.6.1/include/net/tcp.h	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/include/net/tcp.h	2004-01-09 09:50:23.000000000 +0000
@@ -752,7 +752,7 @@ extern int			tcp_v4_remember_stamp(struc
 extern int		    	tcp_v4_tw_remember_stamp(struct tcp_tw_bucket *tw);
 
 extern int			tcp_sendmsg(struct kiocb *iocb, struct sock *sk,
-					    struct msghdr *msg, int size);
+					    struct msghdr *msg, size_t size);
 extern ssize_t			tcp_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags);
 
 extern int			tcp_ioctl(struct sock *sk, 
@@ -846,7 +846,7 @@ extern int			tcp_setsockopt(struct sock 
 extern void			tcp_set_keepalive(struct sock *sk, int val);
 extern int			tcp_recvmsg(struct kiocb *iocb, struct sock *sk,
 					    struct msghdr *msg,
-					    int len, int nonblock, 
+					    size_t len, int nonblock, 
 					    int flags, int *addr_len);
 
 extern int			tcp_listen_start(struct sock *sk);
diff -purN linux-2.6.1/include/net/udp.h linux-2.5/include/net/udp.h
--- linux-2.6.1/include/net/udp.h	2004-01-09 06:59:55.000000000 +0000
+++ linux-2.5/include/net/udp.h	2004-01-09 09:50:23.000000000 +0000
@@ -68,7 +68,7 @@ extern int	udp_connect(struct sock *sk,
 			    struct sockaddr *usin, int addr_len);
 
 extern int	udp_sendmsg(struct kiocb *iocb, struct sock *sk,
-			    struct msghdr *msg, int len);
+			    struct msghdr *msg, size_t len);
 
 extern int	udp_rcv(struct sk_buff *skb);
 extern int	udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
diff -purN linux-2.6.1/mm/mremap.c linux-2.5/mm/mremap.c
--- linux-2.6.1/mm/mremap.c	2004-01-09 06:59:43.000000000 +0000
+++ linux-2.5/mm/mremap.c	2004-01-13 01:11:25.000000000 +0000
@@ -315,8 +315,12 @@ unsigned long do_mremap(unsigned long ad
 	old_len = PAGE_ALIGN(old_len);
 	new_len = PAGE_ALIGN(new_len);
 
-	/* Don't allow the degenerate cases */
-	if (!old_len || !new_len)
+	/*
+	 * We allow a zero old-len as a special case
+	 * for DOS-emu "duplicate shm area" thing. But
+	 * a zero new-len is nonsensical.
+	 */
+	if (!new_len)
 		goto out;
 
 	/* new_addr is only valid if MREMAP_FIXED is specified */
diff -purN linux-2.6.1/net/appletalk/ddp.c linux-2.5/net/appletalk/ddp.c
--- linux-2.6.1/net/appletalk/ddp.c	2004-01-09 07:00:12.000000000 +0000
+++ linux-2.5/net/appletalk/ddp.c	2004-01-09 09:52:10.000000000 +0000
@@ -1552,7 +1552,7 @@ freeit:
 }
 
 static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-			 int len)
+			 size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct atalk_sock *at = at_sk(sk);
@@ -1712,7 +1712,7 @@ static int atalk_sendmsg(struct kiocb *i
 }
 
 static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-			 int size, int flags)
+			 size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;
diff -purN linux-2.6.1/net/atm/br2684.c linux-2.5/net/atm/br2684.c
--- linux-2.6.1/net/atm/br2684.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/atm/br2684.c	2004-01-09 10:00:03.000000000 +0000
@@ -437,6 +437,10 @@ static void br2684_push(struct atm_vcc *
 			dev_kfree_skb(skb);
 			return;
 		}
+
+		/* Strip FCS if present */
+		if (skb->len > 7 && skb->data[7] == 0x01)
+			__skb_trim(skb, skb->len - 4);
 	} else {
 		plen = PADLEN + ETH_HLEN;	/* pad, dstmac,srcmac, ethtype */
 		/* first 2 chars should be 0 */
diff -purN linux-2.6.1/net/atm/common.c linux-2.5/net/atm/common.c
--- linux-2.6.1/net/atm/common.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/net/atm/common.c	2004-01-09 09:52:41.000000000 +0000
@@ -463,7 +463,7 @@ int vcc_connect(struct socket *sock, int
 
 
 int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		int size, int flags)
+		size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct atm_vcc *vcc;
@@ -503,7 +503,7 @@ int vcc_recvmsg(struct kiocb *iocb, stru
 
 
 int vcc_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		int total_len)
+		size_t total_len)
 {
 	struct sock *sk = sock->sk;
 	DEFINE_WAIT(wait);
diff -purN linux-2.6.1/net/atm/common.h linux-2.5/net/atm/common.h
--- linux-2.6.1/net/atm/common.h	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/net/atm/common.h	2004-01-09 09:52:41.000000000 +0000
@@ -14,9 +14,9 @@ int vcc_create(struct socket *sock, int 
 int vcc_release(struct socket *sock);
 int vcc_connect(struct socket *sock, int itf, short vpi, int vci);
 int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		int size, int flags);
+		size_t size, int flags);
 int vcc_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		int total_len);
+		size_t total_len);
 unsigned int vcc_poll(struct file *file, struct socket *sock, poll_table *wait);
 int vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 int vcc_setsockopt(struct socket *sock, int level, int optname, char *optval,
diff -purN linux-2.6.1/net/ax25/af_ax25.c linux-2.5/net/ax25/af_ax25.c
--- linux-2.6.1/net/ax25/af_ax25.c	2004-01-09 07:00:02.000000000 +0000
+++ linux-2.5/net/ax25/af_ax25.c	2004-01-09 09:53:04.000000000 +0000
@@ -1401,7 +1401,7 @@ out:
 }
 
 static int ax25_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sockaddr_ax25 *usax = (struct sockaddr_ax25 *)msg->msg_name;
 	struct sock *sk = sock->sk;
@@ -1410,7 +1410,8 @@ static int ax25_sendmsg(struct kiocb *io
 	ax25_digi dtmp, *dp;
 	unsigned char *asmptr;
 	ax25_cb *ax25;
-	int lv, size, err, addr_len = msg->msg_namelen;
+	size_t size;
+	int lv, err, addr_len = msg->msg_namelen;
 
 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR)) {
 		return -EINVAL;
@@ -1435,6 +1436,11 @@ static int ax25_sendmsg(struct kiocb *io
 		goto out;
 	}
 
+	if (len > ax25->ax25_dev->dev->mtu) {
+		err = -EMSGSIZE;
+		goto out;
+	}
+		
 	if (usax != NULL) {
 		if (usax->sax25_family != AF_AX25) {
 			err = -EINVAL;
@@ -1580,7 +1586,7 @@ out:
 }
 
 static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int size, int flags)
+	struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
diff -purN linux-2.6.1/net/bluetooth/af_bluetooth.c linux-2.5/net/bluetooth/af_bluetooth.c
--- linux-2.6.1/net/bluetooth/af_bluetooth.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/bluetooth/af_bluetooth.c	2004-01-09 09:51:18.000000000 +0000
@@ -201,12 +201,13 @@ struct sock *bt_accept_dequeue(struct so
 }
 
 int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int len, int flags)
+	struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	BT_DBG("sock %p sk %p len %d", sock, sk, len);
 
diff -purN linux-2.6.1/net/bluetooth/hci_sock.c linux-2.5/net/bluetooth/hci_sock.c
--- linux-2.6.1/net/bluetooth/hci_sock.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/bluetooth/hci_sock.c	2004-01-09 09:51:18.000000000 +0000
@@ -319,7 +319,8 @@ static inline void hci_sock_cmsg(struct 
         	put_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, sizeof(skb->stamp), &skb->stamp);
 }
  
-static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len, int flags)
+static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
@@ -355,7 +356,8 @@ static int hci_sock_recvmsg(struct kiocb
 	return err ? : copied;
 }
 
-static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct hci_dev *hdev;
@@ -370,9 +372,9 @@ static int hci_sock_sendmsg(struct kiocb
 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))
 		return -EINVAL;
 
-	if (len < 4)
+	if (len < 4 || len > HCI_MAX_FRAME_SIZE)
 		return -EINVAL;
-	
+
 	lock_sock(sk);
 
 	if (!(hdev = hci_pi(sk)->hdev)) {
diff -purN linux-2.6.1/net/bluetooth/l2cap.c linux-2.5/net/bluetooth/l2cap.c
--- linux-2.6.1/net/bluetooth/l2cap.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/net/bluetooth/l2cap.c	2004-01-09 09:51:18.000000000 +0000
@@ -706,7 +706,8 @@ fail:
 	return err;
 }
 
-static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
diff -purN linux-2.6.1/net/bluetooth/rfcomm/sock.c linux-2.5/net/bluetooth/rfcomm/sock.c
--- linux-2.6.1/net/bluetooth/rfcomm/sock.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/bluetooth/rfcomm/sock.c	2004-01-09 09:51:18.000000000 +0000
@@ -482,12 +482,12 @@ static int rfcomm_sock_getname(struct so
 }
 
 static int rfcomm_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;
 	struct sk_buff *skb;
-	int err, size;
+	int err;
 	int sent = 0;
 
 	if (msg->msg_flags & MSG_OOB)
@@ -501,7 +501,7 @@ static int rfcomm_sock_sendmsg(struct ki
 	lock_sock(sk);
 
 	while (len) {
-		size = min_t(uint, len, d->mtu);
+		size_t size = min(len, d->mtu);
 		
 		skb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,
 				msg->msg_flags & MSG_DONTWAIT, &err);
@@ -556,10 +556,11 @@ static long rfcomm_sock_data_wait(struct
 }
 
 static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size, int flags)
+			       struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
-	int target, err = 0, copied = 0;
+	int err = 0;
+	size_t target, copied = 0;
 	long timeo;
 
 	if (flags & MSG_OOB)
diff -purN linux-2.6.1/net/bluetooth/sco.c linux-2.5/net/bluetooth/sco.c
--- linux-2.6.1/net/bluetooth/sco.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/bluetooth/sco.c	2004-01-09 09:51:18.000000000 +0000
@@ -630,7 +630,8 @@ static int sco_sock_getname(struct socke
 	return 0;
 }
 
-static int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int len)
+static int sco_sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+			    struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	int err = 0;
diff -purN linux-2.6.1/net/core/sock.c linux-2.5/net/core/sock.c
--- linux-2.6.1/net/core/sock.c	2004-01-09 06:59:48.000000000 +0000
+++ linux-2.5/net/core/sock.c	2004-01-09 09:46:38.000000000 +0000
@@ -966,13 +966,13 @@ int sock_no_getsockopt(struct socket *so
 }
 
 int sock_no_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		    int flags)
+		    size_t len)
 {
 	return -EOPNOTSUPP;
 }
 
 int sock_no_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
-		    int len, int flags)
+		    size_t len, int flags)
 {
 	return -EOPNOTSUPP;
 }
diff -purN linux-2.6.1/net/decnet/af_decnet.c linux-2.5/net/decnet/af_decnet.c
--- linux-2.6.1/net/decnet/af_decnet.c	2004-01-09 06:59:42.000000000 +0000
+++ linux-2.5/net/decnet/af_decnet.c	2004-01-09 09:53:59.000000000 +0000
@@ -1659,13 +1659,13 @@ static int dn_data_ready(struct sock *sk
 
 
 static int dn_recvmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int size, int flags)
+	struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct dn_scp *scp = DN_SK(sk);
 	struct sk_buff_head *queue = &sk->sk_receive_queue;
-	int target = size > 1 ? 1 : 0;
-	int copied = 0;
+	size_t target = size > 1 ? 1 : 0;
+	size_t copied = 0;
 	int rv = 0;
 	struct sk_buff *skb, *nskb;
 	struct dn_skb_cb *cb = NULL;
@@ -1746,7 +1746,7 @@ static int dn_recvmsg(struct kiocb *iocb
 	}
 
 	for(skb = queue->next; skb != (struct sk_buff *)queue; skb = nskb) {
-		int chunk = skb->len;
+		unsigned int chunk = skb->len;
 		cb = DN_SKB_CB(skb);
 
 		if ((chunk + copied) > size)
@@ -1888,20 +1888,20 @@ static int dn_error(struct sock *sk, int
 }
 
 static int dn_sendmsg(struct kiocb *iocb, struct socket *sock,
-	   struct msghdr *msg, int size)
+	   struct msghdr *msg, size_t size)
 {
 	struct sock *sk = sock->sk;
 	struct dn_scp *scp = DN_SK(sk);
-	int mss;
+	size_t mss;
 	struct sk_buff_head *queue = &scp->data_xmit_queue;
 	int flags = msg->msg_flags;
 	int err = 0;
-	int sent = 0;
+	size_t sent = 0;
 	int addr_len = msg->msg_namelen;
 	struct sockaddr_dn *addr = (struct sockaddr_dn *)msg->msg_name;
 	struct sk_buff *skb = NULL;
 	struct dn_skb_cb *cb;
-	int len;
+	size_t len;
 	unsigned char fctype;
 	long timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
 
diff -purN linux-2.6.1/net/econet/af_econet.c linux-2.5/net/econet/af_econet.c
--- linux-2.6.1/net/econet/af_econet.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/econet/af_econet.c	2004-01-09 09:54:49.000000000 +0000
@@ -113,11 +113,12 @@ static void econet_insert_socket(struct 
  */
 
 static int econet_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len, int flags)
+			  struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	msg->msg_namelen = sizeof(struct sockaddr_ec);
 
@@ -246,7 +247,7 @@ static void ec_tx_done(struct sk_buff *s
  */
 
 static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ec *saddr=(struct sockaddr_ec *)msg->msg_name;
@@ -308,6 +309,9 @@ static int econet_sendmsg(struct kiocb *
 			return -ENETDOWN;
 	}
 
+	if (len + 15 > dev->mtu)
+		return -EMSGSIZE;
+
 	if (dev->type == ARPHRD_ECONET)
 	{
 		/* Real hardware Econet.  We're not worthy etc. */
diff -purN linux-2.6.1/net/ipv4/af_inet.c linux-2.5/net/ipv4/af_inet.c
--- linux-2.6.1/net/ipv4/af_inet.c	2004-01-09 06:59:09.000000000 +0000
+++ linux-2.5/net/ipv4/af_inet.c	2004-01-09 09:50:23.000000000 +0000
@@ -731,7 +731,7 @@ int inet_getname(struct socket *sock, st
 
 
 int inet_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		 int size, int flags)
+		 size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	int addr_len = 0;
@@ -746,7 +746,7 @@ int inet_recvmsg(struct kiocb *iocb, str
 
 
 int inet_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
-		 int size)
+		 size_t size)
 {
 	struct sock *sk = sock->sk;
 
diff -purN linux-2.6.1/net/ipv4/netfilter/ip_tables.c linux-2.5/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.1/net/ipv4/netfilter/ip_tables.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/ipv4/netfilter/ip_tables.c	2004-01-09 10:05:16.000000000 +0000
@@ -260,7 +260,7 @@ ipt_do_table(struct sk_buff **pskb,
 	     struct ipt_table *table,
 	     void *userdata)
 {
-	static const char nulldevname[IFNAMSIZ];
+	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
 	u_int16_t offset;
 	struct iphdr *ip;
 	u_int16_t datalen;
diff -purN linux-2.6.1/net/ipv4/raw.c linux-2.5/net/ipv4/raw.c
--- linux-2.6.1/net/ipv4/raw.c	2004-01-09 06:59:44.000000000 +0000
+++ linux-2.5/net/ipv4/raw.c	2004-01-09 09:50:23.000000000 +0000
@@ -324,7 +324,7 @@ error:
 }
 
 static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		       int len)
+		       size_t len)
 {
 	struct inet_opt *inet = inet_sk(sk);
 	struct ipcm_cookie ipc;
@@ -335,17 +335,6 @@ static int raw_sendmsg(struct kiocb *ioc
 	u8  tos;
 	int err;
 
-	/* This check is ONLY to check for arithmetic overflow
-	   on integer(!) len. Not more! Real check will be made
-	   in ip_build_xmit --ANK
-
-	   BTW socket.c -> af_*.c -> ... make multiple
-	   invalid conversions size_t -> int. We MUST repair it f.e.
-	   by replacing all of them with size_t and revise all
-	   the places sort of len += sizeof(struct iphdr)
-	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
-	 */
-
 	err = -EMSGSIZE;
 	if (len < 0 || len > 0xFFFF)
 		goto out;
@@ -523,10 +512,10 @@ out:	return ret;
  */
 
 int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int noblock, int flags, int *addr_len)
+		size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_opt *inet = inet_sk(sk);
-	int copied = 0;
+	size_t copied = 0;
 	int err = -EOPNOTSUPP;
 	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 	struct sk_buff *skb;
diff -purN linux-2.6.1/net/ipv4/tcp.c linux-2.5/net/ipv4/tcp.c
--- linux-2.6.1/net/ipv4/tcp.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/ipv4/tcp.c	2004-01-09 09:50:23.000000000 +0000
@@ -1029,7 +1029,7 @@ static inline int select_size(struct soc
 }
 
 int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int size)
+		size_t size)
 {
 	struct iovec *iov;
 	struct tcp_opt *tp = tcp_sk(sk);
@@ -1498,7 +1498,7 @@ int tcp_read_sock(struct sock *sk, read_
  */
 
 int tcp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int nonblock, int flags, int *addr_len)
+		size_t len, int nonblock, int flags, int *addr_len)
 {
 	struct tcp_opt *tp = tcp_sk(sk);
 	int copied = 0;
diff -purN linux-2.6.1/net/ipv4/udp.c linux-2.5/net/ipv4/udp.c
--- linux-2.6.1/net/ipv4/udp.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/ipv4/udp.c	2004-01-09 09:50:23.000000000 +0000
@@ -478,7 +478,7 @@ static unsigned short udp_check(struct u
 }
 
 int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len)
+		size_t len)
 {
 	struct inet_opt *inet = inet_sk(sk);
 	struct udp_opt *up = udp_sk(sk);
@@ -493,18 +493,7 @@ int udp_sendmsg(struct kiocb *iocb, stru
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
 
-	/* This check is ONLY to check for arithmetic overflow
-	   on integer(!) len. Not more! Real check will be made
-	   in ip_append_* --ANK
-
-	   BTW socket.c -> af_*.c -> ... make multiple
-	   invalid conversions size_t -> int. We MUST repair it f.e.
-	   by replacing all of them with size_t and revise all
-	   the places sort of len += sizeof(struct iphdr)
-	   If len was ULONG_MAX-10 it would be cathastrophe  --ANK
-	 */
-
-	if (len < 0 || len > 0xFFFF)
+	if (len > 0xFFFF)
 		return -EMSGSIZE;
 
 	/* 
@@ -782,7 +771,7 @@ static __inline__ int udp_checksum_compl
  */
 
 int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		int len, int noblock, int flags, int *addr_len)
+		size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_opt *inet = inet_sk(sk);
   	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
diff -purN linux-2.6.1/net/ipv6/raw.c linux-2.5/net/ipv6/raw.c
--- linux-2.6.1/net/ipv6/raw.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/ipv6/raw.c	2004-01-09 09:50:23.000000000 +0000
@@ -345,13 +345,15 @@ int rawv6_rcv(struct sock *sk, struct sk
  *	we return it, otherwise we block.
  */
 
-static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len,
+static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,
+		  struct msghdr *msg, size_t len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
@@ -527,7 +529,8 @@ error:
 	IP6_INC_STATS(Ip6OutDiscards);
 	return err; 
 }
-static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len)
+static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
+		   struct msghdr *msg, size_t len)
 {
 	struct ipv6_txoptions opt_space;
 	struct sockaddr_in6 * sin6 = (struct sockaddr_in6 *) msg->msg_name;
diff -purN linux-2.6.1/net/ipv6/udp.c linux-2.5/net/ipv6/udp.c
--- linux-2.6.1/net/ipv6/udp.c	2004-01-09 06:59:56.000000000 +0000
+++ linux-2.5/net/ipv6/udp.c	2004-01-09 09:50:23.000000000 +0000
@@ -366,12 +366,14 @@ static void udpv6_close(struct sock *sk,
  * 	return it, otherwise we block.
  */
 
-static int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len,
+static int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk, 
+		  struct msghdr *msg, size_t len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
   	struct sk_buff *skb;
-  	int copied, err;
+	size_t copied;
+  	int err;
 
   	if (addr_len)
   		*addr_len=sizeof(struct sockaddr_in6);
@@ -774,7 +776,8 @@ out:
 	return err;
 }
 
-static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, int len)
+static int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk, 
+		  struct msghdr *msg, size_t len)
 {
 	struct ipv6_txoptions opt_space;
 	struct udp_opt *up = udp_sk(sk);
@@ -841,7 +844,7 @@ do_udp_sendmsg:
 	/* Rough check on arithmetic overflow,
 	   better check is made in ip6_build_xmit
 	   */
-	if (len < 0 || len > INT_MAX - sizeof(struct udphdr))
+	if (len > INT_MAX - sizeof(struct udphdr))
 		return -EMSGSIZE;
 	
 	if (up->pending) {
diff -purN linux-2.6.1/net/ipx/af_ipx.c linux-2.5/net/ipx/af_ipx.c
--- linux-2.6.1/net/ipx/af_ipx.c	2004-01-09 06:59:10.000000000 +0000
+++ linux-2.5/net/ipx/af_ipx.c	2004-01-09 09:53:38.000000000 +0000
@@ -1683,7 +1683,7 @@ out:
 }
 
 static int ipx_sendmsg(struct kiocb *iocb, struct socket *sock,
-	struct msghdr *msg, int len)
+	struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct ipx_opt *ipxs = ipx_sk(sk);
@@ -1698,6 +1698,10 @@ static int ipx_sendmsg(struct kiocb *ioc
 	if (flags & ~MSG_DONTWAIT)
 		goto out;
 
+	/* Max possible packet size limited by 16 bit pktsize in header */
+	if (len >= 65535 - sizeof(struct ipxhdr))
+		goto out;
+
 	if (usipx) {
 		if (!ipxs->port) {
 			struct sockaddr_ipx uaddr;
@@ -1744,7 +1748,7 @@ out:
 
 
 static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,
-		struct msghdr *msg, int size, int flags)
+		struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct ipx_opt *ipxs = ipx_sk(sk);
diff -purN linux-2.6.1/net/ipx/ipx_route.c linux-2.5/net/ipx/ipx_route.c
--- linux-2.6.1/net/ipx/ipx_route.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/ipx/ipx_route.c	2004-01-09 09:53:38.000000000 +0000
@@ -169,13 +169,13 @@ int ipxrtr_route_skb(struct sk_buff *skb
  * Route an outgoing frame from a socket.
  */
 int ipxrtr_route_packet(struct sock *sk, struct sockaddr_ipx *usipx,
-			struct iovec *iov, int len, int noblock)
+			struct iovec *iov, size_t len, int noblock)
 {
 	struct sk_buff *skb;
 	struct ipx_opt *ipxs = ipx_sk(sk);
 	struct ipx_interface *intrfc;
 	struct ipxhdr *ipx;
-	int size;
+	size_t size;
 	int ipx_offset;
 	struct ipx_route *rt = NULL;
 	int rc;
diff -purN linux-2.6.1/net/irda/af_irda.c linux-2.5/net/irda/af_irda.c
--- linux-2.6.1/net/irda/af_irda.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/af_irda.c	2004-01-09 10:10:53.000000000 +0000
@@ -1257,7 +1257,7 @@ static int irda_release(struct socket *s
  *    fragment the message if necessary
  */
 static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1329,12 +1329,13 @@ static int irda_sendmsg(struct kiocb *io
  *    after being read, regardless of how much the user actually read
  */
 static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int size, int flags)
+			      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self = irda_sk(sk);
 	struct sk_buff *skb;
-	int copied, err;
+	size_t copied;
+	int err;
 
 	IRDA_DEBUG(4, "%s()\n", __FUNCTION__);
 
@@ -1379,12 +1380,12 @@ static int irda_recvmsg_dgram(struct kio
  * Function irda_recvmsg_stream (iocb, sock, msg, size, flags)
  */
 static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size, int flags)
+			       struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self = irda_sk(sk);
 	int noblock = flags & MSG_DONTWAIT;
-	int copied = 0;
+	size_t copied = 0;
 	int target = 1;
 	DECLARE_WAITQUEUE(waitq, current);
 
@@ -1505,7 +1506,7 @@ static int irda_recvmsg_stream(struct ki
  *
  */
 static int irda_sendmsg_dgram(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1571,7 +1572,7 @@ static int irda_sendmsg_dgram(struct kio
  */
 #ifdef CONFIG_IRDA_ULTRA
 static int irda_sendmsg_ultra(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct irda_sock *self;
@@ -1890,11 +1891,10 @@ static int irda_setsockopt(struct socket
 		case IAS_STRING:
 			/* Should check charset & co */
 			/* Check length */
-			if(ias_opt->attribute.irda_attrib_string.len >
-			   IAS_MAX_STRING) {
-				kfree(ias_opt);
-				return -EINVAL;
-			}
+			/* The length is encoded in a __u8, and
+			 * IAS_MAX_STRING == 256, so there is no way
+			 * userspace can pass us a string too large.
+			 * Jean II */
 			/* NULL terminate the string (avoid troubles) */
 			ias_opt->attribute.irda_attrib_string.string[ias_opt->attribute.irda_attrib_string.len] = '\0';
 			/* Add a string attribute */
diff -purN linux-2.6.1/net/irda/ircomm/ircomm_tty.c linux-2.5/net/irda/ircomm/ircomm_tty.c
--- linux-2.6.1/net/irda/ircomm/ircomm_tty.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/ircomm/ircomm_tty.c	2004-01-09 10:10:13.000000000 +0000
@@ -38,6 +38,7 @@
 #include <linux/termios.h>
 #include <linux/tty.h>
 #include <linux/interrupt.h>
+#include <linux/device.h>		/* for MODULE_ALIAS_CHARDEV_MAJOR */
 
 #include <asm/uaccess.h>
 
@@ -1411,6 +1412,7 @@ done:
 MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no>");
 MODULE_DESCRIPTION("IrCOMM serial TTY driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(IRCOMM_TTY_MAJOR);
 
 module_init(ircomm_tty_init);
 module_exit(ircomm_tty_cleanup);
diff -purN linux-2.6.1/net/irda/irlap_event.c linux-2.5/net/irda/irlap_event.c
--- linux-2.6.1/net/irda/irlap_event.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/irda/irlap_event.c	2004-01-09 10:08:28.000000000 +0000
@@ -932,6 +932,12 @@ static int irlap_state_setup(struct irla
 		/* This frame will actually be sent at the new speed */
 		irlap_send_rr_frame(self, CMD_FRAME);
 
+		/* The timer is set to half the normal timer to quickly
+		 * detect a failure to negociate the new connection
+		 * parameters. IrLAP 6.11.3.2, note 3.
+		 * Note that currently we don't process this failure
+		 * properly, as we should do a quick disconnect.
+		 * Jean II */
 		irlap_start_final_timer(self, self->final_timeout/2);
 		irlap_next_state(self, LAP_NRM_P);
 
@@ -1312,7 +1318,12 @@ static int irlap_state_nrm_p(struct irla
 				irlap_resend_rejected_frames(self, CMD_FRAME);
 
 				self->ack_required = FALSE;
-				irlap_start_final_timer(self, self->final_timeout);
+
+				/* Make sure we account for the time
+				 * to transmit our frames. See comemnts
+				 * in irlap_send_data_primary_poll().
+				 * Jean II */
+				irlap_start_final_timer(self, 2 * self->final_timeout);
 
 				/* Keep state, do not move this line */
 				irlap_next_state(self, LAP_NRM_P);
@@ -1352,8 +1363,9 @@ static int irlap_state_nrm_p(struct irla
 				/* Resend rejected frames */
 				irlap_resend_rejected_frames(self, CMD_FRAME);
 
-				/* Give peer some time to retransmit! */
-				irlap_start_final_timer(self, self->final_timeout);
+				/* Give peer some time to retransmit! 
+				 * But account for our own Tx. */
+				irlap_start_final_timer(self, 2 * self->final_timeout);
 
 				/* Keep state, do not move this line */
 				irlap_next_state(self, LAP_NRM_P);
@@ -1450,6 +1462,8 @@ static int irlap_state_nrm_p(struct irla
 			/* Resend rejected frames */
 			irlap_resend_rejected_frames(self, CMD_FRAME);
 
+			/* Final timer ??? Jean II */
+
 			irlap_next_state(self, LAP_NRM_P);
 		} else if (ret == NR_INVALID) {
 			IRDA_DEBUG(1, "%s(), Received RR with "
@@ -1541,7 +1555,7 @@ static int irlap_state_nrm_p(struct irla
 			irlap_send_rr_frame(self, CMD_FRAME);
 		} else
 			irlap_resend_rejected_frames(self, CMD_FRAME);
-		irlap_start_final_timer(self, self->final_timeout);
+		irlap_start_final_timer(self, 2 * self->final_timeout);
 		break;
 	case RECV_SREJ_RSP:
 		irlap_update_nr_received(self, info->nr);
@@ -1550,7 +1564,7 @@ static int irlap_state_nrm_p(struct irla
 			irlap_send_rr_frame(self, CMD_FRAME);
 		} else
 			irlap_resend_rejected_frame(self, CMD_FRAME);
-		irlap_start_final_timer(self, self->final_timeout);
+		irlap_start_final_timer(self, 2 * self->final_timeout);
 		break;
 	case RECV_RD_RSP:
 		IRDA_DEBUG(1, "%s(), RECV_RD_RSP\n", __FUNCTION__);
diff -purN linux-2.6.1/net/irda/irlap_frame.c linux-2.5/net/irda/irlap_frame.c
--- linux-2.6.1/net/irda/irlap_frame.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/irda/irlap_frame.c	2004-01-09 10:08:28.000000000 +0000
@@ -779,6 +779,7 @@ void irlap_send_data_primary(struct irla
 void irlap_send_data_primary_poll(struct irlap_cb *self, struct sk_buff *skb)
 {
 	struct sk_buff *tx_skb;
+	int transmission_time;
 
 	/* Stop P timer */
 	del_timer(&self->poll_timer);
@@ -829,13 +830,49 @@ void irlap_send_data_primary_poll(struct
 		}
 	}
 
+	/* How much time we took for transmission of all frames.
+	 * We don't know, so let assume we used the full window. Jean II */
+	transmission_time = self->final_timeout;
+
+	/* Reset parameter so that we can fill next window */
 	self->window = self->window_size;
+
 #ifdef CONFIG_IRDA_DYNAMIC_WINDOW
+	/* Remove what we have not used. Just do a prorata of the
+	 * bytes left in window to window capacity.
+	 * See max_line_capacities[][] in qos.c for details. Jean II */
+	transmission_time -= (self->final_timeout * self->bytes_left
+			      / self->line_capacity);
+	IRDA_DEBUG(4, "%s() adjusting transmission_time : ft=%d, bl=%d, lc=%d -> tt=%d\n", __FUNCTION__, self->final_timeout, self->bytes_left, self->line_capacity, transmission_time);
+
 	/* We are allowed to transmit a maximum number of bytes again. */
 	self->bytes_left = self->line_capacity;
 #endif /* CONFIG_IRDA_DYNAMIC_WINDOW */
 
-	irlap_start_final_timer(self, self->final_timeout);
+	/*
+	 * The network layer has a intermediate buffer between IrLAP
+	 * and the IrDA driver which can contain 8 frames. So, even
+	 * though IrLAP is currently sending the *last* frame of the
+	 * tx-window, the driver most likely has only just started
+	 * sending the *first* frame of the same tx-window.
+	 * I.e. we are always at the very begining of or Tx window.
+	 * Now, we are supposed to set the final timer from the end
+	 * of our tx-window to let the other peer reply. So, we need
+	 * to add extra time to compensate for the fact that we
+	 * are really at the start of tx-window, otherwise the final timer
+	 * might expire before he can answer...
+	 * Jean II
+	 */
+	irlap_start_final_timer(self, self->final_timeout + transmission_time);
+
+	/*
+	 * The clever amongst you might ask why we do this adjustement
+	 * only here, and not in all the other cases in irlap_event.c.
+	 * In all those other case, we only send a very short management
+	 * frame (few bytes), so the adjustement would be lost in the
+	 * noise...
+	 * The exception of course is irlap_resend_rejected_frame().
+	 * Jean II */
 }
 
 /*
@@ -1003,7 +1040,7 @@ void irlap_resend_rejected_frames(struct
 	}
 #if 0 /* Not yet */
 	/*
-	 *  We can now fill the window with additinal data frames
+	 *  We can now fill the window with additional data frames
 	 */
 	while (skb_queue_len( &self->txq) > 0) {
 
diff -purN linux-2.6.1/net/key/af_key.c linux-2.5/net/key/af_key.c
--- linux-2.6.1/net/key/af_key.c	2004-01-09 06:59:19.000000000 +0000
+++ linux-2.5/net/key/af_key.c	2004-01-09 09:54:26.000000000 +0000
@@ -2655,7 +2655,7 @@ static int pfkey_send_new_mapping(struct
 }
 
 static int pfkey_sendmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, int len)
+			 struct socket *sock, struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb = NULL;
@@ -2697,7 +2697,7 @@ out:
 }
 
 static int pfkey_recvmsg(struct kiocb *kiocb,
-			 struct socket *sock, struct msghdr *msg, int len,
+			 struct socket *sock, struct msghdr *msg, size_t len,
 			 int flags)
 {
 	struct sock *sk = sock->sk;
diff -purN linux-2.6.1/net/llc/af_llc.c linux-2.5/net/llc/af_llc.c
--- linux-2.6.1/net/llc/af_llc.c	2004-01-09 06:59:03.000000000 +0000
+++ linux-2.5/net/llc/af_llc.c	2004-01-09 09:55:43.000000000 +0000
@@ -671,12 +671,13 @@ out:
  *	Returns non-negative upon success, negative otherwise.
  */
 static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int size, int flags)
+			  struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;
 	struct sk_buff *skb;
-	int rc = -ENOMEM, copied = 0, timeout;
+	size_t copied = 0;
+	int rc = -ENOMEM, timeout;
 	int noblock = flags & MSG_DONTWAIT;
 
 	dprintk("%s: receiving in %02X from %02X\n", __FUNCTION__,
@@ -725,7 +726,7 @@ out:
  *	Returns non-negative upon success, negative otherwise.
  */
 static int llc_ui_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct llc_opt *llc = llc_sk(sk);
@@ -734,7 +735,8 @@ static int llc_ui_sendmsg(struct kiocb *
 	int noblock = flags & MSG_DONTWAIT;
 	struct net_device *dev;
 	struct sk_buff *skb;
-	int rc = -EINVAL, size = 0, copied = 0, hdrlen;
+	size_t size = 0;
+	int rc = -EINVAL, copied = 0, hdrlen;
 
 	dprintk("%s: sending from %02X to %02X\n", __FUNCTION__,
 		llc->laddr.lsap, llc->daddr.lsap);
diff -purN linux-2.6.1/net/netlink/af_netlink.c linux-2.5/net/netlink/af_netlink.c
--- linux-2.6.1/net/netlink/af_netlink.c	2004-01-09 06:59:34.000000000 +0000
+++ linux-2.5/net/netlink/af_netlink.c	2004-01-09 09:54:26.000000000 +0000
@@ -601,7 +601,7 @@ static inline void netlink_rcv_wake(stru
 }
 
 static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			   struct msghdr *msg, int len)
+			   struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -641,7 +641,7 @@ static int netlink_sendmsg(struct kiocb 
 	}
 
 	err = -EMSGSIZE;
-	if ((unsigned)len > sk->sk_sndbuf - 32)
+	if (len > sk->sk_sndbuf - 32)
 		goto out;
 	err = -ENOBUFS;
 	skb = alloc_skb(len, GFP_KERNEL);
@@ -683,7 +683,7 @@ out:
 }
 
 static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
-			   struct msghdr *msg, int len,
+			   struct msghdr *msg, size_t len,
 			   int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
@@ -691,7 +691,7 @@ static int netlink_recvmsg(struct kiocb 
 	struct sock *sk = sock->sk;
 	struct netlink_opt *nlk = nlk_sk(sk);
 	int noblock = flags&MSG_DONTWAIT;
-	int copied;
+	size_t copied;
 	struct sk_buff *skb;
 	int err;
 
diff -purN linux-2.6.1/net/netrom/af_netrom.c linux-2.5/net/netrom/af_netrom.c
--- linux-2.6.1/net/netrom/af_netrom.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/netrom/af_netrom.c	2004-01-09 09:56:08.000000000 +0000
@@ -1010,7 +1010,7 @@ int nr_rx_frame(struct sk_buff *skb, str
 }
 
 static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,
-		      struct msghdr *msg, int len)
+		      struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	nr_cb *nr = nr_sk(sk);
@@ -1119,11 +1119,11 @@ out:
 }
 
 static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
-		      struct msghdr *msg, int size, int flags)
+		      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;
-	int copied;
+	size_t copied;
 	struct sk_buff *skb;
 	int er;
 
diff -purN linux-2.6.1/net/packet/af_packet.c linux-2.5/net/packet/af_packet.c
--- linux-2.6.1/net/packet/af_packet.c	2004-01-09 06:59:46.000000000 +0000
+++ linux-2.5/net/packet/af_packet.c	2004-01-09 09:54:26.000000000 +0000
@@ -284,7 +284,7 @@ oom:
  */
  
 static int packet_sendmsg_spkt(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_pkt *saddr=(struct sockaddr_pkt *)msg->msg_name;
@@ -659,7 +659,7 @@ ring_is_full:
 
 
 static int packet_sendmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len)
+			  struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ll *saddr=(struct sockaddr_ll *)msg->msg_name;
@@ -1007,7 +1007,7 @@ out:
  */
 
 static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
-			  struct msghdr *msg, int len, int flags)
+			  struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
diff -purN linux-2.6.1/net/rose/af_rose.c linux-2.5/net/rose/af_rose.c
--- linux-2.6.1/net/rose/af_rose.c	2004-01-09 06:59:33.000000000 +0000
+++ linux-2.5/net/rose/af_rose.c	2004-01-09 09:56:39.000000000 +0000
@@ -1010,7 +1010,7 @@ int rose_rx_call_request(struct sk_buff 
 }
 
 static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int len)
+			struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	rose_cb *rose = rose_sk(sk);
@@ -1174,15 +1174,15 @@ static int rose_sendmsg(struct kiocb *io
 
 
 static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,
-			struct msghdr *msg, int size, int flags)
+			struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	rose_cb *rose = rose_sk(sk);
 	struct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;
-	int copied, qbit;
+	size_t copied;
 	unsigned char *asmptr;
 	struct sk_buff *skb;
-	int n, er;
+	int n, er, qbit;
 
 	/*
 	 * This works for seqpacket too. The receiver has ordered the queue for
diff -purN linux-2.6.1/net/sctp/socket.c linux-2.5/net/sctp/socket.c
--- linux-2.6.1/net/sctp/socket.c	2004-01-09 07:00:14.000000000 +0000
+++ linux-2.5/net/sctp/socket.c	2004-01-09 09:50:23.000000000 +0000
@@ -90,7 +90,7 @@ static inline int sctp_wspace(struct sct
 static inline void sctp_set_owner_w(struct sctp_chunk *chunk);
 static void sctp_wfree(struct sk_buff *skb);
 static int sctp_wait_for_sndbuf(struct sctp_association *, long *timeo_p,
-				int msg_len);
+				size_t msg_len);
 static int sctp_wait_for_packet(struct sock * sk, int *err, long *timeo_p);
 static int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);
 static int sctp_wait_for_accept(struct sock *sk, long timeo);
@@ -943,7 +943,7 @@ static int sctp_error(struct sock *sk, i
 SCTP_STATIC int sctp_msghdr_parse(const struct msghdr *, sctp_cmsgs_t *);
 
 SCTP_STATIC int sctp_sendmsg(struct kiocb *iocb, struct sock *sk,
-			     struct msghdr *msg, int msg_len)
+			     struct msghdr *msg, size_t msg_len)
 {
 	struct sctp_opt *sp;
 	struct sctp_endpoint *ep;
@@ -965,7 +965,7 @@ SCTP_STATIC int sctp_sendmsg(struct kioc
 	struct list_head *pos;
 	int msg_flags = msg->msg_flags;
 
-	SCTP_DEBUG_PRINTK("sctp_sendmsg(sk: %p, msg: %p, msg_len: %d)\n",
+	SCTP_DEBUG_PRINTK("sctp_sendmsg(sk: %p, msg: %p, msg_len: %u)\n",
 			  sk, msg, msg_len);
 
 	err = 0;
@@ -1021,7 +1021,7 @@ SCTP_STATIC int sctp_sendmsg(struct kioc
 		associd = sinfo->sinfo_assoc_id;
 	}
 
-	SCTP_DEBUG_PRINTK("msg_len: %d, sinfo_flags: 0x%x\n",
+	SCTP_DEBUG_PRINTK("msg_len: %u, sinfo_flags: 0x%x\n",
 			  msg_len, sinfo_flags);
 
 	/* MSG_EOF or MSG_ABORT cannot be set on a TCP-style socket. */
@@ -1377,7 +1377,7 @@ static int sctp_skb_pull(struct sk_buff 
 static struct sk_buff *sctp_skb_recv_datagram(struct sock *, int, int, int *);
 
 SCTP_STATIC int sctp_recvmsg(struct kiocb *iocb, struct sock *sk,
-			     struct msghdr *msg, int len, int noblock,
+			     struct msghdr *msg, size_t len, int noblock,
 			     int flags, int *addr_len)
 {
 	struct sctp_ulpevent *event = NULL;
@@ -4157,14 +4157,14 @@ static void sctp_wfree(struct sk_buff *s
 
 /* Helper function to wait for space in the sndbuf.  */
 static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
-				int msg_len)
+				size_t msg_len)
 {
 	struct sock *sk = asoc->base.sk;
 	int err = 0;
 	long current_timeo = *timeo_p;
 	DEFINE_WAIT(wait);
 
-	SCTP_DEBUG_PRINTK("wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%d\n",
+	SCTP_DEBUG_PRINTK("wait_for_sndbuf: asoc=%p, timeo=%ld, msg_len=%u\n",
 	                  asoc, (long)(*timeo_p), msg_len);
 
 	/* Increment the association's refcnt.  */
diff -purN linux-2.6.1/net/socket.c linux-2.5/net/socket.c
--- linux-2.6.1/net/socket.c	2004-01-09 06:59:26.000000000 +0000
+++ linux-2.5/net/socket.c	2004-01-09 09:46:38.000000000 +0000
@@ -523,7 +523,8 @@ void sock_release(struct socket *sock)
 	sock->file=NULL;
 }
 
-static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int size)
+static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock, 
+				 struct msghdr *msg, size_t size)
 {
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 	int err;
@@ -540,7 +541,7 @@ static inline int __sock_sendmsg(struct 
 	return sock->ops->sendmsg(iocb, sock, msg, size);
 }
 
-int sock_sendmsg(struct socket *sock, struct msghdr *msg, int size)
+int sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 {
 	struct kiocb iocb;
 	int ret;
@@ -553,7 +554,8 @@ int sock_sendmsg(struct socket *sock, st
 }
 
 
-static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, int size, int flags)
+static inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock, 
+				 struct msghdr *msg, size_t size, int flags)
 {
 	int err;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
@@ -571,7 +573,8 @@ static inline int __sock_recvmsg(struct 
 	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
 }
 
-int sock_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags)
+int sock_recvmsg(struct socket *sock, struct msghdr *msg, 
+		 size_t size, int flags)
 {
 	struct kiocb iocb;
 	int ret;
@@ -668,7 +671,7 @@ ssize_t sock_sendpage(struct file *file,
 }
 
 int sock_readv_writev(int type, struct inode * inode, struct file * file,
-		      const struct iovec * iov, long count, long size)
+		      const struct iovec * iov, long count, size_t size)
 {
 	struct msghdr msg;
 	struct socket *sock;
diff -purN linux-2.6.1/net/unix/af_unix.c linux-2.5/net/unix/af_unix.c
--- linux-2.6.1/net/unix/af_unix.c	2004-01-09 06:59:45.000000000 +0000
+++ linux-2.5/net/unix/af_unix.c	2004-01-09 09:57:02.000000000 +0000
@@ -1176,7 +1176,7 @@ static void unix_attach_fds(struct scm_c
  */
 
 static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			      struct msghdr *msg, int len)
+			      struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -1217,7 +1217,7 @@ static int unix_dgram_sendmsg(struct kio
 		goto out;
 
 	err = -EMSGSIZE;
-	if ((unsigned)len > sk->sk_sndbuf - 32)
+	if (len > sk->sk_sndbuf - 32)
 		goto out;
 
 	skb = sock_alloc_send_skb(sk, len, msg->msg_flags&MSG_DONTWAIT, &err);
@@ -1324,7 +1324,7 @@ out:
 
 		
 static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
-			       struct msghdr *msg, int len)
+			       struct msghdr *msg, size_t len)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
 	struct sock *sk = sock->sk;
@@ -1447,7 +1447,7 @@ static void unix_copy_addr(struct msghdr
 }
 
 static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
-			      struct msghdr *msg, int size,
+			      struct msghdr *msg, size_t size,
 			      int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
@@ -1555,7 +1555,7 @@ static long unix_stream_data_wait(struct
 
 
 static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
-			       struct msghdr *msg, int size,
+			       struct msghdr *msg, size_t size,
 			       int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
diff -purN linux-2.6.1/net/x25/af_x25.c linux-2.5/net/x25/af_x25.c
--- linux-2.6.1/net/x25/af_x25.c	2004-01-09 07:00:03.000000000 +0000
+++ linux-2.5/net/x25/af_x25.c	2004-01-09 09:57:22.000000000 +0000
@@ -910,7 +910,7 @@ out_clear_request:
 }
 
 static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *msg, int len)
+		       struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
 	struct x25_opt *x25 = x25_sk(sk);
@@ -919,7 +919,8 @@ static int x25_sendmsg(struct kiocb *ioc
 	struct sk_buff *skb;
 	unsigned char *asmptr;
 	int noblock = msg->msg_flags & MSG_DONTWAIT;
-	int size, qbit = 0, rc = -EINVAL;
+	size_t size;
+	int qbit = 0, rc = -EINVAL;
 
 	if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_OOB | MSG_EOR))
 		goto out;
@@ -1085,13 +1086,14 @@ out_kfree_skb:
 
 
 static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,
-		       struct msghdr *msg, int size,
+		       struct msghdr *msg, size_t size,
 		       int flags)
 {
 	struct sock *sk = sock->sk;
 	struct x25_opt *x25 = x25_sk(sk);
 	struct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;
-	int copied, qbit;
+	size_t copied;
+	int qbit;
 	struct sk_buff *skb;
 	unsigned char *asmptr;
 	int rc = -ENOTCONN;

diff -purN linux-post-2.6.4rc1-20040301/Documentation/00-INDEX linux-post-2.6.4rc1-20040302/Documentation/00-INDEX
--- linux-post-2.6.4rc1-20040301/Documentation/00-INDEX	2003-09-10 07:41:25.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/Documentation/00-INDEX	2004-03-02 03:01:25.000000000 +0000
@@ -1,7 +1,7 @@
 
 This is a brief list of all the files in ./linux/Documentation and what
-they contain. If you add a documentation file, please list it here in 
-alphabetical order as well, or risk being hunted down like a rabid dog. 
+they contain. If you add a documentation file, please list it here in
+alphabetical order as well, or risk being hunted down like a rabid dog.
 Please try and keep the descriptions small enough to fit on one line.
 							 Thanks -- Paul G.
 
@@ -26,10 +26,14 @@ DocBook/
 	- directory with DocBook templates etc. for kernel documentation.
 IO-mapping.txt
 	- how to access I/O mapped memory from within device drivers.
+IPMI.txt
+	- info on Linux Intelligent Platform Management Interface (IPMI) Driver.
 IRQ-affinity.txt
 	- how to select which CPU(s) handle which interrupt events on SMP.
+MSI-HOWTO.txt
+	- the Message Signaled Interrupts (MSI) Driver Guide HOWTO and FAQ.
 README.DAC960
-	- info on Mylex DAC960/DAC1100 PCI RAID Controller Driver for Linux
+	- info on Mylex DAC960/DAC1100 PCI RAID Controller Driver for Linux.
 README.moxa
 	- release notes for Moxa mutiport serial card.
 SAK.txt
@@ -42,6 +46,10 @@ VGA-softcursor.txt
 	- how to change your VGA cursor from a blinking underscore.
 arm/
 	- directory with info about Linux on the ARM architecture.
+as-iosched.txt
+	- info on anticipatory IO scheduler.
+basic_profiling.txt
+	- basic instructions for those who wants to profile Linux kernel.
 binfmt_misc.txt
 	- info on the kernel support for extra binary formats.
 block/
@@ -53,25 +61,31 @@ cciss.txt
 cdrom/
 	- directory with information on the CD-ROM drivers that Linux has.
 computone.txt
-	- info on Computone Intelliport II/Plus Multiport Serial Driver
+	- info on Computone Intelliport II/Plus Multiport Serial Driver.
 cpqarray.txt
 	- info on using Compaq's SMART2 Intelligent Disk Array Controllers.
 cpufreq/
-	- info on CPU frequency and voltage scaling
+	- info on CPU frequency and voltage scaling.
 cris/
 	- directory with info about Linux on CRIS architecture.
+debugging-modules.txt
+	- some notes on debugging modules after Linux 2.6.3.
 devices.txt
-	- plain ASCII listing of all the nodes in /dev/ with major minor #'s
+	- plain ASCII listing of all the nodes in /dev/ with major minor #'s.
 digiboard.txt
 	- info on the Digiboard PC/X{i,e,eve} multiport boards.
 digiepca.txt
 	- info on Digi Intl. {PC,PCI,EISA}Xx and Xem series cards.
 dnotify.txt
 	- info about directory notification in Linux.
-driver-model.txt
-	- info about Linux driver model.
+driver-model/
+	- directory with info about Linux driver model.
+dvb/
+	- info on Linux Digital Video Broadcast (DVB) subsystem.
 early-userspace/
 	- info about initramfs, klibc, and userspace early during boot.
+eisa.txt
+	- info on EISA bus support.
 exception.txt
 	- how Linux v2.2 handles exceptions without verify_area etc.
 fb/
@@ -81,47 +95,51 @@ filesystems/
 floppy.txt
 	- notes and driver options for the floppy disk driver.
 ftape.txt
-	- notes about the floppy tape device driver
+	- notes about the floppy tape device driver.
 hayes-esp.txt
 	- info on using the Hayes ESP serial driver.
 highuid.txt
 	- notes on the change from 16 bit to 32 bit user/group IDs.
+hw_random.txt
+	- info on Linux support for random number generator in i8xx chipsets.
 i2c/
-	- directory with info about the I2C bus/protocol (2 wire, kHz speed)
+	- directory with info about the I2C bus/protocol (2 wire, kHz speed).
 i386/
-	- directory with info about Linux on intel 32 bit architecture.
-i810_rng.txt
-	- info on Linux support for random number generator in i8xx chipsets.
+	- directory with info about Linux on Intel 32 bit architecture.
 ia64/
-	- directory with info about Linux on intel 64 bit architecture.
+	- directory with info about Linux on Intel 64 bit architecture.
 ide.txt
-	- important info for users of ATA devices (IDE/EIDE disks and CD-ROMS)
+	- important info for users of ATA devices (IDE/EIDE disks and CD-ROMS).
 initrd.txt
 	- how to use the RAM disk as an initial/temporary root filesystem.
 input/
 	- info on Linux input device support.
 ioctl-number.txt
 	- how to implement and register device/driver ioctl calls.
+iostats.txt
+	- info on I/O statistics Linux kernel provides.
 isapnp.txt
-	- info on Linux ISA Plug & Play support
+	- info on Linux ISA Plug & Play support.
 isdn/
 	- directory with info on the Linux ISDN support, and supported cards.
 java.txt
-	- info on the in-kernel binary support for Java(tm)
+	- info on the in-kernel binary support for Java(tm).
 kbuild/
-	- directory with info about the kernel build process
+	- directory with info about the kernel build process.
 kernel-doc-nano-HOWTO.txt
 	- mini HowTo on generation and location of kernel documentation files.
 kernel-docs.txt
 	- listing of various WWW + books that document kernel internals.
 kernel-parameters.txt
 	- summary listing of command line / boot prompt args for the kernel.
+kobject.txt
+	- info of the kobject infrastructure of the Linux kernel.
 ldm.txt
 	- a brief description of LDM (Windows Dynamic Disks).
 locks.txt
 	- info on file locking implementations, flock() vs. fcntl(), etc.
 logo.gif
-	- Full colour GIF image of Linux logo (penguin)
+	- Full colour GIF image of Linux logo (penguin).
 logo.txt
 	- Info on creator of above logo & site to get additional images from.
 m68k/
@@ -133,27 +151,27 @@ mandatory.txt
 mca.txt
 	- info on supporting Micro Channel Architecture (e.g. PS/2) systems.
 md.txt
-	- info on boot arguments for the multiple devices driver
+	- info on boot arguments for the multiple devices driver.
 memory.txt
 	- info on typical Linux memory problems.
 mips/
 	- directory with info about Linux on MIPS architecture.
 mkdev.cciss
-	- script to make /dev entries for SMART controllers (see cciss.txt)
+	- script to make /dev entries for SMART controllers (see cciss.txt).
 mkdev.ida
 	- script to make /dev entries for Intelligent Disk Array Controllers.
 moxa-smartio
 	- info on installing/using Moxa multiport serial driver.
 mtrr.txt
-	- how to use PPro Memory Type Range Registers to increase performance
+	- how to use PPro Memory Type Range Registers to increase performance.
 nbd.txt
 	- info on a TCP implementation of a network block device.
 networking/
 	- directory with info on various aspects of networking with Linux.
 nfsroot.txt
-	- short guide on setting up a diskless box with NFS root filesystem
+	- short guide on setting up a diskless box with NFS root filesystem.
 nmi_watchdog.txt
-	- info on NMI watchdog for SMP systems
+	- info on NMI watchdog for SMP systems.
 oops-tracing.txt
 	- how to decode those nasty internal kernel error dump messages.
 paride.txt
@@ -165,11 +183,11 @@ parport.txt
 parport-lowlevel.txt
 	- description and usage of the low level parallel port functions.
 pci.txt
-	- info on the PCI subsystem for device driver authors
-pcwd-watchdog.txt
-	- info and sample code for using with the PC Watchdog reset card.
+	- info on the PCI subsystem for device driver authors.
 pm.txt
 	- info on Linux power management support.
+pnp.txt
+	- Linux Plug and Play documentation.
 power/
 	- directory with info on Linux PCI power management.
 powerpc/
@@ -181,29 +199,31 @@ ramdisk.txt
 riscom8.txt
 	- notes on using the RISCom/8 multi-port serial driver.
 rocket.txt
-	- info on installing/using the Comtrol RocketPort multiport serial driver
+	- info on installing/using the Comtrol RocketPort multiport serial driver.
+rpc-cache.txt
+	- introduction to the caching mechanisms in the sunrpc layer.
 rtc.txt
 	- notes on how to use the Real Time Clock (aka CMOS clock) driver.
 s390/
 	- directory with info on using Linux on the IBM S390.
-sh/
-	- directory with info on porting Linux to a new architecture.
+sched-design.txt
+	- goals, design and implementation of the Linux O(1) scheduler.
 scsi/
 	- directory with info on Linux scsi support.
 serial-console.txt
 	- how to set up Linux with a serial line console as the default.
 sgi-visws.txt
 	- short blurb on the SGI Visual Workstations.
+sh/
+	- directory with info on porting Linux to a new architecture.
 smart-config.txt
 	- description of the Smart Config makefile feature.
-smp.tex
-	- LaTeX document describing implementation of Multiprocessor Linux
 smp.txt
-	- a few more notes on symmetric multi-processing
+	- a few notes on symmetric multi-processing.
 sonypi.txt
 	- info on Linux Sony Programmable I/O Device support.
 sound/
-	- directory with info on sound card support
+	- directory with info on sound card support.
 sparc/
 	- directory with info on using Linux on Sparc architecture.
 specialix.txt
@@ -217,9 +237,9 @@ svga.txt
 sx.txt
 	- info on the Specialix SX/SI multiport serial driver.
 sysctl/
-	- directory with info on the /proc/sys/* files
+	- directory with info on the /proc/sys/* files.
 sysrq.txt
-	- info on the magic SysRq key
+	- info on the magic SysRq key.
 telephony/
 	- directory with info on telephony (e.g. voice over IP) support.
 unicode.txt
@@ -230,7 +250,7 @@ video4linux/
 	- directory with info regarding video/TV/radio cards and linux.
 vm/
 	- directory with info on the Linux vm code.
-watchdog.txt
+watchdog/
 	- how to auto-reboot Linux if it has "fallen and can't get up". ;-)
 x86_64/
 	- directory with info on Linux support for AMD x86-64 (Hammer) machines.
@@ -238,4 +258,3 @@ xterm-linux.xpm
 	- XPM image of penguin logo (see logo.txt) sitting on an xterm.
 zorro.txt
 	- info on writing drivers for Zorro bus devices found on Amigas.
-
diff -purN linux-post-2.6.4rc1-20040301/Documentation/networking/arcnet.txt linux-post-2.6.4rc1-20040302/Documentation/networking/arcnet.txt
--- linux-post-2.6.4rc1-20040301/Documentation/networking/arcnet.txt	2003-06-21 10:13:21.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/Documentation/networking/arcnet.txt	2004-03-02 03:01:46.000000000 +0000
@@ -186,7 +186,6 @@ loadable module. You can also say 'y' to
 to the chipset support if you wish.
 
 	make config
-	make dep
 	make clean	
 	make zImage
 	make modules
diff -purN linux-post-2.6.4rc1-20040301/Documentation/s390/CommonIO linux-post-2.6.4rc1-20040302/Documentation/s390/CommonIO
--- linux-post-2.6.4rc1-20040301/Documentation/s390/CommonIO	2004-02-26 11:21:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/Documentation/s390/CommonIO	2004-03-02 03:01:23.000000000 +0000
@@ -14,15 +14,6 @@ Command line parameters
   Default is off.
 
 
-* cio_notoper_msg = yes | no
-
-  Determines whether messages of the type "Device 0.0.4711 became 'not
-  operational'" should be shown during startup; after startup, they will always
-  be shown.
-  
-  Default is on.
-
-
 * cio_ignore = {all} |
 	       {<device> | <range of devices>} |
 	       {!<device> | !<range of devices>}
diff -purN linux-post-2.6.4rc1-20040301/Documentation/s390/driver-model.txt linux-post-2.6.4rc1-20040302/Documentation/s390/driver-model.txt
--- linux-post-2.6.4rc1-20040301/Documentation/s390/driver-model.txt	2004-02-26 11:21:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/Documentation/s390/driver-model.txt	2004-03-02 03:01:23.000000000 +0000
@@ -31,6 +31,9 @@ cutype:	    The control unit type / mode
 
 devtype:    The device type / model, if applicable.
 
+availability: Can be 'good' or 'boxed'; 'no path' or 'no device' for
+	      disconnected devices.
+
 online:     An interface to set the device online and offline.
 	    In the special case of the device being disconnected (see the
 	    notify function under 1.2), piping 0 to online will focibly delete
diff -purN linux-post-2.6.4rc1-20040301/MAINTAINERS linux-post-2.6.4rc1-20040302/MAINTAINERS
--- linux-post-2.6.4rc1-20040301/MAINTAINERS	2004-02-26 11:19:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/MAINTAINERS	2004-03-02 03:01:27.000000000 +0000
@@ -2395,7 +2395,7 @@ S:	Maintained
 
 ZR36067 VIDEO FOR LINUX DRIVER
 P:	Ronald Bultje
-M:	R.S.Bultje@pharm.uu.nl
+M:	rbultje@ronald.bitfreak.net
 L:	mjpeg-users@lists.sourceforge.net
 W:	http://mjpeg.sourceforge.net/driver-zoran/
 S:	Maintained
diff -purN linux-post-2.6.4rc1-20040301/README linux-post-2.6.4rc1-20040302/README
--- linux-post-2.6.4rc1-20040301/README	2003-12-30 08:41:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/README	2004-03-02 03:01:28.000000000 +0000
@@ -172,24 +172,15 @@ COMPILING the kernel:
 
    Please note that you can still run a.out user programs with this kernel.
 
- - Do a "make bzImage" to create a compressed kernel image.  If you want
-   to make a boot disk (without root filesystem or LILO), insert a floppy
-   in your A: drive, and do a "make bzdisk".  It is also possible to do
-   "make install" if you have lilo installed to suit the kernel makefiles,
-   but you may want to check your particular lilo setup first. 
+ - Do a "make" to create a compressed kernel image. It is also
+   possible to do "make install" if you have lilo installed to suit the
+   kernel makefiles, but you may want to check your particular lilo setup first.
 
    To do the actual install you have to be root, but none of the normal
    build should require that. Don't take the name of root in vain.
 
- - In the unlikely event that your system cannot boot bzImage kernels you
-   can still compile your kernel as zImage. However, since zImage support
-   will be removed at some point in the future in favor of bzImage we
-   encourage people having problems with booting bzImage kernels to report
-   these, with detailed hardware configuration information, to the
-   linux-kernel mailing list and to H. Peter Anvin <hpa+linux@zytor.com>.
-
  - If you configured any of the parts of the kernel as `modules', you
-   will have to do "make modules" followed by "make modules_install".
+   will also have to do "make modules_install".
 
  - Keep a backup kernel handy in case something goes wrong.  This is 
    especially true for the development releases, since each new release
@@ -200,11 +191,11 @@ COMPILING the kernel:
    do a "make modules_install".
 
  - In order to boot your new kernel, you'll need to copy the kernel
-   image (found in .../linux/arch/i386/boot/bzImage after compilation)
+   image (e.g. .../linux/arch/i386/boot/bzImage after compilation)
    to the place where your regular bootable kernel is found. 
 
-   For some, this is on a floppy disk, in which case you can copy the
-   kernel bzImage file to /dev/fd0 to make a bootable floppy.
+ - Booting a kernel directly from a floppy without the assistance of a
+   bootloader such as LILO, is no longer supported.
 
    If you boot Linux from the hard drive, chances are you use LILO which
    uses the kernel image as specified in the file /etc/lilo.conf.  The
@@ -262,8 +253,9 @@ IF SOMETHING GOES WRONG:
    the above example it's due to a bad kernel pointer). More information
    on making sense of the dump is in Documentation/oops-tracing.txt
 
- - You can use the "ksymoops" program to make sense of the dump.  This
-   utility can be downloaded from
+ - If you compiled the kernel with CONFIG_KALLSYMS you can send the dump
+   as is, otherwise you will have to use the "ksymoops" program to make
+   sense of the dump.  This utility can be downloaded from
    ftp://ftp.<country>.kernel.org/pub/linux/utils/kernel/ksymoops.
    Alternately you can do the dump lookup by hand:
 
diff -purN linux-post-2.6.4rc1-20040301/arch/arm/kernel/Makefile linux-post-2.6.4rc1-20040302/arch/arm/kernel/Makefile
--- linux-post-2.6.4rc1-20040301/arch/arm/kernel/Makefile	2004-02-27 15:20:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/arm/kernel/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -29,7 +29,7 @@ obj-$(CONFIG_DEBUG_LL)	+= debug.o
 
 extra-y := $(head-y) init_task.o vmlinux.lds.s
 
-# Spell out some dependencies that `make dep' doesn't spot
+# Spell out some dependencies that aren't automatically figured out
 $(obj)/entry-armv.o: 	$(obj)/entry-header.S include/asm-arm/constants.h
 $(obj)/entry-common.o: 	$(obj)/entry-header.S include/asm-arm/constants.h \
 			$(obj)/calls.S
diff -purN linux-post-2.6.4rc1-20040301/arch/arm26/mm/Makefile linux-post-2.6.4rc1-20040302/arch/arm26/mm/Makefile
--- linux-post-2.6.4rc1-20040301/arch/arm26/mm/Makefile	2003-06-04 11:15:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/arm26/mm/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,12 +1,5 @@
 #
 # Makefile for the linux arm26-specific parts of the memory manager.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definition is now in the main makefile...
-
-# Object file lists.
 
 obj-y		:= init.o extable.o proc-funcs.o mm-memc.o fault.o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/mm/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/mm/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/mm/Makefile	2004-01-18 11:35:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/mm/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,5 @@
 #
 # Makefile for the linux m68k-specific parts of the memory manager.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definition is now in the main makefile...
 
 obj-y	 := init.o fault.o memory.o kmap.o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/Makefile	2003-04-17 19:30:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -6,10 +6,6 @@
 
 #VPATH := $(VPATH):$(BOARD)
 
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 .S.o:
 	$(CC) -D__ASSEMBLY__ $(AFLAGS) -I. -c $< -o $*.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/aki3068net/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/aki3068net/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/aki3068net/Makefile	2003-07-14 06:17:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/aki3068net/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 extra-y := crt0_ram.o
 obj-y := timer.o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/generic/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/generic/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/generic/Makefile	2003-07-14 06:17:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/generic/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y := timer.o
 extra-y =  crt0_$(MODEL).o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/h8max/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/h8max/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8300h/h8max/Makefile	2003-07-14 06:17:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8300h/h8max/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 extra-y := crt0_ram.o
 obj-y := timer.o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/Makefile	2003-07-19 16:16:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -6,10 +6,6 @@
 
 #VPATH := $(VPATH):$(BOARD)
 
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 .S.o:
 	$(CC) -D__ASSEMBLY__ $(AFLAGS) -I. -c $< -o $*.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/edosk2674/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/edosk2674/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/edosk2674/Makefile	2003-07-19 16:16:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/edosk2674/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 extra-y := crt0_ram.o
 obj-y := timer.o
diff -purN linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/generic/Makefile linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/generic/Makefile
--- linux-post-2.6.4rc1-20040301/arch/h8300/platform/h8s/generic/Makefile	2003-07-19 16:16:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/h8300/platform/h8s/generic/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 extra-y =  crt0_$(MODEL).o
 obj-y := timer.o
diff -purN linux-post-2.6.4rc1-20040301/arch/i386/defconfig linux-post-2.6.4rc1-20040302/arch/i386/defconfig
--- linux-post-2.6.4rc1-20040301/arch/i386/defconfig	2004-02-05 19:38:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/i386/defconfig	2004-03-02 07:46:57.000000000 +0000
@@ -21,6 +21,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=15
+CONFIG_HOTPLUG=y
 # CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
@@ -44,6 +45,7 @@ CONFIG_KMOD=y
 # Processor type and features
 #
 CONFIG_X86_PC=y
+# CONFIG_X86_ELAN is not set
 # CONFIG_X86_VOYAGER is not set
 # CONFIG_X86_NUMAQ is not set
 # CONFIG_X86_SUMMIT is not set
@@ -59,6 +61,7 @@ CONFIG_X86_PC=y
 # CONFIG_M686 is not set
 # CONFIG_MPENTIUMII is not set
 # CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
 CONFIG_MPENTIUM4=y
 # CONFIG_MK6 is not set
 # CONFIG_MK7 is not set
@@ -105,7 +108,9 @@ CONFIG_NOHIGHMEM=y
 # CONFIG_MATH_EMULATION is not set
 CONFIG_MTRR=y
 # CONFIG_EFI is not set
+CONFIG_IRQBALANCE=y
 CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_REGPARM is not set
 
 #
 # Power management options (ACPI, APM)
@@ -137,6 +142,7 @@ CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
 # CONFIG_ACPI_RELAXED_AML is not set
+# CONFIG_X86_PM_TIMER is not set
 
 #
 # APM (Advanced Power Management) BIOS Support
@@ -164,7 +170,6 @@ CONFIG_ISA=y
 # CONFIG_EISA is not set
 # CONFIG_MCA is not set
 # CONFIG_SCx200 is not set
-CONFIG_HOTPLUG=y
 
 #
 # PCMCIA/CardBus support
@@ -261,6 +266,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 # IDE chipset support/bugfixes
 #
+CONFIG_IDE_GENERIC=y
 CONFIG_BLK_DEV_CMD640=y
 # CONFIG_BLK_DEV_CMD640_ENHANCED is not set
 # CONFIG_BLK_DEV_IDEPNP is not set
@@ -368,10 +374,13 @@ CONFIG_SCSI_ATA_PIIX=y
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX_CONFIG=y
+CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
-# CONFIG_SCSI_QLA23XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_SYM53C416 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
@@ -397,7 +406,7 @@ CONFIG_SCSI_QLA2XXX_CONFIG=y
 # CONFIG_FUSION is not set
 
 #
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+# IEEE 1394 (FireWire) support
 #
 CONFIG_IEEE1394=y
 
@@ -406,6 +415,7 @@ CONFIG_IEEE1394=y
 #
 # CONFIG_IEEE1394_VERBOSEDEBUG is not set
 # CONFIG_IEEE1394_OUI_DB is not set
+# CONFIG_IEEE1394_EXTRA_CONFIG_ROMS is not set
 
 #
 # Device Drivers
@@ -423,7 +433,7 @@ CONFIG_IEEE1394_OHCI1394=y
 # CONFIG_IEEE1394_SBP2 is not set
 # CONFIG_IEEE1394_ETH1394 is not set
 # CONFIG_IEEE1394_DV1394 is not set
-# CONFIG_IEEE1394_RAWIO is not set
+CONFIG_IEEE1394_RAWIO=y
 # CONFIG_IEEE1394_CMP is not set
 
 #
@@ -432,6 +442,10 @@ CONFIG_IEEE1394_OHCI1394=y
 # CONFIG_I2O is not set
 
 #
+# Macintosh device drivers
+#
+
+#
 # Networking support
 #
 CONFIG_NET=y
@@ -595,10 +609,11 @@ CONFIG_NET_PCI=y
 # CONFIG_NE2K_PCI is not set
 # CONFIG_8139CP is not set
 CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_PIO=y
 # CONFIG_8139TOO_TUNE_TWISTER is not set
 # CONFIG_8139TOO_8129 is not set
 # CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_8139_RXBUF_IDX=2
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
@@ -666,7 +681,7 @@ CONFIG_8139TOO=y
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN_BOOL is not set
+# CONFIG_ISDN is not set
 
 #
 # Telephony Support
@@ -742,7 +757,8 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
 CONFIG_PRINTER=y
 # CONFIG_LP_CONSOLE is not set
 # CONFIG_PPDEV is not set
@@ -785,6 +801,7 @@ CONFIG_AGP_INTEL=y
 # CONFIG_AGP_SIS is not set
 # CONFIG_AGP_SWORKS is not set
 # CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
 CONFIG_DRM=y
 # CONFIG_DRM_TDFX is not set
 # CONFIG_DRM_GAMMA is not set
@@ -884,6 +901,7 @@ CONFIG_SND_SEQUENCER_OSS=y
 #
 # CONFIG_SND_ALI5451 is not set
 # CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
 # CONFIG_SND_CS46XX is not set
 # CONFIG_SND_CS4281 is not set
 # CONFIG_SND_EMU10K1 is not set
@@ -976,7 +994,6 @@ CONFIG_USB_HIDINPUT=y
 # USB Imaging devices
 #
 # CONFIG_USB_MDC800 is not set
-# CONFIG_USB_SCANNER is not set
 # CONFIG_USB_MICROTEK is not set
 # CONFIG_USB_HPUSBSCSI is not set
 
@@ -1070,7 +1087,6 @@ CONFIG_VFAT_FS=y
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
 # CONFIG_HUGETLBFS is not set
@@ -1083,6 +1099,7 @@ CONFIG_RAMFS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
@@ -1111,7 +1128,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -1173,6 +1189,7 @@ CONFIG_OPROFILE=y
 # Kernel hacking
 #
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_EARLY_PRINTK=y
 CONFIG_DEBUG_SPINLOCK_SLEEP=y
 # CONFIG_FRAME_POINTER is not set
 CONFIG_X86_FIND_SMP_CONFIG=y
diff -purN linux-post-2.6.4rc1-20040301/arch/i386/kernel/cpu/cpufreq/powernow-k8.c linux-post-2.6.4rc1-20040302/arch/i386/kernel/cpu/cpufreq/powernow-k8.c
--- linux-post-2.6.4rc1-20040301/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2004-02-26 15:38:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2004-03-02 03:01:47.000000000 +0000
@@ -8,6 +8,8 @@
  *
  *  Based on the powernow-k7.c module written by Dave Jones.
  *  (C) 2003 Dave Jones <davej@codemonkey.ork.uk> on behalf of SuSE Labs
+ *  (C) 2004 Dominik Brodowski <linux@brodo.de>
+ *  (C) 2004 Pavel Machek <pavel@suse.cz>
  *  Licensed under the terms of the GNU GPL License version 2.
  *  Based upon datasheets & sample CPUs kindly provided by AMD.
  *
@@ -34,10 +36,6 @@
 #define VERSION "version 1.00.08a"
 #include "powernow-k8.h"
 
-#ifdef CONFIG_PREEMPT
-#warning this driver has not been tested on a preempt system
-#endif
-
 static u32 vstable;	/* voltage stabalization time, from PSB, units 20 us */
 static u32 plllock;	/* pll lock time, from PSB, units 1 us */
 static u32 numps;	/* number of p-states, from PSB */
@@ -636,13 +634,22 @@ find_psb_table(void)
 			return -ENOMEM;
 		}
 
-		for (j = 0; j < numps; j++) {
-			printk(KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j,
-			       pst[j].fid, find_freq_from_fid(pst[j].fid), pst[j].vid);
+		for (j = 0; j < psb->numpstates; j++) {
 			powernow_table[j].index = pst[j].fid; /* lower 8 bits */
 			powernow_table[j].index |= (pst[j].vid << 8); /* upper 8 bits */
-			powernow_table[j].frequency = find_freq_from_fid(pst[j].fid);
 		}
+
+		/* If you want to override your frequency tables, this
+		   is right place. */
+
+		for (j = 0; j < numps; j++) {
+			powernow_table[j].frequency = find_freq_from_fid(powernow_table[j].index & 0xff)*1000;
+			printk(KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j,
+			       powernow_table[j].index & 0xff,
+			       powernow_table[j].frequency/1000,
+			       powernow_table[j].index >> 8);
+		}
+
 		powernow_table[numps].frequency = CPUFREQ_TABLE_END;
 		powernow_table[numps].index = 0;
 
diff -purN linux-post-2.6.4rc1-20040301/arch/i386/mach-voyager/Makefile linux-post-2.6.4rc1-20040302/arch/i386/mach-voyager/Makefile
--- linux-post-2.6.4rc1-20040301/arch/i386/mach-voyager/Makefile	2003-02-03 22:19:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/i386/mach-voyager/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,11 +1,6 @@
 #
 # Makefile for the linux kernel.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile...
 
 EXTRA_CFLAGS	+= -I../kernel
 obj-y			:= setup.o voyager_basic.o voyager_thread.o
diff -purN linux-post-2.6.4rc1-20040301/arch/i386/oprofile/nmi_int.c linux-post-2.6.4rc1-20040302/arch/i386/oprofile/nmi_int.c
--- linux-post-2.6.4rc1-20040301/arch/i386/oprofile/nmi_int.c	2004-02-19 03:43:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/i386/oprofile/nmi_int.c	2004-03-02 03:01:51.000000000 +0000
@@ -88,7 +88,7 @@ static int nmi_callback(struct pt_regs *
 }
  
  
-static void nmi_save_registers(struct op_msrs * msrs)
+static void nmi_cpu_save_registers(struct op_msrs * msrs)
 {
 	unsigned int const nr_ctrs = model->num_counters;
 	unsigned int const nr_ctrls = model->num_controls; 
@@ -110,6 +110,15 @@ static void nmi_save_registers(struct op
 }
 
 
+static void nmi_save_registers(void * dummy)
+{
+	int cpu = smp_processor_id();
+	struct op_msrs * msrs = &cpu_msrs[cpu];
+	model->fill_in_addresses(msrs);
+	nmi_cpu_save_registers(msrs);
+}
+
+
 static void free_msrs(void)
 {
 	int i;
@@ -156,8 +165,6 @@ static void nmi_cpu_setup(void * dummy)
 {
 	int cpu = smp_processor_id();
 	struct op_msrs * msrs = &cpu_msrs[cpu];
-	model->fill_in_addresses(msrs);
-	nmi_save_registers(msrs);
 	spin_lock(&oprofilefs_lock);
 	model->setup_ctrs(msrs);
 	spin_unlock(&oprofilefs_lock);
@@ -177,6 +184,10 @@ static int nmi_setup(void)
 	 * break the core code horrifically.
 	 */
 	disable_lapic_nmi_watchdog();
+	/* We need to serialize save and setup for HT because the subset
+	 * of msrs are distinct for save and setup operations
+	 */
+	on_each_cpu(nmi_save_registers, NULL, 0, 1);
 	on_each_cpu(nmi_cpu_setup, NULL, 0, 1);
 	set_nmi_callback(nmi_callback);
 	nmi_enabled = 1;
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/amiga/amiints.c linux-post-2.6.4rc1-20040302/arch/m68k/amiga/amiints.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/amiga/amiints.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/amiga/amiints.c	2004-03-02 03:01:50.000000000 +0000
@@ -49,7 +49,6 @@
 #include <asm/amigahw.h>
 #include <asm/amigaints.h>
 #include <asm/amipcmcia.h>
-#include <asm/unistd.h>
 
 extern int cia_request_irq(struct ciabase *base,int irq,
                            irqreturn_t (*handler)(int, void *, struct pt_regs *),
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/bvme6000/bvmeints.c linux-post-2.6.4rc1-20040302/arch/m68k/bvme6000/bvmeints.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/bvme6000/bvmeints.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/bvme6000/bvmeints.c	2004-03-02 03:01:50.000000000 +0000
@@ -20,7 +20,6 @@
 #include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/traps.h>
-#include <asm/unistd.h>
 
 static irqreturn_t bvme6000_defhand (int irq, void *dev_id, struct pt_regs *fp);
 
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/hp300/time.c linux-post-2.6.4rc1-20040302/arch/m68k/hp300/time.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/hp300/time.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/hp300/time.c	2004-03-02 03:01:50.000000000 +0000
@@ -17,7 +17,6 @@
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/traps.h>
-#include <asm/unistd.h>
 #include "ints.h"
 
 /* Clock hardware definitions */
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/kernel/setup.c linux-post-2.6.4rc1-20040302/arch/m68k/kernel/setup.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/kernel/setup.c	2004-02-23 05:24:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/kernel/setup.c	2004-03-01 14:30:55.000000000 +0000
@@ -39,7 +39,6 @@
 #endif
 #ifdef CONFIG_SUN3X
 #include <asm/dvma.h>
-extern void sun_serial_setup(void);
 #endif
 
 unsigned long m68k_machtype;
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/mac/iop.c linux-post-2.6.4rc1-20040302/arch/m68k/mac/iop.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/mac/iop.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/mac/iop.c	2004-03-02 03:01:50.000000000 +0000
@@ -118,7 +118,6 @@
 #include <asm/macints.h> 
 #include <asm/mac_iop.h>
 #include <asm/mac_oss.h>
-#include <asm/unistd.h>
 
 /*#define DEBUG_IOP*/
 
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/mac/macints.c linux-post-2.6.4rc1-20040302/arch/m68k/mac/macints.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/mac/macints.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/mac/macints.c	2004-03-02 03:01:50.000000000 +0000
@@ -133,7 +133,6 @@
 #include <asm/hwtest.h>
 #include <asm/errno.h>
 #include <asm/macints.h>
-#include <asm/unistd.h>
 
 #define DEBUG_SPURIOUS
 #define SHUTUP_SONIC
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/mac/oss.c linux-post-2.6.4rc1-20040302/arch/m68k/mac/oss.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/mac/oss.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/mac/oss.c	2004-03-02 03:01:50.000000000 +0000
@@ -26,7 +26,6 @@
 #include <asm/macints.h>
 #include <asm/mac_via.h>
 #include <asm/mac_oss.h>
-#include <asm/unistd.h>
 
 int oss_present;
 volatile struct mac_oss *oss;
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/mac/psc.c linux-post-2.6.4rc1-20040302/arch/m68k/mac/psc.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/mac/psc.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/mac/psc.c	2004-03-02 03:01:50.000000000 +0000
@@ -24,7 +24,6 @@
 #include <asm/macintosh.h> 
 #include <asm/macints.h> 
 #include <asm/mac_psc.h>
-#include <asm/unistd.h>
 
 #define DEBUG_PSC
 
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/mac/via.c linux-post-2.6.4rc1-20040302/arch/m68k/mac/via.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/mac/via.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/mac/via.c	2004-03-02 03:01:50.000000000 +0000
@@ -32,7 +32,6 @@
 #include <asm/machw.h> 
 #include <asm/mac_via.h>
 #include <asm/mac_psc.h>
-#include <asm/unistd.h>
 
 volatile __u8 *via1, *via2;
 #if 0
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/q40/q40ints.c linux-post-2.6.4rc1-20040302/arch/m68k/q40/q40ints.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/q40/q40ints.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/q40/q40ints.c	2004-03-02 03:01:50.000000000 +0000
@@ -26,7 +26,6 @@
 #include <asm/irq.h>
 #include <asm/hardirq.h>
 #include <asm/traps.h>
-#include <asm/unistd.h>
 
 #include <asm/q40_master.h>
 #include <asm/q40ints.h>
diff -purN linux-post-2.6.4rc1-20040301/arch/m68k/sun3/sun3ints.c linux-post-2.6.4rc1-20040302/arch/m68k/sun3/sun3ints.c
--- linux-post-2.6.4rc1-20040301/arch/m68k/sun3/sun3ints.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/m68k/sun3/sun3ints.c	2004-03-02 03:01:50.000000000 +0000
@@ -15,7 +15,6 @@
 #include <asm/intersil.h>
 #include <asm/oplib.h>
 #include <asm/sun3ints.h>
-#include <asm/unistd.h>
 #include <linux/seq_file.h>
 
 extern void sun3_leds (unsigned char);
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/au1000/csb250/Makefile linux-post-2.6.4rc1-20040302/arch/mips/au1000/csb250/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/au1000/csb250/Makefile	2004-02-21 01:32:59.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/au1000/csb250/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -4,10 +4,6 @@
 #
 # Makefile for the Cogent CSB250 Au1500 board.  Copied from Pb1500.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 USE_STANDARD_AS_RULE := true
 
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/au1000/hydrogen3/Makefile linux-post-2.6.4rc1-20040302/arch/mips/au1000/hydrogen3/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/au1000/hydrogen3/Makefile	2004-02-21 01:32:59.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/au1000/hydrogen3/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -5,10 +5,6 @@
 #
 # Makefile for the Alchemy Semiconductor PB1000 board.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 .S.s:
 	$(CPP) $(CFLAGS) $< -o $*.s
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/au1000/mtx-1/Makefile linux-post-2.6.4rc1-20040302/arch/mips/au1000/mtx-1/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/au1000/mtx-1/Makefile	2004-02-21 01:32:59.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/au1000/mtx-1/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -6,9 +6,5 @@
 #
 # Makefile for 4G Systems MTX-1 board.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 lib-y := init.o board_setup.o irqmap.o
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/au1000/pb1550/Makefile linux-post-2.6.4rc1-20040302/arch/mips/au1000/pb1550/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/au1000/pb1550/Makefile	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/au1000/pb1550/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -5,10 +5,6 @@
 #
 # Makefile for the Alchemy Semiconductor PB1000 board.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 .S.s:
 	$(CPP) $(CFLAGS) $< -o $*.s
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/au1000/xxs1500/Makefile linux-post-2.6.4rc1-20040302/arch/mips/au1000/xxs1500/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/au1000/xxs1500/Makefile	2004-02-21 01:33:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/au1000/xxs1500/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -5,9 +5,5 @@
 #
 # Makefile for MyCable XXS1500 board.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 lib-y := init.o board_setup.o irqmap.o
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/kernel/gdb-stub.c linux-post-2.6.4rc1-20040302/arch/mips/kernel/gdb-stub.c
--- linux-post-2.6.4rc1-20040301/arch/mips/kernel/gdb-stub.c	2004-02-19 20:53:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/kernel/gdb-stub.c	2004-03-02 03:01:46.000000000 +0000
@@ -95,7 +95,7 @@
  *  Example:
  *    $ cd ~/linux
  *    $ make menuconfig <go to "Kernel Hacking" and turn on remote debugging>
- *    $ make dep; make vmlinux
+ *    $ make
  *
  *  Step 3:
  *  Download the kernel to the remote target and start
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/momentum/jaguar_atx/Makefile linux-post-2.6.4rc1-20040302/arch/mips/momentum/jaguar_atx/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/momentum/jaguar_atx/Makefile	2004-02-21 01:33:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/momentum/jaguar_atx/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for Momentum Computer's Jaguar-ATX board.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 		+= mv-irq.o int-handler.o irq.o pci-irq.o prom.o reset.o setup.o
 obj-$(CONFIG_PCI)	+= pci.o
diff -purN linux-post-2.6.4rc1-20040301/arch/mips/tx4927/common/Makefile linux-post-2.6.4rc1-20040302/arch/mips/tx4927/common/Makefile
--- linux-post-2.6.4rc1-20040301/arch/mips/tx4927/common/Makefile	2003-04-15 03:10:10.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/mips/tx4927/common/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for common code for Toshiba TX4927 based systems
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	:= tx4927_prom.o
 obj-y	+= tx4927_setup.o
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/configs/g5_defconfig linux-post-2.6.4rc1-20040302/arch/ppc64/configs/g5_defconfig
--- linux-post-2.6.4rc1-20040301/arch/ppc64/configs/g5_defconfig	2004-02-14 05:10:02.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/configs/g5_defconfig	2004-03-02 03:01:22.000000000 +0000
@@ -26,6 +26,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=17
+CONFIG_HOTPLUG=y
 # CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
@@ -56,15 +57,16 @@ CONFIG_PPC64=y
 CONFIG_PPC_OF=y
 CONFIG_ALTIVEC=y
 CONFIG_PPC_PMAC=y
+# CONFIG_PMAC_DART is not set
 CONFIG_PPC_PMAC64=y
 CONFIG_BOOTX_TEXT=y
 CONFIG_POWER4_ONLY=y
+# CONFIG_IOMMU_VMERGE is not set
 CONFIG_SMP=y
 CONFIG_IRQ_ALL_CPUS=y
 CONFIG_NR_CPUS=2
 # CONFIG_HMT is not set
-CONFIG_DISCONTIGMEM=y
-# CONFIG_NUMA is not set
+# CONFIG_DISCONTIGMEM is not set
 # CONFIG_PPC_RTAS is not set
 # CONFIG_LPARCFG is not set
 
@@ -77,7 +79,6 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
-CONFIG_HOTPLUG=y
 
 #
 # PCMCIA/CardBus support
@@ -128,6 +129,7 @@ CONFIG_BLK_DEV_NBD=m
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_BLK_DEV_INITRD=y
+# CONFIG_DCSSBLK is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -277,6 +279,7 @@ CONFIG_MD_RAID5=y
 # CONFIG_MD_MULTIPATH is not set
 CONFIG_BLK_DEV_DM=y
 CONFIG_DM_IOCTL_V4=y
+# CONFIG_DM_CRYPT is not set
 
 #
 # Fusion MPT device support
@@ -284,7 +287,7 @@ CONFIG_DM_IOCTL_V4=y
 # CONFIG_FUSION is not set
 
 #
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+# IEEE 1394 (FireWire) support
 #
 CONFIG_IEEE1394=y
 
@@ -318,11 +321,11 @@ CONFIG_IEEE1394_RAWIO=y
 #
 # Macintosh device drivers
 #
+CONFIG_ADB=y
 CONFIG_ADB_PMU=y
 # CONFIG_PMAC_PBOOK is not set
 # CONFIG_PMAC_BACKLIGHT is not set
 # CONFIG_MAC_SERIAL is not set
-CONFIG_ADB=y
 # CONFIG_INPUT_ADBHID is not set
 CONFIG_THERM_PM72=y
 
@@ -439,6 +442,7 @@ CONFIG_TIGON3=m
 # CONFIG_IXGB is not set
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
+# CONFIG_IBMVETH is not set
 CONFIG_PPP=m
 # CONFIG_PPP_MULTILINK is not set
 # CONFIG_PPP_FILTER is not set
@@ -488,7 +492,7 @@ CONFIG_IBMOL=y
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN_BOOL is not set
+# CONFIG_ISDN is not set
 
 #
 # Telephony Support
@@ -556,7 +560,8 @@ CONFIG_HW_CONSOLE=y
 #
 # CONFIG_SERIAL_PMACZILOG is not set
 CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
 CONFIG_HVC_CONSOLE=y
 
 #
@@ -676,6 +681,7 @@ CONFIG_FB_RIVA=y
 # CONFIG_FB_RADEON_OLD is not set
 CONFIG_FB_RADEON=y
 CONFIG_FB_RADEON_I2C=y
+# CONFIG_FB_RADEON_DEBUG is not set
 # CONFIG_FB_ATY128 is not set
 # CONFIG_FB_ATY is not set
 # CONFIG_FB_SIS is not set
@@ -919,7 +925,6 @@ CONFIG_VFAT_FS=y
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 CONFIG_DEVPTS_FS_XATTR=y
 # CONFIG_DEVPTS_FS_SECURITY is not set
 CONFIG_TMPFS=y
@@ -933,6 +938,7 @@ CONFIG_RAMFS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
@@ -964,7 +970,6 @@ CONFIG_RPCSEC_GSS_KRB5=m
 CONFIG_CIFS=m
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -1037,9 +1042,11 @@ CONFIG_OPROFILE=y
 # Kernel hacking
 #
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_MAGIC_SYSRQ=y
-# CONFIG_XMON is not set
+# CONFIG_DEBUGGER is not set
 # CONFIG_PPCDBG is not set
 # CONFIG_DEBUG_INFO is not set
 
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/pSeries_htab.c linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/pSeries_htab.c
--- linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/pSeries_htab.c	2004-02-27 12:16:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/pSeries_htab.c	2004-03-02 03:01:21.000000000 +0000
@@ -103,7 +103,7 @@ long pSeries_hpte_insert(unsigned long h
 
 	__asm__ __volatile__ ("ptesync" : : : "memory");
 
-	return i;
+	return i | (secondary << 3);
 }
 
 static long pSeries_hpte_remove(unsigned long hpte_group)
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/pSeries_lpar.c linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/pSeries_lpar.c
--- linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/pSeries_lpar.c	2004-02-27 12:16:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/pSeries_lpar.c	2004-03-02 03:01:21.000000000 +0000
@@ -379,7 +379,10 @@ long pSeries_lpar_hpte_insert(unsigned l
 	if (lpar_rc != H_Success)
 		return -2;
 
-	return slot;
+	/* Because of iSeries, we have to pass down the secondary
+	 * bucket bit here as well
+	 */
+	return (slot & 7) | (secondary << 3);
 }
 
 static spinlock_t pSeries_lpar_tlbie_lock = SPIN_LOCK_UNLOCKED;
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/vio.c linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/vio.c
--- linux-post-2.6.4rc1-20040301/arch/ppc64/kernel/vio.c	2004-02-27 12:22:02.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/kernel/vio.c	2004-03-01 16:04:41.000000000 +0000
@@ -29,6 +29,8 @@
 
 #define DBGENTER() pr_debug("%s entered\n", __FUNCTION__)
 
+extern struct subsystem devices_subsys; /* needed for vio_find_name() */
+
 struct iommu_table *vio_build_iommu_table(struct vio_dev *dev);
 
 static int vio_num_address_cells;
@@ -157,8 +159,7 @@ static int __init vio_bus_init(void)
 
 	node_vroot = find_devices("vdevice");
 	if ((node_vroot == NULL) || (node_vroot->child == NULL)) {
-		printk(KERN_INFO "VIO: missing or empty /vdevice node; no virtual IO"
-			" devices present.\n");
+		/* this machine doesn't do virtual IO, and that's ok */
 		return 0;
 	}
 
@@ -260,7 +261,7 @@ struct vio_dev * __devinit vio_register_
 	/* init generic 'struct device' fields: */
 	viodev->dev.parent = &vio_bus_device->dev;
 	viodev->dev.bus = &vio_bus_type;
-	snprintf(viodev->dev.bus_id, BUS_ID_SIZE, "%lx", viodev->unit_address);
+	snprintf(viodev->dev.bus_id, BUS_ID_SIZE, "%x", viodev->unit_address);
 	viodev->dev.release = vio_dev_release;
 
 	/* register with generic device framework */
@@ -299,6 +300,42 @@ const void * vio_get_attribute(struct vi
 }
 EXPORT_SYMBOL(vio_get_attribute);
 
+/* vio_find_name() - internal because only vio.c knows how we formatted the
+ * kobject name
+ * XXX once vio_bus_type.devices is actually used as a kset in
+ * drivers/base/bus.c, this function should be removed in favor of
+ * "device_find(kobj_name, &vio_bus_type)"
+ */
+static struct vio_dev *vio_find_name(const char *kobj_name)
+{
+	struct kobject *found;
+
+	found = kset_find_obj(&devices_subsys.kset, kobj_name);
+	if (!found)
+		return NULL;
+
+	return to_vio_dev(container_of(found, struct device, kobj));
+}
+
+/**
+ * vio_find_node - find an already-registered vio_dev
+ * @vnode: device_node of the virtual device we're looking for
+ */
+struct vio_dev *vio_find_node(struct device_node *vnode)
+{
+	uint32_t *unit_address;
+	char kobj_name[BUS_ID_SIZE];
+
+	/* construct the kobject name from the device node */
+	unit_address = (uint32_t *)get_property(vnode, "reg", NULL);
+	if (!unit_address)
+		return NULL;
+	snprintf(kobj_name, BUS_ID_SIZE, "%x", *unit_address);
+
+	return vio_find_name(kobj_name);
+}
+EXPORT_SYMBOL(vio_find_node);
+
 /**
  * vio_build_iommu_table: - gets the dma information from OF and builds the TCE tree.
  * @dev: the virtual device.
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/mm/hash_low.S linux-post-2.6.4rc1-20040302/arch/ppc64/mm/hash_low.S
--- linux-post-2.6.4rc1-20040301/arch/ppc64/mm/hash_low.S	2004-02-12 04:32:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/mm/hash_low.S	2004-03-02 03:01:21.000000000 +0000
@@ -176,7 +176,6 @@ _GLOBAL(htab_call_hpte_insert1)
 	beq-	htab_pte_insert_failure
 
 	/* Now try secondary slot */
-	ori	r30,r30,_PAGE_SECONDARY
 	
 	/* page number in r5 */
 	rldicl	r5,r31,64-PTE_SHIFT,PTE_SHIFT
@@ -215,8 +214,8 @@ _GLOBAL(htab_call_hpte_remove)
 	b	htab_insert_pte	
 
 htab_pte_insert_ok:
-	/* Insert slot number in PTE */
-	rldimi	r30,r3,12,63-14
+	/* Insert slot number & secondary bit in PTE */
+	rldimi	r30,r3,12,63-15
 		
 	/* Write out the PTE with a normal write
 	 * (maybe add eieio may be good still ?)
diff -purN linux-post-2.6.4rc1-20040301/arch/ppc64/mm/numa.c linux-post-2.6.4rc1-20040302/arch/ppc64/mm/numa.c
--- linux-post-2.6.4rc1-20040301/arch/ppc64/mm/numa.c	2004-02-27 22:42:19.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/ppc64/mm/numa.c	2004-03-02 03:01:22.000000000 +0000
@@ -33,7 +33,10 @@ bootmem_data_t plat_node_bdata[MAX_NUMNO
 static unsigned long node0_io_hole_size;
 
 EXPORT_SYMBOL(node_data);
+EXPORT_SYMBOL(numa_cpu_lookup_table);
 EXPORT_SYMBOL(numa_memory_lookup_table);
+EXPORT_SYMBOL(numa_cpumask_lookup_table);
+EXPORT_SYMBOL(nr_cpus_in_node);
 
 static inline void map_cpu_to_node(int cpu, int node)
 {
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_ioctl.c linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_ioctl.c
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_ioctl.c	2004-01-19 06:35:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_ioctl.c	2004-03-02 03:01:23.000000000 +0000
@@ -49,7 +49,16 @@ COMPATIBLE_IOCTL(BIODASDRSRV)
 COMPATIBLE_IOCTL(BIODASDRLSE)
 COMPATIBLE_IOCTL(BIODASDSLCK)
 COMPATIBLE_IOCTL(BIODASDINFO)
+COMPATIBLE_IOCTL(BIODASDINFO2)
 COMPATIBLE_IOCTL(BIODASDFMT)
+COMPATIBLE_IOCTL(BIODASDPRRST)
+COMPATIBLE_IOCTL(BIODASDQUIESCE)
+COMPATIBLE_IOCTL(BIODASDRESUME)
+COMPATIBLE_IOCTL(BIODASDPRRD)
+COMPATIBLE_IOCTL(BIODASDPSRD)
+COMPATIBLE_IOCTL(BIODASDGATTR)
+COMPATIBLE_IOCTL(BIODASDSATTR)
+
 #endif
 
 #if defined(CONFIG_S390_TAPE) || defined(CONFIG_S390_TAPE_MODULE)
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_linux.c linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_linux.c
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_linux.c	2004-02-25 10:34:46.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_linux.c	2004-03-02 03:01:23.000000000 +0000
@@ -1161,8 +1161,7 @@ static int filldir(void * __buf, const c
 	put_user(reclen, &dirent->d_reclen);
 	copy_to_user(dirent->d_name, name, namlen);
 	put_user(0, dirent->d_name + namlen);
-	((char *) dirent) += reclen;
-	buf->current_dir = dirent;
+	buf->current_dir = ((void *)dirent) + reclen;
 	buf->count -= reclen;
 	return 0;
 }
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_ptrace.h linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_ptrace.h
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/compat_ptrace.h	2003-04-14 19:11:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/compat_ptrace.h	2004-03-02 03:01:23.000000000 +0000
@@ -3,23 +3,20 @@
 
 #include "compat_linux.h"  /* needed for _psw_t32 */
 
-typedef struct
-{
+typedef struct {
 	__u32 cr[3];
-} per_cr_words32  __attribute__((packed));
+} per_cr_words32;
 
-typedef struct
-{
+typedef struct {
 	__u16          perc_atmid;          /* 0x096 */
 	__u32          address;             /* 0x098 */
 	__u8           access_id;           /* 0x0a1 */
-} per_lowcore_words32  __attribute__((packed));
+} per_lowcore_words32;
 
-typedef struct
-{
+typedef struct {
 	union {
 		per_cr_words32   words;
-	} control_regs  __attribute__((packed));
+	} control_regs;
 	/*
 	 * Use these flags instead of setting em_instruction_fetch
 	 * directly they are used so that single stepping can be
@@ -37,7 +34,7 @@ typedef struct
 	union {
 		per_lowcore_words32 words;
 	} lowcore; 
-} per_struct32 __attribute__((packed));
+} per_struct32;
 
 struct user_regs_struct32
 {
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/s390_ksyms.c linux-post-2.6.4rc1-20040302/arch/s390/kernel/s390_ksyms.c
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/s390_ksyms.c	2004-02-26 11:21:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/s390_ksyms.c	2004-03-02 03:01:23.000000000 +0000
@@ -29,6 +29,7 @@
 EXPORT_SYMBOL_NOVERS(_oi_bitmap);
 EXPORT_SYMBOL_NOVERS(_ni_bitmap);
 EXPORT_SYMBOL_NOVERS(_zb_findmap);
+EXPORT_SYMBOL_NOVERS(_sb_findmap);
 EXPORT_SYMBOL_NOVERS(__copy_from_user_asm);
 EXPORT_SYMBOL_NOVERS(__copy_to_user_asm);
 EXPORT_SYMBOL_NOVERS(__clear_user_asm);
@@ -92,5 +93,4 @@ EXPORT_SYMBOL(console_device);
 EXPORT_SYMBOL_NOVERS(do_call_softirq);
 EXPORT_SYMBOL(sys_wait4);
 EXPORT_SYMBOL(cpcmd);
-EXPORT_SYMBOL(smp_call_function_on);
 EXPORT_SYMBOL(sys_ioctl);
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/smp.c linux-post-2.6.4rc1-20040302/arch/s390/kernel/smp.c
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/smp.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/smp.c	2004-03-02 03:01:23.000000000 +0000
@@ -203,10 +203,11 @@ int smp_call_function_on(void (*func) (v
 	put_cpu();
 	return 0;
 }
+EXPORT_SYMBOL(smp_call_function_on);
 
 static inline void do_send_stop(void)
 {
-        u32 dummy;
+        unsigned long dummy;
         int i, rc;
 
         /* stop all processors */
@@ -222,7 +223,7 @@ static inline void do_send_stop(void)
 static inline void do_store_status(void)
 {
         unsigned long low_core_addr;
-        u32 dummy;
+        unsigned long dummy;
         int i, rc;
 
         /* store status of all processors in their lowcores (real 0) */
@@ -619,7 +620,7 @@ void __init smp_prepare_cpus(unsigned in
 		if (lowcore_ptr[i] == NULL || async_stack == 0ULL)
 			panic("smp_boot_cpus failed to allocate memory\n");
 
-                memcpy(lowcore_ptr[i], &S390_lowcore, sizeof(struct _lowcore));
+		*(lowcore_ptr[i]) = S390_lowcore;
 		lowcore_ptr[i]->async_stack = async_stack + (ASYNC_SIZE);
 	}
 	set_prefix((u32)(unsigned long) lowcore_ptr[smp_processor_id()]);
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/kernel/traps.c linux-post-2.6.4rc1-20040302/arch/s390/kernel/traps.c
--- linux-post-2.6.4rc1-20040301/arch/s390/kernel/traps.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/kernel/traps.c	2004-03-02 03:01:23.000000000 +0000
@@ -616,8 +616,6 @@ void __init trap_init(void)
         pgm_check_table[9] = &divide_exception;
         pgm_check_table[0x10] = &do_segment_exception;
         pgm_check_table[0x11] = &do_page_exception;
-        pgm_check_table[0x10] = &do_segment_exception;
-        pgm_check_table[0x11] = &do_page_exception;
         pgm_check_table[0x12] = &translation_exception;
         pgm_check_table[0x13] = &special_op_exception;
 #ifndef CONFIG_ARCH_S390X
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/mm/cmm.c linux-post-2.6.4rc1-20040302/arch/s390/mm/cmm.c
--- linux-post-2.6.4rc1-20040301/arch/s390/mm/cmm.c	2004-02-26 11:21:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/mm/cmm.c	2004-03-02 03:01:23.000000000 +0000
@@ -87,8 +87,7 @@ cmm_alloc_pages(long pages, long *counte
 			pa->index = 0;
 			*list = pa;
 		}
-		if (page < 0x80000000UL)
-			diag10(page);
+		diag10(page);
 		pa->pages[pa->index++] = page;
 		(*counter)++;
 		pages--;
diff -purN linux-post-2.6.4rc1-20040301/arch/s390/mm/init.c linux-post-2.6.4rc1-20040302/arch/s390/mm/init.c
--- linux-post-2.6.4rc1-20040301/arch/s390/mm/init.c	2004-02-26 11:21:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/s390/mm/init.c	2004-03-02 03:01:23.000000000 +0000
@@ -42,9 +42,9 @@ char  empty_zero_page[PAGE_SIZE] __attri
 
 void diag10(unsigned long addr)
 {
-#ifdef __s390x__
-        if (addr >= 0x80000000)
+        if (addr >= 0x7ff00000)
                 return;
+#ifdef __s390x__
         asm volatile ("sam31\n\t"
                       "diag %0,%0,0x10\n\t"
                       "sam64" : : "a" (addr) );
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/adx/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/adx/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/adx/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/adx/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for ADX boards
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o irq.o irq_maskreq.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/bigsur/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/bigsur/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/bigsur/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/bigsur/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the BigSur specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o irq.o led.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/cat68701/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/cat68701/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/cat68701/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/cat68701/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the CAT-68701 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o irq.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/cqreek/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/cqreek/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/cqreek/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/cqreek/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the CqREEK specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o irq.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/dmida/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/dmida/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/dmida/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/dmida/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -2,10 +2,6 @@
 # Makefile for the DataMyte Industrial Digital Assistant(tm) specific parts
 # of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/dreamcast/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/dreamcast/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/dreamcast/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/dreamcast/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the Sega Dreamcast specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o irq.o rtc.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/ec3104/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/ec3104/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/ec3104/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/ec3104/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the EC3104 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o irq.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/harp/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/harp/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/harp/Makefile	2003-03-31 00:51:04.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/harp/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for STMicroelectronics board specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y := irq.o setup.o mach.o led.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp620/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp620/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp620/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp620/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the HP620 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp680/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp680/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp680/Makefile	2004-02-13 15:19:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp680/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the HP680 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o setup.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp690/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp690/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/hp6xx/hp690/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/hp6xx/hp690/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the HP690 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/mpc1211/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/mpc1211/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/mpc1211/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/mpc1211/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the Interface (CTP/PCI/MPC-SH02) specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o rtc.o led.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/overdrive/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/overdrive/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/overdrive/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/overdrive/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the STMicroelectronics Overdrive specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o setup.o io.o irq.o led.o time.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/saturn/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/saturn/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/saturn/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/saturn/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the Sega Saturn specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o irq.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/se/770x/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/se/770x/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/se/770x/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/se/770x/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the 770x SolutionEngine specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o setup.o io.o irq.o led.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/se/7751/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/se/7751/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/se/7751/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/se/7751/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the 7751 SolutionEngine specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o setup.o io.o irq.o led.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/sh2000/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/sh2000/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/sh2000/Makefile	2004-01-19 06:22:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/sh2000/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the SH2000 specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/snapgear/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/snapgear/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/snapgear/Makefile	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/snapgear/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the SnapGear specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o rtc.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/systemh/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/systemh/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/systemh/Makefile	2004-01-19 18:04:57.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/systemh/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the SystemH specific parts of the kernel
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o irq.o io.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/boards/unknown/Makefile linux-post-2.6.4rc1-20040302/arch/sh/boards/unknown/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/boards/unknown/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/boards/unknown/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for unknown SH boards 
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := mach.o io.o setup.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/cchips/hd6446x/hd64461/Makefile linux-post-2.6.4rc1-20040302/arch/sh/cchips/hd6446x/hd64461/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/cchips/hd6446x/hd64461/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/cchips/hd6446x/hd64461/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the HD64461 
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sh/cchips/hd6446x/hd64465/Makefile linux-post-2.6.4rc1-20040302/arch/sh/cchips/hd6446x/hd64465/Makefile
--- linux-post-2.6.4rc1-20040301/arch/sh/cchips/hd6446x/hd64465/Makefile	2003-06-14 18:02:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sh/cchips/hd6446x/hd64465/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,10 +1,6 @@
 #
 # Makefile for the HD64465
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
 
 obj-y	 := setup.o io.o gpio.o
 
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc/kernel/setup.c linux-post-2.6.4rc1-20040302/arch/sparc/kernel/setup.c
--- linux-post-2.6.4rc1-20040301/arch/sparc/kernel/setup.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc/kernel/setup.c	2004-03-01 14:30:54.000000000 +0000
@@ -233,7 +233,6 @@ extern char cputypval;
 extern unsigned long start, end;
 extern void panic_setup(char *, int *);
 extern void srmmu_end_memory(unsigned long, unsigned long *);
-extern void sun_serial_setup(void);
 
 extern unsigned short root_flags;
 extern unsigned short root_dev;
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/Kconfig linux-post-2.6.4rc1-20040302/arch/sparc64/Kconfig
--- linux-post-2.6.4rc1-20040301/arch/sparc64/Kconfig	2004-02-17 00:42:10.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/Kconfig	2004-03-02 03:01:48.000000000 +0000
@@ -450,28 +450,6 @@ config DISPLAY7SEG
 	  another UltraSPARC-IIi-cEngine boardset with a 7-segment display,
 	  you should say N to this option.
 
-config WATCHDOG_CP1XXX
-	tristate "CP1XXX Hardware Watchdog support"
-	depends on PCI
-	---help---
-	  This is the driver for the hardware watchdog timers present on
-	  Sun Microsystems CompactPCI models CP1400 and CP1500.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cpwatchdog.
-
-	  If you do not have a CompactPCI model CP1400 or CP1500, or
-	  another UltraSPARC-IIi-cEngine boardset with hardware watchdog,
-	  you should say N to this option.
-
-config WATCHDOG_RIO
-	tristate "RIO Hardware Watchdog support"
-	depends on PCI
-	help
-	  Say Y here to support the hardware watchdog capability on Sun RIO
-	  machines.  The watchdog timeout period is normally one minute but
-	  can be changed with a boot-time parameter.
-
 config CMDLINE_BOOL
 	bool "Default bootloader kernel arguments"
 
@@ -633,6 +611,15 @@ config DEBUG_KERNEL
 	  Say Y here if you are developing drivers or trying to debug and
 	  identify kernel problems.
 
+config DEBUG_STACK_USAGE
+	bool "Enable stack utilization instrumentation"
+	depends on DEBUG_KERNEL
+	help
+	  Enables the display of the minimum amount of free stack which each
+	  task has ever had available in the sysrq-T and sysrq-P debug output.
+
+	  This option will slow down process creation somewhat.
+
 config DEBUG_SLAB
 	bool "Debug memory allocations"
 	depends on DEBUG_KERNEL
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/defconfig linux-post-2.6.4rc1-20040302/arch/sparc64/defconfig
--- linux-post-2.6.4rc1-20040301/arch/sparc64/defconfig	2004-02-26 22:42:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/defconfig	2004-02-29 05:08:39.000000000 +0000
@@ -905,7 +905,6 @@ CONFIG_IRDA_FAST_RR=y
 #
 # Old SIR device drivers
 #
-# CONFIG_IRPORT_SIR is not set
 
 #
 # Old Serial dongle support
@@ -1657,6 +1656,7 @@ CONFIG_OPROFILE=m
 # Kernel hacking
 #
 CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_STACK_USAGE is not set
 # CONFIG_DEBUG_SLAB is not set
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_DEBUG_SPINLOCK is not set
diff -purN linux-post-2.6.4rc1-20040301/arch/sparc64/mm/init.c linux-post-2.6.4rc1-20040302/arch/sparc64/mm/init.c
--- linux-post-2.6.4rc1-20040301/arch/sparc64/mm/init.c	2004-01-27 21:44:20.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/sparc64/mm/init.c	2004-03-01 14:30:54.000000000 +0000
@@ -1423,7 +1423,6 @@ unsigned long __init bootmem_init(unsign
 
 /* paging_init() sets up the page tables */
 
-extern void sun_serial_setup(void);
 extern void cheetah_ecache_flush_init(void);
 
 static unsigned long last_valid_pfn;
@@ -1548,15 +1547,6 @@ void __init paging_init(void)
 
 	inherit_locked_prom_mappings(1);
 
-#ifdef CONFIG_SUN_SERIAL
-	/* This does not logically belong here, but we need to call it at
-	 * the moment we are able to use the bootmem allocator. This _has_
-	 * to be done after the prom_mappings above so since
-	 * __alloc_bootmem() doesn't work correctly until then.
-	 */
-	sun_serial_setup();
-#endif
-
 	/* We only created DTLB mapping of this stuff. */
 	spitfire_flush_dtlb_nucleus_page(alias_base);
 	if (second_alias_page)
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/Makefile linux-post-2.6.4rc1-20040302/arch/x86_64/Makefile
--- linux-post-2.6.4rc1-20040301/arch/x86_64/Makefile	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/Makefile	2004-03-02 03:01:48.000000000 +0000
@@ -38,7 +38,7 @@ OBJCOPYFLAGS	:= -O binary -R .note -R .c
 LDFLAGS_vmlinux := -e stext
 
 cflags-$(CONFIG_MK8) += $(call check_gcc,-march=k8,)
-cflags-$(CONFIG_MPSC) += $(call check_gcc,-march=pentium4,)
+cflags-$(CONFIG_MPSC) += $(call check_gcc,-march=prescott,)
 CFLAGS += $(cflags-y)
 
 CFLAGS += -mno-red-zone
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/defconfig linux-post-2.6.4rc1-20040302/arch/x86_64/defconfig
--- linux-post-2.6.4rc1-20040301/arch/x86_64/defconfig	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/defconfig	2004-03-02 03:01:48.000000000 +0000
@@ -27,6 +27,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=18
+# CONFIG_HOTPLUG is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 # CONFIG_EMBEDDED is not set
@@ -106,6 +107,7 @@ CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
 # CONFIG_ACPI_RELAXED_AML is not set
+# CONFIG_X86_PM_TIMER is not set
 
 #
 # CPU Frequency scaling
@@ -119,7 +121,6 @@ CONFIG_PCI=y
 CONFIG_PCI_DIRECT=y
 # CONFIG_PCI_LEGACY_PROC is not set
 # CONFIG_PCI_NAMES is not set
-# CONFIG_HOTPLUG is not set
 
 #
 # Executable file formats / Emulations
@@ -168,6 +169,7 @@ CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_SIZE=4096
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_LBD=y
+# CONFIG_DCSSBLK is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -306,7 +308,7 @@ CONFIG_FUSION_MAX_SGE=40
 # CONFIG_FUSION_CTL is not set
 
 #
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+# IEEE 1394 (FireWire) support
 #
 # CONFIG_IEEE1394 is not set
 
@@ -489,7 +491,7 @@ CONFIG_TIGON3=y
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN_BOOL is not set
+# CONFIG_ISDN is not set
 
 #
 # Telephony Support
@@ -562,7 +564,8 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
 
 #
 # Mice
@@ -718,7 +721,6 @@ CONFIG_ISO9660_FS=y
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 # CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
 CONFIG_HUGETLBFS=y
@@ -731,6 +733,7 @@ CONFIG_RAMFS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
@@ -761,7 +764,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/i8259.c linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/i8259.c
--- linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/i8259.c	2004-01-01 05:27:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/i8259.c	2004-03-02 03:01:48.000000000 +0000
@@ -423,7 +423,7 @@ static struct sysdev_class timer_sysclas
 
 static struct sys_device device_timer = {
 	.id		= 0,
-	.cls		&timer_sysclass,
+	.cls		= &timer_sysclass,
 };
 
 static int __init init_timer_sysfs(void)
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/mce.c linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/mce.c
--- linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/mce.c	2004-02-25 17:58:36.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/mce.c	2004-03-02 03:01:48.000000000 +0000
@@ -73,7 +73,9 @@ static void print_mce(struct mce *m)
 	printk("CPU %d: Machine Check Exception: %16Lx Bank %d: %016Lx\n",
 	       m->cpu, m->mcgstatus, m->bank, m->status);
 	if (m->rip) {
-		printk("RIP %02x:<%016Lx> ", m->cs, m->rip);
+		printk("RIP%s %02x:<%016Lx> ",
+		       !(m->mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "",
+		       m->cs, m->rip);
 		if (m->cs == __KERNEL_CS)
 			print_symbol("{%s}", m->rip);
 		printk("\n");
@@ -133,7 +135,7 @@ void do_machine_check(struct pt_regs * r
 		return;
 	if (!(m.mcgstatus & MCG_STATUS_RIPV))
 		kill_it = 1;
-	if (regs && (m.mcgstatus & MCG_STATUS_EIPV)) {
+	if (regs) {
 		m.rip = regs->rip;
 		m.cs = regs->cs;
 	}
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/setup.c linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/setup.c
--- linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/setup.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/setup.c	2004-03-02 03:01:48.000000000 +0000
@@ -610,8 +610,7 @@ static void __init detect_ht(void)
 		 * At this point we only support two siblings per
 		 * processor package.
 		 */
-#define NR_SIBLINGS	2
-		if (smp_num_siblings != NR_SIBLINGS) {
+		if (smp_num_siblings > NR_CPUS) {
 			printk(KERN_WARNING "CPU: Unsupported number of the siblings %d", smp_num_siblings);
 			smp_num_siblings = 1;
 			return;
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/time.c linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/time.c
--- linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/time.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/time.c	2004-03-02 03:01:48.000000000 +0000
@@ -26,6 +26,7 @@
 #include <linux/device.h>
 #include <linux/sysdev.h>
 #include <linux/bcd.h>
+#include <linux/kallsyms.h>
 #include <asm/pgtable.h>
 #include <asm/vsyscall.h>
 #include <asm/timex.h>
@@ -353,11 +354,11 @@ static irqreturn_t timer_interrupt(int i
 	}
 
 	if (lost) {
-		if (report_lost_ticks)
+		if (report_lost_ticks) {
 			printk(KERN_WARNING "time.c: Lost %ld timer "
-			       "tick(s)! (rip %016lx)\n",
-			       (offset - vxtime.last) / hpet_tick - 1,
-			       regs->rip);
+			       "tick(s)! ", lost);
+			print_symbol("rip %s)\n", regs->rip);
+		}
 		jiffies += lost;
 	}
 
@@ -399,8 +400,19 @@ static irqreturn_t timer_interrupt(int i
 	return IRQ_HANDLED;
 }
 
-/* RED-PEN: calculation is done in 32bits with multiply for performance
-   and could overflow, it may be better (but slower)to use an 64bit division. */
+static unsigned int cyc2ns_scale;
+#define CYC2NS_SCALE_FACTOR 10 /* 2^10, carefully chosen */
+
+static inline void set_cyc2ns_scale(unsigned long cpu_mhz)
+{
+	cyc2ns_scale = (1000 << CYC2NS_SCALE_FACTOR)/cpu_mhz;
+}
+
+static inline unsigned long long cycles_2_ns(unsigned long long cyc)
+{
+	return (cyc * cyc2ns_scale) >> CYC2NS_SCALE_FACTOR;
+}
+
 unsigned long long sched_clock(void)
 {
 	unsigned long a = 0;
@@ -420,7 +432,7 @@ unsigned long long sched_clock(void)
 	   purposes. */
 
 	rdtscll(a);
-	return (a * vxtime.tsc_quot) >> 32;
+	return cycles_2_ns(a);
 }
 
 unsigned long get_cmos_time(void)
@@ -527,6 +539,8 @@ static int time_cpufreq_notifier(struct 
 		vxtime.tsc_quot = (1000L << 32) / cpu_khz;
 	}
 	
+	set_cyc2ns_scale(cpu_khz_ref / 1000);
+
 	return 0;
 }
  
@@ -725,6 +739,8 @@ void __init time_init(void)
 	rdtscll_sync(&vxtime.last_tsc);
 	setup_irq(0, &irq0);
 
+	set_cyc2ns_scale(cpu_khz / 1000);
+
 #ifdef CONFIG_CPU_FREQ
 	cpufreq_register_notifier(&time_cpufreq_notifier_block, 
 				  CPUFREQ_TRANSITION_NOTIFIER);
diff -purN linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/traps.c linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/traps.c
--- linux-post-2.6.4rc1-20040301/arch/x86_64/kernel/traps.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/traps.c	2004-03-02 03:01:48.000000000 +0000
@@ -351,9 +351,24 @@ void oops_end(void)
 
 void __die(const char * str, struct pt_regs * regs, long err)
 {
+	int nl = 0;
 	static int die_counter;
 	printk(KERN_EMERG "%s: %04lx [%u]\n", str, err & 0xffff,++die_counter);
 	notify_die(DIE_OOPS, (char *)str, regs, err, 255, SIGSEGV);
+#ifdef CONFIG_PREEMPT
+	printk("PREEMPT ");
+	nl = 1;
+#endif
+#ifdef CONFIG_SMP
+	printk("SMP ");
+	nl = 1;
+#endif
+#ifdef CONFIG_DEBUG_PAGEALLOC
+	printk("DEBUG_PAGEALLOC");
+	nl = 1;
+#endif
+	if (nl)
+		printk("\n");
 	show_registers(regs);
 	/* Executive summary in case the oops scrolled away */
 	printk("RIP "); 
diff -purN linux-post-2.6.4rc1-20040301/crypto/Makefile linux-post-2.6.4rc1-20040302/crypto/Makefile
--- linux-post-2.6.4rc1-20040301/crypto/Makefile	2003-09-05 06:02:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/crypto/Makefile	2004-03-02 03:01:26.000000000 +0000
@@ -4,7 +4,7 @@
 
 proc-crypto-$(CONFIG_PROC_FS) = proc.o
 
-obj-$(CONFIG_CRYPTO) += api.o cipher.o digest.o compress.o \
+obj-$(CONFIG_CRYPTO) += api.o scatterwalk.o cipher.o digest.o compress.o \
 			$(proc-crypto-y)
 
 obj-$(CONFIG_CRYPTO_HMAC) += hmac.o
diff -purN linux-post-2.6.4rc1-20040301/crypto/cipher.c linux-post-2.6.4rc1-20040302/crypto/cipher.c
--- linux-post-2.6.4rc1-20040301/crypto/cipher.c	2003-08-18 11:03:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/crypto/cipher.c	2004-03-02 03:01:26.000000000 +0000
@@ -4,7 +4,6 @@
  * Cipher operations.
  *
  * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
- * Generic scatterwalk code by Adam J. Richter <adam@yggdrasil.com>.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -17,30 +16,13 @@
 #include <linux/errno.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/pagemap.h>
-#include <linux/highmem.h>
 #include <asm/scatterlist.h>
 #include "internal.h"
+#include "scatterwalk.h"
 
 typedef void (cryptfn_t)(void *, u8 *, const u8 *);
 typedef void (procfn_t)(struct crypto_tfm *, u8 *,
-                        u8*, cryptfn_t, int enc, void *);
-
-struct scatter_walk {
-	struct scatterlist	*sg;
-	struct page		*page;
-	void			*data;
-	unsigned int		len_this_page;
-	unsigned int		len_this_segment;
-	unsigned int		offset;
-};
-
-enum km_type crypto_km_types[] = {
-	KM_USER0,
-	KM_USER1,
-	KM_SOFTIRQ0,
-	KM_SOFTIRQ1,
-};
+                        u8*, cryptfn_t, int enc, void *, int);
 
 static inline void xor_64(u8 *a, const u8 *b)
 {
@@ -57,108 +39,6 @@ static inline void xor_128(u8 *a, const 
 }
 
 
-/* Define sg_next is an inline routine now in case we want to change
-   scatterlist to a linked list later. */
-static inline struct scatterlist *sg_next(struct scatterlist *sg)
-{
-	return sg + 1;
-}
-
-void *which_buf(struct scatter_walk *walk, unsigned int nbytes, void *scratch)
-{
-	if (nbytes <= walk->len_this_page &&
-	    (((unsigned long)walk->data) & (PAGE_CACHE_SIZE - 1)) + nbytes <=
-	    PAGE_CACHE_SIZE)
-		return walk->data;
-	else
-		return scratch;
-}
-
-static void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)
-{
-	if (out)
-		memcpy(sgdata, buf, nbytes);
-	else
-		memcpy(buf, sgdata, nbytes);
-}
-
-static void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg)
-{
-	unsigned int rest_of_page;
-
-	walk->sg = sg;
-
-	walk->page = sg->page;
-	walk->len_this_segment = sg->length;
-
-	rest_of_page = PAGE_CACHE_SIZE - (sg->offset & (PAGE_CACHE_SIZE - 1));
-	walk->len_this_page = min(sg->length, rest_of_page);
-	walk->offset = sg->offset;
-}
-
-static void scatterwalk_map(struct scatter_walk *walk, int out)
-{
-	walk->data = crypto_kmap(walk->page, out) + walk->offset;
-}
-
-static void scatter_page_done(struct scatter_walk *walk, int out,
-			      unsigned int more)
-{
-	/* walk->data may be pointing the first byte of the next page;
-	   however, we know we transfered at least one byte.  So,
-	   walk->data - 1 will be a virutual address in the mapped page. */
-
-	if (out)
-		flush_dcache_page(walk->page);
-
-	if (more) {
-		walk->len_this_segment -= walk->len_this_page;
-
-		if (walk->len_this_segment) {
-			walk->page++;
-			walk->len_this_page = min(walk->len_this_segment,
-						  (unsigned)PAGE_CACHE_SIZE);
-			walk->offset = 0;
-		}
-		else
-			scatterwalk_start(walk, sg_next(walk->sg));
-	}
-}
-
-static void scatter_done(struct scatter_walk *walk, int out, int more)
-{
-	crypto_kunmap(walk->data, out);
-	if (walk->len_this_page == 0 || !more)
-		scatter_page_done(walk, out, more);
-}
-
-/*
- * Do not call this unless the total length of all of the fragments 
- * has been verified as multiple of the block size.
- */
-static int copy_chunks(void *buf, struct scatter_walk *walk,
-			size_t nbytes, int out)
-{
-	if (buf != walk->data) {
-		while (nbytes > walk->len_this_page) {
-			memcpy_dir(buf, walk->data, walk->len_this_page, out);
-			buf += walk->len_this_page;
-			nbytes -= walk->len_this_page;
-
-			crypto_kunmap(walk->data, out);
-			scatter_page_done(walk, out, 1);
-			scatterwalk_map(walk, out);
-		}
-
-		memcpy_dir(buf, walk->data, nbytes, out);
-	}
-
-	walk->offset += nbytes;
-	walk->len_this_page -= nbytes;
-	walk->len_this_segment -= nbytes;
-	return 0;
-}
-
 /* 
  * Generic encrypt/decrypt wrapper for ciphers, handles operations across
  * multiple page boundaries by using temporary blocks.  In user context,
@@ -191,19 +71,21 @@ static int crypt(struct crypto_tfm *tfm,
 
 		scatterwalk_map(&walk_in, 0);
 		scatterwalk_map(&walk_out, 1);
-		src_p = which_buf(&walk_in, bsize, tmp_src);
-		dst_p = which_buf(&walk_out, bsize, tmp_dst);
+		src_p = scatterwalk_whichbuf(&walk_in, bsize, tmp_src);
+		dst_p = scatterwalk_whichbuf(&walk_out, bsize, tmp_dst);
 
 		nbytes -= bsize;
 
-		copy_chunks(src_p, &walk_in, bsize, 0);
+		scatterwalk_copychunks(src_p, &walk_in, bsize, 0);
 
-		prfn(tfm, dst_p, src_p, crfn, enc, info);
+		prfn(tfm, dst_p, src_p, crfn, enc, info,
+		     scatterwalk_samebuf(&walk_in, &walk_out,
+					 src_p, dst_p));
 
-		scatter_done(&walk_in, 0, nbytes);
+		scatterwalk_done(&walk_in, 0, nbytes);
 
-		copy_chunks(dst_p, &walk_out, bsize, 1);
-		scatter_done(&walk_out, 1, nbytes);
+		scatterwalk_copychunks(dst_p, &walk_out, bsize, 1);
+		scatterwalk_done(&walk_out, 1, nbytes);
 
 		if (!nbytes)
 			return 0;
@@ -212,8 +94,8 @@ static int crypt(struct crypto_tfm *tfm,
 	}
 }
 
-static void cbc_process(struct crypto_tfm *tfm,
-                        u8 *dst, u8 *src, cryptfn_t fn, int enc, void *info)
+static void cbc_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,
+			cryptfn_t fn, int enc, void *info, int in_place)
 {
 	u8 *iv = info;
 	
@@ -226,10 +108,9 @@ static void cbc_process(struct crypto_tf
 		fn(crypto_tfm_ctx(tfm), dst, iv);
 		memcpy(iv, dst, crypto_tfm_alg_blocksize(tfm));
 	} else {
-		const int need_stack = (src == dst);
-		u8 stack[need_stack ? crypto_tfm_alg_blocksize(tfm) : 0];
-		u8 *buf = need_stack ? stack : dst;
-		
+		u8 stack[in_place ? crypto_tfm_alg_blocksize(tfm) : 0];
+		u8 *buf = in_place ? stack : dst;
+
 		fn(crypto_tfm_ctx(tfm), buf, src);
 		tfm->crt_u.cipher.cit_xor_block(buf, iv);
 		memcpy(iv, src, crypto_tfm_alg_blocksize(tfm));
@@ -239,7 +120,7 @@ static void cbc_process(struct crypto_tf
 }
 
 static void ecb_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,
-                        cryptfn_t fn, int enc, void *info)
+			cryptfn_t fn, int enc, void *info, int in_place)
 {
 	fn(crypto_tfm_ctx(tfm), dst, src);
 }
diff -purN linux-post-2.6.4rc1-20040301/crypto/internal.h linux-post-2.6.4rc1-20040302/crypto/internal.h
--- linux-post-2.6.4rc1-20040301/crypto/internal.h	2003-09-05 06:02:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/crypto/internal.h	2004-03-02 03:01:26.000000000 +0000
@@ -11,6 +11,7 @@
  */
 #ifndef _CRYPTO_INTERNAL_H
 #define _CRYPTO_INTERNAL_H
+#include <linux/crypto.h>
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <linux/interrupt.h>
diff -purN linux-post-2.6.4rc1-20040301/crypto/scatterwalk.c linux-post-2.6.4rc1-20040302/crypto/scatterwalk.c
--- linux-post-2.6.4rc1-20040301/crypto/scatterwalk.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/crypto/scatterwalk.c	2004-03-02 03:01:26.000000000 +0000
@@ -0,0 +1,124 @@
+/*
+ * Cryptographic API.
+ *
+ * Cipher operations.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ *               2002 Adam J. Richter <adam@yggdrasil.com>
+ *               2004 Jean-Luc Cooke <jlcooke@certainkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <asm/scatterlist.h>
+#include "internal.h"
+#include "scatterwalk.h"
+
+enum km_type crypto_km_types[] = {
+	KM_USER0,
+	KM_USER1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+};
+
+void *scatterwalk_whichbuf(struct scatter_walk *walk, unsigned int nbytes, void *scratch)
+{
+	if (nbytes <= walk->len_this_page &&
+	    (((unsigned long)walk->data) & (PAGE_CACHE_SIZE - 1)) + nbytes <=
+	    PAGE_CACHE_SIZE)
+		return walk->data;
+	else
+		return scratch;
+}
+
+static void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)
+{
+	if (out)
+		memcpy(sgdata, buf, nbytes);
+	else
+		memcpy(buf, sgdata, nbytes);
+}
+
+void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg)
+{
+	unsigned int rest_of_page;
+
+	walk->sg = sg;
+
+	walk->page = sg->page;
+	walk->len_this_segment = sg->length;
+
+	rest_of_page = PAGE_CACHE_SIZE - (sg->offset & (PAGE_CACHE_SIZE - 1));
+	walk->len_this_page = min(sg->length, rest_of_page);
+	walk->offset = sg->offset;
+}
+
+void scatterwalk_map(struct scatter_walk *walk, int out)
+{
+	walk->data = crypto_kmap(walk->page, out) + walk->offset;
+}
+
+static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
+				 unsigned int more)
+{
+	/* walk->data may be pointing the first byte of the next page;
+	   however, we know we transfered at least one byte.  So,
+	   walk->data - 1 will be a virutual address in the mapped page. */
+
+	if (out)
+		flush_dcache_page(walk->page);
+
+	if (more) {
+		walk->len_this_segment -= walk->len_this_page;
+
+		if (walk->len_this_segment) {
+			walk->page++;
+			walk->len_this_page = min(walk->len_this_segment,
+						  (unsigned)PAGE_CACHE_SIZE);
+			walk->offset = 0;
+		}
+		else
+			scatterwalk_start(walk, sg_next(walk->sg));
+	}
+}
+
+void scatterwalk_done(struct scatter_walk *walk, int out, int more)
+{
+	crypto_kunmap(walk->data, out);
+	if (walk->len_this_page == 0 || !more)
+		scatterwalk_pagedone(walk, out, more);
+}
+
+/*
+ * Do not call this unless the total length of all of the fragments
+ * has been verified as multiple of the block size.
+ */
+int scatterwalk_copychunks(void *buf, struct scatter_walk *walk,
+			   size_t nbytes, int out)
+{
+	if (buf != walk->data) {
+		while (nbytes > walk->len_this_page) {
+			memcpy_dir(buf, walk->data, walk->len_this_page, out);
+			buf += walk->len_this_page;
+			nbytes -= walk->len_this_page;
+
+			crypto_kunmap(walk->data, out);
+			scatterwalk_pagedone(walk, out, 1);
+			scatterwalk_map(walk, out);
+		}
+
+		memcpy_dir(buf, walk->data, nbytes, out);
+	}
+
+	walk->offset += nbytes;
+	walk->len_this_page -= nbytes;
+	walk->len_this_segment -= nbytes;
+	return 0;
+}
diff -purN linux-post-2.6.4rc1-20040301/crypto/scatterwalk.h linux-post-2.6.4rc1-20040302/crypto/scatterwalk.h
--- linux-post-2.6.4rc1-20040301/crypto/scatterwalk.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/crypto/scatterwalk.h	2004-03-02 03:01:26.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+ * Cryptographic API.
+ *
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * Copyright (c) 2002 Adam J. Richter <adam@yggdrasil.com>
+ * Copyright (c) 2004 Jean-Luc Cooke <jlcooke@certainkey.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _CRYPTO_SCATTERWALK_H
+#define _CRYPTO_SCATTERWALK_H
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+
+struct scatter_walk {
+	struct scatterlist	*sg;
+	struct page		*page;
+	void			*data;
+	unsigned int		len_this_page;
+	unsigned int		len_this_segment;
+	unsigned int		offset;
+};
+
+/* Define sg_next is an inline routine now in case we want to change
+   scatterlist to a linked list later. */
+static inline struct scatterlist *sg_next(struct scatterlist *sg)
+{
+	return sg + 1;
+}
+
+static inline int scatterwalk_samebuf(struct scatter_walk *walk_in,
+				      struct scatter_walk *walk_out,
+				      void *src_p, void *dst_p)
+{
+	return walk_in->page == walk_out->page &&
+	       walk_in->data == src_p && walk_out->data == dst_p;
+}
+
+void *scatterwalk_whichbuf(struct scatter_walk *walk, unsigned int nbytes, void *scratch);
+void scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg);
+int scatterwalk_copychunks(void *buf, struct scatter_walk *walk, size_t nbytes, int out);
+void scatterwalk_map(struct scatter_walk *walk, int out);
+void scatterwalk_done(struct scatter_walk *walk, int out, int more);
+
+#endif  /* _CRYPTO_SCATTERWALK_H */
diff -purN linux-post-2.6.4rc1-20040301/drivers/base/firmware_class.c linux-post-2.6.4rc1-20040302/drivers/base/firmware_class.c
--- linux-post-2.6.4rc1-20040301/drivers/base/firmware_class.c	2004-02-26 11:26:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/base/firmware_class.c	2004-03-02 03:01:49.000000000 +0000
@@ -27,6 +27,7 @@ enum {
 	FW_STATUS_LOADING,
 	FW_STATUS_DONE,
 	FW_STATUS_ABORT,
+	FW_STATUS_READY,
 };
 
 static int loading_timeout = 10;	/* In seconds */
@@ -96,6 +97,9 @@ firmware_class_hotplug(struct class_devi
 	int i = 0;
 	char *scratch = buffer;
 
+	if (!test_bit(FW_STATUS_READY, &fw_priv->status))
+		return -ENODEV;
+
 	if (buffer_size < (FIRMWARE_NAME_MAX + 10))
 		return -ENOMEM;
 	if (num_envp < 1)
@@ -263,6 +267,8 @@ fw_class_dev_release(struct class_device
 
 	kfree(fw_priv);
 	kfree(class_dev);
+
+	module_put(THIS_MODULE);
 }
 
 static void
@@ -325,6 +331,7 @@ error_kfree:
 	kfree(class_dev);
 	return retval;
 }
+
 static int
 fw_setup_class_device(struct firmware *fw, struct class_device **class_dev_p,
 		      const char *fw_name, struct device *device)
@@ -338,6 +345,9 @@ fw_setup_class_device(struct firmware *f
 	if (retval)
 		goto out;
 
+	/* Need to pin this module until class device is destroyed */
+	__module_get(THIS_MODULE);
+
 	fw_priv = class_get_devdata(class_dev);
 
 	fw_priv->fw = fw;
@@ -356,6 +366,7 @@ fw_setup_class_device(struct firmware *f
 		goto error_unreg;
 	}
 
+	set_bit(FW_STATUS_READY, &fw_priv->status);
 	*class_dev_p = class_dev;
 	goto out;
 
@@ -409,6 +420,7 @@ request_firmware(const struct firmware *
 		add_timer(&fw_priv->timeout);
 	}
 
+	kobject_hotplug("add", &class_dev->kobj);
 	wait_for_completion(&fw_priv->completion);
 	set_bit(FW_STATUS_DONE, &fw_priv->status);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/block/viodasd.c linux-post-2.6.4rc1-20040302/drivers/block/viodasd.c
--- linux-post-2.6.4rc1-20040301/drivers/block/viodasd.c	2004-02-27 05:25:15.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/block/viodasd.c	2004-03-02 03:01:22.000000000 +0000
@@ -70,7 +70,6 @@ enum {
 	MAX_DISK_NAME = sizeof(((struct gendisk *)0)->disk_name)
 };
 
-static int		viodasd_max_disk;
 static spinlock_t	viodasd_spinlock = SPIN_LOCK_UNLOCKED;
 
 #define VIOMAXREQ		16
@@ -209,7 +208,6 @@ static int viodasd_open(struct inode *in
 				(int)we.rc, we.sub_result, err->msg);
 		return -EIO;
 	}
-	viodasd_max_disk = we.max_disk;
 
 	return 0;
 }
@@ -483,7 +481,17 @@ static void probe_disk(struct viodasd_de
 
 	if (we.rc != 0)
 		return;
-	viodasd_max_disk = we.max_disk;
+	if (we.max_disk > (MAX_DISKNO - 1)) {
+		static int warned;
+
+		if (warned == 0) {
+			warned++;
+			printk(VIOD_KERN_INFO
+				"Only examining the first %d "
+				"of %d disks connected\n",
+				MAX_DISKNO, we.max_disk + 1);
+		}
+	}
 
 	/* Send the close event to OS/400.  We DON'T expect a response */
 	hvrc = HvCallEvent_signalLpEventFast(viopath_hostLp,
@@ -744,21 +752,8 @@ static int __init viodasd_init(void)
 	/* Initialize our request handler */
 	vio_setHandler(viomajorsubtype_blockio, handle_block_event);
 
-	viodasd_max_disk = MAX_DISKNO - 1;
-	for (i = 0; (i <= viodasd_max_disk) && (i < MAX_DISKNO); i++) {
-		/*
-		 * Note that probe_disk has side effects:
-		 *  a) it updates the size of the disk
-		 *  b) it updates viodasd_max_disk
-		 *  c) it registers the disk if it has not done so already
-		 */
+	for (i = 0; i < MAX_DISKNO; i++)
 		probe_disk(&viodasd_devices[i]);
-	}
-
-	if (viodasd_max_disk > (MAX_DISKNO - 1))
-		printk(VIOD_KERN_INFO
-			"Only examining the first %d of %d disks connected\n",
-			MAX_DISKNO, viodasd_max_disk + 1);
 
 	return 0;
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/bluetooth/bluecard_cs.c linux-post-2.6.4rc1-20040302/drivers/bluetooth/bluecard_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/bluetooth/bluecard_cs.c	2004-02-25 23:53:53.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/bluetooth/bluecard_cs.c	2004-02-28 23:53:36.000000000 +0000
@@ -226,7 +226,7 @@ static int bluecard_write(unsigned int i
 static void bluecard_write_wakeup(bluecard_info_t *info)
 {
 	if (!info) {
-		printk(KERN_WARNING "bluecard_cs: Call of write_wakeup for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -379,7 +379,7 @@ static void bluecard_receive(bluecard_in
 	int i, len;
 
 	if (!info) {
-		printk(KERN_WARNING "bluecard_cs: Call of receive for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -397,7 +397,7 @@ static void bluecard_receive(bluecard_in
 			info->rx_state = RECV_WAIT_PACKET_TYPE;
 			info->rx_count = 0;
 			if (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {
-				printk(KERN_WARNING "bluecard_cs: Can't allocate mem for new packet.\n");
+				BT_ERR("Can't allocate mem for new packet");
 				return;
 			}
 		}
@@ -439,7 +439,7 @@ static void bluecard_receive(bluecard_in
 
 			default:
 				/* unknown packet */
-				printk(KERN_WARNING "bluecard_cs: Unknown HCI packet with type 0x%02x received.\n", info->rx_skb->pkt_type);
+				BT_ERR("Unknown HCI packet with type 0x%02x received", info->rx_skb->pkt_type);
 				info->hdev->stat.err_rx++;
 
 				kfree_skb(info->rx_skb);
@@ -506,7 +506,7 @@ static irqreturn_t bluecard_interrupt(in
 	unsigned char reg;
 
 	if (!info) {
-		printk(KERN_WARNING "bluecard_cs: Call of irq %d for unknown device.\n", irq);
+		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
@@ -574,7 +574,7 @@ static int bluecard_hci_set_baud_rate(st
 	unsigned char cmd[] = { HCI_COMMAND_PKT, 0x09, 0xfc, 0x01, 0x03 };
 
 	if (!(skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {
-		printk(KERN_WARNING "bluecard_cs: Can't allocate mem for new packet.\n");
+		BT_ERR("Can't allocate mem for new packet");
 		return -1;
 	}
 
@@ -664,7 +664,7 @@ static int bluecard_hci_send_frame(struc
 	struct hci_dev *hdev = (struct hci_dev *)(skb->dev);
 
 	if (!hdev) {
-		printk(KERN_WARNING "bluecard_cs: Frame for unknown HCI device (hdev=NULL).");
+		BT_ERR("Frame for unknown HCI device (hdev=NULL)");
 		return -ENODEV;
 	}
 
@@ -780,7 +780,7 @@ int bluecard_open(bluecard_info_t *info)
 	/* Initialize and register HCI device */
 	hdev = hci_alloc_dev();
 	if (!hdev) {
-		printk(KERN_WARNING "bluecard_cs: Can't allocate HCI device.\n");
+		BT_ERR("Can't allocate HCI device");
 		return -ENOMEM;
 	}
 
@@ -799,7 +799,7 @@ int bluecard_open(bluecard_info_t *info)
 	hdev->owner = THIS_MODULE;
 	
 	if (hci_register_dev(hdev) < 0) {
-		printk(KERN_WARNING "bluecard_cs: Can't register HCI device.\n");
+		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -825,7 +825,7 @@ int bluecard_close(bluecard_info_t *info
 	outb(0x80, iobase + 0x30);
 
 	if (hci_unregister_dev(hdev) < 0)
-		printk(KERN_WARNING "bluecard_cs: Can't unregister HCI device %s.\n", hdev->name);
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
 
 	hci_free_dev(hdev);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/bluetooth/bt3c_cs.c linux-post-2.6.4rc1-20040302/drivers/bluetooth/bt3c_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/bluetooth/bt3c_cs.c	2004-02-25 23:53:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/bluetooth/bt3c_cs.c	2004-02-28 23:53:38.000000000 +0000
@@ -195,7 +195,7 @@ static void bt3c_write_wakeup(bt3c_info_
 	unsigned long flags;
 
 	if (!info) {
-		printk(KERN_WARNING "bt3c_cs: Call of write_wakeup for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -222,7 +222,7 @@ static void bt3c_write_wakeup(bt3c_info_
 		len = bt3c_write(iobase, 256, skb->data, skb->len);
 
 		if (len != skb->len) {
-			printk(KERN_WARNING "bt3c_cs: very strange\n");
+			BT_ERR("Very strange");
 		}
 
 		kfree_skb(skb);
@@ -241,7 +241,7 @@ static void bt3c_receive(bt3c_info_t *in
 	int size = 0, avail;
 
 	if (!info) {
-		printk(KERN_WARNING "bt3c_cs: Call of receive for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -260,7 +260,7 @@ static void bt3c_receive(bt3c_info_t *in
 			info->rx_state = RECV_WAIT_PACKET_TYPE;
 			info->rx_count = 0;
 			if (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {
-				printk(KERN_WARNING "bt3c_cs: Can't allocate mem for new packet.\n");
+				BT_ERR("Can't allocate mem for new packet");
 				return;
 			}
 		}
@@ -292,7 +292,7 @@ static void bt3c_receive(bt3c_info_t *in
 
 			default:
 				/* Unknown packet */
-				printk(KERN_WARNING "bt3c_cs: Unknown HCI packet with type 0x%02x received.\n", info->rx_skb->pkt_type);
+				BT_ERR("Unknown HCI packet with type 0x%02x received", info->rx_skb->pkt_type);
 				info->hdev->stat.err_rx++;
 				clear_bit(HCI_RUNNING, &(info->hdev->flags));
 
@@ -362,7 +362,7 @@ static irqreturn_t bt3c_interrupt(int ir
 	int iir;
 
 	if (!info) {
-		printk(KERN_WARNING "bt3c_cs: Call of irq %d for unknown device.\n", irq);
+		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
@@ -375,16 +375,16 @@ static irqreturn_t bt3c_interrupt(int ir
 		int stat = bt3c_read(iobase, 0x7001);
 
 		if ((stat & 0xff) == 0x7f) {
-			printk(KERN_WARNING "bt3c_cs: STRANGE stat=%04x\n", stat);
+			BT_ERR("Very strange (stat=0x%04x)", stat);
 		} else if ((stat & 0xff) != 0xff) {
 			if (stat & 0x0020) {
 				int stat = bt3c_read(iobase, 0x7002) & 0x10;
-				printk(KERN_WARNING "bt3c_cs: antena %s\n", stat ? "OUT" : "IN");
+				BT_ERR("Antenna %s", stat ? "out" : "in");
 			}
 			if (stat & 0x0001)
 				bt3c_receive(info);
 			if (stat & 0x0002) {
-				//printk("bt3c_cs: ACK %04x\n", stat);
+				//BT_ERR("Ack (stat=0x%04x)", stat);
 				clear_bit(XMIT_SENDING, &(info->tx_state));
 				bt3c_write_wakeup(info, 1);
 			}
@@ -441,7 +441,7 @@ static int bt3c_hci_send_frame(struct sk
 	struct hci_dev *hdev = (struct hci_dev *)(skb->dev);
 
 	if (!hdev) {
-		printk(KERN_WARNING "bt3c_cs: Frame for unknown HCI device (hdev=NULL).");
+		BT_ERR("Frame for unknown HCI device (hdev=NULL)");
 		return -ENODEV;
 	}
 
@@ -499,7 +499,7 @@ static int bt3c_firmware_load(bt3c_info_
 
 	err = call_usermodehelper(FW_LOADER, argv, envp, 1);
 	if (err)
-		printk(KERN_WARNING "bt3c_cs: Failed to run \"%s pccard %s\" (errno=%d).\n", FW_LOADER, dev, err);
+		BT_ERR("Failed to run \"%s pccard %s\" (errno=%d)", FW_LOADER, dev, err);
 
 	return err;
 }
@@ -536,7 +536,7 @@ int bt3c_open(bt3c_info_t *info)
 	/* Initialize and register HCI device */
 	hdev = hci_alloc_dev();
 	if (!hdev) {
-		printk(KERN_WARNING "bt3c_cs: Can't allocate HCI device.\n");
+		BT_ERR("Can't allocate HCI device");
 		return -ENOMEM;
 	}
 
@@ -555,7 +555,7 @@ int bt3c_open(bt3c_info_t *info)
 	hdev->owner = THIS_MODULE;
 	
 	if (hci_register_dev(hdev) < 0) {
-		printk(KERN_WARNING "bt3c_cs: Can't register HCI device.\n");
+		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -571,7 +571,7 @@ int bt3c_close(bt3c_info_t *info)
 	bt3c_hci_close(hdev);
 
 	if (hci_unregister_dev(hdev) < 0)
-		printk(KERN_WARNING "bt3c_cs: Can't unregister HCI device %s.\n", hdev->name);
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
 
 	hci_free_dev(hdev);
 
@@ -769,7 +769,7 @@ next_entry:
 
 found_port:
 	if (i != CS_SUCCESS) {
-		printk(KERN_NOTICE "bt3c_cs: No usable port range found. Giving up.\n");
+		BT_ERR("No usable port range found");
 		cs_error(link->handle, RequestIO, i);
 		goto failed;
 	}
diff -purN linux-post-2.6.4rc1-20040301/drivers/bluetooth/btuart_cs.c linux-post-2.6.4rc1-20040302/drivers/bluetooth/btuart_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/bluetooth/btuart_cs.c	2004-02-25 23:54:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/bluetooth/btuart_cs.c	2004-02-28 23:53:39.000000000 +0000
@@ -148,7 +148,7 @@ static int btuart_write(unsigned int iob
 static void btuart_write_wakeup(btuart_info_t *info)
 {
 	if (!info) {
-		printk(KERN_WARNING "btuart_cs: Call of write_wakeup for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -195,7 +195,7 @@ static void btuart_receive(btuart_info_t
 	int boguscount = 0;
 
 	if (!info) {
-		printk(KERN_WARNING "btuart_cs: Call of receive for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -209,7 +209,7 @@ static void btuart_receive(btuart_info_t
 			info->rx_state = RECV_WAIT_PACKET_TYPE;
 			info->rx_count = 0;
 			if (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {
-				printk(KERN_WARNING "btuart_cs: Can't allocate mem for new packet.\n");
+				BT_ERR("Can't allocate mem for new packet");
 				return;
 			}
 		}
@@ -238,7 +238,7 @@ static void btuart_receive(btuart_info_t
 
 			default:
 				/* Unknown packet */
-				printk(KERN_WARNING "btuart_cs: Unknown HCI packet with type 0x%02x received.\n", info->rx_skb->pkt_type);
+				BT_ERR("Unknown HCI packet with type 0x%02x received", info->rx_skb->pkt_type);
 				info->hdev->stat.err_rx++;
 				clear_bit(HCI_RUNNING, &(info->hdev->flags));
 
@@ -309,7 +309,7 @@ static irqreturn_t btuart_interrupt(int 
 	int iir, lsr;
 
 	if (!info) {
-		printk(KERN_WARNING "btuart_cs: Call of irq %d for unknown device.\n", irq);
+		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
@@ -325,7 +325,7 @@ static irqreturn_t btuart_interrupt(int 
 
 		switch (iir) {
 		case UART_IIR_RLSI:
-			printk(KERN_NOTICE "btuart_cs: RLSI\n");
+			BT_ERR("RLSI");
 			break;
 		case UART_IIR_RDI:
 			/* Receive interrupt */
@@ -338,7 +338,7 @@ static irqreturn_t btuart_interrupt(int 
 			}
 			break;
 		default:
-			printk(KERN_NOTICE "btuart_cs: Unhandled IIR=%#x\n", iir);
+			BT_ERR("Unhandled IIR=%#x", iir);
 			break;
 		}
 
@@ -365,7 +365,7 @@ static void btuart_change_speed(btuart_i
 	int divisor;
 
 	if (!info) {
-		printk(KERN_WARNING "btuart_cs: Call of change speed for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -447,7 +447,7 @@ static int btuart_hci_send_frame(struct 
 	struct hci_dev *hdev = (struct hci_dev *)(skb->dev);
 
 	if (!hdev) {
-		printk(KERN_WARNING "btuart_cs: Frame for unknown HCI device (hdev=NULL).");
+		BT_ERR("Frame for unknown HCI device (hdev=NULL)");
 		return -ENODEV;
 	}
 
@@ -531,7 +531,7 @@ int btuart_open(btuart_info_t *info)
 	/* Initialize and register HCI device */
 	hdev = hci_alloc_dev();
 	if (!hdev) {
-		printk(KERN_WARNING "btuart_cs: Can't allocate HCI device.\n");
+		BT_ERR("Can't allocate HCI device");
 		return -ENOMEM;
 	}
 
@@ -550,7 +550,7 @@ int btuart_open(btuart_info_t *info)
 	hdev->owner = THIS_MODULE;
 	
 	if (hci_register_dev(hdev) < 0) {
-		printk(KERN_WARNING "btuart_cs: Can't register HCI device.\n");
+		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -578,7 +578,7 @@ int btuart_close(btuart_info_t *info)
 	spin_unlock_irqrestore(&(info->lock), flags);
 
 	if (hci_unregister_dev(hdev) < 0)
-		printk(KERN_WARNING "btuart_cs: Can't unregister HCI device %s.\n", hdev->name);
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
 
 	hci_free_dev(hdev);
 
@@ -777,7 +777,7 @@ next_entry:
 
 found_port:
 	if (i != CS_SUCCESS) {
-		printk(KERN_NOTICE "btuart_cs: No usable port range found. Giving up.\n");
+		BT_ERR("No usable port range found");
 		cs_error(link->handle, RequestIO, i);
 		goto failed;
 	}
diff -purN linux-post-2.6.4rc1-20040301/drivers/bluetooth/dtl1_cs.c linux-post-2.6.4rc1-20040302/drivers/bluetooth/dtl1_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/bluetooth/dtl1_cs.c	2004-02-25 23:53:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/bluetooth/dtl1_cs.c	2004-02-28 23:53:06.000000000 +0000
@@ -150,7 +150,7 @@ static int dtl1_write(unsigned int iobas
 static void dtl1_write_wakeup(dtl1_info_t *info)
 {
 	if (!info) {
-		printk(KERN_WARNING "dtl1_cs: Call of write_wakeup for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -201,9 +201,9 @@ static void dtl1_control(dtl1_info_t *in
 	u8 flowmask = *(u8 *)skb->data;
 	int i;
 
-	printk(KERN_INFO "dtl1_cs: Nokia control data = ");
+	printk(KERN_INFO "Bluetooth: Nokia control data =");
 	for (i = 0; i < skb->len; i++) {
-		printk("%02x ", skb->data[i]);
+		printk(" %02x", skb->data[i]);
 	}
 	printk("\n");
 
@@ -226,7 +226,7 @@ static void dtl1_receive(dtl1_info_t *in
 	int boguscount = 0;
 
 	if (!info) {
-		printk(KERN_WARNING "dtl1_cs: Call of receive for unknown device.\n");
+		BT_ERR("Unknown device");
 		return;
 	}
 
@@ -238,7 +238,7 @@ static void dtl1_receive(dtl1_info_t *in
 		/* Allocate packet */
 		if (info->rx_skb == NULL)
 			if (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {
-				printk(KERN_WARNING "dtl1_cs: Can't allocate mem for new packet.\n");
+				BT_ERR("Can't allocate mem for new packet");
 				info->rx_state = RECV_WAIT_NSH;
 				info->rx_count = NSHL;
 				return;
@@ -283,7 +283,7 @@ static void dtl1_receive(dtl1_info_t *in
 					break;
 				default:
 					/* unknown packet */
-					printk(KERN_WARNING "dtl1_cs: Unknown HCI packet with type 0x%02x received.\n", info->rx_skb->pkt_type);
+					BT_ERR("Unknown HCI packet with type 0x%02x received", info->rx_skb->pkt_type);
 					kfree_skb(info->rx_skb);
 					break;
 				}
@@ -313,7 +313,7 @@ static irqreturn_t dtl1_interrupt(int ir
 	int iir, lsr;
 
 	if (!info) {
-		printk(KERN_WARNING "dtl1_cs: Call of irq %d for unknown device.\n", irq);
+		BT_ERR("Call of irq %d for unknown device", irq);
 		return IRQ_NONE;
 	}
 
@@ -329,7 +329,7 @@ static irqreturn_t dtl1_interrupt(int ir
 
 		switch (iir) {
 		case UART_IIR_RLSI:
-			printk(KERN_NOTICE "dtl1_cs: RLSI\n");
+			BT_ERR("RLSI");
 			break;
 		case UART_IIR_RDI:
 			/* Receive interrupt */
@@ -342,7 +342,7 @@ static irqreturn_t dtl1_interrupt(int ir
 			}
 			break;
 		default:
-			printk(KERN_NOTICE "dtl1_cs: Unhandled IIR=%#x\n", iir);
+			BT_ERR("Unhandled IIR=%#x", iir);
 			break;
 		}
 
@@ -410,7 +410,7 @@ static int dtl1_hci_send_frame(struct sk
 	nsh_t nsh;
 
 	if (!hdev) {
-		printk(KERN_WARNING "dtl1_cs: Frame for unknown HCI device (hdev=NULL).");
+		BT_ERR("Frame for unknown HCI device (hdev=NULL)");
 		return -ENODEV;
 	}
 
@@ -510,7 +510,7 @@ int dtl1_open(dtl1_info_t *info)
 	/* Initialize and register HCI device */
 	hdev = hci_alloc_dev();
 	if (!hdev) {
-		printk(KERN_WARNING "dtl1_cs: Can't allocate HCI device.\n");
+		BT_ERR("Can't allocate HCI device");
 		return -ENOMEM;
 	}
 
@@ -529,7 +529,7 @@ int dtl1_open(dtl1_info_t *info)
 	hdev->owner = THIS_MODULE;
 
 	if (hci_register_dev(hdev) < 0) {
-		printk(KERN_WARNING "dtl1_cs: Can't register HCI device.\n");
+		BT_ERR("Can't register HCI device");
 		hci_free_dev(hdev);
 		return -ENODEV;
 	}
@@ -557,7 +557,7 @@ int dtl1_close(dtl1_info_t *info)
 	spin_unlock_irqrestore(&(info->lock), flags);
 
 	if (hci_unregister_dev(hdev) < 0)
-		printk(KERN_WARNING "dtl1_cs: Can't unregister HCI device %s.\n", hdev->name);
+		BT_ERR("Can't unregister HCI device %s", hdev->name);
 
 	hci_free_dev(hdev);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/cyclades.c linux-post-2.6.4rc1-20040302/drivers/char/cyclades.c
--- linux-post-2.6.4rc1-20040301/drivers/char/cyclades.c	2004-02-26 12:55:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/cyclades.c	2004-03-02 03:01:44.000000000 +0000
@@ -5411,6 +5411,7 @@ cy_init(void)
     cy_serial_driver->owner = THIS_MODULE;
     cy_serial_driver->driver_name = "cyclades";
     cy_serial_driver->name = "ttyC";
+    cy_serial_driver->devfs_name = "tts/C";
     cy_serial_driver->major = CYCLADES_MAJOR;
     cy_serial_driver->minor_start = 0;
     cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/epca.c linux-post-2.6.4rc1-20040302/drivers/char/epca.c
--- linux-post-2.6.4rc1-20040301/drivers/char/epca.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/epca.c	2004-03-02 03:01:44.000000000 +0000
@@ -1644,6 +1644,7 @@ int __init pc_init(void)
 
 	pc_driver->owner = THIS_MODULE;
 	pc_driver->name = "ttyD"; 
+	pc_driver->devfs_name = "tts/D";
 	pc_driver->major = DIGI_MAJOR; 
 	pc_driver->minor_start = 0;
 	pc_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/esp.c linux-post-2.6.4rc1-20040302/drivers/char/esp.c
--- linux-post-2.6.4rc1-20040301/drivers/char/esp.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/esp.c	2004-03-02 03:01:44.000000000 +0000
@@ -2491,6 +2491,7 @@ int __init espserial_init(void)
 	
 	esp_driver->owner = THIS_MODULE;
 	esp_driver->name = "ttyP";
+	esp_driver->devfs_name = "tts/P";
 	esp_driver->major = ESP_IN_MAJOR;
 	esp_driver->minor_start = 0;
 	esp_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/isicom.c linux-post-2.6.4rc1-20040302/drivers/char/isicom.c
--- linux-post-2.6.4rc1-20040301/drivers/char/isicom.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/isicom.c	2004-03-02 03:01:44.000000000 +0000
@@ -1627,6 +1627,7 @@ static int register_drivers(void)
 
 	isicom_normal->owner	= THIS_MODULE;
 	isicom_normal->name 	= "ttyM";
+	isicom_normal->devfs_name = "isicom/";
 	isicom_normal->major	= ISICOM_NMAJOR;
 	isicom_normal->minor_start	= 0;
 	isicom_normal->type	= TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/moxa.c linux-post-2.6.4rc1-20040302/drivers/char/moxa.c
--- linux-post-2.6.4rc1-20040301/drivers/char/moxa.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/moxa.c	2004-03-02 03:01:44.000000000 +0000
@@ -309,6 +309,7 @@ static int __init moxa_init(void)
 	init_MUTEX(&moxaBuffSem);
 	moxaDriver->owner = THIS_MODULE;
 	moxaDriver->name = "ttya";
+	moxaDriver->devfs_name = "tts/a";
 	moxaDriver->major = ttymajor;
 	moxaDriver->minor_start = 0;
 	moxaDriver->type = TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/pcxx.c linux-post-2.6.4rc1-20040302/drivers/char/pcxx.c
--- linux-post-2.6.4rc1-20040301/drivers/char/pcxx.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/pcxx.c	2004-03-02 03:01:44.000000000 +0000
@@ -1150,6 +1150,7 @@ static int __init pcxe_init(void)
 
 	pcxe_driver->owner = THIS_MODULE;
 	pcxe_driver->name = "ttyD";
+	pcxe_driver->devfs_name = "pcxe/";
 	pcxe_driver->major = DIGI_MAJOR; 
 	pcxe_driver->minor_start = 0;
 	pcxe_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/riscom8.c linux-post-2.6.4rc1-20040302/drivers/char/riscom8.c
--- linux-post-2.6.4rc1-20040301/drivers/char/riscom8.c	2004-02-23 03:09:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/riscom8.c	2004-03-02 03:01:44.000000000 +0000
@@ -1687,6 +1687,7 @@ static inline int rc_init_drivers(void)
 	memset(IRQ_to_board, 0, sizeof(IRQ_to_board));
 	riscom_driver->owner = THIS_MODULE;
 	riscom_driver->name = "ttyL";
+	riscom_driver->devfs_name = "tts/L";
 	riscom_driver->major = RISCOM8_NORMAL_MAJOR;
 	riscom_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	riscom_driver->subtype = SERIAL_TYPE_NORMAL;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/vt.c linux-post-2.6.4rc1-20040302/drivers/char/vt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/vt.c	2004-02-19 03:43:03.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/vt.c	2004-03-02 03:01:44.000000000 +0000
@@ -2743,12 +2743,12 @@ static void vesa_powerdown(void)
      *  Called only if powerdown features are allowed.
      */
     switch (vesa_blank_mode) {
-	case VESA_NO_BLANKING:
-	    c->vc_sw->con_blank(c, VESA_VSYNC_SUSPEND+1);
+    case VESA_NO_BLANKING:
+	    c->vc_sw->con_blank(c, VESA_VSYNC_SUSPEND+1, 0);
 	    break;
-	case VESA_VSYNC_SUSPEND:
-	case VESA_HSYNC_SUSPEND:
-	    c->vc_sw->con_blank(c, VESA_POWERDOWN+1);
+    case VESA_VSYNC_SUSPEND:
+    case VESA_HSYNC_SUSPEND:
+	    c->vc_sw->con_blank(c, VESA_POWERDOWN+1, 0);
 	    break;
     }
 }
@@ -2776,7 +2776,7 @@ void do_blank_screen(int entering_gfx)
 	if (entering_gfx) {
 		hide_cursor(currcons);
 		save_screen(currcons);
-		sw->con_blank(vc_cons[currcons].d, -1);
+		sw->con_blank(vc_cons[currcons].d, -1, 1);
 		console_blanked = fg_console + 1;
 		set_origin(currcons);
 		return;
@@ -2794,7 +2794,7 @@ void do_blank_screen(int entering_gfx)
 
 	save_screen(currcons);
 	/* In case we need to reset origin, blanking hook returns 1 */
-	i = sw->con_blank(vc_cons[currcons].d, 1);
+	i = sw->con_blank(vc_cons[currcons].d, 1, 0);
 	console_blanked = fg_console + 1;
 	if (i)
 		set_origin(currcons);
@@ -2808,14 +2808,14 @@ void do_blank_screen(int entering_gfx)
 	}
 
     	if (vesa_blank_mode)
-		sw->con_blank(vc_cons[currcons].d, vesa_blank_mode + 1);
+		sw->con_blank(vc_cons[currcons].d, vesa_blank_mode + 1, 0);
 }
 
 
 /*
  * Called by timer as well as from vt_console_driver
  */
-void unblank_screen(void)
+void do_unblank_screen(int leaving_gfx)
 {
 	int currcons;
 
@@ -2839,7 +2839,7 @@ void unblank_screen(void)
 	}
 
 	console_blanked = 0;
-	if (sw->con_blank(vc_cons[currcons].d, 0))
+	if (sw->con_blank(vc_cons[currcons].d, 0, leaving_gfx))
 		/* Low-level driver cannot restore -> do it ourselves */
 		update_screen(fg_console);
 	if (console_blank_hook)
@@ -2849,6 +2849,17 @@ void unblank_screen(void)
 }
 
 /*
+ * This is called by the outside world to cause a forced unblank, mostly for
+ * oopses. Currently, I just call do_unblank_screen(0), but we could eventually
+ * call it with 1 as an argument and so force a mode restore... that may kill
+ * X or at least garbage the screen but would also make the Oops visible...
+ */
+void unblank_screen(void)
+{
+	do_unblank_screen(0);
+}
+
+/*
  * We defer the timer blanking to work queue so it can take the console semaphore
  * (console operations can still happen at irq time, but only from printk which
  * has the console semaphore. Not perfect yet, but better than no locking
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/vt_ioctl.c linux-post-2.6.4rc1-20040302/drivers/char/vt_ioctl.c
--- linux-post-2.6.4rc1-20040301/drivers/char/vt_ioctl.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/vt_ioctl.c	2004-03-02 03:01:44.000000000 +0000
@@ -497,7 +497,7 @@ int vt_ioctl(struct tty_struct *tty, str
 		 */
 		acquire_console_sem();
 		if (arg == KD_TEXT)
-			unblank_screen();
+			do_unblank_screen(1);
 		else
 			do_blank_screen(1);
 		release_console_sem();
@@ -1103,7 +1103,7 @@ void complete_change_console(unsigned in
 	if (old_vc_mode != vt_cons[new_console]->vc_mode)
 	{
 		if (vt_cons[new_console]->vc_mode == KD_TEXT)
-			unblank_screen();
+			do_unblank_screen(1);
 		else
 			do_blank_screen(1);
 	}
@@ -1138,7 +1138,7 @@ void complete_change_console(unsigned in
 			if (old_vc_mode != vt_cons[new_console]->vc_mode)
 			{
 				if (vt_cons[new_console]->vc_mode == KD_TEXT)
-					unblank_screen();
+					do_unblank_screen(1);
 				else
 					do_blank_screen(1);
 			}
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/Kconfig linux-post-2.6.4rc1-20040302/drivers/char/watchdog/Kconfig
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/Kconfig	2004-02-11 20:28:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/Kconfig	2004-03-02 03:01:48.000000000 +0000
@@ -339,6 +339,30 @@ config SH_WDT
 	  To compile this driver as a module, choose M here: the
 	  module will be called shwdt.
 
+# SPARC64 Architecture
+
+config WATCHDOG_CP1XXX
+	tristate "CP1XXX Hardware Watchdog support"
+	depends on WATCHDOG && SPARC64 && PCI
+	---help---
+	  This is the driver for the hardware watchdog timers present on
+	  Sun Microsystems CompactPCI models CP1400 and CP1500.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpwatchdog.
+
+	  If you do not have a CompactPCI model CP1400 or CP1500, or
+	  another UltraSPARC-IIi-cEngine boardset with hardware watchdog,
+	  you should say N to this option.
+
+config WATCHDOG_RIO
+	tristate "RIO Hardware Watchdog support"
+	depends on WATCHDOG && SPARC64 && PCI
+	help
+	  Say Y here to support the hardware watchdog capability on Sun RIO
+	  machines.  The watchdog timeout period is normally one minute but
+	  can be changed with a boot-time parameter.
+
 #
 # ISA-based Watchdog Cards
 #
@@ -455,4 +479,26 @@ config WDT_501_PCI
 	  Fahrenheit. This works only if you have a WDT501P watchdog board
 	  installed.
 
+#
+# USB-based Watchdog Cards
+#
+
+comment "USB-based Watchdog Cards"
+	depends on WATCHDOG && USB
+
+config USBPCWATCHDOG
+	tristate "Berkshire Products USB-PC Watchdog"
+	depends on WATCHDOG && USB
+	---help---
+	  This is the driver for the Berkshire Products USB-PC Watchdog card.
+	  This card simply watches your kernel to make sure it doesn't freeze,
+	  and if it does, it reboots your computer after a certain amount of
+	  time. The card can also monitor the internal temperature of the PC.
+	  More info is available at <http://www.berkprod.com/usb_pc_watchdog.htm>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called pcwd_usb.
+
+	  Most people will say N.
+
 endmenu
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/Makefile linux-post-2.6.4rc1-20040302/drivers/char/watchdog/Makefile
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/Makefile	2004-02-11 20:28:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/Makefile	2004-03-02 03:01:48.000000000 +0000
@@ -1,5 +1,5 @@
 #
-# Makefile for the kernel character device drivers.
+# Makefile for the WatchDog device drivers.
 #
 
 # Only one watchdog can succeed. We probe the hardware watchdog
@@ -35,3 +35,4 @@ obj-$(CONFIG_CPU5_WDT) += cpu5wdt.o
 obj-$(CONFIG_AMD7XX_TCO) += amd7xx_tco.o
 obj-$(CONFIG_INDYDOG) += indydog.o
 obj-$(CONFIG_PCIPCWATCHDOG) += pcwd_pci.o
+obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/cpu5wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/cpu5wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/cpu5wdt.c	2004-01-02 22:30:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/cpu5wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -293,6 +293,7 @@ MODULE_AUTHOR("Heiko Ronsdorf <hero@ihg.
 MODULE_DESCRIPTION("sma cpu5 watchdog driver");
 MODULE_SUPPORTED_DEVICE("sma cpu5 watchdog");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
 
 MODULE_PARM(port, "i");
 MODULE_PARM_DESC(port, "base address of watchdog card, default is 0x91");
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/eurotechwdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/eurotechwdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/eurotechwdt.c	2004-01-02 22:30:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/eurotechwdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -503,3 +503,4 @@ module_exit(eurwdt_exit);
 MODULE_AUTHOR("Rodolfo Giometti");
 MODULE_DESCRIPTION("Driver for Eurotech CPU-1220/1410 on board watchdog");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/ib700wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/ib700wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/ib700wdt.c	2004-01-02 22:34:34.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/ib700wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -350,5 +350,6 @@ module_exit(ibwdt_exit);
 MODULE_AUTHOR("Charles Howes <chowes@vsol.net>");
 MODULE_DESCRIPTION("IB700 SBC watchdog driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
 
 /* end of ib700wdt.c */
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/machzwd.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/machzwd.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/machzwd.c	2004-01-02 22:30:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/machzwd.c	2004-03-02 03:01:48.000000000 +0000
@@ -98,6 +98,7 @@ static unsigned short zf_readb(unsigned 
 MODULE_AUTHOR("Fernando Fuganti <fuganti@conectiva.com.br>");
 MODULE_DESCRIPTION("MachZ ZF-Logic Watchdog driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/mixcomwd.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/mixcomwd.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/mixcomwd.c	2004-01-02 22:30:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/mixcomwd.c	2004-03-02 03:01:48.000000000 +0000
@@ -302,4 +302,7 @@ static void __exit mixcomwd_exit(void)
 module_init(mixcomwd_init);
 module_exit(mixcomwd_exit);
 
+MODULE_AUTHOR("Gergely Madarasz <gorgo@itc.hu>");
+MODULE_DESCRIPTION("MixCom Watchdog driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/pcwd.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/pcwd.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/pcwd.c	2004-01-02 22:30:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/pcwd.c	2004-03-02 03:01:48.000000000 +0000
@@ -705,5 +705,8 @@ static void __exit pcwatchdog_exit(void)
 module_init(pcwatchdog_init);
 module_exit(pcwatchdog_exit);
 
+MODULE_AUTHOR("Ken Hollis <kenji@bitgate.com>");
+MODULE_DESCRIPTION("Berkshire ISA-PC Watchdog driver");
 MODULE_LICENSE("GPL");
-
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS_MISCDEV(TEMP_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/pcwd_usb.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/pcwd_usb.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/pcwd_usb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/pcwd_usb.c	2004-03-02 03:01:48.000000000 +0000
@@ -0,0 +1,810 @@
+/*
+ *	Berkshire USB-PC Watchdog Card Driver
+ *
+ *	(c) Copyright 2004 Wim Van Sebroeck <wim@iguana.be>.
+ *
+ *	Based on source code of the following authors:
+ *	  Ken Hollis <kenji@bitgate.com>,
+ *	  Alan Cox <alan@redhat.com>,
+ *	  Matt Domsch <Matt_Domsch@dell.com>,
+ *	  Rob Radez <rob@osinvestor.com>,
+ *	  Greg Kroah-Hartman <greg@kroah.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	Neither Wim Van Sebroeck nor Iguana vzw. admit liability nor
+ *	provide warranty for any of this software. This material is
+ *	provided "AS-IS" and at no charge.
+ *
+ *	Thanks also to Simon Machell at Berkshire Products Inc. for
+ *	providing the test hardware. More info is available at
+ *	http://www.berkprod.com/ or http://www.pcwatchdog.com/
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/fs.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+
+
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug;
+#endif
+
+/* Use our own dbg macro */
+#undef dbg
+#define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG PFX format "\n" , ## arg); } while (0)
+
+
+/* Module and Version Information */
+#define DRIVER_VERSION "v1.00 (28/02/2004)"
+#define DRIVER_AUTHOR "Wim Van Sebroeck <wim@iguana.be>"
+#define DRIVER_DESC "Berkshire USB-PC Watchdog driver"
+#define DRIVER_LICENSE "GPL"
+#define DRIVER_NAME "pcwd_usb"
+#define PFX DRIVER_NAME ": "
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS_MISCDEV(TEMP_MINOR);
+
+/* Module Parameters */
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+#define WATCHDOG_HEARTBEAT 2	/* 2 sec default heartbeat */
+static int heartbeat = WATCHDOG_HEARTBEAT;
+module_param(heartbeat, int, 0);
+MODULE_PARM_DESC(heartbeat, "Watchdog heartbeat in seconds. (0<heartbeat<65536, default=" __MODULE_STRING(WATCHDOG_HEARTBEAT) ")");
+
+#ifdef CONFIG_WATCHDOG_NOWAYOUT
+static int nowayout = 1;
+#else
+static int nowayout = 0;
+#endif
+
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
+
+/* The vendor and product id's for the USB-PC Watchdog card */
+#define USB_PCWD_VENDOR_ID	0x0c98
+#define USB_PCWD_PRODUCT_ID	0x1140
+
+/* table of devices that work with this driver */
+static struct usb_device_id usb_pcwd_table [] = {
+	{ USB_DEVICE(USB_PCWD_VENDOR_ID, USB_PCWD_PRODUCT_ID) },
+	{ }					/* Terminating entry */
+};
+MODULE_DEVICE_TABLE (usb, usb_pcwd_table);
+
+/* according to documentation max. time to process a command for the USB
+ * watchdog card is 100 or 200 ms, so we give it 250 ms to do it's job */
+#define USB_COMMAND_TIMEOUT	250
+
+/* Watchdog's internal commands */
+#define CMD_READ_TEMP			0x02	/* Read Temperature; Re-trigger Watchdog */
+#define CMD_TRIGGER			CMD_READ_TEMP
+#define CMD_GET_STATUS			0x04	/* Get Status Information */
+#define CMD_GET_FIRMWARE_VERSION	0x08	/* Get Firmware Version */
+#define CMD_GET_DIP_SWITCH_SETTINGS	0x0c	/* Get Dip Switch Settings */
+#define CMD_READ_WATCHDOG_TIMEOUT	0x18	/* Read Current Watchdog Time */
+#define CMD_WRITE_WATCHDOG_TIMEOUT	0x19	/* Write Current Watchdog Time */
+#define CMD_ENABLE_WATCHDOG		0x30	/* Enable / Disable Watchdog */
+#define CMD_DISABLE_WATCHDOG		CMD_ENABLE_WATCHDOG
+
+/* Some defines that I like to be somewhere else like include/linux/usb_hid.h */
+#define HID_REQ_SET_REPORT		0x09
+#define HID_DT_REPORT			(USB_TYPE_CLASS | 0x02)
+
+/* We can only use 1 card due to the /dev/watchdog restriction */
+static int cards_found;
+
+/* some internal variables */
+static unsigned long is_active;
+static char expect_release;
+
+/* Structure to hold all of our device specific stuff */
+struct usb_pcwd_private {
+	struct usb_device *	udev;			/* save off the usb device pointer */
+	struct usb_interface *	interface;		/* the interface for this device */
+
+	unsigned int		interface_number;	/* the interface number used for cmd's */
+
+	unsigned char *		intr_buffer;		/* the buffer to intr data */
+	dma_addr_t		intr_dma;		/* the dma address for the intr buffer */
+	size_t			intr_size;		/* the size of the intr buffer */
+	struct urb *		intr_urb;		/* the urb used for the intr pipe */
+
+	unsigned char		cmd_command;		/* The command that is reported back */
+	unsigned char		cmd_data_msb;		/* The data MSB that is reported back */
+	unsigned char		cmd_data_lsb;		/* The data LSB that is reported back */
+	atomic_t		cmd_received;		/* true if we received a report after a command */
+
+	int			exists;			/* Wether or not the device exists */
+	struct semaphore	sem;			/* locks this structure */
+};
+static struct usb_pcwd_private *usb_pcwd_device;
+
+/* prevent races between open() and disconnect() */
+static DECLARE_MUTEX (disconnect_sem);
+
+/* local function prototypes */
+static int usb_pcwd_probe	(struct usb_interface *interface, const struct usb_device_id *id);
+static void usb_pcwd_disconnect	(struct usb_interface *interface);
+
+/* usb specific object needed to register this driver with the usb subsystem */
+static struct usb_driver usb_pcwd_driver = {
+	.owner =	THIS_MODULE,
+	.name =		DRIVER_NAME,
+	.probe =	usb_pcwd_probe,
+	.disconnect =	usb_pcwd_disconnect,
+	.id_table =	usb_pcwd_table,
+};
+
+
+static void usb_pcwd_intr_done(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_pcwd_private *usb_pcwd = (struct usb_pcwd_private *)urb->context;
+	unsigned char *data = usb_pcwd->intr_buffer;
+	int retval;
+
+	switch (urb->status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
+		return;
+	/* -EPIPE:  should clear the halt */
+	default:		/* error */
+		dbg("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
+		goto resubmit;
+	}
+
+	dbg("received following data cmd=0x%02x msb=0x%02x lsb=0x%02x",
+		data[0], data[1], data[2]);
+
+	usb_pcwd->cmd_command  = data[0];
+	usb_pcwd->cmd_data_msb = data[1];
+	usb_pcwd->cmd_data_lsb = data[2];
+
+	/* notify anyone waiting that the cmd has finished */
+	atomic_set (&usb_pcwd->cmd_received, 1);
+
+resubmit:
+	retval = usb_submit_urb (urb, GFP_ATOMIC);
+	if (retval)
+		printk(KERN_ERR PFX "can't resubmit intr, usb_submit_urb failed with result %d\n",
+			retval);
+}
+
+static int usb_pcwd_send_command(struct usb_pcwd_private *usb_pcwd, unsigned char cmd,
+	unsigned char *msb, unsigned char *lsb)
+{
+	int got_response, count;
+	unsigned char buf[6];
+
+	/* We will not send any commands if the USB PCWD device does not exist */
+	if ((!usb_pcwd) || (!usb_pcwd->exists))
+		return -1;
+
+	/* The USB PC Watchdog uses a 6 byte report format. The board currently uses
+	 * only 3 of the six bytes of the report. */
+	buf[0] = cmd;			/* Byte 0 = CMD */
+	buf[1] = *msb;			/* Byte 1 = Data MSB */
+	buf[2] = *lsb;			/* Byte 2 = Data LSB */
+	buf[3] = buf[4] = buf[5] = 0;	/* All other bytes not used */
+
+	dbg("sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x",
+		buf[0], buf[1], buf[2]);
+
+	atomic_set (&usb_pcwd->cmd_received, 0);
+
+	if (usb_control_msg(usb_pcwd->udev, usb_sndctrlpipe(usb_pcwd->udev, 0),
+			HID_REQ_SET_REPORT, HID_DT_REPORT,
+			0x0200, usb_pcwd->interface_number, buf, sizeof(buf),
+			HZ) != sizeof(buf)) {
+		dbg("usb_pcwd_send_command: error in usb_control_msg for cmd 0x%x 0x%x 0x%x\n", cmd, *msb, *lsb);
+	}
+	/* wait till the usb card processed the command,
+	 * with a max. timeout of USB_COMMAND_TIMEOUT */
+	got_response = 0;
+	for (count = 0; (count < USB_COMMAND_TIMEOUT) && (!got_response); count++) {
+		mdelay(1);
+		if (atomic_read (&usb_pcwd->cmd_received))
+			got_response = 1;
+	}
+
+	if ((got_response) && (cmd == usb_pcwd->cmd_command)) {
+		/* read back response */
+		*msb = usb_pcwd->cmd_data_msb;
+		*lsb = usb_pcwd->cmd_data_lsb;
+	}
+
+	return got_response;
+}
+
+static int usb_pcwd_start(struct usb_pcwd_private *usb_pcwd)
+{
+	unsigned char msb = 0x00;
+	unsigned char lsb = 0x00;
+	int retval;
+
+	/* Enable Watchdog */
+	retval = usb_pcwd_send_command(usb_pcwd, CMD_ENABLE_WATCHDOG, &msb, &lsb);
+
+	if ((retval == 0) || (lsb == 0)) {
+		printk(KERN_ERR PFX "Card did not acknowledge enable attempt\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int usb_pcwd_stop(struct usb_pcwd_private *usb_pcwd)
+{
+	unsigned char msb = 0xA5;
+	unsigned char lsb = 0xC3;
+	int retval;
+
+	/* Disable Watchdog */
+	retval = usb_pcwd_send_command(usb_pcwd, CMD_DISABLE_WATCHDOG, &msb, &lsb);
+
+	if ((retval == 0) || (lsb != 0)) {
+		printk(KERN_ERR PFX "Card did not acknowledge disable attempt\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int usb_pcwd_keepalive(struct usb_pcwd_private *usb_pcwd)
+{
+	unsigned char dummy;
+
+	/* Re-trigger Watchdog */
+	usb_pcwd_send_command(usb_pcwd, CMD_TRIGGER, &dummy, &dummy);
+
+	return 0;
+}
+
+static int usb_pcwd_set_heartbeat(struct usb_pcwd_private *usb_pcwd, int t)
+{
+	unsigned char msb = t / 256;
+	unsigned char lsb = t % 256;
+
+	if ((t < 0x0001) || (t > 0xFFFF))
+		return -EINVAL;
+
+	/* Write new heartbeat to watchdog */
+	usb_pcwd_send_command(usb_pcwd, CMD_WRITE_WATCHDOG_TIMEOUT, &msb, &lsb);
+
+	heartbeat = t;
+	return 0;
+}
+
+static int usb_pcwd_get_temperature(struct usb_pcwd_private *usb_pcwd, int *temperature)
+{
+	unsigned char msb, lsb;
+
+	usb_pcwd_send_command(usb_pcwd, CMD_READ_TEMP, &msb, &lsb);
+
+	/*
+	 * Convert celsius to fahrenheit, since this was
+	 * the decided 'standard' for this return value.
+	 */
+	*temperature = (lsb * 9 / 5) + 32;
+
+	return 0;
+}
+
+/*
+ *	/dev/watchdog handling
+ */
+
+static ssize_t usb_pcwd_write(struct file *file, const char *data,
+			      size_t len, loff_t *ppos)
+{
+	/* Can't seek (pwrite) on this device  */
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+
+	/* See if we got the magic character 'V' and reload the timer */
+	if (len) {
+		if (!nowayout) {
+			size_t i;
+
+			/* note: just in case someone wrote the magic character
+			 * five months ago... */
+			expect_release = 0;
+
+			/* scan to see whether or not we got the magic character */
+			for (i = 0; i != len; i++) {
+				char c;
+				if(get_user(c, data+i))
+					return -EFAULT;
+				if (c == 'V')
+					expect_release = 42;
+			}
+		}
+
+		/* someone wrote to us, we should reload the timer */
+		usb_pcwd_keepalive(usb_pcwd_device);
+	}
+	return len;
+}
+
+static int usb_pcwd_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	static struct watchdog_info ident = {
+		.options =		WDIOF_KEEPALIVEPING |
+					WDIOF_SETTIMEOUT |
+					WDIOF_MAGICCLOSE,
+		.firmware_version =	1,
+		.identity =		DRIVER_NAME,
+	};
+
+	switch (cmd) {
+		case WDIOC_GETSUPPORT:
+			return copy_to_user((struct watchdog_info *) arg, &ident,
+				sizeof (ident)) ? -EFAULT : 0;
+
+		case WDIOC_GETSTATUS:
+		case WDIOC_GETBOOTSTATUS:
+			return put_user(0, (int *) arg);
+
+		case WDIOC_GETTEMP:
+		{
+			int temperature;
+
+			if (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))
+				return -EFAULT;
+
+			return put_user(temperature, (int *) arg);
+		}
+
+		case WDIOC_KEEPALIVE:
+			usb_pcwd_keepalive(usb_pcwd_device);
+			return 0;
+
+		case WDIOC_SETOPTIONS:
+		{
+			int new_options, retval = -EINVAL;
+
+			if (get_user (new_options, (int *) arg))
+				return -EFAULT;
+
+			if (new_options & WDIOS_DISABLECARD) {
+				usb_pcwd_stop(usb_pcwd_device);
+				retval = 0;
+			}
+
+			if (new_options & WDIOS_ENABLECARD) {
+				usb_pcwd_start(usb_pcwd_device);
+				retval = 0;
+			}
+
+			return retval;
+		}
+
+		case WDIOC_SETTIMEOUT:
+		{
+			int new_heartbeat;
+
+			if (get_user(new_heartbeat, (int *) arg))
+				return -EFAULT;
+
+			if (usb_pcwd_set_heartbeat(usb_pcwd_device, new_heartbeat))
+			    return -EINVAL;
+
+			usb_pcwd_keepalive(usb_pcwd_device);
+			/* Fall */
+		}
+
+		case WDIOC_GETTIMEOUT:
+			return put_user(heartbeat, (int *)arg);
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+}
+
+static int usb_pcwd_open(struct inode *inode, struct file *file)
+{
+	/* /dev/watchdog can only be opened once */
+	if (test_and_set_bit(0, &is_active))
+		return -EBUSY;
+
+	/* Activate */
+	usb_pcwd_start(usb_pcwd_device);
+	usb_pcwd_keepalive(usb_pcwd_device);
+	return 0;
+}
+
+static int usb_pcwd_release(struct inode *inode, struct file *file)
+{
+	/*
+	 *      Shut off the timer.
+	 */
+	if (expect_release == 42) {
+		usb_pcwd_stop(usb_pcwd_device);
+	} else {
+		printk(KERN_CRIT PFX "Unexpected close, not stopping watchdog!\n");
+		usb_pcwd_keepalive(usb_pcwd_device);
+	}
+	clear_bit(0, &is_active);
+	expect_release = 0;
+	return 0;
+}
+
+/*
+ *	/dev/temperature handling
+ */
+
+static ssize_t usb_pcwd_temperature_read(struct file *file, char *data,
+				size_t len, loff_t *ppos)
+{
+	int temperature;
+
+	/* Can't seek (pwrite) on this device  */
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+
+	if (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))
+		return -EFAULT;
+
+	if (copy_to_user (data, &temperature, 1))
+		return -EFAULT;
+
+	return 1;
+}
+
+static int usb_pcwd_temperature_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int usb_pcwd_temperature_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+/*
+ *	Notify system
+ */
+
+static int usb_pcwd_notify_sys(struct notifier_block *this, unsigned long code, void *unused)
+{
+	if (code==SYS_DOWN || code==SYS_HALT) {
+		/* Turn the WDT off */
+		usb_pcwd_stop(usb_pcwd_device);
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ *	Kernel Interfaces
+ */
+
+static struct file_operations usb_pcwd_fops = {
+	.owner =	THIS_MODULE,
+	.llseek =	no_llseek,
+	.write =	usb_pcwd_write,
+	.ioctl =	usb_pcwd_ioctl,
+	.open =		usb_pcwd_open,
+	.release =	usb_pcwd_release,
+};
+
+static struct miscdevice usb_pcwd_miscdev = {
+	.minor =	WATCHDOG_MINOR,
+	.name =		"watchdog",
+	.fops =		&usb_pcwd_fops,
+};
+
+static struct file_operations usb_pcwd_temperature_fops = {
+	.owner =	THIS_MODULE,
+	.llseek =	no_llseek,
+	.read =		usb_pcwd_temperature_read,
+	.open =		usb_pcwd_temperature_open,
+	.release =	usb_pcwd_temperature_release,
+};
+
+static struct miscdevice usb_pcwd_temperature_miscdev = {
+	.minor =	TEMP_MINOR,
+	.name =		"temperature",
+	.fops =		&usb_pcwd_temperature_fops,
+};
+
+static struct notifier_block usb_pcwd_notifier = {
+	.notifier_call =	usb_pcwd_notify_sys,
+};
+
+/**
+ *	usb_pcwd_delete
+ */
+static inline void usb_pcwd_delete (struct usb_pcwd_private *usb_pcwd)
+{
+	if (usb_pcwd->intr_urb != NULL)
+		usb_free_urb (usb_pcwd->intr_urb);
+	if (usb_pcwd->intr_buffer != NULL)
+		usb_buffer_free(usb_pcwd->udev, usb_pcwd->intr_size,
+				usb_pcwd->intr_buffer, usb_pcwd->intr_dma);
+	kfree (usb_pcwd);
+}
+
+/**
+ *	usb_pcwd_probe
+ *
+ *	Called by the usb core when a new device is connected that it thinks
+ *	this driver might be interested in.
+ */
+static int usb_pcwd_probe(struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(interface);
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_pcwd_private *usb_pcwd = NULL;
+	int pipe, maxp;
+	int retval = -ENOMEM;
+	int got_fw_rev;
+	unsigned char fw_rev_major, fw_rev_minor;
+	char fw_ver_str[20];
+	unsigned char option_switches, dummy;
+
+	/* See if the device offered us matches what we can accept */
+	if ((udev->descriptor.idVendor != USB_PCWD_VENDOR_ID) ||
+	    (udev->descriptor.idProduct != USB_PCWD_PRODUCT_ID)) {
+		return -ENODEV;
+	}
+
+	cards_found++;
+	if (cards_found > 1) {
+		printk(KERN_ERR PFX "This driver only supports 1 device\n");
+		return -ENODEV;
+	}
+
+	/* get the active interface descriptor */
+	iface_desc = &interface->altsetting[interface->act_altsetting];
+
+	/* check out that we have a HID device */
+	if (!(iface_desc->desc.bInterfaceClass == USB_CLASS_HID)) {
+		printk(KERN_ERR PFX "The device isn't a Human Interface Device\n");
+		return -ENODEV;
+	}
+
+	/* check out the endpoint: it has to be Interrupt & IN */
+	endpoint = &iface_desc->endpoint[0].desc;
+
+	if (!((endpoint->bEndpointAddress & USB_DIR_IN) &&
+	     ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+				== USB_ENDPOINT_XFER_INT))) {
+		/* we didn't find a Interrupt endpoint with direction IN */
+		printk(KERN_ERR PFX "Couldn't find an INTR & IN endpoint\n");
+		return -ENODEV;
+	}
+
+	/* get a handle to the interrupt data pipe */
+	pipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);
+	maxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));
+
+	/* allocate memory for our device and initialize it */
+	usb_pcwd = kmalloc (sizeof(struct usb_pcwd_private), GFP_KERNEL);
+	if (usb_pcwd == NULL) {
+		printk(KERN_ERR PFX "Out of memory\n");
+		goto error;
+	}
+	memset (usb_pcwd, 0x00, sizeof (*usb_pcwd));
+
+	usb_pcwd_device = usb_pcwd;
+
+	init_MUTEX (&usb_pcwd->sem);
+	usb_pcwd->udev = udev;
+	usb_pcwd->interface = interface;
+	usb_pcwd->interface_number = iface_desc->desc.bInterfaceNumber;
+	usb_pcwd->intr_size = (endpoint->wMaxPacketSize > 8 ? endpoint->wMaxPacketSize : 8);
+
+	/* set up the memory buffer's */
+	if (!(usb_pcwd->intr_buffer = usb_buffer_alloc(udev, usb_pcwd->intr_size, SLAB_ATOMIC, &usb_pcwd->intr_dma))) {
+		printk(KERN_ERR PFX "Out of memory\n");
+		goto error;
+	}
+
+	/* allocate the urb's */
+	usb_pcwd->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!usb_pcwd->intr_urb) {
+		printk(KERN_ERR PFX "Out of memory\n");
+		goto error;
+	}
+
+	/* initialise the intr urb's */
+	usb_fill_int_urb(usb_pcwd->intr_urb, udev, pipe,
+			usb_pcwd->intr_buffer, usb_pcwd->intr_size,
+			usb_pcwd_intr_done, usb_pcwd, endpoint->bInterval);
+	usb_pcwd->intr_urb->transfer_dma = usb_pcwd->intr_dma;
+	usb_pcwd->intr_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	/* register our interrupt URB with the USB system */
+	if (usb_submit_urb(usb_pcwd->intr_urb, GFP_KERNEL)) {
+		printk(KERN_ERR PFX "Problem registering interrupt URB\n");
+		retval = -EIO; /* failure */
+		goto error;
+	}
+
+	/* The device exists and can be communicated with */
+	usb_pcwd->exists = 1;
+
+	/* disable card */
+	usb_pcwd_stop(usb_pcwd);
+
+	/* Get the Firmware Version */
+	got_fw_rev = usb_pcwd_send_command(usb_pcwd, CMD_GET_FIRMWARE_VERSION, &fw_rev_major, &fw_rev_minor);
+	if (got_fw_rev) {
+		sprintf(fw_ver_str, "%u.%02u", fw_rev_major, fw_rev_minor);
+	} else {
+		sprintf(fw_ver_str, "<card no answer>");
+	}
+
+	printk(KERN_INFO PFX "Found card (Firmware: %s) with temp option\n",
+		fw_ver_str);
+
+	/* Get switch settings */
+	usb_pcwd_send_command(usb_pcwd, CMD_GET_DIP_SWITCH_SETTINGS, &dummy, &option_switches);
+
+	printk(KERN_INFO PFX "Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\n",
+		option_switches,
+		((option_switches & 0x10) ? "ON" : "OFF"),
+		((option_switches & 0x08) ? "ON" : "OFF"));
+
+	/* Check that the heartbeat value is within it's range ; if not reset to the default */
+	if (heartbeat < 1 || heartbeat > 0xFFFF) {
+		heartbeat = WATCHDOG_HEARTBEAT;
+		printk(KERN_INFO PFX "heartbeat value must be 0<heartbeat<65536, using %d\n",
+			heartbeat);
+	}
+
+	/* Calculate the watchdog's heartbeat */
+	usb_pcwd_set_heartbeat(usb_pcwd, heartbeat);
+
+	retval = register_reboot_notifier(&usb_pcwd_notifier);
+	if (retval != 0) {
+		printk(KERN_ERR PFX "cannot register reboot notifier (err=%d)\n",
+			retval);
+		goto error;
+	}
+
+	retval = misc_register(&usb_pcwd_miscdev);
+	if (retval != 0) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, retval);
+		goto err_out_unregister_reboot;
+	}
+
+	retval = misc_register(&usb_pcwd_temperature_miscdev);
+	if (retval != 0) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			TEMP_MINOR, retval);
+		goto err_out_misc_deregister;
+	}
+
+	/* we can register the device now, as it is ready */
+	usb_set_intfdata (interface, usb_pcwd);
+
+	printk(KERN_INFO PFX "initialized. heartbeat=%d sec (nowayout=%d)\n",
+		heartbeat, nowayout);
+
+	return 0;
+
+err_out_misc_deregister:
+	misc_deregister(&usb_pcwd_miscdev);
+err_out_unregister_reboot:
+	unregister_reboot_notifier(&usb_pcwd_notifier);
+error:
+	usb_pcwd_delete (usb_pcwd);
+	usb_pcwd_device = NULL;
+	return retval;
+}
+
+
+/**
+ *	usb_pcwd_disconnect
+ *
+ *	Called by the usb core when the device is removed from the system.
+ *
+ *	This routine guarantees that the driver will not submit any more urbs
+ *	by clearing dev->udev.
+ */
+static void usb_pcwd_disconnect(struct usb_interface *interface)
+{
+	struct usb_pcwd_private *usb_pcwd;
+
+	/* prevent races with open() */
+	down (&disconnect_sem);
+
+	usb_pcwd = usb_get_intfdata (interface);
+	usb_set_intfdata (interface, NULL);
+
+	down (&usb_pcwd->sem);
+
+	/* Stop the timer before we leave */
+	if (!nowayout)
+		usb_pcwd_stop(usb_pcwd);
+
+	/* We should now stop communicating with the USB PCWD device */
+	usb_pcwd->exists = 0;
+
+	/* Deregister */
+	misc_deregister(&usb_pcwd_temperature_miscdev);
+	misc_deregister(&usb_pcwd_miscdev);
+	unregister_reboot_notifier(&usb_pcwd_notifier);
+
+	up (&usb_pcwd->sem);
+
+	/* Delete the USB PCWD device */
+	usb_pcwd_delete(usb_pcwd);
+
+	cards_found--;
+
+	up (&disconnect_sem);
+
+	printk(KERN_INFO PFX "USB PC Watchdog disconnected\n");
+}
+
+
+
+/**
+ *	usb_pcwd_init
+ */
+static int __init usb_pcwd_init(void)
+{
+	int result;
+
+	/* register this driver with the USB subsystem */
+	result = usb_register(&usb_pcwd_driver);
+	if (result) {
+		printk(KERN_ERR PFX "usb_register failed. Error number %d\n",
+		    result);
+		return result;
+	}
+
+	printk(KERN_INFO PFX DRIVER_DESC " " DRIVER_VERSION "\n");
+	return 0;
+}
+
+
+/**
+ *	usb_pcwd_exit
+ */
+static void __exit usb_pcwd_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&usb_pcwd_driver);
+}
+
+
+module_init (usb_pcwd_init);
+module_exit (usb_pcwd_exit);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/sa1100_wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/sa1100_wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/sa1100_wdt.c	2004-01-02 20:44:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/sa1100_wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -218,3 +218,4 @@ module_param(nowayout, int, 0);
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
 
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/sc1200wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/sc1200wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/sc1200wdt.c	2004-01-02 22:30:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/sc1200wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -486,3 +486,4 @@ module_exit(sc1200wdt_exit);
 MODULE_AUTHOR("Zwane Mwaikambo <zwane@commfireservices.com>");
 MODULE_DESCRIPTION("Driver for National Semiconductor PC87307/PC97307 watchdog component");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/w83627hf_wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/w83627hf_wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/w83627hf_wdt.c	2004-01-02 22:30:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/w83627hf_wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -321,4 +321,4 @@ module_exit(wdt_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Pdraig Brady <P@draigBrady.com>");
 MODULE_DESCRIPTION("w38627hf WDT driver");
-
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/w83877f_wdt.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/w83877f_wdt.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/w83877f_wdt.c	2004-01-03 11:58:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/w83877f_wdt.c	2004-03-02 03:01:48.000000000 +0000
@@ -427,3 +427,4 @@ module_exit(w83877f_wdt_unload);
 MODULE_AUTHOR("Scott and Bill Jennings");
 MODULE_DESCRIPTION("Driver for watchdog timer in w83877f chip");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt285.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt285.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt285.c	2004-01-02 22:09:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt285.c	2004-03-02 03:01:48.000000000 +0000
@@ -222,6 +222,7 @@ static void __exit footbridge_watchdog_e
 MODULE_AUTHOR("Phil Blundell <pb@nexus.co.uk>");
 MODULE_DESCRIPTION("Footbridge watchdog driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
 
 module_param(soft_margin, int, 0);
 MODULE_PARM_DESC(soft_margin,"Watchdog timeout in seconds");
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt977.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt977.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt977.c	2004-01-02 22:30:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt977.c	2004-03-02 03:01:48.000000000 +0000
@@ -365,5 +365,7 @@ static void __exit nwwatchdog_exit(void)
 module_init(nwwatchdog_init);
 module_exit(nwwatchdog_exit);
 
+MODULE_AUTHOR("Woody Suwalski <woody@netwinder.org>");
 MODULE_DESCRIPTION("W83977AF Watchdog driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt_pci.c linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt_pci.c
--- linux-post-2.6.4rc1-20040301/drivers/char/watchdog/wdt_pci.c	2004-01-02 22:30:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/char/watchdog/wdt_pci.c	2004-03-02 03:01:48.000000000 +0000
@@ -653,3 +653,5 @@ module_exit(wdtpci_cleanup);
 MODULE_AUTHOR("JP Nollmann, Alan Cox");
 MODULE_DESCRIPTION("Driver for the ICS PCI watchdog cards");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS_MISCDEV(TEMP_MINOR);
diff -purN linux-post-2.6.4rc1-20040301/drivers/ide/arm/icside.c linux-post-2.6.4rc1-20040302/drivers/ide/arm/icside.c
--- linux-post-2.6.4rc1-20040301/drivers/ide/arm/icside.c	2004-02-16 20:26:05.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ide/arm/icside.c	2004-02-28 11:38:08.000000000 +0000
@@ -1,13 +1,7 @@
 /*
  * linux/drivers/ide/arm/icside.c
  *
- * Copyright (c) 1996-2002 Russell King.
- *
- * Changelog:
- *  08-Jun-1996	RMK	Created
- *  12-Sep-1997	RMK	Added interrupt enable/disable
- *  17-Apr-1999	RMK	Added support for V6 EASI
- *  22-May-1999	RMK	Added support for V6 DMA
+ * Copyright (c) 1996-2003 Russell King.
  */
 
 #include <linux/config.h>
@@ -237,7 +231,7 @@ static void icside_build_sglist(ide_driv
 		sg->length = rq->nr_sectors * SECTOR_SIZE;
 		nents = 1;
 	} else {
-		nents = blk_rq_map_sg(&drive->queue, rq, sg);
+		nents = blk_rq_map_sg(drive->queue, rq, sg);
 
 		if (rq_data_dir(rq) == READ)
 			hwif->sg_dma_direction = DMA_FROM_DEVICE;
@@ -487,33 +481,31 @@ icside_dma_common(ide_drive_t *drive, st
 	set_dma_sg(hwif->hw.dma, hwif->sg_table, hwif->sg_nents);
 	set_dma_mode(hwif->hw.dma, dma_mode);
 
+	drive->waiting_for_dma = 1;
+
 	return 0;
 }
 
 static int icside_dma_read(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd = WIN_NOP;
+	task_ioreg_t cmd;
 
 	if (icside_dma_common(drive, rq, DMA_MODE_READ))
 		return 1;
 
-	drive->waiting_for_dma = 1;
-
 	if (drive->media != ide_disk)
 		return 0;
 
 	BUG_ON(HWGROUP(drive)->handler != NULL);
 
-	ide_set_handler(drive, icside_dmaintr, 2*WAIT_CMD, NULL);
-
 	/*
 	 * FIX ME to use only ACB ide_task_t args Struct
 	 */
 #if 0
 	{
 		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
+		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
 	}
 #else
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
@@ -526,35 +518,31 @@ static int icside_dma_read(ide_drive_t *
 	}
 #endif
 	/* issue cmd to drive */
-	HWIF(drive)->OUTB(cmd, IDE_COMMAND_REG);
+	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
 
 	return icside_dma_begin(drive);
 }
 
-int icside_dma_write(ide_drive_t *drive)
+static int icside_dma_write(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd = WIN_NOP;
+	task_ioreg_t cmd;
 
 	if (icside_dma_common(drive, rq, DMA_MODE_WRITE))
 		return 1;
 
-	drive->waiting_for_dma = 1;
-
 	if (drive->media != ide_disk)
 		return 0;
 
 	BUG_ON(HWGROUP(drive)->handler != NULL);
 
-	ide_set_handler(drive, icside_dmaintr, 2*WAIT_CMD, NULL);
-
 	/*
 	 * FIX ME to use only ACB ide_task_t args Struct
 	 */
 #if 0
 	{
 		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
+		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
 	}
 #else
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
@@ -566,8 +554,9 @@ int icside_dma_write(ide_drive_t *drive)
 		cmd = WIN_WRITEDMA;
 	}
 #endif
+
 	/* issue cmd to drive */
-	HWIF(drive)->OUTB(cmd, IDE_COMMAND_REG);
+	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
 
 	return icside_dma_begin(drive);
 }
@@ -787,7 +776,7 @@ icside_register_v6(struct icside_state *
 	state->hwif[0]    = hwif;
 	state->hwif[1]    = mate;
 
-	ec->irq_data	  = state;
+	ec->irq_data      = state;
 	ec->ops           = &icside_ops_arcin_v6;
 
 	hwif->maskproc    = icside_maskproc;
@@ -797,7 +786,7 @@ icside_register_v6(struct icside_state *
 	hwif->serialized  = 1;
 	hwif->config_data = slot_port;
 	hwif->select_data = sel;
-	hwif->hw.dma	  = ec->dma;
+	hwif->hw.dma      = ec->dma;
 
 	mate->maskproc    = icside_maskproc;
 	mate->channel     = 1;
@@ -806,7 +795,7 @@ icside_register_v6(struct icside_state *
 	mate->serialized  = 1;
 	mate->config_data = slot_port;
 	mate->select_data = sel | 1;
-	mate->hw.dma	  = ec->dma;
+	mate->hw.dma      = ec->dma;
 
 	if (ec->dma != NO_DMA && !request_dma(ec->dma, hwif->name)) {
 		icside_dma_init(hwif);
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/Kconfig linux-post-2.6.4rc1-20040302/drivers/ieee1394/Kconfig
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/Kconfig	2004-02-21 05:09:53.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/Kconfig	2004-02-28 19:16:06.000000000 +0000
@@ -47,6 +47,23 @@ config IEEE1394_OUI_DB
 	  This option is not needed for userspace programs like gscanbus
 	  to show this information.
 
+config IEEE1394_EXTRA_CONFIG_ROMS
+	bool "Build in extra config rom entries for certain functionality"
+	depends on IEEE1394
+	help
+	  Some IEEE1394 functionality depends on extra config rom entries
+	  being available in the host adapters CSR. These options will
+	  allow you to choose which ones.
+
+config IEEE1394_CONFIG_ROM_IP1394
+	bool "IP-1394 Entry"
+	depends on IEEE1394_EXTRA_CONFIG_ROMS && IEEE1394
+	help
+	  Adds an entry for using IP-over-1394. If you want to use your
+	  IEEE1394 bus as a network for IP systems (including interacting
+	  with MacOSX and WinXP IP-over-1394), enable this option and the
+	  eth1394 option below.
+
 comment "Device Drivers"
 	depends on IEEE1394
 
@@ -108,6 +125,8 @@ config IEEE1394_SBP2_PHYS_DMA
 config IEEE1394_ETH1394
 	tristate "Ethernet over 1394"
 	depends on IEEE1394 && EXPERIMENTAL
+	select IEEE1394_CONFIG_ROM_IP1394
+	select IEEE1394_EXTRA_CONFIG_ROMS
 	help
 	  This driver implements a functional majority of RFC 2734: IPv4 over
 	  1394.  It will provide IP connectivity with implementations of RFC
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/Makefile linux-post-2.6.4rc1-20040302/drivers/ieee1394/Makefile
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/Makefile	2004-02-04 18:46:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/Makefile	2004-02-28 19:16:15.000000000 +0000
@@ -4,7 +4,7 @@
 
 ieee1394-objs := ieee1394_core.o ieee1394_transactions.o hosts.o \
 		 highlevel.o csr.o nodemgr.o oui.o dma.o iso.o \
-		 csr1212.o
+		 csr1212.o config_roms.o
 
 obj-$(CONFIG_IEEE1394) += ieee1394.o
 obj-$(CONFIG_IEEE1394_PCILYNX) += pcilynx.o
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/amdtp.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/amdtp.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/amdtp.c	2004-02-17 12:41:40.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/amdtp.c	2004-02-29 18:29:18.000000000 +0000
@@ -1227,15 +1227,15 @@ static void amdtp_add_host(struct hpsb_h
 	ah->host = host;
 	ah->ohci = host->hostdata;
 
-	hpsb_set_hostinfo_key(&amdtp_highlevel, host, ah->ohci->id);
+	hpsb_set_hostinfo_key(&amdtp_highlevel, host, ah->host->id);
 
-	minor = IEEE1394_MINOR_BLOCK_AMDTP * 16 + ah->ohci->id;
+	minor = IEEE1394_MINOR_BLOCK_AMDTP * 16 + ah->host->id;
 
 	INIT_LIST_HEAD(&ah->stream_list);
 	spin_lock_init(&ah->stream_list_lock);
 
 	devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, minor),
-			S_IFCHR|S_IRUSR|S_IWUSR, "amdtp/%d", ah->ohci->id);
+			S_IFCHR|S_IRUSR|S_IWUSR, "amdtp/%d", ah->host->id);
 }
 
 static void amdtp_remove_host(struct hpsb_host *host)
@@ -1243,7 +1243,7 @@ static void amdtp_remove_host(struct hps
 	struct amdtp_host *ah = hpsb_get_hostinfo(&amdtp_highlevel, host);
 
 	if (ah)
-		devfs_remove("amdtp/%d", ah->ohci->id);
+		devfs_remove("amdtp/%d", ah->host->id);
 
 	return;
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/config_roms.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/config_roms.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/config_roms.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/config_roms.c	2004-02-28 19:15:44.000000000 +0000
@@ -0,0 +1,236 @@
+/*
+ * IEEE 1394 for Linux
+ *
+ * ConfigROM  entries
+ *
+ * Copyright (C) 2004 Ben Collins
+ *
+ * This code is licensed under the GPL.  See the file COPYING in the root
+ * directory of the kernel sources for details.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+
+#include "csr1212.h"
+#include "ieee1394.h"
+#include "ieee1394_types.h"
+#include "hosts.h"
+#include "ieee1394_core.h"
+#include "highlevel.h"
+#include "csr.h"
+#include "config_roms.h"
+
+struct hpsb_config_rom_entry {
+	const char *name;
+
+	/* Base initialization, called at module load */
+	int (*init)(void);
+
+	/* Add entry to specified host */
+	int (*add)(struct hpsb_host *host);
+
+	/* Remove entry from specified host */
+	void (*remove)(struct hpsb_host *host);
+
+	/* Cleanup called at module exit */
+	void (*cleanup)(void);
+
+	/* The flag added to host->config_roms */
+	unsigned int flag;
+};
+
+
+int hpsb_default_host_entry(struct hpsb_host *host)
+{
+	struct csr1212_keyval *root;
+	struct csr1212_keyval *vend_id = NULL;
+	struct csr1212_keyval *text = NULL;
+	char csr_name[128];
+	int ret;
+
+	sprintf(csr_name, "Linux - %s", host->driver->name);
+	root = host->csr.rom->root_kv;
+
+	vend_id = csr1212_new_immediate(CSR1212_KV_ID_VENDOR, host->csr.guid_hi >> 8);
+	text = csr1212_new_string_descriptor_leaf(csr_name);
+
+	if (!vend_id || !text) {
+		if (vend_id)
+			csr1212_release_keyval(vend_id);
+		if (text)
+			csr1212_release_keyval(text);
+		csr1212_destroy_csr(host->csr.rom);
+		return -ENOMEM;
+	}
+
+	ret = csr1212_associate_keyval(vend_id, text);
+	csr1212_release_keyval(text);
+	ret |= csr1212_attach_keyval_to_directory(root, vend_id);
+	if (ret != CSR1212_SUCCESS) {
+		csr1212_release_keyval(vend_id);
+		csr1212_destroy_csr(host->csr.rom);
+		return -ENOMEM;
+	}
+
+	host->update_config_rom = 1;
+
+	return 0;
+}
+
+
+#ifdef CONFIG_IEEE1394_CONFIG_ROM_IP1394
+#include "eth1394.h"
+
+static struct csr1212_keyval *ip1394_ud;
+
+static int config_rom_ip1394_init(void)
+{
+	struct csr1212_keyval *spec_id = NULL;
+	struct csr1212_keyval *spec_desc = NULL;
+	struct csr1212_keyval *ver = NULL;
+	struct csr1212_keyval *ver_desc = NULL;
+	int ret = -ENOMEM;
+
+	ip1394_ud = csr1212_new_directory(CSR1212_KV_ID_UNIT);
+
+	spec_id = csr1212_new_immediate(CSR1212_KV_ID_SPECIFIER_ID,
+					ETHER1394_GASP_SPECIFIER_ID);
+	spec_desc = csr1212_new_string_descriptor_leaf("IANA");
+	ver = csr1212_new_immediate(CSR1212_KV_ID_VERSION,
+				    ETHER1394_GASP_VERSION);
+	ver_desc = csr1212_new_string_descriptor_leaf("IPv4");
+
+	if (!ip1394_ud || !spec_id || !spec_desc || !ver || !ver_desc)
+		goto ip1394_fail;
+
+	if (csr1212_associate_keyval(spec_id, spec_desc) == CSR1212_SUCCESS &&
+	    csr1212_associate_keyval(ver, ver_desc) == CSR1212_SUCCESS &&
+	    csr1212_attach_keyval_to_directory(ip1394_ud, spec_id) == CSR1212_SUCCESS &&
+	    csr1212_attach_keyval_to_directory(ip1394_ud, ver) == CSR1212_SUCCESS)
+		ret = 0;
+
+ip1394_fail:
+	if (ret && ip1394_ud) {
+		csr1212_release_keyval(ip1394_ud);
+		ip1394_ud = NULL;
+	}
+
+	if (spec_id)
+		csr1212_release_keyval(spec_id);
+	if (spec_desc)
+		csr1212_release_keyval(spec_desc);
+	if (ver)
+		csr1212_release_keyval(ver);
+	if (ver_desc)
+		csr1212_release_keyval(ver_desc);
+
+	return ret;
+}
+
+static void config_rom_ip1394_cleanup(void)
+{
+	if (ip1394_ud) {
+		csr1212_release_keyval(ip1394_ud);
+		ip1394_ud = NULL;
+	}
+}
+
+static int config_rom_ip1394_add(struct hpsb_host *host)
+{
+	if (!ip1394_ud)
+		return -ENODEV;
+
+	if (csr1212_attach_keyval_to_directory(host->csr.rom->root_kv,
+					       ip1394_ud) != CSR1212_SUCCESS)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void config_rom_ip1394_remove(struct hpsb_host *host)
+{
+	csr1212_detach_keyval_from_directory(host->csr.rom->root_kv, ip1394_ud);
+}
+
+static struct hpsb_config_rom_entry ip1394_entry = {
+	.name		= "ip1394",
+	.init		= config_rom_ip1394_init,
+	.add		= config_rom_ip1394_add,
+	.remove		= config_rom_ip1394_remove,
+	.cleanup	= config_rom_ip1394_cleanup,
+	.flag		= HPSB_CONFIG_ROM_ENTRY_IP1394,
+};
+#endif /* CONFIG_IEEE1394_CONFIG_ROM_IP1394 */
+
+
+static struct hpsb_config_rom_entry *const config_rom_entries[] = {
+#ifdef CONFIG_IEEE1394_CONFIG_ROM_IP1394
+	&ip1394_entry,
+#endif
+	NULL,
+};
+
+
+int hpsb_init_config_roms(void)
+{
+	int i, error = 0;
+
+	for (i = 0; config_rom_entries[i]; i++) {
+		if (!config_rom_entries[i]->init)
+			continue;
+
+		if (config_rom_entries[i]->init()) {
+			HPSB_ERR("Failed to initialize config rom entry `%s'",
+				 config_rom_entries[i]->name);
+			error = -1;
+		} else
+			HPSB_DEBUG("Initialized config rom entry `%s'",
+				   config_rom_entries[i]->name);
+	}
+
+	return error;
+}
+
+void hpsb_cleanup_config_roms(void)
+{
+	int i;
+
+	for (i = 0; config_rom_entries[i]; i++) {
+		if (config_rom_entries[i]->cleanup)
+			config_rom_entries[i]->cleanup();
+	}
+}
+
+int hpsb_add_extra_config_roms(struct hpsb_host *host)
+{
+	int i, error = 0;
+
+	for (i = 0; config_rom_entries[i]; i++) {
+		if (config_rom_entries[i]->add(host)) {
+			HPSB_ERR("fw-host%d: Failed to attach config rom entry `%s'",
+				 host->id, config_rom_entries[i]->name);
+			error = -1;
+		} else {
+			host->config_roms |= config_rom_entries[i]->flag;
+			host->update_config_rom = 1;
+		}
+	}
+
+	return error;
+}
+
+void hpsb_remove_extra_config_roms(struct hpsb_host *host)
+{
+	int i;
+
+	for (i = 0; config_rom_entries[i]; i++) {
+		if (!(host->config_roms & config_rom_entries[i]->flag))
+			continue;
+
+		config_rom_entries[i]->remove(host);
+
+		host->config_roms &= ~config_rom_entries[i]->flag;
+		host->update_config_rom = 1;
+	}
+}
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/config_roms.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/config_roms.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/config_roms.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/config_roms.h	2004-02-28 19:15:48.000000000 +0000
@@ -0,0 +1,27 @@
+#ifndef _IEEE1394_CONFIG_ROMS_H
+#define _IEEE1394_CONFIG_ROMS_H
+
+#include "ieee1394_types.h"
+#include "hosts.h"
+
+/* The default host entry. This must succeed. */
+int hpsb_default_host_entry(struct hpsb_host *host);
+
+/* Initialize all config roms */
+int hpsb_init_config_roms(void);
+
+/* Cleanup all config roms */
+void hpsb_cleanup_config_roms(void);
+
+/* Add extra config roms to specified host */
+int hpsb_add_extra_config_roms(struct hpsb_host *host);
+
+/* Remove extra config roms from specified host */
+void hpsb_remove_extra_config_roms(struct hpsb_host *host);
+
+
+/* List of flags to check if a host contains a certain extra config rom
+ * entry. Available in the host->config_roms member. */
+#define HPSB_CONFIG_ROM_ENTRY_IP1394		0x00000001
+
+#endif /* _IEEE1394_CONFIG_ROMS_H */
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/csr1212.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/csr1212.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/csr1212.c	2004-02-04 18:45:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/csr1212.c	2004-02-29 03:24:39.000000000 +0000
@@ -704,10 +704,11 @@ void _csr1212_destroy_keyval(struct csr1
 			if (k->key.type == CSR1212_KV_TYPE_DIRECTORY) {
 				/* If the current entry is a directory, then move all
 				 * the entries to the destruction list. */
-				tail->next = k->value.directory.dentries_head;
-				if (k->value.directory.dentries_head)
+				if (k->value.directory.dentries_head) {
+					tail->next = k->value.directory.dentries_head;
 					k->value.directory.dentries_head->prev = tail;
-				tail = k->value.directory.dentries_tail;
+					tail = k->value.directory.dentries_tail;
+                                }
 			}
 			free_keyval(k);
 			k = a;
@@ -1347,6 +1348,12 @@ int csr1212_parse_keyval(struct csr1212_
 	case CSR1212_KV_TYPE_DIRECTORY:
 		for (i = 0; i < kvi_len; i++) {
 			csr1212_quad_t ki = kvi->data[i];
+
+			/* Some devices put null entries in their unit
+			 * directories.  If we come across such and entry,
+			 * then skip it. */
+			if (ki == 0x0)
+				continue;
 			ret = csr1212_parse_dir_entry(kv, ki,
 						      (kv->offset +
 						       quads_to_bytes(i + 1)),
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/dv1394.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/dv1394.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/dv1394.c	2004-02-25 14:36:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/dv1394.c	2004-02-29 16:36:03.000000000 +0000
@@ -2222,7 +2222,7 @@ static int dv1394_init(struct ti_ohci *o
 	video->ohci = ohci;
 	/* lower 2 bits of id indicate which of four "plugs"
 	   per host */
-	video->id = ohci->id << 2; 
+	video->id = ohci->host->id << 2; 
 	if (format == DV1394_NTSC)
 		video->id |= mode;
 	else
@@ -2302,47 +2302,49 @@ static void dv1394_un_init(struct video_
 		);
 
 	devfs_remove("ieee1394/%s", buf);
-	list_del(&video->list);
 	kfree(video);
 }
 
 	
 static void dv1394_remove_host (struct hpsb_host *host)
 {
-	struct ti_ohci *ohci;
-	struct video_card *video = NULL;
+	struct video_card *video;
 	unsigned long flags;
-	struct list_head *lh, *templh;
-	int	n;
+	int id = host->id;
 	
 	/* We only work with the OHCI-1394 driver */
 	if (strcmp(host->driver->name, OHCI1394_DRIVER_NAME))
 		return;
 
-	ohci = (struct ti_ohci *)host->hostdata;
+	/* find the corresponding video_cards */
+	do {
+		struct video_card *tmp_vid;
 
+		video = NULL;
 
-	/* find the corresponding video_cards */
-	spin_lock_irqsave(&dv1394_cards_lock, flags);
-	if (!list_empty(&dv1394_cards)) {
-		list_for_each_safe(lh, templh, &dv1394_cards) {
-			video = list_entry(lh, struct video_card, list);
-			if ((video->id >> 2) == ohci->id)
-				dv1394_un_init(video);
+		spin_lock_irqsave(&dv1394_cards_lock, flags);
+		list_for_each_entry(tmp_vid, &dv1394_cards, list) {
+			if ((tmp_vid->id >> 2) == id) {
+				list_del(&tmp_vid->list);
+				video = tmp_vid;
+				break;
+			}
 		}
-	}
-	spin_unlock_irqrestore(&dv1394_cards_lock, flags);
+		spin_unlock_irqrestore(&dv1394_cards_lock, flags);
 
-	n = (video->id >> 2);
-
-	devfs_remove("ieee1394/dv/host%d/NTSC", n);
-	devfs_remove("ieee1394/dv/host%d/PAL", n);
-	devfs_remove("ieee1394/dv/host%d", n);
+		if (video)
+			dv1394_un_init(video);
+	} while (video != NULL);
+
+	devfs_remove("ieee1394/dv/host%d/NTSC", id);
+	devfs_remove("ieee1394/dv/host%d/PAL", id);
+	devfs_remove("ieee1394/dv/host%d", id);
 }
 
 static void dv1394_add_host (struct hpsb_host *host)
 {
 	struct ti_ohci *ohci;
+	int id = host->id;
 
 	/* We only work with the OHCI-1394 driver */
 	if (strcmp(host->driver->name, OHCI1394_DRIVER_NAME))
@@ -2350,9 +2352,9 @@ static void dv1394_add_host (struct hpsb
 
 	ohci = (struct ti_ohci *)host->hostdata;
 
-	devfs_mk_dir("ieee1394/dv/host%d", ohci->id);
-	devfs_mk_dir("ieee1394/dv/host%d/NTSC", ohci->id);
-	devfs_mk_dir("ieee1394/dv/host%d/PAL", ohci->id);
+	devfs_mk_dir("ieee1394/dv/host%d", id);
+	devfs_mk_dir("ieee1394/dv/host%d/NTSC", id);
+	devfs_mk_dir("ieee1394/dv/host%d/PAL", id);
 	
 	dv1394_init(ohci, DV1394_NTSC, MODE_RECEIVE);
 	dv1394_init(ohci, DV1394_NTSC, MODE_TRANSMIT);
@@ -2369,7 +2371,7 @@ static void dv1394_add_host (struct hpsb
 static void dv1394_host_reset(struct hpsb_host *host)
 {
 	struct ti_ohci *ohci;
-	struct video_card *video = NULL;
+	struct video_card *video = NULL, *tmp_vid;
 	unsigned long flags;
 	
 	/* We only work with the OHCI-1394 driver */
@@ -2381,10 +2383,10 @@ static void dv1394_host_reset(struct hps
 
 	/* find the corresponding video_cards */
 	spin_lock_irqsave(&dv1394_cards_lock, flags);
-	if (!list_empty(&dv1394_cards)) {
-		list_for_each_entry(video, &dv1394_cards, list) {
-			if ((video->id >> 2) == ohci->id)
-				break;
+	list_for_each_entry(tmp_vid, &dv1394_cards, list) {
+		if ((tmp_vid->id >> 2) == host->id) {
+			video = tmp_vid;
+			break;
 		}
 	}
 	spin_unlock_irqrestore(&dv1394_cards_lock, flags);
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/eth1394.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/eth1394.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/eth1394.c	2004-02-23 22:48:31.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/eth1394.c	2004-02-29 13:40:56.000000000 +0000
@@ -76,6 +76,7 @@
 #include "iso.h"
 #include "nodemgr.h"
 #include "eth1394.h"
+#include "config_roms.h"
 
 #define ETH1394_PRINT_G(level, fmt, args...) \
 	printk(level "%s: " fmt, driver_name, ## args)
@@ -88,7 +89,7 @@
 #define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 1133 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1175 $ Ben Collins <bcollins@debian.org>";
 
 struct fragment_info {
 	struct list_head list;
@@ -106,8 +107,6 @@ struct partial_datagram {
 	struct list_head frag_info;
 };
 
-static struct csr1212_keyval *eth1394_ud = NULL;
-
 struct pdg_list {
 	struct list_head list;		/* partial datagram list per node	*/
 	unsigned int sz;		/* partial datagram list size per node	*/
@@ -461,6 +460,8 @@ static struct ieee1394_device_id eth1394
 	{}
 };
 
+MODULE_DEVICE_TABLE(ieee1394, eth1394_id_table);
+
 static struct hpsb_protocol_driver eth1394_proto_driver = {
 	.name		= "IPv4 over 1394 Driver",
 	.id_table	= eth1394_id_table,
@@ -553,9 +554,11 @@ static void ether1394_add_host (struct h
 	struct net_device *dev = NULL;
 	struct eth1394_priv *priv;
 	static int version_printed = 0;
-
 	u64 fifo_addr;
 
+	if (!(host->config_roms & HPSB_CONFIG_ROM_ENTRY_IP1394))
+		return;
+
 	fifo_addr = hpsb_allocate_and_register_addrspace(&eth1394_highlevel,
 							 host,
 							 &addr_ops,
@@ -634,14 +637,6 @@ static void ether1394_add_host (struct h
 			priv->bc_state = ETHER1394_BC_RUNNING;
 	}
 
-	if (csr1212_attach_keyval_to_directory(host->csr.rom->root_kv,
-					       eth1394_ud) != CSR1212_SUCCESS) {
-		ETH1394_PRINT (KERN_ERR, dev->name,
-			       "Cannot attach IP 1394 Unit Directory to "
-			       "Config ROM\n");
-		goto out;
-	}
-	hi->host->update_config_rom = 1;
 	return;
 
 out:
@@ -668,10 +663,6 @@ static void ether1394_remove_host (struc
 		if (priv->iso != NULL) 
 			hpsb_iso_shutdown(priv->iso);
 
-		csr1212_detach_keyval_from_directory(hi->host->csr.rom->root_kv,
-						     eth1394_ud);
-		hi->host->update_config_rom = 1;
-
 		if (hi->dev) {
 			unregister_netdev (hi->dev);
 			free_netdev(hi->dev);
@@ -1483,7 +1474,6 @@ static inline struct hpsb_packet *ether1
 	p = hpsb_alloc_packet(0);
 	if (p) {
 		p->host = host;
-		p->data = NULL;
 		p->generation = get_hpsb_generation(host);
 		p->type = hpsb_async;
 	}
@@ -1514,7 +1504,7 @@ static inline int ether1394_prep_write_p
 		| (1 << 8) | (TCODE_WRITEB << 4);
 
 	p->header[3] = tx_len << 16;
-	p->data_size = tx_len + (tx_len % 4 ? 4 - (tx_len % 4) : 0);
+	p->data_size = (tx_len + 3) & ~3;
 	p->data = (quadlet_t*)data;
 
 	return 0;
@@ -1807,7 +1797,7 @@ static int ether1394_ethtool_ioctl(struc
 		case ETHTOOL_GDRVINFO: {
 			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
 			strcpy (info.driver, driver_name);
-			strcpy (info.version, "$Rev: 1133 $");
+			strcpy (info.version, "$Rev: 1175 $");
 			/* FIXME XXX provide sane businfo */
 			strcpy (info.bus_info, "ieee1394");
 			if (copy_to_user (useraddr, &info, sizeof (info)))
@@ -1830,67 +1820,13 @@ static int ether1394_ethtool_ioctl(struc
 
 static int __init ether1394_init_module (void)
 {
-	int ret;
-	struct csr1212_keyval *spec_id = NULL;
-	struct csr1212_keyval *spec_desc = NULL;
-	struct csr1212_keyval *ver = NULL;
-	struct csr1212_keyval *ver_desc = NULL;
-
 	packet_task_cache = kmem_cache_create("packet_task", sizeof(struct packet_task),
 					      0, 0, NULL, NULL);
 
-	eth1394_ud = csr1212_new_directory(CSR1212_KV_ID_UNIT);
-	spec_id = csr1212_new_immediate(CSR1212_KV_ID_SPECIFIER_ID,
-					ETHER1394_GASP_SPECIFIER_ID);
-	spec_desc = csr1212_new_string_descriptor_leaf("IANA");
-	ver = csr1212_new_immediate(CSR1212_KV_ID_VERSION,
-				    ETHER1394_GASP_VERSION);
-	ver_desc = csr1212_new_string_descriptor_leaf("IPv4");
-
-	if ((!eth1394_ud) ||
-	    (!spec_id) ||
-	    (!spec_desc) ||
-	    (!ver) ||
-	    (!ver_desc)) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	ret = csr1212_associate_keyval(spec_id, spec_desc);
-	if (ret != CSR1212_SUCCESS)
-		goto out;
-
-	ret = csr1212_associate_keyval(ver, ver_desc);
-	if (ret != CSR1212_SUCCESS)
-		goto out;
-
-	ret = csr1212_attach_keyval_to_directory(eth1394_ud, spec_id);
-	if (ret != CSR1212_SUCCESS)
-		goto out;
-
-	ret = csr1212_attach_keyval_to_directory(eth1394_ud, ver);
-	if (ret != CSR1212_SUCCESS)
-		goto out;
-
 	/* Register ourselves as a highlevel driver */
 	hpsb_register_highlevel(&eth1394_highlevel);
 
-	ret = hpsb_register_protocol(&eth1394_proto_driver);
-
-out:
-	if ((ret != 0) && eth1394_ud) {
-		csr1212_release_keyval(eth1394_ud);
-	}
-	if (spec_id)
-		csr1212_release_keyval(spec_id);
-	if (spec_desc)
-		csr1212_release_keyval(spec_desc);
-	if (ver)
-		csr1212_release_keyval(ver);
-	if (ver_desc)
-		csr1212_release_keyval(ver_desc);
-
-	return ret;
+	return hpsb_register_protocol(&eth1394_proto_driver);
 }
 
 static void __exit ether1394_exit_module (void)
@@ -1898,10 +1834,6 @@ static void __exit ether1394_exit_module
 	hpsb_unregister_protocol(&eth1394_proto_driver);
 	hpsb_unregister_highlevel(&eth1394_highlevel);
 	kmem_cache_destroy(packet_task_cache);
-
-	if (eth1394_ud) {
-		csr1212_release_keyval(eth1394_ud);
-	}
 }
 
 module_init(ether1394_init_module);
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/eth1394.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/eth1394.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/eth1394.h	2004-02-04 18:46:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/eth1394.h	2004-02-28 19:16:21.000000000 +0000
@@ -24,6 +24,8 @@
 #ifndef __ETH1394_H
 #define __ETH1394_H
 
+#include <linux/netdevice.h>
+
 #include "ieee1394.h"
 
 /* Register for incoming packets. This is 4096 bytes, which supports up to
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/hosts.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/hosts.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/hosts.c	2004-02-17 19:17:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/hosts.c	2004-02-28 19:16:22.000000000 +0000
@@ -27,6 +27,7 @@
 #include "highlevel.h"
 #include "nodemgr.h"
 #include "csr.h"
+#include "config_roms.h"
 
 
 static void delayed_reset_bus(unsigned long __reset_info)
@@ -103,6 +104,7 @@ static int alloc_hostnum_cb(struct hpsb_
  * Return Value: a pointer to the &hpsb_host if succesful, %NULL if
  * no memory was available.
  */
+static DECLARE_MUTEX(host_num_alloc);
 
 struct hpsb_host *hpsb_alloc_host(struct hpsb_host_driver *drv, size_t extra,
 				  struct device *dev)
@@ -148,14 +150,12 @@ struct hpsb_host *hpsb_alloc_host(struct
         h->topology_map = h->csr.topology_map + 3;
         h->speed_map = (u8 *)(h->csr.speed_map + 2);
 
-	while (1) {
-		if (!nodemgr_for_each_host(&hostnum, alloc_hostnum_cb)) {
-			h->id = hostnum;
-			break;
-		}
+	down(&host_num_alloc);
 
+	while (nodemgr_for_each_host(&hostnum, alloc_hostnum_cb))
 		hostnum++;
-	}
+
+	h->id = hostnum;
 
 	memcpy(&h->device, &nodemgr_dev_template_host, sizeof(h->device));
 	h->device.parent = dev;
@@ -169,12 +169,21 @@ struct hpsb_host *hpsb_alloc_host(struct
 	class_device_register(&h->class_dev);
 	get_device(&h->device);
 
+	up(&host_num_alloc);
+
 	return h;
 }
 
-void hpsb_add_host(struct hpsb_host *host)
+int hpsb_add_host(struct hpsb_host *host)
 {
-        highlevel_add_host(host);
+	if (hpsb_default_host_entry(host))
+		return -ENOMEM;
+
+	hpsb_add_extra_config_roms(host);
+
+	highlevel_add_host(host);
+
+	return 0;
 }
 
 void hpsb_remove_host(struct hpsb_host *host)
@@ -184,6 +193,8 @@ void hpsb_remove_host(struct hpsb_host *
 
         highlevel_remove_host(host);
 
+	hpsb_remove_extra_config_roms(host);
+
 	class_device_unregister(&host->class_dev);
 	device_unregister(&host->device);
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/hosts.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/hosts.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/hosts.h	2004-02-17 19:17:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/hosts.h	2004-02-28 19:16:23.000000000 +0000
@@ -66,6 +66,8 @@ struct hpsb_host {
 	int update_config_rom;
 	struct timer_list delayed_reset;
 
+	unsigned int config_roms;
+
 	struct list_head addr_space;
 };
 
@@ -191,7 +193,7 @@ struct hpsb_host_driver {
 
 struct hpsb_host *hpsb_alloc_host(struct hpsb_host_driver *drv, size_t extra,
 				  struct device *dev);
-void hpsb_add_host(struct hpsb_host *host);
+int hpsb_add_host(struct hpsb_host *host);
 void hpsb_remove_host(struct hpsb_host *h);
 
 /* The following 2 functions are deprecated and will be removed when the
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394.h	2003-06-15 13:04:31.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394.h	2004-02-27 13:18:57.000000000 +0000
@@ -36,8 +36,11 @@
 #define ACK_BUSY_X               0x4
 #define ACK_BUSY_A               0x5
 #define ACK_BUSY_B               0x6
+#define ACK_TARDY                0xb
+#define ACK_CONFLICT_ERROR       0xc
 #define ACK_DATA_ERROR           0xd
 #define ACK_TYPE_ERROR           0xe 
+#define ACK_ADDRESS_ERROR        0xf
 
 /* Non-standard "ACK codes" for internal use */
 #define ACKX_NONE                (-1)
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_core.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_core.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_core.c	2004-02-24 00:27:21.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_core.c	2004-02-29 14:30:15.000000000 +0000
@@ -44,6 +44,7 @@
 #include "nodemgr.h"
 #include "dma.h"
 #include "iso.h"
+#include "config_roms.h"
 
 /*
  * Disable the nodemgr detection and config rom reading functionality.
@@ -92,7 +93,7 @@ static void queue_packet_complete(struct
 void hpsb_set_packet_complete_task(struct hpsb_packet *packet,
 				   void (*routine)(void *), void *data)
 {
-	BUG_ON(packet->complete_routine != NULL);
+	WARN_ON(packet->complete_routine != NULL);
 	packet->complete_routine = routine;
 	packet->complete_data = data;
 	return;
@@ -120,34 +121,35 @@ void hpsb_set_packet_complete_task(struc
  */
 struct hpsb_packet *hpsb_alloc_packet(size_t data_size)
 {
-        struct hpsb_packet *packet = NULL;
-        void *data = NULL;
-
-        packet = kmem_cache_alloc(hpsb_packet_cache, GFP_ATOMIC);
-        if (packet == NULL)
-                return NULL;
-
-        memset(packet, 0, sizeof(struct hpsb_packet));
-        packet->header = packet->embedded_header;
-
-        if (data_size) {
-                data = kmalloc(data_size + 8, GFP_ATOMIC);
-                if (data == NULL) {
+	struct hpsb_packet *packet = NULL;
+	void *data = NULL;
+	int gfp_flags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+
+	packet = kmem_cache_alloc(hpsb_packet_cache, gfp_flags);
+	if (packet == NULL)
+		return NULL;
+
+	memset(packet, 0, sizeof(*packet));
+
+	packet->header = packet->embedded_header;
+	INIT_LIST_HEAD(&packet->list);
+	packet->state = hpsb_unused;
+	packet->generation = -1;
+	atomic_set(&packet->refcnt, 1);
+
+	if (data_size) {
+		data_size = (data_size + 3) & ~3;
+		data = kmalloc(data_size + 8, gfp_flags);
+		if (data == NULL) {
 			kmem_cache_free(hpsb_packet_cache, packet);
-                        return NULL;
-                }
-
-                packet->data = data;
-                packet->data_size = data_size;
-        }
+			return NULL;
+		}
 
-        INIT_LIST_HEAD(&packet->list);
-	packet->complete_routine = NULL;
-	packet->complete_data = NULL;
-        packet->state = hpsb_unused;
-        packet->generation = -1;
+		packet->data = data;
+		packet->data_size = data_size;
+	}
 
-        return packet;
+	return packet;
 }
 
 
@@ -155,15 +157,14 @@ struct hpsb_packet *hpsb_alloc_packet(si
  * hpsb_free_packet - free packet and data associated with it
  * @packet: packet to free (is NULL safe)
  *
- * This function will free packet->data, packet->header and finally the packet
- * itself.
+ * This function will free packet->data and finally the packet itself.
  */
 void hpsb_free_packet(struct hpsb_packet *packet)
 {
-        if (!packet) return;
-
-        kfree(packet->data);
-        kmem_cache_free(hpsb_packet_cache, packet);
+	if (packet && atomic_dec_and_test(&packet->refcnt)) {
+		kfree(packet->data);
+		kmem_cache_free(hpsb_packet_cache, packet);
+	}
 }
 
 
@@ -402,28 +403,30 @@ void hpsb_selfid_complete(struct hpsb_ho
 void hpsb_packet_sent(struct hpsb_host *host, struct hpsb_packet *packet, 
                       int ackcode)
 {
-        unsigned long flags;
-
-        packet->ack_code = ackcode;
+	packet->ack_code = ackcode;
 
-        if (packet->no_waiter) {
-                /* must not have a tlabel allocated */
-                hpsb_free_packet(packet);
-                return;
-        }
+	if (packet->no_waiter) {
+		/* must not have a tlabel allocated */
+		hpsb_free_packet(packet);
+		return;
+	}
 
-        if (ackcode != ACK_PENDING || !packet->expect_response) {
-                packet->state = hpsb_complete;
-                queue_packet_complete(packet);
-                return;
-        }
+	if (ackcode != ACK_PENDING || !packet->expect_response) {
+		atomic_dec(&packet->refcnt);
+		list_del(&packet->list);
+		packet->state = hpsb_complete;
+		queue_packet_complete(packet);
+		return;
+	}
 
-        packet->state = hpsb_pending;
-        packet->sendtime = jiffies;
+	if (packet->state == hpsb_complete) {
+		hpsb_free_packet(packet);
+		return;
+	}
 
-        spin_lock_irqsave(&host->pending_pkt_lock, flags);
-        list_add_tail(&packet->list, &host->pending_packets);
-        spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+	atomic_dec(&packet->refcnt);
+	packet->state = hpsb_pending;
+	packet->sendtime = jiffies;
 
 	mod_timer(&host->timeout, jiffies + host->timeout_interval);
 }
@@ -492,7 +495,7 @@ int hpsb_send_phy_config(struct hpsb_hos
  */
 int hpsb_send_packet(struct hpsb_packet *packet)
 {
-        struct hpsb_host *host = packet->host;
+	struct hpsb_host *host = packet->host;
 
         if (host->is_shutdown)
 		return -EINVAL;
@@ -502,6 +505,15 @@ int hpsb_send_packet(struct hpsb_packet 
 
         packet->state = hpsb_queued;
 
+	if (!packet->no_waiter || packet->expect_response) {
+		unsigned long flags;
+
+		atomic_inc(&packet->refcnt);
+		spin_lock_irqsave(&host->pending_pkt_lock, flags);
+		list_add_tail(&packet->list, &host->pending_packets);
+		spin_unlock_irqrestore(&host->pending_pkt_lock, flags);
+	}
+
         if (packet->node_id == host->node_id)
         { /* it is a local request, so handle it locally */
                 quadlet_t *data;
@@ -658,7 +670,12 @@ void handle_packet_response(struct hpsb_
                 break;
         }
 
-        packet->state = hpsb_complete;
+	if (packet->state == hpsb_queued) {
+		packet->sendtime = jiffies;
+		packet->ack_code = ACK_PENDING;
+	}
+
+	packet->state = hpsb_complete;
 	queue_packet_complete(packet);
 }
 
@@ -1024,10 +1041,16 @@ static int hpsbpkt_thread(void *__hi)
 	complete_and_exit(&khpsbpkt_complete, 0);
 }
 
+
 static int __init ieee1394_init(void)
 {
 	int i;
 
+	if (hpsb_init_config_roms()) {
+		HPSB_ERR("Failed to initialize some config rom entries.\n");
+		HPSB_ERR("Some features may not be available\n");
+	}
+
 	khpsbpkt_pid = kernel_thread(hpsbpkt_thread, NULL, CLONE_KERNEL);
 	if (khpsbpkt_pid < 0) {
 		HPSB_ERR("Failed to start hpsbpkt thread!\n");
@@ -1044,7 +1067,7 @@ static int __init ieee1394_init(void)
 	devfs_mk_dir("ieee1394");
 
 	hpsb_packet_cache = kmem_cache_create("hpsb_packet", sizeof(struct hpsb_packet),
-					      0, 0, NULL, NULL);
+					      0, SLAB_HWCACHE_ALIGN, NULL, NULL);
 
 	bus_register(&ieee1394_bus_type);
 	for (i = 0; fw_bus_attrs[i]; i++)
@@ -1083,6 +1106,8 @@ static void __exit ieee1394_cleanup(void
 
 	kmem_cache_destroy(hpsb_packet_cache);
 
+	hpsb_cleanup_config_roms();
+
 	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
 	devfs_remove("ieee1394");
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_core.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_core.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_core.h	2004-02-17 19:17:59.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_core.h	2004-02-26 20:51:29.000000000 +0000
@@ -4,6 +4,7 @@
 
 #include <linux/slab.h>
 #include <linux/devfs_fs_kernel.h>
+#include <asm/atomic.h>
 #include <asm/semaphore.h>
 #include "hosts.h"
 
@@ -59,6 +60,8 @@ struct hpsb_packet {
         struct hpsb_host *host;
         unsigned int generation;
 
+	atomic_t refcnt;
+
 	/* Function (and possible data to pass to it) to call when this
 	 * packet is completed.  */
 	void (*complete_routine)(void *);
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_transactions.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_transactions.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ieee1394_transactions.c	2003-12-24 14:44:25.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ieee1394_transactions.c	2004-02-28 02:27:01.000000000 +0000
@@ -239,6 +239,11 @@ int hpsb_packet_success(struct hpsb_pack
                         return -EAGAIN;
                 }
 
+        case ACK_ADDRESS_ERROR:
+                return -EINVAL;
+
+        case ACK_TARDY:
+        case ACK_CONFLICT_ERROR:
         case ACKX_NONE:
         case ACKX_SEND_ERROR:
         case ACKX_ABORTED:
@@ -263,7 +268,7 @@ struct hpsb_packet *hpsb_make_readpacket
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet(length + (length % 4 ? 4 - (length % 4) : 0));
+	packet = hpsb_alloc_packet((length + 3) & ~3);
 	if (!packet)
 		return NULL;
 
@@ -291,7 +296,7 @@ struct hpsb_packet *hpsb_make_writepacke
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet(length + (length % 4 ? 4 - (length % 4) : 0));
+	packet = hpsb_alloc_packet((length + 3) & ~3);
 	if (!packet)
 		return NULL;
 
@@ -325,7 +330,7 @@ struct hpsb_packet *hpsb_make_streampack
 	if (length == 0)
 		return NULL;
 
-	packet = hpsb_alloc_packet(length + (length % 4 ? 4 - (length % 4) : 0));
+	packet = hpsb_alloc_packet((length + 3) & ~3);
 	if (!packet)
 		return NULL;
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/nodemgr.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/nodemgr.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/nodemgr.c	2004-02-25 14:41:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/nodemgr.c	2004-03-02 04:27:36.000000000 +0000
@@ -79,7 +79,7 @@ static int nodemgr_bus_read(struct csr12
 
 static int nodemgr_get_max_rom(quadlet_t *bus_info_data, void *__ci)
 {
-	return (bus_info_data[2] >> 8) & 0x3;
+	return (CSR1212_BE32_TO_CPU(bus_info_data[2]) >> 8) & 0x3;
 }
 
 static struct csr1212_bus_ops nodemgr_csr_ops = {
@@ -1286,18 +1286,19 @@ static void nodemgr_resume_ne(struct nod
 }
 
 
-static void nodemgr_ud_update_pdrv(struct unit_directory *ud)
+static void nodemgr_update_pdrv(struct node_entry *ne)
 {
-	struct device *dev;
+	struct unit_directory *ud;
 	struct hpsb_protocol_driver *pdrv;
+	struct class *class = &nodemgr_ud_class;
+	struct class_device *cdev;
 
-	if (!get_device(&ud->device))
-		return;
-
-	list_for_each_entry(dev, &ud->device.children, node)
-		nodemgr_ud_update_pdrv(container_of(dev, struct unit_directory, device));
+	down_read(&class->subsys.rwsem);
+	list_for_each_entry(cdev, &class->children, node) {
+		ud = container_of(cdev, struct unit_directory, class_dev);
+		if (ud->ne != ne || !ud->device.driver)
+			continue;
 
-	if (ud->device.driver) {
 		pdrv = container_of(ud->device.driver, struct hpsb_protocol_driver, driver);
 
 		if (pdrv->update && pdrv->update(ud)) {
@@ -1306,14 +1307,13 @@ static void nodemgr_ud_update_pdrv(struc
 			up_write(&ud->device.bus->subsys.rwsem);
 		}
 	}
-
-	put_device(&ud->device);
+	up_read(&class->subsys.rwsem);
 }
 
 
 static void nodemgr_probe_ne(struct host_info *hi, struct node_entry *ne, int generation)
 {
-	struct device *dev, *udev;
+	struct device *dev;
 
 	if (ne->host != hi->host || ne->in_limbo)
 		return;
@@ -1330,8 +1330,7 @@ static void nodemgr_probe_ne(struct host
 	if (ne->needs_probe)
 		nodemgr_process_root_directory(hi, ne);
 	else if (ne->generation == generation)
-		list_for_each_entry(udev, &dev->children, node)
-			nodemgr_ud_update_pdrv(container_of(udev, struct unit_directory, device));
+		nodemgr_update_pdrv(ne);
 	else
 		nodemgr_suspend_ne(ne);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ohci1394.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/ohci1394.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ohci1394.c	2004-02-24 00:36:16.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ohci1394.c	2004-02-29 18:29:18.000000000 +0000
@@ -134,10 +134,10 @@
 #endif
 
 #ifdef OHCI1394_DEBUG
-#define DBGMSG(card, fmt, args...) \
-printk(KERN_INFO "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, card , ## args)
+#define DBGMSG(fmt, args...) \
+printk(KERN_INFO "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 #else
-#define DBGMSG(card, fmt, args...)
+#define DBGMSG(fmt, args...)
 #endif
 
 #ifdef CONFIG_IEEE1394_OHCI_DMA_DEBUG
@@ -158,11 +158,11 @@ static int global_outstanding_dmas = 0;
 printk(level "%s: " fmt "\n" , OHCI1394_DRIVER_NAME , ## args)
 
 /* print card specific information */
-#define PRINT(level, card, fmt, args...) \
-printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, card , ## args)
+#define PRINT(level, fmt, args...) \
+printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 static char version[] __devinitdata =
-	"$Rev: 1131 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1172 $ Ben Collins <bcollins@debian.org>";
 
 /* Module Parameters */
 static int phys_dma = 1;
@@ -241,7 +241,7 @@ static u8 get_phy_reg(struct ti_ohci *oh
 	r = reg_read(ohci, OHCI1394_PhyControl);
 
 	if (i >= OHCI_LOOP_COUNT)
-		PRINT (KERN_ERR, ohci->id, "Get PHY Reg timeout [0x%08x/0x%08x/%d]",
+		PRINT (KERN_ERR, "Get PHY Reg timeout [0x%08x/0x%08x/%d]",
 		       r, r & 0x80000000, i);
   
 	spin_unlock_irqrestore (&ohci->phy_reg_lock, flags);
@@ -268,7 +268,7 @@ static void set_phy_reg(struct ti_ohci *
 	}
 
 	if (i == OHCI_LOOP_COUNT)
-		PRINT (KERN_ERR, ohci->id, "Set PHY Reg timeout [0x%08x/0x%08x/%d]",
+		PRINT (KERN_ERR, "Set PHY Reg timeout [0x%08x/0x%08x/%d]",
 		       r, r & 0x00004000, i);
 
 	spin_unlock_irqrestore (&ohci->phy_reg_lock, flags);
@@ -305,7 +305,7 @@ static void handle_selfid(struct ti_ohci
 
 	if ((self_id_count & 0x80000000) || 
 	    ((self_id_count & 0x00FF0000) != (q0 & 0x00FF0000))) {
-		PRINT(KERN_ERR, ohci->id, 
+		PRINT(KERN_ERR,
 		      "Error in reception of SelfID packets [0x%08x/0x%08x] (count: %d)",
 		      self_id_count, q0, ohci->self_id_errors);
 
@@ -315,7 +315,7 @@ static void handle_selfid(struct ti_ohci
 			set_phy_reg_mask (ohci, 1, 0x40);
 			ohci->self_id_errors++;
 		} else {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "Too many errors on SelfID error reception, giving up!");
 		}
 		return;
@@ -337,19 +337,19 @@ static void handle_selfid(struct ti_ohci
 		}
 		
 		if (q0 == ~q1) {
-			DBGMSG (ohci->id, "SelfID packet 0x%x received", q0);
+			DBGMSG ("SelfID packet 0x%x received", q0);
 			hpsb_selfid_received(host, cpu_to_be32(q0));
 			if (((q0 & 0x3f000000) >> 24) == phyid)
-				DBGMSG (ohci->id, "SelfID for this node is 0x%08x", q0);
+				DBGMSG ("SelfID for this node is 0x%08x", q0);
 		} else {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR,
 			      "SelfID is inconsistent [0x%08x/0x%08x]", q0, q1);
 		}
 		q += 2;
 		size -= 2;
 	}
 
-	DBGMSG(ohci->id, "SelfID complete");
+	DBGMSG("SelfID complete");
 
 	return;
 }
@@ -364,7 +364,7 @@ static void ohci_soft_reset(struct ti_oh
 			break;
 		mdelay(1);
 	}
-	DBGMSG (ohci->id, "Soft reset finished");
+	DBGMSG ("Soft reset finished");
 }
 
 static int run_context(struct ti_ohci *ohci, int reg, char *msg)
@@ -374,14 +374,14 @@ static int run_context(struct ti_ohci *o
 	/* check that the node id is valid */
 	nodeId = reg_read(ohci, OHCI1394_NodeID);
 	if (!(nodeId&0x80000000)) {
-		PRINT(KERN_ERR, ohci->id, 
+		PRINT(KERN_ERR,
 		      "Running dma failed because Node ID is not valid");
 		return -1;
 	}
 
 	/* check that the node number != 63 */
 	if ((nodeId&0x3f)==63) {
-		PRINT(KERN_ERR, ohci->id, 
+		PRINT(KERN_ERR,
 		      "Running dma failed because Node ID == 63");
 		return -1;
 	}
@@ -389,7 +389,7 @@ static int run_context(struct ti_ohci *o
 	/* Run the dma context */
 	reg_write(ohci, reg, 0x8000);
 
-	if (msg) PRINT(KERN_DEBUG, ohci->id, "%s", msg);
+	if (msg) PRINT(KERN_DEBUG, "%s", msg);
 
 	return 0;
 }
@@ -451,7 +451,7 @@ static void initialize_dma_rcv_ctx(struc
 	/* Run context */
 	reg_write(ohci, d->ctrlSet, 0x00008000);
 
-	DBGMSG(ohci->id, "Receive DMA ctx=%d initialized", d->ctx);
+	DBGMSG("Receive DMA ctx=%d initialized", d->ctx);
 }
 
 /* Initialize the dma transmit context */
@@ -474,7 +474,7 @@ static void initialize_dma_trm_ctx(struc
 		reg_write(ohci, OHCI1394_IsoXmitIntMaskSet, 1 << d->ctx);
 	}
 
-	DBGMSG(ohci->id, "Transmit DMA ctx=%d initialized", d->ctx);
+	DBGMSG("Transmit DMA ctx=%d initialized", d->ctx);
 }
 
 /* Count the number of available iso contexts */
@@ -486,7 +486,7 @@ static int get_nb_iso_ctx(struct ti_ohci
 	reg_write(ohci, reg, 0xffffffff);
 	tmp = reg_read(ohci, reg);
 
-	DBGMSG(ohci->id,"Iso contexts reg: %08x implemented: %08x", reg, tmp);
+	DBGMSG("Iso contexts reg: %08x implemented: %08x", reg, tmp);
 
 	/* Count the number of contexts */
 	for (i=0; i<32; i++) {
@@ -600,7 +600,7 @@ static void ohci_initialize(struct ti_oh
 #else
 	sprintf (irq_buf, "%s", __irq_itoa(ohci->dev->irq));
 #endif
-	PRINT(KERN_INFO, ohci->id, "OHCI-1394 %d.%d (PCI): IRQ=[%s]  "
+	PRINT(KERN_INFO, "OHCI-1394 %d.%d (PCI): IRQ=[%s]  "
 	      "MMIO=[%lx-%lx]  Max Packet=[%d]",
 	      ((((buf) >> 16) & 0xf) + (((buf) >> 20) & 0xf) * 10),
 	      ((((buf) >> 4) & 0xf) + ((buf) & 0xf) * 10), irq_buf,
@@ -635,7 +635,7 @@ static void insert_packet(struct ti_ohci
 	u32 cycleTimer;
 	int idx = d->prg_ind;
 
-	DBGMSG(ohci->id, "Inserting packet for node " NODE_BUS_FMT
+	DBGMSG("Inserting packet for node " NODE_BUS_FMT
 	       ", tlabel=%d, tcode=0x%x, speed=%d",
 	       NODE_BUS_ARGS(ohci->host, packet->node_id), packet->tlabel,
 	       packet->tcode, packet->speed_code);
@@ -653,7 +653,7 @@ static void insert_packet(struct ti_ohci
 			(((((cycleTimer>>25)&0x7)+1)&0x7)<<13) | 
 			((cycleTimer&0x01fff000)>>12));
 
-		DBGMSG(ohci->id, "cycleTimer: %08x timeStamp: %08x",
+		DBGMSG("cycleTimer: %08x timeStamp: %08x",
 		       cycleTimer, d->prg_cpu[idx]->begin.status);
 	} else 
 		d->prg_cpu[idx]->begin.status = 0;
@@ -709,7 +709,7 @@ static void insert_packet(struct ti_ohci
                         if (cross_bound((unsigned long)packet->data, 
                                         packet->data_size)>0) {
                                 /* FIXME: do something about it */
-                                PRINT(KERN_ERR, ohci->id,
+                                PRINT(KERN_ERR,
                                       "%s: packet data addr: %p size %Zd bytes "
                                       "cross page boundary", __FUNCTION__,
                                       packet->data, packet->data_size);
@@ -773,7 +773,7 @@ static void insert_packet(struct ti_ohci
 
                 d->prg_cpu[idx]->end.branchAddress = 0;
                 d->prg_cpu[idx]->end.status = 0;
-                DBGMSG(ohci->id, "Iso xmit context info: header[%08x %08x]\n"
+                DBGMSG("Iso xmit context info: header[%08x %08x]\n"
                        "                       begin=%08x %08x %08x %08x\n"
                        "                             %08x %08x %08x %08x\n"
                        "                       end  =%08x %08x %08x %08x",
@@ -827,19 +827,19 @@ static int dma_trm_flush(struct ti_ohci 
 	}
 
 	if (d->free_prgs == 0)
-		DBGMSG(ohci->id, "Transmit DMA FIFO ctx=%d is full... waiting", d->ctx);
+		DBGMSG("Transmit DMA FIFO ctx=%d is full... waiting", d->ctx);
 
 	/* Is the context running ? (should be unless it is 
 	   the first packet to be sent in this context) */
 	if (!(reg_read(ohci, d->ctrlSet) & 0x8000)) {
-		DBGMSG(ohci->id,"Starting transmit DMA ctx=%d",d->ctx);
+		DBGMSG("Starting transmit DMA ctx=%d",d->ctx);
 		reg_write(ohci, d->cmdPtr, d->prg_bus[idx]|z);
 		run_context(ohci, d->ctrlSet, NULL);
 	}
 	else {
 		/* Wake up the dma context if necessary */
 		if (!(reg_read(ohci, d->ctrlSet) & 0x400)) {
-			DBGMSG(ohci->id,"Waking transmit DMA ctx=%d",d->ctx);
+			DBGMSG("Waking transmit DMA ctx=%d",d->ctx);
 		}
 
 		/* do this always, to avoid race condition */
@@ -856,7 +856,7 @@ static int ohci_transmit(struct hpsb_hos
 	unsigned long flags;
 
 	if (packet->data_size > ohci->max_packet_size) {
-		PRINT(KERN_ERR, ohci->id, 
+		PRINT(KERN_ERR,
 		      "Transmit packet size %Zd is too big",
 		      packet->data_size);
 		return -EOVERFLOW;
@@ -874,7 +874,7 @@ static int ohci_transmit(struct hpsb_hos
 		
 		if (ohci->it_legacy_context.ohci == NULL) {
 			if (in_interrupt()) {
-				PRINT(KERN_ERR, ohci->id, 
+				PRINT(KERN_ERR,
 				      "legacy IT context cannot be initialized during interrupt");
 				return -EINVAL;
 			}
@@ -882,7 +882,7 @@ static int ohci_transmit(struct hpsb_hos
 			if (alloc_dma_trm_ctx(ohci, &ohci->it_legacy_context,
 					      DMA_CTX_ISO, 0, IT_NUM_DESC,
 					      OHCI1394_IsoXmitContextBase) < 0) {
-				PRINT(KERN_ERR, ohci->id, 
+				PRINT(KERN_ERR,
 				      "error initializing legacy IT context");
 				return -ENOMEM;
 			}
@@ -974,7 +974,7 @@ static int ohci_devctl(struct hpsb_host 
 		break;
 
 	case SET_BUS_ID:
-		PRINT(KERN_ERR, ohci->id, "devctl command SET_BUS_ID err");
+		PRINT(KERN_ERR, "devctl command SET_BUS_ID err");
 		break;
 
 	case ACT_CYCLE_MASTER:
@@ -985,7 +985,7 @@ static int ohci_devctl(struct hpsb_host 
 				/*
 				 * enable cycleTimer, cycleMaster
 				 */
-				DBGMSG(ohci->id, "Cycle master enabled");
+				DBGMSG("Cycle master enabled");
 				reg_write(ohci, OHCI1394_LinkControlSet, 
 					  OHCI1394_LinkControl_CycleTimerEnable |
 					  OHCI1394_LinkControl_CycleMaster);
@@ -1000,7 +1000,7 @@ static int ohci_devctl(struct hpsb_host 
 		break;
 
 	case CANCEL_REQUESTS:
-		DBGMSG(ohci->id, "Cancel request received");
+		DBGMSG("Cancel request received");
 		dma_trm_reset(&ohci->at_req_context);
 		dma_trm_reset(&ohci->at_resp_context);
 		break;
@@ -1010,7 +1010,7 @@ static int ohci_devctl(struct hpsb_host 
 		u64 mask;
 
 		if (arg<0 || arg>63) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR,
 			      "%s: IS0 listen channel %d is out of range", 
 			      __FUNCTION__, arg);
 			return -EFAULT;
@@ -1022,14 +1022,14 @@ static int ohci_devctl(struct hpsb_host 
 					      DMA_CTX_ISO, 0, IR_NUM_DESC,
 					      IR_BUF_SIZE, IR_SPLIT_BUF_SIZE,
 					      OHCI1394_IsoRcvContextBase) < 0) {
-				PRINT(KERN_ERR, ohci->id, "%s: failed to allocate an IR context",
+				PRINT(KERN_ERR, "%s: failed to allocate an IR context",
 				      __FUNCTION__);
 				return -ENOMEM;
 			}
 			ohci->ir_legacy_channels = 0;
 			initialize_dma_rcv_ctx(&ohci->ir_legacy_context, 1);
 
-			DBGMSG(ohci->id, "ISO receive legacy context activated");
+			DBGMSG("ISO receive legacy context activated");
 		}
 
 		mask = (u64)0x1<<arg;
@@ -1037,7 +1037,7 @@ static int ohci_devctl(struct hpsb_host 
                 spin_lock_irqsave(&ohci->IR_channel_lock, flags);
 
 		if (ohci->ISO_channel_usage & mask) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR,
 			      "%s: IS0 listen channel %d is already used", 
 			      __FUNCTION__, arg);
 			spin_unlock_irqrestore(&ohci->IR_channel_lock, flags);
@@ -1055,7 +1055,7 @@ static int ohci_devctl(struct hpsb_host 
 				  1<<arg);			
 
                 spin_unlock_irqrestore(&ohci->IR_channel_lock, flags);
-                DBGMSG(ohci->id, "Listening enabled on channel %d", arg);
+                DBGMSG("Listening enabled on channel %d", arg);
                 break;
         }
 	case ISO_UNLISTEN_CHANNEL:
@@ -1063,7 +1063,7 @@ static int ohci_devctl(struct hpsb_host 
 		u64 mask;
 
 		if (arg<0 || arg>63) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR,
 			      "%s: IS0 unlisten channel %d is out of range", 
 			      __FUNCTION__, arg);
 			return -EFAULT;
@@ -1074,7 +1074,7 @@ static int ohci_devctl(struct hpsb_host 
                 spin_lock_irqsave(&ohci->IR_channel_lock, flags);
 
 		if (!(ohci->ISO_channel_usage & mask)) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR,
 			      "%s: IS0 unlisten channel %d is not used", 
 			      __FUNCTION__, arg);
 			spin_unlock_irqrestore(&ohci->IR_channel_lock, flags);
@@ -1092,12 +1092,12 @@ static int ohci_devctl(struct hpsb_host 
 				  1<<arg);			
 
                 spin_unlock_irqrestore(&ohci->IR_channel_lock, flags);
-                DBGMSG(ohci->id, "Listening disabled on channel %d", arg);
+                DBGMSG("Listening disabled on channel %d", arg);
 
 		if (ohci->ir_legacy_channels == 0) {
 			stop_dma_rcv_ctx(&ohci->ir_legacy_context);
 			free_dma_rcv_ctx(&ohci->ir_legacy_context);
-			DBGMSG(ohci->id, "ISO receive legacy context deactivated");
+			DBGMSG("ISO receive legacy context deactivated");
 		}
                 break;
         }
@@ -1209,7 +1209,7 @@ static int ohci_iso_recv_init(struct hps
 		/* one block per page of data in the DMA buffer, minus the final guard page */
 		recv->nblocks = iso->buf_size/PAGE_SIZE - 1;
 		if (recv->nblocks < 3) {
-			DBGMSG(ohci->id, "ohci_iso_recv_init: DMA buffer too small");
+			DBGMSG("ohci_iso_recv_init: DMA buffer too small");
 			goto err;
 		}
 
@@ -1245,7 +1245,7 @@ static int ohci_iso_recv_init(struct hps
 		if (recv->buf_stride*iso->buf_packets > iso->buf_size ||
 		   recv->buf_stride > PAGE_SIZE) {
 			/* this shouldn't happen, but anyway... */
-			DBGMSG(ohci->id, "ohci_iso_recv_init: problem choosing a buffer stride");
+			DBGMSG("ohci_iso_recv_init: problem choosing a buffer stride");
 			goto err;
 		}
 	}
@@ -1289,7 +1289,7 @@ static int ohci_iso_recv_init(struct hps
 	/* write the DMA program */
 	ohci_iso_recv_program(iso);
 
-	DBGMSG(ohci->id, "ohci_iso_recv_init: %s mode, DMA buffer is %lu pages"
+	DBGMSG("ohci_iso_recv_init: %s mode, DMA buffer is %lu pages"
 	       " (%u bytes), using %u blocks, buf_stride %u, block_irq_interval %d",
 	       recv->dma_mode == BUFFER_FILL_MODE ?
 	       "buffer-fill" : "packet-per-buffer",
@@ -1430,6 +1430,7 @@ static void ohci_iso_recv_set_channel_ma
 static int ohci_iso_recv_start(struct hpsb_iso *iso, int cycle, int tag_mask, int sync)
 {
 	struct ohci_iso_recv *recv = iso->hostdata;
+	struct ti_ohci *ohci = recv->ohci;
 	u32 command, contextMatch;
 
 	reg_write(recv->ohci, recv->ContextControlClear, 0xFFFFFFFF);
@@ -1508,7 +1509,7 @@ static int ohci_iso_recv_start(struct hp
 
 	/* check RUN */
 	if (!(reg_read(recv->ohci, recv->ContextControlSet) & 0x8000)) {
-		PRINT(KERN_ERR, recv->ohci->id,
+		PRINT(KERN_ERR,
 		      "Error starting IR DMA (ContextControl 0x%08x)\n",
 		      reg_read(recv->ohci, recv->ContextControlSet));
 		return -1;
@@ -1591,6 +1592,7 @@ static void ohci_iso_recv_bufferfill_par
 {
 	int wake = 0;
 	int runaway = 0;
+	struct ti_ohci *ohci = recv->ohci;
 		
 	while (1) {
 		/* we expect the next parsable packet to begin at recv->dma_offset */
@@ -1607,7 +1609,7 @@ static void ohci_iso_recv_bufferfill_par
 		/* don't loop indefinitely */
 		if (runaway++ > 100000) {
 			atomic_inc(&iso->overflows);
-			PRINT(KERN_ERR, recv->ohci->id,
+			PRINT(KERN_ERR,
 			      "IR DMA error - Runaway during buffer parsing!\n");
 			break;
 		}
@@ -1626,7 +1628,7 @@ static void ohci_iso_recv_bufferfill_par
 		len = p[recv->dma_offset+2] | (p[recv->dma_offset+3] << 8);
 
 		if (len > 4096) {
-			PRINT(KERN_ERR, recv->ohci->id,
+			PRINT(KERN_ERR,
 			      "IR DMA error - bogus 'len' value %u\n", len);
 		}
 		
@@ -1694,6 +1696,7 @@ static void ohci_iso_recv_bufferfill_par
 static void ohci_iso_recv_bufferfill_task(struct hpsb_iso *iso, struct ohci_iso_recv *recv)
 {
 	int loop;
+	struct ti_ohci *ohci = recv->ohci;
 
 	/* loop over all blocks */
 	for (loop = 0; loop < recv->nblocks; loop++) {
@@ -1716,7 +1719,7 @@ static void ohci_iso_recv_bufferfill_tas
 
 		if (event != 0x11) {
 			atomic_inc(&iso->overflows);
-			PRINT(KERN_ERR, recv->ohci->id,
+			PRINT(KERN_ERR,
 			      "IR DMA error - OHCI error code 0x%02x\n", event);
 		}
 
@@ -1739,7 +1742,7 @@ static void ohci_iso_recv_bufferfill_tas
 
 		if ((recv->block_dma+1) % recv->nblocks == recv->block_reader) {
 			atomic_inc(&iso->overflows);
-			DBGMSG(recv->ohci->id, "ISO reception overflow - "
+			DBGMSG("ISO reception overflow - "
 			       "ran out of DMA blocks");
 		}
 	}
@@ -1752,6 +1755,7 @@ static void ohci_iso_recv_packetperbuf_t
 {
 	int count;
 	int wake = 0;
+	struct ti_ohci *ohci = recv->ohci;
 	
 	/* loop over the entire buffer */
 	for (count = 0; count < recv->nblocks; count++) {
@@ -1779,9 +1783,9 @@ static void ohci_iso_recv_packetperbuf_t
 			packet_len = recv->buf_stride - rescount;
 
 		} else if (event == 0x02) {
-			PRINT(KERN_ERR, recv->ohci->id, "IR DMA error - packet too long for buffer\n");
+			PRINT(KERN_ERR, "IR DMA error - packet too long for buffer\n");
 		} else if (event) {
-			PRINT(KERN_ERR, recv->ohci->id, "IR DMA error - OHCI error code 0x%02x\n", event);
+			PRINT(KERN_ERR, "IR DMA error - OHCI error code 0x%02x\n", event);
 		}
 
 		/* sync our view of the buffer */
@@ -1911,6 +1915,7 @@ err:
 static void ohci_iso_xmit_stop(struct hpsb_iso *iso)
 {
 	struct ohci_iso_xmit *xmit = iso->hostdata;
+	struct ti_ohci *ohci = xmit->ohci;
 
 	/* disable interrupts */
 	reg_write(xmit->ohci, OHCI1394_IsoXmitIntMaskClear, 1 << xmit->task.context);
@@ -1918,7 +1923,7 @@ static void ohci_iso_xmit_stop(struct hp
 	/* halt DMA */
 	if (ohci1394_stop_context(xmit->ohci, xmit->ContextControlClear, NULL)) {
 		/* XXX the DMA context will lock up if you try to send too much data! */
-		PRINT(KERN_ERR, xmit->ohci->id,
+		PRINT(KERN_ERR,
 		      "you probably exceeded the OHCI card's bandwidth limit - "
 		      "reload the module and reduce xmit bandwidth");
 	}
@@ -1943,6 +1948,7 @@ static void ohci_iso_xmit_task(unsigned 
 {
 	struct hpsb_iso *iso = (struct hpsb_iso*) data;
 	struct ohci_iso_xmit *xmit = iso->hostdata;
+	struct ti_ohci *ohci = xmit->ohci;
 	int wake = 0;
 	int count;
 
@@ -1963,7 +1969,7 @@ static void ohci_iso_xmit_task(unsigned 
 		}
 
 		if (event != 0x11)
-			PRINT(KERN_ERR, xmit->ohci->id,
+			PRINT(KERN_ERR,
 			      "IT DMA error - OHCI error code 0x%02x\n", event);
 		
 		/* at least one packet went out, so wake up the writer */
@@ -1986,6 +1992,7 @@ static void ohci_iso_xmit_task(unsigned 
 static int ohci_iso_xmit_queue(struct hpsb_iso *iso, struct hpsb_iso_packet_info *info)
 {
 	struct ohci_iso_xmit *xmit = iso->hostdata;
+	struct ti_ohci *ohci = xmit->ohci;
 
 	int next_i, prev_i;
 	struct iso_xmit_cmd *next, *prev;
@@ -1997,7 +2004,7 @@ static int ohci_iso_xmit_queue(struct hp
 	/* check that the packet doesn't cross a page boundary
 	   (we could allow this if we added OUTPUT_MORE descriptor support) */
 	if (cross_bound(info->offset, info->len)) {
-		PRINT(KERN_ERR, xmit->ohci->id,
+		PRINT(KERN_ERR,
 		      "rawiso xmit: packet %u crosses a page boundary",
 		      iso->first_packet);
 		return -EINVAL;
@@ -2081,6 +2088,7 @@ static int ohci_iso_xmit_queue(struct hp
 static int ohci_iso_xmit_start(struct hpsb_iso *iso, int cycle)
 {
 	struct ohci_iso_xmit *xmit = iso->hostdata;
+	struct ti_ohci *ohci = xmit->ohci;
 
 	/* clear out the control register */
 	reg_write(xmit->ohci, xmit->ContextControlClear, 0xFFFFFFFF);
@@ -2118,7 +2126,7 @@ static int ohci_iso_xmit_start(struct hp
 
 	/* check the RUN bit */
 	if (!(reg_read(xmit->ohci, xmit->ContextControlSet) & 0x8000)) {
-		PRINT(KERN_ERR, xmit->ohci->id, "Error starting IT DMA (ContextControl 0x%08x)\n",
+		PRINT(KERN_ERR, "Error starting IT DMA (ContextControl 0x%08x)\n",
 		      reg_read(xmit->ohci, xmit->ContextControlSet));
 		return -1;
 	}
@@ -2192,8 +2200,9 @@ static void dma_trm_reset(struct dma_trm
 {
 	unsigned long flags;
 	LIST_HEAD(packet_list);
+	struct ti_ohci *ohci = d->ohci;
 
-	ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
+	ohci1394_stop_context(ohci, d->ctrlClear, NULL);
 
 	/* Lock the context, reset it and release it. Move the packets
 	 * that were pending in the context to packet_list and free
@@ -2217,10 +2226,10 @@ static void dma_trm_reset(struct dma_trm
 
 	while (!list_empty(&packet_list)) {
 		struct hpsb_packet *p = driver_packet(packet_list.next);
-		PRINT(KERN_INFO, d->ohci->id, 
+		PRINT(KERN_INFO,
 		      "AT dma reset ctx=%d, aborting transmission", d->ctx);
 		list_del(&p->driver_list);
-		hpsb_packet_sent(d->ohci->host, p, ACKX_ABORTED);
+		hpsb_packet_sent(ohci->host, p, ACKX_ABORTED);
 	}
 }
 
@@ -2270,43 +2279,43 @@ static irqreturn_t ohci_irq_handler(int 
 	 * we just return, and clean up in the ohci1394_pci_remove
 	 * function. */
 	if (event == ~(u32) 0) {
-		DBGMSG(ohci->id, "Device removed.");
+		DBGMSG("Device removed.");
 		return IRQ_NONE;
 	}
 
-	DBGMSG(ohci->id, "IntEvent: %08x", event);
+	DBGMSG("IntEvent: %08x", event);
 
 	if (event & OHCI1394_unrecoverableError) {
 		int ctx;
-		PRINT(KERN_ERR, ohci->id, "Unrecoverable error!");
+		PRINT(KERN_ERR, "Unrecoverable error!");
 
 		if (reg_read(ohci, OHCI1394_AsReqTrContextControlSet) & 0x800)
-			PRINT(KERN_ERR, ohci->id, "Async Req Tx Context died: "
+			PRINT(KERN_ERR, "Async Req Tx Context died: "
 				"ctrl[%08x] cmdptr[%08x]",
 				reg_read(ohci, OHCI1394_AsReqTrContextControlSet),
 				reg_read(ohci, OHCI1394_AsReqTrCommandPtr));
 
 		if (reg_read(ohci, OHCI1394_AsRspTrContextControlSet) & 0x800)
-			PRINT(KERN_ERR, ohci->id, "Async Rsp Tx Context died: "
+			PRINT(KERN_ERR, "Async Rsp Tx Context died: "
 				"ctrl[%08x] cmdptr[%08x]",
 				reg_read(ohci, OHCI1394_AsRspTrContextControlSet),
 				reg_read(ohci, OHCI1394_AsRspTrCommandPtr));
 
 		if (reg_read(ohci, OHCI1394_AsReqRcvContextControlSet) & 0x800)
-			PRINT(KERN_ERR, ohci->id, "Async Req Rcv Context died: "
+			PRINT(KERN_ERR, "Async Req Rcv Context died: "
 				"ctrl[%08x] cmdptr[%08x]",
 				reg_read(ohci, OHCI1394_AsReqRcvContextControlSet),
 				reg_read(ohci, OHCI1394_AsReqRcvCommandPtr));
 
 		if (reg_read(ohci, OHCI1394_AsRspRcvContextControlSet) & 0x800)
-			PRINT(KERN_ERR, ohci->id, "Async Rsp Rcv Context died: "
+			PRINT(KERN_ERR, "Async Rsp Rcv Context died: "
 				"ctrl[%08x] cmdptr[%08x]",
 				reg_read(ohci, OHCI1394_AsRspRcvContextControlSet),
 				reg_read(ohci, OHCI1394_AsRspRcvCommandPtr));
 
 		for (ctx = 0; ctx < ohci->nb_iso_xmit_ctx; ctx++) {
 			if (reg_read(ohci, OHCI1394_IsoXmitContextControlSet + (16 * ctx)) & 0x800)
-				PRINT(KERN_ERR, ohci->id, "Iso Xmit %d Context died: "
+				PRINT(KERN_ERR, "Iso Xmit %d Context died: "
 					"ctrl[%08x] cmdptr[%08x]", ctx,
 					reg_read(ohci, OHCI1394_IsoXmitContextControlSet + (16 * ctx)),
 					reg_read(ohci, OHCI1394_IsoXmitCommandPtr + (16 * ctx)));
@@ -2314,7 +2323,7 @@ static irqreturn_t ohci_irq_handler(int 
 
 		for (ctx = 0; ctx < ohci->nb_iso_rcv_ctx; ctx++) {
 			if (reg_read(ohci, OHCI1394_IsoRcvContextControlSet + (32 * ctx)) & 0x800)
-				PRINT(KERN_ERR, ohci->id, "Iso Recv %d Context died: "
+				PRINT(KERN_ERR, "Iso Recv %d Context died: "
 					"ctrl[%08x] cmdptr[%08x] match[%08x]", ctx,
 					reg_read(ohci, OHCI1394_IsoRcvContextControlSet + (32 * ctx)),
 					reg_read(ohci, OHCI1394_IsoRcvCommandPtr + (32 * ctx)),
@@ -2328,7 +2337,7 @@ static irqreturn_t ohci_irq_handler(int 
 		/* We subscribe to the cycleInconsistent event only to
 		 * clear the corresponding event bit... otherwise,
 		 * isochronous cycleMatch DMA won't work. */
-		DBGMSG(ohci->id, "OHCI1394_cycleInconsistent");
+		DBGMSG("OHCI1394_cycleInconsistent");
 		event &= ~OHCI1394_cycleInconsistent;
 	}
 
@@ -2359,7 +2368,7 @@ static irqreturn_t ohci_irq_handler(int 
 				 * to solve this problem. This mainly effects nForce2. */
 				if (loop_count > 10000) {
 					ohci_devctl(host, RESET_BUS, LONG_RESET);
-					DBGMSG(ohci->id, "Detected bus-reset loop. Forced a bus reset!");
+					DBGMSG("Detected bus-reset loop. Forced a bus reset!");
 					loop_count = 0;
 				}
 
@@ -2368,7 +2377,7 @@ static irqreturn_t ohci_irq_handler(int 
 		}
 		spin_unlock_irqrestore(&ohci->event_lock, flags);
 		if (!host->in_bus_reset) {
-			DBGMSG(ohci->id, "irq_handler: Bus reset requested");
+			DBGMSG("irq_handler: Bus reset requested");
 
 			/* Subsystem call */
 			hpsb_bus_reset(ohci->host);
@@ -2376,24 +2385,20 @@ static irqreturn_t ohci_irq_handler(int 
 		event &= ~OHCI1394_busReset;
 	}
 
-	/* XXX: We need a way to also queue the OHCI1394_reqTxComplete,
-	 * but for right now we simply run it upon reception, to make sure
-	 * we get sent acks before response packets. This sucks mainly
-	 * because it halts the interrupt handler.  */
 	if (event & OHCI1394_reqTxComplete) {
 		struct dma_trm_ctx *d = &ohci->at_req_context;
-		DBGMSG(ohci->id, "Got reqTxComplete interrupt "
+		DBGMSG("Got reqTxComplete interrupt "
 		       "status=0x%08X", reg_read(ohci, d->ctrlSet));
 		if (reg_read(ohci, d->ctrlSet) & 0x800)
 			ohci1394_stop_context(ohci, d->ctrlClear,
 					      "reqTxComplete");
 		else
-			dma_trm_tasklet ((unsigned long)d);
+			tasklet_schedule(&d->task);
 		event &= ~OHCI1394_reqTxComplete;
 	}
 	if (event & OHCI1394_respTxComplete) {
 		struct dma_trm_ctx *d = &ohci->at_resp_context;
-		DBGMSG(ohci->id, "Got respTxComplete interrupt "
+		DBGMSG("Got respTxComplete interrupt "
 		       "status=0x%08X", reg_read(ohci, d->ctrlSet));
 		if (reg_read(ohci, d->ctrlSet) & 0x800)
 			ohci1394_stop_context(ohci, d->ctrlClear,
@@ -2404,7 +2409,7 @@ static irqreturn_t ohci_irq_handler(int 
 	}
 	if (event & OHCI1394_RQPkt) {
 		struct dma_rcv_ctx *d = &ohci->ar_req_context;
-		DBGMSG(ohci->id, "Got RQPkt interrupt status=0x%08X",
+		DBGMSG("Got RQPkt interrupt status=0x%08X",
 		       reg_read(ohci, d->ctrlSet));
 		if (reg_read(ohci, d->ctrlSet) & 0x800)
 			ohci1394_stop_context(ohci, d->ctrlClear, "RQPkt");
@@ -2414,7 +2419,7 @@ static irqreturn_t ohci_irq_handler(int 
 	}
 	if (event & OHCI1394_RSPkt) {
 		struct dma_rcv_ctx *d = &ohci->ar_resp_context;
-		DBGMSG(ohci->id, "Got RSPkt interrupt status=0x%08X",
+		DBGMSG("Got RSPkt interrupt status=0x%08X",
 		       reg_read(ohci, d->ctrlSet));
 		if (reg_read(ohci, d->ctrlSet) & 0x800)
 			ohci1394_stop_context(ohci, d->ctrlClear, "RSPkt");
@@ -2443,7 +2448,7 @@ static irqreturn_t ohci_irq_handler(int 
 			node_id = reg_read(ohci, OHCI1394_NodeID);
 
 			if (!(node_id & 0x80000000)) {
-				PRINT(KERN_ERR, ohci->id,
+				PRINT(KERN_ERR,
 				      "SelfID received, but NodeID invalid "
 				      "(probably new bus reset occurred): %08X",
 				      node_id);
@@ -2453,8 +2458,7 @@ static irqreturn_t ohci_irq_handler(int 
 			phyid =  node_id & 0x0000003f;
 			isroot = (node_id & 0x40000000) != 0;
 
-			DBGMSG(ohci->id,
-			      "SelfID interrupt received "
+			DBGMSG("SelfID interrupt received "
 			      "(phyid %d, %s)", phyid, 
 			      (isroot ? "root" : "not root"));
 
@@ -2484,13 +2488,13 @@ static irqreturn_t ohci_irq_handler(int 
 				reg_write(ohci,OHCI1394_PhyReqFilterLoSet, 0x00000000);
 			}
 
-			DBGMSG(ohci->id, "PhyReqFilter=%08x%08x",
+			DBGMSG("PhyReqFilter=%08x%08x",
 			       reg_read(ohci,OHCI1394_PhyReqFilterHiSet),
 			       reg_read(ohci,OHCI1394_PhyReqFilterLoSet));
 
 			hpsb_selfid_complete(host, phyid, isroot);
 		} else
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "SelfID received outside of bus reset sequence");
 
 selfid_not_valid:
@@ -2500,7 +2504,7 @@ selfid_not_valid:
 	/* Make sure we handle everything, just in case we accidentally
 	 * enabled an interrupt that we didn't write a handler for.  */
 	if (event)
-		PRINT(KERN_ERR, ohci->id, "Unhandled interrupt(s) 0x%08x",
+		PRINT(KERN_ERR, "Unhandled interrupt(s) 0x%08x",
 		      event);
 
 	return IRQ_HANDLED;
@@ -2510,7 +2514,7 @@ selfid_not_valid:
 static void insert_dma_buffer(struct dma_rcv_ctx *d, int idx)
 {
 	struct ti_ohci *ohci = (struct ti_ohci*)(d->ohci);
-	DBGMSG(ohci->id, "Inserting dma buf ctx=%d idx=%d", d->ctx, idx);
+	DBGMSG("Inserting dma buf ctx=%d idx=%d", d->ctx, idx);
 
 	d->prg_cpu[idx]->status = cpu_to_le32(d->buf_size);
 	d->prg_cpu[idx]->branchAddress &= le32_to_cpu(0xfffffff0);
@@ -2519,7 +2523,7 @@ static void insert_dma_buffer(struct dma
 
 	/* wake up the dma context if necessary */
 	if (!(reg_read(ohci, d->ctrlSet) & 0x400)) {
-		PRINT(KERN_INFO, ohci->id, 
+		PRINT(KERN_INFO,
 		      "Waking dma ctx=%d ... processing is probably too slow",
 		      d->ctx);
 	}
@@ -2606,7 +2610,7 @@ static void dma_rcv_tasklet (unsigned lo
 		 * over more than one descriptor. The next case is where
 		 * it's all in the first descriptor.  */
 		if ((offset + length) > d->buf_size) {
-			DBGMSG(ohci->id,"Split packet rcv'd");
+			DBGMSG("Split packet rcv'd");
 			if (length > d->split_buf_size) {
 				ohci1394_stop_context(ohci, d->ctrlClear,
 					     "Split packet size exceeded");
@@ -2621,7 +2625,7 @@ static void dma_rcv_tasklet (unsigned lo
 				/* Other part of packet not written yet.
 				 * this should never happen I think
 				 * anyway we'll get it on the next call.  */
-				PRINT(KERN_INFO, ohci->id,
+				PRINT(KERN_INFO,
 				      "Got only half a packet!");
 				d->buf_ind = idx;
 				d->buf_offset = offset;
@@ -2654,7 +2658,7 @@ static void dma_rcv_tasklet (unsigned lo
 				buf_ptr += offset/4;
 			}
 		} else {
-			DBGMSG(ohci->id,"Single packet rcv'd");
+			DBGMSG("Single packet rcv'd");
 			memcpy(d->spb, buf_ptr, length);
 			offset += length;
 			buf_ptr += length/4;
@@ -2671,7 +2675,7 @@ static void dma_rcv_tasklet (unsigned lo
 		if (tcode != OHCI1394_TCODE_PHY) {
 			if (!ohci->no_swap_incoming)
 				packet_swab(d->spb, tcode);
-			DBGMSG(ohci->id, "Packet received from node"
+			DBGMSG("Packet received from node"
 				" %d ack=0x%02X spd=%d tcode=0x%X"
 				" length=%d ctx=%d tlabel=%d",
 				(d->spb[1]>>16)&0x3f,
@@ -2688,7 +2692,7 @@ static void dma_rcv_tasklet (unsigned lo
 		}
 #ifdef OHCI1394_DEBUG
 		else
-			PRINT (KERN_DEBUG, ohci->id, "Got phy packet ctx=%d ... discarded",
+			PRINT (KERN_DEBUG, "Got phy packet ctx=%d ... discarded",
 			       d->ctx);
 #endif
 
@@ -2733,8 +2737,7 @@ static void dma_trm_tasklet (unsigned lo
 #ifdef OHCI1394_DEBUG
 		if (datasize)
 			if (((le32_to_cpu(d->prg_cpu[d->sent_ind]->data[0])>>4)&0xf) == 0xa)
-				DBGMSG(ohci->id,
-				       "Stream packet sent to channel %d tcode=0x%X "
+				DBGMSG("Stream packet sent to channel %d tcode=0x%X "
 				       "ack=0x%X spd=%d dataLength=%d ctx=%d", 
 				       (le32_to_cpu(d->prg_cpu[d->sent_ind]->data[0])>>8)&0x3f,
 				       (le32_to_cpu(d->prg_cpu[d->sent_ind]->data[0])>>4)&0xf,
@@ -2742,8 +2745,7 @@ static void dma_trm_tasklet (unsigned lo
 				       le32_to_cpu(d->prg_cpu[d->sent_ind]->data[1])>>16,
 				       d->ctx);
 			else
-				DBGMSG(ohci->id,
-				       "Packet sent to node %d tcode=0x%X tLabel="
+				DBGMSG("Packet sent to node %d tcode=0x%X tLabel="
 				       "0x%02X ack=0x%X spd=%d dataLength=%d ctx=%d", 
 				       (le32_to_cpu(d->prg_cpu[d->sent_ind]->data[1])>>16)&0x3f,
 				       (le32_to_cpu(d->prg_cpu[d->sent_ind]->data[0])>>4)&0xf,
@@ -2752,8 +2754,7 @@ static void dma_trm_tasklet (unsigned lo
 				       le32_to_cpu(d->prg_cpu[d->sent_ind]->data[3])>>16,
 				       d->ctx);
 		else 
-			DBGMSG(ohci->id,
-			       "Packet sent to node %d tcode=0x%X tLabel="
+			DBGMSG("Packet sent to node %d tcode=0x%X tLabel="
 			       "0x%02X ack=0x%X spd=%d data=0x%08X ctx=%d", 
                                 (le32_to_cpu(d->prg_cpu[d->sent_ind]->data[1])
                                         >>16)&0x3f,
@@ -2773,7 +2774,7 @@ static void dma_trm_tasklet (unsigned lo
 			case EVT_NO_STATUS: /* that should never happen */
 			case EVT_RESERVED_A: /* that should never happen */
 			case EVT_LONG_PACKET: /* that should never happen */
-				PRINT(KERN_WARNING, ohci->id, "Received OHCI evt_* error 0x%x", status & 0x1f);
+				PRINT(KERN_WARNING, "Received OHCI evt_* error 0x%x", status & 0x1f);
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_MISSING_ACK:
@@ -2783,7 +2784,7 @@ static void dma_trm_tasklet (unsigned lo
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_OVERRUN: /* that should never happen */
-				PRINT(KERN_WARNING, ohci->id, "Received OHCI evt_* error 0x%x", status & 0x1f);
+				PRINT(KERN_WARNING, "Received OHCI evt_* error 0x%x", status & 0x1f);
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_DESCRIPTOR_READ:
@@ -2792,7 +2793,7 @@ static void dma_trm_tasklet (unsigned lo
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_BUS_RESET: /* that should never happen */
-				PRINT(KERN_WARNING, ohci->id, "Received OHCI evt_* error 0x%x", status & 0x1f);
+				PRINT(KERN_WARNING, "Received OHCI evt_* error 0x%x", status & 0x1f);
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_TIMEOUT:
@@ -2803,7 +2804,7 @@ static void dma_trm_tasklet (unsigned lo
 				break;
 			case EVT_RESERVED_B: /* that should never happen */
 			case EVT_RESERVED_C: /* that should never happen */
-				PRINT(KERN_WARNING, ohci->id, "Received OHCI evt_* error 0x%x", status & 0x1f);
+				PRINT(KERN_WARNING, "Received OHCI evt_* error 0x%x", status & 0x1f);
 				ack = ACKX_SEND_ERROR;
 				break;
 			case EVT_UNKNOWN:
@@ -2811,7 +2812,7 @@ static void dma_trm_tasklet (unsigned lo
 				ack = ACKX_SEND_ERROR;
 				break;
 			default:
-				PRINT(KERN_ERR, ohci->id, "Unhandled OHCI evt_* error 0x%x", status & 0x1f);
+				PRINT(KERN_ERR, "Unhandled OHCI evt_* error 0x%x", status & 0x1f);
 				ack = ACKX_SEND_ERROR;
 				BUG();
 			}
@@ -2855,17 +2856,18 @@ static void stop_dma_rcv_ctx(struct dma_
 static void free_dma_rcv_ctx(struct dma_rcv_ctx *d)
 {
 	int i;
+	struct ti_ohci *ohci = d->ohci;
 
-	if (d->ohci == NULL)
+	if (ohci == NULL)
 		return;
 
-	DBGMSG(d->ohci->id, "Freeing dma_rcv_ctx %d", d->ctx);
+	DBGMSG("Freeing dma_rcv_ctx %d", d->ctx);
 
 	if (d->buf_cpu) {
 		for (i=0; i<d->num_desc; i++)
 			if (d->buf_cpu[i] && d->buf_bus[i]) {
 				pci_free_consistent(
-					d->ohci->dev, d->buf_size, 
+					ohci->dev, d->buf_size, 
 					d->buf_cpu[i], d->buf_bus[i]);
 				OHCI_DMA_FREE("consistent dma_rcv buf[%d]", i);
 			}
@@ -2912,7 +2914,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 	d->buf_bus = kmalloc(d->num_desc * sizeof(dma_addr_t), GFP_KERNEL);
 
 	if (d->buf_cpu == NULL || d->buf_bus == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate dma buffer");
+		PRINT(KERN_ERR, "Failed to allocate dma buffer");
 		free_dma_rcv_ctx(d);
 		return -ENOMEM;
 	}
@@ -2924,7 +2926,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 	d->prg_bus = kmalloc(d->num_desc * sizeof(dma_addr_t), GFP_KERNEL);
 
 	if (d->prg_cpu == NULL || d->prg_bus == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate dma prg");
+		PRINT(KERN_ERR, "Failed to allocate dma prg");
 		free_dma_rcv_ctx(d);
 		return -ENOMEM;
 	}
@@ -2934,7 +2936,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 	d->spb = kmalloc(d->split_buf_size, GFP_KERNEL);
 
 	if (d->spb == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate split buffer");
+		PRINT(KERN_ERR, "Failed to allocate split buffer");
 		free_dma_rcv_ctx(d);
 		return -ENOMEM;
 	}
@@ -2952,7 +2954,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 		if (d->buf_cpu[i] != NULL) {
 			memset(d->buf_cpu[i], 0, d->buf_size);
 		} else {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "Failed to allocate dma buffer");
 			free_dma_rcv_ctx(d);
 			return -ENOMEM;
@@ -2964,7 +2966,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
                 if (d->prg_cpu[i] != NULL) {
                         memset(d->prg_cpu[i], 0, sizeof(struct dma_cmd));
 		} else {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "Failed to allocate dma prg");
 			free_dma_rcv_ctx(d);
 			return -ENOMEM;
@@ -2979,7 +2981,7 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 					  dma_rcv_tasklet, (unsigned long) d);
 		if (ohci1394_register_iso_tasklet(ohci,
 						  &ohci->ir_legacy_tasklet) < 0) {
-			PRINT(KERN_ERR, ohci->id, "No IR DMA context available");
+			PRINT(KERN_ERR, "No IR DMA context available");
 			free_dma_rcv_ctx(d);
 			return -EBUSY;
 		}
@@ -3005,11 +3007,12 @@ alloc_dma_rcv_ctx(struct ti_ohci *ohci, 
 static void free_dma_trm_ctx(struct dma_trm_ctx *d)
 {
 	int i;
+	struct ti_ohci *ohci = d->ohci;
 
-	if (d->ohci == NULL)
+	if (ohci == NULL)
 		return;
 
-	DBGMSG(d->ohci->id, "Freeing dma_trm_ctx %d", d->ctx);
+	DBGMSG("Freeing dma_trm_ctx %d", d->ctx);
 
 	if (d->prg_cpu) {
 		for (i=0; i<d->num_desc; i++) 
@@ -3047,7 +3050,7 @@ alloc_dma_trm_ctx(struct ti_ohci *ohci, 
 	d->prg_bus = kmalloc(d->num_desc * sizeof(dma_addr_t), GFP_KERNEL);
 
 	if (d->prg_cpu == NULL || d->prg_bus == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate at dma prg");
+		PRINT(KERN_ERR, "Failed to allocate at dma prg");
 		free_dma_trm_ctx(d);
 		return -ENOMEM;
 	}
@@ -3065,7 +3068,7 @@ alloc_dma_trm_ctx(struct ti_ohci *ohci, 
                 if (d->prg_cpu[i] != NULL) {
                         memset(d->prg_cpu[i], 0, sizeof(struct at_dma_prg));
 		} else {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "Failed to allocate at dma prg");
 			free_dma_trm_ctx(d);
 			return -ENOMEM;
@@ -3080,7 +3083,7 @@ alloc_dma_trm_ctx(struct ti_ohci *ohci, 
 					  dma_trm_tasklet, (unsigned long) d);
 		if (ohci1394_register_iso_tasklet(ohci,
 						  &ohci->it_legacy_tasklet) < 0) {
-			PRINT(KERN_ERR, ohci->id, "No IT DMA context available");
+			PRINT(KERN_ERR, "No IT DMA context available");
 			free_dma_trm_ctx(d);
 			return -EBUSY;
 		}
@@ -3157,11 +3160,6 @@ do {						\
 static int __devinit ohci1394_pci_probe(struct pci_dev *dev,
 					const struct pci_device_id *ent)
 {
-	struct csr1212_keyval *root;
-	struct csr1212_keyval *vend_id = NULL;
-	struct csr1212_keyval *text = NULL;
-	int ret;
-
 	static int version_printed = 0;
 
 	struct hpsb_host *host;
@@ -3179,7 +3177,6 @@ static int __devinit ohci1394_pci_probe(
 	if (!host) FAIL(-ENOMEM, "Failed to allocate host structure");
 
 	ohci = host->hostdata;
-	ohci->id = host->id;
 	ohci->dev = dev;
 	ohci->host = host;
 	ohci->init_state = OHCI_INIT_ALLOC_HOST;
@@ -3223,7 +3220,7 @@ static int __devinit ohci1394_pci_probe(
 	 * clearly says it's 2kb, so this shouldn't be a problem. */ 
 	ohci_base = pci_resource_start(dev, 0);
 	if (pci_resource_len(dev, 0) != OHCI1394_REGISTER_SIZE)
-		PRINT(KERN_WARNING, ohci->id, "Unexpected PCI resource length of %lx!",
+		PRINT(KERN_WARNING, "Unexpected PCI resource length of %lx!",
 		      pci_resource_len(dev, 0));
 
 	/* Seems PCMCIA handles this internally. Not sure why. Seems
@@ -3239,7 +3236,7 @@ static int __devinit ohci1394_pci_probe(
 	if (ohci->registers == NULL)
 		FAIL(-ENXIO, "Failed to remap registers - card not accessible");
 	ohci->init_state = OHCI_INIT_HAVE_IOMAPPING;
-	DBGMSG(ohci->id, "Remapped memory spaces reg 0x%p", ohci->registers);
+	DBGMSG("Remapped memory spaces reg 0x%p", ohci->registers);
 
 	/* csr_config rom allocation */
 	ohci->csr_config_rom_cpu =
@@ -3261,7 +3258,7 @@ static int __devinit ohci1394_pci_probe(
 	ohci->init_state = OHCI_INIT_HAVE_SELFID_BUFFER;
 
 	if ((unsigned long)ohci->selfid_buf_cpu & 0x1fff)
-		PRINT(KERN_INFO, ohci->id, "SelfID buffer %p is not aligned on "
+		PRINT(KERN_INFO, "SelfID buffer %p is not aligned on "
 		      "8Kb boundary... may cause problems on some CXD3222 chip", 
 		      ohci->selfid_buf_cpu);  
 
@@ -3315,12 +3312,12 @@ static int __devinit ohci1394_pci_probe(
 	/* Determine the number of available IR and IT contexts. */
 	ohci->nb_iso_rcv_ctx =
 		get_nb_iso_ctx(ohci, OHCI1394_IsoRecvIntMaskSet);
-	DBGMSG(ohci->id, "%d iso receive contexts available",
+	DBGMSG("%d iso receive contexts available",
 	       ohci->nb_iso_rcv_ctx);
 
 	ohci->nb_iso_xmit_ctx =
 		get_nb_iso_ctx(ohci, OHCI1394_IsoXmitIntMaskSet);
-	DBGMSG(ohci->id, "%d iso transmit contexts available",
+	DBGMSG("%d iso transmit contexts available",
 	       ohci->nb_iso_xmit_ctx);
 
 	/* Set the usage bits for non-existent contexts so they can't
@@ -3346,38 +3343,6 @@ static int __devinit ohci1394_pci_probe(
 	ohci->init_state = OHCI_INIT_HAVE_IRQ;
 	ohci_initialize(ohci);
 
-	/* Setup initial root directory entries */
-	root = host->csr.rom->root_kv;
-
-	vend_id = csr1212_new_immediate(CSR1212_KV_ID_VENDOR,
-					reg_read(ohci, OHCI1394_GUIDHi) >> 8);
-	text = csr1212_new_string_descriptor_leaf("Linux 1394 - OHCI");
-
-	if (!vend_id || !text) {
-		if (vend_id) {
-			csr1212_release_keyval(vend_id);
-		}
-		if (text) {
-			csr1212_release_keyval(text);
-		}
-		FAIL(-ENOMEM, "Failed to allocate memory for mandatory ConfigROM entries!");
-	}
-
-	ret = csr1212_associate_keyval(vend_id, text);
-	csr1212_release_keyval(text);
-	if(ret != CSR1212_SUCCESS) {
-		csr1212_release_keyval(vend_id);
-		FAIL(ret, "Failed to associate text descriptor to vendor id");
-	}
-
-	ret = csr1212_attach_keyval_to_directory(root, vend_id);
-	if(ret != CSR1212_SUCCESS) {
-		csr1212_release_keyval(vend_id);
-		FAIL(ret, "Failed to attach vendor id to root directory");
-	}
-
-	host->update_config_rom = 1;
-
 	/* Set certain csr values */
 	host->csr.guid_hi = reg_read(ohci, OHCI1394_GUIDHi);
 	host->csr.guid_lo = reg_read(ohci, OHCI1394_GUIDLo);
@@ -3386,7 +3351,9 @@ static int __devinit ohci1394_pci_probe(
 	host->csr.lnk_spd = reg_read(ohci, OHCI1394_BusOptions) & 0x7;
 
 	/* Tell the highlevel this host is ready */
-	hpsb_add_host(host);
+	if (hpsb_add_host(host))
+		FAIL(-ENOMEM, "Failed to register host with highlevel");
+
 	ohci->init_state = OHCI_INIT_DONE;
 
 	return 0;
@@ -3582,7 +3549,7 @@ int ohci1394_stop_context(struct ti_ohci
 	while (reg_read(ohci, reg) & 0x400) {
 		i++;
 		if (i>5000) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR,
 			      "Runaway loop while stopping context: %s...", msg ? msg : "");
 			return 1;
 		}
@@ -3590,7 +3557,7 @@ int ohci1394_stop_context(struct ti_ohci
 		mb();
 		udelay(10);
 	}
-	if (msg) PRINT(KERN_ERR, ohci->id, "%s: dma prg stopped", msg);
+	if (msg) PRINT(KERN_ERR, "%s: dma prg stopped", msg);
 	return 0;
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/ohci1394.h linux-post-2.6.4rc1-20040302/drivers/ieee1394/ohci1394.h
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/ohci1394.h	2004-02-24 00:36:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/ohci1394.h	2004-02-29 18:29:18.000000000 +0000
@@ -149,8 +149,6 @@ struct ohci1394_iso_tasklet {
 };
 
 struct ti_ohci {
-        int id; /* sequential card number */
-
         struct pci_dev *dev;
 
 	enum { 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/pcilynx.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/pcilynx.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/pcilynx.c	2004-02-04 18:46:29.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/pcilynx.c	2004-02-28 19:16:26.000000000 +0000
@@ -1516,11 +1516,6 @@ static int __devinit add_card(struct pci
         return error; \
         } while (0)
 
-	struct csr1212_keyval *root;
-	struct csr1212_keyval *vend_id = NULL;
-	struct csr1212_keyval *text = NULL;
-	int ret;
-
 	char irq_buf[16];
 	struct hpsb_host *host;
         struct ti_lynx *lynx; /* shortcut to currently handled device */
@@ -1890,42 +1885,14 @@ static int __devinit add_card(struct pci
 	else
 		host->csr.lnk_spd = be32_to_cpu(lynx->bus_info_block[2]) & 0x7;
 
-	/* Setup initial root directory entries */
-	root = host->csr.rom->root_kv;
-
-	vend_id = csr1212_new_immediate(CSR1212_KV_ID_VENDOR,
-					be32_to_cpu(lynx->bus_info_block[3]) >> 8);
-	text = csr1212_new_string_descriptor_leaf("Linux 1394 - PCI-Lynx");
-
-	if (!vend_id || !text) {
-		if (vend_id)
-			csr1212_release_keyval(vend_id);
-		if (text)
-			csr1212_release_keyval(text);
+	if (hpsb_add_host(host)) {
 		error = -ENOMEM;
-		FAIL("Failed to allocate memory for mandatory ConfigROM entries!");
-	}
-
-	ret = csr1212_associate_keyval(vend_id, text);
-	csr1212_release_keyval(text);		/* no longer needed locally. */
-	if(ret != CSR1212_SUCCESS) {
-		csr1212_release_keyval(vend_id);
-		error = ret;
-		FAIL("Failed to associate text descriptor to vendor id");
-	}
-
-	ret = csr1212_attach_keyval_to_directory(root, vend_id);
-	csr1212_release_keyval(vend_id);	/* no longer needed locally. */
-	if(ret != CSR1212_SUCCESS) {
-		error = ret;
-		FAIL("Failed to attach vendor id to root directory");
+		FAIL("Failed to register host with highlevel");
 	}
 
-	host->update_config_rom = 1;
-	hpsb_add_host(host);
 	lynx->state = is_host;
 
-	return ret;
+	return 0;
 #undef FAIL
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/sbp2.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/sbp2.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/sbp2.c	2004-02-25 14:36:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/sbp2.c	2004-02-29 13:40:56.000000000 +0000
@@ -78,7 +78,7 @@
 #include "sbp2.h"
 
 static char version[] __devinitdata =
-	"$Rev: 1144 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1170 $ Ben Collins <bcollins@debian.org>";
 
 /*
  * Module load parameter definitions
@@ -677,6 +677,10 @@ static int sbp2_update(struct unit_direc
 	 */
 	sbp2scsi_complete_all_commands(scsi_id, DID_BUS_BUSY);
 
+	/* Make sure we unblock requests (since this is likely after a bus
+	 * reset). */
+	scsi_unblock_requests(scsi_id->scsi_host);
+
 	return 0;
 }
 
@@ -2544,8 +2548,6 @@ static void sbp2scsi_complete_all_comman
 		}
 	}
 
-	scsi_unblock_requests(scsi_id->scsi_host);
-
 	return;
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/ieee1394/video1394.c linux-post-2.6.4rc1-20040302/drivers/ieee1394/video1394.c
--- linux-post-2.6.4rc1-20040301/drivers/ieee1394/video1394.c	2004-02-25 14:36:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/ieee1394/video1394.c	2004-02-29 18:29:18.000000000 +0000
@@ -155,7 +155,7 @@ static int free_dma_iso_ctx(struct dma_i
 {
 	int i;
 	
-	DBGMSG(d->ohci->id, "Freeing dma_iso_ctx %d", d->ctx);
+	DBGMSG(d->ohci->host->id, "Freeing dma_iso_ctx %d", d->ctx);
 
 	ohci1394_stop_context(d->ohci, d->ctrlClear, NULL);
 	if (d->iso_tasklet.link.next != NULL)
@@ -200,7 +200,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 
 	d = kmalloc(sizeof(struct dma_iso_ctx), GFP_KERNEL);
 	if (d == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate dma_iso_ctx");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate dma_iso_ctx");
 		return NULL;
 	}
 
@@ -221,7 +221,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 
 	if (dma_region_alloc(&d->dma, d->num_desc * d->buf_size, ohci->dev,
 			     PCI_DMA_BIDIRECTIONAL)) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate dma buffer");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate dma buffer");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
@@ -236,7 +236,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 					  (unsigned long) d);
 
 	if (ohci1394_register_iso_tasklet(ohci, &d->iso_tasklet) < 0) {
-		PRINT(KERN_ERR, ohci->id, "no free iso %s contexts",
+		PRINT(KERN_ERR, ohci->host->id, "no free iso %s contexts",
 		      type == OHCI_ISO_RECEIVE ? "receive" : "transmit");
 		free_dma_iso_ctx(d);
 		return NULL;
@@ -246,7 +246,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 	d->prg_reg = kmalloc(d->num_desc * sizeof(struct dma_prog_region),
 			GFP_KERNEL);
 	if (d->prg_reg == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate ir prg regs");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate ir prg regs");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
@@ -264,7 +264,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 				    GFP_KERNEL);
 
 		if (d->ir_prg == NULL) {
-			PRINT(KERN_ERR, ohci->id, "Failed to allocate dma ir prg");
+			PRINT(KERN_ERR, ohci->host->id, "Failed to allocate dma ir prg");
 			free_dma_iso_ctx(d);
 			return NULL;
 		}
@@ -277,7 +277,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 		for (i = 0;i < d->num_desc; i++) {
 			if (dma_prog_region_alloc(&d->prg_reg[i], d->nb_cmd *
 						  sizeof(struct dma_cmd), ohci->dev)) {
-				PRINT(KERN_ERR, ohci->id, "Failed to allocate dma ir prg");
+				PRINT(KERN_ERR, ohci->host->id, "Failed to allocate dma ir prg");
 				free_dma_iso_ctx(d);
 				return NULL;
 			}
@@ -293,7 +293,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 				    GFP_KERNEL);
 
 		if (d->it_prg == NULL) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Failed to allocate dma it prg");
 			free_dma_iso_ctx(d);
 			return NULL;
@@ -303,7 +303,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 		d->packet_size = packet_size;
 
 		if (PAGE_SIZE % packet_size || packet_size>4096) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Packet size %d (page_size: %ld) "
 			      "not yet supported\n",
 			      packet_size, PAGE_SIZE);
@@ -321,7 +321,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 		for (i = 0; i < d->num_desc; i++) {
 			if (dma_prog_region_alloc(&d->prg_reg[i], d->nb_cmd *
 						sizeof(struct it_dma_prg), ohci->dev)) {
-				PRINT(KERN_ERR, ohci->id, "Failed to allocate dma it prg");
+				PRINT(KERN_ERR, ohci->host->id, "Failed to allocate dma it prg");
 				free_dma_iso_ctx(d);
 				return NULL;
 			}
@@ -339,22 +339,22 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 				 GFP_KERNEL);
 
 	if (d->buffer_status == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate buffer_status");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate buffer_status");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
 	if (d->buffer_time == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate buffer_time");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate buffer_time");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
 	if (d->last_used_cmd == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate last_used_cmd");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate last_used_cmd");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
 	if (d->next_buffer == NULL) {
-		PRINT(KERN_ERR, ohci->id, "Failed to allocate next_buffer");
+		PRINT(KERN_ERR, ohci->host->id, "Failed to allocate next_buffer");
 		free_dma_iso_ctx(d);
 		return NULL;
 	}
@@ -365,7 +365,7 @@ alloc_dma_iso_ctx(struct ti_ohci *ohci, 
 	
         spin_lock_init(&d->lock);
 
-	PRINT(KERN_INFO, ohci->id, "Iso %s DMA: %d buffers "
+	PRINT(KERN_INFO, ohci->host->id, "Iso %s DMA: %d buffers "
 	      "of size %d allocated for a frame size %d, each with %d prgs",
 	      (type == OHCI_ISO_RECEIVE) ? "receive" : "transmit",
 	      d->num_desc, d->buf_size, d->frame_size, d->nb_cmd);
@@ -725,7 +725,7 @@ static int video1394_ioctl(struct inode 
 		    for (i=0; i<ISO_CHANNELS; i++) {
 			if (!(ohci->ISO_channel_usage & mask)) {
 			    v.channel = i;
-			    PRINT(KERN_INFO, ohci->id, "Found free channel %d", i);
+			    PRINT(KERN_INFO, ohci->host->id, "Found free channel %d", i);
 			    break;
 			}
 			mask = mask << 1;
@@ -733,7 +733,7 @@ static int video1394_ioctl(struct inode 
 		}
 		    
 		if (v.channel<0 || v.channel>(ISO_CHANNELS-1)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Iso channel %d out of bounds", v.channel);
 			return -EFAULT;
 		}
@@ -743,26 +743,26 @@ static int video1394_ioctl(struct inode 
 		       (u32)(ohci->ISO_channel_usage>>32),
 		       (u32)(ohci->ISO_channel_usage&0xffffffff));
 		if (ohci->ISO_channel_usage & mask) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Channel %d is already taken", v.channel);
 			return -EFAULT;
 		}
 		ohci->ISO_channel_usage |= mask;
 
 		if (v.buf_size == 0 || v.buf_size > VIDEO1394_MAX_SIZE) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR, ohci->host->id,
 			      "Invalid %d length buffer requested",v.buf_size);
 			return -EFAULT;
 		}
 
 		if (v.nb_buffers == 0 || v.nb_buffers > VIDEO1394_MAX_SIZE) {
-			PRINT(KERN_ERR, ohci->id,
+			PRINT(KERN_ERR, ohci->host->id,
 			      "Invalid %d buffers requested",v.nb_buffers);
 			return -EFAULT;
 		}
 
 		if (v.nb_buffers * v.buf_size > VIDEO1394_MAX_SIZE) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "%d buffers of size %d bytes is too big", 
 			      v.nb_buffers, v.buf_size);
 			return -EFAULT;
@@ -774,7 +774,7 @@ static int video1394_ioctl(struct inode 
 					      v.channel, 0);
 
 			if (d == NULL) {
-				PRINT(KERN_ERR, ohci->id, 
+				PRINT(KERN_ERR, ohci->host->id, 
 				      "Couldn't allocate ir context");
 				return -EFAULT;
 			}
@@ -785,7 +785,7 @@ static int video1394_ioctl(struct inode 
 			v.buf_size = d->buf_size;
 			list_add_tail(&d->link, &ctx->context_list);
 
-			PRINT(KERN_INFO, ohci->id, 
+			PRINT(KERN_INFO, ohci->host->id, 
 			      "iso context %d listen on channel %d",
 			      d->ctx, v.channel);
 		}
@@ -795,7 +795,7 @@ static int video1394_ioctl(struct inode 
 					      v.channel, v.packet_size);
 
 			if (d == NULL) {
-				PRINT(KERN_ERR, ohci->id, 
+				PRINT(KERN_ERR, ohci->host->id, 
 				      "Couldn't allocate it context");
 				return -EFAULT;
 			}
@@ -808,7 +808,7 @@ static int video1394_ioctl(struct inode 
 
 			list_add_tail(&d->link, &ctx->context_list);
 
-			PRINT(KERN_INFO, ohci->id, 
+			PRINT(KERN_INFO, ohci->host->id, 
 			      "Iso context %d talk on channel %d", d->ctx,
 			      v.channel);
 		}
@@ -829,13 +829,13 @@ static int video1394_ioctl(struct inode 
 			return -EFAULT;
 
 		if (channel<0 || channel>(ISO_CHANNELS-1)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Iso channel %d out of bound", channel);
 			return -EFAULT;
 		}
 		mask = (u64)0x1<<channel;
 		if (!(ohci->ISO_channel_usage & mask)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Channel %d is not being used", channel);
 			return -EFAULT;
 		}
@@ -849,7 +849,7 @@ static int video1394_ioctl(struct inode 
 			d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, channel);
 
 		if (d == NULL) return -EFAULT;
-		PRINT(KERN_INFO, ohci->id, "Iso context %d "
+		PRINT(KERN_INFO, ohci->host->id, "Iso context %d "
 		      "stop talking on channel %d", d->ctx, channel);
 		free_dma_iso_ctx(d);
 		
@@ -866,7 +866,7 @@ static int video1394_ioctl(struct inode 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_RECEIVE, v.channel);
 
 		if ((v.buffer<0) || (v.buffer>d->num_desc)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d out of range",v.buffer);
 			return -EFAULT;
 		}
@@ -874,7 +874,7 @@ static int video1394_ioctl(struct inode 
 		spin_lock_irqsave(&d->lock,flags);
 
 		if (d->buffer_status[v.buffer]==VIDEO1394_BUFFER_QUEUED) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d is already used",v.buffer);
 			spin_unlock_irqrestore(&d->lock,flags);
 			return -EFAULT;
@@ -895,7 +895,7 @@ static int video1394_ioctl(struct inode 
 
 		if (!(reg_read(ohci, d->ctrlSet) & 0x8000)) 
 		{
-			DBGMSG(ohci->id, "Starting iso DMA ctx=%d",d->ctx);
+			DBGMSG(ohci->host->id, "Starting iso DMA ctx=%d",d->ctx);
 
 			/* Tell the controller where the first program is */
 			reg_write(ohci, d->cmdPtr,
@@ -907,7 +907,7 @@ static int video1394_ioctl(struct inode 
 		else {
 			/* Wake up dma context if necessary */
 			if (!(reg_read(ohci, d->ctrlSet) & 0x400)) {
-				PRINT(KERN_INFO, ohci->id, 
+				PRINT(KERN_INFO, ohci->host->id, 
 				      "Waking up iso dma ctx=%d", d->ctx);
 				reg_write(ohci, d->ctrlSet, 0x1000);
 			}
@@ -928,7 +928,7 @@ static int video1394_ioctl(struct inode 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_RECEIVE, v.channel);
 
 		if ((v.buffer<0) || (v.buffer>d->num_desc)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d out of range",v.buffer);
 			return -EFAULT;
 		}
@@ -970,7 +970,7 @@ static int video1394_ioctl(struct inode 
 			d->buffer_status[v.buffer]=VIDEO1394_BUFFER_FREE;
 			break;
 		default:
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d is not queued",v.buffer);
 			spin_unlock_irqrestore(&d->lock, flags);
 			return -EFAULT;
@@ -1011,7 +1011,7 @@ static int video1394_ioctl(struct inode 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 
 		if ((v.buffer<0) || (v.buffer>d->num_desc)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d out of range",v.buffer);
 			return -EFAULT;
 		}
@@ -1038,7 +1038,7 @@ static int video1394_ioctl(struct inode 
 		spin_lock_irqsave(&d->lock,flags);
 
 		if (d->buffer_status[v.buffer]!=VIDEO1394_BUFFER_FREE) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d is already used",v.buffer);
 			spin_unlock_irqrestore(&d->lock,flags);
 			if (qv.packet_sizes)
@@ -1075,7 +1075,7 @@ static int video1394_ioctl(struct inode 
 
 		if (!(reg_read(ohci, d->ctrlSet) & 0x8000)) 
 		{
-			DBGMSG(ohci->id, "Starting iso transmit DMA ctx=%d",
+			DBGMSG(ohci->host->id, "Starting iso transmit DMA ctx=%d",
 			       d->ctx);
 			put_timestamp(ohci, d, d->last_buffer);
 
@@ -1089,7 +1089,7 @@ static int video1394_ioctl(struct inode 
 		else {
 			/* Wake up dma context if necessary */
 			if (!(reg_read(ohci, d->ctrlSet) & 0x400)) {
-				PRINT(KERN_INFO, ohci->id, 
+				PRINT(KERN_INFO, ohci->host->id, 
 				      "Waking up iso transmit dma ctx=%d", 
 				      d->ctx);
 				put_timestamp(ohci, d, d->last_buffer);
@@ -1114,7 +1114,7 @@ static int video1394_ioctl(struct inode 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 
 		if ((v.buffer<0) || (v.buffer>d->num_desc)) {
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d out of range",v.buffer);
 			return -EFAULT;
 		}
@@ -1140,7 +1140,7 @@ static int video1394_ioctl(struct inode 
 			d->buffer_status[v.buffer]=VIDEO1394_BUFFER_FREE;
 			return 0;
 		default:
-			PRINT(KERN_ERR, ohci->id, 
+			PRINT(KERN_ERR, ohci->host->id, 
 			      "Buffer %d is not queued",v.buffer);
 			return -EFAULT;
 		}
@@ -1166,7 +1166,7 @@ int video1394_mmap(struct file *file, st
 
 	lock_kernel();
 	if (ctx->current_ctx == NULL) {
-		PRINT(KERN_ERR, ctx->ohci->id, "Current iso context not set");
+		PRINT(KERN_ERR, ctx->ohci->host->id, "Current iso context not set");
 	} else
 		res = dma_region_mmap(&ctx->current_ctx->dma, file, vma);
 	unlock_kernel();
@@ -1186,7 +1186,7 @@ static int video1394_open(struct inode *
 
 	ctx = kmalloc(sizeof(struct file_ctx), GFP_KERNEL);
 	if (ctx == NULL)  {
-		PRINT(KERN_ERR, ohci->id, "Cannot malloc file_ctx");
+		PRINT(KERN_ERR, ohci->host->id, "Cannot malloc file_ctx");
 		return -ENOMEM;
 	}
 
@@ -1213,11 +1213,11 @@ static int video1394_release(struct inod
 		mask = (u64) 1 << d->channel;
 		
 		if (!(ohci->ISO_channel_usage & mask))
-			PRINT(KERN_ERR, ohci->id, "On release: Channel %d "
+			PRINT(KERN_ERR, ohci->host->id, "On release: Channel %d "
 			      "is not being used", d->channel);
 		else
 			ohci->ISO_channel_usage &= ~mask;
-		PRINT(KERN_INFO, ohci->id, "On release: Iso %s context "
+		PRINT(KERN_INFO, ohci->host->id, "On release: Iso %s context "
 		      "%d stop listening on channel %d",
 		      d->type == OHCI_ISO_RECEIVE ? "receive" : "transmit",
 		      d->ctx, d->channel);
@@ -1278,17 +1278,17 @@ static void video1394_add_host (struct h
 	ohci = (struct ti_ohci *)host->hostdata;
 
 	if (!hpsb_create_hostinfo(&video1394_highlevel, host, 0)) {
-		PRINT(KERN_ERR, ohci->id, "Cannot allocate hostinfo");
+		PRINT(KERN_ERR, ohci->host->id, "Cannot allocate hostinfo");
 		return;
 	}
 
 	hpsb_set_hostinfo(&video1394_highlevel, host, ohci);
-	hpsb_set_hostinfo_key(&video1394_highlevel, host, ohci->id);
+	hpsb_set_hostinfo_key(&video1394_highlevel, host, ohci->host->id);
 
-	minor = IEEE1394_MINOR_BLOCK_VIDEO1394 * 16 + ohci->id; 
+	minor = IEEE1394_MINOR_BLOCK_VIDEO1394 * 16 + ohci->host->id; 
 	devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, minor),
 		       S_IFCHR | S_IRUSR | S_IWUSR,
-		       "%s/%d", VIDEO1394_DRIVER_NAME, ohci->id);
+		       "%s/%d", VIDEO1394_DRIVER_NAME, ohci->host->id);
 }
 
 
@@ -1297,7 +1297,7 @@ static void video1394_remove_host (struc
 	struct ti_ohci *ohci = hpsb_get_hostinfo(&video1394_highlevel, host);
 
 	if (ohci)
-		devfs_remove("%s/%d", VIDEO1394_DRIVER_NAME, ohci->id);
+		devfs_remove("%s/%d", VIDEO1394_DRIVER_NAME, ohci->host->id);
 
 	return;
 }
@@ -1459,7 +1459,7 @@ static int __init video1394_init_module 
 	video1394_cdev.owner = THIS_MODULE;
 	kobject_set_name(&video1394_cdev.kobj, VIDEO1394_DRIVER_NAME);
 	ret = cdev_add(&video1394_cdev, IEEE1394_VIDEO1394_DEV, 16);
-	if (cdev_add(&video1394_cdev, IEEE1394_VIDEO1394_DEV, 16)) {
+	if (ret) {
 		PRINT_G(KERN_ERR, "video1394: unable to get minor device block");
 		return ret;
         }
diff -purN linux-post-2.6.4rc1-20040301/drivers/isdn/hisax/hisax_fcpcipnp.c linux-post-2.6.4rc1-20040302/drivers/isdn/hisax/hisax_fcpcipnp.c
--- linux-post-2.6.4rc1-20040301/drivers/isdn/hisax/hisax_fcpcipnp.c	2004-02-19 03:42:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/isdn/hisax/hisax_fcpcipnp.c	2004-03-02 03:01:28.000000000 +0000
@@ -971,10 +971,10 @@ static void __devexit fcpnp_remove(struc
 }
 
 static struct pnp_driver fcpnp_driver = {
-	name:     "fcpnp",
-	probe:    fcpnp_probe,
-	remove:   __devexit_p(fcpnp_remove),
-	id_table: fcpnp_ids,
+	.name		= "fcpnp",
+	.probe		= fcpnp_probe,
+	.remove		= __devexit_p(fcpnp_remove),
+	.id_table	= fcpnp_ids,
 };
 #endif
 
@@ -988,10 +988,10 @@ static void __devexit fcpci_remove(struc
 }
 
 static struct pci_driver fcpci_driver = {
-	name:     "fcpci",
-	probe:    fcpci_probe,
-	remove:   __devexit_p(fcpci_remove),
-	id_table: fcpci_ids,
+	.name		= "fcpci",
+	.probe		= fcpci_probe,
+	.remove		= __devexit_p(fcpci_remove),
+	.id_table	= fcpci_ids,
 };
 
 static int __init hisax_fcpcipnp_init(void)
diff -purN linux-post-2.6.4rc1-20040301/drivers/md/dm-crypt.c linux-post-2.6.4rc1-20040302/drivers/md/dm-crypt.c
--- linux-post-2.6.4rc1-20040301/drivers/md/dm-crypt.c	2004-02-19 03:43:14.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/md/dm-crypt.c	2004-03-02 03:01:27.000000000 +0000
@@ -8,15 +8,18 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/bio.h>
+#include <linux/blkdev.h>
 #include <linux/mempool.h>
 #include <linux/slab.h>
 #include <linux/crypto.h>
-#include <linux/spinlock.h>
 #include <linux/workqueue.h>
+#include <asm/atomic.h>
 #include <asm/scatterlist.h>
 
 #include "dm.h"
 
+#define PFX	"crypt: "
+
 /*
  * per bio private data
  */
@@ -416,7 +419,7 @@ static int crypt_ctr(struct dm_target *t
 	int key_size;
 
 	if (argc != 5) {
-		ti->error = "dm-crypt: Not enough arguments";
+		ti->error = PFX "Not enough arguments";
 		return -EINVAL;
 	}
 
@@ -425,14 +428,14 @@ static int crypt_ctr(struct dm_target *t
 	mode = strsep(&tmp, "-");
 
 	if (tmp)
-		DMWARN("dm-crypt: Unexpected additional cipher options");
+		DMWARN(PFX "Unexpected additional cipher options");
 
 	key_size = strlen(argv[1]) >> 1;
 
 	cc = kmalloc(sizeof(*cc) + key_size * sizeof(u8), GFP_KERNEL);
 	if (cc == NULL) {
 		ti->error =
-			"dm-crypt: Cannot allocate transparent encryption context";
+			PFX "Cannot allocate transparent encryption context";
 		return -ENOMEM;
 	}
 
@@ -441,7 +444,7 @@ static int crypt_ctr(struct dm_target *t
 	else if (strcmp(mode, "ecb") == 0)
 		cc->iv_generator = NULL;
 	else {
-		ti->error = "dm-crypt: Invalid chaining mode";
+		ti->error = PFX "Invalid chaining mode";
 		goto bad1;
 	}
 
@@ -452,18 +455,22 @@ static int crypt_ctr(struct dm_target *t
 
 	tfm = crypto_alloc_tfm(cipher, crypto_flags);
 	if (!tfm) {
-		ti->error = "dm-crypt: Error allocating crypto tfm";
+		ti->error = PFX "Error allocating crypto tfm";
 		goto bad1;
 	}
+	if (crypto_tfm_alg_type(tfm) != CRYPTO_ALG_TYPE_CIPHER) {
+		ti->error = PFX "Expected cipher algorithm";
+		goto bad2;
+	}
 
-	if (tfm->crt_u.cipher.cit_decrypt_iv && tfm->crt_u.cipher.cit_encrypt_iv)
+	if (tfm->crt_cipher.cit_decrypt_iv && tfm->crt_cipher.cit_encrypt_iv)
 		/* at least a 32 bit sector number should fit in our buffer */
 		cc->iv_size = max(crypto_tfm_alg_ivsize(tfm),
 		                  (unsigned int)(sizeof(u32) / sizeof(u8)));
 	else {
 		cc->iv_size = 0;
 		if (cc->iv_generator) {
-			DMWARN("dm-crypt: Selected cipher does not support IVs");
+			DMWARN(PFX "Selected cipher does not support IVs");
 			cc->iv_generator = NULL;
 		}
 	}
@@ -471,14 +478,14 @@ static int crypt_ctr(struct dm_target *t
 	cc->io_pool = mempool_create(MIN_IOS, mempool_alloc_slab,
 				     mempool_free_slab, _crypt_io_pool);
 	if (!cc->io_pool) {
-		ti->error = "dm-crypt: Cannot allocate crypt io mempool";
+		ti->error = PFX "Cannot allocate crypt io mempool";
 		goto bad2;
 	}
 
 	cc->page_pool = mempool_create(MIN_POOL_PAGES, mempool_alloc_page,
 				       mempool_free_page, NULL);
 	if (!cc->page_pool) {
-		ti->error = "dm-crypt: Cannot allocate page mempool";
+		ti->error = PFX "Cannot allocate page mempool";
 		goto bad3;
 	}
 
@@ -486,28 +493,28 @@ static int crypt_ctr(struct dm_target *t
 	cc->key_size = key_size;
 	if ((key_size == 0 && strcmp(argv[1], "-") != 0)
 	    || crypt_decode_key(cc->key, argv[1], key_size) < 0) {
-		ti->error = "dm-crypt: Error decoding key";
+		ti->error = PFX "Error decoding key";
 		goto bad4;
 	}
 
-	if (tfm->crt_u.cipher.cit_setkey(tfm, cc->key, key_size) < 0) {
-		ti->error = "dm-crypt: Error setting key";
+	if (tfm->crt_cipher.cit_setkey(tfm, cc->key, key_size) < 0) {
+		ti->error = PFX "Error setting key";
 		goto bad4;
 	}
 
 	if (sscanf(argv[2], SECTOR_FORMAT, &cc->iv_offset) != 1) {
-		ti->error = "dm-crypt: Invalid iv_offset sector";
+		ti->error = PFX "Invalid iv_offset sector";
 		goto bad4;
 	}
 
 	if (sscanf(argv[4], SECTOR_FORMAT, &cc->start) != 1) {
-		ti->error = "dm-crypt: Invalid device sector";
+		ti->error = PFX "Invalid device sector";
 		goto bad4;
 	}
 
 	if (dm_get_device(ti, argv[3], cc->start, ti->len,
 	                  dm_table_get_mode(ti->table), &cc->dev)) {
-		ti->error = "dm-crypt: Device lookup failed";
+		ti->error = PFX "Device lookup failed";
 		goto bad4;
 	}
 
@@ -586,8 +593,21 @@ crypt_clone(struct crypt_config *cc, str
 				return NULL;
 			}
 		}
-	} else
-		clone = bio_clone(bio, GFP_NOIO);
+	} else {
+		/*
+		 * The block layer might modify the bvec array, so always
+		 * copy the required bvecs because we need the original
+		 * one in order to decrypt the whole bio data *afterwards*.
+		 */
+		clone = bio_alloc(GFP_NOIO, bio_segments(bio));
+		if (clone) {
+			clone->bi_idx = 0;
+			clone->bi_vcnt = bio_segments(bio);
+			clone->bi_size = bio->bi_size;
+			memcpy(clone->bi_io_vec, bio_iovec(bio),
+			       sizeof(struct bio_vec) * clone->bi_vcnt);
+		}
+	}
 
 	if (!clone)
 		return NULL;
@@ -682,7 +702,7 @@ static int crypt_status(struct dm_target
 	case STATUSTYPE_TABLE:
 		cipher = crypto_tfm_alg_name(cc->tfm);
 
-		switch(cc->tfm->crt_u.cipher.cit_mode) {
+		switch(cc->tfm->crt_cipher.cit_mode) {
 		case CRYPTO_TFM_MODE_CBC:
 			mode = "plain";
 			break;
@@ -739,13 +759,13 @@ static int __init dm_crypt_init(void)
 	_kcryptd_workqueue = create_workqueue("kcryptd");
 	if (!_kcryptd_workqueue) {
 		r = -ENOMEM;
-		DMERR("couldn't create kcryptd");
+		DMERR(PFX "couldn't create kcryptd");
 		goto bad1;
 	}
 
 	r = dm_register_target(&crypt_target);
 	if (r < 0) {
-		DMERR("crypt: register failed %d", r);
+		DMERR(PFX "register failed %d", r);
 		goto bad2;
 	}
 
@@ -763,7 +783,7 @@ static void __exit dm_crypt_exit(void)
 	int r = dm_unregister_target(&crypt_target);
 
 	if (r < 0)
-		DMERR("crypt: unregister failed %d", r);
+		DMERR(PFX "unregister failed %d", r);
 
 	destroy_workqueue(_kcryptd_workqueue);
 	kmem_cache_destroy(_crypt_io_pool);
diff -purN linux-post-2.6.4rc1-20040301/drivers/md/raid1.c linux-post-2.6.4rc1-20040302/drivers/md/raid1.c
--- linux-post-2.6.4rc1-20040301/drivers/md/raid1.c	2004-02-19 03:42:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/md/raid1.c	2004-03-02 03:01:28.000000000 +0000
@@ -104,8 +104,8 @@ out_free_pages:
 	for ( ; i > 0 ; i--)
 		__free_page(bio->bi_io_vec[i-1].bv_page);
 out_free_bio:
-	while ( j < conf->raid_disks )
-		bio_put(r1_bio->bios[++j]);
+	while ( ++j < conf->raid_disks )
+		bio_put(r1_bio->bios[j]);
 	r1bio_pool_free(r1_bio, conf->mddev);
 	return NULL;
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/media/video/zr36050.c linux-post-2.6.4rc1-20040302/drivers/media/video/zr36050.c
--- linux-post-2.6.4rc1-20040301/drivers/media/video/zr36050.c	2004-02-26 11:21:50.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/media/video/zr36050.c	2004-03-02 03:01:27.000000000 +0000
@@ -24,7 +24,7 @@
  * ------------------------------------------------------------------------
  */
 
-#define ZR050_VERSION "v0.7"
+#define ZR050_VERSION "v0.7.1"
 
 #include <linux/version.h>
 #include <linux/module.h>
@@ -479,7 +479,7 @@ zr36050_init (struct zr36050 *ptr)
 		zr36050_write(ptr, ZR050_INT_REQ_1, 3);	// low 2 bits always 1
 
 		/* volume control settings */
-		zr36050_write(ptr, ZR050_MBCV, ptr->max_block_vol >> 1);
+		/*zr36050_write(ptr, ZR050_MBCV, ptr->max_block_vol);*/
 		zr36050_write(ptr, ZR050_SF_HI, ptr->scalefact >> 8);
 		zr36050_write(ptr, ZR050_SF_LO, ptr->scalefact & 0xff);
 
@@ -521,13 +521,13 @@ zr36050_init (struct zr36050 *ptr)
 		/* setup misc. data for compression (target code sizes) */
 
 		/* size of compressed code to reach without header data */
-		sum = ptr->total_code_vol - sum;
+		sum = ptr->real_code_vol - sum;
 		bitcnt = sum << 3;	/* need the size in bits */
 
 		tmp = bitcnt >> 16;
 		dprintk(3,
 			"%s: code: csize=%d, tot=%d, bit=%ld, highbits=%ld\n",
-			ptr->name, sum, ptr->total_code_vol, bitcnt, tmp);
+			ptr->name, sum, ptr->real_code_vol, bitcnt, tmp);
 		zr36050_write(ptr, ZR050_TCV_NET_HI, tmp >> 8);
 		zr36050_write(ptr, ZR050_TCV_NET_MH, tmp & 0xff);
 		tmp = bitcnt & 0xffff;
@@ -629,17 +629,37 @@ zr36050_set_video (struct videocodec   *
 		   struct vfe_polarity *pol)
 {
 	struct zr36050 *ptr = (struct zr36050 *) codec->data;
+	int size;
 
-	dprintk(2, "%s: set_video %d.%d, %d/%d-%dx%d (0x%x) call\n",
+	dprintk(2, "%s: set_video %d.%d, %d/%d-%dx%d (0x%x) q%d call\n",
 		ptr->name, norm->HStart, norm->VStart,
 		cap->x, cap->y, cap->width, cap->height,
-		cap->decimation);
+		cap->decimation, cap->quality);
 	/* if () return -EINVAL;
 	 * trust the master driver that it knows what it does - so
 	 * we allow invalid startx/y and norm for now ... */
 	ptr->width = cap->width / (cap->decimation & 0xff);
 	ptr->height = cap->height / ((cap->decimation >> 8) & 0xff);
 
+	/* (KM) JPEG quality */
+	size = ptr->width * ptr->height;
+	size *= 16; /* size in bits */
+	/* apply quality setting */
+	size = size * cap->quality / 200;
+
+	/* Minimum: 1kb */
+	if (size < 8192)
+		size = 8192;
+	/* Maximum: 7/8 of code buffer */
+	if (size > ptr->total_code_vol * 7)
+		size = ptr->total_code_vol * 7;
+
+	ptr->real_code_vol = size >> 3; /* in bytes */
+
+	/* Set max_block_vol here (previously in zr36050_init, moved
+	 * here for consistency with zr36060 code */
+	zr36050_write(ptr, ZR050_MBCV, ptr->max_block_vol);
+
 	return 0;
 }
 
@@ -697,6 +717,9 @@ zr36050_control (struct videocodec *code
 		if (size != sizeof(int))
 			return -EFAULT;
 		ptr->total_code_vol = *ival;
+		/* (Kieran Morrissey)
+		 * code copied from zr36060.c to ensure proper bitrate */
+		ptr->real_code_vol = (ptr->total_code_vol * 6) >> 3;
 		break;
 
 	case CODEC_G_JPEG_SCALE:	/* get scaling factor */
diff -purN linux-post-2.6.4rc1-20040301/drivers/media/video/zr36050.h linux-post-2.6.4rc1-20040302/drivers/media/video/zr36050.h
--- linux-post-2.6.4rc1-20040301/drivers/media/video/zr36050.h	2003-08-20 21:29:31.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/media/video/zr36050.h	2004-03-02 03:01:27.000000000 +0000
@@ -44,6 +44,7 @@ struct zr36050 {
 	__u16 bitrate_ctrl;
 
 	__u32 total_code_vol;
+	__u32 real_code_vol;
 	__u16 max_block_vol;
 
 	__u8 h_samp_ratio[8];
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/Kconfig linux-post-2.6.4rc1-20040302/drivers/net/Kconfig
--- linux-post-2.6.4rc1-20040301/drivers/net/Kconfig	2004-02-17 16:05:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/Kconfig	2004-02-27 22:23:58.000000000 +0000
@@ -1676,25 +1676,23 @@ config VIA_RHINE
 	select CRC32
 	select MII
 	help
-	  If you have a VIA "rhine" based network card (Rhine-I (3043),
-	  Rhine-2 (VT86c100A) or Rhine-III (VT6105)), say Y here.
+	  If you have a VIA "Rhine" based network card (Rhine-I (VT86C100A),
+	  Rhine-II (VT6102), or Rhine-III (VT6105)), say Y here. Rhine-type
+	  Ethernet functions can also be found integrated on South Bridges
+	  (e.g. VT8235).
 
-	  To compile this driver as a module, choose M here and read
-	  <file:Documentation/networking/net-modules.txt>. The module
+	  To compile this driver as a module, choose M here. The module
 	  will be called via-rhine.
 
 config VIA_RHINE_MMIO
-	bool "Use MMIO instead of PIO (EXPERIMENTAL)"
-	depends on VIA_RHINE && EXPERIMENTAL
+	bool "Use MMIO instead of PIO"
+	depends on VIA_RHINE
 	help
 	  This instructs the driver to use PCI shared memory (MMIO) instead of
 	  programmed I/O ports (PIO). Enabling this gives an improvement in
 	  processing time in parts of the driver.
 
-	  It is not known if this works reliably on all "rhine" based cards,
-	  but it has been tested successfully on some DFE-530TX adapters.
-
-	  If unsure, say N.
+	  If unsure, say Y.
 
 config LAN_SAA9730
 	bool "Philips SAA9730 Ethernet support (EXPERIMENTAL)"
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/hp100.c linux-post-2.6.4rc1-20040302/drivers/net/hp100.c
--- linux-post-2.6.4rc1-20040301/drivers/net/hp100.c	2004-02-18 12:39:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/hp100.c	2004-03-01 11:18:00.000000000 +0000
@@ -201,6 +201,7 @@ static struct eisa_device_id hp100_eisa_
 	{ "HWP1990" }, /* HP J2577 */
 	{ "CPX0301" }, /* ReadyLink ENET100-VG4 */
 	{ "CPX0401" }, /* FreedomLine 100/VG */
+	{ "" }	       /* Mandatory final entry ! */
 };
 MODULE_DEVICE_TABLE(eisa, hp100_eisa_tbl);
 #endif
@@ -326,16 +327,21 @@ static __init const char *hp100_read_id(
 	return str;
 }
 
-static __init int hp100_isa_probe1(struct net_device *dev, int addr)
+static __init int hp100_isa_probe1(struct net_device *dev, int ioaddr)
 {
 	const char *sig;
 	int i;
 
-	if (!request_region(addr, HP100_REGION_SIZE, "hp100"))
+	if (!request_region(ioaddr, HP100_REGION_SIZE, "hp100"))
 		goto err;
 
-	sig = hp100_read_id(addr);
-	release_region(addr, HP100_REGION_SIZE);
+	if (hp100_inw(HW_ID) != HP100_HW_ID_CASCADE) {
+		release_region(ioaddr, HP100_REGION_SIZE);
+		goto err;
+	}
+
+	sig = hp100_read_id(ioaddr);
+	release_region(ioaddr, HP100_REGION_SIZE);
 
 	if (sig == NULL)
 		goto err;
@@ -347,7 +353,7 @@ static __init int hp100_isa_probe1(struc
 	}
 
 	if (i < ARRAY_SIZE(hp100_isa_tbl))
-		return hp100_probe1(dev, addr, HP100_BUS_ISA, NULL);
+		return hp100_probe1(dev, ioaddr, HP100_BUS_ISA, NULL);
  err:
 	return -ENODEV;
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/hydra.c linux-post-2.6.4rc1-20040302/drivers/net/hydra.c
--- linux-post-2.6.4rc1-20040301/drivers/net/hydra.c	2004-02-20 15:10:49.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/hydra.c	2004-02-29 08:53:41.000000000 +0000
@@ -142,10 +142,6 @@ static int __devinit hydra_init(struct z
     ei_status.reg_offset = hydra_offsets;
     dev->open = &hydra_open;
     dev->stop = &hydra_close;
-#ifdef MODULE
-    ei_status.priv = (unsigned long)root_hydra_dev;
-    root_hydra_dev = dev;
-#endif
     NS8390_init(dev, 0);
 
     err = register_netdev(dev);
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/ibmveth.c linux-post-2.6.4rc1-20040302/drivers/net/ibmveth.c
--- linux-post-2.6.4rc1-20040301/drivers/net/ibmveth.c	2004-02-17 16:05:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/ibmveth.c	2004-03-01 16:38:07.000000000 +0000
@@ -52,7 +52,7 @@
 #include <asm/semaphore.h>
 #include <asm/hvcall.h>
 #include <asm/atomic.h>
-#include <asm/pci_dma.h>
+#include <asm/iommu.h>
 #include <asm/vio.h>
 #include <asm/uaccess.h>
 #include <linux/proc_fs.h>
@@ -66,16 +66,16 @@
   printk(KERN_INFO "%s: " fmt, __FILE__, ## args)
 
 #define ibmveth_error_printk(fmt, args...) \
-  printk(KERN_ERR "(%s:%3.3d ua:%lx) ERROR: " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
+  printk(KERN_ERR "(%s:%3.3d ua:%x) ERROR: " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
 
 #ifdef DEBUG
 #define ibmveth_debug_printk_no_adapter(fmt, args...) \
   printk(KERN_DEBUG "(%s:%3.3d): " fmt, __FILE__, __LINE__ , ## args)
 #define ibmveth_debug_printk(fmt, args...) \
-  printk(KERN_DEBUG "(%s:%3.3d ua:%lx): " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
+  printk(KERN_DEBUG "(%s:%3.3d ua:%x): " fmt, __FILE__, __LINE__ , adapter->vdev->unit_address, ## args)
 #define ibmveth_assert(expr) \
   if(!(expr)) {                                   \
-    printk(KERN_DEBUG "assertion failed (%s:%3.3d ua:%lx): %s\n", __FILE__, __LINE__, adapter->vdev->unit_address, #expr); \
+    printk(KERN_DEBUG "assertion failed (%s:%3.3d ua:%x): %s\n", __FILE__, __LINE__, adapter->vdev->unit_address, #expr); \
     BUG(); \
   }
 #else
@@ -869,7 +869,7 @@ static int __devinit ibmveth_probe(struc
 	unsigned int *mcastFilterSize_p;
 
 
-	ibmveth_debug_printk_no_adapter("entering ibmveth_probe for UA 0x%lx\n", 
+	ibmveth_debug_printk_no_adapter("entering ibmveth_probe for UA 0x%x\n", 
 					dev->unit_address);
 
 	mac_addr_p = (unsigned int *) vio_get_attribute(dev, VETH_MAC_ADDR, 0);
@@ -913,7 +913,7 @@ static int __devinit ibmveth_probe(struc
 	adapter->mac_addr = 0;
 	memcpy(&adapter->mac_addr, mac_addr_p, 6);
 
-	adapter->liobn = dev->tce_table->index;
+	adapter->liobn = dev->iommu_table->it_index;
 	
 	netdev->irq = dev->irq;
 	netdev->open               = ibmveth_open;
@@ -1014,7 +1014,7 @@ static int ibmveth_seq_show(struct seq_f
 
 	seq_printf(seq, "%s %s\n\n", ibmveth_driver_string, ibmveth_driver_version);
 	
-	seq_printf(seq, "Unit Address:    0x%lx\n", adapter->vdev->unit_address);
+	seq_printf(seq, "Unit Address:    0x%x\n", adapter->vdev->unit_address);
 	seq_printf(seq, "LIOBN:           0x%lx\n", adapter->liobn);
 	seq_printf(seq, "Current MAC:     %02X:%02X:%02X:%02X:%02X:%02X\n",
 		   current_mac[0], current_mac[1], current_mac[2],
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/r8169.c linux-post-2.6.4rc1-20040302/drivers/net/r8169.c
--- linux-post-2.6.4rc1-20040301/drivers/net/r8169.c	2003-12-07 18:58:47.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/r8169.c	2004-02-26 06:19:13.000000000 +0000
@@ -871,7 +871,6 @@ rtl8169_tx_interrupt(struct net_device *
 		     void *ioaddr)
 {
 	unsigned long dirty_tx, tx_left = 0;
-	int entry = tp->cur_tx % NUM_TX_DESC;
 
 	assert(dev != NULL);
 	assert(tp != NULL);
@@ -881,14 +880,18 @@ rtl8169_tx_interrupt(struct net_device *
 	tx_left = tp->cur_tx - dirty_tx;
 
 	while (tx_left > 0) {
+		int entry = dirty_tx % NUM_TX_DESC;
+
 		if ((tp->TxDescArray[entry].status & OWNbit) == 0) {
-			dev_kfree_skb_irq(tp->
-					  Tx_skbuff[dirty_tx % NUM_TX_DESC]);
-			tp->Tx_skbuff[dirty_tx % NUM_TX_DESC] = NULL;
+			struct sk_buff *skb = tp->Tx_skbuff[entry];
+
+			tp->stats.tx_bytes += skb->len >= ETH_ZLEN ?
+					      skb->len : ETH_ZLEN;
 			tp->stats.tx_packets++;
+			dev_kfree_skb_irq(skb);
+			tp->Tx_skbuff[entry] = NULL;
 			dirty_tx++;
 			tx_left--;
-			entry++;
 		}
 	}
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/airo_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/airo_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/airo_cs.c	2004-01-19 06:32:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/airo_cs.c	2004-02-05 16:09:01.000000000 +0000
@@ -264,11 +264,8 @@ static void airo_detach(dev_link_t *link
 	if (*linkp == NULL)
 		return;
 	
-	if (link->state & DEV_CONFIG) {
+	if (link->state & DEV_CONFIG)
 		airo_release(link);
-		if (link->state & DEV_STALE_CONFIG)
-			return;
-	}
 	
 	if ( ((local_info_t*)link->priv)->eth_dev ) {
 		stop_airo_card( ((local_info_t*)link->priv)->eth_dev, 0 );
@@ -504,18 +501,6 @@ static void airo_release(dev_link_t *lin
 {
 	DEBUG(0, "airo_release(0x%p)\n", link);
 	
-	/*
-	  If the device is currently in use, we won't release until it
-	  is actually closed, because until then, we can't be sure that
-	  no one will try to access the device or its data structures.
-	*/
-	if (link->open) {
-		DEBUG(1, "airo_cs: release postponed, '%s' still open\n",
-		      link->dev->dev_name);
-		link->state |= DEV_STALE_CONFIG;
-		return;
-	}
-	
 	/* Unlink the device chain */
 	link->dev = NULL;
 	
@@ -533,9 +518,6 @@ static void airo_release(dev_link_t *lin
 	if (link->irq.AssignedIRQ)
 		pcmcia_release_irq(link->handle, &link->irq);
 	link->state &= ~DEV_CONFIG;
-
-	if (link->state & DEV_STALE_CONFIG)
-		airo_detach(link);
 }
 
 /*======================================================================
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/netwave_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/netwave_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/netwave_cs.c	2004-01-19 06:32:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/netwave_cs.c	2004-02-05 16:09:30.000000000 +0000
@@ -544,14 +544,8 @@ static void netwave_detach(dev_link_t *l
 	  the release() function is called, that will trigger a proper
 	  detach().
 	*/
-    if (link->state & DEV_CONFIG) {
+    if (link->state & DEV_CONFIG)
 	netwave_release(link);
-	if (link->state & DEV_STALE_CONFIG) {
-	    DEBUG(1, "netwave_cs: detach postponed, '%s' still "
-		  "locked\n", link->dev->dev_name);
-	    return;
-	}
-    }
 	
     /* Break the link with Card Services */
     if (link->handle)
@@ -1130,17 +1124,6 @@ static void netwave_release(dev_link_t *
 
     DEBUG(0, "netwave_release(0x%p)\n", link);
 
-    /*
-      If the device is currently in use, we won't release until it
-      is actually closed.
-      */
-    if (link->open) {
-	printk(KERN_DEBUG "netwave_cs: release postponed, '%s' still open\n",
-	       link->dev->dev_name);
-	link->state |= DEV_STALE_CONFIG;
-	return;
-    }
-
     /* Don't bother checking to see if these succeed or not */
     if (link->win) {
 	iounmap(priv->ramBase);
@@ -1151,9 +1134,6 @@ static void netwave_release(dev_link_t *
     pcmcia_release_irq(link->handle, &link->irq);
 
     link->state &= ~DEV_CONFIG;
-
-    if (link->state & DEV_STALE_CONFIG)
-	netwave_detach(link);
 }
 
 /*
@@ -1703,8 +1683,7 @@ static int netwave_close(struct net_devi
 
     link->open--;
     netif_stop_queue(dev);
-    if (link->state & DEV_STALE_CONFIG)
-	    netwave_release(link);
+
     return 0;
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/ray_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/ray_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/ray_cs.c	2004-01-19 23:34:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/ray_cs.c	2004-02-18 22:40:58.000000000 +0000
@@ -454,11 +454,8 @@ static void ray_detach(dev_link_t *link)
       the release() function is called, that will trigger a proper
       detach().
     */
-    if (link->state & DEV_CONFIG) {
+    if (link->state & DEV_CONFIG)
         ray_release(link);
-        if(link->state & DEV_STALE_CONFIG)
-            return;
-    }
 
     /* Break the link with Card Services */
     if (link->handle)
@@ -872,15 +869,7 @@ static void ray_release(dev_link_t *link
     int i;
     
     DEBUG(1, "ray_release(0x%p)\n", link);
-    /* If the device is currently in use, we won't release until it
-      is actually closed.
-    */
-    if (link->open) {
-        DEBUG(1, "ray_cs: release postponed, '%s' still open\n",
-              link->dev->dev_name);
-        link->state |= DEV_STALE_CONFIG;
-        return;
-    }
+
     del_timer(&local->timer);
     link->state &= ~DEV_CONFIG;
 
@@ -900,9 +889,6 @@ static void ray_release(dev_link_t *link
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseIRQ ret = %x\n",i);
 
     DEBUG(2,"ray_release ending\n");
-
-    if (link->state & DEV_STALE_CONFIG)
-	    ray_detach(link);
 }
 
 /*=============================================================================
@@ -1724,8 +1710,6 @@ static int ray_dev_close(struct net_devi
 
     link->open--;
     netif_stop_queue(dev);
-    if (link->state & DEV_STALE_CONFIG)
-	    ray_release(link);
 
     /* In here, we should stop the hardware (stop card from beeing active)
      * and set local->card_status to CARD_AWAITING_PARAM, so that while the
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/wavelan_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/wavelan_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/wavelan_cs.c	2004-01-19 23:29:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/wavelan_cs.c	2004-02-18 22:41:02.000000000 +0000
@@ -4155,18 +4155,6 @@ wv_pcmcia_release(dev_link_t *link)
   printk(KERN_DEBUG "%s: -> wv_pcmcia_release(0x%p)\n", dev->name, link);
 #endif
 
-  /* If the device is currently in use, we won't release until it is
-   * actually closed. */
-  if(link->open)
-    {
-#ifdef DEBUG_CONFIG_INFO
-      printk(KERN_DEBUG "%s: wv_pcmcia_release: release postponed, device still open\n",
-	     dev->name);
-#endif
-      link->state |= DEV_STALE_CONFIG;
-      return;
-    }
-
   /* Don't bother checking to see if these succeed or not */
   iounmap((u_char *)dev->mem_start);
   pcmcia_release_window(link->win);
@@ -4179,9 +4167,6 @@ wv_pcmcia_release(dev_link_t *link)
 #ifdef DEBUG_CONFIG_TRACE
   printk(KERN_DEBUG "%s: <- wv_pcmcia_release()\n", dev->name);
 #endif
-
-  if (link->state & DEV_STALE_CONFIG)
-	  wavelan_detach(link);
 }
 
 /************************ INTERRUPT HANDLING ************************/
@@ -4634,10 +4619,6 @@ wavelan_close(struct net_device *	dev)
       /* Power down the module */
       hacr_write(base, HACR_DEFAULT & (~HACR_PWR_STAT));
     }
-  else
-    /* The card is no more there (flag is activated in wv_pcmcia_release) */
-    if(link->state & DEV_STALE_CONFIG)
-      wv_pcmcia_release(link);
 
 #ifdef DEBUG_CALLBACK_TRACE
   printk(KERN_DEBUG "%s: <-wavelan_close()\n", dev->name);
@@ -4802,14 +4783,6 @@ wavelan_detach(dev_link_t *	link)
     {
       /* Some others haven't done their job : give them another chance */
       wv_pcmcia_release(link);
-      if(link->state & DEV_STALE_CONFIG)
-	{
-#ifdef DEBUG_CONFIG_INFO
-	  printk(KERN_DEBUG "wavelan_detach: detach postponed,"
-		 " '%s' still locked\n", link->dev->dev_name);
-#endif
-	  return;
-	}
     }
 
   /* Break the link with Card Services */
diff -purN linux-post-2.6.4rc1-20040301/drivers/net/wireless/wl3501_cs.c linux-post-2.6.4rc1-20040302/drivers/net/wireless/wl3501_cs.c
--- linux-post-2.6.4rc1-20040301/drivers/net/wireless/wl3501_cs.c	2004-01-19 23:44:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/net/wireless/wl3501_cs.c	2004-02-28 10:12:49.000000000 +0000
@@ -1306,10 +1306,6 @@ static int wl3501_close(struct net_devic
 	/* Mask interrupts from the SUTRO */
 	wl3501_block_interrupt(this);
 
-	if (link->state & DEV_STALE_CONFIG) {
-		link->state |= DEV_RELEASE_PENDING;
-		wl3501_release(link);
-	}
 	rc = 0;
 	printk(KERN_INFO "%s: WL3501 closed\n", dev->name);
 out:
@@ -2220,15 +2216,6 @@ static void wl3501_release(dev_link_t *l
 {
 	struct net_device *dev = link->priv;
 
-	/* If the device is currently in use, we won't release until it is
-	 * actually closed. */
-	if (link->open) {
-		dprintk(1, "release postponed, '%s' still open",
-			link->dev->dev_name);
-		link->state |= DEV_STALE_CONFIG;
-		goto out;
-	}
-
 	/* Unlink the device chain */
 	if (link->dev) {
 		unregister_netdev(dev);
@@ -2240,11 +2227,6 @@ static void wl3501_release(dev_link_t *l
 	pcmcia_release_io(link->handle, &link->io);
 	pcmcia_release_irq(link->handle, &link->irq);
 	link->state &= ~DEV_CONFIG;
-
-	if (link->state & DEV_STALE_CONFIG)
-		wl3501_detach(link);
-out:
-	return;
 }
 
 /**
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/block/Kconfig linux-post-2.6.4rc1-20040302/drivers/s390/block/Kconfig
--- linux-post-2.6.4rc1-20040301/drivers/s390/block/Kconfig	2004-02-26 11:21:57.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/block/Kconfig	2004-03-02 03:01:29.000000000 +0000
@@ -1,3 +1,5 @@
+if ARCH_S390
+
 comment "S/390 block device drivers"
 	depends on ARCH_S390
 
@@ -62,3 +64,5 @@ config DASD_CMB
 	  ioctl functions specific to the dasd driver.
 	  This is only needed if you want to use applications written for
 	  linux-2.4 dasd channel measurement facility interface.
+
+endif
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/block/dasd_eckd.c linux-post-2.6.4rc1-20040302/drivers/s390/block/dasd_eckd.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/block/dasd_eckd.c	2004-02-26 11:21:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/block/dasd_eckd.c	2004-03-02 03:01:23.000000000 +0000
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.50 $
+ * $Revision: 1.51 $
  */
 
 #include <linux/config.h>
@@ -85,7 +85,7 @@ dasd_eckd_probe (struct ccw_device *cdev
 	ret = dasd_generic_probe (cdev, &dasd_eckd_discipline);
 	if (ret)
 		return ret;
-	ccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP);
+	ccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP | CCWDEV_ALLOW_FORCE);
 	return 0;
 }
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/block/xpram.c linux-post-2.6.4rc1-20040302/drivers/s390/block/xpram.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/block/xpram.c	2003-09-25 18:33:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/block/xpram.c	2004-03-02 03:01:24.000000000 +0000
@@ -74,9 +74,10 @@ static int xpram_devs;
  */
 static int devs = XPRAM_DEVS;
 static unsigned int sizes[XPRAM_MAX_DEVS];
+static unsigned int sizes_count;
 
 module_param(devs, int, 0);
-MODULE_PARM(sizes,"1-" __MODULE_STRING(XPRAM_MAX_DEVS) "i"); 
+module_param_array(sizes, int, sizes_count, 0);
 
 MODULE_PARM_DESC(devs, "number of devices (\"partitions\"), " \
 		 "the default is " __MODULE_STRING(XPRAM_DEVS) "\n");
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/Makefile linux-post-2.6.4rc1-20040302/drivers/s390/char/Makefile
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/Makefile	2004-01-19 06:35:57.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/Makefile	2004-03-02 03:01:24.000000000 +0000
@@ -18,6 +18,6 @@ obj-$(CONFIG_SCLP_CPI) += sclp_cpi.o
 
 tape-$(CONFIG_S390_TAPE_BLOCK) += tape_block.o
 tape-$(CONFIG_PROC_FS) += tape_proc.o
-tape-objs := tape_core.o tape_std.o tape_char.o $(tape-y)
+tape-objs := tape_core.o tape_std.o tape_char.o tape_class.o $(tape-y)
 obj-$(CONFIG_S390_TAPE) += tape.o
 obj-$(CONFIG_S390_TAPE_34XX) += tape_34xx.o
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/sclp.c linux-post-2.6.4rc1-20040302/drivers/s390/char/sclp.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/sclp.c	2004-01-31 08:15:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/sclp.c	2004-03-02 03:01:24.000000000 +0000
@@ -19,6 +19,7 @@
 #include <linux/interrupt.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/cpumask.h>
 #include <asm/s390_ext.h>
 #include <asm/processor.h>
 
@@ -334,6 +335,8 @@ sclp_sync_wait(void)
 	unsigned long psw_mask;
 	unsigned long cr0, cr0_sync;
 
+	/* Need to irq_enter() to prevent BH from executing. */
+	irq_enter();
 	/*
 	 * save cr0
 	 * enable service signal external interruption (cr0.22)
@@ -362,6 +365,7 @@ sclp_sync_wait(void)
 
 	/* restore cr0 */
 	__ctl_load(cr0, 0, 0);
+	irq_exit();
 }
 
 /*
@@ -467,29 +471,45 @@ static struct sclp_register sclp_state_c
  * SCLP quiesce event handler
  */
 #ifdef CONFIG_SMP
-static cpumask_t cpu_quiesce_map;
-
 static void
 do_load_quiesce_psw(void * __unused)
 {
 	psw_t quiesce_psw;
+	unsigned long status;
+	int i;
 
-	cpu_clear(smp_processor_id(), cpu_quiesce_map);
-	if (smp_processor_id() == 0) {
-		/* Wait for all other cpus to enter do_load_quiesce_psw */
-		while (!cpus_empty(cpu_quiesce_map));
-		/* Quiesce the last cpu with the special psw */
-		quiesce_psw.mask = PSW_BASE_BITS | PSW_MASK_WAIT;
-		quiesce_psw.addr = 0xfff;
-		__load_psw(quiesce_psw);
+	if (smp_processor_id() != 0)
+		signal_processor(smp_processor_id(), sigp_stop);
+	/* Wait for all other cpus to enter stopped state */
+	i = 1;
+	while (i < NR_CPUS) {
+		if (!cpu_online(i)) {
+			i++;
+			continue;
+		}
+		switch (signal_processor_ps(&status, 0, i, sigp_sense)) {
+		case sigp_order_code_accepted:
+		case sigp_status_stored:
+			/* Check for stopped and check stop state */
+			if (test_bit(6, &status) || test_bit(4, &status))
+				i++;
+			break;
+		case sigp_busy:
+			break;
+		case sigp_not_operational:
+			i++;
+			break;
+		}
 	}
-	signal_processor(smp_processor_id(), sigp_stop);
+	/* Quiesce the last cpu with the special psw */
+	quiesce_psw.mask = PSW_BASE_BITS | PSW_MASK_WAIT;
+	quiesce_psw.addr = 0xfff;
+	__load_psw(quiesce_psw);
 }
 
 static void
 do_machine_quiesce(void)
 {
-	cpu_quiesce_map = cpu_online_map;
 	on_each_cpu(do_load_quiesce_psw, NULL, 0, 0);
 }
 #else
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape.h linux-post-2.6.4rc1-20040302/drivers/s390/char/tape.h
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape.h	2004-01-19 06:35:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape.h	2004-03-02 03:01:24.000000000 +0000
@@ -60,12 +60,6 @@ do { \
 #define TAPEBLOCK_HSEC_S2B	2
 #define TAPEBLOCK_RETRIES	5
 
-/* Event types for hotplug */
-#define TAPE_HOTPLUG_CHAR_ADD     1
-#define TAPE_HOTPLUG_BLOCK_ADD    2
-#define TAPE_HOTPLUG_CHAR_REMOVE  3
-#define TAPE_HOTPLUG_BLOCK_REMOVE 4
-
 enum tape_medium_state {
 	MS_UNKNOWN,
 	MS_LOADED,
@@ -205,6 +199,8 @@ struct tape_device {
 	struct list_head		node;
 
 	struct ccw_device *		cdev;
+	struct cdev *			nt;
+	struct cdev *			rt;
 
 	/* Device discipline information. */
 	struct tape_discipline *	discipline;
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_block.c linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_block.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_block.c	2004-01-19 06:35:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_block.c	2004-03-02 03:01:24.000000000 +0000
@@ -259,9 +259,6 @@ tapeblock_setup_device(struct tape_devic
 	INIT_WORK(&blkdat->requeue_task, tapeblock_requeue,
 		tape_get_device_reference(device));
 
-	/* Will vanish */
-	tape_hotplug_event(device, tapeblock_major, TAPE_HOTPLUG_BLOCK_ADD);
-
 	return 0;
 
 cleanup_queue:
@@ -274,8 +271,6 @@ cleanup_queue:
 void
 tapeblock_cleanup_device(struct tape_device *device)
 {
-	tape_hotplug_event(device, tapeblock_major, TAPE_HOTPLUG_BLOCK_REMOVE);
-
 	flush_scheduled_work();
 	device->blk_data.requeue_task.data = tape_put_device(device);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_char.c linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_char.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_char.c	2004-01-19 06:35:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_char.c	2004-03-02 03:01:24.000000000 +0000
@@ -20,6 +20,7 @@
 
 #include "tape.h"
 #include "tape_std.h"
+#include "tape_class.h"
 
 #define PRINTK_HEADER "TAPE_CHAR: "
 
@@ -47,20 +48,50 @@ static struct file_operations tape_fops 
 
 static int tapechar_major = TAPECHAR_MAJOR;
 
+struct cdev *
+tapechar_register_tape_dev(struct tape_device *device, char *name, int i)
+{
+	struct cdev *	cdev;
+	char		devname[11];
+
+	sprintf(devname, "%s%i", name, i / 2);
+	cdev = register_tape_dev(
+		&device->cdev->dev,
+		MKDEV(tapechar_major, i),
+		&tape_fops,
+		devname
+	);
+
+	return ((IS_ERR(cdev)) ? NULL : cdev);
+}
+
 /*
  * This function is called for every new tapedevice
  */
 int
 tapechar_setup_device(struct tape_device * device)
 {
-	tape_hotplug_event(device, tapechar_major, TAPE_HOTPLUG_CHAR_ADD);
+	device->nt = tapechar_register_tape_dev(
+			device,
+			"ntibm",
+			device->first_minor
+	);
+	device->rt = tapechar_register_tape_dev(
+			device,
+			"rtibm",
+			device->first_minor + 1
+	);
+
 	return 0;
 }
 
 void
 tapechar_cleanup_device(struct tape_device *device)
 {
-	tape_hotplug_event(device, tapechar_major, TAPE_HOTPLUG_CHAR_REMOVE);
+	unregister_tape_dev(device->rt);
+	device->rt = NULL;
+	unregister_tape_dev(device->nt);
+	device->nt = NULL;
 }
 
 /*
@@ -461,20 +492,17 @@ tapechar_ioctl(struct inode *inp, struct
 int
 tapechar_init (void)
 {
-	int rc;
+	dev_t	dev;
 
-	/* Register the tape major number to the kernel */
-	rc = register_chrdev(tapechar_major, "tape", &tape_fops);
-	if (rc < 0) {
-		PRINT_ERR("can't get major %d\n", tapechar_major);
-		DBF_EVENT(3, "TCHAR:initfail\n");
-		return rc;
-	}
-	if (tapechar_major == 0)
-		tapechar_major = rc;  /* accept dynamic major number */
-	PRINT_ERR("Tape gets major %d for char device\n", tapechar_major);
-	DBF_EVENT(3, "Tape gets major %d for char device\n", rc);
-	DBF_EVENT(3, "TCHAR:init ok\n");
+	if (alloc_chrdev_region(&dev, 0, 256, "tape") != 0)
+		return -1;
+
+	tapechar_major = MAJOR(dev);
+	PRINT_INFO("tape gets major %d for character devices\n", MAJOR(dev));
+
+#ifdef TAPE390_INTERNAL_CLASS
+	tape_setup_class();
+#endif
 	return 0;
 }
 
@@ -484,5 +512,10 @@ tapechar_init (void)
 void
 tapechar_exit(void)
 {
-	unregister_chrdev (tapechar_major, "tape");
+#ifdef TAPE390_INTERNAL_CLASS
+	tape_cleanup_class();
+#endif
+	PRINT_INFO("tape releases major %d for character devices\n",
+		tapechar_major);
+	unregister_chrdev_region(MKDEV(tapechar_major, 0), 256);
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_class.c linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_class.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_class.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_class.c	2004-03-02 03:01:24.000000000 +0000
@@ -0,0 +1,100 @@
+/*
+ * Tape class device support
+ *
+ * Author: Stefan Bader <shbader@de.ibm.com>
+ * Based on simple class device code by Greg K-H
+ */
+#include "tape_class.h"
+
+#ifndef TAPE390_INTERNAL_CLASS
+MODULE_AUTHOR("Stefan Bader <shbader@de.ibm.com>");
+MODULE_DESCRIPTION("Tape class");
+MODULE_LICENSE("GPL");
+#endif
+
+struct class_simple *tape_class;
+
+/*
+ * Register a tape device and return a pointer to the cdev structure.
+ *
+ * device
+ *	The pointer to the struct device of the physical (base) device.
+ * drivername
+ *	The pointer to the drivers name for it's character devices.
+ * dev
+ *	The intended major/minor number. The major number may be 0 to
+ *	get a dynamic major number.
+ * fops
+ *	The pointer to the drivers file operations for the tape device.
+ * devname
+ *	The pointer to the name of the character device.
+ */
+struct cdev *register_tape_dev(
+	struct device *		device,
+	dev_t			dev,
+	struct file_operations *fops,
+	char *			devname
+) {
+	struct cdev *	cdev;
+	int		rc;
+	char *		s;
+
+	cdev = cdev_alloc();
+	if (!cdev)
+		return ERR_PTR(-ENOMEM);
+
+	cdev->owner = fops->owner;
+	cdev->ops   = fops;
+	cdev->dev   = dev;
+	strcpy(cdev->kobj.name, devname);
+	for (s = strchr(cdev->kobj.name, '/'); s; s = strchr(s, '/'))
+		*s = '!';
+
+	rc = cdev_add(cdev, cdev->dev, 1);
+	if (rc) {
+		kobject_put(&cdev->kobj);
+		return ERR_PTR(rc);
+	}
+	class_simple_device_add(tape_class, cdev->dev, device, "%s", devname);
+
+	return cdev;
+}
+EXPORT_SYMBOL(register_tape_dev);
+
+void unregister_tape_dev(struct cdev *cdev)
+{
+	if (cdev != NULL) {
+		class_simple_device_remove(cdev->dev);
+		cdev_del(cdev);
+	}
+}
+EXPORT_SYMBOL(unregister_tape_dev);
+
+
+#ifndef TAPE390_INTERNAL_CLASS
+static int __init tape_init(void)
+#else
+int tape_setup_class(void)
+#endif
+{
+	tape_class = class_simple_create(THIS_MODULE, "tape390");
+	return 0;
+}
+
+#ifndef TAPE390_INTERNAL_CLASS
+static void __exit tape_exit(void)
+#else
+void tape_cleanup_class(void)
+#endif
+{
+	class_simple_destroy(tape_class);
+	tape_class = NULL;
+}
+
+#ifndef TAPE390_INTERNAL_CLASS
+postcore_initcall(tape_init);
+module_exit(tape_exit);
+#else
+EXPORT_SYMBOL(tape_setup_class);
+EXPORT_SYMBOL(tape_cleanup_class);
+#endif
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_class.h linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_class.h
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_class.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_class.h	2004-03-02 03:01:24.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+ * Tape class device support
+ *
+ * Author: Stefan Bader <shbader@de.ibm.com>
+ * Based on simple class device code by Greg K-H
+ */
+#ifndef __TAPE_CLASS_H__
+#define __TAPE_CLASS_H__
+
+#if 0
+#include <linux/init.h>
+#include <linux/module.h>
+#endif
+
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/kobject.h>
+#include <linux/kobj_map.h>
+#include <linux/cdev.h>
+
+#include <linux/device.h>
+#include <linux/kdev_t.h>
+
+#define TAPE390_INTERNAL_CLASS
+
+/*
+ * Register a tape device and return a pointer to the cdev structure.
+ *
+ * device
+ *	The pointer to the struct device of the physical (base) device.
+ * drivername
+ *	The pointer to the drivers name for it's character devices.
+ * dev
+ *	The intended major/minor number. The major number may be 0 to
+ *	get a dynamic major number.
+ * fops
+ *	The pointer to the drivers file operations for the tape device.
+ * devname
+ *	The pointer to the name of the character device.
+ */
+struct cdev *register_tape_dev(
+	struct device *		device,
+	dev_t			dev,
+	struct file_operations *fops,
+	char *			devname
+);
+void unregister_tape_dev(struct cdev *cdev);
+
+#ifdef TAPE390_INTERNAL_CLASS
+int tape_setup_class(void);
+void tape_cleanup_class(void);
+#endif
+
+#endif /* __TAPE_CLASS_H__ */
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_core.c linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_core.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/char/tape_core.c	2004-02-19 03:42:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/char/tape_core.c	2004-03-02 03:01:24.000000000 +0000
@@ -237,10 +237,7 @@ __tape_halt_io(struct tape_device *devic
 
 	rc = 0;
 	for (retries = 0; retries < 5; retries++) {
-		if (retries < 2)
-			rc = ccw_device_halt(device->cdev, (long) request);
-		else
-			rc = ccw_device_clear(device->cdev, (long) request);
+		rc = ccw_device_clear(device->cdev, (long) request);
 
 		if (rc == 0) {                     /* Termination successful */
 			request->rc     = -EIO;
@@ -1016,63 +1013,6 @@ tape_mtop(struct tape_device *device, in
 }
 
 /*
- * Hutplug event support.
- */
-void
-tape_hotplug_event(struct tape_device *device, int devmaj, int action) {
-#ifdef CONFIG_HOTPLUG
-	char *argv[3];
-	char *envp[8];
-	char  busid[20];
-	char  major[20];
-	char  minor[20];
-
-	/* Call the busid DEVNO to be compatible with old tape.agent. */
-	sprintf(busid, "DEVNO=%s",   device->cdev->dev.bus_id);
-	sprintf(major, "MAJOR=%d",   devmaj);
-	sprintf(minor, "MINOR=%d",   device->first_minor);
-
-	argv[0] = hotplug_path;
-	argv[1] = "tape";
-	argv[2] = NULL;
-
-	envp[0] = "HOME=/";
-	envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
-
-	switch (action) {
-		case TAPE_HOTPLUG_CHAR_ADD:
-		case TAPE_HOTPLUG_BLOCK_ADD:
-			envp[2] = "ACTION=add";
-			break;
-		case TAPE_HOTPLUG_CHAR_REMOVE:
-		case TAPE_HOTPLUG_BLOCK_REMOVE:
-			envp[2] = "ACTION=remove";
-			break;
-		default:
-			BUG();
-	}
-	switch (action) {
-		case TAPE_HOTPLUG_CHAR_ADD:
-		case TAPE_HOTPLUG_CHAR_REMOVE:
-			envp[3] = "INTERFACE=char";
-			break;
-		case TAPE_HOTPLUG_BLOCK_ADD:
-		case TAPE_HOTPLUG_BLOCK_REMOVE:
-			envp[3] = "INTERFACE=block";
-			break;
-		default:
-			BUG();
-	}
-	envp[4] = busid;
-	envp[5] = major;
-	envp[6] = minor;
-	envp[7] = NULL;
-
-	call_usermodehelper(argv[0], argv, envp, 0);
-#endif
-}
-
-/*
  * Tape init function.
  */
 static int
@@ -1083,7 +1023,7 @@ tape_init (void)
 #ifdef DBF_LIKE_HELL
 	debug_set_level(tape_dbf_area, 6);
 #endif
-	DBF_EVENT(3, "tape init: ($Revision: 1.41 $)\n");
+	DBF_EVENT(3, "tape init: ($Revision: 1.44 $)\n");
 	tape_proc_init();
 	tapechar_init ();
 	tapeblock_init ();
@@ -1108,7 +1048,7 @@ tape_exit(void)
 MODULE_AUTHOR("(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and "
 	      "Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)");
 MODULE_DESCRIPTION("Linux on zSeries channel attached "
-		   "tape device driver ($Revision: 1.41 $)");
+		   "tape device driver ($Revision: 1.44 $)");
 MODULE_LICENSE("GPL");
 
 module_init(tape_init);
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/ccwgroup.c linux-post-2.6.4rc1-20040302/drivers/s390/cio/ccwgroup.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/ccwgroup.c	2004-02-26 11:21:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/ccwgroup.c	2004-03-02 03:01:23.000000000 +0000
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/ccwgroup.c
  *  bus driver for ccwgroup
- *   $Revision: 1.23 $
+ *   $Revision: 1.24 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *                       IBM Corporation
@@ -293,22 +293,28 @@ static ssize_t
 ccwgroup_online_store (struct device *dev, const char *buf, size_t count)
 {
 	struct ccwgroup_device *gdev;
+	struct ccwgroup_driver *gdrv;
 	unsigned int value;
+	int ret;
 
 	gdev = to_ccwgroupdev(dev);
 	if (!dev->driver)
 		return count;
 
-	value = simple_strtoul(buf, 0, 0);
+	gdrv = to_ccwgroupdrv (gdev->dev.driver);
+	if (!try_module_get(gdrv->owner))
+		return -EINVAL;
 
+	value = simple_strtoul(buf, 0, 0);
+	ret = count;
 	if (value == 1)
 		ccwgroup_set_online(gdev);
 	else if (value == 0)
 		ccwgroup_set_offline(gdev);
 	else
-		return -EINVAL;
-
-	return count;
+		ret = -EINVAL;
+	module_put(gdrv->owner);
+	return ret;
 }
 
 static ssize_t
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/cmf.c linux-post-2.6.4rc1-20040302/drivers/s390/cio/cmf.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/cmf.c	2004-02-26 11:21:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/cmf.c	2004-03-02 03:01:23.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/cio/cmf.c ($Revision: 1.11 $)
+ * linux/drivers/s390/cio/cmf.c ($Revision: 1.13 $)
  *
  * Linux on zSeries Channel Measurement Facility support
  *
@@ -138,7 +138,7 @@ static inline u64 time_to_avg_nsec(u32 v
 	if (count == 0)
 		return 0;
 
-	/* value comes in units of 128 5sec */
+	/* value comes in units of 128 sec */
 	ret = time_to_nsec(value);
 	do_div(ret, count);
 
@@ -390,12 +390,13 @@ alloc_cmb (struct ccw_device *cdev)
 		WARN_ON(!list_empty(&cmb_area.list));
 
 		spin_unlock(&cmb_area.lock);
-		mem = kmalloc(size, GFP_KERNEL | GFP_DMA);
+		mem = (void*)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				 get_order(size));
 		spin_lock(&cmb_area.lock);
 
 		if (cmb_area.mem) {
 			/* ok, another thread was faster */
-			kfree(mem);
+			free_pages((unsigned long)mem, get_order(size));
 		} else if (!mem) {
 			/* no luck */
 			ret = -ENOMEM;
@@ -435,8 +436,10 @@ free_cmb(struct ccw_device *cdev)
 	list_del_init(&priv->cmb_list);
 
 	if (list_empty(&cmb_area.list)) {
+		ssize_t size;
+		size = sizeof(struct cmb) * cmb_area.num_channels;
 		cmf_activate(NULL, 0);
-		kfree(cmb_area.mem);
+		free_pages((unsigned long)cmb_area.mem, get_order(size));
 		cmb_area.mem = NULL;
 	}
 out:
@@ -595,11 +598,22 @@ struct cmbe {
 	u32 reserved[7];
 };
 
+/* kmalloc only guarantees 8 byte alignment, but we need cmbe
+ * pointers to be naturally aligned. Make sure to allocate
+ * enough space for two cmbes */
+static inline struct cmbe* cmbe_align(struct cmbe *c)
+{
+	unsigned long addr;
+	addr = ((unsigned long)c + sizeof (struct cmbe) - sizeof(long)) &
+				 ~(sizeof (struct cmbe) - sizeof(long));
+	return (struct cmbe*)addr;
+}
+
 static int
 alloc_cmbe (struct ccw_device *cdev)
 {
 	struct cmbe *cmbe;
-	cmbe = kmalloc (sizeof (*cmbe), GFP_KERNEL /* | GFP_DMA ? */);
+	cmbe = kmalloc (sizeof (*cmbe) * 2, GFP_KERNEL);
 	if (!cmbe)
 		return -ENOMEM;
 
@@ -647,7 +661,7 @@ set_cmbe(struct ccw_device *cdev, u32 mm
 
 	if (!cdev->private->cmb)
 		return -EINVAL;
-	mba = mme ? (unsigned long)cdev->private->cmb : 0;
+	mba = mme ? (unsigned long) cmbe_align(cdev->private->cmb) : 0;
 
 	return set_schib_wait(cdev, mme, 1, mba);
 }
@@ -669,7 +683,7 @@ read_cmbe (struct ccw_device *cdev, int 
 		return 0;
 	}
 
-	cmb = *(struct cmbe*)cdev->private->cmb;
+	cmb = *cmbe_align(cdev->private->cmb);
 	spin_unlock_irqrestore(cdev->ccwlock, flags);
 
 	switch (index) {
@@ -720,7 +734,7 @@ readall_cmbe (struct ccw_device *cdev, s
 		return -ENODEV;
 	}
 
-	cmb = *(struct cmbe*)cdev->private->cmb;
+	cmb = *cmbe_align(cdev->private->cmb);
 	time = get_clock() - cdev->private->cmb_start_time;
 	spin_unlock_irqrestore(cdev->ccwlock, flags);
 
@@ -760,7 +774,7 @@ reset_cmbe(struct ccw_device *cdev)
 {
 	struct cmbe *cmb;
 	spin_lock_irq(cdev->ccwlock);
-	cmb = cdev->private->cmb;
+	cmb = cmbe_align(cdev->private->cmb);
 	if (cmb)
 		memset (cmb, 0, sizeof (*cmb));
 	cdev->private->cmb_start_time = get_clock();
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/css.h linux-post-2.6.4rc1-20040302/drivers/s390/cio/css.h
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/css.h	2004-02-26 11:21:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/css.h	2004-03-02 03:01:23.000000000 +0000
@@ -74,6 +74,7 @@ struct ccw_device_private {
 		unsigned int fast:1;	/* post with "channel end" */
 		unsigned int repall:1;	/* report every interrupt status */
 		unsigned int pgroup:1;  /* do path grouping */
+		unsigned int force:1;   /* allow forced online */
 	} __attribute__ ((packed)) options;
 	struct {
 		unsigned int pgid_single:1; /* use single path for Set PGID */
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/device.c linux-post-2.6.4rc1-20040302/drivers/s390/cio/device.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/device.c	2004-02-26 11:21:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/device.c	2004-03-02 03:01:23.000000000 +0000
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device.c
  *  bus driver for ccw devices
- *   $Revision: 1.103 $
+ *   $Revision: 1.107 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -263,10 +263,10 @@ ccw_device_set_offline(struct ccw_device
 
 	if (!cdev)
 		return -ENODEV;
-	if (!cdev->online || !cdev->drv)
+	if (!cdev->online)
 		return -EINVAL;
 
-	if (cdev->drv->set_offline) {
+	if (cdev->drv && cdev->drv->set_offline) {
 		ret = cdev->drv->set_offline(cdev);
 		if (ret != 0)
 			return ret;
@@ -292,7 +292,7 @@ ccw_device_set_online(struct ccw_device 
 
 	if (!cdev)
 		return -ENODEV;
-	if (cdev->online || !cdev->drv)
+	if (cdev->online)
 		return -EINVAL;
 
 	spin_lock_irq(cdev->ccwlock);
@@ -307,7 +307,8 @@ ccw_device_set_online(struct ccw_device 
 	}
 	if (cdev->private->state != DEV_STATE_ONLINE)
 		return -ENODEV;
-	if (!cdev->drv->set_online || cdev->drv->set_online(cdev) == 0) {
+	if (!cdev->drv || !cdev->drv->set_online ||
+	    cdev->drv->set_online(cdev) == 0) {
 		cdev->online = 1;
 		return 0;
 	}
@@ -326,52 +327,54 @@ static ssize_t
 online_store (struct device *dev, const char *buf, size_t count)
 {
 	struct ccw_device *cdev = to_ccwdev(dev);
-	int i;
+	int i, force;
 	char *tmp;
 
-	if (!cdev->drv)
-		return count;
 	if (atomic_compare_and_swap(0, 1, &cdev->private->onoff))
 		return -EAGAIN;
 
-	i = simple_strtoul(buf, &tmp, 16);
-	if (i == 1 && cdev->drv->set_online)
+	if (cdev->drv && !try_module_get(cdev->drv->owner)) {
+		atomic_set(&cdev->private->onoff, 0);
+		return -EINVAL;
+	}
+	if (!strncmp(buf, "force\n", count)) {
+		force = 1;
+		i = 1;
+	} else {
+		force = 0;
+		i = simple_strtoul(buf, &tmp, 16);
+	}
+	if (i == 1) {
+		/* Do device recognition, if needed. */
+		if (cdev->id.cu_type == 0) {
+			ccw_device_recognition(cdev);
+			wait_event(cdev->private->wait_q,
+				   dev_fsm_final_state(cdev));
+		}
 		ccw_device_set_online(cdev);
-	else if (i == 0 && cdev->drv->set_offline) {
+	} else if (i == 0) {
 		if (cdev->private->state == DEV_STATE_DISCONNECTED)
 			ccw_device_remove_disconnected(cdev);
 		else
 			ccw_device_set_offline(cdev);
 	}
-	atomic_set(&cdev->private->onoff, 0);
-	return count;
-}
-
-static void ccw_device_unbox_recog(void *data);
-
-static ssize_t
-stlck_store(struct device *dev, const char *buf, size_t count)
-{
-	struct ccw_device *cdev = to_ccwdev(dev);
-	int ret;
-
-	/* We don't care what was piped to the attribute 8) */
-	ret = ccw_device_stlck(cdev);
-	if (ret != 0) {
-		printk(KERN_WARNING
-		       "Unconditional reserve failed on device %s, rc=%d\n",
-		       dev->bus_id, ret);
-		return ret;
+	if (force && cdev->private->state == DEV_STATE_BOXED) {
+		int ret;
+		ret = ccw_device_stlck(cdev);
+		if (ret)
+			goto out;
+		/* Do device recognition, if needed. */
+		if (cdev->id.cu_type == 0) {
+			ccw_device_recognition(cdev);
+			wait_event(cdev->private->wait_q,
+				   dev_fsm_final_state(cdev));
+		}
+		ccw_device_set_online(cdev);
 	}
-
-	/*
-	 * Device was successfully unboxed.
-	 * Trigger removal of stlck attribute and device recognition.
-	 */
-	INIT_WORK(&cdev->private->kick_work,
-		  ccw_device_unbox_recog, (void *) cdev);
-	queue_work(ccw_device_work, &cdev->private->kick_work);
-	
+	out:
+	if (cdev->drv)
+		module_put(cdev->drv->owner);
+	atomic_set(&cdev->private->onoff, 0);
 	return count;
 }
 
@@ -403,33 +406,9 @@ static DEVICE_ATTR(pimpampom, 0444, pimp
 static DEVICE_ATTR(devtype, 0444, devtype_show, NULL);
 static DEVICE_ATTR(cutype, 0444, cutype_show, NULL);
 static DEVICE_ATTR(online, 0644, online_show, online_store);
-static DEVICE_ATTR(steal_lock, 0200, NULL, stlck_store);
 extern struct device_attribute dev_attr_cmb_enable;
 static DEVICE_ATTR(availability, 0444, available_show, NULL);
 
-/* A device has been unboxed. Start device recognition. */
-static void
-ccw_device_unbox_recog(void *data)
-{
-	struct ccw_device *cdev;
-
-	cdev = (struct ccw_device *)data;
-	if (!cdev)
-		return;
-
-	/* Remove stlck attribute. */
-	device_remove_file(&cdev->dev, &dev_attr_steal_lock);
-
-	spin_lock_irq(cdev->ccwlock);
-
-	/* Device is no longer boxed. */
-	cdev->private->state = DEV_STATE_NOT_OPER;
-
-	/* Finally start device recognition. */
-	ccw_device_recognition(cdev);
-	spin_unlock_irq(cdev->ccwlock);
-}
-
 static struct attribute * subch_attrs[] = {
 	&dev_attr_chpids.attr,
 	&dev_attr_pimpampom.attr,
@@ -471,22 +450,6 @@ device_remove_files(struct device *dev)
 	sysfs_remove_group(&dev->kobj, &ccwdev_attr_group);
 }
 
-/*
- * Add a "steal lock" attribute to boxed devices.
- * This allows to trigger an unconditional reserve ccw to eckd dasds
- * (if the device is something else, there should be no problems more than
- * a command reject; we don't have any means of finding out the device's
- * type if it was boxed at ipl/attach for older devices and under VM).
- */
-void
-ccw_device_add_stlck(void *data)
-{
-	struct ccw_device *cdev;
-
-	cdev = (struct ccw_device *)data;
-	device_create_file(&cdev->dev, &dev_attr_steal_lock);
-}
-
 /* this is a simple abstraction for device_register that sets the
  * correct bus type and adds the bus specific files */
 int
@@ -565,8 +528,6 @@ io_subchannel_register(void *data)
 	if (ret)
 		printk(KERN_WARNING "%s: could not add attributes to %s\n",
 		       __func__, sch->dev.bus_id);
-	if (cdev->private->state == DEV_STATE_BOXED)
-		device_create_file(&cdev->dev, &dev_attr_steal_lock);
 	put_device(&cdev->dev);
 out:
 	put_device(&sch->dev);
@@ -935,6 +896,7 @@ ccw_device_remove (struct device *dev)
 			pr_debug("ccw_device_offline returned %d, device %s\n",
 				 ret, cdev->dev.bus_id);
 	}
+	ccw_device_set_timeout(cdev, 0);
 	cdev->drv = 0;
 	return 0;
 }
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/device.h linux-post-2.6.4rc1-20040302/drivers/s390/cio/device.h
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/device.h	2004-02-26 11:21:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/device.h	2004-03-02 03:01:23.000000000 +0000
@@ -102,7 +102,6 @@ void ccw_device_disband_done(struct ccw_
 
 int ccw_device_call_handler(struct ccw_device *);
 
-void ccw_device_add_stlck(void *);
 int ccw_device_stlck(struct ccw_device *);
 
 /* qdio needs this. */
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/device_fsm.c linux-post-2.6.4rc1-20040302/drivers/s390/cio/device_fsm.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/device_fsm.c	2004-02-26 11:21:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/device_fsm.c	2004-03-02 03:01:23.000000000 +0000
@@ -317,14 +317,10 @@ ccw_device_done(struct ccw_device *cdev,
 	cdev->private->state = state;
 
 
-	if (state == DEV_STATE_BOXED) {
+	if (state == DEV_STATE_BOXED)
 		CIO_DEBUG(KERN_WARNING, 2,
 			  "Boxed device %04x on subchannel %04x\n",
 			  cdev->private->devno, sch->irq);
-		INIT_WORK(&cdev->private->kick_work,
-			  ccw_device_add_stlck, (void *) cdev);
-		queue_work(ccw_device_work, &cdev->private->kick_work);
-	}
 
 	if (cdev->private->flags.donotify) {
 		cdev->private->flags.donotify = 0;
@@ -377,7 +373,8 @@ ccw_device_recognition(struct ccw_device
 	struct subchannel *sch;
 	int ret;
 
-	if (cdev->private->state != DEV_STATE_NOT_OPER)
+	if ((cdev->private->state != DEV_STATE_NOT_OPER) &&
+	    (cdev->private->state != DEV_STATE_BOXED))
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
 	ret = cio_enable_subchannel(sch, sch->schib.pmcw.isc);
@@ -492,7 +489,8 @@ ccw_device_online(struct ccw_device *cde
 	struct subchannel *sch;
 	int ret;
 
-	if (cdev->private->state != DEV_STATE_OFFLINE)
+	if ((cdev->private->state != DEV_STATE_OFFLINE) &&
+	    (cdev->private->state != DEV_STATE_BOXED))
 		return -EINVAL;
 	sch = to_subchannel(cdev->dev.parent);
 	if (css_init_done && !get_device(&cdev->dev))
@@ -615,6 +613,13 @@ ccw_device_online_notoper(struct ccw_dev
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
+	if (sch->driver->notify &&
+	    sch->driver->notify(&sch->dev, sch->lpm ? CIO_GONE : CIO_NO_PATH)) {
+			ccw_device_set_timeout(cdev, 0);
+			cdev->private->state = DEV_STATE_DISCONNECTED;
+			wake_up(&cdev->private->wait_q);
+			return;
+	}
 	cdev->private->state = DEV_STATE_NOT_OPER;
 	cio_disable_subchannel(sch);
 	if (sch->schib.scsw.actl != 0) {
@@ -627,21 +632,6 @@ ccw_device_online_notoper(struct ccw_dev
 	wake_up(&cdev->private->wait_q);
 }
 
-static void
-ccw_device_disconnected_notoper(struct ccw_device *cdev,
-				enum dev_event dev_event)
-{
-	struct subchannel *sch;
-
-	sch = to_subchannel(cdev->dev.parent);
-	cdev->private->state = DEV_STATE_NOT_OPER;
-	cio_disable_subchannel(sch);
-	device_unregister(&sch->dev);
-	sch->schib.pmcw.intparm = 0;
-	cio_modify(sch);
-	wake_up(&cdev->private->wait_q);
-}
-
 /*
  * Handle path verification event.
  */
@@ -1103,7 +1093,7 @@ fsm_func_t *dev_jumptable[NR_DEV_STATES]
 	},
 	/* special states for devices gone not operational */
 	[DEV_STATE_DISCONNECTED] {
-		[DEV_EVENT_NOTOPER]	ccw_device_disconnected_notoper,
+		[DEV_EVENT_NOTOPER]	ccw_device_nop,
 		[DEV_EVENT_INTERRUPT]	ccw_device_start_id,
 		[DEV_EVENT_TIMEOUT]	ccw_device_bug,
 		[DEV_EVENT_VERIFY]	ccw_device_nop,
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/cio/device_ops.c linux-post-2.6.4rc1-20040302/drivers/s390/cio/device_ops.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/cio/device_ops.c	2004-02-26 11:21:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/cio/device_ops.c	2004-03-02 03:01:23.000000000 +0000
@@ -38,6 +38,7 @@ ccw_device_set_options(struct ccw_device
 	cdev->private->options.fast = (flags & CCWDEV_EARLY_NOTIFICATION) != 0;
 	cdev->private->options.repall = (flags & CCWDEV_REPORT_ALL) != 0;
 	cdev->private->options.pgroup = (flags & CCWDEV_DO_PATHGROUP) != 0;
+	cdev->private->options.force = (flags & CCWDEV_ALLOW_FORCE) != 0;
 	return 0;
 }
 
@@ -453,6 +454,9 @@ ccw_device_stlck(struct ccw_device *cdev
 	if (!cdev)
 		return -ENODEV;
 
+	if (cdev->drv && !cdev->private->options.force)
+		return -EINVAL;
+
 	sch = to_subchannel(cdev->dev.parent);
 	
 	CIO_TRACE_EVENT(2, "stl lock");
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/net/ctcmain.c linux-post-2.6.4rc1-20040302/drivers/s390/net/ctcmain.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/net/ctcmain.c	2004-02-26 11:21:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/net/ctcmain.c	2004-03-02 03:01:23.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.54 2004/02/18 12:35:59 ptiedem Exp $
+ * $Id: ctcmain.c,v 1.56 2004/02/27 17:53:26 mschwide Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.54 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.56 $
  *
  */
 
@@ -319,7 +319,7 @@ static void
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.54 $";
+	char vbuf[] = "$Revision: 1.56 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -3161,6 +3161,7 @@ ctc_remove_device(struct ccwgroup_device
 }
 
 static struct ccwgroup_driver ctc_group_driver = {
+	.owner       = THIS_MODULE,
 	.name        = "ctc",
 	.max_slaves  = 2,
 	.driver_id   = 0xC3E3C3,
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/net/lcs.c linux-post-2.6.4rc1-20040302/drivers/s390/net/lcs.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/net/lcs.c	2004-02-26 11:21:53.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/net/lcs.c	2004-03-02 03:01:23.000000000 +0000
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision: 1.66 $	 $Date: 2004/02/19 13:46:01 $
+ *    $Revision: 1.67 $	 $Date: 2004/02/26 18:26:50 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -58,7 +58,7 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision: 1.66 $"
+#define VERSION_LCS_C  "$Revision: 1.67 $"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
 
@@ -1926,6 +1926,7 @@ lcs_remove_device(struct ccwgroup_device
  * LCS ccwgroup driver registration
  */
 static struct ccwgroup_driver lcs_group_driver = {
+	.owner       = THIS_MODULE,
 	.name        = "lcs",
 	.max_slaves  = 2,
 	.driver_id   = 0xD3C3E2,
diff -purN linux-post-2.6.4rc1-20040301/drivers/s390/net/qeth.c linux-post-2.6.4rc1-20040302/drivers/s390/net/qeth.c
--- linux-post-2.6.4rc1-20040301/drivers/s390/net/qeth.c	2004-01-19 23:44:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/s390/net/qeth.c	2004-03-02 03:01:23.000000000 +0000
@@ -10773,6 +10773,7 @@ qeth_remove_device(struct ccwgroup_devic
 }
 
 static struct ccwgroup_driver qeth_ccwgroup_driver = {
+	.owner = THIS_MODULE,
 	.name = "qeth",
 	.driver_id = 0xD8C5E3C8,
 	.probe = qeth_probe_device,
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/BusLogic.c linux-post-2.6.4rc1-20040302/drivers/scsi/BusLogic.c
--- linux-post-2.6.4rc1-20040301/drivers/scsi/BusLogic.c	2004-02-13 15:19:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/BusLogic.c	2004-03-02 03:01:45.000000000 +0000
@@ -189,7 +189,7 @@ static void __init BusLogic_RegisterHost
   registered BusLogic Host Adapters.
 */
 
-static void __init BusLogic_UnregisterHostAdapter(struct BusLogic_HostAdapter *HostAdapter)
+static void BusLogic_UnregisterHostAdapter(struct BusLogic_HostAdapter *HostAdapter)
 {
   if (HostAdapter == BusLogic_FirstRegisteredHostAdapter)
     {
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/libata-core.c linux-post-2.6.4rc1-20040302/drivers/scsi/libata-core.c
--- linux-post-2.6.4rc1-20040301/drivers/scsi/libata-core.c	2004-02-26 03:41:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/libata-core.c	2004-02-28 22:01:12.000000000 +0000
@@ -2005,6 +2005,14 @@ void ata_eng_timeout(struct ata_port *ap
 		goto out;
 	}
 
+	/* hack alert!  We cannot use the supplied completion
+	 * function from inside the ->eh_strategy_handler() thread.
+	 * libata is the only user of ->eh_strategy_handler() in
+	 * any kernel, so the default scsi_done() assumes it is
+	 * not being called from the SCSI EH.
+	 */
+	qc->scsidone = scsi_finish_command;
+
 	switch (qc->tf.protocol) {
 	case ATA_PROT_DMA_READ:
 	case ATA_PROT_DMA_WRITE:
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/scsi.c linux-post-2.6.4rc1-20040302/drivers/scsi/scsi.c
--- linux-post-2.6.4rc1-20040301/drivers/scsi/scsi.c	2004-02-24 17:34:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/scsi.c	2004-02-28 22:01:12.000000000 +0000
@@ -847,6 +847,7 @@ void scsi_finish_command(struct scsi_cmn
 
 	cmd->done(cmd);
 }
+EXPORT_SYMBOL(scsi_finish_command);
 
 /*
  * Function:	scsi_adjust_queue_depth()
diff -purN linux-post-2.6.4rc1-20040301/drivers/scsi/scsi_priv.h linux-post-2.6.4rc1-20040302/drivers/scsi/scsi_priv.h
--- linux-post-2.6.4rc1-20040301/drivers/scsi/scsi_priv.h	2003-09-29 12:37:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/scsi/scsi_priv.h	2004-02-28 22:01:12.000000000 +0000
@@ -77,7 +77,6 @@ extern int scsi_dispatch_cmd(struct scsi
 extern int scsi_setup_command_freelist(struct Scsi_Host *shost);
 extern void scsi_destroy_command_freelist(struct Scsi_Host *shost);
 extern void scsi_done(struct scsi_cmnd *cmd);
-extern void scsi_finish_command(struct scsi_cmnd *cmd);
 extern int scsi_retry_command(struct scsi_cmnd *cmd);
 extern int scsi_insert_special_req(struct scsi_request *sreq, int);
 extern void scsi_init_cmd_from_req(struct scsi_cmnd *cmd,
diff -purN linux-post-2.6.4rc1-20040301/drivers/usb/class/usblp.c linux-post-2.6.4rc1-20040302/drivers/usb/class/usblp.c
--- linux-post-2.6.4rc1-20040301/drivers/usb/class/usblp.c	2004-02-09 15:03:32.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/usb/class/usblp.c	2004-03-01 07:17:24.000000000 +0000
@@ -603,7 +603,7 @@ static ssize_t usblp_write(struct file *
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct usblp *usblp = file->private_data;
-	int timeout, err = 0, transfer_length;
+	int timeout, err = 0, transfer_length = 0;
 	size_t writecount = 0;
 
 	while (writecount < count) {
@@ -654,6 +654,16 @@ static ssize_t usblp_write(struct file *
 			continue;
 		}
 
+		/* We must increment writecount here, and not at the
+		 * end of the loop. Otherwise, the final loop iteration may
+		 * be skipped, leading to incomplete printer output.
+		 */
+		writecount += transfer_length;
+		if (writecount == count) {
+			up(&usblp->sem);
+			break;
+		}
+
 		transfer_length=(count - writecount);
 		if (transfer_length > USBLP_BUF_SIZE)
 			transfer_length = USBLP_BUF_SIZE;
@@ -677,8 +687,6 @@ static ssize_t usblp_write(struct file *
 			break;
 		}
 		up (&usblp->sem);
-
-		writecount += transfer_length;
 	}
 
 	return count;
diff -purN linux-post-2.6.4rc1-20040301/drivers/usb/host/ohci-sa1111.c linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-sa1111.c
--- linux-post-2.6.4rc1-20040301/drivers/usb/host/ohci-sa1111.c	2004-02-27 21:50:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-sa1111.c	2004-02-28 17:37:22.000000000 +0000
@@ -120,7 +120,13 @@ static irqreturn_t usb_hcd_sa1111_hcim_i
 	}
 #endif
 
-	return usb_hcd_irq(irq, hcd, r);
+	usb_hcd_irq(irq, hcd, r);
+
+	/*
+	 * SA1111 seems to re-assert its interrupt immediately
+	 * after processing an interrupt.  Always return IRQ_HANDLED.
+	 */
+	return IRQ_HANDLED;
 }
 
 /*-------------------------------------------------------------------------*/
diff -purN linux-post-2.6.4rc1-20040301/drivers/usb/serial/keyspan.h linux-post-2.6.4rc1-20040302/drivers/usb/serial/keyspan.h
--- linux-post-2.6.4rc1-20040301/drivers/usb/serial/keyspan.h	2004-02-09 12:00:23.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/usb/serial/keyspan.h	2004-03-02 03:01:28.000000000 +0000
@@ -359,19 +359,19 @@ static const struct keyspan_device_detai
 };
 
 static const struct keyspan_device_details usa19hs_device_details = {
-	product_id:		keyspan_usa19hs_product_id,
-	msg_format:		msg_usa90,
-	num_ports:		1,
-	indat_endp_flip:	0,
-	outdat_endp_flip:	0,
-	indat_endpoints:	{0x81},
-	outdat_endpoints:	{0x01},
-	inack_endpoints:	{-1},
-	outcont_endpoints:	{0x02},
-	instat_endpoint:	0x82,
-	glocont_endpoint:	-1,
-	calculate_baud_rate:	keyspan_usa19hs_calc_baud,
-	baudclk:		KEYSPAN_USA19HS_BAUDCLK,
+	.product_id		= keyspan_usa19hs_product_id,
+	.msg_format		= msg_usa90,
+	.num_ports		= 1,
+	.indat_endp_flip	= 0,
+	.outdat_endp_flip	= 0,
+	.indat_endpoints	= {0x81},
+	.outdat_endpoints	= {0x01},
+	.inack_endpoints	= {-1},
+	.outcont_endpoints	= {0x02},
+	.instat_endpoint	= 0x82,
+	.glocont_endpoint	= -1,
+	.calculate_baud_rate	= keyspan_usa19hs_calc_baud,
+	.baudclk		= KEYSPAN_USA19HS_BAUDCLK,
 };
 
 static const struct keyspan_device_details usa28_device_details = {
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/console/fbcon.c linux-post-2.6.4rc1-20040302/drivers/video/console/fbcon.c
--- linux-post-2.6.4rc1-20040301/drivers/video/console/fbcon.c	2004-02-27 05:33:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/console/fbcon.c	2004-03-02 03:01:44.000000000 +0000
@@ -159,7 +159,7 @@ static int fbcon_scroll(struct vc_data *
 static void fbcon_bmove(struct vc_data *vc, int sy, int sx, int dy, int dx,
 			int height, int width);
 static int fbcon_switch(struct vc_data *vc);
-static int fbcon_blank(struct vc_data *vc, int blank);
+static int fbcon_blank(struct vc_data *vc, int blank, int mode_switch);
 static int fbcon_font_op(struct vc_data *vc, struct console_font_op *op);
 static int fbcon_set_palette(struct vc_data *vc, unsigned char *table);
 static int fbcon_scrolldelta(struct vc_data *vc, int lines);
@@ -1697,14 +1697,23 @@ static int fbcon_switch(struct vc_data *
 	return 1;
 }
 
-static int fbcon_blank(struct vc_data *vc, int blank)
+static int fbcon_blank(struct vc_data *vc, int blank, int mode_switch)
 {
 	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
 	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
 	struct display *p = &fb_display[vc->vc_num];
 
-	if (blank < 0)		/* Entering graphics mode */
-		return 0;
+	if (mode_switch) {
+		struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
+		struct fb_var_screeninfo var = info->var;
+
+		if (blank) {
+			fbcon_cursor(vc, CM_ERASE);
+			return 0;
+		}
+		var.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+		fb_set_var(info, &var);
+	}
 
 	fbcon_cursor(vc, blank ? CM_ERASE : CM_DRAW);
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/console/promcon.c linux-post-2.6.4rc1-20040302/drivers/video/console/promcon.c
--- linux-post-2.6.4rc1-20040301/drivers/video/console/promcon.c	2002-12-11 03:49:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/console/promcon.c	2004-03-02 03:01:44.000000000 +0000
@@ -463,7 +463,7 @@ promcon_font_op(struct vc_data *conp, st
 }
         
 static int
-promcon_blank(struct vc_data *conp, int blank)
+promcon_blank(struct vc_data *conp, int blank, int mode_switch)
 {
 	if (blank) {
 		promcon_puts("\033[H\033[J\033[7m \033[m\b", 15);
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/console/sticon.c linux-post-2.6.4rc1-20040302/drivers/video/console/sticon.c
--- linux-post-2.6.4rc1-20040301/drivers/video/console/sticon.c	2003-01-08 00:45:15.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/console/sticon.c	2004-03-02 03:01:44.000000000 +0000
@@ -250,26 +250,18 @@ static int sticon_set_origin(struct vc_d
     return 0;
 }
 
-static int sticon_blank(struct vc_data *c, int blank)
+static int sticon_blank(struct vc_data *c, int blank, int mode_switch)
 {
-    switch (blank) {
-    case 0:		/* unblank */
-	vga_is_gfx = 0;
-	/* Tell console.c that it has to restore the screen itself */
-	return 1;
-    case 1:		/* normal blanking */
-    default:		/* VESA blanking */
-	if (vga_is_gfx)
-		return 0;
-	sticon_set_origin(c);
-	sti_clear(sticon_sti, 0,0, c->vc_rows, c->vc_cols, BLANK);
-	return 1;
-    case -1:		/* Entering graphic mode */
-	sti_clear(sticon_sti, 0,0, c->vc_rows, c->vc_cols, BLANK);
-	vga_is_gfx = 1;
+    if (blank == 0) {
+	if (mode_switch)
+	    vga_is_gfx = 0;
 	return 1;
     }
-    return 1;		/* console needs to restore screen itself */
+    sticon_set_origin(c);
+    sti_clear(sticon_sti, 0,0, c->vc_rows, c->vc_cols, BLANK);
+    if (mode_switch)
+	vga_is_gfx = 1;
+    return 1;
 }
 
 static int sticon_scrolldelta(struct vc_data *conp, int lines)
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/console/vgacon.c linux-post-2.6.4rc1-20040302/drivers/video/console/vgacon.c
--- linux-post-2.6.4rc1-20040301/drivers/video/console/vgacon.c	2003-03-11 17:17:29.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/console/vgacon.c	2004-03-02 03:01:44.000000000 +0000
@@ -76,7 +76,7 @@ static void vgacon_init(struct vc_data *
 static void vgacon_deinit(struct vc_data *c);
 static void vgacon_cursor(struct vc_data *c, int mode);
 static int vgacon_switch(struct vc_data *c);
-static int vgacon_blank(struct vc_data *c, int blank);
+static int vgacon_blank(struct vc_data *c, int blank, int mode_switch);
 static int vgacon_font_op(struct vc_data *c, struct console_font_op *op);
 static int vgacon_set_palette(struct vc_data *vc, unsigned char *table);
 static int vgacon_scrolldelta(struct vc_data *c, int lines);
@@ -661,7 +661,7 @@ static void vga_pal_blank(struct vgastat
 	}
 }
 
-static int vgacon_blank(struct vc_data *c, int blank)
+static int vgacon_blank(struct vc_data *c, int blank, int mode_switch)
 {
 	switch (blank) {
 	case 0:		/* Unblank */
@@ -678,7 +678,8 @@ static int vgacon_blank(struct vc_data *
 		/* Tell console.c that it has to restore the screen itself */
 		return 1;
 	case 1:		/* Normal blanking */
-		if (vga_video_type == VIDEO_TYPE_VGAC) {
+	case -1:	/* Obsolete */
+		if (!mode_switch && vga_video_type == VIDEO_TYPE_VGAC) {
 			vga_pal_blank(&state);
 			vga_palette_blanked = 1;
 			return 0;
@@ -686,11 +687,8 @@ static int vgacon_blank(struct vc_data *
 		vgacon_set_origin(c);
 		scr_memsetw((void *) vga_vram_base, BLANK,
 			    c->vc_screenbuf_size);
-		return 1;
-	case -1:		/* Entering graphic mode */
-		scr_memsetw((void *) vga_vram_base, BLANK,
-			    c->vc_screenbuf_size);
-		vga_is_gfx = 1;
+		if (mode_switch)
+			vga_is_gfx = 1;
 		return 1;
 	default:		/* VESA blanking */
 		if (vga_video_type == VIDEO_TYPE_VGAC) {
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/fbmem.c linux-post-2.6.4rc1-20040302/drivers/video/fbmem.c
--- linux-post-2.6.4rc1-20040301/drivers/video/fbmem.c	2004-02-27 05:33:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/fbmem.c	2004-03-02 03:01:44.000000000 +0000
@@ -955,7 +955,8 @@ fb_set_var(struct fb_info *info, struct 
 {
 	int err;
 
-	if (memcmp(&info->var, var, sizeof(struct fb_var_screeninfo))) {
+	if ((var->activate & FB_ACTIVATE_FORCE) ||
+	    memcmp(&info->var, var, sizeof(struct fb_var_screeninfo))) {
 		if (!info->fbops->fb_check_var) {
 			*var = info->var;
 			return 0;
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/i810/Makefile linux-post-2.6.4rc1-20040302/drivers/video/i810/Makefile
--- linux-post-2.6.4rc1-20040301/drivers/video/i810/Makefile	2003-01-01 13:00:16.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/i810/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,12 +1,6 @@
 #
 # Makefile for the Intel 810/815 framebuffer driver
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile...
-
 
 obj-$(CONFIG_FB_I810)		+= i810fb.o
 
diff -purN linux-post-2.6.4rc1-20040301/drivers/video/kyro/Makefile linux-post-2.6.4rc1-20040302/drivers/video/kyro/Makefile
--- linux-post-2.6.4rc1-20040301/drivers/video/kyro/Makefile	2004-01-19 06:22:21.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/drivers/video/kyro/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,11 +1,6 @@
 #
 # Makefile for the Kyro framebuffer driver
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile...
 
 obj-$(CONFIG_FB_KYRO)	+= kyrofb.o
 
diff -purN linux-post-2.6.4rc1-20040301/fs/befs/Makefile linux-post-2.6.4rc1-20040302/fs/befs/Makefile
--- linux-post-2.6.4rc1-20040301/fs/befs/Makefile	2002-12-14 12:38:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/fs/befs/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,12 +1,6 @@
 #
 # Makefile for the linux BeOS filesystem routines.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile...
-
  
 obj-$(CONFIG_BEFS_FS) += befs.o
 
diff -purN linux-post-2.6.4rc1-20040301/fs/compat_ioctl.c linux-post-2.6.4rc1-20040302/fs/compat_ioctl.c
--- linux-post-2.6.4rc1-20040301/fs/compat_ioctl.c	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/fs/compat_ioctl.c	2004-03-01 14:18:41.000000000 +0000
@@ -1458,6 +1458,7 @@ static int cdrom_do_generic_command(unsi
 	struct cdrom_generic_command *cgc;
 	struct cdrom_generic_command32 *cgc32;
 	unsigned char dir;
+	int itmp;
 
 	cgc = compat_alloc_user_space(sizeof(*cgc));
 	cgc32 = compat_ptr(arg);
@@ -1469,12 +1470,16 @@ static int cdrom_do_generic_command(unsi
 	    __cgc_do_ptr((void **) &cgc->sense, &cgc32->sense))
 		return -EFAULT;
 
-	if (get_user(dir, &cgc->data_direction) ||
-	    put_user(dir, &cgc32->data_direction))
+	if (get_user(dir, &cgc32->data_direction) ||
+	    put_user(dir, &cgc->data_direction))
 		return -EFAULT;
 
-	if (copy_in_user(&cgc->quiet, &cgc32->quiet,
-			 2 * sizeof(int)))
+	if (get_user(itmp, &cgc32->quiet) ||
+	    put_user(itmp, &cgc->quiet))
+		return -EFAULT;
+
+	if (get_user(itmp, &cgc32->timeout) ||
+	    put_user(itmp, &cgc->timeout))
 		return -EFAULT;
 
 	if (__cgc_do_ptr(&cgc->reserved[0], &cgc32->reserved[0]))
diff -purN linux-post-2.6.4rc1-20040301/fs/fs-writeback.c linux-post-2.6.4rc1-20040302/fs/fs-writeback.c
--- linux-post-2.6.4rc1-20040301/fs/fs-writeback.c	2004-02-04 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/fs/fs-writeback.c	2004-03-02 03:01:21.000000000 +0000
@@ -99,7 +99,7 @@ void __mark_inode_dirty(struct inode *in
 		 * reposition it (that would break s_dirty time-ordering).
 		 */
 		if (!was_dirty) {
-			mapping->dirtied_when = jiffies|1; /* 0 is special */
+			mapping->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		}
 	}
@@ -176,17 +176,15 @@ __sync_single_inode(struct inode *inode,
 		} else if (!list_empty(&mapping->dirty_pages)) {
 			/* Redirtied */
 			inode->i_state |= I_DIRTY_PAGES;
-			mapping->dirtied_when = jiffies|1;
+			mapping->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		} else if (inode->i_state & I_DIRTY) {
 			/* Redirtied */
-			mapping->dirtied_when = jiffies|1;
+			mapping->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		} else if (atomic_read(&inode->i_count)) {
-			mapping->dirtied_when = 0;
 			list_move(&inode->i_list, &inode_in_use);
 		} else {
-			mapping->dirtied_when = 0;
 			list_move(&inode->i_list, &inode_unused);
 		}
 	}
@@ -310,7 +308,7 @@ sync_sb_inodes(struct super_block *sb, s
 		__iget(inode);
 		__writeback_single_inode(inode, wbc);
 		if (wbc->sync_mode == WB_SYNC_HOLD) {
-			mapping->dirtied_when = jiffies|1;
+			mapping->dirtied_when = jiffies;
 			list_move(&inode->i_list, &sb->s_dirty);
 		}
 		if (current_is_pdflush())
diff -purN linux-post-2.6.4rc1-20040301/fs/proc/base.c linux-post-2.6.4rc1-20040302/fs/proc/base.c
--- linux-post-2.6.4rc1-20040301/fs/proc/base.c	2004-02-19 03:43:02.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/fs/proc/base.c	2004-03-02 03:01:27.000000000 +0000
@@ -1582,13 +1582,14 @@ struct dentry *proc_pid_lookup(struct in
 	read_unlock(&tasklist_lock);
 	if (!task)
 		goto out;
-	if (!thread_group_leader(task))
-		goto out_drop_task;
 
 	inode = proc_pid_make_inode(dir->i_sb, task, PROC_TGID_INO);
 
-	if (!inode)
-		goto out_drop_task;
+
+	if (!inode) {
+		put_task_struct(task);
+		goto out;
+	}
 	inode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;
 	inode->i_op = &proc_tgid_base_inode_operations;
 	inode->i_fop = &proc_tgid_base_operations;
@@ -1613,8 +1614,6 @@ struct dentry *proc_pid_lookup(struct in
 		goto out;
 	}
 	return NULL;
-out_drop_task:
-	put_task_struct(task);
 out:
 	return ERR_PTR(-ENOENT);
 }
diff -purN linux-post-2.6.4rc1-20040301/include/asm-m68k/irq.h linux-post-2.6.4rc1-20040302/include/asm-m68k/irq.h
--- linux-post-2.6.4rc1-20040301/include/asm-m68k/irq.h	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-m68k/irq.h	2004-03-02 03:01:50.000000000 +0000
@@ -76,6 +76,11 @@ extern void (*disable_irq)(unsigned int)
 
 struct pt_regs;
 
+extern int sys_request_irq(unsigned int,
+	irqreturn_t (*)(int, void *, struct pt_regs *),
+	unsigned long, const char *, void *);
+extern void sys_free_irq(unsigned int, void *);
+
 /*
  * various flags for request_irq() - the Amiga now uses the standard
  * mechanism like all other architectures - SA_INTERRUPT and SA_SHIRQ
diff -purN linux-post-2.6.4rc1-20040301/include/asm-m68k/unistd.h linux-post-2.6.4rc1-20040302/include/asm-m68k/unistd.h
--- linux-post-2.6.4rc1-20040301/include/asm-m68k/unistd.h	2004-02-25 10:31:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-m68k/unistd.h	2004-03-02 03:01:50.000000000 +0000
@@ -376,10 +376,6 @@ asmlinkage int sys_pipe(unsigned long *f
 asmlinkage int sys_ptrace(long request, long pid, long addr, long data);
 asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int on);
 struct pt_regs;
-int sys_request_irq(unsigned int,
-			irqreturn_t (*)(int, void *, struct pt_regs *),
-			unsigned long, const char *, void *);
-void sys_free_irq(unsigned int, void *);
 struct sigaction;
 asmlinkage long sys_rt_sigaction(int sig,
 				const struct sigaction __user *act,
diff -purN linux-post-2.6.4rc1-20040301/include/asm-ppc64/vio.h linux-post-2.6.4rc1-20040302/include/asm-ppc64/vio.h
--- linux-post-2.6.4rc1-20040301/include/asm-ppc64/vio.h	2004-02-27 23:02:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-ppc64/vio.h	2004-03-01 16:04:24.000000000 +0000
@@ -94,8 +94,8 @@ static inline struct vio_driver *to_vio_
 struct vio_dev {
 	struct device_node *archdata;   /* Open Firmware node */
 	void *driver_data;              /* data private to the driver */
-	unsigned long unit_address;	
 	struct iommu_table *iommu_table;     /* vio_map_* uses this */
+	uint32_t unit_address;	
 	unsigned int irq;
 
 	struct device dev;
diff -purN linux-post-2.6.4rc1-20040301/include/asm-s390/ccwdev.h linux-post-2.6.4rc1-20040302/include/asm-s390/ccwdev.h
--- linux-post-2.6.4rc1-20040301/include/asm-s390/ccwdev.h	2004-01-19 06:35:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-s390/ccwdev.h	2004-03-02 03:01:23.000000000 +0000
@@ -118,6 +118,8 @@ extern int ccw_device_set_options(struct
 #define CCWDEV_REPORT_ALL	 	0x0002
 /* Try to perform path grouping. */
 #define CCWDEV_DO_PATHGROUP             0x0004
+/* Allow forced onlining of boxed devices. */
+#define CCWDEV_ALLOW_FORCE              0x0008
 
 /*
  * ccw_device_start()
diff -purN linux-post-2.6.4rc1-20040301/include/asm-s390/ccwgroup.h linux-post-2.6.4rc1-20040302/include/asm-s390/ccwgroup.h
--- linux-post-2.6.4rc1-20040301/include/asm-s390/ccwgroup.h	2004-02-26 11:21:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-s390/ccwgroup.h	2004-03-02 03:01:23.000000000 +0000
@@ -17,6 +17,7 @@ struct ccwgroup_device {
 };
 
 struct ccwgroup_driver {
+	struct module *owner;
 	char *name;
 	int max_slaves;
 	unsigned long driver_id;
diff -purN linux-post-2.6.4rc1-20040301/include/asm-s390/compat.h linux-post-2.6.4rc1-20040302/include/asm-s390/compat.h
--- linux-post-2.6.4rc1-20040301/include/asm-s390/compat.h	2003-06-27 16:04:37.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-s390/compat.h	2004-03-02 03:01:23.000000000 +0000
@@ -25,6 +25,7 @@ typedef u16		compat_ipc_pid_t;
 typedef s32		compat_daddr_t;
 typedef u32		compat_caddr_t;
 typedef __kernel_fsid_t	compat_fsid_t;
+typedef s32		compat_timer_t;
 
 typedef s32		compat_int_t;
 typedef s32		compat_long_t;
diff -purN linux-post-2.6.4rc1-20040301/include/asm-s390/sigp.h linux-post-2.6.4rc1-20040302/include/asm-s390/sigp.h
--- linux-post-2.6.4rc1-20040301/include/asm-s390/sigp.h	2003-04-14 19:11:59.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-s390/sigp.h	2004-03-02 03:01:23.000000000 +0000
@@ -121,7 +121,7 @@ signal_processor_p(unsigned long paramet
  * Signal processor with parameter and return status
  */
 extern __inline__ sigp_ccode
-signal_processor_ps(__u32 *statusptr, unsigned long parameter,
+signal_processor_ps(unsigned long *statusptr, unsigned long parameter,
 		    __u16 cpu_addr, sigp_order_code order_code)
 {
 	sigp_ccode ccode;
diff -purN linux-post-2.6.4rc1-20040301/include/asm-sparc64/thread_info.h linux-post-2.6.4rc1-20040302/include/asm-sparc64/thread_info.h
--- linux-post-2.6.4rc1-20040301/include/asm-sparc64/thread_info.h	2003-07-12 09:05:37.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-sparc64/thread_info.h	2004-02-29 05:08:39.000000000 +0000
@@ -142,13 +142,30 @@ register struct thread_info *current_thr
 
 /* thread information allocation */
 #if PAGE_SHIFT == 13
-#define alloc_thread_info(tsk)((struct thread_info *)__get_free_pages(GFP_KERNEL, 1))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),1)
+#define __THREAD_INFO_ORDER	1
 #else /* PAGE_SHIFT == 13 */
-#define alloc_thread_info(tsk)((struct thread_info *)__get_free_pages(GFP_KERNEL, 0))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),0)
+#define __THREAD_INFO_ORDER	0
 #endif /* PAGE_SHIFT == 13 */
 
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk)					\
+({								\
+	struct thread_info *ret;				\
+								\
+	ret = (struct thread_info *)				\
+	  __get_free_pages(GFP_KERNEL, __THREAD_INFO_ORDER);	\
+	if (ret)						\
+		memset(ret, 0, PAGE_SIZE<<__THREAD_INFO_ORDER);	\
+	ret;							\
+})
+#else
+#define alloc_thread_info(tsk) \
+	((struct thread_info *)__get_free_pages(GFP_KERNEL, __THREAD_INFO_ORDER))
+#endif
+
+#define free_thread_info(ti) \
+	free_pages((unsigned long)(ti),__THREAD_INFO_ORDER)
+
 #define __thread_flag_byte_ptr(ti)	\
 	((unsigned char *)(&((ti)->flags)))
 #define __cur_thread_flag_byte_ptr	__thread_flag_byte_ptr(current_thread_info())
diff -purN linux-post-2.6.4rc1-20040301/include/asm-x86_64/mmzone.h linux-post-2.6.4rc1-20040302/include/asm-x86_64/mmzone.h
--- linux-post-2.6.4rc1-20040301/include/asm-x86_64/mmzone.h	2003-10-05 08:07:40.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-x86_64/mmzone.h	2004-03-02 03:01:48.000000000 +0000
@@ -31,6 +31,8 @@ static inline __attribute__((pure)) int 
 	return nid; 
 } 
 
+#define pfn_to_nid(pfn) phys_to_nid((unsigned long)(pfn) << PAGE_SHIFT)
+
 #define kvaddr_to_nid(kaddr)	phys_to_nid(__pa(kaddr))
 #define NODE_DATA(nid)		(node_data[nid])
 
diff -purN linux-post-2.6.4rc1-20040301/include/asm-x86_64/processor.h linux-post-2.6.4rc1-20040302/include/asm-x86_64/processor.h
--- linux-post-2.6.4rc1-20040301/include/asm-x86_64/processor.h	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/asm-x86_64/processor.h	2004-03-02 03:01:48.000000000 +0000
@@ -173,7 +173,7 @@ static inline void clear_in_cr4 (unsigne
  * space during mmap's.
  */
 #define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
-#define TASK_UNMAPPED_32 (PAGE_ALIGN(IA32_PAGE_OFFSET / 3))
+#define TASK_UNMAPPED_32 (PAGE_ALIGN(0xc5000000))
 #define TASK_UNMAPPED_64 PAGE_ALIGN(TASK_SIZE/3) 
 #define TASK_UNMAPPED_BASE	\
 	(test_thread_flag(TIF_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
diff -purN linux-post-2.6.4rc1-20040301/include/linux/console.h linux-post-2.6.4rc1-20040302/include/linux/console.h
--- linux-post-2.6.4rc1-20040301/include/linux/console.h	2004-02-04 05:28:11.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/linux/console.h	2004-03-02 03:01:44.000000000 +0000
@@ -37,7 +37,7 @@ struct consw {
 	int	(*con_scroll)(struct vc_data *, int, int, int, int);
 	void	(*con_bmove)(struct vc_data *, int, int, int, int, int, int);
 	int	(*con_switch)(struct vc_data *);
-	int	(*con_blank)(struct vc_data *, int);
+	int	(*con_blank)(struct vc_data *, int, int);
 	int	(*con_font_op)(struct vc_data *, struct console_font_op *);
 	int	(*con_resize)(struct vc_data *, unsigned int, unsigned int);
 	int	(*con_set_palette)(struct vc_data *, unsigned char *);
diff -purN linux-post-2.6.4rc1-20040301/include/linux/fb.h linux-post-2.6.4rc1-20040302/include/linux/fb.h
--- linux-post-2.6.4rc1-20040301/include/linux/fb.h	2004-02-27 05:33:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/linux/fb.h	2004-03-02 03:01:44.000000000 +0000
@@ -152,6 +152,7 @@ struct fb_bitfield {
 #define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
 #define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
 #define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
 
 #define FB_ACCELF_TEXT		1	/* text mode acceleration */
 
diff -purN linux-post-2.6.4rc1-20040301/include/linux/netfilter_bridge.h linux-post-2.6.4rc1-20040302/include/linux/netfilter_bridge.h
--- linux-post-2.6.4rc1-20040301/include/linux/netfilter_bridge.h	2003-12-31 18:33:25.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/linux/netfilter_bridge.h	2004-03-01 05:52:42.000000000 +0000
@@ -88,6 +88,20 @@ void nf_bridge_save_header(struct sk_buf
 	memcpy(skb->nf_bridge->data, skb->data - header_size, header_size);
 }
 
+/* This is called by the IP fragmenting code and it ensures there is
+ * enough room for the encapsulating header (if there is one). */
+static inline
+int nf_bridge_pad(struct sk_buff *skb)
+{
+	if (skb->protocol == __constant_htons(ETH_P_IP))
+		return 0;
+	if (skb->nf_bridge) {
+		if (skb->protocol == __constant_htons(ETH_P_8021Q))
+			return 4;
+	}
+	return 0;
+}
+
 struct bridge_skb_cb {
 	union {
 		__u32 ipv4;
diff -purN linux-post-2.6.4rc1-20040301/include/linux/vt_kern.h linux-post-2.6.4rc1-20040302/include/linux/vt_kern.h
--- linux-post-2.6.4rc1-20040301/include/linux/vt_kern.h	2003-03-11 17:17:29.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/linux/vt_kern.h	2004-03-02 03:01:44.000000000 +0000
@@ -44,7 +44,8 @@ int vc_resize(int currcons, unsigned int
 void vc_disallocate(unsigned int console);
 void reset_palette(int currcons);
 void set_palette(int currcons);
-void do_blank_screen(int gfx_mode);
+void do_blank_screen(int entering_gfx);
+void do_unblank_screen(int leaving_gfx);
 void unblank_screen(void);
 void poke_blanked_console(void);
 int con_font_op(int currcons, struct console_font_op *op);
diff -purN linux-post-2.6.4rc1-20040301/include/scsi/scsi_cmnd.h linux-post-2.6.4rc1-20040302/include/scsi/scsi_cmnd.h
--- linux-post-2.6.4rc1-20040301/include/scsi/scsi_cmnd.h	2004-02-23 14:21:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/include/scsi/scsi_cmnd.h	2004-02-28 22:01:12.000000000 +0000
@@ -159,5 +159,6 @@ struct scsi_cmnd {
 extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, int);
 extern void scsi_put_command(struct scsi_cmnd *);
 extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+extern void scsi_finish_command(struct scsi_cmnd *cmd);
 
 #endif /* _SCSI_SCSI_CMND_H */
diff -purN linux-post-2.6.4rc1-20040301/init/Kconfig linux-post-2.6.4rc1-20040302/init/Kconfig
--- linux-post-2.6.4rc1-20040301/init/Kconfig	2004-02-17 00:58:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/init/Kconfig	2004-03-02 03:01:47.000000000 +0000
@@ -66,7 +66,7 @@ endmenu
 menu "General setup"
 
 config SWAP
-	bool "Support for paging of anonymous memory"
+	bool "Support for paging of anonymous memory (swap)"
 	depends on MMU
 	default y
 	help
diff -purN linux-post-2.6.4rc1-20040301/kernel/power/poweroff.c linux-post-2.6.4rc1-20040302/kernel/power/poweroff.c
--- linux-post-2.6.4rc1-20040301/kernel/power/poweroff.c	2003-08-06 20:59:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/kernel/power/poweroff.c	2004-03-02 03:01:25.000000000 +0000
@@ -8,33 +8,33 @@
 #include <linux/sysrq.h>
 #include <linux/init.h>
 #include <linux/pm.h>
+#include <linux/workqueue.h>
 
-
-/**
- * handle_poweroff	-	sysrq callback for power down
- * @key: key pressed (unused)
- * @pt_regs: register state (unused)
- * @kbd: keyboard state (unused)
- * @tty: tty involved (unused)
- *
+/*
  * When the user hits Sys-Rq o to power down the machine this is the
  * callback we use.
  */
 
-static void handle_poweroff (int key, struct pt_regs *pt_regs,
-			     struct tty_struct *tty)
+static void do_poweroff(void *dummy)
 {
 	if (pm_power_off)
 		pm_power_off();
 }
 
+static DECLARE_WORK(poweroff_work, do_poweroff, 0);
+
+static void handle_poweroff(int key, struct pt_regs *pt_regs,
+				struct tty_struct *tty)
+{
+	schedule_work(&poweroff_work);
+}
+
 static struct sysrq_key_op	sysrq_poweroff_op = {
 	.handler        = handle_poweroff,
 	.help_msg       = "powerOff",
 	.action_msg     = "Power Off\n"
 };
 
-
 static int pm_sysrq_init(void)
 {
 	register_sysrq_key('o', &sysrq_poweroff_op);
diff -purN linux-post-2.6.4rc1-20040301/kernel/power/swsusp.c linux-post-2.6.4rc1-20040302/kernel/power/swsusp.c
--- linux-post-2.6.4rc1-20040301/kernel/power/swsusp.c	2004-02-26 11:26:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/kernel/power/swsusp.c	2004-03-02 03:01:50.000000000 +0000
@@ -673,7 +673,11 @@ asmlinkage void do_magic_suspend_2(void)
 
 	free_pages((unsigned long) pagedir_nosave, pagedir_order);
 	spin_unlock_irq(&suspend_pagedir_lock);
+
+	device_resume();
+	PRINTK( "Fixing swap signatures... " );
 	mark_swapfiles(((swp_entry_t) {0}), MARK_SWAP_RESUME);
+	PRINTK( "ok\n" );
 }
 
 /*
diff -purN linux-post-2.6.4rc1-20040301/kernel/timer.c linux-post-2.6.4rc1-20040302/kernel/timer.c
--- linux-post-2.6.4rc1-20040301/kernel/timer.c	2004-01-19 06:33:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/kernel/timer.c	2004-03-02 03:01:45.000000000 +0000
@@ -868,7 +868,7 @@ asmlinkage unsigned long sys_alarm(unsig
 	oldalarm = it_old.it_value.tv_sec;
 	/* ehhh.. We can't return 0 if we have an alarm pending.. */
 	/* And we'd better return too much than too little anyway */
-	if (it_old.it_value.tv_usec)
+	if ((!oldalarm && it_old.it_value.tv_usec) || it_old.it_value.tv_usec >= 500000)
 		oldalarm++;
 	return oldalarm;
 }
diff -purN linux-post-2.6.4rc1-20040301/mm/highmem.c linux-post-2.6.4rc1-20040302/mm/highmem.c
--- linux-post-2.6.4rc1-20040301/mm/highmem.c	2003-12-29 21:37:53.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/mm/highmem.c	2004-03-02 03:01:25.000000000 +0000
@@ -294,7 +294,12 @@ static void copy_to_high_bio_irq(struct 
 		if (tovec->bv_page == fromvec->bv_page)
 			continue;
 
-		vfrom = page_address(fromvec->bv_page) + fromvec->bv_offset;
+		/*
+		 * fromvec->bv_offset and fromvec->bv_len might have been
+		 * modified by the block layer, so use the original copy,
+		 * bounce_copy_vec already uses tovec->bv_len
+		 */
+		vfrom = page_address(fromvec->bv_page) + tovec->bv_offset;
 
 		bounce_copy_vec(tovec, vfrom);
 	}
diff -purN linux-post-2.6.4rc1-20040301/mm/pdflush.c linux-post-2.6.4rc1-20040302/mm/pdflush.c
--- linux-post-2.6.4rc1-20040301/mm/pdflush.c	2003-03-11 06:34:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/mm/pdflush.c	2004-03-02 03:01:49.000000000 +0000
@@ -5,6 +5,9 @@
  *
  * 09Apr2002	akpm@zip.com.au
  *		Initial version
+ * 29Feb2004	kaos@sgi.com
+ *		Move worker thread creation to kthread to avoid chewing
+ *		up stack space with nested calls to kernel_thread.
  */
 
 #include <linux/sched.h>
@@ -17,6 +20,7 @@
 #include <linux/suspend.h>
 #include <linux/fs.h>		// Needed by writeback.h
 #include <linux/writeback.h>	// Prototypes pdflush_operation()
+#include <linux/kthread.h>
 
 
 /*
@@ -86,8 +90,6 @@ struct pdflush_work {
 
 static int __pdflush(struct pdflush_work *my_work)
 {
-	daemonize("pdflush");
-
 	current->flags |= PF_FLUSHER;
 	my_work->fn = NULL;
 	my_work->who = current;
@@ -207,7 +209,7 @@ int pdflush_operation(void (*fn)(unsigne
 
 static void start_one_pdflush_thread(void)
 {
-	kernel_thread(pdflush, NULL, CLONE_KERNEL);
+	kthread_run(pdflush, NULL, "pdflush");
 }
 
 static int __init pdflush_init(void)
diff -purN linux-post-2.6.4rc1-20040301/net/atm/lec.c linux-post-2.6.4rc1-20040302/net/atm/lec.c
--- linux-post-2.6.4rc1-20040301/net/atm/lec.c	2004-02-26 19:59:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/atm/lec.c	2004-02-28 23:54:09.000000000 +0000
@@ -793,7 +793,7 @@ lec_vcc_attach(struct atm_vcc *vcc, void
 		return -ENOMEM;
 	vpriv->xoff = 0;
 	vpriv->old_pop = vcc->pop;
-	LEC_VCC_PRIV(vcc) = vpriv;
+	vcc->user_back = vpriv;
 	vcc->pop = lec_pop;
         lec_vcc_added(dev_lec[ioc_data.dev_num]->priv, 
                       &ioc_data, vcc, vcc->push);
@@ -1420,7 +1420,7 @@ lec_arp_clear_vccs(struct lec_arp_table 
 		if (vpriv->xoff)
 			netif_wake_queue(dev);
 		kfree(vpriv);
-		LEC_VCC_PRIV(vcc) = NULL;
+		vcc->user_back = NULL;
                 vcc->push = entry->old_push;
 		vcc_release_async(vcc, -EPIPE);
                 vcc = NULL;
@@ -2374,7 +2374,7 @@ lec_mcast_make(struct lec_priv *priv, st
 		return -ENOMEM;
 	vpriv->xoff = 0;
 	vpriv->old_pop = vcc->pop;
-	LEC_VCC_PRIV(vcc) = vpriv;
+	vcc->user_back = vpriv;
         vcc->pop = lec_pop;
         lec_arp_get(priv);
         to_add = make_entry(priv, mac_addr);
diff -purN linux-post-2.6.4rc1-20040301/net/core/dev.c linux-post-2.6.4rc1-20040302/net/core/dev.c
--- linux-post-2.6.4rc1-20040301/net/core/dev.c	2004-02-26 19:58:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/core/dev.c	2004-02-29 00:05:49.000000000 +0000
@@ -2447,9 +2447,8 @@ static int dev_ifsioc(struct ifreq *ifr,
 				return -EINVAL;
 			if (!netif_device_present(dev))
 				return -ENODEV;
-			dev_mc_add(dev, ifr->ifr_hwaddr.sa_data,
-				   dev->addr_len, 1);
-			return 0;
+			return dev_mc_add(dev, ifr->ifr_hwaddr.sa_data,
+					  dev->addr_len, 1);
 
 		case SIOCDELMULTI:
 			if (!dev->set_multicast_list ||
@@ -2457,9 +2456,8 @@ static int dev_ifsioc(struct ifreq *ifr,
 				return -EINVAL;
 			if (!netif_device_present(dev))
 				return -ENODEV;
-			dev_mc_delete(dev, ifr->ifr_hwaddr.sa_data,
-				      dev->addr_len, 1);
-			return 0;
+			return dev_mc_delete(dev, ifr->ifr_hwaddr.sa_data,
+					     dev->addr_len, 1);
 
 		case SIOCGIFINDEX:
 			ifr->ifr_ifindex = dev->ifindex;
diff -purN linux-post-2.6.4rc1-20040301/net/ipv4/ip_output.c linux-post-2.6.4rc1-20040302/net/ipv4/ip_output.c
--- linux-post-2.6.4rc1-20040301/net/ipv4/ip_output.c	2004-02-03 18:24:11.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/ipv4/ip_output.c	2004-03-01 05:52:42.000000000 +0000
@@ -80,6 +80,7 @@
 #include <net/inetpeer.h>
 #include <linux/igmp.h>
 #include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_bridge.h>
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
@@ -442,7 +443,7 @@ int ip_fragment(struct sk_buff *skb, int
 	int ptr;
 	struct net_device *dev;
 	struct sk_buff *skb2;
-	unsigned int mtu, hlen, left, len; 
+	unsigned int mtu, hlen, left, len, ll_rs;
 	int offset;
 	int not_last_frag;
 	struct rtable *rt = (struct rtable*)skb->dst;
@@ -563,6 +564,14 @@ slow_path:
 	left = skb->len - hlen;		/* Space per frame */
 	ptr = raw + hlen;		/* Where to start from */
 
+#ifdef CONFIG_BRIDGE_NETFILTER
+	/* for bridged IP traffic encapsulated inside f.e. a vlan header,
+	 * we need to make room for the encapsulating header */
+	ll_rs = LL_RESERVED_SPACE(rt->u.dst.dev + nf_bridge_pad(skb));
+	mtu -= nf_bridge_pad(skb);
+#else
+	ll_rs = LL_RESERVED_SPACE(rt->u.dst.dev);
+#endif
 	/*
 	 *	Fragment the datagram.
 	 */
@@ -588,7 +597,7 @@ slow_path:
 		 *	Allocate buffer.
 		 */
 
-		if ((skb2 = alloc_skb(len+hlen+LL_RESERVED_SPACE(rt->u.dst.dev), GFP_ATOMIC)) == NULL) {
+		if ((skb2 = alloc_skb(len+hlen+ll_rs, GFP_ATOMIC)) == NULL) {
 			NETDEBUG(printk(KERN_INFO "IP: frag: no memory for new fragment!\n"));
 			err = -ENOMEM;
 			goto fail;
@@ -599,7 +608,7 @@ slow_path:
 		 */
 
 		ip_copy_metadata(skb2, skb);
-		skb_reserve(skb2, LL_RESERVED_SPACE(rt->u.dst.dev));
+		skb_reserve(skb2, ll_rs);
 		skb_put(skb2, len + hlen);
 		skb2->nh.raw = skb2->data;
 		skb2->h.raw = skb2->data + hlen;
diff -purN linux-post-2.6.4rc1-20040301/net/ipv4/ipvs/Makefile linux-post-2.6.4rc1-20040302/net/ipv4/ipvs/Makefile
--- linux-post-2.6.4rc1-20040301/net/ipv4/ipvs/Makefile	2003-07-13 07:23:09.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/ipv4/ipvs/Makefile	2004-03-02 03:01:46.000000000 +0000
@@ -1,12 +1,6 @@
 #
 # Makefile for the IPVS modules on top of IPv4.
 #
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (ie not a .c file).
-#
-# Note 2! The CFLAGS definition is now in the main makefile...
-
 
 # IPVS transport protocol load balancing support
 ip_vs_proto-objs-y :=
diff -purN linux-post-2.6.4rc1-20040301/net/ipv4/route.c linux-post-2.6.4rc1-20040302/net/ipv4/route.c
--- linux-post-2.6.4rc1-20040301/net/ipv4/route.c	2004-02-19 03:42:32.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/ipv4/route.c	2004-03-02 03:01:45.000000000 +0000
@@ -2753,9 +2753,7 @@ int __init ip_rt_init(void)
 		panic("IP: failed to allocate ip_dst_cache\n");
 
 	goal = num_physpages >> (26 - PAGE_SHIFT);
-	if (!rhash_entries)
-		goal = min(10, goal);
-	else
+	if (rhash_entries)
 		goal = (rhash_entries * sizeof(struct rt_hash_bucket)) >> PAGE_SHIFT;
 	for (order = 0; (1UL << order) < goal; order++)
 		/* NOTHING */;
diff -purN linux-post-2.6.4rc1-20040301/net/ipv4/tcp.c linux-post-2.6.4rc1-20040302/net/ipv4/tcp.c
--- linux-post-2.6.4rc1-20040301/net/ipv4/tcp.c	2004-02-19 03:42:32.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/ipv4/tcp.c	2004-03-02 03:01:45.000000000 +0000
@@ -2621,9 +2621,7 @@ void __init tcp_init(void)
 	else
 		goal = num_physpages >> (23 - PAGE_SHIFT);
 
-	if (!thash_entries)
-		goal = min(10UL, goal);
-	else
+	if (thash_entries)
 		goal = (thash_entries * sizeof(struct tcp_ehash_bucket)) >> PAGE_SHIFT;
 	for (order = 0; (1UL << order) < goal; order++)
 		;
diff -purN linux-post-2.6.4rc1-20040301/net/sunrpc/xprt.c linux-post-2.6.4rc1-20040302/net/sunrpc/xprt.c
--- linux-post-2.6.4rc1-20040301/net/sunrpc/xprt.c	2004-02-26 11:26:02.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/sunrpc/xprt.c	2004-03-02 03:01:43.000000000 +0000
@@ -1589,7 +1589,7 @@ xprt_create_socket(int proto, struct rpc
 
 	if ((err = sock_create(PF_INET, type, proto, &sock)) < 0) {
 		printk("RPC: can't create socket (%d).\n", -err);
-		goto failed;
+		return NULL;
 	}
 
 	/* If the caller has the capability, bind to a reserved port */
diff -purN linux-post-2.6.4rc1-20040301/net/unix/af_unix.c linux-post-2.6.4rc1-20040302/net/unix/af_unix.c
--- linux-post-2.6.4rc1-20040301/net/unix/af_unix.c	2004-02-08 21:03:10.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/net/unix/af_unix.c	2004-02-29 00:20:46.000000000 +0000
@@ -377,7 +377,7 @@ static int unix_release_sock (struct soc
 	skpair=unix_peer(sk);
 
 	if (skpair!=NULL) {
-		if (sk->sk_type == SOCK_STREAM) {
+		if (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {
 			unix_state_wlock(skpair);
 			/* No more writes */
 			skpair->sk_shutdown = SHUTDOWN_MASK;
@@ -435,8 +435,8 @@ static int unix_listen(struct socket *so
 	struct unix_sock *u = unix_sk(sk);
 
 	err = -EOPNOTSUPP;
-	if (sock->type!=SOCK_STREAM)
-		goto out;			/* Only stream sockets accept */
+	if (sock->type!=SOCK_STREAM && sock->type!=SOCK_SEQPACKET)
+		goto out;			/* Only stream/seqpacket sockets accept */
 	err = -EINVAL;
 	if (!u->addr)
 		goto out;			/* No listens on an unbound socket */
@@ -459,8 +459,89 @@ out:
 	return err;
 }
 
-extern struct proto_ops unix_stream_ops;
-extern struct proto_ops unix_dgram_ops;
+static int unix_release(struct socket *);
+static int unix_bind(struct socket *, struct sockaddr *, int);
+static int unix_stream_connect(struct socket *, struct sockaddr *,
+			       int addr_len, int flags);
+static int unix_socketpair(struct socket *, struct socket *);
+static int unix_accept(struct socket *, struct socket *, int);
+static int unix_getname(struct socket *, struct sockaddr *, int *, int);
+static unsigned int unix_poll(struct file *, struct socket *, poll_table *);
+static int unix_ioctl(struct socket *, unsigned int, unsigned long);
+static int unix_shutdown(struct socket *, int);
+static int unix_stream_sendmsg(struct kiocb *, struct socket *,
+			       struct msghdr *, size_t);
+static int unix_stream_recvmsg(struct kiocb *, struct socket *,
+			       struct msghdr *, size_t, int);
+static int unix_dgram_sendmsg(struct kiocb *, struct socket *,
+			      struct msghdr *, size_t);
+static int unix_dgram_recvmsg(struct kiocb *, struct socket *,
+			      struct msghdr *, size_t, int);
+static int unix_dgram_connect(struct socket *, struct sockaddr *,
+			      int, int);
+
+static struct proto_ops unix_stream_ops = {
+	.family =	PF_UNIX,
+	.owner =	THIS_MODULE,
+	.release =	unix_release,
+	.bind =		unix_bind,
+	.connect =	unix_stream_connect,
+	.socketpair =	unix_socketpair,
+	.accept =	unix_accept,
+	.getname =	unix_getname,
+	.poll =		unix_poll,
+	.ioctl =	unix_ioctl,
+	.listen =	unix_listen,
+	.shutdown =	unix_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	unix_stream_sendmsg,
+	.recvmsg =	unix_stream_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+};
+
+static struct proto_ops unix_dgram_ops = {
+	.family =	PF_UNIX,
+	.owner =	THIS_MODULE,
+	.release =	unix_release,
+	.bind =		unix_bind,
+	.connect =	unix_dgram_connect,
+	.socketpair =	unix_socketpair,
+	.accept =	sock_no_accept,
+	.getname =	unix_getname,
+	.poll =		datagram_poll,
+	.ioctl =	unix_ioctl,
+	.listen =	sock_no_listen,
+	.shutdown =	unix_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	unix_dgram_sendmsg,
+	.recvmsg =	unix_dgram_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+};
+
+static struct proto_ops unix_seqpacket_ops = {
+	.family =	PF_UNIX,
+	.owner =	THIS_MODULE,
+	.release =	unix_release,
+	.bind =		unix_bind,
+	.connect =	unix_stream_connect,
+	.socketpair =	unix_socketpair,
+	.accept =	unix_accept,
+	.getname =	unix_getname,
+	.poll =		datagram_poll,
+	.ioctl =	unix_ioctl,
+	.listen =	unix_listen,
+	.shutdown =	unix_shutdown,
+	.setsockopt =	sock_no_setsockopt,
+	.getsockopt =	sock_no_getsockopt,
+	.sendmsg =	unix_dgram_sendmsg,
+	.recvmsg =	unix_dgram_recvmsg,
+	.mmap =		sock_no_mmap,
+	.sendpage =	sock_no_sendpage,
+};
 
 static struct sock * unix_create1(struct socket *sock)
 {
@@ -515,6 +596,9 @@ static int unix_create(struct socket *so
 	case SOCK_DGRAM:
 		sock->ops = &unix_dgram_ops;
 		break;
+	case SOCK_SEQPACKET:
+		sock->ops = &unix_seqpacket_ops;
+		break;
 	default:
 		return -ESOCKTNOSUPPORT;
 	}
@@ -982,7 +1066,7 @@ restart:
 	sock_hold(sk);
 	unix_peer(newsk)	= sk;
 	newsk->sk_state		= TCP_ESTABLISHED;
-	newsk->sk_type		= SOCK_STREAM;
+	newsk->sk_type		= sk->sk_type;
 	newsk->sk_peercred.pid	= current->tgid;
 	newsk->sk_peercred.uid	= current->euid;
 	newsk->sk_peercred.gid	= current->egid;
@@ -1066,7 +1150,7 @@ static int unix_accept(struct socket *so
 	int err;
 
 	err = -EOPNOTSUPP;
-	if (sock->type!=SOCK_STREAM)
+	if (sock->type!=SOCK_STREAM && sock->type!=SOCK_SEQPACKET)
 		goto out;
 
 	err = -EINVAL;
@@ -1711,7 +1795,9 @@ static int unix_shutdown(struct socket *
 		unix_state_wunlock(sk);
 		sk->sk_state_change(sk);
 
-		if (other && sk->sk_type == SOCK_STREAM) {
+		if (other &&
+			(sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET)) {
+
 			int peer_mode = 0;
 
 			if (mode&RCV_SHUTDOWN)
@@ -1791,7 +1877,7 @@ static unsigned int unix_poll(struct fil
 		mask |= POLLIN | POLLRDNORM;
 
 	/* Connection-based need to check for termination and startup */
-	if (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE)
+	if ((sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) && sk->sk_state == TCP_CLOSE)
 		mask |= POLLHUP;
 
 	/*
@@ -1884,7 +1970,7 @@ static int unix_seq_show(struct seq_file
 	return 0;
 }
 
-struct seq_operations unix_seq_ops = {
+static struct seq_operations unix_seq_ops = {
 	.start  = unix_seq_start,
 	.next   = unix_seq_next,
 	.stop   = unix_seq_stop,
@@ -1925,49 +2011,7 @@ static struct file_operations unix_seq_f
 
 #endif
 
-struct proto_ops unix_stream_ops = {
-	.family =	PF_UNIX,
-	.owner =	THIS_MODULE,
-	.release =	unix_release,
-	.bind =		unix_bind,
-	.connect =	unix_stream_connect,
-	.socketpair =	unix_socketpair,
-	.accept =	unix_accept,
-	.getname =	unix_getname,
-	.poll =		unix_poll,
-	.ioctl =	unix_ioctl,
-	.listen =	unix_listen,
-	.shutdown =	unix_shutdown,
-	.setsockopt =	sock_no_setsockopt,
-	.getsockopt =	sock_no_getsockopt,
-	.sendmsg =	unix_stream_sendmsg,
-	.recvmsg =	unix_stream_recvmsg,
-	.mmap =		sock_no_mmap,
-	.sendpage =	sock_no_sendpage,
-};
-
-struct proto_ops unix_dgram_ops = {
-	.family =	PF_UNIX,
-	.owner =	THIS_MODULE,
-	.release =	unix_release,
-	.bind =		unix_bind,
-	.connect =	unix_dgram_connect,
-	.socketpair =	unix_socketpair,
-	.accept =	sock_no_accept,
-	.getname =	unix_getname,
-	.poll =		datagram_poll,
-	.ioctl =	unix_ioctl,
-	.listen =	sock_no_listen,
-	.shutdown =	unix_shutdown,
-	.setsockopt =	sock_no_setsockopt,
-	.getsockopt =	sock_no_getsockopt,
-	.sendmsg =	unix_dgram_sendmsg,
-	.recvmsg =	unix_dgram_recvmsg,
-	.mmap =		sock_no_mmap,
-	.sendpage =	sock_no_sendpage,
-};
-
-struct net_proto_family unix_family_ops = {
+static struct net_proto_family unix_family_ops = {
 	.family = PF_UNIX,
 	.create = unix_create,
 	.owner	= THIS_MODULE,
diff -purN linux-post-2.6.4rc1-20040301/scripts/modpost.h linux-post-2.6.4rc1-20040302/scripts/modpost.h
--- linux-post-2.6.4rc1-20040301/scripts/modpost.h	2004-02-27 05:33:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040302/scripts/modpost.h	2004-03-02 03:01:51.000000000 +0000
@@ -31,7 +31,7 @@
 
 #if KERNEL_ELFDATA != HOST_ELFDATA
 
-static void __endian(const void *src, void *dest, unsigned int size)
+static inline void __endian(const void *src, void *dest, unsigned int size)
 {
 	unsigned int i;
 	for (i = 0; i < size; i++)

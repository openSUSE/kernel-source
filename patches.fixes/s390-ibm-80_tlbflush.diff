diffstat:
 mm/fremap.c |   20 +++++++-------------
 mm/memory.c |    6 ++++++
 mm/msync.c  |    4 ++++
 3 files changed, 17 insertions(+), 13 deletions(-)

diff -urN linux-2.6/mm/fremap.c linux-2.6-s390/mm/fremap.c
--- linux-2.6/mm/fremap.c	Sat Oct 25 20:42:47 2003
+++ linux-2.6-s390/mm/fremap.c	Thu Nov 13 15:35:29 2003
@@ -19,18 +19,18 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
-static inline int zap_pte(struct mm_struct *mm, struct vm_area_struct *vma,
+static inline void zap_pte(struct mm_struct *mm, struct vm_area_struct *vma,
 			unsigned long addr, pte_t *ptep)
 {
 	pte_t pte = *ptep;
 
 	if (pte_none(pte))
-		return 0;
+		return;
 	if (pte_present(pte)) {
 		unsigned long pfn = pte_pfn(pte);
 
 		flush_cache_page(vma, addr);
-		pte = ptep_get_and_clear(ptep);
+		pte = ptep_clear_flush(vma, addr, ptep);
 		if (pfn_valid(pfn)) {
 			struct page *page = pfn_to_page(pfn);
 			if (!PageReserved(page)) {
@@ -41,12 +41,10 @@
 				mm->rss--;
 			}
 		}
-		return 1;
 	} else {
 		if (!pte_file(pte))
 			free_swap_and_cache(pte_to_swp_entry(pte));
 		pte_clear(ptep);
-		return 0;
 	}
 }
 
@@ -57,7 +55,7 @@
 int install_page(struct mm_struct *mm, struct vm_area_struct *vma,
 		unsigned long addr, struct page *page, pgprot_t prot)
 {
-	int err = -ENOMEM, flush;
+	int err = -ENOMEM;
 	pte_t *pte;
 	pgd_t *pgd;
 	pmd_t *pmd;
@@ -78,7 +76,7 @@
 	if (!pte)
 		goto err_unlock;
 
-	flush = zap_pte(mm, vma, addr, pte);
+	zap_pte(mm, vma, addr, pte);
 
 	mm->rss++;
 	flush_icache_page(vma, page);
@@ -86,8 +84,6 @@
 	pte_chain = page_add_rmap(page, pte, pte_chain);
 	pte_val = *pte;
 	pte_unmap(pte);
-	if (flush)
-		flush_tlb_page(vma, addr);
 	update_mmu_cache(vma, addr, pte_val);
 	spin_unlock(&mm->page_table_lock);
 	pte_chain_free(pte_chain);
@@ -109,7 +105,7 @@
 int install_file_pte(struct mm_struct *mm, struct vm_area_struct *vma,
 		unsigned long addr, unsigned long pgoff, pgprot_t prot)
 {
-	int err = -ENOMEM, flush;
+	int err = -ENOMEM;
 	pte_t *pte;
 	pgd_t *pgd;
 	pmd_t *pmd;
@@ -126,13 +122,11 @@
 	if (!pte)
 		goto err_unlock;
 
-	flush = zap_pte(mm, vma, addr, pte);
+	zap_pte(mm, vma, addr, pte);
 
 	set_pte(pte, pgoff_to_pte(pgoff));
 	pte_val = *pte;
 	pte_unmap(pte);
-	if (flush)
-		flush_tlb_page(vma, addr);
 	update_mmu_cache(vma, addr, pte_val);
 	spin_unlock(&mm->page_table_lock);
 	return 0;
diff -urN linux-2.6/mm/memory.c linux-2.6-s390/mm/memory.c
--- linux-2.6/mm/memory.c	Thu Nov 13 15:35:27 2003
+++ linux-2.6-s390/mm/memory.c	Thu Nov 13 15:35:29 2003
@@ -868,6 +868,9 @@
 		address = (address + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (address && (address < end));
+	/*
+	 * Why flush? zeromap_pte_range has a BUG_ON for !pte_none()
+	 */
 	flush_tlb_range(vma, beg, end);
 	spin_unlock(&mm->page_table_lock);
 	return error;
@@ -949,6 +952,9 @@
 		from = (from + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (from && (from < end));
+	/*
+	 * Why flush? remap_pte_range has a BUG_ON for !pte_none()
+	 */
 	flush_tlb_range(vma, beg, end);
 	spin_unlock(&mm->page_table_lock);
 	return error;
diff -urN linux-2.6/mm/msync.c linux-2.6-s390/mm/msync.c
--- linux-2.6/mm/msync.c	Sat Oct 25 20:43:26 2003
+++ linux-2.6-s390/mm/msync.c	Thu Nov 13 15:35:29 2003
@@ -115,6 +115,10 @@
 		address = (address + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (address && (address < end));
+	/*
+	 * Why flush ? filemap_sync_pte already flushed the tlbs with the
+	 * dirty bits.
+	 */
 	flush_tlb_range(vma, end - size, end);
 
 	spin_unlock(&vma->vm_mm->page_table_lock);

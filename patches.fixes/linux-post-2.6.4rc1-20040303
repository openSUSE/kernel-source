diff -purN linux-post-2.6.4rc1-20040302/arch/alpha/kernel/semaphore.c linux-post-2.6.4rc1-20040303/arch/alpha/kernel/semaphore.c
--- linux-post-2.6.4rc1-20040302/arch/alpha/kernel/semaphore.c	2003-04-03 22:49:57.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/alpha/kernel/semaphore.c	2004-03-01 23:12:29.000000000 +0000
@@ -9,31 +9,39 @@
 #include <linux/sched.h>
 
 /*
- * Semaphores are implemented using a two-way counter:
- * 
- * The "count" variable is decremented for each process that tries to sleep,
- * while the "waking" variable is incremented when the "up()" code goes to
- * wake up waiting processes.
- *
- * Notably, the inline "up()" and "down()" functions can efficiently test
- * if they need to do any extra work (up needs to do something only if count
- * was negative before the increment operation.
- *
- * waking_non_zero() (from asm/semaphore.h) must execute atomically.
- *
- * When __up() is called, the count was negative before incrementing it,
- * and we need to wake up somebody.
- *
- * This routine adds one to the count of processes that need to wake up and
- * exit.  ALL waiting processes actually wake up but only the one that gets
- * to the "waking" field first will gate through and acquire the semaphore.
- * The others will go back to sleep.
+ * This is basically the PPC semaphore scheme ported to use
+ * the Alpha ll/sc sequences, so see the PPC code for
+ * credits.
+ */
+
+/*
+ * Atomically update sem->count.
+ * This does the equivalent of the following:
  *
- * Note that these functions are only called when there is contention on the
- * lock, and as such all this is the "non-critical" part of the whole
- * semaphore business. The critical part is the inline stuff in
- * <asm/semaphore.h> where we want to avoid any extra jumps and calls.
+ *	old_count = sem->count;
+ *	tmp = MAX(old_count, 0) + incr;
+ *	sem->count = tmp;
+ *	return old_count;
  */
+static inline int __sem_update_count(struct semaphore *sem, int incr)
+{
+	long old_count, tmp = 0;
+
+	__asm__ __volatile__(
+	"1:	ldl_l	%0,%2\n"
+	"	cmovgt	%0,%0,%1\n"
+	"	addl	%1,%3,%1\n"
+	"	stl_c	%1,%2\n"
+	"	beq	%1,2f\n"
+	"	mb\n"
+	".subsection 2\n"
+	"2:	br	1b\n"
+	".previous"
+	: "=&r" (old_count), "=&r" (tmp), "=m" (sem->count)
+	: "Ir" (incr), "1" (tmp), "m" (sem->count));
+
+	return old_count;
+}
 
 /*
  * Perform the "down" function.  Return zero for semaphore acquired,
@@ -55,134 +63,77 @@
 void
 __down_failed(struct semaphore *sem)
 {
-	DECLARE_WAITQUEUE(wait, current);
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
 	printk("%s(%d): down failed(%p)\n",
-	       current->comm, current->pid, sem);
+	       tsk->comm, tsk->pid, sem);
 #endif
 
-	current->state = TASK_UNINTERRUPTIBLE;
+	tsk->state = TASK_UNINTERRUPTIBLE;
 	wmb();
 	add_wait_queue_exclusive(&sem->wait, &wait);
 
-	/* At this point we know that sem->count is negative.  In order
-	   to avoid racing with __up, we must check for wakeup before
-	   going to sleep the first time.  */
-
-	while (1) {
-		long ret, tmp;
-
-		/* An atomic conditional decrement of sem->waking.  */
-		__asm__ __volatile__(
-			"1:	ldl_l	%1,%2\n"
-			"	blt	%1,2f\n"
-			"	subl	%1,1,%0\n"
-			"	stl_c	%0,%2\n"
-			"	beq	%0,3f\n"
-			"2:\n"
-			".subsection 2\n"
-			"3:	br	1b\n"
-			".previous"
-			: "=r"(ret), "=&r"(tmp), "=m"(sem->waking)
-			: "0"(0));
-
-		if (ret)
-			break;
-
+	/*
+	 * Try to get the semaphore.  If the count is > 0, then we've
+	 * got the semaphore; we decrement count and exit the loop.
+	 * If the count is 0 or negative, we set it to -1, indicating
+	 * that we are asleep, and then sleep.
+	 */
+	while (__sem_update_count(sem, -1) <= 0) {
 		schedule();
-		set_task_state(current, TASK_UNINTERRUPTIBLE);
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	}
-
 	remove_wait_queue(&sem->wait, &wait);
-	current->state = TASK_RUNNING;
+	tsk->state = TASK_RUNNING;
+
+	/*
+	 * If there are any more sleepers, wake one of them up so
+	 * that it can either get the semaphore, or set count to -1
+	 * indicating that there are still processes sleeping.
+	 */
+	wake_up(&sem->wait);
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
 	printk("%s(%d): down acquired(%p)\n",
-	       current->comm, current->pid, sem);
+	       tsk->comm, tsk->pid, sem);
 #endif
 }
 
 int
 __down_failed_interruptible(struct semaphore *sem)
 {
-	DECLARE_WAITQUEUE(wait, current);
-	long ret;
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	long ret = 0;
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
 	printk("%s(%d): down failed(%p)\n",
-	       current->comm, current->pid, sem);
+	       tsk->comm, tsk->pid, sem);
 #endif
 
-	current->state = TASK_INTERRUPTIBLE;
+	tsk->state = TASK_INTERRUPTIBLE;
 	wmb();
 	add_wait_queue_exclusive(&sem->wait, &wait);
 
-	while (1) {
-		long tmp, tmp2, tmp3;
-
-		/* We must undo the sem->count down_interruptible decrement
-		   simultaneously and atomically with the sem->waking
-		   adjustment, otherwise we can race with __up.  This is
-		   accomplished by doing a 64-bit ll/sc on two 32-bit words.
-		
-		   "Equivalent" C.  Note that we have to do this all without
-		   (taken) branches in order to be a valid ll/sc sequence.
-
-		   do {
-		       tmp = ldq_l;
-		       ret = 0;
-		       if (tmp >= 0) {			// waking >= 0
-		           tmp += 0xffffffff00000000;	// waking -= 1
-		           ret = 1;
-		       }
-		       else if (pending) {
-			   // count += 1, but since -1 + 1 carries into the
-			   // high word, we have to be more careful here.
-			   tmp = (tmp & 0xffffffff00000000)
-				 | ((tmp + 1) & 0x00000000ffffffff);
-		           ret = -EINTR;
-		       }
-		       tmp = stq_c = tmp;
-		   } while (tmp == 0);
-		*/
-
-		__asm__ __volatile__(
-			"1:	ldq_l	%1,%4\n"
-			"	lda	%0,0\n"
-			"	cmovne	%5,%6,%0\n"
-			"	addq	%1,1,%2\n"
-			"	and	%1,%7,%3\n"
-			"	andnot	%2,%7,%2\n"
-			"	cmovge	%1,1,%0\n"
-			"	or	%3,%2,%2\n"
-			"	addq	%1,%7,%3\n"
-			"	cmovne	%5,%2,%1\n"
-			"	cmovge	%2,%3,%1\n"
-			"	stq_c	%1,%4\n"
-			"	beq	%1,3f\n"
-			"2:\n"
-			".subsection 2\n"
-			"3:	br	1b\n"
-			".previous"
-			: "=&r"(ret), "=&r"(tmp), "=&r"(tmp2),
-			  "=&r"(tmp3), "=m"(*sem)
-			: "r"(signal_pending(current)), "r"(-EINTR),
-			  "r"(0xffffffff00000000));
-
-		/* At this point we have ret
-		  	1	got the lock
-		  	0	go to sleep
-		  	-EINTR	interrupted  */
-		if (ret != 0)
+	while (__sem_update_count(sem, -1) <= 0) {
+		if (signal_pending(current)) {
+			/*
+			 * A signal is pending - give up trying.
+			 * Set sem->count to 0 if it is negative,
+			 * since we are no longer sleeping.
+			 */
+			__sem_update_count(sem, 0);
+			ret = -EINTR;
 			break;
-
+		}
 		schedule();
-		set_task_state(current, TASK_INTERRUPTIBLE);
+		set_task_state(tsk, TASK_INTERRUPTIBLE);
 	}
 
 	remove_wait_queue(&sem->wait, &wait);
-	current->state = TASK_RUNNING;
+	tsk->state = TASK_RUNNING;
 	wake_up(&sem->wait);
 
 #ifdef CONFIG_DEBUG_SEMAPHORE
@@ -190,14 +141,21 @@ __down_failed_interruptible(struct semap
 	       current->comm, current->pid,
 	       (ret < 0 ? "interrupted" : "acquired"), sem);
 #endif
-
-	/* Convert "got the lock" to 0==success.  */
-	return (ret < 0 ? ret : 0);
+	return ret;
 }
 
 void
 __up_wakeup(struct semaphore *sem)
 {
+	/*
+	 * Note that we incremented count in up() before we came here,
+	 * but that was ineffective since the result was <= 0, and
+	 * any negative value of count is equivalent to 0.
+	 * This ends up setting count to 1, unless count is now > 0
+	 * (i.e. because some other cpu has called up() in the meantime),
+	 * in which case we just increment count.
+	 */
+	__sem_update_count(sem, 1);
 	wake_up(&sem->wait);
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/arm/kernel/time.c linux-post-2.6.4rc1-20040303/arch/arm/kernel/time.c
--- linux-post-2.6.4rc1-20040302/arch/arm/kernel/time.c	2004-02-19 03:43:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/arm/kernel/time.c	2004-02-13 06:11:27.000000000 +0000
@@ -178,7 +178,7 @@ static int __init leds_init(void)
 	int ret;
 	ret = sysdev_class_register(&leds_sysclass);
 	if (ret == 0)
-		ret = sys_device_register(&leds_device);
+		ret = sysdev_register(&leds_device);
 	return ret;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/arm/mach-integrator/integrator_ap.c linux-post-2.6.4rc1-20040303/arch/arm/mach-integrator/integrator_ap.c
--- linux-post-2.6.4rc1-20040302/arch/arm/mach-integrator/integrator_ap.c	2004-02-06 14:39:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/arm/mach-integrator/integrator_ap.c	2004-02-13 06:12:19.000000000 +0000
@@ -173,7 +173,7 @@ static int __init irq_init_sysfs(void)
 {
 	int ret = sysdev_class_register(&irq_class);
 	if (ret == 0)
-		ret = sys_device_register(&irq_device);
+		ret = sysdev_register(&irq_device);
 	return ret;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/arm/mach-sa1100/irq.c linux-post-2.6.4rc1-20040303/arch/arm/mach-sa1100/irq.c
--- linux-post-2.6.4rc1-20040302/arch/arm/mach-sa1100/irq.c	2003-06-18 23:17:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/arm/mach-sa1100/irq.c	2004-02-13 06:11:49.000000000 +0000
@@ -278,7 +278,7 @@ static struct sys_device sa1100irq_devic
 static int __init sa1100irq_init_devicefs(void)
 {
 	sysdev_class_register(&sa1100irq_sysclass);
-	return sys_device_register(&sa1100irq_device);
+	return sysdev_register(&sa1100irq_device);
 }
 
 device_initcall(sa1100irq_init_devicefs);
diff -purN linux-post-2.6.4rc1-20040302/arch/i386/kernel/apic.c linux-post-2.6.4rc1-20040303/arch/i386/kernel/apic.c
--- linux-post-2.6.4rc1-20040302/arch/i386/kernel/apic.c	2004-01-22 14:05:26.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/i386/kernel/apic.c	2004-03-03 03:06:19.000000000 +0000
@@ -248,12 +248,6 @@ int __init verify_local_APIC(void)
 	 */
 	reg0 = apic_read(APIC_ID);
 	Dprintk("Getting ID: %x\n", reg0);
-	apic_write(APIC_ID, reg0 ^ APIC_ID_MASK);
-	reg1 = apic_read(APIC_ID);
-	Dprintk("Getting ID: %x\n", reg1);
-	apic_write(APIC_ID, reg0);
-	if (reg1 != (reg0 ^ APIC_ID_MASK))
-		return 0;
 
 	/*
 	 * The next two are just to see if we have sane values.
@@ -595,7 +589,7 @@ static int __init init_lapic_sysfs(void)
 
 	error = sysdev_class_register(&lapic_sysclass);
 	if (!error)
-		error = sys_device_register(&device_lapic);
+		error = sysdev_register(&device_lapic);
 	return error;
 }
 device_initcall(init_lapic_sysfs);
diff -purN linux-post-2.6.4rc1-20040302/arch/i386/kernel/i8259.c linux-post-2.6.4rc1-20040303/arch/i386/kernel/i8259.c
--- linux-post-2.6.4rc1-20040302/arch/i386/kernel/i8259.c	2003-12-29 21:37:23.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/i386/kernel/i8259.c	2004-02-13 06:09:06.000000000 +0000
@@ -258,7 +258,7 @@ static int __init i8259A_init_sysfs(void
 {
 	int error = sysdev_class_register(&i8259_sysdev_class);
 	if (!error)
-		error = sys_device_register(&device_i8259A);
+		error = sysdev_register(&device_i8259A);
 	return error;
 }
 
@@ -401,7 +401,7 @@ static int __init init_timer_sysfs(void)
 {
 	int error = sysdev_class_register(&timer_sysclass);
 	if (!error)
-		error = sys_device_register(&device_timer);
+		error = sysdev_register(&device_timer);
 	return error;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/i386/kernel/nmi.c linux-post-2.6.4rc1-20040303/arch/i386/kernel/nmi.c
--- linux-post-2.6.4rc1-20040302/arch/i386/kernel/nmi.c	2004-02-19 03:43:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/i386/kernel/nmi.c	2004-02-13 06:08:43.000000000 +0000
@@ -248,7 +248,7 @@ static int __init init_lapic_nmi_sysfs(v
 
 	error = sysdev_class_register(&nmi_sysclass);
 	if (!error)
-		error = sys_device_register(&device_lapic_nmi);
+		error = sysdev_register(&device_lapic_nmi);
 	return error;
 }
 /* must come after the local APIC's device_initcall() */
diff -purN linux-post-2.6.4rc1-20040302/arch/i386/kernel/time.c linux-post-2.6.4rc1-20040303/arch/i386/kernel/time.c
--- linux-post-2.6.4rc1-20040302/arch/i386/kernel/time.c	2004-01-19 23:38:08.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/i386/kernel/time.c	2004-02-13 06:08:24.000000000 +0000
@@ -346,7 +346,7 @@ static int time_init_device(void)
 {
 	int error = sysdev_class_register(&pit_sysclass);
 	if (!error)
-		error = sys_device_register(&device_i8253);
+		error = sysdev_register(&device_i8253);
 	return error;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/i386/oprofile/nmi_int.c linux-post-2.6.4rc1-20040303/arch/i386/oprofile/nmi_int.c
--- linux-post-2.6.4rc1-20040302/arch/i386/oprofile/nmi_int.c	2004-03-02 03:01:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/i386/oprofile/nmi_int.c	2004-03-03 03:06:19.000000000 +0000
@@ -65,14 +65,14 @@ static int __init init_driverfs(void)
 {
 	int error;
 	if (!(error = sysdev_class_register(&oprofile_sysclass)))
-		error = sys_device_register(&device_oprofile);
+		error = sysdev_register(&device_oprofile);
 	return error;
 }
 
 
 static void __exit exit_driverfs(void)
 {
-	sys_device_unregister(&device_oprofile);
+	sysdev_unregister(&device_oprofile);
 	sysdev_class_unregister(&oprofile_sysclass);
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/mips/kernel/i8259.c linux-post-2.6.4rc1-20040303/arch/mips/kernel/i8259.c
--- linux-post-2.6.4rc1-20040302/arch/mips/kernel/i8259.c	2004-02-19 20:53:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/mips/kernel/i8259.c	2004-02-26 23:55:11.000000000 +0000
@@ -242,7 +242,7 @@ static int __init i8259A_init_sysfs(void
 {
 	int error = sysdev_class_register(&i8259_sysdev_class);
 	if (!error)
-		error = sys_device_register(&device_i8259A);
+		error = sysdev_register(&device_i8259A);
 	return error;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/ppc/platforms/pmac_pic.c linux-post-2.6.4rc1-20040303/arch/ppc/platforms/pmac_pic.c
--- linux-post-2.6.4rc1-20040302/arch/ppc/platforms/pmac_pic.c	2004-02-05 05:34:19.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/ppc/platforms/pmac_pic.c	2004-02-13 06:10:36.000000000 +0000
@@ -646,7 +646,7 @@ static int __init init_pmacpic_sysfs(voi
 
 	printk(KERN_DEBUG "Registering pmac pic with sysfs...\n");
 	sysdev_class_register(&pmacpic_sysclass);
-	sys_device_register(&device_pmacpic);
+	sysdev_register(&device_pmacpic);
 	sysdev_driver_register(&pmacpic_sysclass, &driver_pmacpic);
 	return 0;
 }
diff -purN linux-post-2.6.4rc1-20040302/arch/ppc/syslib/open_pic.c linux-post-2.6.4rc1-20040303/arch/ppc/syslib/open_pic.c
--- linux-post-2.6.4rc1-20040302/arch/ppc/syslib/open_pic.c	2004-02-05 05:34:19.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/ppc/syslib/open_pic.c	2004-02-13 06:10:12.000000000 +0000
@@ -1032,7 +1032,7 @@ static int __init init_openpic_sysfs(voi
 		printk(KERN_ERR "Failed registering openpic sys class\n");
 		return -ENODEV;
 	}
-	rc = sys_device_register(&device_openpic);
+	rc = sysdev_register(&device_openpic);
 	if (rc) {
 		printk(KERN_ERR "Failed registering openpic sys device\n");
 		return -ENODEV;
diff -purN linux-post-2.6.4rc1-20040302/arch/ppc/syslib/open_pic2.c linux-post-2.6.4rc1-20040303/arch/ppc/syslib/open_pic2.c
--- linux-post-2.6.4rc1-20040302/arch/ppc/syslib/open_pic2.c	2004-02-05 05:34:19.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/ppc/syslib/open_pic2.c	2004-02-13 06:10:06.000000000 +0000
@@ -699,7 +699,7 @@ static int __init init_openpic2_sysfs(vo
 		printk(KERN_ERR "Failed registering openpic sys class\n");
 		return -ENODEV;
 	}
-	rc = sys_device_register(&device_openpic2);
+	rc = sysdev_register(&device_openpic2);
 	if (rc) {
 		printk(KERN_ERR "Failed registering openpic sys device\n");
 		return -ENODEV;
diff -purN linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/apic.c linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/apic.c
--- linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/apic.c	2004-02-25 16:06:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/apic.c	2004-02-26 23:55:11.000000000 +0000
@@ -553,7 +553,7 @@ static int __init init_lapic_sysfs(void)
 	/* XXX: remove suspend/resume procs if !apic_pm_state.active? */
 	error = sysdev_class_register(&lapic_sysclass);
 	if (!error)
-		error = sys_device_register(&device_lapic);
+		error = sysdev_register(&device_lapic);
 	return error;
 }
 device_initcall(init_lapic_sysfs);
diff -purN linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/i8259.c linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/i8259.c
--- linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/i8259.c	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/i8259.c	2004-03-03 03:06:19.000000000 +0000
@@ -430,7 +430,7 @@ static int __init init_timer_sysfs(void)
 {
 	int error = sysdev_class_register(&timer_sysclass);
 	if (!error)
-		error = sys_device_register(&device_timer);
+		error = sysdev_register(&device_timer);
 	return error;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/mce.c linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/mce.c
--- linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/mce.c	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/mce.c	2004-03-03 03:06:19.000000000 +0000
@@ -450,7 +450,7 @@ static __init int mce_init_device(void)
 		return -EIO;
 	err = sysdev_class_register(&mce_sysclass);
 	if (!err)
-		err = sys_device_register(&device_mce);
+		err = sysdev_register(&device_mce);
 	if (!err) { 
 		/* could create per CPU objects, but is not worth it. */
 		sysdev_create_file(&device_mce, &attr_disabled_banks); 
diff -purN linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/nmi.c linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/nmi.c
--- linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/nmi.c	2004-02-25 17:16:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/nmi.c	2004-02-26 23:55:11.000000000 +0000
@@ -241,7 +241,7 @@ static int __init init_lapic_nmi_sysfs(v
 
 	error = sysdev_class_register(&nmi_sysclass);
 	if (!error)
-		error = sys_device_register(&device_lapic_nmi);
+		error = sysdev_register(&device_lapic_nmi);
 	return error;
 }
 /* must come after the local APIC's device_initcall() */
diff -purN linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/time.c linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/time.c
--- linux-post-2.6.4rc1-20040302/arch/x86_64/kernel/time.c	2004-03-02 03:01:48.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/arch/x86_64/kernel/time.c	2004-03-03 03:06:19.000000000 +0000
@@ -804,7 +804,7 @@ static int time_init_device(void)
 {
 	int error = sysdev_class_register(&pit_sysclass);
 	if (!error)
-		error = sys_device_register(&device_i8253);
+		error = sysdev_register(&device_i8253);
 	return error;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/Kconfig linux-post-2.6.4rc1-20040303/drivers/Kconfig
--- linux-post-2.6.4rc1-20040302/drivers/Kconfig	2004-02-05 06:12:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/Kconfig	2004-02-25 21:24:20.000000000 +0000
@@ -42,7 +42,7 @@ source "drivers/char/Kconfig"
 
 source "drivers/i2c/Kconfig"
 
-# source "drivers/misc/Kconfig"
+source "drivers/misc/Kconfig"
 
 source "drivers/media/Kconfig"
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/Kconfig linux-post-2.6.4rc1-20040303/drivers/base/Kconfig
--- linux-post-2.6.4rc1-20040302/drivers/base/Kconfig	2003-08-15 01:17:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/Kconfig	2004-03-03 00:39:28.000000000 +0000
@@ -8,4 +8,15 @@ config FW_LOADER
 	  require hotplug firmware loading support, but a module built outside
 	  the kernel tree does.
 
+config DEBUG_DRIVER
+        bool "Driver Core verbose debug messages"
+        depends on DEBUG_KERNEL
+        help
+          Say Y here if you want the Driver core to produce a bunch of
+          debug messages to the system log. Select this if you are having a
+          problem with the driver core and want to see more of what is
+          going on.
+
+          If you are unsure about this, say N here.
+
 endmenu
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/bus.c linux-post-2.6.4rc1-20040303/drivers/base/bus.c
--- linux-post-2.6.4rc1-20040302/drivers/base/bus.c	2004-02-12 21:00:30.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/bus.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,7 +8,10 @@
  *
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/class.c linux-post-2.6.4rc1-20040303/drivers/base/class.c
--- linux-post-2.6.4rc1-20040302/drivers/base/class.c	2004-02-09 14:00:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/class.c	2004-03-03 00:39:28.000000000 +0000
@@ -10,7 +10,10 @@
  *
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/class_simple.c linux-post-2.6.4rc1-20040303/drivers/base/class_simple.c
--- linux-post-2.6.4rc1-20040302/drivers/base/class_simple.c	2004-02-09 14:00:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/class_simple.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,7 +8,10 @@
  *
  */
 
-#define DEBUG 1
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <linux/kdev_t.h>
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/core.c linux-post-2.6.4rc1-20040303/drivers/base/core.c
--- linux-post-2.6.4rc1-20040302/drivers/base/core.c	2004-02-09 23:40:25.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/core.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,7 +8,10 @@
  *
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <linux/err.h>
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/cpu.c linux-post-2.6.4rc1-20040303/drivers/base/cpu.c
--- linux-post-2.6.4rc1-20040302/drivers/base/cpu.c	2003-10-22 05:10:11.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/cpu.c	2004-02-13 06:35:35.000000000 +0000
@@ -29,7 +29,7 @@ int __init register_cpu(struct cpu *cpu,
 	cpu->sysdev.id = num;
 	cpu->sysdev.cls = &cpu_sysdev_class;
 
-	error = sys_device_register(&cpu->sysdev);
+	error = sysdev_register(&cpu->sysdev);
 	if (!error && root)
 		error = sysfs_create_link(&root->sysdev.kobj,
 					  &cpu->sysdev.kobj,
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/driver.c linux-post-2.6.4rc1-20040303/drivers/base/driver.c
--- linux-post-2.6.4rc1-20040302/drivers/base/driver.c	2003-06-03 23:19:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/driver.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,7 +8,10 @@
  *
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/init.c linux-post-2.6.4rc1-20040303/drivers/base/init.c
--- linux-post-2.6.4rc1-20040302/drivers/base/init.c	2003-06-03 23:19:52.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/init.c	2004-03-01 22:55:55.000000000 +0000
@@ -15,7 +15,7 @@ extern int buses_init(void);
 extern int classes_init(void);
 extern int firmware_init(void);
 extern int platform_bus_init(void);
-extern int sys_bus_init(void);
+extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
 /**
@@ -37,6 +37,6 @@ void __init driver_init(void)
 	 * core core pieces.
 	 */
 	platform_bus_init();
-	sys_bus_init();
+	system_bus_init();
 	cpu_dev_init();
 }
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/node.c linux-post-2.6.4rc1-20040303/drivers/base/node.c
--- linux-post-2.6.4rc1-20040302/drivers/base/node.c	2004-02-19 03:42:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/node.c	2004-02-13 06:35:40.000000000 +0000
@@ -69,7 +69,7 @@ int __init register_node(struct node *no
 	node->cpumap = node_to_cpumask(num);
 	node->sysdev.id = num;
 	node->sysdev.cls = &node_class;
-	error = sys_device_register(&node->sysdev);
+	error = sysdev_register(&node->sysdev);
 
 	if (!error){
 		sysdev_create_file(&node->sysdev, &attr_cpumap);
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/power/main.c linux-post-2.6.4rc1-20040303/drivers/base/power/main.c
--- linux-post-2.6.4rc1-20040302/drivers/base/power/main.c	2003-09-09 18:22:35.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/power/main.c	2004-03-03 00:39:28.000000000 +0000
@@ -19,7 +19,10 @@
  * ancestral dependencies that the subsystem list maintains.
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include "power.h"
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/power/shutdown.c linux-post-2.6.4rc1-20040303/drivers/base/power/shutdown.c
--- linux-post-2.6.4rc1-20040302/drivers/base/power/shutdown.c	2003-08-15 17:32:47.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/power/shutdown.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,7 +8,10 @@
  *
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/device.h>
 #include <asm/semaphore.h>
@@ -54,7 +57,7 @@ void device_shutdown(void)
 	
 	down_write(&devices_subsys.rwsem);
 	list_for_each_entry_reverse(dev,&devices_subsys.kset.list,kobj.entry) {
-		pr_debug("shutting down %s: ",dev->name);
+		pr_debug("shutting down %s: ",dev->bus_id);
 		if (dev->driver && dev->driver->shutdown) {
 			pr_debug("Ok\n");
 			dev->driver->shutdown(dev);
diff -purN linux-post-2.6.4rc1-20040302/drivers/base/sys.c linux-post-2.6.4rc1-20040303/drivers/base/sys.c
--- linux-post-2.6.4rc1-20040302/drivers/base/sys.c	2003-09-05 22:28:42.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/base/sys.c	2004-03-03 00:39:28.000000000 +0000
@@ -8,11 +8,14 @@
  * 
  * This exports a 'system' bus type. 
  * By default, a 'sys' bus gets added to the root of the system. There will
- * always be core system devices. Devices can use sys_device_register() to
+ * always be core system devices. Devices can use sysdev_register() to
  * add themselves as children of the system bus.
  */
 
-#undef DEBUG
+#include <linux/config.h>
+#ifdef CONFIG_DEBUG_DRIVER
+#define DEBUG	1
+#endif
 
 #include <linux/sysdev.h>
 #include <linux/err.h>
@@ -164,11 +167,11 @@ EXPORT_SYMBOL(sysdev_driver_unregister);
 
 
 /**
- *	sys_device_register - add a system device to the tree
+ *	sysdev_register - add a system device to the tree
  *	@sysdev:	device in question
  *
  */
-int sys_device_register(struct sys_device * sysdev)
+int sysdev_register(struct sys_device * sysdev)
 {
 	int error;
 	struct sysdev_class * cls = sysdev->cls;
@@ -212,7 +215,7 @@ int sys_device_register(struct sys_devic
 	return error;
 }
 
-void sys_device_unregister(struct sys_device * sysdev)
+void sysdev_unregister(struct sys_device * sysdev)
 {
 	struct sysdev_driver * drv;
 
@@ -384,11 +387,11 @@ int sysdev_resume(void)
 }
 
 
-int __init sys_bus_init(void)
+int __init system_bus_init(void)
 {
 	system_subsys.kset.kobj.parent = &devices_subsys.kset.kobj;
 	return subsystem_register(&system_subsys);
 }
 
-EXPORT_SYMBOL(sys_device_register);
-EXPORT_SYMBOL(sys_device_unregister);
+EXPORT_SYMBOL(sysdev_register);
+EXPORT_SYMBOL(sysdev_unregister);
diff -purN linux-post-2.6.4rc1-20040302/drivers/char/misc.c linux-post-2.6.4rc1-20040303/drivers/char/misc.c
--- linux-post-2.6.4rc1-20040302/drivers/char/misc.c	2004-01-15 11:05:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/char/misc.c	2004-02-13 11:15:29.000000000 +0000
@@ -212,6 +212,9 @@ static struct file_operations misc_fops 
 int misc_register(struct miscdevice * misc)
 {
 	struct miscdevice *c;
+	struct class_device *class;
+	dev_t dev;
+	int err;
 	
 	down(&misc_sem);
 	list_for_each_entry(c, &misc_list, list) {
@@ -240,19 +243,30 @@ int misc_register(struct miscdevice * mi
 		snprintf(misc->devfs_name, sizeof(misc->devfs_name),
 				"misc/%s", misc->name);
 	}
+	dev = MKDEV(MISC_MAJOR, misc->minor);
 
-	class_simple_device_add(misc_class, MKDEV(MISC_MAJOR, misc->minor),
-				misc->dev, misc->name);
-	devfs_mk_cdev(MKDEV(MISC_MAJOR, misc->minor),
-			S_IFCHR|S_IRUSR|S_IWUSR|S_IRGRP, misc->devfs_name);
+	class = class_simple_device_add(misc_class, dev,
+					misc->dev, misc->name);
+	if (IS_ERR(class)) {
+		err = PTR_ERR(class);
+		goto out;
+	}
+
+	err = devfs_mk_cdev(dev, S_IFCHR|S_IRUSR|S_IWUSR|S_IRGRP, 
+			    misc->devfs_name);
+	if (err) {
+		class_simple_device_remove(dev);
+		goto out;
+	}
 
 	/*
 	 * Add it to the front, so that later devices can "override"
 	 * earlier defaults
 	 */
 	list_add(&misc->list, &misc_list);
+ out:
 	up(&misc_sem);
-	return 0;
+	return err;
 }
 
 /**
diff -purN linux-post-2.6.4rc1-20040302/drivers/input/serio/i8042.c linux-post-2.6.4rc1-20040303/drivers/input/serio/i8042.c
--- linux-post-2.6.4rc1-20040302/drivers/input/serio/i8042.c	2004-02-09 02:35:04.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/input/serio/i8042.c	2004-02-13 06:06:24.000000000 +0000
@@ -957,7 +957,7 @@ int __init i8042_init(void)
 	mod_timer(&i8042_timer, jiffies + I8042_POLL_PERIOD);
 
         if (sysdev_class_register(&kbc_sysclass) == 0) {
-                if (sys_device_register(&device_i8042) == 0)
+                if (sysdev_register(&device_i8042) == 0)
 			i8042_sysdev_initialized = 1;
 		else
 			sysdev_class_unregister(&kbc_sysclass);
@@ -980,7 +980,7 @@ void __exit i8042_exit(void)
 		pm_unregister(i8042_pm_dev);
 
 	if (i8042_sysdev_initialized) {
-		sys_device_unregister(&device_i8042);
+		sysdev_unregister(&device_i8042);
 		sysdev_class_unregister(&kbc_sysclass);
 	}
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/isdn/icn/icn.c linux-post-2.6.4rc1-20040303/drivers/isdn/icn/icn.c
--- linux-post-2.6.4rc1-20040302/drivers/isdn/icn/icn.c	2003-09-07 10:22:44.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/isdn/icn/icn.c	2004-03-02 12:18:59.000000000 +0000
@@ -504,19 +504,19 @@ icn_parse_status(u_char * status, int ch
 		case 3:
 			{
 				char *t = status + 6;
-				char *s = strpbrk(t, ",");
+				char *s = strchr(t, ',');
 
 				*s++ = '\0';
 				strlcpy(cmd.parm.setup.phone, t,
 					sizeof(cmd.parm.setup.phone));
-				s = strpbrk(t = s, ",");
+				s = strchr(t = s, ',');
 				*s++ = '\0';
 				if (!strlen(t))
 					cmd.parm.setup.si1 = 0;
 				else
 					cmd.parm.setup.si1 =
 					    simple_strtoul(t, NULL, 10);
-				s = strpbrk(t = s, ",");
+				s = strchr(t = s, ',');
 				*s++ = '\0';
 				if (!strlen(t))
 					cmd.parm.setup.si2 = 0;
diff -purN linux-post-2.6.4rc1-20040302/drivers/isdn/isdnloop/isdnloop.c linux-post-2.6.4rc1-20040303/drivers/isdn/isdnloop/isdnloop.c
--- linux-post-2.6.4rc1-20040302/drivers/isdn/isdnloop/isdnloop.c	2003-06-04 16:26:29.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/isdn/isdnloop/isdnloop.c	2004-03-02 12:20:06.000000000 +0000
@@ -122,17 +122,17 @@ static void
 isdnloop_parse_setup(char *setup, isdn_ctrl * cmd)
 {
 	char *t = setup;
-	char *s = strpbrk(t, ",");
+	char *s = strchr(t, ',');
 
 	*s++ = '\0';
 	strlcpy(cmd->parm.setup.phone, t, sizeof(cmd->parm.setup.phone));
-	s = strpbrk(t = s, ",");
+	s = strchr(t = s, ',');
 	*s++ = '\0';
 	if (!strlen(t))
 		cmd->parm.setup.si1 = 0;
 	else
 		cmd->parm.setup.si1 = simple_strtoul(t, NULL, 10);
-	s = strpbrk(t = s, ",");
+	s = strchr(t = s, ',');
 	*s++ = '\0';
 	if (!strlen(t))
 		cmd->parm.setup.si2 = 0;
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/Kconfig linux-post-2.6.4rc1-20040303/drivers/misc/Kconfig
--- linux-post-2.6.4rc1-20040302/drivers/misc/Kconfig	2002-10-30 01:17:11.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/Kconfig	2004-03-02 12:13:10.000000000 +0000
@@ -4,5 +4,22 @@
 
 menu "Misc devices"
 
+config IBM_ASM
+	tristate "Device driver for IBM RSA service processor"
+	depends on X86
+	default n
+	---help---
+	  This option enables device driver support for in-band access to the
+	  IBM RSA (Condor) service processor in eServer xSeries systems.
+	  The ibmasm device driver allows user space application to access
+	  ASM (Advanced Systems Management) functions on the service
+	  processor. The driver is meant to be used in conjunction with
+	  a user space API.
+	  The ibmasm driver also enables the OS to use the UART on the
+          service processor board as a regular serial port.
+	  
+
+	  If unsure, say N.
+
 endmenu
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/Makefile linux-post-2.6.4rc1-20040303/drivers/misc/Makefile
--- linux-post-2.6.4rc1-20040302/drivers/misc/Makefile	2002-12-14 12:38:56.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/Makefile	2004-02-25 21:24:20.000000000 +0000
@@ -2,3 +2,5 @@
 # Makefile for misc devices that really don't fit anywhere else.
 #
 obj- := misc.o	# Dummy rule to force built-in.o to be made
+
+obj-$(CONFIG_IBM_ASM)	+= ibmasm/
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/Makefile linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/Makefile
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/Makefile	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,13 @@
+
+obj-$(CONFIG_IBM_ASM) := ibmasm.o
+
+ibmasm-objs :=	module.o      \
+		ibmasmfs.o    \
+		event.o       \
+		command.o     \
+		remote.o      \
+		heartbeat.o   \
+		r_heartbeat.o \
+		dot_command.o \
+		lowlevel.o    \
+		uart.o
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/command.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/command.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/command.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/command.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,175 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include "ibmasm.h"
+
+static void exec_next_command(struct service_processor *sp);
+static void free_command(struct kobject *kobj);
+
+static struct kobj_type ibmasm_cmd_kobj_type = {
+	.release = free_command,
+};
+
+
+struct command *ibmasm_new_command(size_t buffer_size)
+{
+	struct command *cmd;
+
+	if (buffer_size > IBMASM_CMD_MAX_BUFFER_SIZE)
+		return NULL;
+
+	cmd = kmalloc(sizeof(struct command), GFP_KERNEL);
+	if (cmd == NULL)
+		return NULL;
+
+	memset(cmd, 0, sizeof(*cmd));
+
+	cmd->buffer = kmalloc(buffer_size, GFP_KERNEL);
+	if (cmd->buffer == NULL) {
+		kfree(cmd);
+		return NULL;
+	}
+	memset(cmd->buffer, 0, buffer_size);
+	cmd->buffer_size = buffer_size;
+
+	kobject_init(&cmd->kobj);
+	cmd->kobj.ktype = &ibmasm_cmd_kobj_type;
+
+	cmd->status = IBMASM_CMD_PENDING;
+	init_waitqueue_head(&cmd->wait);
+	INIT_LIST_HEAD(&cmd->queue_node);
+
+	return cmd;
+}
+
+static void free_command(struct kobject *kobj)
+{
+	struct command *cmd = to_command(kobj);
+ 
+	list_del(&cmd->queue_node);
+	kfree(cmd->buffer);
+	kfree(cmd);
+}
+
+static void enqueue_command(struct service_processor *sp, struct command *cmd)
+{
+	list_add_tail(&cmd->queue_node, &sp->command_queue);
+}
+
+static struct command *dequeue_command(struct service_processor *sp)
+{
+	struct command *cmd;
+	struct list_head *next;
+
+	if (list_empty(&sp->command_queue))
+		return NULL;
+
+	next = sp->command_queue.next;
+	list_del_init(next);
+	cmd = list_entry(next, struct command, queue_node);
+
+	return cmd;
+}
+
+static inline void do_exec_command(struct service_processor *sp)
+{
+	if (ibmasm_send_i2o_message(sp)) {
+		sp->current_command->status = IBMASM_CMD_FAILED;
+		exec_next_command(sp);
+	}
+}
+	
+/**
+ * exec_command
+ * send a command to a service processor
+ * Commands are executed sequentially. One command (sp->current_command)
+ * is sent to the service processor. Once the interrupt handler gets a
+ * message of type command_response, the message is copied into
+ * the current commands buffer, 
+ */
+void ibmasm_exec_command(struct service_processor *sp, struct command *cmd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&sp->lock, flags);
+
+	if (!sp->current_command) {
+		command_get(cmd);
+		sp->current_command = cmd;
+		spin_unlock_irqrestore(&sp->lock, flags);
+
+		do_exec_command(sp);
+	} else {
+		enqueue_command(sp, cmd);
+		spin_unlock_irqrestore(&sp->lock, flags);
+	}
+}
+
+static void exec_next_command(struct service_processor *sp)
+{
+	unsigned long flags;
+
+	wake_up(&sp->current_command->wait);
+	command_put(sp->current_command);
+
+	spin_lock_irqsave(&sp->lock, flags);
+	sp->current_command = dequeue_command(sp);
+	if (sp->current_command) {
+		command_get(sp->current_command);
+		spin_unlock_irqrestore(&sp->lock, flags);
+		do_exec_command(sp);
+	} else {
+		spin_unlock_irqrestore(&sp->lock, flags);
+	}
+}
+
+/** 
+ * Sleep until a command has failed or a response has been received
+ * and the command status been updated by the interrupt handler.
+ * (see receive_response).
+ */
+void ibmasm_wait_for_response(struct command *cmd, int timeout)
+{
+	wait_event_interruptible_timeout(cmd->wait,
+				cmd->status == IBMASM_CMD_COMPLETE ||
+				cmd->status == IBMASM_CMD_FAILED,
+				timeout * HZ);
+}
+
+/**
+ * receive_command_response
+ * called by the interrupt handler when a dot command of type command_response
+ * was received.
+ */
+void ibmasm_receive_command_response(struct service_processor *sp, void *response, size_t size)
+{
+	struct command *cmd = sp->current_command;
+
+	if (!sp->current_command) 
+		return; 
+
+	memcpy(cmd->buffer, response, min(size, cmd->buffer_size));
+	cmd->status = IBMASM_CMD_COMPLETE;
+	exec_next_command(sp);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/dot_command.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/dot_command.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/dot_command.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/dot_command.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,146 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include "ibmasm.h"
+#include "dot_command.h"
+
+/**
+ * Dispatch an incoming message to the specific handler for the message.
+ * Called from interrupt context.
+ */
+void ibmasm_receive_message(struct service_processor *sp, void *message, int message_size)
+{
+	u32 size;
+	struct dot_command_header *header = (struct dot_command_header *)message;
+
+	size = get_dot_command_size(message);
+	if (size > message_size)
+		size = message_size;
+
+	switch (header->type) {
+	case sp_event: 
+		ibmasm_receive_event(sp, message, size);
+		break;
+	case sp_command_response:
+		ibmasm_receive_command_response(sp, message, size); 
+		break;
+	case sp_heartbeat:
+		ibmasm_receive_heartbeat(sp, message, size);
+		break;
+	default:
+		dev_err(sp->dev, "Received unknown message from service processor\n");
+	}
+}
+
+
+#define INIT_BUFFER_SIZE 32
+
+
+/**
+ * send the 4.3.5.10 dot command (driver VPD) to the service processor
+ */
+int ibmasm_send_driver_vpd(struct service_processor *sp)
+{
+	struct command *command;
+	struct dot_command_header *header;
+	u8 *vpd_command;
+	u8 *vpd_data;
+	int result = 0;
+
+	command = ibmasm_new_command(INIT_BUFFER_SIZE);
+	if (command == NULL)
+		return -ENOMEM;
+
+	header = (struct dot_command_header *)command->buffer;
+	header->type                = sp_write;
+	header->command_size        = 4;
+	header->data_size           = 16;
+	header->status              = 0;
+	header->reserved            = 0;
+
+	vpd_command = command->buffer + sizeof(struct dot_command_header);
+	vpd_command[0] = 0x4;
+	vpd_command[1] = 0x3;
+	vpd_command[2] = 0x5;
+	vpd_command[3] = 0xa;
+
+	vpd_data = vpd_command + header->command_size;
+	vpd_data[0] = 0;
+	strcat(vpd_data, IBMASM_DRIVER_VPD);
+	vpd_data[10] = 0;
+	vpd_data[15] = 0;
+	
+	ibmasm_exec_command(sp, command);
+	ibmasm_wait_for_response(command, IBMASM_CMD_TIMEOUT_NORMAL);
+
+	if (command->status != IBMASM_CMD_COMPLETE)
+		result = -ENODEV;
+
+	command_put(command);
+
+	return result;
+}
+
+struct os_state_command {
+	struct dot_command_header	header;
+	unsigned char			command[3];
+	unsigned char			data;
+};
+
+/**
+ * send the 4.3.6 dot command (os state) to the service processor
+ * During driver init this function is called with os state "up".
+ * This causes the service processor to start sending heartbeats the
+ * driver.
+ * During driver exit the function is called with os state "down", 
+ * causing the service processor to stop the heartbeats.
+ */
+int ibmasm_send_os_state(struct service_processor *sp, int os_state)
+{
+	struct command *cmd;
+	struct os_state_command *os_state_cmd;
+	int result = 0;
+
+	cmd = ibmasm_new_command(sizeof(struct os_state_command));
+	if (cmd == NULL)
+		return -ENOMEM;
+
+	os_state_cmd = (struct os_state_command *)cmd->buffer;
+	os_state_cmd->header.type		= sp_write;
+	os_state_cmd->header.command_size	= 3;
+	os_state_cmd->header.data_size		= 1;
+	os_state_cmd->header.status		= 0;
+	os_state_cmd->command[0]		= 4;
+	os_state_cmd->command[1]		= 3;
+	os_state_cmd->command[2]		= 6;
+	os_state_cmd->data			= os_state;
+
+	ibmasm_exec_command(sp, cmd);
+	ibmasm_wait_for_response(cmd, IBMASM_CMD_TIMEOUT_NORMAL);
+
+	if (cmd->status != IBMASM_CMD_COMPLETE)
+		result = -ENODEV;
+
+	command_put(cmd);
+	return result;
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/dot_command.h linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/dot_command.h
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/dot_command.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/dot_command.h	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,78 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#ifndef __DOT_COMMAND_H__
+#define __DOT_COMMAND_H__
+
+/*
+ * dot commands are the protocol used to communicate with the service
+ * processor.
+ * They consist of header, a command of variable length and data of
+ * variable length.
+ */
+
+/* dot command types */
+#define sp_write		0
+#define sp_write_next		1
+#define sp_read			2
+#define sp_read_next		3
+#define sp_command_response	4
+#define sp_event		5
+#define sp_heartbeat		6
+
+#pragma pack(1)
+struct dot_command_header {
+	u8	type;
+	u8	command_size;
+	u16	data_size;
+	u8	status;
+	u8	reserved;
+};
+#pragma pack()
+
+static inline size_t get_dot_command_size(void *buffer)
+{
+	struct dot_command_header *cmd = (struct dot_command_header *)buffer;
+	return sizeof(struct dot_command_header) + cmd->command_size + cmd->data_size;
+}
+
+static inline unsigned int get_dot_command_timeout(void *buffer)
+{
+	struct dot_command_header *header = (struct dot_command_header *)buffer;
+	unsigned char *cmd = buffer + sizeof(struct dot_command_header);
+
+	/* dot commands 6.3.1, 7.1 and 8.x need a longer timeout */
+
+	if (header->command_size == 3) {
+		if ((cmd[0] == 6) && (cmd[1] == 3) && (cmd[2] == 1))
+			return IBMASM_CMD_TIMEOUT_EXTRA;
+	} else if (header->command_size == 2) {
+		if ((cmd[0] == 7) && (cmd[1] == 1))
+			return IBMASM_CMD_TIMEOUT_EXTRA;
+		if (cmd[0] == 8)
+			return IBMASM_CMD_TIMEOUT_EXTRA;
+	}
+	return IBMASM_CMD_TIMEOUT_NORMAL;
+}
+
+#endif /* __DOT_COMMAND_H__ */
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/event.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/event.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/event.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/event.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,169 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include "ibmasm.h"
+
+/*
+ * ASM service processor event handling routines.
+ *
+ * Events are signalled to the device drivers through interrupts.
+ * They have the format of dot commands, with the type field set to
+ * sp_event.
+ * The driver does not interpret the events, it simply stores them in a
+ * circular buffer.
+ */
+
+
+static void wake_up_event_readers(struct service_processor *sp)
+{
+	struct event_reader *reader;
+
+	list_for_each_entry(reader, &sp->event_buffer->readers, node)
+                wake_up_interruptible(&reader->wait);
+}
+
+/**
+ * receive_event
+ * Called by the interrupt handler when a dot command of type sp_event is
+ * received.
+ * Store the event in the circular event buffer, wake up any sleeping
+ * event readers.
+ * There is no reader marker in the buffer, therefore readers are
+ * responsible for keeping up with the writer, or they will loose events.
+ */ 
+void ibmasm_receive_event(struct service_processor *sp, void *data, unsigned int data_size)
+{
+	struct event_buffer *buffer = sp->event_buffer;
+	struct ibmasm_event *event;
+	unsigned long flags;
+
+	data_size = min(data_size, IBMASM_EVENT_MAX_SIZE);
+
+	spin_lock_irqsave(&sp->lock, flags);
+	/* copy the event into the next slot in the circular buffer */
+	event = &buffer->events[buffer->next_index];
+	memcpy(event->data, data, data_size);
+	event->data_size = data_size;
+	event->serial_number = buffer->next_serial_number;
+
+	/* advance indices in the buffer */
+	buffer->next_index = (buffer->next_index + 1) % IBMASM_NUM_EVENTS;
+	buffer->next_serial_number++;
+	spin_unlock_irqrestore(&sp->lock, flags);
+
+	wake_up_event_readers(sp);
+}
+
+static inline int event_available(struct event_buffer *b, struct event_reader *r)
+{
+	return 	(r->next_serial_number < b->next_serial_number);
+}
+
+/**
+ * get_next_event
+ * Called by event readers (initiated from user space through the file
+ * system). 
+ * Sleeps until a new event is available.
+ */
+int ibmasm_get_next_event(struct service_processor *sp, struct event_reader *reader)
+{
+	struct event_buffer *buffer = sp->event_buffer;
+	struct ibmasm_event *event;
+	unsigned int index;
+	unsigned long flags;
+
+	if (wait_event_interruptible(reader->wait, event_available(buffer, reader)))
+		return -ERESTARTSYS;
+
+	if (!event_available(buffer, reader))
+		return 0;
+
+	spin_lock_irqsave(&sp->lock, flags);
+
+	index = buffer->next_index;
+	event = &buffer->events[index];
+	while (event->serial_number < reader->next_serial_number) {
+		index = (index + 1) % IBMASM_NUM_EVENTS;
+		event = &buffer->events[index];
+	}
+	memcpy(reader->data, event->data, event->data_size);
+	reader->data_size = event->data_size;
+	reader->next_serial_number = event->serial_number + 1;
+
+	spin_unlock_irqrestore(&sp->lock, flags);
+
+	return event->data_size;
+}
+
+void ibmasm_event_reader_register(struct service_processor *sp, struct event_reader *reader)
+{
+	unsigned long flags;
+
+	reader->next_serial_number = sp->event_buffer->next_serial_number;
+	init_waitqueue_head(&reader->wait);
+	spin_lock_irqsave(&sp->lock, flags);
+	list_add(&reader->node, &sp->event_buffer->readers);
+	spin_unlock_irqrestore(&sp->lock, flags);
+}
+
+void ibmasm_event_reader_unregister(struct service_processor *sp, struct event_reader *reader)
+{
+	unsigned long flags;
+
+	wake_up_interruptible(&reader->wait);
+
+	spin_lock_irqsave(&sp->lock, flags);
+	list_del(&reader->node);
+	spin_unlock_irqrestore(&sp->lock, flags);
+}
+
+int ibmasm_event_buffer_init(struct service_processor *sp)
+{
+	struct event_buffer *buffer;
+	struct ibmasm_event *event;
+	int i;
+
+	buffer = kmalloc(sizeof(struct event_buffer), GFP_KERNEL);
+	if (!buffer)
+		return 1;
+
+	buffer->next_index = 0;
+	buffer->next_serial_number = 1;
+
+	event = buffer->events;
+	for (i=0; i<IBMASM_NUM_EVENTS; i++, event++)
+		event->serial_number = 0;
+
+	INIT_LIST_HEAD(&buffer->readers);
+
+	sp->event_buffer = buffer;
+
+	return 0;
+}
+
+void ibmasm_event_buffer_exit(struct service_processor *sp)
+{
+	wake_up_event_readers(sp);
+	kfree(sp->event_buffer);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/heartbeat.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/heartbeat.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/heartbeat.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/heartbeat.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,91 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include <linux/notifier.h>
+#include "ibmasm.h"
+#include "dot_command.h"
+
+static int suspend_heartbeats = 0;
+
+/*
+ * Once the driver indicates to the service processor that it is running
+ * - see send_os_state() - the service processor sends periodic heartbeats
+ * to the driver. The driver must respond to the heartbeats or else the OS
+ * will be rebooted.
+ * In the case of a panic the interrupt handler continues to work and thus
+ * continues to respond to heartbeats, making the service processor believe
+ * the OS is still running and thus preventing a reboot.
+ * To prevent this from happening a callback is added the panic_notifier_list.
+ * Before responding to a heartbeat the driver checks if a panic has happened,
+ * if yes it suspends heartbeat, causing the service processor to reboot as
+ * expected.
+ */
+static int panic_happened(struct notifier_block *n, unsigned long val, void *v)
+{
+	suspend_heartbeats = 1;
+	return 0;
+}
+
+static struct notifier_block panic_notifier = { panic_happened, NULL, 1 };
+
+void ibmasm_register_panic_notifier(void)
+{
+	notifier_chain_register(&panic_notifier_list, &panic_notifier);
+}
+
+void ibmasm_unregister_panic_notifier(void)
+{
+	notifier_chain_unregister(&panic_notifier_list, &panic_notifier);
+}
+
+
+int ibmasm_heartbeat_init(struct service_processor *sp)
+{
+	sp->heartbeat = ibmasm_new_command(HEARTBEAT_BUFFER_SIZE);
+	if (sp->heartbeat == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void ibmasm_heartbeat_exit(struct service_processor *sp)
+{
+	command_put(sp->heartbeat);
+}
+
+void ibmasm_receive_heartbeat(struct service_processor *sp,  void *message, size_t size)
+{
+	struct command *cmd = sp->heartbeat;
+	struct dot_command_header *header = (struct dot_command_header *)cmd->buffer;
+
+	if (suspend_heartbeats)
+		return;
+
+	/* return the received dot command to sender */
+	cmd->status = IBMASM_CMD_PENDING;
+	size = min(size, cmd->buffer_size);
+	memcpy(cmd->buffer, message, size);
+	header->type = sp_write;
+	ibmasm_exec_command(sp, cmd);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/i2o.h linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/i2o.h
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/i2o.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/i2o.h	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,77 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#pragma pack(1)
+struct i2o_header {
+	u8	version;
+	u8	message_flags;
+	u16	message_size;
+	u8	target;           
+	u8	initiator_and_target;
+	u8	initiator;        
+	u8	function;
+	u32	initiator_context;
+};
+#pragma pack()
+
+#define I2O_HEADER_TEMPLATE \
+      { .version              = 0x01, \
+	.message_flags        = 0x00, \
+	.function             = 0xFF, \
+	.initiator            = 0x00, \
+	.initiator_and_target = 0x40, \
+	.target               = 0x00, \
+	.initiator_context    = 0x0 }
+
+#define I2O_MESSAGE_SIZE	0x1000
+#define I2O_COMMAND_SIZE	(I2O_MESSAGE_SIZE - sizeof(struct i2o_header))
+
+#pragma pack(1)
+struct i2o_message {
+	struct i2o_header	header;
+	void			*data;
+};
+#pragma pack()
+
+static inline unsigned short outgoing_message_size(unsigned int data_size)
+{
+	unsigned int size;
+	unsigned short i2o_size;
+
+	if (data_size > I2O_COMMAND_SIZE)
+		data_size = I2O_COMMAND_SIZE;
+
+	size = sizeof(struct i2o_header) + data_size;
+
+	i2o_size = size / sizeof(u32);
+	
+	if (size % sizeof(u32))
+	       i2o_size++;
+
+	return i2o_size;
+}	
+
+static inline u32 incoming_data_size(struct i2o_message *i2o_message)
+{
+	return (sizeof(u32) * i2o_message->header.message_size);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/ibmasm.h linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/ibmasm.h
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/ibmasm.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/ibmasm.h	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,224 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+/* Driver identification */
+#define DRIVER_NAME	"ibmasm"
+#define DRIVER_VERSION  "0.4"
+#define DRIVER_AUTHOR   "Max Asbock"
+#define DRIVER_DESC     "IBM ASM Service Processor Driver"
+
+#define err(msg) printk(KERN_ERR "%s: " msg "\n", DRIVER_NAME)
+#define info(msg) printk(KERN_INFO "%s: " msg "\n", DRIVER_NAME)
+
+
+#define IBMASM_CMD_PENDING	0	
+#define IBMASM_CMD_COMPLETE	1	
+#define IBMASM_CMD_FAILED	2
+
+#define IBMASM_CMD_TIMEOUT_NORMAL	45
+#define IBMASM_CMD_TIMEOUT_EXTRA	240
+
+#define IBMASM_CMD_MAX_BUFFER_SIZE	0x4000
+
+#define REVERSE_HEARTBEAT_TIMEOUT	120
+
+#define HEARTBEAT_BUFFER_SIZE		0x400
+
+#ifdef IA64
+#define IBMASM_DRIVER_VPD "Lin64 6.08      "
+#else
+#define IBMASM_DRIVER_VPD "Lin32 6.08      "
+#endif
+
+#define SYSTEM_STATE_OS_UP      5
+#define SYSTEM_STATE_OS_DOWN    4
+
+#define IBMASM_NAME_SIZE	16
+
+#define IBMASM_NUM_EVENTS	10
+#define IBMASM_EVENT_MAX_SIZE	2048u
+
+
+struct command {
+	struct list_head	queue_node;
+	wait_queue_head_t	wait;
+	unsigned char		*buffer;
+	size_t			buffer_size;
+	int			status;
+	struct kobject		kobj;
+};
+#define to_command(c) container_of(c, struct command, kobj)
+
+static inline void command_put(struct command *cmd)
+{
+        kobject_put(&cmd->kobj);
+}
+
+static inline void command_get(struct command *cmd)
+{
+        kobject_get(&cmd->kobj);
+}
+
+
+struct ibmasm_event {
+	unsigned int	serial_number;
+	unsigned int	data_size;
+	unsigned char	data[IBMASM_EVENT_MAX_SIZE];
+};
+
+struct event_buffer {
+	struct ibmasm_event	events[IBMASM_NUM_EVENTS];
+	unsigned int		next_serial_number;
+	unsigned int		next_index;
+	struct list_head	readers;
+};
+
+struct event_reader {
+	unsigned int		next_serial_number;
+	wait_queue_head_t	wait;
+	struct list_head	node;
+	unsigned int		data_size;
+	unsigned char		data[IBMASM_EVENT_MAX_SIZE];
+};
+
+struct reverse_heartbeat {
+	wait_queue_head_t	wait;
+	unsigned int		stopped;
+};
+
+
+/* remote console events */
+struct mouse_event {
+	long		x;
+	long		y;
+	unsigned char	buttons;
+	unsigned char	transitions;
+};
+
+struct keyboard_event {
+	unsigned long	key_code;
+	unsigned char	key_down;
+};
+
+struct remote_event {
+	unsigned long	type;
+	union {
+		struct mouse_event	mouse;
+		struct keyboard_event	keyboard;
+	} data;
+};
+
+#define DRIVER_REMOTE_QUEUE_SIZE 240
+
+struct remote_queue {
+	struct remote_event	*start;
+	struct remote_event	*end;
+	struct remote_event	*reader;
+	struct remote_event	*writer;
+	unsigned int		size;
+	int			open;
+	wait_queue_head_t	wait;
+};
+
+
+struct service_processor {
+	struct list_head	node;
+	spinlock_t		lock;
+	void 			*base_address;
+	unsigned int		irq;
+	struct command		*current_command;
+	struct command		*heartbeat;
+	struct list_head	command_queue;
+	struct event_buffer	*event_buffer;
+	char			dirname[IBMASM_NAME_SIZE];
+	char			devname[IBMASM_NAME_SIZE];
+	unsigned int		number;
+	struct remote_queue	remote_queue;
+	int			serial_line;
+	struct device		*dev;
+};
+
+/* command processing */
+extern struct command *ibmasm_new_command(size_t buffer_size);
+extern void ibmasm_exec_command(struct service_processor *sp, struct command *cmd);
+extern void ibmasm_wait_for_response(struct command *cmd, int timeout);
+extern void ibmasm_receive_command_response(struct service_processor *sp, void *response,  size_t size);
+
+/* event processing */
+extern int ibmasm_event_buffer_init(struct service_processor *sp);
+extern void ibmasm_event_buffer_exit(struct service_processor *sp);
+extern void ibmasm_receive_event(struct service_processor *sp, void *data,  unsigned int data_size);
+extern void ibmasm_event_reader_register(struct service_processor *sp, struct event_reader *reader);
+extern void ibmasm_event_reader_unregister(struct service_processor *sp, struct event_reader *reader);
+extern int ibmasm_get_next_event(struct service_processor *sp, struct event_reader *reader);
+
+/* heartbeat - from SP to OS */
+extern void ibmasm_register_panic_notifier(void);
+extern void ibmasm_unregister_panic_notifier(void);
+extern int ibmasm_heartbeat_init(struct service_processor *sp);
+extern void ibmasm_heartbeat_exit(struct service_processor *sp);
+extern void ibmasm_receive_heartbeat(struct service_processor *sp,  void *message, size_t size);
+
+/* reverse heartbeat - from OS to SP */
+extern void ibmasm_init_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb);
+extern int ibmasm_start_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb);
+extern void ibmasm_stop_reverse_heartbeat(struct reverse_heartbeat *rhb);
+
+/* dot commands */
+extern void ibmasm_receive_message(struct service_processor *sp, void *data, int data_size);
+extern int ibmasm_send_driver_vpd(struct service_processor *sp);
+extern int ibmasm_send_os_state(struct service_processor *sp, int os_state);
+
+/* low level message processing */
+extern int ibmasm_send_i2o_message(struct service_processor *sp);
+extern irqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id, struct pt_regs *regs);
+
+/* remote console */
+extern void ibmasm_handle_mouse_interrupt(struct service_processor *sp);
+extern int ibmasm_init_remote_queue(struct service_processor *sp);
+extern void ibmasm_free_remote_queue(struct service_processor *sp);
+extern void ibmasm_advance_reader(struct remote_queue *q, unsigned int n);
+extern size_t ibmasm_events_available(struct remote_queue *q);
+
+/* file system */
+extern int ibmasmfs_register(void);
+extern void ibmasmfs_unregister(void);
+extern void ibmasmfs_add_sp(struct service_processor *sp);
+
+/* uart */
+extern void ibmasm_register_uart(struct service_processor *sp);
+extern void ibmasm_unregister_uart(struct service_processor *sp);
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/ibmasmfs.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/ibmasmfs.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/ibmasmfs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/ibmasmfs.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,717 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+/*
+ * Parts of this code are based on an article by Jonathan Corbet 
+ * that appeared in Linux Weekly News.
+ */
+
+
+/*
+ * The IBMASM file virtual filesystem. It creates the following hierarchy
+ * dymamically when mounted from user space:
+ *
+ *    /ibmasm
+ *    |-- 0
+ *    |   |-- command
+ *    |   |-- event
+ *    |   |-- reverse_heartbeat
+ *    |   `-- remote_video
+ *    |       |-- connected
+ *    |       |-- depth
+ *    |       |-- events
+ *    |       |-- height
+ *    |       `-- width
+ *    .
+ *    .
+ *    .
+ *    `-- n
+ *        |-- command
+ *        |-- event
+ *        |-- reverse_heartbeat
+ *        `-- remote_video
+ *            |-- connected
+ *            |-- depth
+ *            |-- events
+ *            |-- height
+ *            `-- width
+ *
+ * For each service processor the following files are created:
+ *
+ * command: execute dot commands
+ * 	write: execute a dot command on the service processor
+ * 	read: return the result of a previously executed dot command
+ *
+ * events: listen for service processor events
+ * 	read: sleep (interruptible) until an event occurs
+ *      write: wakeup sleeping event listener
+ *
+ * reverse_heartbeat: send a heartbeat to the service processor
+ * 	read: sleep (interruptible) until the reverse heartbeat fails
+ *      write: wakeup sleeping heartbeat listener
+ *
+ * remote_video/width
+ * remote_video/height
+ * remote_video/width: control remote display settings
+ * 	write: set value
+ * 	read: read value
+ *
+ * remote_video/connected
+ * 	read: return "1" if web browser VNC java applet is connected, 
+ * 		"0" otherwise
+ *
+ * remote_video/events
+ * 	read: sleep until a remote mouse or keyboard event occurs, then return
+ * 		then event.
+ */
+
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "ibmasm.h"
+#include "remote.h"
+#include "dot_command.h"
+
+#define IBMASMFS_MAGIC 0x66726f67
+
+static LIST_HEAD(service_processors);
+
+static struct inode *ibmasmfs_make_inode(struct super_block *sb, int mode);
+static void ibmasmfs_create_files (struct super_block *sb, struct dentry *root);
+static int ibmasmfs_fill_super (struct super_block *sb, void *data, int silent);
+
+
+static struct super_block *ibmasmfs_get_super(struct file_system_type *fst,
+			int flags, const char *name, void *data)
+{
+	return get_sb_single(fst, flags, data, ibmasmfs_fill_super);
+}
+
+static struct super_operations ibmasmfs_s_ops = {
+	.statfs		= simple_statfs,
+	.drop_inode	= generic_delete_inode,
+};
+
+static struct file_operations *ibmasmfs_dir_ops = &simple_dir_operations;
+
+static struct file_system_type ibmasmfs_type = {
+	.owner          = THIS_MODULE,
+	.name           = "ibmasmfs",
+	.get_sb         = ibmasmfs_get_super,
+	.kill_sb        = kill_litter_super,
+};
+
+static int ibmasmfs_fill_super (struct super_block *sb, void *data, int silent)
+{
+	struct inode *root;
+	struct dentry *root_dentry;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = IBMASMFS_MAGIC;
+	sb->s_op = &ibmasmfs_s_ops;
+
+	root = ibmasmfs_make_inode (sb, S_IFDIR | 0500);
+	if (!root)
+		return -ENOMEM;
+
+	root->i_op = &simple_dir_inode_operations;
+	root->i_fop = ibmasmfs_dir_ops;
+
+	root_dentry = d_alloc_root(root);
+	if (!root_dentry) {
+		iput(root);
+		return -ENOMEM;
+	}
+	sb->s_root = root_dentry;
+
+	ibmasmfs_create_files(sb, root_dentry);
+	return 0;
+}
+
+static struct inode *ibmasmfs_make_inode(struct super_block *sb, int mode)
+{
+	struct inode *ret = new_inode(sb);
+
+	if (ret) {
+		ret->i_mode = mode;
+		ret->i_uid = ret->i_gid = 0;
+		ret->i_blksize = PAGE_CACHE_SIZE;
+		ret->i_blocks = 0;
+		ret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;
+	}
+	return ret;
+}
+
+static struct dentry *ibmasmfs_create_file (struct super_block *sb,
+			struct dentry *parent,
+		       	const char *name,
+			struct file_operations *fops,
+			void *data,
+			int mode)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+	struct qstr qname;
+
+	qname.name = name;
+	qname.len = strlen (name);
+	qname.hash = full_name_hash(name, qname.len);
+
+	dentry = d_alloc(parent, &qname);
+	if (!dentry)
+		return NULL;
+
+	inode = ibmasmfs_make_inode(sb, S_IFREG | mode);
+	if (!inode) {
+		dput(dentry);
+		return NULL;
+	}
+
+	inode->i_fop = fops;
+	inode->u.generic_ip = data;
+
+	d_add(dentry, inode);
+	return dentry;
+}
+
+static struct dentry *ibmasmfs_create_dir (struct super_block *sb,
+				struct dentry *parent,
+				const char *name)
+{
+	struct dentry *dentry;
+	struct inode *inode;
+	struct qstr qname;
+
+	qname.name = name;
+	qname.len = strlen (name);
+	qname.hash = full_name_hash(name, qname.len);
+	dentry = d_alloc(parent, &qname);
+	if (!dentry)
+		return NULL;
+
+	inode = ibmasmfs_make_inode(sb, S_IFDIR | 0500);
+	if (!inode) {
+		dput(dentry);
+		return NULL;
+	}
+
+	inode->i_op = &simple_dir_inode_operations;
+	inode->i_fop = ibmasmfs_dir_ops;
+
+	d_add(dentry, inode);
+	return dentry;
+}
+
+int ibmasmfs_register()
+{
+	return register_filesystem(&ibmasmfs_type);
+}
+
+void ibmasmfs_unregister()
+{
+	unregister_filesystem(&ibmasmfs_type);
+}
+
+void ibmasmfs_add_sp(struct service_processor *sp)
+{
+	list_add(&sp->node, &service_processors);
+}
+
+/* struct to save state between command file operations */
+struct ibmasmfs_command_data {
+	struct service_processor	*sp;
+	struct command			*command;
+};
+
+/* struct to save state between event file operations */
+struct ibmasmfs_event_data {
+	struct service_processor	*sp;
+	struct event_reader		reader;
+	int				active;
+};
+
+/* struct to save state between reverse heartbeat file operations */
+struct ibmasmfs_heartbeat_data {
+	struct service_processor	*sp;
+	struct reverse_heartbeat	heartbeat;
+	int				active;
+};
+
+static int command_file_open(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_command_data *command_data;
+
+	if (!inode->u.generic_ip)
+		return -ENODEV;
+
+	command_data = kmalloc(sizeof(struct ibmasmfs_command_data), GFP_KERNEL);
+	if (!command_data)
+		return -ENOMEM;
+
+	command_data->command = NULL;
+	command_data->sp = inode->u.generic_ip;
+	file->private_data = command_data;
+	return 0;
+}
+
+static int command_file_close(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_command_data *command_data = file->private_data;
+
+	if (command_data->command)
+		command_put(command_data->command);	
+
+	kfree(command_data);
+	return 0;
+}
+
+static ssize_t command_file_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_command_data *command_data = file->private_data;
+	struct command *cmd;
+	int len;
+	unsigned long flags;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	spin_lock_irqsave(&command_data->sp->lock, flags);
+	cmd = command_data->command;
+	if (cmd == NULL) {
+		spin_unlock_irqrestore(&command_data->sp->lock, flags);
+		return 0;
+	}
+	command_data->command = NULL;
+	spin_unlock_irqrestore(&command_data->sp->lock, flags);
+
+	if (cmd->status != IBMASM_CMD_COMPLETE) {
+		command_put(cmd);
+		return -EIO;
+	}
+	len = min(count, cmd->buffer_size);
+	if (copy_to_user(buf, cmd->buffer, len)) {
+		command_put(cmd);
+		return -EFAULT;
+	}
+	command_put(cmd);
+
+	return len;
+}
+
+static ssize_t command_file_write(struct file *file, const char *ubuff, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_command_data *command_data = file->private_data;
+	struct command *cmd;
+	unsigned long flags;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > IBMASM_CMD_MAX_BUFFER_SIZE)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	/* commands are executed sequentially, only one command at a time */
+	if (command_data->command)
+		return -EAGAIN;
+
+	cmd = ibmasm_new_command(count);
+	if (!cmd)
+		return -ENOMEM;
+
+	if (copy_from_user((void *)cmd->buffer, (void *)ubuff, count)) {
+		command_put(cmd);
+		return -EFAULT;
+	}
+
+	spin_lock_irqsave(&command_data->sp->lock, flags);
+	if (command_data->command) {
+		spin_unlock_irqrestore(&command_data->sp->lock, flags);
+		command_put(cmd);
+		return -EAGAIN;
+	}
+	command_data->command = cmd;
+	spin_unlock_irqrestore(&command_data->sp->lock, flags);
+
+	ibmasm_exec_command(command_data->sp, cmd);
+	ibmasm_wait_for_response(cmd, get_dot_command_timeout(cmd->buffer));
+
+	return count;
+}
+
+static int event_file_open(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_event_data *event_data;
+	struct service_processor *sp; 
+
+	if (!inode->u.generic_ip)
+		return -ENODEV;
+
+	sp = inode->u.generic_ip;
+
+	event_data = kmalloc(sizeof(struct ibmasmfs_event_data), GFP_KERNEL);
+	if (!event_data)
+		return -ENOMEM;
+
+	ibmasm_event_reader_register(sp, &event_data->reader);
+
+	event_data->sp = sp;
+	file->private_data = event_data;
+	return 0;
+}
+
+static int event_file_close(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_event_data *event_data = file->private_data;
+
+	ibmasm_event_reader_unregister(event_data->sp, &event_data->reader);
+	kfree(event_data);
+	return 0;
+}
+
+static ssize_t event_file_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_event_data *event_data = file->private_data;
+	struct event_reader *reader = &event_data->reader;
+	int ret;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > IBMASM_EVENT_MAX_SIZE)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	ret = ibmasm_get_next_event(event_data->sp, reader);
+	if (ret <= 0)
+		return ret;
+
+	if (count < reader->data_size)
+		return -EINVAL;
+
+        if (copy_to_user(buf, reader->data, reader->data_size))
+		return -EFAULT;
+
+	return reader->data_size;
+}
+
+static ssize_t event_file_write(struct file *file, const char *buf, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_event_data *event_data = file->private_data;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count != 1)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	wake_up_interruptible(&event_data->reader.wait);
+	return 0;
+}
+
+static int r_heartbeat_file_open(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_heartbeat_data *rhbeat;
+
+	if (!inode->u.generic_ip)
+		return -ENODEV;
+
+	rhbeat = kmalloc(sizeof(struct ibmasmfs_heartbeat_data), GFP_KERNEL);
+	if (!rhbeat)
+		return -ENOMEM;
+
+	rhbeat->sp = (struct service_processor *)inode->u.generic_ip;
+	rhbeat->active = 0;
+	ibmasm_init_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);
+	file->private_data = rhbeat;
+	return 0;
+}
+
+static int r_heartbeat_file_close(struct inode *inode, struct file *file)
+{
+	struct ibmasmfs_heartbeat_data *rhbeat = file->private_data;
+
+	kfree(rhbeat);
+	return 0;
+}
+
+static ssize_t r_heartbeat_file_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_heartbeat_data *rhbeat = file->private_data;
+	unsigned long flags;
+	int result;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > 1024)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	/* allow only one reverse heartbeat per process */
+	spin_lock_irqsave(&rhbeat->sp->lock, flags);
+	if (rhbeat->active) {
+		spin_unlock_irqrestore(&rhbeat->sp->lock, flags);
+		return -EBUSY;
+	}
+	rhbeat->active = 1;
+	spin_unlock_irqrestore(&rhbeat->sp->lock, flags);
+
+	result = ibmasm_start_reverse_heartbeat(rhbeat->sp, &rhbeat->heartbeat);
+	rhbeat->active = 0;
+
+	return result;
+}
+
+static ssize_t r_heartbeat_file_write(struct file *file, const char *buf, size_t count, loff_t *offset)
+{
+	struct ibmasmfs_heartbeat_data *rhbeat = file->private_data;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count != 1)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	if (rhbeat->active)
+		ibmasm_stop_reverse_heartbeat(&rhbeat->heartbeat);
+
+	return 1;
+}
+
+static int remote_settings_file_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->u.generic_ip;
+	return 0;
+}
+
+static int remote_settings_file_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t remote_settings_file_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	unsigned long address = (unsigned long)file->private_data;
+	unsigned char *page;
+	int retval;
+	int len = 0;
+	unsigned int value;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > 1024)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	page = (unsigned char *)__get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	value = readl(address);
+	len = sprintf(page, "%d\n", value);
+
+	if (copy_to_user(buf, page, len)) {
+		retval = -EFAULT;
+		goto exit;
+	}
+	*offset += len;
+	retval = len;
+
+exit:
+	free_page((unsigned long)page);
+	return retval;
+}
+
+static ssize_t remote_settings_file_write(struct file *file, const char *ubuff, size_t count, loff_t *offset)
+{
+	unsigned long address = (unsigned long)file->private_data;
+	char *buff;
+	unsigned int value;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > 1024)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	buff = kmalloc (count + 1, GFP_KERNEL);
+	if (!buff)
+		return -ENOMEM;
+
+	memset(buff, 0x0, count + 1);
+
+	if (copy_from_user((void *)buff, (void *)ubuff, count)) {
+		kfree(buff);
+		return -EFAULT;
+	}
+	
+	value = simple_strtoul(buff, NULL, 10);
+	writel(value, address);
+	kfree(buff);
+
+	return count;
+}
+
+static int remote_event_file_open(struct inode *inode, struct file *file)
+{
+	struct service_processor *sp;
+	unsigned long flags;
+	struct remote_queue *q;
+	
+	file->private_data = inode->u.generic_ip;
+	sp = file->private_data;
+	q = &sp->remote_queue;
+
+	/* allow only one event reader */
+	spin_lock_irqsave(&sp->lock, flags);
+	if (q->open) {
+		spin_unlock_irqrestore(&sp->lock, flags);
+		return -EBUSY;
+	}
+	q->open = 1;
+	spin_unlock_irqrestore(&sp->lock, flags);
+
+	enable_mouse_interrupts(sp);
+	
+	return 0;
+}
+
+static int remote_event_file_close(struct inode *inode, struct file *file)
+{
+	struct service_processor *sp = file->private_data;
+
+	disable_mouse_interrupts(sp);
+	wake_up_interruptible(&sp->remote_queue.wait);
+	sp->remote_queue.open = 0;
+
+	return 0;
+}
+
+static ssize_t remote_event_file_read(struct file *file, char *buf, size_t count, loff_t *offset)
+{
+	struct service_processor *sp = file->private_data;
+	struct remote_queue *q = &sp->remote_queue;
+	size_t data_size;
+	struct remote_event *reader = q->reader;
+	size_t num_events;
+
+	if (*offset < 0)
+		return -EINVAL;
+	if (count == 0 || count > 1024)
+		return 0;
+	if (*offset != 0)
+		return 0;
+
+	if (wait_event_interruptible(q->wait, q->reader != q->writer))
+		return -ERESTARTSYS;
+
+	/* only get multiples of struct remote_event */
+	num_events = min((count/sizeof(struct remote_event)), ibmasm_events_available(q));
+	if (!num_events)
+		return 0;
+
+	data_size = num_events * sizeof(struct remote_event);
+
+	if (copy_to_user(buf, reader, data_size))
+		return -EFAULT;
+
+	ibmasm_advance_reader(q, num_events);
+
+	return data_size;
+}
+
+
+static struct file_operations command_fops = {
+	.open =		command_file_open,
+	.release =	command_file_close,
+	.read =		command_file_read,
+	.write =	command_file_write,
+};
+
+static struct file_operations event_fops = {
+	.open =		event_file_open,
+	.release =	event_file_close,
+	.read =		event_file_read,
+	.write 		event_file_write,
+};
+
+static struct file_operations r_heartbeat_fops = {
+	.open =		r_heartbeat_file_open,
+	.release =	r_heartbeat_file_close,
+	.read =		r_heartbeat_file_read,
+	.write =	r_heartbeat_file_write,
+};
+
+static struct file_operations remote_settings_fops = {
+	.open =		remote_settings_file_open,
+	.release =	remote_settings_file_close,
+	.read =		remote_settings_file_read,
+	.write =	remote_settings_file_write,
+};
+
+static struct file_operations remote_event_fops = {
+	.open =		remote_event_file_open,
+	.release =	remote_event_file_close,
+	.read =		remote_event_file_read,
+};
+
+
+static void ibmasmfs_create_files (struct super_block *sb, struct dentry *root)
+{
+	struct list_head *entry;
+	struct service_processor *sp;
+
+	list_for_each(entry, &service_processors) {
+		struct dentry *dir;
+		struct dentry *remote_dir;
+		sp = list_entry(entry, struct service_processor, node);
+		dir = ibmasmfs_create_dir(sb, root, sp->dirname);
+		if (!dir)
+			continue;
+
+		ibmasmfs_create_file(sb, dir, "command", &command_fops, sp, S_IRUSR|S_IWUSR);
+		ibmasmfs_create_file(sb, dir, "event", &event_fops, sp, S_IRUSR|S_IWUSR);
+		ibmasmfs_create_file(sb, dir, "reverse_heartbeat", &r_heartbeat_fops, sp, S_IRUSR|S_IWUSR);
+
+		remote_dir = ibmasmfs_create_dir(sb, dir, "remote_video");
+		if (!remote_dir)
+			continue;
+
+		ibmasmfs_create_file(sb, remote_dir, "width", &remote_settings_fops, (void *)display_width(sp), S_IRUSR|S_IWUSR);
+		ibmasmfs_create_file(sb, remote_dir, "height", &remote_settings_fops, (void *)display_height(sp), S_IRUSR|S_IWUSR);
+		ibmasmfs_create_file(sb, remote_dir, "depth", &remote_settings_fops, (void *)display_depth(sp), S_IRUSR|S_IWUSR);
+		ibmasmfs_create_file(sb, remote_dir, "connected", &remote_settings_fops, (void *)vnc_status(sp), S_IRUSR);
+		ibmasmfs_create_file(sb, remote_dir, "events", &remote_event_fops, (void *)sp, S_IRUSR);
+	}
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/lowlevel.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/lowlevel.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/lowlevel.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/lowlevel.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,81 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include "ibmasm.h"
+#include "lowlevel.h"
+#include "i2o.h"
+#include "dot_command.h"
+#include "remote.h"
+
+static struct i2o_header header = I2O_HEADER_TEMPLATE;
+
+
+int ibmasm_send_i2o_message(struct service_processor *sp)
+{
+	u32 mfa;
+	unsigned int command_size;
+	struct i2o_message *message;
+	struct command *command = sp->current_command;
+
+	mfa = get_mfa_inbound(sp->base_address);
+	if (!mfa)
+		return 1;
+
+	command_size = get_dot_command_size(command->buffer);
+	header.message_size = outgoing_message_size(command_size);
+
+	message = get_i2o_message(sp->base_address, mfa);
+
+	memcpy(&message->header, &header, sizeof(struct i2o_header));
+	memcpy(&message->data, command->buffer, command_size);
+
+	set_mfa_inbound(sp->base_address, mfa);
+
+	return 0;
+}
+
+irqreturn_t ibmasm_interrupt_handler(int irq, void * dev_id, struct pt_regs *regs)
+{
+	u32	mfa;
+	struct service_processor *sp = (struct service_processor *)dev_id;
+	void *base_address = sp->base_address;
+
+	if (!sp_interrupt_pending(base_address))
+		return IRQ_NONE;
+
+	if (mouse_interrupt_pending(sp)) {
+		ibmasm_handle_mouse_interrupt(sp);
+		mfa = get_mfa_outbound(base_address);
+		clear_mouse_interrupt(sp);
+		set_mfa_outbound(base_address, mfa);
+		return IRQ_HANDLED;
+	}
+
+	mfa = get_mfa_outbound(base_address);
+	if (valid_mfa(mfa)) {
+		struct i2o_message *msg = get_i2o_message(base_address, mfa);
+		ibmasm_receive_message(sp, &msg->data, incoming_data_size(msg));
+	}
+	set_mfa_outbound(base_address, mfa);
+	return IRQ_HANDLED;
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/lowlevel.h linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/lowlevel.h
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/lowlevel.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/lowlevel.h	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,137 @@
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+/* Condor service processor specific hardware definitions */
+
+#ifndef __IBMASM_CONDOR_H__
+#define __IBMASM_CONDOR_H__
+
+#include <asm/io.h>
+
+#define VENDORID_IBM	0x1014
+#define DEVICEID_RSA	0x010F
+
+#define GET_MFA_ADDR(x)  (x & 0xFFFFFF00)
+
+#define MAILBOX_FULL(x)  (x & 0x00000001)
+
+#define NO_MFAS_AVAILABLE     0xFFFFFFFF
+
+
+#define INBOUND_QUEUE_PORT   0x40  /* contains address of next free MFA */
+#define OUTBOUND_QUEUE_PORT  0x44  /* contains address of posted MFA    */
+
+#define SP_INTR_MASK	0x00000008
+#define UART_INTR_MASK	0x00000010
+
+#define INTR_STATUS_REGISTER   0x13A0
+#define INTR_CONTROL_REGISTER  0x13A4
+
+#define SCOUT_COM_A_BASE         0x0000
+#define SCOUT_COM_B_BASE         0x0100   
+#define SCOUT_COM_C_BASE         0x0200   
+#define SCOUT_COM_D_BASE         0x0300   
+
+static inline int sp_interrupt_pending(void *base_address)
+{
+	return SP_INTR_MASK & readl(base_address + INTR_STATUS_REGISTER);
+}
+
+static inline int uart_interrupt_pending(void *base_address)
+{
+	return UART_INTR_MASK & readl(base_address + INTR_STATUS_REGISTER);
+}
+
+static inline void ibmasm_enable_interrupts(void *base_address, int mask)
+{
+	void *ctrl_reg = base_address + INTR_CONTROL_REGISTER;
+	writel( readl(ctrl_reg) & ~mask, ctrl_reg);
+}
+
+static inline void ibmasm_disable_interrupts(void *base_address, int mask)
+{
+	void *ctrl_reg = base_address + INTR_CONTROL_REGISTER;
+	writel( readl(ctrl_reg) | mask, ctrl_reg);
+}
+
+static inline void enable_sp_interrupts(void *base_address)
+{
+	ibmasm_enable_interrupts(base_address, SP_INTR_MASK);
+}
+
+static inline void disable_sp_interrupts(void *base_address)
+{
+	ibmasm_disable_interrupts(base_address, SP_INTR_MASK);
+}
+
+static inline void enable_uart_interrupts(void *base_address)
+{
+	ibmasm_enable_interrupts(base_address, UART_INTR_MASK); 
+}
+
+static inline void disable_uart_interrupts(void *base_address)
+{
+	ibmasm_disable_interrupts(base_address, UART_INTR_MASK); 
+}
+
+#define valid_mfa(mfa)	( (mfa) != NO_MFAS_AVAILABLE )
+
+static inline u32 get_mfa_outbound(void *base_address)
+{
+	int retry;
+	u32 mfa;
+
+	for (retry=0; retry<=10; retry++) {
+		mfa = readl(base_address + OUTBOUND_QUEUE_PORT);
+		if (valid_mfa(mfa))
+			break;
+	}
+	return mfa;
+}
+
+static inline void set_mfa_outbound(void *base_address, u32 mfa)
+{
+   	writel(mfa, base_address + OUTBOUND_QUEUE_PORT);
+}
+
+static inline u32 get_mfa_inbound(void *base_address)
+{
+	u32 mfa = readl(base_address + INBOUND_QUEUE_PORT);
+
+	if (MAILBOX_FULL(mfa))
+		return 0;
+
+	return mfa;
+}
+
+static inline void set_mfa_inbound(void *base_address, u32 mfa)
+{
+   	writel(mfa, base_address + INBOUND_QUEUE_PORT);
+}
+
+static inline struct i2o_message *get_i2o_message(void *base_address, u32 mfa)
+{
+	return (struct i2o_message *)(GET_MFA_ADDR(mfa) + base_address);
+}
+
+#endif /* __IBMASM_CONDOR_H__ */
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/module.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/module.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/module.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/module.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,210 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ * This driver is based on code originally written by Pete Reynolds 
+ * and others.
+ *
+ */
+
+/*
+ * The ASM device driver does the following things:
+ *
+ * 1) When loaded it sends a message to the service processor,
+ * indicating that an OS is * running. This causes the service processor
+ * to send periodic heartbeats to the OS. 
+ *
+ * 2) Answers the periodic heartbeats sent by the service processor.
+ * Failure to do so would result in system reboot.
+ *
+ * 3) Acts as a pass through for dot commands sent from user applications.
+ * The interface for this is the ibmasmfs file system. 
+ *
+ * 4) Allows user applications to register for event notification. Events
+ * are sent to the driver through interrupts. They can be read from user
+ * space through the ibmasmfs file system.
+ *
+ * 5) Allows user space applications to send heartbeats to the service
+ * processor (aka reverse heartbeats). Again this happens through ibmasmfs.
+ *
+ * 6) Handles remote mouse and keyboard event interrupts and makes them
+ * available to user applications through ibmasmfs.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/init.h>
+#include "ibmasm.h"
+#include "lowlevel.h"
+#include "remote.h"
+
+
+static int __init ibmasm_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int result = -ENOMEM;
+	struct service_processor *sp;
+
+	sp = kmalloc(sizeof(struct service_processor), GFP_KERNEL);
+	if (sp == NULL) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		return result;
+	}
+	memset(sp, 0, sizeof(struct service_processor));
+
+	pci_set_drvdata(pdev, (void *)sp);
+	sp->dev = &pdev->dev;
+	sp->number = pdev->bus->number;
+	snprintf(sp->dirname, IBMASM_NAME_SIZE, "%d", sp->number);
+	snprintf(sp->devname, IBMASM_NAME_SIZE, "%s%d", DRIVER_NAME, sp->number);
+
+	if (ibmasm_event_buffer_init(sp)) {
+		dev_err(sp->dev, "Failed to allocate event buffer\n");
+		goto error_eventbuffer;
+	}
+
+	if (ibmasm_heartbeat_init(sp)) {
+		dev_err(sp->dev, "Failed to allocate heartbeat command\n");
+		goto error_heartbeat;
+	}
+
+	sp->irq = pdev->irq;
+	sp->base_address = ioremap(pci_resource_start(pdev, 0), 
+					pci_resource_len(pdev, 0));
+	if (sp->base_address == 0) {
+		dev_err(sp->dev, "Failed to ioremap pci memory\n");
+		result =  -ENODEV;
+		goto error_ioremap;
+	}
+
+	result = ibmasm_init_remote_queue(sp);
+	if (result) {
+		dev_err(sp->dev, "Failed to initialize remote queue\n");
+		goto error_remote_queue;
+	}
+
+	sp->lock = SPIN_LOCK_UNLOCKED;
+	INIT_LIST_HEAD(&sp->command_queue);
+
+	result = request_irq(sp->irq, ibmasm_interrupt_handler, SA_SHIRQ, sp->devname, (void*)sp);
+	if (result) {
+		dev_err(sp->dev, "Failed to register interrupt handler\n");
+		goto error_request_irq;
+	}
+
+	enable_sp_interrupts(sp->base_address);
+	disable_mouse_interrupts(sp);
+
+	result = ibmasm_send_driver_vpd(sp);
+	if (result) {
+		dev_err(sp->dev, "Failed to send driver VPD to service processor\n");
+		goto error_send_message;
+	}
+	result = ibmasm_send_os_state(sp, SYSTEM_STATE_OS_UP);
+	if (result) {
+		dev_err(sp->dev, "Failed to send OS state to service processor\n");
+		goto error_send_message;
+	}
+	ibmasmfs_add_sp(sp);
+
+	ibmasm_register_uart(sp);
+
+	return 0;
+
+error_send_message:
+	disable_sp_interrupts(sp->base_address);
+	free_irq(sp->irq, (void *)sp);
+error_request_irq:
+	ibmasm_free_remote_queue(sp);
+error_remote_queue:
+	iounmap(sp->base_address);
+error_ioremap:
+	ibmasm_heartbeat_exit(sp);
+error_heartbeat:
+	ibmasm_event_buffer_exit(sp);
+error_eventbuffer:
+	kfree(sp);
+
+	return result;
+}
+
+static void __exit ibmasm_remove_one(struct pci_dev *pdev)
+{
+	struct service_processor *sp = (struct service_processor *)pci_get_drvdata(pdev);
+
+	ibmasm_unregister_uart(sp);
+	ibmasm_send_os_state(sp, SYSTEM_STATE_OS_DOWN);
+	disable_sp_interrupts(sp->base_address);
+	disable_mouse_interrupts(sp);
+	free_irq(sp->irq, (void *)sp);
+	ibmasm_heartbeat_exit(sp);
+	ibmasm_free_remote_queue(sp);
+	iounmap(sp->base_address);
+	ibmasm_event_buffer_exit(sp);
+	kfree(sp);
+}
+
+static struct pci_device_id ibmasm_pci_table[] =
+{
+	{ PCI_DEVICE(VENDORID_IBM, DEVICEID_RSA) },
+	{},
+};
+
+static struct pci_driver ibmasm_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= ibmasm_pci_table,
+	.probe		= ibmasm_init_one,
+	.remove		= __devexit_p(ibmasm_remove_one),
+};
+
+static void __exit ibmasm_exit (void)
+{
+	ibmasm_unregister_panic_notifier();
+	ibmasmfs_unregister();
+	pci_unregister_driver(&ibmasm_driver);
+	info(DRIVER_DESC " version " DRIVER_VERSION " unloaded");
+}
+
+static int __init ibmasm_init(void)
+{
+	int result;
+
+	result = ibmasmfs_register();
+	if (result) {
+		err("Failed to register ibmasmfs file system");
+		return result;
+	}
+	result = pci_register_driver(&ibmasm_driver);
+	if (result <= 0) {
+		pci_unregister_driver(&ibmasm_driver);
+		ibmasmfs_unregister();
+		return -ENODEV;
+	}
+	ibmasm_register_panic_notifier();
+	info(DRIVER_DESC " version " DRIVER_VERSION " loaded");
+	return 0;
+}
+
+module_init(ibmasm_init);
+module_exit(ibmasm_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/r_heartbeat.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/r_heartbeat.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/r_heartbeat.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/r_heartbeat.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,98 @@
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include "ibmasm.h"
+#include "dot_command.h"
+
+/*
+ * Reverse Heartbeat, i.e. heartbeats sent from the driver to the
+ * service processor.
+ * These heartbeats are initiated by user level programs.
+ */
+
+/* the reverse heartbeat dot command */
+#pragma pack(1)
+static struct {
+	struct dot_command_header	header;
+	unsigned char			command[3];
+} rhb_dot_cmd = {
+	.header = {
+		.type = 	sp_read,
+		.command_size = 3,
+		.data_size =	0,
+		.status = 	0
+	},
+	.command = { 4, 3, 6 }
+};
+#pragma pack()
+
+void ibmasm_init_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb)
+{
+	init_waitqueue_head(&rhb->wait);
+	rhb->stopped = 0;
+}
+
+/**
+ * start_reverse_heartbeat
+ * Loop forever, sending a reverse heartbeat dot command to the service
+ * processor, then sleeping. The loop comes to an end if the service
+ * processor fails to respond 3 times or we were interrupted.
+ */
+int ibmasm_start_reverse_heartbeat(struct service_processor *sp, struct reverse_heartbeat *rhb)
+{
+	struct command *cmd;
+	int times_failed = 0;
+	int result = 1;
+
+	cmd = ibmasm_new_command(sizeof rhb_dot_cmd);
+	if (!cmd)
+		return -ENOMEM;
+
+	while (times_failed < 3) {
+		memcpy(cmd->buffer, (void *)&rhb_dot_cmd, sizeof rhb_dot_cmd);
+		cmd->status = IBMASM_CMD_PENDING;
+		ibmasm_exec_command(sp, cmd);
+		ibmasm_wait_for_response(cmd, IBMASM_CMD_TIMEOUT_NORMAL);
+
+		if (cmd->status != IBMASM_CMD_COMPLETE)
+			times_failed++;
+
+		wait_event_interruptible_timeout(rhb->wait, 
+			rhb->stopped,
+			REVERSE_HEARTBEAT_TIMEOUT * HZ); 	
+
+		if (signal_pending(current) || rhb->stopped) {
+			result = -EINTR;
+			break;
+		}
+	}
+	command_put(cmd);
+	rhb->stopped = 0;
+
+	return result;
+}
+
+void ibmasm_stop_reverse_heartbeat(struct reverse_heartbeat *rhb)
+{
+	rhb->stopped = 1;
+	wake_up_interruptible(&rhb->wait);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/remote.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/remote.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/remote.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/remote.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,152 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+/* Remote mouse and keyboard event handling functions */
+
+#include "ibmasm.h"
+#include "remote.h"
+
+int ibmasm_init_remote_queue(struct service_processor *sp)
+{
+	struct remote_queue *q = &sp->remote_queue;
+
+	disable_mouse_interrupts(sp);
+
+	q->open = 0;
+	q->size = 0;
+
+	q->start = kmalloc(DRIVER_REMOTE_QUEUE_SIZE * sizeof(struct remote_event), GFP_KERNEL);
+        if (q->start == 0)
+                return -ENOMEM;
+
+	q->end = q->start + DRIVER_REMOTE_QUEUE_SIZE;
+	q->reader = q->start;
+	q->writer = q->start;
+	q->size = DRIVER_REMOTE_QUEUE_SIZE;
+	init_waitqueue_head(&q->wait);
+
+	return 0;
+}
+
+void ibmasm_free_remote_queue(struct service_processor *sp)
+{
+	kfree(sp->remote_queue.start);
+}
+
+void ibmasm_advance_reader(struct remote_queue *q, unsigned int n)
+{
+	q->reader += n;
+	if (q->reader >= q->end)
+		q->reader -= q->size;
+}
+
+size_t ibmasm_events_available(struct remote_queue *q)
+{
+	ssize_t diff = q->writer - q->reader;
+ 
+	return (diff >= 0) ? diff : q->end - q->reader;	
+}
+	
+
+static int space_free(struct remote_queue *q)
+{
+	if (q->reader == q->writer)
+		return q->size - 1;
+
+	return ( (q->reader + q->size - q->writer) % q->size ) - 1;
+}
+
+static void set_mouse_event(struct remote_input *input, struct mouse_event *mouse)
+{
+	static char last_buttons = 0;
+
+	mouse->x = input->data.mouse.x;
+	mouse->y = input->data.mouse.y;
+
+	if (input->mouse_buttons == REMOTE_MOUSE_DOUBLE_CLICK) {
+		mouse->buttons = REMOTE_MOUSE_DOUBLE_CLICK;
+		last_buttons = 0;
+		return;
+	}
+	mouse->transitions = last_buttons ^ input->mouse_buttons;
+	mouse->buttons = input->mouse_buttons;
+
+	last_buttons = input->mouse_buttons;
+}
+
+static void set_keyboard_event(struct remote_input *input, struct keyboard_event *keyboard)
+{
+	keyboard->key_code = input->data.keyboard.key_code;
+	keyboard->key_down = input->data.keyboard.key_down;
+}
+
+static int add_to_driver_queue(struct remote_queue *q, struct remote_input *input)
+{
+	struct remote_event *event = q->writer;
+
+	if (space_free(q) < 1) {
+		return 1;
+	}
+
+	switch(input->type) {
+	case (INPUT_TYPE_MOUSE):
+		event->type = INPUT_TYPE_MOUSE;
+		set_mouse_event(input, &event->data.mouse);
+		break;
+	case (INPUT_TYPE_KEYBOARD):
+		event->type = INPUT_TYPE_KEYBOARD;
+		set_keyboard_event(input, &event->data.keyboard);
+		break;
+	default:
+		return 0;
+	}
+	event->type = input->type;
+
+	q->writer++;
+	if (q->writer == q->end)
+		q->writer = q->start;
+
+	return 0;
+}
+	
+
+void ibmasm_handle_mouse_interrupt(struct service_processor *sp)
+{
+	unsigned long reader;
+	unsigned long writer;
+	struct remote_input input;
+
+	reader = get_queue_reader(sp);
+	writer = get_queue_writer(sp);
+
+	while (reader != writer) {
+		memcpy(&input, (void *)get_queue_entry(sp, reader), sizeof(struct remote_input));
+
+		if (add_to_driver_queue(&sp->remote_queue, &input))
+			break;
+
+		reader = advance_queue_reader(sp, reader);
+	}
+	wake_up_interruptible(&sp->remote_queue.wait);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/remote.h linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/remote.h
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/remote.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/remote.h	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,119 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ * Orignally written by Pete Reynolds
+ */
+
+#ifndef _IBMASM_REMOTE_H_
+#define _IBMASM_REMOTE_H_
+
+#include <asm/io.h>
+
+/* pci offsets */
+#define CONDOR_MOUSE_DATA		0x000AC000
+#define CONDOR_MOUSE_ISR_CONTROL	0x00
+#define CONDOR_MOUSE_ISR_STATUS		0x04
+#define CONDOR_MOUSE_Q_READER		0x08
+#define CONDOR_MOUSE_Q_WRITER		0x0C
+#define CONDOR_MOUSE_Q_BEGIN		0x10
+#define CONDOR_MOUSE_MAX_X		0x14
+#define CONDOR_MOUSE_MAX_Y		0x18
+
+#define CONDOR_INPUT_DESKTOP_INFO	0x1F0
+#define CONDOR_INPUT_DISPLAY_RESX	0x1F4
+#define CONDOR_INPUT_DISPLAY_RESY	0x1F8
+#define CONDOR_INPUT_DISPLAY_BITS	0x1FC
+#define CONDOR_OUTPUT_VNC_STATUS	0x200
+
+#define CONDOR_MOUSE_INTR_STATUS_MASK	0x00000001
+
+#define INPUT_TYPE_MOUSE	0x1
+#define INPUT_TYPE_KEYBOARD	0x2
+
+
+/* mouse button states received from SP */
+#define REMOTE_MOUSE_DOUBLE_CLICK	0xF0
+#define REMOTE_MOUSE_BUTTON_LEFT	0x01
+#define REMOTE_MOUSE_BUTTON_MIDDLE	0x02
+#define REMOTE_MOUSE_BUTTON_RIGHT	0x04
+
+
+struct mouse_input {
+	unsigned short	y;
+	unsigned short	x;
+};
+
+
+struct keyboard_input {
+	unsigned short	key_code;
+	unsigned char	key_flag;
+	unsigned char	key_down;
+};
+
+
+
+struct remote_input { 
+	union {
+		struct mouse_input	mouse;
+		struct keyboard_input	keyboard;
+	} data;
+
+	unsigned char	type;
+	unsigned char	pad1;
+	unsigned char	mouse_buttons;
+	unsigned char	pad3;
+};
+
+#define mouse_addr(sp) 		sp->base_address + CONDOR_MOUSE_DATA
+#define display_width(sp)	mouse_addr(sp) + CONDOR_INPUT_DISPLAY_RESX
+#define display_height(sp)	mouse_addr(sp) + CONDOR_INPUT_DISPLAY_RESY
+#define display_depth(sp)	mouse_addr(sp) + CONDOR_INPUT_DISPLAY_BITS
+#define vnc_status(sp)		mouse_addr(sp) + CONDOR_OUTPUT_VNC_STATUS
+
+#define mouse_interrupt_pending(sp) 	readl(mouse_addr(sp) + CONDOR_MOUSE_ISR_STATUS)
+#define clear_mouse_interrupt(sp)	writel(0, mouse_addr(sp) + CONDOR_MOUSE_ISR_STATUS)
+#define enable_mouse_interrupts(sp)	writel(1, mouse_addr(sp) + CONDOR_MOUSE_ISR_CONTROL)
+#define disable_mouse_interrupts(sp)	writel(0, mouse_addr(sp) + CONDOR_MOUSE_ISR_CONTROL)
+
+/* remote input queue operations */
+#define REMOTE_QUEUE_SIZE	60
+
+#define get_queue_writer(sp)	readl(mouse_addr(sp) + CONDOR_MOUSE_Q_WRITER)
+#define get_queue_reader(sp)	readl(mouse_addr(sp) + CONDOR_MOUSE_Q_READER)
+#define set_queue_reader(sp, reader)	writel(reader, mouse_addr(sp) + CONDOR_MOUSE_Q_READER)
+
+#define queue_begin	mouse_addr(sp) + CONDOR_MOUSE_Q_BEGIN
+
+#define get_queue_entry(sp, read_index) \
+	queue_begin + read_index * sizeof(struct remote_input)
+
+static inline int advance_queue_reader(struct service_processor *sp, unsigned long reader)
+{
+	reader++;
+	if (reader == REMOTE_QUEUE_SIZE)
+		reader = 0;
+
+	set_queue_reader(sp, reader);
+	return reader;
+}
+
+#endif /* _IBMASM_REMOTE_H_ */
diff -purN linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/uart.c linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/uart.c
--- linux-post-2.6.4rc1-20040302/drivers/misc/ibmasm/uart.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/misc/ibmasm/uart.c	2004-02-25 21:24:20.000000000 +0000
@@ -0,0 +1,72 @@
+
+/*
+ * IBM ASM Service Processor Device Driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2004
+ *
+ * Author: Max Asböck <amax@us.ibm.com> 
+ *
+ */
+
+#include <linux/termios.h>
+#include <linux/tty.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_reg.h>
+#include "ibmasm.h"
+#include "lowlevel.h"
+
+
+void ibmasm_register_uart(struct service_processor *sp)
+{
+	struct serial_struct serial;
+	unsigned char *iomem_base;
+
+	iomem_base = sp->base_address + SCOUT_COM_B_BASE;
+
+	/* read the uart scratch register to determine if the UART
+	 * is dedicated to the service processor or if the OS can use it
+	 */
+	if (0 == readl(iomem_base + UART_SCR)) {
+		dev_info(sp->dev, "IBM SP UART not registered, owned by service processor\n");
+		sp->serial_line = -1;
+		return;
+	}
+
+	memset(&serial, 0, sizeof(serial));
+	serial.irq		= sp->irq;
+	serial.baud_base	= 3686400 / 16;
+	serial.flags		= UPF_AUTOPROBE | UPF_SHARE_IRQ;
+	serial.io_type		= UPIO_MEM;
+	serial.iomem_base	= iomem_base;
+
+	sp->serial_line = register_serial(&serial);
+	if (sp->serial_line < 0) {
+		dev_err(sp->dev, "Failed to register serial port\n");
+		return;
+	}
+	enable_uart_interrupts(sp->base_address);
+}
+
+void ibmasm_unregister_uart(struct service_processor *sp)
+{
+	if (sp->serial_line < 0)
+		return;
+
+	disable_uart_interrupts(sp->base_address);
+	unregister_serial(sp->serial_line);
+}
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/Kconfig linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/Kconfig
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/Kconfig	2004-02-28 01:22:51.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/Kconfig	2004-03-03 03:27:39.000000000 +0000
@@ -135,23 +135,14 @@ config HOTPLUG_PCI_PCIE
 	  When in doubt, say N.
 
 config HOTPLUG_PCI_PCIE_POLL_EVENT_MODE
-	bool "Use polling mechanism for hot-plug events."
+	bool "Use polling mechanism for hot-plug events (for testing purpose)"
 	depends on HOTPLUG_PCI_PCIE
 	help
 	  Say Y here if you want to use the polling mechanism for hot-plug 
-	  events.
+	  events for early platform testing.
 	   
 	  When in doubt, say N.
 
-config HOTPLUG_PCI_PCIE_PHPRM_NONACPI
-	bool "Non-ACPI: Use $HPRT for resource/configuration"
-	depends on HOTPLUG_PCI_PCIE
-	help
-	  Say Y here if Hotplug resource/configuration information is provided
-	  by platform BIOS $HPRT or bridge resource information, not by ACPI.
-
-	  When in doubt, say N.
-
 config HOTPLUG_PCI_SHPC
 	tristate "SHPC PCI Hotplug driver"
 	depends on HOTPLUG_PCI
@@ -165,29 +156,20 @@ config HOTPLUG_PCI_SHPC
 	  When in doubt, say N.
 
 config HOTPLUG_PCI_SHPC_POLL_EVENT_MODE
-	bool "Use polling mechanism for hot-plug events"
+	bool "Use polling mechanism for hot-plug events (for testing purpose)"
 	depends on HOTPLUG_PCI_SHPC
 	help
 	  Say Y here if you want to use the polling mechanism for hot-plug 
-	  events.
-
-	  When in doubt, say N.
-
-config HOTPLUG_PCI_SHPC_PHPRM_NONACPI
-	bool "Non-ACPI: Use $HPRT for resource/configuration"
-	depends on HOTPLUG_PCI_SHPC
-	help
-	  Say Y here if Hotplug resource/configuration information is provided
-	  by platform BIOS $HPRT or bridge resource information, not by ACPI.
+	  events for early platform testing.
 
 	  When in doubt, say N.
 
 config HOTPLUG_PCI_SHPC_PHPRM_LEGACY
 	bool "For AMD SHPC only: Use $HRT for resource/configuration"
-	depends on HOTPLUG_PCI_SHPC && HOTPLUG_PCI_SHPC_PHPRM_NONACPI
+	depends on HOTPLUG_PCI_SHPC && !ACPI_BUS 
 	help
 	  Say Y here for AMD SHPC. You have to select this option if you are 
-	  using this driver on AMD platform with SHPC.
+	  using this driver on platform with AMD SHPC.
 
 config HOTPLUG_PCI_RPA
 	tristate "RPA PCI Hotplug driver"
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/Makefile linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/Makefile
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/Makefile	2004-02-24 14:04:19.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/Makefile	2004-03-03 03:25:25.000000000 +0000
@@ -50,11 +50,10 @@ pciehp-objs		:=	pciehp_core.o	\
 				pciehp_pci.o	\
 				pciehp_sysfs.o	\
 				pciehp_hpc.o
-
-ifeq ($(CONFIG_HOTPLUG_PCI_PCIE_PHPRM_NONACPI),y)
-  pciehp-objs += pciehprm_nonacpi.o
+ifdef CONFIG_ACPI_BUS
+	pciehp-objs += pciehprm_acpi.o
 else
-  pciehp-objs += pciehprm_acpi.o
+	pciehp-objs += pciehprm_nonacpi.o
 endif
 
 shpchp-objs		:=	shpchp_core.o	\
@@ -62,13 +61,12 @@ shpchp-objs		:=	shpchp_core.o	\
 				shpchp_pci.o	\
 				shpchp_sysfs.o	\
 				shpchp_hpc.o
-
-ifeq ($(CONFIG_HOTPLUG_PCI_SHPC_PHPRM_LEGACY),y)
-  shpchp-objs += shpchprm_legacy.o
+ifdef CONFIG_ACPI_BUS
+	shpchp-objs += shpchprm_acpi.o
 else
-  ifeq ($(CONFIG_HOTPLUG_PCI_SHPC_PHPRM_NONACPI),y)
-    shpchp-objs += shpchprm_nonacpi.o
-  else
-    shpchp-objs += shpchprm_acpi.o
-  endif
+	ifdef CONFIG_HOTPLUG_PCI_SHPC_PHPRM_LEGACY
+		shpchp-objs += shpchprm_legacy.o
+	else
+		shpchp-objs += shpchprm_nonacpi.o
+	endif
 endif
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp.h linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp.h
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp.h	2003-09-21 21:10:32.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp.h	2004-06-12 14:12:50.000000000 +0000
@@ -444,6 +444,7 @@ extern struct slot *cpqhp_find_slot		(st
 
 /* Global variables */
 extern int cpqhp_debug;
+extern int cpqhp_legacy_mode;
 extern struct controller *cpqhp_ctrl_list;
 extern struct pci_func *cpqhp_slot_list[256];
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_core.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_core.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_core.c	2003-08-27 14:44:50.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_core.c	2004-06-12 14:41:14.000000000 +0000
@@ -49,6 +49,7 @@
 
 /* Global variables */
 int cpqhp_debug;
+int cpqhp_legacy_mode;
 struct controller *cpqhp_ctrl_list;	/* = NULL */
 struct pci_func *cpqhp_slot_list[256];
 
@@ -1169,6 +1170,10 @@ static int cpqhpc_probe(struct pci_dev *
 	 */
 	// The next line is required for cpqhp_find_available_resources
 	ctrl->interrupt = pdev->irq;
+	if (ctrl->interrupt < 0x10) {
+		cpqhp_legacy_mode = 1;
+		dbg("System seems to be configured for Full Table Mapped MPS mode\n");
+	}
 
 	ctrl->cfgspc_irq = 0;
 	pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ctrl->cfgspc_irq);
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_ctrl.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_ctrl.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_ctrl.c	2003-09-15 21:37:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_ctrl.c	2004-06-12 14:12:49.000000000 +0000
@@ -3020,33 +3020,34 @@ static int configure_new_function (struc
 				}
 			}
 		}		// End of base register loop
-
-#if !defined(CONFIG_X86_IO_APIC)
-		// Figure out which interrupt pin this function uses
-		rc = pci_bus_read_config_byte (pci_bus, devfn, PCI_INTERRUPT_PIN, &temp_byte);
-
-		// If this function needs an interrupt and we are behind a bridge
-		// and the pin is tied to something that's alread mapped,
-		// set this one the same
-		if (temp_byte && resources->irqs && 
-		    (resources->irqs->valid_INT & 
-		     (0x01 << ((temp_byte + resources->irqs->barber_pole - 1) & 0x03)))) {
-			// We have to share with something already set up
-			IRQ = resources->irqs->interrupt[(temp_byte + resources->irqs->barber_pole - 1) & 0x03];
-		} else {
-			// Program IRQ based on card type
-			rc = pci_bus_read_config_byte (pci_bus, devfn, 0x0B, &class_code);
-
-			if (class_code == PCI_BASE_CLASS_STORAGE) {
-				IRQ = cpqhp_disk_irq;
+		if (cpqhp_legacy_mode) {
+			// Figure out which interrupt pin this function uses
+			rc = pci_bus_read_config_byte (pci_bus, devfn, 
+				PCI_INTERRUPT_PIN, &temp_byte);
+
+			// If this function needs an interrupt and we are behind a bridge
+			// and the pin is tied to something that's alread mapped,
+			// set this one the same
+			if (temp_byte && resources->irqs && 
+			    (resources->irqs->valid_INT & 
+			     (0x01 << ((temp_byte + resources->irqs->barber_pole - 1) & 0x03)))) {
+				// We have to share with something already set up
+				IRQ = resources->irqs->interrupt[(temp_byte + 
+					resources->irqs->barber_pole - 1) & 0x03];
 			} else {
-				IRQ = cpqhp_nic_irq;
+				// Program IRQ based on card type
+				rc = pci_bus_read_config_byte (pci_bus, devfn, 0x0B, &class_code);
+
+				if (class_code == PCI_BASE_CLASS_STORAGE) {
+					IRQ = cpqhp_disk_irq;
+				} else {
+					IRQ = cpqhp_nic_irq;
+				}
 			}
-		}
 
-		// IRQ Line
-		rc = pci_bus_write_config_byte (pci_bus, devfn, PCI_INTERRUPT_LINE, IRQ);
-#endif
+			// IRQ Line
+			rc = pci_bus_write_config_byte (pci_bus, devfn, PCI_INTERRUPT_LINE, IRQ);
+		}
 
 		if (!behind_bridge) {
 			rc = cpqhp_set_irq(func->bus, func->device, temp_byte + 0x09, IRQ);
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_pci.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_pci.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/cpqphp_pci.c	2003-09-15 21:38:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/cpqphp_pci.c	2004-06-12 14:12:50.000000000 +0000
@@ -151,32 +151,32 @@ static int PCI_RefinedAccessConfig(struc
  */
 int cpqhp_set_irq (u8 bus_num, u8 dev_num, u8 int_pin, u8 irq_num)
 {
-#if !defined(CONFIG_X86_IO_APIC)	
 	int rc;
 	u16 temp_word;
 	struct pci_dev fakedev;
 	struct pci_bus fakebus;
 
-	fakedev.devfn = dev_num << 3;
-	fakedev.bus = &fakebus;
-	fakebus.number = bus_num;
-	dbg("%s: dev %d, bus %d, pin %d, num %d\n",
-	    __FUNCTION__, dev_num, bus_num, int_pin, irq_num);
-	rc = pcibios_set_irq_routing(&fakedev, int_pin - 0x0a, irq_num);
-	dbg("%s: rc %d\n", __FUNCTION__, rc);
-	if (!rc)
-		return !rc;
-
-	// set the Edge Level Control Register (ELCR)
-	temp_word = inb(0x4d0);
-	temp_word |= inb(0x4d1) << 8;
-
-	temp_word |= 0x01 << irq_num;
-
-	// This should only be for x86 as it sets the Edge Level Control Register
-	outb((u8) (temp_word & 0xFF), 0x4d0);
-	outb((u8) ((temp_word & 0xFF00) >> 8), 0x4d1);
-#endif
+	if (cpqhp_legacy_mode) {
+		fakedev.devfn = dev_num << 3;
+		fakedev.bus = &fakebus;
+		fakebus.number = bus_num;
+		dbg("%s: dev %d, bus %d, pin %d, num %d\n",
+		    __FUNCTION__, dev_num, bus_num, int_pin, irq_num);
+		rc = pcibios_set_irq_routing(&fakedev, int_pin - 0x0a, irq_num);
+		dbg("%s: rc %d\n", __FUNCTION__, rc);
+		if (!rc)
+			return !rc;
+
+		// set the Edge Level Control Register (ELCR)
+		temp_word = inb(0x4d0);
+		temp_word |= inb(0x4d1) << 8;
+
+		temp_word |= 0x01 << irq_num;
+
+		// This should only be for x86 as it sets the Edge Level Control Register
+		outb((u8) (temp_word & 0xFF), 0x4d0);
+		outb((u8) ((temp_word & 0xFF00) >> 8), 0x4d1);
+	}
 
 	return 0;
 }
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/pci_hotplug_core.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/pci_hotplug_core.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/pci_hotplug_core.c	2004-02-02 22:50:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/pci_hotplug_core.c	2004-03-02 13:10:39.000000000 +0000
@@ -104,8 +104,19 @@ static struct kobj_type hotplug_slot_kty
 	.release = &hotplug_slot_release,
 };
 
-decl_subsys(pci_hotplug_slots, &hotplug_slot_ktype, NULL);
-
+/* 
+ * We create a struct subsystem on our own and not use decl_subsys so
+ * we can have a sane name "slots" in sysfs, yet still keep a good
+ * global variable name "pci_hotplug_slots_subsys.
+ * If the decl_subsys() #define ever changes, this declaration will
+ * need to be update to make sure everything is initialized properly.
+ */
+struct subsystem pci_hotplug_slots_subsys = {
+	.kset = {
+		.kobj = { .name = "slots" },
+		.ktype = &hotplug_slot_ktype,
+	}
+};
 
 /* these strings match up with the values in pci_bus_speed */
 static char *pci_bus_speed_strings[] = {
@@ -281,7 +292,7 @@ exit:
 }
 
 static struct hotplug_slot_attribute hotplug_slot_attr_latch = {
-	.attr = {.name = "latch", .mode = S_IFREG | S_IRUGO | S_IWUSR},
+	.attr = {.name = "latch", .mode = S_IFREG | S_IRUGO},
 	.show = latch_read_file,
 };
 
@@ -300,7 +311,7 @@ exit:
 }
 
 static struct hotplug_slot_attribute hotplug_slot_attr_presence = {
-	.attr = {.name = "adapter", .mode = S_IFREG | S_IRUGO | S_IWUSR},
+	.attr = {.name = "adapter", .mode = S_IFREG | S_IRUGO},
 	.show = presence_read_file,
 };
 
@@ -350,7 +361,7 @@ exit:
 }
 
 static struct hotplug_slot_attribute hotplug_slot_attr_max_bus_speed = {
-	.attr = {.name = "max_bus_speed", .mode = S_IFREG | S_IRUGO | S_IWUSR},
+	.attr = {.name = "max_bus_speed", .mode = S_IFREG | S_IRUGO},
 	.show = max_bus_speed_read_file,
 };
 
@@ -376,7 +387,7 @@ exit:
 }
 
 static struct hotplug_slot_attribute hotplug_slot_attr_cur_bus_speed = {
-	.attr = {.name = "cur_bus_speed", .mode = S_IFREG | S_IRUGO | S_IWUSR},
+	.attr = {.name = "cur_bus_speed", .mode = S_IFREG | S_IRUGO},
 	.show = cur_bus_speed_read_file,
 };
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/pciehprm_acpi.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/pciehprm_acpi.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/pciehprm_acpi.c	2004-02-02 22:50:05.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/pciehprm_acpi.c	2004-03-03 00:59:50.000000000 +0000
@@ -1188,6 +1188,9 @@ static void free_a_bridge( struct acpi_b
 
 static void pciehprm_free_bridges ( struct acpi_bridge	*ab)
 {
+	if (!ab)
+		return;
+
 	if (ab->child)
 		pciehprm_free_bridges (ab->child);
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/shpchp.h linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/shpchp.h
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/shpchp.h	2004-02-23 22:53:13.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/shpchp.h	2004-03-03 01:26:43.000000000 +0000
@@ -154,9 +154,6 @@ struct resource_lists {
 /* Define AMD SHPC ID  */
 #define PCI_DEVICE_ID_AMD_GOLAM_7450	0x7450 
 
-/* Define SHPC CAP ID - not defined in kernel yet */
-#define PCI_CAP_ID_SHPC			0x0C 
-
 #define INT_BUTTON_IGNORE		0
 #define INT_PRESENCE_ON			1
 #define INT_PRESENCE_OFF		2
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/shpchprm_acpi.c linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/shpchprm_acpi.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/hotplug/shpchprm_acpi.c	2004-02-02 22:50:07.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/hotplug/shpchprm_acpi.c	2004-03-03 00:59:24.000000000 +0000
@@ -1187,6 +1187,9 @@ static void free_a_bridge( struct acpi_b
 
 static void shpchprm_free_bridges ( struct acpi_bridge	*ab)
 {
+	if (!ab)
+		return;
+
 	if (ab->child)
 		shpchprm_free_bridges (ab->child);
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/pci/quirks.c linux-post-2.6.4rc1-20040303/drivers/pci/quirks.c
--- linux-post-2.6.4rc1-20040302/drivers/pci/quirks.c	2004-02-27 03:35:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/pci/quirks.c	2004-03-03 05:15:53.000000000 +0000
@@ -826,7 +826,7 @@ static void __init quirk_intel_ide_combi
 	case 0x24df:
 	case 0x25a3:
 	case 0x25b0:
-	case 0x2562:
+	case 0x2652:
 		break;
 	default:
 		/* we do not handle this PCI device */
diff -purN linux-post-2.6.4rc1-20040302/drivers/s390/block/xpram.c linux-post-2.6.4rc1-20040303/drivers/s390/block/xpram.c
--- linux-post-2.6.4rc1-20040302/drivers/s390/block/xpram.c	2004-03-02 03:01:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/s390/block/xpram.c	2004-03-03 03:06:19.000000000 +0000
@@ -493,7 +493,7 @@ static void __exit xpram_exit(void)
 	}
 	unregister_blkdev(XPRAM_MAJOR, XPRAM_NAME);
 	devfs_remove("slram");
-	sys_device_unregister(&xpram_sys_device);
+	sysdev_unregister(&xpram_sys_device);
 	sysdev_class_unregister(&xpram_sysclass);
 }
 
@@ -516,14 +516,14 @@ static int __init xpram_init(void)
 	if (rc)
 		return rc;
 
-	rc = sys_device_register(&xpram_sys_device);
+	rc = sysdev_register(&xpram_sys_device);
 	if (rc) {
 		sysdev_class_unregister(&xpram_sysclass);
 		return rc;
 	}
 	rc = xpram_setup_blkdev();
 	if (rc)
-		sys_device_unregister(&xpram_sys_device);
+		sysdev_unregister(&xpram_sys_device);
 	return rc;
 }
 
diff -purN linux-post-2.6.4rc1-20040302/drivers/scsi/ata_piix.c linux-post-2.6.4rc1-20040303/drivers/scsi/ata_piix.c
--- linux-post-2.6.4rc1-20040302/drivers/scsi/ata_piix.c	2004-02-27 03:35:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/scsi/ata_piix.c	2004-03-03 05:15:53.000000000 +0000
@@ -80,7 +80,7 @@ static struct pci_device_id piix_pci_tbl
 	 * and enhanced mode, with queueing and other fancy stuff.
 	 * This is distinguished by PCI class code.
 	 */
-	{ 0x8086, 0x2562, PCI_ANY_ID, PCI_ANY_ID,
+	{ 0x8086, 0x2652, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_IDE << 8, 0xffff00, ich5_sata },
 
 	{ }	/* terminate list */
diff -purN linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-hcd.c linux-post-2.6.4rc1-20040303/drivers/usb/host/ohci-hcd.c
--- linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-hcd.c	2004-02-11 11:42:39.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/usb/host/ohci-hcd.c	2004-03-02 13:52:40.000000000 +0000
@@ -229,11 +229,21 @@ static int ohci_urb_enqueue (
 		goto fail;
 	}
 
+	/* in case of unlink-during-submit */
+	spin_lock (&urb->lock);
+	if (urb->status != -EINPROGRESS) {
+		spin_unlock (&urb->lock);
+
+		finish_urb (ohci, urb, 0);
+		retval = 0;
+		goto fail;
+	}
+
 	/* schedule the ed if needed */
 	if (ed->state == ED_IDLE) {
 		retval = ed_schedule (ohci, ed);
 		if (retval < 0)
-			goto fail;
+			goto fail0;
 		if (ed->type == PIPE_ISOCHRONOUS) {
 			u16	frame = OHCI_FRAME_NO(ohci->hcca);
 
@@ -257,6 +267,8 @@ static int ohci_urb_enqueue (
 	urb->hcpriv = urb_priv;
 	td_submit_urb (ohci, urb);
 
+fail0:
+	spin_unlock (&urb->lock);
 fail:
 	if (retval)
 		urb_free_priv (ohci, urb_priv);
diff -purN linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-q.c linux-post-2.6.4rc1-20040303/drivers/usb/host/ohci-q.c
--- linux-post-2.6.4rc1-20040302/drivers/usb/host/ohci-q.c	2004-02-11 11:42:39.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/drivers/usb/host/ohci-q.c	2004-03-02 13:52:46.000000000 +0000
@@ -331,19 +331,6 @@ static void ed_deschedule (struct ohci_h
 		periodic_unlink (ohci, ed);
 		break;
 	}
-
-	/* NOTE: Except for a couple of exceptionally clean unlink cases
-	 * (like unlinking the only c/b ED, with no TDs) HCs may still be
-	 * caching this operational ED (or its address).  Safe unlinking
-	 * involves not marking it ED_IDLE till INTR_SF; we always do that
-	 * if td_list isn't empty.  Otherwise the race is small; but ...
-	 */
-	if (ed->state == ED_OPER) {
-		ed->state = ED_IDLE;
-		ed->hwINFO &= ~(ED_SKIP | ED_DEQUEUE);
-		ed->hwHeadP &= ~ED_H;
-		wmb ();
-	}
 }
 
 
@@ -665,6 +652,7 @@ static void td_submit_urb (
 
 	/* start periodic dma if needed */
 	if (periodic) {
+		wmb ();
 		ohci->hc_control |= OHCI_CTRL_PLE|OHCI_CTRL_IE;
 		writel (ohci->hc_control, &ohci->regs->control);
 	}
@@ -1053,7 +1041,7 @@ dl_done_list (struct ohci_hcd *ohci, str
 
 		/* clean schedule:  unlink EDs that are no longer busy */
 		if (list_empty (&ed->td_list))
-			ed_deschedule (ohci, ed);
+			start_ed_unlink (ohci, ed);
 		/* ... reenabling halted EDs only after fault cleanup */
 		else if ((ed->hwINFO & (ED_SKIP | ED_DEQUEUE)) == ED_SKIP) {
 			td = list_entry (ed->td_list.next, struct td, td_list);
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/Makefile linux-post-2.6.4rc1-20040303/fs/xfs/Makefile
--- linux-post-2.6.4rc1-20040302/fs/xfs/Makefile	2004-01-30 03:07:39.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/Makefile	2004-03-03 04:52:57.000000000 +0000
@@ -54,10 +54,6 @@ endif
 
 obj-$(CONFIG_XFS_FS)		+= xfs.o
 
-ifneq ($(CONFIG_XFS_DMAPI),y)
-xfs-y				+= xfs_dmops.o
-endif
-
 xfs-$(CONFIG_XFS_QUOTA)		+= $(addprefix quota/, \
 				   xfs_dquot.o \
 				   xfs_dquot_item.o \
@@ -67,8 +63,6 @@ xfs-$(CONFIG_XFS_QUOTA)		+= $(addprefix 
 				   xfs_qm.o)
 ifeq ($(CONFIG_XFS_QUOTA),y)
 xfs-$(CONFIG_PROC_FS)		+= quota/xfs_qm_stats.o
-else
-xfs-y				+= xfs_qmops.o
 endif
 
 xfs-$(CONFIG_XFS_RT)		+= xfs_rtalloc.o
@@ -124,13 +118,14 @@ xfs-y				+= xfs_alloc.o \
 				   xfs_utils.o \
 				   xfs_vfsops.o \
 				   xfs_vnodeops.o \
-				   xfs_rw.o
+				   xfs_rw.o \
+				   xfs_dmops.o \
+				   xfs_qmops.o
 
 xfs-$(CONFIG_XFS_TRACE)		+= xfs_dir2_trace.o
 
 # Objects in linux/
 xfs-y				+= $(addprefix linux/, \
-				   mrlock.o \
 				   xfs_aops.o \
 				   xfs_buf.o \
 				   xfs_file.o \
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/mrlock.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/mrlock.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/mrlock.c	2004-01-30 02:12:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/mrlock.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,274 +0,0 @@
-/*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it would be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * Further, this software is distributed without any warranty that it is
- * free of the rightful claim of any third person regarding infringement
- * or the like.  Any license provided herein, whether implied or
- * otherwise, applies only to this software file.  Patent licenses, if
- * any, provided herein do not apply to combinations of this program with
- * other software, or any other product whatsoever.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write the Free Software Foundation, Inc., 59
- * Temple Place - Suite 330, Boston MA 02111-1307, USA.
- *
- * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
- * Mountain View, CA  94043, or:
- *
- * http://www.sgi.com
- *
- * For further information regarding this notice, see:
- *
- * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/
- */
-
-#include <linux/time.h>
-#include <linux/sched.h>
-#include <asm/system.h>
-#include <linux/interrupt.h>
-#include <asm/current.h>
-
-#include "mrlock.h"
-
-
-#if USE_RW_WAIT_QUEUE_SPINLOCK
-# define wq_write_lock	write_lock
-#else
-# define wq_write_lock	spin_lock
-#endif
-
-/*
- * We don't seem to need lock_type (only one supported), name, or
- * sequence. But, XFS will pass it so let's leave them here for now.
- */
-/* ARGSUSED */
-void
-mrlock_init(mrlock_t *mrp, int lock_type, char *name, long sequence)
-{
-	mrp->mr_count = 0;
-	mrp->mr_reads_waiting = 0;
-	mrp->mr_writes_waiting = 0;
-	init_waitqueue_head(&mrp->mr_readerq);
-	init_waitqueue_head(&mrp->mr_writerq);
-	mrp->mr_lock = SPIN_LOCK_UNLOCKED;
-}
-
-/*
- * Macros to lock/unlock the mrlock_t.
- */
-
-#define MRLOCK(m)		spin_lock(&(m)->mr_lock);
-#define MRUNLOCK(m)		spin_unlock(&(m)->mr_lock);
-
-
-/*
- * lock_wait should never be called in an interrupt thread.
- *
- * mrlocks can sleep (i.e. call schedule) and so they can't ever
- * be called from an interrupt thread.
- *
- * threads that wake-up should also never be invoked from interrupt threads.
- *
- * But, waitqueue_lock is locked from interrupt threads - and we are
- * called with interrupts disabled, so it is all OK.
- */
-
-/* ARGSUSED */
-void
-lock_wait(wait_queue_head_t *q, spinlock_t *lock, int rw)
-{
-	DECLARE_WAITQUEUE( wait, current );
-
-	__set_current_state(TASK_UNINTERRUPTIBLE);
-
-	spin_lock(&q->lock);
-	if (rw) {
-		__add_wait_queue_tail(q, &wait);
-	} else {
-		__add_wait_queue(q, &wait);
-	}
-
-	spin_unlock(&q->lock);
-	spin_unlock(lock);
-
-	schedule();
-
-	spin_lock(&q->lock);
-	__remove_wait_queue(q, &wait);
-	spin_unlock(&q->lock);
-
-	spin_lock(lock);
-
-	/* return with lock held */
-}
-
-/* ARGSUSED */
-void
-mrfree(mrlock_t *mrp)
-{
-}
-
-/* ARGSUSED */
-void
-mrlock(mrlock_t *mrp, int type, int flags)
-{
-	if (type == MR_ACCESS)
-		mraccess(mrp);
-	else
-		mrupdate(mrp);
-}
-
-/* ARGSUSED */
-void
-mraccessf(mrlock_t *mrp, int flags)
-{
-	MRLOCK(mrp);
-	if(mrp->mr_writes_waiting > 0) {
-		mrp->mr_reads_waiting++;
-		lock_wait(&mrp->mr_readerq, &mrp->mr_lock, 0);
-		mrp->mr_reads_waiting--;
-	}
-	while (mrp->mr_count < 0) {
-		mrp->mr_reads_waiting++;
-		lock_wait(&mrp->mr_readerq, &mrp->mr_lock, 0);
-		mrp->mr_reads_waiting--;
-	}
-	mrp->mr_count++;
-	MRUNLOCK(mrp);
-}
-
-/* ARGSUSED */
-void
-mrupdatef(mrlock_t *mrp, int flags)
-{
-	MRLOCK(mrp);
-	while(mrp->mr_count) {
-		mrp->mr_writes_waiting++;
-		lock_wait(&mrp->mr_writerq, &mrp->mr_lock, 1);
-		mrp->mr_writes_waiting--;
-	}
-
-	mrp->mr_count = -1; /* writer on it */
-	MRUNLOCK(mrp);
-}
-
-int
-mrtryaccess(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-	/*
-	 * If anyone is waiting for update access or the lock is held for update
-	 * fail the request.
-	 */
-	if(mrp->mr_writes_waiting > 0 || mrp->mr_count < 0) {
-		MRUNLOCK(mrp);
-		return 0;
-	}
-	mrp->mr_count++;
-	MRUNLOCK(mrp);
-	return 1;
-}
-
-int
-mrtrypromote(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-
-	if(mrp->mr_count == 1) { /* We are the only thread with the lock */
-		mrp->mr_count = -1; /* writer on it */
-		MRUNLOCK(mrp);
-		return 1;
-	}
-
-	MRUNLOCK(mrp);
-	return 0;
-}
-
-int
-mrtryupdate(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-
-	if(mrp->mr_count) {
-		MRUNLOCK(mrp);
-		return 0;
-	}
-
-	mrp->mr_count = -1; /* writer on it */
-	MRUNLOCK(mrp);
-	return 1;
-}
-
-static __inline__ void mrwake(mrlock_t *mrp)
-{
-	/*
-	 * First, if the count is now 0, we need to wake-up anyone waiting.
-	 */
-	if (!mrp->mr_count) {
-		if (mrp->mr_writes_waiting) {	/* Wake-up first writer waiting */
-			wake_up(&mrp->mr_writerq);
-		} else if (mrp->mr_reads_waiting) {	/* Wakeup any readers waiting */
-			wake_up(&mrp->mr_readerq);
-		}
-	}
-}
-
-void
-mraccunlock(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-	mrp->mr_count--;
-	mrwake(mrp);
-	MRUNLOCK(mrp);
-}
-
-void
-mrunlock(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-	if (mrp->mr_count < 0) {
-		mrp->mr_count = 0;
-	} else {
-		mrp->mr_count--;
-	}
-	mrwake(mrp);
-	MRUNLOCK(mrp);
-}
-
-int
-ismrlocked(mrlock_t *mrp, int type)	/* No need to lock since info can change */
-{
-	if (type == MR_ACCESS)
-		return (mrp->mr_count > 0); /* Read lock */
-	else if (type == MR_UPDATE)
-		return (mrp->mr_count < 0); /* Write lock */
-	else if (type == (MR_UPDATE | MR_ACCESS))
-		return (mrp->mr_count);	/* Any type of lock held */
-	else /* Any waiters */
-		return (mrp->mr_reads_waiting | mrp->mr_writes_waiting);
-}
-
-/*
- * Demote from update to access. We better be the only thread with the
- * lock in update mode so it should be easy to set to 1.
- * Wake-up any readers waiting.
- */
-
-void
-mrdemote(mrlock_t *mrp)
-{
-	MRLOCK(mrp);
-	mrp->mr_count = 1;
-	if (mrp->mr_reads_waiting) {	/* Wakeup all readers waiting */
-		wake_up(&mrp->mr_readerq);
-	}
-	MRUNLOCK(mrp);
-}
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/mrlock.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/mrlock.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/mrlock.h	2004-01-30 02:12:06.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/mrlock.h	2004-02-27 07:16:53.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -32,56 +32,73 @@
 #ifndef __XFS_SUPPORT_MRLOCK_H__
 #define __XFS_SUPPORT_MRLOCK_H__
 
-#include <linux/time.h>
-#include <linux/wait.h>
-#include <asm/atomic.h>
-#include <asm/semaphore.h>
+#include <linux/rwsem.h>
 
-/*
- * Implement mrlocks on Linux that work for XFS.
- *
- * These are sleep locks and not spinlocks. If one wants read/write spinlocks,
- * use read_lock, write_lock, ... see spinlock.h.
- */
+enum { MR_NONE, MR_ACCESS, MR_UPDATE };
 
-typedef struct mrlock_s {
-	int			mr_count;
-	unsigned short		mr_reads_waiting;
-	unsigned short		mr_writes_waiting;
-	wait_queue_head_t	mr_readerq;
-	wait_queue_head_t	mr_writerq;
-	spinlock_t		mr_lock;
+typedef struct {
+	struct rw_semaphore	mr_lock;
+	int			mr_writer;
 } mrlock_t;
 
-#define MR_ACCESS	1
-#define MR_UPDATE	2
-
-#define MRLOCK_BARRIER		0x1
-#define MRLOCK_ALLOW_EQUAL_PRI	0x8
+#define mrinit(mrp, name)	\
+	( (mrp)->mr_writer = 0, init_rwsem(&(mrp)->mr_lock) )
+#define mrlock_init(mrp, t,n,s)	mrinit(mrp, n)
+#define mrfree(mrp)		do { } while (0)
+#define mraccess(mrp)		mraccessf(mrp, 0)
+#define mrupdate(mrp)		mrupdatef(mrp, 0)
+
+static inline void mraccessf(mrlock_t *mrp, int flags)
+{
+	down_read(&mrp->mr_lock);
+}
+
+static inline void mrupdatef(mrlock_t *mrp, int flags)
+{
+	down_write(&mrp->mr_lock);
+	mrp->mr_writer = 1;
+}
+
+static inline int mrtryaccess(mrlock_t *mrp)
+{
+	return down_read_trylock(&mrp->mr_lock);
+}
+
+static inline int mrtryupdate(mrlock_t *mrp)
+{
+	if (!down_write_trylock(&mrp->mr_lock))
+		return 0;
+	mrp->mr_writer = 1;
+	return 1;
+}
+
+static inline void mrunlock(mrlock_t *mrp)
+{
+	if (mrp->mr_writer) {
+		mrp->mr_writer = 0;
+		up_write(&mrp->mr_lock);
+	} else {
+		up_read(&mrp->mr_lock);
+	}
+}
+
+static inline void mrdemote(mrlock_t *mrp)
+{
+	mrp->mr_writer = 0;
+	downgrade_write(&mrp->mr_lock);
+}
 
 /*
- * mraccessf/mrupdatef take flags to be passed in while sleeping;
- * only PLTWAIT is currently supported.
+ * Debug-only routine, without some platform-specific asm code, we can
+ * now only answer requests regarding whether we hold the lock for write
+ * (reader state is outside our visibility, we only track writer state).
+ * Note: means !ismrlocked would give false positivies, so don't do that.
  */
-
-extern void	mraccessf(mrlock_t *, int);
-extern void	mrupdatef(mrlock_t *, int);
-extern void     mrlock(mrlock_t *, int, int);
-extern void     mrunlock(mrlock_t *);
-extern void     mraccunlock(mrlock_t *);
-extern int      mrtryupdate(mrlock_t *);
-extern int      mrtryaccess(mrlock_t *);
-extern int	mrtrypromote(mrlock_t *);
-extern void     mrdemote(mrlock_t *);
-
-extern int	ismrlocked(mrlock_t *, int);
-extern void     mrlock_init(mrlock_t *, int type, char *name, long sequence);
-extern void     mrfree(mrlock_t *);
-
-#define mrinit(mrp, name)	mrlock_init(mrp, MRLOCK_BARRIER, name, -1)
-#define mraccess(mrp)		mraccessf(mrp, 0) /* grab for READ/ACCESS */
-#define mrupdate(mrp)		mrupdatef(mrp, 0) /* grab for WRITE/UPDATE */
-#define mrislocked_access(mrp)	((mrp)->mr_count > 0)
-#define mrislocked_update(mrp)	((mrp)->mr_count < 0)
+static inline int ismrlocked(mrlock_t *mrp, int type)
+{
+	if (type == MR_UPDATE)
+		return mrp->mr_writer;
+	return 1;
+}
 
 #endif /* __XFS_SUPPORT_MRLOCK_H__ */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_aops.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_aops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_aops.c	2004-02-09 04:39:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_aops.c	2004-02-27 06:51:51.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -54,8 +54,54 @@
 #include "xfs_iomap.h"
 #include <linux/mpage.h>
 
-STATIC void convert_page(struct inode *, struct page *,
-			xfs_iomap_t *, void *, int, int);
+STATIC void xfs_count_page_state(struct page *, int *, int *, int *);
+STATIC void xfs_convert_page(struct inode *, struct page *,
+				xfs_iomap_t *, void *, int, int);
+
+#if defined(XFS_RW_TRACE)
+void
+xfs_page_trace(
+	int		tag,
+	struct inode	*inode,
+	struct page	*page,
+	int		mask)
+{
+	xfs_inode_t	*ip;
+	bhv_desc_t	*bdp;
+	vnode_t		*vp = LINVFS_GET_VP(inode);
+	loff_t		isize = i_size_read(inode);
+	loff_t		offset = page->index << PAGE_CACHE_SHIFT;
+	int		delalloc = -1, unmapped = -1, unwritten = -1;
+
+	if (page_has_buffers(page))
+		xfs_count_page_state(page, &delalloc, &unmapped, &unwritten);
+
+	bdp = vn_bhv_lookup(VN_BHV_HEAD(vp), &xfs_vnodeops);
+	ip = XFS_BHVTOI(bdp);
+	if (!ip->i_rwtrace)
+		return;
+
+	ktrace_enter(ip->i_rwtrace,
+		(void *)((unsigned long)tag),
+		(void *)ip,
+		(void *)inode,
+		(void *)page,
+		(void *)((unsigned long)mask),
+		(void *)((unsigned long)((ip->i_d.di_size >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(ip->i_d.di_size & 0xffffffff)),
+		(void *)((unsigned long)((isize >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(isize & 0xffffffff)),
+		(void *)((unsigned long)((offset >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(offset & 0xffffffff)),
+		(void *)((unsigned long)delalloc),
+		(void *)((unsigned long)unmapped),
+		(void *)((unsigned long)unwritten),
+		(void *)NULL,
+		(void *)NULL);
+}
+#else
+#define xfs_page_trace(tag, inode, page, mask)
+#endif
 
 void
 linvfs_unwritten_done(
@@ -121,7 +167,7 @@ linvfs_unwritten_convert_direct(
 }
 
 STATIC int
-map_blocks(
+xfs_map_blocks(
 	struct inode		*inode,
 	loff_t			offset,
 	ssize_t			count,
@@ -151,12 +197,11 @@ retry:
 }
 
 /*
- * match_offset_to_mapping
  * Finds the corresponding mapping in block @map array of the
  * given @offset within a @page.
  */
 STATIC xfs_iomap_t *
-match_offset_to_mapping(
+xfs_offset_to_map(
 	struct page		*page,
 	xfs_iomap_t		*iomapp,
 	unsigned long		offset)
@@ -177,7 +222,7 @@ match_offset_to_mapping(
 }
 
 STATIC void
-map_buffer_at_offset(
+xfs_map_at_offset(
 	struct page		*page,
 	struct buffer_head	*bh,
 	unsigned long		offset,
@@ -218,7 +263,7 @@ map_buffer_at_offset(
  * in units of filesystem blocks.
  */
 STATIC struct page *
-probe_unwritten_page(
+xfs_probe_unwritten_page(
 	struct address_space	*mapping,
 	unsigned long		index,
 	xfs_iomap_t		*iomapp,
@@ -244,11 +289,11 @@ probe_unwritten_page(
 		do {
 			if (!buffer_unwritten(bh))
 				break;
-			if (!match_offset_to_mapping(page, iomapp, p_offset))
+			if (!xfs_offset_to_map(page, iomapp, p_offset))
 				break;
 			if (p_offset >= max_offset)
 				break;
-			map_buffer_at_offset(page, bh, p_offset, bbits, iomapp);
+			xfs_map_at_offset(page, bh, p_offset, bbits, iomapp);
 			set_buffer_unwritten_io(bh);
 			bh->b_private = pb;
 			p_offset += bh->b_size;
@@ -269,7 +314,7 @@ out:
  * yet - clustering for mmap write case.
  */
 STATIC unsigned int
-probe_unmapped_page(
+xfs_probe_unmapped_page(
 	struct address_space	*mapping,
 	unsigned long		index,
 	unsigned int		pg_offset)
@@ -305,7 +350,7 @@ out:
 }
 
 STATIC unsigned int
-probe_unmapped_cluster(
+xfs_probe_unmapped_cluster(
 	struct inode		*inode,
 	struct page		*startpage,
 	struct buffer_head	*bh,
@@ -330,7 +375,7 @@ probe_unmapped_cluster(
 		/* Prune this back to avoid pathological behavior */
 		tloff = min(tlast, startpage->index + 64);
 		for (tindex = startpage->index + 1; tindex < tloff; tindex++) {
-			len = probe_unmapped_page(mapping, tindex,
+			len = xfs_probe_unmapped_page(mapping, tindex,
 							PAGE_CACHE_SIZE);
 			if (!len)
 				return total;
@@ -338,7 +383,8 @@ probe_unmapped_cluster(
 		}
 		if (tindex == tlast &&
 		    (tloff = i_size_read(inode) & (PAGE_CACHE_SIZE - 1))) {
-			total += probe_unmapped_page(mapping, tindex, tloff);
+			total += xfs_probe_unmapped_page(mapping,
+							tindex, tloff);
 		}
 	}
 	return total;
@@ -350,7 +396,7 @@ probe_unmapped_cluster(
  * reference count.
  */
 STATIC struct page *
-probe_delalloc_page(
+xfs_probe_delalloc_page(
 	struct inode		*inode,
 	unsigned long		index)
 {
@@ -386,7 +432,7 @@ out:
 }
 
 STATIC int
-map_unwritten(
+xfs_map_unwritten(
 	struct inode		*inode,
 	struct page		*start_page,
 	struct buffer_head	*head,
@@ -434,22 +480,16 @@ map_unwritten(
 	do {
 		if (!buffer_unwritten(bh))
 			break;
-		tmp = match_offset_to_mapping(start_page, iomapp, p_offset);
+		tmp = xfs_offset_to_map(start_page, iomapp, p_offset);
 		if (!tmp)
 			break;
-		map_buffer_at_offset(start_page, bh, p_offset, block_bits, iomapp);
+		xfs_map_at_offset(start_page, bh, p_offset, block_bits, iomapp);
 		set_buffer_unwritten_io(bh);
 		bh->b_private = pb;
 		p_offset += bh->b_size;
 		nblocks++;
 	} while ((bh = bh->b_this_page) != head);
 
-	if (unlikely(nblocks == 0)) {
-		printk("XFS: bad unwritten extent map: bh=0x%p, iomapp=0x%p\n",
-		       curr, iomapp);
-		BUG();
-	}
-
 	atomic_add(nblocks, &pb->pb_io_remaining);
 
 	/* If we reached the end of the page, map forwards in any
@@ -465,13 +505,15 @@ map_unwritten(
 		tloff = (iomapp->iomap_offset + iomapp->iomap_bsize) >> PAGE_CACHE_SHIFT;
 		tloff = min(tlast, tloff);
 		for (tindex = start_page->index + 1; tindex < tloff; tindex++) {
-			page = probe_unwritten_page(mapping, tindex, iomapp, pb,
+			page = xfs_probe_unwritten_page(mapping,
+						tindex, iomapp, pb,
 						PAGE_CACHE_SIZE, &bs, bbits);
 			if (!page)
 				break;
 			nblocks += bs;
 			atomic_add(bs, &pb->pb_io_remaining);
-			convert_page(inode, page, iomapp, pb, startio, all_bh);
+			xfs_convert_page(inode, page, iomapp, pb,
+							startio, all_bh);
 			/* stop if converting the next page might add
 			 * enough blocks that the corresponding byte
 			 * count won't fit in our ulong page buf length */
@@ -481,12 +523,14 @@ map_unwritten(
 
 		if (tindex == tlast &&
 		    (tloff = (i_size_read(inode) & (PAGE_CACHE_SIZE - 1)))) {
-			page = probe_unwritten_page(mapping, tindex, iomapp, pb,
+			page = xfs_probe_unwritten_page(mapping,
+							tindex, iomapp, pb,
 							tloff, &bs, bbits);
 			if (page) {
 				nblocks += bs;
 				atomic_add(bs, &pb->pb_io_remaining);
-				convert_page(inode, page, iomapp, pb, startio, all_bh);
+				xfs_convert_page(inode, page, iomapp, pb,
+							startio, all_bh);
 				if (nblocks >= ((ULONG_MAX - PAGE_SIZE) >> block_bits))
 					goto enough;
 			}
@@ -513,7 +557,7 @@ enough:
 }
 
 STATIC void
-submit_page(
+xfs_submit_page(
 	struct page		*page,
 	struct buffer_head	*bh_arr[],
 	int			cnt)
@@ -549,7 +593,7 @@ submit_page(
  * that the page has no mapping at all.
  */
 STATIC void
-convert_page(
+xfs_convert_page(
 	struct inode		*inode,
 	struct page		*page,
 	xfs_iomap_t		*iomapp,
@@ -582,7 +626,7 @@ convert_page(
 			}
 			continue;
 		}
-		tmp = match_offset_to_mapping(page, mp, offset);
+		tmp = xfs_offset_to_map(page, mp, offset);
 		if (!tmp)
 			continue;
 		ASSERT(!(tmp->iomap_flags & IOMAP_HOLE));
@@ -594,10 +638,10 @@ convert_page(
 		 */
 		if (buffer_unwritten(bh) && !bh->b_end_io) {
 			ASSERT(tmp->iomap_flags & IOMAP_UNWRITTEN);
-			map_unwritten(inode, page, head, bh,
+			xfs_map_unwritten(inode, page, head, bh,
 					offset, bbits, tmp, startio, all_bh);
 		} else if (! (buffer_unwritten(bh) && buffer_locked(bh))) {
-			map_buffer_at_offset(page, bh, offset, bbits, tmp);
+			xfs_map_at_offset(page, bh, offset, bbits, tmp);
 			if (buffer_unwritten(bh)) {
 				set_buffer_unwritten_io(bh);
 				bh->b_private = private;
@@ -614,7 +658,7 @@ convert_page(
 	} while (i++, (bh = bh->b_this_page) != head);
 
 	if (startio) {
-		submit_page(page, bh_arr, index);
+		xfs_submit_page(page, bh_arr, index);
 	} else {
 		unlock_page(page);
 	}
@@ -625,7 +669,7 @@ convert_page(
  * by mp and following the start page.
  */
 STATIC void
-cluster_write(
+xfs_cluster_write(
 	struct inode		*inode,
 	unsigned long		tindex,
 	xfs_iomap_t		*iomapp,
@@ -637,10 +681,10 @@ cluster_write(
 
 	tlast = (iomapp->iomap_offset + iomapp->iomap_bsize) >> PAGE_CACHE_SHIFT;
 	for (; tindex < tlast; tindex++) {
-		page = probe_delalloc_page(inode, tindex);
+		page = xfs_probe_delalloc_page(inode, tindex);
 		if (!page)
 			break;
-		convert_page(inode, page, iomapp, NULL, startio, all_bh);
+		xfs_convert_page(inode, page, iomapp, NULL, startio, all_bh);
 	}
 }
 
@@ -664,7 +708,7 @@ cluster_write(
  */
 
 STATIC int
-page_state_convert(
+xfs_page_state_convert(
 	struct inode	*inode,
 	struct page	*page,
 	int		startio,
@@ -707,7 +751,7 @@ page_state_convert(
 			continue;
 
 		if (iomp) {
-			iomp = match_offset_to_mapping(page, &iomap, p_offset);
+			iomp = xfs_offset_to_map(page, &iomap, p_offset);
 		}
 
 		/*
@@ -716,17 +760,17 @@ page_state_convert(
 		 */
 		if (buffer_unwritten(bh)) {
 			if (!iomp) {
-				err = map_blocks(inode, offset, len, &iomap,
+				err = xfs_map_blocks(inode, offset, len, &iomap,
 						BMAPI_READ|BMAPI_IGNSTATE);
 				if (err) {
 					goto error;
 				}
-				iomp = match_offset_to_mapping(page, &iomap,
+				iomp = xfs_offset_to_map(page, &iomap,
 								p_offset);
 			}
 			if (iomp && startio) {
 				if (!bh->b_end_io) {
-					err = map_unwritten(inode, page,
+					err = xfs_map_unwritten(inode, page,
 							head, bh, p_offset,
 							inode->i_blkbits, iomp,
 							startio, unmapped);
@@ -743,17 +787,17 @@ page_state_convert(
 		 */
 		} else if (buffer_delay(bh)) {
 			if (!iomp) {
-				err = map_blocks(inode, offset, len, &iomap,
-					BMAPI_ALLOCATE | flags);
+				err = xfs_map_blocks(inode, offset, len, &iomap,
+						BMAPI_ALLOCATE | flags);
 				if (err) {
 					goto error;
 				}
-				iomp = match_offset_to_mapping(page, &iomap,
+				iomp = xfs_offset_to_map(page, &iomap,
 								p_offset);
 			}
 			if (iomp) {
-				map_buffer_at_offset(page, bh, p_offset,
-					inode->i_blkbits, iomp);
+				xfs_map_at_offset(page, bh, p_offset,
+						inode->i_blkbits, iomp);
 				if (startio) {
 					bh_arr[cnt++] = bh;
 				} else {
@@ -775,19 +819,19 @@ page_state_convert(
 				 * need to write the whole page out.
 				 */
 				if (!iomp) {
-					size = probe_unmapped_cluster(
+					size = xfs_probe_unmapped_cluster(
 							inode, page, bh, head);
-					err = map_blocks(inode, offset,
-						size, &iomap,
-						BMAPI_WRITE | BMAPI_MMAP);
+					err = xfs_map_blocks(inode, offset,
+							size, &iomap,
+							BMAPI_WRITE|BMAPI_MMAP);
 					if (err) {
 						goto error;
 					}
-					iomp = match_offset_to_mapping(page, &iomap,
+					iomp = xfs_offset_to_map(page, &iomap,
 								     p_offset);
 				}
 				if (iomp) {
-					map_buffer_at_offset(page,
+					xfs_map_at_offset(page,
 							bh, p_offset,
 							inode->i_blkbits, iomp);
 					if (startio) {
@@ -814,10 +858,10 @@ page_state_convert(
 		SetPageUptodate(page);
 
 	if (startio)
-		submit_page(page, bh_arr, cnt);
+		xfs_submit_page(page, bh_arr, cnt);
 
 	if (iomp)
-		cluster_write(inode, page->index + 1, iomp, startio, unmapped);
+		xfs_cluster_write(inode, page->index + 1, iomp, startio, unmapped);
 
 	return page_dirty;
 
@@ -1031,7 +1075,7 @@ linvfs_readpages(
 }
 
 STATIC void
-count_page_state(
+xfs_count_page_state(
 	struct page		*page,
 	int			*delalloc,
 	int			*unmapped,
@@ -1085,18 +1129,21 @@ linvfs_writepage(
 	int			delalloc, unmapped, unwritten;
 	struct inode		*inode = page->mapping->host;
 
+	xfs_page_trace(XFS_WRITEPAGE_ENTER, inode, page, 0);
+
 	/*
 	 * We need a transaction if:
 	 *  1. There are delalloc buffers on the page
-	 *  2. The page is upto date and we have unmapped buffers
-	 *  3. The page is upto date and we have no buffers
+	 *  2. The page is uptodate and we have unmapped buffers
+	 *  3. The page is uptodate and we have no buffers
 	 *  4. There are unwritten buffers on the page
 	 */
+
 	if (!page_has_buffers(page)) {
 		unmapped = 1;
 		need_trans = 1;
 	} else {
-		count_page_state(page, &delalloc, &unmapped, &unwritten);
+		xfs_count_page_state(page, &delalloc, &unmapped, &unwritten);
 		if (!PageUptodate(page))
 			unmapped = 0;
 		need_trans = delalloc + unmapped + unwritten;
@@ -1122,7 +1169,7 @@ linvfs_writepage(
 	 * Convert delayed allocate, unwritten or unmapped space
 	 * to real space and flush out to disk.
 	 */
-	error = page_state_convert(inode, page, 1, unmapped);
+	error = xfs_page_state_convert(inode, page, 1, unmapped);
 	if (error == -EAGAIN)
 		goto out_fail;
 	if (unlikely(error < 0))
@@ -1166,7 +1213,9 @@ linvfs_release_page(
 	struct inode		*inode = page->mapping->host;
 	int			dirty, delalloc, unmapped, unwritten;
 
-	count_page_state(page, &delalloc, &unmapped, &unwritten);
+	xfs_page_trace(XFS_RELEASEPAGE_ENTER, inode, page, gfp_mask);
+
+	xfs_count_page_state(page, &delalloc, &unmapped, &unwritten);
 	if (!delalloc && !unwritten)
 		goto free_buffers;
 
@@ -1185,7 +1234,7 @@ linvfs_release_page(
 	 * Never need to allocate space here - we will always
 	 * come back to writepage in that case.
 	 */
-	dirty = page_state_convert(inode, page, 0, 0);
+	dirty = xfs_page_state_convert(inode, page, 0, 0);
 	if (dirty == 0 && !unwritten)
 		goto free_buffers;
 	return 0;
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_buf.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_buf.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_buf.c	2004-02-09 04:09:45.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_buf.c	2004-03-02 05:14:39.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -59,17 +59,7 @@
 #include <linux/suspend.h>
 #include <linux/percpu.h>
 
-#include <support/ktrace.h>
-#include <support/debug.h>
-#include "kmem.h"
-
-#include "xfs_types.h"
-#include "xfs_cred.h"
-#include "xfs_lrw.h"
-#include "xfs_buf.h"
-
-#define BBSHIFT		9
-#define BN_ALIGN_MASK	((1 << (PAGE_CACHE_SHIFT - BBSHIFT)) - 1)
+#include "xfs_linux.h"
 
 #ifndef GFP_READAHEAD
 #define GFP_READAHEAD	(__GFP_NOWARN|__GFP_NORETRY)
@@ -86,60 +76,6 @@ STATIC struct workqueue_struct *pagebuf_
 STATIC struct workqueue_struct *pagebuf_dataio_workqueue;
 
 /*
- * Pagebuf module configuration parameters, exported via
- * /proc/sys/vm/pagebuf
- */
-
-typedef struct pb_sysctl_val {
-	int	min;
-	int	val;
-	int	max;
-} pb_sysctl_val_t;
-
-struct {
-	pb_sysctl_val_t	flush_interval;	/* interval between runs of the
-					 * delwri flush daemon.  */
-	pb_sysctl_val_t	age_buffer;	/* time for buffer to age before
-					 * we flush it.  */
-	pb_sysctl_val_t	stats_clear;	/* clear the pagebuf stats */
-	pb_sysctl_val_t	debug;		/* debug tracing on or off */
-} pb_params = {
-			  /*	MIN	DFLT	MAX	*/
-	.flush_interval	= {	HZ/2,	HZ,	30*HZ	},
-	.age_buffer	= {	1*HZ,	15*HZ,	300*HZ	},
-	.stats_clear	= {	0,	0,	1	},
-	.debug		= {	0,	0,	1	},
-};
-
-enum {
-	PB_FLUSH_INT = 1,
-	PB_FLUSH_AGE = 2,
-	PB_STATS_CLEAR = 3,
-	PB_DEBUG = 4,
-};
-
-/*
- * Pagebuf statistics variables
- */
-
-struct pbstats {
-	u_int32_t	pb_get;
-	u_int32_t	pb_create;
-	u_int32_t	pb_get_locked;
-	u_int32_t	pb_get_locked_waited;
-	u_int32_t	pb_busy_locked;
-	u_int32_t	pb_miss_locked;
-	u_int32_t	pb_page_retries;
-	u_int32_t	pb_page_found;
-	u_int32_t	pb_get_read;
-} pbstats;
-DEFINE_PER_CPU(struct pbstats, pbstats);
-
-/* We don't disable preempt, not too worried about poking the
- * wrong cpu's stat for now */
-#define PB_STATS_INC(count)	(__get_cpu_var(pbstats).count++)
-
-/*
  * Pagebuf debugging
  */
 
@@ -151,8 +87,6 @@ pagebuf_trace(
 	void		*data,
 	void		*ra)
 {
-	if (!pb_params.debug.val)
-		return;
 	ktrace_enter(pagebuf_trace_buf,
 		pb, id,
 		(void *)(unsigned long)pb->pb_flags,
@@ -326,7 +260,7 @@ _pagebuf_initialize(
 	atomic_set(&pb->pb_pin_count, 0);
 	init_waitqueue_head(&pb->pb_waiters);
 
-	PB_STATS_INC(pb_create);
+	XFS_STATS_INC(pb_create);
 	PB_TRACE(pb, "initialize", target);
 }
 
@@ -382,25 +316,13 @@ _pagebuf_freepages(
  *	pagebuf_free releases the specified buffer.  The modification
  *	state of any associated pages is left unchanged.
  */
-STATIC void
-__pagebuf_free(
+void
+pagebuf_free(
 	page_buf_t		*pb)
 {
-	pb_hash_t		*hash = pb_hash(pb);
-
 	PB_TRACE(pb, "free", 0);
-
-	spin_lock(&hash->pb_hash_lock);
-	/*
-	 * Someone grabbed a reference while we weren't looking,
-	 * try again later.
-	 */
-	if (unlikely(atomic_read(&pb->pb_hold))) {
-		spin_unlock(&hash->pb_hash_lock);
-		return;
-	} else if (!list_empty(&pb->pb_hash_list))
-		list_del_init(&pb->pb_hash_list);
-	spin_unlock(&hash->pb_hash_lock);
+	
+	ASSERT(list_empty(&pb->pb_hash_list));
 
 	/* release any virtual mapping */ ;
 	if (pb->pb_flags & _PBF_ADDR_ALLOCATED) {
@@ -429,17 +351,6 @@ __pagebuf_free(
 	pagebuf_deallocate(pb);
 }
 
-void
-pagebuf_free(
-	page_buf_t		*pb)
-{
-	if (unlikely(!atomic_dec_and_test(&pb->pb_hold))) {
-		printk(KERN_ERR "XFS: freeing inuse buffer!\n");
-		dump_stack();
-	} else
-		__pagebuf_free(pb);
-}
-
 /*
  *	_pagebuf_lookup_pages
  *
@@ -513,13 +424,13 @@ _pagebuf_lookup_pages(
 					       "possibly deadlocking in %s\n",
 					       __FUNCTION__);
 				}
-				PB_STATS_INC(pb_page_retries);
+				XFS_STATS_INC(pb_page_retries);
 				pagebuf_daemon_wakeup();
 				current->state = TASK_UNINTERRUPTIBLE;
 				schedule_timeout(10);
 				goto retry;
 			}
-			PB_STATS_INC(pb_page_found);
+			XFS_STATS_INC(pb_page_found);
 			mark_page_accessed(page);
 			pb->pb_pages[pi] = page;
 		} else {
@@ -565,6 +476,7 @@ _pagebuf_lookup_pages(
 		}
 	}
 
+	pb->pb_flags |= _PBF_PAGECACHE;
 mapit:
 	pb->pb_flags |= _PBF_MEM_ALLOCATED;
 	if (all_mapped) {
@@ -649,8 +561,7 @@ _pagebuf_find(				/* find buffer for blo
 
 		if (pb->pb_target == target &&
 		    pb->pb_file_offset == range_base &&
-		    pb->pb_buffer_length == range_length &&
-		    atomic_read(&pb->pb_hold)) {
+		    pb->pb_buffer_length == range_length) {
 			/* If we look at something bring it to the
 			 * front of the list for next time
 			 */
@@ -667,7 +578,7 @@ _pagebuf_find(				/* find buffer for blo
 		new_pb->pb_hash_index = hval;
 		list_add(&new_pb->pb_hash_list, &h->pb_hash);
 	} else {
-		PB_STATS_INC(pb_miss_locked);
+		XFS_STATS_INC(pb_miss_locked);
 	}
 
 	spin_unlock(&h->pb_hash_lock);
@@ -686,7 +597,7 @@ found:
 			/* wait for buffer ownership */
 			PB_TRACE(pb, "get_lock", 0);
 			pagebuf_lock(pb);
-			PB_STATS_INC(pb_get_locked_waited);
+			XFS_STATS_INC(pb_get_locked_waited);
 		} else {
 			/* We asked for a trylock and failed, no need
 			 * to look at file offset and length here, we
@@ -696,7 +607,7 @@ found:
 			 */
 
 			pagebuf_rele(pb);
-			PB_STATS_INC(pb_busy_locked);
+			XFS_STATS_INC(pb_busy_locked);
 			return (NULL);
 		}
 	} else {
@@ -711,7 +622,7 @@ found:
 				_PBF_MEM_ALLOCATED | \
 				_PBF_MEM_SLAB;
 	PB_TRACE(pb, "got_lock", 0);
-	PB_STATS_INC(pb_get_locked);
+	XFS_STATS_INC(pb_get_locked);
 	return (pb);
 }
 
@@ -767,7 +678,7 @@ pagebuf_get(				/* allocate a buffer		*/
 			return (NULL);
 	}
 
-	PB_STATS_INC(pb_get);
+	XFS_STATS_INC(pb_get);
 
 	/* fill in any missing pages */
 	error = _pagebuf_lookup_pages(pb, pb->pb_target->pbr_mapping, flags);
@@ -787,7 +698,7 @@ pagebuf_get(				/* allocate a buffer		*/
 	if (flags & PBF_READ) {
 		if (PBF_NOT_DONE(pb)) {
 			PB_TRACE(pb, "get_read", (unsigned long)flags);
-			PB_STATS_INC(pb_get_read);
+			XFS_STATS_INC(pb_get_read);
 			pagebuf_iostart(pb, flags);
 		} else if (flags & PBF_ASYNC) {
 			PB_TRACE(pb, "get_read_async", (unsigned long)flags);
@@ -1007,16 +918,21 @@ void
 pagebuf_rele(
 	page_buf_t		*pb)
 {
+	pb_hash_t		*hash = pb_hash(pb);
+
 	PB_TRACE(pb, "rele", pb->pb_relse);
 
-	if (atomic_dec_and_test(&pb->pb_hold)) {
+	if (atomic_dec_and_lock(&pb->pb_hold, &hash->pb_hash_lock)) {
 		int		do_free = 1;
 
 		if (pb->pb_relse) {
 			atomic_inc(&pb->pb_hold);
+			spin_unlock(&hash->pb_hash_lock);
 			(*(pb->pb_relse)) (pb);
+			spin_lock(&hash->pb_hash_lock);
 			do_free = 0;
 		}
+
 		if (pb->pb_flags & PBF_DELWRI) {
 			pb->pb_flags |= PBF_ASYNC;
 			atomic_inc(&pb->pb_hold);
@@ -1027,7 +943,11 @@ pagebuf_rele(
 		}
 
 		if (do_free) {
-			__pagebuf_free(pb);
+			list_del_init(&pb->pb_hash_list);
+			spin_unlock(&hash->pb_hash_lock);
+			pagebuf_free(pb);
+		} else {
+			spin_unlock(&hash->pb_hash_lock);
 		}
 	}
 }
@@ -1282,7 +1202,7 @@ pagebuf_iostart(			/* start I/O on a buf
 	page_buf_t		*pb,	/* buffer to start		  */
 	page_buf_flags_t	flags)	/* PBF_LOCK, PBF_ASYNC, PBF_READ, */
 					/* PBF_WRITE, PBF_DELWRI,	  */
-					/* PBF_SYNC, PBF_DONT_BLOCK	  */
+					/* PBF_DONT_BLOCK		  */
 {
 	int			status = 0;
 
@@ -1290,16 +1210,15 @@ pagebuf_iostart(			/* start I/O on a buf
 
 	if (flags & PBF_DELWRI) {
 		pb->pb_flags &= ~(PBF_READ | PBF_WRITE | PBF_ASYNC);
-		pb->pb_flags |= flags &
-				(PBF_DELWRI | PBF_ASYNC | PBF_SYNC);
+		pb->pb_flags |= flags & (PBF_DELWRI | PBF_ASYNC);
 		pagebuf_delwri_queue(pb, 1);
 		return status;
 	}
 
-	pb->pb_flags &= ~(PBF_READ | PBF_WRITE | PBF_ASYNC | \
-			PBF_DELWRI | PBF_READ_AHEAD | PBF_RUN_QUEUES);
+	pb->pb_flags &= ~(PBF_READ | PBF_WRITE | PBF_ASYNC | PBF_DELWRI | \
+			PBF_READ_AHEAD | PBF_RUN_QUEUES);
 	pb->pb_flags |= flags & (PBF_READ | PBF_WRITE | PBF_ASYNC | \
-			PBF_SYNC | PBF_READ_AHEAD | PBF_RUN_QUEUES);
+			PBF_READ_AHEAD | PBF_RUN_QUEUES);
 
 	BUG_ON(pb->pb_bn == PAGE_BUF_DADDR_NULL);
 
@@ -1655,7 +1574,7 @@ pagebuf_delwri_queue(
 	}
 
 	list_add_tail(&pb->pb_list, &pbd_delwrite_queue);
-	pb->pb_flushtime = jiffies + pb_params.age_buffer.val;
+	pb->pb_flushtime = jiffies + xfs_age_buffer;
 	spin_unlock(&pbd_delwrite_lock);
 
 	if (unlock)
@@ -1703,7 +1622,7 @@ pagebuf_daemon(
 	struct list_head	*curr, *next, tmp;
 
 	/*  Set up the thread  */
-	daemonize("pagebufd");
+	daemonize("xfsbufd");
 	current->flags |= PF_MEMALLOC;
 
 	pagebuf_daemon_task = current;
@@ -1717,7 +1636,7 @@ pagebuf_daemon(
 			refrigerator(PF_IOTHREAD);
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(pb_params.flush_interval.val);
+		schedule_timeout(xfs_flush_interval);
 
 		spin_lock(&pbd_delwrite_lock);
 
@@ -1876,112 +1795,6 @@ pagebuf_daemon_stop(void)
 	destroy_workqueue(pagebuf_dataio_workqueue);
 }
 
-
-/*
- * Pagebuf sysctl interface
- */
-
-STATIC int
-pb_stats_clear_handler(
-	ctl_table		*ctl,
-	int			write,
-	struct file		*filp,
-	void			*buffer,
-	size_t			*lenp)
-{
-	int			c, ret;
-	int			*valp = ctl->data;
-
-	ret = proc_dointvec_minmax(ctl, write, filp, buffer, lenp);
-
-	if (!ret && write && *valp) {
-		printk("XFS Clearing pbstats\n");
-		for (c = 0; c < NR_CPUS; c++) {
-			if (!cpu_possible(c)) continue;
-				memset(&per_cpu(pbstats, c), 0,
-				       sizeof(struct pbstats));
-		}
-		pb_params.stats_clear.val = 0;
-	}
-
-	return ret;
-}
-
-STATIC struct ctl_table_header *pagebuf_table_header;
-
-STATIC ctl_table pagebuf_table[] = {
-	{PB_FLUSH_INT, "flush_int", &pb_params.flush_interval.val,
-	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
-	&sysctl_intvec, NULL,
-	&pb_params.flush_interval.min, &pb_params.flush_interval.max},
-
-	{PB_FLUSH_AGE, "flush_age", &pb_params.age_buffer.val,
-	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
-	&sysctl_intvec, NULL, 
-	&pb_params.age_buffer.min, &pb_params.age_buffer.max},
-
-	{PB_STATS_CLEAR, "stats_clear", &pb_params.stats_clear.val,
-	sizeof(int), 0644, NULL, &pb_stats_clear_handler,
-	&sysctl_intvec, NULL, 
-	&pb_params.stats_clear.min, &pb_params.stats_clear.max},
-
-#ifdef PAGEBUF_TRACE
-	{PB_DEBUG, "debug", &pb_params.debug.val,
-	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
-	&sysctl_intvec, NULL, 
-	&pb_params.debug.min, &pb_params.debug.max},
-#endif
-	{0}
-};
-
-STATIC ctl_table pagebuf_dir_table[] = {
-	{VM_PAGEBUF, "pagebuf", NULL, 0, 0555, pagebuf_table},
-	{0}
-};
-
-STATIC ctl_table pagebuf_root_table[] = {
-	{CTL_VM, "vm",  NULL, 0, 0555, pagebuf_dir_table},
-	{0}
-};
-
-#ifdef CONFIG_PROC_FS
-STATIC int
-pagebuf_readstats(
-	char			*buffer,
-	char			**start,
-	off_t			offset,
-	int			count,
-	int			*eof,
-	void			*data)
-{
-	int			c, i, len, val;
-
-	len = 0;
-	len += sprintf(buffer + len, "pagebuf");
-	for (i = 0; i < sizeof(struct pbstats) / sizeof(u_int32_t); i++) {
-		val = 0;
-		for (c = 0 ; c < NR_CPUS; c++) {
-			if (!cpu_possible(c)) continue;
-			val += *(((u_int32_t*)&per_cpu(pbstats, c) + i));
-		}
-		len += sprintf(buffer + len, " %u", val);
-	}
-	buffer[len++] = '\n';
-
-	if (offset >= len) {
-		*start = buffer;
-		*eof = 1;
-		return 0;
-	}
-	*start = buffer + offset;
-	if ((len -= offset) > count)
-		return count;
-	*eof = 1;
-
-	return len;
-}
-#endif  /* CONFIG_PROC_FS */
-
 /*
  *	Initialization and Termination
  */
@@ -1991,14 +1804,6 @@ pagebuf_init(void)
 {
 	int			i;
 
-	pagebuf_table_header = register_sysctl_table(pagebuf_root_table, 1);
-
-#ifdef CONFIG_PROC_FS
-	if (proc_mkdir("fs/pagebuf", 0))
-		create_proc_read_entry(
-			"fs/pagebuf/stat", 0, 0, pagebuf_readstats, NULL);
-#endif
-
 	pagebuf_cache = kmem_cache_create("page_buf_t", sizeof(page_buf_t), 0,
 			SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (pagebuf_cache == NULL) {
@@ -2036,10 +1841,4 @@ pagebuf_terminate(void)
 #endif
 
 	kmem_cache_destroy(pagebuf_cache);
-
-	unregister_sysctl_table(pagebuf_table_header);
-#ifdef  CONFIG_PROC_FS
-	remove_proc_entry("fs/pagebuf/stat", NULL);
-	remove_proc_entry("fs/pagebuf", NULL);
-#endif
 }
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_buf.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_buf.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_buf.h	2004-02-09 03:33:24.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_buf.h	2004-03-02 05:14:39.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -76,7 +76,6 @@ typedef enum page_buf_flags_e {		/* pb_f
 	PBF_ASYNC = (1 << 4),   /* initiator will not wait for completion  */
 	PBF_NONE = (1 << 5),    /* buffer not read at all                  */
 	PBF_DELWRI = (1 << 6),  /* buffer has dirty pages                  */
-	PBF_SYNC = (1 << 8),    /* force updates to disk                   */
 	PBF_STALE = (1 << 10),	/* buffer has been staled, do not find it  */
 	PBF_FS_MANAGED = (1 << 11), /* filesystem controls freeing memory  */
 	PBF_FS_DATAIOD = (1 << 12), /* schedule IO completion on fs datad  */
@@ -87,6 +86,7 @@ typedef enum page_buf_flags_e {		/* pb_f
 	PBF_DONT_BLOCK = (1 << 15), /* do not block in current thread	   */
 
 	/* flags used only internally */
+	_PBF_PAGECACHE = (1 << 16),	/* backed by pagecache		   */
 	_PBF_ALL_PAGES_MAPPED = (1 << 18), /* all pages in range mapped	   */
 	_PBF_ADDR_ALLOCATED = (1 << 19), /* pb_addr space was allocated	   */
 	_PBF_MEM_ALLOCATED = (1 << 20), /* underlying pages are allocated  */
@@ -260,7 +260,7 @@ extern int pagebuf_iostart(		/* start I/
 		page_buf_t *,		/* buffer to start		*/
 		page_buf_flags_t);	/* PBF_LOCK, PBF_ASYNC,		*/
 					/* PBF_READ, PBF_WRITE,		*/
-					/* PBF_DELWRI, PBF_SYNC		*/
+					/* PBF_DELWRI			*/
 
 extern int pagebuf_iorequest(		/* start real I/O		*/
 		page_buf_t *);		/* buffer to convey to device	*/
@@ -355,7 +355,7 @@ extern void pagebuf_trace(
 
 #define XFS_BUF_BFLAGS(x)	((x)->pb_flags)
 #define XFS_BUF_ZEROFLAGS(x)	\
-	((x)->pb_flags &= ~(PBF_READ|PBF_WRITE|PBF_ASYNC|PBF_SYNC|PBF_DELWRI))
+	((x)->pb_flags &= ~(PBF_READ|PBF_WRITE|PBF_ASYNC|PBF_DELWRI))
 
 #define XFS_BUF_STALE(x)	((x)->pb_flags |= XFS_B_STALE)
 #define XFS_BUF_UNSTALE(x)	((x)->pb_flags &= ~XFS_B_STALE)
@@ -558,7 +558,6 @@ static inline int	XFS_bwrite(page_buf_t 
 	int	iowait = (pb->pb_flags & PBF_ASYNC) == 0;
 	int	error = 0;
 
-	pb->pb_flags |= PBF_SYNC;
 	if (!iowait)
 		pb->pb_flags |= PBF_RUN_QUEUES;
 
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_globals.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_globals.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_globals.c	2004-01-30 04:04:27.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_globals.c	2004-02-27 06:40:29.000000000 +0000
@@ -61,6 +61,8 @@ xfs_param_t xfs_params = {
 	.inherit_sync	= {	0,	1,	1	},
 	.inherit_nodump	= {	0,	1,	1	},
 	.inherit_noatim = {	0,	1,	1	},
+	.flush_interval	= {	HZ/2,	HZ,	30*HZ	},
+	.age_buffer	= {	1*HZ,	15*HZ,	300*HZ	},
 };
 
 /*
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_ioctl.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_ioctl.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_ioctl.c	2004-01-08 02:43:10.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_ioctl.c	2004-02-27 06:28:05.000000000 +0000
@@ -699,9 +699,7 @@ xfs_ioctl(
 
 		error = xfs_set_dmattrs(bdp, dmi.fsd_dmevmask, dmi.fsd_dmstate,
 							NULL);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_GETBMAP:
@@ -733,9 +731,7 @@ xfs_ioctl(
 
 	case XFS_IOC_SWAPEXT: {
 		error = xfs_swapext((struct xfs_swapext *)arg);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_FSCOUNTS: {
@@ -763,6 +759,8 @@ xfs_ioctl(
 		/* input parameter is passed in resblks field of structure */
 		in = inout.resblks;
 		error = xfs_reserve_blocks(mp, &in, &inout);
+		if (error)
+			return -error;
 
 		if (copy_to_user((char *)arg, &inout, sizeof(inout)))
 			return -XFS_ERROR(EFAULT);
@@ -795,9 +793,7 @@ xfs_ioctl(
 			return -XFS_ERROR(EFAULT);
 
 		error = xfs_growfs_data(mp, &in);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_FSGROWFSLOG: {
@@ -810,9 +806,7 @@ xfs_ioctl(
 			return -XFS_ERROR(EFAULT);
 
 		error = xfs_growfs_log(mp, &in);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_FSGROWFSRT: {
@@ -825,9 +819,7 @@ xfs_ioctl(
 			return -XFS_ERROR(EFAULT);
 
 		error = xfs_growfs_rt(mp, &in);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_FREEZE:
@@ -842,6 +834,19 @@ xfs_ioctl(
 		xfs_fs_thaw(mp);
 		return 0;
 
+	case XFS_IOC_GOINGDOWN: {
+		__uint32_t in;
+
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+
+		if (get_user(in, (__uint32_t *)arg))
+			return -XFS_ERROR(EFAULT);
+
+		error = xfs_fs_goingdown(mp, in);
+		return -error;
+	}
+
 	case XFS_IOC_ERROR_INJECTION: {
 		xfs_error_injection_t in;
 
@@ -849,9 +854,7 @@ xfs_ioctl(
 			return -XFS_ERROR(EFAULT);
 
 		error = xfs_errortag_add(in.errtag, mp);
-		if (error)
-			return -error;
-		return 0;
+		return -error;
 	}
 
 	case XFS_IOC_ERROR_CLEARALL:
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_iops.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_iops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_iops.c	2004-02-11 01:12:33.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_iops.c	2004-02-27 06:57:29.000000000 +0000
@@ -541,7 +541,6 @@ linvfs_setattr(
 	if (error)
 		return(-error);	/* Positive error up from XFS */
 	if (ia_valid & ATTR_SIZE) {
-		i_size_write(inode, vattr.va_size);
 		error = vmtruncate(inode, attr->ia_size);
 	}
 
@@ -631,8 +630,7 @@ linvfs_listxattr(
 
 	if (!size)
 		xflags |= ATTR_KERNOVAL;
-	if (capable(CAP_SYS_ADMIN))
-		xflags |= ATTR_KERNFULLS;
+	xflags |= capable(CAP_SYS_ADMIN) ? ATTR_KERNFULLS : ATTR_KERNORMALS;
 
 	error = attr_generic_list(vp, data, size, xflags, &result);
 	if (error < 0)
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_linux.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_linux.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_linux.h	2004-01-30 05:42:43.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_linux.h	2004-03-03 04:52:57.000000000 +0000
@@ -85,6 +85,7 @@
 #include <linux/seq_file.h>
 #include <linux/init.h>
 #include <linux/proc_fs.h>
+#include <linux/version.h>
 
 #include <asm/page.h>
 #include <asm/div64.h>
@@ -138,6 +139,8 @@ static inline void set_buffer_unwritten_
 #define xfs_inherit_sync	xfs_params.inherit_sync.val
 #define xfs_inherit_nodump	xfs_params.inherit_nodump.val
 #define xfs_inherit_noatime	xfs_params.inherit_noatim.val
+#define xfs_flush_interval	xfs_params.flush_interval.val
+#define xfs_age_buffer		xfs_params.age_buffer.val
 
 #define current_cpu()		smp_processor_id()
 #define current_pid()		(current->pid)
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_lrw.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_lrw.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_lrw.c	2004-01-08 04:46:03.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_lrw.c	2004-03-03 04:52:57.000000000 +0000
@@ -283,7 +283,6 @@ xfs_read(
 	ip = XFS_BHVTOI(bdp);
 	vp = BHV_TO_VNODE(bdp);
 	mp = ip->i_mount;
-	vn_trace_entry(vp, "xfs_read", (inst_t *)__return_address);
 
 	XFS_STATS_INC(xs_read_calls);
 
@@ -334,17 +333,19 @@ xfs_read(
 
 	if (DM_EVENT_ENABLED(vp->v_vfsp, ip, DM_EVENT_READ) &&
 	    !(ioflags & IO_INVIS)) {
-		int error;
 		vrwlock_t locktype = VRWLOCK_READ;
 
-		error = XFS_SEND_DATA(mp, DM_EVENT_READ, BHV_TO_VNODE(bdp), *offset, size,
-				      FILP_DELAY_FLAG(file), &locktype);
-		if (error) {
+		ret = XFS_SEND_DATA(mp, DM_EVENT_READ,
+					BHV_TO_VNODE(bdp), *offset, size,
+					FILP_DELAY_FLAG(file), &locktype);
+		if (ret) {
 			xfs_iunlock(ip, XFS_IOLOCK_SHARED);
-			return -error;
+			return -ret;
 		}
 	}
 
+	xfs_rw_enter_trace(XFS_READ_ENTER, &ip->i_iocore,
+				iovp, segs, *offset, ioflags);
 	ret = __generic_file_aio_read(iocb, iovp, segs, offset);
 	xfs_iunlock(ip, XFS_IOLOCK_SHARED);
 
@@ -377,7 +378,6 @@ xfs_sendfile(
 	ip = XFS_BHVTOI(bdp);
 	vp = BHV_TO_VNODE(bdp);
 	mp = ip->i_mount;
-	vn_trace_entry(vp, "xfs_sendfile", (inst_t *)__return_address);
 
 	XFS_STATS_INC(xs_read_calls);
 
@@ -405,6 +405,8 @@ xfs_sendfile(
 			return -error;
 		}
 	}
+	xfs_rw_enter_trace(XFS_SENDFILE_ENTER, &ip->i_iocore,
+				target, count, *offset, ioflags);
 	ret = generic_file_sendfile(filp, offset, count, actor, target);
 	xfs_iunlock(ip, XFS_IOLOCK_SHARED);
 
@@ -658,7 +660,6 @@ xfs_write(
 	XFS_STATS_INC(xs_write_calls);
 
 	vp = BHV_TO_VNODE(bdp);
-	vn_trace_entry(vp, "xfs_write", (inst_t *)__return_address);
 	xip = XFS_BHVTOI(bdp);
 
 	/* START copy & waste from filemap.c */
@@ -678,7 +679,7 @@ xfs_write(
 	if (size == 0)
 		return 0;
 
-	io = &(xip->i_iocore);
+	io = &xip->i_iocore;
 	mp = io->io_mount;
 
 	xfs_check_frozen(mp, bdp, XFS_FREEZE_WRITE);
@@ -729,11 +730,12 @@ start:
 	if ((DM_EVENT_ENABLED(vp->v_vfsp, xip, DM_EVENT_WRITE) &&
 	    !(ioflags & IO_INVIS) && !eventsent)) {
 		loff_t		savedsize = *offset;
+		int dmflags = FILP_DELAY_FLAG(file) | DM_SEM_FLAG_RD(ioflags);
 
 		xfs_iunlock(xip, XFS_ILOCK_EXCL);
 		error = XFS_SEND_DATA(xip->i_mount, DM_EVENT_WRITE, vp,
 				      *offset, size,
-				      FILP_DELAY_FLAG(file), &locktype);
+				      dmflags, &locktype);
 		if (error) {
 			xfs_iunlock(xip, iolock);
 			return -error;
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_lrw.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_lrw.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_lrw.h	2004-01-08 04:46:04.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_lrw.h	2004-02-27 06:36:03.000000000 +0000
@@ -45,9 +45,7 @@ struct xfs_iomap;
 /*
  * Defines for the trace mechanisms in xfs_lrw.c.
  */
-#define	XFS_RW_KTRACE_SIZE	64
-#define	XFS_STRAT_KTRACE_SIZE	64
-#define	XFS_STRAT_GTRACE_SIZE	512
+#define	XFS_RW_KTRACE_SIZE	128
 
 #define	XFS_READ_ENTER		1
 #define	XFS_WRITE_ENTER		2
@@ -69,6 +67,12 @@ struct xfs_iomap;
 #define	XFS_INVAL_CACHED	18
 #define	XFS_DIORD_ENTER		19
 #define	XFS_DIOWR_ENTER		20
+#define	XFS_SENDFILE_ENTER	21
+#define	XFS_WRITEPAGE_ENTER	22
+#define	XFS_RELEASEPAGE_ENTER	23
+#define	XFS_IOMAP_ALLOC_ENTER	24
+#define	XFS_IOMAP_ALLOC_MAP	25
+#define	XFS_IOMAP_UNWRITTEN	26
 extern void xfs_rw_enter_trace(int, struct xfs_iocore *,
 			const struct iovec *, size_t, loff_t, int);
 extern void xfs_inval_cached_trace(struct xfs_iocore *,
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_stats.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_stats.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_stats.c	2003-09-29 22:15:04.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_stats.c	2004-02-27 06:40:29.000000000 +0000
@@ -67,6 +67,7 @@ xfs_read_xfsstats(
 		{ "attr",		XFSSTAT_END_ATTRIBUTE_OPS	},
 		{ "icluster",		XFSSTAT_END_INODE_CLUSTER	},
 		{ "vnodes",		XFSSTAT_END_VNODE_OPS		},
+		{ "buf",		XFSSTAT_END_BUF			},
 	};
 
 	/* Loop over all stats groups */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_stats.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_stats.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_stats.h	2003-10-02 22:26:20.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_stats.h	2004-02-27 06:40:29.000000000 +0000
@@ -122,6 +122,16 @@ struct xfsstats {
 	__uint32_t		vn_reclaim;	/* # times vn_reclaim called */
 	__uint32_t		vn_remove;	/* # times vn_remove called */
 	__uint32_t		vn_free;	/* # times vn_free called */
+#define XFSSTAT_END_BUF			(XFSSTAT_END_VNODE_OPS+9)
+	__uint32_t		pb_get;
+	__uint32_t		pb_create;
+	__uint32_t		pb_get_locked;
+	__uint32_t		pb_get_locked_waited;
+	__uint32_t		pb_busy_locked;
+	__uint32_t		pb_miss_locked;
+	__uint32_t		pb_page_retries;
+	__uint32_t		pb_page_found;
+	__uint32_t		pb_get_read;
 /* Extra precision counters */
 	__uint64_t		xs_xstrat_bytes;
 	__uint64_t		xs_write_bytes;
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_super.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_super.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_super.c	2004-02-19 03:42:22.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_super.c	2004-02-27 06:48:48.000000000 +0000
@@ -453,7 +453,7 @@ syncd(void *arg)
 	vfs_t			*vfsp = (vfs_t *) arg;
 	int			error;
 
-	daemonize("xfs_syncd");
+	daemonize("xfssyncd");
 
 	vfsp->vfs_sync_task = current;
 	wmb();
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_super.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_super.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_super.h	2004-01-30 03:24:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_super.h	2004-03-03 04:52:57.000000000 +0000
@@ -44,6 +44,8 @@
 
 #ifdef CONFIG_XFS_QUOTA
 # define vfs_insertquota(vfs)	vfs_insertops(vfsp, &xfs_qmops)
+extern void xfs_qm_init(void);
+extern void xfs_qm_exit(void);
 # define vfs_initquota()	xfs_qm_init()
 # define vfs_exitquota()	xfs_qm_exit()
 #else
@@ -61,7 +63,7 @@
 #endif
 
 #ifdef CONFIG_XFS_SECURITY
-# define XFS_SECURITY_STRING	"security attrs, "
+# define XFS_SECURITY_STRING	"security attributes, "
 # define ENOSECURITY		0
 #else
 # define XFS_SECURITY_STRING
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_sysctl.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_sysctl.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_sysctl.c	2004-01-08 05:52:33.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_sysctl.c	2004-02-27 06:40:29.000000000 +0000
@@ -117,6 +117,16 @@ STATIC ctl_table xfs_table[] = {
 	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
 	&sysctl_intvec, NULL,
 	&xfs_params.inherit_noatim.min, &xfs_params.inherit_noatim.max},
+	
+	{XFS_FLUSH_INTERVAL, "flush_interval", &xfs_params.flush_interval.val,
+	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
+	&sysctl_intvec, NULL,
+	&xfs_params.flush_interval.min, &xfs_params.flush_interval.max},
+
+	{XFS_AGE_BUFFER, "age_buffer", &xfs_params.age_buffer.val,
+	sizeof(int), 0644, NULL, &proc_dointvec_minmax,
+	&sysctl_intvec, NULL,
+	&xfs_params.age_buffer.min, &xfs_params.age_buffer.max},
 
 	/* please keep this the last entry */
 #ifdef CONFIG_PROC_FS
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_sysctl.h linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_sysctl.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_sysctl.h	2003-10-08 14:23:30.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_sysctl.h	2004-02-27 06:40:29.000000000 +0000
@@ -58,6 +58,10 @@ typedef struct xfs_param {
 	xfs_sysctl_val_t inherit_sync;	/* Inherit the "sync" inode flag. */
 	xfs_sysctl_val_t inherit_nodump;/* Inherit the "nodump" inode flag. */
 	xfs_sysctl_val_t inherit_noatim;/* Inherit the "noatime" inode flag. */
+	xfs_sysctl_val_t flush_interval;/* interval between runs of the
+					 * delwri flush daemon.  */
+	xfs_sysctl_val_t age_buffer;	/* time for buffer to age before
+					 * we flush it.  */
 } xfs_param_t;
 
 /*
@@ -86,6 +90,8 @@ enum {
 	XFS_INHERIT_SYNC = 13,
 	XFS_INHERIT_NODUMP = 14,
 	XFS_INHERIT_NOATIME = 15,
+	XFS_FLUSH_INTERVAL = 16,
+	XFS_AGE_BUFFER = 17,
 };
 
 extern xfs_param_t	xfs_params;
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_vfs.c linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_vfs.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/linux/xfs_vfs.c	2004-01-08 22:20:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/linux/xfs_vfs.c	2004-03-03 04:52:57.000000000 +0000
@@ -117,7 +117,6 @@ vfs_mntupdate(
 	return ((*bhvtovfsops(next)->vfs_mntupdate)(next, fl, args));
 }
 
-
 int
 vfs_root(
 	struct bhv_desc		*bdp,
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_alloc.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_alloc.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_alloc.c	2004-01-08 03:12:43.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_alloc.c	2004-03-02 05:07:01.000000000 +0000
@@ -780,14 +780,8 @@ xfs_alloc_ag_vextent_near(
 	/*
 	 * Randomly don't execute the first algorithm.
 	 */
-	static int	seed;		/* randomizing seed value */
 	int		dofirst;	/* set to do first algorithm */
-	timespec_t	now;		/* current time */
 
-	if (!seed) {
-		nanotime(&now);
-		seed = (int)now.tv_sec ^ (int)now.tv_nsec;
-	}
 	dofirst = random() & 1;
 #endif
 	/*
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_attr.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_attr.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_attr.h	2004-01-30 03:24:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_attr.h	2004-02-27 06:57:29.000000000 +0000
@@ -91,10 +91,14 @@ extern int attr_generic_list(struct vnod
 #define ATTR_CREATE	0x0010	/* pure create: fail if attr already exists */
 #define ATTR_REPLACE	0x0020	/* pure set: fail if attr does not exist */
 #define ATTR_SYSTEM	0x0100	/* use attrs in system (pseudo) namespace */
+
 #define ATTR_KERNOTIME	0x1000	/* [kernel] don't update inode timestamps */
 #define ATTR_KERNOVAL	0x2000	/* [kernel] get attr size only, not value */
 #define ATTR_KERNAMELS	0x4000	/* [kernel] list attr names (simple list) */
-#define ATTR_KERNFULLS	0x8000	/* [kernel] full attr list, ie. root+user */
+
+#define ATTR_KERNORMALS	0x0800	/* [kernel] normal attr list: user+secure */
+#define ATTR_KERNROOTLS	0x8000	/* [kernel] include root in the attr list */
+#define ATTR_KERNFULLS	(ATTR_KERNORMALS|ATTR_KERNROOTLS)
 
 /*
  * The maximum size (into the kernel or returned from the kernel) of an
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_attr_leaf.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_attr_leaf.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_attr_leaf.c	2004-01-30 03:24:58.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_attr_leaf.c	2004-02-27 06:57:29.000000000 +0000
@@ -460,9 +460,15 @@ xfs_attr_shortform_list(xfs_attr_list_co
 				i < INT_GET(sf->hdr.count, ARCH_CONVERT); i++) {
 			attrnames_t	*namesp;
 
+			if (((context->flags & ATTR_SECURE) != 0) !=
+			    ((sfe->flags & XFS_ATTR_SECURE) != 0) &&
+			    !(context->flags & ATTR_KERNORMALS)) {
+				sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
+				continue;
+			}
 			if (((context->flags & ATTR_ROOT) != 0) !=
 			    ((sfe->flags & XFS_ATTR_ROOT) != 0) &&
-			    !(context->flags & ATTR_KERNFULLS)) {
+			    !(context->flags & ATTR_KERNROOTLS)) {
 				sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
 				continue;
 			}
@@ -511,9 +517,15 @@ xfs_attr_shortform_list(xfs_attr_list_co
 			kmem_free(sbuf, sbsize);
 			return XFS_ERROR(EFSCORRUPTED);
 		}
+		if (((context->flags & ATTR_SECURE) != 0) !=
+		    ((sfe->flags & XFS_ATTR_SECURE) != 0) &&
+		    !(context->flags & ATTR_KERNORMALS)) {
+			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
+			continue;
+		}
 		if (((context->flags & ATTR_ROOT) != 0) !=
 		    ((sfe->flags & XFS_ATTR_ROOT) != 0) &&
-		    !(context->flags & ATTR_KERNFULLS)) {
+		    !(context->flags & ATTR_KERNROOTLS)) {
 			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
 			continue;
 		}
@@ -2309,9 +2321,13 @@ xfs_attr_leaf_list_int(xfs_dabuf_t *bp, 
 
 		if (entry->flags & XFS_ATTR_INCOMPLETE)
 			continue;		/* skip incomplete entries */
+		if (((context->flags & ATTR_SECURE) != 0) !=
+		    ((entry->flags & XFS_ATTR_SECURE) != 0) &&
+		    !(context->flags & ATTR_KERNORMALS))
+			continue;		/* skip non-matching entries */
 		if (((context->flags & ATTR_ROOT) != 0) !=
 		    ((entry->flags & XFS_ATTR_ROOT) != 0) &&
-		    !(context->flags & ATTR_KERNFULLS))
+		    !(context->flags & ATTR_KERNROOTLS))
 			continue;		/* skip non-matching entries */
 
 		namesp = (entry->flags & XFS_ATTR_SECURE) ? &attr_secure :
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_clnt.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_clnt.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_clnt.h	2003-10-06 18:49:17.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_clnt.h	2004-02-27 07:20:52.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -57,10 +57,10 @@ struct xfs_mount_args {
 	int	flags;		/* flags -> see XFSMNT_... macros below */
 	int	logbufs;	/* Number of log buffers, -1 to default */
 	int	logbufsize;	/* Size of log buffers, -1 to default */
-	char	fsname[MAXNAMELEN];	/* data device name */
-	char	rtname[MAXNAMELEN];	/* realtime device filename */
-	char	logname[MAXNAMELEN];	/* journal device filename */
-	char	mtpt[MAXNAMELEN];	/* filesystem mount point */
+	char	fsname[MAXNAMELEN+1];	/* data device name */
+	char	rtname[MAXNAMELEN+1];	/* realtime device filename */
+	char	logname[MAXNAMELEN+1];	/* journal device filename */
+	char	mtpt[MAXNAMELEN+1];	/* filesystem mount point */
 	int	sunit;		/* stripe unit (BBs) */
 	int	swidth;		/* stripe width (BBs), multiple of sunit */
 	uchar_t iosizelog;	/* log2 of the preferred I/O size */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_dmapi.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_dmapi.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_dmapi.h	2004-01-08 03:55:43.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_dmapi.h	2004-03-02 05:35:29.000000000 +0000
@@ -165,6 +165,27 @@ typedef enum {
 
 #define DM_FLAGS_NDELAY		0x001	/* return EAGAIN after dm_pending() */
 #define DM_FLAGS_UNWANTED	0x002	/* event not in fsys dm_eventset_t */
+#define DM_FLAGS_ISEM		0x004	/* thread holds i_sem */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,21)
+/* i_alloc_sem was added in 2.4.22-pre1 */
+#define DM_FLAGS_IALLOCSEM_RD	0x010	/* thread holds i_alloc_sem rd */
+#define DM_FLAGS_IALLOCSEM_WR	0x020	/* thread holds i_alloc_sem wr */
+#endif
+#endif
+
+/*
+ *	Based on IO_ISDIRECT, decide which i_ flag is set.
+ */
+#ifdef DM_FLAGS_IALLOCSEM_RD
+#define DM_SEM_FLAG_RD(ioflags) (((ioflags) & IO_ISDIRECT) ? \
+			      DM_FLAGS_IALLOCSEM_RD : DM_FLAGS_ISEM)
+#define DM_SEM_FLAG_WR	(DM_FLAGS_IALLOCSEM_WR | DM_FLAGS_ISEM)
+#else
+#define DM_SEM_FLAG_RD(ioflags) (((ioflags) & IO_ISDIRECT) ? \
+			      0 : DM_FLAGS_ISEM)
+#define DM_SEM_FLAG_WR	(DM_FLAGS_ISEM)
+#endif
 
 /*
  *	Macros to turn caller specified delay/block flags into
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_dmops.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_dmops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_dmops.c	2004-01-08 03:24:16.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_dmops.c	2004-03-03 04:52:57.000000000 +0000
@@ -43,7 +43,7 @@
 #include "xfs_dmapi.h"
 #include "xfs_mount.h"
 
-xfs_dmops_t	xfs_dmcore_xfs = {
+xfs_dmops_t	xfs_dmcore_stub = {
 	.xfs_send_data		= (xfs_send_data_t)fs_nosys,
 	.xfs_send_mmap		= (xfs_send_mmap_t)fs_noerr,
 	.xfs_send_destroy	= (xfs_send_destroy_t)fs_nosys,
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fs.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fs.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fs.h	2003-10-03 22:10:23.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fs.h	2004-02-27 06:28:05.000000000 +0000
@@ -437,6 +437,12 @@ typedef struct xfs_handle {
 
 #define FSHSIZE		sizeof(fsid_t)
 
+/* 
+ * Flags for going down operation
+ */
+#define XFS_FSOP_GOING_FLAGS_DEFAULT		0x0	/* going down */
+#define XFS_FSOP_GOING_FLAGS_LOGFLUSH		0x1	/* flush log but not data */
+#define XFS_FSOP_GOING_FLAGS_NOLOGFLUSH		0x2	/* don't flush log nor data */
 
 /*
  * ioctl commands that replace IRIX fcntl()'s
@@ -490,6 +496,7 @@ typedef struct xfs_handle {
 #define XFS_IOC_ATTRLIST_BY_HANDLE   _IOW ('X', 122, struct xfs_fsop_attrlist_handlereq)
 #define XFS_IOC_ATTRMULTI_BY_HANDLE  _IOW ('X', 123, struct xfs_fsop_attrmulti_handlereq)
 #define XFS_IOC_FSGEOMETRY	     _IOR ('X', 124, struct xfs_fsop_geom)
+#define XFS_IOC_GOINGDOWN	     _IOR ('X', 125, __uint32_t)
 /*	XFS_IOC_GETFSUUID ---------- deprecated 140	 */
 
 
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fsops.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fsops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fsops.c	2004-01-08 05:29:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fsops.c	2004-02-27 06:28:05.000000000 +0000
@@ -626,3 +626,28 @@ xfs_fs_thaw(
 	xfs_finish_freeze(mp);
 	return 0;
 }
+
+int
+xfs_fs_goingdown(
+	xfs_mount_t	*mp,
+	__uint32_t	inflags)
+{
+	switch (inflags)
+	{
+	case XFS_FSOP_GOING_FLAGS_DEFAULT:
+		xfs_fs_freeze(mp);
+		xfs_force_shutdown(mp, XFS_FORCE_UMOUNT);
+		xfs_fs_thaw(mp);
+		break;
+	case XFS_FSOP_GOING_FLAGS_LOGFLUSH:
+		xfs_force_shutdown(mp, XFS_FORCE_UMOUNT);
+		break;
+	case XFS_FSOP_GOING_FLAGS_NOLOGFLUSH:
+		xfs_force_shutdown(mp, XFS_FORCE_UMOUNT|XFS_LOG_IO_ERROR);
+		break;
+	default:
+		return XFS_ERROR(EINVAL);
+	}
+
+	return 0;
+}
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fsops.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fsops.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_fsops.h	2003-05-02 19:36:11.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_fsops.h	2004-02-27 06:28:05.000000000 +0000
@@ -67,4 +67,9 @@ int
 xfs_fs_thaw(
 	xfs_mount_t		*mp);
 
+int
+xfs_fs_goingdown(
+	xfs_mount_t		*mp,
+	__uint32_t		inflags);
+
 #endif	/* __XFS_FSOPS_H__ */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_iomap.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_iomap.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_iomap.c	2004-02-09 04:52:38.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_iomap.c	2004-02-27 06:36:03.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -69,6 +69,76 @@
 #include "xfs_utils.h"
 #include "xfs_iomap.h"
 
+#if defined(XFS_RW_TRACE)
+void
+xfs_iomap_enter_trace(
+	int		tag,
+	xfs_iocore_t	*io,
+	xfs_off_t	offset,
+	ssize_t		count)
+{
+	xfs_inode_t	*ip = XFS_IO_INODE(io);
+
+	if (!ip->i_rwtrace)
+		return;
+
+	ktrace_enter(ip->i_rwtrace,
+		(void *)((unsigned long)tag),
+		(void *)ip,
+		(void *)((unsigned long)((ip->i_d.di_size >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(ip->i_d.di_size & 0xffffffff)),
+		(void *)((unsigned long)((offset >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(offset & 0xffffffff)),
+		(void *)((unsigned long)count),
+		(void *)((unsigned long)((io->io_new_size >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(io->io_new_size & 0xffffffff)),
+		(void *)NULL,
+		(void *)NULL,
+		(void *)NULL,
+		(void *)NULL,
+		(void *)NULL,
+		(void *)NULL,
+		(void *)NULL);
+}
+
+void
+xfs_iomap_map_trace(
+	int		tag,
+	xfs_iocore_t	*io,
+	xfs_off_t	offset,
+	ssize_t		count,
+	xfs_iomap_t	*iomapp,
+	xfs_bmbt_irec_t	*imapp,
+	int		flags)
+{
+	xfs_inode_t	*ip = XFS_IO_INODE(io);
+
+	if (!ip->i_rwtrace)
+		return;
+
+	ktrace_enter(ip->i_rwtrace,
+		(void *)((unsigned long)tag),
+		(void *)ip,
+		(void *)((unsigned long)((ip->i_d.di_size >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(ip->i_d.di_size & 0xffffffff)),
+		(void *)((unsigned long)((offset >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(offset & 0xffffffff)),
+		(void *)((unsigned long)count),
+		(void *)((unsigned long)flags),
+		(void *)((unsigned long)((iomapp->iomap_offset >> 32) & 0xffffffff)),
+		(void *)((unsigned long)(iomapp->iomap_offset & 0xffffffff)),
+		(void *)((unsigned long)(iomapp->iomap_delta)),
+		(void *)((unsigned long)(iomapp->iomap_bsize)),
+		(void *)((unsigned long)(iomapp->iomap_bn)),
+		(void *)(__psint_t)(imapp->br_startoff),
+		(void *)((unsigned long)(imapp->br_blockcount)),
+		(void *)(__psint_t)(imapp->br_startblock));
+}
+#else
+#define xfs_iomap_enter_trace(tag, io, offset, count)
+#define xfs_iomap_map_trace(tag, io, offset, count, iomapp, imapp, flags)
+#endif
+
 #define XFS_WRITEIO_ALIGN(mp,off)	(((off) >> mp->m_writeio_log) \
 						<< mp->m_writeio_log)
 #define XFS_STRAT_WRITE_IMAPS	2
@@ -149,17 +219,20 @@ xfs_iomap(
 		(BMAPI_READ | BMAPI_WRITE | BMAPI_ALLOCATE |
 		 BMAPI_UNWRITTEN | BMAPI_DEVICE)) {
 	case BMAPI_READ:
+		xfs_iomap_enter_trace(XFS_IOMAP_READ_ENTER, io, offset, count);
 		lockmode = XFS_LCK_MAP_SHARED(mp, io);
 		bmapi_flags = XFS_BMAPI_ENTIRE;
 		if (flags & BMAPI_IGNSTATE)
 			bmapi_flags |= XFS_BMAPI_IGSTATE;
 		break;
 	case BMAPI_WRITE:
+		xfs_iomap_enter_trace(XFS_IOMAP_WRITE_ENTER, io, offset, count);
 		lockmode = XFS_ILOCK_EXCL|XFS_EXTSIZE_WR;
 		bmapi_flags = 0;
 		XFS_ILOCK(mp, io, lockmode);
 		break;
 	case BMAPI_ALLOCATE:
+		xfs_iomap_enter_trace(XFS_IOMAP_ALLOC_ENTER, io, offset, count);
 		lockmode = XFS_ILOCK_SHARED|XFS_EXTSIZE_RD;
 		bmapi_flags = XFS_BMAPI_ENTIRE;
 		/* Attempt non-blocking lock */
@@ -201,8 +274,11 @@ phase2:
 	switch (flags & (BMAPI_WRITE|BMAPI_ALLOCATE|BMAPI_UNWRITTEN)) {
 	case BMAPI_WRITE:
 		/* If we found an extent, return it */
-		if (nimaps && (imap.br_startblock != HOLESTARTBLOCK))
+		if (nimaps && (imap.br_startblock != HOLESTARTBLOCK)) {
+			xfs_iomap_map_trace(XFS_IOMAP_WRITE_MAP, io,
+					offset, count, iomapp, &imap, flags);
 			break;
+		}
 
 		if (flags & (BMAPI_DIRECT|BMAPI_MMAP)) {
 			error = XFS_IOMAP_WRITE_DIRECT(mp, io, offset,
@@ -211,6 +287,10 @@ phase2:
 			error = XFS_IOMAP_WRITE_DELAY(mp, io, offset, count,
 					flags, &imap, &nimaps);
 		}
+		if (!error) {
+			xfs_iomap_map_trace(XFS_IOMAP_ALLOC_MAP, io,
+					offset, count, iomapp, &imap, flags);
+		}
 		iomap_flags = IOMAP_NEW;
 		break;
 	case BMAPI_ALLOCATE:
@@ -218,8 +298,11 @@ phase2:
 		XFS_IUNLOCK(mp, io, lockmode);
 		lockmode = 0;
 
-		if (nimaps && !ISNULLSTARTBLOCK(imap.br_startblock))
+		if (nimaps && !ISNULLSTARTBLOCK(imap.br_startblock)) {
+			xfs_iomap_map_trace(XFS_IOMAP_WRITE_MAP, io,
+					offset, count, iomapp, &imap, flags);
 			break;
+		}
 
 		error = XFS_IOMAP_WRITE_ALLOCATE(mp, io, &imap, &nimaps);
 		break;
@@ -309,7 +392,6 @@ xfs_iomap_write_direct(
 	 * Make sure that the dquots are there. This doesn't hold
 	 * the ilock across a disk read.
 	 */
-
 	error = XFS_QM_DQATTACH(ip->i_mount, ip, XFS_QMOPT_ILOCKED);
 	if (error)
 		return XFS_ERROR(error);
@@ -540,8 +622,9 @@ retry:
 	 * If bmapi returned us nothing, and if we didn't get back EDQUOT,
 	 * then we must have run out of space.
 	 */
-
 	if (nimaps == 0) {
+		xfs_iomap_enter_trace(XFS_IOMAP_WRITE_NOSPACE,
+					io, offset, count);
 		if (xfs_flush_space(ip, &fsynced, &ioflag))
 			return XFS_ERROR(ENOSPC);
 
@@ -584,7 +667,6 @@ xfs_iomap_write_allocate(
 	/*
 	 * Make sure that the dquots are there.
 	 */
-
 	if ((error = XFS_QM_DQATTACH(mp, ip, 0)))
 		return XFS_ERROR(error);
 
@@ -612,7 +694,6 @@ xfs_iomap_write_allocate(
 					XFS_WRITE_LOG_RES(mp),
 					0, XFS_TRANS_PERM_LOG_RES,
 					XFS_WRITE_LOG_COUNT);
-
 			if (error == ENOSPC) {
 				error = xfs_trans_reserve(tp, 0,
 						XFS_WRITE_LOG_RES(mp),
@@ -653,19 +734,16 @@ xfs_iomap_write_allocate(
 			error = xfs_bmapi(tp, ip, map_start_fsb, count_fsb,
 					XFS_BMAPI_WRITE, &first_block, 1,
 					imap, &nimaps, &free_list);
-
 			if (error)
 				goto trans_cancel;
 
 			error = xfs_bmap_finish(&tp, &free_list,
 					first_block, &committed);
-
 			if (error)
 				goto trans_cancel;
 
 			error = xfs_trans_commit(tp,
 					XFS_TRANS_RELEASE_LOG_RES, NULL);
-
 			if (error)
 				goto error0;
 
@@ -725,6 +803,9 @@ xfs_iomap_write_unwritten(
 	xfs_fsblock_t	firstfsb;
 	xfs_bmap_free_t	free_list;
 
+	xfs_iomap_enter_trace(XFS_IOMAP_UNWRITTEN,
+				&ip->i_iocore, offset, count);
+
 	offset_fsb = XFS_B_TO_FSBT(mp, offset);
 	count_fsb = XFS_B_TO_FSB(mp, count);
 
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log.c	2004-01-08 23:27:04.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log.c	2004-03-02 05:42:14.000000000 +0000
@@ -759,8 +759,9 @@ xfs_log_move_tail(xfs_mount_t	*mp,
 	/* Also an invalid lsn.  1 implies that we aren't passing in a valid
 	 * tail_lsn.
 	 */
-	if (tail_lsn != 1)
+	if (tail_lsn != 1) {
 		log->l_tail_lsn = tail_lsn;
+	}
 
 	if ((tic = log->l_write_headq)) {
 #ifdef DEBUG
@@ -866,10 +867,11 @@ xlog_assign_tail_lsn(xfs_mount_t *mp)
 
 	tail_lsn = xfs_trans_tail_ail(mp);
 	s = GRANT_LOCK(log);
-	if (tail_lsn != 0)
+	if (tail_lsn != 0) {
 		log->l_tail_lsn = tail_lsn;
-	else
+	} else {
 		tail_lsn = log->l_tail_lsn = log->l_last_sync_lsn;
+	}
 	GRANT_UNLOCK(log, s);
 
 	return tail_lsn;
@@ -921,10 +923,8 @@ xlog_space_left(xlog_t *log, int cycle, 
 		 * In this case we just want to return the size of the
 		 * log as the amount of space left.
 		 */
-/* This assert does not take into account padding from striped log writes *
 		ASSERT((tail_cycle == (cycle + 1)) ||
 		       ((bytes + log->l_roundoff) >= tail_bytes));
-*/
 		free_bytes = log->l_logsize;
 	}
 	return free_bytes;
@@ -1183,14 +1183,6 @@ xlog_alloc_log(xfs_mount_t	*mp,
 	log->l_grant_reserve_cycle = 1;
 	log->l_grant_write_cycle = 1;
 
-	if (XFS_SB_VERSION_HASLOGV2(&mp->m_sb)) {
-		if (mp->m_sb.sb_logsunit <= 1) {
-			log->l_stripemask = 1;
-		} else {
-			log->l_stripemask = 1 <<
-				xfs_highbit32(mp->m_sb.sb_logsunit >> BBSHIFT);
-		}
-	}
 	if (XFS_SB_VERSION_HASSECTOR(&mp->m_sb)) {
 		log->l_sectbb_log = mp->m_sb.sb_logsectlog - BBSHIFT;
 		ASSERT(log->l_sectbb_log <= mp->m_sectbb_log);
@@ -1401,45 +1393,35 @@ xlog_sync(xlog_t		*log,
 	xfs_caddr_t	dptr;		/* pointer to byte sized element */
 	xfs_buf_t	*bp;
 	int		i, ops;
-	uint		roundup;
 	uint		count;		/* byte count of bwrite */
+	uint		count_init;	/* initial count before roundup */
 	int		split = 0;	/* split write into two regions */
 	int		error;
 
 	XFS_STATS_INC(xs_log_writes);
 	ASSERT(iclog->ic_refcnt == 0);
 
+	/* Add for LR header */
+	count_init = log->l_iclog_hsize + iclog->ic_offset;
+
 	/* Round out the log write size */
-	if (iclog->ic_offset & BBMASK) {
-		/* count of 0 is already accounted for up in
-		 * xlog_state_sync_all().  Once in this routine,
-		 * operations on the iclog are single threaded.
-		 *
-		 * Difference between rounded up size and size
-		 */
-		count = iclog->ic_offset & BBMASK;
-		iclog->ic_roundoff += BBSIZE - count;
-	}
-	if (XFS_SB_VERSION_HASLOGV2(&log->l_mp->m_sb)) {
-		unsigned sunit = BTOBB(log->l_mp->m_sb.sb_logsunit);
-		if (!sunit)
-			sunit = 1;
-
-		count = BTOBB(log->l_iclog_hsize + iclog->ic_offset);
-		if (count & (sunit - 1)) {
-			roundup = sunit - (count & (sunit - 1));
-		} else {
-			roundup = 0;
-		}
-		iclog->ic_offset += BBTOB(roundup);
+	if (XFS_SB_VERSION_HASLOGV2(&log->l_mp->m_sb) &&
+	    log->l_mp->m_sb.sb_logsunit > 1) {
+		/* we have a v2 stripe unit to use */
+		count = XLOG_LSUNITTOB(log, XLOG_BTOLSUNIT(log, count_init));
+	} else {
+		count = BBTOB(BTOBB(count_init));
 	}
-
+	iclog->ic_roundoff = count - count_init;
 	log->l_roundoff += iclog->ic_roundoff;
 
 	xlog_pack_data(log, iclog);       /* put cycle number in every block */
 
 	/* real byte length */
-	INT_SET(iclog->ic_header.h_len, ARCH_CONVERT, iclog->ic_offset);
+	INT_SET(iclog->ic_header.h_len, 
+		ARCH_CONVERT,
+		iclog->ic_offset + iclog->ic_roundoff);
+
 	/* put ops count in correct order */
 	ops = iclog->ic_header.h_num_logops;
 	INT_SET(iclog->ic_header.h_num_logops, ARCH_CONVERT, ops);
@@ -1449,12 +1431,6 @@ xlog_sync(xlog_t		*log,
 	XFS_BUF_SET_FSPRIVATE2(bp, (unsigned long)2);
 	XFS_BUF_SET_ADDR(bp, BLOCK_LSN(iclog->ic_header.h_lsn, ARCH_CONVERT));
 
-	/* Count is already rounded up to a BBSIZE above */
-	count = iclog->ic_offset + iclog->ic_roundoff;
-	ASSERT((count & BBMASK) == 0);
-
-	/* Add for LR header */
-	count += log->l_iclog_hsize;
 	XFS_STATS_ADD(xs_log_blocks, BTOBB(count));
 
 	/* Do we need to split this write into 2 parts? */
@@ -2783,8 +2759,6 @@ xlog_state_switch_iclogs(xlog_t		*log,
 			 xlog_in_core_t *iclog,
 			 int		eventual_size)
 {
-	uint roundup;
-
 	ASSERT(iclog->ic_state == XLOG_STATE_ACTIVE);
 	if (!eventual_size)
 		eventual_size = iclog->ic_offset;
@@ -2797,14 +2771,10 @@ xlog_state_switch_iclogs(xlog_t		*log,
 	log->l_curr_block += BTOBB(eventual_size)+BTOBB(log->l_iclog_hsize);
 
 	/* Round up to next log-sunit */
-	if (XFS_SB_VERSION_HASLOGV2(&log->l_mp->m_sb)) {
-		if (log->l_curr_block & (log->l_stripemask - 1)) {
-			roundup = log->l_stripemask -
-				(log->l_curr_block & (log->l_stripemask - 1));
-		} else {
-			roundup = 0;
-		}
-		log->l_curr_block += roundup;
+	if (XFS_SB_VERSION_HASLOGV2(&log->l_mp->m_sb) &&
+	    log->l_mp->m_sb.sb_logsunit > 1) {
+		__uint32_t sunit_bb = BTOBB(log->l_mp->m_sb.sb_logsunit);
+		log->l_curr_block = roundup(log->l_curr_block, sunit_bb);
 	}
 
 	if (log->l_curr_block >= log->l_logBBsize) {
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log_priv.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log_priv.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log_priv.h	2004-01-08 02:54:31.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log_priv.h	2004-03-02 05:42:15.000000000 +0000
@@ -63,6 +63,9 @@ int xlog_btolrbb(int b);
 #else
 #define XLOG_BTOLRBB(b)		(((b)+XLOG_RECORD_BSIZE-1) >> XLOG_RECORD_BSHIFT)
 #endif
+#define XLOG_BTOLSUNIT(log, b)  (((b)+(log)->l_mp->m_sb.sb_logsunit-1) / \
+                                 (log)->l_mp->m_sb.sb_logsunit)
+#define XLOG_LSUNITTOB(log, su) ((su) * (log)->l_mp->m_sb.sb_logsunit)
 
 #define XLOG_HEADER_SIZE	512
 
@@ -531,7 +534,6 @@ typedef struct log {
 	uint			l_flags;
 	uint			l_quotaoffs_flag; /* XFS_DQ_*, for QUOTAOFFs */
 	struct xfs_buf_cancel	**l_buf_cancel_table;
-	int			l_stripemask;	/* log stripe mask */
 	int			l_iclog_hsize;  /* size of iclog header */
 	int			l_iclog_heads;  /* # of iclog header sectors */
 	uint			l_sectbb_log;   /* log2 of sector size in BBs */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log_recover.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log_recover.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_log_recover.c	2004-01-30 01:53:43.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_log_recover.c	2004-03-02 05:52:55.000000000 +0000
@@ -3416,6 +3416,7 @@ xlog_unpack_data_checksum(
 {
 	uint			*up = (uint *)dp;
 	uint			chksum = 0;
+	int			i;
 
 	/* divide length by 4 to get # words */
 	for (i=0; i < INT_GET(rhead->h_len, ARCH_CONVERT) >> 2; i++) {
@@ -3476,7 +3477,7 @@ xlog_valid_rec_header(
 	xlog_rec_header_t	*rhead,
 	xfs_daddr_t		blkno)
 {
-	int			bblks;
+	int			hlen;
 
 	if (unlikely(
 	    (INT_GET(rhead->h_magicno, ARCH_CONVERT) !=
@@ -3495,8 +3496,8 @@ xlog_valid_rec_header(
 	}
 
 	/* LR body must have data or it wouldn't have been written */
-	bblks = INT_GET(rhead->h_len, ARCH_CONVERT);
-	if (unlikely( bblks <= 0 || bblks > INT_MAX )) {
+	hlen = INT_GET(rhead->h_len, ARCH_CONVERT);
+	if (unlikely( hlen <= 0 || hlen > INT_MAX )) {
 		XFS_ERROR_REPORT("xlog_valid_rec_header(2)",
 				XFS_ERRLEVEL_LOW, log->l_mp);
 		return XFS_ERROR(EFSCORRUPTED);
@@ -3658,7 +3659,7 @@ xlog_do_recovery_pass(
 				error = xlog_bread(log, 0, wrapped_hblks, hbp);
 				if (error)
 					goto bread_err2;
-				XFS_BUF_SET_PTR(hbp, bufaddr, hblks);
+				XFS_BUF_SET_PTR(hbp, bufaddr, BBTOB(hblks));
 				if (!offset)
 					offset = xlog_align(log, 0,
 							wrapped_hblks, hbp);
@@ -3716,8 +3717,7 @@ xlog_do_recovery_pass(
 				if ((error = xlog_bread(log, wrapped_hblks,
 						bblks - split_bblks, dbp)))
 					goto bread_err2;
-				XFS_BUF_SET_PTR(dbp, bufaddr,
-						XLOG_BIG_RECORD_BSIZE);
+				XFS_BUF_SET_PTR(dbp, bufaddr, h_size);
 				if (!offset)
 					offset = xlog_align(log, wrapped_hblks,
 						bblks - split_bblks, dbp);
@@ -4042,7 +4042,7 @@ xlog_recover_check_summary(
 				XFS_FSS_TO_BB(mp, 1), 0);
 		if (XFS_BUF_ISERROR(agibp)) {
 			xfs_ioerror_alert("xlog_recover_check_summary(agi)",
-					  log->l_mp, agibp, agidaddr);
+					  mp, agibp, agidaddr);
 		}
 		agip = XFS_BUF_TO_AGI(agibp);
 		ASSERT(XFS_AGI_MAGIC ==
@@ -4058,7 +4058,8 @@ xlog_recover_check_summary(
 
 	sbbp = xfs_getsb(mp, 0);
 #ifdef XFS_LOUD_RECOVERY
-	sbp = XFS_BUF_TO_SBP(sbbp);
+	sbp = &mp->m_sb;
+	xfs_xlatesb(XFS_BUF_TO_SBP(sbbp), sbp, 1, ARCH_CONVERT, XFS_SB_ALL_BITS);
 	cmn_err(CE_NOTE,
 		"xlog_recover_check_summary: sb_icount %Lu itotal %Lu",
 		sbp->sb_icount, itotal);
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_mount.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_mount.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_mount.c	2004-01-09 05:57:01.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_mount.c	2004-02-27 06:54:47.000000000 +0000
@@ -675,6 +675,7 @@ xfs_mountfs(
 				error = XFS_ERROR(EINVAL);
 				goto error1;
 			}
+			mp->m_dalign = mp->m_swidth = 0;
 		} else {
 			/*
 			 * Convert the stripe unit and width to FSBs.
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_mount.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_mount.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_mount.h	2003-10-06 18:49:18.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_mount.h	2004-03-03 04:52:57.000000000 +0000
@@ -571,8 +571,8 @@ extern void	xfs_check_frozen(xfs_mount_t
 extern struct vfsops xfs_vfsops;
 extern struct vnodeops xfs_vnodeops;
 
-extern struct xfs_dmops xfs_dmcore_xfs;
-extern struct xfs_qmops xfs_qmcore_xfs;
+extern struct xfs_dmops xfs_dmcore_stub;
+extern struct xfs_qmops xfs_qmcore_stub;
 extern struct xfs_ioops xfs_iocore_xfs;
 
 extern int	xfs_init(void);
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_qmops.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_qmops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_qmops.c	2004-01-08 03:24:16.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_qmops.c	2004-03-03 04:52:57.000000000 +0000
@@ -54,7 +54,7 @@ xfs_dqvopchown_default(
 	return NULL;
 }
 
-xfs_qmops_t	xfs_qmcore_xfs = {
+xfs_qmops_t	xfs_qmcore_stub = {
 	.xfs_qminit		= (xfs_qminit_t) fs_noerr,
 	.xfs_qmdone		= (xfs_qmdone_t) fs_noerr,
 	.xfs_qmmount		= (xfs_qmmount_t) fs_noerr,
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_quota.h linux-post-2.6.4rc1-20040303/fs/xfs/xfs_quota.h
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_quota.h	2003-05-02 19:36:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_quota.h	2004-03-03 04:52:57.000000000 +0000
@@ -347,9 +347,6 @@ extern int xfs_qm_dqcheck(xfs_disk_dquot
 
 extern struct bhv_vfsops xfs_qmops;
 
-extern void xfs_qm_init(void);
-extern void xfs_qm_exit(void);
-
 #endif	/* __KERNEL__ */
 
 #endif	/* __XFS_QUOTA_H__ */
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_vfsops.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_vfsops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_vfsops.c	2004-01-30 03:12:47.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_vfsops.c	2004-03-03 04:52:58.000000000 +0000
@@ -451,9 +451,9 @@ xfs_mount(
 	 * Setup xfs_mount function vectors from available behaviors
 	 */
 	p = vfs_bhv_lookup(vfsp, VFS_POSITION_DM);
-	mp->m_dm_ops = p ? *(xfs_dmops_t *) vfs_bhv_custom(p) : xfs_dmcore_xfs;
+	mp->m_dm_ops = p ? *(xfs_dmops_t *) vfs_bhv_custom(p) : xfs_dmcore_stub;
 	p = vfs_bhv_lookup(vfsp, VFS_POSITION_QM);
-	mp->m_qm_ops = p ? *(xfs_qmops_t *) vfs_bhv_custom(p) : xfs_qmcore_xfs;
+	mp->m_qm_ops = p ? *(xfs_qmops_t *) vfs_bhv_custom(p) : xfs_qmcore_stub;
 	p = vfs_bhv_lookup(vfsp, VFS_POSITION_IO);
 	mp->m_io_ops = p ? *(xfs_ioops_t *) vfs_bhv_custom(p) : xfs_iocore_xfs;
 
@@ -792,8 +792,9 @@ xfs_statvfs(
 #if XFS_BIG_INUMS
 		if (!mp->m_inoadd)
 #endif
-			statp->f_files =
-			    min_t(sector_t, statp->f_files, mp->m_maxicount);
+			statp->f_files = min_t(typeof(statp->f_files),
+						statp->f_files,
+						mp->m_maxicount);
 	statp->f_ffree = statp->f_files - (sbp->sb_icount - sbp->sb_ifree);
 	XFS_SB_UNLOCK(mp, s);
 
diff -purN linux-post-2.6.4rc1-20040302/fs/xfs/xfs_vnodeops.c linux-post-2.6.4rc1-20040303/fs/xfs/xfs_vnodeops.c
--- linux-post-2.6.4rc1-20040302/fs/xfs/xfs_vnodeops.c	2004-01-08 06:09:41.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/fs/xfs/xfs_vnodeops.c	2004-03-02 05:35:29.000000000 +0000
@@ -413,8 +413,9 @@ xfs_setattr(
 	} else {
 		if (DM_EVENT_ENABLED (vp->v_vfsp, ip, DM_EVENT_TRUNCATE) &&
 		    !(flags & ATTR_DMI)) {
+			int dmflags = AT_DELAY_FLAG(flags) | DM_SEM_FLAG_WR;
 			code = XFS_SEND_DATA(mp, DM_EVENT_TRUNCATE, vp,
-				vap->va_size, 0, AT_DELAY_FLAG(flags), NULL);
+				vap->va_size, 0, dmflags, NULL);
 			if (code) {
 				lock_flags = 0;
 				goto error_return;
diff -purN linux-post-2.6.4rc1-20040302/include/asm-alpha/semaphore.h linux-post-2.6.4rc1-20040303/include/asm-alpha/semaphore.h
--- linux-post-2.6.4rc1-20040302/include/asm-alpha/semaphore.h	2003-09-04 06:40:12.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/include/asm-alpha/semaphore.h	2004-02-28 23:25:49.000000000 +0000
@@ -16,10 +16,7 @@
 #include <linux/rwsem.h>
 
 struct semaphore {
-	/* Careful, inline assembly knows about the position of these two.  */
-	atomic_t count __attribute__((aligned(8)));
-	atomic_t waking;		/* biased by -1 */
-
+	atomic_t count;
 	wait_queue_head_t wait;
 #if WAITQUEUE_DEBUG
 	long __magic;
@@ -33,18 +30,18 @@ struct semaphore {
 #endif
 
 #define __SEMAPHORE_INITIALIZER(name,count)		\
-	{ ATOMIC_INIT(count), ATOMIC_INIT(-1),		\
+	{ ATOMIC_INIT(count),				\
 	  __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
 	  __SEM_DEBUG_INIT(name) }
 
-#define __MUTEX_INITIALIZER(name) \
+#define __MUTEX_INITIALIZER(name)			\
 	__SEMAPHORE_INITIALIZER(name,1)
 
-#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+#define __DECLARE_SEMAPHORE_GENERIC(name,count)		\
 	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
 
-#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
-#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+#define DECLARE_MUTEX(name)		__DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name)	__DECLARE_SEMAPHORE_GENERIC(name,0)
 
 static inline void sema_init(struct semaphore *sem, int val)
 {
@@ -55,7 +52,6 @@ static inline void sema_init(struct sema
 	 */
 
 	atomic_set(&sem->count, val);
-	atomic_set(&sem->waking, -1);
 	init_waitqueue_head(&sem->wait);
 #if WAITQUEUE_DEBUG
 	sem->__magic = (long)&sem->__magic;
@@ -107,102 +103,42 @@ static inline int __down_interruptible(s
 
 /*
  * down_trylock returns 0 on success, 1 if we failed to get the lock.
- *
- * We must manipulate count and waking simultaneously and atomically.
- * Do this by using ll/sc on the pair of 32-bit words.
  */
 
-static inline int __down_trylock(struct semaphore * sem)
+static inline int __down_trylock(struct semaphore *sem)
 {
-	long ret, tmp, tmp2, sub;
+	long ret;
 
-	/* "Equivalent" C.  Note that we have to do this all without
-	   (taken) branches in order to be a valid ll/sc sequence.
+	/* "Equivalent" C:
 
 	   do {
-		tmp = ldq_l;
-		sub = 0x0000000100000000;	
-		ret = ((int)tmp <= 0);		// count <= 0 ?
-		// Note that if count=0, the decrement overflows into
-		// waking, so cancel the 1 loaded above.  Also cancel
-		// it if the lock was already free.
-		if ((int)tmp >= 0) sub = 0;	// count >= 0 ?
-		ret &= ((long)tmp < 0);		// waking < 0 ?
-		sub += 1;
-		if (ret) break;	
-		tmp -= sub;
-		tmp = stq_c = tmp;
-	   } while (tmp == 0);
+		ret = ldl_l;
+		--ret;
+		if (ret < 0)
+			break;
+		ret = stl_c = ret;
+	   } while (ret == 0);
 	*/
-
 	__asm__ __volatile__(
-		"1:	ldq_l	%1,%4\n"
-		"	lda	%3,1\n"
-		"	addl	%1,0,%2\n"
-		"	sll	%3,32,%3\n"
-		"	cmple	%2,0,%0\n"
-		"	cmovge	%2,0,%3\n"
-		"	cmplt	%1,0,%2\n"
-		"	addq	%3,1,%3\n"
-		"	and	%0,%2,%0\n"
-		"	bne	%0,2f\n"
-		"	subq	%1,%3,%1\n"
-		"	stq_c	%1,%4\n"
-		"	beq	%1,3f\n"
-		"2:	mb\n"
+		"1:	ldl_l	%0,%1\n"
+		"	subl	%0,1,%0\n"
+		"	blt	%0,2f\n"
+		"	stl_c	%0,%1\n"
+		"	beq	%0,3f\n"
+		"	mb\n"
+		"2:\n"
 		".subsection 2\n"
 		"3:	br	1b\n"
 		".previous"
-		: "=&r"(ret), "=&r"(tmp), "=&r"(tmp2), "=&r"(sub)
-		: "m"(*sem)
-		: "memory");
+		: "=&r" (ret), "=m" (sem->count)
+		: "m" (sem->count));
 
-	return ret;
+	return ret < 0;
 }
 
 static inline void __up(struct semaphore *sem)
 {
-	long ret, tmp, tmp2, tmp3;
-
-	/* We must manipulate count and waking simultaneously and atomically.
-	   Otherwise we have races between up and __down_failed_interruptible
-	   waking up on a signal.
-
-	   "Equivalent" C.  Note that we have to do this all without
-	   (taken) branches in order to be a valid ll/sc sequence.
-
-	   do {
-		tmp = ldq_l;
-		ret = (int)tmp + 1;			// count += 1;
-		tmp2 = tmp & 0xffffffff00000000;	// extract waking
-		if (ret <= 0)				// still sleepers?
-			tmp2 += 0x0000000100000000;	// waking += 1;
-		tmp = ret & 0x00000000ffffffff;		// insert count
-		tmp |= tmp2;				// insert waking;
-	       tmp = stq_c = tmp;
-	   } while (tmp == 0);
-	*/
-
-	__asm__ __volatile__(
-		"	mb\n"
-		"1:	ldq_l	%1,%4\n"
-		"	addl	%1,1,%0\n"
-		"	zapnot	%1,0xf0,%2\n"
-		"	addq	%2,%5,%3\n"
-		"	cmovle	%0,%3,%2\n"
-		"	zapnot	%0,0x0f,%1\n"
-		"	bis	%1,%2,%1\n"
-		"	stq_c	%1,%4\n"
-		"	beq	%1,3f\n"
-		"2:\n"
-		".subsection 2\n"
-		"3:	br	1b\n"
-		".previous"
-		: "=&r"(ret), "=&r"(tmp), "=&r"(tmp2), "=&r"(tmp3)
-		: "m"(*sem), "r"(0x0000000100000000)
-		: "memory");
-
-	if (unlikely(ret <= 0))
+	if (unlikely(atomic_inc_return(&sem->count) <= 0))
 		__up_wakeup(sem);
 }
 
diff -purN linux-post-2.6.4rc1-20040302/include/linux/pci.h linux-post-2.6.4rc1-20040303/include/linux/pci.h
--- linux-post-2.6.4rc1-20040302/include/linux/pci.h	2004-02-18 23:41:55.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/include/linux/pci.h	2004-03-03 01:26:11.000000000 +0000
@@ -199,6 +199,7 @@
 #define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
 #define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
 #define  PCI_CAP_ID_PCIX	0x07	/* PCI-X */
+#define  PCI_CAP_ID_SHPC 	0x0C	/* PCI Standard Hot-Plug Controller */
 #define  PCI_CAP_ID_EXP 	0x10	/* PCI Express */
 #define  PCI_CAP_ID_MSIX	0x11	/* MSI-X */
 #define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
diff -purN linux-post-2.6.4rc1-20040302/include/linux/sysdev.h linux-post-2.6.4rc1-20040303/include/linux/sysdev.h
--- linux-post-2.6.4rc1-20040302/include/linux/sysdev.h	2003-08-20 06:23:33.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/include/linux/sysdev.h	2004-02-13 06:18:02.000000000 +0000
@@ -70,8 +70,8 @@ struct sys_device {
 	struct kobject		kobj;
 };
 
-extern int sys_device_register(struct sys_device *);
-extern void sys_device_unregister(struct sys_device *);
+extern int sysdev_register(struct sys_device *);
+extern void sysdev_unregister(struct sys_device *);
 
 
 struct sysdev_attribute { 
diff -purN linux-post-2.6.4rc1-20040302/lib/kobject.c linux-post-2.6.4rc1-20040303/lib/kobject.c
--- linux-post-2.6.4rc1-20040302/lib/kobject.c	2004-02-02 15:29:54.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/lib/kobject.c	2004-02-27 19:18:02.000000000 +0000
@@ -185,8 +185,8 @@ static void kset_hotplug(const char *act
 		}
 	}
 
-	pr_debug ("%s: %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
-		  envp[0], envp[1], envp[2], envp[3]);
+	pr_debug ("%s: %s %s %s %s %s %s %s\n", __FUNCTION__, argv[0], argv[1],
+		  envp[0], envp[1], envp[2], envp[3], envp[4]);
 	retval = call_usermodehelper (argv[0], argv, envp, 0);
 	if (retval)
 		pr_debug ("%s - call_usermodehelper returned %d\n",
@@ -425,14 +425,11 @@ void kobject_unregister(struct kobject *
 
 struct kobject * kobject_get(struct kobject * kobj)
 {
-	struct kobject * ret = kobj;
-
 	if (kobj) {
 		WARN_ON(!atomic_read(&kobj->refcount));
 		atomic_inc(&kobj->refcount);
-	} else
-		ret = NULL;
-	return ret;
+	}
+	return kobj;
 }
 
 /**
diff -purN linux-post-2.6.4rc1-20040302/sound/oss/dmasound/dac3550a.c linux-post-2.6.4rc1-20040303/sound/oss/dmasound/dac3550a.c
--- linux-post-2.6.4rc1-20040302/sound/oss/dmasound/dac3550a.c	2003-09-30 00:25:28.000000000 +0000
+++ linux-post-2.6.4rc1-20040303/sound/oss/dmasound/dac3550a.c	2004-03-02 21:32:04.000000000 +0000
@@ -42,11 +42,6 @@ static int daca_detach_client(struct i2c
 /* Unique ID allocation */
 static int daca_id;
 
-struct daca_data
-{
-	int arf; /* place holder for furture use */
-};
-
 struct i2c_driver daca_driver = {  
 	.owner			= THIS_MODULE,
 	.name			= "DAC3550A driver  V " DACA_VERSION,
@@ -168,12 +163,12 @@ static int daca_detect_client(struct i2c
 {
 	const char *client_name = "DAC 3550A Digital Equalizer";
 	struct i2c_client *new_client;
-	struct daca_data *data;
 	int rc = -ENODEV;
 
-	new_client = kmalloc(sizeof(*new_client) + sizeof(*data), GFP_KERNEL);
+	new_client = kmalloc(sizeof(*new_client), GFP_KERNEL);
 	if (!new_client)
 		return -ENOMEM;
+	memset(new_client, 0, sizeof(*new_client));
 
 	new_client->addr = address;
 	new_client->adapter = adapter;
@@ -182,9 +177,6 @@ static int daca_detect_client(struct i2c
 	strcpy(new_client->name, client_name);
 	new_client->id = daca_id++; /* racy... */
 
-	data = (struct daca_data *)(new_client+1);
-	dev_set_drvdata(&new_client->dev, data);
-
 	if (daca_init_client(new_client))
 		goto bail;
 

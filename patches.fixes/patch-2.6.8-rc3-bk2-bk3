
 Documentation/crypto/api-intro.txt |    2 
 Makefile                           |    2 
 arch/i386/Makefile                 |    3 
 arch/i386/crypto/Makefile          |    9 
 arch/i386/crypto/aes-i586-asm.S    |  341 ++++++++++++++++++++++++
 arch/i386/crypto/aes.c             |  520 +++++++++++++++++++++++++++++++++++++
 crypto/Kconfig                     |   22 +
 7 files changed, 896 insertions(+), 3 deletions(-)

# --- /mirror/kernel/v2.6/snapshots/patch-2.6.8-rc3-bk2.log	2004-08-07 11:28:00.000000000 +0200
# +++ /mirror/kernel/v2.6/snapshots/patch-2.6.8-rc3-bk3.log	2004-08-08 11:28:00.000000000 +0200
# @@ -1,4 +1,547 @@
# -ChangeSet@1.1900, 2004-08-06 09:46:07-07:00, jmorris@redhat.com
# +ChangeSet@1.1949, 2004-08-07 23:43:47-07:00, torvalds@ppc970.osdl.org
# +  Make sysctl pass the pos pointer around properly.
# +  
# +  Nobody ever fixed the big FIXME in sysctl - but we really need
# +  to pass around the proper "loff_t *" to all the sysctl functions
# +  if we want them to be well-behaved wrt the file pointer position.
# +  
# +  This is all preparation for making direct f_pos accesses go
# +  away.
# +
# +ChangeSet@1.1948, 2004-08-07 19:15:08-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +  [PATCH] mpoa patch done right
# +  
# +   - conversion to seq_file, overflow fixes
# +   - qos_parse sanitized (3 sscanf calls instead of insane manual parsing)
# +  	leaks plugged
# +  	code cleaned up
# +  
# +  We still have serious races, but they are general problem in atm code - it
# +  has no locking whatsoever for any of the lists (mpcs, qos_head, per-client
# +  lists).
# +
# +ChangeSet@1.1947, 2004-08-07 19:14:56-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +  [PATCH] Teach sscanf about 'hh' and 'll'
# +  
# +  Adds support for 'hh' (store number in char *) and 'll' (proper C99 for
# +  long long) modifiers to sscanf().
# +
# +ChangeSet@1.1946, 2004-08-07 19:11:39-07:00, torvalds@ppc970.osdl.org
# +  Fix up a couple of drivers - notable sg - for nonseekability.
# +
# +ChangeSet@1.1945, 2004-08-07 19:09:26-07:00, torvalds@ppc970.osdl.org
# +  The seq_file code already disabled pread/pwrite access,
# +  no need for the mtrr code to check any more.
# +
# +ChangeSet@1.1944, 2004-08-07 19:08:24-07:00, torvalds@ppc970.osdl.org
# +  Mark the sunrpc cache control file nonseekable, and
# +  remove the run-time tests for it.
# +
# +ChangeSet@1.1943, 2004-08-07 19:07:42-07:00, torvalds@ppc970.osdl.org
# +  Character device tape drivers are non-lseekable.
# +  
# +  You can seek the tape, but you do it with the magic tape
# +  control ioctl's, not with lseek/pread/pwrite.
# +
# +ChangeSet@1.1942, 2004-08-07 19:06:26-07:00, torvalds@ppc970.osdl.org
# +  Mark tty's as being non-seekable, and remove the now
# +  unnecessary tests at read/write time.
# +
# +ChangeSet@1.1941, 2004-08-07 19:05:19-07:00, torvalds@ppc970.osdl.org
# +  Teach sendfile() to honour non-seekable source files.
# +  
# +  Remove the test from the socket code, now that it's no
# +  longer necessary.
# +
# +ChangeSet@1.1940, 2004-08-07 18:54:18-07:00, torvalds@ppc970.osdl.org
# +  Add "nonseekable_open()" helper functions for nonseekable
# +  file descriptors.
# +
# +ChangeSet@1.1939, 2004-08-07 16:08:23-07:00, torvalds@ppc970.osdl.org
# +  Add pread/pwrite support bits to match the lseek bit.
# +  
# +  This also removes the ESPIPE logic from pipes and seq_files,
# +  since the VFS layer now supports it. 
# +
# +ChangeSet@1.1938, 2004-08-07 15:02:35-07:00, mporter@kernel.crashing.org
# +  [PATCH] ppc32: add PPC4xx DMA engine library
# +  
# +  Adds a cleaned up version of the PPC4xx DMA engine library.  Converted to
# +  new DCR access method and DMA API.
# +  
# +  Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1937, 2004-08-07 14:58:35-07:00, mporter@kernel.crashing.org
# +  [PATCH] ppc32: remove pci-dma.c
# +  
# +  Remove pci-dma.c.  It is cruft left over from the DMA API changes.
# +  
# +  Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1936, 2004-08-07 14:58:23-07:00, geoffrey.levand@am.sony.com
# +  [PATCH] ppc32: fix ebony uart clock
# +  
# +  This patch corrects the Ebony board's uart clock value to the rate of the
# +  external Epson SG-615P clock source.  Now good to 115Kbps.
# +  
# +  Signed-off-by: Geoff Levand <geoffrey.levand@am.sony.com> for CELF
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1935, 2004-08-07 14:58:12-07:00, mporter@kernel.crashing.org
# +  [PATCH] ppc32: clean up PPC44x mmu_mapin_ram()
# +  
# +  Remove some old cruft in the kernel lowmem mapping code and save some
# +  memory in the process.
# +  
# +  Signed-off-by: Matt Porter <mporter@kernel.crashing.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1934, 2004-08-07 14:58:01-07:00, haveblue@us.ibm.com
# +  [PATCH] ppc64: suppress unused var warning in get_irq_server()
# +  
# +  When normal IRQ balancing is used, the following warnings appear:
# +  
# +  arch/ppc64/kernel/xics.c: In function `get_irq_server':
# +  arch/ppc64/kernel/xics.c:242: warning: unused variable `cpumask'
# +  arch/ppc64/kernel/xics.c:243: warning: unused variable `tmp'
# +  
# +  Simply move the variables inside the #ifdef
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1933, 2004-08-07 14:57:50-07:00, haveblue@us.ibm.com
# +  [PATCH] ppc64: move SPINLINE out of global menu
# +  
# +  This somehow ended up out in the global Kconfig menu.  Move it back inside
# +  debugging where it belongs.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1932, 2004-08-07 14:57:38-07:00, anton@samba.org
# +  [PATCH] ppc64: suppress 'store_purr' unused warning
# +  
# +  Some new sysfs macros declare a store_purr() function that never gets used,
# +  which makes a compiler warning happen.  Suppress the warning with the used
# +  attribute.
# +  
# +  Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1931, 2004-08-07 14:57:27-07:00, anton@samba.org
# +  [PATCH] ppc64: fix chrp_progress mismerge
# +  
# +  Due to a mismerge, some code in chrp_progress appears twice. While here,
# +  clean up some formatting issues.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1930, 2004-08-07 14:57:15-07:00, anton@samba.org
# +  [PATCH] ppc64: set SMT thread priority to medium for all exceptions
# +  
# +  We need to set the thread priority to medium when entering all exceptions. 
# +  We may have been executing in low priority (eg the idle loop), but
# +  definitely do not want to remain in that priority for the duration of the
# +  exception (eg a device interrupt).
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1929, 2004-08-07 14:57:04-07:00, anton@samba.org
# +  [PATCH] ppc64: avoid speculative execution after rfid
# +  
# +  Due to speculative execution, a CPU may execute some instructions after the
# +  rfid.  This makes profiles confusing, since profiling ticks could end up in
# +  those instructions following the rfid that are never executed.
# +  
# +  Add a branch to self after each rfid to avoid this.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1928, 2004-08-07 14:56:54-07:00, anton@samba.org
# +  [PATCH] ppc64: fix PCI allocation warning
# +  
# +  Print the correct domain when a PCI resource allocation fails.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1927, 2004-08-07 14:56:42-07:00, anton@samba.org
# +  [PATCH] ppc64: various XICS fixes
# +  
# +  - Remove unused includes.
# +  - Be consistent about printing irq numbers, avoid a mix of decimal and
# +    hexadecimal.
# +  - Remove prototypes from xics.c, they should be in xics.h.
# +  - Remove infinite loop on failure, and instead use panic. Panic has a chance to
# +    log the error message on the LED panel and reboot the box, a while(1) loop
# +    does not.
# +  - xics isnt compiled for iseries any more, so no need for the
# +    CONFIG_PPC_PSERIES hack.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1926, 2004-08-07 14:56:31-07:00, jhe@us.ibm.com
# +  [PATCH] ppc64: 32-bit ptrace geteventmsg fix
# +  
# +  Here's a fix for the 32-bit PTRACE_GETEVENTMSG ptrace call that handles the
# +  passing of a 32-bit user address.  Please apply, thanks.
# +  
# +  Signed-off-by: John Engel <jhe@us.ibm.com>
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1925, 2004-08-07 14:56:22-07:00, paulus@samba.org
# +  [PATCH] ppc64: pci_dn cleanups
# +  
# +  This patch just cleans up arch/ppc64/kernel/pci_dn.c a bit, including:
# +  	- remove it from the iSeries build completely
# +  	- small changes to Makefile
# +  	- remove the "post" parameter from traverse_pci_devices as
# +  	  noone used it
# +  	- make traverse_all_pci_devices static
# +  	- remove CONFIG_PPC_PSERIES tests as we no longer build for iSeries
# +  	- some reformatting (closer to "standard")
# +  	- remove some of pointer casts
# +  
# +  This has been built (with default config) on pSeries and pmac and built and
# +  run on iSeries.
# +  
# +  Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
# +  Signed-off-by: Paul Mackerras <paulus@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1924, 2004-08-07 14:56:10-07:00, pazke@donpac.ru
# +  [PATCH] ppc64: fix free_irq()
# +  
# +  Fix ppc64 free_irq.
# +  
# +  Signed-off-by: Anton Blanchard <anton@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1923, 2004-08-07 14:55:59-07:00, tspat@de.ibm.com
# +  [PATCH] s390: qeth performance.
# +  
# +  qeth network driver performance improvements. The ping time on the
# +  HiperSockets interface drops from 250 usecs to 50 usecs and the 1 bytes
# +  request/response test improves from 70000 to 110000 transactions.
# +  
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1922, 2004-08-07 14:55:48-07:00, schwidefsky@de.ibm.com
# +  [PATCH] s390: zfcp host adapater.
# +  
# +  From: Heiko Carstens <heiko.carstens@de.ibm.com>
# +  From: Andreas Herrmann <aherrman@de.ibm.com>
# +  
# +  zfcp host adapater change:
# +   - Fix call to close_physical_port to prevent devices going offline
# +     after error recovery.
# +   - Fix return value of sysfs port_remove attribute store function.
# +   - Replace reboot notifier with device driver shutdown function.
# +  
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1921, 2004-08-07 14:55:36-07:00, ptiedem@de.ibm.com
# +  [PATCH] s390: ctc driver changes.
# +  
# +  Prefix debug feature variables with ctc to avoid name space problems.
# +  
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1920, 2004-08-07 14:55:25-07:00, nacc@us.ibm.com
# +  [PATCH] s390: msleep vs. schedule_timeout.
# +  
# +  Use msleep() instead of schedule_timeout() to guarantee the task
# +  delays for the desired time.
# +  
# +  Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1919, 2004-08-07 14:55:13-07:00, cohuck@de.ibm.com
# +  [PATCH] s390: common i/o layer changes.
# +  
# +  common i/o layer changes:
# +   - Set state of a disconnected device to offline before calling
# +     ccw_device_online, otherwise the device doesn't come up again.
# +   - Check for channel end when trying to find out if basic sense
# +     was successful.
# +   - Fix error handling in new_channel_path.
# +  
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1918, 2004-08-07 14:55:02-07:00, schwidefsky@de.ibm.com
# +  [PATCH] s390: core changes.
# +  
# +  From: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  
# +  s390 core changes:
# +   - Add 32 bit compat code for ptrace requests PTRACE_GETEVENTMSG,
# +     PTRACE_GETSIGINFO and PTRACE_SETSIGINFO.
# +   - Make non-smp kernel compile.
# +   - Regenerate default configuration.
# +  
# +  Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1917, 2004-08-07 14:54:50-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: gcc-3.3 macro parenthesization fix for memcpy.S
# +  
# +  From: Art Haas <ahaas@airmail.net>
# +  
# +  The 1.3->1.4 changes to the arch/sparc/lib/copy_user.S file added parenthesis
# +  to a number of macros within that file.  The BK changlog associated with this
# +  change indicate the change was to make the file work with gcc-3.3.
# +  
# +  When looking at the changes made, I see that similar macros exist in memcpy.S
# +  as well, so would a patch adding parens to that file be worthwhile?  Also,
# +  just what was the problem with gcc-3.3 that was resolved by adding the
# +  parenthesis?  Macro mis-expansion I'm guessing.
# +  
# +  Signed-off-by: Art Haas <ahaas@airmail.net>
# +  Signed-off-by: William Irwin <wli@holomorphy.com>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1916, 2004-08-07 14:54:39-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: make CONFIG_SMP depend on CONFIG_BROKEN
# +  
# +  SMP support is in need of a great deal of work to port it from 2.2 and 2.4.
# +  Add a dependency on BROKEN in the Kconfig to warn the unwary.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1915, 2004-08-07 14:54:27-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: sun4 does not support SMP
# +  
# +  The sun4 port does not support SMP.  Disable it via Kconfig.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1914, 2004-08-07 14:54:16-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: remove unused variable in dvma.c
# +  
# +  This variable is unused and causes noisy compiles.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1913, 2004-08-07 14:54:05-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: define cache_decay_ticks
# +  
# +  cache_decay_ticks needs to be defined in order for the kernel to link.  This
# +  placeholder is inaccurate, however, other, more grave SMP issues need to be
# +  addressed first.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1912, 2004-08-07 14:53:53-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: remove references to start_secondary()
# +  
# +  Remove leftover references to now-unused start_secondary()
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1911, 2004-08-07 14:53:42-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: reinstate smp_reschedule_irq()
# +  
# +  smp_reschedule_irq() mysteriously vanished sometime after 2.4.  This patch
# +  reinstates it so that the kernel will link properly and so cpus will set
# +  TIF_NEED_RESCHED when it's asked of them.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1910, 2004-08-07 14:53:33-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: smp_processor_id() BITFIXUP fixes
# +  
# +  The SMP initialization functions try to do btfixups on the wrong symbols for
# +  smp_processor_id(), which is now implemented in terms of
# +  current_thread_info()->cpu.  hard_smp_processor_id() etc.  are now in use
# +  where smp_processor_id() was once used.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1909, 2004-08-07 14:53:21-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: sun4d cpu_present_map is a cpumask_t
# +  
# +  cpu_present_map is a cpumask_t.  Sweep arch/sparc/kernel/sun4d_smp.c so that
# +  it is treated as such.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1908, 2004-08-07 14:53:10-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: sparc32 init_idle()
# +  
# +  An analysis of the code determined that AP initialization called init_idle()
# +  no less than three times, 2 out of the three with incorrect numbers of
# +  arguments.  This patch removes the superfluous calls.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1907, 2004-08-07 14:52:59-07:00, wli@holomorphy.com
# +  [PATCH] sparc32: turbosparc flush warnings
# +  
# +  FLUSH_BEGIN() is a nop at the moment, so the mm variable for its argument
# +  trips a warning.  Pass vma->vm_mm directly instead.
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1906, 2004-08-07 14:52:47-07:00, akpm@osdl.org
# +  [PATCH] jbd: journal_head unmapping race fix
# +  
# +  Fix a race identified by Chris Mason <mason@suse.com>
# +  
# +  journal_unmap_buffer -> __dispose_buffers has the j_list_lock and the
# +  jbd_lock_bh_state held.
# +  
# +  journal_get_write_access calls journal_put_journal_head, which takes
# +  jbd_lock_bh_journal_head(bh) and doesn't seem to have any other locks held.
# +  
# +  Since journal_unmap_buffers trusts the buffer_jbd bit to see if we need to
# +  call __dispose_buffer, and nobody seems to test buffer_jbd after taking
# +  jbd_lock_bh_journal_head.  The kernel dereferences a null jh pointer in
# +  __journal_remove_journal_head.
# +  
# +  
# +  The patch fixes this by using journal_grab_journal_head() in
# +  journal_unmap_buffer().  It ensures that we either grab and pin the
# +  journal_head if the bh has one, or we bale out if the bh doesn't have a
# +  journal_head.
# +  
# +  
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1905, 2004-08-07 14:52:36-07:00, paulus@samba.org
# +  [PATCH] Restore PPP filtering
# +  
# +  Karsten Keil's patch entitled "[ISDN]: Fix kernel PPP/IPPP active/passiv
# +  filter code" that went in back in April was an attempt to solve a real
# +  problem - namely that the libpcap maintainers have removed useful
# +  functionality that pppd was using - but his fix broke existing pppd
# +  binaries and IMO didn't end up actually solving the problem.
# +  
# +  This patch reverts the change to ppp_generic.c so that existing pppd
# +  binaries work again.  I am going to have to work out a proper fix, which
# +  may involve further changes to ppp_generic.c, but I will make sure existing
# +  pppd binaries still work.
# +  
# +  Signed-off-by: Paul Mackerras <paulus@samba.org>
# +  Signed-off-by: Andrew Morton <akpm@osdl.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1904, 2004-08-07 14:52:25-07:00, sam@ravnborg.org
# +  [PATCH] kbuild: Remove LANG preset in top-level Makefile
# +  
# +  In the top-level Makefile a number of locale related environment
# +  variables were preset to give a small speed up when building the kernel.
# +  
# +  Unfortunately this had the bad sideeffect that the variable
# +  CFLAGS_vmlinux.lds.o lost the exported vaule in some setups (obviously
# +  not mine).  This smells like a make issue - but the best solution is
# +  simply to drop presetting the locale related variables.
# +  
# +  Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1903, 2004-08-07 12:12:52-07:00, torvalds@ppc970.osdl.org
# +  Add infrastructure for the VFS layer to mark files seekable.
# +  
# +  We use a FMODE_LSEEK flag to match the existing read/write
# +  bits. This allows us to check for seekability on a VFS level
# +  for lseek/pread/pwrite, and cleans things up.
# +  
# +  Update some sites that used the numeric constants to use 
# +  the symbolic values instead.
# +
# +ChangeSet@1.1899, 2004-08-06 15:21:39-07:00, davem@nuts.davemloft.net
# +  [NET]: Move sndmsg_page destruction back into TCP for now.
# +  
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1884.5.3, 2004-08-06 15:13:07-07:00, trini@kernel.crashing.org
# +  [PATCH] ppc32: Fix building of certain CPU types
# +  
# +  The following corrects how we pass CPU flags to gas.  Previous, AFLAGS
# +  was incorrectly assumed to be pased directly to $(AS), which is not the
# +  case.
# +  
# +  Concept ack'd by Sam Ravnborg.
# +  
# +  Signed-off-by: Tom Rini <trini@kernel.crashing.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1884.5.2, 2004-08-06 15:12:56-07:00, paulus@samba.org
# +  [PATCH] Remove ppc32 proc_rtas.c
# +  
# +  This patch removes proc_rtas.c and error_log.[ch] from
# +  arch/ppc/platforms.  It turns out that the code in error_log.[ch] is
# +  completely unused, and the code in proc_rtas.c is buggy, almost
# +  impossible to understand, and rarely used.
# +  
# +  Signed-off-by: Paul Mackerras <paulus@samba.org>
# +  Signed-off-by: Linus Torvalds <torvalds@osdl.org>
# +
# +ChangeSet@1.1884.1.21, 2004-08-06 22:10:36+01:00, rmk@flint.arm.linux.org.uk
# +  [ARM] Remove unnecessary CONFIG_CPU_32 preprocessor conditional.
# +  
# +  We're only 32-bit ARMs, so testing this symbol in 32-bit only code
# +  is unnecessary.
# +
# +ChangeSet@1.1884.1.20, 2004-08-06 17:55:39+01:00, rmk@flint.arm.linux.org.uk
# +  [FB] replace schedule_timeout() with msleep()
# +  
# +  Patch from: Nishanth Aravamudan
# +  
# +  Use msleep() instead of schedule_timeout() to
# +  guarantee the task delays for the desired time.
# +  
# +  Signed-off-by: Nishanth Aravamudan
# +  Signed-off-by: Russell King
# +
# +ChangeSet@1.1884.5.1, 2004-08-06 09:46:07-07:00, jmorris@redhat.com
#    [PATCH] Re-implemented i586 asm AES
#    
#    This code is a rework of the original Gladman AES code, and does not
# @@ -16,11 +559,56 @@ ChangeSet@1.1900, 2004-08-06 09:46:07-07
#    Signed-off-by: James Morris <jmorris@redhat.com>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1899, 2004-08-05 23:11:00-07:00, torvalds@ppc970.osdl.org
# +ChangeSet@1.1884.4.1, 2004-08-06 17:38:15+01:00, rmk@flint.arm.linux.org.uk
# +  [SERIAL] replace schedule_timeout() with msleep()
# +  
# +  Patch from: Nishanth Aravamudan
# +  
# +  Use msleep() instead of schedule_timeout() to
# +  guarantee the task delays for the desired time.
# +  
# +  Signed-off-by: Nishanth Aravamudan
# +  Signed-off-by: Russell King
# +
# +ChangeSet@1.1884.1.19, 2004-08-06 15:08:24+01:00, ben-linux@org.rmk.(none)
# +  [ARM PATCH] 1990/1: S3C2410 - fix mis-spelled time initialisation calls
# +  
# +  Patch from Ben Dooks
# +  
# +  Fixed mis-spelled time initialisation calls and
# +  a bad prototype in the time header
# +  
# +  Fixes for patch 1962/1
# +
# +ChangeSet@1.1884.1.18, 2004-08-06 14:33:46+01:00, ben-linux@org.rmk.(none)
# +  [ARM PATCH] 1989/1: S3C2410 - rename owner of VR1000 board and update help
# +  
# +  Patch from Ben Dooks
# +  
# +  Rename to Thorcom, and added extra lines to help
# +
# +ChangeSet@1.1884.1.17, 2004-08-06 14:28:22+01:00, ben-linux@org.rmk.(none)
# +  [ARM PATCH] 1988/1: S3C2410 - defconfig update to include all boards
# +  
# +  Patch from Ben Dooks
# +  
# +  Updated default configuration file to include all the
# +  boards possible with this architecture
# +
# +ChangeSet@1.1884.1.16, 2004-08-06 14:20:34+01:00, kevin@org.rmk.(none)
# +  [ARM PATCH] 1986/1: bootpImage/ARM: add ability to run from non-zero address
# +  
# +  Patch from Kevin Hilman
# +  
# +  The following patch allows the bootpImage to be loaded and executed
# +  from a non-zero address.  On OMAP platforms for example, the physical
# +  address for SDRAM is 0x10000000 and not zero.
# +
# +ChangeSet@1.1884.1.15, 2004-08-05 23:11:00-07:00, torvalds@ppc970.osdl.org
#    Make the new simple_read_from_buffer() take a const src
#    buffer without complaints.
#  
# -ChangeSet@1.1898, 2004-08-05 22:36:28-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +ChangeSet@1.1884.1.14, 2004-08-05 22:36:28-07:00, viro@parcelfarce.linux.theplanet.co.uk
#    [PATCH] Fix ppc htab seq_file conversion
#    
#    *grrrrrrrr*
# @@ -30,14 +618,14 @@ ChangeSet@1.1898, 2004-08-05 22:36:28-07
#    
#    This is the incremental fix.
#  
# -ChangeSet@1.1897, 2004-08-05 21:13:56-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +ChangeSet@1.1884.1.13, 2004-08-05 21:13:56-07:00, viro@parcelfarce.linux.theplanet.co.uk
#    [PATCH] ppc: seq_file conversion for ppc_htab
#    
#    This converts the 32-bit ppc htab code to use the seq_file interfaces.
#    
#    Less code means fewer bugs..
#  
# -ChangeSet@1.1896, 2004-08-05 20:37:01-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +ChangeSet@1.1884.1.12, 2004-08-05 20:37:01-07:00, viro@parcelfarce.linux.theplanet.co.uk
#    [PATCH] ppc64: Fix rtas file mess
#    
#    This does the seq_file conversion + annotation + cleanup + race fixes
# @@ -68,14 +656,14 @@ ChangeSet@1.1896, 2004-08-05 20:37:01-07
#    
#    And it's full of that level of lusing ;-/
#  
# -ChangeSet@1.1895, 2004-08-05 20:30:40-07:00, torvalds@ppc970.osdl.org
# +ChangeSet@1.1884.1.11, 2004-08-05 20:30:40-07:00, torvalds@ppc970.osdl.org
#    Fix shrink_dcache_anon() LRU list accesses.
#    
#    It would potentially remove dentries from the LRU list
#    without re-initializing the d_lru fields, causing later
#    accesses to that dentry to do bad things to the LRU list.
#  
# -ChangeSet@1.1894, 2004-08-05 18:18:41-07:00, trini@kernel.crashing.org
# +ChangeSet@1.1884.1.10, 2004-08-05 18:18:41-07:00, trini@kernel.crashing.org
#    [PATCH] ppc32: Fix 'mktree' on 64bit hosts
#    
#    The following patch changes some 'unsigned long's into 'uint32_t's in
# @@ -87,7 +675,7 @@ ChangeSet@1.1894, 2004-08-05 18:18:41-07
#    Signed-off-by: Tom Rini <trini@kernel.crashing.org>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1893, 2004-08-05 17:56:22-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +ChangeSet@1.1884.1.9, 2004-08-05 17:56:22-07:00, viro@parcelfarce.linux.theplanet.co.uk
#    [PATCH] imm.c oops fix
#    
#    Fix bug #3125:
# @@ -101,7 +689,7 @@ ChangeSet@1.1893, 2004-08-05 17:56:22-07
#    Signed-off-by: Andrew Morton <akpm@osdl.org>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1889.1.6, 2004-08-05 17:43:51-07:00, roland@redhat.com
# +ChangeSet@1.1884.2.6, 2004-08-05 17:43:51-07:00, roland@redhat.com
#    [PATCH] fix /proc printing of TASK_DEAD state
#    
#    I just stumbled across this patch that's been sitting in my tree for ages.
# @@ -114,7 +702,7 @@ ChangeSet@1.1889.1.6, 2004-08-05 17:43:5
#    Signed-off-by: Roland McGrath <roland@redhat.com>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1889.1.4, 2004-08-05 17:39:48-07:00, viro@parcelfarce.linux.theplanet.co.uk
# +ChangeSet@1.1884.2.4, 2004-08-05 17:39:48-07:00, viro@parcelfarce.linux.theplanet.co.uk
#    [PATCH] simple_read_buffer() helper function
#    
#    A number of drivers or special virtual devices really just want their
# @@ -125,14 +713,14 @@ ChangeSet@1.1889.1.4, 2004-08-05 17:39:4
#    
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1889.2.7, 2004-08-05 21:48:18+01:00, jelenz@edu.rmk.(none)
# +ChangeSet@1.1884.3.7, 2004-08-05 21:48:18+01:00, jelenz@edu.rmk.(none)
#    [ARM PATCH] 1974/1: add INITTIME macro to collie machine structure
#    
#    Patch from John Lenz
#    
#    Add INITTIME macro to collie machine structure.
#  
# -ChangeSet@1.1889.2.6, 2004-08-05 21:43:43+01:00, ben-linux@org.rmk.(none)
# +ChangeSet@1.1884.3.6, 2004-08-05 21:43:43+01:00, ben-linux@org.rmk.(none)
#    [ARM PATCH] 1972/1: IPAQ H1940 - fix serial clock base
#    
#    Patch from Ben Dooks
# @@ -142,14 +730,14 @@ ChangeSet@1.1889.2.6, 2004-08-05 21:43:4
#    thanks to Gerald Schneider <gerald@gerald-online.de>
#    for fixing this.
#  
# -ChangeSet@1.1889.2.5, 2004-08-05 21:39:15+01:00, ben-linux@org.rmk.(none)
# +ChangeSet@1.1884.3.5, 2004-08-05 21:39:15+01:00, ben-linux@org.rmk.(none)
#    [ARM PATCH] 1971/1: BAST - default configuraiton update
#    
#    Patch from Ben Dooks
#    
#    Patch for default configuration
#  
# -ChangeSet@1.1889.2.4, 2004-08-05 21:33:54+01:00, ben-linux@org.rmk.(none)
# +ChangeSet@1.1884.3.4, 2004-08-05 21:33:54+01:00, ben-linux@org.rmk.(none)
#    [ARM PATCH] 1968/1: S3C2410 - GPIO updates and access functions
#    
#    Patch from Ben Dooks
# @@ -159,28 +747,28 @@ ChangeSet@1.1889.2.4, 2004-08-05 21:33:5
#    New functions for modifying pin configuration and
#    bit-status (see include/asm-arm/arch-s3c2410/hardware.h)
#  
# -ChangeSet@1.1889.2.3, 2004-08-05 21:28:33+01:00, ben-linux@org.rmk.(none)
# +ChangeSet@1.1884.3.3, 2004-08-05 21:28:33+01:00, ben-linux@org.rmk.(none)
#    [ARM PATCH] 1966/1: S3C2410 - Fix for serial driver compile error
#    
#    Patch from Ben Dooks
#    
#    Remove compile error with gcc-3.4 and empty part of case statememnt
#  
# -ChangeSet@1.1889.2.2, 2004-08-05 21:03:23+01:00, catalin.marinas@com.rmk.(none)
# +ChangeSet@1.1884.3.2, 2004-08-05 21:03:23+01:00, catalin.marinas@com.rmk.(none)
#    [ARM PATCH] 1965/1: gas only generates the c and f field bits for the "msr [cs]psr, rN" instruction
#    
#    Patch from Catalin Marinas
#    
#    Gas translates the "msr [cs]psr, rN" instruction to "msr [cs]psr_cf, rN". This may cause problems on the ARMv6 architecture where the A and E bits can leak into the SVC mode from the USR mode via the exception handlers. The reverse can happen when returning to user mode. The patch adds _cxsf to all the msr instruction without the field specifier.
#  
# -ChangeSet@1.1889.2.1, 2004-08-05 20:51:47+01:00, catalin.marinas@com.rmk.(none)
# +ChangeSet@1.1884.3.1, 2004-08-05 20:51:47+01:00, catalin.marinas@com.rmk.(none)
#    [ARM PATCH] 1964/1: Wrong cache block operations checking
#    
#    Patch from Catalin Marinas
#    
#    The "err" is rotated in the blockops_check() function and all the error bits are cleared, the subsequent conditions being always true.
#  
# -ChangeSet@1.1889.1.3, 2004-08-05 12:13:29-07:00, axboe@suse.de
# +ChangeSet@1.1884.2.3, 2004-08-05 12:13:29-07:00, axboe@suse.de
#    [PATCH] multipath readahead fix
#    
#    For requests marked read-ahead, it can legitimately fail without it being a
# @@ -193,7 +781,7 @@ ChangeSet@1.1889.1.3, 2004-08-05 12:13:2
#    Signed-off-by: Andrew Morton <akpm@osdl.org>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1889.1.2, 2004-08-05 12:05:56-07:00, heiko.carstens@de.ibm.com
# +ChangeSet@1.1884.2.2, 2004-08-05 12:05:56-07:00, heiko.carstens@de.ibm.com
#    [PATCH] md multipathing fixes
#    
#    I tried to get multipathing failover running and failed. It seems to be
# @@ -217,7 +805,7 @@ ChangeSet@1.1889.1.2, 2004-08-05 12:05:5
#    Signed-off-by: Andrew Morton <akpm@osdl.org>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1889.1.1, 2004-08-05 12:05:44-07:00, jmorris@redhat.com
# +ChangeSet@1.1884.2.1, 2004-08-05 12:05:44-07:00, jmorris@redhat.com
#    [PATCH] Drop asm i586 AES code.
#    
#    This patch reverts the i586 AES module.  A new one should be ready soon.
# @@ -225,10 +813,44 @@ ChangeSet@1.1889.1.1, 2004-08-05 12:05:4
#    Signed-off-by: James Morris <jmorris@redhat.com>
#    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
#  
# -ChangeSet@1.1890, 2004-08-05 08:53:26-04:00, dwmw2@shinybook.infradead.org
# +ChangeSet@1.1884.1.6, 2004-08-05 08:53:26-04:00, dwmw2@shinybook.infradead.org
#    Merge shinybook.infradead.org:/home/dwmw2/bk/linus-2.5
#    into shinybook.infradead.org:/home/dwmw2/bk/mtd-2.6
#  
# +ChangeSet@1.1898, 2004-08-04 16:18:09-07:00, davem@nuts.davemloft.net
# +  Cset exclude: davem@nuts.davemloft.net|ChangeSet|20040804202342|60209
# +
# +ChangeSet@1.1897, 2004-08-04 13:58:33-07:00, davem@nuts.davemloft.net
# +  [PKT_SCHED]: Move sch_atm over to qdisc_priv().
# +  
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1896, 2004-08-04 13:40:06-07:00, shemminger@osdl.org
# +  [PKT_SCHED]: Cache align qdisc data.
# +  
# +  This patch has qdisc code use the same interface as the
# +  netdevice code to cache align the object private data.
# +  
# +  Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1895, 2004-08-04 13:31:56-07:00, kaber@trash.net
# +  [PKT_SCHED]: Fix q_idx calculation in tc_dump_qdisc.
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1894, 2004-08-04 13:30:46-07:00, kaber@trash.net
# +  [PKT_SCHED]: Use double-linked list for dev->qdisc_list
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1893, 2004-08-04 13:23:42-07:00, davem@nuts.davemloft.net
# +  [IPV4/6]: NULL out sk_sndmsg_{page,off} in flush_pending_frames not append_data.
# +  
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
#  ChangeSet@1.1830.2.10, 2004-08-04 19:54:18+00:00, jbarnes@sgi.com
#    generic_defconfig update.  I just ran 'make oldconfig' against the existing
#    one and turned on a few new options (some of which Altix needs).
# @@ -259,6 +881,40 @@ ChangeSet@1.1830.2.7, 2004-08-04 17:55:4
#    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
#    Signed-off-by: Tony Luck <tony.luck@intel.com>
#  
# +ChangeSet@1.1892, 2004-08-04 09:47:01-07:00, shemminger@osdl.org
# +  [BRIDGE]: rmmod device while bridge is down fails
# +  
# +  The changes to bridge notifier to handle link state changes introduced
# +  a bug. The case of device unregistering while bridge is down was no
# +  longer being handled. Add comment so maintainer doesn't forget.
# +  
# +  Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1891, 2004-08-04 09:35:27-07:00, kaber@trash.net
# +  [PKT_SCHED]: Remove useless noop_qdisc assignments in destroy functions
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1890, 2004-08-04 09:33:23-07:00, kaber@trash.net
# +  [PKT_SCHED]: remove unneccessary checks for qdisc->dev
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1889, 2004-08-04 09:24:45-07:00, kaber@trash.net
# +  [PKT_SCHED]: Refcount qdisc->dev for __qdisc_destroy rcu-callback
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1888, 2004-08-04 09:23:36-07:00, kaber@trash.net
# +  [PKT_SCHED]: Fix locking in __qdisc_destroy rcu-callback
# +  
# +  Signed-off-by: Patrick McHardy <kaber@trash.net>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
#  ChangeSet@1.1830.2.6, 2004-08-03 23:46:56+00:00, jbarnes@sgi.com
#    sgi_io_init.c:
#      Mark per_hub_init as __init and remove an unnecessary extern declaration of it
# @@ -294,7 +950,19 @@ ChangeSet@1.1830.2.3, 2004-08-03 23:09:4
#      Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
#      Signed-off-by: Tony Luck <tony.luck@intel.com>
#  
# -ChangeSet@1.1889, 2004-08-03 14:11:41-07:00, torvalds@ppc970.osdl.org
# +ChangeSet@1.1886, 2004-08-03 14:13:23-07:00, shemminger@osdl.org
# +  [PKT_SCHED]: netem limit not returned correctly
# +  
# +  Minor leftover from earlier code.  Netem scheduler is not reporting
# +  correct limit (ie for 'tc qdisc ls') because it is returning devices limit
# +  not it's own.
# +  
# +  Should apply to 2.4 as well (with fuzz)
# +  
# +  Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
# +  Signed-off-by: David S. Miller <davem@redhat.com>
# +
# +ChangeSet@1.1884.1.5, 2004-08-03 14:11:41-07:00, torvalds@ppc970.osdl.org
#    Linux 2.6.8-rc3
#    TAG: v2.6.8-rc3
   

diff -p -purN linux-2.6.8-rc3-bk2/Makefile linux-2.6.8-rc3-bk3/Makefile
--- linux-2.6.8-rc3-bk2/Makefile	2004-08-08 17:24:48.724422880 +0000
+++ linux-2.6.8-rc3-bk3/Makefile	2004-08-08 17:25:03.312205200 +0000
@@ -619,12 +619,7 @@ $(sort $(vmlinux-objs)) arch/$(ARCH)/ker
 
 .PHONY: $(vmlinux-dirs)
 $(vmlinux-dirs): prepare-all scripts
-	$(Q)if [ ! -z $$LC_ALL ]; then          \
-		export LANG=$$LC_ALL;           \
-		export LC_ALL= ;                \
-	fi;                                     \
-	export LC_COLLATE=C; export LC_CTYPE=C; \
-	$(MAKE) $(build)=$@
+	$(Q)$(MAKE) $(build)=$@
 
 # Things we need to do before we recursively start building the kernel
 # or the modules are listed in "prepare-all".
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/boot/bootp/init.S linux-2.6.8-rc3-bk3/arch/arm/boot/bootp/init.S
--- linux-2.6.8-rc3-bk2/arch/arm/boot/bootp/init.S	2004-08-08 17:21:19.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/boot/bootp/init.S	2004-08-08 17:25:03.312205200 +0000
@@ -20,8 +20,10 @@
 		.type	_start, #function
 		.globl	_start
 
-_start:		adr	r13, data
+_start:		add	lr, pc, #-0x8		@ lr = current load addr
+		adr	r13, data
 		ldmia	r13!, {r4-r6}		@ r5 = dest, r6 = length
+		add	r4, r4, lr		@ r4 = initrd_start + load addr
 		bl	move			@ move the initrd
 
 /*
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/configs/s3c2410_defconfig linux-2.6.8-rc3-bk3/arch/arm/configs/s3c2410_defconfig
--- linux-2.6.8-rc3-bk2/arch/arm/configs/s3c2410_defconfig	2004-06-16 05:19:12.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/configs/s3c2410_defconfig	2004-08-08 17:25:03.331202312 +0000
@@ -11,7 +11,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 #
 CONFIG_EXPERIMENTAL=y
 # CONFIG_CLEAN_COMPILE is not set
-CONFIG_STANDALONE=y
 CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
@@ -20,17 +19,24 @@ CONFIG_BROKEN_ON_SMP=y
 #
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
 CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 
 #
 # Loadable module support
@@ -44,58 +50,32 @@ CONFIG_KMOD=y
 #
 # System Type
 #
-# CONFIG_ARCH_ADIFCC is not set
-# CONFIG_ARCH_ANAKIN is not set
 # CONFIG_ARCH_CLPS7500 is not set
 # CONFIG_ARCH_CLPS711X is not set
 # CONFIG_ARCH_CO285 is not set
-# CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_CAMELOT is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_RPC is not set
 # CONFIG_ARCH_SA1100 is not set
-# CONFIG_ARCH_SHARK is not set
 CONFIG_ARCH_S3C2410=y
-
-#
-# CLPS711X/EP721X Implementations
-#
-
-#
-# Epxa10db
-#
-
-#
-# Footbridge Implementations
-#
-
-#
-# IOP3xx Implementation Options
-#
-# CONFIG_ARCH_IOP310 is not set
-# CONFIG_ARCH_IOP321 is not set
-
-#
-# IOP3xx Chipset Features
-#
-
-#
-# Intel PXA250/210 Implementations
-#
-
-#
-# SA11x0 Implementations
-#
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_VERSATILE_PB is not set
 
 #
 # S3C2410 Implementations
 #
 CONFIG_ARCH_BAST=y
 CONFIG_ARCH_H1940=y
+CONFIG_ARCH_SMDK2410=y
+CONFIG_MACH_VR1000=y
 
 #
 # Processor Type
@@ -120,9 +100,8 @@ CONFIG_CPU_TLB_V4WBI=y
 # General setup
 #
 # CONFIG_ZBOOT_ROM is not set
-CONFIG_ZBOOT_ROM_TEXT=0
-CONFIG_ZBOOT_ROM_BSS=0
-# CONFIG_HOTPLUG is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
 
 #
 # At least one math emulation must be selected
@@ -130,6 +109,7 @@ CONFIG_ZBOOT_ROM_BSS=0
 CONFIG_FPE_NWFPE=y
 CONFIG_FPE_NWFPE_XP=y
 # CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
 CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_AOUT=y
 # CONFIG_BINFMT_MISC is not set
@@ -137,6 +117,9 @@ CONFIG_BINFMT_AOUT=y
 #
 # Generic Driver Options
 #
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_DEBUG_DRIVER is not set
 # CONFIG_PM is not set
 # CONFIG_PREEMPT is not set
 # CONFIG_ARTHUR is not set
@@ -149,7 +132,6 @@ CONFIG_ALIGNMENT_TRAP=y
 CONFIG_PARPORT=y
 CONFIG_PARPORT_PC=y
 CONFIG_PARPORT_PC_CML1=y
-# CONFIG_PARPORT_SERIAL is not set
 CONFIG_PARPORT_PC_FIFO=y
 CONFIG_PARPORT_PC_SUPERIO=y
 # CONFIG_PARPORT_ARC is not set
@@ -180,9 +162,20 @@ CONFIG_MTD_CFI=y
 # CONFIG_MTD_JEDECPROBE is not set
 CONFIG_MTD_GEN_PROBE=y
 # CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
 CONFIG_MTD_CFI_INTELEXT=y
 # CONFIG_MTD_CFI_AMDSTD is not set
 # CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
@@ -200,6 +193,7 @@ CONFIG_MTD_CFI_INTELEXT=y
 # Self-contained MTD device drivers
 #
 # CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
 # CONFIG_MTD_BLKMTD is not set
 
@@ -218,7 +212,6 @@ CONFIG_MTD_CFI_INTELEXT=y
 #
 # Plug and Play support
 #
-# CONFIG_PNP is not set
 
 #
 # Block devices
@@ -259,23 +252,21 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
 # CONFIG_ARPD is not set
-# CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_IPV6 is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
 # CONFIG_NETFILTER is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
 # CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
@@ -291,11 +282,17 @@ CONFIG_IPV6_SCTP__=y
 # QoS and/or fair queueing
 #
 # CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
 
 #
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -316,40 +313,25 @@ CONFIG_NET_ETHERNET=y
 #
 # Ethernet (10000 Mbit)
 #
-# CONFIG_PLIP is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
 
 #
-# Wireless LAN (non-hamradio)
+# Token Ring devices
 #
-# CONFIG_NET_RADIO is not set
-# CONFIG_HOSTAP is not set
 
 #
-# Token Ring devices
+# Wireless LAN (non-hamradio)
 #
-# CONFIG_SHAPER is not set
+# CONFIG_NET_RADIO is not set
 
 #
 # Wan interfaces
 #
 # CONFIG_WAN is not set
-
-#
-# Amateur Radio support
-#
-# CONFIG_HAMRADIO is not set
-
-#
-# IrDA (infrared) support
-#
-# CONFIG_IRDA is not set
-
-#
-# Bluetooth support
-#
-# CONFIG_BT is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -360,9 +342,9 @@ CONFIG_BLK_DEV_IDE=y
 #
 # Please see Documentation/ide.txt for help/info on IDE drives
 #
+# CONFIG_BLK_DEV_IDE_SATA is not set
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 CONFIG_BLK_DEV_IDECD=y
 CONFIG_BLK_DEV_IDETAPE=m
 CONFIG_BLK_DEV_IDEFLOPPY=m
@@ -372,10 +354,10 @@ CONFIG_BLK_DEV_IDEFLOPPY=m
 #
 # IDE chipset support/bugfixes
 #
-CONFIG_BLK_DEV_IDE_BAST=y
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
 # CONFIG_BLK_DEV_HD is not set
 
 #
@@ -384,13 +366,22 @@ CONFIG_BLK_DEV_IDE_BAST=y
 # CONFIG_SCSI is not set
 
 #
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
 # I2O device support
 #
 
 #
 # ISDN subsystem
 #
-# CONFIG_ISDN_BOOL is not set
+# CONFIG_ISDN is not set
 
 #
 # Input device support
@@ -406,7 +397,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_TSLIBDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
@@ -427,12 +417,13 @@ CONFIG_SERIO_SERPORT=y
 CONFIG_INPUT_KEYBOARD=y
 CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_XTKBD is not set
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
-# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
 # CONFIG_INPUT_MISC is not set
@@ -451,8 +442,6 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_DIGI is not set
 # CONFIG_MOXA_INTELLIO is not set
 # CONFIG_MOXA_SMARTIO is not set
-# CONFIG_ISI is not set
-# CONFIG_SYNCLINK is not set
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
 # CONFIG_RISCOM8 is not set
@@ -480,15 +469,37 @@ CONFIG_SERIAL_8250_SHARE_IRQ=y
 CONFIG_SERIAL_S3C2410=y
 CONFIG_SERIAL_S3C2410_CONSOLE=y
 CONFIG_SERIAL_BAST_SIO=y
-# CONFIG_SERIAL_DZ is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
-CONFIG_UNIX98_PTY_COUNT=256
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
 CONFIG_PRINTER=y
 # CONFIG_LP_CONSOLE is not set
 CONFIG_PPDEV=y
 # CONFIG_TIPAR is not set
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_NVRAM is not set
+CONFIG_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
 
 #
 # I2C support
@@ -507,55 +518,46 @@ CONFIG_I2C_ALGOBIT=m
 #
 # CONFIG_I2C_AMD756 is not set
 # CONFIG_I2C_AMD8111 is not set
-# CONFIG_I2C_PHILIPSPAR is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_PARPORT is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_SCx200_ACB is not set
 
 #
-# I2C Hardware Sensors Chip support
+# Hardware Sensors Chip support
 #
 CONFIG_I2C_SENSOR=m
 # CONFIG_SENSORS_ADM1021 is not set
-CONFIG_SENSORS_EEPROM=m
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
 # CONFIG_SENSORS_IT87 is not set
 CONFIG_SENSORS_LM75=m
+# CONFIG_SENSORS_LM77 is not set
 CONFIG_SENSORS_LM78=m
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
 CONFIG_SENSORS_LM85=m
-# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
 # CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
 
 #
-# L3 serial bus support
-#
-# CONFIG_L3 is not set
-
-#
-# Mice
-#
-# CONFIG_BUSMOUSE is not set
-# CONFIG_QIC02_TAPE is not set
-
-#
-# IPMI
-#
-# CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_NVRAM is not set
-CONFIG_RTC=y
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
-
-#
-# Ftape, the floppy tape device driver
+# Other I2C Chip support
 #
-# CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
-# CONFIG_DRM is not set
-# CONFIG_RAW_DRIVER is not set
+CONFIG_SENSORS_EEPROM=m
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
 
 #
 # Multimedia devices
@@ -568,11 +570,6 @@ CONFIG_RTC=y
 # CONFIG_DVB is not set
 
 #
-# MMC/SD Card support
-#
-# CONFIG_MMC is not set
-
-#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -611,8 +608,8 @@ CONFIG_VFAT_FS=y
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
 # CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLBFS is not set
@@ -625,14 +622,20 @@ CONFIG_RAMFS=y
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
 CONFIG_JFFS_FS=y
 CONFIG_JFFS_FS_VERBOSE=0
+# CONFIG_JFFS_PROC_FS is not set
 CONFIG_JFFS2_FS=y
 CONFIG_JFFS2_FS_DEBUG=0
 # CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -652,12 +655,11 @@ CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 # CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_GSS is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -675,16 +677,15 @@ CONFIG_BSD_DISKLABEL=y
 CONFIG_SOLARIS_X86_PARTITION=y
 # CONFIG_UNIXWARE_DISKLABEL is not set
 # CONFIG_LDM_PARTITION is not set
-# CONFIG_NEC98_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
-CONFIG_NLS=y
 
 #
 # Native Language Support
 #
+CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_CODEPAGE_437 is not set
 # CONFIG_NLS_CODEPAGE_737 is not set
@@ -709,6 +710,7 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_ISO8859_8 is not set
 # CONFIG_NLS_CODEPAGE_1250 is not set
 # CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
 # CONFIG_NLS_ISO8859_1 is not set
 # CONFIG_NLS_ISO8859_2 is not set
 # CONFIG_NLS_ISO8859_3 is not set
@@ -725,6 +727,11 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 # CONFIG_NLS_UTF8 is not set
 
 #
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
 # Graphics support
 #
 CONFIG_FB=y
@@ -744,21 +751,20 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_LOGO is not set
 
 #
-# Misc devices
+# Sound
 #
+# CONFIG_SOUND is not set
 
 #
-# Multimedia Capabilities Port drivers
+# Misc devices
 #
-# CONFIG_MCP is not set
 
 #
-# Console Switches
+# USB support
 #
-# CONFIG_SWITCHES is not set
 
 #
-# USB support
+# USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
 
@@ -776,7 +782,6 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_BUGVERBOSE is not set
 # CONFIG_DEBUG_ERRORS is not set
 CONFIG_DEBUG_LL=y
-CONFIG_DEBUG_LL_PRINTK=y
 # CONFIG_DEBUG_ICEDCC is not set
 CONFIG_DEBUG_S3C2410_PORT=y
 CONFIG_DEBUG_S3C2410_UART=0
@@ -794,6 +799,8 @@ CONFIG_DEBUG_S3C2410_UART=0
 #
 # Library routines
 #
+# CONFIG_CRC_CCITT is not set
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/Kconfig linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/Kconfig
--- linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/Kconfig	2004-06-16 05:19:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/Kconfig	2004-08-08 17:25:03.343200488 +0000
@@ -23,9 +23,12 @@ config ARCH_SMDK2410
            <http://www.fsforth.de>
 
 config MACH_VR1000
-	bool "Simtec VR1000"
+	bool "Thorcom VR1000"
 	help
-	  Say Y here if you are using the Simtec VR1000 board.
+	  Say Y here if you are using the Thorcom VR1000 board.
+
+	  This linux port is currently being maintained by Simtec, on behalf
+	  of Thorcom. Any queries, please contact Thorcom first.
 
 endmenu
 
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/mach-smdk2410.c linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/mach-smdk2410.c
--- linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/mach-smdk2410.c	2004-08-08 17:21:20.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/mach-smdk2410.c	2004-08-08 17:25:03.348199728 +0000
@@ -101,7 +101,7 @@ void __init smdk2410_init_irq(void)
 
 void __init smdk2410_init_time(void)
 {
-	s3c2401_init_time();
+	s3c2410_init_time();
 }
 
 MACHINE_START(SMDK2410, "SMDK2410") /* @TODO: request a new identifier and switch
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/mach-vr1000.c linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/mach-vr1000.c
--- linux-2.6.8-rc3-bk2/arch/arm/mach-s3c2410/mach-vr1000.c	2004-08-08 17:21:20.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/mach-s3c2410/mach-vr1000.c	2004-08-08 17:25:03.349199576 +0000
@@ -11,6 +11,7 @@
  * published by the Free Software Foundation.
  *
  * Modifications:
+ *     06-Aug-2004 BJD  Fixed call to time initialisation
  *     12-Jul-2004 BJD  Renamed machine
  *     16-May-2003 BJD  Created initial version
  *     16-Aug-2003 BJD  Fixed header files and copyright, added URL
@@ -159,7 +160,7 @@ void __init vr1000_init_irq(void)
 
 void __init vr1000_init_time(void)
 {
-	s3c2401_init_time();
+	s3c2410_init_time();
 }
 
 MACHINE_START(VR1000, "Thorcom-VR1000")
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/mm/fault.c linux-2.6.8-rc3-bk3/arch/arm/mm/fault.c
--- linux-2.6.8-rc3-bk2/arch/arm/mm/fault.c	2004-08-08 17:21:20.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/mm/fault.c	2004-08-08 17:25:03.353198968 +0000
@@ -66,9 +66,7 @@ void show_pte(struct mm_struct *mm, unsi
 		/* We must not map this if we have highmem enabled */
 		pte = pte_offset_map(pmd, addr);
 		printk(", *pte=%08lx", pte_val(*pte));
-#ifdef CONFIG_CPU_32
 		printk(", *ppte=%08lx", pte_val(pte[-PTRS_PER_PTE]));
-#endif
 		pte_unmap(pte);
 #endif
 	} while(0);
diff -p -purN linux-2.6.8-rc3-bk2/arch/arm/mm/init.c linux-2.6.8-rc3-bk3/arch/arm/mm/init.c
--- linux-2.6.8-rc3-bk2/arch/arm/mm/init.c	2004-08-08 17:21:20.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/arm/mm/init.c	2004-08-08 17:25:03.354198816 +0000
@@ -24,13 +24,7 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 
-#ifdef CONFIG_CPU_32
-#define TABLE_OFFSET	(PTRS_PER_PTE)
-#else
-#define TABLE_OFFSET	0
-#endif
-
-#define TABLE_SIZE	((TABLE_OFFSET + PTRS_PER_PTE) * sizeof(pte_t))
+#define TABLE_SIZE	(2 * PTRS_PER_PTE * sizeof(pte_t))
 
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 
@@ -289,14 +283,13 @@ static __init void reserve_node_zero(uns
 	 */
 	reserve_bootmem_node(pgdat, __pa(&_stext), &_end - &_stext);
 
-#ifdef CONFIG_CPU_32
 	/*
 	 * Reserve the page tables.  These are already in use,
 	 * and can only be in node 0.
 	 */
 	reserve_bootmem_node(pgdat, __pa(swapper_pg_dir),
 			     PTRS_PER_PGD * sizeof(pgd_t));
-#endif
+
 	/*
 	 * And don't forget to reserve the allocator bitmap,
 	 * which will be freed later.
diff -p -purN linux-2.6.8-rc3-bk2/arch/i386/kernel/cpu/mtrr/if.c linux-2.6.8-rc3-bk3/arch/i386/kernel/cpu/mtrr/if.c
--- linux-2.6.8-rc3-bk2/arch/i386/kernel/cpu/mtrr/if.c	2004-08-08 17:21:20.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/i386/kernel/cpu/mtrr/if.c	2004-08-08 17:25:03.382194560 +0000
@@ -101,9 +101,6 @@ mtrr_write(struct file *file, const char
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
-	/*  Can't seek (pwrite) on this device  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
 	memset(line, 0, LINE_SIZE);
 	if (len > LINE_SIZE)
 		len = LINE_SIZE;
diff -p -purN linux-2.6.8-rc3-bk2/arch/mips/kernel/linux32.c linux-2.6.8-rc3-bk3/arch/mips/kernel/linux32.c
--- linux-2.6.8-rc3-bk2/arch/mips/kernel/linux32.c	2004-06-16 05:19:37.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/mips/kernel/linux32.c	2004-08-08 17:25:03.426187872 +0000
@@ -477,6 +477,9 @@ asmlinkage ssize_t sys32_pread(unsigned 
 		goto out;
 	if (pos < 0)
 		goto out;
+	ret = -ESPIPE;
+	if (!(file->f_mode & FMODE_PREAD))
+		goto out;
 	ret = read(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_ACCESS);
@@ -511,6 +514,10 @@ asmlinkage ssize_t sys32_pwrite(unsigned
 	if (pos < 0)
 		goto out;
 
+	ret = -ESPIPE;
+	if (!(file->f_mode & FMODE_PWRITE))
+		goto out;
+
 	ret = write(file, buf, count, &pos);
 	if (ret > 0)
 		dnotify_parent(file->f_dentry, DN_MODIFY);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/Kconfig linux-2.6.8-rc3-bk3/arch/ppc/Kconfig
--- linux-2.6.8-rc3-bk2/arch/ppc/Kconfig	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/Kconfig	2004-08-08 17:25:03.429187416 +0000
@@ -825,39 +825,6 @@ config PROC_DEVICETREE
 	  an image of the device tree that the kernel copies from Open
 	  Firmware. If unsure, say Y here.
 
-config PPC_RTAS
-	bool "Support for RTAS (RunTime Abstraction Services) in /proc"
-	depends on PPC_OF && PROC_FS
-	---help---
-	  When you use this option, you will be able to use RTAS from
-	  userspace.
-
-	  RTAS stands for RunTime Abstraction Services and should
-	  provide a portable way to access and set system information. This is
-	  commonly used on RS/6000 (pSeries) computers.
-
-	  You can access RTAS via the special proc file system entry rtas.
-	  Don't confuse this rtas entry with the one in /proc/device-tree/rtas
-	  which is readonly.
-
-	  If you don't know if you can use RTAS look into
-	  /proc/device-tree/rtas. If there are some entries, it is very likely
-	  that you will be able to use RTAS.
-
-	  You can do cool things with rtas. To print out information about
-	  various sensors in the system, just do a
-
-	  $ cat /proc/rtas/sensors
-
-	  or if you power off your machine at night but want it running when
-	  you enter your office at 7:45 am, do a
-
-	  # date -d 'tomorrow 7:30' +%s > /proc/rtas/poweron
-
-	  and shutdown.
-
-	  If unsure, say Y.
-
 config PREP_RESIDUAL
 	bool "Support for PReP Residual Data"
 	depends on PPC_PREP
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/Makefile linux-2.6.8-rc3-bk3/arch/ppc/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/Makefile	2004-08-08 17:25:03.430187264 +0000
@@ -22,28 +22,25 @@ endif
 
 LDFLAGS_vmlinux	:= -Ttext $(KERNELLOAD) -Bstatic
 CPPFLAGS	+= -Iarch/$(ARCH)
-aflags-y	+= -Iarch/$(ARCH)
-cflags-y	+= -Iarch/$(ARCH) -msoft-float -pipe \
+AFLAGS		+= -Iarch/$(ARCH)
+CFLAGS		+= -Iarch/$(ARCH) -msoft-float -pipe \
 		-ffixed-r2 -Wno-uninitialized -mmultiple
 CPP		= $(CC) -E $(CFLAGS)
 
 CHECK		:= $(CHECK) -D__powerpc__=1
 
 ifndef CONFIG_E500
-cflags-y	+= -mstring
+CFLAGS		+= -mstring
 endif
 
-aflags-$(CONFIG_4xx)		+= -m405
-cflags-$(CONFIG_4xx)		+= -Wa,-m405
-aflags-$(CONFIG_6xx)		+= -maltivec
-cflags-$(CONFIG_6xx)		+= -Wa,-maltivec
-aflags-$(CONFIG_E500)		+= -me500
-cflags-$(CONFIG_E500)		+= -Wa,-me500
-aflags-$(CONFIG_PPC64BRIDGE)	+= -mppc64bridge
-cflags-$(CONFIG_PPC64BRIDGE)	+= -Wa,-mppc64bridge
+cpu-as-$(CONFIG_PPC64BRIDGE)	+= -Wa,-mppc64bridge
+cpu-as-$(CONFIG_4xx)		+= -Wa,-m405
+cpu-as-$(CONFIG_6xx)		+= -Wa,-maltivec
+cpu-as-$(CONFIG_POWER4)		+= -Wa,-maltivec
+cpu-as-$(CONFIG_E500)		+= -Wa,-me500
 
-AFLAGS += $(aflags-y)
-CFLAGS += $(cflags-y)
+AFLAGS += $(cpu-as-y)
+CFLAGS += $(cpu-as-y)
 
 head-y				:= arch/ppc/kernel/head.o
 head-$(CONFIG_8xx)		:= arch/ppc/kernel/head_8xx.o
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/kernel/Makefile linux-2.6.8-rc3-bk3/arch/ppc/kernel/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc/kernel/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/kernel/Makefile	2004-08-08 17:25:03.432186960 +0000
@@ -2,16 +2,6 @@
 # Makefile for the linux kernel.
 #
 
-ifdef CONFIG_PPC64BRIDGE
-EXTRA_AFLAGS		:= -Wa,-mppc64bridge
-endif
-ifdef CONFIG_4xx
-EXTRA_AFLAGS		:= -Wa,-m405
-endif
-ifdef CONFIG_E500
-EXTRA_AFLAGS		:= -Wa,-me500
-endif
-
 extra-$(CONFIG_PPC_STD_MMU)	:= head.o
 extra-$(CONFIG_40x)		:= head_4xx.o
 extra-$(CONFIG_44x)		:= head_44x.o
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/kernel/pci-dma.c linux-2.6.8-rc3-bk3/arch/ppc/kernel/pci-dma.c
--- linux-2.6.8-rc3-bk2/arch/ppc/kernel/pci-dma.c	2004-06-16 05:19:01.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/kernel/pci-dma.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2000   Ani Joshi <ajoshi@unixbox.com>
- *
- *
- * Dynamic DMA mapping support.
- *
- * swiped from i386
- *
- */
-
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/pci.h>
-#include <asm/io.h>
-
-void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
-			   dma_addr_t *dma_handle)
-{
-	void *ret;
-	int gfp = GFP_ATOMIC;
-
-	if (hwdev == NULL || hwdev->dma_mask != 0xffffffff)
-		gfp |= GFP_DMA;
-
-#ifdef CONFIG_NOT_COHERENT_CACHE
-	ret = consistent_alloc(gfp, size, dma_handle);
-#else
-	ret = (void *)__get_free_pages(gfp, get_order(size));
-#endif
-
-	if (ret != NULL) {
-		memset(ret, 0, size);
-#ifndef CONFIG_NOT_COHERENT_CACHE
-		*dma_handle = virt_to_bus(ret);
-#endif
-	}
-	return ret;
-}
-
-void pci_free_consistent(struct pci_dev *hwdev, size_t size,
-			 void *vaddr, dma_addr_t dma_handle)
-{
-#ifdef CONFIG_NOT_COHERENT_CACHE
-	consistent_free(vaddr);
-#else
-	free_pages((unsigned long)vaddr, get_order(size));
-#endif
-}
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/kernel/ppc_htab.c linux-2.6.8-rc3-bk3/arch/ppc/kernel/ppc_htab.c
--- linux-2.6.8-rc3-bk2/arch/ppc/kernel/ppc_htab.c	2004-08-08 17:24:48.812409504 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/kernel/ppc_htab.c	2004-08-08 17:25:03.440185744 +0000
@@ -35,7 +35,7 @@ static int ppc_htab_show(struct seq_file
 static ssize_t ppc_htab_write(struct file * file, const char __user * buffer,
 			      size_t count, loff_t *ppos);
 int proc_dol2crvec(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp);
+		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
 extern PTE *Hash, *Hash_end;
 extern unsigned long Hash_size, Hash_mask;
@@ -320,7 +320,7 @@ static ssize_t ppc_htab_write(struct fil
 }
 
 int proc_dol2crvec(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer_arg, size_t *lenp)
+		  void __user *buffer_arg, size_t *lenp, loff_t *ppos)
 {
 	int vleft, first=1, len, left, val;
 	char __user *buffer = (char __user *) buffer_arg;
@@ -344,7 +344,7 @@ int proc_dol2crvec(ctl_table *table, int
 	if (!(cur_cpu_spec[0]->cpu_features & CPU_FTR_L2CR))
 		return -EFAULT;
 
-	if ( /*!table->maxlen ||*/ (filp->f_pos && !write)) {
+	if ( /*!table->maxlen ||*/ (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -435,6 +435,6 @@ int proc_dol2crvec(ctl_table *table, int
 	if (write && first)
 		return -EINVAL;
 	*lenp -= left;
-	filp->f_pos += *lenp;
+	*ppos += *lenp;
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/mm/44x_mmu.c linux-2.6.8-rc3-bk3/arch/ppc/mm/44x_mmu.c
--- linux-2.6.8-rc3-bk2/arch/ppc/mm/44x_mmu.c	2004-06-16 05:19:37.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/mm/44x_mmu.c	2004-08-08 17:25:03.442185440 +0000
@@ -93,10 +93,14 @@ ppc44x_pin_tlb(int slot, unsigned int vi
 }
 
 /*
- * Configure PPC44x TLB for AS0 exception processing.
+ * MMU_init_hw does the chip-specific initialization of the MMU hardware.
  */
-static void __init
-ppc44x_tlb_config(void)
+void __init MMU_init_hw(void)
+{
+	flush_instruction_cache();
+}
+
+unsigned long __init mmu_mapin_ram(void)
 {
 	unsigned int pinned_tlbs = 1;
 	int i;
@@ -124,39 +128,6 @@ ppc44x_tlb_config(void)
 			unsigned int phys_addr = (PPC44x_LOW_SLOT-i) * PPC44x_PIN_SIZE;
 			ppc44x_pin_tlb(i, phys_addr+PAGE_OFFSET, phys_addr);
 		}
-}
-
-/*
- * MMU_init_hw does the chip-specific initialization of the MMU hardware.
- */
-void __init MMU_init_hw(void)
-{
-	flush_instruction_cache();
-
-	ppc44x_tlb_config();
-}
-
-/* TODO: Add large page lowmem mapping support */
-unsigned long __init mmu_mapin_ram(void)
-{
-	unsigned long v, s, f = _PAGE_GUARDED;
-	phys_addr_t p;
-
-	v = KERNELBASE;
-	p = PPC_MEMSTART;
-
-	for (s = 0; s < total_lowmem; s += PAGE_SIZE) {
-		if ((char *) v >= _stext && (char *) v < etext)
-			f |= _PAGE_RAM_TEXT;
-		else
-			f |= _PAGE_RAM;
-		map_page(v, p, f);
-		v += PAGE_SIZE;
-		p += PAGE_SIZE;
-	}
-
-	if (ppc_md.progress)
-		ppc_md.progress("MMU:mmu_mapin_ram done", 0x401);
 
-	return s;
+	return total_lowmem;
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/mm/Makefile linux-2.6.8-rc3-bk3/arch/ppc/mm/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc/mm/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/mm/Makefile	2004-08-08 17:25:03.442185440 +0000
@@ -2,10 +2,6 @@
 # Makefile for the linux ppc-specific parts of the memory manager.
 #
 
-ifdef CONFIG_PPC64BRIDGE
-EXTRA_AFLAGS		:= -Wa,-mppc64bridge
-endif
-
 obj-y				:= fault.o init.o mem_pieces.o \
 					mmu_context.o pgtable.o
 
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/4xx/Kconfig linux-2.6.8-rc3-bk3/arch/ppc/platforms/4xx/Kconfig
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/4xx/Kconfig	2004-06-16 05:18:58.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/4xx/Kconfig	2004-08-08 17:25:03.443185288 +0000
@@ -175,6 +175,15 @@ config IBM_OPENBIOS
 	depends on ASH || BUBINGA || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
+config PPC4xx_DMA
+	bool "PPC4xx DMA controller support"
+	depends on 4xx
+
+config PPC4xx_EDMA
+	bool
+	depends on !STB03xxx && PPC4xx_DMA
+	default y
+
 config PM
 	bool "Power Management support (EXPERIMENTAL)"
 	depends on 4xx && EXPERIMENTAL
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/4xx/ebony.h linux-2.6.8-rc3-bk3/arch/ppc/platforms/4xx/ebony.h
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/4xx/ebony.h	2004-06-16 05:19:44.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/4xx/ebony.h	2004-08-08 17:25:03.444185136 +0000
@@ -64,7 +64,8 @@
 #define UART0_IO_BASE	(u8 *) 0xE0000200
 #define UART1_IO_BASE	(u8 *) 0xE0000300
 
-#define BASE_BAUD	33000000/3/16
+/* external Epson SG-615P */
+#define BASE_BAUD	691200
 
 #define STD_UART_OP(num)					\
 	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/Makefile linux-2.6.8-rc3-bk3/arch/ppc/platforms/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/Makefile	2004-08-08 17:25:03.444185136 +0000
@@ -2,13 +2,6 @@
 # Makefile for the linux kernel.
 #
 
-ifdef CONFIG_PPC64BRIDGE
-EXTRA_AFLAGS		:= -Wa,-mppc64bridge
-endif
-ifdef CONFIG_40x
-EXTRA_AFLAGS		:= -Wa,-m405
-endif
-
 # Extra CFLAGS so we don't have to do relative includes
 CFLAGS_pmac_setup.o	+= -Iarch/$(ARCH)/mm
 
@@ -26,7 +19,6 @@ obj-$(CONFIG_NVRAM)		+= pmac_nvram.o
 obj-$(CONFIG_CPU_FREQ_PMAC)	+= pmac_cpufreq.o
 endif
 obj-$(CONFIG_PMAC_BACKLIGHT)	+= pmac_backlight.o
-obj-$(CONFIG_PPC_RTAS)		+= error_log.o proc_rtas.o
 obj-$(CONFIG_PREP_RESIDUAL)	+= residual.o
 obj-$(CONFIG_ADIR)		+= adir_setup.o adir_pic.o adir_pci.o
 obj-$(CONFIG_EST8260)		+= est8260_setup.o
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/error_log.c linux-2.6.8-rc3-bk3/arch/ppc/platforms/error_log.c
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/error_log.c	2004-06-16 05:19:43.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/error_log.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,183 +0,0 @@
-/*
- *  arch/ppc/kernel/error_log.c
- *
- *  Copyright (c) 2000 Tilmann Bitterberg
- *  (tilmann@bitterberg.de)
- *
- *  Error processing of errors found by rtas even-scan routine
- *  which is done with every heartbeat. (chrp_setup.c)
- */
-
-#include <linux/sched.h>
-
-#include <asm/prom.h>
-
-#include "error_log.h"
-
-/* ****************************************************************** */
-/*
- * EVENT-SCAN
- * The whole stuff below here doesn't take any action when it found
- * an error, it just prints as much information as possible and
- * then its up to the user to decide what to do.
- *
- * Returns 0 if no errors were found
- * Returns 1 if there may be more errors
- */
-int ppc_rtas_errorlog_scan(void)
-{
-const char *_errlog_severity[] = {
-#ifdef VERBOSE_ERRORS
-	"No Error\n\t\
-Should require no further information",
-	"Event\n\t\
-This is not really an error, it is an event. I use events\n\t\
-to communicate with RTAS back and forth.",
-	"Warning\n\t\
-Indicates a non-state-losing error, either fully recovered\n\t\
-by RTAS or not needing recovery. Ignore it.",
-	"Error sync\n\t\
-May only be fatal to a certain program or thread. Recovery\n\t\
-and continuation is possible, if I only had a handler for\n\t\
-this. Less serious",
-	"Error\n\t\
-Less serious, but still causing a loss of data and state.\n\t\
-I can't tell you exactly what to do, You have to decide\n\t\
-with help from the target and initiator field, what kind\n\t\
-of further actions may take place.",
-	"Fatal\n\t\
-Represent a permanent hardware failure and I believe this\n\t\
-affects my overall performance and behaviour. I would not\n\t\
-attempt to continue normal operation."
-#else
-	"No Error",
-	"Event",
-	"Warning",
-	"Error sync",
-	"Error",
-	"Fatal"
-#endif /* VERBOSE_ERRORS */
-};
-
-#if 0 /* unused?? */
-const char *_errlog_disposition[] = {
-#ifdef VERBOSE_ERRORS
-	"Fully recovered\n\t\
-There was an error, but it is fully recovered by RTAS.",
-	"Limited recovery\n\t\
-RTAS was able to recover the state of the machine, but some\n\t\
-feature of the machine has been disabled or lost (for example\n\t\
-error checking) or performance may suffer.",
-	"Not recovered\n\t\
-Whether RTAS did not try to recover anything or recovery failed:\n\t\
-HOUSTON, WE HAVE A PROBLEM!"
-#else
-	"Fully recovered",
-	"Limited recovery",
-	"Not recovered"
-#endif /* VERBOSE_ERRORS */
-};
-#endif
-
-const char *_errlog_extended[] = {
-#ifdef VERBOSE_ERRORS
-	"Not present\n\t\
-Sad, the RTAS call didn't return an extended error log.",
-	"Present\n\t\
-The extended log is present and hopefully it contains a lot of\n\t\
-useful information, which leads to the solution of the problem."
-#else
-	"Not present",
-	"Present"
-#endif /* VERBOSE_ERRORS */
-};
-
-const char *_errlog_initiator[] = {
-	"Unknown or not applicable",
-	"CPU",
-	"PCI",
-	"ISA",
-	"Memory",
-	"Power management"
-};
-
-const char *_errlog_target[] = {
-	"Unknown or not applicable",
-	"CPU",
-	"PCI",
-	"ISA",
-	"Memory",
-	"Power management"
-};
-	rtas_error_log error_log;
-	char logdata[1024];
-	int error;
-#if 0 /* unused?? */
-	int retries = 0; /* if HW error, try 10 times */
-#endif
-
-	error = call_rtas ("event-scan", 4, 1, (unsigned long *)&error_log,
-			INTERNAL_ERROR | EPOW_WARNING,
-			0, __pa(logdata), 1024);
-
-	if (error == 1) /* no errors found */
-		return 0;
-
-	if (error == -1) {
-		printk(KERN_ERR "Unable to get errors. Do you a favor and throw this box away\n");
-		return 0;
-	}
-	if (error_log.version != 1)
-		printk(KERN_WARNING "Unknown version (%d), please implement me\n",
-				error_log.version);
-
-	switch (error_log.disposition) {
-		case DISP_FULLY_RECOVERED:
-			/* there was an error, but everything is fine now */
-			return 0;
-		case DISP_NOT_RECOVERED:
-			printk("We have a really serious Problem!\n");
-		case DISP_LIMITED_RECOVERY:
-			printk("Error classification\n");
-			printk("Severity  : %s\n",
-					ppc_rtas_errorlog_check_severity (error_log));
-			printk("Initiator : %s\n",
-					ppc_rtas_errorlog_check_initiator (error_log));
-			printk("Target    : %s\n",
-					ppc_rtas_errorlog_check_target (error_log));
-			printk("Type      : %s\n",
-					ppc_rtas_errorlog_check_type (error_log));
-			printk("Ext. log  : %s\n",
-					ppc_rtas_errorlog_check_extended (error_log));
-			if (error_log.extended)
-				ppc_rtas_errorlog_disect_extended (logdata);
-			return 1;
-		default:
-			/* nothing */
-			break;
-	}
-	return 0;
-}
-/* ****************************************************************** */
-const char * ppc_rtas_errorlog_check_type (rtas_error_log error_log)
-{
-	const char *_errlog_type[] = {
-		"unknown type",
-		"too many tries failed",
-		"TCE error",
-		"RTAS device failed",
-		"target timed out",
-		"parity error on data",			/* 5 */
-		"parity error on address",
-		"parity error on external cache",
-		"access to invalid address",
-		"uncorrectable ECC error",
-		"corrected ECC error"			/* 10 */
-	};
-	if (error_log.type == TYPE_EPOW)
-		return "EPOW";
-	if (error_log.type >= TYPE_PMGM_POWER_SW_ON)
-		return "PowerMGM Event (not handled right now)";
-	return _errlog_type[error_log.type];
-}
-
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/error_log.h linux-2.6.8-rc3-bk3/arch/ppc/platforms/error_log.h
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/error_log.h	2004-06-16 05:19:43.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/error_log.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,95 +0,0 @@
-#ifndef __ERROR_LOG_H__
-#define __ERROR_LOG_H__
-
-#define VERBOSE_ERRORS		1 /* Maybe I enlarge the kernel too much */
-#undef VERBOSE_ERRORS
-
-/* Event classes */
-/* XXX: Endianess correct? NOW*/
-#define INTERNAL_ERROR		0x80000000 /* set bit 0 */
-#define EPOW_WARNING		0x40000000 /* set bit 1 */
-#define POWERMGM_EVENTS		0x20000000 /* set bit 2 */
-
-/* event-scan returns */
-#define SEVERITY_FATAL		0x5
-#define SEVERITY_ERROR		0x4
-#define SEVERITY_ERROR_SYNC	0x3
-#define SEVERITY_WARNING	0x2
-#define SEVERITY_EVENT		0x1
-#define SEVERITY_NO_ERROR	0x0
-#define DISP_FULLY_RECOVERED	0x0
-#define DISP_LIMITED_RECOVERY	0x1
-#define DISP_NOT_RECOVERED	0x2
-#define PART_PRESENT		0x0
-#define PART_NOT_PRESENT	0x1
-#define INITIATOR_UNKNOWN	0x0
-#define INITIATOR_CPU		0x1
-#define INITIATOR_PCI		0x2
-#define INITIATOR_ISA		0x3
-#define INITIATOR_MEMORY	0x4
-#define INITIATOR_POWERMGM	0x5
-#define TARGET_UNKNOWN		0x0
-#define TARGET_CPU		0x1
-#define TARGET_PCI		0x2
-#define TARGET_ISA		0x3
-#define TARGET_MEMORY		0x4
-#define TARGET_POWERMGM		0x5
-#define TYPE_RETRY		0x01
-#define TYPE_TCE_ERR		0x02
-#define TYPE_INTERN_DEV_FAIL	0x03
-#define TYPE_TIMEOUT		0x04
-#define TYPE_DATA_PARITY	0x05
-#define TYPE_ADDR_PARITY	0x06
-#define TYPE_CACHE_PARITY	0x07
-#define TYPE_ADDR_INVALID	0x08
-#define TYPE_ECC_UNCORR		0x09
-#define TYPE_ECC_CORR		0x0a
-#define TYPE_EPOW		0x40
-/* I don't add PowerMGM events right now, this is a different topic */
-#define TYPE_PMGM_POWER_SW_ON	0x60
-#define TYPE_PMGM_POWER_SW_OFF	0x61
-#define TYPE_PMGM_LID_OPEN	0x62
-#define TYPE_PMGM_LID_CLOSE	0x63
-#define TYPE_PMGM_SLEEP_BTN	0x64
-#define TYPE_PMGM_WAKE_BTN	0x65
-#define TYPE_PMGM_BATTERY_WARN	0x66
-#define TYPE_PMGM_BATTERY_CRIT	0x67
-#define TYPE_PMGM_SWITCH_TO_BAT	0x68
-#define TYPE_PMGM_SWITCH_TO_AC	0x69
-#define TYPE_PMGM_KBD_OR_MOUSE	0x6a
-#define TYPE_PMGM_ENCLOS_OPEN	0x6b
-#define TYPE_PMGM_ENCLOS_CLOSED	0x6c
-#define TYPE_PMGM_RING_INDICATE	0x6d
-#define TYPE_PMGM_LAN_ATTENTION	0x6e
-#define TYPE_PMGM_TIME_ALARM	0x6f
-#define TYPE_PMGM_CONFIG_CHANGE	0x70
-#define TYPE_PMGM_SERVICE_PROC	0x71
-
-typedef struct _rtas_error_log {
-	unsigned long version:8;		/* Architectural version */
-	unsigned long severity:3;		/* Severity level of error */
-	unsigned long disposition:2;		/* Degree of recovery */
-	unsigned long extended:1;		/* extended log present? */
-	unsigned long /* reserved */ :2;	/* Reserved for future use */
-	unsigned long initiator:4;		/* Initiator of event */
-	unsigned long target:4;			/* Target of failed operation */
-	unsigned long type:8;			/* General event or error*/
-	unsigned long extended_log_length:32;	/* length in bytes */
-} rtas_error_log;
-
-/* ****************************************************************** */
-#define ppc_rtas_errorlog_check_severity(x) \
-	(_errlog_severity[x.severity])
-#define ppc_rtas_errorlog_check_target(x) \
-	(_errlog_target[x.target])
-#define ppc_rtas_errorlog_check_initiator(x) \
-	(_errlog_initiator[x.initiator])
-#define ppc_rtas_errorlog_check_extended(x) \
-	(_errlog_extended[x.extended])
-#define ppc_rtas_errorlog_disect_extended(x) \
-	do { /* implement me */ } while(0)
-extern const char * ppc_rtas_errorlog_check_type (rtas_error_log error_log);
-extern int ppc_rtas_errorlog_scan(void);
-
-
-#endif /* __ERROR_LOG_H__ */
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/platforms/proc_rtas.c linux-2.6.8-rc3-bk3/arch/ppc/platforms/proc_rtas.c
--- linux-2.6.8-rc3-bk2/arch/ppc/platforms/proc_rtas.c	2004-06-16 05:20:26.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/platforms/proc_rtas.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,788 +0,0 @@
-/*
- *   arch/ppc/platforms/proc_rtas.c
- *   Copyright (C) 2000 Tilmann Bitterberg
- *   (tilmann@bitterberg.de)
- *
- *   RTAS (Runtime Abstraction Services) stuff
- *   Intention is to provide a clean user interface
- *   to use the RTAS.
- *
- *   TODO:
- *   Split off a header file and maybe move it to a different
- *   location. Write Documentation on what the /proc/rtas/ entries
- *   actually do.
- */
-
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <linux/ctype.h>
-#include <linux/time.h>
-#include <linux/string.h>
-#include <linux/init.h>
-
-#include <asm/uaccess.h>
-#include <asm/bitops.h>
-#include <asm/processor.h>
-#include <asm/io.h>
-#include <asm/prom.h>
-#include <asm/machdep.h> /* for ppc_md */
-#include <asm/time.h>
-
-/* Token for Sensors */
-#define KEY_SWITCH		0x0001
-#define ENCLOSURE_SWITCH	0x0002
-#define THERMAL_SENSOR		0x0003
-#define LID_STATUS		0x0004
-#define POWER_SOURCE		0x0005
-#define BATTERY_VOLTAGE		0x0006
-#define BATTERY_REMAINING	0x0007
-#define BATTERY_PERCENTAGE	0x0008
-#define EPOW_SENSOR		0x0009
-#define BATTERY_CYCLESTATE	0x000a
-#define BATTERY_CHARGING	0x000b
-
-/* IBM specific sensors */
-#define IBM_SURVEILLANCE	0x2328 /* 9000 */
-#define IBM_FANRPM		0x2329 /* 9001 */
-#define IBM_VOLTAGE		0x232a /* 9002 */
-#define IBM_DRCONNECTOR		0x232b /* 9003 */
-#define IBM_POWERSUPPLY		0x232c /* 9004 */
-#define IBM_INTQUEUE		0x232d /* 9005 */
-
-/* Status return values */
-#define SENSOR_CRITICAL_HIGH	13
-#define SENSOR_WARNING_HIGH	12
-#define SENSOR_NORMAL		11
-#define SENSOR_WARNING_LOW	10
-#define SENSOR_CRITICAL_LOW	 9
-#define SENSOR_SUCCESS		 0
-#define SENSOR_HW_ERROR		-1
-#define SENSOR_BUSY		-2
-#define SENSOR_NOT_EXIST	-3
-#define SENSOR_DR_ENTITY	-9000
-
-/* Location Codes */
-#define LOC_SCSI_DEV_ADDR	'A'
-#define LOC_SCSI_DEV_LOC	'B'
-#define LOC_CPU			'C'
-#define LOC_DISKETTE		'D'
-#define LOC_ETHERNET		'E'
-#define LOC_FAN			'F'
-#define LOC_GRAPHICS		'G'
-/* reserved / not used		'H' */
-#define LOC_IO_ADAPTER		'I'
-/* reserved / not used		'J' */
-#define LOC_KEYBOARD		'K'
-#define LOC_LCD			'L'
-#define LOC_MEMORY		'M'
-#define LOC_NV_MEMORY		'N'
-#define LOC_MOUSE		'O'
-#define LOC_PLANAR		'P'
-#define LOC_OTHER_IO		'Q'
-#define LOC_PARALLEL		'R'
-#define LOC_SERIAL		'S'
-#define LOC_DEAD_RING		'T'
-#define LOC_RACKMOUNTED		'U' /* for _u_nit is rack mounted */
-#define LOC_VOLTAGE		'V'
-#define LOC_SWITCH_ADAPTER	'W'
-#define LOC_OTHER		'X'
-#define LOC_FIRMWARE		'Y'
-#define LOC_SCSI		'Z'
-
-/* Tokens for indicators */
-#define TONE_FREQUENCY		0x0001 /* 0 - 1000 (HZ)*/
-#define TONE_VOLUME		0x0002 /* 0 - 100 (%) */
-#define SYSTEM_POWER_STATE	0x0003
-#define WARNING_LIGHT		0x0004
-#define DISK_ACTIVITY_LIGHT	0x0005
-#define HEX_DISPLAY_UNIT	0x0006
-#define BATTERY_WARNING_TIME	0x0007
-#define CONDITION_CYCLE_REQUEST	0x0008
-#define SURVEILLANCE_INDICATOR	0x2328 /* 9000 */
-#define DR_ACTION		0x2329 /* 9001 */
-#define DR_INDICATOR		0x232a /* 9002 */
-/* 9003 - 9004: Vendor specific */
-#define GLOBAL_INTERRUPT_QUEUE	0x232d /* 9005 */
-/* 9006 - 9999: Vendor specific */
-
-/* other */
-#define MAX_SENSORS		 17  /* I only know of 17 sensors */
-#define MAX_LINELENGTH          256
-#define SENSOR_PREFIX		"ibm,sensor-"
-#define cel_to_fahr(x)		((x*9/5)+32)
-
-
-/* Globals */
-static struct proc_dir_entry *proc_rtas;
-static struct rtas_sensors sensors;
-static struct device_node *rtas;
-static unsigned long power_on_time = 0; /* Save the time the user set */
-static char progress_led[MAX_LINELENGTH];
-
-static unsigned long rtas_tone_frequency = 1000;
-static unsigned long rtas_tone_volume = 0;
-
-/* ****************STRUCTS******************************************* */
-struct individual_sensor {
-	unsigned int token;
-	unsigned int quant;
-};
-
-struct rtas_sensors {
-        struct individual_sensor sensor[MAX_SENSORS];
-	unsigned int quant;
-};
-
-/* ****************************************************************** */
-/* Declarations */
-static int ppc_rtas_sensor_read(char * buf, char ** start, off_t off,
-		int count, int *eof, void *data);
-static ssize_t ppc_rtas_clock_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_clock_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_progress_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_progress_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_poweron_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_poweron_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos);
-
-static ssize_t ppc_rtas_tone_freq_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_tone_freq_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_tone_volume_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos);
-static ssize_t ppc_rtas_tone_volume_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos);
-
-struct file_operations ppc_rtas_poweron_operations = {
-	.read =		ppc_rtas_poweron_read,
-	.write =	ppc_rtas_poweron_write
-};
-struct file_operations ppc_rtas_progress_operations = {
-	.read =		ppc_rtas_progress_read,
-	.write =	ppc_rtas_progress_write
-};
-
-struct file_operations ppc_rtas_clock_operations = {
-	.read =		ppc_rtas_clock_read,
-	.write =	ppc_rtas_clock_write
-};
-
-struct file_operations ppc_rtas_tone_freq_operations = {
-	.read =		ppc_rtas_tone_freq_read,
-	.write =	ppc_rtas_tone_freq_write
-};
-struct file_operations ppc_rtas_tone_volume_operations = {
-	.read =		ppc_rtas_tone_volume_read,
-	.write =	ppc_rtas_tone_volume_write
-};
-
-int ppc_rtas_find_all_sensors (void);
-int ppc_rtas_process_sensor(struct individual_sensor s, int state,
-		int error, char * buf);
-char * ppc_rtas_process_error(int error);
-int get_location_code(struct individual_sensor s, char * buf);
-int check_location_string (char *c, char * buf);
-int check_location (char *c, int idx, char * buf);
-
-/* ****************************************************************** */
-/* MAIN                                                               */
-/* ****************************************************************** */
-static int __init proc_rtas_init(void)
-{
-	struct proc_dir_entry *entry;
-
-	rtas = find_devices("rtas");
-	if ((rtas == 0) || (_machine != _MACH_chrp)) {
-		return 1;
-	}
-
-	proc_rtas = proc_mkdir("rtas", 0);
-	if (proc_rtas == 0)
-		return 1;
-
-	/* /proc/rtas entries */
-
-	entry = create_proc_entry("progress", S_IRUGO|S_IWUSR, proc_rtas);
-	if (entry) entry->proc_fops = &ppc_rtas_progress_operations;
-
-	entry = create_proc_entry("clock", S_IRUGO|S_IWUSR, proc_rtas);
-	if (entry) entry->proc_fops = &ppc_rtas_clock_operations;
-
-	entry = create_proc_entry("poweron", S_IWUSR|S_IRUGO, proc_rtas);
-	if (entry) entry->proc_fops = &ppc_rtas_poweron_operations;
-
-	create_proc_read_entry("sensors", S_IRUGO, proc_rtas,
-			ppc_rtas_sensor_read, NULL);
-
-	entry = create_proc_entry("frequency", S_IWUSR|S_IRUGO, proc_rtas);
-	if (entry) entry->proc_fops = &ppc_rtas_tone_freq_operations;
-
-	entry = create_proc_entry("volume", S_IWUSR|S_IRUGO, proc_rtas);
-	if (entry) entry->proc_fops = &ppc_rtas_tone_volume_operations;
-
-	return 0;
-}
-__initcall(proc_rtas_init);
-
-/* ****************************************************************** */
-/* POWER-ON-TIME                                                      */
-/* ****************************************************************** */
-static ssize_t ppc_rtas_poweron_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos)
-{
-	struct rtc_time tm;
-	unsigned long nowtime;
-	char *dest;
-	int error;
-
-	nowtime = simple_strtoul(buf, &dest, 10);
-	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_poweron_write: Invalid time\n");
-		return count;
-	}
-	power_on_time = nowtime; /* save the time */
-
-	to_tm(nowtime, &tm);
-
-	error = call_rtas("set-time-for-power-on", 7, 1, NULL,
-			tm.tm_year, tm.tm_mon, tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec, 0 /* nano */);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting poweron time returned: %s\n",
-				ppc_rtas_process_error(error));
-	return count;
-}
-/* ****************************************************************** */
-static ssize_t ppc_rtas_poweron_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos)
-{
-	int n;
-	if (power_on_time == 0)
-		n = sprintf(buf, "Power on time not set\n");
-	else
-		n = sprintf(buf, "%lu\n", power_on_time);
-
-	if (*ppos >= strlen(buf))
-		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
-	if (n > count)
-		n = count;
-	*ppos += n;
-	return n;
-}
-
-/* ****************************************************************** */
-/* PROGRESS                                                           */
-/* ****************************************************************** */
-static ssize_t ppc_rtas_progress_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos)
-{
-	unsigned long hex;
-
-	strcpy(progress_led, buf); /* save the string */
-	/* Lets see if the user passed hexdigits */
-	hex = simple_strtoul(buf, NULL, 10);
-
-	ppc_md.progress ((char *)buf, hex);
-	return count;
-
-	/* clear the line */ /* ppc_md.progress("                   ", 0xffff);*/
-}
-/* ****************************************************************** */
-static ssize_t ppc_rtas_progress_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos)
-{
-	int n = 0;
-	if (progress_led != NULL)
-		n = sprintf (buf, "%s\n", progress_led);
-	if (*ppos >= strlen(buf))
-		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
-	if (n > count)
-		n = count;
-	*ppos += n;
-	return n;
-}
-
-/* ****************************************************************** */
-/* CLOCK                                                              */
-/* ****************************************************************** */
-static ssize_t ppc_rtas_clock_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos)
-{
-	struct rtc_time tm;
-	unsigned long nowtime;
-	char *dest;
-	int error;
-
-	nowtime = simple_strtoul(buf, &dest, 10);
-	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_clock_write: Invalid time\n");
-		return count;
-	}
-
-	to_tm(nowtime, &tm);
-	error = call_rtas("set-time-of-day", 7, 1, NULL,
-			tm.tm_year, tm.tm_mon, tm.tm_mday,
-			tm.tm_hour, tm.tm_min, tm.tm_sec, 0);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting the clock returned: %s\n",
-				ppc_rtas_process_error(error));
-	return count;
-}
-/* ****************************************************************** */
-static ssize_t ppc_rtas_clock_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos)
-{
-	unsigned int year, mon, day, hour, min, sec;
-	unsigned long *ret = kmalloc(4*8, GFP_KERNEL);
-	int n, error;
-
-	error = call_rtas("get-time-of-day", 0, 8, ret);
-
-	year = ret[0]; mon  = ret[1]; day  = ret[2];
-	hour = ret[3]; min  = ret[4]; sec  = ret[5];
-
-	if (error != 0){
-		printk(KERN_WARNING "error: reading the clock returned: %s\n",
-				ppc_rtas_process_error(error));
-		n = sprintf (buf, "0");
-	} else {
-		n = sprintf (buf, "%lu\n", mktime(year, mon, day, hour, min, sec));
-	}
-	kfree(ret);
-
-	if (*ppos >= strlen(buf))
-		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
-	if (n > count)
-		n = count;
-	*ppos += n;
-	return n;
-}
-
-/* ****************************************************************** */
-/* SENSOR STUFF                                                       */
-/* ****************************************************************** */
-static int ppc_rtas_sensor_read(char * buf, char ** start, off_t off,
-		int count, int *eof, void *data)
-{
-	int i,j,n;
-	unsigned long ret;
-	int state, error;
-	char buffer[MAX_LINELENGTH*MAX_SENSORS]; /* May not be enough */
-
-	if (count < 0)
-		return -EINVAL;
-
-	n  = sprintf ( buffer  , "RTAS (RunTime Abstraction Services) Sensor Information\n");
-	n += sprintf ( buffer+n, "Sensor\t\tValue\t\tCondition\tLocation\n");
-	n += sprintf ( buffer+n, "********************************************************\n");
-
-	if (ppc_rtas_find_all_sensors() != 0) {
-		n += sprintf ( buffer+n, "\nNo sensors are available\n");
-		goto return_string;
-	}
-
-	for (i=0; i<sensors.quant; i++) {
-		j = sensors.sensor[i].quant;
-		/* A sensor may have multiple instances */
-		while (j >= 0) {
-			error =	call_rtas("get-sensor-state", 2, 2, &ret,
-				  sensors.sensor[i].token, sensors.sensor[i].quant-j);
-			state = (int) ret;
-			n += ppc_rtas_process_sensor(sensors.sensor[i], state, error, buffer+n );
-			n += sprintf (buffer+n, "\n");
-			j--;
-		} /* while */
-	} /* for */
-
-return_string:
-	if (off >= strlen(buffer)) {
-		*eof = 1;
-		return 0;
-	}
-	if (n > strlen(buffer) - off)
-		n = strlen(buffer) - off;
-	if (n > count)
-		n = count;
-	else
-		*eof = 1;
-	memcpy(buf, buffer + off, n);
-	*start = buf;
-	return n;
-}
-
-/* ****************************************************************** */
-
-int ppc_rtas_find_all_sensors (void)
-{
-	unsigned long *utmp;
-	int len, i, j;
-
-	utmp = (unsigned long *) get_property(rtas, "rtas-sensors", &len);
-	if (utmp == NULL) {
-		printk (KERN_ERR "error: could not get rtas-sensors\n");
-		return 1;
-	}
-
-	sensors.quant = len / 8;      /* int + int */
-
-	for (i=0, j=0; j<sensors.quant; i+=2, j++) {
-		sensors.sensor[j].token = utmp[i];
-		sensors.sensor[j].quant = utmp[i+1];
-	}
-	return 0;
-}
-
-/* ****************************************************************** */
-/*
- * Builds a string of what rtas returned
- */
-char * ppc_rtas_process_error(int error)
-{
-	switch (error) {
-		case SENSOR_CRITICAL_HIGH:
-			return "(critical high)";
-		case SENSOR_WARNING_HIGH:
-			return "(warning high)";
-		case SENSOR_NORMAL:
-			return "(normal)";
-		case SENSOR_WARNING_LOW:
-			return "(warning low)";
-		case SENSOR_CRITICAL_LOW:
-			return "(critical low)";
-		case SENSOR_SUCCESS:
-			return "(read ok)";
-		case SENSOR_HW_ERROR:
-			return "(hardware error)";
-		case SENSOR_BUSY:
-			return "(busy)";
-		case SENSOR_NOT_EXIST:
-			return "(non existant)";
-		case SENSOR_DR_ENTITY:
-			return "(dr entity removed)";
-		default:
-			return "(UNKNOWN)";
-	}
-}
-
-/* ****************************************************************** */
-/*
- * Builds a string out of what the sensor said
- */
-
-int ppc_rtas_process_sensor(struct individual_sensor s, int state,
-		int error, char * buf)
-{
-	/* Defined return vales */
-	const char * key_switch[]        = { "Off\t", "Normal\t", "Secure\t", "Mainenance" };
-	const char * enclosure_switch[]  = { "Closed", "Open" };
-	const char * lid_status[]        = { " ", "Open", "Closed" };
-	const char * power_source[]      = { "AC\t", "Battery", "AC & Battery" };
-	const char * battery_remaining[] = { "Very Low", "Low", "Mid", "High" };
-	const char * epow_sensor[]       = {
-		"EPOW Reset", "Cooling warning", "Power warning",
-		"System shutdown", "System halt", "EPOW main enclosure",
-		"EPOW power off" };
-	const char * battery_cyclestate[]  = { "None", "In progress", "Requested" };
-	const char * battery_charging[]    = { "Charging", "Discharching", "No current flow" };
-	const char * ibm_drconnector[]     = { "Empty", "Present" };
-	const char * ibm_intqueue[]        = { "Disabled", "Enabled" };
-
-	int have_strings = 0;
-	int temperature = 0;
-	int unknown = 0;
-	int n = 0;
-
-	/* What kind of sensor do we have here? */
-	switch (s.token) {
-		case KEY_SWITCH:
-			n += sprintf(buf+n, "Key switch:\t");
-			n += sprintf(buf+n, "%s\t", key_switch[state]);
-			have_strings = 1;
-			break;
-		case ENCLOSURE_SWITCH:
-			n += sprintf(buf+n, "Enclosure switch:\t");
-			n += sprintf(buf+n, "%s\t", enclosure_switch[state]);
-			have_strings = 1;
-			break;
-		case THERMAL_SENSOR:
-			n += sprintf(buf+n, "Temp. (C/F):\t");
-			temperature = 1;
-			break;
-		case LID_STATUS:
-			n += sprintf(buf+n, "Lid status:\t");
-			n += sprintf(buf+n, "%s\t", lid_status[state]);
-			have_strings = 1;
-			break;
-		case POWER_SOURCE:
-			n += sprintf(buf+n, "Power source:\t");
-			n += sprintf(buf+n, "%s\t", power_source[state]);
-			have_strings = 1;
-			break;
-		case BATTERY_VOLTAGE:
-			n += sprintf(buf+n, "Battery voltage:\t");
-			break;
-		case BATTERY_REMAINING:
-			n += sprintf(buf+n, "Battery remaining:\t");
-			n += sprintf(buf+n, "%s\t", battery_remaining[state]);
-			have_strings = 1;
-			break;
-		case BATTERY_PERCENTAGE:
-			n += sprintf(buf+n, "Battery percentage:\t");
-			break;
-		case EPOW_SENSOR:
-			n += sprintf(buf+n, "EPOW Sensor:\t");
-			n += sprintf(buf+n, "%s\t", epow_sensor[state]);
-			have_strings = 1;
-			break;
-		case BATTERY_CYCLESTATE:
-			n += sprintf(buf+n, "Battery cyclestate:\t");
-			n += sprintf(buf+n, "%s\t", battery_cyclestate[state]);
-			have_strings = 1;
-			break;
-		case BATTERY_CHARGING:
-			n += sprintf(buf+n, "Battery Charging:\t");
-			n += sprintf(buf+n, "%s\t", battery_charging[state]);
-			have_strings = 1;
-			break;
-		case IBM_SURVEILLANCE:
-			n += sprintf(buf+n, "Surveillance:\t");
-			break;
-		case IBM_FANRPM:
-			n += sprintf(buf+n, "Fan (rpm):\t");
-			break;
-		case IBM_VOLTAGE:
-			n += sprintf(buf+n, "Voltage (mv):\t");
-			break;
-		case IBM_DRCONNECTOR:
-			n += sprintf(buf+n, "DR connector:\t");
-			n += sprintf(buf+n, "%s\t", ibm_drconnector[state]);
-			have_strings = 1;
-			break;
-		case IBM_POWERSUPPLY:
-			n += sprintf(buf+n, "Powersupply:\t");
-			break;
-		case IBM_INTQUEUE:
-			n += sprintf(buf+n, "Interrupt queue:\t");
-			n += sprintf(buf+n, "%s\t", ibm_intqueue[state]);
-			have_strings = 1;
-			break;
-		default:
-			n += sprintf(buf+n,  "Unkown sensor (type %d), ignoring it\n",
-					s.token);
-			unknown = 1;
-			have_strings = 1;
-			break;
-	}
-	if (have_strings == 0) {
-		if (temperature) {
-			n += sprintf(buf+n, "%4d /%4d\t", state, cel_to_fahr(state));
-		} else
-			n += sprintf(buf+n, "%10d\t", state);
-	}
-	if (unknown == 0) {
-		n += sprintf ( buf+n, "%s\t", ppc_rtas_process_error(error));
-		n += get_location_code(s, buf+n);
-	}
-	return n;
-}
-
-/* ****************************************************************** */
-
-int check_location (char *c, int idx, char * buf)
-{
-	int n = 0;
-
-	switch (*(c+idx)) {
-		case LOC_PLANAR:
-			n += sprintf ( buf, "Planar #%c", *(c+idx+1));
-			break;
-		case LOC_CPU:
-			n += sprintf ( buf, "CPU #%c", *(c+idx+1));
-			break;
-		case LOC_FAN:
-			n += sprintf ( buf, "Fan #%c", *(c+idx+1));
-			break;
-		case LOC_RACKMOUNTED:
-			n += sprintf ( buf, "Rack #%c", *(c+idx+1));
-			break;
-		case LOC_VOLTAGE:
-			n += sprintf ( buf, "Voltage #%c", *(c+idx+1));
-			break;
-		case LOC_LCD:
-			n += sprintf ( buf, "LCD #%c", *(c+idx+1));
-			break;
-		case '.':
-			n += sprintf ( buf, "- %c", *(c+idx+1));
-		default:
-			n += sprintf ( buf, "Unknown location");
-			break;
-	}
-	return n;
-}
-
-
-/* ****************************************************************** */
-/*
- * Format:
- * ${LETTER}${NUMBER}[[-/]${LETTER}${NUMBER} [ ... ] ]
- * the '.' may be an abbrevation
- */
-int check_location_string (char *c, char *buf)
-{
-	int n=0,i=0;
-
-	while (c[i]) {
-		if (isalpha(c[i]) || c[i] == '.') {
-			 n += check_location(c, i, buf+n);
-		}
-		else if (c[i] == '/' || c[i] == '-')
-			n += sprintf(buf+n, " at ");
-		i++;
-	}
-	return n;
-}
-
-
-/* ****************************************************************** */
-
-int get_location_code(struct individual_sensor s, char * buffer)
-{
-	char rstr[512], tmp[10], tmp2[10];
-	int n=0, i=0, llen, len;
-	/* char *buf = kmalloc(MAX_LINELENGTH, GFP_KERNEL); */
-	char *ret;
-
-	static int pos = 0; /* remember position where buffer was */
-
-	/* construct the sensor number like 0003 */
-	/* fill with zeros */
-	n = sprintf(tmp, "%d", s.token);
-	len = strlen(tmp);
-	while (strlen(tmp) < 4)
-		n += sprintf (tmp+n, "0");
-
-	/* invert the string */
-	while (tmp[i]) {
-		if (i<len)
-			tmp2[4-len+i] = tmp[i];
-		else
-			tmp2[3-i] = tmp[i];
-		i++;
-	}
-	tmp2[4] = '\0';
-
-	sprintf (rstr, SENSOR_PREFIX"%s", tmp2);
-
-	ret = (char *) get_property(rtas, rstr, &llen);
-
-	n=0;
-	if (ret[0] == '\0')
-		n += sprintf ( buffer+n, "--- ");/* does not have a location */
-	else {
-		char t[50];
-		ret += pos;
-
-		n += check_location_string(ret, buffer + n);
-		n += sprintf ( buffer+n, " ");
-		/* see how many characters we have printed */
-		sprintf ( t, "%s ", ret);
-
-		pos += strlen(t);
-		if (pos >= llen) pos=0;
-	}
-	return n;
-}
-/* ****************************************************************** */
-/* INDICATORS - Tone Frequency                                        */
-/* ****************************************************************** */
-static ssize_t ppc_rtas_tone_freq_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos)
-{
-	unsigned long freq;
-	char *dest;
-	int error;
-	freq = simple_strtoul(buf, &dest, 10);
-	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_tone_freq_write: Invalid tone freqency\n");
-		return count;
-	}
-	if (freq < 0) freq = 0;
-	rtas_tone_frequency = freq; /* save it for later */
-	error = call_rtas("set-indicator", 3, 1, NULL,
-			TONE_FREQUENCY, 0, freq);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting tone frequency returned: %s\n",
-				ppc_rtas_process_error(error));
-	return count;
-}
-/* ****************************************************************** */
-static ssize_t ppc_rtas_tone_freq_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos)
-{
-	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_frequency);
-
-	if (*ppos >= strlen(buf))
-		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
-	if (n > count)
-		n = count;
-	*ppos += n;
-	return n;
-}
-/* ****************************************************************** */
-/* INDICATORS - Tone Volume                                           */
-/* ****************************************************************** */
-static ssize_t ppc_rtas_tone_volume_write(struct file * file, const char * buf,
-		size_t count, loff_t *ppos)
-{
-	unsigned long volume;
-	char *dest;
-	int error;
-	volume = simple_strtoul(buf, &dest, 10);
-	if (*dest != '\0' && *dest != '\n') {
-		printk("ppc_rtas_tone_volume_write: Invalid tone volume\n");
-		return count;
-	}
-	if (volume < 0) volume = 0;
-	if (volume > 100) volume = 100;
-
-        rtas_tone_volume = volume; /* save it for later */
-	error = call_rtas("set-indicator", 3, 1, NULL,
-			TONE_VOLUME, 0, volume);
-	if (error != 0)
-		printk(KERN_WARNING "error: setting tone volume returned: %s\n",
-				ppc_rtas_process_error(error));
-	return count;
-}
-/* ****************************************************************** */
-static ssize_t ppc_rtas_tone_volume_read(struct file * file, char * buf,
-		size_t count, loff_t *ppos)
-{
-	int n;
-	n = sprintf(buf, "%lu\n", rtas_tone_volume);
-
-	if (*ppos >= strlen(buf))
-		return 0;
-	if (n > strlen(buf) - *ppos)
-		n = strlen(buf) - *ppos;
-	if (n > count)
-		n = count;
-	*ppos += n;
-	return n;
-}
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/syslib/Makefile linux-2.6.8-rc3-bk3/arch/ppc/syslib/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc/syslib/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/syslib/Makefile	2004-08-08 17:25:03.463182248 +0000
@@ -2,16 +2,6 @@
 # Makefile for the linux kernel.
 #
 
-ifdef CONFIG_PPC64BRIDGE
-EXTRA_AFLAGS		:= -Wa,-mppc64bridge
-endif
-ifdef CONFIG_4xx
-EXTRA_AFLAGS		:= -Wa,-m405
-endif
-ifdef CONFIG_E500
-EXTRA_AFLAGS		:= -Wa,-me500
-endif
-
 CFLAGS_prom_init.o      += -fPIC
 CFLAGS_btext.o          += -fPIC
 
@@ -25,7 +15,8 @@ ifeq ($(CONFIG_4xx),y)
 obj-$(CONFIG_4xx)		+= ppc4xx_pic.o
 obj-$(CONFIG_40x)		+= ppc4xx_setup.o
 obj-$(CONFIG_GEN_RTC)		+= todc_time.o
-obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
+obj-$(CONFIG_PPC4xx_DMA)	+= ppc4xx_dma.o
+obj-$(CONFIG_PPC4xx_EDMA)	+= ppc4xx_sgdma.o
 ifeq ($(CONFIG_40x),y)
 obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o ppc405_pci.o
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/syslib/ppc4xx_dma.c linux-2.6.8-rc3-bk3/arch/ppc/syslib/ppc4xx_dma.c
--- linux-2.6.8-rc3-bk2/arch/ppc/syslib/ppc4xx_dma.c	2004-06-16 05:20:26.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/syslib/ppc4xx_dma.c	2004-08-08 17:25:03.475180424 +0000
@@ -1,42 +1,427 @@
 /*
- * Author: Pete Popov <ppopov@mvista.com> or source@mvista.com
+ * arch/ppc/kernel/ppc4xx_dma.c
  *
- * arch/ppc/kernel/ppc405_dma.c
+ * IBM PPC4xx DMA engine core library
  *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
+ * Copyright 2000-2004 MontaVista Software Inc.
  *
- * IBM 405 DMA Controller Functions
+ * Cleaned up and converted to new DCR access
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <asm/system.h>
-#include <asm/io.h>
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/init.h>
 #include <linux/module.h>
 
-#include <asm/ppc405_dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+ppc_dma_ch_t dma_channels[MAX_PPC4xx_DMA_CHANNELS];
+
+int
+ppc4xx_get_dma_status(void)
+{
+	return (mfdcr(DCRN_DMASR));
+}
+
+void
+ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr)
+{
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("set_src_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef PPC4xx_DMA64BIT
+	mtdcr(DCRN_DMASAH0 + dmanr*2, (u32)(src_addr >> 32));
+#else
+	mtdcr(DCRN_DMASA0 + dmanr*2, (u32)src_addr);
+#endif
+}
+
+void
+ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr)
+{
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("set_dst_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef PPC4xx_DMA64BIT
+	mtdcr(DCRN_DMADAH0 + dmanr*2, (u32)(dst_addr >> 32));
+#else
+	mtdcr(DCRN_DMADA0 + dmanr*2, (u32)dst_addr);
+#endif
+}
+
+void
+ppc4xx_enable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	unsigned int status_bits[] = { DMA_CS0 | DMA_TS0 | DMA_CH0_ERR,
+				       DMA_CS1 | DMA_TS1 | DMA_CH1_ERR,
+				       DMA_CS2 | DMA_TS2 | DMA_CH2_ERR,
+				       DMA_CS3 | DMA_TS3 | DMA_CH3_ERR};
+
+	if (p_dma_ch->in_use) {
+		printk("enable_dma: channel %d in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("enable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	if (p_dma_ch->mode == DMA_MODE_READ) {
+		/* peripheral to memory */
+		ppc4xx_set_src_addr(dmanr, 0);
+		ppc4xx_set_dst_addr(dmanr, p_dma_ch->addr);
+	} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
+		/* memory to peripheral */
+		ppc4xx_set_src_addr(dmanr, p_dma_ch->addr);
+		ppc4xx_set_dst_addr(dmanr, 0);
+	}
+
+	/* for other xfer modes, the addresses are already set */
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+
+	control &= ~(DMA_TM_MASK | DMA_TD);	/* clear all mode bits */
+	if (p_dma_ch->mode == DMA_MODE_MM) {
+		/* software initiated memory to memory */
+		control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+	}
+
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
+
+	/*
+	 * Clear the CS, TS, RI bits for the channel from DMASR.  This
+	 * has been observed to happen correctly only after the mode and
+	 * ETD/DCE bits in DMACRx are set above.  Must do this before
+	 * enabling the channel.
+	 */
+
+	mtdcr(DCRN_DMASR, status_bits[dmanr]);
+
+	/*
+	 * For device-paced transfers, Terminal Count Enable apparently
+	 * must be on, and this must be turned on after the mode, etc.
+	 * bits are cleared above (at least on Redwood-6).
+	 */
+
+	if ((p_dma_ch->mode == DMA_MODE_MM_DEVATDST) ||
+	    (p_dma_ch->mode == DMA_MODE_MM_DEVATSRC))
+		control |= DMA_TCE_ENABLE;
+
+	/*
+	 * Now enable the channel.
+	 */
+
+	control |= (p_dma_ch->mode | DMA_CE_ENABLE);
+
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
+
+	p_dma_ch->in_use = 1;
+}
+
+void
+ppc4xx_disable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (!p_dma_ch->in_use) {
+		printk("disable_dma: channel %d not in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("disable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+	control &= ~DMA_CE_ENABLE;
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
+
+	p_dma_ch->in_use = 0;
+}
+
+/*
+ * Sets the dma mode for single DMA transfers only.
+ * For scatter/gather transfers, the mode is passed to the
+ * alloc_dma_handle() function as one of the parameters.
+ *
+ * The mode is simply saved and used later.  This allows
+ * the driver to call set_dma_mode() and set_dma_addr() in
+ * any order.
+ *
+ * Valid mode values are:
+ *
+ * DMA_MODE_READ          peripheral to memory
+ * DMA_MODE_WRITE         memory to peripheral
+ * DMA_MODE_MM            memory to memory
+ * DMA_MODE_MM_DEVATSRC   device-paced memory to memory, device at src
+ * DMA_MODE_MM_DEVATDST   device-paced memory to memory, device at dst
+ */
+int
+ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("set_dma_mode: bad channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch->mode = mode;
+
+	return DMA_STATUS_GOOD;
+}
 
+/*
+ * Sets the DMA Count register. Note that 'count' is in bytes.
+ * However, the DMA Count register counts the number of "transfers",
+ * where each transfer is equal to the bus width.  Thus, count
+ * MUST be a multiple of the bus width.
+ */
+void
+ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (count & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (count & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (count & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("set_dma_count: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk
+			    ("Warning: set_dma_count count 0x%x bus width %d\n",
+			     count, p_dma_ch->pwidth);
+	}
+#endif
+
+	count = count >> p_dma_ch->shift;
+
+	mtdcr(DCRN_DMACT0 + (dmanr * 0x8), count);
+}
 
 /*
- * Function prototypes
+ *   Returns the number of bytes left to be transfered.
+ *   After a DMA transfer, this should return zero.
+ *   Reading this while a DMA transfer is still in progress will return
+ *   unpredictable results.
  */
+int
+ppc4xx_get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 
-int hw_init_dma_channel(unsigned int,  ppc_dma_ch_t *);
-int init_dma_channel(unsigned int);
-int get_channel_config(unsigned int, ppc_dma_ch_t *);
-int set_channel_priority(unsigned int, unsigned int);
-unsigned int get_peripheral_width(unsigned int);
-int alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
-void free_dma_handle(sgl_handle_t);
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_get_dma_residue: bad channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
+	count = mfdcr(DCRN_DMACT0 + (dmanr * 0x8));
 
-ppc_dma_ch_t dma_channels[MAX_405GP_DMA_CHANNELS];
+	return (count << p_dma_ch->shift);
+}
+
+/*
+ * Sets the DMA address for a memory to peripheral or peripheral
+ * to memory transfer.  The address is just saved in the channel
+ * structure for now and used later in enable_dma().
+ */
+void
+ppc4xx_set_dma_addr(unsigned int dmanr, phys_addr_t addr)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if ((unsigned) addr & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if ((unsigned) addr & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if ((unsigned) addr & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_set_dma_addr: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk("Warning: ppc4xx_set_dma_addr addr 0x%x bus width %d\n",
+			       addr, p_dma_ch->pwidth);
+	}
+#endif
+
+	/* save dma address and program it later after we know the xfer mode */
+	p_dma_ch->addr = addr;
+}
+
+/*
+ * Sets both DMA addresses for a memory to memory transfer.
+ * For memory to peripheral or peripheral to memory transfers
+ * the function set_dma_addr() should be used instead.
+ */
+void
+ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+		     phys_addr_t dst_dma_addr)
+{
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr2: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef DEBUG_4xxDMA
+	{
+		ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+			case PW_8:
+				break;
+			case PW_16:
+				if (((unsigned) src_dma_addr & 0x1) ||
+						((unsigned) dst_dma_addr & 0x1)
+				   )
+					error = 1;
+				break;
+			case PW_32:
+				if (((unsigned) src_dma_addr & 0x3) ||
+						((unsigned) dst_dma_addr & 0x3)
+				   )
+					error = 1;
+				break;
+			case PW_64:
+				if (((unsigned) src_dma_addr & 0x7) ||
+						((unsigned) dst_dma_addr & 0x7)
+				   )
+					error = 1;
+				break;
+			default:
+				printk("ppc4xx_set_dma_addr2: invalid bus width: 0x%x\n",
+						p_dma_ch->pwidth);
+				return;
+		}
+		if (error)
+			printk
+				("Warning: ppc4xx_set_dma_addr2 src 0x%x dst 0x%x bus width %d\n",
+				 src_dma_addr, dst_dma_addr, p_dma_ch->pwidth);
+	}
+#endif
+
+	ppc4xx_set_src_addr(dmanr, src_dma_addr);
+	ppc4xx_set_dst_addr(dmanr, dst_dma_addr);
+}
+
+/*
+ * Enables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be enabled, if
+ * they were previously disabled.
+ */
+int
+ppc4xx_enable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_enable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch->int_enable = 1;
+
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+	control |= DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Disables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be disabled, if
+ * they were previously enabled.
+ */
+int
+ppc4xx_disable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_disable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch->int_enable = 0;
+
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+	control &= ~DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
+
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Configures a DMA channel, including the peripheral bus width, if a
@@ -47,166 +432,112 @@ ppc_dma_ch_t dma_channels[MAX_405GP_DMA_
  * called from platform specific init code.  The driver should not need to
  * call this function.
  */
-int hw_init_dma_channel(unsigned int dmanr,  ppc_dma_ch_t *p_init)
+int
+ppc4xx_init_dma_channel(unsigned int dmanr, ppc_dma_ch_t * p_init)
 {
-    unsigned int polarity;
-    uint32_t control = 0;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-    if (!p_init) {
-        printk("hw_init_dma_channel: NULL p_init\n");
-        return DMA_STATUS_NULL_POINTER;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("hw_init_dma_channel: bad channel %d\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
+	unsigned int polarity;
+	uint32_t control = 0;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	DMA_MODE_READ = (unsigned long) DMA_TD;	/* Peripheral to Memory */
+	DMA_MODE_WRITE = 0;	/* Memory to Peripheral */
+
+	if (!p_init) {
+		printk("ppc4xx_init_dma_channel: NULL p_init\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_init_dma_channel: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    /* Setup the control register based on the values passed to
-     * us in p_init.  Then, over-write the control register with this
-     * new value.
-     */
-
-    control |= (
-                SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */
-                SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */
-                SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */
-                SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */
-                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */
-                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */
-                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */
-                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */
-                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */
-                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */
-                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */
-                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */
-                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */
-                );
-
-    switch (dmanr) {
-        case 0:
-            /* clear all polarity signals and then "or" in new signal levels */
-            polarity &= ~(DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            polarity |= p_dma_ch->polarity;
-#if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
-#endif
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            polarity &= ~(DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+	/* Setup the control register based on the values passed to
+	 * us in p_init.  Then, over-write the control register with this
+	 * new value.
+	 */
+	control |= SET_DMA_CONTROL;
+
+	/* clear all polarity signals and then "or" in new signal levels */
+	polarity &= ~GET_DMA_POLARITY(dmanr);
+	polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+	mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            polarity &= ~(DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            polarity |= p_dma_ch->polarity;
-#if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
-#endif
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            polarity &= ~(DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            polarity |= p_dma_ch->polarity;
-#if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
-#endif
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    /* save these values in our dma channel structure */
-    memcpy(p_dma_ch, p_init, sizeof(ppc_dma_ch_t));
-
-    /*
-     * The peripheral width values written in the control register are:
-     *   PW_8                 0
-     *   PW_16                1
-     *   PW_32                2
-     *   PW_64                3
-     *
-     *   Since the DMA count register takes the number of "transfers",
-     *   we need to divide the count sent to us in certain
-     *   functions by the appropriate number.  It so happens that our
-     *   right shift value is equal to the peripheral width value.
-     */
-    p_dma_ch->shift = p_init->pwidth;
-
-    /*
-     * Save the control word for easy access.
-     */
-    p_dma_ch->control = control;
-
-    mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
-    return DMA_STATUS_GOOD;
-}
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
 
+	/* save these values in our dma channel structure */
+	memcpy(p_dma_ch, p_init, sizeof (ppc_dma_ch_t));
 
+	/*
+	 * The peripheral width values written in the control register are:
+	 *   PW_8                 0
+	 *   PW_16                1
+	 *   PW_32                2
+	 *   PW_64                3
+	 *
+	 *   Since the DMA count register takes the number of "transfers",
+	 *   we need to divide the count sent to us in certain
+	 *   functions by the appropriate number.  It so happens that our
+	 *   right shift value is equal to the peripheral width value.
+	 */
+	p_dma_ch->shift = p_init->pwidth;
+
+	/*
+	 * Save the control word for easy access.
+	 */
+	p_dma_ch->control = control;
 
+	mtdcr(DCRN_DMASR, 0xffffffff);	/* clear status register */
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * This function returns the channel configuration.
  */
-int get_channel_config(unsigned int dmanr, ppc_dma_ch_t *p_dma_ch)
+int
+ppc4xx_get_channel_config(unsigned int dmanr, ppc_dma_ch_t * p_dma_ch)
 {
-    unsigned int polarity;
-    unsigned int control;
+	unsigned int polarity;
+	unsigned int control;
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_get_channel_config: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    switch (dmanr) {
-        case 0:
-            p_dma_ch->polarity =
-                polarity & (DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            p_dma_ch->polarity =
-                polarity & (DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            p_dma_ch->polarity =
-                polarity & (DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            p_dma_ch->polarity =
-                polarity & (DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    p_dma_ch->cp = GET_DMA_PRIORITY(control);
-    p_dma_ch->pwidth = GET_DMA_PW(control);
-    p_dma_ch->psc = GET_DMA_PSC(control);
-    p_dma_ch->pwc = GET_DMA_PWC(control);
-    p_dma_ch->phc = GET_DMA_PHC(control);
-    p_dma_ch->pf = GET_DMA_PREFETCH(control);
-    p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
-    p_dma_ch->shift = GET_DMA_PW(control);
+	p_dma_ch->polarity = polarity & GET_DMA_POLARITY(dmanr);
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+
+	p_dma_ch->cp = GET_DMA_PRIORITY(control);
+	p_dma_ch->pwidth = GET_DMA_PW(control);
+	p_dma_ch->psc = GET_DMA_PSC(control);
+	p_dma_ch->pwc = GET_DMA_PWC(control);
+	p_dma_ch->phc = GET_DMA_PHC(control);
+	p_dma_ch->ce = GET_DMA_CE_ENABLE(control);
+	p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
+	p_dma_ch->shift = GET_DMA_PW(control);
 
-    return DMA_STATUS_GOOD;
+#ifdef CONFIG_PPC4xx_EDMA
+	p_dma_ch->pf = GET_DMA_PREFETCH(control);
+#else
+	p_dma_ch->ch_enable = GET_DMA_CH(control);
+	p_dma_ch->ece_enable = GET_DMA_ECE(control);
+	p_dma_ch->tcd_disable = GET_DMA_TCD(control);
+#endif
+	return DMA_STATUS_GOOD;
 }
 
 /*
@@ -222,50 +553,28 @@ int get_channel_config(unsigned int dman
  * PRIORITY_HIGH
  *
  */
-int set_channel_priority(unsigned int dmanr, unsigned int priority)
+int
+ppc4xx_set_channel_priority(unsigned int dmanr, unsigned int priority)
 {
-    unsigned int control;
+	unsigned int control;
 
-#ifdef DEBUG_405DMA
-    if ( (priority != PRIORITY_LOW) &&
-            (priority != PRIORITY_MID_LOW) &&
-            (priority != PRIORITY_MID_HIGH) &&
-            (priority != PRIORITY_HIGH)) {
-        printk("set_channel_priority: bad priority: 0x%x\n", priority);
-    }
-#endif
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_channel_priority: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("set_channel_priority: bad channel: %d\n", dmanr);
-#endif
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-    return DMA_STATUS_GOOD;
-}
+	if ((priority != PRIORITY_LOW) &&
+	    (priority != PRIORITY_MID_LOW) &&
+	    (priority != PRIORITY_MID_HIGH) && (priority != PRIORITY_HIGH)) {
+		printk("ppc4xx_set_channel_priority: bad priority: 0x%x\n", priority);
+	}
 
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
+	control |= SET_DMA_PRIORITY(priority);
+	mtdcr(DCRN_DMACR0 + (dmanr * 0x8), control);
 
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Returns the width of the peripheral attached to this channel. This assumes
@@ -280,213 +589,36 @@ int set_channel_priority(unsigned int dm
  *
  *   The function returns 0 on error.
  */
-unsigned int get_peripheral_width(unsigned int dmanr)
+unsigned int
+ppc4xx_get_peripheral_width(unsigned int dmanr)
 {
-    unsigned int control;
-
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("get_peripheral_width: bad channel: %d\n", dmanr);
-#endif
-            return 0;
-    }
-    return(GET_DMA_PW(control));
-}
-
-
-
-
-/*
- *   Create a scatter/gather list handle.  This is simply a structure which
- *   describes a scatter/gather list.
- *
- *   A handle is returned in "handle" which the driver should save in order to
- *   be able to access this list later.  A chunk of memory will be allocated
- *   to be used by the API for internal management purposes, including managing
- *   the sg list and allocating memory for the sgl descriptors.  One page should
- *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use
- *   a whole page for a single sg list, but most likely there will be only one
- *   sg list per channel.
- *
- *   Interrupt notes:
- *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
- *   loads in the control register.  The control word has a "global" interrupt
- *   enable bit for that channel. Interrupts are further qualified by a few bits
- *   in the sgl descriptor count register.  In order to setup an sgl, we have to
- *   know ahead of time whether or not interrupts will be enabled at the completion
- *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
- *   be called before calling alloc_dma_handle().  If the interrupt mode will never
- *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt()
- *   do not have to be called -- interrupts will be enabled or disabled based
- *   on how the channel was configured after powerup by the hw_init_dma_channel()
- *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
- *   however, only the last descriptor will be setup to interrupt. Thus, an
- *   interrupt will occur (if interrupts are enabled) only after the complete
- *   sgl transfer is done.
- */
-int alloc_dma_handle(sgl_handle_t *phandle, unsigned int mode, unsigned int dmanr)
-{
-    sgl_list_info_t *psgl;
-    dma_addr_t dma_addr;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-    uint32_t sg_command;
-    void *ret;
-
-#ifdef DEBUG_405DMA
-    if (!phandle) {
-            printk("alloc_dma_handle: null handle pointer\n");
-            return DMA_STATUS_NULL_POINTER;
-    }
-    switch (mode) {
-        case DMA_MODE_READ:
-        case DMA_MODE_WRITE:
-        case DMA_MODE_MM:
-        case DMA_MODE_MM_DEVATSRC:
-        case DMA_MODE_MM_DEVATDST:
-            break;
-        default:
-            printk("alloc_dma_handle: bad mode 0x%x\n", mode);
-            return DMA_STATUS_BAD_MODE;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("alloc_dma_handle: invalid channel 0x%x\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
+	unsigned int control;
 
-    /* Get a page of memory, which is zeroed out by pci_alloc_consistent() */
-
-/* wrong not a pci device - armin */
-    /* psgl = (sgl_list_info_t *) pci_alloc_consistent(NULL, SGL_LIST_SIZE, &dma_addr);
-*/
-
-	ret = consistent_alloc(GFP_ATOMIC |GFP_DMA, SGL_LIST_SIZE, &dma_addr);
-	if (ret != NULL) {
-		memset(ret, 0,SGL_LIST_SIZE );
-		psgl = (sgl_list_info_t *) ret;
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_get_peripheral_width: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
 	}
 
+	control = mfdcr(DCRN_DMACR0 + (dmanr * 0x8));
 
-    if (psgl == NULL) {
-        *phandle = (sgl_handle_t)NULL;
-        return DMA_STATUS_OUT_OF_MEMORY;
-    }
-
-    psgl->dma_addr = dma_addr;
-    psgl->dmanr = dmanr;
-
-    /*
-     * Modify and save the control word. These word will get written to each sgl
-     * descriptor.  The DMA engine then loads this control word into the control
-     * register every time it reads a new descriptor.
-     */
-    psgl->control = p_dma_ch->control;
-    psgl->control &= ~(DMA_TM_MASK | DMA_TD);  /* clear all "mode" bits first               */
-    psgl->control |= (mode | DMA_CH_ENABLE);   /* save the control word along with the mode */
-
-    if (p_dma_ch->int_enable) {
-        psgl->control |= DMA_CIE_ENABLE;       /* channel interrupt enabled                 */
-    }
-    else {
-        psgl->control &= ~DMA_CIE_ENABLE;
-    }
-
-#if DCRN_ASGC > 0
-    sg_command = mfdcr(DCRN_ASGC);
-    switch (dmanr) {
-        case 0:
-            sg_command |= SSG0_MASK_ENABLE;
-            break;
-        case 1:
-            sg_command |= SSG1_MASK_ENABLE;
-            break;
-        case 2:
-            sg_command |= SSG2_MASK_ENABLE;
-            break;
-        case 3:
-            sg_command |= SSG3_MASK_ENABLE;
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("alloc_dma_handle: bad channel: %d\n", dmanr);
-#endif
-            free_dma_handle((sgl_handle_t)psgl);
-            *phandle = (sgl_handle_t)NULL;
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    mtdcr(DCRN_ASGC, sg_command);  /* enable writing to this channel's sgl control bits */
-#else
-   (void)sg_command;
-#endif
-    psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;   /* sgl descriptor control bits */
-
-    if (p_dma_ch->int_enable) {
-        if (p_dma_ch->tce_enable)
-            psgl->sgl_control |= SG_TCI_ENABLE;
-        else
-            psgl->sgl_control |= SG_ETI_ENABLE;
-    }
-
-    *phandle = (sgl_handle_t)psgl;
-    return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
- * The list must be empty (contain no elements).
- */
-void free_dma_handle(sgl_handle_t handle)
-{
-    sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-
-    if (!handle) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: got NULL\n");
-#endif
-        return;
-    }
-    else if (psgl->phead) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: list not empty\n");
-#endif
-        return;
-    }
-    else if (!psgl->dma_addr) { /* should never happen */
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: no dma address\n");
-#endif
-        return;
-    }
-
-  /* wrong not a PCI device -armin */
-  /*  pci_free_consistent(NULL, SGL_LIST_SIZE, (void *)psgl, psgl->dma_addr); */
-	//	free_pages((unsigned long)psgl, get_order(SGL_LIST_SIZE));
-    	consistent_free((void *)psgl);
-
-
+	return (GET_DMA_PW(control));
 }
 
 
-EXPORT_SYMBOL(hw_init_dma_channel);
-EXPORT_SYMBOL(get_channel_config);
-EXPORT_SYMBOL(set_channel_priority);
-EXPORT_SYMBOL(get_peripheral_width);
-EXPORT_SYMBOL(alloc_dma_handle);
-EXPORT_SYMBOL(free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_init_dma_channel);
+EXPORT_SYMBOL(ppc4xx_get_channel_config);
+EXPORT_SYMBOL(ppc4xx_set_channel_priority);
+EXPORT_SYMBOL(ppc4xx_get_peripheral_width);
 EXPORT_SYMBOL(dma_channels);
+EXPORT_SYMBOL(ppc4xx_set_src_addr);
+EXPORT_SYMBOL(ppc4xx_set_dst_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr2);
+EXPORT_SYMBOL(ppc4xx_enable_dma);
+EXPORT_SYMBOL(ppc4xx_disable_dma);
+EXPORT_SYMBOL(ppc4xx_set_dma_mode);
+EXPORT_SYMBOL(ppc4xx_set_dma_count);
+EXPORT_SYMBOL(ppc4xx_get_dma_residue);
+EXPORT_SYMBOL(ppc4xx_enable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_disable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_get_dma_status);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc/syslib/ppc4xx_sgdma.c linux-2.6.8-rc3-bk3/arch/ppc/syslib/ppc4xx_sgdma.c
--- linux-2.6.8-rc3-bk2/arch/ppc/syslib/ppc4xx_sgdma.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc/syslib/ppc4xx_sgdma.c	2004-08-07 22:02:29.000000000 +0000
@@ -0,0 +1,455 @@
+/*
+ * arch/ppc/kernel/ppc4xx_sgdma.c
+ *
+ * IBM PPC4xx DMA engine scatter/gather library
+ *
+ * Copyright 2002-2003 MontaVista Software Inc.
+ *
+ * Cleaned up and converted to new DCR access
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+void
+ppc4xx_set_sg_addr(int dmanr, phys_addr_t sg_addr)
+{
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_sg_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef PPC4xx_DMA_64BIT
+	mtdcr(DCRN_ASGH0 + (dmanr * 0x8), (u32)(sg_addr >> 32));
+#endif
+	mtdcr(DCRN_ASG0 + (dmanr * 0x8), (u32)sg_addr);
+}
+
+/*
+ *   Add a new sgl descriptor to the end of a scatter/gather list
+ *   which was created by alloc_dma_handle().
+ *
+ *   For a memory to memory transfer, both dma addresses must be
+ *   valid. For a peripheral to memory transfer, one of the addresses
+ *   must be set to NULL, depending on the direction of the transfer:
+ *   memory to peripheral: set dst_addr to NULL,
+ *   peripheral to memory: set src_addr to NULL.
+ */
+int
+ppc4xx_add_dma_sgl(sgl_handle_t handle, phys_addr_t src_addr, phys_addr_t dst_addr,
+		   unsigned int count)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+
+	if (!handle) {
+		printk("ppc4xx_add_dma_sgl: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	}
+
+	if (psgl->dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_add_dma_sgl: bad channel: %d\n", psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		unsigned int aligned =
+		    (unsigned) src_addr | (unsigned) dst_addr | count;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (aligned & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (aligned & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (aligned & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_add_dma_sgl: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return DMA_STATUS_GENERAL_ERROR;
+		}
+		if (error)
+			printk
+			    ("Alignment warning: ppc4xx_add_dma_sgl src 0x%x dst 0x%x count 0x%x bus width var %d\n",
+			     src_addr, dst_addr, count, p_dma_ch->pwidth);
+
+	}
+#endif
+
+	if ((unsigned) (psgl->ptail + 1) >= ((unsigned) psgl + SGL_LIST_SIZE)) {
+		printk("sgl handle out of memory \n");
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	if (!psgl->ptail) {
+		psgl->phead = (ppc_sgl_t *)
+		    ((unsigned) psgl + sizeof (sgl_list_info_t));
+		psgl->phead_dma = psgl->dma_addr + sizeof(sgl_list_info_t);
+		psgl->ptail = psgl->phead;
+		psgl->ptail_dma = psgl->phead_dma;
+	} else {
+		psgl->ptail->next = psgl->ptail_dma + sizeof(ppc_sgl_t);
+		psgl->ptail++;
+		psgl->ptail_dma += sizeof(ppc_sgl_t);
+	}
+
+	psgl->ptail->control = psgl->control;
+	psgl->ptail->src_addr = src_addr;
+	psgl->ptail->dst_addr = dst_addr;
+	psgl->ptail->control_count = (count >> p_dma_ch->shift) |
+	    psgl->sgl_control;
+	psgl->ptail->next = (uint32_t) NULL;
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Enable (start) the DMA described by the sgl handle.
+ */
+void
+ppc4xx_enable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	} else if (!psgl->phead) {
+		printk("ppc4xx_enable_dma_sgl: sg list empty\n");
+		return;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+	psgl->ptail->control_count &= ~SG_LINK;	/* make this the last dscrptr */
+	sg_command = mfdcr(DCRN_ASGC);
+
+	ppc4xx_set_sg_addr(psgl->dmanr, psgl->phead_dma);
+
+	sg_command |= SSG_ENABLE(psgl->dmanr);
+
+	mtdcr(DCRN_ASGC, sg_command);	/* start transfer */
+}
+
+/*
+ * Halt an active scatter/gather DMA operation.
+ */
+void
+ppc4xx_disable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	sg_command &= ~SSG_ENABLE(psgl->dmanr);
+	mtdcr(DCRN_ASGC, sg_command);	/* stop transfer */
+}
+
+/*
+ *  Returns number of bytes left to be transferred from the entire sgl list.
+ *  *src_addr and *dst_addr get set to the source/destination address of
+ *  the sgl descriptor where the DMA stopped.
+ *
+ *  An sgl transfer must NOT be active when this function is called.
+ */
+int
+ppc4xx_get_dma_sgl_residue(sgl_handle_t handle, phys_addr_t * src_addr,
+			   phys_addr_t * dst_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	ppc_sgl_t *pnext, *sgl_addr;
+	uint32_t count_left;
+
+	if (!handle) {
+		printk("ppc4xx_get_dma_sgl_residue: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_get_dma_sgl_residue: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	sgl_addr = (ppc_sgl_t *) __va(mfdcr(DCRN_ASG0 + (psgl->dmanr * 0x8)));
+	count_left = mfdcr(DCRN_DMACT0 + (psgl->dmanr * 0x8));
+
+	if (!sgl_addr) {
+		printk("ppc4xx_get_dma_sgl_residue: sgl addr register is null\n");
+		goto error;
+	}
+
+	pnext = psgl->phead;
+	while (pnext &&
+	       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE) &&
+		(pnext != sgl_addr))
+	    ) {
+		pnext++;
+	}
+
+	if (pnext == sgl_addr) {	/* found the sgl descriptor */
+
+		*src_addr = pnext->src_addr;
+		*dst_addr = pnext->dst_addr;
+
+		/*
+		 * Now search the remaining descriptors and add their count.
+		 * We already have the remaining count from this descriptor in
+		 * count_left.
+		 */
+		pnext++;
+
+		while ((pnext != psgl->ptail) &&
+		       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE))
+		    ) {
+			count_left += pnext->control_count & SG_COUNT_MASK;
+		}
+
+		if (pnext != psgl->ptail) {	/* should never happen */
+			printk
+			    ("ppc4xx_get_dma_sgl_residue error (1) psgl->ptail 0x%x handle 0x%x\n",
+			     (unsigned int) psgl->ptail, (unsigned int) handle);
+			goto error;
+		}
+
+		/* success */
+		p_dma_ch = &dma_channels[psgl->dmanr];
+		return (count_left << p_dma_ch->shift);	/* count in bytes */
+
+	} else {
+		/* this shouldn't happen */
+		printk
+		    ("get_dma_sgl_residue, unable to match current address 0x%x, handle 0x%x\n",
+		     (unsigned int) sgl_addr, (unsigned int) handle);
+
+	}
+
+      error:
+	*src_addr = (phys_addr_t) NULL;
+	*dst_addr = (phys_addr_t) NULL;
+	return 0;
+}
+
+/*
+ * Returns the address(es) of the buffer(s) contained in the head element of
+ * the scatter/gather list.  The element is removed from the scatter/gather
+ * list and the next element becomes the head.
+ *
+ * This function should only be called when the DMA is not active.
+ */
+int
+ppc4xx_delete_dma_sgl_element(sgl_handle_t handle, phys_addr_t * src_dma_addr,
+			      phys_addr_t * dst_dma_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_delete_sgl_element: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_delete_sgl_element: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!psgl->phead) {
+		printk("ppc4xx_delete_sgl_element: sgl list empty\n");
+		*src_dma_addr = (phys_addr_t) NULL;
+		*dst_dma_addr = (phys_addr_t) NULL;
+		return DMA_STATUS_SGL_LIST_EMPTY;
+	}
+
+	*src_dma_addr = (phys_addr_t) psgl->phead->src_addr;
+	*dst_dma_addr = (phys_addr_t) psgl->phead->dst_addr;
+
+	if (psgl->phead == psgl->ptail) {
+		/* last descriptor on the list */
+		psgl->phead = NULL;
+		psgl->ptail = NULL;
+	} else {
+		psgl->phead++;
+		psgl->phead_dma += sizeof(ppc_sgl_t);
+	}
+
+	return DMA_STATUS_GOOD;
+}
+
+
+/*
+ *   Create a scatter/gather list handle.  This is simply a structure which
+ *   describes a scatter/gather list.
+ *
+ *   A handle is returned in "handle" which the driver should save in order to
+ *   be able to access this list later.  A chunk of memory will be allocated
+ *   to be used by the API for internal management purposes, including managing
+ *   the sg list and allocating memory for the sgl descriptors.  One page should
+ *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use
+ *   a whole page for a single sg list, but most likely there will be only one
+ *   sg list per channel.
+ *
+ *   Interrupt notes:
+ *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
+ *   loads in the control register.  The control word has a "global" interrupt
+ *   enable bit for that channel. Interrupts are further qualified by a few bits
+ *   in the sgl descriptor count register.  In order to setup an sgl, we have to
+ *   know ahead of time whether or not interrupts will be enabled at the completion
+ *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
+ *   be called before calling alloc_dma_handle().  If the interrupt mode will never
+ *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt()
+ *   do not have to be called -- interrupts will be enabled or disabled based
+ *   on how the channel was configured after powerup by the hw_init_dma_channel()
+ *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
+ *   however, only the last descriptor will be setup to interrupt. Thus, an
+ *   interrupt will occur (if interrupts are enabled) only after the complete
+ *   sgl transfer is done.
+ */
+int
+ppc4xx_alloc_dma_handle(sgl_handle_t * phandle, unsigned int mode, unsigned int dmanr)
+{
+	sgl_list_info_t *psgl;
+	dma_addr_t dma_addr;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	uint32_t sg_command;
+	void *ret;
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_alloc_dma_handle: invalid channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!phandle) {
+		printk("ppc4xx_alloc_dma_handle: null handle pointer\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	/* Get a page of memory, which is zeroed out by consistent_alloc() */
+	ret = dma_alloc_coherent(NULL, DMA_PPC4xx_SIZE, &dma_addr, GFP_KERNEL);
+	if (ret != NULL) {
+		memset(ret, 0, DMA_PPC4xx_SIZE);
+		psgl = (sgl_list_info_t *) ret;
+	}
+
+	if (psgl == NULL) {
+		*phandle = (sgl_handle_t) NULL;
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	psgl->dma_addr = dma_addr;
+	psgl->dmanr = dmanr;
+
+	/*
+	 * Modify and save the control word. These words will be
+	 * written to each sgl descriptor.  The DMA engine then
+	 * loads this control word into the control register
+	 * every time it reads a new descriptor.
+	 */
+	psgl->control = p_dma_ch->control;
+	/* Clear all mode bits */
+	psgl->control &= ~(DMA_TM_MASK | DMA_TD);
+	/* Save control word and mode */
+	psgl->control |= (mode | DMA_CE_ENABLE);
+
+	/* In MM mode, we must set ETD/TCE */
+	if (mode == DMA_MODE_MM)
+		psgl->control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+
+	if (p_dma_ch->int_enable) {
+		/* Enable channel interrupt */
+		psgl->control |= DMA_CIE_ENABLE;
+	} else {
+		psgl->control &= ~DMA_CIE_ENABLE;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	sg_command |= SSG_MASK_ENABLE(dmanr);
+
+	/* Enable SGL control access */
+	mtdcr(DCRN_ASGC, sg_command);
+	psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;
+
+	if (p_dma_ch->int_enable) {
+		if (p_dma_ch->tce_enable)
+			psgl->sgl_control |= SG_TCI_ENABLE;
+		else
+			psgl->sgl_control |= SG_ETI_ENABLE;
+	}
+
+	*phandle = (sgl_handle_t) psgl;
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
+ * The list must be empty (contain no elements).
+ */
+void
+ppc4xx_free_dma_handle(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_free_dma_handle: got NULL\n");
+		return;
+	} else if (psgl->phead) {
+		printk("ppc4xx_free_dma_handle: list not empty\n");
+		return;
+	} else if (!psgl->dma_addr) {	/* should never happen */
+		printk("ppc4xx_free_dma_handle: no dma address\n");
+		return;
+	}
+
+	dma_free_coherent(NULL, DMA_PPC4xx_SIZE, (void *) psgl, 0);
+}
+
+EXPORT_SYMBOL(ppc4xx_alloc_dma_handle);
+EXPORT_SYMBOL(ppc4xx_free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_add_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_delete_dma_sgl_element);
+EXPORT_SYMBOL(ppc4xx_enable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_disable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_get_dma_sgl_residue);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/Kconfig linux-2.6.8-rc3-bk3/arch/ppc64/Kconfig
--- linux-2.6.8-rc3-bk2/arch/ppc64/Kconfig	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/Kconfig	2004-08-08 17:25:03.482179360 +0000
@@ -424,8 +424,6 @@ config IRQSTACKS
 	  for handling hard and soft interrupts.  This can help avoid
 	  overflowing the process kernel stacks.
 	  
-endmenu
-
 config SPINLINE
 	bool "Inline spinlock code at each call site"
 	depends on SMP && !PPC_SPLPAR && !PPC_ISERIES
@@ -436,6 +434,8 @@ config SPINLINE
 
 	  If in doubt, say N.
 
+endmenu
+
 source "security/Kconfig"
 
 source "crypto/Kconfig"
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/Makefile linux-2.6.8-rc3-bk3/arch/ppc64/kernel/Makefile
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/Makefile	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/Makefile	2004-08-08 17:25:03.484179056 +0000
@@ -15,14 +15,11 @@ obj-y               :=	setup.o entry.o t
 
 obj-$(CONFIG_PPC_OF) +=	of_device.o
 
-obj-$(CONFIG_PCI)	+= pci.o pci_dn.o pci_iommu.o
+pci-obj-$(CONFIG_PPC_ISERIES)	+= iSeries_pci.o iSeries_pci_reset.o \
+				     iSeries_IoMmTable.o
+pci-obj-$(CONFIG_PPC_PSERIES)	+= pci_dn.o pci_dma_direct.o
 
-ifdef CONFIG_PPC_ISERIES
-obj-$(CONFIG_PCI)	+= iSeries_pci.o iSeries_pci_reset.o \
-			     iSeries_IoMmTable.o 
-else
-obj-$(CONFIG_PCI)	+= pci_dma_direct.o
-endif
+obj-$(CONFIG_PCI)	+= pci.o pci_iommu.o $(pci-obj-y)
 
 obj-$(CONFIG_PPC_ISERIES) += iSeries_irq.o \
 			     iSeries_VpdInfo.o XmPciLpEvent.o \
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/chrp_setup.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/chrp_setup.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/chrp_setup.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/chrp_setup.c	2004-08-08 17:25:03.488178448 +0000
@@ -298,8 +298,7 @@ chrp_init(unsigned long r3, unsigned lon
 	       cur_cpu_spec->firmware_features);
 }
 
-void
-chrp_progress(char *s, unsigned short hex)
+void chrp_progress(char *s, unsigned short hex)
 {
 	struct device_node *root;
 	int width, *p;
@@ -313,60 +312,55 @@ chrp_progress(char *s, unsigned short he
 		return;
 
 	if (max_width == 0) {
-		if ( (root = find_path_device("/rtas")) &&
+		if ((root = find_path_device("/rtas")) &&
 		     (p = (unsigned int *)get_property(root,
 						       "ibm,display-line-length",
-						       NULL)) )
+						       NULL)))
 			max_width = *p;
 		else
 			max_width = 0x10;
 		display_character = rtas_token("display-character");
 		set_indicator = rtas_token("set-indicator");
 	}
-	if (display_character == RTAS_UNKNOWN_SERVICE) {
-		/* use hex display */
-		if (set_indicator == RTAS_UNKNOWN_SERVICE)
-			return;
-		rtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);
-		return;
-	}
 
-	if(display_character == RTAS_UNKNOWN_SERVICE) {
+	if (display_character == RTAS_UNKNOWN_SERVICE) {
 		/* use hex display if available */
-		if(set_indicator != RTAS_UNKNOWN_SERVICE)
+		if (set_indicator != RTAS_UNKNOWN_SERVICE)
 			rtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);
 		return;
 	}
 
 	spin_lock(&progress_lock);
 
-	/* Last write ended with newline, but we didn't print it since
+	/*
+	 * Last write ended with newline, but we didn't print it since
 	 * it would just clear the bottom line of output. Print it now
 	 * instead.
 	 *
 	 * If no newline is pending, print a CR to start output at the
 	 * beginning of the line.
 	 */
-	if(pending_newline) {
+	if (pending_newline) {
 		rtas_call(display_character, 1, 1, NULL, '\r');
 		rtas_call(display_character, 1, 1, NULL, '\n');
 		pending_newline = 0;
-	} else
+	} else {
 		rtas_call(display_character, 1, 1, NULL, '\r');
+	}
  
 	width = max_width;
 	os = s;
 	while (*os) {
-		if(*os == '\n' || *os == '\r') {
+		if (*os == '\n' || *os == '\r') {
 			/* Blank to end of line. */
-			while(width-- > 0)
+			while (width-- > 0)
 				rtas_call(display_character, 1, 1, NULL, ' ');
  
 			/* If newline is the last character, save it
 			 * until next call to avoid bumping up the
 			 * display output.
 			 */
-			if(*os == '\n' && !os[1]) {
+			if (*os == '\n' && !os[1]) {
 				pending_newline = 1;
 				spin_unlock(&progress_lock);
 				return;
@@ -374,7 +368,7 @@ chrp_progress(char *s, unsigned short he
  
 			/* RTAS wants CR-LF, not just LF */
  
-			if(*os == '\n') {
+			if (*os == '\n') {
 				rtas_call(display_character, 1, 1, NULL, '\r');
 				rtas_call(display_character, 1, 1, NULL, '\n');
 			} else {
@@ -393,14 +387,14 @@ chrp_progress(char *s, unsigned short he
 		os++;
  
 		/* if we overwrite the screen length */
-		if ( width <= 0 )
-			while ( (*os != 0) && (*os != '\n') && (*os != '\r') )
+		if (width <= 0)
+			while ((*os != 0) && (*os != '\n') && (*os != '\r'))
 				os++;
 	}
  
 	/* Blank to end of line. */
-	while ( width-- > 0 )
-		rtas_call(display_character, 1, 1, NULL, ' ' );
+	while (width-- > 0)
+		rtas_call(display_character, 1, 1, NULL, ' ');
 
 	spin_unlock(&progress_lock);
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/eeh.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/eeh.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/eeh.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/eeh.c	2004-08-08 17:25:03.490178144 +0000
@@ -618,7 +618,7 @@ void __init eeh_init(void)
 
 		info.buid_lo = BUID_LO(buid);
 		info.buid_hi = BUID_HI(buid);
-		traverse_pci_devices(phb, early_enable_eeh, NULL, &info);
+		traverse_pci_devices(phb, early_enable_eeh, &info);
 	}
 
 	if (eeh_subsystem_enabled) {
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/entry.S linux-2.6.8-rc3-bk3/arch/ppc64/kernel/entry.S
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/entry.S	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/entry.S	2004-08-08 17:25:03.493177688 +0000
@@ -194,6 +194,7 @@ syscall_exit_trace_cont:
 	mtspr	SRR0,r7
 	mtspr	SRR1,r8
 	rfid
+	b	.	/* prevent speculative execution */
 
 syscall_enosys:
 	li	r3,-ENOSYS
@@ -540,7 +541,7 @@ restore:
 	ld	r1,GPR1(r1)
 
 	rfid
-	b	.
+	b	.	/* prevent speculative execution */
 
 /* Note: this must change if we start using the TIF_NOTIFY_RESUME bit */
 do_work:
@@ -684,6 +685,7 @@ _GLOBAL(enter_rtas)
 	mtspr	SRR0,r5
 	mtspr	SRR1,r6
 	rfid
+	b	.	/* prevent speculative execution */
 
 _STATIC(rtas_return_loc)
 	/* relocation is off at this point */
@@ -704,6 +706,7 @@ _STATIC(rtas_return_loc)
 	mtspr	SRR0,r3
 	mtspr	SRR1,r4
 	rfid
+	b	.	/* prevent speculative execution */
 
 _STATIC(rtas_restore_regs)
 	/* relocation is on at this point */
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/head.S linux-2.6.8-rc3-bk3/arch/ppc64/kernel/head.S
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/head.S	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/head.S	2004-08-08 17:25:03.499176776 +0000
@@ -221,7 +221,8 @@ exception_marker:
 	mtspr	SRR0,r12;						\
 	mfspr	r12,SRR1;		/* and SRR1 */			\
 	mtspr	SRR1,r10;						\
-	rfid
+	rfid;								\
+	b	.	/* prevent speculative execution */
 
 /*
  * This is the start of the interrupt handlers for iSeries
@@ -302,12 +303,14 @@ exception_marker:
 	. = n;						\
 	.globl label##_Pseries;				\
 label##_Pseries:					\
+	HMT_MEDIUM;					\
 	mtspr	SPRG1,r13;		/* save r13 */	\
 	EXCEPTION_PROLOG_PSERIES(PACA_EXGEN, label##_common)
 
 #define STD_EXCEPTION_ISERIES(n, label, area)		\
 	.globl label##_Iseries;				\
 label##_Iseries:					\
+	HMT_MEDIUM;					\
 	mtspr	SPRG1,r13;		/* save r13 */	\
 	EXCEPTION_PROLOG_ISERIES_1(area);		\
 	EXCEPTION_PROLOG_ISERIES_2;			\
@@ -316,6 +319,7 @@ label##_Iseries:					\
 #define MASKABLE_EXCEPTION_ISERIES(n, label)				\
 	.globl label##_Iseries;						\
 label##_Iseries:							\
+	HMT_MEDIUM;							\
 	mtspr	SPRG1,r13;		/* save r13 */			\
 	EXCEPTION_PROLOG_ISERIES_1(PACA_EXGEN);				\
 	lbz	r10,PACAPROFENABLED(r13);				\
@@ -409,12 +413,14 @@ __start_interrupts:
 
 	. = 0x200
 _MachineCheckPseries:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13		/* save r13 */
 	EXCEPTION_PROLOG_PSERIES(PACA_EXMC, MachineCheck_common)
 
 	. = 0x300
 	.globl DataAccess_Pseries
 DataAccess_Pseries:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13
 BEGIN_FTR_SECTION
 	mtspr	SPRG2,r12
@@ -433,6 +439,7 @@ END_FTR_SECTION_IFCLR(CPU_FTR_SLB)
 	. = 0x380
 	.globl DataAccessSLB_Pseries
 DataAccessSLB_Pseries:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13
 	mfspr	r13,SPRG3		/* get paca address into r13 */
 	std	r9,PACA_EXSLB+EX_R9(r13)	/* save r9 - r12 */
@@ -453,12 +460,14 @@ DataAccessSLB_Pseries:
 	mtspr	SRR1,r10
 	mfspr	r3,DAR
 	rfid
+	b	.	/* prevent speculative execution */
 
 	STD_EXCEPTION_PSERIES(0x400, InstructionAccess)
 
 	. = 0x480
 	.globl InstructionAccessSLB_Pseries
 InstructionAccessSLB_Pseries:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13
 	mfspr	r13,SPRG3		/* get paca address into r13 */
 	std	r9,PACA_EXSLB+EX_R9(r13)	/* save r9 - r12 */
@@ -479,6 +488,7 @@ InstructionAccessSLB_Pseries:
 	mtspr	SRR1,r10
 	mr	r3,r11			/* SRR0 is faulting address */
 	rfid
+	b	.	/* prevent speculative execution */
 
 	STD_EXCEPTION_PSERIES(0x500, HardwareInterrupt)
 	STD_EXCEPTION_PSERIES(0x600, Alignment)
@@ -491,6 +501,7 @@ InstructionAccessSLB_Pseries:
 	. = 0xc00
 	.globl	SystemCall_Pseries
 SystemCall_Pseries:
+	HMT_MEDIUM
 	mr	r9,r13
 	mfmsr	r10
 	mfspr	r13,SPRG3
@@ -503,6 +514,7 @@ SystemCall_Pseries:
 	mfspr	r12,SRR1
 	mtspr	SRR1,r10
 	rfid
+	b	.	/* prevent speculative execution */
 
 	STD_EXCEPTION_PSERIES(0xd00, SingleStep)
 	STD_EXCEPTION_PSERIES(0xe00, Trap_0e)
@@ -727,6 +739,7 @@ HardwareInterrupt_Iseries_masked:
 	ld	r12,PACA_EXGEN+EX_R12(r13)
 	ld	r13,PACA_EXGEN+EX_R13(r13)
 	rfid
+	b	.	/* prevent speculative execution */
 #endif
 
 /*
@@ -742,10 +755,12 @@ fwnmi_data_area:
 	. = 0x8000
 	.globl SystemReset_FWNMI
 SystemReset_FWNMI:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13		/* save r13 */
 	EXCEPTION_PROLOG_PSERIES(PACA_EXGEN, SystemReset_common)
 	.globl MachineCheck_FWNMI
 MachineCheck_FWNMI:
+	HMT_MEDIUM
 	mtspr	SPRG1,r13		/* save r13 */
 	EXCEPTION_PROLOG_PSERIES(PACA_EXMC, MachineCheck_common)
 
@@ -867,6 +882,7 @@ fast_exception_return:
 	REST_4GPRS(10, r1)
 	ld	r1,GPR1(r1)
 	rfid
+	b	.	/* prevent speculative execution */
 
 unrecov_fer:
 	bl	.save_nvgprs
@@ -1146,6 +1162,7 @@ _GLOBAL(do_stab_bolted)
 	ld	r12,PACA_EXSLB+EX_R12(r13)
 	ld	r13,PACA_EXSLB+EX_R13(r13)
 	rfid
+	b	.	/* prevent speculative execution */
 
 /*
  * r13 points to the PACA, r9 contains the saved CR,
@@ -1190,6 +1207,7 @@ _GLOBAL(do_slb_miss)
 	ld	r12,PACA_EXSLB+EX_R12(r13)
 	ld	r13,PACA_EXSLB+EX_R13(r13)
 	rfid
+	b	.	/* prevent speculative execution */
 
 unrecov_slb:
 	EXCEPTION_PROLOG_COMMON(0x4100, PACA_EXSLB)
@@ -1295,6 +1313,7 @@ _STATIC(mmu_off)
 	mtspr	SRR1,r3
 	sync
 	rfid
+	b	.	/* prevent speculative execution */
 _GLOBAL(__start_initialization_pSeries)
 	mr	r31,r3			/* save parameters */
 	mr	r30,r4
@@ -1777,6 +1796,7 @@ _GLOBAL(__secondary_start)
 	mtspr	SRR0,r3
 	mtspr	SRR1,r4
 	rfid
+	b	.	/* prevent speculative execution */
 
 /* 
  * Running with relocation on at this point.  All we want to do is
@@ -1940,6 +1960,7 @@ _STATIC(start_here_pSeries)
 	mtspr	SRR0,r3
 	mtspr	SRR1,r4
 	rfid
+	b	.	/* prevent speculative execution */
 #endif /* CONFIG_PPC_PSERIES */
 	
 	/* This is where all platforms converge execution */
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/irq.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/irq.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/irq.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/irq.c	2004-08-08 17:25:03.502176320 +0000
@@ -143,47 +143,6 @@ EXPORT_SYMBOL(synchronize_irq);
 
 #endif /* CONFIG_SMP */
 
-/* XXX Make this into free_irq() - Anton */
-
-/* This could be promoted to a real free_irq() ... */
-static int
-do_free_irq(int irq, void* dev_id)
-{
-	irq_desc_t *desc = get_irq_desc(irq);
-	struct irqaction **p;
-	unsigned long flags;
-
-	spin_lock_irqsave(&desc->lock,flags);
-	p = &desc->action;
-	for (;;) {
-		struct irqaction * action = *p;
-		if (action) {
-			struct irqaction **pp = p;
-			p = &action->next;
-			if (action->dev_id != dev_id)
-				continue;
-
-			/* Found it - now remove it from the list of entries */
-			*pp = action->next;
-			if (!desc->action) {
-				desc->status |= IRQ_DISABLED;
-				mask_irq(irq);
-			}
-			spin_unlock_irqrestore(&desc->lock,flags);
-
-			/* Wait to make sure it's not being used on another CPU */
-			synchronize_irq(irq);
-			kfree(action);
-			return 0;
-		}
-		printk("Trying to free free IRQ%d\n",irq);
-		spin_unlock_irqrestore(&desc->lock,flags);
-		break;
-	}
-	return -ENOENT;
-}
-
-
 int request_irq(unsigned int irq,
 	irqreturn_t (*handler)(int, void *, struct pt_regs *),
 	unsigned long irqflags, const char * devname, void *dev_id)
@@ -194,8 +153,7 @@ int request_irq(unsigned int irq,
 	if (irq >= NR_IRQS)
 		return -EINVAL;
 	if (!handler)
-		/* We could implement really free_irq() instead of that... */
-		return do_free_irq(irq, dev_id);
+		return -EINVAL;
 
 	action = (struct irqaction *)
 		kmalloc(sizeof(struct irqaction), GFP_KERNEL);
@@ -222,7 +180,38 @@ EXPORT_SYMBOL(request_irq);
 
 void free_irq(unsigned int irq, void *dev_id)
 {
-	request_irq(irq, NULL, 0, NULL, dev_id);
+	irq_desc_t *desc = get_irq_desc(irq);
+	struct irqaction **p;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock,flags);
+	p = &desc->action;
+	for (;;) {
+		struct irqaction * action = *p;
+		if (action) {
+			struct irqaction **pp = p;
+			p = &action->next;
+			if (action->dev_id != dev_id)
+				continue;
+
+			/* Found it - now remove it from the list of entries */
+			*pp = action->next;
+			if (!desc->action) {
+				desc->status |= IRQ_DISABLED;
+				mask_irq(irq);
+			}
+			spin_unlock_irqrestore(&desc->lock,flags);
+
+			/* Wait to make sure it's not being used on another CPU */
+			synchronize_irq(irq);
+			kfree(action);
+			return;
+		}
+		printk("Trying to free free IRQ%d\n",irq);
+		spin_unlock_irqrestore(&desc->lock,flags);
+		break;
+	}
+	return;
 }
 
 EXPORT_SYMBOL(free_irq);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pSeries_pci.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pSeries_pci.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pSeries_pci.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pSeries_pci.c	2004-08-08 17:25:03.506175712 +0000
@@ -600,8 +600,9 @@ void __devinit pcibios_fixup_bus(struct 
 			BUG();	/* No I/O resource for this PHB? */
 
 		if (request_resource(&ioport_resource, res))
-			printk(KERN_ERR "Failed to request IO"
-					"on hose %d\n", 0 /* FIXME */);
+			printk(KERN_ERR "Failed to request IO on "
+					"PCI domain %d\n", pci_domain_nr(bus));
+
 
 		for (i = 0; i < 3; ++i) {
 			res = &hose->mem_resources[i];
@@ -609,8 +610,9 @@ void __devinit pcibios_fixup_bus(struct 
 				BUG();	/* No memory resource for this PHB? */
 			bus->resource[i+1] = res;
 			if (res->flags && request_resource(&iomem_resource, res))
-				printk(KERN_ERR "Failed to request MEM"
-						"on hose %d\n", 0 /* FIXME */);
+				printk(KERN_ERR "Failed to request MEM on "
+						"PCI domain %d\n",
+						pci_domain_nr(bus));
 		}
 	} else if (pci_probe_only &&
 		   (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pci.h linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pci.h
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pci.h	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pci.h	2004-08-08 17:25:03.507175560 +0000
@@ -34,8 +34,8 @@ extern struct pci_dev *ppc64_isabridge_d
  *******************************************************************/
 struct device_node;
 typedef void *(*traverse_func)(struct device_node *me, void *data);
-void *traverse_pci_devices(struct device_node *start, traverse_func pre, traverse_func post, void *data);
-void *traverse_all_pci_devices(traverse_func pre);
+void *traverse_pci_devices(struct device_node *start, traverse_func pre,
+		void *data);
 
 void pci_devs_phb_init(void);
 void pci_fix_bus_sysdata(void);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pci_dn.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pci_dn.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/pci_dn.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/pci_dn.c	2004-08-08 17:25:03.510175104 +0000
@@ -19,8 +19,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
-
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
@@ -40,20 +38,20 @@
 
 #include "pci.h"
 
-/* Traverse_func that inits the PCI fields of the device node.
+/*
+ * Traverse_func that inits the PCI fields of the device node.
  * NOTE: this *must* be done before read/write config to the device.
  */
-static void * __init
-update_dn_pci_info(struct device_node *dn, void *data)
+static void * __init update_dn_pci_info(struct device_node *dn, void *data)
 {
-#ifdef CONFIG_PPC_PSERIES
-	struct pci_controller *phb = (struct pci_controller *)data;
+	struct pci_controller *phb = data;
 	u32 *regs;
 	char *device_type = get_property(dn, "device_type", NULL);
 	char *model;
 
 	dn->phb = phb;
-	if (device_type && strcmp(device_type, "pci") == 0 && get_property(dn, "class-code", NULL) == 0) {
+	if (device_type && (strcmp(device_type, "pci") == 0) &&
+			(get_property(dn, "class-code", NULL) == 0)) {
 		/* special case for PHB's.  Sigh. */
 		regs = (u32 *)get_property(dn, "bus-range", NULL);
 		dn->busno = regs[0];
@@ -72,57 +70,47 @@ update_dn_pci_info(struct device_node *d
 			dn->devfn = (regs[0] >> 8) & 0xff;
 		}
 	}
-#endif
 	return NULL;
 }
 
-/******************************************************************
+/*
  * Traverse a device tree stopping each PCI device in the tree.
  * This is done depth first.  As each node is processed, a "pre"
- * function is called, the children are processed recursively, and
- * then a "post" function is called.
+ * function is called and the children are processed recursively.
  *
- * The "pre" and "post" funcs return a value.  If non-zero
- * is returned from the "pre" func, the traversal stops and this
- * value is returned.  The return value from "post" is not used.
- * This return value is useful when using traverse as
- * a method of finding a device.
+ * The "pre" func returns a value.  If non-zero is returned from
+ * the "pre" func, the traversal stops and this value is returned.
+ * This return value is useful when using traverse as a method of
+ * finding a device.
  *
- * NOTE: we do not run the funcs for devices that do not appear to
+ * NOTE: we do not run the func for devices that do not appear to
  * be PCI except for the start node which we assume (this is good
  * because the start node is often a phb which may be missing PCI
  * properties).
  * We use the class-code as an indicator. If we run into
  * one of these nodes we also assume its siblings are non-pci for
  * performance.
- *
- ******************************************************************/
-void *traverse_pci_devices(struct device_node *start, traverse_func pre, traverse_func post, void *data)
+ */
+void *traverse_pci_devices(struct device_node *start, traverse_func pre,
+		void *data)
 {
 	struct device_node *dn, *nextdn;
 	void *ret;
 
-	if (pre && (ret = pre(start, data)) != NULL)
+	if (pre && ((ret = pre(start, data)) != NULL))
 		return ret;
 	for (dn = start->child; dn; dn = nextdn) {
 		nextdn = NULL;
-#ifdef CONFIG_PPC_PSERIES
 		if (get_property(dn, "class-code", NULL)) {
-			if (pre && (ret = pre(dn, data)) != NULL)
+			if (pre && ((ret = pre(dn, data)) != NULL))
 				return ret;
-			if (dn->child) {
+			if (dn->child)
 				/* Depth first...do children */
 				nextdn = dn->child;
-			} else if (dn->sibling) {
+			else if (dn->sibling)
 				/* ok, try next sibling instead. */
 				nextdn = dn->sibling;
-			} else {
-				/* no more children or siblings...call "post" */
-				if (post)
-					post(dn, data);
-			}
 		}
-#endif
 		if (!nextdn) {
 			/* Walk up to next valid sibling. */
 			do {
@@ -136,31 +124,35 @@ void *traverse_pci_devices(struct device
 	return NULL;
 }
 
-/* Same as traverse_pci_devices except this does it for all phbs.
+/*
+ * Same as traverse_pci_devices except this does it for all phbs.
  */
-void *traverse_all_pci_devices(traverse_func pre)
+static void *traverse_all_pci_devices(traverse_func pre)
 {
-	struct pci_controller* phb;
+	struct pci_controller *phb;
 	void *ret;
-	for (phb=hose_head;phb;phb=phb->next)
-		if ((ret = traverse_pci_devices((struct device_node *)phb->arch_data, pre, NULL, phb)) != NULL)
+
+	for (phb = hose_head; phb; phb = phb->next)
+		if ((ret = traverse_pci_devices(phb->arch_data, pre, phb))
+				!= NULL)
 			return ret;
 	return NULL;
 }
 
 
-/* Traversal func that looks for a <busno,devfcn> value.
+/*
+ * Traversal func that looks for a <busno,devfcn> value.
  * If found, the device_node is returned (thus terminating the traversal).
  */
-static void *
-is_devfn_node(struct device_node *dn, void *data)
+static void *is_devfn_node(struct device_node *dn, void *data)
 {
 	int busno = ((unsigned long)data >> 8) & 0xff;
 	int devfn = ((unsigned long)data) & 0xff;
-	return (devfn == dn->devfn && busno == dn->busno) ? dn : NULL;
+	return ((devfn == dn->devfn) && (busno == dn->busno)) ? dn : NULL;
 }
 
-/* This is the "slow" path for looking up a device_node from a
+/*
+ * This is the "slow" path for looking up a device_node from a
  * pci_dev.  It will hunt for the device under its parent's
  * phb and then update sysdata for a future fastpath.
  *
@@ -174,14 +166,14 @@ is_devfn_node(struct device_node *dn, vo
  */
 struct device_node *fetch_dev_dn(struct pci_dev *dev)
 {
-	struct device_node *orig_dn = (struct device_node *)dev->sysdata;
+	struct device_node *orig_dn = dev->sysdata;
 	struct pci_controller *phb = orig_dn->phb; /* assume same phb as orig_dn */
 	struct device_node *phb_dn;
 	struct device_node *dn;
 	unsigned long searchval = (dev->bus->number << 8) | dev->devfn;
 
-	phb_dn = (struct device_node *)(phb->arch_data);
-	dn = (struct device_node *)traverse_pci_devices(phb_dn, is_devfn_node, NULL, (void *)searchval);
+	phb_dn = phb->arch_data;
+	dn = traverse_pci_devices(phb_dn, is_devfn_node, (void *)searchval);
 	if (dn) {
 		dev->sysdata = dn;
 		/* ToDo: call some device init hook here */
@@ -191,25 +183,23 @@ struct device_node *fetch_dev_dn(struct 
 EXPORT_SYMBOL(fetch_dev_dn);
 
 
-/******************************************************************
+/*
  * Actually initialize the phbs.
  * The buswalk on this phb has not happened yet.
- ******************************************************************/
-void __init
-pci_devs_phb_init(void)
+ */
+void __init pci_devs_phb_init(void)
 {
 	/* This must be done first so the device nodes have valid pci info! */
 	traverse_all_pci_devices(update_dn_pci_info);
 }
 
 
-static void __init
-pci_fixup_bus_sysdata_list(struct list_head *bus_list)
+static void __init pci_fixup_bus_sysdata_list(struct list_head *bus_list)
 {
 	struct list_head *ln;
 	struct pci_bus *bus;
 
-	for (ln=bus_list->next; ln != bus_list; ln=ln->next) {
+	for (ln = bus_list->next; ln != bus_list; ln = ln->next) {
 		bus = pci_bus_b(ln);
 		if (bus->self)
 			bus->sysdata = bus->self->sysdata;
@@ -217,7 +207,7 @@ pci_fixup_bus_sysdata_list(struct list_h
 	}
 }
 
-/******************************************************************
+/*
  * Fixup the bus->sysdata ptrs to point to the bus' device_node.
  * This is done late in pcibios_init().  We do this mostly for
  * sanity, but pci_dma.c uses these at DMA time so they must be
@@ -225,9 +215,8 @@ pci_fixup_bus_sysdata_list(struct list_h
  * To do this we recurse down the bus hierarchy.  Note that PHB's
  * have bus->self == NULL, but fortunately bus->sysdata is already
  * correct in this case.
- ******************************************************************/
-void __init
-pci_fix_bus_sysdata(void)
+ */
+void __init pci_fix_bus_sysdata(void)
 {
 	pci_fixup_bus_sysdata_list(&pci_root_buses);
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/ptrace32.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/ptrace32.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/ptrace32.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/ptrace32.c	2004-08-08 17:25:03.512174800 +0000
@@ -404,7 +404,9 @@ int sys32_ptrace(long request, long pid,
 		break;
 	}
 
-
+       case PTRACE_GETEVENTMSG:
+                ret = put_user(child->ptrace_message, (unsigned int __user *) data);
+                break;
 
 	default:
 		ret = ptrace_request(child, request, addr, data);
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/sysfs.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/sysfs.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/sysfs.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/sysfs.c	2004-08-08 17:25:03.529172216 +0000
@@ -208,8 +208,8 @@ static ssize_t show_##NAME(struct sys_de
 	unsigned long val = run_on_cpu(cpu->sysdev.id, read_##NAME, 0); \
 	return sprintf(buf, "%lx\n", val); \
 } \
-static ssize_t store_##NAME(struct sys_device *dev, const char *buf, \
-			    size_t count) \
+static ssize_t __attribute_used__ \
+	store_##NAME(struct sys_device *dev, const char *buf, size_t count) \
 { \
 	struct cpu *cpu = container_of(dev, struct cpu, sysdev); \
 	unsigned long val; \
diff -p -purN linux-2.6.8-rc3-bk2/arch/ppc64/kernel/xics.c linux-2.6.8-rc3-bk3/arch/ppc64/kernel/xics.c
--- linux-2.6.8-rc3-bk2/arch/ppc64/kernel/xics.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/ppc64/kernel/xics.c	2004-08-08 17:25:03.532171760 +0000
@@ -27,7 +27,6 @@
 #include <asm/naca.h>
 #include <asm/rtas.h>
 #include <asm/xics.h>
-#include <asm/ppcdebug.h>
 #include <asm/hvcall.h>
 #include <asm/machdep.h>
 
@@ -239,13 +238,13 @@ static unsigned int real_irq_to_virt(uns
 #ifdef CONFIG_SMP
 static int get_irq_server(unsigned int irq)
 {
-	cpumask_t cpumask = irq_affinity[irq];
-	cpumask_t tmp = CPU_MASK_NONE;
 	unsigned int server;
 
 #ifdef CONFIG_IRQ_ALL_CPUS
 	/* For the moment only implement delivery to all cpus or one cpu */
 	if (smp_threads_ready) {
+		cpumask_t cpumask = irq_affinity[irq];
+		cpumask_t tmp = CPU_MASK_NONE;
 		if (cpus_equal(cpumask, CPU_MASK_ALL)) {
 			server = default_distrib_server;
 		} else {
@@ -286,7 +285,7 @@ static void xics_enable_irq(unsigned int
 	call_status = rtas_call(ibm_set_xive, 3, 1, NULL, irq, server,
 				DEFAULT_PRIORITY);
 	if (call_status != 0) {
-		printk(KERN_ERR "xics_enable_irq: irq=%x: ibm_set_xive "
+		printk(KERN_ERR "xics_enable_irq: irq=%d: ibm_set_xive "
 		       "returned %x\n", irq, call_status);
 		return;
 	}
@@ -294,7 +293,7 @@ static void xics_enable_irq(unsigned int
 	/* Now unmask the interrupt (often a no-op) */
 	call_status = rtas_call(ibm_int_on, 1, 1, NULL, irq);
 	if (call_status != 0) {
-		printk(KERN_ERR "xics_enable_irq: irq=%x: ibm_int_on "
+		printk(KERN_ERR "xics_enable_irq: irq=%d: ibm_int_on "
 		       "returned %x\n", irq, call_status);
 		return;
 	}
@@ -310,7 +309,7 @@ static void xics_disable_real_irq(unsign
 
 	call_status = rtas_call(ibm_int_off, 1, 1, NULL, irq);
 	if (call_status != 0) {
-		printk(KERN_ERR "xics_disable_real_irq: irq=%x: "
+		printk(KERN_ERR "xics_disable_real_irq: irq=%d: "
 		       "ibm_int_off returned %x\n", irq, call_status);
 		return;
 	}
@@ -319,7 +318,7 @@ static void xics_disable_real_irq(unsign
 	/* Have to set XIVE to 0xff to be able to remove a slot */
 	call_status = rtas_call(ibm_set_xive, 3, 1, NULL, irq, server, 0xff);
 	if (call_status != 0) {
-		printk(KERN_ERR "xics_disable_irq: irq=%x: ibm_set_xive(0xff)"
+		printk(KERN_ERR "xics_disable_irq: irq=%d: ibm_set_xive(0xff)"
 		       " returned %x\n", irq, call_status);
 		return;
 	}
@@ -356,8 +355,6 @@ static void xics_mask_and_ack_irq(unsign
 	}
 }
 
-extern unsigned int real_irq_to_virt_slowpath(unsigned int real_irq);
-
 int xics_get_irq(struct pt_regs *regs)
 {
 	unsigned int cpu = smp_processor_id();
@@ -384,7 +381,7 @@ int xics_get_irq(struct pt_regs *regs)
 		if (irq == NO_IRQ)
 			irq = real_irq_to_virt_slowpath(vec);
 		if (irq == NO_IRQ) {
-			printk(KERN_ERR "Interrupt 0x%x (real) is invalid,"
+			printk(KERN_ERR "Interrupt %d (real) is invalid,"
 			       " disabling it.\n", vec);
 			xics_disable_real_irq(vec);
 		} else
@@ -395,8 +392,6 @@ int xics_get_irq(struct pt_regs *regs)
 
 #ifdef CONFIG_SMP
 
-extern struct xics_ipi_struct xics_ipi_message[NR_CPUS] __cacheline_aligned;
-
 irqreturn_t xics_ipi_action(int irq, void *dev_id, struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
@@ -469,11 +464,9 @@ void xics_init_IRQ(void)
 	ibm_int_off = rtas_token("ibm,int-off");
 
 	np = of_find_node_by_type(NULL, "PowerPC-External-Interrupt-Presentation");
-	if (!np) {
-		printk(KERN_WARNING "Can't find Interrupt Presentation\n");
-		udbg_printf("Can't find Interrupt Presentation\n");
-		while (1);
-	}
+	if (!np)
+		panic("xics_init_IRQ: can't find interrupt presentation");
+
 nextnode:
 	ireg = (uint *)get_property(np, "ibm,interrupt-server-ranges", NULL);
 	if (ireg) {
@@ -484,11 +477,8 @@ nextnode:
 	}
 
 	ireg = (uint *)get_property(np, "reg", &ilen);
-	if (!ireg) {
-		printk(KERN_WARNING "Can't find Interrupt Reg Property\n");
-		udbg_printf("Can't find Interrupt Reg Property\n");
-		while (1);
-	}
+	if (!ireg)
+		panic("xics_init_IRQ: can't find interrupt reg property");
 	
 	while (ilen) {
 		inodes[indx].addr = (unsigned long long)*ireg++ << 32;
@@ -528,16 +518,14 @@ nextnode:
 
 	np = of_find_node_by_type(NULL, "interrupt-controller");
 	if (!np) {
-		printk(KERN_WARNING "xics:  no ISA Interrupt Controller\n");
+		printk(KERN_WARNING "xics: no ISA interrupt controller\n");
 		xics_irq_8259_cascade_real = -1;
 		xics_irq_8259_cascade = -1;
 	} else {
 		ireg = (uint *) get_property(np, "interrupts", NULL);
-		if (!ireg) {
-			printk(KERN_WARNING "Can't find ISA Interrupts Property\n");
-			udbg_printf("Can't find ISA Interrupts Property\n");
-			while (1);
-		}
+		if (!ireg)
+			panic("xics_init_IRQ: can't find ISA interrupts property");
+
 		xics_irq_8259_cascade_real = *ireg;
 		xics_irq_8259_cascade
 			= virt_irq_create_mapping(xics_irq_8259_cascade_real);
@@ -558,13 +546,8 @@ nextnode:
 		xics_per_cpu[0] = __ioremap((ulong)intr_base, intr_size,
 					    _PAGE_NO_CACHE);
 #endif /* CONFIG_SMP */
-#ifdef CONFIG_PPC_PSERIES
-	/* actually iSeries does not use any of xics...but it has link dependencies
-	 * for now, except this new one...
-	 */
 	} else if (systemcfg->platform == PLATFORM_PSERIES_LPAR) {
 		ops = &pSeriesLP_ops;
-#endif
 	}
 
 	xics_8259_pic.enable = i8259_pic.enable;
@@ -590,7 +573,8 @@ static int __init xics_setup_i8259(void)
 	    xics_irq_8259_cascade != -1) {
 		if (request_irq(irq_offset_up(xics_irq_8259_cascade),
 				no_action, 0, "8259 cascade", NULL))
-			printk(KERN_ERR "xics_init_IRQ: couldn't get 8259 cascade\n");
+			printk(KERN_ERR "xics_setup_i8259: couldn't get 8259 "
+					"cascade\n");
 		i8259_init();
 	}
 	return 0;
@@ -643,7 +627,7 @@ static void xics_set_affinity(unsigned i
 				irq, newmask, xics_status[1]);
 
 	if (status) {
-		printk(KERN_ERR "xics_set_affinity irq=%d ibm,set-xive "
+		printk(KERN_ERR "xics_set_affinity: irq=%d ibm,set-xive "
 		       "returns %d\n", irq, status);
 		return;
 	}
@@ -723,7 +707,7 @@ void xics_migrate_irqs_away(void)
 		status = rtas_call(ibm_set_xive, 3, 1, NULL, irq,
 				xics_status[0], xics_status[1]);
 		if (status)
-			printk(KERN_ERR "migrate_irqs_away irq=%d "
+			printk(KERN_ERR "migrate_irqs_away: irq=%d "
 					"ibm,set-xive returns %d\n",
 					virq, status);
 
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/Kconfig linux-2.6.8-rc3-bk3/arch/s390/Kconfig
--- linux-2.6.8-rc3-bk2/arch/s390/Kconfig	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/Kconfig	2004-08-08 17:25:03.534171456 +0000
@@ -181,6 +181,15 @@ config QDIO_PERF_STATS
 
 	  If unsure, say N.
 
+config QDIO_DEBUG
+	bool "Extended debugging information"
+	depends on QDIO
+	help
+	  Say Y here to get extended debugging output in /proc/s390dbf/qdio...
+	  Warning: this option reduces the performance of the QDIO module.
+
+	  If unsure, say N.
+
 comment "Misc"
 
 config PREEMPT
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/appldata/appldata_base.c linux-2.6.8-rc3-bk3/arch/s390/appldata/appldata_base.c
--- linux-2.6.8-rc3-bk2/arch/s390/appldata/appldata_base.c	2004-08-08 17:21:21.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/appldata/appldata_base.c	2004-08-08 17:25:03.538170848 +0000
@@ -17,6 +17,7 @@
 #include <linux/errno.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <asm/smp.h>
 #include <linux/interrupt.h>
 #include <linux/proc_fs.h>
 #include <linux/page-flags.h>
@@ -87,11 +88,11 @@ struct appldata_parameter_list {
  */
 static const char appldata_proc_name[APPLDATA_PROC_NAME_LENGTH] = "appldata";
 static int appldata_timer_handler(ctl_table *ctl, int write, struct file *filp,
-				  void __user *buffer, size_t *lenp);
+				  void __user *buffer, size_t *lenp, loff_t *ppos);
 static int appldata_interval_handler(ctl_table *ctl, int write,
 					 struct file *filp,
 					 void __user *buffer,
-					 size_t *lenp);
+					 size_t *lenp, loff_t *ppos);
 
 static struct ctl_table_header *appldata_sysctl_header;
 static struct ctl_table appldata_table[] = {
@@ -314,12 +315,12 @@ __appldata_vtimer_setup(int cmd)
  */
 static int
 appldata_timer_handler(ctl_table *ctl, int write, struct file *filp,
-			   void __user *buffer, size_t *lenp)
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int len;
 	char buf[2];
 
-	if (!*lenp || filp->f_pos) {
+	if (!*lenp || *ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -342,7 +343,7 @@ appldata_timer_handler(ctl_table *ctl, i
 	spin_unlock(&appldata_timer_lock);
 out:
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	return 0;
 }
 
@@ -354,12 +355,12 @@ out:
  */
 static int
 appldata_interval_handler(ctl_table *ctl, int write, struct file *filp,
-			   void __user *buffer, size_t *lenp)
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int len, interval;
 	char buf[16];
 
-	if (!*lenp || filp->f_pos) {
+	if (!*lenp || *ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -390,7 +391,7 @@ appldata_interval_handler(ctl_table *ctl
 		 interval);
 out:
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	return 0;
 }
 
@@ -402,7 +403,7 @@ out:
  */
 static int
 appldata_generic_handler(ctl_table *ctl, int write, struct file *filp,
-			   void __user *buffer, size_t *lenp)
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	struct appldata_ops *ops = NULL, *tmp_ops;
 	int rc, len, found;
@@ -428,7 +429,7 @@ appldata_generic_handler(ctl_table *ctl,
 	}
 	spin_unlock_bh(&appldata_ops_lock);
 
-	if (!*lenp || filp->f_pos) {
+	if (!*lenp || *ppos) {
 		*lenp = 0;
 		module_put(ops->owner);
 		return 0;
@@ -487,7 +488,7 @@ appldata_generic_handler(ctl_table *ctl,
 	spin_unlock_bh(&appldata_ops_lock);
 out:
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	module_put(ops->owner);
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/defconfig linux-2.6.8-rc3-bk3/arch/s390/defconfig
--- linux-2.6.8-rc3-bk2/arch/s390/defconfig	2004-08-08 17:21:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/defconfig	2004-08-08 17:25:03.540170544 +0000
@@ -11,7 +11,6 @@ CONFIG_UID16=y
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
-CONFIG_STANDALONE=y
 
 #
 # General setup
@@ -71,6 +70,7 @@ CONFIG_MATHEMU=y
 CONFIG_MACHCHK_WARNING=y
 CONFIG_QDIO=y
 # CONFIG_QDIO_PERF_STATS is not set
+# CONFIG_QDIO_DEBUG is not set
 
 #
 # Misc
@@ -93,6 +93,7 @@ CONFIG_NO_IDLE_HZ_INIT=y
 #
 # Generic Driver Options
 #
+CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
@@ -511,7 +512,7 @@ CONFIG_CRYPTO=y
 # CONFIG_CRYPTO_BLOWFISH is not set
 # CONFIG_CRYPTO_TWOFISH is not set
 # CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_AES_GENERIC is not set
 # CONFIG_CRYPTO_CAST5 is not set
 # CONFIG_CRYPTO_CAST6 is not set
 # CONFIG_CRYPTO_TEA is not set
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/kernel/compat_linux.h linux-2.6.8-rc3-bk3/arch/s390/kernel/compat_linux.h
--- linux-2.6.8-rc3-bk2/arch/s390/kernel/compat_linux.h	2004-06-16 05:19:42.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/kernel/compat_linux.h	2004-08-08 17:25:03.540170544 +0000
@@ -214,4 +214,7 @@ struct sigevent32 {
 	} _sigev_un;
 };
 
+extern int copy_siginfo_to_user32(siginfo_t32 __user *to, siginfo_t *from);
+extern int copy_siginfo_from_user32(siginfo_t *to, siginfo_t32 __user *from);
+
 #endif /* _ASM_S390X_S390_H */
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/kernel/compat_signal.c linux-2.6.8-rc3-bk3/arch/s390/kernel/compat_signal.c
--- linux-2.6.8-rc3-bk2/arch/s390/kernel/compat_signal.c	2004-08-08 17:21:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/kernel/compat_signal.c	2004-08-08 17:25:03.542170240 +0000
@@ -106,6 +106,53 @@ int copy_siginfo_to_user32(siginfo_t32 _
 	return err;
 }
 
+int copy_siginfo_from_user32(siginfo_t *to, siginfo_t32 __user *from)
+{
+	int err;
+	u32 tmp;
+
+	if (!access_ok (VERIFY_READ, from, sizeof(siginfo_t32)))
+		return -EFAULT;
+
+	err = __get_user(to->si_signo, &from->si_signo);
+	err |= __get_user(to->si_errno, &from->si_errno);
+	err |= __get_user(to->si_code, &from->si_code);
+
+	if (from->si_code < 0)
+		err |= __copy_from_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);
+	else {
+		switch (from->si_code >> 16) {
+		case __SI_RT >> 16: /* This is not generated by the kernel as of now.  */
+		case __SI_MESGQ >> 16:
+			err |= __get_user(to->si_int, &from->si_int);
+			/* fallthrough */
+		case __SI_KILL >> 16:
+			err |= __get_user(to->si_pid, &from->si_pid);
+			err |= __get_user(to->si_uid, &from->si_uid);
+			break;
+		case __SI_CHLD >> 16:
+			err |= __get_user(to->si_pid, &from->si_pid);
+			err |= __get_user(to->si_uid, &from->si_uid);
+			err |= __get_user(to->si_utime, &from->si_utime);
+			err |= __get_user(to->si_stime, &from->si_stime);
+			err |= __get_user(to->si_status, &from->si_status);
+			break;
+		case __SI_FAULT >> 16:
+			err |= __get_user(tmp, &from->si_addr);
+			to->si_addr = (void *)(u64) (tmp & PSW32_ADDR_INSN);
+			break;
+		case __SI_POLL >> 16:
+		case __SI_TIMER >> 16:
+			err |= __get_user(to->si_band, &from->si_band);
+			err |= __get_user(to->si_fd, &from->si_fd);
+			break;
+		default:
+			break;
+		}
+	}
+	return err;
+}
+
 /*
  * Atomically swap in the new signal mask, and wait for a signal.
  */
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/kernel/ptrace.c linux-2.6.8-rc3-bk3/arch/s390/kernel/ptrace.c
--- linux-2.6.8-rc3-bk2/arch/s390/kernel/ptrace.c	2004-06-16 05:19:53.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/kernel/ptrace.c	2004-08-08 17:25:03.544169936 +0000
@@ -553,6 +553,19 @@ do_ptrace_emu31(struct task_struct *chil
 			copied += sizeof(unsigned int);
 		}
 		return 0;
+	case PTRACE_GETEVENTMSG:
+		return put_user((__u32) child->ptrace_message,
+				(unsigned int __user *) data);
+	case PTRACE_GETSIGINFO:
+		if (child->last_siginfo == NULL)
+			return -EINVAL;
+		return copy_siginfo_to_user32((siginfo_t32 __user *) data,
+					      child->last_siginfo);
+	case PTRACE_SETSIGINFO:
+		if (child->last_siginfo == NULL)
+			return -EINVAL;
+		return copy_siginfo_from_user32(child->last_siginfo,
+						(siginfo_t32 __user *) data);
 	}
 	return ptrace_request(child, request, addr, data);
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/s390/mm/cmm.c linux-2.6.8-rc3-bk3/arch/s390/mm/cmm.c
--- linux-2.6.8-rc3-bk2/arch/s390/mm/cmm.c	2004-08-08 17:21:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/s390/mm/cmm.c	2004-08-08 17:25:03.546169632 +0000
@@ -19,6 +19,7 @@
 
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
+#include <asm/smp.h>
 
 #include "../../../drivers/s390/net/smsgiucv.h"
 
@@ -255,13 +256,13 @@ static struct ctl_table cmm_table[];
 
 static int
 cmm_pages_handler(ctl_table *ctl, int write, struct file *filp,
-		  void *buffer, size_t *lenp)
+		  void *buffer, size_t *lenp, loff_t *ppos)
 {
 	char buf[16], *p;
 	long pages;
 	int len;
 
-	if (!*lenp || (filp->f_pos && !write)) {
+	if (!*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -290,19 +291,19 @@ cmm_pages_handler(ctl_table *ctl, int wr
 			return -EFAULT;
 	}
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	return 0;
 }
 
 static int
 cmm_timeout_handler(ctl_table *ctl, int write, struct file *filp,
-		    void *buffer, size_t *lenp)
+		    void *buffer, size_t *lenp, loff_t *ppos)
 {
 	char buf[64], *p;
 	long pages, seconds;
 	int len;
 
-	if (!*lenp || (filp->f_pos && !write)) {
+	if (!*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -327,7 +328,7 @@ cmm_timeout_handler(ctl_table *ctl, int 
 			return -EFAULT;
 	}
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	return 0;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/Kconfig linux-2.6.8-rc3-bk3/arch/sparc/Kconfig
--- linux-2.6.8-rc3-bk2/arch/sparc/Kconfig	2004-06-16 05:18:37.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/Kconfig	2004-08-08 17:25:03.549169176 +0000
@@ -83,6 +83,7 @@ config HW_CONSOLE
 
 config SMP
 	bool "Symmetric multi-processing support (does not work on sun4/sun4c)"
+	depends on BROKEN
 	---help---
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -221,6 +222,7 @@ config SUN_PM
 
 config SUN4
 	bool "Support for SUN4 machines (disables SUN4[CDM] support)"
+	depends on !SMP
 	help
 	  Say Y here if, and only if, your machine is a sun4. Note that
 	  a kernel compiled with this option will run only on sun4.
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/kernel/smp.c linux-2.6.8-rc3-bk3/arch/sparc/kernel/smp.c
--- linux-2.6.8-rc3-bk2/arch/sparc/kernel/smp.c	2004-08-08 17:21:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/kernel/smp.c	2004-08-08 17:25:03.551168872 +0000
@@ -45,6 +45,7 @@ int smp_activated = 0;
 volatile int __cpu_number_map[NR_CPUS];
 volatile int __cpu_logical_map[NR_CPUS];
 cycles_t cacheflush_time = 0; /* XXX */
+unsigned long cache_decay_ticks = 100;
 
 cpumask_t cpu_online_map = CPU_MASK_NONE;
 cpumask_t phys_cpu_present_map = CPU_MASK_NONE;
@@ -203,6 +204,11 @@ void smp_flush_tlb_page(struct vm_area_s
 	}
 }
 
+void smp_reschedule_irq(void)
+{
+	set_need_resched();
+}
+
 void smp_flush_page_to_ram(unsigned long page)
 {
 	/* Current theory is that those who call this are the one's
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/kernel/sun4d_smp.c linux-2.6.8-rc3-bk3/arch/sparc/kernel/sun4d_smp.c
--- linux-2.6.8-rc3-bk2/arch/sparc/kernel/sun4d_smp.c	2004-06-16 05:18:58.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/kernel/sun4d_smp.c	2004-08-08 17:25:03.553168568 +0000
@@ -43,7 +43,6 @@ extern ctxd_t *srmmu_ctx_table_phys;
 extern void calibrate_delay(void);
 
 extern volatile int smp_processors_ready;
-extern unsigned long cpu_present_map;
 extern int smp_num_cpus;
 static int smp_highest_cpu;
 extern int smp_threads_ready;
@@ -100,8 +99,6 @@ void __init smp4d_callin(void)
 	 * the SMP initialization the master will be just allowed
 	 * to call the scheduler code.
 	 */
-	init_idle();
-
 	/* Get our local ticker going. */
 	smp_setup_percpu_timer();
 
@@ -152,7 +149,6 @@ void __init smp4d_callin(void)
 extern int cpu_idle(void *unused);
 extern void init_IRQ(void);
 extern void cpu_panic(void);
-extern int start_secondary(void *unused);
 
 /*
  *	Cycle through the processors asking the PROM to start each one.
@@ -174,12 +170,12 @@ void __init smp4d_boot_cpus(void)
 		current_set[0] = NULL;
 
 	local_irq_enable();
-	cpu_present_map = 0;
+	cpus_clear(cpu_present_map);
 
 	/* XXX This whole thing has to go.  See sparc64. */
 	for (i = 0; !cpu_find_by_instance(i, NULL, &mid); i++)
-		cpu_present_map |= (1<<mid);
-	SMP_PRINTK(("cpu_present_map %08lx\n", cpu_present_map));
+		cpu_set(mid, cpu_present_map);
+	SMP_PRINTK(("cpu_present_map %08lx\n", cpus_addr(cpu_present_map)[0]));
 	for(i=0; i < NR_CPUS; i++)
 		__cpu_number_map[i] = -1;
 	for(i=0; i < NR_CPUS; i++)
@@ -197,7 +193,7 @@ void __init smp4d_boot_cpus(void)
 		if(i == boot_cpu_id)
 			continue;
 
-		if(cpu_present_map & (1 << i)) {
+		if (cpu_isset(i, cpu_present_map)) {
 			extern unsigned long sun4d_cpu_startup;
 			unsigned long *entry = &sun4d_cpu_startup;
 			struct task_struct *p;
@@ -254,19 +250,19 @@ void __init smp4d_boot_cpus(void)
 			}
 		}
 		if(!(cpu_callin_map[i])) {
-			cpu_present_map &= ~(1 << i);
+			cpu_clear(i, cpu_present_map);
 			__cpu_number_map[i] = -1;
 		}
 	}
 	local_flush_cache_all();
 	if(cpucount == 0) {
 		printk("Error: only one Processor found.\n");
-		cpu_present_map = (1 << hard_smp4d_processor_id());
+		cpu_present_map = cpumask_of_cpu(hard_smp4d_processor_id());
 	} else {
 		unsigned long bogosum = 0;
 		
 		for(i = 0; i < NR_CPUS; i++) {
-			if(cpu_present_map & (1 << i)) {
+			if (cpu_isset(i, cpu_present_map)) {
 				bogosum += cpu_data(i).udelay_val;
 				smp_highest_cpu = i;
 			}
@@ -346,12 +342,13 @@ void smp4d_cross_call(smpfunc_t func, un
 
 		/* Init receive/complete mapping, plus fire the IPI's off. */
 		{
-			register unsigned long mask;
+			cpumask_t mask;
 			register int i;
 
-			mask = (cpu_present_map & ~(1 << hard_smp4d_processor_id()));
+			mask = cpumask_of_cpu(hard_smp4d_processor_id());
+			cpus_andnot(mask, cpu_present_map, mask);
 			for(i = 0; i <= high; i++) {
-				if(mask & (1 << i)) {
+				if (cpu_isset(i, mask)) {
 					ccall_info.processors_in[i] = 0;
 					ccall_info.processors_out[i] = 0;
 					sun4d_send_ipi(i, IRQ_CROSS_CALL);
@@ -498,11 +495,11 @@ void __init sun4d_init_smp(void)
 	t_nmi[1] = t_nmi[1] + (linux_trap_ipi15_sun4d - linux_trap_ipi15_sun4m);
 	
 	/* And set btfixup... */
-	BTFIXUPSET_BLACKBOX(smp_processor_id, smp4d_blackbox_id);
+	BTFIXUPSET_BLACKBOX(hard_smp_processor_id, smp4d_blackbox_id);
 	BTFIXUPSET_BLACKBOX(load_current, smp4d_blackbox_current);
 	BTFIXUPSET_CALL(smp_cross_call, smp4d_cross_call, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(smp_message_pass, smp4d_message_pass, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(__smp_processor_id, __smp4d_processor_id, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(__hard_smp_processor_id, __smp4d_processor_id, BTFIXUPCALL_NORM);
 	
 	for (i = 0; i < NR_CPUS; i++) {
 		ccall_info.processors_in[i] = 1;
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/kernel/sun4m_smp.c linux-2.6.8-rc3-bk3/arch/sparc/kernel/sun4m_smp.c
--- linux-2.6.8-rc3-bk2/arch/sparc/kernel/sun4m_smp.c	2004-08-08 17:21:22.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/kernel/sun4m_smp.c	2004-08-08 17:25:03.555168264 +0000
@@ -95,8 +95,6 @@ void __init smp4m_callin(void)
 	 * the SMP initialization the master will be just allowed
 	 * to call the scheduler code.
 	 */
-	init_idle();
-
 	/* Allow master to continue. */
 	swap((unsigned long *)&cpu_callin_map[cpuid], 1);
 
@@ -126,7 +124,6 @@ void __init smp4m_callin(void)
 extern int cpu_idle(void *unused);
 extern void init_IRQ(void);
 extern void cpu_panic(void);
-extern int start_secondary(void *unused);
 
 /*
  *	Cycle through the processors asking the PROM to start each one.
@@ -460,9 +457,9 @@ void __init smp4m_blackbox_current(unsig
 
 void __init sun4m_init_smp(void)
 {
-	BTFIXUPSET_BLACKBOX(smp_processor_id, smp4m_blackbox_id);
+	BTFIXUPSET_BLACKBOX(hard_smp_processor_id, smp4m_blackbox_id);
 	BTFIXUPSET_BLACKBOX(load_current, smp4m_blackbox_current);
 	BTFIXUPSET_CALL(smp_cross_call, smp4m_cross_call, BTFIXUPCALL_NORM);
 	BTFIXUPSET_CALL(smp_message_pass, smp4m_message_pass, BTFIXUPCALL_NORM);
-	BTFIXUPSET_CALL(__smp_processor_id, __smp4m_processor_id, BTFIXUPCALL_NORM);
+	BTFIXUPSET_CALL(__hard_smp_processor_id, __smp4m_processor_id, BTFIXUPCALL_NORM);
 }
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/kernel/trampoline.S linux-2.6.8-rc3-bk3/arch/sparc/kernel/trampoline.S
--- linux-2.6.8-rc3-bk2/arch/sparc/kernel/trampoline.S	2004-06-16 05:20:03.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/kernel/trampoline.S	2004-08-08 17:25:03.556168112 +0000
@@ -88,8 +88,6 @@ cpu3_startup:
 	.align	4
 
 smp_do_cpu_idle:
-	call	init_idle
-	 nop
 	call	cpu_idle
 	 mov	0, %o0
 
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/lib/memcpy.S linux-2.6.8-rc3-bk3/arch/sparc/lib/memcpy.S
--- linux-2.6.8-rc3-bk2/arch/sparc/lib/memcpy.S	2004-06-16 05:20:26.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/lib/memcpy.S	2004-08-08 17:25:03.562167200 +0000
@@ -42,124 +42,124 @@ x:
 #endif
 
 /* Both these macros have to start with exactly the same insn */
-#define MOVE_BIGCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) 				\
-	ldd	[%src + offset + 0x00], %t0; 								\
-	ldd	[%src + offset + 0x08], %t2; 								\
-	ldd	[%src + offset + 0x10], %t4; 								\
-	ldd	[%src + offset + 0x18], %t6; 								\
-	st	%t0, [%dst + offset + 0x00]; 								\
-	st	%t1, [%dst + offset + 0x04]; 								\
-	st	%t2, [%dst + offset + 0x08]; 								\
-	st	%t3, [%dst + offset + 0x0c]; 								\
-	st	%t4, [%dst + offset + 0x10]; 								\
-	st	%t5, [%dst + offset + 0x14]; 								\
-	st	%t6, [%dst + offset + 0x18]; 								\
-	st	%t7, [%dst + offset + 0x1c];
-
-#define MOVE_BIGALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) 				\
-	ldd	[%src + offset + 0x00], %t0; 								\
-	ldd	[%src + offset + 0x08], %t2; 								\
-	ldd	[%src + offset + 0x10], %t4; 								\
-	ldd	[%src + offset + 0x18], %t6; 								\
-	std	%t0, [%dst + offset + 0x00]; 								\
-	std	%t2, [%dst + offset + 0x08]; 								\
-	std	%t4, [%dst + offset + 0x10]; 								\
-	std	%t6, [%dst + offset + 0x18];
-
-#define MOVE_LASTCHUNK(src, dst, offset, t0, t1, t2, t3) 						\
-	ldd	[%src - offset - 0x10], %t0; 								\
-	ldd	[%src - offset - 0x08], %t2; 								\
-	st	%t0, [%dst - offset - 0x10]; 								\
-	st	%t1, [%dst - offset - 0x0c]; 								\
-	st	%t2, [%dst - offset - 0x08]; 								\
-	st	%t3, [%dst - offset - 0x04];
-
-#define MOVE_LASTALIGNCHUNK(src, dst, offset, t0, t1, t2, t3) 						\
-	ldd	[%src - offset - 0x10], %t0; 								\
-	ldd	[%src - offset - 0x08], %t2; 								\
-	std	%t0, [%dst - offset - 0x10]; 								\
-	std	%t2, [%dst - offset - 0x08];
-
-#define MOVE_SHORTCHUNK(src, dst, offset, t0, t1) 							\
-	ldub	[%src - offset - 0x02], %t0; 								\
-	ldub	[%src - offset - 0x01], %t1; 								\
-	stb	%t0, [%dst - offset - 0x02]; 								\
-	stb	%t1, [%dst - offset - 0x01];
+#define MOVE_BIGCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) \
+	ldd	[%src + (offset) + 0x00], %t0; \
+	ldd	[%src + (offset) + 0x08], %t2; \
+	ldd	[%src + (offset) + 0x10], %t4; \
+	ldd	[%src + (offset) + 0x18], %t6; \
+	st	%t0, [%dst + (offset) + 0x00]; \
+	st	%t1, [%dst + (offset) + 0x04]; \
+	st	%t2, [%dst + (offset) + 0x08]; \
+	st	%t3, [%dst + (offset) + 0x0c]; \
+	st	%t4, [%dst + (offset) + 0x10]; \
+	st	%t5, [%dst + (offset) + 0x14]; \
+	st	%t6, [%dst + (offset) + 0x18]; \
+	st	%t7, [%dst + (offset) + 0x1c];
+
+#define MOVE_BIGALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) \
+	ldd	[%src + (offset) + 0x00], %t0; \
+	ldd	[%src + (offset) + 0x08], %t2; \
+	ldd	[%src + (offset) + 0x10], %t4; \
+	ldd	[%src + (offset) + 0x18], %t6; \
+	std	%t0, [%dst + (offset) + 0x00]; \
+	std	%t2, [%dst + (offset) + 0x08]; \
+	std	%t4, [%dst + (offset) + 0x10]; \
+	std	%t6, [%dst + (offset) + 0x18];
+
+#define MOVE_LASTCHUNK(src, dst, offset, t0, t1, t2, t3) \
+	ldd	[%src - (offset) - 0x10], %t0; \
+	ldd	[%src - (offset) - 0x08], %t2; \
+	st	%t0, [%dst - (offset) - 0x10]; \
+	st	%t1, [%dst - (offset) - 0x0c]; \
+	st	%t2, [%dst - (offset) - 0x08]; \
+	st	%t3, [%dst - (offset) - 0x04];
+
+#define MOVE_LASTALIGNCHUNK(src, dst, offset, t0, t1, t2, t3) \
+	ldd	[%src - (offset) - 0x10], %t0; \
+	ldd	[%src - (offset) - 0x08], %t2; \
+	std	%t0, [%dst - (offset) - 0x10]; \
+	std	%t2, [%dst - (offset) - 0x08];
+
+#define MOVE_SHORTCHUNK(src, dst, offset, t0, t1) \
+	ldub	[%src - (offset) - 0x02], %t0; \
+	ldub	[%src - (offset) - 0x01], %t1; \
+	stb	%t0, [%dst - (offset) - 0x02]; \
+	stb	%t1, [%dst - (offset) - 0x01];
 
 /* Both these macros have to start with exactly the same insn */
-#define RMOVE_BIGCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) 				\
-	ldd	[%src - offset - 0x20], %t0; 								\
-	ldd	[%src - offset - 0x18], %t2; 								\
-	ldd	[%src - offset - 0x10], %t4; 								\
-	ldd	[%src - offset - 0x08], %t6; 								\
-	st	%t0, [%dst - offset - 0x20]; 								\
-	st	%t1, [%dst - offset - 0x1c]; 								\
-	st	%t2, [%dst - offset - 0x18]; 								\
-	st	%t3, [%dst - offset - 0x14]; 								\
-	st	%t4, [%dst - offset - 0x10]; 								\
-	st	%t5, [%dst - offset - 0x0c]; 								\
-	st	%t6, [%dst - offset - 0x08]; 								\
-	st	%t7, [%dst - offset - 0x04];
-
-#define RMOVE_BIGALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) 				\
-	ldd	[%src - offset - 0x20], %t0; 								\
-	ldd	[%src - offset - 0x18], %t2; 								\
-	ldd	[%src - offset - 0x10], %t4; 								\
-	ldd	[%src - offset - 0x08], %t6; 								\
-	std	%t0, [%dst - offset - 0x20]; 								\
-	std	%t2, [%dst - offset - 0x18]; 								\
-	std	%t4, [%dst - offset - 0x10]; 								\
-	std	%t6, [%dst - offset - 0x08];
-
-#define RMOVE_LASTCHUNK(src, dst, offset, t0, t1, t2, t3) 						\
-	ldd	[%src + offset + 0x00], %t0; 								\
-	ldd	[%src + offset + 0x08], %t2; 								\
-	st	%t0, [%dst + offset + 0x00]; 								\
-	st	%t1, [%dst + offset + 0x04]; 								\
-	st	%t2, [%dst + offset + 0x08]; 								\
-	st	%t3, [%dst + offset + 0x0c];
-
-#define RMOVE_SHORTCHUNK(src, dst, offset, t0, t1) 							\
-	ldub	[%src + offset + 0x00], %t0; 								\
-	ldub	[%src + offset + 0x01], %t1; 								\
-	stb	%t0, [%dst + offset + 0x00]; 								\
-	stb	%t1, [%dst + offset + 0x01];
-
-#define SMOVE_CHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, prev, shil, shir, offset2) 		\
-	ldd	[%src + offset + 0x00], %t0; 								\
-	ldd	[%src + offset + 0x08], %t2; 								\
-	srl	%t0, shir, %t5; 									\
-	srl	%t1, shir, %t6; 									\
-	sll	%t0, shil, %t0; 									\
-	or	%t5, %prev, %t5; 									\
-	sll	%t1, shil, %prev; 									\
-	or	%t6, %t0, %t0; 										\
-	srl	%t2, shir, %t1; 									\
-	srl	%t3, shir, %t6; 									\
-	sll	%t2, shil, %t2; 									\
-	or	%t1, %prev, %t1; 									\
-	std	%t4, [%dst + offset + offset2 - 0x04]; 							\
-	std	%t0, [%dst + offset + offset2 + 0x04];							\
-	sll	%t3, shil, %prev; 									\
+#define RMOVE_BIGCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) \
+	ldd	[%src - (offset) - 0x20], %t0; \
+	ldd	[%src - (offset) - 0x18], %t2; \
+	ldd	[%src - (offset) - 0x10], %t4; \
+	ldd	[%src - (offset) - 0x08], %t6; \
+	st	%t0, [%dst - (offset) - 0x20]; \
+	st	%t1, [%dst - (offset) - 0x1c]; \
+	st	%t2, [%dst - (offset) - 0x18]; \
+	st	%t3, [%dst - (offset) - 0x14]; \
+	st	%t4, [%dst - (offset) - 0x10]; \
+	st	%t5, [%dst - (offset) - 0x0c]; \
+	st	%t6, [%dst - (offset) - 0x08]; \
+	st	%t7, [%dst - (offset) - 0x04];
+
+#define RMOVE_BIGALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, t7) \
+	ldd	[%src - (offset) - 0x20], %t0; \
+	ldd	[%src - (offset) - 0x18], %t2; \
+	ldd	[%src - (offset) - 0x10], %t4; \
+	ldd	[%src - (offset) - 0x08], %t6; \
+	std	%t0, [%dst - (offset) - 0x20]; \
+	std	%t2, [%dst - (offset) - 0x18]; \
+	std	%t4, [%dst - (offset) - 0x10]; \
+	std	%t6, [%dst - (offset) - 0x08];
+
+#define RMOVE_LASTCHUNK(src, dst, offset, t0, t1, t2, t3) \
+	ldd	[%src + (offset) + 0x00], %t0; \
+	ldd	[%src + (offset) + 0x08], %t2; \
+	st	%t0, [%dst + (offset) + 0x00]; \
+	st	%t1, [%dst + (offset) + 0x04]; \
+	st	%t2, [%dst + (offset) + 0x08]; \
+	st	%t3, [%dst + (offset) + 0x0c];
+
+#define RMOVE_SHORTCHUNK(src, dst, offset, t0, t1) \
+	ldub	[%src + (offset) + 0x00], %t0; \
+	ldub	[%src + (offset) + 0x01], %t1; \
+	stb	%t0, [%dst + (offset) + 0x00]; \
+	stb	%t1, [%dst + (offset) + 0x01];
+
+#define SMOVE_CHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, prev, shil, shir, offset2) \
+	ldd	[%src + (offset) + 0x00], %t0; \
+	ldd	[%src + (offset) + 0x08], %t2; \
+	srl	%t0, shir, %t5; \
+	srl	%t1, shir, %t6; \
+	sll	%t0, shil, %t0; \
+	or	%t5, %prev, %t5; \
+	sll	%t1, shil, %prev; \
+	or	%t6, %t0, %t0; \
+	srl	%t2, shir, %t1; \
+	srl	%t3, shir, %t6; \
+	sll	%t2, shil, %t2; \
+	or	%t1, %prev, %t1; \
+	std	%t4, [%dst + (offset) + (offset2) - 0x04]; \
+	std	%t0, [%dst + (offset) + (offset2) + 0x04]; \
+	sll	%t3, shil, %prev; \
 	or	%t6, %t2, %t4;
 
-#define SMOVE_ALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, prev, shil, shir, offset2) 	\
-	ldd	[%src + offset + 0x00], %t0; 								\
-	ldd	[%src + offset + 0x08], %t2; 								\
-	srl	%t0, shir, %t4; 									\
-	srl	%t1, shir, %t5; 									\
-	sll	%t0, shil, %t6; 									\
-	or	%t4, %prev, %t0; 									\
-	sll	%t1, shil, %prev; 									\
-	or	%t5, %t6, %t1; 										\
-	srl	%t2, shir, %t4; 									\
-	srl	%t3, shir, %t5; 									\
-	sll	%t2, shil, %t6; 									\
-	or	%t4, %prev, %t2; 									\
-	sll	%t3, shil, %prev; 									\
-	or	%t5, %t6, %t3;										\
-	std	%t0, [%dst + offset + offset2 + 0x00]; 							\
-	std	%t2, [%dst + offset + offset2 + 0x08];
+#define SMOVE_ALIGNCHUNK(src, dst, offset, t0, t1, t2, t3, t4, t5, t6, prev, shil, shir, offset2) \
+	ldd	[%src + (offset) + 0x00], %t0; \
+	ldd	[%src + (offset) + 0x08], %t2; \
+	srl	%t0, shir, %t4;	\
+	srl	%t1, shir, %t5;	\
+	sll	%t0, shil, %t6;	\
+	or	%t4, %prev, %t0; \
+	sll	%t1, shil, %prev; \
+	or	%t5, %t6, %t1; \
+	srl	%t2, shir, %t4;	\
+	srl	%t3, shir, %t5;	\
+	sll	%t2, shil, %t6; \
+	or	%t4, %prev, %t2; \
+	sll	%t3, shil, %prev; \
+	or	%t5, %t6, %t3; \
+	std	%t0, [%dst + (offset) + (offset2) + 0x00]; \
+	std	%t2, [%dst + (offset) + (offset2) + 0x08];
 
 	.text
 	.align	4
diff -p -purN linux-2.6.8-rc3-bk2/arch/sparc/mm/srmmu.c linux-2.6.8-rc3-bk3/arch/sparc/mm/srmmu.c
--- linux-2.6.8-rc3-bk2/arch/sparc/mm/srmmu.c	2004-06-16 05:19:36.000000000 +0000
+++ linux-2.6.8-rc3-bk3/arch/sparc/mm/srmmu.c	2004-08-08 17:25:03.567166440 +0000
@@ -1697,9 +1697,7 @@ static void turbosparc_flush_cache_mm(st
 
 static void turbosparc_flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
-	struct mm_struct *mm = vma->vm_mm;
-
-	FLUSH_BEGIN(mm)
+	FLUSH_BEGIN(vma->vm_mm)
 	flush_user_windows();
 	turbosparc_idflash_clear();
 	FLUSH_END
@@ -1750,9 +1748,7 @@ static void turbosparc_flush_tlb_mm(stru
 
 static void turbosparc_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
-	struct mm_struct *mm = vma->vm_mm;
-
-	FLUSH_BEGIN(mm)
+	FLUSH_BEGIN(vma->vm_mm)
 	srmmu_flush_whole_tlb();
 	FLUSH_END
 }
diff -p -purN linux-2.6.8-rc3-bk2/drivers/cdrom/cdrom.c linux-2.6.8-rc3-bk3/drivers/cdrom/cdrom.c
--- linux-2.6.8-rc3-bk2/drivers/cdrom/cdrom.c	2004-08-08 17:21:23.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/cdrom/cdrom.c	2004-08-08 17:25:03.579164616 +0000
@@ -2933,13 +2933,13 @@ struct cdrom_sysctl_settings {
 } cdrom_sysctl_settings;
 
 int cdrom_sysctl_info(ctl_table *ctl, int write, struct file * filp,
-                           void __user *buffer, size_t *lenp)
+                           void __user *buffer, size_t *lenp, loff_t *ppos)
 {
         int pos;
 	struct cdrom_device_info *cdi;
 	char *info = cdrom_sysctl_settings.info;
 	
-	if (!*lenp || (filp->f_pos && !write)) {
+	if (!*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -3028,7 +3028,7 @@ int cdrom_sysctl_info(ctl_table *ctl, in
 
 	strcpy(info+pos,"\n\n");
 		
-        return proc_dostring(ctl, write, filp, buffer, lenp);
+        return proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 }
 
 /* Unfortunately, per device settings are not implemented through
@@ -3060,13 +3060,13 @@ void cdrom_update_settings(void)
 }
 
 static int cdrom_sysctl_handler(ctl_table *ctl, int write, struct file * filp,
-				void __user *buffer, size_t *lenp)
+				void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int *valp = ctl->data;
 	int val = *valp;
 	int ret;
 	
-	ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && *valp != val) {
 	
diff -p -purN linux-2.6.8-rc3-bk2/drivers/char/ds1620.c linux-2.6.8-rc3-bk3/drivers/char/ds1620.c
--- linux-2.6.8-rc3-bk2/drivers/char/ds1620.c	2004-06-16 05:18:57.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/char/ds1620.c	2004-08-08 17:25:03.582164160 +0000
@@ -218,10 +218,6 @@ ds1620_read(struct file *file, char *buf
 	signed int cur_temp;
 	signed char cur_temp_degF;
 
-	/* Can't seek (pread) on this device */
-	if (ptr != &file->f_pos)
-		return -ESPIPE;
-
 	cur_temp = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9)) >> 1;
 
 	/* convert to Fahrenheit, as per wdt.c */
@@ -338,6 +334,7 @@ static struct proc_dir_entry *proc_therm
 
 static struct file_operations ds1620_fops = {
 	.owner		= THIS_MODULE,
+	.open		= nonseekable_open,
 	.read		= ds1620_read,
 	.ioctl		= ds1620_ioctl,
 };
diff -p -purN linux-2.6.8-rc3-bk2/drivers/char/dtlk.c linux-2.6.8-rc3-bk3/drivers/char/dtlk.c
--- linux-2.6.8-rc3-bk2/drivers/char/dtlk.c	2004-08-08 17:21:23.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/char/dtlk.c	2004-08-08 17:25:03.584163856 +0000
@@ -128,10 +128,6 @@ static ssize_t dtlk_read(struct file *fi
 	char ch;
 	int i = 0, retries;
 
-	/* Can't seek (pread) on the DoubleTalk.  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	TRACE_TEXT("(dtlk_read");
 	/*  printk("DoubleTalk PC - dtlk_read()\n"); */
 
@@ -303,6 +299,7 @@ static int dtlk_open(struct inode *inode
 {
 	TRACE_TEXT("(dtlk_open");
 
+	nonseekable_open(inode, file);
 	switch (iminor(inode)) {
 	case DTLK_MINOR:
 		if (dtlk_busy)
diff -p -purN linux-2.6.8-rc3-bk2/drivers/char/random.c linux-2.6.8-rc3-bk3/drivers/char/random.c
--- linux-2.6.8-rc3-bk2/drivers/char/random.c	2004-06-16 05:18:57.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/char/random.c	2004-08-08 17:25:03.589163096 +0000
@@ -1894,13 +1894,13 @@ static int change_poolsize(int poolsize)
 }
 
 static int proc_do_poolsize(ctl_table *table, int write, struct file *filp,
-			    void __user *buffer, size_t *lenp)
+			    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int	ret;
 
 	sysctl_poolsize = random_state->poolinfo.POOLBYTES;
 
-	ret = proc_dointvec(table, write, filp, buffer, lenp);
+	ret = proc_dointvec(table, write, filp, buffer, lenp, ppos);
 	if (ret || !write ||
 	    (sysctl_poolsize == random_state->poolinfo.POOLBYTES))
 		return ret;
@@ -1945,7 +1945,7 @@ static int poolsize_strategy(ctl_table *
  * sysctl system call, it is returned as 16 bytes of binary data.
  */
 static int proc_do_uuid(ctl_table *table, int write, struct file *filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	ctl_table	fake_table;
 	unsigned char	buf[64], tmp_uuid[16], *uuid;
@@ -1967,7 +1967,7 @@ static int proc_do_uuid(ctl_table *table
 	fake_table.data = buf;
 	fake_table.maxlen = sizeof(buf);
 
-	return proc_dostring(&fake_table, write, filp, buffer, lenp);
+	return proc_dostring(&fake_table, write, filp, buffer, lenp, ppos);
 }
 
 static int uuid_strategy(ctl_table *table, int __user *name, int nlen,
diff -p -purN linux-2.6.8-rc3-bk2/drivers/char/tty_io.c linux-2.6.8-rc3-bk3/drivers/char/tty_io.c
--- linux-2.6.8-rc3-bk2/drivers/char/tty_io.c	2004-08-08 17:21:24.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/char/tty_io.c	2004-08-08 17:25:03.596162032 +0000
@@ -345,18 +345,12 @@ EXPORT_SYMBOL(tty_check_change);
 static ssize_t hung_up_tty_read(struct file * file, char __user * buf,
 				size_t count, loff_t *ppos)
 {
-	/* Can't seek (pread) on ttys.  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
 	return 0;
 }
 
 static ssize_t hung_up_tty_write(struct file * file, const char __user * buf,
 				 size_t count, loff_t *ppos)
 {
-	/* Can't seek (pwrite) on ttys.  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
 	return -EIO;
 }
 
@@ -648,10 +642,6 @@ static ssize_t tty_read(struct file * fi
 	struct tty_struct * tty;
 	struct inode *inode;
 
-	/* Can't seek (pread) on ttys.  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	tty = (struct tty_struct *)file->private_data;
 	inode = file->f_dentry->d_inode;
 	if (tty_paranoia_check(tty, inode, "tty_read"))
@@ -726,10 +716,6 @@ static ssize_t tty_write(struct file * f
 	struct tty_struct * tty;
 	struct inode *inode = file->f_dentry->d_inode;
 
-	/* Can't seek (pwrite) on ttys.  */
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	tty = (struct tty_struct *)file->private_data;
 	if (tty_paranoia_check(tty, inode, "tty_write"))
 		return -EIO;
@@ -755,9 +741,6 @@ ssize_t redirected_tty_write(struct file
 
 	if (p) {
 		ssize_t res;
-		/* Can't seek (pwrite) on ttys.  */
-		if (ppos != &file->f_pos)
-			return -ESPIPE;
 		res = vfs_write(p, buf, count, &p->f_pos);
 		fput(p);
 		return res;
@@ -1339,6 +1322,7 @@ static int tty_open(struct inode * inode
 	dev_t device = inode->i_rdev;
 	unsigned short saved_flags = filp->f_flags;
 
+	nonseekable_open(inode, filp);
 retry_open:
 	noctty = filp->f_flags & O_NOCTTY;
 	index  = -1;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/cpufreq/cpufreq_userspace.c linux-2.6.8-rc3-bk3/drivers/cpufreq/cpufreq_userspace.c
--- linux-2.6.8-rc3-bk2/drivers/cpufreq/cpufreq_userspace.c	2004-06-16 05:18:58.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/cpufreq/cpufreq_userspace.c	2004-08-08 17:25:03.599161576 +0000
@@ -151,13 +151,13 @@ EXPORT_SYMBOL_GPL(cpufreq_setmax);
 /*********************** cpufreq_sysctl interface ********************/
 static int
 cpufreq_procctl(ctl_table *ctl, int write, struct file *filp,
-		void __user *buffer, size_t *lenp)
+		void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	char buf[16], *p;
 	int cpu = (long) ctl->extra1;
 	unsigned int len, left = *lenp;
 
-	if (!left || (filp->f_pos && !write) || !cpu_online(cpu)) {
+	if (!left || (*ppos && !write) || !cpu_online(cpu)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -183,7 +183,7 @@ cpufreq_procctl(ctl_table *ctl, int writ
 	}
 
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 	return 0;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/ide/ide-tape.c linux-2.6.8-rc3-bk3/drivers/ide/ide-tape.c
--- linux-2.6.8-rc3-bk2/drivers/ide/ide-tape.c	2004-08-08 17:21:24.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/ide/ide-tape.c	2004-08-08 17:25:03.612159600 +0000
@@ -3755,10 +3755,6 @@ static ssize_t idetape_chrdev_read (stru
 	idetape_tape_t *tape = drive->driver_data;
 	ssize_t bytes_read,temp, actually_read = 0, rc;
 
-	if (ppos != &file->f_pos) {
-		/* "A request was outside the capabilities of the device." */
-		return -ENXIO;
-	}
 #if IDETAPE_DEBUG_LOG
 	if (tape->debug_level >= 3)
 		printk(KERN_INFO "ide-tape: Reached idetape_chrdev_read, count %Zd\n", count);
@@ -3818,11 +3814,6 @@ static ssize_t idetape_chrdev_write (str
 	idetape_tape_t *tape = drive->driver_data;
 	ssize_t retval, actually_written = 0;
 
-	if (ppos != &file->f_pos) {
-		/* "A request was outside the capabilities of the device." */
-		return -ENXIO;
-	}
-
 	/* The drive is write protected. */
 	if (tape->write_prot)
 		return -EACCES;
@@ -4187,6 +4178,7 @@ static int idetape_chrdev_open (struct i
 	idetape_pc_t pc;
 	int retval;
 
+	nonseekable_open(inode, filp);
 #if IDETAPE_DEBUG_LOG
 	printk(KERN_INFO "ide-tape: Reached idetape_chrdev_open\n");
 #endif /* IDETAPE_DEBUG_LOG */
diff -p -purN linux-2.6.8-rc3-bk2/drivers/net/ppp_generic.c linux-2.6.8-rc3-bk3/drivers/net/ppp_generic.c
--- linux-2.6.8-rc3-bk2/drivers/net/ppp_generic.c	2004-08-08 17:21:27.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/net/ppp_generic.c	2004-08-08 17:25:03.633156408 +0000
@@ -1026,11 +1026,7 @@ ppp_send_frame(struct ppp *ppp, struct s
 		/* check if we should pass this packet */
 		/* the filter instructions are constructed assuming
 		   a four-byte PPP header on each packet */
-		{
-			u_int16_t *p = (u_int16_t *) skb_push(skb, 2);
-
-			*p = htons(4); /* indicate outbound in DLT_LINUX_SLL */;
-		}
+		*skb_push(skb, 2) = 1;
 		if (ppp->pass_filter
 		    && sk_run_filter(skb, ppp->pass_filter,
 				     ppp->pass_len) == 0) {
@@ -1573,11 +1569,7 @@ ppp_receive_nonmp_frame(struct ppp *ppp,
 		/* check if the packet passes the pass and active filters */
 		/* the filter instructions are constructed assuming
 		   a four-byte PPP header on each packet */
-		{
-			u_int16_t *p = (u_int16_t *) skb_push(skb, 2);
-
-			*p = 0; /* indicate inbound in DLT_LINUX_SLL */
-		}
+		*skb_push(skb, 2) = 0;
 		if (ppp->pass_filter
 		    && sk_run_filter(skb, ppp->pass_filter,
 				     ppp->pass_len) == 0) {
diff -p -purN linux-2.6.8-rc3-bk2/drivers/net/wireless/arlan-proc.c linux-2.6.8-rc3-bk3/drivers/net/wireless/arlan-proc.c
--- linux-2.6.8-rc3-bk2/drivers/net/wireless/arlan-proc.c	2004-08-08 17:21:28.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/net/wireless/arlan-proc.c	2004-08-08 17:25:03.637155800 +0000
@@ -399,7 +399,7 @@ static int arlan_setup_card_by_book(stru
 static char arlan_drive_info[ARLAN_STR_SIZE] = "A655\n\0";
 
 static int arlan_sysctl_info(ctl_table * ctl, int write, struct file *filp,
-		      void __user *buffer, size_t * lenp)
+		      void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int i;
 	int retv, pos, devnum;
@@ -625,7 +625,7 @@ final:
 	*lenp = pos;
 
 	if (!write)
-		retv = proc_dostring(ctl, write, filp, buffer, lenp);
+		retv = proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 	else
 	{
 		*lenp = 0;
@@ -636,7 +636,7 @@ final:
 
 
 static int arlan_sysctl_info161719(ctl_table * ctl, int write, struct file *filp,
-			    void __user *buffer, size_t * lenp)
+			    void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int i;
 	int retv, pos, devnum;
@@ -665,12 +665,12 @@ static int arlan_sysctl_info161719(ctl_t
 
 final:
 	*lenp = pos;
-	retv = proc_dostring(ctl, write, filp, buffer, lenp);
+	retv = proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 	return retv;
 }
 
 static int arlan_sysctl_infotxRing(ctl_table * ctl, int write, struct file *filp,
-			    void __user *buffer, size_t * lenp)
+			    void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int i;
 	int retv, pos, devnum;
@@ -694,12 +694,12 @@ static int arlan_sysctl_infotxRing(ctl_t
 	SARLBNpln(u_char, txBuffer, 0x800);
 final:
 	*lenp = pos;
-	retv = proc_dostring(ctl, write, filp, buffer, lenp);
+	retv = proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 	return retv;
 }
 
 static int arlan_sysctl_inforxRing(ctl_table * ctl, int write, struct file *filp,
-			    void __user *buffer, size_t * lenp)
+			    void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int i;
 	int retv, pos, devnum;
@@ -722,12 +722,12 @@ static int arlan_sysctl_inforxRing(ctl_t
 	SARLBNpln(u_char, rxBuffer, 0x800);
 final:
 	*lenp = pos;
-	retv = proc_dostring(ctl, write, filp, buffer, lenp);
+	retv = proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 	return retv;
 }
 
 static int arlan_sysctl_info18(ctl_table * ctl, int write, struct file *filp,
-			void __user *buffer, size_t * lenp)
+			void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int i;
 	int retv, pos, devnum;
@@ -752,7 +752,7 @@ static int arlan_sysctl_info18(ctl_table
 
 final:
 	*lenp = pos;
-	retv = proc_dostring(ctl, write, filp, buffer, lenp);
+	retv = proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 	return retv;
 }
 
@@ -763,7 +763,7 @@ final:
 static char conf_reset_result[200];
 
 static int arlan_configure(ctl_table * ctl, int write, struct file *filp,
-		    void __user *buffer, size_t * lenp)
+		    void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int pos = 0;
 	int devnum = ctl->procname[6] - '0';
@@ -784,11 +784,11 @@ static int arlan_configure(ctl_table * c
 		return -1;
 
 	*lenp = pos;
-	return proc_dostring(ctl, write, filp, buffer, lenp);
+	return proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 }
 
 static int arlan_sysctl_reset(ctl_table * ctl, int write, struct file *filp,
-		       void __user *buffer, size_t * lenp)
+		       void __user *buffer, size_t * lenp, loff_t *ppos)
 {
 	int pos = 0;
 	int devnum = ctl->procname[5] - '0';
@@ -807,7 +807,7 @@ static int arlan_sysctl_reset(ctl_table 
 	} else
 		return -1;
 	*lenp = pos + 3;
-	return proc_dostring(ctl, write, filp, buffer, lenp);
+	return proc_dostring(ctl, write, filp, buffer, lenp, ppos);
 }
 
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/parport/procfs.c linux-2.6.8-rc3-bk3/drivers/parport/procfs.c
--- linux-2.6.8-rc3-bk2/drivers/parport/procfs.c	2004-06-16 05:19:02.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/parport/procfs.c	2004-08-08 17:25:03.643154888 +0000
@@ -33,7 +33,7 @@
 #define PARPORT_MAX_SPINTIME_VALUE 1000
 
 static int do_active_device(ctl_table *table, int write, struct file *filp,
-		      void __user *result, size_t *lenp)
+		      void __user *result, size_t *lenp, loff_t *ppos)
 {
 	struct parport *port = (struct parport *)table->extra1;
 	char buffer[256];
@@ -43,7 +43,7 @@ static int do_active_device(ctl_table *t
 	if (write)		/* can't happen anyway */
 		return -EACCES;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -63,14 +63,14 @@ static int do_active_device(ctl_table *t
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
 }
 
 #ifdef CONFIG_PARPORT_1284
 static int do_autoprobe(ctl_table *table, int write, struct file *filp,
-			void __user *result, size_t *lenp)
+			void __user *result, size_t *lenp, loff_t *ppos)
 {
 	struct parport_device_info *info = table->extra2;
 	const char *str;
@@ -80,7 +80,7 @@ static int do_autoprobe(ctl_table *table
 	if (write) /* permissions stop this */
 		return -EACCES;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -105,7 +105,7 @@ static int do_autoprobe(ctl_table *table
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user (result, buffer, len) ? -EFAULT : 0;
 }
@@ -113,13 +113,13 @@ static int do_autoprobe(ctl_table *table
 
 static int do_hardware_base_addr (ctl_table *table, int write,
 				  struct file *filp, void __user *result,
-				  size_t *lenp)
+				  size_t *lenp, loff_t *ppos)
 {
 	struct parport *port = (struct parport *)table->extra1;
 	char buffer[20];
 	int len = 0;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -134,20 +134,20 @@ static int do_hardware_base_addr (ctl_ta
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
 }
 
 static int do_hardware_irq (ctl_table *table, int write,
 			    struct file *filp, void __user *result,
-			    size_t *lenp)
+			    size_t *lenp, loff_t *ppos)
 {
 	struct parport *port = (struct parport *)table->extra1;
 	char buffer[20];
 	int len = 0;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -162,20 +162,20 @@ static int do_hardware_irq (ctl_table *t
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
 }
 
 static int do_hardware_dma (ctl_table *table, int write,
 			    struct file *filp, void __user *result,
-			    size_t *lenp)
+			    size_t *lenp, loff_t *ppos)
 {
 	struct parport *port = (struct parport *)table->extra1;
 	char buffer[20];
 	int len = 0;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -190,20 +190,20 @@ static int do_hardware_dma (ctl_table *t
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
 }
 
 static int do_hardware_modes (ctl_table *table, int write,
 			      struct file *filp, void __user *result,
-			      size_t *lenp)
+			      size_t *lenp, loff_t *ppos)
 {
 	struct parport *port = (struct parport *)table->extra1;
 	char buffer[40];
 	int len = 0;
 
-	if (filp->f_pos) {
+	if (*ppos) {
 		*lenp = 0;
 		return 0;
 	}
@@ -229,7 +229,7 @@ static int do_hardware_modes (ctl_table 
 	else
 		*lenp = len;
 
-	filp->f_pos += len;
+	*ppos += len;
 
 	return copy_to_user(result, buffer, len) ? -EFAULT : 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/chsc.c linux-2.6.8-rc3-bk3/drivers/s390/cio/chsc.c
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/chsc.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/chsc.c	2004-08-08 17:25:03.645154584 +0000
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision: 1.114 $
+ *   $Revision: 1.115 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -906,8 +906,6 @@ new_channel_path(int chpid)
 		return -ENOMEM;
 	memset(chp, 0, sizeof(struct channel_path));
 
-	chps[chpid] = chp;
-
 	/* fill in status, etc. */
 	chp->id = chpid;
 	chp->state = 1;
@@ -922,12 +920,17 @@ new_channel_path(int chpid)
 	if (ret) {
 		printk(KERN_WARNING "%s: could not register %02x\n",
 		       __func__, chpid);
-		return ret;
+		goto out_free;
 	}
 	ret = device_create_file(&chp->dev, &dev_attr_status);
-	if (ret)
+	if (ret) {
 		device_unregister(&chp->dev);
-
+		goto out_free;
+	} else
+		chps[chpid] = chp;
+	return ret;
+out_free:
+	kfree(chp);
 	return ret;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/cio.h linux-2.6.8-rc3-bk3/drivers/s390/cio/cio.h
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/cio.h	2004-06-16 05:18:52.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/cio.h	2004-08-08 17:25:03.646154432 +0000
@@ -127,10 +127,15 @@ extern int cio_set_options (struct subch
 extern int cio_get_options (struct subchannel *);
 extern int cio_modify (struct subchannel *);
 /* Use with care. */
+#ifdef CONFIG_CCW_CONSOLE
 extern struct subchannel *cio_probe_console(void);
 extern void cio_release_console(void);
 extern int cio_is_console(int irq);
 extern struct subchannel *cio_get_console_subchannel(void);
+#else
+#define cio_is_console(irq) 0
+#define cio_get_console_subchannel() NULL
+#endif
 
 extern int cio_show_msg;
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/device_fsm.c linux-2.6.8-rc3-bk3/drivers/s390/cio/device_fsm.c
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/device_fsm.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/device_fsm.c	2004-08-08 17:25:03.648154128 +0000
@@ -244,6 +244,7 @@ ccw_device_recog_done(struct ccw_device 
 		};
 		if (notify) {
 			/* Get device online again. */
+			cdev->private->state = DEV_STATE_OFFLINE;
 			ccw_device_online(cdev);
 			wake_up(&cdev->private->wait_q);
 			return;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/device_ops.c linux-2.6.8-rc3-bk3/drivers/s390/cio/device_ops.c
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/device_ops.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/device_ops.c	2004-08-08 17:25:03.651153672 +0000
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device_ops.c
  *
- *   $Revision: 1.49 $
+ *   $Revision: 1.50 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -295,7 +295,7 @@ __ccw_device_retry_loop(struct ccw_devic
 			break;
 		/* Try again later. */
 		spin_unlock_irq(&sch->lock);
-		schedule_timeout(1);
+		msleep(10);
 		spin_lock_irq(&sch->lock);
 	} while (1);
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/device_status.c linux-2.6.8-rc3-bk3/drivers/s390/cio/device_status.c
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/device_status.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/device_status.c	2004-08-08 17:25:03.653153368 +0000
@@ -348,7 +348,8 @@ ccw_device_accumulate_basic_sense(struct
 	     (irb->scsw.actl & SCSW_ACTL_SUSPENDED)))
 		ccw_device_path_notoper(cdev);
 
-	if (!(irb->scsw.dstat & DEV_STAT_UNIT_CHECK)) {
+	if (!(irb->scsw.dstat & DEV_STAT_UNIT_CHECK) &&
+	    (irb->scsw.dstat & DEV_STAT_CHN_END)) {
 		cdev->private->irb.esw.esw0.erw.cons = 1;
 		cdev->private->flags.dosense = 0;
 	}
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/qdio.c linux-2.6.8-rc3-bk3/drivers/s390/cio/qdio.c
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/qdio.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/qdio.c	2004-08-08 17:25:03.664151696 +0000
@@ -56,7 +56,7 @@
 #include "ioasm.h"
 #include "chsc.h"
 
-#define VERSION_QDIO_C "$Revision: 1.83 $"
+#define VERSION_QDIO_C "$Revision: 1.84 $"
 
 /****************** MODULE PARAMETER VARIABLES ********************/
 MODULE_AUTHOR("Utz Bacher <utz.bacher@de.ibm.com>");
@@ -87,10 +87,10 @@ static debug_info_t *qdio_dbf_setup;
 static debug_info_t *qdio_dbf_sbal;
 static debug_info_t *qdio_dbf_trace;
 static debug_info_t *qdio_dbf_sense;
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 static debug_info_t *qdio_dbf_slsb_out;
 static debug_info_t *qdio_dbf_slsb_in;
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 /* iQDIO stuff: */
 static volatile struct qdio_q *tiq_list=NULL; /* volatile as it could change
@@ -514,10 +514,13 @@ inline static int
 qdio_is_outbound_q_done(struct qdio_q *q)
 {
 	int no_used;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif
 
 	no_used=atomic_read(&q->number_of_buffers_used);
 
+#ifdef CONFIG_QDIO_DEBUG
 	if (no_used) {
 		sprintf(dbf_text,"oqisnt%02x",no_used);
 		QDIO_DBF_TEXT4(0,trace,dbf_text);
@@ -525,6 +528,7 @@ qdio_is_outbound_q_done(struct qdio_q *q
 		QDIO_DBF_TEXT4(0,trace,"oqisdone");
 	}
 	QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
+#endif /* CONFIG_QDIO_DEBUG */
 	return (no_used==0);
 }
 
@@ -552,10 +556,12 @@ inline static void
 qdio_kick_outbound_q(struct qdio_q *q)
 {
 	int result;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
 
 	QDIO_DBF_TEXT4(0,trace,"kickoutq");
 	QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (!q->siga_out)
 		return;
@@ -593,16 +599,18 @@ qdio_kick_outbound_q(struct qdio_q *q)
 
 		switch (result) {
 		case 0:
-		/* went smooth this time, reset timestamp */
+			/* went smooth this time, reset timestamp */
+#ifdef CONFIG_QDIO_DEBUG
 			QDIO_DBF_TEXT3(0,trace,"cc2reslv");
 			sprintf(dbf_text,"%4x%2x%2x",q->irq,q->q_no,
 				atomic_read(&q->busy_siga_counter));
 			QDIO_DBF_TEXT3(0,trace,dbf_text);
 			q->timing.busy_start=0;
+#endif /* CONFIG_QDIO_DEBUG */
 			break;
 		case (2|QDIO_SIGA_ERROR_B_BIT_SET):
 			/* cc=2 and busy bit: */
-		atomic_inc(&q->busy_siga_counter);
+			atomic_inc(&q->busy_siga_counter);
 
 			/* if the last siga was successful, save
 			 * timestamp here */
@@ -616,9 +624,11 @@ qdio_kick_outbound_q(struct qdio_q *q)
 				break;
 			}
 			QDIO_DBF_TEXT2(0,trace,"cc2REPRT");
+#ifdef CONFIG_QDIO_DEBUG
 			sprintf(dbf_text,"%4x%2x%2x",q->irq,q->q_no,
 				atomic_read(&q->busy_siga_counter));
 			QDIO_DBF_TEXT3(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 			/* else fallthrough and report error */
 		default:
 			/* for plain cc=1, 2 or 3: */
@@ -635,7 +645,9 @@ inline static void
 qdio_kick_outbound_handler(struct qdio_q *q)
 {
 	int start, end, real_end, count;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif
 
 	start = q->first_element_to_kick;
 	/* last_move_ftc was just updated */
@@ -645,11 +657,13 @@ qdio_kick_outbound_handler(struct qdio_q
 	count = (end+QDIO_MAX_BUFFERS_PER_Q+1-start)&
 		(QDIO_MAX_BUFFERS_PER_Q-1);
 
+#ifdef CONFIG_QDIO_DEBUG
 	QDIO_DBF_TEXT4(0,trace,"kickouth");
 	QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
 
 	sprintf(dbf_text,"s=%2xc=%2x",start,count);
 	QDIO_DBF_TEXT4(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (q->state==QDIO_IRQ_STATE_ACTIVE)
 		q->handler(q->cdev,QDIO_STATUS_OUTBOUND_INT|
@@ -732,7 +746,9 @@ qdio_get_inbound_buffer_frontier(struct 
 	int f,f_mod_no;
 	volatile char *slsb;
 	int first_not_to_check;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif /* CONFIG_QDIO_DEBUG */
 #ifdef QDIO_USE_PROCESSING_STATE
 	int last_position=-1;
 #endif /* QDIO_USE_PROCESSING_STATE */
@@ -806,8 +822,10 @@ check_next:
 
 	/* P_ERROR means frontier is reached, break and report error */
 	case SLSB_P_INPUT_ERROR:
+#ifdef CONFIG_QDIO_DEBUG
 		sprintf(dbf_text,"inperr%2x",f_mod_no);
 		QDIO_DBF_TEXT3(1,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 		QDIO_DBF_HEX2(1,sbal,q->sbal[f_mod_no],256);
 
 		/* kind of process the buffer */
@@ -884,13 +902,16 @@ inline static int
 iqdio_is_inbound_q_done(struct qdio_q *q)
 {
 	int no_used;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif
 
 	no_used=atomic_read(&q->number_of_buffers_used);
 
 	/* propagate the change from 82 to 80 through VM */
 	SYNC_MEMORY;
 
+#ifdef CONFIG_QDIO_DEBUG
 	if (no_used) {
 		sprintf(dbf_text,"iqisnt%02x",no_used);
 		QDIO_DBF_TEXT4(0,trace,dbf_text);
@@ -898,6 +919,7 @@ iqdio_is_inbound_q_done(struct qdio_q *q
 		QDIO_DBF_TEXT4(0,trace,"iniqisdo");
 	}
 	QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (!no_used)
 		return 1;
@@ -933,7 +955,9 @@ inline static int
 qdio_is_inbound_q_done(struct qdio_q *q)
 {
 	int no_used;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif
 
 	no_used=atomic_read(&q->number_of_buffers_used);
 
@@ -968,16 +992,20 @@ qdio_is_inbound_q_done(struct qdio_q *q)
 	 * has (probably) not moved (see qdio_inbound_processing) 
 	 */
 	if (NOW>GET_SAVED_TIMESTAMP(q)+q->timing.threshold) {
+#ifdef CONFIG_QDIO_DEBUG
 		QDIO_DBF_TEXT4(0,trace,"inqisdon");
 		QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
 		sprintf(dbf_text,"pf%02xcn%02x",q->first_to_check,no_used);
 		QDIO_DBF_TEXT4(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 		return 1;
 	} else {
+#ifdef CONFIG_QDIO_DEBUG
 		QDIO_DBF_TEXT4(0,trace,"inqisntd");
 		QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
 		sprintf(dbf_text,"pf%02xcn%02x",q->first_to_check,no_used);
 		QDIO_DBF_TEXT4(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 		return 0;
 	}
 }
@@ -986,7 +1014,9 @@ inline static void
 qdio_kick_inbound_handler(struct qdio_q *q)
 {
 	int count, start, end, real_end, i;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
+#endif
 
 	QDIO_DBF_TEXT4(0,trace,"kickinh");
 	QDIO_DBF_HEX4(0,trace,&q,sizeof(void*));
@@ -1004,8 +1034,10 @@ qdio_kick_inbound_handler(struct qdio_q 
  		i=(i+1)&(QDIO_MAX_BUFFERS_PER_Q-1);
  	}
 
+#ifdef CONFIG_QDIO_DEBUG
 	sprintf(dbf_text,"s=%2xc=%2x",start,count);
 	QDIO_DBF_TEXT4(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (likely(q->state==QDIO_IRQ_STATE_ACTIVE))
 		q->handler(q->cdev,
@@ -1622,11 +1654,13 @@ static void
 qdio_set_state(struct qdio_irq *irq_ptr, enum qdio_irq_states state)
 {
 	int i;
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[15];
 
 	QDIO_DBF_TEXT5(0,trace,"newstate");
 	sprintf(dbf_text,"%4x%4x",irq_ptr->irq,state);
 	QDIO_DBF_TEXT5(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	irq_ptr->state=state;
 	for (i=0;i<irq_ptr->no_input_qs;i++)
@@ -1791,9 +1825,11 @@ qdio_handler(struct ccw_device *cdev, un
 	int cstat,dstat;
 	char dbf_text[15];
 
+#ifdef CONFIG_QDIO_DEBUG
 	QDIO_DBF_TEXT4(0, trace, "qint");
 	sprintf(dbf_text, "%s", cdev->dev.bus_id);
 	QDIO_DBF_TEXT4(0, trace, dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 	
 	if (!intparm) {
 		QDIO_PRINT_ERR("got unsolicited interrupt in qdio " \
@@ -1830,8 +1866,10 @@ qdio_handler(struct ccw_device *cdev, un
 
 	qdio_irq_check_sense(irq_ptr->irq, irb);
 
+#ifdef CONFIG_QDIO_DEBUG
 	sprintf(dbf_text, "state:%d", irq_ptr->state);
 	QDIO_DBF_TEXT4(0, trace, dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
         cstat = irb->scsw.cstat;
         dstat = irb->scsw.dstat;
@@ -1872,18 +1910,22 @@ qdio_synchronize(struct ccw_device *cdev
 	int cc;
 	struct qdio_q *q;
 	struct qdio_irq *irq_ptr;
-	char dbf_text[15]="SyncXXXX";
 	void *ptr;
+#ifdef CONFIG_QDIO_DEBUG
+	char dbf_text[15]="SyncXXXX";
+#endif
 
 	irq_ptr = cdev->private->qdio_data;
 	if (!irq_ptr)
 		return -ENODEV;
 
+#ifdef CONFIG_QDIO_DEBUG
 	*((int*)(&dbf_text[4])) = irq_ptr->irq;
 	QDIO_DBF_HEX4(0,trace,dbf_text,QDIO_DBF_TRACE_LEN);
 	*((int*)(&dbf_text[0]))=flags;
 	*((int*)(&dbf_text[4]))=queue_number;
 	QDIO_DBF_HEX4(0,trace,dbf_text,QDIO_DBF_TRACE_LEN);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (flags&QDIO_FLAG_SYNC_INPUT) {
 		q=irq_ptr->input_qs[queue_number];
@@ -3083,11 +3125,12 @@ do_QDIO(struct ccw_device *cdev,unsigned
 	unsigned int count,struct qdio_buffer *buffers)
 {
 	struct qdio_irq *irq_ptr;
-
+#ifdef CONFIG_QDIO_DEBUG
 	char dbf_text[20];
 
 	sprintf(dbf_text,"doQD%04x",cdev->private->irq);
-	QDIO_DBF_TEXT3(0,trace,dbf_text);
+ 	QDIO_DBF_TEXT3(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if ( (qidx>QDIO_MAX_BUFFERS_PER_Q) ||
 	     (count>QDIO_MAX_BUFFERS_PER_Q) ||
@@ -3101,6 +3144,7 @@ do_QDIO(struct ccw_device *cdev,unsigned
 	if (!irq_ptr)
 		return -ENODEV;
 
+#ifdef CONFIG_QDIO_DEBUG
 	if (callflags&QDIO_FLAG_SYNC_INPUT)
 		QDIO_DBF_HEX3(0,trace,&irq_ptr->input_qs[queue_number],
 			      sizeof(void*));
@@ -3111,6 +3155,7 @@ do_QDIO(struct ccw_device *cdev,unsigned
 	QDIO_DBF_TEXT3(0,trace,dbf_text);
 	sprintf(dbf_text,"qi%02xct%02x",qidx,count);
 	QDIO_DBF_TEXT3(0,trace,dbf_text);
+#endif /* CONFIG_QDIO_DEBUG */
 
 	if (irq_ptr->state!=QDIO_IRQ_STATE_ACTIVE)
 		return -EBUSY;
@@ -3261,12 +3306,12 @@ qdio_unregister_dbf_views(void)
 		debug_unregister(qdio_dbf_sense);
 	if (qdio_dbf_trace)
 		debug_unregister(qdio_dbf_trace);
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
         if (qdio_dbf_slsb_out)
                 debug_unregister(qdio_dbf_slsb_out);
         if (qdio_dbf_slsb_in)
                 debug_unregister(qdio_dbf_slsb_in);
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 }
 
 static int
@@ -3311,7 +3356,7 @@ qdio_register_dbf_views(void)
 	debug_register_view(qdio_dbf_trace,&debug_hex_ascii_view);
 	debug_set_level(qdio_dbf_trace,QDIO_DBF_TRACE_LEVEL);
 
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
         qdio_dbf_slsb_out=debug_register(QDIO_DBF_SLSB_OUT_NAME,
                                          QDIO_DBF_SLSB_OUT_INDEX,
                                          QDIO_DBF_SLSB_OUT_NR_AREAS,
@@ -3329,7 +3374,7 @@ qdio_register_dbf_views(void)
 		goto oom;
         debug_register_view(qdio_dbf_slsb_in,&debug_hex_ascii_view);
         debug_set_level(qdio_dbf_slsb_in,QDIO_DBF_SLSB_IN_LEVEL);
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 	return 0;
 oom:
 	QDIO_PRINT_ERR("not enough memory for dbf.\n");
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/cio/qdio.h linux-2.6.8-rc3-bk3/drivers/s390/cio/qdio.h
--- linux-2.6.8-rc3-bk2/drivers/s390/cio/qdio.h	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/cio/qdio.h	2004-08-08 17:25:03.667151240 +0000
@@ -1,15 +1,13 @@
 #ifndef _CIO_QDIO_H
 #define _CIO_QDIO_H
 
-#define VERSION_CIO_QDIO_H "$Revision: 1.24 $"
+#define VERSION_CIO_QDIO_H "$Revision: 1.26 $"
 
-//#define QDIO_DBF_LIKE_HELL
-
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_VERBOSE_LEVEL 9
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_VERBOSE_LEVEL 5
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_USE_PROCESSING_STATE
 
@@ -103,75 +101,75 @@ enum qdio_irq_states {
 #define QDIO_DBF_HEX0(ex,name,addr,len) QDIO_DBF_HEX(ex,name,0,addr,len)
 #define QDIO_DBF_HEX1(ex,name,addr,len) QDIO_DBF_HEX(ex,name,1,addr,len)
 #define QDIO_DBF_HEX2(ex,name,addr,len) QDIO_DBF_HEX(ex,name,2,addr,len)
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_HEX3(ex,name,addr,len) QDIO_DBF_HEX(ex,name,3,addr,len)
 #define QDIO_DBF_HEX4(ex,name,addr,len) QDIO_DBF_HEX(ex,name,4,addr,len)
 #define QDIO_DBF_HEX5(ex,name,addr,len) QDIO_DBF_HEX(ex,name,5,addr,len)
 #define QDIO_DBF_HEX6(ex,name,addr,len) QDIO_DBF_HEX(ex,name,6,addr,len)
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_HEX3(ex,name,addr,len) do {} while (0)
 #define QDIO_DBF_HEX4(ex,name,addr,len) do {} while (0)
 #define QDIO_DBF_HEX5(ex,name,addr,len) do {} while (0)
 #define QDIO_DBF_HEX6(ex,name,addr,len) do {} while (0)
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_DBF_TEXT0(ex,name,text) QDIO_DBF_TEXT(ex,name,0,text)
 #define QDIO_DBF_TEXT1(ex,name,text) QDIO_DBF_TEXT(ex,name,1,text)
 #define QDIO_DBF_TEXT2(ex,name,text) QDIO_DBF_TEXT(ex,name,2,text)
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_TEXT3(ex,name,text) QDIO_DBF_TEXT(ex,name,3,text)
 #define QDIO_DBF_TEXT4(ex,name,text) QDIO_DBF_TEXT(ex,name,4,text)
 #define QDIO_DBF_TEXT5(ex,name,text) QDIO_DBF_TEXT(ex,name,5,text)
 #define QDIO_DBF_TEXT6(ex,name,text) QDIO_DBF_TEXT(ex,name,6,text)
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_TEXT3(ex,name,text) do {} while (0)
 #define QDIO_DBF_TEXT4(ex,name,text) do {} while (0)
 #define QDIO_DBF_TEXT5(ex,name,text) do {} while (0)
 #define QDIO_DBF_TEXT6(ex,name,text) do {} while (0)
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_DBF_SETUP_NAME "qdio_setup"
 #define QDIO_DBF_SETUP_LEN 8
 #define QDIO_DBF_SETUP_INDEX 2
 #define QDIO_DBF_SETUP_NR_AREAS 1
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_SETUP_LEVEL 6
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_SETUP_LEVEL 2
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_DBF_SBAL_NAME "qdio_labs" /* sbal */
 #define QDIO_DBF_SBAL_LEN 256
 #define QDIO_DBF_SBAL_INDEX 2
 #define QDIO_DBF_SBAL_NR_AREAS 2
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_SBAL_LEVEL 6
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_SBAL_LEVEL 2
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_DBF_TRACE_NAME "qdio_trace"
 #define QDIO_DBF_TRACE_LEN 8
 #define QDIO_DBF_TRACE_NR_AREAS 2
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_TRACE_INDEX 4
 #define QDIO_DBF_TRACE_LEVEL 4 /* -------- could be even more verbose here */
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_TRACE_INDEX 2
 #define QDIO_DBF_TRACE_LEVEL 2
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_DBF_SENSE_NAME "qdio_sense"
 #define QDIO_DBF_SENSE_LEN 64
 #define QDIO_DBF_SENSE_INDEX 1
 #define QDIO_DBF_SENSE_NR_AREAS 1
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_DBF_SENSE_LEVEL 6
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define QDIO_DBF_SENSE_LEVEL 2
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
-#ifdef QDIO_DBF_LIKE_HELL
+#ifdef CONFIG_QDIO_DEBUG
 #define QDIO_TRACE_QTYPE QDIO_ZFCP_QFMT
 
 #define QDIO_DBF_SLSB_OUT_NAME "qdio_slsb_out"
@@ -185,7 +183,7 @@ enum qdio_irq_states {
 #define QDIO_DBF_SLSB_IN_INDEX 8
 #define QDIO_DBF_SLSB_IN_NR_AREAS 1
 #define QDIO_DBF_SLSB_IN_LEVEL 6
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 #define QDIO_PRINTK_HEADER QDIO_NAME ": "
 
@@ -494,7 +492,7 @@ struct qdio_perf_stats {
 #define QDIO_GET_ADDR(x) ((__u32)(long)x)
 #endif /* CONFIG_ARCH_S390X */
 
-#ifdef QDIO_DBF_LIKE_HELL 
+#ifdef CONFIG_QDIO_DEBUG
 #define set_slsb(x,y) \
   if(q->queue_type==QDIO_TRACE_QTYPE) { \
         if(q->is_input_q) { \
@@ -511,9 +509,9 @@ struct qdio_perf_stats {
             QDIO_DBF_HEX2(0,slsb_out,&q->slsb,QDIO_MAX_BUFFERS_PER_Q); \
         } \
   }
-#else /* QDIO_DBF_LIKE_HELL */
+#else /* CONFIG_QDIO_DEBUG */
 #define set_slsb(x,y) qdio_set_slsb(x,y)
-#endif /* QDIO_DBF_LIKE_HELL */
+#endif /* CONFIG_QDIO_DEBUG */
 
 struct qdio_q {
 	volatile struct slsb slsb;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/ctcdbug.c linux-2.6.8-rc3-bk3/drivers/s390/net/ctcdbug.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/ctcdbug.c	2004-08-03 21:30:25.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/ctcdbug.c	2004-08-08 17:25:03.669150936 +0000
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/ctcdbug.c ($Revision: 1.2 $)
+ * linux/drivers/s390/net/ctcdbug.c ($Revision: 1.4 $)
  *
  * CTC / ESCON network driver - s390 dbf exploit.
  *
@@ -9,7 +9,7 @@
  *    Author(s): Original Code written by
  *			  Peter Tiedemann (ptiedem@de.ibm.com)
  *
- *    $Revision: 1.2 $	 $Date: 2004/07/15 16:03:08 $
+ *    $Revision: 1.4 $	 $Date: 2004/08/04 10:11:59 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,51 +31,51 @@
 /**
  * Debug Facility Stuff
  */
-debug_info_t *dbf_setup = NULL;
-debug_info_t *dbf_data = NULL;
-debug_info_t *dbf_trace = NULL;
+debug_info_t *ctc_dbf_setup = NULL;
+debug_info_t *ctc_dbf_data = NULL;
+debug_info_t *ctc_dbf_trace = NULL;
 
-DEFINE_PER_CPU(char[256], dbf_txt_buf);
+DEFINE_PER_CPU(char[256], ctc_dbf_txt_buf);
 
 void
-unregister_dbf_views(void)
+ctc_unregister_dbf_views(void)
 {
-	if (dbf_setup)
-		debug_unregister(dbf_setup);
-	if (dbf_data)
-		debug_unregister(dbf_data);
-	if (dbf_trace)
-		debug_unregister(dbf_trace);
+	if (ctc_dbf_setup)
+		debug_unregister(ctc_dbf_setup);
+	if (ctc_dbf_data)
+		debug_unregister(ctc_dbf_data);
+	if (ctc_dbf_trace)
+		debug_unregister(ctc_dbf_trace);
 }
 int
-register_dbf_views(void)
+ctc_register_dbf_views(void)
 {
-	dbf_setup = debug_register(CTC_DBF_SETUP_NAME,
+	ctc_dbf_setup = debug_register(CTC_DBF_SETUP_NAME,
 					CTC_DBF_SETUP_INDEX,
 					CTC_DBF_SETUP_NR_AREAS,
 					CTC_DBF_SETUP_LEN);
-	dbf_data = debug_register(CTC_DBF_DATA_NAME,
+	ctc_dbf_data = debug_register(CTC_DBF_DATA_NAME,
 				       CTC_DBF_DATA_INDEX,
 				       CTC_DBF_DATA_NR_AREAS,
 				       CTC_DBF_DATA_LEN);
-	dbf_trace = debug_register(CTC_DBF_TRACE_NAME,
+	ctc_dbf_trace = debug_register(CTC_DBF_TRACE_NAME,
 					CTC_DBF_TRACE_INDEX,
 					CTC_DBF_TRACE_NR_AREAS,
 					CTC_DBF_TRACE_LEN);
 
-	if ((dbf_setup == NULL) || (dbf_data == NULL) ||
-	    (dbf_trace == NULL)) {
-		unregister_dbf_views();
+	if ((ctc_dbf_setup == NULL) || (ctc_dbf_data == NULL) ||
+	    (ctc_dbf_trace == NULL)) {
+		ctc_unregister_dbf_views();
 		return -ENOMEM;
 	}
-	debug_register_view(dbf_setup, &debug_hex_ascii_view);
-	debug_set_level(dbf_setup, CTC_DBF_SETUP_LEVEL);
+	debug_register_view(ctc_dbf_setup, &debug_hex_ascii_view);
+	debug_set_level(ctc_dbf_setup, CTC_DBF_SETUP_LEVEL);
 
-	debug_register_view(dbf_data, &debug_hex_ascii_view);
-	debug_set_level(dbf_data, CTC_DBF_DATA_LEVEL);
+	debug_register_view(ctc_dbf_data, &debug_hex_ascii_view);
+	debug_set_level(ctc_dbf_data, CTC_DBF_DATA_LEVEL);
 
-	debug_register_view(dbf_trace, &debug_hex_ascii_view);
-	debug_set_level(dbf_trace, CTC_DBF_TRACE_LEVEL);
+	debug_register_view(ctc_dbf_trace, &debug_hex_ascii_view);
+	debug_set_level(ctc_dbf_trace, CTC_DBF_TRACE_LEVEL);
 
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/ctcdbug.h linux-2.6.8-rc3-bk3/drivers/s390/net/ctcdbug.h
--- linux-2.6.8-rc3-bk2/drivers/s390/net/ctcdbug.h	2004-08-03 21:30:24.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/ctcdbug.h	2004-08-08 17:25:03.670150784 +0000
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/ctcdbug.h ($Revision: 1.2 $)
+ * linux/drivers/s390/net/ctcdbug.h ($Revision: 1.3 $)
  *
  * CTC / ESCON network driver - s390 dbf exploit.
  *
@@ -9,7 +9,7 @@
  *    Author(s): Original Code written by
  *			  Peter Tiedemann (ptiedem@de.ibm.com)
  *
- *    $Revision: 1.2 $	 $Date: 2004/07/15 16:03:08 $
+ *    $Revision: 1.3 $	 $Date: 2004/07/28 12:27:54 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -51,38 +51,38 @@
 
 #define DBF_TEXT(name,level,text) \
 	do { \
-		debug_text_event(dbf_##name,level,text); \
+		debug_text_event(ctc_dbf_##name,level,text); \
 	} while (0)
 
 #define DBF_HEX(name,level,addr,len) \
 	do { \
-		debug_event(dbf_##name,level,(void*)(addr),len); \
+		debug_event(ctc_dbf_##name,level,(void*)(addr),len); \
 	} while (0)
 
-extern DEFINE_PER_CPU(char[256], dbf_txt_buf);
-extern debug_info_t *dbf_setup;
-extern debug_info_t *dbf_data;
-extern debug_info_t *dbf_trace;
+extern DEFINE_PER_CPU(char[256], ctc_dbf_txt_buf);
+extern debug_info_t *ctc_dbf_setup;
+extern debug_info_t *ctc_dbf_data;
+extern debug_info_t *ctc_dbf_trace;
 
 
 #define DBF_TEXT_(name,level,text...)				\
 	do {								\
-		char* dbf_txt_buf = get_cpu_var(dbf_txt_buf);	\
-		sprintf(dbf_txt_buf, text);			  	\
-		debug_text_event(dbf_##name,level,dbf_txt_buf);	\
-		put_cpu_var(dbf_txt_buf);				\
+		char* ctc_dbf_txt_buf = get_cpu_var(ctc_dbf_txt_buf);	\
+		sprintf(ctc_dbf_txt_buf, text);			  	\
+		debug_text_event(ctc_dbf_##name,level,ctc_dbf_txt_buf);	\
+		put_cpu_var(ctc_dbf_txt_buf);				\
 	} while (0)
 
 #define DBF_SPRINTF(name,level,text...) \
 	do { \
-		debug_sprintf_event(dbf_trace, level, ##text ); \
-		debug_sprintf_event(dbf_trace, level, text ); \
+		debug_sprintf_event(ctc_dbf_trace, level, ##text ); \
+		debug_sprintf_event(ctc_dbf_trace, level, text ); \
 	} while (0)
 
 
-int register_dbf_views(void);
+int ctc_register_dbf_views(void);
 
-void unregister_dbf_views(void);
+void ctc_unregister_dbf_views(void);
 
 /**
  * some more debug stuff
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/ctcmain.c linux-2.6.8-rc3-bk3/drivers/s390/net/ctcmain.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/ctcmain.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/ctcmain.c	2004-08-08 17:25:03.678149568 +0000
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.62 2004/07/15 16:03:08 ptiedem Exp $
+ * $Id: ctcmain.c,v 1.63 2004/07/28 12:27:54 ptiedem Exp $
  *
  * CTC / ESCON network driver
  *
@@ -36,7 +36,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.62 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.63 $
  *
  */
 
@@ -320,7 +320,7 @@ static void
 print_banner(void)
 {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.62 $";
+	char vbuf[] = "$Revision: 1.63 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -3250,7 +3250,7 @@ ctc_exit(void)
 {
 	unregister_cu3088_discipline(&ctc_group_driver);
 	ctc_tty_cleanup();
-	unregister_dbf_views();
+	ctc_unregister_dbf_views();
 	ctc_pr_info("CTC driver unloaded\n");
 }
 
@@ -3267,16 +3267,16 @@ ctc_init(void)
 
 	print_banner();
 
-	ret = register_dbf_views();
+	ret = ctc_register_dbf_views();
 	if (ret){
-		ctc_pr_crit("ctc_init failed with register_dbf_views rc = %d\n", ret);
+		ctc_pr_crit("ctc_init failed with ctc_register_dbf_views rc = %d\n", ret);
 		return ret;
 	}
 	ctc_tty_init();
 	ret = register_cu3088_discipline(&ctc_group_driver);
 	if (ret) {
 		ctc_tty_cleanup();
-		unregister_dbf_views();
+		ctc_unregister_dbf_views();
 	}
 	return ret;
 }
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/ctctty.c linux-2.6.8-rc3-bk3/drivers/s390/net/ctctty.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/ctctty.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/ctctty.c	2004-08-08 17:25:03.681149112 +0000
@@ -1,5 +1,5 @@
 /*
- * $Id: ctctty.c,v 1.24 2004/07/15 16:03:08 ptiedem Exp $
+ * $Id: ctctty.c,v 1.26 2004/08/04 11:06:55 mschwide Exp $
  *
  * CTC / ESCON network driver, tty interface.
  *
@@ -27,6 +27,7 @@
 #include <linux/tty.h>
 #include <linux/serial_reg.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
 #include <asm/uaccess.h>
 #include <linux/devfs_fs_kernel.h>
 #include "ctctty.h"
@@ -1053,9 +1054,8 @@ ctc_tty_close(struct tty_struct *tty, st
 		 */
 		timeout = jiffies + HZ;
 		while (!(info->lsr & UART_LSR_TEMT)) {
-			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock_irqrestore(&ctc_tty_lock, flags);
-			schedule_timeout(HZ/2);
+			msleep(500);
 			spin_lock_irqsave(&ctc_tty_lock, flags);
 			if (time_after(jiffies,timeout))
 				break;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/iucv.c linux-2.6.8-rc3-bk3/drivers/s390/net/iucv.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/iucv.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/iucv.c	2004-08-08 17:25:03.688148048 +0000
@@ -1,5 +1,5 @@
 /* 
- * $Id: iucv.c,v 1.39 2004/07/12 06:54:14 braunu Exp $
+ * $Id: iucv.c,v 1.40 2004/08/04 12:29:33 cborntra Exp $
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.39 $
+ * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.40 $
  *
  */
 
@@ -53,6 +53,7 @@
 #include <asm/io.h>
 #include <asm/s390_ext.h>
 #include <asm/ebcdic.h>
+#include <asm/smp.h>
 #include <asm/ccwdev.h> //for root device stuff
 
 /* FLAGS:
@@ -354,7 +355,7 @@ do { \
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.39 $";
+	char vbuf[] = "$Revision: 1.40 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/lcs.c linux-2.6.8-rc3-bk3/drivers/s390/net/lcs.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/lcs.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/lcs.c	2004-08-08 17:25:03.692147440 +0000
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision: 1.84 $	 $Date: 2004/07/14 07:23:15 $
+ *    $Revision: 1.85 $	 $Date: 2004/08/04 11:05:43 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,6 +37,7 @@
 #include <linux/inetdevice.h>
 #include <linux/in.h>
 #include <linux/igmp.h>
+#include <linux/delay.h>
 #include <net/arp.h>
 #include <net/ip.h>
 
@@ -58,7 +59,7 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision: 1.84 $"
+#define VERSION_LCS_C  "$Revision: 1.85 $"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
 static char debug_buffer[255];
@@ -1420,7 +1421,7 @@ lcs_resetcard(struct lcs_card *card)
 				   card->dev->name);
 			return 0;
 		}
-		msleep(30);
+		msleep(3000);
 	}
 	PRINT_ERR("Error in Reseting LCS card!\n");
 	return -EIO;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/qeth.h linux-2.6.8-rc3-bk3/drivers/s390/net/qeth.h
--- linux-2.6.8-rc3-bk2/drivers/s390/net/qeth.h	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/qeth.h	2004-08-08 17:25:03.696146832 +0000
@@ -23,7 +23,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.111 $"
+#define VERSION_QETH_H 		"$Revision: 1.113 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -150,6 +150,8 @@ qeth_hex_dump(unsigned char *buf, size_t
 #define SENSE_RESETTING_EVENT_BYTE 1
 #define SENSE_RESETTING_EVENT_FLAG 0x80
 
+#define atomic_swap(a,b) xchg((int *)a.counter, b)
+
 /*
  * Common IO related definitions
  */
@@ -425,12 +427,18 @@ struct qeth_qdio_out_buffer {
 
 struct qeth_card;
 
+enum qeth_out_q_states {
+       QETH_OUT_Q_UNLOCKED,
+       QETH_OUT_Q_LOCKED,
+       QETH_OUT_Q_LOCKED_FLUSH,
+};
+
 struct qeth_qdio_out_q {
 	struct qdio_buffer qdio_bufs[QDIO_MAX_BUFFERS_PER_Q];
 	struct qeth_qdio_out_buffer bufs[QDIO_MAX_BUFFERS_PER_Q];
 	int queue_no;
 	struct qeth_card *card;
-	spinlock_t lock;
+	atomic_t state;
 	volatile int do_pack;
 	/*
 	 * index of buffer to be filled by driver; state EMPTY or PACKING
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/net/qeth_main.c linux-2.6.8-rc3-bk3/drivers/s390/net/qeth_main.c
--- linux-2.6.8-rc3-bk2/drivers/s390/net/qeth_main.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/net/qeth_main.c	2004-08-08 17:25:03.715143944 +0000
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.127 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.130 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.127 $	 $Date: 2004/07/14 21:46:40 $
+ *    $Revision: 1.130 $	 $Date: 2004/08/05 11:21:50 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -78,7 +78,7 @@ qeth_eyecatcher(void)
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-#define VERSION_QETH_C "$Revision: 1.127 $"
+#define VERSION_QETH_C "$Revision: 1.130 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -1801,7 +1801,7 @@ qeth_send_control_data(struct qeth_card 
 	}
 	add_timer(&timer);
 	wait_event(reply->wait_q, reply->received);
-	del_timer(&timer);
+	del_timer_sync(&timer);
 	rc = reply->rc;
 	qeth_put_reply(reply);
 	return rc;
@@ -2105,7 +2105,7 @@ qeth_get_next_skb(struct qeth_card *card
 				QETH_DBF_TEXT(qerr,2,"unexeob");
 				QETH_DBF_TEXT_(qerr,2,"%s",CARD_BUS_ID(card));
 				QETH_DBF_HEX(misc,4,buffer,sizeof(*buffer));
-				dev_kfree_skb_irq(skb);
+				dev_kfree_skb_any(skb);
 				card->stats.rx_errors++;
 				return NULL;
 			}
@@ -2297,7 +2297,7 @@ qeth_process_inbound_buffer(struct qeth_
 		qeth_rebuild_skb(card, skb, hdr);
 		/* is device UP ? */
 		if (!(card->dev->flags & IFF_UP)){
-			dev_kfree_skb_irq(skb);
+			dev_kfree_skb_any(skb);
 			continue;
 		}
 		skb->dev = card->dev;
@@ -2311,16 +2311,16 @@ qeth_process_inbound_buffer(struct qeth_
 static inline struct qeth_buffer_pool_entry *
 qeth_get_buffer_pool_entry(struct qeth_card *card)
 {
-	struct qeth_buffer_pool_entry *entry, *tmp;
+	struct qeth_buffer_pool_entry *entry;
 
 	QETH_DBF_TEXT(trace, 6, "gtbfplen");
-	entry = NULL;
-	list_for_each_entry_safe(entry, tmp,
-				 &card->qdio.in_buf_pool.entry_list, list){
+	if (!list_empty(&card->qdio.in_buf_pool.entry_list)) {
+		entry = list_entry(card->qdio.in_buf_pool.entry_list.next,
+				struct qeth_buffer_pool_entry, list);
 		list_del_init(&entry->list);
-		break;
+		return entry;
 	}
-	return entry;
+	return NULL;
 }
 
 static inline void
@@ -2367,7 +2367,7 @@ qeth_clear_output_buffer(struct qeth_qdi
 		buf->buffer->element[i].flags = 0;
 		while ((skb = skb_dequeue(&buf->skb_list))){
 			atomic_dec(&skb->users);
-			dev_kfree_skb_irq(skb);
+			dev_kfree_skb_any(skb);
 		}
 	}
 	buf->next_element_to_fill = 0;
@@ -2588,14 +2588,9 @@ qeth_flush_buffers(struct qeth_qdio_out_
 		QETH_DBF_TEXT(trace, 2, "flushbuf");
 		QETH_DBF_TEXT_(trace, 2, " err%d", rc);
 		queue->card->stats.tx_errors += count;
-		/* ok, since do_QDIO went wrong the buffers have not been given
-		 * to the hardware. they still belong to us, so we can clear
-		 * them and reuse then, i.e. set back next_buf_to_fill*/
-		for (i = index; i < index + count; ++i) {
-			buf = &queue->bufs[i % QDIO_MAX_BUFFERS_PER_Q];
-			qeth_clear_output_buffer(queue, buf);
-		}
-		queue->next_buf_to_fill = index;
+		/* this must not happen under normal circumstances. if it
+		 * happens something is really wrong -> recover */
+		qeth_schedule_recovery(queue->card);
 		return;
 	}
 	atomic_add(count, &queue->used_buffers);
@@ -2605,16 +2600,12 @@ qeth_flush_buffers(struct qeth_qdio_out_
 }
 
 /*
- * switches between PACKING and non-PACKING state if needed.
- * has to be called holding queue->lock
+ * Switched to packing state if the number of used buffers on a queue
+ * reaches a certain limit.
  */
-static inline int
-qeth_switch_packing_state(struct qeth_qdio_out_q *queue)
+static inline void
+qeth_switch_to_packing_if_needed(struct qeth_qdio_out_q *queue)
 {
-	struct qeth_qdio_out_buffer *buffer;
-	int flush_count = 0;
-
-	QETH_DBF_TEXT(trace, 6, "swipack");
 	if (!queue->do_pack) {
 		if (atomic_read(&queue->used_buffers)
 		    >= QETH_HIGH_WATERMARK_PACK){
@@ -2625,7 +2616,22 @@ qeth_switch_packing_state(struct qeth_qd
 #endif
 			queue->do_pack = 1;
 		}
-	} else {
+	}
+}
+
+/*
+ * Switches from packing to non-packing mode. If there is a packing
+ * buffer on the queue this buffer will be prepared to be flushed.
+ * In that case 1 is returned to inform the caller. If no buffer
+ * has to be flushed, zero is returned.
+ */
+static inline int
+qeth_switch_to_nonpacking_if_needed(struct qeth_qdio_out_q *queue)
+{
+	struct qeth_qdio_out_buffer *buffer;
+	int flush_count = 0;
+
+	if (queue->do_pack) {
 		if (atomic_read(&queue->used_buffers)
 		    <= QETH_LOW_WATERMARK_PACK) {
 			/* switch PACKING -> non-PACKING */
@@ -2650,21 +2656,62 @@ qeth_switch_packing_state(struct qeth_qd
 	return flush_count;
 }
 
-static inline void
-qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue, int under_int)
+/*
+ * Called to flush a packing buffer if no more pci flags are on the queue.
+ * Checks if there is a packing buffer and prepares it to be flushed.
+ * In that case returns 1, otherwise zero.
+ */
+static inline int
+qeth_flush_buffers_on_no_pci(struct qeth_qdio_out_q *queue)
 {
 	struct qeth_qdio_out_buffer *buffer;
-	int index;
 
-	index = queue->next_buf_to_fill;
-	buffer = &queue->bufs[index];
+	buffer = &queue->bufs[queue->next_buf_to_fill];
 	if((atomic_read(&buffer->state) == QETH_QDIO_BUF_EMPTY) &&
 	   (buffer->next_element_to_fill > 0)){
 		/* it's a packing buffer */
 		atomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);
 		queue->next_buf_to_fill =
 			(queue->next_buf_to_fill + 1) % QDIO_MAX_BUFFERS_PER_Q;
-		qeth_flush_buffers(queue, under_int, index, 1);
+		return 1;
+	}
+	return 0;
+}
+
+static inline void
+qeth_check_outbound_queue(struct qeth_qdio_out_q *queue)
+{
+	int index;
+	int flush_cnt = 0;
+
+	/*
+	 * check if weed have to switch to non-packing mode or if
+	 * we have to get a pci flag out on the queue
+	 */
+	if ((atomic_read(&queue->used_buffers) <= QETH_LOW_WATERMARK_PACK) ||
+	    !atomic_read(&queue->set_pci_flags_count)){
+		if (atomic_swap(&queue->state, QETH_OUT_Q_LOCKED_FLUSH) ==
+				QETH_OUT_Q_UNLOCKED) {
+			/*
+			 * If we get in here, there was no action in
+			 * do_send_packet. So, we check if there is a
+			 * packing buffer to be flushed here.
+			 */
+			/* TODO: try if we get a performance improvement
+			 * by calling netif_stop_queue here */
+			/* save start index for flushing */
+			index = queue->next_buf_to_fill;
+			flush_cnt += qeth_switch_to_nonpacking_if_needed(queue);
+			if (!flush_cnt &&
+			    !atomic_read(&queue->set_pci_flags_count))
+				flush_cnt +=
+					qeth_flush_buffers_on_no_pci(queue);
+			/* were done with updating critical queue members */
+			atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
+			/* flushing can be done outside the lock */
+			if (flush_cnt)
+				qeth_flush_buffers(queue, 1, index, flush_cnt);
+		}
 	}
 }
 
@@ -2710,6 +2757,8 @@ qeth_qdio_output_handler(struct ccw_devi
 		qeth_clear_output_buffer(queue, buffer);
 	}
 	atomic_sub(count, &queue->used_buffers);
+	/* check if we need to do something on this outbound queue */
+	qeth_check_outbound_queue(queue);
 
 	netif_wake_queue(card->dev);
 #ifdef CONFIG_QETH_PERF_STATS
@@ -2981,7 +3030,8 @@ qeth_init_qdio_queues(struct qeth_card *
 		card->qdio.out_qs[i]->do_pack = 0;
 		atomic_set(&card->qdio.out_qs[i]->used_buffers,0);
 		atomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);
-		spin_lock_init(&card->qdio.out_qs[i]->lock);
+		atomic_set(&card->qdio.out_qs[i]->state,
+			   QETH_OUT_Q_UNLOCKED);
 	}
 	return 0;
 }
@@ -3295,12 +3345,12 @@ qeth_hard_start_xmit(struct sk_buff *skb
 	card->perf_stats.outbound_start_time = qeth_get_micros();
 #endif
 	/*
-	 * dev_queue_xmit should ensure that we are called packet
-	 * after packet
+	 * We only call netif_stop_queue in case of errors. Since we've
+	 * got our own synchronization on queues we can keep the stack's
+	 * queue running.
 	 */
-	netif_stop_queue(dev);
-	if (!(rc = qeth_send_packet(card, skb)))
-		netif_wake_queue(dev);
+	if ((rc = qeth_send_packet(card, skb)))
+		netif_stop_queue(dev);
 
 #ifdef CONFIG_QETH_PERF_STATS
 	card->perf_stats.outbound_time += qeth_get_micros() -
@@ -3714,7 +3764,11 @@ qeth_do_send_packet_fast(struct qeth_car
 
 	QETH_DBF_TEXT(trace, 6, "dosndpfa");
 
-	spin_lock(&queue->lock);
+	/* spin until we get the queue ... */
+	while (atomic_compare_and_swap(QETH_OUT_Q_UNLOCKED,
+				       QETH_OUT_Q_LOCKED,
+				       &queue->state));
+	/* ... now we've got the queue */
 	index = queue->next_buf_to_fill;
 	buffer = &queue->bufs[queue->next_buf_to_fill];
 	/*
@@ -3723,14 +3777,14 @@ qeth_do_send_packet_fast(struct qeth_car
 	 */
 	if (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY) {
 		card->stats.tx_dropped++;
-		spin_unlock(&queue->lock);
+		atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 		return -EBUSY;
 	}
 	queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
 				  QDIO_MAX_BUFFERS_PER_Q;
+	atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 	qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
 	qeth_flush_buffers(queue, 0, index, 1);
-	spin_unlock(&queue->lock);
 	return 0;
 }
 
@@ -3746,7 +3800,10 @@ qeth_do_send_packet(struct qeth_card *ca
 
 	QETH_DBF_TEXT(trace, 6, "dosndpkt");
 
-	spin_lock(&queue->lock);
+	/* spin until we get the queue ... */
+	while (atomic_compare_and_swap(QETH_OUT_Q_UNLOCKED,
+				       QETH_OUT_Q_LOCKED,
+				       &queue->state));
 	start_index = queue->next_buf_to_fill;
 	buffer = &queue->bufs[queue->next_buf_to_fill];
 	/*
@@ -3755,9 +3812,11 @@ qeth_do_send_packet(struct qeth_card *ca
 	 */
 	if (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY){
 		card->stats.tx_dropped++;
-		spin_unlock(&queue->lock);
+		atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 		return -EBUSY;
 	}
+	/* check if we need to switch packing state of this queue */
+	qeth_switch_to_packing_if_needed(queue);
 	if (queue->do_pack){
 		/* does packet fit in current buffer? */
 		if((QETH_MAX_BUFFER_ELEMENTS(card) -
@@ -3772,11 +3831,10 @@ qeth_do_send_packet(struct qeth_card *ca
 			/* we did a step forward, so check buffer state again */
 			if (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY){
 				card->stats.tx_dropped++;
-				qeth_flush_buffers(queue, 0, start_index, 1);
-				spin_unlock(&queue->lock);
 				/* return EBUSY because we sent old packet, not
 				 * the current one */
-				return -EBUSY;
+				rc = -EBUSY;
+				goto out;
 			}
 		}
 	}
@@ -3787,16 +3845,27 @@ qeth_do_send_packet(struct qeth_card *ca
 		queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
 			QDIO_MAX_BUFFERS_PER_Q;
 	}
-	/* check if we need to switch packing state of this queue */
-	flush_count += qeth_switch_packing_state(queue);
-
+	/*
+	 * queue->state will go from LOCKED -> UNLOCKED or from
+	 * LOCKED_FLUSH -> LOCKED if output_handler wanted to 'notify' us
+	 * (switch packing state or flush buffer to get another pci flag out).
+	 * In that case we will enter this loop
+	 */
+	while (atomic_dec_return(&queue->state)){
+		/* check if we can go back to non-packing state */
+		flush_count += qeth_switch_to_nonpacking_if_needed(queue);
+		/*
+		 * check if we need to flush a packing buffer to get a pci
+		 * flag out on the queue
+		 */
+		if (!flush_count && !atomic_read(&queue->set_pci_flags_count))
+			flush_count += qeth_flush_buffers_on_no_pci(queue);
+	}
+	/* at this point the queue is UNLOCKED again */
+out:
 	if (flush_count)
 		qeth_flush_buffers(queue, 0, start_index, flush_count);
 
-	if (!atomic_read(&queue->set_pci_flags_count))
-		qeth_flush_buffers_on_no_pci(queue, 0);
-
-	spin_unlock(&queue->lock);
 	return rc;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_aux.c linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_aux.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_aux.c	2004-08-08 17:25:03.721143032 +0000
@@ -29,7 +29,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_AUX_REVISION "$Revision: 1.114 $"
+#define ZFCP_AUX_REVISION "$Revision: 1.115 $"
 
 #include "zfcp_ext.h"
 
@@ -41,8 +41,6 @@ static char *device;
 /* written against the module interface */
 static int __init  zfcp_module_init(void);
 
-int zfcp_reboot_handler(struct notifier_block *, unsigned long, void *);
-
 /* FCP related */
 static void zfcp_ns_gid_pn_handler(unsigned long);
 
@@ -338,9 +336,6 @@ zfcp_module_init(void)
 	/* initialise configuration rw lock */
 	rwlock_init(&zfcp_data.config_lock);
 
-	zfcp_data.reboot_notifier.notifier_call = zfcp_reboot_handler;
-	register_reboot_notifier(&zfcp_data.reboot_notifier);
-
 	/* save address of data structure managing the driver module */
 	zfcp_data.scsi_host_template.module = THIS_MODULE;
 
@@ -357,7 +352,6 @@ zfcp_module_init(void)
 	goto out;
 
  out_ccw_register:
-	unregister_reboot_notifier(&zfcp_data.reboot_notifier);
 	misc_deregister(&zfcp_cfdc_misc);
  out_misc_register:
 #ifdef CONFIG_S390_SUPPORT
@@ -370,23 +364,6 @@ zfcp_module_init(void)
 }
 
 /*
- * This function is called automatically by the kernel whenever a reboot or a 
- * shut-down is initiated and zfcp is still loaded
- *
- * locks:       zfcp_data.config_sema is taken prior to shutting down the module
- *              and removing all structures
- * returns:     NOTIFY_DONE in all cases
- */
-int
-zfcp_reboot_handler(struct notifier_block *notifier, unsigned long code,
-		    void *ptr)
-{
-	zfcp_ccw_unregister();
-	return NOTIFY_DONE;
-}
-
-
-/*
  * function:    zfcp_cfdc_dev_ioctl
  *
  * purpose:     Handle control file upload/download transaction via IOCTL
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_ccw.c linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_ccw.c
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_ccw.c	2004-06-16 05:19:02.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_ccw.c	2004-08-08 17:25:03.724142576 +0000
@@ -26,7 +26,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_CCW_C_REVISION "$Revision: 1.55 $"
+#define ZFCP_CCW_C_REVISION "$Revision: 1.56 $"
 
 #include "zfcp_ext.h"
 
@@ -37,6 +37,7 @@ static void zfcp_ccw_remove(struct ccw_d
 static int zfcp_ccw_set_online(struct ccw_device *);
 static int zfcp_ccw_set_offline(struct ccw_device *);
 static int zfcp_ccw_notify(struct ccw_device *, int);
+static void zfcp_ccw_shutdown(struct device *);
 
 static struct ccw_device_id zfcp_ccw_device_id[] = {
 	{CCW_DEVICE_DEVTYPE(ZFCP_CONTROL_UNIT_TYPE,
@@ -59,6 +60,9 @@ static struct ccw_driver zfcp_ccw_driver
 	.set_online  = zfcp_ccw_set_online,
 	.set_offline = zfcp_ccw_set_offline,
 	.notify      = zfcp_ccw_notify,
+	.driver      = {
+		.shutdown = zfcp_ccw_shutdown,
+	},
 };
 
 MODULE_DEVICE_TABLE(ccw, zfcp_ccw_device_id);
@@ -287,4 +291,19 @@ zfcp_ccw_unregister(void)
 	ccw_driver_unregister(&zfcp_ccw_driver);
 }
 
+/**
+ * zfcp_ccw_shutdown - gets called on reboot/shutdown
+ *
+ * Makes sure that QDIO queues are down when the system gets stopped.
+ */
+static void
+zfcp_ccw_shutdown(struct device *dev)
+{
+	struct zfcp_adapter *adapter;
+
+	adapter = dev_get_drvdata(dev);
+	zfcp_erp_adapter_shutdown(adapter, 0);
+	zfcp_erp_wait(adapter);
+}
+
 #undef ZFCP_LOG_AREA
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_def.h linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_def.h	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_def.h	2004-08-08 17:25:03.727142120 +0000
@@ -33,7 +33,7 @@
 #define ZFCP_DEF_H
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_DEF_REVISION "$Revision: 1.78 $"
+#define ZFCP_DEF_REVISION "$Revision: 1.81 $"
 
 /*************************** INCLUDES *****************************************/
 
@@ -42,6 +42,7 @@
 #include <linux/miscdevice.h>
 #include <linux/major.h>
 #include <linux/blkdev.h>
+#include <linux/delay.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_cmnd.h>
@@ -55,7 +56,6 @@
 #include <asm/qdio.h>
 #include <asm/debug.h>
 #include <asm/ebcdic.h>
-#include <linux/reboot.h>
 #include <linux/mempool.h>
 #include <linux/syscalls.h>
 #include <linux/ioctl.h>
@@ -70,7 +70,7 @@
 /********************* GENERAL DEFINES *********************************/
 
 /* zfcp version number, it consists of major, minor, and patch-level number */
-#define ZFCP_VERSION		"4.0.0"
+#define ZFCP_VERSION		"4.1.3"
 
 static inline void *
 zfcp_sg_to_address(struct scatterlist *list)
@@ -1074,8 +1074,6 @@ struct zfcp_data {
 						       lists */
 	struct semaphore        config_sema;        /* serialises configuration
 						       changes */
-	struct notifier_block	reboot_notifier;     /* used to register cleanup
-							functions */
 	atomic_t		loglevel;            /* current loglevel */
 	char                    init_busid[BUS_ID_SIZE];
 	wwn_t                   init_wwpn;
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_erp.c linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_erp.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_erp.c	2004-08-08 17:25:03.736140752 +0000
@@ -31,7 +31,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_ERP
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_ERP_REVISION "$Revision: 1.60 $"
+#define ZFCP_ERP_REVISION "$Revision: 1.61 $"
 
 #include "zfcp_ext.h"
 
@@ -2170,7 +2170,6 @@ static int
 zfcp_erp_adapter_strategy(struct zfcp_erp_action *erp_action)
 {
 	int retval;
-	unsigned long timeout;
 	struct zfcp_adapter *adapter = erp_action->adapter;
 
 	retval = zfcp_erp_adapter_strategy_close(erp_action);
@@ -2187,9 +2186,7 @@ zfcp_erp_adapter_strategy(struct zfcp_er
 		ZFCP_LOG_INFO("Waiting to allow the adapter %s "
 			      "to recover itself\n",
 			      zfcp_get_busid_by_adapter(adapter));
-		timeout = ZFCP_TYPE2_RECOVERY_TIME;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(timeout);
+		msleep(jiffies_to_msecs(ZFCP_TYPE2_RECOVERY_TIME));
 	}
 
 	return retval;
@@ -2365,10 +2362,8 @@ zfcp_erp_adapter_strategy_open_qdio(stru
  failed_qdio_activate:
 	debug_text_event(adapter->erp_dbf, 3, "qdio_down1a");
 	while (qdio_shutdown(adapter->ccw_device,
-			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ);
-	}
+			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS)
+		msleep(1000);
 	debug_text_event(adapter->erp_dbf, 3, "qdio_down1b");
 
  failed_qdio_establish:
@@ -2414,10 +2409,8 @@ zfcp_erp_adapter_strategy_close_qdio(str
 
 	debug_text_event(adapter->erp_dbf, 3, "qdio_down2a");
 	while (qdio_shutdown(adapter->ccw_device,
-			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS) {
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ);
-	}
+			     QDIO_FLAG_CLEANUP_USING_CLEAR) == -EINPROGRESS)
+		msleep(1000);
 	debug_text_event(adapter->erp_dbf, 3, "qdio_down2b");
 
 	/*
@@ -2528,8 +2521,7 @@ zfcp_erp_adapter_strategy_open_fsf_xconf
 			ZFCP_LOG_DEBUG("host connection still initialising... "
 				       "waiting and retrying...\n");
 			/* sleep a little bit before retry */
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(ZFCP_EXCHANGE_CONFIG_DATA_SLEEP);
+			msleep(jiffies_to_msecs(ZFCP_EXCHANGE_CONFIG_DATA_SLEEP));
 		}
 	} while ((retries--) &&
 		 atomic_test_mask(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_fsf.c linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_fsf.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_fsf.c	2004-08-08 17:25:03.748138928 +0000
@@ -29,7 +29,7 @@
  */
 
 /* this drivers version (do not edit !!! generated and updated by cvs) */
-#define ZFCP_FSF_C_REVISION "$Revision: 1.53 $"
+#define ZFCP_FSF_C_REVISION "$Revision: 1.55 $"
 
 #include "zfcp_ext.h"
 
@@ -180,8 +180,7 @@ zfcp_fsf_req_dismiss_all(struct zfcp_ada
 		ZFCP_LOG_DEBUG("fsf req list of adapter %s not yet empty\n",
 			       zfcp_get_busid_by_adapter(adapter));
 		/* wait for woken intiators to clean up their requests */
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(ZFCP_FSFREQ_CLEANUP_TIMEOUT);
+		msleep(jiffies_to_msecs(ZFCP_FSFREQ_CLEANUP_TIMEOUT));
 	}
 
 	/* consistency check */
@@ -2620,6 +2619,7 @@ zfcp_fsf_close_physical_port(struct zfcp
 {
 	int retval = 0;
 	unsigned long lock_flags;
+	volatile struct qdio_buffer_element *sbale;
 
 	/* setup new FSF request */
 	retval = zfcp_fsf_req_create(erp_action->adapter,
@@ -2636,6 +2636,11 @@ zfcp_fsf_close_physical_port(struct zfcp
 		goto out;
 	}
 
+	sbale = zfcp_qdio_sbale_req(erp_action->fsf_req,
+				    erp_action->fsf_req->sbal_curr, 0);
+	sbale[0].flags |= SBAL_FLAGS0_TYPE_READ;
+	sbale[1].flags |= SBAL_FLAGS_LAST_ENTRY;
+
 	/* mark port as being closed */
 	atomic_set_mask(ZFCP_STATUS_PORT_PHYS_CLOSING,
 			&erp_action->port->status);
diff -p -purN linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_sysfs_port.c linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_sysfs_port.c
--- linux-2.6.8-rc3-bk2/drivers/s390/scsi/zfcp_sysfs_port.c	2004-06-16 05:20:04.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/s390/scsi/zfcp_sysfs_port.c	2004-08-08 17:25:03.750138624 +0000
@@ -26,7 +26,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#define ZFCP_SYSFS_PORT_C_REVISION "$Revision: 1.40 $"
+#define ZFCP_SYSFS_PORT_C_REVISION "$Revision: 1.41 $"
 
 #include "zfcp_ext.h"
 
@@ -125,7 +125,7 @@ zfcp_sysfs_unit_remove_store(struct devi
 	struct zfcp_unit *unit;
 	fcp_lun_t fcp_lun;
 	char *endp;
-	int retval = -EINVAL;
+	int retval = 0;
 
 	down(&zfcp_data.config_sema);
 
@@ -136,8 +136,10 @@ zfcp_sysfs_unit_remove_store(struct devi
 	}
 
 	fcp_lun = simple_strtoull(buf, &endp, 0);
-	if ((endp + 1) < (buf + count))
+	if ((endp + 1) < (buf + count)) {
+		retval = -EINVAL;
 		goto out;
+	}
 
 	write_lock_irq(&zfcp_data.config_lock);
 	unit = zfcp_get_unit_by_lun(port, fcp_lun);
diff -p -purN linux-2.6.8-rc3-bk2/drivers/sbus/dvma.c linux-2.6.8-rc3-bk3/drivers/sbus/dvma.c
--- linux-2.6.8-rc3-bk2/drivers/sbus/dvma.c	2004-08-08 17:21:29.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/sbus/dvma.c	2004-08-08 17:25:03.752138320 +0000
@@ -121,7 +121,6 @@ void __init dvma_init(struct sbus_bus *s
 void __init sun4_dvma_init(void)
 {
 	struct sbus_dma *dma;
-	struct sbus_dma *dchain;
 	struct resource r;
 
 	if(sun4_dma_physaddr) {
diff -p -purN linux-2.6.8-rc3-bk2/drivers/scsi/sg.c linux-2.6.8-rc3-bk3/drivers/scsi/sg.c
--- linux-2.6.8-rc3-bk2/drivers/scsi/sg.c	2004-08-08 17:21:32.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/scsi/sg.c	2004-08-08 17:25:03.760137104 +0000
@@ -234,6 +234,7 @@ sg_open(struct inode *inode, struct file
 	int res;
 	int retval;
 
+	nonseekable_open(inode, filp);
 	SCSI_LOG_TIMEOUT(3, printk("sg_open: dev=%d, flags=0x%x\n", dev, flags));
 	sdp = sg_get_dev(dev);
 	if ((!sdp) || (!sdp->device))
@@ -343,7 +344,6 @@ sg_read(struct file *filp, char __user *
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, printk("sg_read: %s, count=%d\n",
 				   sdp->disk->disk_name, (int) count));
-	if (ppos != &filp->f_pos) ;	/* FIXME: Hmm.  Seek to the right place, or fail?  */
 	if ((k = verify_area(VERIFY_WRITE, buf, count)))
 		return k;
 	if (sfp->force_packid && (count >= SZ_SG_HEADER)) {
@@ -501,7 +501,6 @@ sg_write(struct file *filp, const char _
 	if (!((filp->f_flags & O_NONBLOCK) ||
 	      scsi_block_when_processing_errors(sdp->device)))
 		return -ENXIO;
-	if (ppos != &filp->f_pos) ;	/* FIXME: Hmm.  Seek to the right place, or fail?  */
 
 	if ((k = verify_area(VERIFY_READ, buf, count)))
 		return k;	/* protects following copy_from_user()s + get_user()s */
diff -p -purN linux-2.6.8-rc3-bk2/drivers/scsi/st.c linux-2.6.8-rc3-bk3/drivers/scsi/st.c
--- linux-2.6.8-rc3-bk2/drivers/scsi/st.c	2004-08-08 17:21:32.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/scsi/st.c	2004-08-08 17:25:03.771135432 +0000
@@ -1001,6 +1001,7 @@ static int st_open(struct inode *inode, 
 	int dev = TAPE_NR(inode);
 	char *name;
 
+	nonseekable_open(inode, filp);
 	write_lock(&st_dev_arr_lock);
 	if (dev >= st_dev_max || scsi_tapes == NULL ||
 	    ((STp = scsi_tapes[dev]) == NULL)) {
@@ -1203,7 +1204,7 @@ static int st_release(struct inode *inod
 }
 
 /* The checks common to both reading and writing */
-static ssize_t rw_checks(Scsi_Tape *STp, struct file *filp, size_t count, loff_t *ppos)
+static ssize_t rw_checks(Scsi_Tape *STp, struct file *filp, size_t count)
 {
 	ssize_t retval = 0;
 
@@ -1218,12 +1219,6 @@ static ssize_t rw_checks(Scsi_Tape *STp,
 		goto out;
 	}
 
-	if (ppos != &filp->f_pos) {
-		/* "A request was outside the capabilities of the device." */
-		retval = (-ENXIO);
-		goto out;
-	}
-
 	if (STp->ready != ST_READY) {
 		if (STp->ready == ST_NO_TAPE)
 			retval = (-ENOMEDIUM);
@@ -1367,7 +1362,7 @@ st_write(struct file *filp, const char _
 	if (down_interruptible(&STp->lock))
 		return -ERESTARTSYS;
 
-	retval = rw_checks(STp, filp, count, ppos);
+	retval = rw_checks(STp, filp, count);
 	if (retval || count == 0)
 		goto out;
 
@@ -1833,7 +1828,7 @@ st_read(struct file *filp, char __user *
 	if (down_interruptible(&STp->lock))
 		return -ERESTARTSYS;
 
-	retval = rw_checks(STp, filp, count, ppos);
+	retval = rw_checks(STp, filp, count);
 	if (retval || count == 0)
 		goto out;
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/serial/8250_pci.c linux-2.6.8-rc3-bk3/drivers/serial/8250_pci.c
--- linux-2.6.8-rc3-bk2/drivers/serial/8250_pci.c	2004-08-08 17:21:33.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/serial/8250_pci.c	2004-08-08 17:25:03.776134672 +0000
@@ -574,8 +574,7 @@ titan_400l_800l_setup(struct pci_dev *de
 
 static int __devinit pci_xircom_init(struct pci_dev *dev)
 {
-	__set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(HZ/10);
+	msleep(100);
 	return 0;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/drivers/video/sa1100fb.c linux-2.6.8-rc3-bk3/drivers/video/sa1100fb.c
--- linux-2.6.8-rc3-bk2/drivers/video/sa1100fb.c	2004-08-08 17:21:34.000000000 +0000
+++ linux-2.6.8-rc3-bk3/drivers/video/sa1100fb.c	2004-08-08 17:25:03.783133608 +0000
@@ -1291,8 +1291,7 @@ static void sa1100fb_enable_controller(s
 #error Where is GPIO24 set as an output?  Can we fit this in somewhere else?
 	if (machine_is_graphicsclient()) {
 		// From ADS doc again...same as disable
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(20 * HZ / 1000);
+		msleep(20);
 		GPSR |= GPIO_GPIO24;
 	}
 #endif
@@ -1327,8 +1326,7 @@ static void sa1100fb_disable_controller(
 		 * We'll wait 20msec.
 		 */
 		GPCR |= GPIO_GPIO24;
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(20 * HZ / 1000);
+		msleep(20);
 	}
 #endif
 #ifdef CONFIG_SA1100_HUW_WEBPANEL
diff -p -purN linux-2.6.8-rc3-bk2/fs/coda/sysctl.c linux-2.6.8-rc3-bk3/fs/coda/sysctl.c
--- linux-2.6.8-rc3-bk2/fs/coda/sysctl.c	2004-08-08 17:21:35.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/coda/sysctl.c	2004-08-08 17:25:03.790132544 +0000
@@ -69,12 +69,12 @@ void reset_coda_cache_inv_stats( void )
 }
 
 int do_reset_coda_vfs_stats( ctl_table * table, int write, struct file * filp,
-			     void __user * buffer, size_t * lenp )
+			     void __user * buffer, size_t * lenp, loff_t * ppos )
 {
 	if ( write ) {
 		reset_coda_vfs_stats();
 
-		filp->f_pos += *lenp;
+		*ppos += *lenp;
 	} else {
 		*lenp = 0;
 	}
@@ -84,12 +84,12 @@ int do_reset_coda_vfs_stats( ctl_table *
 
 int do_reset_coda_cache_inv_stats( ctl_table * table, int write, 
 				   struct file * filp, void __user * buffer, 
-				   size_t * lenp )
+				   size_t * lenp, loff_t * ppos )
 {
 	if ( write ) {
 		reset_coda_cache_inv_stats();
 
-		filp->f_pos += *lenp;
+		*ppos += *lenp;
 	} else {
 		*lenp = 0;
 	}
diff -p -purN linux-2.6.8-rc3-bk2/fs/fifo.c linux-2.6.8-rc3-bk3/fs/fifo.c
--- linux-2.6.8-rc3-bk2/fs/fifo.c	2004-06-16 05:19:13.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/fifo.c	2004-08-08 17:25:03.794131936 +0000
@@ -45,6 +45,9 @@ static int fifo_open(struct inode *inode
 	}
 	filp->f_version = 0;
 
+	/* We can only do regular read/write on fifos */
+	filp->f_mode &= (FMODE_READ | FMODE_WRITE);
+
 	switch (filp->f_mode) {
 	case 1:
 	/*
diff -p -purN linux-2.6.8-rc3-bk2/fs/file_table.c linux-2.6.8-rc3-bk3/fs/file_table.c
--- linux-2.6.8-rc3-bk2/fs/file_table.c	2004-06-16 05:18:56.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/file_table.c	2004-08-08 17:25:03.795131784 +0000
@@ -117,7 +117,7 @@ int open_private_file(struct file *filp,
 	memset(filp, 0, sizeof(*filp));
 	eventpoll_init_file(filp);
 	filp->f_flags  = flags;
-	filp->f_mode   = (flags+1) & O_ACCMODE;
+	filp->f_mode   = ((flags+1) & O_ACCMODE) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;
 	atomic_set(&filp->f_count, 1);
 	filp->f_dentry = dentry;
 	filp->f_mapping = dentry->d_inode->i_mapping;
diff -p -purN linux-2.6.8-rc3-bk2/fs/jbd/transaction.c linux-2.6.8-rc3-bk3/fs/jbd/transaction.c
--- linux-2.6.8-rc3-bk2/fs/jbd/transaction.c	2004-08-08 17:21:36.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/jbd/transaction.c	2004-08-08 17:25:03.801130872 +0000
@@ -1773,14 +1773,10 @@ static int journal_unmap_buffer(journal_
 	jbd_lock_bh_state(bh);
 	spin_lock(&journal->j_list_lock);
 
-	/*
-	 * Now we have the locks, check again to see whether kjournald has
-	 * taken the buffer off the transaction.
-	 */
-	if (!buffer_jbd(bh))
-		goto zap_buffer;
+	jh = journal_grab_journal_head(bh);
+	if (!jh)
+		goto zap_buffer_no_jh;
 
-	jh = bh2jh(bh);
 	transaction = jh->b_transaction;
 	if (transaction == NULL) {
 		/* First case: not on any transaction.  If it
@@ -1811,6 +1807,7 @@ static int journal_unmap_buffer(journal_
 			spin_unlock(&journal->j_list_lock);
 			jbd_unlock_bh_state(bh);
 			spin_unlock(&journal->j_state_lock);
+			journal_put_journal_head(jh);
 			return ret;
 		} else {
 			/* There is no currently-running transaction. So the
@@ -1824,6 +1821,7 @@ static int journal_unmap_buffer(journal_
 				spin_unlock(&journal->j_list_lock);
 				jbd_unlock_bh_state(bh);
 				spin_unlock(&journal->j_state_lock);
+				journal_put_journal_head(jh);
 				return ret;
 			} else {
 				/* The orphan record's transaction has
@@ -1847,6 +1845,7 @@ static int journal_unmap_buffer(journal_
 		spin_unlock(&journal->j_list_lock);
 		jbd_unlock_bh_state(bh);
 		spin_unlock(&journal->j_state_lock);
+		journal_put_journal_head(jh);
 		return 0;
 	} else {
 		/* Good, the buffer belongs to the running transaction.
@@ -1860,6 +1859,8 @@ static int journal_unmap_buffer(journal_
 	}
 
 zap_buffer:
+	journal_put_journal_head(jh);
+zap_buffer_no_jh:
 	spin_unlock(&journal->j_list_lock);
 	jbd_unlock_bh_state(bh);
 	spin_unlock(&journal->j_state_lock);
diff -p -purN linux-2.6.8-rc3-bk2/fs/nfsd/nfs4state.c linux-2.6.8-rc3-bk3/fs/nfsd/nfs4state.c
--- linux-2.6.8-rc3-bk2/fs/nfsd/nfs4state.c	2004-08-08 17:21:36.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/nfsd/nfs4state.c	2004-08-08 17:25:03.809129656 +0000
@@ -1140,10 +1140,9 @@ int status;
 
 	if (share_access & NFS4_SHARE_ACCESS_WRITE) {
 		status = get_write_access(filp->f_dentry->d_inode);
-		if (!status)
-			filp->f_mode = FMODE_WRITE;
-		else
+		if (status)
 			return nfserrno(status);
+		filp->f_mode = (filp->f_mode | FMODE_WRITE) & ~FMODE_READ;
 	}
 	return nfs_ok;
 }
@@ -1153,7 +1152,7 @@ nfs4_file_downgrade(struct file *filp, u
 {
 	if (share_access & NFS4_SHARE_ACCESS_WRITE) {
 		put_write_access(filp->f_dentry->d_inode);
-		filp->f_mode = FMODE_READ;
+		filp->f_mode = (filp->f_mode | FMODE_READ) & ~FMODE_WRITE;
 	}
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/fs/open.c linux-2.6.8-rc3-bk3/fs/open.c
--- linux-2.6.8-rc3-bk2/fs/open.c	2004-06-16 05:18:56.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/open.c	2004-08-08 17:25:03.811129352 +0000
@@ -781,7 +781,7 @@ struct file *dentry_open(struct dentry *
 	if (!f)
 		goto cleanup_dentry;
 	f->f_flags = flags;
-	f->f_mode = (flags+1) & O_ACCMODE;
+	f->f_mode = ((flags+1) & O_ACCMODE) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
 		error = get_write_access(inode);
@@ -1070,3 +1070,15 @@ int generic_file_open(struct inode * ino
 }
 
 EXPORT_SYMBOL(generic_file_open);
+
+/*
+ * This is used by subsystems that don't want seekable
+ * file descriptors
+ */
+int nonseekable_open(struct inode *inode, struct file *filp)
+{
+	filp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);
+	return 0;
+}
+
+EXPORT_SYMBOL(nonseekable_open);
diff -p -purN linux-2.6.8-rc3-bk2/fs/pipe.c linux-2.6.8-rc3-bk3/fs/pipe.c
--- linux-2.6.8-rc3-bk2/fs/pipe.c	2004-06-16 05:19:35.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/pipe.c	2004-08-08 17:25:03.813129048 +0000
@@ -94,10 +94,6 @@ pipe_readv(struct file *filp, const stru
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
 
-	/* pread is not allowed on pipes. */
-	if (unlikely(ppos != &filp->f_pos))
-		return -ESPIPE;
-
 	total_len = iov_length(iov, nr_segs);
 	/* Null read succeeds. */
 	if (unlikely(total_len == 0))
@@ -187,10 +183,6 @@ pipe_writev(struct file *filp, const str
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
 
-	/* pwrite is not allowed on pipes. */
-	if (unlikely(ppos != &filp->f_pos))
-		return -ESPIPE;
-
 	total_len = iov_length(iov, nr_segs);
 	/* Null write succeeds. */
 	if (unlikely(total_len == 0))
@@ -656,13 +648,13 @@ int do_pipe(int *fd)
 	f1->f_pos = f2->f_pos = 0;
 	f1->f_flags = O_RDONLY;
 	f1->f_op = &read_pipe_fops;
-	f1->f_mode = 1;
+	f1->f_mode = FMODE_READ;
 	f1->f_version = 0;
 
 	/* write file */
 	f2->f_flags = O_WRONLY;
 	f2->f_op = &write_pipe_fops;
-	f2->f_mode = 2;
+	f2->f_mode = FMODE_WRITE;
 	f2->f_version = 0;
 
 	fd_install(i, f1);
diff -p -purN linux-2.6.8-rc3-bk2/fs/read_write.c linux-2.6.8-rc3-bk3/fs/read_write.c
--- linux-2.6.8-rc3-bk2/fs/read_write.c	2004-08-08 17:21:36.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/read_write.c	2004-08-08 17:25:03.816128592 +0000
@@ -113,9 +113,12 @@ loff_t vfs_llseek(struct file *file, lof
 {
 	loff_t (*fn)(struct file *, loff_t, int);
 
-	fn = default_llseek;
-	if (file->f_op && file->f_op->llseek)
-		fn = file->f_op->llseek;
+	fn = no_llseek;
+	if (file->f_mode & FMODE_LSEEK) {
+		fn = default_llseek;
+		if (file->f_op && file->f_op->llseek)
+			fn = file->f_op->llseek;
+	}
 	return fn(file, offset, origin);
 }
 EXPORT_SYMBOL(vfs_llseek);
@@ -310,7 +313,9 @@ asmlinkage ssize_t sys_pread64(unsigned 
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
-		ret = vfs_read(file, buf, count, &pos);
+		ret = -ESPIPE;
+		if (file->f_mode & FMODE_PREAD)
+			ret = vfs_read(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
 
@@ -329,7 +334,9 @@ asmlinkage ssize_t sys_pwrite64(unsigned
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
-		ret = vfs_write(file, buf, count, &pos);
+		ret = -ESPIPE;
+		if (file->f_mode & FMODE_PWRITE)  
+			ret = vfs_write(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
 
@@ -560,8 +567,12 @@ static ssize_t do_sendfile(int out_fd, i
 		goto fput_in;
 	if (!in_file->f_op || !in_file->f_op->sendfile)
 		goto fput_in;
+	retval = -ESPIPE;
 	if (!ppos)
 		ppos = &in_file->f_pos;
+	else
+		if (!(in_file->f_mode & FMODE_PREAD))
+			goto fput_in;
 	retval = locks_verify_area(FLOCK_VERIFY_READ, in_inode, in_file, *ppos, count);
 	if (retval)
 		goto fput_in;
diff -p -purN linux-2.6.8-rc3-bk2/fs/seq_file.c linux-2.6.8-rc3-bk3/fs/seq_file.c
--- linux-2.6.8-rc3-bk2/fs/seq_file.c	2004-06-16 05:19:43.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/seq_file.c	2004-08-08 17:25:03.817128440 +0000
@@ -35,6 +35,9 @@ int seq_open(struct file *file, struct s
 	sema_init(&p->sem, 1);
 	p->op = op;
 	file->private_data = p;
+
+	/* SEQ files support lseek, but not pread/pwrite */
+	file->f_mode &= ~(FMODE_PREAD | FMODE_PWRITE);
 	return 0;
 }
 EXPORT_SYMBOL(seq_open);
@@ -54,9 +57,6 @@ ssize_t seq_read(struct file *file, char
 	void *p;
 	int err = 0;
 
-	if (ppos != &file->f_pos)
-		return -EPIPE;
-
 	down(&m->sem);
 	/* grab buffer if we didn't have one */
 	if (!m->buf) {
diff -p -purN linux-2.6.8-rc3-bk2/fs/xfs/linux-2.6/xfs_sysctl.c linux-2.6.8-rc3-bk3/fs/xfs/linux-2.6/xfs_sysctl.c
--- linux-2.6.8-rc3-bk2/fs/xfs/linux-2.6/xfs_sysctl.c	2004-06-16 05:20:26.000000000 +0000
+++ linux-2.6.8-rc3-bk3/fs/xfs/linux-2.6/xfs_sysctl.c	2004-08-08 17:25:03.820127984 +0000
@@ -46,12 +46,13 @@ xfs_stats_clear_proc_handler(
 	int		write,
 	struct file	*filp,
 	void		*buffer,
-	size_t		*lenp)
+	size_t		*lenp,
+	loff_t		*ppos)
 {
 	int		c, ret, *valp = ctl->data;
 	__uint32_t	vn_active;
 
-	ret = proc_dointvec_minmax(ctl, write, filp, buffer, lenp);
+	ret = proc_dointvec_minmax(ctl, write, filp, buffer, lenp, ppos);
 
 	if (!ret && write && *valp) {
 		printk("XFS Clearing xfsstats\n");
diff -p -purN linux-2.6.8-rc3-bk2/include/asm-ppc/ppc405_dma.h linux-2.6.8-rc3-bk3/include/asm-ppc/ppc405_dma.h
--- linux-2.6.8-rc3-bk2/include/asm-ppc/ppc405_dma.h	2004-06-16 05:19:09.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/asm-ppc/ppc405_dma.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,1271 +0,0 @@
-/*
- * Author: Pete Popov <ppopov@mvista.com>
- *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- *
- * Data structures specific to the IBM PowerPC 405 on-chip DMA controller
- * and API.
- */
-
-#ifdef __KERNEL__
-#ifndef __ASMPPC_405_DMA_H
-#define __ASMPPC_405_DMA_H
-
-#include <linux/types.h>
-
-/* #define DEBUG_405DMA */
-
-#define TRUE  1
-#define FALSE 0
-
-#define SGL_LIST_SIZE 4096
-/* #define PCI_ALLOC_IS_NONCONSISTENT */
-
-#define MAX_405GP_DMA_CHANNELS	4
-
-/* The maximum address that we can perform a DMA transfer to on this platform */
-/* Doesn't really apply... */
-#define MAX_DMA_ADDRESS		0xFFFFFFFF
-
-extern unsigned long ISA_DMA_THRESHOLD;
-
-#define dma_outb	outb
-#define dma_inb		inb
-
-
-/*
- * Function return status codes
- * These values are used to indicate whether or not the function
- * call was successful, or a bad/invalid parameter was passed.
- */
-#define DMA_STATUS_GOOD			0
-#define DMA_STATUS_BAD_CHANNEL		1
-#define DMA_STATUS_BAD_HANDLE		2
-#define DMA_STATUS_BAD_MODE		3
-#define DMA_STATUS_NULL_POINTER		4
-#define DMA_STATUS_OUT_OF_MEMORY	5
-#define DMA_STATUS_SGL_LIST_EMPTY	6
-#define DMA_STATUS_GENERAL_ERROR	7
-
-
-/*
- * These indicate status as returned from the DMA Status Register.
- */
-#define DMA_STATUS_NO_ERROR	0
-#define DMA_STATUS_CS		1	/* Count Status        */
-#define DMA_STATUS_TS		2	/* Transfer Status     */
-#define DMA_STATUS_DMA_ERROR	3	/* DMA Error Occurred  */
-#define DMA_STATUS_DMA_BUSY	4	/* The channel is busy */
-
-
-/*
- * Transfer Modes
- * These modes are defined in a way that makes it possible to
- * simply "or" in the value in the control register.
- */
-#define DMA_MODE_READ		DMA_TD                /* Peripheral to Memory */
-#define DMA_MODE_WRITE		0                     /* Memory to Peripheral */
-#define DMA_MODE_MM		(SET_DMA_TM(TM_S_MM)) /* memory to memory */
-
-				/* Device-paced memory to memory, */
-				/* device is at source address    */
-#define DMA_MODE_MM_DEVATSRC	(DMA_TD | SET_DMA_TM(TM_D_MM))
-
-				/* Device-paced memory to memory,      */
-				/* device is at destination address    */
-#define DMA_MODE_MM_DEVATDST	(SET_DMA_TM(TM_D_MM))
-
-
-/*
- * DMA Polarity Configuration Register
- */
-#define DMAReq0_ActiveLow (1<<31)
-#define DMAAck0_ActiveLow (1<<30)
-#define EOT0_ActiveLow    (1<<29)           /* End of Transfer      */
-
-#define DMAReq1_ActiveLow (1<<28)
-#define DMAAck1_ActiveLow (1<<27)
-#define EOT1_ActiveLow    (1<<26)
-
-#define DMAReq2_ActiveLow (1<<25)
-#define DMAAck2_ActiveLow (1<<24)
-#define EOT2_ActiveLow    (1<<23)
-
-#define DMAReq3_ActiveLow (1<<22)
-#define DMAAck3_ActiveLow (1<<21)
-#define EOT3_ActiveLow    (1<<20)
-
-/*
- * DMA Sleep Mode Register
- */
-#define SLEEP_MODE_ENABLE (1<<21)
-
-
-/*
- * DMA Status Register
- */
-#define DMA_CS0           (1<<31) /* Terminal Count has been reached */
-#define DMA_CS1           (1<<30)
-#define DMA_CS2           (1<<29)
-#define DMA_CS3           (1<<28)
-
-#define DMA_TS0           (1<<27) /* End of Transfer has been requested */
-#define DMA_TS1           (1<<26)
-#define DMA_TS2           (1<<25)
-#define DMA_TS3           (1<<24)
-
-#define DMA_CH0_ERR       (1<<23) /* DMA Chanel 0 Error */
-#define DMA_CH1_ERR       (1<<22)
-#define DMA_CH2_ERR       (1<<21)
-#define DMA_CH3_ERR       (1<<20)
-
-#define DMA_IN_DMA_REQ0   (1<<19) /* Internal DMA Request is pending */
-#define DMA_IN_DMA_REQ1   (1<<18)
-#define DMA_IN_DMA_REQ2   (1<<17)
-#define DMA_IN_DMA_REQ3   (1<<16)
-
-#define DMA_EXT_DMA_REQ0  (1<<15) /* External DMA Request is pending */
-#define DMA_EXT_DMA_REQ1  (1<<14)
-#define DMA_EXT_DMA_REQ2  (1<<13)
-#define DMA_EXT_DMA_REQ3  (1<<12)
-
-#define DMA_CH0_BUSY      (1<<11) /* DMA Channel 0 Busy */
-#define DMA_CH1_BUSY      (1<<10)
-#define DMA_CH2_BUSY       (1<<9)
-#define DMA_CH3_BUSY       (1<<8)
-
-#define DMA_SG0            (1<<7) /* DMA Channel 0 Scatter/Gather in progress */
-#define DMA_SG1            (1<<6)
-#define DMA_SG2            (1<<5)
-#define DMA_SG3            (1<<4)
-
-
-
-/*
- * DMA Channel Control Registers
- */
-#define DMA_CH_ENABLE         (1<<31)     /* DMA Channel Enable */
-#define SET_DMA_CH_ENABLE(x)  (((x)&0x1)<<31)
-#define GET_DMA_CH_ENABLE(x)  (((x)&DMA_CH_ENABLE)>>31)
-
-#define DMA_CIE_ENABLE        (1<<30)     /* DMA Channel Interrupt Enable */
-#define SET_DMA_CIE_ENABLE(x) (((x)&0x1)<<30)
-#define GET_DMA_CIE_ENABLE(x) (((x)&DMA_CIE_ENABLE)>>30)
-
-#define DMA_TD                (1<<29)
-#define SET_DMA_TD(x)         (((x)&0x1)<<29)
-#define GET_DMA_TD(x)         (((x)&DMA_TD)>>29)
-
-#define DMA_PL                (1<<28)     /* Peripheral Location */
-#define SET_DMA_PL(x)         (((x)&0x1)<<28)
-#define GET_DMA_PL(x)         (((x)&DMA_PL)>>28)
-
-#define EXTERNAL_PERIPHERAL    0
-#define INTERNAL_PERIPHERAL    1
-
-
-#define SET_DMA_PW(x)     (((x)&0x3)<<26) /* Peripheral Width */
-#define DMA_PW_MASK       SET_DMA_PW(3)
-#define   PW_8                 0
-#define   PW_16                1
-#define   PW_32                2
-#define   PW_64                3
-#define GET_DMA_PW(x)     (((x)&DMA_PW_MASK)>>26)
-
-#define DMA_DAI           (1<<25)         /* Destination Address Increment */
-#define SET_DMA_DAI(x)    (((x)&0x1)<<25)
-
-#define DMA_SAI           (1<<24)         /* Source Address Increment */
-#define SET_DMA_SAI(x)    (((x)&0x1)<<24)
-
-#define DMA_BEN           (1<<23)         /* Buffer Enable */
-#define SET_DMA_BEN(x)    (((x)&0x1)<<23)
-
-#define SET_DMA_TM(x)     (((x)&0x3)<<21) /* Transfer Mode */
-#define DMA_TM_MASK       SET_DMA_TM(3)
-#define   TM_PERIPHERAL        0          /* Peripheral */
-#define   TM_RESERVED          1          /* Reserved */
-#define   TM_S_MM              2          /* Memory to Memory */
-#define   TM_D_MM              3          /* Device Paced Memory to Memory */
-#define GET_DMA_TM(x)     (((x)&DMA_TM_MASK)>>21)
-
-#define SET_DMA_PSC(x)    (((x)&0x3)<<19) /* Peripheral Setup Cycles */
-#define DMA_PSC_MASK      SET_DMA_PSC(3)
-#define GET_DMA_PSC(x)    (((x)&DMA_PSC_MASK)>>19)
-
-#define SET_DMA_PWC(x)    (((x)&0x3F)<<13) /* Peripheral Wait Cycles */
-#define DMA_PWC_MASK      SET_DMA_PWC(0x3F)
-#define GET_DMA_PWC(x)    (((x)&DMA_PWC_MASK)>>13)
-
-#define SET_DMA_PHC(x)    (((x)&0x7)<<10) /* Peripheral Hold Cycles */
-#define DMA_PHC_MASK      SET_DMA_PHC(0x7)
-#define GET_DMA_PHC(x)    (((x)&DMA_PHC_MASK)>>10)
-
-#define DMA_ETD_OUTPUT     (1<<9)         /* EOT pin is a TC output */
-#define SET_DMA_ETD(x)     (((x)&0x1)<<9)
-
-#define DMA_TCE_ENABLE     (1<<8)
-#define SET_DMA_TCE(x)     (((x)&0x1)<<8)
-
-#define SET_DMA_PRIORITY(x)   (((x)&0x3)<<6)   /* DMA Channel Priority */
-#define DMA_PRIORITY_MASK SET_DMA_PRIORITY(3)
-#define   PRIORITY_LOW         0
-#define   PRIORITY_MID_LOW     1
-#define   PRIORITY_MID_HIGH    2
-#define   PRIORITY_HIGH        3
-#define GET_DMA_PRIORITY(x) (((x)&DMA_PRIORITY_MASK)>>6)
-
-#define SET_DMA_PREFETCH(x)   (((x)&0x3)<<4)  /* Memory Read Prefetch */
-#define DMA_PREFETCH_MASK      SET_DMA_PREFETCH(3)
-#define   PREFETCH_1           0              /* Prefetch 1 Double Word */
-#define   PREFETCH_2           1
-#define   PREFETCH_4           2
-#define GET_DMA_PREFETCH(x) (((x)&DMA_PREFETCH_MASK)>>4)
-
-#define DMA_PCE            (1<<3)         /* Parity Check Enable */
-#define SET_DMA_PCE(x)     (((x)&0x1)<<3)
-#define GET_DMA_PCE(x)     (((x)&DMA_PCE)>>3)
-
-#define DMA_DEC            (1<<2)         /* Address Decrement */
-#define SET_DMA_DEC(x)     (((x)&0x1)<<2)
-#define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
-
-/*
- * DMA SG Command Register
- */
-#define SSG0_ENABLE        (1<<31)        /* Start Scatter Gather */
-#define SSG1_ENABLE        (1<<30)
-#define SSG2_ENABLE        (1<<29)
-#define SSG3_ENABLE        (1<<28)
-#define SSG0_MASK_ENABLE   (1<<15)        /* Enable writing to SSG0 bit */
-#define SSG1_MASK_ENABLE   (1<<14)
-#define SSG2_MASK_ENABLE   (1<<13)
-#define SSG3_MASK_ENABLE   (1<<12)
-
-
-/*
- * DMA Scatter/Gather Descriptor Bit fields
- */
-#define SG_LINK            (1<<31)        /* Link */
-#define SG_TCI_ENABLE      (1<<29)        /* Enable Terminal Count Interrupt */
-#define SG_ETI_ENABLE      (1<<28)        /* Enable End of Transfer Interrupt */
-#define SG_ERI_ENABLE      (1<<27)        /* Enable Error Interrupt */
-#define SG_COUNT_MASK       0xFFFF        /* Count Field */
-
-
-
-
-typedef uint32_t sgl_handle_t;
-
-typedef struct {
-
-	/*
-	 * Valid polarity settings:
-	 *   DMAReq0_ActiveLow
-	 *   DMAAck0_ActiveLow
-	 *   EOT0_ActiveLow
-	 *
-	 *   DMAReq1_ActiveLow
-	 *   DMAAck1_ActiveLow
-	 *   EOT1_ActiveLow
-	 *
-	 *   DMAReq2_ActiveLow
-	 *   DMAAck2_ActiveLow
-	 *   EOT2_ActiveLow
-	 *
-	 *   DMAReq3_ActiveLow
-	 *   DMAAck3_ActiveLow
-	 *   EOT3_ActiveLow
-	 */
-	unsigned int polarity;
-
-	char buffer_enable;      /* Boolean: buffer enable            */
-	char tce_enable;         /* Boolean: terminal count enable    */
-	char etd_output;         /* Boolean: eot pin is a tc output   */
-	char pce;                /* Boolean: parity check enable      */
-
-	/*
-	 * Peripheral location:
-	 * INTERNAL_PERIPHERAL (UART0 on the 405GP)
-	 * EXTERNAL_PERIPHERAL
-	 */
-	char pl;                 /* internal/external peripheral      */
-
-	/*
-	 * Valid pwidth settings:
-	 *   PW_8
-	 *   PW_16
-	 *   PW_32
-	 *   PW_64
-	 */
-	unsigned int pwidth;
-
-	char dai;                /* Boolean: dst address increment   */
-	char sai;                /* Boolean: src address increment   */
-
-	/*
-	 * Valid psc settings: 0-3
-	 */
-	unsigned int psc;        /* Peripheral Setup Cycles         */
-
-	/*
-	 * Valid pwc settings:
-	 * 0-63
-	 */
-	unsigned int pwc;        /* Peripheral Wait Cycles          */
-
-	/*
-	 * Valid phc settings:
-	 * 0-7
-	 */
-	unsigned int phc;        /* Peripheral Hold Cycles          */
-
-	/*
-	 * Valid cp (channel priority) settings:
-	 *   PRIORITY_LOW
-	 *   PRIORITY_MID_LOW
-	 *   PRIORITY_MID_HIGH
-	 *   PRIORITY_HIGH
-	 */
-	unsigned int cp;         /* channel priority                */
-
-	/*
-	 * Valid pf (memory read prefetch) settings:
-	 *
-	 *   PREFETCH_1
-	 *   PREFETCH_2
-	 *   PREFETCH_4
-	 */
-	unsigned int pf;         /* memory read prefetch            */
-
-	/*
-	 * Boolean: channel interrupt enable
-	 * NOTE: for sgl transfers, only the last descriptor will be setup to
-	 * interrupt.
-	 */
-	char int_enable;
-
-	char shift;              /* easy access to byte_count shift, based on */
-	                         /* the width of the channel                  */
-
-	uint32_t control;        /* channel control word                      */
-
-
-	/* These variabled are used ONLY in single dma transfers              */
-	unsigned int mode;       /* transfer mode                     */
-	dma_addr_t addr;
-
-} ppc_dma_ch_t;
-
-
-typedef struct {
-	uint32_t control;
-	uint32_t src_addr;
-	uint32_t dst_addr;
-	uint32_t control_count;
-	uint32_t next;
-} ppc_sgl_t;
-
-
-
-typedef struct {
-	unsigned int dmanr;
-	uint32_t control;     /* channel ctrl word; loaded from each descrptr */
-	uint32_t sgl_control; /* LK, TCI, ETI, and ERI bits in sgl descriptor */
-	dma_addr_t dma_addr;  /* dma (physical) address of this list          */
-	ppc_sgl_t *phead;
-	ppc_sgl_t *ptail;
-
-} sgl_list_info_t;
-
-
-typedef struct {
-	unsigned int *src_addr;
-	unsigned int *dst_addr;
-	dma_addr_t dma_src_addr;
-	dma_addr_t dma_dst_addr;
-} pci_alloc_desc_t;
-
-
-extern ppc_dma_ch_t dma_channels[];
-
-/*
- *
- * DMA API inline functions
- * These functions are implemented here as inline functions for
- * performance reasons.
- *
- */
-
-static __inline__ int get_405gp_dma_status(void)
-{
-	return (mfdcr(DCRN_DMASR));
-}
-
-
-static __inline__ int enable_405gp_dma(unsigned int dmanr)
-{
-	unsigned int control;
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-	if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-		printk("enable_dma: bad channel: %d\n", dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-#endif
-
-
-	switch (dmanr) {
-	case 0:
-		if (p_dma_ch->mode == DMA_MODE_READ) {
-			/* peripheral to memory */
-			mtdcr(DCRN_DMASA0, NULL);
-			mtdcr(DCRN_DMADA0, p_dma_ch->addr);
-			}
-		else if (p_dma_ch->mode == DMA_MODE_WRITE) {
-			/* memory to peripheral */
-			mtdcr(DCRN_DMASA0, p_dma_ch->addr);
-			mtdcr(DCRN_DMADA0, NULL);
-		}
-		/* for other xfer modes, the addresses are already set */
-		control = mfdcr(DCRN_DMACR0);
-		control &= ~(DMA_TM_MASK | DMA_TD);   /* clear all mode bits */
-		control |= (p_dma_ch->mode | DMA_CH_ENABLE);
-		mtdcr(DCRN_DMACR0, control);
-		break;
-	case 1:
-		if (p_dma_ch->mode == DMA_MODE_READ) {
-			mtdcr(DCRN_DMASA1, NULL);
-			mtdcr(DCRN_DMADA1, p_dma_ch->addr);
-		} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
-			mtdcr(DCRN_DMASA1, p_dma_ch->addr);
-			mtdcr(DCRN_DMADA1, NULL);
-		}
-		control = mfdcr(DCRN_DMACR1);
-		control &= ~(DMA_TM_MASK | DMA_TD);
-		control |= (p_dma_ch->mode | DMA_CH_ENABLE);
-		mtdcr(DCRN_DMACR1, control);
-		break;
-	case 2:
-		if (p_dma_ch->mode == DMA_MODE_READ) {
-			mtdcr(DCRN_DMASA2, NULL);
-			mtdcr(DCRN_DMADA2, p_dma_ch->addr);
-		} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
-			mtdcr(DCRN_DMASA2, p_dma_ch->addr);
-			mtdcr(DCRN_DMADA2, NULL);
-		}
-		control = mfdcr(DCRN_DMACR2);
-		control &= ~(DMA_TM_MASK | DMA_TD);
-		control |= (p_dma_ch->mode | DMA_CH_ENABLE);
-		mtdcr(DCRN_DMACR2, control);
-		break;
-	case 3:
-		if (p_dma_ch->mode == DMA_MODE_READ) {
-			mtdcr(DCRN_DMASA3, NULL);
-			mtdcr(DCRN_DMADA3, p_dma_ch->addr);
-		} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
-			mtdcr(DCRN_DMASA3, p_dma_ch->addr);
-			mtdcr(DCRN_DMADA3, NULL);
-		}
-		control = mfdcr(DCRN_DMACR3);
-		control &= ~(DMA_TM_MASK | DMA_TD);
-		control |= (p_dma_ch->mode | DMA_CH_ENABLE);
-		mtdcr(DCRN_DMACR3, control);
-		break;
-	default:
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-	return DMA_STATUS_GOOD;
-}
-
-
-
-static __inline__ void disable_405gp_dma(unsigned int dmanr)
-{
-	unsigned int control;
-
-	switch (dmanr) {
-	case 0:
-		control = mfdcr(DCRN_DMACR0);
-		control &= ~DMA_CH_ENABLE;
-		mtdcr(DCRN_DMACR0, control);
-		break;
-	case 1:
-		control = mfdcr(DCRN_DMACR1);
-		control &= ~DMA_CH_ENABLE;
-		mtdcr(DCRN_DMACR1, control);
-		break;
-	case 2:
-		control = mfdcr(DCRN_DMACR2);
-		control &= ~DMA_CH_ENABLE;
-		mtdcr(DCRN_DMACR2, control);
-		break;
-	case 3:
-		control = mfdcr(DCRN_DMACR3);
-		control &= ~DMA_CH_ENABLE;
-		mtdcr(DCRN_DMACR3, control);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("disable_dma: bad channel: %d\n", dmanr);
-#endif
-	}
-}
-
-
-
-/*
- * Sets the dma mode for single DMA transfers only.
- * For scatter/gather transfers, the mode is passed to the
- * alloc_dma_handle() function as one of the parameters.
- *
- * The mode is simply saved and used later.  This allows
- * the driver to call set_dma_mode() and set_dma_addr() in
- * any order.
- *
- * Valid mode values are:
- *
- * DMA_MODE_READ          peripheral to memory
- * DMA_MODE_WRITE         memory to peripheral
- * DMA_MODE_MM            memory to memory
- * DMA_MODE_MM_DEVATSRC   device-paced memory to memory, device at src
- * DMA_MODE_MM_DEVATDST   device-paced memory to memory, device at dst
- */
-static __inline__ int set_405gp_dma_mode(unsigned int dmanr, unsigned int mode)
-{
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-	switch (mode) {
-	case DMA_MODE_READ:
-	case DMA_MODE_WRITE:
-	case DMA_MODE_MM:
-	case DMA_MODE_MM_DEVATSRC:
-	case DMA_MODE_MM_DEVATDST:
-		break;
-	default:
-		printk("set_dma_mode: bad mode 0x%x\n", mode);
-		return DMA_STATUS_BAD_MODE;
-	}
-	if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-		printk("set_dma_mode: bad channel 0x%x\n", dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-#endif
-
-	p_dma_ch->mode = mode;
-	return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Sets the DMA Count register. Note that 'count' is in bytes.
- * However, the DMA Count register counts the number of "transfers",
- * where each transfer is equal to the bus width.  Thus, count
- * MUST be a multiple of the bus width.
- */
-static __inline__ void
-set_405gp_dma_count(unsigned int dmanr, unsigned int count)
-{
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-	{
-	int error = 0;
-	switch(p_dma_ch->pwidth) {
-	case PW_8:
-		break;
-	case PW_16:
-		if (count & 0x1)
-		error = 1;
-		break;
-	case PW_32:
-		if (count & 0x3)
-		error = 1;
-		break;
-	case PW_64:
-		if (count & 0x7)
-		error = 1;
-		break;
-	default:
-		printk("set_dma_count: invalid bus width: 0x%x\n",
-			p_dma_ch->pwidth);
-		return;
-	}
-	if (error)
-		printk("Warning: set_dma_count count 0x%x bus width %d\n",
-			count, p_dma_ch->pwidth);
-	}
-#endif
-
-	count = count >> p_dma_ch->shift;
-	switch (dmanr) {
-	case 0:
-		mtdcr(DCRN_DMACT0, count);
-		break;
-	case 1:
-		mtdcr(DCRN_DMACT1, count);
-		break;
-	case 2:
-		mtdcr(DCRN_DMACT2, count);
-		break;
-	case 3:
-		mtdcr(DCRN_DMACT3, count);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("set_dma_count: bad channel: %d\n", dmanr);
-#endif
-	}
-}
-
-
-
-/*
- *   Returns the number of bytes left to be transfered.
- *   After a DMA transfer, this should return zero.
- *   Reading this while a DMA transfer is still in progress will return
- *   unpredictable results.
- */
-static __inline__ int get_405gp_dma_residue(unsigned int dmanr)
-{
-	unsigned int count;
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-	switch (dmanr) {
-	case 0:
-		count = mfdcr(DCRN_DMACT0);
-		break;
-	case 1:
-		count = mfdcr(DCRN_DMACT1);
-		break;
-	case 2:
-		count = mfdcr(DCRN_DMACT2);
-		break;
-	case 3:
-		count = mfdcr(DCRN_DMACT3);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("get_dma_residue: bad channel: %d\n", dmanr);
-#endif
-	    return 0;
-	}
-
-	return (count << p_dma_ch->shift);
-}
-
-
-
-/*
- * Sets the DMA address for a memory to peripheral or peripheral
- * to memory transfer.  The address is just saved in the channel
- * structure for now and used later in enable_dma().
- */
-static __inline__ void set_405gp_dma_addr(unsigned int dmanr, dma_addr_t addr)
-{
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-#ifdef DEBUG_405DMA
-	{
-	int error = 0;
-	switch(p_dma_ch->pwidth) {
-	case PW_8:
-		break;
-	case PW_16:
-		if ((unsigned)addr & 0x1)
-		error = 1;
-		break;
-	case PW_32:
-		if ((unsigned)addr & 0x3)
-		error = 1;
-		break;
-	case PW_64:
-		if ((unsigned)addr & 0x7)
-		error = 1;
-		break;
-	default:
-		printk("set_dma_addr: invalid bus width: 0x%x\n",
-			p_dma_ch->pwidth);
-		return;
-	}
-	if (error)
-		printk("Warning: set_dma_addr addr 0x%x bus width %d\n",
-			addr, p_dma_ch->pwidth);
-	}
-#endif
-
-	/* save dma address and program it later after we know the xfer mode */
-	p_dma_ch->addr = addr;
-}
-
-
-
-
-/*
- * Sets both DMA addresses for a memory to memory transfer.
- * For memory to peripheral or peripheral to memory transfers
- * the function set_dma_addr() should be used instead.
- */
-static __inline__ void
-set_405gp_dma_addr2(unsigned int dmanr, dma_addr_t src_dma_addr,
-	dma_addr_t dst_dma_addr)
-{
-#ifdef DEBUG_405DMA
-	{
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-	int error = 0;
-	switch(p_dma_ch->pwidth) {
-	case PW_8:
-		break;
-	case PW_16:
-		if (((unsigned)src_dma_addr & 0x1) ||
-		    ((unsigned)dst_dma_addr & 0x1)
-		   )
-			error = 1;
-		break;
-	case PW_32:
-		if (((unsigned)src_dma_addr & 0x3) ||
-		    ((unsigned)dst_dma_addr & 0x3)
-		   )
-			error = 1;
-		break;
-	case PW_64:
-		if (((unsigned)src_dma_addr & 0x7) ||
-		    ((unsigned)dst_dma_addr & 0x7)
-		   )
-			error = 1;
-		break;
-	default:
-		printk("set_dma_addr2: invalid bus width: 0x%x\n",
-			p_dma_ch->pwidth);
-		return;
-	}
-	if (error)
-		printk("Warning: set_dma_addr2 src 0x%x dst 0x%x bus width %d\n",
-			src_dma_addr, dst_dma_addr, p_dma_ch->pwidth);
-	}
-#endif
-
-	switch (dmanr) {
-	case 0:
-		mtdcr(DCRN_DMASA0, src_dma_addr);
-		mtdcr(DCRN_DMADA0, dst_dma_addr);
-		break;
-	case 1:
-		mtdcr(DCRN_DMASA1, src_dma_addr);
-		mtdcr(DCRN_DMADA1, dst_dma_addr);
-		break;
-	case 2:
-		mtdcr(DCRN_DMASA2, src_dma_addr);
-		mtdcr(DCRN_DMADA2, dst_dma_addr);
-		break;
-	case 3:
-		mtdcr(DCRN_DMASA3, src_dma_addr);
-		mtdcr(DCRN_DMADA3, dst_dma_addr);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("set_dma_addr2: bad channel: %d\n", dmanr);
-#endif
-	}
-}
-
-
-
-/*
- * Enables the channel interrupt.
- *
- * If performing a scatter/gatter transfer, this function
- * MUST be called before calling alloc_dma_handle() and building
- * the sgl list.  Otherwise, interrupts will not be enabled, if
- * they were previously disabled.
- */
-static __inline__ int
-enable_405gp_dma_interrupt(unsigned int dmanr)
-{
-	unsigned int control;
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-	p_dma_ch->int_enable = TRUE;
-	switch (dmanr) {
-	case 0:
-		control = mfdcr(DCRN_DMACR0);
-		control|= DMA_CIE_ENABLE;        /* Channel Interrupt Enable */
-		mtdcr(DCRN_DMACR0, control);
-		break;
-	case 1:
-		control = mfdcr(DCRN_DMACR1);
-		control|= DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR1, control);
-		break;
-	case 2:
-		control = mfdcr(DCRN_DMACR2);
-		control|= DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR2, control);
-		break;
-	case 3:
-		control = mfdcr(DCRN_DMACR3);
-		control|= DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR3, control);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("enable_dma_interrupt: bad channel: %d\n", dmanr);
-#endif
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-	return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Disables the channel interrupt.
- *
- * If performing a scatter/gatter transfer, this function
- * MUST be called before calling alloc_dma_handle() and building
- * the sgl list.  Otherwise, interrupts will not be disabled, if
- * they were previously enabled.
- */
-static __inline__ int
-disable_405gp_dma_interrupt(unsigned int dmanr)
-{
-	unsigned int control;
-	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-	p_dma_ch->int_enable = TRUE;
-	switch (dmanr) {
-	case 0:
-		control = mfdcr(DCRN_DMACR0);
-		control &= ~DMA_CIE_ENABLE;       /* Channel Interrupt Enable */
-		mtdcr(DCRN_DMACR0, control);
-		break;
-	case 1:
-		control = mfdcr(DCRN_DMACR1);
-		control &= ~DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR1, control);
-		break;
-	case 2:
-		control = mfdcr(DCRN_DMACR2);
-		control &= ~DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR2, control);
-		break;
-	case 3:
-		control = mfdcr(DCRN_DMACR3);
-		control &= ~DMA_CIE_ENABLE;
-		mtdcr(DCRN_DMACR3, control);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("enable_dma_interrupt: bad channel: %d\n", dmanr);
-#endif
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-	return DMA_STATUS_GOOD;
-}
-
-
-#ifdef DCRNCAP_DMA_SG
-
-/*
- *   Add a new sgl descriptor to the end of a scatter/gather list
- *   which was created by alloc_dma_handle().
- *
- *   For a memory to memory transfer, both dma addresses must be
- *   valid. For a peripheral to memory transfer, one of the addresses
- *   must be set to NULL, depending on the direction of the transfer:
- *   memory to peripheral: set dst_addr to NULL,
- *   peripheral to memory: set src_addr to NULL.
- */
-static __inline__ int
-add_405gp_dma_sgl(sgl_handle_t handle, dma_addr_t src_addr, dma_addr_t dst_addr,
-	unsigned int count)
-{
-	sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-	ppc_dma_ch_t *p_dma_ch;
-
-	if (!handle) {
-#ifdef DEBUG_405DMA
-		printk("add_dma_sgl: null handle\n");
-#endif
-		return DMA_STATUS_BAD_HANDLE;
-	}
-
-#ifdef DEBUG_405DMA
-	if (psgl->dmanr >= MAX_405GP_DMA_CHANNELS) {
-		printk("add_dma_sgl error: psgl->dmanr == %d\n", psgl->dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-#endif
-
-	p_dma_ch = &dma_channels[psgl->dmanr];
-
-#ifdef DEBUG_405DMA
-	{
-	int error = 0;
-	unsigned int aligned = (unsigned)src_addr | (unsigned)dst_addr | count;
-	switch(p_dma_ch->pwidth) {
-	case PW_8:
-		break;
-	case PW_16:
-		if (aligned & 0x1)
-		error = 1;
-		break;
-	case PW_32:
-		if (aligned & 0x3)
-			error = 1;
-		break;
-	case PW_64:
-		if (aligned & 0x7)
-			error = 1;
-		break;
-	default:
-		printk("add_dma_sgl: invalid bus width: 0x%x\n",
-			p_dma_ch->pwidth);
-		return DMA_STATUS_GENERAL_ERROR;
-	}
-	if (error)
-		printk("Alignment warning: add_dma_sgl src 0x%x dst 0x%x count 0x%x bus width var %d\n",
-			src_addr, dst_addr, count, p_dma_ch->pwidth);
-
-	}
-#endif
-
-	if ((unsigned)(psgl->ptail + 1) >= ((unsigned)psgl + SGL_LIST_SIZE)) {
-#ifdef DEBUG_405DMA
-		printk("sgl handle out of memory \n");
-#endif
-		return DMA_STATUS_OUT_OF_MEMORY;
-	}
-
-
-	if (!psgl->ptail) {
-		psgl->phead = (ppc_sgl_t *)
-			      ((unsigned)psgl + sizeof(sgl_list_info_t));
-		psgl->ptail = psgl->phead;
-	} else {
-		psgl->ptail->next = virt_to_bus(psgl->ptail + 1);
-		psgl->ptail++;
-	}
-
-	psgl->ptail->control       = psgl->control;
-	psgl->ptail->src_addr      = src_addr;
-	psgl->ptail->dst_addr      = dst_addr;
-	psgl->ptail->control_count = (count >> p_dma_ch->shift) |
-				     psgl->sgl_control;
-	psgl->ptail->next          = (uint32_t)NULL;
-
-	return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Enable (start) the DMA described by the sgl handle.
- */
-static __inline__ void enable_405gp_dma_sgl(sgl_handle_t handle)
-{
-	sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-	ppc_dma_ch_t *p_dma_ch;
-	uint32_t sg_command;
-
-#ifdef DEBUG_405DMA
-	if (!handle) {
-		printk("enable_dma_sgl: null handle\n");
-		return;
-	} else if (psgl->dmanr > (MAX_405GP_DMA_CHANNELS - 1)) {
-		printk("enable_dma_sgl: bad channel in handle %d\n",
-			psgl->dmanr);
-		return;
-	} else if (!psgl->phead) {
-		printk("enable_dma_sgl: sg list empty\n");
-		return;
-	}
-#endif
-
-	p_dma_ch = &dma_channels[psgl->dmanr];
-	psgl->ptail->control_count &= ~SG_LINK; /* make this the last dscrptr */
-	sg_command = mfdcr(DCRN_ASGC);
-
-	switch(psgl->dmanr) {
-	case 0:
-		mtdcr(DCRN_ASG0, virt_to_bus(psgl->phead));
-		sg_command |= SSG0_ENABLE;
-		break;
-	case 1:
-		mtdcr(DCRN_ASG1, virt_to_bus(psgl->phead));
-		sg_command |= SSG1_ENABLE;
-		break;
-	case 2:
-		mtdcr(DCRN_ASG2, virt_to_bus(psgl->phead));
-		sg_command |= SSG2_ENABLE;
-		break;
-	case 3:
-		mtdcr(DCRN_ASG3, virt_to_bus(psgl->phead));
-		sg_command |= SSG3_ENABLE;
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
-#endif
-	}
-
-#if 0 /* debug */
-	printk("\n\nenable_dma_sgl at dma_addr 0x%x\n",
-		virt_to_bus(psgl->phead));
-	{
-	ppc_sgl_t *pnext, *sgl_addr;
-
-	pnext = psgl->phead;
-	while (pnext) {
-		printk("dma descriptor at 0x%x, dma addr 0x%x\n",
-			(unsigned)pnext, (unsigned)virt_to_bus(pnext));
-		printk("control 0x%x src 0x%x dst 0x%x c_count 0x%x, next 0x%x\n",
-			(unsigned)pnext->control, (unsigned)pnext->src_addr,
-			(unsigned)pnext->dst_addr,
-			(unsigned)pnext->control_count, (unsigned)pnext->next);
-
-		(unsigned)pnext = bus_to_virt(pnext->next);
-	}
-	printk("sg_command 0x%x\n", sg_command);
-	}
-#endif
-
-#ifdef PCI_ALLOC_IS_NONCONSISTENT
-	/*
-	* This is temporary only, until pci_alloc_consistent() really does
-	* return "consistent" memory.
-	*/
-	flush_dcache_range((unsigned)handle, (unsigned)handle + SGL_LIST_SIZE);
-#endif
-
-	mtdcr(DCRN_ASGC, sg_command);             /* start transfer */
-}
-
-
-
-/*
- * Halt an active scatter/gather DMA operation.
- */
-static __inline__ void disable_405gp_dma_sgl(sgl_handle_t handle)
-{
-	sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-	uint32_t sg_command;
-
-#ifdef DEBUG_405DMA
-	if (!handle) {
-		printk("enable_dma_sgl: null handle\n");
-		return;
-	} else if (psgl->dmanr > (MAX_405GP_DMA_CHANNELS - 1)) {
-		printk("enable_dma_sgl: bad channel in handle %d\n",
-			psgl->dmanr);
-		return;
-	}
-#endif
-	sg_command = mfdcr(DCRN_ASGC);
-	switch(psgl->dmanr) {
-	case 0:
-		sg_command &= ~SSG0_ENABLE;
-		break;
-	case 1:
-		sg_command &= ~SSG1_ENABLE;
-		break;
-	case 2:
-		sg_command &= ~SSG2_ENABLE;
-		break;
-	case 3:
-		sg_command &= ~SSG3_ENABLE;
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
-#endif
-	}
-
-	mtdcr(DCRN_ASGC, sg_command);             /* stop transfer */
-}
-
-
-
-/*
- *  Returns number of bytes left to be transferred from the entire sgl list.
- *  *src_addr and *dst_addr get set to the source/destination address of
- *  the sgl descriptor where the DMA stopped.
- *
- *  An sgl transfer must NOT be active when this function is called.
- */
-static __inline__ int
-get_405gp_dma_sgl_residue(sgl_handle_t handle, dma_addr_t *src_addr,
-	dma_addr_t *dst_addr)
-{
-	sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-	ppc_dma_ch_t *p_dma_ch;
-	ppc_sgl_t *pnext, *sgl_addr;
-	uint32_t count_left;
-
-#ifdef DEBUG_405DMA
-	if (!handle) {
-		printk("get_dma_sgl_residue: null handle\n");
-		return DMA_STATUS_BAD_HANDLE;
-	} else if (psgl->dmanr > (MAX_405GP_DMA_CHANNELS - 1)) {
-		printk("get_dma_sgl_residue: bad channel in handle %d\n",
-			psgl->dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-#endif
-
-	switch(psgl->dmanr) {
-	case 0:
-		sgl_addr = (ppc_sgl_t *)bus_to_virt(mfdcr(DCRN_ASG0));
-		count_left = mfdcr(DCRN_DMACT0);
-		break;
-	case 1:
-		sgl_addr = (ppc_sgl_t *)bus_to_virt(mfdcr(DCRN_ASG1));
-		count_left = mfdcr(DCRN_DMACT1);
-		break;
-	case 2:
-		sgl_addr = (ppc_sgl_t *)bus_to_virt(mfdcr(DCRN_ASG2));
-		count_left = mfdcr(DCRN_DMACT2);
-		break;
-	case 3:
-		sgl_addr = (ppc_sgl_t *)bus_to_virt(mfdcr(DCRN_ASG3));
-		count_left = mfdcr(DCRN_DMACT3);
-		break;
-	default:
-#ifdef DEBUG_405DMA
-		printk("get_dma_sgl_residue: bad channel: %d\n", psgl->dmanr);
-#endif
-		goto error;
-	}
-
-	if (!sgl_addr) {
-#ifdef DEBUG_405DMA
-		printk("get_dma_sgl_residue: sgl addr register is null\n");
-#endif
-		goto error;
-	}
-
-	pnext = psgl->phead;
-	while (pnext &&
-		((unsigned)pnext < ((unsigned)psgl + SGL_LIST_SIZE) &&
-		(pnext != sgl_addr))
-	      ) {
-		pnext = pnext++;
-	}
-
-	if (pnext == sgl_addr) {           /* found the sgl descriptor */
-
-		*src_addr = pnext->src_addr;
-		*dst_addr = pnext->dst_addr;
-
-		/*
-		 * Now search the remaining descriptors and add their count.
-		 * We already have the remaining count from this descriptor in
-		 * count_left.
-		 */
-		pnext++;
-
-		while ((pnext != psgl->ptail) &&
-			((unsigned)pnext < ((unsigned)psgl + SGL_LIST_SIZE))
-		      ) {
-			count_left += pnext->control_count & SG_COUNT_MASK;
-		}
-
-		if (pnext != psgl->ptail) { /* should never happen */
-#ifdef DEBUG_405DMA
-			printk("get_dma_sgl_residue error (1) psgl->ptail 0x%x handle 0x%x\n",
-				(unsigned int)psgl->ptail,
-				(unsigned int)handle);
-#endif
-			goto error;
-		}
-
-		/* success */
-		p_dma_ch = &dma_channels[psgl->dmanr];
-		return (count_left << p_dma_ch->shift);  /* count in bytes */
-
-	} else {
-	/* this shouldn't happen */
-#ifdef DEBUG_405DMA
-		printk("get_dma_sgl_residue, unable to match current address 0x%x, handle 0x%x\n",
-			(unsigned int)sgl_addr, (unsigned int)handle);
-
-#endif
-	}
-
-
-error:
-	*src_addr = (dma_addr_t)NULL;
-	*dst_addr = (dma_addr_t)NULL;
-	return 0;
-}
-
-
-
-
-/*
- * Returns the address(es) of the buffer(s) contained in the head element of
- * the scatter/gather list.  The element is removed from the scatter/gather
- * list and the next element becomes the head.
- *
- * This function should only be called when the DMA is not active.
- */
-static __inline__ int
-delete_405gp_dma_sgl_element(sgl_handle_t handle, dma_addr_t *src_dma_addr,
-	dma_addr_t *dst_dma_addr)
-{
-	sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-
-#ifdef DEBUG_405DMA
-	if (!handle) {
-		printk("delete_sgl_element: null handle\n");
-		return DMA_STATUS_BAD_HANDLE;
-	} else if (psgl->dmanr > (MAX_405GP_DMA_CHANNELS - 1)) {
-		printk("delete_sgl_element: bad channel in handle %d\n",
-			psgl->dmanr);
-		return DMA_STATUS_BAD_CHANNEL;
-	}
-#endif
-
-	if (!psgl->phead) {
-#ifdef DEBUG_405DMA
-		printk("delete_sgl_element: sgl list empty\n");
-#endif
-		*src_dma_addr = (dma_addr_t)NULL;
-		*dst_dma_addr = (dma_addr_t)NULL;
-		return DMA_STATUS_SGL_LIST_EMPTY;
-	}
-
-	*src_dma_addr = (dma_addr_t)psgl->phead->src_addr;
-	*dst_dma_addr = (dma_addr_t)psgl->phead->dst_addr;
-
-	if (psgl->phead == psgl->ptail) {
-		/* last descriptor on the list */
-		psgl->phead = NULL;
-		psgl->ptail = NULL;
-	} else {
-		psgl->phead++;
-	}
-
-	return DMA_STATUS_GOOD;
-}
-
-#endif /* DCRNCAP_DMA_SG */
-
-/*
- * The rest of the DMA API, in ppc405_dma.c
- */
-extern int hw_init_dma_channel(unsigned int,  ppc_dma_ch_t *);
-extern int get_channel_config(unsigned int, ppc_dma_ch_t *);
-extern int set_channel_priority(unsigned int, unsigned int);
-extern unsigned int get_peripheral_width(unsigned int);
-extern int alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
-extern void free_dma_handle(sgl_handle_t);
-
-#endif
-#endif /* __KERNEL__ */
diff -p -purN linux-2.6.8-rc3-bk2/include/asm-ppc/ppc4xx_dma.h linux-2.6.8-rc3-bk3/include/asm-ppc/ppc4xx_dma.h
--- linux-2.6.8-rc3-bk2/include/asm-ppc/ppc4xx_dma.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/asm-ppc/ppc4xx_dma.h	2004-08-07 22:02:29.000000000 +0000
@@ -0,0 +1,570 @@
+/*
+ * include/asm-ppc/ppc4xx_dma.h
+ *
+ * IBM PPC4xx DMA engine library
+ *
+ * Copyright 2000-2004 MontaVista Software Inc.
+ *
+ * Cleaned up a bit more, Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASMPPC_PPC4xx_DMA_H
+#define __ASMPPC_PPC4xx_DMA_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/mmu.h>
+#include <asm/ibm4xx.h>
+
+#undef DEBUG_4xxDMA
+
+#define MAX_PPC4xx_DMA_CHANNELS		4
+
+/* in arch/ppc/kernel/setup.c -- Cort */
+extern unsigned long DMA_MODE_WRITE, DMA_MODE_READ;
+
+/*
+ * Function return status codes
+ * These values are used to indicate whether or not the function
+ * call was successful, or a bad/invalid parameter was passed.
+ */
+#define DMA_STATUS_GOOD			0
+#define DMA_STATUS_BAD_CHANNEL		1
+#define DMA_STATUS_BAD_HANDLE		2
+#define DMA_STATUS_BAD_MODE		3
+#define DMA_STATUS_NULL_POINTER		4
+#define DMA_STATUS_OUT_OF_MEMORY	5
+#define DMA_STATUS_SGL_LIST_EMPTY	6
+#define DMA_STATUS_GENERAL_ERROR	7
+#define DMA_STATUS_CHANNEL_NOTFREE	8
+
+#define DMA_CHANNEL_BUSY		0x80000000
+
+/*
+ * These indicate status as returned from the DMA Status Register.
+ */
+#define DMA_STATUS_NO_ERROR	0
+#define DMA_STATUS_CS		1	/* Count Status        */
+#define DMA_STATUS_TS		2	/* Transfer Status     */
+#define DMA_STATUS_DMA_ERROR	3	/* DMA Error Occurred  */
+#define DMA_STATUS_DMA_BUSY	4	/* The channel is busy */
+
+
+/*
+ * DMA Channel Control Registers
+ */
+
+#ifdef CONFIG_44x
+#define	PPC4xx_DMA_64BIT
+#define DMA_CR_OFFSET 1
+#else
+#define DMA_CR_OFFSET 0
+#endif
+
+#define DMA_CE_ENABLE        (1<<31)	/* DMA Channel Enable */
+#define SET_DMA_CE_ENABLE(x) (((x)&0x1)<<31)
+#define GET_DMA_CE_ENABLE(x) (((x)&DMA_CE_ENABLE)>>31)
+
+#define DMA_CIE_ENABLE        (1<<30)	/* DMA Channel Interrupt Enable */
+#define SET_DMA_CIE_ENABLE(x) (((x)&0x1)<<30)
+#define GET_DMA_CIE_ENABLE(x) (((x)&DMA_CIE_ENABLE)>>30)
+
+#define DMA_TD                (1<<29)
+#define SET_DMA_TD(x)         (((x)&0x1)<<29)
+#define GET_DMA_TD(x)         (((x)&DMA_TD)>>29)
+
+#define DMA_PL                (1<<28)	/* Peripheral Location */
+#define SET_DMA_PL(x)         (((x)&0x1)<<28)
+#define GET_DMA_PL(x)         (((x)&DMA_PL)>>28)
+
+#define EXTERNAL_PERIPHERAL    0
+#define INTERNAL_PERIPHERAL    1
+
+#define SET_DMA_PW(x)     (((x)&0x3)<<(26-DMA_CR_OFFSET))	/* Peripheral Width */
+#define DMA_PW_MASK       SET_DMA_PW(3)
+#define   PW_8                 0
+#define   PW_16                1
+#define   PW_32                2
+#define   PW_64                3
+/* FIXME: Add PW_128 support for 440GP DMA block */
+#define GET_DMA_PW(x)     (((x)&DMA_PW_MASK)>>(26-DMA_CR_OFFSET))
+
+#define DMA_DAI           (1<<(25-DMA_CR_OFFSET))	/* Destination Address Increment */
+#define SET_DMA_DAI(x)    (((x)&0x1)<<(25-DMA_CR_OFFSET))
+
+#define DMA_SAI           (1<<(24-DMA_CR_OFFSET))	/* Source Address Increment */
+#define SET_DMA_SAI(x)    (((x)&0x1)<<(24-DMA_CR_OFFSET))
+
+#define DMA_BEN           (1<<(23-DMA_CR_OFFSET))	/* Buffer Enable */
+#define SET_DMA_BEN(x)    (((x)&0x1)<<(23-DMA_CR_OFFSET))
+
+#define SET_DMA_TM(x)     (((x)&0x3)<<(21-DMA_CR_OFFSET))	/* Transfer Mode */
+#define DMA_TM_MASK       SET_DMA_TM(3)
+#define   TM_PERIPHERAL        0	/* Peripheral */
+#define   TM_RESERVED          1	/* Reserved */
+#define   TM_S_MM              2	/* Memory to Memory */
+#define   TM_D_MM              3	/* Device Paced Memory to Memory */
+#define GET_DMA_TM(x)     (((x)&DMA_TM_MASK)>>(21-DMA_CR_OFFSET))
+
+#define SET_DMA_PSC(x)    (((x)&0x3)<<(19-DMA_CR_OFFSET))	/* Peripheral Setup Cycles */
+#define DMA_PSC_MASK      SET_DMA_PSC(3)
+#define GET_DMA_PSC(x)    (((x)&DMA_PSC_MASK)>>(19-DMA_CR_OFFSET))
+
+#define SET_DMA_PWC(x)    (((x)&0x3F)<<(13-DMA_CR_OFFSET))	/* Peripheral Wait Cycles */
+#define DMA_PWC_MASK      SET_DMA_PWC(0x3F)
+#define GET_DMA_PWC(x)    (((x)&DMA_PWC_MASK)>>(13-DMA_CR_OFFSET))
+
+#define SET_DMA_PHC(x)    (((x)&0x7)<<(10-DMA_CR_OFFSET))	/* Peripheral Hold Cycles */
+#define DMA_PHC_MASK      SET_DMA_PHC(0x7)
+#define GET_DMA_PHC(x)    (((x)&DMA_PHC_MASK)>>(10-DMA_CR_OFFSET))
+
+#define DMA_ETD_OUTPUT     (1<<(9-DMA_CR_OFFSET))	/* EOT pin is a TC output */
+#define SET_DMA_ETD(x)     (((x)&0x1)<<(9-DMA_CR_OFFSET))
+
+#define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
+#define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
+
+#define DMA_DEC            (1<<(2)	/* Address Decrement */
+#define SET_DMA_DEC(x)     (((x)&0x1)<<2)
+#define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
+
+/*
+ * Transfer Modes
+ * These modes are defined in a way that makes it possible to
+ * simply "or" in the value in the control register.
+ */
+
+#define DMA_MODE_MM		(SET_DMA_TM(TM_S_MM))	/* memory to memory */
+
+				/* Device-paced memory to memory, */
+				/* device is at source address    */
+#define DMA_MODE_MM_DEVATSRC	(DMA_TD | SET_DMA_TM(TM_D_MM))
+
+				/* Device-paced memory to memory,      */
+				/* device is at destination address    */
+#define DMA_MODE_MM_DEVATDST	(SET_DMA_TM(TM_D_MM))
+
+/* 405gp/440gp */
+#define SET_DMA_PREFETCH(x)   (((x)&0x3)<<(4-DMA_CR_OFFSET))	/* Memory Read Prefetch */
+#define DMA_PREFETCH_MASK      SET_DMA_PREFETCH(3)
+#define   PREFETCH_1           0	/* Prefetch 1 Double Word */
+#define   PREFETCH_2           1
+#define   PREFETCH_4           2
+#define GET_DMA_PREFETCH(x) (((x)&DMA_PREFETCH_MASK)>>(4-DMA_CR_OFFSET))
+
+#define DMA_PCE            (1<<(3-DMA_CR_OFFSET))	/* Parity Check Enable */
+#define SET_DMA_PCE(x)     (((x)&0x1)<<(3-DMA_CR_OFFSET))
+#define GET_DMA_PCE(x)     (((x)&DMA_PCE)>>(3-DMA_CR_OFFSET))
+
+/* stb3x */
+
+#define DMA_ECE_ENABLE (1<<5)
+#define SET_DMA_ECE(x) (((x)&0x1)<<5)
+#define GET_DMA_ECE(x) (((x)&DMA_ECE_ENABLE)>>5)
+
+#define DMA_TCD_DISABLE	(1<<4)
+#define SET_DMA_TCD(x) (((x)&0x1)<<4)
+#define GET_DMA_TCD(x) (((x)&DMA_TCD_DISABLE)>>4)
+
+typedef uint32_t sgl_handle_t;
+
+#ifdef CONFIG_PPC4xx_EDMA
+
+#define SGL_LIST_SIZE 4096
+#define DMA_PPC4xx_SIZE SGL_LIST_SIZE
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x3)<<(6-DMA_CR_OFFSET))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK SET_DMA_PRIORITY(3)
+#define PRIORITY_LOW           0
+#define PRIORITY_MID_LOW       1
+#define PRIORITY_MID_HIGH      2
+#define PRIORITY_HIGH          3
+#define GET_DMA_PRIORITY(x) (((x)&DMA_PRIORITY_MASK)>>(6-DMA_CR_OFFSET))
+
+/*
+ * DMA Polarity Configuration Register
+ */
+#define DMAReq_ActiveLow(chan) (1<<(31-(chan*3)))
+#define DMAAck_ActiveLow(chan) (1<<(30-(chan*3)))
+#define EOT_ActiveLow(chan)    (1<<(29-(chan*3)))	/* End of Transfer */
+
+/*
+ * DMA Sleep Mode Register
+ */
+#define SLEEP_MODE_ENABLE (1<<21)
+
+/*
+ * DMA Status Register
+ */
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_IN_DMA_REQ0   (1<<19)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<18)
+#define DMA_IN_DMA_REQ2   (1<<17)
+#define DMA_IN_DMA_REQ3   (1<<16)
+
+#define DMA_EXT_DMA_REQ0  (1<<15)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<14)
+#define DMA_EXT_DMA_REQ2  (1<<13)
+#define DMA_EXT_DMA_REQ3  (1<<12)
+
+#define DMA_CH0_BUSY      (1<<11)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<10)
+#define DMA_CH2_BUSY       (1<<9)
+#define DMA_CH3_BUSY       (1<<8)
+
+#define DMA_SG0            (1<<7)	/* DMA Channel 0 Scatter/Gather in progress */
+#define DMA_SG1            (1<<6)
+#define DMA_SG2            (1<<5)
+#define DMA_SG3            (1<<4)
+
+/*
+ * DMA SG Command Register
+ */
+#define SSG_ENABLE(chan)   	(1<<(31-chan))	/* Start Scatter Gather */
+#define SSG_MASK_ENABLE(chan)	(1<<(15-chan))	/* Enable writing to SSG0 bit */
+
+/*
+ * DMA Scatter/Gather Descriptor Bit fields
+ */
+#define SG_LINK            (1<<31)	/* Link */
+#define SG_TCI_ENABLE      (1<<29)	/* Enable Terminal Count Interrupt */
+#define SG_ETI_ENABLE      (1<<28)	/* Enable End of Transfer Interrupt */
+#define SG_ERI_ENABLE      (1<<27)	/* Enable Error Interrupt */
+#define SG_COUNT_MASK       0xFFFF	/* Count Field */
+
+#define SET_DMA_CONTROL \
+ 		(SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */ \
+ 		SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */\
+		SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */ \
+	       	SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */ \
+                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */ \
+                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */ \
+                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */ \
+                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */ \
+                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */)
+
+#define GET_DMA_POLARITY(chan) (DMAReq_ActiveLow(chan) | DMAAck_ActiveLow(chan) | EOT_ActiveLow(chan))
+
+#elif defined(CONFIG_STBXXX_DMA)		/* stb03xxx */
+
+#define DMA_PPC4xx_SIZE	4096
+
+/*
+ * DMA Status Register
+ */
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x00800001))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK	0x00800001
+#define   PRIORITY_LOW         	0x00000000
+#define   PRIORITY_MID_LOW     	0x00000001
+#define   PRIORITY_MID_HIGH    	0x00800000
+#define   PRIORITY_HIGH        	0x00800001
+#define GET_DMA_PRIORITY(x) (((((x)&DMA_PRIORITY_MASK) &0x00800000) >> 22 ) | (((x)&DMA_PRIORITY_MASK) &0x00000001))
+
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_CT0		  (1<<19)	/* Chained transfere */
+
+#define DMA_IN_DMA_REQ0   (1<<18)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<17)
+#define DMA_IN_DMA_REQ2   (1<<16)
+#define DMA_IN_DMA_REQ3   (1<<15)
+
+#define DMA_EXT_DMA_REQ0  (1<<14)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<13)
+#define DMA_EXT_DMA_REQ2  (1<<12)
+#define DMA_EXT_DMA_REQ3  (1<<11)
+
+#define DMA_CH0_BUSY      (1<<10)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<9)
+#define DMA_CH2_BUSY       (1<<8)
+#define DMA_CH3_BUSY       (1<<7)
+
+#define DMA_CT1            (1<<6)	/* Chained transfere */
+#define DMA_CT2            (1<<5)
+#define DMA_CT3            (1<<4)
+
+#define DMA_CH_ENABLE (1<<7)
+#define SET_DMA_CH(x) (((x)&0x1)<<7)
+#define GET_DMA_CH(x) (((x)&DMA_CH_ENABLE)>>7)
+
+/* STBx25xxx dma unique */
+/* enable device port on a dma channel
+ * example ext 0 on dma 1
+ */
+
+#define	SSP0_RECV	15
+#define	SSP0_XMIT	14
+#define EXT_DMA_0	12
+#define	SC1_XMIT	11
+#define SC1_RECV	10
+#define EXT_DMA_2	9
+#define	EXT_DMA_3	8
+#define SERIAL2_XMIT	7
+#define SERIAL2_RECV	6
+#define SC0_XMIT 	5
+#define	SC0_RECV	4
+#define	SERIAL1_XMIT	3
+#define SERIAL1_RECV	2
+#define	SERIAL0_XMIT	1
+#define SERIAL0_RECV	0
+
+#define DMA_CHAN_0	1
+#define DMA_CHAN_1	2
+#define DMA_CHAN_2	3
+#define DMA_CHAN_3	4
+
+/* end STBx25xx */
+
+/*
+ * Bit 30 must be one for Redwoods, otherwise transfers may receive errors.
+ */
+#define DMA_CR_MB0 0x2
+
+#define SET_DMA_CONTROL \
+       		(SET_DMA_CIE_ENABLE(p_init->int_enable) |  /* interrupt enable         */ \
+		SET_DMA_ETD(p_init->etd_output)        |  /* end of transfer pin      */ \
+		SET_DMA_TCE(p_init->tce_enable)        |  /* terminal count enable    */ \
+		SET_DMA_PL(p_init->pl)                 |  /* peripheral location      */ \
+		SET_DMA_DAI(p_init->dai)               |  /* dest addr increment      */ \
+		SET_DMA_SAI(p_init->sai)               |  /* src addr increment       */ \
+		SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */  \
+		SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+		SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+		SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+		SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+		SET_DMA_TCD(p_init->tcd_disable)	  |  /* TC chain mode disable   */ \
+		SET_DMA_ECE(p_init->ece_enable)	  |  /* ECE chanin mode enable  */ \
+		SET_DMA_CH(p_init->ch_enable)	|    /* Chain enable 	        */ \
+		DMA_CR_MB0				/* must be one */)
+
+#define GET_DMA_POLARITY(chan) chan
+
+#endif
+
+typedef struct {
+	unsigned short in_use;	/* set when channel is being used, clr when
+				 * available.
+				 */
+	/*
+	 * Valid polarity settings:
+	 *   DMAReq_ActiveLow(n)
+	 *   DMAAck_ActiveLow(n)
+	 *   EOT_ActiveLow(n)
+	 *
+	 *   n is 0 to max dma chans
+	 */
+	unsigned int polarity;
+
+	char buffer_enable;	/* Boolean: buffer enable            */
+	char tce_enable;	/* Boolean: terminal count enable    */
+	char etd_output;	/* Boolean: eot pin is a tc output   */
+	char pce;		/* Boolean: parity check enable      */
+
+	/*
+	 * Peripheral location:
+	 * INTERNAL_PERIPHERAL (UART0 on the 405GP)
+	 * EXTERNAL_PERIPHERAL
+	 */
+	char pl;		/* internal/external peripheral      */
+
+	/*
+	 * Valid pwidth settings:
+	 *   PW_8
+	 *   PW_16
+	 *   PW_32
+	 *   PW_64
+	 */
+	unsigned int pwidth;
+
+	char dai;		/* Boolean: dst address increment   */
+	char sai;		/* Boolean: src address increment   */
+
+	/*
+	 * Valid psc settings: 0-3
+	 */
+	unsigned int psc;	/* Peripheral Setup Cycles         */
+
+	/*
+	 * Valid pwc settings:
+	 * 0-63
+	 */
+	unsigned int pwc;	/* Peripheral Wait Cycles          */
+
+	/*
+	 * Valid phc settings:
+	 * 0-7
+	 */
+	unsigned int phc;	/* Peripheral Hold Cycles          */
+
+	/*
+	 * Valid cp (channel priority) settings:
+	 *   PRIORITY_LOW
+	 *   PRIORITY_MID_LOW
+	 *   PRIORITY_MID_HIGH
+	 *   PRIORITY_HIGH
+	 */
+	unsigned int cp;	/* channel priority                */
+
+	/*
+	 * Valid pf (memory read prefetch) settings:
+	 *
+	 *   PREFETCH_1
+	 *   PREFETCH_2
+	 *   PREFETCH_4
+	 */
+	unsigned int pf;	/* memory read prefetch            */
+
+	/*
+	 * Boolean: channel interrupt enable
+	 * NOTE: for sgl transfers, only the last descriptor will be setup to
+	 * interrupt.
+	 */
+	char int_enable;
+
+	char shift;		/* easy access to byte_count shift, based on */
+	/* the width of the channel                  */
+
+	uint32_t control;	/* channel control word                      */
+
+	/* These variabled are used ONLY in single dma transfers              */
+	unsigned int mode;	/* transfer mode                     */
+	phys_addr_t addr;
+	char ce;		/* channel enable */
+#ifdef CONFIG_STB03xxx
+	char ch_enable;
+	char tcd_disable;
+	char ece_enable;
+	char td;		/* transfer direction */
+#endif
+
+} ppc_dma_ch_t;
+
+/*
+ * PPC44x DMA implementations have a slightly different
+ * descriptor layout.  Probably moved about due to the
+ * change to 64-bit addresses and link pointer. I don't
+ * know why they didn't just leave control_count after
+ * the dst_addr.
+ */
+#ifdef PPC4xx_DMA_64BIT
+typedef struct {
+	uint32_t control;
+	uint32_t control_count;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	phys_addr_t next;
+} ppc_sgl_t;
+#else
+typedef struct {
+	uint32_t control;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	uint32_t control_count;
+	uint32_t next;
+} ppc_sgl_t;
+#endif
+
+typedef struct {
+	unsigned int dmanr;
+	uint32_t control;	/* channel ctrl word; loaded from each descrptr */
+	uint32_t sgl_control;	/* LK, TCI, ETI, and ERI bits in sgl descriptor */
+	dma_addr_t dma_addr;	/* dma (physical) address of this list          */
+	ppc_sgl_t *phead;
+	dma_addr_t phead_dma;
+	ppc_sgl_t *ptail;
+	dma_addr_t ptail_dma;
+} sgl_list_info_t;
+
+typedef struct {
+	phys_addr_t *src_addr;
+	phys_addr_t *dst_addr;
+	phys_addr_t dma_src_addr;
+	phys_addr_t dma_dst_addr;
+} pci_alloc_desc_t;
+
+extern ppc_dma_ch_t dma_channels[];
+
+/*
+ * The DMA API are in ppc4xx_dma.c and ppc4xx_sgdma.c
+ */
+extern int ppc4xx_init_dma_channel(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_get_channel_config(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_set_channel_priority(unsigned int, unsigned int);
+extern unsigned int ppc4xx_get_peripheral_width(unsigned int);
+extern void ppc4xx_set_sg_addr(int, phys_addr_t);
+extern int ppc4xx_add_dma_sgl(sgl_handle_t, phys_addr_t, phys_addr_t, unsigned int);
+extern void ppc4xx_enable_dma_sgl(sgl_handle_t);
+extern void ppc4xx_disable_dma_sgl(sgl_handle_t);
+extern int ppc4xx_get_dma_sgl_residue(sgl_handle_t, phys_addr_t *, phys_addr_t *);
+extern int ppc4xx_delete_dma_sgl_element(sgl_handle_t, phys_addr_t *, phys_addr_t *);
+extern int ppc4xx_alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
+extern void ppc4xx_free_dma_handle(sgl_handle_t);
+extern int ppc4xx_get_dma_status(void);
+extern void ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr);
+extern void ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr);
+extern void ppc4xx_enable_dma(unsigned int dmanr);
+extern void ppc4xx_disable_dma(unsigned int dmanr);
+extern void ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count);
+extern int ppc4xx_get_dma_residue(unsigned int dmanr);
+extern void ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+				 phys_addr_t dst_dma_addr);
+extern int ppc4xx_enable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_disable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_clr_dma_status(unsigned int dmanr);
+extern int ppc4xx_map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode);
+
+/* These are in kernel/dma.c: */
+
+/* reserve a DMA channel */
+extern int request_dma(unsigned int dmanr, const char *device_id);
+/* release it again */
+extern void free_dma(unsigned int dmanr);
+#endif
+#endif				/* __KERNEL__ */
diff -p -purN linux-2.6.8-rc3-bk2/include/asm-ppc64/irq.h linux-2.6.8-rc3-bk3/include/asm-ppc64/irq.h
--- linux-2.6.8-rc3-bk2/include/asm-ppc64/irq.h	2004-06-16 05:20:26.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/asm-ppc64/irq.h	2004-08-08 17:25:03.857122360 +0000
@@ -9,8 +9,8 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#include <linux/config.h>
 #include <linux/threads.h>
-#include <asm/atomic.h>
 
 /*
  * Maximum number of interrupt sources that we can handle.
@@ -46,6 +46,8 @@ static inline unsigned int virt_irq_to_r
 	return virt_irq_to_real_map[virt_irq];
 }
 
+extern unsigned int real_irq_to_virt_slowpath(unsigned int real_irq);
+
 /*
  * Because many systems have two overlapping names spaces for
  * interrupts (ISA and XICS for example), and the ISA interrupts
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/coda_proc.h linux-2.6.8-rc3-bk3/include/linux/coda_proc.h
--- linux-2.6.8-rc3-bk2/include/linux/coda_proc.h	2004-06-16 05:18:52.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/coda_proc.h	2004-08-08 17:25:03.859122056 +0000
@@ -82,10 +82,10 @@ void reset_coda_cache_inv_stats( void );
  * data structure for /proc/sys/... files 
  */
 int do_reset_coda_vfs_stats( ctl_table * table, int write, struct file * filp,
-			     void __user * buffer, size_t * lenp );
+			     void __user * buffer, size_t * lenp, loff_t * ppos );
 int do_reset_coda_cache_inv_stats( ctl_table * table, int write, 
 				   struct file * filp, void __user * buffer, 
-				   size_t * lenp );
+				   size_t * lenp, loff_t * ppos );
 
 /* these functions are called to form the content of /proc/fs/coda/... files */
 int coda_vfs_stats_get_info( char * buffer, char ** start, off_t offset,
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/fs.h linux-2.6.8-rc3-bk3/include/linux/fs.h
--- linux-2.6.8-rc3-bk2/include/linux/fs.h	2004-08-08 17:24:48.877399624 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/fs.h	2004-08-08 17:25:03.864121296 +0000
@@ -75,6 +75,11 @@ extern int leases_enable, dir_notify_ena
 #define FMODE_READ 1
 #define FMODE_WRITE 2
 
+/* Internal kernel extensions */
+#define FMODE_LSEEK	4
+#define FMODE_PREAD	8
+#define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
+
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0
@@ -1430,6 +1435,7 @@ extern loff_t no_llseek(struct file *fil
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);
 extern int generic_file_open(struct inode * inode, struct file * filp);
+extern int nonseekable_open(struct inode * inode, struct file * filp);
 
 static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
 					read_descriptor_t * desc,
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/hugetlb.h linux-2.6.8-rc3-bk3/include/linux/hugetlb.h
--- linux-2.6.8-rc3-bk2/include/linux/hugetlb.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/hugetlb.h	2004-08-08 17:25:03.866120992 +0000
@@ -12,7 +12,7 @@ static inline int is_vm_hugetlb_page(str
 	return vma->vm_flags & VM_HUGETLB;
 }
 
-int hugetlb_sysctl_handler(struct ctl_table *, int, struct file *, void __user *, size_t *);
+int hugetlb_sysctl_handler(struct ctl_table *, int, struct file *, void __user *, size_t *, loff_t *);
 int copy_hugetlb_page_range(struct mm_struct *, struct mm_struct *, struct vm_area_struct *);
 int follow_hugetlb_page(struct mm_struct *, struct vm_area_struct *, struct page **, struct vm_area_struct **, unsigned long *, int *, int);
 void zap_hugepage_range(struct vm_area_struct *, unsigned long, unsigned long);
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/mmzone.h linux-2.6.8-rc3-bk3/include/linux/mmzone.h
--- linux-2.6.8-rc3-bk2/include/linux/mmzone.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/mmzone.h	2004-08-08 17:25:03.868120688 +0000
@@ -374,9 +374,9 @@ static inline int is_normal(struct zone 
 struct ctl_table;
 struct file;
 int min_free_kbytes_sysctl_handler(struct ctl_table *, int, struct file *, 
-					void __user *, size_t *);
+					void __user *, size_t *, loff_t *);
 int lower_zone_protection_sysctl_handler(struct ctl_table *, int, struct file *,
-					void __user *, size_t *);
+					void __user *, size_t *, loff_t *);
 
 #include <linux/topology.h>
 /* Returns the number of the current Node. */
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/netdevice.h linux-2.6.8-rc3-bk3/include/linux/netdevice.h
--- linux-2.6.8-rc3-bk2/include/linux/netdevice.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/netdevice.h	2004-08-08 17:25:03.874119776 +0000
@@ -362,8 +362,8 @@ struct net_device
 
 	struct Qdisc		*qdisc;
 	struct Qdisc		*qdisc_sleeping;
-	struct Qdisc		*qdisc_list;
 	struct Qdisc		*qdisc_ingress;
+	struct list_head	qdisc_list;
 	unsigned long		tx_queue_len;	/* Max frames per queue allowed */
 
 	/* ingress path synchronizer */
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/skbuff.h linux-2.6.8-rc3-bk3/include/linux/skbuff.h
--- linux-2.6.8-rc3-bk2/include/linux/skbuff.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/skbuff.h	2004-08-08 17:25:03.878119168 +0000
@@ -1108,6 +1108,22 @@ extern void	       skb_split(struct sk_b
 extern void skb_init(void);
 extern void skb_add_mtu(int mtu);
 
+struct skb_iter {
+	/* Iteration functions set these */
+	unsigned char *data;
+	unsigned int len;
+
+	/* Private to iteration */
+	unsigned int nextfrag;
+	struct sk_buff *fraglist;
+};
+
+/* Keep iterating until skb_iter_next returns false. */
+extern void skb_iter_first(const struct sk_buff *skb, struct skb_iter *i);
+extern int skb_iter_next(const struct sk_buff *skb, struct skb_iter *i);
+/* Call this if aborting loop before !skb_iter_next */
+extern void skb_iter_abort(const struct sk_buff *skb, struct skb_iter *i);
+
 #ifdef CONFIG_NETFILTER
 static inline void nf_conntrack_put(struct nf_ct_info *nfct)
 {
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/sysctl.h linux-2.6.8-rc3-bk3/include/linux/sysctl.h
--- linux-2.6.8-rc3-bk2/include/linux/sysctl.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/sysctl.h	2004-08-08 17:25:03.881118712 +0000
@@ -762,24 +762,24 @@ typedef int ctl_handler (ctl_table *tabl
 			 void **context);
 
 typedef int proc_handler (ctl_table *ctl, int write, struct file * filp,
-			  void __user *buffer, size_t *lenp);
+			  void __user *buffer, size_t *lenp, loff_t *ppos);
 
 extern int proc_dostring(ctl_table *, int, struct file *,
-			 void __user *, size_t *);
+			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec(ctl_table *, int, struct file *,
-			 void __user *, size_t *);
+			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_bset(ctl_table *, int, struct file *,
-			      void __user *, size_t *);
+			      void __user *, size_t *, loff_t *);
 extern int proc_dointvec_minmax(ctl_table *, int, struct file *,
-				void __user *, size_t *);
+				void __user *, size_t *, loff_t *);
 extern int proc_dointvec_jiffies(ctl_table *, int, struct file *,
-				 void __user *, size_t *);
+				 void __user *, size_t *, loff_t *);
 extern int proc_dointvec_userhz_jiffies(ctl_table *, int, struct file *,
-					void __user *, size_t *);
+					void __user *, size_t *, loff_t *);
 extern int proc_doulongvec_minmax(ctl_table *, int, struct file *,
-				  void __user *, size_t *);
+				  void __user *, size_t *, loff_t *);
 extern int proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int,
-				      struct file *, void __user *, size_t *);
+				      struct file *, void __user *, size_t *, loff_t *);
 
 extern int do_sysctl (int __user *name, int nlen,
 		      void __user *oldval, size_t __user *oldlenp,
diff -p -purN linux-2.6.8-rc3-bk2/include/linux/writeback.h linux-2.6.8-rc3-bk3/include/linux/writeback.h
--- linux-2.6.8-rc3-bk2/include/linux/writeback.h	2004-06-16 05:18:58.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/linux/writeback.h	2004-08-08 17:25:03.883118408 +0000
@@ -86,7 +86,7 @@ extern int laptop_mode;
 struct ctl_table;
 struct file;
 int dirty_writeback_centisecs_handler(struct ctl_table *, int, struct file *,
-				      void __user *, size_t *);
+				      void __user *, size_t *, loff_t *);
 
 void page_writeback_init(void);
 void balance_dirty_pages_ratelimited(struct address_space *mapping);
diff -p -purN linux-2.6.8-rc3-bk2/include/net/ip.h linux-2.6.8-rc3-bk3/include/net/ip.h
--- linux-2.6.8-rc3-bk2/include/net/ip.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/net/ip.h	2004-08-08 17:25:03.885118104 +0000
@@ -301,7 +301,7 @@ extern int ipv4_proc_init(void);
  */
 int ipv4_doint_and_flush(ctl_table *ctl, int write,
 			 struct file* filp, void __user *buffer,
-			 size_t *lenp);
+			 size_t *lenp, loff_t *ppos);
 int ipv4_doint_and_flush_strategy(ctl_table *table, int __user *name, int nlen,
 				  void __user *oldval, size_t __user *oldlenp,
 				  void __user *newval, size_t newlen, 
diff -p -purN linux-2.6.8-rc3-bk2/include/net/ndisc.h linux-2.6.8-rc3-bk3/include/net/ndisc.h
--- linux-2.6.8-rc3-bk2/include/net/ndisc.h	2004-06-16 05:19:44.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/net/ndisc.h	2004-08-08 17:25:03.887117800 +0000
@@ -103,7 +103,8 @@ extern int 			ndisc_ifinfo_sysctl_change
 							   int write,
 							   struct file * filp,
 							   void __user *buffer,
-							   size_t *lenp);
+							   size_t *lenp,
+							   loff_t *ppos);
 #endif
 
 extern void 			inet6_ifinfo_notify(int event,
diff -p -purN linux-2.6.8-rc3-bk2/include/net/pkt_sched.h linux-2.6.8-rc3-bk3/include/net/pkt_sched.h
--- linux-2.6.8-rc3-bk2/include/net/pkt_sched.h	2004-08-08 17:21:39.000000000 +0000
+++ linux-2.6.8-rc3-bk3/include/net/pkt_sched.h	2004-08-08 17:25:03.890117344 +0000
@@ -77,12 +77,13 @@ struct Qdisc
 #define TCQ_F_BUILTIN	1
 #define TCQ_F_THROTTLED	2
 #define TCQ_F_INGRES	4
+	int			padded;
 	struct Qdisc_ops	*ops;
-	struct Qdisc		*next;
 	u32			handle;
 	atomic_t		refcnt;
 	struct sk_buff_head	q;
 	struct net_device	*dev;
+	struct list_head	list;
 
 	struct tc_stats		stats;
 	spinlock_t		*stats_lock;
@@ -93,10 +94,17 @@ struct Qdisc
 	 * and it will live until better solution will be invented.
 	 */
 	struct Qdisc		*__parent;
-
-	char			data[0];
 };
 
+#define	QDISC_ALIGN		32
+#define	QDISC_ALIGN_CONST	(QDISC_ALIGN - 1)
+
+static inline void *qdisc_priv(struct Qdisc *q)
+{
+	return (char *)q + ((sizeof(struct Qdisc) + QDISC_ALIGN_CONST)
+			      & ~QDISC_ALIGN_CONST);
+}
+
 struct qdisc_rate_table
 {
 	struct tc_ratespec rate;
diff -p -purN linux-2.6.8-rc3-bk2/kernel/sysctl.c linux-2.6.8-rc3-bk3/kernel/sysctl.c
--- linux-2.6.8-rc3-bk2/kernel/sysctl.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/kernel/sysctl.c	2004-08-08 17:25:03.898116128 +0000
@@ -123,7 +123,7 @@ extern int acct_parm[];
 static int parse_table(int __user *, int, void __user *, size_t __user *, void __user *, size_t,
 		       ctl_table *, void **);
 static int proc_doutsstring(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp);
+		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
 static ctl_table root_table[];
 static struct ctl_table_header root_table_header =
@@ -1287,11 +1287,7 @@ static ssize_t do_rw_proc(int write, str
 	
 	res = count;
 
-	/*
-	 * FIXME: we need to pass on ppos to the handler.
-	 */
-
-	error = (*table->proc_handler) (table, write, file, buf, &res);
+	error = (*table->proc_handler) (table, write, file, buf, &res, ppos);
 	if (error)
 		return error;
 	return res;
@@ -1341,14 +1337,14 @@ static ssize_t proc_writesys(struct file
  * Returns 0 on success.
  */
 int proc_dostring(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	size_t len;
 	char __user *p;
 	char c;
 	
 	if (!table->data || !table->maxlen || !*lenp ||
-	    (filp->f_pos && !write)) {
+	    (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -1368,7 +1364,7 @@ int proc_dostring(ctl_table *table, int 
 		if(copy_from_user(table->data, buffer, len))
 			return -EFAULT;
 		((char *) table->data)[len] = 0;
-		filp->f_pos += *lenp;
+		*ppos += *lenp;
 	} else {
 		len = strlen(table->data);
 		if (len > table->maxlen)
@@ -1384,7 +1380,7 @@ int proc_dostring(ctl_table *table, int 
 			len++;
 		}
 		*lenp = len;
-		filp->f_pos += len;
+		*ppos += len;
 	}
 	return 0;
 }
@@ -1395,17 +1391,17 @@ int proc_dostring(ctl_table *table, int 
  */
  
 static int proc_doutsstring(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int r;
 
 	if (!write) {
 		down_read(&uts_sem);
-		r=proc_dostring(table,0,filp,buffer,lenp);
+		r=proc_dostring(table,0,filp,buffer,lenp, ppos);
 		up_read(&uts_sem);
 	} else {
 		down_write(&uts_sem);
-		r=proc_dostring(table,1,filp,buffer,lenp);
+		r=proc_dostring(table,1,filp,buffer,lenp, ppos);
 		up_write(&uts_sem);
 	}
 	return r;
@@ -1431,7 +1427,7 @@ static int do_proc_dointvec_conv(int *ne
 }
 
 static int do_proc_dointvec(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp, 
+		  void __user *buffer, size_t *lenp, loff_t *ppos,
 		  int (*conv)(int *negp, unsigned long *lvalp, int *valp,
 			      int write, void *data),
 		  void *data)
@@ -1445,7 +1441,7 @@ static int do_proc_dointvec(ctl_table *t
 	char __user *s = buffer;
 	
 	if (!table->data || !table->maxlen || !*lenp ||
-	    (filp->f_pos && !write)) {
+	    (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -1534,7 +1530,7 @@ static int do_proc_dointvec(ctl_table *t
 	if (write && first)
 		return -EINVAL;
 	*lenp -= left;
-	filp->f_pos += *lenp;
+	*ppos += *lenp;
 	return 0;
 #undef TMPBUFLEN
 }
@@ -1553,9 +1549,9 @@ static int do_proc_dointvec(ctl_table *t
  * Returns 0 on success.
  */
 int proc_dointvec(ctl_table *table, int write, struct file *filp,
-		     void __user *buffer, size_t *lenp)
+		     void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-    return do_proc_dointvec(table,write,filp,buffer,lenp,
+    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
 		    	    NULL,NULL);
 }
 
@@ -1601,7 +1597,7 @@ static int do_proc_dointvec_bset_conv(in
  */
  
 int proc_dointvec_bset(ctl_table *table, int write, struct file *filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int op;
 
@@ -1610,7 +1606,7 @@ int proc_dointvec_bset(ctl_table *table,
 	}
 
 	op = (current->pid == 1) ? OP_SET : OP_AND;
-	return do_proc_dointvec(table,write,filp,buffer,lenp,
+	return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
 				do_proc_dointvec_bset_conv,&op);
 }
 
@@ -1660,19 +1656,20 @@ static int do_proc_dointvec_minmax_conv(
  * Returns 0 on success.
  */
 int proc_dointvec_minmax(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	struct do_proc_dointvec_minmax_conv_param param = {
 		.min = (int *) table->extra1,
 		.max = (int *) table->extra2,
 	};
-	return do_proc_dointvec(table, write, filp, buffer, lenp,
+	return do_proc_dointvec(table, write, filp, buffer, lenp, ppos,
 				do_proc_dointvec_minmax_conv, &param);
 }
 
 static int do_proc_doulongvec_minmax(ctl_table *table, int write,
 				     struct file *filp,
-				     void __user *buffer, size_t *lenp,
+				     void __user *buffer,
+				     size_t *lenp, loff_t *ppos,
 				     unsigned long convmul,
 				     unsigned long convdiv)
 {
@@ -1684,7 +1681,7 @@ static int do_proc_doulongvec_minmax(ctl
 	char __user *s = buffer;
 	
 	if (!table->data || !table->maxlen || !*lenp ||
-	    (filp->f_pos && !write)) {
+	    (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -1769,7 +1766,7 @@ static int do_proc_doulongvec_minmax(ctl
 	if (write && first)
 		return -EINVAL;
 	*lenp -= left;
-	filp->f_pos += *lenp;
+	*ppos += *lenp;
 	return 0;
 #undef TMPBUFLEN
 }
@@ -1791,9 +1788,9 @@ static int do_proc_doulongvec_minmax(ctl
  * Returns 0 on success.
  */
 int proc_doulongvec_minmax(ctl_table *table, int write, struct file *filp,
-			   void __user *buffer, size_t *lenp)
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-    return do_proc_doulongvec_minmax(table, write, filp, buffer, lenp, 1l, 1l);
+    return do_proc_doulongvec_minmax(table, write, filp, buffer, lenp, ppos, 1l, 1l);
 }
 
 /**
@@ -1815,10 +1812,11 @@ int proc_doulongvec_minmax(ctl_table *ta
  */
 int proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int write,
 				      struct file *filp,
-				      void __user *buffer, size_t *lenp)
+				      void __user *buffer,
+				      size_t *lenp, loff_t *ppos)
 {
     return do_proc_doulongvec_minmax(table, write, filp, buffer,
-				     lenp, HZ, 1000l);
+				     lenp, ppos, HZ, 1000l);
 }
 
 
@@ -1880,9 +1878,9 @@ static int do_proc_dointvec_userhz_jiffi
  * Returns 0 on success.
  */
 int proc_dointvec_jiffies(ctl_table *table, int write, struct file *filp,
-			  void __user *buffer, size_t *lenp)
+			  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-    return do_proc_dointvec(table,write,filp,buffer,lenp,
+    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
 		    	    do_proc_dointvec_jiffies_conv,NULL);
 }
 
@@ -1902,65 +1900,66 @@ int proc_dointvec_jiffies(ctl_table *tab
  * Returns 0 on success.
  */
 int proc_dointvec_userhz_jiffies(ctl_table *table, int write, struct file *filp,
-				 void __user *buffer, size_t *lenp)
+				 void __user *buffer, size_t *lenp, loff_t *ppos)
 {
-    return do_proc_dointvec(table,write,filp,buffer,lenp,
+    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
 		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
 }
 
 #else /* CONFIG_PROC_FS */
 
 int proc_dostring(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 static int proc_doutsstring(ctl_table *table, int write, struct file *filp,
-			    void __user *buffer, size_t *lenp)
+			    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_bset(ctl_table *table, int write, struct file *filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_minmax(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_jiffies(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_userhz_jiffies(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_doulongvec_minmax(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int write,
 				      struct file *filp,
-				      void __user *buffer, size_t *lenp)
+				      void __user *buffer,
+				      size_t *lenp, loff_t *ppos)
 {
     return -ENOSYS;
 }
@@ -2111,50 +2110,51 @@ int sysctl_jiffies(ctl_table *table, int
 }
 
 int proc_dostring(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec(ctl_table *table, int write, struct file *filp,
-		  void __user *buffer, size_t *lenp)
+		  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_bset(ctl_table *table, int write, struct file *filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_minmax(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_jiffies(ctl_table *table, int write, struct file *filp,
-			  void __user *buffer, size_t *lenp)
+			  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_dointvec_userhz_jiffies(ctl_table *table, int write, struct file *filp,
-			  void __user *buffer, size_t *lenp)
+			  void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_doulongvec_minmax(ctl_table *table, int write, struct file *filp,
-		    void __user *buffer, size_t *lenp)
+		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	return -ENOSYS;
 }
 
 int proc_doulongvec_ms_jiffies_minmax(ctl_table *table, int write,
 				      struct file *filp,
-				      void __user *buffer, size_t *lenp)
+				      void __user *buffer,
+				      size_t *lenp, loff_t *ppos)
 {
     return -ENOSYS;
 }
diff -p -purN linux-2.6.8-rc3-bk2/lib/vsprintf.c linux-2.6.8-rc3-bk3/lib/vsprintf.c
--- linux-2.6.8-rc3-bk2/lib/vsprintf.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/lib/vsprintf.c	2004-08-08 17:25:03.901115672 +0000
@@ -668,8 +668,16 @@ int vsscanf(const char * buf, const char
 		qualifier = -1;
 		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
 		    *fmt == 'Z' || *fmt == 'z') {
-			qualifier = *fmt;
-			fmt++;
+			qualifier = *fmt++;
+			if (unlikely(qualifier == *fmt)) {
+				if (qualifier == 'h') {
+					qualifier = 'H';
+					fmt++;
+				} else if (qualifier == 'l') {
+					qualifier = 'L';
+					fmt++;
+				}
+			}
 		}
 		base = 10;
 		is_sign = 0;
@@ -754,6 +762,15 @@ int vsscanf(const char * buf, const char
 				break;
 
 		switch(qualifier) {
+		case 'H':	/* that's 'hh' in format */
+			if (is_sign) {
+				signed char *s = (signed char *) va_arg(args,signed char *);
+				*s = (signed char) simple_strtol(str,&next,base);
+			} else {
+				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
+				*s = (unsigned char) simple_strtoul(str, &next, base);
+			}
+			break;
 		case 'h':
 			if (is_sign) {
 				short *s = (short *) va_arg(args,short *);
diff -p -purN linux-2.6.8-rc3-bk2/mm/hugetlb.c linux-2.6.8-rc3-bk3/mm/hugetlb.c
--- linux-2.6.8-rc3-bk2/mm/hugetlb.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/mm/hugetlb.c	2004-08-08 17:25:03.903115368 +0000
@@ -191,9 +191,9 @@ static unsigned long set_max_huge_pages(
 #ifdef CONFIG_SYSCTL
 int hugetlb_sysctl_handler(struct ctl_table *table, int write,
 			   struct file *file, void __user *buffer,
-			   size_t *length)
+			   size_t *length, loff_t *ppos)
 {
-	proc_doulongvec_minmax(table, write, file, buffer, length);
+	proc_doulongvec_minmax(table, write, file, buffer, length, ppos);
 	max_huge_pages = set_max_huge_pages(max_huge_pages);
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/mm/page-writeback.c linux-2.6.8-rc3-bk3/mm/page-writeback.c
--- linux-2.6.8-rc3-bk2/mm/page-writeback.c	2004-06-16 05:19:42.000000000 +0000
+++ linux-2.6.8-rc3-bk3/mm/page-writeback.c	2004-08-08 17:25:03.906114912 +0000
@@ -399,9 +399,9 @@ static void wb_kupdate(unsigned long arg
  * sysctl handler for /proc/sys/vm/dirty_writeback_centisecs
  */
 int dirty_writeback_centisecs_handler(ctl_table *table, int write,
-		struct file *file, void __user *buffer, size_t *length)
+		struct file *file, void __user *buffer, size_t *length, loff_t *ppos)
 {
-	proc_dointvec(table, write, file, buffer, length);
+	proc_dointvec(table, write, file, buffer, length, ppos);
 	if (dirty_writeback_centisecs) {
 		mod_timer(&wb_timer,
 			jiffies + (dirty_writeback_centisecs * HZ) / 100);
diff -p -purN linux-2.6.8-rc3-bk2/mm/page_alloc.c linux-2.6.8-rc3-bk3/mm/page_alloc.c
--- linux-2.6.8-rc3-bk2/mm/page_alloc.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/mm/page_alloc.c	2004-08-08 17:25:03.911114152 +0000
@@ -1955,9 +1955,9 @@ module_init(init_per_zone_pages_min)
  *	changes.
  */
 int min_free_kbytes_sysctl_handler(ctl_table *table, int write, 
-		struct file *file, void __user *buffer, size_t *length)
+		struct file *file, void __user *buffer, size_t *length, loff_t *ppos)
 {
-	proc_dointvec(table, write, file, buffer, length);
+	proc_dointvec(table, write, file, buffer, length, ppos);
 	setup_per_zone_pages_min();
 	setup_per_zone_protection();
 	return 0;
@@ -1969,9 +1969,9 @@ int min_free_kbytes_sysctl_handler(ctl_t
  *	whenever sysctl_lower_zone_protection changes.
  */
 int lower_zone_protection_sysctl_handler(ctl_table *table, int write,
-		 struct file *file, void __user *buffer, size_t *length)
+		 struct file *file, void __user *buffer, size_t *length, loff_t *ppos)
 {
-	proc_dointvec_minmax(table, write, file, buffer, length);
+	proc_dointvec_minmax(table, write, file, buffer, length, ppos);
 	setup_per_zone_protection();
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/net/atm/mpc.c linux-2.6.8-rc3-bk3/net/atm/mpc.c
--- linux-2.6.8-rc3-bk2/net/atm/mpc.c	2004-06-16 05:19:52.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/atm/mpc.c	2004-08-08 17:25:03.916113392 +0000
@@ -3,6 +3,7 @@
 #include <linux/timer.h>
 #include <linux/init.h>
 #include <linux/bitops.h>
+#include <linux/seq_file.h>
 
 /* We are an ethernet device */
 #include <linux/if_ether.h>
@@ -224,29 +225,27 @@ int atm_mpoa_delete_qos(struct atm_mpoa_
 	return 0;
 }
 
-void atm_mpoa_disp_qos(char *page, ssize_t *len)
+/* this is buggered - we need locking for qos_head */
+void atm_mpoa_disp_qos(struct seq_file *m)
 {
-
 	unsigned char *ip;
 	char ipaddr[16];
 	struct atm_mpoa_qos *qos;
 
 	qos = qos_head;
-	*len += sprintf(page + *len, "QoS entries for shortcuts:\n");
-	*len += sprintf(page + *len, "IP address\n  TX:max_pcr pcr     min_pcr max_cdv max_sdu\n  RX:max_pcr pcr     min_pcr max_cdv max_sdu\n");
+	seq_printf(m, "QoS entries for shortcuts:\n");
+	seq_printf(m, "IP address\n  TX:max_pcr pcr     min_pcr max_cdv max_sdu\n  RX:max_pcr pcr     min_pcr max_cdv max_sdu\n");
 
 	ipaddr[sizeof(ipaddr)-1] = '\0';
 	while (qos != NULL) {
 		ip = (unsigned char *)&qos->ipaddr;
 		sprintf(ipaddr, "%u.%u.%u.%u", NIPQUAD(ip));
-		*len += sprintf(page + *len, "%u.%u.%u.%u\n     %-7d %-7d %-7d %-7d %-7d\n     %-7d %-7d %-7d %-7d %-7d\n",
+		seq_printf(m, "%u.%u.%u.%u\n     %-7d %-7d %-7d %-7d %-7d\n     %-7d %-7d %-7d %-7d %-7d\n",
 				NIPQUAD(ipaddr),
 				qos->qos.txtp.max_pcr, qos->qos.txtp.pcr, qos->qos.txtp.min_pcr, qos->qos.txtp.max_cdv, qos->qos.txtp.max_sdu,
 				qos->qos.rxtp.max_pcr, qos->qos.rxtp.pcr, qos->qos.rxtp.min_pcr, qos->qos.rxtp.max_cdv, qos->qos.rxtp.max_sdu);
 		qos = qos->next;
 	}
-	
-	return;
 }
 
 static struct net_device *find_lec_by_itfnum(int itf)
diff -p -purN linux-2.6.8-rc3-bk2/net/atm/mpc.h linux-2.6.8-rc3-bk3/net/atm/mpc.h
--- linux-2.6.8-rc3-bk2/net/atm/mpc.h	2004-06-16 05:18:58.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/atm/mpc.h	2004-08-08 17:25:03.918113088 +0000
@@ -51,6 +51,7 @@ struct atm_mpoa_qos *atm_mpoa_search_qos
 int atm_mpoa_delete_qos(struct atm_mpoa_qos *qos);
 
 /* Display QoS entries. This is for the procfs */
-void atm_mpoa_disp_qos(char *page, ssize_t *len);
+struct seq_file;
+void atm_mpoa_disp_qos(struct seq_file *m);
 
 #endif /* _MPC_H_ */
diff -p -purN linux-2.6.8-rc3-bk2/net/atm/mpoa_proc.c linux-2.6.8-rc3-bk3/net/atm/mpoa_proc.c
--- linux-2.6.8-rc3-bk2/net/atm/mpoa_proc.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/atm/mpoa_proc.c	2004-08-08 17:25:03.923112328 +0000
@@ -8,6 +8,7 @@
 #include <linux/module.h>
 #include <linux/proc_fs.h>
 #include <linux/time.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/atmmpc.h>
 #include <linux/atm.h>
@@ -30,31 +31,24 @@
 extern struct mpoa_client *mpcs;
 extern struct proc_dir_entry *atm_proc_root;  /* from proc.c. */
 
-static ssize_t proc_mpc_read(struct file *file, char __user *buff,
-			     size_t count, loff_t *pos);
-
+static int proc_mpc_open(struct inode *inode, struct file *file);
 static ssize_t proc_mpc_write(struct file *file, const char __user *buff,
                               size_t nbytes, loff_t *ppos);
 
-static int parse_qos(const char *buff, int len);
+static int parse_qos(const char *buff);
 
 /*
  *   Define allowed FILE OPERATIONS
  */
 static struct file_operations mpc_file_operations = {
 	.owner =	THIS_MODULE,
-	.read =		proc_mpc_read,
+	.open =		proc_mpc_open,
+	.read =		seq_read,
+	.llseek =	seq_lseek,
 	.write =	proc_mpc_write,
+	.release =	seq_release,
 };
 
-static int print_header(char *buff,struct mpoa_client *mpc){
-        if(mpc != NULL){
-	        return sprintf(buff,"\nInterface %d:\n\n",mpc->dev_num);  
-	  
-	}
-	return 0;
-}
-
 /*
  * Returns the state of an ingress cache entry as a string
  */
@@ -97,210 +91,173 @@ static const char *egress_state_string(i
 }
 
 /*
+ * FIXME: mpcs (and per-mpc lists) have no locking whatsoever.
+ */
+
+static void *mpc_start(struct seq_file *m, loff_t *pos)
+{
+	loff_t l = *pos;
+	struct mpoa_client *mpc;
+
+	if (!l--)
+		return SEQ_START_TOKEN;
+	for (mpc = mpcs; mpc; mpc = mpc->next)
+		if (!l--)
+			return mpc;
+	return NULL;
+}
+
+static void *mpc_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	struct mpoa_client *p = v;
+	(*pos)++;
+	return v == SEQ_START_TOKEN ? mpcs : p->next;
+}
+
+static void mpc_stop(struct seq_file *m, void *v)
+{
+}
+
+/*
  * READING function - called when the /proc/atm/mpoa file is read from.
  */
-static ssize_t proc_mpc_read(struct file *file, char __user *buff,
-			     size_t count, loff_t *pos){
-        unsigned long page = 0;
+static ssize_t mpc_show(struct seq_file *m, void *v)
+{
+	struct mpoa_client *mpc = v;
 	unsigned char *temp;
-        ssize_t length = 0;
-	int i = 0;
-	struct mpoa_client *mpc = mpcs;
+	int i;
 	in_cache_entry *in_entry;
 	eg_cache_entry *eg_entry;
 	struct timeval now;
 	unsigned char ip_string[16];
-	if(count == 0)
-	        return 0;
-	page = get_zeroed_page(GFP_KERNEL);
-	if(!page)
-	        return -ENOMEM;
-	atm_mpoa_disp_qos((char *)page, &length);
-	while(mpc != NULL){
-	        length += print_header((char *)page + length, mpc);
-		length += sprintf((char *)page + length,"Ingress Entries:\nIP address      State      Holding time  Packets fwded  VPI  VCI\n");
-		in_entry = mpc->in_cache;
-		do_gettimeofday(&now);
-		while(in_entry != NULL){
-		        temp = (unsigned char *)&in_entry->ctrl_info.in_dst_ip;                        sprintf(ip_string,"%d.%d.%d.%d", temp[0], temp[1], temp[2], temp[3]);
-		        length += sprintf((char *)page + length,"%-16s%s%-14lu%-12u", ip_string, ingress_state_string(in_entry->entry_state), (in_entry->ctrl_info.holding_time-(now.tv_sec-in_entry->tv.tv_sec)), in_entry->packets_fwded);
-			if(in_entry->shortcut)
-			        length += sprintf((char *)page + length,"   %-3d  %-3d",in_entry->shortcut->vpi,in_entry->shortcut->vci);
-			length += sprintf((char *)page + length,"\n");
-			in_entry = in_entry->next;
-		}
-		length += sprintf((char *)page + length,"\n");
-		eg_entry = mpc->eg_cache;
-		length += sprintf((char *)page + length,"Egress Entries:\nIngress MPC ATM addr\nCache-id        State      Holding time  Packets recvd  Latest IP addr   VPI VCI\n");
-		while(eg_entry != NULL){
-		  for(i=0;i<ATM_ESA_LEN;i++){
-		          length += sprintf((char *)page + length,"%02x",eg_entry->ctrl_info.in_MPC_data_ATM_addr[i]);}  
-		        length += sprintf((char *)page + length,"\n%-16lu%s%-14lu%-15u",(unsigned long) ntohl(eg_entry->ctrl_info.cache_id), egress_state_string(eg_entry->entry_state), (eg_entry->ctrl_info.holding_time-(now.tv_sec-eg_entry->tv.tv_sec)), eg_entry->packets_rcvd);
-			
-			/* latest IP address */
-			temp = (unsigned char *)&eg_entry->latest_ip_addr;
-			sprintf(ip_string, "%d.%d.%d.%d", temp[0], temp[1], temp[2], temp[3]);
-			length += sprintf((char *)page + length, "%-16s", ip_string);
-
-			if(eg_entry->shortcut)
-			        length += sprintf((char *)page + length," %-3d %-3d",eg_entry->shortcut->vpi,eg_entry->shortcut->vci);
-			length += sprintf((char *)page + length,"\n");
-			eg_entry = eg_entry->next;
-		}
-		length += sprintf((char *)page + length,"\n");
-		mpc = mpc->next;
+
+	if (v == SEQ_START_TOKEN) {
+		atm_mpoa_disp_qos(m);
+		return 0;
 	}
 
-	if (*pos >= length) length = 0;
-	else {
-	  if ((count + *pos) > length) count = length - *pos;
-	  if (copy_to_user(buff, (char *)page , count)) {
- 		  free_page(page);
-		  return -EFAULT;
-          }
-	  *pos += count;
+	seq_printf(m, "\nInterface %d:\n\n", mpc->dev_num);  
+	seq_printf(m, "Ingress Entries:\nIP address      State      Holding time  Packets fwded  VPI  VCI\n");
+	do_gettimeofday(&now);
+
+	for (in_entry = mpc->in_cache; in_entry; in_entry = in_entry->next) {
+		temp = (unsigned char *)&in_entry->ctrl_info.in_dst_ip;
+		sprintf(ip_string,"%d.%d.%d.%d", temp[0], temp[1], temp[2], temp[3]);
+		seq_printf(m, "%-16s%s%-14lu%-12u",
+			      ip_string,
+			      ingress_state_string(in_entry->entry_state),
+			      in_entry->ctrl_info.holding_time-(now.tv_sec-in_entry->tv.tv_sec),
+			      in_entry->packets_fwded);
+		if (in_entry->shortcut)
+			seq_printf(m, "   %-3d  %-3d",in_entry->shortcut->vpi,in_entry->shortcut->vci);
+		seq_printf(m, "\n");
 	}
 
- 	free_page(page);
-        return length;
+	seq_printf(m, "\n");
+	seq_printf(m, "Egress Entries:\nIngress MPC ATM addr\nCache-id        State      Holding time  Packets recvd  Latest IP addr   VPI VCI\n");
+	for (eg_entry = mpc->eg_cache; eg_entry; eg_entry = eg_entry->next) {
+		unsigned char *p = eg_entry->ctrl_info.in_MPC_data_ATM_addr;
+		for(i = 0; i < ATM_ESA_LEN; i++)
+			seq_printf(m, "%02x", p[i]);
+		seq_printf(m, "\n%-16lu%s%-14lu%-15u",
+			   (unsigned long)ntohl(eg_entry->ctrl_info.cache_id),
+			   egress_state_string(eg_entry->entry_state),
+			   (eg_entry->ctrl_info.holding_time-(now.tv_sec-eg_entry->tv.tv_sec)),
+			   eg_entry->packets_rcvd);
+		
+		/* latest IP address */
+		temp = (unsigned char *)&eg_entry->latest_ip_addr;
+		sprintf(ip_string, "%d.%d.%d.%d", temp[0], temp[1], temp[2], temp[3]);
+		seq_printf(m, "%-16s", ip_string);
+
+		if (eg_entry->shortcut)
+			seq_printf(m, " %-3d %-3d",eg_entry->shortcut->vpi,eg_entry->shortcut->vci);
+		seq_printf(m, "\n");
+	}
+	seq_printf(m, "\n");
+	return 0;
+}
+
+static struct seq_operations mpc_op = {
+	.start =	mpc_start,
+	.next =		mpc_next,
+	.stop =		mpc_stop,
+	.show =		mpc_show
+};
+
+static int proc_mpc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mpc_op);
 }
 
 static ssize_t proc_mpc_write(struct file *file, const char __user *buff,
                               size_t nbytes, loff_t *ppos)
 {
-        int incoming, error, retval;
-        char *page, c;
-        const char __user *tmp;
+        char *page, *p;
+	unsigned len;
 
-        if (nbytes == 0) return 0;
-        if (nbytes >= PAGE_SIZE) nbytes = PAGE_SIZE-1;
+        if (nbytes == 0)
+		return 0;
 
-        error = verify_area(VERIFY_READ, buff, nbytes);
-        if (error) return error;
+        if (nbytes >= PAGE_SIZE)
+		nbytes = PAGE_SIZE-1;
 
         page = (char *)__get_free_page(GFP_KERNEL);
-        if (page == NULL) return -ENOMEM;
+        if (!page)
+		return -ENOMEM;
 
-        incoming = 0;
-        tmp = buff;
-        while(incoming < nbytes){
-                if (get_user(c, tmp++)) return -EFAULT;
-                incoming++;
-                if (c == '\0' || c == '\n')
+        for (p = page, len = 0; len < nbytes; p++, len++) {
+                if (get_user(*p, buff++)) {
+			free_page((unsigned long)page);
+			return -EFAULT;
+		}
+                if (*p == '\0' || *p == '\n')
                         break;
         }
 
-        retval = copy_from_user(page, buff, incoming);
-        if (retval != 0) {
-                printk("mpoa: proc_mpc_write: copy_from_user() failed\n");
-                return -EFAULT;
-        }
+        *p = '\0';
 
-        *ppos += incoming;
-
-        page[incoming] = '\0';
-	retval = parse_qos(page, incoming);
-        if (retval == 0)
+	if (!parse_qos(page))
                 printk("mpoa: proc_mpc_write: could not parse '%s'\n", page);
 
         free_page((unsigned long)page);
         
-        return nbytes;
+        return len;
 }
 
-static int parse_qos(const char *buff, int len)
+static int parse_qos(const char *buff)
 {
         /* possible lines look like this
          * add 130.230.54.142 tx=max_pcr,max_sdu rx=max_pcr,max_sdu
          */
-        
-        int pos, i;
-        uint32_t ipaddr;
         unsigned char ip[4]; 
-        char cmd[4], temp[256];
-        const char *tmp, *prev;
+	int tx_pcr, tx_sdu, rx_pcr, rx_sdu;
+        uint32_t ipaddr;
 	struct atm_qos qos; 
-	int value[5];
         
         memset(&qos, 0, sizeof(struct atm_qos));
-        strlcpy(cmd, buff, sizeof(cmd));
-        if( strncmp(cmd,"add", 3) &&  strncmp(cmd,"del", 3))
-	        return 0;  /* not add or del */
-
-	pos = 4;
-        /* next parse ip */
-        prev = buff + pos;
-        for (i = 0; i < 3; i++) {
-                tmp = strchr(prev, '.');
-                if (tmp == NULL) return 0;
-                memset(temp, '\0', 256);
-                memcpy(temp, prev, tmp-prev);
-                ip[i] = (char)simple_strtoul(temp, NULL, 0);
-		tmp ++; 
-		prev = tmp;
-        }
-	tmp = strchr(prev, ' ');
-        if (tmp == NULL) return 0;
-        memset(temp, '\0', 256);
-        memcpy(temp, prev, tmp-prev);
-        ip[i] = (char)simple_strtoul(temp, NULL, 0);
-        ipaddr = *(uint32_t *)ip;
-                
-	if(!strncmp(cmd, "del", 3))
-	         return atm_mpoa_delete_qos(atm_mpoa_search_qos(ipaddr));
-
-        /* next transmit values */
-	tmp = strstr(buff, "tx=");
-	if(tmp == NULL) return 0;
-	tmp += 3;
-	prev = tmp;
-	for( i = 0; i < 1; i++){
-	         tmp = strchr(prev, ',');
-		 if (tmp == NULL) return 0;
-		 memset(temp, '\0', 256);
-		 memcpy(temp, prev, tmp-prev);
-		 value[i] = (int)simple_strtoul(temp, NULL, 0);
-		 tmp ++; 
-		 prev = tmp;
+
+	if (sscanf(buff, "del %hhu.%hhu.%hhu.%hhu",
+			ip, ip+1, ip+2, ip+3) == 4) {
+		ipaddr = *(uint32_t *)ip;
+		return atm_mpoa_delete_qos(atm_mpoa_search_qos(ipaddr));
 	}
-	tmp = strchr(prev, ' ');
-        if (tmp == NULL) return 0;
-	memset(temp, '\0', 256);
-        memcpy(temp, prev, tmp-prev);
-        value[i] = (int)simple_strtoul(temp, NULL, 0);
-	qos.txtp.traffic_class = ATM_CBR;
-	qos.txtp.max_pcr = value[0];
-	qos.txtp.max_sdu = value[1];
 
-        /* next receive values */
-	tmp = strstr(buff, "rx=");
-	if(tmp == NULL) return 0;
-        if (strstr(buff, "rx=tx")) { /* rx == tx */
-                qos.rxtp.traffic_class = qos.txtp.traffic_class;
-                qos.rxtp.max_pcr = qos.txtp.max_pcr;
-                qos.rxtp.max_cdv = qos.txtp.max_cdv;
-                qos.rxtp.max_sdu = qos.txtp.max_sdu;
-        } else {
-                tmp += 3;
-                prev = tmp;
-                for( i = 0; i < 1; i++){
-                        tmp = strchr(prev, ',');
-                        if (tmp == NULL) return 0;
-                        memset(temp, '\0', 256);
-                        memcpy(temp, prev, tmp-prev);
-                        value[i] = (int)simple_strtoul(temp, NULL, 0);
-                        tmp ++; 
-                        prev = tmp;
-                }
-                tmp = strchr(prev, '\0');
-                if (tmp == NULL) return 0;
-                memset(temp, '\0', 256);
-                memcpy(temp, prev, tmp-prev);
-                value[i] = (int)simple_strtoul(temp, NULL, 0);
-                qos.rxtp.traffic_class = ATM_CBR;
-                qos.rxtp.max_pcr = value[0];
-                qos.rxtp.max_sdu = value[1];
-        }
+	if (sscanf(buff, "add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=tx",
+			ip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu) == 6) {
+		rx_pcr = tx_pcr;
+		rx_sdu = tx_sdu;
+	} else if (sscanf(buff, "add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=%d,%d",
+		ip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu, &rx_pcr, &rx_sdu) != 8)
+		return 0;
+
+        ipaddr = *(uint32_t *)ip;
+	qos.txtp.traffic_class = ATM_CBR;
+	qos.txtp.max_pcr = tx_pcr;
+	qos.txtp.max_sdu = tx_sdu;
+	qos.rxtp.traffic_class = ATM_CBR;
+	qos.rxtp.max_pcr = rx_pcr;
+	qos.rxtp.max_sdu = rx_sdu;
         qos.aal = ATM_AAL5;
 	dprintk("mpoa: mpoa_proc.c: parse_qos(): setting qos paramameters to tx=%d,%d rx=%d,%d\n",
 		qos.txtp.max_pcr,
diff -p -purN linux-2.6.8-rc3-bk2/net/bridge/br_netfilter.c linux-2.6.8-rc3-bk3/net/bridge/br_netfilter.c
--- linux-2.6.8-rc3-bk2/net/bridge/br_netfilter.c	2004-06-16 05:20:04.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/bridge/br_netfilter.c	2004-08-08 17:25:03.927111720 +0000
@@ -800,11 +800,11 @@ static struct nf_hook_ops br_nf_ops[] = 
 #ifdef CONFIG_SYSCTL
 static
 int brnf_sysctl_call_tables(ctl_table *ctl, int write, struct file * filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int ret;
 
-	ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && *(int *)(ctl->data))
 		*(int *)(ctl->data) = 1;
diff -p -purN linux-2.6.8-rc3-bk2/net/bridge/br_notify.c linux-2.6.8-rc3-bk3/net/bridge/br_notify.c
--- linux-2.6.8-rc3-bk2/net/bridge/br_notify.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/bridge/br_notify.c	2004-08-08 17:25:03.929111416 +0000
@@ -23,32 +23,39 @@ struct notifier_block br_device_notifier
 	.notifier_call = br_device_event
 };
 
+/*
+ * Handle changes in state of network devices enslaved to a bridge.
+ * 
+ * Note: don't care about up/down if bridge itself is down, because
+ *     port state is checked when bridge is brought up.
+ */
 static int br_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
 {
 	struct net_device *dev = ptr;
 	struct net_bridge_port *p = dev->br_port;
 	struct net_bridge *br;
 
+	/* not a port of a bridge */
 	if (p == NULL)
 		return NOTIFY_DONE;
 
 	br = p->br;
-	if ( !(br->dev->flags & IFF_UP))
-		return NOTIFY_DONE;
-
-	if (event == NETDEV_CHANGEMTU) {
-		dev_set_mtu(br->dev, br_min_mtu(br));
-		return NOTIFY_DONE;
-	}
 
 	spin_lock_bh(&br->lock);
 	switch (event) {
+	case NETDEV_CHANGEMTU:
+		dev_set_mtu(br->dev, br_min_mtu(br));
+		break;
+
 	case NETDEV_CHANGEADDR:
 		br_fdb_changeaddr(p, dev->dev_addr);
 		br_stp_recalculate_bridge_id(br);
 		break;
 
 	case NETDEV_CHANGE:	/* device is up but carrier changed */
+		if (!(br->dev->flags & IFF_UP))
+			break;
+
 		if (netif_carrier_ok(dev)) {
 			if (p->state == BR_STATE_DISABLED)
 				br_stp_enable_port(p);
@@ -59,11 +66,12 @@ static int br_device_event(struct notifi
 		break;
 
 	case NETDEV_DOWN:
-		br_stp_disable_port(p);
+		if (br->dev->flags & IFF_UP)
+			br_stp_disable_port(p);
 		break;
 
 	case NETDEV_UP:
-		if (netif_carrier_ok(dev)) 
+		if (netif_carrier_ok(dev) && (br->dev->flags & IFF_UP)) 
 			br_stp_enable_port(p);
 		break;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/core/skbuff.c linux-2.6.8-rc3-bk3/net/core/skbuff.c
--- linux-2.6.8-rc3-bk2/net/core/skbuff.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/core/skbuff.c	2004-08-08 17:25:03.933110808 +0000
@@ -929,6 +929,70 @@ fault:
 	return -EFAULT;
 }
 
+/* Keep iterating until skb_iter_next returns false. */
+void skb_iter_first(const struct sk_buff *skb, struct skb_iter *i)
+{
+	i->len = skb_headlen(skb);
+	i->data = (unsigned char *)skb->data;
+	i->nextfrag = 0;
+	i->fraglist = NULL;
+}
+
+int skb_iter_next(const struct sk_buff *skb, struct skb_iter *i)
+{
+	/* Unmap previous, if not head fragment. */
+	if (i->nextfrag)
+		kunmap_skb_frag(i->data);
+
+	if (i->fraglist) {
+	fraglist:
+		/* We're iterating through fraglist. */
+		if (i->nextfrag < skb_shinfo(i->fraglist)->nr_frags) {
+			i->data = kmap_skb_frag(&skb_shinfo(i->fraglist)
+						->frags[i->nextfrag]);
+			i->len = skb_shinfo(i->fraglist)->frags[i->nextfrag]
+				.size;
+			i->nextfrag++;
+			return 1;
+		}
+		/* Fragments with fragments?  Too hard! */
+		BUG_ON(skb_shinfo(i->fraglist)->frag_list);
+		i->fraglist = i->fraglist->next;
+		if (!i->fraglist)
+			goto end;
+
+		i->len = skb_headlen(i->fraglist);
+		i->data = i->fraglist->data;
+		i->nextfrag = 0;
+		return 1;
+	}
+
+	if (i->nextfrag < skb_shinfo(skb)->nr_frags) {
+		i->data = kmap_skb_frag(&skb_shinfo(skb)->frags[i->nextfrag]);
+		i->len = skb_shinfo(skb)->frags[i->nextfrag].size;
+		i->nextfrag++;
+		return 1;
+	}
+
+	i->fraglist = skb_shinfo(skb)->frag_list;
+	if (i->fraglist)
+		goto fraglist;
+
+end:
+	/* Bug trap for callers */
+	i->data = NULL;
+	return 0;
+}
+
+void skb_iter_abort(const struct sk_buff *skb, struct skb_iter *i)
+{
+	/* Unmap previous, if not head fragment. */
+	if (i->data && i->nextfrag)
+		kunmap_skb_frag(i->data);
+	/* Bug trap for callers */
+	i->data = NULL;
+}
+
 /* Checksum skb data. */
 
 unsigned int skb_checksum(const struct sk_buff *skb, int offset,
@@ -1399,3 +1463,6 @@ EXPORT_SYMBOL(skb_queue_tail);
 EXPORT_SYMBOL(skb_unlink);
 EXPORT_SYMBOL(skb_append);
 EXPORT_SYMBOL(skb_split);
+EXPORT_SYMBOL(skb_iter_first);
+EXPORT_SYMBOL(skb_iter_next);
+EXPORT_SYMBOL(skb_iter_abort);
diff -p -purN linux-2.6.8-rc3-bk2/net/core/sock.c linux-2.6.8-rc3-bk3/net/core/sock.c
--- linux-2.6.8-rc3-bk2/net/core/sock.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/core/sock.c	2004-08-08 17:25:03.937110200 +0000
@@ -652,14 +652,6 @@ void sk_free(struct sock *sk)
 		printk(KERN_DEBUG "%s: optmem leakage (%d bytes) detected.\n",
 		       __FUNCTION__, atomic_read(&sk->sk_omem_alloc));
 
-	/*
-	 * If sendmsg cached page exists, toss it.
-	 */
-	if (sk->sk_sndmsg_page) {
-		__free_page(sk->sk_sndmsg_page);
-		sk->sk_sndmsg_page = NULL;
-	}
-
 	security_sk_free(sk);
 	kmem_cache_free(sk->sk_slab, sk);
 	module_put(owner);
diff -p -purN linux-2.6.8-rc3-bk2/net/decnet/dn_dev.c linux-2.6.8-rc3-bk3/net/decnet/dn_dev.c
--- linux-2.6.8-rc3-bk2/net/decnet/dn_dev.c	2004-06-16 05:19:10.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/decnet/dn_dev.c	2004-08-08 17:25:03.940109744 +0000
@@ -161,7 +161,7 @@ static int min_priority[1];
 static int max_priority[] = { 127 }; /* From DECnet spec */
 
 static int dn_forwarding_proc(ctl_table *, int, struct file *,
-			void __user *, size_t *);
+			void __user *, size_t *, loff_t *);
 static int dn_forwarding_sysctl(ctl_table *table, int __user *name, int nlen,
 			void __user *oldval, size_t __user *oldlenp,
 			void __user *newval, size_t newlen,
@@ -362,7 +362,8 @@ static void dn_dev_check_default(struct 
 
 static int dn_forwarding_proc(ctl_table *table, int write, 
 				struct file *filep,
-				void __user *buffer, size_t *lenp)
+				void __user *buffer,
+				size_t *lenp, loff_t *ppos)
 {
 #ifdef CONFIG_DECNET_ROUTER
 	struct net_device *dev = table->extra1;
@@ -376,7 +377,7 @@ static int dn_forwarding_proc(ctl_table 
 	dn_db = dev->dn_ptr;
 	old = dn_db->parms.forwarding;
 
-	err = proc_dointvec(table, write, filep, buffer, lenp);
+	err = proc_dointvec(table, write, filep, buffer, lenp, ppos);
 
 	if ((err >= 0) && write) {
 		if (dn_db->parms.forwarding < 0)
diff -p -purN linux-2.6.8-rc3-bk2/net/decnet/sysctl_net_decnet.c linux-2.6.8-rc3-bk3/net/decnet/sysctl_net_decnet.c
--- linux-2.6.8-rc3-bk2/net/decnet/sysctl_net_decnet.c	2004-06-16 05:19:01.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/decnet/sysctl_net_decnet.c	2004-08-08 17:25:03.942109440 +0000
@@ -162,13 +162,14 @@ static int dn_node_address_strategy(ctl_
 
 static int dn_node_address_handler(ctl_table *table, int write, 
 				struct file *filp,
-				void __user *buffer, size_t *lenp)
+				void __user *buffer,
+				size_t *lenp, loff_t *ppos)
 {
 	char addr[DN_ASCBUF_LEN];
 	size_t len;
 	dn_address dnaddr;
 
-	if (!*lenp || (filp->f_pos && !write)) {
+	if (!*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -191,7 +192,7 @@ static int dn_node_address_handler(ctl_t
 
 		dn_dev_devices_on();
 
-		filp->f_pos += len;
+		*ppos += len;
 
 		return 0;
 	}
@@ -206,7 +207,7 @@ static int dn_node_address_handler(ctl_t
 		return -EFAULT;
 
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 
 	return 0;
 }
@@ -273,13 +274,14 @@ static int dn_def_dev_strategy(ctl_table
 
 static int dn_def_dev_handler(ctl_table *table, int write, 
 				struct file * filp,
-				void __user *buffer, size_t *lenp)
+				void __user *buffer,
+				size_t *lenp, loff_t *ppos)
 {
 	size_t len;
 	struct net_device *dev;
 	char devname[17];
 
-	if (!*lenp || (filp->f_pos && !write)) {
+	if (!*lenp || (*ppos && !write)) {
 		*lenp = 0;
 		return 0;
 	}
@@ -307,7 +309,7 @@ static int dn_def_dev_handler(ctl_table 
 			dev_put(dev);
 			return -ENODEV;
 		}
-		filp->f_pos += *lenp;
+		*ppos += *lenp;
 
 		return 0;
 	}
@@ -329,7 +331,7 @@ static int dn_def_dev_handler(ctl_table 
 		return -EFAULT;
 
 	*lenp = len;
-	filp->f_pos += len;
+	*ppos += len;
 
 	return 0;
 }
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv4/devinet.c linux-2.6.8-rc3-bk3/net/ipv4/devinet.c
--- linux-2.6.8-rc3-bk2/net/ipv4/devinet.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv4/devinet.c	2004-08-08 17:25:03.946108832 +0000
@@ -1151,11 +1151,11 @@ void inet_forward_change(void)
 
 static int devinet_sysctl_forward(ctl_table *ctl, int write,
 				  struct file* filp, void __user *buffer,
-				  size_t *lenp)
+				  size_t *lenp, loff_t *ppos)
 {
 	int *valp = ctl->data;
 	int val = *valp;
-	int ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	int ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && *valp != val) {
 		if (valp == &ipv4_devconf.forwarding)
@@ -1169,11 +1169,11 @@ static int devinet_sysctl_forward(ctl_ta
 
 int ipv4_doint_and_flush(ctl_table *ctl, int write,
 			 struct file* filp, void __user *buffer,
-			 size_t *lenp)
+			 size_t *lenp, loff_t *ppos)
 {
 	int *valp = ctl->data;
 	int val = *valp;
-	int ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	int ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && *valp != val)
 		rt_cache_flush(0);
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv4/ipvs/ip_vs_ctl.c linux-2.6.8-rc3-bk3/net/ipv4/ipvs/ip_vs_ctl.c
--- linux-2.6.8-rc3-bk2/net/ipv4/ipvs/ip_vs_ctl.c	2004-06-16 05:20:03.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv4/ipvs/ip_vs_ctl.c	2004-08-08 17:25:03.951108072 +0000
@@ -1347,13 +1347,13 @@ static int ip_vs_zero_all(void)
 
 static int
 proc_do_defense_mode(ctl_table *table, int write, struct file * filp,
-		     void __user *buffer, size_t *lenp)
+		     void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int *valp = table->data;
 	int val = *valp;
 	int rc;
 
-	rc = proc_dointvec(table, write, filp, buffer, lenp);
+	rc = proc_dointvec(table, write, filp, buffer, lenp, ppos);
 	if (write && (*valp != val)) {
 		if ((*valp < 0) || (*valp > 3)) {
 			/* Restore the correct value */
@@ -1370,7 +1370,7 @@ proc_do_defense_mode(ctl_table *table, i
 
 static int
 proc_do_sync_threshold(ctl_table *table, int write, struct file *filp,
-		       void __user *buffer, size_t *lenp)
+		       void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int *valp = table->data;
 	int val[2];
@@ -1379,7 +1379,7 @@ proc_do_sync_threshold(ctl_table *table,
 	/* backup the value first */
 	memcpy(val, valp, sizeof(val));
 
-	rc = proc_dointvec(table, write, filp, buffer, lenp);
+	rc = proc_dointvec(table, write, filp, buffer, lenp, ppos);
 	if (write && (valp[0] < 0 || valp[1] < 0 || valp[0] >= valp[1])) {
 		/* Restore the correct value */
 		memcpy(valp, val, sizeof(val));
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv4/route.c linux-2.6.8-rc3-bk3/net/ipv4/route.c
--- linux-2.6.8-rc3-bk2/net/ipv4/route.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv4/route.c	2004-08-08 17:25:03.957107160 +0000
@@ -2498,10 +2498,10 @@ static int flush_delay;
 
 static int ipv4_sysctl_rtcache_flush(ctl_table *ctl, int write,
 					struct file *filp, void __user *buffer,
-					size_t *lenp)
+					size_t *lenp, loff_t *ppos)
 {
 	if (write) {
-		proc_dointvec(ctl, write, filp, buffer, lenp);
+		proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 		rt_cache_flush(flush_delay);
 		return 0;
 	} 
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv4/sysctl_net_ipv4.c linux-2.6.8-rc3-bk3/net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.8-rc3-bk2/net/ipv4/sysctl_net_ipv4.c	2004-06-16 05:19:43.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv4/sysctl_net_ipv4.c	2004-08-08 17:25:03.959106856 +0000
@@ -62,12 +62,12 @@ extern ctl_table ipv4_route_table[];
 
 static
 int ipv4_sysctl_forward(ctl_table *ctl, int write, struct file * filp,
-			void __user *buffer, size_t *lenp)
+			void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int val = ipv4_devconf.forwarding;
 	int ret;
 
-	ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && ipv4_devconf.forwarding != val)
 		inet_forward_change();
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv4/tcp_ipv4.c linux-2.6.8-rc3-bk3/net/ipv4/tcp_ipv4.c
--- linux-2.6.8-rc3-bk2/net/ipv4/tcp_ipv4.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv4/tcp_ipv4.c	2004-08-08 17:25:03.964106096 +0000
@@ -2113,6 +2113,14 @@ int tcp_v4_destroy_sock(struct sock *sk)
 	if (tp->bind_hash)
 		tcp_put_port(sk);
 
+	/*
+	 * If sendmsg cached page exists, toss it.
+	 */
+	if (sk->sk_sndmsg_page) {
+		__free_page(sk->sk_sndmsg_page);
+		sk->sk_sndmsg_page = NULL;
+	}
+
 	atomic_dec(&tcp_sockets_allocated);
 
 	return 0;
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv6/addrconf.c linux-2.6.8-rc3-bk3/net/ipv6/addrconf.c
--- linux-2.6.8-rc3-bk2/net/ipv6/addrconf.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv6/addrconf.c	2004-08-08 17:25:03.973104728 +0000
@@ -3003,13 +3003,13 @@ static void ipv6_ifa_notify(int event, s
 
 static
 int addrconf_sysctl_forward(ctl_table *ctl, int write, struct file * filp,
-			   void __user *buffer, size_t *lenp)
+			   void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int *valp = ctl->data;
 	int val = *valp;
 	int ret;
 
-	ret = proc_dointvec(ctl, write, filp, buffer, lenp);
+	ret = proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 
 	if (write && *valp != val && valp != &ipv6_devconf_dflt.forwarding) {
 		struct inet6_dev *idev = NULL;
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv6/ndisc.c linux-2.6.8-rc3-bk3/net/ipv6/ndisc.c
--- linux-2.6.8-rc3-bk2/net/ipv6/ndisc.c	2004-08-08 17:21:40.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv6/ndisc.c	2004-08-08 17:25:03.976104272 +0000
@@ -1423,7 +1423,7 @@ static struct notifier_block ndisc_netde
 };
 
 #ifdef CONFIG_SYSCTL
-int ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, struct file * filp, void __user *buffer, size_t *lenp)
+int ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, struct file * filp, void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	struct net_device *dev = ctl->extra1;
 	struct inet6_dev *idev;
@@ -1433,7 +1433,7 @@ int ndisc_ifinfo_sysctl_change(struct ct
 		inet6_ifinfo_notify(RTM_NEWLINK, idev);
 		in6_dev_put(idev);
 	}
-	return proc_dointvec(ctl, write, filp, buffer, lenp);
+	return proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 }
 #endif
 
diff -p -purN linux-2.6.8-rc3-bk2/net/ipv6/route.c linux-2.6.8-rc3-bk3/net/ipv6/route.c
--- linux-2.6.8-rc3-bk2/net/ipv6/route.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/ipv6/route.c	2004-08-08 17:25:03.982103360 +0000
@@ -1924,10 +1924,10 @@ static int flush_delay;
 
 static
 int ipv6_sysctl_rtcache_flush(ctl_table *ctl, int write, struct file * filp,
-			      void __user *buffer, size_t *lenp)
+			      void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	if (write) {
-		proc_dointvec(ctl, write, filp, buffer, lenp);
+		proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
 		if (flush_delay < 0)
 			flush_delay = 0;
 		fib6_run_gc((unsigned long)flush_delay);
diff -p -purN linux-2.6.8-rc3-bk2/net/irda/irsysctl.c linux-2.6.8-rc3-bk3/net/irda/irsysctl.c
--- linux-2.6.8-rc3-bk2/net/irda/irsysctl.c	2004-06-16 05:19:13.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/irda/irsysctl.c	2004-08-08 17:25:03.983103208 +0000
@@ -78,11 +78,11 @@ static int min_lap_keepalive_time = 100;
  * us on that - Jean II */
 
 static int do_devname(ctl_table *table, int write, struct file *filp,
-		      void __user *buffer, size_t *lenp)
+		      void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	int ret;
 
-	ret = proc_dostring(table, write, filp, buffer, lenp);
+	ret = proc_dostring(table, write, filp, buffer, lenp, ppos);
 	if (ret == 0 && write) {
 		struct ias_value *val;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_api.c linux-2.6.8-rc3-bk3/net/sched/sch_api.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_api.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_api.c	2004-08-08 17:25:03.987102600 +0000
@@ -34,6 +34,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/kmod.h>
+#include <linux/list.h>
 
 #include <net/sock.h>
 #include <net/pkt_sched.h>
@@ -195,7 +196,7 @@ struct Qdisc *qdisc_lookup(struct net_de
 {
 	struct Qdisc *q;
 
-	for (q = dev->qdisc_list; q; q = q->next) {
+	list_for_each_entry(q, &dev->qdisc_list, list) {
 		if (q->handle == handle)
 			return q;
 	}
@@ -421,6 +422,7 @@ qdisc_create(struct net_device *dev, u32
 
 	memset(sch, 0, size);
 
+	INIT_LIST_HEAD(&sch->list);
 	skb_queue_head_init(&sch->q);
 
 	if (handle == TC_H_INGRESS)
@@ -430,6 +432,7 @@ qdisc_create(struct net_device *dev, u32
 	sch->enqueue = ops->enqueue;
 	sch->dequeue = ops->dequeue;
 	sch->dev = dev;
+	dev_hold(dev);
 	atomic_set(&sch->refcnt, 1);
 	sch->stats_lock = &dev->queue_lock;
 	if (handle == 0) {
@@ -453,8 +456,7 @@ qdisc_create(struct net_device *dev, u32
 	smp_wmb();
 	if (!ops->init || (err = ops->init(sch, tca[TCA_OPTIONS-1])) == 0) {
 		qdisc_lock_tree(dev);
-		sch->next = dev->qdisc_list;
-		dev->qdisc_list = sch;
+		list_add_tail(&sch->list, &dev->qdisc_list);
 		qdisc_unlock_tree(dev);
 
 #ifdef CONFIG_NET_ESTIMATOR
@@ -751,7 +753,7 @@ static int tc_fill_qdisc(struct sk_buff 
 	nlh->nlmsg_flags = flags;
 	tcm = NLMSG_DATA(nlh);
 	tcm->tcm_family = AF_UNSPEC;
-	tcm->tcm_ifindex = q->dev ? q->dev->ifindex : 0;
+	tcm->tcm_ifindex = q->dev->ifindex;
 	tcm->tcm_parent = clid;
 	tcm->tcm_handle = q->handle;
 	tcm->tcm_info = atomic_read(&q->refcnt);
@@ -812,18 +814,21 @@ static int tc_dump_qdisc(struct sk_buff 
 			continue;
 		if (idx > s_idx)
 			s_q_idx = 0;
-		read_lock(&qdisc_tree_lock);
-		for (q = dev->qdisc_list, q_idx = 0; q;
-		     q = q->next, q_idx++) {
-			if (q_idx < s_q_idx)
+		read_lock_bh(&qdisc_tree_lock);
+		q_idx = 0;
+		list_for_each_entry(q, &dev->qdisc_list, list) {
+			if (q_idx < s_q_idx) {
+				q_idx++;
 				continue;
+			}
 			if (tc_fill_qdisc(skb, q, 0, NETLINK_CB(cb->skb).pid,
 					  cb->nlh->nlmsg_seq, NLM_F_MULTI, RTM_NEWQDISC) <= 0) {
-				read_unlock(&qdisc_tree_lock);
+				read_unlock_bh(&qdisc_tree_lock);
 				goto done;
 			}
+			q_idx++;
 		}
-		read_unlock(&qdisc_tree_lock);
+		read_unlock_bh(&qdisc_tree_lock);
 	}
 
 done:
@@ -968,7 +973,7 @@ static int tc_fill_tclass(struct sk_buff
 	nlh->nlmsg_flags = flags;
 	tcm = NLMSG_DATA(nlh);
 	tcm->tcm_family = AF_UNSPEC;
-	tcm->tcm_ifindex = q->dev ? q->dev->ifindex : 0;
+	tcm->tcm_ifindex = q->dev->ifindex;
 	tcm->tcm_parent = q->handle;
 	tcm->tcm_handle = q->handle;
 	tcm->tcm_info = 0;
@@ -1032,13 +1037,16 @@ static int tc_dump_tclass(struct sk_buff
 		return 0;
 
 	s_t = cb->args[0];
+	t = 0;
 
-	read_lock(&qdisc_tree_lock);
-	for (q=dev->qdisc_list, t=0; q; q = q->next, t++) {
-		if (t < s_t) continue;
-		if (!q->ops->cl_ops) continue;
-		if (tcm->tcm_parent && TC_H_MAJ(tcm->tcm_parent) != q->handle)
+	read_lock_bh(&qdisc_tree_lock);
+	list_for_each_entry(q, &dev->qdisc_list, list) {
+		if (t < s_t || !q->ops->cl_ops ||
+		    (tcm->tcm_parent &&
+		     TC_H_MAJ(tcm->tcm_parent) != q->handle)) {
+			t++;
 			continue;
+		}
 		if (t > s_t)
 			memset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));
 		arg.w.fn = qdisc_class_dump;
@@ -1051,8 +1059,9 @@ static int tc_dump_tclass(struct sk_buff
 		cb->args[1] = arg.w.count;
 		if (arg.w.stop)
 			break;
+		t++;
 	}
-	read_unlock(&qdisc_tree_lock);
+	read_unlock_bh(&qdisc_tree_lock);
 
 	cb->args[0] = t;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_atm.c linux-2.6.8-rc3-bk3/net/sched/sch_atm.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_atm.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_atm.c	2004-08-08 17:25:03.989102296 +0000
@@ -56,7 +56,7 @@ extern struct socket *sockfd_lookup(int 
  */
 
 
-#define PRIV(sch) ((struct atm_qdisc_data *) (sch)->data)
+#define PRIV(sch) qdisc_priv(sch)
 #define VCC2FLOW(vcc) ((struct atm_flow_data *) ((vcc)->user_back))
 
 
@@ -104,9 +104,10 @@ static int find_flow(struct atm_qdisc_da
 static __inline__ struct atm_flow_data *lookup_flow(struct Qdisc *sch,
     u32 classid)
 {
+	struct atm_qdisc_data *p = PRIV(sch);
 	struct atm_flow_data *flow;
 
-        for (flow = PRIV(sch)->flows; flow; flow = flow->next)
+        for (flow = p->flows; flow; flow = flow->next)
 		if (flow->classid == classid) break;
 	return flow;
 }
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_cbq.c linux-2.6.8-rc3-bk3/net/sched/sch_cbq.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_cbq.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_cbq.c	2004-08-08 17:25:03.998100928 +0000
@@ -241,7 +241,7 @@ cbq_reclassify(struct sk_buff *skb, stru
 static struct cbq_class *
 cbq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qres)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *head = &q->link;
 	struct cbq_class **defmap;
 	struct cbq_class *cl = NULL;
@@ -344,7 +344,7 @@ fallback:
 
 static __inline__ void cbq_activate_class(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	int prio = cl->cpriority;
 	struct cbq_class *cl_tail;
 
@@ -368,7 +368,7 @@ static __inline__ void cbq_activate_clas
 
 static void cbq_deactivate_class(struct cbq_class *this)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)this->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(this->qdisc);
 	int prio = this->cpriority;
 	struct cbq_class *cl;
 	struct cbq_class *cl_prev = q->active[prio];
@@ -419,7 +419,7 @@ cbq_mark_toplevel(struct cbq_sched_data 
 static int
 cbq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	int len = skb->len;
 	int ret = NET_XMIT_SUCCESS;
 	struct cbq_class *cl = cbq_classify(skb, sch,&ret);
@@ -466,7 +466,7 @@ cbq_enqueue(struct sk_buff *skb, struct 
 static int
 cbq_requeue(struct sk_buff *skb, struct Qdisc *sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl;
 	int ret;
 
@@ -500,7 +500,7 @@ cbq_requeue(struct sk_buff *skb, struct 
 
 static void cbq_ovl_classic(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	psched_tdiff_t delay = PSCHED_TDIFF(cl->undertime, q->now);
 
 	if (!cl->delayed) {
@@ -554,7 +554,7 @@ static void cbq_ovl_classic(struct cbq_c
 
 static void cbq_ovl_rclassic(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	struct cbq_class *this = cl;
 
 	do {
@@ -573,7 +573,7 @@ static void cbq_ovl_rclassic(struct cbq_
 
 static void cbq_ovl_delay(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	psched_tdiff_t delay = PSCHED_TDIFF(cl->undertime, q->now);
 
 	if (!cl->delayed) {
@@ -609,7 +609,7 @@ static void cbq_ovl_delay(struct cbq_cla
 
 static void cbq_ovl_lowprio(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 
 	cl->penalized = jiffies + cl->penalty;
 
@@ -678,7 +678,7 @@ static unsigned long cbq_undelay_prio(st
 static void cbq_undelay(unsigned long arg)
 {
 	struct Qdisc *sch = (struct Qdisc*)arg;
-	struct cbq_sched_data *q = (struct cbq_sched_data*)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	long delay = 0;
 	unsigned pmask;
 
@@ -715,7 +715,7 @@ static int cbq_reshape_fail(struct sk_bu
 {
 	int len = skb->len;
 	struct Qdisc *sch = child->__parent;
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = q->rx_class;
 
 	q->rx_class = NULL;
@@ -863,7 +863,7 @@ cbq_update(struct cbq_sched_data *q)
 static __inline__ struct cbq_class *
 cbq_under_limit(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	struct cbq_class *this_cl = cl;
 
 	if (cl->tparent == NULL)
@@ -903,7 +903,7 @@ cbq_under_limit(struct cbq_class *cl)
 static __inline__ struct sk_buff *
 cbq_dequeue_prio(struct Qdisc *sch, int prio)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl_tail, *cl_prev, *cl;
 	struct sk_buff *skb;
 	int deficit;
@@ -1006,7 +1006,7 @@ next_class:
 static __inline__ struct sk_buff *
 cbq_dequeue_1(struct Qdisc *sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *skb;
 	unsigned activemask;
 
@@ -1025,7 +1025,7 @@ static struct sk_buff *
 cbq_dequeue(struct Qdisc *sch)
 {
 	struct sk_buff *skb;
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	psched_time_t now;
 	psched_tdiff_t incr;
 
@@ -1150,7 +1150,7 @@ static void cbq_normalize_quanta(struct 
 
 static void cbq_sync_defmap(struct cbq_class *cl)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 	struct cbq_class *split = cl->split;
 	unsigned h;
 	int i;
@@ -1216,7 +1216,7 @@ static void cbq_change_defmap(struct cbq
 static void cbq_unlink_class(struct cbq_class *this)
 {
 	struct cbq_class *cl, **clp;
-	struct cbq_sched_data *q = (struct cbq_sched_data*)this->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(this->qdisc);
 
 	for (clp = &q->classes[cbq_hash(this->classid)]; (cl = *clp) != NULL; clp = &cl->next) {
 		if (cl == this) {
@@ -1249,7 +1249,7 @@ static void cbq_unlink_class(struct cbq_
 
 static void cbq_link_class(struct cbq_class *this)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)this->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(this->qdisc);
 	unsigned h = cbq_hash(this->classid);
 	struct cbq_class *parent = this->tparent;
 
@@ -1270,7 +1270,7 @@ static void cbq_link_class(struct cbq_cl
 
 static unsigned int cbq_drop(struct Qdisc* sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl, *cl_head;
 	int prio;
 	unsigned int len;
@@ -1293,7 +1293,7 @@ static unsigned int cbq_drop(struct Qdis
 static void
 cbq_reset(struct Qdisc* sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl;
 	int prio;
 	unsigned h;
@@ -1363,7 +1363,7 @@ static void cbq_addprio(struct cbq_sched
 
 static int cbq_set_wrr(struct cbq_class *cl, struct tc_cbq_wrropt *wrr)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)cl->qdisc->data;
+	struct cbq_sched_data *q = qdisc_priv(cl->qdisc);
 
 	if (wrr->allot)
 		cl->allot = wrr->allot;
@@ -1432,7 +1432,7 @@ static int cbq_set_fopt(struct cbq_class
 
 static int cbq_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct rtattr *tb[TCA_CBQ_MAX];
 	struct tc_ratespec *r;
 
@@ -1623,7 +1623,7 @@ rtattr_failure:
 
 static int cbq_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
 
@@ -1650,7 +1650,7 @@ static int
 cbq_dump_class(struct Qdisc *sch, unsigned long arg,
 	       struct sk_buff *skb, struct tcmsg *tcm)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data*)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class*)arg;
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
@@ -1726,7 +1726,7 @@ cbq_leaf(struct Qdisc *sch, unsigned lon
 
 static unsigned long cbq_get(struct Qdisc *sch, u32 classid)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = cbq_class_lookup(q, classid);
 
 	if (cl) {
@@ -1760,7 +1760,7 @@ static void cbq_destroy_class(struct cbq
 static void
 cbq_destroy(struct Qdisc* sch)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl;
 	unsigned h;
 
@@ -1791,7 +1791,7 @@ static void cbq_put(struct Qdisc *sch, u
 
 	if (--cl->refcnt == 0) {
 #ifdef CONFIG_NET_CLS_POLICE
-		struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+		struct cbq_sched_data *q = qdisc_priv(sch);
 
 		spin_lock_bh(&sch->dev->queue_lock);
 		if (q->rx_class == cl)
@@ -1808,7 +1808,7 @@ cbq_change_class(struct Qdisc *sch, u32 
 		 unsigned long *arg)
 {
 	int err;
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class*)*arg;
 	struct rtattr *opt = tca[TCA_OPTIONS-1];
 	struct rtattr *tb[TCA_CBQ_MAX];
@@ -2004,7 +2004,7 @@ failure:
 
 static int cbq_delete(struct Qdisc *sch, unsigned long arg)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class*)arg;
 
 	if (cl->filters || cl->children || cl == &q->link)
@@ -2042,7 +2042,7 @@ static int cbq_delete(struct Qdisc *sch,
 
 static struct tcf_proto **cbq_find_tcf(struct Qdisc *sch, unsigned long arg)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class *)arg;
 
 	if (cl == NULL)
@@ -2054,7 +2054,7 @@ static struct tcf_proto **cbq_find_tcf(s
 static unsigned long cbq_bind_filter(struct Qdisc *sch, unsigned long parent,
 				     u32 classid)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *p = (struct cbq_class*)parent;
 	struct cbq_class *cl = cbq_class_lookup(q, classid);
 
@@ -2076,7 +2076,7 @@ static void cbq_unbind_filter(struct Qdi
 
 static void cbq_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
-	struct cbq_sched_data *q = (struct cbq_sched_data *)sch->data;
+	struct cbq_sched_data *q = qdisc_priv(sch);
 	unsigned h;
 
 	if (arg->stop)
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_dsmark.c linux-2.6.8-rc3-bk3/net/sched/sch_dsmark.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_dsmark.c	2004-06-16 05:18:59.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_dsmark.c	2004-08-08 17:25:03.999100776 +0000
@@ -30,7 +30,7 @@
 #endif
 
 
-#define PRIV(sch) ((struct dsmark_qdisc_data *) (sch)->data)
+#define PRIV(sch) qdisc_priv(sch)
 
 
 /*
@@ -383,7 +383,6 @@ static void dsmark_destroy(struct Qdisc 
 		tcf_destroy(tp);
 	}
 	qdisc_destroy(p->q);
-	p->q = &noop_qdisc;
 	kfree(p->mask);
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_fifo.c linux-2.6.8-rc3-bk3/net/sched/sch_fifo.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_fifo.c	2004-06-16 05:19:01.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_fifo.c	2004-08-08 17:25:04.002100320 +0000
@@ -45,7 +45,7 @@ struct fifo_sched_data
 static int
 bfifo_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct fifo_sched_data *q = (struct fifo_sched_data *)sch->data;
+	struct fifo_sched_data *q = qdisc_priv(sch);
 
 	if (sch->stats.backlog + skb->len <= q->limit) {
 		__skb_queue_tail(&sch->q, skb);
@@ -106,7 +106,7 @@ fifo_reset(struct Qdisc* sch)
 static int
 pfifo_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct fifo_sched_data *q = (struct fifo_sched_data *)sch->data;
+	struct fifo_sched_data *q = qdisc_priv(sch);
 
 	if (sch->q.qlen < q->limit) {
 		__skb_queue_tail(&sch->q, skb);
@@ -138,7 +138,7 @@ pfifo_dequeue(struct Qdisc* sch)
 
 static int fifo_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct fifo_sched_data *q = (void*)sch->data;
+	struct fifo_sched_data *q = qdisc_priv(sch);
 
 	if (opt == NULL) {
 		unsigned int limit = sch->dev->tx_queue_len ? : 1;
@@ -158,7 +158,7 @@ static int fifo_init(struct Qdisc *sch, 
 
 static int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct fifo_sched_data *q = (void*)sch->data;
+	struct fifo_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct tc_fifo_qopt opt;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_generic.c linux-2.6.8-rc3-bk3/net/sched/sch_generic.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_generic.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_generic.c	2004-08-08 17:25:04.005099864 +0000
@@ -31,6 +31,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/init.h>
 #include <linux/rcupdate.h>
+#include <linux/list.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
 
@@ -45,10 +46,11 @@
    The idea is the following:
    - enqueue, dequeue are serialized via top level device
      spinlock dev->queue_lock.
-   - tree walking is protected by read_lock(qdisc_tree_lock)
+   - tree walking is protected by read_lock_bh(qdisc_tree_lock)
      and this lock is used only in process context.
-   - updates to tree are made only under rtnl semaphore,
-     hence this lock may be made without local bh disabling.
+   - updates to tree are made under rtnl semaphore or
+     from softirq context (__qdisc_destroy rcu-callback)
+     hence this lock needs local bh disabling.
 
    qdisc_tree_lock must be grabbed BEFORE dev->queue_lock!
  */
@@ -56,14 +58,14 @@ rwlock_t qdisc_tree_lock = RW_LOCK_UNLOC
 
 void qdisc_lock_tree(struct net_device *dev)
 {
-	write_lock(&qdisc_tree_lock);
+	write_lock_bh(&qdisc_tree_lock);
 	spin_lock_bh(&dev->queue_lock);
 }
 
 void qdisc_unlock_tree(struct net_device *dev)
 {
 	spin_unlock_bh(&dev->queue_lock);
-	write_unlock(&qdisc_tree_lock);
+	write_unlock_bh(&qdisc_tree_lock);
 }
 
 /* 
@@ -283,10 +285,9 @@ static const u8 prio2band[TC_PRIO_MAX+1]
 static int
 pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc* qdisc)
 {
-	struct sk_buff_head *list;
+	struct sk_buff_head *list = qdisc_priv(qdisc);
 
-	list = ((struct sk_buff_head*)qdisc->data) +
-		prio2band[skb->priority&TC_PRIO_MAX];
+	list += prio2band[skb->priority&TC_PRIO_MAX];
 
 	if (list->qlen < qdisc->dev->tx_queue_len) {
 		__skb_queue_tail(list, skb);
@@ -304,7 +305,7 @@ static struct sk_buff *
 pfifo_fast_dequeue(struct Qdisc* qdisc)
 {
 	int prio;
-	struct sk_buff_head *list = ((struct sk_buff_head*)qdisc->data);
+	struct sk_buff_head *list = qdisc_priv(qdisc);
 	struct sk_buff *skb;
 
 	for (prio = 0; prio < 3; prio++, list++) {
@@ -320,10 +321,9 @@ pfifo_fast_dequeue(struct Qdisc* qdisc)
 static int
 pfifo_fast_requeue(struct sk_buff *skb, struct Qdisc* qdisc)
 {
-	struct sk_buff_head *list;
+	struct sk_buff_head *list = qdisc_priv(qdisc);
 
-	list = ((struct sk_buff_head*)qdisc->data) +
-		prio2band[skb->priority&TC_PRIO_MAX];
+	list += prio2band[skb->priority&TC_PRIO_MAX];
 
 	__skb_queue_head(list, skb);
 	qdisc->q.qlen++;
@@ -334,7 +334,7 @@ static void
 pfifo_fast_reset(struct Qdisc* qdisc)
 {
 	int prio;
-	struct sk_buff_head *list = ((struct sk_buff_head*)qdisc->data);
+	struct sk_buff_head *list = qdisc_priv(qdisc);
 
 	for (prio=0; prio < 3; prio++)
 		skb_queue_purge(list+prio);
@@ -359,9 +359,7 @@ rtattr_failure:
 static int pfifo_fast_init(struct Qdisc *qdisc, struct rtattr *opt)
 {
 	int i;
-	struct sk_buff_head *list;
-
-	list = ((struct sk_buff_head*)qdisc->data);
+	struct sk_buff_head *list = qdisc_priv(qdisc);
 
 	for (i=0; i<3; i++)
 		skb_queue_head_init(list+i);
@@ -385,19 +383,30 @@ static struct Qdisc_ops pfifo_fast_ops =
 
 struct Qdisc * qdisc_create_dflt(struct net_device *dev, struct Qdisc_ops *ops)
 {
+	void *p;
 	struct Qdisc *sch;
-	int size = sizeof(*sch) + ops->priv_size;
+	int size;
 
-	sch = kmalloc(size, GFP_KERNEL);
-	if (!sch)
+	/* ensure that the Qdisc and the private data are 32-byte aligned */
+	size = ((sizeof(*sch) + QDISC_ALIGN_CONST) & ~QDISC_ALIGN_CONST);
+	size += ops->priv_size + QDISC_ALIGN_CONST;
+
+	p = kmalloc(size, GFP_KERNEL);
+	if (!p)
 		return NULL;
-	memset(sch, 0, size);
+	memset(p, 0, size);
+
+	sch = (struct Qdisc *)(((unsigned long)p + QDISC_ALIGN_CONST) 
+			       & ~QDISC_ALIGN_CONST);
+	sch->padded = (char *)sch - (char *)p;
 
+	INIT_LIST_HEAD(&sch->list);
 	skb_queue_head_init(&sch->q);
 	sch->ops = ops;
 	sch->enqueue = ops->enqueue;
 	sch->dequeue = ops->dequeue;
 	sch->dev = dev;
+	dev_hold(dev);
 	sch->stats_lock = &dev->queue_lock;
 	atomic_set(&sch->refcnt, 1);
 	/* enqueue is accessed locklessly - make sure it's visible
@@ -406,7 +415,7 @@ struct Qdisc * qdisc_create_dflt(struct 
 	if (!ops->init || ops->init(sch, NULL) == 0)
 		return sch;
 
-	kfree(sch);
+	kfree(p);
 	return NULL;
 }
 
@@ -431,40 +440,29 @@ static void __qdisc_destroy(struct rcu_h
 #ifdef CONFIG_NET_ESTIMATOR
 	qdisc_kill_estimator(&qdisc->stats);
 #endif
+	write_lock(&qdisc_tree_lock);
 	if (ops->reset)
 		ops->reset(qdisc);
 	if (ops->destroy)
 		ops->destroy(qdisc);
+	write_unlock(&qdisc_tree_lock);
 	module_put(ops->owner);
 
+	dev_put(qdisc->dev);
 	if (!(qdisc->flags&TCQ_F_BUILTIN))
-		kfree(qdisc);
+		kfree((char *) qdisc - qdisc->padded);
 }
 
 /* Under dev->queue_lock and BH! */
 
 void qdisc_destroy(struct Qdisc *qdisc)
 {
-	struct net_device *dev = qdisc->dev;
-
 	if (!atomic_dec_and_test(&qdisc->refcnt))
 		return;
-
-	if (dev) {
-		struct Qdisc *q, **qp;
-		for (qp = &qdisc->dev->qdisc_list; (q=*qp) != NULL; qp = &q->next) {
-			if (q == qdisc) {
-				*qp = q->next;
-				break;
-			}
-		}
-	}
-
+	list_del(&qdisc->list);
 	call_rcu(&qdisc->q_rcu, __qdisc_destroy);
-
 }
 
-
 void dev_activate(struct net_device *dev)
 {
 	/* No queueing discipline is attached to device;
@@ -481,18 +479,15 @@ void dev_activate(struct net_device *dev
 				printk(KERN_INFO "%s: activation failed\n", dev->name);
 				return;
 			}
-
-			write_lock(&qdisc_tree_lock);
-			qdisc->next = dev->qdisc_list;
-			dev->qdisc_list = qdisc;
-			write_unlock(&qdisc_tree_lock);
-
+			write_lock_bh(&qdisc_tree_lock);
+			list_add_tail(&qdisc->list, &dev->qdisc_list);
+			write_unlock_bh(&qdisc_tree_lock);
 		} else {
 			qdisc =  &noqueue_qdisc;
 		}
-		write_lock(&qdisc_tree_lock);
+		write_lock_bh(&qdisc_tree_lock);
 		dev->qdisc_sleeping = qdisc;
-		write_unlock(&qdisc_tree_lock);
+		write_unlock_bh(&qdisc_tree_lock);
 	}
 
 	spin_lock_bh(&dev->queue_lock);
@@ -528,7 +523,7 @@ void dev_init_scheduler(struct net_devic
 	qdisc_lock_tree(dev);
 	dev->qdisc = &noop_qdisc;
 	dev->qdisc_sleeping = &noop_qdisc;
-	dev->qdisc_list = NULL;
+	INIT_LIST_HEAD(&dev->qdisc_list);
 	qdisc_unlock_tree(dev);
 
 	dev_watchdog_init(dev);
@@ -549,9 +544,7 @@ void dev_shutdown(struct net_device *dev
 		qdisc_destroy(qdisc);
         }
 #endif
-	BUG_TRAP(dev->qdisc_list == NULL);
 	BUG_TRAP(!timer_pending(&dev->watchdog_timer));
-	dev->qdisc_list = NULL;
 	qdisc_unlock_tree(dev);
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_gred.c linux-2.6.8-rc3-bk3/net/sched/sch_gred.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_gred.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_gred.c	2004-08-08 17:25:04.008099408 +0000
@@ -106,7 +106,7 @@ gred_enqueue(struct sk_buff *skb, struct
 {
 	psched_time_t now;
 	struct gred_sched_data *q=NULL;
-	struct gred_sched *t= (struct gred_sched *)sch->data;
+	struct gred_sched *t= qdisc_priv(sch);
 	unsigned long	qave=0;	
 	int i=0;
 
@@ -215,7 +215,7 @@ static int
 gred_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
 	struct gred_sched_data *q;
-	struct gred_sched *t= (struct gred_sched *)sch->data;
+	struct gred_sched *t= qdisc_priv(sch);
 	q= t->tab[(skb->tc_index&0xf)];
 /* error checking here -- probably unnecessary */
 	PSCHED_SET_PASTPERFECT(q->qidlestart);
@@ -231,7 +231,7 @@ gred_dequeue(struct Qdisc* sch)
 {
 	struct sk_buff *skb;
 	struct gred_sched_data *q;
-	struct gred_sched *t= (struct gred_sched *)sch->data;
+	struct gred_sched *t= qdisc_priv(sch);
 
 	skb = __skb_dequeue(&sch->q);
 	if (skb) {
@@ -264,7 +264,7 @@ static unsigned int gred_drop(struct Qdi
 	struct sk_buff *skb;
 
 	struct gred_sched_data *q;
-	struct gred_sched *t= (struct gred_sched *)sch->data;
+	struct gred_sched *t= qdisc_priv(sch);
 
 	skb = __skb_dequeue_tail(&sch->q);
 	if (skb) {
@@ -300,7 +300,7 @@ static void gred_reset(struct Qdisc* sch
 {
 	int i;
 	struct gred_sched_data *q;
-	struct gred_sched *t= (struct gred_sched *)sch->data;
+	struct gred_sched *t= qdisc_priv(sch);
 
 	__skb_queue_purge(&sch->q);
 
@@ -323,7 +323,7 @@ static void gred_reset(struct Qdisc* sch
 
 static int gred_change(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct gred_sched *table = (struct gred_sched *)sch->data;
+	struct gred_sched *table = qdisc_priv(sch);
 	struct gred_sched_data *q;
 	struct tc_gred_qopt *ctl;
 	struct tc_gred_sopt *sopt;
@@ -469,7 +469,7 @@ static int gred_change(struct Qdisc *sch
 
 static int gred_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct gred_sched *table = (struct gred_sched *)sch->data;
+	struct gred_sched *table = qdisc_priv(sch);
 	struct tc_gred_sopt *sopt;
 	struct rtattr *tb[TCA_GRED_STAB];
 	struct rtattr *tb2[TCA_GRED_DPS];
@@ -502,7 +502,7 @@ static int gred_dump(struct Qdisc *sch, 
 	struct rtattr *rta;
 	struct tc_gred_qopt *opt = NULL ;
 	struct tc_gred_qopt *dst;
-	struct gred_sched *table = (struct gred_sched *)sch->data;
+	struct gred_sched *table = qdisc_priv(sch);
 	struct gred_sched_data *q;
 	int i;
 	unsigned char	 *b = skb->tail;
@@ -593,7 +593,7 @@ rtattr_failure:
 
 static void gred_destroy(struct Qdisc *sch)
 {
-	struct gred_sched *table = (struct gred_sched *)sch->data;
+	struct gred_sched *table = qdisc_priv(sch);
 	int i;
 
 	for (i = 0;i < table->DPs; i++) {
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_hfsc.c linux-2.6.8-rc3-bk3/net/sched/sch_hfsc.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_hfsc.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_hfsc.c	2004-08-08 17:25:04.014098496 +0000
@@ -1016,7 +1016,7 @@ hfsc_hash(u32 h)
 static inline struct hfsc_class *
 hfsc_find_class(u32 classid, struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 
 	list_for_each_entry(cl, &q->clhash[hfsc_hash(classid)], hlist) {
@@ -1061,7 +1061,7 @@ static int
 hfsc_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
                   struct rtattr **tca, unsigned long *arg)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl = (struct hfsc_class *)*arg;
 	struct hfsc_class *parent = NULL;
 	struct rtattr *opt = tca[TCA_OPTIONS-1];
@@ -1204,7 +1204,7 @@ hfsc_destroy_filters(struct tcf_proto **
 static void
 hfsc_destroy_class(struct Qdisc *sch, struct hfsc_class *cl)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 
 	hfsc_destroy_filters(&cl->filter_list);
 	qdisc_destroy(cl->qdisc);
@@ -1218,7 +1218,7 @@ hfsc_destroy_class(struct Qdisc *sch, st
 static int
 hfsc_delete_class(struct Qdisc *sch, unsigned long arg)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl = (struct hfsc_class *)arg;
 
 	if (cl->level > 0 || cl->filter_cnt > 0 || cl == &q->root)
@@ -1240,7 +1240,7 @@ hfsc_delete_class(struct Qdisc *sch, uns
 static struct hfsc_class *
 hfsc_classify(struct sk_buff *skb, struct Qdisc *sch, int *qres)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	struct tcf_result res;
 	struct tcf_proto *tcf;
@@ -1381,7 +1381,7 @@ hfsc_unbind_tcf(struct Qdisc *sch, unsig
 static struct tcf_proto **
 hfsc_tcf_chain(struct Qdisc *sch, unsigned long arg)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl = (struct hfsc_class *)arg;
 
 	if (cl == NULL)
@@ -1489,7 +1489,7 @@ hfsc_dump_class(struct Qdisc *sch, unsig
 static void
 hfsc_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	unsigned int i;
 
@@ -1523,7 +1523,7 @@ hfsc_watchdog(unsigned long arg)
 static void
 hfsc_schedule_watchdog(struct Qdisc *sch, u64 cur_time)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	u64 next_time = 0;
 	long delay;
@@ -1545,7 +1545,7 @@ hfsc_schedule_watchdog(struct Qdisc *sch
 static int
 hfsc_init_qdisc(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct tc_hfsc_qopt *qopt;
 	unsigned int i;
 
@@ -1585,7 +1585,7 @@ hfsc_init_qdisc(struct Qdisc *sch, struc
 static int
 hfsc_change_qdisc(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct tc_hfsc_qopt *qopt;
 
 	if (opt == NULL || RTA_PAYLOAD(opt) < sizeof(*qopt))
@@ -1632,7 +1632,7 @@ hfsc_reset_class(struct hfsc_class *cl)
 static void
 hfsc_reset_qdisc(struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	unsigned int i;
 
@@ -1651,7 +1651,7 @@ hfsc_reset_qdisc(struct Qdisc *sch)
 static void
 hfsc_destroy_qdisc(struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl, *next;
 	unsigned int i;
 
@@ -1666,7 +1666,7 @@ hfsc_destroy_qdisc(struct Qdisc *sch)
 static int
 hfsc_dump_qdisc(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	unsigned char *b = skb->tail;
 	struct tc_hfsc_qopt qopt;
 
@@ -1730,7 +1730,7 @@ hfsc_enqueue(struct sk_buff *skb, struct
 static struct sk_buff *
 hfsc_dequeue(struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	struct sk_buff *skb;
 	u64 cur_time;
@@ -1799,7 +1799,7 @@ hfsc_dequeue(struct Qdisc *sch)
 static int
 hfsc_requeue(struct sk_buff *skb, struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 
 	__skb_queue_head(&q->requeue, skb);
 	sch->q.qlen++;
@@ -1809,7 +1809,7 @@ hfsc_requeue(struct sk_buff *skb, struct
 static unsigned int
 hfsc_drop(struct Qdisc *sch)
 {
-	struct hfsc_sched *q = (struct hfsc_sched *)sch->data;
+	struct hfsc_sched *q = qdisc_priv(sch);
 	struct hfsc_class *cl;
 	unsigned int len;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_htb.c linux-2.6.8-rc3-bk3/net/sched/sch_htb.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_htb.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_htb.c	2004-08-08 17:25:04.021097432 +0000
@@ -267,7 +267,7 @@ static __inline__ int htb_hash(u32 h) 
 /* find class in global hash table using given handle */
 static __inline__ struct htb_class *htb_find(u32 handle, struct Qdisc *sch)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct list_head *p;
 	if (TC_H_MAJ(handle) != sch->handle) 
 		return NULL;
@@ -300,7 +300,7 @@ static inline u32 htb_classid(struct htb
 
 static struct htb_class *htb_classify(struct sk_buff *skb, struct Qdisc *sch, int *qres)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl;
 	struct tcf_result res;
 	struct tcf_proto *tcf;
@@ -712,7 +712,7 @@ htb_deactivate(struct htb_sched *q,struc
 static int htb_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
     int ret = NET_XMIT_SUCCESS;
-    struct htb_sched *q = (struct htb_sched *)sch->data;
+    struct htb_sched *q = qdisc_priv(sch);
     struct htb_class *cl = htb_classify(skb,sch,&ret);
 
 
@@ -759,7 +759,7 @@ static int htb_enqueue(struct sk_buff *s
 /* TODO: requeuing packet charges it to policers again !! */
 static int htb_requeue(struct sk_buff *skb, struct Qdisc *sch)
 {
-    struct htb_sched *q = (struct htb_sched *)sch->data;
+    struct htb_sched *q = qdisc_priv(sch);
     int ret =  NET_XMIT_SUCCESS;
     struct htb_class *cl = htb_classify(skb,sch, &ret);
     struct sk_buff *tskb;
@@ -800,7 +800,7 @@ static void htb_timer(unsigned long arg)
 static void htb_rate_timer(unsigned long arg)
 {
 	struct Qdisc *sch = (struct Qdisc*)arg;
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct list_head *p;
 
 	/* lock queue so that we can muck with it */
@@ -1060,7 +1060,7 @@ next:
 
 static void htb_delay_by(struct Qdisc *sch,long delay)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	if (delay <= 0) delay = 1;
 	if (unlikely(delay > 5*HZ)) {
 		if (net_ratelimit())
@@ -1077,7 +1077,7 @@ static void htb_delay_by(struct Qdisc *s
 static struct sk_buff *htb_dequeue(struct Qdisc *sch)
 {
 	struct sk_buff *skb = NULL;
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	int level;
 	long min_delay;
 #ifdef HTB_DEBUG
@@ -1147,7 +1147,7 @@ fin:
 /* try to drop from each class (by prio) until one succeed */
 static unsigned int htb_drop(struct Qdisc* sch)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	int prio;
 
 	for (prio = TC_HTB_NUMPRIO - 1; prio >= 0; prio--) {
@@ -1172,7 +1172,7 @@ static unsigned int htb_drop(struct Qdis
 /* always caled under BH & queue lock */
 static void htb_reset(struct Qdisc* sch)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	int i;
 	HTB_DBG(0,1,"htb_reset sch=%p, handle=%X\n",sch,sch->handle);
 
@@ -1210,7 +1210,7 @@ static void htb_reset(struct Qdisc* sch)
 
 static int htb_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct htb_sched *q = (struct htb_sched*)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct rtattr *tb[TCA_HTB_INIT];
 	struct tc_htb_glob *gopt;
 	int i;
@@ -1265,7 +1265,7 @@ static int htb_init(struct Qdisc *sch, s
 
 static int htb_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct htb_sched *q = (struct htb_sched*)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
 	struct tc_htb_glob gopt;
@@ -1300,7 +1300,7 @@ static int htb_dump_class(struct Qdisc *
 	struct sk_buff *skb, struct tcmsg *tcm)
 {
 #ifdef HTB_DEBUG
-	struct htb_sched *q = (struct htb_sched*)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 #endif
 	struct htb_class *cl = (struct htb_class*)arg;
 	unsigned char	 *b = skb->tail;
@@ -1358,7 +1358,7 @@ static int htb_graft(struct Qdisc *sch, 
 		sch_tree_lock(sch);
 		if ((*old = xchg(&cl->un.leaf.q, new)) != NULL) {
 			if (cl->prio_activity)
-				htb_deactivate ((struct htb_sched*)sch->data,cl);
+				htb_deactivate (qdisc_priv(sch),cl);
 
 			/* TODO: is it correct ? Why CBQ doesn't do it ? */
 			sch->q.qlen -= (*old)->q.qlen;	
@@ -1379,7 +1379,7 @@ static struct Qdisc * htb_leaf(struct Qd
 static unsigned long htb_get(struct Qdisc *sch, u32 classid)
 {
 #ifdef HTB_DEBUG
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 #endif
 	struct htb_class *cl = htb_find(classid,sch);
 	HTB_DBG(0,1,"htb_get clid=%X q=%p cl=%p ref=%d\n",classid,q,cl,cl?cl->refcnt:0);
@@ -1400,7 +1400,7 @@ static void htb_destroy_filters(struct t
 
 static void htb_destroy_class(struct Qdisc* sch,struct htb_class *cl)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	HTB_DBG(0,1,"htb_destrycls clid=%X ref=%d\n", cl?cl->classid:0,cl?cl->refcnt:0);
 	if (!cl->level) {
 		BUG_TRAP(cl->un.leaf.q);
@@ -1435,7 +1435,7 @@ static void htb_destroy_class(struct Qdi
 /* always caled under BH & queue lock */
 static void htb_destroy(struct Qdisc* sch)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	HTB_DBG(0,1,"htb_destroy q=%p\n",q);
 
 	del_timer_sync (&q->timer);
@@ -1457,7 +1457,7 @@ static void htb_destroy(struct Qdisc* sc
 
 static int htb_delete(struct Qdisc *sch, unsigned long arg)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class*)arg;
 	HTB_DBG(0,1,"htb_delete q=%p cl=%X ref=%d\n",q,cl?cl->classid:0,cl?cl->refcnt:0);
 
@@ -1484,7 +1484,7 @@ static int htb_delete(struct Qdisc *sch,
 static void htb_put(struct Qdisc *sch, unsigned long arg)
 {
 #ifdef HTB_DEBUG
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 #endif
 	struct htb_class *cl = (struct htb_class*)arg;
 	HTB_DBG(0,1,"htb_put q=%p cl=%X ref=%d\n",q,cl?cl->classid:0,cl?cl->refcnt:0);
@@ -1497,7 +1497,7 @@ static int htb_change_class(struct Qdisc
 		u32 parentid, struct rtattr **tca, unsigned long *arg)
 {
 	int err = -EINVAL;
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class*)*arg,*parent;
 	struct rtattr *opt = tca[TCA_OPTIONS-1];
 	struct qdisc_rate_table *rtab = NULL, *ctab = NULL;
@@ -1623,7 +1623,7 @@ failure:
 
 static struct tcf_proto **htb_find_tcf(struct Qdisc *sch, unsigned long arg)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class *)arg;
 	struct tcf_proto **fl = cl ? &cl->filter_list : &q->filter_list;
 	HTB_DBG(0,2,"htb_tcf q=%p clid=%X fref=%d fl=%p\n",q,cl?cl->classid:0,cl?cl->filter_cnt:q->filter_cnt,*fl);
@@ -1633,7 +1633,7 @@ static struct tcf_proto **htb_find_tcf(s
 static unsigned long htb_bind_filter(struct Qdisc *sch, unsigned long parent,
 	u32 classid)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = htb_find (classid,sch);
 	HTB_DBG(0,2,"htb_bind q=%p clid=%X cl=%p fref=%d\n",q,classid,cl,cl?cl->filter_cnt:q->filter_cnt);
 	/*if (cl && !cl->level) return 0;
@@ -1654,7 +1654,7 @@ static unsigned long htb_bind_filter(str
 
 static void htb_unbind_filter(struct Qdisc *sch, unsigned long arg)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class *)arg;
 	HTB_DBG(0,2,"htb_unbind q=%p cl=%p fref=%d\n",q,cl,cl?cl->filter_cnt:q->filter_cnt);
 	if (cl) 
@@ -1665,7 +1665,7 @@ static void htb_unbind_filter(struct Qdi
 
 static void htb_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
-	struct htb_sched *q = (struct htb_sched *)sch->data;
+	struct htb_sched *q = qdisc_priv(sch);
 	int i;
 
 	if (arg->stop)
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_ingress.c linux-2.6.8-rc3-bk3/net/sched/sch_ingress.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_ingress.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_ingress.c	2004-08-08 17:25:04.022097280 +0000
@@ -40,7 +40,7 @@
 #endif
 
 
-#define PRIV(sch) ((struct ingress_qdisc_data *) (sch)->data)
+#define PRIV(sch) qdisc_priv(sch)
 
 
 /* Thanks to Doron Oz for this hack
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_netem.c linux-2.6.8-rc3-bk3/net/sched/sch_netem.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_netem.c	2004-08-03 21:30:27.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_netem.c	2004-08-08 17:25:04.027096520 +0000
@@ -603,7 +603,7 @@ static inline int tabledist(int mu, int 
  */
 static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	struct netem_skb_cb *cb = (struct netem_skb_cb *)skb->cb;
 	psched_time_t now;
 	long delay;
@@ -659,7 +659,7 @@ static int netem_enqueue(struct sk_buff 
 /* Requeue packets but don't change time stamp */
 static int netem_requeue(struct sk_buff *skb, struct Qdisc *sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	int ret;
 
 	if ((ret = q->qdisc->ops->requeue(skb, q->qdisc)) == 0)
@@ -670,7 +670,7 @@ static int netem_requeue(struct sk_buff 
 
 static unsigned int netem_drop(struct Qdisc* sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	unsigned int len;
 
 	if ((len = q->qdisc->ops->drop(q->qdisc)) != 0) {
@@ -686,7 +686,7 @@ static unsigned int netem_drop(struct Qd
  */
 static struct sk_buff *netem_dequeue(struct Qdisc *sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *skb;
 	psched_time_t now;
 
@@ -726,7 +726,7 @@ static void netem_watchdog(unsigned long
 
 static void netem_reset(struct Qdisc *sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 
 	qdisc_reset(q->qdisc);
 	skb_queue_purge(&q->delayed);
@@ -754,7 +754,7 @@ static int set_fifo_limit(struct Qdisc *
 
 static int netem_change(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	struct tc_netem_qopt *qopt = RTA_DATA(opt);
 	struct Qdisc *child;
 	int ret;
@@ -791,7 +791,7 @@ static int netem_change(struct Qdisc *sc
 
 static int netem_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 
 	if (!opt)
 		return -EINVAL;
@@ -809,23 +809,21 @@ static int netem_init(struct Qdisc *sch,
 
 static void netem_destroy(struct Qdisc *sch)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 
 	del_timer_sync(&q->timer);
-
 	qdisc_destroy(q->qdisc);
-	q->qdisc = &noop_qdisc;
 }
 
 static int netem_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct tc_netem_qopt qopt;
 
 	qopt.latency = q->latency;
 	qopt.jitter = q->jitter;
-	qopt.limit = sch->dev->tx_queue_len;
+	qopt.limit = q->limit;
 	qopt.loss = q->loss;
 	qopt.gap = q->gap;
 
@@ -841,7 +839,7 @@ rtattr_failure:
 static int netem_dump_class(struct Qdisc *sch, unsigned long cl,
 			  struct sk_buff *skb, struct tcmsg *tcm)
 {
-	struct netem_sched_data *q = (struct netem_sched_data*)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 
 	if (cl != 1) 	/* only one class */
 		return -ENOENT;
@@ -855,7 +853,7 @@ static int netem_dump_class(struct Qdisc
 static int netem_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 		     struct Qdisc **old)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 
 	if (new == NULL)
 		new = &noop_qdisc;
@@ -871,7 +869,7 @@ static int netem_graft(struct Qdisc *sch
 
 static struct Qdisc *netem_leaf(struct Qdisc *sch, unsigned long arg)
 {
-	struct netem_sched_data *q = (struct netem_sched_data *)sch->data;
+	struct netem_sched_data *q = qdisc_priv(sch);
 	return q->qdisc;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_prio.c linux-2.6.8-rc3-bk3/net/sched/sch_prio.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_prio.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_prio.c	2004-08-08 17:25:04.030096064 +0000
@@ -49,7 +49,7 @@ struct prio_sched_data
 
 struct Qdisc *prio_classify(struct sk_buff *skb, struct Qdisc *sch,int *r)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	u32 band = skb->priority;
 	struct tcf_result res;
 
@@ -151,7 +151,7 @@ static struct sk_buff *
 prio_dequeue(struct Qdisc* sch)
 {
 	struct sk_buff *skb;
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	int prio;
 	struct Qdisc *qdisc;
 
@@ -169,7 +169,7 @@ prio_dequeue(struct Qdisc* sch)
 
 static unsigned int prio_drop(struct Qdisc* sch)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	int prio;
 	unsigned int len;
 	struct Qdisc *qdisc;
@@ -189,7 +189,7 @@ static void
 prio_reset(struct Qdisc* sch)
 {
 	int prio;
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 
 	for (prio=0; prio<q->bands; prio++)
 		qdisc_reset(q->queues[prio]);
@@ -200,7 +200,7 @@ static void
 prio_destroy(struct Qdisc* sch)
 {
 	int prio;
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	struct tcf_proto *tp;
 
 	while ((tp = q->filter_list) != NULL) {
@@ -208,15 +208,13 @@ prio_destroy(struct Qdisc* sch)
 		tcf_destroy(tp);
 	}
 
-	for (prio=0; prio<q->bands; prio++) {
+	for (prio=0; prio<q->bands; prio++)
 		qdisc_destroy(q->queues[prio]);
-		q->queues[prio] = &noop_qdisc;
-	}
 }
 
 static int prio_tune(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	struct tc_prio_qopt *qopt = RTA_DATA(opt);
 	int i;
 
@@ -261,7 +259,7 @@ static int prio_tune(struct Qdisc *sch, 
 
 static int prio_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	int i;
 
 	for (i=0; i<TCQ_PRIO_BANDS; i++)
@@ -280,7 +278,7 @@ static int prio_init(struct Qdisc *sch, 
 
 static int prio_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct tc_prio_qopt opt;
 
@@ -297,7 +295,7 @@ rtattr_failure:
 static int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 		      struct Qdisc **old)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	unsigned long band = arg - 1;
 
 	if (band >= q->bands)
@@ -319,7 +317,7 @@ static int prio_graft(struct Qdisc *sch,
 static struct Qdisc *
 prio_leaf(struct Qdisc *sch, unsigned long arg)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	unsigned long band = arg - 1;
 
 	if (band >= q->bands)
@@ -330,7 +328,7 @@ prio_leaf(struct Qdisc *sch, unsigned lo
 
 static unsigned long prio_get(struct Qdisc *sch, u32 classid)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	unsigned long band = TC_H_MIN(classid);
 
 	if (band - 1 >= q->bands)
@@ -352,7 +350,7 @@ static void prio_put(struct Qdisc *q, un
 static int prio_change(struct Qdisc *sch, u32 handle, u32 parent, struct rtattr **tca, unsigned long *arg)
 {
 	unsigned long cl = *arg;
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 
 	if (cl - 1 > q->bands)
 		return -ENOENT;
@@ -361,7 +359,7 @@ static int prio_change(struct Qdisc *sch
 
 static int prio_delete(struct Qdisc *sch, unsigned long cl)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	if (cl - 1 > q->bands)
 		return -ENOENT;
 	return 0;
@@ -371,7 +369,7 @@ static int prio_delete(struct Qdisc *sch
 static int prio_dump_class(struct Qdisc *sch, unsigned long cl, struct sk_buff *skb,
 			   struct tcmsg *tcm)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 
 	if (cl - 1 > q->bands)
 		return -ENOENT;
@@ -383,7 +381,7 @@ static int prio_dump_class(struct Qdisc 
 
 static void prio_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 	int prio;
 
 	if (arg->stop)
@@ -404,7 +402,7 @@ static void prio_walk(struct Qdisc *sch,
 
 static struct tcf_proto ** prio_find_tcf(struct Qdisc *sch, unsigned long cl)
 {
-	struct prio_sched_data *q = (struct prio_sched_data *)sch->data;
+	struct prio_sched_data *q = qdisc_priv(sch);
 
 	if (cl)
 		return NULL;
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_red.c linux-2.6.8-rc3-bk3/net/sched/sch_red.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_red.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_red.c	2004-08-08 17:25:04.032095760 +0000
@@ -180,7 +180,7 @@ static int red_ecn_mark(struct sk_buff *
 static int
 red_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 
 	psched_time_t now;
 
@@ -303,7 +303,7 @@ drop:
 static int
 red_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 
 	PSCHED_SET_PASTPERFECT(q->qidlestart);
 
@@ -316,7 +316,7 @@ static struct sk_buff *
 red_dequeue(struct Qdisc* sch)
 {
 	struct sk_buff *skb;
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 
 	skb = __skb_dequeue(&sch->q);
 	if (skb) {
@@ -330,7 +330,7 @@ red_dequeue(struct Qdisc* sch)
 static unsigned int red_drop(struct Qdisc* sch)
 {
 	struct sk_buff *skb;
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 
 	skb = __skb_dequeue_tail(&sch->q);
 	if (skb) {
@@ -347,7 +347,7 @@ static unsigned int red_drop(struct Qdis
 
 static void red_reset(struct Qdisc* sch)
 {
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 
 	__skb_queue_purge(&sch->q);
 	sch->stats.backlog = 0;
@@ -358,7 +358,7 @@ static void red_reset(struct Qdisc* sch)
 
 static int red_change(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 	struct rtattr *tb[TCA_RED_STAB];
 	struct tc_red_qopt *ctl;
 
@@ -407,7 +407,7 @@ rtattr_failure:
 
 static int red_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct red_sched_data *q = (struct red_sched_data *)sch->data;
+	struct red_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
 	struct tc_red_qopt opt;
@@ -434,10 +434,6 @@ rtattr_failure:
 	return -1;
 }
 
-static void red_destroy(struct Qdisc *sch)
-{
-}
-
 static struct Qdisc_ops red_qdisc_ops = {
 	.next		=	NULL,
 	.cl_ops		=	NULL,
@@ -449,7 +445,6 @@ static struct Qdisc_ops red_qdisc_ops = 
 	.drop		=	red_drop,
 	.init		=	red_init,
 	.reset		=	red_reset,
-	.destroy	=	red_destroy,
 	.change		=	red_change,
 	.dump		=	red_dump,
 	.owner		=	THIS_MODULE,
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_sfq.c linux-2.6.8-rc3-bk3/net/sched/sch_sfq.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_sfq.c	2004-06-16 05:20:03.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_sfq.c	2004-08-08 17:25:04.036095152 +0000
@@ -211,7 +211,7 @@ static inline void sfq_inc(struct sfq_sc
 
 static unsigned int sfq_drop(struct Qdisc *sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	sfq_index d = q->max_depth;
 	struct sk_buff *skb;
 	unsigned int len;
@@ -253,7 +253,7 @@ static unsigned int sfq_drop(struct Qdis
 static int
 sfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	unsigned hash = sfq_hash(q, skb);
 	sfq_index x;
 
@@ -288,7 +288,7 @@ sfq_enqueue(struct sk_buff *skb, struct 
 static int
 sfq_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	unsigned hash = sfq_hash(q, skb);
 	sfq_index x;
 
@@ -324,7 +324,7 @@ sfq_requeue(struct sk_buff *skb, struct 
 static struct sk_buff *
 sfq_dequeue(struct Qdisc* sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *skb;
 	sfq_index a, old_a;
 
@@ -369,7 +369,7 @@ sfq_reset(struct Qdisc* sch)
 static void sfq_perturbation(unsigned long arg)
 {
 	struct Qdisc *sch = (struct Qdisc*)arg;
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 
 	q->perturbation = net_random()&0x1F;
 	q->perturb_timer.expires = jiffies + q->perturb_period;
@@ -382,7 +382,7 @@ static void sfq_perturbation(unsigned lo
 
 static int sfq_change(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	struct tc_sfq_qopt *ctl = RTA_DATA(opt);
 
 	if (opt->rta_len < RTA_LENGTH(sizeof(*ctl)))
@@ -408,7 +408,7 @@ static int sfq_change(struct Qdisc *sch,
 
 static int sfq_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	int i;
 
 	init_timer(&q->perturb_timer);
@@ -440,13 +440,13 @@ static int sfq_init(struct Qdisc *sch, s
 
 static void sfq_destroy(struct Qdisc *sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	del_timer(&q->perturb_timer);
 }
 
 static int sfq_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct tc_sfq_qopt opt;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_tbf.c linux-2.6.8-rc3-bk3/net/sched/sch_tbf.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_tbf.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_tbf.c	2004-08-08 17:25:04.038094848 +0000
@@ -137,7 +137,7 @@ struct tbf_sched_data
 
 static int tbf_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	int ret;
 
 	if (skb->len > q->max_size) {
@@ -163,7 +163,7 @@ static int tbf_enqueue(struct sk_buff *s
 
 static int tbf_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	int ret;
 
 	if ((ret = q->qdisc->ops->requeue(skb, q->qdisc)) == 0)
@@ -174,7 +174,7 @@ static int tbf_requeue(struct sk_buff *s
 
 static unsigned int tbf_drop(struct Qdisc* sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	unsigned int len;
 
 	if ((len = q->qdisc->ops->drop(q->qdisc)) != 0) {
@@ -194,7 +194,7 @@ static void tbf_watchdog(unsigned long a
 
 static struct sk_buff *tbf_dequeue(struct Qdisc* sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *skb;
 
 	skb = q->qdisc->dequeue(q->qdisc);
@@ -261,7 +261,7 @@ static struct sk_buff *tbf_dequeue(struc
 
 static void tbf_reset(struct Qdisc* sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 
 	qdisc_reset(q->qdisc);
 	sch->q.qlen = 0;
@@ -300,7 +300,7 @@ static struct Qdisc *tbf_create_dflt_qdi
 static int tbf_change(struct Qdisc* sch, struct rtattr *opt)
 {
 	int err = -EINVAL;
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	struct rtattr *tb[TCA_TBF_PTAB];
 	struct tc_tbf_qopt *qopt;
 	struct qdisc_rate_table *rtab = NULL;
@@ -366,7 +366,7 @@ done:
 
 static int tbf_init(struct Qdisc* sch, struct rtattr *opt)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 
 	if (opt == NULL)
 		return -EINVAL;
@@ -383,7 +383,7 @@ static int tbf_init(struct Qdisc* sch, s
 
 static void tbf_destroy(struct Qdisc *sch)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 
 	del_timer(&q->wd_timer);
 
@@ -393,12 +393,11 @@ static void tbf_destroy(struct Qdisc *sc
 		qdisc_put_rtab(q->R_tab);
 
 	qdisc_destroy(q->qdisc);
-	q->qdisc = &noop_qdisc;
 }
 
 static int tbf_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	unsigned char	 *b = skb->tail;
 	struct rtattr *rta;
 	struct tc_tbf_qopt opt;
@@ -427,7 +426,7 @@ rtattr_failure:
 static int tbf_dump_class(struct Qdisc *sch, unsigned long cl,
 			  struct sk_buff *skb, struct tcmsg *tcm)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data*)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 
 	if (cl != 1) 	/* only one class */
 		return -ENOENT;
@@ -441,7 +440,7 @@ static int tbf_dump_class(struct Qdisc *
 static int tbf_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
 		     struct Qdisc **old)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 
 	if (new == NULL)
 		new = &noop_qdisc;
@@ -457,7 +456,7 @@ static int tbf_graft(struct Qdisc *sch, 
 
 static struct Qdisc *tbf_leaf(struct Qdisc *sch, unsigned long arg)
 {
-	struct tbf_sched_data *q = (struct tbf_sched_data *)sch->data;
+	struct tbf_sched_data *q = qdisc_priv(sch);
 	return q->qdisc;
 }
 
diff -p -purN linux-2.6.8-rc3-bk2/net/sched/sch_teql.c linux-2.6.8-rc3-bk3/net/sched/sch_teql.c
--- linux-2.6.8-rc3-bk2/net/sched/sch_teql.c	2004-06-16 05:19:01.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sched/sch_teql.c	2004-08-08 17:25:04.040094544 +0000
@@ -81,7 +81,7 @@ struct teql_sched_data
 	struct sk_buff_head q;
 };
 
-#define NEXT_SLAVE(q) (((struct teql_sched_data*)((q)->data))->next)
+#define NEXT_SLAVE(q) (((struct teql_sched_data*)qdisc_priv(q))->next)
 
 #define FMASK (IFF_BROADCAST|IFF_POINTOPOINT|IFF_BROADCAST)
 
@@ -91,7 +91,7 @@ static int
 teql_enqueue(struct sk_buff *skb, struct Qdisc* sch)
 {
 	struct net_device *dev = sch->dev;
-	struct teql_sched_data *q = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *q = qdisc_priv(sch);
 
 	__skb_queue_tail(&q->q, skb);
 	if (q->q.qlen <= dev->tx_queue_len) {
@@ -109,7 +109,7 @@ teql_enqueue(struct sk_buff *skb, struct
 static int
 teql_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct teql_sched_data *q = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *q = qdisc_priv(sch);
 
 	__skb_queue_head(&q->q, skb);
 	return 0;
@@ -118,7 +118,7 @@ teql_requeue(struct sk_buff *skb, struct
 static struct sk_buff *
 teql_dequeue(struct Qdisc* sch)
 {
-	struct teql_sched_data *dat = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *dat = qdisc_priv(sch);
 	struct sk_buff *skb;
 
 	skb = __skb_dequeue(&dat->q);
@@ -143,7 +143,7 @@ teql_neigh_release(struct neighbour *n)
 static void
 teql_reset(struct Qdisc* sch)
 {
-	struct teql_sched_data *dat = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *dat = qdisc_priv(sch);
 
 	skb_queue_purge(&dat->q);
 	sch->q.qlen = 0;
@@ -154,7 +154,7 @@ static void
 teql_destroy(struct Qdisc* sch)
 {
 	struct Qdisc *q, *prev;
-	struct teql_sched_data *dat = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *dat = qdisc_priv(sch);
 	struct teql_master *master = dat->m;
 
 	if ((prev = master->slaves) != NULL) {
@@ -184,7 +184,7 @@ static int teql_qdisc_init(struct Qdisc 
 {
 	struct net_device *dev = sch->dev;
 	struct teql_master *m = (struct teql_master*)sch->ops;
-	struct teql_sched_data *q = (struct teql_sched_data *)sch->data;
+	struct teql_sched_data *q = qdisc_priv(sch);
 
 	if (dev->hard_header_len > m->dev->hard_header_len)
 		return -EINVAL;
@@ -229,7 +229,7 @@ static int teql_qdisc_init(struct Qdisc 
 static int
 __teql_resolve(struct sk_buff *skb, struct sk_buff *skb_res, struct net_device *dev)
 {
-	struct teql_sched_data *q = (void*)dev->qdisc->data;
+	struct teql_sched_data *q = qdisc_priv(dev->qdisc);
 	struct neighbour *mn = skb->dst->neighbour;
 	struct neighbour *n = q->ncache;
 
diff -p -purN linux-2.6.8-rc3-bk2/net/socket.c linux-2.6.8-rc3-bk3/net/socket.c
--- linux-2.6.8-rc3-bk2/net/socket.c	2004-08-08 17:21:41.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/socket.c	2004-08-08 17:25:04.044093936 +0000
@@ -401,7 +401,7 @@ int sock_map_fd(struct socket *sock)
 
 		sock->file = file;
 		file->f_op = SOCK_INODE(sock)->i_fop = &socket_file_ops;
-		file->f_mode = 3;
+		file->f_mode = FMODE_READ | FMODE_WRITE;
 		file->f_flags = O_RDWR;
 		file->f_pos = 0;
 		fd_install(fd, file);
@@ -727,9 +727,6 @@ ssize_t sock_sendpage(struct file *file,
 	struct socket *sock;
 	int flags;
 
-	if (ppos != &file->f_pos)
-		return -ESPIPE;
-
 	sock = SOCKET_I(file->f_dentry->d_inode);
 
 	flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
diff -p -purN linux-2.6.8-rc3-bk2/net/sunrpc/cache.c linux-2.6.8-rc3-bk3/net/sunrpc/cache.c
--- linux-2.6.8-rc3-bk2/net/sunrpc/cache.c	2004-06-16 05:19:36.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sunrpc/cache.c	2004-08-08 17:25:04.048093328 +0000
@@ -582,9 +582,6 @@ cache_read(struct file *filp, char __use
 	struct cache_detail *cd = PDE(filp->f_dentry->d_inode)->data;
 	int err;
 
-	if (ppos != &filp->f_pos)
-		return -ESPIPE;
-
 	if (count == 0)
 		return 0;
 
@@ -662,9 +659,6 @@ cache_write(struct file *filp, const cha
 	int err;
 	struct cache_detail *cd = PDE(filp->f_dentry->d_inode)->data;
 
-	if (ppos != &filp->f_pos)
-		return -ESPIPE;
-
 	if (count == 0)
 		return 0;
 	if (count >= sizeof(write_buf))
@@ -751,6 +745,7 @@ cache_open(struct inode *inode, struct f
 {
 	struct cache_reader *rp = NULL;
 
+	nonseekable_open(inode, filp);
 	if (filp->f_mode & FMODE_READ) {
 		struct cache_detail *cd = PDE(inode)->data;
 
@@ -1212,6 +1207,7 @@ static ssize_t write_flush(struct file *
 }
 
 static struct file_operations cache_flush_operations = {
+	.open		= nonseekable_open,
 	.read		= read_flush,
 	.write		= write_flush,
 };
diff -p -purN linux-2.6.8-rc3-bk2/net/sunrpc/sysctl.c linux-2.6.8-rc3-bk3/net/sunrpc/sysctl.c
--- linux-2.6.8-rc3-bk2/net/sunrpc/sysctl.c	2004-06-16 05:18:57.000000000 +0000
+++ linux-2.6.8-rc3-bk3/net/sunrpc/sysctl.c	2004-08-08 17:25:04.050093024 +0000
@@ -58,14 +58,14 @@ rpc_unregister_sysctl(void)
 
 static int
 proc_dodebug(ctl_table *table, int write, struct file *file,
-				void __user *buffer, size_t *lenp)
+				void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	char		tmpbuf[20], c, *s;
 	char __user *p;
 	unsigned int	value;
 	size_t		left, len;
 
-	if ((file->f_pos && !write) || !*lenp) {
+	if ((*ppos && !write) || !*lenp) {
 		*lenp = 0;
 		return 0;
 	}
@@ -115,7 +115,7 @@ proc_dodebug(ctl_table *table, int write
 
 done:
 	*lenp -= left;
-	file->f_pos += *lenp;
+	*ppos += *lenp;
 	return 0;
 }
 

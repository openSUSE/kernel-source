diff -purN linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/entry.S linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/entry.S
--- linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/entry.S	2004-01-19 06:28:26.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/entry.S	2004-03-10 12:13:08.000000000 +0000
@@ -570,11 +570,10 @@ _GLOBAL(enter_prom)
 	 * of all registers that it saves.  We therefore save those registers
 	 * PROM might touch to the stack.  (r0, r3-r13 are caller saved)
    	 */
-	SAVE_8GPRS(2, r1)		/* Save the TOC & incoming param(s) */
-	SAVE_GPR(13, r1)		/* Save paca */
-	SAVE_8GPRS(14, r1)		/* Save the non-volatiles */
-	SAVE_10GPRS(22, r1)		/* ditto */
-
+	SAVE_8GPRS(2, r1)
+	SAVE_GPR(13, r1)
+	SAVE_8GPRS(14, r1)
+	SAVE_10GPRS(22, r1)
 	mfcr	r4
 	std	r4,_CCR(r1)
 	mfctr	r5
@@ -592,20 +591,16 @@ _GLOBAL(enter_prom)
 	mfmsr	r11
 	std	r11,_MSR(r1)
 
-	/* Unfortunatly, the stack pointer is also clobbered, so it is saved
-	 * in the SPRG2 which allows us to restore our original state after
-	 * PROM returns.
-         */
-	mtspr	SPRG2,r1
-
-        /* put a relocation offset into r3 */
+	/* Get the PROM entrypoint */
         bl      .reloc_offset
 	LOADADDR(r12,prom)
 	sub	r12,r12,r3
-	ld	r12,PROMENTRY(r12)	/* get the prom->entry value */
+	ld	r12,PROMENTRY(r12)
 	mtlr	r12
 
-        mfmsr   r11			/* grab the current MSR */
+	/* Switch MSR to 32 bits mode
+	 */
+        mfmsr   r11
         li      r12,1
         rldicr  r12,r12,MSR_SF_LG,(63-MSR_SF_LG)
         andc    r11,r11,r12
@@ -615,22 +610,25 @@ _GLOBAL(enter_prom)
         mtmsrd  r11
         isync
 
-	REST_8GPRS(2, r1)		/* Restore the TOC & param(s) */
-	REST_GPR(13, r1)		/* Restore paca */
-	REST_8GPRS(14, r1)		/* Restore the non-volatiles */
-	REST_10GPRS(22, r1)		/* ditto */
-	blrl				/* Entering PROM here... */
-
-	mfspr	r1,SPRG2		/* Restore the stack pointer */
-	ld	r6,_MSR(r1)		/* Restore the MSR */
-	mtmsrd	r6
+	/* Restore arguments & enter PROM here... */
+	ld	r3,GPR3(r1)
+	blrl
+
+	/* Just make sure that r1 top 32 bits didn't get
+	 * corrupt by OF
+	 */
+	rldicl	r1,r1,0,32
+
+	/* Restore the MSR (back to 64 bits) */
+	ld	r0,_MSR(r1)
+	mtmsrd	r0
         isync
 
-	REST_GPR(2, r1)			/* Restore the TOC */
-	REST_GPR(13, r1)		/* Restore paca */
-	REST_8GPRS(14, r1)		/* Restore the non-volatiles */
-	REST_10GPRS(22, r1)		/* ditto */
-
+	/* Restore other registers */
+	REST_GPR(2, r1)
+	REST_GPR(13, r1)
+	REST_8GPRS(14, r1)
+	REST_10GPRS(22, r1)
 	ld	r4,_CCR(r1)
 	mtcr	r4
 	ld	r5,_CTR(r1)
@@ -645,9 +643,10 @@ _GLOBAL(enter_prom)
 	mtsrr0	r9
 	ld	r10,_SRR1(r1)
 	mtsrr1	r10
+	
         addi	r1,r1,PROM_FRAME_SIZE
-	ld	r0,16(r1)		/* get return address */
-
+	ld	r0,16(r1)
 	mtlr    r0
-        blr				/* return to caller */
+        blr
+	
 #endif	/* defined(CONFIG_PPC_PSERIES) */
diff -purN linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/pmac_pci.c linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/pmac_pci.c
--- linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/pmac_pci.c	2004-02-27 22:44:57.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/pmac_pci.c	2004-03-09 20:20:53.000000000 +0000
@@ -719,6 +719,17 @@ void __init pmac_pci_init(void)
 	/* Setup the linkage between OF nodes and PHBs */ 
 	pci_devs_phb_init();
 
+	/* Fixup the PCI<->OF mapping for U3 AGP due to bus renumbering. We
+	 * assume there is no P2P bridge on the AGP bus, which should be a
+	 * safe assumptions hopefully.
+	 */
+	if (u3_agp) {
+		struct device_node *np = u3_agp->arch_data;
+		np->busno = 0xf0;
+		for (np = np->child; np; np = np->sibling)
+			np->busno = 0xf0;
+	}
+
 	pmac_check_ht_link();
 
 	/* Tell pci.c to use the common resource allocation mecanism */
diff -purN linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/prom.c linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/prom.c
--- linux-post-2.6.4rc2-20040309/arch/ppc64/kernel/prom.c	2004-02-28 08:27:02.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/arch/ppc64/kernel/prom.c	2004-03-09 20:54:04.000000000 +0000
@@ -130,6 +130,7 @@ static interpret_func interpret_macio_pr
 struct prom_t prom;
 
 char *prom_display_paths[FB_MAX] __initdata = { 0, };
+phandle prom_display_nodes[FB_MAX] __initdata;
 unsigned int prom_num_displays = 0;
 char *of_stdout_device = 0;
 
@@ -177,7 +178,7 @@ void prom_dump_lmb(void);
 
 extern unsigned long reloc_offset(void);
 
-extern void enter_prom(void *dummy,...);
+extern void enter_prom(struct prom_args *args);
 extern void copy_and_flush(unsigned long dest, unsigned long src,
 			   unsigned long size, unsigned long offset);
 
@@ -1500,13 +1501,12 @@ prom_init(unsigned long r3, unsigned lon
 	/* Default machine type. */
 	_systemcfg->platform = prom_find_machine_type();
 
-
 	/* On pSeries, copy the CPU hold code */
 	if (_systemcfg->platform == PLATFORM_PSERIES)
 		copy_and_flush(0, KERNELBASE - offset, 0x100, 0);
 
 	/* Start storing things at klimit */
-	mem = RELOC(klimit) - offset; 
+      	mem = RELOC(klimit) - offset; 
 
 	/* Get the full OF pathname of the stdout device */
 	p = (char *) mem;
@@ -1646,10 +1646,10 @@ check_display(unsigned long mem)
 {
 	phandle node;
 	ihandle ih;
-	int i;
+	int i, j;
 	unsigned long offset = reloc_offset();
         struct prom_t *_prom = PTRRELOC(&prom);
-	char type[64], *path;
+	char type[16], *path;
 	static unsigned char default_colors[] = {
 		0x00, 0x00, 0x00,
 		0x00, 0x00, 0xaa,
@@ -1672,6 +1672,12 @@ check_display(unsigned long mem)
 
 	_prom->disp_node = 0;
 
+	prom_print(RELOC("Looking for displays\n"));
+	if (RELOC(of_stdout_device) != 0) {
+		prom_print(RELOC("OF stdout is   : "));
+		prom_print(PTRRELOC(RELOC(of_stdout_device)));
+		prom_print(RELOC("\n"));
+	}
 	for (node = 0; prom_next_node(&node); ) {
 		type[0] = 0;
 		call_prom(RELOC("getprop"), 4, 1, node, RELOC("device_type"),
@@ -1682,19 +1688,48 @@ check_display(unsigned long mem)
 		path = (char *) mem;
 		memset(path, 0, 256);
 		if ((long) call_prom(RELOC("package-to-path"), 3, 1,
-				    node, path, 255) < 0)
+				    node, path, 250) < 0)
 			continue;
-		prom_print(RELOC("opening display "));
+		prom_print(RELOC("found display   : "));
+		prom_print(path);
+		prom_print(RELOC("\n"));
+		
+		/*
+		 * If this display is the device that OF is using for stdout,
+		 * move it to the front of the list.
+		 */
+		mem += strlen(path) + 1;
+		i = RELOC(prom_num_displays);
+		RELOC(prom_num_displays) = i + 1;
+		if (RELOC(of_stdout_device) != 0 && i > 0
+		    && strcmp(PTRRELOC(RELOC(of_stdout_device)), path) == 0) {
+			for (; i > 0; --i) {
+				RELOC(prom_display_paths[i])
+					= RELOC(prom_display_paths[i-1]);
+				RELOC(prom_display_nodes[i])
+					= RELOC(prom_display_nodes[i-1]);
+			}
+			_prom->disp_node = (ihandle)(unsigned long)node;
+		}
+		RELOC(prom_display_paths[i]) = PTRUNRELOC(path);
+		RELOC(prom_display_nodes[i]) = node;
+		if (_prom->disp_node == 0)
+			_prom->disp_node = (ihandle)(unsigned long)node;
+		if (RELOC(prom_num_displays) >= FB_MAX)
+			break;
+	}
+	prom_print(RELOC("Opening displays...\n"));
+	for (j = RELOC(prom_num_displays) - 1; j >= 0; j--) {
+		path = PTRRELOC(RELOC(prom_display_paths[j]));
+		prom_print(RELOC("opening display : "));
 		prom_print(path);
 		ih = (ihandle)call_prom(RELOC("open"), 1, 1, path);
 		if (ih == (ihandle)0 || ih == (ihandle)-1) {
 			prom_print(RELOC("... failed\n"));
 			continue;
 		}
-		prom_print(RELOC("... ok\n"));
 
-		if (_prom->disp_node == 0)
-			_prom->disp_node = (ihandle)(unsigned long)node;
+		prom_print(RELOC("... ok\n"));
 
 		/* Setup a useable color table when the appropriate
 		 * method is available. Should update this to set-colors */
@@ -1711,26 +1746,8 @@ check_display(unsigned long mem)
 					   clut[2]) != 0)
 				break;
 #endif /* CONFIG_LOGO_LINUX_CLUT224 */
-
-		/*
-		 * If this display is the device that OF is using for stdout,
-		 * move it to the front of the list.
-		 */
-		mem += strlen(path) + 1;
-		i = RELOC(prom_num_displays)++;
-		if (RELOC(of_stdout_device) != 0 && i > 0
-		    && strcmp(PTRRELOC(RELOC(of_stdout_device)), path) == 0) {
-			for (; i > 0; --i)
-				RELOC(prom_display_paths[i]) = RELOC(prom_display_paths[i-1]);
-		}
-		RELOC(prom_display_paths[i]) = PTRUNRELOC(path);
-		if (RELOC(prom_num_displays) >= FB_MAX)
-			break;
-		/* XXX Temporary workaround: only open the first display so we don't
-		 * lose debug output
-		 */
-		break;
 	}
+	
 	return DOUBLEWORD_ALIGN(mem);
 }
 
diff -purN linux-post-2.6.4rc2-20040309/drivers/char/drm/r128_state.c linux-post-2.6.4rc3-20040310/drivers/char/drm/r128_state.c
--- linux-post-2.6.4rc2-20040309/drivers/char/drm/r128_state.c	2003-08-02 02:51:32.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/drivers/char/drm/r128_state.c	2004-03-09 16:13:42.000000000 +0000
@@ -915,6 +915,9 @@ static int r128_cce_dispatch_write_span(
 	DRM_DEBUG( "\n" );
 
 	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
 	if ( DRM_COPY_FROM_USER( &x, depth->x, sizeof(x) ) ) {
 		return DRM_ERR(EFAULT);
 	}
@@ -1008,6 +1011,8 @@ static int r128_cce_dispatch_write_pixel
 	DRM_DEBUG( "\n" );
 
 	count = depth->n;
+	if (count > 4096  || count <= 0)
+		return -EMSGSIZE;
 
 	xbuf_size = count * sizeof(*x);
 	ybuf_size = count * sizeof(*y);
@@ -1125,6 +1130,9 @@ static int r128_cce_dispatch_read_span( 
 	DRM_DEBUG( "\n" );
 
 	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
 	if ( DRM_COPY_FROM_USER( &x, depth->x, sizeof(x) ) ) {
 		return DRM_ERR(EFAULT);
 	}
@@ -1167,6 +1175,9 @@ static int r128_cce_dispatch_read_pixels
 	DRM_DEBUG( "%s\n", __FUNCTION__ );
 
 	count = depth->n;
+	if (count > 4096 || count <= 0)
+		return -EMSGSIZE;
+
 	if ( count > dev_priv->depth_pitch ) {
 		count = dev_priv->depth_pitch;
 	}
diff -purN linux-post-2.6.4rc2-20040309/drivers/serial/pmac_zilog.c linux-post-2.6.4rc3-20040310/drivers/serial/pmac_zilog.c
--- linux-post-2.6.4rc2-20040309/drivers/serial/pmac_zilog.c	2004-02-12 15:24:56.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/drivers/serial/pmac_zilog.c	2004-03-10 10:18:32.000000000 +0000
@@ -31,10 +31,11 @@
  *
  * TODO:   - Add DMA support
  *         - Defer port shutdown to a few seconds after close
- *         - maybe put something right into up->clk_divisor
+ *         - maybe put something right into uap->clk_divisor
  */
 
 #undef DEBUG
+#undef DEBUG_HARD
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -61,21 +62,17 @@
 #include <asm/pmac_feature.h>
 #include <asm/dbdma.h>
 #include <asm/macio.h>
+#include <asm/semaphore.h>
 
 #include <linux/serial.h>
 #include <linux/serial_core.h>
 
 #include "pmac_zilog.h"
 
-#if defined(CONFIG_SERIAL_PMACZILOG_CONSOLE) && defined(CONFIG_PPC64)
-#define HAS_SCCDBG
-extern int sccdbg;
-#endif
-
 /* Not yet implemented */
 #undef HAS_DBDMA
 
-static char version[] __initdata = "pmac_zilog.c 0.5a (Benjamin Herrenschmidt <benh@kernel.crashing.org>)";
+static char version[] __initdata = "pmac_zilog: 0.6 (Benjamin Herrenschmidt <benh@kernel.crashing.org>)";
 MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
 MODULE_DESCRIPTION("Driver for the PowerMac serial ports.");
 MODULE_LICENSE("GPL");
@@ -89,6 +86,15 @@ MODULE_LICENSE("GPL");
  */
 static struct uart_pmac_port	pmz_ports[MAX_ZS_PORTS];
 static int			pmz_ports_count;
+static DECLARE_MUTEX(pmz_irq_sem);
+
+static struct uart_driver pmz_uart_reg = {
+	.owner		=	THIS_MODULE,
+	.driver_name	=	"ttyS",
+	.devfs_name	=	"tts/",
+	.dev_name	=	"ttyS",
+	.major		=	TTY_MAJOR,
+};
 
 
 /* 
@@ -96,71 +102,78 @@ static int			pmz_ports_count;
  * This function must only be called when the TX is not busy.  The UART
  * port lock must be held and local interrupts disabled.
  */
-static void pmz_load_zsregs(struct uart_pmac_port *up, u8 *regs)
+static void pmz_load_zsregs(struct uart_pmac_port *uap, u8 *regs)
 {
 	int i;
 
+	if (ZS_IS_ASLEEP(uap))
+		return;
+
 	/* Let pending transmits finish.  */
 	for (i = 0; i < 1000; i++) {
-		unsigned char stat = read_zsreg(up, R1);
+		unsigned char stat = read_zsreg(uap, R1);
 		if (stat & ALL_SNT)
 			break;
 		udelay(100);
 	}
 
-	ZS_CLEARERR(up);
-	zssync(up);
-	ZS_CLEARFIFO(up);
-	zssync(up);
-	ZS_CLEARERR(up);
+	ZS_CLEARERR(uap);
+	zssync(uap);
+	ZS_CLEARFIFO(uap);
+	zssync(uap);
+	ZS_CLEARERR(uap);
 
 	/* Disable all interrupts.  */
-	write_zsreg(up, R1,
+	write_zsreg(uap, R1,
 		    regs[R1] & ~(RxINT_MASK | TxINT_ENAB | EXT_INT_ENAB));
 
 	/* Set parity, sync config, stop bits, and clock divisor.  */
-	write_zsreg(up, R4, regs[R4]);
+	write_zsreg(uap, R4, regs[R4]);
 
 	/* Set misc. TX/RX control bits.  */
-	write_zsreg(up, R10, regs[R10]);
+	write_zsreg(uap, R10, regs[R10]);
 
 	/* Set TX/RX controls sans the enable bits.  */
-	write_zsreg(up, R3, regs[R3] & ~RxENABLE);
-	write_zsreg(up, R5, regs[R5] & ~TxENABLE);
+       	write_zsreg(uap, R3, regs[R3] & ~RxENABLE);
+       	write_zsreg(uap, R5, regs[R5] & ~TxENABLE);
+
+	/* now set R7 "prime" on ESCC */
+	write_zsreg(uap, R15, regs[R15] | EN85C30);
+	write_zsreg(uap, R7, regs[R7P]);
+
+	/* make sure we use R7 "non-prime" on ESCC */
+	write_zsreg(uap, R15, regs[R15] & ~EN85C30);
 
 	/* Synchronous mode config.  */
-	write_zsreg(up, R6, regs[R6]);
-	write_zsreg(up, R7, regs[R7]);
+	write_zsreg(uap, R6, regs[R6]);
+	write_zsreg(uap, R7, regs[R7]);
 
 	/* Disable baud generator.  */
-	write_zsreg(up, R14, regs[R14] & ~BRENAB);
+	write_zsreg(uap, R14, regs[R14] & ~BRENAB);
 
 	/* Clock mode control.  */
-	write_zsreg(up, R11, regs[R11]);
+	write_zsreg(uap, R11, regs[R11]);
 
 	/* Lower and upper byte of baud rate generator divisor.  */
-	write_zsreg(up, R12, regs[R12]);
-	write_zsreg(up, R13, regs[R13]);
+	write_zsreg(uap, R12, regs[R12]);
+	write_zsreg(uap, R13, regs[R13]);
 	
 	/* Now rewrite R14, with BRENAB (if set).  */
-	write_zsreg(up, R14, regs[R14]);
-
-	/* External status interrupt control.  */
-	write_zsreg(up, R15, regs[R15]);
+	write_zsreg(uap, R14, regs[R14]);
 
 	/* Reset external status interrupts.  */
-	write_zsreg(up, R0, RES_EXT_INT);
-	write_zsreg(up, R0, RES_EXT_INT);
+	write_zsreg(uap, R0, RES_EXT_INT);
+	write_zsreg(uap, R0, RES_EXT_INT);
 
 	/* Rewrite R3/R5, this time without enables masked.  */
-	write_zsreg(up, R3, regs[R3]);
-	write_zsreg(up, R5, regs[R5]);
+	write_zsreg(uap, R3, regs[R3]);
+	write_zsreg(uap, R5, regs[R5]);
 
 	/* Rewrite R1, this time without IRQ enabled masked.  */
-	write_zsreg(up, R1, regs[R1]);
+	write_zsreg(uap, R1, regs[R1]);
 
 	/* Enable interrupts */
-	write_zsreg(up, R9, regs[R9]);
+	write_zsreg(uap, R9, regs[R9]);
 }
 
 /* 
@@ -171,63 +184,110 @@ static void pmz_load_zsregs(struct uart_
  *
  * The UART port lock must be held and local interrupts disabled.
  */
-static void pmz_maybe_update_regs(struct uart_pmac_port *up)
+static void pmz_maybe_update_regs(struct uart_pmac_port *uap)
 {
-       	if (!ZS_REGS_HELD(up)) {
-		if (ZS_TX_ACTIVE(up)) {
-			up->flags |= PMACZILOG_FLAG_REGS_HELD;
+       	if (!ZS_REGS_HELD(uap)) {
+		if (ZS_TX_ACTIVE(uap)) {
+			uap->flags |= PMACZILOG_FLAG_REGS_HELD;
 		} else {
-			pr_debug("pmz: maybe_update_regs: updating\n");
-			pmz_load_zsregs(up, up->curregs);
+			pmz_debug("pmz: maybe_update_regs: updating\n");
+			pmz_load_zsregs(uap, uap->curregs);
 		}
 	}
 }
 
-static void pmz_receive_chars(struct uart_pmac_port *up, struct pt_regs *regs)
+static struct tty_struct *pmz_receive_chars(struct uart_pmac_port *uap,
+					    struct pt_regs *regs)
 {
-	struct tty_struct *tty = up->port.info->tty;	/* XXX info==NULL? */
+	struct tty_struct *tty = NULL;
+	unsigned char ch, r1, drop, error;
+	int loops = 0;
+
+ retry:
+	/* The interrupt can be enabled when the port isn't open, typically
+	 * that happens when using one port is open and the other closed (stale
+	 * interrupt) or when one port is used as a console.
+	 */
+	if (!ZS_IS_OPEN(uap)) {
+		pmz_debug("pmz: draining input\n");
+		/* Port is closed, drain input data */
+		for (;;) {
+			if ((++loops) > 1000)
+				goto flood;
+			(void)read_zsreg(uap, R1);
+			write_zsreg(uap, R0, ERR_RES);
+			(void)read_zsdata(uap);
+			ch = read_zsreg(uap, R0);
+			if (!(ch & Rx_CH_AV))
+				break;
+		}
+		return NULL;
+	}
+
+	/* Sanity check, make sure the old bug is no longer happening */
+	if (uap->port.info == NULL || uap->port.info->tty == NULL) {
+		WARN_ON(1);
+		(void)read_zsdata(uap);
+		return NULL;
+	}
+	tty = uap->port.info->tty;
 
 	while (1) {
-		unsigned char ch, r1;
+		error = 0;
+		drop = 0;
 
 		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
+			/* Have to drop the lock here */
+			pmz_debug("pmz: flip overflow\n");
+			spin_unlock(&uap->port.lock);
 			tty->flip.work.func((void *)tty);
+			spin_lock(&uap->port.lock);
 			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-				/* XXX Ignores SysRq when we need it most. Fix. */
-				return;	
+				drop = 1;
+			if (ZS_IS_ASLEEP(uap))
+				return 0;
+			if (!ZS_IS_OPEN(uap))
+				goto retry;
 		}
 
-		r1 = read_zsreg(up, R1);
+		r1 = read_zsreg(uap, R1);
+		ch = read_zsdata(uap);
+
 		if (r1 & (PAR_ERR | Rx_OVR | CRC_ERR)) {
-			write_zsreg(up, R0, ERR_RES);
-			zssync(up);
+			write_zsreg(uap, R0, ERR_RES);
+			zssync(uap);
 		}
 
-		ch = read_zsdata(up);
-		ch &= up->parity_mask;
-		if (ch == 0 && up->prev_status & BRK_ABRT) {
+		ch &= uap->parity_mask;
+		if (ch == 0 && uap->prev_status & BRK_ABRT)
 			r1 |= BRK_ABRT;
-			printk("rx break\n");
-		}
 
 		/* A real serial line, record the character and status.  */
+		if (drop)
+			goto next_char;
+
 		*tty->flip.char_buf_ptr = ch;
 		*tty->flip.flag_buf_ptr = TTY_NORMAL;
-		up->port.icount.rx++;
+		uap->port.icount.rx++;
+
 		if (r1 & (PAR_ERR | Rx_OVR | CRC_ERR | BRK_ABRT)) {
+			error = 1;
 			if (r1 & BRK_ABRT) {
+				pmz_debug("pmz: got break !\n");
 				r1 &= ~(PAR_ERR | CRC_ERR);
-				up->port.icount.brk++;
-				if (uart_handle_break(&up->port))
+				uap->port.icount.brk++;
+				if (uart_handle_break(&uap->port)) {
+					pmz_debug("pmz: do handle break !\n");
 					goto next_char;
+				}
 			}
 			else if (r1 & PAR_ERR)
-				up->port.icount.parity++;
+				uap->port.icount.parity++;
 			else if (r1 & CRC_ERR)
-				up->port.icount.frame++;
+				uap->port.icount.frame++;
 			if (r1 & Rx_OVR)
-				up->port.icount.overrun++;
-			r1 &= up->port.read_status_mask;
+				uap->port.icount.overrun++;
+			r1 &= uap->port.read_status_mask;
 			if (r1 & BRK_ABRT)
 				*tty->flip.flag_buf_ptr = TTY_BREAK;
 			else if (r1 & PAR_ERR)
@@ -235,11 +295,13 @@ static void pmz_receive_chars(struct uar
 			else if (r1 & CRC_ERR)
 				*tty->flip.flag_buf_ptr = TTY_FRAME;
 		}
-		if (uart_handle_sysrq_char(&up->port, ch, regs))
+		if (uart_handle_sysrq_char(&uap->port, ch, regs)) {
+			pmz_debug("pmz: sysrq swallowed the char\n");
 			goto next_char;
+		}
 
-		if (up->port.ignore_status_mask == 0xff ||
-		    (r1 & up->port.ignore_status_mask) == 0) {
+		if (uap->port.ignore_status_mask == 0xff ||
+		    (r1 & uap->port.ignore_status_mask) == 0) {
 			tty->flip.flag_buf_ptr++;
 			tty->flip.char_buf_ptr++;
 			tty->flip.count++;
@@ -252,58 +314,66 @@ static void pmz_receive_chars(struct uar
 			tty->flip.count++;
 		}
 	next_char:
-		ch = read_zsreg(up, R0);
+		/* We can get stuck in an infinite loop getting char 0 when the
+		 * line is in a wrong HW state, we break that here.
+		 * When that happens, I disable the receive side of the driver.
+		 * Note that what I've been experiencing is a real irq loop where
+		 * I'm getting flooded regardless of the actual port speed.
+		 * Something stange is going on with the HW
+		 */
+		if ((++loops) > 1000)
+			goto flood;
+		ch = read_zsreg(uap, R0);
 		if (!(ch & Rx_CH_AV))
 			break;
 	}
 
-	tty_flip_buffer_push(tty);
+	return tty;
+ flood:
+	uap->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);
+	write_zsreg(uap, R1, uap->curregs[R1]);
+	zssync(uap);
+	dev_err(&uap->dev->ofdev.dev, "pmz: rx irq flood !\n");
+	return tty;
 }
 
-static void pmz_status_handle(struct uart_pmac_port *up, struct pt_regs *regs)
+static void pmz_status_handle(struct uart_pmac_port *uap, struct pt_regs *regs)
 {
 	unsigned char status;
 
-	status = read_zsreg(up, R0);
-	write_zsreg(up, R0, RES_EXT_INT);
-	zssync(up);
-
-#ifdef HAS_SCCDBG
-	if (sccdbg && (status & BRK_ABRT) && !(up->prev_status & BRK_ABRT)) {
-#ifdef CONFIG_XMON
-		extern void xmon(struct pt_regs *);
-		xmon(regs);
-#endif
-	}
-#endif /* HAS_SCCDBG */
+	status = read_zsreg(uap, R0);
+	write_zsreg(uap, R0, RES_EXT_INT);
+	zssync(uap);
 
-	if (ZS_WANTS_MODEM_STATUS(up)) {
+	if (ZS_IS_OPEN(uap) && ZS_WANTS_MODEM_STATUS(uap)) {
 		if (status & SYNC_HUNT)
-			up->port.icount.dsr++;
+			uap->port.icount.dsr++;
 
 		/* The Zilog just gives us an interrupt when DCD/CTS/etc. change.
 		 * But it does not tell us which bit has changed, we have to keep
 		 * track of this ourselves.
 		 */
-		if ((status & DCD) ^ up->prev_status)
-			uart_handle_dcd_change(&up->port,
+		if ((status & DCD) ^ uap->prev_status)
+			uart_handle_dcd_change(&uap->port,
 					       (status & DCD));
-		if ((status & CTS) ^ up->prev_status)
-			uart_handle_cts_change(&up->port,
+		if ((status & CTS) ^ uap->prev_status)
+			uart_handle_cts_change(&uap->port,
 					       (status & CTS));
 
-		wake_up_interruptible(&up->port.info->delta_msr_wait);
+		wake_up_interruptible(&uap->port.info->delta_msr_wait);
 	}
 
-	up->prev_status = status;
+	uap->prev_status = status;
 }
 
-static void pmz_transmit_chars(struct uart_pmac_port *up)
+static void pmz_transmit_chars(struct uart_pmac_port *uap)
 {
 	struct circ_buf *xmit;
 
-	if (ZS_IS_CONS(up)) {
-		unsigned char status = read_zsreg(up, R0);
+	if (ZS_IS_ASLEEP(uap))
+		return;
+	if (ZS_IS_CONS(uap)) {
+		unsigned char status = read_zsreg(uap, R0);
 
 		/* TX still busy?  Just wait for the next TX done interrupt.
 		 *
@@ -317,115 +387,128 @@ static void pmz_transmit_chars(struct ua
 			return;
 	}
 
-	up->flags &= ~PMACZILOG_FLAG_TX_ACTIVE;
+	uap->flags &= ~PMACZILOG_FLAG_TX_ACTIVE;
 
-	if (ZS_REGS_HELD(up)) {
-		pmz_load_zsregs(up, up->curregs);
-		up->flags &= ~PMACZILOG_FLAG_REGS_HELD;
+	if (ZS_REGS_HELD(uap)) {
+		pmz_load_zsregs(uap, uap->curregs);
+		uap->flags &= ~PMACZILOG_FLAG_REGS_HELD;
 	}
 
-	if (ZS_TX_STOPPED(up)) {
-		up->flags &= ~PMACZILOG_FLAG_TX_STOPPED;
+	if (ZS_TX_STOPPED(uap)) {
+		uap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;
 		goto ack_tx_int;
 	}
 
-	if (up->port.x_char) {
-		up->flags |= PMACZILOG_FLAG_TX_ACTIVE;
-		write_zsdata(up, up->port.x_char);
-		zssync(up);
-		up->port.icount.tx++;
-		up->port.x_char = 0;
+	if (uap->port.x_char) {
+		uap->flags |= PMACZILOG_FLAG_TX_ACTIVE;
+		write_zsdata(uap, uap->port.x_char);
+		zssync(uap);
+		uap->port.icount.tx++;
+		uap->port.x_char = 0;
 		return;
 	}
 
-	if (up->port.info == NULL)
+	if (uap->port.info == NULL)
 		goto ack_tx_int;
-	xmit = &up->port.info->xmit;
+	xmit = &uap->port.info->xmit;
 	if (uart_circ_empty(xmit)) {
-		uart_write_wakeup(&up->port);
+		uart_write_wakeup(&uap->port);
 		goto ack_tx_int;
 	}
-	if (uart_tx_stopped(&up->port))
+	if (uart_tx_stopped(&uap->port))
 		goto ack_tx_int;
 
-	up->flags |= PMACZILOG_FLAG_TX_ACTIVE;
-	write_zsdata(up, xmit->buf[xmit->tail]);
-	zssync(up);
+	uap->flags |= PMACZILOG_FLAG_TX_ACTIVE;
+	write_zsdata(uap, xmit->buf[xmit->tail]);
+	zssync(uap);
 
 	xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-	up->port.icount.tx++;
+	uap->port.icount.tx++;
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&up->port);
+		uart_write_wakeup(&uap->port);
 
 	return;
 
 ack_tx_int:
-	write_zsreg(up, R0, RES_Tx_P);
-	zssync(up);
+	write_zsreg(uap, R0, RES_Tx_P);
+	zssync(uap);
 }
 
 /* Hrm... we register that twice, fixme later.... */
 static irqreturn_t pmz_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	struct uart_pmac_port *up = dev_id;
-	struct uart_pmac_port *up_a;
-	struct uart_pmac_port *up_b;
+	struct uart_pmac_port *uap = dev_id;
+	struct uart_pmac_port *uap_a;
+	struct uart_pmac_port *uap_b;
 	int rc = IRQ_NONE;
+	struct tty_struct *tty;
 	u8 r3;
 
-	up_a = ZS_IS_CHANNEL_A(up) ? up : up->mate;
-	up_b = up_a->mate;
+	uap_a = pmz_get_port_A(uap);
+	uap_b = uap_a->mate;
        
-       	spin_lock(&up_a->port.lock);
-	r3 = read_zsreg(up, R3);
-	pr_debug("pmz_irq: %x\n", r3);
+       	spin_lock(&uap_a->port.lock);
+	r3 = read_zsreg(uap_a, R3);
 
+#ifdef DEBUG_HARD
+	pmz_debug("irq, r3: %x\n", r3);
+#endif
        	/* Channel A */
+	tty = NULL;
        	if (r3 & (CHAEXT | CHATxIP | CHARxIP)) {
-		write_zsreg(up_a, R0, RES_H_IUS);
-		zssync(up_a);		
-		pr_debug("pmz: irq channel A: %x\n", r3);
+		write_zsreg(uap_a, R0, RES_H_IUS);
+		zssync(uap_a);		
        		if (r3 & CHAEXT)
-       			pmz_status_handle(up_a, regs);
+       			pmz_status_handle(uap_a, regs);
 		if (r3 & CHARxIP)
-			pmz_receive_chars(up_a, regs);
+			tty = pmz_receive_chars(uap_a, regs);
        		if (r3 & CHATxIP)
-       			pmz_transmit_chars(up_a);
+       			pmz_transmit_chars(uap_a);
 	        rc = IRQ_HANDLED;
        	}
-       	spin_unlock(&up_a->port.lock);
-	
-       	spin_lock(&up_b->port.lock);
+       	spin_unlock(&uap_a->port.lock);
+	if (tty != NULL)
+		tty_flip_buffer_push(tty);
+
+	if (uap_b->node == NULL)
+		goto out;
+
+       	spin_lock(&uap_b->port.lock);
+	tty = NULL;
 	if (r3 & (CHBEXT | CHBTxIP | CHBRxIP)) {
-		write_zsreg(up_b, R0, RES_H_IUS);
-		zssync(up_b);
-		pr_debug("pmz: irq channel B: %x\n", r3);
+		write_zsreg(uap_b, R0, RES_H_IUS);
+		zssync(uap_b);
        		if (r3 & CHBEXT)
-       			pmz_status_handle(up_b, regs);
+       			pmz_status_handle(uap_b, regs);
        	       	if (r3 & CHBRxIP)
-       			pmz_receive_chars(up_b, regs);
+       			pmz_receive_chars(uap_b, regs);
        		if (r3 & CHBTxIP)
-       			pmz_transmit_chars(up_b);
+       			pmz_transmit_chars(uap_b);
 	       	rc = IRQ_HANDLED;
        	}
-       	spin_unlock(&up_b->port.lock);
-
+       	spin_unlock(&uap_b->port.lock);
+	if (tty != NULL)
+		tty_flip_buffer_push(tty);
 
+ out:
+#ifdef DEBUG_HARD
+	pmz_debug("irq done.\n");
+#endif
 	return rc;
 }
 
 /*
  * Peek the status register, lock not held by caller
  */
-static inline u8 pmz_peek_status(struct uart_pmac_port *up)
+static inline u8 pmz_peek_status(struct uart_pmac_port *uap)
 {
 	unsigned long flags;
 	u8 status;
 	
-	spin_lock_irqsave(&up->port.lock, flags);
-	status = read_zsreg(up, R0);
-	spin_unlock_irqrestore(&up->port.lock, flags);
+	spin_lock_irqsave(&uap->port.lock, flags);
+	status = read_zsreg(uap, R0);
+	spin_unlock_irqrestore(&uap->port.lock, flags);
 
 	return status;
 }
@@ -436,8 +519,12 @@ static inline u8 pmz_peek_status(struct 
  */
 static unsigned int pmz_tx_empty(struct uart_port *port)
 {
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char status;
 
+	if (ZS_IS_ASLEEP(uap) || uap->node == NULL)
+		return TIOCSER_TEMT;
+
 	status = pmz_peek_status(to_pmz(port));
 	if (status & Tx_BUF_EMP)
 		return TIOCSER_TEMT;
@@ -452,16 +539,20 @@ static unsigned int pmz_tx_empty(struct 
  */
 static void pmz_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char set_bits, clear_bits;
 
         /* Do nothing for irda for now... */
-	if (ZS_IS_IRDA(up))
+	if (ZS_IS_IRDA(uap))
+		return;
+	/* We get called during boot with a port not up yet */
+	if (ZS_IS_ASLEEP(uap) ||
+	    !(ZS_IS_OPEN(uap) || ZS_IS_CONS(uap)))
 		return;
 
 	set_bits = clear_bits = 0;
 
-	if (ZS_IS_INTMODEM(up)) {
+	if (ZS_IS_INTMODEM(uap)) {
 		if (mctrl & TIOCM_RTS)
 			set_bits |= RTS;
 		else
@@ -473,10 +564,14 @@ static void pmz_set_mctrl(struct uart_po
 		clear_bits |= DTR;
 
 	/* NOTE: Not subject to 'transmitter active' rule.  */ 
-	up->curregs[R5] |= set_bits;
-	up->curregs[R5] &= ~clear_bits;
-	write_zsreg(up, R5, up->curregs[R5]);
-	zssync(up);
+	uap->curregs[R5] |= set_bits;
+	uap->curregs[R5] &= ~clear_bits;
+	if (ZS_IS_ASLEEP(uap))
+		return;
+	write_zsreg(uap, R5, uap->curregs[R5]);
+	pmz_debug("pmz_set_mctrl: set bits: %x, clear bits: %x -> %x\n",
+		  set_bits, clear_bits, uap->curregs[R5]);
+	zssync(uap);
 }
 
 /* 
@@ -486,9 +581,13 @@ static void pmz_set_mctrl(struct uart_po
  */
 static unsigned int pmz_get_mctrl(struct uart_port *port)
 {
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char status;
 	unsigned int ret;
 
+	if (ZS_IS_ASLEEP(uap) || uap->node == NULL)
+		return 0;
+
 	status = pmz_peek_status(to_pmz(port));
 
 	ret = 0;
@@ -519,15 +618,18 @@ static void pmz_stop_tx(struct uart_port
  */
 static void pmz_start_tx(struct uart_port *port, unsigned int tty_start)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char status;
 
-	pr_debug("pmz: start_tx()\n");
+	pmz_debug("pmz: start_tx()\n");
+
+	uap->flags |= PMACZILOG_FLAG_TX_ACTIVE;
+	uap->flags &= ~PMACZILOG_FLAG_TX_STOPPED;
 
-	up->flags |= PMACZILOG_FLAG_TX_ACTIVE;
-	up->flags &= ~PMACZILOG_FLAG_TX_STOPPED;
+	if (ZS_IS_ASLEEP(uap) || uap->node == NULL)
+		return;
 
-	status = read_zsreg(up, R0);
+	status = read_zsreg(uap, R0);
 
 	/* TX busy?  Just wait for the TX done interrupt.  */
 	if (!(status & Tx_BUF_EMP))
@@ -537,43 +639,44 @@ static void pmz_start_tx(struct uart_por
 	 * IRQ sending engine.
 	 */
 	if (port->x_char) {
-		write_zsdata(up, port->x_char);
-		zssync(up);
+		write_zsdata(uap, port->x_char);
+		zssync(uap);
 		port->icount.tx++;
 		port->x_char = 0;
 	} else {
 		struct circ_buf *xmit = &port->info->xmit;
 
-		write_zsdata(up, xmit->buf[xmit->tail]);
-		zssync(up);
+		write_zsdata(uap, xmit->buf[xmit->tail]);
+		zssync(uap);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		port->icount.tx++;
 
 		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-			uart_write_wakeup(&up->port);
+			uart_write_wakeup(&uap->port);
 	}
-	pr_debug("pmz: start_tx() done.\n");
+	pmz_debug("pmz: start_tx() done.\n");
 }
 
 /* 
  * Stop Rx side, basically disable emitting of
- * Rx interrupts on the port
+ * Rx interrupts on the port. We don't disable the rx
+ * side of the chip proper though
  * The port lock is held.
  */
 static void pmz_stop_rx(struct uart_port *port)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 
-	if (ZS_IS_CONS(up))
+	if (ZS_IS_ASLEEP(uap) || uap->node == NULL)
 		return;
 
-	pr_debug("pmz: stop_rx()()\n");
+	pmz_debug("pmz: stop_rx()()\n");
 
 	/* Disable all RX interrupts.  */
-	up->curregs[R1] &= ~RxINT_MASK;
-	pmz_maybe_update_regs(up);
+	uap->curregs[R1] &= ~RxINT_MASK;
+	pmz_maybe_update_regs(uap);
 
-	pr_debug("pmz: stop_rx() done.\n");
+	pmz_debug("pmz: stop_rx() done.\n");
 }
 
 /* 
@@ -582,15 +685,19 @@ static void pmz_stop_rx(struct uart_port
  */
 static void pmz_enable_ms(struct uart_port *port)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char new_reg;
 
-	new_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);
-	if (new_reg != up->curregs[R15]) {
-		up->curregs[R15] = new_reg;
+	if (ZS_IS_IRDA(uap) || uap->node == NULL)
+		return;
+	new_reg = uap->curregs[R15] | (DCDIE | SYNCIE | CTSIE);
+	if (new_reg != uap->curregs[R15]) {
+		uap->curregs[R15] = new_reg;
 
+		if (ZS_IS_ASLEEP(uap))
+			return;
 		/* NOTE: Not subject to 'transmitter active' rule.  */ 
-		write_zsreg(up, R15, up->curregs[R15]);
+		write_zsreg(uap, R15, uap->curregs[R15]);
 	}
 }
 
@@ -600,10 +707,12 @@ static void pmz_enable_ms(struct uart_po
  */
 static void pmz_break_ctl(struct uart_port *port, int break_state)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned char set_bits, clear_bits, new_reg;
 	unsigned long flags;
 
+	if (uap->node == NULL)
+		return;
 	set_bits = clear_bits = 0;
 
 	if (break_state)
@@ -613,12 +722,14 @@ static void pmz_break_ctl(struct uart_po
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	new_reg = (up->curregs[R5] | set_bits) & ~clear_bits;
-	if (new_reg != up->curregs[R5]) {
-		up->curregs[R5] = new_reg;
+	new_reg = (uap->curregs[R5] | set_bits) & ~clear_bits;
+	if (new_reg != uap->curregs[R5]) {
+		uap->curregs[R5] = new_reg;
 
 		/* NOTE: Not subject to 'transmitter active' rule.  */ 
-		write_zsreg(up, R5, up->curregs[R5]);
+		if (ZS_IS_ASLEEP(uap))
+			return;
+		write_zsreg(uap, R5, uap->curregs[R5]);
 	}
 
 	spin_unlock_irqrestore(&port->lock, flags);
@@ -630,38 +741,38 @@ static void pmz_break_ctl(struct uart_po
  * Returns the number of milliseconds we should wait before
  * trying to use the port.
  */
-static int pmz_set_scc_power(struct uart_pmac_port *up, int state)
+static int pmz_set_scc_power(struct uart_pmac_port *uap, int state)
 {
 	int delay = 0;
+	int rc;
 
 	if (state) {
-		pmac_call_feature(
-			PMAC_FTR_SCC_ENABLE, up->node, up->port_type, 1);
-		if (ZS_IS_INTMODEM(up)) {
-			pmac_call_feature(
-				PMAC_FTR_MODEM_ENABLE, up->node, 0, 1);
+		rc = pmac_call_feature(
+			PMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 1);
+		pmz_debug("port power on result: %d\n", rc);
+		if (ZS_IS_INTMODEM(uap)) {
+			rc = pmac_call_feature(
+				PMAC_FTR_MODEM_ENABLE, uap->node, 0, 1);
 			delay = 2500;	/* wait for 2.5s before using */
-		} else if (ZS_IS_IRDA(up))
-			mdelay(50);	/* Do better here once the problems
-			                 * with blocking have been ironed out
-			                 */
+			pmz_debug("modem power result: %d\n", rc);
+		}
 	} else {
 		/* TODO: Make that depend on a timer, don't power down
 		 * immediately
 		 */
-		if (ZS_IS_INTMODEM(up)) {
-			pmac_call_feature(
-				PMAC_FTR_MODEM_ENABLE, up->node, 0, 0);
+		if (ZS_IS_INTMODEM(uap)) {
+			rc = pmac_call_feature(
+				PMAC_FTR_MODEM_ENABLE, uap->node, 0, 0);
+			pmz_debug("port power off result: %d\n", rc);
 		}
-		pmac_call_feature(
-			PMAC_FTR_SCC_ENABLE, up->node, up->port_type, 0);
+		pmac_call_feature(PMAC_FTR_SCC_ENABLE, uap->node, uap->port_type, 0);
 	}
 	return delay;
 }
 
 /*
  * FixZeroBug....Works around a bug in the SCC receving channel.
- * Taken from Darwin code, 15 Sept. 2000  -DanM
+ * Inspired from Darwin code, 15 Sept. 2000  -DanM
  *
  * The following sequence prevents a problem that is seen with O'Hare ASICs
  * (most versions -- also with some Heathrow and Hydra ASICs) where a zero
@@ -679,44 +790,41 @@ static int pmz_set_scc_power(struct uart
  * the SCC in synchronous loopback mode with a fast clock before programming
  * any of the asynchronous modes.
  */
-static void pmz_fix_zero_bug_scc(struct uart_pmac_port *up)
+static void pmz_fix_zero_bug_scc(struct uart_pmac_port *uap)
 {
-	write_zsreg(up, 9, ZS_IS_CHANNEL_A(up) ? CHRA : CHRB);
-	zssync(up);
+	write_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);
+	zssync(uap);
 	udelay(10);
-	write_zsreg(up, 9, (ZS_IS_CHANNEL_A(up) ? CHRA : CHRB) | NV);
-	zssync(up);
-
-	write_zsreg(up, 4, (X1CLK | EXTSYNC));
+	write_zsreg(uap, 9, (ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB) | NV);
+	zssync(uap);
 
-	/* I think this is wrong....but, I just copying code....
-	*/
-	write_zsreg(up, 3, (8 & ~RxENABLE));
-
-	write_zsreg(up, 5, (8 & ~TxENABLE));
-	write_zsreg(up, 9, NV);	/* Didn't we already do this? */
-	write_zsreg(up, 11, (RCBR | TCBR));
-	write_zsreg(up, 12, 0);
-	write_zsreg(up, 13, 0);
-	write_zsreg(up, 14, (LOOPBAK | SSBR));
-	write_zsreg(up, 14, (LOOPBAK | SSBR | BRENAB));
-	write_zsreg(up, 3, (8 | RxENABLE));
-	write_zsreg(up, 0, RES_EXT_INT);
-	write_zsreg(up, 0, RES_EXT_INT);	/* to kill some time */
+	write_zsreg(uap, 4, X1CLK | MONSYNC);
+	write_zsreg(uap, 3, Rx8);
+	write_zsreg(uap, 5, Tx8 | RTS);
+	write_zsreg(uap, 9, NV);	/* Didn't we already do this? */
+	write_zsreg(uap, 11, RCBR | TCBR);
+	write_zsreg(uap, 12, 0);
+	write_zsreg(uap, 13, 0);
+	write_zsreg(uap, 14, (LOOPBAK | BRSRC));
+	write_zsreg(uap, 14, (LOOPBAK | BRSRC | BRENAB));
+	write_zsreg(uap, 3, Rx8 | RxENABLE);
+	write_zsreg(uap, 0, RES_EXT_INT);
+	write_zsreg(uap, 0, RES_EXT_INT);
+	write_zsreg(uap, 0, RES_EXT_INT);	/* to kill some time */
 
 	/* The channel should be OK now, but it is probably receiving
 	 * loopback garbage.
 	 * Switch to asynchronous mode, disable the receiver,
 	 * and discard everything in the receive buffer.
 	 */
-	write_zsreg(up, 9, NV);
-	write_zsreg(up, 4, PAR_ENAB);
-	write_zsreg(up, 3, (8 & ~RxENABLE));
-
-	while (read_zsreg(up, 0) & Rx_CH_AV) {
-		(void)read_zsreg(up, 8);
-		write_zsreg(up, 0, RES_EXT_INT);
-		write_zsreg(up, 0, ERR_RES);
+	write_zsreg(uap, 9, NV);
+	write_zsreg(uap, 4, X16CLK | SB_MASK);
+	write_zsreg(uap, 3, Rx8);
+
+	while (read_zsreg(uap, 0) & Rx_CH_AV) {
+		(void)read_zsreg(uap, 8);
+		write_zsreg(uap, 0, RES_EXT_INT);
+		write_zsreg(uap, 0, ERR_RES);
 	}
 }
 
@@ -726,352 +834,518 @@ static void pmz_fix_zero_bug_scc(struct 
  * actually using the port, this is typically the internal modem
  * powerup delay. This routine expect the lock to be taken.
  */
-static int __pmz_startup(struct uart_pmac_port *up)
+static int __pmz_startup(struct uart_pmac_port *uap)
 {
 	int pwr_delay = 0;
 
-	memset(&up->curregs, 0, sizeof(up->curregs));
+	memset(&uap->curregs, 0, sizeof(uap->curregs));
 
 	/* Power up the SCC & underlying hardware (modem/irda) */
-	pwr_delay = pmz_set_scc_power(up, 1);
+	pwr_delay = pmz_set_scc_power(uap, 1);
 
 	/* Nice buggy HW ... */
-	pmz_fix_zero_bug_scc(up);
+	pmz_fix_zero_bug_scc(uap);
 
-	/* Reset the chip */
-	write_zsreg(up, 9, ZS_IS_CHANNEL_A(up) ? CHRA : CHRB);
-	zssync(up);
+	/* Reset the channel */
+	uap->curregs[R9] = 0;
+	write_zsreg(uap, 9, ZS_IS_CHANNEL_A(uap) ? CHRA : CHRB);
+	zssync(uap);
 	udelay(10);
-	write_zsreg(up, 9, 0);
-	zssync(up);
+	write_zsreg(uap, 9, 0);
+	zssync(uap);
 
 	/* Clear the interrupt registers */
-	write_zsreg(up, R1, 0);
-	write_zsreg(up, R0, ERR_RES);
-	write_zsreg(up, R0, ERR_RES);
-	write_zsreg(up, R0, RES_H_IUS);
-	write_zsreg(up, R0, RES_H_IUS);
+	write_zsreg(uap, R1, 0);
+	write_zsreg(uap, R0, ERR_RES);
+	write_zsreg(uap, R0, ERR_RES);
+	write_zsreg(uap, R0, RES_H_IUS);
+	write_zsreg(uap, R0, RES_H_IUS);
+
+	/* Setup some valid baud rate */
+	uap->curregs[R4] = X16CLK | SB1;
+	uap->curregs[R3] = Rx8;
+	uap->curregs[R5] = Tx8 | RTS;
+	if (!ZS_IS_IRDA(uap))
+		uap->curregs[R5] |= DTR;
+	uap->curregs[R12] = 0;
+	uap->curregs[R13] = 0;
+	uap->curregs[R14] = BRENAB;
 
-	/* Remember status for DCD/CTS changes */
-	up->prev_status = read_zsreg(up, R0);
+	/* Clear handshaking */
+	uap->curregs[R15] = 0;
+
+	/* Master interrupt enable */
+	uap->curregs[R9] |= NV | MIE;
+
+	pmz_load_zsregs(uap, uap->curregs);
 
 	/* Enable receiver and transmitter.  */
-	up->curregs[R3] |= RxENABLE;
-	up->curregs[R5] |= TxENABLE | RTS | DTR;
+	write_zsreg(uap, R3, uap->curregs[R3] |= RxENABLE);
+	write_zsreg(uap, R5, uap->curregs[R5] |= TxENABLE);
 
-	/* Master interrupt enable */
-	up->curregs[R9] |= NV | MIE;
+	/* Remember status for DCD/CTS changes */
+	uap->prev_status = read_zsreg(uap, R0);
 
-	up->curregs[R1] |= EXT_INT_ENAB | INT_ALL_Rx | TxINT_ENAB;
-       	pmz_maybe_update_regs(up);
 
 	return pwr_delay;
 }
 
+static void pmz_irda_reset(struct uart_pmac_port *uap)
+{
+	uap->curregs[R5] |= DTR;
+	write_zsreg(uap, R5, uap->curregs[R5]);
+	zssync(uap);
+	mdelay(110);
+	uap->curregs[R5] &= ~DTR;
+	write_zsreg(uap, R5, uap->curregs[R5]);
+	zssync(uap);
+	mdelay(10);
+}
+
 /*
  * This is the "normal" startup routine, using the above one
  * wrapped with the lock and doing a schedule delay
  */
 static int pmz_startup(struct uart_port *port)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned long flags;
 	int pwr_delay = 0;
 
-	pr_debug("pmz: startup()\n");
+	pmz_debug("pmz: startup()\n");
+
+	if (ZS_IS_ASLEEP(uap))
+		return -EAGAIN;
+	if (uap->node == NULL)
+		return -ENODEV;
+
+	down(&pmz_irq_sem);
+
+	uap->flags |= PMACZILOG_FLAG_IS_OPEN;
 
-	/* A console is never powered down */
-	if (!ZS_IS_CONS(up)) {
+	/* A console is never powered down. Else, power up and
+	 * initialize the chip
+	 */
+	if (!ZS_IS_CONS(uap)) {
 		spin_lock_irqsave(&port->lock, flags);
-		pwr_delay = __pmz_startup(up);
+		pwr_delay = __pmz_startup(uap);
 		spin_unlock_irqrestore(&port->lock, flags);
-	}
-	
-	if (request_irq(up->port.irq, pmz_interrupt, SA_SHIRQ, "PowerMac Zilog", up)) {
-		printk(KERN_ERR "Unable to register zs interrupt handler.\n");
-		pmz_set_scc_power(up, 0);
+	}	
+
+	pmz_get_port_A(uap)->flags |= PMACZILOG_FLAG_IS_IRQ_ON;
+	if (request_irq(uap->port.irq, pmz_interrupt, SA_SHIRQ, "PowerMac Zilog", uap)) {
+		dev_err(&uap->dev->ofdev.dev,
+			"Unable to register zs interrupt handler.\n");
+		pmz_set_scc_power(uap, 0);
+		up(&pmz_irq_sem);
 		return -ENXIO;
 	}
 
+	up(&pmz_irq_sem);
+
 	/* Right now, we deal with delay by blocking here, I'll be
 	 * smarter later on
 	 */
 	if (pwr_delay != 0) {
-		pr_debug("pmz: delaying %d ms\n", pwr_delay);
+		pmz_debug("pmz: delaying %d ms\n", pwr_delay);
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout((pwr_delay * HZ)/1000);
 	}
 
-	pr_debug("pmz: startup() done.\n");
+	/* IrDA reset is done now */
+	if (ZS_IS_IRDA(uap))
+		pmz_irda_reset(uap);
+
+	/* Enable interrupts emission from the chip */
+	spin_lock_irqsave(&port->lock, flags);
+	uap->curregs[R1] |= INT_ALL_Rx | TxINT_ENAB;
+	if (!ZS_IS_EXTCLK(uap))
+		uap->curregs[R1] |= EXT_INT_ENAB;
+	write_zsreg(uap, R1, uap->curregs[R1]);
+       	spin_unlock_irqrestore(&port->lock, flags);
+
+	pmz_debug("pmz: startup() done.\n");
 
 	return 0;
 }
 
 static void pmz_shutdown(struct uart_port *port)
 {
-	struct uart_pmac_port *up = to_pmz(port);
+	struct uart_pmac_port *uap = to_pmz(port);
 	unsigned long flags;
 
-	pr_debug("pmz: shutdown()\n");
-
-	/* Release interrupt handler */
-       	free_irq(up->port.irq, up);
+	pmz_debug("pmz: shutdown()\n");
 
-	if (ZS_IS_CONS(up))
+	if (uap->node == NULL)
 		return;
 
+	down(&pmz_irq_sem);
+
+	/* Release interrupt handler */
+       	free_irq(uap->port.irq, uap);
+
 	spin_lock_irqsave(&port->lock, flags);
 
+	uap->flags &= ~PMACZILOG_FLAG_IS_OPEN;
+
+	if (!ZS_IS_OPEN(uap->mate))
+		pmz_get_port_A(uap)->flags &= ~PMACZILOG_FLAG_IS_IRQ_ON;
+
+	/* Disable interrupts */
+	if (!ZS_IS_ASLEEP(uap)) {
+		uap->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);
+		write_zsreg(uap, R1, uap->curregs[R1]);
+		zssync(uap);
+	}
+
+	if (ZS_IS_CONS(uap) || ZS_IS_ASLEEP(uap)) {
+		spin_unlock_irqrestore(&port->lock, flags);
+		up(&pmz_irq_sem);
+		return;
+	}
+
 	/* Disable receiver and transmitter.  */
-	up->curregs[R3] &= ~RxENABLE;
-	up->curregs[R5] &= ~TxENABLE;
+	uap->curregs[R3] &= ~RxENABLE;
+	uap->curregs[R5] &= ~TxENABLE;
 
 	/* Disable all interrupts and BRK assertion.  */
-	up->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);
-	up->curregs[R5] &= ~SND_BRK;
-	pmz_maybe_update_regs(up);
+	uap->curregs[R5] &= ~SND_BRK;
+	pmz_maybe_update_regs(uap);
 
 	/* Shut the chip down */
-	pmz_set_scc_power(up, 0);
+	pmz_set_scc_power(uap, 0);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 
-	pr_debug("pmz: shutdown() done.\n");
+	up(&pmz_irq_sem);
+
+	pmz_debug("pmz: shutdown() done.\n");
 }
 
 /* Shared by TTY driver and serial console setup.  The port lock is held
  * and local interrupts are disabled.
  */
-static void
-pmz_convert_to_zs(struct uart_pmac_port *up, unsigned int cflag,
-		       unsigned int iflag, int baud)
+static void pmz_convert_to_zs(struct uart_pmac_port *uap, unsigned int cflag,
+			      unsigned int iflag, unsigned long baud)
 {
 	int brg;
 
-	switch (baud) {
-	case ZS_CLOCK/16:	/* 230400 */
-		up->curregs[R4] = X16CLK;
-		up->curregs[R11] = 0;
-		break;
-	case ZS_CLOCK/32:	/* 115200 */
-	        up->curregs[R4] = X32CLK;
-		up->curregs[R11] = 0;
-		break;
-	default:
-		up->curregs[R4] = X16CLK;
-		up->curregs[R11] = TCBR | RCBR;
-		brg = BPS_TO_BRG(baud, ZS_CLOCK / 16);
-		up->curregs[R12] = (brg & 255);
-		up->curregs[R13] = ((brg >> 8) & 255);
-		up->curregs[R14] = BRENAB;
+
+	/* Switch to external clocking for IrDA high clock rates. That
+	 * code could be re-used for Midi interfaces with different
+	 * multipliers
+	 */
+	if (baud >= 115200 && ZS_IS_IRDA(uap)) {
+		uap->curregs[R4] = X1CLK;
+		uap->curregs[R11] = RCTRxCP | TCTRxCP;
+		uap->curregs[R14] = 0; /* BRG off */
+		uap->curregs[R12] = 0;
+		uap->curregs[R13] = 0;
+		uap->flags |= PMACZILOG_FLAG_IS_EXTCLK;
+	} else {
+		switch (baud) {
+		case ZS_CLOCK/16:	/* 230400 */
+			uap->curregs[R4] = X16CLK;
+			uap->curregs[R11] = 0;
+			uap->curregs[R14] = 0;
+			break;
+		case ZS_CLOCK/32:	/* 115200 */
+			uap->curregs[R4] = X32CLK;
+			uap->curregs[R11] = 0;
+			uap->curregs[R14] = 0;
+			break;
+		default:
+			uap->curregs[R4] = X16CLK;
+			uap->curregs[R11] = TCBR | RCBR;
+			brg = BPS_TO_BRG(baud, ZS_CLOCK / 16);
+			uap->curregs[R12] = (brg & 255);
+			uap->curregs[R13] = ((brg >> 8) & 255);
+			uap->curregs[R14] = BRENAB;
+		}
+		uap->flags &= ~PMACZILOG_FLAG_IS_EXTCLK;
 	}
 
 	/* Character size, stop bits, and parity. */
-	up->curregs[3] &= ~RxN_MASK;
-	up->curregs[5] &= ~TxN_MASK;
+	uap->curregs[3] &= ~RxN_MASK;
+	uap->curregs[5] &= ~TxN_MASK;
 
 	switch (cflag & CSIZE) {
 	case CS5:
-		up->curregs[3] |= Rx5;
-		up->curregs[5] |= Tx5;
-		up->parity_mask = 0x1f;
+		uap->curregs[3] |= Rx5;
+		uap->curregs[5] |= Tx5;
+		uap->parity_mask = 0x1f;
 		break;
 	case CS6:
-		up->curregs[3] |= Rx6;
-		up->curregs[5] |= Tx6;
-		up->parity_mask = 0x3f;
+		uap->curregs[3] |= Rx6;
+		uap->curregs[5] |= Tx6;
+		uap->parity_mask = 0x3f;
 		break;
 	case CS7:
-		up->curregs[3] |= Rx7;
-		up->curregs[5] |= Tx7;
-		up->parity_mask = 0x7f;
+		uap->curregs[3] |= Rx7;
+		uap->curregs[5] |= Tx7;
+		uap->parity_mask = 0x7f;
 		break;
 	case CS8:
 	default:
-		up->curregs[3] |= Rx8;
-		up->curregs[5] |= Tx8;
-		up->parity_mask = 0xff;
+		uap->curregs[3] |= Rx8;
+		uap->curregs[5] |= Tx8;
+		uap->parity_mask = 0xff;
 		break;
 	};
-	up->curregs[4] &= ~(SB_MASK);
+	uap->curregs[4] &= ~(SB_MASK);
 	if (cflag & CSTOPB)
-		up->curregs[4] |= SB2;
+		uap->curregs[4] |= SB2;
 	else
-		up->curregs[4] |= SB1;
+		uap->curregs[4] |= SB1;
 	if (cflag & PARENB)
-		up->curregs[4] |= PAR_ENAB;
+		uap->curregs[4] |= PAR_ENAB;
 	else
-		up->curregs[4] &= ~PAR_ENAB;
+		uap->curregs[4] &= ~PAR_ENAB;
 	if (!(cflag & PARODD))
-		up->curregs[4] |= PAR_EVEN;
+		uap->curregs[4] |= PAR_EVEN;
 	else
-		up->curregs[4] &= ~PAR_EVEN;
+		uap->curregs[4] &= ~PAR_EVEN;
 
-	up->port.read_status_mask = Rx_OVR;
+	uap->port.read_status_mask = Rx_OVR;
 	if (iflag & INPCK)
-		up->port.read_status_mask |= CRC_ERR | PAR_ERR;
+		uap->port.read_status_mask |= CRC_ERR | PAR_ERR;
 	if (iflag & (BRKINT | PARMRK))
-		up->port.read_status_mask |= BRK_ABRT;
+		uap->port.read_status_mask |= BRK_ABRT;
 
-	up->port.ignore_status_mask = 0;
+	uap->port.ignore_status_mask = 0;
 	if (iflag & IGNPAR)
-		up->port.ignore_status_mask |= CRC_ERR | PAR_ERR;
+		uap->port.ignore_status_mask |= CRC_ERR | PAR_ERR;
 	if (iflag & IGNBRK) {
-		up->port.ignore_status_mask |= BRK_ABRT;
+		uap->port.ignore_status_mask |= BRK_ABRT;
 		if (iflag & IGNPAR)
-			up->port.ignore_status_mask |= Rx_OVR;
+			uap->port.ignore_status_mask |= Rx_OVR;
 	}
 
 	if ((cflag & CREAD) == 0)
-		up->port.ignore_status_mask = 0xff;
+		uap->port.ignore_status_mask = 0xff;
 }
 
-static void pmz_irda_rts_pulses(struct uart_pmac_port *up, int w)
-{
-	udelay(w);
-	write_zsreg(up, 5, Tx8 | TxENABLE);
-	zssync(up);
-	udelay(2);
-	write_zsreg(up, 5, Tx8 | TxENABLE | RTS);
-	zssync(up);
-	udelay(8);
-	write_zsreg(up, 5, Tx8 | TxENABLE);
-	zssync(up);
-	udelay(4);
-	write_zsreg(up, 5, Tx8 | TxENABLE | RTS);
-	zssync(up);
-}
 
 /*
  * Set the irda codec on the imac to the specified baud rate.
  */
-static void pmz_irda_setup(struct uart_pmac_port *up, int cflags)
+static void pmz_irda_setup(struct uart_pmac_port *uap, unsigned long *baud)
 {
-	int code, speed, t;
+	u8 cmdbyte;
+	int t, version;
 
-	speed = cflags & CBAUD;
-	if (speed < B2400 || speed > B115200)
-		return;
-	code = 0x4d + B115200 - speed;
-
-	/* disable serial interrupts and receive DMA */
-	write_zsreg(up, 1, up->curregs[1] & ~0x9f);
+	switch (*baud) {
+	/* SIR modes */
+	case 2400:
+		cmdbyte = 0x53;
+		break;
+	case 4800:
+		cmdbyte = 0x52;
+		break;
+	case 9600:
+		cmdbyte = 0x51;
+		break;
+	case 19200:
+		cmdbyte = 0x50;
+		break;
+	case 38400:
+		cmdbyte = 0x4f;
+		break;
+	case 57600:
+		cmdbyte = 0x4e;
+		break;
+	case 115200:
+		cmdbyte = 0x4d;
+		break;
+	/* The FIR modes aren't really supported at this point, how
+	 * do we select the speed ? via the FCR on KeyLargo ?
+	 */
+	case 1152000:
+		cmdbyte = 0;
+		break;
+	case 4000000:
+		cmdbyte = 0;
+		break;
+	default: /* 9600 */
+		cmdbyte = 0x51;
+		*baud = 9600;
+		break;
+	}
 
-	/* wait for transmitter to drain */
+	/* Wait for transmitter to drain */
 	t = 10000;
-	while ((read_zsreg(up, R0) & Tx_BUF_EMP) == 0
-	       || (read_zsreg(up, R1) & ALL_SNT) == 0) {
+	while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0
+	       || (read_zsreg(uap, R1) & ALL_SNT) == 0) {
 		if (--t <= 0) {
-			printk(KERN_ERR "transmitter didn't drain\n");
+			dev_err(&uap->dev->ofdev.dev, "transmitter didn't drain\n");
 			return;
 		}
 		udelay(10);
 	}
-	udelay(100);
 
-	/* set to 8 bits, no parity, 19200 baud, RTS on, DTR off */
-	write_zsreg(up, R4, X16CLK | SB1);
-	write_zsreg(up, R11, TCBR | RCBR);
-	t = BPS_TO_BRG(19200, ZS_CLOCK/16);
-	write_zsreg(up, R12, t);
-	write_zsreg(up, R13, t >> 8);
-	write_zsreg(up, R14, BRENAB);
-	write_zsreg(up, R3, Rx8 | RxENABLE);
-	write_zsreg(up, R5, Tx8 | TxENABLE | RTS);
-	zssync(up);
-
-	/* set TxD low for ~104us and pulse RTS */
-	udelay(1000);
-	write_zsdata(up, 0xfe);
-	pmz_irda_rts_pulses(up, 150);
-	pmz_irda_rts_pulses(up, 180);
-	pmz_irda_rts_pulses(up, 50);
-	udelay(100);
-
-	/* assert DTR, wait 30ms, talk to the chip */
-	write_zsreg(up, R5, Tx8 | TxENABLE | RTS | DTR);
-	zssync(up);
-	mdelay(30);
-	while (read_zsreg(up, R0) & Rx_CH_AV)
-		read_zsdata(up);
-
-	write_zsdata(up, 1);
-	t = 1000;
-	while ((read_zsreg(up, R0) & Rx_CH_AV) == 0) {
+	/* Drain the receiver too */
+	t = 100;
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
+	mdelay(10);
+	while (read_zsreg(uap, R0) & Rx_CH_AV) {
+		read_zsdata(uap);
+		mdelay(10);
 		if (--t <= 0) {
-			printk(KERN_ERR "irda_setup timed out on 1st byte\n");
+			dev_err(&uap->dev->ofdev.dev, "receiver didn't drain\n");
+			return;
+		}
+	}
+
+	/* Switch to command mode */
+	uap->curregs[R5] |= DTR;
+	write_zsreg(uap, R5, uap->curregs[R5]);
+	zssync(uap);
+       	mdelay(1);
+
+	/* Switch SCC to 19200 */
+	pmz_convert_to_zs(uap, CS8, 0, 19200);		
+	pmz_load_zsregs(uap, uap->curregs);
+       	mdelay(1);
+
+	/* Write get_version command byte */
+	write_zsdata(uap, 1);
+	t = 5000;
+	while ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {
+		if (--t <= 0) {
+			dev_err(&uap->dev->ofdev.dev,
+				"irda_setup timed out on get_version byte\n");
 			goto out;
 		}
 		udelay(10);
 	}
-	t = read_zsdata(up);
-	if (t != 4)
-		printk(KERN_ERR "irda_setup 1st byte = %x\n", t);
-
-	write_zsdata(up, code);
-	t = 1000;
-	while ((read_zsreg(up, R0) & Rx_CH_AV) == 0) {
+	version = read_zsdata(uap);
+
+	if (version < 4) {
+		dev_info(&uap->dev->ofdev.dev, "IrDA: dongle version %d not supported\n",
+			 version);
+		goto out;
+	}
+
+	/* Send speed mode */
+	write_zsdata(uap, cmdbyte);
+	t = 5000;
+	while ((read_zsreg(uap, R0) & Rx_CH_AV) == 0) {
 		if (--t <= 0) {
-			printk(KERN_ERR "irda_setup timed out on 2nd byte\n");
+			dev_err(&uap->dev->ofdev.dev,
+				"irda_setup timed out on speed mode byte\n");
 			goto out;
 		}
 		udelay(10);
 	}
-	t = read_zsdata(up);
-	if (t != code)
-		printk(KERN_ERR "irda_setup 2nd byte = %x (%x)\n", t, code);
+	t = read_zsdata(uap);
+	if (t != cmdbyte)
+		dev_err(&uap->dev->ofdev.dev,
+			"irda_setup speed mode byte = %x (%x)\n", t, cmdbyte);
+
+	dev_info(&uap->dev->ofdev.dev, "IrDA setup for %ld bps, dongle version: %d\n",
+		 *baud, version);
+
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
 
-	/* Drop DTR again and do some more RTS pulses */
  out:
-	udelay(100);
-	write_zsreg(up, R5, Tx8 | TxENABLE | RTS);
-	pmz_irda_rts_pulses(up, 80);
-
-	/* We should be right to go now.  We assume that load_zsregs
-	   will get called soon to load up the correct baud rate etc. */
-	up->curregs[R5] = (up->curregs[R5] | RTS) & ~DTR;
+	/* Switch back to data mode */
+	uap->curregs[R5] &= ~DTR;
+	write_zsreg(uap, R5, uap->curregs[R5]);
+	zssync(uap);
+
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
+	(void)read_zsdata(uap);
 }
 
-/* The port lock is not held.  */
-static void
-pmz_set_termios(struct uart_port *port, struct termios *termios,
-		     struct termios *old)
-{
-	struct uart_pmac_port *up = to_pmz(port);
-	unsigned long flags;
-	int baud;
 
-	pr_debug("pmz: set_termios()\n");
+static void __pmz_set_termios(struct uart_port *port, struct termios *termios,
+			      struct termios *old)
+{
+	struct uart_pmac_port *uap = to_pmz(port);
+	unsigned long baud;
 
-	baud = uart_get_baud_rate(port, termios, old, 1200, 230400);
+	pmz_debug("pmz: set_termios()\n");
 
-	spin_lock_irqsave(&up->port.lock, flags);
+	if (ZS_IS_ASLEEP(uap))
+		return;
 
-	pmz_convert_to_zs(up, termios->c_cflag, termios->c_iflag, baud);
+	memcpy(&uap->termios_cache, termios, sizeof(struct termios));
 
-	if (UART_ENABLE_MS(&up->port, termios->c_cflag)) {
-		up->curregs[R15] |= DCDIE | SYNCIE | CTSIE;
-		up->flags |= PMACZILOG_FLAG_MODEM_STATUS;
+	/* XXX Check which revs of machines actually allow 1 and 4Mb speeds
+	 * on the IR dongle. Note that the IRTTY driver currently doesn't know
+	 * about the FIR mode and high speed modes. So these are unused. For
+	 * implementing proper support for these, we should probably add some
+	 * DMA as well, at least on the Rx side, which isn't a simple thing
+	 * at this point.
+	 */
+	if (ZS_IS_IRDA(uap)) {
+		/* Calc baud rate */
+		baud = uart_get_baud_rate(port, termios, old, 1200, 4000000);
+		pmz_debug("pmz: switch IRDA to %ld bauds\n", baud);
+		/* Cet the irda codec to the right rate */
+		pmz_irda_setup(uap, &baud);
+		/* Set final baud rate */
+		pmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);
+		pmz_load_zsregs(uap, uap->curregs);
+		zssync(uap);
 	} else {
-		up->curregs[R15] &= ~(DCDIE | SYNCIE | CTSIE);
-		up->flags &= ~PMACZILOG_FLAG_MODEM_STATUS;
-	}
+		baud = uart_get_baud_rate(port, termios, old, 1200, 230400);
+		pmz_convert_to_zs(uap, termios->c_cflag, termios->c_iflag, baud);
+		/* Make sure modem status interrupts are correctly configured */
+		if (UART_ENABLE_MS(&uap->port, termios->c_cflag)) {
+			uap->curregs[R15] |= DCDIE | SYNCIE | CTSIE;
+			uap->flags |= PMACZILOG_FLAG_MODEM_STATUS;
+		} else {
+			uap->curregs[R15] &= ~(DCDIE | SYNCIE | CTSIE);
+			uap->flags &= ~PMACZILOG_FLAG_MODEM_STATUS;
+		}
 
-	/* set the irda codec to the right rate */
-	if (ZS_IS_IRDA(up))
-		pmz_irda_setup(up, termios->c_cflag);
+		/* Load registers to the chip */
+		pmz_maybe_update_regs(uap);
+	}
+	pmz_debug("pmz: set_termios() done.\n");
+}
 
-	/* Load registers to the chip */
-	pmz_maybe_update_regs(up);
+/* The port lock is not held.  */
+static void pmz_set_termios(struct uart_port *port, struct termios *termios,
+			    struct termios *old)
+{
+	struct uart_pmac_port *uap = to_pmz(port);
+	unsigned long flags;
 
-	spin_unlock_irqrestore(&up->port.lock, flags);
+	spin_lock_irqsave(&port->lock, flags);	
 
-	pr_debug("pmz: set_termios() done.\n");
+	/* Disable IRQs on the port */
+	uap->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);
+	write_zsreg(uap, R1, uap->curregs[R1]);
+
+	/* Setup new port configuration */
+	__pmz_set_termios(port, termios, old);
+
+	/* Re-enable IRQs on the port */
+	if (ZS_IS_OPEN(uap)) {
+		uap->curregs[R1] |= INT_ALL_Rx | TxINT_ENAB;
+		if (!ZS_IS_EXTCLK(uap))
+			uap->curregs[R1] |= EXT_INT_ENAB;
+		write_zsreg(uap, R1, uap->curregs[R1]);
+	}
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static const char *pmz_type(struct uart_port *port)
 {
-	return "PowerMac Zilog";
+	struct uart_pmac_port *uap = to_pmz(port);
+
+	if (ZS_IS_IRDA(uap))
+		return "Z85c30 ESCC - Infrared port";
+	else if (ZS_IS_INTMODEM(uap))
+		return "Z85c30 ESCC - Internal modem";
+	return "Z85c30 ESCC - Serial port";
 }
 
 /* We do not request/release mappings of the registers here, this
@@ -1121,9 +1395,9 @@ static struct uart_ops pmz_pops = {
  * Unlike sunzilog, we don't need to pre-init the spinlock as we don't
  * register our console before uart_add_one_port() is called
  */
-static int __init pmz_init_port(struct uart_pmac_port *up)
+static int __init pmz_init_port(struct uart_pmac_port *uap)
 {
-	struct device_node *np = up->node;
+	struct device_node *np = uap->node;
 	char *conn;
 	struct slot_names_prop {
 		int	count;
@@ -1134,35 +1408,35 @@ static int __init pmz_init_port(struct u
 	/*
 	 * Request & map chip registers
 	 */
-	up->port.mapbase = np->addrs[0].address;
-	up->port.membase = ioremap(up->port.mapbase, 0x1000);
+	uap->port.mapbase = np->addrs[0].address;
+	uap->port.membase = ioremap(uap->port.mapbase, 0x1000);
       
-	up->control_reg = (volatile u8 *)up->port.membase;
-	up->data_reg = up->control_reg + 0x10;
+	uap->control_reg = (volatile u8 *)uap->port.membase;
+	uap->data_reg = uap->control_reg + 0x10;
 	
 	/*
 	 * Request & map DBDMA registers
 	 */
 #ifdef HAS_DBDMA
 	if (np->n_addrs >= 3 && np->n_intrs >= 3)
-		up->flags |= PMACZILOG_FLAG_HAS_DMA;
+		uap->flags |= PMACZILOG_FLAG_HAS_DMA;
 #endif	
-	if (ZS_HAS_DMA(up)) {
-		up->tx_dma_regs = (volatile struct dbdma_regs *)
+	if (ZS_HAS_DMA(uap)) {
+		uap->tx_dma_regs = (volatile struct dbdma_regs *)
 			ioremap(np->addrs[np->n_addrs - 2].address, 0x1000);
-		if (up->tx_dma_regs == NULL) {	
-			up->flags &= ~PMACZILOG_FLAG_HAS_DMA;
+		if (uap->tx_dma_regs == NULL) {	
+			uap->flags &= ~PMACZILOG_FLAG_HAS_DMA;
 			goto no_dma;
 		}
-		up->rx_dma_regs = (volatile struct dbdma_regs *)
+		uap->rx_dma_regs = (volatile struct dbdma_regs *)
 			ioremap(np->addrs[np->n_addrs - 1].address, 0x1000);
-		if (up->rx_dma_regs == NULL) {	
-			iounmap((void *)up->tx_dma_regs);
-			up->flags &= ~PMACZILOG_FLAG_HAS_DMA;
+		if (uap->rx_dma_regs == NULL) {	
+			iounmap((void *)uap->tx_dma_regs);
+			uap->flags &= ~PMACZILOG_FLAG_HAS_DMA;
 			goto no_dma;
 		}
-		up->tx_dma_irq = np->intrs[1].line;
-		up->rx_dma_irq = np->intrs[2].line;
+		uap->tx_dma_irq = np->intrs[1].line;
+		uap->rx_dma_irq = np->intrs[2].line;
 	}
 no_dma:
 
@@ -1170,22 +1444,22 @@ no_dma:
 	 * Detect port type
 	 */
 	if (device_is_compatible(np, "cobalt"))
-		up->flags |= PMACZILOG_FLAG_IS_INTMODEM;
+		uap->flags |= PMACZILOG_FLAG_IS_INTMODEM;
 	conn = get_property(np, "AAPL,connector", &len);
 	if (conn && (strcmp(conn, "infrared") == 0))
-		up->flags |= PMACZILOG_FLAG_IS_IRDA;
-	up->port_type = PMAC_SCC_ASYNC;
+		uap->flags |= PMACZILOG_FLAG_IS_IRDA;
+	uap->port_type = PMAC_SCC_ASYNC;
 	/* 1999 Powerbook G3 has slot-names property instead */
 	slots = (struct slot_names_prop *)get_property(np, "slot-names", &len);
 	if (slots && slots->count > 0) {
 		if (strcmp(slots->name, "IrDA") == 0)
-			up->flags |= PMACZILOG_FLAG_IS_IRDA;
+			uap->flags |= PMACZILOG_FLAG_IS_IRDA;
 		else if (strcmp(slots->name, "Modem") == 0)
-			up->flags |= PMACZILOG_FLAG_IS_INTMODEM;
+			uap->flags |= PMACZILOG_FLAG_IS_INTMODEM;
 	}
-	if (ZS_IS_IRDA(up))
-		up->port_type = PMAC_SCC_IRDA;
-	if (ZS_IS_INTMODEM(up)) {
+	if (ZS_IS_IRDA(uap))
+		uap->port_type = PMAC_SCC_IRDA;
+	if (ZS_IS_INTMODEM(uap)) {
 		struct device_node* i2c_modem = find_devices("i2c-modem");
 		if (i2c_modem) {
 			char* mid = get_property(i2c_modem, "modem-id", NULL);
@@ -1196,7 +1470,7 @@ no_dma:
 			case 0x08 :
 			case 0x0b :
 			case 0x0c :
-				up->port_type = PMAC_SCC_I2S1;
+				uap->port_type = PMAC_SCC_I2S1;
 			}
 			printk(KERN_INFO "pmac_zilog: i2c-modem detected, id: %d\n",
 				mid ? (*mid) : 0);
@@ -1208,13 +1482,19 @@ no_dma:
 	/*
 	 * Init remaining bits of "port" structure
 	 */
-	up->port.iotype = SERIAL_IO_MEM;
-	up->port.irq = np->intrs[0].line;
-	up->port.uartclk = ZS_CLOCK;
-	up->port.fifosize = 1;
-	up->port.ops = &pmz_pops;
-	up->port.type = PORT_PMAC_ZILOG;
-	up->port.flags = 0;
+	uap->port.iotype = SERIAL_IO_MEM;
+	uap->port.irq = np->intrs[0].line;
+	uap->port.uartclk = ZS_CLOCK;
+	uap->port.fifosize = 1;
+	uap->port.ops = &pmz_pops;
+	uap->port.type = PORT_PMAC_ZILOG;
+	uap->port.flags = 0;
+
+	/* Setup some valid baud rate information in the register
+	 * shadows so we don't write crap there before baud rate is
+	 * first initialized.
+	 */
+	pmz_convert_to_zs(uap, CS8, 0, 9600);
 
 	return 0;
 }
@@ -1222,13 +1502,13 @@ no_dma:
 /*
  * Get rid of a port on module removal
  */
-static void pmz_dispose_port(struct uart_pmac_port *up)
+static void pmz_dispose_port(struct uart_pmac_port *uap)
 {
 	struct device_node *np;
 
-	iounmap((void *)up->control_reg);
-	np = up->node;
-	up->node = NULL;
+	iounmap((void *)uap->control_reg);
+	np = uap->node;
+	uap->node = NULL;
 	of_node_put(np);
 }
 
@@ -1243,15 +1523,16 @@ static int pmz_attach(struct macio_dev *
 	 */
 	for (i = 0; i < MAX_ZS_PORTS; i++)
 		if (pmz_ports[i].node == mdev->ofdev.node) {
-			struct uart_pmac_port *up = &pmz_ports[i];
+			struct uart_pmac_port *uap = &pmz_ports[i];
 
-			up->dev = mdev;
-			dev_set_drvdata(&mdev->ofdev.dev, up);
-			if (macio_request_resources(up->dev, "pmac_zilog"))
-				printk(KERN_WARNING "%s: Failed to request resource, port still active\n",
-				       up->node->name);
+			uap->dev = mdev;
+			dev_set_drvdata(&mdev->ofdev.dev, uap);
+			if (macio_request_resources(uap->dev, "pmac_zilog"))
+				printk(KERN_WARNING "%s: Failed to request resource"
+				       ", port still active\n",
+				       uap->node->name);
 			else
-				up->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;				
+				uap->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;				
 			return 0;
 		}
 	return -ENODEV;
@@ -1263,18 +1544,135 @@ static int pmz_attach(struct macio_dev *
  */
 static int pmz_detach(struct macio_dev *mdev)
 {
-	struct uart_pmac_port	*up = dev_get_drvdata(&mdev->ofdev.dev);
+	struct uart_pmac_port	*uap = dev_get_drvdata(&mdev->ofdev.dev);
 	
-	if (!up)
+	if (!uap)
 		return -ENODEV;
 
-	if (up->flags & PMACZILOG_FLAG_RSRC_REQUESTED) {
-		macio_release_resources(up->dev);
-		up->flags &= ~PMACZILOG_FLAG_RSRC_REQUESTED;
+	if (uap->flags & PMACZILOG_FLAG_RSRC_REQUESTED) {
+		macio_release_resources(uap->dev);
+		uap->flags &= ~PMACZILOG_FLAG_RSRC_REQUESTED;
 	}
 	dev_set_drvdata(&mdev->ofdev.dev, NULL);
-	up->dev = NULL;
+	uap->dev = NULL;
+	
+	return 0;
+}
+
+
+static int pmz_suspend(struct macio_dev *mdev, u32 pm_state)
+{
+	struct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);
+	struct uart_state *state = pmz_uart_reg.state + uap->port.line;
+	unsigned long flags;
+
+	if (uap == NULL)
+		return 0;
+
+	if (pm_state == mdev->ofdev.dev.power_state || pm_state < 2)
+		return 0;
+
+	down(&pmz_irq_sem);
+	down(&state->sem);
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+
+	if (ZS_IS_OPEN(uap) || ZS_IS_CONS(uap)) {
+		/* Disable receiver and transmitter.  */
+		uap->curregs[R3] &= ~RxENABLE;
+		uap->curregs[R5] &= ~TxENABLE;
+
+		/* Disable all interrupts and BRK assertion.  */
+		uap->curregs[R1] &= ~(EXT_INT_ENAB | TxINT_ENAB | RxINT_MASK);
+		uap->curregs[R5] &= ~SND_BRK;
+		pmz_load_zsregs(uap, uap->curregs);
+		uap->flags |= PMACZILOG_FLAG_IS_ASLEEP;
+		mb();
+	}
+
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+
+	if (ZS_IS_OPEN(uap) || ZS_IS_OPEN(uap->mate))
+		if (ZS_IS_ASLEEP(uap->mate) && ZS_IS_IRQ_ON(pmz_get_port_A(uap))) {
+			pmz_get_port_A(uap)->flags &= ~PMACZILOG_FLAG_IS_IRQ_ON;
+			disable_irq(uap->port.irq);
+		}
+
+	if (ZS_IS_CONS(uap))
+		uap->port.cons->flags &= ~CON_ENABLED;
+
+	/* Shut the chip down */
+	pmz_set_scc_power(uap, 0);
+
+	up(&state->sem);
+	up(&pmz_irq_sem);
+
+	mdev->ofdev.dev.power_state = pm_state;
+
+	return 0;
+}
+
+
+static int pmz_resume(struct macio_dev *mdev)
+{
+	struct uart_pmac_port *uap = dev_get_drvdata(&mdev->ofdev.dev);
+	struct uart_state *state = pmz_uart_reg.state + uap->port.line;
+	unsigned long flags;
+	int pwr_delay;
+
+	if (uap == NULL)
+		return 0;
+
+	if (mdev->ofdev.dev.power_state == 0)
+		return 0;
 	
+	down(&pmz_irq_sem);
+	down(&state->sem);
+
+	spin_lock_irqsave(&uap->port.lock, flags);
+	if (!ZS_IS_OPEN(uap) && !ZS_IS_CONS(uap)) {
+		spin_unlock_irqrestore(&uap->port.lock, flags);
+		goto bail;
+	}
+	pwr_delay = __pmz_startup(uap);
+
+	/* Take care of config that may have changed while asleep */
+	__pmz_set_termios(&uap->port, &uap->termios_cache, NULL);
+
+	if (ZS_IS_OPEN(uap)) {
+		/* Enable interrupts */		
+		uap->curregs[R1] |= INT_ALL_Rx | TxINT_ENAB;
+		if (!ZS_IS_EXTCLK(uap))
+			uap->curregs[R1] |= EXT_INT_ENAB;
+		write_zsreg(uap, R1, uap->curregs[R1]);
+	}
+
+	spin_unlock_irqrestore(&uap->port.lock, flags);
+
+	if (ZS_IS_CONS(uap))
+		uap->port.cons->flags |= CON_ENABLED;
+
+	/* Re-enable IRQ on the controller */
+	if (ZS_IS_OPEN(uap) && !ZS_IS_IRQ_ON(pmz_get_port_A(uap))) {
+		pmz_get_port_A(uap)->flags |= PMACZILOG_FLAG_IS_IRQ_ON;
+		enable_irq(uap->port.irq);
+	}
+
+	up(&state->sem);
+	up(&pmz_irq_sem);
+
+	/* Right now, we deal with delay by blocking here, I'll be
+	 * smarter later on
+	 */
+	if (pwr_delay != 0) {
+		pmz_debug("pmz: delaying %d ms\n", pwr_delay);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout((pwr_delay * HZ)/1000);
+	}
+
+ bail:
+	mdev->ofdev.dev.power_state = 0;
+
 	return 0;
 }
 
@@ -1307,7 +1705,7 @@ static int __init pmz_probe(void)
 			else if (strncmp(np->name, "ch-b", 4) == 0)
 				node_b = of_node_get(np);
 		}
-		if (!node_a || !node_b) {
+		if (!node_a && !node_b) {
 			of_node_put(node_a);
 			of_node_put(node_b);
 			printk(KERN_ERR "pmac_zilog: missing node %c for escc %s\n",
@@ -1330,7 +1728,7 @@ static int __init pmz_probe(void)
 		 * Setup the ports for real
 		 */
 		rc = pmz_init_port(&pmz_ports[count]);
-		if (rc == 0)
+		if (rc == 0 && node_b != NULL)
 			rc = pmz_init_port(&pmz_ports[count+1]);
 		if (rc != 0) {
 			of_node_put(node_a);
@@ -1348,14 +1746,6 @@ next:
 	return 0;
 }
 
-static struct uart_driver pmz_uart_reg = {
-	.owner		=	THIS_MODULE,
-	.driver_name	=	"ttyS",
-	.devfs_name	=	"tts/",
-	.dev_name	=	"ttyS",
-	.major		=	TTY_MAJOR,
-};
-
 #ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
 
 static void pmz_console_write(struct console *con, const char *s, unsigned int count);
@@ -1400,6 +1790,7 @@ static int __init pmz_register(void)
 	 */
 	for (i = 0; i < pmz_ports_count; i++) {
 		struct uart_pmac_port *uport = &pmz_ports[i];
+		/* NULL node may happen on wallstreet */
 		if (uport->node != NULL)
 			uart_add_one_port(&pmz_uart_reg, &uport->port);
 	}
@@ -1428,13 +1819,13 @@ static struct macio_driver pmz_driver = 
 	.match_table	= pmz_match,
 	.probe		= pmz_attach,
 	.remove		= pmz_detach,
-//	.suspend	= pmz_suspend, *** NYI
-//	.resume		= pmz_resume,  *** NYI
+	.suspend	= pmz_suspend,
+       	.resume		= pmz_resume,
 };
 
 static int __init init_pmz(void)
 {
-	printk(KERN_DEBUG "%s\n", version);
+	printk(KERN_INFO "%s\n", version);
 
 	/* 
 	 * First, we need to do a direct OF-based probe pass. We
@@ -1490,33 +1881,33 @@ static void __exit exit_pmz(void)
  */
 static void pmz_console_write(struct console *con, const char *s, unsigned int count)
 {
-	struct uart_pmac_port *up = &pmz_ports[con->index];
+	struct uart_pmac_port *uap = &pmz_ports[con->index];
 	unsigned long flags;
 	int i;
 
-	spin_lock_irqsave(&up->port.lock, flags);
+	spin_lock_irqsave(&uap->port.lock, flags);
 
 	/* Turn of interrupts and enable the transmitter. */
-	write_zsreg(up, R1, up->curregs[1] & ~TxINT_ENAB);
-	write_zsreg(up, R5, up->curregs[5] | TxENABLE | RTS | DTR);
+	write_zsreg(uap, R1, uap->curregs[1] & ~TxINT_ENAB);
+	write_zsreg(uap, R5, uap->curregs[5] | TxENABLE | RTS | DTR);
 
 	for (i = 0; i < count; i++) {
 		/* Wait for the transmit buffer to empty. */
-		while ((read_zsreg(up, R0) & Tx_BUF_EMP) == 0)
+		while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)
 			udelay(5);
-		write_zsdata(up, s[i]);
+		write_zsdata(uap, s[i]);
 		if (s[i] == 10) {
-			while ((read_zsreg(up, R0) & Tx_BUF_EMP) == 0)
+			while ((read_zsreg(uap, R0) & Tx_BUF_EMP) == 0)
 				udelay(5);
-			write_zsdata(up, R13);
+			write_zsdata(uap, R13);
 		}
 	}
 
 	/* Restore the values in the registers. */
-	write_zsreg(up, R1, up->curregs[1]);
+	write_zsreg(uap, R1, uap->curregs[1]);
 	/* Don't disable the transmitter. */
 
-	spin_unlock_irqrestore(&up->port.lock, flags);
+	spin_unlock_irqrestore(&uap->port.lock, flags);
 }
 
 /*
@@ -1524,6 +1915,7 @@ static void pmz_console_write(struct con
  */
 static int __init pmz_console_setup(struct console *co, char *options)
 {
+	struct uart_pmac_port *uap;
 	struct uart_port *port;
 	int baud = 38400;
 	int bits = 8;
@@ -1535,7 +1927,8 @@ static int __init pmz_console_setup(stru
 	 * XServe's default to 57600 bps
 	 */
 	if (machine_is_compatible("RackMac1,1")
-	 || machine_is_compatible("RackMac1,2"))
+	    || machine_is_compatible("RackMac1,2")
+	    || machine_is_compatible("MacRISC4"))
 	 	baud = 57600;
 
 	/*
@@ -1545,12 +1938,15 @@ static int __init pmz_console_setup(stru
 	 */
 	if (co->index >= pmz_ports_count)
 		co->index = 0;
-	port = &pmz_ports[co->index].port;
+	uap = &pmz_ports[co->index];
+	if (uap->node == NULL)
+		return -ENODEV;
+	port = &uap->port;
 
 	/*
 	 * Mark port as beeing a console
 	 */
-	port->flags |= PMACZILOG_FLAG_IS_CONS;
+	uap->flags |= PMACZILOG_FLAG_IS_CONS;
 
 	/*
 	 * Temporary fix for uart layer who didn't setup the spinlock yet
@@ -1560,7 +1956,7 @@ static int __init pmz_console_setup(stru
 	/*
 	 * Enable the hardware
 	 */
-	pwr_delay = __pmz_startup(&pmz_ports[co->index]);
+	pwr_delay = __pmz_startup(uap);
 	if (pwr_delay)
 		mdelay(pwr_delay);
 	
diff -purN linux-post-2.6.4rc2-20040309/drivers/serial/pmac_zilog.h linux-post-2.6.4rc3-20040310/drivers/serial/pmac_zilog.h
--- linux-post-2.6.4rc2-20040309/drivers/serial/pmac_zilog.h	2003-08-24 15:05:54.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/drivers/serial/pmac_zilog.h	2004-03-10 10:18:32.000000000 +0000
@@ -1,6 +1,8 @@
 #ifndef __PMAC_ZILOG_H__
 #define __PMAC_ZILOG_H__
 
+#define pmz_debug(fmt,arg...)	dev_dbg(&uap->dev->ofdev.dev, fmt, ## arg)
+
 /*
  * At most 2 ESCCs with 2 ports each
  */
@@ -9,7 +11,7 @@
 /* 
  * We wrap our port structure around the generic uart_port.
  */
-#define NUM_ZSREGS    16
+#define NUM_ZSREGS    17
 
 struct uart_pmac_port {
 	struct uart_port		port;
@@ -41,6 +43,10 @@ struct uart_pmac_port {
 #define PMACZILOG_FLAG_IS_INTMODEM	0x00000200
 #define PMACZILOG_FLAG_HAS_DMA		0x00000400
 #define PMACZILOG_FLAG_RSRC_REQUESTED	0x00000800
+#define PMACZILOG_FLAG_IS_ASLEEP	0x00001000
+#define PMACZILOG_FLAG_IS_OPEN		0x00002000
+#define PMACZILOG_FLAG_IS_IRQ_ON	0x00004000
+#define PMACZILOG_FLAG_IS_EXTCLK	0x00008000
 
 	unsigned char			parity_mask;
 	unsigned char			prev_status;
@@ -52,10 +58,19 @@ struct uart_pmac_port {
 	unsigned int			rx_dma_irq;
 	volatile struct dbdma_regs	*tx_dma_regs;
 	volatile struct dbdma_regs	*rx_dma_regs;
+
+	struct termios			termios_cache;
 };
 
 #define to_pmz(p) ((struct uart_pmac_port *)(p))
 
+static inline struct uart_pmac_port *pmz_get_port_A(struct uart_pmac_port *uap)
+{
+	if (uap->flags & PMACZILOG_FLAG_IS_CHANNEL_A)
+		return uap;
+	return uap->mate;
+}
+
 /*
  * Register acessors. Note that we don't need to enforce a recovery
  * delay on PCI PowerMac hardware, it's dealt in HW by the MacIO chip,
@@ -120,6 +135,7 @@ static inline void zssync(struct uart_pm
 #define	R13	13
 #define	R14	14
 #define	R15	15
+#define	R7P	16
 
 #define	NULLCODE	0	/* Null Code */
 #define	POINT_HIGH	0x8	/* Select upper half of registers */
@@ -357,5 +373,9 @@ static inline void zssync(struct uart_pm
 #define ZS_IS_IRDA(UP)			((UP)->flags & PMACZILOG_FLAG_IS_IRDA)
 #define ZS_IS_INTMODEM(UP)	       	((UP)->flags & PMACZILOG_FLAG_IS_INTMODEM)
 #define ZS_HAS_DMA(UP)			((UP)->flags & PMACZILOG_FLAG_HAS_DMA)
+#define ZS_IS_ASLEEP(UP)       		((UP)->flags & PMACZILOG_FLAG_IS_ASLEEP)
+#define ZS_IS_OPEN(UP)       		((UP)->flags & PMACZILOG_FLAG_IS_OPEN)
+#define ZS_IS_IRQ_ON(UP)       		((UP)->flags & PMACZILOG_FLAG_IS_IRQ_ON)
+#define ZS_IS_EXTCLK(UP)       		((UP)->flags & PMACZILOG_FLAG_IS_EXTCLK)
 
 #endif /* __PMAC_ZILOG_H__ */
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/crc.h linux-post-2.6.4rc3-20040310/include/net/irda/crc.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/crc.h	2002-10-11 17:29:10.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/crc.h	2004-03-09 21:34:16.000000000 +0000
@@ -28,6 +28,6 @@ static inline __u16 irda_fcs(__u16 fcs, 
 }
 
 /* Recompute the FCS with len bytes appended. */
-unsigned short irda_calc_crc16( __u16 fcs, __u8 const *buf, size_t len);
+__u16 irda_calc_crc16( __u16 fcs, __u8 const *buf, size_t len);
 
 #endif
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/irda.h linux-post-2.6.4rc3-20040310/include/net/irda/irda.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/irda.h	2002-06-19 02:13:10.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/irda.h	2004-03-09 21:39:26.000000000 +0000
@@ -61,7 +61,7 @@ typedef __u32 magic_t;
 
 #ifdef CONFIG_IRDA_DEBUG
 
-extern __u32 irda_debug;
+extern unsigned int irda_debug;
 
 /* use 0 for production, 1 for verification, >2 for debug */
 #define IRDA_DEBUG_LEVEL 0
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/irda_device.h linux-post-2.6.4rc3-20040310/include/net/irda/irda_device.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/irda_device.h	2004-02-26 20:31:07.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/irda_device.h	2004-03-09 21:36:17.000000000 +0000
@@ -227,7 +227,6 @@ static inline int irda_device_txqueue_em
 int  irda_device_set_raw_mode(struct net_device* self, int status);
 int  irda_device_set_dtr_rts(struct net_device *dev, int dtr, int rts);
 int  irda_device_change_speed(struct net_device *dev, __u32 speed);
-void irda_device_setup(struct net_device *dev);
 struct net_device *alloc_irdadev(int sizeof_priv);
 
 /* Dongle interface */
@@ -253,28 +252,11 @@ void irda_task_next_state(struct irda_ta
  *    Utility function for getting the minimum turnaround time out of 
  *    the skb, where it has been hidden in the cb field.
  */
-#define irda_get_mtt(skb) (                                                 \
-        IRDA_MIN(10000,                                                     \
-                  (((struct irda_skb_cb *) skb->cb)->magic == LAP_MAGIC) ?  \
-                          ((struct irda_skb_cb *)(skb->cb))->mtt : 10000    \
-                 )							    \
-)
-
-#if 0
-extern inline __u16 irda_get_mtt(struct sk_buff *skb)
+static inline __u16 irda_get_mtt(const struct sk_buff *skb)
 {
-	__u16 mtt;
-
-	if (((struct irda_skb_cb *)(skb->cb))->magic != LAP_MAGIC)
-		mtt = 10000;
-	else
-		mtt = ((struct irda_skb_cb *)(skb->cb))->mtt;
-
-	ASSERT(mtt <= 10000, return 10000;);
-	
-	return mtt;
+	const struct irda_skb_cb *cb = (const struct irda_skb_cb *) skb->cb;
+	return (cb->magic == LAP_MAGIC) ? cb->mtt : 10000;
 }
-#endif
 
 /*
  * Function irda_get_next_speed (skb)
@@ -283,24 +265,11 @@ extern inline __u16 irda_get_mtt(struct 
  *
  * Note : return -1 for user space frames
  */
-#define irda_get_next_speed(skb) (	                                        \
-	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
-                  ((struct irda_skb_cb *)(skb->cb))->next_speed : -1 	\
-)
-
-#if 0
-extern inline __u32 irda_get_next_speed(struct sk_buff *skb)
+static inline __u32 irda_get_next_speed(const struct sk_buff *skb)
 {
-	__u32 speed;
-
-	if (((struct irda_skb_cb *)(skb->cb))->magic != LAP_MAGIC)
-		speed = -1;
-	else
-		speed = ((struct irda_skb_cb *)(skb->cb))->next_speed;
-
-	return speed;
+	const struct irda_skb_cb *cb = (const struct irda_skb_cb *) skb->cb;
+	return (cb->magic == LAP_MAGIC) ? cb->next_speed : -1;
 }
-#endif
 
 /*
  * Function irda_get_next_xbofs (skb)
@@ -309,10 +278,11 @@ extern inline __u32 irda_get_next_speed(
  *
  * Note : default to 10 for user space frames
  */
-#define irda_get_xbofs(skb) (	                                        \
-	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
-                  ((struct irda_skb_cb *)(skb->cb))->xbofs : 10 	\
-)
+static inline __u16 irda_get_xbofs(const struct sk_buff *skb)
+{
+	const struct irda_skb_cb *cb = (const struct irda_skb_cb *) skb->cb;
+	return (cb->magic == LAP_MAGIC) ? cb->xbofs : 10;
+}
 
 /*
  * Function irda_get_next_xbofs (skb)
@@ -321,11 +291,11 @@ extern inline __u32 irda_get_next_speed(
  *
  * Note : return -1 for user space frames
  */
-#define irda_get_next_xbofs(skb) (	                                        \
-	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
-                  ((struct irda_skb_cb *)(skb->cb))->next_xbofs : -1 	\
-)
-
+static inline __u16 irda_get_next_xbofs(const struct sk_buff *skb)
+{
+	const struct irda_skb_cb *cb = (const struct irda_skb_cb *) skb->cb;
+	return (cb->magic == LAP_MAGIC) ? cb->next_xbofs : -1;
+}
 #endif /* IRDA_DEVICE_H */
 
 
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/irias_object.h linux-post-2.6.4rc3-20040310/include/net/irda/irias_object.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/irias_object.h	2003-01-14 01:12:00.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/irias_object.h	2004-03-09 21:31:48.000000000 +0000
@@ -101,7 +101,7 @@ struct ias_value *irias_new_octseq_value
 struct ias_value *irias_new_missing_value(void);
 void irias_delete_value(struct ias_value *value);
 
-extern struct ias_value missing;
+extern struct ias_value irias_missing;
 extern hashbin_t *irias_objects;
 
 #endif
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/irlmp.h linux-post-2.6.4rc3-20040310/include/net/irda/irlmp.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/irlmp.h	2004-02-10 02:32:48.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/irlmp.h	2004-03-09 21:32:34.000000000 +0000
@@ -249,10 +249,17 @@ int  irlmp_slsap_inuse(__u8 slsap);
 __u8 irlmp_find_free_slsap(void);
 LM_REASON irlmp_convert_lap_reason(LAP_REASON);
 
-__u32 irlmp_get_saddr(struct lsap_cb *self);
-__u32 irlmp_get_daddr(struct lsap_cb *self);
+static inline __u32 irlmp_get_saddr(const struct lsap_cb *self)
+{
+	return (self && !self->lap) ? self->lap->saddr : 0;
+}
+
+static inline __u32 irlmp_get_daddr(const struct lsap_cb *self)
+{
+	return (self && self->lap) ? self->lap->daddr : 0;
+}
 
-extern char *lmp_reasons[];
+extern const char *irlmp_reasons[];
 extern int sysctl_discovery_timeout;
 extern int sysctl_discovery_slots;
 extern int sysctl_discovery;
diff -purN linux-post-2.6.4rc2-20040309/include/net/irda/timer.h linux-post-2.6.4rc3-20040310/include/net/irda/timer.h
--- linux-post-2.6.4rc2-20040309/include/net/irda/timer.h	2004-01-25 19:06:23.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/include/net/irda/timer.h	2004-03-09 21:34:53.000000000 +0000
@@ -71,8 +71,18 @@ struct lap_cb;
 
 typedef void (*TIMER_CALLBACK)(void *);
 
-void irda_start_timer(struct timer_list *ptimer, int timeout, void* data,
-		      TIMER_CALLBACK callback);
+static inline void irda_start_timer(struct timer_list *ptimer, int timeout, 
+				    void* data, TIMER_CALLBACK callback)
+{
+	ptimer->function = (void (*)(unsigned long)) callback;
+	ptimer->data = (unsigned long) data;
+	
+	/* Set new value for timer (update or add timer).
+	 * We use mod_timer() because it's more efficient and also
+	 * safer with respect to race conditions - Jean II */
+	mod_timer(ptimer, jiffies + timeout);
+}
+
 
 void irlap_start_slot_timer(struct irlap_cb *self, int timeout);
 void irlap_start_query_timer(struct irlap_cb *self, int timeout);
diff -purN linux-post-2.6.4rc2-20040309/init/main.c linux-post-2.6.4rc3-20040310/init/main.c
--- linux-post-2.6.4rc2-20040309/init/main.c	2004-02-26 14:20:24.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/init/main.c	2004-03-09 15:07:59.000000000 +0000
@@ -38,6 +38,7 @@
 #include <linux/profile.h>
 #include <linux/rcupdate.h>
 #include <linux/moduleparam.h>
+#include <linux/kallsyms.h>
 #include <linux/writeback.h>
 #include <linux/cpu.h>
 #include <linux/efi.h>
@@ -510,8 +511,11 @@ static void __init do_initcalls(void)
 	for (call = &__initcall_start; call < &__initcall_end; call++) {
 		char *msg;
 
-		if (initcall_debug)
-			printk("calling initcall 0x%p\n", *call);
+		if (initcall_debug) {
+			printk(KERN_DEBUG "Calling initcall 0x%p", *call);
+			print_symbol(": %s()", (unsigned long) *call);
+			printk("\n");
+		}
 
 		(*call)();
 
diff -purN linux-post-2.6.4rc2-20040309/kernel/stop_machine.c linux-post-2.6.4rc3-20040310/kernel/stop_machine.c
--- linux-post-2.6.4rc2-20040309/kernel/stop_machine.c	2004-02-07 09:50:38.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/kernel/stop_machine.c	2004-03-10 01:03:23.000000000 +0000
@@ -3,6 +3,7 @@
 #include <linux/sched.h>
 #include <linux/cpu.h>
 #include <linux/err.h>
+#include <linux/syscalls.h>
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
 
diff -purN linux-post-2.6.4rc2-20040309/net/ipv4/esp4.c linux-post-2.6.4rc3-20040310/net/ipv4/esp4.c
--- linux-post-2.6.4rc2-20040309/net/ipv4/esp4.c	2003-08-18 11:14:38.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/ipv4/esp4.c	2004-03-09 23:21:50.000000000 +0000
@@ -518,6 +518,8 @@ int esp_init_state(struct xfrm_state *x,
 	esp->conf.padlen = 0;
 	if (esp->conf.ivlen) {
 		esp->conf.ivec = kmalloc(esp->conf.ivlen, GFP_KERNEL);
+		if (unlikely(esp->conf.ivec == NULL))
+			goto error;
 		get_random_bytes(esp->conf.ivec, esp->conf.ivlen);
 	}
 	crypto_cipher_setkey(esp->conf.tfm, esp->conf.key, esp->conf.key_len);
diff -purN linux-post-2.6.4rc2-20040309/net/ipv4/ip_output.c linux-post-2.6.4rc3-20040310/net/ipv4/ip_output.c
--- linux-post-2.6.4rc2-20040309/net/ipv4/ip_output.c	2004-03-01 05:52:42.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/ipv4/ip_output.c	2004-03-09 23:21:50.000000000 +0000
@@ -761,8 +761,11 @@ int ip_append_data(struct sock *sk,
 		 */
 		opt = ipc->opt;
 		if (opt) {
-			if (inet->cork.opt == NULL)
+			if (inet->cork.opt == NULL) {
 				inet->cork.opt = kmalloc(sizeof(struct ip_options) + 40, sk->sk_allocation);
+				if (unlikely(inet->cork.opt == NULL))
+					return -ENOBUFS;
+			}
 			memcpy(inet->cork.opt, opt, sizeof(struct ip_options)+opt->optlen);
 			inet->cork.flags |= IPCORK_OPT;
 			inet->cork.addr = ipc->addr;
diff -purN linux-post-2.6.4rc2-20040309/net/ipv6/addrconf.c linux-post-2.6.4rc3-20040310/net/ipv6/addrconf.c
--- linux-post-2.6.4rc2-20040309/net/ipv6/addrconf.c	2004-02-21 21:16:31.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/ipv6/addrconf.c	2004-03-09 23:26:35.000000000 +0000
@@ -2673,26 +2673,6 @@ static int inet6_dump_ifaddr(struct sk_b
 				goto done;
 		}
 #endif
-		/* multicast address */
-		for (ifmca = idev->mc_list; ifmca; 
-		     ifmca = ifmca->next, ip_idx++) {
-			if (ip_idx < s_ip_idx)
-				continue;
-			if ((err = inet6_fill_ifmcaddr(skb, ifmca, 
-			    NETLINK_CB(cb->skb).pid, 
-			    cb->nlh->nlmsg_seq, RTM_NEWADDR)) <= 0) 
-				goto done;
-		}
-		/* anycast address */
-		for (ifaca = idev->ac_list; ifaca;
-		     ifaca = ifaca->aca_next, ip_idx++) {
-			if (ip_idx < s_ip_idx)
-				continue;
-			if ((err = inet6_fill_ifacaddr(skb, ifaca, 
-			    NETLINK_CB(cb->skb).pid, 
-			    cb->nlh->nlmsg_seq, RTM_NEWADDR)) <= 0) 
-				goto done;
-		}
 		read_unlock_bh(&idev->lock);
 		in6_dev_put(idev);
 	}
diff -purN linux-post-2.6.4rc2-20040309/net/ipv6/esp6.c linux-post-2.6.4rc3-20040310/net/ipv6/esp6.c
--- linux-post-2.6.4rc2-20040309/net/ipv6/esp6.c	2003-08-18 11:14:38.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/ipv6/esp6.c	2004-03-09 23:21:50.000000000 +0000
@@ -422,6 +422,8 @@ int esp6_init_state(struct xfrm_state *x
 	esp->conf.padlen = 0;
 	if (esp->conf.ivlen) {
 		esp->conf.ivec = kmalloc(esp->conf.ivlen, GFP_KERNEL);
+		if (unlikely(esp->conf.ivec == NULL))
+			goto error;
 		get_random_bytes(esp->conf.ivec, esp->conf.ivlen);
 	}
 	crypto_cipher_setkey(esp->conf.tfm, esp->conf.key, esp->conf.key_len);
diff -purN linux-post-2.6.4rc2-20040309/net/ipv6/ip6_output.c linux-post-2.6.4rc3-20040310/net/ipv6/ip6_output.c
--- linux-post-2.6.4rc2-20040309/net/ipv6/ip6_output.c	2004-02-09 19:13:09.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/ipv6/ip6_output.c	2004-03-09 23:21:50.000000000 +0000
@@ -816,9 +816,12 @@ int ip6_append_data(struct sock *sk, int
 		 * setup for corking
 		 */
 		if (opt) {
-			if (np->cork.opt == NULL)
+			if (np->cork.opt == NULL) {
 				np->cork.opt = kmalloc(opt->tot_len,
 						       sk->sk_allocation);
+				if (unlikely(np->cork.opt == NULL))
+					return -ENOBUFS;
+			}
 			memcpy(np->cork.opt, opt, opt->tot_len);
 			inet->cork.flags |= IPCORK_OPT;
 			/* need source address above miyazawa*/
diff -purN linux-post-2.6.4rc2-20040309/net/irda/Makefile linux-post-2.6.4rc3-20040310/net/irda/Makefile
--- linux-post-2.6.4rc2-20040309/net/irda/Makefile	2003-02-03 22:19:39.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/Makefile	2004-03-09 21:39:26.000000000 +0000
@@ -10,6 +10,6 @@ obj-$(CONFIG_IRCOMM) += ircomm/
 irda-y := iriap.o iriap_event.o irlmp.o irlmp_event.o irlmp_frame.o \
           irlap.o irlap_event.o irlap_frame.o timer.o qos.o irqueue.o \
           irttp.o irda_device.o irias_object.o crc.o wrapper.o af_irda.o \
-	  discovery.o parameters.o irsyms.o
+	  discovery.o parameters.o irmod.o
 irda-$(CONFIG_PROC_FS) += irproc.o
 irda-$(CONFIG_SYSCTL) += irsysctl.o
diff -purN linux-post-2.6.4rc2-20040309/net/irda/crc.c linux-post-2.6.4rc3-20040310/net/irda/crc.c
--- linux-post-2.6.4rc2-20040309/net/irda/crc.c	2002-10-11 17:29:10.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/crc.c	2004-03-09 21:34:16.000000000 +0000
@@ -14,6 +14,7 @@
  ********************************************************************/
 
 #include <net/irda/crc.h>
+#include <linux/module.h>
 
 /*
  * This mysterious table is just the CRC of each possible byte.  It can be
@@ -56,10 +57,12 @@ __u16 const irda_crc16_table[256] =
 	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
 	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
 };
+EXPORT_SYMBOL(irda_crc16_table);
 
-unsigned short irda_calc_crc16( __u16 fcs, __u8 const *buf, size_t len) 
+__u16 irda_calc_crc16( __u16 fcs, __u8 const *buf, size_t len) 
 {
 	while (len--)
                 fcs = irda_fcs(fcs, *buf++);
 	return fcs;
 }
+EXPORT_SYMBOL(irda_calc_crc16);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irda_device.c linux-post-2.6.4rc3-20040310/net/irda/irda_device.c
--- linux-post-2.6.4rc2-20040309/net/irda/irda_device.c	2004-02-26 20:31:07.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irda_device.c	2004-03-09 21:36:17.000000000 +0000
@@ -140,6 +140,8 @@ void irda_device_set_media_busy(struct n
 		irlap_stop_mbusy_timer(self);
 	}
 }
+EXPORT_SYMBOL(irda_device_set_media_busy);
+
 
 int irda_device_set_dtr_rts(struct net_device *dev, int dtr, int rts)
 {
@@ -214,6 +216,7 @@ void irda_task_next_state(struct irda_ta
 
 	task->state = state;
 }
+EXPORT_SYMBOL(irda_task_next_state);
 
 static void __irda_task_delete(struct irda_task *task)
 {
@@ -320,7 +323,6 @@ struct irda_task *irda_task_execute(void
 				    struct irda_task *parent, void *param)
 {
 	struct irda_task *task;
-	int ret;
 
 	IRDA_DEBUG(2, "%s()\n", __FUNCTION__);
 
@@ -342,12 +344,9 @@ struct irda_task *irda_task_execute(void
 	hashbin_insert(tasks, (irda_queue_t *) task, (long) task, NULL);
 
 	/* No time to waste, so lets get going! */
-	ret = irda_task_kick(task);
-	if (ret)
-		return NULL;
-	else
-		return task;
+	return irda_task_kick(task) ? NULL : task;
 }
+EXPORT_SYMBOL(irda_task_execute);
 
 /*
  * Function irda_task_timer_expired (data)
@@ -395,6 +394,7 @@ struct net_device *alloc_irdadev(int siz
 {
 	return alloc_netdev(sizeof_priv, "irda%d", irda_device_setup);
 }
+EXPORT_SYMBOL(alloc_irdadev);
 
 /*
  * Function irda_device_init_dongle (self, type, qos)
@@ -446,6 +446,7 @@ dongle_t *irda_device_dongle_init(struct
 	spin_unlock(&dongles->hb_spinlock);
 	return dongle;
 }
+EXPORT_SYMBOL(irda_device_dongle_init);
 
 /*
  * Function irda_device_dongle_cleanup (dongle)
@@ -460,6 +461,7 @@ int irda_device_dongle_cleanup(dongle_t 
 
 	return 0;
 }
+EXPORT_SYMBOL(irda_device_dongle_cleanup);
 
 /*
  * Function irda_device_register_dongle (dongle)
@@ -479,6 +481,7 @@ int irda_device_register_dongle(struct d
 
         return 0;
 }
+EXPORT_SYMBOL(irda_device_register_dongle);
 
 /*
  * Function irda_device_unregister_dongle (dongle)
@@ -496,6 +499,7 @@ void irda_device_unregister_dongle(struc
 		ERROR("%s: dongle not found!\n", __FUNCTION__);
 	spin_unlock(&dongles->hb_spinlock);
 }
+EXPORT_SYMBOL(irda_device_unregister_dongle);
 
 /*
  * Function irda_device_set_mode (self, mode)
diff -purN linux-post-2.6.4rc2-20040309/net/irda/iriap.c linux-post-2.6.4rc3-20040310/net/irda/iriap.c
--- linux-post-2.6.4rc2-20040309/net/irda/iriap.c	2003-11-05 20:51:33.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/iriap.c	2004-03-09 21:32:34.000000000 +0000
@@ -25,6 +25,7 @@
  ********************************************************************/
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/skbuff.h>
 #include <linux/string.h>
@@ -61,8 +62,6 @@ static const char *ias_charset_types[] =
 static hashbin_t *iriap = NULL;
 static void *service_handle;
 
-extern char *lmp_reasons[];
-
 static void __iriap_close(struct iriap_cb *self);
 static int iriap_register_lsap(struct iriap_cb *self, __u8 slsap_sel, int mode);
 static void iriap_disconnect_indication(void *instance, void *sap,
@@ -200,6 +199,7 @@ struct iriap_cb *iriap_open(__u8 slsap_s
 
 	return self;
 }
+EXPORT_SYMBOL(iriap_open);
 
 /*
  * Function __iriap_close (self)
@@ -248,6 +248,7 @@ void iriap_close(struct iriap_cb *self)
 
 	__iriap_close(self);
 }
+EXPORT_SYMBOL(iriap_close);
 
 static int iriap_register_lsap(struct iriap_cb *self, __u8 slsap_sel, int mode)
 {
@@ -288,7 +289,7 @@ static void iriap_disconnect_indication(
 {
 	struct iriap_cb *self;
 
-	IRDA_DEBUG(4, "%s(), reason=%s\n", __FUNCTION__, lmp_reasons[reason]);
+	IRDA_DEBUG(4, "%s(), reason=%s\n", __FUNCTION__, irlmp_reasons[reason]);
 
 	self = (struct iriap_cb *) instance;
 
@@ -435,6 +436,7 @@ int iriap_getvaluebyclass_request(struct
 
 	return 0;
 }
+EXPORT_SYMBOL(iriap_getvaluebyclass_request);
 
 /*
  * Function iriap_getvaluebyclass_confirm (self, skb)
@@ -674,7 +676,7 @@ void iriap_getvaluebyclass_indication(st
 	if (obj == NULL) {
 		IRDA_DEBUG(2, "LM-IAS: Object %s not found\n", name);
 		iriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,
-					       &missing);
+					       &irias_missing);
 		return;
 	}
 	IRDA_DEBUG(4, "LM-IAS: found %s, id=%d\n", obj->name, obj->id);
@@ -683,7 +685,8 @@ void iriap_getvaluebyclass_indication(st
 	if (attrib == NULL) {
 		IRDA_DEBUG(2, "LM-IAS: Attribute %s not found\n", attr);
 		iriap_getvaluebyclass_response(self, obj->id,
-					       IAS_ATTRIB_UNKNOWN, &missing);
+					       IAS_ATTRIB_UNKNOWN, 
+					       &irias_missing);
 		return;
 	}
 
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irias_object.c linux-post-2.6.4rc3-20040310/net/irda/irias_object.c
--- linux-post-2.6.4rc2-20040309/net/irda/irias_object.c	2003-09-04 18:46:24.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irias_object.c	2004-03-09 21:31:48.000000000 +0000
@@ -24,6 +24,7 @@
 
 #include <linux/string.h>
 #include <linux/socket.h>
+#include <linux/module.h>
 
 #include <net/irda/irda.h>
 #include <net/irda/irias_object.h>
@@ -33,7 +34,7 @@ hashbin_t *irias_objects;
 /*
  *  Used when a missing value needs to be returned
  */
-struct ias_value missing = { IAS_MISSING, 0, 0, 0, {0}};
+struct ias_value irias_missing = { IAS_MISSING, 0, 0, 0, {0}};
 
 /*
  * Function strndup (str, max)
@@ -107,6 +108,7 @@ struct ias_object *irias_new_object( cha
 
 	return obj;
 }
+EXPORT_SYMBOL(irias_new_object);
 
 /*
  * Function irias_delete_attrib (attrib)
@@ -165,6 +167,7 @@ int irias_delete_object(struct ias_objec
 
 	return 0;
 }
+EXPORT_SYMBOL(irias_delete_object);
 
 /*
  * Function irias_delete_attrib (obj)
@@ -210,6 +213,7 @@ void irias_insert_object(struct ias_obje
 
 	hashbin_insert(irias_objects, (irda_queue_t *) obj, 0, obj->name);
 }
+EXPORT_SYMBOL(irias_insert_object);
 
 /*
  * Function irias_find_object (name)
@@ -224,6 +228,7 @@ struct ias_object *irias_find_object(cha
 	/* Unsafe (locking), object might change */
 	return hashbin_lock_find(irias_objects, 0, name);
 }
+EXPORT_SYMBOL(irias_find_object);
 
 /*
  * Function irias_find_attrib (obj, name)
@@ -246,6 +251,7 @@ struct ias_attrib *irias_find_attrib(str
 	/* Unsafe (locking), attrib might change */
 	return attrib;
 }
+EXPORT_SYMBOL(irias_find_attrib);
 
 /*
  * Function irias_add_attribute (obj, attrib)
@@ -318,6 +324,7 @@ int irias_object_change_attribute(char *
 	spin_unlock_irqrestore(&obj->attribs->hb_spinlock, flags);
 	return 0;
 }
+EXPORT_SYMBOL(irias_object_change_attribute);
 
 /*
  * Function irias_object_add_integer_attrib (obj, name, value)
@@ -350,6 +357,7 @@ void irias_add_integer_attrib(struct ias
 
 	irias_add_attrib(obj, attrib, owner);
 }
+EXPORT_SYMBOL(irias_add_integer_attrib);
 
  /*
  * Function irias_add_octseq_attrib (obj, name, octet_seq, len)
@@ -384,6 +392,7 @@ void irias_add_octseq_attrib(struct ias_
 
 	irias_add_attrib(obj, attrib, owner);
 }
+EXPORT_SYMBOL(irias_add_octseq_attrib);
 
 /*
  * Function irias_object_add_string_attrib (obj, string)
@@ -417,6 +426,7 @@ void irias_add_string_attrib(struct ias_
 
 	irias_add_attrib(obj, attrib, owner);
 }
+EXPORT_SYMBOL(irias_add_string_attrib);
 
 /*
  * Function irias_new_integer_value (integer)
@@ -441,6 +451,7 @@ struct ias_value *irias_new_integer_valu
 
 	return value;
 }
+EXPORT_SYMBOL(irias_new_integer_value);
 
 /*
  * Function irias_new_string_value (string)
@@ -467,7 +478,7 @@ struct ias_value *irias_new_string_value
 
 	return value;
 }
-
+EXPORT_SYMBOL(irias_new_string_value);
 
 /*
  * Function irias_new_octseq_value (octets, len)
@@ -502,6 +513,7 @@ struct ias_value *irias_new_octseq_value
 	memcpy(value->t.oct_seq, octseq , len);
 	return value;
 }
+EXPORT_SYMBOL(irias_new_octseq_value);
 
 struct ias_value *irias_new_missing_value(void)
 {
@@ -553,3 +565,4 @@ void irias_delete_value(struct ias_value
 	}
 	kfree(value);
 }
+EXPORT_SYMBOL(irias_delete_value);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irlap.c linux-post-2.6.4rc3-20040310/net/irda/irlap.c
--- linux-post-2.6.4rc2-20040309/net/irda/irlap.c	2003-11-05 20:51:33.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irlap.c	2004-03-09 21:35:20.000000000 +0000
@@ -37,6 +37,7 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/random.h>
+#include <linux/module.h>
 #include <linux/seq_file.h>
 
 #include <net/irda/irda.h>
@@ -173,6 +174,7 @@ struct irlap_cb *irlap_open(struct net_d
 
 	return self;
 }
+EXPORT_SYMBOL(irlap_open);
 
 /*
  * Function __irlap_close (self)
@@ -233,6 +235,7 @@ void irlap_close(struct irlap_cb *self)
 	}
 	__irlap_close(lap);
 }
+EXPORT_SYMBOL(irlap_close);
 
 /*
  * Function irlap_connect_indication (self, skb)
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irlmp.c linux-post-2.6.4rc3-20040310/net/irda/irlmp.c
--- linux-post-2.6.4rc2-20040309/net/irda/irlmp.c	2004-02-10 02:32:48.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irlmp.c	2004-03-09 21:32:34.000000000 +0000
@@ -25,6 +25,7 @@
  ********************************************************************/
 
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/skbuff.h>
@@ -49,11 +50,12 @@ struct irlmp_cb *irlmp = NULL;
 /* These can be altered by the sysctl interface */
 int  sysctl_discovery         = 0;
 int  sysctl_discovery_timeout = 3; /* 3 seconds by default */
+EXPORT_SYMBOL(sysctl_discovery_timeout);
 int  sysctl_discovery_slots   = 6; /* 6 slots by default */
 int  sysctl_lap_keepalive_time = LM_IDLE_TIMEOUT * 1000 / HZ;
 char sysctl_devname[65];
 
-char *lmp_reasons[] = {
+const char *irlmp_reasons[] = {
 	"ERROR, NOT USED",
 	"LM_USER_REQUEST",
 	"LM_LAP_DISCONNECT",
@@ -62,8 +64,7 @@ char *lmp_reasons[] = {
 	"LM_INIT_DISCONNECT",
 	"ERROR, NOT USED",
 };
-
-__u8 *irlmp_hint_to_service(__u8 *hint);
+EXPORT_SYMBOL(irlmp_reasons);
 
 /*
  * Function irlmp_init (void)
@@ -189,6 +190,7 @@ struct lsap_cb *irlmp_open_lsap(__u8 sls
 
 	return self;
 }
+EXPORT_SYMBOL(irlmp_open_lsap);
 
 /*
  * Function __irlmp_close_lsap (self)
@@ -264,6 +266,7 @@ void irlmp_close_lsap(struct lsap_cb *se
 	}
 	__irlmp_close_lsap(self);
 }
+EXPORT_SYMBOL(irlmp_close_lsap);
 
 /*
  * Function irlmp_register_irlap (saddr, notify)
@@ -496,6 +499,7 @@ err:
 		dev_kfree_skb(tx_skb);
 	return ret;
 }
+EXPORT_SYMBOL(irlmp_connect_request);
 
 /*
  * Function irlmp_connect_indication (self)
@@ -569,6 +573,7 @@ int irlmp_connect_response(struct lsap_c
 
 	return 0;
 }
+EXPORT_SYMBOL(irlmp_connect_response);
 
 /*
  * Function irlmp_connect_confirm (handle, skb)
@@ -667,6 +672,7 @@ struct lsap_cb *irlmp_dup(struct lsap_cb
 
 	return new;
 }
+EXPORT_SYMBOL(irlmp_dup);
 
 /*
  * Function irlmp_disconnect_request (handle, userdata)
@@ -729,6 +735,7 @@ int irlmp_disconnect_request(struct lsap
 
 	return 0;
 }
+EXPORT_SYMBOL(irlmp_disconnect_request);
 
 /*
  * Function irlmp_disconnect_indication (reason, userdata)
@@ -740,7 +747,7 @@ void irlmp_disconnect_indication(struct 
 {
 	struct lsap_cb *lsap;
 
-	IRDA_DEBUG(1, "%s(), reason=%s\n", __FUNCTION__, lmp_reasons[reason]);
+	IRDA_DEBUG(1, "%s(), reason=%s\n", __FUNCTION__, irlmp_reasons[reason]);
 	ASSERT(self != NULL, return;);
 	ASSERT(self->magic == LMP_LSAP_MAGIC, return;);
 
@@ -900,6 +907,7 @@ void irlmp_discovery_request(int nslots)
 		 * Jean II */
 	}
 }
+EXPORT_SYMBOL(irlmp_discovery_request);
 
 /*
  * Function irlmp_get_discoveries (pn, mask, slots)
@@ -931,6 +939,7 @@ struct irda_device_info *irlmp_get_disco
 	/* Return current cached discovery log */
 	return(irlmp_copy_discoveries(irlmp->cachelog, pn, mask, TRUE));
 }
+EXPORT_SYMBOL(irlmp_get_discoveries);
 
 /*
  * Function irlmp_notify_client (log)
@@ -1122,6 +1131,7 @@ int irlmp_data_request(struct lsap_cb *s
 
 	return ret;
 }
+EXPORT_SYMBOL(irlmp_data_request);
 
 /*
  * Function irlmp_data_indication (handle, skb)
@@ -1433,7 +1443,7 @@ __u8 *irlmp_hint_to_service(__u8 *hint)
 }
 #endif
 
-const __u16 service_hint_mapping[S_END][2] = {
+static const __u16 service_hint_mapping[S_END][2] = {
 	{ HINT_PNP,		0 },			/* S_PNP */
 	{ HINT_PDA,		0 },			/* S_PDA */
 	{ HINT_COMPUTER,	0 },			/* S_COMPUTER */
@@ -1463,6 +1473,7 @@ __u16 irlmp_service_to_hint(int service)
 
 	return hint.word;
 }
+EXPORT_SYMBOL(irlmp_service_to_hint);
 
 /*
  * Function irlmp_register_service (service)
@@ -1490,6 +1501,7 @@ void *irlmp_register_service(__u16 hints
 
 	return (void *)service;
 }
+EXPORT_SYMBOL(irlmp_register_service);
 
 /*
  * Function irlmp_unregister_service (handle)
@@ -1532,6 +1544,7 @@ int irlmp_unregister_service(void *handl
 	spin_unlock_irqrestore(&irlmp->services->hb_spinlock, flags);
 	return 0;
 }
+EXPORT_SYMBOL(irlmp_unregister_service);
 
 /*
  * Function irlmp_register_client (hint_mask, callback1, callback2)
@@ -1568,6 +1581,7 @@ void *irlmp_register_client(__u16 hint_m
 
 	return (void *) client;
 }
+EXPORT_SYMBOL(irlmp_register_client);
 
 /*
  * Function irlmp_update_client (handle, hint_mask, callback1, callback2)
@@ -1599,6 +1613,7 @@ int irlmp_update_client(void *handle, __
 
 	return 0;
 }
+EXPORT_SYMBOL(irlmp_update_client);
 
 /*
  * Function irlmp_unregister_client (handle)
@@ -1628,6 +1643,7 @@ int irlmp_unregister_client(void *handle
 
 	return 0;
 }
+EXPORT_SYMBOL(irlmp_unregister_client);
 
 /*
  * Function irlmp_slsap_inuse (slsap)
@@ -1765,22 +1781,6 @@ LM_REASON irlmp_convert_lap_reason( LAP_
 	return reason;
 }
 
-__u32 irlmp_get_saddr(struct lsap_cb *self)
-{
-	ASSERT(self != NULL, return 0;);
-	ASSERT(self->lap != NULL, return 0;);
-
-	return self->lap->saddr;
-}
-
-__u32 irlmp_get_daddr(struct lsap_cb *self)
-{
-	ASSERT(self != NULL, return 0;);
-	ASSERT(self->lap != NULL, return 0;);
-
-	return self->lap->daddr;
-}
-
 #ifdef CONFIG_PROC_FS
 
 struct irlmp_iter_state {
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irmod.c linux-post-2.6.4rc3-20040310/net/irda/irmod.c
--- linux-post-2.6.4rc2-20040309/net/irda/irmod.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irmod.c	2004-03-09 21:39:16.000000000 +0000
@@ -0,0 +1,185 @@
+/*********************************************************************
+ *                
+ * Filename:      irmod.c
+ * Version:       0.9
+ * Description:   IrDA stack main entry points
+ * Status:        Experimental.
+ * Author:        Dag Brattli <dagb@cs.uit.no>
+ * Created at:    Mon Dec 15 13:55:39 1997
+ * Modified at:   Wed Jan  5 15:12:41 2000
+ * Modified by:   Dag Brattli <dagb@cs.uit.no>
+ * 
+ *     Copyright (c) 1997, 1999-2000 Dag Brattli, All Rights Reserved.
+ *     Copyright (c) 2000-2004 Jean Tourrilhes <jt@hpl.hp.com>
+ *      
+ *     This program is free software; you can redistribute it and/or 
+ *     modify it under the terms of the GNU General Public License as 
+ *     published by the Free Software Foundation; either version 2 of 
+ *     the License, or (at your option) any later version.
+ *  
+ *     Neither Dag Brattli nor University of Troms admit liability nor
+ *     provide warranty for any of this software. This material is 
+ *     provided "AS-IS" and at no charge.
+ *     
+ ********************************************************************/
+
+/*
+ * This file contains the main entry points of the IrDA stack.
+ * They are in this file and not af_irda.c because some developpers
+ * are using the IrDA stack without the socket API (compiling out
+ * af_irda.c).
+ * Jean II
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include <net/irda/irda.h>
+#include <net/irda/irmod.h>		/* notify_t */
+#include <net/irda/irlap.h>		/* irlap_init */
+#include <net/irda/irlmp.h>		/* irlmp_init */
+#include <net/irda/iriap.h>		/* iriap_init */
+#include <net/irda/irttp.h>		/* irttp_init */
+#include <net/irda/irda_device.h>	/* irda_device_init */
+
+/* irproc.c */
+extern void irda_proc_register(void);
+extern void irda_proc_unregister(void);
+/* irsysctl.c */
+extern int  irda_sysctl_register(void);
+extern void irda_sysctl_unregister(void);
+/* af_irda.c */
+extern int  irsock_init(void);
+extern void irsock_cleanup(void);
+/* irlap_frame.c */
+extern int  irlap_driver_rcv(struct sk_buff *, struct net_device *, 
+			     struct packet_type *);
+
+/*
+ * Module parameters
+ */
+#ifdef CONFIG_IRDA_DEBUG
+unsigned int irda_debug = IRDA_DEBUG_LEVEL;
+module_param_named(debug, irda_debug, uint, 0);
+MODULE_PARM_DESC(irda_debug, "IRDA debugging level");
+EXPORT_SYMBOL(irda_debug);
+#endif
+
+/* Packet type handler.
+ * Tell the kernel how IrDA packets should be handled.
+ */
+static struct packet_type irda_packet_type = {
+	.type	= __constant_htons(ETH_P_IRDA),
+	.func	= irlap_driver_rcv,	/* Packet type handler irlap_frame.c */
+};
+
+/*
+ * Function irda_notify_init (notify)
+ *
+ *    Used for initializing the notify structure
+ *
+ */
+void irda_notify_init(notify_t *notify)
+{
+	notify->data_indication = NULL;
+	notify->udata_indication = NULL;
+	notify->connect_confirm = NULL;
+	notify->connect_indication = NULL;
+	notify->disconnect_indication = NULL;
+	notify->flow_indication = NULL;
+	notify->status_indication = NULL;
+	notify->instance = NULL;
+	strlcpy(notify->name, "Unknown", sizeof(notify->name));
+}
+EXPORT_SYMBOL(irda_notify_init);
+
+/*
+ * Function irda_init (void)
+ *
+ *  Protocol stack initialisation entry point.
+ *  Initialise the various components of the IrDA stack
+ */
+int __init irda_init(void)
+{
+	IRDA_DEBUG(0, "%s()\n", __FUNCTION__);
+
+	/* Lower layer of the stack */
+ 	irlmp_init();
+	irlap_init();
+	
+	/* Higher layers of the stack */
+	iriap_init();
+ 	irttp_init();
+	irsock_init();
+	
+	/* Add IrDA packet type (Start receiving packets) */
+        dev_add_pack(&irda_packet_type);
+
+	/* External APIs */
+#ifdef CONFIG_PROC_FS
+	irda_proc_register();
+#endif
+#ifdef CONFIG_SYSCTL
+	irda_sysctl_register();
+#endif
+
+	/* Driver/dongle support */
+ 	irda_device_init();
+
+	return 0;
+}
+
+/*
+ * Function irda_cleanup (void)
+ *
+ *  Protocol stack cleanup/removal entry point.
+ *  Cleanup the various components of the IrDA stack
+ */
+void __exit irda_cleanup(void)
+{
+	/* Remove External APIs */
+#ifdef CONFIG_SYSCTL
+	irda_sysctl_unregister();
+#endif	
+#ifdef CONFIG_PROC_FS
+	irda_proc_unregister();
+#endif
+
+	/* Remove IrDA packet type (stop receiving packets) */
+        dev_remove_pack(&irda_packet_type);
+	
+	/* Remove higher layers */
+	irsock_cleanup();
+	irttp_cleanup();
+	iriap_cleanup();
+
+	/* Remove lower layers */
+	irda_device_cleanup();
+	irlap_cleanup(); /* Must be done before irlmp_cleanup()! DB */
+
+	/* Remove middle layer */
+	irlmp_cleanup();
+}
+
+/*
+ * The IrDA stack must be initialised *before* drivers get initialised,
+ * and *before* higher protocols (IrLAN/IrCOMM/IrNET) get initialised,
+ * otherwise bad things will happen (hashbins will be NULL for example).
+ * Those modules are at module_init()/device_initcall() level.
+ *
+ * On the other hand, it needs to be initialised *after* the basic
+ * networking, the /proc/net filesystem and sysctl module. Those are
+ * currently initialised in .../init/main.c (before initcalls).
+ * Also, IrDA drivers needs to be initialised *after* the random number
+ * generator (main stack and higher layer init don't need it anymore).
+ *
+ * Jean II
+ */
+subsys_initcall(irda_init);
+module_exit(irda_cleanup);
+ 
+MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no> & Jean Tourrilhes <jt@hpl.hp.com>");
+MODULE_DESCRIPTION("The Linux IrDA Protocol Stack"); 
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(PF_IRDA);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irproc.c linux-post-2.6.4rc3-20040310/net/irda/irproc.c
--- linux-post-2.6.4rc2-20040309/net/irda/irproc.c	2003-09-20 07:48:35.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irproc.c	2004-03-09 21:22:58.000000000 +0000
@@ -45,6 +45,7 @@ struct irda_entry {
 };
 
 struct proc_dir_entry *proc_irda;
+EXPORT_SYMBOL(proc_irda);
  
 static struct irda_entry irda_dirs[] = {
 	{"discovery",	&discovery_seq_fops},
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irqueue.c linux-post-2.6.4rc3-20040310/net/irda/irqueue.c
--- linux-post-2.6.4rc2-20040309/net/irda/irqueue.c	2004-02-26 20:30:14.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irqueue.c	2004-03-09 21:30:35.000000000 +0000
@@ -191,6 +191,7 @@
  *
  * Jean II
  */
+#include <linux/module.h>
 
 #include <net/irda/irda.h>
 #include <net/irda/irqueue.h>
@@ -374,6 +375,7 @@ hashbin_t *hashbin_new(int type)
 
 	return hashbin;
 }
+EXPORT_SYMBOL(hashbin_new);
 
 
 /*
@@ -427,6 +429,7 @@ int hashbin_delete( hashbin_t* hashbin, 
 
 	return 0;
 }
+EXPORT_SYMBOL(hashbin_delete);
 
 /********************* HASHBIN LIST OPERATIONS *********************/
 
@@ -478,6 +481,7 @@ void hashbin_insert(hashbin_t* hashbin, 
 		spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
 	} /* Default is no-lock  */
 }
+EXPORT_SYMBOL(hashbin_insert);
 
 /* 
  *  Function hashbin_remove_first (hashbin)
@@ -628,6 +632,7 @@ void* hashbin_remove( hashbin_t* hashbin
 		return NULL;
 	
 }
+EXPORT_SYMBOL(hashbin_remove);
 
 /* 
  *  Function hashbin_remove_this (hashbin, entry)
@@ -690,6 +695,7 @@ void* hashbin_remove_this( hashbin_t* ha
 
 	return entry;
 }
+EXPORT_SYMBOL(hashbin_remove_this);
 
 /*********************** HASHBIN ENUMERATION ***********************/
 
@@ -743,6 +749,7 @@ void* hashbin_find( hashbin_t* hashbin, 
 
 	return NULL;
 }
+EXPORT_SYMBOL(hashbin_find);
 
 /*
  * Function hashbin_lock_find (hashbin, hashv, name)
@@ -771,6 +778,7 @@ void* hashbin_lock_find( hashbin_t* hash
 
 	return entry;
 }
+EXPORT_SYMBOL(hashbin_lock_find);
 
 /*
  * Function hashbin_find (hashbin, hashv, name, pnext)
@@ -812,6 +820,7 @@ void* hashbin_find_next( hashbin_t* hash
 
 	return entry;
 }
+EXPORT_SYMBOL(hashbin_find_next);
 
 /*
  * Function hashbin_get_first (hashbin)
@@ -843,6 +852,7 @@ irda_queue_t *hashbin_get_first( hashbin
 	 */
 	return NULL;
 }
+EXPORT_SYMBOL(hashbin_get_first);
 
 /*
  * Function hashbin_get_next (hashbin)
@@ -900,3 +910,4 @@ irda_queue_t *hashbin_get_next( hashbin_
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(hashbin_get_next);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irsyms.c linux-post-2.6.4rc3-20040310/net/irda/irsyms.c
--- linux-post-2.6.4rc2-20040309/net/irda/irsyms.c	2004-02-26 20:29:04.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irsyms.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,300 +0,0 @@
-/*********************************************************************
- *                
- * Filename:      irsyms.c
- * Version:       0.9
- * Description:   IrDA module symbols
- * Status:        Experimental.
- * Author:        Dag Brattli <dagb@cs.uit.no>
- * Created at:    Mon Dec 15 13:55:39 1997
- * Modified at:   Wed Jan  5 15:12:41 2000
- * Modified by:   Dag Brattli <dagb@cs.uit.no>
- * 
- *     Copyright (c) 1997, 1999-2000 Dag Brattli, All Rights Reserved.
- *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
- *      
- *     This program is free software; you can redistribute it and/or 
- *     modify it under the terms of the GNU General Public License as 
- *     published by the Free Software Foundation; either version 2 of 
- *     the License, or (at your option) any later version.
- *  
- *     Neither Dag Brattli nor University of Troms admit liability nor
- *     provide warranty for any of this software. This material is 
- *     provided "AS-IS" and at no charge.
- *     
- ********************************************************************/
-
-#include <linux/config.h>
-#include <linux/module.h>
-
-#include <linux/init.h>
-#include <linux/poll.h>
-#include <linux/proc_fs.h>
-#include <linux/smp_lock.h>
-#include <linux/if_arp.h>		/* ARPHRD_IRDA */
-
-#include <net/irda/irda.h>
-#include <net/irda/irlap.h>
-#include <net/irda/irlmp.h>
-#include <net/irda/iriap.h>
-#include <net/irda/irias_object.h>
-#include <net/irda/irttp.h>
-#include <net/irda/irda_device.h>
-#include <net/irda/wrapper.h>
-#include <net/irda/timer.h>
-#include <net/irda/parameters.h>
-#include <net/irda/crc.h>
-
-extern struct proc_dir_entry *proc_irda;
-
-extern void irda_proc_register(void);
-extern void irda_proc_unregister(void);
-extern int  irda_sysctl_register(void);
-extern void irda_sysctl_unregister(void);
-
-extern int irda_proto_init(void);
-extern void irda_proto_cleanup(void);
-
-extern int irda_device_init(void);
-extern int irlan_init(void);
-extern int irlan_client_init(void);
-extern int irlan_server_init(void);
-extern int ircomm_init(void);
-extern int ircomm_tty_init(void);
-extern int irlpt_client_init(void);
-extern int irlpt_server_init(void);
-
-extern int  irsock_init(void);
-extern void irsock_cleanup(void);
-extern int  irlap_driver_rcv(struct sk_buff *, struct net_device *, 
-			     struct packet_type *);
-
-/* IrTTP */
-EXPORT_SYMBOL(irttp_open_tsap);
-EXPORT_SYMBOL(irttp_close_tsap);
-EXPORT_SYMBOL(irttp_connect_response);
-EXPORT_SYMBOL(irttp_data_request);
-EXPORT_SYMBOL(irttp_disconnect_request);
-EXPORT_SYMBOL(irttp_flow_request);
-EXPORT_SYMBOL(irttp_connect_request);
-EXPORT_SYMBOL(irttp_udata_request);
-EXPORT_SYMBOL(irttp_dup);
-
-/* Main IrDA module */
-#ifdef CONFIG_IRDA_DEBUG
-EXPORT_SYMBOL(irda_debug);
-#endif
-EXPORT_SYMBOL(irda_notify_init);
-#ifdef CONFIG_PROC_FS
-EXPORT_SYMBOL(proc_irda);
-#endif
-EXPORT_SYMBOL(irda_param_insert);
-EXPORT_SYMBOL(irda_param_extract);
-EXPORT_SYMBOL(irda_param_extract_all);
-EXPORT_SYMBOL(irda_param_pack);
-EXPORT_SYMBOL(irda_param_unpack);
-
-/* IrIAP/IrIAS */
-EXPORT_SYMBOL(iriap_open);
-EXPORT_SYMBOL(iriap_close);
-EXPORT_SYMBOL(iriap_getvaluebyclass_request);
-EXPORT_SYMBOL(irias_object_change_attribute);
-EXPORT_SYMBOL(irias_add_integer_attrib);
-EXPORT_SYMBOL(irias_add_octseq_attrib);
-EXPORT_SYMBOL(irias_add_string_attrib);
-EXPORT_SYMBOL(irias_insert_object);
-EXPORT_SYMBOL(irias_new_object);
-EXPORT_SYMBOL(irias_delete_object);
-EXPORT_SYMBOL(irias_delete_value);
-EXPORT_SYMBOL(irias_find_object);
-EXPORT_SYMBOL(irias_find_attrib);
-EXPORT_SYMBOL(irias_new_integer_value);
-EXPORT_SYMBOL(irias_new_string_value);
-EXPORT_SYMBOL(irias_new_octseq_value);
-
-/* IrLMP */
-EXPORT_SYMBOL(irlmp_discovery_request);
-EXPORT_SYMBOL(irlmp_get_discoveries);
-EXPORT_SYMBOL(sysctl_discovery_timeout);
-EXPORT_SYMBOL(irlmp_register_client);
-EXPORT_SYMBOL(irlmp_unregister_client);
-EXPORT_SYMBOL(irlmp_update_client);
-EXPORT_SYMBOL(irlmp_register_service);
-EXPORT_SYMBOL(irlmp_unregister_service);
-EXPORT_SYMBOL(irlmp_service_to_hint);
-EXPORT_SYMBOL(irlmp_data_request);
-EXPORT_SYMBOL(irlmp_open_lsap);
-EXPORT_SYMBOL(irlmp_close_lsap);
-EXPORT_SYMBOL(irlmp_connect_request);
-EXPORT_SYMBOL(irlmp_connect_response);
-EXPORT_SYMBOL(irlmp_disconnect_request);
-EXPORT_SYMBOL(irlmp_get_daddr);
-EXPORT_SYMBOL(irlmp_get_saddr);
-EXPORT_SYMBOL(irlmp_dup);
-EXPORT_SYMBOL(lmp_reasons);
-
-/* Queue */
-EXPORT_SYMBOL(hashbin_new);
-EXPORT_SYMBOL(hashbin_insert);
-EXPORT_SYMBOL(hashbin_delete);
-EXPORT_SYMBOL(hashbin_remove);
-EXPORT_SYMBOL(hashbin_remove_this);
-EXPORT_SYMBOL(hashbin_find);
-EXPORT_SYMBOL(hashbin_lock_find);
-EXPORT_SYMBOL(hashbin_find_next);
-EXPORT_SYMBOL(hashbin_get_next);
-EXPORT_SYMBOL(hashbin_get_first);
-
-/* IrLAP */
-EXPORT_SYMBOL(irlap_open);
-EXPORT_SYMBOL(irlap_close);
-EXPORT_SYMBOL(irda_init_max_qos_capabilies);
-EXPORT_SYMBOL(irda_qos_bits_to_value);
-EXPORT_SYMBOL(irda_device_setup);
-EXPORT_SYMBOL(alloc_irdadev);
-EXPORT_SYMBOL(irda_device_set_media_busy);
-EXPORT_SYMBOL(irda_device_txqueue_empty);
-
-EXPORT_SYMBOL(irda_device_dongle_init);
-EXPORT_SYMBOL(irda_device_dongle_cleanup);
-EXPORT_SYMBOL(irda_device_register_dongle);
-EXPORT_SYMBOL(irda_device_unregister_dongle);
-EXPORT_SYMBOL(irda_task_execute);
-EXPORT_SYMBOL(irda_task_next_state);
-EXPORT_SYMBOL(irda_task_delete);
-
-EXPORT_SYMBOL(async_wrap_skb);
-EXPORT_SYMBOL(async_unwrap_char);
-EXPORT_SYMBOL(irda_calc_crc16);
-EXPORT_SYMBOL(irda_crc16_table);
-EXPORT_SYMBOL(irda_start_timer);
-
-#ifdef CONFIG_IRTTY
-EXPORT_SYMBOL(irtty_set_dtr_rts);
-EXPORT_SYMBOL(irtty_register_dongle);
-EXPORT_SYMBOL(irtty_unregister_dongle);
-EXPORT_SYMBOL(irtty_set_packet_mode);
-#endif
-
-#ifdef CONFIG_IRDA_DEBUG
-__u32 irda_debug = IRDA_DEBUG_LEVEL;
-#endif
-
-/* Packet type handler.
- * Tell the kernel how IrDA packets should be handled.
- */
-static struct packet_type irda_packet_type = {
-	.type	= __constant_htons(ETH_P_IRDA),
-	.func	= irlap_driver_rcv,	/* Packet type handler irlap_frame.c */
-};
-
-/*
- * Function irda_notify_init (notify)
- *
- *    Used for initializing the notify structure
- *
- */
-void irda_notify_init(notify_t *notify)
-{
-	notify->data_indication = NULL;
-	notify->udata_indication = NULL;
-	notify->connect_confirm = NULL;
-	notify->connect_indication = NULL;
-	notify->disconnect_indication = NULL;
-	notify->flow_indication = NULL;
-	notify->status_indication = NULL;
-	notify->instance = NULL;
-	strlcpy(notify->name, "Unknown", sizeof(notify->name));
-}
-
-/*
- * Function irda_init (void)
- *
- *  Protocol stack initialisation entry point.
- *  Initialise the various components of the IrDA stack
- */
-int __init irda_init(void)
-{
-	IRDA_DEBUG(0, "%s()\n", __FUNCTION__);
-
-	/* Lower layer of the stack */
- 	irlmp_init();
-	irlap_init();
-	
-	/* Higher layers of the stack */
-	iriap_init();
- 	irttp_init();
-	irsock_init();
-	
-	/* Add IrDA packet type (Start receiving packets) */
-        dev_add_pack(&irda_packet_type);
-
-	/* External APIs */
-#ifdef CONFIG_PROC_FS
-	irda_proc_register();
-#endif
-#ifdef CONFIG_SYSCTL
-	irda_sysctl_register();
-#endif
-
-	/* Driver/dongle support */
- 	irda_device_init();
-
-	return 0;
-}
-
-/*
- * Function irda_cleanup (void)
- *
- *  Protocol stack cleanup/removal entry point.
- *  Cleanup the various components of the IrDA stack
- */
-void __exit irda_cleanup(void)
-{
-	/* Remove External APIs */
-#ifdef CONFIG_SYSCTL
-	irda_sysctl_unregister();
-#endif	
-#ifdef CONFIG_PROC_FS
-	irda_proc_unregister();
-#endif
-
-	/* Remove IrDA packet type (stop receiving packets) */
-        dev_remove_pack(&irda_packet_type);
-	
-	/* Remove higher layers */
-	irsock_cleanup();
-	irttp_cleanup();
-	iriap_cleanup();
-
-	/* Remove lower layers */
-	irda_device_cleanup();
-	irlap_cleanup(); /* Must be done before irlmp_cleanup()! DB */
-
-	/* Remove middle layer */
-	irlmp_cleanup();
-}
-
-/*
- * The IrDA stack must be initialised *before* drivers get initialised,
- * and *before* higher protocols (IrLAN/IrCOMM/IrNET) get initialised,
- * otherwise bad things will happen (hashbins will be NULL for example).
- * Those modules are at module_init()/device_initcall() level.
- *
- * On the other hand, it needs to be initialised *after* the basic
- * networking, the /proc/net filesystem and sysctl module. Those are
- * currently initialised in .../init/main.c (before initcalls).
- * Also, IrDA drivers needs to be initialised *after* the random number
- * generator (main stack and higher layer init don't need it anymore).
- *
- * Jean II
- */
-subsys_initcall(irda_init);
-module_exit(irda_cleanup);
- 
-MODULE_AUTHOR("Dag Brattli <dagb@cs.uit.no> & Jean Tourrilhes <jt@hpl.hp.com>");
-MODULE_DESCRIPTION("The Linux IrDA Protocol Stack"); 
-MODULE_LICENSE("GPL");
-#ifdef CONFIG_IRDA_DEBUG
-MODULE_PARM(irda_debug, "1l");
-#endif
-MODULE_ALIAS_NETPROTO(PF_IRDA);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irsysctl.c linux-post-2.6.4rc3-20040310/net/irda/irsysctl.c
--- linux-post-2.6.4rc2-20040309/net/irda/irsysctl.c	2003-08-03 01:29:29.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irsysctl.c	2004-03-09 21:39:26.000000000 +0000
@@ -29,7 +29,7 @@
 #include <linux/sysctl.h>
 #include <linux/init.h>
 
-#include <net/irda/irda.h>
+#include <net/irda/irda.h>		/* irda_debug */
 #include <net/irda/irias_object.h>
 
 #define NET_IRDA 412 /* Random number */
@@ -53,10 +53,6 @@ extern int  sysctl_max_noreply_time;
 extern int  sysctl_warn_noreply_time;
 extern int  sysctl_lap_keepalive_time;
 
-#ifdef CONFIG_IRDA_DEBUG
-extern unsigned int irda_debug;
-#endif
-
 /* this is needed for the proc_dointvec_minmax - Jean II */
 static int max_discovery_slots = 16;		/* ??? */
 static int min_discovery_slots = 1;
diff -purN linux-post-2.6.4rc2-20040309/net/irda/irttp.c linux-post-2.6.4rc3-20040310/net/irda/irttp.c
--- linux-post-2.6.4rc2-20040309/net/irda/irttp.c	2003-11-26 02:53:08.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/irttp.c	2004-03-09 21:31:03.000000000 +0000
@@ -450,6 +450,7 @@ struct tsap_cb *irttp_open_tsap(__u8 sts
 
 	return self;
 }
+EXPORT_SYMBOL(irttp_open_tsap);
 
 /*
  * Function irttp_close (handle)
@@ -525,6 +526,7 @@ int irttp_close_tsap(struct tsap_cb *sel
 
 	return 0;
 }
+EXPORT_SYMBOL(irttp_close_tsap);
 
 /*
  * Function irttp_udata_request (self, skb)
@@ -562,6 +564,8 @@ err:
 	dev_kfree_skb(skb);
 	return -1;
 }
+EXPORT_SYMBOL(irttp_udata_request);
+
 
 /*
  * Function irttp_data_request (handle, skb)
@@ -672,6 +676,7 @@ err:
 	dev_kfree_skb(skb);
 	return ret;
 }
+EXPORT_SYMBOL(irttp_data_request);
 
 /*
  * Function irttp_run_tx_queue (self)
@@ -1058,6 +1063,7 @@ void irttp_flow_request(struct tsap_cb *
 		IRDA_DEBUG(1, "%s(), Unknown flow command!\n", __FUNCTION__);
 	}
 }
+EXPORT_SYMBOL(irttp_flow_request);
 
 /*
  * Function irttp_connect_request (self, dtsap_sel, daddr, qos)
@@ -1153,6 +1159,7 @@ int irttp_connect_request(struct tsap_cb
 	return irlmp_connect_request(self->lsap, dtsap_sel, saddr, daddr, qos,
 				     tx_skb);
 }
+EXPORT_SYMBOL(irttp_connect_request);
 
 /*
  * Function irttp_connect_confirm (handle, qos, skb)
@@ -1397,6 +1404,7 @@ int irttp_connect_response(struct tsap_c
 
 	return ret;
 }
+EXPORT_SYMBOL(irttp_connect_response);
 
 /*
  * Function irttp_dup (self, instance)
@@ -1455,6 +1463,7 @@ struct tsap_cb *irttp_dup(struct tsap_cb
 
 	return new;
 }
+EXPORT_SYMBOL(irttp_dup);
 
 /*
  * Function irttp_disconnect_request (self)
@@ -1549,6 +1558,7 @@ int irttp_disconnect_request(struct tsap
 
 	return ret;
 }
+EXPORT_SYMBOL(irttp_disconnect_request);
 
 /*
  * Function irttp_disconnect_indication (self, reason)
diff -purN linux-post-2.6.4rc2-20040309/net/irda/parameters.c linux-post-2.6.4rc3-20040310/net/irda/parameters.c
--- linux-post-2.6.4rc2-20040309/net/irda/parameters.c	2002-10-11 17:34:27.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/parameters.c	2004-03-09 21:37:17.000000000 +0000
@@ -29,6 +29,8 @@
  ********************************************************************/
 
 #include <linux/types.h>
+#include <linux/module.h>
+
 #include <asm/unaligned.h>
 #include <asm/byteorder.h>
 
@@ -393,6 +395,7 @@ int irda_param_pack(__u8 *buf, char *fmt
 
 	return 0;
 }
+EXPORT_SYMBOL(irda_param_pack);
 
 /*
  * Function irda_param_unpack (skb, fmt, ...)
@@ -437,6 +440,7 @@ int irda_param_unpack(__u8 *buf, char *f
 
 	return 0;
 }
+EXPORT_SYMBOL(irda_param_unpack);
 
 /*
  * Function irda_param_insert (self, pi, buf, len, info)
@@ -489,6 +493,7 @@ int irda_param_insert(void *self, __u8 p
 						 pi_minor_info->func);
 	return ret;
 }
+EXPORT_SYMBOL(irda_param_insert);
 
 /*
  * Function irda_param_extract_all (self, buf, len, info)
@@ -544,6 +549,7 @@ int irda_param_extract(void *self, __u8 
 						  type, pi_minor_info->func);
 	return ret;
 }
+EXPORT_SYMBOL(irda_param_extract);
 
 /*
  * Function irda_param_extract_all (self, buf, len, info)
@@ -575,4 +581,4 @@ int irda_param_extract_all(void *self, _
 	}
 	return n;
 }
-
+EXPORT_SYMBOL(irda_param_extract_all);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/qos.c linux-post-2.6.4rc3-20040310/net/irda/qos.c
--- linux-post-2.6.4rc2-20040309/net/irda/qos.c	2003-04-29 09:29:48.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/qos.c	2004-03-09 21:36:45.000000000 +0000
@@ -336,6 +336,7 @@ void irda_init_max_qos_capabilies(struct
 	qos->link_disc_time.bits &= 0xff;
 	qos->additional_bofs.bits = 0xff;
 }
+EXPORT_SYMBOL(irda_init_max_qos_capabilies);
 
 /*
  * Function irlap_adjust_qos_settings (qos)
@@ -774,3 +775,4 @@ void irda_qos_bits_to_value(struct qos_i
 	index = msb_index(qos->additional_bofs.bits);
 	qos->additional_bofs.value = add_bofs[index];
 }
+EXPORT_SYMBOL(irda_qos_bits_to_value);
diff -purN linux-post-2.6.4rc2-20040309/net/irda/timer.c linux-post-2.6.4rc3-20040310/net/irda/timer.c
--- linux-post-2.6.4rc2-20040309/net/irda/timer.c	2003-09-04 15:50:04.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/timer.c	2004-03-09 21:34:53.000000000 +0000
@@ -41,29 +41,6 @@ static void irlap_wd_timer_expired(void*
 static void irlap_backoff_timer_expired(void* data);
 static void irlap_media_busy_expired(void* data); 
 
-/*
- * Function irda_start_timer (timer, timeout)
- *
- *    Start an IrDA timer
- *
- */
-void irda_start_timer(struct timer_list *ptimer, int timeout, void *data,
-		      TIMER_CALLBACK callback) 
-{
-	/* 
-	 * For most architectures void * is the same as unsigned long, but
-	 * at least we try to use void * as long as possible. Since the 
-	 * timer functions use unsigned long, we cast the function here
-	 */
-	ptimer->function = (void (*)(unsigned long)) callback;
-	ptimer->data = (unsigned long) data;
-	
-	/* Set new value for timer (update or add timer).
-	 * We use mod_timer() because it's more efficient and also
-	 * safer with respect to race conditions - Jean II */
-	mod_timer(ptimer, jiffies + timeout);
-}
-
 void irlap_start_slot_timer(struct irlap_cb *self, int timeout)
 {
 	irda_start_timer(&self->slot_timer, timeout, (void *) self, 
diff -purN linux-post-2.6.4rc2-20040309/net/irda/wrapper.c linux-post-2.6.4rc3-20040310/net/irda/wrapper.c
--- linux-post-2.6.4rc2-20040309/net/irda/wrapper.c	2003-09-04 15:50:47.000000000 +0000
+++ linux-post-2.6.4rc3-20040310/net/irda/wrapper.c	2004-03-09 21:33:15.000000000 +0000
@@ -28,6 +28,7 @@
 
 #include <linux/skbuff.h>
 #include <linux/string.h>
+#include <linux/module.h>
 #include <asm/byteorder.h>
 
 #include <net/irda/irda.h>
@@ -151,6 +152,7 @@ int async_wrap_skb(struct sk_buff *skb, 
 
 	return n;
 }
+EXPORT_SYMBOL(async_wrap_skb);
 
 /************************* FRAME UNWRAPPING *************************/
 /*
@@ -481,4 +483,5 @@ void async_unwrap_char(struct net_device
 		break;
 	}
 }
+EXPORT_SYMBOL(async_unwrap_char);
 

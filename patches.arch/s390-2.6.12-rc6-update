From: Hannes Reinecke <hare@suse.de>
Subject: Update kernel CVS to 2.6.12-rc6

This is a temporary update to the latest mainline codedrop.
Can be deleted once the main tarball is updated.

diff -purN linux-2.6.11/arch/s390/appldata/appldata_base.c linux-2.6.12-rc6/arch/s390/appldata/appldata_base.c
--- linux-2.6.11/arch/s390/appldata/appldata_base.c	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/appldata/appldata_base.c	2005-06-06 17:22:29.000000000 +0200
@@ -28,6 +28,7 @@
 //#include <linux/kernel_stat.h>
 #include <linux/notifier.h>
 #include <linux/cpu.h>
+#include <linux/workqueue.h>
 
 #include "appldata.h"
 
@@ -133,9 +134,12 @@ static int appldata_interval = APPLDATA_
 static int appldata_timer_active;
 
 /*
- * Tasklet
+ * Work queue
  */
-static struct tasklet_struct appldata_tasklet_struct;
+static struct workqueue_struct *appldata_wq;
+static void appldata_work_fn(void *data);
+static DECLARE_WORK(appldata_work, appldata_work_fn, NULL);
+
 
 /*
  * Ops list
@@ -144,11 +148,11 @@ static DEFINE_SPINLOCK(appldata_ops_lock
 static LIST_HEAD(appldata_ops_list);
 
 
-/************************* timer, tasklet, DIAG ******************************/
+/*************************** timer, work, DIAG *******************************/
 /*
  * appldata_timer_function()
  *
- * schedule tasklet and reschedule timer
+ * schedule work and reschedule timer
  */
 static void appldata_timer_function(unsigned long data, struct pt_regs *regs)
 {
@@ -157,22 +161,22 @@ static void appldata_timer_function(unsi
 		atomic_read(&appldata_expire_count));
 	if (atomic_dec_and_test(&appldata_expire_count)) {
 		atomic_set(&appldata_expire_count, num_online_cpus());
-		tasklet_schedule((struct tasklet_struct *) data);
+		queue_work(appldata_wq, (struct work_struct *) data);
 	}
 }
 
 /*
- * appldata_tasklet_function()
+ * appldata_work_fn()
  *
  * call data gathering function for each (active) module
  */
-static void appldata_tasklet_function(unsigned long data)
+static void appldata_work_fn(void *data)
 {
 	struct list_head *lh;
 	struct appldata_ops *ops;
 	int i;
 
-	P_DEBUG("  -= Tasklet =-\n");
+	P_DEBUG("  -= Work Queue =-\n");
 	i = 0;
 	spin_lock(&appldata_ops_lock);
 	list_for_each(lh, &appldata_ops_list) {
@@ -231,7 +235,7 @@ static int appldata_diag(char record_nr,
 			: "=d" (ry) : "d" (&(appldata_parameter_list)) : "cc");
 	return (int) ry;
 }
-/********************** timer, tasklet, DIAG <END> ***************************/
+/************************ timer, work, DIAG <END> ****************************/
 
 
 /****************************** /proc stuff **********************************/
@@ -411,7 +415,7 @@ appldata_generic_handler(ctl_table *ctl,
 	struct list_head *lh;
 
 	found = 0;
-	spin_lock_bh(&appldata_ops_lock);
+	spin_lock(&appldata_ops_lock);
 	list_for_each(lh, &appldata_ops_list) {
 		tmp_ops = list_entry(lh, struct appldata_ops, list);
 		if (&tmp_ops->ctl_table[2] == ctl) {
@@ -419,15 +423,15 @@ appldata_generic_handler(ctl_table *ctl,
 		}
 	}
 	if (!found) {
-		spin_unlock_bh(&appldata_ops_lock);
+		spin_unlock(&appldata_ops_lock);
 		return -ENODEV;
 	}
 	ops = ctl->data;
 	if (!try_module_get(ops->owner)) {	// protect this function
-		spin_unlock_bh(&appldata_ops_lock);
+		spin_unlock(&appldata_ops_lock);
 		return -ENODEV;
 	}
-	spin_unlock_bh(&appldata_ops_lock);
+	spin_unlock(&appldata_ops_lock);
 
 	if (!*lenp || *ppos) {
 		*lenp = 0;
@@ -451,10 +455,11 @@ appldata_generic_handler(ctl_table *ctl,
 		return -EFAULT;
 	}
 
-	spin_lock_bh(&appldata_ops_lock);
+	spin_lock(&appldata_ops_lock);
 	if ((buf[0] == '1') && (ops->active == 0)) {
-		if (!try_module_get(ops->owner)) {	// protect tasklet
-			spin_unlock_bh(&appldata_ops_lock);
+		// protect work queue callback
+		if (!try_module_get(ops->owner)) {
+			spin_unlock(&appldata_ops_lock);
 			module_put(ops->owner);
 			return -ENODEV;
 		}
@@ -485,7 +490,7 @@ appldata_generic_handler(ctl_table *ctl,
 		}
 		module_put(ops->owner);
 	}
-	spin_unlock_bh(&appldata_ops_lock);
+	spin_unlock(&appldata_ops_lock);
 out:
 	*lenp = len;
 	*ppos += len;
@@ -529,7 +534,7 @@ int appldata_register_ops(struct appldat
 	}
 	memset(ops->ctl_table, 0, 4*sizeof(struct ctl_table));
 
-	spin_lock_bh(&appldata_ops_lock);
+	spin_lock(&appldata_ops_lock);
 	list_for_each(lh, &appldata_ops_list) {
 		tmp_ops = list_entry(lh, struct appldata_ops, list);
 		P_DEBUG("register_ops loop: %i) name = %s, ctl = %i\n",
@@ -541,18 +546,18 @@ int appldata_register_ops(struct appldat
 				APPLDATA_PROC_NAME_LENGTH) == 0) {
 			P_ERROR("Name \"%s\" already registered!\n", ops->name);
 			kfree(ops->ctl_table);
-			spin_unlock_bh(&appldata_ops_lock);
+			spin_unlock(&appldata_ops_lock);
 			return -EBUSY;
 		}
 		if (tmp_ops->ctl_nr == ops->ctl_nr) {
 			P_ERROR("ctl_nr %i already registered!\n", ops->ctl_nr);
 			kfree(ops->ctl_table);
-			spin_unlock_bh(&appldata_ops_lock);
+			spin_unlock(&appldata_ops_lock);
 			return -EBUSY;
 		}
 	}
 	list_add(&ops->list, &appldata_ops_list);
-	spin_unlock_bh(&appldata_ops_lock);
+	spin_unlock(&appldata_ops_lock);
 
 	ops->ctl_table[0].ctl_name = CTL_APPLDATA;
 	ops->ctl_table[0].procname = appldata_proc_name;
@@ -583,12 +588,12 @@ int appldata_register_ops(struct appldat
  */
 void appldata_unregister_ops(struct appldata_ops *ops)
 {
-	spin_lock_bh(&appldata_ops_lock);
+	spin_lock(&appldata_ops_lock);
 	unregister_sysctl_table(ops->sysctl_header);
 	list_del(&ops->list);
 	kfree(ops->ctl_table);
 	ops->ctl_table = NULL;
-	spin_unlock_bh(&appldata_ops_lock);
+	spin_unlock(&appldata_ops_lock);
 	P_INFO("%s-ops unregistered!\n", ops->name);
 }
 /********************** module-ops management <END> **************************/
@@ -602,7 +607,7 @@ appldata_online_cpu(int cpu)
 	init_virt_timer(&per_cpu(appldata_timer, cpu));
 	per_cpu(appldata_timer, cpu).function = appldata_timer_function;
 	per_cpu(appldata_timer, cpu).data = (unsigned long)
-		&appldata_tasklet_struct;
+		&appldata_work;
 	atomic_inc(&appldata_expire_count);
 	spin_lock(&appldata_timer_lock);
 	__appldata_vtimer_setup(APPLDATA_MOD_TIMER);
@@ -615,7 +620,7 @@ appldata_offline_cpu(int cpu)
 	del_virt_timer(&per_cpu(appldata_timer, cpu));
 	if (atomic_dec_and_test(&appldata_expire_count)) {
 		atomic_set(&appldata_expire_count, num_online_cpus());
-		tasklet_schedule(&appldata_tasklet_struct);
+		queue_work(appldata_wq, &appldata_work);
 	}
 	spin_lock(&appldata_timer_lock);
 	__appldata_vtimer_setup(APPLDATA_MOD_TIMER);
@@ -648,7 +653,7 @@ static struct notifier_block __devinitda
 /*
  * appldata_init()
  *
- * init timer and tasklet, register /proc entries
+ * init timer, register /proc entries
  */
 static int __init appldata_init(void)
 {
@@ -657,6 +662,12 @@ static int __init appldata_init(void)
 	P_DEBUG("sizeof(parameter_list) = %lu\n",
 		sizeof(struct appldata_parameter_list));
 
+	appldata_wq = create_singlethread_workqueue("appldata");
+	if (!appldata_wq) {
+		P_ERROR("Could not create work queue\n");
+		return -ENOMEM;
+	}
+
 	for_each_online_cpu(i)
 		appldata_online_cpu(i);
 
@@ -670,7 +681,6 @@ static int __init appldata_init(void)
 	appldata_table[1].de->owner = THIS_MODULE;
 #endif
 
-	tasklet_init(&appldata_tasklet_struct, appldata_tasklet_function, 0);
 	P_DEBUG("Base interface initialized.\n");
 	return 0;
 }
@@ -678,7 +688,7 @@ static int __init appldata_init(void)
 /*
  * appldata_exit()
  *
- * stop timer and tasklet, unregister /proc entries
+ * stop timer, unregister /proc entries
  */
 static void __exit appldata_exit(void)
 {
@@ -690,7 +700,7 @@ static void __exit appldata_exit(void)
 	/*
 	 * ops list should be empty, but just in case something went wrong...
 	 */
-	spin_lock_bh(&appldata_ops_lock);
+	spin_lock(&appldata_ops_lock);
 	list_for_each(lh, &appldata_ops_list) {
 		ops = list_entry(lh, struct appldata_ops, list);
 		rc = appldata_diag(ops->record_nr, APPLDATA_STOP_REC,
@@ -700,7 +710,7 @@ static void __exit appldata_exit(void)
 				"return code: %d\n", ops->name, rc);
 		}
 	}
-	spin_unlock_bh(&appldata_ops_lock);
+	spin_unlock(&appldata_ops_lock);
 
 	for_each_online_cpu(i)
 		appldata_offline_cpu(i);
@@ -709,7 +719,7 @@ static void __exit appldata_exit(void)
 
 	unregister_sysctl_table(appldata_sysctl_header);
 
-	tasklet_kill(&appldata_tasklet_struct);
+	destroy_workqueue(appldata_wq);
 	P_DEBUG("... module unloaded!\n");
 }
 /**************************** init / exit <END> ******************************/
diff -purN linux-2.6.11/arch/s390/appldata/appldata_mem.c linux-2.6.12-rc6/arch/s390/appldata/appldata_mem.c
--- linux-2.6.11/arch/s390/appldata/appldata_mem.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/appldata/appldata_mem.c	2005-06-06 17:22:29.000000000 +0200
@@ -68,7 +68,7 @@ struct appldata_mem_data {
 	u64 pgmajfault;		/* page faults (major only) */
 // <-- New in 2.6
 
-} appldata_mem_data;
+} __attribute__((packed)) appldata_mem_data;
 
 
 static inline void appldata_debug_print(struct appldata_mem_data *mem_data)
diff -purN linux-2.6.11/arch/s390/appldata/appldata_net_sum.c linux-2.6.12-rc6/arch/s390/appldata/appldata_net_sum.c
--- linux-2.6.11/arch/s390/appldata/appldata_net_sum.c	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/appldata/appldata_net_sum.c	2005-06-06 17:22:29.000000000 +0200
@@ -57,7 +57,7 @@ struct appldata_net_sum_data {
 	u64 rx_dropped;		/* no space in linux buffers     */
 	u64 tx_dropped;		/* no space available in linux   */
 	u64 collisions;		/* collisions while transmitting */
-} appldata_net_sum_data;
+} __attribute__((packed)) appldata_net_sum_data;
 
 
 static inline void appldata_print_debug(struct appldata_net_sum_data *net_data)
diff -purN linux-2.6.11/arch/s390/appldata/appldata_os.c linux-2.6.12-rc6/arch/s390/appldata/appldata_os.c
--- linux-2.6.11/arch/s390/appldata/appldata_os.c	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/appldata/appldata_os.c	2005-06-06 17:22:29.000000000 +0200
@@ -49,7 +49,7 @@ struct appldata_os_per_cpu {
 	u32 per_cpu_softirq;	/* ... spent in softirqs            */
 	u32 per_cpu_iowait;	/* ... spent while waiting for I/O  */
 // <-- New in 2.6
-};
+} __attribute__((packed));
 
 struct appldata_os_data {
 	u64 timestamp;
@@ -75,7 +75,7 @@ struct appldata_os_data {
 
 	/* per cpu data */
 	struct appldata_os_per_cpu os_cpu[0];
-};
+} __attribute__((packed));
 
 static struct appldata_os_data *appldata_os_data;
 
diff -purN linux-2.6.11/arch/s390/defconfig linux-2.6.12-rc6/arch/s390/defconfig
--- linux-2.6.11/arch/s390/defconfig	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/defconfig	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Mon Jan 31 16:27:12 2005
+# Linux kernel version: 2.6.12-rc3
+# Fri Apr 22 15:30:58 2005
 #
 CONFIG_MMU=y
 CONFIG_RWSEM_XCHGADD_ALGORITHM=y
@@ -15,6 +15,7 @@ CONFIG_UID16=y
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
@@ -26,24 +27,25 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=17
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+# CONFIG_CPUSETS is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SHMEM=y
 CONFIG_CC_ALIGN_FUNCTIONS=0
 CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -54,6 +56,7 @@ CONFIG_OBSOLETE_MODPARM=y
 # CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
 CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
 
 #
 # Base setup
@@ -67,7 +70,7 @@ CONFIG_KMOD=y
 CONFIG_ARCH_S390_31=y
 CONFIG_SMP=y
 CONFIG_NR_CPUS=32
-# CONFIG_HOTPLUG_CPU is not set
+CONFIG_HOTPLUG_CPU=y
 CONFIG_MATHEMU=y
 
 #
@@ -260,7 +263,6 @@ CONFIG_NET=y
 #
 CONFIG_PACKET=y
 # CONFIG_PACKET_MMAP is not set
-# CONFIG_NETLINK_DEV is not set
 CONFIG_UNIX=y
 CONFIG_NET_KEY=y
 CONFIG_INET=y
@@ -328,6 +330,7 @@ CONFIG_NET_SCH_DSMARK=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -337,6 +340,7 @@ CONFIG_NET_CLS_U32=m
 # CONFIG_NET_CLS_IND is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -392,6 +396,8 @@ CONFIG_CTC=m
 CONFIG_IUCV=m
 # CONFIG_NETIUCV is not set
 # CONFIG_SMSGIUCV is not set
+# CONFIG_CLAW is not set
+# CONFIG_MPC is not set
 CONFIG_QETH=y
 
 #
@@ -419,6 +425,10 @@ CONFIG_JBD=y
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -527,10 +537,13 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 CONFIG_DEBUG_KERNEL=y
 CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=17
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_KOBJECT is not set
 # CONFIG_DEBUG_INFO is not set
@@ -555,6 +568,7 @@ CONFIG_CRYPTO=y
 # CONFIG_CRYPTO_SHA256 is not set
 # CONFIG_CRYPTO_SHA512 is not set
 # CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_DES_Z990 is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
diff -purN linux-2.6.11/arch/s390/Kconfig linux-2.6.12-rc6/arch/s390/Kconfig
--- linux-2.6.11/arch/s390/Kconfig	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/Kconfig	2005-06-06 17:22:29.000000000 +0200
@@ -84,12 +84,12 @@ config NR_CPUS
 	  approximately sixteen kilobytes to the kernel image.
 
 config HOTPLUG_CPU
-	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
-	depends on SMP && EXPERIMENTAL
+	bool "Support for hot-pluggable CPUs"
+	depends on SMP
 	select HOTPLUG
 	default n
 	help
-	  Say Y here to experiment with turning CPUs off and on.  CPUs
+	  Say Y here to be able to turn CPUs off and on. CPUs
 	  can be controlled through /sys/devices/system/cpu/cpu#.
 	  Say N if you want to disable CPU hotplug.
 
diff -purN linux-2.6.11/arch/s390/kernel/compat_ioctl.c linux-2.6.12-rc6/arch/s390/kernel/compat_ioctl.c
--- linux-2.6.11/arch/s390/kernel/compat_ioctl.c	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/compat_ioctl.c	2005-06-06 17:22:29.000000000 +0200
@@ -16,6 +16,7 @@
 #define CODE
 #include "../../../fs/compat_ioctl.c"
 #include <asm/dasd.h>
+#include <asm/cmb.h>
 #include <asm/tape390.h>
 
 static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
@@ -58,16 +59,17 @@ COMPATIBLE_IOCTL(BIODASDPRRD)
 COMPATIBLE_IOCTL(BIODASDPSRD)
 COMPATIBLE_IOCTL(BIODASDGATTR)
 COMPATIBLE_IOCTL(BIODASDSATTR)
-
+#if defined(CONFIG_DASD_CMB) || defined(CONFIG_DASD_CMB_MODULE)
+COMPATIBLE_IOCTL(BIODASDCMFENABLE)
+COMPATIBLE_IOCTL(BIODASDCMFDISABLE)
+COMPATIBLE_IOCTL(BIODASDREADALLCMB)
+#endif
 #endif
 
 #if defined(CONFIG_S390_TAPE) || defined(CONFIG_S390_TAPE_MODULE)
 COMPATIBLE_IOCTL(TAPE390_DISPLAY)
 #endif
 
-/* This one should be architecture independent */
-COMPATIBLE_IOCTL(TCSBRKP)
-
 /* s390 doesn't need handlers here */
 COMPATIBLE_IOCTL(TIOCGSERIAL)
 COMPATIBLE_IOCTL(TIOCSSERIAL)
diff -purN linux-2.6.11/arch/s390/kernel/compat_signal.c linux-2.6.12-rc6/arch/s390/kernel/compat_signal.c
--- linux-2.6.11/arch/s390/kernel/compat_signal.c	2005-03-02 08:38:26.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/compat_signal.c	2005-06-06 17:22:29.000000000 +0200
@@ -231,7 +231,7 @@ sys32_sigaction(int sig, const struct ol
 
         if (act) {
 		compat_old_sigset_t mask;
-		if (verify_area(VERIFY_READ, act, sizeof(*act)) ||
+		if (!access_ok(VERIFY_READ, act, sizeof(*act)) ||
 		    __get_user(sa_handler, &act->sa_handler) ||
 		    __get_user(sa_restorer, &act->sa_restorer))
 			return -EFAULT;
@@ -247,7 +247,7 @@ sys32_sigaction(int sig, const struct ol
 	if (!ret && oact) {
 		sa_handler = (unsigned long) old_ka.sa.sa_handler;
 		sa_restorer = (unsigned long) old_ka.sa.sa_restorer;
-		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
+		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||
 		    __put_user(sa_handler, &oact->sa_handler) ||
 		    __put_user(sa_restorer, &oact->sa_restorer))
 			return -EFAULT;
@@ -416,7 +416,7 @@ asmlinkage long sys32_sigreturn(struct p
 	sigframe32 __user *frame = (sigframe32 __user *)regs->gprs[15];
 	sigset_t set;
 
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE32))
 		goto badframe;
@@ -446,7 +446,7 @@ asmlinkage long sys32_rt_sigreturn(struc
 	int err;
 	mm_segment_t old_fs = get_fs();
 
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
 		goto badframe;
diff -purN linux-2.6.11/arch/s390/kernel/compat_wrapper.S linux-2.6.12-rc6/arch/s390/kernel/compat_wrapper.S
--- linux-2.6.11/arch/s390/kernel/compat_wrapper.S	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/compat_wrapper.S	2005-06-06 17:22:29.000000000 +0200
@@ -1406,3 +1406,29 @@ compat_sys_mq_getsetattr_wrapper:
 	llgtr	%r3,%r3			# struct compat_mq_attr *
 	llgtr	%r4,%r4			# struct compat_mq_attr *
 	jg	compat_sys_mq_getsetattr
+
+	.globl	compat_sys_add_key_wrapper
+compat_sys_add_key_wrapper:
+	llgtr	%r2,%r2			# const char *
+	llgtr	%r3,%r3			# const char *
+	llgtr	%r4,%r4			# const void *
+	llgfr	%r5,%r5			# size_t
+	llgfr	%r6,%r6			# (key_serial_t) u32
+	jg	sys_add_key
+
+	.globl	compat_sys_request_key_wrapper
+compat_sys_request_key_wrapper:
+	llgtr	%r2,%r2			# const char *
+	llgtr	%r3,%r3			# const char *
+	llgtr	%r4,%r4			# const void *
+	llgfr	%r5,%r5			# (key_serial_t) u32
+	jg	sys_request_key
+
+	.globl	sys32_remap_file_pages_wrapper
+sys32_remap_file_pages_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgfr	%r3,%r3			# unsigned long
+	llgfr	%r4,%r4			# unsigned long
+	llgfr	%r5,%r5			# unsigned long
+	llgfr	%r6,%r6			# unsigned long
+	jg	sys_remap_file_pages
diff -purN linux-2.6.11/arch/s390/kernel/debug.c linux-2.6.12-rc6/arch/s390/kernel/debug.c
--- linux-2.6.11/arch/s390/kernel/debug.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/debug.c	2005-06-06 17:22:29.000000000 +0200
@@ -931,11 +931,15 @@ int debug_register_view(debug_info_t * i
 	int rc = 0;
 	int i;
 	unsigned long flags;
-	mode_t mode = S_IFREG | S_IRUSR | S_IWUSR;
+	mode_t mode = S_IFREG;
 	struct proc_dir_entry *pde;
 
 	if (!id)
 		goto out;
+	if (view->prolog_proc || view->format_proc || view->header_proc)
+		mode |= S_IRUSR;
+	if (view->input_proc)
+		mode |= S_IWUSR;
 	pde = create_proc_entry(view->name, mode, id->proc_root_entry);
 	if (!pde){
 		printk(KERN_WARNING "debug: create_proc_entry() failed! Cannot register view %s/%s\n", id->name,view->name);
@@ -958,10 +962,6 @@ int debug_register_view(debug_info_t * i
 	}
 	else {
 		id->views[i] = view;
-		if (view->prolog_proc || view->format_proc || view->header_proc)
-			mode |= S_IRUSR;
-		if (view->input_proc)
-			mode |= S_IWUSR;
 		pde->proc_fops = &debug_file_ops;
 		id->proc_entries[i] = pde;
 	}
diff -purN linux-2.6.11/arch/s390/kernel/irq.c linux-2.6.12-rc6/arch/s390/kernel/irq.c
--- linux-2.6.11/arch/s390/kernel/irq.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/irq.c	2005-06-06 17:22:29.000000000 +0200
@@ -25,9 +25,8 @@ int show_interrupts(struct seq_file *p, 
 
 	if (i == 0) {
 		seq_puts(p, "           ");
-		for (j=0; j<NR_CPUS; j++)
-			if (cpu_online(j))
-				seq_printf(p, "CPU%d       ",j);
+		for_each_online_cpu(j)
+			seq_printf(p, "CPU%d       ",j);
 		seq_putc(p, '\n');
 	}
 
@@ -36,9 +35,8 @@ int show_interrupts(struct seq_file *p, 
 #ifndef CONFIG_SMP
 		seq_printf(p, "%10u ", kstat_irqs(i));
 #else
-		for (j = 0; j < NR_CPUS; j++)
-			if (cpu_online(j))
-				seq_printf(p, "%10u ", kstat_cpu(j).irqs[i]);
+		for_each_online_cpu(j)
+			seq_printf(p, "%10u ", kstat_cpu(j).irqs[i]);
 #endif
                 seq_putc(p, '\n');
 
diff -purN linux-2.6.11/arch/s390/kernel/ptrace.c linux-2.6.12-rc6/arch/s390/kernel/ptrace.c
--- linux-2.6.11/arch/s390/kernel/ptrace.c	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/ptrace.c	2005-06-06 17:22:29.000000000 +0200
@@ -31,6 +31,8 @@
 #include <linux/ptrace.h>
 #include <linux/user.h>
 #include <linux/security.h>
+#include <linux/audit.h>
+#include <linux/signal.h>
 
 #include <asm/segment.h>
 #include <asm/page.h>
@@ -38,6 +40,7 @@
 #include <asm/pgalloc.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
+#include <asm/unistd.h>
 
 #ifdef CONFIG_S390_SUPPORT
 #include "compat_ptrace.h"
@@ -128,13 +131,19 @@ static int
 peek_user(struct task_struct *child, addr_t addr, addr_t data)
 {
 	struct user *dummy = NULL;
-	addr_t offset, tmp;
+	addr_t offset, tmp, mask;
 
 	/*
 	 * Stupid gdb peeks/pokes the access registers in 64 bit with
 	 * an alignment of 4. Programmers from hell...
 	 */
-	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
+	mask = __ADDR_MASK;
+#ifdef CONFIG_ARCH_S390X
+	if (addr >= (addr_t) &dummy->regs.acrs &&
+	    addr < (addr_t) &dummy->regs.orig_gpr2)
+		mask = 3;
+#endif
+	if ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
 	if (addr < (addr_t) &dummy->regs.acrs) {
@@ -151,6 +160,16 @@ peek_user(struct task_struct *child, add
 		 * access registers are stored in the thread structure
 		 */
 		offset = addr - (addr_t) &dummy->regs.acrs;
+#ifdef CONFIG_ARCH_S390X
+		/*
+		 * Very special case: old & broken 64 bit gdb reading
+		 * from acrs[15]. Result is a 64 bit value. Read the
+		 * 32 bit acrs[15] value and shift it by 32. Sick...
+		 */
+		if (addr == (addr_t) &dummy->regs.acrs[15])
+			tmp = ((unsigned long) child->thread.acrs[15]) << 32;
+		else
+#endif
 		tmp = *(addr_t *)((addr_t) &child->thread.acrs + offset);
 
 	} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {
@@ -165,6 +184,9 @@ peek_user(struct task_struct *child, add
 		 */
 		offset = addr - (addr_t) &dummy->regs.fp_regs;
 		tmp = *(addr_t *)((addr_t) &child->thread.fp_regs + offset);
+		if (addr == (addr_t) &dummy->regs.fp_regs.fpc)
+			tmp &= (unsigned long) FPC_VALID_MASK
+				<< (BITS_PER_LONG - 32);
 
 	} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {
 		/*
@@ -189,13 +211,19 @@ static int
 poke_user(struct task_struct *child, addr_t addr, addr_t data)
 {
 	struct user *dummy = NULL;
-	addr_t offset;
+	addr_t offset, mask;
 
 	/*
 	 * Stupid gdb peeks/pokes the access registers in 64 bit with
 	 * an alignment of 4. Programmers from hell indeed...
 	 */
-	if ((addr & 3) || addr > sizeof(struct user) - __ADDR_MASK)
+	mask = __ADDR_MASK;
+#ifdef CONFIG_ARCH_S390X
+	if (addr >= (addr_t) &dummy->regs.acrs &&
+	    addr < (addr_t) &dummy->regs.orig_gpr2)
+		mask = 3;
+#endif
+	if ((addr & mask) || addr > sizeof(struct user) - __ADDR_MASK)
 		return -EIO;
 
 	if (addr < (addr_t) &dummy->regs.acrs) {
@@ -222,6 +250,17 @@ poke_user(struct task_struct *child, add
 		 * access registers are stored in the thread structure
 		 */
 		offset = addr - (addr_t) &dummy->regs.acrs;
+#ifdef CONFIG_ARCH_S390X
+		/*
+		 * Very special case: old & broken 64 bit gdb writing
+		 * to acrs[15] with a 64 bit value. Ignore the lower
+		 * half of the value and write the upper 32 bit to
+		 * acrs[15]. Sick...
+		 */
+		if (addr == (addr_t) &dummy->regs.acrs[15])
+			child->thread.acrs[15] = (unsigned int) (data >> 32);
+		else
+#endif
 		*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;
 
 	} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {
@@ -235,7 +274,8 @@ poke_user(struct task_struct *child, add
 		 * floating point regs. are stored in the thread structure
 		 */
 		if (addr == (addr_t) &dummy->regs.fp_regs.fpc &&
-		    (data & ~FPC_VALID_MASK) != 0)
+		    (data & ~((unsigned long) FPC_VALID_MASK
+			      << (BITS_PER_LONG - 32))) != 0)
 			return -EINVAL;
 		offset = addr - (addr_t) &dummy->regs.fp_regs;
 		*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;
@@ -710,22 +750,24 @@ out:
 asmlinkage void
 syscall_trace(struct pt_regs *regs, int entryexit)
 {
-	if (unlikely(current->audit_context)) {
-		if (!entryexit)
-			audit_syscall_entry(current, regs->gprs[2],
-					    regs->orig_gpr2, regs->gprs[3],
-					    regs->gprs[4], regs->gprs[5]);
-		else
-			audit_syscall_exit(current, regs->gprs[2]);
-	}
+	if (unlikely(current->audit_context) && entryexit)
+		audit_syscall_exit(current, regs->gprs[2]);
+
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
-		return;
+		goto out;
 	if (!(current->ptrace & PT_PTRACED))
-		return;
+		goto out;
 	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
 				 ? 0x80 : 0));
 
 	/*
+	 * If the debuffer has set an invalid system call number,
+	 * we prepare to skip the system call restart handling.
+	 */
+	if (!entryexit && regs->gprs[2] >= NR_syscalls)
+		regs->trap = -1;
+
+	/*
 	 * this isn't the same as continuing with a signal, but it will do
 	 * for normal use.  strace only continues with a signal if the
 	 * stopping signal is not SIGTRAP.  -brl
@@ -734,4 +776,9 @@ syscall_trace(struct pt_regs *regs, int 
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
+ out:
+	if (unlikely(current->audit_context) && !entryexit)
+		audit_syscall_entry(current, 
+				    regs->gprs[2], regs->orig_gpr2, regs->gprs[3],
+				    regs->gprs[4], regs->gprs[5]);
 }
diff -purN linux-2.6.11/arch/s390/kernel/s390_ext.c linux-2.6.12-rc6/arch/s390/kernel/s390_ext.c
--- linux-2.6.11/arch/s390/kernel/s390_ext.c	2005-03-02 08:38:08.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/s390_ext.c	2005-06-06 17:22:29.000000000 +0200
@@ -114,6 +114,10 @@ void do_extint(struct pt_regs *regs, uns
 	irq_enter();
 	asm volatile ("mc 0,0");
 	if (S390_lowcore.int_clock >= S390_lowcore.jiffy_timer)
+		/**
+		 * Make sure that the i/o interrupt did not "overtake"
+		 * the last HZ timer interrupt.
+		 */
 		account_ticks(regs);
 	kstat_cpu(smp_processor_id()).irqs[EXTERNAL_INTERRUPT]++;
         index = code & 0xff;
diff -purN linux-2.6.11/arch/s390/kernel/s390_ksyms.c linux-2.6.12-rc6/arch/s390/kernel/s390_ksyms.c
--- linux-2.6.11/arch/s390/kernel/s390_ksyms.c	2005-03-02 08:38:12.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/s390_ksyms.c	2005-06-06 17:22:29.000000000 +0200
@@ -34,7 +34,6 @@ EXPORT_SYMBOL(__clear_user_asm);
 EXPORT_SYMBOL(__strncpy_from_user_asm);
 EXPORT_SYMBOL(__strnlen_user_asm);
 EXPORT_SYMBOL(diag10);
-EXPORT_SYMBOL(default_storage_key);
 
 /*
  * semaphore ops
diff -purN linux-2.6.11/arch/s390/kernel/setup.c linux-2.6.12-rc6/arch/s390/kernel/setup.c
--- linux-2.6.11/arch/s390/kernel/setup.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/setup.c	2005-06-06 17:22:29.000000000 +0200
@@ -44,6 +44,8 @@
 #include <asm/cpcmd.h>
 #include <asm/lowcore.h>
 #include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
 
 /*
  * Machine setup..
@@ -53,13 +55,14 @@ unsigned int console_devno = -1;
 unsigned int console_irq = -1;
 unsigned long memory_size = 0;
 unsigned long machine_flags = 0;
-unsigned int default_storage_key = 0;
 struct {
 	unsigned long addr, size, type;
 } memory_chunk[MEMORY_CHUNKS] = { { 0 } };
 #define CHUNK_READ_WRITE 0
 #define CHUNK_READ_ONLY 1
 volatile int __cpu_logical_map[NR_CPUS]; /* logical cpu to cpu address */
+unsigned long __initdata zholes_size[MAX_NR_ZONES];
+static unsigned long __initdata memory_end;
 
 /*
  * Setup options
@@ -78,11 +81,15 @@ static char command_line[COMMAND_LINE_SI
 
 static struct resource code_resource = {
 	.name  = "Kernel code",
+	.start = (unsigned long) &_text,
+	.end = (unsigned long) &_etext - 1,
 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
 };
 
 static struct resource data_resource = {
 	.name = "Kernel data",
+	.start = (unsigned long) &_etext,
+	.end = (unsigned long) &_edata - 1,
 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
 };
 
@@ -310,90 +317,50 @@ void machine_power_off(void)
 
 EXPORT_SYMBOL(machine_power_off);
 
-/*
- * Setup function called from init/main.c just after the banner
- * was printed.
- */
-extern char _pstart, _pend, _stext;
-
-void __init setup_arch(char **cmdline_p)
+static void __init
+add_memory_hole(unsigned long start, unsigned long end)
 {
-        unsigned long bootmap_size;
-        unsigned long memory_start, memory_end;
-        char c = ' ', cn, *to = command_line, *from = COMMAND_LINE;
-	unsigned long start_pfn, end_pfn;
-        static unsigned int smptrap=0;
-        unsigned long delay = 0;
-	struct _lowcore *lc;
-	int i;
+	unsigned long dma_pfn = MAX_DMA_ADDRESS >> PAGE_SHIFT;
 
-        if (smptrap)
-                return;
-        smptrap=1;
+	if (end <= dma_pfn)
+		zholes_size[ZONE_DMA] += end - start + 1;
+	else if (start > dma_pfn)
+		zholes_size[ZONE_NORMAL] += end - start + 1;
+	else {
+		zholes_size[ZONE_DMA] += dma_pfn - start + 1;
+		zholes_size[ZONE_NORMAL] += end - dma_pfn;
+	}
+}
 
-        /*
-         * print what head.S has found out about the machine 
-         */
-#ifndef CONFIG_ARCH_S390X
-	printk((MACHINE_IS_VM) ?
-	       "We are running under VM (31 bit mode)\n" :
-	       "We are running native (31 bit mode)\n");
-	printk((MACHINE_HAS_IEEE) ?
-	       "This machine has an IEEE fpu\n" :
-	       "This machine has no IEEE fpu\n");
-#else /* CONFIG_ARCH_S390X */
-	printk((MACHINE_IS_VM) ?
-	       "We are running under VM (64 bit mode)\n" :
-	       "We are running native (64 bit mode)\n");
-#endif /* CONFIG_ARCH_S390X */
+static void __init
+parse_cmdline_early(char **cmdline_p)
+{
+	char c = ' ', cn, *to = command_line, *from = COMMAND_LINE;
+	unsigned long delay = 0;
 
-        ROOT_DEV = Root_RAM0;
-        memory_start = (unsigned long) &_end;    /* fixit if use $CODELO etc*/
-#ifndef CONFIG_ARCH_S390X
-	memory_end = memory_size & ~0x400000UL;  /* align memory end to 4MB */
-        /*
-         * We need some free virtual space to be able to do vmalloc.
-         * On a machine with 2GB memory we make sure that we have at
-         * least 128 MB free space for vmalloc.
-         */
-        if (memory_end > 1920*1024*1024)
-                memory_end = 1920*1024*1024;
-#else /* CONFIG_ARCH_S390X */
-	memory_end = memory_size & ~0x200000UL;  /* detected in head.s */
-#endif /* CONFIG_ARCH_S390X */
-        init_mm.start_code = PAGE_OFFSET;
-        init_mm.end_code = (unsigned long) &_etext;
-        init_mm.end_data = (unsigned long) &_edata;
-        init_mm.brk = (unsigned long) &_end;
-
-	code_resource.start = (unsigned long) &_text;
-	code_resource.end = (unsigned long) &_etext - 1;
-	data_resource.start = (unsigned long) &_etext;
-	data_resource.end = (unsigned long) &_edata - 1;
-
-        /* Save unparsed command line copy for /proc/cmdline */
-        memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
-        saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
-
-        for (;;) {
-                /*
-                 * "mem=XXX[kKmM]" sets memsize 
-                 */
-                if (c == ' ' && strncmp(from, "mem=", 4) == 0) {
-                        memory_end = simple_strtoul(from+4, &from, 0);
-                        if ( *from == 'K' || *from == 'k' ) {
-                                memory_end = memory_end << 10;
-                                from++;
-                        } else if ( *from == 'M' || *from == 'm' ) {
-                                memory_end = memory_end << 20;
-                                from++;
-                        }
-                }
-                /*
-                 * "ipldelay=XXX[sm]" sets ipl delay in seconds or minutes
-                 */
-                if (c == ' ' && strncmp(from, "ipldelay=", 9) == 0) {
-                        delay = simple_strtoul(from+9, &from, 0);
+	/* Save unparsed command line copy for /proc/cmdline */
+	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+
+	for (;;) {
+		/*
+		 * "mem=XXX[kKmM]" sets memsize
+		 */
+		if (c == ' ' && strncmp(from, "mem=", 4) == 0) {
+			memory_end = simple_strtoul(from+4, &from, 0);
+			if ( *from == 'K' || *from == 'k' ) {
+				memory_end = memory_end << 10;
+				from++;
+			} else if ( *from == 'M' || *from == 'm' ) {
+				memory_end = memory_end << 20;
+				from++;
+			}
+		}
+		/*
+		 * "ipldelay=XXX[sm]" sets ipl delay in seconds or minutes
+		 */
+		if (c == ' ' && strncmp(from, "ipldelay=", 9) == 0) {
+			delay = simple_strtoul(from+9, &from, 0);
 			if (*from == 's' || *from == 'S') {
 				delay = delay*1000000;
 				from++;
@@ -403,24 +370,110 @@ void __init setup_arch(char **cmdline_p)
 			}
 			/* now wait for the requested amount of time */
 			udelay(delay);
-                }
-                cn = *(from++);
-                if (!cn)
-                        break;
-                if (cn == '\n')
-                        cn = ' ';  /* replace newlines with space */
+		}
+		cn = *(from++);
+		if (!cn)
+			break;
+		if (cn == '\n')
+			cn = ' ';  /* replace newlines with space */
 		if (cn == 0x0d)
 			cn = ' ';  /* replace 0x0d with space */
-                if (cn == ' ' && c == ' ')
-                        continue;  /* remove additional spaces */
-                c = cn;
-                if (to - command_line >= COMMAND_LINE_SIZE)
-                        break;
-                *(to++) = c;
-        }
-        if (c == ' ' && to > command_line) to--;
-        *to = '\0';
-        *cmdline_p = command_line;
+		if (cn == ' ' && c == ' ')
+			continue;  /* remove additional spaces */
+		c = cn;
+		if (to - command_line >= COMMAND_LINE_SIZE)
+			break;
+		*(to++) = c;
+	}
+	if (c == ' ' && to > command_line) to--;
+	*to = '\0';
+	*cmdline_p = command_line;
+}
+
+static void __init
+setup_lowcore(void)
+{
+	struct _lowcore *lc;
+	int lc_pages;
+
+	/*
+	 * Setup lowcore for boot cpu
+	 */
+	lc_pages = sizeof(void *) == 8 ? 2 : 1;
+	lc = (struct _lowcore *)
+		__alloc_bootmem(lc_pages * PAGE_SIZE, lc_pages * PAGE_SIZE, 0);
+	memset(lc, 0, lc_pages * PAGE_SIZE);
+	lc->restart_psw.mask = PSW_BASE_BITS | PSW_DEFAULT_KEY;
+	lc->restart_psw.addr =
+		PSW_ADDR_AMODE | (unsigned long) restart_int_handler;
+	lc->external_new_psw.mask = PSW_KERNEL_BITS;
+	lc->external_new_psw.addr =
+		PSW_ADDR_AMODE | (unsigned long) ext_int_handler;
+	lc->svc_new_psw.mask = PSW_KERNEL_BITS | PSW_MASK_IO | PSW_MASK_EXT;
+	lc->svc_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) system_call;
+	lc->program_new_psw.mask = PSW_KERNEL_BITS;
+	lc->program_new_psw.addr =
+		PSW_ADDR_AMODE | (unsigned long)pgm_check_handler;
+	lc->mcck_new_psw.mask = PSW_KERNEL_BITS;
+	lc->mcck_new_psw.addr =
+		PSW_ADDR_AMODE | (unsigned long) mcck_int_handler;
+	lc->io_new_psw.mask = PSW_KERNEL_BITS;
+	lc->io_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) io_int_handler;
+	lc->ipl_device = S390_lowcore.ipl_device;
+	lc->jiffy_timer = -1LL;
+	lc->kernel_stack = ((unsigned long) &init_thread_union) + THREAD_SIZE;
+	lc->async_stack = (unsigned long)
+		__alloc_bootmem(ASYNC_SIZE, ASYNC_SIZE, 0) + ASYNC_SIZE;
+#ifdef CONFIG_CHECK_STACK
+	lc->panic_stack = (unsigned long)
+		__alloc_bootmem(PAGE_SIZE, PAGE_SIZE, 0) + PAGE_SIZE;
+#endif
+	lc->current_task = (unsigned long) init_thread_union.thread_info.task;
+	lc->thread_info = (unsigned long) &init_thread_union;
+#ifdef CONFIG_ARCH_S390X
+	if (MACHINE_HAS_DIAG44)
+		lc->diag44_opcode = 0x83000044;
+	else
+		lc->diag44_opcode = 0x07000700;
+#endif /* CONFIG_ARCH_S390X */
+	set_prefix((u32)(unsigned long) lc);
+}
+
+static void __init
+setup_resources(void)
+{
+	struct resource *res;
+	int i;
+
+	for (i = 0; i < MEMORY_CHUNKS && memory_chunk[i].size > 0; i++) {
+		res = alloc_bootmem_low(sizeof(struct resource));
+		res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;
+		switch (memory_chunk[i].type) {
+		case CHUNK_READ_WRITE:
+			res->name = "System RAM";
+			break;
+		case CHUNK_READ_ONLY:
+			res->name = "System ROM";
+			res->flags |= IORESOURCE_READONLY;
+			break;
+		default:
+			res->name = "reserved";
+		}
+		res->start = memory_chunk[i].addr;
+		res->end = memory_chunk[i].addr +  memory_chunk[i].size - 1;
+		request_resource(&iomem_resource, res);
+		request_resource(res, &code_resource);
+		request_resource(res, &data_resource);
+	}
+}
+
+static void __init
+setup_memory(void)
+{
+        unsigned long bootmap_size;
+	unsigned long start_pfn, end_pfn, init_pfn;
+	unsigned long last_rw_end;
+	int i;
 
 	/*
 	 * partially used pages are not usable - thus
@@ -429,6 +482,10 @@ void __init setup_arch(char **cmdline_p)
 	start_pfn = (__pa(&_end) + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	end_pfn = max_pfn = memory_end >> PAGE_SHIFT;
 
+	/* Initialize storage key for kernel pages */
+	for (init_pfn = 0 ; init_pfn < start_pfn; init_pfn++)
+		page_set_storage_key(init_pfn << PAGE_SHIFT, PAGE_DEFAULT_KEY);
+
 	/*
 	 * Initialize the boot-time allocator (with low memory only):
 	 */
@@ -437,7 +494,9 @@ void __init setup_arch(char **cmdline_p)
 	/*
 	 * Register RAM areas with the bootmem allocator.
 	 */
-	for (i = 0; i < 16 && memory_chunk[i].size > 0; i++) {
+	last_rw_end = start_pfn;
+
+	for (i = 0; i < MEMORY_CHUNKS && memory_chunk[i].size > 0; i++) {
 		unsigned long start_chunk, end_chunk;
 
 		if (memory_chunk[i].type != CHUNK_READ_WRITE)
@@ -450,102 +509,98 @@ void __init setup_arch(char **cmdline_p)
 			start_chunk = start_pfn;
 		if (end_chunk > end_pfn)
 			end_chunk = end_pfn;
-		if (start_chunk < end_chunk)
+		if (start_chunk < end_chunk) {
+			/* Initialize storage key for RAM pages */
+			for (init_pfn = start_chunk ; init_pfn < end_chunk;
+			     init_pfn++)
+				page_set_storage_key(init_pfn << PAGE_SHIFT,
+						     PAGE_DEFAULT_KEY);
 			free_bootmem(start_chunk << PAGE_SHIFT,
 				     (end_chunk - start_chunk) << PAGE_SHIFT);
+			if (last_rw_end < start_chunk)
+				add_memory_hole(last_rw_end, start_chunk - 1);
+			last_rw_end = end_chunk;
+		}
 	}
 
-        /*
-         * Reserve the bootmem bitmap itself as well. We do this in two
-         * steps (first step was init_bootmem()) because this catches
-         * the (very unlikely) case of us accidentally initializing the
-         * bootmem allocator with an invalid RAM area.
-         */
-        reserve_bootmem(start_pfn << PAGE_SHIFT, bootmap_size);
+	psw_set_key(PAGE_DEFAULT_KEY);
+
+	if (last_rw_end < end_pfn - 1)
+		add_memory_hole(last_rw_end, end_pfn - 1);
+
+	/*
+	 * Reserve the bootmem bitmap itself as well. We do this in two
+	 * steps (first step was init_bootmem()) because this catches
+	 * the (very unlikely) case of us accidentally initializing the
+	 * bootmem allocator with an invalid RAM area.
+	 */
+	reserve_bootmem(start_pfn << PAGE_SHIFT, bootmap_size);
 
 #ifdef CONFIG_BLK_DEV_INITRD
-        if (INITRD_START) {
+	if (INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= memory_end) {
 			reserve_bootmem(INITRD_START, INITRD_SIZE);
 			initrd_start = INITRD_START;
 			initrd_end = initrd_start + INITRD_SIZE;
 		} else {
-                        printk("initrd extends beyond end of memory "
-                               "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-                               initrd_start + INITRD_SIZE, memory_end);
-                        initrd_start = initrd_end = 0;
+			printk("initrd extends beyond end of memory "
+			       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
+			       initrd_start + INITRD_SIZE, memory_end);
+			initrd_start = initrd_end = 0;
 		}
-        }
+	}
 #endif
+}
 
-	for (i = 0; i < 16 && memory_chunk[i].size > 0; i++) {
-		struct resource *res;
-
-		res = alloc_bootmem_low(sizeof(struct resource));
-		res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;
-
-		switch (memory_chunk[i].type) {
-		case CHUNK_READ_WRITE:
-			res->name = "System RAM";
-			break;
-		case CHUNK_READ_ONLY:
-			res->name = "System ROM";
-			res->flags |= IORESOURCE_READONLY;
-			break;
-		default:
-			res->name = "reserved";
-		}
-		res->start = memory_chunk[i].addr;
-		res->end = memory_chunk[i].addr +  memory_chunk[i].size - 1;
-		request_resource(&iomem_resource, res);
-		request_resource(res, &code_resource);
-		request_resource(res, &data_resource);
-	}
+/*
+ * Setup function called from init/main.c just after the banner
+ * was printed.
+ */
 
+void __init
+setup_arch(char **cmdline_p)
+{
         /*
-         * Setup lowcore for boot cpu
+         * print what head.S has found out about the machine
          */
 #ifndef CONFIG_ARCH_S390X
-	lc = (struct _lowcore *) __alloc_bootmem(PAGE_SIZE, PAGE_SIZE, 0);
-	memset(lc, 0, PAGE_SIZE);
+	printk((MACHINE_IS_VM) ?
+	       "We are running under VM (31 bit mode)\n" :
+	       "We are running native (31 bit mode)\n");
+	printk((MACHINE_HAS_IEEE) ?
+	       "This machine has an IEEE fpu\n" :
+	       "This machine has no IEEE fpu\n");
 #else /* CONFIG_ARCH_S390X */
-	lc = (struct _lowcore *) __alloc_bootmem(2*PAGE_SIZE, 2*PAGE_SIZE, 0);
-	memset(lc, 0, 2*PAGE_SIZE);
+	printk((MACHINE_IS_VM) ?
+	       "We are running under VM (64 bit mode)\n" :
+	       "We are running native (64 bit mode)\n");
 #endif /* CONFIG_ARCH_S390X */
-	lc->restart_psw.mask = PSW_BASE_BITS;
-	lc->restart_psw.addr =
-		PSW_ADDR_AMODE | (unsigned long) restart_int_handler;
-	lc->external_new_psw.mask = PSW_KERNEL_BITS;
-	lc->external_new_psw.addr =
-		PSW_ADDR_AMODE | (unsigned long) ext_int_handler;
-	lc->svc_new_psw.mask = PSW_KERNEL_BITS | PSW_MASK_IO | PSW_MASK_EXT;
-	lc->svc_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) system_call;
-	lc->program_new_psw.mask = PSW_KERNEL_BITS;
-	lc->program_new_psw.addr =
-		PSW_ADDR_AMODE | (unsigned long)pgm_check_handler;
-	lc->mcck_new_psw.mask = PSW_KERNEL_BITS;
-	lc->mcck_new_psw.addr =
-		PSW_ADDR_AMODE | (unsigned long) mcck_int_handler;
-	lc->io_new_psw.mask = PSW_KERNEL_BITS;
-	lc->io_new_psw.addr = PSW_ADDR_AMODE | (unsigned long) io_int_handler;
-	lc->ipl_device = S390_lowcore.ipl_device;
-	lc->jiffy_timer = -1LL;
-	lc->kernel_stack = ((unsigned long) &init_thread_union) + THREAD_SIZE;
-	lc->async_stack = (unsigned long)
-		__alloc_bootmem(ASYNC_SIZE, ASYNC_SIZE, 0) + ASYNC_SIZE;
-#ifdef CONFIG_CHECK_STACK
-	lc->panic_stack = (unsigned long)
-		__alloc_bootmem(PAGE_SIZE, PAGE_SIZE, 0) + PAGE_SIZE;
-#endif
-	lc->current_task = (unsigned long) init_thread_union.thread_info.task;
-	lc->thread_info = (unsigned long) &init_thread_union;
-#ifdef CONFIG_ARCH_S390X
-	if (MACHINE_HAS_DIAG44)
-		lc->diag44_opcode = 0x83000044;
-	else
-		lc->diag44_opcode = 0x07000700;
+
+        ROOT_DEV = Root_RAM0;
+#ifndef CONFIG_ARCH_S390X
+	memory_end = memory_size & ~0x400000UL;  /* align memory end to 4MB */
+        /*
+         * We need some free virtual space to be able to do vmalloc.
+         * On a machine with 2GB memory we make sure that we have at
+         * least 128 MB free space for vmalloc.
+         */
+        if (memory_end > 1920*1024*1024)
+                memory_end = 1920*1024*1024;
+#else /* CONFIG_ARCH_S390X */
+	memory_end = memory_size & ~0x200000UL;  /* detected in head.s */
 #endif /* CONFIG_ARCH_S390X */
-	set_prefix((u32)(unsigned long) lc);
+
+	init_mm.start_code = PAGE_OFFSET;
+	init_mm.end_code = (unsigned long) &_etext;
+	init_mm.end_data = (unsigned long) &_edata;
+	init_mm.brk = (unsigned long) &_end;
+
+	parse_cmdline_early(cmdline_p);
+
+	setup_memory();
+	setup_resources();
+	setup_lowcore();
+
         cpu_init();
         __cpu_logical_map[0] = S390_lowcore.cpu_data.cpu_addr;
 
diff -purN linux-2.6.11/arch/s390/kernel/signal.c linux-2.6.12-rc6/arch/s390/kernel/signal.c
--- linux-2.6.11/arch/s390/kernel/signal.c	2005-03-02 08:38:18.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/signal.c	2005-06-06 17:22:29.000000000 +0200
@@ -116,7 +116,7 @@ sys_sigaction(int sig, const struct old_
 
 	if (act) {
 		old_sigset_t mask;
-		if (verify_area(VERIFY_READ, act, sizeof(*act)) ||
+		if (!access_ok(VERIFY_READ, act, sizeof(*act)) ||
 		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
 		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
 			return -EFAULT;
@@ -128,7 +128,7 @@ sys_sigaction(int sig, const struct old_
 	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
 
 	if (!ret && oact) {
-		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
+		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||
 		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
 		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
 			return -EFAULT;
@@ -214,7 +214,7 @@ asmlinkage long sys_sigreturn(struct pt_
 	sigframe __user *frame = (sigframe __user *)regs->gprs[15];
 	sigset_t set;
 
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE))
 		goto badframe;
@@ -240,7 +240,7 @@ asmlinkage long sys_rt_sigreturn(struct 
 	rt_sigframe __user *frame = (rt_sigframe __user *)regs->gprs[15];
 	sigset_t set;
 
-	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&set.sig, &frame->uc.uc_sigmask, sizeof(set)))
 		goto badframe;
@@ -282,7 +282,7 @@ get_sigframe(struct k_sigaction *ka, str
 
 	/* This is the X/Open sanctioned signal stack switching.  */
 	if (ka->sa.sa_flags & SA_ONSTACK) {
-		if (! on_sig_stack(sp))
+		if (! sas_ss_flags(sp))
 			sp = current->sas_ss_sp + current->sas_ss_size;
 	}
 
diff -purN linux-2.6.11/arch/s390/kernel/smp.c linux-2.6.12-rc6/arch/s390/kernel/smp.c
--- linux-2.6.11/arch/s390/kernel/smp.c	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/smp.c	2005-06-06 17:22:29.000000000 +0200
@@ -50,12 +50,9 @@ extern volatile int __cpu_logical_map[];
  */
 
 struct _lowcore *lowcore_ptr[NR_CPUS];
-cycles_t         cacheflush_time=0;
-int              smp_threads_ready=0;      /* Set when the idlers are all forked. */
 
 cpumask_t cpu_online_map;
 cpumask_t cpu_possible_map;
-unsigned long    cache_decay_ticks = 0;
 
 static struct task_struct *current_set[NR_CPUS];
 
@@ -212,29 +209,29 @@ EXPORT_SYMBOL(smp_call_function_on);
 
 static inline void do_send_stop(void)
 {
-        int i, rc;
+        int cpu, rc;
 
         /* stop all processors */
-        for (i =  0; i < NR_CPUS; i++) {
-                if (!cpu_online(i) || smp_processor_id() == i)
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id())
 			continue;
 		do {
-			rc = signal_processor(i, sigp_stop);
+			rc = signal_processor(cpu, sigp_stop);
 		} while (rc == sigp_busy);
 	}
 }
 
 static inline void do_store_status(void)
 {
-        int i, rc;
+        int cpu, rc;
 
         /* store status of all processors in their lowcores (real 0) */
-        for (i =  0; i < NR_CPUS; i++) {
-                if (!cpu_online(i) || smp_processor_id() == i) 
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id())
 			continue;
 		do {
 			rc = signal_processor_p(
-				(__u32)(unsigned long) lowcore_ptr[i], i,
+				(__u32)(unsigned long) lowcore_ptr[cpu], cpu,
 				sigp_store_status_at_address);
 		} while(rc == sigp_busy);
         }
@@ -259,37 +256,41 @@ void smp_send_stop(void)
 /*
  * Reboot, halt and power_off routines for SMP.
  */
-static cpumask_t cpu_restart_map;
 
 static void do_machine_restart(void * __unused)
 {
+	int cpu;
 	static atomic_t cpuid = ATOMIC_INIT(-1);
 
-	cpu_clear(smp_processor_id(), cpu_restart_map);
-	if (atomic_compare_and_swap(-1, smp_processor_id(), &cpuid) == 0) {
-		/* Wait for all other cpus to enter do_machine_restart. */
-		while (!cpus_empty(cpu_restart_map))
+	if (atomic_compare_and_swap(-1, smp_processor_id(), &cpuid))
+		signal_processor(smp_processor_id(), sigp_stop);
+
+	/* Wait for all other cpus to enter stopped state */
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id())
+			continue;
+		while(!smp_cpu_not_running(cpu))
 			cpu_relax();
-		/* Store status of other cpus. */
-		do_store_status();
-		/*
-		 * Finally call reipl. Because we waited for all other
-		 * cpus to enter this function we know that they do
-		 * not hold any s390irq-locks (the cpus have been
-		 * interrupted by an external interrupt and s390irq
-		 * locks are always held disabled).
-		 */
-		if (MACHINE_IS_VM)
-			cpcmd ("IPL", NULL, 0);
-		else
-			reipl (0x10000 | S390_lowcore.ipl_device);
 	}
-	signal_processor(smp_processor_id(), sigp_stop);
+
+	/* Store status of other cpus. */
+	do_store_status();
+
+	/*
+	 * Finally call reipl. Because we waited for all other
+	 * cpus to enter this function we know that they do
+	 * not hold any s390irq-locks (the cpus have been
+	 * interrupted by an external interrupt and s390irq
+	 * locks are always held disabled).
+	 */
+	if (MACHINE_IS_VM)
+		cpcmd ("IPL", NULL, 0);
+	else
+		reipl (0x10000 | S390_lowcore.ipl_device);
 }
 
 void machine_restart_smp(char * __unused) 
 {
-	cpu_restart_map = cpu_online_map;
         on_each_cpu(do_machine_restart, NULL, 0, 0);
 }
 
@@ -384,16 +385,16 @@ static void smp_ext_bitcall(int cpu, ec_
  */
 static void smp_ext_bitcall_others(ec_bit_sig sig)
 {
-        int i;
+        int cpu;
 
-        for (i = 0; i < NR_CPUS; i++) {
-                if (!cpu_online(i) || smp_processor_id() == i)
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id())
                         continue;
                 /*
                  * Set signaling bit in lowcore of target cpu and kick it
                  */
-		set_bit(sig, (unsigned long *) &lowcore_ptr[i]->ext_call_fast);
-                while (signal_processor(i, sigp_external_call) == sigp_busy)
+		set_bit(sig, (unsigned long *) &lowcore_ptr[cpu]->ext_call_fast);
+		while (signal_processor(cpu, sigp_external_call) == sigp_busy)
 			udelay(10);
         }
 }
@@ -497,7 +498,6 @@ __init smp_check_cpus(unsigned int max_c
 	 */
 
 	boot_cpu_addr = S390_lowcore.cpu_data.cpu_addr;
-	__cpu_logical_map[0] = boot_cpu_addr;
 	current_thread_info()->cpu = 0;
 	num_cpus = 1;
 	for (cpu = 0; cpu <= 65535 && num_cpus < max_cpus; cpu++) {
@@ -725,7 +725,7 @@ void
 __cpu_die(unsigned int cpu)
 {
 	/* Wait until target cpu is down */
-	while (!cpu_stopped(cpu))
+	while (!smp_cpu_not_running(cpu))
 		cpu_relax();
 	printk("Processor %d spun down\n", cpu);
 }
@@ -790,6 +790,7 @@ void __devinit smp_prepare_boot_cpu(void
 	BUG_ON(smp_processor_id() != 0);
 
 	cpu_set(0, cpu_online_map);
+	cpu_set(0, cpu_present_map);
 	cpu_set(0, cpu_possible_map);
 	S390_lowcore.percpu_offset = __per_cpu_offset[0];
 	current_set[0] = current;
diff -purN linux-2.6.11/arch/s390/kernel/syscalls.S linux-2.6.12-rc6/arch/s390/kernel/syscalls.S
--- linux-2.6.11/arch/s390/kernel/syscalls.S	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/syscalls.S	2005-06-06 17:22:29.000000000 +0200
@@ -275,7 +275,7 @@ NI_SYSCALL							/* reserved for vserver
 SYSCALL(s390_fadvise64_64,sys_ni_syscall,sys32_fadvise64_64_wrapper)
 SYSCALL(sys_statfs64,sys_statfs64,compat_sys_statfs64_wrapper)
 SYSCALL(sys_fstatfs64,sys_fstatfs64,compat_sys_fstatfs64_wrapper)
-NI_SYSCALL							/* 267 new sys_remap_file_pages */
+SYSCALL(sys_remap_file_pages,sys_remap_file_pages,sys32_remap_file_pages_wrapper)
 NI_SYSCALL							/* 268 sys_mbind */
 NI_SYSCALL							/* 269 sys_get_mempolicy */
 NI_SYSCALL							/* 270 sys_set_mempolicy */
@@ -286,3 +286,6 @@ SYSCALL(sys_mq_timedreceive,sys_mq_timed
 SYSCALL(sys_mq_notify,sys_mq_notify,compat_sys_mq_notify_wrapper) /* 275 */
 SYSCALL(sys_mq_getsetattr,sys_mq_getsetattr,compat_sys_mq_getsetattr_wrapper)
 NI_SYSCALL							/* reserved for kexec */
+SYSCALL(sys_add_key,sys_add_key,compat_sys_add_key_wrapper)
+SYSCALL(sys_request_key,sys_request_key,compat_sys_request_key_wrapper)
+SYSCALL(sys_keyctl,sys_keyctl,compat_sys_keyctl)		/* 280 */
diff -purN linux-2.6.11/arch/s390/kernel/time.c linux-2.6.12-rc6/arch/s390/kernel/time.c
--- linux-2.6.11/arch/s390/kernel/time.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/time.c	2005-06-06 17:22:29.000000000 +0200
@@ -168,8 +168,17 @@ void account_ticks(struct pt_regs *regs)
 	__u32 ticks, xticks;
 
 	/* Calculate how many ticks have passed. */
-	if (S390_lowcore.int_clock < S390_lowcore.jiffy_timer)
+	if (S390_lowcore.int_clock < S390_lowcore.jiffy_timer) {
+		/*
+		 * We have to program the clock comparator even if
+		 * no tick has passed. That happens if e.g. an i/o
+		 * interrupt wakes up an idle processor that has
+		 * switched off its hz timer.
+		 */
+		tmp = S390_lowcore.jiffy_timer + CPU_DEVIATION;
+		asm volatile ("SCKC %0" : : "m" (tmp));
 		return;
+	}
 	tmp = S390_lowcore.int_clock - S390_lowcore.jiffy_timer;
 	if (tmp >= 2*CLK_TICKS_PER_JIFFY) {  /* more than two ticks ? */
 		ticks = __div(tmp, CLK_TICKS_PER_JIFFY) + 1;
@@ -235,7 +244,7 @@ int sysctl_hz_timer = 1;
  */
 static inline void stop_hz_timer(void)
 {
-	__u64 timer;
+	__u64 timer, todval;
 
 	if (sysctl_hz_timer != 0)
 		return;
@@ -256,8 +265,14 @@ static inline void stop_hz_timer(void)
 	 * for the next event.
 	 */
 	timer = (__u64) (next_timer_interrupt() - jiffies) + jiffies_64;
-	timer = jiffies_timer_cc + timer * CLK_TICKS_PER_JIFFY;
-	asm volatile ("SCKC %0" : : "m" (timer));
+	todval = -1ULL;
+	/* Be careful about overflows. */
+	if (timer < (-1ULL / CLK_TICKS_PER_JIFFY)) {
+		timer = jiffies_timer_cc + timer * CLK_TICKS_PER_JIFFY;
+		if (timer >= jiffies_timer_cc)
+			todval = timer;
+	}
+	asm volatile ("SCKC %0" : : "m" (todval));
 }
 
 /*
diff -purN linux-2.6.11/arch/s390/kernel/vtime.c linux-2.6.12-rc6/arch/s390/kernel/vtime.c
--- linux-2.6.11/arch/s390/kernel/vtime.c	2005-03-02 08:38:26.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/kernel/vtime.c	2005-06-06 17:22:29.000000000 +0200
@@ -120,12 +122,17 @@ static void start_cpu_timer(void)
 	struct vtimer_queue *vt_list;
 
 	vt_list = &per_cpu(virt_cpu_timer, smp_processor_id());
-	set_vtimer(vt_list->idle);
+
+	/* CPU timer interrupt is pending, don't reprogramm it */
+	if (vt_list->idle & 1LL<<63)
+		return;
+
+	if (!list_empty(&vt_list->list))
+		set_vtimer(vt_list->idle);
 }
 
 static void stop_cpu_timer(void)
 {
-	__u64 done;
 	struct vtimer_queue *vt_list;
 
 	vt_list = &per_cpu(virt_cpu_timer, smp_processor_id());
@@ -136,21 +143,17 @@ static void stop_cpu_timer(void)
 		goto fire;
 	}
 
-	/* store progress */
-	asm volatile ("STPT %0" : "=m" (done));
+	/* store the actual expire value */
+	asm volatile ("STPT %0" : "=m" (vt_list->idle));
 
 	/*
-	 * If done is negative we do not stop the CPU timer
-	 * because we will get instantly an interrupt that
-	 * will start the CPU timer again.
+	 * If the CPU timer is negative we don't reprogramm
+	 * it because we will get instantly an interrupt.
 	 */
-	if (done & 1LL<<63)
+	if (vt_list->idle & 1LL<<63)
 		return;
-	else
-		vt_list->offset += vt_list->to_expire - done;
 
-	/* save the actual expire value */
-	vt_list->idle = done;
+	vt_list->offset += vt_list->to_expire - vt_list->idle;
 
 	/*
 	 * We cannot halt the CPU timer, we just write a value that
diff -purN linux-2.6.11/arch/s390/Makefile linux-2.6.12-rc6/arch/s390/Makefile
--- linux-2.6.11/arch/s390/Makefile	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/Makefile	2005-06-06 17:22:29.000000000 +0200
@@ -66,7 +66,7 @@ cflags-$(CONFIG_WARN_STACK) += -mwarn-dy
 cflags-$(CONFIG_WARN_STACK) += -mwarn-framesize=$(CONFIG_WARN_STACK_SIZE)
 endif
 
-CFLAGS		+= -mbackchain $(cflags-y)
+CFLAGS		+= -mbackchain -msoft-float $(cflags-y)
 CFLAGS		+= $(call cc-option,-finline-limit=10000)
 CFLAGS 		+= -pipe -fno-strength-reduce -Wno-sign-compare 
 AFLAGS		+= $(aflags-y)
diff -purN linux-2.6.11/arch/s390/mm/cmm.c linux-2.6.12-rc6/arch/s390/mm/cmm.c
--- linux-2.6.11/arch/s390/mm/cmm.c	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/mm/cmm.c	2005-06-06 17:22:29.000000000 +0200
@@ -20,6 +20,11 @@
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
 
+static char *sender = "VMRMSVM";
+module_param(sender, charp, 0);
+MODULE_PARM_DESC(sender,
+		 "Guest name that may send SMSG messages (default VMRMSVM)");
+
 #include "../../../drivers/s390/net/smsgiucv.h"
 
 #define CMM_NR_PAGES ((PAGE_SIZE / sizeof(unsigned long)) - 2)
@@ -367,10 +372,12 @@ static struct ctl_table cmm_dir_table[] 
 #ifdef CONFIG_CMM_IUCV
 #define SMSG_PREFIX "CMM"
 static void
-cmm_smsg_target(char *msg)
+cmm_smsg_target(char *from, char *msg)
 {
 	long pages, seconds;
 
+	if (strlen(sender) > 0 && strcmp(from, sender) != 0)
+		return;
 	if (!cmm_skip_blanks(msg + strlen(SMSG_PREFIX), &msg))
 		return;
 	if (strncmp(msg, "SHRINK", 6) == 0) {
diff -purN linux-2.6.11/arch/s390/mm/fault.c linux-2.6.12-rc6/arch/s390/mm/fault.c
--- linux-2.6.11/arch/s390/mm/fault.c	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/mm/fault.c	2005-06-06 17:22:29.000000000 +0200
@@ -62,8 +62,8 @@ void bust_spinlocks(int yes)
 		oops_in_progress = 1;
 	} else {
 		int loglevel_save = console_loglevel;
-		oops_in_progress = 0;
 		console_unblank();
+		oops_in_progress = 0;
 		/*
 		 * OK, the message is on the console.  Now we call printk()
 		 * without oops_in_progress set so that printk will give klogd
@@ -87,6 +87,7 @@ static int __check_access_register(struc
 	if (areg == 0)
 		/* Access via access register 0 -> kernel address */
 		return 0;
+	save_access_regs(current->thread.acrs);
 	if (regs && areg < NUM_ACRS && current->thread.acrs[areg] <= 1)
 		/*
 		 * access register contains 0 -> kernel address,
@@ -115,11 +116,11 @@ static inline int check_user_space(struc
 	 *   3: Home Segment Table Descriptor
 	 */
 	int descriptor = S390_lowcore.trans_exc_code & 3;
-	if (descriptor == 1) {
-		save_access_regs(current->thread.acrs);
+	if (unlikely(descriptor == 1))
 		return __check_access_register(regs, error_code);
-	}
-	return descriptor >> 1;
+	if (descriptor == 2)
+		return current->thread.mm_segment.ar4;
+	return descriptor != 0;
 }
 
 /*
@@ -206,7 +207,7 @@ do_exception(struct pt_regs *regs, unsig
 	 * we are not in an interrupt and that there is a 
 	 * user context.
 	 */
-        if (user_address == 0 || in_interrupt() || !mm)
+        if (user_address == 0 || in_atomic() || !mm)
                 goto no_context;
 
 	/*
diff -purN linux-2.6.11/arch/s390/oprofile/Kconfig linux-2.6.12-rc6/arch/s390/oprofile/Kconfig
--- linux-2.6.11/arch/s390/oprofile/Kconfig	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/arch/s390/oprofile/Kconfig	2005-06-06 17:22:29.000000000 +0200
@@ -1,16 +1,15 @@
 
 menu "Profiling support"
-	depends on EXPERIMENTAL
 
 config PROFILING
-	bool "Profiling support (EXPERIMENTAL)"
+	bool "Profiling support"
 	help
 	  Say Y here to enable profiling support mechanisms used by
 	  profilers such as readprofile or OProfile.
 
 
 config OPROFILE
-	tristate "OProfile system profiling (EXPERIMENTAL)"
+	tristate "OProfile system profiling"
 	depends on PROFILING
 	help
 	  OProfile is a profiling system capable of profiling the
diff -purN linux-2.6.11/drivers/s390/block/dasd.c linux-2.6.12-rc6/drivers/s390/block/dasd.c
--- linux-2.6.11/drivers/s390/block/dasd.c	2005-03-02 08:38:08.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd.c	2005-06-06 17:22:29.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.156 $
+ * $Revision: 1.164 $
  */
 
 #include <linux/config.h>
@@ -757,6 +757,17 @@ dasd_start_IO(struct dasd_ccw_req * cqr)
 		DBF_DEV_EVENT(DBF_ERR, device, "%s",
 			      "start_IO: request timeout, retry later");
 		break;
+	case -EACCES:
+		/* -EACCES indicates that the request used only a
+		 * subset of the available pathes and all these
+		 * pathes are gone.
+		 * Do a retry with all available pathes.
+		 */
+		cqr->lpm = LPM_ANYPATH;
+		DBF_DEV_EVENT(DBF_ERR, device, "%s",
+			      "start_IO: selected pathes gone,"
+			      " retry on all pathes");
+		break;
 	case -ENODEV:
 	case -EIO:
 		DBF_DEV_EVENT(DBF_ERR, device, "%s",
@@ -1120,13 +1131,17 @@ __dasd_process_blk_queue(struct dasd_dev
 	request_queue_t *queue;
 	struct request *req;
 	struct dasd_ccw_req *cqr;
-	int nr_queued;
+	int nr_queued, feature_ro;
 
 	queue = device->request_queue;
 	/* No queue ? Then there is nothing to do. */
 	if (queue == NULL)
 		return;
 
+	feature_ro = dasd_get_feature(device->cdev, DASD_FEATURE_READONLY);
+	if (feature_ro < 0) 	/* no devmap */
+		return;
+
 	/*
 	 * We requeue request from the block device queue to the ccw
 	 * queue only in two states. In state DASD_STATE_READY the
@@ -1146,8 +1161,8 @@ __dasd_process_blk_queue(struct dasd_dev
 	       elv_next_request(queue) &&
 		nr_queued < DASD_CHANQ_MAX_SIZE) {
 		req = elv_next_request(queue);
-		if (test_bit(DASD_FLAG_RO, &device->flags) &&
-		    rq_data_dir(req) == WRITE) {
+
+		if (feature_ro && rq_data_dir(req) == WRITE) {
 			DBF_DEV_EVENT(DBF_ERR, device,
 				      "Rejecting write request %p",
 				      req);
@@ -1222,7 +1237,9 @@ __dasd_start_head(struct dasd_device * d
 		rc = device->discipline->start_IO(cqr);
 		if (rc == 0)
 			dasd_set_timer(device, cqr->expires);
-		else
+		else if (rc == -EACCES) {
+			dasd_schedule_bh(device);
+		} else
 			/* Hmpf, try again in 1/2 sec */
 			dasd_set_timer(device, 50);
 	}
@@ -1618,6 +1635,7 @@ dasd_setup_queue(struct dasd_device * de
 	blk_queue_max_hw_segments(device->request_queue, -1L);
 	blk_queue_max_segment_size(device->request_queue, -1L);
 	blk_queue_segment_boundary(device->request_queue, -1L);
+	blk_queue_ordered(device->request_queue, 1);
 }
 
 /*
@@ -1748,10 +1766,10 @@ dasd_generic_probe (struct ccw_device *c
 		printk(KERN_WARNING
 		       "dasd_generic_probe: could not add sysfs entries "
 		       "for %s\n", cdev->dev.bus_id);
+	} else {
+		cdev->handler = &dasd_int_handler;
 	}
 
-	cdev->handler = &dasd_int_handler;
-
 	return ret;
 }
 
@@ -1762,6 +1780,8 @@ dasd_generic_remove (struct ccw_device *
 {
 	struct dasd_device *device;
 
+	cdev->handler = NULL;
+
 	dasd_remove_sysfs_files(cdev);
 	device = dasd_device_from_cdev(cdev);
 	if (IS_ERR(device))
@@ -1790,13 +1810,17 @@ dasd_generic_set_online (struct ccw_devi
 
 {
 	struct dasd_device *device;
-	int rc;
+	int feature_diag, rc;
 
 	device = dasd_create_device(cdev);
 	if (IS_ERR(device))
 		return PTR_ERR(device);
 
-	if (test_bit(DASD_FLAG_USE_DIAG, &device->flags)) {
+	feature_diag = dasd_get_feature(cdev, DASD_FEATURE_USEDIAG);
+	if (feature_diag < 0)
+		return feature_diag;
+
+	if (feature_diag) {
 	  	if (!dasd_diag_discipline_pointer) {
 		        printk (KERN_WARNING
 				"dasd_generic couldn't online device %s "
@@ -1813,8 +1837,8 @@ dasd_generic_set_online (struct ccw_devi
 	if (rc) {
 		printk (KERN_WARNING
 			"dasd_generic couldn't online device %s "
-			"with discipline %s\n", 
-			cdev->dev.bus_id, discipline->name);
+			"with discipline %s rc=%i\n",
+			cdev->dev.bus_id, discipline->name, rc);
 		dasd_delete_device(device);
 		return rc;
 	}
diff -purN linux-2.6.11/drivers/s390/block/dasd_cmb.c linux-2.6.12-rc6/drivers/s390/block/dasd_cmb.c
--- linux-2.6.11/drivers/s390/block/dasd_cmb.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_cmb.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/s390/block/dasd_cmb.c ($Revision: 1.6 $)
+ * linux/drivers/s390/block/dasd_cmb.c ($Revision: 1.9 $)
  *
  * Linux on zSeries Channel Measurement Facility support
  *  (dasd device driver interface)
@@ -23,7 +23,6 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/init.h>
-#include <linux/ioctl32.h>
 #include <linux/module.h>
 #include <asm/ccwdev.h>
 #include <asm/cmb.h>
@@ -84,27 +83,13 @@ dasd_ioctl_readall_cmb(struct block_devi
 static inline int
 ioctl_reg(unsigned int no, dasd_ioctl_fn_t handler)
 {
-	int ret;
-	ret = dasd_ioctl_no_register(THIS_MODULE, no, handler);
-#ifdef CONFIG_COMPAT
-	if (ret)
-		return ret;
-
-	ret = register_ioctl32_conversion(no, NULL);
-	if (ret)
-		dasd_ioctl_no_unregister(THIS_MODULE, no, handler);
-#endif
-	return ret;
+	return dasd_ioctl_no_register(THIS_MODULE, no, handler);
 }
 
 static inline void
 ioctl_unreg(unsigned int no, dasd_ioctl_fn_t handler)
 {
 	dasd_ioctl_no_unregister(THIS_MODULE, no, handler);
-#ifdef CONFIG_COMPAT
-	unregister_ioctl32_conversion(no);
-#endif
-
 }
 
 static void
diff -purN linux-2.6.11/drivers/s390/block/dasd_devmap.c linux-2.6.12-rc6/drivers/s390/block/dasd_devmap.c
--- linux-2.6.11/drivers/s390/block/dasd_devmap.c	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_devmap.c	2005-06-06 17:22:29.000000000 +0200
@@ -11,7 +11,7 @@
  * functions may not be called from interrupt context. In particular
  * dasd_get_device is a no-no from interrupt context.
  *
- * $Revision: 1.37 $
+ * $Revision: 1.40 $
  */
 
 #include <linux/config.h>
@@ -513,14 +513,6 @@ dasd_create_device(struct ccw_device *cd
 	if (!devmap->device) {
 		devmap->device = device;
 		device->devindex = devmap->devindex;
-		if (devmap->features & DASD_FEATURE_READONLY)
-			set_bit(DASD_FLAG_RO, &device->flags);
-		else
-			clear_bit(DASD_FLAG_RO, &device->flags);
-		if (devmap->features & DASD_FEATURE_USEDIAG)
-			set_bit(DASD_FLAG_USE_DIAG, &device->flags);
-		else
-			clear_bit(DASD_FLAG_USE_DIAG, &device->flags);
 		get_device(&cdev->dev);
 		device->cdev = cdev;
 		rc = 0;
@@ -651,14 +643,8 @@ dasd_ro_store(struct device *dev, const 
 		devmap->features |= DASD_FEATURE_READONLY;
 	else
 		devmap->features &= ~DASD_FEATURE_READONLY;
-	if (devmap->device) {
-		if (devmap->device->gdp)
-			set_disk_ro(devmap->device->gdp, ro_flag);
-		if (ro_flag)
-			set_bit(DASD_FLAG_RO, &devmap->device->flags);
-		else
-			clear_bit(DASD_FLAG_RO, &devmap->device->flags);
-	}
+	if (devmap->device && devmap->device->gdp)
+		set_disk_ro(devmap->device->gdp, ro_flag);
 	spin_unlock(&dasd_devmap_lock);
 	return count;
 }
@@ -739,6 +725,45 @@ static struct attribute_group dasd_attr_
 	.attrs = dasd_attrs,
 };
 
+/*
+ * Return value of the specified feature.
+ */
+int
+dasd_get_feature(struct ccw_device *cdev, int feature)
+{
+	struct dasd_devmap *devmap;
+
+	devmap = dasd_find_busid(cdev->dev.bus_id);
+	if (IS_ERR(devmap))
+		return (int) PTR_ERR(devmap);
+
+	return ((devmap->features & feature) != 0);
+}
+
+/*
+ * Set / reset given feature.
+ * Flag indicates wether to set (!=0) or the reset (=0) the feature.
+ */
+int
+dasd_set_feature(struct ccw_device *cdev, int feature, int flag)
+{
+	struct dasd_devmap *devmap;
+
+	devmap = dasd_find_busid(cdev->dev.bus_id);
+	if (IS_ERR(devmap))
+		return (int) PTR_ERR(devmap);
+
+	spin_lock(&dasd_devmap_lock);
+	if (flag)
+		devmap->features |= feature;
+	else
+		devmap->features &= ~feature;
+
+	spin_unlock(&dasd_devmap_lock);
+	return 0;
+}
+
+
 int
 dasd_add_sysfs_files(struct ccw_device *cdev)
 {
diff -purN linux-2.6.11/drivers/s390/block/dasd_eckd.c linux-2.6.12-rc6/drivers/s390/block/dasd_eckd.c
--- linux-2.6.11/drivers/s390/block/dasd_eckd.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_eckd.c	2005-06-06 17:22:29.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.68 $
+ * $Revision: 1.71 $
  */
 
 #include <linux/config.h>
@@ -56,6 +56,7 @@ static struct dasd_discipline dasd_eckd_
 struct dasd_eckd_private {
 	struct dasd_eckd_characteristics rdc_data;
 	struct dasd_eckd_confdata conf_data;
+	struct dasd_eckd_path path_data;
 	struct eckd_count count_area[5];
 	int init_cqr_status;
 	int uses_cdl;
@@ -447,12 +448,72 @@ dasd_eckd_cdl_reclen(int recid)
 }
 
 static int
+dasd_eckd_read_conf(struct dasd_device *device)
+{
+	void *conf_data;
+	int conf_len, conf_data_saved;
+	int rc;
+	__u8 lpm;
+	struct dasd_eckd_private *private;
+	struct dasd_eckd_path *path_data;
+
+	private = (struct dasd_eckd_private *) device->private;
+	path_data = (struct dasd_eckd_path *) &private->path_data;
+	path_data->opm = ccw_device_get_path_mask(device->cdev);
+	lpm = 0x80;
+	conf_data_saved = 0;
+
+	/* get configuration data per operational path */
+	for (lpm = 0x80; lpm; lpm>>= 1) {
+		if (lpm & path_data->opm){
+			rc = read_conf_data_lpm(device->cdev, &conf_data,
+						&conf_len, lpm);
+			if (rc && rc != -EOPNOTSUPP) {	/* -EOPNOTSUPP is ok */
+				MESSAGE(KERN_WARNING,
+					"Read configuration data returned "
+					"error %d", rc);
+				return rc;
+			}
+			if (conf_data == NULL) {
+				MESSAGE(KERN_WARNING, "%s", "No configuration "
+					"data retrieved");
+				continue;	/* no errror */
+			}
+			if (conf_len != sizeof (struct dasd_eckd_confdata)) {
+				MESSAGE(KERN_WARNING,
+					"sizes of configuration data mismatch"
+					"%d (read) vs %ld (expected)",
+					conf_len,
+					sizeof (struct dasd_eckd_confdata));
+				kfree(conf_data);
+				continue;	/* no errror */
+			}
+			/* save first valid configuration data */
+			if (!conf_data_saved){
+				memcpy(&private->conf_data, conf_data,
+				       sizeof (struct dasd_eckd_confdata));
+				conf_data_saved++;
+			}
+			switch (((char *)conf_data)[242] & 0x07){
+			case 0x02:
+				path_data->npm |= lpm;
+				break;
+			case 0x03:
+				path_data->ppm |= lpm;
+				break;
+			}
+			kfree(conf_data);
+		}
+	}
+	return 0;
+}
+
+
+static int
 dasd_eckd_check_characteristics(struct dasd_device *device)
 {
 	struct dasd_eckd_private *private;
 	void *rdc_data;
-	void *conf_data;
-	int conf_len;
 	int rc;
 
 	private = (struct dasd_eckd_private *) device->private;
@@ -465,6 +526,7 @@ dasd_eckd_check_characteristics(struct d
 				    "data");
 			return -ENOMEM;
 		}
+		memset(private, 0, sizeof(struct dasd_eckd_private));
 		device->private = (void *) private;
 	}
 	/* Invalidate status of initial analysis. */
@@ -494,30 +556,9 @@ dasd_eckd_check_characteristics(struct d
 		    private->rdc_data.sec_per_trk);
 
 	/* Read Configuration Data */
-	rc = read_conf_data(device->cdev, &conf_data, &conf_len);
-	if (rc && rc != -EOPNOTSUPP) {	/* -EOPNOTSUPP is ok */
-		DEV_MESSAGE(KERN_WARNING, device,
-			    "Read configuration data returned error %d", rc);
-		return rc;
-	}
-	if (conf_data == NULL) {
-		DEV_MESSAGE(KERN_WARNING, device, "%s",
-			    "No configuration data retrieved");
-		return 0;	/* no errror */
-	}
-	if (conf_len != sizeof (struct dasd_eckd_confdata)) {
-		DEV_MESSAGE(KERN_WARNING, device,
-			    "sizes of configuration data mismatch"
-			    "%d (read) vs %ld (expected)",
-			    conf_len, sizeof (struct dasd_eckd_confdata));
+	rc = dasd_eckd_read_conf (device);
+	return rc;
 
-		kfree(conf_data); /* allocated by read_conf_data() */
-		return 0;	/* no errror */
-	}
-	memcpy(&private->conf_data, conf_data,
-	       sizeof (struct dasd_eckd_confdata));
-	kfree(conf_data); /* allocated by read_conf_data() */
-	return 0;
 }
 
 static struct dasd_ccw_req *
@@ -1060,7 +1101,8 @@ dasd_eckd_build_cp(struct dasd_device * 
 				if (dasd_eckd_cdl_special(blk_per_trk, recid)){
 					rcmd |= 0x8;
 					count = dasd_eckd_cdl_reclen(recid);
-					if (count < blksize)
+					if (count < blksize &&
+					    rq_data_dir(req) == READ)
 						memset(dst + count, 0xe5,
 						       blksize - count);
 				}
@@ -1096,7 +1138,7 @@ dasd_eckd_build_cp(struct dasd_device * 
 	}
 	cqr->device = device;
 	cqr->expires = 5 * 60 * HZ;	/* 5 minutes */
-	cqr->lpm = LPM_ANYPATH;
+	cqr->lpm = private->path_data.ppm;
 	cqr->retries = 256;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
diff -purN linux-2.6.11/drivers/s390/block/dasd_eckd.h linux-2.6.12-rc6/drivers/s390/block/dasd_eckd.h
--- linux-2.6.11/drivers/s390/block/dasd_eckd.h	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_eckd.h	2005-06-06 17:22:29.000000000 +0200
@@ -5,7 +5,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.9 $
+ * $Revision: 1.10 $
  */
 
 #ifndef DASD_ECKD_H
@@ -326,6 +326,12 @@ struct dasd_eckd_confdata {
 	} __attribute__ ((packed)) neq;
 } __attribute__ ((packed));
 
+struct dasd_eckd_path {
+	__u8 opm;
+	__u8 ppm;
+	__u8 npm;
+};
+
 /*
  * Perform Subsystem Function - Prepare for Read Subsystem Data	 
  */
diff -purN linux-2.6.11/drivers/s390/block/dasd_erp.c linux-2.6.12-rc6/drivers/s390/block/dasd_erp.c
--- linux-2.6.11/drivers/s390/block/dasd_erp.c	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_erp.c	2005-06-06 17:22:29.000000000 +0200
@@ -7,7 +7,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
- * $Revision: 1.13 $
+ * $Revision: 1.14 $
  */
 
 #include <linux/config.h>
@@ -95,6 +95,7 @@ dasd_default_erp_action(struct dasd_ccw_
                 DEV_MESSAGE (KERN_DEBUG, device, 
                              "default ERP called (%i retries left)",
                              cqr->retries);
+		cqr->lpm    = LPM_ANYPATH;
 		cqr->status = DASD_CQR_QUEUED;
         } else {
                 DEV_MESSAGE (KERN_WARNING, device, "%s",
diff -purN linux-2.6.11/drivers/s390/block/dasd_genhd.c linux-2.6.12-rc6/drivers/s390/block/dasd_genhd.c
--- linux-2.6.11/drivers/s390/block/dasd_genhd.c	2005-03-02 08:38:17.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_genhd.c	2005-06-06 17:22:29.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * gendisk related functions for the dasd driver.
  *
- * $Revision: 1.48 $
+ * $Revision: 1.50 $
  */
 
 #include <linux/config.h>
@@ -31,12 +31,16 @@ int
 dasd_gendisk_alloc(struct dasd_device *device)
 {
 	struct gendisk *gdp;
-	int len;
+	int len, feature_ro;
 
 	/* Make sure the minor for this device exists. */
 	if (device->devindex >= DASD_PER_MAJOR)
 		return -EBUSY;
 
+	feature_ro = dasd_get_feature(device->cdev, DASD_FEATURE_READONLY);
+	if (feature_ro < 0)
+		return feature_ro;
+
 	gdp = alloc_disk(1 << DASD_PARTN_BITS);
 	if (!gdp)
 		return -ENOMEM;
@@ -71,7 +75,7 @@ dasd_gendisk_alloc(struct dasd_device *d
 
  	sprintf(gdp->devfs_name, "dasd/%s", device->cdev->dev.bus_id);
 
-	if (test_bit(DASD_FLAG_RO, &device->flags))
+	if (feature_ro)
 		set_disk_ro(gdp, 1);
 	gdp->private_data = device;
 	gdp->queue = device->request_queue;
diff -purN linux-2.6.11/drivers/s390/block/dasd_int.h linux-2.6.12-rc6/drivers/s390/block/dasd_int.h
--- linux-2.6.11/drivers/s390/block/dasd_int.h	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_int.h	2005-06-06 17:22:29.000000000 +0200
@@ -6,7 +6,7 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
- * $Revision: 1.63 $
+ * $Revision: 1.64 $
  */
 
 #ifndef DASD_INT_H
@@ -329,8 +329,6 @@ struct dasd_device {
 #define DASD_STOPPED_DC_EIO  16        /* disconnected, return -EIO */
 
 /* per device flags */
-#define DASD_FLAG_RO		0	/* device is read-only */
-#define DASD_FLAG_USE_DIAG	1	/* use diag disciplnie */
 #define DASD_FLAG_DSC_ERROR	2	/* return -EIO when disconnected */
 #define DASD_FLAG_OFFLINE	3	/* device is in offline processing */
 
@@ -501,6 +499,9 @@ void dasd_devmap_exit(void);
 struct dasd_device *dasd_create_device(struct ccw_device *);
 void dasd_delete_device(struct dasd_device *);
 
+int dasd_get_feature(struct ccw_device *, int);
+int dasd_set_feature(struct ccw_device *, int, int);
+
 int dasd_add_sysfs_files(struct ccw_device *);
 void dasd_remove_sysfs_files(struct ccw_device *);
 
diff -purN linux-2.6.11/drivers/s390/block/dasd_ioctl.c linux-2.6.12-rc6/drivers/s390/block/dasd_ioctl.c
--- linux-2.6.11/drivers/s390/block/dasd_ioctl.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_ioctl.c	2005-06-06 17:22:29.000000000 +0200
@@ -7,6 +7,8 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
+ * $Revision: 1.45 $
+ *
  * i/o controls for the dasd driver.
  */
 #include <linux/config.h>
@@ -294,6 +296,7 @@ dasd_ioctl_format(struct block_device *b
 {
 	struct dasd_device *device;
 	struct format_data_t fdata;
+	int feature_ro;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
@@ -304,7 +307,11 @@ dasd_ioctl_format(struct block_device *b
 
 	if (device == NULL)
 		return -ENODEV;
-	if (test_bit(DASD_FLAG_RO, &device->flags))
+
+	feature_ro = dasd_get_feature(device->cdev, DASD_FEATURE_READONLY);
+	if (feature_ro < 0)
+		return feature_ro;
+	if (feature_ro)
 		return -EROFS;
 	if (copy_from_user(&fdata, (void __user *) args,
 			   sizeof (struct format_data_t)))
@@ -377,7 +384,7 @@ dasd_ioctl_information(struct block_devi
 	struct dasd_device *device;
 	struct dasd_information2_t *dasd_info;
 	unsigned long flags;
-	int rc;
+	int rc, feature_ro;
 	struct ccw_device *cdev;
 
 	device = bdev->bd_disk->private_data;
@@ -387,6 +394,10 @@ dasd_ioctl_information(struct block_devi
 	if (!device->discipline->fill_info)
 		return -EINVAL;
 
+	feature_ro = dasd_get_feature(device->cdev, DASD_FEATURE_READONLY);
+	if (feature_ro < 0)
+		return feature_ro;
+
 	dasd_info = kmalloc(sizeof(struct dasd_information2_t), GFP_KERNEL);
 	if (dasd_info == NULL)
 		return -ENOMEM;
@@ -415,9 +426,8 @@ dasd_ioctl_information(struct block_devi
 	if ((device->state < DASD_STATE_READY) ||
 	    (dasd_check_blocksize(device->bp_block)))
 		dasd_info->format = DASD_FORMAT_NONE;
-	
-	dasd_info->features |= test_bit(DASD_FLAG_RO, &device->flags) ?
-		DASD_FEATURE_READONLY : DASD_FEATURE_DEFAULT;
+
+	dasd_info->features |= feature_ro;
 
 	if (device->discipline)
 		memcpy(dasd_info->type, device->discipline->name, 4);
@@ -460,7 +470,7 @@ static int
 dasd_ioctl_set_ro(struct block_device *bdev, int no, long args)
 {
 	struct dasd_device *device;
-	int intval;
+	int intval, rc;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
@@ -472,12 +482,11 @@ dasd_ioctl_set_ro(struct block_device *b
 	device =  bdev->bd_disk->private_data;
 	if (device == NULL)
 		return -ENODEV;
+
 	set_disk_ro(bdev->bd_disk, intval);
-	if (intval)
-		set_bit(DASD_FLAG_RO, &device->flags);
-	else
-		clear_bit(DASD_FLAG_RO, &device->flags);
-	return 0;
+	rc = dasd_set_feature(device->cdev, DASD_FEATURE_READONLY, intval);
+
+	return rc;
 }
 
 /*
diff -purN linux-2.6.11/drivers/s390/block/dasd_proc.c linux-2.6.12-rc6/drivers/s390/block/dasd_proc.c
--- linux-2.6.11/drivers/s390/block/dasd_proc.c	2005-03-02 08:37:50.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/block/dasd_proc.c	2005-06-06 17:22:29.000000000 +0200
@@ -9,7 +9,7 @@
  *
  * /proc interface for the dasd driver.
  *
- * $Revision: 1.30 $
+ * $Revision: 1.31 $
  */
 
 #include <linux/config.h>
@@ -54,6 +54,7 @@ dasd_devices_show(struct seq_file *m, vo
 {
 	struct dasd_device *device;
 	char *substr;
+	int feature;
 
 	device = dasd_device_from_devindex((unsigned long) v - 1);
 	if (IS_ERR(device))
@@ -77,7 +78,10 @@ dasd_devices_show(struct seq_file *m, vo
 	else
 		seq_printf(m, " is ????????");
 	/* Print devices features. */
-	substr = test_bit(DASD_FLAG_RO, &device->flags) ? "(ro)" : " ";
+	feature = dasd_get_feature(device->cdev, DASD_FEATURE_READONLY);
+	if (feature < 0)
+		return 0;
+	substr = feature ? "(ro)" : " ";
 	seq_printf(m, "%4s: ", substr);
 	/* Print device status information. */
 	switch ((device != NULL) ? device->state : -1) {
diff -purN linux-2.6.11/drivers/s390/char/keyboard.c linux-2.6.12-rc6/drivers/s390/char/keyboard.c
--- linux-2.6.11/drivers/s390/char/keyboard.c	2005-03-02 08:38:01.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/char/keyboard.c	2005-06-06 17:22:29.000000000 +0200
@@ -32,11 +32,11 @@ static k_handler_fn K_HANDLERS;
 static k_handler_fn *k_handler[16] = { K_HANDLERS };
 
 /* maximum values each key_handler can handle */
-static const int max_vals[] = {
+static const int kbd_max_vals[] = {
 	255, ARRAY_SIZE(func_table) - 1, NR_FN_HANDLER - 1, 0,
 	NR_DEAD - 1, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
-static const int NR_TYPES = ARRAY_SIZE(max_vals);
+static const int KBD_NR_TYPES = ARRAY_SIZE(kbd_max_vals);
 
 static unsigned char ret_diacr[NR_DEAD] = {
 	'`', '\'', '^', '~', '"', ','
@@ -360,7 +360,7 @@ do_kdsk_ioctl(struct kbd_data *kbd, stru
 		key_map = kbd->key_maps[tmp.kb_table];
 		if (key_map) {
 		    val = U(key_map[tmp.kb_index]);
-		    if (KTYP(val) >= NR_TYPES)
+		    if (KTYP(val) >= KBD_NR_TYPES)
 			val = K_HOLE;
 		} else
 		    val = (tmp.kb_index ? K_HOLE : K_NOSUCHMAP);
@@ -378,9 +378,9 @@ do_kdsk_ioctl(struct kbd_data *kbd, stru
 			break;
 		}
 
-		if (KTYP(tmp.kb_value) >= NR_TYPES)
+		if (KTYP(tmp.kb_value) >= KBD_NR_TYPES)
 			return -EINVAL;
-		if (KVAL(tmp.kb_value) > max_vals[KTYP(tmp.kb_value)])
+		if (KVAL(tmp.kb_value) > kbd_max_vals[KTYP(tmp.kb_value)])
 			return -EINVAL;
 
 		if (!(key_map = kbd->key_maps[tmp.kb_table])) {
diff -purN linux-2.6.11/drivers/s390/char/sclp_quiesce.c linux-2.6.12-rc6/drivers/s390/char/sclp_quiesce.c
--- linux-2.6.11/drivers/s390/char/sclp_quiesce.c	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/char/sclp_quiesce.c	2005-06-06 17:22:29.000000000 +0200
@@ -30,31 +30,16 @@ do_load_quiesce_psw(void * __unused)
 {
 	static atomic_t cpuid = ATOMIC_INIT(-1);
 	psw_t quiesce_psw;
-	__u32 status;
-	int i;
+	int cpu;
 
 	if (atomic_compare_and_swap(-1, smp_processor_id(), &cpuid))
 		signal_processor(smp_processor_id(), sigp_stop);
 	/* Wait for all other cpus to enter stopped state */
-	i = 1;
-	while (i < NR_CPUS) {
-		if (!cpu_online(i)) {
-			i++;
+	for_each_online_cpu(cpu) {
+		if (cpu == smp_processor_id())
 			continue;
-		}
-		switch (signal_processor_ps(&status, 0, i, sigp_sense)) {
-		case sigp_order_code_accepted:
-		case sigp_status_stored:
-			/* Check for stopped and check stop state */
-			if (status & 0x50)
-				i++;
-			break;
-		case sigp_busy:
-			break;
-		case sigp_not_operational:
-			i++;
-			break;
-		}
+		while(!smp_cpu_not_running(cpu))
+			cpu_relax();
 	}
 	/* Quiesce the last cpu with the special psw */
 	quiesce_psw.mask = PSW_BASE_BITS | PSW_MASK_WAIT;
diff -purN linux-2.6.11/drivers/s390/cio/chsc.c linux-2.6.12-rc6/drivers/s390/cio/chsc.c
--- linux-2.6.11/drivers/s390/cio/chsc.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/chsc.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/chsc.c
  *   S/390 common I/O routines -- channel subsystem call
- *   $Revision: 1.115 $
+ *   $Revision: 1.119 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -423,12 +423,12 @@ s390_process_res_acc (u8 chpid, __u16 fl
 			     sch->schib.pmcw.pam &
 			     sch->schib.pmcw.pom)
 			    | chp_mask) & sch->opm;
-		spin_unlock_irq(&sch->lock);
 		if (!old_lpm && sch->lpm)
 			device_trigger_reprobe(sch);
 		else if (sch->driver && sch->driver->verify)
 			sch->driver->verify(&sch->dev);
 
+		spin_unlock_irq(&sch->lock);
 		put_device(&sch->dev);
 		if (fla_mask != 0)
 			break;
@@ -703,6 +703,9 @@ __check_for_io_and_kill(struct subchanne
 {
 	int cc;
 
+	if (!device_is_online(sch))
+		/* cio could be doing I/O. */
+		return 0;
 	cc = stsch(sch->irq, &sch->schib);
 	if (cc)
 		return 0;
@@ -717,10 +720,12 @@ static inline void
 __s390_subchannel_vary_chpid(struct subchannel *sch, __u8 chpid, int on)
 {
 	int chp, old_lpm;
+	unsigned long flags;
 
 	if (!sch->ssd_info.valid)
 		return;
 	
+	spin_lock_irqsave(&sch->lock, flags);
 	old_lpm = sch->lpm;
 	for (chp = 0; chp < 8; chp++) {
 		if (sch->ssd_info.chpid[chp] != chpid)
@@ -751,6 +756,7 @@ __s390_subchannel_vary_chpid(struct subc
 		}
 		break;
 	}
+	spin_unlock_irqrestore(&sch->lock, flags);
 }
 
 static int
@@ -881,6 +887,27 @@ chp_status_write(struct device *dev, con
 
 static DEVICE_ATTR(status, 0644, chp_status_show, chp_status_write);
 
+static ssize_t
+chp_type_show(struct device *dev, char *buf)
+{
+	struct channel_path *chp = container_of(dev, struct channel_path, dev);
+
+	if (!chp)
+		return 0;
+	return sprintf(buf, "%x\n", chp->desc.desc);
+}
+
+static DEVICE_ATTR(type, 0444, chp_type_show, NULL);
+
+static struct attribute * chp_attrs[] = {
+	&dev_attr_status.attr,
+	&dev_attr_type.attr,
+	NULL,
+};
+
+static struct attribute_group chp_attr_group = {
+	.attrs = chp_attrs,
+};
 
 static void
 chp_release(struct device *dev)
@@ -891,6 +918,68 @@ chp_release(struct device *dev)
 	kfree(cp);
 }
 
+static int
+chsc_determine_channel_path_description(int chpid,
+					struct channel_path_desc *desc)
+{
+	int ccode, ret;
+
+	struct {
+		struct chsc_header request;
+		u32 : 24;
+		u32 first_chpid : 8;
+		u32 : 24;
+		u32 last_chpid : 8;
+		u32 zeroes1;
+		struct chsc_header response;
+		u32 zeroes2;
+		struct channel_path_desc desc;
+	} *scpd_area;
+
+	scpd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);
+	if (!scpd_area)
+		return -ENOMEM;
+
+	scpd_area->request = (struct chsc_header) {
+		.length = 0x0010,
+		.code   = 0x0002,
+	};
+
+	scpd_area->first_chpid = chpid;
+	scpd_area->last_chpid = chpid;
+
+	ccode = chsc(scpd_area);
+	if (ccode > 0) {
+		ret = (ccode == 3) ? -ENODEV : -EBUSY;
+		goto out;
+	}
+
+	switch (scpd_area->response.code) {
+	case 0x0001: /* Success. */
+		memcpy(desc, &scpd_area->desc,
+		       sizeof(struct channel_path_desc));
+		ret = 0;
+		break;
+	case 0x0003: /* Invalid block. */
+	case 0x0007: /* Invalid format. */
+	case 0x0008: /* Other invalid block. */
+		CIO_CRW_EVENT(2, "Error in chsc request block!\n");
+		ret = -EINVAL;
+		break;
+	case 0x0004: /* Command not provided in model. */
+		CIO_CRW_EVENT(2, "Model does not provide scpd\n");
+		ret = -EOPNOTSUPP;
+		break;
+	default:
+		CIO_CRW_EVENT(2, "Unknown CHSC response %d\n",
+			      scpd_area->response.code);
+		ret = -EIO;
+	}
+out:
+	free_page((unsigned long)scpd_area);
+	return ret;
+}
+
 /*
  * Entries for chpids on the system bus.
  * This replaces /proc/chpids.
@@ -915,6 +1004,11 @@ new_channel_path(int chpid)
 	};
 	snprintf(chp->dev.bus_id, BUS_ID_SIZE, "chp0.%x", chpid);
 
+	/* Obtain channel path description and fill it in. */
+	ret = chsc_determine_channel_path_description(chpid, &chp->desc);
+	if (ret)
+		goto out_free;
+
 	/* make it known to the system */
 	ret = device_register(&chp->dev);
 	if (ret) {
@@ -922,7 +1016,7 @@ new_channel_path(int chpid)
 		       __func__, chpid);
 		goto out_free;
 	}
-	ret = device_create_file(&chp->dev, &dev_attr_status);
+	ret = sysfs_create_group(&chp->dev.kobj, &chp_attr_group);
 	if (ret) {
 		device_unregister(&chp->dev);
 		goto out_free;
@@ -934,6 +1028,23 @@ out_free:
 	return ret;
 }
 
+void *
+chsc_get_chp_desc(struct subchannel *sch, int chp_no)
+{
+	struct channel_path *chp;
+	struct channel_path_desc *desc;
+
+	chp = chps[sch->schib.pmcw.chpid[chp_no]];
+	if (!chp)
+		return NULL;
+	desc = kmalloc(sizeof(struct channel_path_desc), GFP_KERNEL);
+	if (!desc)
+		return NULL;
+	memcpy(desc, &chp->desc, sizeof(struct channel_path_desc));
+	return desc;
+}
+
+
 static int __init
 chsc_alloc_sei_area(void)
 {
diff -purN linux-2.6.11/drivers/s390/cio/chsc.h linux-2.6.12-rc6/drivers/s390/cio/chsc.h
--- linux-2.6.11/drivers/s390/cio/chsc.h	2005-03-02 08:38:19.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/chsc.h	2005-06-06 17:22:29.000000000 +0200
@@ -12,14 +12,24 @@ struct chsc_header {
 	u16 code;
 };
 
+struct channel_path_desc {
+	u8 flags;
+	u8 lsn;
+	u8 desc;
+	u8 chpid;
+	u8 swla;
+	u8 zeroes;
+	u8 chla;
+	u8 chpp;
+};
+
 struct channel_path {
 	int id;
 	int state;
+	struct channel_path_desc desc;
 	struct device dev;
 };
 
-extern struct channel_path *chps[];
-
 extern void s390_process_css( void );
 extern void chsc_validate_chpids(struct subchannel *);
 extern void chpid_is_actually_online(int);
@@ -51,4 +61,6 @@ extern struct css_chsc_char css_chsc_cha
 
 extern int chsc_determine_css_characteristics(void);
 extern int css_characteristics_avail;
+
+extern void *chsc_get_chp_desc(struct subchannel*, int);
 #endif
diff -purN linux-2.6.11/drivers/s390/cio/cio.c linux-2.6.12-rc6/drivers/s390/cio/cio.c
--- linux-2.6.11/drivers/s390/cio/cio.c	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/cio.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/cio.c
  *   S/390 common I/O routines -- low level i/o calls
- *   $Revision: 1.130 $
+ *   $Revision: 1.133 $
  *
  *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,
  *			      IBM Corporation
@@ -228,7 +228,7 @@ cio_start_key (struct subchannel *sch,	/
 int
 cio_start (struct subchannel *sch, struct ccw1 *cpa, __u8 lpm)
 {
-	return cio_start_key(sch, cpa, lpm, default_storage_key);
+	return cio_start_key(sch, cpa, lpm, PAGE_DEFAULT_KEY);
 }
 
 /*
@@ -608,6 +608,10 @@ do_IRQ (struct pt_regs *regs)
 	irq_enter ();
 	asm volatile ("mc 0,0");
 	if (S390_lowcore.int_clock >= S390_lowcore.jiffy_timer)
+		/**
+		 * Make sure that the i/o interrupt did not "overtake"
+		 * the last HZ timer interrupt.
+		 */
 		account_ticks(regs);
 	/*
 	 * Get interrupt information from lowcore
diff -purN linux-2.6.11/drivers/s390/cio/css.c linux-2.6.12-rc6/drivers/s390/cio/css.c
--- linux-2.6.11/drivers/s390/cio/css.c	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/css.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/css.c
  *  driver for channel subsystem
- *   $Revision: 1.84 $
+ *   $Revision: 1.85 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -180,6 +180,7 @@ css_evaluate_subchannel(int irq, int slo
 {
 	int event, ret, disc;
 	struct subchannel *sch;
+	unsigned long flags;
 
 	sch = get_subchannel_by_schid(irq);
 	disc = sch ? device_is_disconnected(sch) : 0;
@@ -221,7 +222,9 @@ css_evaluate_subchannel(int irq, int slo
 			 * coming operational again. It won't do harm in real
 			 * no path situations.
 			 */
+			spin_lock_irqsave(&sch->lock, flags);
 			device_trigger_reprobe(sch);
+			spin_unlock_irqrestore(&sch->lock, flags);
 			ret = 0;
 			break;
 		}
@@ -262,14 +265,19 @@ css_evaluate_subchannel(int irq, int slo
 			 * We can't immediately deregister the disconnected
 			 * device since it might block.
 			 */
+			spin_lock_irqsave(&sch->lock, flags);
 			device_trigger_reprobe(sch);
+			spin_unlock_irqrestore(&sch->lock, flags);
 			ret = 0;
 		}
 		break;
 	case CIO_OPER:
-		if (disc)
+		if (disc) {
+			spin_lock_irqsave(&sch->lock, flags);
 			/* Get device operational again. */
 			device_trigger_reprobe(sch);
+			spin_unlock_irqrestore(&sch->lock, flags);
+		}
 		ret = sch ? 0 : css_probe_device(irq);
 		break;
 	default:
diff -purN linux-2.6.11/drivers/s390/cio/css.h linux-2.6.12-rc6/drivers/s390/cio/css.h
--- linux-2.6.11/drivers/s390/cio/css.h	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/css.h	2005-06-06 17:22:29.000000000 +0200
@@ -84,6 +84,7 @@ struct ccw_device_private {
 		unsigned int doverify:1;    /* delayed path verification */
 		unsigned int donotify:1;    /* call notify function */
 		unsigned int recog_done:1;  /* dev. recog. complete */
+		unsigned int fake_irb:1;    /* deliver faked irb */
 	} __attribute__((packed)) flags;
 	unsigned long intparm;	/* user interruption parameter */
 	struct qdio_irq *qdio_data;
@@ -136,6 +137,7 @@ void device_set_disconnected(struct subc
 void device_trigger_reprobe(struct subchannel *);
 
 /* Helper functions for vary on/off. */
+int device_is_online(struct subchannel *);
 void device_set_waiting(struct subchannel *);
 
 /* Machine check helper function. */
diff -purN linux-2.6.11/drivers/s390/cio/device.c linux-2.6.12-rc6/drivers/s390/cio/device.c
--- linux-2.6.11/drivers/s390/cio/device.c	2005-03-02 08:38:17.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/device.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device.c
  *  bus driver for ccw devices
- *   $Revision: 1.129 $
+ *   $Revision: 1.131 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -293,6 +293,14 @@ ccw_device_set_offline(struct ccw_device
 	cdev->online = 0;
 	spin_lock_irq(cdev->ccwlock);
 	ret = ccw_device_offline(cdev);
+	if (ret == -ENODEV) {
+		if (cdev->private->state != DEV_STATE_NOT_OPER) {
+			cdev->private->state = DEV_STATE_OFFLINE;
+			dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
+		}
+		spin_unlock_irq(cdev->ccwlock);
+		return ret;
+	}
 	spin_unlock_irq(cdev->ccwlock);
 	if (ret == 0)
 		wait_event(cdev->private->wait_q, dev_fsm_final_state(cdev));
diff -purN linux-2.6.11/drivers/s390/cio/device_fsm.c linux-2.6.12-rc6/drivers/s390/cio/device_fsm.c
--- linux-2.6.11/drivers/s390/cio/device_fsm.c	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/device_fsm.c	2005-06-06 17:22:29.000000000 +0200
@@ -24,6 +24,17 @@
 #include "qdio.h"
 
 int
+device_is_online(struct subchannel *sch)
+{
+	struct ccw_device *cdev;
+
+	if (!sch->dev.driver_data)
+		return 0;
+	cdev = sch->dev.driver_data;
+	return (cdev->private->state == DEV_STATE_ONLINE);
+}
+
+int
 device_is_disconnected(struct subchannel *sch)
 {
 	struct ccw_device *cdev;
@@ -44,6 +55,7 @@ device_set_disconnected(struct subchanne
 		return;
 	cdev = sch->dev.driver_data;
 	ccw_device_set_timeout(cdev, 0);
+	cdev->private->flags.fake_irb = 0;
 	cdev->private->state = DEV_STATE_DISCONNECTED;
 }
 
@@ -474,6 +486,7 @@ ccw_device_nopath_notify(void *data)
 	} else {
 		cio_disable_subchannel(sch);
 		ccw_device_set_timeout(cdev, 0);
+		cdev->private->flags.fake_irb = 0;
 		cdev->private->state = DEV_STATE_DISCONNECTED;
 		wake_up(&cdev->private->wait_q);
 	}
@@ -488,6 +501,21 @@ ccw_device_verify_done(struct ccw_device
 		cdev->private->options.pgroup = 0;
 	case 0:
 		ccw_device_done(cdev, DEV_STATE_ONLINE);
+		/* Deliver fake irb to device driver, if needed. */
+		if (cdev->private->flags.fake_irb) {
+			memset(&cdev->private->irb, 0, sizeof(struct irb));
+			cdev->private->irb.scsw = (struct scsw) {
+				.cc = 1,
+				.fctl = SCSW_FCTL_START_FUNC,
+				.actl = SCSW_ACTL_START_PEND,
+				.stctl = SCSW_STCTL_STATUS_PEND,
+			};
+			cdev->private->flags.fake_irb = 0;
+			if (cdev->handler)
+				cdev->handler(cdev, cdev->private->intparm,
+					      &cdev->private->irb);
+			memset(&cdev->private->irb, 0, sizeof(struct irb));
+		}
 		break;
 	case -ETIME:
 		ccw_device_done(cdev, DEV_STATE_BOXED);
@@ -560,6 +588,8 @@ ccw_device_offline(struct ccw_device *cd
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
+	if (stsch(sch->irq, &sch->schib) || !sch->schib.pmcw.dnv)
+		return -ENODEV;
 	if (cdev->private->state != DEV_STATE_ONLINE) {
 		if (sch->schib.scsw.actl != 0)
 			return -EBUSY;
@@ -619,9 +649,11 @@ ccw_device_offline_notoper(struct ccw_de
 
 	cdev->private->state = DEV_STATE_NOT_OPER;
 	sch = to_subchannel(cdev->dev.parent);
-	device_unregister(&sch->dev);
-	sch->schib.pmcw.intparm = 0;
-	cio_modify(sch);
+	if (get_device(&cdev->dev)) {
+		PREPARE_WORK(&cdev->private->kick_work,
+			     ccw_device_call_sch_unregister, (void *)cdev);
+		queue_work(ccw_device_work, &cdev->private->kick_work);
+	}
 	wake_up(&cdev->private->wait_q);
 }
 
@@ -637,6 +669,7 @@ ccw_device_online_notoper(struct ccw_dev
 	if (sch->driver->notify &&
 	    sch->driver->notify(&sch->dev, sch->lpm ? CIO_GONE : CIO_NO_PATH)) {
 			ccw_device_set_timeout(cdev, 0);
+			cdev->private->flags.fake_irb = 0;
 			cdev->private->state = DEV_STATE_DISCONNECTED;
 			wake_up(&cdev->private->wait_q);
 			return;
@@ -647,9 +680,11 @@ ccw_device_online_notoper(struct ccw_dev
 		// FIXME: not-oper indication to device driver ?
 		ccw_device_call_handler(cdev);
 	}
-	device_unregister(&sch->dev);
-	sch->schib.pmcw.intparm = 0;
-	cio_modify(sch);
+	if (get_device(&cdev->dev)) {
+		PREPARE_WORK(&cdev->private->kick_work,
+			     ccw_device_call_sch_unregister, (void *)cdev);
+		queue_work(ccw_device_work, &cdev->private->kick_work);
+	}
 	wake_up(&cdev->private->wait_q);
 }
 
@@ -668,6 +703,12 @@ ccw_device_online_verify(struct ccw_devi
 		return;
 	}
 	sch = to_subchannel(cdev->dev.parent);
+	/*
+	 * Since we might not just be coming from an interrupt from the
+	 * subchannel we have to update the schib.
+	 */
+	stsch(sch->irq, &sch->schib);
+
 	if (sch->schib.scsw.actl != 0 ||
 	    (cdev->private->irb.scsw.stctl & SCSW_STCTL_STATUS_PEND)) {
 		/*
@@ -982,21 +1023,17 @@ void
 device_trigger_reprobe(struct subchannel *sch)
 {
 	struct ccw_device *cdev;
-	unsigned long flags;
 
 	if (!sch->dev.driver_data)
 		return;
 	cdev = sch->dev.driver_data;
-	spin_lock_irqsave(&sch->lock, flags);
-	if (cdev->private->state != DEV_STATE_DISCONNECTED) {
-		spin_unlock_irqrestore(&sch->lock, flags);
+	if (cdev->private->state != DEV_STATE_DISCONNECTED)
 		return;
-	}
+
 	/* Update some values. */
-	if (stsch(sch->irq, &sch->schib)) {
-		spin_unlock_irqrestore(&sch->lock, flags);
+	if (stsch(sch->irq, &sch->schib))
 		return;
-	}
+
 	/*
 	 * The pim, pam, pom values may not be accurate, but they are the best
 	 * we have before performing device selection :/
@@ -1014,7 +1051,6 @@ device_trigger_reprobe(struct subchannel
 	sch->schib.pmcw.intparm = (__u32)(unsigned long)sch;
 	/* We should also udate ssd info, but this has to wait. */
 	ccw_device_start_id(cdev, 0);
-	spin_unlock_irqrestore(&sch->lock, flags);
 }
 
 static void
diff -purN linux-2.6.11/drivers/s390/cio/device_id.c linux-2.6.12-rc6/drivers/s390/cio/device_id.c
--- linux-2.6.11/drivers/s390/cio/device_id.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/device_id.c	2005-06-06 17:22:29.000000000 +0200
@@ -316,6 +316,7 @@ ccw_device_sense_id_irq(struct ccw_devic
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
 		return;
 	ret = ccw_device_check_sense_id(cdev);
+	memset(&cdev->private->irb, 0, sizeof(struct irb));
 	switch (ret) {
 	/* 0, -ETIME, -EOPNOTSUPP, -EAGAIN or -EACCES */
 	case 0:			/* Sense id succeeded. */
diff -purN linux-2.6.11/drivers/s390/cio/device_ops.c linux-2.6.12-rc6/drivers/s390/cio/device_ops.c
--- linux-2.6.11/drivers/s390/cio/device_ops.c	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/device_ops.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  *  drivers/s390/cio/device_ops.c
  *
- *   $Revision: 1.53 $
+ *   $Revision: 1.56 $
  *
  *    Copyright (C) 2002 IBM Deutschland Entwicklung GmbH,
  *			 IBM Corporation
@@ -24,6 +24,7 @@
 #include "cio.h"
 #include "cio_debug.h"
 #include "css.h"
+#include "chsc.h"
 #include "device.h"
 #include "qdio.h"
 
@@ -81,6 +82,16 @@ ccw_device_start_key(struct ccw_device *
 		return -ENODEV;
 	if (cdev->private->state == DEV_STATE_NOT_OPER)
 		return -ENODEV;
+	if (cdev->private->state == DEV_STATE_VERIFY) {
+		/* Remember to fake irb when finished. */
+		if (!cdev->private->flags.fake_irb) {
+			cdev->private->flags.fake_irb = 1;
+			cdev->private->intparm = intparm;
+			return 0;
+		} else
+			/* There's already a fake I/O around. */
+			return -EBUSY;
+	}
 	if (cdev->private->state != DEV_STATE_ONLINE ||
 	    ((sch->schib.scsw.stctl & SCSW_STCTL_PRIM_STATUS) &&
 	     !(sch->schib.scsw.stctl & SCSW_STCTL_SEC_STATUS)) ||
@@ -117,7 +128,7 @@ ccw_device_start(struct ccw_device *cdev
 		 unsigned long intparm, __u8 lpm, unsigned long flags)
 {
 	return ccw_device_start_key(cdev, cpa, intparm, lpm,
-				    default_storage_key, flags);
+				    PAGE_DEFAULT_KEY, flags);
 }
 
 int
@@ -126,7 +137,7 @@ ccw_device_start_timeout(struct ccw_devi
 			 int expires)
 {
 	return ccw_device_start_timeout_key(cdev, cpa, intparm, lpm,
-					    default_storage_key, flags,
+					    PAGE_DEFAULT_KEY, flags,
 					    expires);
 }
 
@@ -281,14 +292,14 @@ ccw_device_wake_up(struct ccw_device *cd
 }
 
 static inline int
-__ccw_device_retry_loop(struct ccw_device *cdev, struct ccw1 *ccw, long magic)
+__ccw_device_retry_loop(struct ccw_device *cdev, struct ccw1 *ccw, long magic, __u8 lpm)
 {
 	int ret;
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
 	do {
-		ret = cio_start (sch, ccw, 0);
+		ret = cio_start (sch, ccw, lpm);
 		if ((ret == -EBUSY) || (ret == -EACCES)) {
 			/* Try again later. */
 			spin_unlock_irq(&sch->lock);
@@ -378,7 +389,7 @@ read_dev_chars (struct ccw_device *cdev,
 		ret = -EBUSY;
 	else
 		/* 0x00D9C4C3 == ebcdic "RDC" */
-		ret = __ccw_device_retry_loop(cdev, rdc_ccw, 0x00D9C4C3);
+		ret = __ccw_device_retry_loop(cdev, rdc_ccw, 0x00D9C4C3, 0);
 
 	/* Restore interrupt handler. */
 	cdev->handler = handler;
@@ -391,10 +402,10 @@ read_dev_chars (struct ccw_device *cdev,
 }
 
 /*
- *  Read Configuration data
+ *  Read Configuration data using path mask
  */
 int
-read_conf_data (struct ccw_device *cdev, void **buffer, int *length)
+read_conf_data_lpm (struct ccw_device *cdev, void **buffer, int *length, __u8 lpm)
 {
 	void (*handler)(struct ccw_device *, unsigned long, struct irb *);
 	struct subchannel *sch;
@@ -447,7 +458,7 @@ read_conf_data (struct ccw_device *cdev,
 		ret = -EBUSY;
 	else
 		/* 0x00D9C3C4 == ebcdic "RCD" */
-		ret = __ccw_device_retry_loop(cdev, rcd_ccw, 0x00D9C3C4);
+		ret = __ccw_device_retry_loop(cdev, rcd_ccw, 0x00D9C3C4, lpm);
 
 	/* Restore interrupt handler. */
 	cdev->handler = handler;
@@ -470,6 +481,15 @@ read_conf_data (struct ccw_device *cdev,
 }
 
 /*
+ *  Read Configuration data
+ */
+int
+read_conf_data (struct ccw_device *cdev, void **buffer, int *length)
+{
+	return read_conf_data_lpm (cdev, buffer, length, 0);
+}
+
+/*
  * Try to break the lock on a boxed device.
  */
 int
@@ -540,6 +560,15 @@ out_unlock:
 	return ret;
 }
 
+void *
+ccw_device_get_chp_desc(struct ccw_device *cdev, int chp_no)
+{
+	struct subchannel *sch;
+
+	sch = to_subchannel(cdev->dev.parent);
+	return chsc_get_chp_desc(sch, chp_no);
+}
+
 // FIXME: these have to go:
 
 int
@@ -570,3 +599,5 @@ EXPORT_SYMBOL(read_conf_data);
 EXPORT_SYMBOL(read_dev_chars);
 EXPORT_SYMBOL(_ccw_device_get_subchannel_number);
 EXPORT_SYMBOL(_ccw_device_get_device_number);
+EXPORT_SYMBOL_GPL(ccw_device_get_chp_desc);
+EXPORT_SYMBOL_GPL(read_conf_data_lpm);
diff -purN linux-2.6.11/drivers/s390/cio/device_pgid.c linux-2.6.12-rc6/drivers/s390/cio/device_pgid.c
--- linux-2.6.11/drivers/s390/cio/device_pgid.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/device_pgid.c	2005-06-06 17:22:29.000000000 +0200
@@ -156,7 +156,9 @@ ccw_device_sense_pgid_irq(struct ccw_dev
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
 		return;
 	sch = to_subchannel(cdev->dev.parent);
-	switch (__ccw_device_check_sense_pgid(cdev)) {
+	ret = __ccw_device_check_sense_pgid(cdev);
+	memset(&cdev->private->irb, 0, sizeof(struct irb));
+	switch (ret) {
 	/* 0, -ETIME, -EOPNOTSUPP, -EAGAIN, -EACCES or -EUSERS */
 	case 0:			/* Sense Path Group ID successful. */
 		if (cdev->private->pgid.inf.ps.state1 == SNID_STATE1_RESET)
@@ -307,6 +309,7 @@ ccw_device_verify_irq(struct ccw_device 
 {
 	struct subchannel *sch;
 	struct irb *irb;
+	int ret;
 
 	irb = (struct irb *) __LC_IRB;
 	/* Retry set pgid for cc=1. */
@@ -319,7 +322,9 @@ ccw_device_verify_irq(struct ccw_device 
 	if (ccw_device_accumulate_and_sense(cdev, irb) != 0)
 		return;
 	sch = to_subchannel(cdev->dev.parent);
-	switch (__ccw_device_check_pgid(cdev)) {
+	ret = __ccw_device_check_pgid(cdev);
+	memset(&cdev->private->irb, 0, sizeof(struct irb));
+	switch (ret) {
 	/* 0, -ETIME, -EAGAIN, -EOPNOTSUPP or -EACCES */
 	case 0:
 		/* Establish or Resign Path Group done. Update vpm. */
@@ -405,6 +410,7 @@ ccw_device_disband_irq(struct ccw_device
 		return;
 	sch = to_subchannel(cdev->dev.parent);
 	ret = __ccw_device_check_pgid(cdev);
+	memset(&cdev->private->irb, 0, sizeof(struct irb));
 	switch (ret) {
 	/* 0, -ETIME, -EAGAIN, -EOPNOTSUPP or -EACCES */
 	case 0:			/* disband successful. */
diff -purN linux-2.6.11/drivers/s390/cio/qdio.h linux-2.6.12-rc6/drivers/s390/cio/qdio.h
--- linux-2.6.11/drivers/s390/cio/qdio.h	2005-03-02 08:37:50.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/cio/qdio.h	2005-06-06 17:22:29.000000000 +0200
@@ -1,7 +1,9 @@
 #ifndef _CIO_QDIO_H
 #define _CIO_QDIO_H
 
-#define VERSION_CIO_QDIO_H "$Revision: 1.26 $"
+#include <asm/page.h>
+
+#define VERSION_CIO_QDIO_H "$Revision: 1.32 $"
 
 #ifdef CONFIG_QDIO_DEBUG
 #define QDIO_VERBOSE_LEVEL 9
@@ -42,7 +44,7 @@
 
 #define QDIO_Q_LAPS 5
 
-#define QDIO_STORAGE_KEY 0
+#define QDIO_STORAGE_KEY PAGE_DEFAULT_KEY
 
 #define L2_CACHELINE_SIZE 256
 #define INDICATORS_PER_CACHELINE (L2_CACHELINE_SIZE/sizeof(__u32))
diff -purN linux-2.6.11/drivers/s390/crypto/z90main.c linux-2.6.12-rc6/drivers/s390/crypto/z90main.c
--- linux-2.6.11/drivers/s390/crypto/z90main.c	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/crypto/z90main.c	2005-06-06 17:22:29.000000000 +0200
@@ -385,8 +385,8 @@ static int z90crypt_release(struct inode
 static ssize_t z90crypt_read(struct file *, char __user *, size_t, loff_t *);
 static ssize_t z90crypt_write(struct file *, const char __user *,
 							size_t, loff_t *);
-static int z90crypt_ioctl(struct inode *, struct file *,
-			  unsigned int, unsigned long);
+static long z90crypt_unlocked_ioctl(struct file *, unsigned int, unsigned long);
+static long z90crypt_compat_ioctl(struct file *, unsigned int, unsigned long);
 
 static void z90crypt_reader_task(unsigned long);
 static void z90crypt_schedule_reader_task(unsigned long);
@@ -433,12 +433,15 @@ static atomic_t total_open;
 static atomic_t z90crypt_step;
 
 static struct file_operations z90crypt_fops = {
-	.owner	 = THIS_MODULE,
-	.read	 = z90crypt_read,
-	.write	 = z90crypt_write,
-	.ioctl	 = z90crypt_ioctl,
-	.open	 = z90crypt_open,
-	.release = z90crypt_release
+	.owner		= THIS_MODULE,
+	.read		= z90crypt_read,
+	.write		= z90crypt_write,
+	.unlocked_ioctl	= z90crypt_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= z90crypt_compat_ioctl,
+#endif
+	.open		= z90crypt_open,
+	.release	= z90crypt_release
 };
 
 #ifndef Z90CRYPT_USE_HOTPLUG
@@ -474,14 +477,13 @@ struct ica_rsa_modexpo_32 { // For 32-bi
 	compat_uptr_t	n_modulus;
 };
 
-static int
-trans_modexpo32(unsigned int fd, unsigned int cmd, unsigned long arg,
-		struct file *file)
+static long
+trans_modexpo32(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct ica_rsa_modexpo_32 __user *mex32u = compat_ptr(arg);
 	struct ica_rsa_modexpo_32  mex32k;
 	struct ica_rsa_modexpo __user *mex64;
-	int ret = 0;
+	long ret = 0;
 	unsigned int i;
 
 	if (!access_ok(VERIFY_WRITE, mex32u, sizeof(struct ica_rsa_modexpo_32)))
@@ -498,7 +500,7 @@ trans_modexpo32(unsigned int fd, unsigne
 	    __put_user(compat_ptr(mex32k.b_key), &mex64->b_key)           ||
 	    __put_user(compat_ptr(mex32k.n_modulus), &mex64->n_modulus))
 		return -EFAULT;
-	ret = sys_ioctl(fd, cmd, (unsigned long)mex64);
+	ret = z90crypt_unlocked_ioctl(filp, cmd, (unsigned long)mex64);
 	if (!ret)
 		if (__get_user(i, &mex64->outputdatalength) ||
 		    __put_user(i, &mex32u->outputdatalength))
@@ -518,14 +520,13 @@ struct ica_rsa_modexpo_crt_32 { // For 3
 	compat_uptr_t	u_mult_inv;
 };
 
-static int
-trans_modexpo_crt32(unsigned int fd, unsigned int cmd, unsigned long arg,
-		    struct file *file)
+static long
+trans_modexpo_crt32(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct ica_rsa_modexpo_crt_32 __user *crt32u = compat_ptr(arg);
 	struct ica_rsa_modexpo_crt_32  crt32k;
 	struct ica_rsa_modexpo_crt __user *crt64;
-	int ret = 0;
+	long ret = 0;
 	unsigned int i;
 
 	if (!access_ok(VERIFY_WRITE, crt32u,
@@ -546,9 +547,8 @@ trans_modexpo_crt32(unsigned int fd, uns
 	    __put_user(compat_ptr(crt32k.np_prime), &crt64->np_prime)     ||
 	    __put_user(compat_ptr(crt32k.nq_prime), &crt64->nq_prime)     ||
 	    __put_user(compat_ptr(crt32k.u_mult_inv), &crt64->u_mult_inv))
-		ret = -EFAULT;
-	if (!ret)
-		ret = sys_ioctl(fd, cmd, (unsigned long)crt64);
+		return -EFAULT;
+	ret = z90crypt_unlocked_ioctl(filp, cmd, (unsigned long)crt64);
 	if (!ret)
 		if (__get_user(i, &crt64->outputdatalength) ||
 		    __put_user(i, &crt32u->outputdatalength))
@@ -556,66 +556,34 @@ trans_modexpo_crt32(unsigned int fd, uns
 	return ret;
 }
 
-static int compatible_ioctls[] = {
-	ICAZ90STATUS, Z90QUIESCE, Z90STAT_TOTALCOUNT, Z90STAT_PCICACOUNT,
-	Z90STAT_PCICCCOUNT, Z90STAT_PCIXCCCOUNT, Z90STAT_PCIXCCMCL2COUNT,
-	Z90STAT_PCIXCCMCL3COUNT, Z90STAT_CEX2CCOUNT, Z90STAT_REQUESTQ_COUNT,
-	Z90STAT_PENDINGQ_COUNT, Z90STAT_TOTALOPEN_COUNT, Z90STAT_DOMAIN_INDEX,
-	Z90STAT_STATUS_MASK, Z90STAT_QDEPTH_MASK, Z90STAT_PERDEV_REQCNT,
-};
-
-static void z90_unregister_ioctl32s(void)
-{
-	int i;
-
-	unregister_ioctl32_conversion(ICARSAMODEXPO);
-	unregister_ioctl32_conversion(ICARSACRT);
-
-	for(i = 0; i < ARRAY_SIZE(compatible_ioctls); i++)
-		unregister_ioctl32_conversion(compatible_ioctls[i]);
-}
-
-static int z90_register_ioctl32s(void)
-{
-	int result, i;
-
-	result = register_ioctl32_conversion(ICARSAMODEXPO, trans_modexpo32);
-	if (result == -EBUSY) {
-		unregister_ioctl32_conversion(ICARSAMODEXPO);
-		result = register_ioctl32_conversion(ICARSAMODEXPO,
-						     trans_modexpo32);
-	}
-	if (result)
-		return result;
-	result = register_ioctl32_conversion(ICARSACRT, trans_modexpo_crt32);
-	if (result == -EBUSY) {
-		unregister_ioctl32_conversion(ICARSACRT);
-		result = register_ioctl32_conversion(ICARSACRT,
-						     trans_modexpo_crt32);
-	}
-	if (result)
-		return result;
-
-	for(i = 0; i < ARRAY_SIZE(compatible_ioctls); i++) {
-		result = register_ioctl32_conversion(compatible_ioctls[i], 0);
-		if (result == -EBUSY) {
-			unregister_ioctl32_conversion(compatible_ioctls[i]);
-			result = register_ioctl32_conversion(
-						       compatible_ioctls[i], 0);
-		}
-		if (result)
-			return result;
-	}
-	return 0;
-}
-#else // !CONFIG_COMPAT
-static inline void z90_unregister_ioctl32s(void)
-{
-}
-
-static inline int z90_register_ioctl32s(void)
+static long
+z90crypt_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	return 0;
+	switch (cmd) {
+	case ICAZ90STATUS:
+	case Z90QUIESCE:
+	case Z90STAT_TOTALCOUNT:
+	case Z90STAT_PCICACOUNT:
+	case Z90STAT_PCICCCOUNT:
+	case Z90STAT_PCIXCCCOUNT:
+	case Z90STAT_PCIXCCMCL2COUNT:
+	case Z90STAT_PCIXCCMCL3COUNT:
+	case Z90STAT_CEX2CCOUNT:
+	case Z90STAT_REQUESTQ_COUNT:
+	case Z90STAT_PENDINGQ_COUNT:
+	case Z90STAT_TOTALOPEN_COUNT:
+	case Z90STAT_DOMAIN_INDEX:
+	case Z90STAT_STATUS_MASK:
+	case Z90STAT_QDEPTH_MASK:
+	case Z90STAT_PERDEV_REQCNT:
+		return z90crypt_unlocked_ioctl(filp, cmd, arg);
+	case ICARSAMODEXPO:
+		return trans_modexpo32(filp, cmd, arg);
+	case ICARSACRT:
+		return trans_modexpo_crt32(filp, cmd, arg);
+	default:
+		return -ENOIOCTLCMD;
+  	}
 }
 #endif
 
@@ -730,14 +698,9 @@ z90crypt_init_module(void)
 	reader_timer.expires = jiffies + (READERTIME * HZ / 1000);
 	add_timer(&reader_timer);
 
-	if ((result = z90_register_ioctl32s()))
-		goto init_module_cleanup;
-
 	return 0; // success
 
 init_module_cleanup:
-	z90_unregister_ioctl32s();
-
 #ifndef Z90CRYPT_USE_HOTPLUG
 	if ((nresult = misc_deregister(&z90crypt_misc_device)))
 		PRINTK("misc_deregister failed with %d.\n", nresult);
@@ -763,8 +726,6 @@ z90crypt_cleanup_module(void)
 
 	PDEBUG("PID %d\n", PID());
 
-	z90_unregister_ioctl32s();
-
 	remove_proc_entry("driver/z90crypt", 0);
 
 #ifndef Z90CRYPT_USE_HOTPLUG
@@ -800,7 +761,7 @@ z90crypt_cleanup_module(void)
  *     z90crypt_release
  *     z90crypt_read
  *     z90crypt_write
- *     z90crypt_ioctl
+ *     z90crypt_unlocked_ioctl
  *     z90crypt_status
  *     z90crypt_status_write
  *	 disable_card
@@ -1804,9 +1765,8 @@ z90crypt_rsa(struct priv_data *private_d
  * This function is a little long, but it's really just one large switch
  * statement.
  */
-static int
-z90crypt_ioctl(struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg)
+static long
+z90crypt_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	struct priv_data *private_data_p = filp->private_data;
 	unsigned char *status;
@@ -2657,8 +2617,8 @@ z90crypt_reader_task(unsigned long ptr)
 
 	/**
 	 * we use workavail = 2 to ensure 2 passes with nothing dequeued before
-	 * exiting the loop. If pendingq_count == 0 after the loop, there is no
-	 * work remaining on the queues.
+	 * exiting the loop. If (pendingq_count+requestq_count) == 0 after the
+	 * loop, there is no work remaining on the queues.
 	 */
 	resp_addr = 0;
 	workavail = 2;
@@ -2697,7 +2657,7 @@ z90crypt_reader_task(unsigned long ptr)
 		spin_unlock_irq(&queuespinlock);
 	}
 
-	if (pendingq_count)
+	if (pendingq_count + requestq_count)
 		z90crypt_schedule_reader_timer();
 }
 
diff -purN linux-2.6.11/drivers/s390/net/claw.c linux-2.6.12-rc6/drivers/s390/net/claw.c
--- linux-2.6.11/drivers/s390/net/claw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/claw.c	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,4447 @@
+/*
+ *  drivers/s390/net/claw.c
+ *    ESCON CLAW network driver
+ *
+ *    $Revision: 1.35 $ $Date: 2005/03/24 12:25:38 $
+ *
+ *  Linux fo zSeries version
+ *    Copyright (C) 2002,2005 IBM Corporation
+ *  Author(s) Original code written by:
+ *              Kazuo Iimura (iimura@jp.ibm.com)
+ *   	      Rewritten by
+ *              Andy Richter (richtera@us.ibm.com)
+ *              Marc Price (mwprice@us.ibm.com)
+ *
+ *    sysfs parms:
+ *   group x.x.rrrr,x.x.wwww
+ *   read_buffer nnnnnnn
+ *   write_buffer nnnnnn
+ *   host_name  aaaaaaaa
+ *   adapter_name aaaaaaaa
+ *   api_type    aaaaaaaa
+ *
+ *  eg.
+ *   group  0.0.0200 0.0.0201
+ *   read_buffer 25
+ *   write_buffer 20
+ *   host_name LINUX390
+ *   adapter_name RS6K
+ *   api_type     TCPIP
+ *
+ *  where
+ *
+ *   The device id is decided by the order entries
+ *   are added to the group the first is claw0 the second claw1
+ *   up to CLAW_MAX_DEV
+ *
+ *   rrrr     -	the first of 2 consecutive device addresses used for the
+ *		CLAW protocol.
+ *		The specified address is always used as the input (Read)
+ *		channel and the next address is used as the output channel.
+ *
+ *   wwww     -	the second of 2 consecutive device addresses used for
+ *		the CLAW protocol.
+ *              The specified address is always used as the output
+ *		channel and the previous address is used as the input channel.
+ *
+ *   read_buffer	-       specifies number of input buffers to allocate.
+ *   write_buffer       -       specifies number of output buffers to allocate.
+ *   host_name          -       host name
+ *   adaptor_name       -       adaptor name
+ *   api_type           -       API type TCPIP or API will be sent and expected
+ *				as ws_name
+ *
+ *   Note the following requirements:
+ *   1)  host_name must match the configured adapter_name on the remote side
+ *   2)  adaptor_name must match the configured host name on the remote side
+ *
+ *  Change History
+ *    1.00  Initial release shipped
+ *    1.10  Changes for Buffer allocation
+ *    1.15  Changed for 2.6 Kernel  No longer compiles on 2.4 or lower
+ *    1.25  Added Packing support
+ */
+#include <asm/bitops.h>
+#include <asm/ccwdev.h>
+#include <asm/ccwgroup.h>
+#include <asm/debug.h>
+#include <asm/idals.h>
+#include <asm/io.h>
+
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/tcp.h>
+#include <linux/timer.h>
+#include <linux/types.h>
+#include <linux/version.h>
+
+#include "cu3088.h"
+#include "claw.h"
+
+MODULE_AUTHOR("Andy Richter <richtera@us.ibm.com>");
+MODULE_DESCRIPTION("Linux for zSeries CLAW Driver\n" \
+			"Copyright 2000,2005 IBM Corporation\n");
+MODULE_LICENSE("GPL");
+
+/* Debugging is based on DEBUGMSG, IOTRACE, or FUNCTRACE  options:
+   DEBUGMSG  - Enables output of various debug messages in the code
+   IOTRACE   - Enables output of CCW and other IO related traces
+   FUNCTRACE - Enables output of function entry/exit trace
+   Define any combination of above options to enable tracing
+
+   CLAW also uses the s390dbf file system  see claw_trace and claw_setup
+*/
+
+/* following enables tracing */
+//#define DEBUGMSG
+//#define IOTRACE
+//#define FUNCTRACE
+
+#ifdef DEBUGMSG
+#define DEBUG
+#endif
+
+#ifdef IOTRACE
+#define DEBUG
+#endif
+
+#ifdef FUNCTRACE
+#define DEBUG
+#endif
+
+ char debug_buffer[255];
+/**
+ * Debug Facility Stuff
+ */
+static debug_info_t *claw_dbf_setup;
+static debug_info_t *claw_dbf_trace;
+
+/**
+ *  CLAW Debug Facility functions
+ */
+static void
+claw_unregister_debug_facility(void)
+{
+	if (claw_dbf_setup)
+		debug_unregister(claw_dbf_setup);
+	if (claw_dbf_trace)
+		debug_unregister(claw_dbf_trace);
+}
+
+static int
+claw_register_debug_facility(void)
+{
+	claw_dbf_setup = debug_register("claw_setup", 1, 1, 8);
+	claw_dbf_trace = debug_register("claw_trace", 1, 2, 8);
+	if (claw_dbf_setup == NULL || claw_dbf_trace == NULL) {
+		printk(KERN_WARNING "Not enough memory for debug facility.\n");
+		claw_unregister_debug_facility();
+		return -ENOMEM;
+	}
+	debug_register_view(claw_dbf_setup, &debug_hex_ascii_view);
+	debug_set_level(claw_dbf_setup, 2);
+	debug_register_view(claw_dbf_trace, &debug_hex_ascii_view);
+	debug_set_level(claw_dbf_trace, 2);
+	return 0;
+}
+
+static inline void
+claw_set_busy(struct net_device *dev)
+{
+ ((struct claw_privbk *) dev->priv)->tbusy=1;
+ eieio();
+}
+
+static inline void
+claw_clear_busy(struct net_device *dev)
+{
+	clear_bit(0, &(((struct claw_privbk *) dev->priv)->tbusy));
+	netif_wake_queue(dev);
+	eieio();
+}
+
+static inline int
+claw_check_busy(struct net_device *dev)
+{
+	eieio();
+	return ((struct claw_privbk *) dev->priv)->tbusy;
+}
+
+static inline void
+claw_setbit_busy(int nr,struct net_device *dev)
+{
+	netif_stop_queue(dev);
+ 	set_bit(nr, (void *)&(((struct claw_privbk *)dev->priv)->tbusy));
+}
+
+static inline void
+claw_clearbit_busy(int nr,struct net_device *dev)
+{
+ 	clear_bit(nr,(void *)&(((struct claw_privbk *)dev->priv)->tbusy));
+	netif_wake_queue(dev);
+}
+
+static inline int
+claw_test_and_setbit_busy(int nr,struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	return test_and_set_bit(nr,
+ 		(void *)&(((struct claw_privbk *) dev->priv)->tbusy));
+}
+
+
+/* Functions for the DEV methods */
+
+static int claw_probe(struct ccwgroup_device *cgdev);
+static void claw_remove_device(struct ccwgroup_device *cgdev);
+static void claw_purge_skb_queue(struct sk_buff_head *q);
+static int claw_new_device(struct ccwgroup_device *cgdev);
+static int claw_shutdown_device(struct ccwgroup_device *cgdev);
+static int claw_tx(struct sk_buff *skb, struct net_device *dev);
+static int claw_change_mtu( struct net_device *dev, int new_mtu);
+static int claw_open(struct net_device *dev);
+static void claw_irq_handler(struct ccw_device *cdev,
+	unsigned long intparm, struct irb *irb);
+static void claw_irq_tasklet ( unsigned long data );
+static int claw_release(struct net_device *dev);
+static void claw_write_retry ( struct chbk * p_ch );
+static void claw_write_next ( struct chbk * p_ch );
+static void claw_timer ( struct chbk * p_ch );
+
+/* Functions */
+static int add_claw_reads(struct net_device *dev,
+	struct ccwbk* p_first, struct ccwbk* p_last);
+static void inline ccw_check_return_code (struct ccw_device *cdev,
+        int return_code);
+static void inline ccw_check_unit_check (struct chbk * p_ch,
+	unsigned char sense );
+static int find_link(struct net_device *dev, char *host_name, char *ws_name );
+static int claw_hw_tx(struct sk_buff *skb, struct net_device *dev, long linkid);
+static int init_ccw_bk(struct net_device *dev);
+static void probe_error( struct ccwgroup_device *cgdev);
+static struct net_device_stats *claw_stats(struct net_device *dev);
+static int inline pages_to_order_of_mag(int num_of_pages);
+static struct sk_buff *claw_pack_skb(struct claw_privbk *privptr);
+#ifdef DEBUG
+static void dumpit (char *buf, int len);
+#endif
+/* sysfs Functions */
+static ssize_t claw_hname_show(struct device *dev, char *buf);
+static ssize_t claw_hname_write(struct device *dev,
+	const char *buf, size_t count);
+static ssize_t claw_adname_show(struct device *dev, char *buf);
+static ssize_t claw_adname_write(struct device *dev,
+	const char *buf, size_t count);
+static ssize_t claw_apname_show(struct device *dev, char *buf);
+static ssize_t claw_apname_write(struct device *dev,
+	const char *buf, size_t count);
+static ssize_t claw_wbuff_show(struct device *dev, char *buf);
+static ssize_t claw_wbuff_write(struct device *dev,
+	const char *buf, size_t count);
+static ssize_t claw_rbuff_show(struct device *dev, char *buf);
+static ssize_t claw_rbuff_write(struct device *dev,
+	const char *buf, size_t count);
+static int claw_add_files(struct device *dev);
+static void claw_remove_files(struct device *dev);
+
+/*   Functions for System Validate  */
+static int claw_process_control( struct net_device *dev, struct ccwbk * p_ccw);
+static int claw_send_control(struct net_device *dev, __u8 type, __u8 link,
+       __u8 correlator, __u8 rc , char *local_name, char *remote_name);
+static int claw_snd_conn_req(struct net_device *dev, __u8 link);
+static int claw_snd_disc(struct net_device *dev, struct clawctl * p_ctl);
+static int claw_snd_sys_validate_rsp(struct net_device *dev,
+        struct clawctl * p_ctl, __u32 return_code);
+static int claw_strt_conn_req(struct net_device *dev );
+static void claw_strt_read ( struct net_device *dev, int lock );
+static void claw_strt_out_IO( struct net_device *dev );
+static void claw_free_wrt_buf( struct net_device *dev );
+
+/* Functions for unpack reads   */
+static void unpack_read (struct net_device *dev );
+
+/* ccwgroup table  */
+
+static struct ccwgroup_driver claw_group_driver = {
+        .owner       = THIS_MODULE,
+        .name        = "claw",
+        .max_slaves  = 2,
+        .driver_id   = 0xC3D3C1E6,
+        .probe       = claw_probe,
+        .remove      = claw_remove_device,
+        .set_online  = claw_new_device,
+        .set_offline = claw_shutdown_device,
+};
+
+/*
+*
+*       Key functions
+*/
+
+/*----------------------------------------------------------------*
+ *   claw_probe                                                   *
+ *      this function is called for each CLAW device.             *
+ *----------------------------------------------------------------*/
+static int
+claw_probe(struct ccwgroup_device *cgdev)
+{
+	int  		rc;
+	struct claw_privbk *privptr=NULL;
+
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s Enter\n",__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"probe");
+	if (!get_device(&cgdev->dev))
+		return -ENODEV;
+#ifdef DEBUGMSG
+        printk(KERN_INFO "claw: variable cgdev =\n");
+        dumpit((char *)cgdev, sizeof(struct ccwgroup_device));
+#endif
+	privptr = kmalloc(sizeof(struct claw_privbk), GFP_KERNEL);
+	if (privptr == NULL) {
+		probe_error(cgdev);
+		put_device(&cgdev->dev);
+		printk(KERN_WARNING "Out of memory %s %s Exit Line %d \n",
+			cgdev->cdev[0]->dev.bus_id,__FUNCTION__,__LINE__);
+		CLAW_DBF_TEXT_(2,setup,"probex%d",-ENOMEM);
+		return -ENOMEM;
+	}
+	memset(privptr,0x00,sizeof(struct claw_privbk));
+	privptr->p_mtc_envelope= kmalloc( MAX_ENVELOPE_SIZE, GFP_KERNEL);
+	privptr->p_env = kmalloc(sizeof(struct claw_env), GFP_KERNEL);
+        if ((privptr->p_mtc_envelope==NULL) || (privptr->p_env==NULL)) {
+                probe_error(cgdev);
+		put_device(&cgdev->dev);
+		printk(KERN_WARNING "Out of memory %s %s Exit Line %d \n",
+			cgdev->cdev[0]->dev.bus_id,__FUNCTION__,__LINE__);
+		CLAW_DBF_TEXT_(2,setup,"probex%d",-ENOMEM);
+                return -ENOMEM;
+        }
+	memset(privptr->p_mtc_envelope, 0x00, MAX_ENVELOPE_SIZE);
+	memset(privptr->p_env, 0x00, sizeof(struct claw_env));
+	memcpy(privptr->p_env->adapter_name,WS_NAME_NOT_DEF,8);
+	memcpy(privptr->p_env->host_name,WS_NAME_NOT_DEF,8);
+	memcpy(privptr->p_env->api_type,WS_NAME_NOT_DEF,8);
+	privptr->p_env->packing = 0;
+	privptr->p_env->write_buffers = 5;
+	privptr->p_env->read_buffers = 5;
+	privptr->p_env->read_size = CLAW_FRAME_SIZE;
+	privptr->p_env->write_size = CLAW_FRAME_SIZE;
+	rc = claw_add_files(&cgdev->dev);
+	if (rc) {
+		probe_error(cgdev);
+		put_device(&cgdev->dev);
+		printk(KERN_WARNING "add_files failed %s %s Exit Line %d \n",
+			cgdev->cdev[0]->dev.bus_id,__FUNCTION__,__LINE__);
+		CLAW_DBF_TEXT_(2,setup,"probex%d",rc);
+		return rc;
+	}
+	printk(KERN_INFO "claw: sysfs files added for %s\n",cgdev->cdev[0]->dev.bus_id);
+	privptr->p_env->p_priv = privptr;
+        cgdev->cdev[0]->handler = claw_irq_handler;
+	cgdev->cdev[1]->handler = claw_irq_handler;
+	cgdev->dev.driver_data = privptr;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "claw:%s exit on line %d, "
+		"rc = 0\n",__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"prbext 0");
+
+        return 0;
+}  /*  end of claw_probe       */
+
+/*-------------------------------------------------------------------*
+ *   claw_tx                                                         *
+ *-------------------------------------------------------------------*/
+
+static int
+claw_tx(struct sk_buff *skb, struct net_device *dev)
+{
+        int             rc;
+        struct claw_privbk *privptr=dev->priv;
+	unsigned long saveflags;
+        struct chbk *p_ch;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"claw_tx");
+        p_ch=&privptr->channel[WRITE];
+        if (skb == NULL) {
+                printk(KERN_WARNING "%s: null pointer passed as sk_buffer\n",
+			dev->name);
+                privptr->stats.tx_dropped++;
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s: %s() exit on line %d, rc = EIO\n",
+			dev->name,__FUNCTION__, __LINE__);
+#endif
+		CLAW_DBF_TEXT_(2,trace,"clawtx%d",-EIO);
+                return -EIO;
+        }
+
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: variable sk_buff=\n",dev->name);
+        dumpit((char *) skb, sizeof(struct sk_buff));
+        printk(KERN_INFO "%s: variable dev=\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+#endif
+        spin_lock_irqsave(get_ccwdev_lock(p_ch->cdev), saveflags);
+        rc=claw_hw_tx( skb, dev, 1 );
+        spin_unlock_irqrestore(get_ccwdev_lock(p_ch->cdev), saveflags);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s exit on line %d, rc = %d\n",
+		dev->name, __FUNCTION__, __LINE__, rc);
+#endif
+	CLAW_DBF_TEXT_(4,trace,"clawtx%d",rc);
+        return rc;
+}   /*  end of claw_tx */
+
+/*------------------------------------------------------------------*
+ *  pack the collect queue into an skb and return it                *
+ *   If not packing just return the top skb from the queue          *
+ *------------------------------------------------------------------*/
+
+static struct sk_buff *
+claw_pack_skb(struct claw_privbk *privptr)
+{
+	struct sk_buff *new_skb,*held_skb;
+	struct chbk *p_ch = &privptr->channel[WRITE];
+	struct claw_env  *p_env = privptr->p_env;
+	int	pkt_cnt,pk_ind,so_far;
+
+	new_skb = NULL;		/* assume no dice */
+	pkt_cnt = 0;
+	CLAW_DBF_TEXT(4,trace,"PackSKBe");
+	if (skb_queue_len(&p_ch->collect_queue) > 0) {
+	/* some data */
+		held_skb = skb_dequeue(&p_ch->collect_queue);
+		if (p_env->packing != DO_PACKED)
+			return held_skb;
+		if (held_skb)
+			atomic_dec(&held_skb->users);
+		else
+			return NULL;
+		/* get a new SKB we will pack at least one */
+		new_skb = dev_alloc_skb(p_env->write_size);
+		if (new_skb == NULL) {
+			atomic_inc(&held_skb->users);
+			skb_queue_head(&p_ch->collect_queue,held_skb);
+			return NULL;
+		}
+		/* we have packed packet and a place to put it  */
+		pk_ind = 1;
+		so_far = 0;
+		new_skb->cb[1] = 'P'; /* every skb on queue has pack header */
+		while ((pk_ind) && (held_skb != NULL)) {
+			if (held_skb->len+so_far <= p_env->write_size-8) {
+				memcpy(skb_put(new_skb,held_skb->len),
+					held_skb->data,held_skb->len);
+				privptr->stats.tx_packets++;
+				so_far += held_skb->len;
+				pkt_cnt++;
+				dev_kfree_skb_irq(held_skb);
+				held_skb = skb_dequeue(&p_ch->collect_queue);
+				if (held_skb)
+					atomic_dec(&held_skb->users);
+			} else {
+				pk_ind = 0;
+				atomic_inc(&held_skb->users);
+				skb_queue_head(&p_ch->collect_queue,held_skb);
+			}
+		}
+#ifdef IOTRACE
+		printk(KERN_INFO "%s: %s() Packed %d len %d\n",
+			p_env->ndev->name,
+			__FUNCTION__,pkt_cnt,new_skb->len);
+#endif
+	}
+	CLAW_DBF_TEXT(4,trace,"PackSKBx");
+	return new_skb;
+}
+
+/*-------------------------------------------------------------------*
+ *   claw_change_mtu                                                 *
+ *                                                                   *
+ *-------------------------------------------------------------------*/
+
+static int
+claw_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct claw_privbk  *privptr=dev->priv;
+	int buff_size;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+#ifdef DEBUGMSG
+        printk(KERN_INFO "variable dev =\n");
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "variable new_mtu = %d\n", new_mtu);
+#endif
+	CLAW_DBF_TEXT(4,trace,"setmtu");
+	buff_size = privptr->p_env->write_size;
+        if ((new_mtu < 60) || (new_mtu > buff_size)) {
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s:%s Exit on line %d, rc=EINVAL\n",
+		dev->name,
+		__FUNCTION__, __LINE__);
+#endif
+                return -EINVAL;
+        }
+        dev->mtu = new_mtu;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d\n",dev->name,
+	__FUNCTION__, __LINE__);
+#endif
+        return 0;
+}  /*   end of claw_change_mtu */
+
+
+/*-------------------------------------------------------------------*
+ *   claw_open                                                       *
+ *                                                                   *
+ *-------------------------------------------------------------------*/
+static int
+claw_open(struct net_device *dev)
+{
+
+        int     rc;
+        int     i;
+        unsigned long       saveflags=0;
+        unsigned long       parm;
+        struct claw_privbk  *privptr;
+	DECLARE_WAITQUEUE(wait, current);
+        struct timer_list  timer;
+        struct ccwbk *p_buf;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"open");
+	if (!dev | (dev->name[0] == 0x00)) {
+		CLAW_DBF_TEXT(2,trace,"BadDev");
+	 	printk(KERN_WARNING "claw: Bad device at open failing \n");
+		return -ENODEV;
+	}
+	privptr = (struct claw_privbk *)dev->priv;
+        /*   allocate and initialize CCW blocks */
+	if (privptr->buffs_alloc == 0) {
+	        rc=init_ccw_bk(dev);
+        	if (rc) {
+                	printk(KERN_INFO "%s:%s Exit on line %d, rc=ENOMEM\n",
+			dev->name,
+			__FUNCTION__, __LINE__);
+			CLAW_DBF_TEXT(2,trace,"openmem");
+                	return -ENOMEM;
+        	}
+	}
+        privptr->system_validate_comp=0;
+        privptr->release_pend=0;
+	if(strncmp(privptr->p_env->api_type,WS_APPL_NAME_PACKED,6) == 0) {
+		privptr->p_env->read_size=DEF_PACK_BUFSIZE;
+		privptr->p_env->write_size=DEF_PACK_BUFSIZE;
+		privptr->p_env->packing=PACKING_ASK;
+	} else {
+		privptr->p_env->packing=0;
+		privptr->p_env->read_size=CLAW_FRAME_SIZE;
+		privptr->p_env->write_size=CLAW_FRAME_SIZE;
+	}
+        claw_set_busy(dev);
+	tasklet_init(&privptr->channel[READ].tasklet, claw_irq_tasklet,
+        	(unsigned long) &privptr->channel[READ]);
+        for ( i = 0; i < 2;  i++) {
+		CLAW_DBF_TEXT_(2,trace,"opn_ch%d",i);
+                init_waitqueue_head(&privptr->channel[i].wait);
+		/* skb_queue_head_init(&p_ch->io_queue); */
+		if (i == WRITE)
+			skb_queue_head_init(
+				&privptr->channel[WRITE].collect_queue);
+                privptr->channel[i].flag_a = 0;
+                privptr->channel[i].IO_active = 0;
+                privptr->channel[i].flag  &= ~CLAW_TIMER;
+                init_timer(&timer);
+                timer.function = (void *)claw_timer;
+                timer.data = (unsigned long)(&privptr->channel[i]);
+                timer.expires = jiffies + 15*HZ;
+                add_timer(&timer);
+                spin_lock_irqsave(get_ccwdev_lock(
+			privptr->channel[i].cdev), saveflags);
+                parm = (unsigned long) &privptr->channel[i];
+                privptr->channel[i].claw_state = CLAW_START_HALT_IO;
+		rc = 0;
+		add_wait_queue(&privptr->channel[i].wait, &wait);
+                rc = ccw_device_halt(
+			(struct ccw_device *)privptr->channel[i].cdev,parm);
+                set_current_state(TASK_INTERRUPTIBLE);
+                spin_unlock_irqrestore(
+			get_ccwdev_lock(privptr->channel[i].cdev), saveflags);
+                schedule();
+		set_current_state(TASK_RUNNING);
+                remove_wait_queue(&privptr->channel[i].wait, &wait);
+                if(rc != 0)
+                        ccw_check_return_code(privptr->channel[i].cdev, rc);
+                if((privptr->channel[i].flag & CLAW_TIMER) == 0x00)
+                        del_timer(&timer);
+        }
+        if ((((privptr->channel[READ].last_dstat |
+		privptr->channel[WRITE].last_dstat) &
+           ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END)) != 0x00) ||
+           (((privptr->channel[READ].flag |
+	   	privptr->channel[WRITE].flag) & CLAW_TIMER) != 0x00)) {
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: channel problems during open - read:"
+			" %02x -  write: %02x\n",
+                        dev->name,
+			privptr->channel[READ].last_dstat,
+			privptr->channel[WRITE].last_dstat);
+#endif
+                printk(KERN_INFO "%s: remote side is not ready\n", dev->name);
+		CLAW_DBF_TEXT(2,trace,"notrdy");
+
+                for ( i = 0; i < 2;  i++) {
+                        spin_lock_irqsave(
+				get_ccwdev_lock(privptr->channel[i].cdev),
+				saveflags);
+                        parm = (unsigned long) &privptr->channel[i];
+                        privptr->channel[i].claw_state = CLAW_STOP;
+                        rc = ccw_device_halt(
+				(struct ccw_device *)&privptr->channel[i].cdev,
+				parm);
+                        spin_unlock_irqrestore(
+				get_ccwdev_lock(privptr->channel[i].cdev),
+				saveflags);
+                        if (rc != 0) {
+                                ccw_check_return_code(
+					privptr->channel[i].cdev, rc);
+                        }
+                }
+                free_pages((unsigned long)privptr->p_buff_ccw,
+			(int)pages_to_order_of_mag(privptr->p_buff_ccw_num));
+                if (privptr->p_env->read_size < PAGE_SIZE) {
+                        free_pages((unsigned long)privptr->p_buff_read,
+			       (int)pages_to_order_of_mag(
+			       		privptr->p_buff_read_num));
+                }
+                else {
+                        p_buf=privptr->p_read_active_first;
+                        while (p_buf!=NULL) {
+                                free_pages((unsigned long)p_buf->p_buffer,
+				      (int)pages_to_order_of_mag(
+				      	privptr->p_buff_pages_perread ));
+                                p_buf=p_buf->next;
+                        }
+                }
+                if (privptr->p_env->write_size < PAGE_SIZE ) {
+                        free_pages((unsigned long)privptr->p_buff_write,
+			     (int)pages_to_order_of_mag(
+			     	privptr->p_buff_write_num));
+                }
+                else {
+                        p_buf=privptr->p_write_active_first;
+                        while (p_buf!=NULL) {
+                                free_pages((unsigned long)p_buf->p_buffer,
+				     (int)pages_to_order_of_mag(
+				     	privptr->p_buff_pages_perwrite ));
+                                p_buf=p_buf->next;
+                        }
+                }
+		privptr->buffs_alloc = 0;
+		privptr->channel[READ].flag= 0x00;
+		privptr->channel[WRITE].flag = 0x00;
+                privptr->p_buff_ccw=NULL;
+                privptr->p_buff_read=NULL;
+                privptr->p_buff_write=NULL;
+                claw_clear_busy(dev);
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s:%s Exit on line %d, rc=EIO\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+		CLAW_DBF_TEXT(2,trace,"open EIO");
+                return -EIO;
+        }
+
+        /*   Send SystemValidate command */
+
+        claw_clear_busy(dev);
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d, rc=0\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"openok");
+        return 0;
+}    /*     end of claw_open    */
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*       claw_irq_handler                                             *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static void
+claw_irq_handler(struct ccw_device *cdev,
+	unsigned long intparm, struct irb *irb)
+{
+        struct chbk *p_ch = NULL;
+        struct claw_privbk *privptr = NULL;
+        struct net_device *dev = NULL;
+        struct claw_env  *p_env;
+        struct chbk *p_ch_r=NULL;
+
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s enter  \n",__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"clawirq");
+        /* Bypass all 'unsolicited interrupts' */
+	if (!cdev->dev.driver_data) {
+                printk(KERN_WARNING "claw: unsolicited interrupt for device:"
+		 	"%s received c-%02x d-%02x\n",
+                        cdev->dev.bus_id,irb->scsw.cstat, irb->scsw.dstat);
+#ifdef FUNCTRACE
+                printk(KERN_INFO "claw: %s() "
+			"exit on line %d\n",__FUNCTION__,__LINE__);
+#endif
+		CLAW_DBF_TEXT(2,trace,"badirq");
+                return;
+        }
+	privptr = (struct claw_privbk *)cdev->dev.driver_data;
+
+	/* Try to extract channel from driver data. */
+	if (privptr->channel[READ].cdev == cdev)
+		p_ch = &privptr->channel[READ];
+	else if (privptr->channel[WRITE].cdev == cdev)
+		p_ch = &privptr->channel[WRITE];
+	else {
+		printk(KERN_WARNING "claw: Can't determine channel for "
+			"interrupt, device %s\n", cdev->dev.bus_id);
+		CLAW_DBF_TEXT(2,trace,"badchan");
+		return;
+	}
+	CLAW_DBF_TEXT_(4,trace,"IRQCH=%d",p_ch->flag);
+
+	dev = (struct net_device *) (p_ch->ndev);
+        p_env=privptr->p_env;
+
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: interrupt for device: %04x "
+		"received c-%02x d-%02x state-%02x\n",
+                dev->name, p_ch->devno, irb->scsw.cstat,
+		irb->scsw.dstat, p_ch->claw_state);
+#endif
+
+	/* Copy interruption response block. */
+	memcpy(p_ch->irb, irb, sizeof(struct irb));
+
+        /* Check for good subchannel return code, otherwise error message */
+        if (irb->scsw.cstat  &&  !(irb->scsw.cstat & SCHN_STAT_PCI)) {
+                printk(KERN_INFO "%s: subchannel check for device: %04x -"
+			" Sch Stat %02x  Dev Stat %02x CPA - %04x\n",
+                        dev->name, p_ch->devno,
+			irb->scsw.cstat, irb->scsw.dstat,irb->scsw.cpa);
+#ifdef IOTRACE
+		dumpit((char *)irb,sizeof(struct irb));
+		dumpit((char *)(unsigned long)irb->scsw.cpa,
+			sizeof(struct ccw1));
+#endif
+#ifdef FUNCTRACE
+		printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+		CLAW_DBF_TEXT(2,trace,"chanchk");
+                /* return; */
+        }
+
+        /* Check the reason-code of a unit check */
+        if (irb->scsw.dstat & DEV_STAT_UNIT_CHECK) {
+                ccw_check_unit_check(p_ch, irb->ecw[0]);
+        }
+
+        /* State machine to bring the connection up, down and to restart */
+        p_ch->last_dstat = irb->scsw.dstat;
+
+        switch (p_ch->claw_state) {
+                case CLAW_STOP:/* HALT_IO by claw_release (halt sequence) */
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: CLAW_STOP enter\n", dev->name);
+#endif
+                        if (!((p_ch->irb->scsw.stctl & SCSW_STCTL_SEC_STATUS) ||
+	    		(p_ch->irb->scsw.stctl == SCSW_STCTL_STATUS_PEND) ||
+	    		(p_ch->irb->scsw.stctl ==
+	     		(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {
+#ifdef FUNCTRACE
+                                printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+                                return;
+                        }
+                        wake_up(&p_ch->wait);   /* wake up claw_release */
+
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: CLAW_STOP exit\n", dev->name);
+#endif
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s:%s Exit on line %d\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+			CLAW_DBF_TEXT(4,trace,"stop");
+                        return;
+
+                case CLAW_START_HALT_IO: /* HALT_IO issued by claw_open  */
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: process CLAW_STAT_HALT_IO\n",
+				dev->name);
+#endif
+                        if (!((p_ch->irb->scsw.stctl & SCSW_STCTL_SEC_STATUS) ||
+	    		(p_ch->irb->scsw.stctl == SCSW_STCTL_STATUS_PEND) ||
+	    		(p_ch->irb->scsw.stctl ==
+	     		(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+				CLAW_DBF_TEXT(4,trace,"haltio");
+                                return;
+                        }
+                        if (p_ch->flag == CLAW_READ) {
+                                p_ch->claw_state = CLAW_START_READ;
+                                wake_up(&p_ch->wait); /* wake claw_open (READ)*/
+                        }
+			else
+			   if (p_ch->flag == CLAW_WRITE) {
+                                p_ch->claw_state = CLAW_START_WRITE;
+                                /*      send SYSTEM_VALIDATE                    */
+                                claw_strt_read(dev, LOCK_NO);
+                               	claw_send_control(dev,
+					SYSTEM_VALIDATE_REQUEST,
+					0, 0, 0,
+					p_env->host_name,
+					p_env->adapter_name );
+                        } else {
+				printk(KERN_WARNING "claw: unsolicited "
+					"interrupt for device:"
+				 	"%s received c-%02x d-%02x\n",
+                		        cdev->dev.bus_id,
+					irb->scsw.cstat,
+					irb->scsw.dstat);
+				return;
+				}
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: process CLAW_STAT_HALT_IO exit\n",
+				dev->name);
+#endif
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s:%s Exit on line %d\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+			CLAW_DBF_TEXT(4,trace,"haltio");
+                        return;
+                case CLAW_START_READ:
+			CLAW_DBF_TEXT(4,trace,"ReadIRQ");
+                        if (p_ch->irb->scsw.dstat & DEV_STAT_UNIT_CHECK) {
+                                clear_bit(0, (void *)&p_ch->IO_active);
+                                if ((p_ch->irb->ecw[0] & 0x41) == 0x41 ||
+                                    (p_ch->irb->ecw[0] & 0x40) == 0x40 ||
+                                    (p_ch->irb->ecw[0])        == 0)
+                                {
+                                        privptr->stats.rx_errors++;
+                                        printk(KERN_INFO "%s: Restart is "
+						"required after remote "
+						"side recovers \n",
+						dev->name);
+                                }
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+					CLAW_DBF_TEXT(4,trace,"notrdy");
+                                        return;
+                        }
+                        if ((p_ch->irb->scsw.cstat & SCHN_STAT_PCI) &&
+			    (p_ch->irb->scsw.dstat==0)) {
+                                if (test_and_set_bit(CLAW_BH_ACTIVE,
+					(void *)&p_ch->flag_a) == 0) {
+					tasklet_schedule(&p_ch->tasklet);
+                                }
+				else {
+					CLAW_DBF_TEXT(4,trace,"PCINoBH");
+				}
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+				CLAW_DBF_TEXT(4,trace,"PCI_read");
+                                return;
+                        }
+                        if(!((p_ch->irb->scsw.stctl & SCSW_STCTL_SEC_STATUS) ||
+	    		 (p_ch->irb->scsw.stctl == SCSW_STCTL_STATUS_PEND) ||
+	    		 (p_ch->irb->scsw.stctl ==
+	     		 (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+				CLAW_DBF_TEXT(4,trace,"SPend_rd");
+                                return;
+                        }
+                        clear_bit(0, (void *)&p_ch->IO_active);
+                        claw_clearbit_busy(TB_RETRY,dev);
+                        if (test_and_set_bit(CLAW_BH_ACTIVE,
+    				(void *)&p_ch->flag_a) == 0) {
+    				tasklet_schedule(&p_ch->tasklet);
+                         }
+    			else {
+    				CLAW_DBF_TEXT(4,trace,"RdBHAct");
+    			}
+
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: process CLAW_START_READ exit\n",
+				dev->name);
+#endif
+#ifdef FUNCTRACE
+			printk(KERN_INFO "%s:%s Exit on line %d\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+			CLAW_DBF_TEXT(4,trace,"RdIRQXit");
+                        return;
+                case CLAW_START_WRITE:
+                        if (p_ch->irb->scsw.dstat & DEV_STAT_UNIT_CHECK) {
+                                printk(KERN_INFO "%s: Unit Check Occured in "
+					"write channel\n",dev->name);
+                                clear_bit(0, (void *)&p_ch->IO_active);
+                                if (p_ch->irb->ecw[0] & 0x80 ) {
+                                        printk(KERN_INFO "%s: Resetting Event "
+						"occurred:\n",dev->name);
+                                        init_timer(&p_ch->timer);
+                                        p_ch->timer.function =
+						(void *)claw_write_retry;
+                                        p_ch->timer.data = (unsigned long)p_ch;
+                                        p_ch->timer.expires = jiffies + 10*HZ;
+                                        add_timer(&p_ch->timer);
+                                        printk(KERN_INFO "%s: write connection "
+						"restarting\n",dev->name);
+                                }
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+				CLAW_DBF_TEXT(4,trace,"rstrtwrt");
+                                return;
+                        }
+                        if (p_ch->irb->scsw.dstat & DEV_STAT_UNIT_EXCEP) {
+                                        clear_bit(0, (void *)&p_ch->IO_active);
+                                        printk(KERN_INFO "%s: Unit Exception "
+						"Occured in write channel\n",
+						dev->name);
+                        }
+                        if(!((p_ch->irb->scsw.stctl & SCSW_STCTL_SEC_STATUS) ||
+	    		(p_ch->irb->scsw.stctl == SCSW_STCTL_STATUS_PEND) ||
+	    		(p_ch->irb->scsw.stctl ==
+	     		(SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)))) {
+#ifdef FUNCTRACE
+				printk(KERN_INFO "%s:%s Exit on line %d\n",
+					dev->name,__FUNCTION__,__LINE__);
+#endif
+				CLAW_DBF_TEXT(4,trace,"writeUE");
+                                return;
+                        }
+                        clear_bit(0, (void *)&p_ch->IO_active);
+                        if (claw_test_and_setbit_busy(TB_TX,dev)==0) {
+                                claw_write_next(p_ch);
+                                claw_clearbit_busy(TB_TX,dev);
+                                claw_clear_busy(dev);
+                        }
+                        p_ch_r=(struct chbk *)&privptr->channel[READ];
+                        if (test_and_set_bit(CLAW_BH_ACTIVE,
+ 					(void *)&p_ch_r->flag_a) == 0) {
+			 	tasklet_schedule(&p_ch_r->tasklet);
+                        }
+
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: process CLAW_START_WRITE exit\n",
+				 dev->name);
+#endif
+#ifdef FUNCTRACE
+			printk(KERN_INFO "%s:%s Exit on line %d\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+			CLAW_DBF_TEXT(4,trace,"StWtExit");
+                        return;
+                default:
+                        printk(KERN_WARNING "%s: wrong selection code - irq "
+				"state=%d\n",dev->name,p_ch->claw_state);
+#ifdef FUNCTRACE
+			printk(KERN_INFO "%s:%s Exit on line %d\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+			CLAW_DBF_TEXT(2,trace,"badIRQ");
+                        return;
+        }
+
+}       /*   end of claw_irq_handler    */
+
+
+/*-------------------------------------------------------------------*
+*       claw_irq_tasklet                                             *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static void
+claw_irq_tasklet ( unsigned long data )
+{
+	struct chbk * p_ch;
+        struct net_device  *dev;
+        struct claw_privbk *       privptr;
+
+	p_ch = (struct chbk *) data;
+        dev = (struct net_device *)p_ch->ndev;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable p_ch =\n",dev->name);
+        dumpit((char *) p_ch, sizeof(struct chbk));
+#endif
+	CLAW_DBF_TEXT(4,trace,"IRQtask");
+
+        privptr = (struct claw_privbk *) dev->priv;
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: bh routine - state-%02x\n" ,
+		dev->name, p_ch->claw_state);
+#endif
+
+        unpack_read(dev);
+        clear_bit(CLAW_BH_ACTIVE, (void *)&p_ch->flag_a);
+	CLAW_DBF_TEXT(4,trace,"TskletXt");
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+        return;
+}       /*    end of claw_irq_bh    */
+
+/*-------------------------------------------------------------------*
+*       claw_release                                                 *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static int
+claw_release(struct net_device *dev)
+{
+        int                rc;
+        int                i;
+        unsigned long      saveflags;
+        unsigned long      parm;
+        struct claw_privbk *privptr;
+        DECLARE_WAITQUEUE(wait, current);
+        struct ccwbk*             p_this_ccw;
+        struct ccwbk*             p_buf;
+
+	if (!dev)
+                return 0;
+        privptr = (struct claw_privbk *) dev->priv;
+        if (!privptr)
+                return 0;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"release");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+	printk(KERN_INFO "Priv Buffalloc %d\n",privptr->buffs_alloc);
+	printk(KERN_INFO "Priv p_buff_ccw = %p\n",&privptr->p_buff_ccw);
+#endif
+        privptr->release_pend=1;
+        claw_setbit_busy(TB_STOP,dev);
+        for ( i = 1; i >=0 ;  i--) {
+                spin_lock_irqsave(
+			get_ccwdev_lock(privptr->channel[i].cdev), saveflags);
+             /*   del_timer(&privptr->channel[READ].timer);  */
+ 		privptr->channel[i].claw_state = CLAW_STOP;
+                privptr->channel[i].IO_active = 0;
+                parm = (unsigned long) &privptr->channel[i];
+		if (i == WRITE)
+			claw_purge_skb_queue(
+				&privptr->channel[WRITE].collect_queue);
+                rc = ccw_device_halt (privptr->channel[i].cdev, parm);
+	        if (privptr->system_validate_comp==0x00)  /* never opened? */
+                   init_waitqueue_head(&privptr->channel[i].wait);
+                add_wait_queue(&privptr->channel[i].wait, &wait);
+                set_current_state(TASK_INTERRUPTIBLE);
+	        spin_unlock_irqrestore(
+			get_ccwdev_lock(privptr->channel[i].cdev), saveflags);
+	        schedule();
+		set_current_state(TASK_RUNNING);
+	        remove_wait_queue(&privptr->channel[i].wait, &wait);
+	        if (rc != 0) {
+                        ccw_check_return_code(privptr->channel[i].cdev, rc);
+                }
+        }
+	if (privptr->pk_skb != NULL) {
+		dev_kfree_skb(privptr->pk_skb);
+		privptr->pk_skb = NULL;
+	}
+	if(privptr->buffs_alloc != 1) {
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+		CLAW_DBF_TEXT(4,trace,"none2fre");
+		return 0;
+	}
+	CLAW_DBF_TEXT(4,trace,"freebufs");
+	if (privptr->p_buff_ccw != NULL) {
+        	free_pages((unsigned long)privptr->p_buff_ccw,
+	        	(int)pages_to_order_of_mag(privptr->p_buff_ccw_num));
+	}
+	CLAW_DBF_TEXT(4,trace,"freeread");
+        if (privptr->p_env->read_size < PAGE_SIZE) {
+	    if (privptr->p_buff_read != NULL) {
+                free_pages((unsigned long)privptr->p_buff_read,
+		      (int)pages_to_order_of_mag(privptr->p_buff_read_num));
+		}
+        }
+        else {
+                p_buf=privptr->p_read_active_first;
+                while (p_buf!=NULL) {
+                        free_pages((unsigned long)p_buf->p_buffer,
+			     (int)pages_to_order_of_mag(
+			     	privptr->p_buff_pages_perread ));
+                        p_buf=p_buf->next;
+                }
+        }
+	 CLAW_DBF_TEXT(4,trace,"freewrit");
+        if (privptr->p_env->write_size < PAGE_SIZE ) {
+                free_pages((unsigned long)privptr->p_buff_write,
+		      (int)pages_to_order_of_mag(privptr->p_buff_write_num));
+        }
+        else {
+                p_buf=privptr->p_write_active_first;
+                while (p_buf!=NULL) {
+                        free_pages((unsigned long)p_buf->p_buffer,
+			      (int)pages_to_order_of_mag(
+			      privptr->p_buff_pages_perwrite ));
+                        p_buf=p_buf->next;
+                }
+        }
+	 CLAW_DBF_TEXT(4,trace,"clearptr");
+	privptr->buffs_alloc = 0;
+        privptr->p_buff_ccw=NULL;
+        privptr->p_buff_read=NULL;
+        privptr->p_buff_write=NULL;
+        privptr->system_validate_comp=0;
+        privptr->release_pend=0;
+        /*      Remove any writes that were pending and reset all reads   */
+        p_this_ccw=privptr->p_read_active_first;
+        while (p_this_ccw!=NULL) {
+                p_this_ccw->header.length=0xffff;
+                p_this_ccw->header.opcode=0xff;
+                p_this_ccw->header.flag=0x00;
+                p_this_ccw=p_this_ccw->next;
+        }
+
+        while (privptr->p_write_active_first!=NULL) {
+                p_this_ccw=privptr->p_write_active_first;
+                p_this_ccw->header.flag=CLAW_PENDING;
+                privptr->p_write_active_first=p_this_ccw->next;
+                p_this_ccw->next=privptr->p_write_free_chain;
+                privptr->p_write_free_chain=p_this_ccw;
+                ++privptr->write_free_count;
+        }
+        privptr->p_write_active_last=NULL;
+        privptr->mtc_logical_link = -1;
+        privptr->mtc_skipping = 1;
+        privptr->mtc_offset=0;
+
+        if (((privptr->channel[READ].last_dstat |
+		privptr->channel[WRITE].last_dstat) &
+		~(DEV_STAT_CHN_END | DEV_STAT_DEV_END)) != 0x00) {
+                printk(KERN_WARNING "%s: channel problems during close - "
+			"read: %02x -  write: %02x\n",
+                dev->name,
+		privptr->channel[READ].last_dstat,
+		privptr->channel[WRITE].last_dstat);
+		 CLAW_DBF_TEXT(2,trace,"badclose");
+        }
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"rlsexit");
+        return 0;
+}      /* end of claw_release     */
+
+
+
+/*-------------------------------------------------------------------*
+*       claw_write_retry                                             *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static void
+claw_write_retry ( struct chbk *p_ch )
+{
+
+        struct net_device  *dev=p_ch->ndev;
+
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+        printk(KERN_INFO "claw: variable p_ch =\n");
+        dumpit((char *) p_ch, sizeof(struct chbk));
+#endif
+	CLAW_DBF_TEXT(4,trace,"w_retry");
+        if (p_ch->claw_state == CLAW_STOP) {
+#ifdef FUNCTRACE
+		printk(KERN_INFO "%s:%s Exit on line %d\n",
+			dev->name,__FUNCTION__,__LINE__);
+#endif
+        	return;
+        }
+#ifdef DEBUGMSG
+        printk( KERN_INFO "%s:%s  state-%02x\n" ,
+		dev->name,
+		__FUNCTION__,
+		p_ch->claw_state);
+#endif
+	claw_strt_out_IO( dev );
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"rtry_xit");
+        return;
+}      /* end of claw_write_retry      */
+
+
+/*-------------------------------------------------------------------*
+*       claw_write_next                                              *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static void
+claw_write_next ( struct chbk * p_ch )
+{
+
+        struct net_device  *dev;
+        struct claw_privbk *privptr=NULL;
+	struct sk_buff *pk_skb;
+	int	rc;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",p_ch->ndev->name,__FUNCTION__);
+        printk(KERN_INFO "%s: variable p_ch =\n",p_ch->ndev->name);
+        dumpit((char *) p_ch, sizeof(struct chbk));
+#endif
+	CLAW_DBF_TEXT(4,trace,"claw_wrt");
+        if (p_ch->claw_state == CLAW_STOP)
+                return;
+        dev = (struct net_device *) p_ch->ndev;
+	privptr = (struct claw_privbk *) dev->priv;
+        claw_free_wrt_buf( dev );
+	if ((privptr->write_free_count > 0) &&
+	    (skb_queue_len(&p_ch->collect_queue) > 0)) {
+	  	pk_skb = claw_pack_skb(privptr);
+		while (pk_skb != NULL) {
+			rc = claw_hw_tx( pk_skb, dev,1);
+			if (privptr->write_free_count > 0) {
+	   			pk_skb = claw_pack_skb(privptr);
+			} else
+				pk_skb = NULL;
+		}
+	}
+        if (privptr->p_write_active_first!=NULL) {
+                claw_strt_out_IO(dev);
+        }
+
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+        return;
+}      /* end of claw_write_next      */
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*       claw_timer                                                   *
+*--------------------------------------------------------------------*/
+
+static void
+claw_timer ( struct chbk * p_ch )
+{
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Entry\n",p_ch->ndev->name,__FUNCTION__);
+        printk(KERN_INFO "%s: variable p_ch =\n",p_ch->ndev->name);
+        dumpit((char *) p_ch, sizeof(struct chbk));
+#endif
+	CLAW_DBF_TEXT(4,trace,"timer");
+        p_ch->flag |= CLAW_TIMER;
+        wake_up(&p_ch->wait);
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		p_ch->ndev->name,__FUNCTION__,__LINE__);
+#endif
+        return;
+}      /* end of claw_timer  */
+
+
+/*
+*
+*       functions
+*/
+
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*     pages_to_order_of_mag                                          *
+*                                                                    *
+*    takes a number of pages from 1 to 512 and returns the           *
+*    log(num_pages)/log(2) get_free_pages() needs a base 2 order     *
+*    of magnitude get_free_pages() has an upper order of 9           *
+*--------------------------------------------------------------------*/
+
+static int inline
+pages_to_order_of_mag(int num_of_pages)
+{
+	int	order_of_mag=1;		/* assume 2 pages */
+	int	nump=2;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s Enter pages = %d \n",__FUNCTION__,num_of_pages);
+#endif
+	CLAW_DBF_TEXT_(5,trace,"pages%d",num_of_pages);
+	if (num_of_pages == 1)   {return 0; }  /* magnitude of 0 = 1 page */
+	/* 512 pages = 2Meg on 4k page systems */
+	if (num_of_pages >= 512) {return 9; }
+	/* we have two or more pages order is at least 1 */
+	for (nump=2 ;nump <= 512;nump*=2) {
+	  if (num_of_pages <= nump)
+		  break;
+	  order_of_mag +=1;
+	}
+	if (order_of_mag > 9) { order_of_mag = 9; }  /* I know it's paranoid */
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s Exit on line %d, order = %d\n",
+	__FUNCTION__,__LINE__, order_of_mag);
+#endif
+	CLAW_DBF_TEXT_(5,trace,"mag%d",order_of_mag);
+	return order_of_mag;
+}
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*     add_claw_reads                                                 *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static int
+add_claw_reads(struct net_device *dev, struct ccwbk* p_first,
+	struct ccwbk* p_last)
+{
+        struct claw_privbk *privptr;
+        struct ccw1  temp_ccw;
+        struct endccw * p_end;
+#ifdef IOTRACE
+        struct ccwbk*  p_buf;
+#endif
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+#ifdef DEBUGMSG
+        printk(KERN_INFO "dev\n");
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "p_first\n");
+        dumpit((char *) p_first, sizeof(struct ccwbk));
+        printk(KERN_INFO "p_last\n");
+        dumpit((char *) p_last, sizeof(struct ccwbk));
+#endif
+	CLAW_DBF_TEXT(4,trace,"addreads");
+        privptr = dev->priv;
+        p_end = privptr->p_end_ccw;
+
+        /* first CCW and last CCW contains a new set of read channel programs
+        *       to apend the running channel programs
+        */
+        if ( p_first==NULL) {
+#ifdef FUNCTRACE
+		printk(KERN_INFO "%s:%s Exit on line %d\n",
+			dev->name,__FUNCTION__,__LINE__);
+#endif
+		CLAW_DBF_TEXT(4,trace,"addexit");
+                return 0;
+        }
+
+        /* set up ending CCW sequence for this segment */
+        if (p_end->read1) {
+                p_end->read1=0x00;    /*  second ending CCW is now active */
+                /*      reset ending CCWs and setup TIC CCWs              */
+                p_end->read2_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+                p_end->read2_nop2.flags  = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+                p_last->r_TIC_1.cda =(__u32)__pa(&p_end->read2_nop1);
+                p_last->r_TIC_2.cda =(__u32)__pa(&p_end->read2_nop1);
+                p_end->read2_nop2.cda=0;
+                p_end->read2_nop2.count=1;
+        }
+        else {
+                p_end->read1=0x01;  /* first ending CCW is now active */
+                /*      reset ending CCWs and setup TIC CCWs          */
+                p_end->read1_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+                p_end->read1_nop2.flags  = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+                p_last->r_TIC_1.cda = (__u32)__pa(&p_end->read1_nop1);
+                p_last->r_TIC_2.cda = (__u32)__pa(&p_end->read1_nop1);
+                p_end->read1_nop2.cda=0;
+                p_end->read1_nop2.count=1;
+        }
+
+        if ( privptr-> p_read_active_first ==NULL ) {
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s:%s p_read_active_frist == NULL \n",
+			dev->name,__FUNCTION__);
+                printk(KERN_INFO "%s:%s Read active first/last changed \n",
+			dev->name,__FUNCTION__);
+#endif
+                privptr-> p_read_active_first= p_first;  /*    set new first */
+                privptr-> p_read_active_last = p_last;   /*    set new last  */
+        }
+        else {
+
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s:%s Read in progress \n",
+		dev->name,__FUNCTION__);
+#endif
+                /* set up TIC ccw  */
+                temp_ccw.cda= (__u32)__pa(&p_first->read);
+                temp_ccw.count=0;
+                temp_ccw.flags=0;
+                temp_ccw.cmd_code = CCW_CLAW_CMD_TIC;
+
+
+                if (p_end->read1) {
+
+               /* first set of CCW's is chained to the new read              */
+               /* chain, so the second set is chained to the active chain.   */
+               /* Therefore modify the second set to point to the new        */
+               /* read chain set up TIC CCWs                                 */
+               /* make sure we update the CCW so channel doesn't fetch it    */
+               /* when it's only half done                                   */
+                        memcpy( &p_end->read2_nop2, &temp_ccw ,
+				sizeof(struct ccw1));
+                        privptr->p_read_active_last->r_TIC_1.cda=
+				(__u32)__pa(&p_first->read);
+                        privptr->p_read_active_last->r_TIC_2.cda=
+				(__u32)__pa(&p_first->read);
+                }
+                else {
+                        /* make sure we update the CCW so channel doesn't   */
+			/* fetch it when it is only half done               */
+                        memcpy( &p_end->read1_nop2, &temp_ccw ,
+				sizeof(struct ccw1));
+                        privptr->p_read_active_last->r_TIC_1.cda=
+				(__u32)__pa(&p_first->read);
+                        privptr->p_read_active_last->r_TIC_2.cda=
+				(__u32)__pa(&p_first->read);
+                }
+                /*      chain in new set of blocks                              */
+                privptr->p_read_active_last->next = p_first;
+                privptr->p_read_active_last=p_last;
+        } /* end of if ( privptr-> p_read_active_first ==NULL)  */
+#ifdef IOTRACE
+        printk(KERN_INFO "%s:%s  dump p_last CCW BK \n",dev->name,__FUNCTION__);
+        dumpit((char *)p_last, sizeof(struct ccwbk));
+        printk(KERN_INFO "%s:%s  dump p_end CCW BK \n",dev->name,__FUNCTION__);
+        dumpit((char *)p_end, sizeof(struct endccw));
+
+        printk(KERN_INFO "%s:%s dump p_first CCW BK \n",dev->name,__FUNCTION__);
+        dumpit((char *)p_first, sizeof(struct ccwbk));
+        printk(KERN_INFO "%s:%s Dump Active CCW chain \n",
+		dev->name,__FUNCTION__);
+        p_buf=privptr->p_read_active_first;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+#endif
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"addexit");
+        return 0;
+}    /*     end of add_claw_reads   */
+
+/*-------------------------------------------------------------------*
+ *   ccw_check_return_code                                           *
+ *                                                                   *
+ *-------------------------------------------------------------------*/
+
+static void inline
+ccw_check_return_code(struct ccw_device *cdev, int return_code)
+{
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > enter  \n",
+		cdev->dev.bus_id,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"ccwret");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "variable cdev =\n");
+        dumpit((char *) cdev, sizeof(struct ccw_device));
+        printk(KERN_INFO "variable return_code = %d\n",return_code);
+#endif
+        if (return_code != 0) {
+                switch (return_code) {
+                        case -EBUSY:
+                                printk(KERN_INFO "%s: Busy !\n",
+					cdev->dev.bus_id);
+                                break;
+                        case -ENODEV:
+                                printk(KERN_EMERG "%s: Missing device called "
+					"for IO ENODEV\n", cdev->dev.bus_id);
+                                break;
+                        case -EIO:
+                                printk(KERN_EMERG "%s: Status pending... EIO \n",
+					cdev->dev.bus_id);
+                                break;
+			case -EINVAL:
+                                printk(KERN_EMERG "%s: Invalid Dev State EINVAL \n",
+					cdev->dev.bus_id);
+                                break;
+                        default:
+                                printk(KERN_EMERG "%s: Unknown error in "
+				 "Do_IO %d\n",cdev->dev.bus_id, return_code);
+                }
+        }
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > exit on line %d\n",
+		cdev->dev.bus_id,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"ccwret");
+}    /*    end of ccw_check_return_code   */
+
+/*-------------------------------------------------------------------*
+*       ccw_check_unit_check                                         *
+*--------------------------------------------------------------------*/
+
+static void inline
+ccw_check_unit_check(struct chbk * p_ch, unsigned char sense )
+{
+	struct net_device *dev = p_ch->ndev;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > enter\n",dev->name,__FUNCTION__);
+#endif
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *)dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable sense =\n",dev->name);
+        dumpit((char *)&sense, 2);
+#endif
+	CLAW_DBF_TEXT(4,trace,"unitchek");
+
+        printk(KERN_INFO "%s: Unit Check with sense byte:0x%04x\n",
+                dev->name, sense);
+
+        if (sense & 0x40) {
+                if (sense & 0x01) {
+                        printk(KERN_WARNING "%s: Interface disconnect or "
+				"Selective reset "
+			       	"occurred (remote side)\n", dev->name);
+                }
+                else {
+                        printk(KERN_WARNING "%s: System reset occured"
+				" (remote side)\n", dev->name);
+                }
+        }
+        else if (sense & 0x20) {
+                if (sense & 0x04) {
+                        printk(KERN_WARNING "%s: Data-streaming "
+				"timeout)\n", dev->name);
+                }
+                else  {
+                        printk(KERN_WARNING "%s: Data-transfer parity"
+				" error\n", dev->name);
+                }
+        }
+        else if (sense & 0x10) {
+                if (sense & 0x20) {
+                        printk(KERN_WARNING "%s: Hardware malfunction "
+				"(remote side)\n", dev->name);
+                }
+                else {
+                        printk(KERN_WARNING "%s: read-data parity error "
+				"(remote side)\n", dev->name);
+                }
+        }
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+}   /*    end of ccw_check_unit_check    */
+
+
+
+/*-------------------------------------------------------------------*
+* Dump buffer format                                                 *
+*                                                                    *
+*--------------------------------------------------------------------*/
+#ifdef DEBUG
+static void
+dumpit(char* buf, int len)
+{
+
+        __u32      ct, sw, rm, dup;
+        char       *ptr, *rptr;
+        char       tbuf[82], tdup[82];
+#if (CONFIG_ARCH_S390X)
+        char       addr[22];
+#else
+        char       addr[12];
+#endif
+        char       boff[12];
+        char       bhex[82], duphex[82];
+        char       basc[40];
+
+        sw  = 0;
+        rptr =ptr=buf;
+        rm  = 16;
+        duphex[0]  = 0x00;
+        dup = 0;
+        for ( ct=0; ct < len; ct++, ptr++, rptr++ )  {
+                if (sw == 0) {
+#if (CONFIG_ARCH_S390X)
+                        sprintf(addr, "%16.16lX",(unsigned long)rptr);
+#else
+                        sprintf(addr, "%8.8X",(__u32)rptr);
+#endif
+                        sprintf(boff, "%4.4X", (__u32)ct);
+                        bhex[0] = '\0';
+                        basc[0] = '\0';
+                }
+                if ((sw == 4) || (sw == 12)) {
+                        strcat(bhex, " ");
+                }
+                if (sw == 8) {
+                        strcat(bhex, "  ");
+                }
+#if (CONFIG_ARCH_S390X)
+                sprintf(tbuf,"%2.2lX", (unsigned long)*ptr);
+#else
+                sprintf(tbuf,"%2.2X", (__u32)*ptr);
+#endif
+                tbuf[2] = '\0';
+                strcat(bhex, tbuf);
+                if ((0!=isprint(*ptr)) && (*ptr >= 0x20)) {
+                        basc[sw] = *ptr;
+                }
+                else {
+                        basc[sw] = '.';
+                }
+                basc[sw+1] = '\0';
+                sw++;
+                rm--;
+                if (sw==16) {
+                        if ((strcmp(duphex, bhex)) !=0) {
+                                if (dup !=0) {
+					sprintf(tdup,"Duplicate as above to"
+						" %s", addr);
+                                        printk( KERN_INFO "                 "
+						"   --- %s ---\n",tdup);
+                                }
+                                printk( KERN_INFO "   %s (+%s) : %s  [%s]\n",
+					 addr, boff, bhex, basc);
+                                dup = 0;
+                                strcpy(duphex, bhex);
+                        }
+                        else {
+                                dup++;
+                        }
+                        sw = 0;
+                        rm = 16;
+                }
+        }  /* endfor */
+
+        if (sw != 0) {
+                for ( ; rm > 0; rm--, sw++ ) {
+                        if ((sw==4) || (sw==12)) strcat(bhex, " ");
+                        if (sw==8)               strcat(bhex, "  ");
+                        strcat(bhex, "  ");
+                        strcat(basc, " ");
+                }
+                if (dup !=0) {
+                        sprintf(tdup,"Duplicate as above to %s", addr);
+                        printk( KERN_INFO "                    --- %s ---\n",
+				tdup);
+                }
+                printk( KERN_INFO "   %s (+%s) : %s  [%s]\n",
+			addr, boff, bhex, basc);
+        }
+        else {
+                if (dup >=1) {
+                        sprintf(tdup,"Duplicate as above to %s", addr);
+                        printk( KERN_INFO "                    --- %s ---\n",
+				tdup);
+                }
+                if (dup !=0) {
+                        printk( KERN_INFO "   %s (+%s) : %s  [%s]\n",
+				addr, boff, bhex, basc);
+                }
+        }
+        return;
+
+}   /*   end of dumpit  */
+#endif
+
+/*-------------------------------------------------------------------*
+*               find_link                                            *
+*--------------------------------------------------------------------*/
+static int
+find_link(struct net_device *dev, char *host_name, char *ws_name )
+{
+	struct claw_privbk *privptr;
+	struct claw_env *p_env;
+	int    rc=0;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s > enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"findlink");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev = \n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable host_name = %s\n",dev->name, host_name);
+        printk(KERN_INFO "%s: variable ws_name = %s\n",dev->name, ws_name);
+#endif
+        privptr=dev->priv;
+        p_env=privptr->p_env;
+	switch (p_env->packing)
+	{
+		case  PACKING_ASK:
+			if ((memcmp(WS_APPL_NAME_PACKED, host_name, 8)!=0) ||
+			    (memcmp(WS_APPL_NAME_PACKED, ws_name, 8)!=0 ))
+        	             rc = EINVAL;
+			break;
+		case  DO_PACKED:
+		case  PACK_SEND:
+			if ((memcmp(WS_APPL_NAME_IP_NAME, host_name, 8)!=0) ||
+			    (memcmp(WS_APPL_NAME_IP_NAME, ws_name, 8)!=0 ))
+        	        	rc = EINVAL;
+			break;
+		default:
+	       		if ((memcmp(HOST_APPL_NAME, host_name, 8)!=0) ||
+		    	    (memcmp(p_env->api_type , ws_name, 8)!=0))
+        	        	rc = EINVAL;
+			break;
+	}
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+        return 0;
+}    /*    end of find_link    */
+
+/*-------------------------------------------------------------------*
+ *   claw_hw_tx                                                      *
+ *                                                                   *
+ *                                                                   *
+ *-------------------------------------------------------------------*/
+
+static int
+claw_hw_tx(struct sk_buff *skb, struct net_device *dev, long linkid)
+{
+        int                             rc=0;
+        struct claw_privbk 		*privptr;
+        struct ccwbk           *p_this_ccw;
+        struct ccwbk           *p_first_ccw;
+        struct ccwbk           *p_last_ccw;
+        __u32                           numBuffers;
+        signed long                     len_of_data;
+        unsigned long                   bytesInThisBuffer;
+        unsigned char                   *pDataAddress;
+        struct endccw                   *pEnd;
+        struct ccw1                     tempCCW;
+        struct chbk                     *p_ch;
+	struct claw_env			*p_env;
+        int                             lock;
+	struct clawph			*pk_head;
+	struct chbk			*ch;
+#ifdef IOTRACE
+        struct ccwbk                   *p_buf;
+#endif
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"hw_tx");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev skb =\n",dev->name);
+        dumpit((char *) skb, sizeof(struct sk_buff));
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable linkid = %ld\n",dev->name,linkid);
+#endif
+        privptr = (struct claw_privbk *) (dev->priv);
+        p_ch=(struct chbk *)&privptr->channel[WRITE];
+	p_env =privptr->p_env;
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: %s() dump sk_buff  \n",dev->name,__FUNCTION__);
+        dumpit((char *)skb ,sizeof(struct sk_buff));
+#endif
+	claw_free_wrt_buf(dev);	/* Clean up free chain if posible */
+        /*  scan the write queue to free any completed write packets   */
+        p_first_ccw=NULL;
+        p_last_ccw=NULL;
+	if ((p_env->packing >= PACK_SEND) &&
+       	    (skb->cb[1] != 'P')) {
+		skb_push(skb,sizeof(struct clawph));
+		pk_head=(struct clawph *)skb->data;
+		pk_head->len=skb->len-sizeof(struct clawph);
+		if (pk_head->len%4)  {
+			pk_head->len+= 4-(pk_head->len%4);
+			skb_pad(skb,4-(pk_head->len%4));
+			skb_put(skb,4-(pk_head->len%4));
+		}
+		if (p_env->packing == DO_PACKED)
+			pk_head->link_num = linkid;
+		else
+			pk_head->link_num = 0;
+		pk_head->flag = 0x00;
+		skb_pad(skb,4);
+		skb->cb[1] = 'P';
+	}
+        if (linkid == 0) {
+        	if (claw_check_busy(dev)) {
+                	if (privptr->write_free_count!=0) {
+                                claw_clear_busy(dev);
+                        }
+                        else {
+                                claw_strt_out_IO(dev );
+                                claw_free_wrt_buf( dev );
+                                if (privptr->write_free_count==0) {
+#ifdef IOTRACE
+                                	printk(KERN_INFO "%s: "
+					   "(claw_check_busy) no free write "
+					   "buffers\n", dev->name);
+#endif
+					ch = &privptr->channel[WRITE];
+					atomic_inc(&skb->users);
+					skb_queue_tail(&ch->collect_queue, skb);
+                                	goto Done;
+                                }
+                                else {
+                                	claw_clear_busy(dev);
+                                }
+                        }
+                }
+                /*  tx lock  */
+                if (claw_test_and_setbit_busy(TB_TX,dev)) { /* set to busy */
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s:  busy  (claw_test_and_setbit_"
+				"busy)\n", dev->name);
+#endif
+			ch = &privptr->channel[WRITE];
+			atomic_inc(&skb->users);
+			skb_queue_tail(&ch->collect_queue, skb);
+                        claw_strt_out_IO(dev );
+                        rc=-EBUSY;
+                        goto Done2;
+                }
+        }
+        /*      See how many write buffers are required to hold this data */
+        numBuffers= ( skb->len + privptr->p_env->write_size - 1) /
+			( privptr->p_env->write_size);
+
+        /*      If that number of buffers isn't available, give up for now */
+        if (privptr->write_free_count < numBuffers ||
+            privptr->p_write_free_chain == NULL ) {
+
+                claw_setbit_busy(TB_NOBUFFER,dev);
+
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s:  busy  (claw_setbit_busy"
+			"(TB_NOBUFFER))\n", dev->name);
+                printk(KERN_INFO "       free_count: %d, numBuffers : %d\n",
+			(int)privptr->write_free_count,(int) numBuffers );
+#endif
+		ch = &privptr->channel[WRITE];
+		atomic_inc(&skb->users);
+		skb_queue_tail(&ch->collect_queue, skb);
+		CLAW_DBF_TEXT(2,trace,"clawbusy");
+                goto Done2;
+        }
+        pDataAddress=skb->data;
+        len_of_data=skb->len;
+
+        while (len_of_data > 0) {
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: %s() length-of-data is %ld \n",
+			dev->name ,__FUNCTION__,len_of_data);
+                dumpit((char *)pDataAddress ,64);
+#endif
+                p_this_ccw=privptr->p_write_free_chain;  /* get a block */
+		if (p_this_ccw == NULL) { /* lost the race */
+			ch = &privptr->channel[WRITE];
+			atomic_inc(&skb->users);
+			skb_queue_tail(&ch->collect_queue, skb);
+			goto Done2;
+		}
+                privptr->p_write_free_chain=p_this_ccw->next;
+                p_this_ccw->next=NULL;
+                --privptr->write_free_count; /* -1 */
+                bytesInThisBuffer=len_of_data;
+                memcpy( p_this_ccw->p_buffer,pDataAddress, bytesInThisBuffer);
+                len_of_data-=bytesInThisBuffer;
+                pDataAddress+=(unsigned long)bytesInThisBuffer;
+                /*      setup write CCW         */
+                p_this_ccw->write.cmd_code = (linkid * 8) +1;
+                if (len_of_data>0) {
+                        p_this_ccw->write.cmd_code+=MORE_to_COME_FLAG;
+                }
+                p_this_ccw->write.count=bytesInThisBuffer;
+                /*      now add to end of this chain    */
+                if (p_first_ccw==NULL)    {
+                        p_first_ccw=p_this_ccw;
+                }
+                if (p_last_ccw!=NULL) {
+                        p_last_ccw->next=p_this_ccw;
+                        /*      set up TIC ccws         */
+                        p_last_ccw->w_TIC_1.cda=
+				(__u32)__pa(&p_this_ccw->write);
+                }
+                p_last_ccw=p_this_ccw;      /* save new last block */
+#ifdef IOTRACE
+		printk(KERN_INFO "%s: %s() > CCW and Buffer %ld bytes long \n",
+			dev->name,__FUNCTION__,bytesInThisBuffer);
+                dumpit((char *)p_this_ccw, sizeof(struct ccwbk));
+                dumpit((char *)p_this_ccw->p_buffer, 64);
+#endif
+        }
+
+        /*      FirstCCW and LastCCW now contain a new set of write channel
+        *       programs to append to the running channel program
+        */
+
+        if (p_first_ccw!=NULL) {
+                /*      setup ending ccw sequence for this segment              */
+                pEnd=privptr->p_end_ccw;
+                if (pEnd->write1) {
+                        pEnd->write1=0x00;   /* second end ccw is now active */
+                        /*      set up Tic CCWs         */
+                        p_last_ccw->w_TIC_1.cda=
+				(__u32)__pa(&pEnd->write2_nop1);
+                        pEnd->write2_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+                        pEnd->write2_nop2.flags    =
+				CCW_FLAG_SLI | CCW_FLAG_SKIP;
+                        pEnd->write2_nop2.cda=0;
+                        pEnd->write2_nop2.count=1;
+                }
+                else {  /*  end of if (pEnd->write1)*/
+                        pEnd->write1=0x01;   /* first end ccw is now active */
+                        /*      set up Tic CCWs         */
+                        p_last_ccw->w_TIC_1.cda=
+				(__u32)__pa(&pEnd->write1_nop1);
+                        pEnd->write1_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+                        pEnd->write1_nop2.flags    =
+				CCW_FLAG_SLI | CCW_FLAG_SKIP;
+                        pEnd->write1_nop2.cda=0;
+                        pEnd->write1_nop2.count=1;
+                }  /* end if if (pEnd->write1) */
+
+
+                if (privptr->p_write_active_first==NULL ) {
+                        privptr->p_write_active_first=p_first_ccw;
+                        privptr->p_write_active_last=p_last_ccw;
+                }
+                else {
+
+                        /*      set up Tic CCWs         */
+
+                        tempCCW.cda=(__u32)__pa(&p_first_ccw->write);
+                        tempCCW.count=0;
+                        tempCCW.flags=0;
+                        tempCCW.cmd_code=CCW_CLAW_CMD_TIC;
+
+                        if (pEnd->write1) {
+
+                 /*
+                 * first set of ending CCW's is chained to the new write
+                 * chain, so the second set is chained to the active chain
+                 * Therefore modify the second set to point the new write chain.
+                 * make sure we update the CCW atomically
+                 * so channel does not fetch it when it's only half done
+                 */
+                                memcpy( &pEnd->write2_nop2, &tempCCW ,
+					sizeof(struct ccw1));
+                                privptr->p_write_active_last->w_TIC_1.cda=
+					(__u32)__pa(&p_first_ccw->write);
+                        }
+                        else {
+
+                        /*make sure we update the CCW atomically
+                         *so channel does not fetch it when it's only half done
+                         */
+                                memcpy(&pEnd->write1_nop2, &tempCCW ,
+					sizeof(struct ccw1));
+                                privptr->p_write_active_last->w_TIC_1.cda=
+				        (__u32)__pa(&p_first_ccw->write);
+
+                        } /* end if if (pEnd->write1) */
+
+                        privptr->p_write_active_last->next=p_first_ccw;
+                        privptr->p_write_active_last=p_last_ccw;
+                }
+
+        } /* endif (p_first_ccw!=NULL)  */
+
+
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: %s() >  Dump Active CCW chain \n",
+		dev->name,__FUNCTION__);
+        p_buf=privptr->p_write_active_first;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+        p_buf=(struct ccwbk*)privptr->p_end_ccw;
+        dumpit((char *)p_buf, sizeof(struct endccw));
+#endif
+        dev_kfree_skb(skb);
+	if (linkid==0) {
+        	lock=LOCK_NO;
+        }
+        else  {
+                lock=LOCK_YES;
+        }
+        claw_strt_out_IO(dev );
+        /*      if write free count is zero , set NOBUFFER       */
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() > free_count is %d\n",
+		dev->name,__FUNCTION__,
+		(int) privptr->write_free_count );
+#endif
+	if (privptr->write_free_count==0) {
+		claw_setbit_busy(TB_NOBUFFER,dev);
+        }
+Done2:
+	claw_clearbit_busy(TB_TX,dev);
+Done:
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > exit on line %d, rc = %d \n",
+		dev->name,__FUNCTION__,__LINE__, rc);
+#endif
+	return(rc);
+}    /*    end of claw_hw_tx    */
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*     init_ccw_bk                                                    *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+init_ccw_bk(struct net_device *dev)
+{
+
+        __u32   ccw_blocks_required;
+        __u32   ccw_blocks_perpage;
+        __u32   ccw_pages_required;
+        __u32   claw_reads_perpage=1;
+        __u32   claw_read_pages;
+        __u32   claw_writes_perpage=1;
+        __u32   claw_write_pages;
+        void    *p_buff=NULL;
+        struct ccwbk*p_free_chain;
+	struct ccwbk*p_buf;
+	struct ccwbk*p_last_CCWB;
+	struct ccwbk*p_first_CCWB;
+        struct endccw *p_endccw=NULL;
+        addr_t  real_address;
+        struct claw_privbk *privptr=dev->priv;
+        struct clawh *pClawH=NULL;
+        addr_t   real_TIC_address;
+        int i,j;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"init_ccw");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+#endif
+
+        /*  initialize  statistics field */
+        privptr->active_link_ID=0;
+        /*  initialize  ccwbk pointers  */
+        privptr->p_write_free_chain=NULL;   /* pointer to free ccw chain*/
+        privptr->p_write_active_first=NULL; /* pointer to the first write ccw*/
+        privptr->p_write_active_last=NULL;  /* pointer to the last write ccw*/
+        privptr->p_read_active_first=NULL;  /* pointer to the first read ccw*/
+        privptr->p_read_active_last=NULL;   /* pointer to the last read ccw */
+        privptr->p_end_ccw=NULL;            /* pointer to ending ccw        */
+        privptr->p_claw_signal_blk=NULL;    /* pointer to signal block      */
+	privptr->buffs_alloc = 0;
+        memset(&privptr->end_ccw, 0x00, sizeof(struct endccw));
+        memset(&privptr->ctl_bk, 0x00, sizeof(struct clawctl));
+        /*  initialize  free write ccwbk counter  */
+        privptr->write_free_count=0;  /* number of free bufs on write chain */
+        p_last_CCWB = NULL;
+        p_first_CCWB= NULL;
+        /*
+        *  We need 1 CCW block for each read buffer, 1 for each
+        *  write buffer, plus 1 for ClawSignalBlock
+        */
+        ccw_blocks_required =
+		privptr->p_env->read_buffers+privptr->p_env->write_buffers+1;
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() "
+		"ccw_blocks_required=%d\n",
+		dev->name,__FUNCTION__,
+		ccw_blocks_required);
+        printk(KERN_INFO "%s: %s() "
+		"PAGE_SIZE=0x%x\n",
+		dev->name,__FUNCTION__,
+		(unsigned int)PAGE_SIZE);
+        printk(KERN_INFO "%s: %s() > "
+		"PAGE_MASK=0x%x\n",
+		dev->name,__FUNCTION__,
+		(unsigned int)PAGE_MASK);
+#endif
+        /*
+        * compute number of CCW blocks that will fit in a page
+        */
+        ccw_blocks_perpage= PAGE_SIZE /  CCWBK_SIZE;
+        ccw_pages_required=
+		(ccw_blocks_required+ccw_blocks_perpage -1) /
+			 ccw_blocks_perpage;
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() > ccw_blocks_perpage=%d\n",
+		dev->name,__FUNCTION__,
+		ccw_blocks_perpage);
+        printk(KERN_INFO "%s: %s() > ccw_pages_required=%d\n",
+		dev->name,__FUNCTION__,
+		ccw_pages_required);
+#endif
+        /*
+         *  read and write sizes are set by 2 constants in claw.h
+	 *  4k and 32k.  Unpacked values other than 4k are not going to
+	 * provide good performance. With packing buffers support 32k
+	 * buffers are used.
+         */
+        if (privptr->p_env->read_size < PAGE_SIZE) {
+            claw_reads_perpage= PAGE_SIZE / privptr->p_env->read_size;
+            claw_read_pages= (privptr->p_env->read_buffers +
+	    	claw_reads_perpage -1) / claw_reads_perpage;
+         }
+         else {       /* > or equal  */
+            privptr->p_buff_pages_perread=
+	    	(privptr->p_env->read_size + PAGE_SIZE - 1) / PAGE_SIZE;
+            claw_read_pages=
+	    	privptr->p_env->read_buffers * privptr->p_buff_pages_perread;
+         }
+        if (privptr->p_env->write_size < PAGE_SIZE) {
+            claw_writes_perpage=
+	    	PAGE_SIZE / privptr->p_env->write_size;
+            claw_write_pages=
+	    	(privptr->p_env->write_buffers + claw_writes_perpage -1) /
+			claw_writes_perpage;
+
+        }
+        else {      /* >  or equal  */
+            privptr->p_buff_pages_perwrite=
+	    	 (privptr->p_env->read_size + PAGE_SIZE - 1) / PAGE_SIZE;
+            claw_write_pages=
+	     	privptr->p_env->write_buffers * privptr->p_buff_pages_perwrite;
+        }
+#ifdef DEBUGMSG
+        if (privptr->p_env->read_size < PAGE_SIZE) {
+            printk(KERN_INFO "%s: %s() reads_perpage=%d\n",
+	    	dev->name,__FUNCTION__,
+		claw_reads_perpage);
+        }
+        else {
+            printk(KERN_INFO "%s: %s() pages_perread=%d\n",
+	    	dev->name,__FUNCTION__,
+		privptr->p_buff_pages_perread);
+        }
+        printk(KERN_INFO "%s: %s() read_pages=%d\n",
+		dev->name,__FUNCTION__,
+		claw_read_pages);
+        if (privptr->p_env->write_size < PAGE_SIZE) {
+            printk(KERN_INFO "%s: %s() writes_perpage=%d\n",
+	    	dev->name,__FUNCTION__,
+		claw_writes_perpage);
+        }
+        else {
+            printk(KERN_INFO "%s: %s() pages_perwrite=%d\n",
+	    	dev->name,__FUNCTION__,
+		privptr->p_buff_pages_perwrite);
+        }
+        printk(KERN_INFO "%s: %s() write_pages=%d\n",
+		dev->name,__FUNCTION__,
+		claw_write_pages);
+#endif
+
+
+        /*
+        *               allocate ccw_pages_required
+        */
+        if (privptr->p_buff_ccw==NULL) {
+                privptr->p_buff_ccw=
+			(void *)__get_free_pages(__GFP_DMA,
+		        (int)pages_to_order_of_mag(ccw_pages_required ));
+                if (privptr->p_buff_ccw==NULL) {
+                        printk(KERN_INFO "%s: %s()  "
+				"__get_free_pages for CCWs failed : "
+				"pages is %d\n",
+                                dev->name,__FUNCTION__,
+				ccw_pages_required );
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s: %s() > "
+				"exit on line %d, rc = ENOMEM\n",
+				dev->name,__FUNCTION__,
+				 __LINE__);
+#endif
+                        return -ENOMEM;
+                }
+                privptr->p_buff_ccw_num=ccw_pages_required;
+        }
+        memset(privptr->p_buff_ccw, 0x00,
+		privptr->p_buff_ccw_num * PAGE_SIZE);
+
+        /*
+        *               obtain ending ccw block address
+        *
+        */
+        privptr->p_end_ccw = (struct endccw *)&privptr->end_ccw;
+        real_address  = (__u32)__pa(privptr->p_end_ccw);
+        /*                              Initialize ending CCW block       */
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() begin initialize ending CCW blocks\n",
+		dev->name,__FUNCTION__);
+#endif
+
+        p_endccw=privptr->p_end_ccw;
+        p_endccw->real=real_address;
+        p_endccw->write1=0x00;
+        p_endccw->read1=0x00;
+
+        /*      write1_nop1                                     */
+        p_endccw->write1_nop1.cmd_code = CCW_CLAW_CMD_NOP;
+        p_endccw->write1_nop1.flags       = CCW_FLAG_SLI | CCW_FLAG_CC;
+        p_endccw->write1_nop1.count       = 1;
+        p_endccw->write1_nop1.cda         = 0;
+
+        /*      write1_nop2                                     */
+        p_endccw->write1_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+        p_endccw->write1_nop2.flags        = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+        p_endccw->write1_nop2.count      = 1;
+        p_endccw->write1_nop2.cda        = 0;
+
+        /*      write2_nop1                                     */
+        p_endccw->write2_nop1.cmd_code = CCW_CLAW_CMD_NOP;
+        p_endccw->write2_nop1.flags        = CCW_FLAG_SLI | CCW_FLAG_CC;
+        p_endccw->write2_nop1.count        = 1;
+        p_endccw->write2_nop1.cda          = 0;
+
+        /*      write2_nop2                                     */
+        p_endccw->write2_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+        p_endccw->write2_nop2.flags        = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+        p_endccw->write2_nop2.count        = 1;
+        p_endccw->write2_nop2.cda          = 0;
+
+        /*      read1_nop1                                      */
+        p_endccw->read1_nop1.cmd_code = CCW_CLAW_CMD_NOP;
+        p_endccw->read1_nop1.flags        = CCW_FLAG_SLI | CCW_FLAG_CC;
+        p_endccw->read1_nop1.count        = 1;
+        p_endccw->read1_nop1.cda          = 0;
+
+        /*      read1_nop2                                      */
+        p_endccw->read1_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+        p_endccw->read1_nop2.flags        = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+        p_endccw->read1_nop2.count        = 1;
+        p_endccw->read1_nop2.cda          = 0;
+
+        /*      read2_nop1                                      */
+        p_endccw->read2_nop1.cmd_code = CCW_CLAW_CMD_NOP;
+        p_endccw->read2_nop1.flags        = CCW_FLAG_SLI | CCW_FLAG_CC;
+        p_endccw->read2_nop1.count        = 1;
+        p_endccw->read2_nop1.cda          = 0;
+
+        /*      read2_nop2                                      */
+        p_endccw->read2_nop2.cmd_code = CCW_CLAW_CMD_READFF;
+        p_endccw->read2_nop2.flags        = CCW_FLAG_SLI | CCW_FLAG_SKIP;
+        p_endccw->read2_nop2.count        = 1;
+        p_endccw->read2_nop2.cda          = 0;
+
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: %s() dump claw ending CCW BK \n",
+		dev->name,__FUNCTION__);
+        dumpit((char *)p_endccw, sizeof(struct endccw));
+#endif
+
+        /*
+        *                               Build a chain of CCWs
+        *
+        */
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s()  Begin build a chain of CCW buffer \n",
+		dev->name,__FUNCTION__);
+#endif
+        p_buff=privptr->p_buff_ccw;
+
+        p_free_chain=NULL;
+        for (i=0 ; i < ccw_pages_required; i++ ) {
+                real_address  = (__u32)__pa(p_buff);
+                p_buf=p_buff;
+                for (j=0 ; j < ccw_blocks_perpage ; j++) {
+                        p_buf->next  = p_free_chain;
+                        p_free_chain = p_buf;
+                        p_buf->real=(__u32)__pa(p_buf);
+                        ++p_buf;
+                }
+                p_buff+=PAGE_SIZE;
+        }
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() "
+		"End build a chain of CCW buffer \n",
+			dev->name,__FUNCTION__);
+        p_buf=p_free_chain;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+#endif
+
+        /*
+        *                               Initialize ClawSignalBlock
+        *
+        */
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() "
+		"Begin initialize ClawSignalBlock \n",
+		dev->name,__FUNCTION__);
+#endif
+        if (privptr->p_claw_signal_blk==NULL) {
+                privptr->p_claw_signal_blk=p_free_chain;
+                p_free_chain=p_free_chain->next;
+                pClawH=(struct clawh *)privptr->p_claw_signal_blk;
+                pClawH->length=0xffff;
+                pClawH->opcode=0xff;
+                pClawH->flag=CLAW_BUSY;
+        }
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() >  End initialize "
+	 	"ClawSignalBlock\n",
+		dev->name,__FUNCTION__);
+        dumpit((char *)privptr->p_claw_signal_blk, sizeof(struct ccwbk));
+#endif
+
+        /*
+        *               allocate write_pages_required and add to free chain
+        */
+        if (privptr->p_buff_write==NULL) {
+            if (privptr->p_env->write_size < PAGE_SIZE) {
+                privptr->p_buff_write=
+			(void *)__get_free_pages(__GFP_DMA,
+			(int)pages_to_order_of_mag(claw_write_pages ));
+                if (privptr->p_buff_write==NULL) {
+                        printk(KERN_INFO "%s: %s() __get_free_pages for write"
+				" bufs failed : get is for %d pages\n",
+                                dev->name,__FUNCTION__,claw_write_pages );
+                        free_pages((unsigned long)privptr->p_buff_ccw,
+			   (int)pages_to_order_of_mag(privptr->p_buff_ccw_num));
+                        privptr->p_buff_ccw=NULL;
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s: %s() > exit on line %d,"
+			 	"rc = ENOMEM\n",
+				dev->name,__FUNCTION__,__LINE__);
+#endif
+                        return -ENOMEM;
+                }
+                /*
+                *                               Build CLAW write free chain
+                *
+                */
+
+                memset(privptr->p_buff_write, 0x00,
+			ccw_pages_required * PAGE_SIZE);
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: %s() Begin build claw write free "
+			"chain \n",dev->name,__FUNCTION__);
+#endif
+                privptr->p_write_free_chain=NULL;
+
+                p_buff=privptr->p_buff_write;
+
+                for (i=0 ; i< privptr->p_env->write_buffers ; i++) {
+                        p_buf        = p_free_chain;      /*  get a CCW */
+                        p_free_chain = p_buf->next;
+                        p_buf->next  =privptr->p_write_free_chain;
+                        privptr->p_write_free_chain = p_buf;
+                        p_buf-> p_buffer	= (struct clawbuf *)p_buff;
+                        p_buf-> write.cda       = (__u32)__pa(p_buff);
+                        p_buf-> write.flags     = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> w_read_FF.cmd_code = CCW_CLAW_CMD_READFF;
+                        p_buf-> w_read_FF.flags   = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> w_read_FF.count   = 1;
+                        p_buf-> w_read_FF.cda     =
+				(__u32)__pa(&p_buf-> header.flag);
+                        p_buf-> w_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;
+                        p_buf-> w_TIC_1.flags      = 0;
+                        p_buf-> w_TIC_1.count      = 0;
+
+                        if (((unsigned long)p_buff+privptr->p_env->write_size) >=
+			   ((unsigned long)(p_buff+2*
+				(privptr->p_env->write_size) -1) & PAGE_MASK)) {
+                        p_buff= p_buff+privptr->p_env->write_size;
+                        }
+                }
+           }
+           else      /*  Buffers are => PAGE_SIZE. 1 buff per get_free_pages */
+           {
+               privptr->p_write_free_chain=NULL;
+               for (i = 0; i< privptr->p_env->write_buffers ; i++) {
+                   p_buff=(void *)__get_free_pages(__GFP_DMA,
+		        (int)pages_to_order_of_mag(
+			privptr->p_buff_pages_perwrite) );
+#ifdef IOTRACE
+                   printk(KERN_INFO "%s:%s __get_free_pages "
+		    "for writes buf: get for %d pages\n",
+		    dev->name,__FUNCTION__,
+		    privptr->p_buff_pages_perwrite);
+#endif
+                   if (p_buff==NULL) {
+                        printk(KERN_INFO "%s:%s __get_free_pages"
+			 	"for writes buf failed : get is for %d pages\n",
+				dev->name,
+				__FUNCTION__,
+				privptr->p_buff_pages_perwrite );
+                        free_pages((unsigned long)privptr->p_buff_ccw,
+			      (int)pages_to_order_of_mag(
+			      		privptr->p_buff_ccw_num));
+                        privptr->p_buff_ccw=NULL;
+			p_buf=privptr->p_buff_write;
+                        while (p_buf!=NULL) {
+                                free_pages((unsigned long)
+					p_buf->p_buffer,
+					(int)pages_to_order_of_mag(
+					privptr->p_buff_pages_perwrite));
+                                p_buf=p_buf->next;
+                        }
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s: %s exit on line %d, rc = ENOMEM\n",
+			dev->name,
+			__FUNCTION__,
+			__LINE__);
+#endif
+                        return -ENOMEM;
+                   }  /* Error on get_pages   */
+                   memset(p_buff, 0x00, privptr->p_env->write_size );
+                   p_buf         = p_free_chain;
+                   p_free_chain  = p_buf->next;
+                   p_buf->next   = privptr->p_write_free_chain;
+                   privptr->p_write_free_chain = p_buf;
+                   privptr->p_buff_write = p_buf;
+                   p_buf->p_buffer=(struct clawbuf *)p_buff;
+                   p_buf-> write.cda     = (__u32)__pa(p_buff);
+                   p_buf-> write.flags   = CCW_FLAG_SLI | CCW_FLAG_CC;
+                   p_buf-> w_read_FF.cmd_code = CCW_CLAW_CMD_READFF;
+                   p_buf-> w_read_FF.flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
+                   p_buf-> w_read_FF.count    = 1;
+                   p_buf-> w_read_FF.cda      =
+			(__u32)__pa(&p_buf-> header.flag);
+                   p_buf-> w_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;
+                   p_buf-> w_TIC_1.flags   = 0;
+                   p_buf-> w_TIC_1.count   = 0;
+               }  /* for all write_buffers   */
+
+           }    /* else buffers are PAGE_SIZE or bigger */
+
+        }
+        privptr->p_buff_write_num=claw_write_pages;
+        privptr->write_free_count=privptr->p_env->write_buffers;
+
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s:%s  End build claw write free chain \n",
+	dev->name,__FUNCTION__);
+        p_buf=privptr->p_write_free_chain;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+#endif
+        /*
+        *               allocate read_pages_required and chain to free chain
+        */
+        if (privptr->p_buff_read==NULL) {
+            if (privptr->p_env->read_size < PAGE_SIZE)  {
+                privptr->p_buff_read=
+			(void *)__get_free_pages(__GFP_DMA,
+			(int)pages_to_order_of_mag(claw_read_pages) );
+                if (privptr->p_buff_read==NULL) {
+                        printk(KERN_INFO "%s: %s() "
+			 	"__get_free_pages for read buf failed : "
+			 	"get is for %d pages\n",
+                                dev->name,__FUNCTION__,claw_read_pages );
+                        free_pages((unsigned long)privptr->p_buff_ccw,
+				(int)pages_to_order_of_mag(
+					privptr->p_buff_ccw_num));
+			/* free the write pages size is < page size  */
+                        free_pages((unsigned long)privptr->p_buff_write,
+				(int)pages_to_order_of_mag(
+				privptr->p_buff_write_num));
+                        privptr->p_buff_ccw=NULL;
+                        privptr->p_buff_write=NULL;
+#ifdef FUNCTRACE
+                        printk(KERN_INFO "%s: %s() > exit on line %d, rc ="
+				" ENOMEM\n",dev->name,__FUNCTION__,__LINE__);
+#endif
+                        return -ENOMEM;
+                }
+                memset(privptr->p_buff_read, 0x00, claw_read_pages * PAGE_SIZE);
+                privptr->p_buff_read_num=claw_read_pages;
+                /*
+                *                               Build CLAW read free chain
+                *
+                */
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: %s() Begin build claw read free chain \n",
+			dev->name,__FUNCTION__);
+#endif
+                p_buff=privptr->p_buff_read;
+                for (i=0 ; i< privptr->p_env->read_buffers ; i++) {
+                        p_buf        = p_free_chain;
+                        p_free_chain = p_buf->next;
+
+                        if (p_last_CCWB==NULL) {
+                                p_buf->next=NULL;
+                                real_TIC_address=0;
+                                p_last_CCWB=p_buf;
+                        }
+                        else {
+                                p_buf->next=p_first_CCWB;
+                                real_TIC_address=
+				(__u32)__pa(&p_first_CCWB -> read );
+                        }
+
+                        p_first_CCWB=p_buf;
+
+                        p_buf->p_buffer=(struct clawbuf *)p_buff;
+                        /*  initialize read command */
+                        p_buf-> read.cmd_code = CCW_CLAW_CMD_READ;
+                        p_buf-> read.cda = (__u32)__pa(p_buff);
+                        p_buf-> read.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> read.count       = privptr->p_env->read_size;
+
+                        /*  initialize read_h command */
+                        p_buf-> read_h.cmd_code = CCW_CLAW_CMD_READHEADER;
+                        p_buf-> read_h.cda =
+				(__u32)__pa(&(p_buf->header));
+                        p_buf-> read_h.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> read_h.count      = sizeof(struct clawh);
+
+                        /*  initialize Signal command */
+                        p_buf-> signal.cmd_code = CCW_CLAW_CMD_SIGNAL_SMOD;
+                        p_buf-> signal.cda =
+				(__u32)__pa(&(pClawH->flag));
+                        p_buf-> signal.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> signal.count     = 1;
+
+                        /*  initialize r_TIC_1 command */
+                        p_buf-> r_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;
+                        p_buf-> r_TIC_1.cda = (__u32)real_TIC_address;
+                        p_buf-> r_TIC_1.flags = 0;
+                        p_buf-> r_TIC_1.count      = 0;
+
+                        /*  initialize r_read_FF command */
+                        p_buf-> r_read_FF.cmd_code = CCW_CLAW_CMD_READFF;
+                        p_buf-> r_read_FF.cda =
+				(__u32)__pa(&(pClawH->flag));
+                        p_buf-> r_read_FF.flags =
+				CCW_FLAG_SLI | CCW_FLAG_CC | CCW_FLAG_PCI;
+                        p_buf-> r_read_FF.count    = 1;
+
+                        /*    initialize r_TIC_2          */
+                        memcpy(&p_buf->r_TIC_2,
+				&p_buf->r_TIC_1, sizeof(struct ccw1));
+
+                        /*     initialize Header     */
+                        p_buf->header.length=0xffff;
+                        p_buf->header.opcode=0xff;
+                        p_buf->header.flag=CLAW_PENDING;
+
+                        if (((unsigned long)p_buff+privptr->p_env->read_size) >=
+				((unsigned long)(p_buff+2*(privptr->p_env->read_size) -1)
+				 & PAGE_MASK) ) {
+                                p_buff= p_buff+privptr->p_env->read_size;
+                        }
+                        else {
+                                p_buff=
+				(void *)((unsigned long)
+					(p_buff+2*(privptr->p_env->read_size) -1)
+					 & PAGE_MASK) ;
+                        }
+                }   /* for read_buffers   */
+          }         /* read_size < PAGE_SIZE  */
+          else {  /* read Size >= PAGE_SIZE  */
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() Begin build claw read free chain \n",
+		dev->name,__FUNCTION__);
+#endif
+                for (i=0 ; i< privptr->p_env->read_buffers ; i++) {
+                        p_buff = (void *)__get_free_pages(__GFP_DMA,
+				(int)pages_to_order_of_mag(privptr->p_buff_pages_perread) );
+                        if (p_buff==NULL) {
+                                printk(KERN_INFO "%s: %s() __get_free_pages for read "
+					"buf failed : get is for %d pages\n",
+					dev->name,__FUNCTION__,
+                                        privptr->p_buff_pages_perread );
+                                free_pages((unsigned long)privptr->p_buff_ccw,
+					(int)pages_to_order_of_mag(privptr->p_buff_ccw_num));
+				/* free the write pages  */
+	                        p_buf=privptr->p_buff_write;
+                                while (p_buf!=NULL) {
+                                        free_pages((unsigned long)p_buf->p_buffer,
+						(int)pages_to_order_of_mag(
+						privptr->p_buff_pages_perwrite ));
+                                        p_buf=p_buf->next;
+                                }
+				/* free any read pages already alloc  */
+	                        p_buf=privptr->p_buff_read;
+                                while (p_buf!=NULL) {
+                                        free_pages((unsigned long)p_buf->p_buffer,
+						(int)pages_to_order_of_mag(
+						privptr->p_buff_pages_perread ));
+                                        p_buf=p_buf->next;
+                                }
+                                privptr->p_buff_ccw=NULL;
+                                privptr->p_buff_write=NULL;
+#ifdef FUNCTRACE
+                                printk(KERN_INFO "%s: %s() exit on line %d, rc = ENOMEM\n",
+					dev->name,__FUNCTION__,
+					__LINE__);
+#endif
+                                return -ENOMEM;
+                        }
+                        memset(p_buff, 0x00, privptr->p_env->read_size);
+                        p_buf        = p_free_chain;
+                        privptr->p_buff_read = p_buf;
+                        p_free_chain = p_buf->next;
+
+                        if (p_last_CCWB==NULL) {
+                                p_buf->next=NULL;
+                                real_TIC_address=0;
+                                p_last_CCWB=p_buf;
+                        }
+                        else {
+                                p_buf->next=p_first_CCWB;
+                                real_TIC_address=
+					(addr_t)__pa(
+						&p_first_CCWB -> read );
+                        }
+
+                        p_first_CCWB=p_buf;
+				/* save buff address */
+                        p_buf->p_buffer=(struct clawbuf *)p_buff;
+                        /*  initialize read command */
+                        p_buf-> read.cmd_code = CCW_CLAW_CMD_READ;
+                        p_buf-> read.cda = (__u32)__pa(p_buff);
+                        p_buf-> read.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> read.count       = privptr->p_env->read_size;
+
+                        /*  initialize read_h command */
+                        p_buf-> read_h.cmd_code = CCW_CLAW_CMD_READHEADER;
+                        p_buf-> read_h.cda =
+				(__u32)__pa(&(p_buf->header));
+                        p_buf-> read_h.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> read_h.count      = sizeof(struct clawh);
+
+                        /*  initialize Signal command */
+                        p_buf-> signal.cmd_code = CCW_CLAW_CMD_SIGNAL_SMOD;
+                        p_buf-> signal.cda =
+				(__u32)__pa(&(pClawH->flag));
+                        p_buf-> signal.flags = CCW_FLAG_SLI | CCW_FLAG_CC;
+                        p_buf-> signal.count     = 1;
+
+                        /*  initialize r_TIC_1 command */
+                        p_buf-> r_TIC_1.cmd_code = CCW_CLAW_CMD_TIC;
+                        p_buf-> r_TIC_1.cda = (__u32)real_TIC_address;
+                        p_buf-> r_TIC_1.flags = 0;
+                        p_buf-> r_TIC_1.count      = 0;
+
+                        /*  initialize r_read_FF command */
+                        p_buf-> r_read_FF.cmd_code = CCW_CLAW_CMD_READFF;
+                        p_buf-> r_read_FF.cda =
+				(__u32)__pa(&(pClawH->flag));
+                        p_buf-> r_read_FF.flags =
+				CCW_FLAG_SLI | CCW_FLAG_CC | CCW_FLAG_PCI;
+                        p_buf-> r_read_FF.count    = 1;
+
+                        /*    initialize r_TIC_2          */
+                        memcpy(&p_buf->r_TIC_2, &p_buf->r_TIC_1,
+				sizeof(struct ccw1));
+
+                        /*     initialize Header     */
+                        p_buf->header.length=0xffff;
+                        p_buf->header.opcode=0xff;
+                        p_buf->header.flag=CLAW_PENDING;
+
+                }    /* For read_buffers   */
+          }     /*  read_size >= PAGE_SIZE   */
+        }       /*  pBuffread = NULL */
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: %s() >  End build claw read free chain \n",
+		dev->name,__FUNCTION__);
+        p_buf=p_first_CCWB;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+
+#endif
+        add_claw_reads( dev  ,p_first_CCWB , p_last_CCWB);
+	privptr->buffs_alloc = 1;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+        return 0;
+}    /*    end of init_ccw_bk */
+
+/*-------------------------------------------------------------------*
+*                                                                    *
+*       probe_error                                                  *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static void
+probe_error( struct ccwgroup_device *cgdev)
+{
+  struct claw_privbk *privptr;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s enter  \n",__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"proberr");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s variable cgdev =\n",__FUNCTION__);
+        dumpit((char *) cgdev, sizeof(struct ccwgroup_device));
+#endif
+        privptr=(struct claw_privbk *)cgdev->dev.driver_data;
+	if (privptr!=NULL) {
+		if (privptr->p_env != NULL) {
+			kfree(privptr->p_env);
+			privptr->p_env=NULL;
+		}
+        	if (privptr->p_mtc_envelope!=NULL) {
+                	kfree(privptr->p_mtc_envelope);
+                	privptr->p_mtc_envelope=NULL;
+        	}
+                kfree(privptr);
+                privptr=NULL;
+        }
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s > exit on line %d\n",
+		 __FUNCTION__,__LINE__);
+#endif
+
+        return;
+}    /*    probe_error    */
+
+
+
+/*-------------------------------------------------------------------*
+*    claw_process_control                                            *
+*                                                                    *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+claw_process_control( struct net_device *dev, struct ccwbk * p_ccw)
+{
+
+        struct clawbuf *p_buf;
+        struct clawctl  ctlbk;
+        struct clawctl *p_ctlbk;
+        char    temp_host_name[8];
+        char    temp_ws_name[8];
+        struct claw_privbk *privptr;
+        struct claw_env *p_env;
+        struct sysval *p_sysval;
+        struct conncmd *p_connect=NULL;
+        int rc;
+        struct chbk *p_ch = NULL;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() > enter  \n",
+		dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"clw_cntl");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable p_ccw =\n",dev->name);
+        dumpit((char *) p_ccw, sizeof(struct ccwbk *));
+#endif
+        udelay(1000);  /* Wait a ms for the control packets to
+			*catch up to each other */
+        privptr=dev->priv;
+        p_env=privptr->p_env;
+	memcpy( &temp_host_name, p_env->host_name, 8);
+        memcpy( &temp_ws_name, p_env->adapter_name , 8);
+        printk(KERN_INFO "%s: CLAW device %.8s: "
+		"Received Control Packet\n",
+		dev->name, temp_ws_name);
+        if (privptr->release_pend==1) {
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s: %s() > "
+			"exit on line %d, rc=0\n",
+			dev->name,__FUNCTION__,__LINE__);
+#endif
+                return 0;
+        }
+        p_buf=p_ccw->p_buffer;
+        p_ctlbk=&ctlbk;
+	if (p_env->packing == DO_PACKED) { /* packing in progress?*/
+		memcpy(p_ctlbk, &p_buf->buffer[4], sizeof(struct clawctl));
+	} else {
+		memcpy(p_ctlbk, p_buf, sizeof(struct clawctl));
+	}
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: dump claw control data inbound\n",dev->name);
+        dumpit((char *)p_ctlbk, sizeof(struct clawctl));
+#endif
+        switch (p_ctlbk->command)
+        {
+                case SYSTEM_VALIDATE_REQUEST:
+                        if (p_ctlbk->version!=CLAW_VERSION_ID) {
+                                claw_snd_sys_validate_rsp(dev, p_ctlbk,
+					CLAW_RC_WRONG_VERSION );
+                                printk("%s: %d is wrong version id. "
+					"Expected %d\n",
+					dev->name, p_ctlbk->version,
+                                        CLAW_VERSION_ID);
+                        }
+                        p_sysval=(struct sysval *)&(p_ctlbk->data);
+			printk( "%s: Recv Sys Validate Request: "
+				"Vers=%d,link_id=%d,Corr=%d,WS name=%."
+				"8s,Host name=%.8s\n",
+                                dev->name, p_ctlbk->version,
+				p_ctlbk->linkid,
+				p_ctlbk->correlator,
+				p_sysval->WS_name,
+                                p_sysval->host_name);
+                        if (0!=memcmp(temp_host_name,p_sysval->host_name,8)) {
+                                claw_snd_sys_validate_rsp(dev, p_ctlbk,
+					CLAW_RC_NAME_MISMATCH );
+				CLAW_DBF_TEXT(2,setup,"HSTBAD");
+				CLAW_DBF_TEXT_(2,setup,"%s",p_sysval->host_name);
+				CLAW_DBF_TEXT_(2,setup,"%s",temp_host_name);
+                                printk(KERN_INFO "%s:  Host name mismatch\n",
+					dev->name);
+				printk(KERN_INFO "%s: Received :%s: "
+					"expected :%s: \n",
+					dev->name,
+					p_sysval->host_name,
+					temp_host_name);
+                        }
+                        if (0!=memcmp(temp_ws_name,p_sysval->WS_name,8)) {
+                                claw_snd_sys_validate_rsp(dev, p_ctlbk,
+					CLAW_RC_NAME_MISMATCH );
+				CLAW_DBF_TEXT(2,setup,"WSNBAD");
+                                CLAW_DBF_TEXT_(2,setup,"%s",p_sysval->WS_name);
+                                CLAW_DBF_TEXT_(2,setup,"%s",temp_ws_name);
+                                printk(KERN_INFO "%s: WS name mismatch\n",
+					dev->name);
+				 printk(KERN_INFO "%s: Received :%s: "
+                                        "expected :%s: \n",
+                                        dev->name,
+                                        p_sysval->WS_name,
+					temp_ws_name);
+                        }
+                        if (( p_sysval->write_frame_size < p_env->write_size) &&
+			   ( p_env->packing == 0)) {
+                                claw_snd_sys_validate_rsp(dev, p_ctlbk,
+					CLAW_RC_HOST_RCV_TOO_SMALL );
+                                printk(KERN_INFO "%s: host write size is too "
+					"small\n", dev->name);
+				CLAW_DBF_TEXT(2,setup,"wrtszbad");
+                        }
+                        if (( p_sysval->read_frame_size < p_env->read_size) &&
+			   ( p_env->packing == 0)) {
+                                claw_snd_sys_validate_rsp(dev, p_ctlbk,
+					CLAW_RC_HOST_RCV_TOO_SMALL );
+                                printk(KERN_INFO "%s: host read size is too "
+					"small\n", dev->name);
+				CLAW_DBF_TEXT(2,setup,"rdsizbad");
+                        }
+                        claw_snd_sys_validate_rsp(dev, p_ctlbk, 0 );
+                        printk("%s: CLAW device %.8s: System validate"
+				" completed.\n",dev->name, temp_ws_name);
+			printk("%s: sys Validate Rsize:%d Wsize:%d\n",dev->name,
+				p_sysval->read_frame_size,p_sysval->write_frame_size);
+                        privptr->system_validate_comp=1;
+                	if(strncmp(p_env->api_type,WS_APPL_NAME_PACKED,6) == 0) {
+				p_env->packing = PACKING_ASK;
+			}
+                        claw_strt_conn_req(dev);
+                        break;
+
+                case SYSTEM_VALIDATE_RESPONSE:
+			p_sysval=(struct sysval *)&(p_ctlbk->data);
+			printk("%s: Recv Sys Validate Resp: Vers=%d,Corr=%d,RC=%d,"
+				"WS name=%.8s,Host name=%.8s\n",
+                        	dev->name,
+                        	p_ctlbk->version,
+                        	p_ctlbk->correlator,
+                        	p_ctlbk->rc,
+                        	p_sysval->WS_name,
+                        	p_sysval->host_name);
+                        switch (p_ctlbk->rc)
+                        {
+                                case 0:
+                                        printk(KERN_INFO "%s: CLAW device "
+						"%.8s: System validate "
+						"completed.\n",
+                                                dev->name, temp_ws_name);
+					if (privptr->system_validate_comp == 0)
+	                                        claw_strt_conn_req(dev);
+					privptr->system_validate_comp=1;
+                                        break;
+                                case CLAW_RC_NAME_MISMATCH:
+                                        printk(KERN_INFO "%s: Sys Validate "
+						"Resp : Host, WS name is "
+						"mismatch\n",
+                                                dev->name);
+                                        break;
+                                case CLAW_RC_WRONG_VERSION:
+                                        printk(KERN_INFO "%s: Sys Validate "
+						"Resp : Wrong version\n",
+						dev->name);
+                                        break;
+                                case CLAW_RC_HOST_RCV_TOO_SMALL:
+                                        printk(KERN_INFO "%s: Sys Validate "
+						"Resp : bad frame size\n",
+						dev->name);
+                                        break;
+                                default:
+                                        printk(KERN_INFO "%s: Sys Validate "
+						"error code=%d \n",
+						 dev->name, p_ctlbk->rc );
+                                        break;
+                        }
+                        break;
+
+                case CONNECTION_REQUEST:
+                        p_connect=(struct conncmd *)&(p_ctlbk->data);
+                        printk(KERN_INFO "%s: Recv Conn Req: Vers=%d,link_id=%d,"
+				"Corr=%d,HOST appl=%.8s,WS appl=%.8s\n",
+                        	dev->name,
+	                        p_ctlbk->version,
+        	                p_ctlbk->linkid,
+                	        p_ctlbk->correlator,
+                        	p_connect->host_name,
+                      		p_connect->WS_name);
+                        if (privptr->active_link_ID!=0 ) {
+                                claw_snd_disc(dev, p_ctlbk);
+                                printk(KERN_INFO "%s: Conn Req error : "
+					"already logical link is active \n",
+					dev->name);
+                        }
+                        if (p_ctlbk->linkid!=1 ) {
+                                claw_snd_disc(dev, p_ctlbk);
+                                printk(KERN_INFO "%s: Conn Req error : "
+					"req logical link id is not 1\n",
+					dev->name);
+                        }
+                        rc=find_link(dev,
+				p_connect->host_name, p_connect->WS_name);
+                        if (rc!=0) {
+                                claw_snd_disc(dev, p_ctlbk);
+                                printk(KERN_INFO "%s: Conn Req error : "
+					"req appl name does not match\n",
+					 dev->name);
+                        }
+                        claw_send_control(dev,
+				CONNECTION_CONFIRM, p_ctlbk->linkid,
+				p_ctlbk->correlator,
+				0, p_connect->host_name,
+                                p_connect->WS_name);
+			if (p_env->packing == PACKING_ASK) {
+				printk("%s: Now Pack ask\n",dev->name);
+				p_env->packing = PACK_SEND;
+				claw_snd_conn_req(dev,0);
+			}
+                        printk(KERN_INFO "%s: CLAW device %.8s: Connection "
+				"completed link_id=%d.\n",
+				dev->name, temp_ws_name,
+                                p_ctlbk->linkid);
+                        privptr->active_link_ID=p_ctlbk->linkid;
+                        p_ch=&privptr->channel[WRITE];
+                        wake_up(&p_ch->wait);  /* wake up claw_open ( WRITE) */
+                        break;
+                case CONNECTION_RESPONSE:
+                        p_connect=(struct conncmd *)&(p_ctlbk->data);
+                        printk(KERN_INFO "%s: Revc Conn Resp: Vers=%d,link_id=%d,"
+				"Corr=%d,RC=%d,Host appl=%.8s, WS appl=%.8s\n",
+                                dev->name,
+				p_ctlbk->version,
+				p_ctlbk->linkid,
+				p_ctlbk->correlator,
+				p_ctlbk->rc,
+				p_connect->host_name,
+                                p_connect->WS_name);
+
+                        if (p_ctlbk->rc !=0 ) {
+                                printk(KERN_INFO "%s: Conn Resp error: rc=%d \n",
+					dev->name, p_ctlbk->rc);
+                                return 1;
+                        }
+                        rc=find_link(dev,
+				p_connect->host_name, p_connect->WS_name);
+                        if (rc!=0) {
+                                claw_snd_disc(dev, p_ctlbk);
+                                printk(KERN_INFO "%s: Conn Resp error: "
+					"req appl name does not match\n",
+					 dev->name);
+                        }
+			/* should be until CONNECTION_CONFIRM */
+                        privptr->active_link_ID =  - (p_ctlbk->linkid);
+                        break;
+                case CONNECTION_CONFIRM:
+                        p_connect=(struct conncmd *)&(p_ctlbk->data);
+                        printk(KERN_INFO "%s: Recv Conn Confirm:Vers=%d,link_id=%d,"
+				"Corr=%d,Host appl=%.8s,WS appl=%.8s\n",
+                        dev->name,
+                        p_ctlbk->version,
+                        p_ctlbk->linkid,
+                        p_ctlbk->correlator,
+                        p_connect->host_name,
+                        p_connect->WS_name);
+                        if (p_ctlbk->linkid== -(privptr->active_link_ID)) {
+                                privptr->active_link_ID=p_ctlbk->linkid;
+				if (p_env->packing > PACKING_ASK) {
+					printk(KERN_INFO "%s: Confirmed Now packing\n",dev->name);
+					p_env->packing = DO_PACKED;
+					}
+				p_ch=&privptr->channel[WRITE];
+                                wake_up(&p_ch->wait);
+                        }
+                        else {
+                                printk(KERN_INFO "%s: Conn confirm: "
+					"unexpected linkid=%d \n",
+					dev->name, p_ctlbk->linkid);
+                                claw_snd_disc(dev, p_ctlbk);
+                        }
+                        break;
+                case DISCONNECT:
+                        printk(KERN_INFO "%s: Disconnect: "
+				"Vers=%d,link_id=%d,Corr=%d\n",
+				dev->name, p_ctlbk->version,
+                                p_ctlbk->linkid, p_ctlbk->correlator);
+			if ((p_ctlbk->linkid == 2) &&
+			    (p_env->packing == PACK_SEND)) {
+				privptr->active_link_ID = 1;
+				p_env->packing = DO_PACKED;
+			}
+			else
+	                        privptr->active_link_ID=0;
+                        break;
+                case CLAW_ERROR:
+                        printk(KERN_INFO "%s: CLAW ERROR detected\n",
+				dev->name);
+                        break;
+                default:
+                        printk(KERN_INFO "%s:  Unexpected command code=%d \n",
+				dev->name,  p_ctlbk->command);
+                        break;
+        }
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s() exit on line %d, rc = 0\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+
+        return 0;
+}   /*    end of claw_process_control    */
+
+
+/*-------------------------------------------------------------------*
+*               claw_send_control                                    *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+claw_send_control(struct net_device *dev, __u8 type, __u8 link,
+	 __u8 correlator, __u8 rc, char *local_name, char *remote_name)
+{
+        struct claw_privbk 		*privptr;
+        struct clawctl                  *p_ctl;
+        struct sysval                   *p_sysval;
+        struct conncmd                  *p_connect;
+        struct sk_buff 			*skb;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s > enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"sndcntl");
+#ifdef DEBUGMSG
+	printk(KERN_INFO "%s: Sending Control Packet \n",dev->name);
+        printk(KERN_INFO "%s: variable type = 0x%X, link = "
+		"%d, correlator = %d, rc = %d\n",
+                dev->name,type, link, correlator, rc);
+        printk(KERN_INFO "%s: variable local_name = %s, "
+		"remote_name = %s\n",dev->name, local_name, remote_name);
+#endif
+        privptr=dev->priv;
+        p_ctl=(struct clawctl *)&privptr->ctl_bk;
+
+        p_ctl->command=type;
+        p_ctl->version=CLAW_VERSION_ID;
+        p_ctl->linkid=link;
+        p_ctl->correlator=correlator;
+        p_ctl->rc=rc;
+
+        p_sysval=(struct sysval *)&p_ctl->data;
+        p_connect=(struct conncmd *)&p_ctl->data;
+
+        switch (p_ctl->command) {
+                case SYSTEM_VALIDATE_REQUEST:
+                case SYSTEM_VALIDATE_RESPONSE:
+                        memcpy(&p_sysval->host_name, local_name, 8);
+                        memcpy(&p_sysval->WS_name, remote_name, 8);
+			if (privptr->p_env->packing > 0) {
+                        	p_sysval->read_frame_size=DEF_PACK_BUFSIZE;
+	                        p_sysval->write_frame_size=DEF_PACK_BUFSIZE;
+			} else {
+				/* how big is the piggest group of packets */
+				p_sysval->read_frame_size=privptr->p_env->read_size;
+	                        p_sysval->write_frame_size=privptr->p_env->write_size;
+			}
+                        memset(&p_sysval->reserved, 0x00, 4);
+                        break;
+                case CONNECTION_REQUEST:
+                case CONNECTION_RESPONSE:
+                case CONNECTION_CONFIRM:
+                case DISCONNECT:
+                        memcpy(&p_sysval->host_name, local_name, 8);
+                        memcpy(&p_sysval->WS_name, remote_name, 8);
+			if (privptr->p_env->packing > 0) {
+			/* How big is the biggest packet */
+				p_connect->reserved1[0]=CLAW_FRAME_SIZE;
+                        	p_connect->reserved1[1]=CLAW_FRAME_SIZE;
+			} else {
+	                        memset(&p_connect->reserved1, 0x00, 4);
+        	                memset(&p_connect->reserved2, 0x00, 4);
+			}
+                        break;
+                default:
+                        break;
+        }
+
+        /*      write Control Record to the device                   */
+
+
+        skb = dev_alloc_skb(sizeof(struct clawctl));
+        if (!skb) {
+                printk(  "%s:%s low on mem, returning...\n",
+			dev->name,__FUNCTION__);
+#ifdef DEBUG
+                printk(KERN_INFO "%s:%s Exit, rc = ENOMEM\n",
+			dev->name,__FUNCTION__);
+#endif
+                return -ENOMEM;
+        }
+	memcpy(skb_put(skb, sizeof(struct clawctl)),
+		p_ctl, sizeof(struct clawctl));
+#ifdef IOTRACE
+	 printk(KERN_INFO "%s: outbnd claw cntl data \n",dev->name);
+        dumpit((char *)p_ctl,sizeof(struct clawctl));
+#endif
+	if (privptr->p_env->packing >= PACK_SEND)
+		claw_hw_tx(skb, dev, 1);
+	else
+        	claw_hw_tx(skb, dev, 0);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+
+        return 0;
+}  /*   end of claw_send_control  */
+
+/*-------------------------------------------------------------------*
+*               claw_snd_conn_req                                    *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static int
+claw_snd_conn_req(struct net_device *dev, __u8 link)
+{
+        int                rc;
+        struct claw_privbk *privptr=dev->priv;
+        struct clawctl 	   *p_ctl;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"snd_conn");
+#ifdef  DEBUGMSG
+        printk(KERN_INFO "%s: variable link = %X, dev =\n",dev->name, link);
+        dumpit((char *) dev, sizeof(struct net_device));
+#endif
+	rc = 1;
+        p_ctl=(struct clawctl *)&privptr->ctl_bk;
+	p_ctl->linkid = link;
+        if ( privptr->system_validate_comp==0x00 ) {
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s:%s Exit on line %d, rc = 1\n",
+			dev->name,__FUNCTION__,__LINE__);
+#endif
+                return rc;
+        }
+	if (privptr->p_env->packing == PACKING_ASK )
+		rc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,
+        		WS_APPL_NAME_PACKED, WS_APPL_NAME_PACKED);
+	if (privptr->p_env->packing == PACK_SEND)  {
+		rc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,
+        		WS_APPL_NAME_IP_NAME, WS_APPL_NAME_IP_NAME);
+	}
+	if (privptr->p_env->packing == 0)
+        	rc=claw_send_control(dev, CONNECTION_REQUEST,0,0,0,
+       			HOST_APPL_NAME, privptr->p_env->api_type);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d, rc = %d\n",
+		dev->name,__FUNCTION__,__LINE__, rc);
+#endif
+        return rc;
+
+}  /*  end of claw_snd_conn_req */
+
+
+/*-------------------------------------------------------------------*
+*               claw_snd_disc                                        *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+claw_snd_disc(struct net_device *dev, struct clawctl * p_ctl)
+{
+        int rc;
+        struct conncmd *  p_connect;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"snd_dsc");
+#ifdef  DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable p_ctl",dev->name);
+        dumpit((char *) p_ctl, sizeof(struct clawctl));
+#endif
+        p_connect=(struct conncmd *)&p_ctl->data;
+
+        rc=claw_send_control(dev, DISCONNECT, p_ctl->linkid,
+		p_ctl->correlator, 0,
+                p_connect->host_name, p_connect->WS_name);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d, rc = %d\n",
+		dev->name,__FUNCTION__, __LINE__, rc);
+#endif
+        return rc;
+}     /*   end of claw_snd_disc    */
+
+
+/*-------------------------------------------------------------------*
+*               claw_snd_sys_validate_rsp                            *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+claw_snd_sys_validate_rsp(struct net_device *dev,
+	struct clawctl *p_ctl, __u32 return_code)
+{
+        struct claw_env *  p_env;
+        struct claw_privbk *privptr;
+        int    rc;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",
+		dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"chkresp");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable return_code = %d, dev =\n",
+		dev->name, return_code);
+        dumpit((char *) dev, sizeof(struct net_device));
+        printk(KERN_INFO "%s: variable p_ctl =\n",dev->name);
+        dumpit((char *) p_ctl, sizeof(struct clawctl));
+#endif
+        privptr = dev->priv;
+        p_env=privptr->p_env;
+        rc=claw_send_control(dev, SYSTEM_VALIDATE_RESPONSE,
+		p_ctl->linkid,
+		p_ctl->correlator,
+                return_code,
+		p_env->host_name,
+		p_env->adapter_name  );
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d, rc = %d\n",
+		dev->name,__FUNCTION__,__LINE__, rc);
+#endif
+        return rc;
+}     /*    end of claw_snd_sys_validate_rsp    */
+
+/*-------------------------------------------------------------------*
+*               claw_strt_conn_req                                   *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static int
+claw_strt_conn_req(struct net_device *dev )
+{
+        int rc;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"conn_req");
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s: variable dev =\n",dev->name);
+        dumpit((char *) dev, sizeof(struct net_device));
+#endif
+        rc=claw_snd_conn_req(dev, 1);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d, rc = %d\n",
+		dev->name,__FUNCTION__,__LINE__, rc);
+#endif
+        return rc;
+}    /*   end of claw_strt_conn_req   */
+
+
+
+/*-------------------------------------------------------------------*
+ *   claw_stats                                                      *
+ *-------------------------------------------------------------------*/
+
+static struct
+net_device_stats *claw_stats(struct net_device *dev)
+{
+        struct claw_privbk *privptr;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"stats");
+        privptr = dev->priv;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+        return &privptr->stats;
+}     /*   end of claw_stats   */
+
+
+/*-------------------------------------------------------------------*
+*       unpack_read                                                  *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static void
+unpack_read(struct net_device *dev )
+{
+        struct sk_buff *skb;
+        struct claw_privbk *privptr;
+	struct claw_env    *p_env;
+        struct ccwbk 	*p_this_ccw;
+        struct ccwbk 	*p_first_ccw;
+        struct ccwbk 	*p_last_ccw;
+	struct clawph 	*p_packh;
+	void		*p_packd;
+	struct clawctl 	*p_ctlrec=NULL;
+
+        __u32	len_of_data;
+	__u32	pack_off;
+        __u8	link_num;
+        __u8 	mtc_this_frm=0;
+        __u32	bytes_to_mov;
+        struct chbk *p_ch = NULL;
+        int	i=0;
+	int     p=0;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s enter  \n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"unpkread");
+        p_first_ccw=NULL;
+        p_last_ccw=NULL;
+	p_packh=NULL;
+	p_packd=NULL;
+        privptr=dev->priv;
+	p_env = privptr->p_env;
+        p_this_ccw=privptr->p_read_active_first;
+        i=0;
+	while (p_this_ccw!=NULL && p_this_ccw->header.flag!=CLAW_PENDING) {
+#ifdef IOTRACE
+		printk(KERN_INFO "%s p_this_ccw \n",dev->name);
+                dumpit((char*)p_this_ccw, sizeof(struct ccwbk));
+                printk(KERN_INFO "%s Inbound p_this_ccw->p_buffer(64)"
+			" pk=%d \n",dev->name,p_env->packing);
+                dumpit((char *)p_this_ccw->p_buffer, 64 );
+#endif
+		pack_off = 0;
+		p = 0;
+		p_this_ccw->header.flag=CLAW_PENDING;
+		privptr->p_read_active_first=p_this_ccw->next;
+                p_this_ccw->next=NULL;
+		p_packh = (struct clawph *)p_this_ccw->p_buffer;
+		if ((p_env->packing == PACK_SEND) &&
+		    (p_packh->len == 32)           &&
+		    (p_packh->link_num == 0)) {   /* is it a packed ctl rec? */
+			p_packh++;  /* peek past pack header */
+			p_ctlrec = (struct clawctl *)p_packh;
+			p_packh--;  /* un peek */
+			if ((p_ctlrec->command == CONNECTION_RESPONSE) ||
+		            (p_ctlrec->command == CONNECTION_CONFIRM))
+				p_env->packing = DO_PACKED;
+		}
+		if (p_env->packing == DO_PACKED)
+			link_num=p_packh->link_num;
+		else
+	                link_num=p_this_ccw->header.opcode / 8;
+                if ((p_this_ccw->header.opcode & MORE_to_COME_FLAG)!=0) {
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: %s > More_to_come is ON\n",
+			dev->name,__FUNCTION__);
+#endif
+                        mtc_this_frm=1;
+                        if (p_this_ccw->header.length!=
+				privptr->p_env->read_size ) {
+                                printk(KERN_INFO " %s: Invalid frame detected "
+					"length is %02x\n" ,
+                                        dev->name, p_this_ccw->header.length);
+                        }
+                }
+
+                if (privptr->mtc_skipping) {
+                        /*
+                        *   We're in the mode of skipping past a
+			*   multi-frame message
+                        *   that we can't process for some reason or other.
+                        *   The first frame without the More-To-Come flag is
+			*   the last frame of the skipped message.
+                        */
+                        /*  in case of More-To-Come not set in this frame */
+                        if (mtc_this_frm==0) {
+                                privptr->mtc_skipping=0; /* Ok, the end */
+                                privptr->mtc_logical_link=-1;
+                        }
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s:%s goto next "
+				"frame from MoretoComeSkip \n",
+				dev->name,__FUNCTION__);
+#endif
+                        goto NextFrame;
+                }
+
+                if (link_num==0) {
+                        claw_process_control(dev, p_this_ccw);
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s:%s goto next "
+				"frame from claw_process_control \n",
+				dev->name,__FUNCTION__);
+#endif
+			CLAW_DBF_TEXT(4,trace,"UnpkCntl");
+                        goto NextFrame;
+                }
+unpack_next:
+		if (p_env->packing == DO_PACKED) {
+			if (pack_off > p_env->read_size)
+				goto NextFrame;
+			p_packd = p_this_ccw->p_buffer+pack_off;
+			p_packh = (struct clawph *) p_packd;
+			if ((p_packh->len == 0) || /* all done with this frame? */
+			    (p_packh->flag != 0))
+				goto NextFrame;
+			bytes_to_mov = p_packh->len;
+			pack_off += bytes_to_mov+sizeof(struct clawph);
+			p++;
+		} else {
+                	bytes_to_mov=p_this_ccw->header.length;
+		}
+                if (privptr->mtc_logical_link<0) {
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: %s mtc_logical_link < 0  \n",
+			dev->name,__FUNCTION__);
+#endif
+
+                /*
+                *  if More-To-Come is set in this frame then we don't know
+                *  length of entire message, and hence have to allocate
+		*  large buffer   */
+
+                /*      We are starting a new envelope  */
+                privptr->mtc_offset=0;
+                        privptr->mtc_logical_link=link_num;
+                }
+
+                if (bytes_to_mov > (MAX_ENVELOPE_SIZE- privptr->mtc_offset) ) {
+                        /*      error     */
+#ifdef DEBUGMSG
+                        printk(KERN_INFO "%s: %s > goto next "
+				"frame from MoretoComeSkip \n",
+				dev->name,
+				__FUNCTION__);
+                        printk(KERN_INFO "      bytes_to_mov %d > (MAX_ENVELOPE_"
+				"SIZE-privptr->mtc_offset %d)\n",
+				bytes_to_mov,(MAX_ENVELOPE_SIZE- privptr->mtc_offset));
+#endif
+                        privptr->stats.rx_frame_errors++;
+                        goto NextFrame;
+                }
+		if (p_env->packing == DO_PACKED) {
+			memcpy( privptr->p_mtc_envelope+ privptr->mtc_offset,
+				p_packd+sizeof(struct clawph), bytes_to_mov);
+
+		} else	{
+                	memcpy( privptr->p_mtc_envelope+ privptr->mtc_offset,
+                        	p_this_ccw->p_buffer, bytes_to_mov);
+		}
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: %s() received data \n",
+			dev->name,__FUNCTION__);
+		if (p_env->packing == DO_PACKED)
+			dumpit((char *)p_packd+sizeof(struct clawph),32);
+		else
+	                dumpit((char *)p_this_ccw->p_buffer, 32);
+		printk(KERN_INFO "%s: %s() bytelength %d \n",
+			dev->name,__FUNCTION__,bytes_to_mov);
+#endif
+                if (mtc_this_frm==0) {
+                        len_of_data=privptr->mtc_offset+bytes_to_mov;
+                        skb=dev_alloc_skb(len_of_data);
+                        if (skb) {
+                                memcpy(skb_put(skb,len_of_data),
+					privptr->p_mtc_envelope,
+					len_of_data);
+                                skb->mac.raw=skb->data;
+                                skb->dev=dev;
+                                skb->protocol=htons(ETH_P_IP);
+                                skb->ip_summed=CHECKSUM_UNNECESSARY;
+                                privptr->stats.rx_packets++;
+				privptr->stats.rx_bytes+=len_of_data;
+                                netif_rx(skb);
+#ifdef DEBUGMSG
+                                printk(KERN_INFO "%s: %s() netif_"
+					"rx(skb) completed \n",
+					dev->name,__FUNCTION__);
+#endif
+                        }
+                        else {
+                                privptr->stats.rx_dropped++;
+                                printk(KERN_WARNING "%s: %s() low on memory\n",
+				dev->name,__FUNCTION__);
+                        }
+                        privptr->mtc_offset=0;
+                        privptr->mtc_logical_link=-1;
+                }
+                else {
+                        privptr->mtc_offset+=bytes_to_mov;
+                }
+		if (p_env->packing == DO_PACKED)
+			goto unpack_next;
+NextFrame:
+                /*
+                *   Remove ThisCCWblock from active read queue, and add it
+                *   to queue of free blocks to be reused.
+                */
+                i++;
+                p_this_ccw->header.length=0xffff;
+                p_this_ccw->header.opcode=0xff;
+                /*
+                *       add this one to the free queue for later reuse
+                */
+                if (p_first_ccw==NULL) {
+                        p_first_ccw = p_this_ccw;
+                }
+                else {
+                        p_last_ccw->next = p_this_ccw;
+                }
+                p_last_ccw = p_this_ccw;
+                /*
+                *       chain to next block on active read queue
+                */
+                p_this_ccw = privptr->p_read_active_first;
+		CLAW_DBF_TEXT_(4,trace,"rxpkt %d",p);
+        } /* end of while */
+
+        /*      check validity                  */
+
+#ifdef IOTRACE
+        printk(KERN_INFO "%s:%s processed frame is %d \n",
+		dev->name,__FUNCTION__,i);
+        printk(KERN_INFO "%s:%s  F:%lx L:%lx\n",
+		dev->name,
+		__FUNCTION__,
+		(unsigned long)p_first_ccw,
+		(unsigned long)p_last_ccw);
+#endif
+	CLAW_DBF_TEXT_(4,trace,"rxfrm %d",i);
+        add_claw_reads(dev, p_first_ccw, p_last_ccw);
+        p_ch=&privptr->channel[READ];
+        claw_strt_read(dev, LOCK_YES);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s: %s exit on line %d\n",
+		dev->name, __FUNCTION__, __LINE__);
+#endif
+        return;
+}     /*  end of unpack_read   */
+
+/*-------------------------------------------------------------------*
+*       claw_strt_read                                               *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static void
+claw_strt_read (struct net_device *dev, int lock )
+{
+        int        rc = 0;
+        __u32      parm;
+        unsigned long  saveflags = 0;
+        struct claw_privbk *privptr=dev->priv;
+        struct ccwbk*p_ccwbk;
+        struct chbk *p_ch;
+        struct clawh *p_clawh;
+        p_ch=&privptr->channel[READ];
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter  \n",dev->name,__FUNCTION__);
+        printk(KERN_INFO "%s: variable lock = %d, dev =\n",dev->name, lock);
+        dumpit((char *) dev, sizeof(struct net_device));
+#endif
+	CLAW_DBF_TEXT(4,trace,"StRdNter");
+        p_clawh=(struct clawh *)privptr->p_claw_signal_blk;
+        p_clawh->flag=CLAW_IDLE;    /* 0x00 */
+
+        if ((privptr->p_write_active_first!=NULL &&
+             privptr->p_write_active_first->header.flag!=CLAW_PENDING) ||
+            (privptr->p_read_active_first!=NULL &&
+             privptr->p_read_active_first->header.flag!=CLAW_PENDING )) {
+                p_clawh->flag=CLAW_BUSY;    /* 0xff */
+        }
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s:%s state-%02x\n" ,
+		dev->name,__FUNCTION__, p_ch->claw_state);
+#endif
+        if (lock==LOCK_YES) {
+                spin_lock_irqsave(get_ccwdev_lock(p_ch->cdev), saveflags);
+        }
+        if (test_and_set_bit(0, (void *)&p_ch->IO_active) == 0) {
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s: HOT READ started in %s\n" ,
+			dev->name,__FUNCTION__);
+                p_clawh=(struct clawh *)privptr->p_claw_signal_blk;
+                dumpit((char *)&p_clawh->flag , 1);
+#endif
+		CLAW_DBF_TEXT(4,trace,"HotRead");
+                p_ccwbk=privptr->p_read_active_first;
+                parm = (unsigned long) p_ch;
+                rc = ccw_device_start (p_ch->cdev, &p_ccwbk->read, parm,
+				       0xff, 0);
+                if (rc != 0) {
+                        ccw_check_return_code(p_ch->cdev, rc);
+                }
+        }
+	else {
+#ifdef DEBUGMSG
+		printk(KERN_INFO "%s: No READ started by %s() In progress\n" ,
+			dev->name,__FUNCTION__);
+#endif
+		CLAW_DBF_TEXT(2,trace,"ReadAct");
+	}
+
+        if (lock==LOCK_YES) {
+                spin_unlock_irqrestore(get_ccwdev_lock(p_ch->cdev), saveflags);
+        }
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+	CLAW_DBF_TEXT(4,trace,"StRdExit");
+        return;
+}       /*    end of claw_strt_read    */
+
+/*-------------------------------------------------------------------*
+*       claw_strt_out_IO                                             *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static void
+claw_strt_out_IO( struct net_device *dev )
+{
+        int             	rc = 0;
+        unsigned long   	parm;
+        struct claw_privbk 	*privptr;
+        struct chbk     	*p_ch;
+        struct ccwbk   	*p_first_ccw;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	if (!dev) {
+		return;
+	}
+        privptr=(struct claw_privbk *)dev->priv;
+        p_ch=&privptr->channel[WRITE];
+
+#ifdef DEBUGMSG
+        printk(KERN_INFO "%s:%s state-%02x\n" ,
+		dev->name,__FUNCTION__,p_ch->claw_state);
+#endif
+        CLAW_DBF_TEXT(4,trace,"strt_io");
+        p_first_ccw=privptr->p_write_active_first;
+
+        if (p_ch->claw_state == CLAW_STOP)
+                return;
+        if (p_first_ccw == NULL) {
+#ifdef FUNCTRACE
+                printk(KERN_INFO "%s:%s Exit on line %d\n",
+			dev->name,__FUNCTION__,__LINE__);
+#endif
+                return;
+        }
+        if (test_and_set_bit(0, (void *)&p_ch->IO_active) == 0) {
+                parm = (unsigned long) p_ch;
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s:%s do_io \n" ,dev->name,__FUNCTION__);
+                dumpit((char *)p_first_ccw, sizeof(struct ccwbk));
+#endif
+		CLAW_DBF_TEXT(2,trace,"StWrtIO");
+                rc = ccw_device_start (p_ch->cdev,&p_first_ccw->write, parm,
+				       0xff, 0);
+                if (rc != 0) {
+                        ccw_check_return_code(p_ch->cdev, rc);
+                }
+        }
+        dev->trans_start = jiffies;
+#ifdef FUNCTRACE
+	printk(KERN_INFO "%s:%s Exit on line %d\n",
+		dev->name,__FUNCTION__,__LINE__);
+#endif
+
+        return;
+}       /*    end of claw_strt_out_IO    */
+
+/*-------------------------------------------------------------------*
+*       Free write buffers                                           *
+*                                                                    *
+*--------------------------------------------------------------------*/
+
+static void
+claw_free_wrt_buf( struct net_device *dev )
+{
+
+        struct claw_privbk *privptr=(struct claw_privbk *)dev->priv;
+        struct ccwbk*p_first_ccw;
+	struct ccwbk*p_last_ccw;
+	struct ccwbk*p_this_ccw;
+	struct ccwbk*p_next_ccw;
+#ifdef IOTRACE
+        struct ccwbk*p_buf;
+#endif
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+        printk(KERN_INFO "%s: free count = %d  variable dev =\n",
+		dev->name,privptr->write_free_count);
+#endif
+	CLAW_DBF_TEXT(4,trace,"freewrtb");
+        /*  scan the write queue to free any completed write packets   */
+        p_first_ccw=NULL;
+        p_last_ccw=NULL;
+#ifdef IOTRACE
+        printk(KERN_INFO "%s:  Dump current CCW chain \n",dev->name  );
+        p_buf=privptr->p_write_active_first;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+        if (p_buf==NULL) {
+                printk(KERN_INFO "%s: privptr->p_write_"
+			"active_first==NULL\n",dev->name  );
+        }
+        p_buf=(struct ccwbk*)privptr->p_end_ccw;
+        dumpit((char *)p_buf, sizeof(struct endccw));
+#endif
+        p_this_ccw=privptr->p_write_active_first;
+        while ( (p_this_ccw!=NULL) && (p_this_ccw->header.flag!=CLAW_PENDING))
+        {
+                p_next_ccw = p_this_ccw->next;
+                if (((p_next_ccw!=NULL) &&
+		     (p_next_ccw->header.flag!=CLAW_PENDING)) ||
+                    ((p_this_ccw == privptr->p_write_active_last) &&
+                     (p_this_ccw->header.flag!=CLAW_PENDING))) {
+                        /* The next CCW is OK or this is  */
+			/* the last CCW...free it   @A1A  */
+                        privptr->p_write_active_first=p_this_ccw->next;
+			p_this_ccw->header.flag=CLAW_PENDING;
+                        p_this_ccw->next=privptr->p_write_free_chain;
+			privptr->p_write_free_chain=p_this_ccw;
+                        ++privptr->write_free_count;
+			privptr->stats.tx_bytes+= p_this_ccw->write.count;
+			p_this_ccw=privptr->p_write_active_first;
+                        privptr->stats.tx_packets++;
+                }
+                else {
+			break;
+                }
+        }
+        if (privptr->write_free_count!=0) {
+                claw_clearbit_busy(TB_NOBUFFER,dev);
+        }
+        /*   whole chain removed?   */
+        if (privptr->p_write_active_first==NULL) {
+                privptr->p_write_active_last=NULL;
+#ifdef DEBUGMSG
+                printk(KERN_INFO "%s:%s p_write_"
+			"active_first==NULL\n",dev->name,__FUNCTION__);
+#endif
+        }
+#ifdef IOTRACE
+        printk(KERN_INFO "%s: Dump arranged CCW chain \n",dev->name  );
+        p_buf=privptr->p_write_active_first;
+        while (p_buf!=NULL) {
+                dumpit((char *)p_buf, sizeof(struct ccwbk));
+                p_buf=p_buf->next;
+        }
+        if (p_buf==NULL) {
+                printk(KERN_INFO "%s: privptr->p_write_active_"
+			"first==NULL\n",dev->name  );
+        }
+        p_buf=(struct ccwbk*)privptr->p_end_ccw;
+        dumpit((char *)p_buf, sizeof(struct endccw));
+#endif
+
+	CLAW_DBF_TEXT_(4,trace,"FWC=%d",privptr->write_free_count);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit on line %d free_count =%d\n",
+		dev->name,__FUNCTION__, __LINE__,privptr->write_free_count);
+#endif
+        return;
+}
+
+/*-------------------------------------------------------------------*
+*       claw free netdevice                                          *
+*                                                                    *
+*--------------------------------------------------------------------*/
+static void
+claw_free_netdevice(struct net_device * dev, int free_dev)
+{
+	struct claw_privbk *privptr;
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"free_dev");
+
+	if (!dev)
+		return;
+	CLAW_DBF_TEXT_(2,setup,"%s",dev->name);
+	privptr = dev->priv;
+	if (dev->flags & IFF_RUNNING)
+		claw_release(dev);
+	if (privptr) {
+		privptr->channel[READ].ndev = NULL;  /* say it's free */
+	}
+	dev->priv=NULL;
+#ifdef MODULE
+	if (free_dev) {
+		free_netdev(dev);
+	}
+#endif
+	CLAW_DBF_TEXT(2,setup,"feee_ok");
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit\n",dev->name,__FUNCTION__);
+#endif
+}
+
+/**
+ * Claw init netdevice
+ * Initialize everything of the net device except the name and the
+ * channel structs.
+ */
+static void
+claw_init_netdevice(struct net_device * dev)
+{
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"init_dev");
+	CLAW_DBF_TEXT_(2,setup,"%s",dev->name);
+	if (!dev) {
+        printk(KERN_WARNING "claw:%s BAD Device exit line %d\n",
+		__FUNCTION__,__LINE__);
+		CLAW_DBF_TEXT(2,setup,"baddev");
+		return;
+	}
+	dev->mtu = CLAW_DEFAULT_MTU_SIZE;
+	dev->hard_start_xmit = claw_tx;
+	dev->open = claw_open;
+	dev->stop = claw_release;
+	dev->get_stats = claw_stats;
+	dev->change_mtu = claw_change_mtu;
+	dev->hard_header_len = 0;
+	dev->addr_len = 0;
+	dev->type = ARPHRD_SLIP;
+	dev->tx_queue_len = 1300;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP;
+	SET_MODULE_OWNER(dev);
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Exit\n",dev->name,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT(2,setup,"initok");
+	return;
+}
+
+/**
+ * Init a new channel in the privptr->channel[i].
+ *
+ * @param cdev  The ccw_device to be added.
+ *
+ * @return 0 on success, !0 on error.
+ */
+static int
+add_channel(struct ccw_device *cdev,int i,struct claw_privbk *privptr)
+{
+	struct chbk *p_ch;
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "%s:%s Enter\n",cdev->dev.bus_id,__FUNCTION__);
+#endif
+	CLAW_DBF_TEXT_(2,setup,"%s",cdev->dev.bus_id);
+	privptr->channel[i].flag  = i+1;   /* Read is 1 Write is 2 */
+	p_ch = &privptr->channel[i];
+	p_ch->cdev = cdev;
+	snprintf(p_ch->id, CLAW_ID_SIZE, "cl-%s", cdev->dev.bus_id);
+	sscanf(cdev->dev.bus_id+4,"%x",&p_ch->devno);
+	if ((p_ch->irb = kmalloc(sizeof (struct irb),GFP_KERNEL)) == NULL) {
+		printk(KERN_WARNING "%s Out of memory in %s for irb\n",
+			p_ch->id,__FUNCTION__);
+#ifdef FUNCTRACE
+        	printk(KERN_INFO "%s:%s Exit on line %d\n",
+			p_ch->id,__FUNCTION__,__LINE__);
+#endif
+		return -ENOMEM;
+	}
+	memset(p_ch->irb, 0, sizeof (struct irb));
+#ifdef FUNCTRACE
+        	printk(KERN_INFO "%s:%s Exit on line %d\n",
+			cdev->dev.bus_id,__FUNCTION__,__LINE__);
+#endif
+	return 0;
+}
+
+
+/**
+ *
+ * Setup an interface.
+ *
+ * @param cgdev  Device to be setup.
+ *
+ * @returns 0 on success, !0 on failure.
+ */
+static int
+claw_new_device(struct ccwgroup_device *cgdev)
+{
+	struct claw_privbk *privptr;
+	struct claw_env *p_env;
+	struct net_device *dev;
+	int ret;
+
+	pr_debug("%s() called\n", __FUNCTION__);
+	printk(KERN_INFO "claw: add for %s\n",cgdev->cdev[READ]->dev.bus_id);
+	CLAW_DBF_TEXT(2,setup,"new_dev");
+	privptr = cgdev->dev.driver_data;
+	cgdev->cdev[READ]->dev.driver_data = privptr;
+	cgdev->cdev[WRITE]->dev.driver_data = privptr;
+	if (!privptr)
+		return -ENODEV;
+	p_env = privptr->p_env;
+	sscanf(cgdev->cdev[READ]->dev.bus_id+4,"%x",
+		&p_env->devno[READ]);
+        sscanf(cgdev->cdev[WRITE]->dev.bus_id+4,"%x",
+		&p_env->devno[WRITE]);
+	ret = add_channel(cgdev->cdev[0],0,privptr);
+	if (ret == 0)
+		ret = add_channel(cgdev->cdev[1],1,privptr);
+	if (ret != 0) {
+			printk(KERN_WARNING
+		 	"add channel failed "
+				"with ret = %d\n", ret);
+			goto out;
+	}
+	ret = ccw_device_set_online(cgdev->cdev[READ]);
+	if (ret != 0) {
+		printk(KERN_WARNING
+		 "claw: ccw_device_set_online %s READ failed "
+			"with ret = %d\n",cgdev->cdev[READ]->dev.bus_id,ret);
+		goto out;
+	}
+	ret = ccw_device_set_online(cgdev->cdev[WRITE]);
+	if (ret != 0) {
+		printk(KERN_WARNING
+		 "claw: ccw_device_set_online %s WRITE failed "
+			"with ret = %d\n",cgdev->cdev[WRITE]->dev.bus_id, ret);
+		goto out;
+	}
+	dev = alloc_netdev(0,"claw%d",claw_init_netdevice);
+	if (!dev) {
+		printk(KERN_WARNING "%s:alloc_netdev failed\n",__FUNCTION__);
+		goto out;
+	}
+	dev->priv = privptr;
+	cgdev->dev.driver_data = privptr;
+        cgdev->cdev[READ]->dev.driver_data = privptr;
+        cgdev->cdev[WRITE]->dev.driver_data = privptr;
+	/* sysfs magic */
+        SET_NETDEV_DEV(dev, &cgdev->dev);
+	if (register_netdev(dev) != 0) {
+		claw_free_netdevice(dev, 1);
+		CLAW_DBF_TEXT(2,trace,"regfail");
+		goto out;
+	}
+	dev->flags &=~IFF_RUNNING;
+	if (privptr->buffs_alloc == 0) {
+	        ret=init_ccw_bk(dev);
+		if (ret !=0) {
+			printk(KERN_WARNING
+			 "claw: init_ccw_bk failed with ret=%d\n", ret);
+			unregister_netdev(dev);
+			claw_free_netdevice(dev,1);
+			CLAW_DBF_TEXT(2,trace,"ccwmem");
+			goto out;
+		}
+	}
+	privptr->channel[READ].ndev = dev;
+	privptr->channel[WRITE].ndev = dev;
+	privptr->p_env->ndev = dev;
+
+	printk(KERN_INFO "%s:readsize=%d  writesize=%d "
+		"readbuffer=%d writebuffer=%d read=0x%04x write=0x%04x\n",
+                dev->name, p_env->read_size,
+		p_env->write_size, p_env->read_buffers,
+                p_env->write_buffers, p_env->devno[READ],
+		p_env->devno[WRITE]);
+        printk(KERN_INFO "%s:host_name:%.8s, adapter_name "
+		":%.8s api_type: %.8s\n",
+                dev->name, p_env->host_name,
+		p_env->adapter_name , p_env->api_type);
+	return 0;
+out:
+	ccw_device_set_offline(cgdev->cdev[1]);
+	ccw_device_set_offline(cgdev->cdev[0]);
+
+	return -ENODEV;
+}
+
+static void
+claw_purge_skb_queue(struct sk_buff_head *q)
+{
+        struct sk_buff *skb;
+
+        CLAW_DBF_TEXT(4,trace,"purgque");
+
+        while ((skb = skb_dequeue(q))) {
+                atomic_dec(&skb->users);
+                dev_kfree_skb_irq(skb);
+        }
+}
+
+/**
+ * Shutdown an interface.
+ *
+ * @param cgdev  Device to be shut down.
+ *
+ * @returns 0 on success, !0 on failure.
+ */
+static int
+claw_shutdown_device(struct ccwgroup_device *cgdev)
+{
+	struct claw_privbk *priv;
+	struct net_device *ndev;
+	int	ret;
+
+	pr_debug("%s() called\n", __FUNCTION__);
+	CLAW_DBF_TEXT_(2,setup,"%s",cgdev->dev.bus_id);
+	priv = cgdev->dev.driver_data;
+	if (!priv)
+		return -ENODEV;
+	ndev = priv->channel[READ].ndev;
+	if (ndev) {
+		/* Close the device */
+		printk(KERN_INFO
+			"%s: shuting down \n",ndev->name);
+		if (ndev->flags & IFF_RUNNING)
+			ret = claw_release(ndev);
+		ndev->flags &=~IFF_RUNNING;
+		unregister_netdev(ndev);
+		ndev->priv = NULL;  /* cgdev data, not ndev's to free */
+		claw_free_netdevice(ndev, 1);
+		priv->channel[READ].ndev = NULL;
+		priv->channel[WRITE].ndev = NULL;
+		priv->p_env->ndev = NULL;
+	}
+	ccw_device_set_offline(cgdev->cdev[1]);
+	ccw_device_set_offline(cgdev->cdev[0]);
+	return 0;
+}
+
+static void
+claw_remove_device(struct ccwgroup_device *cgdev)
+{
+	struct claw_privbk *priv;
+
+	pr_debug("%s() called\n", __FUNCTION__);
+	CLAW_DBF_TEXT_(2,setup,"%s",cgdev->dev.bus_id);
+	priv = cgdev->dev.driver_data;
+	if (!priv) {
+		printk(KERN_WARNING "claw: %s() no Priv exiting\n",__FUNCTION__);
+		return;
+	}
+	printk(KERN_INFO "claw: %s() called %s will be removed.\n",
+			__FUNCTION__,cgdev->cdev[0]->dev.bus_id);
+	if (cgdev->state == CCWGROUP_ONLINE)
+		claw_shutdown_device(cgdev);
+	claw_remove_files(&cgdev->dev);
+	if (priv->p_mtc_envelope!=NULL) {
+                kfree(priv->p_mtc_envelope);
+                priv->p_mtc_envelope=NULL;
+        }
+	if (priv->p_env != NULL) {
+		kfree(priv->p_env);
+		priv->p_env=NULL;
+	}
+	if (priv->channel[0].irb != NULL) {
+		kfree(priv->channel[0].irb);
+		priv->channel[0].irb=NULL;
+	}
+	if (priv->channel[1].irb != NULL) {
+		kfree(priv->channel[1].irb);
+		priv->channel[1].irb=NULL;
+	}
+	kfree(priv);
+	cgdev->dev.driver_data=NULL;
+	cgdev->cdev[READ]->dev.driver_data = NULL;
+	cgdev->cdev[WRITE]->dev.driver_data = NULL;
+	put_device(&cgdev->dev);
+}
+
+
+/*
+ * sysfs attributes
+ */
+static ssize_t
+claw_hname_show(struct device *dev, char *buf)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	return sprintf(buf, "%s\n",p_env->host_name);
+}
+
+static ssize_t
+claw_hname_write(struct device *dev, const char *buf, size_t count)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	if (count > MAX_NAME_LEN+1)
+		return -EINVAL;
+	memset(p_env->host_name, 0x20, MAX_NAME_LEN);
+	strncpy(p_env->host_name,buf, count);
+	p_env->host_name[count-1] = 0x20;  /* clear extra 0x0a */
+	p_env->host_name[MAX_NAME_LEN] = 0x00;
+	CLAW_DBF_TEXT(2,setup,"HstnSet");
+        CLAW_DBF_TEXT_(2,setup,"%s",p_env->host_name);
+
+	return count;
+}
+
+static DEVICE_ATTR(host_name, 0644, claw_hname_show, claw_hname_write);
+
+static ssize_t
+claw_adname_show(struct device *dev, char *buf)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	return sprintf(buf, "%s\n",p_env->adapter_name);
+}
+
+static ssize_t
+claw_adname_write(struct device *dev, const char *buf, size_t count)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	if (count > MAX_NAME_LEN+1)
+		return -EINVAL;
+	memset(p_env->adapter_name, 0x20, MAX_NAME_LEN);
+	strncpy(p_env->adapter_name,buf, count);
+	p_env->adapter_name[count-1] = 0x20; /* clear extra 0x0a */
+	p_env->adapter_name[MAX_NAME_LEN] = 0x00;
+	CLAW_DBF_TEXT(2,setup,"AdnSet");
+	CLAW_DBF_TEXT_(2,setup,"%s",p_env->adapter_name);
+
+	return count;
+}
+
+static DEVICE_ATTR(adapter_name, 0644, claw_adname_show, claw_adname_write);
+
+static ssize_t
+claw_apname_show(struct device *dev, char *buf)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	return sprintf(buf, "%s\n",
+		       p_env->api_type);
+}
+
+static ssize_t
+claw_apname_write(struct device *dev, const char *buf, size_t count)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	if (count > MAX_NAME_LEN+1)
+		return -EINVAL;
+	memset(p_env->api_type, 0x20, MAX_NAME_LEN);
+	strncpy(p_env->api_type,buf, count);
+	p_env->api_type[count-1] = 0x20;  /* we get a loose 0x0a */
+	p_env->api_type[MAX_NAME_LEN] = 0x00;
+	if(strncmp(p_env->api_type,WS_APPL_NAME_PACKED,6) == 0) {
+		p_env->read_size=DEF_PACK_BUFSIZE;
+		p_env->write_size=DEF_PACK_BUFSIZE;
+		p_env->packing=PACKING_ASK;
+		CLAW_DBF_TEXT(2,setup,"PACKING");
+	}
+	else {
+		p_env->packing=0;
+		p_env->read_size=CLAW_FRAME_SIZE;
+		p_env->write_size=CLAW_FRAME_SIZE;
+		CLAW_DBF_TEXT(2,setup,"ApiSet");
+	}
+	CLAW_DBF_TEXT_(2,setup,"%s",p_env->api_type);
+	return count;
+}
+
+static DEVICE_ATTR(api_type, 0644, claw_apname_show, claw_apname_write);
+
+static ssize_t
+claw_wbuff_show(struct device *dev, char *buf)
+{
+	struct claw_privbk *priv;
+	struct claw_env * p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	return sprintf(buf, "%d\n", p_env->write_buffers);
+}
+
+static ssize_t
+claw_wbuff_write(struct device *dev, const char *buf, size_t count)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+	int nnn,max;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	sscanf(buf, "%i", &nnn);
+	if (p_env->packing) {
+		max = 64;
+	}
+	else {
+		max = 512;
+	}
+	if ((nnn > max ) || (nnn < 2))
+		return -EINVAL;
+	p_env->write_buffers = nnn;
+	CLAW_DBF_TEXT(2,setup,"Wbufset");
+        CLAW_DBF_TEXT_(2,setup,"WB=%d",p_env->write_buffers);
+	return count;
+}
+
+static DEVICE_ATTR(write_buffer, 0644, claw_wbuff_show, claw_wbuff_write);
+
+static ssize_t
+claw_rbuff_show(struct device *dev, char *buf)
+{
+	struct claw_privbk *priv;
+	struct claw_env *  p_env;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	return sprintf(buf, "%d\n", p_env->read_buffers);
+}
+
+static ssize_t
+claw_rbuff_write(struct device *dev, const char *buf, size_t count)
+{
+	struct claw_privbk *priv;
+	struct claw_env *p_env;
+	int nnn,max;
+
+	priv = dev->driver_data;
+	if (!priv)
+		return -ENODEV;
+	p_env = priv->p_env;
+	sscanf(buf, "%i", &nnn);
+	if (p_env->packing) {
+		max = 64;
+	}
+	else {
+		max = 512;
+	}
+	if ((nnn > max ) || (nnn < 2))
+		return -EINVAL;
+	p_env->read_buffers = nnn;
+	CLAW_DBF_TEXT(2,setup,"Rbufset");
+	CLAW_DBF_TEXT_(2,setup,"RB=%d",p_env->read_buffers);
+	return count;
+}
+
+static DEVICE_ATTR(read_buffer, 0644, claw_rbuff_show, claw_rbuff_write);
+
+static struct attribute *claw_attr[] = {
+	&dev_attr_read_buffer.attr,
+	&dev_attr_write_buffer.attr,
+	&dev_attr_adapter_name.attr,
+	&dev_attr_api_type.attr,
+	&dev_attr_host_name.attr,
+	NULL,
+};
+
+static struct attribute_group claw_attr_group = {
+	.attrs = claw_attr,
+};
+
+static int
+claw_add_files(struct device *dev)
+{
+	pr_debug("%s() called\n", __FUNCTION__);
+	CLAW_DBF_TEXT(2,setup,"add_file");
+	return sysfs_create_group(&dev->kobj, &claw_attr_group);
+}
+
+static void
+claw_remove_files(struct device *dev)
+{
+	pr_debug("%s() called\n", __FUNCTION__);
+	CLAW_DBF_TEXT(2,setup,"rem_file");
+	sysfs_remove_group(&dev->kobj, &claw_attr_group);
+}
+
+/*--------------------------------------------------------------------*
+*    claw_init  and cleanup                                           *
+*---------------------------------------------------------------------*/
+
+static void __exit
+claw_cleanup(void)
+{
+	unregister_cu3088_discipline(&claw_group_driver);
+	claw_unregister_debug_facility();
+	printk(KERN_INFO "claw: Driver unloaded\n");
+
+}
+
+/**
+ * Initialize module.
+ * This is called just after the module is loaded.
+ *
+ * @return 0 on success, !0 on error.
+ */
+static int __init
+claw_init(void)
+{
+	int ret = 0;
+       printk(KERN_INFO "claw: starting driver "
+#ifdef MODULE
+                "module "
+#else
+                "compiled into kernel "
+#endif
+                " $Revision: 1.35 $ $Date: 2005/03/24 12:25:38 $ \n");
+
+
+#ifdef FUNCTRACE
+        printk(KERN_INFO "claw: %s() enter \n",__FUNCTION__);
+#endif
+	ret = claw_register_debug_facility();
+	if (ret) {
+		printk(KERN_WARNING "claw: %s() debug_register failed %d\n",
+			__FUNCTION__,ret);
+		return ret;
+	}
+	CLAW_DBF_TEXT(2,setup,"init_mod");
+	ret = register_cu3088_discipline(&claw_group_driver);
+	if (ret) {
+		claw_unregister_debug_facility();
+		printk(KERN_WARNING "claw; %s() cu3088 register failed %d\n",
+			__FUNCTION__,ret);
+	}
+#ifdef FUNCTRACE
+        printk(KERN_INFO "claw: %s() exit \n",__FUNCTION__);
+#endif
+	return ret;
+}
+
+module_init(claw_init);
+module_exit(claw_cleanup);
+
+
+
+/*--------------------------------------------------------------------*
+*    End of File                                                      *
+*---------------------------------------------------------------------*/
+
+
diff -purN linux-2.6.11/drivers/s390/net/claw.h linux-2.6.12-rc6/drivers/s390/net/claw.h
--- linux-2.6.11/drivers/s390/net/claw.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/claw.h	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,335 @@
+/*******************************************************
+*  Define constants                                    *
+*                                                      *
+********************************************************/
+#define VERSION_CLAW_H "$Revision: 1.6 $"
+/*-----------------------------------------------------*
+*     CCW command codes for CLAW protocol              *
+*------------------------------------------------------*/
+
+#define CCW_CLAW_CMD_WRITE           0x01      /* write - not including link */
+#define CCW_CLAW_CMD_READ            0x02      /* read */
+#define CCW_CLAW_CMD_NOP             0x03      /* NOP */
+#define CCW_CLAW_CMD_SENSE           0x04      /* Sense */
+#define CCW_CLAW_CMD_SIGNAL_SMOD     0x05      /* Signal Status Modifier */
+#define CCW_CLAW_CMD_TIC             0x08      /* TIC */
+#define CCW_CLAW_CMD_READHEADER      0x12      /* read header data */
+#define CCW_CLAW_CMD_READFF          0x22      /* read an FF */
+#define CCW_CLAW_CMD_SENSEID         0xe4      /* Sense ID */
+
+
+/*-----------------------------------------------------*
+*    CLAW Unique constants                             *
+*------------------------------------------------------*/
+
+#define MORE_to_COME_FLAG       0x04   /* OR with write CCW in case of m-t-c */
+#define CLAW_IDLE               0x00   /* flag to indicate CLAW is idle */
+#define CLAW_BUSY               0xff   /* flag to indicate CLAW is busy */
+#define CLAW_PENDING            0x00   /* flag to indicate i/o is pending */
+#define CLAW_COMPLETE           0xff   /* flag to indicate i/o completed */
+
+/*-----------------------------------------------------*
+*     CLAW control comand code                         *
+*------------------------------------------------------*/
+
+#define SYSTEM_VALIDATE_REQUEST   0x01  /* System Validate request */
+#define SYSTEM_VALIDATE_RESPONSE  0x02  /* System Validate response */
+#define CONNECTION_REQUEST        0x21  /* Connection request */
+#define CONNECTION_RESPONSE       0x22  /* Connection response */
+#define CONNECTION_CONFIRM        0x23  /* Connection confirm */
+#define DISCONNECT                0x24  /* Disconnect */
+#define CLAW_ERROR                0x41  /* CLAW error message */
+#define CLAW_VERSION_ID           2     /* CLAW version ID */
+
+/*-----------------------------------------------------*
+*  CLAW adater sense bytes                             *
+*------------------------------------------------------*/
+
+#define CLAW_ADAPTER_SENSE_BYTE 0x41   /* Stop command issued to adapter */
+
+/*-----------------------------------------------------*
+*      CLAW control command return codes               *
+*------------------------------------------------------*/
+
+#define CLAW_RC_NAME_MISMATCH       166  /*  names do not match */
+#define CLAW_RC_WRONG_VERSION       167  /*  wrong CLAW version number */
+#define CLAW_RC_HOST_RCV_TOO_SMALL  180  /*  Host maximum receive is   */
+					 /*  less than Linux on zSeries*/
+                                         /*  transmit size             */
+
+/*-----------------------------------------------------*
+*      CLAW Constants application name                 *
+*------------------------------------------------------*/
+
+#define HOST_APPL_NAME          "TCPIP   "
+#define WS_APPL_NAME_IP_LINK    "TCPIP   "
+#define WS_APPL_NAME_IP_NAME	"IP      "
+#define WS_APPL_NAME_API_LINK   "API     "
+#define WS_APPL_NAME_PACKED     "PACKED  "
+#define WS_NAME_NOT_DEF         "NOT_DEF "
+#define PACKING_ASK		1
+#define PACK_SEND		2
+#define DO_PACKED		3
+
+#define MAX_ENVELOPE_SIZE       65536
+#define CLAW_DEFAULT_MTU_SIZE   4096
+#define DEF_PACK_BUFSIZE	32768
+#define READ                    0
+#define WRITE                   1
+
+#define TB_TX                   0          /* sk buffer handling in process  */
+#define TB_STOP                 1          /* network device stop in process */
+#define TB_RETRY                2          /* retry in process               */
+#define TB_NOBUFFER             3          /* no buffer on free queue        */
+#define CLAW_MAX_LINK_ID        1
+#define CLAW_MAX_DEV            256        /*      max claw devices          */
+#define MAX_NAME_LEN            8          /* host name, adapter name length */
+#define CLAW_FRAME_SIZE         4096
+#define CLAW_ID_SIZE            BUS_ID_SIZE+3
+
+/* state machine codes used in claw_irq_handler */
+
+#define CLAW_STOP                0
+#define CLAW_START_HALT_IO       1
+#define CLAW_START_SENSEID       2
+#define CLAW_START_READ          3
+#define CLAW_START_WRITE         4
+
+/*-----------------------------------------------------*
+*    Lock flag                                         *
+*------------------------------------------------------*/
+#define LOCK_YES             0
+#define LOCK_NO              1
+
+/*-----------------------------------------------------*
+*    DBF Debug macros                                  *
+*------------------------------------------------------*/
+#define CLAW_DBF_TEXT(level, name, text) \
+	do { \
+		debug_text_event(claw_dbf_##name, level, text); \
+	} while (0)
+
+#define CLAW_DBF_HEX(level,name,addr,len) \
+do { \
+	debug_event(claw_dbf_##name,level,(void*)(addr),len); \
+} while (0)
+
+#define CLAW_DBF_TEXT_(level,name,text...) \
+do {                                       \
+	sprintf(debug_buffer, text);  \
+		debug_text_event(claw_dbf_##name,level, debug_buffer);\
+} while (0)
+
+/*******************************************************
+*  Define Control Blocks                               *
+*                                                      *
+********************************************************/
+
+/*------------------------------------------------------*/
+/*     CLAW header                                      */
+/*------------------------------------------------------*/
+
+struct clawh {
+        __u16  length;     /* length of data read by preceding read CCW */
+        __u8   opcode;     /* equivalent read CCW */
+        __u8   flag;       /* flag of FF to indicate read was completed */
+};
+
+/*------------------------------------------------------*/
+/*     CLAW Packing header   4 bytes                    */
+/*------------------------------------------------------*/
+struct clawph {
+       __u16 len;  	/* Length of Packed Data Area   */
+       __u8  flag;  	/* Reserved not used            */
+       __u8  link_num;	/* Link ID                      */
+};
+
+/*------------------------------------------------------*/
+/*     CLAW Ending struct ccwbk                         */
+/*------------------------------------------------------*/
+struct endccw {
+	__u32     real;            /* real address of this block */
+       __u8      write1;          /* write 1 is active */
+        __u8      read1;           /* read 1 is active  */
+        __u16     reserved;        /* reserved for future use */
+        struct ccw1    write1_nop1;
+        struct ccw1    write1_nop2;
+        struct ccw1    write2_nop1;
+        struct ccw1    write2_nop2;
+        struct ccw1    read1_nop1;
+        struct ccw1    read1_nop2;
+        struct ccw1    read2_nop1;
+        struct ccw1    read2_nop2;
+};
+
+/*------------------------------------------------------*/
+/*     CLAW struct ccwbk                                       */
+/*------------------------------------------------------*/
+struct ccwbk {
+        void   *next;        /* pointer to next ccw block */
+        __u32     real;         /* real address of this ccw */
+        void      *p_buffer;    /* virtual address of data */
+        struct clawh     header;       /* claw header */
+        struct ccw1    write;   /* write CCW    */
+        struct ccw1    w_read_FF; /* read FF */
+        struct ccw1    w_TIC_1;        /* TIC */
+        struct ccw1    read;         /* read CCW  */
+        struct ccw1    read_h;        /* read header */
+        struct ccw1    signal;       /* signal SMOD  */
+        struct ccw1    r_TIC_1;        /* TIC1 */
+        struct ccw1    r_read_FF;      /* read FF  */
+        struct ccw1    r_TIC_2;        /* TIC2 */
+};
+
+/*------------------------------------------------------*/
+/*     CLAW control block                               */
+/*------------------------------------------------------*/
+struct clawctl {
+        __u8    command;      /* control command */
+        __u8    version;      /* CLAW protocol version */
+        __u8    linkid;       /* link ID   */
+        __u8    correlator;   /* correlator */
+        __u8    rc;           /* return code */
+        __u8    reserved1;    /* reserved */
+        __u8    reserved2;    /* reserved */
+        __u8    reserved3;    /* reserved */
+        __u8    data[24];     /* command specific fields */
+};
+
+/*------------------------------------------------------*/
+/*     Data for SYSTEMVALIDATE command                  */
+/*------------------------------------------------------*/
+struct sysval  {
+        char    WS_name[8];        /* Workstation System name  */
+        char    host_name[8];      /* Host system name     */
+        __u16   read_frame_size;   /* read frame size */
+        __u16   write_frame_size;  /* write frame size */
+        __u8    reserved[4];       /* reserved */
+};
+
+/*------------------------------------------------------*/
+/*     Data for Connect command                         */
+/*------------------------------------------------------*/
+struct conncmd  {
+        char     WS_name[8];       /* Workstation application name  */
+        char     host_name[8];     /* Host application name      */
+        __u16    reserved1[2];     /* read frame size */
+        __u8     reserved2[4];     /* reserved  */
+};
+
+/*------------------------------------------------------*/
+/*     Data for CLAW error                              */
+/*------------------------------------------------------*/
+struct clawwerror  {
+        char      reserved1[8];   /* reserved */
+        char      reserved2[8];   /* reserved  */
+        char      reserved3[8];   /* reserved  */
+};
+
+/*------------------------------------------------------*/
+/*     Data buffer for CLAW                             */
+/*------------------------------------------------------*/
+struct clawbuf  {
+       char      buffer[MAX_ENVELOPE_SIZE];   /* data buffer */
+};
+
+/*------------------------------------------------------*/
+/*     Channel control block for read and write channel */
+/*------------------------------------------------------*/
+
+struct chbk {
+        unsigned int        devno;
+        int                 irq;
+	char 		    id[CLAW_ID_SIZE];
+       __u32               IO_active;
+        __u8                claw_state;
+        struct irb          *irb;
+       	struct ccw_device   *cdev;  /* pointer to the channel device */
+	struct net_device   *ndev;
+        wait_queue_head_t   wait;
+        struct tasklet_struct    tasklet;
+        struct timer_list   timer;
+        unsigned long       flag_a;    /* atomic flags */
+#define CLAW_BH_ACTIVE      0
+        unsigned long       flag_b;    /* atomic flags */
+#define CLAW_WRITE_ACTIVE   0
+        __u8                last_dstat;
+        __u8                flag;
+	struct sk_buff_head collect_queue;
+	spinlock_t collect_lock;
+#define CLAW_WRITE      0x02      /* - Set if this is a write channel */
+#define CLAW_READ	0x01      /* - Set if this is a read channel  */
+#define CLAW_TIMER      0x80      /* - Set if timer made the wake_up  */
+};
+
+/*--------------------------------------------------------------*
+*           CLAW  environment block                             *
+*---------------------------------------------------------------*/
+
+struct claw_env {
+        unsigned int            devno[2];       /* device number */
+        char                    host_name[9];   /* Host name */
+        char                    adapter_name [9]; /* adapter name */
+        char                    api_type[9];    /* TCPIP, API or PACKED */
+        void                    *p_priv;        /* privptr */
+        __u16                   read_buffers;   /* read buffer number */
+        __u16                   write_buffers;  /* write buffer number */
+        __u16                   read_size;      /* read buffer size */
+        __u16                   write_size;     /* write buffer size */
+        __u16                   dev_id;         /* device ident */
+	__u8			packing;	/* are we packing? */
+	volatile __u8		queme_switch;   /* gate for imed packing  */
+	volatile unsigned long	pk_delay;	/* Delay for adaptive packing */
+        __u8                    in_use;         /* device active flag */
+        struct net_device       *ndev;    	/* backward ptr to the net dev*/
+};
+
+/*--------------------------------------------------------------*
+*           CLAW  main control block                            *
+*---------------------------------------------------------------*/
+
+struct claw_privbk {
+        void *p_buff_ccw;
+        __u32      p_buff_ccw_num;
+        void  *p_buff_read;
+        __u32      p_buff_read_num;
+        __u32      p_buff_pages_perread;
+        void  *p_buff_write;
+        __u32      p_buff_write_num;
+        __u32      p_buff_pages_perwrite;
+        long       active_link_ID;           /* Active logical link ID */
+        struct ccwbk *p_write_free_chain;     /* pointer to free ccw chain */
+        struct ccwbk *p_write_active_first;   /* ptr to the first write ccw */
+        struct ccwbk *p_write_active_last;    /* ptr to the last write ccw */
+        struct ccwbk *p_read_active_first;    /* ptr to the first read ccw */
+        struct ccwbk *p_read_active_last;     /* ptr to the last read ccw */
+        struct endccw *p_end_ccw;              /*ptr to ending ccw */
+        struct ccwbk *p_claw_signal_blk;      /* ptr to signal block */
+        __u32      write_free_count;       /* number of free bufs for write */
+	struct     net_device_stats  stats; /* 	 device status    */
+        struct chbk channel[2];            /* Channel control blocks */
+        __u8       mtc_skipping;
+        int        mtc_offset;
+        int        mtc_logical_link;
+        void       *p_mtc_envelope;
+	struct	   sk_buff	*pk_skb;	/* packing buffer    */
+	int	   pk_cnt;
+        struct clawctl ctl_bk;
+        struct claw_env *p_env;
+        __u8       system_validate_comp;
+        __u8       release_pend;
+        __u8      checksum_received_ip_pkts;
+	__u8      buffs_alloc;
+        struct endccw  end_ccw;
+        unsigned long  tbusy;
+
+};
+
+
+/************************************************************/
+/* define global constants                                  */
+/************************************************************/
+
+#define CCWBK_SIZE sizeof(struct ccwbk)
+
+
diff -purN linux-2.6.11/drivers/s390/net/ctcdbug.h linux-2.6.12-rc6/drivers/s390/net/ctcdbug.h
--- linux-2.6.11/drivers/s390/net/ctcdbug.h	2005-03-02 08:38:07.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/ctcdbug.h	2005-06-06 17:22:29.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/ctcdbug.h ($Revision: 1.4 $)
+ * linux/drivers/s390/net/ctcdbug.h ($Revision: 1.5 $)
  *
  * CTC / ESCON network driver - s390 dbf exploit.
  *
@@ -9,7 +9,7 @@
  *    Author(s): Original Code written by
  *			  Peter Tiedemann (ptiedem@de.ibm.com)
  *
- *    $Revision: 1.4 $	 $Date: 2004/10/15 09:26:58 $
+ *    $Revision: 1.5 $	 $Date: 2005/02/27 19:46:44 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,9 +25,11 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
+#ifndef _CTCDBUG_H_
+#define _CTCDBUG_H_
 
 #include <asm/debug.h>
+#include "ctcmain.h"
 /**
  * Debug Facility stuff
  */
@@ -41,7 +43,7 @@
 #define CTC_DBF_DATA_LEN 128
 #define CTC_DBF_DATA_INDEX 3
 #define CTC_DBF_DATA_NR_AREAS 1
-#define CTC_DBF_DATA_LEVEL 2
+#define CTC_DBF_DATA_LEVEL 3
 
 #define CTC_DBF_TRACE_NAME "ctc_trace"
 #define CTC_DBF_TRACE_LEN 16
@@ -121,3 +123,5 @@ hex_dump(unsigned char *buf, size_t len)
 	printk("\n");
 }
 
+
+#endif
diff -purN linux-2.6.11/drivers/s390/net/ctcmain.c linux-2.6.12-rc6/drivers/s390/net/ctcmain.c
--- linux-2.6.11/drivers/s390/net/ctcmain.c	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/ctcmain.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.68 2004/12/27 09:25:27 heicarst Exp $
+ * $Id: ctcmain.c,v 1.74 2005/03/24 09:04:17 mschwide Exp $
  *
  * CTC / ESCON network driver
  *
@@ -7,6 +7,7 @@
  * Author(s): Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)
  * Fixes by : Jochen Rhrig (roehrig@de.ibm.com)
  *            Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+	      Peter Tiedemann (ptiedem@de.ibm.com)
  * Driver Model stuff by : Cornelia Huck <cohuck@de.ibm.com>
  *
  * Documentation used:
@@ -36,12 +37,11 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.68 $
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.74 $
  *
  */
 
 #undef DEBUG
-
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -73,286 +73,13 @@
 #include "ctctty.h"
 #include "fsm.h"
 #include "cu3088.h"
+
 #include "ctcdbug.h"
+#include "ctcmain.h"
 
 MODULE_AUTHOR("(C) 2000 IBM Corp. by Fritz Elfert (felfert@millenux.com)");
 MODULE_DESCRIPTION("Linux for S/390 CTC/Escon Driver");
 MODULE_LICENSE("GPL");
-
-/**
- * CCW commands, used in this driver.
- */
-#define CCW_CMD_WRITE		0x01
-#define CCW_CMD_READ		0x02
-#define CCW_CMD_SET_EXTENDED	0xc3
-#define CCW_CMD_PREPARE		0xe3
-
-#define CTC_PROTO_S390          0
-#define CTC_PROTO_LINUX         1
-#define CTC_PROTO_LINUX_TTY     2
-#define CTC_PROTO_OS390         3
-#define CTC_PROTO_MAX           3
-
-#define CTC_BUFSIZE_LIMIT       65535
-#define CTC_BUFSIZE_DEFAULT     32768
-
-#define CTC_TIMEOUT_5SEC        5000
-
-#define CTC_INITIAL_BLOCKLEN    2
-
-#define READ			0
-#define WRITE			1
-
-#define CTC_ID_SIZE             BUS_ID_SIZE+3
-
-
-struct ctc_profile {
-	unsigned long maxmulti;
-	unsigned long maxcqueue;
-	unsigned long doios_single;
-	unsigned long doios_multi;
-	unsigned long txlen;
-	unsigned long tx_time;
-	struct timespec send_stamp;
-};
-
-/**
- * Definition of one channel
- */
-struct channel {
-
-	/**
-	 * Pointer to next channel in list.
-	 */
-	struct channel *next;
-	char id[CTC_ID_SIZE];
-	struct ccw_device *cdev;
-
-	/**
-	 * Type of this channel.
-	 * CTC/A or Escon for valid channels.
-	 */
-	enum channel_types type;
-
-	/**
-	 * Misc. flags. See CHANNEL_FLAGS_... below
-	 */
-	__u32 flags;
-
-	/**
-	 * The protocol of this channel
-	 */
-	__u16 protocol;
-
-	/**
-	 * I/O and irq related stuff
-	 */
-	struct ccw1 *ccw;
-	struct irb *irb;
-
-	/**
-	 * RX/TX buffer size
-	 */
-	int max_bufsize;
-
-	/**
-	 * Transmit/Receive buffer.
-	 */
-	struct sk_buff *trans_skb;
-
-	/**
-	 * Universal I/O queue.
-	 */
-	struct sk_buff_head io_queue;
-
-	/**
-	 * TX queue for collecting skb's during busy.
-	 */
-	struct sk_buff_head collect_queue;
-
-	/**
-	 * Amount of data in collect_queue.
-	 */
-	int collect_len;
-
-	/**
-	 * spinlock for collect_queue and collect_len
-	 */
-	spinlock_t collect_lock;
-
-	/**
-	 * Timer for detecting unresposive
-	 * I/O operations.
-	 */
-	fsm_timer timer;
-
-	/**
-	 * Retry counter for misc. operations.
-	 */
-	int retry;
-
-	/**
-	 * The finite state machine of this channel
-	 */
-	fsm_instance *fsm;
-
-	/**
-	 * The corresponding net_device this channel
-	 * belongs to.
-	 */
-	struct net_device *netdev;
-
-	struct ctc_profile prof;
-
-	unsigned char *trans_skb_data;
-
-	__u16 logflags;
-};
-
-#define CHANNEL_FLAGS_READ            0
-#define CHANNEL_FLAGS_WRITE           1
-#define CHANNEL_FLAGS_INUSE           2
-#define CHANNEL_FLAGS_BUFSIZE_CHANGED 4
-#define CHANNEL_FLAGS_FAILED          8
-#define CHANNEL_FLAGS_WAITIRQ        16
-#define CHANNEL_FLAGS_RWMASK 1
-#define CHANNEL_DIRECTION(f) (f & CHANNEL_FLAGS_RWMASK)
-
-#define LOG_FLAG_ILLEGALPKT  1
-#define LOG_FLAG_ILLEGALSIZE 2
-#define LOG_FLAG_OVERRUN     4
-#define LOG_FLAG_NOMEM       8
-
-#define CTC_LOGLEVEL_INFO     1
-#define CTC_LOGLEVEL_NOTICE   2
-#define CTC_LOGLEVEL_WARN     4
-#define CTC_LOGLEVEL_EMERG    8
-#define CTC_LOGLEVEL_ERR     16
-#define CTC_LOGLEVEL_DEBUG   32
-#define CTC_LOGLEVEL_CRIT    64
-
-#define CTC_LOGLEVEL_DEFAULT \
-(CTC_LOGLEVEL_INFO | CTC_LOGLEVEL_NOTICE | CTC_LOGLEVEL_WARN | CTC_LOGLEVEL_CRIT)
-
-#define CTC_LOGLEVEL_MAX     ((CTC_LOGLEVEL_CRIT<<1)-1)
-
-static int loglevel = CTC_LOGLEVEL_DEFAULT;
-
-#define ctc_pr_debug(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_DEBUG) printk(KERN_DEBUG fmt,##arg); } while (0)
-
-#define ctc_pr_info(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_INFO) printk(KERN_INFO fmt,##arg); } while (0)
-
-#define ctc_pr_notice(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_NOTICE) printk(KERN_NOTICE fmt,##arg); } while (0)
-
-#define ctc_pr_warn(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_WARN) printk(KERN_WARNING fmt,##arg); } while (0)
-
-#define ctc_pr_emerg(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_EMERG) printk(KERN_EMERG fmt,##arg); } while (0)
-
-#define ctc_pr_err(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_ERR) printk(KERN_ERR fmt,##arg); } while (0)
-
-#define ctc_pr_crit(fmt, arg...) \
-do { if (loglevel & CTC_LOGLEVEL_CRIT) printk(KERN_CRIT fmt,##arg); } while (0)
-
-/**
- * Linked list of all detected channels.
- */
-static struct channel *channels = NULL;
-
-struct ctc_priv {
-	struct net_device_stats stats;
-	unsigned long tbusy;
-	/**
-	 * The finite state machine of this interface.
-	 */
-	fsm_instance *fsm;
-	/**
-	 * The protocol of this device
-	 */
-	__u16 protocol;
- 	/**
- 	 * Timer for restarting after I/O Errors
- 	 */
- 	fsm_timer               restart_timer;
-
-	struct channel *channel[2];
-};
-
-/**
- * Definition of our link level header.
- */
-struct ll_header {
-	__u16 length;
-	__u16 type;
-	__u16 unused;
-};
-#define LL_HEADER_LENGTH (sizeof(struct ll_header))
-
-/**
- * Compatibility macros for busy handling
- * of network devices.
- */
-static __inline__ void
-ctc_clear_busy(struct net_device * dev)
-{
-	clear_bit(0, &(((struct ctc_priv *) dev->priv)->tbusy));
-	if (((struct ctc_priv *)dev->priv)->protocol != CTC_PROTO_LINUX_TTY)
-		netif_wake_queue(dev);
-}
-
-static __inline__ int
-ctc_test_and_set_busy(struct net_device * dev)
-{
-	if (((struct ctc_priv *)dev->priv)->protocol != CTC_PROTO_LINUX_TTY)
-		netif_stop_queue(dev);
-	return test_and_set_bit(0, &((struct ctc_priv *) dev->priv)->tbusy);
-}
-
-/**
- * Print Banner.
- */
-static void
-print_banner(void)
-{
-	static int printed = 0;
-	char vbuf[] = "$Revision: 1.68 $";
-	char *version = vbuf;
-
-	if (printed)
-		return;
-	if ((version = strchr(version, ':'))) {
-		char *p = strchr(version + 1, '$');
-		if (p)
-			*p = '\0';
-	} else
-		version = " ??? ";
-	printk(KERN_INFO "CTC driver Version%s"
-#ifdef DEBUG
-		    " (DEBUG-VERSION, " __DATE__ __TIME__ ")"
-#endif
-		    " initialized\n", version);
-	printed = 1;
-}
-
-/**
- * Return type of a detected device.
- */
-static enum channel_types
-get_channel_type(struct ccw_device_id *id)
-{
-	enum channel_types type = (enum channel_types) id->driver_info;
-
-	if (type == channel_type_ficon)
-		type = channel_type_escon;
-
-	return type;
-}
-
 /**
  * States of the interface statemachine.
  */
@@ -368,7 +95,7 @@ enum dev_states {
 	/**
 	 * MUST be always the last element!!
 	 */
-	NR_DEV_STATES
+	CTC_NR_DEV_STATES
 };
 
 static const char *dev_state_names[] = {
@@ -396,7 +123,7 @@ enum dev_events {
 	/**
 	 * MUST be always the last element!!
 	 */
-	NR_DEV_EVENTS
+	CTC_NR_DEV_EVENTS
 };
 
 static const char *dev_event_names[] = {
@@ -473,40 +200,6 @@ enum ch_events {
 	NR_CH_EVENTS,
 };
 
-static const char *ch_event_names[] = {
-	"ccw_device success",
-	"ccw_device busy",
-	"ccw_device enodev",
-	"ccw_device ioerr",
-	"ccw_device unknown",
-
-	"Status ATTN & BUSY",
-	"Status ATTN",
-	"Status BUSY",
-
-	"Unit check remote reset",
-	"Unit check remote system reset",
-	"Unit check TX timeout",
-	"Unit check TX parity",
-	"Unit check Hardware failure",
-	"Unit check RX parity",
-	"Unit check ZERO",
-	"Unit check Unknown",
-
-	"SubChannel check Unknown",
-
-	"Machine check failure",
-	"Machine check operational",
-
-	"IRQ normal",
-	"IRQ final",
-
-	"Timer",
-
-	"Start",
-	"Stop",
-};
-
 /**
  * States of the channel statemachine.
  */
@@ -542,6 +235,87 @@ enum ch_states {
 	NR_CH_STATES,
 };
 
+static int loglevel = CTC_LOGLEVEL_DEFAULT;
+
+/**
+ * Linked list of all detected channels.
+ */
+static struct channel *channels = NULL;
+
+/**
+ * Print Banner.
+ */
+static void
+print_banner(void)
+{
+	static int printed = 0;
+	char vbuf[] = "$Revision: 1.74 $";
+	char *version = vbuf;
+
+	if (printed)
+		return;
+	if ((version = strchr(version, ':'))) {
+		char *p = strchr(version + 1, '$');
+		if (p)
+			*p = '\0';
+	} else
+		version = " ??? ";
+	printk(KERN_INFO "CTC driver Version%s"
+#ifdef DEBUG
+		    " (DEBUG-VERSION, " __DATE__ __TIME__ ")"
+#endif
+		    " initialized\n", version);
+	printed = 1;
+}
+
+/**
+ * Return type of a detected device.
+ */
+static enum channel_types
+get_channel_type(struct ccw_device_id *id)
+{
+	enum channel_types type = (enum channel_types) id->driver_info;
+
+	if (type == channel_type_ficon)
+		type = channel_type_escon;
+
+	return type;
+}
+
+static const char *ch_event_names[] = {
+	"ccw_device success",
+	"ccw_device busy",
+	"ccw_device enodev",
+	"ccw_device ioerr",
+	"ccw_device unknown",
+
+	"Status ATTN & BUSY",
+	"Status ATTN",
+	"Status BUSY",
+
+	"Unit check remote reset",
+	"Unit check remote system reset",
+	"Unit check TX timeout",
+	"Unit check TX parity",
+	"Unit check Hardware failure",
+	"Unit check RX parity",
+	"Unit check ZERO",
+	"Unit check Unknown",
+
+	"SubChannel check Unknown",
+
+	"Machine check failure",
+	"Machine check operational",
+
+	"IRQ normal",
+	"IRQ final",
+
+	"Timer",
+
+	"Start",
+	"Stop",
+};
+
 static const char *ch_state_names[] = {
 	"Idle",
 	"Stopped",
@@ -1894,13 +1668,15 @@ add_channel(struct ccw_device *cdev, enu
 		return -1;
 	}
 	memset(ch, 0, sizeof (struct channel));
-	if ((ch->ccw = (struct ccw1 *) kmalloc(sizeof (struct ccw1) * 8,
+	if ((ch->ccw = (struct ccw1 *) kmalloc(8*sizeof(struct ccw1),
 					       GFP_KERNEL | GFP_DMA)) == NULL) {
 		kfree(ch);
 		ctc_pr_warn("ctc: Out of memory in add_channel\n");
 		return -1;
 	}
 
+	memset(ch->ccw, 0, 8*sizeof(struct ccw1));	// assure all flags and counters are reset
+
 	/**
 	 * "static" ccws are used in the following way:
 	 *
@@ -1914,26 +1690,21 @@ add_channel(struct ccw_device *cdev, enu
 	 *           4: write (idal allocated on every write).
 	 *           5: nop
 	 * ccw[6..7] (Channel program for initial channel setup):
-	 *           3: set extended mode
-	 *           4: nop
+	 *           6: set extended mode
+	 *           7: nop
 	 *
 	 * ch->ccw[0..5] are initialized in ch_action_start because
 	 * the channel's direction is yet unknown here.
 	 */
 	ch->ccw[6].cmd_code = CCW_CMD_SET_EXTENDED;
 	ch->ccw[6].flags = CCW_FLAG_SLI;
-	ch->ccw[6].count = 0;
-	ch->ccw[6].cda = 0;
 
 	ch->ccw[7].cmd_code = CCW_CMD_NOOP;
 	ch->ccw[7].flags = CCW_FLAG_SLI;
-	ch->ccw[7].count = 0;
-	ch->ccw[7].cda = 0;
 
 	ch->cdev = cdev;
 	snprintf(ch->id, CTC_ID_SIZE, "ch-%s", cdev->dev.bus_id);
 	ch->type = type;
-	loglevel = CTC_LOGLEVEL_DEFAULT;
 	ch->fsm = init_fsm(ch->id, ch_state_names,
 			   ch_event_names, NR_CH_STATES, NR_CH_EVENTS,
 			   ch_fsm, CH_FSM_LEN, GFP_KERNEL);
@@ -1955,7 +1726,7 @@ add_channel(struct ccw_device *cdev, enu
 	memset(ch->irb, 0, sizeof (struct irb));
 	while (*c && less_than((*c)->id, ch->id))
 		c = &(*c)->next;
-	if (!strncmp((*c)->id, ch->id, CTC_ID_SIZE)) {
+	if (*c && (!strncmp((*c)->id, ch->id, CTC_ID_SIZE))) {
 		ctc_pr_debug(
 			"ctc: add_channel: device %s already in list, "
 			"using old entry\n", (*c)->id);
@@ -2011,6 +1782,8 @@ channel_remove(struct channel *ch)
 				dev_kfree_skb(ch->trans_skb);
 			}
 			kfree(ch->ccw);
+			kfree(ch->irb);
+			kfree(ch);
 			return;
 		}
 		c = &((*c)->next);
@@ -2694,6 +2467,7 @@ ctc_stats(struct net_device * dev)
 /*
  * sysfs attributes
  */
+
 static ssize_t
 buffer_show(struct device *dev, char *buf)
 {
@@ -2703,7 +2477,7 @@ buffer_show(struct device *dev, char *bu
 	if (!priv)
 		return -ENODEV;
 	return sprintf(buf, "%d\n",
-		       priv->channel[READ]->max_bufsize);
+			priv->buffer_size);
 }
 
 static ssize_t
@@ -2712,56 +2486,61 @@ buffer_write(struct device *dev, const c
 	struct ctc_priv *priv;
 	struct net_device *ndev;
 	int bs1;
+	char buffer[16];
 
 	DBF_TEXT(trace, 3, __FUNCTION__);
+	DBF_TEXT(trace, 3, buf);
 	priv = dev->driver_data;
-	if (!priv)
+	if (!priv) {
+		DBF_TEXT(trace, 3, "bfnopriv");
 		return -ENODEV;
+	}
+
+	sscanf(buf, "%u", &bs1);
+	if (bs1 > CTC_BUFSIZE_LIMIT)
+		goto einval;
+	if (bs1 < (576 + LL_HEADER_LENGTH + 2))
+		goto einval;
+	priv->buffer_size = bs1;	// just to overwrite the default
+
 	ndev = priv->channel[READ]->netdev;
-	if (!ndev)
+	if (!ndev) {
+		DBF_TEXT(trace, 3, "bfnondev");
 		return -ENODEV;
-	sscanf(buf, "%u", &bs1);
+	}
 
-	if (bs1 > CTC_BUFSIZE_LIMIT)
-		return -EINVAL;
 	if ((ndev->flags & IFF_RUNNING) &&
 	    (bs1 < (ndev->mtu + LL_HEADER_LENGTH + 2)))
-		return -EINVAL;
-	if (bs1 < (576 + LL_HEADER_LENGTH + 2))
-		return -EINVAL;
+		goto einval;
 
-	priv->channel[READ]->max_bufsize =
-	    priv->channel[WRITE]->max_bufsize = bs1;
+	priv->channel[READ]->max_bufsize = bs1;
+	priv->channel[WRITE]->max_bufsize = bs1;
 	if (!(ndev->flags & IFF_RUNNING))
 		ndev->mtu = bs1 - LL_HEADER_LENGTH - 2;
 	priv->channel[READ]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;
 	priv->channel[WRITE]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;
 
+	sprintf(buffer, "%d",priv->buffer_size);
+	DBF_TEXT(trace, 3, buffer);
 	return count;
 
+einval:
+	DBF_TEXT(trace, 3, "buff_err");
+	return -EINVAL;
 }
 
 static ssize_t
 loglevel_show(struct device *dev, char *buf)
 {
-	struct ctc_priv *priv;
-
-	priv = dev->driver_data;
-	if (!priv)
-		return -ENODEV;
 	return sprintf(buf, "%d\n", loglevel);
 }
 
 static ssize_t
 loglevel_write(struct device *dev, const char *buf, size_t count)
 {
-	struct ctc_priv *priv;
 	int ll1;
 
 	DBF_TEXT(trace, 5, __FUNCTION__);
-	priv = dev->driver_data;
-	if (!priv)
-		return -ENODEV;
 	sscanf(buf, "%i", &ll1);
 
 	if ((ll1 > CTC_LOGLEVEL_MAX) || (ll1 < 0))
@@ -2831,27 +2610,6 @@ stats_write(struct device *dev, const ch
 	return count;
 }
 
-static DEVICE_ATTR(buffer, 0644, buffer_show, buffer_write);
-static DEVICE_ATTR(loglevel, 0644, loglevel_show, loglevel_write);
-static DEVICE_ATTR(stats, 0644, stats_show, stats_write);
-
-static int
-ctc_add_attributes(struct device *dev)
-{
-//	device_create_file(dev, &dev_attr_buffer);
-	device_create_file(dev, &dev_attr_loglevel);
-	device_create_file(dev, &dev_attr_stats);
-	return 0;
-}
-
-static void
-ctc_remove_attributes(struct device *dev)
-{
-	device_remove_file(dev, &dev_attr_stats);
-	device_remove_file(dev, &dev_attr_loglevel);
-//	device_remove_file(dev, &dev_attr_buffer);
-}
-
 
 static void
 ctc_netdev_unregister(struct net_device * dev)
@@ -2895,51 +2653,6 @@ ctc_free_netdevice(struct net_device * d
 #endif
 }
 
-/**
- * Initialize everything of the net device except the name and the
- * channel structs.
- */
-static struct net_device *
-ctc_init_netdevice(struct net_device * dev, int alloc_device, 
-		   struct ctc_priv *privptr)
-{
-	if (!privptr)
-		return NULL;
-
-	DBF_TEXT(setup, 3, __FUNCTION__);
-	if (alloc_device) {
-		dev = kmalloc(sizeof (struct net_device), GFP_KERNEL);
-		if (!dev)
-			return NULL;
-		memset(dev, 0, sizeof (struct net_device));
-	}
-
-	dev->priv = privptr;
-	privptr->fsm = init_fsm("ctcdev", dev_state_names,
-				dev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,
-				dev_fsm, DEV_FSM_LEN, GFP_KERNEL);
-	if (privptr->fsm == NULL) {
-		if (alloc_device)
-			kfree(dev);
-		return NULL;
-	}
-	fsm_newstate(privptr->fsm, DEV_STATE_STOPPED);
-	fsm_settimer(privptr->fsm, &privptr->restart_timer);
-	dev->mtu = CTC_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2;
-	dev->hard_start_xmit = ctc_tx;
-	dev->open = ctc_open;
-	dev->stop = ctc_close;
-	dev->get_stats = ctc_stats;
-	dev->change_mtu = ctc_change_mtu;
-	dev->hard_header_len = LL_HEADER_LENGTH + 2;
-	dev->addr_len = 0;
-	dev->type = ARPHRD_SLIP;
-	dev->tx_queue_len = 100;
-	dev->flags = IFF_POINTOPOINT | IFF_NOARP;
-	SET_MODULE_OWNER(dev);
-	return dev;
-}
-
 static ssize_t
 ctc_proto_show(struct device *dev, char *buf)
 {
@@ -2972,7 +2685,6 @@ ctc_proto_store(struct device *dev, cons
 	return count;
 }
 
-static DEVICE_ATTR(protocol, 0644, ctc_proto_show, ctc_proto_store);
 
 static ssize_t
 ctc_type_show(struct device *dev, char *buf)
@@ -2986,8 +2698,13 @@ ctc_type_show(struct device *dev, char *
 	return sprintf(buf, "%s\n", cu3088_type[cgdev->cdev[0]->id.driver_info]);
 }
 
+static DEVICE_ATTR(buffer, 0644, buffer_show, buffer_write);
+static DEVICE_ATTR(protocol, 0644, ctc_proto_show, ctc_proto_store);
 static DEVICE_ATTR(type, 0444, ctc_type_show, NULL);
 
+static DEVICE_ATTR(loglevel, 0644, loglevel_show, loglevel_write);
+static DEVICE_ATTR(stats, 0644, stats_show, stats_write);
+
 static struct attribute *ctc_attr[] = {
 	&dev_attr_protocol.attr,
 	&dev_attr_type.attr,
@@ -3000,6 +2717,21 @@ static struct attribute_group ctc_attr_g
 };
 
 static int
+ctc_add_attributes(struct device *dev)
+{
+	device_create_file(dev, &dev_attr_loglevel);
+	device_create_file(dev, &dev_attr_stats);
+	return 0;
+}
+
+static void
+ctc_remove_attributes(struct device *dev)
+{
+	device_remove_file(dev, &dev_attr_stats);
+	device_remove_file(dev, &dev_attr_loglevel);
+}
+
+static int
 ctc_add_files(struct device *dev)
 {
 	pr_debug("%s() called\n", __FUNCTION__);
@@ -3023,15 +2755,15 @@ ctc_remove_files(struct device *dev)
  *
  * @returns 0 on success, !0 on failure.
  */
-
 static int
 ctc_probe_device(struct ccwgroup_device *cgdev)
 {
 	struct ctc_priv *priv;
 	int rc;
+	char buffer[16];
 
 	pr_debug("%s() called\n", __FUNCTION__);
-	DBF_TEXT(trace, 3, __FUNCTION__);
+	DBF_TEXT(setup, 3, __FUNCTION__);
 
 	if (!get_device(&cgdev->dev))
 		return -ENODEV;
@@ -3050,15 +2782,75 @@ ctc_probe_device(struct ccwgroup_device 
 		put_device(&cgdev->dev);
 		return rc;
 	}
-
+	priv->buffer_size = CTC_BUFSIZE_DEFAULT;
 	cgdev->cdev[0]->handler = ctc_irq_handler;
 	cgdev->cdev[1]->handler = ctc_irq_handler;
 	cgdev->dev.driver_data = priv;
 
+	sprintf(buffer, "%p", priv);
+	DBF_TEXT(data, 3, buffer);
+
+	sprintf(buffer, "%u", (unsigned int)sizeof(struct ctc_priv));
+	DBF_TEXT(data, 3, buffer);
+
+	sprintf(buffer, "%p", &channels);
+	DBF_TEXT(data, 3, buffer);
+
+	sprintf(buffer, "%u", (unsigned int)sizeof(struct channel));
+	DBF_TEXT(data, 3, buffer);
+
 	return 0;
 }
 
 /**
+ * Initialize everything of the net device except the name and the
+ * channel structs.
+ */
+static struct net_device *
+ctc_init_netdevice(struct net_device * dev, int alloc_device,
+		   struct ctc_priv *privptr)
+{
+	if (!privptr)
+		return NULL;
+
+	DBF_TEXT(setup, 3, __FUNCTION__);
+
+	if (alloc_device) {
+		dev = kmalloc(sizeof (struct net_device), GFP_KERNEL);
+		if (!dev)
+			return NULL;
+		memset(dev, 0, sizeof (struct net_device));
+	}
+
+	dev->priv = privptr;
+	privptr->fsm = init_fsm("ctcdev", dev_state_names,
+				dev_event_names, CTC_NR_DEV_STATES, CTC_NR_DEV_EVENTS,
+				dev_fsm, DEV_FSM_LEN, GFP_KERNEL);
+	if (privptr->fsm == NULL) {
+		if (alloc_device)
+			kfree(dev);
+		return NULL;
+	}
+	fsm_newstate(privptr->fsm, DEV_STATE_STOPPED);
+	fsm_settimer(privptr->fsm, &privptr->restart_timer);
+	if (dev->mtu == 0)
+		dev->mtu = CTC_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2;
+	dev->hard_start_xmit = ctc_tx;
+	dev->open = ctc_open;
+	dev->stop = ctc_close;
+	dev->get_stats = ctc_stats;
+	dev->change_mtu = ctc_change_mtu;
+	dev->hard_header_len = LL_HEADER_LENGTH + 2;
+	dev->addr_len = 0;
+	dev->type = ARPHRD_SLIP;
+	dev->tx_queue_len = 100;
+	dev->flags = IFF_POINTOPOINT | IFF_NOARP;
+	SET_MODULE_OWNER(dev);
+	return dev;
+}
+
+
+/**
  *
  * Setup an interface.
  *
@@ -3076,6 +2868,7 @@ ctc_new_device(struct ccwgroup_device *c
 	struct ctc_priv *privptr;
 	struct net_device *dev;
 	int ret;
+	char buffer[16];
 
 	pr_debug("%s() called\n", __FUNCTION__);
 	DBF_TEXT(setup, 3, __FUNCTION__);
@@ -3084,6 +2877,9 @@ ctc_new_device(struct ccwgroup_device *c
 	if (!privptr)
 		return -ENODEV;
 
+	sprintf(buffer, "%d", privptr->buffer_size);
+	DBF_TEXT(setup, 3, buffer);
+
 	type = get_channel_type(&cgdev->cdev[0]->id);
 	
 	snprintf(read_id, CTC_ID_SIZE, "ch-%s", cgdev->cdev[0]->dev.bus_id);
@@ -3131,7 +2927,7 @@ ctc_new_device(struct ccwgroup_device *c
 		}
 		privptr->channel[direction]->netdev = dev;
 		privptr->channel[direction]->protocol = privptr->protocol;
-		privptr->channel[direction]->max_bufsize = CTC_BUFSIZE_DEFAULT;
+		privptr->channel[direction]->max_bufsize = privptr->buffer_size;
 	}
 	/* sysfs magic */
 	SET_NETDEV_DEV(dev, &cgdev->dev);
@@ -3172,9 +2968,10 @@ ctc_shutdown_device(struct ccwgroup_devi
 	struct ctc_priv *priv;
 	struct net_device *ndev;
 		
-	DBF_TEXT(trace, 3, __FUNCTION__);
+	DBF_TEXT(setup, 3, __FUNCTION__);
 	pr_debug("%s() called\n", __FUNCTION__);
 
+
 	priv = cgdev->dev.driver_data;
 	ndev = NULL;
 	if (!priv)
@@ -3210,7 +3007,6 @@ ctc_shutdown_device(struct ccwgroup_devi
 		channel_remove(priv->channel[READ]);
 	if (priv->channel[WRITE])
 		channel_remove(priv->channel[WRITE]);
-	
 	priv->channel[READ] = priv->channel[WRITE] = NULL;
 
 	return 0;
@@ -3223,7 +3019,7 @@ ctc_remove_device(struct ccwgroup_device
 	struct ctc_priv *priv;
 
 	pr_debug("%s() called\n", __FUNCTION__);
-	DBF_TEXT(trace, 3, __FUNCTION__);
+	DBF_TEXT(setup, 3, __FUNCTION__);
 
 	priv = cgdev->dev.driver_data;
 	if (!priv)
@@ -3260,6 +3056,7 @@ static struct ccwgroup_driver ctc_group_
 static void __exit
 ctc_exit(void)
 {
+	DBF_TEXT(setup, 3, __FUNCTION__);
 	unregister_cu3088_discipline(&ctc_group_driver);
 	ctc_tty_cleanup();
 	ctc_unregister_dbf_views();
@@ -3277,6 +3074,10 @@ ctc_init(void)
 {
 	int ret = 0;
 
+	loglevel = CTC_LOGLEVEL_DEFAULT;
+
+	DBF_TEXT(setup, 3, __FUNCTION__);
+
 	print_banner();
 
 	ret = ctc_register_dbf_views();
diff -purN linux-2.6.11/drivers/s390/net/ctcmain.h linux-2.6.12-rc6/drivers/s390/net/ctcmain.h
--- linux-2.6.11/drivers/s390/net/ctcmain.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/ctcmain.h	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,276 @@
+/*
+ * $Id: ctcmain.h,v 1.4 2005/03/24 09:04:17 mschwide Exp $
+ *
+ * CTC / ESCON network driver
+ *
+ * Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
+ * Author(s): Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)
+	      Peter Tiedemann (ptiedem@de.ibm.com)
+ *
+ *
+ * Documentation used:
+ *  - Principles of Operation (IBM doc#: SA22-7201-06)
+ *  - Common IO/-Device Commands and Self Description (IBM doc#: SA22-7204-02)
+ *  - Common IO/-Device Commands and Self Description (IBM doc#: SN22-5535)
+ *  - ESCON Channel-to-Channel Adapter (IBM doc#: SA22-7203-00)
+ *  - ESCON I/O Interface (IBM doc#: SA22-7202-029
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.4 $
+ *
+ */
+
+#ifndef _CTCMAIN_H_
+#define _CTCMAIN_H_
+
+#include <asm/ccwdev.h>
+#include <asm/ccwgroup.h>
+
+#include "ctctty.h"
+#include "fsm.h"
+#include "cu3088.h"
+
+
+/**
+ * CCW commands, used in this driver.
+ */
+#define CCW_CMD_WRITE		0x01
+#define CCW_CMD_READ		0x02
+#define CCW_CMD_SET_EXTENDED	0xc3
+#define CCW_CMD_PREPARE		0xe3
+
+#define CTC_PROTO_S390          0
+#define CTC_PROTO_LINUX         1
+#define CTC_PROTO_LINUX_TTY     2
+#define CTC_PROTO_OS390         3
+#define CTC_PROTO_MAX           3
+
+#define CTC_BUFSIZE_LIMIT       65535
+#define CTC_BUFSIZE_DEFAULT     32768
+
+#define CTC_TIMEOUT_5SEC        5000
+
+#define CTC_INITIAL_BLOCKLEN    2
+
+#define READ			0
+#define WRITE			1
+
+#define CTC_ID_SIZE             BUS_ID_SIZE+3
+
+
+struct ctc_profile {
+	unsigned long maxmulti;
+	unsigned long maxcqueue;
+	unsigned long doios_single;
+	unsigned long doios_multi;
+	unsigned long txlen;
+	unsigned long tx_time;
+	struct timespec send_stamp;
+};
+
+/**
+ * Definition of one channel
+ */
+struct channel {
+
+	/**
+	 * Pointer to next channel in list.
+	 */
+	struct channel *next;
+	char id[CTC_ID_SIZE];
+	struct ccw_device *cdev;
+
+	/**
+	 * Type of this channel.
+	 * CTC/A or Escon for valid channels.
+	 */
+	enum channel_types type;
+
+	/**
+	 * Misc. flags. See CHANNEL_FLAGS_... below
+	 */
+	__u32 flags;
+
+	/**
+	 * The protocol of this channel
+	 */
+	__u16 protocol;
+
+	/**
+	 * I/O and irq related stuff
+	 */
+	struct ccw1 *ccw;
+	struct irb *irb;
+
+	/**
+	 * RX/TX buffer size
+	 */
+	int max_bufsize;
+
+	/**
+	 * Transmit/Receive buffer.
+	 */
+	struct sk_buff *trans_skb;
+
+	/**
+	 * Universal I/O queue.
+	 */
+	struct sk_buff_head io_queue;
+
+	/**
+	 * TX queue for collecting skb's during busy.
+	 */
+	struct sk_buff_head collect_queue;
+
+	/**
+	 * Amount of data in collect_queue.
+	 */
+	int collect_len;
+
+	/**
+	 * spinlock for collect_queue and collect_len
+	 */
+	spinlock_t collect_lock;
+
+	/**
+	 * Timer for detecting unresposive
+	 * I/O operations.
+	 */
+	fsm_timer timer;
+
+	/**
+	 * Retry counter for misc. operations.
+	 */
+	int retry;
+
+	/**
+	 * The finite state machine of this channel
+	 */
+	fsm_instance *fsm;
+
+	/**
+	 * The corresponding net_device this channel
+	 * belongs to.
+	 */
+	struct net_device *netdev;
+
+	struct ctc_profile prof;
+
+	unsigned char *trans_skb_data;
+
+	__u16 logflags;
+};
+
+#define CHANNEL_FLAGS_READ            0
+#define CHANNEL_FLAGS_WRITE           1
+#define CHANNEL_FLAGS_INUSE           2
+#define CHANNEL_FLAGS_BUFSIZE_CHANGED 4
+#define CHANNEL_FLAGS_FAILED          8
+#define CHANNEL_FLAGS_WAITIRQ        16
+#define CHANNEL_FLAGS_RWMASK 1
+#define CHANNEL_DIRECTION(f) (f & CHANNEL_FLAGS_RWMASK)
+
+#define LOG_FLAG_ILLEGALPKT  1
+#define LOG_FLAG_ILLEGALSIZE 2
+#define LOG_FLAG_OVERRUN     4
+#define LOG_FLAG_NOMEM       8
+
+#define CTC_LOGLEVEL_INFO     1
+#define CTC_LOGLEVEL_NOTICE   2
+#define CTC_LOGLEVEL_WARN     4
+#define CTC_LOGLEVEL_EMERG    8
+#define CTC_LOGLEVEL_ERR     16
+#define CTC_LOGLEVEL_DEBUG   32
+#define CTC_LOGLEVEL_CRIT    64
+
+#define CTC_LOGLEVEL_DEFAULT \
+(CTC_LOGLEVEL_INFO | CTC_LOGLEVEL_NOTICE | CTC_LOGLEVEL_WARN | CTC_LOGLEVEL_CRIT)
+
+#define CTC_LOGLEVEL_MAX     ((CTC_LOGLEVEL_CRIT<<1)-1)
+
+#define ctc_pr_debug(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_DEBUG) printk(KERN_DEBUG fmt,##arg); } while (0)
+
+#define ctc_pr_info(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_INFO) printk(KERN_INFO fmt,##arg); } while (0)
+
+#define ctc_pr_notice(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_NOTICE) printk(KERN_NOTICE fmt,##arg); } while (0)
+
+#define ctc_pr_warn(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_WARN) printk(KERN_WARNING fmt,##arg); } while (0)
+
+#define ctc_pr_emerg(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_EMERG) printk(KERN_EMERG fmt,##arg); } while (0)
+
+#define ctc_pr_err(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_ERR) printk(KERN_ERR fmt,##arg); } while (0)
+
+#define ctc_pr_crit(fmt, arg...) \
+do { if (loglevel & CTC_LOGLEVEL_CRIT) printk(KERN_CRIT fmt,##arg); } while (0)
+
+struct ctc_priv {
+	struct net_device_stats stats;
+	unsigned long tbusy;
+	/**
+	 * The finite state machine of this interface.
+	 */
+	fsm_instance *fsm;
+	/**
+	 * The protocol of this device
+	 */
+	__u16 protocol;
+ 	/**
+ 	 * Timer for restarting after I/O Errors
+ 	 */
+ 	fsm_timer               restart_timer;
+
+	int buffer_size;
+
+	struct channel *channel[2];
+};
+
+/**
+ * Definition of our link level header.
+ */
+struct ll_header {
+	__u16 length;
+	__u16 type;
+	__u16 unused;
+};
+#define LL_HEADER_LENGTH (sizeof(struct ll_header))
+
+/**
+ * Compatibility macros for busy handling
+ * of network devices.
+ */
+static __inline__ void
+ctc_clear_busy(struct net_device * dev)
+{
+	clear_bit(0, &(((struct ctc_priv *) dev->priv)->tbusy));
+	if (((struct ctc_priv *)dev->priv)->protocol != CTC_PROTO_LINUX_TTY)
+		netif_wake_queue(dev);
+}
+
+static __inline__ int
+ctc_test_and_set_busy(struct net_device * dev)
+{
+	if (((struct ctc_priv *)dev->priv)->protocol != CTC_PROTO_LINUX_TTY)
+		netif_stop_queue(dev);
+	return test_and_set_bit(0, &((struct ctc_priv *) dev->priv)->tbusy);
+}
+
+#endif
diff -purN linux-2.6.11/drivers/s390/net/ctctty.c linux-2.6.12-rc6/drivers/s390/net/ctctty.c
--- linux-2.6.11/drivers/s390/net/ctctty.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/ctctty.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: ctctty.c,v 1.26 2004/08/04 11:06:55 mschwide Exp $
+ * $Id: ctctty.c,v 1.29 2005/04/05 08:50:44 mschwide Exp $
  *
  * CTC / ESCON network driver, tty interface.
  *
@@ -778,11 +778,10 @@ ctc_tty_ioctl(struct tty_struct *tty, st
 			printk(KERN_DEBUG "%s%d ioctl TIOCSERGETLSR\n", CTC_TTY_NAME,
 			       info->line);
 #endif
-			error = verify_area(VERIFY_WRITE, (void __user *) arg, sizeof(uint));
-			if (error)
-				return error;
-			else
+			if (access_ok(VERIFY_WRITE, (void __user *) arg, sizeof(uint)))
 				return ctc_tty_get_lsr_info(info, (uint __user *) arg);
+			else
+				return -EFAULT;
 		default:
 #ifdef CTC_DEBUG_MODEM_IOCTL
 			printk(KERN_DEBUG "UNKNOWN ioctl 0x%08x on %s%d\n", cmd,
@@ -1057,8 +1056,7 @@ ctc_tty_close(struct tty_struct *tty, st
 	info->tty = 0;
 	tty->closing = 0;
 	if (info->blocked_open) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ/2);
+		msleep_interruptible(500);
 		wake_up_interruptible(&info->open_wait);
 	}
 	info->flags &= ~(CTC_ASYNC_NORMAL_ACTIVE | CTC_ASYNC_CLOSING);
diff -purN linux-2.6.11/drivers/s390/net/cu3088.c linux-2.6.12-rc6/drivers/s390/net/cu3088.c
--- linux-2.6.11/drivers/s390/net/cu3088.c	2005-03-02 08:37:53.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/cu3088.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Id: cu3088.c,v 1.34 2004/06/15 13:16:27 pavlic Exp $
+ * $Id: cu3088.c,v 1.35 2005/03/30 19:28:52 richtera Exp $
  *
  * CTC / LCS ccw_device driver
  *
@@ -39,6 +39,7 @@ const char *cu3088_type[] = {
 	"FICON channel",
 	"P390 LCS card",
 	"OSA LCS card",
+	"CLAW channel device",
 	"unknown channel type",
 	"unsupported channel type",
 };
@@ -51,6 +52,7 @@ static struct ccw_device_id cu3088_ids[]
 	{ CCW_DEVICE(0x3088, 0x1e), .driver_info = channel_type_ficon },
 	{ CCW_DEVICE(0x3088, 0x01), .driver_info = channel_type_p390 },
 	{ CCW_DEVICE(0x3088, 0x60), .driver_info = channel_type_osa2 },
+	{ CCW_DEVICE(0x3088, 0x61), .driver_info = channel_type_claw },
 	{ /* end of list */ }
 };
 
diff -purN linux-2.6.11/drivers/s390/net/cu3088.h linux-2.6.12-rc6/drivers/s390/net/cu3088.h
--- linux-2.6.11/drivers/s390/net/cu3088.h	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/cu3088.h	2005-06-06 17:22:29.000000000 +0200
@@ -23,6 +23,9 @@ enum channel_types {
 	/* Device is a OSA2 card */
 	channel_type_osa2,
 
+	/* Device is a CLAW channel device */
+	channel_type_claw,
+
 	/* Device is a channel, but we don't know
 	 * anything about it */
 	channel_type_unknown,
diff -purN linux-2.6.11/drivers/s390/net/iucv.c linux-2.6.12-rc6/drivers/s390/net/iucv.c
--- linux-2.6.11/drivers/s390/net/iucv.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/iucv.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,5 +1,5 @@
 /* 
- * $Id: iucv.c,v 1.42 2005/01/07 10:49:54 braunu Exp $
+ * $Id: iucv.c,v 1.45 2005/04/26 22:59:06 braunu Exp $
  *
  * IUCV network driver
  *
@@ -29,7 +29,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.42 $
+ * RELEASE-TAG: IUCV lowlevel driver $Revision: 1.45 $
  *
  */
 
@@ -355,7 +355,7 @@ do { \
 static void
 iucv_banner(void)
 {
-	char vbuf[] = "$Revision: 1.42 $";
+	char vbuf[] = "$Revision: 1.45 $";
 	char *version = vbuf;
 
 	if ((version = strchr(version, ':'))) {
@@ -2525,7 +2525,7 @@ iucv_tasklet_handler(unsigned long ignor
 	return;
 }
 
-module_init(iucv_init);
+subsys_initcall(iucv_init);
 module_exit(iucv_exit);
 
 /**
@@ -2553,12 +2553,12 @@ EXPORT_SYMBOL (iucv_resume);
 #endif
 EXPORT_SYMBOL (iucv_reply_prmmsg);
 EXPORT_SYMBOL (iucv_send);
-#if 0
 EXPORT_SYMBOL (iucv_send2way);
 EXPORT_SYMBOL (iucv_send2way_array);
-EXPORT_SYMBOL (iucv_send_array);
 EXPORT_SYMBOL (iucv_send2way_prmmsg);
 EXPORT_SYMBOL (iucv_send2way_prmmsg_array);
+#if 0
+EXPORT_SYMBOL (iucv_send_array);
 EXPORT_SYMBOL (iucv_send_prmmsg);
 EXPORT_SYMBOL (iucv_setmask);
 #endif
diff -purN linux-2.6.11/drivers/s390/net/Kconfig linux-2.6.12-rc6/drivers/s390/net/Kconfig
--- linux-2.6.11/drivers/s390/net/Kconfig	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/Kconfig	2005-06-06 17:22:29.000000000 +0200
@@ -50,6 +50,15 @@ config SMSGIUCV
 	  Select this option if you want to be able to receive SMSG messages
 	  from other VM guest systems.
 
+config CLAW
+	tristate "CLAW device support"
+	depends on NETDEVICES
+	help
+	  This driver supports channel attached CLAW devices.
+	  CLAW is Common Link Access for Workstation.  Common devices
+          that use CLAW are RS/6000s, Cisco Routers (CIP) and 3172 devices.
+	  To compile as a module choose M here:  The module will be called
+	  claw.ko to compile into the kernel choose Y
 
 config QETH
 	tristate "Gigabit Ethernet device support"
diff -purN linux-2.6.11/drivers/s390/net/lcs.c linux-2.6.12-rc6/drivers/s390/net/lcs.c
--- linux-2.6.11/drivers/s390/net/lcs.c	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/lcs.c	2005-06-06 17:22:29.000000000 +0200
@@ -11,7 +11,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Martin Schwidefsky <schwidefsky@de.ibm.com>
  *
- *    $Revision: 1.96 $	 $Date: 2004/11/11 13:42:33 $
+ *    $Revision: 1.98 $	 $Date: 2005/04/18 13:41:29 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -59,7 +59,7 @@
 /**
  * initialization string for output
  */
-#define VERSION_LCS_C  "$Revision: 1.96 $"
+#define VERSION_LCS_C  "$Revision: 1.98 $"
 
 static char version[] __initdata = "LCS driver ("VERSION_LCS_C "/" VERSION_LCS_H ")";
 static char debug_buffer[255];
@@ -1098,14 +1098,6 @@ lcs_check_multicast_support(struct lcs_c
 		PRINT_ERR("Query IPAssist failed. Assuming unsupported!\n");
 		return -EOPNOTSUPP;
 	}
-	/* Print out supported assists: IPv6 */
-	PRINT_INFO("LCS device %s %s IPv6 support\n", card->dev->name,
-		   (card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?
-		   "with" : "without");
-	/* Print out supported assist: Multicast */
-	PRINT_INFO("LCS device %s %s Multicast support\n", card->dev->name,
-		   (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?
-		   "with" : "without");
 	if (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT)
 		return 0;
 	return -EOPNOTSUPP;
@@ -1160,7 +1152,7 @@ list_modified:
 		}
 	}
 	/* re-insert all entries from the failed_list into ipm_list */
-	list_for_each_entry(ipm, &failed_list, list) {
+	list_for_each_entry_safe(ipm, tmp, &failed_list, list) {
 		list_del_init(&ipm->list);
 		list_add_tail(&ipm->list, &card->ipm_list);
 	}
@@ -2198,30 +2190,39 @@ lcs_new_device(struct ccwgroup_device *c
 	if (!dev)
 		goto out;
 	card->dev = dev;
-netdev_out:
 	card->dev->priv = card;
 	card->dev->open = lcs_open_device;
 	card->dev->stop = lcs_stop_device;
 	card->dev->hard_start_xmit = lcs_start_xmit;
 	card->dev->get_stats = lcs_getstats;
 	SET_MODULE_OWNER(dev);
-	if (lcs_register_netdev(ccwgdev) != 0)
-		goto out;
 	memcpy(card->dev->dev_addr, card->mac, LCS_MAC_LENGTH);
 #ifdef CONFIG_IP_MULTICAST
 	if (!lcs_check_multicast_support(card))
 		card->dev->set_multicast_list = lcs_set_multicast_list;
 #endif
-	netif_stop_queue(card->dev);
+netdev_out:
 	lcs_set_allowed_threads(card,0xffffffff);
 	if (recover_state == DEV_STATE_RECOVER) {
 		lcs_set_multicast_list(card->dev);
 		card->dev->flags |= IFF_UP;
 		netif_wake_queue(card->dev);
 		card->state = DEV_STATE_UP;
-	} else
+	} else {
 		lcs_stopcard(card);
+	}
 
+	if (lcs_register_netdev(ccwgdev) != 0)
+		goto out;
+
+	/* Print out supported assists: IPv6 */
+	PRINT_INFO("LCS device %s %s IPv6 support\n", card->dev->name,
+		   (card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?
+		   "with" : "without");
+	/* Print out supported assist: Multicast */
+	PRINT_INFO("LCS device %s %s Multicast support\n", card->dev->name,
+		   (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?
+		   "with" : "without");
 	return 0;
 out:
 
diff -purN linux-2.6.11/drivers/s390/net/Makefile linux-2.6.12-rc6/drivers/s390/net/Makefile
--- linux-2.6.11/drivers/s390/net/Makefile	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/Makefile	2005-06-06 17:22:29.000000000 +0200
@@ -9,6 +9,7 @@ obj-$(CONFIG_NETIUCV) += netiucv.o fsm.o
 obj-$(CONFIG_SMSGIUCV) += smsgiucv.o
 obj-$(CONFIG_CTC) += ctc.o fsm.o cu3088.o
 obj-$(CONFIG_LCS) += lcs.o cu3088.o
-qeth-y := qeth_main.o qeth_mpc.o qeth_sys.o
+obj-$(CONFIG_CLAW) += claw.o cu3088.o
+qeth-y := qeth_main.o qeth_mpc.o qeth_sys.o qeth_eddp.o 
 qeth-$(CONFIG_PROC_FS) += qeth_proc.o
 obj-$(CONFIG_QETH) += qeth.o
diff -purN linux-2.6.11/drivers/s390/net/qeth_eddp.c linux-2.6.12-rc6/drivers/s390/net/qeth_eddp.c
--- linux-2.6.11/drivers/s390/net/qeth_eddp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_eddp.c	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,632 @@
+/*
+ *
+ * linux/drivers/s390/net/qeth_eddp.c ($Revision: 1.13 $)
+ *
+ * Enhanced Device Driver Packing (EDDP) support for the qeth driver.
+ *
+ * Copyright 2004 IBM Corporation
+ *
+ *    Author(s): Thomas Spatzier <tspat@de.ibm.com>
+ *
+ *    $Revision: 1.13 $	 $Date: 2005/05/04 20:19:18 $
+ *
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/inetdevice.h>
+#include <linux/netdevice.h>
+#include <linux/kernel.h>
+#include <linux/tcp.h>
+#include <net/tcp.h>
+#include <linux/skbuff.h>
+
+#include <net/ip.h>
+
+#include "qeth.h"
+#include "qeth_mpc.h"
+#include "qeth_eddp.h"
+
+int
+qeth_eddp_check_buffers_for_context(struct qeth_qdio_out_q *queue,
+				    struct qeth_eddp_context *ctx)
+{
+	int index = queue->next_buf_to_fill;
+	int elements_needed = ctx->num_elements;
+	int elements_in_buffer;
+	int skbs_in_buffer;
+	int buffers_needed = 0;
+
+	QETH_DBF_TEXT(trace, 5, "eddpcbfc");
+	while(elements_needed > 0) {
+		buffers_needed++;
+		if (atomic_read(&queue->bufs[index].state) !=
+				QETH_QDIO_BUF_EMPTY)
+			return -EBUSY;
+
+		elements_in_buffer = QETH_MAX_BUFFER_ELEMENTS(queue->card) -
+				     queue->bufs[index].next_element_to_fill;
+		skbs_in_buffer = elements_in_buffer / ctx->elements_per_skb;
+		elements_needed -= skbs_in_buffer * ctx->elements_per_skb;
+		index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
+	}
+	return buffers_needed;
+}
+
+static inline void
+qeth_eddp_free_context(struct qeth_eddp_context *ctx)
+{
+	int i;
+
+	QETH_DBF_TEXT(trace, 5, "eddpfctx");
+	for (i = 0; i < ctx->num_pages; ++i)
+		free_page((unsigned long)ctx->pages[i]);
+	kfree(ctx->pages);
+	if (ctx->elements != NULL)
+		kfree(ctx->elements);
+	kfree(ctx);
+}
+
+
+static inline void
+qeth_eddp_get_context(struct qeth_eddp_context *ctx)
+{
+	atomic_inc(&ctx->refcnt);
+}
+
+void
+qeth_eddp_put_context(struct qeth_eddp_context *ctx)
+{
+	if (atomic_dec_return(&ctx->refcnt) == 0)
+		qeth_eddp_free_context(ctx);
+}
+
+void
+qeth_eddp_buf_release_contexts(struct qeth_qdio_out_buffer *buf)
+{
+	struct qeth_eddp_context_reference *ref;
+	
+	QETH_DBF_TEXT(trace, 6, "eddprctx");
+	while (!list_empty(&buf->ctx_list)){
+		ref = list_entry(buf->ctx_list.next,
+				 struct qeth_eddp_context_reference, list);
+		qeth_eddp_put_context(ref->ctx);
+		list_del(&ref->list);
+		kfree(ref);
+	}
+}
+
+static inline int
+qeth_eddp_buf_ref_context(struct qeth_qdio_out_buffer *buf,
+			  struct qeth_eddp_context *ctx)
+{
+	struct qeth_eddp_context_reference *ref;
+
+	QETH_DBF_TEXT(trace, 6, "eddprfcx");
+	ref = kmalloc(sizeof(struct qeth_eddp_context_reference), GFP_ATOMIC);
+	if (ref == NULL)
+		return -ENOMEM;
+	qeth_eddp_get_context(ctx);
+	ref->ctx = ctx;
+	list_add_tail(&ref->list, &buf->ctx_list);
+	return 0;
+}
+
+int
+qeth_eddp_fill_buffer(struct qeth_qdio_out_q *queue,
+		      struct qeth_eddp_context *ctx,
+		      int index)
+{
+	struct qeth_qdio_out_buffer *buf = NULL;
+	struct qdio_buffer *buffer;
+	int elements = ctx->num_elements;
+	int element = 0;
+	int flush_cnt = 0;
+	int must_refcnt = 1;
+	int i;
+
+	QETH_DBF_TEXT(trace, 5, "eddpfibu");
+	while (elements > 0) {
+		buf = &queue->bufs[index];
+		if (atomic_read(&buf->state) != QETH_QDIO_BUF_EMPTY){
+			/* normally this should not happen since we checked for
+			 * available elements in qeth_check_elements_for_context
+			 */
+			if (element == 0)
+				return -EBUSY;
+			else {
+				PRINT_WARN("could only partially fill eddp "
+					   "buffer!\n");
+				goto out;
+			}
+		}		
+		/* check if the whole next skb fits into current buffer */
+		if ((QETH_MAX_BUFFER_ELEMENTS(queue->card) -
+					buf->next_element_to_fill)
+				< ctx->elements_per_skb){
+			/* no -> go to next buffer */
+			atomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);
+			index = (index + 1) % QDIO_MAX_BUFFERS_PER_Q;
+			flush_cnt++;
+			/* new buffer, so we have to add ctx to buffer'ctx_list
+			 * and increment ctx's refcnt */
+			must_refcnt = 1;
+			continue;
+		}	
+		if (must_refcnt){
+			must_refcnt = 0;
+			if (qeth_eddp_buf_ref_context(buf, ctx)){
+				PRINT_WARN("no memory to create eddp context "
+					   "reference\n");
+				goto out_check;
+			}
+		}
+		buffer = buf->buffer;
+		/* fill one skb into buffer */
+		for (i = 0; i < ctx->elements_per_skb; ++i){
+			buffer->element[buf->next_element_to_fill].addr =
+				ctx->elements[element].addr;
+			buffer->element[buf->next_element_to_fill].length =
+				ctx->elements[element].length;
+			buffer->element[buf->next_element_to_fill].flags =
+				ctx->elements[element].flags;
+			buf->next_element_to_fill++;
+			element++;
+			elements--;
+		}
+	}
+out_check:
+	if (!queue->do_pack) {
+		QETH_DBF_TEXT(trace, 6, "fillbfnp");
+		/* set state to PRIMED -> will be flushed */
+		if (buf->next_element_to_fill > 0){
+			atomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);
+			flush_cnt++;
+		}
+	} else {
+#ifdef CONFIG_QETH_PERF_STATS
+		queue->card->perf_stats.skbs_sent_pack++;
+#endif
+		QETH_DBF_TEXT(trace, 6, "fillbfpa");
+		if (buf->next_element_to_fill >=
+				QETH_MAX_BUFFER_ELEMENTS(queue->card)) {
+			/*
+			 * packed buffer if full -> set state PRIMED
+			 * -> will be flushed
+			 */
+			atomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);
+			flush_cnt++;
+		}
+	}
+out:
+	return flush_cnt;
+}
+
+static inline void
+qeth_eddp_create_segment_hdrs(struct qeth_eddp_context *ctx,
+			      struct qeth_eddp_data *eddp, int data_len)
+{
+	u8 *page;
+	int page_remainder;
+	int page_offset;
+	int pkt_len;
+	struct qeth_eddp_element *element;
+
+	QETH_DBF_TEXT(trace, 5, "eddpcrsh");
+	page = ctx->pages[ctx->offset >> PAGE_SHIFT];
+	page_offset = ctx->offset % PAGE_SIZE;
+	element = &ctx->elements[ctx->num_elements];
+	pkt_len = eddp->nhl + eddp->thl + data_len;
+	/* FIXME: layer2 and VLAN !!! */
+	if (eddp->qh.hdr.l2.id == QETH_HEADER_TYPE_LAYER2)
+		pkt_len += ETH_HLEN;
+	if (eddp->mac.h_proto == __constant_htons(ETH_P_8021Q))
+		pkt_len += VLAN_HLEN;
+	/* does complete packet fit in current page ? */
+	page_remainder = PAGE_SIZE - page_offset;
+	if (page_remainder < (sizeof(struct qeth_hdr) + pkt_len)){
+		/* no -> go to start of next page */
+		ctx->offset += page_remainder;
+		page = ctx->pages[ctx->offset >> PAGE_SHIFT];
+		page_offset = 0;
+	}
+	memcpy(page + page_offset, &eddp->qh, sizeof(struct qeth_hdr));
+	element->addr = page + page_offset;
+	element->length = sizeof(struct qeth_hdr);
+	ctx->offset += sizeof(struct qeth_hdr);
+	page_offset += sizeof(struct qeth_hdr);
+	/* add mac header (?) */
+	if (eddp->qh.hdr.l2.id == QETH_HEADER_TYPE_LAYER2){
+		memcpy(page + page_offset, &eddp->mac, ETH_HLEN);
+		element->length += ETH_HLEN;
+		ctx->offset += ETH_HLEN;
+		page_offset += ETH_HLEN;
+	}
+	/* add VLAN tag */
+	if (eddp->mac.h_proto == __constant_htons(ETH_P_8021Q)){
+		memcpy(page + page_offset, &eddp->vlan, VLAN_HLEN);
+		element->length += VLAN_HLEN;
+		ctx->offset += VLAN_HLEN;
+		page_offset += VLAN_HLEN;
+	}
+	/* add network header */
+	memcpy(page + page_offset, (u8 *)&eddp->nh, eddp->nhl);
+	element->length += eddp->nhl;
+	eddp->nh_in_ctx = page + page_offset;
+	ctx->offset += eddp->nhl;
+	page_offset += eddp->nhl;
+	/* add transport header */
+	memcpy(page + page_offset, (u8 *)&eddp->th, eddp->thl);
+	element->length += eddp->thl;
+	eddp->th_in_ctx = page + page_offset;
+	ctx->offset += eddp->thl;
+}
+
+static inline void
+qeth_eddp_copy_data_tcp(char *dst, struct qeth_eddp_data *eddp, int len,
+			u32 *hcsum)
+{
+	struct skb_frag_struct *frag;
+	int left_in_frag;
+	int copy_len;
+	u8 *src;
+	
+	QETH_DBF_TEXT(trace, 5, "eddpcdtc");
+	if (skb_shinfo(eddp->skb)->nr_frags == 0) {
+		memcpy(dst, eddp->skb->data + eddp->skb_offset, len);
+		*hcsum = csum_partial(eddp->skb->data + eddp->skb_offset, len,
+				      *hcsum);
+		eddp->skb_offset += len;
+	} else {
+		while (len > 0) {
+			if (eddp->frag < 0) {
+				/* we're in skb->data */
+				left_in_frag = (eddp->skb->len - eddp->skb->data_len)
+						- eddp->skb_offset;
+				src = eddp->skb->data + eddp->skb_offset;
+			} else {
+				frag = &skb_shinfo(eddp->skb)->
+					frags[eddp->frag];
+				left_in_frag = frag->size - eddp->frag_offset;
+				src = (u8 *)(
+					(page_to_pfn(frag->page) << PAGE_SHIFT)+
+					frag->page_offset + eddp->frag_offset);
+			}
+			if (left_in_frag <= 0) {
+				eddp->frag++;
+				eddp->frag_offset = 0;
+				continue;
+			}
+			copy_len = min(left_in_frag, len);
+			memcpy(dst, src, copy_len);
+			*hcsum = csum_partial(src, copy_len, *hcsum);
+			dst += copy_len;
+			eddp->frag_offset += copy_len;
+			eddp->skb_offset += copy_len;
+			len -= copy_len;
+		}
+	}
+}
+
+static inline void
+qeth_eddp_create_segment_data_tcp(struct qeth_eddp_context *ctx,
+				  struct qeth_eddp_data *eddp, int data_len,
+				  u32 hcsum)
+{
+	u8 *page;
+	int page_remainder;
+	int page_offset;
+	struct qeth_eddp_element *element;
+	int first_lap = 1;
+
+	QETH_DBF_TEXT(trace, 5, "eddpcsdt");
+	page = ctx->pages[ctx->offset >> PAGE_SHIFT];
+	page_offset = ctx->offset % PAGE_SIZE;
+	element = &ctx->elements[ctx->num_elements];
+	while (data_len){
+		page_remainder = PAGE_SIZE - page_offset;
+		if (page_remainder < data_len){
+			qeth_eddp_copy_data_tcp(page + page_offset, eddp,
+						page_remainder, &hcsum);
+			element->length += page_remainder;
+			if (first_lap)
+				element->flags = SBAL_FLAGS_FIRST_FRAG;
+			else
+				element->flags = SBAL_FLAGS_MIDDLE_FRAG;
+			ctx->num_elements++;
+			element++;
+			data_len -= page_remainder;
+			ctx->offset += page_remainder;
+			page = ctx->pages[ctx->offset >> PAGE_SHIFT];
+			page_offset = 0;
+			element->addr = page + page_offset;
+		} else {
+			qeth_eddp_copy_data_tcp(page + page_offset, eddp,
+						data_len, &hcsum);
+			element->length += data_len;
+			if (!first_lap)
+				element->flags = SBAL_FLAGS_LAST_FRAG;
+			ctx->num_elements++;
+			ctx->offset += data_len;
+			data_len = 0;
+		}
+		first_lap = 0;
+	}
+	((struct tcphdr *)eddp->th_in_ctx)->check = csum_fold(hcsum);
+}
+
+static inline u32
+qeth_eddp_check_tcp4_hdr(struct qeth_eddp_data *eddp, int data_len)
+{
+	u32 phcsum; /* pseudo header checksum */
+
+	QETH_DBF_TEXT(trace, 5, "eddpckt4");
+	eddp->th.tcp.h.check = 0;
+	/* compute pseudo header checksum */
+	phcsum = csum_tcpudp_nofold(eddp->nh.ip4.h.saddr, eddp->nh.ip4.h.daddr,
+				    eddp->thl + data_len, IPPROTO_TCP, 0);
+	/* compute checksum of tcp header */
+	return csum_partial((u8 *)&eddp->th, eddp->thl, phcsum);
+}
+
+static inline u32
+qeth_eddp_check_tcp6_hdr(struct qeth_eddp_data *eddp, int data_len)
+{
+	u32 proto;
+	u32 phcsum; /* pseudo header checksum */
+
+	QETH_DBF_TEXT(trace, 5, "eddpckt6");
+	eddp->th.tcp.h.check = 0;
+	/* compute pseudo header checksum */
+	phcsum = csum_partial((u8 *)&eddp->nh.ip6.h.saddr,
+			      sizeof(struct in6_addr), 0);
+	phcsum = csum_partial((u8 *)&eddp->nh.ip6.h.daddr,
+			      sizeof(struct in6_addr), phcsum);
+	proto = htonl(IPPROTO_TCP);
+	phcsum = csum_partial((u8 *)&proto, sizeof(u32), phcsum);
+	return phcsum;
+}
+
+static inline struct qeth_eddp_data *
+qeth_eddp_create_eddp_data(struct qeth_hdr *qh, u8 *nh, u8 nhl, u8 *th, u8 thl)
+{
+	struct qeth_eddp_data *eddp;
+
+	QETH_DBF_TEXT(trace, 5, "eddpcrda");
+	eddp = kmalloc(sizeof(struct qeth_eddp_data), GFP_ATOMIC);
+	if (eddp){
+		memset(eddp, 0, sizeof(struct qeth_eddp_data));
+		eddp->nhl = nhl;
+		eddp->thl = thl;
+		memcpy(&eddp->qh, qh, sizeof(struct qeth_hdr));
+		memcpy(&eddp->nh, nh, nhl);
+		memcpy(&eddp->th, th, thl);
+		eddp->frag = -1; /* initially we're in skb->data */
+	}
+	return eddp;
+}
+
+static inline void
+__qeth_eddp_fill_context_tcp(struct qeth_eddp_context *ctx,
+			     struct qeth_eddp_data *eddp)
+{
+	struct tcphdr *tcph;
+	int data_len;
+	u32 hcsum;
+	
+	QETH_DBF_TEXT(trace, 5, "eddpftcp");
+	eddp->skb_offset = sizeof(struct qeth_hdr) + eddp->nhl + eddp->thl;
+	tcph = eddp->skb->h.th;
+	while (eddp->skb_offset < eddp->skb->len) {
+		data_len = min((int)skb_shinfo(eddp->skb)->tso_size,
+			       (int)(eddp->skb->len - eddp->skb_offset));
+		/* prepare qdio hdr */
+		if (eddp->qh.hdr.l2.id == QETH_HEADER_TYPE_LAYER2){
+			eddp->qh.hdr.l2.pkt_length = data_len + ETH_HLEN +
+						     eddp->nhl + eddp->thl -
+						     sizeof(struct qeth_hdr);
+#ifdef CONFIG_QETH_VLAN
+			if (eddp->mac.h_proto == __constant_htons(ETH_P_8021Q))
+				eddp->qh.hdr.l2.pkt_length += VLAN_HLEN;
+#endif /* CONFIG_QETH_VLAN */
+		} else
+			eddp->qh.hdr.l3.length = data_len + eddp->nhl +
+						 eddp->thl;
+		/* prepare ip hdr */
+		if (eddp->skb->protocol == ETH_P_IP){
+			eddp->nh.ip4.h.tot_len = data_len + eddp->nhl +
+						 eddp->thl;
+			eddp->nh.ip4.h.check = 0;
+			eddp->nh.ip4.h.check =
+				ip_fast_csum((u8 *)&eddp->nh.ip4.h,
+						eddp->nh.ip4.h.ihl);
+		} else
+			eddp->nh.ip6.h.payload_len = data_len + eddp->thl;
+		/* prepare tcp hdr */
+		if (data_len == (eddp->skb->len - eddp->skb_offset)){
+			/* last segment -> set FIN and PSH flags */
+			eddp->th.tcp.h.fin = tcph->fin;
+			eddp->th.tcp.h.psh = tcph->psh;
+		}
+		if (eddp->skb->protocol == ETH_P_IP)
+			hcsum = qeth_eddp_check_tcp4_hdr(eddp, data_len);
+		else
+			hcsum = qeth_eddp_check_tcp6_hdr(eddp, data_len);
+		/* fill the next segment into the context */
+		qeth_eddp_create_segment_hdrs(ctx, eddp, data_len);
+		qeth_eddp_create_segment_data_tcp(ctx, eddp, data_len, hcsum);
+		if (eddp->skb_offset >= eddp->skb->len)
+			break;
+		/* prepare headers for next round */
+		if (eddp->skb->protocol == ETH_P_IP)
+			eddp->nh.ip4.h.id++;
+		eddp->th.tcp.h.seq += data_len;
+	}
+}
+			   
+static inline int
+qeth_eddp_fill_context_tcp(struct qeth_eddp_context *ctx,
+			   struct sk_buff *skb, struct qeth_hdr *qhdr)
+{
+	struct qeth_eddp_data *eddp = NULL;
+	
+	QETH_DBF_TEXT(trace, 5, "eddpficx");
+	/* create our segmentation headers and copy original headers */
+	if (skb->protocol == ETH_P_IP)
+		eddp = qeth_eddp_create_eddp_data(qhdr, (u8 *)skb->nh.iph,
+				skb->nh.iph->ihl*4,
+				(u8 *)skb->h.th, skb->h.th->doff*4);
+	else
+		eddp = qeth_eddp_create_eddp_data(qhdr, (u8 *)skb->nh.ipv6h,
+				sizeof(struct ipv6hdr),
+				(u8 *)skb->h.th, skb->h.th->doff*4);
+
+	if (eddp == NULL) {
+		QETH_DBF_TEXT(trace, 2, "eddpfcnm");
+		return -ENOMEM;
+	}
+	if (qhdr->hdr.l2.id == QETH_HEADER_TYPE_LAYER2) {
+		memcpy(&eddp->mac, eth_hdr(skb), ETH_HLEN);
+#ifdef CONFIG_QETH_VLAN
+		if (eddp->mac.h_proto == __constant_htons(ETH_P_8021Q)) {
+			eddp->vlan[0] = __constant_htons(skb->protocol);
+			eddp->vlan[1] = htons(vlan_tx_tag_get(skb));
+		}
+#endif /* CONFIG_QETH_VLAN */
+	}
+	/* the next flags will only be set on the last segment */
+	eddp->th.tcp.h.fin = 0;
+	eddp->th.tcp.h.psh = 0;
+	eddp->skb = skb;
+	/* begin segmentation and fill context */
+	__qeth_eddp_fill_context_tcp(ctx, eddp);
+	kfree(eddp);
+	return 0;
+}
+
+static inline void
+qeth_eddp_calc_num_pages(struct qeth_eddp_context *ctx, struct sk_buff *skb,
+			 int hdr_len)
+{
+	int skbs_per_page;
+	
+	QETH_DBF_TEXT(trace, 5, "eddpcanp");
+	/* can we put multiple skbs in one page? */
+	skbs_per_page = PAGE_SIZE / (skb_shinfo(skb)->tso_size + hdr_len);
+	if (skbs_per_page > 1){
+		ctx->num_pages = (skb_shinfo(skb)->tso_segs + 1) /
+				 skbs_per_page + 1;
+		ctx->elements_per_skb = 1;
+	} else {
+		/* no -> how many elements per skb? */
+		ctx->elements_per_skb = (skb_shinfo(skb)->tso_size + hdr_len +
+				     PAGE_SIZE) >> PAGE_SHIFT;
+		ctx->num_pages = ctx->elements_per_skb *
+				 (skb_shinfo(skb)->tso_segs + 1);
+	}
+	ctx->num_elements = ctx->elements_per_skb *
+			    (skb_shinfo(skb)->tso_segs + 1);
+}
+
+static inline struct qeth_eddp_context *
+qeth_eddp_create_context_generic(struct qeth_card *card, struct sk_buff *skb,
+				 int hdr_len)
+{
+	struct qeth_eddp_context *ctx = NULL;
+	u8 *addr;
+	int i;
+
+	QETH_DBF_TEXT(trace, 5, "creddpcg");
+	/* create the context and allocate pages */
+	ctx = kmalloc(sizeof(struct qeth_eddp_context), GFP_ATOMIC);
+	if (ctx == NULL){
+		QETH_DBF_TEXT(trace, 2, "ceddpcn1");
+		return NULL;
+	}
+	memset(ctx, 0, sizeof(struct qeth_eddp_context));
+	ctx->type = QETH_LARGE_SEND_EDDP;
+	qeth_eddp_calc_num_pages(ctx, skb, hdr_len);
+	if (ctx->elements_per_skb > QETH_MAX_BUFFER_ELEMENTS(card)){
+		QETH_DBF_TEXT(trace, 2, "ceddpcis");
+		kfree(ctx);
+		return NULL;
+	}
+	ctx->pages = kmalloc(ctx->num_pages * sizeof(u8 *), GFP_ATOMIC);
+	if (ctx->pages == NULL){
+		QETH_DBF_TEXT(trace, 2, "ceddpcn2");
+		kfree(ctx);
+		return NULL;
+	}
+	memset(ctx->pages, 0, ctx->num_pages * sizeof(u8 *));
+	for (i = 0; i < ctx->num_pages; ++i){
+		addr = (u8 *)__get_free_page(GFP_ATOMIC);
+		if (addr == NULL){
+			QETH_DBF_TEXT(trace, 2, "ceddpcn3");
+			ctx->num_pages = i;
+			qeth_eddp_free_context(ctx);
+			return NULL;
+		}
+		memset(addr, 0, PAGE_SIZE);
+		ctx->pages[i] = addr;
+	}
+	ctx->elements = kmalloc(ctx->num_elements *
+				sizeof(struct qeth_eddp_element), GFP_ATOMIC);
+	if (ctx->elements == NULL){
+		QETH_DBF_TEXT(trace, 2, "ceddpcn4");
+		qeth_eddp_free_context(ctx);
+		return NULL;
+	}
+	memset(ctx->elements, 0,
+	       ctx->num_elements * sizeof(struct qeth_eddp_element));
+	/* reset num_elements; will be incremented again in fill_buffer to
+	 * reflect number of actually used elements */
+	ctx->num_elements = 0;
+	return ctx;
+}
+
+static inline struct qeth_eddp_context *
+qeth_eddp_create_context_tcp(struct qeth_card *card, struct sk_buff *skb,
+			     struct qeth_hdr *qhdr)
+{
+	struct qeth_eddp_context *ctx = NULL;
+	
+	QETH_DBF_TEXT(trace, 5, "creddpct");
+	if (skb->protocol == ETH_P_IP)
+		ctx = qeth_eddp_create_context_generic(card, skb,
+			sizeof(struct qeth_hdr) + skb->nh.iph->ihl*4 +
+			skb->h.th->doff*4);
+	else if (skb->protocol == ETH_P_IPV6)
+		ctx = qeth_eddp_create_context_generic(card, skb,
+			sizeof(struct qeth_hdr) + sizeof(struct ipv6hdr) +
+			skb->h.th->doff*4);
+	else
+		QETH_DBF_TEXT(trace, 2, "cetcpinv");
+
+	if (ctx == NULL) {
+		QETH_DBF_TEXT(trace, 2, "creddpnl");
+		return NULL;
+	}
+	if (qeth_eddp_fill_context_tcp(ctx, skb, qhdr)){
+		QETH_DBF_TEXT(trace, 2, "ceddptfe");
+		qeth_eddp_free_context(ctx);
+		return NULL;
+	}
+	atomic_set(&ctx->refcnt, 1);
+	return ctx;
+}
+
+struct qeth_eddp_context *
+qeth_eddp_create_context(struct qeth_card *card, struct sk_buff *skb,
+			 struct qeth_hdr *qhdr)
+{
+	QETH_DBF_TEXT(trace, 5, "creddpc");
+	switch (skb->sk->sk_protocol){
+	case IPPROTO_TCP:
+		return qeth_eddp_create_context_tcp(card, skb, qhdr);
+	default:
+		QETH_DBF_TEXT(trace, 2, "eddpinvp");
+	}
+	return NULL;
+}
+
+
diff -purN linux-2.6.11/drivers/s390/net/qeth_eddp.h linux-2.6.12-rc6/drivers/s390/net/qeth_eddp.h
--- linux-2.6.11/drivers/s390/net/qeth_eddp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_eddp.h	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+ * linux/drivers/s390/net/qeth_eddp.c ($Revision: 1.5 $)
+ *
+ * Header file for qeth enhanced device driver pakcing.
+ *
+ * Copyright 2004 IBM Corporation
+ *
+ *    Author(s): Thomas Spatzier <tspat@de.ibm.com>
+ *
+ *    $Revision: 1.5 $	 $Date: 2005/03/24 09:04:18 $
+ *
+ */
+#ifndef __QETH_EDDP_H__
+#define __QETH_EDDP_H__
+
+struct qeth_eddp_element {
+	u32 flags;
+	u32 length;
+	void *addr;
+};
+
+struct qeth_eddp_context {
+	atomic_t refcnt;
+	enum qeth_large_send_types type;
+	int num_pages;			    /* # of allocated pages */
+	u8 **pages;			    /* pointers to pages */
+	int offset;			    /* offset in ctx during creation */
+	int num_elements;		    /* # of required 'SBALEs' */
+	struct qeth_eddp_element *elements; /* array of 'SBALEs' */
+	int elements_per_skb;		    /* # of 'SBALEs' per skb **/
+};
+
+struct qeth_eddp_context_reference {
+	struct list_head list;
+	struct qeth_eddp_context *ctx;
+};
+
+extern struct qeth_eddp_context *
+qeth_eddp_create_context(struct qeth_card *,struct sk_buff *,struct qeth_hdr *);
+
+extern void
+qeth_eddp_put_context(struct qeth_eddp_context *);
+
+extern int
+qeth_eddp_fill_buffer(struct qeth_qdio_out_q *,struct qeth_eddp_context *,int);
+
+extern void
+qeth_eddp_buf_release_contexts(struct qeth_qdio_out_buffer *);
+
+extern int
+qeth_eddp_check_buffers_for_context(struct qeth_qdio_out_q *,
+				    struct qeth_eddp_context *);
+/*
+ * Data used for fragmenting a IP packet.
+ */
+struct qeth_eddp_data {
+	struct qeth_hdr qh;
+	struct ethhdr mac;
+	u16 vlan[2];
+	union {
+		struct {
+			struct iphdr h;
+			u8 options[40];
+		} ip4;
+		struct {
+			struct ipv6hdr h;
+		} ip6;
+	} nh;
+	u8 nhl;
+	void *nh_in_ctx;	/* address of nh within the ctx */
+	union {
+		struct {
+			struct tcphdr h;
+			u8 options[40];
+		} tcp;
+	} th;
+	u8 thl;
+	void *th_in_ctx;	/* address of th within the ctx */
+	struct sk_buff *skb;
+	int skb_offset;
+	int frag;
+	int frag_offset;
+} __attribute__ ((packed));
+
+#endif /* __QETH_EDDP_H__ */
diff -purN linux-2.6.11/drivers/s390/net/qeth.h linux-2.6.12-rc6/drivers/s390/net/qeth.h
--- linux-2.6.11/drivers/s390/net/qeth.h	2005-03-02 08:37:31.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth.h	2005-06-06 17:22:29.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "qeth_mpc.h"
 
-#define VERSION_QETH_H 		"$Revision: 1.132 $"
+#define VERSION_QETH_H 		"$Revision: 1.139 $"
 
 #ifdef CONFIG_QETH_IPV6
 #define QETH_VERSION_IPV6 	":IPv6"
@@ -68,7 +68,8 @@
 #define QETH_DBF_TRACE_LEN 8
 #define QETH_DBF_TRACE_INDEX 2
 #define QETH_DBF_TRACE_NR_AREAS 2
-#define QETH_DBF_TRACE_LEVEL 5
+#define QETH_DBF_TRACE_LEVEL 3
+extern debug_info_t *qeth_dbf_trace;
 
 #define QETH_DBF_SENSE_NAME "qeth_sense"
 #define QETH_DBF_SENSE_LEN 64
@@ -206,6 +207,11 @@ struct qeth_perf_stats {
 	__u64 outbound_do_qdio_start_time;
 	unsigned int outbound_do_qdio_cnt;
 	unsigned int outbound_do_qdio_time;
+	/* eddp data */
+	unsigned int large_send_bytes;
+	unsigned int large_send_cnt;
+	unsigned int sg_skbs_sent;
+	unsigned int sg_frags_sent;
 };
 #endif /* CONFIG_QETH_PERF_STATS */
 
@@ -282,7 +288,8 @@ qeth_is_ipa_enabled(struct qeth_ipa_info
 #define QETH_TX_TIMEOUT		100 * HZ
 #define QETH_HEADER_SIZE	32
 #define MAX_PORTNO 		15
-#define QETH_FAKE_LL_LEN 	ETH_HLEN
+#define QETH_FAKE_LL_LEN_ETH	ETH_HLEN
+#define QETH_FAKE_LL_LEN_TR	(sizeof(struct trh_hdr)-TR_MAXRIFLEN+sizeof(struct trllc))
 #define QETH_FAKE_LL_V6_ADDR_POS 24
 
 /*IPv6 address autoconfiguration stuff*/
@@ -334,8 +341,8 @@ qeth_is_ipa_enabled(struct qeth_ipa_info
 struct qeth_hdr_layer3 {
 	__u8  id;
 	__u8  flags;
-	__u16 inbound_checksum;
-	__u32 token;
+	__u16 inbound_checksum; /*TSO:__u16 seqno */
+	__u32 token;		/*TSO: __u32 reserved */
 	__u16 length;
 	__u8  vlan_prio;
 	__u8  ext_flags;
@@ -363,6 +370,25 @@ struct qeth_hdr {
 	} hdr;
 } __attribute__ ((packed));
 
+/*TCP Segmentation Offload header*/
+struct qeth_hdr_ext_tso {
+        __u16 hdr_tot_len;
+        __u8  imb_hdr_no;
+        __u8  reserved;
+        __u8  hdr_type;
+        __u8  hdr_version;
+        __u16 hdr_len;
+        __u32 payload_len;
+        __u16 mss;
+        __u16 dg_hdr_len;
+        __u8  padding[16];
+} __attribute__ ((packed));
+
+struct qeth_hdr_tso {
+        struct qeth_hdr hdr; 	/*hdr->hdr.l3.xxx*/
+	struct qeth_hdr_ext_tso ext;
+} __attribute__ ((packed));
+
 
 /* flags for qeth_hdr.flags */
 #define QETH_HDR_PASSTHRU 0x10
@@ -386,6 +412,7 @@ enum qeth_layer2_frame_flags {
 enum qeth_header_ids {
 	QETH_HEADER_TYPE_LAYER3 = 0x01,
 	QETH_HEADER_TYPE_LAYER2 = 0x02,
+	QETH_HEADER_TYPE_TSO	= 0x03,
 };
 /* flags for qeth_hdr.ext_flags */
 #define QETH_HDR_EXT_VLAN_FRAME       0x01
@@ -394,6 +421,7 @@ enum qeth_header_ids {
 #define QETH_HDR_EXT_SRC_MAC_ADDR     0x08
 #define QETH_HDR_EXT_CSUM_HDR_REQ     0x10
 #define QETH_HDR_EXT_CSUM_TRANSP_REQ  0x20
+#define QETH_HDR_EXT_UDP_TSO          0x40 /*bit off for TCP*/
 
 static inline int
 qeth_is_last_sbale(struct qdio_buffer_element *sbale)
@@ -448,11 +476,19 @@ struct qeth_qdio_q {
 	volatile int next_buf_to_init;
 } __attribute__ ((aligned(256)));
 
+/* possible types of qeth large_send support */
+enum qeth_large_send_types {
+	QETH_LARGE_SEND_NO,
+	QETH_LARGE_SEND_EDDP,
+	QETH_LARGE_SEND_TSO,
+};
+
 struct qeth_qdio_out_buffer {
 	struct qdio_buffer *buffer;
 	atomic_t state;
 	volatile int next_element_to_fill;
 	struct sk_buff_head skb_list;
+	struct list_head ctx_list;
 };
 
 struct qeth_card;
@@ -668,6 +704,14 @@ struct qeth_reply {
 #define QETH_BROADCAST_WITH_ECHO    1
 #define QETH_BROADCAST_WITHOUT_ECHO 2
 
+struct qeth_card_blkt {
+	int time_total;
+	int inter_packet;
+	int inter_packet_jumbo;
+};
+
+
+
 struct qeth_card_info {
 	unsigned short unit_addr2;
 	unsigned short cula;
@@ -686,6 +730,7 @@ struct qeth_card_info {
 	int max_mtu;
 	int broadcast_capable;
 	int unique_id;
+	struct qeth_card_blkt blkt;
 	__u32 csum_mask;
 };
 
@@ -704,6 +749,7 @@ struct qeth_card_options {
 	int add_hhlen;
 	int fake_ll;
 	int layer2;
+	enum qeth_large_send_types large_send;
 };
 
 /*
@@ -790,25 +836,77 @@ qeth_get_ipa_adp_type(enum qeth_link_typ
 }
 
 inline static int
+qeth_realloc_headroom(struct qeth_card *card, struct sk_buff **skb, int size)
+{
+	struct sk_buff *new_skb = NULL;
+
+	if (skb_headroom(*skb) < size){
+		new_skb = skb_realloc_headroom(*skb, size);
+		if (!new_skb) {
+                        PRINT_ERR("qeth_prepare_skb: could "
+                                  "not realloc headroom for qeth_hdr "
+                                  "on interface %s", QETH_CARD_IFNAME(card));
+                        return -ENOMEM;
+                }
+                *skb = new_skb;
+	}
+	return 0;
+}
+static inline struct sk_buff *
+qeth_pskb_unshare(struct sk_buff *skb, int pri)
+{
+        struct sk_buff *nskb;
+        if (!skb_cloned(skb))
+                return skb;
+        nskb = skb_copy(skb, pri);
+        kfree_skb(skb); /* free our shared copy */
+        return nskb;
+}
+
+
+inline static void *
+qeth_push_skb(struct qeth_card *card, struct sk_buff **skb, int size)
+{
+        void *hdr;
+
+	hdr = (void *) skb_push(*skb, size);
+        /*
+         * sanity check, the Linux memory allocation scheme should
+         * never present us cases like this one (the qdio header size plus
+         * the first 40 bytes of the paket cross a 4k boundary)
+         */
+        if ((((unsigned long) hdr) & (~(PAGE_SIZE - 1))) !=
+            (((unsigned long) hdr + size +
+              QETH_IP_HEADER_SIZE) & (~(PAGE_SIZE - 1)))) {
+                PRINT_ERR("qeth_prepare_skb: misaligned "
+                          "packet on interface %s. Discarded.",
+                          QETH_CARD_IFNAME(card));
+                return NULL;
+        }
+        return hdr;
+}
+
+
+inline static int
 qeth_get_hlen(__u8 link_type)
 {
 #ifdef CONFIG_QETH_IPV6
 	switch (link_type) {
 	case QETH_LINK_TYPE_HSTR:
 	case QETH_LINK_TYPE_LANE_TR:
-		return sizeof(struct qeth_hdr) + TR_HLEN;
+		return sizeof(struct qeth_hdr_tso) + TR_HLEN;
 	default:
 #ifdef CONFIG_QETH_VLAN
-		return sizeof(struct qeth_hdr) + VLAN_ETH_HLEN;
+		return sizeof(struct qeth_hdr_tso) + VLAN_ETH_HLEN;
 #else
-		return sizeof(struct qeth_hdr) + ETH_HLEN;
+		return sizeof(struct qeth_hdr_tso) + ETH_HLEN;
 #endif
 	}
 #else  /* CONFIG_QETH_IPV6 */
 #ifdef CONFIG_QETH_VLAN
-	return sizeof(struct qeth_hdr) + VLAN_HLEN;
+	return sizeof(struct qeth_hdr_tso) + VLAN_HLEN;
 #else
-	return sizeof(struct qeth_hdr);
+	return sizeof(struct qeth_hdr_tso);
 #endif
 #endif /* CONFIG_QETH_IPV6 */
 }
@@ -830,17 +928,6 @@ qeth_get_netdev_flags(struct qeth_card *
 #endif
 	}
 }
-static inline struct sk_buff *
-qeth_pskb_unshare(struct sk_buff *skb, int pri)
-{
-        struct sk_buff *nskb;
-        if (!skb_cloned(skb))
-                return skb;
-        nskb = skb_copy(skb, pri);
-        kfree_skb(skb); /* free our shared copy */
-        return nskb;
-}
-
 
 inline static int
 qeth_get_initial_mtu_for_card(struct qeth_card * card)
@@ -1084,4 +1171,13 @@ qeth_schedule_recovery(struct qeth_card 
 extern int
 qeth_realloc_buffer_pool(struct qeth_card *, int);
 
+extern int
+qeth_set_large_send(struct qeth_card *);
+
+extern void
+qeth_fill_header(struct qeth_card *, struct qeth_hdr *,
+		 struct sk_buff *, int, int);
+extern void
+qeth_flush_buffers(struct qeth_qdio_out_q *, int, int, int);
+
 #endif /* __QETH_H__ */
diff -purN linux-2.6.11/drivers/s390/net/qeth_main.c linux-2.6.12-rc6/drivers/s390/net/qeth_main.c
--- linux-2.6.11/drivers/s390/net/qeth_main.c	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_main.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_main.c ($Revision: 1.191 $)
+ * linux/drivers/s390/net/qeth_main.c ($Revision: 1.214 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  *
@@ -12,7 +12,7 @@
  *			  Frank Pavlic (pavlic@de.ibm.com) and
  *		 	  Thomas Spatzier <tspat@de.ibm.com>
  *
- *    $Revision: 1.191 $	 $Date: 2005/01/31 13:13:57 $
+ *    $Revision: 1.214 $	 $Date: 2005/05/04 20:19:18 $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -61,6 +61,7 @@ qeth_eyecatcher(void)
 #include <linux/reboot.h>
 #include <linux/mii.h>
 #include <linux/rcupdate.h>
+#include <linux/ethtool.h>
 
 #include <net/arp.h>
 #include <net/ip.h>
@@ -76,8 +77,10 @@ qeth_eyecatcher(void)
 #include "qeth.h"
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
+#include "qeth_eddp.h"
+#include "qeth_tso.h"
 
-#define VERSION_QETH_C "$Revision: 1.191 $"
+#define VERSION_QETH_C "$Revision: 1.214 $"
 static const char *version = "qeth S/390 OSA-Express driver";
 
 /**
@@ -87,7 +90,7 @@ static debug_info_t *qeth_dbf_setup = NU
 static debug_info_t *qeth_dbf_data = NULL;
 static debug_info_t *qeth_dbf_misc = NULL;
 static debug_info_t *qeth_dbf_control = NULL;
-static debug_info_t *qeth_dbf_trace = NULL;
+debug_info_t *qeth_dbf_trace = NULL;
 static debug_info_t *qeth_dbf_sense = NULL;
 static debug_info_t *qeth_dbf_qerr = NULL;
 
@@ -155,6 +158,9 @@ qeth_irq_tasklet(unsigned long);
 static int
 qeth_set_online(struct ccwgroup_device *);
 
+static int
+__qeth_set_online(struct ccwgroup_device *gdev, int recovery_mode);
+
 static struct qeth_ipaddr *
 qeth_get_addr_buffer(enum qeth_prot_versions);
 
@@ -507,10 +513,10 @@ qeth_irq_tasklet(unsigned long data)
 	wake_up(&card->wait_q);
 }
 
-static int qeth_stop_card(struct qeth_card *);
+static int qeth_stop_card(struct qeth_card *, int);
 
 static int
-qeth_set_offline(struct ccwgroup_device *cgdev)
+__qeth_set_offline(struct ccwgroup_device *cgdev, int recovery_mode)
 {
 	struct qeth_card *card = (struct qeth_card *) cgdev->dev.driver_data;
 	int rc = 0;
@@ -520,7 +526,7 @@ qeth_set_offline(struct ccwgroup_device 
 	QETH_DBF_HEX(setup, 3, &card, sizeof(void *));
 
 	recover_flag = card->state;
-	if (qeth_stop_card(card) == -ERESTARTSYS){
+	if (qeth_stop_card(card, recovery_mode) == -ERESTARTSYS){
 		PRINT_WARN("Stopping card %s interrupted by user!\n",
 			   CARD_BUS_ID(card));
 		return -ERESTARTSYS;
@@ -537,6 +543,12 @@ qeth_set_offline(struct ccwgroup_device 
 }
 
 static int
+qeth_set_offline(struct ccwgroup_device *cgdev)
+{
+	return  __qeth_set_offline(cgdev, 0);
+}
+
+static int
 qeth_wait_for_threads(struct qeth_card *card, unsigned long threads);
 
 
@@ -950,8 +962,8 @@ qeth_recover(void *ptr)
 	PRINT_WARN("Recovery of device %s started ...\n",
 		   CARD_BUS_ID(card));
 	card->use_hard_stop = 1;
-	qeth_set_offline(card->gdev);
-	rc = qeth_set_online(card->gdev);
+	__qeth_set_offline(card->gdev,1);
+	rc = __qeth_set_online(card->gdev,1);
 	if (!rc)
 		PRINT_INFO("Device %s successfully recovered!\n",
 			   CARD_BUS_ID(card));
@@ -1071,6 +1083,35 @@ qeth_setup_card(struct qeth_card *card)
 }
 
 static int
+is_1920_device (struct qeth_card *card)
+{
+	int single_queue = 0;
+	struct ccw_device *ccwdev;
+	struct channelPath_dsc {
+		u8 flags;
+		u8 lsn;
+		u8 desc;
+		u8 chpid;
+		u8 swla;
+		u8 zeroes;
+		u8 chla;
+		u8 chpp;
+	} *chp_dsc;
+
+	QETH_DBF_TEXT(setup, 2, "chk_1920");
+
+	ccwdev = card->data.ccwdev;
+	chp_dsc = (struct channelPath_dsc *)ccw_device_get_chp_desc(ccwdev, 0);
+	if (chp_dsc != NULL) {
+		/* CHPP field bit 6 == 1 -> single queue */
+		single_queue = ((chp_dsc->chpp & 0x02) == 0x02);
+		kfree(chp_dsc);
+	}
+	QETH_DBF_TEXT_(setup, 2, "rc:%x", single_queue);
+	return single_queue;
+}
+
+static int
 qeth_determine_card_type(struct qeth_card *card)
 {
 	int i = 0;
@@ -1081,7 +1122,14 @@ qeth_determine_card_type(struct qeth_car
 		if ((CARD_RDEV(card)->id.dev_type == known_devices[i][2]) &&
 		    (CARD_RDEV(card)->id.dev_model == known_devices[i][3])) {
 			card->info.type = known_devices[i][4];
-			card->qdio.no_out_queues = known_devices[i][8];
+			if (is_1920_device(card)) {
+				PRINT_INFO("Priority Queueing not able "
+					   "due to hardware limitations!\n");
+				card->qdio.no_out_queues = 1;
+				card->qdio.default_out_queue = 0;
+			} else {
+				card->qdio.no_out_queues = known_devices[i][8];
+			}
 			card->info.is_multicast_different = known_devices[i][9];
 			return 0;
 		}
@@ -1112,6 +1160,10 @@ qeth_probe_device(struct ccwgroup_device
 		QETH_DBF_TEXT_(setup, 2, "1err%d", -ENOMEM);
 		return -ENOMEM;
 	}
+	card->read.ccwdev  = gdev->cdev[0];
+	card->write.ccwdev = gdev->cdev[1];
+	card->data.ccwdev  = gdev->cdev[2];
+
 	if ((rc = qeth_setup_card(card))){
 		QETH_DBF_TEXT_(setup, 2, "2err%d", rc);
 		put_device(dev);
@@ -1130,9 +1182,6 @@ qeth_probe_device(struct ccwgroup_device
 		qeth_free_card(card);
 		return rc;
 	}
-	card->read.ccwdev  = gdev->cdev[0];
-	card->write.ccwdev = gdev->cdev[1];
-	card->data.ccwdev  = gdev->cdev[2];
 	if ((rc = qeth_determine_card_type(card))){
 		PRINT_WARN("%s: not a valid card type\n", __func__);
 		QETH_DBF_TEXT_(setup, 2, "3err%d", rc);
@@ -1631,10 +1680,7 @@ qeth_check_ipa_data(struct qeth_card *ca
 				QETH_DBF_TEXT(trace,3, "irla");
 				break;
 			case IPA_CMD_UNREGISTER_LOCAL_ADDR:
-				PRINT_WARN("probably problem on %s: "
-					   "received IPA command 0x%X\n",
-					   QETH_CARD_IFNAME(card),
-					   cmd->hdr.command);
+				QETH_DBF_TEXT(trace,3, "urla");
 				break;
 			default:
 				PRINT_WARN("Received data is IPA "
@@ -1714,7 +1760,7 @@ qeth_send_control_data_cb(struct qeth_ch
 							(unsigned long)iob);
 			}
 			if (cmd)
-				reply->rc = (s16) cmd->hdr.return_code;
+				reply->rc = (u16) cmd->hdr.return_code;
 			else if (iob->rc)
 				reply->rc = iob->rc;
 			if (keep_reply) {
@@ -2115,9 +2161,15 @@ qeth_get_next_skb(struct qeth_card *card
 	if (!skb_len)
 		return NULL;
 	if (card->options.fake_ll){
-		if (!(skb = qeth_get_skb(skb_len + QETH_FAKE_LL_LEN)))
-			goto no_mem;
-		skb_pull(skb, QETH_FAKE_LL_LEN);
+		if(card->dev->type == ARPHRD_IEEE802_TR){
+			if (!(skb = qeth_get_skb(skb_len+QETH_FAKE_LL_LEN_TR)))
+				goto no_mem;
+			skb_reserve(skb,QETH_FAKE_LL_LEN_TR);
+		} else {
+			if (!(skb = qeth_get_skb(skb_len+QETH_FAKE_LL_LEN_ETH)))
+				goto no_mem;
+			skb_reserve(skb,QETH_FAKE_LL_LEN_ETH);
+		}
 	} else if (!(skb = qeth_get_skb(skb_len)))
 		goto no_mem;
 	data_ptr = element->addr + offset;
@@ -2192,14 +2244,68 @@ qeth_type_trans(struct sk_buff *skb, str
 }
 
 static inline void
-qeth_rebuild_skb_fake_ll(struct qeth_card *card, struct sk_buff *skb,
+qeth_rebuild_skb_fake_ll_tr(struct qeth_card *card, struct sk_buff *skb,
+			 struct qeth_hdr *hdr)
+{
+	struct trh_hdr *fake_hdr;
+	struct trllc *fake_llc;
+	struct iphdr *ip_hdr;
+
+	QETH_DBF_TEXT(trace,5,"skbfktr");
+	skb->mac.raw = skb->data - QETH_FAKE_LL_LEN_TR;
+	/* this is a fake ethernet header */
+	fake_hdr = (struct trh_hdr *) skb->mac.raw;
+
+	/* the destination MAC address */
+	switch (skb->pkt_type){
+	case PACKET_MULTICAST:
+		switch (skb->protocol){
+#ifdef CONFIG_QETH_IPV6
+		case __constant_htons(ETH_P_IPV6):
+			ndisc_mc_map((struct in6_addr *)
+				     skb->data + QETH_FAKE_LL_V6_ADDR_POS,
+				     fake_hdr->daddr, card->dev, 0);
+			break;
+#endif /* CONFIG_QETH_IPV6 */
+		case __constant_htons(ETH_P_IP):
+			ip_hdr = (struct iphdr *)skb->data;
+			ip_tr_mc_map(ip_hdr->daddr, fake_hdr->daddr);
+			break;
+		default:
+			memcpy(fake_hdr->daddr, card->dev->dev_addr, TR_ALEN);
+		}
+		break;
+	case PACKET_BROADCAST:
+		memset(fake_hdr->daddr, 0xff, TR_ALEN);
+		break;
+	default:
+		memcpy(fake_hdr->daddr, card->dev->dev_addr, TR_ALEN);
+	}
+	/* the source MAC address */
+	if (hdr->hdr.l3.ext_flags & QETH_HDR_EXT_SRC_MAC_ADDR)
+		memcpy(fake_hdr->saddr, &hdr->hdr.l3.dest_addr[2], TR_ALEN);
+	else
+		memset(fake_hdr->saddr, 0, TR_ALEN);
+	fake_hdr->rcf=0;
+	fake_llc = (struct trllc*)&(fake_hdr->rcf);
+	fake_llc->dsap = EXTENDED_SAP;
+	fake_llc->ssap = EXTENDED_SAP;
+	fake_llc->llc  = UI_CMD;
+	fake_llc->protid[0] = 0;
+	fake_llc->protid[1] = 0;
+	fake_llc->protid[2] = 0;
+	fake_llc->ethertype = ETH_P_IP;
+}
+
+static inline void
+qeth_rebuild_skb_fake_ll_eth(struct qeth_card *card, struct sk_buff *skb,
 			 struct qeth_hdr *hdr)
 {
 	struct ethhdr *fake_hdr;
 	struct iphdr *ip_hdr;
 
-	QETH_DBF_TEXT(trace,5,"skbfake");
-	skb->mac.raw = skb->data - QETH_FAKE_LL_LEN;
+	QETH_DBF_TEXT(trace,5,"skbfketh");
+	skb->mac.raw = skb->data - QETH_FAKE_LL_LEN_ETH;
 	/* this is a fake ethernet header */
 	fake_hdr = (struct ethhdr *) skb->mac.raw;
 
@@ -2216,10 +2322,7 @@ qeth_rebuild_skb_fake_ll(struct qeth_car
 #endif /* CONFIG_QETH_IPV6 */
 		case __constant_htons(ETH_P_IP):
 			ip_hdr = (struct iphdr *)skb->data;
-			if (card->dev->type == ARPHRD_IEEE802_TR)
-				ip_tr_mc_map(ip_hdr->daddr, fake_hdr->h_dest);
-			else
-				ip_eth_mc_map(ip_hdr->daddr, fake_hdr->h_dest);
+			ip_eth_mc_map(ip_hdr->daddr, fake_hdr->h_dest);
 			break;
 		default:
 			memcpy(fake_hdr->h_dest, card->dev->dev_addr, ETH_ALEN);
@@ -2241,6 +2344,16 @@ qeth_rebuild_skb_fake_ll(struct qeth_car
 }
 
 static inline void
+qeth_rebuild_skb_fake_ll(struct qeth_card *card, struct sk_buff *skb,
+			struct qeth_hdr *hdr)
+{
+	if (card->dev->type == ARPHRD_IEEE802_TR)
+		qeth_rebuild_skb_fake_ll_tr(card, skb, hdr);
+	else
+		qeth_rebuild_skb_fake_ll_eth(card, skb, hdr);
+}
+
+static inline void
 qeth_rebuild_skb_vlan(struct qeth_card *card, struct sk_buff *skb,
 		      struct qeth_hdr *hdr)
 {
@@ -2263,19 +2376,25 @@ qeth_layer2_rebuild_skb(struct qeth_card
 			struct qeth_hdr *hdr)
 {
 	unsigned short vlan_id = 0;
+#ifdef CONFIG_QETH_VLAN
+	struct vlan_hdr *vhdr;
+#endif
 
 	skb->pkt_type = PACKET_HOST;
+	skb->protocol = qeth_type_trans(skb, skb->dev);
 	if (card->options.checksum_type == NO_CHECKSUMMING)
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 	else
 		skb->ip_summed = CHECKSUM_NONE;
 #ifdef CONFIG_QETH_VLAN
 	if (hdr->hdr.l2.flags[2] & (QETH_LAYER2_FLAG_VLAN)) {
+		vhdr = (struct vlan_hdr *) skb->data;
+		skb->protocol =
+			__constant_htons(vhdr->h_vlan_encapsulated_proto);
 		vlan_id = hdr->hdr.l2.vlan_id;
 		skb_pull(skb, VLAN_HLEN);
 	}
 #endif
-	skb->protocol = qeth_type_trans(skb, skb->dev);
 	return vlan_id;
 }
 
@@ -2421,14 +2540,15 @@ qeth_clear_output_buffer(struct qeth_qdi
 	if (buf->buffer->element[0].flags & 0x40)
 		atomic_dec(&queue->set_pci_flags_count);
 
+	while ((skb = skb_dequeue(&buf->skb_list))){
+		atomic_dec(&skb->users);
+		dev_kfree_skb_any(skb);
+	}
+	qeth_eddp_buf_release_contexts(buf);
 	for(i = 0; i < QETH_MAX_BUFFER_ELEMENTS(queue->card); ++i){
 		buf->buffer->element[i].length = 0;
 		buf->buffer->element[i].addr = NULL;
 		buf->buffer->element[i].flags = 0;
-		while ((skb = skb_dequeue(&buf->skb_list))){
-			atomic_dec(&skb->users);
-			dev_kfree_skb_any(skb);
-		}
 	}
 	buf->next_element_to_fill = 0;
 	atomic_set(&buf->state, QETH_QDIO_BUF_EMPTY);
@@ -2578,7 +2698,7 @@ qeth_handle_send_error(struct qeth_card 
 	return QETH_SEND_ERROR_LINK_FAILURE;
 }
 
-static inline void
+void
 qeth_flush_buffers(struct qeth_qdio_out_q *queue, int under_int,
 		   int index, int count)
 {
@@ -2619,9 +2739,6 @@ qeth_flush_buffers(struct qeth_qdio_out_
 				atomic_inc(&queue->set_pci_flags_count);
 				buf->buffer->element[0].flags |= 0x40;
 			}
-#ifdef CONFIG_QETH_PERF_STATS
-			queue->card->perf_stats.bufs_sent_pack++;
-#endif
 		}
 	}
 
@@ -2743,6 +2860,7 @@ qeth_check_outbound_queue(struct qeth_qd
 {
 	int index;
 	int flush_cnt = 0;
+	int q_was_packing = 0;
 
 	/*
 	 * check if weed have to switch to non-packing mode or if
@@ -2757,20 +2875,22 @@ qeth_check_outbound_queue(struct qeth_qd
 			 * do_send_packet. So, we check if there is a
 			 * packing buffer to be flushed here.
 			 */
-			/* TODO: try if we get a performance improvement
-			 * by calling netif_stop_queue here */
-			/* save start index for flushing */
+			netif_stop_queue(queue->card->dev);
 			index = queue->next_buf_to_fill;
+			q_was_packing = queue->do_pack;
 			flush_cnt += qeth_switch_to_nonpacking_if_needed(queue);
 			if (!flush_cnt &&
 			    !atomic_read(&queue->set_pci_flags_count))
 				flush_cnt +=
 					qeth_flush_buffers_on_no_pci(queue);
-			/* were done with updating critical queue members */
-			atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
-			/* flushing can be done outside the lock */
+#ifdef CONFIG_QETH_PERF_STATS
+			if (q_was_packing)
+				queue->card->perf_stats.bufs_sent_pack +=
+					flush_cnt;
+#endif
 			if (flush_cnt)
 				qeth_flush_buffers(queue, 1, index, flush_cnt);
+			atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 		}
 	}
 }
@@ -2800,7 +2920,6 @@ qeth_qdio_output_handler(struct ccw_devi
 			return;
 		}
 	}
-
 #ifdef CONFIG_QETH_PERF_STATS
 	card->perf_stats.outbound_handler_cnt++;
 	card->perf_stats.outbound_handler_start_time = qeth_get_micros();
@@ -2821,24 +2940,16 @@ qeth_qdio_output_handler(struct ccw_devi
 	if (card->info.type != QETH_CARD_TYPE_IQD)
 		qeth_check_outbound_queue(queue);
 
-	netif_wake_queue(card->dev);
+	netif_wake_queue(queue->card->dev);
 #ifdef CONFIG_QETH_PERF_STATS
 	card->perf_stats.outbound_handler_time += qeth_get_micros() -
 		card->perf_stats.outbound_handler_start_time;
 #endif
 }
 
-static char*
-qeth_create_qib_param_field(struct qeth_card *card)
+static void
+qeth_create_qib_param_field(struct qeth_card *card, char *param_field)
 {
-	char *param_field;
-
-	param_field = kmalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),
-			      GFP_KERNEL);
- 	if (!param_field)
-		return NULL;
-
- 	memset(param_field, 0, QDIO_MAX_BUFFERS_PER_Q * sizeof(char));
 
 	param_field[0] = _ascebc['P'];
 	param_field[1] = _ascebc['C'];
@@ -2847,8 +2958,18 @@ qeth_create_qib_param_field(struct qeth_
 	*((unsigned int *) (&param_field[4])) = QETH_PCI_THRESHOLD_A(card);
 	*((unsigned int *) (&param_field[8])) = QETH_PCI_THRESHOLD_B(card);
 	*((unsigned int *) (&param_field[12])) = QETH_PCI_TIMER_VALUE(card);
+}
 
-	return param_field;
+static void
+qeth_create_qib_param_field_blkt(struct qeth_card *card, char *param_field)
+{
+	param_field[16] = _ascebc['B'];
+        param_field[17] = _ascebc['L'];
+        param_field[18] = _ascebc['K'];
+        param_field[19] = _ascebc['T'];
+        *((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;
+        *((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;
+        *((unsigned int *) (&param_field[28])) = card->info.blkt.inter_packet_jumbo;
 }
 
 static void
@@ -2898,7 +3019,7 @@ qeth_alloc_buffer_pool(struct qeth_card 
 	void *ptr;
 	int i, j;
 
-	QETH_DBF_TEXT(trace,5,"clwkpool");
+	QETH_DBF_TEXT(trace,5,"alocpool");
 	for (i = 0; i < card->qdio.init_pool.buf_count; ++i){
 	 	pool_entry = kmalloc(sizeof(*pool_entry), GFP_KERNEL);
 		if (!pool_entry){
@@ -2986,12 +3107,13 @@ qeth_alloc_qdio_buffers(struct qeth_card
 		QETH_DBF_HEX(setup, 2, &card->qdio.out_qs[i], sizeof(void *));
 		memset(card->qdio.out_qs[i], 0, sizeof(struct qeth_qdio_out_q));
 		card->qdio.out_qs[i]->queue_no = i;
-		/* give inbound qeth_qdio_buffers their qdio_buffers */
+		/* give outbound qeth_qdio_buffers their qdio_buffers */
 		for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j){
 			card->qdio.out_qs[i]->bufs[j].buffer =
 				&card->qdio.out_qs[i]->qdio_bufs[j];
 			skb_queue_head_init(&card->qdio.out_qs[i]->bufs[j].
 					    skb_list);
+			INIT_LIST_HEAD(&card->qdio.out_qs[i]->bufs[j].ctx_list);
 		}
 	}
 	card->qdio.state = QETH_QDIO_ALLOCATED;
@@ -3108,10 +3230,17 @@ qeth_qdio_establish(struct qeth_card *ca
 	int rc;
 
 	QETH_DBF_TEXT(setup, 2, "qdioest");
-	qib_param_field = qeth_create_qib_param_field(card);
-	if (!qib_param_field)
+
+	qib_param_field = kmalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),
+			      GFP_KERNEL);
+ 	if (!qib_param_field)
 		return -ENOMEM;
 
+ 	memset(qib_param_field, 0, QDIO_MAX_BUFFERS_PER_Q * sizeof(char));
+
+	qeth_create_qib_param_field(card, qib_param_field);
+	qeth_create_qib_param_field_blkt(card, qib_param_field);
+
 	in_sbal_ptrs = kmalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(void *),
 			       GFP_KERNEL);
 	if (!in_sbal_ptrs) {
@@ -3387,18 +3516,25 @@ qeth_fake_header(struct sk_buff *skb, st
 		     unsigned short type, void *daddr, void *saddr,
 		     unsigned len)
 {
-	struct ethhdr *hdr;
-	struct qeth_card *card;
+	if(dev->type == ARPHRD_IEEE802_TR){
+		struct trh_hdr *hdr;
+        	hdr = (struct trh_hdr *)skb_push(skb, QETH_FAKE_LL_LEN_TR);
+		memcpy(hdr->saddr, dev->dev_addr, TR_ALEN);
+        	memcpy(hdr->daddr, "FAKELL", TR_ALEN);
+		return QETH_FAKE_LL_LEN_TR;
 
-	card = (struct qeth_card *)dev->priv;
-        hdr = (struct ethhdr *)skb_push(skb, QETH_FAKE_LL_LEN);
-	memcpy(hdr->h_source, card->dev->dev_addr, ETH_ALEN);
-        memcpy(hdr->h_dest, "FAKELL", ETH_ALEN);
-        if (type != ETH_P_802_3)
-                hdr->h_proto = htons(type);
-        else
-                hdr->h_proto = htons(len);
-	return QETH_FAKE_LL_LEN;
+	} else {
+		struct ethhdr *hdr;
+        	hdr = (struct ethhdr *)skb_push(skb, QETH_FAKE_LL_LEN_ETH);
+		memcpy(hdr->h_source, dev->dev_addr, ETH_ALEN);
+        	memcpy(hdr->h_dest, "FAKELL", ETH_ALEN);
+        	if (type != ETH_P_802_3)
+                	hdr->h_proto = htons(type);
+        	else
+                	hdr->h_proto = htons(len);
+		return QETH_FAKE_LL_LEN_ETH;
+
+	}
 }
 
 static inline int
@@ -3430,32 +3566,19 @@ qeth_hard_start_xmit(struct sk_buff *skb
 	card->perf_stats.outbound_cnt++;
 	card->perf_stats.outbound_start_time = qeth_get_micros();
 #endif
-	if (dev->hard_header == qeth_fake_header) {
-               if ((skb = qeth_pskb_unshare(skb, GFP_ATOMIC)) == NULL) {
-                        card->stats.tx_dropped++;
-                        dev_kfree_skb_irq(skb);
-                        return 0;
-                }
-                skb_pull(skb, QETH_FAKE_LL_LEN);
-	}
-	/*
-	 * We only call netif_stop_queue in case of errors. Since we've
-	 * got our own synchronization on queues we can keep the stack's
-	 * queue running.
-	 */
-	if ((rc = qeth_send_packet(card, skb))){
+	netif_stop_queue(dev);
+	if ((rc = qeth_send_packet(card, skb))) {
 		if (rc == -EBUSY) {
-			netif_stop_queue(dev);
-			rc = NETDEV_TX_BUSY;
+			return NETDEV_TX_BUSY;
 		} else {
 			card->stats.tx_errors++;
 			card->stats.tx_dropped++;
 			dev_kfree_skb_any(skb);
-			/* set to OK; otherwise ksoftirqd goes to 100% */
+			/*set to OK; otherwise ksoftirqd goes to 100% */
 			rc = NETDEV_TX_OK;
 		}
 	}
-
+	netif_wake_queue(dev);
 #ifdef CONFIG_QETH_PERF_STATS
 	card->perf_stats.outbound_time += qeth_get_micros() -
 		card->perf_stats.outbound_start_time;
@@ -3649,8 +3772,9 @@ qeth_get_priority_queue(struct qeth_card
 			/* TODO: IPv6!!! */
 		}
 		return card->qdio.default_out_queue;
+	case 1: /* fallthrough for single-out-queue 1920-device */
 	default:
-		return 0;
+		return card->qdio.default_out_queue;
 	}
 }
 
@@ -3671,22 +3795,12 @@ static inline int
 qeth_prepare_skb(struct qeth_card *card, struct sk_buff **skb,
 		 struct qeth_hdr **hdr, int ipv)
 {
-	struct sk_buff *new_skb;
 #ifdef CONFIG_QETH_VLAN
 	u16 *tag;
 #endif
 
 	QETH_DBF_TEXT(trace, 6, "prepskb");
-	if (skb_headroom(*skb) < sizeof(struct qeth_hdr)){
-		new_skb = skb_realloc_headroom(*skb, sizeof(struct qeth_hdr));
-		if (!new_skb) {
-			PRINT_ERR("qeth_prepare_skb: could "
-				  "not realloc headroom for qeth_hdr "
-				  "on interface %s", QETH_CARD_IFNAME(card));
-			return -ENOMEM;
-		}
-		*skb = new_skb;
-	}
+
 #ifdef CONFIG_QETH_VLAN
 	if (card->vlangrp && vlan_tx_tag_present(*skb) &&
 	    ((ipv == 6) || card->options.layer2) ) {
@@ -3708,20 +3822,10 @@ qeth_prepare_skb(struct qeth_card *card,
 		*(tag + 1) = htons(vlan_tx_tag_get(*skb));
 	}
 #endif
-	*hdr = (struct qeth_hdr *) skb_push(*skb, sizeof(struct qeth_hdr));
-	/*
-	 * sanity check, the Linux memory allocation scheme should
-	 * never present us cases like this one (the 32bytes header plus
-	 * the first 40 bytes of the paket cross a 4k boundary)
-	 */
-	if ((((unsigned long) *hdr) & (~(PAGE_SIZE - 1))) !=
-	    (((unsigned long) *hdr + sizeof(struct qeth_hdr) +
-	      QETH_IP_HEADER_SIZE) & (~(PAGE_SIZE - 1)))) {
-		PRINT_ERR("qeth_prepare_skb: misaligned "
-			  "packet on interface %s. Discarded.",
-			  QETH_CARD_IFNAME(card));
+	*hdr = (struct qeth_hdr *)
+		qeth_push_skb(card, skb, sizeof(struct qeth_hdr));
+	if (hdr == NULL)
 		return -EINVAL;
-	}
 	return 0;
 }
 
@@ -3813,12 +3917,13 @@ qeth_layer2_fill_header(struct qeth_card
 #endif
 }
 
-static inline void
+void
 qeth_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,
 		struct sk_buff *skb, int ipv, int cast_type)
 {
 	QETH_DBF_TEXT(trace, 6, "fillhdr");
 
+	memset(hdr, 0, sizeof(struct qeth_hdr));
 	if (card->options.layer2) {
 		qeth_layer2_fill_header(card, hdr, skb, cast_type);
 		return;
@@ -3858,9 +3963,15 @@ qeth_fill_header(struct qeth_card *card,
 			memcpy(hdr->hdr.l3.dest_addr, &skb->nh.ipv6h->daddr, 16);
 		}
 	} else { /* passthrough */
-		if (!memcmp(skb->data + sizeof(struct qeth_hdr),
+                if((skb->dev->type == ARPHRD_IEEE802_TR) &&
+		    !memcmp(skb->data + sizeof(struct qeth_hdr) + 
+		    sizeof(__u16), skb->dev->broadcast, 6)) {
+			hdr->hdr.l3.flags = QETH_CAST_BROADCAST |
+						QETH_HDR_PASSTHRU;
+		} else if (!memcmp(skb->data + sizeof(struct qeth_hdr),
 			    skb->dev->broadcast, 6)) {   /* broadcast? */
-			hdr->hdr.l3.flags = QETH_CAST_BROADCAST | QETH_HDR_PASSTHRU;
+			hdr->hdr.l3.flags = QETH_CAST_BROADCAST |
+						QETH_HDR_PASSTHRU;
 		} else {
  			hdr->hdr.l3.flags = (cast_type == RTN_MULTICAST) ?
  				QETH_CAST_MULTICAST | QETH_HDR_PASSTHRU :
@@ -3869,30 +3980,30 @@ qeth_fill_header(struct qeth_card *card,
 	}
 }
 
-static inline int
-qeth_fill_buffer(struct qeth_qdio_out_q *queue, struct qeth_qdio_out_buffer *buf,
-		 char *data, struct sk_buff *skb)
+static inline void
+__qeth_fill_buffer(struct sk_buff *skb, struct qdio_buffer *buffer,
+		   int is_tso, int *next_element_to_fill)
 {
-	struct qdio_buffer *buffer;
 	int length = skb->len;
 	int length_here;
 	int element;
-	int first_lap = 1;
+	char *data;
+	int first_lap ;
+
+	element = *next_element_to_fill;
+	data = skb->data;
+	first_lap = (is_tso == 0 ? 1 : 0);
 
-	QETH_DBF_TEXT(trace, 6, "qdfillbf");
-	buffer = buf->buffer;
-	atomic_inc(&skb->users);
-	skb_queue_tail(&buf->skb_list, skb);
-	element = buf->next_element_to_fill;
 	while (length > 0) {
 		/* length_here is the remaining amount of data in this page */
 		length_here = PAGE_SIZE - ((unsigned long) data % PAGE_SIZE);
 		if (length < length_here)
 			length_here = length;
+
 		buffer->element[element].addr = data;
 		buffer->element[element].length = length_here;
 		length -= length_here;
-		if (!length){
+		if (!length) {
 			if (first_lap)
 				buffer->element[element].flags = 0;
 			else
@@ -3910,11 +4021,51 @@ qeth_fill_buffer(struct qeth_qdio_out_q 
 		element++;
 		first_lap = 0;
 	}
-	buf->next_element_to_fill = element;
+	*next_element_to_fill = element;
+}
+
+static inline int
+qeth_fill_buffer(struct qeth_qdio_out_q *queue,
+		 struct qeth_qdio_out_buffer *buf,
+		 struct sk_buff *skb)
+{
+	struct qdio_buffer *buffer;
+	struct qeth_hdr_tso *hdr;
+	int flush_cnt = 0, hdr_len, large_send = 0;
+
+	QETH_DBF_TEXT(trace, 6, "qdfillbf");
+
+	buffer = buf->buffer;
+	atomic_inc(&skb->users);
+	skb_queue_tail(&buf->skb_list, skb);
+
+	hdr  = (struct qeth_hdr_tso *) skb->data;
+	/*check first on TSO ....*/
+	if (hdr->hdr.hdr.l3.id == QETH_HEADER_TYPE_TSO) {
+		int element = buf->next_element_to_fill;
+
+		hdr_len = sizeof(struct qeth_hdr_tso) + hdr->ext.dg_hdr_len;
+		/*fill first buffer entry only with header information */
+		buffer->element[element].addr = skb->data;
+		buffer->element[element].length = hdr_len;
+		buffer->element[element].flags = SBAL_FLAGS_FIRST_FRAG;
+		buf->next_element_to_fill++;
+		skb->data += hdr_len;
+		skb->len  -= hdr_len;
+		large_send = 1;
+	}
+	if (skb_shinfo(skb)->nr_frags == 0)
+		__qeth_fill_buffer(skb, buffer, large_send,
+				   (int *)&buf->next_element_to_fill);
+	else
+		__qeth_fill_buffer_frag(skb, buffer, large_send,
+					(int *)&buf->next_element_to_fill);
+
 	if (!queue->do_pack) {
 		QETH_DBF_TEXT(trace, 6, "fillbfnp");
 		/* set state to PRIMED -> will be flushed */
 		atomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);
+		flush_cnt = 1;
 	} else {
 		QETH_DBF_TEXT(trace, 6, "fillbfpa");
 #ifdef CONFIG_QETH_PERF_STATS
@@ -3927,17 +4078,21 @@ qeth_fill_buffer(struct qeth_qdio_out_q 
 			 * -> will be flushed
 			 */
 			atomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);
+			flush_cnt = 1;
 		}
 	}
-	return 0;
+	return flush_cnt;
 }
 
 static inline int
 qeth_do_send_packet_fast(struct qeth_card *card, struct qeth_qdio_out_q *queue,
 			 struct sk_buff *skb, struct qeth_hdr *hdr,
-			 int elements_needed)
+			 int elements_needed,
+			 struct qeth_eddp_context *ctx)
 {
 	struct qeth_qdio_out_buffer *buffer;
+	int buffers_needed = 0;
+	int flush_cnt = 0;
 	int index;
 
 	QETH_DBF_TEXT(trace, 6, "dosndpfa");
@@ -3958,22 +4113,42 @@ qeth_do_send_packet_fast(struct qeth_car
 		atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 		return -EBUSY;
 	}
-	queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
-				  QDIO_MAX_BUFFERS_PER_Q;
+	if (ctx == NULL)
+		queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
+					  QDIO_MAX_BUFFERS_PER_Q;
+	else {
+		buffers_needed = qeth_eddp_check_buffers_for_context(queue,ctx);
+		if (buffers_needed < 0) {
+			card->stats.tx_dropped++;
+			atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
+			return -EBUSY;
+		}
+		queue->next_buf_to_fill =
+			(queue->next_buf_to_fill + buffers_needed) %
+			QDIO_MAX_BUFFERS_PER_Q;
+	}
 	atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
-	qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
-	qeth_flush_buffers(queue, 0, index, 1);
+	if (ctx == NULL) {
+		qeth_fill_buffer(queue, buffer, skb);
+		qeth_flush_buffers(queue, 0, index, 1);
+	} else {
+		flush_cnt = qeth_eddp_fill_buffer(queue, ctx, index);
+		WARN_ON(buffers_needed != flush_cnt);
+		qeth_flush_buffers(queue, 0, index, flush_cnt);
+	}
 	return 0;
 }
 
 static inline int
 qeth_do_send_packet(struct qeth_card *card, struct qeth_qdio_out_q *queue,
 		    struct sk_buff *skb, struct qeth_hdr *hdr,
-		    int elements_needed)
+		    int elements_needed, struct qeth_eddp_context *ctx)
 {
 	struct qeth_qdio_out_buffer *buffer;
 	int start_index;
 	int flush_count = 0;
+	int do_pack = 0;
+	int tmp;
 	int rc = 0;
 
 	QETH_DBF_TEXT(trace, 6, "dosndpkt");
@@ -3996,34 +4171,56 @@ qeth_do_send_packet(struct qeth_card *ca
 	/* check if we need to switch packing state of this queue */
 	qeth_switch_to_packing_if_needed(queue);
 	if (queue->do_pack){
-		/* does packet fit in current buffer? */
-		if((QETH_MAX_BUFFER_ELEMENTS(card) -
-		    buffer->next_element_to_fill) < elements_needed){
-			/* ... no -> set state PRIMED */
-			atomic_set(&buffer->state, QETH_QDIO_BUF_PRIMED);
-			flush_count++;
-			queue->next_buf_to_fill =
-				(queue->next_buf_to_fill + 1) %
-				QDIO_MAX_BUFFERS_PER_Q;
-			buffer = &queue->bufs[queue->next_buf_to_fill];
-			/* we did a step forward, so check buffer state again */
-			if (atomic_read(&buffer->state) != QETH_QDIO_BUF_EMPTY){
+		do_pack = 1;
+		if (ctx == NULL) {
+			/* does packet fit in current buffer? */
+			if((QETH_MAX_BUFFER_ELEMENTS(card) -
+			    buffer->next_element_to_fill) < elements_needed){
+				/* ... no -> set state PRIMED */
+				atomic_set(&buffer->state,QETH_QDIO_BUF_PRIMED);
+				flush_count++;
+				queue->next_buf_to_fill =
+					(queue->next_buf_to_fill + 1) %
+					QDIO_MAX_BUFFERS_PER_Q;
+				buffer = &queue->bufs[queue->next_buf_to_fill];
+				/* we did a step forward, so check buffer state
+				 * again */
+				if (atomic_read(&buffer->state) !=
+						QETH_QDIO_BUF_EMPTY){
+					card->stats.tx_dropped++;
+					qeth_flush_buffers(queue, 0, start_index, flush_count);
+					atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
+					return -EBUSY;
+				}
+			}
+		} else {
+			/* check if we have enough elements (including following
+			 * free buffers) to handle eddp context */
+			if (qeth_eddp_check_buffers_for_context(queue,ctx) < 0){
+				printk("eddp tx_dropped 1\n");
 				card->stats.tx_dropped++;
-				/* return EBUSY because we sent old packet, not
-				 * the current one */
 				rc = -EBUSY;
-				atomic_set(&queue->state, QETH_OUT_Q_UNLOCKED);
 				goto out;
 			}
 		}
 	}
-	qeth_fill_buffer(queue, buffer, (char *)hdr, skb);
-	if (atomic_read(&buffer->state) == QETH_QDIO_BUF_PRIMED){
-		/* next time fill the next buffer */
-		flush_count++;
-		queue->next_buf_to_fill = (queue->next_buf_to_fill + 1) %
-			QDIO_MAX_BUFFERS_PER_Q;
+	if (ctx == NULL)
+		tmp = qeth_fill_buffer(queue, buffer, skb);
+	else {
+		tmp = qeth_eddp_fill_buffer(queue,ctx,queue->next_buf_to_fill);
+		if (tmp < 0) {
+			printk("eddp tx_dropped 2\n");
+			card->stats.tx_dropped++;
+			rc = - EBUSY;
+			goto out;
+		}
 	}
+	queue->next_buf_to_fill = (queue->next_buf_to_fill + tmp) %
+				  QDIO_MAX_BUFFERS_PER_Q;
+	flush_count += tmp;
+out:
+	if (flush_count)
+		qeth_flush_buffers(queue, 0, start_index, flush_count);
 	/*
 	 * queue->state will go from LOCKED -> UNLOCKED or from
 	 * LOCKED_FLUSH -> LOCKED if output_handler wanted to 'notify' us
@@ -4031,6 +4228,8 @@ qeth_do_send_packet(struct qeth_card *ca
 	 * In that case we will enter this loop
 	 */
 	while (atomic_dec_return(&queue->state)){
+		flush_count = 0;
+		start_index = queue->next_buf_to_fill;
 		/* check if we can go back to non-packing state */
 		flush_count += qeth_switch_to_nonpacking_if_needed(queue);
 		/*
@@ -4039,56 +4238,140 @@ qeth_do_send_packet(struct qeth_card *ca
 		 */
 		if (!flush_count && !atomic_read(&queue->set_pci_flags_count))
 			flush_count += qeth_flush_buffers_on_no_pci(queue);
+		if (flush_count)
+			qeth_flush_buffers(queue, 0, start_index, flush_count);
 	}
 	/* at this point the queue is UNLOCKED again */
-out:
-	if (flush_count)
-		qeth_flush_buffers(queue, 0, start_index, flush_count);
+#ifdef CONFIG_QETH_PERF_STATS
+	if (do_pack)
+		queue->card->perf_stats.bufs_sent_pack += flush_count;
+#endif /* CONFIG_QETH_PERF_STATS */
 
 	return rc;
 }
 
 static inline int
+qeth_get_elements_no(struct qeth_card *card, void *hdr, struct sk_buff *skb)
+{
+	int elements_needed = 0;
+
+        if (skb_shinfo(skb)->nr_frags > 0) {
+                elements_needed = (skb_shinfo(skb)->nr_frags + 1);
+	}
+        if (elements_needed == 0 )
+                elements_needed = 1 + (((((unsigned long) hdr) % PAGE_SIZE)
+                                        + skb->len) >> PAGE_SHIFT);
+        if (elements_needed > QETH_MAX_BUFFER_ELEMENTS(card)){
+                PRINT_ERR("qeth_do_send_packet: invalid size of "
+                          "IP packet. Discarded.");
+                return 0;
+        }
+        return elements_needed;
+}
+
+static inline int
 qeth_send_packet(struct qeth_card *card, struct sk_buff *skb)
 {
 	int ipv = 0;
 	int cast_type;
 	struct qeth_qdio_out_q *queue;
 	struct qeth_hdr *hdr;
-	int elements_needed;
+	int elements_needed = 0;
+	enum qeth_large_send_types large_send = QETH_LARGE_SEND_NO;
+	struct qeth_eddp_context *ctx = NULL;
 	int rc;
 
 	QETH_DBF_TEXT(trace, 6, "sendpkt");
 
-	if (!card->options.layer2)
+	if (!card->options.layer2) {
 		ipv = qeth_get_ip_version(skb);
+		if ((card->dev->hard_header == qeth_fake_header) && ipv) {
+               		if ((skb = qeth_pskb_unshare(skb,GFP_ATOMIC)) == NULL) {
+                        	card->stats.tx_dropped++;
+                        	dev_kfree_skb_irq(skb);
+                        	return 0;
+                	}
+			if(card->dev->type == ARPHRD_IEEE802_TR){
+				skb_pull(skb, QETH_FAKE_LL_LEN_TR);
+			} else {
+                		skb_pull(skb, QETH_FAKE_LL_LEN_ETH);
+			}
+		}
+	}
 	cast_type = qeth_get_cast_type(card, skb);
+	if ((cast_type == RTN_BROADCAST) && (card->info.broadcast_capable == 0)){
+		card->stats.tx_dropped++;
+		card->stats.tx_errors++;
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
 	queue = card->qdio.out_qs
 		[qeth_get_priority_queue(card, skb, ipv, cast_type)];
 
-	if ((rc = qeth_prepare_skb(card, &skb, &hdr, ipv))){
-		QETH_DBF_TEXT_(trace, 4, "1err%d", rc);
-		return rc;
+	if (skb_shinfo(skb)->tso_size)
+		large_send = card->options.large_send;
+
+	/*are we able to do TSO ? If so ,prepare and send it from here */
+	if ((large_send == QETH_LARGE_SEND_TSO) &&
+	    (cast_type == RTN_UNSPEC)) {
+		rc = qeth_tso_prepare_packet(card, skb, ipv, cast_type);
+		if (rc) {
+			card->stats.tx_dropped++;
+			card->stats.tx_errors++;
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		} 
+		elements_needed++;
+	} else {
+		if ((rc = qeth_prepare_skb(card, &skb, &hdr, ipv))) {
+			QETH_DBF_TEXT_(trace, 4, "pskbe%d", rc);
+			return rc;
+		}
+		qeth_fill_header(card, hdr, skb, ipv, cast_type);
 	}
-	qeth_fill_header(card, hdr, skb, ipv, cast_type);
-	elements_needed = 1 + (((((unsigned long) hdr) % PAGE_SIZE) + skb->len)
-				>> PAGE_SHIFT);
-	if (elements_needed > QETH_MAX_BUFFER_ELEMENTS(card)){
-		PRINT_ERR("qeth_do_send_packet: invalid size of "
-				 "IP packet. Discarded.");
-		return -EINVAL;
+
+	if (large_send == QETH_LARGE_SEND_EDDP) {
+		ctx = qeth_eddp_create_context(card, skb, hdr);
+		if (ctx == NULL) {
+			PRINT_WARN("could not create eddp context\n");
+			return -EINVAL;
+		}
+	} else {
+		elements_needed += qeth_get_elements_no(card,(void*) hdr, skb);
+		if (!elements_needed)
+			return -EINVAL;
 	}
 
 	if (card->info.type != QETH_CARD_TYPE_IQD)
 		rc = qeth_do_send_packet(card, queue, skb, hdr,
-					 elements_needed);
+					 elements_needed, ctx);
 	else
 		rc = qeth_do_send_packet_fast(card, queue, skb, hdr,
-					      elements_needed);
-
+					      elements_needed, ctx);
 	if (!rc){
 		card->stats.tx_packets++;
 		card->stats.tx_bytes += skb->len;
+#ifdef CONFIG_QETH_PERF_STATS
+		if (skb_shinfo(skb)->tso_size &&
+		   !(large_send == QETH_LARGE_SEND_NO)) {
+			card->perf_stats.large_send_bytes += skb->len;
+			card->perf_stats.large_send_cnt++;
+		}
+ 		if (skb_shinfo(skb)->nr_frags > 0){
+			card->perf_stats.sg_skbs_sent++;
+			/* nr_frags + skb->data */
+			card->perf_stats.sg_frags_sent +=
+				skb_shinfo(skb)->nr_frags + 1;
+		}
+#endif /* CONFIG_QETH_PERF_STATS */
+	}
+	if (ctx != NULL) {
+		/* drop creator's reference */
+		qeth_eddp_put_context(ctx);
+		/* free skb; it's not referenced by a buffer */
+		if (rc == 0)
+			dev_kfree_skb_any(skb);
+
 	}
 	return rc;
 }
@@ -4943,6 +5226,7 @@ out:
 static void
 qeth_free_vlan_addresses6(struct qeth_card *card, unsigned short vid)
 {
+#ifdef CONFIG_QETH_IPV6
 	struct inet6_dev *in6_dev;
 	struct inet6_ifaddr *ifa;
 	struct qeth_ipaddr *addr;
@@ -4965,6 +5249,7 @@ qeth_free_vlan_addresses6(struct qeth_ca
 		}
 	}
 	in6_dev_put(in6_dev);
+#endif /* CONFIG_QETH_IPV6 */
 }
 
 static void
@@ -5242,7 +5527,8 @@ qeth_add_multicast_ipv6(struct qeth_card
 	struct inet6_dev *in6_dev;
 
 	QETH_DBF_TEXT(trace,4,"chkmcv6");
-	if (!qeth_is_supported(card, IPA_IPV6))
+	if ((card->options.layer2 == 0) &&
+	    (!qeth_is_supported(card, IPA_IPV6)) )
 		return ;
 
 	in6_dev = in6_dev_get(card->dev);
@@ -5563,7 +5849,7 @@ static int
 qeth_layer3_register_addr_entry(struct qeth_card *card,
 				struct qeth_ipaddr *addr)
 {
-	//char buf[50];
+	char buf[50];
 	int rc;
 	int cnt = 3;
 
@@ -5589,12 +5875,9 @@ qeth_layer3_register_addr_entry(struct q
 	} while ((--cnt > 0) && rc);
 	if (rc){
 		QETH_DBF_TEXT(trace, 2, "FAILED");
-		/* TODO: re-activate this warning as soon as we have a
-		 * clean mirco code
 		qeth_ipaddr_to_string(addr->proto, (u8 *)&addr->u, buf);
-		PRINT_WARN("Could not register IP address %s (rc=%x)\n",
-			   buf, rc);
-		*/
+		PRINT_WARN("Could not register IP address %s (rc=0x%x/%d)\n",
+			   buf, rc, rc);
 	}
 	return rc;
 }
@@ -5652,6 +5935,111 @@ qeth_deregister_addr_entry(struct qeth_c
 	return qeth_layer3_deregister_addr_entry(card, addr);
 }
 
+static u32
+qeth_ethtool_get_tx_csum(struct net_device *dev)
+{
+	/* We may need to say that we support tx csum offload if
+	 * we do EDDP or TSO. There are discussions going on to
+	 * enforce rules in the stack and in ethtool that make
+	 * SG and TSO depend on HW_CSUM. At the moment there are
+	 * no such rules....
+	 * If we say yes here, we have to checksum outbound packets
+	 * any time. */
+	return 0;
+}
+
+static int
+qeth_ethtool_set_tx_csum(struct net_device *dev, u32 data)
+{
+	return -EINVAL;
+}
+
+static u32
+qeth_ethtool_get_rx_csum(struct net_device *dev)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	return (card->options.checksum_type == HW_CHECKSUMMING);
+}
+
+static int
+qeth_ethtool_set_rx_csum(struct net_device *dev, u32 data)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	if ((card->state != CARD_STATE_DOWN) &&
+	    (card->state != CARD_STATE_RECOVER))
+		return -EPERM;
+	if (data)
+		card->options.checksum_type = HW_CHECKSUMMING;
+	else
+		card->options.checksum_type = SW_CHECKSUMMING;
+	return 0;
+}
+
+static u32
+qeth_ethtool_get_sg(struct net_device *dev)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	return ((card->options.large_send != QETH_LARGE_SEND_NO) &&
+		(dev->features & NETIF_F_SG));
+}
+
+static int
+qeth_ethtool_set_sg(struct net_device *dev, u32 data)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	if (data) {
+		if (card->options.large_send != QETH_LARGE_SEND_NO)
+			dev->features |= NETIF_F_SG;
+		else {
+			dev->features &= ~NETIF_F_SG;
+			return -EINVAL;
+		}
+	} else
+		dev->features &= ~NETIF_F_SG;
+	return 0;
+}
+
+static u32
+qeth_ethtool_get_tso(struct net_device *dev)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	return ((card->options.large_send != QETH_LARGE_SEND_NO) &&
+		(dev->features & NETIF_F_TSO));
+}
+
+static int
+qeth_ethtool_set_tso(struct net_device *dev, u32 data)
+{
+	struct qeth_card *card = (struct qeth_card *)dev->priv;
+
+	if (data) {
+		if (card->options.large_send != QETH_LARGE_SEND_NO)
+			dev->features |= NETIF_F_TSO;
+		else {
+			dev->features &= ~NETIF_F_TSO;
+			return -EINVAL;
+		}
+	} else
+		dev->features &= ~NETIF_F_TSO;
+	return 0;
+}
+
+static struct ethtool_ops qeth_ethtool_ops = {
+	.get_tx_csum = qeth_ethtool_get_tx_csum,
+	.set_tx_csum = qeth_ethtool_set_tx_csum,
+	.get_rx_csum = qeth_ethtool_get_rx_csum,
+	.set_rx_csum = qeth_ethtool_set_rx_csum,
+	.get_sg      = qeth_ethtool_get_sg,
+	.set_sg      = qeth_ethtool_set_sg,
+	.get_tso     = qeth_ethtool_get_tso,
+	.set_tso     = qeth_ethtool_set_tso,
+};
+
 static int
 qeth_netdev_init(struct net_device *dev)
 {
@@ -5701,6 +6089,8 @@ qeth_netdev_init(struct net_device *dev)
 	dev->addr_len = OSA_ADDR_LEN;
 	dev->mtu = card->info.initial_mtu;
 
+	SET_ETHTOOL_OPS(dev, &qeth_ethtool_ops);
+
 	SET_MODULE_OWNER(dev);
 	return 0;
 }
@@ -6092,6 +6482,9 @@ qeth_query_ipassists_cb(struct qeth_card
 		card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
 #endif
 	}
+	QETH_DBF_TEXT(setup, 2, "suppenbl");
+	QETH_DBF_TEXT_(setup, 2, "%x",cmd->hdr.ipa_supported);
+	QETH_DBF_TEXT_(setup, 2, "%x",cmd->hdr.ipa_enabled);
 	return 0;
 }
 
@@ -6492,26 +6885,33 @@ qeth_start_ipa_checksum(struct qeth_card
 	return rc;
 }
 
-/*
-static inline void
-qeth_print_ipassist_status(struct qeth_card *card)
+static int
+qeth_start_ipa_tso(struct qeth_card *card)
 {
-	char buf[255];
-	int offset = 0;
+	int rc;
+
+	QETH_DBF_TEXT(trace,3,"sttso");
 
-	offset += sprintf(buf, "IPAssist options of %s: ", card->info.if_name);
-	if (qeth_is_enabled(card, IPA_ARP_PROCESSING))
-		offset += sprintf(buf+offset, "ARP ");
-	if (qeth_is_enabled(card, IPA_IP_FRAGMENTATION))
-		offset += sprintf(buf+offset, "IP_FRAG");
-	if (qeth_is_enabled(card, IPA_SOURCE_MAC))
-		offset += sprintf(buf+offset, "SRC_MAC");
-	if (qeth_is_enabled(card, IPA_FULL_VLAN))
-		offset += sprintf(buf+offset, "VLAN");
-	if (qeth_is_enabled(card, IPA_VLAN_PRIO))
-		offset += sprintf(buf+offset, "VLAN_PRIO");
+	if (!qeth_is_supported(card, IPA_OUTBOUND_TSO)) {
+		PRINT_WARN("Outbound TSO not supported on %s\n",
+			   QETH_CARD_IFNAME(card));
+		rc = -EOPNOTSUPP;
+	} else {
+		rc = qeth_send_simple_setassparms(card, IPA_OUTBOUND_TSO,
+						  IPA_CMD_ASS_START,0);
+		if (rc)
+			PRINT_WARN("Could not start outbound TSO "
+				   "assist on %s: rc=%i\n",
+				   QETH_CARD_IFNAME(card), rc);
+		else
+			PRINT_INFO("Outbound TSO enabled\n");
+	}
+	if (rc && (card->options.large_send == QETH_LARGE_SEND_TSO)){
+		card->options.large_send = QETH_LARGE_SEND_NO;
+		card->dev->features &= ~ (NETIF_F_TSO | NETIF_F_SG);
+	}
+	return rc;
 }
-*/
 
 static int
 qeth_start_ipassists(struct qeth_card *card)
@@ -6525,6 +6925,7 @@ qeth_start_ipassists(struct qeth_card *c
 	qeth_start_ipa_ipv6(card);		/* go on*/
 	qeth_start_ipa_broadcast(card);		/* go on*/
 	qeth_start_ipa_checksum(card);		/* go on*/
+	qeth_start_ipa_tso(card);		/* go on*/
 	return 0;
 }
 
@@ -6636,6 +7037,40 @@ qeth_setrouting_v6(struct qeth_card *car
 	return rc;
 }
 
+int
+qeth_set_large_send(struct qeth_card *card)
+{
+	int rc = 0;
+
+	if (card->dev == NULL)
+		return 0;
+
+	netif_stop_queue(card->dev);
+	switch (card->options.large_send) {
+	case QETH_LARGE_SEND_EDDP:
+		card->dev->features |= NETIF_F_TSO | NETIF_F_SG;
+		break;
+	case QETH_LARGE_SEND_TSO:
+		if (qeth_is_supported(card, IPA_OUTBOUND_TSO)){
+			card->dev->features |= NETIF_F_TSO | NETIF_F_SG;
+		} else {
+			PRINT_WARN("TSO not supported on %s. "
+				   "large_send set to 'no'.\n",
+				   card->dev->name);
+			card->dev->features &= ~(NETIF_F_TSO | NETIF_F_SG);
+			card->options.large_send = QETH_LARGE_SEND_NO;
+			rc = -EOPNOTSUPP;
+		}
+		break;
+	default: /* includes QETH_LARGE_SEND_NO */
+		card->dev->features &= ~(NETIF_F_TSO | NETIF_F_SG);
+		break;
+	}
+
+	netif_wake_queue(card->dev);
+	return rc;
+}
+
 /*
  * softsetup card: init IPA stuff
  */
@@ -6673,6 +7108,12 @@ qeth_softsetup_card(struct qeth_card *ca
 #endif
 		goto out;
 	}
+	if ((card->options.large_send == QETH_LARGE_SEND_EDDP) ||
+	    (card->options.large_send == QETH_LARGE_SEND_TSO))
+		card->dev->features |= NETIF_F_TSO | NETIF_F_SG;
+	else
+		card->dev->features &= ~(NETIF_F_TSO | NETIF_F_SG);
+
 	if ((rc = qeth_setadapter_parms(card)))
 		QETH_DBF_TEXT_(setup, 2, "2err%d", rc);
 	if ((rc = qeth_start_ipassists(card)))
@@ -6809,7 +7250,7 @@ qeth_wait_for_threads(struct qeth_card *
 }
 
 static int
-qeth_stop_card(struct qeth_card *card)
+qeth_stop_card(struct qeth_card *card, int recovery_mode)
 {
 	int rc = 0;
 
@@ -6822,9 +7263,13 @@ qeth_stop_card(struct qeth_card *card)
 	if (card->read.state == CH_STATE_UP &&
 	    card->write.state == CH_STATE_UP &&
 	    (card->state == CARD_STATE_UP)) {
-		rtnl_lock();
-		dev_close(card->dev);
-		rtnl_unlock();
+		if(recovery_mode) {
+			qeth_stop(card->dev);
+		} else {
+			rtnl_lock();
+			dev_close(card->dev);
+			rtnl_unlock();
+		}
 		if (!card->use_hard_stop) {
 			__u8 *mac = &card->dev->dev_addr[0];
 			rc = qeth_layer2_send_delmac(card, mac);
@@ -6996,13 +7441,17 @@ qeth_register_netdev(struct qeth_card *c
 }
 
 static void
-qeth_start_again(struct qeth_card *card)
+qeth_start_again(struct qeth_card *card, int recovery_mode)
 {
 	QETH_DBF_TEXT(setup ,2, "startag");
 
-	rtnl_lock();
-	dev_open(card->dev);
-	rtnl_unlock();
+	if(recovery_mode) {
+		qeth_open(card->dev);
+	} else {
+		rtnl_lock();
+		dev_open(card->dev);
+		rtnl_unlock();
+	}
 	/* this also sets saved unicast addresses */
 	qeth_set_multicast_list(card->dev);
 }
@@ -7059,7 +7508,7 @@ static void qeth_make_parameters_consist
 
 
 static int
-qeth_set_online(struct ccwgroup_device *gdev)
+__qeth_set_online(struct ccwgroup_device *gdev, int recovery_mode)
 {
 	struct qeth_card *card = gdev->dev.driver_data;
 	int rc = 0;
@@ -7117,17 +7566,14 @@ qeth_set_online(struct ccwgroup_device *
 	}
 /*maybe it was set offline without ifconfig down
  * we can also use this state for recovery purposes*/
-	if (card->options.layer2)
-		qeth_set_allowed_threads(card, QETH_RECOVER_THREAD, 0);
-	else
-		qeth_set_allowed_threads(card, 0xffffffff, 0);
+	qeth_set_allowed_threads(card, 0xffffffff, 0);
 	if (recover_flag == CARD_STATE_RECOVER)
-		qeth_start_again(card);
+		qeth_start_again(card, recovery_mode);
 	qeth_notify_processes();
 	return 0;
 out_remove:
 	card->use_hard_stop = 1;
-	qeth_stop_card(card);
+	qeth_stop_card(card, 0);
 	ccw_device_set_offline(CARD_DDEV(card));
 	ccw_device_set_offline(CARD_WDEV(card));
 	ccw_device_set_offline(CARD_RDEV(card));
@@ -7138,6 +7584,12 @@ out_remove:
 	return -ENODEV;
 }
 
+static int
+qeth_set_online(struct ccwgroup_device *gdev)
+{
+	return __qeth_set_online(gdev, 0);
+}
+
 static struct ccw_device_id qeth_ids[] = {
 	{CCW_DEVICE(0x1731, 0x01), driver_info:QETH_CARD_TYPE_OSAE},
 	{CCW_DEVICE(0x1731, 0x05), driver_info:QETH_CARD_TYPE_IQD},
diff -purN linux-2.6.11/drivers/s390/net/qeth_mpc.h linux-2.6.12-rc6/drivers/s390/net/qeth_mpc.h
--- linux-2.6.11/drivers/s390/net/qeth_mpc.h	2005-03-02 08:38:08.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_mpc.h	2005-06-06 17:22:29.000000000 +0200
@@ -14,7 +14,7 @@
 
 #include <asm/qeth.h>
 
-#define VERSION_QETH_MPC_H "$Revision: 1.38 $"
+#define VERSION_QETH_MPC_H "$Revision: 1.43 $"
 
 extern const char *VERSION_QETH_MPC_C;
 
@@ -182,6 +182,9 @@ enum qeth_ipa_funcs {
 	IPA_FULL_VLAN           = 0x00004000L,
 	IPA_SOURCE_MAC          = 0x00010000L,
 	IPA_OSA_MC_ROUTER       = 0x00020000L,
+	IPA_QUERY_ARP_ASSIST	= 0x00040000L,
+	IPA_INBOUND_TSO         = 0x00080000L,
+	IPA_OUTBOUND_TSO        = 0x00100000L,
 };
 
 /* SETIP/DELIP IPA Command: ***************************************************/
diff -purN linux-2.6.11/drivers/s390/net/qeth_proc.c linux-2.6.12-rc6/drivers/s390/net/qeth_proc.c
--- linux-2.6.11/drivers/s390/net/qeth_proc.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_proc.c	2005-06-06 17:22:29.000000000 +0200
@@ -236,6 +236,14 @@ qeth_perf_procfile_seq_show(struct seq_f
 		   card->perf_stats.skbs_sent_pack,
 		   card->perf_stats.bufs_sent_pack
 		  );
+	seq_printf(s, "  Skbs sent in SG mode                   : %i\n"
+		      "  Skb fragments sent in SG mode          : %i\n\n",
+		      card->perf_stats.sg_skbs_sent,
+		      card->perf_stats.sg_frags_sent);
+	seq_printf(s, "  large_send tx (in Kbytes)              : %i\n"
+		      "  large_send count                       : %i\n\n",
+		      card->perf_stats.large_send_bytes >> 10,
+		      card->perf_stats.large_send_cnt);
 	seq_printf(s, "  Packing state changes no pkg.->packing : %i/%i\n"
 		      "  Watermarks L/H                         : %i/%i\n"
 		      "  Current buffer usage (outbound q's)    : "
@@ -262,7 +270,7 @@ qeth_perf_procfile_seq_show(struct seq_f
 		      "  Outbound time (in us, incl QDIO)       : %i\n"
 		      "  Outbound count                         : %i\n"
 		      "  Outbound do_QDIO time (in us)          : %i\n"
-		      "  Outbound do_QDIO count                 : %i\n",
+		      "  Outbound do_QDIO count                 : %i\n\n",
 		        card->perf_stats.inbound_time,
 			card->perf_stats.inbound_cnt,
 		        card->perf_stats.inbound_do_qdio_time,
@@ -274,7 +282,6 @@ qeth_perf_procfile_seq_show(struct seq_f
 		        card->perf_stats.outbound_do_qdio_time,
 			card->perf_stats.outbound_do_qdio_cnt
 		  );
-
 	return 0;
 }
 
diff -purN linux-2.6.11/drivers/s390/net/qeth_sys.c linux-2.6.12-rc6/drivers/s390/net/qeth_sys.c
--- linux-2.6.11/drivers/s390/net/qeth_sys.c	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_sys.c	2005-06-06 17:22:29.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  *
- * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.49 $)
+ * linux/drivers/s390/net/qeth_sys.c ($Revision: 1.51 $)
  *
  * Linux on zSeries OSA Express and HiperSockets support
  * This file contains code related to sysfs.
@@ -20,7 +20,7 @@
 #include "qeth_mpc.h"
 #include "qeth_fs.h"
 
-const char *VERSION_QETH_SYS_C = "$Revision: 1.49 $";
+const char *VERSION_QETH_SYS_C = "$Revision: 1.51 $";
 
 /*****************************************************************************/
 /*                                                                           */
@@ -249,6 +249,16 @@ qeth_dev_prioqing_store(struct device *d
 	    (card->state != CARD_STATE_RECOVER))
 		return -EPERM;
 
+	/* check if 1920 devices are supported ,
+	 * if though we have to permit priority queueing
+	 */
+	if (card->qdio.no_out_queues == 1) {
+		PRINT_WARN("Priority queueing disabled due "
+			   "to hardware limitations!\n");
+		card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
+		return -EPERM;
+	}
+
 	tmp = strsep((char **) &buf, "\n");
 	if (!strcmp(tmp, "prio_queueing_prec"))
 		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_PREC;
@@ -731,6 +741,174 @@ qeth_dev_layer2_store(struct device *dev
 static DEVICE_ATTR(layer2, 0644, qeth_dev_layer2_show,
 		   qeth_dev_layer2_store);
 
+static ssize_t
+qeth_dev_large_send_show(struct device *dev, char *buf)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	if (!card)
+		return -EINVAL;
+
+	switch (card->options.large_send) {
+	case QETH_LARGE_SEND_NO:
+		return sprintf(buf, "%s\n", "no");
+	case QETH_LARGE_SEND_EDDP:
+		return sprintf(buf, "%s\n", "EDDP");
+	case QETH_LARGE_SEND_TSO:
+		return sprintf(buf, "%s\n", "TSO");
+	default:
+		return sprintf(buf, "%s\n", "N/A");
+	}
+}
+
+static ssize_t
+qeth_dev_large_send_store(struct device *dev, const char *buf, size_t count)
+{
+	struct qeth_card *card = dev->driver_data;
+	enum qeth_large_send_types type;
+	int rc = 0;
+	char *tmp;
+
+	if (!card)
+		return -EINVAL;
+
+	tmp = strsep((char **) &buf, "\n");
+
+	if (!strcmp(tmp, "no")){
+		type = QETH_LARGE_SEND_NO;
+	} else if (!strcmp(tmp, "EDDP")) {
+		type = QETH_LARGE_SEND_EDDP;
+	} else if (!strcmp(tmp, "TSO")) {
+		type = QETH_LARGE_SEND_TSO;
+	} else {
+		PRINT_WARN("large_send: invalid mode %s!\n", tmp);
+		return -EINVAL;
+	}
+	if (card->options.large_send == type)
+		return count;
+	card->options.large_send = type;
+	if ((rc = qeth_set_large_send(card)))
+		return rc;
+
+	return count;
+}
+
+static DEVICE_ATTR(large_send, 0644, qeth_dev_large_send_show,
+		   qeth_dev_large_send_store);
+
+static ssize_t
+qeth_dev_blkt_show(char *buf, struct qeth_card *card, int value )
+{
+
+	if (!card)
+		return -EINVAL;
+
+	return sprintf(buf, "%i\n", value);
+}
+
+static ssize_t
+qeth_dev_blkt_store(struct qeth_card *card, const char *buf, size_t count,
+			  int *value, int max_value)
+{
+	char *tmp;
+	int i;
+
+	if (!card)
+		return -EINVAL;
+
+	if ((card->state != CARD_STATE_DOWN) &&
+	    (card->state != CARD_STATE_RECOVER))
+		return -EPERM;
+
+	i = simple_strtoul(buf, &tmp, 10);
+	if (i <= max_value) {
+		*value = i;
+	} else {
+		PRINT_WARN("blkt total time: write values between"
+			   " 0 and %d to this file!\n", max_value);
+		return -EINVAL;
+	}
+	return count;
+}
+
+static ssize_t
+qeth_dev_blkt_total_show(struct device *dev, char *buf)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_show(buf, card, card->info.blkt.time_total);
+}
+
+
+static ssize_t
+qeth_dev_blkt_total_store(struct device *dev, const char *buf, size_t count)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_store(card, buf, count,
+				   &card->info.blkt.time_total,1000);
+}
+
+
+
+static DEVICE_ATTR(total, 0644, qeth_dev_blkt_total_show,
+		   qeth_dev_blkt_total_store);
+
+static ssize_t
+qeth_dev_blkt_inter_show(struct device *dev, char *buf)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_show(buf, card, card->info.blkt.inter_packet);
+}
+
+
+static ssize_t
+qeth_dev_blkt_inter_store(struct device *dev, const char *buf, size_t count)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_store(card, buf, count,
+				   &card->info.blkt.inter_packet,100);
+}
+
+static DEVICE_ATTR(inter, 0644, qeth_dev_blkt_inter_show,
+		   qeth_dev_blkt_inter_store);
+
+static ssize_t
+qeth_dev_blkt_inter_jumbo_show(struct device *dev, char *buf)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_show(buf, card,
+				  card->info.blkt.inter_packet_jumbo);
+}
+
+
+static ssize_t
+qeth_dev_blkt_inter_jumbo_store(struct device *dev, const char *buf, size_t count)
+{
+	struct qeth_card *card = dev->driver_data;
+
+	return qeth_dev_blkt_store(card, buf, count,
+				   &card->info.blkt.inter_packet_jumbo,100);
+}
+
+static DEVICE_ATTR(inter_jumbo, 0644, qeth_dev_blkt_inter_jumbo_show,
+		   qeth_dev_blkt_inter_jumbo_store);
+
+static struct device_attribute * qeth_blkt_device_attrs[] = {
+	&dev_attr_total,
+	&dev_attr_inter,
+	&dev_attr_inter_jumbo,
+	NULL,
+};
+
+static struct attribute_group qeth_device_blkt_group = {
+	.name = "blkt",
+	.attrs = (struct attribute **)qeth_blkt_device_attrs,
+};
+
 static struct device_attribute * qeth_device_attrs[] = {
 	&dev_attr_state,
 	&dev_attr_chpid,
@@ -752,6 +930,7 @@ static struct device_attribute * qeth_de
 	&dev_attr_broadcast_mode,
 	&dev_attr_canonical_macaddr,
 	&dev_attr_layer2,
+	&dev_attr_large_send,
 	NULL,
 };
 
@@ -1506,6 +1685,8 @@ qeth_create_device_attributes(struct dev
 		sysfs_remove_group(&dev->kobj, &qeth_device_ipato_group);
 		sysfs_remove_group(&dev->kobj, &qeth_device_vipa_group);
 	}
+	if ((ret = sysfs_create_group(&dev->kobj, &qeth_device_blkt_group)))
+		return ret;
 
 	return ret;
 }
@@ -1517,6 +1698,7 @@ qeth_remove_device_attributes(struct dev
 	sysfs_remove_group(&dev->kobj, &qeth_device_ipato_group);
 	sysfs_remove_group(&dev->kobj, &qeth_device_vipa_group);
 	sysfs_remove_group(&dev->kobj, &qeth_device_rxip_group);
+	sysfs_remove_group(&dev->kobj, &qeth_device_blkt_group);
 }
 
 /**********************/
diff -purN linux-2.6.11/drivers/s390/net/qeth_tso.h linux-2.6.12-rc6/drivers/s390/net/qeth_tso.h
--- linux-2.6.11/drivers/s390/net/qeth_tso.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/qeth_tso.h	2005-06-06 17:22:29.000000000 +0200
@@ -0,0 +1,154 @@
+/*
+ * linux/drivers/s390/net/qeth_tso.h ($Revision: 1.7 $)
+ *
+ * Header file for qeth TCP Segmentation Offload support.
+ *
+ * Copyright 2004 IBM Corporation
+ *
+ *    Author(s): Frank Pavlic <pavlic@de.ibm.com>
+ *
+ *    $Revision: 1.7 $	 $Date: 2005/05/04 20:19:18 $
+ *
+ */
+#ifndef __QETH_TSO_H__
+#define __QETH_TSO_H__
+
+#include <linux/skbuff.h>
+#include <linux/tcp.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#include "qeth.h"
+#include "qeth_mpc.h"
+
+
+static inline struct qeth_hdr_tso *
+qeth_tso_prepare_skb(struct qeth_card *card, struct sk_buff **skb)
+{
+	QETH_DBF_TEXT(trace, 5, "tsoprsk");
+	return qeth_push_skb(card, skb, sizeof(struct qeth_hdr_tso));
+}
+
+/**
+ * fill header for a TSO packet
+ */
+static inline void
+qeth_tso_fill_header(struct qeth_card *card, struct sk_buff *skb)
+{
+	struct qeth_hdr_tso *hdr;
+	struct tcphdr *tcph;
+	struct iphdr *iph;
+
+	QETH_DBF_TEXT(trace, 5, "tsofhdr");
+
+	hdr  = (struct qeth_hdr_tso *) skb->data;
+	iph  = skb->nh.iph;
+	tcph = skb->h.th;
+	/*fix header to TSO values ...*/
+	hdr->hdr.hdr.l3.id = QETH_HEADER_TYPE_TSO;
+	/*set values which are fix for the first approach ...*/
+	hdr->ext.hdr_tot_len = (__u16) sizeof(struct qeth_hdr_ext_tso);
+	hdr->ext.imb_hdr_no  = 1;
+	hdr->ext.hdr_type    = 1;
+	hdr->ext.hdr_version = 1;
+	hdr->ext.hdr_len     = 28;
+	/*insert non-fix values */
+	hdr->ext.mss = skb_shinfo(skb)->tso_size;
+	hdr->ext.dg_hdr_len = (__u16)(iph->ihl*4 + tcph->doff*4);
+	hdr->ext.payload_len = (__u16)(skb->len - hdr->ext.dg_hdr_len -
+				       sizeof(struct qeth_hdr_tso));
+}
+
+/**
+ * change some header values as requested by hardware
+ */
+static inline void
+qeth_tso_set_tcpip_header(struct qeth_card *card, struct sk_buff *skb)
+{
+	struct iphdr *iph;
+	struct ipv6hdr *ip6h;
+	struct tcphdr *tcph;
+
+	iph  = skb->nh.iph;
+	ip6h = skb->nh.ipv6h;
+	tcph = skb->h.th;
+
+	tcph->check = 0;
+	if (skb->protocol == ETH_P_IPV6) {
+		ip6h->payload_len = 0;
+		tcph->check = ~csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,
+					       0, IPPROTO_TCP, 0);
+		return;
+	}
+	/*OSA want us to set these values ...*/
+	tcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,
+					 0, IPPROTO_TCP, 0);
+	iph->tot_len = 0;
+	iph->check = 0;
+}
+
+static inline int
+qeth_tso_prepare_packet(struct qeth_card *card, struct sk_buff *skb,
+			int ipv, int cast_type)
+{
+	struct qeth_hdr_tso *hdr;
+
+	QETH_DBF_TEXT(trace, 5, "tsoprep");
+
+	hdr = (struct qeth_hdr_tso *) qeth_tso_prepare_skb(card, &skb);
+	if (hdr == NULL) {
+		QETH_DBF_TEXT(trace, 4, "tsoperr");
+		return -ENOMEM;
+	}
+	memset(hdr, 0, sizeof(struct qeth_hdr_tso));
+	/*fill first 32 bytes of  qdio header as used
+	 *FIXME: TSO has two struct members
+	 * with different names but same size
+	 * */
+	qeth_fill_header(card, &hdr->hdr, skb, ipv, cast_type);
+	qeth_tso_fill_header(card, skb);
+	qeth_tso_set_tcpip_header(card, skb);
+	return 0;
+}
+
+static inline void
+__qeth_fill_buffer_frag(struct sk_buff *skb, struct qdio_buffer *buffer,
+			int is_tso, int *next_element_to_fill)
+{
+	struct skb_frag_struct *frag;
+	int fragno;
+	unsigned long addr;
+	int element, cnt, dlen;
+	
+	fragno = skb_shinfo(skb)->nr_frags;
+	element = *next_element_to_fill;
+	dlen = 0;
+	
+	if (is_tso)
+		buffer->element[element].flags =
+			SBAL_FLAGS_MIDDLE_FRAG;
+	else
+		buffer->element[element].flags =
+			SBAL_FLAGS_FIRST_FRAG;
+	if ( (dlen = (skb->len - skb->data_len)) ) {
+		buffer->element[element].addr = skb->data;
+		buffer->element[element].length = dlen;
+		element++;
+	}
+	for (cnt = 0; cnt < fragno; cnt++) {
+		frag = &skb_shinfo(skb)->frags[cnt];
+		addr = (page_to_pfn(frag->page) << PAGE_SHIFT) +
+			frag->page_offset;
+		buffer->element[element].addr = (char *)addr;
+		buffer->element[element].length = frag->size;
+		if (cnt < (fragno - 1))
+			buffer->element[element].flags =
+				SBAL_FLAGS_MIDDLE_FRAG;
+		else
+			buffer->element[element].flags =
+				SBAL_FLAGS_LAST_FRAG;
+		element++;
+	}
+	*next_element_to_fill = element;
+}
+#endif /* __QETH_TSO_H__ */
diff -purN linux-2.6.11/drivers/s390/net/smsgiucv.c linux-2.6.12-rc6/drivers/s390/net/smsgiucv.c
--- linux-2.6.11/drivers/s390/net/smsgiucv.c	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/smsgiucv.c	2005-06-06 17:22:29.000000000 +0200
@@ -32,7 +32,7 @@ struct smsg_callback {
 	struct list_head list;
 	char *prefix;
 	int len;
-	void (*callback)(char *str);
+	void (*callback)(char *from, char *str);
 };
 
 MODULE_AUTHOR
@@ -55,8 +55,9 @@ smsg_message_pending(iucv_MessagePending
 {
 	struct smsg_callback *cb;
 	unsigned char *msg;
+	unsigned char sender[9];
 	unsigned short len;
-	int rc;
+	int rc, i;
 
 	len = eib->ln1msg2.ipbfln1f;
 	msg = kmalloc(len + 1, GFP_ATOMIC|GFP_DMA);
@@ -69,10 +70,18 @@ smsg_message_pending(iucv_MessagePending
 	if (rc == 0) {
 		msg[len] = 0;
 		EBCASC(msg, len);
+		memcpy(sender, msg, 8);
+		sender[8] = 0;
+		/* Remove trailing whitespace from the sender name. */
+		for (i = 7; i >= 0; i--) {
+			if (sender[i] != ' ' && sender[i] != '\t')
+				break;
+			sender[i] = 0;
+		}
 		spin_lock(&smsg_list_lock);
 		list_for_each_entry(cb, &smsg_list, list)
 			if (strncmp(msg + 8, cb->prefix, cb->len) == 0) {
-				cb->callback(msg + 8);
+				cb->callback(sender, msg + 8);
 				break;
 			}
 		spin_unlock(&smsg_list_lock);
@@ -91,7 +100,7 @@ static struct device_driver smsg_driver 
 };
 
 int
-smsg_register_callback(char *prefix, void (*callback)(char *str))
+smsg_register_callback(char *prefix, void (*callback)(char *from, char *str))
 {
 	struct smsg_callback *cb;
 
@@ -108,7 +117,7 @@ smsg_register_callback(char *prefix, voi
 }
 
 void
-smsg_unregister_callback(char *prefix, void (*callback)(char *str))
+smsg_unregister_callback(char *prefix, void (*callback)(char *from, char *str))
 {
 	struct smsg_callback *cb, *tmp;
 
diff -purN linux-2.6.11/drivers/s390/net/smsgiucv.h linux-2.6.12-rc6/drivers/s390/net/smsgiucv.h
--- linux-2.6.11/drivers/s390/net/smsgiucv.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/net/smsgiucv.h	2005-06-06 17:22:29.000000000 +0200
@@ -5,6 +5,6 @@
  * Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
  */
 
-int  smsg_register_callback(char *, void (*)(char *));
-void smsg_unregister_callback(char *, void (*)(char *));
+int  smsg_register_callback(char *, void (*)(char *, char *));
+void smsg_unregister_callback(char *, void (*)(char *, char *));
 
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_aux.c linux-2.6.12-rc6/drivers/s390/scsi/zfcp_aux.c
--- linux-2.6.11/drivers/s390/scsi/zfcp_aux.c	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_aux.c	2005-06-06 17:22:29.000000000 +0200
@@ -52,19 +52,18 @@ static inline int zfcp_sg_list_copy_from
 static inline int zfcp_sg_list_copy_to_user(void __user *,
 					    struct zfcp_sg_list *, size_t);
 
-static int zfcp_cfdc_dev_ioctl(struct inode *, struct file *,
-	unsigned int, unsigned long);
+static long zfcp_cfdc_dev_ioctl(struct file *, unsigned int, unsigned long);
 
 #define ZFCP_CFDC_IOC_MAGIC                     0xDD
 #define ZFCP_CFDC_IOC \
 	_IOWR(ZFCP_CFDC_IOC_MAGIC, 0, struct zfcp_cfdc_sense_data)
 
-#ifdef CONFIG_COMPAT
-static struct ioctl_trans zfcp_ioctl_trans = {ZFCP_CFDC_IOC, (void*) sys_ioctl};
-#endif
 
 static struct file_operations zfcp_cfdc_fops = {
-	.ioctl = zfcp_cfdc_dev_ioctl
+	.unlocked_ioctl = zfcp_cfdc_dev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = zfcp_cfdc_dev_ioctl
+#endif
 };
 
 static struct miscdevice zfcp_cfdc_misc = {
@@ -89,10 +88,10 @@ MODULE_DESCRIPTION
     ("FCP (SCSI over Fibre Channel) HBA driver for IBM eServer zSeries");
 MODULE_LICENSE("GPL");
 
-module_param(device, charp, 0);
+module_param(device, charp, 0400);
 MODULE_PARM_DESC(device, "specify initial device");
 
-module_param(loglevel, uint, 0);
+module_param(loglevel, uint, 0400);
 MODULE_PARM_DESC(loglevel,
 		 "log levels, 8 nibbles: "
 		 "FC ERP QDIO CIO Config FSF SCSI Other, "
@@ -308,23 +307,16 @@ zfcp_module_init(void)
 	if (!zfcp_transport_template)
 		return -ENODEV;
 
-	retval = register_ioctl32_conversion(zfcp_ioctl_trans.cmd,
-					     zfcp_ioctl_trans.handler);
-	if (retval != 0) {
-		ZFCP_LOG_INFO("registration of ioctl32 conversion failed\n");
-		goto out;
-	}
-
 	retval = misc_register(&zfcp_cfdc_misc);
 	if (retval != 0) {
 		ZFCP_LOG_INFO("registration of misc device "
 			      "zfcp_cfdc failed\n");
-		goto out_misc_register;
-	} else {
-		ZFCP_LOG_TRACE("major/minor for zfcp_cfdc: %d/%d\n",
-			       ZFCP_CFDC_DEV_MAJOR, zfcp_cfdc_misc.minor);
+		goto out;
 	}
 
+	ZFCP_LOG_TRACE("major/minor for zfcp_cfdc: %d/%d\n",
+		       ZFCP_CFDC_DEV_MAJOR, zfcp_cfdc_misc.minor);
+
 	/* Initialise proc semaphores */
 	sema_init(&zfcp_data.config_sema, 1);
 
@@ -348,8 +340,6 @@ zfcp_module_init(void)
 
  out_ccw_register:
 	misc_deregister(&zfcp_cfdc_misc);
- out_misc_register:
-	unregister_ioctl32_conversion(zfcp_ioctl_trans.cmd);
  out:
 	return retval;
 }
@@ -370,9 +360,9 @@ zfcp_module_init(void)
  *              -EPERM      - Cannot create or queue FSF request or create SBALs
  *              -ERESTARTSYS- Received signal (is mapped to EAGAIN by VFS)
  */
-static int
-zfcp_cfdc_dev_ioctl(struct inode *inode, struct file *file,
-                    unsigned int command, unsigned long buffer)
+static long
+zfcp_cfdc_dev_ioctl(struct file *file, unsigned int command,
+		    unsigned long buffer)
 {
 	struct zfcp_cfdc_sense_data *sense_data, __user *sense_data_user;
 	struct zfcp_adapter *adapter = NULL;
@@ -583,7 +573,7 @@ zfcp_sg_list_alloc(struct zfcp_sg_list *
 		retval = -ENOMEM;
 		goto out;
 	}
-	memset(sg_list->sg, sg_list->count * sizeof(struct scatterlist), 0);
+	memset(sg_list->sg, 0, sg_list->count * sizeof(struct scatterlist));
 
 	for (i = 0, sg = sg_list->sg; i < sg_list->count; i++, sg++) {
 		sg->length = min(size, PAGE_SIZE);
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_def.h linux-2.6.12-rc6/drivers/s390/scsi/zfcp_def.h
--- linux-2.6.11/drivers/s390/scsi/zfcp_def.h	2005-03-02 08:38:10.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_def.h	2005-06-06 17:22:29.000000000 +0200
@@ -61,7 +61,6 @@
 #include <linux/mempool.h>
 #include <linux/syscalls.h>
 #include <linux/ioctl.h>
-#include <linux/ioctl32.h>
 
 /************************ DEBUG FLAGS *****************************************/
 
@@ -70,7 +69,7 @@
 /********************* GENERAL DEFINES *********************************/
 
 /* zfcp version number, it consists of major, minor, and patch-level number */
-#define ZFCP_VERSION		"4.2.0"
+#define ZFCP_VERSION		"4.3.0"
 
 /**
  * zfcp_sg_to_address - determine kernel address from struct scatterlist
@@ -851,6 +850,9 @@ struct zfcp_adapter {
 	wwn_t			wwnn;	           /* WWNN */
 	wwn_t			wwpn;	           /* WWPN */
 	fc_id_t			s_id;	           /* N_Port ID */
+	wwn_t			peer_wwnn;	   /* P2P peer WWNN */
+	wwn_t			peer_wwpn;	   /* P2P peer WWPN */
+	fc_id_t			peer_d_id;	   /* P2P peer D_ID */
 	struct ccw_device       *ccw_device;	   /* S/390 ccw device */
 	u8			fc_service_class;
 	u32			fc_topology;	   /* FC topology */
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_erp.c linux-2.6.12-rc6/drivers/s390/scsi/zfcp_erp.c
--- linux-2.6.11/drivers/s390/scsi/zfcp_erp.c	2005-03-02 08:38:34.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_erp.c	2005-06-06 17:22:29.000000000 +0200
@@ -2568,6 +2568,23 @@ zfcp_erp_port_strategy_open_common(struc
 	case ZFCP_ERP_STEP_UNINITIALIZED:
 	case ZFCP_ERP_STEP_PHYS_PORT_CLOSING:
 	case ZFCP_ERP_STEP_PORT_CLOSING:
+		if (adapter->fc_topology == FSF_TOPO_P2P) {
+			if (port->wwpn != adapter->peer_wwpn) {
+				ZFCP_LOG_NORMAL("Failed to open port 0x%016Lx "
+						"on adapter %s.\nPeer WWPN "
+						"0x%016Lx does not match\n",
+						port->wwpn,
+						zfcp_get_busid_by_adapter(adapter),
+						adapter->peer_wwpn);
+				zfcp_erp_port_failed(port);
+				retval = ZFCP_ERP_FAILED;
+				break;
+			}
+			port->d_id = adapter->peer_d_id;
+			atomic_set_mask(ZFCP_STATUS_PORT_DID_DID, &port->status);
+			retval = zfcp_erp_port_strategy_open_port(erp_action);
+			break;
+		}
 		if (!(adapter->nameserver_port)) {
 			retval = zfcp_nameserver_enqueue(adapter);
 			if (retval != 0) {
@@ -3516,8 +3533,9 @@ zfcp_erp_adapter_access_changed(struct z
 	debug_text_event(adapter->erp_dbf, 3, "a_access_unblock");
 	debug_event(adapter->erp_dbf, 3, &adapter->name, 8);
 
-	zfcp_erp_port_access_changed(adapter->nameserver_port);
 	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	if (adapter->nameserver_port)
+		zfcp_erp_port_access_changed(adapter->nameserver_port);
 	list_for_each_entry(port, &adapter->port_list_head, list)
 		if (port != adapter->nameserver_port)
 			zfcp_erp_port_access_changed(port);
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_fsf.c linux-2.6.12-rc6/drivers/s390/scsi/zfcp_fsf.c
--- linux-2.6.11/drivers/s390/scsi/zfcp_fsf.c	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_fsf.c	2005-06-06 17:22:29.000000000 +0200
@@ -2107,6 +2107,9 @@ zfcp_fsf_exchange_config_evaluate(struct
 		       bottom->low_qtcb_version, bottom->high_qtcb_version);
 	adapter->fsf_lic_version = bottom->lic_version;
 	adapter->supported_features = bottom->supported_features;
+	adapter->peer_wwpn = 0;
+	adapter->peer_wwnn = 0;
+	adapter->peer_d_id = 0;
 
 	if (xchg_ok) {
 		adapter->wwnn = bottom->nport_serv_param.wwnn;
@@ -2124,13 +2127,19 @@ zfcp_fsf_exchange_config_evaluate(struct
 		adapter->hydra_version = 0;
 	}
 
+	if (adapter->fc_topology == FSF_TOPO_P2P) {
+		adapter->peer_d_id = bottom->peer_d_id & ZFCP_DID_MASK;
+		adapter->peer_wwpn = bottom->plogi_payload.wwpn;
+		adapter->peer_wwnn = bottom->plogi_payload.wwnn;
+	}
+
 	if(adapter->supported_features & FSF_FEATURE_HBAAPI_MANAGEMENT){
 		adapter->hardware_version = bottom->hardware_version;
 		memcpy(adapter->serial_number, bottom->serial_number, 17);
 		EBCASC(adapter->serial_number, sizeof(adapter->serial_number));
 	}
 
-	ZFCP_LOG_INFO("The adapter %s reported the following characteristics:\n"
+	ZFCP_LOG_NORMAL("The adapter %s reported the following characteristics:\n"
 		      "WWNN 0x%016Lx, "
 		      "WWPN 0x%016Lx, "
 		      "S_ID 0x%08x,\n"
@@ -2194,14 +2203,18 @@ zfcp_fsf_exchange_config_data_handler(st
 		switch (adapter->fc_topology) {
 		case FSF_TOPO_P2P:
 			ZFCP_LOG_FLAGS(1, "FSF_TOPO_P2P\n");
-			ZFCP_LOG_NORMAL("error: Point-to-point fibrechannel "
-					"configuration detected at adapter %s "
-					"unsupported, shutting down adapter\n",
-					zfcp_get_busid_by_adapter(adapter));
+			ZFCP_LOG_NORMAL("Point-to-Point fibrechannel "
+					"configuration detected at adapter %s\n"
+					"Peer WWNN 0x%016llx, "
+					"peer WWPN 0x%016llx, "
+					"peer d_id 0x%06x\n",
+					zfcp_get_busid_by_adapter(adapter),
+					adapter->peer_wwnn,
+					adapter->peer_wwpn,
+					adapter->peer_d_id);
 			debug_text_event(fsf_req->adapter->erp_dbf, 0,
 					 "top-p-to-p");
-			zfcp_erp_adapter_shutdown(adapter, 0);
-			return -EIO;
+			break;
 		case FSF_TOPO_AL:
 			ZFCP_LOG_FLAGS(1, "FSF_TOPO_AL\n");
 			ZFCP_LOG_NORMAL("error: Arbitrated loop fibrechannel "
@@ -2226,6 +2239,7 @@ zfcp_fsf_exchange_config_data_handler(st
 					"of a type known to the zfcp "
 					"driver, shutting down adapter\n",
 					zfcp_get_busid_by_adapter(adapter));
+			adapter->fc_topology = FSF_TOPO_ERROR;
 			debug_text_exception(fsf_req->adapter->erp_dbf, 0,
 					     "unknown-topo");
 			zfcp_erp_adapter_shutdown(adapter, 0);
@@ -4281,6 +4295,7 @@ zfcp_fsf_send_fcp_command_task_handler(s
 				      bottom.io.fcp_cmnd, FSF_FCP_CMND_SIZE);
 			zfcp_cmd_dbf_event_fsf("undeffcp", fsf_req, NULL, 0);
 			set_host_byte(&scpnt->result, DID_ERROR);
+			goto skip_fsfstatus;
 		}
 	}
 
@@ -4334,7 +4349,7 @@ zfcp_fsf_send_fcp_command_task_handler(s
 
 		scpnt->resid = fcp_rsp_iu->fcp_resid;
 		if (scpnt->request_bufflen - scpnt->resid < scpnt->underflow)
-			scpnt->result |= DID_ERROR << 16;
+			set_host_byte(&scpnt->result, DID_ERROR);
 	}
 
  skip_fsfstatus:
@@ -4607,6 +4622,13 @@ zfcp_fsf_control_file_handler(struct zfc
 		if (bottom->operation_subtype == FSF_CFDC_OPERATION_SUBTYPE) {
 			switch (header->fsf_status_qual.word[0]) {
 
+			case FSF_SQ_CFDC_HARDENED_ON_SE:
+				ZFCP_LOG_NORMAL(
+					"CFDC on the adapter %s has being "
+					"hardened on primary and secondary SE\n",
+					zfcp_get_busid_by_adapter(adapter));
+				break;
+
 			case FSF_SQ_CFDC_COULD_NOT_HARDEN_ON_SE:
 				ZFCP_LOG_NORMAL(
 					"CFDC of the adapter %s could not "
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_fsf.h linux-2.6.12-rc6/drivers/s390/scsi/zfcp_fsf.h
--- linux-2.6.11/drivers/s390/scsi/zfcp_fsf.h	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_fsf.h	2005-06-06 17:22:29.000000000 +0200
@@ -129,6 +129,7 @@
 #define FSF_SQ_NO_RETRY_POSSIBLE		0x07
 
 /* FSF status qualifier for CFDC commands */
+#define FSF_SQ_CFDC_HARDENED_ON_SE		0x00000000
 #define FSF_SQ_CFDC_COULD_NOT_HARDEN_ON_SE	0x00000001
 #define FSF_SQ_CFDC_COULD_NOT_HARDEN_ON_SE2	0x00000002
 /* CFDC subtable codes */
@@ -357,7 +358,6 @@ struct fsf_nport_serv_param {
 	u8  class3_serv_param[16];
 	u8  class4_serv_param[16];
 	u8  vendor_version_level[16];
-	u8  res1[16];
 } __attribute__ ((packed));
 
 struct fsf_plogi {
@@ -415,11 +415,13 @@ struct fsf_qtcb_bottom_config {
 	u8 res2[12];
 	u32 s_id;
 	struct fsf_nport_serv_param nport_serv_param;
+	u8 reserved_nport_serv_param[16];
 	u8 res3[8];
 	u32 adapter_ports;
 	u32 hardware_version;
 	u8 serial_number[32];
-	u8 res4[272];
+	struct fsf_nport_serv_param plogi_payload;
+	u8 res4[160];
 } __attribute__ ((packed));
 
 struct fsf_qtcb_bottom_port {
diff -purN linux-2.6.11/drivers/s390/scsi/zfcp_sysfs_adapter.c linux-2.6.12-rc6/drivers/s390/scsi/zfcp_sysfs_adapter.c
--- linux-2.6.11/drivers/s390/scsi/zfcp_sysfs_adapter.c	2005-03-02 08:37:31.000000000 +0100
+++ linux-2.6.12-rc6/drivers/s390/scsi/zfcp_sysfs_adapter.c	2005-06-06 17:22:29.000000000 +0200
@@ -65,6 +65,9 @@ ZFCP_DEFINE_ADAPTER_ATTR(status, "0x%08x
 ZFCP_DEFINE_ADAPTER_ATTR(wwnn, "0x%016llx\n", adapter->wwnn);
 ZFCP_DEFINE_ADAPTER_ATTR(wwpn, "0x%016llx\n", adapter->wwpn);
 ZFCP_DEFINE_ADAPTER_ATTR(s_id, "0x%06x\n", adapter->s_id);
+ZFCP_DEFINE_ADAPTER_ATTR(peer_wwnn, "0x%016llx\n", adapter->peer_wwnn);
+ZFCP_DEFINE_ADAPTER_ATTR(peer_wwpn, "0x%016llx\n", adapter->peer_wwpn);
+ZFCP_DEFINE_ADAPTER_ATTR(peer_d_id, "0x%06x\n", adapter->peer_d_id);
 ZFCP_DEFINE_ADAPTER_ATTR(card_version, "0x%04x\n", adapter->hydra_version);
 ZFCP_DEFINE_ADAPTER_ATTR(lic_version, "0x%08x\n", adapter->fsf_lic_version);
 ZFCP_DEFINE_ADAPTER_ATTR(fc_link_speed, "%d Gb/s\n", adapter->fc_link_speed);
@@ -255,6 +258,9 @@ static struct attribute *zfcp_adapter_at
 	&dev_attr_wwnn.attr,
 	&dev_attr_wwpn.attr,
 	&dev_attr_s_id.attr,
+	&dev_attr_peer_wwnn.attr,
+	&dev_attr_peer_wwpn.attr,
+	&dev_attr_peer_d_id.attr,
 	&dev_attr_card_version.attr,
 	&dev_attr_lic_version.attr,
 	&dev_attr_fc_link_speed.attr,
diff -purN linux-2.6.11/include/asm-s390/atomic.h linux-2.6.12-rc6/include/asm-s390/atomic.h
--- linux-2.6.11/include/asm-s390/atomic.h	2005-03-02 08:37:48.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/atomic.h	2005-06-06 17:22:29.000000000 +0200
@@ -61,6 +61,10 @@ static __inline__ void atomic_sub(int i,
 {
 	       __CS_LOOP(v, i, "sr");
 }
+static __inline__ int atomic_sub_return(int i, atomic_t * v)
+{
+	return __CS_LOOP(v, i, "sr");
+}
 static __inline__ void atomic_inc(volatile atomic_t * v)
 {
 	       __CS_LOOP(v, 1, "ar");
diff -purN linux-2.6.11/include/asm-s390/bug.h linux-2.6.12-rc6/include/asm-s390/bug.h
--- linux-2.6.11/include/asm-s390/bug.h	2005-03-02 08:38:17.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/bug.h	2005-06-06 17:22:29.000000000 +0200
@@ -3,12 +3,15 @@
 
 #include <linux/kernel.h>
 
+#ifdef CONFIG_BUG
 #define BUG() do { \
         printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
         __asm__ __volatile__(".long 0"); \
 } while (0)
 
 #define HAVE_ARCH_BUG
+#endif
+
 #include <asm-generic/bug.h>
 
 #endif
diff -purN linux-2.6.11/include/asm-s390/ccwdev.h linux-2.6.12-rc6/include/asm-s390/ccwdev.h
--- linux-2.6.11/include/asm-s390/ccwdev.h	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/ccwdev.h	2005-06-06 17:22:29.000000000 +0200
@@ -164,6 +164,8 @@ extern int ccw_device_clear(struct ccw_d
 
 extern int read_dev_chars(struct ccw_device *cdev, void **buffer, int length);
 extern int read_conf_data(struct ccw_device *cdev, void **buffer, int *length);
+extern int read_conf_data_lpm(struct ccw_device *cdev, void **buffer,
+			      int *length, __u8 lpm);
 
 extern int ccw_device_set_online(struct ccw_device *cdev);
 extern int ccw_device_set_offline(struct ccw_device *cdev);
@@ -186,4 +188,5 @@ extern int _ccw_device_get_subchannel_nu
 extern struct device *s390_root_dev_register(const char *);
 extern void s390_root_dev_unregister(struct device *);
 
+extern void *ccw_device_get_chp_desc(struct ccw_device *, int);
 #endif /* _S390_CCWDEV_H_ */
diff -purN linux-2.6.11/include/asm-s390/cmb.h linux-2.6.12-rc6/include/asm-s390/cmb.h
--- linux-2.6.11/include/asm-s390/cmb.h	2005-03-02 08:38:37.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/cmb.h	2005-06-06 17:22:29.000000000 +0200
@@ -52,7 +52,7 @@ struct cmbdata {
 #define BIODASDREADALLCMB	_IOWR(DASD_IOCTL_LETTER,33,struct cmbdata)
 
 #ifdef __KERNEL__
-
+struct ccw_device;
 /**
  * enable_cmf() - switch on the channel measurement for a specific device
  *  @cdev:	The ccw device to be enabled
diff -purN linux-2.6.11/include/asm-s390/cputime.h linux-2.6.12-rc6/include/asm-s390/cputime.h
--- linux-2.6.11/include/asm-s390/cputime.h	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/cputime.h	2005-06-06 17:22:29.000000000 +0200
@@ -9,6 +9,8 @@
 #ifndef _S390_CPUTIME_H
 #define _S390_CPUTIME_H
 
+#include <asm/div64.h>
+
 /* We want to use micro-second resolution. */
 
 typedef unsigned long long cputime_t;
@@ -40,6 +42,12 @@ __div(unsigned long long n, unsigned int
 #define cputime_max			((~0UL >> 1) - 1)
 #define cputime_add(__a, __b)		((__a) +  (__b))
 #define cputime_sub(__a, __b)		((__a) -  (__b))
+#define cputime_div(__a, __n) ({		\
+	unsigned long long __div = (__a);	\
+	do_div(__div,__n);			\
+	__div;					\
+})
+#define cputime_halve(__a)		((__a) >> 1)
 #define cputime_eq(__a, __b)		((__a) == (__b))
 #define cputime_gt(__a, __b)		((__a) >  (__b))
 #define cputime_ge(__a, __b)		((__a) >= (__b))
diff -purN linux-2.6.11/include/asm-s390/debug.h linux-2.6.12-rc6/include/asm-s390/debug.h
--- linux-2.6.11/include/asm-s390/debug.h	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/debug.h	2005-06-06 17:22:29.000000000 +0200
@@ -43,7 +43,7 @@ struct __debug_entry{
 #define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
 #define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
 #define DEBUG_MAX_VIEWS            10 /* max number of views in proc fs */
-#define DEBUG_MAX_PROCF_LEN        16 /* max length for a proc file name */
+#define DEBUG_MAX_PROCF_LEN        64 /* max length for a proc file name */
 #define DEBUG_DEFAULT_LEVEL        3  /* initial debug level */
 
 #define DEBUG_DIR_ROOT "s390dbf" /* name of debug root directory in proc fs */
diff -purN linux-2.6.11/include/asm-s390/io.h linux-2.6.12-rc6/include/asm-s390/io.h
--- linux-2.6.11/include/asm-s390/io.h	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/io.h	2005-06-06 17:22:29.000000000 +0200
@@ -107,6 +107,17 @@ extern void iounmap(void *addr);
 
 #define mmiowb()
 
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
 #endif /* __KERNEL__ */
 
 #endif
diff -purN linux-2.6.11/include/asm-s390/page.h linux-2.6.12-rc6/include/asm-s390/page.h
--- linux-2.6.11/include/asm-s390/page.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/page.h	2005-06-06 17:22:29.000000000 +0200
@@ -16,6 +16,8 @@
 #define PAGE_SHIFT      12
 #define PAGE_SIZE       (1UL << PAGE_SHIFT)
 #define PAGE_MASK       (~(PAGE_SIZE-1))
+#define PAGE_DEFAULT_ACC	0
+#define PAGE_DEFAULT_KEY	(PAGE_DEFAULT_ACC << 4)
 
 #ifdef __KERNEL__
 #ifndef __ASSEMBLY__
diff -purN linux-2.6.11/include/asm-s390/pgtable.h linux-2.6.12-rc6/include/asm-s390/pgtable.h
--- linux-2.6.11/include/asm-s390/pgtable.h	2005-03-02 08:38:18.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/pgtable.h	2005-06-06 17:22:29.000000000 +0200
@@ -756,11 +752,17 @@ extern inline pmd_t * pmd_offset(pgd_t *
  *  0000000000111111111122222222223333333333444444444455 5555 5 55566 66
  *  0123456789012345678901234567890123456789012345678901 2345 6 78901 23
  */
+#ifndef __s390x__
+#define __SWP_OFFSET_MASK (~0UL >> 12)
+#else
+#define __SWP_OFFSET_MASK (~0UL >> 11)
+#endif
 extern inline pte_t mk_swap_pte(unsigned long type, unsigned long offset)
 {
 	pte_t pte;
+	offset &= __SWP_OFFSET_MASK;
 	pte_val(pte) = _PAGE_INVALID_SWAP | ((type & 0x1f) << 2) |
-		((offset & 1) << 7) | ((offset & 0xffffe) << 11);
+		((offset & 1UL) << 7) | ((offset & ~1UL) << 11);
 	return pte;
 }
 
diff -purN linux-2.6.11/include/asm-s390/posix_types.h linux-2.6.12-rc6/include/asm-s390/posix_types.h
--- linux-2.6.11/include/asm-s390/posix_types.h	2005-03-02 08:37:30.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/posix_types.h	2005-06-06 17:22:29.000000000 +0200
@@ -83,16 +83,16 @@ typedef struct {
 #endif
 
 #undef  __FD_SET
-#define __FD_SET(fd,fdsetp)  set_bit(fd,fdsetp->fds_bits)
+#define __FD_SET(fd,fdsetp)  set_bit((fd),(fdsetp)->fds_bits)
 
 #undef  __FD_CLR
-#define __FD_CLR(fd,fdsetp)  clear_bit(fd,fdsetp->fds_bits)
+#define __FD_CLR(fd,fdsetp)  clear_bit((fd),(fdsetp)->fds_bits)
 
 #undef  __FD_ISSET
-#define __FD_ISSET(fd,fdsetp)  test_bit(fd,fdsetp->fds_bits)
+#define __FD_ISSET(fd,fdsetp)  test_bit((fd),(fdsetp)->fds_bits)
 
 #undef  __FD_ZERO
-#define __FD_ZERO(fdsetp) (memset (fdsetp, 0, sizeof(*(fd_set *)fdsetp)))
+#define __FD_ZERO(fdsetp) (memset ((fdsetp), 0, sizeof(*(fd_set *)(fdsetp))))
 
 #endif     /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)*/
 
diff -purN linux-2.6.11/include/asm-s390/processor.h linux-2.6.12-rc6/include/asm-s390/processor.h
--- linux-2.6.11/include/asm-s390/processor.h	2005-06-16 13:52:06.000000000 +0200
+++ linux-2.6.12-rc6/include/asm-s390/processor.h	2005-06-06 17:22:29.000000000 +0200
@@ -248,7 +245,7 @@ static inline void enabled_wait(void)
 	psw_t wait_psw;
 
 	wait_psw.mask = PSW_BASE_BITS | PSW_MASK_IO | PSW_MASK_EXT |
-		PSW_MASK_MCHECK | PSW_MASK_WAIT;
+		PSW_MASK_MCHECK | PSW_MASK_WAIT | PSW_DEFAULT_KEY;
 #ifndef __s390x__
 	asm volatile (
 		"    basr %0,0\n"
diff -purN linux-2.6.11/include/asm-s390/ptrace.h linux-2.6.12-rc6/include/asm-s390/ptrace.h
--- linux-2.6.11/include/asm-s390/ptrace.h	2005-03-02 08:38:13.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/ptrace.h	2005-06-06 17:22:29.000000000 +0200
@@ -185,6 +185,7 @@
 #include <linux/stddef.h>
 #include <linux/types.h>
 #include <asm/setup.h>
+#include <asm/page.h>
 
 typedef union
 {
@@ -235,6 +236,7 @@ typedef struct 
 #define PSW_ADDR_INSN		0x7FFFFFFFUL
 
 #define PSW_BASE_BITS		0x00080000UL
+#define PSW_DEFAULT_KEY		(((unsigned long) PAGE_DEFAULT_ACC) << 20)
 
 #define PSW_ASC_PRIMARY		0x00000000UL
 #define PSW_ASC_ACCREG		0x00004000UL
@@ -260,6 +262,7 @@ typedef struct 
 
 #define PSW_BASE_BITS		0x0000000180000000UL
 #define PSW_BASE32_BITS		0x0000000080000000UL
+#define PSW_DEFAULT_KEY		(((unsigned long) PAGE_DEFAULT_ACC) << 52)
 
 #define PSW_ASC_PRIMARY		0x0000000000000000UL
 #define PSW_ASC_ACCREG		0x0000400000000000UL
@@ -268,14 +271,15 @@ typedef struct 
 
 #define PSW_USER32_BITS (PSW_BASE32_BITS | PSW_MASK_DAT | PSW_ASC_HOME | \
 			 PSW_MASK_IO | PSW_MASK_EXT | PSW_MASK_MCHECK | \
-			 PSW_MASK_PSTATE)
+			 PSW_MASK_PSTATE | PSW_DEFAULT_KEY)
 
 #endif /* __s390x__ */
 
-#define PSW_KERNEL_BITS	(PSW_BASE_BITS | PSW_MASK_DAT | PSW_ASC_PRIMARY)
+#define PSW_KERNEL_BITS	(PSW_BASE_BITS | PSW_MASK_DAT | PSW_ASC_PRIMARY | \
+			 PSW_DEFAULT_KEY)
 #define PSW_USER_BITS	(PSW_BASE_BITS | PSW_MASK_DAT | PSW_ASC_HOME | \
 			 PSW_MASK_IO | PSW_MASK_EXT | PSW_MASK_MCHECK | \
-			 PSW_MASK_PSTATE)
+			 PSW_MASK_PSTATE | PSW_DEFAULT_KEY)
 
 /* This macro merges a NEW PSW mask specified by the user into
    the currently active PSW mask CURRENT, modifying only those
@@ -470,6 +474,12 @@ struct user_regs_struct
 extern void show_regs(struct pt_regs * regs);
 #endif
 
+static inline void
+psw_set_key(unsigned int key)
+{
+	asm volatile ( "spka 0(%0)" : : "d" (key) );
+}
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _S390_PTRACE_H */
diff -purN linux-2.6.11/include/asm-s390/siginfo.h linux-2.6.12-rc6/include/asm-s390/siginfo.h
--- linux-2.6.11/include/asm-s390/siginfo.h	2005-03-02 08:38:25.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/siginfo.h	2005-06-06 17:22:29.000000000 +0200
@@ -13,12 +13,6 @@
 #define __ARCH_SI_PREAMBLE_SIZE (4 * sizeof(int))
 #endif
 
-#ifdef CONFIG_ARCH_S390X
-#define SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE/sizeof(int)) - 4)
-#else
-#define SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE/sizeof(int)) - 3)
-#endif
-
 #include <asm-generic/siginfo.h>
 
 #endif
diff -purN linux-2.6.11/include/asm-s390/smp.h linux-2.6.12-rc6/include/asm-s390/smp.h
--- linux-2.6.11/include/asm-s390/smp.h	2005-03-02 08:38:09.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/smp.h	2005-06-06 17:22:29.000000000 +0200
@@ -18,6 +18,7 @@
 #if defined(__KERNEL__) && defined(CONFIG_SMP) && !defined(__ASSEMBLY__)
 
 #include <asm/lowcore.h>
+#include <asm/sigp.h>
 
 /*
   s390 specific smp.c headers
@@ -59,6 +60,30 @@ extern __inline__ __u16 hard_smp_process
         return cpu_address;
 }
 
+/*
+ * returns 1 if cpu is in stopped/check stopped state or not operational
+ * returns 0 otherwise
+ */
+static inline int
+smp_cpu_not_running(int cpu)
+{
+	__u32 status;
+
+	switch (signal_processor_ps(&status, 0, cpu, sigp_sense)) {
+	case sigp_order_code_accepted:
+	case sigp_status_stored:
+		/* Check for stopped and check stop state */
+		if (status & 0x50)
+			return 1;
+		break;
+	case sigp_not_operational:
+		return 1;
+	default:
+		break;
+	}
+	return 0;
+}
+
 #define cpu_logical_map(cpu) (cpu)
 
 extern int __cpu_disable (void);
diff -purN linux-2.6.11/include/asm-s390/system.h linux-2.6.12-rc6/include/asm-s390/system.h
--- linux-2.6.11/include/asm-s390/system.h	2005-03-02 08:38:33.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/system.h	2005-06-06 17:22:29.000000000 +0200
@@ -335,19 +335,23 @@ __cmpxchg(volatile void *ptr, unsigned l
         __asm__ __volatile__("lpswe 0(%0)" : : "a" (&psw), "m" (psw) : "cc" );
 
 #define __ctl_load(array, low, high) ({ \
+	typedef struct { char _[sizeof(array)]; } addrtype; \
 	__asm__ __volatile__ ( \
 		"   bras  1,0f\n" \
                 "   lctlg 0,0,0(%0)\n" \
 		"0: ex    %1,0(1)" \
-		: : "a" (&array), "a" (((low)<<4)+(high)) : "1" ); \
+		: : "a" (&array), "a" (((low)<<4)+(high)), \
+		    "m" (*(addrtype *)(array)) : "1" ); \
 	})
 
 #define __ctl_store(array, low, high) ({ \
+	typedef struct { char _[sizeof(array)]; } addrtype; \
 	__asm__ __volatile__ ( \
 		"   bras  1,0f\n" \
 		"   stctg 0,0,0(%1)\n" \
 		"0: ex    %2,0(1)" \
-		: "=m" (array) : "a" (&array), "a" (((low)<<4)+(high)) : "1" ); \
+		: "=m" (*(addrtype *)(array)) \
+		: "a" (&array), "a" (((low)<<4)+(high)) : "1" ); \
 	})
 
 #define __ctl_set_bit(cr, bit) ({ \
@@ -390,19 +394,23 @@ __cmpxchg(volatile void *ptr, unsigned l
 	__asm__ __volatile__("lpsw 0(%0)" : : "a" (&psw) : "cc" );
 
 #define __ctl_load(array, low, high) ({ \
+	typedef struct { char _[sizeof(array)]; } addrtype; \
 	__asm__ __volatile__ ( \
 		"   bras  1,0f\n" \
                 "   lctl 0,0,0(%0)\n" \
 		"0: ex    %1,0(1)" \
-		: : "a" (&array), "a" (((low)<<4)+(high)) : "1" ); \
+		: : "a" (&array), "a" (((low)<<4)+(high)), \
+		    "m" (*(addrtype *)(array)) : "1" ); \
 	})
 
 #define __ctl_store(array, low, high) ({ \
+	typedef struct { char _[sizeof(array)]; } addrtype; \
 	__asm__ __volatile__ ( \
 		"   bras  1,0f\n" \
 		"   stctl 0,0,0(%1)\n" \
 		"0: ex    %2,0(1)" \
-		: "=m" (array) : "a" (&array), "a" (((low)<<4)+(high)): "1" ); \
+		: "=m" (*(addrtype *)(array)) \
+		: "a" (&array), "a" (((low)<<4)+(high)): "1" ); \
 	})
 
 #define __ctl_set_bit(cr, bit) ({ \
@@ -461,6 +469,8 @@ extern void (*_machine_restart)(char *co
 extern void (*_machine_halt)(void);
 extern void (*_machine_power_off)(void);
 
+#define arch_align_stack(x) (x)
+
 #endif /* __KERNEL__ */
 
 #endif
diff -purN linux-2.6.11/include/asm-s390/timex.h linux-2.6.12-rc6/include/asm-s390/timex.h
--- linux-2.6.11/include/asm-s390/timex.h	2005-03-02 08:37:31.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/timex.h	2005-06-06 17:22:29.000000000 +0200
@@ -15,8 +15,6 @@
 
 typedef unsigned long long cycles_t;
 
-extern cycles_t cacheflush_time;
-
 static inline cycles_t get_cycles(void)
 {
 	cycles_t cycles;
diff -purN linux-2.6.11/include/asm-s390/uaccess.h linux-2.6.12-rc6/include/asm-s390/uaccess.h
--- linux-2.6.11/include/asm-s390/uaccess.h	2005-03-02 08:37:49.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/uaccess.h	2005-06-06 17:22:29.000000000 +0200
@@ -65,7 +65,8 @@
 
 #define access_ok(type,addr,size) __access_ok(addr,size)
 
-extern inline int verify_area(int type, const void __user *addr,
+/* this function will go away soon - use access_ok() instead */
+extern inline int __deprecated verify_area(int type, const void __user *addr,
 						unsigned long size)
 {
 	return access_ok(type, addr, size) ? 0 : -EFAULT;
@@ -161,7 +162,7 @@ struct exception_table_entry
 		__put_user_asm(__x, ptr, __pu_err);		\
 		break;						\
 	default:						\
-		__pu_err = __put_user_bad();			\
+		__put_user_bad();				\
 		break;						\
 	 }							\
 	__pu_err;						\
@@ -182,7 +183,7 @@ struct exception_table_entry
 })
 
 
-extern int __put_user_bad(void);
+extern int __put_user_bad(void) __attribute__((noreturn));
 
 #if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 2)
 #define __get_user_asm(x, ptr, err) \
@@ -225,8 +226,7 @@ extern int __put_user_bad(void);
 		__get_user_asm(__x, ptr, __gu_err);		\
 		break;						\
 	default:						\
-		__x = 0;					\
-		__gu_err = __get_user_bad();			\
+		__get_user_bad();				\
 		break;						\
 	}							\
 	(x) = __x;						\
@@ -248,7 +248,7 @@ extern int __put_user_bad(void);
 	__get_user(x, ptr);					\
 })
 
-extern int __get_user_bad(void);
+extern int __get_user_bad(void) __attribute__((noreturn));
 
 #define __put_user_unaligned __put_user
 #define __get_user_unaligned __get_user
diff -purN linux-2.6.11/include/asm-s390/unistd.h linux-2.6.12-rc6/include/asm-s390/unistd.h
--- linux-2.6.11/include/asm-s390/unistd.h	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/unistd.h	2005-06-06 17:22:29.000000000 +0200
@@ -259,7 +259,7 @@
 #define __NR_fadvise64_64	264
 #define __NR_statfs64		265
 #define __NR_fstatfs64		266
-/* Number 267 is reserved for new sys_remap_file_pages */
+#define __NR_remap_file_pages	267
 /* Number 268 is reserved for new sys_mbind */
 /* Number 269 is reserved for new sys_get_mempolicy */
 /* Number 270 is reserved for new sys_set_mempolicy */
@@ -270,8 +270,12 @@
 #define __NR_mq_notify		275
 #define __NR_mq_getsetattr	276
 /* Number 277 is reserved for new sys_kexec_load */
+#define __NR_add_key		278
+#define __NR_request_key	279
+#define __NR_keyctl		280
+#define __NR_waitid		281
 
-#define NR_syscalls 278
+#define NR_syscalls 282
 
 /* 
  * There are some system calls that are not present on 64 bit, some
@@ -330,7 +334,6 @@
 #undef  __NR_setgid32
 #undef  __NR_setfsuid32
 #undef  __NR_setfsgid32
-#undef  __NR_getdents64
 #undef  __NR_fcntl64
 #undef  __NR_sendfile64
 #undef  __NR_fadvise64_64
diff -purN linux-2.6.11/include/asm-s390/user.h linux-2.6.12-rc6/include/asm-s390/user.h
--- linux-2.6.11/include/asm-s390/user.h	2005-03-02 08:38:38.000000000 +0100
+++ linux-2.6.12-rc6/include/asm-s390/user.h	2005-06-06 17:22:29.000000000 +0200
@@ -10,7 +10,7 @@
 #define _S390_USER_H
 
 #include <asm/page.h>
-#include <linux/ptrace.h>
+#include <asm/ptrace.h>
 /* Core file format: The core file is written in such a way that gdb
    can understand it and provide useful information to the user (under
    linux we use the 'trad-core' bfd).  There are quite a number of

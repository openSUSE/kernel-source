# This is a BitKeeper generated patch for the following project:
# Project Name: Linux kernel tree
# This patch format is intended for GNU patch command version 2.5 or higher.
# This patch includes the following deltas:
#	           ChangeSet	1.1376  -> 1.1393 
#	arch/i386/kernel/process.c	1.51.1.1 -> 1.53   
#	include/asm-x86_64/agp.h	1.2     -> 1.4    
#	drivers/mtd/devices/doc2001plus.c	1.1     -> 1.2    
#	arch/ppc64/kernel/signal.c	1.28    -> 1.29   
#	drivers/mtd/devices/doc2000.c	1.6     -> 1.7    
#	drivers/input/serio/i8042-io.h	1.4.1.1 -> 1.6    
#	include/asm-parisc/unistd.h	1.8.1.1 -> 1.11   
#	arch/sparc/kernel/module.c	1.11    -> 1.12   
#	include/asm-ia64/topology.h	1.8     -> 1.9    
#	drivers/mtd/mtd_blkdevs.c	1.1     -> 1.3    
#	include/asm-ppc64/page.h	1.19    -> 1.21   
#	include/asm-i386/agp.h	1.1     -> 1.3    
#	arch/alpha/kernel/module.c	1.5     -> 1.6    
#	      kernel/ksyms.c	1.203.1.2 -> 1.206  
#	include/asm-ppc64/unistd.h	1.20.1.1 -> 1.25   
#	arch/ppc64/kernel/entry.S	1.26    -> 1.28   
#	include/asm-mips/unistd.h	1.6     -> 1.8    
#	drivers/mtd/nftlcore.c	1.44    -> 1.45   
#	include/asm-alpha/agp.h	1.2     -> 1.4    
#	         fs/select.c	1.20    -> 1.21   
#	include/linux/timex.h	1.5.1.3 -> 1.11   
#	  arch/ia64/Makefile	1.53    -> 1.55   
#	arch/ia64/kernel/efi.c	1.20    -> 1.21   
#	include/asm-alpha/hw_irq.h	1.2     -> 1.4    
#	  include/linux/mm.h	1.121   -> 1.122  
#	arch/arm/kernel/module.c	1.7     -> 1.8    
#	drivers/serial/8250.c	1.33    -> 1.34   
#	include/asm-ia64/io.h	1.13    -> 1.16   
#	arch/ppc64/kernel/udbg.c	1.8     -> 1.10   
#	drivers/mtd/inftlmount.c	1.1     -> 1.2    
#	include/asm-ppc64/processor.h	1.30    -> 1.31   
#	include/asm-i386/ptrace.h	1.5     -> 1.7    
#	include/asm-sparc/unistd.h	1.20    -> 1.23   
#	drivers/char/drm/i830_dma.c	1.18.1.1 -> 1.20   
#	 arch/ia64/defconfig	1.19    -> 1.21   
#	include/linux/sched.h	1.151.1.2 -> 1.154  
#	       kernel/fork.c	1.124.1.2 -> 1.126  
#	include/asm-ppc64/module.h	1.4     -> 1.6    
#	drivers/mtd/inftlcore.c	1.1     -> 1.2    
#	     kernel/sysctl.c	1.46    -> 1.47   
#	        kernel/sys.c	1.43.1.4 -> 1.45   
#	 fs/jffs2/os-linux.h	1.10    -> 1.11   
#	include/asm-ppc64/thread_info.h	1.7.1.1 -> 1.9    
#	include/asm-ppc64/ucontext.h	1.3     -> 1.5    
#	include/asm-sparc64/agp.h	1.1     -> 1.3    
#	arch/ppc64/kernel/chrp_setup.c	1.29    -> 1.31   
#	include/asm-i386/thread_info.h	1.11.1.1 -> 1.13   
#	arch/sparc/kernel/process.c	1.26    -> 1.27   
#	arch/ia64/sn/kernel/Makefile	1.13    -> 1.14   
#	arch/ia64/hp/common/sba_iommu.c	1.25    -> 1.26   
#	arch/ppc64/kernel/rtas.c	1.11    -> 1.13   
#	drivers/char/drm/r128_cce.c	1.12.1.1 -> 1.14   
#	drivers/mtd/nand/autcpu12.c	1.1     -> 1.2    
#	drivers/char/drm/drm_memory_debug.h	1.1.1.1 -> 1.3    
#	include/asm-sparc64/unistd.h	1.19    -> 1.22   
#	arch/i386/kernel/traps.c	1.52.1.2 -> 1.54   
#	drivers/char/drm/drm_memory.h	1.8.1.3 -> 1.11   
#	arch/i386/kernel/Makefile	1.44    -> 1.45   
#	drivers/mtd/maps/tqm8xxl.c	1.3     -> 1.4    
#	include/asm-ppc/unistd.h	1.23.1.1 -> 1.25   
#	drivers/mtd/maps/impa7.c	1.3     -> 1.4    
#	drivers/char/drm/radeon_cp.c	1.20    -> 1.21   
#	include/asm-ppc64/sigcontext.h	1.4     -> 1.6    
#	include/linux/serial.h	1.8.1.1 -> 1.10   
#	include/asm-ppc/pgtable.h	1.23    -> 1.24   
#	include/asm-ppc/thread_info.h	1.7.1.1 -> 1.9    
#	       kernel/time.c	1.11.1.4 -> 1.16   
#	drivers/char/drm/drm_bufs.h	1.14.1.1 -> 1.16   
#	 drivers/block/nbd.c	1.56    -> 1.57   
#	arch/ia64/kernel/smpboot.c	1.35    -> 1.36   
#	    kernel/softirq.c	1.39.1.2 -> 1.41   
#	arch/ppc64/kernel/LparData.c	1.9     -> 1.11   
#	arch/sparc64/solaris/fs.c	1.14    -> 1.15   
#	arch/ia64/sn/kernel/setup.c	1.14    -> 1.15   
#	drivers/net/tulip/media.c	1.11    -> 1.12   
#	drivers/acpi/pci_root.c	1.13.1.2 -> 1.16   
#	arch/ppc/kernel/module.c	1.9     -> 1.10   
#	drivers/mtd/chips/amd_flash.c	1.6     -> 1.7    
#	arch/ia64/sn/io/machvec/pci.c	1.7     -> 1.8    
#	include/asm-ppc64/types.h	1.3     -> 1.5    
#	drivers/mtd/chips/cfi_cmdset_0001.c	1.8     -> 1.9    
#	arch/ia64/sn/io/machvec/pci_dma.c	1.9     -> 1.11   
#	drivers/mtd/devices/doc2001.c	1.5     -> 1.6    
#	arch/ppc64/kernel/ras.c	1.5     -> 1.7    
#	include/asm-parisc/thread_info.h	1.2.1.1 -> 1.4    
#	include/asm-um/thread_info.h	1.3.1.1 -> 1.5    
#	arch/ia64/sn/io/drivers/ifconfig_net.c	1.6     ->         (deleted)      
#	include/asm-h8300/thread_info.h	1.1.1.1 -> 1.3    
#	drivers/mtd/maps/arctic-mtd.c	1.1     -> 1.2    
#	drivers/char/drm/i810_dma.c	1.26.1.1 -> 1.28   
#	include/linux/nfs_fs.h	1.45    -> 1.46   
#	drivers/media/video/Makefile	1.18    -> 1.19   
#	include/asm-v850/thread_info.h	1.2.1.1 -> 1.4    
#	drivers/mtd/mtdblock.c	1.44    -> 1.45   
#	include/asm-ppc64/proc_fs.h	1.2     -> 1.4    
#	arch/ia64/kernel/irq_ia64.c	1.12    -> 1.13   
#	include/linux/pci_ids.h	1.103.1.2 -> 1.105  
#	 include/linux/irq.h	1.6.1.1 -> 1.9    
#	include/linux/moduleloader.h	1.6     -> 1.7    
#	include/asm-alpha/unistd.h	1.18.1.3 -> 1.22   
#	include/asm-ia64/tlb.h	1.14    -> 1.15   
#	 arch/ia64/mm/init.c	1.44    -> 1.45   
#	include/asm-m68knommu/thread_info.h	1.2.1.1 -> 1.4    
#	arch/sparc64/kernel/systbls.S	1.39    -> 1.40   
#	arch/ppc64/kernel/irq.c	1.29    -> 1.31   
#	       fs/jffs2/fs.c	1.12    -> 1.13   
#	 arch/ia64/pci/pci.c	1.31    -> 1.32   
#	arch/ia64/hp/sim/simscsi.c	1.13    -> 1.14   
#	drivers/acpi/pci_irq.c	1.16.1.2 -> 1.18   
#	         mm/memory.c	1.123.1.2 -> 1.128  
#	arch/ia64/kernel/efivars.c	1.11    -> 1.12   
#	arch/ppc64/kernel/rtas-proc.c	1.6     -> 1.8    
#	 include/linux/pci.h	1.90.1.5 -> 1.92   
#	arch/ia64/kernel/mca.c	1.33    -> 1.34   
#	include/asm-arm/thread_info.h	1.6.1.1 -> 1.8    
#	arch/ppc64/kernel/setup.c	1.28    -> 1.29   
#	arch/ia64/kernel/iosapic.c	1.27    -> 1.28   
#	arch/ia64/kernel/process.c	1.39.1.5 -> 1.45   
#	include/asm-m68k/unistd.h	1.8     -> 1.10   
#	include/asm-ia64/hw_irq.h	1.6     -> 1.7    
#	drivers/mtd/mtdblock_ro.c	1.27    -> 1.28   
#	arch/i386/kernel/module.c	1.11    -> 1.12   
#	drivers/serial/Makefile	1.14.1.3 -> 1.19   
#	arch/ia64/kernel/acpi.c	1.42    -> 1.43   
#	drivers/mtd/maps/elan-104nc.c	1.6     -> 1.7    
#	include/asm-ppc64/naca.h	1.6     -> 1.8    
#	include/asm-h8300/unistd.h	1.1     -> 1.3    
#	arch/sparc/kernel/systbls.S	1.17    -> 1.18   
#	include/linux/acpi_serial.h	1.2.1.1 -> 1.4    
#	  drivers/char/mem.c	1.42    -> 1.43   
#	arch/ppc64/kernel/traps.c	1.19    -> 1.20   
#	include/asm-m68knommu/unistd.h	1.2     -> 1.4    
#	kernel/posix-timers.c	1.19    -> 1.20   
#	arch/ppc64/kernel/head.S	1.36    -> 1.38   
#	include/asm-ppc64/xics.h	1.5     -> 1.7    
#	include/asm-ia64/agp.h	1.3     -> 1.4    
#	arch/ia64/sn/kernel/machvec.c	1.6     -> 1.7    
#	include/linux/mtd/doc2000.h	1.5     -> 1.6    
#	arch/ia64/sn/io/hwgfs/hcl.c	1.2     -> 1.4    
#	include/linux/sunrpc/svc.h	1.20.1.3 -> 1.24   
#	include/linux/sysctl.h	1.47    -> 1.48   
#	arch/ppc64/kernel/xics.c	1.24    -> 1.25   
#	   drivers/net/tg3.c	1.72    -> 1.73   
#	 include/linux/smp.h	1.22.1.3 -> 1.24   
#	        usr/Makefile	1.6     -> 1.7    
#	arch/v850/kernel/module.c	1.5     -> 1.6    
#	arch/ia64/kernel/sys_ia64.c	1.23    -> 1.24   
#	drivers/block/loop.c	1.98    -> 1.99   
#	drivers/media/radio/Makefile	1.9     -> 1.10   
#	arch/ppc64/kernel/htab.c	1.34    -> 1.35   
#	arch/ppc64/mm/init.c	1.46    -> 1.48   
#	arch/ppc64/kernel/open_pic.c	1.13    -> 1.15   
#	drivers/char/agp/i460-agp.c	1.25    -> 1.27   
#	arch/ppc64/kernel/process.c	1.35.1.1 -> 1.38   
#	arch/ppc64/kernel/pci_dma.c	1.16    -> 1.17   
#	arch/ia64/ia32/sys_ia32.c	1.64    -> 1.67   
#	      fs/proc/base.c	1.42.1.7 -> 1.47   
#	           mm/mmap.c	1.85    -> 1.86   
#	include/asm-sparc64/compat.h	1.14    -> 1.15   
#	include/linux/time.h	1.16.1.1 -> 1.18   
#	include/linux/mtd/blktrans.h	1.1     -> 1.2    
#	arch/sparc64/kernel/module.c	1.14    -> 1.15   
#	arch/ppc64/kernel/open_pic_defs.h	1.2     -> 1.4    
#	include/asm-i386/unistd.h	1.25.1.1 -> 1.27   
#	drivers/usb/host/ehci-hcd.c	1.52    -> 1.53   
#	sound/oss/cs4281/cs4281pm-24.c	1.3.1.1 -> 1.5    
#	arch/ppc64/kernel/asm-offsets.c	1.14    -> 1.16   
#	include/asm-m68k/thread_info.h	1.4.1.1 -> 1.6    
#	            Makefile	1.410.1.2 -> 1.413  
#	          fs/fcntl.c	1.28    -> 1.29   
#	arch/ia64/kernel/head.S	1.12    -> 1.13   
#	include/asm-s390/thread_info.h	1.4.1.1 -> 1.6    
#	include/asm-ppc64/mmu.h	1.7     -> 1.9    
#	include/asm-x86_64/unistd.h	1.14    -> 1.16   
#	arch/ppc64/mm/numa.c	1.7     -> 1.8    
#	drivers/mtd/maps/lubbock-flash.c	1.1     -> 1.2    
#	arch/ppc64/kernel/syscalls.c	1.11    -> 1.13   
#	drivers/char/agp/backend.c	1.83    -> 1.84   
#	include/asm-x86_64/thread_info.h	1.12    -> 1.13   
#	include/asm-ppc64/ptrace.h	1.2     -> 1.4    
#	arch/ppc64/kernel/sys_ppc32.c	1.64    -> 1.66   
#	include/asm-sparc64/thread_info.h	1.10.1.1 -> 1.12   
#	arch/ppc64/kernel/prom.c	1.28    -> 1.30   
#	include/asm-x86_64/pgtable.h	1.21    -> 1.22   
#	     kernel/module.c	1.86    -> 1.87   
#	arch/ppc64/kernel/iSeries_setup.c	1.15    -> 1.17   
#	arch/ppc64/kernel/smp.c	1.38    -> 1.39   
#	drivers/char/drm/drmP.h	1.23.1.2 -> 1.25   
#	drivers/mtd/mtdpart.c	1.5     -> 1.6    
#	include/asm-i386/pgtable.h	1.35.1.1 -> 1.37   
#	net/ipv4/tcp_input.c	1.39    -> 1.40   
#	include/linux/highmem.h	1.25.1.2 -> 1.28   
#	arch/ppc64/mm/fault.c	1.10    -> 1.12   
#	arch/ppc64/kernel/pacaData.c	1.7     -> 1.9    
#	      kernel/sched.c	1.193.1.2 -> 1.195  
#	      fs/jffs2/dir.c	1.26    -> 1.27   
#	drivers/char/agp/hp-agp.c	1.24    -> 1.26   
#	  drivers/acpi/osl.c	1.37.1.1 -> 1.40   
#	 include/linux/jbd.h	1.21.1.16 -> 1.24   
#	arch/ia64/kernel/gate.S	1.17    -> 1.18   
#	include/asm-mips64/unistd.h	1.5     -> 1.7    
#	arch/alpha/kernel/traps.c	1.24.1.2 -> 1.27   
#	   drivers/mtd/ftl.c	1.47    -> 1.48   
#	drivers/char/drm/drm_drv.h	1.20    -> 1.21   
#	arch/ia64/sn/io/drivers/Makefile	1.3     -> 1.4    
#	      kernel/timer.c	1.59.1.1 -> 1.61   
#	drivers/mtd/maps/ebony.c	1.1     -> 1.2    
#	drivers/scsi/sym53c8xx_2/sym_malloc.c	1.2     -> 1.4    
#	include/asm-ia64/timex.h	1.7     -> 1.8    
#	arch/ppc64/kernel/pci.c	1.33    -> 1.35   
#	arch/ppc64/xmon/xmon.c	1.26    -> 1.28   
#	include/asm-sh/unistd.h	1.5     -> 1.7    
#	include/asm-m68k/pgtable.h	1.8     -> 1.9    
#	arch/ppc64/kernel/misc.S	1.60    -> 1.62   
#	drivers/char/drm/mga_dma.c	1.13.1.1 -> 1.15   
#	arch/ia64/kernel/irq.c	1.25    -> 1.26   
#	arch/s390/kernel/module.c	1.8     -> 1.9    
#	drivers/char/drm/mga_drv.h	1.13.1.1 -> 1.15   
#	arch/x86_64/kernel/module.c	1.9     -> 1.10   
#	include/linux/percpu.h	1.5.1.2 -> 1.7    
#	arch/arm/kernel/process.c	1.28.1.1 -> 1.30   
#	include/asm-alpha/thread_info.h	1.5.1.1 -> 1.7    
#	arch/ppc64/kernel/signal32.c	1.40    -> 1.42   
#	drivers/mtd/maps/iq80310.c	1.5     -> 1.6    
#	include/asm-cris/unistd.h	1.10    -> 1.12   
#	drivers/serial/Kconfig	1.8.1.2 -> 1.12   
#	   drivers/mtd/afs.c	1.3     -> 1.4    
#	drivers/char/drm/gamma_dma.c	1.12.1.2 -> 1.14   
#	arch/ppc64/kernel/rtas_flash.c	1.5     -> 1.7    
#	    net/sunrpc/svc.c	1.21    -> 1.22   
#	include/linux/irq_cpustat.h	1.7.1.1 -> 1.9    
#	     fs/jffs2/scan.c	1.10    -> 1.11   
#	arch/ia64/kernel/perfmon.c	1.50    -> 1.52   
#	include/asm-arm/unistd.h	1.16    -> 1.18   
#	   arch/ia64/Kconfig	1.32    -> 1.33   
#	arch/ia64/lib/Makefile	1.20    -> 1.21   
#	include/asm-ppc64/pgtable.h	1.23    -> 1.24   
#	include/asm-ppc64/mmzone.h	1.11    -> 1.12   
#	include/asm-sparc/thread_info.h	1.4.1.1 -> 1.6    
#	include/asm-ppc64/io.h	1.8     -> 1.10   
#	arch/ia64/scripts/toolchain-flags	1.1     -> 1.2    
#	arch/sparc64/mm/fault.c	1.15    -> 1.16   
#	drivers/video/radeonfb.c	1.26.1.3 -> 1.28   
#	include/asm-v850/unistd.h	1.6     -> 1.8    
#	include/asm-ppc64/topology.h	1.8     -> 1.9    
#	drivers/mtd/maps/Kconfig	1.6     -> 1.7    
#	arch/ppc64/kernel/Makefile	1.27    -> 1.29   
#	arch/ppc64/kernel/module.c	1.6     -> 1.7    
#	arch/ia64/kernel/ptrace.c	1.28    -> 1.29   
#	arch/sparc64/kernel/traps.c	1.25    -> 1.26   
#	include/asm-ppc64/rtas.h	1.6     -> 1.8    
#	  kernel/workqueue.c	1.8     -> 1.9    
#	arch/ia64/kernel/init_task.c	1.9     -> 1.10   
#	include/asm-i386/hw_irq.h	1.21    -> 1.23   
#	sound/oss/cs4281/cs4281m.c	1.21.1.3 -> 1.23   
#	arch/ppc64/kernel/align.c	1.10    -> 1.11   
#	drivers/mtd/maps/pb1xxx-flash.c	1.1     -> 1.2    
#	     kernel/printk.c	1.25    -> 1.27   
#	drivers/scsi/qla1280.c	1.38    -> 1.39   
#	arch/ppc64/kernel/ioctl32.c	1.35    -> 1.36   
#	arch/ppc64/kernel/pSeries_lpar.c	1.21    -> 1.23   
#	include/linux/loop.h	1.13    -> 1.14   
#	drivers/char/drm/drm_vm.h	1.23.1.1 -> 1.25   
#	arch/ia64/sn/kernel/idle.c	1.1     -> 1.2    
#	include/asm-ia64/thread_info.h	1.9     -> 1.10   
#	arch/ia64/hp/sim/hpsim_irq.c	1.4     -> 1.5    
#	drivers/mtd/maps/edb7312.c	1.3     -> 1.4    
#	include/asm-s390/unistd.h	1.16    -> 1.18   
#	arch/ia64/kernel/unwind.c	1.29    -> 1.31   
#	arch/parisc/kernel/module.c	1.5     -> 1.6    
#	drivers/mtd/nand/nand.c	1.3     -> 1.4    
#	drivers/scsi/sym53c8xx_2/sym_glue.c	1.23    -> 1.24   
#	               (new)	        -> 1.1     drivers/media/video/dummy.c
#	               (new)	        -> 1.1     drivers/media/radio/dummy.c
#
# The following is the BitKeeper ChangeSet Log
# --------------------------------------------
# 03/06/22	akpm@digeo.com	1.1377
# [PATCH] __devinitdata declarations should not be marked const.
# 
# There are some bad compiler issues with section confusion ("const" stuff
# likes going into the rodata section).
# --------------------------------------------
# 03/06/22	Andries.Brouwer@cwi.nl	1.1378
# [PATCH] loop.c cleanups
# 
# This does the following:
#  - remove trailing spaces
#  - make loop.h independent by including bio.h, blk.h, spinlock.h
#  - replace the lock/unlock functions by module_get/module_put;
#    in struct loop this is the change
# 	-       void (*lock)(struct loop_device *);
# 	-       void (*unlock)(struct loop_device *);
# 	+       struct module *owner;
#  - replace the integer lo_encrypt_type by the pointer lo_encryption;
#    there was a race with loop_unregister_transfer
#  - fixed an off-by-one in loop_register_transfer
# 
# This is Step 1 of a series of half a dozen or so.
# 
# Half of the above is from Jari. Anything that is wrong is mine.
# --------------------------------------------
# 03/06/22	ldl@aros.net	1.1379
# [PATCH] fix nbd driver for 2.5 block layer
# 
# This makes NBD work with the new linux 2.5 block layer design.
# Specifically, it fixes memory corruption that results from module
# removal and possible memory corruption from sending or receiving disk
# data from the server.
# 
# It essentially rolls together the changes from two of the last patchlets
# that I emailed: the fix for module removal & the fix for incorrect
# struct bio usage.  I believe it's wisest to roll these both together
# into this one patch since they both deal with making NBD work better
# with the 2.5 linux block layer design and without either of which, it's
# possible that NBD will corrupt memory.
# 
# Other changes I'd like to see introduced (like in the earlier jumbo
# patch) meanwhile are feature enhancements so they can wait.  This patch
# also should address all the very helpful concerns that have been raised
# so far.  Particularly:
# 
# 1. that the very first submitted NBD patch was broken down [Andrew]
# 2. that only 1 spinlock is used for all the NBD request_queue structures
#    used [Jens,Al]
# 3. that kmap() is used in case of highmem pages [Jens]
# 4. that the allocation of request_queue is dynamic and seperate from
#    other allocated objects [Al]
# --------------------------------------------
# 03/06/22	davem@nuts.ninka.net	1.1377.1.1
# [SPARC64]: Update struct compat_statfs.
# --------------------------------------------
# 03/06/22	davem@nuts.ninka.net	1.1377.1.2
# [SPARC64]: Update solaris compat layer for vfs_statfs() changes.
# --------------------------------------------
# 03/06/22	davem@nuts.ninka.net	1.1377.1.3
# [SPARC]: Update for show_stack() changes.
# --------------------------------------------
# 03/06/22	davem@nuts.ninka.net	1.1377.1.4
# [SPARC]: Add {f,}statfs64 syscall entries.
# --------------------------------------------
# 03/06/22	davem@kernel.bkbits.net	1.1380
# Merge davem@nuts.ninka.net:/home/davem/src/BK/sparc-2.5
# into kernel.bkbits.net:/home/davem/sparc-2.5
# --------------------------------------------
# 03/06/22	rusty@rustcorp.com.au	1.1381
# [PATCH] Workqueue Exit Neatening
# 
# Jeff Garzik points out the initializing the exit completion at
# exit time is foolish: we should just initialize it at creation time
# live everything else in that structure, and avoid the memory barrier.
# --------------------------------------------
# 03/06/23	dwmw2@infradead.org	1.1382
# MTD driver cleanups...
# 
#  - Fix AFS partitioning oops when no partitions are found
#  - Add missing spin_unlock, optimise buffer writes in Intel NOR driver
#  - Fix DiskOnChip Millennium Plus register OutputControl register definition
#  - Fix DiskOnChip drivers to indicate correct ECC type
#  - Fix map drivers to use ARRAY_SIZE instead of redefining it.
#  - Make uCLinux map driver depend on !MMU
#  - Fix NAND write verify problem on some chips
#  - Other trivia from Rusty.
# --------------------------------------------
# 03/06/23	dwmw2@infradead.org	1.1383
# Replace mtd_blktrans ->ioctl() method with ->getgeo() and ->flush()
# 
# ... and also fix the embarrassing bug where NFTL and INFTL will
# barf and exit if the add_mtd_blktrans_dev() function _exists_,
# rather than actually calling it and barfing if it returns non-zero :)
# --------------------------------------------
# 03/06/23	dwmw2@infradead.org	1.1384
# Trivia: use JFFS2 PAD() macro instead of masking manually.
# --------------------------------------------
# 03/06/23	dwmw2@infradead.org	1.1385
# Fix jffs2_statfs w.r.t. statfs64
# --------------------------------------------
# 03/06/23	dwmw2@infradead.org	1.1386
# Remove superfluous debugging in mtd_blkdevs.c
# --------------------------------------------
# 03/06/23	jes@wildopensource.com	1.1327.9.17
# [PATCH] ia64: fix static initializers
# 
# No need to explicitly zero out global variables.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1327.9.18
# ia64: Rename init_thread_union to init_task_mem to avoid conflicting
# 	declration in <linux/sched.h>.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1327.9.19
# Drop pcibios_update_resource() #warning.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1327.9.20
# ia64: Rename irq_desc() to irq_descp() to avoid conflict with variable
# 	of same name declared in linux/irq.h.  The expectation is that
# 	this variable will be removed eventually and then irq_descp()
# 	can be renamed to irq_desc() again.  But for now, this makes it
# 	easier to compile against Linus' source tree.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1327.9.21
# ia64: Update defconfig.  Add missing include to <asm-ia64/tlb.h>.  Fix
# 	compiler warning in perfmon.c.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1327.4.24
# Update ia64 defconfig.
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1387
# Merge tiger.hpl.hp.com:/data1/bk/vanilla/linux-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# --------------------------------------------
# 03/06/23	davidm@tiger.hpl.hp.com	1.1388
# Sync with Linus' tree.
# --------------------------------------------
# 03/06/23	davidm@wailua.hpl.hp.com	1.1389
# osl.c:
#   (acpi_os_readable): Correct type of 2nd arg to acpi_size.
# --------------------------------------------
# 03/06/24	arun.sharma@intel.com	1.1387.1.1
# [PATCH] ia64: IA-32 support patch: msgsnd/msgrcv return value off by 4
# 
# --------------------------------------------
# 03/06/24	arun.sharma@intel.com	1.1387.1.2
# [PATCH] ia64: IA-32 support patch: munmap should return EINVAL if size == 0
# 
# Native IA-32 returns EINVAL on a unmap of size 0. Our behavior is currently
# not compatible.
# --------------------------------------------
# 03/06/24	arun.sharma@intel.com	1.1387.1.3
# [PATCH] ia64: IA-32 support patch: mmap should return ENOMEM
# 
# Single Unix Specification says:
# [ENOMEM] MAP_FIXED was specified, and the range [addr, addr + len) exceeds
# that allowed for the address space of a process.
# 
# Therefore if addr + len > IA32_PAGE_OFFSET, we should return ENOMEM.
# --------------------------------------------
# 03/06/26	davidm@hpl.hp.com	1.1387.1.4
# [PATCH] ia64: A couple of additional fixes to sync with 2.5.73+.
# 
# --------------------------------------------
# 03/06/26	davidm@hpl.hp.com	1.1387.1.5
# [PATCH] ia64: support arch_get_unmapped_area() cache
# 
# Add support for the mm->free_area_cache so that we do not stupidly
# search from TASK_UNMAPPED_BASE every time we need to allocate some
# virtual memory.
# --------------------------------------------
# 03/06/26	davidm@tiger.hpl.hp.com	1.1390
# Merge tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/linux-ia64-2.5
# --------------------------------------------
# 03/06/26	alex_williamson@hp.com	1.1387.1.6
# [PATCH] ia64: turn off ALLOW_IOV_BYPASS
# 
# Since the BIO-layer assumes that blocks can be merged virtually
# at the granularity of BIO_VMERGE_BOUNDARY, independent of what device
# is in use, we always need to go through the I/O MMU, even for 64-bit
# devices.  Hopefully, the BIO-layer can be made smarter some day.
# --------------------------------------------
# 03/06/26	davidm@tiger.hpl.hp.com	1.1391
# Cset exclude: davidm@tiger.hpl.hp.com|ChangeSet|20030621161908|14888
# Cset exclude: davidm@tiger.hpl.hp.com|ChangeSet|20030621161905|15263
# --------------------------------------------
# 03/06/26	davidm@tiger.hpl.hp.com	1.1392
# Merge tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/linux-ia64-2.5
# --------------------------------------------
# 03/06/26	jsm@udlkern.fc.hp.com	1.1387.1.7
# [PATCH] ia64: don't let PTRACE_POKEDATA write the NaT bits of syscall args
# 
# --------------------------------------------
# 03/06/26	davidm@tiger.hpl.hp.com	1.1387.1.8
# ia64: Remove UNW_DEBUG again.  Adding it was a mistake.
# --------------------------------------------
# 03/06/27	mort@green.i.bork.org	1.1387.1.9
# [PATCH] ia64: fix register-backing store initialization for main thread
# 
# --------------------------------------------
# 03/06/27	davidm@tiger.hpl.hp.com	1.1393
# Merge tiger.hpl.hp.com:/data1/bk/lia64/to-linus-2.5
# into tiger.hpl.hp.com:/data1/bk/lia64/linux-ia64-2.5
# --------------------------------------------
#
diff -Nru a/Makefile b/Makefile
--- a/Makefile	Fri Jun 27 22:41:17 2003
+++ b/Makefile	Fri Jun 27 22:41:17 2003
@@ -213,7 +213,7 @@
 NOSTDINC_FLAGS  = -nostdinc -iwithprefix include
 
 CPPFLAGS	:= -D__KERNEL__ -Iinclude
-CFLAGS 		:= $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -O2 \
+CFLAGS 		:= $(CPPFLAGS) -Wall -Wstrict-prototypes -Wno-trigraphs -g -O2 \
 	  	   -fno-strict-aliasing -fno-common
 AFLAGS		:= -D__ASSEMBLY__ $(CPPFLAGS)
 
diff -Nru a/arch/i386/kernel/Makefile b/arch/i386/kernel/Makefile
--- a/arch/i386/kernel/Makefile	Fri Jun 27 22:41:17 2003
+++ b/arch/i386/kernel/Makefile	Fri Jun 27 22:41:17 2003
@@ -47,7 +47,7 @@
       cmd_syscall = $(CC) -nostdlib $(SYSCFLAGS_$(@F)) \
 		          -Wl,-T,$(filter-out FORCE,$^) -o $@
 
-vsyscall-flags = -shared -s -Wl,-soname=linux-vsyscall.so.1
+vsyscall-flags = -shared -s -Wl,-soname=linux-gate.so.1
 SYSCFLAGS_vsyscall-sysenter.so	= $(vsyscall-flags)
 SYSCFLAGS_vsyscall-int80.so	= $(vsyscall-flags)
 
diff -Nru a/arch/ia64/Kconfig b/arch/ia64/Kconfig
--- a/arch/ia64/Kconfig	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/Kconfig	Fri Jun 27 22:41:17 2003
@@ -544,6 +544,8 @@
 
 source "drivers/block/Kconfig"
 
+source "drivers/ide/Kconfig"
+
 source "drivers/ieee1394/Kconfig"
 
 source "drivers/message/i2o/Kconfig"
@@ -786,6 +788,10 @@
 config IA64_EARLY_PRINTK_VGA
 	bool "Early printk on VGA"
 	depends on IA64_EARLY_PRINTK
+
+config IA64_EARLY_PRINTK_SGI_SN
+	bool "Early printk on SGI SN serial console"
+	depends on IA64_EARLY_PRINTK && (IA64_GENERIC || IA64_SGI_SN2)
 
 config DEBUG_SLAB
 	bool "Debug memory allocations"
diff -Nru a/arch/ia64/Makefile b/arch/ia64/Makefile
--- a/arch/ia64/Makefile	Fri Jun 27 22:41:16 2003
+++ b/arch/ia64/Makefile	Fri Jun 27 22:41:16 2003
@@ -27,7 +27,7 @@
 
 GAS_STATUS=$(shell arch/ia64/scripts/check-gas $(CC) $(OBJDUMP))
 
-arch-cppflags	:= $(shell arch/ia64/scripts/toolchain-flags $(CC) $(LD) $(OBJDUMP))
+arch-cppflags	:= $(shell arch/ia64/scripts/toolchain-flags $(CC) $(OBJDUMP))
 cflags-y	+= $(arch-cppflags)
 AFLAGS		+= $(arch-cppflags)
 
@@ -66,7 +66,8 @@
 drivers-$(CONFIG_PCI)		+= arch/ia64/pci/
 drivers-$(CONFIG_IA64_HP_SIM)	+= arch/ia64/hp/sim/
 drivers-$(CONFIG_IA64_HP_ZX1)	+= arch/ia64/hp/common/ arch/ia64/hp/zx1/
-drivers-$(CONFIG_IA64_GENERIC)	+= arch/ia64/hp/common/ arch/ia64/hp/zx1/ arch/ia64/hp/sim/
+drivers-$(CONFIG_IA64_GENERIC)	+= arch/ia64/hp/common/ arch/ia64/hp/zx1/ arch/ia64/hp/sim/ \
+				   arch/ia64/sn/
 
 boot := arch/ia64/boot
 
diff -Nru a/arch/ia64/defconfig b/arch/ia64/defconfig
--- a/arch/ia64/defconfig	Fri Jun 27 22:41:16 2003
+++ b/arch/ia64/defconfig	Fri Jun 27 22:41:16 2003
@@ -10,30 +10,38 @@
 #
 # General setup
 #
-CONFIG_NET=y
+CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
-# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_BSD_PROCESS_ACCT=y
 CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_EMBEDDED is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
 
 #
 # Loadable module support
 #
 CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
 CONFIG_MODVERSIONS=y
-# CONFIG_KMOD is not set
+CONFIG_KMOD=y
 
 #
 # Processor type and features
 #
 CONFIG_IA64=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_ITANIUM=y
-# CONFIG_MCKINLEY is not set
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_TIME_INTERPOLATION=y
+# CONFIG_ITANIUM is not set
+CONFIG_MCKINLEY=y
 # CONFIG_IA64_GENERIC is not set
-CONFIG_IA64_DIG=y
+# CONFIG_IA64_DIG is not set
 # CONFIG_IA64_HP_SIM is not set
-# CONFIG_IA64_HP_ZX1 is not set
-# CONFIG_IA64_SGI_SN1 is not set
+CONFIG_IA64_HP_ZX1=y
 # CONFIG_IA64_SGI_SN2 is not set
 # CONFIG_IA64_PAGE_SIZE_4KB is not set
 # CONFIG_IA64_PAGE_SIZE_8KB is not set
@@ -43,41 +51,64 @@
 CONFIG_ACPI_EFI=y
 CONFIG_ACPI_INTERPRETER=y
 CONFIG_ACPI_KERNEL_CONFIG=y
-CONFIG_IA64_BRL_EMU=y
-# CONFIG_ITANIUM_BSTEP_SPECIFIC is not set
-CONFIG_IA64_L1_CACHE_SHIFT=6
+CONFIG_IA64_L1_CACHE_SHIFT=7
+# CONFIG_MCKINLEY_ASTEP_SPECIFIC is not set
 # CONFIG_NUMA is not set
+CONFIG_VIRTUAL_MEM_MAP=y
 CONFIG_IA64_MCA=y
 CONFIG_PM=y
 CONFIG_IOSAPIC=y
 CONFIG_KCORE_ELF=y
 CONFIG_FORCE_MAX_ZONEORDER=18
-# CONFIG_HUGETLB_PAGE is not set
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_HUGETLB_PAGE_SIZE_4GB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_1GB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_256MB is not set
+CONFIG_HUGETLB_PAGE_SIZE_64MB=y
+# CONFIG_HUGETLB_PAGE_SIZE_16MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_4MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_1MB is not set
+# CONFIG_HUGETLB_PAGE_SIZE_256KB is not set
+CONFIG_IA64_PAL_IDLE=y
 CONFIG_SMP=y
+# CONFIG_PREEMPT is not set
 CONFIG_IA32_SUPPORT=y
+CONFIG_COMPAT=y
 CONFIG_PERFMON=y
 CONFIG_IA64_PALINFO=y
 CONFIG_EFI_VARS=y
 CONFIG_NR_CPUS=16
 CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
+CONFIG_BINFMT_MISC=y
 
 #
 # ACPI Support
 #
 CONFIG_ACPI_BOOT=y
 CONFIG_ACPI_BUTTON=y
-CONFIG_ACPI_FAN=m
-CONFIG_ACPI_PROCESSOR=m
-CONFIG_ACPI_THERMAL=m
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_THERMAL=y
 # CONFIG_ACPI_DEBUG is not set
 CONFIG_ACPI_BUS=y
 CONFIG_ACPI_POWER=y
 CONFIG_ACPI_PCI=y
 CONFIG_ACPI_SYSTEM=y
 CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
 
 #
 # Parallel port support
@@ -85,12 +116,17 @@
 # CONFIG_PARPORT is not set
 
 #
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
 
 #
-# Plug and Play configuration
+# Plug and Play support
 #
 # CONFIG_PNP is not set
 
@@ -104,7 +140,9 @@
 # CONFIG_BLK_DEV_UMEM is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
 
 #
 # IEEE 1394 (FireWire) support (EXPERIMENTAL)
@@ -124,64 +162,11 @@
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-
-#
-# IDE, ATA and ATAPI Block devices
-#
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_HD is not set
-CONFIG_BLK_DEV_IDEDISK=y
-CONFIG_IDEDISK_MULTI_MODE=y
-# CONFIG_IDEDISK_STROKE is not set
-CONFIG_BLK_DEV_IDECD=y
-CONFIG_BLK_DEV_IDEFLOPPY=y
-CONFIG_BLK_DEV_IDESCSI=y
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_BLK_DEV_IDEPCI=y
-# CONFIG_BLK_DEV_GENERIC is not set
-CONFIG_IDEPCI_SHARE_IRQ=y
-CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_IDE_TCQ is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
-# CONFIG_IDEDMA_PCI_AUTO is not set
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_IDEDMA_PCI_WIP is not set
-CONFIG_BLK_DEV_ADMA=y
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_HPT34X is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_NFORCE is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_IDEDMA_IVB is not set
+CONFIG_FUSION=y
+CONFIG_FUSION_BOOT=y
+CONFIG_FUSION_MAX_SGE=40
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
 
 #
 # SCSI support
@@ -192,16 +177,17 @@
 # SCSI support type (disk, tape, CD-ROM)
 #
 CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=y
+CONFIG_CHR_DEV_OSST=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_REPORT_LUNS=y
 CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
@@ -212,57 +198,76 @@
 # CONFIG_SCSI_ACARD is not set
 # CONFIG_SCSI_AACRAID is not set
 # CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC7XXX_OLD=y
+# CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_IN2000 is not set
-# CONFIG_SCSI_AM53C974 is not set
-# CONFIG_SCSI_MEGARAID is not set
+CONFIG_SCSI_MEGARAID=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_DMA is not set
 # CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_NCR53C7xx is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_NCR53C8XX is not set
-# CONFIG_SCSI_SYM53C8XX is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_PCI2000 is not set
 # CONFIG_SCSI_PCI2220I is not set
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 CONFIG_SCSI_QLOGIC_1280=y
+# CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_U14_34F is not set
 # CONFIG_SCSI_NSP32 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
+# Networking support
+#
+CONFIG_NET=y
+
+#
 # Networking options
 #
 CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
+# CONFIG_PACKET_MMAP is not set
 # CONFIG_NETLINK_DEV is not set
-# CONFIG_NETFILTER is not set
-CONFIG_FILTER=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
 CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
+CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
 # CONFIG_IP_PNP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+CONFIG_IP_NF_ARPTABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
 # CONFIG_IPV6 is not set
+# CONFIG_XFRM_USER is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
@@ -288,8 +293,9 @@
 # CONFIG_NET_SCHED is not set
 
 #
-# Network device support
+# Network testing
 #
+# CONFIG_NET_PKTGEN is not set
 CONFIG_NETDEVICES=y
 
 #
@@ -297,7 +303,7 @@
 #
 # CONFIG_ARCNET is not set
 CONFIG_DUMMY=y
-# CONFIG_BONDING is not set
+CONFIG_BONDING=y
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
 # CONFIG_ETHERTAP is not set
@@ -306,11 +312,10 @@
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
 # CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_NET_VENDOR_SMC is not set
-# CONFIG_NET_VENDOR_RACAL is not set
 
 #
 # Tulip family network device support
@@ -319,9 +324,12 @@
 # CONFIG_HP100 is not set
 CONFIG_NET_PCI=y
 # CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
 # CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
 # CONFIG_DGRS is not set
 CONFIG_EEPRO100=y
+# CONFIG_EEPRO100_PIO is not set
 # CONFIG_E100 is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
@@ -333,19 +341,25 @@
 # CONFIG_SUNDANCE is not set
 # CONFIG_TLAN is not set
 # CONFIG_VIA_RHINE is not set
-# CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
 #
 # CONFIG_ACENIC is not set
 # CONFIG_DL2K is not set
-# CONFIG_E1000 is not set
+CONFIG_E1000=y
+# CONFIG_E1000_NAPI is not set
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
 # CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
+CONFIG_TIGON3=m
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
@@ -357,9 +371,8 @@
 # CONFIG_NET_RADIO is not set
 
 #
-# Token Ring devices
+# Token Ring devices (depends on LLC=y)
 #
-# CONFIG_TR is not set
 # CONFIG_NET_FC is not set
 # CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
@@ -393,10 +406,10 @@
 # Userland interfaces
 #
 CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_JOYDEV=y
 # CONFIG_INPUT_TSDEV is not set
 CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
@@ -407,26 +420,19 @@
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
 
 #
 # Input Device Drivers
 #
-CONFIG_INPUT_KEYBOARD=y
-CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_KEYBOARD_SUNKBD is not set
-# CONFIG_KEYBOARD_XTKBD is not set
-# CONFIG_KEYBOARD_NEWTON is not set
-CONFIG_INPUT_MOUSE=y
-CONFIG_MOUSE_PS2=y
-# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
-CONFIG_INPUT_MISC=y
-# CONFIG_INPUT_PCSPKR is not set
-# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_MISC is not set
 
 #
 # Character devices
@@ -441,12 +447,9 @@
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_EXTENDED=y
-# CONFIG_SERIAL_8250_MANY_PORTS is not set
-CONFIG_SERIAL_8250_SHARE_IRQ=y
-# CONFIG_SERIAL_8250_DETECT_IRQ is not set
-# CONFIG_SERIAL_8250_MULTIPORT is not set
-# CONFIG_SERIAL_8250_RSA is not set
+CONFIG_SERIAL_8250_ACPI=y
+CONFIG_SERIAL_8250_HCDP=y
+# CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
 # Non-8250 serial port support
@@ -459,14 +462,16 @@
 #
 # I2C support
 #
-CONFIG_I2C=y
-CONFIG_I2C_ALGOBIT=y
-# CONFIG_I2C_ELV is not set
-# CONFIG_I2C_VELLEMAN is not set
-# CONFIG_SCx200_ACB is not set
-# CONFIG_I2C_ALGOPCF is not set
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_PROC=y
+# CONFIG_I2C is not set
+
+#
+# I2C Hardware Sensors Mainboard support
+#
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
 
 #
 # Mice
@@ -475,12 +480,16 @@
 # CONFIG_QIC02_TAPE is not set
 
 #
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-# CONFIG_INTEL_RNG is not set
+# CONFIG_HW_RANDOM is not set
 # CONFIG_NVRAM is not set
-# CONFIG_RTC is not set
 # CONFIG_GEN_RTC is not set
 CONFIG_EFI_RTC=y
 # CONFIG_DTLK is not set
@@ -491,25 +500,17 @@
 # Ftape, the floppy tape device driver
 #
 # CONFIG_FTAPE is not set
-CONFIG_AGP=y
-CONFIG_AGP_INTEL=y
-CONFIG_AGP_I810=y
-CONFIG_AGP_VIA=y
-CONFIG_AGP_AMD=y
-CONFIG_AGP_SIS=y
-CONFIG_AGP_ALI=y
-CONFIG_AGP_SWORKS=y
-# CONFIG_AGP_AMD_8151 is not set
-CONFIG_AGP_I460=y
-CONFIG_AGP_HP_ZX1=y
+CONFIG_AGP=m
+CONFIG_AGP_I460=m
+CONFIG_AGP_HP_ZX1=m
 CONFIG_DRM=y
-CONFIG_DRM_TDFX=y
-CONFIG_DRM_R128=y
-CONFIG_DRM_RADEON=y
-CONFIG_DRM_I810=y
-CONFIG_DRM_I830=y
-CONFIG_DRM_MGA=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_GAMMA is not set
+# CONFIG_DRM_R128 is not set
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_MGA is not set
 # CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
 
 #
 # Multimedia devices
@@ -517,51 +518,79 @@
 # CONFIG_VIDEO_DEV is not set
 
 #
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
 # File systems
 #
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
 # CONFIG_QUOTA is not set
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
-# CONFIG_REISERFS_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
-CONFIG_EXT3_FS=y
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FAT_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
 # CONFIG_EFS_FS is not set
 # CONFIG_CRAMFS is not set
-# CONFIG_TMPFS is not set
-CONFIG_RAMFS=y
-CONFIG_ISO9660_FS=y
-# CONFIG_JOLIET is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_MINIX_FS is not set
 # CONFIG_VXFS_FS is not set
-# CONFIG_NTFS_FS is not set
 # CONFIG_HPFS_FS is not set
-CONFIG_PROC_FS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS=y
 # CONFIG_QNX4FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
 # CONFIG_UFS_FS is not set
-# CONFIG_XFS_FS is not set
 
 #
 # Network File Systems
 #
-# CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 CONFIG_NFS_V4=y
@@ -569,13 +598,16 @@
 CONFIG_NFSD_V3=y
 # CONFIG_NFSD_V4 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
-# CONFIG_CIFS is not set
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
 # CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -593,6 +625,7 @@
 # CONFIG_SOLARIS_X86_PARTITION is not set
 # CONFIG_UNIXWARE_DISKLABEL is not set
 # CONFIG_LDM_PARTITION is not set
+# CONFIG_NEC98_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
@@ -603,53 +636,84 @@
 # Native Language Support
 #
 CONFIG_NLS_DEFAULT="iso8859-1"
-# CONFIG_NLS_CODEPAGE_437 is not set
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
 # CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-# CONFIG_NLS_ISO8859_1 is not set
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_UTF8 is not set
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_UTF8=y
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_IMSTT is not set
+CONFIG_FB_RIVA=m
+# CONFIG_FB_MATROX is not set
+CONFIG_FB_RADEON=y
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_VIRTUAL is not set
 
 #
-# Console drivers
+# Console display driver support
 #
 CONFIG_VGA_CONSOLE=y
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
 
 #
-# Frame-buffer support
-#
-# CONFIG_FB is not set
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
 
 #
 # Sound
@@ -659,31 +723,62 @@
 #
 # Advanced Linux Sound Architecture
 #
-# CONFIG_SND is not set
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+# CONFIG_SND_SEQ_DUMMY is not set
+# CONFIG_SND_OSSEMUL is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# PCI devices
+#
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_MAESTRO3 is not set
+CONFIG_SND_FM801=m
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VX222 is not set
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
 
 #
 # Open Sound System
 #
-CONFIG_SOUND_PRIME=y
-# CONFIG_SOUND_BT878 is not set
-# CONFIG_SOUND_CMPCI is not set
-# CONFIG_SOUND_EMU10K1 is not set
-# CONFIG_SOUND_FUSION is not set
-CONFIG_SOUND_CS4281=y
-# CONFIG_SOUND_ES1370 is not set
-# CONFIG_SOUND_ES1371 is not set
-# CONFIG_SOUND_ESSSOLO1 is not set
-# CONFIG_SOUND_MAESTRO is not set
-# CONFIG_SOUND_MAESTRO3 is not set
-# CONFIG_SOUND_ICH is not set
-# CONFIG_SOUND_RME96XX is not set
-# CONFIG_SOUND_SONICVIBES is not set
-# CONFIG_SOUND_TRIDENT is not set
-# CONFIG_SOUND_MSNDCLAS is not set
-# CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_VIA82CXXX is not set
-# CONFIG_SOUND_OSS is not set
-# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_PRIME is not set
 
 #
 # USB support
@@ -694,17 +789,16 @@
 #
 # Miscellaneous USB options
 #
-CONFIG_USB_DEVICEFS=y
-# CONFIG_USB_LONG_TIMEOUT is not set
-# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_BANDWIDTH=y
 # CONFIG_USB_DYNAMIC_MINORS is not set
 
 #
 # USB Host Controller Drivers
 #
-# CONFIG_USB_EHCI_HCD is not set
-# CONFIG_USB_OHCI_HCD is not set
-CONFIG_USB_UHCI_HCD_ALT=y
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_UHCI_HCD=m
 
 #
 # USB Device Class drivers
@@ -725,6 +819,7 @@
 CONFIG_USB_HIDDEV=y
 # CONFIG_USB_AIPTEK is not set
 # CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
 # CONFIG_USB_POWERMATE is not set
 # CONFIG_USB_XPAD is not set
 
@@ -748,8 +843,8 @@
 #
 # USB Network adaptors
 #
+# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_RTL8150 is not set
@@ -772,17 +867,17 @@
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_BRLVGER is not set
 # CONFIG_USB_LCD is not set
-# CONFIG_USB_TEST is not set
+# CONFIG_USB_GADGET is not set
 
 #
-# Library routines
+# Bluetooth support
 #
-# CONFIG_CRC32 is not set
+# CONFIG_BT is not set
 
 #
-# Bluetooth support
+# Library routines
 #
-# CONFIG_BT is not set
+CONFIG_CRC32=y
 
 #
 # Kernel hacking
@@ -794,18 +889,17 @@
 CONFIG_IA64_PRINT_HAZARDS=y
 # CONFIG_DISABLE_VHPT is not set
 CONFIG_MAGIC_SYSRQ=y
-CONFIG_IA64_EARLY_PRINTK=y
-# CONFIG_IA64_EARLY_PRINTK_UART is not set
-CONFIG_IA64_EARLY_PRINTK_VGA=y
+# CONFIG_IA64_EARLY_PRINTK is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_IA64_DEBUG_CMPXCHG is not set
 # CONFIG_IA64_DEBUG_IRQ is not set
 
 #
 # Security options
 #
-CONFIG_SECURITY_CAPABILITIES=y
+# CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
diff -Nru a/arch/ia64/hp/common/sba_iommu.c b/arch/ia64/hp/common/sba_iommu.c
--- a/arch/ia64/hp/common/sba_iommu.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/hp/common/sba_iommu.c	Fri Jun 27 22:41:17 2003
@@ -47,8 +47,10 @@
 /*
 ** This option allows cards capable of 64bit DMA to bypass the IOMMU.  If
 ** not defined, all DMA will be 32bit and go through the TLB.
+** There's potentially a conflict in the bio merge code with us
+** advertising an iommu, but then bypassing it.  Disabled for now.
 */
-#define ALLOW_IOV_BYPASS
+#undef ALLOW_IOV_BYPASS
 
 /*
 ** If a device prefetches beyond the end of a valid pdir entry, it will cause
diff -Nru a/arch/ia64/hp/sim/hpsim_irq.c b/arch/ia64/hp/sim/hpsim_irq.c
--- a/arch/ia64/hp/sim/hpsim_irq.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/hp/sim/hpsim_irq.c	Fri Jun 27 22:41:17 2003
@@ -39,7 +39,7 @@
 	int i;
 
 	for (i = 0; i < NR_IRQS; ++i) {
-		idesc = irq_desc(i);
+		idesc = irq_descp(i);
 		if (idesc->handler == &no_irq_type)
 			idesc->handler = &irq_type_hp_sim;
 	}
diff -Nru a/arch/ia64/hp/sim/simscsi.c b/arch/ia64/hp/sim/simscsi.c
--- a/arch/ia64/hp/sim/simscsi.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/hp/sim/simscsi.c	Fri Jun 27 22:41:17 2003
@@ -350,6 +350,7 @@
 			break;
 
 		      case MODE_SENSE:
+		      case MODE_SENSE_10:
 			/* sd.c uses this to determine whether disk does write-caching. */
 			memset(sc->request_buffer, 0, 128);
 			sc->result = GOOD;
diff -Nru a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c
--- a/arch/ia64/ia32/sys_ia32.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/ia32/sys_ia32.c	Fri Jun 27 22:41:17 2003
@@ -420,7 +420,12 @@
 		return addr;
 
 	if (len > IA32_PAGE_OFFSET || addr > IA32_PAGE_OFFSET - len)
+	{
+		if (flags & MAP_FIXED)
+			return -ENOMEM;
+		else
 		return -EINVAL;
+	}
 
 	if (OFFSET4K(offset))
 		return -EINVAL;
@@ -519,7 +524,7 @@
 #if PAGE_SHIFT <= IA32_PAGE_SHIFT
 	ret = sys_munmap(start, end - start);
 #else
-	if (start > end)
+	if (start >= end)
 		return -EINVAL;
 
 	start = PAGE_ALIGN(start);
@@ -1275,7 +1280,7 @@
 static int
 do_sys32_msgsnd (int first, int second, int third, void *uptr)
 {
-	struct msgbuf *p = kmalloc(second + sizeof(struct msgbuf) + 4, GFP_USER);
+	struct msgbuf *p = kmalloc(second + sizeof(struct msgbuf), GFP_USER);
 	struct msgbuf32 *up = (struct msgbuf32 *)uptr;
 	mm_segment_t old_fs;
 	int err;
@@ -1317,12 +1322,12 @@
 		msgtyp = ipck.msgtyp;
 	}
 	err = -ENOMEM;
-	p = kmalloc(second + sizeof(struct msgbuf) + 4, GFP_USER);
+	p = kmalloc(second + sizeof(struct msgbuf), GFP_USER);
 	if (!p)
 		goto out;
 	old_fs = get_fs();
 	set_fs(KERNEL_DS);
-	err = sys_msgrcv(first, p, second + 4, msgtyp, third);
+	err = sys_msgrcv(first, p, second, msgtyp, third);
 	set_fs(old_fs);
 	if (err < 0)
 		goto free_then_out;
diff -Nru a/arch/ia64/kernel/acpi.c b/arch/ia64/kernel/acpi.c
--- a/arch/ia64/kernel/acpi.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/acpi.c	Fri Jun 27 22:41:17 2003
@@ -575,59 +575,6 @@
 }
 
 
-#ifdef CONFIG_SERIAL_8250_ACPI
-
-#include <linux/acpi_serial.h>
-
-static int __init
-acpi_parse_spcr (unsigned long phys_addr, unsigned long size)
-{
-	acpi_ser_t *spcr;
-	unsigned int gsi;
-
-	if (!phys_addr || !size)
-		return -EINVAL;
-
-	if (!iosapic_register_intr)
-		return -ENODEV;
-
-	/*
-	 * ACPI is able to describe serial ports that live at non-standard
-	 * memory addresses and use non-standard interrupts, either via
-	 * direct SAPIC mappings or via PCI interrupts.  We handle interrupt
-	 * routing for SAPIC-based (non-PCI) devices here.  Interrupt routing
-	 * for PCI devices will be handled when processing the PCI Interrupt
-	 * Routing Table (PRT).
-	 */
-
-	spcr = (acpi_ser_t *) __va(phys_addr);
-
-	setup_serial_acpi(spcr);
-
-	if (spcr->length < sizeof(acpi_ser_t))
-		/* Table not long enough for full info, thus no interrupt */
-		return -ENODEV;
-
-	if ((spcr->base_addr.space_id != ACPI_SERIAL_PCICONF_SPACE) &&
-	    (spcr->int_type == ACPI_SERIAL_INT_SAPIC))
-	{
-		int vector;
-
-		/* We have a UART in memory space with an SAPIC interrupt */
-
-		gsi = (  (spcr->global_int[3] << 24) |
-			 (spcr->global_int[2] << 16) |
-			 (spcr->global_int[1] << 8)  |
-			 (spcr->global_int[0])  );
-
-		vector = iosapic_register_intr(gsi, IOSAPIC_POL_HIGH, IOSAPIC_EDGE);
-	}
-	return 0;
-}
-
-#endif /* CONFIG_SERIAL_8250_ACPI */
-
-
 int __init
 acpi_boot_init (void)
 {
@@ -681,16 +628,6 @@
 	 */
 	if (acpi_table_parse(ACPI_FADT, acpi_parse_fadt) < 1)
 		printk(KERN_ERR PREFIX "Can't find FADT\n");
-
-#ifdef CONFIG_SERIAL_8250_ACPI
-	/*
-	 * TBD: Need phased approach to table parsing (only do those absolutely
-	 *      required during boot-up).  Recommend expanding concept of fix-
-	 *      feature devices (LDM) to include table-based devices such as
-	 *      serial ports, EC, SMBus, etc.
-	 */
-	acpi_table_parse(ACPI_SPCR, acpi_parse_spcr);
-#endif
 
 #ifdef CONFIG_SMP
 	smp_boot_data.cpu_count = available_cpus;
diff -Nru a/arch/ia64/kernel/efi.c b/arch/ia64/kernel/efi.c
--- a/arch/ia64/kernel/efi.c	Fri Jun 27 22:41:16 2003
+++ b/arch/ia64/kernel/efi.c	Fri Jun 27 22:41:16 2003
@@ -46,7 +46,7 @@
  * prior to creating their own entries under /proc/efi.
  */
 #ifdef CONFIG_PROC_FS
-struct proc_dir_entry *efi_dir = NULL;
+struct proc_dir_entry *efi_dir;
 #endif
 
 static unsigned long mem_limit = ~0UL;
diff -Nru a/arch/ia64/kernel/efivars.c b/arch/ia64/kernel/efivars.c
--- a/arch/ia64/kernel/efivars.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/efivars.c	Fri Jun 27 22:41:17 2003
@@ -119,7 +119,7 @@
 */
 static spinlock_t efivars_lock = SPIN_LOCK_UNLOCKED;
 static LIST_HEAD(efivar_list);
-static struct proc_dir_entry *efi_vars_dir = NULL;
+static struct proc_dir_entry *efi_vars_dir;
 
 #define efivar_entry(n) list_entry(n, efivar_entry_t, list)
 
diff -Nru a/arch/ia64/kernel/gate.S b/arch/ia64/kernel/gate.S
--- a/arch/ia64/kernel/gate.S	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/gate.S	Fri Jun 27 22:41:17 2003
@@ -199,7 +199,7 @@
 	cmp.ne p8,p0=r15,r0		// do we need to switch the rbs?
 	mov.m r9=ar.bsp			// fetch ar.bsp
 	.spillsp.p p8, ar.rnat, RNAT_OFF+SIGCONTEXT_OFF
-(p8)	br.cond.spnt setup_rbs		// yup -> (clobbers r14, r15, and r16)
+(p8)	br.cond.spnt setup_rbs		// yup -> (clobbers p8, r14-r16, and r18-r20)
 back_from_setup_rbs:
 	alloc r8=ar.pfs,0,0,3,0
 	ld8 out0=[base0],16		// load arg0 (signum)
@@ -268,26 +268,30 @@
 setup_rbs:
 	mov ar.rsc=0				// put RSE into enforced lazy mode
 	;;
-	.save ar.rnat, r16
-	mov r16=ar.rnat				// save RNaT before switching backing store area
+	.save ar.rnat, r19
+	mov r19=ar.rnat				// save RNaT before switching backing store area
 	adds r14=(RNAT_OFF+SIGCONTEXT_OFF),sp
 
+	mov r18=ar.bspstore
 	mov ar.bspstore=r15			// switch over to new register backing store area
 	;;
+
 	.spillsp ar.rnat, RNAT_OFF+SIGCONTEXT_OFF
-	st8 [r14]=r16				// save sc_ar_rnat
+	st8 [r14]=r19				// save sc_ar_rnat
 	.body
-	adds r14=(LOADRS_OFF+SIGCONTEXT_OFF),sp
-
 	mov.m r16=ar.bsp			// sc_loadrs <- (new bsp - new bspstore) << 16
+	adds r14=(LOADRS_OFF+SIGCONTEXT_OFF),sp
 	;;
 	invala
 	sub r15=r16,r15
+	extr.u r20=r18,3,6
 	;;
+	mov ar.rsc=0xf				// set RSE into eager mode, pl 3
+	cmp.eq p8,p0=63,r20
 	shl r15=r15,16
 	;;
 	st8 [r14]=r15				// save sc_loadrs
-	mov ar.rsc=0xf				// set RSE into eager mode, pl 3
+(p8)	st8 [r18]=r19		// if bspstore points at RNaT slot, store RNaT there now
 	.restore sp				// pop .prologue
 	br.cond.sptk back_from_setup_rbs
 
diff -Nru a/arch/ia64/kernel/head.S b/arch/ia64/kernel/head.S
--- a/arch/ia64/kernel/head.S	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/head.S	Fri Jun 27 22:41:17 2003
@@ -144,13 +144,13 @@
 	movl r3=task_for_booting_cpu
  	;;
 	ld8 r3=[r3]
-	movl r2=init_thread_union
+	movl r2=init_task
 	;;
 	cmp.eq isBP,isAP=r3,r0
 	;;
 (isAP)	mov r2=r3
 #else
-	movl r2=init_thread_union
+	movl r2=init_task
 	cmp.eq isBP,isAP=r0,r0
 #endif
 	;;
diff -Nru a/arch/ia64/kernel/init_task.c b/arch/ia64/kernel/init_task.c
--- a/arch/ia64/kernel/init_task.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/init_task.c	Fri Jun 27 22:41:17 2003
@@ -26,17 +26,17 @@
  * We need to make sure that this is properly aligned due to the way process stacks are
  * handled. This is done by having a special ".data.init_task" section...
  */
-#define init_thread_info	init_thread_union.s.thread_info
+#define init_thread_info	init_task_mem.s.thread_info
 
-union init_thread {
+static union {
 	struct {
 		struct task_struct task;
 		struct thread_info thread_info;
 	} s;
 	unsigned long stack[KERNEL_STACK_SIZE/sizeof (unsigned long)];
-} init_thread_union __attribute__((section(".data.init_task"))) = {{
-	.task =		INIT_TASK(init_thread_union.s.task),
-	.thread_info =	INIT_THREAD_INFO(init_thread_union.s.task)
+} init_task_mem __attribute__((section(".data.init_task"))) = {{
+	.task =		INIT_TASK(init_task_mem.s.task),
+	.thread_info =	INIT_THREAD_INFO(init_task_mem.s.task)
 }};
 
-asm (".global init_task; init_task = init_thread_union");
+asm (".global init_task; init_task = init_task_mem");
diff -Nru a/arch/ia64/kernel/iosapic.c b/arch/ia64/kernel/iosapic.c
--- a/arch/ia64/kernel/iosapic.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/iosapic.c	Fri Jun 27 22:41:17 2003
@@ -382,7 +382,7 @@
 static void
 iosapic_ack_edge_irq (unsigned int irq)
 {
-	irq_desc_t *idesc = irq_desc(irq);
+	irq_desc_t *idesc = irq_descp(irq);
 	/*
 	 * Once we have recorded IRQ_PENDING already, we can mask the
 	 * interrupt for real. This prevents IRQ storms from unhandled
@@ -478,7 +478,7 @@
 	else
 		irq_type = &irq_type_iosapic_level;
 
-	idesc = irq_desc(vector);
+	idesc = irq_descp(vector);
 	if (idesc->handler != irq_type) {
 		if (idesc->handler != &no_irq_type)
 			printk(KERN_WARNING "%s: changing vector %d from %s to %s\n",
@@ -724,7 +724,7 @@
 		 * If vector was previously initialized to a different
 		 * handler, re-initialize.
 		 */
-		idesc = irq_desc(vector);
+		idesc = irq_descp(vector);
 		if (idesc->handler != irq_type)
 			register_intr(gsi, vector, IOSAPIC_LOWEST_PRIORITY, IOSAPIC_POL_LOW,
 				      IOSAPIC_LEVEL);
diff -Nru a/arch/ia64/kernel/irq.c b/arch/ia64/kernel/irq.c
--- a/arch/ia64/kernel/irq.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/irq.c	Fri Jun 27 22:41:17 2003
@@ -74,7 +74,7 @@
 };
 
 #ifdef CONFIG_IA64_GENERIC
-struct irq_desc * __ia64_irq_desc (unsigned int irq)
+irq_desc_t * __ia64_irq_desc (unsigned int irq)
 {
 	return _irq_desc + irq;
 }
@@ -171,7 +171,7 @@
 	seq_putc(p, '\n');
 
 	for (i = 0 ; i < NR_IRQS ; i++) {
-		idesc = irq_desc(i);
+		idesc = irq_descp(i);
 		spin_lock_irqsave(&idesc->lock, flags);
 		action = idesc->action;
 		if (!action)
@@ -218,7 +218,7 @@
 #ifdef CONFIG_SMP
 inline void synchronize_irq(unsigned int irq)
 {
-	while (irq_desc(irq)->status & IRQ_INPROGRESS)
+	while (irq_descp(irq)->status & IRQ_INPROGRESS)
 		cpu_relax();
 }
 #endif
@@ -352,7 +352,7 @@
 
 inline void disable_irq_nosync(unsigned int irq)
 {
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = irq_descp(irq);
 	unsigned long flags;
 
 	spin_lock_irqsave(&desc->lock, flags);
@@ -395,7 +395,7 @@
 
 void enable_irq(unsigned int irq)
 {
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = irq_descp(irq);
 	unsigned long flags;
 
 	spin_lock_irqsave(&desc->lock, flags);
@@ -437,7 +437,7 @@
 	 * 0 return value means that this irq is already being
 	 * handled by some other CPU. (or is disabled)
 	 */
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = irq_descp(irq);
 	struct irqaction * action;
 	irqreturn_t action_ret;
 	unsigned int status;
@@ -620,7 +620,7 @@
 	if (irq >= NR_IRQS)
 		return;
 
-	desc = irq_desc(irq);
+	desc = irq_descp(irq);
 	spin_lock_irqsave(&desc->lock,flags);
 	p = &desc->action;
 	for (;;) {
@@ -682,7 +682,7 @@
 	 * flush such a longstanding irq before considering it as spurious.
 	 */
 	for (i = NR_IRQS-1; i > 0; i--)  {
-		desc = irq_desc(i);
+		desc = irq_descp(i);
 
 		spin_lock_irq(&desc->lock);
 		if (!desc->action)
@@ -700,7 +700,7 @@
 	 * happened in the previous stage, it may have masked itself)
 	 */
 	for (i = NR_IRQS-1; i > 0; i--) {
-		desc = irq_desc(i);
+		desc = irq_descp(i);
 
 		spin_lock_irq(&desc->lock);
 		if (!desc->action) {
@@ -722,7 +722,7 @@
 	 */
 	val = 0;
 	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = irq_descp(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -762,7 +762,7 @@
 
 	mask = 0;
 	for (i = 0; i < 16; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = irq_descp(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -807,7 +807,7 @@
 	nr_irqs = 0;
 	irq_found = 0;
 	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc_t *desc = irq_desc(i);
+		irq_desc_t *desc = irq_descp(i);
 		unsigned int status;
 
 		spin_lock_irq(&desc->lock);
@@ -836,7 +836,7 @@
 	int shared = 0;
 	unsigned long flags;
 	struct irqaction *old, **p;
-	irq_desc_t *desc = irq_desc(irq);
+	irq_desc_t *desc = irq_descp(irq);
 
 	if (desc->handler == &no_irq_type)
 		return -ENOSYS;
@@ -963,15 +963,16 @@
 }
 
 static int irq_affinity_write_proc (struct file *file, const char *buffer,
-					unsigned long count, void *data)
+				    unsigned long count, void *data)
 {
 	unsigned int irq = (unsigned long) data;
 	int full_count = count, err;
 	unsigned long new_value;
 	const char *buf = buffer;
+	irq_desc_t *desc = irq_descp(irq);
 	int redir;
 
-	if (!irq_desc(irq)->handler->set_affinity)
+	if (!desc->handler->set_affinity)
 		return -EIO;
 
 	if (buf[0] == 'r' || buf[0] == 'R') {
@@ -993,8 +994,7 @@
 	if (!(new_value & cpu_online_map))
 		return -EINVAL;
 
-	irq_desc(irq)->handler->set_affinity(irq | (redir? IA64_IRQ_REDIRECTED : 0), new_value);
-
+	desc->handler->set_affinity(irq | (redir? IA64_IRQ_REDIRECTED : 0), new_value);
 	return full_count;
 }
 
@@ -1030,7 +1030,7 @@
 {
 	char name [MAX_NAMELEN];
 
-	if (!root_irq_dir || (irq_desc(irq)->handler == &no_irq_type) || irq_dir[irq])
+	if (!root_irq_dir || (irq_descp(irq)->handler == &no_irq_type) || irq_dir[irq])
 		return;
 
 	memset(name, 0, MAX_NAMELEN);
@@ -1083,7 +1083,7 @@
 	 * Create entries for all existing IRQs.
 	 */
 	for (i = 0; i < NR_IRQS; i++) {
-		if (irq_desc(i)->handler == &no_irq_type)
+		if (irq_descp(i)->handler == &no_irq_type)
 			continue;
 		register_irq_proc(i);
 	}
diff -Nru a/arch/ia64/kernel/irq_ia64.c b/arch/ia64/kernel/irq_ia64.c
--- a/arch/ia64/kernel/irq_ia64.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/irq_ia64.c	Fri Jun 27 22:41:17 2003
@@ -162,7 +162,7 @@
 
 	for (irq = 0; irq < NR_IRQS; ++irq)
 		if (irq_to_vector(irq) == vec) {
-			desc = irq_desc(irq);
+			desc = irq_descp(irq);
 			desc->status |= IRQ_PER_CPU;
 			desc->handler = &irq_type_ia64_lsapic;
 			if (action)
diff -Nru a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
--- a/arch/ia64/kernel/mca.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/mca.c	Fri Jun 27 22:41:17 2003
@@ -734,7 +734,7 @@
 		if (cpev >= 0) {
 			for (irq = 0; irq < NR_IRQS; ++irq)
 				if (irq_to_vector(irq) == cpev) {
-					desc = irq_desc(irq);
+					desc = irq_descp(irq);
 					desc->status |= IRQ_PER_CPU;
 					desc->handler = &irq_type_iosapic_level;
 					setup_irq(irq, &mca_cpe_irqaction);
diff -Nru a/arch/ia64/kernel/perfmon.c b/arch/ia64/kernel/perfmon.c
--- a/arch/ia64/kernel/perfmon.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/perfmon.c	Fri Jun 27 22:41:17 2003
@@ -115,6 +115,8 @@
 #define PMD_IS_COUNTING(i) ((pmu_conf.pmd_desc[i].type & PFM_REG_COUNTING) == PFM_REG_COUNTING)
 #define PMC_IS_COUNTING(i) ((pmu_conf.pmc_desc[i].type & PFM_REG_COUNTING) == PFM_REG_COUNTING)
 #define PMC_IS_MONITOR(i)  ((pmu_conf.pmc_desc[i].type & PFM_REG_MONITOR)  == PFM_REG_MONITOR)
+#define PMC_IS_CONTROL(i)  ((pmu_conf.pmc_desc[i].type & PFM_REG_CONTROL)  == PFM_REG_CONTROL)
+
 #define PMC_DFL_VAL(i)     pmu_conf.pmc_desc[i].default_value
 #define PMC_RSVD_MASK(i)   pmu_conf.pmc_desc[i].reserved_mask
 #define PMD_PMD_DEP(i)	   pmu_conf.pmd_desc[i].dep_pmd[0]
@@ -232,6 +234,8 @@
  */
 #define PMC0_HAS_OVFL(cmp0)  (cmp0 & ~0x1UL)
 
+#define PFMFS_MAGIC 0xa0b4d889
+
 /*
  * debugging
  */
@@ -328,7 +332,7 @@
 
 	pfm_counter_t		ctx_pmds[IA64_NUM_PMD_REGS]; /* software state for PMDS */
 
-	u64			ctx_saved_psr;		/* copy of psr used for ctxsw */
+	u64			ctx_saved_psr_up;	/* only contains psr.up value */
 
 	unsigned long		ctx_last_activation;	/* context last activation number for last_cpu */
 	unsigned int		ctx_last_cpu;		/* CPU id of current or last CPU used (SMP only) */
@@ -560,100 +564,6 @@
 	close: pfm_vm_close
 };
 
-/*
- * Linux 2.5 vs. 2.4 helper macros and definitions
- *
- * if not at least 2.5.69, then assume 2.4.x.
- */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
-
-#define PFM_COMPILED_FOR_2_4 1
-
-#include <linux/wrapper.h>
-
-#define pfm_get_cpu_var(v)	local_cpu_data->v
-#define pfm_get_cpu_data(a,b)	cpu_data((b))->a
-typedef	void pfm_irq_handler_t;
-#define PFM_IRQ_HANDLER_RET(v)
-
-#define DEFINE_PER_CPU(a,b)
-
-static inline int
-pfm_wait_task_inactive(struct task_struct *task)
-{
-#ifdef CONFIG_SMP
-	/* Make sure the child gets off its CPU.. */
-	for (;;) {
-		task_lock(task);
-		if (!task_has_cpu(task)) break;
-		task_unlock(task);
-		do {
-			if (task->state != TASK_STOPPED)
-				return -ESRCH;
-			barrier();
-			cpu_relax();
-		} while (task_has_cpu(task));
-	}
-	task_unlock(task);
-#endif
-	return 0;
-}
-
-static inline void
-pfm_put_task(struct task_struct *task)
-{
-	if (task != current) free_task_struct(task);
-}
-
-static inline void
-pfm_set_task_notify(struct task_struct *task)
-{
-}
-
-static inline void
-pfm_clear_task_notify(void)
-{
-}
-
-static inline void
-pfm_reserve_page(unsigned long a)
-{
-	unsigned long page;
-
-	page = ia64_tpa(a);
-	mem_map_reserve(virt_to_page(__va(page)));
-}
-
-static inline void
-pfm_unreserve_page(unsigned long a)
-{
-	unsigned long page;
-
-	page = ia64_tpa(a);
-	mem_map_unreserve(virt_to_page(__va(page)));
-}
-
-static inline int
-pfm_remap_page_range(struct vm_area_struct *vma, unsigned long from, unsigned long phys_addr, unsigned long size, pgprot_t prot)
-{
-	return remap_page_range(from, phys_addr, size, prot);
-}
-
-static inline unsigned long
-pfm_protect_ctx_ctxsw(pfm_context_t *x)
-{
-	unsigned long f;
-	spin_lock(&(x)->ctx_lock);
-	return f;
-}
-
-static inline unsigned long
-pfm_unprotect_ctx_ctxsw(pfm_context_t *x, unsigned long f)
-{
-	spin_unlock(&(x)->ctx_lock);
-}
-
-#else /* 2.5.69 or higher */
 
 #define pfm_wait_task_inactive(t)	wait_task_inactive(t)
 #define pfm_get_cpu_var(v)		__get_cpu_var(v)
@@ -705,7 +615,7 @@
 static inline unsigned long
 pfm_protect_ctx_ctxsw(pfm_context_t *x)
 {
-	spin_lock_irq(&(x)->ctx_lock);
+	spin_lock(&(x)->ctx_lock);
 	return 0UL;
 }
 
@@ -715,7 +625,30 @@
 	spin_unlock(&(x)->ctx_lock);
 }
 
-#endif /* 2.5 vs. 2.4 */
+static inline unsigned int
+pfm_do_munmap(struct mm_struct *mm, unsigned long addr, size_t len, int acct)
+{
+	return do_munmap(mm, addr, len);
+}
+
+static inline unsigned long 
+pfm_get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags, unsigned long exec)
+{
+	return get_unmapped_area(file, addr, len, pgoff, flags);
+}
+
+
+static struct super_block *
+pfmfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+{
+	return get_sb_pseudo(fs_type, "pfm:", NULL, PFMFS_MAGIC);
+}
+
+static struct file_system_type pfm_fs_type = {
+	.name     = "pfmfs",
+	.get_sb   = pfmfs_get_sb,
+	.kill_sb  = kill_anon_super,
+};
 
 DEFINE_PER_CPU(unsigned long, pfm_syst_info);
 DEFINE_PER_CPU(struct task_struct *, pmu_owner);
@@ -758,13 +691,13 @@
 static inline void
 pfm_clear_psr_up(void)
 {
-	__asm__ __volatile__ ("rum psr.up;; srlz.i;;"::: "memory");
+	__asm__ __volatile__ ("rsm psr.up;; srlz.i;;"::: "memory");
 }
 
 static inline void
 pfm_set_psr_up(void)
 {
-	__asm__ __volatile__ ("sum psr.up;; srlz.i;;"::: "memory");
+	__asm__ __volatile__ ("ssm psr.up;; srlz.i;;"::: "memory");
 }
 
 static inline unsigned long
@@ -1502,7 +1435,7 @@
 
 	DPRINT(("down_write done smpl_vaddr=%p size=%lu\n", vaddr, size));
 
-	r = do_munmap(task->mm, (unsigned long)vaddr, size);
+	r = pfm_do_munmap(task->mm, (unsigned long)vaddr, size, 0);
 
 	up_write(&task->mm->mmap_sem);
 	if (r !=0) {
@@ -1569,68 +1502,6 @@
  * d_name - pfm: will go nicely and kill the special-casing in procfs.
  */
 static struct vfsmount *pfmfs_mnt;
-#define PFMFS_MAGIC 0xa0b4d889
-
-#ifdef PFM_COMPILED_FOR_2_4
-
-static int
-pfmfs_statfs(struct super_block *sb, struct statfs *buf)
-{
-	buf->f_type = PFMFS_MAGIC;
-	buf->f_bsize = 1024;
-	buf->f_namelen = 255;
-	return 0;
-}
-
-static struct super_operations pfmfs_ops = {
-	statfs:		pfmfs_statfs,
-};
-
-static struct super_block *
-pfmfs_read_super(struct super_block *sb, void *data, int silent)
-{
-	struct inode *root = new_inode(sb);
-	if (!root)
-		return NULL;
-	root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
-	root->i_uid = root->i_gid = 0;
-	root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
-	sb->s_blocksize = 1024;
-	sb->s_blocksize_bits = 10;
-	sb->s_magic = PFMFS_MAGIC;
-	sb->s_op	= &pfmfs_ops;
-	sb->s_root = d_alloc(NULL, &(const struct qstr) { "pfm:", 4, 0 });
-	if (!sb->s_root) {
-		iput(root);
-		return NULL;
-	}
-	sb->s_root->d_sb = sb;
-	sb->s_root->d_parent = sb->s_root;
-	d_instantiate(sb->s_root, root);
-	return sb;
-}
-
-//static DECLARE_FSTYPE(pfm_fs_type, "pfmfs", pfmfs_read_super, FS_NOMOUNT);
-static struct file_system_type pfm_fs_type = {
-	name:		"pfmfs",
-	read_super:	pfmfs_read_super,
-	fs_flags:	FS_NOMOUNT,
-};
-
-#else /* ! COMPILED_FOR_2_4 */
-
-static struct super_block *
-pfmfs_get_sb(struct file_system_type *fs_type, int flags, char *dev_name, void *data)
-{
-	return get_sb_pseudo(fs_type, "pfm:", NULL, PFMFS_MAGIC);
-}
-
-static struct file_system_type pfm_fs_type = {
-	.name     = "pfmfs",
-	.get_sb   = pfmfs_get_sb,
-	.kill_sb  = kill_anon_super,
-};
-#endif /* COMPILED_FOR_2_4 */
 
 static int __init
 init_pfm_fs(void)
@@ -2453,7 +2324,7 @@
 	down_write(&task->mm->mmap_sem);
 
 	/* find some free area in address space, must have mmap sem held */
-	vma->vm_start = get_unmapped_area(NULL, 0, size, 0, MAP_PRIVATE|MAP_ANONYMOUS);
+	vma->vm_start = pfm_get_unmapped_area(NULL, 0, size, 0, MAP_PRIVATE|MAP_ANONYMOUS, 0);
 	if (vma->vm_start == 0UL) {
 		DPRINT(("Cannot find unmapped area for size %ld\n", size));
 		up_write(&task->mm->mmap_sem);
@@ -3020,7 +2891,7 @@
 		 * as attempts to modify PMC[0-3] which are used
 		 * as status registers by the PMU
 		 */
-		if (!PMC_IS_IMPL(cnum) || cnum < 4) {
+		if (PMC_IS_IMPL(cnum) == 0 || PMC_IS_CONTROL(cnum)) {
 			DPRINT(("pmc%u is unimplemented or invalid\n", cnum));
 			goto error;
 		}
@@ -4124,7 +3995,7 @@
 		/*
 		 * monitoring disabled in kernel at next reschedule
 		 */
-		ctx->ctx_saved_psr &= ~IA64_PSR_UP;
+		ctx->ctx_saved_psr_up = 0;
 		printk("pfm_stop: current [%d] task=[%d]\n", current->pid, ctx->ctx_task->pid);
 	}
 	return 0;
@@ -4198,7 +4069,7 @@
 		 * start monitoring at the kernel level the next
 		 * time the task is scheduled
 		 */
-		ctx->ctx_saved_psr |= IA64_PSR_UP;
+		ctx->ctx_saved_psr_up = IA64_PSR_UP;
 
 		/*
 		 * activate monitoring at user level
@@ -4429,7 +4300,7 @@
 		SET_LAST_CPU(ctx, -1);
 
 		/* initial saved psr (stopped) */
-		ctx->ctx_saved_psr = pfm_get_psr() & ~(IA64_PSR_PP|IA64_PSR_UP);
+		ctx->ctx_saved_psr_up = 0UL;
 		ia64_psr(regs)->up = ia64_psr(regs)->pp = 0;
 
 		if (ctx->ctx_fl_unsecure) {
@@ -5640,6 +5511,7 @@
 	unsigned long flags;
 	u64 psr;
 
+
 	ctx = PFM_GET_CTX(task);
 	if (ctx == NULL) goto save_error;
 	t = &task->thread;
@@ -5672,9 +5544,9 @@
 	 * sanity check
 	 */
 	if (ctx->ctx_last_activation != GET_ACTIVATION()) {
-		DPRINT(("ctx_activation=%lu activation=%lu state=%d: no save\n",
+		printk("ctx_activation=%lu activation=%lu state=%d: no save\n",
 				ctx->ctx_last_activation,
-				GET_ACTIVATION(), ctx->ctx_state));
+				GET_ACTIVATION(), ctx->ctx_state);
 
 		pfm_unprotect_ctx_ctxsw(ctx, flags);
 
@@ -5684,8 +5556,11 @@
 	/*
 	 * save current PSR: needed because we modify it
 	 */
+	ia64_srlz_d();
 	psr = pfm_get_psr();
 
+	BUG_ON(psr & (IA64_PSR_I));
+
 	/*
 	 * stop monitoring:
 	 * This is the last instruction which may generate an overflow
@@ -5696,9 +5571,13 @@
 	pfm_clear_psr_up();
 
 	/*
-	 * keep a copy of the saved psr (for reload)
+	 * keep a copy of psr.up (for reload)
 	 */
-	ctx->ctx_saved_psr = psr;
+	ctx->ctx_saved_psr_up = psr & IA64_PSR_UP;
+
+	{ u64 foo = pfm_get_psr();
+	  BUG_ON(foo & ((IA64_PSR_UP|IA64_PSR_PP)));
+	}
 
 	/*
 	 * release ownership of this PMU.
@@ -5772,18 +5651,16 @@
 	pfm_clear_psr_up();
 
 	/*
-	 * keep a copy of the saved psr (for reload)
+	 * keep a copy of psr.up (for reload)
 	 */
-	ctx->ctx_saved_psr = psr;
+	ctx->ctx_saved_psr_up = psr & IA64_PSR_UP;
 
-	psr = pfm_get_psr();
-	if (psr & IA64_PSR_UP) {
-		printk(KERN_ERR " perfmon: pfm_save_regs: psr.up set current [%d] owner [%d] psr=0x%lx\n", current->pid, GET_PMU_OWNER()->pid, psr);
-	}
-	if (psr & IA64_PSR_I) {
-		printk(KERN_ERR " perfmon: pfm_save_regs: psr.i set current [%d] owner [%d] psr=0x%lx\n", current->pid, GET_PMU_OWNER()->pid, psr);
+#if 1
+	{ u64 foo = pfm_get_psr();
+	  BUG_ON(foo & (IA64_PSR_I));
+	  BUG_ON(foo & ((IA64_PSR_UP|IA64_PSR_PP)));
 	}
-
+#endif
 	return;
 save_error:
 	printk(KERN_ERR "perfmon: pfm_save_regs CPU%d [%d] NULL context PM_VALID=%ld\n",
@@ -5797,13 +5674,10 @@
 	pfm_context_t *ctx;
 	struct thread_struct *t;
 	unsigned long flags;
-	unsigned long psr;
 
 #if 1
-	psr = pfm_get_psr();
-	if (psr & IA64_PSR_UP) {
-		printk(KERN_ERR " perfmon: pfm_lazy_save_regs: psr.up set current [%d] owner [%d] psr=0x%lx\n", current->pid, task->pid, psr);
-		pfm_clear_psr_up();
+	{ u64 foo  = pfm_get_psr();
+	  BUG_ON(foo & IA64_PSR_UP);
 	}
 #endif
 
@@ -5864,10 +5738,9 @@
 {
 	pfm_context_t *ctx;
 	struct thread_struct *t;
-	struct task_struct *owner;
 	unsigned long pmc_mask = 0UL, pmd_mask = 0UL;
 	unsigned long flags;
-	u64 psr;
+	u64 psr, psr_up;
 
 	ctx = PFM_GET_CTX(task);
 	if (unlikely(ctx == NULL)) {
@@ -5875,22 +5748,21 @@
 		return;
 	}
 
-	owner = GET_PMU_OWNER();
+	BUG_ON(GET_PMU_OWNER());
+
 	t     = &task->thread;
+	psr   = pfm_get_psr();
 
 #if 1
-	psr = pfm_get_psr();
-	BUG_ON(psr & IA64_PSR_UP);
-	psr = pfm_get_psr();
+	BUG_ON(psr & (IA64_PSR_UP|IA64_PSR_PP));
 	BUG_ON(psr & IA64_PSR_I);
 #endif
 
-
 	/*
 	 * possible on unload
 	 */
 	if (unlikely((t->flags & IA64_THREAD_PM_VALID) == 0)) {
-		DPRINT(("[%d] PM_VALID=0, nothing to do\n", task->pid));
+		printk("[%d] PM_VALID=0, nothing to do\n", task->pid);
 		return;
 	}
 
@@ -5923,19 +5795,15 @@
 	/*
 	 * we restore ALL the debug registers to avoid picking up
 	 * stale state.
-	 *
-	 * This must be done even when the task is still the owner
-	 * as the registers may have been modified via ptrace()
-	 * (not perfmon) by the previous task.
 	 */
 	if (ctx->ctx_fl_using_dbreg) {
 		pfm_restore_ibrs(ctx->ctx_ibrs, pmu_conf.num_ibrs);
 		pfm_restore_dbrs(ctx->ctx_dbrs, pmu_conf.num_dbrs);
 	}
 	/*
-	 * retrieve saved psr
+	 * retrieve saved psr.up
 	 */
-	psr = ctx->ctx_saved_psr;
+	psr_up = ctx->ctx_saved_psr_up;
 
 	/*
 	 * if we were the last user of the PMU on that CPU,
@@ -5968,8 +5836,8 @@
 	 	 */
 		pmc_mask = ctx->ctx_all_pmcs[0];
 
-		DPRINT(("full reload for [%d] owner=%d activation=%lu last_activation=%lu last_cpu=%d pmd_mask=0x%lx pmc_mask=0x%lx\n",
-			task->pid, owner ? owner->pid : -1,
+		DPRINT(("full reload for [%d] activation=%lu last_activation=%lu last_cpu=%d pmd_mask=0x%lx pmc_mask=0x%lx\n",
+			task->pid,
 			GET_ACTIVATION(), ctx->ctx_last_activation,
 			GET_LAST_CPU(ctx), pmd_mask, pmc_mask));
 
@@ -6026,9 +5894,9 @@
 	SET_PMU_OWNER(task, ctx);
 
 	/*
-	 * restore the psr we changed
+	 * restore the psr.up bit 
 	 */
-	pfm_set_psr_l(psr);
+	if (likely(psr_up)) pfm_set_psr_up();
 
 	/*
 	 * allow concurrent access to context
@@ -6047,21 +5915,16 @@
 	pfm_context_t *ctx;
 	struct task_struct *owner;
 	unsigned long pmd_mask, pmc_mask;
-	u64 psr;
+	u64 psr, psr_up;
 
-	owner      = GET_PMU_OWNER();
-	ctx        = PFM_GET_CTX(task);
-	t          = &task->thread;
+	owner = GET_PMU_OWNER();
+	ctx   = PFM_GET_CTX(task);
+	t     = &task->thread;
+	psr   = pfm_get_psr();
 
 #if 1
-	psr = pfm_get_psr();
-	if (psr & IA64_PSR_UP) {
-		printk(KERN_ERR " perfmon: pfm_load_regs: psr.up set current [%d] owner [%d] psr=0x%lx\n", current->pid, owner->pid, psr);
-	}
-	psr = pfm_get_psr();
-	if (psr & IA64_PSR_I) {
-		printk(KERN_ERR " perfmon: pfm_load_regs: psr.i set current [%d] owner [%d] psr=0x%lx\n", current->pid, owner->pid, psr);
-	}
+	BUG_ON(psr & (IA64_PSR_UP|IA64_PSR_PP));
+	BUG_ON(psr & IA64_PSR_I);
 #endif
 
 	/*
@@ -6078,9 +5941,9 @@
 	}
 
 	/*
-	 * retrieved save psr
+	 * retrieved saved psr.up
 	 */
-	psr = ctx->ctx_saved_psr;
+	psr_up = ctx->ctx_saved_psr_up;
 
 	/*
 	 * short path, our state is still there, just
@@ -6091,7 +5954,7 @@
 	 * concurrency even without interrupt masking.
 	 */
 	if (likely(owner == task)) {
-		pfm_set_psr_l(psr);
+		if (likely(psr_up)) pfm_set_psr_up();
 		return;
 	}
 
@@ -6163,8 +6026,7 @@
 	 * restore the psr. This is the point at which
 	 * new overflow interrupts can be generated again.
 	 */
-	pfm_set_psr_l(psr);
-
+	if (likely(psr_up)) pfm_set_psr_up();
 }
 #endif /* CONFIG_SMP */
 
@@ -6469,13 +6331,13 @@
 		printk("pmd[%d]=0x%lx tpmd=0x%lx\n", i, ia64_get_pmd(i), t->pmds[i]);
 	}
 	if (ctx) {
-		printk("ctx_state=%d vaddr=%p addr=%p fd=%d ctx_task=[%d] saved_psr=0x%lx\n",
+		printk("ctx_state=%d vaddr=%p addr=%p fd=%d ctx_task=[%d] saved_psr_up=0x%lx\n",
 				ctx->ctx_state,
 				ctx->ctx_smpl_vaddr,
 				ctx->ctx_smpl_hdr,
 				ctx->ctx_msgq_head,
 				ctx->ctx_msgq_tail,
-				ctx->ctx_saved_psr);
+				ctx->ctx_saved_psr_up);
 	}
 }
 
diff -Nru a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
--- a/arch/ia64/kernel/process.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/process.c	Fri Jun 27 22:41:17 2003
@@ -45,7 +45,7 @@
 ia64_do_show_stack (struct unw_frame_info *info, void *arg)
 {
 	unsigned long ip, sp, bsp;
-	char buf[80];			/* don't make it so big that it overflows the stack! */
+	char buf[128];			/* don't make it so big that it overflows the stack! */
 
 	printk("\nCall Trace:\n");
 	do {
@@ -55,7 +55,9 @@
 
 		unw_get_sp(info, &sp);
 		unw_get_bsp(info, &bsp);
-		snprintf(buf, sizeof(buf), " [<%016lx>] %%s\n\t\t\t\tsp=%016lx bsp=%016lx\n",
+		snprintf(buf, sizeof(buf),
+			 " [<%016lx>] %%s\n"
+			 "                                sp=%016lx bsp=%016lx\n",
 			 ip, sp, bsp);
 		print_symbol(buf, ip);
 	} while (unw_unwind(info) >= 0);
diff -Nru a/arch/ia64/kernel/ptrace.c b/arch/ia64/kernel/ptrace.c
--- a/arch/ia64/kernel/ptrace.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/ptrace.c	Fri Jun 27 22:41:17 2003
@@ -199,13 +199,15 @@
  *   rnat0/rnat1 gets its value from sw->ar_rnat.
  */
 static unsigned long
-get_rnat (struct pt_regs *pt, struct switch_stack *sw,
+get_rnat (struct task_struct *task, struct switch_stack *sw,
 	  unsigned long *krbs, unsigned long *urnat_addr, unsigned long *urbs_end)
 {
 	unsigned long rnat0 = 0, rnat1 = 0, urnat = 0, *slot0_kaddr, umask = 0, mask, m;
 	unsigned long *kbsp, *ubspstore, *rnat0_kaddr, *rnat1_kaddr, shift;
 	long num_regs, nbits;
+	struct pt_regs *pt;
 
+	pt = ia64_task_regs(task);
 	kbsp = (unsigned long *) sw->ar_bspstore;
 	ubspstore = (unsigned long *) pt->ar_bspstore;
 
@@ -254,21 +256,41 @@
  * The reverse of get_rnat.
  */
 static void
-put_rnat (struct pt_regs *pt, struct switch_stack *sw,
+put_rnat (struct task_struct *task, struct switch_stack *sw,
 	  unsigned long *krbs, unsigned long *urnat_addr, unsigned long urnat,
 	  unsigned long *urbs_end)
 {
 	unsigned long rnat0 = 0, rnat1 = 0, *slot0_kaddr, umask = 0, mask, m;
 	unsigned long *kbsp, *ubspstore, *rnat0_kaddr, *rnat1_kaddr, shift;
 	long num_regs, nbits;
+	struct pt_regs *pt;
+	unsigned long cfm, *urbs_kargs;
+	struct unw_frame_info info;
 
+	pt = ia64_task_regs(task);
 	kbsp = (unsigned long *) sw->ar_bspstore;
 	ubspstore = (unsigned long *) pt->ar_bspstore;
 
-	if (urbs_end < urnat_addr)
-		nbits = ia64_rse_num_regs(urnat_addr - 63, urbs_end);
-	else
+	urbs_kargs = urbs_end;
+	if ((long)pt->cr_ifs >= 0) {
+		/*
+		 * If entered via syscall, don't allow user to set rnat bits
+		 * for syscall args.
+		 */
+		unw_init_from_blocked_task(&info,task);
+		if (unw_unwind_to_user(&info) == 0) {
+			unw_get_cfm(&info,&cfm);
+			urbs_kargs = ia64_rse_skip_regs(urbs_end,-(cfm & 0x7f));
+		}
+	}
+
+	if (urbs_kargs >= urnat_addr)
 		nbits = 63;
+	else {
+		if ((urnat_addr - 63) >= urbs_kargs)
+			return;
+		nbits = ia64_rse_num_regs(urnat_addr - 63, urbs_kargs);
+	}
 	mask = (1UL << nbits) - 1;
 
 	/*
@@ -339,7 +361,7 @@
 		 * read the corresponding bits in the kernel RBS.
 		 */
 		rnat_addr = ia64_rse_rnat_addr(laddr);
-		ret = get_rnat(child_regs, child_stack, krbs, rnat_addr, urbs_end);
+		ret = get_rnat(child, child_stack, krbs, rnat_addr, urbs_end);
 
 		if (laddr == rnat_addr) {
 			/* return NaT collection word itself */
@@ -390,7 +412,7 @@
 		 * => write the corresponding bits in the kernel RBS.
 		 */
 		if (ia64_rse_is_rnat_slot(laddr))
-			put_rnat(child_regs, child_stack, krbs, laddr, val, urbs_end);
+			put_rnat(child, child_stack, krbs, laddr, val, urbs_end);
 		else {
 			if (laddr < urbs_end) {
 				regnum = ia64_rse_num_regs(bspstore, laddr);
diff -Nru a/arch/ia64/kernel/smpboot.c b/arch/ia64/kernel/smpboot.c
--- a/arch/ia64/kernel/smpboot.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/smpboot.c	Fri Jun 27 22:41:17 2003
@@ -452,7 +452,7 @@
 		sapicid = smp_boot_data.cpu_phys_id[i];
 		if (sapicid == boot_cpu_id)
 			continue;
-		phys_cpu_present_map |= (1 << cpu);
+		phys_cpu_present_map |= (1UL << cpu);
 		ia64_cpu_to_sapicid[cpu] = sapicid;
 		cpu++;
 	}
diff -Nru a/arch/ia64/kernel/sys_ia64.c b/arch/ia64/kernel/sys_ia64.c
--- a/arch/ia64/kernel/sys_ia64.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/sys_ia64.c	Fri Jun 27 22:41:17 2003
@@ -26,8 +26,9 @@
 			unsigned long pgoff, unsigned long flags)
 {
 	long map_shared = (flags & MAP_SHARED);
-	unsigned long align_mask = PAGE_SIZE - 1;
-	struct vm_area_struct * vmm;
+	unsigned long start_addr, align_mask = PAGE_SIZE - 1;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
 
 	if (len > RGN_MAP_LIMIT)
 		return -ENOMEM;
@@ -37,7 +38,7 @@
 		addr = 0;
 #endif
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = mm->free_area_cache;
 
 	if (map_shared && (TASK_SIZE > 0xfffffffful))
 		/*
@@ -48,17 +49,25 @@
 		 */
 		align_mask = SHMLBA - 1;
 
-	addr = (addr + align_mask) & ~align_mask;
+  full_search:
+	start_addr = addr = (addr + align_mask) & ~align_mask;
 
-	for (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {
-		/* At this point:  (!vmm || addr < vmm->vm_end). */
-		if (TASK_SIZE - len < addr)
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {
+			if (start_addr != TASK_UNMAPPED_BASE) {
+				/* Start a new search --- just in case we missed some holes.  */
+				addr = TASK_UNMAPPED_BASE;
+				goto full_search;
+			}
 			return -ENOMEM;
-		if (REGION_OFFSET(addr) + len > RGN_MAP_LIMIT)	/* no risk of overflow here... */
-			return -ENOMEM;
-		if (!vmm || addr + len <= vmm->vm_start)
+		}
+		if (!vma || addr + len <= vma->vm_start) {
+			/* Remember the address where we stopped this search:  */
+			mm->free_area_cache = addr + len;
 			return addr;
-		addr = (vmm->vm_end + align_mask) & ~align_mask;
+		}
+		addr = (vma->vm_end + align_mask) & ~align_mask;
 	}
 }
 
diff -Nru a/arch/ia64/kernel/unwind.c b/arch/ia64/kernel/unwind.c
--- a/arch/ia64/kernel/unwind.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/kernel/unwind.c	Fri Jun 27 22:41:17 2003
@@ -58,15 +58,9 @@
 
 #ifdef UNW_DEBUG
   static unsigned int unw_debug_level = UNW_DEBUG;
-#  ifdef CONFIG_KDB
-#    include <linux/kdb.h>
-#    define UNW_DEBUG_ON(n)	(unw_debug_level >= n && !KDB_IS_RUNNING())
-#    define UNW_DPRINT(n, ...)	if (UNW_DEBUG_ON(n)) kdb_printf(__VA_ARGS__)
-#  else	/* !CONFIG_KDB */
-#    define UNW_DEBUG_ON(n)	unw_debug_level >= n
-     /* Do not code a printk level, not all debug lines end in newline */
-#    define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
-#  endif /* CONFIG_KDB */
+#  define UNW_DEBUG_ON(n)	unw_debug_level >= n
+   /* Do not code a printk level, not all debug lines end in newline */
+#  define UNW_DPRINT(n, ...)  if (UNW_DEBUG_ON(n)) printk(__VA_ARGS__)
 #  define inline
 #else /* !UNW_DEBUG */
 #  define UNW_DEBUG_ON(n)  0
@@ -2124,7 +2118,7 @@
 	kfree(table);
 }
 
-static void __init
+static int __init
 create_gate_table (void)
 {
 	const struct unw_table_entry *entry, *start, *end;
@@ -2142,7 +2136,7 @@
 
 	if (!punw) {
 		printk("%s: failed to find gate DSO's unwind table!\n", __FUNCTION__);
-		return;
+		return 0;
 	}
 
 	start = (const struct unw_table_entry *) punw->p_vaddr;
@@ -2159,7 +2153,7 @@
 	if (!unw.gate_table) {
 		unw.gate_table_size = 0;
 		printk(KERN_ERR "%s: unable to create unwind data for gate page!\n", __FUNCTION__);
-		return;
+		return 0;
 	}
 	unw.gate_table_size = size;
 
@@ -2176,6 +2170,7 @@
 		lp[2] = info - (char *) unw.gate_table;		/* info */
 	}
 	*lp = 0;	/* end-of-table marker */
+	return 0;
 }
 
 __initcall(create_gate_table);
diff -Nru a/arch/ia64/lib/Makefile b/arch/ia64/lib/Makefile
--- a/arch/ia64/lib/Makefile	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/lib/Makefile	Fri Jun 27 22:41:17 2003
@@ -12,12 +12,7 @@
 lib-$(CONFIG_ITANIUM)	+= copy_page.o copy_user.o memcpy.o
 lib-$(CONFIG_MCKINLEY)	+= copy_page_mck.o memcpy_mck.o
 lib-$(CONFIG_PERFMON)	+= carta_random.o
-
-ifeq ($(CONFIG_MD_RAID5),m)
-	lib-y += xor.o
-else
-	lib-$(CONFIG_MD_RAID5)	+= xor.o
-endif
+lib-$(CONFIG_MD_RAID5)	+= xor.o
 
 IGNORE_FLAGS_OBJS =	__divsi3.o __udivsi3.o __modsi3.o __umodsi3.o \
 			__divdi3.o __udivdi3.o __moddi3.o __umoddi3.o
diff -Nru a/arch/ia64/mm/init.c b/arch/ia64/mm/init.c
--- a/arch/ia64/mm/init.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/mm/init.c	Fri Jun 27 22:41:17 2003
@@ -121,7 +121,7 @@
 	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 	if (vma) {
 		vma->vm_mm = current->mm;
-		vma->vm_start = current->thread.rbs_bot;
+		vma->vm_start = current->thread.rbs_bot & PAGE_MASK;
 		vma->vm_end = vma->vm_start + PAGE_SIZE;
 		vma->vm_page_prot = protection_map[VM_DATA_DEFAULT_FLAGS & 0x7];
 		vma->vm_flags = VM_READ|VM_WRITE|VM_MAYREAD|VM_MAYWRITE|VM_GROWSUP;
diff -Nru a/arch/ia64/pci/pci.c b/arch/ia64/pci/pci.c
--- a/arch/ia64/pci/pci.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/pci/pci.c	Fri Jun 27 22:41:17 2003
@@ -364,8 +364,6 @@
 	return;
 }
 
-#warning pcibios_update_resource() is now a generic implementation - please check
-
 void __devinit
 pcibios_update_irq (struct pci_dev *dev, int irq)
 {
diff -Nru a/arch/ia64/scripts/toolchain-flags b/arch/ia64/scripts/toolchain-flags
--- a/arch/ia64/scripts/toolchain-flags	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/scripts/toolchain-flags	Fri Jun 27 22:41:17 2003
@@ -3,15 +3,13 @@
 # Check whether linker can handle cross-segment @segrel():
 #
 CC=$1
-LD=$2
-OBJDUMP=$3
+OBJDUMP=$2
 dir=$(dirname $0)
 tmp=${TMPDIR:-/tmp}
 out=$tmp/out$$
-$CC -c $dir/check-segrel.S -o $out.o
-$LD -static -T$dir/check-segrel.lds $out.o -o $out
+$CC -nostdlib -static -Wl,-T$dir/check-segrel.lds $dir/check-segrel.S -o $out
 res=$($OBJDUMP --full --section .rodata $out | fgrep 000 | cut -f3 -d' ')
-rm -f $out $out.o
+rm -f $out
 if [ $res != 00000a00 ]; then
     echo " -DHAVE_BUGGY_SEGREL"
     cat >&2 <<EOF
diff -Nru a/arch/ia64/sn/io/drivers/Makefile b/arch/ia64/sn/io/drivers/Makefile
--- a/arch/ia64/sn/io/drivers/Makefile	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/io/drivers/Makefile	Fri Jun 27 22:41:17 2003
@@ -9,4 +9,4 @@
 
 EXTRA_CFLAGS    := -DLITTLE_ENDIAN
 
-obj-y				+= ioconfig_bus.o ifconfig_net.o
+obj-y				+= ioconfig_bus.o
diff -Nru a/arch/ia64/sn/io/drivers/ifconfig_net.c b/arch/ia64/sn/io/drivers/ifconfig_net.c
--- a/arch/ia64/sn/io/drivers/ifconfig_net.c	Fri Jun 27 22:41:17 2003
+++ /dev/null	Wed Dec 31 16:00:00 1969
@@ -1,298 +0,0 @@
-/* $Id: ifconfig_net.c,v 1.1 2002/02/28 17:31:25 marcelo Exp $
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- *  ifconfig_net - SGI's Persistent Network Device names.
- *
- * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All rights reserved.
- */
-
-#include <linux/types.h>
-#include <linux/config.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-
-#include <asm/sn/sgi.h>
-#include <linux/devfs_fs.h>
-#include <linux/devfs_fs_kernel.h>
-#include <asm/io.h>
-#include <asm/sn/iograph.h>
-#include <asm/sn/invent.h>
-#include <asm/sn/hcl.h>
-#include <asm/sn/labelcl.h>
-#include <asm/sn/ifconfig_net.h>
-
-#define SGI_IFCONFIG_NET "SGI-PERSISTENT NETWORK DEVICE NAME DRIVER"
-#define SGI_IFCONFIG_NET_VERSION "1.0"
-
-/*
- * Some Global definitions.
- */
-static devfs_handle_t ifconfig_net_handle;
-static unsigned long ifconfig_net_debug;
-
-/*
- * ifconfig_net_open - Opens the special device node "/devhw/.ifconfig_net".
- */
-static int ifconfig_net_open(struct inode * inode, struct file * filp)
-{
-	if (ifconfig_net_debug) {
-        	printk("ifconfig_net_open called.\n");
-	}
-
-        return(0);
-
-}
-
-/*
- * ifconfig_net_close - Closes the special device node "/devhw/.ifconfig_net".
- */
-static int ifconfig_net_close(struct inode * inode, struct file * filp)
-{
-
-	if (ifconfig_net_debug) {
-        	printk("ifconfig_net_close called.\n");
-	}
-
-        return(0);
-}
-
-/*
- * assign_ifname - Assign the next available interface name from the persistent list.
- */
-void
-assign_ifname(struct net_device *dev,
-		  struct ifname_num *ifname_num)
-
-{
-
-	/*
-	 * Handle eth devices.
-	 */
-        if ( (memcmp(dev->name, "eth", 3) == 0) ) {
-		if (ifname_num->next_eth != -1) {
-			/*
-			 * Assign it the next available eth interface number. 
-			 */
-			memset(dev->name, 0, strlen(dev->name));
-			sprintf(dev->name, "eth%d", (int)ifname_num->next_eth);
-			ifname_num->next_eth++;
-		} 
-
-                return;
-        }
-
-	/*
-	 * Handle fddi devices.
-	 */
-	if ( (memcmp(dev->name, "fddi", 4) == 0) ) {
-		if (ifname_num->next_fddi != -1) {
-			/*
-			 * Assign it the next available fddi interface number.
-			 */
-			memset(dev->name, 0, strlen(dev->name));
-			sprintf(dev->name, "fddi%d", (int)ifname_num->next_fddi);
-			ifname_num->next_fddi++;
-		}
-
-		return;
-	}
-
-	/*
-	 * Handle hip devices.
-	 */
-	if ( (memcmp(dev->name, "hip", 3) == 0) ) {
-		if (ifname_num->next_hip != -1) {
-			/*
-			 * Assign it the next available hip interface number.
-			 */
-			memset(dev->name, 0, strlen(dev->name));
-			sprintf(dev->name, "hip%d", (int)ifname_num->next_hip);
-			ifname_num->next_hip++;
-		}
-
-		return;
-	}
-
-	/*
-	 * Handle tr devices.
-	 */
-	if ( (memcmp(dev->name, "tr", 2) == 0) ) {
-		if (ifname_num->next_tr != -1) {
-			/*
-			 * Assign it the next available tr interface number.
-			 */
-			memset(dev->name, 0, strlen(dev->name));
-			sprintf(dev->name, "tr%d", (int)ifname_num->next_tr);
-			ifname_num->next_tr++;
-		}
-
-		return;
-	}
-
-	/*
-	 * Handle fc devices.
-	 */
-	if ( (memcmp(dev->name, "fc", 2) == 0) ) {
-		if (ifname_num->next_fc != -1) {
-			/*
-			 * Assign it the next available fc interface number.
-			 */
-			memset(dev->name, 0, strlen(dev->name));
-			sprintf(dev->name, "fc%d", (int)ifname_num->next_fc);
-			ifname_num->next_fc++;
-		}
-
-		return;
-	}
-}
-
-/*
- * find_persistent_ifname: Returns the entry that was seen in previous boot.
- */
-struct ifname_MAC *
-find_persistent_ifname(struct net_device *dev,
-	struct ifname_MAC *ifname_MAC)
-
-{
-
-	while (ifname_MAC->addr_len) {
-		if (memcmp(dev->dev_addr, ifname_MAC->dev_addr, dev->addr_len) == 0)
-			return(ifname_MAC);
-
-		ifname_MAC++;
-	}
-
-	return(NULL);
-}
-
-/*
- * ifconfig_net_ioctl: ifconfig_net driver ioctl interface.
- */
-static int ifconfig_net_ioctl(struct inode * inode, struct file * file,
-        unsigned int cmd, unsigned long arg)
-{
-
-	extern struct net_device *__dev_get_by_name(const char *);
-#ifdef CONFIG_NET
-	struct net_device *dev;
-	struct ifname_MAC *found;
-	char temp[64];
-#endif
-	struct ifname_MAC *ifname_MAC;
-	struct ifname_MAC *new_devices, *temp_new_devices;
-	struct ifname_num *ifname_num;
-	unsigned long size;
-
-
-	if (ifconfig_net_debug) {
-		printk("HCL: hcl_ioctl called.\n");
-	}
-
-	/*
-	 * Read in the header and see how big of a buffer we really need to 
-	 * allocate.
-	 */
-	ifname_num = (struct ifname_num *) kmalloc(sizeof(struct ifname_num), 
-			GFP_KERNEL);
-	copy_from_user( ifname_num, (char *) arg, sizeof(struct ifname_num));
-	size = ifname_num->size;
-	kfree(ifname_num);
-	ifname_num = (struct ifname_num *) kmalloc(size, GFP_KERNEL);
-	ifname_MAC = (struct ifname_MAC *) ((char *)ifname_num + (sizeof(struct ifname_num)) );
-
-	copy_from_user( ifname_num, (char *) arg, size);
-	new_devices =  kmalloc(size - sizeof(struct ifname_num), GFP_KERNEL);
-	temp_new_devices = new_devices;
-
-	memset(new_devices, 0, size - sizeof(struct ifname_num));
-
-#ifdef CONFIG_NET
-	/*
-	 * Go through the net device entries and make them persistent!
-	 */
-	for (dev = dev_base; dev != NULL; dev = dev->next) {
-		/*
-		 * Skip NULL entries or "lo"
-		 */
-		if ( (dev->addr_len == 0) || ( !strncmp(dev->name, "lo", strlen(dev->name))) ){
-			continue;
-		}
-
-		/*
-		 * See if we have a persistent interface name for this device.
-		 */
-		found = NULL;
-		found = find_persistent_ifname(dev, ifname_MAC);
-		if (found) {
-			strcpy(dev->name, found->name);
-		} else {
-			/* Never seen this before .. */
-			assign_ifname(dev, ifname_num);
-
-			/* 
-			 * Save the information for the next boot.
-			 */
- 			sprintf(temp,"%s %02x:%02x:%02x:%02x:%02x:%02x\n", dev->name,
-				dev->dev_addr[0],  dev->dev_addr[1],  dev->dev_addr[2],
-				dev->dev_addr[3],  dev->dev_addr[4],  dev->dev_addr[5]);
-			strcpy(temp_new_devices->name, dev->name);
-			temp_new_devices->addr_len = dev->addr_len;
-			memcpy(temp_new_devices->dev_addr, dev->dev_addr, dev->addr_len);
-			temp_new_devices++;
-		}
-		
-	}
-#endif
-
-	/*
-	 * Copy back to the User Buffer area any new devices encountered.
-	 */
-	copy_to_user((char *)arg + (sizeof(struct ifname_num)), new_devices, 
-			size - sizeof(struct ifname_num));
-
-	return(0);
-
-}
-
-struct file_operations ifconfig_net_fops = {
-	ioctl:ifconfig_net_ioctl,	/* ioctl */
-	open:ifconfig_net_open,		/* open */
-	release:ifconfig_net_close	/* release */
-};
-
-
-/*
- * init_ifconfig_net() - Boot time initialization.  Ensure that it is called 
- *	after devfs has been initialized.
- *
- */
-#ifdef MODULE
-int init_module (void)
-#else
-int __init init_ifconfig_net(void)
-#endif
-{
-	ifconfig_net_handle = NULL;
-	ifconfig_net_handle = hwgraph_register(hwgraph_root, ".ifconfig_net",
- 		        0, 0,
-			0, 0,
-			S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP, 0, 0,
-			&ifconfig_net_fops, NULL);
-
-	if (ifconfig_net_handle == NULL) {
-		panic("Unable to create SGI PERSISTENT NETWORK DEVICE Name Driver.\n");
-	}
-
-	return(0);
-
-}
diff -Nru a/arch/ia64/sn/io/hwgfs/hcl.c b/arch/ia64/sn/io/hwgfs/hcl.c
--- a/arch/ia64/sn/io/hwgfs/hcl.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/io/hwgfs/hcl.c	Fri Jun 27 22:41:17 2003
@@ -113,22 +113,10 @@
 }
 
 struct file_operations hcl_fops = {
-	(struct module *)0,
-	NULL,		/* lseek - default */
-	NULL,		/* read - general block-dev read */
-	NULL,		/* write - general block-dev write */
-	NULL,		/* readdir - bad */
-	NULL,		/* poll */
-	hcl_ioctl,      /* ioctl */
-	NULL,		/* mmap */
-	hcl_open,	/* open */
-	NULL,		/* flush */
-	hcl_close,	/* release */
-	NULL,		/* fsync */
-	NULL,		/* fasync */
-	NULL,		/* lock */
-	NULL,		/* readv */
-	NULL,		/* writev */
+	.owner = (struct module *)0,
+	.ioctl = hcl_ioctl,
+	.open = hcl_open,
+	.release = hcl_close,
 };
 
 
@@ -140,7 +128,6 @@
 {
 	extern void string_table_init(struct string_table *);
 	extern struct string_table label_string_table;
-	extern int init_ifconfig_net(void);
 	extern int init_ioconfig_bus(void);
 	extern int init_hwgfs_fs(void);
 	int rv = 0;
@@ -195,7 +182,6 @@
 	 * Initialize the ifconfgi_net driver that does network devices 
 	 * Persistent Naming.
 	 */
-	init_ifconfig_net();
 	init_ioconfig_bus();
 
 	return(0);
@@ -258,6 +244,7 @@
 
 	if (!de) {
 		printk(KERN_WARNING "HCL: hwgraph_fastinfo_get handle given is NULL.\n");
+		dump_stack();
 		return(-1);
 	}
 
@@ -568,7 +555,7 @@
 	 * In this case the vertex was previous created with a REAL pathname.
 	 */
 	rv = hwgfs_mk_symlink (from, (const char *)name,
-			       DEVFS_FL_DEFAULT, link,
+			       0, link,
 			       &handle, NULL);
 	kfree(path);
 	kfree(link);
diff -Nru a/arch/ia64/sn/io/machvec/pci.c b/arch/ia64/sn/io/machvec/pci.c
--- a/arch/ia64/sn/io/machvec/pci.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/io/machvec/pci.c	Fri Jun 27 22:41:17 2003
@@ -49,6 +49,8 @@
 	vertex_hdl_t device_vertex;
 
 	device_vertex = devfn_to_vertex(bus->number, devfn);
+	if (!device_vertex)
+		return PCIBIOS_DEVICE_NOT_FOUND;
 	res = pciio_config_get(device_vertex, (unsigned) where, size);
 	*val = (unsigned int) res;
 	return PCIBIOS_SUCCESSFUL;
@@ -59,6 +61,8 @@
 	vertex_hdl_t device_vertex;
 
 	device_vertex = devfn_to_vertex(bus->number, devfn);
+	if (!device_vertex)
+		return PCIBIOS_DEVICE_NOT_FOUND;
 	pciio_config_set( device_vertex, (unsigned)where, size, (uint64_t) val);
 	return PCIBIOS_SUCCESSFUL;
 }
diff -Nru a/arch/ia64/sn/io/machvec/pci_dma.c b/arch/ia64/sn/io/machvec/pci_dma.c
--- a/arch/ia64/sn/io/machvec/pci_dma.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/io/machvec/pci_dma.c	Fri Jun 27 22:41:17 2003
@@ -280,7 +280,7 @@
 	 */
 	for (i = 0; i < nents; i++, sg++) {
 		phys_addr = __pa(sg->dma_address ? sg->dma_address :
-			page_address(sg->page) + sg->offset);
+			(unsigned long)page_address(sg->page) + sg->offset);
 
 		/*
 		 * Handle the most common case: 64 bit cards.  This
@@ -578,7 +578,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	return pci_dma_supported(to_pci_dev(dev), mask);
+	return sn_pci_dma_supported(to_pci_dev(dev), mask);
 }
 EXPORT_SYMBOL(sn_dma_supported);
 
@@ -587,7 +587,11 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	return pci_set_dma_mask(to_pci_dev(dev), dma_mask);
+	if (!sn_dma_supported(dev, dma_mask))
+		return 0;
+
+	dev->dma_mask = dma_mask;
+	return 1;
 }
 EXPORT_SYMBOL(sn_dma_set_mask);
 
@@ -597,7 +601,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	return pci_alloc_consistent(to_pci_dev(dev), size, dma_handle);
+	return sn_pci_alloc_consistent(to_pci_dev(dev), size, dma_handle);
 }
 EXPORT_SYMBOL(sn_dma_alloc_coherent);
 
@@ -607,7 +611,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	pci_free_consistent(to_pci_dev(dev), size, cpu_addr, dma_handle);
+	sn_pci_free_consistent(to_pci_dev(dev), size, cpu_addr, dma_handle);
 }
 EXPORT_SYMBOL(sn_dma_free_coherent);
 
@@ -617,7 +621,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	return pci_map_single(to_pci_dev(dev), cpu_addr, size, (int)direction);
+	return sn_pci_map_single(to_pci_dev(dev), cpu_addr, size, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_map_single);
 
@@ -627,7 +631,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	pci_unmap_single(to_pci_dev(dev), dma_addr, size, (int)direction);
+	sn_pci_unmap_single(to_pci_dev(dev), dma_addr, size, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_unmap_single);
 
@@ -658,7 +662,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	return pci_map_sg(to_pci_dev(dev), sg, nents, (int)direction);
+	return sn_pci_map_sg(to_pci_dev(dev), sg, nents, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_map_sg);
 
@@ -668,7 +672,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	pci_unmap_sg(to_pci_dev(dev), sg, nhwentries, (int)direction);
+	sn_pci_unmap_sg(to_pci_dev(dev), sg, nhwentries, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_unmap_sg);
 
@@ -678,7 +682,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	pci_dma_sync_single(to_pci_dev(dev), dma_handle, size, (int)direction);
+	sn_pci_dma_sync_single(to_pci_dev(dev), dma_handle, size, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_sync_single);
 
@@ -688,7 +692,7 @@
 {
 	BUG_ON(dev->bus != &pci_bus_type);
 
-	pci_dma_sync_sg(to_pci_dev(dev), sg, nelems, (int)direction);
+	sn_pci_dma_sync_sg(to_pci_dev(dev), sg, nelems, (int)direction);
 }
 EXPORT_SYMBOL(sn_dma_sync_sg);
 
diff -Nru a/arch/ia64/sn/kernel/Makefile b/arch/ia64/sn/kernel/Makefile
--- a/arch/ia64/sn/kernel/Makefile	Fri Jun 27 22:41:16 2003
+++ b/arch/ia64/sn/kernel/Makefile	Fri Jun 27 22:41:16 2003
@@ -9,7 +9,8 @@
 
 EXTRA_CFLAGS := -DLITTLE_ENDIAN
 
-obj-y				:= probe.o setup.o sv.o bte.o irq.o mca.o sn2/
+obj-y				:= probe.o setup.o sv.o bte.o irq.o mca.o \
+				   idle.o sn2/
 
 obj-$(CONFIG_IA64_GENERIC)      += machvec.o
 obj-$(CONFIG_MODULES)           += sn_ksyms.o
diff -Nru a/arch/ia64/sn/kernel/idle.c b/arch/ia64/sn/kernel/idle.c
--- a/arch/ia64/sn/kernel/idle.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/kernel/idle.c	Fri Jun 27 22:41:17 2003
@@ -12,7 +12,7 @@
 
 void snidle(int state) {
 	if (state) {
-		if (pda.idle_flag == 0) {
+		if (pda->idle_flag == 0) {
 			/* 
 			 * Turn the activity LED off.
 			 */
@@ -24,13 +24,13 @@
 			SIMULATOR_SLEEP();
 #endif
 
-		pda.idle_flag = 1;
+		pda->idle_flag = 1;
 	} else {
 		/* 
 		 * Turn the activity LED on.
 		 */
 		set_led_bits(LED_CPU_ACTIVITY, LED_CPU_ACTIVITY);
 
-		pda.idle_flag = 0;
+		pda->idle_flag = 0;
 	}
 }
diff -Nru a/arch/ia64/sn/kernel/machvec.c b/arch/ia64/sn/kernel/machvec.c
--- a/arch/ia64/sn/kernel/machvec.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/kernel/machvec.c	Fri Jun 27 22:41:17 2003
@@ -31,4 +31,5 @@
  */
 
 #define MACHVEC_PLATFORM_NAME	sn2
+#define MACHVEC_PLATFORM_HEADER	<asm/machvec_sn2.h>
 #include <asm/machvec_init.h>
diff -Nru a/arch/ia64/sn/kernel/setup.c b/arch/ia64/sn/kernel/setup.c
--- a/arch/ia64/sn/kernel/setup.c	Fri Jun 27 22:41:17 2003
+++ b/arch/ia64/sn/kernel/setup.c	Fri Jun 27 22:41:17 2003
@@ -75,11 +75,13 @@
 
 #define pxm_to_nasid(pxm) ((pxm)<<1)
 
+#define MAX_PHYS_MEMORY		(1UL << 49)     /* 1 TB */
+
 extern void bte_init_node (nodepda_t *, cnodeid_t);
 extern void bte_init_cpu (void);
-extern void sn_timer_init (void);
+extern void sn_timer_init(void);
 extern void (*ia64_mark_idle)(int);
-void snidle(int);
+extern void snidle(int);
 
 unsigned long sn_rtc_cycles_per_second;   
 
@@ -296,21 +298,20 @@
 	 */
 	sn_check_for_wars();
 
+	ia64_mark_idle = &snidle;
+
 	/* 
 	 * For the bootcpu, we do this here. All other cpus will make the
 	 * call as part of cpu_init in slave cpu initialization.
 	 */
 	sn_cpu_init();
 
-
 #ifdef CONFIG_SMP
 	init_smp_config();
 #endif
 	screen_info = sn_screen_info;
 
 	sn_timer_init();
-
-	ia64_mark_idle = &snidle;
 }
 
 /**
@@ -437,20 +438,4 @@
 	}
 
 	bte_init_cpu();
-}
-
-void snidle(int idleness)
-{
-	if (!idleness) {
-		if (pda->idle_flag == 0) {
-			set_led_bits(0, LED_CPU_ACTIVITY);
-		}
-
-		pda->idle_flag = 1;
-	}
-	else {
-		set_led_bits(LED_CPU_ACTIVITY, LED_CPU_ACTIVITY);
-
-		pda->idle_flag = 0;
-	}
 }
diff -Nru a/arch/sparc/kernel/process.c b/arch/sparc/kernel/process.c
--- a/arch/sparc/kernel/process.c	Fri Jun 27 22:41:16 2003
+++ b/arch/sparc/kernel/process.c	Fri Jun 27 22:41:16 2003
@@ -287,17 +287,14 @@
 	       rw->ins[4], rw->ins[5], rw->ins[6], rw->ins[7]);
 }
 
-void show_trace_task(struct task_struct *tsk)
+void show_stack(struct task_struct *tsk, unsigned long *_ksp)
 {
 	unsigned long pc, fp;
 	unsigned long task_base = (unsigned long) tsk;
 	struct reg_window *rw;
 	int count = 0;
 
-	if (!tsk)
-		return;
-
-	fp = tsk->thread_info->ksp;
+	fp = (unsigned long) _ksp;
 	do {
 		/* Bogus frame pointer? */
 		if (fp < (task_base + sizeof(struct task_struct)) ||
@@ -309,6 +306,13 @@
 		fp = rw->ins[6];
 	} while (++count < 16);
 	printk("\n");
+}
+
+void show_trace_task(struct task_struct *tsk)
+{
+	if (tsk)
+		show_stack(tsk,
+			   (unsigned long *) tsk->thread_info->ksp);
 }
 
 /*
diff -Nru a/arch/sparc/kernel/systbls.S b/arch/sparc/kernel/systbls.S
--- a/arch/sparc/kernel/systbls.S	Fri Jun 27 22:41:17 2003
+++ b/arch/sparc/kernel/systbls.S	Fri Jun 27 22:41:17 2003
@@ -64,9 +64,9 @@
 /*215*/	.long sys_ipc, sys_sigreturn, sys_clone, sys_nis_syscall, sys_adjtimex
 /*220*/	.long sys_sigprocmask, sys_ni_syscall, sys_delete_module, sys_ni_syscall, sys_getpgid
 /*225*/	.long sys_bdflush, sys_sysfs, sys_nis_syscall, sys_setfsuid16, sys_setfsgid16
-/*230*/	.long sys_select, sys_time, sys_nis_syscall, sys_stime, sys_nis_syscall
+/*230*/	.long sys_select, sys_time, sys_nis_syscall, sys_stime, sys_statfs64
 					  /* "We are the Knights of the Forest of Ni!!" */
-/*235*/	.long sys_nis_syscall, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+/*235*/	.long sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
 /*240*/	.long sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 /*245*/	.long sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
diff -Nru a/arch/sparc64/kernel/systbls.S b/arch/sparc64/kernel/systbls.S
--- a/arch/sparc64/kernel/systbls.S	Fri Jun 27 22:41:17 2003
+++ b/arch/sparc64/kernel/systbls.S	Fri Jun 27 22:41:17 2003
@@ -65,8 +65,8 @@
 	.word sys32_ipc, sys32_sigreturn, sys_clone, sys_nis_syscall, sys32_adjtimex
 /*220*/	.word compat_sys_sigprocmask, sys_ni_syscall, sys32_delete_module, sys_ni_syscall, sys_getpgid
 	.word sys32_bdflush, sys32_sysfs, sys_nis_syscall, sys32_setfsuid16, sys32_setfsgid16
-/*230*/	.word sys32_select, sys_time, sys_nis_syscall, sys_stime, sys_ni_syscall
-	.word sys_ni_syscall, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+/*230*/	.word sys32_select, sys_time, sys_nis_syscall, sys_stime, sys_statfs64
+	.word sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys32_sched_rr_get_interval, compat_sys_nanosleep
 /*250*/	.word sys32_mremap, sys32_sysctl, sys_getsid, sys_fdatasync, sys32_nfsservctl
@@ -124,11 +124,8 @@
 	.word sys_ipc, sys_nis_syscall, sys_clone, sys_nis_syscall, sys_adjtimex
 /*220*/	.word sys_nis_syscall, sys_ni_syscall, sys_delete_module, sys_ni_syscall, sys_getpgid
 	.word sys_bdflush, sys_sysfs, sys_nis_syscall, sys_setfsuid, sys_setfsgid
-
-	/* 234 and 235 were for the hugetlb syscalls.  They can be reused */
-
-/*230*/	.word sys_select, sys_nis_syscall, sys_nis_syscall, sys_stime, sys_nis_syscall
-	.word sys_nis_syscall, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
+/*230*/	.word sys_select, sys_nis_syscall, sys_nis_syscall, sys_stime, sys_statfs64
+	.word sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall
 /*240*/	.word sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler
 	.word sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep
 /*250*/	.word sys64_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl
diff -Nru a/arch/sparc64/kernel/traps.c b/arch/sparc64/kernel/traps.c
--- a/arch/sparc64/kernel/traps.c	Fri Jun 27 22:41:17 2003
+++ b/arch/sparc64/kernel/traps.c	Fri Jun 27 22:41:17 2003
@@ -1569,12 +1569,15 @@
 	printk("\n");
 }
 
-void show_trace_raw(struct thread_info *tp, unsigned long ksp)
+void show_stack(struct task_struct *tsk, unsigned long *_ksp)
 {
-	unsigned long pc, fp, thread_base;
+	unsigned long pc, fp, thread_base, ksp;
+	struct thread_info *tp = tsk->thread_info;
 	struct reg_window *rw;
 	int count = 0;
 
+	ksp = (unsigned long) _ksp;
+
 	if (tp == current_thread_info())
 		flushw_all();
 
@@ -1596,17 +1599,17 @@
 void show_trace_task(struct task_struct *tsk)
 {
 	if (tsk)
-		show_trace_raw(tsk->thread_info,
-			       tsk->thread_info->ksp);
+		show_stack(tsk,
+			   (unsigned long *) tsk->thread_info->ksp);
 }
 
 void dump_stack(void)
 {
-	unsigned long ksp;
+	unsigned long *ksp;
 
 	__asm__ __volatile__("mov	%%fp, %0"
 			     : "=r" (ksp));
-	show_trace_raw(current_thread_info(), ksp);
+	show_stack(current, ksp);
 }
 
 void die_if_kernel(char *str, struct pt_regs *regs)
diff -Nru a/arch/sparc64/mm/fault.c b/arch/sparc64/mm/fault.c
--- a/arch/sparc64/mm/fault.c	Fri Jun 27 22:41:17 2003
+++ b/arch/sparc64/mm/fault.c	Fri Jun 27 22:41:17 2003
@@ -149,16 +149,14 @@
 	die_if_kernel("Oops", regs);
 }
 
-extern void show_trace_raw(struct thread_info *, unsigned long);
-
 static void bad_kernel_pc(struct pt_regs *regs)
 {
-	unsigned long ksp;
+	unsigned long *ksp;
 
 	printk(KERN_CRIT "OOPS: Bogus kernel PC [%016lx] in fault handler\n",
 	       regs->tpc);
 	__asm__("mov %%sp, %0" : "=r" (ksp));
-	show_trace_raw(current_thread_info(), ksp);
+	show_stack(current, ksp);
 	unhandled_fault(regs->tpc, current, regs);
 }
 
diff -Nru a/arch/sparc64/solaris/fs.c b/arch/sparc64/solaris/fs.c
--- a/arch/sparc64/solaris/fs.c	Fri Jun 27 22:41:17 2003
+++ b/arch/sparc64/solaris/fs.c	Fri Jun 27 22:41:17 2003
@@ -390,7 +390,7 @@
 
 static int report_statvfs(struct vfsmount *mnt, struct inode *inode, u32 buf)
 {
-	struct statfs s;
+	struct kstatfs s;
 	int error;
 	struct sol_statvfs *ss = (struct sol_statvfs *)A(buf);
 
@@ -424,7 +424,7 @@
 
 static int report_statvfs64(struct vfsmount *mnt, struct inode *inode, u32 buf)
 {
-	struct statfs s;
+	struct kstatfs s;
 	int error;
 	struct sol_statvfs64 *ss = (struct sol_statvfs64 *)A(buf);
 			
diff -Nru a/drivers/acpi/osl.c b/drivers/acpi/osl.c
--- a/drivers/acpi/osl.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/acpi/osl.c	Fri Jun 27 22:41:17 2003
@@ -250,7 +250,14 @@
 	irq = acpi_fadt.sci_int;
 
 #ifdef CONFIG_IA64
-	irq = gsi_to_vector(irq);
+	int vector;
+
+	vector = acpi_irq_to_vector(irq);
+	if (vector < 0) {
+		printk(KERN_ERR PREFIX "SCI (IRQ%d) not registerd\n", irq);
+		return AE_OK;
+	}
+	irq = vector;
 #endif
 	acpi_irq_irq = irq;
 	acpi_irq_handler = handler;
@@ -268,7 +275,7 @@
 {
 	if (acpi_irq_handler) {
 #ifdef CONFIG_IA64
-		irq = gsi_to_vector(irq);
+		irq = acpi_irq_to_vector(irq);
 #endif
 		free_irq(irq, acpi_irq);
 		acpi_irq_handler = NULL;
@@ -934,7 +941,7 @@
 
 /* Assumes no unreadable holes inbetween */
 BOOLEAN
-acpi_os_readable(void *ptr, u32 len)
+acpi_os_readable(void *ptr, acpi_size len)
 {
 #if defined(__i386__) || defined(__x86_64__) 
 	char tmp;
@@ -944,7 +951,7 @@
 }
 
 BOOLEAN
-acpi_os_writable(void *ptr, u32 len)
+acpi_os_writable(void *ptr, acpi_size len)
 {
 	/* could do dummy write (racy) or a kernel page table lookup.
 	   The later may be difficult at early boot when kmap doesn't work yet. */
diff -Nru a/drivers/acpi/pci_irq.c b/drivers/acpi/pci_irq.c
--- a/drivers/acpi/pci_irq.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/acpi/pci_irq.c	Fri Jun 27 22:41:17 2003
@@ -24,6 +24,8 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
+#include <linux/config.h>
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -36,9 +38,16 @@
 #ifdef CONFIG_X86_IO_APIC
 #include <asm/mpspec.h>
 #endif
+#ifdef CONFIG_IOSAPIC
+# include <asm/iosapic.h>
+#endif
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
 
+#ifdef CONFIG_X86
+# define PCI_SEGMENT(x)	0	/* XXX fix me */
+#endif
+
 
 #define _COMPONENT		ACPI_PCI_COMPONENT
 ACPI_MODULE_NAME		("pci_irq")
@@ -248,6 +257,8 @@
 		return_VALUE(0);
 	}
 
+	entry->irq = entry->link.index;
+
 	if (!entry->irq && entry->link.handle) {
 		entry->irq = acpi_pci_link_get_irq(entry->link.handle, entry->link.index);
 		if (!entry->irq) {
@@ -356,7 +367,11 @@
 		}
  	}
 
+#ifdef CONFIG_IA64
+	dev->irq = gsi_to_irq(irq);
+#else
 	dev->irq = irq;
+#endif
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device %s using IRQ %d\n", dev->slot_name, dev->irq));
 
@@ -369,6 +384,10 @@
 		irq_mask |= (1 << dev->irq);
 		eisa_set_level_irq(dev->irq);
 	}
+#endif
+#ifdef CONFIG_IOSAPIC
+	if (acpi_irq_model == ACPI_IRQ_MODEL_IOSAPIC)
+		iosapic_enable_intr(dev->irq);
 #endif
 
 	return_VALUE(dev->irq);
diff -Nru a/drivers/acpi/pci_root.c b/drivers/acpi/pci_root.c
--- a/drivers/acpi/pci_root.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/acpi/pci_root.c	Fri Jun 27 22:41:17 2003
@@ -23,6 +23,8 @@
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  */
 
+#include <linux/config.h>
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -246,8 +248,6 @@
 	switch (status) {
 	case AE_OK:
 		root->id.segment = (u16) value;
-		printk("_SEG exists! Unsupported. Abort.\n");
-		BUG();
 		break;
 	case AE_NOT_FOUND:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, 
@@ -309,7 +309,12 @@
 	 * PCI namespace does not get created until this call is made (and 
 	 * thus the root bridge's pci_dev does not exist).
 	 */
+#ifdef CONFIG_X86
 	root->bus = pcibios_scan_root(root->id.bus);
+#else
+	root->bus = pcibios_scan_root(root->handle,
+	                              root->id.segment, root->id.bus);
+#endif
 	if (!root->bus) {
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, 
 			"Bus %02x:%02x not present in PCI namespace\n", 
diff -Nru a/drivers/block/loop.c b/drivers/block/loop.c
--- a/drivers/block/loop.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/block/loop.c	Fri Jun 27 22:41:17 2003
@@ -2,7 +2,7 @@
  *  linux/drivers/block/loop.c
  *
  *  Written by Theodore Ts'o, 3/29/93
- * 
+ *
  * Copyright 1993 by Theodore Ts'o.  Redistribution of this file is
  * permitted under the GNU General Public License.
  *
@@ -21,12 +21,12 @@
  * Loadable modules and other fixes by AK, 1998
  *
  * Make real block number available to downstream transfer functions, enables
- * CBC (and relatives) mode encryption requiring unique IVs per data block. 
+ * CBC (and relatives) mode encryption requiring unique IVs per data block.
  * Reed H. Petty, rhp@draper.net
  *
  * Maximum number of loop devices now dynamic via max_loop module parameter.
  * Russell Kroll <rkroll@exploits.org> 19990701
- * 
+ *
  * Maximum number of loop devices when compiled-in now selectable by passing
  * max_loop=<1-255> to the kernel on boot.
  * Erik I. Bols, <eriki@himolde.no>, Oct 31, 1999
@@ -40,19 +40,19 @@
  * Heinz Mauelshagen <mge@sistina.com>, Feb 2002
  *
  * Still To Fix:
- * - Advisory locking is ignored here. 
- * - Should use an own CAP_* category instead of CAP_SYS_ADMIN 
+ * - Advisory locking is ignored here.
+ * - Should use an own CAP_* category instead of CAP_SYS_ADMIN
  *
  * WARNING/FIXME:
  * - The block number as IV passing to low level transfer functions is broken:
  *   it passes the underlying device's block number instead of the
- *   offset. This makes it change for a given block when the file is 
- *   moved/restored/copied and also doesn't work over NFS. 
+ *   offset. This makes it change for a given block when the file is
+ *   moved/restored/copied and also doesn't work over NFS.
  * AV, Feb 12, 2000: we pass the logical block number now. It fixes the
  *   problem above. Encryption modules that used to rely on the old scheme
  *   should just call ->i_mapping->bmap() to calculate the physical block
  *   number.
- */ 
+ */
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -60,12 +60,10 @@
 #include <linux/sched.h>
 #include <linux/fs.h>
 #include <linux/file.h>
-#include <linux/bio.h>
 #include <linux/stat.h>
 #include <linux/errno.h>
 #include <linux/major.h>
 #include <linux/wait.h>
-#include <linux/blk.h>
 #include <linux/blkpg.h>
 #include <linux/init.h>
 #include <linux/devfs_fs_kernel.h>
@@ -127,24 +125,25 @@
 	return 0;
 }
 
-struct loop_func_table none_funcs = { 
+struct loop_func_table none_funcs = {
 	.number = LO_CRYPT_NONE,
 	.transfer = transfer_none,
 }; 	
 
-struct loop_func_table xor_funcs = { 
+struct loop_func_table xor_funcs = {
 	.number = LO_CRYPT_XOR,
 	.transfer = transfer_xor,
 	.init = xor_status
 }; 	
 
-/* xfer_funcs[0] is special - its release function is never called */ 
+/* xfer_funcs[0] is special - its release function is never called */
 struct loop_func_table *xfer_funcs[MAX_LO_CRYPT] = {
 	&none_funcs,
-	&xor_funcs  
+	&xor_funcs
 };
 
-static int figure_loop_size(struct loop_device *lo)
+static int
+figure_loop_size(struct loop_device *lo)
 {
 	loff_t size = lo->lo_backing_file->f_dentry->d_inode->i_mapping->host->i_size;
 	sector_t x;
@@ -154,15 +153,17 @@
 	 */
 	size = (size - lo->lo_offset) >> 9;
 	x = (sector_t)size;
+
 	if ((loff_t)x != size)
 		return -EFBIG;
 
-	set_capacity(disks[lo->lo_number], size);
+	set_capacity(disks[lo->lo_number], x);
 	return 0;					
 }
 
-static inline int lo_do_transfer(struct loop_device *lo, int cmd, char *rbuf,
-				 char *lbuf, int size, sector_t rblock)
+static inline int
+lo_do_transfer(struct loop_device *lo, int cmd, char *rbuf,
+	       char *lbuf, int size, sector_t rblock)
 {
 	if (!lo->transfer)
 		return 0;
@@ -614,9 +615,12 @@
 
 	daemonize("loop%d", lo->lo_number);
 
-	current->flags |= PF_IOTHREAD;	/* loop can be used in an encrypted device
-					   hence, it mustn't be stopped at all because it could
-					   be indirectly used during suspension */
+	/*
+	 * loop can be used in an encrypted device,
+	 * hence, it mustn't be stopped at all
+	 * because it could be indirectly used during suspension
+	 */
+	current->flags |= PF_IOTHREAD;
 
 	set_user_nice(current, -20);
 
@@ -771,36 +775,42 @@
 	return error;
 }
 
-static int loop_release_xfer(struct loop_device *lo)
+static int
+loop_release_xfer(struct loop_device *lo)
 {
-	int err = 0; 
-	if (lo->lo_encrypt_type) {
-		struct loop_func_table *xfer= xfer_funcs[lo->lo_encrypt_type]; 
-		if (xfer && xfer->release)
-			err = xfer->release(lo); 
-		if (xfer && xfer->unlock)
-			xfer->unlock(lo); 
-		lo->lo_encrypt_type = 0;
+	int err = 0;
+	struct loop_func_table *xfer = lo->lo_encryption;
+
+	if (xfer) {
+		if (xfer->release)
+			err = xfer->release(lo);
+		lo->transfer = NULL;
+		lo->lo_encryption = NULL;
+		module_put(xfer->owner);
 	}
 	return err;
 }
 
 static int
-loop_init_xfer(struct loop_device *lo, int type, const struct loop_info64 *i)
+loop_init_xfer(struct loop_device *lo, struct loop_func_table *xfer,
+	       const struct loop_info64 *i)
 {
-	int err = 0; 
-	if (type) {
-		struct loop_func_table *xfer = xfer_funcs[type]; 
+	int err = 0;
+
+	if (xfer) {
+		struct module *owner = xfer->owner;
+
+		if (!try_module_get(owner))
+			return -EINVAL;
 		if (xfer->init)
 			err = xfer->init(lo, i);
-		if (!err) { 
-			lo->lo_encrypt_type = type;
-			if (xfer->lock)
-				xfer->lock(lo);
-		}
+		if (err)
+			module_put(owner);
+		else
+			lo->lo_encryption = xfer;
 	}
 	return err;
-}  
+}
 
 static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
 {
@@ -809,9 +819,11 @@
 
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
+
 	if (lo->lo_refcnt > 1)	/* we needed one fd for the ioctl */
 		return -EBUSY;
-	if (filp==NULL)
+
+	if (filp == NULL)
 		return -EINVAL;
 
 	spin_lock_irq(&lo->lo_lock);
@@ -828,7 +840,7 @@
 	lo->transfer = NULL;
 	lo->ioctl = NULL;
 	lo->lo_device = NULL;
-	lo->lo_encrypt_type = 0;
+	lo->lo_encryption = NULL;
 	lo->lo_offset = 0;
 	lo->lo_encrypt_key_size = 0;
 	lo->lo_flags = 0;
@@ -849,49 +861,55 @@
 loop_set_status(struct loop_device *lo, const struct loop_info64 *info)
 {
 	int err;
-	unsigned int type;
-	loff_t offset;
+	struct loop_func_table *xfer;
 
-	if (lo->lo_encrypt_key_size && lo->lo_key_owner != current->uid && 
+	if (lo->lo_encrypt_key_size && lo->lo_key_owner != current->uid &&
 	    !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
 	if ((unsigned int) info->lo_encrypt_key_size > LO_KEY_SIZE)
 		return -EINVAL;
-	type = info->lo_encrypt_type; 
-	if (type >= MAX_LO_CRYPT || xfer_funcs[type] == NULL)
-		return -EINVAL;
-	if (type == LO_CRYPT_XOR && info->lo_encrypt_key_size == 0)
-		return -EINVAL;
 
 	err = loop_release_xfer(lo);
-	if (!err) 
-		err = loop_init_xfer(lo, type, info);
+	if (err)
+		return err;
 
-	offset = lo->lo_offset;
-	if (offset != info->lo_offset) {
-		lo->lo_offset = info->lo_offset;
-		if (figure_loop_size(lo)){
-			err = -EFBIG;
-			lo->lo_offset = offset;
-		}
-	}
+	if (info->lo_encrypt_type) {
+		unsigned int type = info->lo_encrypt_type;
+
+		if (type >= MAX_LO_CRYPT)
+			return -EINVAL;
+		xfer = xfer_funcs[type];
+		if (xfer == NULL)
+			return -EINVAL;
+	} else
+		xfer = NULL;
 
+	err = loop_init_xfer(lo, xfer, info);
 	if (err)
-		return err;	
+		return err;
+
+	if (lo->lo_offset != info->lo_offset) {
+		lo->lo_offset = info->lo_offset;
+		if (figure_loop_size(lo))
+			return -EFBIG;
+	}
 
 	strlcpy(lo->lo_name, info->lo_name, LO_NAME_SIZE);
 
-	lo->transfer = xfer_funcs[type]->transfer;
-	lo->ioctl = xfer_funcs[type]->ioctl;
+	if (!xfer)
+		xfer = &none_funcs;
+	lo->transfer = xfer->transfer;
+	lo->ioctl = xfer->ioctl;
+
 	lo->lo_encrypt_key_size = info->lo_encrypt_key_size;
 	lo->lo_init[0] = info->lo_init[0];
 	lo->lo_init[1] = info->lo_init[1];
 	if (info->lo_encrypt_key_size) {
-		memcpy(lo->lo_encrypt_key, info->lo_encrypt_key, 
+		memcpy(lo->lo_encrypt_key, info->lo_encrypt_key,
 		       info->lo_encrypt_key_size);
-		lo->lo_key_owner = current->uid; 
+		lo->lo_key_owner = current->uid;
 	}	
 
 	return 0;
@@ -917,7 +935,8 @@
 	info->lo_offset = lo->lo_offset;
 	info->lo_flags = lo->lo_flags;
 	strlcpy(info->lo_name, lo->lo_name, LO_NAME_SIZE);
-	info->lo_encrypt_type = lo->lo_encrypt_type;
+	info->lo_encrypt_type =
+		lo->lo_encryption ? lo->lo_encryption->number : 0;
 	if (lo->lo_encrypt_key_size && capable(CAP_SYS_ADMIN)) {
 		info->lo_encrypt_key_size = lo->lo_encrypt_key_size;
 		memcpy(info->lo_encrypt_key, lo->lo_encrypt_key,
@@ -1060,30 +1079,22 @@
 static int lo_open(struct inode *inode, struct file *file)
 {
 	struct loop_device *lo = inode->i_bdev->bd_disk->private_data;
-	int type;
 
 	down(&lo->lo_ctl_mutex);
-
-	type = lo->lo_encrypt_type; 
-	if (type && xfer_funcs[type] && xfer_funcs[type]->lock)
-		xfer_funcs[type]->lock(lo);
 	lo->lo_refcnt++;
 	up(&lo->lo_ctl_mutex);
+
 	return 0;
 }
 
 static int lo_release(struct inode *inode, struct file *file)
 {
 	struct loop_device *lo = inode->i_bdev->bd_disk->private_data;
-	int type;
 
 	down(&lo->lo_ctl_mutex);
-	type = lo->lo_encrypt_type;
 	--lo->lo_refcnt;
-	if (xfer_funcs[type] && xfer_funcs[type]->unlock)
-		xfer_funcs[type]->unlock(lo);
-
 	up(&lo->lo_ctl_mutex);
+
 	return 0;
 }
 
@@ -1103,34 +1114,41 @@
 
 int loop_register_transfer(struct loop_func_table *funcs)
 {
-	if ((unsigned)funcs->number > MAX_LO_CRYPT || xfer_funcs[funcs->number])
+	unsigned int n = funcs->number;
+
+	if (n >= MAX_LO_CRYPT || xfer_funcs[n])
 		return -EINVAL;
-	xfer_funcs[funcs->number] = funcs;
-	return 0; 
+	xfer_funcs[n] = funcs;
+	return 0;
 }
 
 int loop_unregister_transfer(int number)
 {
-	struct loop_device *lo; 
+	unsigned int n = number;
+	struct loop_device *lo;
+	struct loop_func_table *xfer;
 
-	if ((unsigned)number >= MAX_LO_CRYPT)
-		return -EINVAL; 
-	for (lo = &loop_dev[0]; lo < &loop_dev[max_loop]; lo++) { 
-		int type = lo->lo_encrypt_type;
-		if (type == number) { 
-			xfer_funcs[type]->release(lo);
-			lo->transfer = NULL; 
-			lo->lo_encrypt_type = 0; 
-		}
+	if (n == 0 || n >= MAX_LO_CRYPT || (xfer = xfer_funcs[n]) == NULL)
+		return -EINVAL;
+
+	xfer_funcs[n] = NULL;
+
+	for (lo = &loop_dev[0]; lo < &loop_dev[max_loop]; lo++) {
+		down(&lo->lo_ctl_mutex);
+
+		if (lo->lo_encryption == xfer)
+			loop_release_xfer(lo);
+
+		up(&lo->lo_ctl_mutex);
 	}
-	xfer_funcs[number] = NULL; 
-	return 0; 
+
+	return 0;
 }
 
 EXPORT_SYMBOL(loop_register_transfer);
 EXPORT_SYMBOL(loop_unregister_transfer);
 
-int __init loop_init(void) 
+int __init loop_init(void)
 {
 	int	i;
 
@@ -1190,9 +1208,10 @@
 	return -ENOMEM;
 }
 
-void loop_exit(void) 
+void loop_exit(void)
 {
 	int i;
+
 	for (i = 0; i < max_loop; i++) {
 		del_gendisk(disks[i]);
 		put_disk(disks[i]);
diff -Nru a/drivers/block/nbd.c b/drivers/block/nbd.c
--- a/drivers/block/nbd.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/block/nbd.c	Fri Jun 27 22:41:17 2003
@@ -28,6 +28,9 @@
  *   the transmit lock. <steve@chygwyn.com>
  * 02-10-11 Allow hung xmit to be aborted via SIGKILL & various fixes.
  *   <Paul.Clements@SteelEye.com> <James.Bottomley@SteelEye.com>
+ * 03-06-22 Make nbd work with new linux 2.5 block layer design. This fixes
+ *   memory corruption from module removal and possible memory corruption
+ *   from sending/receiving disk data. <ldl@aros.net>
  *
  * possible FIXME: make set_sock / set_blksize / set_size / do_it one syscall
  * why not: would need verify_area and friends, would share yet another 
@@ -63,6 +66,16 @@
 
 static struct nbd_device nbd_dev[MAX_NBD];
 
+/*
+ * Use just one lock (or at most 1 per NIC). Two arguments for this:
+ * 1. Each NIC is essentially a synchronization point for all servers
+ *    accessed through that NIC so there's no need to have more locks
+ *    than NICs anyway.
+ * 2. More locks lead to more "Dirty cache line bouncing" which will slow
+ *    down each lock to the point where they're actually slower than just
+ *    a single lock.
+ * Thanks go to Jens Axboe and Al Viro for their LKML emails explaining this!
+ */
 static spinlock_t nbd_lock = SPIN_LOCK_UNLOCKED;
 
 #define DEBUG( s )
@@ -168,6 +181,17 @@
 	return result;
 }
 
+static inline int sock_send_bvec(struct socket *sock, struct bio_vec *bvec,
+		int flags)
+{
+	int result;
+	void *kaddr = kmap(bvec->bv_page);
+	result = nbd_xmit(1, sock, kaddr + bvec->bv_offset, bvec->bv_len,
+			flags);
+	kunmap(bvec->bv_page);
+	return result;
+}
+
 #define FAIL( s ) { printk( KERN_ERR "NBD: " s "(result %d)\n", result ); goto error_out; }
 
 void nbd_send_req(struct nbd_device *lo, struct request *req)
@@ -209,7 +233,7 @@
 				if ((i < (bio->bi_vcnt - 1)) || bio->bi_next)
 					flags = MSG_MORE;
 				DEBUG("data, ");
-				result = nbd_xmit(1, sock, page_address(bvec->bv_page) + bvec->bv_offset, bvec->bv_len, flags);
+				result = sock_send_bvec(sock, bvec, flags);
 				if (result <= 0)
 					FAIL("Send data failed.");
 			}
@@ -244,6 +268,16 @@
 	return NULL;
 }
 
+static inline int sock_recv_bvec(struct socket *sock, struct bio_vec *bvec)
+{
+	int result;
+	void *kaddr = kmap(bvec->bv_page);
+	result = nbd_xmit(0, sock, kaddr + bvec->bv_offset, bvec->bv_len,
+			MSG_WAITALL);
+	kunmap(bvec->bv_page);
+	return result;
+}
+
 #define HARDFAIL( s ) { printk( KERN_ERR "NBD: " s "(result %d)\n", result ); lo->harderror = result; return NULL; }
 struct request *nbd_read_stat(struct nbd_device *lo)
 		/* NULL returned = something went wrong, inform userspace       */ 
@@ -251,10 +285,11 @@
 	int result;
 	struct nbd_reply reply;
 	struct request *req;
+	struct socket *sock = lo->sock;
 
 	DEBUG("reading control, ");
 	reply.magic = 0;
-	result = nbd_xmit(0, lo->sock, (char *) &reply, sizeof(reply), MSG_WAITALL);
+	result = nbd_xmit(0, sock, (char *) &reply, sizeof(reply), MSG_WAITALL);
 	if (result <= 0)
 		HARDFAIL("Recv control failed.");
 	req = nbd_find_request(lo, reply.handle);
@@ -268,14 +303,17 @@
 		FAIL("Other side returned error.");
 
 	if (nbd_cmd(req) == NBD_CMD_READ) {
-		struct bio *bio = req->bio;
+		int i;
+		struct bio *bio;
 		DEBUG("data, ");
-		do {
-			result = nbd_xmit(0, lo->sock, bio_data(bio), bio->bi_size, MSG_WAITALL);
-			if (result <= 0)
-				HARDFAIL("Recv data failed.");
-			bio = bio->bi_next;
-		} while(bio);
+		rq_for_each_bio(bio, req) {
+			struct bio_vec *bvec;
+			bio_for_each_segment(bvec, bio, i) {
+				result = sock_recv_bvec(sock, bvec);
+				if (result <= 0)
+					HARDFAIL("Recv data failed.");
+			}
+		}
 	}
 	DEBUG("done.\n");
 	return req;
@@ -538,8 +576,6 @@
  *  (Just smiley confuses emacs :-)
  */
 
-static struct request_queue nbd_queue;
-
 static int __init nbd_init(void)
 {
 	int err = -ENOMEM;
@@ -555,6 +591,17 @@
 		if (!disk)
 			goto out;
 		nbd_dev[i].disk = disk;
+		/*
+		 * The new linux 2.5 block layer implementation requires
+		 * every gendisk to have its very own request_queue struct.
+		 * These structs are big so we dynamically allocate them.
+		 */
+		disk->queue = kmalloc(sizeof(struct request_queue), GFP_KERNEL);
+		if (!disk->queue) {
+			put_disk(disk);
+			goto out;
+		}
+		blk_init_queue(disk->queue, do_nbd_request, &nbd_lock);
 	}
 
 	if (register_blkdev(NBD_MAJOR, "nbd")) {
@@ -564,7 +611,6 @@
 #ifdef MODULE
 	printk("nbd: registered device at major %d\n", NBD_MAJOR);
 #endif
-	blk_init_queue(&nbd_queue, do_nbd_request, &nbd_lock);
 	devfs_mk_dir("nbd");
 	for (i = 0; i < MAX_NBD; i++) {
 		struct gendisk *disk = nbd_dev[i].disk;
@@ -582,7 +628,6 @@
 		disk->first_minor = i;
 		disk->fops = &nbd_fops;
 		disk->private_data = &nbd_dev[i];
-		disk->queue = &nbd_queue;
 		sprintf(disk->disk_name, "nbd%d", i);
 		sprintf(disk->devfs_name, "nbd/%d", i);
 		set_capacity(disk, 0x3ffffe);
@@ -591,8 +636,10 @@
 
 	return 0;
 out:
-	while (i--)
+	while (i--) {
+		kfree(nbd_dev[i].disk->queue);
 		put_disk(nbd_dev[i].disk);
+	}
 	return err;
 }
 
@@ -600,12 +647,22 @@
 {
 	int i;
 	for (i = 0; i < MAX_NBD; i++) {
-		del_gendisk(nbd_dev[i].disk);
-		put_disk(nbd_dev[i].disk);
+		struct gendisk *disk = nbd_dev[i].disk;
+		if (disk) {
+			if (disk->queue) {
+				blk_cleanup_queue(disk->queue);
+				kfree(disk->queue);
+				disk->queue = NULL;
+			}
+			del_gendisk(disk);
+			put_disk(disk);
+		}
 	}
 	devfs_remove("nbd");
-	blk_cleanup_queue(&nbd_queue);
 	unregister_blkdev(NBD_MAJOR, "nbd");
+#ifdef MODULE
+	printk("nbd: unregistered device at major %d\n", NBD_MAJOR);
+#endif
 }
 
 module_init(nbd_init);
diff -Nru a/drivers/char/agp/hp-agp.c b/drivers/char/agp/hp-agp.c
--- a/drivers/char/agp/hp-agp.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/char/agp/hp-agp.c	Fri Jun 27 22:41:17 2003
@@ -1,17 +1,36 @@
 /*
- * HP AGPGART routines. 
+ * HP AGPGART routines.
+ *	Copyright (C) 2002-2003 Hewlett-Packard Co
+ *		Bjorn Helgaas <bjorn_helgaas@hp.com>
  */
 
+#include <linux/acpi.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/agp_backend.h>
+
+#include <asm/acpi-ext.h>
+
 #include "agp.h"
 
 #ifndef log2
 #define log2(x)		ffz(~(x))
 #endif
 
+#define HP_ZX1_IOC_OFFSET	0x1000  /* ACPI reports SBA, we want IOC */
+
+/* HP ZX1 IOC registers */
+#define HP_ZX1_IBASE		0x300
+#define HP_ZX1_IMASK		0x308
+#define HP_ZX1_PCOM		0x310
+#define HP_ZX1_TCNFG		0x318
+#define HP_ZX1_PDIR_BASE	0x320
+
+/* HP ZX1 LBA registers */
+#define HP_ZX1_AGP_STATUS	0x64
+#define HP_ZX1_AGP_COMMAND	0x68
+
 #define HP_ZX1_IOVA_BASE	GB(1UL)
 #define HP_ZX1_IOVA_SIZE	GB(1UL)
 #define HP_ZX1_GART_SIZE	(HP_ZX1_IOVA_SIZE / 2)
@@ -20,6 +39,9 @@
 #define HP_ZX1_PDIR_VALID_BIT	0x8000000000000000UL
 #define HP_ZX1_IOVA_TO_PDIR(va)	((va - hp_private.iova_base) >> hp_private.io_tlb_shift)
 
+/* AGP bridge need not be PCI device, but DRM thinks it is. */
+static struct pci_dev fake_bridge_dev;
+
 static struct aper_size_info_fixed hp_zx1_sizes[] =
 {
 	{0, 0, 0},		/* filled in by hp_zx1_fetch_size() */
@@ -31,8 +53,8 @@
 };
 
 static struct _hp_private {
-	struct pci_dev *ioc;
-	volatile u8 *registers;
+	volatile u8 *ioc_regs;
+	volatile u8 *lba_regs;
 	u64 *io_pdir;		// PDIR for entire IOVA
 	u64 *gatt;		// PDIR just for GART (subset of above)
 	u64 gatt_entries;
@@ -59,7 +81,7 @@
 	 * 	- IOVA space is 1Gb in size
 	 * 	- first 512Mb is IOMMU, second 512Mb is GART
 	 */
-	hp->io_tlb_ps = INREG64(hp->registers, HP_ZX1_TCNFG);
+	hp->io_tlb_ps = INREG64(hp->ioc_regs, HP_ZX1_TCNFG);
 	switch (hp->io_tlb_ps) {
 		case 0: hp->io_tlb_shift = 12; break;
 		case 1: hp->io_tlb_shift = 13; break;
@@ -75,13 +97,13 @@
 	hp->io_page_size = 1 << hp->io_tlb_shift;
 	hp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;
 
-	hp->iova_base = INREG64(hp->registers, HP_ZX1_IBASE) & ~0x1;
+	hp->iova_base = INREG64(hp->ioc_regs, HP_ZX1_IBASE) & ~0x1;
 	hp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - HP_ZX1_GART_SIZE;
 
 	hp->gart_size = HP_ZX1_GART_SIZE;
 	hp->gatt_entries = hp->gart_size / hp->io_page_size;
 
-	hp->io_pdir = phys_to_virt(INREG64(hp->registers, HP_ZX1_PDIR_BASE));
+	hp->io_pdir = phys_to_virt(INREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE));
 	hp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];
 
 	if (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {
@@ -95,7 +117,8 @@
 	return 0;
 }
 
-static int __init hp_zx1_ioc_owner(u8 ioc_rev)
+static int __init
+hp_zx1_ioc_owner (void)
 {
 	struct _hp_private *hp = &hp_private;
 
@@ -130,47 +153,28 @@
 	return 0;
 }
 
-static int __init hp_zx1_ioc_init(void)
+static int __init
+hp_zx1_ioc_init (u64 ioc_hpa, u64 lba_hpa)
 {
 	struct _hp_private *hp = &hp_private;
-	struct pci_dev *ioc;
-	int i;
-	u8 ioc_rev;
-
-	ioc = pci_find_device(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_ZX1_IOC, NULL);
-	if (!ioc) {
-		printk(KERN_ERR PFX "Detected HP ZX1 AGP bridge but no IOC\n");
-		return -ENODEV;
-	}
-	hp->ioc = ioc;
-
-	pci_read_config_byte(ioc, PCI_REVISION_ID, &ioc_rev);
 
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		if (pci_resource_flags(ioc, i) == IORESOURCE_MEM) {
-			hp->registers = (u8 *) ioremap(pci_resource_start(ioc, i),
-						    pci_resource_len(ioc, i));
-			break;
-		}
-	}
-	if (!hp->registers) {
-		printk(KERN_ERR PFX "Detected HP ZX1 AGP bridge but no CSRs\n");
-		return -ENODEV;
-	}
+	hp->ioc_regs = ioremap(ioc_hpa, 1024);
+	hp->lba_regs = ioremap(lba_hpa, 256);
 
 	/*
 	 * If the IOTLB is currently disabled, we can take it over.
 	 * Otherwise, we have to share with sba_iommu.
 	 */
-	hp->io_pdir_owner = (INREG64(hp->registers, HP_ZX1_IBASE) & 0x1) == 0;
+	hp->io_pdir_owner = (INREG64(hp->ioc_regs, HP_ZX1_IBASE) & 0x1) == 0;
 
 	if (hp->io_pdir_owner)
-		return hp_zx1_ioc_owner(ioc_rev);
+		return hp_zx1_ioc_owner();
 
 	return hp_zx1_ioc_shared();
 }
 
-static int hp_zx1_fetch_size(void)
+static int
+hp_zx1_fetch_size(void)
 {
 	int size;
 
@@ -180,47 +184,53 @@
 	return size;
 }
 
-static int hp_zx1_configure(void)
+static int
+hp_zx1_configure (void)
 {
 	struct _hp_private *hp = &hp_private;
 
 	agp_bridge->gart_bus_addr = hp->gart_base;
+#if 0
+	/* ouch!! can't do that with a non-PCI AGP bridge... */
 	agp_bridge->capndx = pci_find_capability(agp_bridge->dev, PCI_CAP_ID_AGP);
-	pci_read_config_dword(agp_bridge->dev,
-		agp_bridge->capndx + PCI_AGP_STATUS, &agp_bridge->mode);
+#else
+	agp_bridge->capndx = 0;
+#endif
+	agp_bridge->mode = INREG32(hp->lba_regs, HP_ZX1_AGP_STATUS);
 
 	if (hp->io_pdir_owner) {
-		OUTREG64(hp->registers, HP_ZX1_PDIR_BASE,
-			virt_to_phys(hp->io_pdir));
-		OUTREG64(hp->registers, HP_ZX1_TCNFG, hp->io_tlb_ps);
-		OUTREG64(hp->registers, HP_ZX1_IMASK, ~(HP_ZX1_IOVA_SIZE - 1));
-		OUTREG64(hp->registers, HP_ZX1_IBASE, hp->iova_base | 0x1);
-		OUTREG64(hp->registers, HP_ZX1_PCOM,
-			hp->iova_base | log2(HP_ZX1_IOVA_SIZE));
-		INREG64(hp->registers, HP_ZX1_PCOM);
+		OUTREG64(hp->ioc_regs, HP_ZX1_PDIR_BASE, virt_to_phys(hp->io_pdir));
+		OUTREG64(hp->ioc_regs, HP_ZX1_TCNFG, hp->io_tlb_ps);
+		OUTREG64(hp->ioc_regs, HP_ZX1_IMASK, ~(HP_ZX1_IOVA_SIZE - 1));
+		OUTREG64(hp->ioc_regs, HP_ZX1_IBASE, hp->iova_base | 0x1);
+		OUTREG64(hp->ioc_regs, HP_ZX1_PCOM, hp->iova_base | log2(HP_ZX1_IOVA_SIZE));
+		INREG64(hp->ioc_regs, HP_ZX1_PCOM);
 	}
 
 	return 0;
 }
 
-static void hp_zx1_cleanup(void)
+static void
+hp_zx1_cleanup (void)
 {
 	struct _hp_private *hp = &hp_private;
 
 	if (hp->io_pdir_owner)
-		OUTREG64(hp->registers, HP_ZX1_IBASE, 0);
-	iounmap((void *) hp->registers);
+		OUTREG64(hp->ioc_regs, HP_ZX1_IBASE, 0);
+	iounmap((void *) hp->ioc_regs);
 }
 
-static void hp_zx1_tlbflush(struct agp_memory *mem)
+static void
+hp_zx1_tlbflush (struct agp_memory *mem)
 {
 	struct _hp_private *hp = &hp_private;
 
-	OUTREG64(hp->registers, HP_ZX1_PCOM, hp->gart_base | log2(hp->gart_size));
-	INREG64(hp->registers, HP_ZX1_PCOM);
+	OUTREG64(hp->ioc_regs, HP_ZX1_PCOM, hp->gart_base | log2(hp->gart_size));
+	INREG64(hp->ioc_regs, HP_ZX1_PCOM);
 }
 
-static int hp_zx1_create_gatt_table(void)
+static int
+hp_zx1_create_gatt_table (void)
 {
 	struct _hp_private *hp = &hp_private;
 	int i;
@@ -247,7 +257,8 @@
 	return 0;
 }
 
-static int hp_zx1_free_gatt_table(void)
+static int
+hp_zx1_free_gatt_table (void)
 {
 	struct _hp_private *hp = &hp_private;
 
@@ -259,8 +270,8 @@
 	return 0;
 }
 
-static int hp_zx1_insert_memory(struct agp_memory *mem, off_t pg_start,
-				int type)
+static int
+hp_zx1_insert_memory (struct agp_memory *mem, off_t pg_start, int type)
 {
 	struct _hp_private *hp = &hp_private;
 	int i, k;
@@ -305,8 +316,8 @@
 	return 0;
 }
 
-static int hp_zx1_remove_memory(struct agp_memory *mem, off_t pg_start,
-				int type)
+static int
+hp_zx1_remove_memory (struct agp_memory *mem, off_t pg_start, int type)
 {
 	struct _hp_private *hp = &hp_private;
 	int i, io_pg_start, io_pg_count;
@@ -325,11 +336,28 @@
 	return 0;
 }
 
-static unsigned long hp_zx1_mask_memory(unsigned long addr, int type)
+static unsigned long
+hp_zx1_mask_memory (unsigned long addr, int type)
 {
 	return HP_ZX1_PDIR_VALID_BIT | addr;
 }
 
+static void
+hp_zx1_enable (u32 mode)
+{
+	struct _hp_private *hp = &hp_private;
+	u32 command;
+
+	command = INREG32(hp->lba_regs, HP_ZX1_AGP_STATUS);
+
+	command = agp_collect_device_status(mode, command);
+	command |= 0x00000100;
+
+	OUTREG32(hp->lba_regs, HP_ZX1_AGP_COMMAND, command);
+
+	agp_device_command(command, 0);
+}
+
 struct agp_bridge_driver hp_zx1_driver = {
 	.owner			= THIS_MODULE,
 	.size_type		= FIXED_APER_SIZE,
@@ -339,7 +367,7 @@
 	.tlb_flush		= hp_zx1_tlbflush,
 	.mask_memory		= hp_zx1_mask_memory,
 	.masks			= hp_zx1_masks,
-	.agp_enable		= agp_generic_enable,
+	.agp_enable		= hp_zx1_enable,
 	.cache_flush		= global_cache_flush,
 	.create_gatt_table	= hp_zx1_create_gatt_table,
 	.free_gatt_table	= hp_zx1_free_gatt_table,
@@ -352,71 +380,93 @@
 	.cant_use_aperture	= 1,
 };
 
-static int __init agp_hp_probe(struct pci_dev *pdev,
-			       const struct pci_device_id *ent)
+static int __init
+hp_zx1_setup (u64 ioc_hpa, u64 lba_hpa)
 {
 	struct agp_bridge_data *bridge;
 	int error;
 
-	/* ZX1 LBAs can be either PCI or AGP bridges */
-	if (!pci_find_capability(pdev, PCI_CAP_ID_AGP))
-		return -ENODEV;
-
-	printk(KERN_INFO PFX "Detected HP ZX1 AGP chipset at %s\n",
-			pdev->slot_name);
+	printk(KERN_INFO PFX "Detected HP ZX1 AGP chipset (ioc=%lx, lba=%lx)\n", ioc_hpa, lba_hpa);
 
-	error = hp_zx1_ioc_init();
+	error = hp_zx1_ioc_init(ioc_hpa, lba_hpa);
 	if (error)
 		return error;
 
 	bridge = agp_alloc_bridge();
 	if (!bridge)
 		return -ENOMEM;
-
 	bridge->driver = &hp_zx1_driver;
-	bridge->dev = pdev;
 
-	pci_set_drvdata(pdev, bridge);
+	fake_bridge_dev.vendor = PCI_VENDOR_ID_HP;
+	fake_bridge_dev.device = PCI_DEVICE_ID_HP_ZX1_LBA;
+	bridge->dev = &fake_bridge_dev;
+
 	return agp_add_bridge(bridge);
 }
 
-static void __devexit agp_hp_remove(struct pci_dev *pdev)
+static acpi_status __init
+zx1_gart_probe (acpi_handle obj, u32 depth, void *context, void **ret)
 {
-	struct agp_bridge_data *bridge = pci_get_drvdata(pdev);
-
-	agp_remove_bridge(bridge);
-	agp_put_bridge(bridge);
-}
-
-static struct pci_device_id agp_hp_pci_table[] __initdata = {
-	{
-	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
-	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_HP,
-	.device		= PCI_DEVICE_ID_HP_ZX1_LBA,
-	.subvendor	= PCI_ANY_ID,
-	.subdevice	= PCI_ANY_ID,
-	},
-	{ }
-};
+	acpi_handle handle, parent;
+	acpi_status status;
+	struct acpi_buffer buffer;
+	struct acpi_device_info *info;
+	u64 lba_hpa, sba_hpa, length;
+	int match;
+
+	status = hp_acpi_csr_space(obj, &lba_hpa, &length);
+	if (ACPI_FAILURE(status))
+		return 1;
+
+	/* Look for an enclosing IOC scope and find its CSR space */
+	handle = obj;
+	do {
+		buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+		status = acpi_get_object_info(handle, &buffer);
+		if (ACPI_SUCCESS(status)) {
+			/* TBD check _CID also */
+			info = buffer.pointer;
+			info->hardware_id.value[sizeof(info->hardware_id)-1] = '\0';
+			match = (strcmp(info->hardware_id.value, "HWP0001") == 0);
+			ACPI_MEM_FREE(info);
+			if (match) {
+				status = hp_acpi_csr_space(handle, &sba_hpa, &length);
+				if (ACPI_SUCCESS(status))
+					break;
+				else {
+					printk(KERN_ERR PFX "Detected HP ZX1 "
+					       "AGP LBA but no IOC.\n");
+					return status;
+				}
+			}
+		}
 
-MODULE_DEVICE_TABLE(pci, agp_hp_pci_table);
+		status = acpi_get_parent(handle, &parent);
+		handle = parent;
+	} while (ACPI_SUCCESS(status));
 
-static struct pci_driver agp_hp_pci_driver = {
-	.name		= "agpgart-hp",
-	.id_table	= agp_hp_pci_table,
-	.probe		= agp_hp_probe,
-	.remove		= agp_hp_remove,
-};
+	if (hp_zx1_setup(sba_hpa + HP_ZX1_IOC_OFFSET, lba_hpa))
+		return 1;
+	return 0;
+}
 
-static int __init agp_hp_init(void)
+static int __init
+agp_hp_init (void)
 {
-	return pci_module_init(&agp_hp_pci_driver);
+	acpi_status status;
+
+	status = acpi_get_devices("HWP0003", zx1_gart_probe, "HWP0003 AGP LBA", NULL);
+	if (!(ACPI_SUCCESS(status))) {
+		agp_bridge->type = NOT_SUPPORTED;
+		printk(KERN_INFO PFX "Failed to initialize zx1 AGP.\n");
+		return -ENODEV;
+	}
+	return 0;
 }
 
-static void __exit agp_hp_cleanup(void)
+static void __exit
+agp_hp_cleanup (void)
 {
-	pci_unregister_driver(&agp_hp_pci_driver);
 }
 
 module_init(agp_hp_init);
diff -Nru a/drivers/char/agp/i460-agp.c b/drivers/char/agp/i460-agp.c
--- a/drivers/char/agp/i460-agp.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/char/agp/i460-agp.c	Fri Jun 27 22:41:17 2003
@@ -608,7 +608,7 @@
 	.name		= "agpgart-intel-i460",
 	.id_table	= agp_intel_i460_pci_table,
 	.probe		= agp_intel_i460_probe,
-	.remove		= agp_intel_i460_remove,
+	.remove		= __exit_p(agp_intel_i460_remove),
 };
 
 static int __init agp_intel_i460_init(void)
diff -Nru a/drivers/media/radio/Makefile b/drivers/media/radio/Makefile
--- a/drivers/media/radio/Makefile	Fri Jun 27 22:41:17 2003
+++ b/drivers/media/radio/Makefile	Fri Jun 27 22:41:17 2003
@@ -2,6 +2,8 @@
 # Makefile for the kernel character device drivers.
 #
 
+obj-y		:= dummy.o
+
 miropcm20-objs	:= miropcm20-rds-core.o miropcm20-radio.o
 
 obj-$(CONFIG_RADIO_AZTECH) += radio-aztech.o
diff -Nru a/drivers/media/radio/dummy.c b/drivers/media/radio/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/radio/dummy.c	Fri Jun 27 22:41:17 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/media/video/Makefile b/drivers/media/video/Makefile
--- a/drivers/media/video/Makefile	Fri Jun 27 22:41:17 2003
+++ b/drivers/media/video/Makefile	Fri Jun 27 22:41:17 2003
@@ -6,6 +6,8 @@
 			bttv-risc.o bttv-vbi.o
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 
+obj-y		:=	dummy.o
+
 obj-$(CONFIG_VIDEO_DEV) += videodev.o v4l2-common.o v4l1-compat.o
 
 obj-$(CONFIG_VIDEO_BT848) += bttv.o msp3400.o tvaudio.o \
diff -Nru a/drivers/media/video/dummy.c b/drivers/media/video/dummy.c
--- /dev/null	Wed Dec 31 16:00:00 1969
+++ b/drivers/media/video/dummy.c	Fri Jun 27 22:41:17 2003
@@ -0,0 +1 @@
+/* just so the linker knows what kind of object files it's deadling with... */
diff -Nru a/drivers/mtd/afs.c b/drivers/mtd/afs.c
--- a/drivers/mtd/afs.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/afs.c	Fri Jun 27 22:41:17 2003
@@ -21,7 +21,7 @@
    This is access code for flashes using ARM's flash partitioning 
    standards.
 
-   $Id: afs.c,v 1.11 2003/05/16 17:08:24 dwmw2 Exp $
+   $Id: afs.c,v 1.12 2003/06/13 15:31:06 rmk Exp $
 
 ======================================================================*/
 
@@ -76,17 +76,19 @@
 		return ret;
 	}
 
+	ret = 1;
+
 	/*
 	 * Does it contain the magic number?
 	 */
 	if (fs.signature != 0xa0ffff9f)
-		ret = 1;
+		ret = 0;
 
 	/*
 	 * Don't touch the SIB.
 	 */
 	if (fs.type == 2)
-		ret = 1;
+		ret = 0;
 
 	*iis_start = fs.image_info_base & mask;
 	*img_start = fs.image_start & mask;
@@ -96,14 +98,14 @@
 	 * be located after the footer structure.
 	 */
 	if (*iis_start >= ptr)
-		ret = 1;
+		ret = 0;
 
 	/*
 	 * Check the start of this image.  The image
 	 * data can not be located after this block.
 	 */
 	if (*img_start > off)
-		ret = 1;
+		ret = 0;
 
 	return ret;
 }
@@ -152,7 +154,7 @@
 		ret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);
 		if (ret < 0)
 			break;
-		if (ret == 1)
+		if (ret == 0)
 			continue;
 
 		ret = afs_read_iis(mtd, &iis, iis_ptr);
@@ -185,7 +187,7 @@
 		ret = afs_read_footer(mtd, &img_ptr, &iis_ptr, off, mask);
 		if (ret < 0)
 			break;
-		if (ret == 1)
+		if (ret == 0)
 			continue;
 
 		/* Read the image info block */
diff -Nru a/drivers/mtd/chips/amd_flash.c b/drivers/mtd/chips/amd_flash.c
--- a/drivers/mtd/chips/amd_flash.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/chips/amd_flash.c	Fri Jun 27 22:41:17 2003
@@ -3,7 +3,7 @@
  *
  * Author: Jonas Holmberg <jonas.holmberg@axis.com>
  *
- * $Id: amd_flash.c,v 1.22 2003/05/28 13:47:19 dwmw2 Exp $
+ * $Id: amd_flash.c,v 1.23 2003/06/12 09:24:13 dwmw2 Exp $
  *
  * Copyright (c) 2001 Axis Communications AB
  *
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/init.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/flashchip.h>
diff -Nru a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
--- a/drivers/mtd/chips/cfi_cmdset_0001.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c	Fri Jun 27 22:41:17 2003
@@ -4,7 +4,7 @@
  *
  * (C) 2000 Red Hat. GPL'd
  *
- * $Id: cfi_cmdset_0001.c,v 1.123 2003/05/28 12:51:48 dwmw2 Exp $
+ * $Id: cfi_cmdset_0001.c,v 1.126 2003/06/23 07:45:48 dwmw2 Exp $
  *
  * 
  * 10/10/2000	Nicolas Pitre <nico@cam.org>
@@ -936,7 +936,7 @@
 	struct cfi_private *cfi = map->fldrv_priv;
 	cfi_word status, status_OK;
 	unsigned long cmd_adr, timeo;
-	int wbufsize, z, ret=0;
+	int wbufsize, z, ret=0, bytes, words;
 
 	wbufsize = CFIDEV_INTERLEAVE << cfi->cfiq->MaxBufWriteSize;
 	adr += chip->start;
@@ -995,10 +995,13 @@
 	}
 
 	/* Write length of data to come */
-	cfi_write(map, CMD(len/CFIDEV_BUSWIDTH-1), cmd_adr );
+	bytes = len & (CFIDEV_BUSWIDTH-1);
+	words = len / CFIDEV_BUSWIDTH;
+	cfi_write(map, CMD(words - !bytes), cmd_adr );
 
 	/* Write data */
-	for (z = 0; z < len; z += CFIDEV_BUSWIDTH) {
+	z = 0;
+	while(z < words * CFIDEV_BUSWIDTH) {
 		if (cfi_buswidth_is_1()) {
 			map_write8 (map, *((__u8*)buf)++, adr+z);
 		} else if (cfi_buswidth_is_2()) {
@@ -1011,6 +1014,26 @@
 			ret = -EINVAL;
 			goto out;
 		}
+		z += CFIDEV_BUSWIDTH;
+	}
+	if (bytes) {
+		int i = 0, n = 0;
+		u_char tmp_buf[8], *tmp_p = tmp_buf;
+
+		while (bytes--)
+			tmp_buf[i++] = buf[n++];
+		while (i < CFIDEV_BUSWIDTH)
+			tmp_buf[i++] = 0xff;
+		if (cfi_buswidth_is_2()) {
+			map_write16 (map, *((__u16*)tmp_p)++, adr+z);
+		} else if (cfi_buswidth_is_4()) {
+			map_write32 (map, *((__u32*)tmp_p)++, adr+z);
+		} else if (cfi_buswidth_is_8()) {
+			map_write64 (map, *((__u64*)tmp_p)++, adr+z);
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
 	}
 	/* GO GO GO */
 	cfi_write(map, CMD(0xd0), cmd_adr);
@@ -1119,12 +1142,12 @@
 	}
 
 	/* Write buffer is worth it only if more than one word to write... */
-	while(len > CFIDEV_BUSWIDTH) {
+	while(len) {
 		/* We must not cross write block boundaries */
 		int size = wbufsize - (ofs & (wbufsize-1));
 
 		if (size > len)
-			size = len & ~(CFIDEV_BUSWIDTH-1);
+			size = len;
 		ret = do_write_buffer(map, &cfi->chips[chipnum], 
 				      ofs, buf, size);
 		if (ret)
@@ -1142,17 +1165,6 @@
 				return 0;
 		}
 	}
-
-	/* ... and write the remaining bytes */
-	if (len > 0) {
-		size_t local_retlen;
-		ret = cfi_intelext_write_words(mtd, ofs + (chipnum << cfi->chipshift),
-					       len, &local_retlen, buf);
-		if (ret)
-			return ret;
-		(*retlen) += local_retlen;
-	}
-
 	return 0;
 }
 
@@ -1423,6 +1435,7 @@
 			 * with the chip now anyway.
 			 */
 		}
+		spin_unlock(chip->mutex);
 	}
 
 	/* Unlock the chips again */
diff -Nru a/drivers/mtd/devices/doc2000.c b/drivers/mtd/devices/doc2000.c
--- a/drivers/mtd/devices/doc2000.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/devices/doc2000.c	Fri Jun 27 22:41:16 2003
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2000.c,v 1.52 2003/05/20 21:03:07 dwmw2 Exp $
+ * $Id: doc2000.c,v 1.53 2003/06/11 09:45:19 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -553,6 +553,7 @@
 
 	mtd->type = MTD_NANDFLASH;
 	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->ecctype = MTD_ECC_RS_DiskOnChip;
 	mtd->size = 0;
 	mtd->erasesize = 0;
 	mtd->oobblock = 512;
diff -Nru a/drivers/mtd/devices/doc2001.c b/drivers/mtd/devices/doc2001.c
--- a/drivers/mtd/devices/doc2001.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/devices/doc2001.c	Fri Jun 27 22:41:17 2003
@@ -4,7 +4,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001.c,v 1.40 2003/05/20 21:03:07 dwmw2 Exp $
+ * $Id: doc2001.c,v 1.41 2003/06/11 09:45:19 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -359,9 +359,10 @@
 
 	mtd->type = MTD_NANDFLASH;
 	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->ecctype = MTD_ECC_RS_DiskOnChip;
 	mtd->size = 0;
 
-	/* FIXME: erase size is not always 8kB */
+	/* FIXME: erase size is not always 8KiB */
 	mtd->erasesize = 0x2000;
 
 	mtd->oobblock = 512;
diff -Nru a/drivers/mtd/devices/doc2001plus.c b/drivers/mtd/devices/doc2001plus.c
--- a/drivers/mtd/devices/doc2001plus.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/devices/doc2001plus.c	Fri Jun 27 22:41:16 2003
@@ -6,7 +6,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: doc2001plus.c,v 1.4 2003/05/23 11:28:46 dwmw2 Exp $
+ * $Id: doc2001plus.c,v 1.5 2003/06/11 09:45:19 dwmw2 Exp $
  */
 
 #include <linux/kernel.h>
@@ -458,6 +458,7 @@
 
 	mtd->type = MTD_NANDFLASH;
 	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->ecctype = MTD_ECC_RS_DiskOnChip;
 	mtd->size = 0;
 
 	mtd->erasesize = 0;
diff -Nru a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
--- a/drivers/mtd/ftl.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/ftl.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.50 2003/05/21 10:49:47 dwmw2 Exp $
+ * $Id: ftl.c,v 1.51 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -984,37 +984,20 @@
     return 0;
 } /* ftl_write */
 
-/*======================================================================
-
-    IOCTL calls for getting device parameters.
-
-======================================================================*/
-
-static int ftl_ioctl(struct mtd_blktrans_dev *dev, struct inode *inode, 
-		     struct file *file, u_int cmd, u_long arg)
+static int ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)
 {
-    struct hd_geometry *geo = (struct hd_geometry *)arg;
-    partition_t *part = (void *)dev;
-    u_long sect;
-
-    switch (cmd) {
-    case HDIO_GETGEO:
-	/* Sort of arbitrary: round size down to 4K boundary */
-	sect = le32_to_cpu(part->header.FormattedSize)/SECTOR_SIZE;
-	if (put_user(1, (char *)&geo->heads) ||
-	    put_user(8, (char *)&geo->sectors) ||
-	    put_user((sect>>3), (short *)&geo->cylinders) ||
-	    put_user(0, (u_long *)&geo->start))
-		return -EFAULT;
+	partition_t *part = (void *)dev;
+	u_long sect;
 
-    case BLKFLSBUF:
-	    return 0;
-    }
-    return -ENOTTY;
-} /* ftl_ioctl */
+	/* Sort of arbitrary: round size down to 4KiB boundary */
+	sect = le32_to_cpu(part->header.FormattedSize)/SECTOR_SIZE;
 
+	geo->heads = 1;
+	geo->sectors = 8;
+	geo->cylinders = sect >> 3;
 
-/*======================================================================*/
+	return 0;
+}
 
 static int ftl_readsect(struct mtd_blktrans_dev *dev,
 			      unsigned long block, char *buf)
@@ -1102,7 +1085,7 @@
 	.part_bits	= PART_BITS,
 	.readsect	= ftl_readsect,
 	.writesect	= ftl_writesect,
-	.ioctl		= ftl_ioctl,
+	.getgeo		= ftl_getgeo,
 	.add_mtd	= ftl_add_mtd,
 	.remove_dev	= ftl_remove_dev,
 	.owner		= THIS_MODULE,
@@ -1110,7 +1093,7 @@
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.50 2003/05/21 10:49:47 dwmw2 Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.51 2003/06/23 12:00:08 dwmw2 Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }
diff -Nru a/drivers/mtd/inftlcore.c b/drivers/mtd/inftlcore.c
--- a/drivers/mtd/inftlcore.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/inftlcore.c	Fri Jun 27 22:41:16 2003
@@ -7,7 +7,7 @@
  * (c) 1999 Machine Vision Holdings, Inc.
  * Author: David Woodhouse <dwmw2@infradead.org>
  *
- * $Id: inftlcore.c,v 1.9 2003/05/23 11:41:47 dwmw2 Exp $
+ * $Id: inftlcore.c,v 1.11 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -113,7 +113,7 @@
 			(long)inftl->sectors );
 	}
 
-	if (add_mtd_blktrans_dev) {
+	if (add_mtd_blktrans_dev(&inftl->mbd)) {
 		if (inftl->PUtable)
 			kfree(inftl->PUtable);
 		if (inftl->VUtable)
@@ -835,35 +835,22 @@
 	return 0;
 }
 
-
-static int inftl_ioctl(struct mtd_blktrans_dev *dev,
-		     struct inode *inode, struct file *file, 
-		     unsigned int cmd, unsigned long arg)
+static int inftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)
 {
 	struct NFTLrecord *nftl = (void *)dev;
 
-	switch (cmd) {
-	case HDIO_GETGEO: {
-		struct hd_geometry g;
-
-		g.heads = nftl->heads;
-		g.sectors = nftl->sectors;
-		g.cylinders = nftl->cylinders;
-		g.start = 0;
-		return copy_to_user((void *)arg, &g, sizeof g) ? -EFAULT : 0;
-	}
+	geo->heads = nftl->heads;
+	geo->sectors = nftl->sectors;
+	geo->cylinders = nftl->cylinders;
 
-	default:
-		return -ENOTTY;
-	}
+	return 0;
 }
 
-
 struct mtd_blktrans_ops inftl_tr = {
 	.name		= "inftl",
 	.major		= INFTL_MAJOR,
 	.part_bits	= INFTL_PARTN_BITS,
-	.ioctl		= inftl_ioctl,
+	.getgeo		= inftl_getgeo,
 	.readsect	= inftl_readblock,
 	.writesect	= inftl_writeblock,
 	.add_mtd	= inftl_add_mtd,
@@ -875,7 +862,7 @@
 
 int __init init_inftl(void)
 {
-	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.9 $, "
+	printk(KERN_INFO "INFTL: inftlcore.c $Revision: 1.11 $, "
 		"inftlmount.c %s\n", inftlmountrev);
 
 	return register_mtd_blktrans(&inftl_tr);
diff -Nru a/drivers/mtd/inftlmount.c b/drivers/mtd/inftlmount.c
--- a/drivers/mtd/inftlmount.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/inftlmount.c	Fri Jun 27 22:41:16 2003
@@ -8,7 +8,7 @@
  * Author: Fabrice Bellard (fabrice.bellard@netgem.com) 
  * Copyright (C) 2000 Netgem S.A.
  *
- * $Id: inftlmount.c,v 1.9 2003/05/23 11:35:07 dwmw2 Exp $
+ * $Id: inftlmount.c,v 1.11 2003/06/23 07:39:21 dwmw2 Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,7 +25,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#define __NO_VERSION__
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -42,7 +41,7 @@
 #include <linux/mtd/inftl.h>
 #include <linux/mtd/compatmac.h>
 
-char inftlmountrev[]="$Revision: 1.9 $";
+char inftlmountrev[]="$Revision: 1.11 $";
 
 /*
  * find_boot_record: Find the INFTL Media Header and its Spare copy which
@@ -242,7 +241,7 @@
 			}
 			if ((ip->lastUnit - ip->firstUnit + 1) < ip->virtualUnits) {
 				printk(KERN_WARNING "INFTL: Media Header "
-					"Parition %d sanity check failed\n"
+					"Partition %d sanity check failed\n"
 					"    firstUnit %d : lastUnit %d  >  "
 					"virtualUnits %d\n", i, ip->lastUnit,
 					ip->firstUnit, ip->Reserved0);
@@ -250,7 +249,7 @@
 			}
 			if (ip->Reserved1 != 0) {
 				printk(KERN_WARNING "INFTL: Media Header "
-					"Parition %d sanity check failed: "
+					"Partition %d sanity check failed: "
 					"Reserved1 %d != 0\n",
 					i, ip->Reserved1);
 				return -1;
@@ -261,7 +260,7 @@
 		}
 
 		if (i >= 4) {
-			printk(KERN_WARNING "INFTL: Media Header Parition "
+			printk(KERN_WARNING "INFTL: Media Header Partition "
 				"sanity check failed:\n       No partition "
 				"marked as Disk Partition\n");
 			return -1;
@@ -630,7 +629,7 @@
 			if (prev_block < s->nb_blocks)
 				prev_block += s->firstEUN;
 
-			/* Already explored paritial chain? */
+			/* Already explored partial chain? */
 			if (s->PUtable[block] != BLOCK_NOTEXPLORED) {
 				/* Check if chain for this logical */
 				if (logical_block == first_logical_block) {
diff -Nru a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
--- a/drivers/mtd/maps/Kconfig	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/Kconfig	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 # drivers/mtd/maps/Kconfig
-# $Id: Kconfig,v 1.11 2003/05/28 15:16:56 dwmw2 Exp $
+# $Id: Kconfig,v 1.12 2003/06/23 07:38:11 dwmw2 Exp $
 
 menu "Mapping drivers for chip access"
 	depends on MTD!=n
@@ -476,7 +476,7 @@
 
 config MTD_UCLINUX
 	tristate "Generic uClinux RAM/ROM filesystem support"
-	depends on MTD_PARTITIONS
+	depends on MTD_PARTITIONS && !MMU
 	help
 	  Map driver to support image based filesystems for uClinux.
 
diff -Nru a/drivers/mtd/maps/arctic-mtd.c b/drivers/mtd/maps/arctic-mtd.c
--- a/drivers/mtd/maps/arctic-mtd.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/arctic-mtd.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: arctic-mtd.c,v 1.8 2003/05/21 12:45:17 dwmw2 Exp $
+ * $Id: arctic-mtd.c,v 1.10 2003/06/02 16:37:59 trini Exp $
  * 
  * drivers/mtd/maps/arctic-mtd.c MTD mappings and partition tables for 
  *                              IBM 405LP Arctic boards.
@@ -45,18 +45,23 @@
 #include <asm/ibm4xx.h>
 
 /*
- * fe000000 -- ff9fffff  Arctic FFS (26MB)
- * ffa00000 -- fff5ffff  kernel (5.504MB)
- * fff60000 -- ffffffff  firmware (640KB)
+ * 0 : 0xFE00 0000 - 0xFEFF FFFF : Filesystem 1 (16MiB)
+ * 1 : 0xFF00 0000 - 0xFF4F FFFF : kernel (5.12MiB)
+ * 2 : 0xFF50 0000 - 0xFFF5 FFFF : Filesystem 2 (10.624MiB) (if non-XIP)
+ * 3 : 0xFFF6 0000 - 0xFFFF FFFF : PIBS Firmware (640KiB)
  */
 
-#define ARCTIC_FFS_SIZE		0x01a00000 /* 26 M */
-#define ARCTIC_FIRMWARE_SIZE	0x000a0000 /* 640K */
+#define FFS1_SIZE	0x01000000 /* 16MiB */
+#define KERNEL_SIZE	0x00500000 /* 5.12MiB */
+#define FFS2_SIZE	0x00a60000 /* 10.624MiB */
+#define FIRMWARE_SIZE	0x000a0000 /* 640KiB */
 
-#define NAME     "Arctic Linux Flash"
-#define PADDR    SUBZERO_BOOTFLASH_PADDR
-#define SIZE     SUBZERO_BOOTFLASH_SIZE
-#define BUSWIDTH 2
+
+#define NAME     	"Arctic Linux Flash"
+#define PADDR    	SUBZERO_BOOTFLASH_PADDR
+#define BUSWIDTH	2
+#define SIZE		SUBZERO_BOOTFLASH_SIZE
+#define PARTITIONS	4
 
 /* Flash memories on these boards are memory resources, accessed big-endian. */
 
@@ -73,17 +78,19 @@
 
 static struct mtd_info *arctic_mtd;
 
-static struct mtd_partition arctic_partitions[3] = {
-	{ .name		= "Arctic FFS",
-	  .size		= ARCTIC_FFS_SIZE,
+static struct mtd_partition arctic_partitions[PARTITIONS] = {
+	{ .name		= "Filesystem",
+	  .size		= FFS1_SIZE,
 	  .offset	= 0,},
-	{ .name		= "Kernel",
-	  .size		= SUBZERO_BOOTFLASH_SIZE - ARCTIC_FFS_SIZE -
-	  		  ARCTIC_FIRMWARE_SIZE,
-	  .offset	= ARCTIC_FFS_SIZE,},
+        { .name		= "Kernel",
+	  .size		= KERNEL_SIZE,
+	  .offset	= FFS1_SIZE,},
+	{ .name		= "Filesystem",
+	  .size		= FFS2_SIZE,
+	  .offset	= FFS1_SIZE + KERNEL_SIZE,},
 	{ .name		= "Firmware",
-	  .size		= ARCTIC_FIRMWARE_SIZE,
-	  .offset	= SUBZERO_BOOTFLASH_SIZE - ARCTIC_FIRMWARE_SIZE,},
+	  .size		= FIRMWARE_SIZE,
+	  .offset	= SUBZERO_BOOTFLASH_SIZE - FIRMWARE_SIZE,},
 };
 
 static int __init
@@ -107,7 +114,7 @@
 
 	arctic_mtd->owner = THIS_MODULE;
 
-	return add_mtd_partitions(arctic_mtd, arctic_partitions, 3);
+	return add_mtd_partitions(arctic_mtd, arctic_partitions, PARTITIONS);
 }
 
 static void __exit
diff -Nru a/drivers/mtd/maps/ebony.c b/drivers/mtd/maps/ebony.c
--- a/drivers/mtd/maps/ebony.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/ebony.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: ebony.c,v 1.7 2003/05/21 12:45:18 dwmw2 Exp $
+ * $Id: ebony.c,v 1.8 2003/06/23 11:48:18 dwmw2 Exp $
  * 
  * Mapping for Ebony user flash
  *
@@ -60,8 +60,6 @@
 	}
 };
 
-#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
-
 int __init init_ebony(void)
 {
 	u8 fpga0_reg;
@@ -109,7 +107,7 @@
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_small_partitions,
-					NB_OF(ebony_small_partitions));
+					ARRAY_SIZE(ebony_small_partitions));
 	} else {
 		printk("map probe failed for flash\n");
 		return -ENXIO;
@@ -131,7 +129,7 @@
 	if (flash) {
 		flash->owner = THIS_MODULE;
 		add_mtd_partitions(flash, ebony_large_partitions,
-					NB_OF(ebony_large_partitions));
+					ARRAY_SIZE(ebony_large_partitions));
 	} else {
 		printk("map probe failed for flash\n");
 		return -ENXIO;
diff -Nru a/drivers/mtd/maps/edb7312.c b/drivers/mtd/maps/edb7312.c
--- a/drivers/mtd/maps/edb7312.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/edb7312.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: edb7312.c,v 1.8 2003/05/21 12:45:18 dwmw2 Exp $
+ * $Id: edb7312.c,v 1.9 2003/06/23 11:48:18 dwmw2 Exp $
  *
  * Handle mapping of the NOR flash on Cogent EDB7312 boards
  *
@@ -67,7 +67,6 @@
 	},
 };
 
-#define NB_OF(x) (sizeof (x) / sizeof (x[0]))
 static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
 
 #endif
@@ -109,7 +108,7 @@
 		if (mtd_parts_nb == 0)
 		{
 			mtd_parts = static_partitions;
-			mtd_parts_nb = NB_OF(static_partitions);
+			mtd_parts_nb = ARRAY_SIZE(static_partitions);
 			part_type = "static";
 		}
 #endif
diff -Nru a/drivers/mtd/maps/elan-104nc.c b/drivers/mtd/maps/elan-104nc.c
--- a/drivers/mtd/maps/elan-104nc.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/elan-104nc.c	Fri Jun 27 22:41:17 2003
@@ -16,7 +16,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 
-   $Id: elan-104nc.c,v 1.17 2003/05/21 15:15:07 dwmw2 Exp $
+   $Id: elan-104nc.c,v 1.18 2003/06/23 07:37:02 dwmw2 Exp $
 
 The ELAN-104NC has up to 8 Mibyte of Intel StrataFlash (28F320/28F640) in x16
 mode.  This drivers uses the CFI probe and Intel Extended Command Set drivers.
@@ -223,30 +223,19 @@
 	}
 
 	iounmap((void *)iomapadr);
-	release_region(PAGE_IO,PAGE_IO_SIZE);
 }
 
 int __init init_elan_104nc(void)
 {
-	/* Urg! We use I/O port 0x22 without request_region()ing it */
-	/*
-	if (check_region(PAGE_IO,PAGE_IO_SIZE) != 0) {
-		printk( KERN_ERR"%s: IO ports 0x%x-0x%x in use\n",
-			elan_104nc_map.name,
-			PAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );
-		return -EAGAIN;
-	}
-	*/
+	/* Urg! We use I/O port 0x22 without request_region()ing it,
+	   because it's already allocated to the PIC. */
+
   	iomapadr = (unsigned long)ioremap(WINDOW_START, WINDOW_LENGTH);
 	if (!iomapadr) {
 		printk( KERN_ERR"%s: failed to ioremap memory region\n",
 			elan_104nc_map.name );
 		return -EIO;
 	}
-
-	/*
-	request_region( PAGE_IO, PAGE_IO_SIZE, "ELAN-104NC flash" );
-	*/
 
 	printk( KERN_INFO"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\n",
 		elan_104nc_map.name,
diff -Nru a/drivers/mtd/maps/impa7.c b/drivers/mtd/maps/impa7.c
--- a/drivers/mtd/maps/impa7.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/impa7.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: impa7.c,v 1.8 2003/05/21 12:45:18 dwmw2 Exp $
+ * $Id: impa7.c,v 1.9 2003/06/23 11:47:43 dwmw2 Exp $
  *
  * Handle mapping of the NOR flash on implementa A7 boards
  *
@@ -66,12 +66,11 @@
 	},
 };
 
-#define NB_OF(x) (sizeof (x) / sizeof (x[0]))
+static int mtd_parts_nb[NUM_FLASHBANKS];
+static struct mtd_partition *mtd_parts[NUM_FLASHBANKS];
 
 #endif
 
-static int                   mtd_parts_nb = 0;
-static struct mtd_partition *mtd_parts    = 0;
 static const char *probes[] = { "cmdlinepart", NULL };
 
 int __init init_impa7(void)
@@ -84,7 +83,6 @@
 	  { WINDOW_ADDR0, WINDOW_SIZE0 },
 	  { WINDOW_ADDR1, WINDOW_SIZE1 },
         };
-	char mtdid[10];
 	int devicesfound = 0;
 
 	for(i=0; i<NUM_FLASHBANKS; i++)
@@ -107,42 +105,34 @@
 			impa7_mtd[i] = do_map_probe(*type, &impa7_map[i]);
 		}
 
-		if (impa7_mtd[i]) 
-		{
+		if (impa7_mtd[i]) {
 			impa7_mtd[i]->owner = THIS_MODULE;
-			add_mtd_device(impa7_mtd[i]);
 			devicesfound++;
 #ifdef CONFIG_MTD_PARTITIONS
-			mtd_parts_nb = parse_mtd_partitions(impa7_mtd[i], 
-							    probes,
-							    &mtd_parts, 
-							    0);
-			if (mtd_parts_nb > 0)
-			  part_type = "command line";
-#endif
-			if (mtd_parts_nb <= 0)
-			{
-				mtd_parts = static_partitions;
-				mtd_parts_nb = NB_OF(static_partitions);
+			mtd_parts_nb[i] = parse_mtd_partitions(impa7_mtd[i], 
+							       probes,
+							       &mtd_parts[i], 
+							       0);
+			if (mtd_parts_nb[i] > 0) {
+				part_type = "command line";
+			} else {
+				mtd_parts[i] = static_partitions;
+				mtd_parts_nb[i] = ARRAY_SIZE(static_partitions);
 				part_type = "static";
 			}
-			if (mtd_parts_nb <= 0)
-			{
-				printk(KERN_NOTICE MSG_PREFIX 
-				       "no partition info available\n");
-			}
-			else
-			{
-				printk(KERN_NOTICE MSG_PREFIX
-				       "using %s partition definition\n", 
-				       part_type);
-				add_mtd_partitions(impa7_mtd[i], 
-						   mtd_parts, mtd_parts_nb);
-			}
+
+			printk(KERN_NOTICE MSG_PREFIX
+			       "using %s partition definition\n", 
+			       part_type);
+			add_mtd_partitions(impa7_mtd[i], 
+					   mtd_parts[i], mtd_parts_nb[i]);
+#else
+			add_mtd_device(impa7_mtd[i]);
+
 #endif
 		}
 		else 
-		  iounmap((void *)impa7_map[i].virt);
+			iounmap((void *)impa7_map[i].virt);
 	}
 	return devicesfound == 0 ? -ENXIO : 0;
 }
@@ -150,15 +140,14 @@
 static void __exit cleanup_impa7(void)
 {
 	int i;
-	for (i=0; i<NUM_FLASHBANKS; i++) 
-	{
-		if (impa7_mtd[i]) 
-		{
+	for (i=0; i<NUM_FLASHBANKS; i++) {
+		if (impa7_mtd[i]) {
+#ifdef CONFIG_MTD_PARTITIONS
+			del_mtd_partitions(impa7_mtd[i]);
+#else
 			del_mtd_device(impa7_mtd[i]);
+#endif
 			map_destroy(impa7_mtd[i]);
-		}
-		if (impa7_map[i].virt)
-		{
 			iounmap((void *)impa7_map[i].virt);
 			impa7_map[i].virt = 0;
 		}
diff -Nru a/drivers/mtd/maps/iq80310.c b/drivers/mtd/maps/iq80310.c
--- a/drivers/mtd/maps/iq80310.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/iq80310.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: iq80310.c,v 1.16 2003/05/21 15:15:07 dwmw2 Exp $
+ * $Id: iq80310.c,v 1.17 2003/06/23 11:48:18 dwmw2 Exp $
  *
  * Mapping for the Intel XScale IQ80310 evaluation board
  *
@@ -57,8 +57,6 @@
 	}
 };
 
-#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
-
 static struct mtd_info *mymtd;
 static struct mtd_partition *parsed_parts;
 static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
@@ -94,7 +92,7 @@
 		nb_parts = parsed_nr_parts;
 	} else {
 		parts = iq80310_partitions;
-		nb_parts = NB_OF(iq80310_partitions);
+		nb_parts = ARRAY_SIZE(iq80310_partitions);
 	}
 	add_mtd_partitions(mymtd, parts, nb_parts);
 	return 0;
diff -Nru a/drivers/mtd/maps/lubbock-flash.c b/drivers/mtd/maps/lubbock-flash.c
--- a/drivers/mtd/maps/lubbock-flash.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/lubbock-flash.c	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: lubbock-flash.c,v 1.8 2003/05/21 12:45:19 dwmw2 Exp $
+ * $Id: lubbock-flash.c,v 1.9 2003/06/23 11:48:18 dwmw2 Exp $
  *
  * Map driver for the Lubbock developer platform.
  *
@@ -52,8 +52,6 @@
 	}
 };
 
-#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
-
 static struct mtd_info *mymtds[2];
 static struct mtd_partition *parsed_parts[2];
 static int nr_parsed_parts[2];
@@ -116,7 +114,7 @@
 			add_mtd_partitions(mymtds[i], parsed_parts[i], nr_parsed_parts[i]);
 		} else if (!i) {
 			printk("Using static partitions on %s\n", lubbock_maps[i].name);
-			add_mtd_partitions(mymtds[i], lubbock_partitions, NB_OF(lubbock_partitions));
+			add_mtd_partitions(mymtds[i], lubbock_partitions, ARRAY_SIZE(lubbock_partitions));
 		} else {
 			printk("Registering %s as whole device\n", lubbock_maps[i].name);
 			add_mtd_device(mymtds[i]);
diff -Nru a/drivers/mtd/maps/pb1xxx-flash.c b/drivers/mtd/maps/pb1xxx-flash.c
--- a/drivers/mtd/maps/pb1xxx-flash.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/pb1xxx-flash.c	Fri Jun 27 22:41:17 2003
@@ -3,7 +3,7 @@
  * 
  * (C) 2001 Pete Popov <ppopov@mvista.com>
  * 
- * $Id: pb1xxx-flash.c,v 1.8 2003/05/21 12:45:19 dwmw2 Exp $
+ * $Id: pb1xxx-flash.c,v 1.9 2003/06/23 11:48:18 dwmw2 Exp $
  */
 
 #include <linux/config.h>
@@ -131,9 +131,6 @@
 #error Unsupported board
 #endif
 
-
-#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
-
 static struct mtd_partition *parsed_parts;
 static struct mtd_info *mymtd;
 
@@ -151,7 +148,7 @@
 	 */
 	part_type = "static";
 	parts = pb1xxx_partitions;
-	nb_parts = NB_OF(pb1xxx_partitions);
+	nb_parts = ARRAY_SIZE(pb1xxx_partitions);
 	pb1xxx_map.size = flash_size;
 
 	/*
diff -Nru a/drivers/mtd/maps/tqm8xxl.c b/drivers/mtd/maps/tqm8xxl.c
--- a/drivers/mtd/maps/tqm8xxl.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/maps/tqm8xxl.c	Fri Jun 27 22:41:17 2003
@@ -2,7 +2,7 @@
  * Handle mapping of the flash memory access routines 
  * on TQM8xxL based devices.
  *
- * $Id: tqm8xxl.c,v 1.8 2003/05/21 12:45:20 dwmw2 Exp $
+ * $Id: tqm8xxl.c,v 1.9 2003/06/23 11:48:18 dwmw2 Exp $
  *
  * based on rpxlite.c
  *
@@ -110,8 +110,6 @@
 };
 #endif
 
-#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
-
 int __init init_tqm_mtd(void)
 {
 	int idx = 0, ret = 0;
@@ -198,11 +196,11 @@
 	 */
 	part_banks[0].mtd_part = tqm8xxl_partitions;
 	part_banks[0].type = "Static image";
-	part_banks[0].nums = NB_OF(tqm8xxl_partitions);
+	part_banks[0].nums = ARRAY_SIZE(tqm8xxl_partitions);
 
 	part_banks[1].mtd_part = tqm8xxl_fs_partitions;
 	part_banks[1].type = "Static file system";
-	part_banks[1].nums = NB_OF(tqm8xxl_fs_partitions);
+	part_banks[1].nums = ARRAY_SIZE(tqm8xxl_fs_partitions);
 
 	for(idx = 0; idx < num_banks ; idx++) {
 		if (part_banks[idx].nums == 0) {
diff -Nru a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
--- a/drivers/mtd/mtd_blkdevs.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/mtd_blkdevs.c	Fri Jun 27 22:41:16 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: mtd_blkdevs.c,v 1.12 2003/05/21 01:00:59 dwmw2 Exp $
+ * $Id: mtd_blkdevs.c,v 1.16 2003/06/23 13:34:43 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
@@ -18,8 +18,10 @@
 #include <linux/blk.h>
 #include <linux/blkpg.h>
 #include <linux/spinlock.h>
+#include <linux/hdreg.h>
 #include <linux/init.h>
 #include <asm/semaphore.h>
+#include <asm/uaccess.h>
 #include <linux/devfs_fs_kernel.h>
 
 static LIST_HEAD(blktrans_majors);
@@ -46,7 +48,7 @@
 	nsect = req->current_nr_sectors;
 	buf = req->buffer;
 
-	if (!req->flags & REQ_CMD)
+	if (!(req->flags & REQ_CMD))
 		return 0;
 
 	if (block + nsect > get_capacity(req->rq_disk))
@@ -93,14 +95,14 @@
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
 
+	spin_lock_irq(rq->queue_lock);
+		
 	while (!tr->blkcore_priv->exiting) {
 		struct request *req;
 		struct mtd_blktrans_dev *dev;
 		int res = 0;
 		DECLARE_WAITQUEUE(wait, current);
 
-		spin_lock_irq(rq->queue_lock);
-
 		req = elv_next_request(rq);
 
 		if (!req) {
@@ -112,6 +114,8 @@
 			schedule();
 			remove_wait_queue(&tr->blkcore_priv->thread_wq, &wait);
 
+			spin_lock_irq(rq->queue_lock);
+
 			continue;
 		}
 
@@ -159,7 +163,7 @@
 	dev->mtd->usecount++;
 
 	ret = 0;
-	if (tr->open && (ret = tr->open(dev, i, f))) {
+	if (tr->open && (ret = tr->open(dev))) {
 		dev->mtd->usecount--;
 		module_put(dev->mtd->owner);
 	out_tr:
@@ -179,7 +183,7 @@
 	tr = dev->tr;
 
 	if (tr->release)
-		ret = tr->release(dev, i, f);
+		ret = tr->release(dev);
 
 	if (!ret) {
 		dev->mtd->usecount--;
@@ -194,21 +198,33 @@
 static int blktrans_ioctl(struct inode *inode, struct file *file, 
 			      unsigned int cmd, unsigned long arg)
 {
-	struct mtd_blktrans_dev *dev;
-	struct mtd_blktrans_ops *tr;
-	int ret = -ENOTTY;
-
-	dev = inode->i_bdev->bd_disk->private_data;
-	tr = dev->tr;
+	struct mtd_blktrans_dev *dev = inode->i_bdev->bd_disk->private_data;
+	struct mtd_blktrans_ops *tr = dev->tr;
 
-	if (tr->ioctl)
-		ret = tr->ioctl(dev, inode, file, cmd, arg);
-
-	if (ret == -ENOTTY && (cmd == BLKROSET || cmd == BLKFLSBUF)) {
+	switch (cmd) {
+	case BLKFLSBUF:
+		if (tr->flush)
+			return tr->flush(dev);
 		/* The core code did the work, we had nothing to do. */
-		ret = 0;
+		return 0;
+
+	case HDIO_GETGEO:
+		if (tr->getgeo) {
+			struct hd_geometry g;
+
+			memset(&g, 0, sizeof(g));
+			int ret = tr->getgeo(dev, &g);
+			if (ret)
+				return ret;
+
+			g.start = get_start_sect(inode->i_bdev);
+			if (copy_to_user((void *)arg, &g, sizeof(g)))
+				return -EFAULT;
+			return 0;
+		} /* else */
+	default:
+		return -ENOTTY;
 	}
-	return ret;
 }
 
 struct block_device_operations mtd_blktrans_ops = {
@@ -328,8 +344,6 @@
 	if (mtd->type == MTD_ABSENT)
 		return;
 
-	printk("%s:%s %d: count %d\n", __FILE__, __func__, __LINE__, atomic_read(&mtd_table_mutex.count));
-
 	list_for_each(this, &blktrans_majors) {
 		struct mtd_blktrans_ops *tr = list_entry(this, struct mtd_blktrans_ops, list);
 
@@ -391,8 +405,6 @@
 
 	INIT_LIST_HEAD(&tr->devs);
 	list_add(&tr->list, &blktrans_majors);
-
-	printk("%s:%s %d: count %d\n", __FILE__, __func__, __LINE__, atomic_read(&mtd_table_mutex.count));
 
 	for (i=0; i<MAX_MTD_DEVICES; i++) {
 		if (mtd_table[i] && mtd_table[i]->type != MTD_ABSENT)
diff -Nru a/drivers/mtd/mtdblock.c b/drivers/mtd/mtdblock.c
--- a/drivers/mtd/mtdblock.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/mtdblock.c	Fri Jun 27 22:41:17 2003
@@ -1,7 +1,7 @@
 /* 
  * Direct MTD block device access
  *
- * $Id: mtdblock.c,v 1.61 2003/05/21 10:49:38 dwmw2 Exp $
+ * $Id: mtdblock.c,v 1.63 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * (C) 2000-2003 Nicolas Pitre <nico@cam.org>
  * (C) 1999-2003 David Woodhouse <dwmw2@infradead.org>
@@ -248,11 +248,19 @@
 			      unsigned long block, char *buf)
 {
 	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
+	if (unlikely(!mtdblk->cache_data)) {
+		mtdblk->cache_data = vmalloc(mtdblk->mtd->erasesize);
+		if (!mtdblk->cache_data)
+			return -EINTR;
+		/* -EINTR is not really correct, but it is the best match
+		 * documented in man 2 write for all cases.  We could also
+		 * return -EAGAIN sometimes, but why bother?
+		 */
+	}
 	return do_cached_write(mtdblk, block<<9, 512, buf);
 }
 
-static int mtdblock_open(struct mtd_blktrans_dev *mbd, 
-			 struct inode *inode, struct file *file)
+static int mtdblock_open(struct mtd_blktrans_dev *mbd)
 {
 	struct mtdblk_dev *mtdblk;
 	struct mtd_info *mtd = mbd->mtd;
@@ -279,11 +287,7 @@
 	if ((mtdblk->mtd->flags & MTD_CAP_RAM) != MTD_CAP_RAM &&
 	    mtdblk->mtd->erasesize) {
 		mtdblk->cache_size = mtdblk->mtd->erasesize;
-		mtdblk->cache_data = vmalloc(mtdblk->mtd->erasesize);
-		if (!mtdblk->cache_data) {
-			kfree(mtdblk);
-			return -ENOMEM;
-		}
+		mtdblk->cache_data = NULL;
 	}
 
 	mtdblks[dev] = mtdblk;
@@ -293,17 +297,13 @@
 	return 0;
 }
 
-static int mtdblock_release(struct mtd_blktrans_dev *mbd,
-				  struct inode *inode, struct file *file)
+static int mtdblock_release(struct mtd_blktrans_dev *mbd)
 {
-	int dev;
-	struct mtdblk_dev *mtdblk;
+	int dev = mbd->devnum;
+	struct mtdblk_dev *mtdblk = mtdblks[dev];
 
    	DEBUG(MTD_DEBUG_LEVEL1, "mtdblock_release\n");
 
-	dev = minor(inode->i_rdev);
-	mtdblk = mtdblks[dev];
-
 	down(&mtdblk->cache_sem);
 	write_cached_data(mtdblk);
 	up(&mtdblk->cache_sem);
@@ -321,27 +321,17 @@
 	return 0;
 }  
 
-
-static int mtdblock_ioctl(struct mtd_blktrans_dev *dev, 
-			  struct inode * inode, struct file * file,
-			  unsigned int cmd, unsigned long arg)
+static int mtdblock_flush(struct mtd_blktrans_dev *dev)
 {
-	struct mtdblk_dev *mtdblk;
-
-	mtdblk = mtdblks[minor(inode->i_rdev)];
+	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
 
-	switch (cmd) {
-	case BLKFLSBUF:
-		down(&mtdblk->cache_sem);
-		write_cached_data(mtdblk);
-		up(&mtdblk->cache_sem);
-		if (mtdblk->mtd->sync)
-			mtdblk->mtd->sync(mtdblk->mtd);
-		return 0;
+	down(&mtdblk->cache_sem);
+	write_cached_data(mtdblk);
+	up(&mtdblk->cache_sem);
 
-	default:
-		return -ENOTTY;
-	}
+	if (mtdblk->mtd->sync)
+		mtdblk->mtd->sync(mtdblk->mtd);
+	return 0;
 }
 
 static void mtdblock_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
@@ -376,7 +366,7 @@
 	.major		= 31,
 	.part_bits	= 0,
 	.open		= mtdblock_open,
-	.ioctl		= mtdblock_ioctl,
+	.flush		= mtdblock_flush,
 	.release	= mtdblock_release,
 	.readsect	= mtdblock_readsect,
 	.writesect	= mtdblock_writesect,
diff -Nru a/drivers/mtd/mtdblock_ro.c b/drivers/mtd/mtdblock_ro.c
--- a/drivers/mtd/mtdblock_ro.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/mtdblock_ro.c	Fri Jun 27 22:41:17 2003
@@ -1,11 +1,12 @@
 /*
- * $Id: mtdblock_ro.c,v 1.17 2003/05/18 19:27:27 dwmw2 Exp $
+ * $Id: mtdblock_ro.c,v 1.18 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
  * Simple read-only (writable only for RAM) mtdblock driver
  */
 
+#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/blktrans.h>
diff -Nru a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
--- a/drivers/mtd/mtdpart.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/mtdpart.c	Fri Jun 27 22:41:17 2003
@@ -5,7 +5,7 @@
  *
  * This code is GPL
  *
- * $Id: mtdpart.c,v 1.39 2003/05/21 15:15:03 dwmw2 Exp $
+ * $Id: mtdpart.c,v 1.41 2003/06/18 14:53:02 dwmw2 Exp $
  *
  * 	02-21-2002	Thomas Gleixner <gleixner@autronix.de>
  *			added support for read_oob, write_oob
@@ -120,7 +120,7 @@
 			size_t *retlen, u_char *buf)
 {
 	struct mtd_part *part = PART(mtd);
-	return part->master->read_user_prot_reg (part->master, from, 
+	return part->master->read_fact_prot_reg (part->master, from, 
 					len, retlen, buf);
 }
 
diff -Nru a/drivers/mtd/nand/autcpu12.c b/drivers/mtd/nand/autcpu12.c
--- a/drivers/mtd/nand/autcpu12.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/nand/autcpu12.c	Fri Jun 27 22:41:17 2003
@@ -6,7 +6,7 @@
  *  Derived from drivers/mtd/spia.c
  * 	 Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 
- * $Id: autcpu12.c,v 1.10 2003/04/20 07:24:40 gleixner Exp $
+ * $Id: autcpu12.c,v 1.11 2003/06/04 17:04:09 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -28,6 +28,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/init.h>
 #include <linux/module.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
diff -Nru a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
--- a/drivers/mtd/nand/nand.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/mtd/nand/nand.c	Fri Jun 27 22:41:17 2003
@@ -124,9 +124,15 @@
  +		a structure, which will be supplied by a filesystem driver
  *		If NULL is given, then the defaults (none or defaults
  *		supplied by ioctl (MEMSETOOBSEL) are used.
- *		For partitions the partition defaults are used (mtdpart.c)		
+ *		For partitions the partition defaults are used (mtdpart.c)
+ *
+ *  06-04-2003  tglx: fix compile errors and fix write verify problem for
+ *		some chips, which need either a delay between the readback
+ *		and the next write command or have the CE removed. The
+ *		CE disable/enable is much faster than a 20us delay and
+ *		it should work on all available chips.
  *	
- * $Id: nand.c,v 1.45 2003/05/20 21:01:30 dwmw2 Exp $
+ * $Id: nand.c,v 1.46 2003/06/04 17:10:36 gleixner Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -141,6 +147,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/compatmac.h>
 #include <linux/interrupt.h>
 #include <asm/io.h>
 
@@ -510,6 +517,13 @@
 			}
 		}
 	}
+	/* 
+	 * Terminate the read command. This is faster than sending a reset command or 
+	 * applying a 20us delay before issuing the next programm sequence.
+	 * This is not a problem for all chips, but I have found a bunch of them.
+	 */
+	nand_deselect();
+	nand_select();
 #endif
 	return 0;
 }
diff -Nru a/drivers/mtd/nftlcore.c b/drivers/mtd/nftlcore.c
--- a/drivers/mtd/nftlcore.c	Fri Jun 27 22:41:16 2003
+++ b/drivers/mtd/nftlcore.c	Fri Jun 27 22:41:16 2003
@@ -1,7 +1,7 @@
 /* Linux driver for NAND Flash Translation Layer      */
 /* (c) 1999 Machine Vision Holdings, Inc.             */
 /* Author: David Woodhouse <dwmw2@infradead.org>      */
-/* $Id: nftlcore.c,v 1.92 2003/05/23 11:41:47 dwmw2 Exp $ */
+/* $Id: nftlcore.c,v 1.94 2003/06/23 12:00:08 dwmw2 Exp $ */
 
 /*
   The contents of this file are distributed under the GNU General
@@ -101,7 +101,7 @@
 			(long)nftl->sectors );
 	}
 
-	if (add_mtd_blktrans_dev) {
+	if (add_mtd_blktrans_dev(&nftl->mbd)) {
 		if (nftl->ReplUnitTable)
 			kfree(nftl->ReplUnitTable);
 		if (nftl->EUNtable)
@@ -699,29 +699,17 @@
 	return 0;
 }
 
-static int nftl_ioctl(struct mtd_blktrans_dev *dev,
-		     struct inode * inode, struct file * file, 
-		     unsigned int cmd, unsigned long arg)
+static int nftl_getgeo(struct mtd_blktrans_dev *dev,  struct hd_geometry *geo)
 {
 	struct NFTLrecord *nftl = (void *)dev;
 
-	switch (cmd) {
-	case HDIO_GETGEO: {
-		struct hd_geometry g;
-
-		g.heads = nftl->heads;
-		g.sectors = nftl->sectors;
-		g.cylinders = nftl->cylinders;
-		g.start = 0;
-		return copy_to_user((void *)arg, &g, sizeof g) ? -EFAULT : 0;
-	}
+	geo->heads = nftl->heads;
+	geo->sectors = nftl->sectors;
+	geo->cylinders = nftl->cylinders;
 
-	default:
-		return -ENOTTY;
-	}
+	return 0;
 }
 
-
 /****************************************************************************
  *
  * Module stuff
@@ -733,7 +721,7 @@
 	.name		= "nftl",
 	.major		= NFTL_MAJOR,
 	.part_bits	= NFTL_PARTN_BITS,
-	.ioctl		= nftl_ioctl,
+	.getgeo		= nftl_getgeo,
 	.readsect	= nftl_readblock,
 #ifdef CONFIG_NFTL_RW
 	.writesect	= nftl_writeblock,
@@ -747,7 +735,7 @@
 
 int __init init_nftl(void)
 {
-	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.92 $, nftlmount.c %s\n", nftlmountrev);
+	printk(KERN_INFO "NFTL driver: nftlcore.c $Revision: 1.94 $, nftlmount.c %s\n", nftlmountrev);
 
 	return register_mtd_blktrans(&nftl_tr);
 }
diff -Nru a/drivers/net/tulip/media.c b/drivers/net/tulip/media.c
--- a/drivers/net/tulip/media.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/net/tulip/media.c	Fri Jun 27 22:41:17 2003
@@ -278,6 +278,10 @@
 				for (i = 0; i < init_length; i++)
 					outl(init_sequence[i], ioaddr + CSR12);
 			}
+
+			(void) inl(ioaddr + CSR6); /* flush CSR12 writes */
+			udelay(500);		/* Give MII time to recover */
+
 			tmp_info = get_u16(&misc_info[1]);
 			if (tmp_info)
 				tp->advertising[phy_num] = tmp_info | 1;
diff -Nru a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
--- a/drivers/scsi/qla1280.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/scsi/qla1280.c	Fri Jun 27 22:41:17 2003
@@ -284,7 +284,7 @@
 #define  QL1280_TARGET_MODE_SUPPORT    0	/* Target mode support */
 #define  QL1280_LUN_SUPPORT            0
 #define  WATCHDOGTIMER                 0
-#define  MEMORY_MAPPED_IO              0
+#define  MEMORY_MAPPED_IO              1
 #define  DEBUG_QLA1280_INTR            0
 #define  USE_NVRAM_DEFAULTS	       0
 #define  DEBUG_PRINT_NVRAM             0
@@ -2491,7 +2491,7 @@
 	/*
 	 * Get memory mapped I/O address.
 	 */
-	pci_read_config_word (ha->pdev, PCI_BASE_ADDRESS_1, &mmapbase);
+	pci_read_config_dword (ha->pdev, PCI_BASE_ADDRESS_1, &mmapbase);
 	mmapbase &= PCI_BASE_ADDRESS_MEM_MASK;
 
 	/*
diff -Nru a/drivers/scsi/sym53c8xx_2/sym_glue.c b/drivers/scsi/sym53c8xx_2/sym_glue.c
--- a/drivers/scsi/sym53c8xx_2/sym_glue.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/scsi/sym53c8xx_2/sym_glue.c	Fri Jun 27 22:41:17 2003
@@ -295,11 +295,7 @@
 #ifndef SYM_LINUX_DYNAMIC_DMA_MAPPING
 typedef u_long		bus_addr_t;
 #else
-#if	SYM_CONF_DMA_ADDRESSING_MODE > 0
-typedef dma64_addr_t	bus_addr_t;
-#else
 typedef dma_addr_t	bus_addr_t;
-#endif
 #endif
 
 /*
diff -Nru a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
--- a/drivers/usb/host/ehci-hcd.c	Fri Jun 27 22:41:17 2003
+++ b/drivers/usb/host/ehci-hcd.c	Fri Jun 27 22:41:17 2003
@@ -974,7 +974,7 @@
 /* EHCI spec says PCI is required. */
 
 /* PCI driver selection metadata; PCI hotplugging uses this */
-static const struct pci_device_id __devinitdata pci_ids [] = { {
+static struct pci_device_id __devinitdata pci_ids [] = { {
 
 	/* handle any USB 2.0 EHCI controller */
 
diff -Nru a/fs/jffs2/dir.c b/fs/jffs2/dir.c
--- a/fs/jffs2/dir.c	Fri Jun 27 22:41:17 2003
+++ b/fs/jffs2/dir.c	Fri Jun 27 22:41:17 2003
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: dir.c,v 1.76 2003/05/26 09:50:38 dwmw2 Exp $
+ * $Id: dir.c,v 1.77 2003/06/05 14:42:24 dwmw2 Exp $
  *
  */
 
@@ -356,7 +356,7 @@
 	up(&f->sem);
 
 	/* Work out where to put the dirent node now. */
-	writtenlen = (writtenlen+3)&~3;
+	writtenlen = PAD(writtenlen);
 	phys_ofs += writtenlen;
 	alloclen -= writtenlen;
 
@@ -653,7 +653,7 @@
 	up(&f->sem);
 
 	/* Work out where to put the dirent node now. */
-	writtenlen = (writtenlen+3)&~3;
+	writtenlen = PAD(writtenlen);
 	phys_ofs += writtenlen;
 	alloclen -= writtenlen;
 
diff -Nru a/fs/jffs2/fs.c b/fs/jffs2/fs.c
--- a/fs/jffs2/fs.c	Fri Jun 27 22:41:17 2003
+++ b/fs/jffs2/fs.c	Fri Jun 27 22:41:17 2003
@@ -22,7 +22,7 @@
 #include <linux/vfs.h>
 #include "nodelist.h"
 
-int jffs2_statfs(struct super_block *sb, struct statfs *buf)
+int jffs2_statfs(struct super_block *sb, struct kstatfs *buf)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
 	unsigned long avail;
diff -Nru a/fs/jffs2/os-linux.h b/fs/jffs2/os-linux.h
--- a/fs/jffs2/os-linux.h	Fri Jun 27 22:41:16 2003
+++ b/fs/jffs2/os-linux.h	Fri Jun 27 22:41:16 2003
@@ -123,7 +123,7 @@
 #define jffs2_flash_write_oob(c, ofs, len, retlen, buf) ((c)->mtd->write_oob((c)->mtd, ofs, len, retlen, buf))
 #define jffs2_flash_read_oob(c, ofs, len, retlen, buf) ((c)->mtd->read_oob((c)->mtd, ofs, len, retlen, buf))
 
-struct statfs;
+struct kstatfs;
 
 /* wbuf.c */
 int jffs2_flash_writev(struct jffs2_sb_info *c, const struct iovec *vecs, unsigned long count, loff_t to, size_t *retlen);
@@ -169,7 +169,7 @@
 void jffs2_clear_inode (struct inode *);
 struct inode *jffs2_new_inode (struct inode *dir_i, int mode,
 			       struct jffs2_raw_inode *ri);
-int jffs2_statfs (struct super_block *, struct statfs *);
+int jffs2_statfs (struct super_block *, struct kstatfs *);
 void jffs2_write_super (struct super_block *);
 int jffs2_remount_fs (struct super_block *, int *, char *);
 int jffs2_do_fill_super(struct super_block *sb, void *data, int silent);
diff -Nru a/fs/jffs2/scan.c b/fs/jffs2/scan.c
--- a/fs/jffs2/scan.c	Fri Jun 27 22:41:17 2003
+++ b/fs/jffs2/scan.c	Fri Jun 27 22:41:17 2003
@@ -7,7 +7,7 @@
  *
  * For licensing information, see the file 'LICENCE' in this directory.
  *
- * $Id: scan.c,v 1.99 2003/04/28 10:17:17 dwmw2 Exp $
+ * $Id: scan.c,v 1.100 2003/06/05 14:42:24 dwmw2 Exp $
  *
  */
 #include <linux/kernel.h>
@@ -354,7 +354,7 @@
 
 		if (ofs & 3) {
 			printk(KERN_WARNING "Eep. ofs 0x%08x not word-aligned!\n", ofs);
-			ofs = (ofs+3)&~3;
+			ofs = PAD(ofs);
 			continue;
 		}
 		if (ofs == prevofs) {
diff -Nru a/include/asm-ia64/agp.h b/include/asm-ia64/agp.h
--- a/include/asm-ia64/agp.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-ia64/agp.h	Fri Jun 27 22:41:17 2003
@@ -4,7 +4,7 @@
 /*
  * IA-64 specific AGP definitions.
  *
- * Copyright (C) 2002 Hewlett-Packard Co
+ * Copyright (C) 2002-2003 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
@@ -17,8 +17,5 @@
 #define unmap_page_from_agp(page)	/* nothing */
 #define flush_agp_mappings()		/* nothing */
 #define flush_agp_cache()		mb()
-
-/* Page-protection value to be used for AGP memory mapped into kernel space.  */
-#define PAGE_AGP			PAGE_KERNEL
 
 #endif /* _ASM_IA64_AGP_H */
diff -Nru a/include/asm-ia64/hw_irq.h b/include/asm-ia64/hw_irq.h
--- a/include/asm-ia64/hw_irq.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-ia64/hw_irq.h	Fri Jun 27 22:41:17 2003
@@ -2,7 +2,7 @@
 #define _ASM_IA64_HW_IRQ_H
 
 /*
- * Copyright (C) 2001-2002 Hewlett-Packard Co
+ * Copyright (C) 2001-2003 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  */
 
@@ -91,10 +91,10 @@
  * Default implementations for the irq-descriptor API:
  */
 
-extern struct irq_desc _irq_desc[NR_IRQS];
+extern irq_desc_t _irq_desc[NR_IRQS];
 
 #ifndef CONFIG_IA64_GENERIC
-static inline struct irq_desc *
+static inline irq_desc_t *
 __ia64_irq_desc (unsigned int irq)
 {
 	return _irq_desc + irq;
@@ -124,8 +124,8 @@
  */
 
 /* Return a pointer to the irq descriptor for IRQ.  */
-static inline struct irq_desc *
-irq_desc (int irq)
+static inline irq_desc_t *
+irq_descp (int irq)
 {
 	return platform_irq_desc(irq);
 }
diff -Nru a/include/asm-ia64/thread_info.h b/include/asm-ia64/thread_info.h
--- a/include/asm-ia64/thread_info.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-ia64/thread_info.h	Fri Jun 27 22:41:17 2003
@@ -37,7 +37,6 @@
 	struct restart_block restart_block;
 };
 
-#define INIT_THREAD_SIZE		/* tell sched.h not to declare the thread_union */
 #define THREAD_SIZE			KERNEL_STACK_SIZE
 
 #define INIT_THREAD_INFO(tsk)			\
diff -Nru a/include/asm-ia64/timex.h b/include/asm-ia64/timex.h
--- a/include/asm-ia64/timex.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-ia64/timex.h	Fri Jun 27 22:41:17 2003
@@ -15,8 +15,15 @@
 typedef unsigned long cycles_t;
 
 /*
- * Something low processor frequency like 100Mhz but 
- * yet multiple of HZ to avoid truncation in some formulas.
+ * For performance reasons, we don't want to define CLOCK_TICK_TRATE as
+ * local_cpu_data->itc_rate.  Fortunately, we don't have to, either: according to George
+ * Anzinger, 1/CLOCK_TICK_RATE is taken as the resolution of the timer clock.  The time
+ * calculation assumes that you will use enough of these so that your tick size <= 1/HZ.
+ * If the calculation shows that your CLOCK_TICK_RATE can not supply exactly 1/HZ ticks,
+ * the actual value is calculated and used to update the wall clock each jiffie.  Setting
+ * the CLOCK_TICK_RATE to x*HZ insures that the calculation will find no errors.  Hence we
+ * pick a multiple of HZ which gives us a (totally virtual) CLOCK_TICK_RATE of about
+ * 100MHz.
  */
 #define CLOCK_TICK_RATE		(HZ * 100000UL)
 
diff -Nru a/include/asm-ia64/tlb.h b/include/asm-ia64/tlb.h
--- a/include/asm-ia64/tlb.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-ia64/tlb.h	Fri Jun 27 22:41:17 2003
@@ -39,6 +39,7 @@
  */
 #include <linux/config.h>
 #include <linux/mm.h>
+#include <linux/swap.h>
 
 #include <asm/processor.h>
 #include <asm/tlbflush.h>
diff -Nru a/include/asm-ia64/topology.h b/include/asm-ia64/topology.h
--- a/include/asm-ia64/topology.h	Fri Jun 27 22:41:16 2003
+++ b/include/asm-ia64/topology.h	Fri Jun 27 22:41:16 2003
@@ -28,11 +28,6 @@
  */
 #define node_to_cpumask(node) (node_to_cpu_mask[node])
 
-#else
-#define cpu_to_node(cpu) (0)
-#define node_to_cpumask(node) (phys_cpu_present_map)
-#endif
-
 /*
  * Returns the number of the node containing MemBlk 'memblk'
  */
@@ -64,5 +59,9 @@
 #define NODE_BALANCE_RATE 10
 
 void build_cpu_to_node_map(void);
+
+#endif /* CONFIG_NUMA */
+
+#include <asm-generic/topology.h>
 
 #endif /* _ASM_IA64_TOPOLOGY_H */
diff -Nru a/include/asm-sparc/unistd.h b/include/asm-sparc/unistd.h
--- a/include/asm-sparc/unistd.h	Fri Jun 27 22:41:16 2003
+++ b/include/asm-sparc/unistd.h	Fri Jun 27 22:41:16 2003
@@ -250,6 +250,8 @@
 #define __NR_time               231 /* Linux Specific                              */
 /* #define __NR_oldstat         232    Linux Specific                              */
 #define __NR_stime              233 /* Linux Specific                              */
+#define __NR_statfs64           234 /* Linux Specific                              */
+#define __NR_fstatfs64          235 /* Linux Specific                              */
 #define __NR__llseek            236 /* Linux Specific                              */
 #define __NR_mlock              237
 #define __NR_munlock            238
@@ -270,6 +272,11 @@
 #define __NR_fdatasync          253
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
+/* WARNING: You MAY NOT add syscall numbers larger than 255, since
+ *          all of the syscall tables in the Sparc kernel are
+ *          sized to have 256 entries (starting at zero).  Therefore
+ *          find a free slot in the 0-255 range.
+ */
 
 #define _syscall0(type,name) \
 type name(void) \
diff -Nru a/include/asm-sparc64/compat.h b/include/asm-sparc64/compat.h
--- a/include/asm-sparc64/compat.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-sparc64/compat.h	Fri Jun 27 22:41:17 2003
@@ -92,7 +92,8 @@
 	int		f_ffree;
 	compat_fsid_t	f_fsid;
 	int		f_namelen;	/* SunOS ignores this field. */
-	int		f_spare[6];
+	int		f_frsize;
+	int		f_spare[5];
 };
 
 #define COMPAT_RLIM_INFINITY 0x7fffffff
diff -Nru a/include/asm-sparc64/unistd.h b/include/asm-sparc64/unistd.h
--- a/include/asm-sparc64/unistd.h	Fri Jun 27 22:41:17 2003
+++ b/include/asm-sparc64/unistd.h	Fri Jun 27 22:41:17 2003
@@ -252,8 +252,8 @@
 #endif
 /* #define __NR_oldstat         232    Linux Specific                              */
 #define __NR_stime              233 /* Linux Specific                              */
-/* #define __NR_UNUSED          234 */
-/* #define __NR_UNUSED          235 */
+#define __NR_statfs64           234 /* Linux Specific                              */
+#define __NR_fstatfs64          235 /* Linux Specific                              */
 #define __NR__llseek            236 /* Linux Specific                              */
 #define __NR_mlock              237
 #define __NR_munlock            238
@@ -274,6 +274,11 @@
 #define __NR_fdatasync          253
 #define __NR_nfsservctl         254
 #define __NR_aplib              255
+/* WARNING: You MAY NOT add syscall numbers larger than 255, since
+ *          all of the syscall tables in the Sparc64 kernel are
+ *          sized to have 256 entries (starting at zero).  Therefore
+ *          find a free slot in the 0-255 range.
+ */
 
 #define _syscall0(type,name) \
 type name(void) \
diff -Nru a/include/linux/irq.h b/include/linux/irq.h
--- a/include/linux/irq.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/irq.h	Fri Jun 27 22:41:17 2003
@@ -56,7 +56,7 @@
  *
  * Pad this out to 32 bytes for cache and indexing reasons.
  */
-typedef struct {
+typedef struct irq_desc {
 	unsigned int status;		/* IRQ status */
 	hw_irq_controller *handler;
 	struct irqaction *action;	/* IRQ action list */
@@ -66,7 +66,9 @@
 	spinlock_t lock;
 } ____cacheline_aligned irq_desc_t;
 
+#ifndef CONFIG_IA64
 extern irq_desc_t irq_desc [NR_IRQS];
+#endif
 
 #include <asm/hw_irq.h> /* the arch dependent stuff */
 
diff -Nru a/include/linux/loop.h b/include/linux/loop.h
--- a/include/linux/loop.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/loop.h	Fri Jun 27 22:41:17 2003
@@ -14,6 +14,9 @@
 #define LO_KEY_SIZE	32
 
 #ifdef __KERNEL__
+#include <linux/bio.h>
+#include <linux/blk.h>
+#include <linux/spinlock.h>
 
 /* Possible states of device */
 enum {
@@ -22,18 +25,20 @@
 	Lo_rundown,
 };
 
+struct loop_func_table;
+
 struct loop_device {
 	int		lo_number;
 	int		lo_refcnt;
 	int		lo_offset;
-	int		lo_encrypt_type;
-	int		lo_encrypt_key_size;
 	int		lo_flags;
 	int		(*transfer)(struct loop_device *, int cmd,
 				    char *raw_buf, char *loop_buf, int size,
 				    sector_t real_block);
 	char		lo_name[LO_NAME_SIZE];
 	char		lo_encrypt_key[LO_KEY_SIZE];
+	int		lo_encrypt_key_size;
+	struct loop_func_table *lo_encryption;
 	__u32           lo_init[2];
 	uid_t		lo_key_owner;	/* Who set the key */
 	int		(*ioctl)(struct loop_device *, int cmd, 
@@ -129,9 +134,7 @@
 	/* release is called from loop_unregister_transfer or clr_fd */
 	int (*release)(struct loop_device *); 
 	int (*ioctl)(struct loop_device *, int cmd, unsigned long arg);
-	/* lock and unlock manage the module use counts */ 
-	void (*lock)(struct loop_device *);
-	void (*unlock)(struct loop_device *);
+	struct module *owner;
 }; 
 
 int loop_register_transfer(struct loop_func_table *funcs);
diff -Nru a/include/linux/mtd/blktrans.h b/include/linux/mtd/blktrans.h
--- a/include/linux/mtd/blktrans.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/mtd/blktrans.h	Fri Jun 27 22:41:17 2003
@@ -1,5 +1,5 @@
 /*
- * $Id: blktrans.h,v 1.4 2003/05/21 01:01:32 dwmw2 Exp $
+ * $Id: blktrans.h,v 1.5 2003/06/23 12:00:08 dwmw2 Exp $
  *
  * (C) 2003 David Woodhouse <dwmw2@infradead.org>
  *
@@ -12,6 +12,7 @@
 
 #include <asm/semaphore.h>
 
+struct hd_geometry;
 struct mtd_info;
 struct mtd_blktrans_ops;
 struct file;
@@ -42,17 +43,13 @@
 	int (*writesect)(struct mtd_blktrans_dev *dev,
 		     unsigned long block, char *buffer);
 
-	/* HDIO_GETGEO and HDIO_GETGEO_BIG are the only non-private
-	   ioctls which are expected to be passed through */
-	int (*ioctl)(struct mtd_blktrans_dev *dev,
-		     struct inode * inode, struct file * file, 
-		     unsigned int cmd, unsigned long arg);
+	/* Block layer ioctls */
+	int (*getgeo)(struct mtd_blktrans_dev *dev, struct hd_geometry *geo);
+	int (*flush)(struct mtd_blktrans_dev *dev);
 
 	/* Called with mtd_table_mutex held; no race with add/remove */
-	int (*open)(struct mtd_blktrans_dev *dev, 
-		 struct inode *i, struct file *f);
-	int (*release)(struct mtd_blktrans_dev *dev,
-		    struct inode *i, struct file *f);
+	int (*open)(struct mtd_blktrans_dev *dev);
+	int (*release)(struct mtd_blktrans_dev *dev);
 
 	/* Called on {de,}registration and on subsequent addition/removal
 	   of devices, with mtd_table_mutex held. */
diff -Nru a/include/linux/mtd/doc2000.h b/include/linux/mtd/doc2000.h
--- a/include/linux/mtd/doc2000.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/mtd/doc2000.h	Fri Jun 27 22:41:17 2003
@@ -2,7 +2,7 @@
 /* Linux driver for Disk-On-Chip 2000       */
 /* (c) 1999 Machine Vision Holdings, Inc.   */
 /* Author: David Woodhouse <dwmw2@mvhi.com> */
-/* $Id: doc2000.h,v 1.16 2003/05/23 11:29:33 dwmw2 Exp $ */
+/* $Id: doc2000.h,v 1.17 2003/06/12 01:20:46 gerg Exp $ */
 
 #ifndef __MTD_DOC2000_H__
 #define __MTD_DOC2000_H__
@@ -44,7 +44,7 @@
 #define DoC_Mplus_AccessStatus		0x1008
 #define DoC_Mplus_DeviceSelect		0x1008
 #define DoC_Mplus_Configuration		0x100a
-#define DoC_Mplus_OutputControl		0x1002
+#define DoC_Mplus_OutputControl		0x100c
 #define DoC_Mplus_FlashControl		0x1020
 #define DoC_Mplus_FlashSelect 		0x1022
 #define DoC_Mplus_FlashCmd		0x1024
diff -Nru a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
--- a/include/linux/nfs_fs.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/nfs_fs.h	Fri Jun 27 22:41:17 2003
@@ -408,7 +408,7 @@
 nfs_size_to_loff_t(__u64 size)
 {
 	loff_t maxsz = (((loff_t) ULONG_MAX) << PAGE_CACHE_SHIFT) + PAGE_CACHE_SIZE - 1;
-	if (size > maxsz)
+	if (size > (__u64) maxsz)
 		return maxsz;
 	return (loff_t) size;
 }
diff -Nru a/include/linux/sched.h b/include/linux/sched.h
--- a/include/linux/sched.h	Fri Jun 27 22:41:16 2003
+++ b/include/linux/sched.h	Fri Jun 27 22:41:16 2003
@@ -512,9 +512,10 @@
  */
 extern struct exec_domain	default_exec_domain;
 
-#ifndef INIT_THREAD_SIZE
-# define INIT_THREAD_SIZE	2048*sizeof(long)
-#endif
+#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR
+# ifndef INIT_THREAD_SIZE
+#  define INIT_THREAD_SIZE	2048*sizeof(long)
+# endif
 
 union thread_union {
 	struct thread_info thread_info;
@@ -522,6 +523,9 @@
 };
 
 extern union thread_union init_thread_union;
+
+#endif /* !__HAVE_ARCH_TASK_STRUCT_ALLOCATOR */
+
 extern struct task_struct init_task;
 
 extern struct   mm_struct init_mm;
diff -Nru a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.h
--- a/include/linux/sunrpc/svc.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/sunrpc/svc.h	Fri Jun 27 22:41:17 2003
@@ -73,7 +73,7 @@
  * This assumes that the non-page part of an rpc reply will fit
  * in a page - NFSd ensures this.  lockd also has no trouble.
  */
-#define RPCSVC_MAXPAGES		((RPCSVC_MAXPAYLOAD+PAGE_SIZE-1)/PAGE_SIZE + 1)
+#define RPCSVC_MAXPAGES		((RPCSVC_MAXPAYLOAD+PAGE_SIZE-1)/PAGE_SIZE + 2)
 
 static inline u32 svc_getu32(struct iovec *iov)
 {
diff -Nru a/include/linux/sysctl.h b/include/linux/sysctl.h
--- a/include/linux/sysctl.h	Fri Jun 27 22:41:17 2003
+++ b/include/linux/sysctl.h	Fri Jun 27 22:41:17 2003
@@ -130,6 +130,7 @@
 	KERN_PIDMAX=55,		/* int: PID # limit */
   	KERN_CORE_PATTERN=56,	/* string: pattern for core-file names */
 	KERN_PANIC_ON_OOPS=57,  /* int: whether we will panic on an oops */
+	KERN_CACHEDECAYTICKS=58, /* ulong: value for cache_decay_ticks (EXPERIMENTAL!) */
 };
 
 
diff -Nru a/kernel/printk.c b/kernel/printk.c
--- a/kernel/printk.c	Fri Jun 27 22:41:17 2003
+++ b/kernel/printk.c	Fri Jun 27 22:41:17 2003
@@ -308,6 +308,12 @@
 			__call_console_drivers(start, end);
 		}
 	}
+#ifdef CONFIG_IA64_EARLY_PRINTK
+	if (!console_drivers) {
+		void early_printk (const char *str, size_t len);
+		early_printk(&LOG_BUF(start), end - start);
+	}
+#endif
 }
 
 /*
@@ -625,7 +631,11 @@
 		 * for us.
 		 */
 		spin_lock_irqsave(&logbuf_lock, flags);
+#ifdef CONFIG_IA64_EARLY_PRINTK
+		con_start = log_end;
+#else
 		con_start = log_start;
+#endif
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 	}
 	release_console_sem();
@@ -678,3 +688,117 @@
 		tty->driver->write(tty, 0, msg, strlen(msg));
 	return;
 }
+
+#ifdef CONFIG_IA64_EARLY_PRINTK
+
+#include <asm/io.h>
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+
+
+#define VGABASE		((char *)0xc0000000000b8000)
+#define VGALINES	24
+#define VGACOLS		80
+
+static int current_ypos = VGALINES, current_xpos = 0;
+
+static void
+early_printk_vga (const char *str, size_t len)
+{
+	char c;
+	int  i, k, j;
+
+	while (len-- > 0) {
+		c = *str++;
+		if (current_ypos >= VGALINES) {
+			/* scroll 1 line up */
+			for (k = 1, j = 0; k < VGALINES; k++, j++) {
+				for (i = 0; i < VGACOLS; i++) {
+					writew(readw(VGABASE + 2*(VGACOLS*k + i)),
+					       VGABASE + 2*(VGACOLS*j + i));
+				}
+			}
+			for (i = 0; i < VGACOLS; i++) {
+				writew(0x720, VGABASE + 2*(VGACOLS*j + i));
+			}
+			current_ypos = VGALINES-1;
+		}
+		if (c == '\n') {
+			current_xpos = 0;
+			current_ypos++;
+		} else if (c != '\r')  {
+			writew(((0x7 << 8) | (unsigned short) c),
+			       VGABASE + 2*(VGACOLS*current_ypos + current_xpos++));
+			if (current_xpos >= VGACOLS) {
+				current_xpos = 0;
+				current_ypos++;
+			}
+		}
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_VGA */
+
+# ifdef CONFIG_IA64_EARLY_PRINTK_UART
+
+#include <linux/serial_reg.h>
+#include <asm/system.h>
+
+static void early_printk_uart(const char *str, size_t len)
+{
+	static char *uart = NULL;
+	unsigned long uart_base;
+	char c;
+
+	if (!uart) {
+		uart_base = 0;
+#  ifdef CONFIG_SERIAL_8250_HCDP
+		{
+			extern unsigned long hcdp_early_uart(void);
+			uart_base = hcdp_early_uart();
+		}
+#  endif
+#  if CONFIG_IA64_EARLY_PRINTK_UART_BASE
+		if (!uart_base)
+			uart_base = CONFIG_IA64_EARLY_PRINTK_UART_BASE;
+#  endif
+		if (!uart_base)
+			return;
+
+		uart = ioremap(uart_base, 64);
+		if (!uart)
+			return;
+	}
+
+	while (len-- > 0) {
+		c = *str++;
+		while ((readb(uart + UART_LSR) & UART_LSR_TEMT) == 0)
+			cpu_relax(); /* spin */
+
+		writeb(c, uart + UART_TX);
+
+		if (c == '\n')
+			writeb('\r', uart + UART_TX);
+	}
+}
+
+# endif /* CONFIG_IA64_EARLY_PRINTK_UART */
+
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+extern int sn_sal_console_out(const char *str, int len);
+#endif
+
+void early_printk(const char *str, size_t len)
+{
+#ifdef CONFIG_IA64_EARLY_PRINTK_UART
+	early_printk_uart(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_VGA
+	early_printk_vga(str, len);
+#endif
+#ifdef CONFIG_IA64_EARLY_PRINTK_SGI_SN
+ 	sn_sal_console_out(str, len);
+#endif
+}
+
+#endif /* CONFIG_IA64_EARLY_PRINTK */
diff -Nru a/kernel/sys.c b/kernel/sys.c
--- a/kernel/sys.c	Fri Jun 27 22:41:16 2003
+++ b/kernel/sys.c	Fri Jun 27 22:41:16 2003
@@ -1219,7 +1219,7 @@
 			? -EFAULT : 0;
 }
 
-#if !defined(__ia64__) && !defined(CONFIG_V850)
+#if (!defined(__ia64__) && !defined(CONFIG_V850)) || defined(CONFIG_COMPAT)
 
 /*
  *	Back compatibility for getrlimit. Needed for some apps.
diff -Nru a/kernel/sysctl.c b/kernel/sysctl.c
--- a/kernel/sysctl.c	Fri Jun 27 22:41:16 2003
+++ b/kernel/sysctl.c	Fri Jun 27 22:41:16 2003
@@ -551,6 +551,16 @@
 		.mode		= 0644,
 		.proc_handler	= &proc_dointvec,
 	},
+#ifdef CONFIG_SMP
+	{
+		.ctl_name	= KERN_CACHEDECAYTICKS,
+		.procname	= "cache_decay_ticks",
+		.data		= &cache_decay_ticks,
+		.maxlen		= sizeof(cache_decay_ticks),
+		.mode		= 0644,
+		.proc_handler	= &proc_doulongvec_minmax,
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
diff -Nru a/kernel/workqueue.c b/kernel/workqueue.c
--- a/kernel/workqueue.c	Fri Jun 27 22:41:17 2003
+++ b/kernel/workqueue.c	Fri Jun 27 22:41:17 2003
@@ -275,6 +275,7 @@
 	INIT_LIST_HEAD(&cwq->worklist);
 	init_waitqueue_head(&cwq->more_work);
 	init_waitqueue_head(&cwq->work_done);
+	init_completion(&cwq->exit);
 
 	init_completion(&startup.done);
 	startup.cwq = cwq;
@@ -320,10 +321,7 @@
 
 	cwq = wq->cpu_wq + cpu;
 	if (cwq->thread) {
-		printk("Cleaning up workqueue thread for %i\n", cpu);
-		/* Initiate an exit and wait for it: */
-		init_completion(&cwq->exit);
-		wmb(); /* Thread must see !cwq->thread after completion init */
+		/* Tell thread to exit and wait for it. */
 		cwq->thread = NULL;
 		wake_up(&cwq->more_work);
 
diff -Nru a/mm/memory.c b/mm/memory.c
--- a/mm/memory.c	Fri Jun 27 22:41:17 2003
+++ b/mm/memory.c	Fri Jun 27 22:41:17 2003
@@ -114,8 +114,10 @@
 	}
 	pmd = pmd_offset(dir, 0);
 	pgd_clear(dir);
-	for (j = 0; j < PTRS_PER_PMD ; j++)
+	for (j = 0; j < PTRS_PER_PMD ; j++) {
+		prefetchw(pmd + j + PREFETCH_STRIDE/sizeof(*pmd));
 		free_one_pmd(tlb, pmd+j);
+	}
 	pmd_free_tlb(tlb, pmd);
 }
 
diff -Nru a/usr/Makefile b/usr/Makefile
--- a/usr/Makefile	Fri Jun 27 22:41:17 2003
+++ b/usr/Makefile	Fri Jun 27 22:41:17 2003
@@ -5,11 +5,9 @@
 
 clean-files := initramfs_data.cpio.gz
 
-LDFLAGS_initramfs_data.o := $(LDFLAGS_BLOB) -r -T
-
-$(obj)/initramfs_data.o: $(src)/initramfs_data.scr \
-			 $(obj)/initramfs_data.cpio.gz FORCE
-	$(call if_changed,ld)
+$(obj)/initramfs_data.S: $(obj)/initramfs_data.cpio.gz
+	echo '.section ".init.ramfs", "a"' > $@
+	od -v -An -t x1 -w8 $^ | cut -c2- | sed -e s"/ /,0x/g" -e s"/^/.byte 0x"/ >> $@
 
 # initramfs-y are the programs which will be copied into the CPIO
 # archive. Currently, the filenames are hardcoded in gen_init_cpio,

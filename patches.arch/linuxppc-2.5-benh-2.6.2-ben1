diff -purN /dev/shm/linux-2.5/TODO linuxppc-2.5-benh/TODO
--- /dev/shm/linux-2.5/TODO	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/TODO	2003-12-18 05:22:24.000000000 +0000
@@ -0,0 +1,61 @@
+(*=done, not submited)
+
+- fbdev: use a new activate flag to tell drivers to apply a mode even if it didn't
+  change. Call set_var() with this flag when switching from KD_GRAPHICS back to
+  text mode. That should fix most of the problems of apps banging the HW and
+  leaving it in an incorrect state. (XFree still should be shot for banging the
+  HW on exit when it's not the front VT)
+
+* fbdev: add a couple of routines to suspend/resume display on a framebuffer.
+  Resume will additionally restore the screen. To be called by the drivers when
+  they are power managed
+
+- fbdev: make fbset work properly again ! stty isn't a solution for lots of
+  cases (supposedly done in jsimmons tree)
+
+- look at scsi P.M (hrm....)
+
+- get rid of "pre-parsed" fields in the device-tree. Everything should come
+  from properties. PCI drivers don't need addr parsing, mac-io based drivers
+  can parse "reg" (or it can be done by macio_asic and stored as resources),
+  etc... As far as interrupts are concerned, I need to think about it, we
+  shall either have an helper that walks the interrupt tree to get the
+  vector, or we still do a one-time parsing and store those in linux,irq
+  properties. The later is probably better at first.
+  We probably also want to factor the strings in the device tree memory
+  representation when building it from OF.
+  -> partially done, macio drivers now have resource management
+
+* figure out breakage of release_OF_resource on macio devices (probably
+  getting to the wrong resource)
+
+- Implement DMA api instead of using generic stuff
+
+- Move more of arch/ppc/platforms/pmac* to drivers/macintosh. I want to
+  rework the way "features" are done, but I still can't find a new design
+  that would please me while not copying what Apple did in darwin ...
+  I probably want to split that file in per-chipset files (gc, ohare,
+  heathrow/paddington, keylargo, uninorth, etc...) though the way those
+  would "advertise" their routines still need to be defined. What about
+  hooking function pointers to the device-tree ?
+
+- Use device-tree values to fill the PCI latency setting and add fixups
+  for the values of uninorth devices like darwin does
+
+- Rework swim3 using BIO properly, dealing with hotswap (should be rmmod'able
+  as well), and including paulus latest fixes. Also adapt it to new model
+
+- Port ADB to new driver model, add various settings (trackpad tap, kbd Fn
+  key behaviour etc...) to sysfs attribute files
+
+- Add PHY layer & ethtool support to bmac driver
+
+- G5 sound drivers (probably want a complete rewrite of dmasound if we decide
+  to keep that driver around, or just base on Alsa)
+
+- While we are at sound: proper refcounting of KeyLargo clocks for better PM
+  and separate I2S channel configuration
+
+- Rework PPC arch whole interrupt management to finally deal with cascaded
+  controllers properly, also get rid of the linar irq_desc array
+
diff -purN /dev/shm/linux-2.5/arch/ppc/Kconfig linuxppc-2.5-benh/arch/ppc/Kconfig
--- /dev/shm/linux-2.5/arch/ppc/Kconfig	2004-02-04 05:28:10.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/Kconfig	2004-02-05 10:07:31.000000000 +0000
@@ -30,6 +30,10 @@ config PPC32
 	bool
 	default y
 
+# All PPCs use generic nvram driver through ppc_md
+config GENERIC_NVRAM
+	bool
+	default y
 
 source "init/Kconfig"
 
@@ -588,6 +592,11 @@ config PPC_PMAC
 	depends on PPC_MULTIPLATFORM
 	default y
 
+config PPC_PMAC64
+	bool
+	depends on PPC_PMAC && POWER4
+	default y
+
 config PPC_PREP
 	bool
 	depends on PPC_MULTIPLATFORM
@@ -989,8 +998,6 @@ config HOTPLUG
 
 source "drivers/pcmcia/Kconfig"
 
-source "drivers/parport/Kconfig"
-
 endmenu
 
 menu "Advanced setup"
@@ -1088,179 +1095,10 @@ config PIN_TLB
 	depends on ADVANCED_OPTIONS && 8xx
 endmenu
 
-source "drivers/base/Kconfig"
-
-source "drivers/mtd/Kconfig"
-
-source "drivers/pnp/Kconfig"
-
-source "drivers/block/Kconfig"
-
-source "drivers/md/Kconfig"
-
-source "drivers/ide/Kconfig"
-
-source "drivers/scsi/Kconfig"
-
-source "drivers/message/fusion/Kconfig"
-
-source "drivers/ieee1394/Kconfig"
-
-source "drivers/message/i2o/Kconfig"
-
-source "net/Kconfig"
-
-source "drivers/isdn/Kconfig"
-
-source "drivers/video/Kconfig"
-
-source "drivers/cdrom/Kconfig"
-
-source "drivers/input/Kconfig"
-
-
-menu "Macintosh device drivers"
-
-# we want to change this to something like CONFIG_SYSCTRL_CUDA/PMU
-config ADB_CUDA
-	bool "Support for CUDA based PowerMacs"
-	depends on PPC_PMAC
-	help
-	  This provides support for CUDA based Power Macintosh systems.  This
-	  includes most OldWorld PowerMacs, the first generation iMacs, the
-	  Blue&White G3 and the "Yikes" G4 (PCI Graphics).  All later models
-	  should use CONFIG_ADB_PMU instead.  It is safe to say Y here even if
-	  your machine doesn't have a CUDA.
-
-	  If unsure say Y.
-
-config ADB_PMU
-	bool "Support for PMU  based PowerMacs"
-	depends on PPC_PMAC
-	help
-	  On PowerBooks, iBooks, and recent iMacs and Power Macintoshes, the
-	  PMU is an embedded microprocessor whose primary function is to
-	  control system power, and battery charging on the portable models.
-	  The PMU also controls the ADB (Apple Desktop Bus) which connects to
-	  the keyboard and mouse on some machines, as well as the non-volatile
-	  RAM and the RTC (real time clock) chip.  Say Y to enable support for
-	  this device; you should do so if your machine is one of those
-	  mentioned above.
-
-config PMAC_PBOOK
-	bool "Power management support for PowerBooks"
-	depends on ADB_PMU
-	---help---
-	  This provides support for putting a PowerBook to sleep; it also
-	  enables media bay support.  Power management works on the
-	  PB2400/3400/3500, Wallstreet, Lombard, and Bronze PowerBook G3 and
-	  the Titanium Powerbook G4, as well as the iBooks.  You should get
-	  the power management daemon, pmud, to make it work and you must have
-	  the /dev/pmu device (see the pmud README).
-
-	  Get pmud from <ftp://ftp.samba.org/pub/ppclinux/pmud/>.
-
-	  If you have a PowerBook, you should say Y here.
-
-	  You may also want to compile the dma sound driver as a module and
-	  have it autoloaded. The act of removing the module shuts down the
-	  sound hardware for more power savings.
-
-config PM
-	bool
-	depends on PPC_PMAC && ADB_PMU && PMAC_PBOOK
-	default y
-
-config PMAC_APM_EMU
-	tristate "APM emulation"
-	depends on PMAC_PBOOK
-
-# made a separate option since backlight may end up beeing used
-# on non-powerbook machines (but only on PMU based ones AFAIK)
-config PMAC_BACKLIGHT
-	bool "Backlight control for LCD screens"
-	depends on ADB_PMU
-	help
-	  Say Y here to build in code to manage the LCD backlight on a
-	  Macintosh PowerBook.  With this code, the backlight will be turned
-	  on and off appropriately on power-management and lid-open/lid-closed
-	  events; also, the PowerBook button device will be enabled so you can
-	  change the screen brightness.
-
-config MAC_FLOPPY
-	bool "Support for PowerMac floppy"
-	depends on PPC_PMAC
-	help
-	  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)
-	  floppy controller, say Y here. Most commonly found in PowerMacs.
-
-config MAC_SERIAL
-	tristate "Support for PowerMac serial ports (OBSOLETE DRIVER)"
-	depends on PPC_PMAC
-	help
-	  This driver is obsolete. Use CONFIG_SERIAL_PMACZILOG in
-	  "Character devices --> Serial drivers --> PowerMac z85c30" option.
-
-config ADB
-	bool "Apple Desktop Bus (ADB) support"
-	depends on PPC_PMAC
-	help
-	  Apple Desktop Bus (ADB) support is for support of devices which
-	  are connected to an ADB port.  ADB devices tend to have 4 pins.
-	  If you have an Apple Macintosh prior to the iMac, an iBook or
-	  PowerBook, or a "Blue and White G3", you probably want to say Y
-	  here.  Otherwise say N.
-
-config ADB_MACIO
-	bool "Include MacIO (CHRP) ADB driver"
-	depends on ADB
-	help
-	  Say Y here to include direct support for the ADB controller in the
-	  Hydra chip used on PowerPC Macintoshes of the CHRP type.  (The Hydra
-	  also includes a MESH II SCSI controller, DBDMA controller, VIA chip,
-	  OpenPIC controller and two RS422/Geoports.)
-
-config INPUT_ADBHID
-	bool "Support for ADB input devices (keyboard, mice, ...)"
-	depends on ADB && INPUT=y
-	help
-	  Say Y here if you want to have ADB (Apple Desktop Bus) HID devices
-	  such as keyboards, mice, joysticks, trackpads  or graphic tablets
-	  handled by the input layer.  If you say Y here, make sure to say Y to
-	  the corresponding drivers "Keyboard support" (CONFIG_INPUT_KEYBDEV),
-	  "Mouse Support" (CONFIG_INPUT_MOUSEDEV) and "Event interface
-	  support" (CONFIG_INPUT_EVDEV) as well.
-
-	  If unsure, say Y.
-
-config MAC_EMUMOUSEBTN
-	bool "Support for mouse button 2+3 emulation"
-	depends on INPUT_ADBHID
-	help
-	  This provides generic support for emulating the 2nd and 3rd mouse
-	  button with keypresses.  If you say Y here, the emulation is still
-	  disabled by default.  The emulation is controlled by these sysctl
-	  entries:
-	  /proc/sys/dev/mac_hid/mouse_button_emulation
-	  /proc/sys/dev/mac_hid/mouse_button2_keycode
-	  /proc/sys/dev/mac_hid/mouse_button3_keycode
-
-	  If you have an Apple machine with a 1-button mouse, say Y here.
-
-config ANSLCD
-	bool "Support for ANS LCD display"
-	depends on ADB_CUDA
-
-endmenu
-
-source "drivers/char/Kconfig"
-
-source "drivers/media/Kconfig"
+source "drivers/Kconfig"
 
 source "fs/Kconfig"
 
-source "sound/Kconfig"
-
 source "arch/ppc/8xx_io/Kconfig"
 
 source "arch/ppc/8260_io/Kconfig"
@@ -1285,10 +1123,9 @@ config SERIAL_SICC_CONSOLE
 
 endmenu
 
-source "drivers/usb/Kconfig"
-
 source "lib/Kconfig"
 
+source "arch/ppc/oprofile/Kconfig"
 
 menu "Kernel hacking"
 
@@ -1377,6 +1214,10 @@ config XMON
 	  Include in-kernel hooks for the xmon kernel monitor/debugger.
 	  Unless you are intending to debug the kernel, say N here.
 
+config XMON_FW
+	bool "xmon over firewire support"
+	depends on XMON
+
 config BDI_SWITCH
 	bool "Include BDI-2000 user context switcher"
 	depends on DEBUG_KERNEL
diff -purN /dev/shm/linux-2.5/arch/ppc/Makefile linuxppc-2.5-benh/arch/ppc/Makefile
--- /dev/shm/linux-2.5/arch/ppc/Makefile	2003-10-08 21:39:31.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/Makefile	2003-12-31 02:50:43.000000000 +0000
@@ -44,6 +44,7 @@ drivers-$(CONFIG_8xx)		+= arch/ppc/8xx_i
 drivers-$(CONFIG_4xx)		+= arch/ppc/4xx_io/
 drivers-$(CONFIG_8260)		+= arch/ppc/8260_io/
 drivers-$(CONFIG_OCP)		+= arch/ppc/ocp/
+drivers-$(CONFIG_OPROFILE)	+= arch/ppc/oprofile/
 
 BOOT_TARGETS = zImage zImage.initrd znetboot znetboot.initrd vmlinux.sm
 
diff -purN /dev/shm/linux-2.5/arch/ppc/boot/of1275/claim.c linuxppc-2.5-benh/arch/ppc/boot/of1275/claim.c
--- /dev/shm/linux-2.5/arch/ppc/boot/of1275/claim.c	2002-09-17 05:18:12.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/boot/of1275/claim.c	2003-08-25 17:36:14.000000000 +0000
@@ -10,6 +10,7 @@
 
 #include "of1275.h"
 
+
 void *
 claim(unsigned int virt, unsigned int size, unsigned int align)
 {
diff -purN /dev/shm/linux-2.5/arch/ppc/boot/simple/embed_config.c linuxppc-2.5-benh/arch/ppc/boot/simple/embed_config.c
--- /dev/shm/linux-2.5/arch/ppc/boot/simple/embed_config.c	2004-01-31 08:15:24.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/boot/simple/embed_config.c	2004-02-02 02:29:27.000000000 +0000
@@ -667,6 +667,20 @@ embed_config(bd_t **bdp)
 #endif /* WILLOW */
 
 #ifdef CONFIG_XILINX_ML300
+/* SAATODO: Remove this when CONFIG_XILINX_ML300_MACADDR is removed. */
+static int
+char2dec(char c)
+{
+	if ('0' <= c && c <= '9')
+		return c - '0';
+	else if ('a' <= c && c <= 'f')
+		return c - 'a' + 10;
+	else if ('A' <= c && c <= 'F')
+		return c - 'A' + 10;
+	else
+		return -1;
+}
+
 void
 embed_config(bd_t ** bdp)
 {
@@ -699,6 +713,36 @@ embed_config(bd_t ** bdp)
 	bd->bi_memsize = XPAR_DDR_0_SIZE;
 	bd->bi_intfreq = XPAR_CORE_CLOCK_FREQ_HZ;
 	bd->bi_busfreq = XPAR_PLB_CLOCK_FREQ_HZ;
+
+	/* SAATODO: Use board's MAC address once that is defined. */
+	if (1) {
+		char MAC_string[] = CONFIG_XILINX_ML300_MACADDR;
+		int good_addr = 1;
+
+		if (sizeof (MAC_string) != 13)
+			good_addr = 0;
+		else {
+			char *s = MAC_string;
+			cp = bd->bi_enetaddr;
+
+			while (s < MAC_string + 12) {
+				int msn, lsn;
+				msn = char2dec(*s++);
+				lsn = char2dec(*s++);
+				if (msn < 0 || lsn < 0) {
+					good_addr = 0;
+					break;
+				}
+				*cp++ = msn << 4 | lsn;
+			}
+		}
+		if (!good_addr) {
+			cp = (u_char *) def_enet_addr;
+			for (i = 0; i < 6; i++) {
+				bd->bi_enetaddr[i] = *cp++;
+			}
+		}
+	}
 }
 #endif /* CONFIG_XILINX_ML300 */
 
@@ -784,6 +828,52 @@ embed_config(bd_t **bdp)
 #endif /* CONFIG_BEECH */
 #endif /* CONFIG_IBM_OPENBIOS */
 
+#ifdef CONFIG_ARCTIC2
+/* Several bootloaders have been used on the Arctic.  We assume either
+ * SSX or PIBS */
+
+#define SSX_BIOS_ADDR 		0xFFFF0000
+#define SSX_BIOS_GET_BOARD_INFO 0
+#define	PIBS_BOARD_INFO_VECTOR	0xFFF62004
+
+struct ssx_bios_id {
+	unsigned int boot_branch;	/* Branch to bootcode */
+	char ssx_bios[8];		/* "SSX BIOS" (no \0) */
+	void (*bios_entry_point)(unsigned int, bd_t *); /* Call bios_entry_point(cmd, &data) */
+};
+
+extern int memcmp(const void *s1, const void *s2, size_t n);
+
+static void get_board_info(bd_t **bdp)
+{
+	struct ssx_bios_id *ssx = (struct ssx_bios_id *)SSX_BIOS_ADDR;
+
+	/* Check for SSX signature */
+
+	if (memcmp(&ssx->ssx_bios, "SSX BIOS", 8) == 0) {
+		ssx->bios_entry_point(SSX_BIOS_GET_BOARD_INFO, *bdp);
+	} else {
+		/* It's not SSX, so assume PIBS */
+		typedef void (*PFV)(bd_t *bd);
+		((PFV)(*(unsigned long *)PIBS_BOARD_INFO_VECTOR))(*bdp);
+	}
+}
+
+void embed_config(bd_t **bdp)
+{
+        *bdp = &bdinfo;
+	get_board_info(bdp);
+#if 0
+	/* Enable RefClk/4 mode for both UARTs */
+	mtdcr(DCRN_CPC0_CR0, mfdcr(DCRN_CPC0_CR0) | 0x30000000);
+#endif
+#if 0
+	timebase_period_ns = 1000000000 / bdinfo.bi_tbfreq;
+#endif
+}
+
+#endif
+
 #ifdef CONFIG_EP405
 #include <linux/serial_reg.h>
 
diff -purN /dev/shm/linux-2.5/arch/ppc/configs/ebony_defconfig linuxppc-2.5-benh/arch/ppc/configs/ebony_defconfig
--- /dev/shm/linux-2.5/arch/ppc/configs/ebony_defconfig	2003-10-06 12:04:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/configs/ebony_defconfig	2003-10-14 07:27:59.000000000 +0000
@@ -12,7 +12,6 @@ CONFIG_PPC32=y
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
-# CONFIG_STANDALONE is not set
 CONFIG_BROKEN_ON_SMP=y
 
 #
@@ -126,6 +125,7 @@ CONFIG_BOOT_LOAD=0x01000000
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -308,11 +308,6 @@ CONFIG_NETDEVICES=y
 # CONFIG_IRDA is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -351,11 +346,7 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 #
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO is not set
 
 #
 # Input Device Drivers
@@ -383,7 +374,6 @@ CONFIG_HW_CONSOLE=y
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_8250_EXTENDED=y
 CONFIG_SERIAL_8250_MANY_PORTS=y
 CONFIG_SERIAL_8250_SHARE_IRQ=y
@@ -405,11 +395,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
 #
 
 #
@@ -492,7 +477,6 @@ CONFIG_PROC_KCORE=y
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
-# CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
 
 #
@@ -548,6 +532,11 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_USB_GADGET is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # Library routines
 #
 CONFIG_CRC32=y
diff -purN /dev/shm/linux-2.5/arch/ppc/configs/g5_defconfig linuxppc-2.5-benh/arch/ppc/configs/g5_defconfig
--- /dev/shm/linux-2.5/arch/ppc/configs/g5_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/configs/g5_defconfig	2003-11-11 00:20:40.000000000 +0000
@@ -0,0 +1,1392 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_PPC=y
+CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_IKCONFIG is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor
+#
+# CONFIG_6xx is not set
+# CONFIG_40x is not set
+# CONFIG_44x is not set
+# CONFIG_POWER3 is not set
+CONFIG_POWER4=y
+# CONFIG_8xx is not set
+CONFIG_ALTIVEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_PROC_INTF=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_24_API=y
+CONFIG_CPU_FREQ_PMAC=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_PM=y
+CONFIG_PPC64BRIDGE=y
+CONFIG_PPC_STD_MMU=y
+
+#
+# Platform options
+#
+CONFIG_PPC_MULTIPLATFORM=y
+# CONFIG_APUS is not set
+# CONFIG_WILLOW is not set
+# CONFIG_PCORE is not set
+# CONFIG_POWERPMC250 is not set
+# CONFIG_EV64260 is not set
+# CONFIG_SPRUCE is not set
+# CONFIG_LOPEC is not set
+# CONFIG_MCPN765 is not set
+# CONFIG_MVME5100 is not set
+# CONFIG_PPLUS is not set
+# CONFIG_PRPMC750 is not set
+# CONFIG_PRPMC800 is not set
+# CONFIG_SANDPOINT is not set
+# CONFIG_ADIR is not set
+# CONFIG_K2 is not set
+# CONFIG_PAL4 is not set
+# CONFIG_GEMINI is not set
+# CONFIG_EST8260 is not set
+# CONFIG_SBS8260 is not set
+# CONFIG_RPX6 is not set
+# CONFIG_TQM8260 is not set
+CONFIG_PPC_CHRP=y
+CONFIG_PPC_PMAC=y
+CONFIG_PPC_PREP=y
+CONFIG_PPC_OF=y
+CONFIG_PPCBUG_NVRAM=y
+CONFIG_SMP=y
+CONFIG_IRQ_ALL_CPUS=y
+CONFIG_NR_CPUS=4
+CONFIG_HIGHMEM=y
+CONFIG_KERNEL_ELF=y
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_MISC=m
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_PPC_RTAS is not set
+# CONFIG_PREP_RESIDUAL is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+# CONFIG_ISA is not set
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_PCI_NAMES=y
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+CONFIG_YENTA=m
+CONFIG_CARDBUS=y
+# CONFIG_I82092 is not set
+# CONFIG_TCIC is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Advanced setup
+#
+CONFIG_ADVANCED_OPTIONS=y
+# CONFIG_HIGHMEM_START_BOOL is not set
+CONFIG_HIGHMEM_START=0xfe000000
+# CONFIG_LOWMEM_SIZE_BOOL is not set
+CONFIG_LOWMEM_SIZE=0x30000000
+# CONFIG_KERNEL_START_BOOL is not set
+CONFIG_KERNEL_START=0xc0000000
+CONFIG_TASK_SIZE_BOOL=y
+CONFIG_TASK_SIZE=0x80000000
+CONFIG_BOOT_LOAD=0x00800000
+
+#
+# Generic Driver Options
+#
+CONFIG_FW_LOADER=y
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+CONFIG_BLK_DEV_IDEFLOPPY=y
+CONFIG_BLK_DEV_IDESCSI=y
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_SL82C105 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDE_TCQ is not set
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_IDEDMA_PCI_WIP is not set
+CONFIG_BLK_DEV_ADMA=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+CONFIG_BLK_DEV_CMD64X=y
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+CONFIG_BLK_DEV_PDC202XX_OLD=y
+CONFIG_PDC202XX_BURST=y
+CONFIG_BLK_DEV_PDC202XX_NEW=y
+CONFIG_PDC202XX_FORCE=y
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+CONFIG_BLK_DEV_IDE_PMAC=y
+CONFIG_BLK_DEV_IDE_PMAC_ATA100FIRST=y
+CONFIG_BLK_DEV_IDEDMA_PMAC=y
+CONFIG_BLK_DEV_IDE_PMAC_BLINK=y
+CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO=y
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_DMA_NONPCI is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_REPORT_LUNS is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+CONFIG_SCSI_AIC7XXX=y
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=253
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_PROBE_EISA_VL is not set
+# CONFIG_AIC7XXX_BUILD_FIRMWARE is not set
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_MEGARAID is not set
+CONFIG_SCSI_SATA=y
+CONFIG_SCSI_SATA_SVW=y
+# CONFIG_SCSI_ATA_PIIX is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_CPQFCTS is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_SCSI_MESH=y
+CONFIG_SCSI_MESH_SYNC_RATE=5
+CONFIG_SCSI_MESH_RESET_DELAY_MS=4000
+CONFIG_SCSI_MAC53C94=y
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+CONFIG_IEEE1394=y
+
+#
+# Subsystem Options
+#
+# CONFIG_IEEE1394_VERBOSEDEBUG is not set
+CONFIG_IEEE1394_OUI_DB=y
+
+#
+# Device Drivers
+#
+# CONFIG_IEEE1394_PCILYNX is not set
+CONFIG_IEEE1394_OHCI1394=y
+
+#
+# Protocol Drivers
+#
+CONFIG_IEEE1394_VIDEO1394=m
+CONFIG_IEEE1394_SBP2=m
+# CONFIG_IEEE1394_SBP2_PHYS_DMA is not set
+CONFIG_IEEE1394_ETH1394=m
+CONFIG_IEEE1394_DV1394=m
+CONFIG_IEEE1394_RAWIO=m
+# CONFIG_IEEE1394_CMP is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+# CONFIG_IP_NF_NAT_LOCAL is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_ADLER32 is not set
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+CONFIG_SCTP_HMAC_SHA1=y
+# CONFIG_SCTP_HMAC_MD5 is not set
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+CONFIG_ATM_CLIP_NO_ICMP=y
+# CONFIG_ATM_LANE is not set
+CONFIG_ATM_BR2684=m
+# CONFIG_ATM_BR2684_IPFILTER is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+CONFIG_CRC32=y
+CONFIG_MACE=y
+# CONFIG_MACE_AAUI_PORT is not set
+CONFIG_BMAC=y
+# CONFIG_OAKNET is not set
+# CONFIG_HAPPYMEAL is not set
+CONFIG_SUNGEM=y
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+CONFIG_NET_TULIP=y
+CONFIG_DE2104X=y
+CONFIG_TULIP=y
+# CONFIG_TULIP_MWI is not set
+CONFIG_TULIP_MMIO=y
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_PCMCIA_XIRTULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPPOE=m
+CONFIG_PPPOATM=m
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_AIRO is not set
+CONFIG_HERMES=m
+CONFIG_APPLE_AIRPORT=m
+CONFIG_PLX_HERMES=m
+CONFIG_TMD_HERMES=m
+CONFIG_PCI_HERMES=m
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+# CONFIG_PCMCIA_HERMES is not set
+CONFIG_AIRO_CS=m
+# CONFIG_PCMCIA_ATMEL is not set
+# CONFIG_PCMCIA_WL3501 is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# ATM drivers
+#
+# CONFIG_ATM_TCP is not set
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_FORE200E_MAYBE is not set
+# CONFIG_ATM_HE is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+CONFIG_BT_SCO=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIUSB=m
+CONFIG_BT_USB_SCO=y
+CONFIG_BT_USB_ZERO_PACKET=y
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_BCSP_TXCRC=y
+# CONFIG_BT_HCIDTL1 is not set
+# CONFIG_BT_HCIBT3C is not set
+# CONFIG_BT_HCIBLUECARD is not set
+CONFIG_BT_HCIBTUART=m
+# CONFIG_BT_HCIVHCI is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN_BOOL is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+CONFIG_FB_OF=y
+CONFIG_FB_CONTROL=y
+CONFIG_FB_PLATINUM=y
+CONFIG_FB_VALKYRIE=y
+CONFIG_FB_CT65550=y
+CONFIG_FB_IMSTT=y
+# CONFIG_FB_S3TRIO is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_RIVA=y
+CONFIG_FB_MATROX=y
+CONFIG_FB_MATROX_MILLENIUM=y
+CONFIG_FB_MATROX_MYSTIQUE=y
+CONFIG_FB_MATROX_G450=y
+CONFIG_FB_MATROX_G100=y
+# CONFIG_FB_MATROX_I2C is not set
+# CONFIG_FB_MATROX_MULTIHEAD is not set
+# CONFIG_FB_RADEON_OLD is not set
+CONFIG_FB_RADEON=y
+# CONFIG_FB_RADEON_I2C is not set
+CONFIG_FB_ATY128=y
+CONFIG_FB_ATY=y
+CONFIG_FB_ATY_CT=y
+CONFIG_FB_ATY_GX=y
+# CONFIG_FB_ATY_XL_INIT is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+CONFIG_FB_3DFX=y
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDDLER is not set
+# CONFIG_INPUT_JOYDUMP is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_PCSPKR is not set
+CONFIG_INPUT_UINPUT=m
+
+#
+# Macintosh device drivers
+#
+CONFIG_ADB_CUDA=y
+CONFIG_ADB_PMU=y
+CONFIG_PMAC_PBOOK=y
+CONFIG_PMAC_APM_EMU=y
+CONFIG_PMAC_BACKLIGHT=y
+# CONFIG_MAC_FLOPPY is not set
+# CONFIG_MAC_SERIAL is not set
+CONFIG_ADB=y
+CONFIG_ADB_MACIO=y
+CONFIG_INPUT_ADBHID=y
+CONFIG_MAC_EMUMOUSEBTN=y
+# CONFIG_ANSLCD is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=m
+CONFIG_SERIAL_8250_CS=m
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_PMACZILOG=y
+CONFIG_SERIAL_PMACZILOG_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+CONFIG_I2C_KEYWEST=y
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# I2C Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+
+#
+# Mice
+#
+CONFIG_BUSMOUSE=y
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_NVRAM=y
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+CONFIG_AGP=y
+CONFIG_AGP_UNINORTH=y
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_GAMMA is not set
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=y
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_HFS_FS=m
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_GSS is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_CIFS=m
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_NEC98_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=m
+CONFIG_DMASOUND_PMAC=m
+CONFIG_DMASOUND=m
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=m
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_OSSEMUL is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# PCI devices
+#
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VX222 is not set
+
+#
+# ALSA PowerMac devices
+#
+CONFIG_SND_POWERMAC=m
+
+#
+# ALSA USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# PCMCIA devices
+#
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_VXP440 is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_AUDIO=m
+
+#
+# USB Bluetooth TTY can only be used with disabled Bluetooth subsystem
+#
+CONFIG_USB_MIDI=m
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_STORAGE=m
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_HP8200e=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+CONFIG_HID_FF=y
+CONFIG_HID_PID=y
+CONFIG_LOGITECH_FF=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+CONFIG_USB_WACOM=m
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_XPAD is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+CONFIG_USB_SCANNER=m
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+CONFIG_USB_SERIAL_VISOR=m
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+CONFIG_USB_SERIAL_KEYSPAN=m
+# CONFIG_USB_SERIAL_KEYSPAN_MPR is not set
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+# CONFIG_USB_SERIAL_KEYSPAN_USA49WLC is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_EZUSB=y
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_SPEEDTOUCH is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# Library routines
+#
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_HIGHMEM=y
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_KGDB is not set
+CONFIG_XMON=y
+CONFIG_XMON_FW=y
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_DEBUG_INFO is not set
+CONFIG_BOOTX_TEXT=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_TEST is not set
diff -purN /dev/shm/linux-2.5/arch/ppc/configs/ocotea_defconfig linuxppc-2.5-benh/arch/ppc/configs/ocotea_defconfig
--- /dev/shm/linux-2.5/arch/ppc/configs/ocotea_defconfig	2003-10-06 12:04:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/configs/ocotea_defconfig	2003-10-14 07:39:07.000000000 +0000
@@ -12,7 +12,7 @@ CONFIG_PPC32=y
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
-# CONFIG_STANDALONE is not set
+CONFIG_STANDALONE=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
@@ -24,7 +24,7 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
+CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
@@ -67,6 +67,8 @@ CONFIG_PIN_TLB=y
 CONFIG_BOOKE=y
 CONFIG_IBM_OCP=y
 CONFIG_IBM_EMAC4=y
+# CONFIG_PPC4xx_DMA is not set
+CONFIG_OCP=y
 # CONFIG_PM is not set
 CONFIG_NOT_COHERENT_CACHE=y
 
@@ -128,6 +130,7 @@ CONFIG_BOOT_LOAD=0x01000000
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -257,19 +260,17 @@ CONFIG_NETDEVICES=y
 #
 # Ethernet (10 or 100Mbit)
 #
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_OAKNET is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_IBM_OCP_ENET=y
+# CONFIG_IBM_OCP_ENET_ERROR_MSG is not set
+CONFIG_IBM_OCP_ENET_RX_BUFF=64
+CONFIG_IBM_OCP_ENET_TX_BUFF=8
+CONFIG_IBM_OCP_ENET_GAP=8
+CONFIG_IBM_OCP_ENET_SKB_RES=0
+CONFIG_OCP_NET=y
+CONFIG_IBM_OCP_MAL_CNT=1
+CONFIG_IBM_OCP_ZMII=y
+CONFIG_CRC32=y
 
 #
 # Ethernet (1000 Mbit)
@@ -322,11 +323,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_IRDA is not set
 
 #
-# Bluetooth support
-#
-# CONFIG_BT is not set
-
-#
 # ISDN subsystem
 #
 # CONFIG_ISDN_BOOL is not set
@@ -337,13 +333,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_FB is not set
 
 #
-# Console display driver support
-#
-CONFIG_VGA_CONSOLE=y
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
 # Input device support
 #
 CONFIG_INPUT=y
@@ -366,8 +355,8 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 
@@ -387,9 +376,7 @@ CONFIG_SERIO=y
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -397,7 +384,6 @@ CONFIG_HW_CONSOLE=y
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
 CONFIG_SERIAL_8250_EXTENDED=y
 CONFIG_SERIAL_8250_MANY_PORTS=y
 CONFIG_SERIAL_8250_SHARE_IRQ=y
@@ -419,10 +405,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_I2C is not set
 
 #
-# I2C Algorithms
-#
-
-#
 # I2C Hardware Bus support
 #
 
@@ -451,6 +433,7 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+# CONFIG_IBM_GPIO is not set
 
 #
 # Ftape, the floppy tape device driver
@@ -506,6 +489,7 @@ CONFIG_PROC_KCORE=y
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
 
@@ -562,9 +546,13 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_USB_GADGET is not set
 
 #
+# Bluetooth support
+#
+# CONFIG_BT is not set
+
+#
 # Library routines
 #
-CONFIG_CRC32=y
 
 #
 # Kernel hacking
@@ -579,7 +567,6 @@ CONFIG_DEBUG_KERNEL=y
 CONFIG_BDI_SWITCH=y
 CONFIG_DEBUG_INFO=y
 # CONFIG_SERIAL_TEXT_DEBUG is not set
-CONFIG_OCP=y
 
 #
 # Security options
diff -purN /dev/shm/linux-2.5/arch/ppc/configs/pmac_defconfig linuxppc-2.5-benh/arch/ppc/configs/pmac_defconfig
--- /dev/shm/linux-2.5/arch/ppc/configs/pmac_defconfig	2003-10-06 12:04:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/configs/pmac_defconfig	2003-12-24 07:45:26.000000000 +0000
@@ -6,13 +6,15 @@ CONFIG_RWSEM_XCHGADD_ALGORITHM=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_PPC=y
 CONFIG_PPC32=y
+CONFIG_GENERIC_NVRAM=y
 
 #
 # Code maturity level options
 #
 CONFIG_EXPERIMENTAL=y
-CONFIG_CLEAN_COMPILE=y
+# CONFIG_CLEAN_COMPILE is not set
 # CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
 CONFIG_BROKEN_ON_SMP=y
 
 #
@@ -23,8 +25,7 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 CONFIG_LOG_BUF_SHIFT=14
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKCONFIG is not set
 # CONFIG_EMBEDDED is not set
 CONFIG_KALLSYMS=y
 CONFIG_FUTEX=y
@@ -53,16 +54,15 @@ CONFIG_6xx=y
 # CONFIG_POWER4 is not set
 # CONFIG_8xx is not set
 CONFIG_ALTIVEC=y
-CONFIG_TAU=y
-# CONFIG_TAU_INT is not set
-# CONFIG_TAU_AVERAGE is not set
+# CONFIG_TAU is not set
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_PROC_INTF=y
 CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
 # CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
 CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_24_API=y
 CONFIG_CPU_FREQ_PMAC=y
 CONFIG_CPU_FREQ_TABLE=y
 CONFIG_PPC601_SYNC_FIX=y
@@ -101,7 +101,7 @@ CONFIG_PPC_OF=y
 CONFIG_PPCBUG_NVRAM=y
 # CONFIG_SMP is not set
 # CONFIG_PREEMPT is not set
-# CONFIG_HIGHMEM is not set
+CONFIG_HIGHMEM=y
 CONFIG_KERNEL_ELF=y
 CONFIG_BINFMT_ELF=y
 CONFIG_BINFMT_MISC=m
@@ -139,6 +139,7 @@ CONFIG_TCIC=m
 # Advanced setup
 #
 CONFIG_ADVANCED_OPTIONS=y
+# CONFIG_HIGHMEM_START_BOOL is not set
 CONFIG_HIGHMEM_START=0xfe000000
 # CONFIG_LOWMEM_SIZE_BOOL is not set
 CONFIG_LOWMEM_SIZE=0x30000000
@@ -166,6 +167,7 @@ CONFIG_BOOT_LOAD=0x00800000
 #
 # Block devices
 #
+# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -213,7 +215,6 @@ CONFIG_BLK_DEV_GENERIC=y
 # CONFIG_BLK_DEV_OPTI621 is not set
 CONFIG_BLK_DEV_SL82C105=y
 CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_IDE_TCQ is not set
 # CONFIG_BLK_DEV_IDEDMA_FORCED is not set
 CONFIG_IDEDMA_PCI_AUTO=y
 # CONFIG_IDEDMA_ONLYDISK is not set
@@ -291,8 +292,10 @@ CONFIG_AIC7XXX_DEBUG_MASK=0
 CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 CONFIG_SCSI_AIC7XXX_OLD=m
 # CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
 CONFIG_SCSI_ADVANSYS=m
 # CONFIG_SCSI_MEGARAID is not set
+# CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -301,16 +304,20 @@ CONFIG_SCSI_ADVANSYS=m
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
 CONFIG_SCSI_SYM53C8XX_2=y
 CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
 CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
 CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 # CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_PCI2000 is not set
+# CONFIG_SCSI_PCI2220I is not set
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 # CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
 # CONFIG_SCSI_DEBUG is not set
 CONFIG_SCSI_MESH=y
@@ -340,15 +347,12 @@ CONFIG_IEEE1394=m
 # Subsystem Options
 #
 # CONFIG_IEEE1394_VERBOSEDEBUG is not set
-# CONFIG_IEEE1394_OUI_DB is not set
+CONFIG_IEEE1394_OUI_DB=y
 
 #
 # Device Drivers
 #
-
-#
-# Texas Instruments PCILynx requires I2C bit-banging
-#
+CONFIG_IEEE1394_PCILYNX=m
 CONFIG_IEEE1394_OHCI1394=m
 
 #
@@ -499,6 +503,7 @@ CONFIG_NETDEVICES=y
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
+CONFIG_CRC32=y
 CONFIG_MACE=y
 # CONFIG_MACE_AAUI_PORT is not set
 CONFIG_BMAC=y
@@ -513,7 +518,7 @@ CONFIG_SUNGEM=y
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
 CONFIG_NET_PCI=y
-CONFIG_PCNET32=y
+# CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
 # CONFIG_ADAPTEC_STARFIRE is not set
 # CONFIG_B44 is not set
@@ -543,7 +548,7 @@ CONFIG_PCNET32=y
 # CONFIG_R8169 is not set
 # CONFIG_SIS190 is not set
 # CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
+CONFIG_TIGON3=y
 
 #
 # Ethernet (10000 Mbit)
@@ -557,8 +562,8 @@ CONFIG_PPP_MULTILINK=y
 CONFIG_PPP_ASYNC=y
 CONFIG_PPP_SYNC_TTY=m
 CONFIG_PPP_DEFLATE=y
-CONFIG_PPP_BSDCOMP=m
-# CONFIG_PPPOE is not set
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPPOE=m
 # CONFIG_SLIP is not set
 
 #
@@ -692,6 +697,8 @@ CONFIG_IRTTY_SIR=m
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
 # CONFIG_FB_CYBER2000 is not set
 CONFIG_FB_OF=y
 CONFIG_FB_CONTROL=y
@@ -701,15 +708,18 @@ CONFIG_FB_CT65550=y
 CONFIG_FB_IMSTT=y
 # CONFIG_FB_S3TRIO is not set
 # CONFIG_FB_VGA16 is not set
-# CONFIG_FB_RIVA is not set
+CONFIG_FB_RIVA=y
 CONFIG_FB_MATROX=y
 CONFIG_FB_MATROX_MILLENIUM=y
 CONFIG_FB_MATROX_MYSTIQUE=y
 # CONFIG_FB_MATROX_G450 is not set
 CONFIG_FB_MATROX_G100A=y
 CONFIG_FB_MATROX_G100=y
+# CONFIG_FB_MATROX_I2C is not set
 # CONFIG_FB_MATROX_MULTIHEAD is not set
+# CONFIG_FB_RADEON_OLD is not set
 CONFIG_FB_RADEON=y
+CONFIG_FB_RADEON_I2C=y
 CONFIG_FB_ATY128=y
 CONFIG_FB_ATY=y
 CONFIG_FB_ATY_CT=y
@@ -720,6 +730,7 @@ CONFIG_FB_ATY_GX=y
 CONFIG_FB_3DFX=y
 # CONFIG_FB_VOODOO1 is not set
 # CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_PM3 is not set
 # CONFIG_FB_VIRTUAL is not set
 
 #
@@ -764,11 +775,8 @@ CONFIG_INPUT_EVDEV=y
 #
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
+# CONFIG_SERIO is not set
 # CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
 
 #
 # Input Device Drivers
@@ -794,11 +802,12 @@ CONFIG_PMAC_PBOOK=y
 CONFIG_PMAC_APM_EMU=y
 CONFIG_PMAC_BACKLIGHT=y
 # CONFIG_MAC_FLOPPY is not set
-CONFIG_MAC_SERIAL=y
+# CONFIG_MAC_SERIAL is not set
 CONFIG_ADB=y
 CONFIG_ADB_MACIO=y
 CONFIG_INPUT_ADBHID=y
 CONFIG_MAC_EMUMOUSEBTN=y
+# CONFIG_THERM_PM72 is not set
 # CONFIG_ANSLCD is not set
 
 #
@@ -821,21 +830,22 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_SERIAL_PMACZILOG=y
-# CONFIG_SERIAL_PMACZILOG_CONSOLE is not set
+CONFIG_SERIAL_PMACZILOG_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
 #
 # I2C support
 #
-CONFIG_I2C=m
-CONFIG_I2C_CHARDEV=m
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
 
 #
 # I2C Algorithms
 #
-# CONFIG_I2C_ALGOBIT is not set
+CONFIG_I2C_ALGOBIT=y
 # CONFIG_I2C_ALGOPCF is not set
 
 #
@@ -846,13 +856,19 @@ CONFIG_I2C_CHARDEV=m
 # CONFIG_I2C_AMD756 is not set
 # CONFIG_I2C_AMD8111 is not set
 # CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
 CONFIG_I2C_KEYWEST=m
 # CONFIG_I2C_NFORCE2 is not set
 # CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
 # CONFIG_I2C_SIS5595 is not set
 # CONFIG_I2C_SIS630 is not set
 # CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
 # CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
 
 #
 # I2C Hardware Sensors Chip support
@@ -870,7 +886,7 @@ CONFIG_I2C_KEYWEST=m
 #
 # Mice
 #
-CONFIG_BUSMOUSE=y
+# CONFIG_BUSMOUSE is not set
 # CONFIG_QIC02_TAPE is not set
 
 #
@@ -884,7 +900,7 @@ CONFIG_BUSMOUSE=y
 # CONFIG_WATCHDOG is not set
 CONFIG_NVRAM=y
 CONFIG_GEN_RTC=y
-# CONFIG_GEN_RTC_X is not set
+CONFIG_GEN_RTC_X=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -893,8 +909,15 @@ CONFIG_GEN_RTC=y
 # Ftape, the floppy tape device driver
 #
 # CONFIG_FTAPE is not set
-# CONFIG_AGP is not set
-# CONFIG_DRM is not set
+CONFIG_AGP=m
+CONFIG_AGP_UNINORTH=m
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_GAMMA is not set
+CONFIG_DRM_R128=m
+CONFIG_DRM_RADEON=m
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
 
 #
 # PCMCIA character devices
@@ -954,12 +977,11 @@ CONFIG_VFAT_FS=m
 #
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
-CONFIG_DEVFS_FS=y
-# CONFIG_DEVFS_MOUNT is not set
-# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVFS_FS is not set
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
 
@@ -968,7 +990,8 @@ CONFIG_RAMFS=y
 #
 # CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
-CONFIG_HFS_FS=m
+CONFIG_HFS_FS=y
+CONFIG_HFSPLUS_FS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
@@ -985,6 +1008,7 @@ CONFIG_HFS_FS=m
 CONFIG_NFS_FS=y
 # CONFIG_NFS_V3 is not set
 # CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
@@ -1164,7 +1188,7 @@ CONFIG_USB_DYNAMIC_MINORS=y
 #
 # CONFIG_USB_EHCI_HCD is not set
 CONFIG_USB_OHCI_HCD=y
-# CONFIG_USB_UHCI_HCD is not set
+CONFIG_USB_UHCI_HCD=y
 
 #
 # USB Device Class drivers
@@ -1234,8 +1258,20 @@ CONFIG_USB_SERIAL_VISOR=m
 # CONFIG_USB_SERIAL_IR is not set
 # CONFIG_USB_SERIAL_EDGEPORT is not set
 # CONFIG_USB_SERIAL_EDGEPORT_TI is not set
-# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
-# CONFIG_USB_SERIAL_KEYSPAN is not set
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
 # CONFIG_USB_SERIAL_KLSI is not set
 # CONFIG_USB_SERIAL_KOBIL_SCT is not set
 # CONFIG_USB_SERIAL_MCT_U232 is not set
@@ -1244,6 +1280,7 @@ CONFIG_USB_SERIAL_VISOR=m
 # CONFIG_USB_SERIAL_CYBERJACK is not set
 # CONFIG_USB_SERIAL_XIRCOM is not set
 # CONFIG_USB_SERIAL_OMNINET is not set
+CONFIG_USB_EZUSB=y
 
 #
 # USB Miscellaneous drivers
@@ -1259,14 +1296,22 @@ CONFIG_USB_SERIAL_VISOR=m
 #
 # Library routines
 #
-CONFIG_CRC32=y
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
 
 #
 # Kernel hacking
 #
-# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_KGDB is not set
+# CONFIG_XMON is not set
+# CONFIG_BDI_SWITCH is not set
+# CONFIG_DEBUG_INFO is not set
 CONFIG_BOOTX_TEXT=y
 
 #
diff -purN /dev/shm/linux-2.5/arch/ppc/configs/sandpoint_defconfig linuxppc-2.5-benh/arch/ppc/configs/sandpoint_defconfig
--- /dev/shm/linux-2.5/arch/ppc/configs/sandpoint_defconfig	2003-07-03 00:44:13.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/configs/sandpoint_defconfig	2003-07-07 15:38:55.000000000 +0000
@@ -455,6 +455,7 @@ CONFIG_KEYBOARD_ATKBD=y
 # CONFIG_KEYBOARD_NEWTON is not set
 CONFIG_INPUT_MOUSE=y
 CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_PS2_SYNAPTICS is not set
 # CONFIG_MOUSE_SERIAL is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TOUCHSCREEN is not set
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/Makefile linuxppc-2.5-benh/arch/ppc/kernel/Makefile
--- /dev/shm/linux-2.5/arch/ppc/kernel/Makefile	2004-01-19 06:28:33.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/Makefile	2004-01-21 00:29:20.000000000 +0000
@@ -22,11 +22,12 @@ obj-y				:= entry.o traps.o irq.o idle.o
 					semaphore.o syscalls.o setup.o \
 					cputable.o ppc_htab.o
 obj-$(CONFIG_6xx)		+= l2cr.o cpu_setup_6xx.o
+obj-$(CONFIG_POWER4)		+= cpu_setup_power4.o
 obj-$(CONFIG_MODULES)		+= module.o ppc_ksyms.o
 obj-$(CONFIG_PCI)		+= pci.o
 obj-$(CONFIG_PCI)		+= pci-dma.o
 obj-$(CONFIG_KGDB)		+= ppc-stub.o
-obj-$(CONFIG_SMP)		+= smp.o
+obj-$(CONFIG_SMP)		+= smp.o smp-tbsync.o
 obj-$(CONFIG_TAU)		+= temp.o
 
 ifdef CONFIG_MATH_EMULATION
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/cpu_setup_6xx.S linuxppc-2.5-benh/arch/ppc/kernel/cpu_setup_6xx.S
--- /dev/shm/linux-2.5/arch/ppc/kernel/cpu_setup_6xx.S	2003-10-07 00:06:57.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/cpu_setup_6xx.S	2003-11-10 07:06:15.000000000 +0000
@@ -142,7 +142,7 @@ setup_7410_workarounds:
 	sync
 	isync
 	blr
-	
+
 /* 740/750/7400/7410
  * Enable Store Gathering (SGE), Address Brodcast (ABE),
  * Branch History Table (BHTE), Branch Target ICache (BTIC)
@@ -213,7 +213,7 @@ setup_745x_specifics:
 	li	r7,CPU_FTR_CAN_NAP
 	andc	r6,r6,r7
 	stw	r6,CPU_SPEC_FEATURES(r5)
-1:	
+1:
 	mfspr	r11,HID0
 
 	/* All of the bits we have to set.....
@@ -248,20 +248,21 @@ END_FTR_SECTION_IFCLR(CPU_FTR_NO_DPM)
 /* Definitions for the table use to save CPU states */
 #define CS_HID0		0
 #define CS_HID1		4
-#define	CS_MSSCR0	8
-#define CS_MSSSR0	12
-#define CS_ICTRL	16
-#define CS_LDSTCR	20
-#define CS_LDSTDB	24
-#define CS_SIZE		28
+#define CS_HID2		8
+#define	CS_MSSCR0	12
+#define CS_MSSSR0	16
+#define CS_ICTRL	20
+#define CS_LDSTCR	24
+#define CS_LDSTDB	28
+#define CS_SIZE		32
 
 	.data
 	.balign	L1_CACHE_LINE_SIZE
-cpu_state_storage:	
+cpu_state_storage:
 	.space	CS_SIZE
 	.balign	L1_CACHE_LINE_SIZE,0
 	.text
-	
+
 /* Called in normal context to backup CPU 0 state. This
  * does not include cache settings. This function is also
  * called for machine sleep. This does not include the MMU
@@ -311,11 +312,18 @@ _GLOBAL(__save_cpu_setup)
 	stw	r4,CS_LDSTCR(r5)
 	mfspr	r4,SPRN_LDSTDB
 	stw	r4,CS_LDSTDB(r5)
-1:	
+1:
 	bne	cr5,1f
 	/* Backup 750FX specific registers */
 	mfspr	r4,SPRN_HID1
 	stw	r4,CS_HID1(r5)
+	/* If rev 2.x, backup HID2 */
+	mfspr	r3,PVR
+	andi.	r3,r3,0xff00
+	cmpi	cr0,r3,0x0200
+	bne	1f
+	mfspr	r4,SPRN_HID2
+	stw	r4,CS_HID2(r5)
 1:
 	mtcr	r7
 	blr
@@ -395,9 +403,19 @@ _GLOBAL(__restore_cpu_setup)
 	sync
 2:	bne	cr5,1f
 	/* Restore 750FX specific registers
-	 * that is restore PLL config & switch
-	 * to PLL 0
+	 * that is restore HID2 on rev 2.x and PLL config & switch
+	 * to PLL 0 on all
 	 */
+	/* If rev 2.x, restore HID2 with low voltage bit cleared */
+	mfspr	r3,PVR
+	andi.	r3,r3,0xff00
+	cmpi	cr0,r3,0x0200
+	bne	4f
+	lwz	r4,CS_HID2(r5)
+	rlwinm	r4,r4,0,19,17
+	mtspr	SPRN_HID2,r4
+	sync
+4:
 	lwz	r4,CS_HID1(r5)
 	rlwinm  r5,r4,0,16,14
 	mtspr	SPRN_HID1,r5
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/cpu_setup_power4.S linuxppc-2.5-benh/arch/ppc/kernel/cpu_setup_power4.S
--- /dev/shm/linux-2.5/arch/ppc/kernel/cpu_setup_power4.S	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/cpu_setup_power4.S	2003-10-30 03:25:31.000000000 +0000
@@ -0,0 +1,182 @@
+/*
+ * This file contains low level CPU setup functions.
+ *    Copyright (C) 2003 Benjamin Herrenschmidt (benh@kernel.crashing.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/ppc_asm.h>
+#include <asm/offsets.h>
+#include <asm/cache.h>
+
+_GLOBAL(__power4_cpu_preinit)
+	/*
+	 * On the PPC970, we have to turn off real-mode cache inhibit
+	 * early, before we first turn the MMU off.
+	 */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bnelr
+
+	li	r0,0
+	sync
+	mtspr	SPRN_HID4,r0
+	isync
+	sync
+	mtspr	SPRN_HID5,r0
+	isync
+
+	mfspr	r0,SPRN_HID1
+	li	r11,0x1200		/* enable i-fetch cacheability */
+	sldi	r11,r11,44		/* and prefetch */
+	or	r0,r0,r11
+	mtspr	SPRN_HID1,r0
+	mtspr	SPRN_HID1,r0
+	isync
+	li	r0,0
+	sync
+	mtspr	SPRN_HIOR,0		/* Clear interrupt prefix */
+	isync
+	blr
+
+_GLOBAL(__setup_cpu_power4)
+	blr
+_GLOBAL(__setup_cpu_ppc970)
+	mfspr	r0,SPRN_HID0
+	li	r11,5			/* clear DOZE and SLEEP */
+	rldimi	r0,r11,52,8		/* set NAP and DPM */
+	mtspr	SPRN_HID0,r0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	sync
+	isync
+	blr
+
+/* Definitions for the table use to save CPU states */
+#define CS_HID0		0
+#define CS_HID1		8
+#define	CS_HID4		16
+#define CS_HID5		24
+#define CS_SIZE		32
+
+	.data
+	.balign	L1_CACHE_LINE_SIZE
+cpu_state_storage:	
+	.space	CS_SIZE
+	.balign	L1_CACHE_LINE_SIZE,0
+	.text
+	
+/* Called in normal context to backup CPU 0 state. This
+ * does not include cache settings. This function is also
+ * called for machine sleep. This does not include the MMU
+ * setup, BATs, etc... but rather the "special" registers
+ * like HID0, HID1, HID4, etc...
+ */
+_GLOBAL(__save_cpu_setup)
+	/* Some CR fields are volatile, we back it up all */
+	mfcr	r7
+
+	/* Get storage ptr */
+	lis	r5,cpu_state_storage@h
+	ori	r5,r5,cpu_state_storage@l
+
+	/* We only deal with 970 for now */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bne	1f
+
+	/* Save HID0,1,4 and 5 */
+	mfspr	r3,SPRN_HID0
+	std	r3,CS_HID0(r5)
+	mfspr	r3,SPRN_HID1
+	std	r3,CS_HID1(r5)
+	mfspr	r3,SPRN_HID4
+	std	r3,CS_HID4(r5)
+	mfspr	r3,SPRN_HID5
+	std	r3,CS_HID5(r5)
+	
+1:
+	mtcr	r7
+	blr
+
+/* Called with no MMU context (typically MSR:IR/DR off) to
+ * restore CPU state as backed up by the previous
+ * function. This does not include cache setting
+ */
+_GLOBAL(__restore_cpu_setup)
+	/* Some CR fields are volatile, we back it up all */
+	mfcr	r7
+
+	/* Get storage ptr */
+	lis	r5,(cpu_state_storage-KERNELBASE)@h
+	ori	r5,r5,cpu_state_storage@l
+
+	/* We only deal with 970 for now */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bne	1f
+
+	/* Clear interrupt prefix */
+	li	r0,0
+	sync
+	mtspr	SPRN_HIOR,0
+	isync
+
+	/* Restore HID0 */
+	ld	r3,CS_HID0(r5)
+	sync
+	isync
+	mtspr	SPRN_HID0,r3
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	sync
+	isync
+
+	/* Restore HID1 */
+	ld	r3,CS_HID1(r5)
+	sync
+	isync
+	mtspr	SPRN_HID1,r3
+	mtspr	SPRN_HID1,r3
+	sync
+	isync
+	
+	/* Restore HID4 */
+	ld	r3,CS_HID4(r5)
+	sync
+	isync
+	mtspr	SPRN_HID4,r3
+	sync
+	isync
+
+	/* Restore HID5 */
+	ld	r3,CS_HID5(r5)
+	sync
+	isync
+	mtspr	SPRN_HID5,r3
+	sync
+	isync
+1:
+	mtcr	r7
+	blr
+
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/head.S linuxppc-2.5-benh/arch/ppc/kernel/head.S
--- /dev/shm/linux-2.5/arch/ppc/kernel/head.S	2003-10-11 13:58:20.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/head.S	2003-11-17 01:29:46.000000000 +0000
@@ -141,17 +141,6 @@ __start:
 	mr	r27,r7
 	li	r24,0			/* cpu # */
 
-#ifdef CONFIG_POWER4
-/*
- * On the PPC970, we have to turn off real-mode cache inhibit
- * early, before we first turn the MMU off.
- */
-	mfspr	r0,SPRN_PVR
-	srwi	r0,r0,16
-	cmpwi	r0,0x39
-	beql	ppc970_setup_hid
-#endif /* CONFIG_POWER4 */
-
 /*
  * early_init() does the early machine identification and does
  * the necessary low-level setup and clears the BSS
@@ -159,6 +148,14 @@ __start:
  */
 	bl	early_init
 
+/*
+ * On POWER4, we first need to tweak some CPU configuration registers
+ * like real mode cache inhibit or exception base
+ */
+#ifdef CONFIG_POWER4
+	bl	__power4_cpu_preinit
+#endif /* CONFIG_POWER4 */
+
 #ifdef CONFIG_APUS
 /* On APUS the __va/__pa constants need to be set to the correct
  * values before continuing.
@@ -1216,7 +1213,7 @@ __secondary_start_psurge99:
 __secondary_start:
 #ifdef CONFIG_PPC64BRIDGE
 	mfmsr	r0
-	clrldi	r0,r0,1		/* make sure it's in 32-bit mode */
+	clrldi	r0,r0,1			/* make sure it's in 32-bit mode */
 	SYNC
 	MTMSRD(r0)
 	isync
@@ -1278,26 +1275,15 @@ __secondary_start:
  */
 _GLOBAL(__setup_cpu_power3)
 	blr
-_GLOBAL(__setup_cpu_power4)
-	blr
-_GLOBAL(__setup_cpu_ppc970)
-	blr
 _GLOBAL(__setup_cpu_generic)
 	blr
 
-#ifndef CONFIG_6xx
+#if !defined(CONFIG_6xx) && !defined(CONFIG_POWER4)
 _GLOBAL(__save_cpu_setup)
 	blr
 _GLOBAL(__restore_cpu_setup)
-#ifdef CONFIG_POWER4
-	/* turn off real-mode cache inhibit on the PPC970 */
-	mfspr	r0,SPRN_PVR
-	srwi	r0,r0,16
-	cmpwi	r0,0x39
-	beq	ppc970_setup_hid
-#endif
 	blr
-#endif /* CONFIG_6xx */
+#endif /* !defined(CONFIG_6xx) && !defined(CONFIG_POWER4) */
 
 
 /*
@@ -1633,10 +1619,14 @@ initial_mm_power4:
 	lis	r4,0x2000		/* set pseudo-segment reg 12 */
 	ori	r5,r4,0x0ccc
 	mtsr	12,r5
+#if 0
 	ori	r5,r4,0x0888		/* set pseudo-segment reg 8 */
 	mtsr	8,r5			/* (for access to serial port) */
-	ori	r5,r4,0x0999		/* set pseudo-segment reg 8 */
+#endif
+#ifdef CONFIG_BOOTX_TEXT
+	ori	r5,r4,0x0999		/* set pseudo-segment reg 9 */
 	mtsr	9,r5			/* (for access to screen) */
+#endif
 	mfmsr	r0
 	clrldi	r0,r0,1
 	sync
@@ -1644,43 +1634,8 @@ initial_mm_power4:
 	isync
 	blr
 
-/*
- * On 970 (G5), we pre-set a few bits in HID0 & HID1
- */
-ppc970_setup_hid:
-	li	r0,0
-	sync
-	mtspr	0x3f4,r0
-	isync
-	sync
-	mtspr	0x3f6,r0
-	isync
-	mfspr	r0,SPRN_HID0
-	li	r11,1			/* clear DOZE, NAP and SLEEP */
-	rldimi	r0,r11,52,8		/* set DPM */
-	mtspr	SPRN_HID0,r0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	sync
-	isync
-	mfspr	r0,SPRN_HID1
-	li	r11,0x1200		/* enable i-fetch cacheability */
-	sldi	r11,r11,44		/* and prefetch */
-	or	r0,r0,r11
-	mtspr	SPRN_HID1,r0
-	mtspr	SPRN_HID1,r0
-	isync
-	li	r0,0
-	sync
-	mtspr	0x137,0
-	isync
-	blr
 #endif /* CONFIG_POWER4 */
-
+	
 #ifdef CONFIG_8260
 /* Jump into the system reset for the rom.
  * We first disable the MMU, and then jump to the ROM reset address.
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/idle_power4.S linuxppc-2.5-benh/arch/ppc/kernel/idle_power4.S
--- /dev/shm/linux-2.5/arch/ppc/kernel/idle_power4.S	2003-09-17 20:17:13.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/idle_power4.S	2003-10-30 03:25:30.000000000 +0000
@@ -28,17 +28,11 @@
 
 /*
  * Init idle, called at early CPU setup time from head.S for each CPU
- * Make sure no rest of NAP mode remains in HID0, save default
- * values for some CPU specific registers. Called with r24
- * containing CPU number and r3 reloc offset
+ * So nothing for now. Called with r24 containing CPU number and r3
+ * reloc offset
  */
  	.globl	init_idle_power4
 init_idle_power4:
-BEGIN_FTR_SECTION
-	mfspr	r4,SPRN_HID0
-	rlwinm	r4,r4,0,10,8	/* Clear NAP */
-	mtspr	SPRN_HID0, r4
-END_FTR_SECTION_IFSET(CPU_FTR_CAN_NAP)
 	blr
 
 /*
@@ -48,10 +42,9 @@ END_FTR_SECTION_IFSET(CPU_FTR_CAN_NAP)
  */
 	.globl	power4_idle
 power4_idle:
-	/* Check if we can nap or doze, put HID0 mask in r3
-	 */
-	lis	r3, 0
 BEGIN_FTR_SECTION
+	blr
+END_FTR_SECTION_IFCLR(CPU_FTR_CAN_NAP)
 	/* We must dynamically check for the NAP feature as it
 	 * can be cleared by CPU init after the fixups are done
 	 */
@@ -59,16 +52,11 @@ BEGIN_FTR_SECTION
 	lwz	r4,cur_cpu_spec@l(r4)
 	lwz	r4,CPU_SPEC_FEATURES(r4)
 	andi.	r0,r4,CPU_FTR_CAN_NAP
-	beq	1f
+	beqlr
 	/* Now check if user or arch enabled NAP mode */
 	lis	r4,powersave_nap@ha
 	lwz	r4,powersave_nap@l(r4)
 	cmpi	0,r4,0
-	beq	1f
-	lis	r3,HID0_NAP@h
-1:	
-END_FTR_SECTION_IFSET(CPU_FTR_CAN_NAP)
-	cmpi	0,r3,0
 	beqlr
 
 	/* Clear MSR:EE */
@@ -85,18 +73,6 @@ END_FTR_SECTION_IFSET(CPU_FTR_CAN_NAP)
 	blr
 1:	
 	/* Go to NAP now */	
-	mfspr	r4,SPRN_HID0
-	lis	r5,(HID0_NAP|HID0_SLEEP)@h
-	andc	r4,r4,r5
-	or	r4,r4,r3
-	oris	r4,r4,HID0_DPM@h	/* that should be done once for all  */
-	mtspr	SPRN_HID0,r4
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
-	mfspr	r0,SPRN_HID0
 BEGIN_FTR_SECTION
 	DSSALL
 	sync
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/irq.c linuxppc-2.5-benh/arch/ppc/kernel/irq.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/irq.c	2003-12-29 21:37:47.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/irq.c	2003-12-31 04:25:11.000000000 +0000
@@ -46,6 +46,7 @@
 #include <linux/random.h>
 #include <linux/seq_file.h>
 #include <linux/cpumask.h>
+#include <linux/sysdev.h>
 
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
@@ -56,6 +57,7 @@
 #include <asm/cache.h>
 #include <asm/prom.h>
 #include <asm/ptrace.h>
+#include <asm/xmon.h>
 
 #define NR_MASK_WORDS	((NR_IRQS + 31) / 32)
 
@@ -280,6 +282,11 @@ void disable_irq_nosync(unsigned int irq
 	irq_desc_t *desc = irq_desc + irq;
 	unsigned long flags;
 
+	if (irq >= NR_IRQS) {
+		printk("Argh, disable_irq_nosync(%d) !\n", irq);
+		dump_stack();
+	}
+
 	spin_lock_irqsave(&desc->lock, flags);
 	if (!desc->depth++) {
 		if (!(desc->status & IRQ_PER_CPU))
@@ -323,6 +330,11 @@ void enable_irq(unsigned int irq)
 	irq_desc_t *desc = irq_desc + irq;
 	unsigned long flags;
 
+	if (irq >= NR_IRQS) {
+		printk("Argh, enable_irq(%d) !\n", irq);
+		dump_stack();
+	}
+
 	spin_lock_irqsave(&desc->lock, flags);
 	switch (desc->depth) {
 	case 1: {
@@ -513,6 +525,8 @@ out:
 void do_IRQ(struct pt_regs *regs)
 {
 	int irq, first = 1;
+	static unsigned long deadcount = 0;
+
         irq_enter();
 
 	/*
@@ -526,7 +540,16 @@ void do_IRQ(struct pt_regs *regs)
 	while ((irq = ppc_md.get_irq(regs)) >= 0) {
 		ppc_irq_dispatch_handler(regs, irq);
 		first = 0;
+	        if (deadcount++ > 1000000) {
+#ifdef CONFIG_XMON
+			xmon_printf("Argh, stuck in IRQ loop, irq is %d\n", irq);
+			xmon(NULL);
+#else
+			printk("Argh, stuck in IRQ loop, irq is %d\n", irq);
+#endif
+		}
 	}
+	deadcount = 0;
 	if (irq != -2 && first)
 		/* That's not SMP safe ... but who cares ? */
 		ppc_spurious_interrupts++;
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/misc.S linuxppc-2.5-benh/arch/ppc/kernel/misc.S
--- /dev/shm/linux-2.5/arch/ppc/kernel/misc.S	2004-01-19 06:28:18.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/misc.S	2004-01-21 00:29:20.000000000 +0000
@@ -201,7 +201,7 @@ _GLOBAL(call_setup_cpu)
 	mr	r4,r24
 	bctr
 
-#ifdef CONFIG_CPU_FREQ_PMAC
+#if defined(CONFIG_CPU_FREQ_PMAC) && defined(CONFIG_6xx)
 
 /* This gets called by via-pmu.c to switch the PLL selection
  * on 750fx CPU. This function should really be moved to some
@@ -253,7 +253,7 @@ _GLOBAL(low_choose_750fx_pll)
 	mtmsr	r7
 	blr
 
-#endif /* CONFIG_CPU_FREQ_PMAC */
+#endif /* CONFIG_CPU_FREQ_PMAC && CONFIG_6xx */
 
 /* void local_save_flags_ptr(unsigned long *flags) */
 _GLOBAL(local_save_flags_ptr)
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/ocp.c linuxppc-2.5-benh/arch/ppc/kernel/ocp.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/ocp.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/ocp.c	2003-01-06 09:11:42.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ * ocp.c
+ *
+ *	The is drived from pci.c
+ *
+ * 	Current Maintainer
+ *      Armin Kuster akuster@pacbell.net
+ *      Jan, 2002
+ *
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <asm/ocp.h>
+
+
+static int __init
+ocparch_init(void)
+{
+	struct ocp_bus *bus;
+	int next_hostno, max_hostno;
+
+	printk(KERN_INFO "OCP: Probing OCP hardware\n");
+	max_hostno = 1;
+	/* Scan all of the recorded OCP controllers.  */
+	for (next_hostno = 0;next_hostno < max_hostno; next_hostno++) {
+		bus = ocp_scan_bus(next_hostno, NULL);
+	}
+	return 0;
+}
+
+subsys_initcall(ocparch_init);
+
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/pci.c linuxppc-2.5-benh/arch/ppc/kernel/pci.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/pci.c	2003-09-12 16:26:52.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/pci.c	2003-11-25 06:03:12.000000000 +0000
@@ -22,7 +22,7 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
-#undef DEBUG
+#define DEBUG
 
 #ifdef DEBUG
 #define DBG(x...) printk(x)
@@ -46,7 +46,9 @@ static int reparent_resources(struct res
 static void fixup_rev1_53c810(struct pci_dev* dev);
 static void fixup_cpc710_pci64(struct pci_dev* dev);
 #ifdef CONFIG_PPC_PMAC
-static void pcibios_fixup_cardbus(struct pci_dev* dev);
+extern void pmac_pci_fixup_cardbus(struct pci_dev* dev);
+extern void pmac_pci_fixup_pciata(struct pci_dev* dev);
+extern void pmac_pci_fixup_k2_sata(struct pci_dev* dev);
 #endif
 #ifdef CONFIG_PPC_OF
 static u8* pci_to_OF_bus_map;
@@ -69,7 +71,9 @@ struct pci_fixup pcibios_fixups[] = {
 	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,		PCI_ANY_ID,			pcibios_fixup_resources },
 #ifdef CONFIG_PPC_PMAC
 	/* We should add per-machine fixup support in xxx_setup.c or xxx_pci.c */
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_TI,	PCI_ANY_ID,			pcibios_fixup_cardbus },
+	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_TI,	PCI_ANY_ID,			pmac_pci_fixup_cardbus },
+	{ PCI_FIXUP_FINAL,	PCI_ANY_ID,		PCI_ANY_ID,			pmac_pci_fixup_pciata },
+	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SERVERWORKS, 0x0240,			pmac_pci_fixup_k2_sata },
 #endif /* CONFIG_PPC_PMAC */
  	{ 0 }
 };
@@ -155,42 +159,6 @@ pcibios_fixup_resources(struct pci_dev *
 		ppc_md.pcibios_fixup_resources(dev);
 }
 
-#ifdef CONFIG_PPC_PMAC
-static void
-pcibios_fixup_cardbus(struct pci_dev* dev)
-{
-	if (_machine != _MACH_Pmac)
-		return;
-	/*
-	 * Fix the interrupt routing on the various cardbus bridges
-	 * used on powerbooks
-	 */
-	if (dev->vendor != PCI_VENDOR_ID_TI)
-		return;
-	if (dev->device == PCI_DEVICE_ID_TI_1130 ||
-	    dev->device == PCI_DEVICE_ID_TI_1131) {
-		u8 val;
-	    	/* Enable PCI interrupt */
-		if (pci_read_config_byte(dev, 0x91, &val) == 0)
-			pci_write_config_byte(dev, 0x91, val | 0x30);
-		/* Disable ISA interrupt mode */
-		if (pci_read_config_byte(dev, 0x92, &val) == 0)
-			pci_write_config_byte(dev, 0x92, val & ~0x06);
-	}
-	if (dev->device == PCI_DEVICE_ID_TI_1210 ||
-	    dev->device == PCI_DEVICE_ID_TI_1211 ||
-	    dev->device == PCI_DEVICE_ID_TI_1410) {
-		u8 val;
-		/* 0x8c == TI122X_IRQMUX, 2 says to route the INTA
-		   signal out the MFUNC0 pin */
-		if (pci_read_config_byte(dev, 0x8c, &val) == 0)
-			pci_write_config_byte(dev, 0x8c, (val & ~0x0f) | 2);
-		/* Disable ISA interrupt mode */
-		if (pci_read_config_byte(dev, 0x92, &val) == 0)
-			pci_write_config_byte(dev, 0x92, val & ~0x06);
-	}
-}
-#endif /* CONFIG_PPC_PMAC */
 
 void
 pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
@@ -832,6 +800,12 @@ pci_busdev_to_OF_node(struct pci_bus *bu
 		return NULL;
 
 	/* Fixup bus number according to what OF think it is. */
+#ifdef CONFIG_PPC_PMAC
+	/* Sorry about that, I need to find a best way to fix it.... */
+	if (_machine == _MACH_Pmac && busnr >= 0xf0)
+		busnr -= 0xf0;
+	else
+#endif
 	if (pci_to_OF_bus_map)
 		busnr = pci_to_OF_bus_map[busnr];
 	if (busnr == 0xff)
@@ -922,9 +896,10 @@ void __init
 pci_process_bridge_OF_ranges(struct pci_controller *hose,
 			   struct device_node *dev, int primary)
 {
-	unsigned int *ranges, *prev;
+	static unsigned int static_lc_ranges[1024] __initdata;
+	unsigned int *dt_ranges, *lc_ranges, *ranges, *prev;
 	unsigned int size;
-	int rlen = 0;
+	int rlen = 0, orig_rlen;
 	int memno = 0;
 	struct resource *res;
 	int np, na = prom_n_addr_cells(dev);
@@ -934,7 +909,22 @@ pci_process_bridge_OF_ranges(struct pci_
 	 * that can have more than 3 ranges, fortunately using contiguous
 	 * addresses -- BenH
 	 */
-	ranges = (unsigned int *) get_property(dev, "ranges", &rlen);
+	dt_ranges = (unsigned int *) get_property(dev, "ranges", &rlen);
+	if (!dt_ranges)
+		return;
+	/* Sanity check, though hopefully that never happens */
+	if (rlen > 1024) {
+		printk(KERN_WARNING "OF ranges property too large !\n");
+		rlen = 1024;
+	}
+	lc_ranges = static_lc_ranges;
+	memcpy(lc_ranges, dt_ranges, rlen);
+	orig_rlen = rlen;
+
+	/* Let's work on a copy of the "ranges" property instead of damaging
+	 * the device-tree image in memory
+	 */
+	ranges = lc_ranges;
 	prev = NULL;
 	while ((rlen -= np * sizeof(unsigned int)) >= 0) {
 		if (prev) {
@@ -959,10 +949,9 @@ pci_process_bridge_OF_ranges(struct pci_
 	 *			(size depending on dev->n_addr_cells)
 	 *   cells 4+5 or 5+6:	the size of the range
 	 */
-	rlen = 0;
-	hose->io_base_phys = 0;
-	ranges = (unsigned int *) get_property(dev, "ranges", &rlen);
-	while ((rlen -= np * sizeof(unsigned int)) >= 0) {
+	ranges = lc_ranges;
+	rlen = orig_rlen;
+	while (ranges && (rlen -= np * sizeof(unsigned int)) >= 0) {
 		res = NULL;
 		size = ranges[na+4];
 		switch (ranges[0] >> 24) {
@@ -1059,7 +1048,7 @@ do_update_p2p_io_resource(struct pci_bus
 
  	res = *(bus->resource[0]);
 
-	DBG("Remapping Bus %d, bridge: %s\n", bus->number, bridge->name);
+	DBG("Remapping Bus %d, bridge: %s\n", bus->number, bridge->slot_name);
 	res.start -= ((unsigned long) hose->io_base_virt - isa_io_base);
 	res.end -= ((unsigned long) hose->io_base_virt - isa_io_base);
 	DBG("  IO window: %08lx-%08lx\n", res.start, res.end);
@@ -1662,12 +1651,23 @@ pci_bus_to_phys(unsigned int ba, int bus
  * Note that the returned IO or memory base is a physical address
  */
 
-long
-sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)
+long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)
 {
-	struct pci_controller* hose = pci_bus_to_hose(bus);
+	struct pci_controller* hose;
 	long result = -EOPNOTSUPP;
 
+	/* Argh ! Please forgive me for that hack, but that's the
+	 * simplest way to get existing XFree to not lockup on some
+	 * G5 machines... So when something asks for bus 0 io base
+	 * (bus 0 is HT root), we return the AGP one instead.
+	 */
+#ifdef CONFIG_PPC_PMAC
+	if (_machine == _MACH_Pmac && machine_is_compatible("MacRISC4"))
+		if (bus == 0)
+			bus = 0xf0;
+#endif /* CONFIG_PPC_PMAC */
+
+	hose = pci_bus_to_hose(bus);
 	if (!hose)
 		return -ENODEV;
 
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/ppc_ksyms.c linuxppc-2.5-benh/arch/ppc/kernel/ppc_ksyms.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/ppc_ksyms.c	2004-01-19 06:28:33.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/ppc_ksyms.c	2004-01-21 00:29:20.000000000 +0000
@@ -75,6 +75,7 @@ int abs(int);
 extern unsigned long mm_ptov (unsigned long paddr);
 
 EXPORT_SYMBOL(clear_page);
+EXPORT_SYMBOL(clear_user_page);
 EXPORT_SYMBOL(do_signal);
 EXPORT_SYMBOL(do_syscall_trace);
 EXPORT_SYMBOL(transfer_to_handler);
@@ -236,12 +237,6 @@ EXPORT_SYMBOL(adb_try_handler_change);
 EXPORT_SYMBOL(cuda_request);
 EXPORT_SYMBOL(cuda_poll);
 #endif /* CONFIG_ADB_CUDA */
-#ifdef CONFIG_PMAC_BACKLIGHT
-EXPORT_SYMBOL(get_backlight_level);
-EXPORT_SYMBOL(set_backlight_level);
-EXPORT_SYMBOL(set_backlight_enable);
-EXPORT_SYMBOL(register_backlight_controller);
-#endif /* CONFIG_PMAC_BACKLIGHT */
 #ifdef CONFIG_PPC_MULTIPLATFORM
 EXPORT_SYMBOL(_machine);
 #endif
@@ -282,14 +277,6 @@ EXPORT_SYMBOL(note_scsi_host);
 #ifdef CONFIG_VT
 EXPORT_SYMBOL(kd_mksound);
 #endif
-#ifdef CONFIG_NVRAM
-EXPORT_SYMBOL(nvram_read_byte);
-EXPORT_SYMBOL(nvram_write_byte);
-#ifdef CONFIG_PPC_PMAC
-EXPORT_SYMBOL(pmac_xpram_read);
-EXPORT_SYMBOL(pmac_xpram_write);
-#endif
-#endif /* CONFIG_NVRAM */
 EXPORT_SYMBOL(to_tm);
 
 EXPORT_SYMBOL(pm_power_off);
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/setup.c linuxppc-2.5-benh/arch/ppc/kernel/setup.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/setup.c	2004-02-04 05:28:09.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/setup.c	2004-02-05 10:07:32.000000000 +0000
@@ -35,6 +35,7 @@
 #include <asm/system.h>
 #include <asm/pmac_feature.h>
 #include <asm/sections.h>
+#include <asm/nvram.h>
 #include <asm/xmon.h>
 
 #if defined CONFIG_KGDB
@@ -111,6 +112,9 @@ struct screen_info screen_info = {
 
 void machine_restart(char *cmd)
 {
+#ifdef CONFIG_NVRAM
+	nvram_sync();
+#endif
 	ppc_md.restart(cmd);
 }
 
@@ -118,6 +122,9 @@ EXPORT_SYMBOL(machine_restart);
 
 void machine_power_off(void)
 {
+#ifdef CONFIG_NVRAM
+	nvram_sync();
+#endif
 	ppc_md.power_off();
 }
 
@@ -125,6 +132,9 @@ EXPORT_SYMBOL(machine_power_off);
 
 void machine_halt(void)
 {
+#ifdef CONFIG_NVRAM
+	nvram_sync();
+#endif
 	ppc_md.halt();
 }
 
@@ -364,6 +374,7 @@ platform_init(unsigned long r3, unsigned
 	      unsigned long r6, unsigned long r7)
 {
 #ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
 	if (boot_text_mapped) {
 		btext_clearscreen();
 		btext_welcome();
@@ -447,12 +458,26 @@ platform_init(unsigned long r3, unsigned
 			}
 		}
 	}
+#ifdef CONFIG_ADB_PMU
+	if (strstr(cmd_line, "fake_sleep")) {
+		extern int __fake_sleep;
+		__fake_sleep = 1;
+	}
+#endif /* CONFIG_ADB_PMU */	
 #ifdef CONFIG_ADB
 	if (strstr(cmd_line, "adb_sync")) {
 		extern int __adb_probe_sync;
 		__adb_probe_sync = 1;
 	}
 #endif /* CONFIG_ADB */
+	if (strstr(cmd_line, "nol3") && cur_cpu_spec[0]->cpu_features & CPU_FTR_L3CR)
+		_set_L3CR(0);
+	if (strstr(cmd_line, "nonap"))
+		cur_cpu_spec[0]->cpu_features &= ~CPU_FTR_CAN_NAP;
+#ifdef CONFIG_BOOTX_TEXT
+	if (strstr(cmd_line, "printkbtext"))
+		force_printk_to_btext = 1;
+#endif
 
 	switch (_machine) {
 	case _MACH_Pmac:
@@ -558,24 +583,30 @@ int __init ppc_setup_l2cr(char *str)
 __setup("l2cr=", ppc_setup_l2cr);
 
 #ifdef CONFIG_NVRAM
-/* Generic nvram hooks we now look into ppc_md.nvram_read_val
- * on pmac too ;)
- * //XX Those 2 could be moved to headers
- */
-unsigned char
-nvram_read_byte(int addr)
+
+/* Generic nvram hooks used by drivers/char/gen_nvram.c */
+unsigned char nvram_read_byte(int addr)
 {
 	if (ppc_md.nvram_read_val)
 		return ppc_md.nvram_read_val(addr);
 	return 0xff;
 }
+EXPORT_SYMBOL(nvram_read_byte);
 
-void
-nvram_write_byte(unsigned char val, int addr)
+void nvram_write_byte(unsigned char val, int addr)
 {
 	if (ppc_md.nvram_write_val)
-		ppc_md.nvram_write_val(val, addr);
+		ppc_md.nvram_write_val(addr, val);
 }
+EXPORT_SYMBOL(nvram_write_byte);
+
+void nvram_sync(void)
+{
+	if (ppc_md.nvram_sync)
+		ppc_md.nvram_sync();
+}
+EXPORT_SYMBOL(nvram_sync);
+
 #endif /* CONFIG_NVRAM */
 
 static struct cpu cpu_devices[NR_CPUS];
@@ -608,8 +639,8 @@ void __init setup_arch(char **cmdline_p)
 	extern char *klimit;
 	extern void do_init_bootmem(void);
 
-	/* so udelay does something sensible, assume <= 1000 bogomips */
-	loops_per_jiffy = 500000000 / HZ;
+	/* so udelay does something sensible, assume <= 2000 bogomips */
+	loops_per_jiffy = 1000000000 / HZ;
 
 #ifdef CONFIG_PPC_MULTIPLATFORM
 	/* This could be called "early setup arch", it must be done
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/smp-tbsync.c linuxppc-2.5-benh/arch/ppc/kernel/smp-tbsync.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/smp-tbsync.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/smp-tbsync.c	2003-08-25 17:39:17.000000000 +0000
@@ -0,0 +1,181 @@
+/*
+ * Smp timebase synchronization for ppc.
+ *
+ * Copyright (C) 2003 Samuel Rydh (samuel@ibrium.se)
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/unistd.h>
+#include <linux/init.h>
+#include <asm/atomic.h>
+#include <asm/smp.h>
+#include <asm/time.h>
+
+#define NUM_ITER		300
+
+enum {
+	kExit=0, kSetAndTest, kTest
+};
+
+static struct {
+	volatile int		tbu;
+	volatile int		tbl;
+	volatile int		mark;
+	volatile int		cmd;
+	volatile int		handshake;
+	int			filler[3];
+
+	volatile int		ack;
+	int			filler2[7];
+
+	volatile int		race_result;
+} *tbsync;
+
+static volatile int		running;
+
+static void __devinit
+enter_contest( int mark, int add )
+{
+	while( (int)(get_tbl() - mark) < 0 )
+		tbsync->race_result = add;
+}
+
+void __devinit
+smp_generic_take_timebase( void )
+{
+	int cmd, tbl, tbu;
+
+	local_irq_disable();
+	while( !running )
+		;
+	rmb();
+
+	for( ;; ) {
+		tbsync->ack = 1;
+		while( !tbsync->handshake )
+			;
+		rmb();
+
+		cmd = tbsync->cmd;
+		tbl = tbsync->tbl;
+		tbu = tbsync->tbu;
+		tbsync->ack = 0;
+		if( cmd == kExit )
+			return;
+
+		if( cmd == kSetAndTest ) {
+			while( tbsync->handshake )
+				;
+			asm volatile ("mttbl %0" :: "r" (tbl) );
+			asm volatile ("mttbu %0" :: "r" (tbu) );
+		} else {
+			while( tbsync->handshake )
+				;
+		}
+		enter_contest( tbsync->mark, -1 );
+	}
+	local_irq_enable();
+}
+
+static int __devinit
+start_contest( int cmd, int offset, int num )
+{
+	int i, tbu, tbl, mark, score=0;
+
+	tbsync->cmd = cmd;
+
+	local_irq_disable();
+	for( i=-3; i<num; ) {
+		tbl = get_tbl() + 400;
+		tbsync->tbu = tbu = get_tbu();
+		tbsync->tbl = tbl + offset;
+		tbsync->mark = mark = tbl + 400;
+
+		wmb();
+
+		tbsync->handshake = 1;
+		while( tbsync->ack )
+			;
+
+		while( (int)(get_tbl() - tbl) <= 0 )
+			;
+		tbsync->handshake = 0;
+		enter_contest( mark, 1 );
+
+		while( !tbsync->ack )
+			;
+
+		if( tbsync->tbu != get_tbu() || ((tbsync->tbl ^ get_tbl()) & 0x80000000) )
+			continue;
+		if( i++ > 0 )
+			score += tbsync->race_result;
+	}
+	local_irq_enable();
+	return score;
+}
+
+void __devinit
+smp_generic_give_timebase( void )
+{
+	int i, score, score2, old, min=0, max=5000, offset=1000;
+
+	printk("Synchronizing timebase\n");
+
+	/* if this fails then this kernel won't work anyway... */
+	tbsync = kmalloc( sizeof(*tbsync), GFP_KERNEL );
+	memset( tbsync, 0, sizeof(*tbsync) );
+	mb();
+	running = 1;
+
+	while( !tbsync->ack )
+		;
+
+	/* binary search */
+	for( old=-1 ; old != offset ; offset=(min+max)/2 ) {
+		score = start_contest( kSetAndTest, offset, NUM_ITER );
+
+		printk("score %d, offset %d\n", score, offset );
+
+		if( score > 0 )
+			max = offset;
+		else
+			min = offset;
+		old = offset;
+	}
+	score = start_contest( kSetAndTest, min, NUM_ITER );
+	score2 = start_contest( kSetAndTest, max, NUM_ITER );
+
+	printk( "Min %d (score %d), Max %d (score %d)\n", min, score, max, score2 );
+	score = abs( score );
+	score2 = abs( score2 );
+	offset = (score < score2) ? min : max;
+
+	/* guard against inaccurate mttb */
+	for( i=0; i<10; i++ ) {
+		start_contest( kSetAndTest, offset, NUM_ITER/10 );
+
+		if( (score2=start_contest(kTest, offset, NUM_ITER)) < 0 )
+			score2 = -score2;
+		if( score2 <= score || score2 < 20 )
+			break;
+	}
+	printk("Final offset: %d (%d/%d)\n", offset, score2, NUM_ITER );
+
+	/* exiting */
+	tbsync->cmd = kExit;
+	wmb();
+	tbsync->handshake = 1;
+	while( tbsync->ack )
+		;
+	tbsync->handshake = 0;
+	kfree( tbsync );
+	tbsync = NULL;
+	running = 0;
+
+	/* all done */
+	smp_tb_synchronized = 1;
+}
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/smp.c linuxppc-2.5-benh/arch/ppc/kernel/smp.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/smp.c	2003-10-08 02:53:39.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/smp.c	2004-01-21 23:48:55.000000000 +0000
@@ -61,10 +61,6 @@ static struct smp_ops_t *smp_ops;
 /* all cpu mappings are 1-1 -- Cort */
 volatile unsigned long cpu_callin_map[NR_CPUS];
 
-#define TB_SYNC_PASSES 4
-volatile unsigned long __initdata tb_sync_flag = 0;
-volatile unsigned long __initdata tb_offset = 0;
-
 int start_secondary(void *);
 extern int cpu_idle(void *unused);
 void smp_call_function_interrupt(void);
@@ -83,11 +79,14 @@ extern void __save_cpu_setup(void);
 #define PPC_MSG_INVALIDATE_TLB	2
 #define PPC_MSG_XMON_BREAK	3
 
-#define smp_message_pass(t,m,d,w) \
-    do { if (smp_ops) \
-	     atomic_inc(&ipi_sent); \
-	     smp_ops->message_pass((t),(m),(d),(w)); \
-       } while(0)
+static inline void
+smp_message_pass(int target, int msg, unsigned long data, int wait)
+{
+	if (smp_ops){
+		atomic_inc(&ipi_sent);
+		smp_ops->message_pass(target,msg,data,wait);
+	}
+}
 
 /*
  * Common functions
@@ -291,41 +290,6 @@ void smp_call_function_interrupt(void)
 		atomic_inc(&call_data->finished);
 }
 
-/* FIXME: Do this properly for all archs --RR */
-static spinlock_t timebase_lock = SPIN_LOCK_UNLOCKED;
-static unsigned int timebase_upper = 0, timebase_lower = 0;
-
-void __devinit
-smp_generic_give_timebase(void)
-{
-	spin_lock(&timebase_lock);
-	do {
-		timebase_upper = get_tbu();
-		timebase_lower = get_tbl();
-	} while (timebase_upper != get_tbu());
-	spin_unlock(&timebase_lock);
-
-	while (timebase_upper || timebase_lower)
-		rmb();
-}
-
-void __devinit
-smp_generic_take_timebase(void)
-{
-	int done = 0;
-
-	while (!done) {
-		spin_lock(&timebase_lock);
-		if (timebase_upper || timebase_lower) {
-			set_tb(timebase_upper, timebase_lower);
-			timebase_upper = 0;
-			timebase_lower = 0;
-			done = 1;
-		}
-		spin_unlock(&timebase_lock);
-	}
-}
-
 static void __devinit smp_store_cpu_info(int id)
 {
         struct cpuinfo_PPC *c = &cpu_data[id];
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/time.c linuxppc-2.5-benh/arch/ppc/kernel/time.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/time.c	2003-10-08 02:53:39.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/time.c	2003-12-31 02:50:43.000000000 +0000
@@ -56,6 +56,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/time.h>
 #include <linux/init.h>
+#include <linux/profile.h>
 
 #include <asm/segment.h>
 #include <asm/io.h>
@@ -107,17 +108,23 @@ static inline int tb_delta(unsigned *jif
 	return delta;
 }
 
-extern unsigned long prof_cpu_mask;
-extern unsigned int * prof_buffer;
-extern unsigned long prof_len;
-extern unsigned long prof_shift;
 extern char _stext;
 
-static inline void ppc_do_profile (unsigned long nip)
+static inline void ppc_do_profile(struct pt_regs *regs)
 {
+	unsigned long nip;
+	extern unsigned long prof_cpu_mask;
+
+	profile_hook(regs);
+
+	if (user_mode(regs))
+		return;
+
 	if (!prof_buffer)
 		return;
 
+	nip = instruction_pointer(regs);
+
 	/*
 	 * Only measure the CPUs specified by /proc/irq/prof_cpu_mask.
 	 * (default is all CPUs.)
@@ -149,6 +156,13 @@ void timer_interrupt(struct pt_regs * re
 	unsigned jiffy_stamp = last_jiffy_stamp(cpu);
 	extern void do_IRQ(struct pt_regs *);
 
+#ifdef CONFIG_XMON_FW
+	extern volatile unsigned int xmon_fw_kick;
+	extern void xmon(void *);
+	if (xmon_fw_kick)
+		xmon(regs);
+#endif /* CONFIG_XMON_FW */
+
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
@@ -156,8 +170,7 @@ void timer_interrupt(struct pt_regs * re
 
 	while ((next_dec = tb_ticks_per_jiffy - tb_delta(&jiffy_stamp)) < 0) {
 		jiffy_stamp += tb_ticks_per_jiffy;
-		if (!user_mode(regs))
-			ppc_do_profile(instruction_pointer(regs));
+		ppc_do_profile(regs);
 	  	if (smp_processor_id())
 			continue;
 
diff -purN /dev/shm/linux-2.5/arch/ppc/kernel/traps.c linuxppc-2.5-benh/arch/ppc/kernel/traps.c
--- /dev/shm/linux-2.5/arch/ppc/kernel/traps.c	2003-09-26 23:31:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/kernel/traps.c	2003-10-14 07:28:02.000000000 +0000
@@ -380,14 +380,25 @@ check_bug_trap(struct pt_regs *regs)
 		return 0;
 	if (bug->line & BUG_WARNING_TRAP) {
 		/* this is a WARN_ON rather than BUG/BUG_ON */
+#ifdef CONFIG_XMON
+		xmon_printf(KERN_ERR "Badness in %s at %s:%d\n",
+		       bug->function, bug->file,
+		       bug->line & ~BUG_WARNING_TRAP);
+#endif /* CONFIG_XMON */		
 		printk(KERN_ERR "Badness in %s at %s:%d\n",
 		       bug->function, bug->file,
 		       bug->line & ~BUG_WARNING_TRAP);
 		dump_stack();
 		return 1;
 	}
+#ifdef CONFIG_XMON
+	xmon_printf(KERN_CRIT "kernel BUG in %s at %s:%d!\n",
+	       bug->function, bug->file, bug->line);
+	xmon(regs);
+#endif /* CONFIG_XMON */
 	printk(KERN_CRIT "kernel BUG in %s at %s:%d!\n",
 	       bug->function, bug->file, bug->line);
+
 	return 0;
 }
 
@@ -588,6 +599,7 @@ AltivecAssistException(struct pt_regs *r
 }
 #endif /* CONFIG_ALTIVEC */
 
+
 void __init trap_init(void)
 {
 }
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/cachemap.c linuxppc-2.5-benh/arch/ppc/mm/cachemap.c
--- /dev/shm/linux-2.5/arch/ppc/mm/cachemap.c	2004-01-19 06:28:33.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/cachemap.c	2004-01-21 00:29:21.000000000 +0000
@@ -36,6 +36,7 @@
 #include <linux/bootmem.h>
 #include <linux/highmem.h>
 #include <linux/pci.h>
+#include <linux/interrupt.h>
 
 #include <asm/pgalloc.h>
 #include <asm/prom.h>
@@ -157,18 +158,64 @@ void consistent_sync(void *vaddr, size_t
 	}
 }
 
+#ifdef CONFIG_HIGHMEM
 /*
- * consistent_sync_page make a page are consistent. identical
- * to consistent_sync, but takes a struct page instead of a virtual address
+ * consistent_sync_page() implementation for non cache coherent
+ * systems using highmem. In this case, each page of a buffer
+ * must be kmapped/kunmapped in order to have a virtual address
+ * for consistent_sync(). This must be interrupt safe so hard
+ * interrupts are disabled and kmap_atomic() are used when in an
+ * interrupt context.
  */
+static inline void __consistent_sync_page(struct page *page,
+		unsigned long offset, size_t size, int direction,
+		int in_int)
+{
+	size_t seg_size = min((size_t)PAGE_SIZE, size) - offset;
+	size_t cur_size = seg_size;
+	unsigned long flags, start, seg_offset = offset;
+	int nr_segs = PAGE_ALIGN(size + (PAGE_SIZE - offset))/PAGE_SIZE;
+	int seg_nr = 0;
+
+	if (in_int) local_irq_save(flags);
+
+	do {
+		if (in_int)
+			start = (unsigned long)kmap_atomic(page + seg_nr, KM_PPC_SYNC_PAGE) + seg_offset; 
+		else
+			start = (unsigned long)kmap(page + seg_nr) + seg_offset; 
+		/* Sync this buffer segment */
+		consistent_sync((void *)start, seg_size, direction);
+		if (in_int)
+			kunmap_atomic((void *)start, KM_PPC_SYNC_PAGE);
+		else
+			kunmap(page + seg_nr);
+		seg_nr++;
+		/* Calculate next buffer segment size */
+		seg_size = min((size_t)PAGE_SIZE, size - cur_size);
+		/* Add the segment size to our running total */
+		cur_size += seg_size;
+		seg_offset = 0;
+	} while (seg_nr < nr_segs);
+
+	if (in_int) local_irq_restore(flags);
+}
+#endif /* CONFIG_HIGHMEM */
 
+/*
+ * consistent_sync_page makes memory consistent. identical
+ * to consistent_sync, but takes a struct page instead of a
+ * virtual address
+ */
 void consistent_sync_page(struct page *page, unsigned long offset,
 	size_t size, int direction)
 {
-	unsigned long start;
-
-	start = (unsigned long)page_address(page) + offset;
+#ifdef CONFIG_HIGHMEM
+	__consistent_sync_page(page, offset, size, direction, in_interrupt());
+#else
+	unsigned long start = (unsigned long)page_address(page) + offset; 
 	consistent_sync((void *)start, size, direction);
+#endif
 }
 
 EXPORT_SYMBOL(consistent_sync_page);
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/hashtable.S linuxppc-2.5-benh/arch/ppc/mm/hashtable.S
--- /dev/shm/linux-2.5/arch/ppc/mm/hashtable.S	2003-10-11 13:58:20.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/hashtable.S	2003-12-24 07:25:38.000000000 +0000
@@ -37,6 +37,32 @@
 #endif /* CONFIG_SMP */
 
 /*
+ * Sync CPUs with hash_page taking & releasing the hash
+ * table lock
+ */
+#ifdef CONFIG_SMP
+	.text
+_GLOBAL(hash_page_sync)
+	lis	r8,mmu_hash_lock@h
+	ori	r8,r8,mmu_hash_lock@l
+	lis	r0,0x0fff
+	b	10f
+11:	lwz	r6,0(r8)
+	cmpwi	0,r6,0
+	bne	11b
+10:	lwarx	r6,0,r8
+	cmpwi	0,r6,0
+	bne-	11b
+	stwcx.	r0,0,r8
+	bne-	10b
+	isync
+	eieio
+	li	r0,0
+	stw	r0,0(r8)
+	blr	
+#endif
+
+/*
  * Load a PTE into the hash table, if possible.
  * The address is in r4, and r3 contains an access flag:
  * _PAGE_RW (0x400) if a write.
@@ -417,21 +443,6 @@ _GLOBAL(hash_page_patch_C)
 	lwz	r6,next_slot@l(r4)
 	addi	r6,r6,PTE_SIZE
 	andi.	r6,r6,7*PTE_SIZE
-#ifdef CONFIG_POWER4
-	/*
-	 * Since we don't have BATs on POWER4, we rely on always having
-	 * PTEs in the hash table to map the hash table and the code
-	 * that manipulates it in virtual mode, namely flush_hash_page and
-	 * flush_hash_segments.  Otherwise we can get a DSI inside those
-	 * routines which leads to a deadlock on the hash_table_lock on
-	 * SMP machines.  We avoid this by never overwriting the first
-	 * PTE of each PTEG if it is already valid.
-	 *	-- paulus.
-	 */
-	bne	102f
-	li	r6,PTE_SIZE
-102:
-#endif /* CONFIG_POWER4 */
 	stw	r6,next_slot@l(r4)
 	add	r4,r3,r6
 
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/init.c linuxppc-2.5-benh/arch/ppc/mm/init.c
--- /dev/shm/linux-2.5/arch/ppc/mm/init.c	2003-10-08 02:53:39.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/init.c	2003-10-14 07:28:03.000000000 +0000
@@ -291,6 +291,8 @@ void __init MMU_init(void)
 		ppc_md.progress("MMU:exit", 0x211);
 
 #ifdef CONFIG_BOOTX_TEXT
+	/* By default, we are no longer mapped */
+       	boot_text_mapped = 0;
 	/* Must be done last, or ppc_md.progress will die. */
 	map_boot_text();
 #endif
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/mmu_context.c linuxppc-2.5-benh/arch/ppc/mm/mmu_context.c
--- /dev/shm/linux-2.5/arch/ppc/mm/mmu_context.c	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/mmu_context.c	2003-10-23 19:51:52.000000000 +0000
@@ -81,6 +81,16 @@ steal_context(void)
 		next_mmu_context = FIRST_CONTEXT;
 	mm = context_mm[next_mmu_context];
 	flush_tlb_mm(mm);
+#ifdef CONFIG_44x
+	/*
+	 * PPC44x has a virtually tagged icache. It is necessary
+	 * to invalidate all icache lines that match the PID of
+	 * the stolen context.  Identifying these lines would
+	 * require too much overhead, so simply flush the entire
+	 * icache array. -Matt
+	 */
+	flush_instruction_cache();
+#endif
 	destroy_context(mm);
 }
 #endif /* FEW_CONTEXTS */
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/pgtable.c linuxppc-2.5-benh/arch/ppc/mm/pgtable.c
--- /dev/shm/linux-2.5/arch/ppc/mm/pgtable.c	2003-10-02 07:11:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/pgtable.c	2003-12-24 07:25:39.000000000 +0000
@@ -44,6 +44,10 @@ int io_bat_index;
 
 extern char etext[], _stext[];
 
+#ifdef CONFIG_SMP
+extern void hash_page_sync(void);
+#endif
+
 #ifdef HAVE_BATS
 extern unsigned long v_mapped_by_bats(unsigned long va);
 extern unsigned long p_mapped_by_bats(unsigned long pa);
@@ -109,11 +113,17 @@ struct page *pte_alloc_one(struct mm_str
 
 void pte_free_kernel(pte_t *pte)
 {
+#ifdef CONFIG_SMP
+	hash_page_sync();
+#endif
 	free_page((unsigned long)pte);
 }
 
 void pte_free(struct page *pte)
 {
+#ifdef CONFIG_SMP
+	hash_page_sync();
+#endif
 	__free_page(pte);
 }
 
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/ppc_mmu.c linuxppc-2.5-benh/arch/ppc/mm/ppc_mmu.c
--- /dev/shm/linux-2.5/arch/ppc/mm/ppc_mmu.c	2003-10-11 13:58:20.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/ppc_mmu.c	2003-11-17 01:29:48.000000000 +0000
@@ -83,6 +83,9 @@ unsigned long p_mapped_by_bats(unsigned 
 
 unsigned long __init mmu_mapin_ram(void)
 {
+#ifdef CONFIG_POWER4
+	return 0;
+#else
 	unsigned long tot, bl, done;
 	unsigned long max_size = (256<<20);
 	unsigned long align;
@@ -119,6 +122,7 @@ unsigned long __init mmu_mapin_ram(void)
 	}
 
 	return done;
+#endif
 }
 
 /*
@@ -244,9 +248,10 @@ void __init MMU_init_hw(void)
 	Hash = mem_pieces_find(Hash_size, Hash_size);
 	cacheable_memzero(Hash, Hash_size);
 	_SDR1 = __pa(Hash) | SDR1_LOW_BITS;
-	Hash_end = (PTE *) ((unsigned long)Hash + Hash_size);
 #endif /* CONFIG_POWER4 */
 
+	Hash_end = (PTE *) ((unsigned long)Hash + Hash_size);
+
 	printk("Total memory = %ldMB; using %ldkB for hash table (at %p)\n",
 	       total_memory >> 20, Hash_size >> 10, Hash);
 
diff -purN /dev/shm/linux-2.5/arch/ppc/mm/tlb.c linuxppc-2.5-benh/arch/ppc/mm/tlb.c
--- /dev/shm/linux-2.5/arch/ppc/mm/tlb.c	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/mm/tlb.c	2003-12-31 03:29:58.000000000 +0000
@@ -47,6 +47,26 @@ void flush_hash_entry(struct mm_struct *
 }
 
 /*
+ * Called by ptep_test_and_clear_young()
+ */
+void flush_hash_one_pte(pte_t *ptep)
+{
+	struct page *ptepage;
+	struct mm_struct *mm;
+	unsigned long ptephys;
+	unsigned long addr;
+
+	if (Hash == 0)
+		return;
+	
+	ptepage = virt_to_page(ptep);
+	mm = (struct mm_struct *) ptepage->mapping;
+	ptephys = __pa(ptep) & PAGE_MASK;
+	addr = ptepage->index + (((unsigned long)ptep & ~PAGE_MASK) << 9);
+	flush_hash_pages(mm->context, addr, ptephys, 1);
+}
+
+/*
  * Called at the end of a mmu_gather operation to make sure the
  * TLB flush is completely done.
  */
diff -purN /dev/shm/linux-2.5/arch/ppc/ocp/ocp-hotplug.c linuxppc-2.5-benh/arch/ppc/ocp/ocp-hotplug.c
--- /dev/shm/linux-2.5/arch/ppc/ocp/ocp-hotplug.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/ocp/ocp-hotplug.c	2003-01-10 05:30:56.000000000 +0000
@@ -0,0 +1,99 @@
+#include <asm/ocp.h>
+#include <linux/module.h>
+#include <linux/kmod.h>		/* for hotplug_path */
+
+#ifndef FALSE
+#define FALSE	(0)
+#define TRUE	(!FALSE)
+#endif
+
+static void
+run_sbin_hotplug(struct ocp_device *pdev, int insert)
+{
+	int i;
+	char *argv[3], *envp[8];
+	char id[20], sub_id[24], bus_id[24], class_id[20];
+
+	if (!hotplug_path[0])
+		return;
+#if 0
+	sprintf(class_id, "PCI_CLASS=%04X", pdev->class);
+	sprintf(id, "PCI_ID=%04X:%04X", pdev->vendor, pdev->device);
+	sprintf(sub_id, "PCI_SUBSYS_ID=%04X:%04X", pdev->subsystem_vendor, pdev->subsystem_device);
+	sprintf(bus_id, "PCI_SLOT_NAME=%s", pdev->slot_name);
+#endif
+	i = 0;
+	argv[i++] = hotplug_path;
+	argv[i++] = "ocp";
+	argv[i] = 0;
+
+	i = 0;
+	/* minimal command environment */
+	envp[i++] = "HOME=/";
+	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	
+	/* other stuff we want to pass to /sbin/hotplug */
+	envp[i++] = class_id;
+	envp[i++] = id;
+	envp[i++] = sub_id;
+	envp[i++] = bus_id;
+	if (insert)
+		envp[i++] = "ACTION=add";
+	else
+		envp[i++] = "ACTION=remove";
+	envp[i] = 0;
+
+	call_usermodehelper (argv [0], argv, envp);
+}
+
+/**
+ * ocp_insert_device - insert a hotplug device
+ * @dev: the device to insert
+ * @bus: where to insert it
+ *
+ * Add a new device to the device lists and notify userspace (/sbin/hotplug).
+ */
+void
+ocp_insert_device(struct ocp_device *dev, struct ocp_bus *bus)
+{
+	list_add_tail(&dev->bus_list, &bus->devices);
+	list_add_tail(&dev->global_list, &ocp_devices);
+	/* notify userspace of new hotplug device */
+	run_sbin_hotplug(dev, TRUE);
+}
+
+#if 0
+static void
+ocp_free_resources(struct ocp_device *dev)
+{
+	int i;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *res = dev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+}
+#endif
+
+/**
+ * ocp_remove_device - remove a hotplug device
+ * @dev: the device to remove
+ *
+ * Delete the device structure from the device lists and 
+ * notify userspace (/sbin/hotplug).
+ */
+void
+ocp_remove_device(struct ocp_device *dev)
+{
+	put_device(&dev->dev);
+	list_del(&dev->bus_list);
+	list_del(&dev->global_list);
+//	ocp_free_resources(dev);
+
+	/* notify userspace of hotplug device removal */
+	run_sbin_hotplug(dev, FALSE);
+}
+
+EXPORT_SYMBOL(ocp_insert_device);
+EXPORT_SYMBOL(ocp_remove_device);
diff -purN /dev/shm/linux-2.5/arch/ppc/ocp/ocp-power.c linuxppc-2.5-benh/arch/ppc/ocp/ocp-power.c
--- /dev/shm/linux-2.5/arch/ppc/ocp/ocp-power.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/ocp/ocp-power.c	2003-01-10 05:30:56.000000000 +0000
@@ -0,0 +1,195 @@
+/*
+ * FILE NAME: ocp-power.c
+ *
+ * BRIEF MODULE DESCRIPTION: 
+ * Based on drivers/pci/power, Copyright (c) 1997--1999 Martin Mares
+ *
+ * Maintained by: Armin <akuster@mvista.com>
+ *
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/ocp.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+
+/*
+ * OCP Power management..
+ *
+ * This needs to be done centralized, so that we power manage OCP
+ * devices in the right order: we should not shut down OCP bridges
+ * before we've shut down the devices behind them, and we should
+ * not wake up devices before we've woken up the bridge to the
+ * device.
+ *
+ * We do not touch devices that don't have a driver that exports
+ * a suspend/resume function. That is just too dangerous. If the default
+ * OCP suspend/resume functions work for a device, the driver can
+ * easily implement them (ie just have a suspend function that calls
+ * the ocp_set_power_state() function).
+ */
+
+static int ocp_pm_save_state_device(struct ocp_device *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->save_state) 
+			error = driver->save_state(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend_device(struct ocp_device *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->suspend)
+			error = driver->suspend(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_resume_device(struct ocp_device *dev)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_driver *driver = dev->driver;
+		if (driver && driver->resume)
+			error = driver->resume(dev);
+	}
+	return error;
+}
+
+static int ocp_pm_save_state_bus(struct ocp_bus *bus, u32 state)
+{
+	struct list_head *list;
+	int error = 0;
+
+	list_for_each(list, &bus->children) {
+		error = ocp_pm_save_state_bus(ocp_bus_b(list),state);
+		if (error) return error;
+	}
+	list_for_each(list, &bus->devices) {
+		error = ocp_pm_save_state_device(ocp_dev_b(list),state);
+		if (error) return error;
+	}
+	return 0;
+}
+
+static int ocp_pm_suspend_bus(struct ocp_bus *bus, u32 state)
+{
+	struct list_head *list;
+
+	/* Walk the bus children list */
+	list_for_each(list, &bus->children) 
+		ocp_pm_suspend_bus(ocp_bus_b(list),state);
+
+	/* Walk the device children list */
+	list_for_each(list, &bus->devices)
+		ocp_pm_suspend_device(ocp_dev_b(list),state);
+	return 0;
+}
+
+static int ocp_pm_resume_bus(struct ocp_bus *bus)
+{
+	struct list_head *list;
+
+	/* Walk the device children list */
+	list_for_each(list, &bus->devices)
+		ocp_pm_resume_device(ocp_dev_b(list));
+
+	/* And then walk the bus children */
+	list_for_each(list, &bus->children)
+		ocp_pm_resume_bus(ocp_bus_b(list));
+	return 0;
+}
+
+static int ocp_pm_save_state(u32 state)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+	int error = 0;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		error = ocp_pm_save_state_bus(bus,state);
+		if (!error)
+			error = ocp_pm_save_state_device(bus->self,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend(u32 state)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		ocp_pm_suspend_bus(bus,state);
+		ocp_pm_suspend_device(bus->self,state);
+	}
+	return 0;
+}
+
+static int ocp_pm_resume(void)
+{
+	struct list_head *list;
+	struct ocp_bus *bus;
+
+	list_for_each(list, &ocp_root_buses) {
+		bus = ocp_bus_b(list);
+		ocp_pm_resume_device(bus->self);
+		ocp_pm_resume_bus(bus);
+	}
+	return 0;
+}
+
+static int 
+ocp_pm_callback(struct pm_dev *pm_device, pm_request_t rqst, void *data)
+{
+	int error = 0;
+
+	switch (rqst) {
+	case PM_SAVE_STATE:
+		error = ocp_pm_save_state((unsigned long)data);
+		break;
+	case PM_SUSPEND:
+		error = ocp_pm_suspend((unsigned long)data);
+		break;
+	case PM_RESUME:
+		error = ocp_pm_resume();
+		break;
+	default: break;
+	}
+	return error;
+}
+
+static int __init ocp_pm_init(void)
+{
+	pm_register(PM_OCP_DEV, 0, ocp_pm_callback);
+	return 0;
+}
+
+subsys_initcall(ocp_pm_init);
diff -purN /dev/shm/linux-2.5/arch/ppc/oprofile/Kconfig linuxppc-2.5-benh/arch/ppc/oprofile/Kconfig
--- /dev/shm/linux-2.5/arch/ppc/oprofile/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/oprofile/Kconfig	2003-12-31 02:50:43.000000000 +0000
@@ -0,0 +1,23 @@
+
+menu "Profiling support"
+	depends on EXPERIMENTAL
+
+config PROFILING
+	bool "Profiling support (EXPERIMENTAL)"
+	help
+	  Say Y here to enable the extended profiling support mechanisms used
+	  by profilers such as OProfile.
+
+
+config OPROFILE
+	tristate "OProfile system profiling (EXPERIMENTAL)"
+	depends on PROFILING
+	help
+	  OProfile is a profiling system capable of profiling the
+	  whole system, include the kernel, kernel modules, libraries,
+	  and applications.
+
+	  If unsure, say N.
+
+endmenu
+
diff -purN /dev/shm/linux-2.5/arch/ppc/oprofile/Makefile linuxppc-2.5-benh/arch/ppc/oprofile/Makefile
--- /dev/shm/linux-2.5/arch/ppc/oprofile/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/oprofile/Makefile	2003-12-31 02:50:44.000000000 +0000
@@ -0,0 +1,9 @@
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS := $(addprefix ../../../drivers/oprofile/, \
+		oprof.o cpu_buffer.o buffer_sync.o \
+		event_buffer.o oprofile_files.o \
+		oprofilefs.o oprofile_stats.o \
+		timer_int.o )
+
+oprofile-y := $(DRIVER_OBJS) init.o
diff -purN /dev/shm/linux-2.5/arch/ppc/oprofile/init.c linuxppc-2.5-benh/arch/ppc/oprofile/init.c
--- /dev/shm/linux-2.5/arch/ppc/oprofile/init.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/oprofile/init.c	2003-12-31 02:50:45.000000000 +0000
@@ -0,0 +1,25 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+extern void timer_init(struct oprofile_operations ** ops);
+
+int __init oprofile_arch_init(struct oprofile_operations ** ops)
+{
+	return -ENODEV;
+}
+
+
+void oprofile_arch_exit(void)
+{
+}
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/Kconfig linuxppc-2.5-benh/arch/ppc/platforms/4xx/Kconfig
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/Kconfig	2003-09-17 16:03:24.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/Kconfig	2003-09-27 09:36:18.000000000 +0000
@@ -11,6 +11,9 @@ choice
 	depends on 40x
 	default WALNUT
 
+config ARCTIC2
+	bool "Arctic II"
+
 config ASH
 	bool "Ash"
 
@@ -36,6 +39,9 @@ config OAK
 	  More information on these boards is available at:
 	  <http://www.chips.ibm.com/products/powerpc/tools/evk_pn.html#GCX>.
 
+config RAINIER
+	bool "Rainier"
+
 config REDWOOD_4
 	bool "Redwood-4"
 
@@ -108,16 +114,16 @@ config 440A
 	depends on 440GX
 	default y
 
-# All 405-based cores up until the 405GPR and 405EP have this errata.
+# All 405-based cores have this errata.  This leaves out the 403GCX
 config IBM405_ERR77
 	bool
-	depends on 40x && !403GCX && !405GPR
+	depends on 40x && !403GCX
 	default y
 
-# All 40x-based cores, up until the 405GPR and 405EP have this errata.
+# All 40x-based cores have this errata.
 config IBM405_ERR51
 	bool
-	depends on 40x && !405GPR
+	depends on 40x
 	default y
 
 
@@ -133,7 +139,7 @@ config BOOKE
 
 config IBM_OCP
 	bool
-	depends on ASH || BEECH || CEDAR || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
+	depends on ARCTIC || ASH || BEECH || CEDAR || CPCI405 || EBONY || EP405 || OCOTEA || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
 config IBM_EMAC4
@@ -167,7 +173,8 @@ config 405GPR
 
 config 405LP
 	bool
-	depends on CEDAR
+	depends on ARCTIC2 || BEECH
+	default y
 
 config STB03xxx
 	bool
@@ -176,7 +183,7 @@ config STB03xxx
 
 config EMBEDDEDBOOT
 	bool
-	depends on EP405
+	depends on EP405 || RAINIER
 	default y
 
 config IBM_OPENBIOS
@@ -184,6 +191,30 @@ config IBM_OPENBIOS
 	depends on ASH || BEECH || CEDAR || REDWOOD_4 || REDWOOD_5 || REDWOOD_6 || SYCAMORE || WALNUT
 	default y
 
+config IBM_PIBS
+	bool
+	depends on ARCTIC2
+	default y
+
+config PPC4xx_DMA
+	bool "PPC4xx DMA controller support"
+	depends on 4xx
+
+config STBXXX_DMA
+	bool
+	depends on STB03xxx && PPC4xx_DMA
+	default y
+
+config PPC4xx_EDMA
+	bool
+	depends on !STB03xxx && PPC4xx_DMA
+	default y
+
+config OCP
+	bool
+	depends on IBM_OCP
+	default y
+
 config 405_DMA
 	bool "Blue Logic DMA"
 	depends on 40x
@@ -205,6 +236,11 @@ config UART0_TTYS1
 
 endchoice
 
+config GEN550_KGDB
+	bool
+	depends on EBONY
+	default y
+
 config SERIAL_SICC
 	bool "SICC Serial port support"
 	depends on STB03xxx
@@ -218,4 +254,10 @@ config SERIAL_SICC_CONSOLE
 	bool
 	depends on SERIAL_SICC && UART0_TTYS1
 	default y
+
+config 405LP_PM_BUTTON
+	bool
+	depends on 405LP
+	default y
+
 endmenu
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/Makefile linuxppc-2.5-benh/arch/ppc/platforms/4xx/Makefile
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/Makefile	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/Makefile	2003-09-12 17:39:40.000000000 +0000
@@ -1,6 +1,7 @@
 #
 # Makefile for the PowerPC 4xx linux kernel.
 
+obj-$(CONFIG_ARCTIC2)		+= arctic2.o subzero.o
 obj-$(CONFIG_ASH)		+= ash.o
 obj-$(CONFIG_BEECH)		+= beech.o
 obj-$(CONFIG_CEDAR)		+= cedar.o
@@ -9,6 +10,7 @@ obj-$(CONFIG_EBONY)		+= ebony.o
 obj-$(CONFIG_EP405)		+= ep405.o
 obj-$(CONFIG_OAK)		+= oak.o
 obj-$(CONFIG_OCOTEA)		+= ocotea.o
+obj-$(CONFIG_RAINIER)		+= rainier.o 
 obj-$(CONFIG_REDWOOD_4)		+= redwood.o
 obj-$(CONFIG_REDWOOD_5)		+= redwood5.o
 obj-$(CONFIG_REDWOOD_6)		+= redwood6.o
@@ -26,3 +28,4 @@ obj-$(CONFIG_405LP)		+= ibm405lp.o
 obj-$(CONFIG_EBONY)		+= ibm440gp.o
 obj-$(CONFIG_OCOTEA)		+= ibm440gx.o
 obj-$(CONFIG_405GPR)		+= ibm405gpr.o
+obj-$(CONFIG_VIRTEX_II_PRO)	+= virtex-ii_pro.o
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/arctic2.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/arctic2.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/arctic2.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/arctic2.c	2003-06-12 22:26:52.000000000 +0000
@@ -0,0 +1,236 @@
+/*
+ * arch/ppc/platforms/arctic2.c  Platform setup for the IBM Arctic-2 reference platform
+ *					with the Subzero core card and Beech personality card
+ * 				      Based on beech.c by Bishop Brock 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * keninoue@us.ibm.com
+ *
+ * David Gibson
+ * IBM Ozlabs, Canberra, Australia
+ * arctic@gibson.dropbear.id.au
+ */
+
+#include <linux/blk.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/rtc.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <platforms/4xx/arctic2.h>
+
+/* Virtual address of the PCCF macro, which needs to be ioremap()ed
+ * and initialized by the board setup code. */
+volatile u16 *pccf_4xx_macro_vaddr;
+unsigned long pccf_4xx_io_base;
+unsigned long pccf_4xx_mem_base;
+EXPORT_SYMBOL(pccf_4xx_macro_vaddr);
+EXPORT_SYMBOL(pccf_4xx_io_base);
+EXPORT_SYMBOL(pccf_4xx_mem_base);
+
+volatile u8 *arctic2_fpga_regs;
+EXPORT_SYMBOL(arctic2_fpga_regs);
+
+/* Different Arctic2 versions have different capabilities in terms of dynamic
+   and static power control.  Older units do not support the APM peripheral or
+   voltage scaling. The unit's capabilities are determined at boot and recorded
+   in these variables.  Run-time rather than compile-time control is used to
+   simplify kernel distribution. */
+
+int arctic2_supports_apm = 0;
+int arctic2_supports_dvs = 0;
+
+#define GPIO0_OR 	((u32 *)(GPIO0_BASE + 0))
+#define GPIO0_TCR	((u32 *)(GPIO0_BASE + 4))
+#define GPIO0_ODR	((u32 *)(GPIO0_BASE + 8))
+#define GPIO0_IR	((u32 *)(GPIO0_BASE + 12))
+
+void __init
+board_setup_irq(void)
+{
+	ibm405lp_setup_apm_pic();
+
+	/*
+	 * Set USB interrupt edge-triggered polarity=rising edge.
+	 */
+
+	mtdcr(DCRN_UIC0_TR, mfdcr(DCRN_UIC0_TR) | (1 << (31 - UIC_IRQ_EIR0)));
+	mtdcr(DCRN_UIC0_PR, mfdcr(DCRN_UIC0_PR) | (1 << (31 - UIC_IRQ_EIR0)));
+}
+
+void
+arctic2_poweroff(void)
+{
+	if (! arctic2_fpga_regs)
+		BUG();
+
+	cli();
+
+	writeb(1, ARCTIC2_FPGA_POWERDOWN);
+	eieio();
+
+	while (1)
+		;
+}
+
+void
+arctic2_set_lcdpower(int on)
+{
+	iobarrier_rw(); 
+	if (on)
+		out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) | 0x80000000 );
+	else
+		out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) & ~0x80000000);
+	iobarrier_rw(); 
+	udelay(100); /* KI guard time */
+}
+
+EXPORT_SYMBOL(arctic2_poweroff);
+EXPORT_SYMBOL(arctic2_set_lcdpower);
+
+/* Units that support APM/DVS pull GPIO3 low as a strap. On older units this
+   GPIO is pulled high. After boot this can be used as a trace/debug signal, as
+   it has no other purpose on the board. */
+
+static void __init
+check_apm_dvs_support(void)
+{
+	u32 gpio3 = 0x10000000;
+
+	iobarrier_rw();
+	out_be32(GPIO0_TCR, in_be32(GPIO0_TCR) & ~gpio3);
+	out_be32(GPIO0_ODR, in_be32(GPIO0_ODR) & ~gpio3);
+	iobarrier_rw();
+	arctic2_supports_apm = ((in_be32(GPIO0_IR) & gpio3) == 0);
+	arctic2_supports_dvs = arctic2_supports_apm;
+}
+
+void __init
+arctic_setup_arch(void)
+{
+	cpc0_cgcr1_t	cgcr1;
+	u32 cfg;
+
+	ppc4xx_setup_arch();
+
+#ifdef CONFIG_GEN_RTC
+	ppc_md.time_init = ibm405lp_time_init;
+	ppc_md.set_rtc_time = ibm405lp_set_rtc_time;
+	ppc_md.get_rtc_time = ibm405lp_get_rtc_time;
+#endif
+	ppc_md.power_off = arctic2_poweroff;
+
+	/* Set up the EBC, then Disable the LCD controller, which may have been
+	   left on by the BIOS. */
+
+	subzero_core_ebc_setup();
+
+	/* Turn on PerClk, so that the SDIO chip works */
+	/* FIXME: This is bad for power usage - this will want to be
+	 * fixed to turn the clock on "on demand" when we merge with
+	 * the DPM code. */
+	cgcr1.reg=mfdcr(DCRN_CPC0_CGCR1);
+	cgcr1.fields.csel=CPC0_CGCR1_CSEL_PERCLK;
+	mtdcr(DCRN_CPC0_CGCR1, cgcr1.reg);
+
+	/* Configure the Arctic-II specific EBC banks */
+
+	/* Bank 1: 16-bit FPGA peripherals (ethernet data, SDIO, USB, DOC)
+	 * 1MB, RW, 16-bit at 0xf9000000-0xf90fffff */
+	/* The access parameters are programmed assuming a 33Mhz EBC
+	   clock, which is true for nearly all the operating points we
+	   have defined:
+	   	BME=0, TWT=5, CSN=0, OEN=1, WBN=1, WBF=1 TH=4
+		RE=1, SOR=0, BEM=0, PEN=0
+	 */
+	mtdcri(DCRN_EBC0, BnAP(1), 0x02815900);
+	mtdcri(DCRN_EBC0, BnCR(1), ARCTIC2_FPGA16_PADDR | 0x1a000);
+
+	/* Bank 2: 8-bit FPGA peripherals (switch/control, ethernet regs, TCPA)
+	 * 1MB, RW, 8-bit at 0xf8000000-0xf80fffff */
+	mtdcri(DCRN_EBC0, BnAP(2), 0x02815580);
+	mtdcri(DCRN_EBC0, BnCR(2), ARCTIC2_FPGA8_PADDR | 0x18000);
+
+	mtdcri(DCRN_LCD0, DER, 0);
+
+	/* Data access of the Arctic2 debug sled ethernet chip will time out
+	   under certain conditions unless the EBC ready wait is extended. The
+	   data sheet doesn't give a bound on this, so we allow a generous
+	   amount of time. Note that this problem is normally masked by the
+	   PCMCIA setup, which sets an even longer timeout. */
+
+	cfg = mfdcri(DCRN_EBC0, CFG);
+	if ((cfg & EBC_CFG_RTC) < EBC_CFG_RTC_128)
+		mtdcri(DCRN_EBC0, CFG, (cfg & ~EBC_CFG_RTC) | EBC_CFG_RTC_128);
+}
+
+
+void __init
+arctic_map_io(void)
+{
+	ppc4xx_map_io();
+	ibm405lp_setup_pccf(&pccf_4xx_macro_vaddr, &pccf_4xx_io_base,
+			    &pccf_4xx_mem_base);
+
+#if 0
+	if (! request_mem_region(ARCTIC2_FPGA8_PADDR,
+				 ARCTIC2_FPGA_REGS_EXTENT,
+				 "Arctic-2 FPGA Control Registers"))
+		BUG(); /* If someone's grabbed these addresses
+			* already, something's seriously wrong */
+#endif
+
+	arctic2_fpga_regs = ioremap(ARCTIC2_FPGA8_PADDR,
+				    ARCTIC2_FPGA_REGS_EXTENT);
+	if (!arctic2_fpga_regs)
+		BUG();
+
+	check_apm_dvs_support();
+	return;
+}
+
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = arctic_setup_arch;
+	ppc_md.setup_io_mappings = arctic_map_io;
+}
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End: */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/arctic2.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/arctic2.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/arctic2.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/arctic2.h	2003-06-12 22:26:52.000000000 +0000
@@ -0,0 +1,148 @@
+/*
+ * arch/ppc/platforms/arctic2.h   Platform definitions for the IBM Arctic-II
+ *				based on beech.h by Bishop Brock
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * keninoue@us.ibm.com
+ *
+ * David Gibson
+ * IBM Ozlabs, Canberra, Australia
+ * arctic@gibson.dropbear.id.au
+ * 
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_ARCTIC2_H__
+#define __ASM_ARCTIC2_H__
+
+#include <platforms/4xx/subzero.h>
+
+#ifndef __ASSEMBLY__
+
+/* Physical address for the 8-bit peripheral bank */
+#define ARCTIC2_FPGA8_PADDR	(0xf8000000)
+
+/* Physical address for the 16-bit peripheral bank */
+#define ARCTIC2_FPGA16_PADDR	(0xf9000000)
+
+/* Virtual address of the FPGA control registers */
+extern volatile u8 *arctic2_fpga_regs;
+
+#define ARCTIC2_FPGA_REGS_EXTENT	(0xf)
+#define ARCTIC2_FPGA_POWERDOWN		(arctic2_fpga_regs + 0x0)
+#define ARCTIC2_FPGA_BUTTONS		(arctic2_fpga_regs + 0x1)
+#define ARCTIC2_FPGA_MULTIWAY		(arctic2_fpga_regs + 0x2)
+#define ARCTIC2_FPGA_IRQ_ENABLE		(arctic2_fpga_regs + 0x3)
+#define ARCTIC2_FPGA_PCCF_POWER		(arctic2_fpga_regs + 0x4)
+#define ARCTIC2_FPGA_JACKET		(arctic2_fpga_regs + 0x5)
+#define ARCTIC2_FPGA_SDIO_CTRL		(arctic2_fpga_regs + 0x6)
+#define ARCTIC2_FPGA_USB_CTRL		(arctic2_fpga_regs + 0x7)
+#define ARCTIC2_FPGA_MDOC_CTRL		(arctic2_fpga_regs + 0x8)
+#define ARCTIC2_FPGA_CHARGER		(arctic2_fpga_regs + 0x9)
+#define ARCTIC2_FPGA_CRYO		(arctic2_fpga_regs + 0xa)
+#define ARCTIC2_FPGA_LED_DATA_HI        (arctic2_fpga_regs + 0xc)
+#define ARCTIC2_FPGA_LED_DATA_LOW       (arctic2_fpga_regs + 0xd)
+#define ARCTIC2_FPGA_LED_ADDR           (arctic2_fpga_regs + 0xe)
+#define ARCTIC2_FPGA_LED_CTRL           (arctic2_fpga_regs + 0xf)
+
+#define ARCTIC2_FPGA_BTN_PWR		0x20
+#define ARCTIC2_FPGA_BTN_MIC		0x10
+
+#define ARCTIC2_FPGA_MULTIWAY_PUSH	0x01
+#define ARCTIC2_FPGA_MULTIWAY_NE	0x02
+#define ARCTIC2_FPGA_MULTIWAY_SE	0x04
+#define ARCTIC2_FPGA_MULTIWAY_SW	0x08
+#define ARCTIC2_FPGA_MULTIWAY_NW	0x10
+
+#define ARCTIC2_FPGA_MULTIWAY_N		0x12
+#define ARCTIC2_FPGA_MULTIWAY_E		0x06
+#define ARCTIC2_FPGA_MULTIWAY_S		0x0c
+#define ARCTIC2_FPGA_MULTIWAY_W		0x18
+
+#define ARCTIC2_FPGA_IRQ_PWR		0x10
+#define ARCTIC2_FPGA_IRQ_TCPA		0x08
+#define ARCTIC2_FPGA_IRQ_JACKET		0x04
+#define ARCTIC2_FPGA_IRQ_MIC		0x02
+#define ARCTIC2_FPGA_IRQ_BTN		0x01
+
+#define ARCTIC2_FPGA_PCCF_POWER_5V	0x01
+
+/* Arctic II uses the internal clock for UART. Note that the OPB
+   frequency must be more than 2x the UART clock frequency. At OPB
+   frequencies less than this the serial port will not function due to
+   the way that SerClk is sampled.  We use 11.1111MHz as the frequency
+   because it can be generated from a wide range of OPB frequencies we
+   want to use. */
+
+#define PPC4xx_SERCLK_FREQ 11111111
+
+#define BASE_BAUD (PPC4xx_SERCLK_FREQ / 16)
+
+#define RTC_DVBITS	RTC_DVBITS_33KHZ	/* 33kHz RTC */
+
+#define PPC4xx_MACHINE_NAME	"IBM Arctic II"
+
+#include <asm/pccf_4xx.h>
+#define _IO_BASE		(pccf_4xx_io_base)
+#define _ISA_MEM_BASE		(pccf_4xx_mem_base)
+
+void arctic2_poweroff(void) __attribute__ ((noreturn));
+void arctic2_set_lcdpower(int on);
+
+extern int arctic2_supports_apm;
+extern int arctic2_supports_dvs;
+
+/*****************************************************************************
+ * Serial port definitions
+ *****************************************************************************/
+
+/*
+ * Arctic UART1 is touchscreen handled by separate driver, not included in
+ * standard serial defines.
+ */
+
+#define UART0_INT	UIC_IRQ_U0
+#define UART1_INT	UIC_IRQ_U1
+#define UART0_IO_BASE	0xEF600300
+#define UART1_IO_BASE	0xEF600400
+
+#define RS_TABLE_SIZE	2
+
+#define STD_UART_OP(num)					\
+	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
+		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
+		iomem_base:(u8 *) UART##num##_IO_BASE,		\
+		io_type: SERIAL_IO_MEM},
+
+#define SERIAL_DEBUG_IO_BASE    UART0_IO_BASE
+#define SERIAL_PORT_DFNS        \
+        STD_UART_OP(0)
+
+/* PM Button support */
+
+#ifdef CONFIG_405LP_PM_BUTTON
+#define IBM405LP_PM_IRQ      APM0_IRQ_WUI0
+#define IBM405LP_PM_POLARITY 1
+#endif
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_ARCTIC2_H__ */
+#endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ash.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ash.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ash.h	2003-02-11 23:48:52.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ash.h	2003-07-18 01:36:49.000000000 +0000
@@ -27,14 +27,16 @@
  */
 
 typedef struct board_info {
-	unsigned char	 bi_s_version[4];	/* Version of this structure */
-	unsigned char	 bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int	 bi_memsize;		/* DRAM installed, in bytes */
-	unsigned char	 bi_enetaddr[4][6];	/* Local Ethernet MAC address */
-	unsigned char	 bi_pci_enetaddr[6];
-	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
-	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
-	unsigned int	 bi_pci_busfreq;	/* PCI speed in Hz */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char	bi_enetaddr[4][6];	/* Local Ethernet MAC address */
+	unsigned char	bi_pci_enetaddr[6];
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int	bi_pci_busfreq;		/* PCI speed in Hz */
+	unsigned int  	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/beech.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/beech.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/beech.h	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/beech.h	2003-09-12 17:39:40.000000000 +0000
@@ -42,17 +42,18 @@
  */
 
 typedef struct board_info {
-	unsigned char bi_s_version[4];	/* Version of this structure */
-	unsigned long bi_tbfreq;	/* Frequency of SysTmrClk */
-	unsigned char bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int bi_memsize;	/* DRAM installed, in bytes */
-	unsigned long sysclock_period;	/* SysClk period in ns */
-	unsigned long sys_speed;	/* SysCLk frequency in Hz */
-	unsigned long bi_intfreq;	/* Processor speed, in Hz */
-	unsigned long vco_speed;	/* PLL VCO speed, in Hz */
-	unsigned long bi_busfreq;	/* PLB Bus speed, in Hz */
-	unsigned long opb_speed;	/* OPB Bus speed, in Hz */
-	unsigned long ebc_speed;	/* EBC Bus speed, in Hz */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned long	bi_tbfreq;		/* Frequency of SysTmrClk */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned long	sysclock_period;	/* SysClk period in ns */
+	unsigned long	sys_speed;		/* SysCLk frequency in Hz */
+	unsigned long	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned long	vco_speed;		/* PLL VCO speed, in Hz */
+	unsigned long	bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int  	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	unsigned long	bi_ebc_busfreq;		/* EBC Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 
 /* See beech.c for a concise diagram of the Beech physical memory map. */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/cedar.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/cedar.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/cedar.h	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/cedar.h	2003-09-12 17:39:40.000000000 +0000
@@ -34,6 +34,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI speed in Hz */
+	unsigned int	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ep405.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ep405.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ep405.h	2003-02-11 23:48:52.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ep405.h	2003-07-18 01:36:49.000000000 +0000
@@ -30,6 +30,8 @@ typedef struct board_info {
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
 	unsigned int	 bi_nvramsize;		/* Size of the NVRAM/RTC */
+	unsigned int	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp.c	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp.c	2003-09-12 17:39:40.000000000 +0000
@@ -32,6 +32,8 @@
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
 #include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/bcd.h>
 
 #include <asm/delay.h>
 #include <asm/hardirq.h>
@@ -43,6 +45,7 @@
 #include <asm/time.h>
 #include <asm/uaccess.h>
 #include <asm/ocp.h>
+#include <asm/pccf_4xx.h>
 
 struct ocp_def core_ocp[]  __initdata = {
 	{OCP_VENDOR_IBM, OCP_FUNC_OPB, OPB0_BASE, OCP_IRQ_NA, OCP_CPM_NA},
@@ -204,7 +207,7 @@ ibm405lp_setup_cpm(void)
 	mtdcr(DCRN_CPMFR, force);
 	mtdcr(DCRN_CPMER, enable);
 }
-#endif
+#endif /* CONFIG_PM */
 
 /* This routine is included here because the framebuffer driver needs a way to
    tell the system the Pixel clock frequency it needs, regardless of whether
@@ -237,7 +240,7 @@ int
 ibm405lp_set_pixclk(unsigned pixclk_min, unsigned pixclk_max)
 {
 	unsigned divider;
-	bd_t *bip = (bd_t *) __res;
+	bd_t *bip = &__res;
 	unsigned plb_khz = bip->bi_busfreq / 1000;
 	cpc0_cgcr1_t cgcr1;
 
@@ -264,3 +267,476 @@ ibm405lp_set_pixclk(unsigned pixclk_min,
 		return 0;
 	}
 }
+
+/* Somewhat misleading name, as well as the EBC, this sets up the UIC
+   and CPC ready for PCMCIA operation */
+static void
+pccf_ebc_setup(void)
+{
+	/* Set up EBC bank 4 as per PCCF docs., assuming 66 MHz EBC bus. The
+	   ready timeout is set for 1024 cycles (~ 15 us at 66 MHz), unless
+	   someone else has already set it for 2048.  In the event of a
+	   timeout we'll get a Data Machine Check. */
+
+	unsigned long bits, mask, flags;
+
+	save_flags(flags);
+	cli();
+
+	/* Program EBC0_CFG for ready timeout */
+
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_CFG);
+	bits = mfdcr(DCRN_EBC0_CFGDATA);
+	if ((bits & EBC_CFG_RTC) != EBC_CFG_RTC_2048)
+		mtdcr(DCRN_EBC0_CFGDATA, (bits & ~EBC_CFG_RTC) | EBC_CFG_RTC_1024);
+
+	/* Program EBC bank properties : 32 MB, 16-bit RW bank; 
+	   BME = 0, TWT = 22, CSN = 2, OEN = 3, WBN = WBF = 0, TH = 5, 
+	   RE = 1, SOR = 0, BEM = 1 */
+
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_B4CR);
+	mtdcr(DCRN_EBC0_CFGDATA, (PCCF_4XX_PADDR & 0xfff00000) | 0x000ba000);
+	mtdcr(DCRN_EBC0_CFGADDR, DCRN_EBC0_B4AP);
+	mtdcr(DCRN_EBC0_CFGDATA, 0x0b0b0b40);
+
+	/* Program the UIC for active-high, level-triggered interrupts.  Note
+	   that the active-low PCMCIA interrupt pin is inverted by the PCCF
+	   macro.  */
+
+	mask = (0x80000000 >> PCCF_4XX_MACRO_IRQ) | 
+		(0x80000000 >> PCCF_4XX_CARD_IRQ);
+
+	bits = mfdcr(DCRN_UIC0_PR);
+	bits |= mask;
+	mtdcr(DCRN_UIC0_PR, bits);
+
+	bits = mfdcr(DCRN_UIC0_TR);
+	bits &= ~mask;
+	mtdcr(DCRN_UIC0_TR, bits);
+
+	/* Clear CPC0_CR0[PCMD] to enable the PCMCIA controller */
+
+	mtdcr(DCRN_CPC0_CR0, mfdcr(DCRN_CPC0_CR0) & ~0x00000200);
+
+	restore_flags(flags);
+}
+
+/* Map the PCCF controller's memory windows.
+ *
+ * HACK ALERT: Logically this belongs in the pccf_4xx driver itself,
+ * however that causes problems because it happens so late in
+ * initialization.  We want to use some ISA-ish drivers (notably
+ * 8390.c) on memory mapped devices by using the
+ * ioaddr=(memaddr-_IO_BASE) hack.  If _IO_BASE is the PCMCIA ISA IO
+ * space (which we want so PC Card drivers using ISA IO work) but is
+ * not initialized until the pccf_4xx driver starts, this could well
+ * be after drivers like 8390 have initialized and computed a fake
+ * "IO" address which is now incorrect.  Putting the ioremap()ing of
+ * the PCCF macro in the chip/board setup code works around this
+ * problem. */
+int
+ibm405lp_setup_pccf(volatile u16 **vaddr, unsigned long *io_base,
+		    unsigned long *mem_base)
+{
+	pccf_ebc_setup();
+
+	*vaddr = ioremap(PCCF_4XX_MACRO_PADDR, PCCF_4XX_MACRO_WINSIZE);
+
+	if (*vaddr == NULL) {
+		printk(KERN_ERR "pccf_4xx: ioremap macro at 0x%lx failed.\n",
+		       PCCF_4XX_MACRO_PADDR);
+		return -EBUSY;
+	}
+
+	printk("ibm405lp_setup_pcmcia:  phys addr = %lx,  virt addr = %p\n",
+	       PCCF_4XX_MACRO_PADDR, *vaddr);
+
+	*io_base = (unsigned long) ioremap(PCCF_4XX_IO_PADDR,
+					   PCCF_4XX_IO_WINSIZE);
+	if (*io_base == 0) {
+		printk(KERN_ERR "pccf_4xx: ioremap io at 0x%lx failed.\n",
+		       PCCF_4XX_IO_PADDR);
+		return -EBUSY;
+	}
+
+	*mem_base = (unsigned long) ioremap(PCCF_4XX_MEM_PADDR,
+					    PCCF_4XX_MEM_WINSIZE);
+	if (*mem_base == 0) {
+		printk(KERN_ERR "pccf_4xx: ioremap mem at 0x%lx failed.\n",
+		       PCCF_4XX_MEM_PADDR);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+/****************************************************************************
+ * TODC
+ ****************************************************************************/
+
+/*
+ * The 405LP includes an MC146818-equivalent core accessed via a DCR
+ * wrapper.  The 405LP does not implement the NVRAM.
+ */
+
+long __init ibm405lp_time_init(void)
+{
+	static int not_initialized = 1;
+
+	/* Make sure clocks are running */
+	if (not_initialized) {
+		/* Reset the core and ensure it's enabled. */
+		mtdcr(DCRN_RTC0_WRAP, 0);		/* toggle NRST & NMR */
+		mtdcr(DCRN_RTC0_WRAP, 3);
+		mtdcr(DCRN_RTC0_CR0, 0x60);		/* No divider chain, No square wave */
+		mtdcr(DCRN_RTC0_CR1, 0x80);		/* Disable update cycles/interrupts*/
+		mtdcr(DCRN_RTC0_WRAP, 0);       /* toggle NRST & NMR */
+		mtdcr(DCRN_RTC0_WRAP, 3);
+
+		/* if necessary, set the input clock frequency */
+		if ((mfdcr(DCRN_RTC0_CR0) >> 4) != RTC_DVBITS) {
+			printk(KERN_WARNING "Warning: RTC frequency was incorrect\n");
+			mtdcr(DCRN_RTC0_CR0,
+					 ((RTC_DVBITS & 0x7) << 4) | (mfdcr(DCRN_RTC0_CR0) & 0xf));
+		}
+
+		mtdcr(DCRN_RTC0_CR1, mfdcr(DCRN_RTC0_CR1) & 0x7f);	/* allow updates */
+
+		not_initialized = 0;
+	}
+
+	return 0;
+}
+
+unsigned long ibm405lp_get_rtc_time(void)
+{
+	uint	year, mon, day, hour, min, sec;
+	uint	i, pm;
+	u_char	save_control, uip;
+
+	spin_lock(&rtc_lock);
+	save_control = mfdcr(DCRN_RTC0_CR1);
+
+	for (i=0; i<100000000; i++) {
+		uip = mfdcr(DCRN_RTC0_CR0);
+		sec = mfdcr(DCRN_RTC0_SEC) & 0x7f;
+		min = mfdcr(DCRN_RTC0_MIN) & 0x7f;
+		hour = mfdcr(DCRN_RTC0_HR) & 0xff;
+		day = mfdcr(DCRN_RTC0_DOM) & 0x3f;
+		mon = mfdcr(DCRN_RTC0_MONTH) & 0x1f;
+		year = mfdcr(DCRN_RTC0_YEAR) & 0xff;
+
+		uip |= mfdcr(DCRN_RTC0_CR0);
+		if ((uip & RTC_UIP) == 0) break;
+	}
+
+	spin_unlock(&rtc_lock);
+
+	pm = hour & 0x80;
+	hour = hour & 0x3f;
+
+	if (((save_control & RTC_DM_BINARY) == 0) ||
+	    RTC_ALWAYS_BCD) {
+
+		BCD_TO_BIN(sec);
+		BCD_TO_BIN(min);
+		BCD_TO_BIN(hour);
+		BCD_TO_BIN(day);
+		BCD_TO_BIN(mon);
+		BCD_TO_BIN(year);
+	}
+
+	
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!(save_control & RTC_24H)) {
+		if (pm && (hour != 12))
+			hour += 12;
+		if (!pm && (hour == 12))
+			hour = 0;
+	}
+
+	year = year + 1900;
+	if (year < 1970) {
+		year += 100;
+	}
+
+	return mktime(year, mon, day, hour, min, sec);
+}
+
+int ibm405lp_set_rtc_time(unsigned long nowtime)
+{
+	struct rtc_time	tm;
+	u_char		save_control, save_freq_select, pm = 0;
+
+	spin_lock(&rtc_lock);
+	to_tm(nowtime, &tm);
+
+	save_control = mfdcr(DCRN_RTC0_CR1);
+	save_freq_select = mfdcr(DCRN_RTC0_CR0);
+	mtdcr(DCRN_RTC0_CR0, save_freq_select | RTC_DIV_RESET2);
+
+        tm.tm_year = (tm.tm_year - 1900) % 100;
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!(save_control & RTC_24H)) {
+		if (tm.tm_hour == 0)
+			tm.tm_hour = 12;
+		else if (tm.tm_hour >= 12) {
+			pm = 0x80;
+			if (tm.tm_hour > 12) 
+				tm.tm_hour -= 12;
+		}
+	}
+
+	if (((save_control & RTC_DM_BINARY) == 0) ||
+	    RTC_ALWAYS_BCD) {
+
+		BIN_TO_BCD(tm.tm_sec);
+		BIN_TO_BCD(tm.tm_min);
+		BIN_TO_BCD(tm.tm_hour);
+		BIN_TO_BCD(tm.tm_mon);
+		BIN_TO_BCD(tm.tm_mday);
+		BIN_TO_BCD(tm.tm_year);
+	}
+
+	tm.tm_hour |= pm;
+
+	mtdcr(DCRN_RTC0_SEC,   tm.tm_sec);
+	mtdcr(DCRN_RTC0_MIN,   tm.tm_min);
+	mtdcr(DCRN_RTC0_HR,    tm.tm_hour);
+	mtdcr(DCRN_RTC0_MONTH, tm.tm_mon);
+	mtdcr(DCRN_RTC0_DOM,   tm.tm_mday);
+	mtdcr(DCRN_RTC0_YEAR,  tm.tm_year);
+	mtdcr(DCRN_RTC0_WRAP, 0); /* Reset divider chain */ 
+	mtdcr(DCRN_RTC0_WRAP, 3);
+	mtdcr(DCRN_RTC0_CR0, save_freq_select);
+
+	spin_unlock(&rtc_lock);
+	return 0;
+}
+
+/* ibm405lp_set_rtc_sqw()
+ * Set the RTC squarewave frequency and enable SQW output. This is needed to
+ * drive the APM watchdog.
+ */
+void ibm405lp_set_rtc_sqw(unsigned long rsbits)
+{
+	/* set RS field */
+	mtdcr(DCRN_RTC0_CR0, (mfdcr(DCRN_RTC0_CR0) & 0xf0) | (rsbits & 0xf));
+
+	/* set SQWE (enable squarewave output) */
+	mtdcr(DCRN_RTC0_CR1, mfdcr(DCRN_RTC0_CR1) | 0x08);
+}
+
+/* The RTC only has a 24-hour alarm capability, so only the hours, minutes and
+ * seconds fields of the rtc_time struct are used in alarm functions.  This
+ * implementation converts all out-of-range inputs to 'don't cares' (0xff), and
+ * returns 'don't cares' verbatim.  Somewhat inspired by drivers/char/rtc.c
+ */
+
+static inline int
+dont_care(uint value)
+{
+	return (value & 0xc0) == 0xc0;
+}
+
+void ibm405lp_get_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	uint   hour, min, sec, pm;
+	u_char save_control;
+
+	spin_lock_irq(&rtc_lock);
+	sec = mfdcr(DCRN_RTC0_SECAL);
+	min = mfdcr(DCRN_RTC0_MINAL);
+	hour = mfdcr(DCRN_RTC0_HRAL);
+	save_control = mfdcr(DCRN_RTC0_CR1);
+	spin_unlock_irq(&rtc_lock);
+
+	if (!dont_care(hour)) {
+		pm = hour & 0x80;
+		hour = hour & 0x3f;
+	}
+
+	if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		if (!dont_care(sec)) BCD_TO_BIN(sec);
+		if (!dont_care(min)) BCD_TO_BIN(min);
+		if (!dont_care(hour)) BCD_TO_BIN(hour);
+	}
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!dont_care(hour) && !(save_control & RTC_24H)) {
+		if (pm && (hour != 12))
+			hour += 12;
+		if (!pm && (hour == 12))
+			hour = 0;
+	}
+
+	alm_tm->tm_hour = hour;
+	alm_tm->tm_min = min;
+	alm_tm->tm_sec = sec;
+}
+
+void ibm405lp_set_rtc_alm_time(struct rtc_time *alm_tm)
+{
+	uint   hour, min, sec, pm = 0;
+	u_char save_control;
+
+	hour = alm_tm->tm_hour;
+	min = alm_tm->tm_min;
+	sec = alm_tm->tm_sec;
+
+	if (hour > 23) hour = 0xff;
+	if (min > 59) min = 0xff;
+	if (sec > 59) sec = 0xff;
+
+	spin_lock_irq(&rtc_lock);
+
+	save_control = mfdcr(DCRN_RTC0_CR1);
+
+	/* 11:59 AM -> 12:00 PM ->-> 1:00 PM ->-> 11:59 PM -> 12:00 AM */
+	if (!dont_care(hour) && !(save_control & RTC_24H)) {
+		if (hour == 0)
+			hour = 12;
+		else if (hour >= 12) {
+			pm = 0x80;
+			if (hour > 12) 
+				hour -= 12;
+		}
+	}
+
+	if (((save_control & RTC_DM_BINARY) == 0) || RTC_ALWAYS_BCD) {
+		if (!dont_care(sec)) BIN_TO_BCD(sec);
+		if (!dont_care(min)) BIN_TO_BCD(min);
+		if (!dont_care(hour)) BIN_TO_BCD(hour);
+	}
+
+	mtdcr(DCRN_RTC0_HRAL, hour | pm);
+	mtdcr(DCRN_RTC0_MINAL, min);
+	mtdcr(DCRN_RTC0_SECAL, sec);
+
+	spin_unlock_irq(&rtc_lock);
+}
+
+/****************************************************************************
+ * APM Unit PIC
+ ****************************************************************************/
+
+/* The 405LP "APM" unit implements a hierarchical interrupt controller.  This
+   controller is buried in the APM unit, and is not part of the UIC. Three
+   special "wakeup" interrupts and the RTC interrupt are handled here. These
+   interrupts and this controller are special for several reasons:
+
+   1) They are the only interrupts that can wake the system from an
+   APM-controlled low-power state. 
+
+   2) The APM DCRs actually function at the RTC frequency.  Writes to these
+   registers do not take effect for several RTC cycles, and must be done with
+   the 'mtdcr_interlock()' protocol as they all have 'valid' bits.
+
+   3) The function of this unit is predictable, but difficult to understand.
+
+   In this implementation, RTC and wakeup IRQ handlers will attach to the APM
+   interrupt using the shared interrupt protocol.  The individual handlers are
+   responsible for setting up their polarity and triggers and clearing the
+   interrupt conditions they service, using the routines defined here. This
+   seemed simpler than going into ppc4xx_pic.c and implementing a new type of
+   cascaded IRQ service, esp. given that that this structure is unique to the
+   405LP and has such an unusual specification. 
+
+   Hardware Notes: Wakeup input trigger and level conditions are programmable
+   just like in the UIC, and the "wakeup" interrupts can be used for any
+   purpose.  Unfortunately there's no way to determine the input level of a
+   "wakeup" input other than by generating interrupt status. The APM interrupt
+   controller ORs the enabled status of the 4 interrupts it controls and
+   presents a single, active-high, level-triggered interrupt to the UIC.  This
+   signal is also used as the wakeup indication when the device is asleep.
+
+   The function of the APM0_IER and APM0_ISR are reversed from their usage in
+   the UIC.  Rather than IER masking status in ISR, status for _all_ bits in
+   ISR only appears when _any_ bit in IER is set.  The interrupt signal is the
+   correct reduced OR of IER & ISR, however.  Furthermore, the ISR will only
+   generate new status if the final value written to it is 0 after any status
+   clearing operations. 
+
+   The RTC0_CR1 and RTC0_ISR registers will be cleared during unpowered sleep
+   states (power-down, standby, hibernate). The device will still generate RTC
+   alarm interrupts correctly though, so the clearing must take place on power
+   up. */
+
+void
+ibm405lp_apm_dcr_delay(void)
+{
+  udelay(153);			/* 5 RTC cycles at 32768 Hz */
+}
+
+void
+ibm405lp_apm_irq_enable(unsigned apm_irq)
+{
+	u32 ier = mfdcr(DCRN_APM0_IER);
+
+	mtdcr_interlock(DCRN_APM0_IER, ier | (1 << (31 - apm_irq)), 
+			APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+}
+
+void
+ibm405lp_apm_irq_disable(unsigned apm_irq)
+{
+	u32 ier = mfdcr(DCRN_APM0_IER);
+
+	mtdcr_interlock(DCRN_APM0_IER, ier & ~(1 << (31 - apm_irq)),
+			APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+}
+
+void
+ibm405lp_apm_irq_ack(unsigned apm_irq)
+{
+	mtdcr_interlock(DCRN_APM0_ISR, 1 << (31 - apm_irq), APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+
+	mtdcr(DCRN_APM0_ISR, 0);
+	ibm405lp_apm_dcr_delay();
+}
+
+int
+ibm405lp_apm_irq_status(unsigned apm_irq)
+{
+	return mfdcr(DCRN_APM0_ISR) & mfdcr(DCRN_APM0_IER) & 
+		(1 << (31 - apm_irq));
+}
+
+/* Setup should be called with the APM IRQ disabled.  Since changing parameters
+   may cause status to be asserted, it is always ack'ed before returning. */
+
+void
+ibm405lp_apm_irq_setup(unsigned apm_irq, unsigned trigger, unsigned polarity)
+{
+	u32 itr, ipr;
+
+	itr = mfdcr(DCRN_APM0_ITR) | ((trigger ? 1 : 0) << (31 - apm_irq));
+	mtdcr_interlock(DCRN_APM0_ITR, itr, APM0_IRQ_MASK);
+	ipr = mfdcr(DCRN_APM0_IPR) | ((polarity ? 1 : 0) << (31 - apm_irq));
+	mtdcr_interlock(DCRN_APM0_IPR, ipr, APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+	ibm405lp_apm_irq_ack(apm_irq);
+}
+
+/* The RTC interrupt is always level-triggered, active high.  Others are board
+   dependent. */
+
+void __init
+ibm405lp_setup_apm_pic(void)
+{
+	mtdcr_interlock(DCRN_APM0_IER, 0, APM0_IRQ_MASK);
+	ibm405lp_apm_dcr_delay();
+	ibm405lp_apm_irq_setup(APM0_IRQ_RTC, 0, 1);
+}
+
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp.h	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp.h	2003-09-12 17:45:00.000000000 +0000
@@ -32,6 +32,15 @@
 #include <linux/config.h>
 #include <asm/ibm4xx.h>
 
+/* See beech.c for a concise diagram of the Beech physical memory map. */
+
+#define PPC4xx_ONB_IO_PADDR    ((uint)0xef600000)
+#define PPC4xx_ONB_IO_VADDR    PPC4xx_ONB_IO_PADDR
+#define PPC4xx_ONB_IO_SIZE     ((uint)4*1024)
+#define PVR_405LP     0x41F10000
+#define PVR_405LP_1_0 (PVR_405LP | 0x0890)
+#define PVR_405LP_1_1 (PVR_405LP | 0x0991)
+
 /* Machine-specific register naming for the 4xx processors is a mess. It seems
    that everyone had a different idea on how to prefix/abbreviate/configure the
    DCR numbers and MMIO addresses.  I'm no different! For the 405LP we have
@@ -197,6 +206,16 @@
 #define DCRN_EBC0_BnCR(bank) (bank)
 #define DCRN_EBC0_BnAP(bank) (0x10 + (bank))
 
+#define EBC_CFG_RTC		0x38000000
+#define EBC_CFG_RTC_16		0x00000000
+#define EBC_CFG_RTC_32		0x08000000
+#define EBC_CFG_RTC_64		0x10000000
+#define EBC_CFG_RTC_128		0x18000000
+#define EBC_CFG_RTC_256		0x20000000
+#define EBC_CFG_RTC_512		0x28000000
+#define EBC_CFG_RTC_1024	0x30000000
+#define EBC_CFG_RTC_2048	0x38000000
+
 /* Offsets for LCD Controller DCRs */
 
 #define DCRN_LCD0_DER    0x80010000	/* Display Enable Regsiter */
@@ -310,6 +329,15 @@
 
 #define TDES0_IO_BASE  0xef600b00
 
+/* The PCMCIA controller driver 4xx_pccf.c is responsible for the EBC setup of
+   PCMCIA.  Externally, EBC bank selects 3..7 take on PCMCIA functions when
+   PCMCIA is enabled. */
+
+#define PCCF_4XX_PADDR		(0xf0000000UL)
+#define PCCF_4XX_SIZE		(32 * 1024 * 1024)
+#define PCCF_4XX_MACRO_IRQ	UIC_IRQ_EIR5
+#define PCCF_4XX_CARD_IRQ	UIC_IRQ_EIR6
+
 /*****************************************************************************
  * CPM bits for the 405LP.
  *****************************************************************************/
@@ -375,45 +403,14 @@
 #define UIC_IRQ_EIR5  30	/* External IRQ 5 */
 #define UIC_IRQ_EIR6  31	/* External IRQ 6 */
 
-/*****************************************************************************
- * Serial port definitions
- *****************************************************************************/
-
-#ifdef CONFIG_SERIAL_MANY_PORTS
-#define RS_TABLE_SIZE	64
-#else
-#define RS_TABLE_SIZE	4
-#endif
-
-#define UART0_INT	UIC_IRQ_U0
-#define UART1_INT	UIC_IRQ_U1
-#define UART0_IO_BASE	0xEF600300
-#define UART1_IO_BASE	0xEF600400
-
-#define STD_UART_OP(num)					\
-	{ 0, BASE_BAUD, 0, UART##num##_INT,			\
-		(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),	\
-		iomem_base:(u8 *) UART##num##_IO_BASE,		\
-		io_type: SERIAL_IO_MEM},
-
-#if defined(CONFIG_UART0_TTYS0)
-#define SERIAL_DEBUG_IO_BASE    UART0_IO_BASE
-#define SERIAL_PORT_DFNS        \
-        STD_UART_OP(0)          \
-        STD_UART_OP(1)
-#endif
-
-#if defined(CONFIG_UART0_TTYS1)
-#define SERIAL_DEBUG_IO_BASE    UART1_IO_BASE
-#define SERIAL_PORT_DFNS        \
-        STD_UART_OP(1)          \
-        STD_UART_OP(0)
-#endif
+/* Serial port definitions are per-board. */
 
 #ifndef __ASSEMBLY__
 
 #include <linux/types.h>
+#include <linux/rtc.h>
 #include <asm/system.h>
+#include <platforms/4xx/ibm405lp_pm.h>
 
 /****************************************************************************
  * DCR type structures and field definitions for DCRs manipulated by the 405LP
@@ -422,10 +419,15 @@
 
 /* APM0_CFG - APM Configuration Register */
 
+/* Three bits were added in 405LP 1.1.  The new defs. *should* work for 1.0 if
+   we're careful - and we really shouldn't be using 1.0 for APM anyway. */
+
 typedef union {
 	u32 reg;
 	struct {
-		unsigned int rsvd:17;
+		unsigned int rsvd:14;
+		unsigned int rtcmd:2;	/* RTC mode - Don't Change it! */
+		unsigned int rst:1;	/* Reset after Cryo sleep */
 		unsigned int isp:1;	/* Initiate Sleep */
 		unsigned int ewt:1;	/* Enable Watchdog Timer */
 		unsigned int sm:2;	/* Sleep Mode */
@@ -436,92 +438,38 @@ typedef union {
 	} fields;
 } apm0_cfg_t;
 
-#define APM0_CFG_MASK 0xffff8000	/* AND to clear all non-reserved fields */
+#define APM0_CFG_MASK 0xfffc0000 /* AND to clear all non-reserved fields */
+
+/* DPM can only set the power control bit and initiate sleep bit.
+   The initiate sleep bit is included so that we can be sure it's clear
+   whenever changing voltages. */
+
+#define APM0_CFG_DPM_MASK 0xffffbf7f
+
+#define APM0_CFG_SM_CLOCK_SUSPEND	0
+#define APM0_CFG_SM_POWER_DOWN		1
+#define APM0_CFG_SM_CRYO_STANDBY	2
 
 /* APM0_SR - APM Status Register */
 
 typedef union {
 	u32 reg;
 	struct {
-		unsigned int rsvd:17;
+		unsigned int rsvd0:20;
 		unsigned int cdet:1;	/* Clock Detect */
 		unsigned int en:1;	/* APM Enable Indicator */
-		unsigned int rset:1;	/* Processor Reset by APM? */
 		unsigned int pfr:1;	/* Power Fail Reset? */
+		unsigned int rset:1;	/* Processor Reset by APM? */
 		unsigned int rsrt:1;	/* Restart Successful? */
 		unsigned int sdwn:1;	/* Shutdown Complete */
-		unsigned int errc:8;	/* Error Code */
+	        unsigned int sigm:1;	/* Signature mismatch */
+	        unsigned int pap:1;	/* Previous APM phase */
+                unsigned int rsvd1:3;
 		unsigned int v:1;	/* Valid Bit */
 	} fields;
 } apm0_sr_t;
 
-#define APM0_SR_MASK 0xffff8000	/* AND to clear all non-reserved fields */
-
-/* APM0_IER -- APM Interrupt Enable Register
-   APM0_IPR -- APM Interrupt Polarity Register
-   APM0_ISR -- APM Interrupt Status Register
-   APM0_ITR -- APM Interrupt Trigger Register
-
-   The interrupts are also accessed via standard interrupt numbers:
-
-   59 : Wake-up Input 0
-   60 : Wake-up Input 1
-   61 : Wake-up Input 2
-   62 : Real-Time Clock Interrupt
-*/
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0e:1;
-		unsigned int wi1e:1;
-		unsigned int wi2e:1;
-		unsigned int cie:1;
-		unsigned int v:1;
-	} fields;
-} apm0_ier_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0p:1;
-		unsigned int wi1p:1;
-		unsigned int wi2p:1;
-		unsigned int cip:1;
-		unsigned int v:1;
-	} fields;
-} apm0_ipr_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0s:1;
-		unsigned int wi1s:1;
-		unsigned int wi2s:1;
-		unsigned int cis:1;
-		unsigned int v:1;
-	} fields;
-} apm0_isr_t;
-
-typedef union {
-	u32 reg;
-	struct {
-		unsigned int rsvd:27;
-		unsigned int wi0t:1;
-		unsigned int wi1t:1;
-		unsigned int wi2t:1;
-		unsigned int cit:1;
-		unsigned int v:1;
-	} fields;
-} apm0_itr_t;
-
-#define APM0_IER_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_IPR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_ISR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
-#define APM0_ITR_MASK 0xffffffe0	/* AND to clear all non-reserved fields */
+#define APM0_SR_MASK 0xfffff00e	/* AND to clear all non-reserved fields */
 
 /* CPC0_PLLMR - PLL Mode Register */
 
@@ -530,16 +478,17 @@ typedef union {
 	struct {
 		unsigned int pmul:5;	/* PLL Multiplier */
 		unsigned int pdiv:5;	/* PLL Divider */
-		unsigned int tun:10;	/* PLL Tuning Control */
+		unsigned int tun:1;	/* PLL Tuning Control */
+		unsigned int bps:1;     /* Bypass SysClk through PLL Divider */
+                unsigned int rsvd0:8;   /* Reserved */
 		unsigned int db2:1;	/* Divide VCO by 2 Select */
 		unsigned int csel:2;	/* PLL Clock Output Select */
-		unsigned int rsvd:8;	/* Reserved */
+		unsigned int rsvd1:8;	/* Reserved */
 		unsigned int v:1;	/* Valid bit */
 	} fields;
 } cpc0_pllmr_t;
 
-#define CPC0_PLLMR_MASK 0x000001fe	/* AND to clear all non-reserved fields */
-#define CPC0_PLLMR_RTVFS_MASK CPC0_PLLMR_MASK	/* All bits controlled by RTVFS */
+#define CPC0_PLLMR_MASK 0x000ff1fe	/* AND to clear all non-reserved fields */
 
 /* The PLL multiplier/divider are always multiples of 4. */
 
@@ -547,13 +496,13 @@ typedef union {
 #define CPC0_PLLMR_MULDIV_DECODE(n) (((n) + 1) * 4)
 #define CPC0_PLLMR_MULDIV_MAX 128
 
-#define CPC0_PLLMR_TUN_HIGH 0x200	/* High-band tuning */
-#define CPC0_PLLMR_TUN_LOW  0x000	/* Low-band tuning */
+#define CPC0_PLLMR_TUN_HIGH 0x1  	/* High-band tuning */
+#define CPC0_PLLMR_TUN_LOW  0x0 	/* Low-band tuning */
 
 #define CPC0_PLLMR_CSEL_REFCLK  0	/* System Reference Clock */
 #define CPC0_PLLMR_CSEL_PLLVCO  1	/* PLL VCO */
 #define CPC0_PLLMR_CSEL_RTC     2	/* RTC */
-#define CPC0_PLLMR_CSEL_EBCPLB5 3	/* EBC-PLB divisor is 5 ??? */
+#define CPC0_PLLMR_CSEL_RSVD    3	/* Reserved */
 
 /* CPC0_CGCR0 - Clock Generation and Control Register 0 */
 
@@ -571,8 +520,6 @@ typedef union {
 } cpc0_cgcr0_t;
 
 #define CPC0_CGCR0_MASK 0x00001fff	/* AND to clear all non-reserved fields */
-#define CPC0_CGCR0_RTVFS_MASK 0x0001ffff	/* AND to clear all rtvfs-modified
-						   fields */
 
 #define CPC0_CGCR0_SCSEL_OFF  0	/* SysClkOut driven low (low power) */
 #define CPC0_CGCR0_SCSEL_CPU  1	/* Select CPU clock as SysClkOut */
@@ -593,8 +540,6 @@ typedef union {
 } cpc0_cgcr1_t;
 
 #define CPC0_CGCR1_MASK 0x00007fff	/* AND to clear all non-reserved fields */
-#define CPC0_CGCR1_RTVFS_MASK 0x0001ffff	/* AND to clear all rtvfs-modified
-						   fields */
 
 /* 5-bit clock dividers are directly encoded, except that an encoding of 0
    indicates divide-by-32. */
@@ -808,7 +753,6 @@ typedef union {
 } sdram0_rtr_t;
 
 #define SDRAM0_RTR_MASK 0xc007ffff	/* AND to clear non-reserved fields */
-#define SDRAM0_RTR_RTVFS_MASK SDRAM0_RTR_MASK
 
 #define SDRAM0_RTR_IV(n) (((n) & 0x3ff8) >> 2)
 
@@ -830,7 +774,6 @@ typedef union {
 } sdram0_tr_t;
 
 #define SDRAM0_TR_MASK 0xfe703fe0	/* AND to clear non-reserved fields */
-#define SDRAM0_TR_RTVFS_MASK SDRAM0_TR_MASK
 
 #define SDRAM0_TR_ENCODE(n) ((n) - 1)
 #define SDRAM0_TR_ENCODE_RFTA(n) ((n) - 4)
@@ -849,6 +792,11 @@ typedef union {
 
 #define SLA0_SLPMD_MASK 0x07dfffff	/* AND to clear all non-reserved fields */
 
+/* these defines are for the DV bits of RTC0_CR0 */
+#define RTC_DVBITS_4MHZ		0	/* 4.194304 MHz */
+#define RTC_DVBITS_1MHZ		1	/* 1.048576 MHz */
+#define RTC_DVBITS_33KHZ	2	/*   32.768 kHz */
+
 /* Several direct-write DCRs on the 405LP have an interlock requirement,
    implemented by a "valid" bit in the low-order bit.  This routine handles the
    handshaking for these registers, by
@@ -885,13 +833,40 @@ do {                                    
  ****************************************************************************/
 
 int ibm405lp_set_pixclk(unsigned pixclk_min, unsigned pixclk_max);
-
-void ibm405lp_reset_sdram(u32 new_rtr, u32 new_tr);
+int ibm405lp_setup_pccf(volatile u16 **vaddr, unsigned long *io_base,
+			unsigned long *mem_base);
+void ibm405lp_setup_cpm(void);
 
 extern int (*set_pixclk_hook) (unsigned pixclk_min, unsigned pixclk_max);
 extern unsigned last_pixclk_min;
 extern unsigned last_pixclk_max;
 
+extern long ibm405lp_time_init(void);
+extern unsigned long ibm405lp_get_rtc_time(void);
+extern int ibm405lp_set_rtc_time(unsigned long nowtime);
+extern void ibm405lp_set_rtc_sqw(unsigned long rsbits);
+extern void ibm405lp_set_rtc_alm_time(struct rtc_time *alm_time);
+extern void ibm405lp_get_rtc_alm_time(struct rtc_time *alm_time);
+
+/* APM0 interrupt routines are in ibm405lp.c */
+
+#define APM0_IRQ_MASK 0xffffffe0 /* AND to clear all non-reserved fields */
+
+#define APM0_IRQ_WUI0 27
+#define APM0_IRQ_WUI1 28
+#define APM0_IRQ_WUI2 29
+#define APM0_IRQ_RTC  30
+
+void ibm405lp_apm_dcr_delay(void);
+#define ibm405lp_rtc_dcr_delay() ibm405lp_apm_dcr_delay();
+void ibm405lp_apm_irq_ack(unsigned apm_irq);
+void ibm405lp_apm_irq_setup(unsigned apm_irq,
+			    unsigned trigger, unsigned polarity);
+void ibm405lp_apm_irq_enable(unsigned apm_irq);
+void ibm405lp_apm_irq_disable(unsigned apm_irq);
+int ibm405lp_apm_irq_status(unsigned apm_irq);
+void ibm405lp_setup_apm_pic(void);
+
 #endif				/* __ASSEMBLY__ */
 
 #include <asm/ibm405.h>
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp_pm.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibm405lp_pm.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibm405lp_pm.h	2003-06-12 22:25:46.000000000 +0000
@@ -0,0 +1,55 @@
+#ifndef IBM405LP_PM_H
+#define IBM405LP_PM_H
+
+#include <asm/types.h>
+
+#ifndef __ASSEMBLY__
+
+/* sysctl numbers */
+
+/* top-level number for the 405LP sleep sysctl()s
+ *
+ * This is picked at random out of thin air, hoping that it won't
+ * clash with someone.  That's really ugly, but appears to be
+ * "standard" practice (!?).  Oh well, with any luck we can throw
+ * these away and replace them with sysfs parameters, in the
+ * not-too-distant future...
+ */
+#define CTL_PM_405LP 0xbc17
+
+/* sleep sysctls */
+enum
+{
+	PM_405LP_SLEEP_CMD=1,
+	PM_405LP_SLEEP_MODE=2,
+	PM_405LP_SLEEP_ALARM=3,
+	PM_405LP_SLEEP_DEBUG_CDIV=4,
+	PM_405LP_SLEEP_DEBUG_WATCHDOG=5
+};
+
+/* Used to tell firmware where to return control to Linux on
+ * wake. Currently only the first two words are used by firmware; the
+ * rest are Linux convenience.
+ */
+struct ibm405lp_wakeup_info {
+	/* physical address of wakeup function */
+	void (*wakeup_func_phys)(unsigned long apm0_cfg,
+				 unsigned long apm0_sr);
+	u32 magic;
+
+	/* private to Linux: */
+	unsigned long wakeup_stack_phys; /* physical stack pointer */
+};
+
+#endif /* __ASSEMBLY__ */
+
+#define IBM405LP_WAKEUP_MAGIC	(0x31415926)
+
+/* These values are ORed into RTC0_CEN before APM power-down modes as a
+ * signal to the firmware as to which type of wakeup is required. */
+
+#define IBM405LP_POWERDOWN_REBOOT    0x00 /* Reboot the system */
+#define IBM405LP_POWERDOWN_SUSPEND   0x40 /* Suspend-to-RAM */
+#define IBM405LP_POWERDOWN_HIBERNATE 0x80 /* Hibernate to device 0 */
+
+#endif /* IBM405LP_PM_H */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibmstb4.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibmstb4.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibmstb4.c	2003-02-11 23:48:52.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibmstb4.c	2003-06-03 21:59:10.000000000 +0000
@@ -15,13 +15,13 @@
 #include <asm/ocp.h>
 
 struct ocp_def core_ocp[] = {
-	{UART, UART0_IO_BASE, UART0_INT,IBM_CPM_UART0},
-	{UART, UART1_IO_BASE, UART1_INT, IBM_CPM_UART1},
-	{UART, UART2_IO_BASE, UART2_INT, IBM_CPM_UART2},
-	{IIC, IIC0_BASE, IIC0_IRQ, IBM_CPM_IIC0},
-	{IIC, IIC1_BASE, IIC1_IRQ, IBM_CPM_IIC1},
-	{GPIO, GPIO0_BASE, OCP_IRQ_NA, IBM_CPM_GPIO0},
-	{IDE, IDE0_BASE, IDE0_IRQ, OCP_CPM_NA},
-	{USB, USB0_BASE, USB0_IRQ, IBM_CPM_USB0},
-	{OCP_NULL_TYPE, 0x0, OCP_IRQ_NA, OCP_CPM_NA},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART0_IO_BASE, UART0_INT,IBM_CPM_UART0},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART1_IO_BASE, UART1_INT, IBM_CPM_UART1},
+	{OCP_VENDOR_IBM, OCP_FUNC_16550, UART2_IO_BASE, UART2_INT, IBM_CPM_UART2},
+	{OCP_VENDOR_IBM, OCP_FUNC_IIC, IIC0_BASE, IIC0_IRQ, IBM_CPM_IIC0},
+	{OCP_VENDOR_IBM, OCP_FUNC_IIC, IIC1_BASE, IIC1_IRQ, IBM_CPM_IIC1},
+	{OCP_VENDOR_IBM, OCP_FUNC_GPIO, GPIO0_BASE, OCP_IRQ_NA, IBM_CPM_GPIO0},
+	{OCP_VENDOR_IBM, OCP_FUNC_IDE, IDE0_BASE, IDE0_IRQ, OCP_CPM_NA},
+	{OCP_VENDOR_IBM, OCP_FUNC_USB, USB0_BASE, USB0_IRQ, IBM_CPM_USB0},
+	{OCP_VENDOR_INVALID, OCP_FUNC_INVALID, 0x0, OCP_IRQ_NA, OCP_CPM_NA},
 };
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibmstb4.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibmstb4.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ibmstb4.h	2003-02-11 23:48:52.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ibmstb4.h	2003-06-03 21:59:11.000000000 +0000
@@ -14,7 +14,6 @@
 #define __ASM_IBMSTB4_H__
 
 #include <linux/config.h>
-#include <platforms/4xx/ibm_ocp.h>
 
 /* serial port defines */
 #define STB04xxx_IO_BASE	((uint)0xe0000000)
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ocotea.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/ocotea.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ocotea.c	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ocotea.c	2003-11-04 20:20:04.000000000 +0000
@@ -144,7 +144,7 @@ ocotea_setup_pcix(void)
 	/* Setup 2GB PCI->PLB inbound memory window at 0, enable MSIs */
 	PCIX_WRITEL(0x00000000, PCIX0_PIM0LAH);
 	PCIX_WRITEL(0x00000000, PCIX0_PIM0LAL);
-	PCIX_WRITEL(0xe0000007, PCIX0_PIM0SA);
+	PCIX_WRITEL(0x80000007, PCIX0_PIM0SA);
 
 	eieio();
 }
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ocotea.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/ocotea.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/ocotea.h	2003-09-03 12:16:34.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/ocotea.h	2003-11-18 21:10:26.000000000 +0000
@@ -25,7 +25,7 @@
 #define PPC44x_EMAC0_MR0	0xE0000800
 
 /* Location of MAC addresses in firmware */
-#define OCOTEA_MAC_BASE		(OCOTEA_SMALL_FLASH_HIGH+0xc0500)
+#define OCOTEA_MAC_BASE		(OCOTEA_SMALL_FLASH_HIGH+0xb0500)
 #define OCOTEA_MAC_SIZE		0x200
 #define OCOTEA_MAC1_OFFSET	0x100
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/rainier.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/rainier.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/rainier.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/rainier.c	2003-06-21 01:52:18.000000000 +0000
@@ -0,0 +1,229 @@
+/*
+ *
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Author: MontaVista Software, Inc.
+ *      	akuster@mvista.com <source@mvista.com>
+ *
+ *    Module name: rainier.c
+ *
+ *    Description:
+ *      Architecture- / platform-specific boot-time initialization code for
+ *      IBM PowerPC 4xx based boards. Adapted from original
+ *      code from walnut.c
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/threads.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/blk.h>
+#include <linux/pci.h>
+#include <linux/rtc.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/pci-bridge.h>
+#include <asm/processor.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <platforms/ibm_ocp.h>
+#include <asm/todc.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+void *rainier_rtc_base;
+unsigned int rainier_io_page;
+
+void
+*locate_rainier_io(void)
+{
+	unsigned int temp;
+
+	temp = in_le32((void*)PPC405_PCI_CONFIG_ADDR) & PCI_CONFIG_ADDR_MASK;
+	out_le32((void*)PPC405_PCI_CONFIG_ADDR,
+			temp | PCI_CONFIG_CYCLE_ENABLE |PCI_BASE_ADDRESS_2);
+	temp = in_le32((void*)PPC405_PCI_CONFIG_DATA);
+
+	if (temp == (PCI_BASE_ADDRESS_MEM_CARD2 | PCI_BASE_ADDRESS_MEM_PREFETCH))
+		return PPC_405RAINIER2_IO_PAGE;
+	else
+		return PPC_405RAINIER1_IO_PAGE;
+}
+
+int __init
+ppc405_map_irq(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	    /*
+	     *      PCI IDSEL/INTPIN->INTLINE
+	     *      A       B       C       D
+	     */
+	{
+		{28, 28, 28, 28},	/* IDSEL 1 - PCI slot 1 */
+		{29, 29, 29, 29},	/* IDSEL 2 - PCI slot 2 */
+		{30, 30, 30, 30},	/* IDSEL 3 - PCI slot 3 */
+		{31, 31, 31, 31},	/* IDSEL 4 - PCI slot 4 */
+	};
+
+	const long min_idsel = 1, max_idsel = 4, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+
+void __init
+raininer_setup_arch(void)
+{
+	struct uart_port port;
+
+	ppc4xx_setup_arch();
+
+	port.membase = (void*)PPC405_UART0_IO_BASE;
+	port.membase += rainier_io_page;
+	port.irq = PPC405_UART0_INT;
+	port.uartclk = BASE_BAUD * 16;
+	port.iotype = SERIAL_IO_MEM;
+	port.flags = STD_COM_FLAGS;
+	port.line = 0;
+
+        early_serial_setup(&port);
+
+	/* RTC step for the rainier */
+	rainier_rtc_base = (void *) WALNUT_RTC_VADDR;
+	TODC_INIT(TODC_TYPE_DS1743, rainier_rtc_base, rainier_rtc_base,
+		  rainier_rtc_base, 8);
+}
+
+void __init
+bios_fixup(struct pci_controller *hose, struct pcil0_regs *pcip)
+{
+	/*
+	 * Expected PCI mapping:
+	 *
+	 *  PLB addr             PCI memory addr
+	 *  ---------------------       ---------------------
+	 *  0000'0000 - 7fff'ffff <---  0000'0000 - 7fff'ffff
+	 *  8000'0000 - Bfff'ffff --->  8000'0000 - Bfff'ffff
+	 *
+	 *  PLB addr             PCI io addr
+	 *  ---------------------       ---------------------
+	 *  e800'0000 - e800'ffff --->  0000'0000 - 0001'0000
+	 *
+	 * The following code is simplified by assuming that the bootrom
+	 * has been well behaved in following this mapping.
+	 */
+
+#ifdef DEBUG
+	int i;
+
+	printk("ioremap PCLIO_BASE = 0x%x\n", pcip);
+	printk("PCI bridge regs before fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+
+	/* Disable region first */
+	out_le32((void *) &(pcip->pmm[0].ma), 0x00000000);
+	/* PLB starting addr, PCI: 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].la), 0x80000000);
+	/* PCI start addr, 0x80000000 */
+	out_le32((void *) &(pcip->pmm[0].pcila), PPC405_PCI_MEM_BASE);
+	/* 512MB range of PLB to PCI */
+	out_le32((void *) &(pcip->pmm[0].pciha), 0x00000000);
+	/* Enable no pre-fetch, enable region */
+	out_le32((void *) &(pcip->pmm[0].ma), ((0xffffffff -
+						(PPC405_PCI_UPPER_MEM -
+						 PPC405_PCI_MEM_BASE)) | 0x01));
+
+	/*region one used bu rainier*/
+	out_le32((void *) &(pcip->pmm[1].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].la), 0x80000000);
+	out_le32((void *) &(pcip->pmm[1].pcila), 0x80000000);
+	out_le32((void *) &(pcip->pmm[1].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[1].ma), 0xFFFF8001);
+	out_le32((void *) &(pcip->ptm1ms), 0x00000000);
+
+	/* Disable region two */
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].la), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pcila), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].pciha), 0x00000000);
+	out_le32((void *) &(pcip->pmm[2].ma), 0x00000000);
+	out_le32((void *) &(pcip->ptm2ms), 0x00000000);
+
+	/* end work arround */
+
+#ifdef DEBUG
+	printk("PCI bridge regs after fixup \n");
+	for (i = 0; i <= 3; i++) {
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].ma)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].la)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pcila)));
+		printk(" pmm%dma\t0x%x\n", i, in_le32(&(pcip->pmm[i].pciha)));
+	}
+	printk(" ptm1ms\t0x%x\n", in_le32(&(pcip->ptm1ms)));
+	printk(" ptm1la\t0x%x\n", in_le32(&(pcip->ptm1la)));
+	printk(" ptm2ms\t0x%x\n", in_le32(&(pcip->ptm2ms)));
+	printk(" ptm2la\t0x%x\n", in_le32(&(pcip->ptm2la)));
+
+#endif
+}
+
+void __init
+rainier_map_io(void)
+{
+	ppc4xx_map_io();
+
+	io_block_mapping(RAINIER_IO_PAGE_INTERPOSER_PADDR,
+			 RAINIER_IO_PAGE_INTERPOSER_VADDR,PAGE_SIZE , _PAGE_IO);
+
+	io_block_mapping(RAINIER_IO_PAGE_PCI_PADDR,
+			 RAINIER_IO_PAGE_PCI_VADDR,PAGE_SIZE , _PAGE_IO);
+	
+	io_block_mapping(RAINIER_RTC_VADDR,
+			 RAINIER_RTC_PADDR, RAINIER_RTC_SIZE, _PAGE_IO);
+
+	rainier_io_page = locate_rainier_io();
+       
+	io_block_mapping(rainier_io_page ,
+			 rainier_io_page , PAGE_SIZE, _PAGE_IO);
+
+}
+
+void __init
+platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+	      unsigned long r6, unsigned long r7)
+{
+	ppc4xx_init(r3, r4, r5, r6, r7);
+
+	ppc_md.setup_arch = rainier_setup_arch;
+	ppc_md.setup_io_mappings = rainier_map_io;
+
+	ppc_md.time_init	 	= m48t3x_time_init;
+	ppc_md.set_rtc_time	 	= m48t3x_set_rtc_time;
+	ppc_md.get_rtc_time	 	= m48t3x_get_rtc_time;
+	ppc_md.time_init = todc_time_init;
+	ppc_md.nvram_read_val = todc_direct_read_val;
+	ppc_md.nvram_write_val = todc_direct_write_val;
+}
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/rainier.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/rainier.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/rainier.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/rainier.h	2002-12-05 02:30:44.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *	NP405GS modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	Akuster@mvista.com or source@mvista.com
+ *
+ *    Module name: rainier.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      Network processor based boards.
+ *
+ *      This includes:
+ *
+ *         NP405GS "Rainier" evaluation board
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_RAINIER_H__
+#define __ASM_RAINIER_H__
+
+/* We have a N405GS core */
+#include <platforms/ibmnp4gs.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * Data structure defining board information maintained 
+ * manuals since the rainer uses vxworks
+ */
+
+typedef struct board_info {
+	unsigned char bi_s_version[4];		/* Version of this structure */
+	unsigned char bi_r_version[30];		/* Version of the IBM ROM */
+	unsigned int bi_memsize;		/* DRAM installed, in bytes */
+	unsigned char bi_enetaddr[6];		/* Local Ethernet MAC address */
+	unsigned char bi_pci_enetaddr[6];	/* PCI Ethernet MAC address */
+	unsigned int bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int bi_busfreq;		/* PLB Bus speed, in Hz */
+	unsigned int bi_pci_busfreq;		/* PCI Bus speed, in Hz */
+} bd_t;
+
+#define bi_tbfreq bi_intfreq
+
+extern void *rainer_rtc_base;
+#define RAINIER_RTC_PADDR	((uint)0xf0000000)
+#define RAINIER_RTC_VADDR	RAINIER_RTC_PADDR
+#define RAINIER_RTC_SIZE	((uint)8*1024)
+
+#define BASE_BAUD		115200
+
+#define PPC4xx_MACHINE_NAME	"IBM Rainier"
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_RAINIER_H__ */
+#endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood.h	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood.h	2003-09-12 17:39:40.000000000 +0000
@@ -28,6 +28,8 @@ typedef struct board_info {
 	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
 	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
 } bd_t;
 #define bi_tbfreq bi_intfreq
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood5.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood5.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood5.h	2003-04-02 20:04:29.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood5.h	2003-07-18 01:36:49.000000000 +0000
@@ -29,6 +29,8 @@ typedef struct board_info {
 	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
 	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[2];		/* Use fast i2c mode */
 } bd_t;
 #endif /* !__ASSEMBLY__ */
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood6.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood6.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/redwood6.h	2003-04-02 20:04:29.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/redwood6.h	2003-07-18 01:36:49.000000000 +0000
@@ -21,14 +21,16 @@
 
 #ifndef __ASSEMBLY__
 typedef struct board_info {
-	unsigned char bi_s_version[4];	/* Version of this structure */
-	unsigned char bi_r_version[30];	/* Version of the IBM ROM */
-	unsigned int bi_memsize;	/* DRAM installed, in bytes */
-	unsigned int bi_dummy;	/* field shouldn't exist */
-	unsigned char bi_enetaddr[6];	/* Ethernet MAC address */
-	unsigned int bi_intfreq;	/* Processor speed, in Hz */
-	unsigned int bi_busfreq;	/* Bus speed, in Hz */
-	unsigned int bi_tbfreq;	/* Software timebase freq */
+	unsigned char	bi_s_version[4];	/* Version of this structure */
+	unsigned char	bi_r_version[30];	/* Version of the IBM ROM */
+	unsigned int	bi_memsize;		/* DRAM installed, in bytes */
+	unsigned int	bi_dummy;		/* field shouldn't exist */
+	unsigned char	bi_enetaddr[6];		/* Ethernet MAC address */
+	unsigned int	bi_intfreq;		/* Processor speed, in Hz */
+	unsigned int	bi_busfreq;		/* Bus speed, in Hz */
+	unsigned int	bi_tbfreq;		/* Software timebase freq */
+	unsigned int	bi_opb_busfreq;		/* OPB Bus speed, in Hz */
+	int		bi_iic_fast[1];		/* Use fast i2c mode */
 } bd_t;
 #endif				/* !__ASSEMBLY__ */
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/subzero.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/subzero.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/subzero.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/subzero.c	2003-06-12 22:26:52.000000000 +0000
@@ -0,0 +1,96 @@
+/*
+ * arch/ppc/platforms/subzero.c  Platform setup for the IBM Subzero CPU core card.
+ *
+ *				Based on arctic1.c by Ken Inoue, which
+ *				was based on beech.c by Bishop Brock
+ *
+ * The source code contained herein is licensed under the IBM Public License
+ * Version 1.0, which has been approved by the Open Source Initiative.
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David Gibson
+ * IBM OzLabs, Canberra, Australia
+ * <dwg@au1.ibm.com>
+ */
+
+#include <linux/blk.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/rtc.h>
+#include <linux/string.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+/* 
+   Subzero core card physical memory map:
+
+   Main Memory (Initialized by the BIOS)
+   =======================================================================
+
+   SDRAM (32 MB)     0x00000000 - 0x02000000
+
+   OPB Space: (Mapped virtual = physical in ppc4xx_setup.c)
+   =======================================================================
+
+   UART0               	      0xEF600300
+   UART1               	      0xEF600400
+   IIC                 	      0xEF600500
+   OPB Arbiter         	      0xEF600600
+   GPIO Controller     	      0xEF600700
+   CODEC Interface            0xEF600900
+   Touch Panel Controller     0xEF600A00
+   DES Controller             0xEF600B00
+
+   
+   EBC Space: (Mapped virtual = physical in board_io_mapping())
+	      (EBC setup for personality cards left to individual card setups) 
+   Space             EBC Bank    Physical Addresses  EBC Base Address
+   =========================================================================
+   Boot/Linux Flash      0       FF000000 - FFFFFFFF  FF000000 (16MB)
+
+*/
+
+
+/****************************************************************************
+ * EBC Setup
+ ****************************************************************************/
+
+/* The EBC is set up for Arctic1.  This may simply replicate the setup already
+   done by the IBM BIOS for Arctic1 (possibly with some address map changes), or
+   may be the first initialization if the board is booting from another BIOS.
+   Virtually all that is required to boot Linux on Subzero is that the BIOS
+   enable the memory controller, load a Linux image from flash, and run it.
+
+   For optimal dynamic frequency scaling the EBC settings will also vary as the
+   frequency varies.
+*/
+
+void __init
+subzero_core_ebc_setup(void)
+{
+	ebc0_bnap_t ap;
+
+	/* Set EBC bank 0 for the boot/data flash.
+
+	   Access parameters assume 150ns Intel flash @ 66.66 MHz maximum bus
+	   speed = 10 cycle access with 2 turnaround cycles (30 ns).
+
+	   NB: IBM BIOS sets this bank to burst, however bursting will never
+	   happen in Linux because this region is mapped non-cacheable and
+	   guarded, so it is set non-burst here. */
+	ap.reg = mfdcri(DCRN_EBC0, BnAP(0)) & EBC0_BnAP_MASK;
+	ap.fields.twt = 10;
+	ap.fields.th = 2;
+	mtdcri(DCRN_EBC0, BnAP(0), ap.reg);
+
+}
+
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/subzero.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/subzero.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/subzero.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/subzero.h	2003-07-18 01:36:49.000000000 +0000
@@ -0,0 +1,100 @@
+/*
+ * arch/ppc/platforms/subzero.h   Platform definitions for the IBM 
+ *				Subzero card, based on beech.h by Bishop Brock
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David Gibson
+ * IBM OzLabs, Canberra, Australia
+ * <arctic@gibson.dropbear.id.au>
+ *
+ * Ken Inoue 
+ * IBM Thomas J. Watson Research Center
+ * <keninoue@us.ibm.com>
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_SUBZERO_CORE_H__
+#define __ASM_SUBZERO_CORE_H__
+
+#include <platforms/4xx/ibm405lp.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+
+/*
+ * Data structure defining board information maintained by the standard boot
+ * ROM on the IBM Subzero card. An effort has been made to
+ * keep the field names consistent with the 8xx 'bd_t' board info
+ * structures.
+ * 
+ * Original Beech BIOS Definition:
+ * 
+ * typedef struct board_cfg_data {
+ *    unsigned char     usr_config_ver[4];
+ *    unsigned long     timerclk_freq;
+ *    unsigned char     rom_sw_ver[30];
+ *    unsigned int      mem_size;
+ *    unsigned long     sysclock_period;
+ *    unsigned long     sys_speed;
+ *    unsigned long     cpu_speed;
+ *    unsigned long     vco_speed;
+ *    unsigned long     plb_speed;
+ *    unsigned long     opb_speed;
+ *    unsigned long     ebc_speed;
+ *  } bd_t;
+ */
+
+typedef struct board_info {
+	unsigned char     bi_s_version[4];  /* Version of this structure */
+	unsigned long     bi_tbfreq;        /* Frequency of SysTmrClk */
+	unsigned char     bi_r_version[30]; /* Version of the IBM ROM */
+	unsigned int      bi_memsize;       /* DRAM installed, in bytes */
+	unsigned long     sysclock_period;  /* SysClk period in ns */
+	unsigned long     sys_speed;        /* SysCLk frequency in Hz */
+	unsigned long     bi_intfreq;       /* Processor speed, in Hz */
+	unsigned long     vco_speed;        /* PLL VCO speed, in Hz */
+	unsigned long     bi_busfreq;       /* PLB Bus speed, in Hz */
+	unsigned long     bi_opb_busfreq;   /* OPB Bus speed, in Hz */
+	unsigned long     bi_ebc_busfreq;   /* EBC Bus speed, in Hz */
+	int		  bi_iic_fast[1];   /* Use fast i2c mode */
+} bd_t;
+
+/* EBC Bank 0 controls the boot flash
+ *
+ * FIXME? these values assume that there is 16MB of flash on the
+ * personality card, in addition to the 16MB on the subzero card
+ * itself */
+#define SUBZERO_BANK0_PADDR      ((uint)0xfe000000)
+#define SUBZERO_BANK0_EBC_SIZE   EBC0_BnCR_BS_32MB
+
+#define SUBZERO_BOOTFLASH_PADDR  (SUBZERO_BANK0_PADDR)
+#define SUBZERO_BOOTFLASH_SIZE   ((uint)(32 * 1024 * 1024))
+
+#define PCI_DRAM_OFFSET		0
+
+void *beech_sram_alloc(size_t size);
+int beech_sram_free(void *p);
+
+void subzero_core_ebc_setup(void);
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __ASM_SUBZERO_CORE_H__ */
+#endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/sycamore.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/sycamore.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/sycamore.h	2003-02-11 23:48:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/sycamore.h	2003-07-18 01:36:49.000000000 +0000
@@ -35,6 +35,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+	unsigned long	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c linuxppc-2.5-benh/arch/ppc/platforms/4xx/virtex-ii_pro.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/virtex-ii_pro.c	2002-12-05 02:30:44.000000000 +0000
@@ -0,0 +1,61 @@
+/*
+ *
+ *    Copyright 2000-2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *	Current maintainer
+ *      Armin Kuster akuster@mvista.com
+ *
+ *    Module name: virtex-ii_pro.c
+ *Xilinx Manua Loa 2 evaluation board initialization
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/ocp.h>
+#include "virtex-ii_pro.h"
+
+/* Have OCP take care of the serial ports. */
+struct ocp_def core_ocp[] = {
+#ifdef XPAR_UARTNS550_0_BASEADDR
+	{UART, XPAR_UARTNS550_0_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_0_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_1_BASEADDR
+	{UART, XPAR_UARTNS550_1_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_1_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_2_BASEADDR
+	{UART, XPAR_UARTNS550_2_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_2_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_3_BASEADDR
+	{UART, XPAR_UARTNS550_3_BASEADDR, 31 - XPAR_INTC_0_UARTNS550_3_VEC_ID,
+	 OCP_CPM_NA},
+#ifdef XPAR_UARTNS550_4_BASEADDR
+#error Edit this file to add more devices.
+#endif				/* 4 */
+#endif				/* 3 */
+#endif				/* 2 */
+#endif				/* 1 */
+#endif				/* 0 */
+	{OCP_NULL_TYPE, 0x0, OCP_IRQ_NA, OCP_CPM_NA}
+};
+
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/virtex-ii_pro.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/virtex-ii_pro.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/virtex-ii_pro.h	2002-11-07 07:07:25.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+ * virtex-ii_pro.h
+ *
+ * Include file that defines the Xilinx Virtex-II Pro processor
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASM_VIRTEXIIPRO_H__
+#define __ASM_VIRTEXIIPRO_H__
+
+#include <linux/config.h>
+#include <asm/xilinx_ocp.h>
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+# define RS_TABLE_SIZE  64
+#else
+# define RS_TABLE_SIZE  4
+#endif
+
+#define DCRN_CPMFR_BASE	0
+
+#include <asm/ibm405.h>
+
+#endif				/* __ASM_VIRTEXIIPRO_H__ */
+#endif				/* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/4xx/walnut.h linuxppc-2.5-benh/arch/ppc/platforms/4xx/walnut.h
--- /dev/shm/linux-2.5/arch/ppc/platforms/4xx/walnut.h	2003-02-11 23:48:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/4xx/walnut.h	2003-07-18 01:36:49.000000000 +0000
@@ -40,6 +40,8 @@ typedef struct board_info {
 	unsigned int	 bi_intfreq;		/* Processor speed, in Hz */
 	unsigned int	 bi_busfreq;		/* PLB Bus speed, in Hz */
 	unsigned int	 bi_pci_busfreq;	/* PCI Bus speed, in Hz */
+	unsigned long	 bi_opb_busfreq;	/* OPB Bus speed, in Hz */
+	int		 bi_iic_fast[1];	/* Use fast i2c mode */
 } bd_t;
 
 /* Some 4xx parts use a different timebase frequency from the internal clock.
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/Makefile linuxppc-2.5-benh/arch/ppc/platforms/Makefile
--- /dev/shm/linux-2.5/arch/ppc/platforms/Makefile	2003-07-03 00:44:14.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/Makefile	2003-12-31 03:57:53.000000000 +0000
@@ -11,13 +11,18 @@ endif
 
 # Extra CFLAGS so we don't have to do relative includes
 CFLAGS_pmac_setup.o	+= -Iarch/$(ARCH)/mm
+CFLAGS_spruce_setup.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_spruce_pci.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_pal4_setup.o	+= -Iarch/$(ARCH)/kernel
+CFLAGS_pal4_pci.o	+= -Iarch/$(ARCH)/kernel
 
 obj-$(CONFIG_APUS)		+= apus_setup.o
 ifeq ($(CONFIG_APUS),y)
 obj-$(CONFIG_PCI)		+= apus_pci.o
 endif
 obj-$(CONFIG_PPC_PMAC)		+= pmac_pic.o pmac_setup.o pmac_time.o \
-					pmac_feature.o pmac_pci.o pmac_sleep.o
+					pmac_feature.o pmac_pci.o pmac_sleep.o \
+					pmac_low_i2c.o
 obj-$(CONFIG_PPC_CHRP)		+= chrp_setup.o chrp_time.o chrp_pci.o
 obj-$(CONFIG_PPC_PREP)		+= prep_pci.o prep_time.o prep_setup.o
 ifeq ($(CONFIG_PPC_PMAC),y)
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/ev64260_setup.c linuxppc-2.5-benh/arch/ppc/platforms/ev64260_setup.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/ev64260_setup.c	2003-09-12 16:26:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/ev64260_setup.c	2003-09-12 17:39:39.000000000 +0000
@@ -35,6 +35,7 @@
 #if	!defined(CONFIG_GT64260_CONSOLE)
 #include <linux/serial.h>
 #endif
+#include <linux/serial_core.h>
 
 #include <asm/system.h>
 #include <asm/pgtable.h>
@@ -184,7 +185,7 @@ static void __init
 ev64260_setup_arch(void)
 {
 #if	!defined(CONFIG_GT64260_CONSOLE)
-	struct serial_struct	serial_req;
+	struct uart_port port;
 #endif
 
 	if ( ppc_md.progress )
@@ -228,27 +229,25 @@ ev64260_setup_arch(void)
 	TODC_INIT(TODC_TYPE_DS1501, 0, 0, ioremap(EV64260_TODC_BASE,0x20), 8);
 
 #if	!defined(CONFIG_GT64260_CONSOLE)
-	memset(&serial_req, 0, sizeof(serial_req));
-	serial_req.line = 0;
-	serial_req.baud_base = BASE_BAUD;
-	serial_req.port = 0;
-	serial_req.irq = 85;
-	serial_req.flags = STD_COM_FLAGS;
-	serial_req.io_type = SERIAL_IO_MEM;
-	serial_req.iomem_base = ioremap(EV64260_SERIAL_0, 0x20);
-	serial_req.iomem_reg_shift = 2;
+	memset(&port, 0, sizeof(port));
+	port.membase = ioremap(EV64260_SERIAL_0, 0x20);
+	port.irq = 85;
+	port.uartclk = BASE_BAUD * 16;
+	port.regshift = 2;
+	port.flags = STD_COM_FLAGS;
+	port.iotype = SERIAL_IO_MEM;
+	port.line = 0;
 
-	if (early_serial_setup(&serial_req) != 0) {
+	if (early_serial_setup(&port) != 0) {
 		printk("Early serial init of port 0 failed\n");
 	}
 
 	/* Assume early_serial_setup() doesn't modify serial_req */
-	serial_req.line = 1;
-	serial_req.port = 1;
-	serial_req.irq = 86;
-	serial_req.iomem_base = ioremap(EV64260_SERIAL_1, 0x20);
+	port.membase = ioremap(EV64260_SERIAL_1, 0x20);
+	port.irq = 86;
+	port.line = 1;
 
-	if (early_serial_setup(&serial_req) != 0) {
+	if (early_serial_setup(&port) != 0) {
 		printk("Early serial init of port 1 failed\n");
 	}
 #endif
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_backlight.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_backlight.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_backlight.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_backlight.c	2003-11-14 08:54:26.000000000 +0000
@@ -8,6 +8,7 @@
 
 #include <linux/config.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/stddef.h>
 #include <linux/reboot.h>
 #include <linux/nvram.h>
@@ -37,6 +38,10 @@ register_backlight_controller(struct bac
 	char *prop;
 	int valid = 0;
 
+	/* There's already a matching controller, bail out */
+	if (backlighter != NULL)
+		return;
+
 	bk_node = find_devices("backlight");
 
 #ifdef CONFIG_ADB_PMU
@@ -84,6 +89,7 @@ register_backlight_controller(struct bac
 	printk(KERN_INFO "Registered \"%s\" backlight controller, level: %d/15\n",
 		type, backlight_level);
 }
+EXPORT_SYMBOL(register_backlight_controller);
 
 void __pmac
 unregister_backlight_controller(struct backlight_controller *ctrler, void *data)
@@ -92,6 +98,7 @@ unregister_backlight_controller(struct b
 	if (ctrler == backlighter && data == backlighter_data)
 		backlighter = NULL;
 }
+EXPORT_SYMBOL(unregister_backlight_controller);
 
 int __pmac
 set_backlight_enable(int enable)
@@ -105,6 +112,7 @@ set_backlight_enable(int enable)
 		backlight_enabled = enable;
 	return rc;
 }
+EXPORT_SYMBOL(set_backlight_enable);
 
 int __pmac
 get_backlight_enable(void)
@@ -113,6 +121,7 @@ get_backlight_enable(void)
 		return -ENODEV;
 	return backlight_enabled;
 }
+EXPORT_SYMBOL(get_backlight_enable);
 
 int __pmac
 set_backlight_level(int level)
@@ -137,6 +146,7 @@ set_backlight_level(int level)
 	}
 	return rc;
 }
+EXPORT_SYMBOL(set_backlight_level);
 
 int __pmac
 get_backlight_level(void)
@@ -145,3 +155,4 @@ get_backlight_level(void)
 		return -ENODEV;
 	return backlight_level;
 }
+EXPORT_SYMBOL(get_backlight_level);
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_cpufreq.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_cpufreq.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_cpufreq.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_cpufreq.c	2004-01-04 00:20:47.000000000 +0000
@@ -22,6 +22,7 @@
 #include <linux/cpufreq.h>
 #include <linux/init.h>
 #include <linux/sysdev.h>
+#include <linux/i2c.h>
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/irq.h>
@@ -38,6 +39,14 @@
  */
 #undef DEBUG_FREQ
 
+/*
+ * There is a problem with the core cpufreq code on SMP kernels,
+ * it won't recalculate the Bogomips properly
+ */
+#ifdef CONFIG_SMP
+#warning "WARNING, CPUFREQ not recommended on SMP kernels"
+#endif
+
 extern void low_choose_750fx_pll(int pll);
 extern void low_sleep_handler(void);
 extern void openpic_suspend(struct sys_device *sysdev, u32 state);
@@ -48,7 +57,14 @@ extern void enable_kernel_fp(void);
 static unsigned int low_freq;
 static unsigned int hi_freq;
 static unsigned int cur_freq;
+
+/* Clean that up some day ... use a func ptr or at least an enum... */
 static int cpufreq_uses_pmu;
+static int cpufreq_uses_gpios;
+
+static u32 voltage_gpio;
+static u32 frequency_gpio;
+static u32 slew_done_gpio;
 
 #define PMAC_CPU_LOW_SPEED	1
 #define PMAC_CPU_HIGH_SPEED	0
@@ -65,8 +81,7 @@ static struct cpufreq_frequency_table pm
 	{0,			CPUFREQ_TABLE_END},
 };
 
-static inline void
-wakeup_decrementer(void)
+static inline void wakeup_decrementer(void)
 {
 	set_dec(tb_ticks_per_jiffy);
 	/* No currently-supported powerbook has a 601,
@@ -76,8 +91,7 @@ wakeup_decrementer(void)
 }
 
 #ifdef DEBUG_FREQ
-static inline void
-debug_calc_bogomips(void)
+static inline void debug_calc_bogomips(void)
 {
 	/* This will cause a recalc of bogomips and display the
 	 * result. We backup/restore the value to avoid affecting the
@@ -89,17 +103,18 @@ debug_calc_bogomips(void)
 	calibrate_delay();
 	loops_per_jiffy = save_lpj;
 }
-#endif
+#endif /* DEBUG_FREQ */
 
 /* Switch CPU speed under 750FX CPU control
  */
-static int __pmac
-cpu_750fx_cpu_speed(int low_speed)
+static int __pmac cpu_750fx_cpu_speed(int low_speed)
 {
 #ifdef DEBUG_FREQ
 	printk(KERN_DEBUG "HID1, before: %x\n", mfspr(SPRN_HID1));
 #endif
+#ifdef CONFIG_6xx
 	low_choose_750fx_pll(low_speed);
+#endif
 #ifdef DEBUG_FREQ
 	printk(KERN_DEBUG "HID1, after: %x\n", mfspr(SPRN_HID1));
 	debug_calc_bogomips();
@@ -108,15 +123,54 @@ cpu_750fx_cpu_speed(int low_speed)
 	return 0;
 }
 
+/* Switch CPU speed using slewing GPIOs
+ */
+static int __pmac gpios_set_cpu_speed(unsigned int low_speed)
+{
+	int gpio;
+
+	/* If ramping up, set voltage first */
+	if (low_speed == 0) {
+		pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);
+		/* Delay is way too big but it's ok, we schedule */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
+	}
+
+	/* Set frequency */
+	pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, frequency_gpio, low_speed ? 0x04 : 0x05);
+	udelay(200);
+	do {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+		gpio = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, slew_done_gpio, 0);
+	} while((gpio & 0x02) == 0);
+
+	/* If ramping down, set voltage last */
+	if (low_speed == 1) {
+		pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);
+		/* Delay is way too big but it's ok, we schedule */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
+	}
+
+#ifdef DEBUG_FREQ
+	debug_calc_bogomips();
+#endif
+
+	return 0;
+}
+
 /* Switch CPU speed under PMU control
  */
-static int __pmac
-pmu_set_cpu_speed(unsigned int low_speed)
+static int __pmac pmu_set_cpu_speed(unsigned int low_speed)
 {
 	struct adb_request req;
 	unsigned long save_l2cr;
 	unsigned long save_l3cr;
 
+	preempt_disable();
+
 #ifdef DEBUG_FREQ
 	printk(KERN_DEBUG "HID1, before: %x\n", mfspr(SPRN_HID1));
 #endif
@@ -197,11 +251,12 @@ pmu_set_cpu_speed(unsigned int low_speed
 	debug_calc_bogomips();
 #endif
 
+	preempt_enable();
+
 	return 0;
 }
 
-static int __pmac
-do_set_cpu_speed(int speed_mode)
+static int __pmac do_set_cpu_speed(int speed_mode)
 {
 	struct cpufreq_freqs freqs;
 	int rc;
@@ -216,6 +271,8 @@ do_set_cpu_speed(int speed_mode)
 	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 	if (cpufreq_uses_pmu)
 		rc = pmu_set_cpu_speed(speed_mode);
+	else if (cpufreq_uses_gpios)
+		rc = gpios_set_cpu_speed(speed_mode);
 	else
 		rc = cpu_750fx_cpu_speed(speed_mode);
 	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
@@ -224,16 +281,14 @@ do_set_cpu_speed(int speed_mode)
 	return rc;
 }
 
-static int __pmac
-pmac_cpufreq_verify(struct cpufreq_policy *policy)
+static int __pmac pmac_cpufreq_verify(struct cpufreq_policy *policy)
 {
 	return cpufreq_frequency_table_verify(policy, pmac_cpu_freqs);
 }
 
-static int __pmac
-pmac_cpufreq_target(	struct cpufreq_policy *policy,
-			unsigned int target_freq,
-			unsigned int relation)
+static int __pmac pmac_cpufreq_target(	struct cpufreq_policy *policy,
+					unsigned int target_freq,
+					unsigned int relation)
 {
 	unsigned int    newstate = 0;
 
@@ -244,15 +299,13 @@ pmac_cpufreq_target(	struct cpufreq_poli
 	return do_set_cpu_speed(newstate);
 }
 
-unsigned int __pmac
-pmac_get_one_cpufreq(int i)
+unsigned int __pmac pmac_get_one_cpufreq(int i)
 {
 	/* Supports only one CPU for now */
 	return (i == 0) ? cur_freq : 0;
 }
 
-static int __pmac
-pmac_cpufreq_cpu_init(struct cpufreq_policy *policy)
+static int __pmac pmac_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
 	if (policy->cpu != 0)
 		return -ENODEV;
@@ -264,6 +317,18 @@ pmac_cpufreq_cpu_init(struct cpufreq_pol
 	return cpufreq_frequency_table_cpuinfo(policy, &pmac_cpu_freqs[0]);
 }
 
+static u32 __pmac read_gpio(struct device_node *np)
+{
+	u32 *reg = (u32 *)get_property(np, "reg", NULL);
+
+	if (reg == NULL)
+		return 0;
+	/* That works for all keylargos but shall be fixed properly
+	 * some day...
+	 */
+	return 0x50 + (*reg);
+}
+
 static struct cpufreq_driver pmac_cpufreq_driver = {
 	.verify 	= pmac_cpufreq_verify,
 	.target 	= pmac_cpufreq_target,
@@ -272,15 +337,17 @@ static struct cpufreq_driver pmac_cpufre
 	.owner		= THIS_MODULE,
 };
 
+
 /* Currently, we support the following machines:
  *
+ *  - Titanium PowerBook 1Ghz (PMU based, 667Mhz & 1Ghz)
  *  - Titanium PowerBook 800 (PMU based, 667Mhz & 800Mhz)
  *  - Titanium PowerBook 500 (PMU based, 300Mhz & 500Mhz)
  *  - iBook2 500 (PMU based, 400Mhz & 500Mhz)
  *  - iBook2 700 (CPU based, 400Mhz & 700Mhz, support low voltage)
+ *  - Recent MacRISC3 machines
  */
-static int __init
-pmac_cpufreq_setup(void)
+static int __init pmac_cpufreq_setup(void)
 {
 	struct device_node	*cpunode;
 	u32			*value;
@@ -304,10 +371,79 @@ pmac_cpufreq_setup(void)
 	if (machine_is_compatible("PowerBook3,4") ||
 	    machine_is_compatible("PowerBook3,5") ||
 	    machine_is_compatible("MacRISC3")) {
+		struct device_node *volt_gpio_np = of_find_node_by_name(NULL, "voltage-gpio");
+		struct device_node *freq_gpio_np = of_find_node_by_name(NULL, "frequency-gpio");
+		struct device_node *slew_done_gpio_np = of_find_node_by_name(NULL, "slewing-done");
+
+		/*
+		 * Check to see if it's GPIO driven or PMU only
+		 *
+		 * The way we extract the GPIO address is slightly hackish, but it
+		 * works well enough for now. We need to abstract the whole GPIO
+		 * stuff sooner or later anyway
+		 */
+
+		if (volt_gpio_np)
+			voltage_gpio = read_gpio(volt_gpio_np);
+		if (freq_gpio_np)
+			frequency_gpio = read_gpio(freq_gpio_np);
+		if (slew_done_gpio_np)
+			slew_done_gpio = read_gpio(slew_done_gpio_np);
+
+		/* If we use the frequency GPIOs, calculate the min/max speeds based
+		 * on the bus frequencies
+		 */
+		if (frequency_gpio && slew_done_gpio) {
+			int lenp, rc;
+			u32 *freqs, *ratio;
+
+			freqs = (u32 *)get_property(cpunode, "bus-frequencies", &lenp);
+			lenp /= sizeof(u32);
+			if (freqs == NULL || lenp != 2) {
+				printk(KERN_ERR "cpufreq: bus-frequencies incorrect or missing\n");
+				goto out;
+			}
+			ratio = (u32 *)get_property(cpunode, "processor-to-bus-ratio*2", NULL);
+			if (ratio == NULL) {
+				printk(KERN_ERR "cpufreq: processor-to-bus-ratio*2 missing\n");
+				goto out;
+			}
+
+			/* Get the min/max bus frequencies */
+			low_freq = min(freqs[0], freqs[1]);
+			hi_freq = max(freqs[0], freqs[1]);
+
+			/* Grrrr.. It _seems_ that the device-tree is lying on the low bus
+			 * frequency, it claims it to be around 84Mhz on some models while
+			 * it appears to be approx. 101Mhz on all. Let's hack around here...
+			 * fortunately, we don't need to be too precise
+			 */
+			if (low_freq < 98000000)
+				low_freq = 101000000;
+			
+			/* Convert those to CPU core clocks */
+			low_freq = (low_freq * (*ratio)) / 2000;
+			hi_freq = (hi_freq * (*ratio)) / 2000;
+
+			/* Now we get the frequencies, we read the GPIO to see what is out current
+			 * speed
+			 */
+			rc = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, frequency_gpio, 0);
+			cur_freq = (rc & 0x01) ? hi_freq : low_freq;
+
+			has_freq_ctl = 1;
+			cpufreq_uses_gpios = 1;
+			goto out;
+		}
+
+		/* If we use the PMU, look for the min & max frequencies in the
+		 * device-tree
+		 */
 		value = (u32 *)get_property(cpunode, "min-clock-frequency", NULL);
 		if (!value)
 			goto out;
 		low_freq = (*value) / 1000;
+
 		/* The PowerBook G4 12" (PowerBook6,1) has an error in the device-tree
 		 * here */
 		if (low_freq < 100000)
@@ -359,6 +495,11 @@ out:
 	pmac_cpu_freqs[CPUFREQ_LOW].frequency = low_freq;
 	pmac_cpu_freqs[CPUFREQ_HIGH].frequency = hi_freq;
 
+	printk(KERN_INFO "Registering PowerMac CPU frequency driver\n");
+	printk(KERN_INFO "Low: %d Mhz, High: %d Mhz, Boot: %d Mhz, switch method: %s\n",
+	       low_freq/1000, hi_freq/1000, cur_freq/1000,
+	       cpufreq_uses_pmu ? "PMU" : (cpufreq_uses_gpios ? "GPIOs" : "CPU"));
+
 	return cpufreq_register_driver(&pmac_cpufreq_driver);
 }
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_feature.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_feature.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_feature.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_feature.c	2003-12-31 10:14:23.000000000 +0000
@@ -41,6 +41,7 @@
 #include <asm/pmac_feature.h>
 #include <asm/dbdma.h>
 #include <asm/pci-bridge.h>
+#include <asm/pmac_low_i2c.h>
 
 #undef DEBUG_FEATURE
 
@@ -50,9 +51,13 @@
 #define DBG(fmt,...)
 #endif
 
-/* Exported from arch/ppc/kernel/idle.c */
+#ifdef CONFIG_6xx
 extern int powersave_lowspeed;
+#endif
+
 extern int powersave_nap;
+extern struct pci_dev *k2_skiplist[2];
+
 
 /*
  * We use a single global lock to protect accesses. Each driver has
@@ -95,7 +100,8 @@ static const char* macio_names[] __pmacd
 	"Paddington",
 	"Keylargo",
 	"Pangea",
-	"Intrepid"
+	"Intrepid",
+	"K2"
 };
 
 
@@ -113,14 +119,15 @@ static const char* macio_names[] __pmacd
 static struct device_node* uninorth_node __pmacdata;
 static u32* uninorth_base __pmacdata;
 static u32 uninorth_rev __pmacdata;
-
+static int uninorth_u3 __pmacdata;
+static void *u3_ht;
 
 /*
  * For each motherboard family, we have a table of functions pointers
  * that handle the various features.
  */
 
-typedef int (*feature_call)(struct device_node* node, int param, int value);
+typedef long (*feature_call)(struct device_node* node, long param, long value);
 
 struct feature_table_entry {
 	unsigned int	selector;
@@ -161,8 +168,10 @@ simple_feature_tweak(struct device_node*
 	return 0;
 }
 
-static int __pmac
-ohare_htw_scc_enable(struct device_node* node, int param, int value)
+#ifndef CONFIG_POWER4
+
+static long __pmac
+ohare_htw_scc_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		chan_mask;
@@ -254,22 +263,22 @@ ohare_htw_scc_enable(struct device_node*
 	return 0;
 }
 
-static int __pmac
-ohare_floppy_enable(struct device_node* node, int param, int value)
+static long __pmac
+ohare_floppy_enable(struct device_node* node, long param, long value)
 {
 	return simple_feature_tweak(node, macio_ohare,
 		OHARE_FCR, OH_FLOPPY_ENABLE, value);
 }
 
-static int __pmac
-ohare_mesh_enable(struct device_node* node, int param, int value)
+static long __pmac
+ohare_mesh_enable(struct device_node* node, long param, long value)
 {
 	return simple_feature_tweak(node, macio_ohare,
 		OHARE_FCR, OH_MESH_ENABLE, value);
 }
 
-static int __pmac
-ohare_ide_enable(struct device_node* node, int param, int value)
+static long __pmac
+ohare_ide_enable(struct device_node* node, long param, long value)
 {
 	switch(param) {
 	    case 0:
@@ -289,8 +298,8 @@ ohare_ide_enable(struct device_node* nod
 	}
 }
 
-static int __pmac
-ohare_ide_reset(struct device_node* node, int param, int value)
+static long __pmac
+ohare_ide_reset(struct device_node* node, long param, long value)
 {
 	switch(param) {
 	    case 0:
@@ -304,8 +313,8 @@ ohare_ide_reset(struct device_node* node
 	}
 }
 
-static int __pmac
-ohare_sleep_state(struct device_node* node, int param, int value)
+static long __pmac
+ohare_sleep_state(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio = &macio_chips[0];
 
@@ -320,8 +329,8 @@ ohare_sleep_state(struct device_node* no
 	return 0;
 }
 
-static int __pmac
-heathrow_modem_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_modem_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	u8			gpio;
@@ -364,8 +373,8 @@ heathrow_modem_enable(struct device_node
 	return 0;
 }
 
-static int __pmac
-heathrow_floppy_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_floppy_enable(struct device_node* node, long param, long value)
 {
 	return simple_feature_tweak(node, macio_unknown,
 		HEATHROW_FCR,
@@ -373,8 +382,8 @@ heathrow_floppy_enable(struct device_nod
 		value);
 }
 
-static int __pmac
-heathrow_mesh_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_mesh_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -390,22 +399,11 @@ heathrow_mesh_enable(struct device_node*
 		MACIO_BIC(HEATHROW_FCR, HRW_MESH_ENABLE);
 	(void)MACIO_IN32(HEATHROW_FCR);
 	udelay(10);
-	/* Set/Clear termination power (todo: test ! the bit value
-	 * used by Darwin doesn't seem to match what we used so
-	 * far. If you experience problems, turn #if 1 into #if 0
-	 * and tell me about it --BenH.
-	 */
-#if 1
+	/* Set/Clear termination power */
 	if (value)
-		MACIO_BIC(HEATHROW_MBCR, 0x00000004);
+		MACIO_BIC(HEATHROW_MBCR, 0x04000000);
 	else
-		MACIO_BIS(HEATHROW_MBCR, 0x00000004);
-#else
-	if (value)
-		MACIO_BIC(HEATHROW_MBCR, 0x00040000);
-	else
-		MACIO_BIS(HEATHROW_MBCR, 0x00040000);
-#endif
+		MACIO_BIS(HEATHROW_MBCR, 0x04000000);
 	(void)MACIO_IN32(HEATHROW_MBCR);
 	udelay(10);
 	UNLOCK(flags);
@@ -413,8 +411,8 @@ heathrow_mesh_enable(struct device_node*
 	return 0;
 }
 
-static int __pmac
-heathrow_ide_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_ide_enable(struct device_node* node, long param, long value)
 {
 	switch(param) {
 	    case 0:
@@ -428,8 +426,8 @@ heathrow_ide_enable(struct device_node* 
 	}
 }
 
-static int __pmac
-heathrow_ide_reset(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_ide_reset(struct device_node* node, long param, long value)
 {
 	switch(param) {
 	    case 0:
@@ -443,8 +441,8 @@ heathrow_ide_reset(struct device_node* n
 	}
 }
 
-static int __pmac
-heathrow_bmac_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_bmac_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -472,8 +470,8 @@ heathrow_bmac_enable(struct device_node*
 	return 0;
 }
 
-static int __pmac
-heathrow_sound_enable(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_sound_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -608,8 +606,8 @@ heathrow_wakeup(struct macio_chip* macio
 	}
 }
 
-static int __pmac
-heathrow_sleep_state(struct device_node* node, int param, int value)
+static long __pmac
+heathrow_sleep_state(struct device_node* node, long param, long value)
 {
 	if ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)
 		return -EPERM;
@@ -625,8 +623,8 @@ heathrow_sleep_state(struct device_node*
 	return 0;
 }
 
-static int __pmac
-core99_scc_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_scc_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -726,8 +724,8 @@ core99_scc_enable(struct device_node* no
 	return 0;
 }
 
-static int __pmac
-core99_modem_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_modem_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	u8			gpio;
@@ -778,8 +776,8 @@ core99_modem_enable(struct device_node* 
 	return 0;
 }
 
-static int __pmac
-pangea_modem_enable(struct device_node* node, int param, int value)
+static long __pmac
+pangea_modem_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	u8			gpio;
@@ -833,8 +831,8 @@ pangea_modem_enable(struct device_node* 
 	return 0;
 }
 
-static int __pmac
-core99_ata100_enable(struct device_node* node, int value)
+static long __pmac
+core99_ata100_enable(struct device_node* node, long value)
 {
 	unsigned long flags;
 	struct pci_dev *pdev = NULL;
@@ -863,8 +861,8 @@ core99_ata100_enable(struct device_node*
     	return 0;
 }
 
-static int __pmac
-core99_ide_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_ide_enable(struct device_node* node, long param, long value)
 {
 	/* Bus ID 0 to 2 are KeyLargo based IDE, busID 3 is U2
 	 * based ata-100
@@ -886,8 +884,8 @@ core99_ide_enable(struct device_node* no
 	}
 }
 
-static int __pmac
-core99_ide_reset(struct device_node* node, int param, int value)
+static long __pmac
+core99_ide_reset(struct device_node* node, long param, long value)
 {
 	switch(param) {
 	    case 0:
@@ -904,8 +902,8 @@ core99_ide_reset(struct device_node* nod
 	}
 }
 
-static int __pmac
-core99_gmac_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_gmac_enable(struct device_node* node, long param, long value)
 {
 	unsigned long flags;
 
@@ -921,8 +919,8 @@ core99_gmac_enable(struct device_node* n
 	return 0;
 }
 
-static int __pmac
-core99_gmac_phy_reset(struct device_node* node, int param, int value)
+static long __pmac
+core99_gmac_phy_reset(struct device_node* node, long param, long value)
 {
 	unsigned long flags;
 	struct macio_chip* macio;
@@ -938,16 +936,16 @@ core99_gmac_phy_reset(struct device_node
 	UNLOCK(flags);
 	mdelay(10);
 	LOCK(flags);
-	MACIO_OUT8(KL_GPIO_ETH_PHY_RESET, KEYLARGO_GPIO_OUTPUT_ENABLE
-		| KEYLARGO_GPIO_OUTOUT_DATA);
+	MACIO_OUT8(KL_GPIO_ETH_PHY_RESET, /*KEYLARGO_GPIO_OUTPUT_ENABLE | */
+		KEYLARGO_GPIO_OUTOUT_DATA);
 	UNLOCK(flags);
 	mdelay(10);
 
 	return 0;
 }
 
-static int __pmac
-core99_sound_chip_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_sound_chip_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -976,8 +974,8 @@ core99_sound_chip_enable(struct device_n
 	return 0;
 }
 
-static int __pmac
-core99_airport_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_airport_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip*	macio;
 	unsigned long		flags;
@@ -1063,8 +1061,8 @@ core99_airport_enable(struct device_node
 }
 
 #ifdef CONFIG_SMP
-static int __pmac
-core99_reset_cpu(struct device_node* node, int param, int value)
+static long __pmac
+core99_reset_cpu(struct device_node* node, long param, long value)
 {
 	unsigned int reset_io = 0;
 	unsigned long flags;
@@ -1099,7 +1097,7 @@ core99_reset_cpu(struct device_node* nod
 	MACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTPUT_ENABLE);
 	(void)MACIO_IN8(reset_io);
 	udelay(1);
-	MACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTOUT_DATA | KEYLARGO_GPIO_OUTPUT_ENABLE);
+	MACIO_OUT8(reset_io, 0);
 	(void)MACIO_IN8(reset_io);
 	UNLOCK(flags);
 
@@ -1107,8 +1105,8 @@ core99_reset_cpu(struct device_node* nod
 }
 #endif /* CONFIG_SMP */
 
-static int __pmac
-core99_usb_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_usb_enable(struct device_node* node, long param, long value)
 {
 	struct macio_chip* macio;
 	unsigned long flags;
@@ -1121,9 +1119,6 @@ core99_usb_enable(struct device_node* no
 	    macio->type != macio_intrepid)
 		return -ENODEV;
 
-	/* XXX Fix handling of 3rd USB controller in Intrepid, move the
-	 * port connect stuff (KL4_*) to the sleep code eventually
-	 */
 	prop = (char *)get_property(node, "AAPL,clock-id", NULL);
 	if (!prop)
 		return -ENODEV;
@@ -1131,6 +1126,8 @@ core99_usb_enable(struct device_node* no
 		number = 0;
 	else if (strncmp(prop, "usb1u148", 8) == 0)
 		number = 2;
+	else if (strncmp(prop, "usb2u248", 8) == 0)
+		number = 4;
 	else
 		return -ENODEV;
 
@@ -1147,44 +1144,79 @@ core99_usb_enable(struct device_node* no
 			mdelay(1);
 			LOCK(flags);
 			MACIO_BIS(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);
-		} else {
+		} else if (number == 2) {
 			MACIO_BIC(KEYLARGO_FCR0, (KL0_USB1_PAD_SUSPEND0 | KL0_USB1_PAD_SUSPEND1));
 			UNLOCK(flags);
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 			mdelay(1);
 			LOCK(flags);
 			MACIO_BIS(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);
+		} else if (number == 4) {
+			MACIO_BIC(KEYLARGO_FCR1, (KL1_USB2_PAD_SUSPEND0 | KL1_USB2_PAD_SUSPEND1));
+			UNLOCK(flags);
+			(void)MACIO_IN32(KEYLARGO_FCR1);
+			mdelay(1);
+			LOCK(flags);
+			MACIO_BIS(KEYLARGO_FCR0, KL1_USB2_CELL_ENABLE);
+		}
+		if (number < 4) {
+			reg = MACIO_IN32(KEYLARGO_FCR4);
+			reg &=	~(KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |
+				KL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number));
+			reg &=	~(KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |
+				KL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1));
+			MACIO_OUT32(KEYLARGO_FCR4, reg);
+			(void)MACIO_IN32(KEYLARGO_FCR4);
+			udelay(10);
+		} else {
+			reg = MACIO_IN32(KEYLARGO_FCR3);
+			reg &=	~(KL3_IT_PORT_WAKEUP_ENABLE(0) | KL3_IT_PORT_RESUME_WAKE_EN(0) |
+				KL3_IT_PORT_CONNECT_WAKE_EN(0) | KL3_IT_PORT_DISCONNECT_WAKE_EN(0));
+			reg &=	~(KL3_IT_PORT_WAKEUP_ENABLE(1) | KL3_IT_PORT_RESUME_WAKE_EN(1) |
+				KL3_IT_PORT_CONNECT_WAKE_EN(1) | KL3_IT_PORT_DISCONNECT_WAKE_EN(1));
+			MACIO_OUT32(KEYLARGO_FCR3, reg);
+			(void)MACIO_IN32(KEYLARGO_FCR3);
+			udelay(10);
 		}
-		reg = MACIO_IN32(KEYLARGO_FCR4);
-		reg &=	~(KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |
-			KL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number));
-		reg &=	~(KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |
-			KL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1));
-		MACIO_OUT32(KEYLARGO_FCR4, reg);
-		(void)MACIO_IN32(KEYLARGO_FCR4);
-		udelay(10);
 	} else {
 		/* Turn OFF */
-		reg = MACIO_IN32(KEYLARGO_FCR4);
-		reg |=	KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |
-			KL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number);
-		reg |=	KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |
-			KL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1);
-		MACIO_OUT32(KEYLARGO_FCR4, reg);
-		(void)MACIO_IN32(KEYLARGO_FCR4);
-		udelay(1);
+		if (number < 4) {
+			reg = MACIO_IN32(KEYLARGO_FCR4);
+			reg |=	KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |
+				KL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number);
+			reg |=	KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |
+				KL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1);
+			MACIO_OUT32(KEYLARGO_FCR4, reg);
+			(void)MACIO_IN32(KEYLARGO_FCR4);
+			udelay(1);
+		} else {
+			reg = MACIO_IN32(KEYLARGO_FCR3);
+			reg |=	KL3_IT_PORT_WAKEUP_ENABLE(0) | KL3_IT_PORT_RESUME_WAKE_EN(0) |
+				KL3_IT_PORT_CONNECT_WAKE_EN(0) | KL3_IT_PORT_DISCONNECT_WAKE_EN(0);
+			reg |=	KL3_IT_PORT_WAKEUP_ENABLE(1) | KL3_IT_PORT_RESUME_WAKE_EN(1) |
+				KL3_IT_PORT_CONNECT_WAKE_EN(1) | KL3_IT_PORT_DISCONNECT_WAKE_EN(1);
+			MACIO_OUT32(KEYLARGO_FCR3, reg);
+			(void)MACIO_IN32(KEYLARGO_FCR3);
+			udelay(1);
+		}
 		if (number == 0) {
 			MACIO_BIC(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 			udelay(1);
 			MACIO_BIS(KEYLARGO_FCR0, (KL0_USB0_PAD_SUSPEND0 | KL0_USB0_PAD_SUSPEND1));
 			(void)MACIO_IN32(KEYLARGO_FCR0);
-		} else {
+		} else if (number == 2) {
 			MACIO_BIC(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);
 			(void)MACIO_IN32(KEYLARGO_FCR0);
 			udelay(1);
 			MACIO_BIS(KEYLARGO_FCR0, (KL0_USB1_PAD_SUSPEND0 | KL0_USB1_PAD_SUSPEND1));
 			(void)MACIO_IN32(KEYLARGO_FCR0);
+		} else if (number == 4) {
+			MACIO_BIC(KEYLARGO_FCR1, KL1_USB2_CELL_ENABLE);
+			(void)MACIO_IN32(KEYLARGO_FCR1);
+			udelay(1);
+			MACIO_BIS(KEYLARGO_FCR1, (KL1_USB2_PAD_SUSPEND0 | KL1_USB2_PAD_SUSPEND1));
+			(void)MACIO_IN32(KEYLARGO_FCR1);
 		}
 		udelay(1);
 	}
@@ -1193,8 +1225,8 @@ core99_usb_enable(struct device_node* no
 	return 0;
 }
 
-static int __pmac
-core99_firewire_enable(struct device_node* node, int param, int value)
+static long __pmac
+core99_firewire_enable(struct device_node* node, long param, long value)
 {
 	unsigned long flags;
 	struct macio_chip* macio;
@@ -1220,8 +1252,8 @@ core99_firewire_enable(struct device_nod
 	return 0;
 }
 
-static int __pmac
-core99_firewire_cable_power(struct device_node* node, int param, int value)
+static long __pmac
+core99_firewire_cable_power(struct device_node* node, long param, long value)
 {
 	unsigned long flags;
 	struct macio_chip* macio;
@@ -1251,8 +1283,10 @@ core99_firewire_cable_power(struct devic
 	return 0;
 }
 
-static int __pmac
-core99_read_gpio(struct device_node* node, int param, int value)
+#endif /* CONFIG_POWER4 */
+
+static long __pmac
+core99_read_gpio(struct device_node* node, long param, long value)
 {
 	struct macio_chip* macio = &macio_chips[0];
 
@@ -1260,8 +1294,8 @@ core99_read_gpio(struct device_node* nod
 }
 
 
-static int __pmac
-core99_write_gpio(struct device_node* node, int param, int value)
+static long __pmac
+core99_write_gpio(struct device_node* node, long param, long value)
 {
 	struct macio_chip* macio = &macio_chips[0];
 
@@ -1269,6 +1303,145 @@ core99_write_gpio(struct device_node* no
 	return 0;
 }
 
+#ifdef CONFIG_POWER4
+
+static long __pmac
+g5_gmac_enable(struct device_node* node, long param, long value)
+{
+	struct macio_chip* macio = &macio_chips[0];
+	unsigned long flags;
+	struct pci_dev *pdev;
+	u8 pbus, pid;
+
+	/* XXX FIXME: We should fix pci_device_from_OF_node here, and
+	 * get to a real pci_dev or we'll get into trouble with PCI
+	 * domains the day we get overlapping numbers (like if we ever
+	 * decide to show the HT root
+	 */
+	if (pci_device_from_OF_node(node, &pbus, &pid) == 0)
+		pdev = pci_find_slot(pbus, pid);
+
+	LOCK(flags);
+	if (value) {
+		MACIO_BIS(KEYLARGO_FCR1, K2_FCR1_GMAC_CLK_ENABLE);
+		mb();
+		k2_skiplist[0] = NULL;
+	} else {
+		k2_skiplist[0] = pdev;
+		mb();
+		MACIO_BIC(KEYLARGO_FCR1, K2_FCR1_GMAC_CLK_ENABLE);
+	}
+	
+	UNLOCK(flags);
+	mdelay(1);
+
+	return 0;
+}
+
+static long __pmac
+g5_fw_enable(struct device_node* node, long param, long value)
+{
+	struct macio_chip* macio = &macio_chips[0];
+	unsigned long flags;
+	struct pci_dev *pdev;
+	u8 pbus, pid;
+
+	/* XXX FIXME: We should fix pci_device_from_OF_node here, and
+	 * get to a real pci_dev or we'll get into trouble with PCI
+	 * domains the day we get overlapping numbers (like if we ever
+	 * decide to show the HT root
+	 */
+	if (pci_device_from_OF_node(node, &pbus, &pid) == 0)
+		pdev = pci_find_slot(pbus, pid);
+
+	LOCK(flags);
+	if (value) {
+		MACIO_BIS(KEYLARGO_FCR1, K2_FCR1_FW_CLK_ENABLE);
+		mb();
+		k2_skiplist[1] = NULL;
+	} else {
+		k2_skiplist[0] = pdev;
+		mb();
+		MACIO_BIC(KEYLARGO_FCR1, K2_FCR1_FW_CLK_ENABLE);
+	}
+	
+	UNLOCK(flags);
+	mdelay(1);
+
+	return 0;
+}
+
+static long __pmac
+g5_mpic_enable(struct device_node* node, long param, long value)
+{
+	unsigned long flags;
+
+	if (node->parent == NULL || strcmp(node->parent->name, "u3"))
+		return 0;
+
+	LOCK(flags);
+	UN_BIS(U3_TOGGLE_REG, U3_MPIC_RESET | U3_MPIC_OUTPUT_ENABLE);
+	UNLOCK(flags);
+
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+static long __pmac
+g5_reset_cpu(struct device_node* node, long param, long value)
+{
+	unsigned int reset_io = 0;
+	unsigned long flags;
+	struct macio_chip* macio;
+	struct device_node* np;
+
+	macio = &macio_chips[0];
+	if (macio->type != macio_keylargo2)
+		return -ENODEV;
+
+	np = find_path_device("/cpus");
+	if (np == NULL)
+		return -ENODEV;
+	for (np = np->child; np != NULL; np = np->sibling) {
+		u32* num = (u32 *)get_property(np, "reg", NULL);
+		u32* rst = (u32 *)get_property(np, "soft-reset", NULL);
+		if (num == NULL || rst == NULL)
+			continue;
+		if (param == *num) {
+			reset_io = *rst;
+			break;
+		}
+	}
+	if (np == NULL || reset_io == 0)
+		return -ENODEV;
+
+	LOCK(flags);
+	MACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTPUT_ENABLE);
+	(void)MACIO_IN8(reset_io);
+	udelay(1);
+	MACIO_OUT8(reset_io, 0);
+	(void)MACIO_IN8(reset_io);
+	UNLOCK(flags);
+
+	return 0;
+}
+#endif /* CONFIG_SMP */
+
+/*
+ * This can be called from pmac_smp so isn't static
+ *
+ * This takes the second CPU off the bus on dual CPU machines
+ * running UP
+ */
+void __pmac g5_phy_disable_cpu1(void)
+{
+	UN_OUT(U3_API_PHY_CONFIG_1, 0);
+}
+
+#endif /* CONFIG_POWER4 */
+
+#ifndef CONFIG_POWER4
+
 static void __pmac
 keylargo_shutdown(struct macio_chip* macio, int sleep_mode)
 {
@@ -1541,8 +1714,8 @@ core99_wake_up(void)
 	return 0;
 }
 
-static int __pmac
-core99_sleep_state(struct device_node* node, int param, int value)
+static long __pmac
+core99_sleep_state(struct device_node* node, long param, long value)
 {
 	/* Param == 1 means to enter the "fake sleep" mode that is
 	 * used for CPU speed switch
@@ -1568,8 +1741,10 @@ core99_sleep_state(struct device_node* n
 	return 0;
 }
 
-static int __pmac
-generic_get_mb_info(struct device_node* node, int param, int value)
+#endif /* CONFIG_POWER4 */
+
+static long __pmac
+generic_get_mb_info(struct device_node* node, long param, long value)
 {
 	switch(param) {
 		case PMAC_MB_INFO_MODEL:
@@ -1579,9 +1754,9 @@ generic_get_mb_info(struct device_node* 
 		case PMAC_MB_INFO_NAME:
 			/* hack hack hack... but should work */
 			*((const char **)value) = pmac_mb.model_name;
-			break;
+			return 0;
 	}
-	return 0;
+	return -EINVAL;
 }
 
 
@@ -1596,6 +1771,8 @@ static struct feature_table_entry any_fe
 	{ 0, NULL }
 };
 
+#ifndef CONFIG_POWER4
+
 /* OHare based motherboards. Currently, we only use these on the
  * 2400,3400 and 3500 series powerbooks. Some older desktops seem
  * to have issues with turning on/off those asic cells
@@ -1741,10 +1918,29 @@ static struct feature_table_entry intrep
 	{ 0, NULL }
 };
 
+#else /* CONFIG_POWER4 */
+
+/* G5 features
+ */
+static struct feature_table_entry g5_features[]  __pmacdata = {
+	{ PMAC_FTR_GMAC_ENABLE,		g5_gmac_enable },
+	{ PMAC_FTR_1394_ENABLE,		g5_fw_enable },
+	{ PMAC_FTR_ENABLE_MPIC,		g5_mpic_enable },
+#ifdef CONFIG_SMP
+	{ PMAC_FTR_RESET_CPU,		g5_reset_cpu },
+#endif /* CONFIG_SMP */
+	{ PMAC_FTR_READ_GPIO,		core99_read_gpio },
+	{ PMAC_FTR_WRITE_GPIO,		core99_write_gpio },
+	{ 0, NULL }
+};
+
+#endif /* CONFIG_POWER4 */
+
 static struct pmac_mb_def pmac_mb_defs[] __pmacdata = {
 	/* Warning: ordering is important as some models may claim
 	 * beeing compatible with several types
 	 */
+#ifndef CONFIG_POWER4
 	{	"AAPL,8500",			"PowerMac 8500/8600",
 		PMAC_TYPE_PSURGE,		NULL,
 		0
@@ -1753,6 +1949,14 @@ static struct pmac_mb_def pmac_mb_defs[]
 		PMAC_TYPE_PSURGE,		NULL,
 		0
 	},
+	{	"AAPL,7200",			"PowerMac 7200",
+		PMAC_TYPE_PSURGE,		NULL,
+		0
+	},
+	{	"AAPL,7300",			"PowerMac 7200/7300",
+		PMAC_TYPE_PSURGE,		NULL,
+		0
+	},
 	{	"AAPL,7500",			"PowerMac 7500",
 		PMAC_TYPE_PSURGE,		NULL,
 		0
@@ -1905,20 +2109,43 @@ static struct pmac_mb_def pmac_mb_defs[]
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
 		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
+	{	"PowerBook5,2",			"PowerBook G4 15\"",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
+	{	"PowerBook5,3",			"PowerBook G4 17\"",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
 	{	"PowerBook6,1",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
 		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
+	{	"PowerBook6,2",			"PowerBook G4",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
+	{	"PowerBook6,3",			"iBook G4",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
+#else /* CONFIG_POWER4 */
+	{	"PowerMac7,2",			"PowerMac G5",
+		PMAC_TYPE_POWERMAC_G5,		g5_features,
+		0,
+	},
+#endif /* CONFIG_POWER4 */
 };
 
 /*
  * The toplevel feature_call callback
  */
-int __pmac
+long __pmac
 pmac_do_feature_call(unsigned int selector, ...)
 {
 	struct device_node* node;
-	int param, value, i;
+	long param, value;
+	int i;
 	feature_call func = NULL;
 	va_list args;
 
@@ -1939,8 +2166,8 @@ pmac_do_feature_call(unsigned int select
 
 	va_start(args, selector);
 	node = (struct device_node*)va_arg(args, void*);
-	param = va_arg(args, int);
-	value = va_arg(args, int);
+	param = va_arg(args, long);
+	value = va_arg(args, long);
 	va_end(args);
 
 	return func(node, param, value);
@@ -1976,6 +2203,7 @@ probe_motherboard(void)
 
 	/* Fallback to selection depending on mac-io chip type */
 	switch(macio->type) {
+#ifndef CONFIG_POWER4
 	    case macio_grand_central:
 		pmac_mb.model_id = PMAC_TYPE_PSURGE;
 		pmac_mb.model_name = "Unknown PowerSurge";
@@ -2009,10 +2237,18 @@ probe_motherboard(void)
 		pmac_mb.model_name = "Unknown Intrepid-based";
 	    	pmac_mb.features = intrepid_features;
 	    	break;
+#else /* CONFIG_POWER4 */
+	    case macio_keylargo2:
+		pmac_mb.model_id = PMAC_TYPE_POWERMAC_G5;
+		pmac_mb.model_name = "Unknown G5";
+	    	pmac_mb.features = g5_features;
+	    	break;
+#endif /* CONFIG_POWER4 */
 	    default:
 	    	return -ENODEV;
 	}
 found:
+#ifndef CONFIG_POWER4
 	/* Fixup Hooper vs. Comet */
 	if (pmac_mb.model_id == PMAC_TYPE_HOOPER) {
 		u32* mach_id_ptr = (u32*)ioremap(0xf3000034, 4);
@@ -2026,6 +2262,7 @@ found:
 			pmac_mb.model_id = PMAC_TYPE_COMET;
 		iounmap(mach_id_ptr);
 	}
+#endif /* CONFIG_POWER4 */
 
 #ifdef CONFIG_6xx
 	/* Set default value of powersave_nap on machines that support it.
@@ -2057,7 +2294,9 @@ found:
 	 */
 	powersave_lowspeed = 1;
 #endif /* CONFIG_6xx */
-
+#ifdef CONFIG_POWER4
+	powersave_nap = 1;
+#endif
 	/* Check for "mobile" machine */
 	if (model && (strncmp(model, "PowerBook", 9) == 0
 		   || strncmp(model, "iBook", 5) == 0))
@@ -2076,18 +2315,26 @@ probe_uninorth(void)
 	unsigned long actrl;
 
 	/* Locate core99 Uni-N */
-	uninorth_node = find_devices("uni-n");
+	uninorth_node = of_find_node_by_name(NULL, "uni-n");
+	/* Locate G5 u3 */
+	if (uninorth_node == NULL) {
+		uninorth_node = of_find_node_by_name(NULL, "u3");
+		uninorth_u3 = 1;
+	}
 	if (uninorth_node && uninorth_node->n_addrs > 0) {
-		uninorth_base = ioremap(uninorth_node->addrs[0].address, 0x4000);
+		unsigned long address = uninorth_node->addrs[0].address;
+		uninorth_base = ioremap(address, 0x40000);
 		uninorth_rev = in_be32(UN_REG(UNI_N_VERSION));
+		if (uninorth_u3)
+			u3_ht = ioremap(address + U3_HT_CONFIG_BASE, 0x1000);
 	} else
 		uninorth_node = NULL;
 
 	if (!uninorth_node)
 		return;
 
-	printk(KERN_INFO "Found Uninorth memory controller & host bridge, revision: %d\n",
-			uninorth_rev);
+	printk(KERN_INFO "Found %s memory controller & host bridge, revision: %d\n",
+	       uninorth_u3 ? "U3" : "UniNorth", uninorth_rev);
 	printk(KERN_INFO "Mapped at 0x%08lx\n", (unsigned long)uninorth_base);
 
 	/* Set the arbitrer QAck delay according to what Apple does
@@ -2172,6 +2419,7 @@ probe_macios(void)
 	probe_one_macio("mac-io", "paddington", macio_paddington);
 	probe_one_macio("mac-io", "gatwick", macio_gatwick);
 	probe_one_macio("mac-io", "heathrow", macio_heathrow);
+	probe_one_macio("mac-io", "K2-Keylargo", macio_keylargo2);
 
 	/* Make sure the "main" macio chip appear first */
 	if (macio_chips[0].type == macio_gatwick
@@ -2244,19 +2492,60 @@ set_initial_features(void)
 		MACIO_BIS(OHARE_FCR, OH_IOBUS_ENABLE);
 	}
 
+#ifdef CONFIG_POWER4
+	if (macio_chips[0].type == macio_keylargo2) {
+#ifndef CONFIG_SMP
+		/* On SMP machines running UP, we have the second CPU eating
+		 * bus cycles. We need to take it off the bus. This is done
+		 * from pmac_smp for SMP kernels running on one CPU
+		 */
+		np = of_find_node_by_type(NULL, "cpu");
+		if (np != NULL)
+			np = of_find_node_by_type(np, "cpu");
+		if (np != NULL) {
+			g5_phy_disable_cpu1();
+			of_node_put(np);
+		}
+#endif /* CONFIG_SMP */
+		/* Enable GMAC for now for PCI probing. It will be disabled
+		 * later on after PCI probe
+		 */
+		np = of_find_node_by_name(NULL, "ethernet");
+		while(np) {
+			if (device_is_compatible(np, "K2-GMAC"))
+				g5_gmac_enable(np, 0, 1);
+			np = of_find_node_by_name(np, "ethernet");
+		}
+
+		/* Enable FW before PCI probe. Will be disabled later on
+		 * Note: We should have a batter way to check that we are
+		 * dealing with uninorth internal cell and not a PCI cell
+		 * on the external PCI. The code below works though.
+		 */
+		np = of_find_node_by_name(NULL, "firewire");
+		while(np) {
+			if (device_is_compatible(np, "pci106b,5811")) {
+				macio_chips[0].flags |= MACIO_FLAG_FW_SUPPORTED;
+				g5_fw_enable(np, 0, 1);
+			}
+			np = of_find_node_by_name(np, "firewire");
+		}
+	}
+#else /* CONFIG_POWER4 */
+
 	if (macio_chips[0].type == macio_keylargo ||
 	    macio_chips[0].type == macio_pangea ||
 	    macio_chips[0].type == macio_intrepid) {
 		/* Enable GMAC for now for PCI probing. It will be disabled
 		 * later on after PCI probe
 		 */
-		np = find_devices("ethernet");
+		np = of_find_node_by_name(NULL, "ethernet");
 		while(np) {
 			if (np->parent
 			    && device_is_compatible(np->parent, "uni-north")
 			    && device_is_compatible(np, "gmac"))
 				core99_gmac_enable(np, 0, 1);
-			np = np->next;
+			np = of_find_node_by_name(np, "ethernet");
 		}
 
 		/* Enable FW before PCI probe. Will be disabled later on
@@ -2264,7 +2553,7 @@ set_initial_features(void)
 		 * dealing with uninorth internal cell and not a PCI cell
 		 * on the external PCI. The code below works though.
 		 */
-		np = find_devices("firewire");
+		np = of_find_node_by_name(NULL, "firewire");
 		while(np) {
 			if (np->parent
 			    && device_is_compatible(np->parent, "uni-north")
@@ -2274,18 +2563,18 @@ set_initial_features(void)
 				macio_chips[0].flags |= MACIO_FLAG_FW_SUPPORTED;
 				core99_firewire_enable(np, 0, 1);
 			}
-			np = np->next;
+			np = of_find_node_by_name(np, "firewire");
 		}
 
 		/* Enable ATA-100 before PCI probe. */
-		np = find_devices("ata-6");
+		np = of_find_node_by_name(NULL, "ata-6");
 		while(np) {
 			if (np->parent
 			    && device_is_compatible(np->parent, "uni-north")
 			    && device_is_compatible(np, "kauai-ata")) {
 				core99_ata100_enable(np, 1);
 			}
-			np = np->next;
+			np = of_find_node_by_name(np, "ata-6");
 		}
 
 		/* Switch airport off */
@@ -2313,6 +2602,99 @@ set_initial_features(void)
 		MACIO_BIC(HEATHROW_FCR, HRW_SOUND_POWER_N);
 	}
 
+	/* Hack for bumping clock speed on the new PowerBooks and the
+	 * iBook G4. This implements the "platform-do-clockspreading" OF
+	 * property. For safety, we also check the product ID in the
+	 * device-tree to make reasonably sure we won't set wrong values
+	 * in the clock chip.
+	 *
+	 * Of course, ultimately, we have to implement a real parser for
+	 * the platform-do-* stuff...
+	 */
+	while (machine_is_compatible("PowerBook5,2") ||
+	       machine_is_compatible("PowerBook5,3") ||
+	       machine_is_compatible("PowerBook6,2") ||
+	       machine_is_compatible("PowerBook6,3")) {
+		struct device_node *ui2c = of_find_node_by_type(NULL, "i2c");
+		struct device_node *dt = of_find_node_by_name(NULL, "device-tree");
+		u8 buffer[9];
+		u32 *productID;
+		int i, rc, changed = 0;
+		
+		if (dt == NULL)
+			break;
+		productID = (u32 *)get_property(dt, "pid#", NULL);
+		if (productID == NULL)
+			break;
+		while(ui2c) {
+			struct device_node *p = of_get_parent(ui2c);
+			if (p && !strcmp(p->name, "uni-n"))
+				break;
+			ui2c = of_find_node_by_type(np, "i2c");
+		}
+		if (ui2c == NULL)
+			break;
+		DBG("Trying to bump clock speed for PID: %08x...\n", *productID);
+		rc = pmac_low_i2c_open(ui2c, 1);
+		if (rc != 0)
+			break;
+		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_combined);
+		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_read, 0x80, buffer, 9);
+		DBG("read result: %d,", rc);
+		if (rc != 0) {
+			pmac_low_i2c_close(ui2c);
+			break;
+		}
+		for (i=0; i<9; i++)
+			DBG(" %02x", buffer[i]);
+		DBG("\n");
+		
+		switch(*productID) {
+		case 0x1182:	/* AlBook 12" rev 2 */
+		case 0x1183:	/* iBook G4 12" */
+			buffer[0] = (buffer[0] & 0x8f) | 0x70;
+			buffer[2] = (buffer[2] & 0x7f) | 0x00;
+			buffer[5] = (buffer[5] & 0x80) | 0x31;
+			buffer[6] = (buffer[6] & 0x40) | 0xb0;
+			buffer[7] = (buffer[7] & 0x00) | 0xc0;
+			buffer[8] = (buffer[8] & 0x00) | 0x30;
+			changed = 1;
+			break;
+		case 0x3142:	/* AlBook 15" (ATI M10) */
+		case 0x3143:	/* AlBook 17" (ATI M10) */
+			buffer[0] = (buffer[0] & 0xaf) | 0x50;
+			buffer[2] = (buffer[2] & 0x7f) | 0x00;
+			buffer[5] = (buffer[5] & 0x80) | 0x31;
+			buffer[6] = (buffer[6] & 0x40) | 0xb0;
+			buffer[7] = (buffer[7] & 0x00) | 0xd0;
+			buffer[8] = (buffer[8] & 0x00) | 0x30;
+			changed = 1;
+			break;
+		default:
+			DBG("i2c-hwclock: Machine model not handled\n");
+			break;
+		}
+		if (!changed) {
+			pmac_low_i2c_close(ui2c);
+			break;
+		}
+		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_stdsub);
+		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_write, 0x80, buffer, 9);
+		DBG("write result: %d,", rc);
+		pmac_low_i2c_setmode(ui2c, pmac_low_i2c_mode_combined);
+		rc = pmac_low_i2c_xfer(ui2c, 0xd2 | pmac_low_i2c_read, 0x80, buffer, 9);
+		DBG("read result: %d,", rc);
+		if (rc != 0) {
+			pmac_low_i2c_close(ui2c);
+			break;
+		}
+		for (i=0; i<9; i++)
+			DBG(" %02x", buffer[i]);
+		pmac_low_i2c_close(ui2c);
+		break;
+	}
+
+#endif /* CONFIG_POWER4 */
 
 	/* On all machines, switch modem & serial ports off */
 	np = find_devices("ch-a");
@@ -2339,6 +2721,9 @@ pmac_feature_init(void)
 		return;
 	}
 
+	/* Setup low-level i2c stuffs */
+	pmac_init_low_i2c();
+
 	/* Probe machine type */
 	if (probe_motherboard())
 		printk(KERN_WARNING "Unknown PowerMac !\n");
@@ -2367,3 +2752,55 @@ pmac_feature_late_init(void)
 }
 
 device_initcall(pmac_feature_late_init);
+
+#ifdef CONFIG_POWER4
+
+static void dump_HT_speeds(char *name, u32 cfg, u32 frq)
+{
+	int	freqs[16] = { 200,300,400,500,600,800,1000,0,0,0,0,0,0,0,0,0 };
+	int	bits[8] = { 8,16,0,32,2,4,0,0 };
+	int	freq = (frq >> 8) & 0xf;
+
+	if (freqs[freq] == 0)
+		printk("%s: Unknown HT link frequency %x\n", name, freq);
+	else
+		printk("%s: %d MHz on main link, (%d in / %d out) bits width\n",
+		       name, freqs[freq],
+		       bits[(cfg >> 28) & 0x7], bits[(cfg >> 24) & 0x7]);
+}
+
+void __init pmac_check_ht_link(void)
+{
+	u32	ufreq, freq, ucfg, cfg;
+	struct device_node *pcix_node;
+	u8  	px_bus, px_devfn;
+	struct pci_controller *px_hose;
+
+	(void)in_be32(u3_ht + U3_HT_LINK_COMMAND);
+	ucfg = cfg = in_be32(u3_ht + U3_HT_LINK_CONFIG);
+	ufreq = freq = in_be32(u3_ht + U3_HT_LINK_FREQ);
+	dump_HT_speeds("U3 HyperTransport", cfg, freq);
+
+	pcix_node = of_find_compatible_node(NULL, "pci", "pci-x");
+	if (pcix_node == NULL) {
+		printk("No PCI-X bridge found\n");
+		return;
+	}
+	if (pci_device_from_OF_node(pcix_node, &px_bus, &px_devfn) != 0) {
+		printk("PCI-X bridge found but not matched to pci\n");
+		return;
+	}
+	px_hose = pci_find_hose_for_OF_device(pcix_node);
+	if (px_hose == NULL) {
+		printk("PCI-X bridge found but not matched to host\n");
+		return;
+	}	
+	early_read_config_dword(px_hose, px_bus, px_devfn, 0xc4, &cfg);
+	early_read_config_dword(px_hose, px_bus, px_devfn, 0xcc, &freq);
+	dump_HT_speeds("PCI-X HT Uplink", cfg, freq);
+	early_read_config_dword(px_hose, px_bus, px_devfn, 0xc8, &cfg);
+	early_read_config_dword(px_hose, px_bus, px_devfn, 0xd0, &freq);
+	dump_HT_speeds("PCI-X HT Downlink", cfg, freq);
+}
+
+#endif /* CONFIG_POWER4 */
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_low_i2c.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_low_i2c.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_low_i2c.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_low_i2c.c	2003-12-31 03:57:54.000000000 +0000
@@ -0,0 +1,513 @@
+/*
+ *  arch/ppc/platforms/pmac_low_i2c.c
+ *
+ *  Copyright (C) 2003 Ben. Herrenschmidt (benh@kernel.crashing.org)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ *  This file contains some low-level i2c access routines that
+ *  need to be used by various bits of the PowerMac platform code
+ *  at times where the real asynchronous & interrupt driven driver
+ *  cannot be used. The API borrows some semantics from the darwin
+ *  driver in order to ease the implementation of the platform
+ *  properties parser
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <asm/keylargo.h>
+#include <asm/uninorth.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/pmac_low_i2c.h>
+
+#define MAX_LOW_I2C_HOST	4
+
+#if 1
+#define DBG(x...) do {\
+		printk(KERN_DEBUG "KW:" x);	\
+	} while(0)
+#else
+#define DBGG(x...)
+#endif
+
+struct low_i2c_host;
+
+typedef int (*low_i2c_func_t)(struct low_i2c_host *host, u8 addr, u8 sub, u8 *data, int len);
+
+struct low_i2c_host
+{
+	struct device_node	*np;		/* OF device node */
+	struct semaphore	mutex;		/* Access mutex for use by i2c-keywest */
+	low_i2c_func_t		func;		/* Access function */
+	int			is_open : 1;	/* Poor man's access control */
+	int			mode;		/* Current mode */
+	int			channel;	/* Current channel */
+	int			num_channels;	/* Number of channels */
+	unsigned long		base;		/* For keywest-i2c, base address */
+	int			bsteps;		/* And register stepping */
+	int			speed;		/* And speed */
+};
+
+static struct low_i2c_host	low_i2c_hosts[MAX_LOW_I2C_HOST];
+
+/* No locking is necessary on allocation, we are running way before
+ * anything can race with us
+ */
+static struct low_i2c_host *find_low_i2c_host(struct device_node *np)
+{
+	int i;
+
+	for (i = 0; i < MAX_LOW_I2C_HOST; i++)
+		if (low_i2c_hosts[i].np == np)
+			return &low_i2c_hosts[i];
+	return NULL;
+}
+
+/*
+ *
+ * i2c-keywest implementation (UniNorth, U2, U3, Keylargo's)
+ *
+ */
+
+/*
+ * Keywest i2c definitions borrowed from drivers/i2c/i2c-keywest.h,
+ * should be moved somewhere in include/asm-ppc/
+ */
+/* Register indices */
+typedef enum {
+	reg_mode = 0,
+	reg_control,
+	reg_status,
+	reg_isr,
+	reg_ier,
+	reg_addr,
+	reg_subaddr,
+	reg_data
+} reg_t;
+
+
+/* Mode register */
+#define KW_I2C_MODE_100KHZ	0x00
+#define KW_I2C_MODE_50KHZ	0x01
+#define KW_I2C_MODE_25KHZ	0x02
+#define KW_I2C_MODE_DUMB	0x00
+#define KW_I2C_MODE_STANDARD	0x04
+#define KW_I2C_MODE_STANDARDSUB	0x08
+#define KW_I2C_MODE_COMBINED	0x0C
+#define KW_I2C_MODE_MODE_MASK	0x0C
+#define KW_I2C_MODE_CHAN_MASK	0xF0
+
+/* Control register */
+#define KW_I2C_CTL_AAK		0x01
+#define KW_I2C_CTL_XADDR	0x02
+#define KW_I2C_CTL_STOP		0x04
+#define KW_I2C_CTL_START	0x08
+
+/* Status register */
+#define KW_I2C_STAT_BUSY	0x01
+#define KW_I2C_STAT_LAST_AAK	0x02
+#define KW_I2C_STAT_LAST_RW	0x04
+#define KW_I2C_STAT_SDA		0x08
+#define KW_I2C_STAT_SCL		0x10
+
+/* IER & ISR registers */
+#define KW_I2C_IRQ_DATA		0x01
+#define KW_I2C_IRQ_ADDR		0x02
+#define KW_I2C_IRQ_STOP		0x04
+#define KW_I2C_IRQ_START	0x08
+#define KW_I2C_IRQ_MASK		0x0F
+
+/* State machine states */
+enum {
+	state_idle,
+	state_addr,
+	state_read,
+	state_write,
+	state_stop,
+	state_dead
+};
+
+#define WRONG_STATE(name) do {\
+		printk(KERN_DEBUG "KW: wrong state. Got %s, state: %s (isr: %02x)\n", \
+		       name, __kw_state_names[state], isr); \
+	} while(0)
+
+static const char *__kw_state_names[] = {
+	"state_idle",
+	"state_addr",
+	"state_read",
+	"state_write",
+	"state_stop",
+	"state_dead"
+};
+
+static inline u8 __kw_read_reg(struct low_i2c_host *host, reg_t reg)
+{
+	return in_8(((volatile u8 *)host->base)
+		+ (((unsigned)reg) << host->bsteps));
+}
+
+static inline void __kw_write_reg(struct low_i2c_host *host, reg_t reg, u8 val)
+{
+	out_8(((volatile u8 *)host->base)
+		+ (((unsigned)reg) << host->bsteps), val);
+	(void)__kw_read_reg(host, reg_subaddr);
+}
+
+#define kw_write_reg(reg, val)	__kw_write_reg(host, reg, val) 
+#define kw_read_reg(reg)	__kw_read_reg(host, reg) 
+
+
+/* Don't schedule, the g5 fan controller is too
+ * timing sensitive
+ */
+static u8 kw_wait_interrupt(struct low_i2c_host* host)
+{
+	int i;
+	u8 isr;
+	
+	for (i = 0; i < 200000; i++) {
+		isr = kw_read_reg(reg_isr) & KW_I2C_IRQ_MASK;
+		if (isr != 0)
+			return isr;
+		udelay(1);
+	}
+	return isr;
+}
+
+static int kw_handle_interrupt(struct low_i2c_host *host, int state, int rw, int *rc, u8 **data, int *len, u8 isr)
+{
+	u8 ack;
+
+	if (isr == 0) {
+		if (state != state_stop) {
+			DBG("KW: Timeout !\n");
+			*rc = -EIO;
+			goto stop;
+		}
+		if (state == state_stop) {
+			ack = kw_read_reg(reg_status);
+			if (!(ack & KW_I2C_STAT_BUSY)) {
+				state = state_idle;
+				kw_write_reg(reg_ier, 0x00);
+			}
+		}
+		return state;
+	}
+
+	if (isr & KW_I2C_IRQ_ADDR) {
+		ack = kw_read_reg(reg_status);
+		if (state != state_addr) {
+			kw_write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+			WRONG_STATE("KW_I2C_IRQ_ADDR"); 
+			*rc = -EIO;
+			goto stop;
+		}
+		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {			
+			*rc = -ENODEV;
+			DBG("KW: NAK on address\n");
+			return state_stop;		     
+		} else {
+			if (rw) {
+				state = state_read;
+				if (*len > 1)
+					kw_write_reg(reg_control, KW_I2C_CTL_AAK);
+			} else {
+				state = state_write;
+				kw_write_reg(reg_data, **data);
+				(*data)++; (*len)--;
+			}
+		}
+		kw_write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+	}
+
+	if (isr & KW_I2C_IRQ_DATA) {
+		if (state == state_read) {
+			**data = kw_read_reg(reg_data);
+			(*data)++; (*len)--;
+			kw_write_reg(reg_isr, KW_I2C_IRQ_DATA);
+			if ((*len) == 0)
+				state = state_stop;
+			else if ((*len) == 1)
+				kw_write_reg(reg_control, 0);
+		} else if (state == state_write) {
+			ack = kw_read_reg(reg_status);
+			if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
+				DBG("KW: nack on data write\n");
+				*rc = -EIO;
+				goto stop;
+			} else if (*len) {
+				kw_write_reg(reg_data, **data);
+				(*data)++; (*len)--;
+			} else {
+				kw_write_reg(reg_control, KW_I2C_CTL_STOP);
+				state = state_stop;
+				*rc = 0;
+			}
+			kw_write_reg(reg_isr, KW_I2C_IRQ_DATA);
+		} else {
+			kw_write_reg(reg_isr, KW_I2C_IRQ_DATA);
+			WRONG_STATE("KW_I2C_IRQ_DATA"); 
+			if (state != state_stop) {
+				*rc = -EIO;
+				goto stop;
+			}
+		}
+	}
+
+	if (isr & KW_I2C_IRQ_STOP) {
+		kw_write_reg(reg_isr, KW_I2C_IRQ_STOP);
+		if (state != state_stop) {
+			WRONG_STATE("KW_I2C_IRQ_STOP");
+			*rc = -EIO;
+		}
+		return state_idle;
+	}
+
+	if (isr & KW_I2C_IRQ_START)
+		kw_write_reg(reg_isr, KW_I2C_IRQ_START);
+
+	return state;
+
+ stop:
+	kw_write_reg(reg_control, KW_I2C_CTL_STOP);	
+	return state_stop;
+}
+
+static int keywest_low_i2c_func(struct low_i2c_host *host, u8 addr, u8 subaddr, u8 *data, int len)
+{
+	u8 mode_reg = host->speed;
+	int state = state_addr;
+	int rc = 0;
+
+	/* Setup mode & subaddress if any */
+	switch(host->mode) {
+	case pmac_low_i2c_mode_dumb:
+		printk(KERN_ERR "low_i2c: Dumb mode not supported !\n");
+		return -EINVAL;
+	case pmac_low_i2c_mode_std:
+		mode_reg |= KW_I2C_MODE_STANDARD;
+		break;
+	case pmac_low_i2c_mode_stdsub:
+		mode_reg |= KW_I2C_MODE_STANDARDSUB;
+		kw_write_reg(reg_subaddr, subaddr);
+		break;
+	case pmac_low_i2c_mode_combined:
+		mode_reg |= KW_I2C_MODE_COMBINED;
+		kw_write_reg(reg_subaddr, subaddr);
+		break;
+	}
+
+	/* Setup channel & clear pending irqs */
+	kw_write_reg(reg_isr, kw_read_reg(reg_isr));
+	kw_write_reg(reg_mode, mode_reg | (host->channel << 4));
+	kw_write_reg(reg_status, 0);
+
+	/* Set up address and r/w bit */
+	kw_write_reg(reg_addr, addr);
+
+	/* Start sending address & disable interrupt*/
+	kw_write_reg(reg_ier, 0 /*KW_I2C_IRQ_MASK*/);
+	kw_write_reg(reg_control, KW_I2C_CTL_XADDR);
+
+	/* State machine, to turn into an interrupt handler */
+	while(state != state_idle) {
+		u8 isr = kw_wait_interrupt(host);
+		state = kw_handle_interrupt(host, state, addr & 1, &rc, &data, &len, isr);
+	}
+
+	return rc;
+}
+
+static void keywest_low_i2c_add(struct device_node *np)
+{
+	struct low_i2c_host	*host = find_low_i2c_host(NULL);
+	unsigned long		*psteps, *prate, steps, aoffset = 0;
+	struct device_node	*parent;
+
+	if (host == NULL) {
+		printk(KERN_ERR "low_i2c: Can't allocate host for %s\n",
+		       np->full_name);
+		return;
+	}
+	memset(host, 0, sizeof(*host));
+
+	init_MUTEX(&host->mutex);
+	host->np = of_node_get(np);	
+	psteps = (unsigned long *)get_property(np, "AAPL,address-step", NULL);
+	steps = psteps ? (*psteps) : 0x10;
+	for (host->bsteps = 0; (steps & 0x01) == 0; host->bsteps++)
+		steps >>= 1;
+	parent = of_get_parent(np);
+	host->num_channels = 1;
+	if (parent && parent->name[0] == 'u') {
+		host->num_channels = 2;
+		aoffset = 3;
+	}
+	/* Select interface rate */
+	host->speed = KW_I2C_MODE_100KHZ;
+	prate = (unsigned long *)get_property(np, "AAPL,i2c-rate", NULL);
+	if (prate) switch(*prate) {
+	case 100:
+		host->speed = KW_I2C_MODE_100KHZ;
+		break;
+	case 50:
+		host->speed = KW_I2C_MODE_50KHZ;
+		break;
+	case 25:
+		host->speed = KW_I2C_MODE_25KHZ;
+		break;
+	}	
+	host->mode = pmac_low_i2c_mode_std;
+	host->base = (unsigned long)ioremap(np->addrs[0].address + aoffset,
+						np->addrs[0].size);
+	host->func = keywest_low_i2c_func;
+}
+
+/*
+ *
+ * PMU implementation
+ *
+ */
+
+
+#ifdef CONFIG_ADB_PMU
+
+static int pmu_low_i2c_func(struct low_i2c_host *host, u8 addr, u8 sub, u8 *data, int len)
+{
+	// TODO
+	return -ENODEV;
+}
+
+static void pmu_low_i2c_add(struct device_node *np)
+{
+	struct low_i2c_host	*host = find_low_i2c_host(NULL);
+
+	if (host == NULL) {
+		printk(KERN_ERR "low_i2c: Can't allocate host for %s\n",
+		       np->full_name);
+		return;
+	}
+	memset(host, 0, sizeof(*host));
+
+	init_MUTEX(&host->mutex);
+	host->np = of_node_get(np);	
+	host->num_channels = 3;
+	host->mode = pmac_low_i2c_mode_std;
+	host->func = pmu_low_i2c_func;
+}
+
+#endif /* CONFIG_ADB_PMU */
+
+void __init pmac_init_low_i2c(void)
+{
+	struct device_node *np;
+
+	/* Probe keywest-i2c busses */
+	np = of_find_compatible_node(NULL, "i2c", "keywest-i2c");
+	while(np) {
+		keywest_low_i2c_add(np);
+		np = of_find_compatible_node(np, "i2c", "keywest-i2c");
+	}
+
+#ifdef CONFIG_ADB_PMU
+	/* Probe PMU busses */
+	np = of_find_node_by_name(NULL, "via-pmu");
+	if (np)
+		pmu_low_i2c_add(np);
+#endif /* CONFIG_ADB_PMU */
+
+	/* TODO: Add CUDA support as well */
+}
+
+int pmac_low_i2c_lock(struct device_node *np)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+	down(&host->mutex);
+	return 0;
+}
+EXPORT_SYMBOL(pmac_low_i2c_lock);
+
+int pmac_low_i2c_unlock(struct device_node *np)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+	up(&host->mutex);
+	return 0;
+}
+EXPORT_SYMBOL(pmac_low_i2c_unlock);
+
+
+int pmac_low_i2c_open(struct device_node *np, int channel)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+
+	if (channel >= host->num_channels)
+		return -EINVAL;
+
+	down(&host->mutex);
+	host->is_open = 1;
+	host->channel = channel;
+
+	return 0;
+}
+EXPORT_SYMBOL(pmac_low_i2c_open);
+
+int pmac_low_i2c_close(struct device_node *np)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+
+	host->is_open = 0;
+	up(&host->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(pmac_low_i2c_close);
+
+int pmac_low_i2c_setmode(struct device_node *np, int mode)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+	WARN_ON(!host->is_open);
+	host->mode = mode;
+
+	return 0;
+}
+EXPORT_SYMBOL(pmac_low_i2c_setmode);
+
+int pmac_low_i2c_xfer(struct device_node *np, u8 addrdir, u8 subaddr, u8 *data, int len)
+{
+	struct low_i2c_host *host = find_low_i2c_host(np);
+
+	if (!host)
+		return -ENODEV;
+	WARN_ON(!host->is_open);
+
+	return host->func(host, addrdir, subaddr, data, len);
+}
+EXPORT_SYMBOL(pmac_low_i2c_xfer);
+
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_nvram.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_nvram.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_nvram.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_nvram.c	2003-12-24 07:30:11.000000000 +0000
@@ -8,8 +8,7 @@
  *  as published by the Free Software Foundation; either version
  *  2 of the License, or (at your option) any later version.
  *
- *  Todo: - cleanup some coding horrors in the flash code
- *        - add support for the OF persistent properties
+ *  Todo: - add support for the OF persistent properties
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -21,29 +20,40 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <linux/bootmem.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
 #include <asm/sections.h>
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/nvram.h>
-#include <linux/adb.h>
-#include <linux/pmu.h>
 
-#undef DEBUG
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
 
 #define NVRAM_SIZE		0x2000	/* 8kB of non-volatile RAM */
 
 #define CORE99_SIGNATURE	0x5a
 #define CORE99_ADLER_START	0x14
 
-/* Core99 nvram is a flash */
-#define CORE99_FLASH_STATUS_DONE	0x80
-#define CORE99_FLASH_STATUS_ERR		0x38
-#define CORE99_FLASH_CMD_ERASE_CONFIRM	0xd0
-#define CORE99_FLASH_CMD_ERASE_SETUP	0x20
-#define CORE99_FLASH_CMD_RESET		0xff
-#define CORE99_FLASH_CMD_WRITE_SETUP	0x40
+/* On Core99, nvram is either a sharp, a micron or an AMD flash */
+#define SM_FLASH_STATUS_DONE	0x80
+#define SM_FLASH_STATUS_ERR		0x38
+#define SM_FLASH_CMD_ERASE_CONFIRM	0xd0
+#define SM_FLASH_CMD_ERASE_SETUP	0x20
+#define SM_FLASH_CMD_RESET		0xff
+#define SM_FLASH_CMD_WRITE_SETUP	0x40
+#define SM_FLASH_CMD_CLEAR_STATUS	0x50
+#define SM_FLASH_CMD_READ_STATUS	0x70
 
 /* CHRP NVRAM header */
 struct chrp_header {
@@ -70,21 +80,110 @@ static volatile unsigned char *nvram_dat
 static int nvram_mult, is_core_99;
 static int core99_bank = 0;
 static int nvram_partitions[3];
-
-/* FIXME: kmalloc fails to allocate the image now that I had to move it
- *        before time_init(). For now, I allocate a static buffer here
- *        but it's a waste of space on all but core99 machines
- */
-#if 0
-static char* nvram_image;
-#else
-static char nvram_image[NVRAM_SIZE] __pmacdata;
-#endif
+static spinlock_t nv_lock = SPIN_LOCK_UNLOCKED;
 
 extern int pmac_newworld;
+extern int system_running;
+
+static int (*core99_write_bank)(int bank, u8* datas);
+static int (*core99_erase_bank)(int bank);
+
+static char *nvram_image __pmacdata;
+
+
+static unsigned char __pmac core99_nvram_read_byte(int addr)
+{
+	if (nvram_image == NULL)
+		return 0xff;
+	return nvram_image[addr];
+}
+
+static void __pmac core99_nvram_write_byte(int addr, unsigned char val)
+{
+	if (nvram_image == NULL)
+		return;
+	nvram_image[addr] = val;
+}
+
+
+static unsigned char __openfirmware direct_nvram_read_byte(int addr)
+{
+	return in_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult]);
+}
+
+static void __openfirmware direct_nvram_write_byte(int addr, unsigned char val)
+{
+	out_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult], val);
+}
+
+
+static unsigned char __pmac indirect_nvram_read_byte(int addr)
+{
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	out_8(nvram_addr, addr >> 5);
+	val = in_8(&nvram_data[(addr & 0x1f) << 4]);
+	spin_unlock_irqrestore(&nv_lock, flags);
+
+	return val;
+}
+
+static void __pmac indirect_nvram_write_byte(int addr, unsigned char val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	out_8(nvram_addr, addr >> 5);
+	out_8(&nvram_data[(addr & 0x1f) << 4], val);
+	spin_unlock_irqrestore(&nv_lock, flags);
+}
+
+
+#ifdef CONFIG_ADB_PMU
+
+static void __pmac pmu_nvram_complete(struct adb_request *req)
+{
+	if (req->arg)
+		complete((struct completion *)req->arg);
+}
 
-static u8 __pmac
-chrp_checksum(struct chrp_header* hdr)
+static unsigned char __pmac pmu_nvram_read_byte(int addr)
+{
+	struct adb_request req;
+	DECLARE_COMPLETION(req_complete); 
+	
+	req.arg = system_running ? &req_complete : NULL;
+	if (pmu_request(&req, pmu_nvram_complete, 3, PMU_READ_NVRAM,
+			(addr >> 8) & 0xff, addr & 0xff))
+		return 0xff;
+	if (system_running)
+		wait_for_completion(&req_complete);
+	while (!req.complete)
+		pmu_poll();
+	return req.reply[0];
+}
+
+static void __pmac pmu_nvram_write_byte(int addr, unsigned char val)
+{
+	struct adb_request req;
+	DECLARE_COMPLETION(req_complete); 
+	
+	req.arg = system_running ? &req_complete : NULL;
+	if (pmu_request(&req, pmu_nvram_complete, 4, PMU_WRITE_NVRAM,
+			(addr >> 8) & 0xff, addr & 0xff, val))
+		return;
+	if (system_running)
+		wait_for_completion(&req_complete);
+	while (!req.complete)
+		pmu_poll();
+}
+
+#endif /* CONFIG_ADB_PMU */
+
+
+static u8 __pmac chrp_checksum(struct chrp_header* hdr)
 {
 	u8 *ptr;
 	u16 sum = hdr->signature;
@@ -95,8 +194,7 @@ chrp_checksum(struct chrp_header* hdr)
 	return sum;
 }
 
-static u32 __pmac
-core99_calc_adler(u8 *buffer)
+static u32 __pmac core99_calc_adler(u8 *buffer)
 {
 	int cnt;
 	u32 low, high;
@@ -118,86 +216,186 @@ core99_calc_adler(u8 *buffer)
 	return (high << 16) | low;
 }
 
-static u32 __pmac
-core99_check(u8* datas)
+static u32 __pmac core99_check(u8* datas)
 {
 	struct core99_header* hdr99 = (struct core99_header*)datas;
 
 	if (hdr99->hdr.signature != CORE99_SIGNATURE) {
-#ifdef DEBUG
-		printk("Invalid signature\n");
-#endif
+		DBG("Invalid signature\n");
 		return 0;
 	}
 	if (hdr99->hdr.cksum != chrp_checksum(&hdr99->hdr)) {
-#ifdef DEBUG
-		printk("Invalid checksum\n");
-#endif
+		DBG("Invalid checksum\n");
 		return 0;
 	}
 	if (hdr99->adler != core99_calc_adler(datas)) {
-#ifdef DEBUG
-		printk("Invalid adler\n");
-#endif
+		DBG("Invalid adler\n");
 		return 0;
 	}
 	return hdr99->generation;
 }
 
-static int __pmac
-core99_erase_bank(int bank)
+static int __pmac sm_erase_bank(int bank)
 {
 	int stat, i;
+	unsigned long timeout;
 
 	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
 
-	out_8(base, CORE99_FLASH_CMD_ERASE_SETUP);
-	out_8(base, CORE99_FLASH_CMD_ERASE_CONFIRM);
-	do { stat = in_8(base); }
-	while(!(stat & CORE99_FLASH_STATUS_DONE));
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on erase !\n", stat);
-		return -ENXIO;
-	}
+       	DBG("nvram: Sharp/Micron Erasing bank %d...\n", bank);
+
+	out_8(base, SM_FLASH_CMD_ERASE_SETUP);
+	out_8(base, SM_FLASH_CMD_ERASE_CONFIRM);
+	timeout = 0;
+	do {
+		if (++timeout > 1000000) {
+			printk(KERN_ERR "nvram: Sharp/Miron flash erase timeout !\n");
+			break;
+		}
+		out_8(base, SM_FLASH_CMD_READ_STATUS);
+		stat = in_8(base);
+	} while (!(stat & SM_FLASH_STATUS_DONE));
+
+	out_8(base, SM_FLASH_CMD_CLEAR_STATUS);
+	out_8(base, SM_FLASH_CMD_RESET);
+
 	for (i=0; i<NVRAM_SIZE; i++)
 		if (base[i] != 0xff) {
-			printk("nvram: flash erase failed !\n");
+			printk(KERN_ERR "nvram: Sharp/Micron flash erase failed !\n");
 			return -ENXIO;
 		}
 	return 0;
 }
 
-static int __pmac
-core99_write_bank(int bank, u8* datas)
+static int __pmac sm_write_bank(int bank, u8* datas)
 {
 	int i, stat = 0;
+	unsigned long timeout;
 
 	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
 
+       	DBG("nvram: Sharp/Micron Writing bank %d...\n", bank);
+
 	for (i=0; i<NVRAM_SIZE; i++) {
-		out_8(base+i, CORE99_FLASH_CMD_WRITE_SETUP);
+		out_8(base+i, SM_FLASH_CMD_WRITE_SETUP);
+		udelay(1);
 		out_8(base+i, datas[i]);
-		do { stat = in_8(base); }
-		while(!(stat & CORE99_FLASH_STATUS_DONE));
-		if (stat & CORE99_FLASH_STATUS_ERR)
+		timeout = 0;
+		do {
+			if (++timeout > 1000000) {
+				printk(KERN_ERR "nvram: Sharp/Micron flash write timeout !\n");
+				break;
+			}
+			out_8(base, SM_FLASH_CMD_READ_STATUS);
+			stat = in_8(base);
+		} while (!(stat & SM_FLASH_STATUS_DONE));
+		if (!(stat & SM_FLASH_STATUS_DONE))
 			break;
 	}
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on write !\n", stat);
-		return -ENXIO;
+	out_8(base, SM_FLASH_CMD_CLEAR_STATUS);
+	out_8(base, SM_FLASH_CMD_RESET);
+	for (i=0; i<NVRAM_SIZE; i++)
+		if (base[i] != datas[i]) {
+			printk(KERN_ERR "nvram: Sharp/Micron flash write failed !\n");
+			return -ENXIO;
+		}
+	return 0;
+}
+
+static int __pmac amd_erase_bank(int bank)
+{
+	int i, stat = 0;
+	unsigned long timeout;
+
+	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
+
+       	DBG("nvram: AMD Erasing bank %d...\n", bank);
+
+	/* Unlock 1 */
+	out_8(base+0x555, 0xaa);
+	udelay(1);
+	/* Unlock 2 */
+	out_8(base+0x2aa, 0x55);
+	udelay(1);
+
+	/* Sector-Erase */
+	out_8(base+0x555, 0x80);
+	udelay(1);
+	out_8(base+0x555, 0xaa);
+	udelay(1);
+	out_8(base+0x2aa, 0x55);
+	udelay(1);
+	out_8(base, 0x30);
+	udelay(1);
+
+	timeout = 0;
+	do {
+		if (++timeout > 1000000) {
+			printk(KERN_ERR "nvram: AMD flash erase timeout !\n");
+			break;
+		}
+		stat = in_8(base) ^ in_8(base);
+	} while (stat != 0);
+	
+	/* Reset */
+	out_8(base, 0xf0);
+	udelay(1);
+	
+	for (i=0; i<NVRAM_SIZE; i++)
+		if (base[i] != 0xff) {
+			printk(KERN_ERR "nvram: AMD flash erase failed !\n");
+			return -ENXIO;
+		}
+	return 0;
+}
+
+static int __pmac amd_write_bank(int bank, u8* datas)
+{
+	int i, stat = 0;
+	unsigned long timeout;
+
+	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
+
+       	DBG("nvram: AMD Writing bank %d...\n", bank);
+
+	for (i=0; i<NVRAM_SIZE; i++) {
+		/* Unlock 1 */
+		out_8(base+0x555, 0xaa);
+		udelay(1);
+		/* Unlock 2 */
+		out_8(base+0x2aa, 0x55);
+		udelay(1);
+
+		/* Write single word */
+		out_8(base+0x555, 0xa0);
+		udelay(1);
+		out_8(base+i, datas[i]);
+		
+		timeout = 0;
+		do {
+			if (++timeout > 1000000) {
+				printk(KERN_ERR "nvram: AMD flash write timeout !\n");
+				break;
+			}
+			stat = in_8(base) ^ in_8(base);
+		} while (stat != 0);
+		if (stat != 0)
+			break;
 	}
+
+	/* Reset */
+	out_8(base, 0xf0);
+	udelay(1);
+
 	for (i=0; i<NVRAM_SIZE; i++)
 		if (base[i] != datas[i]) {
-			printk("nvram: flash write failed !\n");
+			printk(KERN_ERR "nvram: AMD flash write failed !\n");
 			return -ENXIO;
 		}
 	return 0;
 }
 
-static void __init
-lookup_partitions(void)
+static void __init lookup_partitions(void)
 {
 	u8 buffer[17];
 	int i, offset;
@@ -227,15 +425,49 @@ lookup_partitions(void)
 		nvram_partitions[pmac_nvram_XPRAM] = 0x1300;
 		nvram_partitions[pmac_nvram_NR] = 0x1400;
 	}
+	DBG("nvram: OF partition at 0x%x\n", nvram_partitions[pmac_nvram_OF]);
+	DBG("nvram: XP partition at 0x%x\n", nvram_partitions[pmac_nvram_XPRAM]);
+	DBG("nvram: NR partition at 0x%x\n", nvram_partitions[pmac_nvram_NR]);
+}
+
+static void __pmac core99_nvram_sync(void)
+{
+	struct core99_header* hdr99;
+	unsigned long flags;
+
+	if (!is_core_99 || !nvram_data || !nvram_image)
+		return;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	if (!memcmp(nvram_image, (u8*)nvram_data + core99_bank*NVRAM_SIZE,
+		NVRAM_SIZE))
+		goto bail;
+
+	DBG("Updating nvram...\n");
+
+	hdr99 = (struct core99_header*)nvram_image;
+	hdr99->generation++;
+	hdr99->hdr.signature = CORE99_SIGNATURE;
+	hdr99->hdr.cksum = chrp_checksum(&hdr99->hdr);
+	hdr99->adler = core99_calc_adler(nvram_image);
+	core99_bank = core99_bank ? 0 : 1;
+	if (core99_erase_bank)
+		if (core99_erase_bank(core99_bank)) {
+			printk("nvram: Error erasing bank %d\n", core99_bank);
+			goto bail;
+		}
+	if (core99_write_bank)
+		if (core99_write_bank(core99_bank, nvram_image))
+			printk("nvram: Error writing bank %d\n", core99_bank);
+ bail:
+	spin_unlock_irqrestore(&nv_lock, flags);
+
 #ifdef DEBUG
-	printk("nvram: OF partition at 0x%x\n", nvram_partitions[pmac_nvram_OF]);
-	printk("nvram: XP partition at 0x%x\n", nvram_partitions[pmac_nvram_XPRAM]);
-	printk("nvram: NR partition at 0x%x\n", nvram_partitions[pmac_nvram_NR]);
+       	mdelay(2000);
 #endif
 }
 
-void __init
-pmac_nvram_init(void)
+void __init pmac_nvram_init(void)
 {
 	struct device_node *dp;
 
@@ -256,38 +488,65 @@ pmac_nvram_init(void)
 			printk(KERN_ERR "nvram: no address\n");
 			return;
 		}
-#if 0
-		nvram_image = kmalloc(NVRAM_SIZE, GFP_KERNEL);
-		if (!nvram_image) {
-			printk(KERN_ERR "nvram: can't allocate image\n");
+		nvram_image = alloc_bootmem(NVRAM_SIZE);
+		if (nvram_image == NULL) {
+			printk(KERN_ERR "nvram: can't allocate ram image\n");
 			return;
 		}
-#endif
 		nvram_data = ioremap(dp->addrs[0].address, NVRAM_SIZE*2);
-#ifdef DEBUG
-		printk("nvram: Checking bank 0...\n");
-#endif
+		nvram_naddrs = 1; /* Make sure we get the correct case */
+
+		DBG("nvram: Checking bank 0...\n");
+
 		gen_bank0 = core99_check((u8 *)nvram_data);
 		gen_bank1 = core99_check((u8 *)nvram_data + NVRAM_SIZE);
 		core99_bank = (gen_bank0 < gen_bank1) ? 1 : 0;
-#ifdef DEBUG
-		printk("nvram: gen0=%d, gen1=%d\n", gen_bank0, gen_bank1);
-		printk("nvram: Active bank is: %d\n", core99_bank);
-#endif
+
+		DBG("nvram: gen0=%d, gen1=%d\n", gen_bank0, gen_bank1);
+		DBG("nvram: Active bank is: %d\n", core99_bank);
+
 		for (i=0; i<NVRAM_SIZE; i++)
 			nvram_image[i] = nvram_data[i + core99_bank*NVRAM_SIZE];
+
+		ppc_md.nvram_read_val	= core99_nvram_read_byte;
+		ppc_md.nvram_write_val	= core99_nvram_write_byte;
+		ppc_md.nvram_sync	= core99_nvram_sync;
+		/* 
+		 * Maybe we could be smarter here though making an exclusive list
+		 * of known flash chips is a bit nasty as older OF didn't provide us
+		 * with a useful "compatible" entry. A solution would be to really
+		 * identify the chip using flash id commands and base ourselves on
+		 * a list of known chips IDs
+		 */
+		if (device_is_compatible(dp, "amd-0137")) {
+			core99_erase_bank = amd_erase_bank;
+			core99_write_bank = amd_write_bank;
+		} else {
+			core99_erase_bank = sm_erase_bank;
+			core99_write_bank = sm_write_bank;
+		}
 	} else if (_machine == _MACH_chrp && nvram_naddrs == 1) {
 		nvram_data = ioremap(dp->addrs[0].address + isa_mem_base,
 				     dp->addrs[0].size);
 		nvram_mult = 1;
+		ppc_md.nvram_read_val	= direct_nvram_read_byte;
+		ppc_md.nvram_write_val	= direct_nvram_write_byte;
 	} else if (nvram_naddrs == 1) {
 		nvram_data = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_mult = (dp->addrs[0].size + NVRAM_SIZE - 1) / NVRAM_SIZE;
+		ppc_md.nvram_read_val	= direct_nvram_read_byte;
+		ppc_md.nvram_write_val	= direct_nvram_write_byte;
 	} else if (nvram_naddrs == 2) {
 		nvram_addr = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_data = ioremap(dp->addrs[1].address, dp->addrs[1].size);
+		ppc_md.nvram_read_val	= indirect_nvram_read_byte;
+		ppc_md.nvram_write_val	= indirect_nvram_write_byte;
 	} else if (nvram_naddrs == 0 && sys_ctrler == SYS_CTRLER_PMU) {
+#ifdef CONFIG_ADB_PMU
 		nvram_naddrs = -1;
+		ppc_md.nvram_read_val	= pmu_nvram_read_byte;
+		ppc_md.nvram_write_val	= pmu_nvram_write_byte;
+#endif /* CONFIG_ADB_PMU */
 	} else {
 		printk(KERN_ERR "Don't know how to access NVRAM with %d addresses\n",
 		       nvram_naddrs);
@@ -295,117 +554,31 @@ pmac_nvram_init(void)
 	lookup_partitions();
 }
 
-void __pmac
-pmac_nvram_update(void)
-{
-	struct core99_header* hdr99;
-
-	if (!is_core_99 || !nvram_data || !nvram_image)
-		return;
-	if (!memcmp(nvram_image, (u8*)nvram_data + core99_bank*NVRAM_SIZE,
-		NVRAM_SIZE))
-		return;
-#ifdef DEBUG
-	printk("Updating nvram...\n");
-#endif
-	hdr99 = (struct core99_header*)nvram_image;
-	hdr99->generation++;
-	hdr99->hdr.signature = CORE99_SIGNATURE;
-	hdr99->hdr.cksum = chrp_checksum(&hdr99->hdr);
-	hdr99->adler = core99_calc_adler(nvram_image);
-	core99_bank = core99_bank ? 0 : 1;
-	if (core99_erase_bank(core99_bank)) {
-		printk("nvram: Error erasing bank %d\n", core99_bank);
-		return;
-	}
-	if (core99_write_bank(core99_bank, nvram_image))
-		printk("nvram: Error writing bank %d\n", core99_bank);
-}
-
-unsigned char __pmac
-pmac_nvram_read_byte(int addr)
-{
-	switch (nvram_naddrs) {
-#ifdef CONFIG_ADB_PMU
-	case -1: {
-		struct adb_request req;
-
-		if (pmu_request(&req, NULL, 3, PMU_READ_NVRAM,
-				(addr >> 8) & 0xff, addr & 0xff))
-			break;
-		while (!req.complete)
-			pmu_poll();
-		return req.reply[0];
-	}
-#endif
-	case 1:
-		if (is_core_99)
-			return nvram_image[addr];
-		return nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult];
-	case 2:
-		*nvram_addr = addr >> 5;
-		eieio();
-		return nvram_data[(addr & 0x1f) << 4];
-	}
-	return 0;
-}
-
-void __pmac
-pmac_nvram_write_byte(int addr, unsigned char val)
-{
-	switch (nvram_naddrs) {
-#ifdef CONFIG_ADB_PMU
-	case -1: {
-		struct adb_request req;
-
-		if (pmu_request(&req, NULL, 4, PMU_WRITE_NVRAM,
-				(addr >> 8) & 0xff, addr & 0xff, val))
-			break;
-		while (!req.complete)
-			pmu_poll();
-		break;
-	}
-#endif
-	case 1:
-		if (is_core_99) {
-			nvram_image[addr] = val;
-			break;
-		}
-		nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult] = val;
-		break;
-	case 2:
-		*nvram_addr = addr >> 5;
-		eieio();
-		nvram_data[(addr & 0x1f) << 4] = val;
-		break;
-	}
-	eieio();
-}
-
-int __pmac
-pmac_get_partition(int partition)
+int __pmac pmac_get_partition(int partition)
 {
 	return nvram_partitions[partition];
 }
 
-u8 __pmac
-pmac_xpram_read(int xpaddr)
+u8 __pmac pmac_xpram_read(int xpaddr)
 {
 	int offset = nvram_partitions[pmac_nvram_XPRAM];
 
 	if (offset < 0)
-		return 0;
+		return 0xff;
 
-	return pmac_nvram_read_byte(xpaddr + offset);
+	return ppc_md.nvram_read_val(xpaddr + offset);
 }
 
-void __pmac
-pmac_xpram_write(int xpaddr, u8 data)
+void __pmac pmac_xpram_write(int xpaddr, u8 data)
 {
 	int offset = nvram_partitions[pmac_nvram_XPRAM];
 
 	if (offset < 0)
 		return;
 
-	pmac_nvram_write_byte(data, xpaddr + offset);
+	ppc_md.nvram_write_val(xpaddr + offset, data);
 }
+
+EXPORT_SYMBOL(pmac_get_partition);
+EXPORT_SYMBOL(pmac_xpram_read);
+EXPORT_SYMBOL(pmac_xpram_write);
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_pci.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_pci.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_pci.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_pci.c	2003-12-18 05:08:46.000000000 +0000
@@ -1,13 +1,11 @@
 /*
  * Support for PCI bridges found on Power Macintoshes.
- *
- * This includes support for bandit, chaos, grackle (motorola
- * MPC106), and uninorth
+ * At present the "bandit" and "chaos" bridges are supported.
+ * Fortunately you access configuration space in the same
+ * way with either bridge.
  *
  * Copyright (C) 1997 Paul Mackerras (paulus@cs.anu.edu.au)
  *
- * Maintained by Benjamin Herrenschmidt (benh@kernel.crashing.org)
- *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
@@ -30,11 +28,30 @@
 
 #undef DEBUG
 
-static void add_bridges(struct device_node *dev);
+#ifdef DEBUG
+#ifdef CONFIG_XMON
+extern void xmon_printf(const char *fmt, ...);
+#define DBG(x...) xmon_printf(x)
+#else
+#define DBG(x...) printk(x)
+#endif
+#else
+#define DBG(x...)
+#endif
+
+static int add_bridge(struct device_node *dev);
+extern void pmac_check_ht_link(void);
 
 /* XXX Could be per-controller, but I don't think we risk anything by
  * assuming we won't have both UniNorth and Bandit */
 static int has_uninorth;
+#ifdef CONFIG_POWER4
+static struct pci_controller *u3_agp;
+#endif /* CONFIG_POWER4 */
+
+extern u8 pci_cache_line_size;
+
+struct pci_dev *k2_skiplist[2];
 
 /*
  * Magic constants for enabling cache coherency in the bandit/PSX bridge.
@@ -51,7 +68,7 @@ fixup_one_level_bus_range(struct device_
 {
 	for (; node != 0;node = node->sibling) {
 		int * bus_range;
-		unsigned int *class_code;		
+		unsigned int *class_code;
 		int len;
 
 		/* For PCI<->PCI bridges or CardBus bridges, we go down */
@@ -81,7 +98,7 @@ fixup_bus_range(struct device_node *brid
 	int * bus_range;
 	int len;
 
-	/* Lookup the "bus-range" property for the hose */	
+	/* Lookup the "bus-range" property for the hose */
 	bus_range = (int *) get_property(bridge, "bus-range", &len);
 	if (bus_range == NULL || len < 2 * sizeof(int)) {
 		printk(KERN_WARNING "Can't get bus-range for %s\n",
@@ -92,7 +109,7 @@ fixup_bus_range(struct device_node *brid
 }
 
 /*
- * Apple MacRISC (UniNorth, Bandit, Chaos) PCI controllers.
+ * Apple MacRISC (U3, UniNorth, Bandit, Chaos) PCI controllers.
  *
  * The "Bandit" version is present in all early PCI PowerMacs,
  * and up to the first ones using Grackle. Some machines may
@@ -106,6 +123,11 @@ fixup_bus_range(struct device_node *brid
  * The "UniNorth" version is present in all Core99 machines
  * (iBook, G4, new IMacs, and all the recent Apple machines).
  * It contains 3 controllers in one ASIC.
+ *
+ * The U3 is the bridge used on G5 machines. It contains on
+ * AGP bus which is dealt with the old UniNorth access routines
+ * and an HyperTransport bus which uses its own set of access
+ * functions.
  */
 
 #define MACRISC_CFA0(devfn, off)	\
@@ -211,12 +233,22 @@ static struct pci_ops macrisc_pci_ops =
 static int __pmac
 chaos_validate_dev(struct pci_bus *bus, int devfn, int offset)
 {
-	if (pci_busdev_to_OF_node(bus, devfn) == 0)
+	struct device_node *np;
+	u32 *vendor, *device;
+
+	np = pci_busdev_to_OF_node(bus, devfn);
+	if (np == NULL)
 		return PCIBIOS_DEVICE_NOT_FOUND;
-	if (/*(dev->vendor == 0x106b) && (dev->device == 3) &&*/ (offset >= 0x10)
-	    && (offset != 0x14) && (offset != 0x18) && (offset <= 0x24)) {
+
+	vendor = (u32 *)get_property(np, "vendor-id", NULL);
+	device = (u32 *)get_property(np, "device-id", NULL);
+	if (vendor == NULL || device == NULL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if ((*vendor == 0x106b) && (*device == 3) && (offset >= 0x10)
+	    && (offset != 0x14) && (offset != 0x18) && (offset <= 0x24))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
+
 	return PCIBIOS_SUCCESSFUL;
 }
 
@@ -248,6 +280,128 @@ static struct pci_ops chaos_pci_ops =
 	chaos_write_config
 };
 
+#ifdef CONFIG_POWER4
+
+/*
+ * These versions of U3 HyperTransport config space access ops do not
+ * implement self-view of the HT host yet
+ */
+
+#define U3_HT_CFA0(devfn, off)		\
+		((((unsigned long)devfn) << 8) | offset)
+#define U3_HT_CFA1(bus, devfn, off)	\
+		(U3_HT_CFA0(devfn, off) \
+		+ (((unsigned long)bus) << 16) \
+		+ 0x01000000UL)
+
+static unsigned long __pmac
+u3_ht_cfg_access(struct pci_controller* hose, u8 bus, u8 devfn, u8 offset)
+{
+	if (bus == hose->first_busno) {
+		/* For now, we don't self probe U3 HT bridge */
+		if (PCI_FUNC(devfn) != 0 || PCI_SLOT(devfn) > 7 ||
+		    PCI_SLOT(devfn) < 1)
+			return 0;
+		return ((unsigned long)hose->cfg_data) + U3_HT_CFA0(devfn, offset);
+	} else
+		return ((unsigned long)hose->cfg_data) + U3_HT_CFA1(bus, devfn, offset);
+}
+
+static int __pmac
+u3_ht_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
+		    int len, u32 *val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	unsigned int addr;
+	int i;
+
+	/*
+	 * When a device in K2 is powered down, we die on config
+	 * cycle accesses. Fix that here.
+	 */
+	for (i=0; i<2; i++)
+		if (k2_skiplist[i] && k2_skiplist[i]->bus == bus &&
+		    k2_skiplist[i]->devfn == devfn) {
+			switch (len) {
+			case 1:
+				*val = 0xff; break;
+			case 2:
+				*val = 0xffff; break;
+			default:
+				*val = 0xfffffffful; break;
+			}
+			return PCIBIOS_SUCCESSFUL;
+		}
+	    
+	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset);
+	if (!addr)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		*val = in_8((u8 *)addr);
+		break;
+	case 2:
+		*val = in_le16((u16 *)addr);
+		break;
+	default:
+		*val = in_le32((u32 *)addr);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int __pmac
+u3_ht_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
+		     int len, u32 val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	unsigned int addr;
+	int i;
+
+	/*
+	 * When a device in K2 is powered down, we die on config
+	 * cycle accesses. Fix that here.
+	 */
+	for (i=0; i<2; i++)
+		if (k2_skiplist[i] && k2_skiplist[i]->bus == bus &&
+		    k2_skiplist[i]->devfn == devfn)
+			return PCIBIOS_SUCCESSFUL;
+
+	addr = u3_ht_cfg_access(hose, bus->number, devfn, offset);
+	if (!addr)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		out_8((u8 *)addr, val);
+		(void) in_8((u8 *)addr);
+		break;
+	case 2:
+		out_le16((u16 *)addr, val);
+		(void) in_le16((u16 *)addr);
+		break;
+	default:
+		out_le32((u32 *)addr, val);
+		(void) in_le32((u32 *)addr);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops u3_ht_pci_ops =
+{
+	u3_ht_read_config,
+	u3_ht_write_config
+};
+
+#endif /* CONFIG_POWER4 */
 
 /*
  * For a bandit bridge, turn on cache coherency if necessary.
@@ -309,9 +463,7 @@ init_p2pbridge(void)
 	    || strcmp(p2pbridge->parent->name, "pci") != 0)
 		return;
 	if (pci_device_from_OF_node(p2pbridge, &bus, &devfn) < 0) {
-#ifdef DEBUG
-		printk("Can't find PCI infos for PCI<->PCI bridge\n");
-#endif	
+		DBG("Can't find PCI infos for PCI<->PCI bridge\n");
 		return;
 	}
 	/* Warning: At this point, we have not yet renumbered all busses.
@@ -319,9 +471,7 @@ init_p2pbridge(void)
 	 */
 	hose = pci_find_hose_for_OF_device(p2pbridge);
 	if (!hose) {
-#ifdef DEBUG
-		printk("Can't find hose for PCI<->PCI bridge\n");
-#endif	
+		DBG("Can't find hose for PCI<->PCI bridge\n");
 		return;
 	}
 	if (early_read_config_word(hose, bus, devfn,
@@ -333,13 +483,114 @@ init_p2pbridge(void)
 	early_write_config_word(hose, bus, devfn, PCI_BRIDGE_CONTROL, val);
 }
 
+/*
+ * Some Apple desktop machines have a NEC PD720100A USB2 controller
+ * on the motherboard. Open Firmware, on these, will disable the
+ * EHCI part of it so it behaves like a pair of OHCI's. This fixup
+ * code re-enables it ;)
+ */
+static void __init
+fixup_nec_usb2(void)
+{
+	struct device_node *nec;
+
+	for (nec = NULL; (nec = of_find_node_by_name(nec, "usb")) != NULL;) {
+		struct pci_controller *hose;
+		u32 data, *prop;
+		u8 bus, devfn;
+		
+		prop = (u32 *)get_property(nec, "vendor-id", NULL);
+		if (prop == NULL)
+			continue;
+		if (0x1033 != *prop)
+			continue;
+		prop = (u32 *)get_property(nec, "device-id", NULL);
+		if (prop == NULL)
+			continue;
+		if (0x0035 != *prop)
+			continue;
+		prop = (u32 *)get_property(nec, "reg", 0);
+		if (prop == NULL)
+			continue;
+		devfn = (prop[0] >> 8) & 0xff;
+		bus = (prop[0] >> 16) & 0xff;
+		if (PCI_FUNC(devfn) != 0)
+			continue;
+		hose = pci_find_hose_for_OF_device(nec);
+		if (!hose)
+			continue;
+		early_read_config_dword(hose, bus, devfn, 0xe4, &data);
+		if (data & 1UL) {
+			printk("Found NEC PD720100A USB2 chip with disabled EHCI, fixing up...\n");
+			data &= ~1UL;
+			early_write_config_dword(hose, bus, devfn, 0xe4, data);
+			early_write_config_byte(hose, bus, devfn | 2, PCI_INTERRUPT_LINE,
+				nec->intrs[0].line);
+		}
+	}
+}
+
 void __init
 pmac_find_bridges(void)
 {
-	add_bridges(find_devices("bandit"));
-	add_bridges(find_devices("chaos"));
-	add_bridges(find_devices("pci"));
+	struct device_node *np, *root;
+	struct device_node *ht = NULL;
+
+	root = of_find_node_by_path("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "pmac_find_bridges: can't find root of device tree\n");
+		return;
+	}
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;) {
+		if (np->name == NULL)
+			continue;
+		if (strcmp(np->name, "bandit") == 0
+		    || strcmp(np->name, "chaos") == 0
+		    || strcmp(np->name, "pci") == 0) {
+			if (add_bridge(np) == 0)
+				of_node_get(np);
+		}
+		if (strcmp(np->name, "ht") == 0) {
+			of_node_get(np);
+			ht = np;
+		}
+	}
+	of_node_put(root);
+
+	/* Probe HT last as it relies on the agp resources to be already
+	 * setup
+	 */
+	if (ht && add_bridge(ht) != 0)
+		of_node_put(ht);
+
 	init_p2pbridge();
+	fixup_nec_usb2();
+#ifdef CONFIG_POWER4 
+	/* There is something wrong with DMA on U3/HT. I haven't figured out
+	 * the details yet, but if I set the cache line size to 128 bytes like
+	 * it should, I'm getting memory corruption caused by devices like
+	 * sungem (even without the MWI bit set, but maybe sungem doesn't
+	 * care). Right now, it appears that setting up a 64 bytes line size
+	 * works properly, 64 bytes beeing the max transfer size of HT, I
+	 * suppose this is related the way HT/PCI are hooked together. I still
+	 * need to dive into more specs though to be really sure of what's
+	 * going on. --BenH.
+	 *
+	 * Ok, apparently, it's just that HT can't do more than 64 bytes
+	 * transactions. MWI seem to be meaningless there as well, it may
+	 * be worth nop'ing out pci_set_mwi too though I haven't done that
+	 * yet.
+	 *
+	 * Note that it's a bit different for whatever is in the AGP slot.
+	 * For now, I don't care, but this can become a real issue, we
+	 * should probably hook pci_set_mwi anyway to make sure it sets
+	 * the real cache line size in there.
+	 */
+	if (machine_is_compatible("MacRISC4"))
+		pci_cache_line_size = 16; /* 64 bytes */
+
+	pmac_check_ht_link();
+#endif /* CONFIG_POWER4 */
 }
 
 #define GRACKLE_CFA(b, d, o)	(0x80 | ((b) << 8) | ((d) << 16) \
@@ -410,6 +661,118 @@ setup_chaos(struct pci_controller* hose,
 		ioremap(addr->address + 0xc00000, 0x1000);
 }
 
+#ifdef CONFIG_POWER4
+
+static void __init
+setup_u3_agp(struct pci_controller* hose, struct reg_property* addr)
+{
+	/* On G5, we move AGP up to high bus number so we don't need
+	 * to reassign bus numbers for HT. If we ever have P2P bridges
+	 * on AGP, we'll have to move pci_assign_all_busses to the
+	 * pci_controller structure so we enable it for AGP and not for
+	 * HT childs.
+	 * We hard code the address because of the different size of
+	 * the reg address cell, we shall fix that by killing struct
+	 * reg_property and using some accessor functions instead
+	 */
+       	hose->first_busno = 0xf0;
+	hose->last_busno = 0xff;
+	has_uninorth = 1;
+	hose->ops = &macrisc_pci_ops;
+	hose->cfg_addr = ioremap(0xf0000000 + 0x800000, 0x1000);
+	hose->cfg_data = ioremap(0xf0000000 + 0xc00000, 0x1000);
+
+	u3_agp = hose;
+}
+
+static void __init
+setup_u3_ht(struct pci_controller* hose, struct reg_property *addr)
+{
+	struct device_node *np = (struct device_node *)hose->arch_data;
+	int i, cur;
+
+	hose->ops = &u3_ht_pci_ops;
+
+	/* We hard code the address because of the different size of
+	 * the reg address cell, we shall fix that by killing struct
+	 * reg_property and using some accessor functions instead
+	 */
+	hose->cfg_data = (volatile unsigned char *)ioremap(0xf2000000, 0x02000000);
+
+	/*
+	 * /ht node doesn't expose a "ranges" property, so we "remove" regions that
+	 * have been allocated to AGP. So far, this version of the code doesn't assign
+	 * any of the 0xfxxxxxxx "fine" memory regions to /ht.
+	 * We need to fix that sooner or later by either parsing all child "ranges"
+	 * properties or figuring out the U3 address space decoding logic and
+	 * then read it's configuration register (if any).
+	 */
+	hose->io_base_phys = 0xf4000000 + 0x00400000;
+	hose->io_base_virt = ioremap(hose->io_base_phys, 0x00400000);
+	isa_io_base = (unsigned long) hose->io_base_virt;
+	hose->io_resource.name = np->full_name;
+	hose->io_resource.start = 0;
+	hose->io_resource.end = 0x003fffff;
+	hose->io_resource.flags = IORESOURCE_IO;
+	hose->pci_mem_offset = 0;
+	hose->first_busno = 0;
+	hose->last_busno = 0xef;
+	hose->mem_resources[0].name = np->full_name;
+	hose->mem_resources[0].start = 0x80000000;
+	hose->mem_resources[0].end = 0xefffffff;
+	hose->mem_resources[0].flags = IORESOURCE_MEM;
+
+	if (u3_agp == NULL) {
+		DBG("U3 has no AGP, using full resource range\n");
+		return;
+	}
+
+	/* We "remove" the AGP resources from the resources allocated to HT, that
+	 * is we create "holes". However, that code does assumptions that so far
+	 * happen to be true (cross fingers...), typically that resources in the
+	 * AGP node are properly ordered
+	 */
+	cur = 0;
+	for (i=0; i<3; i++) {
+		struct resource *res = &u3_agp->mem_resources[i];
+		if (res->flags != IORESOURCE_MEM)
+			continue;
+		/* We don't care about "fine" resources */
+		if (res->start >= 0xf0000000)
+			continue;
+		/* Check if it's just a matter of "shrinking" us in one direction */
+		if (hose->mem_resources[cur].start == res->start) {
+			DBG("U3/HT: shrink start of %d, %08lx -> %08lx\n",
+			    cur, hose->mem_resources[cur].start, res->end + 1);
+			hose->mem_resources[cur].start = res->end + 1;
+			continue;
+		}
+		if (hose->mem_resources[cur].end == res->end) {
+			DBG("U3/HT: shrink end of %d, %08lx -> %08lx\n",
+			    cur, hose->mem_resources[cur].end, res->start - 1);
+			hose->mem_resources[cur].end = res->start - 1;
+			continue;
+		}
+		/* No, it's not the case, we need a hole */
+		if (cur == 2) {
+			/* not enough resources to make a hole, we drop part of the range */
+			printk(KERN_WARNING "Running out of resources for /ht host !\n");
+			hose->mem_resources[cur].end = res->start - 1;
+			continue;
+		}		
+		cur++;
+       		DBG("U3/HT: hole, %d end at %08lx, %d start at %08lx\n",
+		    cur-1, res->start - 1, cur, res->end + 1);
+		hose->mem_resources[cur].name = np->full_name;
+		hose->mem_resources[cur].flags = IORESOURCE_MEM;
+		hose->mem_resources[cur].start = res->end + 1;
+		hose->mem_resources[cur].end = hose->mem_resources[cur-1].end;
+		hose->mem_resources[cur-1].end = res->start - 1;
+	}
+}
+
+#endif /* CONFIG_POWER4 */
+
 void __init
 setup_grackle(struct pci_controller *hose)
 {
@@ -426,69 +789,77 @@ setup_grackle(struct pci_controller *hos
  * "pci" (a MPC106) and no bandit or chaos bridges, and contrariwise,
  * if we have one or more bandit or chaos bridges, we don't have a MPC106.
  */
-static void __init
-add_bridges(struct device_node *dev)
+static int __init
+add_bridge(struct device_node *dev)
 {
 	int len;
 	struct pci_controller *hose;
 	struct reg_property *addr;
 	char* disp_name;
 	int *bus_range;
-	int first = 1, primary;
+	int primary = 1;
 
-	for (; dev != NULL; dev = dev->next) {
-		addr = (struct reg_property *) get_property(dev, "reg", &len);
-		if (addr == NULL || len < sizeof(*addr)) {
-			printk(KERN_WARNING "Can't use %s: no address\n",
-			       dev->full_name);
-			continue;
-		}
-		bus_range = (int *) get_property(dev, "bus-range", &len);
-		if (bus_range == NULL || len < 2 * sizeof(int)) {
-			printk(KERN_WARNING "Can't get bus-range for %s, assume bus 0\n",
-				       dev->full_name);
-		}
-	
-		hose = pcibios_alloc_controller();
-		if (!hose)
-			continue;
-		hose->arch_data = dev;
-		hose->first_busno = bus_range ? bus_range[0] : 0;
-		hose->last_busno = bus_range ? bus_range[1] : 0xff;
-
-		disp_name = NULL;
-		primary = first;
-		if (device_is_compatible(dev, "uni-north")) {
-			primary = setup_uninorth(hose, addr);
-			disp_name = "UniNorth";
-		} else if (strcmp(dev->name, "pci") == 0) {
-			/* XXX assume this is a mpc106 (grackle) */
-			setup_grackle(hose);
-			disp_name = "Grackle (MPC106)";
-		} else if (strcmp(dev->name, "bandit") == 0) {
-			setup_bandit(hose, addr);
-			disp_name = "Bandit";
-		} else if (strcmp(dev->name, "chaos") == 0) {
-			setup_chaos(hose, addr);
-			disp_name = "Chaos";
-			primary = 0;
-		}
-		printk(KERN_INFO "Found %s PCI host bridge at 0x%08x. Firmware bus number: %d->%d\n",
-			disp_name, addr->address, hose->first_busno, hose->last_busno);
-#ifdef DEBUG
-		printk(" ->Hose at 0x%08lx, cfg_addr=0x%08lx,cfg_data=0x%08lx\n",
-			hose, hose->cfg_addr, hose->cfg_data);
-#endif	
-	
-		/* Interpret the "ranges" property */
-		/* This also maps the I/O region and sets isa_io/mem_base */
-		pci_process_bridge_OF_ranges(hose, dev, primary);
+	DBG("Adding PCI host bridge %s\n", dev->full_name);
 
-		/* Fixup "bus-range" OF property */
-		fixup_bus_range(dev);
+       	addr = (struct reg_property *) get_property(dev, "reg", &len);
+       	if (addr == NULL || len < sizeof(*addr)) {
+       		printk(KERN_WARNING "Can't use %s: no address\n",
+       		       dev->full_name);
+       		return -ENODEV;
+       	}
+       	bus_range = (int *) get_property(dev, "bus-range", &len);
+       	if (bus_range == NULL || len < 2 * sizeof(int)) {
+       		printk(KERN_WARNING "Can't get bus-range for %s, assume bus 0\n",
+       			       dev->full_name);
+       	}
+
+       	hose = pcibios_alloc_controller();
+       	if (!hose)
+       		return -ENOMEM;
+       	hose->arch_data = dev;
+       	hose->first_busno = bus_range ? bus_range[0] : 0;
+       	hose->last_busno = bus_range ? bus_range[1] : 0xff;
+
+	disp_name = NULL;
+#ifdef CONFIG_POWER4
+       	if (device_is_compatible(dev, "u3-agp")) {
+       		setup_u3_agp(hose, addr);
+       		disp_name = "U3-AGP";
+       		primary = 0;
+       	} else if (device_is_compatible(dev, "u3-ht")) {
+       		setup_u3_ht(hose, addr);
+       		disp_name = "U3-HT";
+       		primary = 1;
+       	} else
+#endif /* CONFIG_POWER4 */
+	if (device_is_compatible(dev, "uni-north")) {
+       		primary = setup_uninorth(hose, addr);
+       		disp_name = "UniNorth";
+       	} else if (strcmp(dev->name, "pci") == 0) {
+       		/* XXX assume this is a mpc106 (grackle) */
+       		setup_grackle(hose);
+       		disp_name = "Grackle (MPC106)";
+       	} else if (strcmp(dev->name, "bandit") == 0) {
+       		setup_bandit(hose, addr);
+       		disp_name = "Bandit";
+       	} else if (strcmp(dev->name, "chaos") == 0) {
+       		setup_chaos(hose, addr);
+       		disp_name = "Chaos";
+       		primary = 0;
+       	}
+       	printk(KERN_INFO "Found %s PCI host bridge at 0x%08x. Firmware bus number: %d->%d\n",
+       		disp_name, addr->address, hose->first_busno, hose->last_busno);
+       	DBG(" ->Hose at 0x%p, cfg_addr=0x%p,cfg_data=0x%p\n",
+       		hose, hose->cfg_addr, hose->cfg_data);
+
+       	/* Interpret the "ranges" property */
+       	/* This also maps the I/O region and sets isa_io/mem_base */
+       	pci_process_bridge_OF_ranges(hose, dev, primary);
 
-		first &= !primary;
-	}
+       	/* Fixup "bus-range" OF property */
+       	fixup_bus_range(dev);
+
+	return 0;
 }
 
 static void __init
@@ -575,7 +946,7 @@ pmac_pci_enable_device_hook(struct pci_d
 		cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;
     		pci_write_config_word(dev, PCI_COMMAND, cmd);
     		pci_write_config_byte(dev, PCI_LATENCY_TIMER, 16);
-    		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8);
+    		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, pci_cache_line_size);
 	}
 
 	return 0;
@@ -628,3 +999,108 @@ pmac_pcibios_after_init(void)
 	}
 }
 
+void pmac_pci_fixup_cardbus(struct pci_dev* dev)
+{
+	if (_machine != _MACH_Pmac)
+		return;
+	/*
+	 * Fix the interrupt routing on the various cardbus bridges
+	 * used on powerbooks
+	 */
+	if (dev->vendor != PCI_VENDOR_ID_TI)
+		return;
+	if (dev->device == PCI_DEVICE_ID_TI_1130 ||
+	    dev->device == PCI_DEVICE_ID_TI_1131) {
+		u8 val;
+	    	/* Enable PCI interrupt */
+		if (pci_read_config_byte(dev, 0x91, &val) == 0)
+			pci_write_config_byte(dev, 0x91, val | 0x30);
+		/* Disable ISA interrupt mode */
+		if (pci_read_config_byte(dev, 0x92, &val) == 0)
+			pci_write_config_byte(dev, 0x92, val & ~0x06);
+	}
+	if (dev->device == PCI_DEVICE_ID_TI_1210 ||
+	    dev->device == PCI_DEVICE_ID_TI_1211 ||
+	    dev->device == PCI_DEVICE_ID_TI_1410 ||
+	    dev->device == PCI_DEVICE_ID_TI_1510) {
+		u8 val;
+		/* 0x8c == TI122X_IRQMUX, 2 says to route the INTA
+		   signal out the MFUNC0 pin */
+		if (pci_read_config_byte(dev, 0x8c, &val) == 0)
+			pci_write_config_byte(dev, 0x8c, (val & ~0x0f) | 2);
+		/* Disable ISA interrupt mode */
+		if (pci_read_config_byte(dev, 0x92, &val) == 0)
+			pci_write_config_byte(dev, 0x92, val & ~0x06);
+	}
+}
+
+void pmac_pci_fixup_pciata(struct pci_dev* dev)
+{
+       u8 progif = 0;
+
+       /*
+        * On PowerMacs, we try to switch any PCI ATA controller to
+	* fully native mode
+        */
+	if (_machine != _MACH_Pmac)
+		return;
+	/* Some controllers don't have the class IDE */
+	if (dev->vendor == PCI_VENDOR_ID_PROMISE)
+		switch(dev->device) {
+		case PCI_DEVICE_ID_PROMISE_20246:
+		case PCI_DEVICE_ID_PROMISE_20262:
+		case PCI_DEVICE_ID_PROMISE_20263:
+		case PCI_DEVICE_ID_PROMISE_20265:
+		case PCI_DEVICE_ID_PROMISE_20267:
+		case PCI_DEVICE_ID_PROMISE_20268:
+		case PCI_DEVICE_ID_PROMISE_20269:
+		case PCI_DEVICE_ID_PROMISE_20270:
+		case PCI_DEVICE_ID_PROMISE_20271:
+		case PCI_DEVICE_ID_PROMISE_20275:
+		case PCI_DEVICE_ID_PROMISE_20276:
+		case PCI_DEVICE_ID_PROMISE_20277:
+			goto good;
+		}
+	/* Others, check PCI class */
+	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+ good:
+	pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
+	if ((progif & 5) != 5) {
+		printk(KERN_INFO "Forcing PCI IDE into native mode: %s\n", pci_name(dev));
+		(void) pci_write_config_byte(dev, PCI_CLASS_PROG, progif|5);
+		if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
+		    (progif & 5) != 5)
+			printk(KERN_ERR "Rewrite of PROGIF failed !\n");
+	}
+}
+
+/*
+ * Disable second function on K2-SATA, it's broken
+ * and disable IO BARs on first one
+ */
+void __pmac pmac_pci_fixup_k2_sata(struct pci_dev* dev)
+{
+	int i;
+	u16 cmd;
+
+	if (PCI_FUNC(dev->devfn) > 0) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		cmd &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+		for (i = 0; i < 6; i++) {
+			dev->resource[i].start = dev->resource[i].end = 0;
+			dev->resource[i].flags = 0;
+			pci_write_config_dword(dev, PCI_BASE_ADDRESS_0 + 4 * i, 0);
+		}
+	} else {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		cmd &= ~PCI_COMMAND_IO;
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+		for (i = 0; i < 5; i++) {
+			dev->resource[i].start = dev->resource[i].end = 0;
+			dev->resource[i].flags = 0;
+			pci_write_config_dword(dev, PCI_BASE_ADDRESS_0 + 4 * i, 0);
+		}
+	}
+}
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_pic.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_pic.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_pic.c	2003-09-12 16:26:54.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_pic.c	2003-11-16 23:56:04.000000000 +0000
@@ -34,6 +34,7 @@
 #include <asm/time.h>
 #include <asm/open_pic.h>
 #include <asm/xmon.h>
+#include <asm/pmac_feature.h>
 
 #include "pmac_pic.h"
 
@@ -363,32 +364,76 @@ static int __init enable_second_ohare(vo
 	return irqctrler->intrs[0].line;
 }
 
-void __init
-pmac_pic_init(void)
+#ifdef CONFIG_POWER4
+static irqreturn_t k2u3_action(int cpl, void *dev_id, struct pt_regs *regs)
+{
+	int irq;
+
+	irq = openpic2_get_irq(regs);
+	if (irq != -1)
+		ppc_irq_dispatch_handler(regs, irq);
+	return IRQ_HANDLED;
+}
+#endif /* CONFIG_POWER4 */
+
+void __init pmac_pic_init(void)
 {
         int i;
-        struct device_node *irqctrler;
+        struct device_node *irqctrler  = NULL;
+        struct device_node *irqctrler2 = NULL;
+	struct device_node *np;
         unsigned long addr;
 	int irq_cascade = -1;
 
 	/* We first try to detect Apple's new Core99 chipset, since mac-io
 	 * is quite different on those machines and contains an IBM MPIC2.
 	 */
-	irqctrler = find_type_devices("open-pic");
+	np = find_type_devices("open-pic");
+	while(np) {
+		if (np->parent && !strcmp(np->parent->name, "u3"))
+			irqctrler2 = np;
+		else
+			irqctrler = np;
+		np = np->next;
+	}
 	if (irqctrler != NULL)
 	{
-		printk("PowerMac using OpenPIC irq controller\n");
 		if (irqctrler->n_addrs > 0)
 		{
-			unsigned char senses[NR_IRQS];
+			unsigned char senses[128];
+
+			printk(KERN_INFO "PowerMac using OpenPIC irq controller at 0x%08x\n",
+			       irqctrler->addrs[0].address);
 
-			prom_get_irq_senses(senses, 0, NR_IRQS);
+			prom_get_irq_senses(senses, 0, 128);
 			OpenPIC_InitSenses = senses;
-			OpenPIC_NumInitSenses = NR_IRQS;
+			OpenPIC_NumInitSenses = 128;
 			ppc_md.get_irq = openpic_get_irq;
+			pmac_call_feature(PMAC_FTR_ENABLE_MPIC, irqctrler, 0, 0);
 			OpenPIC_Addr = ioremap(irqctrler->addrs[0].address,
 					       irqctrler->addrs[0].size);
 			openpic_init(0);
+
+#ifdef CONFIG_POWER4
+			if (irqctrler2 != NULL && irqctrler2->n_intrs > 0 &&
+			    irqctrler2->n_addrs > 0) {
+				printk(KERN_INFO "Slave OpenPIC at 0x%08x hooked on IRQ %d\n",
+				       irqctrler2->addrs[0].address,
+				       irqctrler2->intrs[0].line);
+				pmac_call_feature(PMAC_FTR_ENABLE_MPIC, irqctrler2, 0, 0);
+				OpenPIC2_Addr = ioremap(irqctrler2->addrs[0].address,
+							irqctrler2->addrs[0].size);
+				prom_get_irq_senses(senses, PMAC_OPENPIC2_OFFSET,
+						    PMAC_OPENPIC2_OFFSET+128);
+				OpenPIC_InitSenses = senses;
+				OpenPIC_NumInitSenses = 128;
+				openpic2_init(PMAC_OPENPIC2_OFFSET);
+				if (request_irq(irqctrler2->intrs[0].line, k2u3_action, 0,
+						"U3->K2 Cascade", NULL))
+					printk("Unable to get OpenPIC IRQ for cascade\n");
+			}
+#endif /* CONFIG_POWER4 */
+
 #ifdef CONFIG_XMON
 			{
 				struct device_node* pswitch;
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_setup.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_setup.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_setup.c	2003-09-26 23:31:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_setup.c	2003-11-01 01:36:52.000000000 +0000
@@ -332,7 +332,7 @@ pmac_setup_arch(void)
 
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
-	if (find_devices("uni-n"))
+	if (find_devices("uni-n") || find_devices("u3"))
 		ppc_md.smp_ops = &core99_smp_ops;
 	else
 		ppc_md.smp_ops = &psurge_smp_ops;
@@ -469,10 +469,6 @@ pmac_restart(char *cmd)
 	struct adb_request req;
 #endif /* CONFIG_ADB_CUDA */
 
-#ifdef CONFIG_NVRAM
-	pmac_nvram_update();
-#endif
-
 	switch (sys_ctrler) {
 #ifdef CONFIG_ADB_CUDA
 	case SYS_CTRLER_CUDA:
@@ -498,10 +494,6 @@ pmac_power_off(void)
 	struct adb_request req;
 #endif /* CONFIG_ADB_CUDA */
 
-#ifdef CONFIG_NVRAM
-	pmac_nvram_update();
-#endif
-
 	switch (sys_ctrler) {
 #ifdef CONFIG_ADB_CUDA
 	case SYS_CTRLER_CUDA:
@@ -637,11 +629,6 @@ pmac_init(unsigned long r3, unsigned lon
 	ppc_md.get_rtc_time   = pmac_get_rtc_time;
 	ppc_md.calibrate_decr = pmac_calibrate_decr;
 
-#ifdef CONFIG_NVRAM
-	ppc_md.nvram_read_val	= pmac_nvram_read_byte;
-	ppc_md.nvram_write_val	= pmac_nvram_write_byte;
-#endif
-
 	ppc_md.find_end_of_memory = pmac_find_end_of_memory;
 
 	ppc_md.feature_call   = pmac_do_feature_call;
@@ -685,6 +672,14 @@ pmac_declare_of_platform_devices(void)
 				break;
 			}
 	}
+	np = find_devices("u3");
+	if (np) {
+		for (np = np->child; np != NULL; np = np->sibling)
+			if (strncmp(np->name, "i2c", 3) == 0) {
+				of_platform_device_create(np, "u3-i2c");
+				break;
+			}
+	}
 
 	np = find_devices("valkyrie");
 	if (np)
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_smp.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_smp.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_smp.c	2003-10-11 14:13:41.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_smp.c	2003-11-20 23:56:36.000000000 +0000
@@ -119,8 +119,7 @@ static unsigned int core99_tb_gpio;
 /* Sync flag for HW tb sync */
 static volatile int sec_tb_reset = 0;
 
-static void __init
-core99_init_caches(int cpu)
+static void __init core99_init_caches(int cpu)
 {
 	if (!(cur_cpu_spec[0]->cpu_features & CPU_FTR_L2CR))
 		return;
@@ -188,8 +187,7 @@ static inline void psurge_clr_ipi(int cp
  */
 static unsigned long psurge_smp_message[NR_CPUS];
 
-void __pmac
-psurge_smp_message_recv(struct pt_regs *regs)
+void __pmac psurge_smp_message_recv(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
 	int msg;
@@ -206,15 +204,14 @@ psurge_smp_message_recv(struct pt_regs *
 			smp_message_recv(msg, regs);
 }
 
-irqreturn_t __pmac
-psurge_primary_intr(int irq, void *d, struct pt_regs *regs)
+irqreturn_t __pmac psurge_primary_intr(int irq, void *d, struct pt_regs *regs)
 {
 	psurge_smp_message_recv(regs);
 	return IRQ_HANDLED;
 }
 
-static void __pmac
-smp_psurge_message_pass(int target, int msg, unsigned long data, int wait)
+static void __pmac smp_psurge_message_pass(int target, int msg, unsigned long data,
+					   int wait)
 {
 	int i;
 
@@ -410,8 +407,7 @@ static void __init psurge_dual_sync_tb(i
 	smp_tb_synchronized = 1;
 }
 
-static void __init
-smp_psurge_setup_cpu(int cpu_nr)
+static void __init smp_psurge_setup_cpu(int cpu_nr)
 {
 
 	if (cpu_nr == 0) {
@@ -435,41 +431,54 @@ smp_psurge_setup_cpu(int cpu_nr)
 		psurge_dual_sync_tb(cpu_nr);
 }
 
-void __init
-smp_psurge_take_timebase(void)
+void __init smp_psurge_take_timebase(void)
 {
 	/* Dummy implementation */
 }
 
-void __init
-smp_psurge_give_timebase(void)
+void __init smp_psurge_give_timebase(void)
 {
 	/* Dummy implementation */
 }
 
-static int __init
-smp_core99_probe(void)
+static int __init smp_core99_probe(void)
 {
+#ifdef CONFIG_6xx
 	extern int powersave_nap;
-	struct device_node *cpus;
-	int i, ncpus = 1;
+#endif
+	struct device_node *cpus, *firstcpu;
+	int i, ncpus = 0, boot_cpu = -1;
 	u32 *tbprop;
 
 	if (ppc_md.progress) ppc_md.progress("smp_core99_probe", 0x345);
-	cpus = find_type_devices("cpu");
-	if (cpus == NULL)
-		return 0;
-
-	tbprop = (u32 *)get_property(cpus, "timebase-enable", NULL);
-	if (tbprop)
-		core99_tb_gpio = *tbprop;
-	else
-		core99_tb_gpio = KL_GPIO_TB_ENABLE;
+	cpus = firstcpu = find_type_devices("cpu");
+	while(cpus != NULL) {
+		u32 *regprop = (u32 *)get_property(cpus, "reg", NULL);
+		char *stateprop = (char *)get_property(cpus, "state", NULL);
+		if (regprop != NULL && stateprop != NULL &&
+		    !strncmp(stateprop, "running", 7))
+			boot_cpu = *regprop;
+		++ncpus;
+		cpus = cpus->next;
+	}
+	if (boot_cpu == -1)
+		printk(KERN_WARNING "Couldn't detect boot CPU !\n");
+	if (boot_cpu != 0)
+		printk(KERN_WARNING "Boot CPU is %d, unsupported setup !\n", boot_cpu);
 
-       	while ((cpus = cpus->next) != NULL)
-	       	++ncpus;
+	if (machine_is_compatible("MacRISC4")) {
+		extern struct smp_ops_t core99_smp_ops;
 
-	printk("smp_core99_probe: found %d cpus\n", ncpus);
+		core99_smp_ops.take_timebase = smp_generic_take_timebase;
+		core99_smp_ops.give_timebase = smp_generic_give_timebase;
+	} else {
+		if (firstcpu != NULL)
+			tbprop = (u32 *)get_property(firstcpu, "timebase-enable", NULL);
+		if (tbprop)
+			core99_tb_gpio = *tbprop;
+		else
+			core99_tb_gpio = KL_GPIO_TB_ENABLE;
+	}
 
 	if (ncpus > 1) {
 		openpic_request_IPIs();
@@ -484,8 +493,7 @@ smp_core99_probe(void)
 	return ncpus;
 }
 
-static void __init
-smp_core99_kick_cpu(int nr)
+static void __init smp_core99_kick_cpu(int nr)
 {
 	unsigned long save_vector, new_vector;
 	unsigned long flags;
@@ -539,23 +547,31 @@ smp_core99_kick_cpu(int nr)
 	if (ppc_md.progress) ppc_md.progress("smp_core99_kick_cpu done", 0x347);
 }
 
-static void __init
-smp_core99_setup_cpu(int cpu_nr)
+static void __init smp_core99_setup_cpu(int cpu_nr)
 {
-	/* Setup some registers */
+	/* Setup L2/L3 */
 	if (cpu_nr != 0)
 		core99_init_caches(cpu_nr);
 
 	/* Setup openpic */
 	do_openpic_setup_cpu();
 
-	/* Setup L2/L3 */
-	if (cpu_nr == 0)
+	if (cpu_nr == 0) {
+#ifdef CONFIG_POWER4
+		extern void g5_phy_disable_cpu1(void);
+
+		/* If we didn't start the second CPU, we must take
+		 * it off the bus
+		 */
+		if (machine_is_compatible("MacRISC4") &&
+		    num_online_cpus() < 2)		
+			g5_phy_disable_cpu1();
+#endif /* CONFIG_POWER4 */
 		if (ppc_md.progress) ppc_md.progress("core99_setup_cpu 0 done", 0x349);
+	}
 }
 
-void __init
-smp_core99_take_timebase(void)
+void __init smp_core99_take_timebase(void)
 {
 	/* Secondary processor "takes" the timebase by freezing
 	 * it, resetting its local TB and telling CPU 0 to go on
@@ -572,8 +588,7 @@ smp_core99_take_timebase(void)
        	sec_tb_reset = 1;
 }
 
-void __init
-smp_core99_give_timebase(void)
+void __init smp_core99_give_timebase(void)
 {
 	unsigned int t;
 
diff -purN /dev/shm/linux-2.5/arch/ppc/platforms/pmac_time.c linuxppc-2.5-benh/arch/ppc/platforms/pmac_time.c
--- /dev/shm/linux-2.5/arch/ppc/platforms/pmac_time.c	2003-10-11 14:15:21.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/platforms/pmac_time.c	2003-11-17 01:29:49.000000000 +0000
@@ -266,6 +266,14 @@ pmac_calibrate_decr(void)
 		if (via_calibrate_decr())
 			return;
 
+	/* Special case: QuickSilver G4s seem to have a badly calibrated
+	 * timebase-frequency in OF, VIA is much better on these. We should
+	 * probably implement calibration based on the KL timer on these
+	 * machines anyway... -BenH
+	 */
+	if (machine_is_compatible("PowerMac3,5"))
+		if (via_calibrate_decr())
+			return;
 	/*
 	 * The cpu node should have a timebase-frequency property
 	 * to tell us the rate at which the decrementer counts.
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/Makefile linuxppc-2.5-benh/arch/ppc/syslib/Makefile
--- /dev/shm/linux-2.5/arch/ppc/syslib/Makefile	2004-02-04 05:28:09.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/Makefile	2004-02-05 10:07:32.000000000 +0000
@@ -20,6 +20,9 @@ obj-$(CONFIG_4xx)		+= ppc4xx_pic.o
 obj-$(CONFIG_40x)		+= ppc4xx_setup.o
 obj-$(CONFIG_GEN_RTC)		+= todc_time.o
 obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
+obj-$(CONFIG_PPC4xx_EDMA)	+= ppc4xx_sgdma.o
+obj-$(CONFIG_STBXXX_DMA)	+= ppc4xx_stbdma.o
+obj-$(CONFIG_PPC4xx_DMA)	+= ppc4xx_dma.o
 ifeq ($(CONFIG_40x),y)
 obj-$(CONFIG_KGDB)		+= ppc4xx_kgdb.o
 obj-$(CONFIG_PCI)		+= indirect_pci.o pci_auto.o ppc405_pci.o
@@ -31,6 +34,7 @@ obj-$(CONFIG_PCI)		+= qspan_pci.o i8259.
 endif
 obj-$(CONFIG_PPC_OF)		+= prom_init.o prom.o of_device.o
 obj-$(CONFIG_PPC_PMAC)		+= open_pic.o indirect_pci.o
+obj-$(CONFIG_POWER4)		+= open_pic2.o
 obj-$(CONFIG_PPC_CHRP)		+= open_pic.o indirect_pci.o i8259.o
 obj-$(CONFIG_PPC_PREP)		+= open_pic.o indirect_pci.o i8259.o
 obj-$(CONFIG_ADIR)		+= i8259.o indirect_pci.o pci_auto.o \
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/cpc700.h linuxppc-2.5-benh/arch/ppc/syslib/cpc700.h
--- /dev/shm/linux-2.5/arch/ppc/syslib/cpc700.h	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/cpc700.h	2003-09-12 17:39:40.000000000 +0000
@@ -17,13 +17,14 @@
  * memory controller, PIC, UARTs, IIC, and Timers.
  */
 
-#ifndef	_ASMPPC_CPC700_H
-#define	_ASMPPC_CPC700_H
+#ifndef	__PPC_SYSLIB_CPC700_H__
+#define	__PPC_SYSLIB_CPC700_H__
 
 #include <linux/stddef.h>
 #include <linux/types.h>
 #include <linux/init.h>
 
+/* XXX no barriers? not even any volatiles?  -- paulus */
 #define CPC700_OUT_32(a,d)  (*(u_int *)a = d)
 #define CPC700_IN_32(a)     (*(u_int *)a)
 
@@ -33,21 +34,26 @@
 #define CPC700_PCI_CONFIG_ADDR          0xfec00000
 #define CPC700_PCI_CONFIG_DATA          0xfec00004
 
-#define CPC700_PMM0_LOCAL		0xff400000
-#define CPC700_PMM0_MASK_ATTR		0xff400004
-#define CPC700_PMM0_PCI_LOW		0xff400008
-#define CPC700_PMM0_PCI_HIGH		0xff40000c
+/* CPU -> PCI memory window 0 */
+#define CPC700_PMM0_LOCAL		0xff400000	/* CPU physical addr */
+#define CPC700_PMM0_MASK_ATTR		0xff400004	/* size and attrs */
+#define CPC700_PMM0_PCI_LOW		0xff400008	/* PCI addr, low word */
+#define CPC700_PMM0_PCI_HIGH		0xff40000c	/* PCI addr, high wd */
+/* CPU -> PCI memory window 1 */
 #define CPC700_PMM1_LOCAL		0xff400010
 #define CPC700_PMM1_MASK_ATTR		0xff400014
 #define CPC700_PMM1_PCI_LOW		0xff400018
 #define CPC700_PMM1_PCI_HIGH		0xff40001c
+/* CPU -> PCI memory window 2 */
 #define CPC700_PMM2_LOCAL		0xff400020
 #define CPC700_PMM2_MASK_ATTR		0xff400024
 #define CPC700_PMM2_PCI_LOW		0xff400028
 #define CPC700_PMM2_PCI_HIGH		0xff40002c
-#define CPC700_PTM1_MEMSIZE		0xff400030
-#define CPC700_PTM1_LOCAL		0xff400034
-#define CPC700_PTM2_MEMSIZE		0xff400038
+/* PCI memory -> CPU window 1 */
+#define CPC700_PTM1_MEMSIZE		0xff400030	/* window size */
+#define CPC700_PTM1_LOCAL		0xff400034	/* CPU phys addr */
+/* PCI memory -> CPU window 2 */
+#define CPC700_PTM2_MEMSIZE		0xff400038	/* size and enable */
 #define CPC700_PTM2_LOCAL		0xff40003c
 
 /*
@@ -89,4 +95,4 @@ extern unsigned int cpc700_irq_assigns[3
 extern void __init cpc700_init_IRQ(void);
 extern int cpc700_get_irq(struct pt_regs *);
 
-#endif	/* _ASMPPC_CPC700_H */
+#endif	/* __PPC_SYSLIB_CPC700_H__ */
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/of_device.c linuxppc-2.5-benh/arch/ppc/syslib/of_device.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/of_device.c	2003-10-11 14:17:31.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/of_device.c	2003-11-14 08:30:40.000000000 +0000
@@ -183,6 +183,7 @@ void of_release_dev(struct device *dev)
 	struct of_device *ofdev;
 
         ofdev = to_of_device(dev);
+	of_node_put(ofdev->node);
 	kfree(ofdev);
 }
 
@@ -242,7 +243,7 @@ struct of_device* of_platform_device_cre
 		return NULL;
 	memset(dev, 0, sizeof(*dev));
 
-	dev->node = np;
+	dev->node = of_node_get(np);
 	dev->dma_mask = 0xffffffffUL;
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.parent = NULL;
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/open_pic.c linuxppc-2.5-benh/arch/ppc/syslib/open_pic.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/open_pic.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/open_pic.c	2004-01-29 04:53:40.000000000 +0000
@@ -610,12 +610,15 @@ void openpic_request_IPIs(void)
 
 void __devinit do_openpic_setup_cpu(void)
 {
+#ifdef CONFIG_IRQ_ALL_CPUS
  	int i;
-	u32 msk = 1 << smp_hw_index[smp_processor_id()];
-
+	u32 msk;
+#endif
 	spin_lock(&openpic_setup_lock);
 
 #ifdef CONFIG_IRQ_ALL_CPUS
+	msk = 1 << smp_hw_index[smp_processor_id()];
+
  	/* let the openpic know we want intrs. default affinity
  	 * is 0xffffffff until changed via /proc
  	 * That's how it's done on x86. If we want it differently, then
@@ -788,15 +791,25 @@ static void openpic_set_sense(u_int irq,
  */
 static void openpic_ack_irq(unsigned int irq_nr)
 {
+#ifdef __SLOW_VERSION__
 	openpic_disable_irq(irq_nr);
 	openpic_eoi();
+#else
+	if ((irq_desc[irq_nr].status & IRQ_LEVEL) == 0)
+		openpic_eoi();
+#endif
 }
 
 static void openpic_end_irq(unsigned int irq_nr)
 {
+#ifdef __SLOW_VERSION__
 	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))
 	    && irq_desc[irq_nr].action)
 		openpic_enable_irq(irq_nr);
+#else
+	if ((irq_desc[irq_nr].status & IRQ_LEVEL) != 0)
+		openpic_eoi();
+#endif
 }
 
 static void openpic_set_affinity(unsigned int irq_nr, unsigned long cpumask)
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/open_pic2.c linuxppc-2.5-benh/arch/ppc/syslib/open_pic2.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/open_pic2.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/open_pic2.c	2003-11-01 01:48:00.000000000 +0000
@@ -0,0 +1,716 @@
+/*
+ *  arch/ppc/kernel/open_pic.c -- OpenPIC Interrupt Handling
+ *
+ *  Copyright (C) 1997 Geert Uytterhoeven
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive
+ *  for more details.
+ *
+ *  This is a duplicate of open_pic.c that deals with U3s MPIC on
+ *  G5 PowerMacs. It's the same file except it's using big endian
+ *  register accesses
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <asm/ptrace.h>
+#include <asm/signal.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/prom.h>
+#include <asm/sections.h>
+#include <asm/open_pic.h>
+#include <asm/i8259.h>
+#include <asm/hardirq.h>
+
+#include "open_pic_defs.h"
+
+void *OpenPIC2_Addr;
+static volatile struct OpenPIC *OpenPIC2 = NULL;
+/*
+ * We define OpenPIC_InitSenses table thusly:
+ * bit 0x1: sense, 0 for edge and 1 for level.
+ * bit 0x2: polarity, 0 for negative, 1 for positive.
+ */
+extern  u_int OpenPIC_NumInitSenses;
+extern u_char *OpenPIC_InitSenses;
+extern int use_of_interrupt_tree;
+
+static u_int NumProcessors;
+static u_int NumSources;
+static int open_pic2_irq_offset;
+static volatile OpenPIC_Source *ISR[NR_IRQS];
+
+/* Global Operations */
+static void openpic2_disable_8259_pass_through(void);
+static void openpic2_set_priority(u_int pri);
+static void openpic2_set_spurious(u_int vector);
+
+/* Timer Interrupts */
+static void openpic2_inittimer(u_int timer, u_int pri, u_int vector);
+static void openpic2_maptimer(u_int timer, u_int cpumask);
+
+/* Interrupt Sources */
+static void openpic2_enable_irq(u_int irq);
+static void openpic2_disable_irq(u_int irq);
+static void openpic2_initirq(u_int irq, u_int pri, u_int vector, int polarity,
+			    int is_level);
+static void openpic2_mapirq(u_int irq, u_int cpumask, u_int keepmask);
+
+/*
+ * These functions are not used but the code is kept here
+ * for completeness and future reference.
+ */
+static void openpic2_reset(void);
+#ifdef notused
+static void openpic2_enable_8259_pass_through(void);
+static u_int openpic2_get_priority(void);
+static u_int openpic2_get_spurious(void);
+static void openpic2_set_sense(u_int irq, int sense);
+#endif /* notused */
+
+/*
+ * Description of the openpic for the higher-level irq code
+ */
+static void openpic2_end_irq(unsigned int irq_nr);
+static void openpic2_ack_irq(unsigned int irq_nr);
+
+struct hw_interrupt_type open_pic2 = {
+	" OpenPIC2 ",
+	NULL,
+	NULL,
+	openpic2_enable_irq,
+	openpic2_disable_irq,
+	openpic2_ack_irq,
+	openpic2_end_irq,
+};
+
+/*
+ *  Accesses to the current processor's openpic registers
+ *  On cascaded controller, this is only CPU 0
+ */
+#define THIS_CPU		Processor[0]
+#define DECL_THIS_CPU
+#define CHECK_THIS_CPU
+
+#if 1
+#define check_arg_ipi(ipi) \
+    if (ipi < 0 || ipi >= OPENPIC_NUM_IPI) \
+	printk("open_pic.c:%d: illegal ipi %d\n", __LINE__, ipi);
+#define check_arg_timer(timer) \
+    if (timer < 0 || timer >= OPENPIC_NUM_TIMERS) \
+	printk("open_pic.c:%d: illegal timer %d\n", __LINE__, timer);
+#define check_arg_vec(vec) \
+    if (vec < 0 || vec >= OPENPIC_NUM_VECTORS) \
+	printk("open_pic.c:%d: illegal vector %d\n", __LINE__, vec);
+#define check_arg_pri(pri) \
+    if (pri < 0 || pri >= OPENPIC_NUM_PRI) \
+	printk("open_pic.c:%d: illegal priority %d\n", __LINE__, pri);
+/*
+ * Print out a backtrace if it's out of range, since if it's larger than NR_IRQ's
+ * data has probably been corrupted and we're going to panic or deadlock later
+ * anyway --Troy
+ */
+extern unsigned long* _get_SP(void);
+#define check_arg_irq(irq) \
+    if (irq < open_pic2_irq_offset || irq >= NumSources+open_pic2_irq_offset \
+	|| ISR[irq - open_pic2_irq_offset] == 0) { \
+      printk("open_pic.c:%d: illegal irq %d\n", __LINE__, irq); \
+      /*print_backtrace(_get_SP());*/ }
+#define check_arg_cpu(cpu) \
+    if (cpu < 0 || cpu >= NumProcessors){ \
+	printk("open_pic2.c:%d: illegal cpu %d\n", __LINE__, cpu); \
+	/*print_backtrace(_get_SP());*/ }
+#else
+#define check_arg_ipi(ipi)	do {} while (0)
+#define check_arg_timer(timer)	do {} while (0)
+#define check_arg_vec(vec)	do {} while (0)
+#define check_arg_pri(pri)	do {} while (0)
+#define check_arg_irq(irq)	do {} while (0)
+#define check_arg_cpu(cpu)	do {} while (0)
+#endif
+
+static u_int openpic2_read(volatile u_int *addr)
+{
+	u_int val;
+
+	val = in_be32(addr);
+	return val;
+}
+
+static inline void openpic2_write(volatile u_int *addr, u_int val)
+{
+	out_be32(addr, val);
+}
+
+static inline u_int openpic2_readfield(volatile u_int *addr, u_int mask)
+{
+	u_int val = openpic2_read(addr);
+	return val & mask;
+}
+
+inline void openpic2_writefield(volatile u_int *addr, u_int mask,
+			       u_int field)
+{
+	u_int val = openpic2_read(addr);
+	openpic2_write(addr, (val & ~mask) | (field & mask));
+}
+
+static inline void openpic2_clearfield(volatile u_int *addr, u_int mask)
+{
+	openpic2_writefield(addr, mask, 0);
+}
+
+static inline void openpic2_setfield(volatile u_int *addr, u_int mask)
+{
+	openpic2_writefield(addr, mask, mask);
+}
+
+static void openpic2_safe_writefield(volatile u_int *addr, u_int mask,
+				    u_int field)
+{
+	openpic2_setfield(addr, OPENPIC_MASK);
+	while (openpic2_read(addr) & OPENPIC_ACTIVITY);
+	openpic2_writefield(addr, mask | OPENPIC_MASK, field | OPENPIC_MASK);
+}
+
+static void openpic2_reset(void)
+{
+	openpic2_setfield(&OpenPIC2->Global.Global_Configuration0,
+			 OPENPIC_CONFIG_RESET);
+	while (openpic2_readfield(&OpenPIC2->Global.Global_Configuration0,
+				 OPENPIC_CONFIG_RESET))
+		mb();
+}
+
+void __init openpic2_set_sources(int first_irq, int num_irqs, void *first_ISR)
+{
+	volatile OpenPIC_Source *src = first_ISR;
+	int i, last_irq;
+
+	last_irq = first_irq + num_irqs;
+	if (last_irq > NumSources)
+		NumSources = last_irq;
+	if (src == 0)
+		src = &((struct OpenPIC *)OpenPIC2_Addr)->Source[first_irq];
+	for (i = first_irq; i < last_irq; ++i, ++src)
+		ISR[i] = src;
+}
+
+/*
+ * The `offset' parameter defines where the interrupts handled by the
+ * OpenPIC start in the space of interrupt numbers that the kernel knows
+ * about.  In other words, the OpenPIC's IRQ0 is numbered `offset' in the
+ * kernel's interrupt numbering scheme.
+ * We assume there is only one OpenPIC.
+ */
+void __init openpic2_init(int offset)
+{
+	u_int t, i;
+	u_int timerfreq;
+	const char *version;
+
+	if (!OpenPIC2_Addr) {
+		printk("No OpenPIC2 found !\n");
+		return;
+	}
+	OpenPIC2 = (volatile struct OpenPIC *)OpenPIC2_Addr;
+
+	if (ppc_md.progress) ppc_md.progress("openpic: enter", 0x122);
+
+	t = openpic2_read(&OpenPIC2->Global.Feature_Reporting0);
+	switch (t & OPENPIC_FEATURE_VERSION_MASK) {
+	case 1:
+		version = "1.0";
+		break;
+	case 2:
+		version = "1.2";
+		break;
+	case 3:
+		version = "1.3";
+		break;
+	default:
+		version = "?";
+		break;
+	}
+	NumProcessors = ((t & OPENPIC_FEATURE_LAST_PROCESSOR_MASK) >>
+			 OPENPIC_FEATURE_LAST_PROCESSOR_SHIFT) + 1;
+	if (NumSources == 0)
+		openpic2_set_sources(0,
+				    ((t & OPENPIC_FEATURE_LAST_SOURCE_MASK) >>
+				     OPENPIC_FEATURE_LAST_SOURCE_SHIFT) + 1,
+				    NULL);
+	printk("OpenPIC (2) Version %s (%d CPUs and %d IRQ sources) at %p\n",
+	       version, NumProcessors, NumSources, OpenPIC2);
+	timerfreq = openpic2_read(&OpenPIC2->Global.Timer_Frequency);
+	if (timerfreq)
+		printk("OpenPIC timer frequency is %d.%06d MHz\n",
+		       timerfreq / 1000000, timerfreq % 1000000);
+
+	open_pic2_irq_offset = offset;
+
+	/* Initialize timer interrupts */
+	if ( ppc_md.progress ) ppc_md.progress("openpic2: timer",0x3ba);
+	for (i = 0; i < OPENPIC_NUM_TIMERS; i++) {
+		/* Disabled, Priority 0 */
+		openpic2_inittimer(i, 0, OPENPIC2_VEC_TIMER+i+offset);
+		/* No processor */
+		openpic2_maptimer(i, 0);
+	}
+
+	/* Initialize external interrupts */
+	if (ppc_md.progress) ppc_md.progress("openpic2: external",0x3bc);
+
+	openpic2_set_priority(0xf);
+
+	/* Init all external sources, including possibly the cascade. */
+	for (i = 0; i < NumSources; i++) {
+		int sense;
+
+		if (ISR[i] == 0)
+			continue;
+
+		/* the bootloader may have left it enabled (bad !) */
+		openpic2_disable_irq(i+offset);
+
+		sense = (i < OpenPIC_NumInitSenses)? OpenPIC_InitSenses[i]: \
+				(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE);
+
+		if (sense & IRQ_SENSE_MASK)
+			irq_desc[i+offset].status = IRQ_LEVEL;
+
+		/* Enabled, Priority 8 */
+		openpic2_initirq(i, 8, i+offset, (sense & IRQ_POLARITY_MASK),
+				(sense & IRQ_SENSE_MASK));
+		/* Processor 0 */
+		openpic2_mapirq(i, 1<<0, 0);
+	}
+
+	/* Init descriptors */
+	for (i = offset; i < NumSources + offset; i++)
+		irq_desc[i].handler = &open_pic2;
+
+	/* Initialize the spurious interrupt */
+	if (ppc_md.progress) ppc_md.progress("openpic2: spurious",0x3bd);
+	openpic2_set_spurious(OPENPIC2_VEC_SPURIOUS+offset);
+
+	openpic2_disable_8259_pass_through();
+	openpic2_set_priority(0);
+
+	if (ppc_md.progress) ppc_md.progress("openpic2: exit",0x222);
+}
+
+#ifdef notused
+static void openpic2_enable_8259_pass_through(void)
+{
+	openpic2_clearfield(&OpenPIC2->Global.Global_Configuration0,
+			   OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE);
+}
+#endif /* notused */
+
+/* This can't be __init, it is used in openpic_sleep_restore_intrs */
+static void openpic2_disable_8259_pass_through(void)
+{
+	openpic2_setfield(&OpenPIC2->Global.Global_Configuration0,
+			 OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE);
+}
+
+/*
+ *  Find out the current interrupt
+ */
+u_int openpic2_irq(void)
+{
+	u_int vec;
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	vec = openpic2_readfield(&OpenPIC2->THIS_CPU.Interrupt_Acknowledge,
+				OPENPIC_VECTOR_MASK);
+	return vec;
+}
+
+void openpic2_eoi(void)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	openpic2_write(&OpenPIC2->THIS_CPU.EOI, 0);
+	/* Handle PCI write posting */
+	(void)openpic2_read(&OpenPIC2->THIS_CPU.EOI);
+}
+
+#ifdef notused
+static u_int openpic2_get_priority(void)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	return openpic2_readfield(&OpenPIC2->THIS_CPU.Current_Task_Priority,
+				 OPENPIC_CURRENT_TASK_PRIORITY_MASK);
+}
+#endif /* notused */
+
+static void __init openpic2_set_priority(u_int pri)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	check_arg_pri(pri);
+	openpic2_writefield(&OpenPIC2->THIS_CPU.Current_Task_Priority,
+			   OPENPIC_CURRENT_TASK_PRIORITY_MASK, pri);
+}
+
+/*
+ *  Get/set the spurious vector
+ */
+#ifdef notused
+static u_int openpic2_get_spurious(void)
+{
+	return openpic2_readfield(&OpenPIC2->Global.Spurious_Vector,
+				 OPENPIC_VECTOR_MASK);
+}
+#endif /* notused */
+
+/* This can't be __init, it is used in openpic_sleep_restore_intrs */
+static void openpic2_set_spurious(u_int vec)
+{
+	check_arg_vec(vec);
+	openpic2_writefield(&OpenPIC2->Global.Spurious_Vector, OPENPIC_VECTOR_MASK,
+			   vec);
+}
+
+static spinlock_t openpic2_setup_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ *  Initialize a timer interrupt (and disable it)
+ *
+ *  timer: OpenPIC timer number
+ *  pri: interrupt source priority
+ *  vec: the vector it will produce
+ */
+static void __init openpic2_inittimer(u_int timer, u_int pri, u_int vec)
+{
+	check_arg_timer(timer);
+	check_arg_pri(pri);
+	check_arg_vec(vec);
+	openpic2_safe_writefield(&OpenPIC2->Global.Timer[timer].Vector_Priority,
+				OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK,
+				(pri << OPENPIC_PRIORITY_SHIFT) | vec);
+}
+
+/*
+ *  Map a timer interrupt to one or more CPUs
+ */
+static void __init openpic2_maptimer(u_int timer, u_int cpumask)
+{
+	check_arg_timer(timer);
+	openpic2_write(&OpenPIC2->Global.Timer[timer].Destination,
+		      cpumask);
+}
+
+/*
+ * Initalize the interrupt source which will generate an NMI.
+ * This raises the interrupt's priority from 8 to 9.
+ *
+ * irq: The logical IRQ which generates an NMI.
+ */
+void __init
+openpic2_init_nmi_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	openpic2_safe_writefield(&ISR[irq - open_pic2_irq_offset]->Vector_Priority,
+				OPENPIC_PRIORITY_MASK,
+				9 << OPENPIC_PRIORITY_SHIFT);
+}
+
+/*
+ *
+ * All functions below take an offset'ed irq argument
+ *
+ */
+
+
+/*
+ *  Enable/disable an external interrupt source
+ *
+ *  Externally called, irq is an offseted system-wide interrupt number
+ */
+static void openpic2_enable_irq(u_int irq)
+{
+	volatile u_int *vpp;
+
+	check_arg_irq(irq);
+	vpp = &ISR[irq - open_pic2_irq_offset]->Vector_Priority;
+       	openpic2_clearfield(vpp, OPENPIC_MASK);
+	/* make sure mask gets to controller before we return to user */
+       	do {
+       		mb(); /* sync is probably useless here */
+       	} while (openpic2_readfield(vpp, OPENPIC_MASK));
+}
+
+static void openpic2_disable_irq(u_int irq)
+{
+	volatile u_int *vpp;
+	u32 vp;
+
+	check_arg_irq(irq);
+	vpp = &ISR[irq - open_pic2_irq_offset]->Vector_Priority;
+	openpic2_setfield(vpp, OPENPIC_MASK);
+	/* make sure mask gets to controller before we return to user */
+	do {
+		mb();  /* sync is probably useless here */
+		vp = openpic2_readfield(vpp, OPENPIC_MASK | OPENPIC_ACTIVITY);
+	} while((vp & OPENPIC_ACTIVITY) && !(vp & OPENPIC_MASK));
+}
+
+
+/*
+ *  Initialize an interrupt source (and disable it!)
+ *
+ *  irq: OpenPIC interrupt number
+ *  pri: interrupt source priority
+ *  vec: the vector it will produce
+ *  pol: polarity (1 for positive, 0 for negative)
+ *  sense: 1 for level, 0 for edge
+ */
+static void __init
+openpic2_initirq(u_int irq, u_int pri, u_int vec, int pol, int sense)
+{
+	openpic2_safe_writefield(&ISR[irq]->Vector_Priority,
+				OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK |
+				OPENPIC_SENSE_MASK | OPENPIC_POLARITY_MASK,
+				(pri << OPENPIC_PRIORITY_SHIFT) | vec |
+				(pol ? OPENPIC_POLARITY_POSITIVE :
+			    		OPENPIC_POLARITY_NEGATIVE) |
+				(sense ? OPENPIC_SENSE_LEVEL : OPENPIC_SENSE_EDGE));
+}
+
+/*
+ *  Map an interrupt source to one or more CPUs
+ */
+static void openpic2_mapirq(u_int irq, u_int physmask, u_int keepmask)
+{
+	if (ISR[irq] == 0)
+		return;
+	if (keepmask != 0)
+		physmask |= openpic2_read(&ISR[irq]->Destination) & keepmask;
+	openpic2_write(&ISR[irq]->Destination, physmask);
+}
+
+#ifdef notused
+/*
+ *  Set the sense for an interrupt source (and disable it!)
+ *
+ *  sense: 1 for level, 0 for edge
+ */
+static void openpic2_set_sense(u_int irq, int sense)
+{
+	if (ISR[irq] != 0)
+		openpic2_safe_writefield(&ISR[irq]->Vector_Priority,
+					OPENPIC_SENSE_LEVEL,
+					(sense ? OPENPIC_SENSE_LEVEL : 0));
+}
+#endif /* notused */
+
+/* No spinlocks, should not be necessary with the OpenPIC
+ * (1 register = 1 interrupt and we have the desc lock).
+ */
+static void openpic2_ack_irq(unsigned int irq_nr)
+{
+	openpic2_disable_irq(irq_nr);
+	openpic2_eoi();
+}
+
+static void openpic2_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		openpic2_enable_irq(irq_nr);
+}
+
+int
+openpic2_get_irq(struct pt_regs *regs)
+{
+	int irq = openpic2_irq();
+
+	if (irq == (OPENPIC2_VEC_SPURIOUS + open_pic2_irq_offset))
+		irq = -1;
+	return irq;
+}
+
+#ifdef CONFIG_PM
+
+/*
+ * We implement the IRQ controller as a sysdev and put it
+ * to sleep at powerdown stage (the callback is named suspend,
+ * but it's old semantics, for the Device Model, it's really
+ * powerdown). The possible problem is that another sysdev that
+ * happens to be suspend after this one will have interrupts off,
+ * that may be an issue... For now, this isn't an issue on pmac
+ * though...
+ */
+
+static u32 save_ipi_vp[OPENPIC_NUM_IPI];
+static u32 save_irq_src_vp[OPENPIC_MAX_SOURCES];
+static u32 save_irq_src_dest[OPENPIC_MAX_SOURCES];
+static u32 save_cpu_task_pri[OPENPIC_MAX_PROCESSORS];
+static int openpic_suspend_count;
+
+static void openpic2_cached_enable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic2_irq_offset] &= ~OPENPIC_MASK;
+}
+
+static void openpic2_cached_disable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic2_irq_offset] |= OPENPIC_MASK;
+}
+
+/* WARNING: Can be called directly by the cpufreq code with NULL parameter,
+ * we need something better to deal with that... Maybe switch to S1 for
+ * cpufreq changes
+ */
+int openpic2_suspend(struct sys_device *sysdev, u32 state)
+{
+	int	i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&openpic2_setup_lock, flags);
+
+	if (openpic_suspend_count++ > 0) {
+		spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+		return 0;
+	}
+
+	open_pic2.enable = openpic2_cached_enable_irq;
+	open_pic2.disable = openpic2_cached_disable_irq;
+
+	for (i=0; i<NumProcessors; i++) {
+		save_cpu_task_pri[i] = openpic2_read(&OpenPIC2->Processor[i].Current_Task_Priority);
+		openpic2_writefield(&OpenPIC2->Processor[i].Current_Task_Priority,
+				   OPENPIC_CURRENT_TASK_PRIORITY_MASK, 0xf);
+	}
+
+	for (i=0; i<OPENPIC_NUM_IPI; i++)
+		save_ipi_vp[i] = openpic2_read(&OpenPIC2->Global.IPI_Vector_Priority(i));
+	for (i=0; i<NumSources; i++) {
+		if (ISR[i] == 0)
+			continue;
+		save_irq_src_vp[i] = openpic2_read(&ISR[i]->Vector_Priority) & ~OPENPIC_ACTIVITY;
+		save_irq_src_dest[i] = openpic2_read(&ISR[i]->Destination);
+	}
+
+	spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+
+	return 0;
+}
+
+/* WARNING: Can be called directly by the cpufreq code with NULL parameter,
+ * we need something better to deal with that... Maybe switch to S1 for
+ * cpufreq changes
+ */
+int openpic2_resume(struct sys_device *sysdev)
+{
+	int		i;
+	unsigned long	flags;
+	u32		vppmask =	OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK |
+					OPENPIC_SENSE_MASK | OPENPIC_POLARITY_MASK |
+					OPENPIC_MASK;
+
+	spin_lock_irqsave(&openpic2_setup_lock, flags);
+
+	if ((--openpic_suspend_count) > 0) {
+		spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+		return 0;
+	}
+
+	openpic2_reset();
+
+	/* OpenPIC sometimes seem to need some time to be fully back up... */
+	do {
+		openpic2_set_spurious(OPENPIC2_VEC_SPURIOUS+open_pic2_irq_offset);
+	} while(openpic2_readfield(&OpenPIC2->Global.Spurious_Vector, OPENPIC_VECTOR_MASK)
+			!= (OPENPIC2_VEC_SPURIOUS + open_pic2_irq_offset));
+	
+	openpic2_disable_8259_pass_through();
+
+	for (i=0; i<OPENPIC_NUM_IPI; i++)
+		openpic2_write(&OpenPIC2->Global.IPI_Vector_Priority(i),
+			      save_ipi_vp[i]);
+	for (i=0; i<NumSources; i++) {
+		if (ISR[i] == 0)
+			continue;
+		openpic2_write(&ISR[i]->Destination, save_irq_src_dest[i]);
+		openpic2_write(&ISR[i]->Vector_Priority, save_irq_src_vp[i]);
+		/* make sure mask gets to controller before we return to user */
+		do {
+			openpic2_write(&ISR[i]->Vector_Priority, save_irq_src_vp[i]);
+		} while (openpic2_readfield(&ISR[i]->Vector_Priority, vppmask)
+			 != (save_irq_src_vp[i] & vppmask));
+	}
+	for (i=0; i<NumProcessors; i++)
+		openpic2_write(&OpenPIC2->Processor[i].Current_Task_Priority,
+			      save_cpu_task_pri[i]);
+
+	open_pic2.enable = openpic2_enable_irq;
+	open_pic2.disable = openpic2_disable_irq;
+
+	spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+/* HACK ALERT */
+static struct sysdev_class openpic2_sysclass = {
+	set_kset_name("openpic2"),
+};
+
+static struct sys_device device_openpic2 = {
+	.id		= 0,
+	.cls		= &openpic2_sysclass,
+};
+
+static struct sysdev_driver driver_openpic2 = {
+#ifdef CONFIG_PM
+	.suspend	= &openpic2_suspend,
+	.resume		= &openpic2_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init init_openpic2_sysfs(void)
+{
+	int rc;
+
+	if (!OpenPIC2_Addr)
+		return -ENODEV;
+	printk(KERN_DEBUG "Registering openpic2 with sysfs...\n");
+	rc = sysdev_class_register(&openpic2_sysclass);
+	if (rc) {
+		printk(KERN_ERR "Failed registering openpic sys class\n");
+		return -ENODEV;
+	}
+	rc = sys_device_register(&device_openpic2);
+	if (rc) {
+		printk(KERN_ERR "Failed registering openpic sys device\n");
+		return -ENODEV;
+	}
+	rc = sysdev_driver_register(&openpic2_sysclass, &driver_openpic2);
+	if (rc) {
+		printk(KERN_ERR "Failed registering openpic sys driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+subsys_initcall(init_openpic2_sysfs);
+
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_dma.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_dma.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_dma.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_dma.c	2003-09-12 17:45:00.000000000 +0000
@@ -1,42 +1,586 @@
 /*
- * Author: Pete Popov <ppopov@mvista.com> or source@mvista.com
+ * arch/ppc/kernel/ppc4xx_dma.c
  *
- * arch/ppc/kernel/ppc405_dma.c
+ * IBM PPC4xx DMA engine core library
  *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
+ * Copyright 2000-2003 MontaVista Software Inc.
  *
- * IBM 405 DMA Controller Functions
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/config.h>
 #include <linux/kernel.h>
-#include <asm/system.h>
-#include <asm/io.h>
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/init.h>
 #include <linux/module.h>
 
-#include <asm/ppc405_dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+ppc_dma_ch_t dma_channels[MAX_PPC4xx_DMA_CHANNELS];
+
+int
+ppc4xx_get_dma_status(void)
+{
+	return (mfdcr(DCRN_DMASR));
+}
+
+void
+ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH0, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA0, (u32)src_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH1, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA1, (u32)src_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH2, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA2, (u32)src_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMASAH3, (u32)(src_addr >> 32));
+#endif
+			mtdcr(DCRN_DMASA3, (u32)src_addr);
+			break;
+		default:
+			if (dmanr >= MAX_PPC4xx_DMA_CHANNELS)
+				printk("set_src_addr: bad channel: %d\n", dmanr);
+	}
+}
+
+void
+ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH0, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA0, (u32)dst_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH1, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA1, (u32)dst_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH2, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA2, (u32)dst_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_DMADAH3, (u32)(dst_addr >> 32));
+#endif
+			mtdcr(DCRN_DMADA3, (u32)dst_addr);
+			break;
+		default:
+			if (dmanr >= MAX_PPC4xx_DMA_CHANNELS)
+				printk("set_dst_addr: bad channel: %d\n", dmanr);
+	}
+}
+
+
+void
+ppc4xx_enable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	unsigned int status_bits[] = { DMA_CS0 | DMA_TS0 | DMA_CH0_ERR,
+				       DMA_CS1 | DMA_TS1 | DMA_CH1_ERR,
+				       DMA_CS2 | DMA_TS2 | DMA_CH2_ERR,
+				       DMA_CS3 | DMA_TS3 | DMA_CH3_ERR};
+
+	if (p_dma_ch->in_use) {
+		printk("enable_dma: channel %d in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("enable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	if (p_dma_ch->mode == DMA_MODE_READ) {
+		/* peripheral to memory */
+		ppc4xx_set_src_addr(dmanr, 0);
+		ppc4xx_set_dst_addr(dmanr, p_dma_ch->addr);
+	} else if (p_dma_ch->mode == DMA_MODE_WRITE) {
+		/* memory to peripheral */
+		ppc4xx_set_src_addr(dmanr, p_dma_ch->addr);
+		ppc4xx_set_dst_addr(dmanr, 0);
+	}
+
+	/* for other xfer modes, the addresses are already set */
+	switch (dmanr) {
+		case 0:
+			control = mfdcr(DCRN_DMACR0);
+			break;
+		case 1:
+			control = mfdcr(DCRN_DMACR1);
+			break;
+		case 2:
+			control = mfdcr(DCRN_DMACR2);
+			break;
+		case 3:
+			control = mfdcr(DCRN_DMACR3);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	control &= ~(DMA_TM_MASK | DMA_TD);	/* clear all mode bits */
+	if (p_dma_ch->mode == DMA_MODE_MM) {
+		/* software initiated memory to memory */
+		control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+	}
+
+	switch (dmanr) {
+		case 0:
+			mtdcr(DCRN_DMACR0, control);
+			break;
+		case 1:
+			mtdcr(DCRN_DMACR1, control);
+			break;
+		case 2:
+			mtdcr(DCRN_DMACR2, control);
+			break;
+		case 3:
+			mtdcr(DCRN_DMACR3, control);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	/*
+	 * Clear the CS, TS, RI bits for the channel from DMASR.  This
+	 * has been observed to happen correctly only after the mode and
+	 * ETD/DCE bits in DMACRx are set above.  Must do this before
+	 * enabling the channel.
+	 */
+
+	mtdcr(DCRN_DMASR, status_bits[dmanr]);
+
+	/*
+	 * For device-paced transfers, Terminal Count Enable apparently
+	 * must be on, and this must be turned on after the mode, etc.
+	 * bits are cleared above (at least on Redwood-6).
+	 */
+
+	if ((p_dma_ch->mode == DMA_MODE_MM_DEVATDST) ||
+	    (p_dma_ch->mode == DMA_MODE_MM_DEVATSRC))
+		control |= DMA_TCE_ENABLE;
+
+	/*
+	 * Now enable the channel.
+	 */
+
+	control |= (p_dma_ch->mode | DMA_CE_ENABLE);
+
+	switch (dmanr) {
+		case 0:
+			mtdcr(DCRN_DMACR0, control);
+			break;
+		case 1:
+			mtdcr(DCRN_DMACR1, control);
+			break;
+		case 2:
+			mtdcr(DCRN_DMACR2, control);
+			break;
+		case 3:
+			mtdcr(DCRN_DMACR3, control);
+			break;
+		default:
+			printk("enable_dma: bad channel: %d\n", dmanr);
+	}
+
+	p_dma_ch->in_use = 1;
+}
+
+void
+ppc4xx_disable_dma(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (!p_dma_ch->in_use) {
+		printk("disable_dma: channel %d not in use\n", dmanr);
+		return;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("disable_dma: bad channel: %d\n", dmanr);
+		return;
+	}
+
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control &= ~DMA_CE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("disable_dma: bad channel: %d\n", dmanr);
+	}
+
+	p_dma_ch->in_use = 0;
+}
+
+/*
+ * Sets the dma mode for single DMA transfers only.
+ * For scatter/gather transfers, the mode is passed to the
+ * alloc_dma_handle() function as one of the parameters.
+ *
+ * The mode is simply saved and used later.  This allows
+ * the driver to call set_dma_mode() and set_dma_addr() in
+ * any order.
+ *
+ * Valid mode values are:
+ *
+ * DMA_MODE_READ          peripheral to memory
+ * DMA_MODE_WRITE         memory to peripheral
+ * DMA_MODE_MM            memory to memory
+ * DMA_MODE_MM_DEVATSRC   device-paced memory to memory, device at src
+ * DMA_MODE_MM_DEVATDST   device-paced memory to memory, device at dst
+ */
+int
+ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("set_dma_mode: bad channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch->mode = mode;
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Sets the DMA Count register. Note that 'count' is in bytes.
+ * However, the DMA Count register counts the number of "transfers",
+ * where each transfer is equal to the bus width.  Thus, count
+ * MUST be a multiple of the bus width.
+ */
+void
+ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (count & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (count & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (count & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("set_dma_count: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk
+			    ("Warning: set_dma_count count 0x%x bus width %d\n",
+			     count, p_dma_ch->pwidth);
+	}
+#endif
+
+	count = count >> p_dma_ch->shift;
+	switch (dmanr) {
+	case 0:
+		mtdcr(DCRN_DMACT0, count);
+		break;
+	case 1:
+		mtdcr(DCRN_DMACT1, count);
+		break;
+	case 2:
+		mtdcr(DCRN_DMACT2, count);
+		break;
+	case 3:
+		mtdcr(DCRN_DMACT3, count);
+		break;
+	default:
+		printk("ppc4xx_set_dma_count: bad channel: %d\n", dmanr);
+	}
+}
+
+/*
+ *   Returns the number of bytes left to be transfered.
+ *   After a DMA transfer, this should return zero.
+ *   Reading this while a DMA transfer is still in progress will return
+ *   unpredictable results.
+ */
+int
+ppc4xx_get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	switch (dmanr) {
+	case 0:
+		count = mfdcr(DCRN_DMACT0);
+		break;
+	case 1:
+		count = mfdcr(DCRN_DMACT1);
+		break;
+	case 2:
+		count = mfdcr(DCRN_DMACT2);
+		break;
+	case 3:
+		count = mfdcr(DCRN_DMACT3);
+		break;
+	default:
+		printk("ppc4xx_get_dma_residue: bad channel: %d\n", dmanr);
+		return 0;
+	}
+
+	return (count << p_dma_ch->shift);
+}
+
+/*
+ * Sets the DMA address for a memory to peripheral or peripheral
+ * to memory transfer.  The address is just saved in the channel
+ * structure for now and used later in enable_dma().
+ */
+void
+ppc4xx_set_dma_addr(unsigned int dmanr, phys_addr_t addr)
+{
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr: bad channel: %d\n", dmanr);
+		return;
+	}
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if ((unsigned) addr & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if ((unsigned) addr & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if ((unsigned) addr & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_set_dma_addr: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return;
+		}
+		if (error)
+			printk("Warning: ppc4xx_set_dma_addr addr 0x%x bus width %d\n",
+			       addr, p_dma_ch->pwidth);
+	}
+#endif
+
+	/* save dma address and program it later after we know the xfer mode */
+	p_dma_ch->addr = addr;
+}
+
+/*
+ * Sets both DMA addresses for a memory to memory transfer.
+ * For memory to peripheral or peripheral to memory transfers
+ * the function set_dma_addr() should be used instead.
+ */
+void
+ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+		     phys_addr_t dst_dma_addr)
+{
+#ifdef DEBUG_4xxDMA
+	{
+		ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+		int error = 0;
+		switch (p_dma_ch->pwidth) {
+			case PW_8:
+				break;
+			case PW_16:
+				if (((unsigned) src_dma_addr & 0x1) ||
+						((unsigned) dst_dma_addr & 0x1)
+				   )
+					error = 1;
+				break;
+			case PW_32:
+				if (((unsigned) src_dma_addr & 0x3) ||
+						((unsigned) dst_dma_addr & 0x3)
+				   )
+					error = 1;
+				break;
+			case PW_64:
+				if (((unsigned) src_dma_addr & 0x7) ||
+						((unsigned) dst_dma_addr & 0x7)
+				   )
+					error = 1;
+				break;
+			default:
+				printk("ppc4xx_set_dma_addr2: invalid bus width: 0x%x\n",
+						p_dma_ch->pwidth);
+				return;
+		}
+		if (error)
+			printk
+				("Warning: ppc4xx_set_dma_addr2 src 0x%x dst 0x%x bus width %d\n",
+				 src_dma_addr, dst_dma_addr, p_dma_ch->pwidth);
+	}
+#endif
 
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_set_dma_addr2: bad channel: %d\n", dmanr);
+	}
+	else {
+		ppc4xx_set_src_addr(dmanr, src_dma_addr);
+		ppc4xx_set_dst_addr(dmanr, dst_dma_addr);
+	}
+}
 
 /*
- * Function prototypes
+ * Enables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be enabled, if
+ * they were previously disabled.
  */
+int
+ppc4xx_enable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 
-int hw_init_dma_channel(unsigned int,  ppc_dma_ch_t *);
-int init_dma_channel(unsigned int);
-int get_channel_config(unsigned int, ppc_dma_ch_t *);
-int set_channel_priority(unsigned int, unsigned int);
-unsigned int get_peripheral_width(unsigned int);
-int alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
-void free_dma_handle(sgl_handle_t);
+	p_dma_ch->int_enable = 1;
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control |= DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control |= DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_enable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
+/*
+ * Disables the channel interrupt.
+ *
+ * If performing a scatter/gatter transfer, this function
+ * MUST be called before calling alloc_dma_handle() and building
+ * the sgl list.  Otherwise, interrupts will not be disabled, if
+ * they were previously enabled.
+ */
+int
+ppc4xx_disable_dma_interrupt(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
 
-ppc_dma_ch_t dma_channels[MAX_405GP_DMA_CHANNELS];
+	p_dma_ch->int_enable = 0;
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control &= ~DMA_CIE_ENABLE;	/* Channel Interrupt Enable */
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control &= ~DMA_CIE_ENABLE;
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_disable_dma_interrupt: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Configures a DMA channel, including the peripheral bus width, if a
@@ -47,166 +591,155 @@ ppc_dma_ch_t dma_channels[MAX_405GP_DMA_
  * called from platform specific init code.  The driver should not need to
  * call this function.
  */
-int hw_init_dma_channel(unsigned int dmanr,  ppc_dma_ch_t *p_init)
+int
+ppc4xx_init_dma_channel(unsigned int dmanr, ppc_dma_ch_t * p_init)
 {
-    unsigned int polarity;
-    uint32_t control = 0;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-
-#ifdef DEBUG_405DMA
-    if (!p_init) {
-        printk("hw_init_dma_channel: NULL p_init\n");
-        return DMA_STATUS_NULL_POINTER;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("hw_init_dma_channel: bad channel %d\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
+	unsigned int polarity;
+	uint32_t control = 0;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	DMA_MODE_READ = (unsigned long) DMA_TD;	/* Peripheral to Memory */
+	DMA_MODE_WRITE = 0;	/* Memory to Peripheral */
+
+	if (!p_init) {
+		printk("ppc4xx_init_dma_channel: NULL p_init\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_init_dma_channel: bad channel %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    /* Setup the control register based on the values passed to
-     * us in p_init.  Then, over-write the control register with this
-     * new value.
-     */
-
-    control |= (
-                SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */
-                SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */
-                SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */
-                SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */
-                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */
-                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */
-                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */
-                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */
-                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */
-                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */
-                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */
-                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */
-                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */
-                );
-
-    switch (dmanr) {
-        case 0:
-            /* clear all polarity signals and then "or" in new signal levels */
-            polarity &= ~(DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+	/* Setup the control register based on the values passed to
+	 * us in p_init.  Then, over-write the control register with this
+	 * new value.
+	 */
+	control |= SET_DMA_CONTROL;
+
+	switch (dmanr) {
+	case 0:
+		/* clear all polarity signals and then "or" in new signal levels */
+		polarity &= ~GET_DMA_POLARITY(0);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            polarity &= ~(DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		polarity &= ~GET_DMA_POLARITY(1);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            polarity &= ~(DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		polarity &= ~GET_DMA_POLARITY(2);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            polarity &= ~(DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            polarity |= p_dma_ch->polarity;
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		polarity &= ~GET_DMA_POLARITY(3);
+		polarity |= p_dma_ch->polarity;
 #if DCRN_POL > 0
-            mtdcr(DCRN_POL, polarity);
+		mtdcr(DCRN_POL, polarity);
 #endif
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    /* save these values in our dma channel structure */
-    memcpy(p_dma_ch, p_init, sizeof(ppc_dma_ch_t));
-
-    /*
-     * The peripheral width values written in the control register are:
-     *   PW_8                 0
-     *   PW_16                1
-     *   PW_32                2
-     *   PW_64                3
-     *
-     *   Since the DMA count register takes the number of "transfers",
-     *   we need to divide the count sent to us in certain
-     *   functions by the appropriate number.  It so happens that our
-     *   right shift value is equal to the peripheral width value.
-     */
-    p_dma_ch->shift = p_init->pwidth;
-
-    /*
-     * Save the control word for easy access.
-     */
-    p_dma_ch->control = control;
-
-    mtdcr(DCRN_DMASR, 0xffffffff); /* clear status register */
-    return DMA_STATUS_GOOD;
-}
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
+	/* save these values in our dma channel structure */
+	memcpy(p_dma_ch, p_init, sizeof (ppc_dma_ch_t));
 
+	/*
+	 * The peripheral width values written in the control register are:
+	 *   PW_8                 0
+	 *   PW_16                1
+	 *   PW_32                2
+	 *   PW_64                3
+	 *
+	 *   Since the DMA count register takes the number of "transfers",
+	 *   we need to divide the count sent to us in certain
+	 *   functions by the appropriate number.  It so happens that our
+	 *   right shift value is equal to the peripheral width value.
+	 */
+	p_dma_ch->shift = p_init->pwidth;
+
+	/*
+	 * Save the control word for easy access.
+	 */
+	p_dma_ch->control = control;
 
+	mtdcr(DCRN_DMASR, 0xffffffff);	/* clear status register */
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * This function returns the channel configuration.
  */
-int get_channel_config(unsigned int dmanr, ppc_dma_ch_t *p_dma_ch)
+int
+ppc4xx_get_channel_config(unsigned int dmanr, ppc_dma_ch_t * p_dma_ch)
 {
-    unsigned int polarity;
-    unsigned int control;
+	unsigned int polarity;
+	unsigned int control;
 
 #if DCRN_POL > 0
-    polarity = mfdcr(DCRN_POL);
+	polarity = mfdcr(DCRN_POL);
 #else
-    polarity = 0;
+	polarity = 0;
 #endif
 
-    switch (dmanr) {
-        case 0:
-            p_dma_ch->polarity =
-                polarity & (DMAReq0_ActiveLow | DMAAck0_ActiveLow | EOT0_ActiveLow);
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            p_dma_ch->polarity =
-                polarity & (DMAReq1_ActiveLow | DMAAck1_ActiveLow | EOT1_ActiveLow);
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            p_dma_ch->polarity =
-                polarity & (DMAReq2_ActiveLow | DMAAck2_ActiveLow | EOT2_ActiveLow);
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            p_dma_ch->polarity =
-                polarity & (DMAReq3_ActiveLow | DMAAck3_ActiveLow | EOT3_ActiveLow);
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    p_dma_ch->cp = GET_DMA_PRIORITY(control);
-    p_dma_ch->pwidth = GET_DMA_PW(control);
-    p_dma_ch->psc = GET_DMA_PSC(control);
-    p_dma_ch->pwc = GET_DMA_PWC(control);
-    p_dma_ch->phc = GET_DMA_PHC(control);
-    p_dma_ch->pf = GET_DMA_PREFETCH(control);
-    p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
-    p_dma_ch->shift = GET_DMA_PW(control);
+	switch (dmanr) {
+	case 0:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(0);
+		control = mfdcr(DCRN_DMACR0);
+		break;
+	case 1:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(1);
+		control = mfdcr(DCRN_DMACR1);
+		break;
+	case 2:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(2);
+		control = mfdcr(DCRN_DMACR2);
+		break;
+	case 3:
+		p_dma_ch->polarity = polarity & GET_DMA_POLARITY(3);
+		control = mfdcr(DCRN_DMACR3);
+		break;
+	default:
+		return DMA_STATUS_BAD_CHANNEL;
+	}
 
-    return DMA_STATUS_GOOD;
+	p_dma_ch->cp = GET_DMA_PRIORITY(control);
+	p_dma_ch->pwidth = GET_DMA_PW(control);
+	p_dma_ch->psc = GET_DMA_PSC(control);
+	p_dma_ch->pwc = GET_DMA_PWC(control);
+	p_dma_ch->phc = GET_DMA_PHC(control);
+	p_dma_ch->ce = GET_DMA_CE_ENABLE(control);
+	p_dma_ch->int_enable = GET_DMA_CIE_ENABLE(control);
+	p_dma_ch->shift = GET_DMA_PW(control);
+
+#ifdef CONFIG_PPC4xx_EDMA
+	p_dma_ch->pf = GET_DMA_PREFETCH(control);
+#else
+	p_dma_ch->ch_enable = GET_DMA_CH(control);
+	p_dma_ch->ece_enable = GET_DMA_ECE(control);
+	p_dma_ch->tcd_disable = GET_DMA_TCD(control);
+#endif
+	return DMA_STATUS_GOOD;
 }
 
 /*
@@ -222,50 +755,44 @@ int get_channel_config(unsigned int dman
  * PRIORITY_HIGH
  *
  */
-int set_channel_priority(unsigned int dmanr, unsigned int priority)
+int
+ppc4xx_set_channel_priority(unsigned int dmanr, unsigned int priority)
 {
-    unsigned int control;
-
-#ifdef DEBUG_405DMA
-    if ( (priority != PRIORITY_LOW) &&
-            (priority != PRIORITY_MID_LOW) &&
-            (priority != PRIORITY_MID_HIGH) &&
-            (priority != PRIORITY_HIGH)) {
-        printk("set_channel_priority: bad priority: 0x%x\n", priority);
-    }
-#endif
-
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR0, control);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR1, control);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR2, control);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            control|= SET_DMA_PRIORITY(priority);
-            mtdcr(DCRN_DMACR3, control);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("set_channel_priority: bad channel: %d\n", dmanr);
-#endif
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-    return DMA_STATUS_GOOD;
-}
+	unsigned int control;
 
+	if ((priority != PRIORITY_LOW) &&
+	    (priority != PRIORITY_MID_LOW) &&
+	    (priority != PRIORITY_MID_HIGH) && (priority != PRIORITY_HIGH)) {
+		printk("ppc4xx_set_channel_priority: bad priority: 0x%x\n", priority);
+	}
 
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR0, control);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR1, control);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR2, control);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		control |= SET_DMA_PRIORITY(priority);
+		mtdcr(DCRN_DMACR3, control);
+		break;
+	default:
+		printk("ppc4xx_set_channel_priority: bad channel: %d\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
 
 /*
  * Returns the width of the peripheral attached to this channel. This assumes
@@ -280,213 +807,46 @@ int set_channel_priority(unsigned int dm
  *
  *   The function returns 0 on error.
  */
-unsigned int get_peripheral_width(unsigned int dmanr)
+unsigned int
+ppc4xx_get_peripheral_width(unsigned int dmanr)
 {
-    unsigned int control;
-
-    switch (dmanr) {
-        case 0:
-            control = mfdcr(DCRN_DMACR0);
-            break;
-        case 1:
-            control = mfdcr(DCRN_DMACR1);
-            break;
-        case 2:
-            control = mfdcr(DCRN_DMACR2);
-            break;
-        case 3:
-            control = mfdcr(DCRN_DMACR3);
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("get_peripheral_width: bad channel: %d\n", dmanr);
-#endif
-            return 0;
-    }
-    return(GET_DMA_PW(control));
-}
-
-
-
-
-/*
- *   Create a scatter/gather list handle.  This is simply a structure which
- *   describes a scatter/gather list.
- *
- *   A handle is returned in "handle" which the driver should save in order to
- *   be able to access this list later.  A chunk of memory will be allocated
- *   to be used by the API for internal management purposes, including managing
- *   the sg list and allocating memory for the sgl descriptors.  One page should
- *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use
- *   a whole page for a single sg list, but most likely there will be only one
- *   sg list per channel.
- *
- *   Interrupt notes:
- *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
- *   loads in the control register.  The control word has a "global" interrupt
- *   enable bit for that channel. Interrupts are further qualified by a few bits
- *   in the sgl descriptor count register.  In order to setup an sgl, we have to
- *   know ahead of time whether or not interrupts will be enabled at the completion
- *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
- *   be called before calling alloc_dma_handle().  If the interrupt mode will never
- *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt()
- *   do not have to be called -- interrupts will be enabled or disabled based
- *   on how the channel was configured after powerup by the hw_init_dma_channel()
- *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
- *   however, only the last descriptor will be setup to interrupt. Thus, an
- *   interrupt will occur (if interrupts are enabled) only after the complete
- *   sgl transfer is done.
- */
-int alloc_dma_handle(sgl_handle_t *phandle, unsigned int mode, unsigned int dmanr)
-{
-    sgl_list_info_t *psgl;
-    dma_addr_t dma_addr;
-    ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
-    uint32_t sg_command;
-    void *ret;
-
-#ifdef DEBUG_405DMA
-    if (!phandle) {
-            printk("alloc_dma_handle: null handle pointer\n");
-            return DMA_STATUS_NULL_POINTER;
-    }
-    switch (mode) {
-        case DMA_MODE_READ:
-        case DMA_MODE_WRITE:
-        case DMA_MODE_MM:
-        case DMA_MODE_MM_DEVATSRC:
-        case DMA_MODE_MM_DEVATDST:
-            break;
-        default:
-            printk("alloc_dma_handle: bad mode 0x%x\n", mode);
-            return DMA_STATUS_BAD_MODE;
-    }
-    if (dmanr >= MAX_405GP_DMA_CHANNELS) {
-        printk("alloc_dma_handle: invalid channel 0x%x\n", dmanr);
-        return DMA_STATUS_BAD_CHANNEL;
-    }
-#endif
-
-    /* Get a page of memory, which is zeroed out by pci_alloc_consistent() */
-
-/* wrong not a pci device - armin */
-    /* psgl = (sgl_list_info_t *) pci_alloc_consistent(NULL, SGL_LIST_SIZE, &dma_addr);
-*/
-
-	ret = consistent_alloc(GFP_ATOMIC |GFP_DMA, SGL_LIST_SIZE, &dma_addr);
-	if (ret != NULL) {
-		memset(ret, 0,SGL_LIST_SIZE );
-		psgl = (sgl_list_info_t *) ret;
-	}
-
-
-    if (psgl == NULL) {
-        *phandle = (sgl_handle_t)NULL;
-        return DMA_STATUS_OUT_OF_MEMORY;
-    }
-
-    psgl->dma_addr = dma_addr;
-    psgl->dmanr = dmanr;
-
-    /*
-     * Modify and save the control word. These word will get written to each sgl
-     * descriptor.  The DMA engine then loads this control word into the control
-     * register every time it reads a new descriptor.
-     */
-    psgl->control = p_dma_ch->control;
-    psgl->control &= ~(DMA_TM_MASK | DMA_TD);  /* clear all "mode" bits first               */
-    psgl->control |= (mode | DMA_CH_ENABLE);   /* save the control word along with the mode */
-
-    if (p_dma_ch->int_enable) {
-        psgl->control |= DMA_CIE_ENABLE;       /* channel interrupt enabled                 */
-    }
-    else {
-        psgl->control &= ~DMA_CIE_ENABLE;
-    }
-
-#if DCRN_ASGC > 0
-    sg_command = mfdcr(DCRN_ASGC);
-    switch (dmanr) {
-        case 0:
-            sg_command |= SSG0_MASK_ENABLE;
-            break;
-        case 1:
-            sg_command |= SSG1_MASK_ENABLE;
-            break;
-        case 2:
-            sg_command |= SSG2_MASK_ENABLE;
-            break;
-        case 3:
-            sg_command |= SSG3_MASK_ENABLE;
-            break;
-        default:
-#ifdef DEBUG_405DMA
-            printk("alloc_dma_handle: bad channel: %d\n", dmanr);
-#endif
-            free_dma_handle((sgl_handle_t)psgl);
-            *phandle = (sgl_handle_t)NULL;
-            return DMA_STATUS_BAD_CHANNEL;
-    }
-
-    mtdcr(DCRN_ASGC, sg_command);  /* enable writing to this channel's sgl control bits */
-#else
-   (void)sg_command;
-#endif
-    psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;   /* sgl descriptor control bits */
-
-    if (p_dma_ch->int_enable) {
-        if (p_dma_ch->tce_enable)
-            psgl->sgl_control |= SG_TCI_ENABLE;
-        else
-            psgl->sgl_control |= SG_ETI_ENABLE;
-    }
-
-    *phandle = (sgl_handle_t)psgl;
-    return DMA_STATUS_GOOD;
-}
-
-
-
-/*
- * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
- * The list must be empty (contain no elements).
- */
-void free_dma_handle(sgl_handle_t handle)
-{
-    sgl_list_info_t *psgl = (sgl_list_info_t *)handle;
-
-    if (!handle) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: got NULL\n");
-#endif
-        return;
-    }
-    else if (psgl->phead) {
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: list not empty\n");
-#endif
-        return;
-    }
-    else if (!psgl->dma_addr) { /* should never happen */
-#ifdef DEBUG_405DMA
-        printk("free_dma_handle: no dma address\n");
-#endif
-        return;
-    }
-
-  /* wrong not a PCI device -armin */
-  /*  pci_free_consistent(NULL, SGL_LIST_SIZE, (void *)psgl, psgl->dma_addr); */
-	//	free_pages((unsigned long)psgl, get_order(SGL_LIST_SIZE));
-    	consistent_free((void *)psgl);
-
+	unsigned int control;
 
+	switch (dmanr) {
+	case 0:
+		control = mfdcr(DCRN_DMACR0);
+		break;
+	case 1:
+		control = mfdcr(DCRN_DMACR1);
+		break;
+	case 2:
+		control = mfdcr(DCRN_DMACR2);
+		break;
+	case 3:
+		control = mfdcr(DCRN_DMACR3);
+		break;
+	default:
+		printk("ppc4xx_get_peripheral_width: bad channel: %d\n", dmanr);
+		return 0;
+	}
+	return (GET_DMA_PW(control));
 }
 
 
-EXPORT_SYMBOL(hw_init_dma_channel);
-EXPORT_SYMBOL(get_channel_config);
-EXPORT_SYMBOL(set_channel_priority);
-EXPORT_SYMBOL(get_peripheral_width);
-EXPORT_SYMBOL(alloc_dma_handle);
-EXPORT_SYMBOL(free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_init_dma_channel);
+EXPORT_SYMBOL(ppc4xx_get_channel_config);
+EXPORT_SYMBOL(ppc4xx_set_channel_priority);
+EXPORT_SYMBOL(ppc4xx_get_peripheral_width);
 EXPORT_SYMBOL(dma_channels);
+EXPORT_SYMBOL(ppc4xx_set_src_addr);
+EXPORT_SYMBOL(ppc4xx_set_dst_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr);
+EXPORT_SYMBOL(ppc4xx_set_dma_addr2);
+EXPORT_SYMBOL(ppc4xx_enable_dma);
+EXPORT_SYMBOL(ppc4xx_disable_dma);
+EXPORT_SYMBOL(ppc4xx_set_dma_mode);
+EXPORT_SYMBOL(ppc4xx_set_dma_count);
+EXPORT_SYMBOL(ppc4xx_get_dma_residue);
+EXPORT_SYMBOL(ppc4xx_enable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_disable_dma_interrupt);
+EXPORT_SYMBOL(ppc4xx_get_dma_status);
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_pic.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_pic.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_pic.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_pic.c	2003-09-12 17:45:00.000000000 +0000
@@ -40,7 +40,7 @@
 struct hw_interrupt_type *ppc4xx_pic;
 /*
  * We define 4xxIRQ_InitSenses table thusly:
- * bit 0x1: sense, 1 for edge and 0 for level.
+ * bit 0x1: sense, 0 for edge and 1 for level.
  * bit 0x2: polarity, 0 for negative, 1 for positive.
  */
 unsigned int ibm4xxPIC_NumInitSenses __initdata = 0;
@@ -225,10 +225,14 @@ ppc405_uic_disable_and_ack(unsigned int 
 		mtdcr(DCRN_UIC_ER(UIC0), ppc_cached_irq_mask[word]);
 		mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - bit)));
 		break;
+#if NR_UICS > 1
 	case 1:
 		mtdcr(DCRN_UIC_ER(UIC1), ppc_cached_irq_mask[word]);
 		mtdcr(DCRN_UIC_SR(UIC1), (1 << (31 - bit)));
+		/* ACK cascaded interrupt in UIC0 */
+		mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - UIC0_UIC1NC)));
 		break;
+#endif
 	}
 }
 
@@ -260,9 +264,13 @@ ppc405_uic_end(unsigned int irq)
 		case 0:
 			mtdcr(DCRN_UIC_SR(UIC0), 1 << (31 - bit));
 			break;
+#if NR_UICS > 1
 		case 1:
 			mtdcr(DCRN_UIC_SR(UIC1), 1 << (31 - bit));
+			/* ACK cascaded interrupt in UIC0 */
+			mtdcr(DCRN_UIC_SR(UIC0), (1 << (31 - UIC0_UIC1NC)));
 			break;
+#endif
 		}
 	}
 
@@ -340,14 +348,6 @@ ppc405_pic_get_irq(struct pt_regs *regs)
 void __init
 ppc4xx_extpic_init(void)
 {
-	/* set polarity
-	 * 1 = default/pos/rising  , 0= neg/falling internal
-	 * 1 = neg/falling , 0= pos/rising external
-	 * Sense
-	 * 0 = default level internal
-	 * 0 = level, 1 = edge external
-	 */
-
 	unsigned int sense, irq;
 	int bit, word;
 	unsigned long ppc_cached_sense_mask[NR_MASK_WORDS];
@@ -362,15 +362,15 @@ ppc4xx_extpic_init(void)
 		bit = irq & 0x1f;
 		word = irq >> 5;
 
-		sense =
-		    (irq <
-		     ibm4xxPIC_NumInitSenses) ? ibm4xxPIC_InitSenses[irq] : 3;
+		sense = (irq < ibm4xxPIC_NumInitSenses) ?
+			ibm4xxPIC_InitSenses[irq] :
+			IRQ_SENSE_EDGE | IRQ_POLARITY_POSITIVE;
 #ifdef PPC4xx_PIC_DEBUG
 		printk("PPC4xx_picext %d word:%x bit:%x sense:%x", irq, word,
 		       bit, sense);
 #endif
 		ppc_cached_sense_mask[word] |=
-		    (sense & IRQ_SENSE_MASK) << (31 - bit);
+		    (~sense & IRQ_SENSE_MASK) << (31 - bit);
 		ppc_cached_pol_mask[word] |=
 		    ((sense & IRQ_POLARITY_MASK) >> 1) << (31 - bit);
 		switch (word) {
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_pm.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_pm.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_pm.c	2003-02-11 23:48:53.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_pm.c	2003-02-13 01:00:41.000000000 +0000
@@ -12,36 +12,154 @@
 
 #include <linux/config.h>
 #include <linux/init.h>
-
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/pm.h>
 #include <asm/ibm4xx.h>
+#include <asm/ibm_ocp.h>
+#include <linux/interrupt.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+
+#ifdef CONFIG_APM
+/*
+ * OCP Power management..
+ *
+ * This needs to be done centralized, so that we power manage PCI
+ * devices in the right order: we should not shut down PCI bridges
+ * before we've shut down the devices behind them, and we should
+ * not wake up devices before we've woken up the bridge to the
+ * device.. Eh?
+ *
+ * We do not touch devices that don't have a driver that exports
+ * a suspend/resume function. That is just too dangerous. If the default
+ * PCI suspend/resume functions work for a device, the driver can
+ * easily implement them (ie just have a suspend function that calls
+ * the pci_set_power_state() function).
+ */
+
+static int ocp_pm_save_state_device(struct ocp_dev *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->save_state)
+			error = driver->save_state(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_suspend_device(struct ocp_dev *dev, u32 state)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->suspend)
+			error = driver->suspend(dev,state);
+	}
+	return error;
+}
+
+static int ocp_pm_resume_device(struct ocp_dev *dev)
+{
+	int error = 0;
+	if (dev) {
+		struct ocp_dev *driver = dev->driver;
+		if (driver && driver->resume)
+			error = driver->resume(dev);
+	}
+	return error;
+}
+
+static int
+ocp_pm_callback(struct pm_dev *pm_device, pm_request_t rqst, void *data)
+{
+	int error = 0;
+
+	switch (rqst) {
+	case PM_SAVE_STATE:
+		error = ocp_pm_save_state_device((u32)data);
+		break;
+	case PM_SUSPEND:
+		error = ocp_pm_suspend_device((u32)data);
+		break;
+	case PM_RESUME:
+		error = ocp_pm_resume_device((u32)data);
+		break;
+	default: break;
+	}
+	return error;
+}
+/**
+ * ocp_register_driver - register a new ocp driver
+ * @drv: the driver structure to register
+ *
+ * Adds the driver structure to the list of registered drivers
+ * Returns the number of ocp devices which were claimed by the driver
+ * during registration.  The driver remains registered even if the
+ * return value is zero.
+ */
+int
+ocp_register_driver(struct ocp_dev *drv)
+{
+	struct ocp_dev *dev;
+	struct ocp_
+	list_add_tail(&drv->node, &ocp_devs);
+	return 0;
+}
+
+EXPORT_SYMBOL(ocp_register_driver);
+#endif
+
+/* When bits are "1" then the given clock is
+ * stopped therefore saving power 
+ *
+ * The objected is to turn off all unneccessary 
+ * clocks and have the drivers enable/disable
+ * them when in use.  We set the default
+ * in the <core>.h file
+ */
 
 void __init
 ppc4xx_pm_init(void)
 {
-
-	unsigned int value = 0;
+	
+	mtdcr(DCRN_CPMFR, 0);
 
 	/* turn off unused hardware to save power */
-#ifdef CONFIG_405GP
-	value |= CPM_DCP;	/* CodePack */
-#endif
 
-#if !defined(CONFIG_IBM_OCP_GPIO)
-	value |= CPM_GPIO0;
-#endif
+	printk(KERN_INFO "OCP 4xx power management enabled\n");
+	mtdcr(DCRN_CPMFR, DFLT_IBM4xx_PM);
 
-#if !defined(CONFIG_PPC405_I2C_ADAP)
-	value |= CPM_IIC0;
-#ifdef CONFIG_STB03xxx
-	value |= CPM_IIC1;
-#endif
+#ifdef CONFIG_APM
+	pm_gpio = pm_register(PM_SYS_DEV, 0, ocp_pm_callback);
 #endif
+}
+__initcall(ppc4xx_pm_init);
 
+/* Force/unforce power down for CPM Class 1 devices */
 
-#if !defined(CONFIG_405_DMA)
-	value |= CPM_DMA;
-#endif
+void
+ppc4xx_cpm_fr(u32 bits, int val)
+{
+	unsigned long flags;
 
-	mtdcr(DCRN_CPMFR, value);
+	save_flags(flags);
+	cli();
 
+	if (val)
+		mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | bits);
+	else
+		mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~bits);
+
+	restore_flags(flags);
 }
+
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_serial.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_serial.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_serial.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_serial.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,171 +0,0 @@
-/*
- * arch/ppc/syslib/ppc405_serial.c
- *
- * Author: MontaVista Software, Inc.
- *         	frank_rowand@mvista.com or source@mvista.com
- * 	   	debbie_chu@mvista.com
- *
- * This is a fairly standard 165xx type device that will eventually
- * be merged with other similar processor/boards.	-- Dan
- *
- * 2000 (c) MontaVista, Software, Inc.  This file is licensed under
- * the terms of the GNU General Public License version 2.  This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- *
- * Console I/O support for Early kernel bringup.
- */
-
-#include <linux/config.h>
-
-#if defined(CONFIG_IBM405GP) || defined(CONFIG_IBM405CR)
-
-#ifdef CONFIG_KGDB
-#include <asm/kgdb.h>
-#include <linux/init.h>
-#endif
-
-#ifdef CONFIG_DEBUG_BRINGUP
-
-#include <linux/console.h>
-
-extern void ftr_reset_preferred_console(void);
-
-
-static int ppc405_sercons_setup(struct console *co, char *options)
-{
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_dll  = (char *)0xef600300;
-    volatile unsigned char *uart_fcr  = (char *)0xef600302;
-    volatile unsigned char *uart_lcr  = (char *)0xef600303;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_dll  = (char *)0xef600400;
-    volatile unsigned char *uart_fcr  = (char *)0xef600402;
-    volatile unsigned char *uart_lcr  = (char *)0xef600403;
-#endif
-
-    *uart_lcr = *uart_lcr | 0x80;   /* DLAB on  */
-
-/* ftr revisit - there is no config option for this
-**  also see include/asm-ppc/ppc405_serial.h
-**
-** #define CONFIG_IBM405GP_INTERNAL_CLOCK
-*/
-
-
-#ifdef  CONFIG_IBM405GP_INTERNAL_CLOCK
-    /* ftr revisit
-    ** why is bit 19 of chcr0 (0x1000) being set?
-    */
-    /* 0x2a results in data corruption, kgdb works with 0x28 */
-    *uart_dll = 0x28;		    /* 9600 baud */
-    _put_CHCR0((_get_CHCR0() & 0xffffe000) | 0x103e);
-#else
-    *uart_dll = 0x48;		    /* 9600 baud */
-#endif
-    *uart_lcr = *uart_lcr & 0x7f;   /* DLAB off */
-
-    return 0;
-}
-
-
-/*
- * This is a bringup hack, writing directly to uart0 or uart1
- */
-
-static void
-ppc405_sercons_write(struct console *co, const char *ptr,
-            unsigned nb)
-{
-    int i;
-
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_xmit = (char *)0xef600300;
-    volatile unsigned char *uart_lsr  = (char *)0xef600305;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_xmit = (char *)0xef600400;
-    volatile unsigned char *uart_lsr  = (char *)0xef600405;
-#endif
-
-    for (i = 0; i < nb; ++i) {
-
-	/* wait for transmit reg (possibly fifo) to empty */
-	while ((*uart_lsr & 0x40) == 0)
-	    ;
-
-	*uart_xmit = (ptr[i] & 0xff);
-
-	if (ptr[i] == '\n') {
-
-	    /* add a carriage return */
-
-	    /* wait for transmit reg (possibly fifo) to empty */
-	    while ((*uart_lsr & 0x40) == 0)
-		;
-
-	    *uart_xmit = '\r';
-	}
-    }
-
-    return;
-}
-
-
-static int
-ppc405_sercons_read(struct console *co, char *ptr, unsigned nb)
-{
-#ifdef CONFIG_UART0_DEBUG_CONSOLE
-    volatile unsigned char *uart_rcv  = (char *)0xef600300;
-    volatile unsigned char *uart_lsr  = (char *)0xef600305;
-#endif
-
-#ifdef CONFIG_UART1_DEBUG_CONSOLE
-    volatile unsigned char *uart_rcv  = (char *)0xef600400;
-    volatile unsigned char *uart_lsr  = (char *)0xef600405;
-#endif
-
-
-    /* ftr revisit: not tested */
-
-    if (nb == 0)
-	return(0);
-
-    if (!ptr)
-	return(-1);
-
-    /* wait for receive reg (possibly fifo) to contain data */
-    while ((*uart_lsr & 0x01) == 0)
-	;
-
-    *ptr = *uart_rcv;
-
-    return(1);
-}
-
-static struct console ppc405_sercons = {
-	.name =		"dbg_cons",
-	.write =	ppc405_console_write,
-	.setup =	ppc405_console_setup,
-	.flags =	CON_PRINTBUFFER,
-	.index =	-1,
-};
-
-void
-register_debug_console(void)
-{
-	register_console(&ppc405_sercons);
-}
-
-void
-unregister_debug_console(void)
-{
-	unregister_console(&ppc405_sercons);
-}
-
-#endif	/* CONFIG_DEBUG_BRINGUP */
-
-#endif	/* #if defined(CONFIG_IBM405GP) || defined(CONFIG_IBM405CR) */
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_sgdma.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_sgdma.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_sgdma.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_sgdma.c	2003-07-18 20:39:24.000000000 +0000
@@ -0,0 +1,536 @@
+/*
+ * arch/ppc/kernel/ppc4xx_sgdma.c
+ *
+ * IBM PPC4xx DMA engine scatter/gather library 
+ *
+ * Copyright 2002-2003 MontaVista Software Inc.
+ *
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *   
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/ppc4xx_dma.h>
+
+static __inline__ void
+ppc4xx_set_sg_addr(int dmanr, phys_addr_t sg_addr)
+{
+	switch (dmanr) {
+		case 0:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH0, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG0, (u32)sg_addr);
+			break;
+		case 1:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH1, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG1, (u32)sg_addr);
+			break;
+		case 2:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH2, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG2, sg_addr);
+			break;
+		case 3:
+#ifdef PPC4xx_DMA_64BIT
+			mtdcr(DCRN_ASGH3, (u32)(sg_addr >> 32));
+#endif			
+			mtdcr(DCRN_ASG3, (u32)sg_addr);
+			break;
+	}
+}
+
+
+/*
+ *   Add a new sgl descriptor to the end of a scatter/gather list 
+ *   which was created by alloc_dma_handle(). 
+ *
+ *   For a memory to memory transfer, both dma addresses must be
+ *   valid. For a peripheral to memory transfer, one of the addresses
+ *   must be set to NULL, depending on the direction of the transfer:
+ *   memory to peripheral: set dst_addr to NULL,
+ *   peripheral to memory: set src_addr to NULL.
+ */
+static __inline__ int
+ppc4xx_add_dma_sgl(sgl_handle_t handle, phys_addr_t src_addr, phys_addr_t dst_addr,
+		   unsigned int count)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+
+	if (!handle) {
+		printk("ppc4xx_add_dma_sgl: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	}
+
+	if (psgl->dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_add_dma_sgl: bad channel: %d\n", psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+
+#ifdef DEBUG_4xxDMA
+	{
+		int error = 0;
+		unsigned int aligned =
+		    (unsigned) src_addr | (unsigned) dst_addr | count;
+		switch (p_dma_ch->pwidth) {
+		case PW_8:
+			break;
+		case PW_16:
+			if (aligned & 0x1)
+				error = 1;
+			break;
+		case PW_32:
+			if (aligned & 0x3)
+				error = 1;
+			break;
+		case PW_64:
+			if (aligned & 0x7)
+				error = 1;
+			break;
+		default:
+			printk("ppc4xx_add_dma_sgl: invalid bus width: 0x%x\n",
+			       p_dma_ch->pwidth);
+			return DMA_STATUS_GENERAL_ERROR;
+		}
+		if (error)
+			printk
+			    ("Alignment warning: ppc4xx_add_dma_sgl src 0x%x dst 0x%x count 0x%x bus width var %d\n",
+			     src_addr, dst_addr, count, p_dma_ch->pwidth);
+
+	}
+#endif
+
+	if ((unsigned) (psgl->ptail + 1) >= ((unsigned) psgl + SGL_LIST_SIZE)) {
+		printk("sgl handle out of memory \n");
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	if (!psgl->ptail) {
+		psgl->phead = (ppc_sgl_t *)
+		    ((unsigned) psgl + sizeof (sgl_list_info_t));
+		psgl->ptail = psgl->phead;
+	} else {
+		psgl->ptail->next = iopa((unsigned long)(psgl->ptail + 1));
+		psgl->ptail++;
+	}
+
+	psgl->ptail->control = psgl->control;
+	psgl->ptail->src_addr = src_addr;
+	psgl->ptail->dst_addr = dst_addr;
+	psgl->ptail->control_count = (count >> p_dma_ch->shift) |
+	    psgl->sgl_control;
+	psgl->ptail->next = (uint32_t) NULL;
+
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Enable (start) the DMA described by the sgl handle.
+ */
+static __inline__ void
+ppc4xx_enable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	} else if (!psgl->phead) {
+		printk("ppc4xx_enable_dma_sgl: sg list empty\n");
+		return;
+	}
+
+	p_dma_ch = &dma_channels[psgl->dmanr];
+	psgl->ptail->control_count &= ~SG_LINK;	/* make this the last dscrptr */
+	sg_command = mfdcr(DCRN_ASGC);
+
+	ppc4xx_set_sg_addr(psgl->dmanr, iopa((unsigned long)psgl->phead));
+
+	switch (psgl->dmanr) {
+	case 0:
+		sg_command |= SSG0_ENABLE;
+		break;
+	case 1:
+		sg_command |= SSG1_ENABLE;
+		break;
+	case 2:
+		sg_command |= SSG2_ENABLE;
+		break;
+	case 3:
+		sg_command |= SSG3_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
+	}
+
+	mtdcr(DCRN_ASGC, sg_command);	/* start transfer */
+}
+
+/*
+ * Halt an active scatter/gather DMA operation.
+ */
+static __inline__ void
+ppc4xx_disable_dma_sgl(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	uint32_t sg_command;
+
+	if (!handle) {
+		printk("ppc4xx_enable_dma_sgl: null handle\n");
+		return;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_enable_dma_sgl: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	switch (psgl->dmanr) {
+	case 0:
+		sg_command &= ~SSG0_ENABLE;
+		break;
+	case 1:
+		sg_command &= ~SSG1_ENABLE;
+		break;
+	case 2:
+		sg_command &= ~SSG2_ENABLE;
+		break;
+	case 3:
+		sg_command &= ~SSG3_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_enable_dma_sgl: bad channel: %d\n", psgl->dmanr);
+	}
+
+	mtdcr(DCRN_ASGC, sg_command);	/* stop transfer */
+}
+
+/*
+ *  Returns number of bytes left to be transferred from the entire sgl list.
+ *  *src_addr and *dst_addr get set to the source/destination address of
+ *  the sgl descriptor where the DMA stopped.
+ *
+ *  An sgl transfer must NOT be active when this function is called.
+ */
+static __inline__ int
+ppc4xx_get_dma_sgl_residue(sgl_handle_t handle, phys_addr_t * src_addr,
+			   phys_addr_t * dst_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+	ppc_dma_ch_t *p_dma_ch;
+	ppc_sgl_t *pnext, *sgl_addr;
+	uint32_t count_left;
+
+	if (!handle) {
+		printk("ppc4xx_get_dma_sgl_residue: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_get_dma_sgl_residue: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	switch (psgl->dmanr) {
+	case 0:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG0));
+		count_left = mfdcr(DCRN_DMACT0);
+		break;
+	case 1:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG1));
+		count_left = mfdcr(DCRN_DMACT1);
+		break;
+	case 2:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG2));
+		count_left = mfdcr(DCRN_DMACT2);
+		break;
+	case 3:
+		sgl_addr = (ppc_sgl_t *) bus_to_virt(mfdcr(DCRN_ASG3));
+		count_left = mfdcr(DCRN_DMACT3);
+		break;
+	default:
+		printk("ppc4xx_get_dma_sgl_residue: bad channel %d\n", psgl->dmanr);
+		goto error;
+	}
+
+	if (!sgl_addr) {
+		printk("ppc4xx_get_dma_sgl_residue: sgl addr register is null\n");
+		goto error;
+	}
+
+	pnext = psgl->phead;
+	while (pnext &&
+	       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE) &&
+		(pnext != sgl_addr))
+	    ) {
+		pnext++;
+	}
+
+	if (pnext == sgl_addr) {	/* found the sgl descriptor */
+
+		*src_addr = pnext->src_addr;
+		*dst_addr = pnext->dst_addr;
+
+		/*
+		 * Now search the remaining descriptors and add their count.
+		 * We already have the remaining count from this descriptor in
+		 * count_left.
+		 */
+		pnext++;
+
+		while ((pnext != psgl->ptail) &&
+		       ((unsigned) pnext < ((unsigned) psgl + SGL_LIST_SIZE))
+		    ) {
+			count_left += pnext->control_count & SG_COUNT_MASK;
+		}
+
+		if (pnext != psgl->ptail) {	/* should never happen */
+			printk
+			    ("ppc4xx_get_dma_sgl_residue error (1) psgl->ptail 0x%x handle 0x%x\n",
+			     (unsigned int) psgl->ptail, (unsigned int) handle);
+			goto error;
+		}
+
+		/* success */
+		p_dma_ch = &dma_channels[psgl->dmanr];
+		return (count_left << p_dma_ch->shift);	/* count in bytes */
+
+	} else {
+		/* this shouldn't happen */
+		printk
+		    ("get_dma_sgl_residue, unable to match current address 0x%x, handle 0x%x\n",
+		     (unsigned int) sgl_addr, (unsigned int) handle);
+
+	}
+
+      error:
+	*src_addr = (phys_addr_t) NULL;
+	*dst_addr = (phys_addr_t) NULL;
+	return 0;
+}
+
+/*
+ * Returns the address(es) of the buffer(s) contained in the head element of
+ * the scatter/gather list.  The element is removed from the scatter/gather
+ * list and the next element becomes the head.
+ *
+ * This function should only be called when the DMA is not active.
+ */
+static __inline__ int
+ppc4xx_delete_dma_sgl_element(sgl_handle_t handle, phys_addr_t * src_dma_addr,
+			      phys_addr_t * dst_dma_addr)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_delete_sgl_element: null handle\n");
+		return DMA_STATUS_BAD_HANDLE;
+	} else if (psgl->dmanr > (MAX_PPC4xx_DMA_CHANNELS - 1)) {
+		printk("ppc4xx_delete_sgl_element: bad channel in handle %d\n",
+		       psgl->dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!psgl->phead) {
+		printk("ppc4xx_delete_sgl_element: sgl list empty\n");
+		*src_dma_addr = (phys_addr_t) NULL;
+		*dst_dma_addr = (phys_addr_t) NULL;
+		return DMA_STATUS_SGL_LIST_EMPTY;
+	}
+
+	*src_dma_addr = (phys_addr_t) psgl->phead->src_addr;
+	*dst_dma_addr = (phys_addr_t) psgl->phead->dst_addr;
+
+	if (psgl->phead == psgl->ptail) {
+		/* last descriptor on the list */
+		psgl->phead = NULL;
+		psgl->ptail = NULL;
+	} else {
+		psgl->phead++;
+	}
+
+	return DMA_STATUS_GOOD;
+}
+
+
+/*
+ *   Create a scatter/gather list handle.  This is simply a structure which
+ *   describes a scatter/gather list.
+ *
+ *   A handle is returned in "handle" which the driver should save in order to 
+ *   be able to access this list later.  A chunk of memory will be allocated 
+ *   to be used by the API for internal management purposes, including managing 
+ *   the sg list and allocating memory for the sgl descriptors.  One page should 
+ *   be more than enough for that purpose.  Perhaps it's a bit wasteful to use 
+ *   a whole page for a single sg list, but most likely there will be only one 
+ *   sg list per channel.
+ *
+ *   Interrupt notes:
+ *   Each sgl descriptor has a copy of the DMA control word which the DMA engine
+ *   loads in the control register.  The control word has a "global" interrupt 
+ *   enable bit for that channel. Interrupts are further qualified by a few bits
+ *   in the sgl descriptor count register.  In order to setup an sgl, we have to
+ *   know ahead of time whether or not interrupts will be enabled at the completion
+ *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST
+ *   be called before calling alloc_dma_handle().  If the interrupt mode will never
+ *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt() 
+ *   do not have to be called -- interrupts will be enabled or disabled based
+ *   on how the channel was configured after powerup by the hw_init_dma_channel()
+ *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;
+ *   however, only the last descriptor will be setup to interrupt. Thus, an 
+ *   interrupt will occur (if interrupts are enabled) only after the complete
+ *   sgl transfer is done.
+ */
+int
+ppc4xx_alloc_dma_handle(sgl_handle_t * phandle, unsigned int mode, unsigned int dmanr)
+{
+	sgl_list_info_t *psgl;
+	dma_addr_t dma_addr;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	uint32_t sg_command;
+	void *ret;
+
+	if (dmanr >= MAX_PPC4xx_DMA_CHANNELS) {
+		printk("ppc4xx_alloc_dma_handle: invalid channel 0x%x\n", dmanr);
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	if (!phandle) {
+		printk("ppc4xx_alloc_dma_handle: null handle pointer\n");
+		return DMA_STATUS_NULL_POINTER;
+	}
+
+	/* Get a page of memory, which is zeroed out by consistent_alloc() */
+	ret = consistent_alloc(GFP_KERNEL, DMA_PPC4xx_SIZE, &dma_addr);
+	if (ret != NULL) {
+		memset(ret, 0, DMA_PPC4xx_SIZE);
+		psgl = (sgl_list_info_t *) ret;
+	}
+
+	if (psgl == NULL) {
+		*phandle = (sgl_handle_t) NULL;
+		return DMA_STATUS_OUT_OF_MEMORY;
+	}
+
+	psgl->dma_addr = dma_addr;
+	psgl->dmanr = dmanr;
+
+	/*
+	 * Modify and save the control word. These words will be
+	 * written to each sgl descriptor.  The DMA engine then
+	 * loads this control word into the control register
+	 * every time it reads a new descriptor.
+	 */
+	psgl->control = p_dma_ch->control;
+	/* Clear all mode bits */
+	psgl->control &= ~(DMA_TM_MASK | DMA_TD);
+	/* Save control word and mode */
+	psgl->control |= (mode | DMA_CE_ENABLE);
+
+	/* In MM mode, we must set ETD/TCE */
+	if (mode == DMA_MODE_MM)
+		psgl->control |= DMA_ETD_OUTPUT | DMA_TCE_ENABLE;
+
+	if (p_dma_ch->int_enable) {
+		/* Enable channel interrupt */
+		psgl->control |= DMA_CIE_ENABLE;
+	} else {
+		psgl->control &= ~DMA_CIE_ENABLE;
+	}
+
+	sg_command = mfdcr(DCRN_ASGC);
+	switch (dmanr) {
+	case 0:
+		sg_command |= SSG0_MASK_ENABLE;
+		break;
+	case 1:
+		sg_command |= SSG1_MASK_ENABLE;
+		break;
+	case 2:
+		sg_command |= SSG2_MASK_ENABLE;
+		break;
+	case 3:
+		sg_command |= SSG3_MASK_ENABLE;
+		break;
+	default:
+		printk("ppc4xx_alloc_dma_handle: bad channel: %d\n", dmanr);
+		ppc4xx_free_dma_handle((sgl_handle_t) psgl);
+		*phandle = (sgl_handle_t) NULL;
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+
+	/* Enable SGL control access */
+	mtdcr(DCRN_ASGC, sg_command);
+	psgl->sgl_control = SG_ERI_ENABLE | SG_LINK;
+
+	if (p_dma_ch->int_enable) {
+		if (p_dma_ch->tce_enable)
+			psgl->sgl_control |= SG_TCI_ENABLE;
+		else
+			psgl->sgl_control |= SG_ETI_ENABLE;
+	}
+
+	*phandle = (sgl_handle_t) psgl;
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Destroy a scatter/gather list handle that was created by alloc_dma_handle().
+ * The list must be empty (contain no elements).
+ */
+void
+ppc4xx_free_dma_handle(sgl_handle_t handle)
+{
+	sgl_list_info_t *psgl = (sgl_list_info_t *) handle;
+
+	if (!handle) {
+		printk("ppc4xx_free_dma_handle: got NULL\n");
+		return;
+	} else if (psgl->phead) {
+		printk("ppc4xx_free_dma_handle: list not empty\n");
+		return;
+	} else if (!psgl->dma_addr) {	/* should never happen */
+		printk("ppc4xx_free_dma_handle: no dma address\n");
+		return;
+	}
+
+	consistent_free((void *) psgl);
+}
+
+EXPORT_SYMBOL(ppc4xx_alloc_dma_handle);
+EXPORT_SYMBOL(ppc4xx_free_dma_handle);
+EXPORT_SYMBOL(ppc4xx_add_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_delete_dma_sgl_element);
+EXPORT_SYMBOL(ppc4xx_enable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_disable_dma_sgl);
+EXPORT_SYMBOL(ppc4xx_get_dma_sgl_residue);
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_stbdma.c linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_stbdma.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/ppc4xx_stbdma.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/ppc4xx_stbdma.c	2003-02-25 01:41:01.000000000 +0000
@@ -0,0 +1,135 @@
+/*
+ * arch/ppc/syslib/ppc4xx_stbdma.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	IBM PPC4xx STBxxxx DMA Controller Functions
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         Armin Kuster <akuster@mvista.com>
+ *   
+ * Based on ppc4xx_dma.c by
+ *         ppopov@mvista.com or source@mvista.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <asm/ppc4xx_dma.h>
+
+int
+clr_dma_status(unsigned int dmanr)
+{
+	unsigned int control;
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+
+	p_dma_ch->int_enable = 1;
+
+	control = mfdcr(DCRN_DMASR);
+	switch (dmanr) {
+	case 0:
+		control |= DMA_CS0 & DMA_CH0_ERR & DMA_CT0;	
+		break;
+	case 1:
+		control |= DMA_CS1 & DMA_CH1_ERR & DMA_CT1;
+		break;
+	case 2:
+		control |= DMA_CS2 & DMA_CH2_ERR & DMA_CT2;
+		break;
+	case 3:
+		control |= DMA_CS3 & DMA_CH3_ERR & DMA_CT3;
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("clr_dma_status: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	mtdcr(DCRN_DMASR, control);
+	return DMA_STATUS_GOOD;
+}
+
+/*
+ * Maps a given port to a one of the dma
+ * channels
+ */
+int
+map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+{
+	unsigned int map;
+	int connect_port_to_chan, select; 
+
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+	
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map |= (connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map |= (connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("map_dma_port: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+int
+disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan)
+{
+	unsigned int map;
+	int connect_port_to_chan, select; 
+
+	ppc_dma_ch_t *p_dma_ch = &dma_channels[dmanr];
+	
+	connect_port_to_chan = ((ocp_dma & 0x7)*4);
+	
+	select = ocp_dma >> 3;
+	switch (select) {
+	case 0:
+		map = mfdcr(DCRN_DMAS1);
+		map &= ~(connect_port_to_chan << dma_chan);	/* */
+		mtdcr(DCRN_DMAS1, map);
+		break;
+	case 1:
+		map = mfdcr(DCRN_DMAS2);
+		map &= ~(connect_port_to_chan << dma_chan);
+		mtdcr(DCRN_DMAS2, map);
+		break;
+	default:
+#ifdef DEBUG_4xxDMA
+		printk("disable_dma_port: bad channel: %d\n", dmanr);
+#endif
+		return DMA_STATUS_BAD_CHANNEL;
+	}
+	return DMA_STATUS_GOOD;
+}
+
+EXPORT_SYMBOL(disable_dma_port);
+EXPORT_SYMBOL(map_dma_port);
+EXPORT_SYMBOL(clr_dma_status);
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/prom.c linuxppc-2.5-benh/arch/ppc/syslib/prom.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/prom.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/prom.c	2003-11-05 08:33:47.000000000 +0000
@@ -160,7 +160,7 @@ finish_device_tree(void)
 			   match on /chosen.interrupt_controller */
 			if ((name != NULL
 			     && strcmp(name, "interrupt-controller") == 0)
-			    || (ic != NULL && iclen == 0)) {
+			    || (ic != NULL && iclen == 0 && strcmp(name, "AppleKiwi"))) {
 				if (n == 0)
 					dflt_interrupt_controller = np;
 				++n;
@@ -217,7 +217,7 @@ finish_node(struct device_node *np, unsi
 		ifunc = interpret_macio_props;
 	else if (!strcmp(np->type, "isa"))
 		ifunc = interpret_isa_props;
-	else if (!strcmp(np->name, "uni-n"))
+	else if (!strcmp(np->name, "uni-n") || !strcmp(np->name, "u3"))
 		ifunc = interpret_root_props;
 	else if (!((ifunc == interpret_dbdma_props
 		    || ifunc == interpret_macio_props)
@@ -431,10 +431,21 @@ finish_node_interrupts(struct device_nod
 		 * This doesn't cope with the general case of multiple
 		 * cascaded interrupt controllers, but then neither will
 		 * irq.c at the moment either.  -- paulus
+		 * The G5 triggers that code, I add a machine test. On
+		 * those machines, we want to offset interrupts from the
+		 * second openpic by 128 -- BenH
 		 */
-		if (num_interrupt_controllers > 1 && ic != NULL
+		if (_machine != _MACH_Pmac && num_interrupt_controllers > 1
+		    && ic != NULL
 		    && get_property(ic, "interrupt-parent", NULL) == NULL)
 			offset = 16;
+		else if (_machine == _MACH_Pmac && num_interrupt_controllers > 1
+			 && ic != NULL && ic->parent != NULL) {
+			char *name = get_property(ic->parent, "name", NULL);
+			if (name && !strcmp(name, "u3"))
+				offset = 128;
+		}
+
 		np->intrs[i].line = irq[0] + offset;
 		if (n > 1)
 			np->intrs[i].sense = irq[1];
@@ -1212,8 +1223,6 @@ find_parent_pci_resource(struct pci_dev*
  * Request an OF device resource. Currently handles child of PCI devices,
  * or other nodes attached to the root node. Ultimately, put some
  * link to resources in the OF node.
- * WARNING: out_resource->name should be initialized before calling this
- * function.
  */
 struct resource* __openfirmware
 request_OF_resource(struct device_node* node, int index, const char* name_postfix)
@@ -1276,7 +1285,7 @@ release_OF_resource(struct device_node* 
 {
 	struct pci_dev* pcidev;
 	u8 pci_bus, pci_devfn;
-	unsigned long iomask;
+	unsigned long iomask, start, end;
 	struct device_node* nd;
 	struct resource* parent;
 	struct resource *res = NULL;
@@ -1305,18 +1314,23 @@ release_OF_resource(struct device_node* 
 	if (pcidev)
 		parent = find_parent_pci_resource(pcidev, &node->addrs[index]);
 	if (!parent) {
-		printk(KERN_WARNING "request_OF_resource(%s), parent not found\n",
+		printk(KERN_WARNING "release_OF_resource(%s), parent not found\n",
 			node->name);
 		return -ENODEV;
 	}
 
-	/* Find us in the parent */
+	/* Find us in the parent and its childs */
 	res = parent->child;
+	start = node->addrs[index].address;
+	end = start + node->addrs[index].size - 1;
 	while (res) {
-		if (res->start == node->addrs[index].address &&
-		    res->end == (res->start + node->addrs[index].size - 1))
+		if (res->start == start && res->end == end &&
+		    (res->flags & IORESOURCE_BUSY))
 		    	break;
-		res = res->sibling;
+		if (res->start <= start && res->end >= end)
+			res = res->child;
+		else
+			res = res->sibling;
 	}
 	if (!res)
 		return -ENODEV;
diff -purN /dev/shm/linux-2.5/arch/ppc/syslib/prom_init.c linuxppc-2.5-benh/arch/ppc/syslib/prom_init.c
--- /dev/shm/linux-2.5/arch/ppc/syslib/prom_init.c	2003-09-26 23:31:59.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/syslib/prom_init.c	2003-11-14 08:01:14.000000000 +0000
@@ -260,6 +260,74 @@ prom_next_node(phandle *nodep)
 	}
 }
 
+#ifdef CONFIG_POWER4
+/*
+ * Set up a hash table with a set of entries in it to map the
+ * first 64MB of RAM.  This is used on 64-bit machines since
+ * some of them don't have BATs.
+ */
+
+static inline void make_pte(unsigned long htab, unsigned int hsize,
+			    unsigned int va, unsigned int pa, int mode)
+{
+	unsigned int *pteg;
+	unsigned int hash, i, vsid;
+
+	vsid = ((va >> 28) * 0x111) << 12;
+	hash = ((va ^ vsid) >> 5) & 0x7fff80;
+	pteg = (unsigned int *)(htab + (hash & (hsize - 1)));
+	for (i = 0; i < 8; ++i, pteg += 4) {
+		if ((pteg[1] & 1) == 0) {
+			pteg[1] = vsid | ((va >> 16) & 0xf80) | 1;
+			pteg[3] = pa | mode;
+			break;
+		}
+	}
+}
+
+extern unsigned long _SDR1;
+extern PTE *Hash;
+extern unsigned long Hash_size;
+
+static void __init
+prom_alloc_htab(void)
+{
+	unsigned int hsize;
+	unsigned long htab;
+	unsigned int addr;
+
+	/*
+	 * Because of OF bugs we can't use the "claim" client
+	 * interface to allocate memory for the hash table.
+	 * This code is only used on 64-bit PPCs, and the only
+	 * 64-bit PPCs at the moment are RS/6000s, and their
+	 * OF is based at 0xc00000 (the 12M point), so we just
+	 * arbitrarily use the 0x800000 - 0xc00000 region for the
+	 * hash table.
+	 *  -- paulus.
+	 */
+	hsize = 4 << 20;	/* POWER4 has no BATs */
+	htab = (8 << 20);
+	call_prom("claim", 3, 1, htab, hsize, 0);
+	Hash = (void *)(htab + KERNELBASE);
+	Hash_size = hsize;
+	_SDR1 = htab + __ilog2(hsize) - 18;
+
+	/*
+	 * Put in PTEs for the first 64MB of RAM
+	 */
+	memset((void *)htab, 0, hsize);
+	for (addr = 0; addr < 0x4000000; addr += 0x1000)
+		make_pte(htab, hsize, addr + KERNELBASE, addr,
+			 _PAGE_ACCESSED | _PAGE_COHERENT | PP_RWXX);
+#if 0 /* DEBUG stuff mapping the SCC */
+	make_pte(htab, hsize, 0x80013000, 0x80013000,
+		 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
+#endif
+}
+#endif /* CONFIG_POWER4 */
+
+
 /*
  * If we have a display that we don't know how to drive,
  * we will want to try to execute OF's open method for it
@@ -433,14 +501,31 @@ setup_disp_fake_bi(ihandle dp)
 	if (strcmp(name, "valkyrie") == 0)
 		address += 0x1000;
 
+	prom_print("address:");
+	prom_print_hex(address);
+	prom_print("\n");
+
 #ifdef CONFIG_POWER4
-	extern int boot_text_mapped;
-	btext_setup_display(width, height, depth, pitch, address);
-	boot_text_mapped = 0;
-#else
+	{
+		extern boot_infos_t disp_bi;
+		unsigned long va, pa, i, offset;
+       		va = 0x90000000;
+		pa = address & 0xfffff000ul;
+		offset = address & 0x00000fff;
+
+		for (i=0; i<0x4000; i++) {  
+			make_pte((unsigned long)Hash - KERNELBASE, Hash_size, va, pa, 
+				 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
+			va += 0x1000;
+			pa += 0x1000;
+		}
+		btext_setup_display(width, height, depth, pitch, 0x90000000 | offset);
+		disp_bi.dispDeviceBase = (u8 *)address;
+	}
+#else /* CONFIG_POWER4 */
 	btext_setup_display(width, height, depth, pitch, address);
 	btext_prepare_BAT();
-#endif
+#endif /* CONFIG_POWER4 */
 #endif /* CONFIG_BOOTX_TEXT */
 }
 
@@ -648,72 +733,6 @@ prom_hold_cpus(unsigned long mem)
 	}
 }
 
-#ifdef CONFIG_POWER4
-/*
- * Set up a hash table with a set of entries in it to map the
- * first 64MB of RAM.  This is used on 64-bit machines since
- * some of them don't have BATs.
- * We assume the PTE will fit in the primary PTEG.
- */
-
-static inline void make_pte(unsigned long htab, unsigned int hsize,
-			    unsigned int va, unsigned int pa, int mode)
-{
-	unsigned int *pteg;
-	unsigned int hash, i, vsid;
-
-	vsid = ((va >> 28) * 0x111) << 12;
-	hash = ((va ^ vsid) >> 5) & 0x7fff80;
-	pteg = (unsigned int *)(htab + (hash & (hsize - 1)));
-	for (i = 0; i < 8; ++i, pteg += 4) {
-		if ((pteg[1] & 1) == 0) {
-			pteg[1] = vsid | ((va >> 16) & 0xf80) | 1;
-			pteg[3] = pa | mode;
-			break;
-		}
-	}
-}
-
-extern unsigned long _SDR1;
-extern PTE *Hash;
-extern unsigned long Hash_size;
-
-static void __init
-prom_alloc_htab(void)
-{
-	unsigned int hsize;
-	unsigned long htab;
-	unsigned int addr;
-
-	/*
-	 * Because of OF bugs we can't use the "claim" client
-	 * interface to allocate memory for the hash table.
-	 * This code is only used on 64-bit PPCs, and the only
-	 * 64-bit PPCs at the moment are RS/6000s, and their
-	 * OF is based at 0xc00000 (the 12M point), so we just
-	 * arbitrarily use the 0x800000 - 0xc00000 region for the
-	 * hash table.
-	 *  -- paulus.
-	 */
-	hsize = 4 << 20;	/* POWER4 has no BATs */
-	htab = (8 << 20);
-	call_prom("claim", 3, 1, htab, hsize, 0);
-	Hash = (void *)(htab + KERNELBASE);
-	Hash_size = hsize;
-	_SDR1 = htab + __ilog2(hsize) - 18;
-
-	/*
-	 * Put in PTEs for the first 64MB of RAM
-	 */
-	cacheable_memzero((void *)htab, hsize);
-	for (addr = 0; addr < 0x4000000; addr += 0x1000)
-		make_pte(htab, hsize, addr + KERNELBASE, addr,
-			 _PAGE_ACCESSED | _PAGE_COHERENT | PP_RWXX);
-	make_pte(htab, hsize, 0x80013000, 0x80013000,
-		 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
-}
-#endif /* CONFIG_POWER4 */
-
 static void __init
 prom_instantiate_rtas(void)
 {
@@ -836,9 +855,12 @@ prom_init(int r3, int r4, prom_entry pp)
 	 * loaded by an OF bootloader which did set a BAT for us.
 	 * This breaks OF translate so we force phys to be 0.
 	 */
-	if (offset == 0)
+	prom_print("&stext=0x");
+	prom_print_hex(phys);
+	if (offset == 0) {
+		prom_print("(already at 0xc0000000) phys=0\n");
 		phys = 0;
-	else if ((int) call_prom("getprop", 4, 1, prom_chosen, "mmu",
+	} else if ((int) call_prom("getprop", 4, 1, prom_chosen, "mmu",
 				 &prom_mmu, sizeof(prom_mmu)) <= 0) {
 		prom_print(" no MMU found\n");
 	} else if ((int)call_prom_ret("call-method", 4, 4, result, "translate",
@@ -847,6 +869,13 @@ prom_init(int r3, int r4, prom_entry pp)
 	} else {
 		/* We assume the phys. address size is 3 cells */
 		phys = (unsigned long)result[2];
+		prom_print(" phys=0x");
+		prom_print_hex(phys);
+		prom_print("(result[0]=0x");
+		prom_print_hex((unsigned long)result[0]);
+		prom_print(" result[1]=0x");
+		prom_print_hex((unsigned long)result[1]);
+		prom_print(")\n");
 	}
 
 	if (prom_disp_node != 0)
diff -purN /dev/shm/linux-2.5/arch/ppc/xmon/start.c linuxppc-2.5-benh/arch/ppc/xmon/start.c
--- /dev/shm/linux-2.5/arch/ppc/xmon/start.c	2003-09-12 16:26:55.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/xmon/start.c	2003-10-31 06:29:31.000000000 +0000
@@ -35,6 +35,22 @@ static int via_modem;
 static int xmon_use_sccb;
 static struct device_node *channel_node;
 
+/* There are used when hooked via firewire */
+#ifdef CONFIG_XMON_FW
+volatile unsigned int xmon_fw_outbuf_size;
+volatile unsigned char xmon_fw_outbuf[1024];
+volatile unsigned int xmon_fw_oflags;
+volatile unsigned int xmon_fw_iflags;
+volatile unsigned int xmon_fw_idata;
+volatile unsigned int xmon_fw_kick;
+#define XMON_FW_FLAGS_OUT_ENTERED	0x00000001
+#define XMON_FW_FLAGS_OUT_DATA		0x00000002
+#define XMON_FW_FLAGS_OUT_ACK		0x00000004
+#define XMON_FW_FLAGS_IN_ATTACHED	0x00000001
+#define XMON_FW_FLAGS_IN_DATA		0x00000002
+#define XMON_FW_FLAGS_IN_ACK		0x00000004
+#endif /* CONFIG_XMON_FW */
+
 #define TB_SPEED	25000000
 
 static inline unsigned int readtb(void)
@@ -239,6 +255,98 @@ static inline void do_poll_adb(void)
 #endif /* CONFIG_ADB_CUDA */
 }
 
+#ifdef CONFIG_XMON_FW
+static int
+xmon_fw_write(void* ptr, int nb)
+{
+	char* p = (char *)ptr;
+	int c, i;
+
+	while (nb && (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED)) {
+		c = (nb > 1024) ? 1024 : nb;
+		memcpy((void *)xmon_fw_outbuf, p, c);
+		xmon_fw_outbuf_size = c;
+		wmb();
+		xmon_fw_oflags |= XMON_FW_FLAGS_OUT_DATA;
+		wmb();
+		for (i=0; i<1000000; i++) {
+			rmb();
+			if (xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK)
+				break;
+			udelay(1);
+		}
+		xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_DATA;
+		wmb();
+		if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) == 0) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		for (i=0; i<1000000; i++) {
+			rmb();
+			if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) == 0)
+				break;
+			udelay(1);
+		}
+		if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) != 0) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		nb -= c;
+		p += c;
+	}
+	return (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) != 0;
+}
+
+static int
+xmon_fw_read(void* ptr, int nb)
+{
+	int t, on, i;
+	unsigned int k;
+	char c[3];
+	char* p = (char *)ptr;
+	
+	while (nb) {
+		t = 0;
+		on = 0;
+		while(xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) {
+			if (xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA)
+				break;
+			if (--t < 0) {
+				on = 1 - on;
+				c[0] = on? 0xdb: 0x20;
+				c[1] = '\b';
+				if (!xmon_fw_write(c, 2))
+					break;
+				t = 2000000;
+			}
+			rmb();
+		}
+		k = xmon_fw_idata & 0xff;
+		xmon_fw_oflags |= XMON_FW_FLAGS_OUT_ACK;
+		wmb();
+		for (i=0; i<1000000; i++) {
+			rmb();
+			if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA) == 0)
+				break;
+			udelay(1);
+		}
+		if (xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_ACK;
+		wmb();
+		if (on) {
+			c[0] = 0x20; c[1] = '\b';
+			xmon_fw_write(c, 2);
+		}
+		*(p++) = k;
+		nb--;
+	}
+	return (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) != 0;
+}
+#endif /* CONFIG_XMON_FW */
+
 int
 xmon_write(void *handle, void *ptr, int nb)
 {
@@ -255,6 +363,10 @@ xmon_write(void *handle, void *ptr, int 
 			break;
 #endif
 
+#ifdef CONFIG_XMON_FW
+	if (xmon_fw_write(ptr, nb))
+		goto out;
+#endif /* CONFIG_XMON_FW */
 #ifdef CONFIG_BOOTX_TEXT
 	if (use_screen) {
 		/* write it on the screen */
@@ -357,6 +469,10 @@ xmon_read(void *handle, void *ptr, int n
     char *p = ptr;
     int i;
 
+#ifdef CONFIG_XMON_FW
+	if (xmon_fw_read(ptr, nb))
+		return nb;
+#endif /* CONFIG_XMON_FW */		
 #ifdef CONFIG_BOOTX_TEXT
     if (use_screen) {
 	for (i = 0; i < nb; ++i)
@@ -637,11 +753,20 @@ xmon_enter(void)
 		pmu_suspend();
 	}
 #endif
+#ifdef CONFIG_XMON_FW
+	xmon_fw_oflags |= XMON_FW_FLAGS_OUT_ENTERED;
+	wmb();
+	xmon_fw_kick = 0;
+#endif /* CONFIG_XMON_FW */
 }
 
 void
 xmon_leave(void)
 {
+#ifdef CONFIG_XMON_FW
+	xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_ENTERED;
+	wmb();
+#endif /* CONFIG_XMON_FW */
 #ifdef CONFIG_ADB_PMU
 	if (_machine == _MACH_Pmac) {
 		pmu_resume();
diff -purN /dev/shm/linux-2.5/arch/ppc/xmon/xmon.c linuxppc-2.5-benh/arch/ppc/xmon/xmon.c
--- /dev/shm/linux-2.5/arch/ppc/xmon/xmon.c	2003-06-07 09:20:17.000000000 +0000
+++ linuxppc-2.5-benh/arch/ppc/xmon/xmon.c	2003-09-25 11:52:05.000000000 +0000
@@ -15,6 +15,7 @@
 #include <asm/bootx.h>
 #include <asm/machdep.h>
 #include <asm/xmon.h>
+#include <asm/mmu_context.h>
 #ifdef CONFIG_PMAC_BACKLIGHT
 #include <asm/backlight.h>
 #endif
@@ -75,6 +76,7 @@ void print_address(unsigned);
 static int getsp(void);
 static void dump_hash_table(void);
 static void backtrace(struct pt_regs *);
+static void show_processes(void);
 static void excprint(struct pt_regs *);
 static void prregs(struct pt_regs *);
 static void memops(int);
@@ -154,6 +156,8 @@ Commands:\n\
   t	print backtrace\n\
   la	lookup address in system.map\n\
   ls	lookup symbol in system.map\n\
+  p	call procedure\n\
+  P	show processes\n\
   x	exit monitor\n\
 ";
 
@@ -241,6 +245,10 @@ xmon(struct pt_regs *excp)
 	}
 	debugger_fault_handler = 0;
 #endif	/* CONFIG_PMAC_BACKLIGHT */
+#if 1
+	termch = '\n';
+	backtrace(excp);
+#endif
 	cmd = cmds(excp);
 	if (cmd == 's') {
 		xmon_trace[smp_processor_id()] = SSTEP;
@@ -373,7 +381,7 @@ insert_bpts(void)
 		}
 		store_inst((void *) bp->address);
 	}
-#if !defined(CONFIG_8xx)
+#if !defined(CONFIG_8xx) && !defined(CONFIG_POWER4)
 	if (dabr.enabled)
 		set_dabr(dabr.address);
 	if (iabr.enabled)
@@ -388,7 +396,7 @@ remove_bpts(void)
 	struct bpt *bp;
 	unsigned instr;
 
-#if !defined(CONFIG_8xx)
+#if !defined(CONFIG_8xx) && !defined(CONFIG_POWER4)
 	set_dabr(0);
 	set_iabr(0);
 #endif
@@ -521,6 +529,9 @@ cmds(struct pt_regs *excp)
 		case 'T':
 			printtime();
 			break;
+		case 'P':
+			show_processes();
+			break;
 		}
 	}
 }
@@ -710,7 +721,7 @@ bpt_cmds(void)
 
 	cmd = inchar();
 	switch (cmd) {
-#if !defined(CONFIG_8xx)
+#if !defined(CONFIG_8xx) && !defined(CONFIG_POWER4)
 	case 'd':
 		mode = 7;
 		cmd = inchar();
@@ -1676,6 +1687,95 @@ void proccall(void)
 	debugger_fault_handler = 0;
 }
 
+static char
+state_to_char(int state)
+{
+	switch(state) {
+	case TASK_RUNNING:		return 'R';
+	case TASK_INTERRUPTIBLE:	return 'I';
+	case TASK_UNINTERRUPTIBLE:	return 'U';
+	case TASK_ZOMBIE:		return 'Z';
+	case TASK_STOPPED:		return 'S';
+	case TASK_DEAD:			return 'D';
+	}
+	return '?';
+}
+
+static void
+show_processes(void)
+{
+	struct task_struct *p, *g;
+	unsigned pid = -1UL;
+	char c = 0;
+
+	/* We can add some "actions" like 'Pw' to wakeup a process etc... */
+	if (termch != '\n' && termch != 0)
+		c = inchar();
+	if (isxdigit(c) && c != 'd')
+		termch = c;
+	scanhex(&pid);
+
+	if (setjmp(bus_error_jmp) == 0) {
+		debugger_fault_handler = handle_fault;
+		mb();
+		do_each_thread(g, p) {
+			unsigned long ksp;
+			struct pt_regs *regs;
+			if (pid != -1UL && pid != p->pid)
+				goto next;
+			ksp = p->thread.ksp;
+			regs = (struct pt_regs *)(ksp + STACK_FRAME_OVERHEAD);
+			printf("%8d %c %c F:%08x %16s KSP:%08x",
+			       p->pid, p == current ? '*' : ' ', state_to_char(p->state), p->flags, p->comm, ksp);
+			if (p->thread.regs)
+				printf(" USP:%08lx UPC:%08lx",
+					p->thread.regs->nip, p->thread.regs->link);
+			printf("\n");
+			if (c == 'd') {
+				/* Add more to detailed report infos...
+				 */
+				printf("comm          : %s\n", p->comm);
+				printf("lock_depth    : %d\n", p->lock_depth);
+				printf("prio          : %d\n", p->prio);
+				printf("static_prio   : %d\n", p->static_prio);
+				printf("mm            : %08x\n", p->mm);
+				if (p->thread.regs) {
+					printf("userland sp   : %08x\n", p->thread.regs->gpr[1]);
+					printf("userland pc   : %08x\n", p->thread.regs->nip);
+					printf("userland lr   : %08x\n", p->thread.regs->link);
+				}
+				if (p->mm) {
+					printf(" mm_users     : %d\n", p->mm->mm_users);
+					printf(" mm_count     : %d\n", p->mm->mm_count);
+					printf(" map_count    : %d\n", p->mm->map_count);
+					printf(" context      : %08x\n", p->mm->context);
+					printf(" VSID 0x0*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x00000000));
+					printf(" VSID 0x1*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x10000000));
+					printf(" VSID 0x2*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x20000000));
+					printf(" VSID 0x3*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x30000000));
+					printf(" VSID 0x4*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x40000000));
+					printf(" VSID 0x5*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x50000000));
+					printf(" VSID 0x6*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x60000000));
+					printf(" VSID 0x7*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x70000000));
+					printf(" VSID 0x8*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x80000000));
+					printf(" VSID 0x9*    : %08x\n", CTX_TO_VSID(p->mm->context, 0x90000000));
+					printf(" VSID 0xa*    : %08x\n", CTX_TO_VSID(p->mm->context, 0xa0000000));
+					printf(" VSID 0xb*    : %08x\n", CTX_TO_VSID(p->mm->context, 0xb0000000));
+				}
+				printf("registers:\n");
+				prregs(regs);
+				backtrace(regs);
+			}
+		next:
+			;
+		} while_each_thread(g, p);
+	} else {
+		printf("*** %x exception occurred\n", fault_except);
+	}
+	debugger_fault_handler = 0;
+}
+
+
 /* Input scanning routines */
 int
 skipbl(void)
diff -purN /dev/shm/linux-2.5/drivers/Kconfig linuxppc-2.5-benh/drivers/Kconfig
--- /dev/shm/linux-2.5/drivers/Kconfig	2004-01-15 10:34:16.000000000 +0000
+++ linuxppc-2.5-benh/drivers/Kconfig	2004-01-21 00:29:21.000000000 +0000
@@ -26,6 +26,8 @@ source "drivers/ieee1394/Kconfig"
 
 source "drivers/message/i2o/Kconfig"
 
+source "drivers/macintosh/Kconfig"
+
 source "net/Kconfig"
 
 source "drivers/isdn/Kconfig"
diff -purN /dev/shm/linux-2.5/drivers/Makefile linuxppc-2.5-benh/drivers/Makefile
--- /dev/shm/linux-2.5/drivers/Makefile	2003-08-24 14:59:26.000000000 +0000
+++ linuxppc-2.5-benh/drivers/Makefile	2003-08-25 20:03:35.000000000 +0000
@@ -20,6 +20,8 @@ obj-$(CONFIG_PARPORT)		+= parport/
 obj-y				+= base/ block/ misc/ net/ media/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-$(CONFIG_ATM)		+= atm/
+# macintosh (on PPC at least) comes before ide & scsi for proper
+# interfaces ordering
 obj-$(CONFIG_PPC_PMAC)		+= macintosh/
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_FC4)		+= fc4/
diff -purN /dev/shm/linux-2.5/drivers/base/bus.c linuxppc-2.5-benh/drivers/base/bus.c
--- /dev/shm/linux-2.5/drivers/base/bus.c	2003-09-30 15:59:35.000000000 +0000
+++ linuxppc-2.5-benh/drivers/base/bus.c	2003-10-14 07:28:05.000000000 +0000
@@ -8,7 +8,7 @@
  *
  */
 
-#undef DEBUG
+#define DEBUG
 
 #include <linux/device.h>
 #include <linux/module.h>
diff -purN /dev/shm/linux-2.5/drivers/block/genhd.c linuxppc-2.5-benh/drivers/block/genhd.c
--- /dev/shm/linux-2.5/drivers/block/genhd.c	2004-02-04 05:34:23.000000000 +0000
+++ linuxppc-2.5-benh/drivers/block/genhd.c	2004-02-05 10:07:32.000000000 +0000
@@ -223,6 +223,7 @@ struct gendisk *get_gendisk(dev_t dev, i
 	struct kobject *kobj = kobj_lookup(bdev_map, dev, part);
 	return  kobj ? to_disk(kobj) : NULL;
 }
+EXPORT_SYMBOL(get_gendisk);
 
 #ifdef CONFIG_PROC_FS
 /* iterator */
diff -purN /dev/shm/linux-2.5/drivers/block/swim3.c linuxppc-2.5-benh/drivers/block/swim3.c
--- /dev/shm/linux-2.5/drivers/block/swim3.c	2003-08-07 09:25:24.000000000 +0000
+++ linuxppc-2.5-benh/drivers/block/swim3.c	2003-08-24 08:31:29.000000000 +0000
@@ -24,7 +24,10 @@
 #include <linux/delay.h>
 #include <linux/fd.h>
 #include <linux/ioctl.h>
+#include <linux/blkdev.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
 #include <asm/io.h>
 #include <asm/dbdma.h>
 #include <asm/prom.h>
@@ -144,7 +147,7 @@ struct swim3 {
 #define RELAX		3	/* also eject in progress */
 #define READ_DATA_0	4
 #define TWOMEG_DRIVE	5
-#define SINGLE_SIDED	6
+#define SINGLE_SIDED	6	/* drive or diskette is 4MB type? */
 #define DRIVE_PRESENT	7
 #define DISK_IN		8
 #define WRITE_PROT	9
@@ -184,6 +187,7 @@ struct floppy_state {
 	int	req_sector;	/* sector number ditto */
 	int	scount;		/* # sectors we're transferring at present */
 	int	retries;
+	int	settle_time;
 	int	secpercyl;	/* disk geometry information */
 	int	secpertrack;
 	int	total_secs;
@@ -232,8 +236,9 @@ static void setup_transfer(struct floppy
 static void act(struct floppy_state *fs);
 static void scan_timeout(unsigned long data);
 static void seek_timeout(unsigned long data);
+static void settle_timeout(unsigned long data);
 static void xfer_timeout(unsigned long data);
-static void swim3_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t swim3_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 /*static void fd_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs);*/
 static int grab_drive(struct floppy_state *fs, enum swim_state state,
 		      int interruptible);
@@ -274,7 +279,6 @@ static void swim3_action(struct floppy_s
 	udelay(2);
 	out_8(&sw->select, sw->select & ~LSTRB);
 	udelay(1);
-	out_8(&sw->select, RELAX);
 }
 
 static int swim3_readbit(struct floppy_state *fs, int bit)
@@ -283,9 +287,8 @@ static int swim3_readbit(struct floppy_s
 	int stat;
 
 	swim3_select(fs, bit);
-	udelay(10);
+	udelay(1);
 	stat = in_8(&sw->status);
-	out_8(&sw->select, RELAX);
 	return (stat & DATA) == 0;
 }
 
@@ -374,13 +377,13 @@ static void set_timeout(struct floppy_st
 static inline void scan_track(struct floppy_state *fs)
 {
 	volatile struct swim3 *sw = fs->swim3;
-	int xx;
 
 	swim3_select(fs, READ_DATA_0);
-	xx = sw->intr;		/* clear SEEN_SECTOR bit */
+	in_8(&sw->intr);		/* clear SEEN_SECTOR bit */
+	in_8(&sw->error);
+	out_8(&sw->intr_enable, SEEN_SECTOR);
 	out_8(&sw->control_bis, DO_ACTION);
 	/* enable intr when track found */
-	out_8(&sw->intr_enable, ERROR_INTR | SEEN_SECTOR);
 	set_timeout(fs, HZ, scan_timeout);	/* enable timeout */
 }
 
@@ -395,12 +398,14 @@ static inline void seek_track(struct flo
 		swim3_action(fs, SEEK_NEGATIVE);
 		sw->nseek = -n;
 	}
-	fs->expect_cyl = (fs->cur_cyl > 0)? fs->cur_cyl + n: -1;
+	fs->expect_cyl = (fs->cur_cyl >= 0)? fs->cur_cyl + n: -1;
 	swim3_select(fs, STEP);
-	out_8(&sw->control_bis, DO_SEEK);
+	in_8(&sw->error);
 	/* enable intr when seek finished */
-	out_8(&sw->intr_enable, ERROR_INTR | SEEK_DONE);
-	set_timeout(fs, HZ/2, seek_timeout);	/* enable timeout */
+	out_8(&sw->intr_enable, SEEK_DONE);
+	out_8(&sw->control_bis, DO_SEEK);
+	set_timeout(fs, 3*HZ, seek_timeout);	/* enable timeout */
+	fs->settle_time = 0;
 }
 
 static inline void init_dma(struct dbdma_cmd *cp, int cmd,
@@ -448,18 +453,21 @@ static inline void setup_transfer(struct
 	}
 	++cp;
 	out_le16(&cp->command, DBDMA_STOP);
+	out_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);
+	in_8(&sw->error);
+	out_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);
+	if (rq_data_dir(fd_req) == WRITE)
+		out_8(&sw->control_bis, WRITE_SECTORS);
+	in_8(&sw->intr);
 	out_le32(&dr->control, (RUN << 16) | RUN);
-	out_8(&sw->control_bis,
-	      (rq_data_dir(fd_req) == WRITE? WRITE_SECTORS: 0) | DO_ACTION);
 	/* enable intr when transfer complete */
-	out_8(&sw->intr_enable, ERROR_INTR | TRANSFER_DONE);
+	out_8(&sw->intr_enable, TRANSFER_DONE);
+	out_8(&sw->control_bis, DO_ACTION);
 	set_timeout(fs, 2*HZ, xfer_timeout);	/* enable timeout */
 }
 
 static void act(struct floppy_state *fs)
 {
-	volatile struct swim3 *sw = fs->swim3;
-
 	for (;;) {
 		switch (fs->state) {
 		case idle:
@@ -492,20 +500,10 @@ static void act(struct floppy_state *fs)
 			return;
 
 		case settling:
-			/* wait for SEEK_COMPLETE to become true */
-			swim3_select(fs, SEEK_COMPLETE);
-			udelay(10);
-			out_8(&sw->intr_enable, ERROR_INTR | DATA_CHANGED);
-			in_8(&sw->intr);	/* clear DATA_CHANGED */
-			if (in_8(&sw->status) & DATA) {
-				/* seek_complete is not yet true */
-				set_timeout(fs, HZ/2, seek_timeout);
-				return;
-			}
-			out_8(&sw->intr_enable, 0);
-			in_8(&sw->intr);
-			fs->state = locating;
-			break;
+			/* check for SEEK_COMPLETE after 30ms */
+			fs->settle_time = (HZ + 32) / 33;
+			set_timeout(fs, fs->settle_time, settle_timeout);
+			return;
 
 		case do_transfer:
 			if (fs->cur_cyl != fs->req_cyl) {
@@ -537,7 +535,7 @@ static void scan_timeout(unsigned long d
 	volatile struct swim3 *sw = fs->swim3;
 
 	fs->timeout_pending = 0;
-	out_8(&sw->control_bic, DO_ACTION);
+	out_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);
 	out_8(&sw->select, RELAX);
 	out_8(&sw->intr_enable, 0);
 	fs->cur_cyl = -1;
@@ -557,20 +555,34 @@ static void seek_timeout(unsigned long d
 	volatile struct swim3 *sw = fs->swim3;
 
 	fs->timeout_pending = 0;
-	if (fs->state == settling) {
-		printk(KERN_ERR "swim3: MSI sel=%x ctrl=%x stat=%x intr=%x ie=%x\n",
-		       sw->select, sw->control, sw->status, sw->intr, sw->intr_enable);
-	}
 	out_8(&sw->control_bic, DO_SEEK);
 	out_8(&sw->select, RELAX);
 	out_8(&sw->intr_enable, 0);
-	if (fs->state == settling && swim3_readbit(fs, SEEK_COMPLETE)) {
-		/* printk(KERN_DEBUG "swim3: missed settling interrupt\n"); */
+	printk(KERN_ERR "swim3: seek timeout\n");
+	end_request(fd_req, 0);
+	fs->state = idle;
+	start_request(fs);
+}
+
+static void settle_timeout(unsigned long data)
+{
+	struct floppy_state *fs = (struct floppy_state *) data;
+	volatile struct swim3 *sw = fs->swim3;
+
+	fs->timeout_pending = 0;
+	if (swim3_readbit(fs, SEEK_COMPLETE)) {
+		out_8(&sw->select, RELAX);
 		fs->state = locating;
 		act(fs);
 		return;
 	}
-	printk(KERN_ERR "swim3: seek timeout\n");
+	out_8(&sw->select, RELAX);
+	if (fs->settle_time < 2*HZ) {
+		++fs->settle_time;
+		set_timeout(fs, 1, settle_timeout);
+		return;
+	}
+	printk(KERN_ERR "swim3: seek settle timeout\n");
 	end_request(fd_req, 0);
 	fs->state = idle;
 	start_request(fs);
@@ -583,9 +595,13 @@ static void xfer_timeout(unsigned long d
 	struct dbdma_regs *dr = fs->dma;
 	struct dbdma_cmd *cp = fs->dma_cmd;
 	unsigned long s;
+	int n;
 
 	fs->timeout_pending = 0;
 	st_le32(&dr->control, RUN << 16);
+	/* We must wait a bit for dbdma to stop */
+	for (n = 0; (in_le32(&dr->status) & ACTIVE) && n < 1000; n++)
+		udelay(1);
 	out_8(&sw->intr_enable, 0);
 	out_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);
 	out_8(&sw->select, RELAX);
@@ -604,7 +620,7 @@ static void xfer_timeout(unsigned long d
 	start_request(fs);
 }
 
-static void swim3_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t swim3_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct floppy_state *fs = (struct floppy_state *) dev_id;
 	volatile struct swim3 *sw = fs->swim3;
@@ -613,18 +629,15 @@ static void swim3_interrupt(int irq, voi
 	struct dbdma_regs *dr;
 	struct dbdma_cmd *cp;
 
-	err = in_8(&sw->error);
 	intr = in_8(&sw->intr);
-#if 0
-	printk("swim3 intr state=%d intr=%x err=%x\n", fs->state, intr, err);
-#endif
+	err = (intr & ERROR_INTR)? in_8(&sw->error): 0;
 	if ((intr & ERROR_INTR) && fs->state != do_transfer)
 		printk(KERN_ERR "swim3_interrupt, state=%d, dir=%lx, intr=%x, err=%x\n",
 		       fs->state, rq_data_dir(fd_req), intr, err);
 	switch (fs->state) {
 	case locating:
 		if (intr & SEEN_SECTOR) {
-			out_8(&sw->control_bic, DO_ACTION);
+			out_8(&sw->control_bic, DO_ACTION | WRITE_SECTORS);
 			out_8(&sw->select, RELAX);
 			out_8(&sw->intr_enable, 0);
 			del_timer(&fs->timeout);
@@ -674,19 +687,33 @@ static void swim3_interrupt(int irq, voi
 	case do_transfer:
 		if ((intr & (ERROR_INTR | TRANSFER_DONE)) == 0)
 			break;
-		dr = fs->dma;
-		cp = fs->dma_cmd;
-		/* We must wait a bit for dbdma to complete */
-		for (n=0; (in_le32(&dr->status) & ACTIVE) && n < 1000; n++)
-			udelay(10);
-		DBDMA_DO_STOP(dr);
 		out_8(&sw->intr_enable, 0);
 		out_8(&sw->control_bic, WRITE_SECTORS | DO_ACTION);
 		out_8(&sw->select, RELAX);
 		del_timer(&fs->timeout);
 		fs->timeout_pending = 0;
+		dr = fs->dma;
+		cp = fs->dma_cmd;
 		if (rq_data_dir(fd_req) == WRITE)
 			++cp;
+		/*
+		 * Check that the main data transfer has finished.
+		 * On writing, the swim3 sometimes doesn't use
+		 * up all the bytes of the postamble, so we can still
+		 * see DMA active here.  That doesn't matter as long
+		 * as all the sector data has been transferred.
+		 */
+		if ((intr & ERROR_INTR) == 0 && cp->xfer_status == 0) {
+			/* wait a little while for DMA to complete */
+			for (n = 0; n < 100; ++n) {
+				if (cp->xfer_status != 0)
+					break;
+				udelay(1);
+				barrier();
+			}
+		}
+		/* turn off DMA */
+		out_le32(&dr->control, (RUN | PAUSE) << 16);
 		stat = ld_le16(&cp->xfer_status);
 		resid = ld_le16(&cp->res_count);
 		if (intr & ERROR_INTR) {
@@ -742,6 +769,7 @@ static void swim3_interrupt(int irq, voi
 	default:
 		printk(KERN_ERR "swim3: don't know what to do in state %d\n", fs->state);
 	}
+	return IRQ_HANDLED;
 }
 
 /*
@@ -793,16 +821,19 @@ static int fd_eject(struct floppy_state 
 	if (err)
 		return err;
 	swim3_action(fs, EJECT);
-	for (n = 2*HZ; n > 0; --n) {
-		if (swim3_readbit(fs, RELAX))
-			break;
+	for (n = 20; n > 0; --n) {
 		if (signal_pending(current)) {
 			err = -EINTR;
 			break;
 		}
+		swim3_select(fs, RELAX);
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(1);
+		if (swim3_readbit(fs, DISK_IN) == 0)
+			break;
 	}
+	swim3_select(fs, RELAX);
+	udelay(150);
 	fs->ejected = 1;
 	release_drive(fs);
 	return err;
@@ -847,29 +878,31 @@ static int floppy_open(struct inode *ino
 	if (fs->ref_count == 0) {
 		if (fs->media_bay && check_media_bay(fs->media_bay, MB_FD))
 			return -ENXIO;
-		out_8(&sw->mode, 0x95);
-		out_8(&sw->control_bic, 0xff);
 		out_8(&sw->setup, S_IBM_DRIVE | S_FCLK_DIV2);
+		out_8(&sw->control_bic, 0xff);
+		out_8(&sw->mode, 0x95);
 		udelay(10);
 		out_8(&sw->intr_enable, 0);
 		out_8(&sw->control_bis, DRIVE_ENABLE | INTR_ENABLE);
 		swim3_action(fs, MOTOR_ON);
 		fs->write_prot = -1;
 		fs->cur_cyl = -1;
-		for (n = HZ; n > 0; --n) {
-			if (swim3_readbit(fs, SEEK_COMPLETE))
+		for (n = 0; n < 2 * HZ; ++n) {
+			if (n >= HZ/30 && swim3_readbit(fs, SEEK_COMPLETE))
 				break;
 			if (signal_pending(current)) {
 				err = -EINTR;
 				break;
 			}
+			swim3_select(fs, RELAX);
 			current->state = TASK_INTERRUPTIBLE;
 			schedule_timeout(1);
 		}
 		if (err == 0 && (swim3_readbit(fs, SEEK_COMPLETE) == 0
 				 || swim3_readbit(fs, DISK_IN) == 0))
 			err = -ENXIO;
-		swim3_action(fs, 9);
+		swim3_action(fs, SETMFM);
+		swim3_select(fs, RELAX);
 
 	} else if (fs->ref_count == -1 || filp->f_flags & O_EXCL)
 		return -EBUSY;
@@ -892,6 +925,7 @@ static int floppy_open(struct inode *ino
 		if (fs->ref_count == 0) {
 			swim3_action(fs, MOTOR_OFF);
 			out_8(&sw->control_bic, DRIVE_ENABLE | INTR_ENABLE);
+			swim3_select(fs, RELAX);
 		}
 		return err;
 	}
@@ -911,6 +945,7 @@ static int floppy_release(struct inode *
 	if (fs->ref_count > 0 && --fs->ref_count == 0) {
 		swim3_action(fs, MOTOR_OFF);
 		out_8(&sw->control_bic, 0xff);
+		swim3_select(fs, RELAX);
 	}
 	return 0;
 }
@@ -933,15 +968,17 @@ static int floppy_revalidate(struct gend
 	sw = fs->swim3;
 	grab_drive(fs, revalidating, 0);
 	out_8(&sw->intr_enable, 0);
-	out_8(&sw->control_bis, DRIVE_ENABLE | INTR_ENABLE);
-	swim3_action(fs, MOTOR_ON);
+	out_8(&sw->control_bis, DRIVE_ENABLE);
+	swim3_action(fs, MOTOR_ON);	/* necessary? */
 	fs->write_prot = -1;
 	fs->cur_cyl = -1;
+	mdelay(1);
 	for (n = HZ; n > 0; --n) {
 		if (swim3_readbit(fs, SEEK_COMPLETE))
 			break;
 		if (signal_pending(current))
 			break;
+		swim3_select(fs, RELAX);
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(1);
 	}
@@ -951,17 +988,14 @@ static int floppy_revalidate(struct gend
 		swim3_action(fs, MOTOR_OFF);
 	else {
 		fs->ejected = 0;
-		swim3_action(fs, 9);
+		swim3_action(fs, SETMFM);
 	}
+	swim3_select(fs, RELAX);
 
 	release_drive(fs);
 	return ret;
 }
 
-static void floppy_off(unsigned int nr)
-{
-}
-
 static struct block_device_operations floppy_fops = {
 	.open		= floppy_open,
 	.release	= floppy_release,
@@ -1104,3 +1138,5 @@ static int swim3_add_device(struct devic
 	
 	return 0;
 }
+
+module_init(swim3_init)
diff -purN /dev/shm/linux-2.5/drivers/char/Kconfig linuxppc-2.5-benh/drivers/char/Kconfig
--- /dev/shm/linux-2.5/drivers/char/Kconfig	2004-02-04 05:33:50.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/Kconfig	2004-02-05 10:07:32.000000000 +0000
@@ -876,6 +876,9 @@ config SONYPI
 	  To compile this driver as a module, choose M here: the
 	  module will be called sonypi.
 
+config IBM_GPIO
+	tristate "IBM GPIO"
+	depends on IBM_OCP
 
 menu "Ftape, the floppy tape device driver"
 
diff -purN /dev/shm/linux-2.5/drivers/char/Makefile linuxppc-2.5-benh/drivers/char/Makefile
--- /dev/shm/linux-2.5/drivers/char/Makefile	2004-01-21 01:50:56.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/Makefile	2004-01-21 06:17:00.000000000 +0000
@@ -54,10 +54,13 @@ obj-$(CONFIG_DTLK) += dtlk.o
 obj-$(CONFIG_R3964) += n_r3964.o
 obj-$(CONFIG_APPLICOM) += applicom.o
 obj-$(CONFIG_SONYPI) += sonypi.o
+obj-$(CONFIG_IBM_GPIO) += ibm_gpio.o
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_GEN_RTC) += genrtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
-ifeq ($(CONFIG_PPC),)
+ifeq ($(CONFIG_GENERIC_NVRAM),y)
+  obj-$(CONFIG_NVRAM) += generic_nvram.o
+else
   obj-$(CONFIG_NVRAM) += nvram.o
 endif
 obj-$(CONFIG_TOSHIBA) += toshiba.o
diff -purN /dev/shm/linux-2.5/drivers/char/drm/drmP.h linuxppc-2.5-benh/drivers/char/drm/drmP.h
--- /dev/shm/linux-2.5/drivers/char/drm/drmP.h	2003-12-29 22:04:51.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/drm/drmP.h	2003-12-31 04:25:12.000000000 +0000
@@ -52,9 +52,10 @@
 #include <linux/file.h>
 #include <linux/pci.h>
 #include <linux/version.h>
-#include <linux/jiffies.h>
+#include <linux/sched.h>
 #include <linux/smp_lock.h>	/* For (un)lock_kernel */
 #include <linux/mm.h>
+#include <linux/pagemap.h>
 #if defined(__alpha__) || defined(__powerpc__)
 #include <asm/pgtable.h> /* For pte_wrprotect */
 #endif
@@ -197,11 +198,7 @@ static inline struct page * vmalloc_to_p
 }
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define DRM_RPR_ARG(vma)
-#else
 #define DRM_RPR_ARG(vma) vma,
-#endif
 
 #define VM_OFFSET(vma) ((vma)->vm_pgoff << PAGE_SHIFT)
 
diff -purN /dev/shm/linux-2.5/drivers/char/drm/drm_drv.h linuxppc-2.5-benh/drivers/char/drm/drm_drv.h
--- /dev/shm/linux-2.5/drivers/char/drm/drm_drv.h	2003-10-22 05:10:14.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/drm/drm_drv.h	2003-11-17 01:29:51.000000000 +0000
@@ -344,6 +344,7 @@ static int DRM(setup)( drm_device_t *dev
 	dev->last_context = 0;
 	dev->last_switch = 0;
 	dev->last_checked = 0;
+	init_timer( &dev->timer );
 	init_waitqueue_head( &dev->context_wait );
 
 	dev->ctx_start = 0;
@@ -623,7 +624,6 @@ static int __init drm_init( void )
 		dev = &(DRM(device)[i]);
 		memset( (void *)dev, 0, sizeof(*dev) );
 		dev->count_lock = SPIN_LOCK_UNLOCKED;
-		init_timer( &dev->timer );
 		sema_init( &dev->struct_sem, 1 );
 
 		if ((DRM(minor)[i] = DRM(stub_register)(DRIVER_NAME, &DRM(fops),dev)) < 0)
diff -purN /dev/shm/linux-2.5/drivers/char/drm/r128_cce.c linuxppc-2.5-benh/drivers/char/drm/r128_cce.c
--- /dev/shm/linux-2.5/drivers/char/drm/r128_cce.c	2003-09-24 23:41:22.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/drm/r128_cce.c	2003-09-27 12:05:22.000000000 +0000
@@ -81,6 +81,8 @@ static u32 r128_cce_microcode[] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 };
 
+int r128_do_wait_for_idle( drm_r128_private_t *dev_priv );
+
 int R128_READ_PLL(drm_device_t *dev, int addr)
 {
 	drm_r128_private_t *dev_priv = dev->dev_private;
@@ -149,7 +151,7 @@ static int r128_do_wait_for_fifo( drm_r1
 	return DRM_ERR(EBUSY);
 }
 
-static int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
+int r128_do_wait_for_idle( drm_r128_private_t *dev_priv )
 {
 	int i, ret;
 
@@ -212,7 +214,7 @@ int r128_do_cce_idle( drm_r128_private_t
 	int i;
 
 	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		if ( GET_RING_HEAD( &dev_priv->ring ) == dev_priv->ring.tail ) {
+		if ( GET_RING_HEAD( dev_priv ) == dev_priv->ring.tail ) {
 			int pm4stat = R128_READ( R128_PM4_STAT );
 			if ( ( (pm4stat & R128_PM4_FIFOCNT_MASK) >=
 			       dev_priv->cce_fifo_size ) &&
@@ -238,7 +240,8 @@ static void r128_do_cce_start( drm_r128_
 	r128_do_wait_for_idle( dev_priv );
 
 	R128_WRITE( R128_PM4_BUFFER_CNTL,
-		    dev_priv->cce_mode | dev_priv->ring.size_l2qw );
+		    dev_priv->cce_mode | dev_priv->ring.size_l2qw
+		    | R128_PM4_BUFFER_CNTL_NOUPDATE );
 	R128_READ( R128_PM4_BUFFER_ADDR ); /* as per the sample code */
 	R128_WRITE( R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN );
 
@@ -253,7 +256,6 @@ static void r128_do_cce_reset( drm_r128_
 {
 	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
 	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
-	SET_RING_HEAD( &dev_priv->ring, 0 );
 	dev_priv->ring.tail = 0;
 }
 
@@ -264,7 +266,8 @@ static void r128_do_cce_reset( drm_r128_
 static void r128_do_cce_stop( drm_r128_private_t *dev_priv )
 {
 	R128_WRITE( R128_PM4_MICRO_CNTL, 0 );
-	R128_WRITE( R128_PM4_BUFFER_CNTL, R128_PM4_NONPM4 );
+	R128_WRITE( R128_PM4_BUFFER_CNTL,
+		    R128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE );
 
 	dev_priv->cce_running = 0;
 }
@@ -333,26 +336,6 @@ static void r128_cce_init_ring_buffer( d
 	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, 0 );
 	R128_WRITE( R128_PM4_BUFFER_DL_RPTR, 0 );
 
-	/* DL_RPTR_ADDR is a physical address in AGP space. */
-	SET_RING_HEAD( &dev_priv->ring, 0 );
-
-	if ( !dev_priv->is_pci ) {
-		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
-			    dev_priv->ring_rptr->offset );
-	} else {
-		drm_sg_mem_t *entry = dev->sg;
-		unsigned long tmp_ofs, page_ofs;
-
-		tmp_ofs = dev_priv->ring_rptr->offset - dev->sg->handle;
-		page_ofs = tmp_ofs >> PAGE_SHIFT;
-
-		R128_WRITE( R128_PM4_BUFFER_DL_RPTR_ADDR,
-     			    entry->busaddr[page_ofs]);
-		DRM_DEBUG( "ring rptr: offset=0x%08lx handle=0x%08lx\n",
-			   (unsigned long) entry->busaddr[page_ofs],
-     			   entry->handle + tmp_ofs );
-	}
-
 	/* Set watermark control */
 	R128_WRITE( R128_PM4_BUFFER_WM_CNTL,
 		    ((R128_WATERMARK_L/4) << R128_WMA_SHIFT)
@@ -567,9 +550,6 @@ static int r128_do_init_cce( drm_device_
 #endif
 		dev_priv->cce_buffers_offset = dev->sg->handle;
 
-	dev_priv->ring.head = ((__volatile__ u32 *)
-			       dev_priv->ring_rptr->handle);
-
 	dev_priv->ring.start = (u32 *)dev_priv->cce_ring->handle;
 	dev_priv->ring.end = ((u32 *)dev_priv->cce_ring->handle
 			      + init->ring_size / sizeof(u32));
@@ -580,7 +560,6 @@ static int r128_do_init_cce( drm_device_
 		(dev_priv->ring.size / sizeof(u32)) - 1;
 
 	dev_priv->ring.high_mark = 128;
-	dev_priv->ring.ring_rptr = dev_priv->ring_rptr;
 
 	dev_priv->sarea_priv->last_frame = 0;
 	R128_WRITE( R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame );
@@ -589,8 +568,9 @@ static int r128_do_init_cce( drm_device_
 	R128_WRITE( R128_LAST_DISPATCH_REG,
 		    dev_priv->sarea_priv->last_dispatch );
 
-#if __REALLY_HAVE_SG
+#if __REALLY_HAVE_AGP
 	if ( dev_priv->is_pci ) {
+#endif
 		if (!DRM(ati_pcigart_init)( dev, &dev_priv->phys_pci_gart,
      					    &dev_priv->bus_pci_gart) ) {
 			DRM_ERROR( "failed to init PCI GART!\n" );
@@ -599,6 +579,7 @@ static int r128_do_init_cce( drm_device_
 			return DRM_ERR(ENOMEM);
 		}
 		R128_WRITE( R128_PCI_GART_PAGE, dev_priv->bus_pci_gart );
+#if __REALLY_HAVE_AGP
 	}
 #endif
 
@@ -901,7 +882,7 @@ int r128_wait_ring( drm_r128_private_t *
 	int i;
 
 	for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {
-		r128_update_ring_snapshot( ring );
+		r128_update_ring_snapshot( dev_priv );
 		if ( ring->space >= n )
 			return 0;
 		DRM_UDELAY( 1 );
diff -purN /dev/shm/linux-2.5/drivers/char/drm/r128_drv.h linuxppc-2.5-benh/drivers/char/drm/r128_drv.h
--- /dev/shm/linux-2.5/drivers/char/drm/r128_drv.h	2003-08-02 02:51:32.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/drm/r128_drv.h	2003-09-27 12:05:22.000000000 +0000
@@ -34,8 +34,7 @@
 #ifndef __R128_DRV_H__
 #define __R128_DRV_H__
 
-#define GET_RING_HEAD(ring)		DRM_READ32(  (ring)->ring_rptr, 0 ) /* (ring)->head */
-#define SET_RING_HEAD(ring,val)		DRM_WRITE32( (ring)->ring_rptr, 0, (val) ) /* (ring)->head */
+#define GET_RING_HEAD(dev_priv)		R128_READ( R128_PM4_BUFFER_DL_RPTR )
 
 typedef struct drm_r128_freelist {
    	unsigned int age;
@@ -50,13 +49,11 @@ typedef struct drm_r128_ring_buffer {
 	int size;
 	int size_l2qw;
 
-	volatile u32 *head;
 	u32 tail;
 	u32 tail_mask;
 	int space;
 
 	int high_mark;
-	drm_local_map_t *ring_rptr;
 } drm_r128_ring_buffer_t;
 
 typedef struct drm_r128_private {
@@ -132,14 +129,6 @@ extern drm_buf_t *r128_freelist_get( drm
 
 extern int r128_wait_ring( drm_r128_private_t *dev_priv, int n );
 
-static __inline__ void
-r128_update_ring_snapshot( drm_r128_ring_buffer_t *ring )
-{
-	ring->space = (GET_RING_HEAD( ring ) - ring->tail) * sizeof(u32);
-	if ( ring->space <= 0 )
-		ring->space += ring->size;
-}
-
 extern int r128_do_cce_idle( drm_r128_private_t *dev_priv );
 extern int r128_do_cleanup_cce( drm_device_t *dev );
 extern int r128_do_cleanup_pageflip( drm_device_t *dev );
@@ -279,6 +268,7 @@ extern int r128_cce_indirect( DRM_IOCTL_
 #	define R128_PM4_64PIO_64VCBM_64INDBM	(7  << 28)
 #	define R128_PM4_64BM_64VCBM_64INDBM	(8  << 28)
 #	define R128_PM4_64PIO_64VCPIO_64INDPIO	(15 << 28)
+#	define R128_PM4_BUFFER_CNTL_NOUPDATE	(1 << 27)
 
 #define R128_PM4_BUFFER_WM_CNTL		0x0708
 #	define R128_WMA_SHIFT			0
@@ -403,6 +393,15 @@ extern int R128_READ_PLL(drm_device_t *d
 					 (pkt) | ((n) << 16))
 
 
+static __inline__ void
+r128_update_ring_snapshot( drm_r128_private_t *dev_priv )
+{
+	drm_r128_ring_buffer_t *ring = &dev_priv->ring;
+	ring->space = (GET_RING_HEAD( dev_priv ) - ring->tail) * sizeof(u32);
+	if ( ring->space <= 0 )
+		ring->space += ring->size;
+}
+
 /* ================================================================
  * Misc helper macros
  */
@@ -412,7 +411,7 @@ do {									\
 	drm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;		\
 	if ( ring->space < ring->high_mark ) {				\
 		for ( i = 0 ; i < dev_priv->usec_timeout ; i++ ) {	\
-			r128_update_ring_snapshot( ring );		\
+			r128_update_ring_snapshot( dev_priv );		\
 			if ( ring->space >= ring->high_mark )		\
 				goto __ring_space_done;			\
 			DRM_UDELAY(1);				\
@@ -445,17 +444,10 @@ do {									\
  * Ring control
  */
 
-#if defined(__powerpc__)
-#define r128_flush_write_combine()	(void) GET_RING_HEAD( &dev_priv->ring )
-#else
-#define r128_flush_write_combine()	DRM_WRITEMEMORYBARRIER()
-#endif
-
-
 #define R128_VERBOSE	0
 
 #define RING_LOCALS							\
-	int write; unsigned int tail_mask; volatile u32 *ring;
+	int write, _nr; unsigned int tail_mask; volatile u32 *ring;
 
 #define BEGIN_RING( n ) do {						\
 	if ( R128_VERBOSE ) {						\
@@ -463,9 +455,10 @@ do {									\
 			   (n), __FUNCTION__ );				\
 	}								\
 	if ( dev_priv->ring.space <= (n) * sizeof(u32) ) {		\
+		COMMIT_RING();						\
 		r128_wait_ring( dev_priv, (n) * sizeof(u32) );		\
 	}								\
-	dev_priv->ring.space -= (n) * sizeof(u32);			\
+	_nr = n; dev_priv->ring.space -= (n) * sizeof(u32);		\
 	ring = dev_priv->ring.start;					\
 	write = dev_priv->ring.tail;					\
 	tail_mask = dev_priv->ring.tail_mask;				\
@@ -488,9 +481,23 @@ do {									\
 			dev_priv->ring.start,				\
 			write * sizeof(u32) );				\
 	}								\
-	r128_flush_write_combine();					\
-	dev_priv->ring.tail = write;					\
-	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, write );			\
+	if (((dev_priv->ring.tail + _nr) & tail_mask) != write) {	\
+		DRM_ERROR( 						\
+			"ADVANCE_RING(): mismatch: nr: %x write: %x line: %d\n",	\
+			((dev_priv->ring.tail + _nr) & tail_mask),	\
+			write, __LINE__);				\
+	} else								\
+		dev_priv->ring.tail = write;				\
+} while (0)
+
+#define COMMIT_RING() do {						\
+	if ( R128_VERBOSE ) {						\
+		DRM_INFO( "COMMIT_RING() tail=0x%06x\n",		\
+			dev_priv->ring.tail );				\
+	}								\
+	DRM_MEMORYBARRIER();						\
+	R128_WRITE( R128_PM4_BUFFER_DL_WPTR, dev_priv->ring.tail );	\
+	R128_READ( R128_PM4_BUFFER_DL_WPTR );				\
 } while (0)
 
 #define OUT_RING( x ) do {						\
diff -purN /dev/shm/linux-2.5/drivers/char/drm/r128_state.c linuxppc-2.5-benh/drivers/char/drm/r128_state.c
--- /dev/shm/linux-2.5/drivers/char/drm/r128_state.c	2003-08-02 02:51:32.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/drm/r128_state.c	2003-09-27 12:05:22.000000000 +0000
@@ -45,7 +45,7 @@ static void r128_emit_clip_rects( drm_r1
 	RING_LOCALS;
 	DRM_DEBUG( "    %s\n", __FUNCTION__ );
 
-	BEGIN_RING( 17 );
+	BEGIN_RING( (count < 3? count: 3) * 5 + 2 );
 
 	if ( count >= 1 ) {
 		OUT_RING( CCE_PACKET0( R128_AUX1_SC_LEFT, 3 ) );
@@ -1269,6 +1269,7 @@ int r128_cce_clear( DRM_IOCTL_ARGS )
 		sarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;
 
 	r128_cce_dispatch_clear( dev, &clear );
+	COMMIT_RING();
 
 	/* Make sure we restore the 3D state next time.
 	 */
@@ -1304,8 +1305,10 @@ int r128_do_cleanup_pageflip( drm_device
 	R128_WRITE( R128_CRTC_OFFSET,      dev_priv->crtc_offset );
 	R128_WRITE( R128_CRTC_OFFSET_CNTL, dev_priv->crtc_offset_cntl );
 
-	if (dev_priv->current_page != 0)
+	if (dev_priv->current_page != 0) {
 		r128_cce_dispatch_flip( dev );
+		COMMIT_RING();
+	}
 
 	dev_priv->page_flipping = 0;
 	return 0;
@@ -1330,6 +1333,7 @@ int r128_cce_flip( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_flip( dev );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1351,6 +1355,7 @@ int r128_cce_swap( DRM_IOCTL_ARGS )
 	dev_priv->sarea_priv->dirty |= (R128_UPLOAD_CONTEXT |
 					R128_UPLOAD_MASKS);
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1410,6 +1415,7 @@ int r128_cce_vertex( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_vertex( dev, buf );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1481,6 +1487,7 @@ int r128_cce_indices( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_indices( dev, buf, elts.start, elts.end, count );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1490,6 +1497,7 @@ int r128_cce_blit( DRM_IOCTL_ARGS )
 	drm_device_dma_t *dma = dev->dma;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_blit_t blit;
+	int ret;
 
 	LOCK_TEST_WITH_RETURN( dev, filp );
 
@@ -1507,7 +1515,10 @@ int r128_cce_blit( DRM_IOCTL_ARGS )
 	RING_SPACE_TEST_WITH_RETURN( dev_priv );
 	VB_AGE_TEST_WITH_RETURN( dev_priv );
 
-	return r128_cce_dispatch_blit( filp, dev, &blit );
+	ret = r128_cce_dispatch_blit( filp, dev, &blit );
+
+	COMMIT_RING();
+	return ret;
 }
 
 int r128_cce_depth( DRM_IOCTL_ARGS )
@@ -1515,6 +1526,7 @@ int r128_cce_depth( DRM_IOCTL_ARGS )
 	DRM_DEVICE;
 	drm_r128_private_t *dev_priv = dev->dev_private;
 	drm_r128_depth_t depth;
+	int ret;
 
 	LOCK_TEST_WITH_RETURN( dev, filp );
 
@@ -1523,18 +1535,20 @@ int r128_cce_depth( DRM_IOCTL_ARGS )
 
 	RING_SPACE_TEST_WITH_RETURN( dev_priv );
 
+	ret = DRM_ERR(EINVAL);
 	switch ( depth.func ) {
 	case R128_WRITE_SPAN:
-		return r128_cce_dispatch_write_span( dev, &depth );
+		ret = r128_cce_dispatch_write_span( dev, &depth );
 	case R128_WRITE_PIXELS:
-		return r128_cce_dispatch_write_pixels( dev, &depth );
+		ret = r128_cce_dispatch_write_pixels( dev, &depth );
 	case R128_READ_SPAN:
-		return r128_cce_dispatch_read_span( dev, &depth );
+		ret = r128_cce_dispatch_read_span( dev, &depth );
 	case R128_READ_PIXELS:
-		return r128_cce_dispatch_read_pixels( dev, &depth );
+		ret = r128_cce_dispatch_read_pixels( dev, &depth );
 	}
 
-	return DRM_ERR(EINVAL);
+	COMMIT_RING();
+	return ret;
 }
 
 int r128_cce_stipple( DRM_IOCTL_ARGS )
@@ -1557,6 +1571,7 @@ int r128_cce_stipple( DRM_IOCTL_ARGS )
 
 	r128_cce_dispatch_stipple( dev, mask );
 
+	COMMIT_RING();
 	return 0;
 }
 
@@ -1632,6 +1647,7 @@ int r128_cce_indirect( DRM_IOCTL_ARGS )
 	 */
 	r128_cce_dispatch_indirect( dev, buf, indirect.start, indirect.end );
 
+	COMMIT_RING();
 	return 0;
 }
 
diff -purN /dev/shm/linux-2.5/drivers/char/generic_nvram.c linuxppc-2.5-benh/drivers/char/generic_nvram.c
--- /dev/shm/linux-2.5/drivers/char/generic_nvram.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/generic_nvram.c	2003-11-01 01:36:52.000000000 +0000
@@ -0,0 +1,145 @@
+/*
+ * Generic /dev/nvram driver for architectures providing some
+ * "generic" hooks, that is :
+ *
+ * nvram_read_byte, nvram_write_byte, nvram_sync
+ *
+ * Note that an additional hook is supported for PowerMac only
+ * for getting the nvram "partition" informations
+ *
+ */
+
+#define NVRAM_VERSION "1.1"
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+#include <asm/nvram.h>
+
+#define NVRAM_SIZE	8192
+
+static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
+{
+	lock_kernel();
+	switch (origin) {
+	case 1:
+		offset += file->f_pos;
+		break;
+	case 2:
+		offset += NVRAM_SIZE;
+		break;
+	}
+	if (offset < 0) {
+		unlock_kernel();
+		return -EINVAL;
+	}
+	file->f_pos = offset;
+	unlock_kernel();
+	return file->f_pos;
+}
+
+static ssize_t read_nvram(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	unsigned int i;
+	char __user *p = buf;
+
+	if (verify_area(VERIFY_WRITE, buf, count))
+		return -EFAULT;
+	if (*ppos >= NVRAM_SIZE)
+		return 0;
+	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count)
+		if (__put_user(nvram_read_byte(i), p))
+			return -EFAULT;
+	*ppos = i;
+	return p - buf;
+}
+
+static ssize_t write_nvram(struct file *file, const char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	unsigned int i;
+	const char __user *p = buf;
+	char c;
+
+	if (verify_area(VERIFY_READ, buf, count))
+		return -EFAULT;
+	if (*ppos >= NVRAM_SIZE)
+		return 0;
+	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count) {
+		if (__get_user(c, p))
+			return -EFAULT;
+		nvram_write_byte(c, i);
+	}
+	*ppos = i;
+	return p - buf;
+}
+
+static int nvram_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	switch(cmd) {
+#ifdef CONFIG_PPC_PMAC
+	case OBSOLETE_PMAC_NVRAM_GET_OFFSET:
+		printk(KERN_WARNING "nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\n");
+	case IOC_NVRAM_GET_OFFSET: {
+		int part, offset;
+
+		if (_machine != _MACH_Pmac)
+			return -EINVAL;
+		if (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)
+			return -EFAULT;
+		if (part < pmac_nvram_OF || part > pmac_nvram_NR)
+			return -EINVAL;
+		offset = pmac_get_partition(part);
+		if (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)
+			return -EFAULT;
+		break;
+	}
+#endif /* CONFIG_PPC_PMAC */
+	case IOC_NVRAM_SYNC:
+		nvram_sync();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct file_operations nvram_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= nvram_llseek,
+	.read		= read_nvram,
+	.write		= write_nvram,
+	.ioctl		= nvram_ioctl,
+};
+
+static struct miscdevice nvram_dev = {
+	NVRAM_MINOR,
+	"nvram",
+	&nvram_fops
+};
+
+int __init nvram_init(void)
+{
+	printk(KERN_INFO "Macintosh non-volatile memory driver v%s\n",
+		NVRAM_VERSION);
+	return misc_register(&nvram_dev);
+}
+
+void __exit nvram_cleanup(void)
+{
+        misc_deregister( &nvram_dev );
+}
+
+module_init(nvram_init);
+module_exit(nvram_cleanup);
+MODULE_LICENSE("GPL");
diff -purN /dev/shm/linux-2.5/drivers/char/ibm_gpio.c linuxppc-2.5-benh/drivers/char/ibm_gpio.c
--- /dev/shm/linux-2.5/drivers/char/ibm_gpio.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/ibm_gpio.c	2003-07-21 22:46:25.000000000 +0000
@@ -0,0 +1,380 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *	TODO: devfs
+ *
+ *	Version: 02/01/12 - Armin
+ *			 converted to ocp and using ioremap
+ *
+ *	1.2 02/21/01 - Armin
+ *		minor compiler warning fixes
+ *
+ *	1.3 02/22/01 - Armin
+ *		added apm
+ *
+ *	1.4 05/07/02 - Armin/David Mueller
+ *		coverted to core_ocp[];
+ *
+ *	1.5 05/25/02 - Armin
+ *	 name change from *_driver to *_dev
+ *
+ *	1.6 06/04/02 - Matt Porter
+ *	ioremap paddr. Comment as 4xx generic driver.
+ *	Fix header to be userland safe and locate in
+ *	an accessible area.  Add ioctl to configure
+ *	multiplexed GPIO pins.
+ *
+ *	1.7 07/25/02 - Armin
+ *	added CPM to enable/disable in init/exit
+ *
+ */
+
+#define VUFX "07.25.02"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <linux/ibm_gpio.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ocp.h>
+
+struct miscdevice ibm_gpio_miscdev;
+static struct gpio_regs *gpiop;
+
+#ifdef CONFIG_PM
+static struct pm_dev *pm_gpio;
+
+static int
+gpio_save_state(u32 state)
+{
+	return 0;
+}
+
+static int
+gpio_suspend(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | state);
+	return 0;
+}
+
+static int
+gpio_resume(u32 state)
+{
+	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~state);
+	return 0;
+}
+#endif
+
+int
+ibm_gpio_config(__u32 device, __u32 mask, __u32 data)
+{
+	u32 cfg_reg;
+
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+
+#ifdef CONFIG_40x
+#ifdef DCRN_CHCR0
+	/*
+	 * PPC405 uses CPC0_CR0 to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CHCR0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CHCR0, cfg_reg);
+#endif
+#elif CONFIG_440GP
+	/*
+	 * PPC440GP uses CPC0_GPIO to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CPC0_GPIO);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CPC0_GPIO, cfg_reg);
+#elif CONFIG_440GX
+	/*
+	 * PPC440GX uses SDR0_PFC0 to select multiplexed GPIO pins
+	 */
+	cfg_reg = SDR_READ(DCRN_SDR_PFC0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	SDR_WRITE(DCRN_SDR_PFC0, cfg_reg);
+#else
+#error This driver is only supported on PPC40x and PPC440 CPUs
+#endif
+
+	return 0;
+}
+
+int
+ibm_gpio_tristate(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = (gpiop->tcr & ~mask) | (data & mask);
+	return 0;
+}
+
+int
+ibm_gpio_open_drain(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->odr = (gpiop->odr & ~mask) | (data & mask);
+
+	return 0;
+}
+
+int
+ibm_gpio_in(__u32 device, __u32 mask, volatile __u32 * data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->tcr = gpiop->tcr & ~mask;
+	eieio();
+
+	/*
+	   ** If the previous state was OUT, and gpiop->ir is read once, then the
+	   ** data that was being OUTput will be read.  One way to get the right
+	   ** data is to read gpiop->ir twice.
+	 */
+
+	*data = gpiop->ir;
+	*data = gpiop->ir & mask;
+	eieio();
+	return 0;
+}
+
+int
+ibm_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+#ifdef CONFIG_PM
+	pm_access(pm_gpio);
+#endif
+	gpiop->or = (gpiop->or & ~mask) | (data & mask);
+	eieio();
+	gpiop->tcr = gpiop->tcr | mask;
+	eieio();
+	return 0;
+}
+
+static int
+ibm_gpio_open(struct inode *inode, struct file *file)
+{
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+ibm_gpio_release(struct inode *inode, struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int
+ibm_gpio_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	static struct ibm_gpio_ioctl_data ioctl_data;
+	int status;
+
+	switch (cmd) {
+	case IBMGPIO_IN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		status = ibm_gpio_in(ioctl_data.device,
+				     ioctl_data.mask, &ioctl_data.data);
+		if (status != 0)
+			return status;
+
+		if (copy_to_user((struct ibm_gpio_ioctl_data *) arg,
+				 &ioctl_data, sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		break;
+
+	case IBMGPIO_OUT:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_out(ioctl_data.device,
+				    ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_OPEN_DRAIN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ibm_gpio_open_drain(ioctl_data.device,
+					   ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_TRISTATE:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_tristate(ioctl_data.device,
+					 ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_CFG:
+		if (copy_from_user(&ioctl_data,
+				   (struct ibm_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ibm_gpio_config(ioctl_data.device,
+				ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+	return 0;
+}
+
+static struct file_operations ibm_gpio_fops = {
+	owner:THIS_MODULE,
+	ioctl:ibm_gpio_ioctl,
+	open:ibm_gpio_open,
+	release:ibm_gpio_release,
+};
+
+static int __init
+ibm_gpio_probe(struct ocp_device *ocp)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+
+	ibm_gpio_miscdev.minor = 185;
+	ibm_gpio_miscdev.name = ocp->name;
+	ibm_gpio_miscdev.fops = &ibm_gpio_fops;
+	misc_register(&ibm_gpio_miscdev);
+
+	gpiop = (struct gpio_regs *) ioremap(ocp->paddr,
+			sizeof(struct gpio_regs));
+	printk("GPIO #%d at 0x%lx\n", ocp->num,
+			(unsigned long) gpiop);
+
+
+	return 0;
+}
+
+static void __exit
+ibm_gpio_remove(struct ocp_device *ocp)
+{
+	misc_deregister(&ibm_gpio_miscdev);
+}
+
+static struct ocp_device_id ibm_gpio_ids[] __devinitdata =
+{
+	{ .vendor = OCP_VENDOR_IBM, .device = OCP_FUNC_GPIO },
+	{ .vendor = OCP_VENDOR_INVALID }
+};
+
+static struct ocp_driver ibm_gpio_driver =
+{
+	.name           = "ibm_gpio",
+	.id_table       = ibm_gpio_ids,
+	.probe          = ibm_gpio_probe,
+	.remove         = __devexit_p(ibm_gpio_remove),
+#if defined(CONFIG_PM)
+	.suspend        = NULL,
+	.resume         = NULL,
+#endif
+};
+
+static int __init
+ibm_gpio_init(void)
+{
+	printk("IBM GPIO driver version %s\n", VUFX);
+	return ocp_module_init(&ibm_gpio_driver);
+}
+
+static void __exit
+ibm_gpio_exit(void)
+{
+	ocp_unregister_driver(&ibm_gpio_driver);
+}
+
+module_init(ibm_gpio_init);
+module_exit(ibm_gpio_exit);
+
+EXPORT_SYMBOL(ibm_gpio_tristate);
+EXPORT_SYMBOL(ibm_gpio_open_drain);
+EXPORT_SYMBOL(ibm_gpio_in);
+EXPORT_SYMBOL(ibm_gpio_out);
+
+MODULE_LICENSE("GPL");
diff -purN /dev/shm/linux-2.5/drivers/char/keyboard.c linuxppc-2.5-benh/drivers/char/keyboard.c
--- /dev/shm/linux-2.5/drivers/char/keyboard.c	2004-02-04 05:29:18.000000000 +0000
+++ linuxppc-2.5-benh/drivers/char/keyboard.c	2004-02-05 10:07:32.000000000 +0000
@@ -972,11 +972,6 @@ extern void sun_do_break(void);
 static int emulate_raw(struct vc_data *vc, unsigned int keycode, 
 		       unsigned char up_flag)
 {
-#ifdef CONFIG_MAC_EMUMOUSEBTN
-	if (mac_hid_mouse_emulate_buttons(1, keycode, !up_flag))
-		return 0;
-#endif /* CONFIG_MAC_EMUMOUSEBTN */
-
 	if (keycode > 255 || !x86_keycodes[keycode])
 		return -1; 
 
@@ -1055,6 +1050,11 @@ void kbd_keycode(unsigned int keycode, i
 
 	rep = (down == 2);
 
+#ifdef CONFIG_MAC_EMUMOUSEBTN
+	if (mac_hid_mouse_emulate_buttons(1, keycode, down))
+		return;
+#endif /* CONFIG_MAC_EMUMOUSEBTN */
+
 	if ((raw_mode = (kbd->kbdmode == VC_RAW)))
 		if (emulate_raw(vc, keycode, !down << 7))
 			if (keycode < BTN_MISC)
diff -purN /dev/shm/linux-2.5/drivers/i2c/busses/i2c-keywest.c linuxppc-2.5-benh/drivers/i2c/busses/i2c-keywest.c
--- /dev/shm/linux-2.5/drivers/i2c/busses/i2c-keywest.c	2004-01-19 15:05:40.000000000 +0000
+++ linuxppc-2.5-benh/drivers/i2c/busses/i2c-keywest.c	2004-01-29 23:58:18.000000000 +0000
@@ -26,6 +26,8 @@
     2001/12/13 BenH	New implementation
     2001/12/15 BenH	Add support for "byte" and "quick"
                         transfers. Add i2c_xfer routine.
+    2003/09/21 BenH	Rework state machine with Paulus help
+    2004/01/21 BenH	Merge in Greg KH changes, polled mode is back
 
     My understanding of the various modes supported by keywest are:
 
@@ -67,9 +69,35 @@
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>
+#include <asm/pmac_low_i2c.h>
 
 #include "i2c-keywest.h"
 
+/* Currently, we don't deal with the weird interrupt cascade of the G5
+ * machines with the ppc64 kernel, so use Polled mode on these
+ */
+#ifdef CONFIG_PPC64
+#define POLLED_MODE
+#else
+#undef POLLED_MODE
+#endif
+
+/* Some debug macros */
+#define WRONG_STATE(name) do {\
+		pr_debug("KW: wrong state. Got %s, state: %s (isr: %02x)\n", \
+			 name, __kw_state_names[iface->state], isr);	\
+	} while(0)
+
+#ifdef DEBUG
+static const char *__kw_state_names[] = {
+	"state_idle",
+	"state_addr",
+	"state_read",
+	"state_write",
+	"state_stop",
+	"state_dead"
+};
+#endif /* DEBUG */
 
 MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
 MODULE_DESCRIPTION("I2C driver for Apple's Keywest");
@@ -78,121 +106,154 @@ MODULE_PARM(probe, "i");
 
 static int probe = 0;
 
+#ifdef POLLED_MODE
+/* Don't schedule, the g5 fan controller is too
+ * timing sensitive
+ */
+static u8
+wait_interrupt(struct keywest_iface* iface)
+{
+	int i;
+	u8 isr;
+	
+	for (i = 0; i < 200000; i++) {
+		isr = read_reg(reg_isr) & KW_I2C_IRQ_MASK;
+		if (isr != 0)
+			return isr;
+		udelay(10);
+	}
+	return isr;
+}
+#endif /* POLLED_MODE */
+
 static void
 do_stop(struct keywest_iface* iface, int result)
 {
-	write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_STOP);
+	write_reg(reg_control, KW_I2C_CTL_STOP);
 	iface->state = state_stop;
 	iface->result = result;
 }
 
 /* Main state machine for standard & standard sub mode */
-static int
+static void
 handle_interrupt(struct keywest_iface *iface, u8 isr)
 {
 	int ack;
-	int rearm_timer = 1;
 	
-	pr_debug("handle_interrupt(), got: %x, status: %x, state: %d\n",
-		isr, read_reg(reg_status), iface->state);
-	if (isr == 0 && iface->state != state_stop) {
-		do_stop(iface, -1);
-		return rearm_timer;
-	}
-	if (isr & KW_I2C_IRQ_STOP && iface->state != state_stop) {
-		iface->result = -1;
-		iface->state = state_stop;
-	}
-	switch(iface->state) {
-	case state_addr:
-		if (!(isr & KW_I2C_IRQ_ADDR)) {
-			do_stop(iface, -1);
-			break;
+	if (isr == 0) {
+		if (iface->state != state_stop) {
+			pr_debug("KW: Timeout !\n");
+			do_stop(iface, -EIO);
 		}
-		ack = read_reg(reg_status);
-		pr_debug("ack on set address: %x\n", ack);
-		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
-			do_stop(iface, -1);
-			break;
-		}
-		/* Handle rw "quick" mode */
-		if (iface->datalen == 0)
-			do_stop(iface, 0);
-		else if (iface->read_write == I2C_SMBUS_READ) {
-			iface->state = state_read;
-			if (iface->datalen > 1)
-				write_reg(reg_control, read_reg(reg_control)
-					| KW_I2C_CTL_AAK);
-		} else {
-			iface->state = state_write;
-			pr_debug("write byte: %x\n", *(iface->data));
-			write_reg(reg_data, *(iface->data++));
-			iface->datalen--;
-		}
-		
-		break;
-	case state_read:
-		if (!(isr & KW_I2C_IRQ_DATA)) {
-			do_stop(iface, -1);
-			break;
-		}
-		*(iface->data++) = read_reg(reg_data);
-		pr_debug("read byte: %x\n", *(iface->data-1));
-		iface->datalen--;
-		if (iface->datalen == 0)
-			iface->state = state_stop;
-		else
-			write_reg(reg_control, 0);
-		break;
-	case state_write:
-		if (!(isr & KW_I2C_IRQ_DATA)) {
-			do_stop(iface, -1);
-			break;
+		if (iface->state == state_stop) {
+			ack = read_reg(reg_status);
+			if (!(ack & KW_I2C_STAT_BUSY)) {
+				iface->state = state_idle;
+				write_reg(reg_ier, 0x00);
+#ifndef POLLED_MODE
+				complete(&iface->complete);
+#endif /* POLLED_MODE */
+			}
 		}
-		/* Check ack status */
+		return;
+	}
+
+	if (isr & KW_I2C_IRQ_ADDR) {
 		ack = read_reg(reg_status);
-		pr_debug("ack on data write: %x\n", ack);
+		if (iface->state != state_addr) {
+			write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+			WRONG_STATE("KW_I2C_IRQ_ADDR"); 
+			do_stop(iface, -EIO);
+			return;
+		}
 		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
-			do_stop(iface, -1);
-			break;
+			iface->state = state_stop;		     
+			iface->result = -ENODEV;
+			pr_debug("KW: NAK on address\n");
+		} else {
+			/* Handle rw "quick" mode */
+			if (iface->datalen == 0) {
+				do_stop(iface, 0);
+			} else if (iface->read_write == I2C_SMBUS_READ) {
+				iface->state = state_read;
+				if (iface->datalen > 1)
+					write_reg(reg_control, KW_I2C_CTL_AAK);
+			} else {
+				iface->state = state_write;
+				write_reg(reg_data, *(iface->data++));
+				iface->datalen--;
+			}
 		}
-		if (iface->datalen) {
-			pr_debug("write byte: %x\n", *(iface->data));
-			write_reg(reg_data, *(iface->data++));
+		write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+	}
+
+	if (isr & KW_I2C_IRQ_DATA) {
+		if (iface->state == state_read) {
+			*(iface->data++) = read_reg(reg_data);
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
 			iface->datalen--;
-		} else
-			do_stop(iface, 0);
-		break;
-		
-	case state_stop:
-		if (!(isr & KW_I2C_IRQ_STOP) && (++iface->stopretry) < 10)
-			do_stop(iface, -1);
-		else {
-			rearm_timer = 0;
-			iface->state = state_idle;
-			write_reg(reg_control, 0x00);
-			write_reg(reg_ier, 0x00);
-			complete(&iface->complete);
+			if (iface->datalen == 0)
+				iface->state = state_stop;
+			else if (iface->datalen == 1)
+				write_reg(reg_control, 0);
+		} else if (iface->state == state_write) {
+			/* Check ack status */
+			ack = read_reg(reg_status);
+			if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
+				pr_debug("KW: nack on data write (%x): %x\n",
+				    iface->data[-1], ack);
+				do_stop(iface, -EIO);
+			} else if (iface->datalen) {
+				write_reg(reg_data, *(iface->data++));
+				iface->datalen--;
+			} else {
+				write_reg(reg_control, KW_I2C_CTL_STOP);
+				iface->state = state_stop;
+				iface->result = 0;
+			}
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
+		} else {
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
+			WRONG_STATE("KW_I2C_IRQ_DATA"); 
+			if (iface->state != state_stop)
+				do_stop(iface, -EIO);
 		}
-		break;
 	}
-	
-	write_reg(reg_isr, isr);
 
-	return rearm_timer;
+	if (isr & KW_I2C_IRQ_STOP) {
+		write_reg(reg_isr, KW_I2C_IRQ_STOP);
+		if (iface->state != state_stop) {
+			WRONG_STATE("KW_I2C_IRQ_STOP");
+			iface->result = -EIO;
+		}
+		iface->state = state_idle;
+		write_reg(reg_ier, 0x00);
+#ifndef POLLED_MODE
+		complete(&iface->complete);
+#endif /* POLLED_MODE */			
+	}
+
+	if (isr & KW_I2C_IRQ_START)
+		write_reg(reg_isr, KW_I2C_IRQ_START);
 }
 
+#ifndef POLLED_MODE
+
 /* Interrupt handler */
 static irqreturn_t
 keywest_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct keywest_iface *iface = (struct keywest_iface *)dev_id;
+	unsigned long flags;
 
-	spin_lock(&iface->lock);
+	spin_lock_irqsave(&iface->lock, flags);
 	del_timer(&iface->timeout_timer);
-	if (handle_interrupt(iface, read_reg(reg_isr)))
-		mod_timer(&iface->timeout_timer, jiffies + POLL_TIMEOUT);
-	spin_unlock(&iface->lock);
+	handle_interrupt(iface, read_reg(reg_isr));
+	if (iface->state != state_idle) {
+		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
+		add_timer(&iface->timeout_timer);
+	}
+	spin_unlock_irqrestore(&iface->lock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -200,14 +261,20 @@ static void
 keywest_timeout(unsigned long data)
 {
 	struct keywest_iface *iface = (struct keywest_iface *)data;
+	unsigned long flags;
 
 	pr_debug("timeout !\n");
-	spin_lock_irq(&iface->lock);
-	if (handle_interrupt(iface, read_reg(reg_isr)))
-		mod_timer(&iface->timeout_timer, jiffies + POLL_TIMEOUT);
-	spin_unlock(&iface->lock);
+	spin_lock_irqsave(&iface->lock, flags);
+	handle_interrupt(iface, read_reg(reg_isr));
+	if (iface->state != state_idle) {
+		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
+		add_timer(&iface->timeout_timer);
+	}
+	spin_unlock_irqrestore(&iface->lock, flags);
 }
 
+#endif /* POLLED_MODE */
+
 /*
  * SMBUS-type transfer entrypoint
  */
@@ -228,46 +295,54 @@ keywest_smbus_xfer(	struct i2c_adapter*	
 	int rc = 0;
 
 	if (iface->state == state_dead)
-		return -1;
+		return -ENXIO;
 		
 	/* Prepare datas & select mode */
 	iface->cur_mode &= ~KW_I2C_MODE_MODE_MASK;
 	switch (size) {
-	    case I2C_SMBUS_QUICK:
+        case I2C_SMBUS_QUICK:
 	    	len = 0;
 	    	buffer = NULL;
 	    	iface->cur_mode |= KW_I2C_MODE_STANDARD;
 	    	break;
-	    case I2C_SMBUS_BYTE:
+        case I2C_SMBUS_BYTE:
 	    	len = 1;
 	    	buffer = &data->byte;
 	    	iface->cur_mode |= KW_I2C_MODE_STANDARD;
 	    	break;
-	    case I2C_SMBUS_BYTE_DATA:
+        case I2C_SMBUS_BYTE_DATA:
 	    	len = 1;
 	    	buffer = &data->byte;
 	    	iface->cur_mode |= KW_I2C_MODE_STANDARDSUB;
 	    	break;
-	    case I2C_SMBUS_WORD_DATA:
+        case I2C_SMBUS_WORD_DATA:
 	    	len = 2;
 	    	cur_word = cpu_to_le16(data->word);
 	    	buffer = (u8 *)&cur_word;
 	    	iface->cur_mode |= KW_I2C_MODE_STANDARDSUB;
 		break;
-	    case I2C_SMBUS_BLOCK_DATA:
+        case I2C_SMBUS_BLOCK_DATA:
 	    	len = data->block[0];
 	    	buffer = &data->block[1];
 	    	iface->cur_mode |= KW_I2C_MODE_STANDARDSUB;
 		break;
-	    default:
+        default:
 	    	return -1;
 	}
 
+	/* Turn a standardsub read into a combined mode access */
+ 	if (read_write == I2C_SMBUS_READ
+ 	    && (iface->cur_mode & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_STANDARDSUB) {
+ 		iface->cur_mode &= ~KW_I2C_MODE_MODE_MASK;
+ 		iface->cur_mode |= KW_I2C_MODE_COMBINED;
+ 	}
+
 	/* Original driver had this limitation */
 	if (len > 32)
 		len = 32;
 
-	down(&iface->sem);
+	if (pmac_low_i2c_lock(iface->node))
+		return -ENXIO;
 
 	pr_debug("chan: %d, addr: 0x%x, transfer len: %d, read: %d\n",
 		chan->chan_no, addr, len, read_write == I2C_SMBUS_READ);
@@ -276,12 +351,11 @@ keywest_smbus_xfer(	struct i2c_adapter*	
 	iface->datalen = len;
 	iface->state = state_addr;
 	iface->result = 0;
-	iface->stopretry = 0;
 	iface->read_write = read_write;
 	
 	/* Setup channel & clear pending irqs */
-	write_reg(reg_mode, iface->cur_mode | (chan->chan_no << 4));
 	write_reg(reg_isr, read_reg(reg_isr));
+	write_reg(reg_mode, iface->cur_mode | (chan->chan_no << 4));
 	write_reg(reg_status, 0);
 
 	/* Set up address and r/w bit */
@@ -293,15 +367,31 @@ keywest_smbus_xfer(	struct i2c_adapter*	
 	    || (iface->cur_mode & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_COMBINED)
 		write_reg(reg_subaddr, command);
 
+#ifndef POLLED_MODE
 	/* Arm timeout */
-	mod_timer(&iface->timeout_timer, jiffies + POLL_TIMEOUT);
+	iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
+	add_timer(&iface->timeout_timer);
+#endif
 
 	/* Start sending address & enable interrupt*/
-	write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_XADDR);
+	write_reg(reg_control, KW_I2C_CTL_XADDR);
 	write_reg(reg_ier, KW_I2C_IRQ_MASK);
 
-	/* Wait interrupt operations completion */
+#ifdef POLLED_MODE
+	pr_debug("using polled mode...\n");
+	/* State machine, to turn into an interrupt handler */
+	while(iface->state != state_idle) {
+		unsigned long flags;
+
+		u8 isr = wait_interrupt(iface);
+		spin_lock_irqsave(&iface->lock, flags);
+		handle_interrupt(iface, isr);
+		spin_unlock_irqrestore(&iface->lock, flags);
+	}
+#else /* POLLED_MODE */
+	pr_debug("using interrupt mode...\n");
 	wait_for_completion(&iface->complete);	
+#endif /* POLLED_MODE */	
 
 	rc = iface->result;	
 	pr_debug("transfer done, result: %d\n", rc);
@@ -310,7 +400,7 @@ keywest_smbus_xfer(	struct i2c_adapter*	
 	    	data->word = le16_to_cpu(cur_word);
 	
 	/* Release sem */
-	up(&iface->sem);
+	pmac_low_i2c_unlock(iface->node);
 	
 	return rc;
 }
@@ -329,7 +419,11 @@ keywest_xfer(	struct i2c_adapter *adap,
 	int i, completed;
 	int rc = 0;
 
-	down(&iface->sem);
+	if (iface->state == state_dead)
+		return -ENXIO;
+
+	if (pmac_low_i2c_lock(iface->node))
+		return -ENXIO;
 
 	/* Set adapter to standard mode */
 	iface->cur_mode &= ~KW_I2C_MODE_MODE_MASK;
@@ -360,7 +454,6 @@ keywest_xfer(	struct i2c_adapter *adap,
 		iface->datalen = pmsg->len;
 		iface->state = state_addr;
 		iface->result = 0;
-		iface->stopretry = 0;
 		if (pmsg->flags & I2C_M_RD)
 			iface->read_write = I2C_SMBUS_READ;
 		else
@@ -373,15 +466,27 @@ keywest_xfer(	struct i2c_adapter *adap,
 			(addr << 1) |
 			((iface->read_write == I2C_SMBUS_READ) ? 0x01 : 0x00));
 
+#ifndef POLLED_MODE
 		/* Arm timeout */
-		mod_timer(&iface->timeout_timer, jiffies + POLL_TIMEOUT);
+		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
+		add_timer(&iface->timeout_timer);
+#endif
 
 		/* Start sending address & enable interrupt*/
-		write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_XADDR);
 		write_reg(reg_ier, KW_I2C_IRQ_MASK);
+		write_reg(reg_control, KW_I2C_CTL_XADDR);
 
-		/* Wait interrupt operations completion */
+#ifdef POLLED_MODE
+		pr_debug("using polled mode...\n");
+		/* State machine, to turn into an interrupt handler */
+		while(iface->state != state_idle) {
+			u8 isr = wait_interrupt(iface);
+			handle_interrupt(iface, isr);
+		}
+#else /* POLLED_MODE */
+		pr_debug("using interrupt mode...\n");
 		wait_for_completion(&iface->complete);	
+#endif /* POLLED_MODE */	
 
 		rc = iface->result;
 		if (rc == 0)
@@ -390,7 +495,7 @@ keywest_xfer(	struct i2c_adapter *adap,
 	}
 
 	/* Release sem */
-	up(&iface->sem);
+	pmac_low_i2c_unlock(iface->node);
 
 	return completed;
 }
@@ -416,19 +521,23 @@ static struct i2c_algorithm keywest_algo
 static int
 create_iface(struct device_node *np, struct device *dev)
 {
-	unsigned long steps, *psteps, *prate;
+	unsigned long steps;
 	unsigned bsteps, tsize, i, nchan, addroffset;
 	struct keywest_iface* iface;
+	u32 *psteps, *prate;
 	int rc;
 
-	psteps = (unsigned long *)get_property(np, "AAPL,address-step", NULL);
+	if (pmac_low_i2c_lock(np))
+		return -ENODEV;
+
+	psteps = (u32 *)get_property(np, "AAPL,address-step", NULL);
 	steps = psteps ? (*psteps) : 0x10;
 
 	/* Hrm... maybe we can be smarter here */
 	for (bsteps = 0; (steps & 0x01) == 0; bsteps++)
 		steps >>= 1;
 
-	if (!strcmp(np->parent->name, "uni-n")) {
+	if (np->parent->name[0] == 'u') {
 		nchan = 2;
 		addroffset = 3;
 	} else {
@@ -441,12 +550,13 @@ create_iface(struct device_node *np, str
 	iface = (struct keywest_iface *) kmalloc(tsize, GFP_KERNEL);
 	if (iface == NULL) {
 		printk(KERN_ERR "i2c-keywest: can't allocate inteface !\n");
+		pmac_low_i2c_unlock(np);
 		return -ENOMEM;
 	}
 	memset(iface, 0, tsize);
-	init_MUTEX(&iface->sem);
 	spin_lock_init(&iface->lock);
 	init_completion(&iface->complete);
+	iface->node = of_node_get(np);
 	iface->bsteps = bsteps;
 	iface->chan_count = nchan;
 	iface->state = state_idle;
@@ -458,16 +568,19 @@ create_iface(struct device_node *np, str
 	if (iface->base == 0) {
 		printk(KERN_ERR "i2c-keywest: can't map inteface !\n");
 		kfree(iface);
+		pmac_low_i2c_unlock(np);
 		return -ENOMEM;
 	}
 
+#ifndef POLLED_MODE
 	init_timer(&iface->timeout_timer);
 	iface->timeout_timer.function = keywest_timeout;
 	iface->timeout_timer.data = (unsigned long)iface;
+#endif
 
 	/* Select interface rate */
 	iface->cur_mode = KW_I2C_MODE_100KHZ;
-	prate = (unsigned long *)get_property(np, "AAPL,i2c-rate", NULL);
+	prate = (u32 *)get_property(np, "AAPL,i2c-rate", NULL);
 	if (prate) switch(*prate) {
 	case 100:
 		iface->cur_mode = KW_I2C_MODE_100KHZ;
@@ -480,11 +593,11 @@ create_iface(struct device_node *np, str
 		break;
 	default:
 		printk(KERN_WARNING "i2c-keywest: unknown rate %ldKhz, using 100KHz\n",
-			*prate);
+		       (long)*prate);
 	}
 	
-	/* Select standard sub mode */
-	iface->cur_mode |= KW_I2C_MODE_STANDARDSUB;
+	/* Select standard mode by default */
+	iface->cur_mode |= KW_I2C_MODE_STANDARD;
 	
 	/* Write mode */
 	write_reg(reg_mode, iface->cur_mode);
@@ -493,14 +606,17 @@ create_iface(struct device_node *np, str
 	write_reg(reg_ier, 0x00);
 	write_reg(reg_isr, KW_I2C_IRQ_MASK);
 
+#ifndef POLLED_MODE
 	/* Request chip interrupt */	
-	rc = request_irq(iface->irq, keywest_irq, 0, "keywest i2c", iface);
+	rc = request_irq(iface->irq, keywest_irq, SA_INTERRUPT, "keywest i2c", iface);
 	if (rc) {
 		printk(KERN_ERR "i2c-keywest: can't get IRQ %d !\n", iface->irq);
 		iounmap((void *)iface->base);
 		kfree(iface);
+		pmac_low_i2c_unlock(np);
 		return -ENODEV;
 	}
+#endif /* POLLED_MODE */
 
 	dev_set_drvdata(dev, iface);
 	
@@ -539,6 +655,7 @@ create_iface(struct device_node *np, str
 	printk(KERN_INFO "Found KeyWest i2c on \"%s\", %d channel%s, stepping: %d bits\n",
 		np->parent->name, nchan, nchan > 1 ? "s" : "", bsteps);
 		
+	pmac_low_i2c_unlock(np);
 	return 0;
 }
 
@@ -549,8 +666,10 @@ dispose_iface(struct device *dev)
 	int i, rc;
 	
 	/* Make sure we stop all activity */
-	down(&iface->sem);
+	if (pmac_low_i2c_lock(iface->node))
+		return -ENODEV;
 
+#ifndef POLLED_MODE
 	spin_lock_irq(&iface->lock);
 	while (iface->state != state_idle) {
 		spin_unlock_irq(&iface->lock);
@@ -558,10 +677,14 @@ dispose_iface(struct device *dev)
 		schedule_timeout(HZ/10);
 		spin_lock_irq(&iface->lock);
 	}
+#endif /* POLLED_MODE */
 	iface->state = state_dead;
+#ifndef POLLED_MODE
 	spin_unlock_irq(&iface->lock);
 	free_irq(iface->irq, iface);
-	up(&iface->sem);
+#endif /* POLLED_MODE */
+
+	pmac_low_i2c_unlock(iface->node);
 
 	/* Release all channels */
 	for (i=0; i<iface->chan_count; i++) {
@@ -576,6 +699,7 @@ dispose_iface(struct device *dev)
 	}
 	iounmap((void *)iface->base);
 	dev_set_drvdata(dev, NULL);
+	of_node_put(iface->node);
 	kfree(iface);
 
 	return 0;
@@ -634,8 +758,8 @@ static struct of_platform_driver i2c_key
 static int __init
 i2c_keywest_init(void)
 {
-	macio_register_driver(&i2c_keywest_macio_driver);
 	of_register_driver(&i2c_keywest_of_platform_driver);
+	macio_register_driver(&i2c_keywest_macio_driver);
 
 	return 0;
 }
@@ -643,8 +767,8 @@ i2c_keywest_init(void)
 static void __exit
 i2c_keywest_cleanup(void)
 {
-	macio_unregister_driver(&i2c_keywest_macio_driver);
 	of_unregister_driver(&i2c_keywest_of_platform_driver);
+	macio_unregister_driver(&i2c_keywest_macio_driver);
 }
 
 module_init(i2c_keywest_init);
diff -purN /dev/shm/linux-2.5/drivers/i2c/busses/i2c-keywest.h linuxppc-2.5-benh/drivers/i2c/busses/i2c-keywest.h
--- /dev/shm/linux-2.5/drivers/i2c/busses/i2c-keywest.h	2003-09-22 14:58:42.000000000 +0000
+++ linuxppc-2.5-benh/drivers/i2c/busses/i2c-keywest.h	2003-12-31 03:57:54.000000000 +0000
@@ -51,20 +51,19 @@ typedef enum {
 /* Physical interface */
 struct keywest_iface
 {
+	struct device_node	*node;
 	unsigned long		base;
 	unsigned		bsteps;
 	int			irq;
-	struct semaphore	sem;
 	spinlock_t		lock;
-	struct keywest_chan*	channels;
+	struct keywest_chan	*channels;
 	unsigned		chan_count;
 	u8			cur_mode;
 	char			read_write;
-	u8*			data;
+	u8			*data;
 	unsigned		datalen;
 	int			state;
 	int			result;
-	int			stopretry;
 	struct timer_list	timeout_timer;
 	struct completion	complete;
 };
@@ -98,8 +97,7 @@ static inline void __write_reg(struct ke
 {
 	out_8(((volatile u8 *)iface->base)
 		+ (((unsigned)reg) << iface->bsteps), val);
-	(void)__read_reg(iface, reg);
-	udelay(10);
+	(void)__read_reg(iface, reg_subaddr);
 }
 
 #define write_reg(reg, val)	__write_reg(iface, reg, val) 
diff -purN /dev/shm/linux-2.5/drivers/ide/Kconfig linuxppc-2.5-benh/drivers/ide/Kconfig
--- /dev/shm/linux-2.5/drivers/ide/Kconfig	2004-02-01 18:09:12.000000000 +0000
+++ linuxppc-2.5-benh/drivers/ide/Kconfig	2004-02-04 07:27:07.000000000 +0000
@@ -1013,6 +1013,15 @@ config IDE_EXT_DIRECT
 
 endchoice
 
+config BLK_DEV_IDE_STB04xxx
+	bool "STB04xxx (Redwood-5) IDE support"
+	depends on BLK_DEV_IDE && REDWOOD_5
+	help
+	  This option provides support for IDE on IBM STB04xxx Redwood-5
+	  systems.
+
+	  If unsure, say N.
+
 # no isa -> no vlb
 config IDE_CHIPSETS
 	bool "Other IDE chipset support"
diff -purN /dev/shm/linux-2.5/drivers/ide/ide.c linuxppc-2.5-benh/drivers/ide/ide.c
--- /dev/shm/linux-2.5/drivers/ide/ide.c	2004-02-04 19:20:06.000000000 +0000
+++ linuxppc-2.5-benh/drivers/ide/ide.c	2004-02-05 10:07:33.000000000 +0000
@@ -2256,6 +2256,12 @@ static void __init probe_for_hwifs (void
 		pnpide_init(1);
 	}
 #endif /* CONFIG_BLK_DEV_IDEPNP */
+#ifdef CONFIG_BLK_DEV_STD
+	{
+		extern void std_ide_cntl_scan(void);
+		std_ide_cntl_scan();
+	}
+#endif /* CONFIG_BLK_DEV_STD */
 }
 
 /*
diff -purN /dev/shm/linux-2.5/drivers/ide/ppc/ibm_ocp_ide.c linuxppc-2.5-benh/drivers/ide/ppc/ibm_ocp_ide.c
--- /dev/shm/linux-2.5/drivers/ide/ppc/ibm_ocp_ide.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/ide/ppc/ibm_ocp_ide.c	2003-06-03 21:59:11.000000000 +0000
@@ -0,0 +1,903 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: Armin Kuster <akuster@mvista.com>
+ *      MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: ibm_ocp_ide.c
+ *
+ *    Description:
+ *
+ *    Based on ocp_stbxxxx.c
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include "../ide-timing.h"
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/ppc4xx_dma.h>
+
+#include "ide_modes.h"
+
+#define IDE_VER			"2.0"
+ppc_dma_ch_t dma_ch;
+
+/* use DMA channel 2 for IDE DMA operations */
+#define IDE_DMACH	2	/* 2nd DMA channel */
+#define IDE_DMA_INT	6	/* IDE dma channel 2 interrupt */
+
+#define WMODE	0		/* default to DMA line mode */
+#define PIOMODE	0
+
+#define MK_TIMING(AS, DIOP, DIOY, DH) \
+	((FIT((AS),    0, 15) << 27) | \
+	 (FIT((DIOP),  0, 63) << 20) | \
+	 (FIT((DIOY),  0, 63) << 13) | \
+	 (FIT((DH),    0,  7) << 9))
+
+#define UTIMING_SETHLD	(EZ(20 /*tACK*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_ENV	(EZ(20 /*tENV*/, SYS_CLOCK_NS) - 1 /*fixed cycles*/)
+#define UTIMING_SS	(EZ(50 /*tSS */, SYS_CLOCK_NS) - 3 /*fixed cycles*/)
+#define MK_UTIMING(CYC, RP) \
+	((FIT(UTIMING_SETHLD, 0, 15) << 27) | \
+	 (FIT(UTIMING_ENV,    0, 15) << 22) | \
+	 (FIT((CYC),          0, 15) << 17) | \
+	 (FIT((RP),           0, 63) << 10) | \
+	 (FIT(UTIMING_SS,     0, 15) << 5)  | \
+	 1 /* Turn on Ultra DMA */)
+
+/* Define the period of the STB clock used to generate the
+ * IDE bus timing.  The clock is actually 63 MHz, but it
+ * get rounded in a favorable direction.
+ */
+#define IDE_SYS_FREQ	63	/* MHz */
+#define SYS_CLOCK_NS	(1000 / IDE_SYS_FREQ)
+
+struct whold_timing {
+	short mode;
+	short whold;
+};
+
+static struct whold_timing whold_timing[] = {
+
+	{XFER_UDMA_5, 0},
+	{XFER_UDMA_4, 0},
+	{XFER_UDMA_3, 0},
+
+	{XFER_UDMA_2, 0},
+	{XFER_UDMA_1, 0},
+	{XFER_UDMA_0, 0},
+
+	{XFER_UDMA_SLOW, 0},
+
+	{XFER_MW_DMA_2, 0},
+	{XFER_MW_DMA_1, 0},
+	{XFER_MW_DMA_0, 0},
+
+	{XFER_SW_DMA_2, 0},
+	{XFER_SW_DMA_1, 0},
+	{XFER_SW_DMA_0, 10},
+
+	{XFER_PIO_5, 10},
+	{XFER_PIO_4, 10},
+	{XFER_PIO_3, 15},
+
+	{XFER_PIO_2, 20},
+	{XFER_PIO_1, 30},
+	{XFER_PIO_0, 50},
+
+	{XFER_PIO_SLOW,},
+
+	{-1}
+};
+
+/* The interface doesn't have register/PIO timing for each device,
+ * but rather "fast" and "slow" timing.  We have to determeine
+ * which is the "fast" device based upon their capability.
+ */
+static int pio_mode[2];
+
+/* Structure of the memory mapped IDE control.
+*/
+typedef struct ide_regs {
+	unsigned int si_stat;	/* IDE status */
+	unsigned int si_intenable;	/* IDE interrupt enable */
+	unsigned int si_control;	/* IDE control */
+	unsigned int pad0[0x3d];
+	unsigned int si_c0rt;	/* Chan 0 Register transfer timing */
+	unsigned int si_c0fpt;	/* Chan 0 Fast PIO transfer timing */
+	unsigned int si_c0timo;	/* Chan 0 timeout */
+	unsigned int pad1[2];
+	unsigned int si_c0d0u;	/* Chan 0 UDMA transfer timing */
+#define si_c0d0m si_c0d0u	/* Chan 0 Multiword DMA timing */
+	unsigned int pad2;
+	unsigned int si_c0d1u;	/* Chan 0 dev 1 UDMA timing */
+#define si_c0d1m si_c0d1u	/* Chan 0 dev 1 Multiword DMA timing */
+	unsigned int si_c0c;	/* Chan 0 Control */
+	unsigned int si_c0s0;	/* Chan 0 Status 0 */
+	unsigned int si_c0ie;	/* Chan 0 Interrupt Enable */
+	unsigned int si_c0s1;	/* Chan 0 Status 0 */
+	unsigned int pad4[4];
+	unsigned int si_c0dcm;	/* Chan 0 DMA Command */
+	unsigned int si_c0tb;	/* Chan 0 PRD Table base address */
+	unsigned int si_c0dct;	/* Chan 0 DMA Count */
+	unsigned int si_c0da;	/* Chan 0 DMA Address */
+	unsigned int si_c0sr;	/* Chan 0 Slew Rate Output Control */
+	unsigned char pad5[0xa2];
+	unsigned short si_c0adc;	/* Chan 0 Alt status/control */
+	unsigned char si_c0d;	/* Chan 0 data */
+	unsigned char si_c0ef;	/* Chan 0 error/features */
+	unsigned char si_c0sct;	/* Chan 0 sector count */
+	unsigned char si_c0sn;	/* Chan 0 sector number */
+	unsigned char si_c0cl;	/* Chan 0 cylinder low */
+	unsigned char si_c0ch;	/* Chan 0 cylinder high */
+	unsigned char si_c0dh;	/* Chan 0 device/head */
+	unsigned char si_c0scm;	/* Chan 0 status/command */
+} ide_t;
+
+/* The structure of the PRD entry.  The address must be word aligned,
+ * and the count must be an even number of bytes.
+ */
+typedef struct {
+	unsigned int prd_physptr;
+	unsigned int prd_count;	/* Count only in lower 16 bits */
+} prd_entry_t;
+#define PRD_EOT		(uint)0x80000000	/* Set in prd_count */
+
+/* The number of PRDs required in a single transfer from the upper IDE
+ * functions.  I believe the maximum number is 128, but most seem to
+ * code to 256.  It's probably best to keep this under one page......
+ */
+#define NUM_PRD	256
+
+static volatile ide_t *idp;
+/* Virtual and physical address of the PRD page.
+*/
+static prd_entry_t *prd_table;
+static dma_addr_t prd_phys;
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static int ocp_ide_dma_off(ide_drive_t * drive);
+
+/* The STB04 has a fixed number of cycles that get added in
+ * regardless.  Adjust an ide_timing struct to accommodate that.
+ */
+static void
+ocp_ide_adjust_timing(struct ide_timing *t)
+{
+	t->setup -= 2;
+	t->act8b -= 1;
+	t->rec8b -= 1;
+	t->active -= 1;
+	t->recover -= 1;
+}
+
+/* this iis barrowed from ide_timing_find_mode so we can find the proper 
+ * whold parameter 
+ */
+
+static short
+whold_timing_find_mode(short speed)
+{
+	struct whold_timing *t;
+
+	for (t = whold_timing; t->mode != speed; t++)
+		if (t->mode < 0)
+			return 0;
+	return t->whold;
+}
+
+static int
+ocp_ide_set_drive(ide_drive_t * drive, unsigned char speed)
+{
+	ide_drive_t *peer;
+	struct ide_timing d, p, merge, *fast;
+	int fast_device;
+	unsigned int ctl;
+	volatile unsigned int *dtiming;
+
+	if (speed != XFER_PIO_SLOW && speed != drive->current_speed)
+		if (ide_config_drive_speed(drive, speed))
+			printk(KERN_WARNING
+			       "ide%d: Drive %d didn't accept speed setting. Oh, well.\n",
+			       drive->dn >> 1, drive->dn & 1);
+
+	ide_timing_compute(drive, speed, &d, SYS_CLOCK_NS, SYS_CLOCK_NS);
+	ocp_ide_adjust_timing(&d);
+
+	/* This should be set somewhere else, but it isn't.....
+	 */
+	drive->dn = ((drive->select.all & 0x10) != 0);
+	peer = HWIF(drive)->drives + (~drive->dn & 1);
+
+	if (peer->present) {
+		ide_timing_compute(peer, peer->current_speed, &p,
+				   SYS_CLOCK_NS, SYS_CLOCK_NS);
+		ocp_ide_adjust_timing(&p);
+		ide_timing_merge(&p, &d, &merge,
+				 IDE_TIMING_8BIT | IDE_TIMING_SETUP);
+	} else {
+		merge = d;
+	}
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	drive->current_speed = speed;
+
+	/* Now determine which drive is faster, and set up the
+	 * interface timing.  It would sure be nice if they would
+	 * have just had the timing registers for each device......
+	 */
+	if (drive->dn & 1)
+		pio_mode[1] = (int) speed;
+	else
+		pio_mode[0] = (int) speed;
+
+	if (pio_mode[0] > pio_mode[1])
+		fast_device = 0;
+	else
+		fast_device = 1;
+
+	/* Now determine which of the drives
+	 * the first call we only know one device, and on subsequent
+	 * calls the user may manually change drive parameters.
+	 * Make timing[0] the fast device and timing[1] the slow.
+	 */
+	if (fast_device == (drive->dn & 1))
+		fast = &d;
+	else
+		fast = &p;
+
+	/* Now we know which device is the fast one and which is
+	 * the slow one.  The merged timing goes into the "regular"
+	 * timing registers and represents the slower of both times.
+	 */
+
+	idp->si_c0rt = MK_TIMING(merge.setup, merge.act8b,
+				 merge.rec8b,
+				 whold_timing_find_mode(merge.mode));
+
+	idp->si_c0fpt = MK_TIMING(fast->setup, fast->act8b,
+				  fast->rec8b,
+				  whold_timing_find_mode(fast->mode));
+
+	/* Tell the interface which drive is the fast one.
+	 */
+	ctl = idp->si_c0c;	/* Chan 0 Control */
+	ctl &= ~0x10000000;
+	ctl |= fast_device << 28;
+	idp->si_c0c = ctl;
+
+	/* Set up DMA timing.
+	 */
+	if ((speed & XFER_MODE) != XFER_PIO) {
+		/* NOTE: si_c0d0m and si_c0d0u are two different names
+		 * for the same register.  Whether it is used for
+		 * Multi-word DMA timings or Ultra DMA timings is
+		 * determined by the LSB written into it.  This is also
+		 * true for si_c0d1m and si_c0d1u.  */
+		if (drive->dn & 1)
+			dtiming = &(idp->si_c0d1m);
+		else
+			dtiming = &(idp->si_c0d0m);
+
+		if ((speed & XFER_MODE) == XFER_UDMA) {
+			static const int tRP[] = {
+				EZ(160, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(125, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(100, SYS_CLOCK_NS) - 2 /*fixed cycles */ ,
+				EZ(85, SYS_CLOCK_NS) - 2	/*fixed cycles */
+			};
+			static const int NUMtRP =
+			    (sizeof (tRP) / sizeof (tRP[0]));
+			*dtiming =
+			    MK_UTIMING(d.udma,
+				       tRP[FIT(speed & 0xf, 0, NUMtRP - 1)]);
+		} else {
+			/* Multi-word DMA.  Note that d.recover/2 is an
+			 * approximation of MAX(tH, MAX(tJ, tN)) */
+			*dtiming = MK_TIMING(d.setup, d.active,
+					     d.recover, d.recover / 2);
+		}
+		drive->using_dma = 1;
+	}
+
+	return 0;
+}
+
+static void
+ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+}
+
+/*
+ * Fill in the next PRD entry.
+ */
+
+static int ocp_ide_build_prd_entry(prd_entry_t **table, unsigned int paddr, 
+				   unsigned int size, int *count)
+{
+
+	/*
+	 * Note that one PRD entry can transfer
+	 * at most 65535 bytes.
+	 */
+
+	while (size) {
+		unsigned int tc = (size < 0xfe00) ? size : 0xfe00;
+
+		if (++(*count) >= NUM_PRD) {
+		  printk(KERN_WARNING "DMA table too small\n");
+			return 0;	/* revert to PIO for this request */
+		}
+		(*table)->prd_physptr = (paddr & 0xfffffffe);
+
+		if ((*table)->prd_physptr & 0xF) {
+			printk(KERN_WARNING "DMA buffer not 16 byte aligned.\n");
+			return 0;	/* revert to PIO for this request */
+		}
+		
+		(*table)->prd_count = (tc & 0xfffe);
+		paddr += tc;
+		size -= tc;
+		++(*table);
+	}
+
+	return 1;
+}
+
+
+static int
+ocp_ide_build_dmatable(ide_drive_t * drive, int wr)
+{
+	prd_entry_t *table;
+	int count = 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long size, vaddr, paddr;
+	unsigned long prd_size, prd_paddr = 0;
+	struct bio_vec *bvec, *bvprv;
+	struct bio *bio;
+	int i;
+
+	table = prd_table;
+
+	bvprv = NULL;
+	rq_for_each_bio(bio, rq) {
+		bio_for_each_segment(bvec, bio, i) {
+			paddr = bvec_to_phys(bvec);
+			vaddr = (unsigned long) __va(paddr);
+			size = bvec->bv_len;
+			if (wr)
+				consistent_sync((void *)vaddr, 
+						size, PCI_DMA_TODEVICE);
+			else
+				consistent_sync((void *)vaddr,
+						size, PCI_DMA_FROMDEVICE);
+
+			if (!BIOVEC_PHYS_MERGEABLE(bvprv, bvec)) {
+				if (ocp_ide_build_prd_entry(&table, 
+							    prd_paddr,
+							    prd_size,
+							    &count) == 0)
+					return 0; /* use PIO */
+				prd_paddr = 0;
+			}
+
+			if (prd_paddr == 0) {
+				prd_paddr = paddr;
+				prd_size = size;
+			} else {
+			  prd_size += size;
+			}
+
+			bvprv = bvec;
+		} /* segments in bio */
+	} /* bios in rq */
+
+	if (prd_paddr) {
+		if (ocp_ide_build_prd_entry(&table, 
+					    prd_paddr,
+					    prd_size,
+					    &count) == 0)
+			return 0; /* use PIO */
+	}
+
+	/* Add the EOT to the last table entry.
+	 */
+	if (count) {
+		table--;
+		table->prd_count |= PRD_EOT;
+	} else {
+		printk(KERN_DEBUG "%s: empty DMA table?\n", drive->name);
+	}
+
+	return 1;
+}
+
+/*
+ * ocp_ide_dma_intr() is the handler for disk read/write DMA interrupts
+ * This is taken directly from ide-dma.c, which we can't use because
+ * it requires PCI support.
+ */
+ide_startstop_t
+ocp_ide_dma_intr(ide_drive_t * drive)
+{
+	int i;
+	byte stat, dma_stat;
+
+	dma_stat = HWIF(drive)->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);	/* get drive status */
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (!dma_stat) {
+			struct request *rq = HWGROUP(drive)->rq;
+			rq = HWGROUP(drive)->rq;
+			for (i = rq->nr_sectors; i > 0;) {
+				i -= rq->current_nr_sectors;
+				ide_end_request(drive, 1, 
+						rq->current_nr_sectors );
+			}
+			return ide_stopped;
+		}
+		printk("%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+	return ide_error(drive, "dma_intr", stat);
+}
+
+/* ....and another one....
+*/
+int
+report_drive_dmaing(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+
+	if ((id->field_valid & 4) && (eighty_ninty_three(drive)) &&
+	    (id->dma_ultra & (id->dma_ultra >> 11) & 7)) {
+		if ((id->dma_ultra >> 13) & 1) {
+			printk(", UDMA(100)");	/* UDMA BIOS-enabled! */
+		} else if ((id->dma_ultra >> 12) & 1) {
+			printk(", UDMA(66)");	/* UDMA BIOS-enabled! */
+		} else {
+			printk(", UDMA(44)");	/* UDMA BIOS-enabled! */
+		}
+	} else if ((id->field_valid & 4) &&
+		   (id->dma_ultra & (id->dma_ultra >> 8) & 7)) {
+		if ((id->dma_ultra >> 10) & 1) {
+			printk(", UDMA(33)");	/* UDMA BIOS-enabled! */
+		} else if ((id->dma_ultra >> 9) & 1) {
+			printk(", UDMA(25)");	/* UDMA BIOS-enabled! */
+		} else {
+			printk(", UDMA(16)");	/* UDMA BIOS-enabled! */
+		}
+	} else if (id->field_valid & 4) {
+		printk(", (U)DMA");	/* Can be BIOS-enabled! */
+	} else {
+		printk(", DMA");
+	}
+	return 1;
+}
+
+static int
+ocp_ide_check_dma(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+	int enable = 1;
+	int speed;
+
+	drive->using_dma = 0;
+
+	if (drive->media == ide_floppy)
+		enable = 0;
+
+	/* Check timing here, we may be able to include XFER_UDMA_66
+	 * and XFER_UDMA_100.  This basically tells the 'best_mode'
+	 * function to also consider UDMA3 to UDMA5 device timing.
+	 */
+	if (enable) {
+		/* Section 1.6.2.6 "IDE Controller, ATA/ATAPI-5" in the STB04xxx
+		 * Datasheet says the following modes are supported:
+		 *   PIO modes 0 to 4
+		 *   Multiword DMA modes 0 to 2
+		 *   UltraDMA modes 0 to 4
+		 */
+		int map = XFER_PIO | XFER_EPIO | XFER_MWDMA | XFER_UDMA;
+		/* XFER_EPIO includes both PIO modes 4 and 5.  Mode 5 is not
+		 * valid for the STB04, so mask it out of consideration just
+		 * in case some drive sets it...
+		 */
+		id->eide_pio_modes &= ~4;
+
+		/* Allow UDMA_66 only if an 80 conductor cable is connected. */
+		if (eighty_ninty_three(drive))
+			map |= XFER_UDMA_66;
+
+		speed = ide_find_best_mode(drive, map);
+		ocp_ide_set_drive(drive, speed);
+
+		if (HWIF(drive)->autodma &&
+		    (((speed & XFER_MODE) == XFER_PIO) ||
+		     ((speed & XFER_MODE) == XFER_EPIO))) {
+			drive->using_dma = 0;
+		}
+	}
+
+	return 0;
+}
+
+static int ocp_ide_dma_off_quietly(ide_drive_t * drive)
+{
+	drive->using_dma = 0;
+	return 0;
+}
+
+static int ocp_ide_dma_off(ide_drive_t * drive)
+{
+	printk(KERN_INFO "%s: DMA disabled\n", drive->name);
+	return ocp_ide_dma_off_quietly(drive);
+}
+
+static int ocp_ide_dma_on(ide_drive_t * drive)
+{
+	return ocp_ide_check_dma(drive);
+}
+
+static int ocp_ide_dma_check(ide_drive_t * drive)
+{
+	return ocp_ide_dma_on(drive);
+}
+
+static int __ocp_ide_dma_begin(ide_drive_t * drive, int writing)
+{
+	idp->si_c0tb = (unsigned int) prd_phys;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	idp->si_c0ie = 0x90000000;	/* Enable all intr */
+	idp->si_c0dcm = 0;
+	idp->si_c0dcm =
+		(writing ? 0x09000000 : 0x01000000);
+	return 0;
+}
+
+static int ocp_ide_dma_begin(ide_drive_t * drive)
+{
+	idp->si_c0tb = (unsigned int) prd_phys;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	idp->si_c0ie = 0x90000000;	/* Enable all intr */
+	idp->si_c0dcm = 0;
+	idp->si_c0dcm =	0x01000000;
+	return 0;
+}
+
+static int ocp_ide_dma_io(ide_drive_t * drive, int writing)
+{
+	if (!ocp_ide_build_dmatable(drive, writing))
+		return 1;
+
+	drive->waiting_for_dma = 1;
+	if (drive->media != ide_disk)
+		return 0;
+	ide_set_handler(drive, &ocp_ide_dma_intr, WAIT_CMD, NULL);
+	HWIF(drive)->OUTB(writing ? WIN_WRITEDMA : WIN_READDMA,
+		 IDE_COMMAND_REG);
+	return __ocp_ide_dma_begin(drive, writing);
+}
+
+static int ocp_ide_dma_read(ide_drive_t * drive)
+{
+	return ocp_ide_dma_io(drive, 0);
+}
+
+static int ocp_ide_dma_write(ide_drive_t * drive)
+{
+	return ocp_ide_dma_io(drive, 1);
+}
+
+static int ocp_ide_dma_end(ide_drive_t * drive)
+{
+	unsigned int dstat;
+
+	drive->waiting_for_dma = 0;
+	dstat = idp->si_c0s1;
+	idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+	/* verify good dma status */
+	return (dstat & 0x80000000);
+}
+
+static int ocp_ide_dma_test_irq(ide_drive_t * drive)
+{
+	return idp->si_c0s0 & 0x10000000 ? 1 : 0;
+}
+
+static int ocp_ide_dma_verbose(ide_drive_t * drive)
+{
+	return report_drive_dmaing(drive);
+}
+
+static unsigned int
+ocp_ide_spinup(int index)
+{
+	int i, ret;
+	ide_ioreg_t *io_ports;
+
+	ret = 1;
+	printk("OCP ide: waiting for drive spinup");
+	printk("ioports for drive %d @ %p\n",index,ide_hwifs[index].io_ports);
+	io_ports = ide_hwifs[index].io_ports;
+	printk(".");
+	
+	/* wait until drive is not busy (it may be spinning up) */
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk(".");
+
+	/* select slave */
+	outb_p(0xa0 | 0x10, io_ports[6]);
+
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+		udelay(1000 * 1000);	/* 1 second */
+	}
+	if( i < 30){
+		outb_p(0xa0, io_ports[6]);
+		printk("Drive spun up \n");
+	} else {
+		printk("Drive spin up Failed !\n");
+		ret = 0;
+	}
+	return (ret);
+}
+
+int
+ocp_ide_default_irq(ide_ioreg_t base)
+{
+	return IDE0_IRQ;
+}
+
+/*
+ * setup_ocp_ide()
+ * Completes the setup of a on-chip ide controller card, once found.
+ */
+int __init setup_ocp_ide (struct ocp_device *pdev)
+{
+	ide_hwif_t	*hwif;
+	unsigned int uicdcr;
+	
+	hwif = &ide_hwifs[pdev->num];
+	hwif->index = pdev->num;
+#ifdef WMODE
+   /*Word Mode psc(11-12)=00,pwc(13-18)=000110, phc(19-21)=010, 22=1, 30=1  ----  0xCB02*/
+
+    dma_ch.mode	=TM_S_MM;	  /* xfer from peripheral to mem */
+    dma_ch.pwidth = PW_16;
+    dma_ch.pwc = 6;                     /* set the max wait cycles  */
+#else
+/*Line Mode psc(11-12)=00,pwc(13-18)=000001, phc(19-21)=010, 22=1, 30=1  ----  0x2B02*/
+
+    dma_ch.mode	=DMA_MODE_MM_DEVATSRC;	  /* xfer from peripheral to mem */
+    dma_ch.pwidth = PW_64;		/* Line mode on stbs */
+    dma_ch.pwc = 1;                     /* set the max wait cycles  */
+#endif
+
+    dma_ch.td	= DMA_TD;
+    dma_ch.buffer_enable = 0;
+    dma_ch.tce_enable = 0;
+    dma_ch.etd_output = 0;
+    dma_ch.pce = 0;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.dai = 1;
+    dma_ch.sai = 0;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = 0;
+    dma_ch.ch_enable = 0;		/* No chaining */
+    dma_ch.tcd_disable = 1;		/* No chaining */
+
+    if (hw_init_dma_channel(IDE_DMACH, &dma_ch) != DMA_STATUS_GOOD)
+        return -EBUSY;
+
+    /* init CIC select2 reg to connect external DMA port 3 to internal
+     * DMA channel 2
+     */
+    map_dma_port(IDE_DMACH,EXT_DMA_3,DMA_CHAN_2); 
+
+    /* Enable the interface.
+     */
+    idp->si_control = 0x80000000;
+    idp->si_c0s0 = 0xdc800000;	/* Clear all status */
+    idp->si_intenable = 0x80000000;
+
+    /* Per the STB04 data sheet:
+     *  1)  tTO = ((8*RDYT) + 1) * SYS_CLK
+     * and:
+     *  2)  tTO >= 1250 + (2 * SYS_CLK) - t2
+     * Solving the first equation for RDYT:
+     *             (tTO/SYS_CLK) - 1
+     *  3)  RDYT = -----------------
+     *                     8
+     * Substituting equation 2) for tTO in equation 3:
+     *             ((1250 + (2 * SYS_CLK) - t2)/SYS_CLK) - 1
+     *  3)  RDYT = -----------------------------------------
+     *                                8
+     * It's just the timeout so having it too long isn't too
+     * significant, so we'll just assume t2 is zero.  All this math
+     * is handled by the compiler and RDYT ends up being 11 assuming
+     * that SYS_CLOCK_NS is 15.
+     */
+    idp->si_c0timo = (EZ(EZ(1250 + 2 * SYS_CLOCK_NS, SYS_CLOCK_NS) - 1, 8)) << 23;	/* Chan 0 timeout */
+
+    /* Stuff some slow default PIO timing.
+     */
+    idp->si_c0rt = MK_TIMING(6, 19, 15, 2);
+    idp->si_c0fpt = MK_TIMING(6, 19, 15, 2);
+    
+    /* We should probably have UIC functions to set external
+     * interrupt level/edge.
+     */
+    uicdcr = mfdcr(DCRN_UIC_PR(UIC0));
+    uicdcr &= ~(0x80000000 >> IDE0_IRQ);
+    mtdcr(DCRN_UIC_PR(UIC0), uicdcr);
+    mtdcr(DCRN_UIC_TR(UIC0), 0x80000000 >> IDE0_IRQ);
+
+    /* Grab a page for the PRD Table.
+     */
+    prd_table = (prd_entry_t *) consistent_alloc(GFP_KERNEL,
+						 NUM_PRD *
+						 sizeof
+						 (prd_entry_t),
+						 &prd_phys);
+
+
+    if(!ocp_ide_spinup(hwif->index))
+	    return 0;
+    
+    return 1;
+}
+
+
+static int __devinit ocp_ide_probe(struct ocp_device *pdev)
+{
+	int i;
+	unsigned int index;
+	hw_regs_t * hw;
+	unsigned char *ip;
+
+	printk("IBM STB04xxx IDE driver version %s\n", IDE_VER);
+
+	hw = kmalloc(sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return 0;
+	memset(hw, 0, sizeof(*hw));
+
+	if (!request_region(pdev->paddr, IDE0_SIZE, "IDE")) {
+		printk(KERN_WARNING "ocp_ide: failed request_region\n");
+		return -1;
+	}
+
+	if ((idp = (ide_t *) ioremap(pdev->paddr,
+				     IDE0_SIZE)) == NULL) {
+		printk(KERN_WARNING "ocp_ide: failed ioremap\n");
+		return -1;
+	}
+
+	pdev->dev.driver_data = (void *) idp;
+
+	pdev->ocpdev  = (void *) hw;
+	index = pdev->num;
+	ip = (unsigned char *) (&(idp->si_c0d));	/* Chan 0 data */
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = (unsigned long) (ip++);
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = (unsigned long) (&(idp->si_c0adc));
+	hw->irq = pdev->irq;
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = IDE_DMACH;
+
+	ide_hwifs[index].tuneproc = &ocp_ide_tune_drive;
+	ide_hwifs[index].drives[0].autotune = 1;
+	ide_hwifs[index].autodma = 1;
+	ide_hwifs[index].ide_dma_off = &ocp_ide_dma_off;
+	ide_hwifs[index].ide_dma_off_quietly = &ocp_ide_dma_off_quietly;
+	ide_hwifs[index].ide_dma_host_off = &ocp_ide_dma_off_quietly;
+	ide_hwifs[index].ide_dma_on = &ocp_ide_dma_on;
+	ide_hwifs[index].ide_dma_host_on = &ocp_ide_dma_on;
+	ide_hwifs[index].ide_dma_check = &ocp_ide_dma_check;
+	ide_hwifs[index].ide_dma_read = &ocp_ide_dma_read;
+	ide_hwifs[index].ide_dma_write = &ocp_ide_dma_write;
+	ide_hwifs[index].ide_dma_begin = &ocp_ide_dma_begin;
+	ide_hwifs[index].ide_dma_end = &ocp_ide_dma_end;
+	ide_hwifs[index].ide_dma_test_irq = &ocp_ide_dma_test_irq;
+	ide_hwifs[index].ide_dma_verbose = &ocp_ide_dma_verbose;
+	ide_hwifs[index].speedproc = &ocp_ide_set_drive;
+	ide_hwifs[index].noprobe = 0;
+
+	memcpy(ide_hwifs[index].io_ports, hw->io_ports, sizeof (hw->io_ports));
+	ide_hwifs[index].irq = pdev->irq;
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+
+static void __devexit ocp_ide_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+}
+
+static struct ocp_device_id ocp_ide_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_IDE},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_ide_id_tbl );
+
+static struct ocp_driver ocp_ide_driver = {
+	.name		= "ocp_ide",
+	.id_table	= ocp_ide_id_tbl,
+	.probe		= ocp_ide_probe,
+	.remove		= __devexit_p(ocp_ide_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+
+void __init std_ide_cntl_scan(void)
+{
+	struct ocp_device *dev;
+	int i, max;
+	printk("OCP ide ver:%s\n", IDE_VER);
+
+	ocp_module_init(&ocp_ide_driver);
+	max = ocp_get_num(OCP_FUNC_IDE);
+	for(i = 0; i < max; i++){
+		dev = ocp_get_dev(OCP_FUNC_IDE,i);
+		if(!dev)	
+		  setup_ocp_ide(dev);
+	}
+}
+#if 0
+#if defined (CONFIG_MODULE)
+static int __init
+ocp_ide_init(void)
+{
+	printk("OCP ide ver:%s\n", IDE_VER);
+	return ocp_module_init(&ocp_ide_driver);
+}
+
+void __exit
+ocp_ide_fini(void)
+{
+	ocp_unregister_driver(&ocp_ide_driver);
+}
+
+module_init(ocp_ide_init);
+module_exit(ocp_ide_fini);
+#endif
+#endif
+
diff -purN /dev/shm/linux-2.5/drivers/ide/ppc/ocp_stbxxxxx.c linuxppc-2.5-benh/drivers/ide/ppc/ocp_stbxxxxx.c
--- /dev/shm/linux-2.5/drivers/ide/ppc/ocp_stbxxxxx.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/ide/ppc/ocp_stbxxxxx.c	2003-01-08 04:34:25.000000000 +0000
@@ -0,0 +1,578 @@
+/*
+ *    Copyright 2002 MontaVista Software Inc.
+ *      Completed implementation.
+ *      Author: Armin Kuster <akuster@mvista.com>
+ *      MontaVista Software, Inc.  <source@mvista.com>
+ *
+ *    Module name: ocp_stbxxxx.c
+ *
+ *    Description:
+ *
+ *    Based on stb03xxx.c
+ */
+
+#include <linux/types.h>
+#include <linux/hdreg.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#include <asm/ppc4xx_dma.h>
+
+#include "ide_modes.h"
+
+#define IDE_VER			"2.0"
+ppc_dma_ch_t dma_ch;
+
+/* use DMA channel 2 for IDE DMA operations */
+#define IDE_DMACH	2	/* 2nd DMA channel */
+#define IDE_DMA_INT	6	/* IDE dma channel 2 interrupt */
+
+extern char *ide_dmafunc_verbose(ide_dma_action_t dmafunc);
+
+#define WMODE	0		/* default to DMA line mode */
+#define PIOMODE	0
+static volatile unsigned long dmastat;
+
+/* Function Prototypes */
+static void ocp_ide_tune_drive(ide_drive_t *, byte);
+static byte ocp_ide_dma_2_pio(byte);
+static int ocp_ide_tune_chipset(ide_drive_t *, byte);
+static int ocp_ide_dmaproc(ide_dma_action_t, ide_drive_t *);
+
+static void
+ocp_ide_tune_drive(ide_drive_t * drive, byte pio)
+{
+	pio = ide_get_best_pio_mode(drive, pio, 5, NULL);
+}
+
+static byte
+ocp_ide_dma_2_pio(byte xfer_rate)
+{
+	switch (xfer_rate) {
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+static int
+ocp_ide_tune_chipset(ide_drive_t * drive, byte speed)
+{
+	int err = 0;
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+
+	if (!drive->init_speed)
+		drive->init_speed = speed;
+	err = ide_config_drive_speed(drive, speed);
+	drive->current_speed = speed;
+	return err;
+}
+
+static int
+redwood_config_drive_for_dma(ide_drive_t * drive)
+{
+	struct hd_driveid *id = drive->id;
+	byte speed;
+	int func = ide_dma_off;
+
+	/*
+	 * Enable DMA on any drive that has multiword DMA
+	 */
+	if (id->field_valid & 2) {
+		if (id->dma_mword & 0x0004) {
+			speed = XFER_MW_DMA_2;
+			func = ide_dma_on;
+		} else if (id->dma_mword & 0x0002) {
+			speed = XFER_MW_DMA_1;
+			func = ide_dma_on;
+		} else if (id->dma_mword & 1) {
+			speed = XFER_MW_DMA_0;
+			func = ide_dma_on;
+		} else if (id->dma_1word & 0x0004) {
+			speed = XFER_SW_DMA_2;
+			func = ide_dma_on;
+		} else {
+			speed = XFER_PIO_0 +
+			    ide_get_best_pio_mode(drive, 255, 5, NULL);
+		}
+	}
+
+	ocp_ide_tune_drive(drive, ocp_ide_dma_2_pio(speed));
+	return ocp_ide_dmaproc(func, drive);
+}
+
+ide_startstop_t
+ocp_ide_intr(ide_drive_t * drive)
+{
+	int i;
+	byte dma_stat;
+	unsigned int nsect;
+	ide_hwgroup_t *hwgroup = HWGROUP(drive);
+	struct request *rq = hwgroup->rq;
+	unsigned long block, b1, b2, b3, b4;
+
+	nsect = rq->current_nr_sectors;
+
+	dma_stat = HWIF(drive)->dmaproc(ide_dma_end, drive);
+
+	rq->sector += nsect;
+	rq->buffer += nsect << 9;
+	rq->errors = 0;
+	i = (rq->nr_sectors -= nsect);
+	ide_end_request(1, HWGROUP(drive));
+	if (i > 0) {
+		b1 = IN_BYTE(IDE_SECTOR_REG);
+		b2 = IN_BYTE(IDE_LCYL_REG);
+		b3 = IN_BYTE(IDE_HCYL_REG);
+		b4 = IN_BYTE(IDE_SELECT_REG);
+		block = ((b4 & 0x0f) << 24) + (b3 << 16) + (b2 << 8) + (b1);
+		block++;
+		if (drive->select.b.lba) {
+			OUT_BYTE(block, IDE_SECTOR_REG);
+			OUT_BYTE(block >>= 8, IDE_LCYL_REG);
+			OUT_BYTE(block >>= 8, IDE_HCYL_REG);
+			OUT_BYTE(((block >> 8) & 0x0f) | drive->select.all,
+				 IDE_SELECT_REG);
+		} else {
+			unsigned int sect, head, cyl, track;
+			track = block / drive->sect;
+			sect = block % drive->sect + 1;
+			OUT_BYTE(sect, IDE_SECTOR_REG);
+			head = track % drive->head;
+			cyl = track / drive->head;
+			OUT_BYTE(cyl, IDE_LCYL_REG);
+			OUT_BYTE(cyl >> 8, IDE_HCYL_REG);
+			OUT_BYTE(head | drive->select.all, IDE_SELECT_REG);
+		}
+
+		if (rq->cmd == READ)
+			dma_stat = HWIF(drive)->dmaproc(ide_dma_read, drive);
+		else
+			dma_stat = HWIF(drive)->dmaproc(ide_dma_write, drive);
+		return ide_started;
+	}
+	return ide_stopped;
+}
+
+void
+ocp_ide_dma_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dmastat = get_dma_status();
+#if WMODE
+	if (dmastat & 0x1000) {
+		//This should not happen at least in Word Mode, I have noticed this. Is it some timing problem ?
+		printk
+		    ("ocp_ide_dma_intr dma req pending from external device\n");
+	}
+#endif
+
+	clr_dma_status(IDE_DMACH);
+}
+
+static int
+ocp_ide_dmaproc(ide_dma_action_t func, ide_drive_t * drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	int i, reading = 0;
+	struct request *rq = HWGROUP(drive)->rq;
+	unsigned long flags;
+	unsigned long length;
+
+	switch (func) {
+	case ide_dma_off:
+	case ide_dma_off_quietly:
+		/*disable_dma */
+		return 0;
+
+	case ide_dma_on:
+#if PIOMODE
+		return 1;
+#endif
+
+		mtdcr(DCRN_DMACR2, 0);
+		clr_dma_status(IDE_DMACH);
+
+		save_flags(flags);
+		cli();
+		if (ide_request_irq
+		    (IDE_DMA_INT, &ocp_ide_dma_intr, SA_INTERRUPT,
+		     hwif->name, hwif->hwgroup)) {
+			printk("ide_redwood: ide_request_irq failed int=%d\n",
+			       IDE_DMA_INT);
+			restore_flags(flags);
+			return 1;
+		}
+		restore_flags(flags);
+
+		drive->using_dma = (func == ide_dma_on);
+#if WMODE
+		mtdcr(DCRN_DCRXBCR, 0);
+		mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) | 0x00000400);
+#else
+		/* Configure CIC reg for line mode dma */
+		mtdcr(DCRN_CICCR, mfdcr(DCRN_CICCR) & ~0x00000400);
+#endif
+		return 0;
+
+	case ide_dma_check:
+		return redwood_config_drive_for_dma(drive);
+	case ide_dma_read:
+		reading = 1;
+	case ide_dma_write:
+		if (drive->media != ide_disk)
+			return -1;
+
+		if (get_channel_config(IDE_DMACH, &dma_ch) & DMA_CHANNEL_BUSY )	/* DMA is busy? */
+			return -1;
+
+
+		if (reading) {
+			dma_cache_inv((unsigned long) rq->buffer,
+				      rq->current_nr_sectors * 512);
+#if WMODE
+			set_src_addr(IDE_DMACH, 0);
+#else
+			set_src_addr(IDE_DMACH, 0xfce00000);
+#endif
+			set_dst_addr(IDE_DMACH, virt_to_bus(rq->buffer));
+		} else {
+			dma_cache_wback_inv((unsigned long) rq->buffer,
+					    rq->current_nr_sectors * 512);
+			set_src_addr(IDE_DMACH, virt_to_bus(rq->buffer));
+#if WMODE
+			set_dst_addr(2, 0);
+#else
+			set_dst_addr(IDE_DMACH, 0xfce00000);
+#endif
+		}
+
+#if WMODE
+		length = rq->current_nr_sectors * 512 / 2;
+#else
+		length = rq->current_nr_sectors * 512 / 16;
+#endif
+		OUT_BYTE(rq->current_nr_sectors, IDE_NSECTOR_REG);
+		set_dma_count(IDE_DMACH, length);
+
+		/* CE=0 disable DMA */
+		/* Set up the Line Buffer Control Register
+		 * 11d1xxxx0.. - 11=Mode 2 (120 ns cycle), d=1/0(read/write)
+		 * 1=active, 0=1X clock mode.
+		 */
+
+		if (reading) {
+#if WMODE
+			set_dma_mode(IDE_DMACH,DMA_TD | TM_S_MM);
+#else
+		mtdcr(DCRN_DCRXBCR, 0x90000000);
+		set_dma_mode(IDE_DMACH,SET_DMA_DAI(1) | SET_DMA_SAI(0) | DMA_MODE_MM_DEVATDST);
+#endif
+		} else {
+#if WMODE
+			set_dma_mode(IDE_DMACH,DMA_TD | TM_S_MM);
+#else
+			mtdcr(DCRN_DCRXBCR, 0xB0000000);
+			set_dma_mode(IDE_DMACH,SET_DMA_DAI(0) | SET_DMA_SAI(1) | DMA_MODE_MM_DEVATDST);
+#endif
+		}
+
+		set_dma_mode(hwif->hw.dma, reading
+			     ? DMA_MODE_READ : DMA_MODE_WRITE);
+		drive->waiting_for_dma = 1;
+		ide_set_handler(drive, &ocp_ide_intr, WAIT_CMD, NULL);
+		OUT_BYTE(reading ? WIN_READDMA : WIN_WRITEDMA, IDE_COMMAND_REG);
+
+	case ide_dma_begin:
+		/* enable DMA */
+		enable_dma_interrupt(IDE_DMACH);
+		/* wait for dma to complete (channel 2 terminal count) */
+		for (i = 0; i < 5000000; i++) {
+			if (dmastat & DMA_CS2)
+				break;
+		}
+		dmastat = 0;
+		return 0;
+
+	case ide_dma_end:
+		drive->waiting_for_dma = 0;
+
+		/* disable DMA */
+		disable_dma_interrupt(IDE_DMACH);
+		return 0;
+
+	case ide_dma_test_irq:
+		return 1;	/* returns 1 if dma irq issued, 0 otherwise */
+
+	case ide_dma_bad_drive:
+	case ide_dma_good_drive:
+	case ide_dma_verbose:
+	case ide_dma_timeout:
+	case ide_dma_retune:
+	case ide_dma_lostirq:
+		printk("ide_dmaproc: chipset supported %s func only: %d\n",
+		       ide_dmafunc_verbose(func), func);
+		return 1;
+	default:
+		printk("ide_dmaproc: unsupported %s func: %d\n",
+		       ide_dmafunc_verbose(func), func);
+		return 1;
+
+	}
+
+}
+void
+ibm4xx_ide_spinup(int index)
+{
+	int i;
+	ide_ioreg_t *io_ports;
+
+	printk("ide_redwood: waiting for drive ready..");
+	io_ports = ide_hwifs[index].io_ports;
+
+	/* wait until drive is not busy (it may be spinning up) */
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk("..");
+
+	/* select slave */
+	outb_p(0xa0 | 0x10, io_ports[6]);
+
+	for (i = 0; i < 30; i++) {
+		unsigned char stat;
+		stat = inb_p(io_ports[7]);
+		/* wait for !busy & ready */
+		if ((stat & 0x80) == 0) {
+			break;
+		}
+
+		udelay(1000 * 1000);	/* 1 second */
+	}
+
+	printk("..");
+
+	outb_p(0xa0, io_ports[6]);
+	printk("Drive spun up \n");
+}
+
+int
+nonpci_ide_default_irq(ide_ioreg_t base)
+{
+	return IDE0_IRQ;
+}
+/*
+ * setup_ocp_ide()
+ * Completes the setup of a on-chip ide controller card, once found.
+ */
+int __init setup_ocp_ide (ide_hwif_t *hwif)
+{
+
+	unsigned long ioaddr;
+	int i, index;
+	
+	ide_drive_t *drive;
+	ide_hwif_t *hwif2;
+	struct dc_ident ident;
+	ide_startstop_t startstop;
+	
+	if (!hwif) return 0;
+
+
+	if (!request_region(REDWOOD_IDE_CMD, 0x10, "IDE"))
+		return;
+
+	if (!request_region(REDWOOD_IDE_CTRL, 2, "IDE")) {
+		release_region(REDWOOD_IDE_CMD, 0x10);
+		return;
+	}
+
+	ioaddr = (unsigned long) ioremap(REDWOOD_IDE_CMD, 0x10);
+
+	hw->irq = IDE0_IRQ;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = ioaddr;
+		ioaddr += 2;
+	}
+	hw->io_ports[IDE_CONTROL_OFFSET] =
+	    (unsigned long) ioremap(REDWOOD_IDE_CTRL, 2);
+
+	/* use DMA channel 2 for IDE DMA operations */
+	hw->dma = IDE_DMACH;
+#ifdef WMODE
+   /*Word Mode psc(11-12)=00,pwc(13-18)=000110, phc(19-21)=010, 22=1, 30=1  ----  0xCB02*/
+
+    dma_ch.mode	=TM_S_MM;	  /* xfer from peripheral to mem */
+    dma_ch.td	= DMA_TD;
+    dma_ch.buffer_enable = FALSE;
+    dma_ch.tce_enable = FALSE;
+    dma_ch.etd_output = FALSE;
+    dma_ch.pce = FALSE;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.pwidth = PW_16;
+    dma_ch.dai = TRUE;
+    dma_ch.sai = FALSE;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.pwc = 6;                     /* set the max wait cycles  */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = FALSE;
+    dma_ch.ch_enable = FALSE;		/* No chaining */
+    dma_ch.tcd_disable = TRUE;		/* No chaining */
+#else
+/*Line Mode psc(11-12)=00,pwc(13-18)=000001, phc(19-21)=010, 22=1, 30=1  ----  0x2B02*/
+
+   dma_ch.mode	=DMA_MODE_MM_DEVATSRC;	  /* xfer from peripheral to mem */
+   dma_ch.td	= DMA_TD;
+   dma_ch.buffer_enable = FALSE;
+    dma_ch.tce_enable = FALSE;
+    dma_ch.etd_output = FALSE;
+    dma_ch.pce = FALSE;
+    dma_ch.pl = EXTERNAL_PERIPHERAL;    /* no op */
+    dma_ch.pwidth = PW_64;		/* Line mode on stbs */
+    dma_ch.dai = TRUE;
+    dma_ch.sai = FALSE;
+    dma_ch.psc = 0;                      /* set the max setup cycles */
+    dma_ch.pwc = 1;                     /* set the max wait cycles  */
+    dma_ch.phc = 2;                      /* set the max hold cycles  */
+    dma_ch.cp = PRIORITY_LOW;
+    dma_ch.int_enable = FALSE;
+    dma_ch.ch_enable = FALSE;		/* No chaining */
+    dma_ch.tcd_disable = TRUE;		/* No chaining */
+
+#endif
+    if (hw_init_dma_channel(IDE_DMACH, &dma_ch) != DMA_STATUS_GOOD)
+        return -EBUSY;
+
+	/* init CIC select2 reg to connect external DMA port 3 to internal
+	 * DMA channel 2
+	 */
+       map_dma_port(IDE_DMACH,EXT_DMA_3,DMA_CHAN_2); 
+
+	index = 0;
+
+	ide_hwifs[index].tuneproc = &ocp_ide_tune_drive;
+	ide_hwifs[index].drives[0].autotune = 1;
+#ifdef CONFIG_BLK_DEV_IDEDMA
+	ide_hwifs[index].autodma = 1;
+	ide_hwifs[index].dmaproc = &ocp_ide_dmaproc;
+#endif
+	ide_hwifs[index].speedproc = &ocp_ide_tune_chipset;
+	ide_hwifs[index].noprobe = 0;
+
+	memcpy(ide_hwifs[index].io_ports, hw->io_ports, sizeof (hw->io_ports));
+	ide_hwifs[index].irq = hw->irq;
+	ibm4xx_ide_spinup(index);
+}
+
+void __init ocp_ide_init(void)
+{
+	unsigned int	index;
+	ide_hwif_t	*hwif;
+
+	for (index = 0; index < MAX_HWIFS; index++) {
+		hwif = &ide_hwifs[index];
+			setup_ocp_ide(hwif);
+	}
+}
+
+static int __devinit ocp_ide_probe(struct ocp_device *pdev)
+{
+	printk("IBM IDE driver version %s\n", IDEVR);
+
+	DBG("Vendor:%x Device:%x.%d @%p irq:%d\n",pdev->vendor, pdev->device,pdev->num,pdev->paddr,pdev->irq);
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+static void __devexit ocp_ide_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+}
+
+static struct ocp_device_id ocp_ide_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_IDE},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_ide_id_tbl );
+
+static struct ocp_driver ocp_ide_driver = {
+	.name		= "ocp_ide",
+	.id_table	= ocp_ide_id_tbl,
+	.probe		= ocp_ide_probe,
+	.remove		= __devexit_p(ocp_ide_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+void __init ide_scan_ocpdev (struct ocp_device *dev)
+{
+
+}
+
+void __init ide_scan_ocpbus (int scan_direction)
+{
+	struct ocp_device *dev;
+
+	if (!scan_direction) {
+		ocp_for_each_dev(dev) {
+			ide_scan_ocpdev(dev);
+		}
+	} else {
+		ocp_for_each_dev_reverse(dev) {
+			ide_scan_ocpdev(dev);
+		}
+	}
+}
+
+static int __init
+ocp_ide_init(void)
+{
+	printk("OCP ide ver:%s\n", IDE_VER);
+	return ocp_module_init(&ocp_ide_driver);
+}
+
+void __exit
+ocp_ide_fini(void)
+{
+	ocp_unregister_driver(&ocp_ide_driver);
+}
+
+module_init(ocp_ide_init);
+module_exit(ocp_ide_fini);
+
+
diff -purN /dev/shm/linux-2.5/drivers/ide/ppc/pmac.c linuxppc-2.5-benh/drivers/ide/ppc/pmac.c
--- /dev/shm/linux-2.5/drivers/ide/ppc/pmac.c	2003-08-31 21:09:16.000000000 +0000
+++ linuxppc-2.5-benh/drivers/ide/ppc/pmac.c	2003-11-02 22:30:01.000000000 +0000
@@ -69,7 +69,7 @@ typedef struct pmac_ide_hwif {
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 	/* Those fields are duplicating what is in hwif. We currently
 	 * can't use the hwif ones because of some assumptions that are
-	 * being done by the generic code about the kind of dma controller
+	 * beeing done by the generic code about the kind of dma controller
 	 * and format of the dma table. This will have to be fixed though.
 	 */
 	volatile struct dbdma_regs*	dma_regs;
@@ -90,15 +90,17 @@ enum {
 	controller_heathrow,	/* Heathrow/Paddington */
 	controller_kl_ata3,	/* KeyLargo ATA-3 */
 	controller_kl_ata4,	/* KeyLargo ATA-4 */
-	controller_un_ata6	/* UniNorth2 ATA-6 */
+	controller_un_ata6,	/* UniNorth2 ATA-6 */
+	controller_k2_ata6	/* K2 ATA-6 */
 };
 
 static const char* model_name[] = {
 	"OHare ATA",		/* OHare based */
 	"Heathrow ATA",		/* Heathrow/Paddington */
-	"KeyLargo ATA-3",	/* KeyLargo ATA-3 */
-	"KeyLargo ATA-4",	/* KeyLargo ATA-4 */
-	"UniNorth ATA-6"	/* UniNorth2 ATA-6 */
+	"KeyLargo ATA-3",	/* KeyLargo ATA-3 (MDMA only) */
+	"KeyLargo ATA-4",	/* KeyLargo ATA-4 (UDMA/66) */
+	"UniNorth ATA-6",	/* UniNorth2 ATA-6 (UDMA/100) */
+	"K2 ATA-6",		/* K2 ATA-6 (UDMA/100) */
 };
 
 /*
@@ -336,16 +338,19 @@ kauai_lookup_timing(struct kauai_timing*
 /* allow up to 256 DBDMA commands per xfer */
 #define MAX_DCMDS		256
 
-/* Wait 2s for disk to answer on IDE bus after
- * enable operation.
- * NOTE: There is at least one case I know of a disk that needs about 10sec
- *       before anwering on the bus. I beleive we could add a kernel command
- *       line arg to override this delay for such cases.
- *       
- * NOTE2: This has to be fixed with a BSY wait loop. I'm working on adding
- *        that to the generic probe code.
+/* 
+ * Wait 1s for disk to answer on IDE bus after a hard reset
+ * of the device (via GPIO/FCR).
+ * 
+ * Some devices seem to "pollute" the bus even after dropping
+ * the BSY bit (typically some combo drives slave on the UDMA
+ * bus) after a hard reset. Since we hard reset all drives on
+ * KeyLargo ATA66, we have to keep that delay around. I may end
+ * up not hard resetting anymore on these and keep the delay only
+ * for older interfaces instead (we have to reset when coming
+ * from MacOS...) --BenH. 
  */
-#define IDE_WAKEUP_DELAY_MS	2000
+#define IDE_WAKEUP_DELAY	(1*HZ)
 
 static void pmac_ide_setup_dma(pmac_ide_hwif_t *pmif, ide_hwif_t *hwif);
 static int pmac_ide_build_dmatable(ide_drive_t *drive, struct request *rq);
@@ -357,9 +362,16 @@ static int pmac_ide_dma_begin (ide_drive
 
 #endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
 
+/*
+ * Below is the code for blinking the laptop LED along with hard
+ * disk activity.
+ */
+
 #ifdef CONFIG_BLK_DEV_IDE_PMAC_BLINK
 
-/* Set to 50ms */
+/* Set to 50ms minimum led-on time (also used to limit frequency
+ * of requests sent to the PMU
+ */
 #define PMU_HD_BLINK_TIME	(HZ/50)
 
 static struct adb_request pmu_blink_on, pmu_blink_off;
@@ -402,6 +414,7 @@ pmu_hd_kick_blink(void *data, int rw)
 	pmu_blink_stoptime = jiffies + PMU_HD_BLINK_TIME;
 	wmb();
 	mod_timer(&pmu_blink_timer, pmu_blink_stoptime);
+	/* Fast path when LED is already ON */
 	if (pmu_blink_ledstate == 1)
 		return;
 	spin_lock_irqsave(&pmu_blink_lock, flags);
@@ -418,6 +431,11 @@ pmu_hd_blink_init(void)
 	struct device_node *dt;
 	const char *model;
 
+	/* Currently, I only enable this feature on KeyLargo based laptops,
+	 * older laptops may support it (at least heathrow/paddington) but
+	 * I don't feel like loading those venerable old machines with so
+	 * much additional interrupt & PMU activity...
+	 */
 	if (pmu_get_model() != PMU_KEYLARGO_BASED)
 		return 0;
 	
@@ -476,9 +494,11 @@ pmac_ide_init_hwif_ports(hw_regs_t *hw,
 		*irq = pmac_ide[ix].irq;
 }
 
-/* Setup timings for the selected drive (master/slave). I still need to verify if this
- * is enough, I beleive selectproc will be called whenever an IDE command is started,
- * but... */
+/*
+ * Apply the timings of the proper unit (master/slave) to the shared
+ * timing register when selecting that unit. This version is for
+ * ASICs with a single timing register
+ */
 static void __pmac
 pmac_ide_selectproc(ide_drive_t *drive)
 {
@@ -496,6 +516,11 @@ pmac_ide_selectproc(ide_drive_t *drive)
 	(void)readl((unsigned *)(IDE_DATA_REG+IDE_TIMING_CONFIG));
 }
 
+/*
+ * Apply the timings of the proper unit (master/slave) to the shared
+ * timing register when selecting that unit. This version is for
+ * ASICs with a dual timing register (Kauai)
+ */
 static void __pmac
 pmac_ide_kauai_selectproc(ide_drive_t *drive)
 {
@@ -518,6 +543,9 @@ pmac_ide_kauai_selectproc(ide_drive_t *d
 	(void)readl((unsigned *)(IDE_DATA_REG + IDE_KAUAI_PIO_CONFIG));
 }
 
+/*
+ * Force an update of controller timing values for a given drive
+ */
 static void __pmac
 pmac_ide_do_update_timings(ide_drive_t *drive)
 {
@@ -526,12 +554,29 @@ pmac_ide_do_update_timings(ide_drive_t *
 	if (pmif == NULL)
 		return;
 
-	if (pmif->kind == controller_un_ata6)
+	if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 		pmac_ide_kauai_selectproc(drive);
 	else
 		pmac_ide_selectproc(drive);
 }
 
+static void
+pmac_outbsync(ide_drive_t *drive, u8 value, unsigned long port)
+{
+	u32 tmp;
+	
+	writeb(value, port);	
+	tmp = readl((unsigned *)(IDE_DATA_REG + IDE_TIMING_CONFIG));
+}
+
+/*
+ * Send the SET_FEATURE IDE command to the drive and update drive->id with
+ * the new state. We currently don't use the generic routine as it used to
+ * cause various trouble, especially with older mediabays.
+ * This code is sometimes triggering a spurrious interrupt though, I need
+ * to sort that out sooner or later and see if I can finally get the
+ * common version to work properly in all cases
+ */
 static int __pmac
 pmac_ide_do_setfeature(ide_drive_t *drive, u8 command)
 {
@@ -606,7 +651,9 @@ out:
 	return result;
 }
 
-/* Calculate PIO timings */
+/*
+ * Old tuning functions (called on hdparm -p), sets up drive PIO timings
+ */
 static void __pmac
 pmac_ide_tuneproc(ide_drive_t *drive, u8 pio)
 {
@@ -625,7 +672,8 @@ pmac_ide_tuneproc(ide_drive_t *drive, u8
 	pio = ide_get_best_pio_mode(drive, pio, 4, &d);
 
 	switch (pmif->kind) {
-	case controller_un_ata6: {
+	case controller_un_ata6:
+	case controller_k2_ata6: {
 		/* 100Mhz cell */
 		u32 tr = kauai_lookup_timing(kauai_pio_timings, d.cycle_time);
 		if (tr == 0)
@@ -685,6 +733,10 @@ pmac_ide_tuneproc(ide_drive_t *drive, u8
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
+
+/*
+ * Calculate KeyLargo ATA/66 UDMA timings
+ */
 static int __pmac
 set_timings_udma_ata4(u32 *timings, u8 speed)
 {
@@ -710,6 +762,9 @@ set_timings_udma_ata4(u32 *timings, u8 s
 	return 0;
 }
 
+/*
+ * Calculate Kauai ATA/100 UDMA timings
+ */
 static int __pmac
 set_timings_udma_ata6(u32 *pio_timings, u32 *ultra_timings, u8 speed)
 {
@@ -727,6 +782,9 @@ set_timings_udma_ata6(u32 *pio_timings, 
 	return 0;
 }
 
+/*
+ * Calculate MDMA timings for all cells
+ */
 static int __pmac
 set_timings_mdma(ide_drive_t *drive, int intf_type, u32 *timings, u32 *timings2,
 			u8 speed, int drive_cycle_time)
@@ -753,6 +811,7 @@ set_timings_mdma(ide_drive_t *drive, int
 	/* Get the proper timing array for this controller */
 	switch(intf_type) {
 		case controller_un_ata6:
+		case controller_k2_ata6:
 			break;
 		case controller_kl_ata4:
 			tm = mdma_timings_66;
@@ -784,7 +843,8 @@ set_timings_mdma(ide_drive_t *drive, int
 #endif
 	}
 	switch(intf_type) {
-	case controller_un_ata6: {
+	case controller_un_ata6:
+	case controller_k2_ata6: {
 		/* 100Mhz cell */
 		u32 tr = kauai_lookup_timing(kauai_mdma_timings, cycleTime);
 		if (tr == 0)
@@ -854,8 +914,12 @@ set_timings_mdma(ide_drive_t *drive, int
 }
 #endif /* #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC */
 
-/* You may notice we don't use this function on normal operation,
- * our, normal mdma function is supposed to be more precise
+/* 
+ * Speedproc. This function is called by the core to set any of the standard
+ * timing (PIO, MDMA or UDMA) to both the drive and the controller.
+ * You may notice we don't use this function on normal "dma check" operation,
+ * our dedicated function is more precise as it uses the drive provided
+ * cycle time value. We should probably fix this one to deal with that too...
  */
 static int __pmac
 pmac_ide_tune_chipset (ide_drive_t *drive, byte speed)
@@ -874,7 +938,8 @@ pmac_ide_tune_chipset (ide_drive_t *driv
 	switch(speed) {
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 		case XFER_UDMA_5:
-			if (pmif->kind != controller_un_ata6)
+			if (pmif->kind != controller_un_ata6 &&
+			    pmif->kind != controller_k2_ata6)
 				return 1;
 		case XFER_UDMA_4:
 		case XFER_UDMA_3:
@@ -885,7 +950,8 @@ pmac_ide_tune_chipset (ide_drive_t *driv
 		case XFER_UDMA_0:
 			if (pmif->kind == controller_kl_ata4)
 				ret = set_timings_udma_ata4(timings, speed);
-			else if (pmif->kind == controller_un_ata6)
+			else if (pmif->kind == controller_un_ata6
+				 || pmif->kind == controller_k2_ata6)
 				ret = set_timings_udma_ata6(timings, timings2, speed);
 			else
 				ret = 1;		
@@ -923,6 +989,10 @@ pmac_ide_tune_chipset (ide_drive_t *driv
 	return 0;
 }
 
+/*
+ * Blast some well known "safe" values to the timing registers at init or
+ * wakeup from sleep time, before we do real calculation
+ */
 static void __pmac
 sanitize_timings(pmac_ide_hwif_t *pmif)
 {
@@ -930,6 +1000,7 @@ sanitize_timings(pmac_ide_hwif_t *pmif)
 	
 	switch(pmif->kind) {
 		case controller_un_ata6:
+		case controller_k2_ata6:
 			value = 0x08618a92;
 			value2 = 0x00002921;
 			break;
@@ -1052,9 +1123,11 @@ pmac_ide_do_resume(ide_hwif_t *hwif)
 	if (!pmif->mediabay) {
 		ppc_md.feature_call(PMAC_FTR_IDE_RESET, pmif->node, pmif->aapl_bus_id, 1);
 		ppc_md.feature_call(PMAC_FTR_IDE_ENABLE, pmif->node, pmif->aapl_bus_id, 1);
-		mdelay(10);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
 		ppc_md.feature_call(PMAC_FTR_IDE_RESET, pmif->node, pmif->aapl_bus_id, 0);
-		mdelay(100);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(IDE_WAKEUP_DELAY);
 	}
 
 	/* Sanitize drive timings */
@@ -1063,6 +1136,13 @@ pmac_ide_do_resume(ide_hwif_t *hwif)
 	return 0;
 }
 
+/*
+ * Setup, register & probe an IDE channel driven by this driver, this is
+ * called by one of the 2 probe functions (macio or PCI). Note that a channel
+ * that ends up beeing free of any device is not kept around by this driver
+ * (it is kept in 2.4). This introduce an interface numbering change on some
+ * rare machines unfortunately, but it's better this way.
+ */
 static int
 pmac_ide_setup_device(pmac_ide_hwif_t *pmif, ide_hwif_t *hwif)
 {
@@ -1073,6 +1153,8 @@ pmac_ide_setup_device(pmac_ide_hwif_t *p
 	pmif->broken_dma = pmif->broken_dma_warn = 0;
 	if (device_is_compatible(np, "kauai-ata"))
 		pmif->kind = controller_un_ata6;
+	else if (device_is_compatible(np, "K2-UATA"))
+		pmif->kind = controller_k2_ata6;
 	else if (device_is_compatible(np, "keylargo-ata")) {
 		if (strcmp(np->name, "ata-4") == 0)
 			pmif->kind = controller_kl_ata4;
@@ -1089,7 +1171,8 @@ pmac_ide_setup_device(pmac_ide_hwif_t *p
 	pmif->aapl_bus_id =  bidp ? *bidp : 0;
 
 	/* Get cable type from device-tree */
-	if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6) {
+	if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6
+	    || pmif->kind == controller_k2_ata6) {
 		char* cable = get_property(np, "cable-type", NULL);
 		if (cable && !strncmp(cable, "80-", 3))
 			pmif->cable_80 = 1;
@@ -1119,13 +1202,16 @@ pmac_ide_setup_device(pmac_ide_hwif_t *p
  		/* This is necessary to enable IDE when net-booting */
 		ppc_md.feature_call(PMAC_FTR_IDE_RESET, np, pmif->aapl_bus_id, 1);
 		ppc_md.feature_call(PMAC_FTR_IDE_ENABLE, np, pmif->aapl_bus_id, 1);
-		mdelay(10);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
 		ppc_md.feature_call(PMAC_FTR_IDE_RESET, np, pmif->aapl_bus_id, 0);
-		mdelay(100);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(IDE_WAKEUP_DELAY);		
 	}
 
 	/* Setup MMIO ops */
 	default_hwif_mmiops(hwif);
+       	hwif->OUTBSYNC = pmac_outbsync;
 
 	/* Tell common code _not_ to mess with resources */
 	hwif->mmio = 2;
@@ -1139,7 +1225,7 @@ pmac_ide_setup_device(pmac_ide_hwif_t *p
 	hwif->drives[0].unmask = 1;
 	hwif->drives[1].unmask = 1;
 	hwif->tuneproc = pmac_ide_tuneproc;
-	if (pmif->kind == controller_un_ata6)
+	if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 		hwif->selectproc = pmac_ide_kauai_selectproc;
 	else
 		hwif->selectproc = pmac_ide_selectproc;
@@ -1187,6 +1273,9 @@ pmac_ide_setup_device(pmac_ide_hwif_t *p
 	return 0;
 }
 
+/*
+ * Attach to a macio probed interface
+ */
 static int __devinit
 pmac_ide_macio_attach(struct macio_dev *mdev, const struct of_match *match)
 {
@@ -1215,17 +1304,8 @@ pmac_ide_macio_attach(struct macio_dev *
 		return -ENXIO;
 	}
 
-	/*
-	 * Some older OFs have bogus sizes, causing request_OF_resource
-	 * to fail. We fix them up here
-	 */
-	if (mdev->ofdev.node->addrs[0].size > 0x1000)
-		mdev->ofdev.node->addrs[0].size = 0x1000;
-	if (mdev->ofdev.node->n_addrs > 1 && mdev->ofdev.node->addrs[1].size > 0x100)
-		mdev->ofdev.node->addrs[1].size = 0x100;
-
 	/* Request memory resource for IO ports */
-	if (request_OF_resource(mdev->ofdev.node, 0, "  (mac-io ata ports)") == NULL) {
+	if (macio_request_resource(mdev, 0, "ide-pmac (ports)")) {
 		printk(KERN_ERR "ide%d: can't request mmio resource !\n", i);
 		return -EBUSY;
 	}
@@ -1235,14 +1315,14 @@ pmac_ide_macio_attach(struct macio_dev *
 	 * fixes in irq.c. That works well enough for the single case
 	 * where that happens though...
 	 */
-	if (mdev->ofdev.node->n_intrs == 0) {
+	if (macio_irq_count(mdev) == 0) {
 		printk(KERN_WARNING "ide%d: no intrs for device %s, using 13\n",
 			i, mdev->ofdev.node->full_name);
 		irq = 13;
 	} else
-		irq = mdev->ofdev.node->intrs[0].line;
+		irq = macio_irq(mdev, 0);
 
-	base =  (unsigned long) ioremap(mdev->ofdev.node->addrs[0].address, 0x400);
+	base =  (unsigned long)ioremap(macio_resource_start(mdev, 0), 0x400);
 	regbase = base;
 
 	hwif->pci_dev = mdev->bus->pdev;
@@ -1253,10 +1333,13 @@ pmac_ide_macio_attach(struct macio_dev *
 	pmif->regbase = regbase;
 	pmif->irq = irq;
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
-	if (mdev->ofdev.node->n_addrs >= 2)
-		pmif->dma_regs = (volatile struct dbdma_regs*)
-			ioremap(mdev->ofdev.node->addrs[1].address, 0x1000);
-	else
+	if (macio_resource_count(mdev) >= 2) {
+		if (macio_request_resource(mdev, 1, "ide-pmac (dma)"))
+			printk(KERN_WARNING "ide%d: can't request DMA resource !\n", i);
+		else
+			pmif->dma_regs = (volatile struct dbdma_regs*)
+				ioremap(macio_resource_start(mdev, 1), 0x1000);
+	} else
 		pmif->dma_regs = NULL;
 #endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
 	dev_set_drvdata(&mdev->ofdev.dev, hwif);
@@ -1269,7 +1352,9 @@ pmac_ide_macio_attach(struct macio_dev *
 		if (pmif->dma_regs)
 			iounmap((void *)pmif->dma_regs);
 		memset(pmif, 0, sizeof(*pmif));
-		release_OF_resource(mdev->ofdev.node, 0);
+		macio_release_resource(mdev, 0);
+		if (pmif->dma_regs)
+			macio_release_resource(mdev, 1);
 	}
 
 	return rc;
@@ -1305,6 +1390,9 @@ pmac_ide_macio_resume(struct macio_dev *
 	return rc;
 }
 
+/*
+ * Attach to a PCI probed interface
+ */
 static int __devinit
 pmac_ide_pci_attach(struct pci_dev *pdev, const struct pci_device_id *id)
 {
@@ -1439,8 +1527,10 @@ static struct macio_driver pmac_ide_maci
 	.resume		= pmac_ide_macio_resume,
 };
 
-static struct pci_device_id pmac_ide_pci_match[] __devinitdata = {
-	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_KAUAI_ATA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+static struct pci_device_id pmac_ide_pci_match[] = {
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVIEC_ID_APPLE_UNI_N_ATA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_IPID_ATA100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_K2_ATA100, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 };
 
 static struct pci_driver pmac_ide_pci_driver = {
@@ -1468,6 +1558,11 @@ pmac_ide_probe(void)
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 
+/*
+ * This is very close to the generic ide-dma version of the function except
+ * that we don't use the fields in the hwif but our own copies for sg_table
+ * and friends. We build & map the sglist for a given request
+ */
 static int __pmac
 pmac_ide_build_sglist(ide_drive_t *drive, struct request *rq)
 {
@@ -1489,6 +1584,9 @@ pmac_ide_build_sglist(ide_drive_t *drive
 	return pci_map_sg(hwif->pci_dev, sg, nents, pmif->sg_dma_direction);
 }
 
+/*
+ * Same as above but for a "raw" taskfile request
+ */
 static int __pmac
 pmac_ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
 {
@@ -1630,7 +1728,9 @@ pmac_ide_destroy_dmatable (ide_drive_t *
 	}
 }
 
-/* Calculate MultiWord DMA timings */
+/*
+ * Pick up best MDMA timing for the drive and apply it
+ */
 static int __pmac
 pmac_ide_mdma_enable(ide_drive_t *drive, u16 mode)
 {
@@ -1685,7 +1785,9 @@ pmac_ide_mdma_enable(ide_drive_t *drive,
 	return 1;
 }
 
-/* Calculate Ultra DMA timings */
+/*
+ * Pick up best UDMA timing for the drive and apply it
+ */
 static int __pmac
 pmac_ide_udma_enable(ide_drive_t *drive, u16 mode)
 {
@@ -1704,7 +1806,7 @@ pmac_ide_udma_enable(ide_drive_t *drive,
 	timing_local[1] = *timings2;
 	
 	/* Calculate timings for interface */
-	if (pmif->kind == controller_un_ata6)
+	if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 		ret = set_timings_udma_ata6(	&timing_local[0],
 						&timing_local[1],
 						mode);
@@ -1733,6 +1835,10 @@ pmac_ide_udma_enable(ide_drive_t *drive,
 	return 1;
 }
 
+/*
+ * Check what is the best DMA timing setting for the drive and
+ * call appropriate functions to apply it.
+ */
 static int __pmac
 pmac_ide_dma_check(ide_drive_t *drive)
 {
@@ -1754,11 +1860,13 @@ pmac_ide_dma_check(ide_drive_t *drive)
 		short mode;
 		
 		map = XFER_MWDMA;
-		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6) {
+		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6
+		    || pmif->kind == controller_k2_ata6) {
 			map |= XFER_UDMA;
 			if (pmif->cable_80) {
 				map |= XFER_UDMA_66;
-				if (pmif->kind == controller_un_ata6)
+				if (pmif->kind == controller_un_ata6 ||
+				    pmif->kind == controller_k2_ata6)
 					map |= XFER_UDMA_100;
 			}
 		}
@@ -1774,6 +1882,10 @@ pmac_ide_dma_check(ide_drive_t *drive)
 	return 0;
 }
 
+/*
+ * Prepare a DMA transfer. We build the DMA table, adjust the timings for
+ * a read on KeyLargo ATA/66 and mark us as waiting for DMA completion
+ */
 static int __pmac
 pmac_ide_dma_start(ide_drive_t *drive, int reading)
 {
@@ -1802,6 +1914,9 @@ pmac_ide_dma_start(ide_drive_t *drive, i
 	return 0;
 }
 
+/*
+ * Start a DMA READ command
+ */
 static int __pmac
 pmac_ide_dma_read(ide_drive_t *drive)
 {
@@ -1831,6 +1946,9 @@ pmac_ide_dma_read(ide_drive_t *drive)
 	return pmac_ide_dma_begin(drive);
 }
 
+/*
+ * Start a DMA WRITE command
+ */
 static int __pmac
 pmac_ide_dma_write (ide_drive_t *drive)
 {
@@ -1865,6 +1983,10 @@ pmac_ide_dma_count (ide_drive_t *drive)
 	return HWIF(drive)->ide_dma_begin(drive);
 }
 
+/*
+ * Kick the DMA controller into life after the DMA command has been issued
+ * to the drive.
+ */
 static int __pmac
 pmac_ide_dma_begin (ide_drive_t *drive)
 {
@@ -1881,6 +2003,9 @@ pmac_ide_dma_begin (ide_drive_t *drive)
 	return 0;
 }
 
+/*
+ * After a DMA transfer, make sure the controller is stopped
+ */
 static int __pmac
 pmac_ide_dma_end (ide_drive_t *drive)
 {
@@ -1900,6 +2025,12 @@ pmac_ide_dma_end (ide_drive_t *drive)
 	return (dstat & (RUN|DEAD|ACTIVE)) != RUN;
 }
 
+/*
+ * Check out that the interrupt we got was for us. We can't always know this
+ * for sure with those Apple interfaces (well, we could on the recent ones but
+ * that's not implemented yet), on the other hand, we don't have shared interrupts
+ * so it's not really a problem
+ */
 static int __pmac
 pmac_ide_dma_test_irq (ide_drive_t *drive)
 {
@@ -1982,6 +2113,10 @@ pmac_ide_dma_lostirq (ide_drive_t *drive
 	return 0;
 }
 
+/*
+ * Allocate the data structures needed for using DMA with an interface
+ * and fill the proper list of functions pointers
+ */
 static void __init 
 pmac_ide_setup_dma(pmac_ide_hwif_t *pmif, ide_hwif_t *hwif)
 {
@@ -2049,6 +2184,7 @@ pmac_ide_setup_dma(pmac_ide_hwif_t *pmif
 	hwif->atapi_dma = 1;
 	switch(pmif->kind) {
 		case controller_un_ata6:
+		case controller_k2_ata6:
 			hwif->ultra_mask = pmif->cable_80 ? 0x3f : 0x07;
 			hwif->mwdma_mask = 0x07;
 			hwif->swdma_mask = 0x00;
diff -purN /dev/shm/linux-2.5/drivers/macintosh/Kconfig linuxppc-2.5-benh/drivers/macintosh/Kconfig
--- /dev/shm/linux-2.5/drivers/macintosh/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/Kconfig	2004-01-30 00:08:45.000000000 +0000
@@ -0,0 +1,156 @@
+
+menu "Macintosh device drivers"
+
+# we want to change this to something like CONFIG_SYSCTRL_CUDA/PMU
+config ADB_CUDA
+	bool "Support for CUDA based PowerMacs"
+	depends on PPC_PMAC && !PPC_PMAC64
+	help
+	  This provides support for CUDA based Power Macintosh systems.  This
+	  includes most OldWorld PowerMacs, the first generation iMacs, the
+	  Blue&White G3 and the "Yikes" G4 (PCI Graphics).  All later models
+	  should use CONFIG_ADB_PMU instead.  It is safe to say Y here even if
+	  your machine doesn't have a CUDA.
+
+	  If unsure say Y.
+
+config ADB_PMU
+	bool "Support for PMU  based PowerMacs"
+	depends on PPC_PMAC
+	help
+	  On PowerBooks, iBooks, and recent iMacs and Power Macintoshes, the
+	  PMU is an embedded microprocessor whose primary function is to
+	  control system power, and battery charging on the portable models.
+	  The PMU also controls the ADB (Apple Desktop Bus) which connects to
+	  the keyboard and mouse on some machines, as well as the non-volatile
+	  RAM and the RTC (real time clock) chip.  Say Y to enable support for
+	  this device; you should do so if your machine is one of those
+	  mentioned above.
+
+config PMAC_PBOOK
+	bool "Power management support for PowerBooks"
+	depends on ADB_PMU
+	---help---
+	  This provides support for putting a PowerBook to sleep; it also
+	  enables media bay support.  Power management works on the
+	  PB2400/3400/3500, Wallstreet, Lombard, and Bronze PowerBook G3 and
+	  the Titanium Powerbook G4, as well as the iBooks.  You should get
+	  the power management daemon, pmud, to make it work and you must have
+	  the /dev/pmu device (see the pmud README).
+
+	  Get pmud from <ftp://ftp.samba.org/pub/ppclinux/pmud/>.
+
+	  If you have a PowerBook, you should say Y here.
+
+	  You may also want to compile the dma sound driver as a module and
+	  have it autoloaded. The act of removing the module shuts down the
+	  sound hardware for more power savings.
+
+config PM
+	bool
+	depends on PPC_PMAC && ADB_PMU && PMAC_PBOOK
+	default y
+
+config PMAC_APM_EMU
+	tristate "APM emulation"
+	depends on PMAC_PBOOK
+
+# made a separate option since backlight may end up beeing used
+# on non-powerbook machines (but only on PMU based ones AFAIK)
+config PMAC_BACKLIGHT
+	bool "Backlight control for LCD screens"
+	depends on ADB_PMU
+	help
+	  Say Y here to build in code to manage the LCD backlight on a
+	  Macintosh PowerBook.  With this code, the backlight will be turned
+	  on and off appropriately on power-management and lid-open/lid-closed
+	  events; also, the PowerBook button device will be enabled so you can
+	  change the screen brightness.
+
+config MAC_FLOPPY
+	bool "Support for PowerMac floppy"
+	depends on PPC_PMAC && !PPC_PMAC64
+	help
+	  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)
+	  floppy controller, say Y here. Most commonly found in PowerMacs.
+
+config MAC_SERIAL
+	tristate "Support for PowerMac serial ports (OBSOLETE DRIVER)"
+	depends on PPC_PMAC
+	help
+	  This driver is obsolete. Use CONFIG_SERIAL_PMACZILOG in
+	  "Character devices --> Serial drivers --> PowerMac z85c30" option.
+
+config ADB
+	bool "Apple Desktop Bus (ADB) support"
+	depends on PPC_PMAC
+	help
+	  Apple Desktop Bus (ADB) support is for support of devices which
+	  are connected to an ADB port.  ADB devices tend to have 4 pins.
+	  If you have an Apple Macintosh prior to the iMac, an iBook or
+	  PowerBook, or a "Blue and White G3", you probably want to say Y
+	  here.  Otherwise say N.
+
+config ADB_MACIO
+	bool "Include MacIO (CHRP) ADB driver"
+	depends on ADB && !PPC_PMAC64
+	help
+	  Say Y here to include direct support for the ADB controller in the
+	  Hydra chip used on PowerPC Macintoshes of the CHRP type.  (The Hydra
+	  also includes a MESH II SCSI controller, DBDMA controller, VIA chip,
+	  OpenPIC controller and two RS422/Geoports.)
+
+config INPUT_ADBHID
+	bool "Support for ADB input devices (keyboard, mice, ...)"
+	depends on ADB && INPUT=y
+	help
+	  Say Y here if you want to have ADB (Apple Desktop Bus) HID devices
+	  such as keyboards, mice, joysticks, trackpads  or graphic tablets
+	  handled by the input layer.  If you say Y here, make sure to say Y to
+	  the corresponding drivers "Keyboard support" (CONFIG_INPUT_KEYBDEV),
+	  "Mouse Support" (CONFIG_INPUT_MOUSEDEV) and "Event interface
+	  support" (CONFIG_INPUT_EVDEV) as well.
+
+	  If unsure, say Y.
+
+config MAC_EMUMOUSEBTN
+	bool "Support for mouse button 2+3 emulation"
+	depends on INPUT_ADBHID
+	help
+	  This provides generic support for emulating the 2nd and 3rd mouse
+	  button with keypresses.  If you say Y here, the emulation is still
+	  disabled by default.  The emulation is controlled by these sysctl
+	  entries:
+	  /proc/sys/dev/mac_hid/mouse_button_emulation
+	  /proc/sys/dev/mac_hid/mouse_button2_keycode
+	  /proc/sys/dev/mac_hid/mouse_button3_keycode
+
+	  If you have an Apple machine with a 1-button mouse, say Y here.
+
+config THERM_WINDTUNNEL
+	tristate "Support for thermal management on Windtunnel G4s"
+	depends on I2C && I2C_KEYWEST && !PPC_PMAC64
+	help
+	  This driver provides some thermostat and fan control for the desktop
+	  G4 "Windtunnel"
+
+config THERM_IBOOKG4
+	tristate "Support for thermal management on iBook G4"
+	depends on I2C && I2C_KEYWEST && !PPC_PMAC64
+	help
+	  This driver provides some thermostat and fan control for the
+          iBook G4, allowing slighlty better fan behaviour by default,
+	  and optionally some manual control.
+
+config THERM_PM72
+	tristate "Support for thermal management on PowerMac G5"
+	depends on I2C && I2C_KEYWEST && PPC_PMAC64
+	help
+	  This driver provides thermostat and fan control for the desktop
+	  G5 machines. 
+
+config ANSLCD
+	bool "Support for ANS LCD display"
+	depends on ADB_CUDA
+
+endmenu
diff -purN /dev/shm/linux-2.5/drivers/macintosh/Makefile linuxppc-2.5-benh/drivers/macintosh/Makefile
--- /dev/shm/linux-2.5/drivers/macintosh/Makefile	2003-08-09 16:39:19.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/Makefile	2004-01-09 13:50:23.000000000 +0000
@@ -4,13 +4,11 @@
 
 # Each configuration option enables a list of files.
 
+# Turn that into a separate config option
 obj-$(CONFIG_PPC_PMAC)		+= macio_asic.o
 
 obj-$(CONFIG_PMAC_PBOOK)	+= mediabay.o
 obj-$(CONFIG_MAC_SERIAL)	+= macserial.o
-ifneq ($(CONFIG_MAC),y)
-  obj-$(CONFIG_NVRAM)		+= nvram.o
-endif
 obj-$(CONFIG_MAC_EMUMOUSEBTN)	+= mac_hid.o
 obj-$(CONFIG_INPUT_ADBHID)	+= adbhid.o
 obj-$(CONFIG_ANSLCD)		+= ans-lcd.o
@@ -25,3 +23,7 @@ obj-$(CONFIG_ADB_MACIISI)	+= via-maciisi
 obj-$(CONFIG_ADB_IOP)		+= adb-iop.o
 obj-$(CONFIG_ADB_PMU68K)	+= via-pmu68k.o
 obj-$(CONFIG_ADB_MACIO)		+= macio-adb.o
+
+obj-$(CONFIG_THERM_PM72)	+= therm_pm72.o
+obj-$(CONFIG_THERM_WINDTUNNEL)	+= therm_windtunnel.o
+obj-$(CONFIG_THERM_IBOOKG4)	+= therm_adt7467.o
diff -purN /dev/shm/linux-2.5/drivers/macintosh/adb.c linuxppc-2.5-benh/drivers/macintosh/adb.c
--- /dev/shm/linux-2.5/drivers/macintosh/adb.c	2003-09-22 02:03:32.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/adb.c	2004-01-30 00:08:45.000000000 +0000
@@ -83,6 +83,7 @@ static pid_t adb_probe_task_pid;
 static DECLARE_MUTEX(adb_probe_mutex);
 static struct completion adb_probe_task_comp;
 static int sleepy_trackpad;
+static int autopoll_devs;
 int __adb_probe_sync;
 
 #ifdef CONFIG_PMAC_PBOOK
@@ -289,10 +290,14 @@ int __init adb_init(void)
 	struct adb_driver *driver;
 	int i;
 
-#ifdef CONFIG_PPC
+#ifdef CONFIG_PPC32
 	if ( (_machine != _MACH_chrp) && (_machine != _MACH_Pmac) )
 		return 0;
 #endif
+#ifdef CONFIG_PPC64
+	if (_machine != _MACH_Pmac)
+		return 0;
+#endif
 #ifdef CONFIG_MAC
 	if (!MACH_IS_MAC)
 		return 0;
@@ -340,6 +345,7 @@ __initcall(adb_init);
 int
 adb_notify_sleep(struct pmu_sleep_notifier *self, int when)
 {
+	extern int __fake_sleep;
 	int ret;
 	
 	switch (when) {
@@ -348,7 +354,7 @@ adb_notify_sleep(struct pmu_sleep_notifi
 		/* We need to get a lock on the probe thread */
 		down(&adb_probe_mutex);
 		/* Stop autopoll */
-		if (adb_controller->autopoll)
+		if (!__fake_sleep && adb_controller->autopoll)
 			adb_controller->autopoll(0);
 		ret = notifier_call_chain(&adb_client_list, ADB_MSG_POWERDOWN, NULL);
 		if (ret & NOTIFY_STOP_MASK) {
@@ -379,7 +385,7 @@ adb_notify_sleep(struct pmu_sleep_notifi
 static int
 do_adb_reset_bus(void)
 {
-	int ret, nret, devs;
+	int ret, nret;
 	
 	if (adb_controller == NULL)
 		return -ENXIO;
@@ -390,7 +396,7 @@ do_adb_reset_bus(void)
 	nret = notifier_call_chain(&adb_client_list, ADB_MSG_PRE_RESET, NULL);
 	if (nret & NOTIFY_STOP_MASK) {
 		if (adb_controller->autopoll)
-			adb_controller->autopoll(devs);
+			adb_controller->autopoll(autopoll_devs);
 		return -EBUSY;
 	}
 
@@ -416,9 +422,9 @@ do_adb_reset_bus(void)
 	}
 
 	if (!ret) {
-		devs = adb_scan_bus();
+		autopoll_devs = adb_scan_bus();
 		if (adb_controller->autopoll)
-			adb_controller->autopoll(devs);
+			adb_controller->autopoll(autopoll_devs);
 	}
 	up(&adb_handler_sem);
 
diff -purN /dev/shm/linux-2.5/drivers/macintosh/adbhid.c linuxppc-2.5-benh/drivers/macintosh/adbhid.c
--- /dev/shm/linux-2.5/drivers/macintosh/adbhid.c	2004-01-14 23:13:26.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/adbhid.c	2004-01-29 05:09:37.000000000 +0000
@@ -30,6 +30,8 @@
  * To do:
  *
  * Improve Kensington support.
+ * Split mouse/kbd
+ * Move to syfs
  */
 
 #include <linux/config.h>
@@ -63,6 +65,15 @@ static struct notifier_block adbhid_adb_
 	.notifier_call	= adb_message_handler,
 };
 
+/* Some special keys */
+#define ADB_KEY_DEL		0x33
+#define ADB_KEY_CMD		0x37
+#define ADB_KEY_CAPSLOCK	0x39
+#define ADB_KEY_FN		0x3f
+#define ADB_KEY_FWDEL		0x75
+#define ADB_KEY_POWER_OLD	0x7e
+#define ADB_KEY_POWER		0x7f
+
 unsigned char adb_to_linux_keycodes[128] = {
 	 30, 31, 32, 33, 35, 34, 44, 45, 46, 47, 86, 48, 16, 17, 18, 19,
 	 21, 20,  2,  3,  4,  5,  7,  6, 13, 10,  8, 12,  9, 11, 27, 24,
@@ -84,8 +95,13 @@ struct adbhid {
 	unsigned char *keycode;
 	char name[64];
 	char phys[32];
+	int flags;
 };
 
+#define FLAG_FN_KEY_PRESSED	0x00000001
+#define FLAG_POWER_FROM_FN	0x00000002
+#define FLAG_EMU_FWDEL_DOWN	0x00000004
+
 static struct adbhid *adbhid[16] = { 0 };
 
 static void adbhid_probe(void);
@@ -148,28 +164,64 @@ adbhid_keyboard_input(unsigned char *dat
 static void
 adbhid_input_keycode(int id, int keycode, int repeat, struct pt_regs *regs)
 {
+	struct adbhid *ahid = adbhid[id];
 	int up_flag;
 
 	up_flag = (keycode & 0x80);
 	keycode &= 0x7f;
 
 	switch (keycode) {
-	case 0x39: /* Generate down/up events for CapsLock everytime. */
-		input_regs(&adbhid[id]->input, regs);
-		input_report_key(&adbhid[id]->input, KEY_CAPSLOCK, 1);
-		input_report_key(&adbhid[id]->input, KEY_CAPSLOCK, 0);
-		input_sync(&adbhid[id]->input);
-		return;
-	case 0x3f: /* ignore Powerbook Fn key */
+	case ADB_KEY_CAPSLOCK: /* Generate down/up events for CapsLock everytime. */
+		input_regs(&ahid->input, regs);
+		input_report_key(&ahid->input, KEY_CAPSLOCK, 1);
+		input_report_key(&ahid->input, KEY_CAPSLOCK, 0);
+		input_sync(&ahid->input);
 		return;
 #ifdef CONFIG_PPC_PMAC
-	case 0x7e: /* Power key on PBook 3400 needs remapping */
+	case ADB_KEY_POWER_OLD: /* Power key on PBook 3400 needs remapping */
 		switch(pmac_call_feature(PMAC_FTR_GET_MB_INFO,
 			NULL, PMAC_MB_INFO_MODEL, 0)) {
 		case PMAC_TYPE_COMET:
 		case PMAC_TYPE_HOOPER:
 		case PMAC_TYPE_KANGA:
-			keycode = 0x7f;
+			keycode = ADB_KEY_POWER;
+		}
+		break;
+	case ADB_KEY_POWER: 
+		/* Fn + Command will produce a bogus "power" keycode */
+		if (ahid->flags & FLAG_FN_KEY_PRESSED) {
+			keycode = ADB_KEY_CMD;
+			if (up_flag)
+				ahid->flags &= ~FLAG_POWER_FROM_FN;
+			else
+				ahid->flags |= FLAG_POWER_FROM_FN;
+		} else if (ahid->flags & FLAG_POWER_FROM_FN) {
+			keycode = ADB_KEY_CMD;
+			ahid->flags &= ~FLAG_POWER_FROM_FN;
+		}
+		break;
+	case ADB_KEY_FN:
+		/* Keep track of the Fn key state */
+		if (up_flag) {
+			ahid->flags &= ~FLAG_FN_KEY_PRESSED;
+			/* Emulate Fn+delete = forward delete */
+			if (ahid->flags & FLAG_EMU_FWDEL_DOWN) {
+				ahid->flags &= ~FLAG_EMU_FWDEL_DOWN;
+				keycode = ADB_KEY_FWDEL;
+				break;
+			}
+		} else
+			ahid->flags |= FLAG_FN_KEY_PRESSED;
+		/* Swallow the key press */
+		return;
+	case ADB_KEY_DEL:
+		/* Emulate Fn+delete = forward delete */
+		if (ahid->flags & FLAG_FN_KEY_PRESSED) {
+			keycode = ADB_KEY_FWDEL;
+			if (up_flag)
+				ahid->flags &= ~FLAG_EMU_FWDEL_DOWN;
+			else
+				ahid->flags |= FLAG_EMU_FWDEL_DOWN;
 		}
 		break;
 #endif /* CONFIG_PPC_PMAC */
@@ -500,6 +552,7 @@ adbhid_input_register(int id, int defaul
 	adbhid[id]->original_handler_id = original_handler_id;
 	adbhid[id]->current_handler_id = current_handler_id;
 	adbhid[id]->mouse_kind = mouse_kind;
+	adbhid[id]->flags = 0;
 	adbhid[id]->input.private = adbhid[id];
 	adbhid[id]->input.name = adbhid[id]->name;
 	adbhid[id]->input.phys = adbhid[id]->phys;
diff -purN /dev/shm/linux-2.5/drivers/macintosh/macio_asic.c linuxppc-2.5-benh/drivers/macintosh/macio_asic.c
--- /dev/shm/linux-2.5/drivers/macintosh/macio_asic.c	2003-08-26 13:35:38.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/macio_asic.c	2004-01-30 00:08:45.000000000 +0000
@@ -23,10 +23,13 @@
 #include <asm/prom.h>
 #include <asm/pci-bridge.h>
 
+#define DEBUG
+
+#define MAX_NODE_NAME_SIZE (BUS_ID_SIZE - 12)
+
 static struct macio_chip      *macio_on_hold;
 
-static int
-macio_bus_match(struct device *dev, struct device_driver *drv) 
+static int macio_bus_match(struct device *dev, struct device_driver *drv) 
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
 	struct macio_driver * macio_drv = to_macio_driver(drv);
@@ -85,41 +88,42 @@ static int macio_device_probe(struct dev
 static int macio_device_remove(struct device *dev)
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
-	struct macio_driver * drv = to_macio_driver(macio_dev->ofdev.dev.driver);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
 
-	if (drv && drv->remove)
+	if (dev->driver && drv->remove)
 		drv->remove(macio_dev);
 	macio_dev_put(macio_dev);
 
 	return 0;
 }
 
+static void macio_device_shutdown(struct device *dev)
+{
+	struct macio_dev * macio_dev = to_macio_device(dev);
+	struct macio_driver * drv = to_macio_driver(dev->driver);
+
+	if (dev->driver && drv->shutdown)
+		drv->shutdown(macio_dev);
+}
+
 static int macio_device_suspend(struct device *dev, u32 state)
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
-	struct macio_driver * drv;
-	int error = 0;
+	struct macio_driver * drv = to_macio_driver(dev->driver);
 
-	if (macio_dev->ofdev.dev.driver == NULL)
-		return 0;
-	drv = to_macio_driver(macio_dev->ofdev.dev.driver);
-	if (drv->suspend)
-		error = drv->suspend(macio_dev, state);
-	return error;
+	if (dev->driver && drv->suspend)
+		return drv->suspend(macio_dev, state);
+	return 0;
 }
 
 static int macio_device_resume(struct device * dev)
 {
 	struct macio_dev * macio_dev = to_macio_device(dev);
-	struct macio_driver * drv;
-	int error = 0;
+	struct macio_driver * drv = to_macio_driver(dev->driver);
 
-	if (macio_dev->ofdev.dev.driver == NULL)
-		return 0;
-	drv = to_macio_driver(macio_dev->ofdev.dev.driver);
-	if (drv->resume)
-		error = drv->resume(macio_dev);
-	return error;
+	if (dev->driver && drv->resume)
+		return drv->resume(macio_dev);
+	return 0;
 }
 
 struct bus_type macio_bus_type = {
@@ -129,8 +133,7 @@ struct bus_type macio_bus_type = {
        .resume	= macio_device_resume,
 };
 
-static int __init
-macio_bus_driver_init(void)
+static int __init macio_bus_driver_init(void)
 {
 	return bus_register(&macio_bus_type);
 }
@@ -155,6 +158,58 @@ static void macio_release_dev(struct dev
 }
 
 /**
+ * macio_resource_quirks - tweak or skip some resources for a device
+ * @np: pointer to the device node
+ * @res: resulting resource
+ * @index: index of resource in node
+ *
+ * If this routine returns non-null, then the resource is completely
+ * skipped.
+ */
+static int macio_resource_quirks(struct device_node *np, struct resource *res, int index)
+{
+	if (res->flags & IORESOURCE_MEM) {
+		/* Grand Central has too large resource 0 on some machines */
+		if (index == 0 && !strcmp(np->name, "gc")) {
+			np->addrs[0].size = 0x20000;
+			res->end = res->start + 0x1ffff;
+		}
+		/* Airport has bogus resource 2 */
+		if (index >= 2 && !strcmp(np->name, "radio"))
+			return 1;
+		/* DBDMAs may have bogus sizes */
+		if ((res->start & 0x0001f000) == 0x00008000) {
+			np->addrs[index].size = 0x100;
+			res->end = res->start + 0xff;
+		}
+		/* ESCC parent eats child resources. We could have added a level of hierarchy,
+		 * but I don't really feel the need for it */
+		if (!strcmp(np->name, "escc"))
+			return 1;
+		/* ESCC has bogus resources >= 3 */
+		if (index >= 3 && !(strcmp(np->name, "ch-a") && strcmp(np->name, "ch-b")))
+			return 1;
+		/* Media bay has too many resources, keep only first one */
+		if (index > 0 && !strcmp(np->name, "media-bay"))
+			return 1;
+		/* Some older IDE resources have bogus sizes */
+		if (!(strcmp(np->name, "IDE") && strcmp(np->name, "ATA") &&
+		      strcmp(np->type, "ide") && strcmp(np->type, "ata"))) {
+			if (index == 0 && np->addrs[0].size > 0x1000) {
+				np->addrs[0].size = 0x1000;
+				res->end = res->start + 0xfff;
+			}
+			if (index == 1 && np->addrs[1].size > 0x100) {
+				np->addrs[1].size = 0x100;
+				res->end = res->start + 0xff;
+			}
+		}
+	}
+	return 0;
+}
+
+
+/**
  * macio_add_one_device - Add one device from OF node to the device tree
  * @chip: pointer to the macio_chip holding the device
  * @np: pointer to the device node in the OF tree
@@ -164,9 +219,11 @@ static void macio_release_dev(struct dev
  * be exposed to the bay driver some way...
  */
 static struct macio_dev * macio_add_one_device(struct macio_chip *chip, struct device *parent,
-		     struct device_node *np, struct macio_dev *in_bay)
+					       struct device_node *np, struct macio_dev *in_bay,
+					       struct resource *parent_res)
 {
 	struct macio_dev *dev;
+	int i, j;
 	u32 *reg;
 	
 	if (np == NULL)
@@ -186,22 +243,76 @@ static struct macio_dev * macio_add_one_
 	dev->ofdev.dev.bus = &macio_bus_type;
 	dev->ofdev.dev.release = macio_release_dev;
 
+#ifdef DEBUG
+	printk("preparing mdev @%p, ofdev @%p, dev @%p, kobj @%p\n",
+	       dev, &dev->ofdev, &dev->ofdev.dev, &dev->ofdev.dev.kobj);
+#endif
+
 	/* MacIO itself has a different reg, we use it's PCI base */
 	if (np == chip->of_node) {
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.8s", chip->lbus.index,
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08lx:%.*s", chip->lbus.index,
 #ifdef CONFIG_PCI
 			pci_resource_start(chip->lbus.pdev, 0),
 #else
 			0, /* NuBus may want to do something better here */
 #endif
-			np->name);
+			MAX_NODE_NAME_SIZE, np->name);
 	} else {
 		reg = (u32 *)get_property(np, "reg", NULL);
-		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.8s", chip->lbus.index,
-			reg ? *reg : 0, np->name);
+		sprintf(dev->ofdev.dev.bus_id, "%1d.%08x:%.*s", chip->lbus.index,
+			reg ? *reg : 0, MAX_NODE_NAME_SIZE, np->name);
 	}
 
+	/* For now, we use pre-parsed entries in the device-tree for
+	 * interrupt routing and addresses, but we should change that
+	 * to dynamically parsed entries and so get rid of most of the
+	 * clutter in struct device_node
+	 */
+	for (i = j = 0; i < np->n_intrs; i++) {
+		struct resource *res = &dev->interrupt[j];
+
+		if (j >= MACIO_DEV_COUNT_IRQS)
+			break;
+		res->start = np->intrs[i].line;
+		res->flags = IORESOURCE_IO;
+		if (np->intrs[j].sense)
+			res->flags |= IORESOURCE_IRQ_LOWLEVEL;
+		else
+			res->flags |= IORESOURCE_IRQ_HIGHEDGE;
+		res->name = dev->ofdev.dev.bus_id;
+		if (macio_resource_quirks(np, res, i))
+			memset(res, 0, sizeof(struct resource));
+		else
+			j++;
+	}
+	dev->n_interrupts = j;
+	for (i = j = 0; i < np->n_addrs; i++) {
+		struct resource *res = &dev->resource[j];
+		
+		if (j >= MACIO_DEV_COUNT_RESOURCES)
+			break;
+		res->start = np->addrs[i].address;
+		res->end = np->addrs[i].address + np->addrs[i].size - 1;
+		res->flags = IORESOURCE_MEM;
+		res->name = dev->ofdev.dev.bus_id;
+		if (macio_resource_quirks(np, res, i))
+			memset(res, 0, sizeof(struct resource));
+		else {
+			j++;
+			/* Currently, we consider failure as harmless, this may
+			 * change in the future, once I've found all the device
+			 * tree bugs in older machines & worked around them
+			 */
+			if (insert_resource(parent_res, res))
+       				printk(KERN_WARNING "Can't request resource %d for MacIO"
+				       " device %s\n", i, dev->ofdev.dev.bus_id);
+		}
+	}
+	dev->n_resources = j;
+
 	if (of_device_register(&dev->ofdev) != 0) {
+		printk(KERN_DEBUG"macio: device registration error for %s!\n",
+		       dev->ofdev.dev.bus_id);
 		kfree(dev);
 		return NULL;
 	}
@@ -234,25 +345,30 @@ static void macio_pci_add_devices(struct
 	struct device_node *np, *pnode;
 	struct macio_dev *rdev, *mdev, *mbdev = NULL, *sdev = NULL;
 	struct device *parent = NULL;
+	struct resource *root_res = &iomem_resource;
 	
 	/* Add a node for the macio bus itself */
 #ifdef CONFIG_PCI
-	if (chip->lbus.pdev)
+	if (chip->lbus.pdev) {
 		parent = &chip->lbus.pdev->dev;
+		root_res = &chip->lbus.pdev->resource[0];
+	}
 #endif
 	pnode = of_node_get(chip->of_node);
 	if (pnode == NULL)
 		return;
 
-	rdev = macio_add_one_device(chip, parent, pnode, NULL);
+	/* Add macio itself to hierarchy */
+	rdev = macio_add_one_device(chip, parent, pnode, NULL, root_res);
 	if (rdev == NULL)
 		return;
+	root_res = &rdev->resource[0];
 
 	/* First scan 1st level */
 	for (np = NULL; (np = of_get_next_child(pnode, np)) != NULL;) {
 		if (!macio_skip_device(np)) {
 			of_node_get(np);
-			mdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL);
+			mdev = macio_add_one_device(chip, &rdev->ofdev.dev, np, NULL, root_res);
 			if (mdev == NULL)
 				of_node_put(np);
 			else if (strncmp(np->name, "media-bay", 9) == 0)
@@ -267,17 +383,20 @@ static void macio_pci_add_devices(struct
 		for (np = NULL; (np = of_get_next_child(mbdev->ofdev.node, np)) != NULL;)
 			if (!macio_skip_device(np)) {
 				of_node_get(np);
-				if (macio_add_one_device(chip, &mbdev->ofdev.dev, np, mbdev) == NULL)
+				if (macio_add_one_device(chip, &mbdev->ofdev.dev, np, mbdev,
+							 root_res) == NULL)
 					of_node_put(np);
 			}
 	/* Add serial ports if any */
-	if (sdev)
+	if (sdev) {
 		for (np = NULL; (np = of_get_next_child(sdev->ofdev.node, np)) != NULL;)
 			if (!macio_skip_device(np)) {
 				of_node_get(np);
-				if (macio_add_one_device(chip, &sdev->ofdev.dev, np, NULL) == NULL)
+				if (macio_add_one_device(chip, &sdev->ofdev.dev, np, NULL,
+							 root_res) == NULL)
 					of_node_put(np);
 			}
+	}
 }
 
 
@@ -294,6 +413,7 @@ int macio_register_driver(struct macio_d
 	drv->driver.bus = &macio_bus_type;
 	drv->driver.probe = macio_device_probe;
 	drv->driver.remove = macio_device_remove;
+	drv->driver.shutdown = macio_device_shutdown;
 
 	/* register with core */
 	count = driver_register(&drv->driver);
@@ -309,6 +429,97 @@ void macio_unregister_driver(struct maci
 	driver_unregister(&drv->driver);
 }
 
+/**
+ *	macio_request_resource - Request an MMIO resource
+ * 	@dev: pointer to the device holding the resource
+ *	@resource_no: resource number to request
+ *	@name: resource name
+ *
+ *	Mark  memory region number @resource_no associated with MacIO
+ *	device @dev as being reserved by owner @name.  Do not access
+ *	any address inside the memory regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name)
+{
+	if (macio_resource_len(dev, resource_no) == 0)
+		return 0;
+		
+	if (!request_mem_region(macio_resource_start(dev, resource_no),
+				macio_resource_len(dev, resource_no),
+				name))
+		goto err_out;
+	
+	return 0;
+
+err_out:
+	printk (KERN_WARNING "MacIO: Unable to reserve resource #%d:%lx@%lx"
+		" for device %s\n",
+		resource_no,
+		macio_resource_len(dev, resource_no),
+		macio_resource_start(dev, resource_no),
+		dev->ofdev.dev.bus_id);
+	return -EBUSY;
+}
+
+/**
+ * macio_release_resource - Release an MMIO resource
+ * @dev: pointer to the device holding the resource
+ * @resource_no: resource number to release
+ */
+void macio_release_resource(struct macio_dev *dev, int resource_no)
+{
+	if (macio_resource_len(dev, resource_no) == 0)
+		return;
+	release_mem_region(macio_resource_start(dev, resource_no),
+			   macio_resource_len(dev, resource_no));
+}
+
+/**
+ *	macio_request_resources - Reserve all memory resources
+ *	@dev: MacIO device whose resources are to be reserved
+ *	@name: Name to be associated with resource.
+ *
+ *	Mark all memory regions associated with MacIO device @dev as
+ *	being reserved by owner @name.  Do not access any address inside
+ *	the memory regions unless this call returns successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int macio_request_resources(struct macio_dev *dev, const char *name)
+{
+	int i;
+	
+	for (i = 0; i < dev->n_resources; i++)
+		if (macio_request_resource(dev, i, name))
+			goto err_out;
+	return 0;
+
+err_out:
+	while(--i >= 0)
+		macio_release_resource(dev, i);
+		
+	return -EBUSY;
+}
+
+/**
+ *	macio_release_resources - Release reserved memory resources
+ *	@dev: MacIO device whose resources were previously reserved
+ */
+
+void macio_release_resources(struct macio_dev *dev)
+{
+	int i;
+	
+	for (i = 0; i < dev->n_resources; i++)
+		macio_release_resource(dev, i);
+}
+
+
 #ifdef CONFIG_PCI
 
 static int __devinit macio_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
@@ -328,6 +539,9 @@ static int __devinit macio_pci_probe(str
 	if (np == NULL)
 		return -ENODEV;
 
+	/* This assumption is wrong, fix that here for now until I fix the arch */
+	of_node_get(np);
+
 	/* We also assume that pmac_feature will have done a get() on nodes stored
 	 * in the macio chips array
 	 */
@@ -416,3 +630,7 @@ EXPORT_SYMBOL(macio_register_driver);
 EXPORT_SYMBOL(macio_unregister_driver);
 EXPORT_SYMBOL(macio_dev_get);
 EXPORT_SYMBOL(macio_dev_put);
+EXPORT_SYMBOL(macio_request_resource);
+EXPORT_SYMBOL(macio_release_resource);
+EXPORT_SYMBOL(macio_request_resources);
+EXPORT_SYMBOL(macio_release_resources);
diff -purN /dev/shm/linux-2.5/drivers/macintosh/mediabay.c linuxppc-2.5-benh/drivers/macintosh/mediabay.c
--- /dev/shm/linux-2.5/drivers/macintosh/mediabay.c	2003-09-22 02:04:05.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/mediabay.c	2004-01-29 04:57:34.000000000 +0000
@@ -101,12 +101,18 @@ int media_bay_count = 0;
 #define MB_IDE_READY(i)	((readb(media_bays[i].cd_base + 0x70) & 0x80) == 0)
 #endif
 
+
 /* Note: All delays are not in milliseconds and converted to HZ relative
  * values by the macro below
  */
 #define MS_TO_HZ(ms)	((ms * HZ + 999) / 1000)
 
 /*
+ * Wait that number of ms between each step in normal polling mode
+ */
+#define MB_POLL_DELAY	25
+
+/*
  * Consider the media-bay ID value stable if it is the same for
  * this number of milliseconds
  */
@@ -121,7 +127,7 @@ int media_bay_count = 0;
  * Hold the media-bay reset signal true for this many ticks
  * after a device is inserted before releasing it.
  */
-#define MB_RESET_DELAY	40
+#define MB_RESET_DELAY	50
 
 /*
  * Wait this long after the reset signal is released and before doing
@@ -390,24 +396,28 @@ static void __pmac poll_media_bay(struct
 	int id = bay->ops->content(bay);
 
 	if (id == bay->last_value) {
-	    if (id != bay->content_id
-	        && ++bay->value_count >= MS_TO_HZ(MB_STABLE_DELAY)) {
-	        /* If the device type changes without going thru "MB_NO", we force
-	           a pass by "MB_NO" to make sure things are properly reset */
-	        if ((id != MB_NO) && (bay->content_id != MB_NO)) {
-	            id = MB_NO;
-		    MBDBG("mediabay%d: forcing MB_NO\n", bay->index);
-		}
-		MBDBG("mediabay%d: switching to %d\n", bay->index, id);
-		set_mb_power(bay, id != MB_NO);
-		bay->content_id = id;
-		if (id == MB_NO) {
+		if (id != bay->content_id) {
+			bay->value_count += MS_TO_HZ(MB_POLL_DELAY);
+			if (bay->value_count >= MS_TO_HZ(MB_STABLE_DELAY)) {
+				/* If the device type changes without going thru
+				 * "MB_NO", we force a pass by "MB_NO" to make sure
+				 * things are properly reset
+				 */
+				if ((id != MB_NO) && (bay->content_id != MB_NO)) {
+					id = MB_NO;
+					MBDBG("mediabay%d: forcing MB_NO\n", bay->index);
+				}
+				MBDBG("mediabay%d: switching to %d\n", bay->index, id);
+				set_mb_power(bay, id != MB_NO);
+				bay->content_id = id;
+				if (id == MB_NO) {
 #ifdef CONFIG_BLK_DEV_IDE
-		    bay->cd_retry = 0;
+					bay->cd_retry = 0;
 #endif
-		    printk(KERN_INFO "media bay %d is empty\n", bay->index);
+					printk(KERN_INFO "media bay %d is empty\n", bay->index);
+				}
+			}
 		}
- 	    }
 	} else {
 		bay->last_value = id;
 		bay->value_count = 0;
@@ -496,8 +506,12 @@ static void __pmac media_bay_step(int i)
 	    poll_media_bay(bay);
 
 	/* If timer expired or polling IDE busy, run state machine */
-	if ((bay->state != mb_ide_waiting) && (bay->timer != 0) && ((--bay->timer) != 0))
-	    return;
+	if ((bay->state != mb_ide_waiting) && (bay->timer != 0)) {
+		bay->timer -= MS_TO_HZ(MB_POLL_DELAY);
+		if (bay->timer > 0)
+			return;
+		bay->timer = 0;
+	}
 
 	switch(bay->state) {
 	case mb_powering_up:
@@ -572,12 +586,13 @@ static void __pmac media_bay_step(int i)
 			}
 			break;
 	    	} else if (bay->timer > 0)
-			bay->timer--;
-	    	if (bay->timer == 0) {
+			bay->timer -= MS_TO_HZ(MB_POLL_DELAY);
+	    	if (bay->timer <= 0) {
 			printk("\nIDE Timeout in bay %d !, IDE state is: 0x%02x\n",
 			       i, readb(bay->cd_base + 0x70));
 			MBDBG("mediabay%d: nIDE Timeout !\n", i);
 			set_mb_power(bay, 0);
+			bay->timer = 0;
 	    	}
 		break;
 #endif /* CONFIG_BLK_DEV_IDE */
@@ -630,7 +645,7 @@ static int __pmac media_bay_task(void *x
 		}
 
 		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(MS_TO_HZ(10));
+		schedule_timeout(MS_TO_HZ(MB_POLL_DELAY));
 		if (signal_pending(current))
 			return 0;
 	}
@@ -645,17 +660,16 @@ static int __devinit media_bay_attach(st
 
 	ofnode = mdev->ofdev.node;
 
-	if (!request_OF_resource(ofnode, 0, NULL))
-		return -ENXIO;
-
+	if (macio_resource_count(mdev) < 1)
+		return -ENODEV;
+	if (macio_request_resources(mdev, "media-bay"))
+		return -EBUSY;
 	/* Media bay registers are located at the beginning of the
          * mac-io chip, we get the parent address for now (hrm...)
          */
-	if (ofnode->parent->n_addrs == 0)
-		return -ENODEV;
 	regbase = (volatile u32 *)ioremap(ofnode->parent->addrs[0].address, 0x100);
 	if (regbase == NULL) {
-		release_OF_resource(ofnode, 0);
+		macio_release_resources(mdev);
 		return -ENOMEM;
 	}
 	
@@ -684,13 +698,13 @@ static int __devinit media_bay_attach(st
 	bay->state = mb_empty;
 	do {
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(MS_TO_HZ(10));
+		schedule_timeout(MS_TO_HZ(MB_POLL_DELAY));
 		media_bay_step(i);
 	} while((bay->state != mb_empty) &&
 		(bay->state != mb_up));
 
 	/* Mark us ready by filling our mdev data */
-	dev_set_drvdata(&mdev->ofdev.dev, bay);
+	macio_set_drvdata(mdev, bay);
 
 	/* Startup kernel thread */
 	if (i == 0)
@@ -702,7 +716,7 @@ static int __devinit media_bay_attach(st
 
 static int __pmac media_bay_suspend(struct macio_dev *mdev, u32 state)
 {
-	struct media_bay_info	*bay = dev_get_drvdata(&mdev->ofdev.dev);
+	struct media_bay_info	*bay = macio_get_drvdata(mdev);
 
 	if (state != mdev->ofdev.dev.power_state && state >= 2) {
 		down(&bay->lock);
@@ -710,7 +724,7 @@ static int __pmac media_bay_suspend(stru
 		set_mb_power(bay, 0);
 		up(&bay->lock);
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(MS_TO_HZ(10));
+		schedule_timeout(MS_TO_HZ(MB_POLL_DELAY));
 		mdev->ofdev.dev.power_state = state;
 	}
 	return 0;
@@ -718,7 +732,7 @@ static int __pmac media_bay_suspend(stru
 
 static int __pmac media_bay_resume(struct macio_dev *mdev)
 {
-	struct media_bay_info	*bay = dev_get_drvdata(&mdev->ofdev.dev);
+	struct media_bay_info	*bay = macio_get_drvdata(mdev);
 
 	if (mdev->ofdev.dev.power_state != 0) {
 		mdev->ofdev.dev.power_state = 0;
@@ -746,7 +760,7 @@ static int __pmac media_bay_resume(struc
 #endif
 	       	do {
 			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(MS_TO_HZ(10));
+			schedule_timeout(MS_TO_HZ(MB_POLL_DELAY));
 	       		media_bay_step(bay->index);
 	       	} while((bay->state != mb_empty) &&
 	       		(bay->state != mb_up));
diff -purN /dev/shm/linux-2.5/drivers/macintosh/nvram.c linuxppc-2.5-benh/drivers/macintosh/nvram.c
--- /dev/shm/linux-2.5/drivers/macintosh/nvram.c	2003-06-07 07:46:01.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/nvram.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,131 +0,0 @@
-/*
- * /dev/nvram driver for Power Macintosh.
- */
-
-#define NVRAM_VERSION "1.0"
-
-#include <linux/module.h>
-
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/miscdevice.h>
-#include <linux/fcntl.h>
-#include <linux/nvram.h>
-#include <linux/init.h>
-#include <linux/smp_lock.h>
-#include <asm/uaccess.h>
-#include <asm/nvram.h>
-
-#define NVRAM_SIZE	8192
-
-static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
-{
-	lock_kernel();
-	switch (origin) {
-	case 1:
-		offset += file->f_pos;
-		break;
-	case 2:
-		offset += NVRAM_SIZE;
-		break;
-	}
-	if (offset < 0) {
-		unlock_kernel();
-		return -EINVAL;
-	}
-	file->f_pos = offset;
-	unlock_kernel();
-	return file->f_pos;
-}
-
-static ssize_t read_nvram(struct file *file, char __user *buf,
-			  size_t count, loff_t *ppos)
-{
-	unsigned int i;
-	char __user *p = buf;
-
-	if (verify_area(VERIFY_WRITE, buf, count))
-		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
-	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count)
-		if (__put_user(nvram_read_byte(i), p))
-			return -EFAULT;
-	*ppos = i;
-	return p - buf;
-}
-
-static ssize_t write_nvram(struct file *file, const char __user *buf,
-			   size_t count, loff_t *ppos)
-{
-	unsigned int i;
-	const char __user *p = buf;
-	char c;
-
-	if (verify_area(VERIFY_READ, buf, count))
-		return -EFAULT;
-	if (*ppos >= NVRAM_SIZE)
-		return 0;
-	for (i = *ppos; count > 0 && i < NVRAM_SIZE; ++i, ++p, --count) {
-		if (__get_user(c, p))
-			return -EFAULT;
-		nvram_write_byte(c, i);
-	}
-	*ppos = i;
-	return p - buf;
-}
-
-static int nvram_ioctl(struct inode *inode, struct file *file,
-	unsigned int cmd, unsigned long arg)
-{
-	switch(cmd) {
-		case PMAC_NVRAM_GET_OFFSET:
-		{
-			int part, offset;
-			if (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)
-				return -EFAULT;
-			if (part < pmac_nvram_OF || part > pmac_nvram_NR)
-				return -EINVAL;
-			offset = pmac_get_partition(part);
-			if (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)
-				return -EFAULT;
-			break;
-		}
-
-		default:
-			return -EINVAL;
-	}
-
-	return 0;
-}
-
-struct file_operations nvram_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= nvram_llseek,
-	.read		= read_nvram,
-	.write		= write_nvram,
-	.ioctl		= nvram_ioctl,
-};
-
-static struct miscdevice nvram_dev = {
-	NVRAM_MINOR,
-	"nvram",
-	&nvram_fops
-};
-
-int __init nvram_init(void)
-{
-	printk(KERN_INFO "Macintosh non-volatile memory driver v%s\n",
-		NVRAM_VERSION);
-	return misc_register(&nvram_dev);
-}
-
-void __exit nvram_cleanup(void)
-{
-        misc_deregister( &nvram_dev );
-}
-
-module_init(nvram_init);
-module_exit(nvram_cleanup);
-MODULE_LICENSE("GPL");
diff -purN /dev/shm/linux-2.5/drivers/macintosh/therm_adt7467.c linuxppc-2.5-benh/drivers/macintosh/therm_adt7467.c
--- /dev/shm/linux-2.5/drivers/macintosh/therm_adt7467.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/therm_adt7467.c	2004-02-04 08:44:30.000000000 +0000
@@ -0,0 +1,562 @@
+/*
+ * Device driver for the i2c thermostat found on the iBook G4, Albook G4
+ *
+ * Copyright (C) 2003, 2004 Colin Leroy, Rasmus Rohde, Benjamin Herrenschmidt
+ *
+ * Documentation from
+ * http://www.analog.com/UploadedFiles/Data_Sheets/115254175ADT7467_pra.pdf
+ * http://www.analog.com/UploadedFiles/Data_Sheets/3686221171167ADT7460_b.pdf
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/wait.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+#include <asm/of_device.h>
+
+#undef DEBUG
+
+#define CONFIG_REG   0x40
+#define MANUAL_MASK  0xe0
+#define AUTO_MASK    0x20
+
+static u8 TEMP_REG[3]    = {0x26, 0x25, 0x27}; /* local, cpu, gpu */
+static u8 LIMIT_REG[3]   = {0x6b, 0x6a, 0x6c}; /* local, cpu, gpu */
+static u8 MANUAL_MODE[2] = {0x5c, 0x5d};       
+static u8 REM_CONTROL[2] = {0x00, 0x40};
+static u8 FAN_SPEED[2]   = {0x28, 0x2a};
+static u8 FAN_SPD_SET[2] = {0x30, 0x31};
+
+static u8 default_limits_local[3] = {70, 50, 70};    /* local, cpu, gpu */
+static u8 default_limits_chip[3] = {80, 65, 80};    /* local, cpu, gpu */
+
+static int limit_adjust = 0;
+static int fan_speed = -1;
+
+MODULE_AUTHOR("Colin Leroy <colin@colino.net>");
+MODULE_DESCRIPTION("Driver for ADT7467 thermostat in iBook G4");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM(limit_adjust,"i");
+MODULE_PARM_DESC(limit_adjust,"Adjust maximum temperatures (50C cpu, 70C gpu) by N C.");
+MODULE_PARM(fan_speed,"i");
+MODULE_PARM_DESC(fan_speed,"Specify fan speed (0-255) when lim < temp < lim+8 (default 128)");
+
+struct thermostat {
+	struct i2c_client	clt;
+	u8			cached_temp[3];
+	u8			initial_limits[3];
+	u8			limits[3];
+	int			last_speed[2];
+	int			overriding[2];
+};
+
+static enum {ADT7460, ADT7467} therm_type;
+static int therm_bus, therm_address;
+static struct of_device * of_dev;
+static struct thermostat* thermostat;
+static pid_t monitor_thread_id;
+static int monitor_running;
+static struct completion monitor_task_compl;
+
+static int attach_one_thermostat(struct i2c_adapter *adapter, int addr, int busno);
+static void write_both_fan_speed(struct thermostat *th, int speed);
+static void write_fan_speed(struct thermostat *th, int speed, int fan);
+
+static int
+write_reg(struct thermostat* th, int reg, u8 data)
+{
+	u8 tmp[2];
+	int rc;
+	
+	tmp[0] = reg;
+	tmp[1] = data;
+	rc = i2c_master_send(&th->clt, (const char *)tmp, 2);
+	if (rc < 0)
+		return rc;
+	if (rc != 2)
+		return -ENODEV;
+	return 0;
+}
+
+static int
+read_reg(struct thermostat* th, int reg)
+{
+	u8 reg_addr, data;
+	int rc;
+
+	reg_addr = (u8)reg;
+	rc = i2c_master_send(&th->clt, &reg_addr, 1);
+	if (rc < 0)
+		return rc;
+	if (rc != 1)
+		return -ENODEV;
+	rc = i2c_master_recv(&th->clt, (char *)&data, 1);
+	if (rc < 0)
+		return rc;
+	return data;
+}
+
+static int
+attach_thermostat(struct i2c_adapter *adapter)
+{
+	unsigned long bus_no;
+
+	if (strncmp(adapter->name, "uni-n", 5))
+		return -ENODEV;
+	bus_no = simple_strtoul(adapter->name + 6, NULL, 10);
+	if (bus_no != therm_bus)
+		return -ENODEV;
+	return attach_one_thermostat(adapter, therm_address, bus_no);
+}
+
+static int
+detach_thermostat(struct i2c_adapter *adapter)
+{
+	struct thermostat* th;
+	int i;
+	
+	if (thermostat == NULL)
+		return 0;
+
+	th = thermostat;
+
+	if (monitor_running) {
+		monitor_running = 0;
+		wait_for_completion(&monitor_task_compl);
+	}
+		
+	printk(KERN_INFO "adt746x: Putting max temperatures back from %d, %d, %d,"
+		" to %d, %d, %d, (C)\n", 
+		th->limits[0], th->limits[1], th->limits[2],
+		th->initial_limits[0], th->initial_limits[1], th->initial_limits[2]);
+	
+	for (i = 0; i < 3; i++)
+		write_reg(th, LIMIT_REG[i], th->initial_limits[i]);
+
+	write_both_fan_speed(th, -1);
+
+	i2c_detach_client(&th->clt);
+
+	thermostat = NULL;
+
+	kfree(th);
+
+	return 0;
+}
+
+static struct i2c_driver thermostat_driver = {  
+	.name		="Apple Thermostat ADT7467",
+	.id		=0xDEAD7467,
+	.flags		=I2C_DF_NOTIFY,
+	.attach_adapter	=&attach_thermostat,
+	.detach_adapter	=&detach_thermostat,
+};
+
+static int read_fan_speed(struct thermostat *th, u8 addr)
+{
+	u8 tmp[2];
+	u16 res;
+	
+	/* should start with low byte */
+	tmp[1] = read_reg(th, addr);
+	tmp[0] = read_reg(th, addr + 1);
+	
+	res = tmp[1] + (tmp[0] << 8);
+	return (90000*60)/res;
+}
+
+static void write_both_fan_speed(struct thermostat *th, int speed)
+{
+	write_fan_speed(th, speed, 0);
+	if (therm_type == ADT7460)
+		write_fan_speed(th, speed, 1);
+}
+
+static void write_fan_speed(struct thermostat *th, int speed, int fan)
+{
+	u8 manual;
+	
+	if (speed > 0xff) 
+		speed = 0xff;
+	else if (speed < -1) 
+		speed = 0;
+	
+	if (therm_type == ADT7467 && fan == 1)
+		return;
+	
+	if (th->last_speed[fan] != speed) {
+		if (speed == -1)
+			printk(KERN_INFO "adt746x: Setting speed to: automatic for %s fan.\n",
+				fan?"GPU":"CPU");
+		else
+			printk(KERN_INFO "adt746x: Setting speed to: %d for %s fan.\n",
+				speed, fan?"GPU":"CPU");
+	} else
+		return;
+	
+	if (speed >= 0) {
+		manual = read_reg(th, MANUAL_MODE[fan]);
+		write_reg(th, MANUAL_MODE[fan], manual|MANUAL_MASK);
+		write_reg(th, FAN_SPD_SET[fan], speed);
+	} else {
+		/* back to automatic */
+		if(therm_type == ADT7460) {
+			manual = read_reg(th, MANUAL_MODE[fan]) & (~MANUAL_MASK);
+			write_reg(th, MANUAL_MODE[fan], manual|REM_CONTROL[fan]);
+		} else {
+			manual = read_reg(th, MANUAL_MODE[fan]);
+			write_reg(th, MANUAL_MODE[fan], manual&(~AUTO_MASK));
+		}
+	}
+	
+	th->last_speed[fan] = speed;			
+}
+
+static int monitor_task(void *arg)
+{
+	struct thermostat* th = arg;
+	u8 temps[3];
+	u8 lims[3];
+	int i;
+#ifdef DEBUG
+	int mfan_speed;
+#endif
+	
+	lock_kernel();
+	daemonize("kfand");
+	unlock_kernel();
+	strcpy(current->comm, "thermostat");
+	monitor_running = 1;
+
+	while(monitor_running)
+	{
+		set_task_state(current, TASK_UNINTERRUPTIBLE);
+		schedule_timeout(2*HZ);
+
+		/* Check status */
+		/* local   : chip */
+		/* remote 1: CPU ?*/
+		/* remote 2: GPU ?*/
+#ifndef DEBUG
+		if (fan_speed != -1) {
+#endif
+			for (i = 0; i < 3; i++) {
+				temps[i]  = read_reg(th, TEMP_REG[i]);
+				lims[i]   = th->limits[i];
+			}
+#ifndef DEBUG
+		}
+#endif		
+		if (fan_speed != -1) {
+			int lastvar = 0;		/* for iBook */
+			for (i = 1; i < 3; i++) {	/* we don't care about local sensor */
+				int started = 0;
+				int fan_number = (therm_type == ADT7460 && i == 2);
+				int var = temps[i] - lims[i];
+				if (var > 8) {
+					if (th->overriding[fan_number] == 0)
+						printk(KERN_INFO "adt746x: Limit exceeded by %dC, overriding specified fan speed for %s.\n",
+							var, fan_number?"GPU":"CPU");
+					th->overriding[fan_number] = 1;
+					write_fan_speed(th, 255, fan_number);
+					started = 1;
+				} else if ((!th->overriding[fan_number] || var < 6) && var > 0) {
+					if (th->overriding[fan_number] == 1)
+						printk(KERN_INFO "adt746x: Limit exceeded by %dC, setting speed to specified for %s.\n",
+							var, fan_number?"GPU":"CPU");					
+					th->overriding[fan_number] = 0;
+					write_fan_speed(th, fan_speed, fan_number);
+					started = 1;
+				} else if (var < -1) {
+					/* don't stop iBook fan if GPU is cold and CPU is not
+					 * so cold (lastvar >= -1) */
+					if (therm_type == ADT7460 || lastvar < -1 || i == 1) {
+						if (th->last_speed[fan_number] != 0)
+							printk(KERN_INFO "adt746x: Stopping %s fan.\n",
+								fan_number?"GPU":"CPU");
+						write_fan_speed(th, 0, fan_number);
+					}
+				}
+				
+				lastvar = var;
+				
+				if (started && therm_type == ADT7467)
+					break; /* we don't want to re-stop the fan
+						* if CPU is heating and GPU is not */
+			}
+		}
+#ifdef DEBUG
+		mfan_speed = read_fan_speed(th, FAN_SPEED[0]);
+		/* only one fan in the iBook G4 */
+				
+		if (temps[0] != th->cached_temp[0]
+		||  temps[1] != th->cached_temp[1]
+		||  temps[2] != th->cached_temp[2]) {
+			printk(KERN_INFO "adt746x: Temperature infos:"
+					 " thermostats: %d,%d,%d C;"
+					 " limits: %d,%d,%d C;"
+					 " fan speed: %d RPM\n",
+				temps[0], temps[1], temps[2],
+				lims[0],  lims[1],  lims[2],
+				mfan_speed);
+		}
+		th->cached_temp[0] = temps[0];
+		th->cached_temp[1] = temps[1];
+		th->cached_temp[2] = temps[2];
+#endif		
+	}
+
+	complete_and_exit(&monitor_task_compl, 0);
+	return 0;
+}
+
+static void
+set_limit(struct thermostat *th, int i)
+{
+		/* Set CPU limit higher to avoid powerdowns */ 
+		th->limits[i] = default_limits_chip[i] + limit_adjust;
+		write_reg(th, LIMIT_REG[i], th->limits[i]);
+		
+		/* set our limits to normal */
+		th->limits[i] = default_limits_local[i] + limit_adjust;
+}
+	
+static int
+attach_one_thermostat(struct i2c_adapter *adapter, int addr, int busno)
+{
+	struct thermostat* th;
+	int rc;
+	int i;
+
+	if (thermostat)
+		return 0;
+	th = (struct thermostat *)kmalloc(sizeof(struct thermostat), GFP_KERNEL);
+	if (!th)
+		return -ENOMEM;
+	memset(th, 0, sizeof(*th));
+	th->clt.addr = addr;
+	th->clt.adapter = adapter;
+	th->clt.driver = &thermostat_driver;
+	th->clt.id = 0xDEAD7467;
+	strcpy(th->clt.name, "thermostat");
+
+	rc = read_reg(th, 0);
+	if (rc < 0) {
+		printk(KERN_ERR "adt746x: Thermostat failed to read config from bus %d !\n",
+			busno);
+		kfree(th);
+		return -ENODEV;
+	}
+	/* force manual control to start the fan quieter */
+	
+	if (fan_speed == -1)
+		fan_speed=128;
+	
+	if(therm_type == ADT7460) {
+		printk(KERN_INFO "adt746x: ADT7460 initializing\n");
+		/* The 7460 needs to be started explicitly */
+		write_reg(th, CONFIG_REG, 1);
+	} else
+		printk(KERN_INFO "adt746x: ADT7467 initializing\n");
+
+	for (i = 0; i < 3; i++) {
+		th->initial_limits[i] = read_reg(th, LIMIT_REG[i]);
+		set_limit(th, i);
+	}
+	
+	printk(KERN_INFO "adt746x: Lowering max temperatures from %d, %d, %d"
+		" to %d, %d, %d (C)\n", 
+		th->initial_limits[0], th->initial_limits[1], th->initial_limits[2], 
+		th->limits[0], th->limits[1], th->limits[2]);
+
+	thermostat = th;
+
+	if (i2c_attach_client(&th->clt)) {
+		printk("adt746x: Thermostat failed to attach client !\n");
+		thermostat = NULL;
+		kfree(th);
+		return -ENODEV;
+	}
+
+	/* be sure to really write fan speed the first time */
+	th->last_speed[0] = -2;
+	th->last_speed[1] = -2;
+	
+	if (fan_speed != -1) {
+		write_both_fan_speed(th, 0);
+	} else {
+		write_both_fan_speed(th, -1);
+	}
+	
+	init_completion(&monitor_task_compl);
+	
+	monitor_thread_id = kernel_thread(monitor_task, th,
+		SIGCHLD | CLONE_KERNEL);
+
+	return 0;
+}
+
+/* 
+ * Now, unfortunately, sysfs doesn't give us a nice void * we could
+ * pass around to the attribute functions, so we don't really have
+ * choice but implement a bunch of them...
+ *
+ */
+#define BUILD_SHOW_FUNC_DEG(name, data)				\
+static ssize_t show_##name(struct device *dev, char *buf)	\
+{								\
+	return sprintf(buf, "%dC\n", data);			\
+}
+#define BUILD_SHOW_FUNC_INT(name, data)				\
+static ssize_t show_##name(struct device *dev, char *buf)	\
+{								\
+	return sprintf(buf, "%d\n", data);			\
+}
+
+#define BUILD_STORE_FUNC_DEG(name, data)			\
+static ssize_t store_##name(struct device *dev, const char *buf, size_t n) \
+{								\
+	int val;						\
+	int i;							\
+	val = simple_strtol(buf, NULL, 10);			\
+	printk(KERN_INFO "Adjusting limits by %dC\n", val);	\
+	limit_adjust = val;					\
+	for (i=0; i < 3; i++)					\
+		set_limit(thermostat, i);			\
+	return n;						\
+}
+
+#define BUILD_STORE_FUNC_INT(name, data)			\
+static ssize_t store_##name(struct device *dev, const char *buf, size_t n) \
+{								\
+	u32 val;						\
+	val = simple_strtoul(buf, NULL, 10);			\
+	if (val < 0 || val > 255)				\
+		return -EINVAL;					\
+	printk(KERN_INFO "Setting fan speed to %d\n", val);	\
+	data = val;						\
+	return n;						\
+}
+
+BUILD_SHOW_FUNC_DEG(cpu_temperature,	 (read_reg(thermostat, TEMP_REG[1])))
+BUILD_SHOW_FUNC_DEG(gpu_temperature,	 (read_reg(thermostat, TEMP_REG[2])))
+BUILD_SHOW_FUNC_DEG(cpu_limit,		 thermostat->limits[1])
+BUILD_SHOW_FUNC_DEG(gpu_limit,		 thermostat->limits[2])
+
+BUILD_SHOW_FUNC_INT(specified_fan_speed, fan_speed)
+BUILD_SHOW_FUNC_INT(cpu_fan_speed,	 (read_fan_speed(thermostat, FAN_SPEED[0])))
+BUILD_SHOW_FUNC_INT(gpu_fan_speed,	 (read_fan_speed(thermostat, FAN_SPEED[1])))
+
+BUILD_STORE_FUNC_INT(specified_fan_speed,fan_speed)
+BUILD_SHOW_FUNC_INT(limit_adjust,	 limit_adjust)
+BUILD_STORE_FUNC_DEG(limit_adjust,	 thermostat)
+		
+static DEVICE_ATTR(cpu_temperature,	S_IRUGO,
+		   show_cpu_temperature,NULL);
+static DEVICE_ATTR(gpu_temperature,	S_IRUGO,
+		   show_gpu_temperature,NULL);
+static DEVICE_ATTR(cpu_limit,		S_IRUGO,
+		   show_cpu_limit,	NULL);
+static DEVICE_ATTR(gpu_limit,		S_IRUGO,
+		   show_gpu_limit,	NULL);
+
+static DEVICE_ATTR(specified_fan_speed,	S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH,
+		   show_specified_fan_speed,store_specified_fan_speed);
+
+static DEVICE_ATTR(cpu_fan_speed,	S_IRUGO,
+		   show_cpu_fan_speed,	NULL);
+static DEVICE_ATTR(gpu_fan_speed,	S_IRUGO,
+		   show_gpu_fan_speed,	NULL);
+
+static DEVICE_ATTR(limit_adjust,	S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH,
+		   show_limit_adjust,	store_limit_adjust);
+
+
+static int __init
+thermostat_init(void)
+{
+	struct device_node* np;
+	u32 *prop;
+	
+	/* Currently, we only deal with the iBook G4, we will support
+	 * all "2003" powerbooks later on
+	 */
+	np = of_find_node_by_name(NULL, "fan");
+	if (!np)
+		return -ENODEV;
+	if (device_is_compatible(np, "adt7460"))
+		therm_type = ADT7460;
+	else if (device_is_compatible(np, "adt7467"))
+		therm_type = ADT7467;
+	else
+		return -ENODEV;
+
+	prop = (u32 *)get_property(np, "reg", NULL);
+	if (!prop)
+		return -ENODEV;
+	therm_bus = ((*prop) >> 8) & 0x0f;
+	therm_address = ((*prop) & 0xff) >> 1;
+
+	printk(KERN_INFO "adt746x: Thermostat bus: %d, address: 0x%02x, limit_adjust: %d, fan_speed: %d\n",
+		therm_bus, therm_address, limit_adjust, fan_speed);
+
+	of_dev = of_platform_device_create(np, "temperatures");
+	
+	if (of_dev == NULL) {
+		printk(KERN_ERR "Can't register temperatures device !\n");
+		return -ENODEV;
+	}
+	
+	device_create_file(&of_dev->dev, &dev_attr_cpu_temperature);
+	device_create_file(&of_dev->dev, &dev_attr_gpu_temperature);
+	device_create_file(&of_dev->dev, &dev_attr_cpu_limit);
+	device_create_file(&of_dev->dev, &dev_attr_gpu_limit);
+	device_create_file(&of_dev->dev, &dev_attr_limit_adjust);
+	device_create_file(&of_dev->dev, &dev_attr_specified_fan_speed);
+	device_create_file(&of_dev->dev, &dev_attr_cpu_fan_speed);
+	if(therm_type == ADT7460)
+		device_create_file(&of_dev->dev, &dev_attr_gpu_fan_speed);
+
+#ifndef CONFIG_I2C_KEYWEST
+	request_module("i2c-keywest");
+#endif
+
+	return i2c_add_driver(&thermostat_driver);
+}
+
+static void __exit
+thermostat_exit(void)
+{
+	if (of_dev) {
+		device_remove_file(&of_dev->dev, &dev_attr_cpu_temperature);
+		device_remove_file(&of_dev->dev, &dev_attr_gpu_temperature);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu_limit);
+		device_remove_file(&of_dev->dev, &dev_attr_gpu_limit);
+		device_remove_file(&of_dev->dev, &dev_attr_limit_adjust);
+		device_remove_file(&of_dev->dev, &dev_attr_specified_fan_speed);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu_fan_speed);
+		if(therm_type == ADT7460)
+			device_remove_file(&of_dev->dev, &dev_attr_gpu_fan_speed);
+		of_device_unregister(of_dev);
+	}
+	i2c_del_driver(&thermostat_driver);
+}
+
+module_init(thermostat_init);
+module_exit(thermostat_exit);
diff -purN /dev/shm/linux-2.5/drivers/macintosh/therm_pm72.c linuxppc-2.5-benh/drivers/macintosh/therm_pm72.c
--- /dev/shm/linux-2.5/drivers/macintosh/therm_pm72.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/therm_pm72.c	2004-01-30 00:08:45.000000000 +0000
@@ -0,0 +1,1241 @@
+/*
+ * Device driver for the thermostats & fan controller of  the
+ * Apple G5 "PowerMac7,2" desktop machines.
+ *
+ * (c) Copyright IBM Corp. 2003
+ *
+ * Maintained by: Benjamin Herrenschmidt
+ *                <benh@kernel.crashing.org>
+ * 
+ *
+ * The algorithm used is the PID control algorithm, used the same
+ * way the published Darwin code does, using the same values that
+ * are present in the Darwin 7.0 snapshot property lists.
+ *
+ * As far as the CPUs control loops are concerned, I use the
+ * calibration & PID constants provided by the EEPROM,
+ * I do _not_ embed any value from the property lists, as the ones
+ * provided by Darwin 7.0 seem to always have an older version that
+ * what I've seen on the actual computers.
+ * It would be interesting to verify that though. Darwin has a
+ * version code of 1.0.0d11 for all control loops it seems, while
+ * so far, the machines EEPROMs contain a dataset versioned 1.0.0f
+ *
+ * Darwin doesn't provide source to all parts, some missing
+ * bits like the AppleFCU driver or the actual scale of some
+ * of the values returned by sensors had to be "guessed" some
+ * way... or based on what Open Firmware does.
+ *
+ * I didn't yet figure out how to get the slots power consumption
+ * out of the FCU, so that part has not been implemented yet and
+ * the slots fan is set to a fixed 50% PWM, hoping this value is
+ * safe enough ...
+ *
+ * Note: I have observed strange oscillations of the CPU control
+ * loop on a dual G5 here. When idle, the CPU exhaust fan tend to
+ * oscillates slowly (over several minutes) between the minimum
+ * of 300RPMs and approx. 1000 RPMs. I don't know what is causing
+ * this, it could be some incorrect constant or an error in the
+ * way I ported the algorithm, or it could be just normal. I
+ * don't have full understanding on the way Apple tweaked the PID
+ * algorithm for the CPU control, it is definitely not a standard
+ * implementation...
+ *
+ * TODO:  - Check MPU structure version/signature
+ *        - Add things like /sbin/overtemp for non-critical
+ *          overtemp conditions so userland can take some policy
+ *          decisions, like slewing down CPUs
+ *	  - Deal with fan failures
+ *
+ * History:
+ *
+ *  Nov. 13, 2003 : 0.5
+ *	- First release
+ *
+ *  Nov. 14, 2003 : 0.6
+ *	- Read fan speed from FCU, low level fan routines now deal
+ *	  with errors & check fan status, though higher level don't
+ *	  do much.
+ *	- Move a bunch of definitions to .h file
+ *
+ *  Nov. 18, 2003 : 0.7
+ *	- Fix build on ppc64 kernel
+ *	- Move back statics definitions to .c file
+ *	- Avoid calling schedule_timeout with a negative number
+ *
+ *  Dev. 18, 2003 : 0.8
+ *	- Fix typo when reading back fan speed on 2 CPU machines
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/wait.h>
+#include <linux/reboot.h>
+#include <linux/kmod.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+#include <asm/of_device.h>
+
+#include "therm_pm72.h"
+
+#define VERSION "0.8"
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(args...)	printk(args)
+#else
+#define DBG(args...)
+#endif
+
+
+/*
+ * Driver statics
+ */
+
+static struct of_device *		of_dev;
+static struct i2c_adapter *		u3_0;
+static struct i2c_adapter *		u3_1;
+static struct i2c_client *		fcu;
+static struct cpu_pid_state		cpu_state[2];
+static struct backside_pid_state	backside_state;
+static struct drives_pid_state		drives_state;
+static int				state;
+static int				cpu_count;
+static pid_t				ctrl_task;
+static struct completion		ctrl_complete;
+static int				critical_state;
+static DECLARE_MUTEX(driver_lock);
+
+/*
+ * i2c_driver structure to attach to the host i2c controller
+ */
+
+static int therm_pm72_attach(struct i2c_adapter *adapter);
+static int therm_pm72_detach(struct i2c_adapter *adapter);
+
+static struct i2c_driver therm_pm72_driver =
+{
+	.name		= "therm_pm72",
+	.id		= 0xDEADBEEF,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= therm_pm72_attach,
+	.detach_adapter	= therm_pm72_detach,
+};
+
+
+static inline void wait_ms(unsigned int ms)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1 + (ms * HZ + 999) / 1000);
+}
+
+/*
+ * Utility function to create an i2c_client structure and
+ * attach it to one of u3 adapters
+ */
+static struct i2c_client *attach_i2c_chip(int id, const char *name)
+{
+	struct i2c_client *clt;
+	struct i2c_adapter *adap;
+
+	if (id & 0x100)
+		adap = u3_1;
+	else
+		adap = u3_0;
+	if (adap == NULL)
+		return NULL;
+
+	clt = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (clt == NULL)
+		return NULL;
+	memset(clt, 0, sizeof(struct i2c_client));
+
+	clt->addr = (id >> 1) & 0x7f;
+	clt->adapter = adap;
+	clt->driver = &therm_pm72_driver;
+	clt->id = 0xDEADBEEF;
+	strncpy(clt->name, name, I2C_NAME_SIZE-1);
+
+	if (i2c_attach_client(clt)) {
+		printk(KERN_ERR "therm_pm72: Failed to attach to i2c ID 0x%x\n", id);
+		kfree(clt);
+		return NULL;
+	}
+	return clt;
+}
+
+/*
+ * Utility function to get rid of the i2c_client structure
+ * (will also detach from the adapter hopepfully)
+ */
+static void detach_i2c_chip(struct i2c_client *clt)
+{
+	i2c_detach_client(clt);
+	kfree(clt);
+}
+
+/*
+ * Here are the i2c chip access wrappers
+ */
+static int read_smon_adc(struct i2c_client *chip, int chan)
+{
+	int ctrl;
+
+	ctrl = i2c_smbus_read_byte_data(chip, 1);
+	i2c_smbus_write_byte_data(chip, 1, (ctrl & 0x1f) | (chan << 5));
+	wait_ms(1);
+	return le16_to_cpu(i2c_smbus_read_word_data(chip, 4)) >> 6;
+}
+
+static int fan_read_reg(int reg, unsigned char *buf, int nb)
+{
+	int tries, nr, nw;
+
+	buf[0] = reg;
+	tries = 0;
+	for (;;) {
+		nw = i2c_master_send(fcu, buf, 1);
+		if (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nw <= 0) {
+		printk(KERN_ERR "Failure writing address to FCU: %d", nw);
+		return -EIO;
+	}
+	tries = 0;
+	for (;;) {
+		nr = i2c_master_recv(fcu, buf, nb);
+		if (nr > 0 || (nr < 0 && nr != ENODEV) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nr <= 0)
+		printk(KERN_ERR "Failure reading data from FCU: %d", nw);
+	return nr;
+}
+
+static int fan_write_reg(int reg, const unsigned char *ptr, int nb)
+{
+	int tries, nw;
+	unsigned char buf[16];
+
+	buf[0] = reg;
+	memcpy(buf+1, ptr, nb);
+	++nb;
+	tries = 0;
+	for (;;) {
+		nw = i2c_master_send(fcu, buf, nb);
+		if (nw > 0 || (nw < 0 && nw != EIO) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nw < 0)
+		printk(KERN_ERR "Failure writing to FCU: %d", nw);
+	return nw;
+}
+
+static int set_rpm_fan(int fan, int rpm)
+{
+	unsigned char buf[2];
+	int rc;
+
+	if (rpm < 300)
+		rpm = 300;
+	else if (rpm > 8191)
+		rpm = 8191;
+	buf[0] = rpm >> 5;
+	buf[1] = rpm << 3;
+	rc = fan_write_reg(0x10 + (fan * 2), buf, 2);
+	if (rc < 0)
+		return -EIO;
+	return 0;
+}
+
+static int get_rpm_fan(int fan, int programmed)
+{
+	unsigned char failure;
+	unsigned char active;
+	unsigned char buf[2];
+	int rc, reg_base;
+
+	rc = fan_read_reg(0xb, &failure, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((failure & (1 << fan)) != 0)
+		return -EFAULT;
+	rc = fan_read_reg(0xd, &active, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((active & (1 << fan)) == 0)
+		return -ENXIO;
+
+	/* Programmed value or real current speed */
+	reg_base = programmed ? 0x10 : 0x11;
+	rc = fan_read_reg(reg_base + (fan * 2), buf, 2);
+	if (rc != 2)
+		return -EIO;
+
+	return (buf[0] << 5) | buf[1] >> 3;
+}
+
+static int set_pwm_fan(int fan, int pwm)
+{
+	unsigned char buf[2];
+	int rc;
+
+	if (pwm < 10)
+		pwm = 10;
+	else if (pwm > 100)
+		pwm = 100;
+	pwm = (pwm * 2559) / 1000;
+	buf[0] = pwm;
+	rc = fan_write_reg(0x30 + (fan * 2), buf, 1);
+	if (rc < 0)
+		return rc;
+	return 0;
+}
+
+static int get_pwm_fan(int fan)
+{
+	unsigned char failure;
+	unsigned char active;
+	unsigned char buf[2];
+	int rc;
+
+	rc = fan_read_reg(0x2b, &failure, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((failure & (1 << fan)) != 0)
+		return -EFAULT;
+	rc = fan_read_reg(0x2d, &active, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((active & (1 << fan)) == 0)
+		return -ENXIO;
+
+	/* Programmed value or real current speed */
+	rc = fan_read_reg(0x30 + (fan * 2), buf, 1);
+	if (rc != 1)
+		return -EIO;
+
+	return (buf[0] * 1000) / 2559;
+}
+
+/*
+ * Utility routine to read the CPU calibration EEPROM data
+ * from the device-tree
+ */
+static int read_eeprom(int cpu, struct mpu_data *out)
+{
+	struct device_node *np;
+	char nodename[64];
+	u8 *data;
+	int len;
+
+	/* prom.c routine for finding a node by path is a bit brain dead
+	 * and requires exact @xxx unit numbers. This is a bit ugly but
+	 * will work for these machines
+	 */
+	sprintf(nodename, "/u3@0,f8000000/i2c@f8001000/cpuid@a%d", cpu ? 2 : 0);
+	np = of_find_node_by_path(nodename);
+	if (np == NULL) {
+		printk(KERN_ERR "therm_pm72: Failed to retreive cpuid node from device-tree\n");
+		return -ENODEV;
+	}
+	data = (u8 *)get_property(np, "cpuid", &len);
+	if (data == NULL) {
+		printk(KERN_ERR "therm_pm72: Failed to retreive cpuid property from device-tree\n");
+		of_node_put(np);
+		return -ENODEV;
+	}
+	memcpy(out, data, sizeof(struct mpu_data));
+	of_node_put(np);
+	
+	return 0;
+}
+
+/* 
+ * Now, unfortunately, sysfs doesn't give us a nice void * we could
+ * pass around to the attribute functions, so we don't really have
+ * choice but implement a bunch of them...
+ *
+ * That sucks a bit, we take the lock because FIX32TOPRINT evaluates
+ * the input twice... I accept patches :)
+ */
+#define BUILD_SHOW_FUNC_FIX(name, data)				\
+static ssize_t show_##name(struct device *dev, char *buf)	\
+{								\
+	ssize_t r;						\
+	down(&driver_lock);					\
+	r = sprintf(buf, "%d.%03d", FIX32TOPRINT(data));	\
+	up(&driver_lock);					\
+	return r;						\
+}
+#define BUILD_SHOW_FUNC_INT(name, data)				\
+static ssize_t show_##name(struct device *dev, char *buf)	\
+{								\
+	return sprintf(buf, "%d", data);			\
+}
+
+BUILD_SHOW_FUNC_FIX(cpu0_temperature, cpu_state[0].last_temp)
+BUILD_SHOW_FUNC_FIX(cpu0_voltage, cpu_state[0].voltage)
+BUILD_SHOW_FUNC_FIX(cpu0_current, cpu_state[0].current_a)
+BUILD_SHOW_FUNC_INT(cpu0_exhaust_fan_rpm, cpu_state[0].rpm)
+BUILD_SHOW_FUNC_INT(cpu0_intake_fan_rpm, cpu_state[0].intake_rpm)
+
+BUILD_SHOW_FUNC_FIX(cpu1_temperature, cpu_state[1].last_temp)
+BUILD_SHOW_FUNC_FIX(cpu1_voltage, cpu_state[1].voltage)
+BUILD_SHOW_FUNC_FIX(cpu1_current, cpu_state[1].current_a)
+BUILD_SHOW_FUNC_INT(cpu1_exhaust_fan_rpm, cpu_state[1].rpm)
+BUILD_SHOW_FUNC_INT(cpu1_intake_fan_rpm, cpu_state[1].intake_rpm)
+
+BUILD_SHOW_FUNC_FIX(backside_temperature, backside_state.last_temp)
+BUILD_SHOW_FUNC_INT(backside_fan_pwm, backside_state.pwm)
+
+BUILD_SHOW_FUNC_FIX(drives_temperature, drives_state.last_temp)
+BUILD_SHOW_FUNC_INT(drives_fan_rpm, drives_state.rpm)
+
+static DEVICE_ATTR(cpu0_temperature,S_IRUGO,show_cpu0_temperature,NULL);
+static DEVICE_ATTR(cpu0_voltage,S_IRUGO,show_cpu0_voltage,NULL);
+static DEVICE_ATTR(cpu0_current,S_IRUGO,show_cpu0_current,NULL);
+static DEVICE_ATTR(cpu0_exhaust_fan_rpm,S_IRUGO,show_cpu0_exhaust_fan_rpm,NULL);
+static DEVICE_ATTR(cpu0_intake_fan_rpm,S_IRUGO,show_cpu0_intake_fan_rpm,NULL);
+
+static DEVICE_ATTR(cpu1_temperature,S_IRUGO,show_cpu1_temperature,NULL);
+static DEVICE_ATTR(cpu1_voltage,S_IRUGO,show_cpu1_voltage,NULL);
+static DEVICE_ATTR(cpu1_current,S_IRUGO,show_cpu1_current,NULL);
+static DEVICE_ATTR(cpu1_exhaust_fan_rpm,S_IRUGO,show_cpu1_exhaust_fan_rpm,NULL);
+static DEVICE_ATTR(cpu1_intake_fan_rpm,S_IRUGO,show_cpu1_intake_fan_rpm,NULL);
+
+static DEVICE_ATTR(backside_temperature,S_IRUGO,show_backside_temperature,NULL);
+static DEVICE_ATTR(backside_fan_pwm,S_IRUGO,show_backside_fan_pwm,NULL);
+
+static DEVICE_ATTR(drives_temperature,S_IRUGO,show_drives_temperature,NULL);
+static DEVICE_ATTR(drives_fan_rpm,S_IRUGO,show_drives_fan_rpm,NULL);
+
+/*
+ * CPUs fans control loop
+ */
+static void do_monitor_cpu(struct cpu_pid_state *state)
+{
+	s32 temp, voltage, current_a, power, power_target;
+	s32 integral, derivative, proportional, adj_in_target, sval;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, intake, rc;
+
+	DBG("cpu %d:\n", state->index);
+
+	/* Read current fan status */
+	if (state->index == 0)
+		rc = get_rpm_fan(CPUA_EXHAUST_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	else
+		rc = get_rpm_fan(CPUB_EXHAUST_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading CPU %d exhaust fan !\n",
+		       rc, state->index);
+		/* XXX What do we do now ? */
+	} else
+		state->rpm = rc;
+	DBG("  current rpm: %d\n", state->rpm);
+
+	/* Get some sensor readings and scale it */
+	temp = read_smon_adc(state->monitor, 1);
+	voltage = read_smon_adc(state->monitor, 3);
+	current_a = read_smon_adc(state->monitor, 4);
+
+	/* Fixup temperature according to diode calibration
+	 */
+	DBG("  temp raw: %04x, m_diode: %04x, b_diode: %04x\n",
+	    temp, state->mpu.mdiode, state->mpu.bdiode);
+	temp = ((s32)temp * (s32)state->mpu.mdiode + ((s32)state->mpu.bdiode << 12)) >> 2;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d\n", FIX32TOPRINT(temp));
+
+	/* Check tmax, increment overtemp if we are there. At tmax+8, we go
+	 * full blown immediately and try to trigger a shutdown
+	 */
+	if (temp >= ((state->mpu.tmax + 8) << 16)) {
+		printk(KERN_WARNING "Warning ! CPU %d temperature way above maximum (%d) !\n",
+		       state->index, temp >> 16);
+		state->overtemp = CPU_MAX_OVERTEMP;
+	} else if (temp > (state->mpu.tmax << 16))
+		state->overtemp++;
+	else
+		state->overtemp = 0;
+	if (state->overtemp >= CPU_MAX_OVERTEMP)
+		critical_state = 1;
+	if (state->overtemp > 0) {
+		state->rpm = state->mpu.rmaxn_exhaust_fan;
+		state->intake_rpm = intake = state->mpu.rmaxn_intake_fan;
+		goto do_set_fans;
+	}
+	
+	/* Scale other sensor values according to fixed scales
+	 * obtained in Darwin and calculate power from I and V
+	 */
+	state->voltage = voltage *= ADC_CPU_VOLTAGE_SCALE;
+	state->current_a = current_a *= ADC_CPU_CURRENT_SCALE;
+	power = (((u64)current_a) * ((u64)voltage)) >> 16;
+
+	/* Calculate power target value (could be done once for all)
+	 * and convert to a 16.16 fp number
+	 */
+	power_target = ((u32)(state->mpu.pmaxh - state->mpu.padjmax)) << 16;
+
+	DBG("  current: %d.%03d, voltage: %d.%03d\n",
+	    FIX32TOPRINT(current_a), FIX32TOPRINT(voltage));
+	DBG("  power: %d.%03d W, target: %d.%03d, error: %d.%03d\n", FIX32TOPRINT(power),
+	    FIX32TOPRINT(power_target), FIX32TOPRINT(power_target - power));
+
+	/* Store temperature and power in history array */
+	state->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;
+	state->temp_history[state->cur_temp] = temp;
+	state->cur_power = (state->cur_power + 1) % state->count_power;
+	state->power_history[state->cur_power] = power;
+	state->error_history[state->cur_power] = power_target - power;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (state->count_power - 1); i++) {
+			state->cur_power = (state->cur_power + 1) % state->count_power;
+			state->power_history[state->cur_power] = power;
+			state->error_history[state->cur_power] = power_target - power;
+		}
+		for (i = 0; i < (CPU_TEMP_HISTORY_SIZE - 1); i++) {
+			state->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;
+			state->temp_history[state->cur_temp] = temp;			
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term normally based on the "power" values */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < state->count_power; i++)
+		integral += state->error_history[i];
+	integral *= CPU_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+
+	/* Calculate the adjusted input (sense value).
+	 *   G_r is 12.20
+	 *   integ is 16.16
+	 *   so the result is 28.36
+	 *
+	 * input target is mpu.ttarget, input max is mpu.tmax
+	 */
+	integ_p = ((s64)state->mpu.pid_gr) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(deriv_p >> 36));
+	sval = (state->mpu.tmax << 16) - ((integ_p >> 20) & 0xffffffff);
+	adj_in_target = (state->mpu.ttarget << 16);
+	if (adj_in_target > sval)
+		adj_in_target = sval;
+	DBG("   adj_in_target: %d.%03d, ttarget: %d\n", FIX32TOPRINT(adj_in_target),
+	    state->mpu.ttarget);
+
+	/* Calculate the derivative term */
+	derivative = state->temp_history[state->cur_temp] -
+		state->temp_history[(state->cur_temp + CPU_TEMP_HISTORY_SIZE - 1)
+				    % CPU_TEMP_HISTORY_SIZE];
+	derivative /= CPU_PID_INTERVAL;
+	deriv_p = ((s64)state->mpu.pid_gd) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	proportional = temp - adj_in_target;
+	prop_p = ((s64)state->mpu.pid_gp) * (s64)proportional;
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->rpm += (s32)sum;
+
+	if (state->rpm < state->mpu.rminn_exhaust_fan)
+		state->rpm = state->mpu.rminn_exhaust_fan;
+	if (state->rpm > state->mpu.rmaxn_exhaust_fan)
+		state->rpm = state->mpu.rmaxn_exhaust_fan;
+
+	intake = (state->rpm * CPU_INTAKE_SCALE) >> 16;
+	if (intake < state->mpu.rminn_intake_fan)
+		intake = state->mpu.rminn_intake_fan;
+	if (intake > state->mpu.rmaxn_intake_fan)
+		intake = state->mpu.rmaxn_intake_fan;
+	state->intake_rpm = intake;
+
+ do_set_fans:
+	DBG("** CPU %d RPM: %d Ex, %d In, overtemp: %d\n",
+	    state->index, (int)state->rpm, intake, state->overtemp);
+
+	/* We should check for errors, shouldn't we ? But then, what
+	 * do we do once the error occurs ? For FCU notified fan
+	 * failures (-EFAULT) we probably want to notify userland
+	 * some way...
+	 */
+	if (state->index == 0) {
+		set_rpm_fan(CPUA_INTAKE_FAN_RPM_ID, intake);
+		set_rpm_fan(CPUA_EXHAUST_FAN_RPM_ID, state->rpm);
+	} else {
+		set_rpm_fan(CPUB_INTAKE_FAN_RPM_ID, intake);
+		set_rpm_fan(CPUB_EXHAUST_FAN_RPM_ID, state->rpm);
+	}
+}
+
+/*
+ * Initialize the state structure for one CPU control loop
+ */
+static int init_cpu_state(struct cpu_pid_state *state, int index)
+{
+	state->index = index;
+	state->first = 1;
+	state->rpm = 1000;
+	state->overtemp = 0;
+
+	if (index == 0)
+		state->monitor = attach_i2c_chip(SUPPLY_MONITOR_ID, "CPU0_monitor");
+	else if (index == 1)
+		state->monitor = attach_i2c_chip(SUPPLY_MONITORB_ID, "CPU1_monitor");
+	if (state->monitor == NULL)
+		goto fail;
+
+	if (read_eeprom(index, &state->mpu))
+		goto fail;
+
+	state->count_power = state->mpu.tguardband;
+	if (state->count_power > CPU_POWER_HISTORY_SIZE) {
+		printk(KERN_WARNING "Warning ! too many power history slots\n");
+		state->count_power = CPU_POWER_HISTORY_SIZE;
+	}
+	DBG("CPU %d Using %d power history entries\n", index, state->count_power);
+
+	if (index == 0) {
+		device_create_file(&of_dev->dev, &dev_attr_cpu0_temperature);
+		device_create_file(&of_dev->dev, &dev_attr_cpu0_voltage);
+		device_create_file(&of_dev->dev, &dev_attr_cpu0_current);
+		device_create_file(&of_dev->dev, &dev_attr_cpu0_exhaust_fan_rpm);
+		device_create_file(&of_dev->dev, &dev_attr_cpu0_intake_fan_rpm);
+	} else {
+		device_create_file(&of_dev->dev, &dev_attr_cpu1_temperature);
+		device_create_file(&of_dev->dev, &dev_attr_cpu1_voltage);
+		device_create_file(&of_dev->dev, &dev_attr_cpu1_current);
+		device_create_file(&of_dev->dev, &dev_attr_cpu1_exhaust_fan_rpm);
+		device_create_file(&of_dev->dev, &dev_attr_cpu1_intake_fan_rpm);
+	}
+
+	return 0;
+ fail:
+	if (state->monitor)
+		detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+	
+	return -ENODEV;
+}
+
+/*
+ * Dispose of the state data for one CPU control loop
+ */
+static void dispose_cpu_state(struct cpu_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	if (state->index == 0) {
+		device_remove_file(&of_dev->dev, &dev_attr_cpu0_temperature);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu0_voltage);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu0_current);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu0_exhaust_fan_rpm);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu0_intake_fan_rpm);
+	} else {
+		device_remove_file(&of_dev->dev, &dev_attr_cpu1_temperature);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu1_voltage);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu1_current);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu1_exhaust_fan_rpm);
+		device_remove_file(&of_dev->dev, &dev_attr_cpu1_intake_fan_rpm);
+	}
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+
+/*
+ * Motherboard backside & U3 heatsink fan control loop
+ */
+static void do_monitor_backside(struct backside_pid_state *state)
+{
+	s32 temp, integral, derivative;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, rc;
+
+	if (--state->ticks != 0)
+		return;
+	state->ticks = BACKSIDE_PID_INTERVAL;
+
+	DBG("backside:\n");
+
+	/* Check fan status */
+	rc = get_pwm_fan(BACKSIDE_FAN_PWM_ID);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading backside fan !\n", rc);
+		/* XXX What do we do now ? */
+	} else
+		state->pwm = rc;
+	DBG("  current pwm: %d\n", state->pwm);
+
+	/* Get some sensor readings */
+	temp = i2c_smbus_read_byte_data(state->monitor, MAX6690_EXT_TEMP) << 16;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),
+	    FIX32TOPRINT(BACKSIDE_PID_INPUT_TARGET));
+
+	/* Store temperature and error in history array */
+	state->cur_sample = (state->cur_sample + 1) % BACKSIDE_PID_HISTORY_SIZE;
+	state->sample_history[state->cur_sample] = temp;
+	state->error_history[state->cur_sample] = temp - BACKSIDE_PID_INPUT_TARGET;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (BACKSIDE_PID_HISTORY_SIZE - 1); i++) {
+			state->cur_sample = (state->cur_sample + 1) %
+				BACKSIDE_PID_HISTORY_SIZE;
+			state->sample_history[state->cur_sample] = temp;
+			state->error_history[state->cur_sample] =
+				temp - BACKSIDE_PID_INPUT_TARGET;
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < BACKSIDE_PID_HISTORY_SIZE; i++)
+		integral += state->error_history[i];
+	integral *= BACKSIDE_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+	integ_p = ((s64)BACKSIDE_PID_G_r) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(integ_p >> 36));
+	sum += integ_p;
+
+	/* Calculate the derivative term */
+	derivative = state->error_history[state->cur_sample] -
+		state->error_history[(state->cur_sample + BACKSIDE_PID_HISTORY_SIZE - 1)
+				    % BACKSIDE_PID_HISTORY_SIZE];
+	derivative /= BACKSIDE_PID_INTERVAL;
+	deriv_p = ((s64)BACKSIDE_PID_G_d) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	prop_p = ((s64)BACKSIDE_PID_G_p) * (s64)(state->error_history[state->cur_sample]);
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->pwm += (s32)sum;
+	if (state->pwm < BACKSIDE_PID_OUTPUT_MIN)
+		state->pwm = BACKSIDE_PID_OUTPUT_MIN;
+	if (state->pwm > BACKSIDE_PID_OUTPUT_MAX)
+		state->pwm = BACKSIDE_PID_OUTPUT_MAX;
+
+	DBG("** BACKSIDE PWM: %d\n", (int)state->pwm);
+	set_pwm_fan(BACKSIDE_FAN_PWM_ID, state->pwm);
+}
+
+/*
+ * Initialize the state structure for the backside fan control loop
+ */
+static int init_backside_state(struct backside_pid_state *state)
+{
+	state->ticks = 1;
+	state->first = 1;
+	state->pwm = 50;
+
+	state->monitor = attach_i2c_chip(BACKSIDE_MAX_ID, "backside_temp");
+	if (state->monitor == NULL)
+		return -ENODEV;
+
+	device_create_file(&of_dev->dev, &dev_attr_backside_temperature);
+	device_create_file(&of_dev->dev, &dev_attr_backside_fan_pwm);
+
+	return 0;
+}
+
+/*
+ * Dispose of the state data for the backside control loop
+ */
+static void dispose_backside_state(struct backside_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	device_remove_file(&of_dev->dev, &dev_attr_backside_temperature);
+	device_remove_file(&of_dev->dev, &dev_attr_backside_fan_pwm);
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+ 
+/*
+ * Drives bay fan control loop
+ */
+static void do_monitor_drives(struct drives_pid_state *state)
+{
+	s32 temp, integral, derivative;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, rc;
+
+	if (--state->ticks != 0)
+		return;
+	state->ticks = DRIVES_PID_INTERVAL;
+
+	DBG("drives:\n");
+
+	/* Check fan status */
+	rc = get_rpm_fan(DRIVES_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading drives fan !\n", rc);
+		/* XXX What do we do now ? */
+	} else
+		state->rpm = rc;
+	DBG("  current rpm: %d\n", state->rpm);
+
+	/* Get some sensor readings */
+	temp = le16_to_cpu(i2c_smbus_read_word_data(state->monitor, DS1775_TEMP)) << 8;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),
+	    FIX32TOPRINT(DRIVES_PID_INPUT_TARGET));
+
+	/* Store temperature and error in history array */
+	state->cur_sample = (state->cur_sample + 1) % DRIVES_PID_HISTORY_SIZE;
+	state->sample_history[state->cur_sample] = temp;
+	state->error_history[state->cur_sample] = temp - DRIVES_PID_INPUT_TARGET;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (DRIVES_PID_HISTORY_SIZE - 1); i++) {
+			state->cur_sample = (state->cur_sample + 1) %
+				DRIVES_PID_HISTORY_SIZE;
+			state->sample_history[state->cur_sample] = temp;
+			state->error_history[state->cur_sample] =
+				temp - DRIVES_PID_INPUT_TARGET;
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < DRIVES_PID_HISTORY_SIZE; i++)
+		integral += state->error_history[i];
+	integral *= DRIVES_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+	integ_p = ((s64)DRIVES_PID_G_r) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(integ_p >> 36));
+	sum += integ_p;
+
+	/* Calculate the derivative term */
+	derivative = state->error_history[state->cur_sample] -
+		state->error_history[(state->cur_sample + DRIVES_PID_HISTORY_SIZE - 1)
+				    % DRIVES_PID_HISTORY_SIZE];
+	derivative /= DRIVES_PID_INTERVAL;
+	deriv_p = ((s64)DRIVES_PID_G_d) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	prop_p = ((s64)DRIVES_PID_G_p) * (s64)(state->error_history[state->cur_sample]);
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->rpm += (s32)sum;
+	if (state->rpm < DRIVES_PID_OUTPUT_MIN)
+		state->rpm = DRIVES_PID_OUTPUT_MIN;
+	if (state->rpm > DRIVES_PID_OUTPUT_MAX)
+		state->rpm = DRIVES_PID_OUTPUT_MAX;
+
+	DBG("** DRIVES RPM: %d\n", (int)state->rpm);
+	set_rpm_fan(DRIVES_FAN_RPM_ID, state->rpm);
+}
+
+/*
+ * Initialize the state structure for the drives bay fan control loop
+ */
+static int init_drives_state(struct drives_pid_state *state)
+{
+	state->ticks = 1;
+	state->first = 1;
+	state->rpm = 1000;
+
+	state->monitor = attach_i2c_chip(DRIVES_DALLAS_ID, "drives_temp");
+	if (state->monitor == NULL)
+		return -ENODEV;
+
+	device_create_file(&of_dev->dev, &dev_attr_drives_temperature);
+	device_create_file(&of_dev->dev, &dev_attr_drives_fan_rpm);
+
+	return 0;
+}
+
+/*
+ * Dispose of the state data for the drives control loop
+ */
+static void dispose_drives_state(struct drives_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	device_remove_file(&of_dev->dev, &dev_attr_drives_temperature);
+	device_remove_file(&of_dev->dev, &dev_attr_drives_fan_rpm);
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+
+static int call_critical_overtemp(void)
+{
+	char *argv[] = { critical_overtemp_path, NULL };
+	static char *envp[] = { "HOME=/",
+				"TERM=linux",
+				"PATH=/sbin:/usr/sbin:/bin:/usr/bin",
+				NULL };
+
+	return call_usermodehelper(critical_overtemp_path, argv, envp, 0);
+}
+
+
+/*
+ * Here's the kernel thread that calls the various control loops
+ */
+static int main_control_loop(void *x)
+{
+	daemonize("kfand");
+
+	DBG("main_control_loop started\n");
+
+	/* Set the PCI fan once for now */
+	set_pwm_fan(SLOTS_FAN_PWM_ID, SLOTS_FAN_DEFAULT_PWM);
+
+	while (state == state_attached) {
+		unsigned long elapsed, start;
+
+		start = jiffies;
+
+		down(&driver_lock);
+		do_monitor_cpu(&cpu_state[0]);
+		if (cpu_state[1].monitor != NULL)
+			do_monitor_cpu(&cpu_state[1]);
+		do_monitor_backside(&backside_state);
+		do_monitor_drives(&drives_state);
+		up(&driver_lock);
+
+		if (critical_state == 1) {
+			printk(KERN_WARNING "Temperature control detected a critical condition\n");
+			printk(KERN_WARNING "Attempting to shut down...\n");
+			if (call_critical_overtemp()) {
+				printk(KERN_WARNING "Can't call %s, power off now!\n",
+				       critical_overtemp_path);
+				machine_power_off();
+			}
+		}
+		if (critical_state > 0)
+			critical_state++;
+		if (critical_state > MAX_CRITICAL_STATE) {
+			printk(KERN_WARNING "Shutdown timed out, power off now !\n");
+			machine_power_off();
+		}
+
+		// FIXME: Deal with signals
+		set_current_state(TASK_INTERRUPTIBLE);
+		elapsed = jiffies - start;
+		if (elapsed < HZ)
+			schedule_timeout(HZ - elapsed);
+	}
+
+	DBG("main_control_loop ended\n");
+
+	ctrl_task = 0;
+	complete_and_exit(&ctrl_complete, 0);
+}
+
+/*
+ * Dispose the control loops when tearing down
+ */
+static void dispose_control_loops(void)
+{
+	dispose_cpu_state(&cpu_state[0]);
+	dispose_cpu_state(&cpu_state[1]);
+
+	dispose_backside_state(&backside_state);
+	dispose_drives_state(&drives_state);
+}
+
+/*
+ * Create the control loops. U3-0 i2c bus is up, so we can now
+ * get to the various sensors
+ */
+static int create_control_loops(void)
+{
+	struct device_node *np;
+
+	/* Count CPUs from the device-tree, we don't care how many are
+	 * actually used by Linux
+	 */
+	cpu_count = 0;
+	for (np = NULL; NULL != (np = of_find_node_by_type(np, "cpu"));)
+		cpu_count++;
+
+	DBG("counted %d CPUs in the device-tree\n", cpu_count);
+
+	/* Create control loops for everything. If any fail, everything
+	 * fails
+	 */
+	if (init_cpu_state(&cpu_state[0], 0))
+		goto fail;
+	if (cpu_count > 1 && init_cpu_state(&cpu_state[1], 1))
+		goto fail;
+	if (init_backside_state(&backside_state))
+		goto fail;
+	if (init_drives_state(&drives_state))
+		goto fail;
+
+	DBG("all control loops up !\n");
+
+	return 0;
+	
+ fail:
+	DBG("failure creating control loops, disposing\n");
+
+	dispose_control_loops();
+
+	return -ENODEV;
+}
+
+/*
+ * Start the control loops after everything is up, that is create
+ * the thread that will make them run
+ */
+static void start_control_loops(void)
+{
+	init_completion(&ctrl_complete);
+
+	ctrl_task = kernel_thread(main_control_loop, NULL, SIGCHLD | CLONE_KERNEL);
+}
+
+/*
+ * Stop the control loops when tearing down
+ */
+static void stop_control_loops(void)
+{
+	if (ctrl_task != 0)
+		wait_for_completion(&ctrl_complete);
+}
+
+/*
+ * Attach to the i2c FCU after detecting U3-1 bus
+ */
+static int attach_fcu(void)
+{
+	fcu = attach_i2c_chip(FAN_CTRLER_ID, "fcu");
+	if (fcu == NULL)
+		return -ENODEV;
+
+	DBG("FCU attached\n");
+
+	return 0;
+}
+
+/*
+ * Detach from the i2c FCU when tearing down
+ */
+static void detach_fcu(void)
+{
+	if (fcu)
+		detach_i2c_chip(fcu);
+	fcu = NULL;
+}
+
+/*
+ * Attach to the i2c controller. We probe the various chips based
+ * on the device-tree nodes and build everything for the driver to
+ * run, we then kick the driver monitoring thread
+ */
+static int therm_pm72_attach(struct i2c_adapter *adapter)
+{
+	down(&driver_lock);
+
+	/* Check state */
+	if (state == state_detached)
+		state = state_attaching;
+	if (state != state_attaching) {
+		up(&driver_lock);
+		return 0;
+	}
+
+	/* Check if we are looking for one of these */
+	if (u3_0 == NULL && !strcmp(adapter->name, "u3 0")) {
+		u3_0 = adapter;
+		DBG("found U3-0, creating control loops\n");
+		if (create_control_loops())
+			u3_0 = NULL;
+	} else if (u3_1 == NULL && !strcmp(adapter->name, "u3 1")) {
+		u3_1 = adapter;
+		DBG("found U3-1, attaching FCU\n");
+		if (attach_fcu())
+			u3_1 = NULL;
+	}
+	/* We got all we need, start control loops */
+	if (u3_0 != NULL && u3_1 != NULL) {
+		DBG("everything up, starting control loops\n");
+		state = state_attached;
+		start_control_loops();
+	}
+	up(&driver_lock);
+
+	return 0;
+}
+
+/*
+ * Called on every adapter when the driver or the i2c controller
+ * is going away.
+ */
+static int therm_pm72_detach(struct i2c_adapter *adapter)
+{
+	down(&driver_lock);
+
+	if (state != state_detached)
+		state = state_detaching;
+
+	/* Stop control loops if any */
+	DBG("stopping control loops\n");
+	up(&driver_lock);
+	stop_control_loops();
+	down(&driver_lock);
+
+	if (u3_0 != NULL && !strcmp(adapter->name, "u3 0")) {
+		DBG("lost U3-0, disposing control loops\n");
+		dispose_control_loops();
+		u3_0 = NULL;
+	}
+	
+	if (u3_1 != NULL && !strcmp(adapter->name, "u3 1")) {
+		DBG("lost U3-1, detaching FCU\n");
+		detach_fcu();
+		u3_1 = NULL;
+	}
+	if (u3_0 == NULL && u3_1 == NULL)
+		state = state_detached;
+
+	up(&driver_lock);
+
+	return 0;
+}
+
+static int fcu_of_probe(struct of_device* dev, const struct of_match *match)
+{
+	int rc;
+
+	state = state_detached;
+
+	rc = i2c_add_driver(&therm_pm72_driver);
+	if (rc < 0)
+		return rc;
+	return 0;
+}
+
+static int fcu_of_remove(struct of_device* dev)
+{
+	i2c_del_driver(&therm_pm72_driver);
+
+	return 0;
+}
+
+static struct of_match fcu_of_match[] = 
+{
+	{
+	.name 		= OF_ANY_MATCH,
+	.type		= "fcu",
+	.compatible	= OF_ANY_MATCH
+	},
+	{},
+};
+
+static struct of_platform_driver fcu_of_platform_driver = 
+{
+	.name 		= "temperature",
+	.match_table	= fcu_of_match,
+	.probe		= fcu_of_probe,
+	.remove		= fcu_of_remove
+};
+
+/*
+ * Check machine type, attach to i2c controller
+ */
+static int __init therm_pm72_init(void)
+{
+	struct device_node *np;
+
+	if (!machine_is_compatible("PowerMac7,2"))
+	    	return -ENODEV;
+
+	printk(KERN_INFO "PowerMac G5 Thermal control driver %s\n", VERSION);
+
+	np = of_find_node_by_type(NULL, "fcu");
+	if (np == NULL) {
+		printk(KERN_ERR "Can't find FCU in device-tree !\n");
+		return -ENODEV;
+	}
+	of_dev = of_platform_device_create(np, "temperature");
+	if (of_dev == NULL) {
+		printk(KERN_ERR "Can't register FCU platform device !\n");
+		return -ENODEV;
+	}
+
+	of_register_driver(&fcu_of_platform_driver);
+	
+	return 0;
+}
+
+static void __exit therm_pm72_exit(void)
+{
+	of_unregister_driver(&fcu_of_platform_driver);
+
+	if (of_dev)
+		of_device_unregister(of_dev);
+}
+
+module_init(therm_pm72_init);
+module_exit(therm_pm72_exit);
+
+MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
+MODULE_DESCRIPTION("Driver for Apple's PowerMac7,2 G5 thermal control");
+MODULE_LICENSE("GPL");
+
diff -purN /dev/shm/linux-2.5/drivers/macintosh/therm_pm72.h linuxppc-2.5-benh/drivers/macintosh/therm_pm72.h
--- /dev/shm/linux-2.5/drivers/macintosh/therm_pm72.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/therm_pm72.h	2003-11-19 06:29:16.000000000 +0000
@@ -0,0 +1,236 @@
+#ifndef __THERM_PMAC_7_2_H__
+#define __THERM_PMAC_7_2_H__
+
+typedef unsigned short fu16;
+typedef int fs32;
+typedef short fs16;
+
+struct mpu_data
+{
+	u8	signature;		/* 0x00 - EEPROM sig. */
+	u8	bytes_used;		/* 0x01 - Bytes used in eeprom (160 ?) */
+	u8	size;			/* 0x02 - EEPROM size (256 ?) */
+	u8	version;		/* 0x03 - EEPROM version */
+	u32	data_revision;		/* 0x04 - Dataset revision */
+	u8	processor_bin_code[3];	/* 0x08 - Processor BIN code */
+	u8	bin_code_expansion;	/* 0x0b - ??? (padding ?) */
+	u8	processor_num;		/* 0x0c - Number of CPUs on this MPU */
+	u8	input_mul_bus_div;	/* 0x0d - Clock input multiplier/bus divider */
+	u8	reserved1[2];		/* 0x0e - */
+	u32	input_clk_freq_high;	/* 0x10 - Input clock frequency high */
+	u8	cpu_nb_target_cycles;	/* 0x14 - ??? */
+	u8	cpu_statlat;		/* 0x15 - ??? */
+	u8	cpu_snooplat;		/* 0x16 - ??? */
+	u8	cpu_snoopacc;		/* 0x17 - ??? */
+	u8	nb_paamwin;		/* 0x18 - ??? */
+	u8	nb_statlat;		/* 0x19 - ??? */
+	u8	nb_snooplat;		/* 0x1a - ??? */
+	u8	nb_snoopwin;		/* 0x1b - ??? */
+	u8	api_bus_mode;		/* 0x1c - ??? */
+	u8	reserved2[3];		/* 0x1d - */
+	u32	input_clk_freq_low;	/* 0x20 - Input clock frequency low */
+	u8	processor_card_slot;	/* 0x24 - Processor card slot number */
+	u8	reserved3[2];		/* 0x25 - */
+	u8	padjmax;       		/* 0x27 - Max power adjustment (Not in OF!) */
+	u8	ttarget;		/* 0x28 - Target temperature */
+	u8	tmax;			/* 0x29 - Max temperature */
+	u8	pmaxh;			/* 0x2a - Max power */
+	u8	tguardband;		/* 0x2b - Guardband temp ??? Hist. len in OSX */
+	fs32	pid_gp;			/* 0x2c - PID proportional gain */
+	fs32	pid_gr;			/* 0x30 - PID reset gain */
+	fs32	pid_gd;			/* 0x34 - PID derivative gain */
+	fu16	voph;			/* 0x38 - Vop High */
+	fu16	vopl;			/* 0x3a - Vop Low */
+	fs16	nactual_die;		/* 0x3c - nActual Die */
+	fs16	nactual_heatsink;	/* 0x3e - nActual Heatsink */
+	fs16	nactual_system;		/* 0x40 - nActual System */
+	u16	calibration_flags;	/* 0x42 - Calibration flags */
+	fu16	mdiode;			/* 0x44 - Diode M value (scaling factor) */
+	fs16	bdiode;			/* 0x46 - Diode B value (offset) */
+	fs32	theta_heat_sink;	/* 0x48 - Theta heat sink */
+	u16	rminn_intake_fan;	/* 0x4c - Intake fan min RPM */
+	u16	rmaxn_intake_fan;	/* 0x4e - Intake fan max RPM */
+	u16	rminn_exhaust_fan;	/* 0x50 - Exhaust fan min RPM */
+	u16	rmaxn_exhaust_fan;	/* 0x52 - Exhaust fan max RPM */
+	u8	processor_part_num[8];	/* 0x54 - Processor part number */
+	u32	processor_lot_num;	/* 0x5c - Processor lot number */
+	u8	orig_card_sernum[0x10];	/* 0x60 - Card original serial number */
+	u8	curr_card_sernum[0x10];	/* 0x70 - Card current serial number */
+	u8	mlb_sernum[0x18];	/* 0x80 - MLB serial number */
+	u32	checksum1;		/* 0x98 - */
+	u32	checksum2;		/* 0x9c - */	
+}; /* Total size = 0xa0 */
+
+/* Display a 16.16 fixed point value */
+#define FIX32TOPRINT(f)	((f) >> 16),((((f) & 0xffff) * 1000) >> 16)
+
+/*
+ * Maximum number of seconds to be in critical state (after a
+ * normal shutdown attempt). If the machine isn't down after
+ * this counter elapses, we force an immediate machine power
+ * off.
+ */
+#define MAX_CRITICAL_STATE			30
+static char * critical_overtemp_path = "/sbin/critical_overtemp";
+
+/*
+ * This option is "weird" :) Basically, if you define this to 1
+ * the control loop for the RPMs fans (not PWMs) will apply the
+ * correction factor obtained from the PID to the _actual_ RPM
+ * speed read from the FCU.
+ * If you define the below constant to 0, then it will be
+ * applied to the setpoint RPM speed, that is basically the
+ * speed we proviously "asked" for.
+ *
+ * I'm not sure which of these Apple's algorithm is supposed
+ * to use
+ */
+#define RPM_PID_USE_ACTUAL_SPEED		1
+
+/*
+ * i2c IDs. Currently, we hard code those and assume that
+ * the FCU is on U3 bus 1 while all sensors are on U3 bus
+ * 0. This appear to be safe enough for this first version
+ * of the driver, though I would accept any clean patch
+ * doing a better use of the device-tree without turning the
+ * while i2c registration mecanism into a racy mess
+ */
+#define FAN_CTRLER_ID		0x15e
+#define SUPPLY_MONITOR_ID      	0x58
+#define SUPPLY_MONITORB_ID     	0x5a
+#define DRIVES_DALLAS_ID	0x94
+#define BACKSIDE_MAX_ID		0x98
+
+/*
+ * Some MAX6690 & DS1775 register definitions
+ */
+#define MAX6690_INT_TEMP	0
+#define MAX6690_EXT_TEMP	1
+#define DS1775_TEMP		0
+
+/*
+ * Scaling factors for the AD7417 ADC converters (except
+ * for the CPU diode which is obtained from the EEPROM).
+ * Those values are obtained from the property list of
+ * the darwin driver
+ */
+#define ADC_12V_CURRENT_SCALE	0x0320	/* _AD2 */
+#define ADC_CPU_VOLTAGE_SCALE	0x00a0	/* _AD3 */
+#define ADC_CPU_CURRENT_SCALE	0x1f40	/* _AD4 */
+
+/*
+ * PID factors for the U3/Backside fan control loop
+ */
+#define BACKSIDE_FAN_PWM_ID		1
+#define BACKSIDE_PID_G_d		0x02800000
+#define BACKSIDE_PID_G_p		0x00500000
+#define BACKSIDE_PID_G_r		0x00000000
+#define BACKSIDE_PID_INPUT_TARGET	0x00410000
+#define BACKSIDE_PID_INTERVAL		5
+#define BACKSIDE_PID_OUTPUT_MAX		100
+#define BACKSIDE_PID_OUTPUT_MIN		20
+#define BACKSIDE_PID_HISTORY_SIZE	2
+
+struct backside_pid_state
+{
+	int			ticks;
+	struct i2c_client *	monitor;
+	s32		       	sample_history[BACKSIDE_PID_HISTORY_SIZE];
+	s32			error_history[BACKSIDE_PID_HISTORY_SIZE];
+	int			cur_sample;
+	s32			last_temp;
+	int			pwm;
+	int			first;
+};
+
+/*
+ * PID factors for the Drive Bay fan control loop
+ */
+#define DRIVES_FAN_RPM_ID      		2
+#define DRIVES_PID_G_d			0x01e00000
+#define DRIVES_PID_G_p			0x00500000
+#define DRIVES_PID_G_r			0x00000000
+#define DRIVES_PID_INPUT_TARGET		0x00280000
+#define DRIVES_PID_INTERVAL    		5
+#define DRIVES_PID_OUTPUT_MAX		4000
+#define DRIVES_PID_OUTPUT_MIN		300
+#define DRIVES_PID_HISTORY_SIZE		2
+
+struct drives_pid_state
+{
+	int			ticks;
+	struct i2c_client *	monitor;
+	s32	       		sample_history[BACKSIDE_PID_HISTORY_SIZE];
+	s32			error_history[BACKSIDE_PID_HISTORY_SIZE];
+	int			cur_sample;
+	s32			last_temp;
+	int			rpm;
+	int			first;
+};
+
+#define SLOTS_FAN_PWM_ID       		2
+#define	SLOTS_FAN_DEFAULT_PWM		50 /* Do better here ! */
+
+/*
+ * IDs in Darwin for the sensors & fans
+ *
+ * CPU A AD7417_TEMP	10	(CPU A ambient temperature)
+ * CPU A AD7417_AD1	11	(CPU A diode temperature)
+ * CPU A AD7417_AD2	12	(CPU A 12V current)
+ * CPU A AD7417_AD3	13	(CPU A voltage)
+ * CPU A AD7417_AD4	14	(CPU A current)
+ *
+ * CPU A FAKE POWER	48	(I_V_inputs: 13, 14)
+ *
+ * CPU B AD7417_TEMP	15	(CPU B ambient temperature)
+ * CPU B AD7417_AD1	16	(CPU B diode temperature)
+ * CPU B AD7417_AD2	17	(CPU B 12V current)
+ * CPU B AD7417_AD3	18	(CPU B voltage)
+ * CPU B AD7417_AD4	19	(CPU B current)
+ *
+ * CPU B FAKE POWER	49	(I_V_inputs: 18, 19)
+ */
+
+#define CPUA_INTAKE_FAN_RPM_ID		3
+#define CPUA_EXHAUST_FAN_RPM_ID		4
+#define CPUB_INTAKE_FAN_RPM_ID		5
+#define CPUB_EXHAUST_FAN_RPM_ID		6
+
+#define CPU_INTAKE_SCALE		0x0000f852
+#define CPU_TEMP_HISTORY_SIZE		2
+#define CPU_POWER_HISTORY_SIZE		10
+#define CPU_PID_INTERVAL		1
+#define CPU_MAX_OVERTEMP		30
+
+struct cpu_pid_state
+{
+	int			index;
+	struct i2c_client *	monitor;
+	struct mpu_data		mpu;
+	int			overtemp;
+	s32	       		temp_history[CPU_TEMP_HISTORY_SIZE];
+	int			cur_temp;
+	s32			power_history[CPU_POWER_HISTORY_SIZE];
+	s32			error_history[CPU_POWER_HISTORY_SIZE];
+	int			cur_power;
+	int			count_power;
+	int			rpm;
+	int			intake_rpm;
+	s32			voltage;
+	s32			current_a;
+	s32			last_temp;
+	int			first;
+};
+
+/*
+ * Driver state
+ */
+enum {
+	state_detached,
+	state_attaching,
+	state_attached,
+	state_detaching,
+};
+
+
+#endif /* __THERM_PMAC_7_2_H__ */
diff -purN /dev/shm/linux-2.5/drivers/macintosh/therm_windtunnel.c linuxppc-2.5-benh/drivers/macintosh/therm_windtunnel.c
--- /dev/shm/linux-2.5/drivers/macintosh/therm_windtunnel.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/therm_windtunnel.c	2004-01-04 00:19:24.000000000 +0000
@@ -0,0 +1,456 @@
+/* 
+ *   Creation Date: <2003/03/14 20:54:13 samuel>
+ *   Time-stamp: <2003/03/15 18:55:53 samuel>
+ *   
+ *	<therm_windtunnel.c>
+ *	
+ *	The G4 "windtunnel" has a single fan controlled by a
+ *	DS1775 fan controller and an ADM1030 thermostat.
+ *
+ *	The fan controller is equipped with a temperature sensor
+ *	which measures the case temperature. The ADM censor
+ *	measures the CPU temperature. This driver tunes the
+ *	behavior of the fan. It is based upon empirical observations
+ *	of the 'AppleFan' driver under OSX.
+ *
+ *	WARNING: This driver has only been testen on Apple's
+ *	1.25 MHz Dual G4 (March 03). Other machines might have
+ *	a different thermal design. It is tuned for a CPU
+ *	temperatur around 57 C.
+ *
+ *   Copyright (C) 2003 Samuel Rydh (samuel@ibrium.se)
+ *
+ *   Loosely based upon 'thermostat.c' written by Benjamin Herrenschmidt
+ *   
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation
+ *   
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+
+MODULE_AUTHOR("Samuel Rydh <samuel@ibrium.se>");
+MODULE_DESCRIPTION("Apple G4 (windtunnel) fan driver");
+MODULE_LICENSE("GPL");
+
+#define LOG_TEMP		0			/* continously log temperature */
+
+/* scan 0x48-0x4f (DS1775) and 0x2c-2x2f (ADM1030) */
+static unsigned short normal_i2c[] = { 0x49, 0x2c, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { 0x48, 0x4f, 0x2c, 0x2f, I2C_CLIENT_END };
+static struct work_struct poll_work;
+
+I2C_CLIENT_INSMOD;
+
+#define I2C_DRIVERID_G4FAN	0x9001			/* fixme */
+
+#define THERMOSTAT_CLIENT_ID	1
+#define FAN_CLIENT_ID		2
+
+struct temp_range {
+	u8			high;			/* start the fan */
+	u8			low;			/* stop the fan */
+};
+struct apple_thermal_info {
+	u8			id;			/* implementation ID */
+	u8			fan_count;		/* number of fans */
+	u8			thermostat_count;	/* number of thermostats */
+	u8			unused[5];
+	struct temp_range	ranges[4];		/* temperature ranges (may be [])*/
+};
+
+static int do_detect( struct i2c_adapter *adapter, int addr, int kind);
+
+static struct {
+	struct i2c_client	*thermostat;
+	struct i2c_client	*fan;
+	int			error;
+	struct timer_list	timer;
+
+	int			overheat_temp;		/* 100% fan at this temp */
+	int			overheat_hyst;
+	int			temp;
+	int			casetemp;
+	int			fan_level;		/* active fan_table setting */
+
+	int			downind;
+	int			upind;
+
+	int			r0, r1, r20, r23, r25;	/* saved register */
+} x;
+
+static struct {
+	int			temp;
+	int			fan_setting;
+} fan_up_table[] = {
+	{ 0x0000, 11 },		/* min fan */
+	{ 0x3900, 8 },		/* 57.0 C */
+	{ 0x3a4a, 7 },		/* 58.3 C */
+	{ 0x3ad3, 6 },		/* 58.8 C */
+	{ 0x3b3c, 5 },		/* 59.2 C */
+	{ 0x3b94, 4 },		/* 59.6 C */
+	{ 0x3be3, 3 },		/* 58.9 C */
+	{ 0x3c29, 2 },		/* 59.2 C */
+	{ 0xffff, 1 }		/* on fire */
+};
+static struct {
+	int			temp;
+	int			fan_setting;
+} fan_down_table[] = {
+	{ 0x3700, 11 },		/* 55.0 C */
+	{ 0x374a, 6 },
+	{ 0x3800, 7 },		/* 56.0 C */
+	{ 0x3900, 8 },		/* 57.0 C */
+	{ 0x3a4a, 7 },		/* 58.3 C */
+	{ 0x3ad3, 6 },		/* 58.8 C */
+	{ 0x3b3c, 5 },		/* 59.2 C */
+	{ 0x3b94, 4 },		/* 58.9 C */
+	{ 0x3be3, 3 },		/* 58.9 C */
+	{ 0x3c29, 2 },		/* 59.2 C */
+	{ 0xffff, 1 }
+};
+
+static int
+write_reg( struct i2c_client *cl, int reg, int data, int len )
+{
+	u8 tmp[3];
+
+	if( len < 1 || len > 2 || data < 0 )
+		return -EINVAL;
+
+	tmp[0] = reg;
+	tmp[1] = (len == 1) ? data : (data >> 8);
+	tmp[2] = data;
+	len++;
+	
+	if( i2c_master_send(cl, tmp, len) != len )
+		return -ENODEV;
+	return 0;
+}
+
+static int
+read_reg( struct i2c_client *cl, int reg, int len )
+{
+	u8 buf[2];
+
+	if( len != 1 && len != 2 )
+		return -EINVAL;
+	buf[0] = reg;
+	if( i2c_master_send(cl, buf, 1) != 1 )
+		return -ENODEV;
+	if( i2c_master_recv(cl, buf, len) != len )
+		return -ENODEV;
+	return (len == 2)? ((unsigned int)buf[0] << 8) | buf[1] : buf[0];
+}
+
+
+static void
+print_temp( const char *s, int temp )
+{
+	printk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );
+}
+
+static void
+tune_fan( int fan_setting )
+{
+	int val = (fan_setting << 3) | 7;
+	x.fan_level = fan_setting;
+	
+	//write_reg( x.fan, 0x24, val, 1 );
+	write_reg( x.fan, 0x25, val, 1 );
+	write_reg( x.fan, 0x20, 0, 1 );
+	print_temp("CPU-temp: ", x.temp );
+	if( x.casetemp )
+		print_temp(", Case: ", x.casetemp );
+	printk("  Tuning fan: %d (%02x)\n", fan_setting, val );
+}
+
+static void
+poll_temp( void *param )
+{
+	int temp = read_reg( x.thermostat, 0, 2 );
+	int i, level, casetemp;
+
+	/* this actually occurs when the computer is loaded */
+	if( temp < 0 )
+		goto out;
+
+	casetemp = read_reg(x.fan, 0x0b, 1) << 8;
+	casetemp |= (read_reg(x.fan, 0x06, 1) & 0x7) << 5;
+
+	if( LOG_TEMP && x.temp != temp ) {
+		print_temp("CPU-temp: ", temp );
+		print_temp(", Case: ", casetemp );
+		printk(",  Fan: %d\n", x.fan_level );
+	}
+	x.temp = temp;
+	x.casetemp = casetemp;
+
+	level = -1;
+	for( i=0; (temp & 0xffff) > fan_down_table[i].temp ; i++ )
+		;
+	if( i < x.downind )
+		level = fan_down_table[i].fan_setting;
+	x.downind = i;
+
+	for( i=0; (temp & 0xfffe) >= fan_up_table[i+1].temp ; i++ )
+		;
+	if( x.upind < i )
+		level = fan_up_table[i].fan_setting;
+	x.upind = i;
+
+	if( level >= 0 )
+		tune_fan( level );
+ out:
+	x.timer.expires = jiffies + 8*HZ;
+	add_timer( &x.timer );
+}
+
+static void
+schedule_poll( unsigned long t )
+{
+	schedule_work(&poll_work);
+}
+
+/************************************************************************/
+/*	i2c probing and setup						*/
+/************************************************************************/
+
+static int
+do_attach( struct i2c_adapter *adapter )
+{
+	return i2c_probe( adapter, &addr_data, &do_detect );
+}
+
+static int
+do_detach( struct i2c_client *client )
+{
+	int err;
+
+	printk("do_detach: id %d\n", client->id );
+	if( (err=i2c_detach_client(client)) ) {
+		printk("failed to detach thermostat client\n");
+		return err;
+	}
+	kfree( client );
+	return 0;
+}
+
+static struct i2c_driver g4fan_driver = {  
+	.name		= "Apple G4 Thermostat/Fan",
+	.id		= I2C_DRIVERID_G4FAN,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter = &do_attach,
+	.detach_client	= &do_detach,
+	.command	= NULL,
+};
+
+static int
+detect_fan( struct i2c_client *cl )
+{
+	/* check that this is an ADM1030 */
+	if( read_reg(cl, 0x3d, 1) != 0x30 || read_reg(cl, 0x3e, 1) != 0x41 )
+		goto out;
+	printk("ADM1030 fan controller detected at %02x\n", cl->addr );
+
+	if( x.fan ) {
+		x.error |= 2;
+		goto out;
+	}
+	x.fan = cl;
+	cl->id = FAN_CLIENT_ID;
+	strncpy( cl->name, "ADM1030 fan controller", sizeof(cl->name) );
+
+	if( i2c_attach_client( cl ) )
+		goto out;
+	return 0;
+ out:
+	if( cl != x.fan )
+		kfree( cl );
+	return 0;
+}
+
+static int
+detect_thermostat( struct i2c_client *cl ) 
+{
+	int hyst_temp, os_temp, temp;
+
+	if( (temp=read_reg(cl, 0, 2)) < 0 )
+		goto out;
+	
+	/* temperature sanity check */
+	if( temp < 0x1600 || temp > 0x3c00 )
+		goto out;
+	hyst_temp = read_reg(cl, 2, 2);
+	os_temp = read_reg(cl, 3, 2);
+	if( hyst_temp < 0 || os_temp < 0 )
+		goto out;
+
+	printk("DS1775 digital thermometer detected at %02x\n", cl->addr );
+	print_temp("Temp: ", temp );
+	print_temp("  Hyst: ", hyst_temp );
+	print_temp("  OS: ", os_temp );
+	printk("\n");
+
+	if( x.thermostat ) {
+		x.error |= 1;
+		goto out;
+	}
+	x.temp = temp;
+	x.thermostat = cl;
+	x.overheat_temp = os_temp;
+	x.overheat_hyst = hyst_temp;
+	
+	cl->id = THERMOSTAT_CLIENT_ID;
+	strncpy( cl->name, "DS1775 thermostat", sizeof(cl->name) );
+
+	if( i2c_attach_client( cl ) )
+		goto out;
+	return 0;
+out:
+	kfree( cl );
+	return 0;
+}
+
+static int
+do_detect( struct i2c_adapter *adapter, int addr, int kind )
+{
+	struct i2c_client *cl;
+
+	if( strncmp(adapter->name, "uni-n", 5) )
+		return 0;
+	if( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA
+				     | I2C_FUNC_SMBUS_WRITE_BYTE) )
+		return 0;
+
+	if( !(cl=kmalloc( sizeof(struct i2c_client), GFP_KERNEL )) )
+		return -ENOMEM;
+	memset( cl, 0, sizeof(struct i2c_client) );
+
+	cl->addr = addr;
+	cl->adapter = adapter;
+	cl->driver = &g4fan_driver;
+	cl->flags = 0;
+
+	if( addr < 0x48 )
+		return detect_fan( cl );
+	return detect_thermostat( cl );
+}
+
+#define PRINT_REG( r )	printk("reg %02x = %02x\n", r, read_reg(x.fan, r, 1) )
+
+static int __init
+g4fan_init( void )
+{
+	struct apple_thermal_info *info;
+	struct device_node *np;
+	int ret, val;
+	
+	np = of_find_node_by_name(NULL, "power-mgt");
+	if (np == NULL)
+		return -ENODEV;
+	info = (struct apple_thermal_info*)get_property(np, "thermal-info", NULL);
+	of_node_put(np);
+	if (info == NULL)
+		return -ENODEV;
+	
+	/* check for G4 "Windtunnel" SMP */
+	if( machine_is_compatible("PowerMac3,6") ) {
+		if( info->id != 3 ) {
+			printk(KERN_ERR "g4fan: design id %d unknown\n", info->id);
+			return -ENODEV;
+		}
+	} else {
+		printk(KERN_ERR "g4fan: unsupported machine type\n");
+		return -ENODEV;
+	}
+	if( (ret=i2c_add_driver(&g4fan_driver)) )
+		return ret;
+
+	if( !x.thermostat || !x.fan ) {
+		i2c_del_driver(&g4fan_driver );
+		return -ENODEV;
+	}
+
+	/* save registers (if we unload the module) */
+	x.r0 = read_reg( x.fan, 0x00, 1 );
+	x.r1 = read_reg( x.fan, 0x01, 1 );
+	x.r20 = read_reg( x.fan, 0x20, 1 );
+	x.r23 = read_reg( x.fan, 0x23, 1 );
+	x.r25 = read_reg( x.fan, 0x25, 1 );
+
+	/* improve measurement resolution (convergence time 1.5s) */
+	if( (val=read_reg( x.thermostat, 1, 1 )) >= 0 ) {
+		val |= 0x60;
+		if( write_reg( x.thermostat, 1, val, 1 ) )
+			printk("Failed writing config register\n");
+	}
+	/* disable interrupts and TAC input */
+	write_reg( x.fan, 0x01, 0x01, 1 );
+	/* enable filter */
+	write_reg( x.fan, 0x23, 0x91, 1 );
+	/* remote temp. controls fan */
+	write_reg( x.fan, 0x00, 0x95, 1 );
+
+	/* The thermostat (which besides measureing temperature controls
+	 * has a THERM output which puts the fan on 100%) is usually
+	 * set to kick in at 80 C (chip default). We reduce this a bit
+	 * to be on the safe side (OSX doesn't)...
+	 */
+	if( x.overheat_temp == (80 << 8) ) {
+		x.overheat_temp = 65 << 8;
+		x.overheat_hyst = 60 << 8;
+		write_reg( x.thermostat, 2, x.overheat_hyst, 2 );
+		write_reg( x.thermostat, 3, x.overheat_temp, 2 );
+
+		print_temp("Reducing overheating limit to ", x.overheat_temp );
+		print_temp(" (Hyst: ", x.overheat_hyst );
+		printk(")\n");
+	}
+
+	/* set an initial fan setting */
+	x.upind = x.downind = 1;
+	tune_fan( fan_up_table[x.upind].fan_setting );
+
+	INIT_WORK(&poll_work, poll_temp, NULL);
+
+	init_timer( &x.timer );
+	x.timer.expires = jiffies + 8*HZ;
+	x.timer.function = schedule_poll;
+	add_timer( &x.timer );
+	return 0;
+}
+
+static void __exit
+g4fan_exit( void )
+{
+	del_timer( &x.timer );
+
+	write_reg( x.fan, 0x01, x.r1, 1 );
+	write_reg( x.fan, 0x20, x.r20, 1 );
+	write_reg( x.fan, 0x23, x.r23, 1 );
+	write_reg( x.fan, 0x25, x.r25, 1 );
+	write_reg( x.fan, 0x00, x.r0, 1 );
+
+	i2c_del_driver( &g4fan_driver );
+}
+
+module_init(g4fan_init);
+module_exit(g4fan_exit);
+
diff -purN /dev/shm/linux-2.5/drivers/macintosh/via-pmu.c linuxppc-2.5-benh/drivers/macintosh/via-pmu.c
--- /dev/shm/linux-2.5/drivers/macintosh/via-pmu.c	2004-02-04 05:32:35.000000000 +0000
+++ linuxppc-2.5-benh/drivers/macintosh/via-pmu.c	2004-02-05 10:07:34.000000000 +0000
@@ -168,6 +168,7 @@ static struct proc_dir_entry *proc_pmu_r
 static struct proc_dir_entry *proc_pmu_info;
 static struct proc_dir_entry *proc_pmu_irqstats;
 static struct proc_dir_entry *proc_pmu_options;
+static int option_server_mode;
 
 #ifdef CONFIG_PMAC_PBOOK
 int pmu_battery_count;
@@ -334,7 +335,8 @@ find_via_pmu(void)
 		pmu_kind = PMU_PADDINGTON_BASED;
 	else if (device_is_compatible(vias->parent, "heathrow"))
 		pmu_kind = PMU_HEATHROW_BASED;
-	else if (device_is_compatible(vias->parent, "Keylargo")) {
+	else if (device_is_compatible(vias->parent, "Keylargo")
+		 || device_is_compatible(vias->parent, "K2-Keylargo")) {
 		struct device_node *gpio, *gpiop;
 
 		pmu_kind = PMU_KEYLARGO_BASED;
@@ -349,6 +351,8 @@ find_via_pmu(void)
 		if (gpiop && gpiop->n_addrs) {
 			gpio_reg = ioremap(gpiop->addrs->address, 0x10);
 			gpio = find_devices("extint-gpio1");
+			if (gpio == NULL)
+				gpio = find_devices("pmu-interrupt");
 			if (gpio && gpio->parent == gpiop && gpio->n_intrs)
 				gpio_irq = gpio->intrs[0].line;
 		}
@@ -370,8 +374,9 @@ find_via_pmu(void)
 	printk(KERN_INFO "PMU driver %d initialized for %s, firmware: %02x\n",
 	       PMU_DRIVER_VERSION, pbook_type[pmu_kind], pmu_version);
 	       
+#ifndef CONFIG_PPC64
 	sys_ctrler = SYS_CTRLER_PMU;
-	
+#endif
 	return 1;
 }
 
@@ -455,7 +460,9 @@ static int __init via_pmu_dev_init(void)
 	if (vias == NULL)
 		return -ENODEV;
 
+#ifndef CONFIG_PPC64
 	request_OF_resource(vias, 0, NULL);
+#endif
 #ifdef CONFIG_PMAC_BACKLIGHT
 	/* Enable backlight */
 	register_backlight_controller(&pmu_backlight_controller, NULL, "pmu");
@@ -564,7 +571,19 @@ init_pmu(void)
 	pmu_wait_complete(&req);
 	if (req.reply_len > 0)
 		pmu_version = req.reply[0];
-
+	
+	/* Read server mode setting */
+	if (pmu_kind == PMU_KEYLARGO_BASED) {
+		pmu_request(&req, NULL, 2, PMU_POWER_EVENTS,
+			    PMU_PWR_GET_POWERUP_EVENTS);
+		pmu_wait_complete(&req);
+		if (req.reply_len == 2) {
+			if (req.reply[1] & PMU_PWR_WAKEUP_AC_INSERT)
+				option_server_mode = 1;
+			printk(KERN_INFO "via-pmu: Server Mode is %s\n",
+			       option_server_mode ? "enabled" : "disabled");
+		}
+	}
 	return 1;
 }
 
@@ -574,6 +593,7 @@ pmu_get_model(void)
 	return pmu_kind;
 }
 
+#ifndef CONFIG_PPC64
 static inline void wakeup_decrementer(void)
 {
 	set_dec(tb_ticks_per_jiffy);
@@ -582,7 +602,29 @@ static inline void wakeup_decrementer(vo
 	 */
 	last_jiffy_stamp(0) = tb_last_stamp = get_tbl();
 }
+#endif
+static void pmu_set_server_mode(int server_mode)
+{
+	struct adb_request req;
 
+	if (pmu_kind != PMU_KEYLARGO_BASED)
+		return;
+
+	option_server_mode = server_mode;
+	pmu_request(&req, NULL, 2, PMU_POWER_EVENTS, PMU_PWR_GET_POWERUP_EVENTS);
+	pmu_wait_complete(&req);
+	if (req.reply_len < 2)
+		return;
+	if (server_mode)
+		pmu_request(&req, NULL, 4, PMU_POWER_EVENTS,
+			    PMU_PWR_SET_POWERUP_EVENTS,
+			    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); 
+	else
+		pmu_request(&req, NULL, 4, PMU_POWER_EVENTS,
+			    PMU_PWR_CLR_POWERUP_EVENTS,
+			    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); 
+	pmu_wait_complete(&req);
+}
 
 #ifdef CONFIG_PMAC_PBOOK
 
@@ -845,6 +887,8 @@ proc_read_options(char *page, char **sta
 	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep)
 		p += sprintf(p, "lid_wakeup=%d\n", option_lid_wakeup);
 #endif /* CONFIG_PMAC_PBOOK */
+	if (pmu_kind == PMU_KEYLARGO_BASED)
+		p += sprintf(p, "server_mode=%d\n", option_server_mode);
 
 	return p - page;
 }
@@ -884,6 +928,12 @@ proc_write_options(struct file *file, co
 		if (!strcmp(label, "lid_wakeup"))
 			option_lid_wakeup = ((*val) == '1');
 #endif /* CONFIG_PMAC_PBOOK */
+	if (pmu_kind == PMU_KEYLARGO_BASED && !strcmp(label, "server_mode")) {
+		int new_value;
+		new_value = ((*val) == '1');
+		if (new_value != option_server_mode)
+			pmu_set_server_mode(new_value);
+	}
 	return fcount;
 }
 
@@ -1758,6 +1808,11 @@ pmu_shutdown(void)
 		pmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |
 						PMU_INT_TICK );
 		pmu_wait_complete(&req);
+	} else {
+		/* Disable server mode on shutdown or we'll just
+		 * wake up again
+		 */
+		pmu_set_server_mode(0);
 	}
 
 	pmu_request(&req, NULL, 5, PMU_SHUTDOWN,
@@ -2496,6 +2551,7 @@ powerbook_sleep_grackle(void)
 	return 0;
 }
 
+
 static int __pmac
 powerbook_sleep_Core99(void)
 {
diff -purN /dev/shm/linux-2.5/drivers/media/video/planb.c linuxppc-2.5-benh/drivers/media/video/planb.c
--- /dev/shm/linux-2.5/drivers/media/video/planb.c	2003-09-30 00:22:14.000000000 +0000
+++ linuxppc-2.5-benh/drivers/media/video/planb.c	2003-10-14 07:28:06.000000000 +0000
@@ -422,6 +422,16 @@ static void planb_prepare_close(struct p
 /* overlay support functions */
 /*****************************/
 
+static inline int overlay_is_active(struct planb *pb)
+{
+	unsigned int size = pb->tab_size * sizeof(struct dbdma_cmd);
+	unsigned int caddr = (unsigned)in_le32(&pb->planb_base->ch1.cmdptr);
+
+	return (in_le32(&pb->overlay_last1->cmd_dep) == pb->ch1_cmd_phys)
+			&& (caddr < (pb->ch1_cmd_phys + size))
+			&& (caddr >= (unsigned)pb->ch1_cmd_phys);
+}
+
 static void overlay_start(struct planb *pb)
 {
 
@@ -853,16 +863,6 @@ static int palette2fmt[] = {
 
 #define PLANB_PALETTE_MAX 15
 
-static inline int overlay_is_active(struct planb *pb)
-{
-	unsigned int size = pb->tab_size * sizeof(struct dbdma_cmd);
-	unsigned int caddr = (unsigned)in_le32(&pb->planb_base->ch1.cmdptr);
-
-	return (in_le32(&pb->overlay_last1->cmd_dep) == pb->ch1_cmd_phys)
-			&& (caddr < (pb->ch1_cmd_phys + size))
-			&& (caddr >= (unsigned)pb->ch1_cmd_phys);
-}
-
 static int vgrab(struct planb *pb, struct video_mmap *mp)
 {
 	unsigned int fr = mp->frame;
diff -purN /dev/shm/linux-2.5/drivers/misc/ChanageLog.misc linuxppc-2.5-benh/drivers/misc/ChanageLog.misc
--- /dev/shm/linux-2.5/drivers/misc/ChanageLog.misc	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/misc/ChanageLog.misc	2002-09-05 21:46:12.000000000 +0000
@@ -0,0 +1,5 @@
+Thu,  5 Sep 12:22:47 2002  Armin Kuster <akuster@mvista.com>
+	
+	* fixed compiler error in line 308.  missed indirection in parm 
+ 
+
diff -purN /dev/shm/linux-2.5/drivers/misc/Makefile linuxppc-2.5-benh/drivers/misc/Makefile
--- /dev/shm/linux-2.5/drivers/misc/Makefile	2002-12-14 12:38:56.000000000 +0000
+++ linuxppc-2.5-benh/drivers/misc/Makefile	2003-05-14 09:01:16.000000000 +0000
@@ -1,4 +1,7 @@
 #
 # Makefile for misc devices that really don't fit anywhere else.
 #
+
+obj-$(CONFIG_IBM_OCP_GPIO) += ibm_ocp_gpio.o
+
 obj- := misc.o	# Dummy rule to force built-in.o to be made
diff -purN /dev/shm/linux-2.5/drivers/misc/ibm_ocp_gpio.c linuxppc-2.5-benh/drivers/misc/ibm_ocp_gpio.c
--- /dev/shm/linux-2.5/drivers/misc/ibm_ocp_gpio.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/misc/ibm_ocp_gpio.c	2003-06-06 20:09:22.000000000 +0000
@@ -0,0 +1,296 @@
+/*
+ * FILE NAME ibm_ocp_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  API for IBM PowerPC 4xx GPIO device.
+ *  Driver for IBM PowerPC 4xx GPIO device.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *          Debbie Chu   <debbie_chu@mvista.com>
+ *
+ * Copyright 2000,2001,2002 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define VUFX "09.06.02"
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/pm.h>
+#include <asm/ibm_ocp_gpio.h>
+#include <asm/ocp.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+
+
+typedef struct gpio_regs {
+	u32 or;
+	u32 tcr;
+	u32 pad[4];
+	u32 odr;
+	u32 ir;
+} gpio_t;
+
+static struct gpio_regs *gpiop;
+
+int
+ocp_gpio_config(__u32 device, __u32 mask, __u32 data)
+{
+	u32 cfg_reg;
+
+	if (device != 0)
+		return -ENXIO;
+
+#ifdef CONFIG_40x
+	/*
+	 * PPC405 uses CPC0_CR0 to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CHCR0);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CHCR0, cfg_reg);
+#elif CONFIG_44x
+	/*
+	 * PPC440 uses CPC0_GPIO to select multiplexed GPIO pins.
+	 */
+	cfg_reg = mfdcr(DCRN_CPC0_GPIO);
+	cfg_reg = (cfg_reg & ~mask) | (data & mask);
+	mtdcr(DCRN_CPC0_GPIO, cfg_reg);
+#else
+#error This driver is only supported on PPC40x and PPC440 CPUs
+#endif
+
+	return 0;
+}
+
+int
+ocp_gpio_tristate(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->tcr = (gpiop->tcr & ~mask) | (data & mask);
+	return 0;
+}
+
+int
+ocp_gpio_open_drain(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->odr = (gpiop->odr & ~mask) | (data & mask);
+
+	return 0;
+}
+
+int
+ocp_gpio_in(__u32 device, __u32 mask, volatile __u32 * data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->tcr = gpiop->tcr & ~mask;
+	eieio();
+
+	/*
+	   ** If the previous state was OUT, and gpiop->ir is read once, then the
+	   ** data that was being OUTput will be read.  One way to get the right
+	   ** data is to read gpiop->ir twice.
+	 */
+
+	*data = gpiop->ir;
+	*data = gpiop->ir & mask;
+	eieio();
+	return 0;
+}
+
+int
+ocp_gpio_out(__u32 device, __u32 mask, __u32 data)
+{
+	if (device != 0)
+		return -ENXIO;
+	gpiop->or = (gpiop->or & ~mask) | (data & mask);
+	eieio();
+	gpiop->tcr = gpiop->tcr | mask;
+	eieio();
+	return 0;
+}
+
+static int
+ocp_gpio_ioctl(struct inode *inode, struct file *file,
+	       unsigned int cmd, unsigned long arg)
+{
+	static struct ocp_gpio_ioctl_data ioctl_data;
+	int status;
+
+	switch (cmd) {
+	case IBMGPIO_IN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		status = ocp_gpio_in(ioctl_data.device,
+				     ioctl_data.mask, &ioctl_data.data);
+		if (status != 0)
+			return status;
+
+		if (copy_to_user((struct ocp_gpio_ioctl_data *) arg,
+				 &ioctl_data, sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		break;
+
+	case IBMGPIO_OUT:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ocp_gpio_out(ioctl_data.device,
+				    ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_OPEN_DRAIN:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data))) {
+			return -EFAULT;
+		}
+
+		return ocp_gpio_open_drain(ioctl_data.device,
+					   ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_TRISTATE:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ocp_gpio_tristate(ioctl_data.device,
+					 ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	case IBMGPIO_CFG:
+		if (copy_from_user(&ioctl_data,
+				   (struct ocp_gpio_ioctl_data *) arg,
+				   sizeof (ioctl_data)))
+			return -EFAULT;
+
+		return ocp_gpio_config(ioctl_data.device,
+				ioctl_data.mask, ioctl_data.data);
+
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+	return 0;
+}
+
+static struct file_operations ocp_gpio_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= ocp_gpio_ioctl,
+};
+
+struct miscdevice ocp_gpio_miscdev = {
+	.minor		= 185,	/*GPIO_MINOR; */
+	.name		= "IBM4xx ocp gpio",
+	.fops		= &ocp_gpio_fops,
+};
+
+static int __devinit ocp_gpio_probe(struct ocp_device *pdev)
+{
+	printk("IBM gpio driver version %s\n", VUFX);
+
+	misc_register(&ocp_gpio_miscdev);	/*ocp_gpio_miscdev); */
+
+	pdev->vaddr = ioremap(pdev->paddr, sizeof (struct gpio_regs));
+	gpiop = (struct gpio_regs *)pdev->vaddr;
+	printk("GPIO #%d at 0x%lx\n", pdev->num, (unsigned long) gpiop);
+
+	ocp_force_power_on(pdev);
+	return 1;
+}
+
+static void __devexit ocp_gpio_remove_one (struct ocp_device *pdev)
+{
+	ocp_force_power_off(pdev);
+	misc_deregister(&ocp_gpio_miscdev);
+}
+
+static struct ocp_device_id ocp_gpio_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_GPIO},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_gpio_id_tbl );
+
+static struct ocp_driver ocp_gpio_driver = {
+	.name		= "ocp_gpio",
+	.id_table	= ocp_gpio_id_tbl,
+	.probe		= ocp_gpio_probe,
+	.remove		= __devexit_p(ocp_gpio_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_generic_suspend,
+	.resume		= ocp_generic_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+ocp_gpio_init(void)
+{
+	printk("IBM gpio driver version %s\n", VUFX);
+	return ocp_module_init(&ocp_gpio_driver);
+}
+
+void __exit
+ocp_gpio_fini(void)
+{
+	ocp_unregister_driver(&ocp_gpio_driver);
+}
+
+module_init(ocp_gpio_init);
+module_exit(ocp_gpio_fini);
+
+EXPORT_SYMBOL(ocp_gpio_tristate);
+EXPORT_SYMBOL(ocp_gpio_open_drain);
+EXPORT_SYMBOL(ocp_gpio_in);
+EXPORT_SYMBOL(ocp_gpio_out);
+
diff -purN /dev/shm/linux-2.5/drivers/mtd/maps/Kconfig linuxppc-2.5-benh/drivers/mtd/maps/Kconfig
--- /dev/shm/linux-2.5/drivers/mtd/maps/Kconfig	2003-08-18 18:25:06.000000000 +0000
+++ linuxppc-2.5-benh/drivers/mtd/maps/Kconfig	2003-08-20 17:32:37.000000000 +0000
@@ -296,12 +296,20 @@ config MTD_ARCTIC
 
 config MTD_EBONY
 	tristate "CFI Flash device mapped on IBM 440GP Ebony"
-	depends on MTD_CFI && PPC32 && 440 && EBONY
+	depends on MTD_CFI && PPC32 && 44x && EBONY
 	help
 	  This enables access routines for the flash chips on the IBM 440GP
 	  Ebony board. If you have one of these boards and would like to
 	  use the flash chips on it, say 'Y'.
 
+config MTD_OCOTEA
+	tristate "CFI Flash device mapped on IBM 440GX Ocotea"
+	depends on MTD_CFI && PPC32 && 44x && OCOTEA
+	help
+	  This enables access routines for the flash chips on the IBM 440GX
+	  Ocotea board. If you have one of these boards and would like to
+	  use the flash chips on it, say 'Y'.
+
 config MTD_REDWOOD
 	tristate "CFI Flash devices mapped on IBM Redwood"
 	depends on MTD_CFI && PPC32 && 4xx && 40x && ( REDWOOD_4 || REDWOOD_5 || REDWOOD_6 )
diff -purN /dev/shm/linux-2.5/drivers/mtd/maps/Makefile linuxppc-2.5-benh/drivers/mtd/maps/Makefile
--- /dev/shm/linux-2.5/drivers/mtd/maps/Makefile	2003-05-28 15:01:02.000000000 +0000
+++ linuxppc-2.5-benh/drivers/mtd/maps/Makefile	2003-08-02 00:04:32.000000000 +0000
@@ -52,6 +52,7 @@ obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
 obj-$(CONFIG_MTD_EBONY)		+= ebony.o
+obj-$(CONFIG_MTD_OCOTEA)	+= ocotea.o
 obj-$(CONFIG_MTD_BEECH)		+= beech-mtd.o
 obj-$(CONFIG_MTD_ARCTIC)	+= arctic-mtd.o
 obj-$(CONFIG_MTD_H720X)		+= h720x-flash.o
diff -purN /dev/shm/linux-2.5/drivers/mtd/maps/ebony.c linuxppc-2.5-benh/drivers/mtd/maps/ebony.c
--- /dev/shm/linux-2.5/drivers/mtd/maps/ebony.c	2003-06-23 12:34:05.000000000 +0000
+++ linuxppc-2.5-benh/drivers/mtd/maps/ebony.c	2003-06-26 23:07:07.000000000 +0000
@@ -1,11 +1,11 @@
 /*
  * $Id: ebony.c,v 1.8 2003/06/23 11:48:18 dwmw2 Exp $
- * 
+ *
  * Mapping for Ebony user flash
  *
  * Matt Porter <mporter@mvista.com>
  *
- * Copyright 2002 MontaVista Software Inc.
+ * Copyright 2002-2003 MontaVista Software Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -22,8 +22,8 @@
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
 #include <asm/io.h>
-#include <asm/ibm440.h>
-#include <platforms/ebony.h>
+#include <asm/ibm44x.h>
+#include <platforms/4xx/ebony.h>
 
 static struct mtd_info *flash;
 
@@ -71,7 +71,7 @@ int __init init_ebony(void)
 		return -ENOMEM;
 
 	fpga0_reg = readb(fpga0_adr);
-	iounmap64(fpga0_adr);
+	iounmap(fpga0_adr);
 
 	if (EBONY_BOOT_SMALL_FLASH(fpga0_reg) &&
 			!EBONY_FLASH_SEL(fpga0_reg))
diff -purN /dev/shm/linux-2.5/drivers/mtd/maps/ocotea.c linuxppc-2.5-benh/drivers/mtd/maps/ocotea.c
--- /dev/shm/linux-2.5/drivers/mtd/maps/ocotea.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/mtd/maps/ocotea.c	2003-08-02 00:04:00.000000000 +0000
@@ -0,0 +1,155 @@
+/*
+ * Mapping for Ocotea user flash
+ *
+ * Matt Porter <mporter@mvista.com>
+ *
+ * Copyright 2002-2003 MontaVista Software Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/config.h>
+#include <asm/io.h>
+#include <asm/ibm44x.h>
+#include <platforms/4xx/ocotea.h>
+
+static struct mtd_info *flash;
+
+static struct map_info ocotea_small_map = {
+	.name =		"Ocotea small flash",
+	.size =		OCOTEA_SMALL_FLASH_SIZE,
+	.buswidth =	1,
+};
+
+static struct map_info ocotea_large_map = {
+	.name =		"Ocotea large flash",
+	.size =		OCOTEA_LARGE_FLASH_SIZE,
+	.buswidth =	1,
+};
+
+static struct mtd_partition ocotea_small_partitions[] = {
+	{
+		.name =   "pibs",
+		.offset = 0x0,
+		.size =   0x100000,
+	}
+};
+
+static struct mtd_partition ocotea_large_partitions[] = {
+	{
+		.name =   "fs",
+		.offset = 0,
+		.size =   0x300000,
+	},
+	{
+		.name =   "firmware",
+		.offset = 0x300000,
+		.size =   0x100000,
+	}
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+int __init init_ocotea(void)
+{
+	u8 fpga0_reg;
+	void * fpga0_adr;
+	unsigned long long small_flash_base, large_flash_base;
+
+	fpga0_adr = ioremap64(OCOTEA_FPGA_ADDR, 16);
+	if (!fpga0_adr)
+		return -ENOMEM;
+
+	fpga0_reg = readb((unsigned long)fpga0_adr);
+	iounmap(fpga0_adr);
+
+	if (OCOTEA_BOOT_LARGE_FLASH(fpga0_reg)) {
+		small_flash_base = OCOTEA_SMALL_FLASH_HIGH;
+		large_flash_base = OCOTEA_LARGE_FLASH_LOW;
+	}
+	else {
+		small_flash_base = OCOTEA_SMALL_FLASH_LOW;
+		large_flash_base = OCOTEA_LARGE_FLASH_HIGH;
+	}
+
+	ocotea_small_map.phys = small_flash_base;
+	ocotea_small_map.virt =
+		(unsigned long)ioremap64(small_flash_base,
+					 ocotea_small_map.size);
+
+	if (!ocotea_small_map.virt) {
+		printk("Failed to ioremap flash\n");
+		return -EIO;
+	}
+
+	simple_map_init(&ocotea_small_map);
+
+	flash = do_map_probe("map_rom", &ocotea_small_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, ocotea_small_partitions,
+					NB_OF(ocotea_small_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	ocotea_large_map.phys = large_flash_base;
+	ocotea_large_map.virt =
+		(unsigned long)ioremap64(large_flash_base,
+					 ocotea_large_map.size);
+
+	if (!ocotea_large_map.virt) {
+		printk("Failed to ioremap flash\n");
+		return -EIO;
+	}
+
+	simple_map_init(&ocotea_large_map);
+
+	flash = do_map_probe("cfi_probe", &ocotea_large_map);
+	if (flash) {
+		flash->owner = THIS_MODULE;
+		add_mtd_partitions(flash, ocotea_large_partitions,
+					NB_OF(ocotea_large_partitions));
+	} else {
+		printk("map probe failed for flash\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static void __exit cleanup_ocotea(void)
+{
+	if (flash) {
+		del_mtd_partitions(flash);
+		map_destroy(flash);
+	}
+
+	if (ocotea_small_map.virt) {
+		iounmap((void *)ocotea_small_map.virt);
+		ocotea_small_map.virt = 0;
+	}
+
+	if (ocotea_large_map.virt) {
+		iounmap((void *)ocotea_large_map.virt);
+		ocotea_large_map.virt = 0;
+	}
+}
+
+module_init(init_ocotea);
+module_exit(cleanup_ocotea);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matt Porter <mporter@mvista.com>");
+MODULE_DESCRIPTION("MTD map and partitions for IBM 440GX Ocotea boards");
diff -purN /dev/shm/linux-2.5/drivers/net/Kconfig linuxppc-2.5-benh/drivers/net/Kconfig
--- /dev/shm/linux-2.5/drivers/net/Kconfig	2004-01-19 17:40:47.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/Kconfig	2004-01-21 00:29:26.000000000 +0000
@@ -198,6 +198,8 @@ config MII
 
 source "drivers/net/arm/Kconfig"
 
+source "drivers/net/ibm_ocp/Kconfig"
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on NET_ETHERNET && PPC_PMAC
@@ -242,6 +244,17 @@ config OAKNET
 	  To compile this driver as a module, choose M here: the module
 	  will be called oaknet.
 
+config ARCTIC_ENET
+	tristate "Arctic-III development sled ethernet support"
+	depends on NET_ETHERNET && ARCTIC2
+	help
+	  
+	  If you have an IBM Arctic III with an RTL8019AS ethernet
+	  chip on the development sled, say Y.  Otherwise, say N.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called arctic_enet.
+
 config ARIADNE
 	tristate "Ariadne support"
 	depends on NET_ETHERNET && ZORRO
diff -purN /dev/shm/linux-2.5/drivers/net/Makefile linuxppc-2.5-benh/drivers/net/Makefile
--- /dev/shm/linux-2.5/drivers/net/Makefile	2004-01-10 15:59:02.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/Makefile	2004-01-21 00:37:25.000000000 +0000
@@ -96,6 +96,7 @@ obj-$(CONFIG_NE3210) += ne3210.o 8390.o
 obj-$(CONFIG_NET_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
 obj-$(CONFIG_FORCEDETH) += forcedeth.o
+obj-$(CONFIG_ARCTIC_ENET) += arctic_enet.o 8390.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
@@ -188,4 +189,4 @@ obj-$(CONFIG_NET_WIRELESS) += wireless/
 obj-$(CONFIG_NET_TULIP) += tulip/
 obj-$(CONFIG_HAMRADIO) += hamradio/
 obj-$(CONFIG_IRDA) += irda/
-
+obj-$(CONFIG_OCP_NET)	+= ibm_ocp/
diff -purN /dev/shm/linux-2.5/drivers/net/arctic_enet.c linuxppc-2.5-benh/drivers/net/arctic_enet.c
--- /dev/shm/linux-2.5/drivers/net/arctic_enet.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/arctic_enet.c	2003-06-12 22:26:06.000000000 +0000
@@ -0,0 +1,652 @@
+/*
+ *  IPE405 (IBM IAP 405 chip evaluation board) Debug Support Board
+ *    Ehernet Driver
+ *  (C) Copyright 2001 by S.nishino (jl04348@jp.ibm.com)  IBM-Japan
+ *
+ * ---------- Strategy ----------
+ *
+ *  This NIC is RTL8019AS, simply connected to External Bus Controller
+ *  of IAP 405 chip. As many folks of 8390 based NIC, 8390 core driver
+ *  is usable.  luckily, the following driver is already available for
+ *  Amiga zorro bus (however I don't know this architecture beyond
+ *  below), this is modified based on this driver (ariadne2).
+ *
+ * ---------- original header ----------
+ *  Amiga Linux/m68k Ariadne II Ethernet Driver
+ *
+ *  (C) Copyright 1998 by some Elitist 680x0 Users(TM)
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This program is based on all the other NE2000 drivers for Linux
+ *
+ *  ---------------------------------------------------------------------------
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of the Linux
+ *  distribution for more details.  */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/irq.h>
+
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/ppc4xx_pic.h>
+#if defined(CONFIG_ARCTIC2)
+#include <platforms/4xx/arctic2.h>
+#else
+#error The driver only works on Arctic
+#endif
+
+#include "8390.h"
+
+
+#define ARCTIC_ENET_BASE8	(ARCTIC2_FPGA8_PADDR + 256*1024)
+#define ARCTIC_ENET_BASE16	(ARCTIC2_FPGA16_PADDR + 0)
+
+#define ARCTIC_ENET_IOBASE	0x0300	/* io base offset from NIC region */
+
+#define ARCTIC_ENET_IRQ		29	/* irq number in UIC */
+#define ARCTIC_ENET_IRQ_MASK	(0x80000000 >> ARCTIC_ENET_IRQ)
+
+#define NE_BASE         (ARCTIC_ENET_BASE8 + ARCTIC_ENET_IOBASE)
+#define NE_BASE16       (ARCTIC_ENET_BASE16 + ARCTIC_ENET_IOBASE)
+
+/* 8390 register address */
+#define NE_CMD          (0x00)
+#define NE_DATAPORT     (0x10)	/* NatSemi-defined port window offset. */
+#define NE_DATAPORT16	(NE_DATAPORT / sizeof(u16))
+#define NE_RESET        (0x1f)	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT    (0x20)	/* region extent */
+
+#define NE_EN0_ISR      (0x07)
+#define NE_EN0_DCFG     (0x0e)
+
+#define NE_EN0_RSARLO   (0x08)
+#define NE_EN0_RSARHI   (0x09)
+#define NE_EN0_RCNTLO   (0x0a)
+#define NE_EN0_RXCR     (0x0c)
+#define NE_EN0_TXCR     (0x0d)
+#define NE_EN0_RCNTHI   (0x0b)
+#define NE_EN0_IMR      (0x0f)
+
+/* 8390 packet buffer page number */
+#define NESM_START_PG   0x40	/* First page of TX buffer */
+#define NESM_STOP_PG    0x80	/* Last page +1 of RX ring */
+
+static u8 *iobase8;
+static u16 *iobase16;
+
+static int arctic_enet_probe(struct net_device *dev);
+static int arctic_enet_init(struct net_device *dev);
+
+static int arctic_enet_open(struct net_device *dev);
+static int arctic_enet_close(struct net_device *dev);
+
+static void arctic_enet_reset_8390(struct net_device *dev);
+static void arctic_enet_get_8390_hdr(struct net_device *dev,
+				    struct e8390_pkt_hdr *hdr,
+				    int ring_page);
+static void arctic_enet_block_input(struct net_device *dev, int count,
+				   struct sk_buff *skb, int ring_offset);
+static void arctic_enet_block_output(struct net_device *dev,
+				    const int count,
+				    const unsigned char *buf,
+				    const int start_page);
+
+/* These macros will do something on Arctic-I if we ever add support
+ * for it back in */
+#define switch_16bit_bank()	do { } while (0)
+#define switch_8bit_bank()	do { } while (0)
+
+void p_dump(unsigned char *p, int sz)
+{
+	int i;
+	unsigned char *wp;
+	
+	wp = p;
+	
+	printk("------ PACKET START :  %d Bytes  ------ \n", sz);
+	
+	for (i = 0; i < sz; i++) {
+		if (i % 16 == 0) {
+			printk("\n %04X: %02X ", i, *wp);
+		} else if (i % 16 == 15) {
+			printk("%02X", *wp);
+		} else {
+			printk("%02X ", *wp);
+		}
+		wp++;
+	}
+
+	printk("------ PACKET END   ------ \n");
+}
+
+/* Code for reading the MAC address from the Arctic ethernet based on
+ * similar code in PIBS */
+
+static void __init writereg_9346(volatile u8 *iobase, u8 value)
+{
+	/* Switch to register page 3 */
+	writeb(readb(iobase + NE_CMD) | 0xc0, iobase + NE_CMD);
+	writeb(value, iobase + 0x01);
+}
+
+static u8 __init readreg_9346(volatile u8 *iobase)
+{
+	/* Switch to register page 3 */
+	writeb(readb(iobase + NE_CMD) | 0xc0, iobase + NE_CMD);
+	return readb(iobase + 0x01);
+}
+
+static void __init write_bit_9346(volatile u8 *iobase, u8 bit)
+{
+	u8 mask = ~0x06;
+	
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | bit);
+	udelay(1000);
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | bit | 0x04);
+	udelay(1000);
+}
+
+static u8 __init read_bit_9346(volatile u8 *iobase)
+{
+	u8 bit;
+	u8 mask = ~0x05;
+	
+	mask = ~0x05;
+	writereg_9346(iobase, readreg_9346(iobase) & mask);
+	udelay(1000);
+	writereg_9346(iobase, (readreg_9346(iobase) & mask) | 0x04);
+	bit = readreg_9346(iobase) & 0x01;
+	udelay(1000);
+
+	return bit;
+}
+
+static u16 __init arctic_read_9346(volatile u8 *iobase, unsigned long addr)
+{
+	unsigned long flags;
+	int i;
+	u16 data;
+
+	local_irq_save(flags);
+
+	/* Put the chip into 8390 programming mode */
+	writereg_9346(iobase, (readreg_9346(iobase) & ~0xc0) | 0x80);
+	udelay(1000);
+
+	/* Send command (read 16-bit value) to EEPROM */
+	/* Bring CS Low */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0x0f);
+	udelay(1000);
+	/* Bring CS High */
+	writereg_9346(iobase, (readreg_9346(iobase) & ~0x0f) | 0x08);
+	udelay(1000);
+
+	/* Send a 1 */
+	write_bit_9346(iobase, 0x02);
+	/* Send opcode 0b10 */
+	write_bit_9346(iobase, 0x02);
+	write_bit_9346(iobase, 0x00);
+	/* Send address to read */
+	for (i = 0; i < 6; i++) {
+		if (addr & 0x20)
+			write_bit_9346(iobase, 0x02);
+		else
+			write_bit_9346(iobase, 0x00);
+		addr <<= 1;
+	}
+
+	/* Read the value back, bit by bit */
+	data = 0;
+	for (i = 0; i < 16; i++) {
+		data <<= 1;
+		if (read_bit_9346(iobase))
+			data |= 0x1;
+	}
+
+	/* Bring CS Low */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0x0f);
+	udelay(1000);
+	/* Bring the chip out of 8390 programming mode */
+	writereg_9346(iobase, readreg_9346(iobase) & ~0xc0);
+	udelay(1000);
+
+	/* Return to register page 0 */
+	writeb(readb(iobase + NE_CMD) & ~0xc0, iobase + NE_CMD);
+	udelay(1000);
+
+	local_irq_restore(flags);
+	
+	return data;
+}
+
+static void __init arctic_get_macaddr(struct net_device *dev)
+{
+	u16 t0, t1, t2, v0, v1;
+
+	t0 = arctic_read_9346(iobase8, 0);
+	t1 = arctic_read_9346(iobase8, 2);
+	t2 = arctic_read_9346(iobase8, 4);
+	v0 = arctic_read_9346(iobase8, 6);
+	v1 = arctic_read_9346(iobase8, 8);
+
+	if ( (v0 != 0x4d50) || (v1 != 0x5400) ) {
+		printk(KERN_WARNING "%s: MAC address is not set in EEPROM\n", dev->name);
+		return;
+	}
+
+	dev->dev_addr[0] = t0 >> 8;
+	dev->dev_addr[1] = t0 & 0xff;
+	dev->dev_addr[2] = t1 >> 8;
+	dev->dev_addr[3] = t1 & 0xff;
+	dev->dev_addr[4] = t2 >> 8;
+	dev->dev_addr[5] = t2 & 0xff;
+}
+
+int __init arctic_enet_probe(struct net_device *dev)
+{
+	unsigned long reset_start_time;
+
+	switch_8bit_bank();
+	/* Reset card. Who knows what dain-bramaged state it was left in. */
+	reset_start_time = jiffies;
+	
+	writeb(readb(iobase8 + NE_RESET), iobase8 + NE_RESET);
+
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2 * HZ / 100) {
+			printk("arctic_enet: not found (no reset ack).\n");
+			return -ENODEV;
+		}
+	
+	writeb(0xff, iobase8 + NE_EN0_ISR);	/* Ack all intr. */
+
+	arctic_get_macaddr(dev);
+
+	printk("arctic_enet: found at 0x%08x/0x%08x, MAC address "
+	       "%02x:%02x:%02x:%02x:%02x:%02x\n",
+	       NE_BASE, NE_BASE16,
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	/* Hack to let 8390.c work properly - it assumes IO space
+	 * addresses */
+	dev->base_addr = (unsigned long)iobase8 - _IO_BASE;
+	dev->irq = ARCTIC_ENET_IRQ;
+
+	return 0;
+}
+
+static int __init arctic_enet_init(struct net_device *dev)
+{
+	static u32 arctic_enet_offsets[16] = {
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	};
+
+	/* Since this irq is connected to uic as edge interrupt, its pending must be cleared. */
+	/* FIXME: it would be nice to get rid of the direct reference
+	 * to the 4xx irq structure */
+	ppc4xx_pic->ack(dev->irq);
+
+	/* Install the Interrupt handler */
+	if (request_irq(dev->irq, ei_interrupt, SA_SHIRQ, dev->name, dev))
+		return -EAGAIN;
+
+	/* Allocate dev->priv and fill in 8390 specific dev fields. */
+	if (ethdev_init(dev)) {
+		printk(" Unable to get memory for dev->priv.\n");
+		return -ENOMEM;
+	}
+	
+	/*
+	 * Fill 8390 specific member for 8390 core driver
+	 */
+	ei_status.name = "RTL8019AS";
+	ei_status.tx_start_page = NESM_START_PG;
+	ei_status.stop_page = NESM_STOP_PG;
+	ei_status.word16 = 1;
+	ei_status.rx_start_page = NESM_START_PG + TX_PAGES;
+	
+	ei_status.reset_8390 = &arctic_enet_reset_8390;
+	ei_status.block_input = &arctic_enet_block_input;
+	ei_status.block_output = &arctic_enet_block_output;
+	ei_status.get_8390_hdr = &arctic_enet_get_8390_hdr;
+	ei_status.reg_offset = arctic_enet_offsets;
+
+	NS8390_init(dev, 0);
+	return 0;
+}
+
+static int arctic_enet_open(struct net_device *dev)
+{
+	int err;
+	err = ei_open(dev);
+	if (err)
+		return err;
+
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static int arctic_enet_close(struct net_device *dev)
+{
+	int err;
+
+	err = ei_close(dev);
+	if (err)
+		return err;
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/* Hard reset the card.  This used to pause for the same period that a
+   8390 reset command required, but that shouldn't be necessary. */
+static void arctic_enet_reset_8390(struct net_device *dev)
+{
+	unsigned long reset_start_time = jiffies;
+
+	if (ei_debug > 1)
+		printk("resetting the 8390 t=%ld...", jiffies);
+
+	writeb(readb(iobase8 + NE_RESET), iobase8 + NE_RESET);
+
+	ei_status.txing = 0;
+	ei_status.dmaing = 0;
+
+	/* This check _should_not_ be necessary, omit eventually. */
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2 * HZ / 100) {
+			printk("%s: ne_reset_8390() did not complete.\n",
+			       dev->name);
+			break;
+		}
+	writeb(ENISR_RESET, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+}
+
+/* Grab the 8390 specific header. Similar to the block_input routine, but
+   we don't need to be concerned with ring wrap as the header will be at
+   the start of a page, so we optimize accordingly. */
+
+static void arctic_enet_get_8390_hdr(struct net_device *dev,
+				    struct e8390_pkt_hdr *hdr,
+				    int ring_page)
+{
+	int cnt;
+	u16 *ptrs;
+	unsigned char *ptrc;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_get_8390_hdr "
+		       "[DMAstat:%d][irqlock:%d].\n", dev->name,
+		       ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+
+	ei_status.dmaing |= 0x01;
+	writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, iobase8 + NE_CMD);
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+	writeb(sizeof(struct e8390_pkt_hdr), iobase8 + NE_EN0_RCNTLO);
+	writeb(0, iobase8 + NE_EN0_RCNTHI);
+	writeb(0, iobase8 + NE_EN0_RSARLO);	/* On page boundary */
+	writeb(ring_page, iobase8 + NE_EN0_RSARHI);
+	writeb(E8390_RREAD + E8390_START, iobase8 + NE_CMD);
+
+	if (ei_status.word16) {
+		switch_16bit_bank();
+		ptrs = (u16 *) hdr;
+		for (cnt = 0; cnt < (sizeof(struct e8390_pkt_hdr) >> 1);
+		     cnt++)
+			*ptrs++ = in_be16((u16 *) (iobase16 + NE_DATAPORT16));
+		switch_8bit_bank();
+	} else {
+
+		ptrc = (unsigned char *) hdr;
+		for (cnt = 0; cnt < sizeof(struct e8390_pkt_hdr); cnt++)
+			*ptrc++ = readb(iobase8 + NE_DATAPORT);
+	}
+
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+
+	/* I am Big Endian, but received byte count is Little Endian. */
+	hdr->count = le16_to_cpu(hdr->count);
+
+	ei_status.dmaing &= ~0x01;
+}
+
+/* Block input and output, similar to the Crynwr packet driver.  If you
+   are porting to a new ethercard, look at the packet driver source for hints.
+   The NEx000 doesn't share the on-board packet memory -- you have to put
+   the packet out through the "remote DMA" dataport using writeb. */
+
+static void arctic_enet_block_input(struct net_device *dev, int count,
+				   struct sk_buff *skb, int ring_offset)
+{
+	char *buf = skb->data;
+	u16 *ptrs;
+	unsigned char *ptrc;
+
+	int cnt;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_block_input "
+		       "[DMAstat:%d][irqlock:%d].\n",
+		       dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, iobase8 + NE_CMD);
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+	writeb(count & 0xff, iobase8 + NE_EN0_RCNTLO);
+	writeb(count >> 8, iobase8 + NE_EN0_RCNTHI);
+	writeb(ring_offset & 0xff, iobase8 + NE_EN0_RSARLO);
+	writeb(ring_offset >> 8, iobase8 + NE_EN0_RSARHI);
+	writeb(E8390_RREAD + E8390_START, iobase8 + NE_CMD);
+
+
+	if (ei_status.word16) {
+
+		switch_16bit_bank();
+
+		ptrs = (u16 *) buf;
+		for (cnt = 0; cnt < (count >> 1); cnt++)
+			/* At 16 bits mode, bus acts as Little Endian mode
+			   That's swap is needed ??? */
+			*ptrs++ = in_be16((u16 *) (iobase16 + NE_DATAPORT16));
+		switch_8bit_bank();
+
+		if (count & 0x01)
+			buf[count - 1] = readb(iobase8 + NE_DATAPORT);
+
+	} else {
+
+
+		ptrc = (unsigned char *) buf;
+		for (cnt = 0; cnt < count; cnt++)
+			*ptrc++ = readb(iobase8 + NE_DATAPORT);
+	}
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+}
+
+static void arctic_enet_block_output(struct net_device *dev, int count,
+				    const unsigned char *buf,
+				    const int start_page)
+{
+	unsigned long dma_start;
+	u16 *ptrs;
+	unsigned char *ptrc;
+	int cnt;
+
+	/* Round the count up for word writes.  Do we need to do this?
+	   What effect will an odd byte count have on the 8390?
+	   I should check someday. */
+	if (count & 0x01)
+		count++;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing) {
+		printk("%s: DMAing conflict in ne_block_output."
+		       "[DMAstat:%d][irqlock:%d]\n", dev->name,
+		       ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+
+#if 1 /* FIXME: not sure what this is for -dwg */
+	writeb(0x42, iobase8 + EN0_RCNTLO);
+	writeb(0x00, iobase8 + EN0_RCNTHI);
+	writeb(0x42, iobase8 + EN0_RSARLO);
+	writeb(0x00, iobase8 + EN0_RSARHI);
+#endif
+	/* We should already be in page 0, but to be safe... */
+	writeb(E8390_PAGE0 + E8390_START + E8390_NODMA, iobase8 + NE_CMD);
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);
+
+	/* Now the normal output. */
+	writeb(count & 0xff, iobase8 + NE_EN0_RCNTLO);
+	writeb(count >> 8, iobase8 + NE_EN0_RCNTHI);
+	writeb(0x00, iobase8 + NE_EN0_RSARLO);
+	writeb(start_page, iobase8 + NE_EN0_RSARHI);
+
+	writeb(E8390_RWRITE + E8390_START, iobase8 + NE_CMD);
+
+	if (ei_status.word16) {
+		switch_16bit_bank();
+
+		ptrs = (u16 *) buf;
+		for (cnt = 0; cnt < count >> 1; cnt++) {
+			/* At 16 bits mode, bus acts as Little Endian mode
+			   That's swap is needed ??? */
+			out_be16((u16 *) (iobase16 + NE_DATAPORT16),
+				 *ptrs);
+			ptrs++;
+		}
+
+		switch_8bit_bank();
+
+	} else {
+		ptrc = (unsigned char *) buf;
+		for (cnt = 0; cnt < count; cnt++)
+			writeb(*ptrc++, iobase8 + NE_DATAPORT);
+	}
+
+	dma_start = jiffies;
+
+	while ((readb(iobase8 + NE_EN0_ISR) & ENISR_RDC) == 0)
+		if (jiffies - dma_start > 2 * HZ / 100) {	/* 20ms */
+			printk("%s: timeout waiting for Tx RDC.\n",
+			       dev->name);
+			arctic_enet_reset_8390(dev);
+			NS8390_init(dev, 1);
+			break;
+		}
+
+	writeb(ENISR_RDC, iobase8 + NE_EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+	return;
+}
+
+static struct net_device arctic_enet_dev = {
+	.init	= arctic_enet_init,
+	.open	= arctic_enet_open,
+	.stop	= arctic_enet_close,
+};
+
+int init_arctic_enet(void)
+{
+	struct net_device *dev = &arctic_enet_dev;
+	int rsvd8 = 0;
+	int rsvd16 = 0;
+	int err;
+
+	/* First set up our IO regions */
+	if (! request_mem_region(NE_BASE, NE_IO_EXTENT, "arctic_enet"))
+		goto fail;
+	rsvd8 = 1;
+
+	iobase8 = ioremap(NE_BASE, NE_IO_EXTENT);
+	if (! iobase8) {
+		err = -EBUSY;
+		goto fail;
+	}
+	
+	if (NE_BASE16 != NE_BASE) {
+		if (! request_mem_region(NE_BASE16, NE_IO_EXTENT, "arctic_enet"))
+			goto fail;
+		rsvd16 = 1;
+	}
+
+	iobase16 = ioremap(NE_BASE16, NE_IO_EXTENT);
+	if (! iobase16) {
+		err = -EBUSY;
+		goto fail;
+	}	
+
+	/* Configure IRQ */
+	cli();
+	mtdcr(DCRN_UIC0_TR, mfdcr(DCRN_UIC0_TR) | ARCTIC_ENET_IRQ_MASK);
+	mtdcr(DCRN_UIC0_PR, mfdcr(DCRN_UIC0_PR) | ARCTIC_ENET_IRQ_MASK);
+	mtdcr(DCRN_UIC0_SR, ARCTIC_ENET_IRQ_MASK);
+	sti();
+
+	err = arctic_enet_probe(dev);
+	if (err) {
+		printk(KERN_ERR "arctic_enet: No Arctic ethernet card found.\n");
+		goto fail;
+	}
+
+	err = register_netdev(dev);
+	if (err)
+		goto fail;
+
+	return 0;
+
+ fail:
+	if (iobase16)
+		iounmap(iobase16);
+	if (rsvd16)
+		release_mem_region(NE_BASE16, NE_IO_EXTENT);
+	if (iobase8)
+		iounmap(iobase8);
+	if (rsvd8)
+		release_mem_region(NE_BASE, NE_IO_EXTENT);
+
+	return err;
+	
+}
+
+void remove_arctic_enet(void)
+{
+	unregister_netdev(&arctic_enet_dev);
+	free_irq(ARCTIC_ENET_IRQ, &arctic_enet_dev);
+
+	if (iobase16) {
+		iounmap(iobase16);
+		release_mem_region(NE_BASE16, NE_IO_EXTENT);
+	}
+	if (iobase8) {
+		iounmap(iobase8);
+		release_mem_region(NE_BASE, NE_IO_EXTENT);
+	}
+}
+
+module_init(init_arctic_enet);
+module_exit(remove_arctic_enet);
diff -purN /dev/shm/linux-2.5/drivers/net/bmac.c linuxppc-2.5-benh/drivers/net/bmac.c
--- /dev/shm/linux-2.5/drivers/net/bmac.c	2003-09-04 07:36:29.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/bmac.c	2003-12-31 05:48:13.000000000 +0000
@@ -26,11 +26,9 @@
 #include <asm/pgtable.h>
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>
+#include <asm/macio.h>
 #include <asm/irq.h>
-#ifdef CONFIG_PMAC_PBOOK
-#include <linux/adb.h>
-#include <linux/pmu.h>
-#endif
+
 #include "bmac.h"
 
 #define trunc_page(x)	((void *)(((unsigned long)(x)) & ~((unsigned long)(PAGE_SIZE - 1))))
@@ -67,7 +65,7 @@ struct bmac_data {
 	int rx_dma_intr;
 	volatile struct dbdma_cmd *tx_cmds;	/* xmit dma command list */
 	volatile struct dbdma_cmd *rx_cmds;	/* recv dma command list */
-	struct device_node *node;
+	struct macio_dev *mdev;
 	int is_bmac_plus;
 	struct sk_buff *rx_bufs[N_RX_RING];
 	int rx_fill;
@@ -84,9 +82,10 @@ struct bmac_data {
 	unsigned short hash_use_count[64];
 	unsigned short hash_table_mask[4];
 	spinlock_t lock;
-	struct net_device *next_bmac;
 };
 
+#if 0 /* Move that to ethtool */
+
 typedef struct bmac_reg_entry {
 	char *name;
 	unsigned short reg_offset;
@@ -128,16 +127,10 @@ static bmac_reg_entry_t reg_entries[N_RE
 	{"RXCV", RXCV}
 };
 
-static struct net_device *bmac_devs;
-static unsigned char *bmac_emergency_rxbuf;
-
-#ifdef CONFIG_PMAC_PBOOK
-static int bmac_sleep_notify(struct pmu_sleep_notifier *self, int when);
-static struct pmu_sleep_notifier bmac_sleep_notifier = {
-	bmac_sleep_notify, SLEEP_LEVEL_NET,
-};
 #endif
 
+static unsigned char *bmac_emergency_rxbuf;
+
 /*
  * Number of bytes of private data per BMAC: allow enough for
  * the rx and tx dma commands plus a branch dma command each,
@@ -149,7 +142,6 @@ static struct pmu_sleep_notifier bmac_sl
 	+ sizeof(struct sk_buff_head))
 
 static unsigned char bitrev(unsigned char b);
-static void bmac_probe1(struct device_node *bmac, int is_bmac_plus);
 static int bmac_open(struct net_device *dev);
 static int bmac_close(struct net_device *dev);
 static int bmac_transmit_packet(struct sk_buff *skb, struct net_device *dev);
@@ -166,7 +158,6 @@ static irqreturn_t bmac_txdma_intr(int i
 static irqreturn_t bmac_rxdma_intr(int irq, void *dev_id, struct pt_regs *regs);
 static void bmac_set_timeout(struct net_device *dev);
 static void bmac_tx_timeout(unsigned long data);
-static int bmac_proc_info ( char *buffer, char **start, off_t offset, int length);
 static int bmac_output(struct sk_buff *skb, struct net_device *dev);
 static void bmac_start(struct net_device *dev);
 
@@ -244,7 +235,7 @@ bmac_enable_and_reset_chip(struct net_de
 	if (td)
 		dbdma_reset(td);
 
-	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, bp->node, 0, 1);
+	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 1);
 }
 
 #define MIFDELAY	udelay(10)
@@ -457,87 +448,80 @@ bmac_init_phy(struct net_device *dev)
 	}
 }
 
-static void
-bmac_init_chip(struct net_device *dev)
+static void bmac_init_chip(struct net_device *dev)
 {
 	bmac_init_phy(dev);
 	bmac_init_registers(dev);
 }
 
-#ifdef CONFIG_PMAC_PBOOK
-static int
-bmac_sleep_notify(struct pmu_sleep_notifier *self, int when)
+#ifdef CONFIG_PM
+static int bmac_suspend(struct macio_dev *mdev, u32 state)
 {
-	struct bmac_data *bp;
+	struct net_device* dev = macio_get_drvdata(mdev);	
+	struct bmac_data *bp = dev->priv;	
 	unsigned long flags;
 	unsigned short config;
-	struct net_device* dev = bmac_devs;
 	int i;
 	
-	if (bmac_devs == 0)
-		return PBOOK_SLEEP_OK;
-		
-	bp = (struct bmac_data *) dev->priv;
-	
-	switch (when) {
-	case PBOOK_SLEEP_REQUEST:
-		break;
-	case PBOOK_SLEEP_REJECT:
-		break;
-	case PBOOK_SLEEP_NOW:
-		netif_device_detach(dev);
-		/* prolly should wait for dma to finish & turn off the chip */
-		spin_lock_irqsave(&bp->lock, flags);
-		if (bp->timeout_active) {
-			del_timer(&bp->tx_timeout);
-			bp->timeout_active = 0;
-		}
-		disable_irq(dev->irq);
-		disable_irq(bp->tx_dma_intr);
-		disable_irq(bp->rx_dma_intr);
-		bp->sleeping = 1;
-		spin_unlock_irqrestore(&bp->lock, flags);
-		if (bp->opened) {
-			volatile struct dbdma_regs *rd = bp->rx_dma;
-			volatile struct dbdma_regs *td = bp->tx_dma;
+	netif_device_detach(dev);
+	/* prolly should wait for dma to finish & turn off the chip */
+	spin_lock_irqsave(&bp->lock, flags);
+	if (bp->timeout_active) {
+		del_timer(&bp->tx_timeout);
+		bp->timeout_active = 0;
+	}
+	disable_irq(dev->irq);
+	disable_irq(bp->tx_dma_intr);
+	disable_irq(bp->rx_dma_intr);
+	bp->sleeping = 1;
+	spin_unlock_irqrestore(&bp->lock, flags);
+	if (bp->opened) {
+		volatile struct dbdma_regs *rd = bp->rx_dma;
+		volatile struct dbdma_regs *td = bp->tx_dma;
 			
-			config = bmread(dev, RXCFG);
-			bmwrite(dev, RXCFG, (config & ~RxMACEnable));
-			config = bmread(dev, TXCFG);
-			bmwrite(dev, TXCFG, (config & ~TxMACEnable));
-			bmwrite(dev, INTDISABLE, DisableAll); /* disable all intrs */
-			/* disable rx and tx dma */
-			st_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
-			st_le32(&td->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
-			/* free some skb's */
-			for (i=0; i<N_RX_RING; i++) {
-				if (bp->rx_bufs[i] != NULL) {
-					dev_kfree_skb(bp->rx_bufs[i]);
-					bp->rx_bufs[i] = NULL;
-				}
-			}
-			for (i = 0; i<N_TX_RING; i++) {
-				if (bp->tx_bufs[i] != NULL) {
-					dev_kfree_skb(bp->tx_bufs[i]);
-					bp->tx_bufs[i] = NULL;
-				}
-			}
+		config = bmread(dev, RXCFG);
+		bmwrite(dev, RXCFG, (config & ~RxMACEnable));
+		config = bmread(dev, TXCFG);
+       		bmwrite(dev, TXCFG, (config & ~TxMACEnable));
+		bmwrite(dev, INTDISABLE, DisableAll); /* disable all intrs */
+       		/* disable rx and tx dma */
+       		st_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
+       		st_le32(&td->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
+       		/* free some skb's */
+       		for (i=0; i<N_RX_RING; i++) {
+       			if (bp->rx_bufs[i] != NULL) {
+       				dev_kfree_skb(bp->rx_bufs[i]);
+       				bp->rx_bufs[i] = NULL;
+       			}
+       		}
+       		for (i = 0; i<N_TX_RING; i++) {
+			if (bp->tx_bufs[i] != NULL) {
+		       		dev_kfree_skb(bp->tx_bufs[i]);
+	       			bp->tx_bufs[i] = NULL;
+		       	}
 		}
-		pmac_call_feature(PMAC_FTR_BMAC_ENABLE, bp->node, 0, 0);
-		break;
-	case PBOOK_WAKE:
-		/* see if this is enough */
-		if (bp->opened)
-			bmac_reset_and_enable(dev);
-		enable_irq(dev->irq);
-		enable_irq(bp->tx_dma_intr);
-		enable_irq(bp->rx_dma_intr);
-		netif_device_attach(dev);
-		break;
 	}
-	return PBOOK_SLEEP_OK;
+       	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);
+	return 0;
 }
-#endif
+
+static int bmac_resume(struct macio_dev *mdev)
+{
+	struct net_device* dev = macio_get_drvdata(mdev);	
+	struct bmac_data *bp = dev->priv;	
+
+	/* see if this is enough */
+	if (bp->opened)
+		bmac_reset_and_enable(dev);
+
+	enable_irq(dev->irq);
+       	enable_irq(bp->tx_dma_intr);
+       	enable_irq(bp->rx_dma_intr);
+       	netif_device_attach(dev);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
 
 static int bmac_set_address(struct net_device *dev, void *addr)
 {
@@ -1277,103 +1261,61 @@ static void bmac_reset_and_enable(struct
 	spin_unlock_irqrestore(&bp->lock, flags);
 }
 
-static int __init bmac_probe(void)
-{
-	struct device_node *bmac;
-
-	MOD_INC_USE_COUNT;
-
-	for (bmac = find_devices("bmac"); bmac != 0; bmac = bmac->next)
-		bmac_probe1(bmac, 0);
-	for (bmac = find_compatible_devices("network", "bmac+"); bmac != 0;
-	     bmac = bmac->next)
-		bmac_probe1(bmac, 1);
-
-	if (bmac_devs != 0) {
-		proc_net_create ("bmac", 0, bmac_proc_info);
-#ifdef CONFIG_PMAC_PBOOK
-		pmu_register_sleep_notifier(&bmac_sleep_notifier);
-#endif
-	}
-
-	MOD_DEC_USE_COUNT;
-
-	return bmac_devs? 0: -ENODEV;
-}
-
-static void __init bmac_probe1(struct device_node *bmac, int is_bmac_plus)
+static int __devinit bmac_probe(struct macio_dev *mdev, const struct of_match *match)
 {
 	int j, rev, ret;
 	struct bmac_data *bp;
 	unsigned char *addr;
 	struct net_device *dev;
+	int is_bmac_plus = ((int)match->data) != 0;
 
-	if (bmac->n_addrs != 3 || bmac->n_intrs != 3) {
-		printk(KERN_ERR "can't use BMAC %s: need 3 addrs and 3 intrs\n",
-		       bmac->full_name);
-		return;
+	if (macio_resource_count(mdev) != 3 || macio_irq_count(mdev) != 3) {
+		printk(KERN_ERR "BMAC: can't use, need 3 addrs and 3 intrs\n");
+		return -ENODEV;
 	}
-	addr = get_property(bmac, "mac-address", NULL);
+	addr = get_property(macio_get_of_node(mdev), "mac-address", NULL);
 	if (addr == NULL) {
-		addr = get_property(bmac, "local-mac-address", NULL);
+		addr = get_property(macio_get_of_node(mdev), "local-mac-address", NULL);
 		if (addr == NULL) {
-			printk(KERN_ERR "Can't get mac-address for BMAC %s\n",
-			       bmac->full_name);
-			return;
-		}
-	}
-
-	if (bmac_emergency_rxbuf == NULL) {
-		bmac_emergency_rxbuf = kmalloc(RX_BUFLEN, GFP_KERNEL);
-		if (bmac_emergency_rxbuf == NULL) {
-			printk(KERN_ERR "BMAC: can't allocate emergency RX buffer\n");
-			return;
+			printk(KERN_ERR "BMAC: Can't get mac-address\n");
+			return -ENODEV;
 		}
 	}
 
 	dev = alloc_etherdev(PRIV_BYTES);
 	if (!dev) {
-		printk(KERN_ERR "alloc_etherdev failed, out of memory for BMAC %s\n",
-		       bmac->full_name);
-		return;
+		printk(KERN_ERR "BMAC: alloc_etherdev failed, out of memory\n");
+		return -ENOMEM;
 	}
 		
 	bp = (struct bmac_data *) dev->priv;
 	SET_MODULE_OWNER(dev);
-	bp->node = bmac;
+	SET_NETDEV_DEV(dev, &mdev->ofdev.dev);
+	macio_set_drvdata(mdev, dev);
+
+	bp->mdev = mdev;
 	spin_lock_init(&bp->lock);
 
-	if (!request_OF_resource(bmac, 0, " (bmac)")) {
+	if (macio_request_resources(mdev, "bmac")) {
 		printk(KERN_ERR "BMAC: can't request IO resource !\n");
-		goto out1;
-	}
-	if (!request_OF_resource(bmac, 1, " (bmac tx dma)")) {
-		printk(KERN_ERR "BMAC: can't request TX DMA resource !\n");
-		goto out2;
-	}
-	if (!request_OF_resource(bmac, 2, " (bmac rx dma)")) {
-		printk(KERN_ERR "BMAC: can't request RX DMA resource !\n");
-		goto out3;
+		goto out_free;
 	}
 
 	dev->base_addr = (unsigned long)
-		ioremap(bmac->addrs[0].address, bmac->addrs[0].size);
-	if (!dev->base_addr)
-		goto out4;
+		ioremap(macio_resource_start(mdev, 0), macio_resource_len(mdev, 0));
+	if (dev->base_addr == 0)
+		goto out_release;
 
-	dev->irq = bmac->intrs[0].line;
+	dev->irq = macio_irq(mdev, 0);
 
 	bmac_enable_and_reset_chip(dev);
 	bmwrite(dev, INTDISABLE, DisableAll);
 
-	printk(KERN_INFO "%s: BMAC%s at", dev->name, (is_bmac_plus? "+": ""));
 	rev = addr[0] == 0 && addr[1] == 0xA0;
 	for (j = 0; j < 6; ++j) {
 		dev->dev_addr[j] = rev? bitrev(addr[j]): addr[j];
 		printk("%c%.2x", (j? ':': ' '), dev->dev_addr[j]);
 	}
-	XXDEBUG((", base_addr=%#0lx", dev->base_addr));
-	printk("\n");
 
 	/* Enable chip without interrupts for now */
 	bmac_enable_and_reset_chip(dev);
@@ -1392,15 +1334,15 @@ static void __init bmac_probe1(struct de
 
 	bp->is_bmac_plus = is_bmac_plus;
 	bp->tx_dma = (volatile struct dbdma_regs *)
-		ioremap(bmac->addrs[1].address, bmac->addrs[1].size);
+		ioremap(macio_resource_start(mdev, 1), macio_resource_len(mdev, 1));
 	if (!bp->tx_dma)
 		goto err_out_iounmap;
-	bp->tx_dma_intr = bmac->intrs[1].line;
+	bp->tx_dma_intr = macio_irq(mdev, 1);
 	bp->rx_dma = (volatile struct dbdma_regs *)
-		ioremap(bmac->addrs[2].address, bmac->addrs[2].size);
+		ioremap(macio_resource_start(mdev, 2), macio_resource_len(mdev, 2));
 	if (!bp->rx_dma)
 		goto err_out_iounmap_tx;
-	bp->rx_dma_intr = bmac->intrs[2].line;
+	bp->rx_dma_intr = macio_irq(mdev, 2);
 
 	bp->tx_cmds = (volatile struct dbdma_cmd *) DBDMA_ALIGN(bp + 1);
 	bp->rx_cmds = bp->tx_cmds + N_TX_RING + 1;
@@ -1415,14 +1357,14 @@ static void __init bmac_probe1(struct de
 		printk(KERN_ERR "BMAC: can't get irq %d\n", dev->irq);
 		goto err_out_iounmap_rx;
 	}
-	ret = request_irq(bmac->intrs[1].line, bmac_txdma_intr, 0, "BMAC-txdma", dev);
+	ret = request_irq(bp->tx_dma_intr, bmac_txdma_intr, 0, "BMAC-txdma", dev);
 	if (ret) {
-		printk(KERN_ERR "BMAC: can't get irq %d\n", bmac->intrs[1].line);
+		printk(KERN_ERR "BMAC: can't get irq %d\n", bp->tx_dma_intr);
 		goto err_out_irq0;
 	}
-	ret = request_irq(bmac->intrs[2].line, bmac_rxdma_intr, 0, "BMAC-rxdma", dev);
+	ret = request_irq(bp->rx_dma_intr, bmac_rxdma_intr, 0, "BMAC-rxdma", dev);
 	if (ret) {
-		printk(KERN_ERR "BMAC: can't get irq %d\n", bmac->intrs[2].line);
+		printk(KERN_ERR "BMAC: can't get irq %d\n", bp->rx_dma_intr);
 		goto err_out_irq1;
 	}
 
@@ -1430,22 +1372,23 @@ static void __init bmac_probe1(struct de
 	 * re-enabled on open()
 	 */
 	disable_irq(dev->irq);
-	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, bp->node, 0, 0);
+	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);
 
 	if (register_netdev(dev) != 0) {
-		printk(KERN_ERR "registration failed for BMAC %s\n",
-		       bmac->full_name);
+		printk(KERN_ERR "BMAC: Ethernet registration failed\n");
 		goto err_out_irq2;
 	}
+
+	printk(KERN_INFO "%s: BMAC%s at", dev->name, (is_bmac_plus? "+": ""));
+	XXDEBUG((", base_addr=%#0lx", dev->base_addr));
+	printk("\n");
 	
-	bp->next_bmac = bmac_devs;
-	bmac_devs = dev;
-	return;
+	return 0;
 
 err_out_irq2:
-	free_irq(bmac->intrs[2].line, dev);
+	free_irq(bp->rx_dma_intr, dev);
 err_out_irq1:
-	free_irq(bmac->intrs[1].line, dev);
+	free_irq(bp->tx_dma_intr, dev);
 err_out_irq0:
 	free_irq(dev->irq, dev);
 err_out_iounmap_rx:
@@ -1454,15 +1397,13 @@ err_out_iounmap_tx:
 	iounmap((void *)bp->tx_dma);
 err_out_iounmap:
 	iounmap((void *)dev->base_addr);
-out4:
-	release_OF_resource(bp->node, 2);
-out3:
-	release_OF_resource(bp->node, 1);
-out2:
-	release_OF_resource(bp->node, 0);
-out1:
-	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, bp->node, 0, 0);
+out_release:
+	macio_release_resources(mdev);
+out_free:
+	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);
 	free_netdev(dev);
+
+	return -ENODEV;
 }
 
 static int bmac_open(struct net_device *dev)
@@ -1520,7 +1461,7 @@ static int bmac_close(struct net_device 
 
 	bp->opened = 0;
 	disable_irq(dev->irq);
-	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, bp->node, 0, 0);
+	pmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);
 
 	return 0;
 }
@@ -1649,6 +1590,7 @@ static void dump_dbdma(volatile struct d
 }
 #endif
 
+#if 0
 static int
 bmac_proc_info(char *buffer, char **start, off_t offset, int length)
 {
@@ -1683,46 +1625,86 @@ bmac_proc_info(char *buffer, char **star
 
 	return len;
 }
+#endif
 
+static int __devexit bmac_remove(struct macio_dev *mdev)
+{
+	struct net_device *dev = macio_get_drvdata(mdev);
+	struct bmac_data *bp = dev->priv;
 
-MODULE_AUTHOR("Randy Gobbel/Paul Mackerras");
-MODULE_DESCRIPTION("PowerMac BMAC ethernet driver.");
-MODULE_LICENSE("GPL");
+	unregister_netdev(dev);
 
-static void __exit bmac_cleanup (void)
-{
-	struct bmac_data *bp;
-	struct net_device *dev;
+       	free_irq(dev->irq, dev);
+	free_irq(bp->tx_dma_intr, dev);	
+	free_irq(bp->rx_dma_intr, dev);
 
-	if (bmac_emergency_rxbuf != NULL) {
-		kfree(bmac_emergency_rxbuf);
-		bmac_emergency_rxbuf = NULL;
-	}
+	iounmap((void *)dev->base_addr);
+	iounmap((void *)bp->tx_dma);
+	iounmap((void *)bp->rx_dma);
 
-	if (bmac_devs == 0)
-		return;
-#ifdef CONFIG_PMAC_PBOOK
-	pmu_unregister_sleep_notifier(&bmac_sleep_notifier);
+	macio_release_resources(mdev);
+
+	free_netdev(dev);
+
+	return 0;
+}
+
+static struct of_match bmac_match[] = 
+{
+	{
+	.name 		= "bmac",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH,
+	.data		= (void *)0,
+	},
+	{
+	.name 		= OF_ANY_MATCH,
+	.type		= "network",
+	.compatible	= "bmac+",
+	.data		= (void *)1,
+	},
+	{},
+};
+
+static struct macio_driver bmac_driver = 
+{
+	.name 		= "bmac",
+	.match_table	= bmac_match,
+	.probe		= bmac_probe,
+	.remove		= bmac_remove,
+#ifdef CONFIG_PM
+	.suspend	= bmac_suspend,
+	.resume		= bmac_resume,
 #endif
-	proc_net_remove("bmac");
+};
 
-	do {
-		dev = bmac_devs;
-		bp = (struct bmac_data *) dev->priv;
-		bmac_devs = bp->next_bmac;
 
-		unregister_netdev(dev);
+static int __init bmac_init(void)
+{
+	if (bmac_emergency_rxbuf == NULL) {
+		bmac_emergency_rxbuf = kmalloc(RX_BUFLEN, GFP_KERNEL);
+		if (bmac_emergency_rxbuf == NULL) {
+			printk(KERN_ERR "BMAC: can't allocate emergency RX buffer\n");
+			return -ENOMEM;
+		}
+	}
 
-		release_OF_resource(bp->node, 0);
-		release_OF_resource(bp->node, 1);
-		release_OF_resource(bp->node, 2);
-		free_irq(dev->irq, dev);
-		free_irq(bp->tx_dma_intr, dev);
-		free_irq(bp->rx_dma_intr, dev);
+	return macio_register_driver(&bmac_driver);
+}
 
-		free_netdev(dev);
-	} while (bmac_devs != NULL);
+static void __exit bmac_exit(void)
+{
+	macio_unregister_driver(&bmac_driver);
+
+	if (bmac_emergency_rxbuf != NULL) {
+		kfree(bmac_emergency_rxbuf);
+		bmac_emergency_rxbuf = NULL;
+	}
 }
 
-module_init(bmac_probe);
-module_exit(bmac_cleanup);
+MODULE_AUTHOR("Randy Gobbel/Paul Mackerras");
+MODULE_DESCRIPTION("PowerMac BMAC ethernet driver.");
+MODULE_LICENSE("GPL");
+
+module_init(bmac_init);
+module_exit(bmac_exit);
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/Kconfig linuxppc-2.5-benh/drivers/net/ibm_ocp/Kconfig
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/Kconfig	2003-06-06 20:09:22.000000000 +0000
@@ -0,0 +1,48 @@
+config IBM_OCP_ENET
+	bool "IBM on-chip ethernet"
+	depends on IBM_OCP
+
+config IBM_OCP_ENET_ERROR_MSG
+	bool "Verbose error messages"
+	depends on IBM_OCP_ENET
+	default n
+
+config IBM_OCP_ENET_RX_BUFF
+	int "Number of receive buffers"
+	depends on IBM_OCP_ENET
+	default 64
+
+config IBM_OCP_ENET_TX_BUFF
+	int "Number of transmit buffers"
+	depends on IBM_OCP_ENET
+	default 8
+
+config IBM_OCP_ENET_GAP
+	int "Frame gap"
+	depends on IBM_OCP_ENET
+	default 8
+
+config IBM_OCP_ENET_SKB_RES
+	int "Skb reserve amount"
+	depends on IBM_OCP_ENET
+	default 0
+
+config OCP_NET
+	bool
+	depends on IBM_OCP_ENET
+	default y
+
+config IBM_OCP_MAL_CNT
+	int
+	depends on IBM_OCP_ENET && ( NP405H || NP405L || 44x )
+	default 1
+
+config IBM_OCP_ZMII
+	bool
+	depends on IBM_OCP_ENET && ( NP405H || NP405L || 44x )
+	default y
+
+config CRC32
+	bool
+	depends on IBM_OCP_ENET
+	default y
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/Makefile linuxppc-2.5-benh/drivers/net/ibm_ocp/Makefile
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/Makefile	2003-06-06 20:09:22.000000000 +0000
@@ -0,0 +1,20 @@
+#
+# Makefile for the IBM 4xx on-chip  ethernet drivers
+#
+
+# Module support doesn't work yet.
+export-objs     := 
+
+obj-$(CONFIG_IBM_OCP_ENET) += ibm_ocp.o
+
+# NB! Link order matters
+
+ibm_ocp-objs := ibm_ocp_mal.o ibm_ocp_enet.o ibm_ocp_phy.o
+
+# These chips have a ZMII
+ibm_ocp-$(CONFIG_NP405L)			+= ibm_ocp_zmii.o
+ibm_ocp-$(CONFIG_NP405H)			+= ibm_ocp_zmii.o
+ibm_ocp-$(CONFIG_44x)				+= ibm_ocp_zmii.o
+
+# Only need this if you want to see additional debug messages
+ibm_ocp-$(CONFIG_IBM_OCP_ENET_ERROR_MSG)	+= ibm_ocp_debug.o
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_debug.c
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_debug.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_debug.c	2002-09-20 07:23:30.000000000 +0000
@@ -0,0 +1,264 @@
+/*
+ * ibm_ocp_debug.c
+ *
+ * This has all the debug routines that where in *_enet.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      April , 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * TODO: 
+ *
+ * Version 1.0: (04/15/02)
+ * 	initial release 
+ * 	These are all the debug routines from *_enet.c and a few new ones. 
+ * 	this was done to reduce the *_enet.c code.
+ *
+ * Version 1.1: 04/24/02
+ * 	fixed missind EMAC_DEV macros - Todd
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include "ibm_ocp_enet.h"
+#include "ibm_ocp_mal.h"
+
+int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+
+void ppc405_phy_dump(struct net_device *dev)
+{
+	unsigned long i;
+	uint data;
+
+	printk(KERN_DEBUG " Prepare for Phy dump....\n");
+	for (i = 0; i < 0x1A; i++) {
+		if (ocp_enet_mdio_read(dev, mk_mii_read(i), &data))
+			return;
+
+		printk(KERN_DEBUG "Phy reg 0x%lx ==> %4x\n", i, data);
+
+		if (i == 0x07)
+			i = 0x0f;
+	}
+}
+
+void
+ppc405_eth_desc_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int curr_slot;
+
+	printk(KERN_DEBUG "dumping the receive descriptors:  current slot is %d\n",
+	       fep->rx_slot);
+	for (curr_slot = 0; curr_slot < NUM_RX_BUFF; curr_slot++) {
+		printk(KERN_DEBUG "Desc %02d: status 0x%04x, length %3d, addr 0x%x\n",
+		       curr_slot,
+		       fep->rx_desc[curr_slot].ctrl,
+		       fep->rx_desc[curr_slot].data_len,
+		       (unsigned int) fep->rx_desc[curr_slot].data_ptr);
+	}
+}
+
+void
+ppc405_eth_emac_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	printk(KERN_DEBUG "EMAC DEBUG ********** \n");
+	printk(KERN_DEBUG "EMAC_M0  ==> 0x%x\n", in_be32(&emacp->em0mr0));
+	printk(KERN_DEBUG "EMAC_M1  ==> 0x%x\n", in_be32(&emacp->em0mr1));
+	printk(KERN_DEBUG "EMAC_TXM0==> 0x%x\n", in_be32(&emacp->em0tmr0));
+	printk(KERN_DEBUG "EMAC_TXM1==> 0x%x\n", in_be32(&emacp->em0tmr1));
+	printk(KERN_DEBUG "EMAC_RXM ==> 0x%x\n", in_be32(&emacp->em0rmr));
+	printk(KERN_DEBUG "EMAC_ISR ==> 0x%x\n", in_be32(&emacp->em0isr));
+	printk(KERN_DEBUG "EMAC_IER ==> 0x%x\n", in_be32(&emacp->em0iser));
+	printk(KERN_DEBUG "EMAC_IAH ==> 0x%x\n", in_be32(&emacp->em0iahr));
+	printk(KERN_DEBUG "EMAC_IAL ==> 0x%x\n", in_be32(&emacp->em0ialr));
+	printk(KERN_DEBUG "EMAC_VLAN_TPID_REG ==> 0x%x\n", in_be32(&emacp->em0vtpid));
+}
+
+void
+ppc405_eth_mal_dump(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_DEBUG " MAL DEBUG ********** \n");
+	printk(KERN_DEBUG " MCR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALCR));
+	printk(KERN_DEBUG " ESR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALESR));
+	printk(KERN_DEBUG " IER      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALIER));
+#ifdef CONFIG_40x
+	printk(KERN_DEBUG " DBR      ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALDBR));
+#endif				/* CONFIG_40x */
+	printk(KERN_DEBUG " TXCASR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCASR));
+	printk(KERN_DEBUG " TXCARR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCARR));
+	printk(KERN_DEBUG " TXEOBISR ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXEOBISR));
+	printk(KERN_DEBUG " TXDEIR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXDEIR));
+	printk(KERN_DEBUG " RXCASR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCASR));
+	printk(KERN_DEBUG " RXCARR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCARR));
+	printk(KERN_DEBUG " RXEOBISR ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXEOBISR));
+	printk(KERN_DEBUG " RXDEIR   ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXDEIR));
+	printk(KERN_DEBUG " TXCTP0R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP0R));
+	printk(KERN_DEBUG " TXCTP1R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP1R));
+	printk(KERN_DEBUG " TXCTP2R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP2R));
+	printk(KERN_DEBUG " TXCTP3R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALTXCTP3R));
+	printk(KERN_DEBUG " RXCTP0R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCTP0R));
+	printk(KERN_DEBUG " RXCTP1R  ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRXCTP1R));
+	printk(KERN_DEBUG " RCBS0    ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRCBS0));
+	printk(KERN_DEBUG " RCBS1    ==> 0x%x\n", 
+	       (unsigned int) get_mal_dcrn(fep->mal, DCRN_MALRCBS1));
+}
+
+void
+ppc405_serr_dump_0(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned long int mal_error, plb_error, plb_addr;
+
+	mal_error = get_mal_dcrn(fep->mal, DCRN_MALESR);
+	printk(KERN_DEBUG "ppc405_eth_serr: %s channel %ld \n",
+	       (mal_error & 0x40000000) ? "Receive" :
+	       "Transmit", (mal_error & 0x3e000000) >> 25);
+	printk(KERN_DEBUG "  -----  latched error  -----\n");
+	if (mal_error & MALESR_DE)
+		printk(KERN_DEBUG "  DE: descriptor error\n");
+	if (mal_error & MALESR_OEN)
+		printk(KERN_DEBUG
+		       "  ONE: OPB non-fullword error\n");
+	if (mal_error & MALESR_OTE)
+		printk(KERN_DEBUG "  OTE: OPB timeout error\n");
+	if (mal_error & MALESR_OSE)
+		printk(KERN_DEBUG "  OSE: OPB slave error\n");
+	
+	if (mal_error & MALESR_PEIN) {
+		plb_error = mfdcr(DCRN_PLB0_BESR);
+		printk(KERN_DEBUG
+		       "  PEIN: PLB error, PLB0_BESR is 0x%x\n",
+		       (unsigned int) plb_error);
+		plb_addr = mfdcr(DCRN_PLB0_BEAR);
+		printk(KERN_DEBUG
+		       "  PEIN: PLB error, PLB0_BEAR is 0x%x\n",
+		       (unsigned int) plb_addr);
+	}
+}
+
+void
+ppc405_serr_dump_1(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int mal_error = get_mal_dcrn(fep->mal, DCRN_MALESR);
+
+	printk(KERN_DEBUG "  -----  cumulative errors  -----\n");
+	if (mal_error & MALESR_DEI)
+		printk(KERN_DEBUG
+		       "  DEI: descriptor error interrupt\n");
+	if (mal_error & MALESR_ONEI)
+		printk(KERN_DEBUG
+		       "  OPB non-fullword error interrupt\n");
+	if (mal_error & MALESR_OTEI)
+		printk(KERN_DEBUG
+		       "  OTEI: timeout error interrupt\n");
+	if (mal_error & MALESR_OSEI)
+		printk(KERN_DEBUG
+		       "  OSEI: slave error interrupt\n");
+	if (mal_error & MALESR_PBEI)
+		printk(KERN_DEBUG
+		       "  PBEI: PLB bus error interrupt\n");
+}
+
+void
+ppc405_bl_mac_eth_dump(struct net_device *dev, int em0isr)
+{
+	printk(KERN_DEBUG "%s: on-chip ethernet error:\n", dev->name);
+	
+	if (em0isr & EMAC_ISR_OVR)
+		printk(KERN_DEBUG "  OVR: overrun\n");
+	if (em0isr & EMAC_ISR_PP)
+		printk(KERN_DEBUG "  PP: control pause packet\n");
+	if (em0isr & EMAC_ISR_BP)
+		printk(KERN_DEBUG "  BP: packet error\n");
+	if (em0isr & EMAC_ISR_RP)
+		printk(KERN_DEBUG "  RP: runt packet\n");
+	if (em0isr & EMAC_ISR_SE)
+		printk(KERN_DEBUG "  SE: short event\n");
+	if (em0isr & EMAC_ISR_ALE)
+		printk(KERN_DEBUG
+		       "  ALE: odd number of nibbles in packet\n");
+	if (em0isr & EMAC_ISR_BFCS)
+		printk(KERN_DEBUG "  BFCS: bad FCS\n");
+	if (em0isr & EMAC_ISR_PTLE)
+		printk(KERN_DEBUG "  PTLE: oversized packet\n");
+	if (em0isr & EMAC_ISR_ORE)
+		printk(KERN_DEBUG
+		       "  ORE: packet length field > max allowed LLC\n");
+	if (em0isr & EMAC_ISR_IRE)
+		printk(KERN_DEBUG "  IRE: In Range error\n");
+	if (em0isr & EMAC_ISR_DBDM)
+		printk(KERN_DEBUG "  DBDM: xmit error or SQE\n");
+	if (em0isr & EMAC_ISR_DB0)
+		printk(KERN_DEBUG
+		       "  DB0: xmit error or SQE on TX channel 0\n");
+	if (em0isr & EMAC_ISR_SE0)
+		printk(KERN_DEBUG
+		       "  SE0: Signal Quality Error test failure from TX channel 0\n");
+	if (em0isr & EMAC_ISR_TE0)
+		printk(KERN_DEBUG "  TE0: xmit channel 0 aborted\n");
+	if (em0isr & EMAC_ISR_DB1)
+		printk(KERN_DEBUG
+		       "  DB1: xmit error or SQE on TX channel \n");
+	if (em0isr & EMAC_ISR_SE1)
+		printk(KERN_DEBUG
+		       "  SE1: Signal Quality Error test failure from TX channel 1\n");
+	if (em0isr & EMAC_ISR_TE1)
+		printk(KERN_DEBUG "  TE1: xmit channel 1 aborted\n");
+	if (em0isr & EMAC_ISR_MOS)
+		printk(KERN_DEBUG "  MOS\n");
+	if (em0isr & EMAC_ISR_MOF)
+		printk(KERN_DEBUG "  MOF\n");
+	
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+}
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_emac.h
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_emac.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_emac.h	2003-07-19 01:01:21.000000000 +0000
@@ -0,0 +1,192 @@
+/*
+ * ibm_ocp_emac.h
+ *
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      June, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Version: 1.0: 06/02/02 - armin
+ *  	pulled all emac defined out od enet.h
+ *
+ */
+
+#ifndef _IBM_OCP_EMAC_H_
+#define _IBM_OCP_EMAC_H_
+/* General defines needed for the driver */
+
+/* MODE REG 0 */
+#define EMAC_M0_RXI			0x80000000
+#define EMAC_M0_TXI			0x40000000
+#define EMAC_M0_SRST			0x20000000
+#define EMAC_M0_TXE			0x10000000
+#define EMAC_M0_RXE			0x08000000
+#define EMAC_M0_WKE			0x04000000
+
+/* MODE Reg 1 */
+#define EMAC_M1_FDE			0x80000000
+#define EMAC_M1_ILE			0x40000000
+#define EMAC_M1_VLE			0x20000000
+#define EMAC_M1_EIFC			0x10000000
+#define EMAC_M1_APP			0x08000000
+#define EMAC_M1_AEMI			0x02000000
+#define EMAC_M1_IST			0x01000000
+#define EMAC_M1_MF_1000MBPS		0x00800000	/* 0's for 10MBPS */
+#define EMAC_M1_MF_100MBPS		0x00400000
+#ifdef CONFIG_IBM_EMAC4
+#define EMAC_M1_RFS_16K                 0x00280000	/* 000 for 512 byte */
+#define EMAC_M1_RFS_8K                  0x00200000
+#define EMAC_M1_RFS_4K                  0x00180000
+#define EMAC_M1_RFS_2K                  0x00100000
+#define EMAC_M1_RFS_1K                  0x00080000
+#define EMAC_M1_TX_FIFO_16K             0x00050000	/* 0's for 512 byte */
+#define EMAC_M1_TX_FIFO_8K              0x00040000
+#define EMAC_M1_TX_FIFO_4K              0x00030000
+#define EMAC_M1_TX_FIFO_2K              0x00020000
+#define EMAC_M1_TX_FIFO_1K              0x00010000
+#define EMAC_M1_TX_TR                   0x00008000
+#define EMAC_M1_TX_MWSW                 0x00001000	/* 0 wait for status */
+#define EMAC_M1_JUMBO_ENABLE            0x00000800	/* Upt to 9Kr status */
+#define EMAC_M1_OPB_CLK_66              0x00000010	/* 66Mhz */
+#define EMAC_M1_OPB_CLK_83              0x00000008	/* 83hz */
+#define EMAC_M1_OPB_CLK_100             0x00000018	/* 100Mhz */
+#define EMAC_M1_OPB_CLK_100P            0x00000020	/* 100Mhz+ */
+#else
+#define EMAC_M1_RFS_4K			0x00300000	/* ~4k for 512 byte */
+#define EMAC_M1_RFS_2K			0x00200000
+#define EMAC_M1_RFS_1K			0x00100000
+#define EMAC_M1_TX_FIFO_2K		0x00080000	/* 0 for 512 byte */
+#define EMAC_M1_TX_FIFO_1K		0x00040000
+#define EMAC_M1_TR0_DEPEND		0x00010000	/* 0 for one packet */
+#define EMAC_M1_TR0_MULTI		0x00008000
+#define EMAC_M1_TR1_DEPEND		0x00004000
+#define EMAC_M1_TR1_MULTI		0x00002000
+#define EMAC_M1_JUMBO_ENABLE		0x00001000
+#endif /* CONFIG_IBM_EMAC4 */
+
+/* Transmit Mode Register 0 */
+#define EMAC_TXM0_GNP0			0x80000000
+#define EMAC_TXM0_GNP1			0x40000000
+#define EMAC_TXM0_GNPD			0x20000000
+#define EMAC_TXM0_FC			0x10000000
+
+/* Receive Mode Register */
+#define EMAC_RMR_SP			0x80000000
+#define EMAC_RMR_SFCS			0x40000000
+#define EMAC_RMR_ARRP			0x20000000
+#define EMAC_RMR_ARP			0x10000000
+#define EMAC_RMR_AROP			0x08000000
+#define EMAC_RMR_ARPI			0x04000000
+#define EMAC_RMR_PPP			0x02000000
+#define EMAC_RMR_PME			0x01000000
+#define EMAC_RMR_PMME			0x00800000
+#define EMAC_RMR_IAE			0x00400000
+#define EMAC_RMR_MIAE			0x00200000
+#define EMAC_RMR_BAE			0x00100000
+#define EMAC_RMR_MAE			0x00080000
+
+/* Interrupt Status & enable Regs */
+#define EMAC_ISR_OVR			0x02000000
+#define EMAC_ISR_PP			0x01000000
+#define EMAC_ISR_BP			0x00800000
+#define EMAC_ISR_RP			0x00400000
+#define EMAC_ISR_SE			0x00200000
+#define EMAC_ISR_ALE			0x00100000
+#define EMAC_ISR_BFCS			0x00080000
+#define EMAC_ISR_PTLE			0x00040000
+#define EMAC_ISR_ORE			0x00020000
+#define EMAC_ISR_IRE			0x00010000
+#define EMAC_ISR_DBDM			0x00000200
+#define EMAC_ISR_DB0			0x00000100
+#define EMAC_ISR_SE0			0x00000080
+#define EMAC_ISR_TE0			0x00000040
+#define EMAC_ISR_DB1			0x00000020
+#define EMAC_ISR_SE1			0x00000010
+#define EMAC_ISR_TE1			0x00000008
+#define EMAC_ISR_MOS			0x00000002
+#define EMAC_ISR_MOF			0x00000001
+
+/* STA CONTROL REG */
+#define EMAC_STACR_OC			0x00008000
+#define EMAC_STACR_PHYE			0x00004000
+#define EMAC_STACR_WRITE		0x00002000
+#define EMAC_STACR_READ			0x00001000
+#define EMAC_STACR_CLK_83MHZ		0x00000800	/* 0's for 50Mhz */
+#define EMAC_STACR_CLK_66MHZ		0x00000400
+#define EMAC_STACR_CLK_100MHZ		0x00000C00
+
+/* Transmit Request Threshold Register */
+#define EMAC_TRTR_1600			0x18000000	/* 0's for 64 Bytes */
+#define EMAC_TRTR_256			0x03000000
+#define EMAC_TRTR_192			0x10000000
+#define EMAC_TRTR_128			0x01000000
+
+
+#define EMAC_TX_CTRL_GFCS		0x0200
+#define EMAC_TX_CTRL_GP			0x0100
+#define EMAC_TX_CTRL_ISA		0x0080
+#define EMAC_TX_CTRL_RSA		0x0040
+#define EMAC_TX_CTRL_IVT		0x0020
+#define EMAC_TX_CTRL_RVT		0x0010
+
+#define EMAC_TX_CTRL_DFLT ( \
+	MAL_TX_CTRL_LAST | MAL_TX_CTRL_READY | MAL_TX_CTRL_INTR | \
+	EMAC_TX_CTRL_GFCS | EMAC_TX_CTRL_GP )
+
+/* madmal transmit status / Control bits */
+#define EMAC_TX_ST_BFCS			0x0200
+#define EMAC_TX_ST_BPP			0x0100
+#define EMAC_TX_ST_LCS			0x0080
+#define EMAC_TX_ST_ED			0x0040
+#define EMAC_TX_ST_EC			0x0020
+#define EMAC_TX_ST_LC			0x0010
+#define EMAC_TX_ST_MC			0x0008
+#define EMAC_TX_ST_SC			0x0004
+#define EMAC_TX_ST_UR			0x0002
+#define EMAC_TX_ST_SQE			0x0001
+
+/* madmal receive status / Control bits */
+#define EMAC_RX_ST_OE			0x0200
+#define EMAC_RX_ST_PP			0x0100
+#define EMAC_RX_ST_BP			0x0080
+#define EMAC_RX_ST_RP			0x0040
+#define EMAC_RX_ST_SE			0x0020
+#define EMAC_RX_ST_AE			0x0010
+#define EMAC_RX_ST_BFCS			0x0008
+#define EMAC_RX_ST_PTL			0x0004
+#define EMAC_RX_ST_ORE			0x0002
+#define EMAC_RX_ST_IRE			0x0001
+#define EMAC_BAD_RX_PACKET		0x02ff
+
+/* all the errors we care about */
+#define EMAC_RX_ERRORS			0x03FF
+
+/* phy seed setup */
+#define AUTO				99
+#define _100BASET			100
+#define _10BASET			10
+#define HALF				22
+#define FULL				44
+
+#endif
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_enet.c
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_enet.c	2003-07-19 01:01:21.000000000 +0000
@@ -0,0 +1,975 @@
+/*
+ * ibm_ocp_enet.c
+ *
+ * Ethernet driver for the built in ethernet on the IBM 4xx PowerPC
+ * processors.
+ * 
+ * Added support for multiple PHY's and use of MII for PHY control
+ * configurable and bug fixes.
+ *
+ * Based on  the Fast Ethernet Controller (FEC) driver for
+ * Motorola MPC8xx and other contributions, see driver for contributers.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ *      Original driver
+ * 	Author: Johnnie Peters
+ *	jpeters@mvista.com
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <asm/ocp.h>
+#include <asm/processor.h>	/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/crc32.h>
+
+#include "ocp_zmii.h"
+#include "ibm_ocp_enet.h"
+#include "ibm_ocp_mal.h"
+
+/* Forward declarations of some structures to support different PHYs */
+
+static int emac_open(struct net_device *);
+static int emac_start_xmit(struct sk_buff *, struct net_device *);
+static struct net_device_stats *ppc405_enet_stats(struct net_device *);
+static int ppc405_enet_close(struct net_device *);
+static void ppc405_enet_set_multicast_list(struct net_device *);
+
+static irqreturn_t ppc405_eth_wakeup(int, void *, struct pt_regs *);
+static void ppc405_eth_txeob_dev(void *, u32);
+static void ppc405_eth_rxeob_dev(void *, u32);
+static void ppc405_eth_txde_dev(void *, u32);
+static void ppc405_eth_rxde_dev(void *, u32);
+static irqreturn_t ppc405_eth_mac(int, void *, struct pt_regs *);
+static void ppc405_rx_fill(struct net_device *, int);
+static int ppc405_rx_clean(struct net_device *);
+
+int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+int ocp_enet_mdio_write(struct net_device *dev, int reg);
+int ocp_enet_ioctl(struct net_device *, struct ifreq *rq, int cmd);
+
+static struct net_device *emac_dev[EMAC_NUMS];
+
+mii_list_t mii_cmds[NMII];
+
+int emac_max;
+
+static int skb_res = SKB_RES;
+MODULE_PARM(skb_res, "i");
+MODULE_PARM_DESC(skb_res, "Amount of data to reserve on skb buffs\n"
+		 "The 405 handles a misaligned IP header fine but\n"
+		 "this can help if you are routing to a tunnel or a\n"
+		 "device that needs aligned data");
+
+
+static void disable_mal_chan(struct ocp_enet_private *fep)
+{
+	mal_disable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	mal_disable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static void enable_mal_chan(struct ocp_enet_private *fep)
+{
+	mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	mal_enable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static void init_rings(struct net_device *dev)
+{
+	struct ocp_enet_private *ep = dev->priv;
+	int loop;
+
+	ep->tx_desc = (struct mal_descriptor *) ((char *) ep->mal->tx_virt_addr +
+				      (ep->mal_tx_chan * MAL_DT_ALIGN));
+	ep->rx_desc = (struct mal_descriptor *) ((char *) ep->mal->rx_virt_addr +
+				      (ep->mal_rx_chan * MAL_DT_ALIGN));
+
+	/* Fill in the transmit descriptor ring. */
+	for (loop = 0; loop < NUM_TX_BUFF; loop++) {
+		ep->tx_skb[loop] = (struct sk_buff *) NULL;
+		ep->tx_desc[loop].ctrl = 0;
+		ep->tx_desc[loop].data_len = 0;
+		ep->tx_desc[loop].data_ptr = NULL;
+	}
+	ep->tx_desc[loop - 1].ctrl |= MAL_TX_CTRL_WRAP;
+
+	/* Format the receive descriptor ring. */
+	ep->rx_slot = 0;
+	ppc405_rx_fill(dev, 0);
+	if (ep->rx_slot != 0) {
+		printk(KERN_ERR
+		       "%s: Not enough mem for RxChain durning Open?\n",
+		       dev->name);
+		/*We couldn't fill the ring at startup?
+		 *We could clean up and fail to open but right now we will try to
+		 *carry on. It may be a sign of a bad NUM_RX_BUFF value
+		 */
+	}
+
+	ep->tx_cnt = 0;
+	ep->tx_slot = 0;
+	ep->ack_slot = 0;
+}
+
+static int emac_open(struct net_device *dev)
+{
+	unsigned long mode_reg;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+	unsigned long emac_ier;
+
+	if (!fep->link) {
+		printk(KERN_NOTICE "%s: Cannot open interface without phy\n",
+		       dev->name);
+		return -ENODEV;
+	}
+	disable_mal_chan(fep);
+	mal_set_rcbs(fep->mal, fep->mal_rx_chan, DESC_BUF_SIZE_REG);
+
+	/* set the high address */
+	out_be32(&emacp->em0iahr, (dev->dev_addr[0] << 8) | dev->dev_addr[1]);
+
+	/* set the low address */
+	out_be32(&emacp->em0ialr,
+		 (dev->dev_addr[2] << 24) | (dev->dev_addr[3] << 16)
+		 | (dev->dev_addr[4] << 8) | dev->dev_addr[5]);
+
+	mii_do_cmd(dev, fep->phy->ack_int);
+	mii_do_cmd(dev, fep->phy->config);
+	process_mii_queue(dev);
+
+	mii_display_status(dev);
+
+	/* set receive fifo to 4k and tx fifo to 2k */
+	mode_reg = EMAC_M1_RFS_4K | EMAC_M1_TX_FIFO_2K | EMAC_M1_APP;
+
+	/* set speed (default is 10Mb) */
+	if (fep->phy_speed == _100BASET) {
+		mode_reg = mode_reg | EMAC_M1_MF_100MBPS;
+		zmii_set_port_speed(100, dev);
+	} else {
+		mode_reg = mode_reg & ~EMAC_M1_MF_100MBPS;	/* 10 MBPS */
+		zmii_set_port_speed(10, dev);
+	}
+
+	if (fep->phy_duplex == FULL)
+		mode_reg = mode_reg | EMAC_M1_FDE | EMAC_M1_EIFC | EMAC_M1_IST;
+	else
+		mode_reg = mode_reg & ~(EMAC_M1_FDE | EMAC_M1_EIFC | EMAC_M1_ILE);	/* half duplex */
+
+#ifdef CONFIG_IBM_EMAC4
+	/* enable broadcast and individual address */
+	out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE | 0x00000007);
+	/* set transmit request threshold register */
+	out_be32(&emacp->em0trtr, EMAC_TRTR_256);
+	/* mode register settings */
+	mode_reg |= EMAC_M1_OPB_CLK_66 | 0x00009000;
+#else
+	out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE);
+	out_be32(&emacp->em0trtr, EMAC_TRTR_1600);
+	mode_reg |= EMAC_M1_TR0_MULTI;
+#endif
+
+	out_be32(&emacp->em0mr1, mode_reg);
+
+#if defined(CONFIG_440GP)
+	/* set receive low/high water mark register */
+	out_be32(&emacp->em0rwmr, 0x80009000);
+	out_be32(&emacp->em0tmr1, 0xf8640000);
+#elif defined(CONFIG_440GX)
+	out_be32(&emacp->em0rwmr, 0x1000a200);
+	out_be32(&emacp->em0tmr0, 0x00000007);
+	out_be32(&emacp->em0tmr1, 0x88810000);
+#else
+	out_be32(&emacp->em0rwmr, 0x0f002000);
+#endif /* CONFIG_440GP */
+
+	/* set frame gap */
+	out_be32(&emacp->em0ipgvr, CONFIG_IBM_OCP_ENET_GAP);
+
+	emac_ier = EMAC_ISR_PP | EMAC_ISR_BP | EMAC_ISR_RP |
+	    EMAC_ISR_SE | EMAC_ISR_PTLE | EMAC_ISR_ALE |
+	    EMAC_ISR_BFCS | EMAC_ISR_ORE | EMAC_ISR_IRE;
+
+	out_be32(&emacp->em0iser, emac_ier);
+
+	/* FIXME: check failures */
+	request_irq(dev->irq, ppc405_eth_mac, 0, dev->name, dev);
+	request_irq(fep->wol_irq, ppc405_eth_wakeup, SA_SHIRQ, "EMAC WOL", dev);
+
+	/* init buffer descriptors rings */
+	init_rings(dev);
+
+	/* enable all MAL transmit and receive channels */
+	enable_mal_chan(fep);
+
+	/* set transmit and receive enable */
+	out_be32(&emacp->em0mr0, EMAC_M0_TXE | EMAC_M0_RXE);
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int
+emac_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	unsigned short ctrl;
+	unsigned long flags;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	save_flags(flags);
+	cli();
+	if (netif_queue_stopped(dev) || (fep->tx_cnt == NUM_TX_BUFF)) {
+
+		fep->stats.tx_dropped++;
+		restore_flags(flags);
+		return -EBUSY;
+	}
+
+	if (++fep->tx_cnt == NUM_TX_BUFF)
+		netif_stop_queue(dev);
+
+	/* Store the skb buffer for later ack by the transmit end of buffer
+	 * interrupt.
+	 */
+	fep->tx_skb[fep->tx_slot] = skb;
+	consistent_sync((void *) skb->data, skb->len, PCI_DMA_TODEVICE);
+
+	ctrl = EMAC_TX_CTRL_DFLT;
+	if ((NUM_TX_BUFF - 1) == fep->tx_slot)
+		ctrl |= MAL_TX_CTRL_WRAP;
+
+	fep->tx_desc[fep->tx_slot].data_ptr = (char *) virt_to_phys(skb->data);
+	fep->tx_desc[fep->tx_slot].data_len = (short) skb->len;
+	fep->tx_desc[fep->tx_slot].ctrl = ctrl;
+
+	/* Send the packet out. */
+#ifdef CONFIG_IBM_EMAC4
+	out_be32(&emacp->em0tmr0, EMAC_TXM0_GNP0 | 0x00000007);
+#else
+	out_be32(&emacp->em0tmr0, EMAC_TXM0_GNP0);
+#endif
+
+	if (++fep->tx_slot == NUM_TX_BUFF)
+		fep->tx_slot = 0;
+
+	fep->stats.tx_packets++;
+	fep->stats.tx_bytes += skb->len;
+
+	restore_flags(flags);
+
+	return 0;
+}
+
+static int
+ppc405_enet_close(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	disable_mal_chan(fep);
+
+	out_be32(&emacp->em0mr0, EMAC_M0_SRST);
+	udelay(10);
+
+	if (emacp->em0mr0 & EMAC_M0_SRST) {
+		/*not sure what to do here hopefully it clears before another open */
+		printk(KERN_ERR "%s: Phy SoftReset didn't clear, no link?\n",
+		       dev->name);
+	}
+
+	/* Free the irq's */
+	free_irq(dev->irq, dev);
+	free_irq(fep->wol_irq, dev);
+
+	free_phy(dev);
+	return 0;
+}
+
+static void
+ppc405_enet_set_multicast_list(struct net_device *dev)
+{
+	struct ocp_enet_private *ep = dev->priv;
+	volatile emac_t *emacp = ep->emacp;
+
+	if (dev->flags & IFF_PROMISC) {
+
+		/* If promiscuous mode is set then we do not need anything else */
+		out_be32(&emacp->em0rmr, EMAC_RMR_PME);
+
+	} else if (dev->flags & IFF_ALLMULTI || 32 < dev->mc_count) {
+
+		/* Must be setting up to use multicast.  Now check for promiscuous
+		 * multicast
+		 */
+		out_be32(&emacp->em0rmr,
+			 EMAC_RMR_IAE | EMAC_RMR_BAE | EMAC_RMR_PMME);
+	} else if (dev->flags & IFF_MULTICAST && 0 < dev->mc_count) {
+
+		unsigned short em0gaht[4] = { 0, 0, 0, 0 };
+		struct dev_mc_list *dmi;
+
+		/* Need to hash on the multicast address. */
+		for (dmi = dev->mc_list; dmi; dmi = dmi->next) {
+			unsigned long mc_crc;
+			unsigned int bit_number;
+
+			mc_crc = ether_crc(6, (char *) dmi->dmi_addr);
+			bit_number = 63 - (mc_crc >> 26);	/* MSB: 0 LSB: 63 */
+			em0gaht[bit_number >> 4] |=
+			    0x8000 >> (bit_number & 0x0f);
+		}
+		emacp->em0gaht1 = em0gaht[0];
+		emacp->em0gaht2 = em0gaht[1];
+		emacp->em0gaht3 = em0gaht[2];
+		emacp->em0gaht4 = em0gaht[3];
+
+		/* Turn on multicast addressing */
+		out_be32(&emacp->em0rmr,
+			 EMAC_RMR_IAE | EMAC_RMR_BAE | EMAC_RMR_MAE);
+
+	} else {
+		/* If multicast mode is not set then we are 
+		 * turning it off at this point 
+		 */
+		out_be32(&emacp->em0rmr, EMAC_RMR_IAE | EMAC_RMR_BAE);
+
+	}
+
+	return;
+}
+
+static struct net_device_stats *
+ppc405_enet_stats(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	return &fep->stats;
+}
+
+static void  __devexit ocp_emac_remove_one (struct ocp_device *pdev)
+{
+	struct net_device *dev = ocp_get_drvdata(pdev);
+	printk("removing net dev \n");
+	ocp_force_power_off(pdev);
+	unregister_netdev(dev);
+}
+
+struct mal_commac_ops emac_commac_ops = {
+	.txeob = &ppc405_eth_txeob_dev,
+	.txde = &ppc405_eth_txde_dev,
+	.rxeob = &ppc405_eth_rxeob_dev,
+	.rxde = &ppc405_eth_rxde_dev,
+};
+
+static int __devinit ocp_emac_probe(struct ocp_device *pdev)
+{
+	int err = 0;
+	int i;
+	struct net_device *dev;
+	struct ocp_enet_private *ep;
+	int emac_num = pdev->num;
+
+	dev = init_etherdev(NULL, sizeof (struct ocp_enet_private));
+	if (dev == NULL) {
+		printk(KERN_ERR
+		       "ibm_ocp_enet: Could not allocate ethernet device.\n");
+		return -1;
+	}
+
+	ep = dev->priv;
+	ep->ocpdev = pdev;
+	ocp_set_drvdata(pdev, dev);
+
+	ep->mal = &mal_table[0];
+	/* FIXME: need a better way of determining these */
+#ifdef CONFIG_440GX
+	ep->mal_tx_chan = emac_num;
+#else
+	ep->mal_tx_chan = emac_num * 2;
+#endif
+	ep->mal_rx_chan = emac_num;
+
+	ep->emacp = __ioremap(pdev->paddr, sizeof (emac_t), _PAGE_NO_CACHE);
+
+	zmii_init(ZMII_AUTO, dev);
+	find_phy(dev);
+	if (!ep->phy)
+		return -1;
+
+	ep->link = 1;
+	dev->irq = pdev->irq;
+	ep->wol_irq = BL_MAC_WOL; /* FIXME: need a better way to get this */
+
+	/* read the MAC Address */
+	for (i = 0; i < 6; i++)
+		dev->dev_addr[i] = __res.BD_EMAC_ADDR(emac_num, i);	/* Marco to disques array */
+
+	ep->commac.ops = &emac_commac_ops;
+	ep->commac.dev = dev;
+	ep->commac.tx_chan_mask = MAL_CHAN_MASK(ep->mal_tx_chan);
+	ep->commac.rx_chan_mask = MAL_CHAN_MASK(ep->mal_rx_chan);
+	err = mal_register_commac(ep->mal, &ep->commac);
+	if (err)
+		return err; /* FIXME: cleanup needed? */
+	
+
+	/* Fill in the driver function table */
+	dev->open = &emac_open;
+	dev->hard_start_xmit = &emac_start_xmit;
+	dev->stop = &ppc405_enet_close;
+	dev->get_stats = &ppc405_enet_stats;
+	dev->set_multicast_list = &ppc405_enet_set_multicast_list;
+	dev->do_ioctl = &ocp_enet_ioctl;
+	emac_dev[emac_num] = dev;
+
+	/* Reset the EMAC */
+	out_be32(&ep->emacp->em0mr0, EMAC_M0_SRST);
+	udelay(10);
+
+	if (in_be32(&ep->emacp->em0mr0) & EMAC_M0_SRST) {
+		printk(KERN_NOTICE "%s: Cannot open interface without Link\n",
+		       dev->name);
+		return -1;
+	}
+
+	printk("IBM EMAC: %s: ", dev->name);
+	printk("MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
+			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+
+	return 0;
+
+}
+
+static struct ocp_device_id ocp_emac_id_tbl[] __devinitdata = {
+	{OCP_VENDOR_IBM,OCP_FUNC_EMAC},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(ocp,ocp_emac_id_tbl );
+
+static struct ocp_driver ocp_emac_driver = {
+	.name		= "ocp_emac",
+	.id_table	= ocp_emac_id_tbl,
+	.probe		= ocp_emac_probe,
+	.remove		= __devexit_p(ocp_emac_remove_one),
+#if defined(CONFIG_PM)
+	.suspend	= ocp_emac_suspend,
+	.resume		= ocp_emac_resume,
+#endif /* CONFIG_PM */
+};
+
+static int __init
+init_ppc405_enet(void)
+{
+	int i;
+
+	for (i = 0; i < NMII - 1; i++)
+		mii_cmds[i].mii_next = &mii_cmds[i + 1];
+	mii_free = mii_cmds;
+
+	return ocp_module_init(&ocp_emac_driver);
+}
+
+/*
+ * int ocp_enet_mdio_read()
+ *
+ * Description:
+ *   This routine reads from a specified register on a PHY over the MII
+ *   Management Interface.
+ *
+ * Input(s):
+ *   phy    - The address of the PHY to read from. May be 0 through 31.
+ *   reg    - The PHY register to read. May be 0 through 31.
+ *   *value - Storage for the value to read from the PHY register.
+ *
+ * Output(s):
+ *   *value - The value read from the PHY register.
+ *
+ * Returns:
+ *   0 if OK, otherwise -1 on error.
+ *
+ */
+int
+ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value)
+{
+	register int i;
+	uint32_t stacr;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	/* Wait for data transfer complete bit */
+	zmii_enable_port(dev);
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if (emacp->em0stacr & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);	/* changed to 2 with new scheme -armin */
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout #1!\n");
+		return -1;
+	}
+
+	/* Clear the speed bits and make a read request to the PHY */
+
+	stacr = reg | ((fep->phy_addr & 0x1F) << 5);
+
+	out_be32(&emacp->em0stacr, stacr);
+	stacr = in_be32(&emacp->em0stacr);
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if ((stacr = in_be32(&emacp->em0stacr)) & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);
+	}
+	if ((stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout #2!\n");
+		return -1;
+	}
+
+	/* Check for a read error */
+	if (stacr & EMAC_STACR_PHYE) {
+		return -1;
+	}
+	*value = (stacr >> 16);
+	return 0;
+}
+
+/*
+ * int ocp_enet_mdio_write()
+ *
+ * Description:
+ *   This routine reads from a specified register on a PHY over the MII
+ *   Management Interface.
+ *
+ * Input(s):
+ *   phy    - The address of the PHY to read from. May be 0 through 31.
+ *   reg    - The PHY register to read. May be 0 through 31.
+ *
+ * Output(s):
+ *   value - The value writing to the PHY register.
+ *
+ * Returns:
+ *   0 if OK, otherwise -1 on error.
+ *
+ */
+int
+ocp_enet_mdio_write(struct net_device *dev, int reg)
+{
+	register int i = 0;
+	uint32_t stacr;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	zmii_enable_port(dev);
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if (emacp->em0stacr & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);	/* changed to 2 with new scheme -armin */
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout!\n");
+		return -1;
+	}
+
+	/* Clear the speed bits and make a read request to the PHY */
+
+	stacr = reg | ((fep->phy_addr & 0x1F) << 5);
+	out_be32(&emacp->em0stacr, stacr);
+
+	/* Wait for data transfer complete bit */
+	for (i = 0; i < OCP_RESET_DELAY; ++i) {
+		if ((stacr = emacp->em0stacr) & EMAC_STACR_OC)
+			break;
+		udelay(MDIO_DELAY);
+	}
+	if ((emacp->em0stacr & EMAC_STACR_OC) == 0) {
+		printk("OCP Reset timeout!\n");
+		return -1;
+	}
+
+	/* Check for a read error */
+	if ((stacr & EMAC_STACR_PHYE) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * int ocp_enet_ioctl()
+ *
+ * Description:
+ *   This routine performs the specified I/O control command on the
+ *   specified net device.
+ *
+ * Input(s):
+ *   *dev - Pointer to the device structure for this driver.
+ *   *rq  - Pointer to data to be written and/or storage for return data.
+ *    cmd - I/O control command to perform.
+ *
+ *
+ * Output(s):
+ *   *rq  - If OK, pointer to return data for a read command.
+ *
+ * Returns:
+ *   0 if OK, otherwise an error number on error.
+ *
+ */
+int
+ocp_enet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	uint *data = (uint *) & rq->ifr_data;
+
+	switch (cmd) {
+
+	case SIOCDEVPRIVATE:
+		data[0] = fep->phy_addr;
+	 /*FALLTHRU*/ case SIOCDEVPRIVATE + 1:
+		if (ocp_enet_mdio_read(dev, mk_mii_read(data[1]), &data[3]) < 0)
+			return -EIO;
+
+		return 0;
+
+	case SIOCDEVPRIVATE + 2:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		if (ocp_enet_mdio_write(dev, mk_mii_write(data[1], data[2])) <
+		    0)
+			return -EIO;
+
+		return 0;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static irqreturn_t
+ppc405_eth_wakeup(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	/* On Linux the 405 ethernet will always be active if configured
+	 * in.  This interrupt should never occur.
+	 */
+	printk(KERN_INFO "IBM EMAC: interrupt ppc405_eth_wakeup\n");
+	return IRQ_HANDLED;
+}
+
+
+static void ppc405_eth_txeob_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	while (fep->tx_cnt &&
+		!(fep->tx_desc[fep->ack_slot].ctrl & MAL_TX_CTRL_READY)) {
+
+		/* Tell the system the transmit completed. */
+		dev_kfree_skb_irq(fep->tx_skb[fep->ack_slot]);
+
+		if (fep->tx_desc[fep->ack_slot].ctrl &
+		    (EMAC_TX_ST_EC | EMAC_TX_ST_MC | EMAC_TX_ST_SC))
+			fep->stats.collisions++;
+
+		fep->tx_skb[fep->ack_slot] = (struct sk_buff *) NULL;
+		if (++fep->ack_slot == NUM_TX_BUFF)
+			fep->ack_slot = 0;
+
+		fep->tx_cnt--;
+
+		netif_wake_queue(dev);
+	}
+
+	return;
+}
+
+/*
+  Fill/Re-fill the rx chain with valid ctrl/ptrs.
+  This function will fill from rx_slot up to the parm end.
+  So to completely fill the chain pre-set rx_slot to 0 and
+  pass in an end of 0.
+ */
+static void
+ppc405_rx_fill(struct net_device *dev, int end)
+{
+	int i;
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned char *ptr;
+
+	i = fep->rx_slot;
+	do {
+		if (fep->rx_skb[i] != NULL) {
+			/*We will trust the skb is still in a good state */
+			ptr = (char *) virt_to_phys(fep->rx_skb[i]->data);
+		} else {
+
+			fep->rx_skb[i] =
+			    dev_alloc_skb(DESC_RX_BUF_SIZE + skb_res);
+
+			if (fep->rx_skb[i] == NULL) {
+				/* Keep rx_slot here, the next time clean/fill is called
+				 * we will try again before the MAL wraps back here
+				 * If the MAL tries to use this descriptor with
+				 * the EMPTY bit off it will cause the
+				 * rxde interrupt.  That is where we will
+				 * try again to allocate an sk_buff.
+				 */
+				break;
+
+			}
+
+			if (skb_res)
+				skb_reserve(fep->rx_skb[i], skb_res);
+
+			consistent_sync((void *) fep->rx_skb[i]->
+					data, DESC_RX_BUF_SIZE,
+					PCI_DMA_BIDIRECTIONAL);
+			ptr = (char *) virt_to_phys(fep->rx_skb[i]->data);
+		}
+		fep->rx_desc[i].ctrl = MAL_RX_CTRL_EMPTY | MAL_RX_CTRL_INTR |	/*could be smarter about this to avoid ints at high loads */
+		    (i == (NUM_RX_BUFF - 1) ? MAL_RX_CTRL_WRAP : 0);
+
+		fep->rx_desc[i].data_ptr = ptr;
+		/*
+		   * 440GP uses the previously reserved bits in the
+		   * data_len to encode the upper 4-bits of the buffer
+		   * physical address (ERPN). Initialize these.
+		 */
+		fep->rx_desc[i].data_len = 0;
+	} while ((i = (i + 1) % NUM_RX_BUFF) != end);
+
+	fep->rx_slot = i;
+}
+
+static int
+ppc405_rx_clean(struct net_device *dev)
+{
+	int i;
+	int error, frame_length;
+	struct ocp_enet_private *fep = dev->priv;
+	unsigned short ctrl;
+
+	i = fep->rx_slot;
+
+	do {
+		if (fep->rx_skb[i] == NULL)
+			continue;	/*we have already handled the packet but haved failed to alloc */
+		/* 
+		   since rx_desc is in uncached mem we don't keep reading it directly 
+		   we pull out a local copy of ctrl and do the checks on the copy.
+		 */
+		ctrl = fep->rx_desc[i].ctrl;
+		if (ctrl & MAL_RX_CTRL_EMPTY)
+			break;	/*we don't have any more ready packets */
+
+		if (ctrl & EMAC_BAD_RX_PACKET) {
+
+			fep->stats.rx_errors++;
+			fep->stats.rx_dropped++;
+
+			if (ctrl & EMAC_RX_ST_OE)
+				fep->stats.rx_fifo_errors++;
+			if (ctrl & EMAC_RX_ST_AE)
+				fep->stats.rx_frame_errors++;
+			if (ctrl & EMAC_RX_ST_BFCS)
+				fep->stats.rx_crc_errors++;
+			if (ctrl & (EMAC_RX_ST_RP | EMAC_RX_ST_PTL |
+				    EMAC_RX_ST_ORE | EMAC_RX_ST_IRE))
+				fep->stats.rx_length_errors++;
+		} else {
+
+			/* Send the skb up the chain. */
+			frame_length = fep->rx_desc[i].data_len - 4;
+
+			skb_put(fep->rx_skb[i], frame_length);
+			fep->rx_skb[i]->dev = dev;
+			fep->rx_skb[i]->protocol =
+			    eth_type_trans(fep->rx_skb[i], dev);
+
+			error = netif_rx(fep->rx_skb[i]);
+			if ((error == NET_RX_DROP) || (error == NET_RX_BAD)) {
+				fep->stats.rx_dropped++;
+			} else {
+				fep->stats.rx_packets++;
+				fep->stats.rx_bytes += frame_length;
+			}
+			fep->rx_skb[i] = NULL;
+		}
+	} while ((i = (i + 1) % NUM_RX_BUFF) != fep->rx_slot);
+	return i;
+}
+
+static void ppc405_eth_rxeob_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	int n;
+	
+	n = ppc405_rx_clean(dev);
+	ppc405_rx_fill(dev, n);
+}
+
+/*
+ * This interrupt should never occurr, we don't program
+ * the MAL for contiunous mode.
+ */
+static void ppc405_eth_txde_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_WARNING "%s: Tx descriptor error\n", dev->name);
+
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+
+	/* Reenable the transmit channel */
+	mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	return;
+}
+
+/*
+ * This interrupt should be very rare at best.  This occurs when
+ * the hardware has a problem with the receive descriptors.  The manual
+ * states that it occurs when the hardware cannot the receive descriptor
+ * empty bit is not set.  The recovery mechanism will be to
+ * traverse through the descriptors, handle any that are marked to be
+ * handled and reinitialize each along the way.  At that point the driver
+ * will be restarted.
+ */
+static void ppc405_eth_rxde_dev(void *p, u32 chanmask)
+{
+	struct net_device *dev = p;
+	struct ocp_enet_private *fep = dev->priv;
+
+	printk(KERN_WARNING "%s: Rx descriptor error\n", dev->name);
+
+	ppc405_eth_emac_dump(dev);
+	ppc405_eth_mal_dump(dev);
+	ppc405_eth_desc_dump(dev);
+
+
+	fep->stats.rx_errors++;
+
+	/* so do we have any good packets still? */
+	ppc405_rx_clean(dev);
+	
+	/* When the interface is restarted it resets processing to the
+	 * first descriptor in the table.  */
+	fep->rx_slot = 0;
+	ppc405_rx_fill(dev, 0);
+	
+	set_mal_dcrn(fep->mal, DCRN_MALRXEOBISR, MAL_CHAN_MASK(fep->mal_rx_chan));
+
+	/* Clear the interrupt */
+	set_mal_dcrn(fep->mal, DCRN_MALRXDEIR, MAL_CHAN_MASK(fep->mal_rx_chan));
+
+	/* Reenable the receive channel */
+	mal_enable_rx_channels(fep->mal, fep->commac.rx_chan_mask);
+}
+
+static irqreturn_t
+ppc405_eth_mac(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	unsigned long tmp_em0isr;
+	struct net_device *dev = dev_instance;
+	struct ocp_enet_private *fep = dev->priv;
+	volatile emac_t *emacp = fep->emacp;
+
+	/* EMAC interrupt */
+	tmp_em0isr = in_be32(&emacp->em0isr);
+	if (tmp_em0isr & (EMAC_ISR_TE0 | EMAC_ISR_TE1)) {
+		/* This error is a hard transmit error - could retransmit */
+		fep->stats.tx_errors++;
+
+		/* Reenable the transmit channel */
+		mal_enable_tx_channels(fep->mal, fep->commac.tx_chan_mask);
+	} else {
+		fep->stats.rx_errors++;
+	}
+
+/*	if (tmp_em0isr & EMAC_ISR_OVR ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_PP ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_BP ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_RP)
+		fep->stats.rx_length_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_SE ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_ALE)
+		fep->stats.rx_frame_errors++;
+	if (tmp_em0isr & EMAC_ISR_BFCS)
+		fep->stats.rx_crc_errors++;
+	if (tmp_em0isr & EMAC_ISR_PTLE)
+		fep->stats.rx_length_errors++;
+	if (tmp_em0isr & EMAC_ISR_ORE)
+		fep->stats.rx_length_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_IRE ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_DBDM) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_DB0 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_SE0 ) fep->stats.ZZZ++;		*/
+	if (tmp_em0isr & EMAC_ISR_TE0)
+		fep->stats.tx_aborted_errors++;
+/*	if (tmp_em0isr & EMAC_ISR_DB1 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_SE1 ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_TE1) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_MOS ) fep->stats.ZZZ++;		*/
+/*	if (tmp_em0isr & EMAC_ISR_MOF ) fep->stats.ZZZ++;		*/
+
+	ppc405_bl_mac_eth_dump(dev, tmp_em0isr);
+
+	out_be32(&emacp->em0isr, tmp_em0isr);
+	
+	return IRQ_HANDLED;
+}
+
+static void __exit
+exit_ppc405_enet(void)
+{
+}
+
+module_init(init_ppc405_enet);
+module_exit(exit_ppc405_enet);
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_enet.h
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_enet.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_enet.h	2003-07-19 01:01:21.000000000 +0000
@@ -0,0 +1,173 @@
+/*
+ * ibm_ocp_enet.h
+ *
+ * Ethernet driver for the built in ethernet on the IBM 405 PowerPC
+ * processor.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ *      Orignial driver
+ *         Johnnie Peters
+ *         jpeters@mvista.com
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _IBM_OCP_ENET_H_
+#define _IBM_OCP_ENET_H_
+
+#include <linux/netdevice.h>
+#include <asm/ocp.h>
+#include <asm/mmu.h>		/* For phys_addr_t */
+#include "ocp_zmii.h"
+#include "ibm_ocp_emac.h"
+#include "ibm_ocp_phy.h"
+#include "ibm_ocp_mal.h"
+
+#ifndef CONFIG_IBM_OCP_ENET_TX_BUFF
+#define NUM_TX_BUFF		6
+#define NUM_RX_BUFF		64
+#else
+#define NUM_TX_BUFF		CONFIG_IBM_OCP_ENET_TX_BUFF
+#define NUM_RX_BUFF		CONFIG_IBM_OCP_ENET_RX_BUFF
+#endif
+
+/* This does 16 byte alignment, exactly what we need.
+ * The packet length includes FCS, but we don't want to
+ * include that when passing upstream as it messes up
+ * bridging applications.
+ */
+#ifndef CONFIG_IBM_OCP_ENET_SKB_RES
+#define SKB_RES 2
+#else
+#define SKB_RES CONFIG_IBM_OCP_ENET_SKB_RES
+#endif
+
+#define MAX_NUM_BUF_DESC	255
+#define DECS_TX_BUF_SIZE	2048
+#define DESC_RX_BUF_SIZE	2048	/* max 4096-16 */
+#define DESC_BUF_SIZE		2048
+#define DESC_BUF_SIZE_REG	(DESC_RX_BUF_SIZE / 16)
+
+
+#define MIN_PHY_ADDR            0x01
+#define MAX_PHY_ADDR            0x1f
+/* Transmitter timeout. */
+#define TX_TIMEOUT		(2*HZ)
+#define OCP_RESET_DELAY		50
+#define MDIO_DELAY		2
+#define NMII				20
+
+
+#ifdef CONFIG_IBM_OCP_ENET_ERROR_MSG
+void ppc405_serr_dump_0(struct net_device *dev);
+void ppc405_serr_dump_1(struct net_device *dev);
+void ppc405_bl_mac_eth_dump(struct net_device *dev, int em0isr);
+void  ppc405_phy_dump(struct net_device *);
+void ppc405_eth_desc_dump(struct net_device *);
+void ppc405_eth_emac_dump(struct net_device *);
+void ppc405_eth_mal_dump(struct net_device *);
+#else
+#define ppc405_serr_dump_0(dev) do { } while (0)
+#define ppc405_serr_dump_1(dev) do { } while (0)
+#define ppc405_bl_mac_eth_dump(dev,x) do { } while (0)
+#define ppc405_phy_dump(dev) do { } while (0)
+#define ppc405_eth_desc_dump(dev) do { } while (0)
+#define ppc405_eth_emac_dump(dev) do { } while (0)
+#define ppc405_eth_mal_dump(dev) do { } while (0)
+#endif
+
+#define mk_mii_read(REG)		((EMAC_STACR_READ| (REG & 0x1f)) & \
+						~EMAC_STACR_CLK_100MHZ)
+#define mk_mii_write(REG,VAL)		(((EMAC_STACR_WRITE | (REG & 0x1f)) & \
+						~EMAC_STACR_CLK_100MHZ) | \
+						((VAL & 0xffff) << 16))
+/* Emac */
+typedef struct emac_regs {
+	volatile u32 em0mr0;
+	volatile u32 em0mr1;
+	volatile u32 em0tmr0;
+	volatile u32 em0tmr1;
+	volatile u32 em0rmr;
+	volatile u32 em0isr;
+	volatile u32 em0iser;
+	volatile u32 em0iahr;
+	volatile u32 em0ialr;
+	volatile u32 em0vtpid;
+	volatile u32 em0vtci;
+	volatile u32 em0ptr;
+	volatile u32 em0iaht1;
+	volatile u32 em0iaht2;
+	volatile u32 em0iaht3;
+	volatile u32 em0iaht4;
+	volatile u32 em0gaht1;
+	volatile u32 em0gaht2;
+	volatile u32 em0gaht3;
+	volatile u32 em0gaht4;
+	volatile u32 em0lsal;
+	volatile u32 em0lsah;
+	volatile u32 em0ipgvr;
+	volatile u32 em0stacr;
+	volatile u32 em0trtr;
+	volatile u32 em0rwmr;
+} emac_t;
+
+struct ocp_enet_private {
+	struct sk_buff *tx_skb[NUM_TX_BUFF];
+	struct sk_buff *rx_skb[NUM_RX_BUFF];
+	struct mal_descriptor *tx_desc;
+	struct mal_descriptor *rx_desc;
+	struct mal_descriptor *rx_dirty;
+	struct net_device_stats stats;
+	int tx_cnt;
+	int rx_slot;
+	int dirty_rx;
+	int tx_slot;
+	int ack_slot;
+	uint phy_id;
+	uint phy_id_done;
+	uint phy_status;
+	uint phy_speed;
+	uint phy_duplex;
+	phy_info_t *phy;
+	uint phy_addr;
+	int link;
+	int old_link;
+	int full_duplex;
+
+	zmii_t *zmii_base;
+	int zmii_mode;
+	struct ocp_device *zmii_ocpdev;
+
+	struct ibm_ocp_mal *mal;
+	int mal_tx_chan, mal_rx_chan;
+	struct mal_commac commac;
+
+	volatile emac_t *emacp;
+	int wol_irq;
+	struct ocp_device *ocpdev;
+};
+
+
+#endif				/* _IBM_OCP_ENET_H_ */
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_mal.c
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_mal.c	2003-08-23 15:04:02.000000000 +0000
@@ -0,0 +1,410 @@
+/*
+ * ibm_ocp_mal.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Juen, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/netdevice.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/ocp.h>
+
+#include "ibm_ocp_mal.h"
+
+struct ibm_ocp_mal mal_table[NUM_MALS]; /* = 0 */
+
+static void __exit exit_mal(struct ibm_ocp_mal *mal);
+
+int mal_register_commac(struct ibm_ocp_mal *mal, struct mal_commac *commac)
+{
+	/* FIXME: locking? */
+
+	/* Don't let multiple commacs claim the same channel */
+	if ( (mal->tx_chan_mask & commac->tx_chan_mask) ||
+	     (mal->rx_chan_mask & commac->rx_chan_mask) )
+		return -EBUSY;
+
+	mal->tx_chan_mask |= commac->tx_chan_mask;
+	mal->rx_chan_mask |= commac->rx_chan_mask;
+
+	list_add(&commac->list, &mal->commac);
+
+	return 0;
+}
+
+int mal_set_rcbs(struct ibm_ocp_mal *mal, int channel, unsigned long size)
+{
+	switch (channel) {
+	case 0:
+		set_mal_dcrn(mal, DCRN_MALRCBS0, size);
+		break;
+#ifdef DCRN_MALRCBS1
+	case 1:
+		set_mal_dcrn(mal, DCRN_MALRCBS1, size);
+		break;
+#endif
+#ifdef DCRN_MALRCBS2
+	case 2:
+		set_mal_dcrn(mal, DCRN_MALRCBS2, size);
+		break;
+#endif
+#ifdef DCRN_MALRCBS3
+	case 3:
+		set_mal_dcrn(mal, DCRN_MALRCBS3, size);
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static irqreturn_t mal_serr(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	unsigned long mal_error;
+
+	/*
+	 * This SERR applies to one of the devices on the MAL, here we charge
+	 * it against the first EMAC registered for the MAL.
+	 */
+
+	mal_error = get_mal_dcrn(mal, DCRN_MALESR);
+
+	printk(KERN_ERR "%s: System Error (MALESR=%lx)\n", 
+	       "MAL" /* FIXME: get the name right */, mal_error);
+
+	/* FIXME: decipher error */
+	/* DIXME: distribute to commacs, if possible */
+
+	/* Clear the error status register */
+	set_mal_dcrn(mal, DCRN_MALESR, mal_error);
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_txeob(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long isr;
+
+	/* Loop to better handle lots of interrupts */
+
+	isr = get_mal_dcrn(mal, DCRN_MALTXEOBISR);
+	set_mal_dcrn(mal, DCRN_MALTXEOBISR, isr);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (isr & mc->tx_chan_mask) {
+			mc->ops->txeob(mc->dev, isr & mc->tx_chan_mask);
+		}
+	}
+	/* What if we don't get a hit in the list? */
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_rxeob(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long isr;
+
+	/*
+	 * Protect against mal_rxde() modifying data structures this
+	 * function is using. FIXME: synchronisation should move within
+	 * the client drivers */
+	disable_irq(mal->rxde_irq);
+
+
+	/* FIXME: Loop to better handle lots of interrupts? */
+
+	isr = get_mal_dcrn(mal, DCRN_MALRXEOBISR);
+	set_mal_dcrn(mal, DCRN_MALRXEOBISR, isr);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (isr & mc->rx_chan_mask) {
+			mc->ops->rxeob(mc->dev, isr & mc->rx_chan_mask);
+		}
+	}
+	/* FIXME: What if we don't get a hit in the list? */
+
+	enable_irq(mal->rxde_irq);
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mal_txde(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long deir;
+
+	deir = get_mal_dcrn(mal, DCRN_MALTXDEIR);
+
+	/* FIXME: print which MAL correctly */
+	printk(KERN_WARNING "%s: Tx descriptor error (MALTXDEIR=%lx)\n",
+	       "MAL", deir);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (deir & mc->tx_chan_mask) {
+			mc->ops->txde(mc->dev, deir & mc->tx_chan_mask);
+		}
+	}
+	/* What if there is no match in the list? */
+	
+	return IRQ_HANDLED;
+}
+
+/*
+ * This interrupt should be very rare at best.  This occurs when
+ * the hardware has a problem with the receive descriptors.  The manual
+ * states that it occurs when the hardware cannot the receive descriptor
+ * empty bit is not set.  The recovery mechanism will be to
+ * traverse through the descriptors, handle any that are marked to be
+ * handled and reinitialize each along the way.  At that point the driver
+ * will be restarted.
+ */
+static irqreturn_t mal_rxde(int irq, void *dev_instance, struct pt_regs *regs)
+{
+	struct ibm_ocp_mal *mal = dev_instance;
+	struct list_head *l;
+	unsigned long deir;
+
+	deir = get_mal_dcrn(mal, DCRN_MALRXDEIR);
+
+	/*
+	 * This really is needed.  This case encountered in stress testing.
+	 */
+	if (deir == 0)
+		return IRQ_HANDLED;
+
+	/* FIXME: print which MAL correctly */
+	printk(KERN_WARNING "%s: Rx descriptor error (MALRXDEIR=%lx)\n",
+	       "MAL", deir);
+
+
+	/*
+	 * Protect against ppc405_eth_rxeob modifying these same
+	 * structures.  If an rxde interrupt occurs the hardware will
+	 * have disabled that EMAC, but since there may be multiple
+	 * EMACs on the same MAL another rxeob interrupt could occur
+	 * for another EMAC prior to ppc405_eth_rxde() re-enabling
+	 * EMACs below.  FIXME: this looks bogus
+	 */
+	disable_irq(BL_MAL_RXEOB);
+
+	list_for_each(l, &mal->commac) {
+		struct mal_commac *mc = list_entry(l, struct mal_commac, list);
+
+		if (deir & mc->rx_chan_mask) {
+			mc->ops->rxde(mc->dev, deir & mc->rx_chan_mask);
+		}
+	}
+
+	enable_irq(BL_MAL_RXEOB);
+	
+	return IRQ_HANDLED;
+}
+
+static int __init init_mal(int n)
+{
+	struct ibm_ocp_mal *mal;
+	int err;
+
+	mal = &mal_table[n];
+
+
+	switch (n) {
+	case 0:
+		mal->dcrbase = DCRN_MAL_BASE;
+		break;
+#ifdef DCRN_MAL1_BASE
+	case 1:
+		mal->dcrbase = DCRN_MAL1_BASE;
+		break;
+#endif
+	default:
+		BUG();
+	}
+	mal->serr_irq = BL_MAL_SERR;
+	mal->txde_irq = BL_MAL_TXDE;
+	mal->txeob_irq = BL_MAL_TXEOB;
+	mal->rxde_irq = BL_MAL_RXDE;
+	mal->rxeob_irq = BL_MAL_RXEOB;
+	
+	/* Wrong in general, but the best we have for now: */
+	mal->num_tx_channels = 2*EMAC_NUMS;
+	mal->num_rx_channels = EMAC_NUMS;
+
+	/**************************/
+
+	INIT_LIST_HEAD(&mal->commac);
+
+
+	set_mal_dcrn(mal, DCRN_MALRXCARR, 0xFFFFFFFF);
+	set_mal_dcrn(mal, DCRN_MALTXCARR, 0xFFFFFFFF);
+
+	set_mal_dcrn(mal, DCRN_MALCR, MALCR_MMSR);	/* 384 */
+	/* FIXME: Add delay */
+
+	/* Set the MAL configuration register */
+	set_mal_dcrn(mal, DCRN_MALCR,
+		     MALCR_PLBB | MALCR_OPBBL | MALCR_LEA |
+		     MALCR_PLBLT_DEFAULT);
+
+	/* It would be nice to allocate buffers separately for each
+	 * channel, but we can't because the channels share the upper
+	 * 13 bits of address lines.  Each channels buffer must also
+	 * be 4k aligned, so we allocate 4k for each channel.  This is
+	 * inefficient FIXME: do better, if possible */
+
+	mal->tx_virt_addr = consistent_alloc(GFP_KERNEL,
+					     MAL_DT_ALIGN * mal->num_tx_channels,
+					     &mal->tx_phys_addr);
+
+	/* God, oh, god, I hate DCRs */
+	set_mal_dcrn(mal, DCRN_MALTXCTP0R, mal->tx_phys_addr);
+#ifdef DCRN_MALTXCTP1R
+	set_mal_dcrn(mal, DCRN_MALTXCTP1R, mal->tx_phys_addr + MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP1R */
+#ifdef DCRN_MALTXCTP2R
+	set_mal_dcrn(mal, DCRN_MALTXCTP2R, mal->tx_phys_addr + 2*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP2R */
+#ifdef DCRN_MALTXCTP3R
+	set_mal_dcrn(mal, DCRN_MALTXCTP3R, mal->tx_phys_addr + 3*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP3R */
+#ifdef DCRN_MALTXCTP4R
+	set_mal_dcrn(mal, DCRN_MALTXCTP4R, mal->tx_phys_addr + 4*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP4R */
+#ifdef DCRN_MALTXCTP5R
+	set_mal_dcrn(mal, DCRN_MALTXCTP5R, mal->tx_phys_addr + 5*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP5R */
+#ifdef DCRN_MALTXCTP6R
+	set_mal_dcrn(mal, DCRN_MALTXCTP6R, mal->tx_phys_addr + 6*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP6R */
+#ifdef DCRN_MALTXCTP7R
+	set_mal_dcrn(mal, DCRN_MALTXCTP7R, mal->tx_phys_addr + 7*MAL_DT_ALIGN);
+#endif /* DCRN_MALTXCTP7R */
+
+	mal->rx_virt_addr = consistent_alloc(GFP_KERNEL,
+					     MAL_DT_ALIGN * mal->num_rx_channels,
+					     &mal->rx_phys_addr);
+
+	set_mal_dcrn(mal, DCRN_MALRXCTP0R, mal->rx_phys_addr);
+#ifdef DCRN_MALRXCTP1R
+	set_mal_dcrn(mal, DCRN_MALRXCTP1R, mal->rx_phys_addr + MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP1R */
+#ifdef DCRN_MALRXCTP2R
+	set_mal_dcrn(mal, DCRN_MALRXCTP2R, mal->rx_phys_addr + 2*MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP2R */
+#ifdef DCRN_MALRXCTP3R
+	set_mal_dcrn(mal, DCRN_MALRXCTP3R, mal->rx_phys_addr + 3*MAL_DT_ALIGN);
+#endif /* DCRN_MALRXCTP3R */
+	
+	err = request_irq(mal->serr_irq, mal_serr, 0 ,"MAL SERR", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->txde_irq, mal_txde,0, "MAL TX DE ", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->txeob_irq, mal_txeob, 0, "MAL TX EOB", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->rxde_irq, mal_rxde, 0, "MAL RX DE", mal);
+	if (err)
+		goto fail;
+	err = request_irq(mal->rxeob_irq, mal_rxeob, 0, "MAL RX EOB", mal);
+	if (err)
+		goto fail;
+
+	set_mal_dcrn(mal, DCRN_MALIER,
+		     MALIER_DE | MALIER_NE | MALIER_TE |
+		     MALIER_OPBE | MALIER_PLBE);
+
+	return 0;
+
+ fail:
+	exit_mal(mal);
+	return err;
+}
+
+static void __exit exit_mal(struct ibm_ocp_mal *mal)
+{
+	/* FIXME: shut down the MAL */
+	free_irq(mal->serr_irq, mal);
+	free_irq(mal->txde_irq, mal);
+	free_irq(mal->txeob_irq, mal);
+	free_irq(mal->rxde_irq, mal);
+	free_irq(mal->rxeob_irq, mal);
+	
+	if (mal->tx_virt_addr)
+		consistent_free(mal->tx_virt_addr);
+	if (mal->rx_virt_addr)
+		consistent_free(mal->rx_virt_addr);
+
+	memset(mal, 0, sizeof(*mal));
+}
+
+static int __init init_mals(void)
+{
+	int i;
+	int err;
+
+	printk(KERN_DEBUG "init_mals()\n");
+
+	for (i = 0; i < NUM_MALS; i++) {
+		err = init_mal(i);
+		if (err)
+			return err; /* FIXME: cleanup initalized MALs */
+	}
+
+	return 0;
+}
+
+static void __exit exit_mals(void)
+{
+	int i;
+
+	for (i = 0; i < NUM_MALS; i++)
+		exit_mal(&mal_table[i]);
+}
+
+module_init(init_mals);
+module_exit(exit_mals);
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_mal.h
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_mal.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_mal.h	2003-01-16 02:37:15.000000000 +0000
@@ -0,0 +1,145 @@
+/*
+ * 06/02/02 -Armin
+ *    added new mal functions and defines from ibm_ocp_enet.h
+ */
+
+#ifndef _IBM_OCP_MAL_H
+#define _IBM_OCP_MAL_H
+
+#include <linux/list.h>
+
+#define MAL_DT_ALIGN	(4096)	/* Alignment for each channel's descriptor table */
+
+#define MAL_CHAN_MASK(chan)	(0x80000000 >> (chan))
+
+/* MAL Buffer Descriptor structure */
+struct mal_descriptor {
+	volatile unsigned short ctrl;	/* MAL / Commac status control bits */
+	volatile short data_len;	/* Max length is 4K-1 (12 bits)     */
+	unsigned char *data_ptr;	/* pointer to actual data buffer    */
+} __attribute__((packed));
+
+/* the following defines are for the MadMAL status and control registers. */
+/* MADMAL transmit and receive status/control bits  */
+#define MAL_RX_CTRL_EMPTY		0x8000
+#define MAL_RX_CTRL_WRAP		0x4000
+#define MAL_RX_CTRL_CM			0x2000
+#define MAL_RX_CTRL_LAST		0x1000
+#define MAL_RX_CTRL_FIRST		0x0800
+#define MAL_RX_CTRL_INTR		0x0400
+
+#define MAL_TX_CTRL_READY		0x8000
+#define MAL_TX_CTRL_WRAP		0x4000
+#define MAL_TX_CTRL_CM			0x2000
+#define MAL_TX_CTRL_LAST		0x1000
+#define MAL_TX_CTRL_INTR		0x0400
+
+struct mal_commac_ops {
+	void (*txeob)(void *dev, u32 chanmask);
+	void (*txde)(void *dev, u32 chanmask);
+	void (*rxeob)(void *dev, u32 chanmask);
+	void (*rxde)(void *dev, u32 chanmask);
+};
+
+struct mal_commac {
+	struct mal_commac_ops *ops;
+	void *dev;
+	u32 tx_chan_mask, rx_chan_mask;
+	struct list_head list;
+};
+
+/* FIXME: Work this out better */
+#define MAL_MAX_TX_CHANNELS	(EMAC_NUMS*2)
+#define MAL_MAX_RX_CHANNELS	(EMAC_NUMS)
+
+struct ibm_ocp_mal {
+	int dcrbase;
+	int serr_irq, txeob_irq, txde_irq, rxeob_irq, rxde_irq;
+
+	struct list_head commac;
+	u32 tx_chan_mask, rx_chan_mask;
+
+	int num_tx_channels;
+	dma_addr_t tx_phys_addr;
+	struct mal_descriptor *tx_virt_addr;
+
+	int num_rx_channels;
+	dma_addr_t rx_phys_addr;
+	struct mal_descriptor *rx_virt_addr;
+};
+
+#ifdef DCRN_MAL1_BASE
+#define NUM_MALS	2
+#else
+#define	NUM_MALS	1
+#endif
+
+extern struct ibm_ocp_mal mal_table[NUM_MALS];
+
+#define GET_MAL_STANZA(base,dcrn) \
+	case base: \
+		x = mfdcr(dcrn(base)); \
+		break;
+
+#define SET_MAL_STANZA(base,dcrn, val) \
+	case base: \
+		mtdcr(dcrn(base), (val)); \
+		break;
+
+#define GET_MAL0_STANZA(dcrn) GET_MAL_STANZA(DCRN_MAL_BASE,dcrn)
+#define SET_MAL0_STANZA(dcrn,val) SET_MAL_STANZA(DCRN_MAL_BASE,dcrn,val)
+
+#ifdef DCRN_MAL1_BASE
+#define GET_MAL1_STANZA(dcrn) GET_MAL_STANZA(DCRN_MAL1_BASE,dcrn)
+#define SET_MAL1_STANZA(dcrn,val) SET_MAL_STANZA(DCRN_MAL1_BASE,dcrn,val)
+#else /* ! DCRN_MAL1_BASE */
+#define GET_MAL1_STANZA(dcrn) 
+#define SET_MAL1_STANZA(dcrn,val)
+#endif
+
+
+#define get_mal_dcrn(mal, dcrn) ({ \
+	u32 x; \
+	switch ((mal)->dcrbase) { \
+		GET_MAL0_STANZA(dcrn) \
+		GET_MAL1_STANZA(dcrn) \
+	default: \
+		BUG(); \
+	} \
+x; })
+
+#define set_mal_dcrn(mal, dcrn, val) do { \
+	switch ((mal)->dcrbase) { \
+		SET_MAL0_STANZA(dcrn,val) \
+		SET_MAL1_STANZA(dcrn,val) \
+	default: \
+		BUG(); \
+	} } while (0)
+
+
+static inline void mal_enable_tx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALTXCASR,
+		     get_mal_dcrn(mal, DCRN_MALTXCASR) | chanmask);
+}
+
+static inline void mal_disable_tx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALTXCARR, chanmask);
+}
+
+static inline void mal_enable_rx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALRXCASR,
+		     get_mal_dcrn(mal, DCRN_MALRXCASR) | chanmask);
+}
+
+static inline void mal_disable_rx_channels(struct ibm_ocp_mal *mal, u32 chanmask)
+{
+	set_mal_dcrn(mal, DCRN_MALRXCARR, chanmask);
+}
+
+extern int mal_register_commac(struct ibm_ocp_mal *mal, struct mal_commac *commac);
+extern int mal_set_rcbs(struct ibm_ocp_mal *mal, int channel, unsigned long size);
+
+#endif /* _IBM_OCP_MAL_H */
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_phy.c
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_phy.c	2002-11-11 21:59:05.000000000 +0000
@@ -0,0 +1,1054 @@
+/*
+ * ibm_ocp_phy.c
+ *
+ * Ethernet PHY routines and database for IBM 4xx PowerPC processors.
+ *
+ * Based on  the Fast Ethernet Controller (FEC) driver for
+ * Motorola MPC8xx and other contributions, see driver for contributers.
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ * Copyright 2000 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * TODO: mii queue process
+ *
+ * Version 1.0 (01/09/28) by Armin kuster
+ *	added find_phy to auto discover phy adder
+ *	and phy type.
+ * Version 1.1 (01/10/05) Armin Kuster
+ *	Use dev->base_addr for EMAC reg addr
+ *
+ * Version 1.2 (01/10/17) Armin
+ *      removed unused emac from process_mii_queue & mii_enet_mii
+ *      switch 10HD w/ 100FD in  mii_parse_dp83843_pcr via Dimitrios Michailidiss
+ *      general clean-up
+ *      added proccess_mii_queue & mii_queue_schedule
+ *      added support for National DP83846A PHY
+ *
+ * Vesrion: 1.3 (01/11/13) Armin
+ * 	fixed mii_parse_dp83843_pcr, decode 100FDX & 10HDX wrong./
+ *
+ * Version: 1.4 (01/12/26) Armin & Kim Young-Han
+ * 		added BCM5221 phy support, Kim
+ * 		added Am79C875 phy support, armin
+ * Version: 1.5 (02/05/02) Armin
+ * 		Name change
+ * Version: 1.6 (02/12/02) Andrew, David, Stefan
+ * 		fixed find_phy
+ * Version: 1.7 (03/01/02) Andrew May
+ * 		Improved find_phy
+ * 		added Am79C874
+ * Version: 1.8 (03/25/02) Andrew May 
+ *		Fix bad Partner Link check for the Am79C874 phy
+ *
+ * Version: 1.9 (04/04/02) Matt Porter
+ * 		Added Am79C875A phy support
+ * 		Message cleanup
+ * Version: 2.0 (04/15/02) Todd Poynor
+ * 	redid ANLPAR parser for Am79c875* to select proper speed
+ *
+ * Version: 2.0 (04/18/02) - Armin
+ * 	shifted  Am79c865 id by 4 and changed shift to 4 (Ash suppport)
+ *
+ * Version: 2.1 (04/25/02) - Armin
+ *  	using zmii_phyid_adj() to adjust phy addrs on those cpus
+ *  	that use a zmii bridge
+ *  	fixed find_phy for zmii bridge support
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/netdevice.h>
+
+#include <asm/processor.h>	/* Processor type for cache alignment. */
+#include <asm/bitops.h>
+#include <asm/io.h>
+
+#include "ibm_ocp_enet.h"
+static int next_phy_available = MIN_PHY_ADDR;
+
+/* Forward declarations of some structures to support different PHYs */
+
+/* Interrupt events/masks. */
+#define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
+#define FEC_ENET_BABR	((uint)0x40000000)	/* Babbling receiver */
+#define FEC_ENET_BABT	((uint)0x20000000)	/* Babbling transmitter */
+#define FEC_ENET_GRA	((uint)0x10000000)	/* Graceful stop complete */
+#define FEC_ENET_TXF	((uint)0x08000000)	/* Full frame transmitted */
+#define FEC_ENET_TXB	((uint)0x04000000)	/* A buffer was transmitted */
+#define FEC_ENET_RXF	((uint)0x02000000)	/* Full frame received */
+#define FEC_ENET_RXB	((uint)0x01000000)	/* A buffer was received */
+#define FEC_ENET_MII	((uint)0x00800000)	/* MII interrupt */
+#define FEC_ENET_EBERR	((uint)0x00400000)	/* SDMA bus error */
+
+#define FEC_ECNTRL_PINMUX	0x00000004
+#define FEC_ECNTRL_ETHER_EN	0x00000002
+#define FEC_ECNTRL_RESET	0x00000001
+
+#define FEC_RCNTRL_BC_REJ	0x00000010
+#define FEC_RCNTRL_PROM		0x00000008
+#define FEC_RCNTRL_MII_MODE	0x00000004
+#define FEC_RCNTRL_DRT		0x00000002
+#define FEC_RCNTRL_LOOP		0x00000001
+
+#define FEC_TCNTRL_FDEN		0x00000004
+#define FEC_TCNTRL_HBC		0x00000002
+#define FEC_TCNTRL_GTS		0x00000001
+
+void ocp_enet_mii(struct net_device *dev);
+extern int ocp_enet_mdio_read(struct net_device *dev, int reg, uint * value);
+extern int ocp_enet_mdio_write(struct net_device *dev, int reg);
+
+/* Make MII read/write commands for the OCP. */
+
+/* MII processing.  We keep this as simple as possible.  Requests are
+ * placed on the list (if there is room).  When the request is finished
+ * by the MII, an optional function may be called.
+ */
+static int mii_queue(struct net_device *dev, int request,
+		     void (*func) (uint, struct net_device *));
+
+/* Register definitions for the PHY. */
+
+#define MII_REG_CR		0	/* Control Register */
+#define MII_REG_SR		1	/* Status Register */
+#define MII_REG_PHYIR1		2	/* PHY Identification Register 1 */
+#define MII_REG_PHYIR2		3	/* PHY Identification Register 2 */
+#define MII_REG_ANAR		4	/* A-N Advertisement Register */
+#define MII_REG_ANLPAR		5	/* A-N Link Partner Ability Register */
+#define MII_REG_ANER		6	/* A-N Expansion Register */
+#define MII_REG_ANNPTR		7	/* A-N Next Page Transmit Register */
+#define MII_REG_ANLPRNPR	8	/* A-N Link Partner Received Next Page Reg. */
+
+/* values for phy_status */
+
+#define PHY_CONF_ANE		0x0001	/* 1 auto-negotiation enabled */
+#define PHY_CONF_LOOP		0x0002	/* 1 loopback mode enabled */
+#define PHY_CONF_SPMASK		0x01E0	/* mask for speed */
+#define PHY_CONF_10HDX		0x0010	/* 10 Mbit half duplex supported */
+#define PHY_CONF_10FDX		0x0020	/* 10 Mbit full duplex supported */
+#define PHY_CONF_100HDX		0x0040	/* 100 Mbit half duplex supported */
+#define PHY_CONF_100FDX		0x0080	/* 100 Mbit full duplex supported */
+
+#define PHY_STAT_LINK		0x0100	/* 1 up - 0 down */
+#define PHY_STAT_FAULT		0x0200	/* 1 remote fault */
+#define PHY_STAT_ANC		0x0400	/* 1 auto-negotiation complete */
+#define PHY_STAT_SPMASK		0xf000	/* mask for speed */
+#define PHY_STAT_10HDX		0x1000	/* 10 Mbit half duplex selected */
+#define PHY_STAT_10FDX		0x2000	/* 10 Mbit full duplex selected */
+#define PHY_STAT_100HDX		0x4000	/* 100 Mbit half duplex selected */
+#define PHY_STAT_100FDX		0x8000	/* 100 Mbit full duplex selected */
+
+mii_list_t *mii_free;
+mii_list_t *mii_head;
+mii_list_t *mii_tail;
+
+/* mii routines */
+
+/* 	Manually process all queued commands */
+
+void
+process_mii_queue(struct net_device *dev)
+{
+	mii_list_t *mip;
+	uint mii_reg = 0;
+
+	while ((mip = mii_head) != NULL) {
+
+		if (mip->mii_func != NULL) {
+			ocp_enet_mdio_read(dev, mip->mii_regval, &mii_reg);
+			(*(mip->mii_func)) (mii_reg, dev);
+		} else {
+			if (mip->mii_regval & EMAC_STACR_READ)
+				ocp_enet_mdio_read(dev, mip->mii_regval,
+						   &mii_reg);
+			else
+				ocp_enet_mdio_write(dev, mip->mii_regval);
+		}
+
+		mii_head = mip->mii_next;
+		mip->mii_next = mii_free;
+		mii_free = mip;
+	}
+}
+
+static int
+mii_queue(struct net_device *dev, int regval,
+	  void (*func) (uint, struct net_device *))
+{
+	unsigned long flags;
+	mii_list_t *mip;
+	int retval;
+
+	retval = 0;
+	save_flags(flags);
+	cli();
+
+	if ((mip = mii_free) != NULL) {
+		mii_free = mip->mii_next;
+		mip->mii_regval = regval;
+		mip->mii_func = func;
+		mip->mii_next = NULL;
+		if (mii_head) {
+			mii_tail->mii_next = mip;
+			mii_tail = mip;
+		} else {
+			mii_head = mii_tail = mip;
+		}
+	} else
+		retval = 1;
+
+	restore_flags(flags);
+
+	return retval;
+}
+
+void
+mii_do_cmd(struct net_device *dev, const phy_cmd_t * c)
+{
+	int k;
+
+	if (!c)
+		return;
+
+	for (k = 0; (c + k)->mii_data != mk_mii_end; k++)
+		mii_queue(dev, (c + k)->mii_data, (c + k)->funct);
+}
+
+static void
+mii_parse_sr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		*s |= PHY_STAT_LINK;
+	if (mii_reg & 0x0010)
+		*s |= PHY_STAT_FAULT;
+	if (mii_reg & 0x0020)
+		*s |= PHY_STAT_ANC;
+}
+
+static void
+mii_parse_cr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_ANE | PHY_CONF_LOOP);
+
+	if (mii_reg & 0x1000)
+		*s |= PHY_CONF_ANE;
+	if (mii_reg & 0x4000)
+		*s |= PHY_CONF_LOOP;
+}
+
+static void
+mii_parse_anar(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	if (mii_reg & 0x0020)
+		*s |= PHY_CONF_10HDX;
+	if (mii_reg & 0x0040)
+		*s |= PHY_CONF_10FDX;
+	if (mii_reg & 0x0080)
+		*s |= PHY_CONF_100HDX;
+	if (mii_reg & 0x00100)
+		*s |= PHY_CONF_100FDX;
+
+}
+
+/* ------------------------------------------------------------------------- */
+/* The National Semiconductor DP83843  is used on the IBM Walnut	     */
+
+/* register definitions */
+
+#define MII_DP83843_PHYSTS	0x10	/* Phy Status Register */
+#define MII_DP83843_MIPSCR	0x11	/* MII int PHY spec. Register */
+#define MII_DP83843_MIPGSR	0x12	/* MII int generic status Register */
+#define MII_DP83843_DCR		0x13	/* Disconnect Counter Register */
+#define MII_DP83843_FCSCR	0x14	/* False Carrier Sense Register */
+#define MII_DP83843_RECS	0x15	/* Receive counter Reg. */
+#define MII_DP83843_PCSR	0x16	/* PCS Sub-layer Config & status Reg. */
+#define MII_DP83843_LBR		0x17	/* Loopback & bypass Reg. */
+#define MII_DP83843_10BTSCR	0x18	/* 10BASE-T status & cntl Reg. */
+#define MII_DP83843_PHYCTRL	0x19	/* PHY cntl Reg. */
+
+static void
+mii_parse_dp83843_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 1) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_dp83843 = {
+	0x20005c10,
+	"DP83843",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_DP83843_MIPSCR, 0x0001), NULL},
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANER to acknowledge */
+
+			     {mk_mii_read(MII_DP83843_MIPGSR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+
+			     {mk_mii_read(MII_DP83843_PHYSTS),
+			      mii_parse_dp83843_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_DP83843_MIPSCR, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Intel LXT971A is used on the esd CPCI-405 and EP 405 */
+
+/* register definitions */
+
+#define MII_LXT971A_SR2		17	/* PHY status Register #2 */
+#define MII_LXT971A_IER		18	/* PHY interrupt enable Register */
+#define MII_LXT971A_ISR		19	/* PHY interrupt status Register */
+
+static void
+mii_parse_lxt971a_sr2(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch (mii_reg & 0x4200) {
+	case 0x4200:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 0x4000:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 0x0200:
+		*s |= PHY_STAT_10FDX;
+		break;
+	case 0x0000:
+		*s |= PHY_STAT_10HDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_lxt971a = {
+	0x0001378e,
+	"LXT971A",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_LXT971A_IER, 0x00f2), NULL},	/* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANAR to acknowledge */
+
+			     {mk_mii_read(MII_LXT971A_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read sr2 to get info */
+
+			     {mk_mii_read(MII_LXT971A_SR2),
+			      mii_parse_lxt971a_sr2},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_LXT971A_IER, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Cirrus Logic CS8952 (CrystalLAN) is used on the MPL PIP405	     */
+
+/* register definitions */
+
+#define MII_CS8952_IMR		0x10	/* Interrupt Mask Reg. */
+#define MII_CS8952_ISR		0x11	/* Interrupt Status Reg. */
+#define MII_CS8952_DCR		0x12	/* Disconnect Counter Reg. */
+#define MII_CS8952_FCSCR	0x13	/* False Carrier Counter Reg. */
+#define MII_CS8952_SKIR		0x14	/* Scrambler Key Init Reg. */
+#define MII_CS8952_RECR		0x15	/* Receive Error Counter Reg. */
+#define MII_CS8952_DKIR		0x16	/* Descrambler Key Init Register */
+#define MII_CS8952_PCSR		0x17	/* PCS Sub-layer Config & status Reg. */
+#define MII_CS8952_LBR		0x18	/* Loopback & bypass Reg. */
+#define MII_CS8952_SSR		0x19	/* Self Status Reg. */
+#define MII_CS8952_10BTSR	0x1B	/* 10BASE-T Status Reg. */
+#define MII_CS8952_10BTCR	0x1C	/* 10BASE-T Control Reg. */
+
+static void
+mii_parse_cs8952_ssr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 6) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_cs8952 = {
+	0x001a2205,
+	"CS8952",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+			     /* parse cr and anar to get some info */
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_CS8952_IMR, 0xFFFE), NULL},
+			     /* auto-negotiate */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* we need to read ISR, SR and ANER to acknowledge */
+			     {mk_mii_read(MII_CS8952_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     /* read ssr to get more info */
+			     {mk_mii_read(MII_CS8952_SSR),
+			      mii_parse_cs8952_ssr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_CS8952_IMR, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The National Semiconductor DP83846A 	*/
+
+/* register definitions */
+
+#define MII_DP83846A_PHYSTS	0x10	/* Phy Status Register */
+#define MII_DP83846A_FCSCR	0x14	/* False Carrier Sense Register */
+#define MII_DP83846A_RECS	0x15	/* Receive Error Counter Reg. */
+#define MII_DP83846A_PCSR	0x16	/* PCS Sub-layer Config/status Reg. */
+#define MII_DP83846A_PHYCTRL	0x19	/* PHY cntl Reg. */
+
+static void
+mii_parse_dp83846A_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 1) & 3) {
+	case 0:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100FDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_10FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_dp83846A = {
+	0x20005c23,
+	"DP83846A",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* 83846A doesn't have interrupts but ack_int is also used to
+			        get initial status so here it goes. */
+
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+
+			     {mk_mii_read(MII_DP83846A_PHYSTS),
+			      mii_parse_dp83846A_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Lucent Technologies LU3X31FT */
+
+/* register definitions */
+
+#define MII_LU3X31FT_PHYCTRLSTS	0x17	/* PHY Control/Status Register */
+#define MII_LU3X31FT_IER	0x1D	/* PHY interrupt enable Register */
+#define MII_LU3X31FT_ISR	0x1E	/* PHY interrupt status Register */
+
+static void
+mii_parse_lu3x31ft_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	switch ((mii_reg >> 8) & 3) {
+	case 0:
+		*s |= PHY_STAT_10HDX;
+		break;
+	case 1:
+		*s |= PHY_STAT_10FDX;
+		break;
+	case 2:
+		*s |= PHY_STAT_100HDX;
+		break;
+	case 3:
+		*s |= PHY_STAT_100FDX;
+		break;
+	}
+}
+
+static phy_info_t phy_info_lu3x31ft = {
+	0x90307421,
+	"LU3X31FT",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {
+			     /* startup - enable interrupts */
+			     {mk_mii_write(MII_LU3X31FT_IER, 0x0000), NULL},
+			     /* autonegotiate */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     /* we need to read ISR, SR and ANER to acknowledge */
+			     {mk_mii_read(MII_LU3X31FT_ISR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+
+			     /* read pcr to get info */
+			     {mk_mii_read(MII_LU3X31FT_PHYCTRLSTS),
+			      mii_parse_lu3x31ft_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_LU3X31FT_IER, 0xff80), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The AMD Am79C875 */
+
+/* register definitions */
+
+#define MII_AM79C875_MFR	0x10	/* Mics. Feature Register */
+#define MII_AM79C875_ICR	0x11	/* Interrupt Cntl/Status Register */
+#define MII_AM79C875_DIAG	0x18	/* Diag Reg. */
+#define MII_AM79C875_TEST	0x13	/* Test Reg. */
+#define MII_AM79C875_MFR2	0x14	/* Mics. Feature 2 Register */
+#define MII_AM79C875_RCR	0x15	/* Recv. Error counter */
+#define MII_AM79C875_MCR	0x18	/* Mode contl reg */
+
+static void
+mii_parse_Am79C875_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_SPMASK);
+
+	if (mii_reg & 0x0100) {
+		*s |= PHY_STAT_100FDX;
+	} else if (mii_reg & 0x0080) {
+		*s |= PHY_STAT_100HDX;
+	} else if (mii_reg & 0x0040) {
+		*s |= PHY_STAT_10FDX;
+	} else if (mii_reg & 0x0020) {
+		*s |= PHY_STAT_10HDX;
+	} else {
+		*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_Am79C875 = {
+	/*0x00137886,*/
+	0x00013788,
+	"Am79c875",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+//              { mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, /* int 1 to signle interrupt */
+//              { mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, /* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+static phy_info_t phy_info_Am79C875A = {
+	0x00225541,
+	"Am79c875A",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+//              { mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, /* int 1 to signle interrupt */
+//              { mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, /* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C875_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The Broadcom BCM5221 */
+
+/* register definitions */
+
+#define MII_BCM5221_IER 0x1a
+#define MII_BCM5221_ISR 0x1a
+#define MII_BCM5221_SR  0x19
+#define MII_BCM5221_CSR 0x18
+
+void
+mii_parse_bcm5221_sr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_LINK | PHY_STAT_FAULT | PHY_STAT_ANC);
+
+	if (mii_reg & 0x0004)
+		*s |= PHY_STAT_LINK;
+	if (mii_reg & 0x0040)
+		*s |= PHY_STAT_FAULT;
+	if (mii_reg & 0x8000)
+		*s |= PHY_STAT_ANC;
+}
+
+void
+mii_parse_bcm5221_csr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_STAT_SPMASK);
+
+	if (mii_reg & 0x0002) {
+		if (mii_reg & 0x0001)
+			*s |= PHY_STAT_100FDX;
+		else
+			*s |= PHY_STAT_100HDX;
+	} else {
+		if (mii_reg & 0x0001)
+			*s |= PHY_STAT_10FDX;
+		else
+			*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_bcm5221 = {
+	0x0004061e,
+	"BCM5221",
+	4,
+	(const phy_cmd_t[]) {	/* config */
+			     {mk_mii_write(MII_REG_CR, 0x8000), NULL},	/* reset */
+			     {mk_mii_read(MII_BCM5221_SR), NULL},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     {mk_mii_read(MII_BCM5221_CSR), NULL},
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_read(MII_BCM5221_SR), NULL},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     {mk_mii_read(MII_BCM5221_CSR), NULL},
+
+#if 0
+			     {mk_mii_write(MII_BCM5221_IER, 0x4000), NULL},
+#endif
+			     {mk_mii_write(MII_REG_CR, 0x1200), NULL},	/*
+									   autonegotiate */
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_CSR),
+			      mii_parse_bcm5221_csr},
+
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+			     /* read SR and ISR to acknowledge */
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_SR),
+			      mii_parse_bcm5221_sr},
+			     {mk_mii_read(MII_BCM5221_ISR), NULL},
+			     /* find out the current status */
+			     {mk_mii_read(MII_BCM5221_CSR),
+			      mii_parse_bcm5221_csr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - disable interrupts */
+			     {mk_mii_write(MII_BCM5221_IER, 0x0000), NULL},
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+/* The AMD Am79C874 NetPHY-1LP same as AC101                                 */
+/* This is a hackish copy of the 75 right now. It works for now.             */
+/* It has 100FX support that I have not been able to add/test yet            */
+/*                                                                Andrew May */
+/* Using the same register definitions same as Am79c875*/
+
+static void
+mii_parse_Am79C874_pcr(uint mii_reg, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+
+	*s &= ~(PHY_CONF_SPMASK);
+	mii_reg = mii_reg >> 5;
+	if (mii_reg & 0x10) {
+		/*100Base-T4 this phy doesn't support this */
+	}
+	/*
+	 * pick the best one since a partner can advertise all
+	 * anyone want 10FD over 100HD ?
+	 */
+	if (mii_reg & 0x08) {
+		*s |= PHY_STAT_100FDX;
+	} else if (mii_reg & 0x04) {
+		*s |= PHY_STAT_100HDX;
+	} else if (mii_reg & 0x02) {
+		*s |= PHY_STAT_10FDX;
+	} else if (mii_reg & 0x01) {
+		*s |= PHY_STAT_10HDX;
+	} else {
+		*s |= PHY_STAT_10HDX;
+	}
+}
+
+static phy_info_t phy_info_Am79C874 = {
+	0x0022561b,
+	"Am79c874",
+	0,
+	(const phy_cmd_t[]) {	/* config */
+
+			     /* parse cr and anar to get some info */
+
+			     {mk_mii_read(MII_REG_CR), mii_parse_cr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* startup - enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_AUTON), NULL},	/* Auto neg. on */
+/*{ mk_mii_write(MII_AM79C875_MFR, 0x4000), NULL}, *//* int 1 to signle interrupt */
+/*{ mk_mii_write(MII_AM79C875_ICR, 0x00ff), NULL }, *//* enable interrupts */
+			     {mk_mii_write(MII_REG_CR, PHY_BMCR_RST_NEG), NULL},	/* autonegotiate */
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* ack_int */
+
+			     {mk_mii_read(MII_AM79C875_ICR), NULL},
+			     {mk_mii_read(MII_REG_SR), mii_parse_sr},
+			     {mk_mii_read(MII_REG_ANAR), mii_parse_anar},
+			     {mk_mii_read(MII_REG_ANLPAR),
+			      mii_parse_Am79C874_pcr},
+			     {mk_mii_end,}
+			     },
+	(const phy_cmd_t[]) {	/* shutdown - nothing */
+			     {mk_mii_end,}
+			     },
+};
+
+/* ------------------------------------------------------------------------- */
+
+static phy_info_t *phy_info[] = {
+
+	&phy_info_dp83843,
+	&phy_info_lxt971a,
+	&phy_info_cs8952,
+	&phy_info_dp83846A,
+	&phy_info_lu3x31ft,
+	&phy_info_Am79C875,
+	&phy_info_bcm5221,
+	&phy_info_Am79C874,
+	&phy_info_Am79C875A,
+	NULL
+};
+
+void
+mii_display_status(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	volatile uint *s = &(fep->phy_status);
+	fep->phy_speed = _10BASET;
+	fep->phy_duplex = HALF;
+
+	/* Link is still down - don't print anything */
+	if (!fep->link && !fep->old_link)
+		return;
+
+	printk("IBM EMAC: %s: ", dev->name);
+
+	if (!fep->link)
+		printk("link down");
+	else {
+		printk("link up");
+
+		switch (*s & PHY_STAT_SPMASK) {
+		case PHY_STAT_100FDX:
+			printk(", 100 Mbps FDX");
+			fep->phy_speed = _100BASET;
+			fep->phy_duplex = FULL;
+			break;
+		case PHY_STAT_100HDX:
+			printk(", 100 Mbps HDX");
+			fep->phy_speed = _100BASET;
+			break;
+		case PHY_STAT_10FDX:
+			printk(", 10 Mbps FDX");
+			fep->phy_duplex = FULL;
+			break;
+		case PHY_STAT_10HDX:
+			printk(", 10 Mbps HDX");
+			break;
+		default:
+			printk(", Unknown speed/duplex");
+		}
+
+		if (*s & PHY_STAT_ANC)
+			printk(", auto-negotiation complete");
+		printk(".\n");
+	}
+
+	if (*s & PHY_STAT_FAULT)
+		printk(", remote fault.\n");
+}
+
+/*
+ * Check if there is a valid PHY connected at address phnum.
+ */
+static int check_phy(struct net_device *dev, int phnum)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	uint phy_reg;
+	int i;
+
+	fep->phy_addr = phnum;
+	if (ocp_enet_mdio_read(dev, mk_mii_read(MII_REG_PHYIR1), &phy_reg))
+		return 0;
+
+	ppc405_phy_dump(dev);
+
+	/* Got 2nd part of ID, now get remainder. */
+	fep->phy_id = (phy_reg & 0xffff) << 16;
+
+	if (ocp_enet_mdio_read(dev, mk_mii_read(MII_REG_PHYIR2), &phy_reg)) {
+		if (phnum == MIN_PHY_ADDR)
+			printk(KERN_ERR "%s: Got bad Phy Read, missing MDIO pullup?\n",
+			       dev->name);
+		return 0;
+	}
+
+	fep->phy_id |= (phy_reg & 0xffff);
+
+	for (i = 0; phy_info[i]; i++)
+		if (phy_info[i]->id == (fep->phy_id >> phy_info[i]->shift))
+			break;
+	if (!phy_info[i]) {
+		printk(KERN_ERR "%s: PHY id 0x%08x is not supported!\n",
+		       dev->name, fep->phy_id);
+		return 0;
+	}
+
+	fep->phy = phy_info[i];
+
+	printk("IBM EMAC: %s: Phy @ 0x%x, type %s (0x%08x)\n",
+	       dev->name, fep->phy_addr, fep->phy->name, fep->phy_id);
+	return 1;
+}
+
+/* Scan all valid PHY addresses looking for someone to respond
+ * with a valid ID.  This usually happens quickly. This eliminated
+ * the need to pass in the addr & PHY name
+ */
+void
+find_phy(struct net_device *dev)
+{
+	int i;
+
+	for (i = next_phy_available; i <= MAX_PHY_ADDR; i++)
+		if (check_phy(dev, i)){
+			next_phy_available = i + 1;
+			return;
+		}
+	printk("%s: No PHY device found.\n", dev->name);
+}
+/*	this decreaments the next_phy_available 
+ *	This is a temp work arround
+ *	armin
+ */
+int
+free_phy(struct net_device *dev)
+{
+	if (next_phy_available-- == MIN_PHY_ADDR)
+		next_phy_available =  MIN_PHY_ADDR;
+	return(next_phy_available);
+
+}
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_phy.h
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_phy.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_phy.h	2002-09-20 07:16:31.000000000 +0000
@@ -0,0 +1,156 @@
+
+/*
+ * ibm_ocp_phy.h
+ *
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      June, 2002
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Version: 1.0: armin
+ *  moved phy defines out of enet.h
+ *
+ */
+
+#ifndef _IBM_OCP_PHY_H_
+#define _IBM_OCP_PHY_H_
+
+#define mk_mii_end			0
+
+typedef struct mii_list {
+	uint mii_regval;
+	void (*mii_func) (uint val, struct net_device * dev);
+	struct mii_list *mii_next;
+} mii_list_t;
+
+typedef struct {
+	uint mii_data;
+	void (*funct) (uint mii_reg, struct net_device * dev);
+} phy_cmd_t;
+
+typedef struct {
+	uint id;
+	char *name;
+	uint shift;
+	const phy_cmd_t *config;
+	const phy_cmd_t *startup;
+	const phy_cmd_t *ack_int;
+	const phy_cmd_t *shutdown;
+} phy_info_t;
+
+extern void process_mii_queue(struct net_device *dev);
+extern void mii_do_cmd(struct net_device *dev, const phy_cmd_t * c);
+extern void mii_display_status(struct net_device *dev);
+extern void find_phy(struct net_device *dev);
+extern int free_phy(struct net_device *dev);
+extern mii_list_t *mii_free;
+extern mii_list_t *mii_nead;
+extern mii_list_t *mii_tail;
+
+/* phy register offsets */
+#define PHY_BMCR			0x00
+#define PHY_BMS				0x01
+#define PHY_PHY1DR1			0x02
+#define PHY_PHYIDR2			0x03
+#define PHY_ANAR			0x04
+#define PHY_ANLPAR			0x05
+#define PHY_ANER			0x06
+#define PHY_ANNPTR			0x07
+#define PHY_PHYSTS			0x10
+#define PHY_MIPSCR			0x11
+#define PHY_MIPGSR			0x12
+#define PHY_DCR				0x13
+#define PHY_FCSCR			0x14
+#define PHY_RECR			0x15
+#define PHY_PCSR			0x16
+#define PHY_LBR				0x17
+#define PHY_10BTSCR			0x18
+#define PHY_PHYCTRL			0x19
+
+/* PHY BMCR */
+#define PHY_BMCR_RESET			0x8000
+#define PHY_BMCR_LOOP			0x4000
+#define PHY_BMCR_100MB			0x2000
+#define PHY_BMCR_AUTON			0x1000
+#define PHY_BMCR_POWD			0x0800
+#define PHY_BMCR_ISO			0x0400
+#define PHY_BMCR_RST_NEG		0x0200
+#define PHY_BMCR_DPLX			0x0100
+#define PHY_BMCR_COL_TST		0x0080
+
+/* phy BMSR */
+#define PHY_BMSR_100T4			0x8000
+#define PHY_BMSR_100TXF			0x4000
+#define PHY_BMSR_100TXH			0x2000
+#define PHY_BMSR_10TF			0x1000
+#define PHY_BMSR_10TH			0x0800
+#define PHY_BMSR_PRE_SUP		0x0040
+#define PHY_BMSR_AUTN_COMP		0x0020
+#define PHY_BMSR_RF			0x0010
+#define PHY_BMSR_AUTN_ABLE		0x0008
+#define PHY_BMSR_LS			0x0004
+#define PHY_BMSR_JD			0x0002
+#define PHY_BMSR_EXT			0x0001
+
+/* phy ANAR */
+#define PHY_ANAR_NP			0x8000	/* Next page indication */
+#define PHY_ANAR_RF			0x2000	/* Remote Fault */
+#define PHY_ANAR_FDFC			0x0400	/* Full Duplex control */
+#define PHY_ANAR_T4			0x0200	/* 100BASE-T4 supported */
+#define PHY_ANAR_TX_FD			0x0100	/* 100BASE-TX Full duplex supported */
+#define PHY_ANAR_TX			0x0080	/* 100BASE-TX supported */
+#define PHY_ANAR_10_FD			0x0040	/* 10BASE-T Full duplex supported */
+#define PHY_ANAR_10			0x0020	/* 10BASE-T Supported */
+#define PHY_ANAR_SEL			0x0010	/* Protocol selection bits  */
+
+/* phy ANLPAR */
+#define PHY_ANLPAR_NP			0x8000
+#define PHY_ANLPAR_ACK			0x4000
+#define PHY_ANLPAR_RF			0x2000
+#define PHY_ANLPAR_T4			0x0200
+#define PHY_ANLPAR_TXFD			0x0100
+#define PHY_ANLPAR_TX			0x0080
+#define PHY_ANLPAR_10FD			0x0040
+#define PHY_ANLPAR_10			0x0020
+#define PHY_ANLPAR_100			0x0380	/* we can run at 100 */
+
+/* phy status PHYSTS */
+
+#define PHY_PHYSTS_RLE			0x8000	/* Receive error latch 1: rx error */
+#define PHY_PHYSTS_CIM			0x4000	/* Carrier Integrity 1: False carrier */
+#define PHY_PHYSTS_FC 			0x2000	/* False carrier 1: false carrier */
+#define PHY_PHYSTS_DR 			0x0800	/* Device ready 1: ready 0: not */
+#define PHY_PHYSTS_PR 			0x0400	/* Page received 1: new page code */
+#define PHY_PHYSTS_AN 			0x0200	/* Auto Negociate Enabled 1: enabled 0: disabled  */
+#define PHY_PHYSTS_MI 			0x0100	/* MII interrupt pending */
+#define PHY_PHYSTS_RF 			0x0080	/* Remote fault 1: fault 0: no falut */
+#define PHY_PHYSTS_JD 			0x0040	/* Jabber detect 1:jabber 0: no jabber */
+#define PHY_PHYSTS_NWC			0x0020	/* Auto negociate complete 1: done 0:not */
+#define PHY_PHYSTS_RS	 		0x0010	/* Reset Status 1: in progress 0: normal */
+#define PHY_PHYSTS_LBS			0x0008	/* Loopback 1:LB enabled 0:disabled */
+#define PHY_PHYSTS_DS 			0x0004	/* Duplex status 1:FD 0: HD */
+#define PHY_PHYSTS_SS 			0x0002	/* Speed status 1:10 0:100 */
+#define PHY_PHYSTS_LS 			0x0001	/* Link status 1: valid 0: no link */
+
+#endif				/* _IBM_OCP_PHY_H_ */
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_zmii.c
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ibm_ocp_zmii.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ibm_ocp_zmii.c	2003-01-06 09:11:42.000000000 +0000
@@ -0,0 +1,129 @@
+/*
+ * ibm_ocp_zmii.c
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Sept, 2001
+ *
+ * Copyright 2002 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/netdevice.h>
+
+#include <asm/ocp.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+
+#include "ocp_zmii.h"
+#include "ibm_ocp_enet.h"
+
+static unsigned int zmii_enable[][4] = {
+	{ZMII_SMII0, ZMII_RMII0, ZMII_MII0,
+	 ~(ZMII_MDI1 | ZMII_MDI2 | ZMII_MDI3)},
+	{ZMII_SMII1, ZMII_RMII1, ZMII_MII1,
+	 ~(ZMII_MDI0 | ZMII_MDI2 | ZMII_MDI3)},
+	{ZMII_SMII2, ZMII_RMII2, ZMII_MII2,
+	 ~(ZMII_MDI0 | ZMII_MDI1 | ZMII_MDI3)},
+	{ZMII_SMII3, ZMII_RMII3, ZMII_MII3, ~(ZMII_MDI0 | ZMII_MDI1 | ZMII_MDI2)}
+};
+static unsigned int mdi_enable[] =
+    { ZMII_MDI0, ZMII_MDI1, ZMII_MDI2, ZMII_MDI3 };
+
+static unsigned int zmii_speed = 0x0;
+static unsigned int zmii_speed100[] = { ZMII_MII0_100MB, ZMII_MII1_100MB };
+
+void
+zmii_enable_port(struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	zmii_t *zmiip = fep->zmii_base;
+	int emac_num = (fep->ocpdev)->num;
+	unsigned int mask;
+
+	mask = in_be32(&zmiip->fer);
+
+	mask &= zmii_enable[emac_num][MDI];	/* turn all non enable MDI's off */
+	mask |= zmii_enable[emac_num][fep->zmii_mode]
+	    | mdi_enable[emac_num];
+	out_be32(&zmiip->fer, mask);
+
+#ifdef EMAC_DEBUG
+	printk("EMAC# %d zmiip 0x%x  = 0x%x\n", emac_num, zmiip,
+	       zmiip->fer);
+#endif
+}
+
+void
+zmii_set_port_speed(int speed, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	int emac_num = (fep->ocpdev)->num;
+	zmii_t *zmiip = fep->zmii_base;
+
+	if (speed == 100)
+		zmii_speed |= zmii_speed100[emac_num];
+
+	out_be32(&zmiip->ssr, zmii_speed);
+	return;
+}
+
+int
+zmii_init(int mode, struct net_device *dev)
+{
+	struct ocp_enet_private *fep = dev->priv;
+	struct zmii_regs *zmiip;
+	char *mode_name[] = { "SMII", "RMII", "MII" };
+
+	/*
+	 * FIXME: Need to handle multiple ZMII case that worked
+	 * in the older code.  This is a kludge.
+	 */
+	fep->zmii_ocpdev = ocp_get_dev(OCP_FUNC_ZMII, 0);
+
+	zmiip = (struct zmii_regs *)
+	    __ioremap((fep->zmii_ocpdev)->paddr, sizeof (*zmiip), _PAGE_NO_CACHE);
+
+	fep->zmii_base = zmiip;
+	fep->zmii_mode = mode;
+	if (mode == ZMII_AUTO) {
+		if (zmiip->fer & (ZMII_MII0 | ZMII_MII1 | 
+				  ZMII_MII2 | ZMII_MII3))
+			fep->zmii_mode = MII;
+		if (zmiip->fer & (ZMII_RMII0 | ZMII_RMII1 |
+				  ZMII_RMII2 | ZMII_RMII3))
+			fep->zmii_mode = RMII;
+		if (zmiip->fer & (ZMII_SMII0 | ZMII_SMII1 |
+				  ZMII_SMII2 | ZMII_SMII3))
+			fep->zmii_mode = SMII;
+
+		/* Failsafe: ZMII_AUTO is invalid index into the arrays,
+		   so force SMII if all else fails. */
+
+		if (fep->zmii_mode == ZMII_AUTO)
+			fep->zmii_mode = SMII;
+	}
+
+	printk(KERN_NOTICE "IBM ZMII: %s mode\n",
+			mode_name[fep->zmii_mode]);
+	return (fep->zmii_mode);
+}
diff -purN /dev/shm/linux-2.5/drivers/net/ibm_ocp/ocp_zmii.h linuxppc-2.5-benh/drivers/net/ibm_ocp/ocp_zmii.h
--- /dev/shm/linux-2.5/drivers/net/ibm_ocp/ocp_zmii.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/ibm_ocp/ocp_zmii.h	2002-11-07 20:31:58.000000000 +0000
@@ -0,0 +1,113 @@
+/*
+ * ocp_zmii.h
+ *
+ * Defines for the IBM ZMII bridge
+ *
+ *      Armin Kuster akuster@mvista.com
+ *      Dec, 2001
+ *
+ * Copyright 2001 MontaVista Softare Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR   IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  V 1.2 (04/19/02 ) - Armin
+ *    added support for emac 2 & 3
+ */
+
+#ifndef _OCP_ZMII_H_
+#define _OCP_ZMII_H_
+
+#include <linux/config.h>
+
+#ifdef CONFIG_IBM_OCP_ZMII
+int zmii_init(int, struct net_device *);
+void zmii_enable_port(struct net_device *);
+void zmii_set_port_speed(int speed, struct net_device *);
+#else
+#define zmii_init(x,y)
+#define zmii_enable_port(x)
+#define zmii_set_port_speed(x,y)
+#endif
+
+/* ZMII bridge */
+typedef struct zmii_regs {
+	u32 fer;		/* Function enable reg */
+	u32 ssr;		/* Spedd select reg */
+	u32 smiirs;		/* SMII status reg */
+} zmii_t;
+
+
+/* Fuctional Enable Reg */
+
+#define ZMII_MDI0	0x80000000
+#define ZMII_SMII0	0x40000000
+#define ZMII_RMII0	0x20000000
+#define ZMII_MII0	0x10000000
+#define ZMII_MDI1	0x08000000
+#define ZMII_SMII1	0x04000000
+#define ZMII_RMII1	0x02000000
+#define ZMII_MII1	0x01000000
+#define ZMII_MDI2	0x00800000
+#define ZMII_SMII2	0x00400000
+#define ZMII_RMII2	0x00200000
+#define ZMII_MII2	0x00100000
+#define ZMII_MDI3	0x00080000
+#define ZMII_SMII3	0x00040000
+#define ZMII_RMII3	0x00020000
+#define ZMII_MII3	0x00010000
+
+/* Speed Selection reg */
+
+#define ZMII_SCI0	0x40000000
+#define ZMII_FSS0	0x20000000
+#define ZMII_SP0	0x10000000
+#define ZMII_SCI1	0x04000000
+#define ZMII_FSS1	0x02000000
+#define ZMII_SP1	0x01000000
+#define ZMII_SCI2	0x00400000
+#define ZMII_FSS2	0x00200000
+#define ZMII_SP2	0x00100000
+#define ZMII_SCI3	0x00040000
+#define ZMII_FSS3	0x00020000
+#define ZMII_SP3	0x00010000
+
+#define ZMII_MII0_100MB	ZMII_SP0
+#define ZMII_MII0_10MB	~ZMII_SP0
+#define ZMII_MII1_100MB	ZMII_SP1
+#define ZMII_MII1_10MB	~ZMII_SP1
+#define ZMII_MII2_100MB	ZMII_SP2
+#define ZMII_MII2_10MB	~ZMII_SP2
+#define ZMII_MII3_100MB	ZMII_SP3
+#define ZMII_MII3_10MB	~ZMII_SP3
+
+/* SMII Status reg */
+
+#define ZMII_STS0 0xFF000000	/* EMAC0 smii status mask */
+#define ZMII_STS1 0x00FF0000	/* EMAC1 smii status mask */
+
+
+#define SMII	0
+#define RMII	1
+#define MII	2
+#define MDI	3
+#define ZMII_AUTO 4
+
+#endif				/* _OCP_ZMII_H_ */
diff -purN /dev/shm/linux-2.5/drivers/net/mace.c linuxppc-2.5-benh/drivers/net/mace.c
--- /dev/shm/linux-2.5/drivers/net/mace.c	2003-09-22 01:01:09.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/mace.c	2004-01-29 05:02:08.000000000 +0000
@@ -20,9 +20,10 @@
 #include <asm/dbdma.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>
+#include <asm/macio.h>
+
 #include "mace.h"
 
-static struct net_device *mace_devs;
 static int port_aaui = -1;
 
 #define N_RX_RING	8
@@ -61,8 +62,7 @@ struct mace_data {
     int timeout_active;
     int port_aaui;
     int chipid;
-    struct device_node* of_node;
-    struct net_device *next_mace;
+    struct macio_dev *mdev;
     spinlock_t lock;
 };
 
@@ -76,8 +76,6 @@ struct mace_data {
 	+ (N_RX_RING + NCMDS_TX * N_TX_RING + 3) * sizeof(struct dbdma_cmd))
 
 static int bitrev(int);
-static int mace_probe(void);
-static void mace_probe1(struct device_node *mace);
 static int mace_open(struct net_device *dev);
 static int mace_close(struct net_device *dev);
 static int mace_xmit_start(struct sk_buff *skb, struct net_device *dev);
@@ -110,26 +108,19 @@ bitrev(int b)
     return d;
 }
 
-static int __init mace_probe(void)
-{
-	struct device_node *mace;
-
-	for (mace = find_devices("mace"); mace != NULL; mace = mace->next)
-		mace_probe1(mace);
-	return mace_devs? 0: -ENODEV;
-}
 
-static void __init mace_probe1(struct device_node *mace)
+static int __devinit mace_probe(struct macio_dev *mdev, const struct of_match *match)
 {
-	int j, rev;
+	struct device_node *mace = macio_get_of_node(mdev);
 	struct net_device *dev;
 	struct mace_data *mp;
 	unsigned char *addr;
+	int j, rev, rc = -EBUSY;
 
-	if (mace->n_addrs != 3 || mace->n_intrs != 3) {
+	if (macio_resource_count(mdev) != 3 || macio_irq_count(mdev) != 3) {
 		printk(KERN_ERR "can't use MACE %s: need 3 addrs and 3 irqs\n",
 		       mace->full_name);
-		return;
+		return -ENODEV;
 	}
 
 	addr = get_property(mace, "mac-address", NULL);
@@ -138,44 +129,48 @@ static void __init mace_probe1(struct de
 		if (addr == NULL) {
 			printk(KERN_ERR "Can't get mac-address for MACE %s\n",
 			       mace->full_name);
-			return;
+			return -ENODEV;
 		}
 	}
 
+	/*
+	 * lazy allocate the driver-wide dummy buffer. (Note that we
+	 * never have more than one MACE in the system anyway)
+	 */
 	if (dummy_buf == NULL) {
 		dummy_buf = kmalloc(RX_BUFLEN+2, GFP_KERNEL);
 		if (dummy_buf == NULL) {
 			printk(KERN_ERR "MACE: couldn't allocate dummy buffer\n");
-			return;
+			return -ENOMEM;
 		}
 	}
 
-	dev = init_etherdev(0, PRIV_BYTES);
-	if (!dev)
-		return;
+	if (macio_request_resources(mdev, "mace")) {
+		printk(KERN_ERR "MACE: can't request IO resources !\n");
+		return -EBUSY;
+	}
+
+	dev = alloc_etherdev(PRIV_BYTES);
+	if (!dev) {
+		printk(KERN_ERR "MACE: can't allocate ethernet device !\n");
+		rc = -ENOMEM;
+		goto err_release;
+	}
 	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &mdev->ofdev.dev);
 
 	mp = dev->priv;
-	mp->of_node = mace;
-	
-	if (!request_OF_resource(mace, 0, " (mace)")) {
-		printk(KERN_ERR "MACE: can't request IO resource !\n");
-		goto err_out;
-	}
-	if (!request_OF_resource(mace, 1, " (mace tx dma)")) {
-		printk(KERN_ERR "MACE: can't request TX DMA resource !\n");
-		goto err_out;
-	}
-
-	if (!request_OF_resource(mace, 2, " (mace tx dma)")) {
-		printk(KERN_ERR "MACE: can't request RX DMA resource !\n");
-		goto err_out;
-	}
-
-	dev->base_addr = mace->addrs[0].address;
-	mp->mace = (volatile struct mace *)
-		ioremap(mace->addrs[0].address, 0x1000);
-	dev->irq = mace->intrs[0].line;
+	mp->mdev = mdev;
+	macio_set_drvdata(mdev, dev);
+
+	dev->base_addr = macio_resource_start(mdev, 0);
+	mp->mace = (volatile struct mace *)ioremap(dev->base_addr, 0x1000);
+	if (mp->mace == NULL) {
+		printk(KERN_ERR "MACE: can't map IO resources !\n");
+		rc = -ENOMEM;
+		goto err_free;
+	}
+	dev->irq = macio_irq(mdev, 0);
 
 	printk(KERN_INFO "%s: MACE at", dev->name);
 	rev = addr[0] == 0 && addr[1] == 0xA0;
@@ -190,12 +185,24 @@ static void __init mace_probe1(struct de
 
 	mp = (struct mace_data *) dev->priv;
 	mp->maccc = ENXMT | ENRCV;
+
 	mp->tx_dma = (volatile struct dbdma_regs *)
-		ioremap(mace->addrs[1].address, 0x1000);
-	mp->tx_dma_intr = mace->intrs[1].line;
+		ioremap(macio_resource_start(mdev, 1), 0x1000);
+	if (mp->tx_dma == NULL) {
+		printk(KERN_ERR "MACE: can't map TX DMA resources !\n");
+		rc = -ENOMEM;
+		goto err_unmap_io;
+	}
+	mp->tx_dma_intr = macio_irq(mdev, 1);
+
 	mp->rx_dma = (volatile struct dbdma_regs *)
-		ioremap(mace->addrs[2].address, 0x1000);
-	mp->rx_dma_intr = mace->intrs[2].line;
+		ioremap(macio_resource_start(mdev, 2), 0x1000);
+	if (mp->rx_dma == NULL) {
+		printk(KERN_ERR "MACE: can't map RX DMA resources !\n");
+		rc = -ENOMEM;
+		goto err_unmap_tx_dma;
+	}
+	mp->rx_dma_intr = macio_irq(mdev, 2);;
 
 	mp->tx_cmds = (volatile struct dbdma_cmd *) DBDMA_ALIGN(mp + 1);
 	mp->rx_cmds = mp->tx_cmds + NCMDS_TX * N_TX_RING + 1;
@@ -229,31 +236,81 @@ static void __init mace_probe1(struct de
 	dev->set_multicast_list = mace_set_multicast;
 	dev->set_mac_address = mace_set_address;
 
-	ether_setup(dev);
-
+	/*
+	 * Most of what is below could be moved to mace_open()
+	 */
 	mace_reset(dev);
 
-	if (request_irq(dev->irq, mace_interrupt, 0, "MACE", dev))
+	rc = request_irq(dev->irq, mace_interrupt, 0, "MACE", dev);
+	if (rc) {
 		printk(KERN_ERR "MACE: can't get irq %d\n", dev->irq);
-	if (request_irq(mace->intrs[1].line, mace_txdma_intr, 0, "MACE-txdma",
-			dev))
+		goto err_unmap_rx_dma;
+	}
+	rc = request_irq(mp->tx_dma_intr, mace_txdma_intr, 0, "MACE-txdma", dev);
+	if (rc) {
 		printk(KERN_ERR "MACE: can't get irq %d\n", mace->intrs[1].line);
-	if (request_irq(mace->intrs[2].line, mace_rxdma_intr, 0, "MACE-rxdma",
-			dev))
+		goto err_free_irq;
+	}
+	rc = request_irq(mp->rx_dma_intr, mace_rxdma_intr, 0, "MACE-rxdma", dev);
+	if (rc) {
 		printk(KERN_ERR "MACE: can't get irq %d\n", mace->intrs[2].line);
+		goto err_free_tx_irq;
+	}
+
+	rc = register_netdev(dev);
+	if (rc) {
+		printk(KERN_ERR "Cannot register net device, aborting.\n");
+		goto err_free_rx_irq;
+	}
+
+	return 0;
+ 
+ err_free_rx_irq:
+	free_irq(macio_irq(mdev, 2), dev);
+ err_free_tx_irq:
+	free_irq(macio_irq(mdev, 1), dev);
+ err_free_irq:
+	free_irq(macio_irq(mdev, 0), dev);
+ err_unmap_rx_dma:
+	iounmap((void*)mp->rx_dma);
+ err_unmap_tx_dma:
+	iounmap((void*)mp->tx_dma);
+ err_unmap_io:
+	iounmap((void*)mp->mace);
+ err_free:
+	free_netdev(dev);
+ err_release:
+	macio_release_resources(mdev);
+
+	return rc;
+}
+
+static int __devexit mace_remove(struct macio_dev *mdev)
+{
+	struct net_device *dev = macio_get_drvdata(mdev);
+	struct mace_data *mp;
+
+	BUG_ON(dev == NULL);
+
+	macio_set_drvdata(mdev, NULL);
+
+	mp = dev->priv;
 
-	mp->next_mace = mace_devs;
-	mace_devs = dev;
-	return;
-	
-err_out:
 	unregister_netdev(dev);
-	if (mp->of_node) {
-		release_OF_resource(mp->of_node, 0);
-		release_OF_resource(mp->of_node, 1);
-		release_OF_resource(mp->of_node, 2);
-	}
+
+	free_irq(dev->irq, dev);
+	free_irq(mp->tx_dma_intr, dev);
+	free_irq(mp->rx_dma_intr, dev);
+
+	iounmap((void*)mp->rx_dma);
+	iounmap((void*)mp->tx_dma);
+	iounmap((void*)mp->mace);
+
 	free_netdev(dev);
+
+	macio_release_resources(mdev);
+
+	return 0;
 }
 
 static void dbdma_reset(volatile struct dbdma_regs *dma)
@@ -951,37 +1008,45 @@ static irqreturn_t mace_rxdma_intr(int i
     return IRQ_HANDLED;
 }
 
-MODULE_AUTHOR("Paul Mackerras");
-MODULE_DESCRIPTION("PowerMac MACE driver.");
-MODULE_PARM(port_aaui, "i");
-MODULE_PARM_DESC(port_aaui, "MACE uses AAUI port (0-1)");
-MODULE_LICENSE("GPL");
+static struct of_match mace_match[] = 
+{
+	{
+	.name 		= "mace",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH
+	},
+	{},
+};
 
-static void __exit mace_cleanup (void)
+static struct macio_driver mace_driver = 
 {
-    struct net_device *dev;
-    struct mace_data *mp;
+	.name 		= "mace",
+	.match_table	= mace_match,
+	.probe		= mace_probe,
+	.remove		= mace_remove,
+};
 
-    while ((dev = mace_devs) != 0) {
-		mp = (struct mace_data *) mace_devs->priv;
-		mace_devs = mp->next_mace;
 
-		unregister_netdev(dev);
-		free_irq(dev->irq, dev);
-		free_irq(mp->tx_dma_intr, dev);
-		free_irq(mp->rx_dma_intr, dev);
+static int __init mace_init(void)
+{
+	return macio_register_driver(&mace_driver);
+}
 
-		release_OF_resource(mp->of_node, 0);
-		release_OF_resource(mp->of_node, 1);
-		release_OF_resource(mp->of_node, 2);
+static void __exit mace_cleanup(void)
+{
+	macio_unregister_driver(&mace_driver);
 
-		kfree(dev);
-    }
-    if (dummy_buf != NULL) {
+	if (dummy_buf) {
 		kfree(dummy_buf);
 		dummy_buf = NULL;
-    }
+	}
 }
 
-module_init(mace_probe);
+MODULE_AUTHOR("Paul Mackerras");
+MODULE_DESCRIPTION("PowerMac MACE driver.");
+MODULE_PARM(port_aaui, "i");
+MODULE_PARM_DESC(port_aaui, "MACE uses AAUI port (0-1)");
+MODULE_LICENSE("GPL");
+
+module_init(mace_init);
 module_exit(mace_cleanup);
diff -purN /dev/shm/linux-2.5/drivers/net/pcnet32.c linuxppc-2.5-benh/drivers/net/pcnet32.c
--- /dev/shm/linux-2.5/drivers/net/pcnet32.c	2003-12-07 18:58:47.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/pcnet32.c	2003-12-31 04:25:14.000000000 +0000
@@ -541,8 +541,10 @@ pcnet32_probe1(unsigned long ioaddr, uns
 	pcnet32_dwio_reset(ioaddr);
 	if (pcnet32_dwio_read_csr(ioaddr, 0) == 4 && pcnet32_dwio_check(ioaddr)) {
 	    a = &pcnet32_dwio;
-	} else
+	} else {
+		printk(KERN_INFO "pcnet32: probe at %lx failed\n", ioaddr);
 		goto err_release_region;
+	}
     }
 
     chip_version = a->read_csr(ioaddr, 88) | (a->read_csr(ioaddr,89) << 16);
diff -purN /dev/shm/linux-2.5/drivers/net/smc91111.c linuxppc-2.5-benh/drivers/net/smc91111.c
--- /dev/shm/linux-2.5/drivers/net/smc91111.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/smc91111.c	2002-08-27 14:33:38.000000000 +0000
@@ -0,0 +1,3693 @@
+/*------------------------------------------------------------------------
+ . smc91111.c
+ . This is a driver for SMSC's 91C111 single-chip Ethernet device.
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ .
+ . "Features" of the SMC chip:
+ .   Integrated PHY/MAC for 10/100BaseT Operation
+ .   Supports internal and external MII
+ .   Integrated 8K packet memory
+ .   EEPROM interface for configuration
+ .
+ . Arguments:
+ . 	io	= for the base address
+ .	irq	= for the IRQ
+ .	nowait	= 0 for normal wait states, 1 eliminates additional wait states
+ .
+ . author:
+ . 	Erik Stahlman				( erik@vt.edu )
+ . 	Daris A Nevil				( dnevil@snmc.com )
+ . contributors:
+ .      Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ .
+ . Hardware multicast code from Peter Cammaert ( pc@denkart.be )
+ .
+ . Sources:
+ .    o   SMSC LAN91C111 databook (www.smsc.com)
+ .    o   smc9194.c by Erik Stahlman
+ .    o   skeleton.c by Donald Becker ( becker@scyld.com )
+ .
+ . History:
+ .      08/20/00  Arnaldo Melo   fix kfree(skb) in smc_hardware_send_packet
+ .      12/15/00  Christian Jullien fix "Warning: kfree_skb on hard IRQ"
+ .	04/25/01  Daris A Nevil  Initial public release through SMSC
+ .	03/16/01  Daris A Nevil  Modified smc9194.c for use with LAN91C111
+ .	08/22/01  Scott Anderson Merge changes from smc9194 to smc91111
+ ----------------------------------------------------------------------------*/
+
+// Use power-down feature of the chip
+#define POWER_DOWN	1
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+#ifndef SMC_DEBUG
+#define SMC_DEBUG 0
+#endif
+
+static const char version[] =
+	"smc91111.c:v1.0saa 08/22/01 by Daris A Nevil (dnevil@snmc.com)\n";
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#endif
+
+#include "smc91111.h"
+
+#ifdef CONFIG_ISA
+
+/*
+ .the LAN91C111 can be at any of the following port addresses.  To change,
+ .for a slightly different card, you can add it to the array.  Keep in
+ .mind that the array must end in zero.
+*/
+static unsigned int smc_portlist[] __initdata = {
+	0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
+	0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0
+};
+
+#endif  /* CONFIG_ISA */
+
+static struct net_device *global_dev = NULL;
+#ifndef SMC91111_BASE_ADDR
+# define SMC91111_BASE_ADDR -1
+#endif
+static int io = SMC91111_BASE_ADDR;
+#ifndef SMC91111_IRQ
+# define SMC91111_IRQ -1
+#endif
+static int irq = SMC91111_IRQ;
+static int nowait = 0;
+
+MODULE_PARM(io, "i");
+MODULE_PARM(irq, "i");
+MODULE_PARM(nowait, "i");
+MODULE_PARM_DESC(io, "SMC 91111 I/O base address");
+MODULE_PARM_DESC(irq, "SMC 91111 IRQ number");
+
+/*
+ . Wait time for memory to be free.  This probably shouldn't be
+ . tuned that much, as waiting for this means nothing else happens
+ . in the system
+*/
+#define MEMORY_WAIT_TIME 16
+
+#if SMC_DEBUG > 2
+#define PRINTK3(args...) printk(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printk(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#if SMC_DEBUG > 0
+#define PRINTK(args...) printk(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.  If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+#define CARDNAME "LAN91C111"
+
+// Memory sizing constant
+#define LAN91C111_MEMORY_MULTIPLIER	(1024*2)
+
+/* store this information for the driver.. */
+struct smc_local {
+
+ 	// these are things that the kernel wants me to keep, so users
+	// can find out semi-useless statistics of how well the card is
+	// performing
+	struct net_device_stats stats;
+
+	// If I have to wait until memory is available to send
+	// a packet, I will store the skbuff here, until I get the
+	// desired memory.  Then, I'll send it out and free it.
+	struct sk_buff * saved_skb;
+
+ 	// This keeps track of how many packets that I have
+ 	// sent out.  When an TX_EMPTY interrupt comes, I know
+	// that all of these have been sent.
+	int	packets_waiting;
+
+	// Set to true during the auto-negotiation sequence
+	int	autoneg_active;
+
+	// Address of our PHY port
+	word	phyaddr;
+
+	// Type of PHY
+	word	phytype;
+
+	// Last contents of PHY Register 18
+	word	lastPhy18;
+
+	// Contains the current active transmission mode
+	word	tcr_cur_mode;
+
+	// Contains the current active receive mode
+	word	rcr_cur_mode;
+
+	// Contains the current active receive/phy mode
+	word	rpc_cur_mode;
+
+
+#ifdef CONFIG_SYSCTL
+
+	// Root directory /proc/sys/dev
+	// Second entry must be null to terminate the table
+	ctl_table root_table[2];
+
+	// Directory for this device /proc/sys/dev/ethX
+	// Again the second entry must be zero to terminate
+	ctl_table eth_table[2];
+
+	// This is the parameters (file) table
+	ctl_table param_table[CTL_SMC_LAST_ENTRY];
+
+	// Saves the sysctl header returned by register_sysctl_table()
+	// we send this to unregister_sysctl_table()
+	struct ctl_table_header *sysctl_header;
+
+	// Parameter variables (files) go here
+	char ctl_info[1024];
+	int ctl_swfdup;
+	int ctl_ephloop;
+	int ctl_miiop;
+	int ctl_autoneg;
+	int ctl_rfduplx;
+	int ctl_rspeed;
+	int ctl_afduplx;
+	int ctl_aspeed;
+	int ctl_lnkfail;
+	int ctl_forcol;
+	int ctl_filtcar;
+	int ctl_freemem;
+	int ctl_totmem;
+	int ctl_leda;
+	int ctl_ledb;
+	int ctl_chiprev;
+#if SMC_DEBUG > 0
+	int ctl_reg_bsr;
+	int ctl_reg_tcr;
+	int ctl_reg_esr;
+	int ctl_reg_rcr;
+	int ctl_reg_ctrr;
+	int ctl_reg_mir;
+	int ctl_reg_rpcr;
+	int ctl_reg_cfgr;
+	int ctl_reg_bar;
+	int ctl_reg_iar0;
+	int ctl_reg_iar1;
+	int ctl_reg_iar2;
+	int ctl_reg_gpr;
+	int ctl_reg_ctlr;
+	int ctl_reg_mcr;
+	int ctl_reg_pnr;
+	int ctl_reg_fpr;
+	int ctl_reg_ptr;
+	int ctl_reg_dr;
+	int ctl_reg_isr;
+	int ctl_reg_mtr1;
+	int ctl_reg_mtr2;
+	int ctl_reg_mtr3;
+	int ctl_reg_mtr4;
+	int ctl_reg_miir;
+	int ctl_reg_revr;
+	int ctl_reg_ercvr;
+	int ctl_reg_extr;
+	int ctl_phy_ctrl;
+	int ctl_phy_stat;
+	int ctl_phy_id1;
+	int ctl_phy_id2;
+	int ctl_phy_adc;
+	int ctl_phy_remc;
+	int ctl_phy_cfg1;
+	int ctl_phy_cfg2;
+	int ctl_phy_int;
+	int ctl_phy_mask;
+#endif // SMC_DEBUG > 0
+
+
+#endif // CONFIG_SYSCTL
+
+};
+
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+/*
+ . The kernel calls this function when someone wants to use the device,
+ . typically 'ifconfig ethX up'.
+*/
+static int smc_open(struct net_device *dev);
+
+/*
+ . Our watchdog timed out. Called by the networking layer
+*/
+static void smc_timeout(struct net_device *dev);
+
+/*
+ . This is called by the kernel in response to 'ifconfig ethX down'.  It
+ . is responsible for cleaning up everything that the open routine
+ . does, and maybe putting the card into a powerdown state.
+*/
+static int smc_close(struct net_device *dev);
+
+/*
+ . This routine allows the proc file system to query the driver's
+ . statistics.
+*/
+static struct net_device_stats * smc_query_statistics( struct net_device *dev);
+
+/*
+ . Finally, a call to set promiscuous mode ( for TCPDUMP and related
+ . programs ) and multicast modes.
+*/
+static void smc_set_multicast_list(struct net_device *dev);
+
+/*
+ . CRC compute
+ */
+static int crc32( char * s, int length );
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+static void smc_phy_configure(struct net_device* dev);
+
+/*---------------------------------------------------------------
+ .
+ . Interrupt level calls..
+ .
+ ----------------------------------------------------------------*/
+
+/*
+ . Handles the actual interrupt
+*/
+static void smc_interrupt(int irq, void *, struct pt_regs *regs);
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+inline static void smc_rcv( struct net_device *dev );
+/*
+ . This handles a TX interrupt, which is only called when an error
+ . relating to a packet is sent.
+*/
+inline static void smc_tx( struct net_device * dev );
+
+/*
+ . This handles interrupts generated from PHY register 18
+*/
+static void smc_phy_interrupt(struct net_device* dev);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+/*
+ . Test if a given location contains a chip, trying to cause as
+ . little damage as possible if it's not a SMC chip.
+*/
+static int smc_probe(struct net_device *dev, unsigned long ioaddr);
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+#define tx_done(dev) 1
+
+/* this is called to actually send the packet to the chip */
+static void smc_hardware_send_packet( struct net_device * dev );
+
+/* Since I am not sure if I will have enough room in the chip's ram
+ . to store the packet, I call this routine, which either sends it
+ . now, or generates an interrupt when the card is ready for the
+ . packet */
+static int  smc_wait_to_send_packet( struct sk_buff * skb, struct net_device *dev );
+
+/* this does a soft reset on the device */
+static void smc_reset( struct net_device* dev );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( struct net_device *dev );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( unsigned long ioaddr );
+
+/* This routine will find the IRQ of the driver if one is not
+ . specified in the input to the device.  */
+static int smc_findirq( unsigned long ioaddr );
+
+/* Routines to Read and Write the PHY Registers across the
+   MII Management Interface
+*/
+
+static word smc_read_phy_register(unsigned long ioaddr,
+				  byte phyaddr, byte phyreg);
+static void smc_write_phy_register(unsigned long ioaddr,
+	byte phyaddr, byte phyreg, word phydata);
+
+/*
+  Initilizes our device's sysctl proc filesystem
+*/
+
+#ifdef CONFIG_SYSCTL
+static void smc_sysctl_register(struct net_device *dev);
+static void smc_sysctl_unregister(struct net_device *dev);
+#endif /* CONFIG_SYSCTL */
+
+/*
+ . Function: smc_reset( struct net_device* dev )
+ . Purpose:
+ .  	This sets the SMC91111 chip to its normal state, hopefully from whatever
+ . 	mess that any other DOS driver has put it in.
+ .
+ . Maybe I should reset more registers to defaults in here?  SOFTRST  should
+ . do that for me.
+ .
+ . Method:
+ .	1.  send a SOFT RESET
+ .	2.  wait for it to finish
+ .	3.  enable autorelease mode
+ .	4.  reset the memory management unit
+ .	5.  clear all interrupts
+ .
+*/
+static void smc_reset( struct net_device* dev )
+{
+	//struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_reset\n", dev->name);
+
+	/* This resets the registers mostly to defaults, but doesn't
+	   affect EEPROM.  That seems unnecessary */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RCR( RCR_SOFTRST );
+
+	/* Setup the Configuration Register */
+	/* This is necessary because the CONFIG_REG is not affected */
+	/* by a soft reset */
+
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( CONFIG_DEFAULT );
+
+	/* Setup for fast accesses if requested */
+	/* If the card/system can't handle it then there will */
+	/* be no recovery except for a hard reset or power cycle */
+
+	if (dev->dma)
+		SMC_SET_CONFIG( SMC_GET_CONFIG() | CONFIG_NO_WAIT );
+
+#ifdef POWER_DOWN
+	/* Release from possible power-down state */
+	/* Configuration register is not affected by Soft Reset */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( SMC_GET_CONFIG() | CONFIG_EPH_POWER_EN );
+#endif
+
+	SMC_SELECT_BANK( 0 );
+
+	/* this should pause enough for the chip to be happy */
+	mdelay(10);
+
+	/* Disable transmit and receive functionality */
+	SMC_SET_RCR( RCR_CLEAR );
+	SMC_SET_TCR( TCR_CLEAR );
+
+	/* set the control register to automatically
+	   release successfully transmitted packets, to make the best
+	   use out of our limited memory */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CTL( SMC_GET_CTL() | CTL_AUTO_RELEASE );
+
+	/* Reset the MMU */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_RESET );
+
+	/* Note:  It doesn't seem that waiting for the MMU busy is needed here,
+	   but this is a place where future chipsets _COULD_ break.  Be wary
+ 	   of issuing another MMU command right after this */
+
+	/* Disable all interrupts */
+	SMC_SET_INT_MASK( 0 );
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	1.  Enable the transmitter
+ .	2.  Enable the receiver
+ .	3.  Enable interrupts
+*/
+static void smc_enable( struct net_device *dev )
+{
+	unsigned long ioaddr 	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_enable\n", dev->name);
+
+	SMC_SELECT_BANK( 0 );
+	/* see the header file for options in TCR/RCR DEFAULT*/
+	SMC_SET_TCR( lp->tcr_cur_mode );
+	SMC_SET_RCR( lp->rcr_cur_mode );
+
+	/* now, enable interrupts */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_INT_MASK( SMC_INTERRUPT_MASK );
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.   Empirical results do not show this working.
+*/
+static void smc_shutdown( unsigned long ioaddr )
+{
+	PRINTK2(CARDNAME ":smc_shutdown\n");
+
+	/* no more interrupts for me */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_INT_MASK( 0 );
+
+	/* and tell the card to stay away from that nasty outside world */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RCR( RCR_CLEAR );
+	SMC_SET_TCR( TCR_CLEAR );
+
+#ifdef POWER_DOWN
+	/* finally, shut the chip down */
+	SMC_SELECT_BANK( 1 );
+	SMC_SET_CONFIG( SMC_GET_CONFIG() & ~CONFIG_EPH_POWER_EN );
+#endif
+}
+
+
+/*
+ . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )
+ . Purpose:
+ .    This sets the internal hardware table to filter out unwanted multicast
+ .    packets before they take up memory.
+ .
+ .    The SMC chip uses a hash table where the high 6 bits of the CRC of
+ .    address are the offset into the table.  If that bit is 1, then the
+ .    multicast packet is accepted.  Otherwise, it's dropped silently.
+ .
+ .    To use the 6 bits as an offset into the table, the high 3 bits are the
+ .    number of the 8 bit register, while the low 3 bits are the bit within
+ .    that register.
+ .
+ . This routine is based very heavily on the one provided by Peter Cammaert.
+*/
+
+
+static void smc_setmulticast( unsigned long ioaddr, int count,
+			      struct dev_mc_list * addrs ) {
+	int			i;
+	unsigned char		multicast_table[ 8 ];
+	struct dev_mc_list	* cur_addr;
+	/* table for flipping the order of 3 bits */
+	unsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };
+
+	PRINTK2(CARDNAME ":smc_setmulticast\n");
+
+	/* start with a table of all zeros: reject all */
+	memset( multicast_table, 0, sizeof( multicast_table ) );
+
+	cur_addr = addrs;
+	for ( i = 0; i < count ; i ++, cur_addr = cur_addr->next  ) {
+		int position;
+
+		/* do we have a pointer here? */
+		if ( !cur_addr )
+			break;
+		/* make sure this is a multicast address - shouldn't this
+		   be a given if we have it here ? */
+		if ( !( *cur_addr->dmi_addr & 1 ) )
+			continue;
+
+		/* only use the low order bits */
+		position = crc32( cur_addr->dmi_addr, 6 ) & 0x3f;
+
+		/* do some messy swapping to put the bit in the right spot */
+		multicast_table[invert3[position&7]] |=
+					(1<<invert3[(position>>3)&7]);
+
+	}
+	/* now, the table can be loaded into the chipset */
+	SMC_SELECT_BANK( 3 );
+	SMC_SET_MCAST( multicast_table );
+}
+
+/*
+  Finds the CRC32 of a set of bytes.
+  Again, from Peter Cammaert's code.
+*/
+static int crc32( char * s, int length ) {
+	/* indices */
+	int perByte;
+	int perBit;
+	/* crc polynomial for Ethernet */
+	const unsigned long poly = 0xedb88320;
+	/* crc value - preinitialized to all 1's */
+	unsigned long crc_value = 0xffffffff;
+
+	for ( perByte = 0; perByte < length; perByte ++ ) {
+		unsigned char	c;
+
+		c = *(s++);
+		for ( perBit = 0; perBit < 8; perBit++ ) {
+			crc_value = (crc_value>>1)^
+				(((crc_value^c)&0x01)?poly:0);
+			c >>= 1;
+		}
+	}
+	return	crc_value;
+}
+
+
+/*
+ . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * )
+ . Purpose:
+ .    Attempt to allocate memory for a packet, if chip-memory is not
+ .    available, then tell the card to generate an interrupt when it
+ .    is available.
+ .
+ . Algorithm:
+ .
+ . o	if the saved_skb is not currently null, then drop this packet
+ .	on the floor.  This should never happen, because of TBUSY.
+ . o	if the saved_skb is null, then replace it with the current packet,
+ . o	See if I can sending it now.
+ . o 	(NO): Enable interrupts and let the interrupt handler deal with it.
+ . o	(YES):Send it now.
+*/
+static int smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * dev )
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr 	= dev->base_addr;
+	word 			length;
+	unsigned short 		numPages;
+	word			time_out;
+	word			status;
+
+	PRINTK3("%s:smc_wait_to_send_packet\n", dev->name);
+
+	netif_stop_queue(dev);
+	/* Well, I want to send the packet.. but I don't know
+	   if I can send it right now...  */
+
+	if ( lp->saved_skb) {
+		/* THIS SHOULD NEVER HAPPEN. */
+		lp->stats.tx_aborted_errors++;
+		printk("%s: Bad Craziness - sent packet while busy.\n",
+			dev->name);
+		return 1;
+	}
+	lp->saved_skb = skb;
+
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+
+
+	/*
+	** The MMU wants the number of pages to be the number of 256 bytes
+	** 'pages', minus 1 ( since a packet can't ever have 0 pages :) )
+	**
+	** The 91C111 ignores the size bits, but the code is left intact
+	** for backwards and future compatibility.
+	**
+	** Pkt size for allocating is data length +6 (for additional status
+	** words, length and ctl!)
+	**
+	** If odd size then last byte is included in this header.
+	*/
+	numPages =   ((length & 0xfffe) + 6);
+	numPages >>= 8; // Divide by 256
+
+	if (numPages > 7 ) {
+		printk("%s: Far too big packet error. \n", dev->name);
+		/* freeing the packet is a good thing here... but should
+		 . any packets of this size get down here?   */
+		dev_kfree_skb (skb);
+		lp->saved_skb = NULL;
+		/* this IS an error, but, i don't want the skb saved */
+		netif_wake_queue(dev);
+		return 0;
+	}
+	/* either way, a packet is waiting now */
+	lp->packets_waiting++;
+
+	/* now, try to allocate the memory */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_ALLOC | numPages );
+	/*
+ 	. Performance Hack
+	.
+ 	. wait a short amount of time.. if I can send a packet now, I send
+	. it now.  Otherwise, I enable an interrupt and wait for one to be
+	. available.
+	.
+	. I could have handled this a slightly different way, by checking to
+	. see if any memory was available in the FREE MEMORY register.  However,
+	. either way, I need to generate an allocation, and the allocation works
+	. no matter what, so I saw no point in checking free memory.
+	*/
+	time_out = MEMORY_WAIT_TIME;
+	do {
+		status = SMC_GET_INT();
+		if ( status & IM_ALLOC_INT ) {
+			/* acknowledge the interrupt */
+			SMC_ACK_INT( IM_ALLOC_INT );
+  			break;
+		}
+   	} while ( -- time_out );
+
+   	if ( !time_out ) {
+		/* oh well, wait until the chip finds memory later */
+		SMC_ENABLE_INT( IM_ALLOC_INT );
+
+		/* Check the status bit one more time just in case */
+		/* it snuk in between the time we last checked it */
+		/* and when we set the interrupt bit */
+		status = SMC_GET_INT();
+		if ( !(status & IM_ALLOC_INT) ) {
+      			PRINTK2("%s: memory allocation deferred. \n",
+				dev->name);
+			/* it's deferred, but I'll handle it later */
+      			return 0;
+			}
+
+		/* Looks like it did sneak in, so disable */
+		/* the interrupt */
+		SMC_DISABLE_INT( IM_ALLOC_INT );
+   	}
+	/* or YES! I can send the packet now.. */
+	smc_hardware_send_packet(dev);
+	netif_wake_queue(dev);
+	return 0;
+}
+
+/*
+ . Function:  smc_hardware_send_packet(struct net_device * )
+ . Purpose:
+ .	This sends the actual packet to the SMC9xxx chip.
+ .
+ . Algorithm:
+ . 	First, see if a saved_skb is available.
+ .		( this should NOT be called if there is no 'saved_skb'
+ .	Now, find the packet number that the chip allocated
+ .	Point the data pointers at it in memory
+ .	Set the length word in the chip's memory
+ .	Dump the packet to chip memory
+ .	Check if a last byte is needed ( odd length packet )
+ .		if so, set the control flag right
+ . 	Tell the card to send it
+ .	Enable the transmit interrupt, so I know if it failed
+ . 	Free the kernel data if I actually sent it.
+*/
+static void smc_hardware_send_packet( struct net_device * dev )
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte	 		packet_no;
+	struct sk_buff * 	skb = lp->saved_skb;
+	word			length;
+	unsigned long		ioaddr;
+	byte			* buf;
+
+	PRINTK3("%s:smc_hardware_send_packet\n", dev->name);
+
+	ioaddr = dev->base_addr;
+
+	if ( !skb ) {
+		PRINTK("%s: In XMIT with no packet to send \n", dev->name);
+		return;
+	}
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+	buf = skb->data;
+
+	/* If I get here, I _know_ there is a packet slot waiting for me */
+	packet_no = SMC_GET_AR();
+	if ( packet_no & AR_FAILED ) {
+		/* or isn't there?  BAD CHIP! */
+		printk(KERN_DEBUG "%s: Memory allocation failed. \n",
+			dev->name);
+		dev_kfree_skb_any(skb);
+		lp->saved_skb = NULL;
+		netif_wake_queue(dev);
+		return;
+	}
+
+	/* we have a packet address, so tell the card to use it */
+	SMC_SET_PN( packet_no );
+
+	/* point to the beginning of the packet */
+	SMC_SET_PTR( PTR_AUTOINC );
+
+   	PRINTK3("%s: Trying to xmit packet of length %x\n",
+		dev->name, length);
+
+#if SMC_DEBUG > 2
+	printk("Transmitting Packet\n");
+	print_packet( buf, length );
+#endif
+
+	/* send the packet length ( +6 for status, length and ctl byte )
+ 	   and the status word ( set to zeros ) */
+#ifdef CONFIG_SMC91111_USE_32_BIT
+	SMC_outl(  (length +6 ) << 16 , ioaddr + DATA_REG );
+#else
+	SMC_outw( 0, ioaddr + DATA_REG );
+	/* send the packet length ( +6 for status words, length, and ctl*/
+	SMC_outw( (length+6), ioaddr + DATA_REG );
+#endif
+
+	/* send the actual data
+	 . I _think_ it's faster to send the longs first, and then
+	 . mop up by sending the last word.  It depends heavily
+ 	 . on alignment, at least on the 486.  Maybe it would be
+ 	 . a good idea to check which is optimal?  But that could take
+	 . almost as much time as is saved?
+	*/
+#ifdef CONFIG_SMC91111_USE_32_BIT
+	SMC_outsl(ioaddr + DATA_REG, buf,  length >> 2 );
+	if ( length & 0x2  )
+		SMC_outw(*((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +
+				DATA_REG);
+#else
+	SMC_outsw(ioaddr + DATA_REG , buf, (length ) >> 1);
+#endif // CONFIG_SMC91111_USE_32_BIT
+
+	/* Send the last byte, if there is one.   */
+	if ( (length & 1) == 0 ) {
+		SMC_outw( 0, ioaddr + DATA_REG );
+	} else {
+		SMC_outw( 0x2000 | buf[length -1 ], ioaddr + DATA_REG );
+	}
+
+	/* enable the interrupts */
+	SMC_ENABLE_INT( (IM_TX_INT | IM_TX_EMPTY_INT) );
+
+	/* and let the chipset deal with it */
+	SMC_SET_MMU_CMD( MC_ENQUEUE );
+
+	PRINTK2("%s: Sent packet of length %d \n", dev->name, length);
+
+	lp->saved_skb = NULL;
+	dev_kfree_skb_any (skb);
+
+	dev->trans_start = jiffies;
+
+	/* we can send another packet */
+	netif_wake_queue(dev);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_init( void )
+ |   Input parameters:
+ |	dev->base_addr == 0, try to find all possible locations
+ |	dev->base_addr > 0x1ff, this is the address to check
+ |	dev->base_addr == <anything else>, return failure code
+ |
+ |   Output:
+ |	0 --> there is a device
+ |	anything else, error
+ |
+ ---------------------------------------------------------------------------
+*/
+static int __init smc_init( void )
+{
+	int rtn;
+
+	PRINTK2(CARDNAME ":smc_init\n");
+
+#ifdef MODULE
+	if (io == -1)
+		printk(KERN_WARNING
+		CARDNAME": You shouldn't use auto-probing with insmod!\n" );
+#endif
+
+	if (global_dev) {
+		printk(CARDNAME ": already initialized.\n");
+		return -EBUSY;
+	}
+
+	global_dev = init_etherdev(0, sizeof(struct smc_local));
+	if (!global_dev) {
+		printk(CARDNAME ": could not allocate device.\n");
+		return -ENODEV;
+	}
+	SET_MODULE_OWNER(global_dev);
+
+	/* copy the parameters from insmod into the device structure */
+	if (io != -1)
+		global_dev->base_addr	= io;
+	if (irq != -1)
+		global_dev->irq	= irq;
+	global_dev->dma		= nowait; // Use DMA field for nowait
+
+#ifdef CONFIG_ISA
+	/*  try a specific location */
+	if (global_dev->base_addr > 0x1ff)
+		rtn = smc_probe(global_dev, global_dev->base_addr);
+	else if (global_dev->base_addr != 0)
+		rtn = -ENXIO;
+	else {
+		int i;
+
+		/* check every ethernet address */
+		for (i = 0; smc_portlist[i]; i++) {
+			rtn = smc_probe(global_dev, smc_portlist[i]);
+			if (rtn == 0)
+				break;
+		}
+	}
+#else
+	if (global_dev->base_addr == -1) {
+		printk(KERN_WARNING
+		CARDNAME": SMC91111_BASE_ADDR not set!\n" );
+		rtn = -ENXIO;
+	}
+	else
+		rtn = smc_probe(global_dev,
+				(int)ioremap(global_dev->base_addr,
+					     SMC_IO_EXTENT));
+#endif
+
+	if (rtn != 0) {
+		printk(CARDNAME ": not found.\n");
+		/* couldn't find anything */
+#ifndef CONFIG_ISA
+		iounmap((void *)global_dev->base_addr);
+#endif
+		kfree(global_dev->priv);
+		unregister_netdev(global_dev);
+		kfree(global_dev);
+	}
+
+	return rtn;
+}
+
+/*----------------------------------------------------------------------
+ . smc_findirq
+ .
+ . This routine has a simple purpose -- make the SMC chip generate an
+ . interrupt, so an auto-detect routine can detect it, and find the IRQ,
+ ------------------------------------------------------------------------
+*/
+int __init smc_findirq( unsigned long ioaddr )
+{
+	int	timeout = 20;
+	unsigned long cookie;
+
+	PRINTK2(CARDNAME ":smc_findirq\n");
+
+	/* I have to do a STI() here, because this is called from
+	   a routine that does an CLI during this process, making it
+	   rather difficult to get interrupts for auto detection */
+	sti();
+
+	cookie = probe_irq_on();
+
+	/*
+	 * What I try to do here is trigger an ALLOC_INT. This is done
+	 * by allocating a small chunk of memory, which will give an interrupt
+	 * when done.
+	 */
+
+
+	SMC_SELECT_BANK(2);
+	/* enable ALLOCation interrupts ONLY */
+	SMC_SET_INT_MASK( IM_ALLOC_INT );
+
+	/*
+ 	 . Allocate 512 bytes of memory.  Note that the chip was just
+	 . reset so all the memory is available
+	*/
+	SMC_SET_MMU_CMD( MC_ALLOC | 1 );
+
+	/*
+	 . Wait until positive that the interrupt has been generated
+	*/
+	while ( timeout ) {
+		byte	int_status;
+
+		int_status = SMC_GET_INT();
+
+		if ( int_status & IM_ALLOC_INT )
+			break;		/* got the interrupt */
+		timeout--;
+	}
+
+	/* there is really nothing that I can do here if timeout fails,
+	   as autoirq_report will return a 0 anyway, which is what I
+	   want in this case.   Plus, the clean up is needed in both
+	   cases.  */
+
+	/* DELAY HERE!
+	   On a fast machine, the status might change before the interrupt
+	   is given to the processor.  This means that the interrupt was
+	   never detected, and autoirq_report fails to report anything.
+	   This should fix autoirq_* problems.
+	*/
+	mdelay(10);
+
+	/* and disable all interrupts again */
+	SMC_SET_INT_MASK( 0 );
+
+	/* clear hardware interrupts again, because that's how it
+	   was when I was called... */
+	cli();
+
+	/* and return what I found */
+	return probe_irq_off(cookie);
+}
+
+/*----------------------------------------------------------------------
+ . Function: smc_probe( unsigned long ioaddr )
+ .
+ . Purpose:
+ .	Tests to see if a given ioaddr points to an SMC91111 chip.
+ .	Returns a 0 on success
+ .
+ . Algorithm:
+ .	(1) see if the high byte of BANK_SELECT is 0x33
+ . 	(2) compare the ioaddr with the base register's address
+ .	(3) see if I recognize the chip ID in the appropriate register
+ .
+ .---------------------------------------------------------------------
+ */
+/*---------------------------------------------------------------
+ . Here I do typical initialization tasks.
+ .
+ . o  Initialize the structure if needed
+ . o  print out my vanity message if not done so already
+ . o  print out what type of hardware is detected
+ . o  print out the ethernet address
+ . o  find the IRQ
+ . o  set up my private data
+ . o  configure the dev structure with my subroutines
+ . o  actually GRAB the irq.
+ . o  GRAB the region
+ .-----------------------------------------------------------------
+*/
+static int __init smc_probe(struct net_device *dev, unsigned long ioaddr)
+{
+	int i, memory, retval;
+	static unsigned version_printed;
+	unsigned int	bank;
+
+	const char *version_string;
+	const char *if_string;
+
+	/* registers */
+	word	revision_register;
+	word  base_address_register;
+	word memory_info_register;
+
+	PRINTK2(CARDNAME ":smc_probe\n");
+
+	/* Grab the region so that no one else tries to probe our ioports. */
+	if (!request_region(ioaddr, SMC_IO_EXTENT, dev->name))
+		return -EBUSY;
+
+	/* First, see if the high byte is 0x33 */
+	bank = SMC_CURRENT_BANK();
+	if ( (bank & 0xFF00) != 0x3300 ) {
+		if ( (bank & 0xFF) == 0x33 ) {
+			printk(CARDNAME
+			       ": Detected possible byte-swapped interface"
+			       " at IOADDR %lx\n", ioaddr);
+		}
+		retval = -ENODEV;
+		goto err_out;
+	}
+	/* The above MIGHT indicate a device, but I need to write to further
+ 	 	test this.  */
+	SMC_SELECT_BANK(0);
+	bank = SMC_CURRENT_BANK();
+	if ( (bank & 0xFF00 ) != 0x3300 ) {
+		retval = -ENODEV;
+		goto err_out;
+	}
+	/* well, we've already written once, so hopefully another time won't
+ 	   hurt.  This time, I need to switch the bank register to bank 1,
+	   so I can access the base address register */
+	SMC_SELECT_BANK(1);
+	base_address_register = SMC_GET_BASE();
+	base_address_register = ((base_address_register & 0xE000)
+				 | ((base_address_register & 0x1F00) >> 3));
+	if ( (ioaddr & (PAGE_SIZE-1)) != base_address_register )  {
+		printk(CARDNAME ": IOADDR %lx doesn't match configuration (%x)."
+			"Probably not a SMC chip\n",
+			ioaddr, base_address_register );
+		/* well, the base address register didn't match.  Must not have
+		   been a SMC chip after all. */
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/*  check if the revision register is something that I recognize.
+	    These might need to be added to later, as future revisions
+	    could be added.  */
+	SMC_SELECT_BANK(3);
+	revision_register  = SMC_GET_REV();
+	if ( !chip_ids[ ( revision_register  >> 4 ) & 0xF  ] ) {
+		/* I don't recognize this chip, so... */
+		printk(CARDNAME ": IO %lx: Unrecognized revision register:"
+			" %x, Contact author. \n",
+			ioaddr, revision_register );
+
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/* at this point I'll assume that the chip is an SMC9xxx.
+	   It might be prudent to check a listing of MAC addresses
+	   against the hardware address, or do some other tests. */
+
+	if (version_printed++ == 0)
+		printk("%s", version);
+
+	/* fill in some of the fields */
+	dev->base_addr = ioaddr;
+
+	/*
+ 	 . Get the MAC address ( bank 1, regs 4 - 9 )
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 ) {
+		word	address;
+
+		address = SMC_inw( ioaddr + ADDR0_REG + i  );
+		dev->dev_addr[ i + 1] = address >> 8;
+		dev->dev_addr[ i ] = address & 0xFF;
+	}
+
+	/* get the memory information */
+
+	SMC_SELECT_BANK( 0 );
+	memory_info_register = SMC_GET_MIR();
+	memory = memory_info_register & (word)0x00ff;
+	memory *= LAN91C111_MEMORY_MULTIPLIER;
+
+	/*
+	 Now, I want to find out more about the chip.  This is sort of
+ 	 redundant, but it's cleaner to have it in both, rather than having
+ 	 one VERY long probe procedure.
+	*/
+	SMC_SELECT_BANK(3);
+	revision_register  = SMC_GET_REV();
+	version_string = chip_ids[ ( revision_register  >> 4 ) & 0xF  ];
+	if ( !version_string ) {
+		/* I shouldn't get here because this call was done before.... */
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+
+	/* now, reset the chip, and put it into a known state */
+	smc_reset( dev );
+
+	/*
+	 . If dev->irq is 0, then the device has to be banged on to see
+	 . what the IRQ is.
+ 	 .
+	 . This banging doesn't always detect the IRQ, for unknown reasons.
+	 . a workaround is to reset the chip and try again.
+	 .
+	 . Interestingly, the DOS packet driver *SETS* the IRQ on the card to
+	 . be what is requested on the command line.   I don't do that, mostly
+	 . because the card that I have uses a non-standard method of accessing
+	 . the IRQs, and because this _should_ work in most configurations.
+	 .
+	 . Specifying an IRQ is done with the assumption that the user knows
+	 . what (s)he is doing.  No checking is done!!!!
+ 	 .
+	*/
+	if ( dev->irq < 2 ) {
+		int	trials;
+
+		trials = 3;
+		while ( trials-- ) {
+			dev->irq = smc_findirq( ioaddr );
+			if ( dev->irq )
+				break;
+			/* kick the card and try again */
+			smc_reset( dev );
+		}
+	}
+	if (dev->irq == 0 ) {
+		printk("%s: Couldn't autodetect your IRQ. Use irq=xx.\n",
+			dev->name);
+		retval = -ENODEV;
+		goto err_out;
+	}
+	if (dev->irq == 2) {
+		/* Fixup for users that don't know that IRQ 2 is really IRQ 9,
+		 * or don't know which one to set.
+		 */
+		dev->irq = 9;
+	}
+
+	/* now, print out the card info, in a short format.. */
+
+	printk("%s: %s(r:%d) at %#lx IRQ:%d\n", dev->name,
+	       version_string, revision_register & 0xF, ioaddr, dev->irq );
+	printk(" INTF:%s MEM:%db NOWAIT:%d", if_string, memory, dev->dma );
+	/*
+	 . Print the Ethernet address
+	*/
+	printk("  ADDR ");
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", dev->dev_addr[i] );
+	printk("%2.2x \n", dev->dev_addr[5] );
+
+	/* set the private data to zero by default */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(dev);
+
+	/* Grab the IRQ */
+      	retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+      	if (retval) {
+  	  	goto err_out;
+      	}
+
+	dev->open		        = smc_open;
+	dev->stop		        = smc_close;
+	dev->hard_start_xmit    	= smc_wait_to_send_packet;
+	dev->tx_timeout		    	= smc_timeout;
+	dev->watchdog_timeo		= HZ/20;
+	dev->get_stats			= smc_query_statistics;
+	dev->set_multicast_list 	= smc_set_multicast_list;
+
+	return 0;
+
+err_out:
+	release_region(ioaddr, SMC_IO_EXTENT);
+	return retval;
+}
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+#if 1
+#if SMC_DEBUG > 3
+	int i;
+	int remainder;
+	int lines;
+#endif
+
+	printk("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printk("%02x%02x ", a, b );
+		}
+		printk("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printk("%02x%02x ", a, b );
+	}
+	printk("\n");
+#endif
+#endif
+}
+#endif
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open(struct net_device *dev)
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned long ioaddr	= dev->base_addr;
+	int	i;	/* used to set hw ethernet address */
+
+	PRINTK2("%s:smc_open\n", dev->name);
+
+	/* clear out all the junk that was put here before... */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+
+	// Setup the default Register Modes
+	lp->tcr_cur_mode = TCR_DEFAULT;
+	lp->rcr_cur_mode = RCR_DEFAULT;
+	lp->rpc_cur_mode = RPC_DEFAULT;
+
+	// Set default parameters (files)
+	lp->ctl_swfdup = 0;
+	lp->ctl_ephloop = 0;
+	lp->ctl_miiop = 0;
+	lp->ctl_autoneg = 1;
+	lp->ctl_rfduplx = 1;
+	lp->ctl_rspeed = 100;
+	lp->ctl_afduplx = 1;
+	lp->ctl_aspeed = 100;
+	lp->ctl_lnkfail = 1;
+	lp->ctl_forcol = 0;
+	lp->ctl_filtcar = 0;
+
+	/* reset the hardware */
+
+	smc_reset( dev );
+	smc_enable( dev );
+
+	/* Configure the PHY */
+	smc_phy_configure(dev);
+
+	/*
+  		According to Becker, I have to set the hardware address
+		at this point, because the (l)user can set it with an
+		ioctl.  Easily done...
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 ) {
+		word	address;
+
+		address = dev->dev_addr[ i + 1 ] << 8 ;
+		address  |= dev->dev_addr[ i ];
+		SMC_outw( address, ioaddr + ADDR0_REG + i );
+	}
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_register(dev);
+#endif /* CONFIG_SYSCTL */
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+/*--------------------------------------------------------
+ . Called by the kernel to send a packet out into the void
+ . of the net.  This routine is largely based on
+ . skeleton.c, from Becker.
+ .--------------------------------------------------------
+*/
+static void smc_timeout(struct net_device *dev)
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	PRINTK3("%s:smc_timeout\n", dev->name);
+
+	/* If we get here, some higher level has decided we are broken.
+	   There should really be a "kick me" function call instead. */
+	printk(KERN_WARNING "%s: transmit timed out, %s?\n",
+		dev->name, tx_done(dev) ? "IRQ conflict" :
+		"network cable problem");
+	/* "kick" the adaptor */
+	smc_reset( dev );
+	smc_enable( dev );
+
+#if 0
+	/* Reconfiguring the PHY doesn't seem like a bad idea here, but
+	 * it introduced a problem.  Now that this is a timeout routine,
+	 * we are getting called from within an interrupt context.
+	 * smc_phy_configure() calls smc_wait_ms() which calls
+	 * schedule_timeout() which calls schedule().  When schedule()
+	 * is called from an interrupt context, it prints out
+	 * "Scheduling in interrupt" and then calls BUG().  This is
+	 * obviously not desirable.  This was worked around by removing
+	 * the call to smc_phy_configure() here because it didn't seem
+	 * absolutely necessary.  Ultimately, if smc_wait_ms() is
+	 * supposed to be usable from an interrupt context (which it
+	 * looks like it thinks it should handle), it should be fixed.
+	 */
+	/* Reconfigure the PHY */
+	smc_phy_configure(dev);
+#endif
+	dev->trans_start = jiffies;
+	/* clear anything saved */
+	if (lp->saved_skb != NULL) {
+		dev_kfree_skb (lp->saved_skb);
+		lp->saved_skb = NULL;
+	}
+	((struct smc_local *)dev->priv)->saved_skb = NULL;
+	netif_wake_queue(dev);
+}
+
+/*--------------------------------------------------------------------
+ .
+ . This is the main routine of the driver, to handle the device when
+ . it needs some attention.
+ .
+ . So:
+ .   first, save state of the chipset
+ .   branch off into routines to handle each case, and acknowledge
+ .	    each to the interrupt register
+ .   and finally restore state.
+ .
+ ---------------------------------------------------------------------*/
+static void smc_interrupt(int irq, void * dev_id,  struct pt_regs * regs)
+{
+	struct net_device *dev 	= dev_id;
+	unsigned long ioaddr	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	byte	status;
+	word	card_stats;
+	byte	mask;
+	int	timeout;
+	/* state registers */
+	word	saved_bank;
+	word	saved_pointer;
+
+	PRINTK3("%s: SMC interrupt started \n", dev->name);
+
+	if (dev == NULL) {
+		printk(KERN_WARNING "%s: irq %d for unknown device.\n",
+			dev->name, irq);
+		return;
+	}
+
+	saved_bank = SMC_CURRENT_BANK();
+
+	SMC_SELECT_BANK(2);
+	saved_pointer = SMC_GET_PTR();
+
+	/* read the interrupt mask register */
+	mask = SMC_GET_INT_MASK();
+
+	/* disable all interrupts */
+	SMC_SET_INT_MASK( 0 );
+
+	/* set a timeout value, so I don't stay here forever */
+	timeout = 4;
+
+	PRINTK2(KERN_WARNING "%s: MASK IS %x \n", dev->name, mask);
+	do {
+		/* read the status flag, and mask it */
+		status = SMC_GET_INT() & mask;
+		if (!status )
+			break;
+
+		PRINTK3(KERN_WARNING "%s: Handling interrupt status %x \n",
+			dev->name, status);
+
+		if (status & IM_RCV_INT) {
+			/* Got a packet(s). */
+			PRINTK2(KERN_WARNING
+				"%s: Receive Interrupt\n", dev->name);
+			smc_rcv(dev);
+		} else if (status & IM_TX_INT ) {
+			PRINTK2(KERN_WARNING "%s: TX ERROR handled\n",
+				dev->name);
+			smc_tx(dev);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_TX_INT );
+		} else if (status & IM_TX_EMPTY_INT ) {
+			/* update stats */
+			SMC_SELECT_BANK( 0 );
+			card_stats = SMC_GET_COUNTER();
+			/* single collisions */
+			lp->stats.collisions += card_stats & 0xF;
+			card_stats >>= 4;
+			/* multiple collisions */
+			lp->stats.collisions += card_stats & 0xF;
+
+			/* these are for when linux supports these statistics */
+
+			SMC_SELECT_BANK( 2 );
+			PRINTK2(KERN_WARNING "%s: TX_BUFFER_EMPTY handled\n",
+				dev->name);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_TX_EMPTY_INT );
+			mask &= ~IM_TX_EMPTY_INT;
+			lp->stats.tx_packets += lp->packets_waiting;
+			lp->packets_waiting = 0;
+
+		} else if (status & IM_ALLOC_INT ) {
+			PRINTK2(KERN_DEBUG "%s: Allocation interrupt \n",
+				dev->name);
+			/* clear this interrupt so it doesn't happen again */
+			mask &= ~IM_ALLOC_INT;
+
+			smc_hardware_send_packet( dev );
+
+			/* enable xmit interrupts based on this */
+			mask |= ( IM_TX_EMPTY_INT | IM_TX_INT );
+
+			/* and let the card send more packets to me */
+			netif_wake_queue(dev);
+
+			PRINTK2("%s: Handoff done successfully.\n",
+				dev->name);
+		} else if (status & IM_RX_OVRN_INT ) {
+			lp->stats.rx_errors++;
+			lp->stats.rx_fifo_errors++;
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_RX_OVRN_INT );
+		} else if (status & IM_EPH_INT ) {
+			PRINTK("%s: UNSUPPORTED: EPH INTERRUPT \n",
+				dev->name);
+		} else if (status & IM_MDINT ) {
+			smc_phy_interrupt(dev);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_MDINT );
+		} else if (status & IM_ERCV_INT ) {
+			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n",
+				dev->name);
+			// Acknowledge the interrupt
+			SMC_ACK_INT( IM_ERCV_INT );
+		}
+	} while ( timeout -- );
+
+
+	/* restore register states */
+
+	SMC_SELECT_BANK( 2 );
+
+	SMC_SET_INT_MASK( mask );
+
+	PRINTK3( KERN_WARNING "%s: MASK is now %x \n", dev->name, mask);
+	SMC_SET_PTR( saved_pointer );
+
+	SMC_SELECT_BANK( saved_bank );
+
+	PRINTK3("%s: Interrupt done\n", dev->name);
+	return;
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+static void smc_rcv(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	unsigned long ioaddr  = dev->base_addr;
+	int 	packet_number;
+	word	status;
+	word	packet_length;
+
+	PRINTK3("%s:smc_rcv\n", dev->name);
+
+	/* assume bank 2 */
+
+	packet_number = SMC_GET_RXFIFO();
+
+	if ( packet_number & RXFIFO_REMPTY ) {
+
+		/* we got called , but nothing was on the FIFO */
+		PRINTK("%s: WARNING: smc_rcv with nothing on FIFO. \n",
+			dev->name);
+		/* don't need to restore anything */
+		return;
+	}
+
+	/*  start reading from the start of the packet */
+	SMC_SET_PTR( PTR_READ | PTR_RCV | PTR_AUTOINC );
+
+	/* First two words are status and packet_length */
+	status 		= SMC_inw( ioaddr + DATA_REG );
+	packet_length 	= SMC_inw( ioaddr + DATA_REG );
+
+	packet_length &= 0x07ff;  /* mask off top bits */
+
+	PRINTK2("RCV: STATUS %4x LENGTH %4x\n", status, packet_length );
+
+	if ( !(status & RS_ERRORS ) ){
+		/* do stuff to make a new packet */
+		struct sk_buff  * skb;
+		byte		* data;
+
+		/* set multicast stats */
+		if ( status & RS_MULTICAST )
+			lp->stats.multicast++;
+
+		// Allocate enough memory for entire receive frame, to be safe
+		skb = dev_alloc_skb( packet_length );
+
+		/* Adjust for having already read the first two words */
+		packet_length -= 4;
+
+		if ( skb == NULL ) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+				dev->name);
+			lp->stats.rx_dropped++;
+			goto done;
+		}
+
+		/*
+		 ! This should work without alignment, but it could be
+		 ! in the worse case
+		*/
+
+		skb_reserve( skb, 2 );   /* 16 bit alignment */
+
+		skb->dev = dev;
+
+		// set odd length for bug in LAN91C111,
+		// which never sets RS_ODDFRAME
+		data = skb_put( skb, packet_length + 1 );
+
+#ifdef CONFIG_SMC91111_USE_32_BIT
+		PRINTK3(" Reading %d dwords (and %d bytes) \n",
+			packet_length >> 2, packet_length & 3 );
+		/* QUESTION:  Like in the TX routine, do I want
+		   to send the DWORDs or the bytes first, or some
+		   mixture.  A mixture might improve already slow PIO
+		   performance  */
+		SMC_insl(ioaddr + DATA_REG , data, packet_length >> 2 );
+		/* read the left over bytes */
+#ifdef CONFIG_SMC91111_USE_8_BIT
+		SMC_insb( ioaddr + DATA_REG, data + (packet_length & 0xFFFFFC),
+			  packet_length & 0x3  );
+#else
+		if (packet_length & 0x3)
+		{
+			unsigned long remaining_data;
+			insl(ioaddr + DATA_REG , &remaining_data, 1);
+			memcpy(data + (packet_length & 0xFFFFFC),
+			       &remaining_data, packet_length & 0x3  );
+		}
+#endif // CONFIG_SMC91111_USE_8_BIT
+#else
+		PRINTK3(" Reading %d words and %d byte(s) \n",
+			(packet_length >> 1 ), packet_length & 1 );
+		SMC_insw(ioaddr + DATA_REG , data, packet_length >> 1);
+
+#endif // CONFIG_SMC91111_USE_32_BIT
+
+#if	SMC_DEBUG > 2
+		printk("Receiving Packet\n");
+		print_packet( data, packet_length );
+#endif
+
+		skb->protocol = eth_type_trans(skb, dev );
+		netif_rx(skb);
+		dev->last_rx = jiffies;
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += packet_length;
+	} else {
+		/* error ... */
+		lp->stats.rx_errors++;
+
+		if ( status & RS_ALGNERR )  lp->stats.rx_frame_errors++;
+		if ( status & (RS_TOOSHORT | RS_TOOLONG ) )
+			lp->stats.rx_length_errors++;
+		if ( status & RS_BADCRC)	lp->stats.rx_crc_errors++;
+	}
+
+	while ( SMC_GET_MMU_CMD() & MC_BUSY )
+		udelay(1); // Wait until not busy
+
+done:
+	/*  error or good, tell the card to get rid of this packet */
+	SMC_SET_MMU_CMD( MC_RELEASE );
+}
+
+
+/*************************************************************************
+ . smc_tx
+ .
+ . Purpose:  Handle a transmit error message.   This will only be called
+ .   when an error, because of the AUTO_RELEASE mode.
+ .
+ . Algorithm:
+ .	Save pointer and packet no
+ .	Get the packet no from the top of the queue
+ .	check if it's valid ( if not, is this an error??? )
+ .	read the status word
+ .	record the error
+ .	( resend?  Not really, since we don't want old packets around )
+ .	Restore saved values
+ ************************************************************************/
+static void smc_tx( struct net_device * dev )
+{
+	unsigned long  ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte saved_packet;
+	byte packet_no;
+	word tx_status;
+
+
+	PRINTK3("%s:smc_tx\n", dev->name);
+
+	/* assume bank 2  */
+
+	saved_packet = SMC_GET_PN();
+	packet_no = SMC_GET_RXFIFO();
+	packet_no &= 0x7F;
+
+	/* If the TX FIFO is empty then nothing to do */
+	if ( packet_no & TXFIFO_TEMPTY )
+		return;
+
+	/* select this as the packet to read from */
+	SMC_SET_PN( packet_no );
+
+	/* read the first word (status word) from this packet */
+	SMC_SET_PTR( PTR_AUTOINC | PTR_READ );
+
+	tx_status = SMC_inw( ioaddr + DATA_REG );
+	PRINTK3("%s: TX DONE STATUS: %4x \n", dev->name, tx_status);
+
+	lp->stats.tx_errors++;
+	if ( tx_status & TS_LOSTCAR ) lp->stats.tx_carrier_errors++;
+	if ( tx_status & TS_LATCOL  ) {
+		printk(KERN_DEBUG
+			"%s: Late collision occurred on last xmit.\n",
+			dev->name);
+		lp->stats.tx_window_errors++;
+		lp->ctl_forcol = 0; // Reset forced collsion
+	}
+#if 0
+	if ( tx_status & TS_16COL ) { ... }
+#endif
+
+	if ( tx_status & TS_SUCCESS ) {
+		printk("%s: Successful packet caused interrupt \n", dev->name);
+	}
+	/* re-enable transmit */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_TCR( SMC_GET_TCR() | TCR_ENABLE );
+
+	/* kill the packet */
+	SMC_SELECT_BANK( 2 );
+	SMC_SET_MMU_CMD( MC_FREEPKT );
+
+	/* one less packet waiting for me */
+	lp->packets_waiting--;
+
+	/* Don't change Packet Number Reg until busy bit is cleared */
+	/* Per LAN91C111 Spec, Page 50 */
+	while ( SMC_GET_MMU_CMD() & MC_BUSY );
+
+	SMC_SET_PN( saved_packet );
+	return;
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.   Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close(struct net_device *dev)
+{
+	PRINTK2("%s:smc_close\n", dev->name);
+
+	netif_stop_queue(dev);
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_unregister(dev);
+#endif /* CONFIG_SYSCTL */
+
+	/* clear everything */
+	smc_shutdown( dev->base_addr );
+
+	/* Update the statistics here. */
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Get the current statistics.
+ . This may be called with the card open or closed.
+ .-------------------------------------------------------------*/
+static struct net_device_stats* smc_query_statistics(struct net_device *dev) {
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_query_statistics\n", dev->name);
+
+	return &lp->stats;
+}
+
+/*-----------------------------------------------------------
+ . smc_set_multicast_list
+ .
+ . This routine will, depending on the values passed to it,
+ . either make it accept multicast packets, go into
+ . promiscuous mode ( for TCPDUMP and cousins ) or accept
+ . a select set of multicast packets
+*/
+static void smc_set_multicast_list(struct net_device *dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_set_multicast_list\n", dev->name);
+
+	SMC_SELECT_BANK(0);
+	if ( dev->flags & IFF_PROMISC ) {
+		PRINTK2("%s:smc_set_multicast_list:RCR_PRMS\n", dev->name);
+		SMC_SET_RCR( SMC_GET_RCR() | RCR_PRMS );
+	}
+
+/* BUG?  I never disable promiscuous mode if multicasting was turned on.
+   Now, I turn off promiscuous mode, but I don't do anything to multicasting
+   when promiscuous mode is turned on.
+*/
+
+	/* Here, I am setting this to accept all multicast packets.
+	   I don't need to zero the multicast table, because the flag is
+	   checked before the table is
+	*/
+	else if (dev->flags & IFF_ALLMULTI) {
+		SMC_SET_RCR( SMC_GET_RCR() | RCR_ALMUL );
+		PRINTK2("%s:smc_set_multicast_list:RCR_ALMUL\n", dev->name);
+	}
+
+	/* We just get all multicast packets even if we only want them
+	 . from one source.  This will be changed at some future
+	 . point. */
+	else if (dev->mc_count )  {
+		/* support hardware multicasting */
+
+		/* be sure I get rid of flags I might have set */
+		SMC_SET_RCR( SMC_GET_RCR() & ~(RCR_PRMS | RCR_ALMUL) );
+		/* NOTE: this has to set the bank, so make sure it is the
+		   last thing called.  The bank is set to zero at the top */
+		smc_setmulticast( ioaddr, dev->mc_count, dev->mc_list );
+	} else  {
+		PRINTK2("%s:smc_set_multicast_list:~(RCR_PRMS|RCR_ALMUL)\n",
+			dev->name);
+		SMC_SET_RCR( SMC_GET_RCR() & ~(RCR_PRMS | RCR_ALMUL) );
+
+		/*
+		  since I'm disabling all multicast entirely, I need to
+		  clear the multicast list
+		*/
+		SMC_SELECT_BANK( 3 );
+		SMC_CLEAR_MCAST();
+	}
+}
+
+/*------------------------------------------------------------
+ . Cleanup when module is removed with rmmod
+ .-------------------------------------------------------------*/
+static void __exit smc_cleanup(void)
+{
+	/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
+	unregister_netdev(global_dev);
+
+	free_irq(global_dev->irq, global_dev);
+	release_region(global_dev->base_addr, SMC_IO_EXTENT);
+
+#ifndef CONFIG_ISA
+	iounmap((void *)global_dev->base_addr);
+#endif
+
+	kfree(global_dev);
+	global_dev = NULL;
+}
+
+module_init(smc_init);
+module_exit(smc_cleanup);
+
+
+#ifdef CONFIG_SYSCTL
+/*------------------------------------------------------------
+ . Modify a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static word smc_modify_regbit(int bank, unsigned long ioaddr, int reg,
+	unsigned int bit, int val)
+{
+	word regval;
+
+	SMC_SELECT_BANK( bank );
+
+	regval = SMC_inw( ioaddr+reg );
+	if (val)
+		regval |= bit;
+	else
+		regval &= ~bit;
+
+	SMC_outw( regval, ioaddr );
+	return(regval);
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static int smc_get_regbit(int bank, unsigned long ioaddr,
+			  int reg, unsigned int bit)
+{
+	SMC_SELECT_BANK( bank );
+	if ( SMC_inw( ioaddr+reg ) & bit)
+		return(1);
+	else
+		return(0);
+}
+
+
+/*------------------------------------------------------------
+ . Modify a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static void smc_modify_reg(int bank, unsigned long ioaddr,
+			   int reg, word val)
+{
+	SMC_SELECT_BANK( bank );
+	SMC_outw( val, ioaddr+reg );
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static int smc_get_reg(int bank, unsigned long ioaddr,
+		       int reg)
+{
+	SMC_SELECT_BANK( bank );
+	return(SMC_inw( ioaddr+reg ));
+}
+
+
+static const char smc_info_string[] =
+"\n"
+"info           Provides this information blurb\n"
+"swver          Prints the software version information of this driver\n"
+"autoneg        Auto-negotiate Mode = 1\n"
+"rspeed         Requested Speed, 100=100Mbps, 10=10Mpbs\n"
+"rfduplx        Requested Full Duplex Operation\n"
+"aspeed         Actual Speed, 100=100Mbps, 10=10Mpbs\n"
+"afduplx        Actual Full Duplex Operation\n"
+"lnkfail        PHY Link Failure when 1\n"
+"miiop          External MII when 1, Internal PHY when 0\n"
+"swfdup         Switched Full Duplex Mode (allowed only in MII operation)\n"
+"ephloop        EPH Block Loopback\n"
+"forcol         Force a collision\n"
+"filtcar        Filter leading edge of carrier sense for 12 bit times\n"
+"freemem        Free buffer memory in bytes\n"
+"totmem         Total buffer memory in bytes\n"
+"leda           Output of LED-A (green)\n"
+"ledb           Output of LED-B (yellow)\n"
+"chiprev        Revision ID of the LAN91C111 chip\n"
+"";
+
+/*------------------------------------------------------------
+ . Sysctl handler for all integer parameters
+ .-------------------------------------------------------------*/
+static int smc_sysctl_handler(ctl_table *ctl, int write, struct file * filp,
+				void *buffer, size_t *lenp)
+{
+	struct net_device *dev = (struct net_device*)ctl->extra1;
+	struct smc_local *lp = (struct smc_local *)ctl->extra2;
+	unsigned long ioaddr = dev->base_addr;
+	int *valp = ctl->data;
+	int val;
+	int ret;
+
+	// Update parameters from the real registers
+	switch (ctl->ctl_name)
+	{
+	case CTL_SMC_FORCOL:
+		*valp = smc_get_regbit(0, ioaddr, TCR_REG, TCR_FORCOL);
+		break;
+
+	case CTL_SMC_FREEMEM:
+		*valp = ( (word)smc_get_reg(0, ioaddr, MIR_REG) >> 8 )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+
+	case CTL_SMC_TOTMEM:
+		*valp = ( smc_get_reg(0, ioaddr, MIR_REG) & (word)0x00ff )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+	case CTL_SMC_CHIPREV:
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_AFDUPLX:
+		*valp = (lp->lastPhy18 & PHY_INT_DPLXDET) ? 1 : 0;
+		break;
+
+	case CTL_SMC_ASPEED:
+		*valp = (lp->lastPhy18 & PHY_INT_SPDDET) ? 100 : 10;
+		break;
+
+	case CTL_SMC_LNKFAIL:
+		*valp = (lp->lastPhy18 & PHY_INT_LNKFAIL) ? 1 : 0;
+		break;
+
+	case CTL_SMC_LEDA:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXA_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_LEDB:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXB_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_MIIOP:
+		*valp = smc_get_regbit(1, ioaddr, CONFIG_REG, CONFIG_EXT_PHY);
+		break;
+
+#if SMC_DEBUG > 1
+	case CTL_SMC_REG_BSR:	// Bank Select
+		*valp = smc_get_reg(0, ioaddr, BSR_REG);
+		break;
+
+	case CTL_SMC_REG_TCR:	// Transmit Control
+		*valp = smc_get_reg(0, ioaddr, TCR_REG);
+		break;
+
+	case CTL_SMC_REG_ESR:	// EPH Status
+		*valp = smc_get_reg(0, ioaddr, EPH_STATUS_REG);
+		break;
+
+	case CTL_SMC_REG_RCR:	// Receive Control
+		*valp = smc_get_reg(0, ioaddr, RCR_REG);
+		break;
+
+	case CTL_SMC_REG_CTRR:	// Counter
+		*valp = smc_get_reg(0, ioaddr, COUNTER_REG);
+		break;
+
+	case CTL_SMC_REG_MIR:	// Memory Information
+		*valp = smc_get_reg(0, ioaddr, MIR_REG);
+		break;
+
+	case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+		*valp = smc_get_reg(0, ioaddr, RPC_REG);
+		break;
+
+	case CTL_SMC_REG_CFGR:	// Configuration
+		*valp = smc_get_reg(1, ioaddr, CONFIG_REG);
+		break;
+
+	case CTL_SMC_REG_BAR:	// Base Address
+		*valp = smc_get_reg(1, ioaddr, BASE_REG);
+		break;
+
+	case CTL_SMC_REG_IAR0:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR0_REG);
+		break;
+
+	case CTL_SMC_REG_IAR1:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR1_REG);
+		break;
+
+	case CTL_SMC_REG_IAR2:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR2_REG);
+		break;
+
+	case CTL_SMC_REG_GPR:	// General Purpose
+		*valp = smc_get_reg(1, ioaddr, GP_REG);
+		break;
+
+	case CTL_SMC_REG_CTLR:	// Control
+		*valp = smc_get_reg(1, ioaddr, CTL_REG);
+		break;
+
+	case CTL_SMC_REG_MCR:	// MMU Command
+		*valp = smc_get_reg(2, ioaddr, MMU_CMD_REG);
+		break;
+
+	case CTL_SMC_REG_PNR:	// Packet Number
+		*valp = smc_get_reg(2, ioaddr, PN_REG);
+		break;
+
+	case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+		*valp = smc_get_reg(2, ioaddr, RXFIFO_REG);
+		break;
+
+	case CTL_SMC_REG_PTR:	// Pointer
+		*valp = smc_get_reg(2, ioaddr, PTR_REG);
+		break;
+
+	case CTL_SMC_REG_DR:	// Data
+		*valp = smc_get_reg(2, ioaddr, DATA_REG);
+		break;
+
+	case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+		*valp = smc_get_reg(2, ioaddr, INT_REG);
+		break;
+
+	case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG1);
+		break;
+
+	case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG2);
+		break;
+
+	case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG3);
+		break;
+
+	case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG4);
+		break;
+
+	case CTL_SMC_REG_MIIR:	// Management Interface
+		*valp = smc_get_reg(3, ioaddr, MII_REG);
+		break;
+
+	case CTL_SMC_REG_REVR:	// Revision
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_REG_ERCVR:	// Early RCV
+		*valp = smc_get_reg(3, ioaddr, ERCV_REG);
+		break;
+
+	case CTL_SMC_REG_EXTR:	// External
+		*valp = smc_get_reg(7, ioaddr, EXT_REG);
+		break;
+
+	case CTL_SMC_PHY_CTRL:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CNTL_REG);
+		break;
+
+	case CTL_SMC_PHY_STAT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_STAT_REG);
+		break;
+
+	case CTL_SMC_PHY_ID1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID1_REG);
+		break;
+
+	case CTL_SMC_PHY_ID2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID2_REG);
+		break;
+
+	case CTL_SMC_PHY_ADC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_AD_REG);
+		break;
+
+	case CTL_SMC_PHY_REMC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_RMT_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG1_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG2_REG);
+		break;
+
+	case CTL_SMC_PHY_INT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_INT_REG);
+		break;
+
+	case CTL_SMC_PHY_MASK:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_MASK_REG);
+		break;
+
+#endif // SMC_DEBUG > 1
+
+	default:
+		// Just ignore unsupported parameters
+		break;
+	}
+
+	// Save old state
+	val = *valp;
+
+	// Perform the generic integer operation
+	if ((ret = proc_dointvec(ctl, write, filp, buffer, lenp)) != 0)
+		return(ret);
+
+	// Write changes out to the registers
+	if (write && *valp != val) {
+
+		val = *valp;
+		switch (ctl->ctl_name) {
+
+		case CTL_SMC_SWFDUP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_SWFDUP;
+			else
+				lp->tcr_cur_mode &= ~TCR_SWFDUP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_SWFDUP, val);
+			break;
+
+		case CTL_SMC_EPHLOOP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_EPH_LOOP;
+			else
+				lp->tcr_cur_mode &= ~TCR_EPH_LOOP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_EPH_LOOP, val);
+			break;
+
+		case CTL_SMC_FORCOL:
+			if (val)
+				lp->tcr_cur_mode |= TCR_FORCOL;
+			else
+				lp->tcr_cur_mode &= ~TCR_FORCOL;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_FORCOL, val);
+			break;
+
+		case CTL_SMC_FILTCAR:
+			if (val)
+				lp->rcr_cur_mode |= RCR_FILT_CAR;
+			else
+				lp->rcr_cur_mode &= ~RCR_FILT_CAR;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, RCR_REG, RCR_FILT_CAR, val);
+			break;
+
+		case CTL_SMC_RFDUPLX:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val)
+				lp->rpc_cur_mode |= RPC_DPLX;
+			else
+				lp->rpc_cur_mode &= ~RPC_DPLX;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_RSPEED:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val > 10)
+				lp->rpc_cur_mode |= RPC_SPEED;
+			else
+				lp->rpc_cur_mode &= ~RPC_SPEED;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_AUTONEG:
+			if (val)
+				lp->rpc_cur_mode |= RPC_ANEG;
+			else
+				lp->rpc_cur_mode &= ~RPC_ANEG;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_LEDA:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXA_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXA_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_LEDB:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXB_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXB_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_MIIOP:
+			// Update the Internal PHY block
+			smc_modify_regbit(1, ioaddr, CONFIG_REG,
+				CONFIG_EXT_PHY, val);
+			break;
+
+#if SMC_DEBUG > 1
+		case CTL_SMC_REG_BSR:	// Bank Select
+			smc_modify_reg(0, ioaddr, BSR_REG, val);
+			break;
+
+		case CTL_SMC_REG_TCR:	// Transmit Control
+			smc_modify_reg(0, ioaddr, TCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_ESR:	// EPH Status
+			smc_modify_reg(0, ioaddr, EPH_STATUS_REG, val);
+			break;
+
+		case CTL_SMC_REG_RCR:	// Receive Control
+			smc_modify_reg(0, ioaddr, RCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTRR:	// Counter
+			smc_modify_reg(0, ioaddr, COUNTER_REG, val);
+			break;
+
+		case CTL_SMC_REG_MIR:	// Memory Information
+			smc_modify_reg(0, ioaddr, MIR_REG, val);
+			break;
+
+		case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+			smc_modify_reg(0, ioaddr, RPC_REG, val);
+			break;
+
+		case CTL_SMC_REG_CFGR:	// Configuration
+			smc_modify_reg(1, ioaddr, CONFIG_REG, val);
+			break;
+
+		case CTL_SMC_REG_BAR:	// Base Address
+			smc_modify_reg(1, ioaddr, BASE_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR0:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR0_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR1:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR1_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR2:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR2_REG, val);
+			break;
+
+		case CTL_SMC_REG_GPR:	// General Purpose
+			smc_modify_reg(1, ioaddr, GP_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTLR:	// Control
+			smc_modify_reg(1, ioaddr, CTL_REG, val);
+			break;
+
+		case CTL_SMC_REG_MCR:	// MMU Command
+			smc_modify_reg(2, ioaddr, MMU_CMD_REG, val);
+			break;
+
+		case CTL_SMC_REG_PNR:	// Packet Number
+			smc_modify_reg(2, ioaddr, PN_REG, val);
+			break;
+
+		case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+			smc_modify_reg(2, ioaddr, RXFIFO_REG, val);
+			break;
+
+		case CTL_SMC_REG_PTR:	// Pointer
+			smc_modify_reg(2, ioaddr, PTR_REG, val);
+			break;
+
+		case CTL_SMC_REG_DR:	// Data
+			smc_modify_reg(2, ioaddr, DATA_REG, val);
+			break;
+
+		case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+			smc_modify_reg(2, ioaddr, INT_REG, val);
+			break;
+
+		case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+			smc_modify_reg(3, ioaddr, MCAST_REG1, val);
+			break;
+
+		case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+			smc_modify_reg(3, ioaddr, MCAST_REG2, val);
+			break;
+
+		case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+			smc_modify_reg(3, ioaddr, MCAST_REG3, val);
+			break;
+
+		case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+			smc_modify_reg(3, ioaddr, MCAST_REG4, val);
+			break;
+
+		case CTL_SMC_REG_MIIR:	// Management Interface
+			smc_modify_reg(3, ioaddr, MII_REG, val);
+			break;
+
+		case CTL_SMC_REG_REVR:	// Revision
+			smc_modify_reg(3, ioaddr, REV_REG, val);
+			break;
+
+		case CTL_SMC_REG_ERCVR:	// Early RCV
+			smc_modify_reg(3, ioaddr, ERCV_REG, val);
+			break;
+
+		case CTL_SMC_REG_EXTR:	// External
+			smc_modify_reg(7, ioaddr, EXT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CTRL:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CNTL_REG, val);
+			break;
+
+		case CTL_SMC_PHY_STAT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_STAT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ADC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_AD_REG, val);
+			break;
+
+		case CTL_SMC_PHY_REMC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_RMT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_INT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_INT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_MASK:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_MASK_REG, val);
+			break;
+
+#endif // SMC_DEBUG > 1
+
+		default:
+			// Just ignore unsupported parameters
+			break;
+		} // end switch
+
+	} // end if
+
+        return ret;
+}
+
+
+#ifdef MODULE
+/*
+ * This is called as the fill_inode function when an inode
+ * is going into (fill = 1) or out of service (fill = 0).
+ * We use it here to manage the module use counts.
+ *
+ * Note: only the top-level directory needs to do this; if
+ * a lower level is referenced, the parent will be as well.
+ */
+static void smc_procfs_modcount(struct inode *inode, int fill)
+{
+	if (fill)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
+}
+#endif // MODULE
+
+/*------------------------------------------------------------
+ . Sysctl registration function for all parameters (files)
+ .-------------------------------------------------------------*/
+static void smc_sysctl_register(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	static int ctl_name = CTL_SMC;
+	ctl_table* ct;
+	int i;
+
+	// Make sure the ctl_tables start out as all zeros
+	memset(lp->root_table, 0, sizeof lp->root_table);
+	memset(lp->eth_table, 0, sizeof lp->eth_table);
+	memset(lp->param_table, 0, sizeof lp->param_table);
+
+	// Initialize the root table
+	ct = lp->root_table;
+	ct->ctl_name = CTL_DEV;
+	ct->procname = "dev";
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->eth_table;
+	// remaining fields are zero
+
+	// Initialize the ethX table (this device's table)
+	ct = lp->eth_table;
+	ct->ctl_name = ctl_name++; // Must be unique
+	ct->procname = dev->name;
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->param_table;
+	// remaining fields are zero
+
+	// Initialize the parameter (files) table
+	// Make sure the last entry remains null
+	ct = lp->param_table;
+	for (i = 0; i < (CTL_SMC_LAST_ENTRY-1); ++i) {
+		// Initialize fields common to all table entries
+		ct[i].proc_handler = smc_sysctl_handler;
+		ct[i].extra1 = (void*)dev; // Save our device pointer
+		ct[i].extra2 = (void*)lp;  // Save our smc_local data pointer
+	}
+
+	// INFO - this is our only string parameter
+	i = 0;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_INFO;
+	ct[i].procname = "info";
+	ct[i].data = (void*)smc_info_string;
+	ct[i].maxlen = sizeof smc_info_string;
+	ct[i].mode = 0444; // Read only
+
+	// SWVER
+	++i;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_SWVER;
+	ct[i].procname = "swver";
+	ct[i].data = (void*)version;
+	ct[i].maxlen = sizeof version;
+	ct[i].mode = 0444; // Read only
+
+	// SWFDUP
+	++i;
+	ct[i].ctl_name = CTL_SMC_SWFDUP;
+	ct[i].procname = "swfdup";
+	ct[i].data = (void*)&(lp->ctl_swfdup);
+	ct[i].maxlen = sizeof lp->ctl_swfdup;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// EPHLOOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_EPHLOOP;
+	ct[i].procname = "ephloop";
+	ct[i].data = (void*)&(lp->ctl_ephloop);
+	ct[i].maxlen = sizeof lp->ctl_ephloop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// MIIOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_MIIOP;
+	ct[i].procname = "miiop";
+	ct[i].data = (void*)&(lp->ctl_miiop);
+	ct[i].maxlen = sizeof lp->ctl_miiop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AUTONEG
+	++i;
+	ct[i].ctl_name = CTL_SMC_AUTONEG;
+	ct[i].procname = "autoneg";
+	ct[i].data = (void*)&(lp->ctl_autoneg);
+	ct[i].maxlen = sizeof lp->ctl_autoneg;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_RFDUPLX;
+	ct[i].procname = "rfduplx";
+	ct[i].data = (void*)&(lp->ctl_rfduplx);
+	ct[i].maxlen = sizeof lp->ctl_rfduplx;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RSPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_RSPEED;
+	ct[i].procname = "rspeed";
+	ct[i].data = (void*)&(lp->ctl_rspeed);
+	ct[i].maxlen = sizeof lp->ctl_rspeed;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_AFDUPLX;
+	ct[i].procname = "afduplx";
+	ct[i].data = (void*)&(lp->ctl_afduplx);
+	ct[i].maxlen = sizeof lp->ctl_afduplx;
+	ct[i].mode = 0444; // Read only
+
+	// ASPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_ASPEED;
+	ct[i].procname = "aspeed";
+	ct[i].data = (void*)&(lp->ctl_aspeed);
+	ct[i].maxlen = sizeof lp->ctl_aspeed;
+	ct[i].mode = 0444; // Read only
+
+	// LNKFAIL
+	++i;
+	ct[i].ctl_name = CTL_SMC_LNKFAIL;
+	ct[i].procname = "lnkfail";
+	ct[i].data = (void*)&(lp->ctl_lnkfail);
+	ct[i].maxlen = sizeof lp->ctl_lnkfail;
+	ct[i].mode = 0444; // Read only
+
+	// FORCOL
+	++i;
+	ct[i].ctl_name = CTL_SMC_FORCOL;
+	ct[i].procname = "forcol";
+	ct[i].data = (void*)&(lp->ctl_forcol);
+	ct[i].maxlen = sizeof lp->ctl_forcol;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FILTCAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_FILTCAR;
+	ct[i].procname = "filtcar";
+	ct[i].data = (void*)&(lp->ctl_filtcar);
+	ct[i].maxlen = sizeof lp->ctl_filtcar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FREEMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_FREEMEM;
+	ct[i].procname = "freemem";
+	ct[i].data = (void*)&(lp->ctl_freemem);
+	ct[i].maxlen = sizeof lp->ctl_freemem;
+	ct[i].mode = 0444; // Read only
+
+	// TOTMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_TOTMEM;
+	ct[i].procname = "totmem";
+	ct[i].data = (void*)&(lp->ctl_totmem);
+	ct[i].maxlen = sizeof lp->ctl_totmem;
+	ct[i].mode = 0444; // Read only
+
+	// LEDA
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDA;
+	ct[i].procname = "leda";
+	ct[i].data = (void*)&(lp->ctl_leda);
+	ct[i].maxlen = sizeof lp->ctl_leda;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// LEDB
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDB;
+	ct[i].procname = "ledb";
+	ct[i].data = (void*)&(lp->ctl_ledb);
+	ct[i].maxlen = sizeof lp->ctl_ledb;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// CHIPREV
+	++i;
+	ct[i].ctl_name = CTL_SMC_CHIPREV;
+	ct[i].procname = "chiprev";
+	ct[i].data = (void*)&(lp->ctl_chiprev);
+	ct[i].maxlen = sizeof lp->ctl_chiprev;
+	ct[i].mode = 0444; // Read only
+
+#if SMC_DEBUG > 1
+	// REG_BSR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BSR;
+	ct[i].procname = "reg_bsr";
+	ct[i].data = (void*)&(lp->ctl_reg_bsr);
+	ct[i].maxlen = sizeof lp->ctl_reg_bsr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_TCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_TCR;
+	ct[i].procname = "reg_tcr";
+	ct[i].data = (void*)&(lp->ctl_reg_tcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_tcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ESR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ESR;
+	ct[i].procname = "reg_esr";
+	ct[i].data = (void*)&(lp->ctl_reg_esr);
+	ct[i].maxlen = sizeof lp->ctl_reg_esr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RCR;
+	ct[i].procname = "reg_rcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTRR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTRR;
+	ct[i].procname = "reg_ctrr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctrr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctrr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIR;
+	ct[i].procname = "reg_mir";
+	ct[i].data = (void*)&(lp->ctl_reg_mir);
+	ct[i].maxlen = sizeof lp->ctl_reg_mir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RPCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RPCR;
+	ct[i].procname = "reg_rpcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rpcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rpcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CFGR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CFGR;
+	ct[i].procname = "reg_cfgr";
+	ct[i].data = (void*)&(lp->ctl_reg_cfgr);
+	ct[i].maxlen = sizeof lp->ctl_reg_cfgr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_BAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BAR;
+	ct[i].procname = "reg_bar";
+	ct[i].data = (void*)&(lp->ctl_reg_bar);
+	ct[i].maxlen = sizeof lp->ctl_reg_bar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR0
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR0;
+	ct[i].procname = "reg_iar0";
+	ct[i].data = (void*)&(lp->ctl_reg_iar0);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar0;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR1;
+	ct[i].procname = "reg_iar1";
+	ct[i].data = (void*)&(lp->ctl_reg_iar1);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR2;
+	ct[i].procname = "reg_iar2";
+	ct[i].data = (void*)&(lp->ctl_reg_iar2);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_GPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_GPR;
+	ct[i].procname = "reg_gpr";
+	ct[i].data = (void*)&(lp->ctl_reg_gpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_gpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTLR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTLR;
+	ct[i].procname = "reg_ctlr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctlr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctlr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MCR;
+	ct[i].procname = "reg_mcr";
+	ct[i].data = (void*)&(lp->ctl_reg_mcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_mcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PNR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PNR;
+	ct[i].procname = "reg_pnr";
+	ct[i].data = (void*)&(lp->ctl_reg_pnr);
+	ct[i].maxlen = sizeof lp->ctl_reg_pnr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_FPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_FPR;
+	ct[i].procname = "reg_fpr";
+	ct[i].data = (void*)&(lp->ctl_reg_fpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_fpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PTR;
+	ct[i].procname = "reg_ptr";
+	ct[i].data = (void*)&(lp->ctl_reg_ptr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ptr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_DR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_DR;
+	ct[i].procname = "reg_dr";
+	ct[i].data = (void*)&(lp->ctl_reg_dr);
+	ct[i].maxlen = sizeof lp->ctl_reg_dr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ISR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ISR;
+	ct[i].procname = "reg_isr";
+	ct[i].data = (void*)&(lp->ctl_reg_isr);
+	ct[i].maxlen = sizeof lp->ctl_reg_isr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR1;
+	ct[i].procname = "reg_mtr1";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr1);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR2;
+	ct[i].procname = "reg_mtr2";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr2);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR3
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR3;
+	ct[i].procname = "reg_mtr3";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr3);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr3;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR4
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR4;
+	ct[i].procname = "reg_mtr4";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr4);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr4;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIIR;
+	ct[i].procname = "reg_miir";
+	ct[i].data = (void*)&(lp->ctl_reg_miir);
+	ct[i].maxlen = sizeof lp->ctl_reg_miir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_REVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_REVR;
+	ct[i].procname = "reg_revr";
+	ct[i].data = (void*)&(lp->ctl_reg_revr);
+	ct[i].maxlen = sizeof lp->ctl_reg_revr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ERCVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ERCVR;
+	ct[i].procname = "reg_ercvr";
+	ct[i].data = (void*)&(lp->ctl_reg_ercvr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ercvr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_EXTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_EXTR;
+	ct[i].procname = "reg_extr";
+	ct[i].data = (void*)&(lp->ctl_reg_extr);
+	ct[i].maxlen = sizeof lp->ctl_reg_extr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Control
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CTRL;
+	ct[i].procname = "phy_ctrl";
+	ct[i].data = (void*)&(lp->ctl_phy_ctrl);
+	ct[i].maxlen = sizeof lp->ctl_phy_ctrl;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Status
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_STAT;
+	ct[i].procname = "phy_stat";
+	ct[i].data = (void*)&(lp->ctl_phy_stat);
+	ct[i].maxlen = sizeof lp->ctl_phy_stat;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID1;
+	ct[i].procname = "phy_id1";
+	ct[i].data = (void*)&(lp->ctl_phy_id1);
+	ct[i].maxlen = sizeof lp->ctl_phy_id1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID2;
+	ct[i].procname = "phy_id2";
+	ct[i].data = (void*)&(lp->ctl_phy_id2);
+	ct[i].maxlen = sizeof lp->ctl_phy_id2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Advertise Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ADC;
+	ct[i].procname = "phy_adc";
+	ct[i].data = (void*)&(lp->ctl_phy_adc);
+	ct[i].maxlen = sizeof lp->ctl_phy_adc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Remote Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_REMC;
+	ct[i].procname = "phy_remc";
+	ct[i].data = (void*)&(lp->ctl_phy_remc);
+	ct[i].maxlen = sizeof lp->ctl_phy_remc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG1;
+	ct[i].procname = "phy_cfg1";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg1);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG2;
+	ct[i].procname = "phy_cfg2";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg2);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Output
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_INT;
+	ct[i].procname = "phy_int";
+	ct[i].data = (void*)&(lp->ctl_phy_int);
+	ct[i].maxlen = sizeof lp->ctl_phy_int;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Mask
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_MASK;
+	ct[i].procname = "phy_mask";
+	ct[i].data = (void*)&(lp->ctl_phy_mask);
+	ct[i].maxlen = sizeof lp->ctl_phy_mask;
+	ct[i].mode = 0644; // Read by all, write by root
+
+#endif // SMC_DEBUG > 1
+
+	// Register /proc/sys/dev/ethX
+	lp->sysctl_header = register_sysctl_table(lp->root_table, 1);
+
+#ifdef MODULE
+	// Register our modcount function which adjusts the module count
+	lp->root_table->child->de->fill_inode = smc_procfs_modcount;
+#endif // MODULE
+
+}
+
+
+/*------------------------------------------------------------
+ . Sysctl unregistration when driver is closed
+ .-------------------------------------------------------------*/
+static void smc_sysctl_unregister(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	unregister_sysctl_table(lp->sysctl_header);
+}
+
+#endif /* endif CONFIG_SYSCTL */
+
+
+//---PHY CONTROL AND CONFIGURATION-----------------------------------------
+
+#if (SMC_DEBUG > 2 )
+
+/*------------------------------------------------------------
+ . Debugging function for viewing MII Management serial bitstream
+ .-------------------------------------------------------------*/
+static void smc_dump_mii_stream(byte* bits, int size)
+{
+	int i;
+
+	printk("BIT#:");
+	for (i = 0; i < size; ++i)
+		printk("%d", i%10);
+
+	printk("\nMDOE:");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDOE)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\nMDO :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDO)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\nMDI :");
+	for (i = 0; i < size; ++i) {
+		if (bits[i] & MII_MDI)
+			printk("1");
+		else
+			printk("0");
+	}
+
+	printk("\n");
+}
+#endif
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static word smc_read_phy_register(unsigned long ioaddr,
+				  byte phyaddr, byte phyreg)
+{
+	int oldBank;
+	int i;
+	byte mask;
+	word mii_reg;
+	byte bits[64];
+	int clk_idx = 0;
+	int input_idx;
+	word phydata;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Read command <10>
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+	bits[clk_idx++] = MII_MDOE;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	//bits[clk_idx++] = 0;
+
+	// Input starts at this bit time
+	input_idx = clk_idx;
+
+	// Will input 16 bits
+	for (i = 0; i < 16; ++i)
+		bits[clk_idx++] = 0;
+
+	// Final clock bit
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = SMC_CURRENT_BANK();
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = SMC_GET_MII();
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all 64 cycles
+	for (i = 0; i < sizeof bits; ++i) {
+		// Clock Low - output data
+		SMC_SET_MII( mii_reg | bits[i] );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		SMC_SET_MII( mii_reg | bits[i] | MII_MCLK );
+		udelay(50);
+		bits[i] |= SMC_GET_MII() & MII_MDI;
+	}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	SMC_SET_MII( mii_reg );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+	// Recover input data
+	phydata = 0;
+	for (i = 0; i < 16; ++i) {
+		phydata <<= 1;
+
+		if (bits[input_idx++] & MII_MDI)
+			phydata |= 0x0001;
+	}
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_read_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+
+	return(phydata);
+}
+
+
+/*------------------------------------------------------------
+ . Writes a register to the MII Management serial interface
+ .-------------------------------------------------------------*/
+static void smc_write_phy_register(unsigned long ioaddr,
+	byte phyaddr, byte phyreg, word phydata)
+{
+	int oldBank;
+	int i;
+	word mask;
+	word mii_reg;
+	byte bits[65];
+	int clk_idx = 0;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Write command <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i) {
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	bits[clk_idx++] = 0;
+
+	// Write out 16 bits of data, msb first
+	mask = 0x8000;
+	for (i = 0; i < 16; ++i) {
+		if (phydata & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+	}
+
+	// Final clock bit (tristate)
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = SMC_CURRENT_BANK();
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = SMC_GET_MII();
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all cycles
+	for (i = 0; i < sizeof bits; ++i) {
+		// Clock Low - output data
+		SMC_SET_MII( mii_reg | bits[i] );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		SMC_SET_MII( mii_reg | bits[i] | MII_MCLK );
+		udelay(50);
+		bits[i] |= SMC_GET_MII() & MII_MDI;
+	}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	SMC_SET_MII( mii_reg );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_write_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+}
+
+
+/*------------------------------------------------------------
+ . Finds and reports the PHY address
+ .-------------------------------------------------------------*/
+static int smc_detect_phy(struct net_device* dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	unsigned long ioaddr = dev->base_addr;
+	word phy_id1;
+	word phy_id2;
+	int phyaddr;
+	int found = 0;
+
+	PRINTK3("%s:smc_detect_phy()\n", dev->name);
+
+	// Scan all 32 PHY addresses if necessary
+	for (phyaddr = 0; phyaddr < 32; ++phyaddr) {
+		// Read the PHY identifiers
+		phy_id1  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID1_REG);
+		phy_id2  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID2_REG);
+
+		PRINTK3("%s: phy_id1=%x, phy_id2=%x\n",
+			dev->name, phy_id1, phy_id2);
+
+		// Make sure it is a valid identifier
+		if ((phy_id2 > 0x0000) && (phy_id2 < 0xffff) &&
+		    (phy_id1 > 0x0000) && (phy_id1 < 0xffff)) {
+			if ((phy_id1 != 0x8000) && (phy_id2 != 0x8000)) {
+				// Save the PHY's address
+				lp->phyaddr = phyaddr;
+				found = 1;
+				break;
+			}
+		}
+	}
+
+	if (!found) {
+		PRINTK("%s: No PHY found\n", dev->name);
+		return(0);
+	}
+
+	// Set the PHY type
+	if ( (phy_id1 == 0x0016) && ((phy_id2 & 0xFFF0) == 0xF840 ) ) {
+		lp->phytype = PHY_LAN83C183;
+		PRINTK("%s: PHY=LAN83C183 (LAN91C111 Internal)\n", dev->name);
+	}
+
+	if ( (phy_id1 == 0x0282) && ((phy_id2 & 0xFFF0) == 0x1C50) ) {
+		lp->phytype = PHY_LAN83C180;
+		PRINTK("%s: PHY=LAN83C180\n", dev->name);
+	}
+
+	return(1);
+}
+
+/*------------------------------------------------------------
+ . Waits the specified number of milliseconds - kernel friendly
+ .-------------------------------------------------------------*/
+static void smc_wait_ms(unsigned int ms)
+{
+
+	if (!in_interrupt()) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+	} else {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1 + ms * HZ / 1000);
+		set_current_state(TASK_RUNNING);
+	}
+}
+
+/*------------------------------------------------------------
+ . Sets the PHY to a configuration as determined by the user
+ .-------------------------------------------------------------*/
+static int smc_phy_fixed(struct net_device* dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word my_fixed_caps;
+	word cfg1;
+
+	PRINTK3("%s:smc_phy_fixed()\n", dev->name);
+
+	// Enter Link Disable state
+	cfg1 = smc_read_phy_register(ioaddr, phyaddr, PHY_CFG1_REG);
+	cfg1 |= PHY_CFG1_LNKDIS;
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CFG1_REG, cfg1);
+
+	// Set our fixed capabilities
+	// Disable auto-negotiation
+	my_fixed_caps = 0;
+
+	if (lp->ctl_rfduplx)
+		my_fixed_caps |= PHY_CNTL_DPLX;
+
+	if (lp->ctl_rspeed == 100)
+		my_fixed_caps |= PHY_CNTL_SPEED;
+
+	// Write our capabilities to the phy control register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, my_fixed_caps);
+
+	// Re-Configure the Receive/Phy Control register
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+	// Success
+	return(1);
+}
+
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+static void smc_phy_configure(struct net_device* dev)
+{
+	unsigned long ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	int timeout;
+	byte phyaddr;
+	word my_phy_caps; // My PHY capabilities
+	word my_ad_caps; // My Advertised capabilities
+	word status;
+	int failed = 0;
+
+	PRINTK3("%s:smc_program_phy()\n", dev->name);
+
+	// Set the blocking flag
+	lp->autoneg_active = 1;
+
+	// Find the address and type of our phy
+	if (!smc_detect_phy(dev))
+		goto smc_phy_configure_exit;
+
+	// Get the detected phy address
+	phyaddr = lp->phyaddr;
+
+	// Reset the PHY, setting all other bits to zero
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, PHY_CNTL_RST);
+
+	// Wait for the reset to complete, or time out
+	timeout = 6; // Wait up to 3 seconds
+	while (timeout--) {
+		if (!(smc_read_phy_register(ioaddr, phyaddr, PHY_CNTL_REG)
+		    & PHY_CNTL_RST))
+			// reset complete
+			break;
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) { // Exit anyway if signaled
+			PRINTK2("%s:PHY reset interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+		}
+	}
+
+	if (timeout < 1) {
+		printk("%s:PHY reset timed out\n", dev->name);
+		goto smc_phy_configure_exit;
+	}
+
+	// Read PHY Register 18, Status Output
+	lp->lastPhy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+	// Enable PHY Interrupts (for register 18)
+	// Interrupts listed here are disabled
+	smc_write_phy_register(ioaddr, phyaddr, PHY_MASK_REG,
+		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
+		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
+		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+
+	/* Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK( 0 );
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+	// Copy our capabilities from PHY_STAT_REG to PHY_AD_REG
+	my_phy_caps = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+	my_ad_caps  = PHY_AD_CSMA; // I am CSMA capable
+
+	if (my_phy_caps & PHY_STAT_CAP_T4)
+		my_ad_caps |= PHY_AD_T4;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXF)
+		my_ad_caps |= PHY_AD_TX_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXH)
+		my_ad_caps |= PHY_AD_TX_HDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TF)
+		my_ad_caps |= PHY_AD_10_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TH)
+		my_ad_caps |= PHY_AD_10_HDX;
+
+	// Disable capabilities not selected by our user
+	if (lp->ctl_rspeed != 100)
+		my_ad_caps &= ~(PHY_AD_T4|PHY_AD_TX_FDX|PHY_AD_TX_HDX);
+
+	if (!lp->ctl_rfduplx)
+		my_ad_caps &= ~(PHY_AD_TX_FDX|PHY_AD_10_FDX);
+
+	// Update our Auto-Neg Advertisement Register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_AD_REG, my_ad_caps);
+
+	// Read the register back.  Without this, it appears that when
+	// auto-negotiation is restarted, sometimes it isn't ready and
+	// the link does not come up.
+	status = smc_read_phy_register(ioaddr, phyaddr, PHY_AD_REG);
+
+	PRINTK2("%s:phy caps=%x\n", dev->name, my_phy_caps);
+	PRINTK2("%s:phy advertised caps=%x\n", dev->name, my_ad_caps);
+
+	// If the user requested no auto neg, then go set his request
+	if (!(lp->ctl_autoneg)) {
+		smc_phy_fixed(dev);
+		goto smc_phy_configure_exit;
+	}
+
+	// Restart auto-negotiation process in order to advertise my caps
+	smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+		PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST );
+
+	// Wait for the auto-negotiation to complete.  This may take from
+	// 2 to 3 seconds.
+	// Wait for the reset to complete, or time out
+	timeout = 20; // Wait up to 10 seconds
+	while (timeout--) {
+		status = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+		if (status & PHY_STAT_ANEG_ACK)
+			// auto-negotiate complete
+			break;
+
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) { // Exit anyway if signaled
+			printk(KERN_DEBUG
+				"%s:PHY auto-negotiate interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+		}
+
+		// Restart auto-negotiation if remote fault
+		if (status & PHY_STAT_REM_FLT) {
+			PRINTK2("%s:PHY remote fault detected\n", dev->name);
+
+			// Restart auto-negotiation
+			PRINTK2("%s:PHY restarting auto-negotiation\n",
+				dev->name);
+			smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+				PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST |
+				PHY_CNTL_SPEED | PHY_CNTL_DPLX);
+		}
+	}
+
+	if (timeout < 1) {
+		printk(KERN_DEBUG "%s:PHY auto-negotiate timed out\n",
+			dev->name);
+		PRINTK2("%s:PHY auto-negotiate timed out\n", dev->name);
+		failed = 1;
+	}
+
+	// Fail if we detected an auto-negotiate remote fault
+	if (status & PHY_STAT_REM_FLT) {
+		printk(KERN_DEBUG "%s:PHY remote fault detected\n", dev->name);
+		PRINTK2("%s:PHY remote fault detected\n", dev->name);
+		failed = 1;
+	}
+
+	// The smc_phy_interrupt() routine will be called to update lastPhy18
+
+	// Set our sysctl parameters to match auto-negotiation results
+	if ( lp->lastPhy18 & PHY_INT_SPDDET ) {
+		PRINTK2("%s:PHY 100BaseT\n", dev->name);
+		lp->rpc_cur_mode |= RPC_SPEED;
+	} else {
+		PRINTK2("%s:PHY 10BaseT\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_SPEED;
+	}
+
+	if ( lp->lastPhy18 & PHY_INT_DPLXDET ) {
+		PRINTK2("%s:PHY Full Duplex\n", dev->name);
+		lp->rpc_cur_mode |= RPC_DPLX;
+	} else {
+		PRINTK2("%s:PHY Half Duplex\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_DPLX;
+	}
+
+	// Re-Configure the Receive/Phy Control register
+	SMC_SET_RPC( lp->rpc_cur_mode );
+
+smc_phy_configure_exit:
+	// Exit auto-negotiation
+	lp->autoneg_active = 0;
+}
+
+
+
+/*************************************************************************
+ . smc_phy_interrupt
+ .
+ . Purpose:  Handle interrupts relating to PHY register 18. This is
+ .  called from the "hard" interrupt handler.
+ .
+ ************************************************************************/
+static void smc_phy_interrupt(struct net_device* dev)
+{
+	unsigned long ioaddr	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word phy18;
+
+	PRINTK2("%s: smc_phy_interrupt\n", dev->name);
+
+	for(;;) {
+		// Read PHY Register 18, Status Output
+		phy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+		// Exit if not more changes
+		if (phy18 == lp->lastPhy18)
+			break;
+
+#if (SMC_DEBUG > 1 )
+		PRINTK2("%s:     phy18=0x%x\n", dev->name, phy18);
+		PRINTK2("%s: lastPhy18=0x%x\n", dev->name, lp->lastPhy18);
+
+		// Handle events
+		if ((phy18 & PHY_INT_LNKFAIL) !=
+				(lp->lastPhy18 & PHY_INT_LNKFAIL))
+			PRINTK2("%s: PHY Link Fail=%x\n", dev->name,
+					phy18 & PHY_INT_LNKFAIL);
+
+		if ((phy18 & PHY_INT_LOSSSYNC) !=
+				(lp->lastPhy18 & PHY_INT_LOSSSYNC))
+			PRINTK2("%s: PHY LOSS SYNC=%x\n", dev->name,
+					phy18 & PHY_INT_LOSSSYNC);
+
+		if ((phy18 & PHY_INT_CWRD) != (lp->lastPhy18 & PHY_INT_CWRD))
+			PRINTK2("%s: PHY INVALID 4B5B code=%x\n", dev->name,
+					phy18 & PHY_INT_CWRD);
+
+		if ((phy18 & PHY_INT_SSD) != (lp->lastPhy18 & PHY_INT_SSD))
+			PRINTK2("%s: PHY No Start Of Stream=%x\n", dev->name,
+					phy18 & PHY_INT_SSD);
+
+		if ((phy18 & PHY_INT_ESD) != (lp->lastPhy18 & PHY_INT_ESD))
+
+			PRINTK2("%s: PHY No End Of Stream=%x\n", dev->name,
+					phy18 & PHY_INT_ESD);
+
+		if ((phy18 & PHY_INT_RPOL) != (lp->lastPhy18 & PHY_INT_RPOL))
+			PRINTK2("%s: PHY Reverse Polarity Detected=%x\n",
+					dev->name, phy18 & PHY_INT_RPOL);
+
+		if ((phy18 & PHY_INT_JAB) != (lp->lastPhy18 & PHY_INT_JAB))
+			PRINTK2("%s: PHY Jabber Detected=%x\n", dev->name,
+					phy18 & PHY_INT_JAB);
+
+		if ((phy18 & PHY_INT_SPDDET) !=
+				(lp->lastPhy18 & PHY_INT_SPDDET))
+			PRINTK2("%s: PHY Speed Detect=%x\n", dev->name,
+					phy18 & PHY_INT_SPDDET);
+
+		if ((phy18 & PHY_INT_DPLXDET) !=
+				(lp->lastPhy18 & PHY_INT_DPLXDET))
+			PRINTK2("%s: PHY Duplex Detect=%x\n", dev->name,
+					phy18 & PHY_INT_DPLXDET);
+#endif
+		// Update the last phy 18 variable
+		lp->lastPhy18 = phy18;
+	}
+}
diff -purN /dev/shm/linux-2.5/drivers/net/smc91111.h linuxppc-2.5-benh/drivers/net/smc91111.h
--- /dev/shm/linux-2.5/drivers/net/smc91111.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/smc91111.h	2002-08-27 14:33:39.000000000 +0000
@@ -0,0 +1,712 @@
+/*------------------------------------------------------------------------
+ . smc91111.h - macros for the LAN91C111 Ethernet Driver
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for
+ . the LAN91C111 single chip ethernet controller.  It is a modified
+ . version of the smc9194.h file.
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ . 	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ . History
+ . 03/16/01		Daris A Nevil	Modified for use with LAN91C111 device
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC91111_H_
+#define _SMC91111_H_
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+
+/*
+ . Do you want to use 8 bit xfers?  This should work on all chips, as the
+ . chipset is designed to accommodate them, although some hardware engineers
+ . do not connect byte enables so 8 bit xfers can not be used.
+*/
+#ifdef CONFIG_SMC91111_USE_8_BIT
+#define SMC_inb(port)		inb(port)
+#define SMC_insb(port,buf,ns)	insb((port),(buf),(ns))
+#define SMC_outb(val,port)	outb((val),(port))
+#define SMC_outsb(port,buf,ns)	outsb((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_USE_8_BIT */
+
+/* Define 16 bit xfers. */
+#ifdef CONFIG_SMC91111_BYTE_SWAP
+#define SMC_inw(port)		swab16(inw(port))
+#define SMC_insw(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		word *__buf = (word *)(buf);				\
+		int __ns = (ns);					\
+		insw(__port,__buf,__ns);				\
+		while (__ns > 0) {					\
+			*__buf = swab16(*__buf);			\
+			__buf++;					\
+			__ns--;						\
+		}							\
+	} while (0)
+#define SMC_outw(val,port)	outw(swab16(val),(port))
+#define SMC_outsw(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		word *__buf = (word *)(buf);				\
+		int __ns = (ns);					\
+		while (__ns > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outw( /* swab16 */ (*__buf++), __port);		\
+			__ns--;						\
+		}							\
+	} while (0)
+#else /* CONFIG_SMC91111_BYTE_SWAP is not defined */
+#define SMC_inw(port)		inw(port)
+#define SMC_insw(port,buf,ns)	insw((port),(buf),(ns))
+#define SMC_outw(val,port)	outw((val),(port))
+#define SMC_outsw(port,buf,ns)	outsw((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_BYTE_SWAP */
+
+/*
+ . Do you want to use 32 bit xfers?  This should work on all chips, as the
+ . chipset is designed to accommodate them, although some hardware engineers
+ . do not connect all 32 data bits so 32 bit xfers can not be used.
+*/
+#ifdef CONFIG_SMC91111_USE_32_BIT
+#ifdef CONFIG_SMC91111_BYTE_SWAP
+#define SMC_inl(port)		swab32(inl(port))
+#define SMC_insl(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		dword *__buf = (dword *)(buf);				\
+		int __ns = (ns);					\
+		insl(__port,__buf,__ns);				\
+		while (__ns > 0) {					\
+			*__buf = swab32(*__buf);			\
+			__buf++;					\
+			__ns--;						\
+		}							\
+	} while (0)
+#define SMC_outl(val,port)	outl(swab32(val),(port))
+#define SMC_outsl(port,buf,ns) 						\
+	do {								\
+		unsigned long __port = (port);				\
+		dword *__buf = (dword *)(buf);				\
+		int __ns = (ns);					\
+		while (__ns > 0) {					\
+			/* Believe it or not, the swab isn't needed. */	\
+			outl( /* swab32 */ (*__buf++), __port);		\
+			__ns--;						\
+		}							\
+	} while (0)
+#else /* CONFIG_SMC91111_BYTE_SWAP is not defined */
+#define SMC_inl(port)		inl(port)
+#define SMC_insl(port,buf,ns)	insl((port),(buf),(ns))
+#define SMC_outl(val,port)	outl((val),(port))
+#define SMC_outsl(port,buf,ns)	outsl((port),(buf),(ns))
+#endif /* CONFIG_SMC91111_BYTE_SWAP */
+#endif /* CONFIG_SMC91111_USE_32_BIT */
+
+
+/* Because of bank switching, the LAN91xxx uses only 16 I/O ports */
+
+#define SMC_IO_EXTENT	16
+
+
+/*---------------------------------------------------------------
+ .
+ . A description of the SMSC registers is probably in order here,
+ . although for details, the SMC datasheet is invaluable.
+ .
+ . Basically, the chip has 4 banks of registers ( 0 to 3 ), which
+ . are accessed by writing a number into the BANK_SELECT register
+ . ( I also use a SMC_SELECT_BANK macro for this ).
+ .
+ . The banks are configured so that for most purposes, bank 2 is all
+ . that is needed for simple run time tasks.
+ -----------------------------------------------------------------------*/
+
+/*
+ . Bank Select Register:
+ .
+ .		yyyy yyyy 0000 00xx
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define BANK_SELECT		14
+
+// Transmit Control Register
+/* BANK 0  */
+#define TCR_REG 	0x0000 	// transmit control register
+#define TCR_ENABLE	0x0001	// When 1 we can transmit
+#define TCR_LOOP	0x0002	// Controls output pin LBK
+#define TCR_FORCOL	0x0004	// When 1 will force a collision
+#define TCR_PAD_EN	0x0080	// When 1 will pad tx frames < 64 bytes w/0
+#define TCR_NOCRC	0x0100	// When 1 will not append CRC to tx frames
+#define TCR_MON_CSN	0x0400	// When 1 tx monitors carrier
+#define TCR_FDUPLX    	0x0800  // When 1 enables full duplex operation
+#define TCR_STP_SQET	0x1000	// When 1 stops tx if Signal Quality Error
+#define TCR_EPH_LOOP	0x2000	// When 1 enables EPH block loopback
+#define TCR_SWFDUP	0x8000	// When 1 enables Switched Full Duplex mode
+
+#define TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */
+/* QUESTION: do I want to enable padding of short packets ? */
+#define TCR_DEFAULT  	TCR_ENABLE
+
+
+// EPH Status Register
+/* BANK 0  */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	// Last TX was successful
+#define ES_SNGL_COL	0x0002	// Single collision detected for last tx
+#define ES_MUL_COL	0x0004	// Multiple collisions detected for last tx
+#define ES_LTX_MULT	0x0008	// Last tx was a multicast
+#define ES_16COL	0x0010	// 16 Collisions Reached
+#define ES_SQET		0x0020	// Signal Quality Error Test
+#define ES_LTXBRD	0x0040	// Last tx was a broadcast
+#define ES_TXDEFR	0x0080	// Transmit Deferred
+#define ES_LATCOL	0x0200	// Late collision detected on last tx
+#define ES_LOSTCARR	0x0400	// Lost Carrier Sense
+#define ES_EXC_DEF	0x0800	// Excessive Deferral
+#define ES_CTR_ROL	0x1000	// Counter Roll Over indication
+#define ES_LINK_OK	0x4000	// Driven by inverted value of nLNK pin
+#define ES_TXUNRN	0x8000	// Tx Underrun
+
+
+// Receive Control Register
+/* BANK 0  */
+#define RCR_REG		0x0004
+#define RCR_RX_ABORT	0x0001	// Set if a rx frame was aborted
+#define RCR_PRMS	0x0002	// Enable promiscuous mode
+#define RCR_ALMUL	0x0004	// When set accepts all multicast frames
+#define RCR_RXEN	0x0100	// IFF this is set, we can receive packets
+#define RCR_STRIP_CRC	0x0200	// When set strips CRC from rx packets
+#define RCR_ABORT_ENB	0x0200	// When set will abort rx on collision
+#define RCR_FILT_CAR	0x0400	// When set filters leading 12 bit s of carrier
+#define RCR_SOFTRST	0x8000 	// resets the chip
+
+/* the normal settings for the RCR register : */
+#define RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	// set it to a base state
+
+// Counter Register
+/* BANK 0  */
+#define COUNTER_REG	0x0006
+
+// Memory Information Register
+/* BANK 0  */
+#define MIR_REG		0x0008
+
+// Receive/Phy Control Register
+/* BANK 0  */
+#define RPC_REG		0x000A
+#define RPC_SPEED	0x2000	// When 1 PHY is in 100Mbps mode.
+#define RPC_DPLX	0x1000	// When 1 PHY is in Full-Duplex Mode
+#define RPC_ANEG	0x0800	// When 1 PHY is in Auto-Negotiate Mode
+#define RPC_LSXA_SHFT	5	// Bits to shift LS2A,LS1A,LS0A to lsb
+#define RPC_LSXB_SHFT	2	// Bits to get LS2B,LS1B,LS0B to lsb
+#define RPC_LED_100_10	(0x00)	// LED = 100Mbps OR's with 10Mbps link detect
+#define RPC_LED_RES	(0x01)	// LED = Reserved
+#define RPC_LED_10	(0x02)	// LED = 10Mbps link detect
+#define RPC_LED_FD	(0x03)	// LED = Full Duplex Mode
+#define RPC_LED_TX_RX	(0x04)	// LED = TX or RX packet occurred
+#define RPC_LED_100	(0x05)	// LED = 100Mbps link dectect
+#define RPC_LED_TX	(0x06)	// LED = TX packet occurred
+#define RPC_LED_RX	(0x07)	// LED = RX packet occurred
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LED_100 << RPC_LSXA_SHFT) | (RPC_LED_FD << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+
+/* Bank 0 0x000C is reserved */
+
+// Bank Select Register
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+// Configuration Reg
+/* BANK 1 */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
+#define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
+#define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
+
+// Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+// Base Address Register
+/* BANK 1 */
+#define BASE_REG	0x0002
+
+
+// Individual Address Registers
+/* BANK 1 */
+#define ADDR0_REG	0x0004
+#define ADDR1_REG	0x0006
+#define ADDR2_REG	0x0008
+
+
+// General Purpose Register
+/* BANK 1 */
+#define GP_REG		0x000A
+
+
+// Control Register
+/* BANK 1 */
+#define CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 // When 1 bad CRC packets are received
+#define CTL_AUTO_RELEASE 0x0800 // When 1 tx pages are released automatically
+#define CTL_LE_ENABLE	0x0080 // When 1 enables Link Error interrupt
+#define CTL_CR_ENABLE	0x0040 // When 1 enables Counter Rollover interrupt
+#define CTL_TE_ENABLE	0x0020 // When 1 enables Transmit Error interrupt
+#define CTL_EEPROM_SELECT 0x0004 // Controls EEPROM reload & store
+#define CTL_RELOAD	0x0002 // When set reads EEPROM into registers
+#define CTL_STORE	0x0001 // When set stores registers into EEPROM
+
+
+// MMU Command Register
+/* BANK 2 */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	// When 1 the last release has not completed
+#define MC_NOP		(0<<5)	// No Op
+#define MC_ALLOC	(1<<5) 	// OR with number of 256 byte packets
+#define MC_RESET	(2<<5)	// Reset MMU to initial state
+#define MC_REMOVE	(3<<5) 	// Remove the current rx packet
+#define MC_RELEASE  	(4<<5) 	// Remove and release the current rx packet
+#define MC_FREEPKT  	(5<<5) 	// Release packet in PNR register
+#define MC_ENQUEUE	(6<<5)	// Enqueue the packet for transmit
+#define MC_RSTTXFIFO	(7<<5)	// Reset the TX FIFOs
+
+
+// Packet Number Register
+/* BANK 2 */
+#define PN_REG		0x0002
+
+
+// Allocation Result Register
+/* BANK 2 */
+#define AR_REG		0x0003
+#define AR_FAILED	0x80	// Alocation Failed
+
+
+// RX FIFO Ports Register
+/* BANK 2 */
+#define RXFIFO_REG	0x0004	// Must be read as a word
+#define RXFIFO_REMPTY	0x8000	// RX FIFO Empty
+
+
+// TX FIFO Ports Register
+/* BANK 2 */
+#define TXFIFO_REG	RXFIFO_REG	// Must be read as a word
+#define TXFIFO_TEMPTY	0x80	// TX FIFO Empty
+
+
+// Pointer Register
+/* BANK 2 */
+#define PTR_REG		0x0006
+#define PTR_RCV		0x8000 // 1=Receive area, 0=Transmit area
+#define PTR_AUTOINC 	0x4000 // Auto increment the pointer on each access
+#define PTR_READ	0x2000 // When 1 the operation is a read
+
+
+// Data Register
+/* BANK 2 */
+#define DATA_REG	0x0008
+
+
+// Interrupt Status/Acknowledge Register
+/* BANK 2 */
+#define INT_REG		0x000C
+
+
+// Interrupt Mask Register
+/* BANK 2 */
+#define IM_REG		0x000D
+#define IM_MDINT	0x80 // PHY MI Register 18 Interrupt
+#define IM_ERCV_INT	0x40 // Early Receive Interrupt
+#define IM_EPH_INT	0x20 // Set by Etheret Protocol Handler section
+#define IM_RX_OVRN_INT	0x10 // Set by Receiver Overruns
+#define IM_ALLOC_INT	0x08 // Set when allocation request is completed
+#define IM_TX_EMPTY_INT	0x04 // Set if the TX FIFO goes empty
+#define IM_TX_INT	0x02 // Transmit Interrrupt
+#define IM_RCV_INT	0x01 // Receive Interrupt
+
+
+// Multicast Table Registers
+/* BANK 3 */
+#define MCAST_REG1	0x0000
+#define MCAST_REG2	0x0002
+#define MCAST_REG3	0x0004
+#define MCAST_REG4	0x0006
+
+
+// Management Interface Register (MII)
+/* BANK 3 */
+#define MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 // Disables CRS100 detection during tx half dup
+#define MII_MDOE	0x0008 // MII Output Enable
+#define MII_MCLK	0x0004 // MII Clock, pin MDCLK
+#define MII_MDI		0x0002 // MII Input, pin MDI
+#define MII_MDO		0x0001 // MII Output, pin MDO
+
+
+// Revision Register
+/* BANK 3 */
+#define REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+// Early RCV Register
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 // When 1 discards a packet being received
+#define ERCV_THRESHOLD	0x001F // ERCV Threshold Mask
+
+// External Register
+/* BANK 7 */
+#define EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+static const char * chip_ids[ 15 ] =  {
+	NULL, NULL, NULL,
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100",
+	/* 8 */ "SMC91C100FD",
+	/* 9 */ "SMC91C11xFD",
+	NULL, NULL,
+	NULL, NULL, NULL};
+
+/*
+ . Transmit status bits
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	// bug: the LAN91C111 never sets this on receive
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT)
+
+
+// PHY Types
+enum {
+	PHY_LAN83C183 = 1,	// LAN91C111 Internal PHY
+	PHY_LAN83C180
+};
+
+
+// PHY Register Addresses (LAN91C111 Internal PHY)
+
+// PHY Control Register
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	// 1=PHY Reset
+#define PHY_CNTL_LPBK		0x4000	// 1=PHY Loopback
+#define PHY_CNTL_SPEED		0x2000	// 1=100Mbps, 0=10Mpbs
+#define PHY_CNTL_ANEG_EN	0x1000 // 1=Enable Auto negotiation
+#define PHY_CNTL_PDN		0x0800	// 1=PHY Power Down mode
+#define PHY_CNTL_MII_DIS	0x0400	// 1=MII 4 bit interface disabled
+#define PHY_CNTL_ANEG_RST	0x0200 // 1=Reset Auto negotiate
+#define PHY_CNTL_DPLX		0x0100	// 1=Full Duplex, 0=Half Duplex
+#define PHY_CNTL_COLTST		0x0080	// 1= MII Colision Test
+
+// PHY Status Register
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	// 1=100Base-T4 capable
+#define PHY_STAT_CAP_TXF	0x4000	// 1=100Base-X full duplex capable
+#define PHY_STAT_CAP_TXH	0x2000	// 1=100Base-X half duplex capable
+#define PHY_STAT_CAP_TF		0x1000	// 1=10Mbps full duplex capable
+#define PHY_STAT_CAP_TH		0x0800	// 1=10Mbps half duplex capable
+#define PHY_STAT_CAP_SUPR	0x0040	// 1=recv mgmt frames with not preamble
+#define PHY_STAT_ANEG_ACK	0x0020	// 1=ANEG has completed
+#define PHY_STAT_REM_FLT	0x0010	// 1=Remote Fault detected
+#define PHY_STAT_CAP_ANEG	0x0008	// 1=Auto negotiate capable
+#define PHY_STAT_LINK		0x0004	// 1=valid link
+#define PHY_STAT_JAB		0x0002	// 1=10Mbps jabber condition
+#define PHY_STAT_EXREG		0x0001	// 1=extended registers implemented
+
+// PHY Identifier Registers
+#define PHY_ID1_REG		0x02	// PHY Identifier 1
+#define PHY_ID2_REG		0x03	// PHY Identifier 2
+
+// PHY Auto-Negotiation Advertisement Register
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	// 1=PHY requests exchange of Next Page
+#define PHY_AD_ACK		0x4000	// 1=got link code word from remote
+#define PHY_AD_RF		0x2000	// 1=advertise remote fault
+#define PHY_AD_T4		0x0200	// 1=PHY is capable of 100Base-T4
+#define PHY_AD_TX_FDX		0x0100	// 1=PHY is capable of 100Base-TX FDPLX
+#define PHY_AD_TX_HDX		0x0080	// 1=PHY is capable of 100Base-TX HDPLX
+#define PHY_AD_10_FDX		0x0040	// 1=PHY is capable of 10Base-T FDPLX
+#define PHY_AD_10_HDX		0x0020	// 1=PHY is capable of 10Base-T HDPLX
+#define PHY_AD_CSMA		0x0001	// 1=PHY is capable of 802.3 CMSA
+
+// PHY Auto-negotiation Remote End Capability Register
+#define PHY_RMT_REG		0x05
+// Uses same bit definitions as PHY_AD_REG
+
+// PHY Configuration Register 1
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	// 1=Rx Link Detect Function disabled
+#define PHY_CFG1_XMTDIS		0x4000	// 1=TP Transmitter Disabled
+#define PHY_CFG1_XMTPDN		0x2000	// 1=TP Transmitter Powered Down
+#define PHY_CFG1_BYPSCR		0x0400	// 1=Bypass scrambler/descrambler
+#define PHY_CFG1_UNSCDS		0x0200	// 1=Unscramble Idle Reception Disable
+#define PHY_CFG1_EQLZR		0x0100	// 1=Rx Equalizer Disabled
+#define PHY_CFG1_CABLE		0x0080	// 1=STP(150ohm), 0=UTP(100ohm)
+#define PHY_CFG1_RLVL0		0x0040	// 1=Rx Squelch level reduced by 4.5db
+#define PHY_CFG1_TLVL_SHIFT	2	// Transmit Output Level Adjust
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	// Transmitter Rise/Fall time
+
+
+// PHY Configuration Register 2
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	// 1=Auto Polarity Correction disabled
+#define PHY_CFG2_JABDIS		0x0010	// 1=Jabber disabled
+#define PHY_CFG2_MREG		0x0008	// 1=Multiple register access (MII mgt)
+#define PHY_CFG2_INTMDIO	0x0004	// 1=Interrupt signaled with MDIO pulseo
+
+// PHY Status Output (and Interrupt status) Register
+#define PHY_INT_REG		0x12	// Status Output (Interrupt Status)
+#define PHY_INT_INT		0x8000	// 1=bits have changed since last read
+#define PHY_INT_LNKFAIL		0x4000	// 1=Link Not detected
+#define PHY_INT_LOSSSYNC	0x2000	// 1=Descrambler has lost sync
+#define PHY_INT_CWRD		0x1000	// 1=Invalid 4B5B code detected on rx
+#define PHY_INT_SSD		0x0800	// 1=No Start Of Stream detected on rx
+#define PHY_INT_ESD		0x0400	// 1=No End Of Stream detected on rx
+#define PHY_INT_RPOL		0x0200	// 1=Reverse Polarity detected
+#define PHY_INT_JAB		0x0100	// 1=Jabber detected
+#define PHY_INT_SPDDET		0x0080	// 1=100Base-TX mode, 0=10Base-T mode
+#define PHY_INT_DPLXDET		0x0040	// 1=Device in Full Duplex
+
+// PHY Interrupt/Status Mask Register
+#define PHY_MASK_REG		0x13	// Interrupt Mask
+// Uses the same bit definitions as PHY_INT_REG
+
+
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks.
+ --------------------------------------------------------------------------*/
+
+/* select a register bank, 0 to 3  */
+
+#define SMC_SELECT_BANK(x)  { SMC_outw( x, ioaddr + BANK_SELECT ); }
+#define SMC_CURRENT_BANK()  SMC_inw( ioaddr + BANK_SELECT )
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_GET_INT_MASK();\
+		mask |= (x);\
+		SMC_SET_INT_MASK(mask); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = SMC_GET_INT_MASK();\
+		mask &= ~(x);\
+		SMC_SET_INT_MASK(mask); \
+}
+
+/* Note: the following macros do *not* select the bank. */
+#if USE_8_BIT
+#define SMC_GET_PN()		SMC_inb( ioaddr + PN_REG )
+#define SMC_SET_PN(x)		SMC_outb( (x), ioaddr + PN_REG )
+#define SMC_GET_AR()		SMC_inb( ioaddr + AR_REG )
+#define SMC_GET_INT()		SMC_inb( ioaddr + INT_REG )
+#define SMC_ACK_INT(x)		SMC_outb( (x), ioaddr + INT_REG )
+#define SMC_GET_INT_MASK()	SMC_inb( ioaddr + IM_REG )
+#define SMC_SET_INT_MASK(x)	SMC_outb( (x), ioaddr + IM_REG )
+#else
+#define SMC_GET_PN()		(SMC_inw( ioaddr + PN_REG ) & 0xFF)
+#define SMC_SET_PN(x)		SMC_outw( (x), ioaddr + PN_REG )
+#define SMC_GET_AR()		(SMC_inw( ioaddr + PN_REG ) >> 8)
+#define SMC_GET_INT()		(SMC_inw( ioaddr + INT_REG ) & 0xFF)
+#define SMC_ACK_INT(x)		SMC_outw( (SMC_GET_INT_MASK() << 8) | (x), \
+					  ioaddr + INT_REG )
+#define SMC_GET_INT_MASK()	(SMC_inw( ioaddr + INT_REG ) >> 8)
+#define SMC_SET_INT_MASK(x)	SMC_outw( (x) << 8, ioaddr + INT_REG )
+#endif
+
+#define SMC_GET_BASE()		SMC_inw( ioaddr + BASE_REG)
+#define SMC_SET_BASE(x)		SMC_outw( (x), ioaddr + BASE_REG)
+#define SMC_GET_CONFIG()	SMC_inw( ioaddr + CONFIG_REG)
+#define SMC_SET_CONFIG(x)	SMC_outw( (x), ioaddr + CONFIG_REG)
+#define SMC_GET_COUNTER()	SMC_inw( ioaddr + COUNTER_REG)
+#define SMC_SET_COUNTER(x)	SMC_outw( (x), ioaddr + COUNTER_REG)
+#define SMC_GET_CTL()		SMC_inw( ioaddr + CTL_REG)
+#define SMC_SET_CTL(x)		SMC_outw( (x), ioaddr + CTL_REG)
+#define SMC_GET_MII()		SMC_inw( ioaddr + MII_REG)
+#define SMC_SET_MII(x)		SMC_outw( (x), ioaddr + MII_REG)
+#define SMC_GET_MIR()		SMC_inw( ioaddr + MIR_REG)
+#define SMC_SET_MIR(x)		SMC_outw( (x), ioaddr + MIR_REG)
+#define SMC_GET_MMU_CMD()	SMC_inw( ioaddr + MMU_CMD_REG)
+#define SMC_SET_MMU_CMD(x)	SMC_outw( (x), ioaddr + MMU_CMD_REG)
+#define SMC_GET_PTR()		SMC_inw( ioaddr + PTR_REG)
+#define SMC_SET_PTR(x)		SMC_outw( (x), ioaddr + PTR_REG)
+#define SMC_GET_RCR()		SMC_inw( ioaddr + RCR_REG)
+#define SMC_SET_RCR(x)		SMC_outw( (x), ioaddr + RCR_REG)
+#define SMC_GET_REV()		SMC_inw( ioaddr + REV_REG)
+#define SMC_SET_REV(x)		SMC_outw( (x), ioaddr + REV_REG)
+#define SMC_GET_RPC()		SMC_inw( ioaddr + RPC_REG)
+#define SMC_SET_RPC(x)		SMC_outw( (x), ioaddr + RPC_REG)
+#define SMC_GET_RXFIFO()	SMC_inw( ioaddr + RXFIFO_REG)
+#define SMC_SET_RXFIFO(x)	SMC_outw( (x), ioaddr + RXFIFO_REG)
+#define SMC_GET_TCR()		SMC_inw( ioaddr + TCR_REG)
+#define SMC_SET_TCR(x)		SMC_outw( (x), ioaddr + TCR_REG)
+
+#define SMC_CLEAR_MCAST()	{\
+		SMC_outw( 0, ioaddr + MCAST_REG1); \
+		SMC_outw( 0, ioaddr + MCAST_REG2); \
+		SMC_outw( 0, ioaddr + MCAST_REG3); \
+		SMC_outw( 0, ioaddr + MCAST_REG4); \
+}
+#define SMC_SET_MCAST(x) {\
+		int i;\
+		word w;\
+		unsigned char *mt = (x);\
+		for ( i = 0; i < 8; i += 2 ) {\
+			w = mt[i] | (mt[i + 1] << 8);\
+			SMC_outw( w, ioaddr + MCAST_REG1 + i );\
+		}\
+}
+
+
+/*----------------------------------------------------------------------
+ . Define the interrupts that I want to receive from the card
+ .
+ . I want:
+ .  IM_EPH_INT, for nasty errors
+ .  IM_RCV_INT, for happy received packets
+ .  IM_RX_OVRN_INT, because I have to kick the receiver
+ .  IM_MDINT, for PHY Register 18 Status Changes
+ --------------------------------------------------------------------------*/
+#define SMC_INTERRUPT_MASK   (IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | \
+	IM_MDINT)
+
+
+#ifdef CONFIG_SYSCTL
+/*
+ * Declarations for the sysctl interface, which allows users the ability to
+ * control the finer aspects of the LAN91C111 chip.  Since the smc
+ * module currently registers its sysctl table dynamically, the sysctl path
+ * for module FOO is /proc/sys/dev/ethX/FOO
+ */
+#define CTL_SMC         (CTL_BUS+1389)      // arbitrary and hopefully unused
+
+enum {
+	CTL_SMC_INFO = 1,	// Sysctl files information
+	CTL_SMC_SWVER,		// Driver Software Version Info
+	CTL_SMC_SWFDUP,		// Switched Full Duplex Mode
+	CTL_SMC_EPHLOOP,	// EPH Block Internal Loopback
+	CTL_SMC_MIIOP,		// MII Operation
+	CTL_SMC_AUTONEG,	// Auto-negotiate Mode
+	CTL_SMC_RFDUPLX,	// Request Full Duplex Mode
+	CTL_SMC_RSPEED,		// Request Speed Selection
+	CTL_SMC_AFDUPLX,	// Actual Full Duplex Mode
+	CTL_SMC_ASPEED,		// Actual Speed Selection
+	CTL_SMC_LNKFAIL,	// Link Failed
+	CTL_SMC_FORCOL,		// Force a Collision
+	CTL_SMC_FILTCAR,	// Filter Carrier
+	CTL_SMC_FREEMEM,	// Free Buffer Memory
+	CTL_SMC_TOTMEM,		// Total Buffer Memory
+	CTL_SMC_LEDA,		// Output of LED-A
+	CTL_SMC_LEDB,		// Output of LED-B
+	CTL_SMC_CHIPREV,	// LAN91C111 Chip Revision ID
+#if SMC_DEBUG > 1
+	// Register access for debugging
+	CTL_SMC_REG_BSR,	// Bank Select
+	CTL_SMC_REG_TCR,	// Transmit Control
+	CTL_SMC_REG_ESR,	// EPH Status
+	CTL_SMC_REG_RCR,	// Receive Control
+	CTL_SMC_REG_CTRR,	// Counter
+	CTL_SMC_REG_MIR,	// Memory Information
+	CTL_SMC_REG_RPCR,	// Receive/Phy Control
+	CTL_SMC_REG_CFGR,	// Configuration
+	CTL_SMC_REG_BAR,	// Base Address
+	CTL_SMC_REG_IAR0,	// Individual Address 0
+	CTL_SMC_REG_IAR1,	// Individual Address 1
+	CTL_SMC_REG_IAR2,	// Individual Address 2
+	CTL_SMC_REG_GPR,	// General Purpose
+	CTL_SMC_REG_CTLR,	// Control
+	CTL_SMC_REG_MCR,	// MMU Command
+	CTL_SMC_REG_PNR,	// Packet Number
+	CTL_SMC_REG_FPR,	// FIFO Ports
+	CTL_SMC_REG_PTR,	// Pointer
+	CTL_SMC_REG_DR,		// Data
+	CTL_SMC_REG_ISR,	// Interrupt Status
+	CTL_SMC_REG_MTR1,	// Multicast Table Entry 1
+	CTL_SMC_REG_MTR2,	// Multicast Table Entry 2
+	CTL_SMC_REG_MTR3,	// Multicast Table Entry 3
+	CTL_SMC_REG_MTR4,	// Multicast Table Entry 4
+	CTL_SMC_REG_MIIR,	// Management Interface
+	CTL_SMC_REG_REVR,	// Revision
+	CTL_SMC_REG_ERCVR,	// Early RCV
+	CTL_SMC_REG_EXTR,	// External
+	CTL_SMC_PHY_CTRL,	// PHY Control
+	CTL_SMC_PHY_STAT,	// PHY Status
+	CTL_SMC_PHY_ID1,	// PHY ID1
+	CTL_SMC_PHY_ID2,	// PHY ID2
+	CTL_SMC_PHY_ADC,	// PHY Advertise Capability
+	CTL_SMC_PHY_REMC,	// PHY Advertise Capability
+	CTL_SMC_PHY_CFG1,	// PHY Configuration 1
+	CTL_SMC_PHY_CFG2,	// PHY Configuration 2
+	CTL_SMC_PHY_INT,	// PHY Interrupt/Status Output
+	CTL_SMC_PHY_MASK,	// PHY Interrupt/Status Mask
+#endif
+	// ---------------------------------------------------
+	CTL_SMC_LAST_ENTRY	// Add new entries above the line
+};
+#endif // CONFIG_SYSCTL
+#endif  /* _SMC_91111_H_ */
diff -purN /dev/shm/linux-2.5/drivers/net/sungem.c linuxppc-2.5-benh/drivers/net/sungem.c
--- /dev/shm/linux-2.5/drivers/net/sungem.c	2003-10-10 06:57:39.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/sungem.c	2004-01-29 04:53:40.000000000 +0000
@@ -103,6 +103,8 @@ static struct pci_device_id gem_pci_tbl[
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_UNI_N_GMAC2,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_K2_GMAC,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{0, }
 };
 
@@ -778,6 +780,10 @@ static irqreturn_t gem_interrupt(int irq
 	struct gem *gp = dev->priv;
 	u32 gem_status = readl(gp->regs + GREG_STAT);
 
+	/* Swallow interrupts when shutting the chip down */
+	if (gp->hw_running == 0)
+		goto out;
+
 	spin_lock(&gp->lock);
 
 	if (gem_status & GREG_STAT_ABNORMAL) {
@@ -1240,6 +1246,12 @@ static int gem_mdio_link_not_up(struct g
 		gp->lstate = link_force_ok;
 		return 0;
 	case link_aneg:
+		/* We try forced modes after a failed aneg only on PHYs that don't
+		 * have "magic_aneg" bit set, which means they internally do the
+		 * while forced-mode thingy. On these, we just restart aneg
+		 */
+		if (gp->phy_mii.def->magic_aneg)
+			return 1;
 		if (netif_msg_link(gp))
 			printk(KERN_INFO "%s: switching to forced 100bt\n",
 				gp->dev->name);
@@ -1497,18 +1509,26 @@ static void gem_init_phy(struct gem *gp)
 		 * to schedule instead
 		 */
 		pmac_call_feature(PMAC_FTR_GMAC_PHY_RESET, gp->of_node, 0, 0);
-		mdelay(10);
 		for (j = 0; j < 3; j++) {
 			/* Some PHYs used by apple have problem getting back to us,
-			 * we _know_ it's actually at addr 0, that's a hack, but
+			 * we _know_ it's actually at addr 0 or 1, that's a hack, but
 			 * it helps to do that reset now. I suspect some motherboards
 			 * don't wire the PHY reset line properly, thus the PHY doesn't
 			 * come back with the above pmac_call_feature.
 			 */
 			gp->mii_phy_addr = 0;
 			phy_write(gp, MII_BMCR, BMCR_RESET);
+			gp->mii_phy_addr = 1;
+			phy_write(gp, MII_BMCR, BMCR_RESET);
 			/* We should probably break some locks here and schedule... */
 			mdelay(10);
+			
+			/* On K2, we only probe the internal PHY at address 1, other
+			 * addresses tend to return garbage.
+			 */
+			if (gp->pdev->device == PCI_DEVICE_ID_APPLE_K2_GMAC)
+				break;
+
 			for (i = 0; i < 32; i++) {
 				gp->mii_phy_addr = i;
 				if (phy_read(gp, MII_BMCR) != 0xffff)
@@ -1770,6 +1790,8 @@ static void gem_init_mac(struct gem *gp)
 /* Must be invoked under gp->lock. */
 static void gem_init_pause_thresholds(struct gem *gp)
 {
+       	u32 cfg;
+
 	/* Calculate pause thresholds.  Setting the OFF threshold to the
 	 * full RX fifo size effectively disables PAUSE generation which
 	 * is what we do for 10/100 only GEMs which have FIFOs too small
@@ -1786,17 +1808,28 @@ static void gem_init_pause_thresholds(st
 		gp->rx_pause_on = on;
 	}
 
-	{
-		u32 cfg;
 
-		cfg  = 0;
+	/* Configure the chip "burst" DMA mode & enable some
+	 * HW bug fixes on Apple version
+	 */
+       	cfg  = 0;
+       	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE)
+		cfg |= GREG_CFG_RONPAULBIT | GREG_CFG_ENBUG2FIX;
 #if !defined(CONFIG_SPARC64) && !defined(CONFIG_ALPHA)
-		cfg |= GREG_CFG_IBURST;
+       	cfg |= GREG_CFG_IBURST;
 #endif
-		cfg |= ((31 << 1) & GREG_CFG_TXDMALIM);
-		cfg |= ((31 << 6) & GREG_CFG_RXDMALIM);
+       	cfg |= ((31 << 1) & GREG_CFG_TXDMALIM);
+       	cfg |= ((31 << 6) & GREG_CFG_RXDMALIM);
+       	writel(cfg, gp->regs + GREG_CFG);
+
+	/* If Infinite Burst didn't stick, then use different
+	 * thresholds (and Apple bug fixes don't exist)
+	 */
+	if (readl(gp->regs + GREG_CFG) & GREG_CFG_IBURST) {
+		cfg = ((2 << 1) & GREG_CFG_TXDMALIM);
+		cfg = ((8 << 6) & GREG_CFG_RXDMALIM);
 		writel(cfg, gp->regs + GREG_CFG);
-	}
+	}	
 }
 
 static int gem_check_invariants(struct gem *gp)
@@ -1931,18 +1964,10 @@ static void gem_apple_powerup(struct gem
 	u16 cmd;
 	u32 mif_cfg;
 
+	mb();
 	pmac_call_feature(PMAC_FTR_GMAC_ENABLE, gp->of_node, 0, 1);
 
-	current->state = TASK_UNINTERRUPTIBLE;
-	schedule_timeout((21 * HZ) / 1000);
-
-	pci_read_config_word(gp->pdev, PCI_COMMAND, &cmd);
-	cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;
-    	pci_write_config_word(gp->pdev, PCI_COMMAND, cmd);
-    	pci_write_config_byte(gp->pdev, PCI_LATENCY_TIMER, 6);
-    	pci_write_config_byte(gp->pdev, PCI_CACHE_LINE_SIZE, 8);
-
-	mdelay(1);
+	udelay(3);
 	
 	mif_cfg = readl(gp->regs + MIF_CFG);
 	mif_cfg &= ~(MIF_CFG_PSELECT|MIF_CFG_POLL|MIF_CFG_BBMODE|MIF_CFG_MDI1);
@@ -1950,8 +1975,6 @@ static void gem_apple_powerup(struct gem
 	writel(mif_cfg, gp->regs + MIF_CFG);
 	writel(PCS_DMODE_MGM, gp->regs + PCS_DMODE);
 	writel(MAC_XIFCFG_OE, gp->regs + MAC_XIFCFG);
-
-	mdelay(1);
 }
 
 /* Turn off the chip's clock */
@@ -1962,10 +1985,17 @@ static void gem_apple_powerdown(struct g
 
 #endif /* CONFIG_PPC_PMAC */
 
-/* Must be invoked under gp->lock. */
+/* Must be invoked with no lock held. */
 static void gem_stop_phy(struct gem *gp)
 {
 	u32 mifcfg;
+	unsigned long flags;
+
+	/* Let the chip settle down a bit, it seems that helps
+	 * for sleep mode on some models
+	 */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ/100);
 
 	/* Make sure we aren't polling PHY status change. We
 	 * don't currently use that feature though
@@ -1976,17 +2006,28 @@ static void gem_stop_phy(struct gem *gp)
 
 	if (gp->wake_on_lan) {
 		/* Setup wake-on-lan */
-	} else
+	} else {
 		writel(0, gp->regs + MAC_RXCFG);
+		(void)readl(gp->regs + MAC_RXCFG);
+		/* Machine sleep will die in strange ways if we
+		 * dont wait a bit here, looks like the chip takes
+		 * some time to really shut down
+		 */
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
+	}
+
 	writel(0, gp->regs + MAC_TXCFG);
 	writel(0, gp->regs + MAC_XIFCFG);
 	writel(0, gp->regs + TXDMA_CFG);
 	writel(0, gp->regs + RXDMA_CFG);
 
 	if (!gp->wake_on_lan) {
+		spin_lock_irqsave(&gp->lock, flags);
 		gem_stop(gp);
 		writel(MAC_TXRST_CMD, gp->regs + MAC_TXRST);
 		writel(MAC_RXRST_CMD, gp->regs + MAC_RXRST);
+		spin_unlock_irqrestore(&gp->lock, flags);
 	}
 
 	if (found_mii_phy(gp) && gp->phy_mii.def->ops->suspend)
@@ -2008,31 +2049,33 @@ static void gem_stop_phy(struct gem *gp)
 /* Shut down the chip, must be called with pm_sem held.  */
 static void gem_shutdown(struct gem *gp)
 {
-	/* Make us not-running to avoid timers respawning */
+	/* Make us not-running to avoid timers respawning
+	 * and swallow irqs 
+	 */
 	gp->hw_running = 0;
+	wmb();
 
 	/* Stop the link timer */
 	del_timer_sync(&gp->link_timer);
 
 	/* Stop the reset task */
 	while (gp->reset_task_pending)
-		schedule();
+		yield();
 	
 	/* Actually stop the chip */
-	spin_lock_irq(&gp->lock);
 	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE) {
 		gem_stop_phy(gp);
 
-		spin_unlock_irq(&gp->lock);
-
 #ifdef CONFIG_PPC_PMAC
 		/* Power down the chip */
 		gem_apple_powerdown(gp);
 #endif /* CONFIG_PPC_PMAC */
-	} else {
-		gem_stop(gp);
+	} else{
+		unsigned long flags;
 
-		spin_unlock_irq(&gp->lock);
+		spin_lock_irqsave(&gp->lock, flags);
+		gem_stop(gp);
+		spin_unlock_irqrestore(&gp->lock, flags);	
 	}
 }
 
@@ -2692,6 +2735,7 @@ static int __devinit gem_init_one(struct
 	 * not have properly shut down the PHY.
 	 */
 #ifdef CONFIG_PPC_PMAC
+	gp->of_node = pci_device_to_OF_node(pdev);
 	if (pdev->vendor == PCI_VENDOR_ID_APPLE)
 		gem_apple_powerup(gp);
 #endif
@@ -2725,9 +2769,6 @@ static int __devinit gem_init_one(struct
 		goto err_out_iounmap;
 	}
 
-#ifdef CONFIG_PPC_PMAC
-	gp->of_node = pci_device_to_OF_node(pdev);
-#endif	
 	if (gem_get_device_address(gp))
 		goto err_out_free_consistent;
 
diff -purN /dev/shm/linux-2.5/drivers/net/sungem.h linuxppc-2.5-benh/drivers/net/sungem.h
--- /dev/shm/linux-2.5/drivers/net/sungem.h	2003-06-12 07:45:33.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/sungem.h	2003-10-14 09:04:24.000000000 +0000
@@ -28,6 +28,9 @@
 #define GREG_CFG_IBURST		0x00000001	/* Infinite Burst		*/
 #define GREG_CFG_TXDMALIM	0x0000003e	/* TX DMA grant limit		*/
 #define GREG_CFG_RXDMALIM	0x000007c0	/* RX DMA grant limit		*/
+#define GREG_CFG_RONPAULBIT	0x00000800	/* Use mem read multiple for PCI read
+						 * after infinite burst (Apple) */
+#define GREG_CFG_ENBUG2FIX	0x00001000	/* Fix Rx hang after overflow */
 
 /* Global Interrupt Status Register.
  *
diff -purN /dev/shm/linux-2.5/drivers/net/sungem_phy.c linuxppc-2.5-benh/drivers/net/sungem_phy.c
--- /dev/shm/linux-2.5/drivers/net/sungem_phy.c	2003-08-31 23:14:08.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/sungem_phy.c	2003-11-16 23:46:12.000000000 +0000
@@ -72,7 +72,7 @@ static int reset_one_mii_phy(struct mii_
 	int limit = 10000;
 	
 	val = __phy_read(phy, phy_id, MII_BMCR);
-	val &= ~BMCR_ISOLATE;
+	val &= ~(BMCR_ISOLATE | BMCR_PDOWN);
 	val |= BMCR_RESET;
 	__phy_write(phy, phy_id, MII_BMCR, val);
 
@@ -157,7 +157,7 @@ static int bcm5400_init(struct mii_phy* 
 	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
 	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
 	
-	mdelay(10);
+	udelay(100);
 
 	/* Reset and configure cascaded 10/100 PHY */
 	(void)reset_one_mii_phy(phy, 0x1f);
@@ -217,7 +217,7 @@ static int bcm5401_init(struct mii_phy* 
 	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
 	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
 
-	mdelay(10);
+	udelay(10);
 
 	/* Reset and configure cascaded 10/100 PHY */
 	(void)reset_one_mii_phy(phy, 0x1f);
@@ -258,7 +258,7 @@ static int bcm5411_init(struct mii_phy* 
 	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
 	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
 
-	mdelay(10);
+	udelay(10);
 
 	/* Reset and configure cascaded 10/100 PHY */
 	(void)reset_one_mii_phy(phy, 0x1f);
@@ -302,6 +302,15 @@ static int bcm5421_init(struct mii_phy* 
 	return 0;
 }
 
+static int bcm5421k2_init(struct mii_phy* phy)
+{
+	/* Init code borrowed from OF */
+	phy_write(phy, 4, 0x01e1);
+	phy_write(phy, 9, 0x0300);
+
+	return 0;
+}
+
 static int bcm54xx_setup_aneg(struct mii_phy *phy, u32 advertise)
 {
 	u16 ctl, adv;
@@ -647,7 +656,7 @@ static struct mii_phy_def bcm5201_phy_de
 	.phy_id_mask	= 0xfffffff0,
 	.name		= "BCM5201",
 	.features	= MII_BASIC_FEATURES,
-	.magic_aneg	= 0,
+	.magic_aneg	= 1,
 	.ops		= &bcm5201_phy_ops
 };
 
@@ -666,7 +675,7 @@ static struct mii_phy_def bcm5221_phy_de
 	.phy_id_mask	= 0xfffffff0,
 	.name		= "BCM5221",
 	.features	= MII_BASIC_FEATURES,
-	.magic_aneg	= 0,
+	.magic_aneg	= 1,
 	.ops		= &bcm5221_phy_ops
 };
 
@@ -746,6 +755,25 @@ static struct mii_phy_def bcm5421_phy_de
 	.ops		= &bcm5421_phy_ops
 };
 
+/* Broadcom BCM 5421 built-in K2 */
+static struct mii_phy_ops bcm5421k2_phy_ops = {
+	.init		= bcm5421k2_init,
+	.suspend	= bcm5411_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5421k2_phy_def = {
+	.phy_id		= 0x002062e0,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5421-K2",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5421k2_phy_ops
+};
+
 /* Marvell 88E1101 (Apple seem to deal with 2 different revs,
  * I masked out the 8 last bits to get both, but some specs
  * would be useful here) --BenH.
@@ -790,6 +818,7 @@ static struct mii_phy_def* mii_phy_table
 	&bcm5401_phy_def,
 	&bcm5411_phy_def,
 	&bcm5421_phy_def,
+	&bcm5421k2_phy_def,
 	&marvell_phy_def,
 	&genmii_phy_def,
 	NULL
@@ -813,8 +842,8 @@ int mii_phy_probe(struct mii_phy *phy, i
 		goto fail;
 
 	/* Read ID and find matching entry */	
-	id = (phy_read(phy, MII_PHYSID1) << 16 | phy_read(phy, MII_PHYSID2))
-			 	& 0xfffffff0;
+	id = (phy_read(phy, MII_PHYSID1) << 16 | phy_read(phy, MII_PHYSID2));
+	printk(KERN_DEBUG "PHY ID: %x, addr: %x\n", id, mii_id);
 	for (i=0; (def = mii_phy_table[i]) != NULL; i++)
 		if ((id & def->phy_id_mask) == def->phy_id)
 			break;
diff -purN /dev/shm/linux-2.5/drivers/net/wireless/airport.c linuxppc-2.5-benh/drivers/net/wireless/airport.c
--- /dev/shm/linux-2.5/drivers/net/wireless/airport.c	2003-08-25 16:51:43.000000000 +0000
+++ linuxppc-2.5-benh/drivers/net/wireless/airport.c	2004-01-29 05:03:22.000000000 +0000
@@ -40,7 +40,7 @@
 #define AIRPORT_IO_LEN	(0x1000)	/* one page */
 
 struct airport {
-	struct device_node *node;
+	struct macio_dev *mdev;
 	void *vaddr;
 	int irq_requested;
 	int ndev_registered;
@@ -51,7 +51,6 @@ airport_suspend(struct macio_dev *mdev, 
 {
 	struct net_device *dev = dev_get_drvdata(&mdev->ofdev.dev);
 	struct orinoco_private *priv = dev->priv;
-	struct airport *card = priv->card;
 	unsigned long flags;
 	int err;
 
@@ -76,7 +75,7 @@ airport_suspend(struct macio_dev *mdev, 
 	orinoco_unlock(priv, &flags);
 
 	disable_irq(dev->irq);
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(mdev), 0, 0);
 
 	return 0;
 }
@@ -86,14 +85,14 @@ airport_resume(struct macio_dev *mdev)
 {
 	struct net_device *dev = dev_get_drvdata(&mdev->ofdev.dev);
 	struct orinoco_private *priv = dev->priv;
-	struct airport *card = priv->card;
 	unsigned long flags;
 	int err;
 
 	printk(KERN_DEBUG "%s: Airport waking up\n", dev->name);
 
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
-	mdelay(200);
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(mdev), 0, 1);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ/5);
 
 	enable_irq(dev->irq);
 
@@ -142,15 +141,13 @@ airport_detach(struct macio_dev *mdev)
 		iounmap(card->vaddr);
 	card->vaddr = 0;
 
-	dev->base_addr = 0;
+	macio_release_resource(mdev, 0);
 
-	release_OF_resource(card->node, 0);
-
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
-	current->state = TASK_UNINTERRUPTIBLE;
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(mdev), 0, 0);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(HZ);
 
-	dev_set_drvdata(&mdev->ofdev.dev, NULL);
+	macio_set_drvdata(mdev, NULL);
 	free_netdev(dev);
 
 	return 0;
@@ -173,11 +170,11 @@ static int airport_hard_reset(struct ori
 	 * off. */
 	disable_irq(dev->irq);
 
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 0);
-	current->state = TASK_UNINTERRUPTIBLE;
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(card->mdev), 0, 0);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(HZ);
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
-	current->state = TASK_UNINTERRUPTIBLE;
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(card->mdev), 0, 1);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(HZ);
 
 	enable_irq(dev->irq);
@@ -194,10 +191,9 @@ airport_attach(struct macio_dev *mdev, c
 	struct net_device *dev;
 	struct airport *card;
 	unsigned long phys_addr;
-	struct device_node *of_node = mdev->ofdev.node;
 	hermes_t *hw;
 
-	if (of_node->n_addrs < 1 || of_node->n_intrs < 1) {
+	if (macio_resource_count(mdev) < 1 || macio_irq_count(mdev) < 1) {
 		printk(KERN_ERR "airport: wrong interrupt/addresses in OF tree\n");
 		return -ENODEV;
 	}
@@ -212,27 +208,26 @@ airport_attach(struct macio_dev *mdev, c
 	card = priv->card;
 
 	hw = &priv->hw;
-	card->node = of_node;
+	card->mdev = mdev;
 
-	if (! request_OF_resource(of_node, 0, " (airport)")) {
+	if (macio_request_resource(mdev, 0, "airport")) {
 		printk(KERN_ERR "airport: can't request IO resource !\n");
-		kfree(dev);
-		return -ENODEV;
+		free_netdev(dev);
+		return -EBUSY;
 	}
 
-	dev->name[0] = '\0';	/* register_netdev will give us an ethX name */
 	SET_MODULE_OWNER(dev);
 	SET_NETDEV_DEV(dev, &mdev->ofdev.dev);
 
-	dev_set_drvdata(&mdev->ofdev.dev, dev);
+	macio_set_drvdata(mdev, dev);
 
 	/* Setup interrupts & base address */
-	dev->irq = of_node->intrs[0].line;
-	phys_addr = of_node->addrs[0].address;  /* Physical address */
+	dev->irq = macio_irq(mdev, 0);
+	phys_addr = macio_resource_start(mdev, 0);  /* Physical address */
 	printk(KERN_DEBUG "Airport at physical address %lx\n", phys_addr);
 	dev->base_addr = phys_addr;
 	card->vaddr = ioremap(phys_addr, AIRPORT_IO_LEN);
-	if (! card->vaddr) {
+	if (!card->vaddr) {
 		printk("airport: ioremap() failed\n");
 		goto failed;
 	}
@@ -241,8 +236,8 @@ airport_attach(struct macio_dev *mdev, c
 			HERMES_MEM, HERMES_16BIT_REGSPACING);
 		
 	/* Power up card */
-	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, card->node, 0, 1);
-	current->state = TASK_UNINTERRUPTIBLE;
+	pmac_call_feature(PMAC_FTR_AIRPORT_ENABLE, macio_get_of_node(mdev), 0, 1);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 	schedule_timeout(HZ);
 
 	/* Reset it before we get the interrupt */
diff -purN /dev/shm/linux-2.5/drivers/pci/pci-sysfs.c linuxppc-2.5-benh/drivers/pci/pci-sysfs.c
--- /dev/shm/linux-2.5/drivers/pci/pci-sysfs.c	2004-01-29 14:43:36.000000000 +0000
+++ linuxppc-2.5-benh/drivers/pci/pci-sysfs.c	2004-02-04 07:24:30.000000000 +0000
@@ -20,6 +20,24 @@
 
 #include "pci.h"
 
+#ifdef CONFIG_PPC_OF
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+
+static ssize_t pci_show_devspec(struct device *dev, char *buf)
+{
+	struct pci_dev *pdev;
+	struct device_node *np;
+
+	pdev = to_pci_dev (dev);
+	np = pci_device_to_OF_node(pdev);
+	if (np == NULL || np->full_name == NULL)
+		return 0;
+	return sprintf(buf, "%s", np->full_name);
+}
+static DEVICE_ATTR(devspec, S_IRUGO, pci_show_devspec, NULL);
+#endif /* CONFIG_PPC_OF */
+
 /* show configuration fields */
 #define pci_config_attr(field, format_string)				\
 static ssize_t								\
@@ -179,5 +197,8 @@ void pci_create_sysfs_dev_files (struct 
 	device_create_file (dev, &dev_attr_class);
 	device_create_file (dev, &dev_attr_irq);
 	device_create_file (dev, &dev_attr_resource);
+#ifdef CONFIG_PPC_OF
+	device_create_file (dev, &dev_attr_devspec);
+#endif
 	sysfs_create_bin_file(&dev->kobj, &pci_config_attr);
 }
diff -purN /dev/shm/linux-2.5/drivers/scsi/ata_piix.c linuxppc-2.5-benh/drivers/scsi/ata_piix.c
--- /dev/shm/linux-2.5/drivers/scsi/ata_piix.c	2003-12-17 00:16:55.000000000 +0000
+++ linuxppc-2.5-benh/drivers/scsi/ata_piix.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,597 +0,0 @@
-/*
-
-    ata_piix.c - Intel PATA/SATA controllers
-
-
-	Copyright 2003 Red Hat Inc
-	Copyright 2003 Jeff Garzik
-
-
-	Copyright header from piix.c:
-
-    Copyright (C) 1998-1999 Andrzej Krzysztofowicz, Author and Maintainer
-    Copyright (C) 1998-2000 Andre Hedrick <andre@linux-ide.org>
-    Copyright (C) 2003 Red Hat Inc <alan@redhat.com>
-
-    May be copied or modified under the terms of the GNU General Public License
-
- */
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include "scsi.h"
-#include "hosts.h"
-#include <linux/libata.h>
-
-#define DRV_NAME	"ata_piix"
-#define DRV_VERSION	"0.95"
-
-enum {
-	PIIX_IOCFG		= 0x54, /* IDE I/O configuration register */
-	ICH5_PCS		= 0x92,	/* port control and status */
-
-	PIIX_FLAG_COMBINED	= (1 << 30), /* combined mode possible */
-
-	PIIX_COMB_PRI		= (1 << 0), /* combined mode, PATA primary */
-	PIIX_COMB_SEC		= (1 << 1), /* combined mode, PATA secondary */
-
-	PIIX_80C_PRI		= (1 << 5) | (1 << 4),
-	PIIX_80C_SEC		= (1 << 7) | (1 << 6),
-
-	ich5_pata		= 0,
-	ich5_sata		= 1,
-	piix4_pata		= 2,
-};
-
-static int piix_init_one (struct pci_dev *pdev,
-				    const struct pci_device_id *ent);
-
-static void piix_pata_phy_reset(struct ata_port *ap);
-static void piix_sata_phy_reset(struct ata_port *ap);
-static void piix_sata_port_disable(struct ata_port *ap);
-static void piix_set_piomode (struct ata_port *ap, struct ata_device *adev,
-			      unsigned int pio);
-static void piix_set_udmamode (struct ata_port *ap, struct ata_device *adev,
-			       unsigned int udma);
-
-static unsigned int in_module_init = 1;
-
-static struct pci_device_id piix_pci_tbl[] = {
-#ifdef ATA_ENABLE_PATA
-	{ 0x8086, 0x7111, PCI_ANY_ID, PCI_ANY_ID, 0, 0, piix4_pata },
-	{ 0x8086, 0x24db, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_pata },
-	{ 0x8086, 0x25a2, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_pata },
-#endif
-
-	{ 0x8086, 0x24d1, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
-	{ 0x8086, 0x24df, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
-	{ 0x8086, 0x25a3, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
-	{ 0x8086, 0x25b0, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich5_sata },
-
-	{ }	/* terminate list */
-};
-
-static struct pci_driver piix_pci_driver = {
-	.name			= DRV_NAME,
-	.id_table		= piix_pci_tbl,
-	.probe			= piix_init_one,
-	.remove			= ata_pci_remove_one,
-};
-
-static Scsi_Host_Template piix_sht = {
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.queuecommand		= ata_scsi_queuecmd,
-	.eh_strategy_handler	= ata_scsi_error,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= ATA_MAX_PRD,
-	.max_sectors		= ATA_MAX_SECTORS,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.bios_param		= ata_std_bios_param,
-};
-
-static struct ata_port_operations piix_pata_ops = {
-	.port_disable		= ata_port_disable,
-	.set_piomode		= piix_set_piomode,
-	.set_udmamode		= piix_set_udmamode,
-
-	.tf_load		= ata_tf_load_pio,
-	.tf_read		= ata_tf_read_pio,
-	.check_status		= ata_check_status_pio,
-	.exec_command		= ata_exec_command_pio,
-
-	.phy_reset		= piix_pata_phy_reset,
-	.phy_config		= pata_phy_config,
-
-	.bmdma_start		= ata_bmdma_start_pio,
-	.fill_sg		= ata_fill_sg,
-	.eng_timeout		= ata_eng_timeout,
-
-	.irq_handler		= ata_interrupt,
-
-	.port_start		= ata_port_start,
-	.port_stop		= ata_port_stop,
-};
-
-static struct ata_port_operations piix_sata_ops = {
-	.port_disable		= piix_sata_port_disable,
-	.set_piomode		= piix_set_piomode,
-	.set_udmamode		= piix_set_udmamode,
-
-	.tf_load		= ata_tf_load_pio,
-	.tf_read		= ata_tf_read_pio,
-	.check_status		= ata_check_status_pio,
-	.exec_command		= ata_exec_command_pio,
-
-	.phy_reset		= piix_sata_phy_reset,
-	.phy_config		= pata_phy_config,	/* not a typo */
-
-	.bmdma_start		= ata_bmdma_start_pio,
-	.fill_sg		= ata_fill_sg,
-	.eng_timeout		= ata_eng_timeout,
-
-	.irq_handler		= ata_interrupt,
-
-	.port_start		= ata_port_start,
-	.port_stop		= ata_port_stop,
-};
-
-static struct ata_port_info piix_port_info[] = {
-	/* ich5_pata */
-	{
-		.sht		= &piix_sht,
-		.host_flags	= ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
-		.pio_mask	= 0x03,	/* pio3-4 */
-		.udma_mask	= ATA_UDMA_MASK_40C, /* FIXME: cbl det */
-		.port_ops	= &piix_pata_ops,
-	},
-
-	/* ich5_sata */
-	{
-		.sht		= &piix_sht,
-		.host_flags	= ATA_FLAG_SATA | PIIX_FLAG_COMBINED |
-				  ATA_FLAG_SRST,
-		.pio_mask	= 0x03,	/* pio3-4 */
-		.udma_mask	= 0x7f,	/* udma0-6 ; FIXME */
-		.port_ops	= &piix_sata_ops,
-	},
-
-	/* piix4_pata */
-	{
-		.sht		= &piix_sht,
-		.host_flags	= ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
-		.pio_mask	= 0x03, /* pio3-4 */
-		.udma_mask	= ATA_UDMA_MASK_40C, /* FIXME: cbl det */
-		.port_ops	= &piix_pata_ops,
-	},
-};
-
-static struct pci_bits piix_enable_bits[] = {
-	{ 0x41U, 1U, 0x80UL, 0x80UL },	/* port 0 */
-	{ 0x43U, 1U, 0x80UL, 0x80UL },	/* port 1 */
-};
-
-MODULE_AUTHOR("Andre Hedrick, Alan Cox, Andrzej Krzysztofowicz, Jeff Garzik");
-MODULE_DESCRIPTION("SCSI low-level driver for Intel PIIX/ICH ATA controllers");
-MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE(pci, piix_pci_tbl);
-
-/**
- *	piix_pata_cbl_detect - Probe host controller cable detect info
- *	@ap: Port for which cable detect info is desired
- *
- *	Read 80c cable indicator from SATA PCI device's PCI config
- *	register.  This register is normally set by firmware (BIOS).
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-static void piix_pata_cbl_detect(struct ata_port *ap)
-{
-	struct pci_dev *pdev = ap->host_set->pdev;
-	u8 tmp, mask;
-
-	/* no 80c support in host controller? */
-	if ((ap->udma_mask & ~ATA_UDMA_MASK_40C) == 0)
-		goto cbl40;
-
-	/* check BIOS cable detect results */
-	mask = ap->port_no == 0 ? PIIX_80C_PRI : PIIX_80C_SEC;
-	pci_read_config_byte(pdev, PIIX_IOCFG, &tmp);
-	if ((tmp & mask) == 0)
-		goto cbl40;
-
-	ap->cbl = ATA_CBL_PATA80;
-	return;
-
-cbl40:
-	ap->cbl = ATA_CBL_PATA40;
-	ap->udma_mask &= ATA_UDMA_MASK_40C;
-}
-
-/**
- *	piix_pata_phy_reset - Probe specified port on PATA host controller
- *	@ap: Port to probe
- *
- *	Probe PATA phy.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-static void piix_pata_phy_reset(struct ata_port *ap)
-{
-	if (!pci_test_config_bits(ap->host_set->pdev,
-				  &piix_enable_bits[ap->port_no])) {
-		ata_port_disable(ap);
-		printk(KERN_INFO "ata%u: port disabled. ignoring.\n", ap->id);
-		return;
-	}
-
-	piix_pata_cbl_detect(ap);
-
-	ata_port_probe(ap);
-
-	ata_bus_reset(ap);
-}
-
-/**
- *	piix_pcs_probe - Probe SATA port configuration and status register
- *	@ap: Port to probe
- *	@have_port: (output) Non-zero if SATA port is enabled
- *	@have_device: (output) Non-zero if SATA phy indicates device present
- *
- *	Reads SATA PCI device's PCI config register Port Configuration
- *	and Status (PCS) to determine port and device availability.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-static void piix_pcs_probe (struct ata_port *ap, unsigned int *have_port,
-			    unsigned int *have_device)
-{
-	struct pci_dev *pdev = ap->host_set->pdev;
-	u16 pcs;
-
-	pci_read_config_word(pdev, ICH5_PCS, &pcs);
-
-	/* is SATA port enabled? */
-	if (pcs & (1 << ap->port_no)) {
-		*have_port = 1;
-
-		if (pcs & (1 << (ap->port_no + 4)))
-			*have_device = 1;
-	}
-}
-
-/**
- *	piix_pcs_disable - Disable SATA port
- *	@ap: Port to disable
- *
- *	Disable SATA phy for specified port.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-static void piix_pcs_disable (struct ata_port *ap)
-{
-	struct pci_dev *pdev = ap->host_set->pdev;
-	u16 pcs;
-
-	pci_read_config_word(pdev, ICH5_PCS, &pcs);
-
-	if (pcs & (1 << ap->port_no)) {
-		pcs &= ~(1 << ap->port_no);
-		pci_write_config_word(pdev, ICH5_PCS, pcs);
-	}
-}
-
-/**
- *	piix_sata_phy_reset - Probe specified port on SATA host controller
- *	@ap: Port to probe
- *
- *	Probe SATA phy.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-static void piix_sata_phy_reset(struct ata_port *ap)
-{
-	unsigned int have_port = 0, have_dev = 0;
-
-	if (!pci_test_config_bits(ap->host_set->pdev,
-				  &piix_enable_bits[ap->port_no])) {
-		ata_port_disable(ap);
-		printk(KERN_INFO "ata%u: port disabled. ignoring.\n", ap->id);
-		return;
-	}
-
-	piix_pcs_probe(ap, &have_port, &have_dev);
-
-	/* if port not enabled, exit */
-	if (!have_port) {
-		ata_port_disable(ap);
-		printk(KERN_INFO "ata%u: SATA port disabled. ignoring.\n",
-		       ap->id);
-		return;
-	}
-
-	/* if port enabled but no device, disable port and exit */
-	if (!have_dev) {
-		piix_sata_port_disable(ap);
-		printk(KERN_INFO "ata%u: SATA port has no device. disabling.\n",
-		       ap->id);
-		return;
-	}
-
-	ap->cbl = ATA_CBL_SATA;
-
-	ata_port_probe(ap);
-
-	ata_bus_reset(ap);
-}
-
-/**
- *	piix_sata_port_disable - Disable SATA port
- *	@ap: Port to disable.
- *
- *	Disable SATA port.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-static void piix_sata_port_disable(struct ata_port *ap)
-{
-	ata_port_disable(ap);
-	piix_pcs_disable(ap);
-}
-
-/**
- *	piix_set_piomode - Initialize host controller PATA PIO timings
- *	@ap: Port whose timings we are configuring
- *	@adev: um
- *	@pio: PIO mode, 0 - 4
- *
- *	Set PIO mode for device, in host controller PCI config space.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-static void piix_set_piomode (struct ata_port *ap, struct ata_device *adev,
-			      unsigned int pio)
-{
-	struct pci_dev *dev	= ap->host_set->pdev;
-	unsigned int is_slave	= (adev->flags & ATA_DFLAG_MASTER) ? 0 : 1;
-	unsigned int master_port= ap->port_no ? 0x42 : 0x40;
-	unsigned int slave_port	= 0x44;
-	u16 master_data;
-	u8 slave_data;
-
-	static const	 /* ISP  RTC */
-	u8 timings[][2]	= { { 0, 0 },
-			    { 0, 0 },
-			    { 1, 0 },
-			    { 2, 1 },
-			    { 2, 3 }, };
-
-	pci_read_config_word(dev, master_port, &master_data);
-	if (is_slave) {
-		master_data |= 0x4000;
-		/* enable PPE, IE and TIME */
-		master_data |= 0x0070;
-		pci_read_config_byte(dev, slave_port, &slave_data);
-		slave_data &= (ap->port_no ? 0x0f : 0xf0);
-		slave_data |=
-			(timings[pio][0] << 2) |
-			(timings[pio][1] << (ap->port_no ? 4 : 0));
-	} else {
-		master_data &= 0xccf8;
-		/* enable PPE, IE and TIME */
-		master_data |= 0x0007;
-		master_data |=
-			(timings[pio][0] << 12) |
-			(timings[pio][1] << 8);
-	}
-	pci_write_config_word(dev, master_port, master_data);
-	if (is_slave)
-		pci_write_config_byte(dev, slave_port, slave_data);
-}
-
-/**
- *	piix_set_udmamode - Initialize host controller PATA PIO timings
- *	@ap: Port whose timings we are configuring
- *	@adev: um
- *	@udma: udma mode, 0 - 6
- *
- *	Set UDMA mode for device, in host controller PCI config space.
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-static void piix_set_udmamode (struct ata_port *ap, struct ata_device *adev,
-			      unsigned int udma)
-{
-	struct pci_dev *dev	= ap->host_set->pdev;
-	u8 maslave		= ap->port_no ? 0x42 : 0x40;
-	u8 speed		= udma;
-	unsigned int drive_dn	= (ap->port_no ? 2 : 0) + adev->devno;
-	int a_speed		= 3 << (drive_dn * 4);
-	int u_flag		= 1 << drive_dn;
-	int v_flag		= 0x01 << drive_dn;
-	int w_flag		= 0x10 << drive_dn;
-	int u_speed		= 0;
-	int			sitre;
-	u16			reg4042, reg44, reg48, reg4a, reg54;
-	u8			reg55;
-
-	pci_read_config_word(dev, maslave, &reg4042);
-	DPRINTK("reg4042 = 0x%04x\n", reg4042);
-	sitre = (reg4042 & 0x4000) ? 1 : 0;
-	pci_read_config_word(dev, 0x44, &reg44);
-	pci_read_config_word(dev, 0x48, &reg48);
-	pci_read_config_word(dev, 0x4a, &reg4a);
-	pci_read_config_word(dev, 0x54, &reg54);
-	pci_read_config_byte(dev, 0x55, &reg55);
-
-	switch(speed) {
-		case XFER_UDMA_4:
-		case XFER_UDMA_2:	u_speed = 2 << (drive_dn * 4); break;
-		case XFER_UDMA_6:
-		case XFER_UDMA_5:
-		case XFER_UDMA_3:
-		case XFER_UDMA_1:	u_speed = 1 << (drive_dn * 4); break;
-		case XFER_UDMA_0:	u_speed = 0 << (drive_dn * 4); break;
-		default:
-			BUG();
-			return;
-	}
-
-	if (!(reg48 & u_flag))
-		pci_write_config_word(dev, 0x48, reg48|u_flag);
-	if (speed == XFER_UDMA_5) {
-		pci_write_config_byte(dev, 0x55, (u8) reg55|w_flag);
-	} else {
-		pci_write_config_byte(dev, 0x55, (u8) reg55 & ~w_flag);
-	}
-	if (!(reg4a & u_speed)) {
-		pci_write_config_word(dev, 0x4a, reg4a & ~a_speed);
-		pci_write_config_word(dev, 0x4a, reg4a|u_speed);
-	}
-	if (speed > XFER_UDMA_2) {
-		if (!(reg54 & v_flag)) {
-			pci_write_config_word(dev, 0x54, reg54|v_flag);
-		}
-	} else {
-		pci_write_config_word(dev, 0x54, reg54 & ~v_flag);
-	}
-}
-
-/**
- *	piix_probe_combined - Determine if PATA and SATA are combined
- *	@pdev: PCI device to examine
- *	@mask: (output) zero, %PIIX_COMB_PRI or %PIIX_COMB_SEC
- *
- *	Determine if BIOS has secretly stuffed a PATA port into our
- *	otherwise-beautiful SATA PCI device.
- *
- *	LOCKING:
- *	Inherited from PCI layer (may sleep).
- */
-static void piix_probe_combined (struct pci_dev *pdev, unsigned int *mask)
-{
-	u8 tmp;
-
-	pci_read_config_byte(pdev, 0x90, &tmp); /* combined mode reg */
-	tmp &= 0x6; 	/* interesting bits 2:1, PATA primary/secondary */
-
-	/* backwards from what one might expect */
-	if (tmp == 0x4)	/* bits 10x */
-		*mask |= PIIX_COMB_SEC;
-	if (tmp == 0x6)	/* bits 11x */
-		*mask |= PIIX_COMB_PRI;
-}
-
-/**
- *	piix_init_one - Register PIIX ATA PCI device with kernel services
- *	@pdev: PCI device to register
- *	@ent: Entry in piix_pci_tbl matching with @pdev
- *
- *	Called from kernel PCI layer.  We probe for combined mode (sigh),
- *	and then hand over control to libata, for it to do the rest.
- *
- *	LOCKING:
- *	Inherited from PCI layer (may sleep).
- *
- *	RETURNS:
- *	Zero on success, or -ERRNO value.
- */
-
-static int piix_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
-{
-	static int printed_version;
-	struct ata_port_info *port_info[2];
-	unsigned int combined = 0, n_ports = 1;
-	unsigned int pata_comb = 0, sata_comb = 0;
-
-	if (!printed_version++)
-		printk(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
-
-	/* no hotplugging support (FIXME) */
-	if (!in_module_init)
-		return -ENODEV;
-
-	port_info[0] = &piix_port_info[ent->driver_data];
-	port_info[1] = NULL;
-	if (port_info[0]->host_flags & PIIX_FLAG_COMBINED)
-		piix_probe_combined(pdev, &combined);
-
-	if (combined & PIIX_COMB_PRI)
-		sata_comb = 1;
-	else if (combined & PIIX_COMB_SEC)
-		pata_comb = 1;
-
-	if (pata_comb || sata_comb) {
-		port_info[sata_comb] = &piix_port_info[ent->driver_data];
-		port_info[sata_comb]->host_flags |= ATA_FLAG_SLAVE_POSS; /* sigh */
-		port_info[pata_comb] = &piix_port_info[ich5_pata]; /*ich5-specific*/
-		n_ports++;
-
-		printk(KERN_WARNING DRV_NAME ": combined mode detected\n");
-	}
-
-	return ata_pci_init_one(pdev, port_info, n_ports);
-}
-
-/**
- *	piix_init -
- *
- *	LOCKING:
- *
- *	RETURNS:
- *
- */
-
-static int __init piix_init(void)
-{
-	int rc;
-
-	DPRINTK("pci_module_init\n");
-	rc = pci_module_init(&piix_pci_driver);
-	if (rc)
-		return rc;
-
-	in_module_init = 0;
-
-	DPRINTK("done\n");
-	return 0;
-}
-
-/**
- *	piix_exit -
- *
- *	LOCKING:
- *
- */
-
-static void __exit piix_exit(void)
-{
-	pci_unregister_driver(&piix_pci_driver);
-}
-
-module_init(piix_init);
-module_exit(piix_exit);
-
diff -purN /dev/shm/linux-2.5/drivers/scsi/libata-core.c linuxppc-2.5-benh/drivers/scsi/libata-core.c
--- /dev/shm/linux-2.5/drivers/scsi/libata-core.c	2003-12-20 01:42:42.000000000 +0000
+++ linuxppc-2.5-benh/drivers/scsi/libata-core.c	2003-12-31 04:25:14.000000000 +0000
@@ -1927,12 +1927,17 @@ static void ata_pio_sector(struct ata_po
 		status);
 
 	/* do the actual data transfer */
-	/* FIXME: mmio-ize */
-	if (qc->flags & ATA_QCFLAG_WRITE)
-		outsl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
-	else
-		insl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
-
+	if (ap->flags & ATA_FLAG_MMIO) {
+		if (qc->flags & ATA_QCFLAG_WRITE)
+			__ide_mm_outsl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
+		else
+			__ide_mm_insl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
+	} else {
+		if (qc->flags & ATA_QCFLAG_WRITE)
+			outsl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
+		else
+			insl(ap->ioaddr.data_addr, buf, ATA_SECT_DWORDS);
+	}
 	kunmap(sg[qc->cursg].page);
 }
 
diff -purN /dev/shm/linux-2.5/drivers/scsi/mac53c94.c linuxppc-2.5-benh/drivers/scsi/mac53c94.c
--- /dev/shm/linux-2.5/drivers/scsi/mac53c94.c	2003-07-27 19:26:20.000000000 +0000
+++ linuxppc-2.5-benh/drivers/scsi/mac53c94.c	2003-10-11 16:46:53.000000000 +0000
@@ -23,6 +23,7 @@
 #include <asm/prom.h>
 #include <asm/system.h>
 #include <asm/pci-bridge.h>
+#include <asm/macio.h>
 
 #include "scsi.h"
 #include "hosts.h"
@@ -37,13 +38,12 @@ enum fsc_phase {
 };
 
 struct fsc_state {
-	volatile struct	mac53c94_regs *regs;
+	struct	mac53c94_regs *regs;
 	int	intr;
-	volatile struct	dbdma_regs *dma;
+	struct	dbdma_regs *dma;
 	int	dmaintr;
 	int	clk_freq;
 	struct	Scsi_Host *host;
-	struct	fsc_state *next;
 	Scsi_Cmnd *request_q;
 	Scsi_Cmnd *request_qtail;
 	Scsi_Cmnd *current_req;		/* req we're currently working on */
@@ -52,151 +52,23 @@ struct fsc_state {
 	void	*dma_cmd_space;
 	struct	pci_dev *pdev;
 	dma_addr_t dma_addr;
+	struct macio_dev *mdev;
 };
 
-static struct fsc_state *all_53c94s;
-
 static void mac53c94_init(struct fsc_state *);
 static void mac53c94_start(struct fsc_state *);
 static void mac53c94_interrupt(int, void *, struct pt_regs *);
 static irqreturn_t do_mac53c94_interrupt(int, void *, struct pt_regs *);
 static void cmd_done(struct fsc_state *, int result);
 static void set_dma_cmds(struct fsc_state *, Scsi_Cmnd *);
-static int data_goes_out(Scsi_Cmnd *);
-
-int
-mac53c94_detect(Scsi_Host_Template *tp)
-{
-	struct device_node *node;
-	int nfscs;
-	struct fsc_state *state, **prev_statep;
-	struct Scsi_Host *host;
-	void *dma_cmd_space;
-	unsigned char *clkprop;
-	int proplen;
-	struct pci_dev *pdev;
-	u8 pbus, devfn;
-
-	nfscs = 0;
-	prev_statep = &all_53c94s;
-	for (node = find_devices("53c94"); node != 0; node = node->next) {
-		if (node->n_addrs != 2 || node->n_intrs != 2) {
-			printk(KERN_ERR "mac53c94: expected 2 addrs and intrs"
-			       " (got %d/%d) for node %s\n",
-			       node->n_addrs, node->n_intrs, node->full_name);
-			continue;
-		}
-
-		pdev = NULL;
-		if (node->parent != NULL
-		    && !pci_device_from_OF_node(node->parent, &pbus, &devfn))
-			pdev = pci_find_slot(pbus, devfn);
-		if (pdev == NULL) {
-			printk(KERN_ERR "mac53c94: can't find PCI device "
-			       "for %s\n", node->full_name);
-			continue;
-		}
-
-		host = scsi_register(tp, sizeof(struct fsc_state));
-		if (host == NULL)
-			break;
-		host->unique_id = nfscs;
-
-		state = (struct fsc_state *) host->hostdata;
-		if (state == 0) {
-			/* "can't happen" */
-			printk(KERN_ERR "mac53c94: no state for %s?!\n",
-			       node->full_name);
-			scsi_unregister(host);
-			break;
-		}
-		state->host = host;
-		state->pdev = pdev;
-
-		state->regs = (volatile struct mac53c94_regs *)
-			ioremap(node->addrs[0].address, 0x1000);
-		state->intr = node->intrs[0].line;
-		state->dma = (volatile struct dbdma_regs *)
-			ioremap(node->addrs[1].address, 0x1000);
-		state->dmaintr = node->intrs[1].line;
-		if (state->regs == NULL || state->dma == NULL) {
-			printk(KERN_ERR "mac53c94: ioremap failed for %s\n",
-			       node->full_name);
-			if (state->dma != NULL)
-				iounmap(state->dma);
-			if (state->regs != NULL)
-				iounmap(state->regs);
-			scsi_unregister(host);
-			break;
-		}
-
-		clkprop = get_property(node, "clock-frequency", &proplen);
-		if (clkprop == NULL || proplen != sizeof(int)) {
-			printk(KERN_ERR "%s: can't get clock frequency, "
-			       "assuming 25MHz\n", node->full_name);
-			state->clk_freq = 25000000;
-		} else
-			state->clk_freq = *(int *)clkprop;
-
-		/* Space for dma command list: +1 for stop command,
-		   +1 to allow for aligning. */
-		dma_cmd_space = kmalloc((host->sg_tablesize + 2) *
-					sizeof(struct dbdma_cmd), GFP_KERNEL);
-		if (dma_cmd_space == 0) {
-			printk(KERN_ERR "mac53c94: couldn't allocate dma "
-			       "command space for %s\n", node->full_name);
-			goto err_cleanup;
-		}
-		state->dma_cmds = (struct dbdma_cmd *)
-			DBDMA_ALIGN(dma_cmd_space);
-		memset(state->dma_cmds, 0, (host->sg_tablesize + 1)
-		       * sizeof(struct dbdma_cmd));
-		state->dma_cmd_space = dma_cmd_space;
-
-		*prev_statep = state;
-		prev_statep = &state->next;
-
-		if (request_irq(state->intr, do_mac53c94_interrupt, 0,
-				"53C94", state)) {
-			printk(KERN_ERR "mac53C94: can't get irq %d for %s\n",
-			       state->intr, node->full_name);
-		err_cleanup:
-			iounmap(state->dma);
-			iounmap(state->regs);
-			scsi_unregister(host);
-			break;
-		}
-
-		mac53c94_init(state);
-
-		++nfscs;
-	}
-	return nfscs;
-}
-
-int
-mac53c94_release(struct Scsi_Host *host)
-{
-	struct fsc_state *fp = (struct fsc_state *) host->hostdata;
 
-	if (fp == 0)
-		return 0;
-	if (fp->regs)
-		iounmap((void *) fp->regs);
-	if (fp->dma)
-		iounmap((void *) fp->dma);
-	kfree(fp->dma_cmd_space);
-	free_irq(fp->intr, fp);
-	return 0;
-}
 
-int
-mac53c94_queue(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+static int mac53c94_queue(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
 {
 	struct fsc_state *state;
 
 #if 0
-	if (data_goes_out(cmd)) {
+	if (cmd->sc_data_direction == SCSI_DATA_WRITE) {
 		int i;
 		printk(KERN_DEBUG "mac53c94_queue %p: command is", cmd);
 		for (i = 0; i < cmd->cmd_len; ++i)
@@ -223,60 +95,52 @@ mac53c94_queue(Scsi_Cmnd *cmd, void (*do
 	return 0;
 }
 
-int
-mac53c94_abort(Scsi_Cmnd *cmd)
+static int mac53c94_abort(Scsi_Cmnd *cmd)
 {
 	return SCSI_ABORT_SNOOZE;
 }
 
-int
-mac53c94_host_reset(Scsi_Cmnd *cmd)
+static int mac53c94_host_reset(Scsi_Cmnd *cmd)
 {
 	struct fsc_state *state = (struct fsc_state *) cmd->device->host->hostdata;
-	volatile struct mac53c94_regs *regs = state->regs;
-	volatile struct dbdma_regs *dma = state->dma;
+	struct mac53c94_regs *regs = state->regs;
+	struct dbdma_regs *dma = state->dma;
 
 	st_le32(&dma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
-	regs->command = CMD_SCSI_RESET;	/* assert RST */
-	eieio();
+	writeb(CMD_SCSI_RESET, &regs->command);	/* assert RST */
 	udelay(100);			/* leave it on for a while (>= 25us) */
-	regs->command = CMD_RESET;
-	eieio();
+	writeb(CMD_RESET, &regs->command);
 	udelay(20);
 	mac53c94_init(state);
-	regs->command = CMD_NOP;
-	eieio();
+	writeb(CMD_NOP, &regs->command);
 	return SUCCESS;
 }
 
-static void
-mac53c94_init(struct fsc_state *state)
+static void mac53c94_init(struct fsc_state *state)
 {
-	volatile struct mac53c94_regs *regs = state->regs;
-	volatile struct dbdma_regs *dma = state->dma;
+	struct mac53c94_regs *regs = state->regs;
+	struct dbdma_regs *dma = state->dma;
 	int x;
 
-	regs->config1 = state->host->this_id | CF1_PAR_ENABLE;
-	regs->sel_timeout = TIMO_VAL(250);	/* 250ms */
-	regs->clk_factor = CLKF_VAL(state->clk_freq);
-	regs->config2 = CF2_FEATURE_EN;
-	regs->config3 = 0;
-	regs->sync_period = 0;
-	regs->sync_offset = 0;
-	eieio();
-	x = regs->interrupt;
-	st_le32(&dma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
+	writeb(state->host->this_id | CF1_PAR_ENABLE, &regs->config1);
+	writeb(TIMO_VAL(250), &regs->sel_timeout);	/* 250ms */
+	writeb(CLKF_VAL(state->clk_freq), &regs->clk_factor);
+	writeb(CF2_FEATURE_EN, &regs->config2);
+	writeb(0, &regs->config3);
+	writeb(0, &regs->sync_period);
+	writeb(0, &regs->sync_offset);
+	x = readb(&regs->interrupt);
+	writel((RUN|PAUSE|FLUSH|WAKE) << 16, &dma->control);
 }
 
 /*
  * Start the next command for a 53C94.
  * Should be called with interrupts disabled.
  */
-static void
-mac53c94_start(struct fsc_state *state)
+static void mac53c94_start(struct fsc_state *state)
 {
 	Scsi_Cmnd *cmd;
-	volatile struct mac53c94_regs *regs = state->regs;
+	struct mac53c94_regs *regs = state->regs;
 	int i;
 
 	if (state->phase != idle || state->current_req != NULL)
@@ -287,37 +151,30 @@ mac53c94_start(struct fsc_state *state)
 	state->request_q = (Scsi_Cmnd *) cmd->host_scribble;
 
 	/* Off we go */
-	regs->count_lo = 0;
-	regs->count_mid = 0;
-	regs->count_hi = 0;
-	eieio();
-	regs->command = CMD_NOP + CMD_DMA_MODE;
+	writeb(0, &regs->count_lo);
+	writeb(0, &regs->count_mid);
+	writeb(0, &regs->count_hi);
+	writeb(CMD_NOP + CMD_DMA_MODE, &regs->command);
 	udelay(1);
-	eieio();
-	regs->command = CMD_FLUSH;
+	writeb(CMD_FLUSH, &regs->command);
 	udelay(1);
-	eieio();
-	regs->dest_id = cmd->device->id;
-	regs->sync_period = 0;
-	regs->sync_offset = 0;
-	eieio();
+	writeb(cmd->device->id, &regs->dest_id);
+	writeb(0, &regs->sync_period);
+	writeb(0, &regs->sync_offset);
 
 	/* load the command into the FIFO */
-	for (i = 0; i < cmd->cmd_len; ++i) {
-		regs->fifo = cmd->cmnd[i];
-		eieio();
-	}
+	for (i = 0; i < cmd->cmd_len; ++i)
+		writeb(cmd->cmnd[i], &regs->fifo);
 
 	/* do select without ATN XXX */
-	regs->command = CMD_SELECT;
+	writeb(CMD_SELECT, &regs->command);
 	state->phase = selecting;
 
 	if (cmd->use_sg > 0 || cmd->request_bufflen != 0)
 		set_dma_cmds(state, cmd);
 }
 
-static irqreturn_t
-do_mac53c94_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static irqreturn_t do_mac53c94_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
 {
 	unsigned long flags;
 	struct Scsi_Host *dev = ((struct fsc_state *) dev_id)->current_req->device->host;
@@ -328,12 +185,11 @@ do_mac53c94_interrupt(int irq, void *dev
 	return IRQ_HANDLED;
 }
 
-static void
-mac53c94_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static void mac53c94_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
 {
 	struct fsc_state *state = (struct fsc_state *) dev_id;
-	volatile struct mac53c94_regs *regs = state->regs;
-	volatile struct dbdma_regs *dma = state->dma;
+	struct mac53c94_regs *regs = state->regs;
+	struct dbdma_regs *dma = state->dma;
 	Scsi_Cmnd *cmd = state->current_req;
 	int nb, stat, seq, intr;
 	static int mac53c94_errors;
@@ -343,9 +199,9 @@ mac53c94_interrupt(int irq, void *dev_id
 	 * Apparently, reading the interrupt register unlatches
 	 * the status and sequence step registers.
 	 */
-	seq = regs->seqstep;
-	stat = regs->status;
-	intr = regs->interrupt;
+	seq = readb(&regs->seqstep);
+	stat = readb(&regs->status);
+	intr = readb(&regs->interrupt);
 
 #if 0
 	printk(KERN_DEBUG "mac53c94_intr, intr=%x stat=%x seq=%x phase=%d\n",
@@ -355,8 +211,8 @@ mac53c94_interrupt(int irq, void *dev_id
 	if (intr & INTR_RESET) {
 		/* SCSI bus was reset */
 		printk(KERN_INFO "external SCSI bus reset detected\n");
-		regs->command = CMD_NOP;
-		st_le32(&dma->control, RUN << 16);	/* stop dma */
+		writeb(CMD_NOP, &regs->command);
+		writel(RUN << 16, &dma->control);	/* stop dma */
 		cmd_done(state, DID_RESET << 16);
 		return;
 	}
@@ -373,8 +229,7 @@ mac53c94_interrupt(int irq, void *dev_id
 		       intr, stat, seq, state->phase);
 #endif
 		++mac53c94_errors;
-		regs->command = CMD_NOP + CMD_DMA_MODE;
-		eieio();
+		writeb(CMD_NOP + CMD_DMA_MODE, &regs->command);
 	}
 	if (cmd == 0) {
 		printk(KERN_DEBUG "53c94: interrupt with no command active?\n");
@@ -402,7 +257,7 @@ mac53c94_interrupt(int irq, void *dev_id
 			cmd_done(state, DID_ERROR << 16);
 			return;
 		}
-		regs->command = CMD_NOP;
+		writeb(CMD_NOP, &regs->command);
 		/* set DMA controller going if any data to transfer */
 		if ((stat & (STAT_MSG|STAT_CD)) == 0
 		    && (cmd->use_sg > 0 || cmd->request_bufflen != 0)) {
@@ -410,20 +265,17 @@ mac53c94_interrupt(int irq, void *dev_id
 			if (nb > 0xfff0)
 				nb = 0xfff0;
 			cmd->SCp.this_residual -= nb;
-			regs->count_lo = nb;
-			regs->count_mid = nb >> 8;
-			eieio();
-			regs->command = CMD_DMA_MODE + CMD_NOP;
-			eieio();
-			st_le32(&dma->cmdptr, virt_to_phys(state->dma_cmds));
-			st_le32(&dma->control, (RUN << 16) | RUN);
-			eieio();
-			regs->command = CMD_DMA_MODE + CMD_XFER_DATA;
+			writeb(nb, &regs->count_lo);
+			writeb(nb >> 8, &regs->count_mid);
+			writeb(CMD_DMA_MODE + CMD_NOP, &regs->command);
+			writel(virt_to_phys(state->dma_cmds), &dma->cmdptr);
+			writel((RUN << 16) | RUN, &dma->control);
+			writeb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);
 			state->phase = dataing;
 			break;
 		} else if ((stat & STAT_PHASE) == STAT_CD + STAT_IO) {
 			/* up to status phase already */
-			regs->command = CMD_I_COMPLETE;
+			writeb(CMD_I_COMPLETE, &regs->command);
 			state->phase = completing;
 		} else {
 			printk(KERN_DEBUG "in unexpected phase %x after cmd\n",
@@ -446,18 +298,16 @@ mac53c94_interrupt(int irq, void *dev_id
 			if (nb > 0xfff0)
 				nb = 0xfff0;
 			cmd->SCp.this_residual -= nb;
-			regs->count_lo = nb;
-			regs->count_mid = nb >> 8;
-			eieio();
-			regs->command = CMD_DMA_MODE + CMD_NOP;
-			eieio();
-			regs->command = CMD_DMA_MODE + CMD_XFER_DATA;
+			writeb(nb, &regs->count_lo);
+			writeb(nb >> 8, &regs->count_mid);
+			writeb(CMD_DMA_MODE + CMD_NOP, &regs->command);
+			writeb(CMD_DMA_MODE + CMD_XFER_DATA, &regs->command);
 			break;
 		}
 		if ((stat & STAT_PHASE) != STAT_CD + STAT_IO) {
 			printk(KERN_DEBUG "intr %x before data xfer complete\n", intr);
 		}
-		out_le32(&dma->control, RUN << 16);	/* stop dma */
+		writel(RUN << 16, &dma->control);	/* stop dma */
 		dma_dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
 		if (cmd->use_sg != 0) {
 			pci_unmap_sg(state->pdev,
@@ -468,7 +318,7 @@ mac53c94_interrupt(int irq, void *dev_id
 				cmd->request_bufflen, dma_dir);
 		}
 		/* should check dma status */
-		regs->command = CMD_I_COMPLETE;
+		writeb(CMD_I_COMPLETE, &regs->command);
 		state->phase = completing;
 		break;
 	case completing:
@@ -477,10 +327,10 @@ mac53c94_interrupt(int irq, void *dev_id
 			cmd_done(state, DID_ERROR << 16);
 			return;
 		}
-		cmd->SCp.Status = regs->fifo; eieio();
-		cmd->SCp.Message = regs->fifo; eieio();
-		cmd->result = 
-		regs->command = CMD_ACCEPT_MSG;
+		cmd->SCp.Status = readb(&regs->fifo);
+		cmd->SCp.Message = readb(&regs->fifo);
+		cmd->result = CMD_ACCEPT_MSG;
+		writeb(CMD_ACCEPT_MSG, &regs->command);
 		state->phase = busfreeing;
 		break;
 	case busfreeing:
@@ -495,8 +345,7 @@ mac53c94_interrupt(int irq, void *dev_id
 	}
 }
 
-static void
-cmd_done(struct fsc_state *state, int result)
+static void cmd_done(struct fsc_state *state, int result)
 {
 	Scsi_Cmnd *cmd;
 
@@ -513,8 +362,7 @@ cmd_done(struct fsc_state *state, int re
 /*
  * Set up DMA commands for transferring data.
  */
-static void
-set_dma_cmds(struct fsc_state *state, Scsi_Cmnd *cmd)
+static void set_dma_cmds(struct fsc_state *state, Scsi_Cmnd *cmd)
 {
 	int i, dma_cmd, total;
 	struct scatterlist *scl;
@@ -523,7 +371,8 @@ set_dma_cmds(struct fsc_state *state, Sc
 	u32 dma_len;
 	int dma_dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
 
-	dma_cmd = data_goes_out(cmd)? OUTPUT_MORE: INPUT_MORE;
+	dma_cmd = cmd->sc_data_direction == SCSI_DATA_WRITE? OUTPUT_MORE:
+		INPUT_MORE;
 	dcmds = state->dma_cmds;
 	if (cmd->use_sg > 0) {
 		int nseg;
@@ -562,63 +411,9 @@ set_dma_cmds(struct fsc_state *state, Sc
 	cmd->SCp.this_residual = total;
 }
 
-/*
- * Work out whether data will be going out from the host adaptor or into it.
- */
-static int
-data_goes_out(Scsi_Cmnd *cmd)
-{
-	switch (cmd->sc_data_direction) {
-	case SCSI_DATA_WRITE:
-		return 1;
-	case SCSI_DATA_READ:
-		return 0;
-	}
-
-	/* for SCSI_DATA_UNKNOWN or SCSI_DATA_NONE, fall back on the
-	   old method for now... */
-	switch (cmd->cmnd[0]) {
-	case CHANGE_DEFINITION: 
-	case COMPARE:	  
-	case COPY:
-	case COPY_VERIFY:	    
-	case FORMAT_UNIT:	 
-	case LOG_SELECT:
-	case MEDIUM_SCAN:	  
-	case MODE_SELECT:
-	case MODE_SELECT_10:
-	case REASSIGN_BLOCKS: 
-	case RESERVE:
-	case SEARCH_EQUAL:	  
-	case SEARCH_EQUAL_12: 
-	case SEARCH_HIGH:	 
-	case SEARCH_HIGH_12:  
-	case SEARCH_LOW:
-	case SEARCH_LOW_12:
-	case SEND_DIAGNOSTIC: 
-	case SEND_VOLUME_TAG:	     
-	case SET_WINDOW: 
-	case UPDATE_BLOCK:	
-	case WRITE_BUFFER:
- 	case WRITE_6:	
-	case WRITE_10:	
-	case WRITE_12:	  
-	case WRITE_LONG:	
-	case WRITE_LONG_2:      /* alternate code for WRITE_LONG */
-	case WRITE_SAME:	
-	case WRITE_VERIFY:
-	case WRITE_VERIFY_12:
-		return 1;
-	default:
-		return 0;
-	}
-}
-
-static Scsi_Host_Template driver_template = {
+static Scsi_Host_Template mac53c94_template = {
 	.proc_name	= "53c94",
 	.name		= "53C94",
-	.detect		= mac53c94_detect,
-	.release	= mac53c94_release,
 	.queuecommand	= mac53c94_queue,
 	.eh_abort_handler = mac53c94_abort,
 	.eh_host_reset_handler = mac53c94_host_reset,
@@ -629,4 +424,158 @@ static Scsi_Host_Template driver_templat
 	.use_clustering	= DISABLE_CLUSTERING,
 };
 
-#include "scsi_module.c"
+static int mac53c94_probe(struct macio_dev *mdev, const struct of_match *match)
+{
+	struct device_node *node = macio_get_of_node(mdev);
+	struct pci_dev *pdev = macio_get_pci_dev(mdev);
+	struct fsc_state *state;
+	struct Scsi_Host *host;
+	void *dma_cmd_space;
+	unsigned char *clkprop;
+	int proplen;
+
+	if (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {
+		printk(KERN_ERR "mac53c94: expected 2 addrs and intrs (got %d/%d)\n",
+		       node->n_addrs, node->n_intrs);
+		return -ENODEV;
+	}
+
+	if (macio_request_resources(mdev, "mac53c94") != 0) {
+       		printk(KERN_ERR "mac53c94: unable to request memory resources");
+		return -EBUSY;
+	}
+
+       	host = scsi_host_alloc(&mac53c94_template, sizeof(struct fsc_state));
+	if (host == NULL) {
+		printk(KERN_ERR "mac53c94: couldn't register host");
+		goto out_release;
+	}
+
+	state = (struct fsc_state *) host->hostdata;
+	macio_set_drvdata(mdev, state);
+	state->host = host;
+	state->pdev = pdev;
+	state->mdev = mdev;
+
+	state->regs = (struct mac53c94_regs *)
+		ioremap(macio_resource_start(mdev, 0), 0x1000);
+	state->intr = macio_irq(mdev, 0);
+	state->dma = (struct dbdma_regs *)
+		ioremap(macio_resource_start(mdev, 1), 0x1000);
+	state->dmaintr = macio_irq(mdev, 1);
+	if (state->regs == NULL || state->dma == NULL) {
+		printk(KERN_ERR "mac53c94: ioremap failed for %s\n",
+		       node->full_name);
+		goto out_free;
+	}
+
+       	clkprop = get_property(node, "clock-frequency", &proplen);
+       	if (clkprop == NULL || proplen != sizeof(int)) {
+       		printk(KERN_ERR "%s: can't get clock frequency, "
+       		       "assuming 25MHz\n", node->full_name);
+       		state->clk_freq = 25000000;
+       	} else
+       		state->clk_freq = *(int *)clkprop;
+
+       	/* Space for dma command list: +1 for stop command,
+       	 * +1 to allow for aligning.
+	 * XXX FIXME: Use DMA consistent routines
+	 */
+       	dma_cmd_space = kmalloc((host->sg_tablesize + 2) *
+       				sizeof(struct dbdma_cmd), GFP_KERNEL);
+       	if (dma_cmd_space == 0) {
+       		printk(KERN_ERR "mac53c94: couldn't allocate dma "
+       		       "command space for %s\n", node->full_name);
+       		goto out_free;
+       	}
+	state->dma_cmds = (struct dbdma_cmd *)DBDMA_ALIGN(dma_cmd_space);
+	memset(state->dma_cmds, 0, (host->sg_tablesize + 1)
+	       * sizeof(struct dbdma_cmd));
+	state->dma_cmd_space = dma_cmd_space;
+
+	mac53c94_init(state);
+
+	if (request_irq(state->intr, do_mac53c94_interrupt, 0, "53C94", state)) {
+		printk(KERN_ERR "mac53C94: can't get irq %d for %s\n",
+		       state->intr, node->full_name);
+		goto out_free_dma;
+	}
+
+	/* XXX FIXME: handle failure */
+	scsi_add_host(host, &mdev->ofdev.dev);
+	scsi_scan_host(host);
+
+	return 0;
+
+ out_free_dma:
+	kfree(state->dma_cmd_space);
+ out_free:
+	if (state->dma != NULL)
+		iounmap(state->dma);
+	if (state->regs != NULL)
+		iounmap(state->regs);
+	scsi_host_put(host);
+ out_release:
+	macio_release_resources(mdev);
+
+	return  -ENODEV;
+}
+
+static int mac53c94_remove(struct macio_dev *mdev)
+{
+	struct fsc_state *fp = (struct fsc_state *)macio_get_drvdata(mdev);
+	struct Scsi_Host *host = fp->host;
+
+	scsi_remove_host(host);
+
+	free_irq(fp->intr, fp);
+
+	if (fp->regs)
+		iounmap((void *) fp->regs);
+	if (fp->dma)
+		iounmap((void *) fp->dma);
+	kfree(fp->dma_cmd_space);
+
+	scsi_host_put(host);
+
+	macio_release_resources(mdev);
+
+	return 0;
+}
+
+
+static struct of_match mac53c94_match[] = 
+{
+	{
+	.name 		= "53c94",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH
+	},
+	{},
+};
+
+static struct macio_driver mac53c94_driver = 
+{
+	.name 		= "mac53c94",
+	.match_table	= mac53c94_match,
+	.probe		= mac53c94_probe,
+	.remove		= mac53c94_remove,
+};
+
+
+static int __init init_mac53c94(void)
+{
+	return macio_register_driver(&mac53c94_driver);
+}
+
+static void __exit exit_mac53c94(void)
+{
+	return macio_unregister_driver(&mac53c94_driver);
+}
+
+module_init(init_mac53c94);
+module_exit(exit_mac53c94);
+
+MODULE_DESCRIPTION("PowerMac 53c94 SCSI driver");
+MODULE_AUTHOR("Paul Mackerras <paulus@samba.org>");
+MODULE_LICENSE("GPL");
diff -purN /dev/shm/linux-2.5/drivers/scsi/mesh.c linuxppc-2.5-benh/drivers/scsi/mesh.c
--- /dev/shm/linux-2.5/drivers/scsi/mesh.c	2003-05-02 19:42:12.000000000 +0000
+++ linuxppc-2.5-benh/drivers/scsi/mesh.c	2003-10-11 16:48:05.000000000 +0000
@@ -10,9 +10,13 @@
  * Apr. 21 2002  - BenH		Rework bus reset code for new error handler
  *                              Add delay after initial bus reset
  *                              Add module parameters
+ *
+ * Sep. 27 2003  - BenH		Move to new driver model, fix some write posting
+ *				issues
  * To do:
  * - handle aborts correctly
  * - retry arbitration if lost (unless higher levels do this for us)
+ * - power down the chip when no device is detected
  */
 #include <linux/config.h>
 #include <linux/module.h>
@@ -38,10 +42,7 @@
 #include <asm/machdep.h>
 #include <asm/pmac_feature.h>
 #include <asm/pci-bridge.h>
-#ifdef CONFIG_PMAC_PBOOK
-#include <linux/adb.h>
-#include <linux/pmu.h>
-#endif
+#include <asm/macio.h>
 
 #include "scsi.h"
 #include "hosts.h"
@@ -164,10 +165,12 @@ struct mesh_state {
 	int	last_n_msgout;
 	u8	msgout[16];
 	struct dbdma_cmd *dma_cmds;	/* space for dbdma commands, aligned */
+	dma_addr_t dma_cmd_bus;
+	void	*dma_cmd_space;
+	int	dma_cmd_size;
 	int	clk_freq;
 	struct mesh_target tgts[8];
-	void	*dma_cmd_space;
-	struct device_node *ofnode;
+	struct macio_dev *mdev;
 	struct pci_dev* pdev;
 #ifdef MESH_DBG
 	int	log_ix;
@@ -176,324 +179,124 @@ struct mesh_state {
 #endif
 };
 
-#ifdef MESH_DBG
-
-static void dlog(struct mesh_state *ms, char *fmt, int a);
-static void dumplog(struct mesh_state *ms, int tgt);
-static void dumpslog(struct mesh_state *ms);
-
-#else
-static inline void dlog(struct mesh_state *ms, char *fmt, int a)
-{}
-static inline void dumplog(struct mesh_state *ms, int tgt)
-{}
-static inline void dumpslog(struct mesh_state *ms)
-{}
-
-#endif /* MESH_DBG */
-#define MKWORD(a, b, c, d)	(((a) << 24) + ((b) << 16) + ((c) << 8) + (d))
+/*
+ * Driver is too messy, we need a few prototypes...
+ */
+static void mesh_done(struct mesh_state *ms, int start_next);
+static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs);
+static void cmd_complete(struct mesh_state *ms);
+static void set_dma_cmds(struct mesh_state *ms, Scsi_Cmnd *cmd);
+static void halt_dma(struct mesh_state *ms);
+static void phase_mismatch(struct mesh_state *ms);
 
-static struct mesh_state *all_meshes;
 
-static void mesh_init(struct mesh_state *);
-static int mesh_notify_reboot(struct notifier_block *, unsigned long, void *);
-static void mesh_dump_regs(struct mesh_state *);
-static void mesh_start(struct mesh_state *);
-static void mesh_start_cmd(struct mesh_state *, Scsi_Cmnd *);
-static void add_sdtr_msg(struct mesh_state *);
-static void set_sdtr(struct mesh_state *, int, int);
-static void start_phase(struct mesh_state *);
-static void get_msgin(struct mesh_state *);
-static int msgin_length(struct mesh_state *);
-static void cmd_complete(struct mesh_state *);
-static void phase_mismatch(struct mesh_state *);
-static void reselected(struct mesh_state *);
-static void handle_reset(struct mesh_state *);
-static void handle_error(struct mesh_state *);
-static void handle_exception(struct mesh_state *);
-static void mesh_interrupt(int, void *, struct pt_regs *);
-static irqreturn_t do_mesh_interrupt(int, void *, struct pt_regs *);
-static void handle_msgin(struct mesh_state *);
-static void mesh_done(struct mesh_state *, int);
-static void mesh_completed(struct mesh_state *, Scsi_Cmnd *);
-static void set_dma_cmds(struct mesh_state *, Scsi_Cmnd *);
-static void halt_dma(struct mesh_state *);
-static int data_goes_out(Scsi_Cmnd *);
-static void do_abort(struct mesh_state *ms);
-static void set_mesh_power(struct mesh_state *ms, int state);
-
-#ifdef CONFIG_PMAC_PBOOK
-static int mesh_notify_sleep(struct pmu_sleep_notifier *self, int when);
-static struct pmu_sleep_notifier mesh_sleep_notifier = {
-	mesh_notify_sleep,
-	SLEEP_LEVEL_BLOCK,
-};
-#endif
+/*
+ * Some debugging & logging routines
+ */
 
-static struct notifier_block mesh_notifier = {
-	mesh_notify_reboot,
-	NULL,
-	0
-};
+#ifdef MESH_DBG
 
-int
-mesh_detect(Scsi_Host_Template *tp)
+static inline u32 readtb(void)
 {
-	struct device_node *mesh;
-	int nmeshes, tgt, *cfp, minper;
-	struct mesh_state *ms, **prev_statep;
-	struct Scsi_Host *mesh_host;
-	void *dma_cmd_space;
-
-	if (_machine == _MACH_Pmac) {
-	    use_active_neg = (find_devices("mac-io") ? 0 : SEQ_ACTIVE_NEG);
-	} else {
-	    /* CHRP mac-io */
-	    use_active_neg = SEQ_ACTIVE_NEG;
-	}
-
-	/* Calculate sync rate from module parameters */
-	if (sync_rate > 10)
-		sync_rate = 10;
-	if (sync_rate > 0) {
-		printk(KERN_INFO "mesh: configured for synchronous %d MB/s\n", sync_rate);
-		mesh_sync_period = 1000 / sync_rate;	/* ns */
-		mesh_sync_offset = 15;
-	} else
-		printk(KERN_INFO "mesh: configured for asynchronous\n");
-
-	nmeshes = 0;
-	prev_statep = &all_meshes;
-	/*
-	 * On powermacs, the MESH node has device_type "mesh".
-	 * On chrp machines, its device_type is "scsi" with
-	 * "chrp,mesh0" as its `compatible' property.
-	 */
-	mesh = find_devices("mesh");
-	if (mesh == 0)
-		mesh = find_compatible_devices("scsi", "chrp,mesh0");
-	for (; mesh != 0; mesh = mesh->next) {
-		u8 pci_bus, pci_devfn;
-		struct pci_dev* pdev = NULL;
-		
-		if (mesh->n_addrs != 2 || mesh->n_intrs != 2) {
-			printk(KERN_ERR "mesh: expected 2 addrs and 2 intrs"
-			       " (got %d,%d)\n", mesh->n_addrs, mesh->n_intrs);
-			continue;
-		}
-		if (mesh->parent != NULL
-		    && pci_device_from_OF_node(mesh->parent, &pci_bus,
-					       &pci_devfn) == 0)
-			pdev = pci_find_slot(pci_bus, pci_devfn);
-		if (pdev == NULL) {
-			printk(KERN_ERR "mesh: Can't locate PCI entry\n");
-			continue;
-		}
+	u32 tb;
 
-		mesh_host = scsi_register(tp, sizeof(struct mesh_state));
-		if (mesh_host == 0) {
-			printk(KERN_ERR "mesh: couldn't register host");
-			continue;
-		}
-		mesh_host->unique_id = nmeshes;
-#if !defined(MODULE)
-		note_scsi_host(mesh, mesh_host);
+#ifdef DBG_USE_TB
+	/* Beware: if you enable this, it will crash on 601s. */
+	asm ("mftb %0" : "=r" (tb) : );
+#else
+	tb = 0;
 #endif
-
-		ms = (struct mesh_state *) mesh_host->hostdata;
-		if (ms == 0)
-			panic("no mesh state");
-		memset(ms, 0, sizeof(*ms));
-		ms->host = mesh_host;
-		ms->ofnode = mesh;
-		ms->pdev = pdev;
-		ms->mesh = (volatile struct mesh_regs *)
-			ioremap(mesh->addrs[0].address, 0x1000);
-		ms->dma = (volatile struct dbdma_regs *)
-			ioremap(mesh->addrs[1].address, 0x1000);
-		ms->meshintr = mesh->intrs[0].line;
-		ms->dmaintr = mesh->intrs[1].line;
-
-		/* Space for dma command list: +1 for stop command,
-		   +1 to allow for aligning. */
-		dma_cmd_space = kmalloc((mesh_host->sg_tablesize + 2) *
-					sizeof(struct dbdma_cmd), GFP_KERNEL);
-		if (dma_cmd_space == 0)
-			panic("mesh: couldn't allocate dma command space");
-		ms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);
-		memset(ms->dma_cmds, 0, (mesh_host->sg_tablesize + 1)
-		       * sizeof(struct dbdma_cmd));
-		ms->dma_cmd_space = dma_cmd_space;
-
-		ms->current_req = 0;
-		for (tgt = 0; tgt < 8; ++tgt) {
-			ms->tgts[tgt].sdtr_state = do_sdtr;
-			ms->tgts[tgt].sync_params = ASYNC_PARAMS;
-			ms->tgts[tgt].current_req = 0;
-		}
-		*prev_statep = ms;
-		prev_statep = &ms->next;
-
-		if ((cfp = (int *) get_property(mesh, "clock-frequency",
-						NULL))) {
-			ms->clk_freq = *cfp;
-		} else {
-			printk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");
-			ms->clk_freq = 50000000;
-		}
-		/* The maximum sync rate is clock / 5; increase
-		   mesh_sync_period if necessary. */
-		minper = 1000000000 / (ms->clk_freq / 5);	/* ns */
-		if (mesh_sync_period < minper)
-			mesh_sync_period = minper;
-
-		set_mesh_power(ms, 1);
-
-		mesh_init(ms);
-
-		if (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms)) {
-			printk(KERN_ERR "MESH: can't get irq %d\n", ms->meshintr);
-		}
-
-		++nmeshes;
-	}
-
-	if ((_machine == _MACH_Pmac) && (nmeshes > 0)) {
-#ifdef CONFIG_PMAC_PBOOK
-		pmu_register_sleep_notifier(&mesh_sleep_notifier);
-#endif /* CONFIG_PMAC_PBOOK */
-		register_reboot_notifier(&mesh_notifier);
-	}
-
-	return nmeshes;
+	return tb;
 }
 
-int
-mesh_release(struct Scsi_Host *host)
+static void dlog(struct mesh_state *ms, char *fmt, int a)
 {
-	struct mesh_state *ms = (struct mesh_state *) host->hostdata;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	struct dbglog *tlp, *slp;
 
-	if (ms == 0)
-		return 0;
-	if (ms->mesh)
-		iounmap((void *) ms->mesh);
-	if (ms->dma)
-		iounmap((void *) ms->dma);
-	kfree(ms->dma_cmd_space);
-	free_irq(ms->meshintr, ms);
-	pmac_call_feature(PMAC_FTR_MESH_ENABLE, ms->ofnode, 0, 0);
-	return 0;
+	tlp = &tp->log[tp->log_ix];
+	slp = &ms->log[ms->log_ix];
+	tlp->fmt = fmt;
+	tlp->tb = readtb();
+	tlp->phase = (ms->msgphase << 4) + ms->phase;
+	tlp->bs0 = ms->mesh->bus_status0;
+	tlp->bs1 = ms->mesh->bus_status1;
+	tlp->tgt = ms->conn_tgt;
+	tlp->d = a;
+	*slp = *tlp;
+	if (++tp->log_ix >= N_DBG_LOG)
+		tp->log_ix = 0;
+	if (tp->n_log < N_DBG_LOG)
+		++tp->n_log;
+	if (++ms->log_ix >= N_DBG_SLOG)
+		ms->log_ix = 0;
+	if (ms->n_log < N_DBG_SLOG)
+		++ms->n_log;
 }
 
-static void
-set_mesh_power(struct mesh_state *ms, int state)
+static void dumplog(struct mesh_state *ms, int t)
 {
-	if (_machine != _MACH_Pmac)
-		return;
-	if (state) {
-		pmac_call_feature(PMAC_FTR_MESH_ENABLE, ms->ofnode, 0, 1);
-		mdelay(200);
-	} else {
-		pmac_call_feature(PMAC_FTR_MESH_ENABLE, ms->ofnode, 0, 0);
-		mdelay(10);
-	}
-}			
+	struct mesh_target *tp = &ms->tgts[t];
+	struct dbglog *lp;
+	int i;
 
-#ifdef CONFIG_PMAC_PBOOK
-/*
- * notify clients before sleep and reset bus afterwards
- */
-int
-mesh_notify_sleep(struct pmu_sleep_notifier *self, int when)
-{
-	struct mesh_state *ms;
-	
-	switch (when) {
-	case PBOOK_SLEEP_REQUEST:
-		/* XXX We should wait for current transactions and queue
-		 * new ones that would be posted beyond this point 
-		 */ 
-		break;
-	case PBOOK_SLEEP_REJECT:
-		break;
-		
-	case PBOOK_SLEEP_NOW:
-		for (ms = all_meshes; ms != 0; ms = ms->next) {
-			unsigned long flags;
-
-			scsi_block_requests(ms->host);
-			spin_lock_irqsave(ms->host->host_lock, flags);
-			while(ms->phase != idle) {
-				spin_unlock_irqrestore(ms->host->host_lock, flags);
-				current->state = TASK_UNINTERRUPTIBLE;
-				schedule_timeout(1);
-				spin_lock_irqsave(ms->host->host_lock, flags);
-			}
-			ms->phase = sleeping;
-			spin_unlock_irqrestore(ms->host->host_lock, flags);
-			disable_irq(ms->meshintr);
-			set_mesh_power(ms, 0);
-		}
-		break;
-	case PBOOK_WAKE:
-		for (ms = all_meshes; ms != 0; ms = ms->next) {
-			unsigned long flags;
-			
-			set_mesh_power(ms, 1);
-			mesh_init(ms);
-			spin_lock_irqsave(ms->host->host_lock, flags);
-			mesh_start(ms);
-			spin_unlock_irqrestore(ms->host->host_lock, flags);
-			enable_irq(ms->meshintr);
-			scsi_unblock_requests(ms->host);
-		}
-		break;
-	}
-	return PBOOK_SLEEP_OK;
+	if (tp->n_log == 0)
+		return;
+	i = tp->log_ix - tp->n_log;
+	if (i < 0)
+		i += N_DBG_LOG;
+	tp->n_log = 0;
+	do {
+		lp = &tp->log[i];
+		printk(KERN_DEBUG "mesh log %d: bs=%.2x%.2x ph=%.2x ",
+		       t, lp->bs1, lp->bs0, lp->phase);
+#ifdef DBG_USE_TB
+		printk("tb=%10u ", lp->tb);
+#endif
+		printk(lp->fmt, lp->d);
+		printk("\n");
+		if (++i >= N_DBG_LOG)
+			i = 0;
+	} while (i != tp->log_ix);
 }
-#endif /* CONFIG_PMAC_PBOOK */
 
-/*
- * Called by midlayer with host locked to queue a new
- * request
- */
-int
-mesh_queue(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+static void dumpslog(struct mesh_state *ms)
 {
-	struct mesh_state *ms;
-
-	cmd->scsi_done = done;
-	cmd->host_scribble = NULL;
-
-	ms = (struct mesh_state *) cmd->device->host->hostdata;
+	struct dbglog *lp;
+	int i;
 
-	if (ms->request_q == NULL)
-		ms->request_q = cmd;
-	else
-		ms->request_qtail->host_scribble = (void *) cmd;
-	ms->request_qtail = cmd;
+	if (ms->n_log == 0)
+		return;
+	i = ms->log_ix - ms->n_log;
+	if (i < 0)
+		i += N_DBG_SLOG;
+	ms->n_log = 0;
+	do {
+		lp = &ms->log[i];
+		printk(KERN_DEBUG "mesh log: bs=%.2x%.2x ph=%.2x t%d ",
+		       lp->bs1, lp->bs0, lp->phase, lp->tgt);
+#ifdef DBG_USE_TB
+		printk("tb=%10u ", lp->tb);
+#endif
+		printk(lp->fmt, lp->d);
+		printk("\n");
+		if (++i >= N_DBG_SLOG)
+			i = 0;
+	} while (i != ms->log_ix);
+}
 
-	if (ms->phase == idle)
-		mesh_start(ms);
+#else
 
-	return 0;
-}
+static inline void dlog(struct mesh_state *ms, char *fmt, int a)
+{}
+static inline void dumplog(struct mesh_state *ms, int tgt)
+{}
+static inline void dumpslog(struct mesh_state *ms)
+{}
 
-/* Todo: here we can at least try to remove the command from the
- * queue if it isn't connected yet, and for pending command, assert
- * ATN until the bus gets freed.
- */
-int
-mesh_abort(Scsi_Cmnd *cmd)
-{
-	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
+#endif /* MESH_DBG */
 
-	printk(KERN_DEBUG "mesh_abort(%p)\n", cmd);
-	mesh_dump_regs(ms);
-	dumplog(ms, cmd->device->id);
-	dumpslog(ms);
-	return SCSI_ABORT_SNOOZE;
-}
+#define MKWORD(a, b, c, d)	(((a) << 24) + ((b) << 16) + ((c) << 8) + (d))
 
 static void
 mesh_dump_regs(struct mesh_state *ms)
@@ -528,79 +331,35 @@ mesh_dump_regs(struct mesh_state *ms)
 	}
 }
 
+
 /*
- * Called by the midlayer with the lock held to reset the
- * SCSI host and bus.
- * The midlayer will wait for devices to come back, we don't need
- * to do that ourselves
+ * Flush write buffers on the bus path to the mesh
  */
-int
-mesh_host_reset(Scsi_Cmnd *cmd)
+static inline void mesh_flush_io(volatile struct mesh_regs *mr)
 {
-	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
-	volatile struct mesh_regs *mr = ms->mesh;
-	volatile struct dbdma_regs *md = ms->dma;
-
-	printk(KERN_DEBUG "mesh_host_reset\n");
-
-	/* Reset the controller & dbdma channel */
-	out_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);	/* stop dma */
-	out_8(&mr->exception, 0xff);	/* clear all exception bits */
-	out_8(&mr->error, 0xff);	/* clear all error bits */
-	out_8(&mr->sequence, SEQ_RESETMESH);
-	udelay(1);
-	out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
-	out_8(&mr->source_id, ms->host->this_id);
-	out_8(&mr->sel_timeout, 25);	/* 250ms */
-	out_8(&mr->sync_params, ASYNC_PARAMS);
-
-	/* Reset the bus */
-	out_8(&mr->bus_status1, BS1_RST);	/* assert RST */
-	udelay(30);			/* leave it on for >= 25us */
-	out_8(&mr->bus_status1, 0);	/* negate RST */
-
-	/* Complete pending commands */
-	handle_reset(ms);
-	
-	return SUCCESS;
+	(void)in_8(&mr->mesh_id);
 }
 
+
 /*
- * If we leave drives set for synchronous transfers (especially
- * CDROMs), and reboot to MacOS, it gets confused, poor thing.
- * So, on reboot we reset the SCSI bus.
+ * Complete a SCSI command
  */
-static int
-mesh_notify_reboot(struct notifier_block *this, unsigned long code, void *x)
+static void mesh_completed(struct mesh_state *ms, Scsi_Cmnd *cmd)
 {
-	struct mesh_state *ms;
-	volatile struct mesh_regs *mr;
-
-	if (code == SYS_DOWN) {
-		printk(KERN_INFO "resetting MESH scsi bus(es)\n");
-		for (ms = all_meshes; ms != 0; ms = ms->next) {
-			mr = ms->mesh;
-			out_8(&mr->intr_mask, 0);
-			out_8(&mr->interrupt,
-			      INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
-			out_8(&mr->bus_status1, BS1_RST);
-			udelay(30);
-			out_8(&mr->bus_status1, 0);
-		}
-	}
-	return NOTIFY_DONE;
+	(*cmd->scsi_done)(cmd);
 }
 
+
 /* Called with  meshinterrupt disabled, initialize the chipset
  * and eventually do the initial bus reset. The lock must not be
  * held since we can schedule.
  */
-static void
-mesh_init(struct mesh_state *ms)
+static void mesh_init(struct mesh_state *ms)
 {
 	volatile struct mesh_regs *mr = ms->mesh;
 	volatile struct dbdma_regs *md = ms->dma;
 
+	mesh_flush_io(mr);
 	udelay(100);
 
 	/* Reset controller */
@@ -608,6 +367,7 @@ mesh_init(struct mesh_state *ms)
 	out_8(&mr->exception, 0xff);	/* clear all exception bits */
 	out_8(&mr->error, 0xff);	/* clear all error bits */
 	out_8(&mr->sequence, SEQ_RESETMESH);
+	mesh_flush_io(mr);
 	udelay(10);
 	out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
 	out_8(&mr->source_id, ms->host->this_id);
@@ -619,8 +379,10 @@ mesh_init(struct mesh_state *ms)
 		
 		/* Reset bus */
 		out_8(&mr->bus_status1, BS1_RST);	/* assert RST */
+		mesh_flush_io(mr);
 		udelay(30);			/* leave it on for >= 25us */
 		out_8(&mr->bus_status1, 0);	/* negate RST */
+		mesh_flush_io(mr);
 
 		/* Wait for bus to come back */
 		current->state = TASK_UNINTERRUPTIBLE;
@@ -630,6 +392,7 @@ mesh_init(struct mesh_state *ms)
 	/* Reconfigure controller */
 	out_8(&mr->interrupt, 0xff);	/* clear all interrupt bits */
 	out_8(&mr->sequence, SEQ_FLUSHFIFO);
+	mesh_flush_io(mr);
 	udelay(1);
 	out_8(&mr->sync_params, ASYNC_PARAMS);
 	out_8(&mr->sequence, SEQ_ENBRESEL);
@@ -638,51 +401,15 @@ mesh_init(struct mesh_state *ms)
 	ms->msgphase = msg_none;
 }
 
-/*
- * Start the next command for a MESH.
- * Should be called with interrupts disabled.
- */
-static void
-mesh_start(struct mesh_state *ms)
+
+static void mesh_start_cmd(struct mesh_state *ms, Scsi_Cmnd *cmd)
 {
-	Scsi_Cmnd *cmd, *prev, *next;
-
-	if (ms->phase != idle || ms->current_req != NULL) {
-		printk(KERN_ERR "inappropriate mesh_start (phase=%d, ms=%p)",
-		       ms->phase, ms);
-		return;
-	}
-
-	while (ms->phase == idle) {
-		prev = NULL;
-		for (cmd = ms->request_q; ; cmd = (Scsi_Cmnd *) cmd->host_scribble) {
-			if (cmd == NULL)
-				return;
-			if (ms->tgts[cmd->device->id].current_req == NULL)
-				break;
-			prev = cmd;
-		}
-		next = (Scsi_Cmnd *) cmd->host_scribble;
-		if (prev == NULL)
-			ms->request_q = next;
-		else
-			prev->host_scribble = (void *) next;
-		if (next == NULL)
-			ms->request_qtail = prev;
-
-		mesh_start_cmd(ms, cmd);
-	}
-}
-
-static void
-mesh_start_cmd(struct mesh_state *ms, Scsi_Cmnd *cmd)
-{
-	volatile struct mesh_regs *mr = ms->mesh;
-	int t, id;
+	volatile struct mesh_regs *mr = ms->mesh;
+	int t, id;
 
 	id = cmd->device->id;
 	ms->current_req = cmd;
-	ms->tgts[id].data_goes_out = data_goes_out(cmd);
+	ms->tgts[id].data_goes_out = cmd->sc_data_direction == SCSI_DATA_WRITE;
 	ms->tgts[id].current_req = cmd;
 
 #if 1
@@ -720,9 +447,10 @@ mesh_start_cmd(struct mesh_state *ms, Sc
 	     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
 	out_8(&mr->interrupt, INT_CMDDONE);
 	out_8(&mr->sequence, SEQ_ENBRESEL);
+	mesh_flush_io(mr);
 	udelay(1);
 
-	if (mr->bus_status1 & (BS1_BSY | BS1_SEL)) {
+	if (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {
 		/*
 		 * Some other device has the bus or is arbitrating for it -
 		 * probably a target which is about to reselect us.
@@ -731,7 +459,7 @@ mesh_start_cmd(struct mesh_state *ms, Sc
 		     MKWORD(mr->interrupt, mr->exception,
 			    mr->error, mr->fifo_count));
 		for (t = 100; t > 0; --t) {
-			if ((mr->bus_status1 & (BS1_BSY | BS1_SEL)) == 0)
+			if ((in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) == 0)
 				break;
 			if (in_8(&mr->interrupt) != 0) {
 				dlog(ms, "intr b4 arb, intr/exc/err/fc=%.8x",
@@ -743,7 +471,7 @@ mesh_start_cmd(struct mesh_state *ms, Sc
 			}
 			udelay(1);
 		}
-		if (mr->bus_status1 & (BS1_BSY | BS1_SEL)) {
+		if (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {
 			/* XXX should try again in a little while */
 			ms->stat = DID_BUS_BUSY;
 			ms->phase = idle;
@@ -792,23 +520,25 @@ mesh_start_cmd(struct mesh_state *ms, Sc
 	}
 	dlog(ms, "after arb, intr/exc/err/fc=%.8x",
 	     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
-	if (mr->interrupt == 0 && (mr->bus_status1 & BS1_SEL)
-	    && (mr->bus_status0 & BS0_IO)) {
+	if (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)
+	    && (in_8(&mr->bus_status0) & BS0_IO)) {
 		/* looks like a reselection - try resetting the mesh */
 		dlog(ms, "resel? after arb, intr/exc/err/fc=%.8x",
 		     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
 		out_8(&mr->sequence, SEQ_RESETMESH);
+		mesh_flush_io(mr);
 		udelay(10);
 		out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
 		out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
 		out_8(&mr->sequence, SEQ_ENBRESEL);
-		for (t = 10; t > 0 && mr->interrupt == 0; --t)
+		mesh_flush_io(mr);
+		for (t = 10; t > 0 && in_8(&mr->interrupt) == 0; --t)
 			udelay(1);
 		dlog(ms, "tried reset after arb, intr/exc/err/fc=%.8x",
 		     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));
 #ifndef MESH_MULTIPLE_HOSTS
-		if (mr->interrupt == 0 && (mr->bus_status1 & BS1_SEL)
-		    && (mr->bus_status0 & BS0_IO)) {
+		if (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)
+		    && (in_8(&mr->bus_status0) & BS0_IO)) {
 			printk(KERN_ERR "mesh: controller not responding"
 			       " to reselection!\n");
 			/*
@@ -822,8 +552,76 @@ mesh_start_cmd(struct mesh_state *ms, Sc
 	}
 }
 
-static inline void
-add_sdtr_msg(struct mesh_state *ms)
+/*
+ * Start the next command for a MESH.
+ * Should be called with interrupts disabled.
+ */
+static void mesh_start(struct mesh_state *ms)
+{
+	Scsi_Cmnd *cmd, *prev, *next;
+
+	if (ms->phase != idle || ms->current_req != NULL) {
+		printk(KERN_ERR "inappropriate mesh_start (phase=%d, ms=%p)",
+		       ms->phase, ms);
+		return;
+	}
+
+	while (ms->phase == idle) {
+		prev = NULL;
+		for (cmd = ms->request_q; ; cmd = (Scsi_Cmnd *) cmd->host_scribble) {
+			if (cmd == NULL)
+				return;
+			if (ms->tgts[cmd->device->id].current_req == NULL)
+				break;
+			prev = cmd;
+		}
+		next = (Scsi_Cmnd *) cmd->host_scribble;
+		if (prev == NULL)
+			ms->request_q = next;
+		else
+			prev->host_scribble = (void *) next;
+		if (next == NULL)
+			ms->request_qtail = prev;
+
+		mesh_start_cmd(ms, cmd);
+	}
+}
+
+static void mesh_done(struct mesh_state *ms, int start_next)
+{
+	Scsi_Cmnd *cmd;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+
+	cmd = ms->current_req;
+	ms->current_req = 0;
+	tp->current_req = 0;
+	if (cmd) {
+		cmd->result = (ms->stat << 16) + cmd->SCp.Status;
+		if (ms->stat == DID_OK)
+			cmd->result += (cmd->SCp.Message << 8);
+		if (DEBUG_TARGET(cmd)) {
+			printk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",
+			       cmd->result, ms->data_ptr, cmd->request_bufflen);
+			if ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)
+			    && cmd->request_buffer != 0) {
+				unsigned char *b = cmd->request_buffer;
+				printk(KERN_DEBUG "buffer = %x %x %x %x %x %x %x %x\n",
+				       b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
+			}
+		}
+		cmd->SCp.this_residual -= ms->data_ptr;
+		mesh_completed(ms, cmd);
+	}
+	if (start_next) {
+		out_8(&ms->mesh->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(ms->mesh);
+		udelay(1);
+		ms->phase = idle;
+		mesh_start(ms);
+	}
+}
+
+static inline void add_sdtr_msg(struct mesh_state *ms)
 {
 	int i = ms->n_msgout;
 
@@ -835,8 +633,7 @@ add_sdtr_msg(struct mesh_state *ms)
 	ms->n_msgout = i + 5;
 }
 
-static void
-set_sdtr(struct mesh_state *ms, int period, int offset)
+static void set_sdtr(struct mesh_state *ms, int period, int offset)
 {
 	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
 	volatile struct mesh_regs *mr = ms->mesh;
@@ -877,8 +674,7 @@ set_sdtr(struct mesh_state *ms, int peri
 	       ms->conn_tgt, tr/10, tr%10);
 }
 
-static void
-start_phase(struct mesh_state *ms)
+static void start_phase(struct mesh_state *ms)
 {
 	int i, seq, nb;
 	volatile struct mesh_regs *mr = ms->mesh;
@@ -925,14 +721,16 @@ start_phase(struct mesh_state *ms)
 						ms->msgout[1], ms->msgout[2]));
 		out_8(&mr->count_hi, 0);
 		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
 		udelay(1);
 		/*
 		 * If ATN is not already asserted, we assert it, then
 		 * issue a SEQ_MSGOUT to get the mesh to drop ACK.
 		 */
-		if ((mr->bus_status0 & BS0_ATN) == 0) {
+		if ((in_8(&mr->bus_status0) & BS0_ATN) == 0) {
 			dlog(ms, "bus0 was %.2x explictly asserting ATN", mr->bus_status0);
 			out_8(&mr->bus_status0, BS0_ATN); /* explicit ATN */
+			mesh_flush_io(mr);
 			udelay(1);
 			out_8(&mr->count_lo, 1);
 			out_8(&mr->sequence, SEQ_MSGOUT + seq);
@@ -1006,6 +804,7 @@ start_phase(struct mesh_state *ms)
 	case busfreeing:
 	case disconnecting:
 		out_8(&mr->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(mr);
 		udelay(1);
 		dlog(ms, "enbresel intr/exc/err/fc=%.8x",
 		     MKWORD(mr->interrupt, mr->exception, mr->error,
@@ -1020,8 +819,7 @@ start_phase(struct mesh_state *ms)
 
 }
 
-static inline void
-get_msgin(struct mesh_state *ms)
+static inline void get_msgin(struct mesh_state *ms)
 {
 	volatile struct mesh_regs *mr = ms->mesh;
 	int i, n;
@@ -1035,8 +833,7 @@ get_msgin(struct mesh_state *ms)
 	}
 }
 
-static inline int
-msgin_length(struct mesh_state *ms)
+static inline int msgin_length(struct mesh_state *ms)
 {
 	int b, n;
 
@@ -1054,349 +851,95 @@ msgin_length(struct mesh_state *ms)
 	return n;
 }
 
-static void
-cmd_complete(struct mesh_state *ms)
+static void reselected(struct mesh_state *ms)
 {
 	volatile struct mesh_regs *mr = ms->mesh;
-	Scsi_Cmnd *cmd = ms->current_req;
-	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
-	int seq, n, t;
-
-	dlog(ms, "cmd_complete fc=%x", mr->fifo_count);
-	seq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);
-	switch (ms->msgphase) {
-	case msg_out_xxx:
-		/* huh?  we expected a phase mismatch */
-		ms->n_msgin = 0;
-		ms->msgphase = msg_in;
-		/* fall through */
+	Scsi_Cmnd *cmd;
+	struct mesh_target *tp;
+	int b, t, prev;
 
-	case msg_in:
-		/* should have some message bytes in fifo */
-		get_msgin(ms);
-		n = msgin_length(ms);
-		if (ms->n_msgin < n) {
-			out_8(&mr->count_lo, n - ms->n_msgin);
-			out_8(&mr->sequence, SEQ_MSGIN + seq);
-		} else {
-			ms->msgphase = msg_none;
-			handle_msgin(ms);
-			start_phase(ms);
+	switch (ms->phase) {
+	case idle:
+		break;
+	case arbitrating:
+		if ((cmd = ms->current_req) != NULL) {
+			/* put the command back on the queue */
+			cmd->host_scribble = (void *) ms->request_q;
+			if (ms->request_q == NULL)
+				ms->request_qtail = cmd;
+			ms->request_q = cmd;
+			tp = &ms->tgts[cmd->device->id];
+			tp->current_req = NULL;
 		}
 		break;
+	case busfreeing:
+		ms->phase = reselecting;
+		mesh_done(ms, 0);
+		break;
+	case disconnecting:
+		break;
+	default:
+		printk(KERN_ERR "mesh: reselected in phase %d/%d tgt %d\n",
+		       ms->msgphase, ms->phase, ms->conn_tgt);
+		dumplog(ms, ms->conn_tgt);
+		dumpslog(ms);
+	}
 
-	case msg_in_bad:
-		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+	if (ms->dma_started) {
+		printk(KERN_ERR "mesh: reselected with DMA started !\n");
+		halt_dma(ms);
+	}
+	ms->current_req = NULL;
+	ms->phase = dataing;
+	ms->msgphase = msg_in;
+	ms->n_msgout = 0;
+	ms->last_n_msgout = 0;
+	prev = ms->conn_tgt;
+
+	/*
+	 * We seem to get abortive reselections sometimes.
+	 */
+	while ((in_8(&mr->bus_status1) & BS1_BSY) == 0) {
+		static int mesh_aborted_resels;
+		mesh_aborted_resels++;
+		out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+		mesh_flush_io(mr);
 		udelay(1);
-		out_8(&mr->count_lo, 1);
-		out_8(&mr->sequence, SEQ_MSGIN + SEQ_ATN + use_active_neg);
-		break;
+		out_8(&mr->sequence, SEQ_ENBRESEL);
+		mesh_flush_io(mr);
+		udelay(5);
+		dlog(ms, "extra resel err/exc/fc = %.6x",
+		     MKWORD(0, mr->error, mr->exception, mr->fifo_count));
+	}
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sequence, SEQ_ENBRESEL);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->sync_params, ASYNC_PARAMS);
 
-	case msg_out:
-		/*
-		 * To get the right timing on ATN wrt ACK, we have
-		 * to get the MESH to drop ACK, wait until REQ gets
-		 * asserted, then drop ATN.  To do this we first
-		 * issue a SEQ_MSGOUT with ATN and wait for REQ,
-		 * then change the command to a SEQ_MSGOUT w/o ATN.
-		 * If we don't see REQ in a reasonable time, we
-		 * change the command to SEQ_MSGIN with ATN,
-		 * wait for the phase mismatch interrupt, then
-		 * issue the SEQ_MSGOUT without ATN.
-		 */
-		out_8(&mr->count_lo, 1);
-		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg + SEQ_ATN);
-		t = 30;		/* wait up to 30us */
-		while ((mr->bus_status0 & BS0_REQ) == 0 && --t >= 0)
-			udelay(1);
-		dlog(ms, "last_mbyte err/exc/fc/cl=%.8x",
-		     MKWORD(mr->error, mr->exception,
-			    mr->fifo_count, mr->count_lo));
-		if (in_8(&mr->interrupt) & (INT_ERROR | INT_EXCEPTION)) {
-			/* whoops, target didn't do what we expected */
-			ms->last_n_msgout = ms->n_msgout;
-			ms->n_msgout = 0;
-			if (in_8(&mr->interrupt) & INT_ERROR) {
-				printk(KERN_ERR "mesh: error %x in msg_out\n",
-				       in_8(&mr->error));
-				handle_error(ms);
-				return;
-			}
-			if (in_8(&mr->exception) != EXC_PHASEMM)
-				printk(KERN_ERR "mesh: exc %x in msg_out\n",
-				       in_8(&mr->exception));
-			else
-				printk(KERN_DEBUG "mesh: bs0=%x in msg_out\n",
-				       in_8(&mr->bus_status0));
-			handle_exception(ms);
-			return;
-		}
-		if (mr->bus_status0 & BS0_REQ) {
-			out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
-			udelay(1);
-			out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
-			ms->msgphase = msg_out_last;
-		} else {
-			out_8(&mr->sequence, SEQ_MSGIN + use_active_neg + SEQ_ATN);
-			ms->msgphase = msg_out_xxx;
-		}
-		break;
-
-	case msg_out_last:
-		ms->last_n_msgout = ms->n_msgout;
-		ms->n_msgout = 0;
-		ms->msgphase = ms->expect_reply? msg_in: msg_none;
-		start_phase(ms);
-		break;
-
-	case msg_none:
-		switch (ms->phase) {
-		case idle:
-			printk(KERN_ERR "mesh: interrupt in idle phase?\n");
-			dumpslog(ms);
-			return;
-		case selecting:
-			dlog(ms, "Selecting phase at command completion",0);
-			ms->msgout[0] = IDENTIFY(ALLOW_RESEL(ms->conn_tgt),
-						 (cmd? cmd->device->lun: 0));
-			ms->n_msgout = 1;
-			ms->expect_reply = 0;
-			if (ms->aborting) {
-				ms->msgout[0] = ABORT;
-				ms->n_msgout++;
-			} else if (tp->sdtr_state == do_sdtr) {
-				/* add SDTR message */
-				add_sdtr_msg(ms);
-				ms->expect_reply = 1;
-				tp->sdtr_state = sdtr_sent;
-			}
-			ms->msgphase = msg_out;
-			/*
-			 * We need to wait for REQ before dropping ATN.
-			 * We wait for at most 30us, then fall back to
-			 * a scheme where we issue a SEQ_COMMAND with ATN,
-			 * which will give us a phase mismatch interrupt
-			 * when REQ does come, and then we send the message.
-			 */
-			t = 230;		/* wait up to 230us */
-			while ((mr->bus_status0 & BS0_REQ) == 0) {
-				if (--t < 0) {
-					dlog(ms, "impatient for req", ms->n_msgout);
-					ms->msgphase = msg_none;
-					break;
-				}
-				udelay(1);
-			}
-			break;
-		case dataing:
-			if (ms->dma_count != 0) {
-				start_phase(ms);
-				return;
-			}
-			/*
-			 * We can get a phase mismatch here if the target
-			 * changes to the status phase, even though we have
-			 * had a command complete interrupt.  Then, if we
-			 * issue the SEQ_STATUS command, we'll get a sequence
-			 * error interrupt.  Which isn't so bad except that
-			 * occasionally the mesh actually executes the
-			 * SEQ_STATUS *as well as* giving us the sequence
-			 * error and phase mismatch exception.
-			 */
-			out_8(&mr->sequence, 0);
-			out_8(&mr->interrupt,
-			      INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
-			halt_dma(ms);
-			break;
-		case statusing:
-			if (cmd) {
-				cmd->SCp.Status = mr->fifo;
-				if (DEBUG_TARGET(cmd))
-					printk(KERN_DEBUG "mesh: status is %x\n",
-					       cmd->SCp.Status);
-			}
-			ms->msgphase = msg_in;
-			break;
-		case busfreeing:
-			mesh_done(ms, 1);
-			return;
-		case disconnecting:
-			ms->current_req = 0;
-			ms->phase = idle;
-			mesh_start(ms);
-			return;
-		default:
-			break;
-		}
-		++ms->phase;
-		start_phase(ms);
-		break;
-	}
-}
-
-static void phase_mismatch(struct mesh_state *ms)
-{
-	volatile struct mesh_regs *mr = ms->mesh;
-	int phase;
-
-	dlog(ms, "phasemm ch/cl/seq/fc=%.8x",
-	     MKWORD(mr->count_hi, mr->count_lo, mr->sequence, mr->fifo_count));
-	phase = mr->bus_status0 & BS0_PHASE;
-	if (ms->msgphase == msg_out_xxx && phase == BP_MSGOUT) {
-		/* output the last byte of the message, without ATN */
-		out_8(&mr->count_lo, 1);
-		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
-		udelay(1);
-		out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
-		ms->msgphase = msg_out_last;
-		return;
-	}
-
-	if (ms->msgphase == msg_in) {
-		get_msgin(ms);
-		if (ms->n_msgin)
-			handle_msgin(ms);
-	}
-
-	if (ms->dma_started)
-		halt_dma(ms);
-	if (mr->fifo_count) {
-		out_8(&mr->sequence, SEQ_FLUSHFIFO);
-		udelay(1);
-	}
-
-	ms->msgphase = msg_none;
-	switch (phase) {
-	case BP_DATAIN:
-		ms->tgts[ms->conn_tgt].data_goes_out = 0;
-		ms->phase = dataing;
-		break;
-	case BP_DATAOUT:
-		ms->tgts[ms->conn_tgt].data_goes_out = 1;
-		ms->phase = dataing;
-		break;
-	case BP_COMMAND:
-		ms->phase = commanding;
-		break;
-	case BP_STATUS:
-		ms->phase = statusing;
-		break;
-	case BP_MSGIN:
-		ms->msgphase = msg_in;
-		ms->n_msgin = 0;
-		break;
-	case BP_MSGOUT:
-		ms->msgphase = msg_out;
-		if (ms->n_msgout == 0) {
-			if (ms->aborting) {
-				do_abort(ms);
-			} else {
-				if (ms->last_n_msgout == 0) {
-					printk(KERN_DEBUG
-					       "mesh: no msg to repeat\n");
-					ms->msgout[0] = NOP;
-					ms->last_n_msgout = 1;
-				}
-				ms->n_msgout = ms->last_n_msgout;
-			}
-		}
-		break;
-	default:
-		printk(KERN_DEBUG "mesh: unknown scsi phase %x\n", phase);
-		ms->stat = DID_ERROR;
-		mesh_done(ms, 1);
-		return;
-	}
-
-	start_phase(ms);
-}
-
-static void
-reselected(struct mesh_state *ms)
-{
-	volatile struct mesh_regs *mr = ms->mesh;
-	Scsi_Cmnd *cmd;
-	struct mesh_target *tp;
-	int b, t, prev;
-
-	switch (ms->phase) {
-	case idle:
-		break;
-	case arbitrating:
-		if ((cmd = ms->current_req) != NULL) {
-			/* put the command back on the queue */
-			cmd->host_scribble = (void *) ms->request_q;
-			if (ms->request_q == NULL)
-				ms->request_qtail = cmd;
-			ms->request_q = cmd;
-			tp = &ms->tgts[cmd->device->id];
-			tp->current_req = NULL;
-		}
-		break;
-	case busfreeing:
-		ms->phase = reselecting;
-		mesh_done(ms, 0);
-		break;
-	case disconnecting:
-		break;
-	default:
-		printk(KERN_ERR "mesh: reselected in phase %d/%d tgt %d\n",
-		       ms->msgphase, ms->phase, ms->conn_tgt);
-		dumplog(ms, ms->conn_tgt);
-		dumpslog(ms);
-	}
-
-	if (ms->dma_started) {
-		printk(KERN_ERR "mesh: reselected with DMA started !\n");
-		halt_dma(ms);
-	}
-	ms->current_req = NULL;
-	ms->phase = dataing;
-	ms->msgphase = msg_in;
-	ms->n_msgout = 0;
-	ms->last_n_msgout = 0;
-	prev = ms->conn_tgt;
-
-	/*
-	 * We seem to get abortive reselections sometimes.
-	 */
-	while ((mr->bus_status1 & BS1_BSY) == 0) {
-		static int mesh_aborted_resels;
-		mesh_aborted_resels++;
-		out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
-		udelay(1);
-		out_8(&mr->sequence, SEQ_ENBRESEL);
-		udelay(5);
-		dlog(ms, "extra resel err/exc/fc = %.6x",
-		     MKWORD(0, mr->error, mr->exception, mr->fifo_count));
-	}
-	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
-	udelay(1);
-	out_8(&mr->sequence, SEQ_ENBRESEL);
-	udelay(1);
-	out_8(&mr->sync_params, ASYNC_PARAMS);
-
-	/*
-	 * Find out who reselected us.
-	 */
-	if (mr->fifo_count == 0) {
-		printk(KERN_ERR "mesh: reselection but nothing in fifo?\n");
-		ms->conn_tgt = ms->host->this_id;
-		goto bogus;
-	}
-	/* get the last byte in the fifo */
-	do {
-		b = in_8(&mr->fifo);
-		dlog(ms, "reseldata %x", b);
-	} while (in_8(&mr->fifo_count));
-	for (t = 0; t < 8; ++t)
-		if ((b & (1 << t)) != 0 && t != ms->host->this_id)
-			break;
-	if (b != (1 << t) + (1 << ms->host->this_id)) {
-		printk(KERN_ERR "mesh: bad reselection data %x\n", b);
-		ms->conn_tgt = ms->host->this_id;
-		goto bogus;
-	}
+	/*
+	 * Find out who reselected us.
+	 */
+	if (in_8(&mr->fifo_count) == 0) {
+		printk(KERN_ERR "mesh: reselection but nothing in fifo?\n");
+		ms->conn_tgt = ms->host->this_id;
+		goto bogus;
+	}
+	/* get the last byte in the fifo */
+	do {
+		b = in_8(&mr->fifo);
+		dlog(ms, "reseldata %x", b);
+	} while (in_8(&mr->fifo_count));
+	for (t = 0; t < 8; ++t)
+		if ((b & (1 << t)) != 0 && t != ms->host->this_id)
+			break;
+	if (b != (1 << t) + (1 << ms->host->this_id)) {
+		printk(KERN_ERR "mesh: bad reselection data %x\n", b);
+		ms->conn_tgt = ms->host->this_id;
+		goto bogus;
+	}
 
 
 	/*
@@ -1438,8 +981,7 @@ static void do_abort(struct mesh_state *
 	dlog(ms, "abort", 0);
 }
 
-static void
-handle_reset(struct mesh_state *ms)
+static void handle_reset(struct mesh_state *ms)
 {
 	int tgt;
 	struct mesh_target *tp;
@@ -1466,13 +1008,13 @@ handle_reset(struct mesh_state *ms)
 	ms->msgphase = msg_none;
 	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
 	out_8(&mr->sequence, SEQ_FLUSHFIFO);
+       	mesh_flush_io(mr);
 	udelay(1);
 	out_8(&mr->sync_params, ASYNC_PARAMS);
 	out_8(&mr->sequence, SEQ_ENBRESEL);
 }
 
-static irqreturn_t
-do_mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static irqreturn_t do_mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
 {
 	unsigned long flags;
 	struct Scsi_Host *dev = ((struct mesh_state *)dev_id)->host;
@@ -1497,7 +1039,7 @@ static void handle_error(struct mesh_sta
 		/* SCSI bus was reset */
 		printk(KERN_INFO "mesh: SCSI bus reset detected: "
 		       "waiting for end...");
-		while ((mr->bus_status1 & BS1_RST) != 0)
+		while ((in_8(&mr->bus_status1) & BS1_RST) != 0)
 			udelay(1);
 		printk("done\n");
 		handle_reset(ms);
@@ -1567,7 +1109,7 @@ static void handle_error(struct mesh_sta
 	}
 	mesh_dump_regs(ms);
 	dumplog(ms, ms->conn_tgt);
-	if (ms->phase > selecting && (mr->bus_status1 & BS1_BSY)) {
+	if (ms->phase > selecting && (in_8(&mr->bus_status1) & BS1_BSY)) {
 		/* try to do what the target wants */
 		do_abort(ms);
 		phase_mismatch(ms);
@@ -1609,40 +1151,11 @@ static void handle_exception(struct mesh
 	}
 }
 
-static void
-mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+static void handle_msgin(struct mesh_state *ms)
 {
-	struct mesh_state *ms = (struct mesh_state *) dev_id;
-	volatile struct mesh_regs *mr = ms->mesh;
-	int intr;
-
-#if 0
-	if (ALLOW_DEBUG(ms->conn_tgt))
-		printk(KERN_DEBUG "mesh_intr, bs0=%x int=%x exc=%x err=%x "
-		       "phase=%d msgphase=%d\n", mr->bus_status0,
-		       mr->interrupt, mr->exception, mr->error,
-		       ms->phase, ms->msgphase);
-#endif
-	while ((intr = in_8(&mr->interrupt)) != 0) {
-		dlog(ms, "interrupt intr/err/exc/seq=%.8x", 
-		     MKWORD(intr, mr->error, mr->exception, mr->sequence));
-		if (intr & INT_ERROR) {
-			handle_error(ms);
-		} else if (intr & INT_EXCEPTION) {
-			handle_exception(ms);
-		} else if (intr & INT_CMDDONE) {
-			out_8(&mr->interrupt, INT_CMDDONE);
-			cmd_complete(ms);
-		}
-	}
-}
-
-static void
-handle_msgin(struct mesh_state *ms)
-{
-	int i, code;
-	Scsi_Cmnd *cmd = ms->current_req;
-	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	int i, code;
+	Scsi_Cmnd *cmd = ms->current_req;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
 
 	if (ms->n_msgin == 0)
 		return;
@@ -1736,51 +1249,10 @@ handle_msgin(struct mesh_state *ms)
 	ms->msgphase = msg_out;
 }
 
-static void
-mesh_done(struct mesh_state *ms, int start_next)
-{
-	Scsi_Cmnd *cmd;
-	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
-
-	cmd = ms->current_req;
-	ms->current_req = 0;
-	tp->current_req = 0;
-	if (cmd) {
-		cmd->result = (ms->stat << 16) + cmd->SCp.Status;
-		if (ms->stat == DID_OK)
-			cmd->result += (cmd->SCp.Message << 8);
-		if (DEBUG_TARGET(cmd)) {
-			printk(KERN_DEBUG "mesh_done: result = %x, data_ptr=%d, buflen=%d\n",
-			       cmd->result, ms->data_ptr, cmd->request_bufflen);
-			if ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)
-			    && cmd->request_buffer != 0) {
-				unsigned char *b = cmd->request_buffer;
-				printk(KERN_DEBUG "buffer = %x %x %x %x %x %x %x %x\n",
-				       b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
-			}
-		}
-		cmd->SCp.this_residual -= ms->data_ptr;
-		mesh_completed(ms, cmd);
-	}
-	if (start_next) {
-		out_8(&ms->mesh->sequence, SEQ_ENBRESEL);
-		udelay(1);
-		ms->phase = idle;
-		mesh_start(ms);
-	}
-}
-
-static void
-mesh_completed(struct mesh_state *ms, Scsi_Cmnd *cmd)
-{
-	(*cmd->scsi_done)(cmd);
-}
-
 /*
  * Set up DMA commands for transferring data.
  */
-static void
-set_dma_cmds(struct mesh_state *ms, Scsi_Cmnd *cmd)
+static void set_dma_cmds(struct mesh_state *ms, Scsi_Cmnd *cmd)
 {
 	int i, dma_cmd, total, off, dtot;
 	struct scatterlist *scl;
@@ -1848,8 +1320,7 @@ set_dma_cmds(struct mesh_state *ms, Scsi
 	ms->dma_count = dtot;
 }
 
-static void
-halt_dma(struct mesh_state *ms)
+static void halt_dma(struct mesh_state *ms)
 {
 	volatile struct dbdma_regs *md = ms->dma;
 	volatile struct mesh_regs *mr = ms->mesh;
@@ -1859,7 +1330,7 @@ halt_dma(struct mesh_state *ms)
 	if (!ms->tgts[ms->conn_tgt].data_goes_out) {
 		/* wait a little while until the fifo drains */
 		t = 50;
-		while (t > 0 && mr->fifo_count != 0
+		while (t > 0 && in_8(&mr->fifo_count) != 0
 		       && (in_le32(&md->status) & ACTIVE) != 0) {
 			--t;
 			udelay(1);
@@ -1899,162 +1370,697 @@ halt_dma(struct mesh_state *ms)
 	ms->dma_started = 0;
 }
 
-/*
- * Work out whether we expect data to go out from the host adaptor or into it.
- */
-static int
-data_goes_out(Scsi_Cmnd *cmd)
+static void phase_mismatch(struct mesh_state *ms)
 {
-	switch (cmd->sc_data_direction) {
-	case SCSI_DATA_WRITE:
-		return 1;
-	case SCSI_DATA_READ:
-		return 0;
-	}
+	volatile struct mesh_regs *mr = ms->mesh;
+	int phase;
 
-	/* for SCSI_DATA_UNKNOWN or SCSI_DATA_NONE, fall back on the
-	   old method for now... */
-	switch (cmd->cmnd[0]) {
-	case CHANGE_DEFINITION: 
-	case COMPARE:	  
-	case COPY:
-	case COPY_VERIFY:	    
-	case FORMAT_UNIT:	 
-	case LOG_SELECT:
-	case MEDIUM_SCAN:	  
-	case MODE_SELECT:
-	case MODE_SELECT_10:
-	case REASSIGN_BLOCKS: 
-	case RESERVE:
-	case SEARCH_EQUAL:	  
-	case SEARCH_EQUAL_12: 
-	case SEARCH_HIGH:	 
-	case SEARCH_HIGH_12:  
-	case SEARCH_LOW:
-	case SEARCH_LOW_12:
-	case SEND_DIAGNOSTIC: 
-	case SEND_VOLUME_TAG:	     
-	case SET_WINDOW: 
-	case UPDATE_BLOCK:	
-	case WRITE_BUFFER:
- 	case WRITE_6:	
-	case WRITE_10:	
-	case WRITE_12:	  
-	case WRITE_LONG:	
-	case WRITE_LONG_2:      /* alternate code for WRITE_LONG */
-	case WRITE_SAME:	
-	case WRITE_VERIFY:
-	case WRITE_VERIFY_12:
-		return 1;
-	default:
-		return 0;
+	dlog(ms, "phasemm ch/cl/seq/fc=%.8x",
+	     MKWORD(mr->count_hi, mr->count_lo, mr->sequence, mr->fifo_count));
+	phase = in_8(&mr->bus_status0) & BS0_PHASE;
+	if (ms->msgphase == msg_out_xxx && phase == BP_MSGOUT) {
+		/* output the last byte of the message, without ATN */
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
+		mesh_flush_io(mr);
+		udelay(1);
+		out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
+		ms->msgphase = msg_out_last;
+		return;
 	}
-}
 
-#ifdef MESH_DBG
-static inline u32 readtb(void)
-{
-	u32 tb;
+	if (ms->msgphase == msg_in) {
+		get_msgin(ms);
+		if (ms->n_msgin)
+			handle_msgin(ms);
+	}
 
-#ifdef DBG_USE_TB
-	/* Beware: if you enable this, it will crash on 601s. */
-	asm ("mftb %0" : "=r" (tb) : );
-#else
-	tb = 0;
-#endif
-	return tb;
-}
+	if (ms->dma_started)
+		halt_dma(ms);
+	if (mr->fifo_count) {
+		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
+		udelay(1);
+	}
 
-static void dlog(struct mesh_state *ms, char *fmt, int a)
-{
-	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
-	struct dbglog *tlp, *slp;
+	ms->msgphase = msg_none;
+	switch (phase) {
+	case BP_DATAIN:
+		ms->tgts[ms->conn_tgt].data_goes_out = 0;
+		ms->phase = dataing;
+		break;
+	case BP_DATAOUT:
+		ms->tgts[ms->conn_tgt].data_goes_out = 1;
+		ms->phase = dataing;
+		break;
+	case BP_COMMAND:
+		ms->phase = commanding;
+		break;
+	case BP_STATUS:
+		ms->phase = statusing;
+		break;
+	case BP_MSGIN:
+		ms->msgphase = msg_in;
+		ms->n_msgin = 0;
+		break;
+	case BP_MSGOUT:
+		ms->msgphase = msg_out;
+		if (ms->n_msgout == 0) {
+			if (ms->aborting) {
+				do_abort(ms);
+			} else {
+				if (ms->last_n_msgout == 0) {
+					printk(KERN_DEBUG
+					       "mesh: no msg to repeat\n");
+					ms->msgout[0] = NOP;
+					ms->last_n_msgout = 1;
+				}
+				ms->n_msgout = ms->last_n_msgout;
+			}
+		}
+		break;
+	default:
+		printk(KERN_DEBUG "mesh: unknown scsi phase %x\n", phase);
+		ms->stat = DID_ERROR;
+		mesh_done(ms, 1);
+		return;
+	}
 
-	tlp = &tp->log[tp->log_ix];
-	slp = &ms->log[ms->log_ix];
-	tlp->fmt = fmt;
-	tlp->tb = readtb();
-	tlp->phase = (ms->msgphase << 4) + ms->phase;
-	tlp->bs0 = ms->mesh->bus_status0;
-	tlp->bs1 = ms->mesh->bus_status1;
-	tlp->tgt = ms->conn_tgt;
-	tlp->d = a;
-	*slp = *tlp;
-	if (++tp->log_ix >= N_DBG_LOG)
-		tp->log_ix = 0;
-	if (tp->n_log < N_DBG_LOG)
-		++tp->n_log;
-	if (++ms->log_ix >= N_DBG_SLOG)
-		ms->log_ix = 0;
-	if (ms->n_log < N_DBG_SLOG)
-		++ms->n_log;
+	start_phase(ms);
 }
 
-static void dumplog(struct mesh_state *ms, int t)
+static void cmd_complete(struct mesh_state *ms)
 {
-	struct mesh_target *tp = &ms->tgts[t];
-	struct dbglog *lp;
-	int i;
+	volatile struct mesh_regs *mr = ms->mesh;
+	Scsi_Cmnd *cmd = ms->current_req;
+	struct mesh_target *tp = &ms->tgts[ms->conn_tgt];
+	int seq, n, t;
 
-	if (tp->n_log == 0)
-		return;
-	i = tp->log_ix - tp->n_log;
-	if (i < 0)
-		i += N_DBG_LOG;
-	tp->n_log = 0;
-	do {
-		lp = &tp->log[i];
-		printk(KERN_DEBUG "mesh log %d: bs=%.2x%.2x ph=%.2x ",
-		       t, lp->bs1, lp->bs0, lp->phase);
-#ifdef DBG_USE_TB
-		printk("tb=%10u ", lp->tb);
-#endif
-		printk(lp->fmt, lp->d);
-		printk("\n");
-		if (++i >= N_DBG_LOG)
-			i = 0;
-	} while (i != tp->log_ix);
-}
+	dlog(ms, "cmd_complete fc=%x", mr->fifo_count);
+	seq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);
+	switch (ms->msgphase) {
+	case msg_out_xxx:
+		/* huh?  we expected a phase mismatch */
+		ms->n_msgin = 0;
+		ms->msgphase = msg_in;
+		/* fall through */
 
-static void dumpslog(struct mesh_state *ms)
-{
-	struct dbglog *lp;
-	int i;
+	case msg_in:
+		/* should have some message bytes in fifo */
+		get_msgin(ms);
+		n = msgin_length(ms);
+		if (ms->n_msgin < n) {
+			out_8(&mr->count_lo, n - ms->n_msgin);
+			out_8(&mr->sequence, SEQ_MSGIN + seq);
+		} else {
+			ms->msgphase = msg_none;
+			handle_msgin(ms);
+			start_phase(ms);
+		}
+		break;
 
-	if (ms->n_log == 0)
-		return;
-	i = ms->log_ix - ms->n_log;
-	if (i < 0)
-		i += N_DBG_SLOG;
-	ms->n_log = 0;
-	do {
-		lp = &ms->log[i];
-		printk(KERN_DEBUG "mesh log: bs=%.2x%.2x ph=%.2x t%d ",
-		       lp->bs1, lp->bs0, lp->phase, lp->tgt);
-#ifdef DBG_USE_TB
-		printk("tb=%10u ", lp->tb);
-#endif
-		printk(lp->fmt, lp->d);
-		printk("\n");
-		if (++i >= N_DBG_SLOG)
-			i = 0;
-	} while (i != ms->log_ix);
-}
-#endif /* MESH_DBG */
+	case msg_in_bad:
+		out_8(&mr->sequence, SEQ_FLUSHFIFO);
+		mesh_flush_io(mr);
+		udelay(1);
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGIN + SEQ_ATN + use_active_neg);
+		break;
 
-static Scsi_Host_Template driver_template = {
-	.proc_name			= "mesh",
-	.name				= "MESH",
-	.detect				= mesh_detect,
-	.release			= mesh_release,
-	.queuecommand			= mesh_queue,
-	.eh_abort_handler		= mesh_abort,
-	.eh_host_reset_handler		= mesh_host_reset,
-	.can_queue			= 20,
-	.this_id			= 7,
-	.sg_tablesize			= SG_ALL,
+	case msg_out:
+		/*
+		 * To get the right timing on ATN wrt ACK, we have
+		 * to get the MESH to drop ACK, wait until REQ gets
+		 * asserted, then drop ATN.  To do this we first
+		 * issue a SEQ_MSGOUT with ATN and wait for REQ,
+		 * then change the command to a SEQ_MSGOUT w/o ATN.
+		 * If we don't see REQ in a reasonable time, we
+		 * change the command to SEQ_MSGIN with ATN,
+		 * wait for the phase mismatch interrupt, then
+		 * issue the SEQ_MSGOUT without ATN.
+		 */
+		out_8(&mr->count_lo, 1);
+		out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg + SEQ_ATN);
+		t = 30;		/* wait up to 30us */
+		while ((in_8(&mr->bus_status0) & BS0_REQ) == 0 && --t >= 0)
+			udelay(1);
+		dlog(ms, "last_mbyte err/exc/fc/cl=%.8x",
+		     MKWORD(mr->error, mr->exception,
+			    mr->fifo_count, mr->count_lo));
+		if (in_8(&mr->interrupt) & (INT_ERROR | INT_EXCEPTION)) {
+			/* whoops, target didn't do what we expected */
+			ms->last_n_msgout = ms->n_msgout;
+			ms->n_msgout = 0;
+			if (in_8(&mr->interrupt) & INT_ERROR) {
+				printk(KERN_ERR "mesh: error %x in msg_out\n",
+				       in_8(&mr->error));
+				handle_error(ms);
+				return;
+			}
+			if (in_8(&mr->exception) != EXC_PHASEMM)
+				printk(KERN_ERR "mesh: exc %x in msg_out\n",
+				       in_8(&mr->exception));
+			else
+				printk(KERN_DEBUG "mesh: bs0=%x in msg_out\n",
+				       in_8(&mr->bus_status0));
+			handle_exception(ms);
+			return;
+		}
+		if (in_8(&mr->bus_status0) & BS0_REQ) {
+			out_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);
+			mesh_flush_io(mr);
+			udelay(1);
+			out_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);
+			ms->msgphase = msg_out_last;
+		} else {
+			out_8(&mr->sequence, SEQ_MSGIN + use_active_neg + SEQ_ATN);
+			ms->msgphase = msg_out_xxx;
+		}
+		break;
+
+	case msg_out_last:
+		ms->last_n_msgout = ms->n_msgout;
+		ms->n_msgout = 0;
+		ms->msgphase = ms->expect_reply? msg_in: msg_none;
+		start_phase(ms);
+		break;
+
+	case msg_none:
+		switch (ms->phase) {
+		case idle:
+			printk(KERN_ERR "mesh: interrupt in idle phase?\n");
+			dumpslog(ms);
+			return;
+		case selecting:
+			dlog(ms, "Selecting phase at command completion",0);
+			ms->msgout[0] = IDENTIFY(ALLOW_RESEL(ms->conn_tgt),
+						 (cmd? cmd->device->lun: 0));
+			ms->n_msgout = 1;
+			ms->expect_reply = 0;
+			if (ms->aborting) {
+				ms->msgout[0] = ABORT;
+				ms->n_msgout++;
+			} else if (tp->sdtr_state == do_sdtr) {
+				/* add SDTR message */
+				add_sdtr_msg(ms);
+				ms->expect_reply = 1;
+				tp->sdtr_state = sdtr_sent;
+			}
+			ms->msgphase = msg_out;
+			/*
+			 * We need to wait for REQ before dropping ATN.
+			 * We wait for at most 30us, then fall back to
+			 * a scheme where we issue a SEQ_COMMAND with ATN,
+			 * which will give us a phase mismatch interrupt
+			 * when REQ does come, and then we send the message.
+			 */
+			t = 230;		/* wait up to 230us */
+			while ((in_8(&mr->bus_status0) & BS0_REQ) == 0) {
+				if (--t < 0) {
+					dlog(ms, "impatient for req", ms->n_msgout);
+					ms->msgphase = msg_none;
+					break;
+				}
+				udelay(1);
+			}
+			break;
+		case dataing:
+			if (ms->dma_count != 0) {
+				start_phase(ms);
+				return;
+			}
+			/*
+			 * We can get a phase mismatch here if the target
+			 * changes to the status phase, even though we have
+			 * had a command complete interrupt.  Then, if we
+			 * issue the SEQ_STATUS command, we'll get a sequence
+			 * error interrupt.  Which isn't so bad except that
+			 * occasionally the mesh actually executes the
+			 * SEQ_STATUS *as well as* giving us the sequence
+			 * error and phase mismatch exception.
+			 */
+			out_8(&mr->sequence, 0);
+			out_8(&mr->interrupt,
+			      INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+			halt_dma(ms);
+			break;
+		case statusing:
+			if (cmd) {
+				cmd->SCp.Status = mr->fifo;
+				if (DEBUG_TARGET(cmd))
+					printk(KERN_DEBUG "mesh: status is %x\n",
+					       cmd->SCp.Status);
+			}
+			ms->msgphase = msg_in;
+			break;
+		case busfreeing:
+			mesh_done(ms, 1);
+			return;
+		case disconnecting:
+			ms->current_req = 0;
+			ms->phase = idle;
+			mesh_start(ms);
+			return;
+		default:
+			break;
+		}
+		++ms->phase;
+		start_phase(ms);
+		break;
+	}
+}
+
+
+/*
+ * Called by midlayer with host locked to queue a new
+ * request
+ */
+static int mesh_queue(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	struct mesh_state *ms;
+
+	cmd->scsi_done = done;
+	cmd->host_scribble = NULL;
+
+	ms = (struct mesh_state *) cmd->device->host->hostdata;
+
+	if (ms->request_q == NULL)
+		ms->request_q = cmd;
+	else
+		ms->request_qtail->host_scribble = (void *) cmd;
+	ms->request_qtail = cmd;
+
+	if (ms->phase == idle)
+		mesh_start(ms);
+
+	return 0;
+}
+
+/*
+ * Called to handle interrupts, either call by the interrupt
+ * handler (do_mesh_interrupt) or by other functions in
+ * exceptional circumstances
+ */
+static void mesh_interrupt(int irq, void *dev_id, struct pt_regs *ptregs)
+{
+	struct mesh_state *ms = (struct mesh_state *) dev_id;
+	volatile struct mesh_regs *mr = ms->mesh;
+	int intr;
+
+#if 0
+	if (ALLOW_DEBUG(ms->conn_tgt))
+		printk(KERN_DEBUG "mesh_intr, bs0=%x int=%x exc=%x err=%x "
+		       "phase=%d msgphase=%d\n", mr->bus_status0,
+		       mr->interrupt, mr->exception, mr->error,
+		       ms->phase, ms->msgphase);
+#endif
+	while ((intr = in_8(&mr->interrupt)) != 0) {
+		dlog(ms, "interrupt intr/err/exc/seq=%.8x", 
+		     MKWORD(intr, mr->error, mr->exception, mr->sequence));
+		if (intr & INT_ERROR) {
+			handle_error(ms);
+		} else if (intr & INT_EXCEPTION) {
+			handle_exception(ms);
+		} else if (intr & INT_CMDDONE) {
+			out_8(&mr->interrupt, INT_CMDDONE);
+			cmd_complete(ms);
+		}
+	}
+}
+
+/* Todo: here we can at least try to remove the command from the
+ * queue if it isn't connected yet, and for pending command, assert
+ * ATN until the bus gets freed.
+ */
+static int mesh_abort(Scsi_Cmnd *cmd)
+{
+	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
+
+	printk(KERN_DEBUG "mesh_abort(%p)\n", cmd);
+	mesh_dump_regs(ms);
+	dumplog(ms, cmd->device->id);
+	dumpslog(ms);
+	return SCSI_ABORT_SNOOZE;
+}
+
+/*
+ * Called by the midlayer with the lock held to reset the
+ * SCSI host and bus.
+ * The midlayer will wait for devices to come back, we don't need
+ * to do that ourselves
+ */
+static int mesh_host_reset(Scsi_Cmnd *cmd)
+{
+	struct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;
+	volatile struct mesh_regs *mr = ms->mesh;
+	volatile struct dbdma_regs *md = ms->dma;
+
+	printk(KERN_DEBUG "mesh_host_reset\n");
+
+	/* Reset the controller & dbdma channel */
+	out_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);	/* stop dma */
+	out_8(&mr->exception, 0xff);	/* clear all exception bits */
+	out_8(&mr->error, 0xff);	/* clear all error bits */
+	out_8(&mr->sequence, SEQ_RESETMESH);
+       	mesh_flush_io(mr);
+	udelay(1);
+	out_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->source_id, ms->host->this_id);
+	out_8(&mr->sel_timeout, 25);	/* 250ms */
+	out_8(&mr->sync_params, ASYNC_PARAMS);
+
+	/* Reset the bus */
+	out_8(&mr->bus_status1, BS1_RST);	/* assert RST */
+       	mesh_flush_io(mr);
+	udelay(30);			/* leave it on for >= 25us */
+	out_8(&mr->bus_status1, 0);	/* negate RST */
+
+	/* Complete pending commands */
+	handle_reset(ms);
+	
+	return SUCCESS;
+}
+
+static void set_mesh_power(struct mesh_state *ms, int state)
+{
+	if (_machine != _MACH_Pmac)
+		return;
+	if (state) {
+		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 1);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/5);
+	} else {
+		pmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 0);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ/100);
+	}
+}			
+
+
+#ifdef CONFIG_PM
+static int mesh_suspend(struct macio_dev *mdev, u32 state)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	unsigned long flags;
+
+	if (state == mdev->ofdev.dev.power_state || state < 2)
+		return 0;
+
+	scsi_block_requests(ms->host);
+	spin_lock_irqsave(ms->host->host_lock, flags);
+	while(ms->phase != idle) {
+		spin_unlock_irqrestore(ms->host->host_lock, flags);
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout(HZ/100);
+		spin_lock_irqsave(ms->host->host_lock, flags);
+	}
+	ms->phase = sleeping;
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+	disable_irq(ms->meshintr);
+	set_mesh_power(ms, 0);
+
+	mdev->ofdev.dev.power_state = state;
+
+	return 0;
+}
+
+static int mesh_resume(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	unsigned long flags;
+
+	if (mdev->ofdev.dev.power_state == 0)
+		return 0;
+
+	set_mesh_power(ms, 1);
+	mesh_init(ms);
+	spin_lock_irqsave(ms->host->host_lock, flags);
+	mesh_start(ms);
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+	enable_irq(ms->meshintr);
+	scsi_unblock_requests(ms->host);
+
+	mdev->ofdev.dev.power_state = 0;
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+/*
+ * If we leave drives set for synchronous transfers (especially
+ * CDROMs), and reboot to MacOS, it gets confused, poor thing.
+ * So, on reboot we reset the SCSI bus.
+ */
+static int mesh_shutdown(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	volatile struct mesh_regs *mr;
+	unsigned long flags;
+
+       	printk(KERN_INFO "resetting MESH scsi bus(es)\n");
+	spin_lock_irqsave(ms->host->host_lock, flags);
+       	mr = ms->mesh;
+	out_8(&mr->intr_mask, 0);
+	out_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);
+	out_8(&mr->bus_status1, BS1_RST);
+	mesh_flush_io(mr);
+	udelay(30);
+	out_8(&mr->bus_status1, 0);
+	spin_unlock_irqrestore(ms->host->host_lock, flags);
+
+	return 0;
+}
+
+static Scsi_Host_Template mesh_template = {
+	.proc_name			= "mesh",
+	.name				= "MESH",
+	.queuecommand			= mesh_queue,
+	.eh_abort_handler		= mesh_abort,
+	.eh_host_reset_handler		= mesh_host_reset,
+	.can_queue			= 20,
+	.this_id			= 7,
+	.sg_tablesize			= SG_ALL,
 	.cmd_per_lun			= 2,
 	.use_clustering			= DISABLE_CLUSTERING,
 };
 
-#include "scsi_module.c"
+static int mesh_probe(struct macio_dev *mdev, const struct of_match *match)
+{
+	struct device_node *mesh = macio_get_of_node(mdev);
+	struct pci_dev* pdev = macio_get_pci_dev(mdev);
+	int tgt, *cfp, minper;
+	struct mesh_state *ms;
+	struct Scsi_Host *mesh_host;
+	void *dma_cmd_space;
+	dma_addr_t dma_cmd_bus;
+
+	switch (mdev->bus->chip->type) {
+	case macio_heathrow:
+	case macio_gatwick:
+	case macio_paddington:
+		use_active_neg = 0;
+		break;
+	default:
+		use_active_neg = SEQ_ACTIVE_NEG;
+	}
+
+	if (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {
+       		printk(KERN_ERR "mesh: expected 2 addrs and 2 intrs"
+	       	       " (got %d,%d)\n", mesh->n_addrs, mesh->n_intrs);
+		return -ENODEV;
+	}
+
+	if (macio_request_resources(mdev, "mesh") != 0) {
+       		printk(KERN_ERR "mesh: unable to request memory resources");
+		return -EBUSY;
+	}
+       	mesh_host = scsi_host_alloc(&mesh_template, sizeof(struct mesh_state));
+	if (mesh_host == NULL) {
+		printk(KERN_ERR "mesh: couldn't register host");
+		goto out_release;
+	}
+	
+	/* Old junk for root discovery, that will die ultimately */
+#if !defined(MODULE)
+       	note_scsi_host(mesh, mesh_host);
+#endif
+
+	mesh_host->base = macio_resource_start(mdev, 0);
+	mesh_host->irq = macio_irq(mdev, 0);
+       	ms = (struct mesh_state *) mesh_host->hostdata;
+	macio_set_drvdata(mdev, ms);
+	ms->host = mesh_host;
+	ms->mdev = mdev;
+	ms->pdev = pdev;
+	
+	ms->mesh = (volatile struct mesh_regs *)
+		ioremap(macio_resource_start(mdev, 0), 0x1000);
+	if (ms->mesh == NULL) {
+		printk(KERN_ERR "mesh: can't map registers\n");
+		goto out_free;
+	}		
+	ms->dma = (volatile struct dbdma_regs *)
+	       	ioremap(macio_resource_start(mdev, 1), 0x1000);
+	if (ms->dma == NULL) {
+		printk(KERN_ERR "mesh: can't map registers\n");
+		iounmap((void *)ms->mesh);
+		goto out_free;
+	}
+
+       	ms->meshintr = macio_irq(mdev, 0);
+       	ms->dmaintr = macio_irq(mdev, 1);
+
+       	/* Space for dma command list: +1 for stop command,
+       	 * +1 to allow for aligning.
+	 */
+	ms->dma_cmd_size = (mesh_host->sg_tablesize + 2) * sizeof(struct dbdma_cmd);
+
+	/* We use the PCI APIs for now until the generic one gets fixed
+	 * enough or until we get some macio-specific versions
+	 */
+	dma_cmd_space = pci_alloc_consistent(macio_get_pci_dev(mdev),
+					     ms->dma_cmd_size,
+					     &dma_cmd_bus);
+	if (dma_cmd_space == NULL) {
+		printk(KERN_ERR "mesh: can't allocate DMA table\n");
+		goto out_unmap;
+	}
+	memset(dma_cmd_space, 0, ms->dma_cmd_size);
+
+	ms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);
+       	ms->dma_cmd_space = dma_cmd_space;
+	ms->dma_cmd_bus = dma_cmd_bus + ((unsigned long)ms->dma_cmds)
+		- (unsigned long)dma_cmd_space;
+	ms->current_req = NULL;
+       	for (tgt = 0; tgt < 8; ++tgt) {
+	       	ms->tgts[tgt].sdtr_state = do_sdtr;
+	       	ms->tgts[tgt].sync_params = ASYNC_PARAMS;
+	       	ms->tgts[tgt].current_req = 0;
+       	}
+
+	if ((cfp = (int *) get_property(mesh, "clock-frequency", NULL)))
+       		ms->clk_freq = *cfp;
+	else {
+       		printk(KERN_INFO "mesh: assuming 50MHz clock frequency\n");
+	       	ms->clk_freq = 50000000;
+       	}
+
+       	/* The maximum sync rate is clock / 5; increase
+       	 * mesh_sync_period if necessary.
+	 */
+	minper = 1000000000 / (ms->clk_freq / 5); /* ns */
+	if (mesh_sync_period < minper)
+		mesh_sync_period = minper;
+
+	/* Power up the chip */
+	set_mesh_power(ms, 1);
+
+	/* Set it up */
+       	mesh_init(ms);
+
+	/* XXX FIXME: error should be fatal */
+       	if (request_irq(ms->meshintr, do_mesh_interrupt, 0, "MESH", ms))
+	       	printk(KERN_ERR "MESH: can't get irq %d\n", ms->meshintr);
+
+	/* XXX FIXME: handle failure */
+	scsi_add_host(mesh_host, &mdev->ofdev.dev);
+	scsi_scan_host(mesh_host);
+
+	return 0;
+
+out_unmap:
+	iounmap((void *)ms->dma);
+	iounmap((void *)ms->mesh);
+out_free:
+	scsi_host_put(mesh_host);
+out_release:
+	macio_release_resources(mdev);
+
+	return -ENODEV;
+}
+
+static int mesh_remove(struct macio_dev *mdev)
+{
+	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
+	struct Scsi_Host *mesh_host = ms->host;
+
+	scsi_remove_host(mesh_host);
+
+	free_irq(ms->meshintr, ms);
+
+	/* Reset scsi bus */
+	mesh_shutdown(mdev);
+
+	/* Shut down chip & termination */
+	set_mesh_power(ms, 0);
+
+	/* Unmap registers & dma controller */
+	iounmap((void *) ms->mesh);
+       	iounmap((void *) ms->dma);
+
+	/* Free DMA commands memory */
+	pci_free_consistent(macio_get_pci_dev(mdev), ms->dma_cmd_size,
+			  ms->dma_cmd_space, ms->dma_cmd_bus);
+
+	/* Release memory resources */
+	macio_release_resources(mdev);
+
+	scsi_host_put(mesh_host);
+
+	return 0;
+}
+
+
+static struct of_match mesh_match[] = 
+{
+	{
+	.name 		= "mesh",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH
+	},
+	{
+	.name 		= OF_ANY_MATCH,
+	.type		= "scsi",
+	.compatible	= "chrp,mesh0"
+	},
+	{},
+};
+
+static struct macio_driver mesh_driver = 
+{
+	.name 		= "mesh",
+	.match_table	= mesh_match,
+	.probe		= mesh_probe,
+	.remove		= mesh_remove,
+	.shutdown	= mesh_shutdown,
+#ifdef CONFIG_PM
+	.suspend	= mesh_suspend,
+	.resume		= mesh_resume,
+#endif
+};
+
+
+static int __init init_mesh(void)
+{
+
+	/* Calculate sync rate from module parameters */
+	if (sync_rate > 10)
+		sync_rate = 10;
+	if (sync_rate > 0) {
+		printk(KERN_INFO "mesh: configured for synchronous %d MB/s\n", sync_rate);
+		mesh_sync_period = 1000 / sync_rate;	/* ns */
+		mesh_sync_offset = 15;
+	} else
+		printk(KERN_INFO "mesh: configured for asynchronous\n");
+
+	return macio_register_driver(&mesh_driver);
+}
+
+static void __exit exit_mesh(void)
+{
+	return macio_unregister_driver(&mesh_driver);
+}
+
+module_init(init_mesh);
+module_exit(exit_mesh);
diff -purN /dev/shm/linux-2.5/drivers/serial/Makefile linuxppc-2.5-benh/drivers/serial/Makefile
--- /dev/shm/linux-2.5/drivers/serial/Makefile	2003-09-09 09:30:53.000000000 +0000
+++ linuxppc-2.5-benh/drivers/serial/Makefile	2003-09-15 15:14:29.000000000 +0000
@@ -32,3 +32,4 @@ obj-$(CONFIG_SERIAL_COLDFIRE) += mcfseri
 obj-$(CONFIG_V850E_UART) += v850e_uart.o
 obj-$(CONFIG_SERIAL98) += serial98.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
+
diff -purN /dev/shm/linux-2.5/drivers/serial/pmac_zilog.c linuxppc-2.5-benh/drivers/serial/pmac_zilog.c
--- /dev/shm/linux-2.5/drivers/serial/pmac_zilog.c	2003-08-24 15:05:53.000000000 +0000
+++ linuxppc-2.5-benh/drivers/serial/pmac_zilog.c	2004-02-02 02:09:37.000000000 +0000
@@ -575,15 +575,12 @@ static void pmz_stop_rx(struct uart_port
 
 /* 
  * Enable modem status change interrupts
- * The port lock is not held.
+ * The port lock is held.
  */
 static void pmz_enable_ms(struct uart_port *port)
 {
 	struct uart_pmac_port *up = to_pmz(port);
 	unsigned char new_reg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&port->lock, flags);
 
 	new_reg = up->curregs[R15] | (DCDIE | SYNCIE | CTSIE);
 	if (new_reg != up->curregs[R15]) {
@@ -592,8 +589,6 @@ static void pmz_enable_ms(struct uart_po
 		/* NOTE: Not subject to 'transmitter active' rule.  */ 
 		write_zsreg(up, R15, up->curregs[R15]);
 	}
-
-	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 /* 
@@ -1120,7 +1115,7 @@ static struct uart_ops pmz_pops = {
  * Unlike sunzilog, we don't need to pre-init the spinlock as we don't
  * register our console before uart_add_one_port() is called
  */
-static int __init pmz_setup_port(struct uart_pmac_port *up, int early)
+static int __init pmz_setup_port(struct uart_pmac_port *up)
 {
 	struct device_node *np = up->node;
 	char *conn;
@@ -1133,11 +1128,6 @@ static int __init pmz_setup_port(struct 
 	/*
 	 * Request & map chip registers
 	 */
-	if (!early && request_OF_resource(np, 0, NULL) == NULL) {
-		printk("pmac_zilog: failed to request resources for %s\n",
-			np->full_name);
-		return -EBUSY;
-	}
 	up->port.mapbase = np->addrs[0].address;
 	up->port.membase = ioremap(up->port.mapbase, 0x1000);
       
@@ -1152,27 +1142,23 @@ static int __init pmz_setup_port(struct 
 		up->flags |= PMACZILOG_FLAG_HAS_DMA;
 #endif	
 	if (ZS_HAS_DMA(up)) {
-		if (!early && request_OF_resource(np, np->n_addrs - 2, " (tx dma)") == NULL) {
-			printk(KERN_ERR "pmac_zilog: can't request TX DMA resource !\n");
+		up->tx_dma_regs = (volatile struct dbdma_regs *)
+			ioremap(np->addrs[np->n_addrs - 2].address, 0x1000);
+		if (up->tx_dma_regs == NULL) {	
 			up->flags &= ~PMACZILOG_FLAG_HAS_DMA;
 			goto no_dma;
 		}
-		if (!early && request_OF_resource(np, np->n_addrs - 1, " (rx dma)") == NULL) {
-			release_OF_resource(np, np->n_addrs - 2);
-			printk(KERN_ERR "pmac_zilog: can't request RX DMA resource !\n");
+		up->rx_dma_regs = (volatile struct dbdma_regs *)
+			ioremap(np->addrs[np->n_addrs - 1].address, 0x1000);
+		if (up->rx_dma_regs == NULL) {	
+			iounmap((void *)up->tx_dma_regs);
 			up->flags &= ~PMACZILOG_FLAG_HAS_DMA;
 			goto no_dma;
 		}
-		up->tx_dma_regs = (volatile struct dbdma_regs *)
-			ioremap(np->addrs[np->n_addrs - 2].address, 0x1000);
-		up->rx_dma_regs = (volatile struct dbdma_regs *)
-			ioremap(np->addrs[np->n_addrs - 1].address, 0x1000);
 		up->tx_dma_irq = np->intrs[1].line;
 		up->rx_dma_irq = np->intrs[2].line;
 	}
 no_dma:
-	if (!early)
-		up->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;
 
 	/*
 	 * Detect port type
@@ -1247,6 +1233,7 @@ static void pmz_dispose_port(struct uart
 	of_node_put(np);
 }
 
+
 /*
  * Called upon match with an escc node in the devive-tree.
  */
@@ -1258,8 +1245,15 @@ static int pmz_attach(struct macio_dev *
 	 */
 	for (i = 0; i < MAX_ZS_PORTS; i++)
 		if (pmz_ports[i].node == mdev->ofdev.node) {
-			pmz_ports[i].dev = mdev;
-			dev_set_drvdata(&mdev->ofdev.dev, &pmz_ports[i]);
+			struct uart_pmac_port *up = &pmz_ports[i];
+
+			up->dev = mdev;
+			dev_set_drvdata(&mdev->ofdev.dev, up);
+			if (macio_request_resources(up->dev, "pmac_zilog"))
+				printk(KERN_WARNING "%s: Failed to request resource, port still active\n",
+				       up->node->name);
+			else
+				up->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;				
 			return 0;
 		}
 	return -ENODEV;
@@ -1271,13 +1265,17 @@ static int pmz_attach(struct macio_dev *
  */
 static int pmz_detach(struct macio_dev *mdev)
 {
-	struct uart_pmac_port	*port = dev_get_drvdata(&mdev->ofdev.dev);
+	struct uart_pmac_port	*up = dev_get_drvdata(&mdev->ofdev.dev);
 	
-	if (!port)
+	if (!up)
 		return -ENODEV;
 
+	if (up->flags & PMACZILOG_FLAG_RSRC_REQUESTED) {
+		macio_release_resources(up->dev);
+		up->flags &= ~PMACZILOG_FLAG_RSRC_REQUESTED;
+	}
 	dev_set_drvdata(&mdev->ofdev.dev, NULL);
-	port->dev = NULL;
+	up->dev = NULL;
 	
 	return 0;
 }
@@ -1288,7 +1286,7 @@ static int pmz_detach(struct macio_dev *
  * used later to "attach" to the sysfs tree so we get power management
  * events
  */
-static int __init pmz_probe(int early)
+static int __init pmz_probe(void)
 {
 	struct device_node	*node_p, *node_a, *node_b, *np;
 	int			count = 0;
@@ -1333,9 +1331,9 @@ static int __init pmz_probe(int early)
 		/*
 		 * Setup the ports for real
 		 */
-		rc = pmz_setup_port(&pmz_ports[count], early);
+		rc = pmz_setup_port(&pmz_ports[count]);
 		if (rc == 0)
-			rc = pmz_setup_port(&pmz_ports[count+1], early);
+			rc = pmz_setup_port(&pmz_ports[count+1]);
 		if (rc != 0) {
 			of_node_put(node_a);
 			of_node_put(node_b);
@@ -1436,43 +1434,10 @@ static struct macio_driver pmz_driver = 
 //	.resume		= pmz_resume,  *** NYI
 };
 
-static void pmz_fixup_resources(void)
-{
-	int i;
-       	for (i=0; i<pmz_ports_count; i++) {
-       		struct uart_pmac_port *up = &pmz_ports[i];
-
-		if (up->node == NULL)
-			continue;
-       		if (up->flags & PMACZILOG_FLAG_RSRC_REQUESTED)
-			continue;
-		if (request_OF_resource(up->node, 0, NULL) == NULL)
-			printk(KERN_WARNING "%s: Failed to do late IO resource request, port still active\n",
-			       up->node->name);
-		up->flags |= PMACZILOG_FLAG_RSRC_REQUESTED;
-		if (!ZS_HAS_DMA(up))
-			continue;
-		if (request_OF_resource(up->node, up->node->n_addrs - 2, NULL) == NULL)
-			printk(KERN_WARNING "%s: Failed to do late DMA resource request, port still active\n",
-			       up->node->name);
-		if (request_OF_resource(up->node, up->node->n_addrs - 1, NULL) == NULL)
-			printk(KERN_WARNING "%s: Failed to do late DMA resource request, port still active\n",
-			       up->node->name);
-       	}
-
-}
-
 static int __init init_pmz(void)
 {
 	printk(KERN_DEBUG "%s\n", version);
 
-	/*
-	 * If we had serial console, then we didn't request
-	 * resources yet. We fix that up now
-	 */
-	if (pmz_ports_count > 0)
-		pmz_fixup_resources();
-
 	/* 
 	 * First, we need to do a direct OF-based probe pass. We
 	 * do that because we want serial console up before the
@@ -1481,7 +1446,7 @@ static int __init init_pmz(void)
 	 * uart_register_driver()
 	 */
 	if (pmz_ports_count == 0)
-		pmz_probe(0);
+		pmz_probe();
 
 	/*
 	 * Bail early if no port found
@@ -1610,7 +1575,7 @@ static int __init pmz_console_setup(stru
 static int __init pmz_console_init(void)
 {
 	/* Probe ports */
-	pmz_probe(1);
+	pmz_probe();
 
 	/* TODO: Autoprobe console based on OF */
 	/* pmz_console.index = i; */
diff -purN /dev/shm/linux-2.5/drivers/usb/core/hcd-pci.c linuxppc-2.5-benh/drivers/usb/core/hcd-pci.c
--- /dev/shm/linux-2.5/drivers/usb/core/hcd-pci.c	2003-10-09 10:20:18.000000000 +0000
+++ linuxppc-2.5-benh/drivers/usb/core/hcd-pci.c	2003-10-14 07:25:48.000000000 +0000
@@ -32,6 +32,12 @@
 #include <linux/usb.h>
 #include "hcd.h"
 
+#ifdef CONFIG_PPC_PMAC
+#include <asm/machdep.h>
+#include <asm/pmac_feature.h>
+#include <asm/pci-bridge.h>
+#include <asm/prom.h>
+#endif /* CONFIG_PPC_PMAC */
 
 /* PCI-based HCs are normal, but custom bus glue should be ok */
 
@@ -295,8 +301,17 @@ int usb_hcd_pci_suspend (struct pci_dev 
 		if (retval)
 			dev_dbg (hcd->controller, "suspend fail, retval %d\n",
 					retval);
-		else
+		else {
+#ifdef CONFIG_PPC_PMAC
+			struct device_node	*of_node;
+ 
+			/* Disable USB PAD & cell clock for Keylargo built-in controller */
+			of_node = pci_device_to_OF_node (dev);
+			if (of_node)
+				pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
+#endif /* CONFIG_PPC_PMAC */
 			hcd->state = USB_STATE_SUSPENDED;
+		}
 	}
 
  	pci_set_power_state (dev, state);
@@ -326,6 +341,17 @@ int usb_hcd_pci_resume (struct pci_dev *
 	hcd->state = USB_STATE_RESUMING;
 
 	pci_set_power_state (dev, 0);
+#ifdef CONFIG_PPC_PMAC
+	{
+		struct device_node *of_node;
+
+		/* Re-enable USB PAD & cell clock for Keykargo built-in controller */
+		of_node = pci_device_to_OF_node (dev);
+		if (of_node)
+			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
+	}
+#endif /* CONFIG_PPC_PMAC */
+
 	pci_restore_state (dev, hcd->pci_state);
 
 	/* remote wakeup needs hub->suspend() cooperation */
diff -purN /dev/shm/linux-2.5/drivers/usb/host/ohci-hcd.c linuxppc-2.5-benh/drivers/usb/host/ohci-hcd.c
--- /dev/shm/linux-2.5/drivers/usb/host/ohci-hcd.c	2004-01-26 09:48:45.000000000 +0000
+++ linuxppc-2.5-benh/drivers/usb/host/ohci-hcd.c	2004-01-29 05:09:38.000000000 +0000
@@ -316,6 +316,11 @@ ohci_endpoint_disable (struct usb_hcd *h
 	/* ASSERT:  any requests/urbs are being unlinked */
 	/* ASSERT:  nobody can be submitting urbs for this any more */
 
+	if (!HCD_IS_RUNNING (ohci->hcd.state)) {
+		ed->state = ED_IDLE;
+		finish_unlinks (ohci, 0, 0);
+	}
+
 	epnum <<= 1;
 	if (epnum != 0 && !(ep & USB_DIR_IN))
 		epnum |= 1;
@@ -571,9 +576,17 @@ static void ohci_irq (struct usb_hcd *hc
 		disable (ohci);
 		ohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");
 		// e.g. due to PCI Master/Target Abort
+#if 1
+		if (hcd->pdev) {
+			u16 status;
+
+			pci_read_config_word(hcd->pdev, PCI_STATUS, &status);
+			printk(KERN_ERR "OHCI PCI Status: 0x%04x\n", status);
+		}
+#endif
 
 		ohci_dump (ohci, 1);
-		hc_reset (ohci);
+       		hc_reset (ohci);
 	}
   
 	if (ints & OHCI_INTR_WDH) {
diff -purN /dev/shm/linux-2.5/drivers/usb/host/ohci-hub.c linuxppc-2.5-benh/drivers/usb/host/ohci-hub.c
--- /dev/shm/linux-2.5/drivers/usb/host/ohci-hub.c	2003-10-13 13:24:06.000000000 +0000
+++ linuxppc-2.5-benh/drivers/usb/host/ohci-hub.c	2003-10-28 04:09:32.000000000 +0000
@@ -71,6 +71,11 @@ ohci_hub_status_data (struct usb_hcd *hc
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		ports, i, changed = 0, length = 1;
 
+	if (HCD_IS_SUSPENDED(hcd->state)) {
+		printk("ohci_hub_status_data() : sleeping\n");
+		return 0;
+	}
+
 	ports = roothub_a (ohci) & RH_A_NDP; 
 	if (ports > MAX_ROOT_PORTS) {
 		if (!HCD_IS_RUNNING(ohci->hcd.state))
@@ -161,6 +166,11 @@ static int ohci_hub_control (
 	u32		temp;
 	int		retval = 0;
 
+	if (HCD_IS_SUSPENDED(hcd->state)) {
+		printk("ohci_hub_control() : sleeping\n");
+		return -ENODEV;
+	}
+
 	switch (typeReq) {
 	case ClearHubFeature:
 		switch (wValue) {
diff -purN /dev/shm/linux-2.5/drivers/usb/host/ohci-pci.c linuxppc-2.5-benh/drivers/usb/host/ohci-pci.c
--- /dev/shm/linux-2.5/drivers/usb/host/ohci-pci.c	2003-10-13 13:24:06.000000000 +0000
+++ linuxppc-2.5-benh/drivers/usb/host/ohci-pci.c	2004-01-21 00:24:37.000000000 +0000
@@ -13,16 +13,6 @@
  *
  * This file is licenced under the GPL.
  */
- 
-#ifdef CONFIG_PMAC_PBOOK
-#include <asm/machdep.h>
-#include <asm/pmac_feature.h>
-#include <asm/pci-bridge.h>
-#include <asm/prom.h>
-#ifndef CONFIG_PM
-#	define CONFIG_PM
-#endif
-#endif
 
 #ifndef CONFIG_PCI
 #error "This file is PCI bus glue.  CONFIG_PCI must be defined."
@@ -46,6 +36,17 @@ ohci_pci_start (struct usb_hcd *hcd)
 	int		ret;
 
 	if (hcd->pdev) {
+#if 1
+		u16 status;
+
+		pci_read_config_word(hcd->pdev, PCI_STATUS, &status);
+		printk(KERN_ERR "OHCI PCI Status: 0x%04x\n", status);
+		if (status & 0xf900) {
+			printk(KERN_ERR "Initial error ! clearing ...\n");
+			pci_write_config_word(hcd->pdev, PCI_STATUS, status);
+		}
+#endif
+
 		ohci->hcca = pci_alloc_consistent (hcd->pdev,
 				sizeof *ohci->hcca, &ohci->hcca_dma);
 		if (!ohci->hcca)
@@ -142,12 +143,6 @@ static int ohci_pci_suspend (struct usb_
 	mdelay (1);
 	if (!readl (&ohci->regs->intrstatus) & OHCI_INTR_SF)
 		mdelay (1);
-		
-#ifdef CONFIG_PMAC_PBOOK
-	if (_machine == _MACH_Pmac)
-		disable_irq (hcd->pdev->irq);
- 	/* else, 2.4 assumes shared irqs -- don't disable */
-#endif
 
 	/* Enable remote wakeup */
 	writel (readl (&ohci->regs->intrenable) | OHCI_INTR_RD,
@@ -182,16 +177,7 @@ static int ohci_pci_suspend (struct usb_
 	pci_read_config_word (hcd->pdev, PCI_COMMAND, &cmd);
 	cmd &= ~PCI_COMMAND_MASTER;
 	pci_write_config_word (hcd->pdev, PCI_COMMAND, cmd);
-#ifdef CONFIG_PMAC_PBOOK
-	{
-	   	struct device_node	*of_node;
- 
-		/* Disable USB PAD & cell clock */
-		of_node = pci_device_to_OF_node (hcd->pdev);
-		if (of_node)
-			pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
-	}
-#endif
+
 	return 0;
 }
 
@@ -202,16 +188,6 @@ static int ohci_pci_resume (struct usb_h
 	int			temp;
 	int			retval = 0;
 
-#ifdef CONFIG_PMAC_PBOOK
-	{
-		struct device_node *of_node;
-
-		/* Re-enable USB PAD & cell clock */
-		of_node = pci_device_to_OF_node (hcd->pdev);
-		if (of_node)
-			pmac_call_feature (PMAC_FTR_USB_ENABLE, of_node, 0, 1);
-	}
-#endif
 	/* did we suspend, or were we powered off? */
 	ohci->hc_control = readl (&ohci->regs->control);
 	temp = ohci->hc_control & OHCI_CTRL_HCFS;
@@ -277,10 +253,6 @@ restart:
 		(void) readl (&ohci->regs->intrdisable);
 		spin_unlock_irq (&ohci->lock);
 
-#ifdef CONFIG_PMAC_PBOOK
-		if (_machine == _MACH_Pmac)
-			enable_irq (hcd->pdev->irq);
-#endif
 
 		/* Check for a pending done list */
 		if (ohci->hcca->done_head)
diff -purN /dev/shm/linux-2.5/drivers/video/Kconfig linuxppc-2.5-benh/drivers/video/Kconfig
--- /dev/shm/linux-2.5/drivers/video/Kconfig	2004-02-04 05:29:14.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/Kconfig	2004-02-05 10:07:35.000000000 +0000
@@ -614,16 +614,40 @@ config FB_MATROX_MULTIHEAD
 	  There is no need for enabling 'Matrox multihead support' if you have
 	  only one Matrox card in the box.
 
+config FB_RADEON_OLD
+	tristate "ATI Radeon display support (Old driver)"
+	depends on FB && PCI
+	help
+	  Choose this option if you want to use an ATI Radeon graphics card as
+	  a framebuffer device.  There are both PCI and AGP versions.  You
+	  don't need to choose this to run the Radeon in plain VGA mode.
+	  There is a product page at
+	  <http://www.ati.com/na/pages/products/pc/radeon32/index.html>.
+
 config FB_RADEON
-	tristate "ATI Radeon display support"
+	tristate "ATI Radeon display support (New driver)"
 	depends on FB && PCI
 	help
 	  Choose this option if you want to use an ATI Radeon graphics card as
 	  a framebuffer device.  There are both PCI and AGP versions.  You
 	  don't need to choose this to run the Radeon in plain VGA mode.
+
+	  If you say Y here and want DDC/I2C support you must first say Y to
+	  "I2C support" and "I2C bit-banging support" in the character devices
+	  section.
+
+	  If you say M here then "I2C support" and "I2C bit-banging support" 
+	  can be build either as modules or built-in.
+
 	  There is a product page at
 	  <http://www.ati.com/na/pages/products/pc/radeon32/index.html>.
 
+config FB_RADEON_I2C
+	bool "DDC/I2C for ATI Radeon support"
+	depends on FB_RADEON && (I2C_ALGOBIT=FB_RADEON || I2C_ALGOBIT=y)
+	help
+	  Say Y here if you want DDC/I2C support for your Radeon board. 
+
 config FB_ATY128
 	tristate "ATI Rage128 display support"
 	depends on FB && PCI
diff -purN /dev/shm/linux-2.5/drivers/video/Makefile linuxppc-2.5-benh/drivers/video/Makefile
--- /dev/shm/linux-2.5/drivers/video/Makefile	2004-01-19 06:22:21.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/Makefile	2004-01-21 00:29:28.000000000 +0000
@@ -21,7 +21,7 @@ obj-$(CONFIG_FB_APOLLO)           += dnf
 obj-$(CONFIG_FB_Q40)              += q40fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_ATARI)            += atafb.o
 obj-$(CONFIG_FB_68328)            += 68328fb.o
-obj-$(CONFIG_FB_RADEON)		  += radeonfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_RADEON_OLD)	  += radeonfb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_NEOMAGIC)         += neofb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_IGA)              += igafb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_CONTROL)          += controlfb.o macmodes.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
@@ -54,12 +54,14 @@ obj-$(CONFIG_FB_PMAG_BA)          += pma
 obj-$(CONFIG_FB_PMAGB_B)          += pmagb-b-fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_MAXINE)           += maxinefb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_TX3912)           += tx3912fb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+obj-$(CONFIG_FB_IBMLCDC)	  += ibmlcdfb.o
 
 obj-$(CONFIG_FB_MATROX)		  += matrox/ cfbfillrect.o cfbcopyarea.o cfbimgblt.o
 obj-$(CONFIG_FB_RIVA)		  += riva/ cfbimgblt.o vgastate.o 
 obj-$(CONFIG_FB_SIS)		  += sis/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
 obj-$(CONFIG_FB_ATY)		  += aty/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
 obj-$(CONFIG_FB_ATY128)		  += aty/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
+obj-$(CONFIG_FB_RADEON)		  += aty/ cfbcopyarea.o cfbfillrect.o cfbimgblt.o
 obj-$(CONFIG_FB_I810)             += i810/ cfbfillrect.o cfbcopyarea.o \
 	                             cfbimgblt.o vgastate.o
 
diff -purN /dev/shm/linux-2.5/drivers/video/aty/Makefile linuxppc-2.5-benh/drivers/video/aty/Makefile
--- /dev/shm/linux-2.5/drivers/video/aty/Makefile	2003-05-01 16:32:15.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/Makefile	2004-01-21 06:00:06.000000000 +0000
@@ -1,7 +1,12 @@
 obj-$(CONFIG_FB_ATY) += atyfb.o
 obj-$(CONFIG_FB_ATY128) += aty128fb.o
+obj-$(CONFIG_FB_RADEON) += radeonfb.o
 
 atyfb-y				:= atyfb_base.o mach64_accel.o
 atyfb-$(CONFIG_FB_ATY_GX)	+= mach64_gx.o
 atyfb-$(CONFIG_FB_ATY_CT)	+= mach64_ct.o mach64_cursor.o
 atyfb-objs			:= $(atyfb-y)
+
+radeonfb-y			:= radeon_base.o radeon_pm.o radeon_monitor.o radeon_accel.o
+radeonfb-$(CONFIG_FB_RADEON_I2C)	+= radeon_i2c.o
+radeonfb-objs			:= $(radeonfb-y)
\ No newline at end of file
diff -purN /dev/shm/linux-2.5/drivers/video/aty/ati_ids.h linuxppc-2.5-benh/drivers/video/aty/ati_ids.h
--- /dev/shm/linux-2.5/drivers/video/aty/ati_ids.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/ati_ids.h	2003-10-05 17:33:41.000000000 +0000
@@ -0,0 +1,167 @@
+/*
+ * ATI PCI IDs from XFree86, kept here to make sync'ing with
+ * XFree much simpler. Currently, this list is only used by
+ * radeonfb
+ */
+
+#define PCI_CHIP_RS100_4136		0x4136
+#define PCI_CHIP_RS200_4137		0x4137
+#define PCI_CHIP_R300_AD		0x4144
+#define PCI_CHIP_R300_AE		0x4145
+#define PCI_CHIP_R300_AF		0x4146
+#define PCI_CHIP_R300_AG		0x4147
+#define PCI_CHIP_R350_AH                0x4148
+#define PCI_CHIP_R350_AI                0x4149
+#define PCI_CHIP_R350_AJ                0x414A
+#define PCI_CHIP_R350_AK                0x414B
+#define PCI_CHIP_RV350_AP               0x4150
+#define PCI_CHIP_RV350_AQ               0x4151
+#define PCI_CHIP_RV360_AR               0x4152
+#define PCI_CHIP_RV350_AS               0x4153
+#define PCI_CHIP_RV350_AT               0x4154
+#define PCI_CHIP_RV350_AV               0x4156
+#define PCI_CHIP_MACH32			0x4158
+#define PCI_CHIP_RS250_4237		0x4237
+#define PCI_CHIP_R200_BB		0x4242
+#define PCI_CHIP_R200_BC		0x4243
+#define PCI_CHIP_RS100_4336		0x4336
+#define PCI_CHIP_RS200_4337		0x4337
+#define PCI_CHIP_MACH64CT		0x4354
+#define PCI_CHIP_MACH64CX		0x4358
+#define PCI_CHIP_RS250_4437		0x4437
+#define PCI_CHIP_MACH64ET		0x4554
+#define PCI_CHIP_MACH64GB		0x4742
+#define PCI_CHIP_MACH64GD		0x4744
+#define PCI_CHIP_MACH64GI		0x4749
+#define PCI_CHIP_MACH64GL		0x474C
+#define PCI_CHIP_MACH64GM		0x474D
+#define PCI_CHIP_MACH64GN		0x474E
+#define PCI_CHIP_MACH64GO		0x474F
+#define PCI_CHIP_MACH64GP		0x4750
+#define PCI_CHIP_MACH64GQ		0x4751
+#define PCI_CHIP_MACH64GR		0x4752
+#define PCI_CHIP_MACH64GS		0x4753
+#define PCI_CHIP_MACH64GT		0x4754
+#define PCI_CHIP_MACH64GU		0x4755
+#define PCI_CHIP_MACH64GV		0x4756
+#define PCI_CHIP_MACH64GW		0x4757
+#define PCI_CHIP_MACH64GX		0x4758
+#define PCI_CHIP_MACH64GY		0x4759
+#define PCI_CHIP_MACH64GZ		0x475A
+#define PCI_CHIP_RV250_Id		0x4964
+#define PCI_CHIP_RV250_Ie		0x4965
+#define PCI_CHIP_RV250_If		0x4966
+#define PCI_CHIP_RV250_Ig		0x4967
+#define PCI_CHIP_MACH64LB		0x4C42
+#define PCI_CHIP_MACH64LD		0x4C44
+#define PCI_CHIP_RAGE128LE		0x4C45
+#define PCI_CHIP_RAGE128LF		0x4C46
+#define PCI_CHIP_MACH64LG		0x4C47
+#define PCI_CHIP_MACH64LI		0x4C49
+#define PCI_CHIP_MACH64LM		0x4C4D
+#define PCI_CHIP_MACH64LN		0x4C4E
+#define PCI_CHIP_MACH64LP		0x4C50
+#define PCI_CHIP_MACH64LQ		0x4C51
+#define PCI_CHIP_MACH64LR		0x4C52
+#define PCI_CHIP_MACH64LS		0x4C53
+#define PCI_CHIP_RADEON_LW		0x4C57
+#define PCI_CHIP_RADEON_LX		0x4C58
+#define PCI_CHIP_RADEON_LY		0x4C59
+#define PCI_CHIP_RADEON_LZ		0x4C5A
+#define PCI_CHIP_RV250_Ld		0x4C64
+#define PCI_CHIP_RV250_Le		0x4C65
+#define PCI_CHIP_RV250_Lf		0x4C66
+#define PCI_CHIP_RV250_Lg		0x4C67
+#define PCI_CHIP_RAGE128MF		0x4D46
+#define PCI_CHIP_RAGE128ML		0x4D4C
+#define PCI_CHIP_R300_ND		0x4E44
+#define PCI_CHIP_R300_NE		0x4E45
+#define PCI_CHIP_R300_NF		0x4E46
+#define PCI_CHIP_R300_NG		0x4E47
+#define PCI_CHIP_R350_NH                0x4E48  
+#define PCI_CHIP_R350_NI                0x4E49  
+#define PCI_CHIP_R360_NJ                0x4E4A  
+#define PCI_CHIP_R350_NK                0x4E4B  
+#define PCI_CHIP_RV350_NP               0x4E50
+#define PCI_CHIP_RV350_NQ               0x4E51
+#define PCI_CHIP_RV350_NR               0x4E52
+#define PCI_CHIP_RV350_NS               0x4E53
+#define PCI_CHIP_RV350_NT               0x4E54
+#define PCI_CHIP_RV350_NV               0x4E56
+#define PCI_CHIP_RAGE128PA		0x5041
+#define PCI_CHIP_RAGE128PB		0x5042
+#define PCI_CHIP_RAGE128PC		0x5043
+#define PCI_CHIP_RAGE128PD		0x5044
+#define PCI_CHIP_RAGE128PE		0x5045
+#define PCI_CHIP_RAGE128PF		0x5046
+#define PCI_CHIP_RAGE128PG		0x5047
+#define PCI_CHIP_RAGE128PH		0x5048
+#define PCI_CHIP_RAGE128PI		0x5049
+#define PCI_CHIP_RAGE128PJ		0x504A
+#define PCI_CHIP_RAGE128PK		0x504B
+#define PCI_CHIP_RAGE128PL		0x504C
+#define PCI_CHIP_RAGE128PM		0x504D
+#define PCI_CHIP_RAGE128PN		0x504E
+#define PCI_CHIP_RAGE128PO		0x504F
+#define PCI_CHIP_RAGE128PP		0x5050
+#define PCI_CHIP_RAGE128PQ		0x5051
+#define PCI_CHIP_RAGE128PR		0x5052
+#define PCI_CHIP_RAGE128PS		0x5053
+#define PCI_CHIP_RAGE128PT		0x5054
+#define PCI_CHIP_RAGE128PU		0x5055
+#define PCI_CHIP_RAGE128PV		0x5056
+#define PCI_CHIP_RAGE128PW		0x5057
+#define PCI_CHIP_RAGE128PX		0x5058
+#define PCI_CHIP_RADEON_QD		0x5144
+#define PCI_CHIP_RADEON_QE		0x5145
+#define PCI_CHIP_RADEON_QF		0x5146
+#define PCI_CHIP_RADEON_QG		0x5147
+#define PCI_CHIP_R200_QH		0x5148
+#define PCI_CHIP_R200_QI		0x5149
+#define PCI_CHIP_R200_QJ		0x514A
+#define PCI_CHIP_R200_QK		0x514B
+#define PCI_CHIP_R200_QL		0x514C
+#define PCI_CHIP_R200_QM		0x514D
+#define PCI_CHIP_R200_QN		0x514E
+#define PCI_CHIP_R200_QO		0x514F
+#define PCI_CHIP_RV200_QW		0x5157
+#define PCI_CHIP_RV200_QX		0x5158
+#define PCI_CHIP_RV100_QY		0x5159
+#define PCI_CHIP_RV100_QZ		0x515A
+#define PCI_CHIP_RAGE128RE		0x5245
+#define PCI_CHIP_RAGE128RF		0x5246
+#define PCI_CHIP_RAGE128RG		0x5247
+#define PCI_CHIP_RAGE128RK		0x524B
+#define PCI_CHIP_RAGE128RL		0x524C
+#define PCI_CHIP_RAGE128SE		0x5345
+#define PCI_CHIP_RAGE128SF		0x5346
+#define PCI_CHIP_RAGE128SG		0x5347
+#define PCI_CHIP_RAGE128SH		0x5348
+#define PCI_CHIP_RAGE128SK		0x534B
+#define PCI_CHIP_RAGE128SL		0x534C
+#define PCI_CHIP_RAGE128SM		0x534D
+#define PCI_CHIP_RAGE128SN		0x534E
+#define PCI_CHIP_RAGE128TF		0x5446
+#define PCI_CHIP_RAGE128TL		0x544C
+#define PCI_CHIP_RAGE128TR		0x5452
+#define PCI_CHIP_RAGE128TS		0x5453
+#define PCI_CHIP_RAGE128TT		0x5454
+#define PCI_CHIP_RAGE128TU		0x5455
+#define PCI_CHIP_MACH64VT		0x5654
+#define PCI_CHIP_MACH64VU		0x5655
+#define PCI_CHIP_MACH64VV		0x5656
+#define PCI_CHIP_RS300_5834		0x5834
+#define PCI_CHIP_RS300_5835		0x5835
+#define PCI_CHIP_RS300_5836		0x5836
+#define PCI_CHIP_RS300_5837		0x5837
+#define PCI_CHIP_RV280_5960		0x5960
+#define PCI_CHIP_RV280_5961		0x5961
+#define PCI_CHIP_RV280_5962		0x5962
+#define PCI_CHIP_RV280_5963		0x5963
+#define PCI_CHIP_RV280_5964		0x5964
+#define PCI_CHIP_RV280_5968		0x5968
+#define PCI_CHIP_RV280_5969		0x5969
+#define PCI_CHIP_RV280_596A		0x596A
+#define PCI_CHIP_RV280_596B		0x596B
+#define PCI_CHIP_RV280_5C61		0x5C61
+#define PCI_CHIP_RV280_5C63		0x5C63
diff -purN /dev/shm/linux-2.5/drivers/video/aty/aty128fb.c linuxppc-2.5-benh/drivers/video/aty/aty128fb.c
--- /dev/shm/linux-2.5/drivers/video/aty/aty128fb.c	2004-01-14 07:07:10.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/aty128fb.c	2004-01-29 05:09:39.000000000 +0000
@@ -52,11 +52,13 @@
 #include <linux/vmalloc.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <asm/uaccess.h>
 #include <linux/fb.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/ioport.h>
+#include <linux/console.h>
+
+#include <asm/uaccess.h>
 #include <asm/io.h>
 
 #ifdef CONFIG_PPC_PMAC
@@ -65,11 +67,6 @@
 #include "../macmodes.h"
 #endif
 
-#ifdef CONFIG_ADB_PMU
-#include <linux/adb.h>
-#include <linux/pmu.h>
-#endif
-
 #ifdef CONFIG_PMAC_BACKLIGHT
 #include <asm/backlight.h>
 #endif
@@ -146,6 +143,8 @@ enum {
 static int aty128_probe(struct pci_dev *pdev,
                                const struct pci_device_id *ent);
 static void aty128_remove(struct pci_dev *pdev);
+static int aty128_pci_suspend(struct pci_dev *pdev, u32 state);
+static int aty128_pci_resume(struct pci_dev *pdev);
 
 /* supported Rage128 chipsets */
 static struct pci_device_id aty128_pci_tbl[] = {
@@ -185,6 +184,8 @@ static struct pci_driver aty128fb_driver
 	.id_table	= aty128_pci_tbl,
 	.probe		= aty128_probe,
 	.remove		= __devexit_p(aty128_remove),
+	.suspend	= aty128_pci_suspend,
+	.resume		= aty128_pci_resume,
 };
 
 /* packed BIOS settings */
@@ -322,26 +323,20 @@ struct aty128fb_par {
 #endif
 	int blitter_may_be_busy;
 	int fifo_slots;                 /* free slots in FIFO (64 max) */
-#ifdef CONFIG_PMAC_PBOOK
-	unsigned char *save_framebuffer;
+
 	int	pm_reg;
 	int crt_on, lcd_on;
 	struct pci_dev *pdev;
 	struct fb_info *next;
-#endif
+	int	asleep;
+	int	lock_blank;
+
 	u8	red[32];		/* see aty128fb_setcolreg */
 	u8	green[64];
 	u8	blue[32];
 	u32	pseudo_palette[16];	/* used for TRUECOLOR */
 };
 
-#ifdef CONFIG_PMAC_PBOOK
-int aty128_sleep_notify(struct pmu_sleep_notifier *self, int when);
-static struct pmu_sleep_notifier aty128_sleep_notifier = {
-	aty128_sleep_notify, SLEEP_LEVEL_VIDEO,
-};
-static struct fb_info *aty128_fb = NULL;
-#endif
 
 #define round_div(n, d) ((n+(d/2))/d)
 
@@ -395,15 +390,9 @@ static struct fb_ops aty128fb_ops = {
 	.fb_blank	= aty128fb_blank,
 	.fb_ioctl	= aty128fb_ioctl,
 	.fb_sync	= aty128fb_sync,
-#if 0
-	.fb_fillrect	= aty128fb_fillrect,
-	.fb_copyarea	= aty128fb_copyarea,
-	.fb_imageblit	= aty128fb_imageblit,
-#else
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
-#endif
 	.fb_cursor	= soft_cursor,
 };
 
@@ -1039,7 +1028,7 @@ aty128_set_lcd_enable(struct aty128fb_pa
 		aty_st_le32(LVDS_GEN_CNTL, reg);
 	}
 }
-#endif
+#endif /* CONFIG_PMAC_PBOOK */
 
 static void
 aty128_set_pll(struct aty128_pll *pll, const struct aty128fb_par *par)
@@ -1623,16 +1612,12 @@ aty128_init(struct pci_dev *pdev, const 
 	if (par->chip_gen == rage_M3)
 		register_backlight_controller(&aty128_backlight_controller, par, "ati");
 #endif /* CONFIG_PMAC_BACKLIGHT */
-#ifdef CONFIG_PMAC_PBOOK
+
 	par->pm_reg = pci_find_capability(pdev, PCI_CAP_ID_PM);
-	if (aty128_fb == NULL) {
-		/* XXX can only put one chip to sleep */
-		aty128_fb = info;
-	} else
-		printk(KERN_WARNING "aty128fb: can only sleep one Rage 128\n");
 	par->pdev = pdev;
-#endif
-
+	par->asleep = 0;
+	par->lock_blank = 0;
+	
 	printk(KERN_INFO "fb%d: %s frame buffer device on %s\n",
 	       info->node, info->fix.id, video_card);
 
@@ -1780,10 +1765,6 @@ static void __devexit aty128_remove(stru
 			   pci_resource_len(pdev, 1));
 	release_mem_region(pci_resource_start(pdev, 2),
 			   pci_resource_len(pdev, 2));
-#ifdef CONFIG_PMAC_PBOOK
-	if (info == aty128_fb)
-		aty128_fb = NULL;
-#endif
 	kfree(info);
 }
 #endif /* CONFIG_PCI */
@@ -1944,6 +1925,9 @@ aty128fb_blank(int blank, struct fb_info
 	struct aty128fb_par *par = fb->par;
 	u8 state = 0;
 
+	if (par->lock_blank || par->asleep)
+		return 0;
+
 #ifdef CONFIG_PMAC_BACKLIGHT
 	if ((_machine == _MACH_Pmac) && blank)
 		set_backlight_enable(0);
@@ -2041,9 +2025,9 @@ aty128fb_setcolreg(u_int regno, u_int re
 #define ATY_MIRROR_CRT_ON	0x00000002
 
 /* out param: u32*	backlight value: 0 to 15 */
-#define FBIO_ATY128_GET_MIRROR	_IOR('@', 1, __u32*)
+#define FBIO_ATY128_GET_MIRROR	_IOR('@', 1, __u32)
 /* in param: u32*	backlight value: 0 to 15 */
-#define FBIO_ATY128_SET_MIRROR	_IOW('@', 2, __u32*)
+#define FBIO_ATY128_SET_MIRROR	_IOW('@', 2, __u32)
 
 static int aty128fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
 			  u_long arg, struct fb_info *info)
@@ -2212,7 +2196,6 @@ fbcon_aty128_bmove(struct display *p, in
 }
 #endif /* 0 */
 
-#ifdef CONFIG_PMAC_PBOOK
 static void
 aty128_set_suspend(struct aty128fb_par *par, int suspend)
 {
@@ -2257,85 +2240,121 @@ aty128_set_suspend(struct aty128fb_par *
 	}
 }
 
-/*
- * Save the contents of the frame buffer when we go to sleep,
- * and restore it when we wake up again.
- */
-int
-aty128_sleep_notify(struct pmu_sleep_notifier *self, int when)
+static int
+aty128_pci_suspend(struct pci_dev *pdev, u32 state)
 {
- 	int nb;
-	struct fb_info *info = aty128_fb;
-	struct aty128fb_par *par;
+	struct fb_info *info = pci_get_drvdata(pdev);
+	struct aty128fb_par *par = info->par;
 
-	if (info == NULL)
-		return PBOOK_SLEEP_OK;
-	par = info->par;
-	nb = info->var.yres * info->fix.line_length;
-
-	switch (when) {
-	case PBOOK_SLEEP_REQUEST:
-		par->save_framebuffer = vmalloc(nb);
-		if (par->save_framebuffer == NULL)
-			return PBOOK_SLEEP_REFUSE;
-		break;
-	case PBOOK_SLEEP_REJECT:
-		if (par->save_framebuffer) {
-			vfree(par->save_framebuffer);
-			par->save_framebuffer = 0;
-		}
-		break;
-	case PBOOK_SLEEP_NOW:
-		wait_for_idle(par);
-		aty128_reset_engine(par);
-		wait_for_idle(par);
+	/* We don't do anything but D2, for now we return 0, but
+	 * we may want to change that. How do we know if the BIOS
+	 * can properly take care of D3 ? Also, with swsusp, we
+	 * know we'll be rebooted, ...
+	 */
+#ifdef CONFIG_PPC_PMAC
+	/* HACK ALERT ! Once I find a proper way to say to each driver
+	 * individually what will happen with it's PCI slot, I'll change
+	 * that. On laptops, the AGP slot is just unclocked, so D2 is
+	 * expected, while on desktops, the card is powered off
+	 */
+	if (state >= 3)
+		state = 2;
+#endif /* CONFIG_PPC_PMAC */
+	 
+	if (state != 2 || state == pdev->dev.power_state)
+		return 0;
 
-		/* Backup fb content */	
-		if (par->save_framebuffer)
-			memcpy_fromio(par->save_framebuffer,
-			       info->screen_base, nb);
-
-		/* Blank display and LCD */
-		aty128fb_blank(VESA_POWERDOWN, info);
-			
-		/* Sleep the chip */
+	printk(KERN_DEBUG "aty128fb: suspending...\n");
+	
+	acquire_console_sem();
+
+	fb_set_suspend(info, 1);
+
+	/* Setup dummy fb raster ops */
+	info->fbops->fb_fillrect 	= fb_dummy_fillrect;
+	info->fbops->fb_copyarea 	= fb_dummy_copyarea;
+	info->fbops->fb_imageblit	= fb_dummy_imageblit;
+	info->fbops->fb_cursor   	= fb_dummy_cursor;
+
+	/* Make sure engine is reset */
+	wait_for_idle(par);
+	aty128_reset_engine(par);
+	wait_for_idle(par);
+
+	/* Blank display and LCD */
+	aty128fb_blank(VESA_POWERDOWN, info);
+
+	/* Sleep */
+	par->asleep = 1;
+	par->lock_blank = 1;
+
+	/* We need a way to make sure the fbdev layer will _not_ touch the
+	 * framebuffer before we put the chip to suspend state. On 2.4, I
+	 * used dummy fb ops, 2.5 need proper support for this at the
+	 * fbdev level
+	 */
+	if (state == 2)
 		aty128_set_suspend(par, 1);
 
-		break;
-	case PBOOK_WAKE:
-		/* Wake the chip */
+	release_console_sem();
+
+	pdev->dev.power_state = state;
+
+	return 0;
+}
+
+static int
+aty128_pci_resume(struct pci_dev *pdev)
+{
+	struct fb_info *info = pci_get_drvdata(pdev);
+	struct aty128fb_par *par = info->par;
+
+	if (pdev->dev.power_state == 0)
+		return 0;
+
+	acquire_console_sem();
+
+	/* Wakeup chip */
+	if (pdev->dev.power_state == 2)
 		aty128_set_suspend(par, 0);
-		
-		aty128_reset_engine(par);
-		wait_for_idle(par);
+	par->asleep = 0;
 
-		/* Restore fb content */			
-		if (par->save_framebuffer) {
-			memcpy_toio(info->screen_base,
-			       par->save_framebuffer, nb);
-			vfree(par->save_framebuffer);
-			par->save_framebuffer = 0;
-		}
-		aty128fb_blank(0, info);
-		break;
-	}
-	return PBOOK_SLEEP_OK;
+	/* Restore display & engine */
+	aty128_reset_engine(par);
+	wait_for_idle(par);
+	aty128fb_set_par(info);
+	fb_pan_display(info, &info->var);
+	fb_set_cmap(&info->cmap, 1, info);
+
+	/* Restore fb raster ops */
+	info->fbops->fb_fillrect	= cfb_fillrect;
+	info->fbops->fb_copyarea	= cfb_copyarea;
+	info->fbops->fb_imageblit = cfb_imageblit;
+	info->fbops->fb_cursor   	= soft_cursor;
+
+	/* Refresh */
+	fb_set_suspend(info, 0);
+
+	/* Unblank */
+	par->lock_blank = 0;
+	aty128fb_blank(0, info);
+
+	release_console_sem();
+
+	pdev->dev.power_state = 0;
+
+	printk(KERN_DEBUG "aty128fb: resumed !\n");
+
+	return 0;
 }
-#endif /* CONFIG_PMAC_PBOOK */
 
 int __init aty128fb_init(void)
 {
-#ifdef CONFIG_PMAC_PBOOK
-	pmu_register_sleep_notifier(&aty128_sleep_notifier);
-#endif
 	return pci_module_init(&aty128fb_driver);
 }
 
 static void __exit aty128fb_exit(void)
 {
-#ifdef CONFIG_PMAC_PBOOK
-	pmu_unregister_sleep_notifier(&aty128_sleep_notifier);
-#endif
 	pci_unregister_driver(&aty128fb_driver);
 }
 
diff -purN /dev/shm/linux-2.5/drivers/video/aty/atyfb.h linuxppc-2.5-benh/drivers/video/aty/atyfb.h
--- /dev/shm/linux-2.5/drivers/video/aty/atyfb.h	2003-05-01 16:32:15.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/atyfb.h	2003-12-24 07:15:02.000000000 +0000
@@ -80,6 +80,7 @@ struct atyfb_par {
 	u8 mem_refresh_rate;
 	u8 blitter_may_be_busy;
 	u32 accel_flags;
+	u32 pseudo_palette[17];
 #ifdef __sparc__
 	struct pci_mmap_map *mmap_map;
 	u8 mmaped;
@@ -89,6 +90,9 @@ struct atyfb_par {
 	struct fb_info *next;
 	unsigned char *save_framebuffer;
 	unsigned long save_pll[64];
+	int pm_reg;
+	int crt_on, lcd_on;
+	u32 save_lcd_gen_cntl;
 #endif
 };
     
diff -purN /dev/shm/linux-2.5/drivers/video/aty/atyfb_base.c linuxppc-2.5-benh/drivers/video/aty/atyfb_base.c
--- /dev/shm/linux-2.5/drivers/video/aty/atyfb_base.c	2003-05-26 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/atyfb_base.c	2003-12-24 07:15:02.000000000 +0000
@@ -178,6 +178,10 @@ static void set_off_pitch(struct atyfb_p
 #ifdef CONFIG_PPC
 static int read_aty_sense(const struct atyfb_par *par);
 #endif
+#ifdef CONFIG_PMAC_PBOOK
+static void aty_set_crt_enable(struct atyfb_par *par, int on);
+static void aty_set_lcd_enable(struct atyfb_par *par, int on);
+#endif
 
 
     /*
@@ -211,6 +215,7 @@ static struct fb_ops atyfb_ops = {
 
 static char curblink __initdata = 1;
 static char noaccel __initdata = 0;
+static char mirror  __initdata = 0;
 static u32 default_vram __initdata = 0;
 static int default_pll __initdata = 0;
 static int default_mclk __initdata = 0;
@@ -403,8 +408,6 @@ static char ram_off[] __initdata = "OFF"
 #endif /* CONFIG_FB_ATY_CT */
 static char ram_resv[] __initdata = "RESV";
 
-static u32 pseudo_palette[17];
-
 #ifdef CONFIG_FB_ATY_GX
 static char *aty_gx_ram[8] __initdata = {
 	ram_dram, ram_vram, ram_vram, ram_dram,
@@ -860,6 +863,12 @@ static int atyfb_set_par(struct fb_info 
 			     var->bits_per_pixel,
 			     par->crtc.vxres * var->bits_per_pixel / 8);
 #endif				/* CONFIG_BOOTX_TEXT */
+#ifdef CONFIG_PMAC_PBOOK
+	if (M64_HAS(RESET_3D)) {
+		aty_set_crt_enable(par, par->crt_on);
+		aty_set_lcd_enable(par, par->lcd_on);
+	}
+#endif
 	return 0;
 }
 
@@ -1017,12 +1026,27 @@ struct atyclk {
 #define ATYIO_FEATW		0x41545903	/* ATY\03 */
 #endif
 
+#ifdef CONFIG_PMAC_PBOOK	/* LCD/CRT mirror */
+#define ATY_MIRROR_LCD_ON	0x00000001
+#define ATY_MIRROR_CRT_ON	0x00000002
+
+/* out param: u32*	mirror level: 0 to 3 */
+#define FBIO_ATY_GET_MIRROR	_IOR('@', 1, __u32*)
+/* in param: u32*	mirror level: 0 to 3 */
+#define FBIO_ATY_SET_MIRROR	_IOW('@', 2, __u32*)
+#endif
+
+
 static int atyfb_ioctl(struct inode *inode, struct file *file, u_int cmd,
 		       u_long arg, struct fb_info *info)
 {
-#if defined(__sparc__) || (defined(DEBUG) && defined(CONFIG_FB_ATY_CT))
+#if defined(__sparc__) || (defined(DEBUG) && defined(CONFIG_FB_ATY_CT)) || defined(CONFIG_PMAC_PBOOK)
 	struct atyfb_par *par = (struct atyfb_par *) info->par;
 #endif				/* __sparc__ || DEBUG */
+#ifdef CONFIG_PMAC_PBOOK
+	u32 value;
+	int rc;
+#endif
 #ifdef __sparc__
 	struct fbtype fbtyp;
 #endif
@@ -1102,6 +1126,29 @@ static int atyfb_ioctl(struct inode *ino
 			return -EFAULT;
 		break;
 #endif				/* DEBUG && CONFIG_FB_ATY_CT */
+#ifdef CONFIG_PMAC_PBOOK
+	case FBIO_ATY_SET_MIRROR:
+		if (!M64_HAS(RESET_3D)) 
+			return -EINVAL;
+		rc = get_user(value, (__u32*)arg);
+		if (rc) {
+			printk("atyfb_ioctl: get_user returned %d\n", rc);
+			return rc;
+		}
+
+		par->lcd_on = (value & 0x01) != 0;
+		par->crt_on = (value & 0x02) != 0;
+		if (!par->crt_on && !par->lcd_on)
+			par->lcd_on = 1;
+		aty_set_crt_enable(par, par->crt_on);	
+		aty_set_lcd_enable(par, par->lcd_on);	
+		break;
+	case FBIO_ATY_GET_MIRROR:
+		if (!M64_HAS(RESET_3D)) 
+			return -EINVAL;
+		value = (par->crt_on << 1) | par->lcd_on;
+		return put_user(value, (__u32*)arg);
+#endif /* CONFIG_PMAC_PBOOK */
 	default:
 		return -EINVAL;
 	}
@@ -1256,6 +1303,31 @@ static void atyfb_palette(int enter)
 
 #ifdef CONFIG_PMAC_PBOOK
 
+/*
+ * ++MSch: LCD/CRT mirror support
+ */
+ 
+static void aty_set_crt_enable(struct atyfb_par *par, int on)
+{
+	if (on) {
+		aty_st_lcd(LCD_GEN_CTRL,
+			   aty_ld_lcd(LCD_GEN_CTRL, par) | LCD_GCTL_CRT_ON, par);
+	} else
+		aty_st_lcd(LCD_GEN_CTRL,
+			   aty_ld_lcd(LCD_GEN_CTRL, par) & ~LCD_GCTL_CRT_ON, par);
+}
+ 
+static void aty_set_lcd_enable(struct atyfb_par *par, int on)
+{
+	if (on) {
+		aty_st_lcd(LCD_GEN_CTRL,
+			   aty_ld_lcd(LCD_GEN_CTRL, par) | LCD_GCTL_LCD_ON, par);
+	} else
+		aty_st_lcd(LCD_GEN_CTRL,
+			   aty_ld_lcd(LCD_GEN_CTRL, par) & ~LCD_GCTL_LCD_ON, par);
+}
+ 
+
 static struct fb_info *first_display = NULL;
 
 /* Power management routines. Those are used for PowerBook sleep.
@@ -1412,6 +1484,16 @@ static int aty_sleep_notify(struct pmu_s
 			}
 			break;
 		case PBOOK_SLEEP_NOW:
+			acquire_console_sem();
+
+			fb_set_suspend(info, 1);
+
+			/* Setup dummy fb raster ops */
+			info->fbops->fb_fillrect 	= fb_dummy_fillrect;
+			info->fbops->fb_copyarea 	= fb_dummy_copyarea;
+			info->fbops->fb_imageblit	= fb_dummy_imageblit;
+			info->fbops->fb_cursor   	= fb_dummy_cursor;
+
 			if (par->blitter_may_be_busy)
 				wait_for_idle(par);
 			/* Stop accel engine (stop bus mastering) */
@@ -1428,9 +1510,13 @@ static int aty_sleep_notify(struct pmu_s
 
 			/* Set chip to "suspend" mode */
 			result = aty_power_mgmt(1, par);
+
+			release_console_sem();
 			break;
 		case PBOOK_WAKE:
 			/* Wakeup chip */
+			acquire_console_sem();
+
 			result = aty_power_mgmt(0, par);
 
 			/* Restore fb content */
@@ -1440,9 +1526,21 @@ static int aty_sleep_notify(struct pmu_s
 				vfree(par->save_framebuffer);
 				par->save_framebuffer = 0;
 			}
+
+			/* Restore fb raster ops */
+			info->fbops->fb_fillrect	= atyfb_fillrect;
+			info->fbops->fb_copyarea	= atyfb_copyarea;
+			info->fbops->fb_imageblit 	= atyfb_imageblit;
+			info->fbops->fb_cursor   	= soft_cursor;
+
+			/* Refresh */
+			fb_set_suspend(info, 0);
+
 			/* Restore display */
 			atyfb_set_par(info);
 			atyfb_blank(0, info);
+
+			release_console_sem();
 			break;
 		}
 	}
@@ -1789,9 +1887,60 @@ static int __init aty_init(struct fb_inf
 		  info->fix.smem_len);
 
 	info->fbops = &atyfb_ops;
-	info->pseudo_palette = pseudo_palette;
+	info->pseudo_palette = par->pseudo_palette;
 	info->flags = FBINFO_FLAG_DEFAULT;
 
+#ifdef CONFIG_PMAC_PBOOK
+	/* set up initial output to LCD only, unless OF set CRTC1 to the external port */
+	par->lcd_on=1;
+	par->crt_on=1;
+
+	if (M64_HAS(RESET_3D)) {
+		int lcd_src = aty_ld_le32(LCD_INDEX, par) & LCD_SRC_SEL;
+#ifdef DEBUG
+		printk("atyfb: LCD_INDEX: %d \n", aty_ld_le32(LCD_INDEX, par));
+		printk("atyfb: LCD_GEN_CTRL: %08x \n", aty_ld_lcd(LCD_GEN_CTRL, par));
+#endif
+		if (lcd_src || mirror ||
+		    (aty_ld_lcd(LCD_GEN_CTRL, par) & LCD_GCTL_CRT_ON)) {
+			u32 h_tot_disp, h_start_width, v_tot_disp;
+			u32 v_start_width, off_pitch;
+
+			par->crt_on=1;
+			printk("atyfb: switching LCD to primary CRTC \n");
+			/* LCD source is CRTC1 */
+			aty_st_le32(LCD_INDEX,
+				    aty_ld_le32(LCD_INDEX, par) & ~LCD_SRC_SEL, par);
+			/* set LCD_GEN_CNTL as OF on LCD boot (xcept CRTC_RW_SEL is cleared):  */ 
+			aty_st_lcd(LCD_GEN_CTRL,
+				   (aty_ld_lcd(LCD_GEN_CTRL, par) &
+				    ~(LCD_GCTL_CRTC_RW_SEL | LCD_GCTL_SHADOW_RW_EN)), par);
+			/* DAC1 source is CRTC1 */
+			aty_st_le32(DAC_CNTL, (aty_ld_le32(DAC_CNTL, par) & ~0x10) |
+				    0x01001000, par);
+			/* copy CRTC1 to CRTC2 if CRTC2 unset */
+			h_tot_disp = aty_ld_le32(CRTC_H_TOTAL_DISP, par);
+			v_tot_disp = aty_ld_le32(CRTC_V_TOTAL_DISP, par);
+			h_start_width = aty_ld_le32(CRTC_H_SYNC_STRT_WID, par);
+			v_start_width = aty_ld_le32(CRTC_V_SYNC_STRT_WID, par);
+			off_pitch = aty_ld_le32(CRTC_OFF_PITCH, par);
+			/* select second CRTC register set */ 
+			aty_st_lcd(LCD_GEN_CTRL, aty_ld_lcd(LCD_GEN_CTRL, par) |
+				   LCD_GCTL_CRTC_RW_SEL, par);
+			aty_st_le32(CRTC_H_TOTAL_DISP, h_tot_disp, par);
+			aty_st_le32(CRTC_V_TOTAL_DISP, v_tot_disp, par);
+			aty_st_le32(CRTC_H_SYNC_STRT_WID, h_start_width, par);
+			aty_st_le32(CRTC_V_SYNC_STRT_WID, v_start_width, par);
+			aty_st_le32(CRTC_OFF_PITCH, off_pitch, par);
+			/* select first CRTC register set */ 
+			aty_st_lcd(LCD_GEN_CTRL, aty_ld_lcd(LCD_GEN_CTRL, par) &
+				   ~LCD_GCTL_CRTC_RW_SEL, par);
+		}
+		aty_set_crt_enable(par, par->crt_on);
+		aty_set_lcd_enable(par, par->lcd_on);
+	}
+#endif /* CONFIG_PMAC_PBOOK */
+
 #ifdef CONFIG_PMAC_BACKLIGHT
 	if (M64_HAS(G3_PB_1_1) && machine_is_compatible("PowerBook1,1")) {
 		/* these bits let the 101 powerbook wake up from sleep -- paulus */
@@ -2293,7 +2442,8 @@ int __init atyfb_init(void)
 			if (first_display == NULL)
 				pmu_register_sleep_notifier(&aty_sleep_notifier);
 			default_par->next = first_display;
-#endif
+			first_display = info;
+#endif /* CONFIG_PMAC_PBOOK */
 		}
 	}
 
@@ -2382,6 +2532,8 @@ int __init atyfb_setup(char *options)
 			curblink = 0;
 		} else if (!strncmp(this_opt, "noaccel", 7)) {
 			noaccel = 1;
+		} else if (!strncmp(this_opt, "mirror", 6)) {
+			mirror = 1;
 		} else if (!strncmp(this_opt, "vram:", 5))
 			default_vram =
 			    simple_strtoul(this_opt + 5, NULL, 0);
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeon_accel.c linuxppc-2.5-benh/drivers/video/aty/radeon_accel.c
--- /dev/shm/linux-2.5/drivers/video/aty/radeon_accel.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeon_accel.c	2004-01-30 00:13:26.000000000 +0000
@@ -0,0 +1,280 @@
+#include "radeonfb.h"
+
+/* the accelerated functions here are patterned after the 
+ * "ACCEL_MMIO" ifdef branches in XFree86
+ * --dte
+ */
+static void radeonfb_prim_fillrect(struct radeonfb_info *rinfo, 
+				   const struct fb_fillrect *region)
+{
+	radeon_fifo_wait(4);  
+  
+	OUTREG(DP_GUI_MASTER_CNTL,  
+		rinfo->dp_gui_master_cntl  /* contains, like GMC_DST_32BPP */
+                | GMC_BRUSH_SOLID_COLOR
+                | ROP3_P);
+	OUTREG(DP_BRUSH_FRGD_CLR, region->color);
+	OUTREG(DP_WRITE_MSK, 0xffffffff);
+	OUTREG(DP_CNTL, (DST_X_LEFT_TO_RIGHT | DST_Y_TOP_TO_BOTTOM));
+
+	radeon_fifo_wait(2);  
+	OUTREG(DST_Y_X, (region->dy << 16) | region->dx);
+	OUTREG(DST_WIDTH_HEIGHT, (region->width << 16) | region->height);
+}
+
+void radeonfb_fillrect(struct fb_info *info, const struct fb_fillrect *region)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)info;
+	struct fb_fillrect modded;
+	int vxres, vyres;
+  
+	if (radeon_accel_disabled()) {
+		cfb_fillrect(info, region);
+		return;
+	}
+
+	vxres = info->var.xres;
+	vyres = info->var.yres;
+
+	memcpy(&modded, region, sizeof(struct fb_fillrect));
+
+	if(!modded.width || !modded.height ||
+	   modded.dx >= vxres || modded.dy >= vyres)
+		return;
+  
+	if(modded.dx + modded.width  > vxres) modded.width  = vxres - modded.dx;
+	if(modded.dy + modded.height > vyres) modded.height = vyres - modded.dy;
+
+	radeonfb_prim_fillrect(rinfo, &modded);
+}
+
+static void radeonfb_prim_copyarea(struct radeonfb_info *rinfo, 
+				   const struct fb_copyarea *area)
+{
+	radeon_fifo_wait(3);
+	OUTREG(DP_GUI_MASTER_CNTL,
+		rinfo->dp_gui_master_cntl /* i.e. GMC_DST_32BPP */
+		| GMC_SRC_DSTCOLOR
+		| ROP3_S 
+		| DP_SRC_RECT );
+	OUTREG(DP_WRITE_MSK, 0xffffffff);
+	OUTREG(DP_CNTL, (DST_X_LEFT_TO_RIGHT | DST_Y_TOP_TO_BOTTOM));
+
+	radeon_fifo_wait(3);
+	OUTREG(SRC_Y_X, (area->sy << 16) | area->sx);
+	OUTREG(DST_Y_X, (area->dy << 16) | area->dx);
+	OUTREG(DST_HEIGHT_WIDTH, (area->height << 16) | area->width);
+}
+
+
+void radeonfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)info;
+	struct fb_copyarea modded;
+	u32 vxres, vyres;
+	modded.sx = area->sx;
+	modded.sy = area->sy;
+	modded.dx = area->dx;
+	modded.dy = area->dy;
+	modded.width  = area->width;
+	modded.height = area->height;
+  
+	if (radeon_accel_disabled()) {
+		cfb_copyarea(info, area);
+		return;
+	}
+
+	vxres = info->var.xres;
+	vyres = info->var.yres;
+
+	if(!modded.width || !modded.height ||
+	   modded.sx >= vxres || modded.sy >= vyres ||
+	   modded.dx >= vxres || modded.dy >= vyres)
+		return;
+  
+	if(modded.sx + modded.width > vxres)  modded.width = vxres - modded.sx;
+	if(modded.dx + modded.width > vxres)  modded.width = vxres - modded.dx;
+	if(modded.sy + modded.height > vyres) modded.height = vyres - modded.sy;
+	if(modded.dy + modded.height > vyres) modded.height = vyres - modded.dy;
+  
+	radeonfb_prim_copyarea(rinfo, &modded);
+}
+
+void radeonfb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)info;
+
+	radeon_engine_idle();
+
+	cfb_imageblit(info, image);
+}
+
+int radeonfb_sync(struct fb_info *info)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)info;
+
+	radeon_engine_idle();
+
+	return 0;
+}
+
+void radeon_engine_reset(struct radeonfb_info *rinfo)
+{
+	u32 clock_cntl_index, mclk_cntl, rbbm_soft_reset;
+	u32 host_path_cntl;
+
+	radeon_engine_flush (rinfo);
+
+    	/* Some ASICs have bugs with dynamic-on feature, which are  
+     	 * ASIC-version dependent, so we force all blocks on for now
+     	 * -- from XFree86
+     	 * We don't do that on macs, things just work here with dynamic
+     	 * clocking... --BenH
+	 */
+#ifdef CONFIG_ALL_PPC
+	if (_machine != _MACH_Pmac && rinfo->hasCRTC2)
+#else
+	if (rinfo->has_CRTC2)
+#endif	
+	{
+		u32 tmp;
+
+		tmp = INPLL(SCLK_CNTL);
+		OUTPLL(SCLK_CNTL, ((tmp & ~DYN_STOP_LAT_MASK) |
+				   CP_MAX_DYN_STOP_LAT |
+				   SCLK_FORCEON_MASK));
+
+		if (rinfo->family == CHIP_FAMILY_RV200)
+		{
+			tmp = INPLL(SCLK_MORE_CNTL);
+			OUTPLL(SCLK_MORE_CNTL, tmp | SCLK_MORE_FORCEON);
+		}
+	}
+
+	clock_cntl_index = INREG(CLOCK_CNTL_INDEX);
+	mclk_cntl = INPLL(MCLK_CNTL);
+
+	OUTPLL(MCLK_CNTL, (mclk_cntl |
+			   FORCEON_MCLKA |
+			   FORCEON_MCLKB |
+			   FORCEON_YCLKA |
+			   FORCEON_YCLKB |
+			   FORCEON_MC |
+			   FORCEON_AIC));
+
+	host_path_cntl = INREG(HOST_PATH_CNTL);
+	rbbm_soft_reset = INREG(RBBM_SOFT_RESET);
+
+	if (rinfo->family == CHIP_FAMILY_R300 ||
+	    rinfo->family == CHIP_FAMILY_R350 ||
+	    rinfo->family == CHIP_FAMILY_RV350) {
+		u32 tmp;
+
+		OUTREG(RBBM_SOFT_RESET, (rbbm_soft_reset |
+					 SOFT_RESET_CP |
+					 SOFT_RESET_HI |
+					 SOFT_RESET_E2));
+		INREG(RBBM_SOFT_RESET);
+		OUTREG(RBBM_SOFT_RESET, 0);
+		tmp = INREG(RB2D_DSTCACHE_MODE);
+		OUTREG(RB2D_DSTCACHE_MODE, tmp | (1 << 17)); /* FIXME */
+	} else {
+		OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset |
+					SOFT_RESET_CP |
+					SOFT_RESET_HI |
+					SOFT_RESET_SE |
+					SOFT_RESET_RE |
+					SOFT_RESET_PP |
+					SOFT_RESET_E2 |
+					SOFT_RESET_RB);
+		INREG(RBBM_SOFT_RESET);
+		OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset & (u32)
+					~(SOFT_RESET_CP |
+					  SOFT_RESET_HI |
+					  SOFT_RESET_SE |
+					  SOFT_RESET_RE |
+					  SOFT_RESET_PP |
+					  SOFT_RESET_E2 |
+					  SOFT_RESET_RB));
+		INREG(RBBM_SOFT_RESET);
+	}
+
+	OUTREG(HOST_PATH_CNTL, host_path_cntl | HDP_SOFT_RESET);
+	INREG(HOST_PATH_CNTL);
+	OUTREG(HOST_PATH_CNTL, host_path_cntl);
+
+	if (rinfo->family != CHIP_FAMILY_R300 ||
+	    rinfo->family != CHIP_FAMILY_R350 ||
+	    rinfo->family != CHIP_FAMILY_RV350)
+		OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset);
+
+	OUTREG(CLOCK_CNTL_INDEX, clock_cntl_index);
+	OUTPLL(MCLK_CNTL, mclk_cntl);
+	if (rinfo->R300_cg_workaround)
+		R300_cg_workardound(rinfo);
+}
+
+void radeon_engine_init (struct radeonfb_info *rinfo)
+{
+	unsigned long temp;
+
+	/* disable 3D engine */
+	OUTREG(RB3D_CNTL, 0);
+
+	radeon_engine_reset(rinfo);
+
+	radeon_fifo_wait (1);
+	if ((rinfo->family != CHIP_FAMILY_R300) &&
+	    (rinfo->family != CHIP_FAMILY_R350) &&
+	    (rinfo->family != CHIP_FAMILY_RV350))
+		OUTREG(RB2D_DSTCACHE_MODE, 0);
+
+	radeon_fifo_wait (3);
+	/* We re-read MC_FB_LOCATION from card as it can have been
+	 * modified by XFree drivers (ouch !)
+	 */
+	rinfo->fb_local_base = INREG(MC_FB_LOCATION) << 16;
+
+	OUTREG(DEFAULT_PITCH_OFFSET, (rinfo->pitch << 0x16) |
+				     (rinfo->fb_local_base >> 10));
+	OUTREG(DST_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
+	OUTREG(SRC_PITCH_OFFSET, (rinfo->pitch << 0x16) | (rinfo->fb_local_base >> 10));
+
+	radeon_fifo_wait (1);
+#if defined(__BIG_ENDIAN)
+	OUTREGP(DP_DATATYPE, HOST_BIG_ENDIAN_EN, ~HOST_BIG_ENDIAN_EN);
+#else
+	OUTREGP(DP_DATATYPE, 0, ~HOST_BIG_ENDIAN_EN);
+#endif
+	radeon_fifo_wait (2);
+	OUTREG(DEFAULT_SC_TOP_LEFT, 0);
+	OUTREG(DEFAULT_SC_BOTTOM_RIGHT, (DEFAULT_SC_RIGHT_MAX |
+					 DEFAULT_SC_BOTTOM_MAX));
+
+	temp = radeon_get_dstbpp(rinfo->depth);
+	rinfo->dp_gui_master_cntl = ((temp << 8) | GMC_CLR_CMP_CNTL_DIS);
+
+	radeon_fifo_wait (1);
+	OUTREG(DP_GUI_MASTER_CNTL, (rinfo->dp_gui_master_cntl |
+				    GMC_BRUSH_SOLID_COLOR |
+				    GMC_SRC_DATATYPE_COLOR));
+
+	radeon_fifo_wait (7);
+
+	/* clear line drawing regs */
+	OUTREG(DST_LINE_START, 0);
+	OUTREG(DST_LINE_END, 0);
+
+	/* set brush color regs */
+	OUTREG(DP_BRUSH_FRGD_CLR, 0xffffffff);
+	OUTREG(DP_BRUSH_BKGD_CLR, 0x00000000);
+
+	/* set source color regs */
+	OUTREG(DP_SRC_FRGD_CLR, 0xffffffff);
+	OUTREG(DP_SRC_BKGD_CLR, 0x00000000);
+
+	/* default write mask */
+	OUTREG(DP_WRITE_MSK, 0xffffffff);
+
+	radeon_engine_idle ();
+}
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeon_base.c linuxppc-2.5-benh/drivers/video/aty/radeon_base.c
--- /dev/shm/linux-2.5/drivers/video/aty/radeon_base.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeon_base.c	2004-02-04 20:25:45.000000000 +0000
@@ -0,0 +1,2385 @@
+/*
+ *	drivers/video/radeonfb.c
+ *	framebuffer driver for ATI Radeon chipset video boards
+ *
+ *	Copyright 2003	Ben. Herrenschmidt <benh@kernel.crashing.org>
+ *	Copyright 2000	Ani Joshi <ajoshi@kernel.crashing.org>
+ *
+ *	i2c bits from Luca Tettamanti <kronos@kronoz.cjb.net>
+ *	
+ *	Special thanks to ATI DevRel team for their hardware donations.
+ *
+ *	...Insert GPL boilerplate here...
+ *
+ *	Significant portions of this driver apdated from XFree86 Radeon
+ *	driver which has the following copyright notice:
+ *
+ *	Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
+ *                     VA Linux Systems Inc., Fremont, California.
+ *
+ *	All Rights Reserved.
+ *
+ *	Permission is hereby granted, free of charge, to any person obtaining
+ *	a copy of this software and associated documentation files (the
+ *	"Software"), to deal in the Software without restriction, including
+ *	without limitation on the rights to use, copy, modify, merge,
+ *	publish, distribute, sublicense, and/or sell copies of the Software,
+ *	and to permit persons to whom the Software is furnished to do so,
+ *	subject to the following conditions:
+ *
+ *	The above copyright notice and this permission notice (including the
+ *	next paragraph) shall be included in all copies or substantial
+ *	portions of the Software.
+ *
+ *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * 	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ *	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *	NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
+ *	THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ *	DEALINGS IN THE SOFTWARE.
+ *
+ *	XFree86 driver authors:
+ *
+ *	   Kevin E. Martin <martin@xfree86.org>
+ *	   Rickard E. Faith <faith@valinux.com>
+ *	   Alan Hourihane <alanh@fairlite.demon.co.uk>
+ *
+ */
+
+
+#define RADEON_VERSION	"0.2.0"
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/vmalloc.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_PPC_OF
+
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include "../macmodes.h"
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+#include <asm/backlight.h>
+#endif
+
+#ifdef CONFIG_BOOTX_TEXT
+#include <asm/btext.h>
+#endif
+
+#endif /* CONFIG_PPC_OF */
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include <video/radeon.h>
+#include <linux/radeonfb.h>
+
+#include "../edid.h" // MOVE THAT TO include/video
+#include "ati_ids.h"
+#include "radeonfb.h"		    
+
+
+#define CHIP_DEF(id, family, flags)					\
+	{ PCI_VENDOR_ID_ATI, id, PCI_ANY_ID, PCI_ANY_ID, 0, 0, (flags) | (CHIP_FAMILY_##family) }
+
+static struct pci_device_id radeonfb_pci_table[] = {
+	/* Mobility M6 */
+	CHIP_DEF(PCI_CHIP_RADEON_LY, 	RV100,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RADEON_LZ,	RV100,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	/* Radeon VE/7000 */
+	CHIP_DEF(PCI_CHIP_RV100_QY, 	RV100,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV100_QZ, 	RV100,	CHIP_HAS_CRTC2),
+	/* Radeon IGP320M (U1) */
+	CHIP_DEF(PCI_CHIP_RS100_4336,	RS100,	CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),
+	/* Radeon IGP320 (A3) */
+	CHIP_DEF(PCI_CHIP_RS100_4136,	RS100,	CHIP_HAS_CRTC2 | CHIP_IS_IGP), 
+	/* IGP330M/340M/350M (U2) */
+	CHIP_DEF(PCI_CHIP_RS200_4337,	RS200,	CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),
+	/* IGP330/340/350 (A4) */
+	CHIP_DEF(PCI_CHIP_RS200_4137,	RS200,	CHIP_HAS_CRTC2 | CHIP_IS_IGP),
+	/* Mobility 7000 IGP */
+	CHIP_DEF(PCI_CHIP_RS250_4437,	RS200,	CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),
+	/* 7000 IGP (A4+) */
+	CHIP_DEF(PCI_CHIP_RS250_4237,	RS200,	CHIP_HAS_CRTC2 | CHIP_IS_IGP),
+	/* 8500 AIW */
+	CHIP_DEF(PCI_CHIP_R200_BB,	R200,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R200_BC,	R200,	CHIP_HAS_CRTC2),
+	/* 8700/8800 */
+	CHIP_DEF(PCI_CHIP_R200_QH,	R200,	CHIP_HAS_CRTC2),
+	/* 8500 */
+	CHIP_DEF(PCI_CHIP_R200_QL,	R200,	CHIP_HAS_CRTC2),
+	/* 9100 */
+	CHIP_DEF(PCI_CHIP_R200_QM,	R200,	CHIP_HAS_CRTC2),
+	/* Mobility M7 */
+	CHIP_DEF(PCI_CHIP_RADEON_LW,	RV200,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RADEON_LW,	RV200,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	/* 7500 */
+	CHIP_DEF(PCI_CHIP_RV200_QW,	RV200,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV200_QX,	RV200,	CHIP_HAS_CRTC2),
+	/* Mobility M9 */
+	CHIP_DEF(PCI_CHIP_RV250_Ld,	RV250,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV250_Le,	RV250,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV250_Lf,	RV250,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV250_Lg,	RV250,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	/* 9000/Pro */
+	CHIP_DEF(PCI_CHIP_RV250_If,	RV250,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV250_Ig,	RV250,	CHIP_HAS_CRTC2),
+	/* Mobility 9100 IGP (U3) */
+	CHIP_DEF(PCI_CHIP_RS300_5835,	RS300,	CHIP_HAS_CRTC2 | CHIP_IS_IGP | CHIP_IS_MOBILITY),
+	/* 9100 IGP (A5) */
+	CHIP_DEF(PCI_CHIP_RS300_5834,	RS300,	CHIP_HAS_CRTC2 | CHIP_IS_IGP),
+	/* Mobility 9200 (M9+) */
+	CHIP_DEF(PCI_CHIP_RV280_5C61,	RV280,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV280_5C63,	RV280,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	/* 9200 */
+	CHIP_DEF(PCI_CHIP_RV280_5960,	RV280,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV280_5961,	RV280,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV280_5962,	RV280,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV280_5964,	RV280,	CHIP_HAS_CRTC2),
+	/* 9500 */
+	CHIP_DEF(PCI_CHIP_R300_AD,	R300,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R300_AE,	R300,	CHIP_HAS_CRTC2),
+	/* 9600TX / FireGL Z1 */
+	CHIP_DEF(PCI_CHIP_R300_AF,	R300,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R300_AG,	R300,	CHIP_HAS_CRTC2),
+	/* 9700/9500/Pro/FireGL X1 */
+	CHIP_DEF(PCI_CHIP_R300_ND,	R300,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R300_NE,	R300,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R300_NF,	R300,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R300_NG,	R300,	CHIP_HAS_CRTC2),
+	/* Mobility M10/M11 */
+	CHIP_DEF(PCI_CHIP_RV350_NP,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV350_NQ,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV350_NR,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV350_NS,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV350_NT,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	CHIP_DEF(PCI_CHIP_RV350_NV,	RV350,	CHIP_HAS_CRTC2 | CHIP_IS_MOBILITY),
+	/* 9600/FireGL T2 */
+	CHIP_DEF(PCI_CHIP_RV350_AP,	RV350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV350_AQ,	RV350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV360_AR,	RV350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV350_AS,	RV350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV350_AT,	RV350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_RV350_AV,	RV350,	CHIP_HAS_CRTC2),
+	/* 9800/Pro/FileGL X2 */
+	CHIP_DEF(PCI_CHIP_R350_AH,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_AI,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_AJ,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_AK,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_NH,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_NI,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R360_NJ,	R350,	CHIP_HAS_CRTC2),
+	CHIP_DEF(PCI_CHIP_R350_NK,	R350,	CHIP_HAS_CRTC2),
+	/* Original Radeon/7200 */
+	CHIP_DEF(PCI_CHIP_RADEON_QD,	RADEON,	0),
+	CHIP_DEF(PCI_CHIP_RADEON_QE,	RADEON,	0),
+	CHIP_DEF(PCI_CHIP_RADEON_QF,	RADEON,	0),
+	CHIP_DEF(PCI_CHIP_RADEON_QG,	RADEON,	0),
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, radeonfb_pci_table);
+
+
+typedef struct {
+	u16 reg;
+	u32 val;
+} reg_val;
+
+
+/* these common regs are cleared before mode setting so they do not
+ * interfere with anything
+ */
+reg_val common_regs[] = {
+	{ OVR_CLR, 0 },	
+	{ OVR_WID_LEFT_RIGHT, 0 },
+	{ OVR_WID_TOP_BOTTOM, 0 },
+	{ OV0_SCALE_CNTL, 0 },
+	{ SUBPIC_CNTL, 0 },
+	{ VIPH_CONTROL, 0 },
+	{ I2C_CNTL_1, 0 },
+	{ GEN_INT_CNTL, 0 },
+	{ CAP0_TRIG_CNTL, 0 },
+};
+
+reg_val common_regs_m6[] = {
+	{ OVR_CLR,      0 },
+	{ OVR_WID_LEFT_RIGHT,   0 },
+	{ OVR_WID_TOP_BOTTOM,   0 },
+	{ OV0_SCALE_CNTL,   0 },
+	{ SUBPIC_CNTL,      0 },
+	{ GEN_INT_CNTL,     0 },
+	{ CAP0_TRIG_CNTL,   0 } 
+};
+
+/*
+ * globals
+ */
+        
+static char *mode_option;
+static char *monitor_layout;
+static int noaccel = 0;
+static int nomodeset = 0;
+static int ignore_edid = 0;
+static int mirror = 0;
+static int panel_yres = 0;
+static int force_dfp = 0;
+static int force_measure_pll = 0;
+#ifdef CONFIG_MTRR
+static int nomtrr = 0;
+#endif
+
+int radeonfb_noaccel = 0;
+
+/*
+ * prototypes
+ */
+
+
+#ifdef CONFIG_PPC_OF
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+static int radeon_set_backlight_enable(int on, int level, void *data);
+static int radeon_set_backlight_level(int level, void *data);
+static struct backlight_controller radeon_backlight_controller = {
+	radeon_set_backlight_enable,
+	radeon_set_backlight_level
+};
+#endif /* CONFIG_PMAC_BACKLIGHT */
+
+#endif /* CONFIG_PPC_OF */
+
+static void __devexit radeon_unmap_ROM(struct radeonfb_info *rinfo, struct pci_dev *dev)
+{
+	// leave it disabled and unassigned
+	struct resource *r = &dev->resource[PCI_ROM_RESOURCE];
+	
+	if (!rinfo->bios_seg)
+		return;
+	iounmap(rinfo->bios_seg);
+	
+	/* Release the ROM resource if we used it in the first place */
+	if (r->parent && r->flags & PCI_ROM_ADDRESS_ENABLE) {
+		release_resource(r);
+		r->flags &= ~PCI_ROM_ADDRESS_ENABLE;
+		r->end -= r->start;
+		r->start = 0;
+	}
+	/* This will disable and set address to unassigned */
+	pci_write_config_dword(dev, dev->rom_base_reg, 0);
+}
+
+static int __devinit radeon_map_ROM(struct radeonfb_info *rinfo, struct pci_dev *dev)
+{
+	void *rom;
+	struct resource *r;
+	u16 dptr;
+	u8 rom_type;
+
+	/* If this is a primary card, there is a shadow copy of the
+	 * ROM somewhere in the first meg. We will just ignore the copy
+	 * and use the ROM directly.
+	 */
+    
+    	/* Fix from ATI for problem with Radeon hardware not leaving ROM enabled */
+    	unsigned int temp;
+	temp = INREG(MPP_TB_CONFIG);
+	temp &= 0x00ffffffu;
+	temp |= 0x04 << 24;
+	OUTREG(MPP_TB_CONFIG, temp);
+	temp = INREG(MPP_TB_CONFIG);
+                                                                                                          
+	/* no need to search for the ROM, just ask the card where it is. */
+	r = &dev->resource[PCI_ROM_RESOURCE];
+	
+	/* assign the ROM an address if it doesn't have one */
+	if (r->parent == NULL)
+		pci_assign_resource(dev, PCI_ROM_RESOURCE);
+	
+	/* enable if needed */
+	if (!(r->flags & PCI_ROM_ADDRESS_ENABLE)) {
+		pci_write_config_dword(dev, dev->rom_base_reg,
+				       r->start | PCI_ROM_ADDRESS_ENABLE);
+		r->flags |= PCI_ROM_ADDRESS_ENABLE;
+	}
+	
+	rom = ioremap(r->start, r->end - r->start + 1);
+	if (!rom) {
+		printk(KERN_ERR "radeonfb: ROM failed to map\n");
+		return -ENOMEM;
+	}
+	
+	rinfo->bios_seg = rom;
+
+	/* Very simple test to make sure it appeared */
+	if (BIOS_IN16(0) != 0xaa55) {
+		printk(KERN_ERR "radeonfb: Invalid ROM signature %x should be 0xaa55\n",
+		       BIOS_IN16(0));
+		goto failed;
+	}
+	/* Look for the PCI data to check the ROM type */
+	dptr = BIOS_IN16(0x18);
+
+	/* Check the PCI data signature. If it's wrong, we still assume a normal x86 ROM
+	 * for now, until I've verified this works everywhere. The goal here is more
+	 * to phase out Open Firmware images.
+	 *
+	 * Currently, we only look at the first PCI data, we could iteratre and deal with
+	 * them all, and we should use fb_bios_start relative to start of image and not
+	 * relative start of ROM, but so far, I never found a dual-image ATI card
+	 *
+	 * typedef struct {
+	 * 	u32	signature;	+ 0x00
+	 * 	u16	vendor;		+ 0x04
+	 * 	u16	device;		+ 0x06
+	 * 	u16	reserved_1;	+ 0x08
+	 * 	u16	dlen;		+ 0x0a
+	 * 	u8	drevision;	+ 0x0c
+	 * 	u8	class_hi;	+ 0x0d
+	 * 	u16	class_lo;	+ 0x0e
+	 * 	u16	ilen;		+ 0x10
+	 * 	u16	irevision;	+ 0x12
+	 * 	u8	type;		+ 0x14
+	 * 	u8	indicator;	+ 0x15
+	 * 	u16	reserved_2;	+ 0x16
+	 * } pci_data_t;
+	 */
+	if (BIOS_IN32(dptr) !=  (('R' << 24) | ('I' << 16) | ('C' << 8) | 'P')) {
+		printk(KERN_WARNING "radeonfb: PCI DATA signature in ROM incorrect: %08x\n",
+		       BIOS_IN32(dptr));
+		goto anyway;
+	}
+	rom_type = BIOS_IN8(dptr + 0x14);
+	switch(rom_type) {
+	case 0:
+		printk(KERN_INFO "radeonfb: Found Intel x86 BIOS ROM Image\n");
+		break;
+	case 1:
+		printk(KERN_INFO "radeonfb: Found Open Firmware ROM Image\n");
+		goto failed;
+	case 2:
+		printk(KERN_INFO "radeonfb: Found HP PA-RISC ROM Image\n");
+		goto failed;
+	default:
+		printk(KERN_INFO "radeonfb: Found unknown type %d ROM Image\n", rom_type);
+		goto failed;
+	}
+ anyway:
+	/* Locate the flat panel infos, do some sanity checking !!! */
+	rinfo->fp_bios_start = BIOS_IN16(0x48);
+	return 0;
+
+ failed:
+	rinfo->bios_seg = NULL;
+	radeon_unmap_ROM(rinfo, dev);
+	return -ENXIO;
+}
+
+#ifdef __i386__
+static int  __devinit radeon_find_mem_vbios(struct radeonfb_info *rinfo)
+{
+	/* I simplified this code as we used to miss the signatures in
+	 * a lot of case. It's now closer to XFree, we just don't check
+	 * for signatures at all... Something better will have to be done
+	 * if we end up having conflicts
+	 */
+        u32  segstart;
+        unsigned char *rom_base = NULL;
+                                                
+        for(segstart=0x000c0000; segstart<0x000f0000; segstart+=0x00001000) {
+                rom_base = (char *)ioremap(segstart, 0x10000);
+		if (rom_base == NULL)
+			return -ENOMEM;
+                if ((*rom_base == 0x55) && (((*(rom_base + 1)) & 0xff) == 0xaa))
+	                break;
+                iounmap(rom_base);
+		rom_base = NULL;
+        }
+	if (rom_base == NULL)
+		return -ENXIO;
+
+	/* Locate the flat panel infos, do some sanity checking !!! */
+	rinfo->bios_seg = rom_base;
+	rinfo->fp_bios_start = BIOS_IN16(0x48);
+
+	return 0;
+}
+#endif /* __i386__ */
+
+#ifdef CONFIG_PPC_OF
+/*
+ * Read XTAL (ref clock), SCLK and MCLK from Open Firmware device
+ * tree. Hopefully, ATI OF driver is kind enough to fill these
+ */
+static int __devinit radeon_read_xtal_OF (struct radeonfb_info *rinfo)
+{
+	struct device_node *dp;
+	u32 *val;
+
+	dp = pci_device_to_OF_node(rinfo->pdev);
+	if (dp == NULL) {
+		printk(KERN_WARNING "radeonfb: Cannot match card to OF node !\n");
+		return -ENODEV;
+	}
+	val = (u32 *) get_property(dp, "ATY,RefCLK", 0);
+	if (!val || !*val) {
+		printk(KERN_WARNING "radeonfb: No ATY,RefCLK property !\n");
+		return -EINVAL;
+	}
+
+	rinfo->pll.ref_clk = (*val) / 10;
+
+	val = (u32 *) get_property(dp, "ATY,SCLK", 0);
+	if (val && *val)
+		rinfo->pll.sclk = (*val) / 10;
+
+	val = (u32 *) get_property(dp, "ATY,MCLK", 0);
+	if (val && *val)
+		rinfo->pll.mclk = (*val) / 10;
+
+       	return 0;
+}
+#endif /* CONFIG_PPC_OF */
+
+/*
+ * Read PLL infos from chip registers
+ */
+static int __devinit radeon_probe_pll_params(struct radeonfb_info *rinfo)
+{
+	unsigned char ppll_div_sel;
+	unsigned Ns, Nm, M;
+	unsigned sclk, mclk, tmp, ref_div;
+	int hTotal, vTotal, num, denom, m, n;
+	unsigned long long hz, vclk;
+	long xtal;
+	struct timeval start_tv, stop_tv;
+	long total_secs, total_usecs;
+	int i;
+
+	/* Ugh, we cut interrupts, bad bad bad, but we want some precision
+	 * here, so... --BenH
+	 */
+
+	/* Flush PCI buffers ? */
+	tmp = INREG(DEVICE_ID);
+
+	local_irq_disable();
+
+	for(i=0; i<1000000; i++)
+		if (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
+			break;
+
+	do_gettimeofday(&start_tv);
+
+	for(i=0; i<1000000; i++)
+		if (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)
+			break;
+
+	for(i=0; i<1000000; i++)
+		if (((INREG(CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
+			break;
+	
+	do_gettimeofday(&stop_tv);
+	
+	local_irq_enable();
+
+	total_secs = stop_tv.tv_sec - start_tv.tv_sec;
+	if (total_secs > 10)
+		return -1;
+	total_usecs = stop_tv.tv_usec - start_tv.tv_usec;
+	total_usecs += total_secs * 1000000;
+	if (total_usecs < 0)
+		total_usecs = -total_usecs;
+	hz = 1000000/total_usecs;
+ 
+	hTotal = ((INREG(CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;
+	vTotal = ((INREG(CRTC_V_TOTAL_DISP) & 0x3ff) + 1);
+	vclk = (long long)hTotal * (long long)vTotal * hz;
+
+	switch((INPLL(PPLL_REF_DIV) & 0x30000) >> 16) {
+	case 0:
+	default:
+		num = 1;
+		denom = 1;
+		break;
+	case 1:
+		n = ((INPLL(X_MPLL_REF_FB_DIV) >> 16) & 0xff);
+		m = (INPLL(X_MPLL_REF_FB_DIV) & 0xff);
+		num = 2*n;
+		denom = 2*m;
+		break;
+	case 2:
+		n = ((INPLL(X_MPLL_REF_FB_DIV) >> 8) & 0xff);
+		m = (INPLL(X_MPLL_REF_FB_DIV) & 0xff);
+		num = 2*n;
+		denom = 2*m;
+        break;
+	}
+
+	OUTREG8(CLOCK_CNTL_INDEX, 1);
+	ppll_div_sel = INREG8(CLOCK_CNTL_DATA + 1) & 0x3;
+
+	n = (INPLL(PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
+	m = (INPLL(PPLL_REF_DIV) & 0x3ff);
+
+	num *= n;
+	denom *= m;
+
+	switch ((INPLL(PPLL_DIV_0 + ppll_div_sel) >> 16) & 0x7) {
+	case 1:
+		denom *= 2;
+		break;
+	case 2:
+		denom *= 4;
+		break;
+	case 3:
+		denom *= 8;
+		break;
+	case 4:
+		denom *= 3;
+		break;
+	case 6:
+		denom *= 6;   
+		break;
+	case 7:
+		denom *= 12;
+		break;
+	}
+
+	do_div(vclk, 1000);
+	xtal = (xtal * denom) / num;
+
+	if ((xtal > 26900) && (xtal < 27100))
+		xtal = 2700;
+	else if ((xtal > 14200) && (xtal < 14400))
+		xtal = 1432;
+	else if ((xtal > 29400) && (xtal < 29600))
+		xtal = 2950;
+	else {
+		printk(KERN_WARNING "xtal calculation failed: %ld\n", xtal);
+		return -1;
+	}
+
+	tmp = INPLL(X_MPLL_REF_FB_DIV);
+	ref_div = INPLL(PPLL_REF_DIV) & 0x3ff;
+
+	Ns = (tmp & 0xff0000) >> 16;
+	Nm = (tmp & 0xff00) >> 8;
+	M = (tmp & 0xff);
+	sclk = round_div((2 * Ns * xtal), (2 * M));
+	mclk = round_div((2 * Nm * xtal), (2 * M));
+
+	/* we're done, hopefully these are sane values */
+	rinfo->pll.ref_clk = xtal;
+	rinfo->pll.ref_div = ref_div;
+	rinfo->pll.sclk = sclk;
+	rinfo->pll.mclk = mclk;
+
+	return 0;
+}
+
+/*
+ * Retreive PLL infos by different means (BIOS, Open Firmware, register probing...)
+ */
+static void __devinit radeon_get_pllinfo(struct radeonfb_info *rinfo)
+{
+#ifdef CONFIG_PPC_OF
+	/*
+	 * Retreive PLL infos from Open Firmware first
+	 */
+       	if (!force_measure_pll && radeon_read_xtal_OF(rinfo) == 0) {
+       		printk(KERN_INFO "radeonfb: Retreived PLL infos from Open Firmware\n");
+       		rinfo->pll.ref_div = INPLL(PPLL_REF_DIV) & 0x3ff;
+		/* FIXME: Max clock may be higher on newer chips */
+       		rinfo->pll.ppll_min = 12000;
+       		rinfo->pll.ppll_max = 35000;
+		goto found;
+	}
+#endif /* CONFIG_PPC_OF */
+
+	/*
+	 * Check out if we have an X86 which gave us some PLL informations
+	 * and if yes, retreive them
+	 */
+	if (!force_measure_pll && rinfo->bios_seg) {
+		u16 pll_info_block = BIOS_IN16(rinfo->fp_bios_start + 0x30);
+
+		rinfo->pll.sclk		= BIOS_IN16(pll_info_block + 0x08);
+		rinfo->pll.mclk		= BIOS_IN16(pll_info_block + 0x0a);
+		rinfo->pll.ref_clk	= BIOS_IN16(pll_info_block + 0x0e);
+		rinfo->pll.ref_div	= BIOS_IN16(pll_info_block + 0x10);
+		rinfo->pll.ppll_min	= BIOS_IN32(pll_info_block + 0x12);
+		rinfo->pll.ppll_max	= BIOS_IN32(pll_info_block + 0x16);
+
+		printk(KERN_INFO "radeonfb: Retreived PLL infos from BIOS\n");
+		goto found;
+	}
+
+	/*
+	 * We didn't get PLL parameters from either OF or BIOS, we try to
+	 * probe them
+	 */
+	if (radeon_probe_pll_params(rinfo) == 0) {
+		printk(KERN_INFO "radeonfb: Retreived PLL infos from registers\n");
+		/* FIXME: Max clock may be higher on newer chips */
+       		rinfo->pll.ppll_min = 12000;
+       		rinfo->pll.ppll_max = 35000;
+		goto found;
+	}
+
+	/*
+	 * Neither of the above worked, we have a few default values, though
+	 * that's mostly incomplete
+	 */
+	switch (rinfo->chipset) {
+	case PCI_DEVICE_ID_ATI_RADEON_QW:
+	case PCI_DEVICE_ID_ATI_RADEON_QX:
+		rinfo->pll.ppll_max = 35000;
+		rinfo->pll.ppll_min = 12000;
+		rinfo->pll.mclk = 23000;
+		rinfo->pll.sclk = 23000;
+		rinfo->pll.ref_clk = 2700;
+		break;
+	case PCI_DEVICE_ID_ATI_RADEON_QL:
+	case PCI_DEVICE_ID_ATI_RADEON_QN:
+	case PCI_DEVICE_ID_ATI_RADEON_QO:
+	case PCI_DEVICE_ID_ATI_RADEON_Ql:
+	case PCI_DEVICE_ID_ATI_RADEON_BB:
+		rinfo->pll.ppll_max = 35000;
+		rinfo->pll.ppll_min = 12000;
+		rinfo->pll.mclk = 27500;
+		rinfo->pll.sclk = 27500;
+		rinfo->pll.ref_clk = 2700;
+		break;
+	case PCI_DEVICE_ID_ATI_RADEON_Id:
+	case PCI_DEVICE_ID_ATI_RADEON_Ie:
+	case PCI_DEVICE_ID_ATI_RADEON_If:
+	case PCI_DEVICE_ID_ATI_RADEON_Ig:
+		rinfo->pll.ppll_max = 35000;
+		rinfo->pll.ppll_min = 12000;
+		rinfo->pll.mclk = 25000;
+		rinfo->pll.sclk = 25000;
+		rinfo->pll.ref_clk = 2700;
+		break;
+	case PCI_DEVICE_ID_ATI_RADEON_ND:
+	case PCI_DEVICE_ID_ATI_RADEON_NE:
+	case PCI_DEVICE_ID_ATI_RADEON_NF:
+	case PCI_DEVICE_ID_ATI_RADEON_NG:
+		rinfo->pll.ppll_max = 40000;
+		rinfo->pll.ppll_min = 20000;
+		rinfo->pll.mclk = 27000;
+		rinfo->pll.sclk = 27000;
+		rinfo->pll.ref_clk = 2700;
+		break;
+	case PCI_DEVICE_ID_ATI_RADEON_QD:
+	case PCI_DEVICE_ID_ATI_RADEON_QE:
+	case PCI_DEVICE_ID_ATI_RADEON_QF:
+	case PCI_DEVICE_ID_ATI_RADEON_QG:
+	default:
+		rinfo->pll.ppll_max = 35000;
+		rinfo->pll.ppll_min = 12000;
+		rinfo->pll.mclk = 16600;
+		rinfo->pll.sclk = 16600;
+		rinfo->pll.ref_clk = 2700;
+		break;
+	}
+	rinfo->pll.ref_div = INPLL(PPLL_REF_DIV) & 0x3ff;
+
+       	printk(KERN_INFO "radeonfb: Used default PLL infos\n");
+
+found:
+	/*
+	 * Some methods fail to retreive SCLK and MCLK values, we apply default
+	 * settings in this case (200Mhz). If that really happne often, we could
+	 * fetch from registers instead...
+	 */
+	if (rinfo->pll.mclk == 0)
+		rinfo->pll.mclk = 20000;
+	if (rinfo->pll.sclk == 0)
+		rinfo->pll.sclk = 20000;
+
+	printk("radeonfb: Reference=%d.%02d MHz (RefDiv=%d) Memory=%d.%02d Mhz, System=%d.%02d MHz\n",
+	       rinfo->pll.ref_clk / 100, rinfo->pll.ref_clk % 100,
+	       rinfo->pll.ref_div,
+	       rinfo->pll.mclk / 100, rinfo->pll.mclk % 100,
+	       rinfo->pll.sclk / 100, rinfo->pll.sclk % 100);
+}
+
+static int radeonfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *) info->par;
+        struct fb_var_screeninfo v;
+        int nom, den;
+	unsigned int pitch;
+
+	if (radeon_match_mode(rinfo, &v, var))
+		return -EINVAL;
+
+        switch (v.bits_per_pixel) {
+		case 0 ... 8:
+			v.bits_per_pixel = 8;
+			break;
+		case 9 ... 16:
+			v.bits_per_pixel = 16;
+			break;
+		case 17 ... 24:
+#if 0 /* Doesn't seem to work */
+			v.bits_per_pixel = 24;
+			break;
+#endif			
+			return -EINVAL;
+		case 25 ... 32:
+			v.bits_per_pixel = 32;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	switch (var_to_depth(&v)) {
+                case 8:
+                        nom = den = 1;
+                        v.red.offset = v.green.offset = v.blue.offset = 0;
+                        v.red.length = v.green.length = v.blue.length = 8;
+                        v.transp.offset = v.transp.length = 0;
+                        break;
+		case 15:
+			nom = 2;
+			den = 1;
+			v.red.offset = 10;
+			v.green.offset = 5;
+			v.blue.offset = 0;
+			v.red.length = v.green.length = v.blue.length = 5;
+			v.transp.offset = v.transp.length = 0;
+			break;
+                case 16:
+                        nom = 2;
+                        den = 1;
+                        v.red.offset = 11;
+                        v.green.offset = 5;
+                        v.blue.offset = 0;
+                        v.red.length = 5;
+                        v.green.length = 6;
+                        v.blue.length = 5;
+                        v.transp.offset = v.transp.length = 0;
+                        break;                          
+                case 24:
+                        nom = 4;
+                        den = 1;
+                        v.red.offset = 16;
+                        v.green.offset = 8;
+                        v.blue.offset = 0;
+                        v.red.length = v.blue.length = v.green.length = 8;
+                        v.transp.offset = v.transp.length = 0;
+                        break;
+                case 32:
+                        nom = 4;
+                        den = 1;
+                        v.red.offset = 16;
+                        v.green.offset = 8;
+                        v.blue.offset = 0;
+                        v.red.length = v.blue.length = v.green.length = 8;
+                        v.transp.offset = 24;
+                        v.transp.length = 8;
+                        break;
+                default:
+                        printk ("radeonfb: mode %dx%dx%d rejected, color depth invalid\n",
+                                var->xres, var->yres, var->bits_per_pixel);
+                        return -EINVAL;
+        }
+
+	if (v.yres_virtual < v.yres)
+		v.yres_virtual = v.yres;
+	if (v.xres_virtual < v.xres)
+		v.xres_virtual = v.xres;
+                
+
+	/* XXX I'm adjusting xres_virtual to the pitch, that may help XFree
+	 * with some panels, though I don't quite like this solution
+	 */
+  	if (radeon_accel_disabled()) {
+		v.xres_virtual = v.xres_virtual & ~7ul;
+		v.accel_flags = 0;
+	} else {
+		pitch = ((v.xres_virtual * ((v.bits_per_pixel + 1) / 8) + 0x3f)
+ 				& ~(0x3f)) >> 6;
+		v.xres_virtual = (pitch << 6) / ((v.bits_per_pixel + 1) / 8);
+	}
+
+	if (v.xres_virtual < v.xres)
+		v.xres = v.xres_virtual;
+
+	if (v.xoffset < 0)
+                v.xoffset = 0;
+        if (v.yoffset < 0)
+                v.yoffset = 0;
+         
+        if (v.xoffset > v.xres_virtual - v.xres)
+                v.xoffset = v.xres_virtual - v.xres - 1;
+                        
+        if (v.yoffset > v.yres_virtual - v.yres)
+                v.yoffset = v.yres_virtual - v.yres - 1;
+         
+        v.red.msb_right = v.green.msb_right = v.blue.msb_right =
+                          v.transp.offset = v.transp.length =
+                          v.transp.msb_right = 0;
+	
+        memcpy(var, &v, sizeof(v));
+
+        return 0;
+}
+
+
+static int radeonfb_pan_display (struct fb_var_screeninfo *var,
+                                 struct fb_info *info)
+{
+        struct radeonfb_info *rinfo = (struct radeonfb_info *) info;
+
+        if ((var->xoffset + var->xres > var->xres_virtual)
+	    || (var->yoffset + var->yres > var->yres_virtual))
+               return -EINVAL;
+                
+        if (rinfo->asleep)
+        	return 0;
+
+        OUTREG(CRTC_OFFSET, ((var->yoffset * var->xres_virtual + var->xoffset)
+			     * var->bits_per_pixel / 8) & ~7);
+        return 0;
+}
+
+
+static int radeonfb_ioctl (struct inode *inode, struct file *file, unsigned int cmd,
+                           unsigned long arg, struct fb_info *info)
+{
+        struct radeonfb_info *rinfo = (struct radeonfb_info *) info;
+	unsigned int tmp;
+	u32 value = 0;
+	int rc;
+
+	switch (cmd) {
+		/*
+		 * TODO:  set mirror accordingly for non-Mobility chipsets with 2 CRTC's
+		 *        and do something better using 2nd CRTC instead of just hackish
+		 *        routing to second output
+		 */
+		case FBIO_RADEON_SET_MIRROR:
+			if (!rinfo->is_mobility)
+				return -EINVAL;
+
+			rc = get_user(value, (__u32*)arg);
+
+			if (rc)
+				return rc;
+
+			if (value & 0x01) {
+				tmp = INREG(LVDS_GEN_CNTL);
+
+				tmp |= (LVDS_ON | LVDS_BLON);
+			} else {
+				tmp = INREG(LVDS_GEN_CNTL);
+
+				tmp &= ~(LVDS_ON | LVDS_BLON);
+			}
+
+			OUTREG(LVDS_GEN_CNTL, tmp);
+
+			if (value & 0x02) {
+				tmp = INREG(CRTC_EXT_CNTL);
+				tmp |= CRTC_CRT_ON;
+
+				mirror = 1;
+			} else {
+				tmp = INREG(CRTC_EXT_CNTL);
+				tmp &= ~CRTC_CRT_ON;
+
+				mirror = 0;
+			}
+
+			OUTREG(CRTC_EXT_CNTL, tmp);
+
+			break;
+		case FBIO_RADEON_GET_MIRROR:
+			if (!rinfo->is_mobility)
+				return -EINVAL;
+
+			tmp = INREG(LVDS_GEN_CNTL);
+			if ((LVDS_ON | LVDS_BLON) & tmp)
+				value |= 0x01;
+
+			tmp = INREG(CRTC_EXT_CNTL);
+			if (CRTC_CRT_ON & tmp)
+				value |= 0x02;
+
+			return put_user(value, (__u32*)arg);
+		default:
+			return -EINVAL;
+	}
+
+	return -EINVAL;
+}
+
+
+static int radeon_screen_blank (struct radeonfb_info *rinfo, int blank)
+{
+        u32 val = INREG(CRTC_EXT_CNTL);
+	u32 val2;
+
+	if (rinfo->mon1_type == MT_LCD)
+		val2 = INREG(LVDS_GEN_CNTL) & ~LVDS_DISPLAY_DIS;
+	
+        /* reset it */
+        val &= ~(CRTC_DISPLAY_DIS | CRTC_HSYNC_DIS |
+                 CRTC_VSYNC_DIS);
+
+        switch (blank) {
+                case VESA_NO_BLANKING:
+                        break;
+                case VESA_VSYNC_SUSPEND:
+                        val |= (CRTC_DISPLAY_DIS | CRTC_VSYNC_DIS);
+                        break;
+                case VESA_HSYNC_SUSPEND:
+                        val |= (CRTC_DISPLAY_DIS | CRTC_HSYNC_DIS);
+                        break;
+                case VESA_POWERDOWN:
+                        val |= (CRTC_DISPLAY_DIS | CRTC_VSYNC_DIS | 
+                                CRTC_HSYNC_DIS);
+			val2 |= (LVDS_DISPLAY_DIS);
+                        break;
+        }
+
+	switch (rinfo->mon1_type) {
+		case MT_LCD:
+			OUTREG(LVDS_GEN_CNTL, val2);
+			break;
+		case MT_CRT:
+		default:
+		        OUTREG(CRTC_EXT_CNTL, val);
+			break;
+	}
+
+	return 0;
+}
+
+int radeonfb_blank (int blank, struct fb_info *info)
+{
+        struct radeonfb_info *rinfo = (struct radeonfb_info *) info;
+
+	if (rinfo->asleep)
+		return 0;
+		
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if (rinfo->mon1_type == MT_LCD && _machine == _MACH_Pmac && blank)
+		set_backlight_enable(0);
+#endif
+                        
+	radeon_screen_blank(rinfo, blank);
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if (rinfo->mon1_type == MT_LCD && _machine == _MACH_Pmac && !blank)
+		set_backlight_enable(1);
+#endif
+
+	return 0;
+}
+
+static int radeonfb_setcolreg (unsigned regno, unsigned red, unsigned green,
+                             unsigned blue, unsigned transp, struct fb_info *info)
+{
+        struct radeonfb_info *rinfo = (struct radeonfb_info *) info;
+	u32 pindex;
+	unsigned int i;
+	
+	if (regno > 255)
+		return 1;
+
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+	rinfo->palette[regno].red = red;
+	rinfo->palette[regno].green = green;
+	rinfo->palette[regno].blue = blue;
+
+        /* default */
+        pindex = regno;
+
+        if (!rinfo->asleep) {
+        	u32 dac_cntl2, vclk_cntl;
+        	
+		if (rinfo->is_mobility) {
+			vclk_cntl = INPLL(VCLK_ECP_CNTL);
+			OUTPLL(VCLK_ECP_CNTL, vclk_cntl & ~PIXCLK_DAC_ALWAYS_ONb);
+		}
+
+		/* Make sure we are on first palette */
+		if (rinfo->has_CRTC2) {
+			dac_cntl2 = INREG(DAC_CNTL2);
+			dac_cntl2 &= ~DAC2_PALETTE_ACCESS_CNTL;
+			OUTREG(DAC_CNTL2, dac_cntl2);
+		}
+
+		if (rinfo->bpp == 16) {
+			pindex = regno * 8;
+
+			if (rinfo->depth == 16 && regno > 63)
+				return 1;
+			if (rinfo->depth == 15 && regno > 31)
+				return 1;
+
+			/* For 565, the green component is mixed one order below */
+			if (rinfo->depth == 16) {
+		                OUTREG(PALETTE_INDEX, pindex>>1);
+	       	         	OUTREG(PALETTE_DATA, (rinfo->palette[regno>>1].red << 16) |
+	                        	(green << 8) | (rinfo->palette[regno>>1].blue));
+	                	green = rinfo->palette[regno<<1].green;
+	        	}
+		}
+
+		if (rinfo->depth != 16 || regno < 32) {
+			OUTREG(PALETTE_INDEX, pindex);
+			OUTREG(PALETTE_DATA, (red << 16) | (green << 8) | blue);
+		}
+		if (rinfo->is_mobility)
+			OUTPLL(VCLK_ECP_CNTL, vclk_cntl);
+	}
+ 	if (regno < 16) {
+		u32 *pal = info->pseudo_palette;
+        	switch (rinfo->depth) {
+		case 15:
+			pal[regno] = (regno << 10) | (regno << 5) | regno;
+			break;
+		case 16:
+			pal[regno] = (regno << 11) | (regno << 5) | regno;
+			break;
+		case 24:
+			pal[regno] = (regno << 16) | (regno << 8) | regno;
+			break;
+		case 32:
+			i = (regno << 8) | regno;
+			pal[regno] = (i << 16) | i;
+			break;
+		}
+        }
+	return 0;
+}
+
+
+static void radeon_save_state (struct radeonfb_info *rinfo, struct radeon_regs *save)
+{
+	/* CRTC regs */
+	save->crtc_gen_cntl = INREG(CRTC_GEN_CNTL);
+	save->crtc_ext_cntl = INREG(CRTC_EXT_CNTL);
+	save->crtc_more_cntl = INREG(CRTC_MORE_CNTL);
+	save->dac_cntl = INREG(DAC_CNTL);
+        save->crtc_h_total_disp = INREG(CRTC_H_TOTAL_DISP);
+        save->crtc_h_sync_strt_wid = INREG(CRTC_H_SYNC_STRT_WID);
+        save->crtc_v_total_disp = INREG(CRTC_V_TOTAL_DISP);
+        save->crtc_v_sync_strt_wid = INREG(CRTC_V_SYNC_STRT_WID);
+	save->crtc_pitch = INREG(CRTC_PITCH);
+	save->surface_cntl = INREG(SURFACE_CNTL);
+
+	/* FP regs */
+	save->fp_crtc_h_total_disp = INREG(FP_CRTC_H_TOTAL_DISP);
+	save->fp_crtc_v_total_disp = INREG(FP_CRTC_V_TOTAL_DISP);
+	save->fp_gen_cntl = INREG(FP_GEN_CNTL);
+	save->fp_h_sync_strt_wid = INREG(FP_H_SYNC_STRT_WID);
+	save->fp_horz_stretch = INREG(FP_HORZ_STRETCH);
+	save->fp_v_sync_strt_wid = INREG(FP_V_SYNC_STRT_WID);
+	save->fp_vert_stretch = INREG(FP_VERT_STRETCH);
+	save->lvds_gen_cntl = INREG(LVDS_GEN_CNTL);
+	save->lvds_pll_cntl = INREG(LVDS_PLL_CNTL);
+	save->tmds_crc = INREG(TMDS_CRC);	save->tmds_transmitter_cntl = INREG(TMDS_TRANSMITTER_CNTL);
+	save->vclk_ecp_cntl = INPLL(VCLK_ECP_CNTL);
+}
+
+
+static void radeon_write_pll_regs(struct radeonfb_info *rinfo, struct radeon_regs *mode)
+{
+	int i;
+
+	/* Workaround from XFree */
+	if (rinfo->is_mobility) {
+	        /* A temporal workaround for the occational blanking on certain laptop panels. 
+	           This appears to related to the PLL divider registers (fail to lock?).  
+		   It occurs even when all dividers are the same with their old settings.  
+	           In this case we really don't need to fiddle with PLL registers. 
+	           By doing this we can avoid the blanking problem with some panels.
+	        */
+		if ((mode->ppll_ref_div == (INPLL(PPLL_REF_DIV) & PPLL_REF_DIV_MASK)) &&
+		    (mode->ppll_div_3 == (INPLL(PPLL_DIV_3) &
+					  (PPLL_POST3_DIV_MASK | PPLL_FB3_DIV_MASK)))) {
+			/* We still have to force a switch to PPLL div 3 thanks to
+			 * an XFree86 driver bug which will switch it away in some cases
+			 * even when using UseFDev */
+			OUTREGP(CLOCK_CNTL_INDEX, PPLL_DIV_SEL_MASK, ~PPLL_DIV_SEL_MASK);
+            		return;
+		}
+	}
+
+	/* Swich VCKL clock input to CPUCLK so it stays fed while PPLL updates*/
+	OUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_CPUCLK, ~VCLK_SRC_SEL_MASK);
+
+	/* Reset PPLL & enable atomic update */
+	OUTPLLP(PPLL_CNTL,
+		PPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN,
+		~(PPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));
+
+	/* Switch to PPLL div 3 */
+	OUTREGP(CLOCK_CNTL_INDEX, PPLL_DIV_SEL_MASK, ~PPLL_DIV_SEL_MASK);
+
+	/* Set PPLL ref. div */
+	if (rinfo->family == CHIP_FAMILY_R300 ||
+	    rinfo->family == CHIP_FAMILY_R350 ||
+	    rinfo->family == CHIP_FAMILY_RV350) {
+		if (mode->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {
+			/* When restoring console mode, use saved PPLL_REF_DIV
+			 * setting.
+			 */
+			OUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, 0);
+		} else {
+			/* R300 uses ref_div_acc field as real ref divider */
+			OUTPLLP(PPLL_REF_DIV,
+				(mode->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT), 
+				~R300_PPLL_REF_DIV_ACC_MASK);
+		}
+	} else
+		OUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, ~PPLL_REF_DIV_MASK);
+
+	/* Set PPLL divider 3 & post divider*/
+	OUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_FB3_DIV_MASK);
+	OUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_POST3_DIV_MASK);
+
+	/* Write update */
+	while (INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R)
+		;
+	OUTPLLP(PPLL_REF_DIV, PPLL_ATOMIC_UPDATE_W, ~PPLL_ATOMIC_UPDATE_W);
+
+	/* Wait read update complete */
+	/* FIXME: Certain revisions of R300 can't recover here.  Not sure of
+	   the cause yet, but this workaround will mask the problem for now.
+	   Other chips usually will pass at the very first test, so the
+	   workaround shouldn't have any effect on them. */
+	for (i = 0; (i < 10000 && INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R); i++)
+		;
+	
+	OUTPLL(HTOTAL_CNTL, 0);
+
+	/* Clear reset & atomic update */
+	OUTPLLP(PPLL_CNTL, 0,
+		~(PPLL_RESET | PPLL_SLEEP | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));
+
+	/* We may want some locking ... oh well */
+       	wait_ms(5);
+
+	/* Switch back VCLK source to PPLL */
+	OUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_PPLLCLK, ~VCLK_SRC_SEL_MASK);
+}
+
+/*
+ * Timer function for delayed LVDS panel power up/down
+ */
+static void radeon_lvds_timer_func(unsigned long data)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)data;
+
+	OUTREG(LVDS_GEN_CNTL, rinfo->pending_lvds_gen_cntl);
+	if (rinfo->pending_pixclks_cntl) {
+		OUTPLL(PIXCLKS_CNTL, rinfo->pending_pixclks_cntl);
+		rinfo->pending_pixclks_cntl = 0;
+	}
+}
+
+/*
+ * Apply a video mode. This will apply the whole register set, including
+ * the PLL registers, to the card
+ */
+static void radeon_write_mode (struct radeonfb_info *rinfo,
+                               struct radeon_regs *mode)
+{
+	int i;
+	int primary_mon = PRIMARY_MONITOR(rinfo);
+
+	if (nomodeset)
+		return;
+
+	del_timer_sync(&rinfo->lvds_timer);
+
+	radeon_screen_blank(rinfo, VESA_POWERDOWN);
+
+	for (i=0; i<9; i++)
+		OUTREG(common_regs[i].reg, common_regs[i].val);
+
+	/* Apply surface registers */
+	for (i=0; i<8; i++) {
+		OUTREG(SURFACE0_LOWER_BOUND + 0x10*i, mode->surf_lower_bound[i]);
+		OUTREG(SURFACE0_UPPER_BOUND + 0x10*i, mode->surf_upper_bound[i]);
+		OUTREG(SURFACE0_INFO + 0x10*i, mode->surf_info[i]);
+	}
+
+	OUTREG(CRTC_GEN_CNTL, mode->crtc_gen_cntl);
+	OUTREGP(CRTC_EXT_CNTL, mode->crtc_ext_cntl,
+		~(CRTC_HSYNC_DIS | CRTC_VSYNC_DIS | CRTC_DISPLAY_DIS));
+	OUTREG(CRTC_MORE_CNTL, mode->crtc_more_cntl);
+	OUTREGP(DAC_CNTL, mode->dac_cntl, DAC_RANGE_CNTL | DAC_BLANKING);
+	OUTREG(CRTC_H_TOTAL_DISP, mode->crtc_h_total_disp);
+	OUTREG(CRTC_H_SYNC_STRT_WID, mode->crtc_h_sync_strt_wid);
+	OUTREG(CRTC_V_TOTAL_DISP, mode->crtc_v_total_disp);
+	OUTREG(CRTC_V_SYNC_STRT_WID, mode->crtc_v_sync_strt_wid);
+	OUTREG(CRTC_OFFSET, 0);
+	OUTREG(CRTC_OFFSET_CNTL, 0);
+	OUTREG(CRTC_PITCH, mode->crtc_pitch);
+	OUTREG(SURFACE_CNTL, mode->surface_cntl);
+
+	radeon_write_pll_regs(rinfo, mode);
+
+	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
+		OUTREG(FP_CRTC_H_TOTAL_DISP, mode->fp_crtc_h_total_disp);
+		OUTREG(FP_CRTC_V_TOTAL_DISP, mode->fp_crtc_v_total_disp);
+		OUTREG(FP_H_SYNC_STRT_WID, mode->fp_h_sync_strt_wid);
+		OUTREG(FP_V_SYNC_STRT_WID, mode->fp_v_sync_strt_wid);
+		OUTREG(FP_HORZ_STRETCH, mode->fp_horz_stretch);
+		OUTREG(FP_VERT_STRETCH, mode->fp_vert_stretch);
+		OUTREG(FP_GEN_CNTL, mode->fp_gen_cntl);
+		OUTREG(TMDS_CRC, mode->tmds_crc);
+		OUTREG(TMDS_TRANSMITTER_CNTL, mode->tmds_transmitter_cntl);
+
+		if (primary_mon == MT_LCD) {
+			unsigned int tmp = INREG(LVDS_GEN_CNTL);
+
+			/* HACK: The backlight control code may have modified init_state.lvds_gen_cntl,
+			 * so we update ourselves
+			 */
+			mode->lvds_gen_cntl &= ~LVDS_STATE_MASK;
+			mode->lvds_gen_cntl |= (rinfo->init_state.lvds_gen_cntl & LVDS_STATE_MASK);
+
+			if ((tmp & (LVDS_ON | LVDS_BLON)) ==
+			    (mode->lvds_gen_cntl & (LVDS_ON | LVDS_BLON))) {
+				OUTREG(LVDS_GEN_CNTL, mode->lvds_gen_cntl);
+			} else {
+				rinfo->pending_pixclks_cntl = INPLL(PIXCLKS_CNTL);
+				if (rinfo->is_mobility || rinfo->is_IGP)
+					OUTPLLP(PIXCLKS_CNTL, 0, ~PIXCLK_LVDS_ALWAYS_ONb);
+				if (!(tmp & (LVDS_ON | LVDS_BLON)))
+					OUTREG(LVDS_GEN_CNTL, mode->lvds_gen_cntl | LVDS_BLON);
+				rinfo->pending_lvds_gen_cntl = mode->lvds_gen_cntl;
+				mod_timer(&rinfo->lvds_timer,
+					  jiffies + MS_TO_HZ(rinfo->panel_info.pwr_delay));
+			}
+		}
+	}
+
+	RTRACE("lvds_gen_cntl: %08x\n", INREG(LVDS_GEN_CNTL));
+
+	radeon_screen_blank(rinfo, VESA_NO_BLANKING);
+
+	OUTPLL(VCLK_ECP_CNTL, mode->vclk_ecp_cntl);
+	
+	return;
+}
+
+/*
+ * Calculate the PLL values for a given mode
+ */
+static void radeon_calc_pll_regs(struct radeonfb_info *rinfo, struct radeon_regs *regs,
+				 unsigned long freq)
+{
+	const struct {
+		int divider;
+		int bitvalue;
+	} *post_div,
+	  post_divs[] = {
+		{ 1,  0 },
+		{ 2,  1 },
+		{ 4,  2 },
+		{ 8,  3 },
+		{ 3,  4 },
+		{ 16, 5 },
+		{ 6,  6 },
+		{ 12, 7 },
+		{ 0,  0 },
+	};
+	int fb_div, pll_output_freq;
+	int uses_dvo = 0;
+
+	/* Check if the DVO port is enabled and sourced from the primary CRTC. I'm
+	 * not sure which model starts having FP2_GEN_CNTL, I assume anything more
+	 * recent than an r(v)100...
+	 */
+	while (rinfo->has_CRTC2) {
+		u32 fp2_gen_cntl = INREG(FP2_GEN_CNTL);
+		u32 disp_output_cntl;
+		int source;
+
+		/* FP2 path not enabled */
+		if ((fp2_gen_cntl & FP2_ON) == 0)
+			break;
+		/* Not all chip revs have the same format for this register,
+		 * extract the source selection
+		 */
+		if (rinfo->family == CHIP_FAMILY_R200 ||
+		    rinfo->family == CHIP_FAMILY_R300 ||
+		    rinfo->family == CHIP_FAMILY_R350 ||
+		    rinfo->family == CHIP_FAMILY_RV350) {
+			source = (fp2_gen_cntl >> 10) & 0x3;
+			/* sourced from transform unit, check for transform unit
+			 * own source
+			 */
+			if (source == 3) {
+				disp_output_cntl = INREG(DISP_OUTPUT_CNTL);
+				source = (disp_output_cntl >> 12) & 0x3;
+			}
+		} else
+			source = (fp2_gen_cntl >> 13) & 0x1;
+		/* sourced from CRTC2 -> exit */
+		if (source == 1)
+			break;
+
+		/* so we end up on CRTC1, let's set uses_dvo to 1 now */
+		uses_dvo = 1;
+		break;
+	}
+	if (freq > rinfo->pll.ppll_max)
+		freq = rinfo->pll.ppll_max;
+	if (freq*12 < rinfo->pll.ppll_min)
+		freq = rinfo->pll.ppll_min / 12;
+
+	for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
+		pll_output_freq = post_div->divider * freq;
+		/* If we output to the DVO port (external TMDS), we don't allow an
+		 * odd PLL divider as those aren't supported on this path
+		 */
+		if (uses_dvo && (post_div->divider & 1))
+			continue;
+		if (pll_output_freq >= rinfo->pll.ppll_min  &&
+		    pll_output_freq <= rinfo->pll.ppll_max)
+			break;
+	}
+
+	fb_div = round_div(rinfo->pll.ref_div*pll_output_freq,
+				  rinfo->pll.ref_clk);
+	regs->ppll_ref_div = rinfo->pll.ref_div;
+	regs->ppll_div_3 = fb_div | (post_div->bitvalue << 16);
+
+	RTRACE("post div = 0x%x\n", post_div->bitvalue);
+	RTRACE("fb_div = 0x%x\n", fb_div);
+	RTRACE("ppll_div_3 = 0x%x\n", regs->ppll_div_3);
+}
+
+int radeonfb_set_par(struct fb_info *info)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)info->par;
+	struct fb_var_screeninfo *mode = &info->var;
+	struct radeon_regs newmode;
+	int hTotal, vTotal, hSyncStart, hSyncEnd,
+	    hSyncPol, vSyncStart, vSyncEnd, vSyncPol, cSync;
+	u8 hsync_adj_tab[] = {0, 0x12, 9, 9, 6, 5};
+	u8 hsync_fudge_fp[] = {2, 2, 0, 0, 5, 5};
+	u32 sync, h_sync_pol, v_sync_pol, dotClock, pixClock;
+	int i, freq;
+        int format = 0;
+	int nopllcalc = 0;
+	int hsync_start, hsync_fudge, bytpp, hsync_wid, vsync_wid;
+	int primary_mon = PRIMARY_MONITOR(rinfo);
+	int depth = var_to_depth(mode);
+
+	/* We always want engine to be idle on a mode switch, even
+	 * if we won't actually change the mode
+	 */
+	radeon_engine_idle();
+
+	hSyncStart = mode->xres + mode->right_margin;
+	hSyncEnd = hSyncStart + mode->hsync_len;
+	hTotal = hSyncEnd + mode->left_margin;
+
+	vSyncStart = mode->yres + mode->lower_margin;
+	vSyncEnd = vSyncStart + mode->vsync_len;
+	vTotal = vSyncEnd + mode->upper_margin;
+	pixClock = mode->pixclock;
+
+	sync = mode->sync;
+	h_sync_pol = sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;
+	v_sync_pol = sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;
+
+	if (primary_mon == MT_DFP || primary_mon == MT_LCD) {
+		if (rinfo->panel_info.xres < mode->xres)
+			mode->xres = rinfo->panel_info.xres;
+		if (rinfo->panel_info.yres < mode->yres)
+			mode->yres = rinfo->panel_info.yres;
+
+		hTotal = mode->xres + rinfo->panel_info.hblank;
+		hSyncStart = mode->xres + rinfo->panel_info.hOver_plus;
+		hSyncEnd = hSyncStart + rinfo->panel_info.hSync_width;
+
+		vTotal = mode->yres + rinfo->panel_info.vblank;
+		vSyncStart = mode->yres + rinfo->panel_info.vOver_plus;
+		vSyncEnd = vSyncStart + rinfo->panel_info.vSync_width;
+
+		h_sync_pol = !rinfo->panel_info.hAct_high;
+		v_sync_pol = !rinfo->panel_info.vAct_high;
+
+		pixClock = 100000000 / rinfo->panel_info.clock;
+
+		if (rinfo->panel_info.use_bios_dividers) {
+			nopllcalc = 1;
+			newmode.ppll_div_3 = rinfo->panel_info.fbk_divider |
+				(rinfo->panel_info.post_divider << 16);
+			newmode.ppll_ref_div = rinfo->pll.ref_div;
+		}
+	}
+	dotClock = 1000000000 / pixClock;
+	freq = dotClock / 10; /* x100 */
+
+	RTRACE("hStart = %d, hEnd = %d, hTotal = %d\n",
+		hSyncStart, hSyncEnd, hTotal);
+	RTRACE("vStart = %d, vEnd = %d, vTotal = %d\n",
+		vSyncStart, vSyncEnd, vTotal);
+
+	hsync_wid = (hSyncEnd - hSyncStart) / 8;
+	vsync_wid = vSyncEnd - vSyncStart;
+	if (hsync_wid == 0)
+		hsync_wid = 1;
+	else if (hsync_wid > 0x3f)	/* max */
+		hsync_wid = 0x3f;
+
+	if (vsync_wid == 0)
+		vsync_wid = 1;
+	else if (vsync_wid > 0x1f)	/* max */
+		vsync_wid = 0x1f;
+
+	hSyncPol = mode->sync & FB_SYNC_HOR_HIGH_ACT ? 0 : 1;
+	vSyncPol = mode->sync & FB_SYNC_VERT_HIGH_ACT ? 0 : 1;
+
+	cSync = mode->sync & FB_SYNC_COMP_HIGH_ACT ? (1 << 4) : 0;
+
+	format = radeon_get_dstbpp(depth);
+	bytpp = mode->bits_per_pixel >> 3;
+
+	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD))
+		hsync_fudge = hsync_fudge_fp[format-1];
+	else
+		hsync_fudge = hsync_adj_tab[format-1];
+
+	hsync_start = hSyncStart - 8 + hsync_fudge;
+
+	newmode.crtc_gen_cntl = CRTC_EXT_DISP_EN | CRTC_EN |
+				(format << 8);
+
+	/* Clear auto-center etc... */
+	newmode.crtc_more_cntl = rinfo->init_state.crtc_more_cntl;
+	newmode.crtc_more_cntl &= 0xfffffff0;
+	
+	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
+		newmode.crtc_ext_cntl = VGA_ATI_LINEAR | XCRT_CNT_EN;
+		if (mirror)
+			newmode.crtc_ext_cntl |= CRTC_CRT_ON;
+
+		newmode.crtc_gen_cntl &= ~(CRTC_DBL_SCAN_EN |
+					   CRTC_INTERLACE_EN);
+	} else {
+		newmode.crtc_ext_cntl = VGA_ATI_LINEAR | XCRT_CNT_EN |
+					CRTC_CRT_ON;
+	}
+
+	newmode.dac_cntl = /* INREG(DAC_CNTL) | */ DAC_MASK_ALL | DAC_VGA_ADR_EN |
+			   DAC_8BIT_EN;
+
+	newmode.crtc_h_total_disp = ((((hTotal / 8) - 1) & 0x3ff) |
+				     (((mode->xres / 8) - 1) << 16));
+
+	newmode.crtc_h_sync_strt_wid = ((hsync_start & 0x1fff) |
+					(hsync_wid << 16) | (h_sync_pol << 23));
+
+	newmode.crtc_v_total_disp = ((vTotal - 1) & 0xffff) |
+				    ((mode->yres - 1) << 16);
+
+	newmode.crtc_v_sync_strt_wid = (((vSyncStart - 1) & 0xfff) |
+					 (vsync_wid << 16) | (v_sync_pol  << 23));
+
+	if (!radeon_accel_disabled()) {
+		/* We first calculate the engine pitch */
+		rinfo->pitch = ((mode->xres_virtual * ((mode->bits_per_pixel + 1) / 8) + 0x3f)
+ 				& ~(0x3f)) >> 6;
+
+		/* Then, re-multiply it to get the CRTC pitch */
+		newmode.crtc_pitch = (rinfo->pitch << 3) / ((mode->bits_per_pixel + 1) / 8);
+	} else
+		newmode.crtc_pitch = (mode->xres_virtual >> 3);
+
+	newmode.crtc_pitch |= (newmode.crtc_pitch << 16);
+
+	/*
+	 * It looks like recent chips have a problem with SURFACE_CNTL,
+	 * setting SURF_TRANSLATION_DIS completely disables the
+	 * swapper as well, so we leave it unset now.
+	 */
+	newmode.surface_cntl = 0;
+
+#if defined(__BIG_ENDIAN)
+
+	/* Setup swapping on both apertures, though we currently
+	 * only use aperture 0, enabling swapper on aperture 1
+	 * won't harm
+	 */
+	switch (mode->bits_per_pixel) {
+		case 16:
+			newmode.surface_cntl |= NONSURF_AP0_SWP_16BPP;
+			newmode.surface_cntl |= NONSURF_AP1_SWP_16BPP;
+			break;
+		case 24:	
+		case 32:
+			newmode.surface_cntl |= NONSURF_AP0_SWP_32BPP;
+			newmode.surface_cntl |= NONSURF_AP1_SWP_32BPP;
+			break;
+	}
+#endif
+
+	/* Clear surface registers */
+	for (i=0; i<8; i++) {
+		newmode.surf_lower_bound[i] = 0;
+		newmode.surf_upper_bound[i] = 0x1f;
+		newmode.surf_info[i] = 0;
+	}
+
+	RTRACE("h_total_disp = 0x%x\t   hsync_strt_wid = 0x%x\n",
+		newmode.crtc_h_total_disp, newmode.crtc_h_sync_strt_wid);
+	RTRACE("v_total_disp = 0x%x\t   vsync_strt_wid = 0x%x\n",
+		newmode.crtc_v_total_disp, newmode.crtc_v_sync_strt_wid);
+
+	rinfo->bpp = mode->bits_per_pixel;
+	rinfo->depth = depth;
+
+	RTRACE("pixclock = %lu\n", (unsigned long)pixClock);
+	RTRACE("freq = %lu\n", (unsigned long)freq);
+
+	if (!nopllcalc)
+		radeon_calc_pll_regs(rinfo, &newmode, freq);
+
+	newmode.vclk_ecp_cntl = rinfo->init_state.vclk_ecp_cntl;
+
+	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
+		unsigned int hRatio, vRatio;
+
+		if (mode->xres > rinfo->panel_info.xres)
+			mode->xres = rinfo->panel_info.xres;
+		if (mode->yres > rinfo->panel_info.yres)
+			mode->yres = rinfo->panel_info.yres;
+
+		newmode.fp_horz_stretch = (((rinfo->panel_info.xres / 8) - 1)
+					   << HORZ_PANEL_SHIFT);
+		newmode.fp_vert_stretch = ((rinfo->panel_info.yres - 1)
+					   << VERT_PANEL_SHIFT);
+
+		if (mode->xres != rinfo->panel_info.xres) {
+			hRatio = round_div(mode->xres * HORZ_STRETCH_RATIO_MAX,
+					   rinfo->panel_info.xres);
+			newmode.fp_horz_stretch = (((((unsigned long)hRatio) & HORZ_STRETCH_RATIO_MASK)) |
+						   (newmode.fp_horz_stretch &
+						    (HORZ_PANEL_SIZE | HORZ_FP_LOOP_STRETCH |
+						     HORZ_AUTO_RATIO_INC)));
+			newmode.fp_horz_stretch |= (HORZ_STRETCH_BLEND |
+						    HORZ_STRETCH_ENABLE);
+		}
+		newmode.fp_horz_stretch &= ~HORZ_AUTO_RATIO;
+
+		if (mode->yres != rinfo->panel_info.yres) {
+			vRatio = round_div(mode->yres * VERT_STRETCH_RATIO_MAX,
+					   rinfo->panel_info.yres);
+			newmode.fp_vert_stretch = (((((unsigned long)vRatio) & VERT_STRETCH_RATIO_MASK)) |
+						   (newmode.fp_vert_stretch &
+						   (VERT_PANEL_SIZE | VERT_STRETCH_RESERVED)));
+			newmode.fp_vert_stretch |= (VERT_STRETCH_BLEND |
+						    VERT_STRETCH_ENABLE);
+		}
+		newmode.fp_vert_stretch &= ~VERT_AUTO_RATIO_EN;
+
+		newmode.fp_gen_cntl = (rinfo->init_state.fp_gen_cntl & (u32)
+				       ~(FP_SEL_CRTC2 |
+					 FP_RMX_HVSYNC_CONTROL_EN |
+					 FP_DFP_SYNC_SEL |
+					 FP_CRT_SYNC_SEL |
+					 FP_CRTC_LOCK_8DOT |
+					 FP_USE_SHADOW_EN |
+					 FP_CRTC_USE_SHADOW_VEND |
+					 FP_CRT_SYNC_ALT));
+
+		newmode.fp_gen_cntl |= (FP_CRTC_DONT_SHADOW_VPAR |
+					FP_CRTC_DONT_SHADOW_HEND);
+
+		newmode.lvds_gen_cntl = rinfo->init_state.lvds_gen_cntl;
+		newmode.lvds_pll_cntl = rinfo->init_state.lvds_pll_cntl;
+		newmode.tmds_crc = rinfo->init_state.tmds_crc;
+		newmode.tmds_transmitter_cntl = rinfo->init_state.tmds_transmitter_cntl;
+
+		if (primary_mon == MT_LCD) {
+			newmode.lvds_gen_cntl |= (LVDS_ON | LVDS_BLON);
+			newmode.fp_gen_cntl &= ~(FP_FPON | FP_TMDS_EN);
+		} else {
+			/* DFP */
+			newmode.fp_gen_cntl |= (FP_FPON | FP_TMDS_EN);
+			newmode.tmds_transmitter_cntl = (TMDS_RAN_PAT_RST | TMDS_ICHCSEL) &
+							 ~(TMDS_PLLRST);
+			/* TMDS_PLL_EN bit is reversed on RV (and mobility) chips */
+			if ((rinfo->family == CHIP_FAMILY_R300) ||
+			    (rinfo->family == CHIP_FAMILY_R350) ||
+			    (rinfo->family == CHIP_FAMILY_RV350) ||
+			    (rinfo->family == CHIP_FAMILY_R200) || !rinfo->has_CRTC2)
+				newmode.tmds_transmitter_cntl &= ~TMDS_PLL_EN;
+			else
+				newmode.tmds_transmitter_cntl |= TMDS_PLL_EN;
+			newmode.crtc_ext_cntl &= ~CRTC_CRT_ON;
+		}
+
+		newmode.fp_crtc_h_total_disp = (((rinfo->panel_info.hblank / 8) & 0x3ff) |
+				(((mode->xres / 8) - 1) << 16));
+		newmode.fp_crtc_v_total_disp = (rinfo->panel_info.vblank & 0xffff) |
+				((mode->yres - 1) << 16);
+		newmode.fp_h_sync_strt_wid = ((rinfo->panel_info.hOver_plus & 0x1fff) |
+				(hsync_wid << 16) | (h_sync_pol << 23));
+		newmode.fp_v_sync_strt_wid = ((rinfo->panel_info.vOver_plus & 0xfff) |
+				(vsync_wid << 16) | (v_sync_pol  << 23));
+	}
+
+	/* do it! */
+	if (!rinfo->asleep) {
+		radeon_write_mode (rinfo, &newmode);
+		/* (re)initialize the engine */
+		if (!radeon_accel_disabled())
+			radeon_engine_init (rinfo);
+	
+	}
+	/* Update fix */
+	if (!radeon_accel_disabled())
+        	info->fix.line_length = rinfo->pitch*64;
+        else
+		info->fix.line_length = mode->xres_virtual
+			* ((mode->bits_per_pixel + 1) / 8);
+        info->fix.visual = rinfo->depth == 8 ? FB_VISUAL_PSEUDOCOLOR
+		: FB_VISUAL_DIRECTCOLOR;
+
+#ifdef CONFIG_BOOTX_TEXT
+	/* Update debug text engine */
+	btext_update_display(rinfo->fb_base_phys, mode->xres, mode->yres,
+			     rinfo->depth, info->fix.line_length);
+#endif
+
+	return 0;
+}
+
+
+
+static struct fb_ops radeonfb_ops = {
+	.owner			= THIS_MODULE,
+	.fb_check_var		= radeonfb_check_var,
+	.fb_set_par		= radeonfb_set_par,
+	.fb_setcolreg		= radeonfb_setcolreg,
+	.fb_pan_display 	= radeonfb_pan_display,
+	.fb_blank		= radeonfb_blank,
+	.fb_ioctl		= radeonfb_ioctl,
+	.fb_sync		= radeonfb_sync,
+	.fb_fillrect		= radeonfb_fillrect,
+	.fb_copyarea		= radeonfb_copyarea,
+	.fb_imageblit		= radeonfb_imageblit,
+	.fb_cursor		= soft_cursor,
+};
+
+
+static int __devinit radeon_set_fbinfo (struct radeonfb_info *rinfo)
+{
+	struct fb_info *info;
+
+	info = &rinfo->info;
+
+	info->currcon = -1;
+	info->par = rinfo;
+	info->pseudo_palette = rinfo->pseudo_palette;
+        info->flags = FBINFO_FLAG_DEFAULT;
+        info->fbops = &radeonfb_ops;
+        info->display_fg = NULL;
+        info->screen_base = (char *)rinfo->fb_base;
+
+	/* Fill fix common fields */
+	strlcpy(info->fix.id, rinfo->name, sizeof(info->fix.id));
+        info->fix.smem_start = rinfo->fb_base_phys;
+        info->fix.smem_len = rinfo->video_ram;
+        info->fix.type = FB_TYPE_PACKED_PIXELS;
+        info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+        info->fix.xpanstep = 8;
+        info->fix.ypanstep = 1;
+        info->fix.ywrapstep = 0;
+        info->fix.type_aux = 0;
+        info->fix.mmio_start = rinfo->mmio_base_phys;
+        info->fix.mmio_len = RADEON_REGSIZE;
+	if (radeon_accel_disabled())
+	        info->fix.accel = FB_ACCEL_NONE;
+	else
+		info->fix.accel = FB_ACCEL_ATI_RADEON;
+
+	fb_alloc_cmap(&info->cmap, 256, 0);
+
+	if (radeon_accel_disabled())
+		info->var.accel_flags &= ~FB_ACCELF_TEXT;
+	else
+		info->var.accel_flags |= FB_ACCELF_TEXT;
+
+        return 0;
+}
+
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+
+/* TODO: Dbl check these tables, we don't go up to full ON backlight
+ * in these, possibly because we noticed MacOS doesn't, but I'd prefer
+ * having some more official numbers from ATI
+ */
+static int backlight_conv_m6[] = {
+	0xff, 0xc0, 0xb5, 0xaa, 0x9f, 0x94, 0x89, 0x7e,
+	0x73, 0x68, 0x5d, 0x52, 0x47, 0x3c, 0x31, 0x24
+};
+static int backlight_conv_m7[] = {
+	0x00, 0x3f, 0x4a, 0x55, 0x60, 0x6b, 0x76, 0x81,
+	0x8c, 0x97, 0xa2, 0xad, 0xb8, 0xc3, 0xce, 0xd9
+};
+
+#define BACKLIGHT_LVDS_OFF
+#undef BACKLIGHT_DAC_OFF
+
+/* We turn off the LCD completely instead of just dimming the backlight.
+ * This provides some greater power saving and the display is useless
+ * without backlight anyway.
+ */
+static int radeon_set_backlight_enable(int on, int level, void *data)
+{
+	struct radeonfb_info *rinfo = (struct radeonfb_info *)data;
+	unsigned int lvds_gen_cntl = INREG(LVDS_GEN_CNTL);
+	unsigned long tmpPixclksCntl = INPLL(PIXCLKS_CNTL);
+	int* conv_table;
+
+	if (rinfo->mon1_type != MT_LCD)
+		return 0;
+
+	/* Pardon me for that hack... maybe some day we can figure
+	 * out in what direction backlight should work on a given
+	 * panel ?
+	 */
+	if ((rinfo->family == CHIP_FAMILY_RV200 ||
+	     rinfo->family == CHIP_FAMILY_RV250 ||
+	     rinfo->family == CHIP_FAMILY_RV280 ||
+	     rinfo->family == CHIP_FAMILY_RV350) &&
+	    !machine_is_compatible("PowerBook4,3") &&
+	    !machine_is_compatible("PowerBook6,3"))
+		conv_table = backlight_conv_m7;
+	else
+		conv_table = backlight_conv_m6;
+
+	del_timer_sync(&rinfo->lvds_timer);
+
+	lvds_gen_cntl |= (LVDS_BL_MOD_EN | LVDS_BLON);
+	if (on && (level > BACKLIGHT_OFF)) {
+		lvds_gen_cntl |= LVDS_DIGON;
+		if (!lvds_gen_cntl & LVDS_ON) {
+			lvds_gen_cntl &= ~LVDS_BLON;
+			OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
+			(void)INREG(LVDS_GEN_CNTL);
+			mdelay(rinfo->panel_info.pwr_delay);/* OUCH !!! FIXME */
+			lvds_gen_cntl |= LVDS_BLON;
+			OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
+		}
+		lvds_gen_cntl &= ~LVDS_BL_MOD_LEVEL_MASK;
+		lvds_gen_cntl |= (conv_table[level] <<
+				  LVDS_BL_MOD_LEVEL_SHIFT);
+		lvds_gen_cntl |= (LVDS_ON | LVDS_EN);
+		lvds_gen_cntl &= ~LVDS_DISPLAY_DIS;
+	} else {
+		/* Asic bug, when turning off LVDS_ON, we have to make sure
+		   RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
+		*/
+		if (rinfo->is_mobility || rinfo->is_IGP)
+			OUTPLLP(PIXCLKS_CNTL, 0, ~PIXCLK_LVDS_ALWAYS_ONb);
+		lvds_gen_cntl &= ~LVDS_BL_MOD_LEVEL_MASK;
+		lvds_gen_cntl |= (conv_table[0] <<
+				  LVDS_BL_MOD_LEVEL_SHIFT);
+		lvds_gen_cntl |= LVDS_DISPLAY_DIS | LVDS_BLON;
+		OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
+		mdelay(rinfo->panel_info.pwr_delay);/* OUCH !!! FIXME */
+		lvds_gen_cntl &= ~(LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGON);
+	}
+
+	OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
+	if (rinfo->is_mobility || rinfo->is_IGP)
+		OUTPLL(PIXCLKS_CNTL, tmpPixclksCntl);
+	rinfo->init_state.lvds_gen_cntl &= ~LVDS_STATE_MASK;
+	rinfo->init_state.lvds_gen_cntl |= (lvds_gen_cntl & LVDS_STATE_MASK);
+
+	return 0;
+}
+
+
+static int radeon_set_backlight_level(int level, void *data)
+{
+	return radeon_set_backlight_enable(1, level, data);
+}
+#endif /* CONFIG_PMAC_BACKLIGHT */
+
+
+/*
+ * This reconfigure the card's internal memory map. In theory, we'd like
+ * to setup the card's memory at the same address as it's PCI bus address,
+ * and the AGP aperture right after that so that system RAM on 32 bits
+ * machines at least, is directly accessible. However, doing so would
+ * conflict with the current XFree drivers...
+ * Ultimately, I hope XFree, GATOS and ATI binary drivers will all agree
+ * on the proper way to set this up and duplicate this here. In the meantime,
+ * I put the card's memory at 0 in card space and AGP at some random high
+ * local (0xe0000000 for now) that will be changed by XFree/DRI anyway
+ */
+#ifdef CONFIG_PPC_OF
+#undef SET_MC_FB_FROM_APERTURE
+static void fixup_memory_mappings(struct radeonfb_info *rinfo)
+{
+	u32 save_crtc_gen_cntl, save_crtc2_gen_cntl;
+	u32 save_crtc_ext_cntl;
+	u32 aper_base, aper_size;
+	u32 agp_base;
+
+	/* First, we disable display to avoid interfering */
+	if (rinfo->has_CRTC2) {
+		save_crtc2_gen_cntl = INREG(CRTC2_GEN_CNTL);
+		OUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl | CRTC2_DISP_REQ_EN_B);
+	}
+	save_crtc_gen_cntl = INREG(CRTC_GEN_CNTL);
+	save_crtc_ext_cntl = INREG(CRTC_EXT_CNTL);
+	
+	OUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl | CRTC_DISPLAY_DIS);
+	OUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl | CRTC_DISP_REQ_EN_B);
+	mdelay(100);
+
+	aper_base = INREG(CONFIG_APER_0_BASE);
+	aper_size = INREG(CONFIG_APER_SIZE);
+
+#ifdef SET_MC_FB_FROM_APERTURE
+	/* Set framebuffer to be at the same address as set in PCI BAR */
+	OUTREG(MC_FB_LOCATION, 
+		((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16));
+	rinfo->fb_local_base = aper_base;
+#else
+	OUTREG(MC_FB_LOCATION, 0x7fff0000);
+	rinfo->fb_local_base = 0;
+#endif
+	agp_base = aper_base + aper_size;
+	if (agp_base & 0xf0000000)
+		agp_base = (aper_base | 0x0fffffff) + 1;
+
+	/* Set AGP to be just after the framebuffer on a 256Mb boundary. This
+	 * assumes the FB isn't mapped to 0xf0000000 or above, but this is
+	 * always the case on PPCs afaik.
+	 */
+#ifdef SET_MC_FB_FROM_APERTURE
+	OUTREG(MC_AGP_LOCATION, 0xffff0000 | (agp_base >> 16));
+#else
+	OUTREG(MC_AGP_LOCATION, 0xffffe000);
+#endif
+
+	/* Fixup the display base addresses & engine offsets while we
+	 * are at it as well
+	 */
+#ifdef SET_MC_FB_FROM_APERTURE
+	OUTREG(DISPLAY_BASE_ADDR, aper_base);
+	if (rinfo->has_CRTC2)
+		OUTREG(CRTC2_DISPLAY_BASE_ADDR, aper_base);
+#else
+	OUTREG(DISPLAY_BASE_ADDR, 0);
+	if (rinfo->has_CRTC2)
+		OUTREG(CRTC2_DISPLAY_BASE_ADDR, 0);
+#endif
+	mdelay(100);
+
+	/* Restore display settings */
+	OUTREG(CRTC_GEN_CNTL, save_crtc_gen_cntl);
+	OUTREG(CRTC_EXT_CNTL, save_crtc_ext_cntl);
+	if (rinfo->has_CRTC2)
+		OUTREG(CRTC2_GEN_CNTL, save_crtc2_gen_cntl);	
+
+	RTRACE("aper_base: %08x MC_FB_LOC to: %08x, MC_AGP_LOC to: %08x\n",
+		aper_base,
+		((aper_base + aper_size - 1) & 0xffff0000) | (aper_base >> 16),
+		0xffff0000 | (agp_base >> 16));
+}
+#endif /* CONFIG_PPC_OF */
+
+
+/*
+ * Sysfs
+ */
+
+static ssize_t radeon_show_one_edid(char *buf, loff_t off, size_t count, const u8 *edid)
+{
+	if (off > EDID_LENGTH)
+		return 0;
+
+	if (off + count > EDID_LENGTH)
+		count = EDID_LENGTH - off;
+
+	memcpy(buf, edid + off, count);
+
+	return count;
+}
+
+
+static ssize_t radeon_show_edid1(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct radeonfb_info *rinfo = pci_get_drvdata(pdev);
+
+	return radeon_show_one_edid(buf, off, count, rinfo->mon1_EDID);
+}
+
+
+static ssize_t radeon_show_edid2(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct radeonfb_info *rinfo = pci_get_drvdata(pdev);
+
+	return radeon_show_one_edid(buf, off, count, rinfo->mon2_EDID);
+}
+
+static struct bin_attribute edid1_attr = {
+	.attr   = {
+		.name	= "edid1",
+		.owner	= THIS_MODULE,
+		.mode	= 0444,
+	},
+	.size	= EDID_LENGTH,
+	.read	= radeon_show_edid1,
+};
+
+static struct bin_attribute edid2_attr = {
+	.attr   = {
+		.name	= "edid2",
+		.owner	= THIS_MODULE,
+		.mode	= 0444,
+	},
+	.size	= EDID_LENGTH,
+	.read	= radeon_show_edid2,
+};
+
+
+static int radeonfb_pci_register (struct pci_dev *pdev,
+				  const struct pci_device_id *ent)
+{
+	struct radeonfb_info *rinfo;
+	u32 tmp;
+
+	RTRACE("radeonfb_pci_register BEGIN\n");
+	
+	/* Enable device in PCI config */
+	if (pci_enable_device(pdev) != 0) {
+		printk(KERN_ERR "radeonfb: Cannot enable PCI device\n");
+		return -ENODEV;
+	}
+
+	rinfo = kmalloc (sizeof (struct radeonfb_info), GFP_KERNEL);
+	if (!rinfo) {
+		printk (KERN_ERR "radeonfb: could not allocate memory\n");
+		return -ENODEV;
+	}
+
+	memset (rinfo, 0, sizeof (struct radeonfb_info));
+	rinfo->pdev = pdev;
+	
+	spin_lock_init(&rinfo->reg_lock);
+	init_timer(&rinfo->lvds_timer);
+	rinfo->lvds_timer.function = radeon_lvds_timer_func;
+	rinfo->lvds_timer.data = (unsigned long)rinfo;
+
+	strcpy(rinfo->name, "ATI Radeon XX ");
+	rinfo->name[11] = ent->device >> 8;
+	rinfo->name[12] = ent->device & 0xFF;
+	rinfo->family = ent->driver_data & CHIP_FAMILY_MASK;
+	rinfo->chipset = pdev->device;
+	rinfo->has_CRTC2 = (ent->driver_data & CHIP_HAS_CRTC2) != 0;
+	rinfo->is_mobility = (ent->driver_data & CHIP_IS_MOBILITY) != 0;
+	rinfo->is_IGP = (ent->driver_data & CHIP_IS_IGP) != 0;
+		
+	/* Set base addrs */
+	rinfo->fb_base_phys = pci_resource_start (pdev, 0);
+	rinfo->mmio_base_phys = pci_resource_start (pdev, 2);
+
+	/* request the mem regions */
+	if (!request_mem_region (rinfo->fb_base_phys,
+				 pci_resource_len(pdev, 0), "radeonfb")) {
+		printk (KERN_ERR "radeonfb: cannot reserve FB region\n");
+		goto free_rinfo;
+	}
+
+	if (!request_mem_region (rinfo->mmio_base_phys,
+				 pci_resource_len(pdev, 2), "radeonfb")) {
+		printk (KERN_ERR "radeonfb: cannot reserve MMIO region\n");
+		goto release_fb;
+	}
+
+	/* map the regions */
+	rinfo->mmio_base = (unsigned long) ioremap (rinfo->mmio_base_phys, RADEON_REGSIZE);
+	if (!rinfo->mmio_base) {
+		printk (KERN_ERR "radeonfb: cannot map MMIO\n");
+		goto release_mmio;
+	}
+
+	/* On PPC, the firmware sets up a memory mapping that tends
+	 * to cause lockups when enabling the engine. We reconfigure
+	 * the card internal memory mappings properly
+	 */
+#ifdef CONFIG_PPC_OF
+	fixup_memory_mappings(rinfo);
+#else	
+	rinfo->fb_local_base = INREG(MC_FB_LOCATION) << 16;
+#endif /* CONFIG_PPC_OF */
+
+	/* framebuffer size */
+	tmp = INREG(CONFIG_MEMSIZE);
+
+	/* mem size is bits [28:0], mask off the rest */
+	rinfo->video_ram = tmp & CONFIG_MEMSIZE_MASK;
+
+	/* ram type */
+	tmp = INREG(MEM_SDRAM_MODE_REG);
+	switch ((MEM_CFG_TYPE & tmp) >> 30) {
+       	case 0:
+       		/* SDR SGRAM (2:1) */
+       		strcpy(rinfo->ram_type, "SDR SGRAM");
+       		rinfo->ram.ml = 4;
+       		rinfo->ram.mb = 4;
+       		rinfo->ram.trcd = 1;
+       		rinfo->ram.trp = 2;
+       		rinfo->ram.twr = 1;
+       		rinfo->ram.cl = 2;
+       		rinfo->ram.loop_latency = 16;
+       		rinfo->ram.rloop = 16;
+       		break;
+       	case 1:
+       		/* DDR SGRAM */
+       		strcpy(rinfo->ram_type, "DDR SGRAM");
+       		rinfo->ram.ml = 4;
+       		rinfo->ram.mb = 4;
+       		rinfo->ram.trcd = 3;
+       		rinfo->ram.trp = 3;
+       		rinfo->ram.twr = 2;
+       		rinfo->ram.cl = 3;
+       		rinfo->ram.tr2w = 1;
+       		rinfo->ram.loop_latency = 16;
+       		rinfo->ram.rloop = 16;
+		break;
+       	default:
+       		/* 64-bit SDR SGRAM */
+       		strcpy(rinfo->ram_type, "SDR SGRAM 64");
+       		rinfo->ram.ml = 4;
+       		rinfo->ram.mb = 8;
+       		rinfo->ram.trcd = 3;
+       		rinfo->ram.trp = 3;
+       		rinfo->ram.twr = 1;
+       		rinfo->ram.cl = 3;
+       		rinfo->ram.tr2w = 1;
+       		rinfo->ram.loop_latency = 17;
+       		rinfo->ram.rloop = 17;
+		break;
+	}
+
+	/*
+	 * Hack to get around some busted production M6's
+	 * reporting no ram
+	 */
+	if (rinfo->video_ram == 0) {
+		switch (pdev->device) {
+	       	case PCI_CHIP_RADEON_LY:
+		case PCI_CHIP_RADEON_LZ:
+	       		rinfo->video_ram = 8192 * 1024;
+	       		break;
+	       	default:
+	       		break;
+		}
+	}
+
+	RTRACE("radeonfb: probed %s %ldk videoram\n", (rinfo->ram_type), (rinfo->video_ram/1024));
+
+	rinfo->fb_base = (unsigned long) ioremap (rinfo->fb_base_phys, rinfo->video_ram);
+	if (!rinfo->fb_base) {
+		printk (KERN_ERR "radeonfb: cannot map FB\n");
+		goto unmap_rom;
+	}
+	/* Argh. Scary arch !!! */
+#ifdef CONFIG_PPC64
+	rinfo->fb_base = IO_TOKEN_TO_ADDR(rinfo->fb_base);
+#endif
+
+	/*
+	 * Check for required workaround for PLL accesses
+	 */
+	rinfo->R300_cg_workaround = (rinfo->family == CHIP_FAMILY_R300 &&
+				     (INREG(CONFIG_CNTL) & CFG_ATI_REV_ID_MASK)
+				     == CFG_ATI_REV_A11);
+
+	/*
+	 * Map the BIOS ROM if any and retreive PLL parameters from
+	 * either BIOS or Open Firmware
+	 */
+	radeon_map_ROM(rinfo, pdev);
+
+	/*
+	 * On x86, the primary display on laptop may have it's BIOS
+	 * ROM elsewhere, try to locate it at the legacy memory hole.
+	 * We probably need to make sure this is the primary dispay,
+	 * but that is difficult without some arch support.
+	 */
+#ifdef __i386__
+	if (rinfo->bios_seg == NULL)
+		radeon_find_mem_vbios(rinfo);
+#endif /* __i386__ */
+
+	/* Get informations about the board's PLL */
+	radeon_get_pllinfo(rinfo);
+
+#ifdef CONFIG_FB_RADEON_I2C
+	/* Register I2C bus */
+	radeon_create_i2c_busses(rinfo);
+#endif
+
+	/* set all the vital stuff */
+	radeon_set_fbinfo (rinfo);
+
+	/* Probe screen types */
+	radeon_probe_screens(rinfo, monitor_layout, ignore_edid);
+
+	/* Build mode list, check out panel native model */
+	radeon_check_modes(rinfo, mode_option);
+
+	/* Register some sysfs stuff (should be done better) */
+	if (rinfo->mon1_EDID)
+		sysfs_create_bin_file(&rinfo->pdev->dev.kobj, &edid1_attr);
+	if (rinfo->mon2_EDID)
+		sysfs_create_bin_file(&rinfo->pdev->dev.kobj, &edid2_attr);
+
+	/* save current mode regs before we switch into the new one
+	 * so we can restore this upon __exit
+	 */
+	radeon_save_state (rinfo, &rinfo->init_state);
+
+	pci_set_drvdata(pdev, rinfo);
+
+	/* Enable PM on mobility chips */
+	if (rinfo->is_mobility) {
+		/* Find PM registers in config space */
+		rinfo->pm_reg = pci_find_capability(pdev, PCI_CAP_ID_PM);
+		/* Enable dynamic PM of chip clocks */
+		radeon_pm_enable_dynamic_mode(rinfo);
+		printk("radeonfb: Power Management enabled for Mobility chipsets\n");
+	}
+
+	if (register_framebuffer ((struct fb_info *) rinfo) < 0) {
+		printk (KERN_ERR "radeonfb: could not register framebuffer\n");
+		goto unmap_fb;
+	}
+
+#ifdef CONFIG_MTRR
+	rinfo->mtrr_hdl = nomtrr ? -1 : mtrr_add(rinfo->fb_base_phys,
+						 rinfo->video_ram,
+						 MTRR_TYPE_WRCOMB, 1);
+#endif
+
+#ifdef CONFIG_PMAC_BACKLIGHT
+	if (rinfo->mon1_type == MT_LCD) {
+		register_backlight_controller(&radeon_backlight_controller,
+					      rinfo, "ati");
+		register_backlight_controller(&radeon_backlight_controller,
+					      rinfo, "mnca");
+	}
+#endif
+
+	printk ("radeonfb: %s %s %ld MB\n", rinfo->name, rinfo->ram_type,
+		(rinfo->video_ram/(1024*1024)));
+
+	if (rinfo->bios_seg)
+		radeon_unmap_ROM(rinfo, pdev);
+	RTRACE("radeonfb_pci_register END\n");
+
+	return 0;
+unmap_fb:
+	iounmap ((void*)rinfo->fb_base);
+unmap_rom:	
+	if (rinfo->mon1_EDID)
+	    kfree(rinfo->mon1_EDID);
+	if (rinfo->mon2_EDID)
+	    kfree(rinfo->mon2_EDID);
+	if (rinfo->mon1_modedb)
+		fb_destroy_modedb(rinfo->mon1_modedb);
+#ifdef CONFIG_FB_RADEON_I2C
+	radeon_delete_i2c_busses(rinfo);
+#endif
+	if (rinfo->bios_seg)
+		radeon_unmap_ROM(rinfo, pdev);
+	iounmap ((void*)rinfo->mmio_base);
+release_mmio:
+	release_mem_region (rinfo->mmio_base_phys,
+			    pci_resource_len(pdev, 2));
+release_fb:	
+	release_mem_region (rinfo->fb_base_phys,
+			    pci_resource_len(pdev, 0));
+free_rinfo:	
+	kfree (rinfo);
+	return -ENODEV;
+}
+
+
+
+static void __devexit radeonfb_pci_unregister (struct pci_dev *pdev)
+{
+        struct radeonfb_info *rinfo = pci_get_drvdata(pdev);
+ 
+        if (!rinfo)
+                return;
+ 
+	/* restore original state
+	 * 
+	 * Doesn't quite work yet, possibly because of the PPC hacking
+	 * I do on startup, disable for now. --BenH
+	 */
+        radeon_write_mode (rinfo, &rinfo->init_state);
+ 
+	del_timer_sync(&rinfo->lvds_timer);
+
+#ifdef CONFIG_MTRR
+	if (rinfo->mtrr_hdl >= 0)
+		mtrr_del(rinfo->mtrr_hdl, 0, 0);
+#endif
+
+        unregister_framebuffer ((struct fb_info *) rinfo);
+
+        iounmap ((void*)rinfo->mmio_base);
+        iounmap ((void*)rinfo->fb_base);
+ 
+	release_mem_region (rinfo->mmio_base_phys,
+			    pci_resource_len(pdev, 2));
+	release_mem_region (rinfo->fb_base_phys,
+			    pci_resource_len(pdev, 0));
+
+	if (rinfo->mon1_EDID)
+		kfree(rinfo->mon1_EDID);
+	if (rinfo->mon2_EDID)
+		kfree(rinfo->mon2_EDID);
+	if (rinfo->mon1_modedb)
+		fb_destroy_modedb(rinfo->mon1_modedb);
+#ifdef CONFIG_FB_RADEON_I2C
+	radeon_delete_i2c_busses(rinfo);
+#endif        
+        kfree (rinfo);
+}
+
+
+static struct pci_driver radeonfb_driver = {
+	.name		= "radeonfb",
+	.id_table	= radeonfb_pci_table,
+	.probe		= radeonfb_pci_register,
+	.remove		= __devexit_p(radeonfb_pci_unregister),
+#ifdef CONFIG_PM
+	.suspend       	= radeonfb_pci_suspend,
+	.resume		= radeonfb_pci_resume,
+#endif /* CONFIG_PM */
+};
+
+
+int __init radeonfb_init (void)
+{
+	radeonfb_noaccel = noaccel;
+	return pci_module_init (&radeonfb_driver);
+}
+
+
+void __exit radeonfb_exit (void)
+{
+	pci_unregister_driver (&radeonfb_driver);
+}
+
+int __init radeonfb_setup (char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep (&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+
+		if (!strncmp(this_opt, "noaccel", 7)) {
+			radeonfb_noaccel = 1;
+		} else if (!strncmp(this_opt, "mirror", 6)) {
+			mirror = 1;
+		} else if (!strncmp(this_opt, "force_dfp", 9)) {
+			force_dfp = 1;
+		} else if (!strncmp(this_opt, "panel_yres:", 11)) {
+			panel_yres = simple_strtoul((this_opt+11), NULL, 0);
+#ifdef CONFIG_MTRR
+		} else if (!strncmp(this_opt, "nomtrr", 6)) {
+			nomtrr = 1;
+#endif
+		} else if (!strncmp(this_opt, "nomodeset", 9)) {
+			nomodeset = 1;
+		} else if (!strncmp(this_opt, "force_measure_pll", 17)) {
+			force_measure_pll = 1;
+		} else if (!strncmp(this_opt, "ignore_edid", 11)) {
+			ignore_edid = 1;
+		} else
+			mode_option = this_opt;
+	}
+	return 0;
+}
+
+
+#ifdef MODULE
+module_init(radeonfb_init);
+module_exit(radeonfb_exit);
+#endif
+
+MODULE_AUTHOR("Ani Joshi");
+MODULE_DESCRIPTION("framebuffer driver for ATI Radeon chipset");
+MODULE_LICENSE("GPL");
+module_param(noaccel, bool, 0);
+MODULE_PARM_DESC(noaccel, "bool: disable acceleration");
+module_param(nomodeset, bool, 0);
+MODULE_PARM_DESC(nomodeset, "bool: disable actual setting of video mode");
+module_param(mirror, bool, 0);
+MODULE_PARM_DESC(mirror, "bool: mirror the display to both monitors");
+module_param(force_dfp, bool, 0);
+MODULE_PARM_DESC(force_dfp, "bool: force display to dfp");
+module_param(ignore_edid, bool, 0);
+MODULE_PARM_DESC(ignore_edid, "bool: Ignore EDID data when doing DDC probe");
+module_param(monitor_layout, charp, 0);
+MODULE_PARM_DESC(monitor_layout, "Specify monitor mapping (like XFree86)");
+module_param(force_measure_pll, bool, 0);
+MODULE_PARM_DESC(force_measure_pll, "Force measurement of PLL (debug)");
+#ifdef CONFIG_MTRR
+module_param(nomtrr, bool, 0);
+MODULE_PARM_DESC(nomtrr, "bool: disable use of MTRR registers");
+#endif
+module_param(panel_yres, int, 0);
+MODULE_PARM_DESC(panel_yres, "int: set panel yres");
+module_param(mode_option, charp, 0);
+MODULE_PARM_DESC(mode_option, "Specify resolution as \"<xres>x<yres>[-<bpp>][@<refresh>]\" ");
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeon_i2c.c linuxppc-2.5-benh/drivers/video/aty/radeon_i2c.c
--- /dev/shm/linux-2.5/drivers/video/aty/radeon_i2c.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeon_i2c.c	2004-02-04 06:58:21.000000000 +0000
@@ -0,0 +1,258 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/fb.h>
+
+
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/i2c-algo-bit.h>
+
+#include <asm/io.h>
+
+#include <video/radeon.h>
+#include "radeonfb.h"
+#include "../edid.h"
+
+#define RADEON_DDC 	0x50
+
+static void radeon_gpio_setscl(void* data, int state)
+{
+	struct radeon_i2c_chan 	*chan = data;
+	struct radeonfb_info	*rinfo = chan->rinfo;
+	u32			val;
+	
+	val = INREG(chan->ddc_reg) & ~(VGA_DDC_CLK_OUT_EN);
+	if (!state)
+		val |= VGA_DDC_CLK_OUT_EN;
+
+	OUTREG(chan->ddc_reg, val);
+	(void)INREG(chan->ddc_reg);
+}
+
+static void radeon_gpio_setsda(void* data, int state)
+{
+	struct radeon_i2c_chan 	*chan = data;
+	struct radeonfb_info	*rinfo = chan->rinfo;
+	u32			val;
+	
+	val = INREG(chan->ddc_reg) & ~(VGA_DDC_DATA_OUT_EN);
+	if (!state)
+		val |= VGA_DDC_DATA_OUT_EN;
+
+	OUTREG(chan->ddc_reg, val);
+	(void)INREG(chan->ddc_reg);
+}
+
+static int radeon_gpio_getscl(void* data)
+{
+	struct radeon_i2c_chan 	*chan = data;
+	struct radeonfb_info	*rinfo = chan->rinfo;
+	u32			val;
+	
+	val = INREG(chan->ddc_reg);
+
+	return (val & VGA_DDC_CLK_INPUT) ? 1 : 0;
+}
+
+static int radeon_gpio_getsda(void* data)
+{
+	struct radeon_i2c_chan 	*chan = data;
+	struct radeonfb_info	*rinfo = chan->rinfo;
+	u32			val;
+	
+	val = INREG(chan->ddc_reg);
+
+	return (val & VGA_DDC_DATA_INPUT) ? 1 : 0;
+}
+
+static int radeon_setup_i2c_bus(struct radeon_i2c_chan *chan, const char *name)
+{
+	int rc;
+
+	strcpy(chan->adapter.name, name);
+	chan->adapter.owner		= THIS_MODULE;
+	chan->adapter.id		= I2C_ALGO_ATI;
+	chan->adapter.algo_data		= &chan->algo;
+	chan->adapter.dev.parent	= &chan->rinfo->pdev->dev;
+	chan->algo.setsda		= radeon_gpio_setsda;
+	chan->algo.setscl		= radeon_gpio_setscl;
+	chan->algo.getsda		= radeon_gpio_getsda;
+	chan->algo.getscl		= radeon_gpio_getscl;
+	chan->algo.udelay		= 40;
+	chan->algo.timeout		= 20;
+	chan->algo.data 		= chan;	
+	
+	i2c_set_adapdata(&chan->adapter, chan);
+	
+	/* Raise SCL and SDA */
+	radeon_gpio_setsda(chan, 1);
+	radeon_gpio_setscl(chan, 1);
+	udelay(20);
+
+	rc = i2c_bit_add_bus(&chan->adapter);
+	if (rc == 0)
+		dev_dbg(&chan->rinfo->pdev->dev, "I2C bus %s registered.\n", name);
+	else
+		dev_warn(&chan->rinfo->pdev->dev, "Failed to register I2C bus %s.\n", name);
+	return rc;
+}
+
+void radeon_create_i2c_busses(struct radeonfb_info *rinfo)
+{
+	rinfo->i2c[0].rinfo	= rinfo;
+	rinfo->i2c[0].ddc_reg	= GPIO_MONID;
+	radeon_setup_i2c_bus(&rinfo->i2c[0], "monid");
+
+	rinfo->i2c[1].rinfo	= rinfo;
+	rinfo->i2c[1].ddc_reg	= GPIO_DVI_DDC;
+	radeon_setup_i2c_bus(&rinfo->i2c[1], "dvi");
+
+	rinfo->i2c[2].rinfo	= rinfo;
+	rinfo->i2c[2].ddc_reg	= GPIO_VGA_DDC;
+	radeon_setup_i2c_bus(&rinfo->i2c[2], "vga");
+
+	rinfo->i2c[3].rinfo	= rinfo;
+	rinfo->i2c[3].ddc_reg	= GPIO_CRT2_DDC;
+	radeon_setup_i2c_bus(&rinfo->i2c[3], "crt2");
+}
+
+void radeon_delete_i2c_busses(struct radeonfb_info *rinfo)
+{
+	if (rinfo->i2c[0].rinfo)
+		i2c_bit_del_bus(&rinfo->i2c[0].adapter);
+	rinfo->i2c[0].rinfo = NULL;
+
+	if (rinfo->i2c[1].rinfo)
+		i2c_bit_del_bus(&rinfo->i2c[1].adapter);
+	rinfo->i2c[1].rinfo = NULL;
+
+	if (rinfo->i2c[2].rinfo)
+		i2c_bit_del_bus(&rinfo->i2c[2].adapter);
+	rinfo->i2c[2].rinfo = NULL;
+
+	if (rinfo->i2c[3].rinfo)
+		i2c_bit_del_bus(&rinfo->i2c[3].adapter);
+	rinfo->i2c[3].rinfo = NULL;
+}
+
+
+static u8 *radeon_do_probe_i2c_edid(struct radeon_i2c_chan *chan)
+{
+	u8 start = 0x0;
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= RADEON_DDC,
+			.len	= 1,
+			.buf	= &start,
+		}, {
+			.addr	= RADEON_DDC,
+			.flags	= I2C_M_RD,
+			.len	= EDID_LENGTH,
+		},
+	};
+	u8 *buf;
+
+	buf = kmalloc(EDID_LENGTH, GFP_KERNEL);
+	if (!buf) {
+		dev_warn(&chan->rinfo->pdev->dev, "Out of memory!\n");
+		return NULL;
+	}
+	msgs[1].buf = buf;
+
+	if (i2c_transfer(&chan->adapter, msgs, 2) == 2)
+		return buf;
+	dev_dbg(&chan->rinfo->pdev->dev, "Unable to read EDID block.\n");
+	kfree(buf);
+	return NULL;
+}
+
+
+int radeon_probe_i2c_connector(struct radeonfb_info *rinfo, int conn, u8 **out_edid)
+{
+	u32 reg = rinfo->i2c[conn-1].ddc_reg;
+	u8 *edid = NULL;
+	int i, j;
+
+	OUTREG(reg, INREG(reg) & 
+			~(VGA_DDC_DATA_OUTPUT | VGA_DDC_CLK_OUTPUT));
+
+	OUTREG(reg, INREG(reg) & ~(VGA_DDC_CLK_OUT_EN));
+	(void)INREG(reg);
+
+	for (i = 0; i < 3; i++) {
+		/* For some old monitors we need the
+		 * following process to initialize/stop DDC
+		 */
+		OUTREG(reg, INREG(reg) & ~(VGA_DDC_DATA_OUT_EN));
+		(void)INREG(reg);
+		wait_ms(13);
+
+		OUTREG(reg, INREG(reg) & ~(VGA_DDC_CLK_OUT_EN));
+		(void)INREG(reg);
+		for (j = 0; j < 5; j++) {
+			wait_ms(10);
+			if (INREG(reg) & VGA_DDC_CLK_INPUT)
+				break;
+		}
+		if (j == 5)
+			continue;
+
+		OUTREG(reg, INREG(reg) | VGA_DDC_DATA_OUT_EN);
+		(void)INREG(reg);
+		wait_ms(15);
+		OUTREG(reg, INREG(reg) | VGA_DDC_CLK_OUT_EN);
+		(void)INREG(reg);
+		wait_ms(15);
+		OUTREG(reg, INREG(reg) & ~(VGA_DDC_DATA_OUT_EN));
+		(void)INREG(reg);
+		wait_ms(15);
+
+		/* Do the real work */
+		edid = radeon_do_probe_i2c_edid(&rinfo->i2c[conn-1]);
+
+		OUTREG(reg, INREG(reg) | 
+				(VGA_DDC_DATA_OUT_EN | VGA_DDC_CLK_OUT_EN));
+		(void)INREG(reg);
+		wait_ms(15);
+		
+		OUTREG(reg, INREG(reg) & ~(VGA_DDC_CLK_OUT_EN));
+		(void)INREG(reg);
+		for (j = 0; j < 10; j++) {
+			wait_ms(10);
+			if (INREG(reg) & VGA_DDC_CLK_INPUT)
+				break;
+		}
+
+		OUTREG(reg, INREG(reg) & ~(VGA_DDC_DATA_OUT_EN));
+		(void)INREG(reg);
+		wait_ms(15);
+		OUTREG(reg, INREG(reg) |
+				(VGA_DDC_DATA_OUT_EN | VGA_DDC_CLK_OUT_EN));
+		(void)INREG(reg);
+		if (edid)
+			break;
+	}
+	if (out_edid)
+		*out_edid = edid;
+	if (!edid) {
+		RTRACE("radeonfb: I2C (port %d) ... not found\n", conn);
+		return MT_NONE;
+	}
+	if (edid[0x14] & 0x80) {
+		if (rinfo->is_mobility && conn == ddc_dvi &&
+		    (INREG(LVDS_GEN_CNTL) & LVDS_ON)) {
+			RTRACE("radeonfb: I2C (port %d) ... found LVDS panel\n", conn);
+			return MT_LCD;
+		} else {
+			RTRACE("radeonfb: I2C (port %d) ... found TMDS panel\n", conn);
+			return MT_DFP;
+		}
+	}
+       	RTRACE("radeonfb: I2C (port %d) ... found CRT display\n", conn);
+	return MT_CRT;
+}
+
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeon_monitor.c linuxppc-2.5-benh/drivers/video/aty/radeon_monitor.c
--- /dev/shm/linux-2.5/drivers/video/aty/radeon_monitor.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeon_monitor.c	2004-01-21 00:25:45.000000000 +0000
@@ -0,0 +1,912 @@
+#include "radeonfb.h"
+#include "../edid.h"
+
+#ifdef CONFIG_PPC_OF
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#endif /* CONFIG_PPC_OF */
+
+static struct fb_var_screeninfo radeonfb_default_var = {
+        640, 480, 640, 480, 0, 0, 8, 0,
+        {0, 6, 0}, {0, 6, 0}, {0, 6, 0}, {0, 0, 0},
+        0, 0, -1, -1, 0, 39721, 40, 24, 32, 11, 96, 2,
+        0, FB_VMODE_NONINTERLACED
+};
+
+static char *radeon_get_mon_name(int type)
+{
+	char *pret = NULL;
+
+	switch (type) {
+		case MT_NONE:
+			pret = "no";
+			break;
+		case MT_CRT:
+			pret = "CRT";
+			break;
+		case MT_DFP:
+			pret = "DFP";
+			break;
+		case MT_LCD:
+			pret = "LCD";
+			break;
+		case MT_CTV:
+			pret = "CTV";
+			break;
+		case MT_STV:
+			pret = "STV";
+			break;
+	}
+
+	return pret;
+}
+
+
+#ifdef CONFIG_PPC_OF
+/*
+ * Try to find monitor informations & EDID data out of the Open Firmware
+ * device-tree. This also contains some "hacks" to work around a few machine
+ * models with broken OF probing by hard-coding known EDIDs for some Mac
+ * laptops internal LVDS panel. (XXX: not done yet)
+ */
+static int __devinit radeon_parse_montype_prop(struct device_node *dp, u8 **out_EDID, int hdno)
+{
+        static char *propnames[] = { "DFP,EDID", "LCD,EDID", "EDID", "EDID1", "EDID2",  NULL };
+	u8 *pedid = NULL;
+	u8 *pmt = NULL;
+	u8 *tmp;
+        int i, mt;  
+	
+	RTRACE("analyzing OF properties...\n");
+	pmt = (u8 *)get_property(dp, "display-type", NULL);
+	if (!pmt)
+		return MT_NONE;
+	RTRACE("display-type: %s\n", pmt);
+	/* OF says "LCD" for DFP as well, we discriminate from the caller of this
+	 * function
+	 */
+	if (!strcmp(pmt, "LCD") || !strcmp(pmt, "DFP"))
+		mt = MT_DFP;
+	else if (!strcmp(pmt, "CRT"))
+		mt = MT_CRT;
+	else if (strcmp(pmt, "NONE")) {
+		printk(KERN_WARNING "radeonfb: Unknown OF display-type: %s\n", pmt);
+		return MT_NONE;
+	}
+	for (i = 0; propnames[i] != NULL; ++i) {
+		pedid = (u8 *)get_property(dp, propnames[i], NULL);
+		if (pedid != NULL)
+			break;
+	}
+	/* We didn't find the EDID in the leaf node, some cards will actually
+	 * put EDID1/EDID2 in the parent, look for these (typically M6 tipb).
+	 * single-head cards have hdno == -1 and skip this step
+	 */
+	if (pedid == NULL && dp->parent && (hdno != -1))
+		pedid = get_property(dp->parent, (hdno == 0) ? "EDID1" : "EDID2", NULL);
+	if (pedid == NULL && dp->parent && (hdno == 0))
+		pedid = get_property(dp->parent, "EDID", NULL);
+	if (pedid == NULL)
+		return mt;
+
+	tmp = (u8 *)kmalloc(EDID_LENGTH, GFP_KERNEL);
+	if (!tmp)
+		return mt;
+	memcpy(tmp, pedid, EDID_LENGTH);
+	*out_EDID = tmp;
+	return mt;
+}
+
+static int __devinit radeon_probe_OF_head(struct radeonfb_info *rinfo, int head_no,
+					  u8 **out_EDID)
+{
+        struct device_node *dp;
+
+	RTRACE("radeon_probe_OF_head\n");
+
+        dp = pci_device_to_OF_node(rinfo->pdev);
+        while (dp == NULL)
+		return MT_NONE;
+
+	if (rinfo->has_CRTC2) {
+		char *pname;
+		int len, second = 0;
+
+		dp = dp->child;
+		do {
+			if (!dp)
+				return MT_NONE;
+			pname = (char *)get_property(dp, "name", NULL);
+			if (!pname)
+				return MT_NONE;
+			len = strlen(pname);
+			RTRACE("head: %s (letter: %c, head_no: %d)\n",
+			       pname, pname[len-1], head_no);
+			if (pname[len-1] == 'A' && head_no == 0) {
+				int mt = radeon_parse_montype_prop(dp, out_EDID, 0);
+				/* Maybe check for LVDS_GEN_CNTL here ? I need to check out
+				 * what OF does when booting with lid closed
+				 */
+				if (mt == MT_DFP && rinfo->is_mobility)
+					mt = MT_LCD;
+				return mt;
+			} else if (pname[len-1] == 'B' && head_no == 1)
+				return radeon_parse_montype_prop(dp, out_EDID, 1);
+			second = 1;
+			dp = dp->sibling;
+		} while(!second);
+	} else {
+		if (head_no > 0)
+			return MT_NONE;
+		return radeon_parse_montype_prop(dp, out_EDID, -1);
+	}
+        return MT_NONE;
+}
+#endif /* CONFIG_PPC_OF */
+
+
+static int __devinit radeon_get_panel_info_BIOS(struct radeonfb_info *rinfo)
+{
+	unsigned long tmp, tmp0;
+	char stmp[30];
+	int i;
+
+	if (!rinfo->bios_seg)
+		return 0;
+
+	if (!(tmp = BIOS_IN16(rinfo->fp_bios_start + 0x40))) {
+		printk(KERN_ERR "radeonfb: Failed to detect DFP panel info using BIOS\n");
+		return 0;
+	}
+
+	for(i=0; i<24; i++)
+		stmp[i] = BIOS_IN8(tmp+i+1);
+	stmp[24] = 0;
+	printk("radeonfb: panel ID string: %s\n", stmp);
+	rinfo->panel_info.xres = BIOS_IN16(tmp + 25);
+	rinfo->panel_info.yres = BIOS_IN16(tmp + 27);
+	printk("radeonfb: detected LVDS panel size from BIOS: %dx%d\n",
+		rinfo->panel_info.xres, rinfo->panel_info.yres);
+
+	rinfo->panel_info.pwr_delay = BIOS_IN16(tmp + 44);
+	if (rinfo->panel_info.pwr_delay > 2000 || rinfo->panel_info.pwr_delay < 0)
+		rinfo->panel_info.pwr_delay = 2000;
+
+	/*
+	 * Some panels only work properly with some divider combinations
+	 */
+	rinfo->panel_info.ref_divider = BIOS_IN16(tmp + 46);
+	rinfo->panel_info.post_divider = BIOS_IN8(tmp + 48);
+	rinfo->panel_info.fbk_divider = BIOS_IN16(tmp + 49);
+	if (rinfo->panel_info.ref_divider != 0 &&
+	    rinfo->panel_info.fbk_divider > 3) {
+		rinfo->panel_info.use_bios_dividers = 1;
+		printk(KERN_INFO "radeondb: BIOS provided dividers will be used\n");
+	}
+	for(i=0; i<32; i++) {
+		tmp0 = BIOS_IN16(tmp+64+i*2);
+		if (tmp0 == 0)
+			break;
+		if ((BIOS_IN16(tmp0) == rinfo->panel_info.xres) &&
+		    (BIOS_IN16(tmp0+2) == rinfo->panel_info.yres)) {
+			rinfo->panel_info.hblank = (BIOS_IN16(tmp0+17) - BIOS_IN16(tmp0+19)) * 8;
+			rinfo->panel_info.hOver_plus = ((BIOS_IN16(tmp0+21) -
+							 BIOS_IN16(tmp0+19) -1) * 8) & 0x7fff;
+			rinfo->panel_info.hSync_width = BIOS_IN8(tmp0+23) * 8;
+			rinfo->panel_info.vblank = BIOS_IN16(tmp0+24) - BIOS_IN16(tmp0+26);
+			rinfo->panel_info.vOver_plus = (BIOS_IN16(tmp0+28) & 0x7ff) - BIOS_IN16(tmp0+26);
+			rinfo->panel_info.vSync_width = (BIOS_IN16(tmp0+28) & 0xf800) >> 11;
+			rinfo->panel_info.clock = BIOS_IN16(tmp0+9);
+			/* Assume high active syncs for now until ATI tells me more... maybe we
+			 * can probe register values here ?
+			 */
+			rinfo->panel_info.hAct_high = 1;
+			rinfo->panel_info.vAct_high = 1;
+			/* Mark panel infos valid */
+			rinfo->panel_info.valid = 1;
+
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Probe physical connection of a CRT. This code comes from XFree
+ * as well and currently is only implemented for the CRT DAC, the
+ * code for the TVDAC is commented out in XFree as "non working"
+ */
+static int __devinit radeon_crt_is_connected(struct radeonfb_info *rinfo, int is_crt_dac)
+{
+    int	          connected = 0;
+
+    /* the monitor either wasn't connected or it is a non-DDC CRT.
+     * try to probe it
+     */
+    if(is_crt_dac) {
+	unsigned long ulOrigVCLK_ECP_CNTL;
+	unsigned long ulOrigDAC_CNTL;
+	unsigned long ulOrigDAC_EXT_CNTL;
+	unsigned long ulOrigCRTC_EXT_CNTL;
+	unsigned long ulData;
+	unsigned long ulMask;
+
+	ulOrigVCLK_ECP_CNTL = INPLL(VCLK_ECP_CNTL);
+
+	ulData              = ulOrigVCLK_ECP_CNTL;
+	ulData             &= ~(PIXCLK_ALWAYS_ONb
+				| PIXCLK_DAC_ALWAYS_ONb);
+	ulMask              = ~(PIXCLK_ALWAYS_ONb
+				| PIXCLK_DAC_ALWAYS_ONb);
+	OUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);
+
+	ulOrigCRTC_EXT_CNTL = INREG(CRTC_EXT_CNTL);
+	ulData              = ulOrigCRTC_EXT_CNTL;
+	ulData             |= CRTC_CRT_ON;
+	OUTREG(CRTC_EXT_CNTL, ulData);
+   
+	ulOrigDAC_EXT_CNTL = INREG(DAC_EXT_CNTL);
+	ulData             = ulOrigDAC_EXT_CNTL;
+	ulData            &= ~DAC_FORCE_DATA_MASK;
+	ulData            |=  (DAC_FORCE_BLANK_OFF_EN
+			       |DAC_FORCE_DATA_EN
+			       |DAC_FORCE_DATA_SEL_MASK);
+	if ((rinfo->family == CHIP_FAMILY_RV250) ||
+	    (rinfo->family == CHIP_FAMILY_RV280))
+	    ulData |= (0x01b6 << DAC_FORCE_DATA_SHIFT);
+	else
+	    ulData |= (0x01ac << DAC_FORCE_DATA_SHIFT);
+
+	OUTREG(DAC_EXT_CNTL, ulData);
+
+	ulOrigDAC_CNTL     = INREG(DAC_CNTL);
+	ulData             = ulOrigDAC_CNTL;
+	ulData            |= DAC_CMP_EN;
+	ulData            &= ~(DAC_RANGE_CNTL_MASK
+			       | DAC_PDWN);
+	ulData            |= 0x2;
+	OUTREG(DAC_CNTL, ulData);
+
+	mdelay(1);
+
+	ulData     = INREG(DAC_CNTL);
+	connected =  (DAC_CMP_OUTPUT & ulData) ? 1 : 0;
+  
+	ulData    = ulOrigVCLK_ECP_CNTL;
+	ulMask    = 0xFFFFFFFFL;
+	OUTPLLP(VCLK_ECP_CNTL, ulData, ulMask);
+
+	OUTREG(DAC_CNTL,      ulOrigDAC_CNTL     );
+	OUTREG(DAC_EXT_CNTL,  ulOrigDAC_EXT_CNTL );
+	OUTREG(CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);
+    }
+
+    return connected ? MT_CRT : MT_NONE;
+}
+
+/*
+ * Parse the "monitor_layout" string if any. This code is mostly
+ * copied from XFree's radeon driver
+ */
+static int __devinit radeon_parse_monitor_layout(struct radeonfb_info *rinfo,
+						 const char *monitor_layout)
+{
+	char s1[5], s2[5];
+	int i = 0, second = 0;
+	const char *s;
+
+	if (!monitor_layout)
+		return 0;
+
+	s = monitor_layout;
+	do {
+		switch(*s) {
+		case ',':
+			s1[i] = '\0';
+			i = 0;
+			second = 1;
+			break;
+		case ' ':
+		case '\0':
+			break;
+		default:
+			if (i > 4)
+				break;
+			if (second)
+				s2[i] = *s;
+			else
+				s1[i] = *s;
+			i++;
+		}
+	} while (*s++);
+	if (second)
+		s2[i] = 0;
+	else {
+		s1[i] = 0;
+		s2[0] = 0;
+	}
+	if (strcmp(s1, "CRT") == 0)
+		rinfo->mon1_type = MT_CRT;
+	else if (strcmp(s1, "TMDS") == 0)
+		rinfo->mon1_type = MT_DFP;
+	else if (strcmp(s1, "LVDS") == 0)
+		rinfo->mon1_type = MT_LCD;
+
+	if (strcmp(s2, "CRT") == 0)
+		rinfo->mon2_type = MT_CRT;
+	else if (strcmp(s2, "TMDS") == 0)
+		rinfo->mon2_type = MT_DFP;
+	else if (strcmp(s2, "LVDS") == 0)
+		rinfo->mon2_type = MT_LCD;
+
+	return 1;
+}
+
+/*
+ * Probe display on both primary and secondary card's connector (if any)
+ * by various available techniques (i2c, OF device tree, BIOS, ...) and
+ * try to retreive EDID. The algorithm here comes from XFree's radeon
+ * driver
+ */
+void __devinit radeon_probe_screens(struct radeonfb_info *rinfo,
+				    const char *monitor_layout, int ignore_edid)
+{
+#ifdef CONFIG_FB_RADEON_I2C
+	int ddc_crt2_used = 0;
+#endif
+	int tmp, i;
+
+	if (radeon_parse_monitor_layout(rinfo, monitor_layout)) {
+
+		/*
+		 * If user specified a monitor_layout option, use it instead
+		 * of auto-detecting. Maybe we should only use this argument
+		 * on the first radeon card probed or provide a way to specify
+		 * a layout for each card ?
+		 */
+
+		RTRACE("Using specified monitor layout: %s", monitor_layout);
+#ifdef CONFIG_FB_RADEON_I2C
+		if (!ignore_edid) {
+			if (rinfo->mon1_type != MT_NONE)
+				if (!radeon_probe_i2c_connector(rinfo, ddc_dvi, &rinfo->mon1_EDID)) {
+					radeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon1_EDID);
+					ddc_crt2_used = 1;
+				}
+			if (rinfo->mon2_type != MT_NONE)
+				if (!radeon_probe_i2c_connector(rinfo, ddc_vga, &rinfo->mon2_EDID) &&
+				    !ddc_crt2_used)
+					radeon_probe_i2c_connector(rinfo, ddc_crt2, &rinfo->mon2_EDID);
+		}
+#endif /* CONFIG_FB_RADEON_I2C */
+		if (rinfo->mon1_type == MT_NONE) {
+			if (rinfo->mon2_type != MT_NONE) {
+				rinfo->mon1_type = rinfo->mon2_type;
+				rinfo->mon1_EDID = rinfo->mon2_EDID;
+			} else {
+				rinfo->mon1_type = MT_CRT;
+				printk(KERN_INFO "radeonfb: No valid monitor, assuming CRT on first port\n");
+			}
+			rinfo->mon2_type = MT_NONE;
+			rinfo->mon2_EDID = NULL;
+		}
+	} else {
+
+		/*
+		 * Auto-detecting display type (well... trying to ...)
+		 */
+		
+		RTRACE("Starting monitor auto detection...\n");
+
+		/*
+		 * Old single head cards
+		 */
+		if (!rinfo->has_CRTC2) {
+#ifdef CONFIG_PPC_OF
+			if (rinfo->mon1_type == MT_NONE)
+				rinfo->mon1_type = radeon_probe_OF_head(rinfo, 0,
+									&rinfo->mon1_EDID);
+#endif /* CONFIG_PPC_OF */
+#ifdef CONFIG_FB_RADEON_I2C
+			if (rinfo->mon1_type == MT_NONE)
+				rinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_dvi,
+								      &rinfo->mon1_EDID);
+			if (rinfo->mon1_type == MT_NONE)
+				rinfo->mon1_type =
+					radeon_probe_i2c_connector(rinfo, ddc_vga,
+								   &rinfo->mon1_EDID);
+			if (rinfo->mon1_type == MT_NONE)
+				rinfo->mon1_type =
+					radeon_probe_i2c_connector(rinfo, ddc_crt2,
+								   &rinfo->mon1_EDID);	
+#endif /* CONFIG_FB_RADEON_I2C */
+			if (rinfo->mon1_type == MT_NONE)
+				rinfo->mon1_type = MT_CRT;
+			goto bail;
+		}
+
+		/*
+		 * Check for cards with reversed DACs or TMDS controllers using BIOS
+		 */
+		if (rinfo->bios_seg &&
+		    (tmp = BIOS_IN16(rinfo->fp_bios_start + 0x50))) {
+			for (i = 1; i < 4; i++) {
+				unsigned int tmp0;
+
+				if (!BIOS_IN8(tmp + i*2) && i > 1)
+					break;
+				tmp0 = BIOS_IN16(tmp + i*2);
+				if ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0x0f) == ddc_dvi)) {
+					rinfo->reversed_DAC = 1;
+					printk(KERN_INFO "radeonfb: Reversed DACs detected\n");
+				}
+				if ((((tmp0 >> 8) & 0x0f) == ddc_dvi) && ((tmp0 >> 4) & 0x01)) {
+					rinfo->reversed_TMDS = 1;
+					printk(KERN_INFO "radeonfb: Reversed TMDS detected\n");
+				}
+			}
+		}
+
+		/*
+		 * Probe primary head (DVI or laptop internal panel)
+		 */
+#ifdef CONFIG_PPC_OF
+		if (rinfo->mon1_type == MT_NONE)
+			rinfo->mon1_type = radeon_probe_OF_head(rinfo, 0, &rinfo->mon1_EDID);
+#endif /* CONFIG_PPC_OF */
+#ifdef CONFIG_FB_RADEON_I2C
+		if (rinfo->mon1_type == MT_NONE)
+			rinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_dvi,
+								      &rinfo->mon1_EDID);
+		if (rinfo->mon1_type == MT_NONE) {
+			rinfo->mon1_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,
+								      &rinfo->mon1_EDID);
+			if (rinfo->mon1_type != MT_NONE)
+				ddc_crt2_used = 1;
+		}
+#endif /* CONFIG_FB_RADEON_I2C */
+		if (rinfo->mon1_type == MT_NONE && rinfo->is_mobility &&
+		    ((rinfo->bios_seg && (INREG(BIOS_4_SCRATCH) & 4))
+		     || (INREG(LVDS_GEN_CNTL) & LVDS_ON))) {
+			rinfo->mon1_type = MT_LCD;
+			printk("Non-DDC laptop panel detected\n");
+		}
+		if (rinfo->mon1_type == MT_NONE)
+			rinfo->mon1_type = radeon_crt_is_connected(rinfo, rinfo->reversed_DAC);
+
+		/*
+		 * Probe secondary head (mostly VGA, can be DVI)
+		 */
+#ifdef CONFIG_PPC_OF
+		if (rinfo->mon2_type == MT_NONE)
+			rinfo->mon2_type = radeon_probe_OF_head(rinfo, 1, &rinfo->mon2_EDID);
+#endif /* CONFIG_PPC_OF */
+#ifdef CONFIG_FB_RADEON_I2C
+		if (rinfo->mon2_type == MT_NONE)
+			rinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_vga,
+								      &rinfo->mon2_EDID);
+		if (rinfo->mon2_type == MT_NONE && !ddc_crt2_used)
+			rinfo->mon2_type = radeon_probe_i2c_connector(rinfo, ddc_crt2,
+								      &rinfo->mon2_EDID);
+#endif /* CONFIG_FB_RADEON_I2C */
+		if (rinfo->mon2_type == MT_NONE)
+			rinfo->mon2_type = radeon_crt_is_connected(rinfo, !rinfo->reversed_DAC);
+
+		/*
+		 * If we only detected port 2, we swap them, if none detected,
+		 * assume CRT (maybe fallback to old BIOS_SCRATCH stuff ? or look
+		 * at FP registers ?)
+		 */
+		if (rinfo->mon1_type == MT_NONE) {
+			if (rinfo->mon2_type != MT_NONE) {
+				rinfo->mon1_type = rinfo->mon2_type;
+				rinfo->mon1_EDID = rinfo->mon2_EDID;
+			} else
+				rinfo->mon1_type = MT_CRT;
+			rinfo->mon2_type = MT_NONE;
+			rinfo->mon2_EDID = NULL;
+		}
+
+		/*
+		 * Deal with reversed TMDS
+		 */
+		if (rinfo->reversed_TMDS) {
+			/* Always keep internal TMDS as primary head */
+			if (rinfo->mon1_type == MT_DFP || rinfo->mon2_type == MT_DFP) {
+				int tmp_type = rinfo->mon1_type;
+				u8 *tmp_EDID = rinfo->mon1_EDID;
+				rinfo->mon1_type = rinfo->mon2_type;
+				rinfo->mon1_EDID = rinfo->mon2_EDID;
+				rinfo->mon2_type = tmp_type;
+				rinfo->mon2_EDID = tmp_EDID;
+				if (rinfo->mon1_type == MT_CRT || rinfo->mon2_type == MT_CRT)
+					rinfo->reversed_DAC ^= 1;
+			}
+		}
+	}
+	if (ignore_edid) {
+		if (rinfo->mon1_EDID)
+			kfree(rinfo->mon1_EDID);
+		rinfo->mon1_EDID = NULL;
+		if (rinfo->mon2_EDID)
+			kfree(rinfo->mon2_EDID);
+		rinfo->mon2_EDID = NULL;
+	}
+
+ bail:
+	printk(KERN_INFO "radeonfb: Monitor 1 type %s found\n",
+	       radeon_get_mon_name(rinfo->mon1_type));
+	if (rinfo->mon1_EDID) {
+		printk(KERN_INFO "radeonfb: EDID probed\n");
+		show_edid(rinfo->mon1_EDID);
+	}
+	if (!rinfo->has_CRTC2)
+		return;
+	printk(KERN_INFO "radeonfb: Monitor 2 type %s found\n",
+	       radeon_get_mon_name(rinfo->mon2_type));
+	if (rinfo->mon2_EDID) {
+		printk(KERN_INFO "radeonfb: EDID probed\n");
+		show_edid(rinfo->mon2_EDID);
+	}
+}
+
+
+/*
+ * This functions applyes any arch/model/machine specific fixups
+ * to the panel info. It may eventually alter EDID block as
+ * well or whatever is specific to a given model and not probed
+ * properly by the default code
+ */
+static void radeon_fixup_panel_info(struct radeonfb_info *rinfo)
+{
+	/*
+	 * A few iBook laptop panels seem to need a fixed PLL setting
+	 *
+	 * We should probably do this differently based on the panel
+	 * type/model or eventually some other device-tree informations,
+	 * but these tweaks below work enough for now. --BenH
+	 */
+#ifdef CONFIG_PPC_OF
+	/* iBook2's */
+	if (machine_is_compatible("PowerBook4,3")) {
+		rinfo->panel_info.ref_divider = rinfo->pll.ref_div;;
+		rinfo->panel_info.post_divider = 0x6;
+		rinfo->panel_info.fbk_divider = 0xad;
+		rinfo->panel_info.use_bios_dividers = 1;
+	}
+	/* Aluminium PowerBook 17" */
+	if (machine_is_compatible("PowerBook5,3")) {
+		rinfo->panel_info.ref_divider = rinfo->pll.ref_div;;
+		rinfo->panel_info.post_divider = 0x4;
+		rinfo->panel_info.fbk_divider = 0x80;
+		rinfo->panel_info.use_bios_dividers = 1;
+	}
+	/* iBook G4 */
+	if (machine_is_compatible("PowerBook6,3")) {
+		rinfo->panel_info.ref_divider = rinfo->pll.ref_div;;
+		rinfo->panel_info.post_divider = 0x6;
+		rinfo->panel_info.fbk_divider = 0xad;
+		rinfo->panel_info.use_bios_dividers = 1;
+	}
+#endif /* CONFIG_PPC_OF */
+}
+
+
+/*
+ * Fill up panel infos from a mode definition, either returned by the EDID
+ * or from the default mode when we can't do any better
+ */
+static void radeon_var_to_panel_info(struct radeonfb_info *rinfo, struct fb_var_screeninfo *var)
+{
+	rinfo->panel_info.xres = var->xres;
+	rinfo->panel_info.yres = var->yres;
+	rinfo->panel_info.clock = 100000000 / var->pixclock;
+	rinfo->panel_info.hOver_plus = var->right_margin;
+	rinfo->panel_info.hSync_width = var->hsync_len;
+       	rinfo->panel_info.hblank = var->left_margin +
+		(var->right_margin + var->hsync_len);
+	rinfo->panel_info.vOver_plus = var->lower_margin;
+	rinfo->panel_info.vSync_width = var->vsync_len;
+       	rinfo->panel_info.vblank = var->upper_margin +
+		(var->lower_margin + var->vsync_len);
+	rinfo->panel_info.hAct_high =
+		(var->sync & FB_SYNC_HOR_HIGH_ACT) != 0;
+	rinfo->panel_info.vAct_high =
+		(var->sync & FB_SYNC_VERT_HIGH_ACT) != 0;
+	rinfo->panel_info.valid = 1;
+	/* We use a default of 200ms for the panel power delay, 
+	 * I need to have a real schedule() instead of mdelay's in the panel code.
+	 * we might be possible to figure out a better power delay either from
+	 * MacOS OF tree or from the EDID block (proprietary extensions ?)
+	 */
+	rinfo->panel_info.pwr_delay = 200;
+}
+
+static void radeon_var_to_videomode(struct fb_videomode *mode,
+				    const struct fb_var_screeninfo *var)
+{
+    mode->xres = var->xres;
+    mode->yres = var->yres;
+    mode->pixclock = var->pixclock;
+    mode->left_margin = var->left_margin;
+    mode->right_margin = var->right_margin;
+    mode->upper_margin = var->upper_margin;
+    mode->lower_margin = var->lower_margin;
+    mode->hsync_len = var->hsync_len;
+    mode->vsync_len = var->vsync_len;
+    mode->sync = var->sync;
+    mode->vmode = var->vmode;
+}
+
+static void radeon_videomode_to_var(struct fb_var_screeninfo *var,
+				    const struct fb_videomode *mode)
+{
+    var->xres = mode->xres;
+    var->yres = mode->yres;
+    var->xres_virtual = mode->xres;
+    var->yres_virtual = mode->yres;
+    var->xoffset = 0;
+    var->yoffset = 0;
+    var->pixclock = mode->pixclock;
+    var->left_margin = mode->left_margin;
+    var->right_margin = mode->right_margin;
+    var->upper_margin = mode->upper_margin;
+    var->lower_margin = mode->lower_margin;
+    var->hsync_len = mode->hsync_len;
+    var->vsync_len = mode->vsync_len;
+    var->sync = mode->sync;
+    var->vmode = mode->vmode;
+}
+
+/*
+ * Build the modedb for head 1 (head 2 will come later), check panel infos
+ * from either BIOS or EDID, and pick up the default mode
+ */
+void __devinit radeon_check_modes(struct radeonfb_info *rinfo, const char *mode_option)
+{
+	int has_default_mode = 0;
+
+	/*
+	 * Fill default var first
+	 */
+	rinfo->info.var = radeonfb_default_var;
+
+	/*
+	 * First check out what BIOS has to say
+	 */
+	if (rinfo->mon1_type == MT_LCD)
+		radeon_get_panel_info_BIOS(rinfo);
+
+	/*
+	 * Parse EDID detailed timings and deduce panel infos if any. Right now
+	 * we only deal with first entry returned by parse_EDID, we may do better
+	 * some day...
+	 */
+	if (!rinfo->panel_info.use_bios_dividers && rinfo->mon1_type != MT_CRT
+	    && rinfo->mon1_EDID) {
+		struct fb_var_screeninfo var;
+		RTRACE("Parsing EDID data for panel info\n");
+		if (parse_edid(rinfo->mon1_EDID, &var) == 0) {
+			if (var.xres >= rinfo->panel_info.xres &&
+			    var.yres >= rinfo->panel_info.yres)
+				radeon_var_to_panel_info(rinfo, &var);
+		}
+	}
+
+	/*
+	 * Do any additional platform/arch fixups to the panel infos
+	 */
+	radeon_fixup_panel_info(rinfo);
+
+	/*
+	 * If we have some valid panel infos, we setup the default mode based on
+	 * those
+	 */
+	if (rinfo->mon1_type != MT_CRT && rinfo->panel_info.valid) {
+		struct fb_var_screeninfo *var = &rinfo->info.var;
+
+		RTRACE("Setting up default mode based on panel info\n");
+		var->xres = rinfo->panel_info.xres;
+		var->yres = rinfo->panel_info.yres;
+		var->xres_virtual = rinfo->panel_info.xres;
+		var->yres_virtual = rinfo->panel_info.yres;
+		var->xoffset = var->yoffset = 0;
+		var->bits_per_pixel = 8;
+		var->pixclock = 100000000 / rinfo->panel_info.clock;
+		var->left_margin = (rinfo->panel_info.hblank - rinfo->panel_info.hOver_plus
+				    - rinfo->panel_info.hSync_width);
+		var->right_margin = rinfo->panel_info.hOver_plus;
+		var->upper_margin = (rinfo->panel_info.vblank - rinfo->panel_info.vOver_plus
+				     - rinfo->panel_info.vSync_width);
+		var->lower_margin = rinfo->panel_info.vOver_plus;
+		var->hsync_len = rinfo->panel_info.hSync_width;
+		var->vsync_len = rinfo->panel_info.vSync_width;
+		var->sync = 0;
+		if (rinfo->panel_info.hAct_high)
+			var->sync |= FB_SYNC_HOR_HIGH_ACT;
+		if (rinfo->panel_info.vAct_high)
+			var->sync |= FB_SYNC_VERT_HIGH_ACT;
+		var->vmode = 0;
+		has_default_mode = 1;
+	}
+
+	/*
+	 * Now build modedb from EDID
+	 */
+	if (rinfo->mon1_EDID) {
+		rinfo->mon1_modedb = fb_create_modedb(rinfo->mon1_EDID,
+						      &rinfo->mon1_dbsize);
+		fb_get_monitor_limits(rinfo->mon1_EDID, &rinfo->info.monspecs);
+	}
+
+	
+	/*
+	 * Finally, if we don't have panel infos we need to figure some (or
+	 * we try to read it from card), we try to pick a default mode
+	 * and create some panel infos. Whatever...
+	 */
+	if (rinfo->mon1_type != MT_CRT && !rinfo->panel_info.valid) {
+		struct fb_videomode	*modedb;
+		int			dbsize;
+		char			modename[32];
+
+		RTRACE("Guessing panel info...\n");
+		if (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {
+			u32 tmp = INREG(FP_HORZ_STRETCH) & HORZ_PANEL_SIZE;
+			rinfo->panel_info.xres = ((tmp >> HORZ_PANEL_SHIFT) + 1) * 8;
+			tmp = INREG(FP_VERT_STRETCH) & VERT_PANEL_SIZE;
+			rinfo->panel_info.yres = (tmp >> VERT_PANEL_SHIFT) + 1;
+		}
+		if (rinfo->panel_info.xres == 0 || rinfo->panel_info.yres == 0) {
+			printk(KERN_WARNING "radeonfb: Can't find panel size, going back to CRT\n");
+			rinfo->mon1_type = MT_CRT;
+			goto pickup_default;
+		}
+		printk(KERN_WARNING "radeonfb: Asssuming panel size %dx%d\n",
+		       rinfo->panel_info.xres, rinfo->panel_info.yres);
+		modedb = rinfo->mon1_modedb;
+		dbsize = rinfo->mon1_dbsize;
+		snprintf(modename, 31, "%dx%d", rinfo->panel_info.xres, rinfo->panel_info.yres);
+		if (fb_find_mode(&rinfo->info.var, &rinfo->info, modename,
+				 modedb, dbsize, NULL, 8) == 0) {
+			printk(KERN_WARNING "radeonfb: Can't find mode for panel size, going back to CRT\n");
+			rinfo->mon1_type = MT_CRT;
+			goto pickup_default;
+		}
+		has_default_mode = 1;
+		radeon_var_to_panel_info(rinfo, &rinfo->info.var);
+	}
+
+ pickup_default:
+	/*
+	 * Pick up a random default mode
+	 */
+	if (!has_default_mode || mode_option) {
+		struct fb_videomode default_mode;
+		if (has_default_mode)
+			radeon_var_to_videomode(&default_mode, &rinfo->info.var);
+		else
+			radeon_var_to_videomode(&default_mode, &radeonfb_default_var);
+		if (fb_find_mode(&rinfo->info.var, &rinfo->info, mode_option,
+				 rinfo->mon1_modedb, rinfo->mon1_dbsize, &default_mode, 8) == 0)
+			rinfo->info.var = radeonfb_default_var;
+	}
+
+}
+
+/*
+ * The code below is used to pick up a mode in check_var and
+ * set_var. It should be made generic
+ */
+
+/*
+ * This is used when looking for modes. We assign a "goodness" value
+ * to a mode in the modedb depending how "close" it is from what we
+ * are looking for.
+ * Currently, we don't compare that much, we could do better but
+ * the current fbcon doesn't quite mind ;)
+ */
+static int radeon_compare_modes(const struct fb_var_screeninfo *var,
+				const struct fb_videomode *mode)
+{
+	int goodness = 0;
+
+	if (var->yres == mode->yres)
+		goodness += 10;
+	if (var->xres == mode->xres)
+		goodness += 9;
+	return goodness;
+}
+
+/*
+ * This function is called by check_var, it gets the passed in mode parameter, and
+ * outputs a valid mode matching the passed-in one as closely as possible.
+ * We need something better ultimately. Things like fbcon basically pass us out
+ * current mode with xres/yres hacked, while things like XFree will actually
+ * produce a full timing that we should respect as much as possible.
+ *
+ * This is why I added the FB_ACTIVATE_FIND that is used by fbcon. Without this,
+ * we do a simple spec match, that's all. With it, we actually look for a mode in
+ * either our monitor modedb or the vesa one if none
+ *
+ */
+int  radeon_match_mode(struct radeonfb_info *rinfo,
+		       struct fb_var_screeninfo *dest,
+		       const struct fb_var_screeninfo *src)
+{
+	const struct fb_videomode	*db = vesa_modes;
+	int				i, dbsize = 34;
+	int				has_rmx, native_db = 0;
+	int				goodness = 0;
+	const struct fb_videomode	*candidate = NULL;
+
+	/* Start with a copy of the requested mode */
+	memcpy(dest, src, sizeof(struct fb_var_screeninfo));
+
+	/* Check if we have a modedb built from EDID */
+	if (rinfo->mon1_modedb) {
+		db = rinfo->mon1_modedb;
+		dbsize = rinfo->mon1_dbsize;
+		native_db = 1;
+	}
+
+	/* Check if we have a scaler allowing any fancy mode */
+	has_rmx = rinfo->mon1_type == MT_LCD || rinfo->mon1_type == MT_DFP;
+
+	/* If we have a scaler and are passed FB_ACTIVATE_TEST or
+	 * FB_ACTIVATE_NOW, just do basic checking and return if the
+	 * mode match
+	 */
+	if ((src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST ||
+	    (src->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
+		/* We don't have an RMX, validate timings. If we don't have
+	 	 * monspecs, we should be paranoid and not let use go above
+		 * 640x480-60, but I assume userland knows what it's doing here
+		 * (though I may be proven wrong...)
+		 */
+		if (has_rmx == 0 && rinfo->mon1_modedb)
+			if (fb_validate_mode(src, &rinfo->info))
+				return -EINVAL;
+		return 0;
+	}
+
+	/* Now look for a mode in the database */
+	while (db) {
+		for (i = 0; i < dbsize; i++) {
+			int g;
+
+			if (db[i].yres < src->yres)
+				continue;	
+			if (db[i].xres < src->xres)
+				continue;
+			g = radeon_compare_modes(src, &db[i]);
+			/* If the new mode is at least as good as the previous one,
+			 * then it's our new candidate
+			 */
+			if (g >= goodness) {
+				candidate = &db[i];
+				goodness = g;
+			}
+		}
+		db = NULL;
+		/* If we have a scaler, we allow any mode from the database */
+		if (native_db && has_rmx) {
+			db = vesa_modes;
+			dbsize = 34;
+			native_db = 0;
+		}
+	}
+
+	/* If we have found a match, return it */
+	if (candidate != NULL) {
+		radeon_videomode_to_var(dest, candidate);
+		return 0;
+	}
+
+	/* If we haven't and don't have a scaler, fail */
+	if (!has_rmx)
+		return -EINVAL;
+
+	return 0;
+}
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeon_pm.c linuxppc-2.5-benh/drivers/video/aty/radeon_pm.c
--- /dev/shm/linux-2.5/drivers/video/aty/radeon_pm.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeon_pm.c	2004-01-21 06:00:06.000000000 +0000
@@ -0,0 +1,939 @@
+#include "radeonfb.h"
+
+#include <linux/console.h>
+#include <linux/agp_backend.h>
+
+/*
+ * Currently, only PowerMac do D2 state
+ */
+#define CONFIG_RADEON_HAS_D2	CONFIG_PPC_PMAC
+
+#ifdef CONFIG_RADEON_HAS_D2
+/*
+ * On PowerMac, we assume any mobility chip based machine does D2
+ */
+#ifdef CONFIG_PPC_PMAC
+static inline int radeon_suspend_to_d2(struct radeonfb_info *rinfo, u32 state)
+{
+	return rinfo->is_mobility;
+}
+#else
+static inline int radeon_suspend_to_d2(struct radeonfb_info *rinfo, u32 state)
+{
+	return 0;
+}
+#endif
+
+#endif /* CONFIG_RADEON_HAS_D2 */
+
+/*
+ * Radeon M6, M7 and M9 Power Management code. This code currently
+ * only supports the mobile chips in D2 mode, that is typically what
+ * is used on Apple laptops, it's based from some informations provided
+ * by ATI along with hours of tracing of MacOS drivers.
+ * 
+ * New version of this code almost totally rewritten by ATI, many thanks
+ * for their support.
+ */
+
+void radeon_pm_disable_dynamic_mode(struct radeonfb_info *rinfo)
+{
+
+	u32 sclk_cntl;
+	u32 mclk_cntl;
+	u32 sclk_more_cntl;
+	
+	u32 vclk_ecp_cntl;
+	u32 pixclks_cntl;
+
+	/* Mobility chips only, untested on M9+/M10/11 */
+	if (!rinfo->is_mobility)
+		return;
+	if (rinfo->family > CHIP_FAMILY_RV250)
+		return;
+	
+	/* Force Core Clocks */
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);
+	sclk_cntl |= 	SCLK_CNTL_M6__FORCE_CP|
+			SCLK_CNTL_M6__FORCE_HDP|
+			SCLK_CNTL_M6__FORCE_DISP1|
+			SCLK_CNTL_M6__FORCE_DISP2|
+			SCLK_CNTL_M6__FORCE_TOP|
+			SCLK_CNTL_M6__FORCE_E2|
+			SCLK_CNTL_M6__FORCE_SE|
+			SCLK_CNTL_M6__FORCE_IDCT|
+			SCLK_CNTL_M6__FORCE_VIP|
+			SCLK_CNTL_M6__FORCE_RE|
+			SCLK_CNTL_M6__FORCE_PB|
+			SCLK_CNTL_M6__FORCE_TAM|
+			SCLK_CNTL_M6__FORCE_TDM|
+			SCLK_CNTL_M6__FORCE_RB|
+			SCLK_CNTL_M6__FORCE_TV_SCLK|
+			SCLK_CNTL_M6__FORCE_SUBPIC|
+			SCLK_CNTL_M6__FORCE_OV0;
+    	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+	
+	
+	
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl |= 	SCLK_MORE_CNTL__FORCE_DISPREGS|
+				SCLK_MORE_CNTL__FORCE_MC_GUI|
+				SCLK_MORE_CNTL__FORCE_MC_HOST;	
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);
+	
+	/* Force Display clocks	*/
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	vclk_ecp_cntl &= ~(	VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb |
+			 	VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb);
+
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+	
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	pixclks_cntl &= ~(	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb |
+			 	PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb |
+				PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb);
+						
+ 	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+
+	/* Force Memory Clocks */
+	mclk_cntl = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl &= ~(	MCLK_CNTL_M6__FORCE_MCLKA |  
+			MCLK_CNTL_M6__FORCE_MCLKB |
+			MCLK_CNTL_M6__FORCE_YCLKA |
+			MCLK_CNTL_M6__FORCE_YCLKB );
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+}
+
+void radeon_pm_enable_dynamic_mode(struct radeonfb_info *rinfo)
+{
+	u32 clk_pwrmgt_cntl;
+	u32 sclk_cntl;
+	u32 sclk_more_cntl;
+	u32 clk_pin_cntl;
+	u32 pixclks_cntl;
+	u32 vclk_ecp_cntl;
+	u32 mclk_cntl;
+	u32 mclk_misc;
+
+	/* Mobility chips only, untested on M9+/M10/11 */
+	if (!rinfo->is_mobility)
+		return;
+	if (rinfo->family > CHIP_FAMILY_RV250)
+		return;
+	
+	/* Set Latencies */
+	clk_pwrmgt_cntl = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	
+	clk_pwrmgt_cntl &= ~(	 CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE_MASK|
+				 CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK|
+				 CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT_MASK|
+				 CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE_MASK);
+	/* Mode 1 */
+	clk_pwrmgt_cntl = 	CLK_PWRMGT_CNTL_M6__MC_CH_MODE|
+				CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE | 
+				(1<<CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT__SHIFT) |
+				(0<<CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT__SHIFT)|
+				(0<<CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE__SHIFT);
+
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);
+						
+
+	clk_pin_cntl = INPLL( pllCLK_PIN_CNTL);
+	clk_pin_cntl |= CLK_PIN_CNTL__SCLK_DYN_START_CNTL;
+	 
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
+
+	/* Enable Dyanmic mode for SCLK */
+
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);	
+	sclk_cntl &= SCLK_CNTL_M6__SCLK_SRC_SEL_MASK;
+	sclk_cntl |= SCLK_CNTL_M6__FORCE_VIP;		
+
+	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+
+
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl &= ~(SCLK_MORE_CNTL__FORCE_DISPREGS);
+				                    
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);
+
+	
+	/* Enable Dynamic mode for PIXCLK & PIX2CLK */
+
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	
+	pixclks_cntl|=  PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb | 
+			PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+			PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb;
+
+	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+		
+		
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	
+	vclk_ecp_cntl|=  VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb | 
+			 VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb;
+
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+
+
+	/* Enable Dynamic mode for MCLK	*/
+
+	mclk_cntl  = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl |= 	MCLK_CNTL_M6__FORCE_MCLKA|  
+			MCLK_CNTL_M6__FORCE_MCLKB|	
+			MCLK_CNTL_M6__FORCE_YCLKA|
+			MCLK_CNTL_M6__FORCE_YCLKB;
+			
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+
+	mclk_misc = INPLL(pllMCLK_MISC);
+	mclk_misc |= 	MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT|
+			MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT|
+			MCLK_MISC__MC_MCLK_DYN_ENABLE|
+			MCLK_MISC__IO_MCLK_DYN_ENABLE;	
+	
+	OUTPLL(pllMCLK_MISC, mclk_misc);
+}
+
+#ifdef CONFIG_PM
+
+static void OUTMC( struct radeonfb_info *rinfo, u8 indx, u32 value)
+{
+	OUTREG( MC_IND_INDEX, indx | MC_IND_INDEX__MC_IND_WR_EN);	
+	OUTREG( MC_IND_DATA, value);		
+}
+
+static u32 INMC(struct radeonfb_info *rinfo, u8 indx)
+{
+	OUTREG( MC_IND_INDEX, indx);					
+	return INREG( MC_IND_DATA);
+}
+
+static void radeon_pm_save_regs(struct radeonfb_info *rinfo)
+{
+	rinfo->save_regs[0] = INPLL(PLL_PWRMGT_CNTL);
+	rinfo->save_regs[1] = INPLL(CLK_PWRMGT_CNTL);
+	rinfo->save_regs[2] = INPLL(MCLK_CNTL);
+	rinfo->save_regs[3] = INPLL(SCLK_CNTL);
+	rinfo->save_regs[4] = INPLL(CLK_PIN_CNTL);
+	rinfo->save_regs[5] = INPLL(VCLK_ECP_CNTL);
+	rinfo->save_regs[6] = INPLL(PIXCLKS_CNTL);
+	rinfo->save_regs[7] = INPLL(MCLK_MISC);
+	rinfo->save_regs[8] = INPLL(P2PLL_CNTL);
+	
+	rinfo->save_regs[9] = INREG(DISP_MISC_CNTL);
+	rinfo->save_regs[10] = INREG(DISP_PWR_MAN);
+	rinfo->save_regs[11] = INREG(LVDS_GEN_CNTL);
+	rinfo->save_regs[12] = INREG(LVDS_PLL_CNTL);
+	rinfo->save_regs[13] = INREG(TV_DAC_CNTL);
+	rinfo->save_regs[14] = INREG(BUS_CNTL1);
+	rinfo->save_regs[15] = INREG(CRTC_OFFSET_CNTL);
+	rinfo->save_regs[16] = INREG(AGP_CNTL);
+	rinfo->save_regs[17] = (INREG(CRTC_GEN_CNTL) & 0xfdffffff) | 0x04000000;
+	rinfo->save_regs[18] = (INREG(CRTC2_GEN_CNTL) & 0xfdffffff) | 0x04000000;
+	rinfo->save_regs[19] = INREG(GPIOPAD_A);
+	rinfo->save_regs[20] = INREG(GPIOPAD_EN);
+	rinfo->save_regs[21] = INREG(GPIOPAD_MASK);
+	rinfo->save_regs[22] = INREG(ZV_LCDPAD_A);
+	rinfo->save_regs[23] = INREG(ZV_LCDPAD_EN);
+	rinfo->save_regs[24] = INREG(ZV_LCDPAD_MASK);
+	rinfo->save_regs[25] = INREG(GPIO_VGA_DDC);
+	rinfo->save_regs[26] = INREG(GPIO_DVI_DDC);
+	rinfo->save_regs[27] = INREG(GPIO_MONID);
+	rinfo->save_regs[28] = INREG(GPIO_CRT2_DDC);
+
+	rinfo->save_regs[29] = INREG(SURFACE_CNTL);
+	rinfo->save_regs[30] = INREG(MC_FB_LOCATION);
+	rinfo->save_regs[31] = INREG(DISPLAY_BASE_ADDR);
+	rinfo->save_regs[32] = INREG(MC_AGP_LOCATION);
+	rinfo->save_regs[33] = INREG(CRTC2_DISPLAY_BASE_ADDR);
+}
+
+static void radeon_pm_restore_regs(struct radeonfb_info *rinfo)
+{
+	OUTPLL(P2PLL_CNTL, rinfo->save_regs[8] & 0xFFFFFFFE); /* First */
+	
+	OUTPLL(PLL_PWRMGT_CNTL, rinfo->save_regs[0]);
+	OUTPLL(CLK_PWRMGT_CNTL, rinfo->save_regs[1]);
+	OUTPLL(MCLK_CNTL, rinfo->save_regs[2]);
+	OUTPLL(SCLK_CNTL, rinfo->save_regs[3]);
+	OUTPLL(CLK_PIN_CNTL, rinfo->save_regs[4]);
+	OUTPLL(VCLK_ECP_CNTL, rinfo->save_regs[5]);
+	OUTPLL(PIXCLKS_CNTL, rinfo->save_regs[6]);
+	OUTPLL(MCLK_MISC, rinfo->save_regs[7]);
+	
+	OUTREG(SURFACE_CNTL, rinfo->save_regs[29]);
+	OUTREG(MC_FB_LOCATION, rinfo->save_regs[30]);
+	OUTREG(DISPLAY_BASE_ADDR, rinfo->save_regs[31]);
+	OUTREG(MC_AGP_LOCATION, rinfo->save_regs[32]);
+	OUTREG(CRTC2_DISPLAY_BASE_ADDR, rinfo->save_regs[33]);
+
+	OUTREG(DISP_MISC_CNTL, rinfo->save_regs[9]);
+	OUTREG(DISP_PWR_MAN, rinfo->save_regs[10]);
+	OUTREG(LVDS_GEN_CNTL, rinfo->save_regs[11]);
+	OUTREG(LVDS_PLL_CNTL,rinfo->save_regs[12]);
+	OUTREG(TV_DAC_CNTL, rinfo->save_regs[13]);
+	OUTREG(BUS_CNTL1, rinfo->save_regs[14]);
+	OUTREG(CRTC_OFFSET_CNTL, rinfo->save_regs[15]);
+	OUTREG(AGP_CNTL, rinfo->save_regs[16]);
+	OUTREG(CRTC_GEN_CNTL, rinfo->save_regs[17]);
+	OUTREG(CRTC2_GEN_CNTL, rinfo->save_regs[18]);
+
+	// wait VBL before that one  ?
+	OUTPLL(P2PLL_CNTL, rinfo->save_regs[8]);
+	
+	OUTREG(GPIOPAD_A, rinfo->save_regs[19]);
+	OUTREG(GPIOPAD_EN, rinfo->save_regs[20]);
+	OUTREG(GPIOPAD_MASK, rinfo->save_regs[21]);
+	OUTREG(ZV_LCDPAD_A, rinfo->save_regs[22]);
+	OUTREG(ZV_LCDPAD_EN, rinfo->save_regs[23]);
+	OUTREG(ZV_LCDPAD_MASK, rinfo->save_regs[24]);
+	OUTREG(GPIO_VGA_DDC, rinfo->save_regs[25]);
+	OUTREG(GPIO_DVI_DDC, rinfo->save_regs[26]);
+	OUTREG(GPIO_MONID, rinfo->save_regs[27]);
+	OUTREG(GPIO_CRT2_DDC, rinfo->save_regs[28]);
+}
+
+static void radeon_pm_disable_iopad(struct radeonfb_info *rinfo)
+{		
+	OUTREG(GPIOPAD_MASK, 0x0001ffff);
+	OUTREG(GPIOPAD_EN, 0x00000400);
+	OUTREG(GPIOPAD_A, 0x00000000);		
+        OUTREG(ZV_LCDPAD_MASK, 0x00000000);
+        OUTREG(ZV_LCDPAD_EN, 0x00000000);
+      	OUTREG(ZV_LCDPAD_A, 0x00000000); 	
+	OUTREG(GPIO_VGA_DDC, 0x00030000);
+	OUTREG(GPIO_DVI_DDC, 0x00000000);
+	OUTREG(GPIO_MONID, 0x00030000);
+	OUTREG(GPIO_CRT2_DDC, 0x00000000);
+}
+
+static void radeon_pm_program_v2clk(struct radeonfb_info *rinfo)
+{
+	/* Set v2clk to 65MHz */
+  	OUTPLL(pllPIXCLKS_CNTL,
+  		INPLL(pllPIXCLKS_CNTL) & ~PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK);
+	 
+  	OUTPLL(pllP2PLL_REF_DIV, 0x0000000c);
+	OUTPLL(pllP2PLL_CNTL, 0x0000bf00);
+	OUTPLL(pllP2PLL_DIV_0, 0x00020074 | P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W);
+	
+	OUTPLL(pllP2PLL_CNTL, INPLL(pllP2PLL_CNTL) & ~P2PLL_CNTL__P2PLL_SLEEP);
+	mdelay(1);
+
+	OUTPLL(pllP2PLL_CNTL, INPLL(pllP2PLL_CNTL) & ~P2PLL_CNTL__P2PLL_RESET); 	
+	mdelay( 1);
+
+  	OUTPLL(pllPIXCLKS_CNTL,
+  		(INPLL(pllPIXCLKS_CNTL) & ~PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK)
+  		| (0x03 << PIXCLKS_CNTL__PIX2CLK_SRC_SEL__SHIFT));
+	mdelay( 1);	
+}
+
+static void radeon_pm_low_current(struct radeonfb_info *rinfo)
+{
+	u32 reg;
+
+	reg  = INREG(BUS_CNTL1);
+	reg &= ~BUS_CNTL1_MOBILE_PLATFORM_SEL_MASK;
+	reg |= BUS_CNTL1_AGPCLK_VALID | (1<<BUS_CNTL1_MOBILE_PLATFORM_SEL_SHIFT);
+	OUTREG(BUS_CNTL1, reg);
+	
+	reg  = INPLL(PLL_PWRMGT_CNTL);
+	reg |= PLL_PWRMGT_CNTL_SPLL_TURNOFF | PLL_PWRMGT_CNTL_PPLL_TURNOFF |
+		PLL_PWRMGT_CNTL_P2PLL_TURNOFF | PLL_PWRMGT_CNTL_TVPLL_TURNOFF;
+	reg &= ~PLL_PWRMGT_CNTL_SU_MCLK_USE_BCLK;
+	reg &= ~PLL_PWRMGT_CNTL_MOBILE_SU;
+	OUTPLL(PLL_PWRMGT_CNTL, reg);
+	
+	reg  = INREG(TV_DAC_CNTL);
+	reg &= ~(TV_DAC_CNTL_BGADJ_MASK |TV_DAC_CNTL_DACADJ_MASK);
+	reg |=TV_DAC_CNTL_BGSLEEP | TV_DAC_CNTL_RDACPD | TV_DAC_CNTL_GDACPD |
+		TV_DAC_CNTL_BDACPD |
+		(8<<TV_DAC_CNTL_BGADJ__SHIFT) | (8<<TV_DAC_CNTL_DACADJ__SHIFT);
+	OUTREG(TV_DAC_CNTL, reg);
+	
+	reg  = INREG(TMDS_TRANSMITTER_CNTL);
+	reg &= ~(TMDS_PLL_EN | TMDS_PLLRST);
+	OUTREG(TMDS_TRANSMITTER_CNTL, reg);
+
+	reg = INREG(DAC_CNTL);
+	reg &= ~DAC_CMP_EN;
+	OUTREG(DAC_CNTL, reg);
+
+	reg = INREG(DAC_CNTL2);
+	reg &= ~DAC2_CMP_EN;
+	OUTREG(DAC_CNTL2, reg);
+	
+	reg  = INREG(TV_DAC_CNTL);
+	reg &= ~TV_DAC_CNTL_DETECT;
+	OUTREG(TV_DAC_CNTL, reg);
+}
+
+static void radeon_pm_setup_for_suspend(struct radeonfb_info *rinfo)
+{
+
+	u32 sclk_cntl, mclk_cntl, sclk_more_cntl;
+
+	u32 pll_pwrmgt_cntl;
+	u32 clk_pwrmgt_cntl;
+	u32 clk_pin_cntl;
+	u32 vclk_ecp_cntl; 
+	u32 pixclks_cntl;
+	u32 disp_mis_cntl;
+	u32 disp_pwr_man;
+
+	
+	/* Force Core Clocks */
+	sclk_cntl = INPLL( pllSCLK_CNTL_M6);
+	sclk_cntl |= 	SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT|
+			SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT|
+			
+			SCLK_CNTL_M6__FORCE_DISP2|
+			SCLK_CNTL_M6__FORCE_CP|
+			SCLK_CNTL_M6__FORCE_HDP|
+			SCLK_CNTL_M6__FORCE_DISP1|
+			SCLK_CNTL_M6__FORCE_TOP|
+			SCLK_CNTL_M6__FORCE_E2|
+			SCLK_CNTL_M6__FORCE_SE|
+			SCLK_CNTL_M6__FORCE_IDCT|
+			SCLK_CNTL_M6__FORCE_VIP|
+			
+			SCLK_CNTL_M6__FORCE_RE|
+			SCLK_CNTL_M6__FORCE_PB|
+			SCLK_CNTL_M6__FORCE_TAM|
+			SCLK_CNTL_M6__FORCE_TDM|
+			SCLK_CNTL_M6__FORCE_RB|
+			SCLK_CNTL_M6__FORCE_TV_SCLK|
+			SCLK_CNTL_M6__FORCE_SUBPIC|
+			SCLK_CNTL_M6__FORCE_OV0;
+
+	OUTPLL( pllSCLK_CNTL_M6, sclk_cntl);
+
+	sclk_more_cntl = INPLL(pllSCLK_MORE_CNTL);
+	sclk_more_cntl |= 	SCLK_MORE_CNTL__FORCE_DISPREGS |
+				SCLK_MORE_CNTL__FORCE_MC_GUI |
+				SCLK_MORE_CNTL__FORCE_MC_HOST;
+
+	OUTPLL(pllSCLK_MORE_CNTL, sclk_more_cntl);		
+
+	
+	mclk_cntl = INPLL( pllMCLK_CNTL_M6);
+	mclk_cntl &= ~(	MCLK_CNTL_M6__FORCE_MCLKA |  
+			MCLK_CNTL_M6__FORCE_MCLKB |
+			MCLK_CNTL_M6__FORCE_YCLKA | 
+			MCLK_CNTL_M6__FORCE_YCLKB | 
+			MCLK_CNTL_M6__FORCE_MC
+		      );	
+    	OUTPLL( pllMCLK_CNTL_M6, mclk_cntl);
+	
+	/* Force Display clocks	*/
+	vclk_ecp_cntl = INPLL( pllVCLK_ECP_CNTL);
+	vclk_ecp_cntl &= ~(VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb |VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb);
+	vclk_ecp_cntl |= VCLK_ECP_CNTL__ECP_FORCE_ON;
+	OUTPLL( pllVCLK_ECP_CNTL, vclk_ecp_cntl);
+	
+	
+	pixclks_cntl = INPLL( pllPIXCLKS_CNTL);
+	pixclks_cntl &= ~(	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb | 
+				PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb |
+				PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb|
+				PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb);
+						
+ 	OUTPLL( pllPIXCLKS_CNTL, pixclks_cntl);
+
+
+
+	/* Enable System power management */
+	pll_pwrmgt_cntl = INPLL( pllPLL_PWRMGT_CNTL);
+	
+	pll_pwrmgt_cntl |= 	PLL_PWRMGT_CNTL__SPLL_TURNOFF |
+				PLL_PWRMGT_CNTL__MPLL_TURNOFF|
+				PLL_PWRMGT_CNTL__PPLL_TURNOFF|
+				PLL_PWRMGT_CNTL__P2PLL_TURNOFF|
+				PLL_PWRMGT_CNTL__TVPLL_TURNOFF;
+						
+	OUTPLL( pllPLL_PWRMGT_CNTL, pll_pwrmgt_cntl);
+	
+	clk_pwrmgt_cntl	 = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	
+	clk_pwrmgt_cntl &= ~(	CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF|
+				CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF|
+				CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN|
+				CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE|
+				CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK|
+				CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG_MASK			
+			);
+						
+	clk_pwrmgt_cntl |= CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN | CLK_PWRMGT_CNTL_M6__DISP_PM;
+	
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);	
+	
+	clk_pin_cntl = INPLL( pllCLK_PIN_CNTL);
+	
+	clk_pin_cntl &= ~CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND;
+	OUTPLL( pllMCLK_MISC, INPLL( pllMCLK_MISC) | MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND);	
+	
+	/* AGP PLL control */
+	OUTREG(BUS_CNTL1, INREG(BUS_CNTL1) |  BUS_CNTL1__AGPCLK_VALID);
+
+	OUTREG(BUS_CNTL1,
+		(INREG(BUS_CNTL1) & ~BUS_CNTL1__MOBILE_PLATFORM_SEL_MASK)
+		| (2<<BUS_CNTL1__MOBILE_PLATFORM_SEL__SHIFT));	// 440BX
+	OUTREG(CRTC_OFFSET_CNTL, (INREG(CRTC_OFFSET_CNTL) & ~CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN));
+	
+	clk_pin_cntl &= ~CLK_PIN_CNTL__CG_CLK_TO_OUTPIN;
+	clk_pin_cntl |= CLK_PIN_CNTL__XTALIN_ALWAYS_ONb;	
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
+
+	/* Solano2M */
+	OUTREG(AGP_CNTL,
+		(INREG(AGP_CNTL) & ~(AGP_CNTL__MAX_IDLE_CLK_MASK))
+		| (0x20<<AGP_CNTL__MAX_IDLE_CLK__SHIFT));
+
+	/* ACPI mode */
+	OUTPLL( pllPLL_PWRMGT_CNTL, INPLL( pllPLL_PWRMGT_CNTL) & ~PLL_PWRMGT_CNTL__PM_MODE_SEL);					
+
+
+	disp_mis_cntl = INREG(DISP_MISC_CNTL);
+	
+	disp_mis_cntl &= ~(	DISP_MISC_CNTL__SOFT_RESET_GRPH_PP | 
+				DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP | 
+				DISP_MISC_CNTL__SOFT_RESET_OV0_PP |
+				DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP|
+				DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK|
+				DISP_MISC_CNTL__SOFT_RESET_LVDS|
+				DISP_MISC_CNTL__SOFT_RESET_TMDS|
+				DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS|
+				DISP_MISC_CNTL__SOFT_RESET_TV);
+	
+	OUTREG(DISP_MISC_CNTL, disp_mis_cntl);					
+						
+	disp_pwr_man = INREG(DISP_PWR_MAN);
+	
+	disp_pwr_man &= ~(	DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN	| 
+						DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN |
+						DISP_PWR_MAN__DISP_PWR_MAN_DPMS_MASK|		
+						DISP_PWR_MAN__DISP_D3_RST|
+						DISP_PWR_MAN__DISP_D3_REG_RST
+					);
+	
+	disp_pwr_man |= DISP_PWR_MAN__DISP_D3_GRPH_RST|
+					DISP_PWR_MAN__DISP_D3_SUBPIC_RST|
+					DISP_PWR_MAN__DISP_D3_OV0_RST|
+					DISP_PWR_MAN__DISP_D1D2_GRPH_RST|
+					DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST|
+					DISP_PWR_MAN__DISP_D1D2_OV0_RST|
+					DISP_PWR_MAN__DIG_TMDS_ENABLE_RST|
+					DISP_PWR_MAN__TV_ENABLE_RST| 
+//					DISP_PWR_MAN__AUTO_PWRUP_EN|
+					0;
+	
+	OUTREG(DISP_PWR_MAN, disp_pwr_man);					
+							
+	clk_pwrmgt_cntl = INPLL( pllCLK_PWRMGT_CNTL_M6);
+	pll_pwrmgt_cntl = INPLL( pllPLL_PWRMGT_CNTL) ;
+	clk_pin_cntl 	= INPLL( pllCLK_PIN_CNTL);
+	disp_pwr_man	= INREG(DISP_PWR_MAN);
+		
+	
+	/* D2 */
+	clk_pwrmgt_cntl |= CLK_PWRMGT_CNTL_M6__DISP_PM;
+	pll_pwrmgt_cntl |= PLL_PWRMGT_CNTL__MOBILE_SU | PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK;
+	clk_pin_cntl	|= CLK_PIN_CNTL__XTALIN_ALWAYS_ONb;
+	disp_pwr_man 	&= ~(DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN_MASK | DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN_MASK);							
+						
+
+	OUTPLL( pllCLK_PWRMGT_CNTL_M6, clk_pwrmgt_cntl);
+	OUTPLL( pllPLL_PWRMGT_CNTL, pll_pwrmgt_cntl);
+	OUTPLL( pllCLK_PIN_CNTL, clk_pin_cntl);
+	OUTREG(DISP_PWR_MAN, disp_pwr_man);
+
+	/* disable display request & disable display */
+	OUTREG( CRTC_GEN_CNTL, (INREG( CRTC_GEN_CNTL) & ~CRTC_GEN_CNTL__CRTC_EN) | CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B);
+	OUTREG( CRTC2_GEN_CNTL, (INREG( CRTC2_GEN_CNTL) & ~CRTC2_GEN_CNTL__CRTC2_EN) | CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B);
+
+	mdelay(17);				   
+
+}
+
+static void radeon_pm_yclk_mclk_sync(struct radeonfb_info *rinfo)
+{
+	u32 mc_chp_io_cntl_a1, mc_chp_io_cntl_b1;
+
+	mc_chp_io_cntl_a1 = INMC( rinfo, ixMC_CHP_IO_CNTL_A1) & ~MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA_MASK;
+	mc_chp_io_cntl_b1 = INMC( rinfo, ixMC_CHP_IO_CNTL_B1) & ~MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB_MASK;
+
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_A1, mc_chp_io_cntl_a1 | (1<<MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT));
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_B1, mc_chp_io_cntl_b1 | (1<<MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT));
+
+	/* Wassup ? This doesn't seem to be defined, let's hope we are ok this way --BenH */
+#ifdef MCLK_YCLK_SYNC_ENABLE
+	mc_chp_io_cntl_a1 |= (2<<MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT);
+	mc_chp_io_cntl_b1 |= (2<<MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT);
+#endif
+
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_A1, mc_chp_io_cntl_a1);
+	OUTMC( rinfo, ixMC_CHP_IO_CNTL_B1, mc_chp_io_cntl_b1);
+
+	mdelay( 1);
+}
+
+static void radeon_pm_program_mode_reg(struct radeonfb_info *rinfo, u16 value, u8 delay_required)
+{  
+	u32 mem_sdram_mode;
+
+	mem_sdram_mode  = INREG( MEM_SDRAM_MODE_REG);
+
+	mem_sdram_mode &= ~MEM_SDRAM_MODE_REG__MEM_MODE_REG_MASK;
+	mem_sdram_mode |= (value<<MEM_SDRAM_MODE_REG__MEM_MODE_REG__SHIFT) | MEM_SDRAM_MODE_REG__MEM_CFG_TYPE;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	mem_sdram_mode |=  MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	mem_sdram_mode &= ~MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET;
+	OUTREG( MEM_SDRAM_MODE_REG, mem_sdram_mode);
+
+	if (delay_required == 1)
+		while( (INREG( MC_STATUS) & (MC_STATUS__MEM_PWRUP_COMPL_A | MC_STATUS__MEM_PWRUP_COMPL_B) ) == 0 )
+			{ }; 	
+}
+
+
+static void radeon_pm_enable_dll(struct radeonfb_info *rinfo)
+{  
+#define DLL_RESET_DELAY 	5
+#define DLL_SLEEP_DELAY		1
+
+	u32 DLL_CKO_Value = INPLL(pllMDLL_CKO)   | MDLL_CKO__MCKOA_SLEEP |  MDLL_CKO__MCKOA_RESET;
+	u32 DLL_CKA_Value = INPLL(pllMDLL_RDCKA) | MDLL_RDCKA__MRDCKA0_SLEEP | MDLL_RDCKA__MRDCKA1_SLEEP | MDLL_RDCKA__MRDCKA0_RESET | MDLL_RDCKA__MRDCKA1_RESET;
+	u32 DLL_CKB_Value = INPLL(pllMDLL_RDCKB) | MDLL_RDCKB__MRDCKB0_SLEEP | MDLL_RDCKB__MRDCKB1_SLEEP | MDLL_RDCKB__MRDCKB0_RESET | MDLL_RDCKB__MRDCKB1_RESET;
+
+	/* Setting up the DLL range for write */
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	OUTPLL(pllMDLL_RDCKA,  	DLL_CKA_Value);
+	OUTPLL(pllMDLL_RDCKB,	DLL_CKB_Value);
+
+	mdelay( DLL_RESET_DELAY);
+
+	/* Channel A */
+
+	/* Power Up */
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOA_SLEEP );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+   
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOA_RESET );
+	OUTPLL(pllMDLL_CKO,	DLL_CKO_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA0_SLEEP );
+	OUTPLL(pllMDLL_RDCKA,  	DLL_CKA_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA0_RESET );
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA1_SLEEP);
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKA_Value &= ~(MDLL_RDCKA__MRDCKA1_RESET);
+	OUTPLL(pllMDLL_RDCKA,	DLL_CKA_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+
+	/* Channel B */
+
+	/* Power Up */
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOB_SLEEP );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+   
+	DLL_CKO_Value &= ~(MDLL_CKO__MCKOB_RESET );
+	OUTPLL(pllMDLL_CKO,   	DLL_CKO_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB0_SLEEP);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB0_RESET);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+	/* Power Up */
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB1_SLEEP);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_SLEEP_DELAY);  		
+
+	DLL_CKB_Value &= ~(MDLL_RDCKB__MRDCKB1_RESET);
+	OUTPLL(pllMDLL_RDCKB,   DLL_CKB_Value);
+	mdelay( DLL_RESET_DELAY);  		
+
+#undef DLL_RESET_DELAY 
+#undef DLL_SLEEP_DELAY
+}
+
+static void radeon_pm_full_reset_sdram(struct radeonfb_info *rinfo)
+{
+	u32 crtcGenCntl, crtcGenCntl2, memRefreshCntl, crtc_more_cntl, fp_gen_cntl, fp2_gen_cntl;
+ 
+	crtcGenCntl  = INREG( CRTC_GEN_CNTL);
+	crtcGenCntl2 = INREG( CRTC2_GEN_CNTL);
+
+	memRefreshCntl 	= INREG( MEM_REFRESH_CNTL);
+	crtc_more_cntl 	= INREG( CRTC_MORE_CNTL);
+	fp_gen_cntl 	= INREG( FP_GEN_CNTL);
+	fp2_gen_cntl 	= INREG( FP2_GEN_CNTL);
+ 
+
+	OUTREG( CRTC_MORE_CNTL, 	0);
+	OUTREG( FP_GEN_CNTL, 	0);
+	OUTREG( FP2_GEN_CNTL, 	0);
+ 
+	OUTREG( CRTC_GEN_CNTL,  (crtcGenCntl | CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B) );
+	OUTREG( CRTC2_GEN_CNTL, (crtcGenCntl2 | CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B) );
+  
+	/* Disable refresh */
+	OUTREG( MEM_REFRESH_CNTL, memRefreshCntl | MEM_REFRESH_CNTL__MEM_REFRESH_DIS);
+ 
+	/* Reset memory */
+	OUTREG( MEM_SDRAM_MODE_REG,
+		INREG( MEM_SDRAM_MODE_REG) & ~MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE); // Init  Not Complete
+
+	/* DLL */
+	radeon_pm_enable_dll(rinfo);
+
+	// MLCK /YCLK sync 
+	radeon_pm_yclk_mclk_sync(rinfo);
+
+       	/* M6, M7 and M9 so far ... */
+	if (rinfo->is_mobility && rinfo->family <= CHIP_FAMILY_RV250) {
+		radeon_pm_program_mode_reg(rinfo, 0x2000, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x2001, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x2002, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x0132, 1);   
+		radeon_pm_program_mode_reg(rinfo, 0x0032, 1); 
+	}	
+
+	OUTREG( MEM_SDRAM_MODE_REG,
+		INREG( MEM_SDRAM_MODE_REG) |  MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE); // Init Complete
+
+	OUTREG( MEM_REFRESH_CNTL, 	memRefreshCntl);
+
+	OUTREG( CRTC_GEN_CNTL, 		crtcGenCntl);
+	OUTREG( CRTC2_GEN_CNTL, 	crtcGenCntl2);
+	OUTREG( FP_GEN_CNTL, 		fp_gen_cntl);
+	OUTREG( FP2_GEN_CNTL, 		fp2_gen_cntl);
+
+	OUTREG( CRTC_MORE_CNTL, 	crtc_more_cntl);
+
+	mdelay( 15);
+}
+
+static void radeon_set_suspend(struct radeonfb_info *rinfo, int suspend)
+{
+	u16 pwr_cmd;
+
+	if (!rinfo->pm_reg)
+		return;
+
+	/* Set the chip into appropriate suspend mode (we use D2,
+	 * D3 would require a compete re-initialization of the chip,
+	 * including PCI config registers, clocks, AGP conf, ...)
+	 */
+	if (suspend) {
+		printk(KERN_DEBUG "radeonfb: switching to D2 state...\n");
+
+		/* Disable dynamic power management of clocks for the
+		 * duration of the suspend/resume process
+		 */
+		radeon_pm_disable_dynamic_mode(rinfo);
+		/* Save some registers */
+		radeon_pm_save_regs(rinfo);
+
+		/* Prepare mobility chips for suspend. Only do that on <= RV250 chips that
+		 * have been tested
+		 */
+		if (rinfo->is_mobility && rinfo->family <= CHIP_FAMILY_RV250) {
+			/* Program V2CLK */
+			radeon_pm_program_v2clk(rinfo);
+		
+			/* Disable IO PADs */
+			radeon_pm_disable_iopad(rinfo);
+
+			/* Set low current */
+			radeon_pm_low_current(rinfo);
+
+			/* Prepare chip for power management */
+			radeon_pm_setup_for_suspend(rinfo);
+
+			/* Reset the MDLL */
+			OUTPLL( pllMDLL_CKO, INPLL( pllMDLL_CKO) | MDLL_CKO__MCKOA_RESET | MDLL_CKO__MCKOB_RESET);
+		}
+
+		/* Switch PCI power managment to D2. */
+		for (;;) {
+			pci_read_config_word(
+				rinfo->pdev, rinfo->pm_reg+PCI_PM_CTRL,
+				&pwr_cmd);
+			if (pwr_cmd & 2)
+				break;			
+			pci_write_config_word(
+				rinfo->pdev, rinfo->pm_reg+PCI_PM_CTRL,
+				(pwr_cmd & ~PCI_PM_CTRL_STATE_MASK) | 2);
+			mdelay(500);
+		}
+	} else {
+		printk(KERN_DEBUG "radeonfb: switching to D0 state...\n");
+
+		/* Switch back PCI powermanagment to D0 */
+		mdelay(200);
+		pci_write_config_word(rinfo->pdev, rinfo->pm_reg+PCI_PM_CTRL, 0);
+		mdelay(500);
+
+		/* Reset the SDRAM controller  */
+       		radeon_pm_full_reset_sdram(rinfo);
+		
+		/* Restore some registers */
+		radeon_pm_restore_regs(rinfo);
+		radeon_pm_enable_dynamic_mode(rinfo);
+	}
+}
+
+int radeonfb_pci_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct radeonfb_info *rinfo = pci_get_drvdata(pdev);
+
+	/* We don't do anything but D2, for now we return 0, but
+	 * we may want to change that. How do we know if the BIOS
+	 * can properly take care of D3 ? Also, with swsusp, we
+	 * know we'll be rebooted, ...
+	 */
+
+	printk(KERN_DEBUG "radeonfb: suspending to state: %d...\n", state);
+	
+	acquire_console_sem();
+
+	/* Userland should do this but doesn't... bridge gets suspended
+	 * too late. Unfortunately, that works only when AGP is built-in,
+	 * not for a module.
+	 */
+#ifdef CONFIG_AGP
+	agp_enable(0);
+#endif
+
+	fb_set_suspend(&rinfo->info, 1);
+
+	/* Setup dummy fb raster ops */
+	rinfo->info.fbops->fb_fillrect 	= fb_dummy_fillrect;
+	rinfo->info.fbops->fb_copyarea 	= fb_dummy_copyarea;
+	rinfo->info.fbops->fb_imageblit	= fb_dummy_imageblit;
+	rinfo->info.fbops->fb_cursor   	= fb_dummy_cursor;
+
+	if (!radeon_accel_disabled()) {
+		/* Make sure engine is reset */
+		radeon_engine_idle();
+		radeon_engine_reset(rinfo);
+		radeon_engine_idle();
+	}
+
+	/* Blank display and LCD */
+	radeonfb_blank(VESA_POWERDOWN+1, (struct fb_info *)rinfo);
+
+	/* Sleep */
+	rinfo->asleep = 1;
+	rinfo->lock_blank = 1;
+
+	/* Suspend the chip to D2 state when supported
+	 */
+#ifdef CONFIG_RADEON_HAS_D2
+	if (radeon_suspend_to_d2(rinfo, state))
+		radeon_set_suspend(rinfo, 1);
+#endif /* CONFIG_RADEON_HAS_D2 */
+
+	release_console_sem();
+
+	pdev->dev.power_state = state;
+
+	return 0;
+}
+
+int radeonfb_pci_resume(struct pci_dev *pdev)
+{
+	struct radeonfb_info *rinfo = pci_get_drvdata(pdev);
+
+	if (pdev->dev.power_state == 0)
+		return 0;
+
+	acquire_console_sem();
+
+	/* Wakeup chip */
+#ifdef CONFIG_RADEON_HAS_D2
+	if (radeon_suspend_to_d2(rinfo, 0))
+		radeon_set_suspend(rinfo, 0);
+#endif /* CONFIG_RADEON_HAS_D2 */
+
+	rinfo->asleep = 0;
+
+	/* Restore display & engine */
+	radeonfb_set_par(&rinfo->info);
+	fb_pan_display(&rinfo->info, &rinfo->info.var);
+	fb_set_cmap(&rinfo->info.cmap, 1, &rinfo->info);
+
+	/* Restore fb raster ops */
+	rinfo->info.fbops->fb_fillrect	= cfb_fillrect;
+	rinfo->info.fbops->fb_copyarea	= cfb_copyarea;
+	rinfo->info.fbops->fb_imageblit = cfb_imageblit;
+	rinfo->info.fbops->fb_cursor   	= soft_cursor;
+
+	/* Refresh */
+	fb_set_suspend(&rinfo->info, 0);
+
+	/* Unblank */
+	rinfo->lock_blank = 0;
+	radeonfb_blank(0, (struct fb_info *)rinfo);
+
+	release_console_sem();
+
+	pdev->dev.power_state = 0;
+
+	printk(KERN_DEBUG "radeonfb: resumed !\n");
+
+	return 0;
+}
+
+#endif /* CONFIG_PM */
diff -purN /dev/shm/linux-2.5/drivers/video/aty/radeonfb.h linuxppc-2.5-benh/drivers/video/aty/radeonfb.h
--- /dev/shm/linux-2.5/drivers/video/aty/radeonfb.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/aty/radeonfb.h	2004-01-30 00:13:26.000000000 +0000
@@ -0,0 +1,566 @@
+#ifndef __RADEONFB_H__
+#define __RADEONFB_H__
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/fb.h>
+
+
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/i2c-algo-bit.h>
+
+#include <asm/io.h>
+
+#include <video/radeon.h>
+
+/***************************************************************
+ * Most of the definitions here are adapted right from XFree86 *
+ ***************************************************************/
+
+
+/*
+ * Chip families. Must fit in the low 16 bits of a long word
+ */
+enum radeon_family {
+	CHIP_FAMILY_UNKNOW,
+	CHIP_FAMILY_LEGACY,
+	CHIP_FAMILY_RADEON,
+	CHIP_FAMILY_RV100,
+	CHIP_FAMILY_RS100,    /* U1 (IGP320M) or A3 (IGP320)*/
+	CHIP_FAMILY_RV200,
+	CHIP_FAMILY_RS200,    /* U2 (IGP330M/340M/350M) or A4 (IGP330/340/345/350), RS250 (IGP 7000) */
+	CHIP_FAMILY_R200,
+	CHIP_FAMILY_RV250,
+	CHIP_FAMILY_RS300,    /* Radeon 9000 IGP */
+	CHIP_FAMILY_RV280,
+	CHIP_FAMILY_R300,
+	CHIP_FAMILY_R350,
+	CHIP_FAMILY_RV350,
+	CHIP_FAMILY_LAST,
+};
+
+/*
+ * Chip flags
+ */
+enum radeon_chip_flags {
+	CHIP_FAMILY_MASK	= 0x0000ffffUL,
+	CHIP_FLAGS_MASK		= 0xffff0000UL,
+	CHIP_IS_MOBILITY	= 0x00010000UL,
+	CHIP_IS_IGP		= 0x00020000UL,
+	CHIP_HAS_CRTC2		= 0x00040000UL,	
+};
+
+
+/*
+ * Monitor types
+ */
+enum radeon_montype {
+	MT_NONE = 0,
+	MT_CRT,		/* CRT */
+	MT_LCD,		/* LCD */
+	MT_DFP,		/* DVI */
+	MT_CTV,		/* composite TV */
+	MT_STV		/* S-Video out */
+};
+
+/*
+ * DDC i2c ports
+ */
+enum ddc_type {
+	ddc_none,
+	ddc_monid,
+	ddc_dvi,
+	ddc_vga,
+	ddc_crt2,
+};
+
+/*
+ * Connector types
+ */
+enum conn_type {
+	conn_none,
+	conn_proprietary,
+	conn_crt,
+	conn_DVI_I,
+	conn_DVI_D,
+};
+
+
+/*
+ * PLL infos
+ */
+struct pll_info {
+	int ppll_max;
+	int ppll_min;
+	int sclk, mclk;
+	int ref_div;
+	int ref_clk;
+};
+
+/*
+ * VRAM infos
+ */
+struct ram_info {
+	int ml;
+	int mb;
+	int trcd;
+	int trp;
+	int twr;
+	int cl;
+	int tr2w;
+	int loop_latency;
+	int rloop;
+};
+
+
+/*
+ * This structure contains the various registers manipulated by this
+ * driver for setting or restoring a mode. It's mostly copied from
+ * XFree's RADEONSaveRec structure. A few chip settings might still be
+ * tweaked without beeing reflected or saved in these registers though
+ */
+struct radeon_regs {
+	/* Common registers */
+	u32		ovr_clr;
+	u32		ovr_wid_left_right;
+	u32		ovr_wid_top_bottom;
+	u32		ov0_scale_cntl;
+	u32		mpp_tb_config;
+	u32		mpp_gp_config;
+	u32		subpic_cntl;
+	u32		viph_control;
+	u32		i2c_cntl_1;
+	u32		gen_int_cntl;
+	u32		cap0_trig_cntl;
+	u32		cap1_trig_cntl;
+	u32		bus_cntl;
+	u32		surface_cntl;
+	u32		bios_5_scratch;
+
+	/* Other registers to save for VT switches or driver load/unload */
+	u32		dp_datatype;
+	u32		rbbm_soft_reset;
+	u32		clock_cntl_index;
+	u32		amcgpio_en_reg;
+	u32		amcgpio_mask;
+
+	/* Surface/tiling registers */
+	u32		surf_lower_bound[8];
+	u32		surf_upper_bound[8];
+	u32		surf_info[8];
+
+	/* CRTC registers */
+	u32		crtc_gen_cntl;
+	u32		crtc_ext_cntl;
+	u32		dac_cntl;
+	u32		crtc_h_total_disp;
+	u32		crtc_h_sync_strt_wid;
+	u32		crtc_v_total_disp;
+	u32		crtc_v_sync_strt_wid;
+	u32		crtc_offset;
+	u32		crtc_offset_cntl;
+	u32		crtc_pitch;
+	u32		disp_merge_cntl;
+	u32		grph_buffer_cntl;
+	u32		crtc_more_cntl;
+
+	/* CRTC2 registers */
+	u32		crtc2_gen_cntl;
+	u32		dac2_cntl;
+	u32		disp_output_cntl;
+	u32		disp_hw_debug;
+	u32		disp2_merge_cntl;
+	u32		grph2_buffer_cntl;
+	u32		crtc2_h_total_disp;
+	u32		crtc2_h_sync_strt_wid;
+	u32		crtc2_v_total_disp;
+	u32		crtc2_v_sync_strt_wid;
+	u32		crtc2_offset;
+	u32		crtc2_offset_cntl;
+	u32		crtc2_pitch;
+
+	/* Flat panel regs */
+	u32 		fp_crtc_h_total_disp;
+	u32		fp_crtc_v_total_disp;
+	u32		fp_gen_cntl;
+	u32		fp2_gen_cntl;
+	u32		fp_h_sync_strt_wid;
+	u32		fp2_h_sync_strt_wid;
+	u32		fp_horz_stretch;
+	u32		fp_panel_cntl;
+	u32		fp_v_sync_strt_wid;
+	u32		fp2_v_sync_strt_wid;
+	u32		fp_vert_stretch;
+	u32		lvds_gen_cntl;
+	u32		lvds_pll_cntl;
+	u32		tmds_crc;
+	u32		tmds_transmitter_cntl;
+
+	/* Computed values for PLL */
+	u32		dot_clock_freq;
+	int		feedback_div;
+	int		post_div;	
+
+	/* PLL registers */
+	u32		ppll_div_3;
+	u32		ppll_ref_div;
+	u32		vclk_ecp_cntl;
+
+	/* Computed values for PLL2 */
+	u32		dot_clock_freq_2;
+	int		feedback_div_2;
+	int		post_div_2;
+
+	/* PLL2 registers */
+	u32		p2pll_ref_div;
+	u32		p2pll_div_0;
+	u32		htotal_cntl2;
+
+       	/* Palette */
+	int		palette_valid;
+	u32		palette[256];
+	u32		palette2[256];
+};
+
+struct panel_info {
+	int xres, yres;
+	int valid;
+	int clock;
+	int hOver_plus, hSync_width, hblank;
+	int vOver_plus, vSync_width, vblank;
+	int hAct_high, vAct_high, interlaced;
+	int pwr_delay;
+	int use_bios_dividers;
+	int ref_divider;
+	int post_divider;
+	int fbk_divider;
+};
+
+struct radeonfb_info;
+
+#ifdef CONFIG_FB_RADEON_I2C
+struct radeon_i2c_chan {
+	struct radeonfb_info		*rinfo;
+	u32		 		ddc_reg;
+	struct i2c_adapter		adapter;
+	struct i2c_algo_bit_data	algo;
+};
+#endif
+
+struct radeonfb_info {
+	struct fb_info 		info;
+
+	struct radeon_regs 	state;
+	struct radeon_regs	init_state;
+
+	char			name[DEVICE_NAME_SIZE];
+	char			ram_type[12];
+
+	unsigned long		mmio_base_phys;
+	unsigned long		fb_base_phys;
+
+	unsigned long		mmio_base;
+	unsigned long		fb_base;
+
+	unsigned long 		fb_local_base;
+
+	struct pci_dev		*pdev;
+
+	u8			*bios_seg;
+	int			fp_bios_start;
+
+	u32			pseudo_palette[17];
+	struct { u8 red, green, blue, pad; }
+				palette[256];
+
+	int			chipset;
+	u8			family;
+	u8			rev;
+	unsigned long		video_ram;
+
+	int			pitch, bpp, depth;
+
+	int			has_CRTC2 : 1;
+	int			is_mobility : 1;
+	int			is_IGP : 1;
+	int			R300_cg_workaround : 1;
+	int			reversed_DAC : 1;
+	int			reversed_TMDS : 1;
+	struct panel_info	panel_info;
+	int			mon1_type;
+	u8			*mon1_EDID;
+	struct fb_videomode	*mon1_modedb;
+	int			mon1_dbsize;
+	int			mon2_type;
+	u8		        *mon2_EDID;
+
+	u32			dp_gui_master_cntl;
+
+	struct pll_info		pll;
+
+	struct ram_info		ram;
+
+	int			mtrr_hdl;
+
+	int			pm_reg;
+	u32			save_regs[64];
+	int			asleep;
+	int			lock_blank;
+
+	/* Lock on register access */
+	spinlock_t		reg_lock;
+
+	/* Timer used for delayed LVDS operations */
+	struct timer_list	lvds_timer;
+	u32			pending_lvds_gen_cntl;
+	u32			pending_pixclks_cntl;
+
+#ifdef CONFIG_FB_RADEON_I2C
+	struct radeon_i2c_chan 	i2c[4];
+#endif
+};
+
+
+#define PRIMARY_MONITOR(rinfo)	(rinfo->mon1_type)
+
+
+/*
+ * Debugging stuffs
+ */
+#define DEBUG		1
+
+#if DEBUG
+#define RTRACE		printk
+#else
+#define RTRACE		if(0) printk
+#endif
+
+
+/*
+ * IO macros
+ */
+
+#define INREG8(addr)		readb((rinfo->mmio_base)+addr)
+#define OUTREG8(addr,val)	writeb(val, (rinfo->mmio_base)+addr)
+#define INREG(addr)		readl((rinfo->mmio_base)+addr)
+#define OUTREG(addr,val)	writel(val, (rinfo->mmio_base)+addr)
+
+static inline void R300_cg_workardound(struct radeonfb_info *rinfo)
+{
+	u32 save, tmp;
+	save = INREG(CLOCK_CNTL_INDEX);
+	tmp = save & ~(0x3f | PLL_WR_EN);
+	OUTREG(CLOCK_CNTL_INDEX, tmp);
+	tmp = INREG(CLOCK_CNTL_DATA);
+	OUTREG(CLOCK_CNTL_INDEX, save);
+}
+
+#define __OUTPLL(addr,val)	\
+	do {	\
+		OUTREG8(CLOCK_CNTL_INDEX, (addr & 0x0000003f) | 0x00000080); \
+		OUTREG(CLOCK_CNTL_DATA, val); \
+} while(0)
+
+
+static inline u32 __INPLL(struct radeonfb_info *rinfo, u32 addr)
+{
+	u32 data;
+	OUTREG8(CLOCK_CNTL_INDEX, addr & 0x0000003f);
+	data = (INREG(CLOCK_CNTL_DATA));
+	if (rinfo->R300_cg_workaround)
+		R300_cg_workardound(rinfo);
+	return data;
+}
+
+static inline u32 _INPLL(struct radeonfb_info *rinfo, u32 addr)
+{
+       	unsigned long flags;
+	u32 data;
+
+	spin_lock_irqsave(&rinfo->reg_lock, flags);
+	data = __INPLL(rinfo, addr);
+	spin_unlock_irqrestore(&rinfo->reg_lock, flags);
+	return data;
+}
+
+#define INPLL(addr)		_INPLL(rinfo, addr)
+
+#define OUTPLL(addr,val)	\
+	do {	\
+		unsigned long flags;\
+		spin_lock_irqsave(&rinfo->reg_lock, flags); \
+		__OUTPLL(addr, val); \
+		spin_unlock_irqrestore(&rinfo->reg_lock, flags); \
+	} while(0)
+
+#define OUTPLLP(addr,val,mask)  					\
+	do {								\
+		unsigned long flags;                                    \
+		unsigned int _tmp;					\
+		spin_lock_irqsave(&rinfo->reg_lock, flags); 		\
+		_tmp  = __INPLL(rinfo,addr);				\
+		_tmp &= (mask);						\
+		_tmp |= (val);						\
+		__OUTPLL(addr, _tmp);					\
+		spin_unlock_irqrestore(&rinfo->reg_lock, flags); 	\
+	} while (0)
+
+#define OUTREGP(addr,val,mask)  					\
+	do {								\
+		unsigned long flags;                                    \
+		unsigned int _tmp;					\
+		spin_lock_irqsave(&rinfo->reg_lock, flags); 		\
+		_tmp = INREG(addr);				       	\
+		_tmp &= (mask);						\
+		_tmp |= (val);						\
+		OUTREG(addr, _tmp);					\
+		spin_unlock_irqrestore(&rinfo->reg_lock, flags); 	\
+	} while (0)
+
+#define MS_TO_HZ(ms)       ((ms * HZ + 999) / 1000)
+
+#define BIOS_IN8(v)  	(readb(rinfo->bios_seg + (v)))
+#define BIOS_IN16(v) 	(readb(rinfo->bios_seg + (v)) | \
+			  (readb(rinfo->bios_seg + (v) + 1) << 8))
+#define BIOS_IN32(v) 	(readb(rinfo->bios_seg + (v)) | \
+			  (readb(rinfo->bios_seg + (v) + 1) << 8) | \
+			  (readb(rinfo->bios_seg + (v) + 2) << 16) | \
+			  (readb(rinfo->bios_seg + (v) + 3) << 24))
+
+/*
+ * Inline utilities
+ */
+
+static inline void wait_ms(unsigned long ms)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((ms * HZ + 999) / 1000);
+}
+
+
+
+static inline int round_div(int num, int den)
+{
+        return (num + (den / 2)) / den;
+}
+
+static inline int var_to_depth(const struct fb_var_screeninfo *var)
+{
+	if (var->bits_per_pixel != 16)
+		return var->bits_per_pixel;
+	return (var->green.length == 5) ? 15 : 16;
+}
+
+static inline u32 radeon_get_dstbpp(u16 depth)
+{
+	switch (depth) {
+       	case 8:
+       		return DST_8BPP;
+       	case 15:
+       		return DST_15BPP;
+       	case 16:
+       		return DST_16BPP;
+       	case 32:
+       		return DST_32BPP;
+       	default:
+       		return 0;
+	}
+}
+
+/*
+ * 2D Engine helper routines
+ */
+static inline void radeon_engine_flush (struct radeonfb_info *rinfo)
+{
+	int i;
+
+	/* initiate flush */
+	OUTREGP(RB2D_DSTCACHE_CTLSTAT, RB2D_DC_FLUSH_ALL,
+	        ~RB2D_DC_FLUSH_ALL);
+
+	for (i=0; i < 2000000; i++) {
+		if (!(INREG(RB2D_DSTCACHE_CTLSTAT) & RB2D_DC_BUSY))
+			return;
+		udelay(1);
+	}
+	printk(KERN_ERR "radeonfb: Flush Timeout !\n");
+}
+
+
+static inline void _radeon_fifo_wait (struct radeonfb_info *rinfo, int entries)
+{
+	int i;
+
+	for (i=0; i<2000000; i++) {
+		if ((INREG(RBBM_STATUS) & 0x7f) >= entries)
+			return;
+		udelay(1);
+	}
+	printk(KERN_ERR "radeonfb: FIFO Timeout !\n");
+}
+
+
+static inline void _radeon_engine_idle (struct radeonfb_info *rinfo)
+{
+	int i;
+
+	/* ensure FIFO is empty before waiting for idle */
+	_radeon_fifo_wait (rinfo, 64);
+
+	for (i=0; i<2000000; i++) {
+		if (((INREG(RBBM_STATUS) & GUI_ACTIVE)) == 0) {
+			radeon_engine_flush (rinfo);
+			return;
+		}
+		udelay(1);
+	}
+	printk(KERN_ERR "radeonfb: Idle Timeout !\n");
+}
+
+static inline int radeon_accel_disabled(void)
+{
+	extern int radeonfb_noaccel;
+	return radeonfb_noaccel;
+}
+
+#define radeon_engine_idle()		_radeon_engine_idle(rinfo)
+#define radeon_fifo_wait(entries)	_radeon_fifo_wait(rinfo,entries)
+
+
+/* I2C Functions */
+extern void radeon_create_i2c_busses(struct radeonfb_info *rinfo);
+extern void radeon_delete_i2c_busses(struct radeonfb_info *rinfo);
+extern int radeon_probe_i2c_connector(struct radeonfb_info *rinfo, int conn, u8 **out_edid);
+
+/* PM Functions */
+extern void radeon_pm_disable_dynamic_mode(struct radeonfb_info *rinfo);
+extern void radeon_pm_enable_dynamic_mode(struct radeonfb_info *rinfo);
+extern int radeonfb_pci_suspend(struct pci_dev *pdev, u32 state);
+extern int radeonfb_pci_resume(struct pci_dev *pdev);
+
+/* Monitor probe functions */
+extern void radeon_probe_screens(struct radeonfb_info *rinfo,
+				 const char *monitor_layout, int ignore_edid);
+extern void radeon_check_modes(struct radeonfb_info *rinfo, const char *mode_option);
+extern int radeon_match_mode(struct radeonfb_info *rinfo,
+			     struct fb_var_screeninfo *dest,
+			     const struct fb_var_screeninfo *src);
+
+/* Accel functions */
+extern void radeonfb_fillrect(struct fb_info *info, const struct fb_fillrect *region);
+extern void radeonfb_copyarea(struct fb_info *info, const struct fb_copyarea *area);
+extern void radeonfb_imageblit(struct fb_info *p, const struct fb_image *image);
+extern int radeonfb_sync(struct fb_info *info);
+extern void radeon_engine_init (struct radeonfb_info *rinfo);
+extern void radeon_engine_reset(struct radeonfb_info *rinfo);
+
+/* Other functions */
+extern int radeonfb_blank(int blank, struct fb_info *info);
+extern int radeonfb_set_par(struct fb_info *info);
+
+#endif /* __RADEONFB_H__ */
diff -purN /dev/shm/linux-2.5/drivers/video/console/fbcon.c linuxppc-2.5-benh/drivers/video/console/fbcon.c
--- /dev/shm/linux-2.5/drivers/video/console/fbcon.c	2004-02-04 05:29:30.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/console/fbcon.c	2004-02-05 10:07:35.000000000 +0000
@@ -115,6 +115,7 @@ static int softback_lines;
 static int first_fb_vc;
 static int last_fb_vc = MAX_NR_CONSOLES - 1;
 static int fbcon_is_default = 1; 
+static int console_resizing;
 
 #define REFCOUNT(fd)	(((int *)(fd))[-1])
 #define FNTSIZE(fd)	(((int *)(fd))[-2])
@@ -1613,14 +1614,21 @@ static int fbcon_resize(struct vc_data *
 	y_diff = info->var.yres - var.yres;
 	if (x_diff < 0 || x_diff > fw ||
 	   (y_diff < 0 || y_diff > fh)) {
-		var.activate = FB_ACTIVATE_TEST;
+		var.activate = FB_ACTIVATE_FIND;
 		err = fb_set_var(info, &var);
 		if (err || width > var.xres/fw ||
 		    height > var.yres/fh)
 			return -EINVAL;
-		DPRINTK("resize now %ix%i\n", var.xres, var.yres);
+       		DPRINTK("resize now %ix%i\n", var.xres, var.yres);
 		var.activate = FB_ACTIVATE_NOW;
+		/* This flag is enough for now as we are supposed to hold
+		 * the console semaphore at this point. I agree it's a bit
+		 * ugly but it does the job until some better solution is
+		 * found
+		 */
+		console_resizing = 1;
 		fb_set_var(info, &var);
+		console_resizing = 0;
 	}
 	p->vrows = var.yres_virtual/fh;
 	if (var.yres > (fh * (height + 1)))
@@ -1658,6 +1666,12 @@ static int fbcon_switch(struct vc_data *
 	}
 	if (info)
 		info->var.yoffset = p->yscroll = 0;
+
+	/* Set currcon before fbcon_resize or we'll do bad things
+	 * when fbdev calls us back on mode changed notification
+	 */
+	info->currcon = vc->vc_num;
+
         fbcon_resize(vc, vc->vc_cols, vc->vc_rows);
 	switch (p->scrollmode & __SCROLL_YMASK) {
 	case __SCROLL_YWRAP:
@@ -1674,8 +1688,6 @@ static int fbcon_switch(struct vc_data *
 	}
 	scrollback_max = 0;
 	scrollback_current = 0;
-
-	info->currcon = vc->vc_num;
 	
 	update_var(vc->vc_num, info);
 	fbcon_set_palette(vc, color_table); 	
@@ -1697,7 +1709,7 @@ static int fbcon_switch(struct vc_data *
 
 static int fbcon_blank(struct vc_data *vc, int blank)
 {
-	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
+ 	unsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;
 	struct fb_info *info = registered_fb[(int) con2fb_map[vc->vc_num]];
 	struct display *p = &fb_display[vc->vc_num];
 
@@ -2261,6 +2273,58 @@ static int fbcon_set_origin(struct vc_da
 	return 0;
 }
 
+static void fbcon_suspended(void *data, struct fb_info *info)
+{
+	/* Here, we should do something to properly erase the
+	 * cursor and synchronize with the cursor interrupt on
+	 * SMP... (may not be that critical though...)
+	 */
+}
+
+static void fbcon_resumed(void *data, struct fb_info *info)
+{
+	struct vc_data *vc;
+
+	if (info->currcon < 0)
+		return;
+	vc = vc_cons[info->currcon].d;
+
+	update_screen(vc->vc_num);
+}
+
+static void fbcon_mode_changed(void *data, struct fb_info *info)
+{
+	struct vc_data *vc;
+	int rows, cols;
+
+	if (info->currcon < 0)
+		return;
+	vc = vc_cons[info->currcon].d;
+
+	/* This isn't perfect yet. If we change one console, we
+	 * don't change them all and we switch back to the wrong
+	 * mode on next console switch. We need to either keep a
+	 * per-console car or fix mode selection based on console
+	 * size. --BenH.
+	 */
+	if (vt_cons[vc->vc_num]->vc_mode != KD_TEXT)
+		return;
+	rows = info->var.yres / vc->vc_font.height;
+	cols = info->var.xres / vc->vc_font.width;
+	if (cols == vc->vc_cols && rows == vc->vc_rows)
+		return;
+	DPRINTK("mode changed, resizing: %dx%d\n", cols, rows);
+	if (console_resizing) {
+		DPRINTK("resize skipped, busy !\n");
+		return;
+	}
+	vc_resize(vc->vc_num, cols, rows);
+	if (CON_IS_VISIBLE(vc)) {
+		accel_clear_margins(vc, info, 0);
+		update_screen(vc->vc_num);
+	}
+}
+
 /*
  *  The console `switch' structure for the frame buffer based console
  */
@@ -2287,16 +2351,25 @@ const struct consw fb_con = {
 	.con_resize             = fbcon_resize,
 };
 
+static struct fb_client_ops fbcon_client = {
+	.owner			= THIS_MODULE,
+	.mode_changed		= fbcon_mode_changed,
+	.suspended		= fbcon_suspended,
+	.resumed		= fbcon_resumed,
+};
+
 int __init fb_console_init(void)
 {
 	if (!num_registered_fb)
 		return -ENODEV;
 	take_over_console(&fb_con, first_fb_vc, last_fb_vc, fbcon_is_default);
+	register_fb_client(&fbcon_client, NULL);
 	return 0;
 }
 
 void __exit fb_console_exit(void)
 {
+	unregister_fb_client(&fbcon_client);
 	give_up_console(&fb_con);
 }	
 
diff -purN /dev/shm/linux-2.5/drivers/video/fbmem.c linuxppc-2.5-benh/drivers/video/fbmem.c
--- /dev/shm/linux-2.5/drivers/video/fbmem.c	2004-01-19 06:22:21.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/fbmem.c	2004-01-21 00:29:29.000000000 +0000
@@ -27,6 +27,7 @@
 #include <linux/init.h>
 #include <linux/linux_logo.h>
 #include <linux/proc_fs.h>
+#include <linux/console.h>
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
@@ -143,6 +144,8 @@ extern int sstfb_init(void);
 extern int sstfb_setup(char*);
 extern int i810fb_init(void);
 extern int i810fb_setup(char*);
+extern int ibmlcdfb_init(void);
+extern int ibmlcdfb_setup(char*);
 extern int ffb_init(void);
 extern int ffb_setup(char*);
 extern int cg6_init(void);
@@ -255,6 +258,9 @@ static struct {
 #ifdef CONFIG_FB_STI
 	{ "stifb", stifb_init, stifb_setup },
 #endif
+#ifdef CONFIG_FB_IBMLCDC
+	{ "ibmlcdfb", ibmlcdfb_init, ibmlcdfb_setup },
+#endif
 #ifdef CONFIG_FB_FFB
 	{ "ffb", ffb_init, ffb_setup },
 #endif
@@ -398,6 +404,9 @@ static int num_pref_init_funcs __initdat
 struct fb_info *registered_fb[FB_MAX];
 int num_registered_fb;
 
+static LIST_HEAD(fb_clients);
+static DECLARE_MUTEX(fb_clients_lock);
+
 #ifdef CONFIG_FB_OF
 static int ofonly __initdata = 0;
 #endif
@@ -941,6 +950,8 @@ fb_set_var(struct fb_info *info, struct 
 			fb_pan_display(info, &info->var);
 
 			fb_set_cmap(&info->cmap, 1, info);
+
+			fb_clients_call_mode_changed(info);
 		}
 	}
 	return 0;
@@ -990,7 +1001,9 @@ fb_ioctl(struct inode *inode, struct fil
 	case FBIOPUT_VSCREENINFO:
 		if (copy_from_user(&var, (void *) arg, sizeof(var)))
 			return -EFAULT;
+		acquire_console_sem();
 		i = fb_set_var(info, &var);
+		release_console_sem();
 		if (i) return i;
 		if (copy_to_user((void *) arg, &var, sizeof(var)))
 			return -EFAULT;
@@ -1009,7 +1022,10 @@ fb_ioctl(struct inode *inode, struct fil
 	case FBIOPAN_DISPLAY:
 		if (copy_from_user(&var, (void *) arg, sizeof(var)))
 			return -EFAULT;
-		if ((i = fb_pan_display(info, &var)))
+		acquire_console_sem();
+		i = fb_pan_display(info, &var);
+		release_console_sem();
+		if (i)
 			return i;
 		if (copy_to_user((void *) arg, &var, sizeof(var)))
 			return -EFAULT;
@@ -1045,7 +1061,10 @@ fb_ioctl(struct inode *inode, struct fil
 		return 0;
 #endif	/* CONFIG_FRAMEBUFFER_CONSOLE */
 	case FBIOBLANK:
-		return fb_blank(info, arg);
+		acquire_console_sem();
+		i = fb_blank(info, arg);
+		release_console_sem();
+		return i;
 	default:
 		if (fb->fb_ioctl == NULL)
 			return -EINVAL;
@@ -1377,6 +1396,107 @@ int __init video_setup(char *options)
 
 __setup("video=", video_setup);
 
+/*
+ * Dummy operations used typically when power managing
+ */
+
+int fb_dummy_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	return 0;
+}
+
+void fb_dummy_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+}
+
+void fb_dummy_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+}
+
+void fb_dummy_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+}
+
+/*
+ * Wrappers to client calls
+ */
+
+int
+fb_set_suspend(struct fb_info *info, int suspended)
+{
+	if (suspended == info->suspended)
+		return 0;
+
+	info->suspended = suspended;
+	if (suspended)
+		fb_clients_call_suspended(info);
+	else
+		fb_clients_call_resumed(info);
+
+	return 0;
+}
+
+int register_fb_client(struct fb_client_ops *ops, void *data)
+{
+	struct fb_client *client;
+
+	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	if (client == NULL)
+		return -ENOMEM;
+
+	memset(client, 0, sizeof(*client));
+	client->ops = ops;
+	client->data = data;
+	
+	down(&fb_clients_lock);
+	list_add(&client->link, &fb_clients);
+	up(&fb_clients_lock);
+
+	return 0;
+}
+
+int unregister_fb_client(struct fb_client_ops *ops)
+{
+	struct fb_client *client = NULL;
+	struct list_head *pos;
+	
+	down(&fb_clients_lock);
+	list_for_each(pos, &fb_clients) {
+		client = list_entry(pos, struct fb_client, link);
+		if (client->ops == ops) {
+			list_del(&client->link);
+			kfree(client);
+			break;
+		}
+	}
+	up(&fb_clients_lock);
+
+	return 0;
+}
+
+#define make_fb_client_call(name) \
+int fb_clients_call_##name(struct fb_info *info) \
+{ \
+	struct fb_client *client = NULL; \
+	struct list_head *pos; \
+\
+	down(&fb_clients_lock); \
+	list_for_each(pos, &fb_clients) { \
+		client = list_entry(pos, struct fb_client, link); \
+		if (try_module_get(client->ops->owner)) { \
+			if (client->ops->name) \
+				client->ops->name(client->data, info); \
+			module_put(client->ops->owner); \
+		} \
+	} \
+	up(&fb_clients_lock); \
+	return 0; \
+}
+
+make_fb_client_call(mode_changed)
+make_fb_client_call(suspended)
+make_fb_client_call(resumed)
+
     /*
      *  Visible symbols for modules
      */
@@ -1393,5 +1513,15 @@ EXPORT_SYMBOL(fb_pan_display);
 EXPORT_SYMBOL(fb_get_buffer_offset);
 EXPORT_SYMBOL(move_buf_unaligned);
 EXPORT_SYMBOL(move_buf_aligned);
+EXPORT_SYMBOL(fb_set_suspend);
+EXPORT_SYMBOL(register_fb_client);
+EXPORT_SYMBOL(unregister_fb_client);
+EXPORT_SYMBOL(fb_clients_call_mode_changed);
+EXPORT_SYMBOL(fb_clients_call_suspended);
+EXPORT_SYMBOL(fb_clients_call_resumed);
+EXPORT_SYMBOL(fb_dummy_fillrect);
+EXPORT_SYMBOL(fb_dummy_copyarea);
+EXPORT_SYMBOL(fb_dummy_imageblit);
+EXPORT_SYMBOL(fb_dummy_cursor);
 
 MODULE_LICENSE("GPL");
diff -purN /dev/shm/linux-2.5/drivers/video/fbmon.c linuxppc-2.5-benh/drivers/video/fbmon.c
--- /dev/shm/linux-2.5/drivers/video/fbmon.c	2003-12-29 21:37:26.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/fbmon.c	2004-01-09 02:58:32.000000000 +0000
@@ -566,17 +566,18 @@ static int get_std_timing(unsigned char 
 	}
 	refresh = (block[1] & 0x3f) + 60;
 
+	/* First find standard mode from the table of VESA modes */
 	for (i = 0; i < VESA_MODEDB_SIZE; i++) {
 		if (vesa_modes[i].xres == xres && 
 		    vesa_modes[i].yres == yres &&
 		    vesa_modes[i].refresh == refresh) {
 			*mode = vesa_modes[i];
-			break;
-		} else {
-			calc_mode_timings(xres, yres, refresh, mode);
-			break;
+			return 1;
 		}
 	}
+	/* If mode is not found in table, calculate it using GTF */
+	calc_mode_timings(xres, yres, refresh, mode);
+
 	return 1;
 }
 
@@ -1178,7 +1179,7 @@ int fb_get_mode(int flags, u32 val, stru
  * REQUIRES:
  * A valid info->monspecs.
  */
-int fb_validate_mode(struct fb_var_screeninfo *var, struct fb_info *info)
+int fb_validate_mode(const struct fb_var_screeninfo *var, struct fb_info *info)
 {
 	u32 hfreq, vfreq, htotal, vtotal, pixclock;
 	u32 hfmin, hfmax, vfmin, vfmax, dclkmin, dclkmax;
diff -purN /dev/shm/linux-2.5/drivers/video/ibmlcd.h linuxppc-2.5-benh/drivers/video/ibmlcd.h
--- /dev/shm/linux-2.5/drivers/video/ibmlcd.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/ibmlcd.h	2002-09-05 23:31:08.000000000 +0000
@@ -0,0 +1,417 @@
+/*
+ * linux/drivers/video/ibmlcd.h -- 
+ *    Driver for IBM Liquid Crystal Display Controller 
+ *    - original use in PowerPC 405LP embedded platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, International Business Machines Corporation
+ * All Rights Reserved.
+ *
+ * David T. Eger   <eger@cc.gatech.edu>
+ * Matthew Helsley <mhelsley@linux.ucla.edu>
+ * Bishop Brock    <bcbrock@us.ibm.com>
+ * August 2001
+ *
+ * March 2002 : Modified for Initial Release
+ *              Bishop Brock, bcbrock@us.ibm.com
+ */
+
+#ifndef __IBMLCDC_H__
+#define __IBMLCDC_H__
+
+/* Provide debugging-level ioctl()'s to dump registers directly? */
+/* #define DEBUG_IBMLCD */
+
+#ifdef __KERNEL__
+#include <linux/fb.h>
+#include <asm/semaphore.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/ibm4xx.h>
+#endif
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#define IBMLCD_IDSTRING	"IBM LCDC"
+
+/* track if a par we are passed has been properly initialized */
+#define IBMLCD_INIT_MAGIC 0x1CDC600D
+
+/* Default amount of Mem to alloc for the Framebuffer */
+#define DEFAULT_FB_MEM 0x00100000
+
+struct ibmlcdfb_par;
+
+#ifdef DEBUG_IBMLCD
+struct ibmlcd_raw_dcrs;
+
+ /* Debugging IOCTLs */
+
+ /* Read the raw values of the LCD DCRs and report report 
+  * them to user space at the user address given */
+#define FBIO_GETRAW_HW  _IOR('F',0x18,struct ibmlcd_raw_dcrs)
+
+ /* Read the raw values out of the LCD DCRs, convert their
+  * values to that of a par struct, and report them to user
+  * space at the user address given */
+#define FBIO_GETHW_PAR	_IOR('F',0x19,struct ibmlcdfb_par)
+
+ /* #define FBIO_SETHW_PAR      _IOW('F',0x1A, struct ibmlcdfb_par) */
+
+ /* Return the locality that this driver believes itself to be 
+  *  - IBMLCD_ON_CHIP or IBMLCD_ON_BOARD_PECAN */
+#define FBIO_GETLOCALE  _IO('F',0x1B)
+
+#endif
+
+/* Note:  This driver was written long before the LCDC DCRs obtained their
+   "official" names in the 405LP manual.  At some point we should go back and
+   make the names consistent, but for now, these #defines serve as a
+   translation key.*/
+
+/* Direct-mapped DCRs.  */
+
+#define LCDC0_CR      DCRN_LCD0_CFG	/* Configuration Register */
+#define LCDC0_ICR     DCRN_LCD0_ICR	/* Interrupt Control Register */
+#define LCDC0_ISR     DCRN_LCD0_ISR	/* Interrupt Status Register */
+#define LCDC0_IMR     DCRN_LCD0_IMR	/* Interrupt Mask Register */
+#define LCDC0_CFGADDR DCRN_LCD0_CFGADDR	/* Indirect Configuration Address */
+#define LCDC0_CFGDATA DCRN_LCD0_CFGDATA	/* Indirect Configuration Data */
+
+/* Indirect DCRs */
+
+#define LCDC0_DER     DCRN_LCD0_DER	/* Display Enable Regsiter */
+#define LCDC0_DCR     DCRN_LCD0_DCFG	/* Display Configuration Register */
+#define LCDC0_DSR     DCRN_LCD0_DSR	/* Display Status Register */
+#define LCDC0_DFRMR   DCRN_LCD0_FRDR	/* Dither and Frame Rate Modulation Reg. */
+#define LCDC0_PSR     DCRN_LCD0_SDR	/* Power On/Off Sequence Register */
+#define LCDC0_ADSR    DCRN_LCD0_ADSR	/* Active Display Size Register */
+#define LCDC0_TDSR    DCRN_LCD0_TDSR	/* Total Display Size Register */
+#define LCDC0_FPLCR   DCRN_LCD0_FPLCR	/* FPLINE Control Register */
+#define LCDC0_FPLOR   DCRN_LCD0_FPLOR	/* FPLINE Offset Register */
+#define LCDC0_FPFCR   DCRN_LCD0_FPFCR	/* FPFRAME Control Register */
+#define LCDC0_FPFOR   DCRN_LCD0_FPFOR	/* FPFRAME Offset Register */
+#define LCDC0_FPSCR   DCRN_LCD0_FPSCR	/* FPSHIFT Control Register */
+#define LCDC0_FPDRCR  DCRN_LCD0_FPDRR	/* FPDRDY Control Register */
+#define LCDC0_FPDACR  DCRN_LCD0_FPDCR	/* FPDATA Control Register */
+#define LCDC0_MISC    DCRN_LCD0_PFBFR	/* Miscellaneous Register */
+#define LCDC0_PFR     DCRN_LCD0_PFR	/* Pixel Format Register */
+#define LCDC0_BAR     DCRN_LCD0_FBBAR	/* Base Address Register */
+#define LCDC0_SR      DCRN_LCD0_STRIDE	/* Stride Register */
+#define LCDC0_PARBASE DCRN_LCD0_PAR	/* Palette Access Registers Base */
+#define LCDC0_CER     DCRN_LCD0_CER	/* Cursor Enable Register */
+#define LCDC0_CBAR    DCRN_LCD0_CBAR	/* Cursor Base Address Register */
+#define LCDC0_CLR     DCRN_LCD0_CLR	/* Cursor Location Register */
+#define LCDC0_CC0     DCRN_LCD0_CC0R	/* Cursor Color 0 */
+#define LCDC0_CC1     DCRN_LCD0_CC1R	/* Cursor Color 1 */
+#define LCDC0_PARn(n) DCRN_LCD0_PARn(n)	/* Palette Register n */
+
+#define LCDC0_PIXMAP_CUR_COLOR0 0
+#define LCDC0_PIXMAP_CUR_COLOR1 1
+#define LCDC0_PIXMAP_CUR_TRANSP 2
+#define LCDC0_PIXMAP_CUR_XOR    3
+#define LCDC0_PIXMAP_CURSOR_SIZE (64*64*2/8)
+	/* 64 pix by 64 pix by 2 bits / (8bits/byte) */
+
+/* Routines for accessing LCDC DCRs */
+
+#define write_lcdc_dcr(info,dcrn,rvalue) 	\
+do { 					\
+mtdcr((dcrn),(rvalue));	\
+}while(0)
+
+#define read_lcdc_dcr(info,dcrn) \
+({ mfdcr((dcrn)); })
+
+#define write_lcdc_dcri(info,dcrn, rvalue) \
+do {\
+	write_lcdc_dcr((info),LCDC0_CFGADDR,(dcrn));\
+	write_lcdc_dcr((info),LCDC0_CFGDATA,(rvalue));\
+}while(0)
+
+#define read_lcdc_dcri(info,dcrn) \
+({\
+	write_lcdc_dcr((info),LCDC0_CFGADDR,(dcrn));\
+	read_lcdc_dcr((info),LCDC0_CFGDATA);\
+})
+
+/* Structures to represent the LCDC registers */
+
+#ifdef DEBUG_IBMLCD
+
+struct ibmlcd_raw_dcrs {
+	__u32 der;
+	__u32 dcr;
+	__u32 dfrmr;
+	__u32 psr;
+	__u32 adsr;
+	__u32 tdsr;
+	__u32 fplcr;
+	__u32 fplor;
+	__u32 fpfcr;
+	__u32 fpfor;
+	__u32 fpscr;
+	__u32 fpdrcr;
+	__u32 fpdacr;
+	__u32 misc;
+	__u32 pfr;
+	__u32 bar;
+	__u32 sr;
+	__u32 cer;
+	__u32 cbar;
+	__u32 clr;
+	__u32 cc0;
+	__u32 cc1;
+};
+
+#endif
+
+#ifdef __KERNEL__
+
+/*
+ * struct ibmlcdfb_info
+ * 
+ * Warning! This is very C++ish.  
+ * We "subclass" from fb_info_gen - the struct that the "generic" fb driver
+ * 		expects - fbgen.c (see include/linux/fb.h)
+ * which "subclasses" from fb_info - the struct that the rest of the kernel
+ * 		expects. (see include/linux/fb.h)
+ * 		
+ * The purpose of this struct is to contain all of the information associated
+ * with a single framebuffer device.  In our case, we associate one framebuffer
+ * with each LCD Controller Core.
+ */
+struct ibmlcdfb_info {
+	struct fb_info info;	/* must be first so casting works */
+	struct semaphore sem;	/* lock on this framebuffer device */
+	struct list_head list;	/* provision for multiple LCDs */
+
+	unsigned int locality;	/* AV: 0,1,2,3 */
+
+	void *LCDC_pdcr_base;	/* ioremap() virtual addy */
+};
+
+#endif
+
+/* 
+ * This structure defines the hardware state of the graphics card. 
+ *
+ * The fields in this struct roughly equate to the bitfields of the
+ * registers we must set.  Unfortunately, the values are
+ * counter-intuitive.
+ * For example, for single scan mode, the DCR's bitfield is 0, and
+ * for double scan mode, the DCR's bitfield is 1, where more intutively,
+ * they should be 1 and 2.  Therefore, in our struct, we accept the
+ * values 1 and 2 instead of 0 and 1.  Accepted Values are indicated.
+ */
+struct ibmlcdfb_par {
+	/* Basic Hardware information */
+	__u32 magic;		/* struct set up = IBMLCD_INIT_MAGIC */
+
+	/* the difference between this and the base address register is 
+	 * that (1) this points to the *actual* beginning of video memory,  
+	 * the BAR may change with panning, and (2) the BAR is a physical 
+	 * address locally for IBMLCD_ON_CHIP and IBMLCD_ON_BOARD_PECAN,
+	 * and PCI-ish space for IBMLCD_VIA_PCI */
+	void *LCDC_vfb_base;	/* ioremap() virtual addy */
+	__u32 LCDC_dfb_base;	/* start of frame buffer memory adjusted 
+				   for device.  That is, it is the 
+				   physical address for soc and on_board
+				   and remote-PCI adjusted for pci */
+
+	/* Used when we allocate the framebuffer from main memory */
+	unsigned int num_fb_pages;	/* number of pages alloc'd for
+					   the framebuffer */
+	void *LCDC_vfb_orig;	/* pre-ioremap() virtual addy 
+				   from __get_free_pages() */
+
+	__u16 virt_xres;
+	__u16 virt_yres;
+
+	/* Much like the LCDC_vfb_base, and LCDC_dfb_base... */
+	void *LCDC_vcursor_base;
+	__u32 LCDC_dcursor_base;
+
+	/* Display Configuration Register - LCDC0_DCR */
+	unsigned int reduced_horiz_blanking:1;	/* AV: 0,1 */
+	unsigned int tft_multiplex_ratio:2;	/* AV: 1,2 */
+	unsigned int FPSHIFT_clocks:2;	/* AV: 1,2 */
+	unsigned int pixel_clock_per_shift_clock:4;	/* AV: 1-8 */
+	unsigned int n_scan_mode:2;	/* AV: 1,2 */
+	unsigned int LCD_panel_size:3;	/* AV: 0-7 */
+	unsigned int LCD_panel_type:2;	/* AV: 0,1,3 */
+
+	/* Dither and Frame Rate Modulation Register - LCDC0_DFRMR */
+	unsigned int FRM_bits:3;	/* AV: 0-4,7 */
+	unsigned int dither_bits:3;	/* AV: 0-4 */
+	unsigned int native_resolution_bits:4;	/* AV: 1-8 */
+
+	/* Power On/Off Sequence Register - LCDC0_PSR */
+	/* These signal delay values are in 2^(n-1) scan line periods */
+	/* except n=0, where there is no delay. */
+	unsigned int FPSHIFT_delay:4;	/* AV: 0-15 */
+	unsigned int FPFRAME_delay:4;	/* AV: 0-15 */
+	unsigned int FP_VEE_EN_delay:4;	/* AV: 0-15 */
+	unsigned int FP_EN_delay:4;	/* AV: 0-15 */
+
+	/* Active Display Size Register - LCDC0_ADSR */
+	unsigned int horiz_pixels:11;	/* AV: 1-2048 */
+	unsigned int vert_pixels:12;	/* AV: 1-2048 */
+	/* vert_pixels is the total number of pixels.
+	 *  the registers are funky and for dual scan mode take 
+	 *  half this value. */
+
+	/* Total Display Size Register - LCDC0_TDSR */
+	/*  These values incorporate the active scan + blanking */
+	unsigned int total_horiz_pixels:11;	/* AV: 1-2048 */
+	/* Horizontal display size in number of pixels
+	 * - must be integer multiple of effective_pclk_to_sclk ratio
+	 * - normal blanking => must be long enough to fetch pixel data
+	 * - reduced blanking => at least 4 +
+	 *                        "effective_pclk_to_sclk_ratio" */
+	unsigned int total_vert_pixels:12;	/* AV: 2-2048 */
+	/* v_blanking = total_vert_pixels - vert_pixels */
+	/* vert_pixels is the total number of pixels.
+	 *  the registers are funky and for dual scan mode take 
+	 *  half this value. */
+
+	/* FPLINE Control Register - LCDC0_FPLCR */
+	unsigned int FPLINE_mask_during_v_blank:1;	/* AV: 0,1 */
+	unsigned int FPLINE_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPLINE Offset Register - LCDC0_FPLOR */
+	unsigned int FPLINE_hoff_start:11;	/* AV: 1-2048 */
+	unsigned int FPLINE_hoff_end:11;	/* AV: 1-2048 */
+
+	/* FPFRAME Control Register - LCDC0_FPFCR */
+	unsigned int FPFRAME_hoff:11;	/* AV: 1-2048 */
+	unsigned int FPFRAME_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPFRAME Offset Register - LCDC0_FPFOR */
+	unsigned int FPFRAME_voff_start:11;	/* AV: 1-2048 */
+	unsigned int FPFRAME_voff_end:11;	/* AV: 1-2048 */
+
+	/* FPSHIFT Control Register - LCDC0_FPSCR */
+	unsigned int FPSHIFT_masking:2;	/* AV: 0,1,3 */
+	unsigned int FPSHIFT_valid_at_positive_edge:1;	/* AV: 0,1 */
+
+	/* FPDRDY Control Register - LCDC0_FPDRCR */
+	unsigned int FPDRDY_polarity_negative:1;	/* AV: 0,1 */
+
+	/* FPDATA Control Register - LCDC0_FPDACR */
+	unsigned int FPDATA_polarity_negative:1;	/* AV: 0,1 */
+
+	/* Miscellaneous Register - LCDC0_MISC */
+	unsigned int pixels_big_endian:1;	/* AV: 0,1 */
+
+	/* Pixel Format Register - LCDC0_PFR */
+	unsigned int pixel_packing:1;	/* AV: 0,1 */
+	unsigned int pixel_size:3;	/* AV: 0,1,5,6,7 */
+	unsigned int pixel_index_size:2;	/* AV: 0-3 */
+	unsigned int palette_enable:1;	/* AV: 0,1 */
+	unsigned int enable_surface:1;	/* AV: 0,1 */
+
+	/* Base Address Register - LCDC0_BAR */
+	__u32 fb_base_address;
+
+	/* Stride Register - LCDC0_SR */
+	unsigned int stride:13;
+
+	/* Cursor Enable Register - LCDC0_CER */
+	unsigned int cursor_enable:1;	/* AV: 0,1 */
+
+	/* Cursor Base Address Register - LCDC0_CBAR */
+	__u32 cursor_base_address;	/* AV: 1k granularity */
+
+	/* Cursor Location Register - LCDC0_CLR */
+	int cursor_x;		/* AV: -2048 - 2047 */
+	int cursor_y;		/* AV: -2048 - 2047 */
+
+	/* Cursor Color 0 - LCDC0_CC0 */
+	unsigned int cc0r:6;	/* AV: 0..63 */
+	unsigned int cc0g:6;	/* AV: 0..63 */
+	unsigned int cc0b:6;	/* AV: 0..63 */
+
+	/* Cursor Color 1 - LCDC0_CC1 */
+	unsigned int cc1r:6;	/* AV: 0..63 */
+	unsigned int cc1g:6;	/* AV: 0..63 */
+	unsigned int cc1b:6;	/* AV: 0..63 */
+
+	/* Timing - frequencies are in KHz */
+
+	unsigned int pixclk_min;
+	unsigned int pixclk_max;
+};
+
+/* Some field values */
+
+/* locality */
+#define IBMLCD_NOT_FOUND	0
+#define IBMLCD_ON_CHIP		1
+#define IBMLCD_ON_BOARD_PECAN	2
+
+/* power state - or'ed together */
+#define IBMLCD_HSYNC_ENABLE 0x00000002
+#define IBMLCD_VSYNC_ENABLE 0x00000001
+#define IBMLCD_POWER_OFF    0x04000000
+
+/* LCDC0_DCR - LCD_panel_size */
+#define TFT_3BIT	0
+#define STN_1BIT	0
+#define TFT_6BIT	1
+#define STN_2BIT	1
+#define TFT_9BIT	2
+#define STN_4BIT	2
+#define TFT_12BIT	3
+#define STN_8BIT	3
+#define TFT_15BIT	4
+#define STN_16BIT	4
+#define TFT_18BIT	5
+#define TFT_21BIT	6
+#define TFT_24BIT	7
+
+/* LCDC0_DCR - LCD_panel_type */
+#define IBMLCD_MONO_STN  0
+#define IBMLCD_COLOR_STN 2
+#define IBMLCD_COLOR_TFT 3
+
+/* LCDC0_FPSCR - FPSHIFT_masking */
+#define IBMLCD_FPSHIFT_NO_MASKING	       0
+#define IBMLCD_FPSHIFT_MASK_FOR_HORIZ	       1
+#define IBMLCD_FPSHIFT_MASK_FOR_HORIZ_AND_VERT 3
+
+/* LCDC0_PFR - pixel_packing */
+#define IBMLCD_RGB	0
+#define IBMLCD_BGR	1
+
+/* LCDC0_PFR - pixel_size */
+#define IBMLCD_PIX_INDEXED 0
+#define IBMLCD_PIX_15BPP   1
+#define IBMLCD_PIX_16BPP   5
+#define IBMLCD_PIX_24BPP   6
+#define IBMLCD_PIX_32BPP   7
+
+/* LCDC0_PFR - pixel_index_size */
+#define IBMLCD_PAL_1BPP 0
+#define IBMLCD_PAL_2BPP 1
+#define IBMLCD_PAL_4BPP 2
+#define IBMLCD_PAL_8BPP 3
+
+#endif
diff -purN /dev/shm/linux-2.5/drivers/video/ibmlcdfb.c linuxppc-2.5-benh/drivers/video/ibmlcdfb.c
--- /dev/shm/linux-2.5/drivers/video/ibmlcdfb.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/ibmlcdfb.c	2002-09-05 23:31:08.000000000 +0000
@@ -0,0 +1,2013 @@
+/*
+ * linux/drivers/video/ibmlcdfb.c -- 
+ *    Driver for IBM Liquid Crystal Display Controller 
+ *    - original use in PowerPC 405LP embedded platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *  Copyright (C) 2001 David T. Eger   <eger@cc.gatech.edu>
+ *                     Matthew Helsley <mhelsley@linux.ucla.edu>
+ *                     Bishop Brock    <bcbrock@us.ibm.com>
+ *
+ *  Adapted from FB Skeleton by Geert Uytterhoeven 
+ *                   --- linux/drivers/video/skeletonfb.c
+ *  And Framebuffer non-cacheable memory allocation scheme inspired by
+ *                   --- linux/drivers/video/sa1100fb.c
+ *                   
+ * April 2002, Modified for initial public release
+ *             Bishop Brock, bcbrock@us.ibm.com
+ *             Simplified the emulation setup and removed PCI emulation
+ * Sept. 2002, Ported to 2.5  Todd Poynor <source@mvista.com>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/wrapper.h> /* mem_map_(un)reserve */
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/ctype.h>	/* isdigit, isxdigit */
+#include <asm/uaccess.h>	/* copy_[to|from]_user */
+#include <video/fbcon.h>
+#include "ibmlcd.h"
+
+#undef CEIL
+#define CEIL(n,d) (((n)+(d-1))/(d))
+
+/*
+ * Below is a collection of structures, each one defining the capabilities
+ * and default video mode for an LCD.  The values you enter here for resolution
+ * are taken to be the exact capabilities of the LCD, and cannot be changed at
+ * run time.  Some of the other characteristics, such as bit-depth and virtual
+ * resolution can be changed at run time.  
+ *
+ * In order to add a new profile, you need to do two things:
+ *    (1) Create a new structure describing your LCD panel
+ *        This involves getting the proper values to write to the
+ *        LCDC's registers.  A lot of them you can figure out, most of them,
+ *        you'll need to consult:
+ *         - "Liquid Crystal Display Controller Core" 
+ *            SA14-2342-00 IBM Microelectronics Division
+ *            (NOTE: IBM Confidential)
+ *         - linux/drivers/video/ibmlcd.h - contains definition of the 
+ *            par structure used here, what the fields mean,  and what 
+ *            ranges are valid for the given fields.
+ *    (2) Add your structure, and one or more unique aliases to it to 
+ *        ibmlcd_configs at the bottom of this file.
+ *    (3) Use the alias as a command line argument to the kernel.
+ *
+ * TODO: + Change the timing information presented here from precise values, 
+ *         to a usable range, for use with frequency-scaling and dynamic 
+ *         reprogramming of clock dividers
+ *       + Pass the physical screen size in mm width and height, to put in
+ *         the var struct.
+ */
+
+static const struct ibmlcdfb_par IBMLCD_CONFIG0 = {
+	/* DCR */
+	reduced_horiz_blanking:1,
+	tft_multiplex_ratio:1,
+	FPSHIFT_clocks:1,
+	pixel_clock_per_shift_clock:3,
+	n_scan_mode:1,
+	LCD_panel_size:STN_8BIT,
+	LCD_panel_type:IBMLCD_COLOR_STN,
+
+	/* DFRMR */
+	FRM_bits:4,
+	dither_bits:2,
+	native_resolution_bits:1,
+
+	/* PSR */
+	FPSHIFT_delay:12,
+	FPFRAME_delay:12,
+	FP_VEE_EN_delay:13,
+	FP_EN_delay:14,
+
+	/* ADSR */
+	horiz_pixels:320,
+	vert_pixels:240,
+
+	/* TDSR */
+	total_horiz_pixels:328,
+	total_vert_pixels:245,
+
+	FPLINE_mask_during_v_blank:0,
+	FPLINE_polarity_negative:0,
+
+	FPLINE_hoff_start:122,
+	/* 122 * 8/3 =  325; Yes this looks strange. */
+	/* Basic idea - setting hoff_start to zero resulted in screen
+	 * being shifted to the right several pixels.  To correct this,
+	 * we set the value here to the equivalent of -3 pixels in the
+	 * data stream.  -3 = 325 mod 328.
+	 * Why the 8/3?  The Controller sees 8 bit values, but sends 
+	 * 3 bit values packed to the LCD.  Yeah, funky, like I said.
+	 * Koji Ishii was the mastermind to figure this value out */
+	FPLINE_hoff_end:0,
+
+	FPFRAME_hoff:1,
+	FPFRAME_polarity_negative:0,
+
+	FPFRAME_voff_start:0,
+	FPFRAME_voff_end:1,
+
+	FPSHIFT_masking:IBMLCD_FPSHIFT_NO_MASKING,
+	FPSHIFT_valid_at_positive_edge:0,
+
+	FPDRDY_polarity_negative:0,
+	FPDATA_polarity_negative:0,
+
+	pixels_big_endian:1,
+	pixel_packing:IBMLCD_RGB,
+	pixel_size:IBMLCD_PIX_16BPP,
+	pixel_index_size:IBMLCD_PAL_8BPP,
+	palette_enable:0,
+	enable_surface:1,
+
+	fb_base_address:0,	/* dummy value */
+	stride:320 * 2,		/* 320 pixels, 2 bytes per pixel */
+	cursor_enable:0,
+	cursor_base_address:0,	/* dummy value */
+	cursor_x:0,
+	cursor_y:0,
+	cc0r:0, cc0g:0, cc0b:0,
+	cc1r:0xFF, cc1g:0xFF, cc1b:0xFF,
+
+	/* The Hitachi STN is specified for a Pixel clock in the range of 
+	   6 MHz to 8 Mhz.  CLock frequencies are in KHz */
+
+	pixclk_min:6000,
+	pixclk_max:8000
+};
+
+static const struct ibmlcdfb_par IBMLCD_CONFIG1 = {
+	/* DCR */
+	reduced_horiz_blanking:1,
+	tft_multiplex_ratio:1,
+	FPSHIFT_clocks:1,
+	pixel_clock_per_shift_clock:1,
+	n_scan_mode:1,
+	LCD_panel_size:TFT_18BIT,
+	LCD_panel_type:IBMLCD_COLOR_TFT,
+
+	/* FRMR */
+	FRM_bits:0,
+	dither_bits:0,
+	native_resolution_bits:6,
+
+	/* PSR */
+	FPSHIFT_delay:12,
+	FPFRAME_delay:12,
+	FP_VEE_EN_delay:13,
+	FP_EN_delay:14,
+
+	/* ADSR */
+	horiz_pixels:640,
+	vert_pixels:480,
+
+	/* TDSR */
+	total_horiz_pixels:800,
+	total_vert_pixels:525,
+
+	FPLINE_mask_during_v_blank:1,
+	FPLINE_polarity_negative:1,
+
+	FPLINE_hoff_start:640,	/* See comment in the first configuration */
+	FPLINE_hoff_end:0,
+
+	FPFRAME_hoff:1,
+	FPFRAME_polarity_negative:1,
+
+	FPFRAME_voff_start:480,
+	FPFRAME_voff_end:0,
+
+	FPSHIFT_masking:IBMLCD_FPSHIFT_NO_MASKING,
+	FPSHIFT_valid_at_positive_edge:0,
+
+	FPDRDY_polarity_negative:0,
+	FPDATA_polarity_negative:0,
+
+	pixels_big_endian:1,
+	pixel_packing:IBMLCD_RGB,
+	pixel_size:IBMLCD_PIX_16BPP,
+	pixel_index_size:IBMLCD_PAL_8BPP,
+	palette_enable:0,
+	enable_surface:1,
+
+	fb_base_address:0,	/* dummy value */
+	stride:640 * 2,		/* 640 pixels, 2 bytes per pixel */
+	cursor_enable:0,
+	cursor_base_address:0,	/* dummy value */
+	cursor_x:0,
+	cursor_y:0,
+	cc0r:0, cc0g:0, cc0b:0,
+	cc1r:0xFF, cc1g:0xFF, cc1b:0xFF,
+
+	/* The Toshiba TFT is specified for a Pixel clock in the range of 
+	   21.5 MHz to 28.6 Mhz.  Clock frequencies are in KHz */
+
+	pixclk_min:21500,
+	pixclk_max:28600
+};
+
+/* Format: A sequence of database entries, terminated by two consecutive NULLs
+ *	Each entry consists of:
+ *	+ a pointer to a (constant) par description for the LCD,
+ *	+ 1 or more pointers to (constant) descriptive strings / aliases,
+ *	+ a NULL
+ */
+static const void *ibmlcd_configs[] = {
+	/* First Entry */
+	&IBMLCD_CONFIG0,
+	"HitachiQVGA-STN",
+	"HitachiSC09Q002-AZA",
+	NULL,
+	/* Second Entry */
+	&IBMLCD_CONFIG1,
+	"ToshibaVGA-TFT",
+	"TosibaLTM04C380K",
+	NULL,
+	/* ... */
+	/* Last Entry */
+	NULL,
+};
+
+/* 
+ * The current state of the hardware.
+ */
+static struct ibmlcdfb_par current_par;
+
+    /* To go away in the near future */ 
+static struct display disp;
+
+static u32 pseudo_palette[17];
+
+const struct ibmlcdfb_par *
+ibmlcd_config_matching(char *description)
+{
+	void **entry = (void **) ibmlcd_configs;
+	while ((*entry) != NULL) {
+
+		char **name = (char **) (entry);
+		while (*++name != NULL)
+			if (!strcmp(description, *name)) {
+				printk(KERN_INFO
+				       "ibmlcdfb: Configuring for panel %s\n",
+				       *name);
+				return *entry;
+			}
+		entry = (void **) ++name;
+	}
+	return NULL;
+}
+
+const char *
+ibmlcd_config_name(const struct ibmlcdfb_par *par)
+{
+	const void **entry;
+	for (entry = ibmlcd_configs; (*entry) != NULL; entry++) {
+		if ((*entry) == par)
+			return *(entry + 1);
+		else
+			while (*entry != NULL)
+				entry++;
+	}
+	return "Invalid LCD Description";
+}
+
+/* macros to encode the register formatted translations of our struct */
+
+/* Information is packed very tightly into the registers of 
+ * the LCD Controller -- we have much easier access to that information
+ * in the ibmlcdfb_par, but must eventually read and write to the hardware
+ * registers.  These functions are for packing and unpacking data to register
+ * format.
+ *
+ * Bit numbering in PowerPC:
+ * MSB                                      LSB
+ *  0 ... 7 | 8 ... 15 | 16 ... 23 | 24 ... 31 
+ *
+ * Examples:
+ * 
+ * ret |= (par->reduced_horiz_blanking << (31-7))
+ *
+ *    This line inserts a bitfield  starting at bit 7 into
+ *    a 32 bit value that is being prepared to be written to a DCR
+ *
+ * ret |= ((par->FPSHIFT_clocks & 0x2) << (31-11-1))
+ *
+ *    This is a bit trickier.  You are allowed to set 1 or 2 clocks
+ *    in par->FPSHIFT_clocks.  However, these are encoded as 0 or 1
+ *    in bit 11 of the register.  You see?
+ */
+
+static inline __u32
+mk_dcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->reduced_horiz_blanking << (31 - 7));
+	ret |= ((par->tft_multiplex_ratio & 0x2) << (31 - 10 - 1));
+	ret |= ((par->FPSHIFT_clocks & 0x2) << (31 - 11 - 1));
+	ret |= ((par->pixel_clock_per_shift_clock - 1) << (31 - 15));
+	ret |= ((par->n_scan_mode & 0x2) << (31 - 24 - 1));
+	ret |= ((par->LCD_panel_size) << (31 - 27));
+	ret |= ((par->LCD_panel_type) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_dcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->reduced_horiz_blanking = (value >> (31 - 7)) & 0x1;
+
+	par->tft_multiplex_ratio = (value >> (31 - 10 - 1)) & 0x2;
+	if (par->tft_multiplex_ratio != 0x2)
+		par->tft_multiplex_ratio = 1;
+
+	par->FPSHIFT_clocks = (value >> (31 - 11 - 1)) & 0x2;
+	if (par->FPSHIFT_clocks != 0x2)
+		par->FPSHIFT_clocks = 1;
+
+	par->pixel_clock_per_shift_clock = ((value >> (31 - 15)) & 0x7) + 1;
+
+	par->n_scan_mode = (value >> (31 - 24 - 1)) & 0x2;
+	if (par->n_scan_mode != 0x2)
+		par->n_scan_mode = 1;
+
+	par->LCD_panel_size = (value >> (31 - 27)) & 0x7;
+	par->LCD_panel_type = (value >> (31 - 31)) & 0x3;
+}
+
+static inline __u32
+mk_dfrmr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= ((par->FRM_bits) << (31 - 15));
+	ret |= ((par->dither_bits) << (31 - 23));
+	ret |= ((par->native_resolution_bits - 1) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_dfrmr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FRM_bits = (value >> (31 - 15)) & 0x7;
+	par->dither_bits = (value >> (31 - 23)) & 0x7;
+	par->native_resolution_bits = ((value >> (31 - 31)) & 0x7) + 1;
+}
+
+static inline __u32
+mk_psr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= ((par->FPSHIFT_delay) << (31 - 19));
+	ret |= ((par->FPFRAME_delay) << (31 - 23));
+	ret |= ((par->FP_VEE_EN_delay) << (31 - 27));
+	ret |= ((par->FP_EN_delay) << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_psr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPSHIFT_delay = (value >> (31 - 19)) & 0xF;
+	par->FPFRAME_delay = (value >> (31 - 23)) & 0xF;
+	par->FP_VEE_EN_delay = (value >> (31 - 27)) & 0xF;
+	par->FP_EN_delay = (value >> (31 - 31)) & 0xF;
+}
+
+static inline __u32
+mk_adsr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->horiz_pixels << (31 - 15));
+	ret |= ((par->vert_pixels / par->n_scan_mode) << (31 - 31));
+	return ret;
+}
+
+/* must digest_dcr first */
+static inline void
+digest_adsr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->horiz_pixels = (value >> (31 - 15)) & 0x7FF;
+	par->vert_pixels = ((value >> (31 - 31)) & 0x7FF) * par->n_scan_mode;
+}
+
+static inline __u32
+mk_tdsr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->total_horiz_pixels << (31 - 15));
+	ret |= ((par->total_vert_pixels / par->n_scan_mode) << (31 - 31));
+	return ret;
+}
+
+/* must digest_dcr first */
+static inline void
+digest_tdsr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->total_horiz_pixels = (value >> (31 - 15)) & 0x7FF;
+	par->total_vert_pixels =
+	    ((value >> (31 - 31)) & 0x7FF) * par->n_scan_mode;
+}
+
+static inline __u32
+mk_fplcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPLINE_mask_during_v_blank << (31 - 30));
+	ret |= (par->FPLINE_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fplcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPLINE_mask_during_v_blank = (value >> (31 - 30)) & 0x1;
+	par->FPLINE_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fplor(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPLINE_hoff_start << (31 - 15));
+	ret |= (par->FPLINE_hoff_end << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fplor(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPLINE_hoff_start = (value >> (31 - 15)) & 0x7FF;
+	par->FPLINE_hoff_end = (value >> (31 - 31)) & 0x7FF;
+}
+
+static inline __u32
+mk_fpfcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPFRAME_hoff << (31 - 15));
+	ret |= (par->FPFRAME_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpfcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPFRAME_hoff = (value >> (31 - 15)) & 0x7FF;
+	par->FPFRAME_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpfor(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPFRAME_voff_start << (31 - 15));
+	ret |= (par->FPFRAME_voff_end << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpfor(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPFRAME_voff_start = (value >> (31 - 15)) & 0x7FF;
+	par->FPFRAME_voff_end = (value >> (31 - 31)) & 0x7FF;
+}
+
+static inline __u32
+mk_fpscr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPSHIFT_masking << (31 - 30));
+	ret |= (par->FPSHIFT_valid_at_positive_edge << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpscr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPSHIFT_masking = (value >> (31 - 30)) & 0x3;
+	par->FPSHIFT_valid_at_positive_edge = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpdrcr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPDRDY_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpdrcr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPDRDY_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_fpdacr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->FPDATA_polarity_negative << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_fpdacr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->FPDATA_polarity_negative = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_misc(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->pixels_big_endian << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_misc(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->pixels_big_endian = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_pfr(const struct ibmlcdfb_par *par)
+{
+	__u32 ret = 0;
+	ret |= (par->pixel_packing << (31 - 24));
+	ret |= (par->pixel_size << (31 - 27));
+	ret |= (par->pixel_index_size << (31 - 29));
+	ret |= (par->palette_enable << (31 - 30));
+	ret |= (par->enable_surface << (31 - 31));
+	return ret;
+}
+
+static inline void
+digest_pfr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->pixel_packing = (value >> (31 - 24)) & 0x1;
+	par->pixel_size = (value >> (31 - 27)) & 0x7;
+	par->pixel_index_size = (value >> (31 - 29)) & 0x3;
+	par->palette_enable = (value >> (31 - 30)) & 0x1;
+	par->enable_surface = (value >> (31 - 31)) & 0x1;
+}
+
+static inline __u32
+mk_bar(const struct ibmlcdfb_par *par)
+{
+	return par->fb_base_address;
+}
+
+static inline void
+digest_bar(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->fb_base_address = value;
+}
+
+static inline __u32
+mk_sr(const struct ibmlcdfb_par *par)
+{
+	return par->stride;
+}
+
+static inline void
+digest_sr(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->stride = value & 0x1FFF;
+}
+
+static inline __u32
+mk_palent(const __u32 r, const __u32 g, const __u32 b)
+{
+	__u32 ret = 0;
+	ret |= ((0x3F & r) << (31 - 13));
+	ret |= ((0x3F & g) << (31 - 21));
+	ret |= ((0x3F & b) << (31 - 29));
+	return ret;
+}
+
+static inline __u32
+mk_cer(const struct ibmlcdfb_par *par)
+{
+	return par->cursor_enable;
+}
+
+static inline void
+digest_cer(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cursor_enable = value & 0x1;
+}
+
+static inline __u32
+mk_cbar(const struct ibmlcdfb_par *par)
+{
+	return par->cursor_base_address;
+}
+
+static inline void
+digest_cbar(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cursor_base_address = value & 0xFFFFFE00;
+}
+
+static inline __u32
+mk_clr(const struct ibmlcdfb_par *par)
+{
+	return (((par->cursor_x) << (31 - 15)) |
+		((par->cursor_y) << (31 - 31))) & 0x0FFF0FFF;
+}
+
+static inline void
+digest_clr(__u32 value, struct ibmlcdfb_par *par)
+{
+	int val = value;
+
+	/* Do some signed bit magic to extract the correct field
+	   (signed) field values -MH */
+	val = val << 4;
+	par->cursor_x = val >> (31 - 15 + 4);
+	par->cursor_y = (val << 12) >> (31 - 31 + 12);
+
+}
+
+static inline __u32
+mk_cc0(const struct ibmlcdfb_par *par)
+{
+	return mk_palent(par->cc0r, par->cc0g, par->cc0b);
+}
+
+static inline void
+digest_cc0(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cc0r = (value >> (31 - 13)) & 0x3F;
+	par->cc0g = (value >> (31 - 21)) & 0x3F;
+	par->cc0b = (value >> (31 - 29)) & 0x3F;
+}
+
+static inline __u32
+mk_cc1(const struct ibmlcdfb_par *par)
+{
+	return mk_palent(par->cc1r, par->cc1g, par->cc1b);
+}
+
+static inline void
+digest_cc1(__u32 value, struct ibmlcdfb_par *par)
+{
+	par->cc1r = (value >> (31 - 13)) & 0x3F;
+	par->cc1g = (value >> (31 - 21)) & 0x3F;
+	par->cc1b = (value >> (31 - 29)) & 0x3F;
+}
+
+static struct list_head fb_list;	/* provision for multiple LCDs */
+static struct semaphore fb_list_sem;	/* lock on the list */
+
+/* command line parameters passed to our driver
+ * - what sort of LCD is attached to this device? */
+static struct lcd_params {
+	const struct ibmlcdfb_par *par;
+	__u32 mem_length;
+	__u32 mem_location;	/* 0xFFFFFFFF if not specified */
+} lcd_params;
+
+int ibmlcdfb_init(void);
+int ibmlcdfb_setup(char *);
+
+/* ------------------- chipset specific functions -------------------------- */
+
+/* return bits per pixel in video RAM from the current par struct */
+static int
+bpp_from_par(const struct ibmlcdfb_par *par)
+{
+	int bpp;
+
+	switch (par->pixel_size) {
+	case IBMLCD_PIX_INDEXED:
+		switch (par->pixel_index_size) {
+		case IBMLCD_PAL_1BPP:
+			bpp = 1;
+			break;
+		case IBMLCD_PAL_2BPP:
+			bpp = 2;
+			break;
+		case IBMLCD_PAL_4BPP:
+			bpp = 4;
+			break;
+		case IBMLCD_PAL_8BPP:
+			bpp = 8;
+			break;
+		default:
+			bpp = 0;
+		}
+		break;
+	case IBMLCD_PIX_15BPP:	/* 15bpp and 16bpp both use 2 bytes */
+	case IBMLCD_PIX_16BPP:
+		bpp = 16;
+		break;
+	case IBMLCD_PIX_24BPP:
+		bpp = 24;
+		break;
+	case IBMLCD_PIX_32BPP:
+		bpp = 32;
+		break;
+	default:
+		bpp = 0;
+	}
+
+	return bpp;
+}
+
+/*
+ *  Fills in the 'fix' structure based on the values
+ *  in the `par' structure.
+ */
+int
+ibmlcd_encode_fix(struct fb_fix_screeninfo *fix,
+		  const void *vp, struct fb_info *inf)
+{
+	const struct ibmlcdfb_par *par = vp;
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	int bpp = bpp_from_par(par);
+
+	if (info->locality == IBMLCD_ON_CHIP)
+		strncpy(fix->id, IBMLCD_IDSTRING " (On-Chip)", 16);
+	else if (info->locality == IBMLCD_ON_BOARD_PECAN)
+		strncpy(fix->id, IBMLCD_IDSTRING " (Local)", 16);
+	else
+		strncpy(fix->id, IBMLCD_IDSTRING " (Attached How?)", 16);
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux = 0;
+	if (par->pixel_size == IBMLCD_PIX_INDEXED)
+		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fix->visual = FB_VISUAL_TRUECOLOR;
+
+	/* How many pixels can we move the screen by with simple panning? */
+	fix->xpanstep = (bpp <= 8) ? (8 / bpp) : 1;
+	fix->ypanstep = 1;
+
+	fix->line_length = par->stride;
+	fix->accel = FB_ACCEL_NONE;
+	return 0;
+}
+
+/* 0 - Basic Check okay */
+static int
+par_inited(const struct ibmlcdfb_par *par)
+{
+	return (par->magic == IBMLCD_INIT_MAGIC);
+}
+
+/* 0 - prelim check OK */
+static int
+check_for_mem(const struct ibmlcdfb_par *par, 
+	      const struct fb_fix_screeninfo *fix)
+{
+	/* Simplistic model -- allocate enough  RAM at driver load for the
+	 * highest video mode you'll want */
+	long needed_ram =
+	    par->stride * par->virt_yres + LCDC0_PIXMAP_CURSOR_SIZE;
+
+	return (needed_ram > fix->smem_len) || (needed_ram > 16 * 1024 * 1024);	/* LCDC Doc, 3.3.17 - 16MB limit */
+}
+
+/*
+ *  Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *  if it's too big, return -EINVAL.
+ *
+ *  Suggestion: Round up in the following order: bits_per_pixel, xres,
+ *  yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ *  bitfields, horizontal timing, vertical timing.
+ *
+ *  par is a new struct; no one cares what is scribbled in it if we
+ *  return an error. Otherwise, the user can use it as a sane set of
+ *  settings to switch to that are as close to var as we can get.
+ */
+static int
+ibmlcd_decode_var(const struct fb_var_screeninfo *var,
+		  struct ibmlcdfb_par *par, struct fb_info *inf)
+{	
+	const struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	unsigned int req_xres_virt, req_yres_virt;
+	int granularity, total_bits, bpp, pal_bits;
+
+	if (!par_inited(par)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: "
+		       "passed an uninitialized par\n");
+		return -EINVAL;
+	}
+
+	pal_bits = 0;
+
+	if (var->bits_per_pixel > 32) {
+		printk(KERN_WARNING "ibmlcd_decode_var: IBM LCDC Driver"
+		       " not written to support >32bpp modes.\n");
+		return -EINVAL;
+	}
+	/* These modes *should* be supported */
+	else if (var->bits_per_pixel > 24)
+		par->pixel_size = IBMLCD_PIX_32BPP;
+	else if (var->bits_per_pixel > 16)
+		par->pixel_size = IBMLCD_PIX_24BPP;
+	else if (var->bits_per_pixel > 15) {
+		par->pixel_size = IBMLCD_PIX_16BPP;
+	} else if (var->bits_per_pixel > 8) {
+		par->pixel_size = IBMLCD_PIX_15BPP;
+	} else if (var->bits_per_pixel > 4) {
+		pal_bits = 8;
+	} else if (var->bits_per_pixel > 2) {
+		pal_bits = 4;
+	} else if (var->bits_per_pixel > 1) {
+		pal_bits = 2;
+	} else {
+		pal_bits = 1;
+	}
+
+	if (pal_bits) {
+		/* We can do a palette here.  Otherwise it' no-go */
+		par->pixel_size = IBMLCD_PIX_INDEXED;
+		par->palette_enable = 1;
+		if (pal_bits == 1)
+			par->pixel_index_size = IBMLCD_PAL_1BPP;
+		else if (pal_bits == 2)
+			par->pixel_index_size = IBMLCD_PAL_2BPP;
+		else if (pal_bits == 4)
+			par->pixel_index_size = IBMLCD_PAL_4BPP;
+		else if (pal_bits == 8)
+			par->pixel_index_size = IBMLCD_PAL_8BPP;
+	} /* User requested a palettized (<=8 bpp) mode */
+	else {
+		par->palette_enable = 0;
+	}
+
+	/* Remember, these are LCDs, they can't change their resolution */
+	if ((var->xres > par->horiz_pixels) || (var->yres > par->vert_pixels)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by the LCD.\n");
+		return -EINVAL;
+	}
+
+	/* Calculate the stride with the virtual resolution they want */
+
+	/* with what granularity (in pixels) must the 
+	 *  base address register for the screen be set? */
+	granularity = bpp_from_par(par) / 8;
+	if (!granularity)	/* packed pixels */
+		granularity = 1;
+
+	/* we simply maintain our current resolution */
+	req_xres_virt = var->xres_virtual;
+	req_yres_virt = var->yres_virtual;
+	if (req_xres_virt < par->horiz_pixels)
+		req_xres_virt = par->horiz_pixels;
+	if (req_yres_virt < par->vert_pixels)
+		req_yres_virt = par->vert_pixels;
+
+	par->stride = CEIL(bpp_from_par(par) * req_xres_virt, 8);
+
+	if (par->stride > 0x1FFF) {	/* full bit pattern for the field */
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by Video RAM -- allocate more"
+		       " or use a lower bitdepth\n");
+		return -EINVAL;
+	}
+
+	par->virt_xres = (par->stride * 8) / bpp_from_par(par);
+	par->virt_yres = req_yres_virt;
+
+	if (check_for_mem(par, &info->info.fix)) {
+		/* can't possibly get that much video RAM */
+		printk(KERN_WARNING "ibmlcd_decode_var: user requested a"
+		       " video mode with a higher resolution than"
+		       " supported by Video RAM -- allocate more"
+		       " or use a lower bitdepth\n");
+		return -EINVAL;
+	}
+
+	if ((var->xoffset < 0) ||
+	    ((var->xoffset + par->horiz_pixels) > par->virt_xres)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: invalid xoffset=%d\n",
+		       var->xoffset);
+		return -EINVAL;
+	}
+	if ((var->yoffset < 0) ||
+	    ((var->yoffset + par->vert_pixels) > par->virt_yres)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: invalid yoffset=%d\n",
+		       var->yoffset);
+		return -EINVAL;
+	}
+
+	par->fb_base_address = par->LCDC_dfb_base + par->stride * var->yoffset;
+	par->fb_base_address += (var->xoffset * bpp_from_par(par)) / 8;
+
+	if (!var->grayscale && (par->LCD_panel_type == IBMLCD_MONO_STN)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: non-grayscale mode"
+		       " requested on monochrome LCD\n");
+		return -EINVAL;
+	}
+	if (var->grayscale && (par->LCD_panel_type != IBMLCD_MONO_STN)) {
+		printk(KERN_WARNING "ibmlcd_decode_var: grayscale mode"
+		       " requested on color LCD\n");
+		return -EINVAL;
+	}
+
+	/* Assumption: only length of bitfields is important.  
+	 * They will inspect a generated var to find the proper offsets. */
+	if (var->transp.length != 0) {	/* we don't support transparency */
+		printk(KERN_WARNING "ibmlcd_decode_var: alpha channel "
+		       "requested, but not supported by hardware.\n");
+		return -EINVAL;
+	}
+	total_bits = var->red.length + var->green.length + var->blue.length;
+	bpp = bpp_from_par(par);
+
+	/* Check for inconsistencies between bpp's */
+	if ((total_bits > bpp) ||
+	    ((bpp == 16) &&
+	     ((var->red.length > 5) || (var->green.length > 6)
+	      || (var->blue.length > 5))
+	    ) || (		/* 24BPP or 32BPP */
+			 ((var->red.length > 8) || (var->green.length > 8)
+			  || (var->blue.length > 8))
+	    )
+	    ) {
+		printk(KERN_WARNING "ibmlcd_decode_var: bits per pixel"
+		       " data inconsistent for requested mode.\n");
+		return -EINVAL;
+	}
+
+	par->pixels_big_endian = 1;
+
+	/* NOTE! We assume that the timings in the database are correct
+	 * for our LCD.  We ignore timing information passed by the user
+	 */
+
+	return 0;
+}
+
+/*
+ *  Fill the 'var' structure based on the values in 'par' and maybe other
+ *  values read out of the hardware.
+ */
+static int
+ibmlcd_encode_var(struct fb_var_screeninfo *var,
+		  const struct ibmlcdfb_par *par)
+{
+	int bpp;
+	__u32 fb_rel_base_address;
+	var->xres = par->horiz_pixels;
+	var->yres = par->vert_pixels;
+	var->xres_virtual = par->virt_xres;
+	var->yres_virtual = par->virt_yres;
+	var->bits_per_pixel = bpp_from_par(par);
+
+	fb_rel_base_address = par->LCDC_dfb_base;
+
+	var->xoffset = (((par->fb_base_address - fb_rel_base_address)
+			 % par->stride) * 8)
+	    / var->bits_per_pixel;
+	var->yoffset = ((par->fb_base_address - fb_rel_base_address)
+			/ par->stride);
+	var->grayscale = (par->LCD_panel_type == IBMLCD_MONO_STN);
+
+	/* Assume packing is RGB, then reverse if we find it's BGR */
+	bpp = var->bits_per_pixel;
+	/* If there's a difference between the bpp and the number of
+	 * bits actually used for color, adjust here */
+	if (bpp == 32)
+		bpp = 24;
+	if ((bpp == 16) && (par->pixel_size == IBMLCD_PIX_15BPP))
+		bpp = 15;
+
+	var->red.length = var->blue.length = bpp / 3;
+	var->green.length = bpp - 2 * var->red.length;
+	var->blue.offset = 0;
+	var->green.offset = var->blue.length;
+	var->red.offset = var->blue.length + var->green.length;
+
+	/* if actually BGR, reverse */
+	if (par->pixel_packing == IBMLCD_BGR) {
+		int i = var->red.offset;
+		var->red.offset = var->blue.offset;
+		var->blue.offset = i;
+	}
+
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+
+	var->accel_flags = FB_ACCEL_NONE;
+
+	var->left_margin = 0;
+	var->right_margin = par->total_horiz_pixels - par->horiz_pixels;
+	var->upper_margin = 0;
+	var->lower_margin = par->total_vert_pixels - par->vert_pixels;
+
+	/* physical dimensions of the screen in mm ....
+	 * as if I know... assume 72 ppi */
+	var->height = (var->yres * 254) / 720;
+	var->width = (var->xres * 254) / 720;
+
+	/* From here on out, these values are trash.  We ignore all 
+	 * information on timings besides that which is stored
+	 * in our database. */
+	var->pixclock = 40000;
+
+	/* guessing here... */
+	var->nonstd = 0;
+	var->activate = FB_ACTIVATE_NOW;
+
+	/* FIX ME: Not a clue. */
+	var->hsync_len = 1;
+	var->vsync_len = 1;
+	var->sync = 0;
+	var->vmode = 0;
+
+	return 0;
+}
+
+static int 
+ibmlcd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int err;
+
+        if ((err = ibmlcd_decode_var(var, &current_par, info)) != 0)
+                return err;
+        ibmlcd_encode_var(var, (const struct ibmlcdfb_par *) &current_par);
+	return 0;
+}
+
+/*
+ *  Fill the hardware's 'par' structure.
+ */
+
+#ifdef DEBUG_IBMLCD
+static void
+ibmlcd_hard_get_raw(struct ibmlcd_raw_dcrs *dcrs,
+		    const struct ibmlcdfb_info *info)
+{
+	dcrs->der = read_lcdc_dcri(info, LCDC0_DER);
+	dcrs->dcr = read_lcdc_dcri(info, LCDC0_DCR);
+	dcrs->dfrmr = read_lcdc_dcri(info, LCDC0_DFRMR);
+	dcrs->psr = read_lcdc_dcri(info, LCDC0_PSR);
+	dcrs->adsr = read_lcdc_dcri(info, LCDC0_ADSR);
+	dcrs->tdsr = read_lcdc_dcri(info, LCDC0_TDSR);
+	dcrs->fplcr = read_lcdc_dcri(info, LCDC0_FPLCR);
+	dcrs->fplor = read_lcdc_dcri(info, LCDC0_FPLOR);
+	dcrs->fpfcr = read_lcdc_dcri(info, LCDC0_FPFCR);
+	dcrs->fpfor = read_lcdc_dcri(info, LCDC0_FPFOR);
+	dcrs->fpscr = read_lcdc_dcri(info, LCDC0_FPSCR);
+	dcrs->fpdrcr = read_lcdc_dcri(info, LCDC0_FPDRCR);
+	dcrs->fpdacr = read_lcdc_dcri(info, LCDC0_FPDACR);
+	dcrs->misc = read_lcdc_dcri(info, LCDC0_MISC);
+	dcrs->pfr = read_lcdc_dcri(info, LCDC0_PFR);
+	dcrs->bar = read_lcdc_dcri(info, LCDC0_BAR);
+	dcrs->sr = read_lcdc_dcri(info, LCDC0_SR);
+	dcrs->cer = read_lcdc_dcri(info, LCDC0_CER);
+	dcrs->cbar = read_lcdc_dcri(info, LCDC0_CBAR);
+	dcrs->clr = read_lcdc_dcri(info, LCDC0_CLR);
+	dcrs->cc0 = read_lcdc_dcri(info, LCDC0_CC0);
+	dcrs->cc1 = read_lcdc_dcri(info, LCDC0_CC1);
+}
+
+#endif
+
+#ifdef DEBUG_IBMLCD
+static void
+ibmlcd_hard_get_par(struct ibmlcdfb_par *par, const struct ibmlcdfb_info *info)
+{
+	const struct ibmlcdfb_par *infopar
+	    = (struct ibmlcdfb_par *) (info->info.par);
+
+	/* copy the couple of things that we manage */
+	memcpy(par, infopar, sizeof (struct ibmlcdfb_par));
+
+	digest_dcr(read_lcdc_dcri(info, LCDC0_DCR), par);
+	digest_dfrmr(read_lcdc_dcri(info, LCDC0_DFRMR), par);
+	digest_psr(read_lcdc_dcri(info, LCDC0_PSR), par);
+	digest_adsr(read_lcdc_dcri(info, LCDC0_ADSR), par);
+	digest_tdsr(read_lcdc_dcri(info, LCDC0_TDSR), par);
+	digest_fplcr(read_lcdc_dcri(info, LCDC0_FPLCR), par);
+	digest_fplor(read_lcdc_dcri(info, LCDC0_FPLOR), par);
+	digest_fpfcr(read_lcdc_dcri(info, LCDC0_FPFCR), par);
+	digest_fpfor(read_lcdc_dcri(info, LCDC0_FPFOR), par);
+	digest_fpscr(read_lcdc_dcri(info, LCDC0_FPSCR), par);
+	digest_fpdrcr(read_lcdc_dcri(info, LCDC0_FPDRCR), par);
+	digest_fpdacr(read_lcdc_dcri(info, LCDC0_FPDACR), par);
+	digest_misc(read_lcdc_dcri(info, LCDC0_MISC), par);
+	digest_pfr(read_lcdc_dcri(info, LCDC0_PFR), par);
+	digest_bar(read_lcdc_dcri(info, LCDC0_BAR), par);
+	digest_sr(read_lcdc_dcri(info, LCDC0_SR), par);
+	digest_cer(read_lcdc_dcri(info, LCDC0_CER), par);
+	digest_cbar(read_lcdc_dcri(info, LCDC0_CBAR), par);
+	digest_clr(read_lcdc_dcri(info, LCDC0_CLR), par);
+	digest_cc0(read_lcdc_dcri(info, LCDC0_CC0), par);
+	digest_cc1(read_lcdc_dcri(info, LCDC0_CC1), par);
+}
+#endif
+
+/*
+ *  Set the hardware according to 'par'.
+ */
+
+static int ibmlcd_blank(int blank_mode, struct fb_info *inf);
+
+static void
+ibmlcd_hard_set_par(const struct ibmlcdfb_par *par, struct ibmlcdfb_info *info)
+{
+	printk(KERN_DEBUG "ibmlcdfb: Setting hardware par,"
+	       " turning on LCD device.\n");
+
+	/* Do honest-to-goodness DCR writes */
+	/* First, reset the thing */
+	iobarrier_rw();
+	write_lcdc_dcri(info, LCDC0_DER, 0x00000000);
+	iobarrier_rw();
+	write_lcdc_dcr(info, LCDC0_CR, 0);	/* Reset value, no interrupts */
+	write_lcdc_dcr(info, LCDC0_ICR, 0);	/* Reset value */
+
+	write_lcdc_dcri(info, LCDC0_DCR, mk_dcr(par));
+	write_lcdc_dcri(info, LCDC0_DFRMR, mk_dfrmr(par));
+	write_lcdc_dcri(info, LCDC0_PSR, mk_psr(par));
+	write_lcdc_dcri(info, LCDC0_ADSR, mk_adsr(par));
+	write_lcdc_dcri(info, LCDC0_TDSR, mk_tdsr(par));
+	write_lcdc_dcri(info, LCDC0_FPLCR, mk_fplcr(par));
+	write_lcdc_dcri(info, LCDC0_FPLOR, mk_fplor(par));
+	write_lcdc_dcri(info, LCDC0_FPFCR, mk_fpfcr(par));
+	write_lcdc_dcri(info, LCDC0_FPFOR, mk_fpfor(par));
+	write_lcdc_dcri(info, LCDC0_FPSCR, mk_fpscr(par));
+	write_lcdc_dcri(info, LCDC0_FPDRCR, mk_fpdrcr(par));
+	write_lcdc_dcri(info, LCDC0_FPDACR, mk_fpdacr(par));
+	write_lcdc_dcri(info, LCDC0_MISC, mk_misc(par));
+	write_lcdc_dcri(info, LCDC0_PFR, mk_pfr(par));
+	write_lcdc_dcri(info, LCDC0_BAR, mk_bar(par));
+	write_lcdc_dcri(info, LCDC0_SR, mk_sr(par));
+	write_lcdc_dcri(info, LCDC0_CER, mk_cer(par));
+	write_lcdc_dcri(info, LCDC0_CBAR, mk_cbar(par));
+	write_lcdc_dcri(info, LCDC0_CLR, mk_clr(par));
+	write_lcdc_dcri(info, LCDC0_CC0, mk_cc0(par));
+	write_lcdc_dcri(info, LCDC0_CC1, mk_cc1(par));
+
+	/* Now we enable the device */
+	iobarrier_rw();
+	ibmlcd_blank(0, (struct fb_info *) info);
+	iobarrier_rw();
+
+}
+
+static int
+ibmlcd_set_par(struct fb_info *info)
+{
+	const struct ibmlcdfb_par *par = info->par;
+
+	if (!par_inited(par)) {
+		printk(KERN_ERR "ibmlcd_set_par: passed an invalid par struct");
+		return -EINVAL;
+	}
+
+	ibmlcd_hard_set_par(par, (struct ibmlcdfb_info *) info);
+	return 0;
+}
+
+/*
+ *  Set a single color register. The values supplied have a 16 bit
+ *  magnitude.
+ *  Return != 0 for invalid regno.
+ */
+static int
+ibmlcd_setcolreg(unsigned regno, unsigned red, unsigned green,
+		 unsigned blue, unsigned transp, struct fb_info *inf)
+{
+	__u32 reg_value;
+	int ncolors;
+	u32 v;
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+
+	ncolors = bpp_from_par(info->info.par);
+
+	if (regno >= ncolors)
+		return -EINVAL;
+
+	if (((struct ibmlcdfb_par *) info->info.par)->pixel_size
+	    == IBMLCD_PIX_INDEXED) {
+		reg_value = mk_palent(red >> 10, green >> 10, blue >> 10);
+
+		/* Set the actual entry in the palette */
+		write_lcdc_dcri(info, LCDC0_PARn(regno), reg_value);
+	}
+
+       if (regno >= 16)
+           return 1;
+
+       red >>= (16 - info->info.var.red.length);
+       green >>= (16 - info->info.var.green.length);
+       blue >>= (16 - info->info.var.blue.length);
+
+       v = (red << info->info.var.red.offset) |
+           (green << info->info.var.green.offset) |
+           (blue << info->info.var.blue.offset) |
+           (transp << info->info.var.transp.offset);
+
+       switch (info->info.var.bits_per_pixel) {
+		case 8:
+           		((u8*)(info->info.pseudo_palette))[regno] = v;
+			break;	
+   		case 16:
+           		((u16*)(info->info.pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:	
+           		((u32*)(info->info.pseudo_palette))[regno] = v;
+			break;
+       }
+
+       return 0;
+}
+
+/*
+ *  Pan (or wrap, depending on the `vmode' field) the display using the
+ *  `xoffset' and `yoffset' fields of the `var' structure.
+ *  If the values don't fit, return -EINVAL.
+ */
+static int
+ibmlcd_pan_display(struct fb_var_screeninfo *var, int con,
+		   struct fb_info *inf)
+{
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	struct ibmlcdfb_par *par = info->info.par;
+
+	if ((var->xoffset < 0) ||
+	    ((var->xoffset + par->horiz_pixels) > par->virt_xres))
+		return -EINVAL;
+	if ((var->yoffset < 0) ||
+	    ((var->yoffset + par->vert_pixels) > par->virt_yres))
+		return -EINVAL;
+
+	par->fb_base_address = par->LCDC_dfb_base + par->stride * var->yoffset;
+	par->fb_base_address += (var->xoffset * bpp_from_par(par)) / 8;
+
+	write_lcdc_dcri(info, LCDC0_BAR, mk_bar(par));
+
+	info->info.var.xoffset = var->xoffset;
+	info->info.var.yoffset = var->yoffset;
+
+	return 0;
+}
+
+/*
+ *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL
+ *  then the caller blanks by setting the CLUT (Color Look Up Table) to all
+ *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due
+ *  to e.g. a video mode which doesn't support it. Implements VESA suspend
+ *  and powerdown modes on hardware that supports disabling hsync/vsync:
+ *    blank_mode == 2: suspend vsync
+ *    blank_mode == 3: suspend hsync
+ *    blank_mode == 4: powerdown
+ */
+static int
+ibmlcd_blank(int blank_mode, struct fb_info *inf)
+{
+	const struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+	__u32 config, enable;
+
+	printk(KERN_DEBUG "ibmlcd_blank: called with value %d", blank_mode);
+
+	config = read_lcdc_dcr(info, LCDC0_CR);
+	enable = read_lcdc_dcri(info, LCDC0_DER);
+
+	if (blank_mode == 0) {
+
+		/* User wants to unblank (turn on) the display.  We set the
+		   Pixel clock frequency, power up the controller, and enable
+		   the display. */
+
+		printk(", unblanking the display\n");
+		{
+			const struct ibmlcdfb_par *infopar
+			    = (struct ibmlcdfb_par *) (info->info.par);
+
+			if (ibm405lp_set_pixclk(infopar->pixclk_min,
+						infopar->pixclk_max)) {
+				printk(KERN_ERR "ibmlcd: "
+				       "Pixel clock frequency request "
+				       "(%d, %d) failed.\n",
+				       infopar->pixclk_min,
+				       infopar->pixclk_max);
+				return -EINVAL;
+			}
+		}
+		write_lcdc_dcr(info, LCDC0_CR, config & (~IBMLCD_POWER_OFF));
+		write_lcdc_dcri(info, LCDC0_DER, enable | 0x1);
+
+	} else {
+
+		/* User wants to blank (turn off) the display.  We disable the
+		   display, power it off, and set the pixel clock to its
+		   minimum frequency. */
+
+		printk(", blanking the display\n");
+
+		write_lcdc_dcri(info, LCDC0_DER, enable & (~0x1));
+		write_lcdc_dcr(info, LCDC0_CR, config | IBMLCD_POWER_OFF);
+
+		if (ibm405lp_set_pixclk(0, 0)) {
+			printk(KERN_ERR "ibmlcd: "
+			       "Pixel clock frequency request "
+			       "(%d, %d) failed.\n", 0, 0);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+
+static void
+ibmlcd_set_disp(const void *par, struct display *disp, struct fb_info *inf)
+{
+#ifdef FBCON_HAS_CFB8
+	if (bpp_from_par(par) == 8) {
+		disp->dispsw = &fbcon_cfb8;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB16
+	if (bpp_from_par(par) == 16) {
+		disp->dispsw = &fbcon_cfb16;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB24
+	if (bpp_from_par(par) == 24) {
+		disp->dispsw = &fbcon_cfb24;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+#ifdef FBCON_HAS_CFB32
+	if (bpp_from_par(par) == 32) {
+		disp->dispsw = &fbcon_cfb32;
+		disp->dispsw_data = inf->pseudo_palette;
+	} else
+#endif
+	{
+		disp->dispsw = &fbcon_dummy;
+	}
+
+	disp->can_soft_blank = 0;
+	disp->var = inf->var;
+}
+
+/*
+  The default cursor pixmap
+
+  0 - black         LCDC0_PIXMAP_CUR_COLOR0
+  1 - white         LCDC0_PIXMAP_CUR_COLOR1
+  2 - transparent   LCDC0_PIXMAP_CUR_TRANSP
+  3 - xor           LCDC0_PIXMAP_CUR_XOR
+ */
+static __u32 dcursor[256] = {
+	0x5AAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x46AAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x41AAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x406AAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x401AAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4006AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4001AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x40006AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x40001AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x400556AA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4106AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x4641AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0x5A41AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAB06AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAB06AAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAA5AAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA,
+	0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA, 0xAAAAAAAA
+};
+
+/*
+  Given a set of pixels, copy it into our
+  available cursor image format
+ */
+static void
+ibmlcd_set_default_cursor(struct ibmlcdfb_par *par, struct ibmlcdfb_info *info)
+{
+	unsigned char *cursor = par->LCDC_vcursor_base;
+	par->cc0r = par->cc0g = par->cc0b = 0;
+	par->cc1r = par->cc1g = par->cc1b = 63;
+
+	memcpy(cursor, dcursor, LCDC0_PIXMAP_CURSOR_SIZE);
+	write_lcdc_dcri(info, LCDC0_CBAR, mk_cbar(par));
+	write_lcdc_dcri(info, LCDC0_CC0, mk_cc0(par));
+	write_lcdc_dcri(info, LCDC0_CC1, mk_cc1(par));
+}
+
+static int
+ibmlcd_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	     unsigned long arg, int console, struct fb_info *inf)
+{
+	struct ibmlcdfb_info *info = (struct ibmlcdfb_info *) inf;
+
+	down(&info->sem);
+
+	switch (cmd) {
+#ifdef DEBUG_IBMLCD
+
+	case FBIO_GETHW_PAR:
+		{
+			struct ibmlcdfb_par par;
+			ibmlcd_hard_get_par(&par, info);
+			up(&info->sem);
+			return copy_to_user((void *) arg, &par,
+					    sizeof (par)) ? -EFAULT : 0;
+		}
+		break;
+/*	case FBIO_SETHW_PAR: */
+	case FBIO_GETRAW_HW:
+		{
+			struct ibmlcd_raw_dcrs raw;
+			ibmlcd_hard_get_raw(&raw, info);
+			up(&info->sem);
+			return copy_to_user((void *) arg, &raw,
+					    sizeof (raw)) ? -EFAULT : 0;
+		}
+		break;
+	case FBIO_GETLOCALE:
+		up(&info->sem);
+		return info->locality;
+#endif
+	case FBIOGET_FCURSORINFO:
+		{
+			struct fb_fix_cursorinfo curs;
+			curs.crsr_xsize = 64;
+			curs.crsr_ysize = 64;
+			curs.crsr_width = 64;
+			curs.crsr_height = 64;
+			curs.crsr_color1 = 0;
+			/* FIXME - find closest color in the cmap */
+			curs.crsr_color2 = 0;
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs,
+					    sizeof (struct fb_fix_cursorinfo));
+		} break;
+	case FBIOGET_VCURSORINFO:
+		{
+			struct fb_var_cursorinfo curs;
+			curs.width = 64;
+			curs.height = 64;
+			curs.xspot = 0;
+			curs.yspot = 0;
+			curs.data[0] = 0;
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs,
+					    sizeof (struct fb_var_cursorinfo));
+		} break;
+	case FBIOPUT_VCURSORINFO:
+		{
+			/* struct fb_var_cursorinfo * curs = (struct fb_var_cursorinfo*)arg; */
+			up(&info->sem);
+			return -EINVAL;
+		}
+		break;
+	case FBIOGET_CURSORSTATE:
+		{
+			struct fb_cursorstate curs;
+			struct ibmlcdfb_par par;
+
+			digest_cer(read_lcdc_dcri(info, LCDC0_CER), &par);
+			digest_clr(read_lcdc_dcri(info, LCDC0_CLR), &par);
+
+			if (par.cursor_enable) {
+				curs.mode = FB_CURSOR_ON;
+			} else {
+				curs.mode = FB_CURSOR_OFF;
+			}
+
+			curs.xoffset = par.cursor_x;
+			curs.yoffset = par.cursor_y;
+
+			up(&info->sem);
+			return copy_to_user((void *) arg, &curs, sizeof (curs));
+		}
+		break;
+	case FBIOPUT_CURSORSTATE:
+		{
+			struct fb_cursorstate *curs
+			    = (struct fb_cursorstate *) arg;
+			struct ibmlcdfb_par par;
+
+			if ((par.cursor_x != curs->xoffset) ||
+			    (par.cursor_y != curs->yoffset) ||
+			    ((par.cursor_enable != 0) !=
+			     (curs->mode != FB_CURSOR_OFF))) {
+
+				/* Change state of LCD */
+				if (curs->mode == FB_CURSOR_ON) {
+					par.cursor_enable = 1;
+				} else {
+					par.cursor_enable = 0;
+				}
+
+				par.cursor_x = curs->xoffset;
+				par.cursor_y = curs->yoffset;
+
+				write_lcdc_dcri(info, LCDC0_CER, mk_cer(&par));
+				write_lcdc_dcri(info, LCDC0_CLR, mk_clr(&par));
+			} else {
+				/* No changium */
+			}
+			up(&info->sem);
+			return 0;
+		}
+		break;
+	default:
+		break;
+	}
+	up(&info->sem);
+	return -EINVAL;
+}
+
+/* ------------ Hardware Independent Functions ------------ */
+
+static struct fb_ops ibmlcdfb_ops = {
+	.owner          = THIS_MODULE,
+	.fb_set_var     = gen_set_var,
+	.fb_get_cmap    = gen_get_cmap,
+	.fb_set_cmap    = gen_set_cmap,
+	.fb_check_var   = ibmlcd_check_var,
+	.fb_set_par     = ibmlcd_set_par,
+	.fb_setcolreg   = ibmlcd_setcolreg,
+	.fb_blank       = ibmlcd_blank,
+	.fb_pan_display = ibmlcd_pan_display,
+	.fb_ioctl       = ibmlcd_ioctl,
+};
+
+static void
+ibmlcdfb_free_video_memory(struct ibmlcdfb_par *par)
+{
+	int i;
+	struct page *page;
+
+	page = virt_to_page(__va(par->LCDC_dfb_base));
+
+	for(i = 0; i < par->num_fb_pages; i++)
+		mem_map_unreserve(page+i);
+
+	consistent_free(par->LCDC_vfb_orig);
+}
+
+/* 
+ * ibmlcdfb_map_video_memory(par, params):
+ *
+ *      Allocates the DRAM memory for the frame buffer.  This buffer is  
+ *	remapped into a non-cached, non-buffered, memory region to  
+ *      allow palette and pixel writes to occur without flushing the 
+ *      cache.  Once this area is remapped, all virtual memory
+ *      access to the video memory should occur at the new region.
+ *                  ( Blatantly ripped from sa1100fb.c )
+ *      Responsible for setting up:
+ *         par->LCDC_vfb_orig
+ *         par->LCDC_dfb_base
+ *         par->num_fb_pages
+ *         par->LCDC_vfb_base 
+ *
+ * NB: Framebuffer *must* be in __GFP_DMA memory to take advantage of advanced
+ * memory power management options for 405 platforms.
+ */
+static int
+    __init
+ibmlcdfb_map_video_memory(struct ibmlcdfb_par *par, struct lcd_params *params)
+{
+	u_int order;
+	struct page *page;
+	void *allocated_region;
+	int i;
+
+	/* Find order required to allocate enough memory for framebuffer, and
+	   the number of extra pages. */
+
+	par->num_fb_pages = CEIL(params->mem_length, PAGE_SIZE);
+	order = get_order(par->num_fb_pages * PAGE_SIZE);
+
+	if (!(allocated_region =
+	      consistent_alloc(GFP_KERNEL | __GFP_DMA,
+			       (1 << (order + PAGE_SHIFT)),
+			       &par->LCDC_dfb_base))) {
+		printk(KERN_ERR "ibmlcdfb: Error from consistent_alloc()"
+		       " for framebuffer memory\n");
+		return -ENOMEM;
+	}
+
+	par->LCDC_vfb_base = allocated_region;
+	par->LCDC_vfb_orig = allocated_region;
+
+	printk(KERN_INFO
+	       "ibmlcdfb: FB 0x%08lx bytes at 0x%08lx (0x%08lx -> 0x%08lx)\n",
+	       par->num_fb_pages * PAGE_SIZE,
+	       (unsigned long) par->LCDC_vfb_base,
+	       (unsigned long) par->LCDC_dfb_base,
+	       (unsigned long) par->LCDC_vfb_orig);
+
+        /* Set reserved flag for fb memory to allow it to be remapped into */
+        /* user space by the common fbmem driver using remap_page_range(). */
+
+	page = virt_to_page(__va(par->LCDC_dfb_base));
+
+	for(i = 0; i < par->num_fb_pages; i++)
+		mem_map_reserve(page+i);
+
+	return 0;
+}
+
+static int __init
+ibmlcd_add(void)
+{
+	struct lcd_params *params = &lcd_params;
+	struct ibmlcdfb_info *fbinfo;
+	int ret = 0;
+
+	if (params->mem_location != 0xFFFFFFFF) {
+		printk(KERN_ERR "ibmlcdfb: User settable video RAM locations"
+		       " not yet supported.\n");
+		return -EINVAL;
+	}
+
+	fbinfo = kmalloc(sizeof (*fbinfo), GFP_KERNEL);
+	if (!fbinfo) {
+		ret = -ENOMEM;
+		goto err_out0;
+	}
+	memset(fbinfo, 0, sizeof (*fbinfo));
+
+	fbinfo->info.par = &current_par;
+	memcpy(&current_par, params->par, sizeof (struct ibmlcdfb_par));
+
+	fbinfo->info.disp = &disp;
+	// memset(fbinfo->info.disp, 0, sizeof (struct display));
+
+	/* fixup the par */
+
+	if ((ret = ibmlcdfb_map_video_memory(&current_par, params)) != 0)
+		goto err_out3;
+
+	current_par.virt_xres = current_par.horiz_pixels;
+	current_par.virt_yres = current_par.vert_pixels;
+
+	fbinfo->info.fix.smem_start = current_par.LCDC_dfb_base;
+	fbinfo->info.fix.smem_len = current_par.num_fb_pages << PAGE_SHIFT;
+
+	/* fix.smem_* need be set before check_for_mem */
+	if (check_for_mem(&current_par, 
+			  (const struct fb_fix_screeninfo *)&fbinfo->info.fix)) {
+		printk(KERN_WARNING "ibmlcdfb: Too little memory specified"
+		       " for resolution of LCD\n");
+		goto err_out4;
+	}
+
+	current_par.LCDC_vcursor_base = current_par.LCDC_vfb_base + 
+		(current_par.num_fb_pages << PAGE_SHIFT)
+		- LCDC0_PIXMAP_CURSOR_SIZE;
+
+	current_par.LCDC_dcursor_base =
+	    current_par.cursor_base_address =
+	    current_par.LCDC_dfb_base + 
+		(current_par.num_fb_pages << PAGE_SHIFT)
+		- LCDC0_PIXMAP_CURSOR_SIZE;
+
+	current_par.fb_base_address = current_par.LCDC_dfb_base;
+
+	/* initialize those structures */
+	fbinfo->locality = IBMLCD_ON_CHIP;
+	fbinfo->LCDC_pdcr_base = 0;	/* we don't use pseudo-DCRs */
+	strncpy(fbinfo->info.modename, ibmlcd_config_name(params->par), 40);
+
+	fbinfo->info.flags = FBINFO_FLAG_DEFAULT;
+	fbinfo->info.open = 0;
+
+	fbinfo->info.fbops = &ibmlcdfb_ops;
+	fbinfo->info.changevar = NULL;
+	fbinfo->info.currcon = -1;
+	fbinfo->info.node = NODEV;
+	fbinfo->info.pseudo_palette = pseudo_palette;
+
+	fbinfo->info.switch_con = gen_switch;
+	fbinfo->info.updatevar = gen_update_var;
+	fbinfo->info.screen_base = current_par.LCDC_vfb_base;
+
+	current_par.magic = IBMLCD_INIT_MAGIC;
+
+	ibmlcd_encode_var(&fbinfo->info.var, &current_par);
+	memcpy(&fbinfo->info.disp->var, &fbinfo->info.var,
+	       sizeof (struct fb_var_screeninfo));
+
+	/* for System on a Chip, it's done through DCRs */
+	fbinfo->info.fix.mmio_start = 0;
+	fbinfo->info.fix.mmio_len = 0;
+	ibmlcd_encode_fix(&fbinfo->info.fix, &current_par, 
+			  (struct fb_info *) fbinfo);
+
+	/* This should give a reasonable default video mode */
+
+	ibmlcd_set_par((struct fb_info *) fbinfo);
+	strcpy(fbinfo->info.fontname, "VGA8x8");
+
+	// FIXME: I ripped off cmap_len == 256 from other files.
+
+	fb_alloc_cmap(&fbinfo->info.cmap, 256, 0);
+
+#if 1 /* Eventually should be able to call gen_set_disp instead. */
+	ibmlcd_set_disp(&current_par, &disp, &fbinfo->info);
+#else
+	gen_set_disp(-1, &fbinfo->info);
+#endif
+
+	ibmlcd_set_default_cursor(&current_par, fbinfo);
+
+	init_MUTEX(&fbinfo->sem);
+
+	/* black out the screen */
+	memset(current_par.LCDC_vfb_base, 0, current_par.stride * 
+	       current_par.virt_yres);
+
+	if ((ret = register_framebuffer(&fbinfo->info)) < 0) {
+		printk(KERN_ERR "ibmlcdfb: Error registering"
+		       " framebuffer device\n");
+		goto err_out5;
+	}
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+	       GET_FB_IDX(fbinfo->info.node), fbinfo->info.modename);
+
+	down(&fb_list_sem);
+	list_add(&(fbinfo->list), &fb_list);
+	up(&fb_list_sem);
+
+	return 0;
+      err_out5:
+	/* shut the LCDC off */
+	write_lcdc_dcri(fbinfo, LCDC0_DER, 0x00000000);
+	write_lcdc_dcr(fbinfo, LCDC0_CR, 0);
+	/* Reset value, no interrupts */
+	write_lcdc_dcr(fbinfo, LCDC0_ICR, 0);	/* Reset value */
+
+      err_out4:
+	/* free mem area */
+	ibmlcdfb_free_video_memory(&current_par);
+      err_out3:
+	kfree(fbinfo);
+      err_out0:
+	if (ret == -ENOMEM) {
+		printk(KERN_ERR
+		       "ibmlcdfb: Could not allocate auxilury fb structs\n");
+	}
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+
+/*
+ *  Initialization
+ *
+ *  Command-line parameters are not needed for Beech (Pass 2 +), as an FPGA
+ *  register holds a switch setting indicating which panel is installed.
+ */
+
+static int setup_called = 0;
+
+int __init
+ibmlcdfb_init(void)
+{
+	INIT_LIST_HEAD(&fb_list);
+	init_MUTEX(&fb_list_sem);
+
+	if (!lcd_params.par) {
+#if defined(CONFIG_BEECH)
+		volatile u8 *beech_fpga_reg_0;
+
+		beech_fpga_reg_0 = (volatile u8 *)
+			ioremap(BEECH_FPGA_REG_0_PADDR, BEECH_FPGA_REG_0_SIZE);
+
+		if (beech_fpga_reg_0 == NULL) {
+			printk(KERN_ERR 
+			       "ibmlcdfb: ioremap of FPGA reg 0 at 0x%x failed.\n",
+			       BEECH_FPGA_REG_0_PADDR);
+			return -EINVAL;
+		}
+
+		if (*beech_fpga_reg_0 & FPGA_REG_0_HITA_TOSH_N)
+			lcd_params.par =
+			    ibmlcd_config_matching("HitachiQVGA-STN");
+		else
+			lcd_params.par =
+			    ibmlcd_config_matching("ToshibaVGA-TFT");
+
+		iounmap((void *) beech_fpga_reg_0);
+#endif
+	}
+
+	if (!setup_called) {
+		lcd_params.mem_length = DEFAULT_FB_MEM;
+		lcd_params.mem_location = 0xFFFFFFFF;
+	}
+
+	if (lcd_params.par) {
+		if (ibmlcd_add())
+			printk(KERN_WARNING "ibmlcdfb: Error initializing"
+			       " LCDC core\n");
+		else
+			printk(KERN_INFO "ibmlcdfb: LCDC initialized\n");
+	} else {
+		printk(KERN_ERR "ibmlcdfb: Error - No Panel Selected\n");
+	}
+
+	return 0;
+}
+
+/*
+ *  Setup
+ *
+ *  The IBM Liquid Crystal Display Core is available in two configurations.
+ *  (1) System On A Chip - where the LCDC is on chip in a PowerPC derivate
+ *  (2) On Board - in the FPGA of the Pecan Board
+ *
+ *  These options are deprecated as command-line options.
+ *
+ *  This code is only called if a video=ibmlcdfb: option is given.  If not, a
+ *  default panel will be selected in ibmlcdfb_init above.
+ */
+
+int __init
+ibmlcdfb_setup(char *options)
+{
+	char *this_opt;
+	char *nextopt = options;
+	struct lcd_params *params = &lcd_params;
+
+	setup_called = 1;
+
+	params->par = NULL;
+	params->mem_length = DEFAULT_FB_MEM;
+	params->mem_location = 0xFFFFFFFF;
+
+	printk(KERN_INFO "ibmlcdfb: Parsing options: %s\n", options);
+
+	if (options && *options) {
+		for (this_opt = strsep(&nextopt, ","); this_opt;
+		     this_opt = strsep(&nextopt, ",")) {
+
+			if (!*this_opt)
+				continue;
+
+				/* Assume it's the LCD name */
+			params->par = ibmlcd_config_matching(this_opt);
+			if (!params->par)
+				printk(KERN_WARNING "ibmlcdfb: %s is"
+				       " not a known LCD.  Add a"
+				       " profile to"
+				       " ibmlcds.c\n", this_opt);
+		}
+	}
+	return 0;
+}
+
+#undef CEIL
+
+/* ------------------------------------------------------------------------- */
+
+    /*
+     *  Modularization
+     */
+
+    /*
+     *  Cleanup
+     */
+
+#ifdef MODULE
+
+static void __devexit
+ibmlcd_deconfigure(void)
+{
+	struct list_head *p;
+	struct ibmlcdfb_info *fbinfo;
+	struct ibmlcdfb_par *par;
+
+	down(&fb_list_sem);
+	list_for_each(p, &fb_list) {
+		fbinfo = list_entry(p, struct ibmlcdfb_info, list);
+		par = (struct ibmlcdfb_par *) fbinfo->info.par;
+
+		/* FIXME: handle -EBUSY */
+		unregister_framebuffer((struct fb_info *) fbinfo);
+		/* shut the LCDC off */
+		write_lcdc_dcri(fbinfo, LCDC0_DER, 0x00000000);
+		write_lcdc_dcr(fbinfo, LCDC0_CR, 0);
+		/* Reset value, no interrupts */
+		write_lcdc_dcr(fbinfo, LCDC0_ICR, 0);	/* Reset value */
+
+		if (par->LCDC_vfb_base)
+			iounmap(par->LCDC_vfb_base);
+		ibmlcdfb_free_video_memory(par);
+		kfree(fbinfo->info.disp);
+		kfree(fbinfo->info.par);
+		list_del(&fbinfo->list);
+		kfree(fbinfo);
+	}
+	up(&fb_list_sem);
+}
+
+static void
+ibmlcdfb_cleanup(struct fb_info *inf)
+{
+	ibmlcd_deconfigure();
+}
+
+int
+init_module(void)
+{
+	return ibmlcdfb_init();
+}
+
+void
+cleanup_module(void)
+{
+	ibmlcdfb_cleanup(void);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("(c) 2001 David T Eger <dteger@cc.gatech.edu>");
+MODULE_DESCRIPTION("IBM Liquid Crystal Display Controller driver");
+
+#endif				/* MODULE */
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -purN /dev/shm/linux-2.5/drivers/video/macmodes.c linuxppc-2.5-benh/drivers/video/macmodes.c
--- /dev/shm/linux-2.5/drivers/video/macmodes.c	2002-10-29 20:05:45.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/macmodes.c	2003-11-19 08:33:00.000000000 +0000
@@ -19,6 +19,7 @@
 #include <linux/errno.h>
 #include <linux/fb.h>
 #include <linux/string.h>
+#include <linux/module.h>
 
 #include "macmodes.h"
 
@@ -281,6 +282,7 @@ int mac_vmode_to_var(int vmode, int cmod
     var->vmode = mode->vmode;
     return 0;
 }
+EXPORT_SYMBOL(mac_vmode_to_var);
 
 
 /**
@@ -326,6 +328,7 @@ int mac_var_to_vmode(const struct fb_var
     }
     return -EINVAL;
 }
+EXPORT_SYMBOL(mac_var_to_vmode);
 
 
 /**
@@ -348,6 +351,7 @@ int mac_map_monitor_sense(int sense)
 	    break;
     return map->vmode;
 }
+EXPORT_SYMBOL(mac_map_monitor_sense);
 
 
 /**
@@ -384,3 +388,4 @@ int __init mac_find_mode(struct fb_var_s
     return fb_find_mode(var, info, mode_option, db, dbsize,
 			&mac_modedb[DEFAULT_MODEDB_INDEX], default_bpp);
 }
+EXPORT_SYMBOL(mac_find_mode);
diff -purN /dev/shm/linux-2.5/drivers/video/offb.c linuxppc-2.5-benh/drivers/video/offb.c
--- /dev/shm/linux-2.5/drivers/video/offb.c	2003-04-24 10:30:41.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/offb.c	2003-12-24 07:15:03.000000000 +0000
@@ -151,20 +151,20 @@ static int offb_setcolreg(u_int regno, u
 		break;
 	}
 
-	if (regno < 16)
+	if (regno < 16) {
+		u32 *pal = info->pseudo_palette;
+		unsigned int i;
+
 		switch (info->var.bits_per_pixel) {
 		case 16:
-			((u16 *) (info->pseudo_palette))[regno] =
-			    (regno << 10) | (regno << 5) | regno;
+			pal[regno] = (regno << 10) | (regno << 5) | regno;
 			break;
 		case 32:
-			{
-				int i = (regno << 8) | regno;
-				((u32 *) (info->pseudo_palette))[regno] =
-				    (i << 16) | i;
-				break;
-			}
+			i = (regno << 8) | regno;
+			pal[regno] = (i << 16) | i;
+			break;
 		}
+	}
 	return 0;
 }
 
diff -purN /dev/shm/linux-2.5/drivers/video/radeonfb.c linuxppc-2.5-benh/drivers/video/radeonfb.c
--- /dev/shm/linux-2.5/drivers/video/radeonfb.c	2004-01-21 17:48:54.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/radeonfb.c	2004-01-29 05:09:38.000000000 +0000
@@ -924,7 +924,7 @@ static void radeon_get_moninfo (struct r
 		return;
 	}
 
-	tmp = INREG(RADEON_BIOS_4_SCRATCH);
+	tmp = INREG(BIOS_4_SCRATCH);
 	printk(KERN_DEBUG "radeon_get_moninfo: bios 4 scratch = %x\n", tmp);
 	
 	if (rinfo->hasCRTC2) {
diff -purN /dev/shm/linux-2.5/drivers/video/riva/fbdev.c linuxppc-2.5-benh/drivers/video/riva/fbdev.c
--- /dev/shm/linux-2.5/drivers/video/riva/fbdev.c	2004-02-04 05:29:30.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/riva/fbdev.c	2004-02-05 10:07:36.000000000 +0000
@@ -52,6 +52,11 @@
 #error This driver requires PCI support.
 #endif
 
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+
 /* version number of this driver */
 #define RIVAFB_VERSION "0.9.5b"
 
@@ -285,7 +290,6 @@ MODULE_DEVICE_TABLE(pci, rivafb_pci_tbl)
  * ------------------------------------------------------------------------- */
 
 /* command line data, set in rivafb_setup() */
-static u32 pseudo_palette[17];
 static int flatpanel __initdata = -1; /* Autodetect later */
 static int forceCRTC __initdata = -1;
 #ifdef CONFIG_MTRR
@@ -348,6 +352,94 @@ static const struct riva_regs reg_templa
 	0xEB							/* MISC */
 };
 
+/*
+ * Here is some specific support for the eMac machine
+ * 
+ * This machine is "special" because of it's ivad2 display
+ * controller and fixed horizontal timing requirements.
+ * 
+ * Right now, all I do is to set a fixed working 1024x768
+ * mode at boot (I also have a 1280x960 at hand, if you
+ * prefer...).
+ * 
+ * I expect to do things better in a future 2.5 version
+ * though.
+ * 
+ * I also turn off the screen during blanking using IVAD
+ * i2c accesses, that's the basis we can use to later
+ * implement full IVAD support (geometry setting,
+ * brightness, ...).
+ */
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_ADB_PMU)
+
+static int ivad_iic_addr = -1;
+
+/* Default mode for eMac */
+static struct fb_var_screeninfo emac_default_var = {
+	xres:		1024,
+	yres:		768,
+	xres_virtual:	1024,
+	yres_virtual:	768,
+	xoffset:	0,
+	yoffset:	0,
+	bits_per_pixel:	8,
+	grayscale:	0,
+	red:		{0, 6, 0},
+	green:		{0, 6, 0},
+	blue:		{0, 6, 0},
+	transp:		{0, 0, 0},
+	nonstd:		0,
+	activate:	0,
+	height:		-1,
+	width:		-1,
+	accel_flags:	0,
+	pixclock:	10081,
+	left_margin:	208,
+	right_margin:	48,
+	upper_margin:	31,
+	lower_margin:	1,
+	hsync_len:	96,
+	vsync_len:	3,
+	sync:		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	vmode:		FB_VMODE_NONINTERLACED
+};
+
+static void
+init_ivad(void)
+{
+	if (machine_is_compatible("PowerMac4,4")) {
+		struct device_node* np = find_devices("ivad2");
+		unsigned int* prop;
+		
+		if (np == NULL)
+			return;
+		prop = (unsigned int*)get_property(np, "iic-address", NULL);
+		if (np == NULL) {
+			printk(KERN_INFO "IVAD2 has no iic-address property !\n");
+			return;
+		}
+		ivad_iic_addr = *prop;
+		printk(KERN_INFO "Found IVAD2, iic address is: 0x%02x\n", ivad_iic_addr);
+		rivafb_default_var = emac_default_var;
+	}
+}
+
+#define IVAD_CONTRAST_REG	0x00
+
+static void set_ivad_contrast(u8 contrast)
+{
+	int rc;
+
+	if (ivad_iic_addr < 0)
+		return;
+	rc = pmu_i2c_stdsub_write(PMU_I2C_BUS_POWER, ivad_iic_addr,
+				  IVAD_CONTRAST_REG, &contrast, 1);
+	if (rc < 0)
+		printk(KERN_ERR "IVAD2: Can't set contrast !\n");
+}
+
+#endif /* defined(CONFIG_PPC_PMAC) && defined(CONFIG_ADB_PMU) */
+
 /* ------------------------------------------------------------------------- *
  *
  * MMIO access macros
@@ -929,6 +1021,7 @@ static int rivafb_do_maximize(struct fb_
 /* acceleration routines */
 inline void wait_for_idle(struct riva_par *par)
 {
+	mb();
 	while (par->riva.Busy(&par->riva));
 }
 
@@ -1196,7 +1289,14 @@ static int rivafb_blank(int blank, struc
 			vesa |= 0xc0;
 			break;
 		}
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_ADB_PMU)
+		set_ivad_contrast(0);
+#endif
 	}
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_ADB_PMU)
+	else
+		set_ivad_contrast(0xff);
+#endif
 	SEQout(par, 0x01, tmp);
 	CRTCout(par, 0x1a, vesa);
 	return 0;
@@ -1227,6 +1327,7 @@ static int rivafb_setcolreg(unsigned reg
 {
 	struct riva_par *par = (struct riva_par *)info->par;
 	RIVA_HW_INST *chip = &par->riva;
+	u32 *pal = info->pseudo_palette;
 	int i;
 
 	if (regno >= riva_get_cmap_len(&info->var))
@@ -1247,7 +1348,7 @@ static int rivafb_setcolreg(unsigned reg
 		if (info->var.green.length == 5) {
 			if (regno < 16) {
 				/* 0rrrrrgg gggbbbbb */
-				((u32 *)info->pseudo_palette)[regno] =
+				pal[regno] =
 					((red & 0xf800) >> 1) |
 					((green & 0xf800) >> 6) |
 					((blue & 0xf800) >> 11);
@@ -1260,7 +1361,7 @@ static int rivafb_setcolreg(unsigned reg
 
 			if (regno < 16) {
 				/* rrrrrggg gggbbbbb */
-				((u32 *)info->pseudo_palette)[regno] =
+				pal[regno] =
 					((red & 0xf800) >> 0) |
 					((green & 0xf800) >> 5) |
 					((blue & 0xf800) >> 11);
@@ -1279,7 +1380,7 @@ static int rivafb_setcolreg(unsigned reg
 		break;
 	case 32:
 		if (regno < 16) {
-			((u32 *)info->pseudo_palette)[regno] =
+			pal[regno] =
 				((red & 0xff00) << 8) |
 				((green & 0xff00)) | ((blue & 0xff00) >> 8);
 			
@@ -1589,7 +1690,7 @@ static int __devinit riva_set_fbinfo(str
 	info->var = rivafb_default_var;
 	info->fix = rivafb_fix;
 	info->fbops = &riva_fb_ops;
-	info->pseudo_palette = pseudo_palette;
+	info->pseudo_palette = par->pseudo_palette;
 
 #ifndef MODULE
 	if (mode_option)
@@ -1615,15 +1716,28 @@ static int riva_get_EDID_OF(struct riva_
 {
 	struct device_node *dp;
 	unsigned char *pedid = NULL;
+	unsigned char *disptype = NULL;
+	static char *propnames[] = {
+		"DFP,EDID", "LCD,EDID", "EDID", "EDID1", "EDID,B", "EDID,A", NULL };
+	int i;  
 
 	dp = pci_device_to_OF_node(pd);
-	pedid = (unsigned char *)get_property(dp, "EDID,B", 0);
-
-	if (pedid) {
-		par->EDID = pedid;
-		return 1;
-	} else
-		return 0;
+	for (; dp != NULL; dp = dp->child) {
+		disptype = (unsigned char *)get_property(dp, "display-type", NULL);
+		if (disptype == NULL)
+			continue;
+		if (strncmp(disptype, "LCD", 3) != 0)
+			continue;
+		for (i = 0; propnames[i] != NULL; ++i) {
+			pedid = (unsigned char *)
+				get_property(dp, propnames[i], NULL);
+			if (pedid != NULL) {
+				par->EDID = pedid;
+				return 1;
+			}
+		}
+	}
+	return 0;
 }
 #endif /* CONFIG_PPC_OF */
 
@@ -1704,7 +1818,8 @@ static void riva_update_default_var(stru
 static void riva_get_EDID(struct fb_info *info, struct pci_dev *pdev)
 {
 #ifdef CONFIG_PPC_OF
-	if (!riva_get_EDID_OF(info, pdev))
+	struct riva_par *par = (struct riva_par *) info->par;
+	if (!riva_get_EDID_OF(par, pdev))
 		printk("rivafb: could not retrieve EDID from OF\n");
 #else
 	/* XXX use other methods later */
@@ -1997,10 +2112,11 @@ static struct pci_driver rivafb_driver =
 
 int __init rivafb_init(void)
 {
-	if (pci_register_driver(&rivafb_driver) > 0)
-		return 0;
-	pci_unregister_driver(&rivafb_driver);
-	return -ENODEV;
+	pci_register_driver(&rivafb_driver);
+#if defined(CONFIG_PPC_PMAC) && defined(CONFIG_ADB_PMU)
+       	init_ivad();
+#endif
+	return 0;
 }
 
 
diff -purN /dev/shm/linux-2.5/drivers/video/riva/nv_driver.c linuxppc-2.5-benh/drivers/video/riva/nv_driver.c
--- /dev/shm/linux-2.5/drivers/video/riva/nv_driver.c	2003-02-16 18:36:47.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/riva/nv_driver.c	2003-11-17 01:25:43.000000000 +0000
@@ -337,6 +337,11 @@ riva_common_setup(struct riva_par *par)
 	case 0x01F0:
 	case 0x0250:
 	case 0x0280:
+	case 0x0300:
+	case 0x0310:
+	case 0x0320:
+	case 0x0330:
+	case 0x0340:
 		riva_is_second(par);
 		break;
 	default:
diff -purN /dev/shm/linux-2.5/drivers/video/riva/riva_hw.c linuxppc-2.5-benh/drivers/video/riva/riva_hw.c
--- /dev/shm/linux-2.5/drivers/video/riva/riva_hw.c	2003-01-06 22:40:01.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/riva/riva_hw.c	2003-11-17 01:25:43.000000000 +0000
@@ -2061,7 +2061,8 @@ static void nv10GetConfig
 
 #ifdef __BIG_ENDIAN
     /* turn on big endian register access */
-    chip->PMC[0x00000004/4] = 0x01000001;
+    if(!(chip->PMC[0x00000004/4] & 0x01000001))
+        chip->PMC[0x00000004/4] = 0x01000001;
 #endif
 
     /*
@@ -2122,6 +2123,11 @@ static void nv10GetConfig
     case 0x01F0:
     case 0x0250:
     case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
        if(chip->PEXTDEV[0x0000/4] & (1 << 22))
            chip->CrystalFreqKHz = 27000;
        break;
@@ -2153,6 +2159,11 @@ static void nv10GetConfig
     case 0x01F0:
     case 0x0250:
     case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
         chip->twoHeads = TRUE;
         break;
     default:
diff -purN /dev/shm/linux-2.5/drivers/video/riva/riva_hw.h linuxppc-2.5-benh/drivers/video/riva/riva_hw.h
--- /dev/shm/linux-2.5/drivers/video/riva/riva_hw.h	2002-12-18 00:11:53.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/riva/riva_hw.h	2003-11-28 01:35:53.000000000 +0000
@@ -537,10 +537,18 @@ int RivaGetConfig(RIVA_HW_INST *, unsign
  * FIFO Free Count. Should attempt to yield processor if RIVA is busy.
  */
 
+/*
+ * The mb()'s work around some lockup problems I experienced with some
+ * GeForceII MX cards, neither I nor Mark Vojkovich knows for sure what's
+ * going on there. --BenH
+ */ 
 #define RIVA_FIFO_FREE(hwinst,hwptr,cnt)                            \
 {                                                                   \
-    while ((hwinst).FifoFreeCount < (cnt))                          \
+    while ((hwinst).FifoFreeCount < (cnt)) {                        \
+    	mb();                                                       \
+    	mb();	                                                    \
         (hwinst).FifoFreeCount = (hwinst).hwptr->FifoFree >> 2;     \
+    }                                                               \
     (hwinst).FifoFreeCount -= (cnt);                                \
 }
 #endif /* __RIVA_HW_H__ */
diff -purN /dev/shm/linux-2.5/drivers/video/riva/rivafb.h linuxppc-2.5-benh/drivers/video/riva/rivafb.h
--- /dev/shm/linux-2.5/drivers/video/riva/rivafb.h	2003-02-16 18:36:48.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/riva/rivafb.h	2003-12-24 07:15:03.000000000 +0000
@@ -49,6 +49,7 @@ struct riva_par {
 	int forceCRTC;
 	Bool SecondCRTC;
 	int FlatPanel;
+	u32 pseudo_palette[17];
 #ifdef CONFIG_MTRR
 	struct { int vram; int vram_valid; } mtrr;
 #endif
diff -purN /dev/shm/linux-2.5/drivers/video/valkyriefb.c linuxppc-2.5-benh/drivers/video/valkyriefb.c
--- /dev/shm/linux-2.5/drivers/video/valkyriefb.c	2003-05-19 00:58:52.000000000 +0000
+++ linuxppc-2.5-benh/drivers/video/valkyriefb.c	2003-08-17 12:16:00.000000000 +0000
@@ -63,6 +63,7 @@
 #include <asm/macintosh.h>
 #else
 #include <asm/prom.h>
+#include <asm/of_device.h>
 #endif
 #include <asm/pgtable.h>
 
@@ -313,42 +314,14 @@ static void __init valkyrie_choose_mode(
 	       default_vmode, default_cmode);
 }
 
-int __init valkyriefb_init(void)
+static int __devinit valkyriefb_fb_init(
+		struct device *dev,
+		unsigned long frame_buffer_phys,
+		unsigned long cmap_regs_phys, unsigned long flags)
 {
 	struct fb_info_valkyrie	*p;
-	unsigned long frame_buffer_phys, cmap_regs_phys, flags;
 	int err;
 
-#ifdef CONFIG_MAC
-	if (!MACH_IS_MAC)
-		return 0;
-	if (!(mac_bi_data.id == MAC_MODEL_Q630
-	      /* I'm not sure about this one */
-	    || mac_bi_data.id == MAC_MODEL_P588))
-		return 0;
-
-	/* Hardcoded addresses... welcome to 68k Macintosh country :-) */
-	frame_buffer_phys = 0xf9000000;
-	cmap_regs_phys = 0x50f24000;
-	flags = IOMAP_NOCACHE_SER; /* IOMAP_WRITETHROUGH?? */
-#else /* ppc (!CONFIG_MAC) */
-	struct device_node *dp;
-
-	dp = find_devices("valkyrie");
-	if (dp == 0)
-		return 0;
-
-	if (dp->n_addrs != 1) {
-		printk(KERN_ERR "expecting 1 address for valkyrie (got %d)\n",
-		       dp->n_addrs);
-		return 0;
-	}
-
-	frame_buffer_phys = dp->addrs[0].address;
-	cmap_regs_phys = dp->addrs[0].address+0x304000;
-	flags = _PAGE_WRITETHRU;
-#endif /* ppc (!CONFIG_MAC) */
-
 	p = kmalloc(sizeof(*p), GFP_ATOMIC);
 	if (p == 0)
 		return -ENOMEM;
@@ -359,6 +332,8 @@ int __init valkyriefb_init(void)
 		kfree(p);
 		return 0;
 	}
+	if (dev)
+		dev_set_drvdata(dev, p);
 	p->total_vram = 0x100000;
 	p->frame_buffer_phys = frame_buffer_phys;
 	p->frame_buffer = __ioremap(frame_buffer_phys, p->total_vram, flags);
@@ -388,6 +363,8 @@ int __init valkyriefb_init(void)
 	return 0;
 
  out_free:
+	if (dev)
+		dev_set_drvdata(dev, NULL);
 	if (p->frame_buffer)
 		iounmap(p->frame_buffer);
 	if (p->cmap_regs)
@@ -581,3 +558,90 @@ int __init valkyriefb_setup(char *option
 }
 
 MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("framebuffer driver for Apple Platinum video");
+
+#ifdef CONFIG_MAC
+int __init valkyriefb_init(void)
+{
+	unsigned long frame_buffer_phys, cmap_regs_phys, flags;
+
+	if (!MACH_IS_MAC)
+		return 0;
+	if (!(mac_bi_data.id == MAC_MODEL_Q630
+	      /* I'm not sure about this one */
+	    || mac_bi_data.id == MAC_MODEL_P588))
+		return 0;
+
+	/* Hardcoded addresses... welcome to 68k Macintosh country :-) */
+	return valkyriefb_fb_init(NULL, 0xf9000000, 0x50f24000, IOMAP_NOCACHE_SER);
+}
+#else  /* CONFIG_MAC */
+
+static int __devinit valkyriefb_probe(struct of_device* odev, const struct of_match *match)
+{
+	if (odev->node->n_addrs != 1) {
+		printk(KERN_ERR "expecting 1 address for valkyrie (got %d)\n",
+		       odev->node->n_addrs);
+		return -ENXIO;
+	}
+
+	return valkyriefb_fb_init(&odev->dev, odev->node->addrs[0].address,
+		odev->node->addrs[0].address+0x304000, _PAGE_WRITETHRU);
+}
+
+static int __devexit valkyriefb_remove(struct of_device* odev)
+{
+	struct fb_info_valkyrie	*p = dev_get_drvdata(&odev->dev);
+
+	if (!p)
+		return 0;
+
+        unregister_framebuffer (&p->info);
+	
+	release_mem_region(p->frame_buffer_phys, 0x100000);
+	iounmap((void *)p->frame_buffer);
+	iounmap((void *)p->cmap_regs);
+	iounmap((void *)p->valkyrie_regs);
+
+	kfree(p);
+
+	return 0;
+}
+
+static struct of_match valkyriefb_match[] = 
+{
+	{
+	.name 		= "valkyrie",
+	.type		= OF_ANY_MATCH,
+	.compatible	= OF_ANY_MATCH,
+	},
+	{},
+};
+
+static struct of_platform_driver valkyrie_driver = 
+{
+	.name 		= "valkyriefb",
+	.match_table	= valkyriefb_match,
+	.probe		= valkyriefb_probe,
+	.remove		= valkyriefb_remove,
+};
+
+int __init valkyriefb_init(void)
+{
+	of_register_driver(&valkyrie_driver);
+
+	return 0;
+}
+
+void __exit valkyriefb_exit(void)
+{
+	of_unregister_driver(&valkyrie_driver);	
+}
+
+#ifdef MODULE
+module_init(valkyriefb_init);
+module_exit(valkyriefb_exit);
+#endif
+
+#endif /* (else) CONFIG_MAC */
+
diff -purN /dev/shm/linux-2.5/fs/Kconfig linuxppc-2.5-benh/fs/Kconfig
--- /dev/shm/linux-2.5/fs/Kconfig	2003-12-29 21:37:29.000000000 +0000
+++ linuxppc-2.5-benh/fs/Kconfig	2003-12-31 04:25:18.000000000 +0000
@@ -963,6 +963,19 @@ config HFS_FS
 	  To compile this file system support as a module, choose M here: the
 	  module will be called hfs.
 
+config HFSPLUS_FS
+	tristate "Apple Extended HFS file system support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select NLS
+	help
+	  If you say Y here, you will be able to mount extended format
+	  Macintosh-formatted hard drive partitions with full read-write access.
+
+	  This file system is often called HFS+ and was introduced with
+	  MacOS 8. It includes all Mac specific filesystem data such as
+	  data forks and creator codes, but it also has several UNIX
+	  style features such as file ownership and permissions.
+
 config BEFS_FS
 	tristate "BeOS file systemv(BeFS) support (read only) (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff -purN /dev/shm/linux-2.5/fs/Makefile linuxppc-2.5-benh/fs/Makefile
--- /dev/shm/linux-2.5/fs/Makefile	2004-02-04 05:37:17.000000000 +0000
+++ linuxppc-2.5-benh/fs/Makefile	2004-02-05 10:07:36.000000000 +0000
@@ -62,6 +62,7 @@ obj-$(CONFIG_VFAT_FS)		+= vfat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_DEVFS_FS)		+= devfs/
+obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
 obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_VXFS_FS)		+= freevxfs/
 obj-$(CONFIG_NFS_FS)		+= nfs/
diff -purN /dev/shm/linux-2.5/fs/hfs/HFS.txt linuxppc-2.5-benh/fs/hfs/HFS.txt
--- /dev/shm/linux-2.5/fs/hfs/HFS.txt	2002-02-05 17:39:38.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/HFS.txt	2003-12-24 03:48:17.000000000 +0000
@@ -14,29 +14,19 @@
 
   2.      Mounting HFS Filesystems
 
-  2.1.    afpd
+  2.1.    creator=cccc
 
-  2.2.    case={asis, lower}
+  2.2.    gid=n
 
-  2.3.    conv={auto, binary, text}
+  2.3.    part=n
 
-  2.4.    creator=cccc
+  2.4.    quiet
 
-  2.5.    fork={cap, double, netatalk}
+  2.5.   type=cccc
 
-  2.6.    gid=n
+  2.6.   uid=n
 
-  2.7.    names={7bit, 8bit, alpha, cap, latin, netatalk, trivial}
-
-  2.8.    part=n
-
-  2.9.    quiet
-
-  2.10.   type=cccc
-
-  2.11.   uid=n
-
-  2.12.   umask=n
+  2.7.   umask=n
 
   3.      Writing to HFS Filesystems
 
@@ -105,346 +95,21 @@
   (case, conv, fork and names) can be abbreviated by their first
   character.
 
-  22..11..  aaffppdd
-
-  If included in the options, then the behavior of the filesystem is
-  changed to make it fully read-write compatible with Netatalk's afpd.
-  In this mode you should not use normal user-level tools to modify the
-  filesystem, though reading from it is acceptable.  This is because the
-  return codes from some system calls are changed to fool afpd.  These
-  changes will confuse many user-level tools.  In particular ``rm -r''
-  will loop forever.
-
-  This option implies fork=netatalk, which in turn implies
-  names=netatalk.  If either of these options are explicitly set to
-  something else they will take precedence and will confuse afpd.  The
-  quiet option has no effect.  The case= option functions normally, but
-  afpd usually does the same thing for you.  The conv= and part= options
-  also function normally.
-
-  You will probably want to use the uid=, gid= and umask= mount options.
-  Note that because all the files on an HFS filesystem belong to a
-  single user and group and have a single umask, the full AppleShare
-  permission scheme will not work through Netatalk.
-
-  One additional limitation is that the Desktop database on the disk is
-  stored in afpd's format and is separate from any existing database
-  maintained by the Finder when the volume is used on a Macintosh.
-  Because of this mounting an HFS CDROM across the network to a
-  Macintosh may result in applications and documents showing up with
-  default application and document icons.  Additionally double clicking
-  on a document will fail to start the correct application.  Both of
-  these problems can be worked around by copying the application to a
-  local disk on the Macintosh.
-
-  This mode is known to be compatible with afpd from Netatalk versions
-  1.4b1 and 1.4b2, and known to be incompatible with the afpd from
-  version 1.3.3.  As of this writing Netatalk version 1.4 has not yet
-  been released.  However, it is expected that this mode will be
-  compatible with afpd from Netatalk version 1.4 when it is released.
-
-  22..22..  ccaassee=={{aassiiss,, lloowweerr}}
-
-  default value: asis
-
-  This option determines if Macintosh filenames are presented in their
-  original case or in all lowercase.  Filename lookup is always case
-  insensitive, so either way foo and Foo refer to the same file but ls
-  will list Foo with case=asis, and foo with case=lower.  (Same as for
-  the HPFS filesystem.)
-
-     aassiiss
-        Filenames are reported in the case they were created with.
-
-     lloowweerr
-        Filenames are reported in lowercase.
-
-  22..33..  ccoonnvv=={{aauuttoo,, bbiinnaarryy,, tteexxtt}}
-
-  default value: binary
-
-  This option controls CR<->NL conversion of Macintosh _d_a_t_a _f_o_r_k_s.  Any
-  translation takes place only for files accessed with the read() and
-  write() system calls (either directly or through the stdio functions).
-  Access through mmap() is unaffected.  (Similar to the conv= option for
-  the MS-DOS filesystem.)
-
-     aauuttoo
-        If the Finder's type for a file is TEXT or ttro, then CR
-        characters are converted to NL characters when read, and NL
-        characters are converted to CR characters when written.
-
-        Be warned that some Macintosh applications create files with
-        type TEXT even though the contents is clearly binary.
-
-     bbiinnaarryy
-        No CR<->NL conversion is done.
-
-     tteexxtt
-        In all data forks, regardless of the Finder's type for the file,
-        CR characters are converted to NL characters when read, and NL
-        characters are converted to CR characters when written.
-
-  22..44..  ccrreeaattoorr==cccccccc
+  22..11..  ccrreeaattoorr==cccccccc
 
   default value: ``????''
 
   Specifies the 4-character string specifying the Finder's Creator for
   new files.
 
-  22..55..  ffoorrkk=={{ccaapp,, ddoouubbllee,, nneettaattaallkk}}
-
-  default value: cap
-
-  This option determines how resource forks and the Finder's metadata
-  are represented within the structure of the Linux filesystem.
-
-     ccaapp
-        The scheme used by the Columbia AppleTalk Package's AUFS.
-
-        Associated with each directory are two special directories and a
-        metadata file.  The directory ./bar is represented by:
-
-        ..//bbaarr
-           The directory itself, containing subdirectories, the data
-           forks of files, and the following two special directories.
-
-        ..//bbaarr//..rreessoouurrccee
-           A special directory holding resource forks of the files in
-           ./bar.
-
-        ..//bbaarr//..ffiinnddeerriinnffoo
-           A special directory holding metadata files for the files and
-           subdirectories in ./bar.
-
-        ..//..ffiinnddeerriinnffoo//bbaarr
-           The metadata file for the directory ./bar.
-
-        The files in a directory are represented as three files:
-
-        ..//ffoooo
-           The data fork of the file ./foo.
-
-        ..//..rreessoouurrccee//ffoooo
-           The resource fork of the file ./foo.
-
-        ..//..ffiinnddeerriinnffoo//ffoooo
-           The metadata file for the file ./foo.
-
-        Additionally, the file .rootinfo in the root directory of the
-        HFS filesystem is a metadata file for the root directory.
-
-        Brief documentation on the format of file containing the
-        Finder's metadata is included in the section ``A Guide to
-        Special File Formats'' in this document.  More detailed
-        information is available in the Columbia AppleTalk Package.
-
-     ddoouubbllee
-        The ``AppleDouble'' format recommended by Apple.  (Apple's other
-        recommended format, ``AppleSingle'', is not yet implemented.)
-
-        Associated with each directory is an AppleDouble ``header
-        file''.  The directory ./bar is represented by:
-
-        ..//bbaarr
-           The directory itself, containing subdirectories, the data
-           forks for files, and the header files for files and
-           subdirectories.
-
-        ..//%%bbaarr
-           The header file for the directory ./bar, containing the
-           Finder's metadata for the directory.
-
-        The files in a directory are represented as two files:
-
-        ..//ffoooo
-           The data fork of the file ./foo.
-
-        ..//%%ffoooo
-           The header file for the file ./foo, containing the resource
-           fork and the Finder's metadata for the file.
-
-        Additionally, the file %RootInfo in the root directory of the
-        HFS filesystem is a header file for the root directory.  This is
-        not quite the %RootInfo file referred to in the AppleDouble
-        specification.
-
-        The header files used in this scheme are version 2 AppleDouble
-        header files.  Their format is described briefly in the section
-        ``A Guide to Special File Formats'' in this document.  They are
-        documented in detail in ``AppleSingle/AppleDouble Formats:
-        Developer's Note (9/94)'', available from Apple's Developer
-        Services Page <http://devworld.apple.com>.
-
-        Note that the naming convention for the header file can cause
-        name conflicts.  For instance, using Apple's 7-bit ASCII name
-        conversion (see the names mount option) the name %Desktop could
-        be interpreted either as the header file for the file Desktop or
-        as the file with 0xDE as the hexadecimal representation of its
-        first character, and "sktop" as the remaining 5 characters.  The
-        problem arises when both files exist, since only one will be
-        accessible.  The behavior of the HFS filesystem in the case of
-        such a conflict is undefined, and may change in future releases.
-        (If this causes problems for you, please don't report it as a
-        bug; I didn't design this ``standard'', Apple did.)
-
-     nneettaattaallkk
-        The scheme used by the Netatalk afpd.
-
-        Associated with each directory is a special directory and a
-        metadata file.  The directory ./bar is represented by:
-
-        ..//bbaarr
-           The directory itself, containing subdirectories, the data
-           forks of files, and the following special directory.
-
-        ..//bbaarr//..AApppplleeDDoouubbllee
-           A special directory holding AppleDouble header files for
-           ./bar and the files it contains, but not for the
-           subdirectories it contains.
-
-        ..//bbaarr//..AApppplleeDDoouubbllee//..PPaarreenntt
-           The header file for the directory ./bar, containing the
-           Finder's metadata for the directory.
-
-        The files in a directory are represented as two files:
-
-        ..//ffoooo
-           The data fork of the file ./foo.
-
-        ..//..AApppplleeDDoouubbllee//ffoooo
-           The header file for file ./foo, containing the resource fork
-           and the Finder's metadata.
-
-        The header files used in this scheme are version 1 AppleDouble
-        header files.  They are described briefly in the section ``A
-        Guide to Special File Formats'' in this document.  The format is
-        documented in detail in the ``Apple II File Type Notes'' under
-        the type ``$E0.0002/$E0.0003-AppleDouble'', and in Appendix B of
-        the ``A/UX Toolbox: Macintosh ROM Interface'' manual.
-
-  22..66..  ggiidd==nn
+  22..22..  ggiidd==nn
 
   default value: gid of the mounting process
 
   Specifies the group that owns all files and directories on the
   filesystem.  (Same as for the MS-DOS and HPFS filesystems.)
 
-  22..77..  nnaammeess=={{77bbiitt,, 88bbiitt,, aallpphhaa,, ccaapp,, llaattiinn,, nneettaattaallkk,, ttrriivviiaall}}
-
-  default value: varies as follows
-
-  +o  If the fork option is set to double, then names defaults to alpha.
-
-  +o  If the fork option is set to netatalk, then names defaults to
-     netatalk.
-
-  +o  If the fork option is set to cap (or has taken that value by
-     default), then names defaults to cap.
-
-  This option determines how to convert between valid Macintosh
-  filenames and valid Linux filenames.  The 7bit, 8bit and alpha options
-  correspond to Apple's recommended conventions named ``7-bit ASCII'',
-  ``8-bit'' and ``7-bit alphanumeric''.
-
-     77bbiitt
-        When converting from Macintosh filenames to Linux filenames the
-        NULL (0x00), slash (/) and percent (%) characters and the
-        extended 8-bit characters (hexadecimal codes 0x80-0xff) are
-        replaced by a percent character (%) followed by the two-digit
-        hexadecimal code for the character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string "%YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the string "%YZ" is unchanged.  A
-        colon (:) is replaced by a pipe character (|).
-
-     88bbiitt
-        When converting from Macintosh filenames to Linux filenames the
-        NULL (0x00), slash (/) and percent (%) characters are replaced
-        by a percent character (%) followed by the two-digit hexadecimal
-        code for the character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string "%YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the string "%YZ" is unchanged.  A
-        colon (:) is replaced by a pipe character (|).
-
-     aallpphhaa
-        When converting from Macintosh filenames to Linux filenames only
-        the alphanumeric characters (a-z, A-Z and 0-9), the underscore
-        (_) and the last period (.) in the filename are unchanged.  The
-        remaining characters are replaced by a percent character (%)
-        followed by the two-digit hexadecimal code for the character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string "%YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the string "%YZ" is unchanged.  A
-        colon (:) is replaced by a pipe character (|).
-
-     ccaapp
-        The convention used by the Columbia AppleTalk Package's AUFS.
-
-        When converting from Macintosh filenames to Linux filenames the
-        characters from space ( ) through tilde (~) (ASCII 32-126) are
-        unchanged, with the exception of slash (/).  The slash (/) and
-        all characters outside the range 32-126 are replaced by a colon
-        (:) followed by the two-digit hexadecimal code for the
-        character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string ":YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the colon is replaced by a pipe
-        character (|).
-
-     llaattiinn
-        When converting from Macintosh filenames to Linux filenames the
-        characters from space ( ) through tilde (~) (ASCII 32-126) are
-        unchanged, with the exception of slash (/) and percent (%).  The
-        extended 8-bit Macintosh characters with equivalents in the
-        Latin-1 character set are replaced by those equivalents.  The
-        remaining characters are replaced by a percent character (%)
-        followed by the two-digit hexadecimal code for the character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string "%YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the string "%YZ" is unchanged. The
-        Latin-1 characters with equivalents in the extended 8-bit
-        Macintosh character set are replaced by those equivalents.  A
-        colon (:) is replaced by a pipe character (|).
-
-        Thanks to Holger Schemel (aeglos@valinor.owl.de) for
-        contributing this conversion mode.
-
-     nneettaattaallkk
-        The convention used by the Netatalk afpd.
-
-        When converting from Macintosh filenames to Linux filenames the
-        characters from space ( ) through tilde (~) (ASCII 32-126) are
-        unchanged, with the exception of slash (/) and any initial
-        period (.).  The slash (/) and any initial period (.)  and all
-        characters outside the range 32-126 are replaced by a colon (:)
-        followed by the two-digit hexadecimal code for the character.
-
-        When converting from Linux filenames to Macintosh filenames the
-        string ":YZ" is replaced by the character with hexadecimal code
-        0xYZ.  If 0xYZ is not a valid hexadecimal number or is the code
-        for NULL or colon (:) then the colon is replaced by a pipe
-        character (|).
-
-     ttrriivviiaall
-        When converting from Macintosh filenames to Linux filenames a
-        slash character (/) is replaced by a colon (:).
-
-        When converting from Linux filenames to Macintosh filenames a
-        colon (:) is replaced by a slash character (/).
-
-  22..88..  ppaarrtt==nn
+  22..33..  ppaarrtt==nn
 
   default value: 0
 
@@ -457,27 +122,27 @@
 
   Note that in versions before 0.8.3 partitions were numbered from 1.
 
-  22..99..  qquuiieett
+  22..44..  qquuiieett
 
   If included in the options, then chown and chmod operations will not
   return errors, but will instead fail silently.  (Same as for the MS-
   DOS and HPFS filesystems.)
 
-  22..1100..  ttyyppee==cccccccc
+  22..550.  ttyyppee==cccccccc
 
   default value: ``????''
 
   Specifies the 4-character string specifying the Finder's Type for new
   files.
 
-  22..1111..  uuiidd==nn
+  22..66..  uuiidd==nn
 
   default value: uid of the mounting process
 
   Specifies the user that owns all files and directories on the
   filesystem.  (Same as for the MS-DOS and HPFS filesystems.)
 
-  22..1122..  uummaasskk==nn
+  22..77..  uummaasskk==nn
 
   default value: umask of the mounting process
 
@@ -522,391 +187,6 @@
 
   +o  You can't create symlinks, device files, sockets or FIFOs.
 
-  33..11..  WWrriittiinngg wwiitthh ffoorrkk==ccaapp
-
-  Unlike the other schemes for representing forked files, the CAP scheme
-  presents the resource fork as an independent file; the resource fork
-  of ./foo is ./.resource/foo.  Therefore, you can treat it as a normal
-  file.  You can do anything to a resource fork that you can do to a
-  data fork, except that you cannot enable execute permissions on a
-  resource fork.  Therefore, resource forks are not suitable for holding
-  Linux executables or shared libraries.
-
-  If you plan to use the resource fork on a Macintosh then you must obey
-  the format of a valid resource fork.  This format is documented in
-  Chapter 1 of Apple's _I_n_s_i_d_e _M_a_c_i_n_t_o_s_h_: _M_o_r_e _M_a_c_i_n_t_o_s_h _T_o_o_l_b_o_x.  The
-  filesystem knows nothing about this format and so does nothing to
-  enforce it.
-
-  The current support for reading and writing is sufficient to allow
-  copying of entire directories with tar, as long as both the source and
-  destination are mounted with fork=cap.  tar may complain about being
-  unable to change the uid, gid or mode of files.  This is normal and is
-  an unavoidable side effect of the having a single uid, gid and umask
-  for the entire filesystem.
-
-  It is impossible to create a resource fork or a Finder metadata file.
-  However, they are created automatically when the data fork is created.
-  Therefore, if you wish to copy a single file including both forks and
-  the Finder's metadata then you must create the data fork first.  Then
-  you can copy the resource fork and the Finder's metadata.  For
-  instance to copy the file foo to dir/bar you should do the following:
-
-  1. cp foo dir/bar
-
-  2. cp .resource/foo dir/.resource/bar
-
-  3. cp .finderinfo/foo dir/.finderinfo/bar
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  If you wish to move foo to dir/bar and foo and dir are on the same
-  filesystem then you only need to execute ``mv foo dir/bar'' and the
-  resource fork and the Finder's metadata will move too.  However, if
-  foo and dir are on different filesystem then this will lose the
-  resource fork and metadata.  Therefore, it is safest to always move
-  files as follows:
-
-  1. cp foo dir/bar
-
-  2. cp .resource/foo dir/.resource/bar
-
-  3. cp .finderinfo/foo dir/.finderinfo/bar
-
-  4. rm foo
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  Directories have no resource fork but you may wish to create a
-  directory which has the same location and view on the Finder's screen
-  as an existing one.  This can be done by copying the Finder metadata
-  file.  To give the directory bar the same location, layout, creation
-  date and modify date as foo you simply execute ``cp .finderinfo/foo
-  .finderinfo/bar''.
-
-  When copying an entire directory with ``cp -R'' you may also wish to
-  copy the metadata for the directory:
-
-  1. cp -R foo bar
-
-  2. cp .finderinfo/foo .finderinfo/bar
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.
-
-  33..22..  WWrriittiinngg wwiitthh ffoorrkk==ddoouubbllee
-
-  The current support for reading and writing header files is sufficient
-  to allow copying of entire directories with tar, as long as both the
-  source and destination are mounted with fork=double.  tar may complain
-  about being unable to change the uid, gid or mode of files.  This is
-  normal and is an unavoidable side effect of the having a single uid,
-  gid and umask for the entire filesystem.
-
-  It is impossible to create a header file.  However, they are created
-  automatically when the data fork is created.  Therefore, if you wish
-  to copy a single file including both forks and the Finder's metadata
-  then you must create the data fork first.  Then you can copy the
-  header file.  instance to copy the file foo to dir/bar you should do
-  the following:
-
-  1. cp foo dir/bar
-
-  2. cp %foo dir/%bar
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  If you wish to move foo to dir/bar and foo and dir are on the same
-  filesystem then you only need to execute ``mv foo dir/bar'' and the
-  header file will move too.  However, if foo and dir are on different
-  filesystem then this will lose the header file.  Therefore, it is
-  safest to always move files as follows:
-
-  1. cp foo dir/bar
-
-  2. cp %foo dir/%bar
-
-  3. rm foo
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  Directories have no resource fork but you may wish to create a
-  directory which has the same location and view on the Finder's screen
-  as an existing one.  This can be done by copying the corresponding
-  header file.  To give the directory bar the same location, layout,
-  creation date and modify date as foo simply execute ``cp %foo %bar''.
-
-  When copying an entire directory with ``cp -R'' you may also wish to
-  copy the header file for the directory as well:
-
-  1. cp -R foo bar
-
-  2. cp %foo %bar
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.
-
-  33..33..  WWrriittiinngg wwiitthh ffoorrkk==nneettaattaallkk
-
-  The current support for reading and writing header files is sufficient
-  to allow copying of entire directories with tar, as long as both the
-  source and destination are mounted fork=netatalk.  tar may complain
-  about being unable to change the uid, gid or mode of files.  This is
-  normal and is an unavoidable side effect of the having a single uid,
-  gid and umask for the entire filesystem.
-
-  It is impossible to create a header file.  However, they are created
-  automatically when the data fork is created.  Therefore, if you wish
-  to copy a single file including both forks and the Finder's metadata
-  then you must create the data fork first.  Then you can copy the
-  header file.  instance to copy the file foo to dir/bar you should do
-  the following:
-
-  1. cp foo dir/bar
-
-  2. cp .AppleDouble/foo dir/.AppleDouble/bar
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  If you wish to move foo to dir/bar and foo and dir are on the same
-  filesystem then you only need to execute ``mv foo dir/bar'' and the
-  header file will move too.  However, if foo and dir are on different
-  filesystem then this will lose the header file.  Therefore, it is
-  safest to always move files as follows:
-
-  1. cp foo dir/bar
-
-  2. cp .AppleDouble/foo dir/.AppleDouble/bar
-
-  3. rm foo
-
-  You may get ``Operation not permitted'' errors from cp when it tries
-  to change the permissions on files.  These errors can safely be
-  ignored.  This method will work even if the file dir/bar exists.
-
-  Directories have no resource fork but you may wish to create a
-  directory which has the same location and view on the Finder's screen
-  as an existing one.  This can be done by copying the corresponding
-  header file.  To give the directory bar the same location, layout,
-  creation date and modify date as foo you simply execute ``cp
-  foo/.AppleDouble/.Parent bar/.AppleDouble/.Parent''.
-
-  Because the fork=netatalk scheme holds the header file for a directory
-  within that directory, directories can safely be copied with ``cp -R
-  foo bar'' with no loss of information.  However, you may get
-  ``Operation not permitted'' errors from cp when it tries to change the
-  permissions on files.  These errors can safely be ignored.
-
-  44..  AA GGuuiiddee ttoo SSppeecciiaall FFiillee FFoorrmmaattss
-
-  Each of the values of the fork mount option yields different special
-  files to represent the Macintosh-specific parts of a file within the
-  structure of the Linux filesystem.  You can write to these special
-  files to change things such as the Creator and Type of a file.
-  However, to do so safely you must follow certain rules to avoid
-  corrupting the data.  Additionally, there are certain fields in the
-  special files that you can't change (writes to them will fail
-  silently).
-
-  44..11..  CCAAPP ..ffiinnddeerriinnffoo FFiilleess
-
-  The Finder's metadata for the file ./foo in held in the file
-  ./.finderinfo/foo.  The file has a fixed format defined in hfs_fs.h as
-  follows:
-
-       ______________________________________________________________________
-       struct hfs_cap_info {
-               __u8    fi_fndr[32];            /* Finder's info */
-               __u16   fi_attr;                /* AFP attributes */
-               __u8    fi_magic1;              /* Magic number: */
-       #define HFS_CAP_MAGIC1          0xFF
-               __u8    fi_version;             /* Version of this structure: */
-       #define HFS_CAP_VERSION         0x10
-               __u8    fi_magic;               /* Another magic number: */
-       #define HFS_CAP_MAGIC           0xDA
-               __u8    fi_bitmap;              /* Bitmap of which names are valid: */
-       #define HFS_CAP_SHORTNAME       0x01
-       #define HFS_CAP_LONGNAME        0x02
-               __u8    fi_shortfilename[12+1]; /* "short name" (unused) */
-               __u8    fi_macfilename[32+1];   /* Original (Macintosh) name */
-               __u8    fi_comln;               /* Length of comment (always 0) */
-               __u8    fi_comnt[200];          /* Finder comment (unused) */
-               /* optional:    used by aufs only if compiled with USE_MAC_DATES */
-               __u8    fi_datemagic;           /* Magic number for dates extension: */
-       #define HFS_CAP_DMAGIC          0xDA
-               __u8    fi_datevalid;           /* Bitmap of which dates are valid: */
-       #define HFS_CAP_MDATE           0x01
-       #define HFS_CAP_CDATE           0x02
-               __u8    fi_ctime[4];            /* Creation date (in AFP format) */
-               __u8    fi_mtime[4];            /* Modify date (in AFP format) */
-               __u8    fi_utime[4];            /* Un*x time of last mtime change */
-       };
-       ______________________________________________________________________
-
-  The type __u8 is an unsigned character, and __u16 is an unsigned
-  16-bit integer.
-
-  Currently only the fields fi_fndr, fi_attr, fi_ctime and fi_mtime can
-  be changed.  Writes to the other fields are silently ignored.
-  However, you shouldn't write random bytes to the other fields, since
-  they may be writable in the future.
-
-  The fi_fndr field is the ``Finder info'' and ``Extended Finder info''
-  for a file or directory.  These structures are described in various
-  books on Macintosh programming.  The portion of the most interest is
-  probably the first 8 bytes which, for a file, give the 4-byte Type
-  followed by the 4-byte Creator.
-
-  The fi_attr field is the AFP attributes of the file or directory.
-  While you can write any value to this field, only the ``write-
-  inhibit'' bit is significant.  Setting or clearing this bit will clear
-  or set the write bits in the file's permissions.  When you read from
-  this field anything you may have written is lost.  If the file has
-  write permissions enabled then you will read zero from this field.
-  With write permission disabled you will read back 0x01 0xA0, which
-  corresponds to setting the ``write-inhibit'', ``rename-inhibit'' and
-  ``delete-inhibit'' bits.
-
-  The fi_ctime and fi_mtime are the Macintosh created and modified time
-  for the file or directory, and are 32-bit signed integers in network
-  byteorder giving seconds from 00:00 GMT Jan. 1, 2000.
-
-  44..22..  AApppplleeDDoouubbllee HHeeaaddeerr FFiilleess
-
-  Both the fork=double and fork=netatalk schemes for representing forked
-  files use AppleDouble header files to contain the resource fork and
-  the Finder's metadata together in a single file.
-
-  The AppleDouble format specifies a fixed-format header which describes
-  which fields are contained in the remainder of the file, where they
-  are located in the file and how long they are.  A full description of
-  the version 1 format used when fork=netatalk is available from ??????.
-  The version 2 format used when fork=double is documented in ??????.
-  The discussion that follows assumes you have read and understood these
-  documents, which may be difficult until I've replaced the ``??????''s
-  above with something more informative :-).
-
-  Due to the variable structure of an AppleDouble header file you must
-  not use buffered I/O when reading or writing them; you should only use
-  the read() and write() system calls.  It is also important that you
-  make some effort to coordinate processes that are reading and writing
-  the same header file, since a reader will receive the wrong data if
-  the location of a given entry has changed since it read the descriptor
-  for the entry.  If a process tries to read the descriptor table while
-  it is changing then it is possible to read totally meaningless data.
-
-  When a header file is opened it is initially presented with a default
-  header layout.  You may write to the header to change the layout, but
-  when all file descriptors for the file or directory have been closed
-  the change in format is lost and subsequent opens will yield the
-  default layout.  Changes to supported entries are made directly to the
-  filesystem and are thus preserved when the file is closed and
-  reopened.
-
-  The HFS filesystem currently uses a fixed-size table to hold the
-  descriptors.  Therefore you are limited to HFS_HDR_MAX (currently 10)
-  descriptors.  In the unlikely event that you try to write a header
-  with more descriptors, a warning will be issued by the kernel, and
-  extra descriptors will be ignored.  This should be considered a bug
-  and will hopefully change sooner rather than later.
-
-  The results of specifying overlapping entries is undefined and should
-  not be relied upon to remain unchanged from one version of the HFS
-  filesystem to the next.  There is no valid reason to define
-  overlapping entries, so just don't do it!
-
-  Changes to the magic number and version fields are preserved until all
-  file descriptors are closed, however the only significance given to
-  them internally is that the 16 bytes following the version changes
-  meaning according to the version.  For version 1 header files these 16
-  bytes contain the string ``Macintosh'' followed by 7 spaces.  For any
-  other value of the version field these 16 bytes are all zeros.  In
-  either case writes to these 16 bytes are silently ignored.
-
-  Since the magic number and version are given no other significance
-  internally, you are free to do many things that violate the official
-  formats.  For instance you can create an entry for the data fork in a
-  header file with an AppleDouble magic number or create ``File Info''
-  (id=7) entries in version 2 header files and ``File Dates Info''
-  (id=8) entries in version 1 header files.  However, future versions of
-  the filesystem may enforce the format more strictly.
-
-  Entry id 1 (``Data Fork'') is read-only.  You should use the data file
-  to modify the data fork.  The data fork is, of course, not supported
-  for directories.
-
-  Entry ids 2, 7, 8, 9 and 10 (``Resource Fork'', ``File Info'', ``File
-  Dates Info'', ``Finder Info'' and ``Macintosh File Info'') are fully
-  supported, meaning that their contents may be read and written and
-  that data written is preserved when the file is closed and reopened.
-  The resource fork is, of course, not supported for directories.
-
-  Entry id 7 specifies some of the same data given by ids 8 and 10.  If
-  you create a header file with an entry for id 7 and for ids 8 or 10,
-  then the behavior with respect to their interaction is undefined.  A
-  header that contains an entry for id 7 and for ids 8 or 10 is not
-  valid as either a version 1 or a version 2 header file, so there is no
-  reason to do this and future versions may prevent it.
-
-  Entry id 3 (``Real Name'') is read-only, since it will change
-  automatically when a file is renamed.  Writes to the corresponding
-  entry are silently ignored.
-
-  All other entry ids are ignored.  You may create descriptors for them;
-  in fact the default header layout when fork=netatalk includes a
-  descriptor for id 4 (``Comment'').  However writes to the entries
-  corresponding to the ignored ids fail silently and reads from the
-  entries always return zeros.  However, you shouldn't write random
-  bytes to unsupported entries, since they may be supported in the
-  future.
-
-  All of the supported entry types except the data and resource forks
-  have a fixed length.  If you give them a smaller length in the
-  descriptor then you are unable to access part of the corresponding
-  entry.  If you give them a larger length in the descriptor, then the
-  corresponding entry is padded with zeros and writes to the extra space
-  are silently ignored.
-
-  Writes to the length field of descriptors for the data and resource
-  forks will cause the corresponding fork to grow (with zero padding) or
-  shrink to the indicated length.
-
-  If you have an entry for the data fork then the descriptor's length
-  field does not change automatically to reflect any modification of the
-  data fork directly (the data does change however).  If the data fork
-  is longer than the descriptor indicates, then a portion of it is
-  inaccessible.  If the data fork is shorter than the descriptor
-  indicates then reads will be padded with zeros.
-
-  Writes beyond the end of the resource fork that extend into empty
-  space between entries or beyond the end of the file will extend the
-  fork, automatically changing the length field of the corresponding
-  descriptor.  Writes to any other space between entries are silently
-  ignored and read of such spaces always return zeros.
-
-  Calling truncate() on a header file can change the length of the
-  resource fork and such a change will automatically be reflected in the
-  length field of the corresponding descriptor.  If truncate() shortens
-  the file so that the entry for the resource fork would extend beyond
-  the new end of the file then the fork is shortened to fit in the space
-  that remains, or to zero bytes if the entry is now entirely beyond the
-  end of the file.  If the last entry in a header file is the resource
-  fork then a call to truncate() that extends the header file will
-  extend the fork with zeros.  Note that this happens even if there was
-  previously space between the end of the fork and the end of the file.
-
   55..  RReeppoorrttiinngg BBuuggss
 
   If you'd like any problems you encounter fixed, you'll need to provide
diff -purN /dev/shm/linux-2.5/fs/hfs/Makefile linuxppc-2.5-benh/fs/hfs/Makefile
--- /dev/shm/linux-2.5/fs/hfs/Makefile	2002-12-14 12:38:56.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/Makefile	2003-12-24 03:48:17.000000000 +0000
@@ -1,10 +1,10 @@
 #
 # Makefile for the Linux hfs filesystem routines.
 #
+hfs-objs := bitmap.o bfind.o bnode.o brec.o btree.o \
+	    catalog.o dir.o extent.o inode.o mdb.o \
+            part_tbl.o string.o super.o sysdep.o trans.o
+
 
 obj-$(CONFIG_HFS_FS) += hfs.o
 
-hfs-objs := balloc.o bdelete.o bfind.o bins_del.o binsert.o bitmap.o bitops.o \
-	    bnode.o brec.o btree.o catalog.o dir.o dir_cap.o dir_dbl.o \
-	    dir_nat.o extent.o file.o file_cap.o file_hdr.o inode.o mdb.o \
-            part_tbl.o string.o super.o sysdep.o trans.o version.o
diff -purN /dev/shm/linux-2.5/fs/hfs/TODO linuxppc-2.5-benh/fs/hfs/TODO
--- /dev/shm/linux-2.5/fs/hfs/TODO	2002-02-05 17:39:38.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/TODO	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-The hfs_fs "to do" list.
-------------------------
-Items are broken down into groups and the groups are listed in order
-from most important to least important.  The items within each group
-are not placed in any particular order.  The order in which items are
-listed probably doesn't correlate well with the order they will be
-addressed.
-
-Genuine bugs:
-1.	Header files have compiled-in limit (currently 10) on descriptors.
-
-Missing features:
-1.	1k block support is needed for some devices.
-2.	An ioctl()-based interface is needed to provide a consistent way
-	to do things under all of the representations of forked files.
-
-Possible additional "fork" mount options:
-1.	AppleSingle.
-2.	The scheme MacOS uses on FAT disks (PC Exchange).
-3.	"Flat" (no resource forks or metadata).
-
-Performance issues:
-1.	Use drAllocPtr to speed block allocations.
-2.	Keep a real cache of bnodes, rather than just a hash table of
-	the ones that are currently in use.
-3.	Keep a real cache of extent records, rather than just a linked
-	list of the ones that are currently in use and the one most
-	recently used.  This is particularly needed to get acceptable
-	performance with multiple readers on a file.  Perhaps simply
-	keep them in memory once they've been read until the file is
-	closed.
-
-Implementation details:
-1.	Allocation scheme could/should be closer to that used by Apple.
-2.	B*-tree insertion could/should be closer to that used by Apple.
-3.	Magic-number checks on data structures are rarely done.
-4.	Error recovery is needed for failed binsert(), bdelete() and rename().
-5.	Deadlock detection is needed to make insert_empty_bnode() and
-	bdelete() less likely to hang on a corrupted B-tree.
-6.	Metadata for covered directories shouldn't appear in the filesystem.
-	Under CAP and AppleDouble it currently does.  However, the obvious
-	solution is a real performance killer and is not worth implementing.
-
-Fantasy features:
-1.	Access Desktop file/database for comment and icon.
-2.	Implement mmap() for AppleDouble header files and CAP info files.
-3.	Implement AppleShare client support.
-
-Suggestions/comments/questions are welcome.
-Code addressing any of the issues listed above is especially welcome.
-Paul H. Hargrove
-hargrove@sccm.Stanford.EDU
diff -purN /dev/shm/linux-2.5/fs/hfs/balloc.c linuxppc-2.5-benh/fs/hfs/balloc.c
--- /dev/shm/linux-2.5/fs/hfs/balloc.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/balloc.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,439 +0,0 @@
-/*
- * linux/fs/hfs/balloc.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * hfs_bnode_alloc() and hfs_bnode_bitop() are based on GPLed code
- * Copyright (C) 1995  Michael Dreher
- *
- * This file contains the code to create and destroy nodes
- * in the B-tree structure.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- *
- * The code in this file initializes some structures which contain
- * pointers by calling memset(&foo, 0, sizeof(foo)).
- * This produces the desired behavior only due to the non-ANSI
- * assumption that the machine representation of NULL is all zeros.
- */
-
-#include "hfs_btree.h"
-
-/*================ File-local functions ================*/
-
-/*
- * get_new_node()
- *
- * Get a buffer for a new node with out reading it from disk.
- */
-static hfs_buffer get_new_node(struct hfs_btree *tree, hfs_u32 node)
-{
-	int tmp;
-	hfs_buffer retval = HFS_BAD_BUFFER;
-
-  	tmp = hfs_extent_map(&tree->entry.u.file.data_fork, node, 0);
-	if (tmp) {
-		retval = hfs_buffer_get(tree->sys_mdb, tmp, 0);
-	}
-	return retval;
-}
-
-/*
- * hfs_bnode_init()
- *
- * Description:
- *   Initialize a newly allocated bnode.
- * Input Variable(s):
- *   struct hfs_btree *tree: Pointer to a B-tree
- *   hfs_u32 node: the node number to allocate
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_bnode_ref for the new node
- * Preconditions:
- *   'tree' points to a "valid" (struct hfs_btree)
- *   'node' exists and has been allocated in the bitmap of bnodes.
- * Postconditions:
- *   On success:
- *    The node is not read from disk, nor added to the bnode cache.
- *    The 'sticky' and locking-related fields are all zero/NULL.
- *    The bnode's nd{[FB]Link, Type, NHeight} fields are uninitialized.
- *    The bnode's ndNRecs field and offsets table indicate an empty bnode.
- *   On failure:
- *    The node is deallocated.
- */
-static struct hfs_bnode_ref hfs_bnode_init(struct hfs_btree * tree,
-					   hfs_u32 node)
-{
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	extern int bnode_count;
-#endif
-	struct hfs_bnode_ref retval;
-
-	retval.lock_type = HFS_LOCK_NONE;
-	if (!HFS_NEW(retval.bn)) {
-		hfs_warn("hfs_bnode_init: out of memory.\n");
-		goto bail2;
-	}
-
-	/* Partially initialize the in-core structure */
-	memset(retval.bn, 0, sizeof(*retval.bn));
-	retval.bn->magic = HFS_BNODE_MAGIC;
-	retval.bn->tree = tree;
-	retval.bn->node = node;
-	hfs_init_waitqueue(&retval.bn->wqueue);
-	hfs_init_waitqueue(&retval.bn->rqueue);
-	hfs_bnode_lock(&retval, HFS_LOCK_WRITE);
-
-	retval.bn->buf = get_new_node(tree, node);
-	if (!hfs_buffer_ok(retval.bn->buf)) {
-		goto bail1;
-	}
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	++bnode_count;
-#endif
-
-	/* Partially initialize the on-disk structure */
-	memset(hfs_buffer_data(retval.bn->buf), 0, HFS_SECTOR_SIZE);
-	hfs_put_hs(sizeof(struct NodeDescriptor), RECTBL(retval.bn, 1));
-
-	return retval;
-
-bail1:
-	HFS_DELETE(retval.bn);
-bail2:
-	/* clear the bit in the bitmap */
-	hfs_bnode_bitop(tree, node, 0);
-	return retval;
-}
-
-/*
- * init_mapnode()
- *
- * Description:
- *   Initializes a given node as a mapnode in the given tree.
- * Input Variable(s):
- *   struct hfs_bnode *bn: the node to add the mapnode after.
- *   hfs_u32: the node to use as a mapnode.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_bnode *: the new mapnode or NULL
- * Preconditions:
- *   'tree' is a valid (struct hfs_btree).
- *   'node' is the number of the first node in 'tree' that is not
- *    represented by a bit in the existing mapnodes.
- * Postconditions:
- *   On failure 'tree' is unchanged and NULL is returned.
- *   On success the node given by 'node' has been added to the linked
- *    list of mapnodes attached to 'tree', and has been initialized as
- *    a valid mapnode with its first bit set to indicate itself as
- *    allocated.
- */
-static struct hfs_bnode *init_mapnode(struct hfs_bnode *bn, hfs_u32 node)
-{
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	extern int bnode_count;
-#endif
-	struct hfs_bnode *retval;
-
-	if (!HFS_NEW(retval)) {
-		hfs_warn("hfs_bnode_add: out of memory.\n");
-		return NULL;
-	}
-
-	memset(retval, 0, sizeof(*retval));
-	retval->magic = HFS_BNODE_MAGIC;
-	retval->tree = bn->tree;
-	retval->node = node;
-	retval->sticky = HFS_STICKY;
-	retval->buf = get_new_node(bn->tree, node);
-	if (!hfs_buffer_ok(retval->buf)) {
-		HFS_DELETE(retval);
-		return NULL;
-	}
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	++bnode_count;
-#endif
-
-	/* Initialize the bnode data structure */
-	memset(hfs_buffer_data(retval->buf), 0, HFS_SECTOR_SIZE);
-	retval->ndFLink = 0;
-	retval->ndBLink = bn->node;
-	retval->ndType = ndMapNode;
-	retval->ndNHeight = 0;
-	retval->ndNRecs = 1;
-	hfs_put_hs(sizeof(struct NodeDescriptor), RECTBL(retval, 1));
-	hfs_put_hs(0x1fa,                         RECTBL(retval, 2));
-	*((hfs_u8 *)bnode_key(retval, 1)) = 0x80; /* set first bit of bitmap */
-	retval->prev = bn;
-	hfs_bnode_commit(retval);
-
-	bn->ndFLink = node;
-	bn->next = retval;
-	hfs_bnode_commit(bn);
-
-	return retval;
-}
-
-/*================ Global functions ================*/
-
-/*
- * hfs_bnode_bitop()
- *
- * Description:
- *   Allocate/free the requested node of a B-tree of the hfs filesystem
- *   by setting/clearing the corresponding bit in the B-tree bitmap.
- *   The size of the B-tree will not be changed.
- * Input Variable(s):
- *   struct hfs_btree *tree: Pointer to a B-tree
- *   hfs_u32 bitnr: The node number to free
- *   int set: 0 to clear the bit, non-zero to set it.
- * Output Variable(s):
- *   None
- * Returns:
- *    0: no error
- *   -1: The node was already allocated/free, nothing has been done.
- *   -2: The node is out of range of the B-tree.
- *   -4: not enough map nodes to hold all the bits
- * Preconditions:
- *   'tree' points to a "valid" (struct hfs_btree)
- *   'bitnr' is a node number within the range of the btree, which is
- *   currently free/allocated.
- * Postconditions:
- *   The bit number 'bitnr' of the node bitmap is set/cleared and the
- *   number of free nodes in the btree is decremented/incremented by one.
- */
-int hfs_bnode_bitop(struct hfs_btree *tree, hfs_u32 bitnr, int set)
-{
-	struct hfs_bnode *bn;   /* the current bnode */
-	hfs_u16 start;		/* the start (in bits) of the bitmap in node */
-	hfs_u16 len;		/* the len (in bits) of the bitmap in node */
-	hfs_u32 *u32;		/* address of the u32 containing the bit */
-
-	if (bitnr >= tree->bthNNodes) {
-		hfs_warn("hfs_bnode_bitop: node number out of range.\n");
-		return -2;
-	}
-
-	bn = &tree->head;
-	for (;;) {
-		start = bnode_offset(bn, bn->ndNRecs) << 3;
-		len = (bnode_offset(bn, bn->ndNRecs + 1) << 3) - start;
-
-		if (bitnr < len) {
-			break;
-		}
-
-		/* continue on to next map node if available */
-		if (!(bn = bn->next)) {
-			hfs_warn("hfs_bnode_bitop: too few map nodes.\n");
-			return -4;
-		}
-		bitnr -= len;
-	}
-
-	/* Change the correct bit */
-	bitnr += start;
-	u32 = (hfs_u32 *)hfs_buffer_data(bn->buf) + (bitnr >> 5);
-	bitnr %= 32;
-	if ((set && hfs_set_bit(bitnr, u32)) ||
-	    (!set && !hfs_clear_bit(bitnr, u32))) {
-		hfs_warn("hfs_bnode_bitop: bitmap corruption.\n");
-		return -1;
-	}
-	hfs_buffer_dirty(bn->buf);
-
-	/* adjust the free count */
-	tree->bthFree += (set ? -1 : 1);
-	tree->dirt = 1;
-
-	return 0;
-}
-
-/*
- * hfs_bnode_alloc()
- *
- * Description:
- *   Find a cleared bit in the B-tree node bitmap of the hfs filesystem,
- *   set it and return the corresponding bnode, with its contents zeroed.
- *   When there is no free bnode in the tree, an error is returned, no
- *   new nodes will be added by this function!
- * Input Variable(s):
- *   struct hfs_btree *tree: Pointer to a B-tree
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_bnode_ref for the new bnode
- * Preconditions:
- *   'tree' points to a "valid" (struct hfs_btree)
- *   There is at least one free bnode.
- * Postconditions:
- *   On success:
- *     The corresponding bit in the btree bitmap is set.
- *     The number of free nodes in the btree is decremented by one.
- *   The node is not read from disk, nor added to the bnode cache.
- *   The 'sticky' field is uninitialized.
- */
-struct hfs_bnode_ref hfs_bnode_alloc(struct hfs_btree *tree)
-{
-	struct hfs_bnode *bn;   /* the current bnode */
-	hfs_u32 bitnr = 0;	/* which bit are we examining */
-	hfs_u16 first;		/* the first clear bit in this bnode */
-	hfs_u16 start;		/* the start (in bits) of the bitmap in node */
-	hfs_u16 end;		/* the end (in bits) of the bitmap in node */
-	hfs_u32 *data;		/* address of the data in this bnode */
-	
-	bn = &tree->head;
-	for (;;) {
-		start = bnode_offset(bn, bn->ndNRecs) << 3;
-		end = bnode_offset(bn, bn->ndNRecs + 1) << 3;
-		data =  (hfs_u32 *)hfs_buffer_data(bn->buf);
-		
-		/* search the current node */
-		first = hfs_find_zero_bit(data, end, start);
-		if (first < end) {
-			break;
-		}
-
-		/* continue search in next map node */
-		bn = bn->next;
-
-		if (!bn) {
-			hfs_warn("hfs_bnode_alloc: too few map nodes.\n");
-			goto bail;
-		}
-		bitnr += (end - start);
-	}
-
-	if ((bitnr += (first - start)) >= tree->bthNNodes) {
-		hfs_warn("hfs_bnode_alloc: no free nodes found, "
-			 "count wrong?\n");
-		goto bail;
-	}
-
-	if (hfs_set_bit(first % 32, data + (first>>5))) {
-		hfs_warn("hfs_bnode_alloc: bitmap corruption.\n");
-		goto bail;
-	}
-	hfs_buffer_dirty(bn->buf);
-
-	/* decrement the free count */
-	--tree->bthFree;
-	tree->dirt = 1;
-
-	return hfs_bnode_init(tree, bitnr);
-
-bail:
-	return (struct hfs_bnode_ref){NULL, HFS_LOCK_NONE};
-}
-
-/*
- * hfs_btree_extend()
- *
- * Description:
- *   Adds nodes to a B*-tree if possible.
- * Input Variable(s):
- *   struct hfs_btree *tree: the btree to add nodes to.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'tree' is a valid (struct hfs_btree *).
- * Postconditions:
- *   If possible the number of nodes indicated by the tree's clumpsize
- *    have been added to the tree, updating all in-core and on-disk
- *    allocation information.
- *   If insufficient disk-space was available then fewer nodes may have
- *    been added than would be expected based on the clumpsize.
- *   In the case of the extents B*-tree this function will add fewer
- *    nodes than expected if adding more would result in an extent
- *    record for the extents tree being added to the extents tree.
- *    The situation could be dealt with, but doing so confuses Macs.
- */
-void hfs_btree_extend(struct hfs_btree *tree)
-{
-	struct hfs_bnode_ref head;
-	struct hfs_bnode *bn, *tmp;
-	struct hfs_cat_entry *entry = &tree->entry;
-	struct hfs_mdb *mdb = entry->mdb;
-	hfs_u32 old_nodes, new_nodes, total_nodes, new_mapnodes, seen;
-
-	old_nodes = entry->u.file.data_fork.psize;
-
-	entry->u.file.data_fork.lsize += 1; /* rounded up to clumpsize */
-	hfs_extent_adj(&entry->u.file.data_fork);
-
-	total_nodes = entry->u.file.data_fork.psize;
-	entry->u.file.data_fork.lsize = total_nodes << HFS_SECTOR_SIZE_BITS;
-	new_nodes = total_nodes - old_nodes;
-	if (!new_nodes) {
-		return;
-	}
-
-	head = hfs_bnode_find(tree, 0, HFS_LOCK_WRITE);
-	if (!(bn = head.bn)) {
-		hfs_warn("hfs_btree_extend: header node not found.\n");
-		return;
-	}
-
-	seen = 0;
-	new_mapnodes = 0;
-	for (;;) {
-		seen += bnode_rsize(bn, bn->ndNRecs) << 3;
-
-		if (seen >= total_nodes) {
-			break;
-		}
-
-		if (!bn->next) {
-			tmp = init_mapnode(bn, seen);
-			if (!tmp) {
-				hfs_warn("hfs_btree_extend: "
-					 "can't build mapnode.\n");
-				hfs_bnode_relse(&head);
-				return;
-			}
-			++new_mapnodes;
-		}
-		bn = bn->next;
-	}
-	hfs_bnode_relse(&head);
-
-	tree->bthNNodes = total_nodes;
-	tree->bthFree += (new_nodes - new_mapnodes);
-	tree->dirt = 1;
-
-	/* write the backup MDB, not returning until it is written */
-	hfs_mdb_commit(mdb, 1);
-
-	return;
-}
-
-/*
- * hfs_bnode_free()
- *
- * Remove a node from the cache and mark it free in the bitmap.
- */
-int hfs_bnode_free(struct hfs_bnode_ref *bnr)
-{
-	hfs_u32 node = bnr->bn->node;
-	struct hfs_btree *tree = bnr->bn->tree;
-
-	if (bnr->bn->count != 1) {
-		hfs_warn("hfs_bnode_free: count != 1.\n");
-		return -EIO;
-	}
-
-	hfs_bnode_relse(bnr);
-	hfs_bnode_bitop(tree, node, 0);
-	return 0;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/bdelete.c linuxppc-2.5-benh/fs/hfs/bdelete.c
--- /dev/shm/linux-2.5/fs/hfs/bdelete.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bdelete.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,488 +0,0 @@
-/*
- * linux/fs/hfs/bdelete.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the code to delete records in a B-tree.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs_btree.h"
-
-/*================ Variable-like macros ================*/
-
-#define FULL (HFS_SECTOR_SIZE - sizeof(struct NodeDescriptor))
-#define NO_SPACE (HFS_SECTOR_SIZE+1)
-
-/*================ File-local functions ================*/
-
-/*
- * bdelete_nonempty()
- *
- * Description:
- *   Deletes a record from a given bnode without regard to it becoming empty.
- * Input Variable(s):
- *   struct hfs_brec* brec: pointer to the brec for the deletion
- *   struct hfs_belem* belem: which node in 'brec' to delete from
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'brec' points to a valid (struct hfs_brec).
- *   'belem' points to a valid (struct hfs_belem) in 'brec'.
- * Postconditions:
- *   The record has been inserted in the position indicated by 'brec'.
- */
-static void bdelete_nonempty(struct hfs_brec *brec, struct hfs_belem *belem)
-{
-	int i, rec, nrecs, tomove;
-	hfs_u16 size;
-	hfs_u8 *start;
-	struct hfs_bnode *bnode = belem->bnr.bn;
-
-	rec = belem->record;
-	nrecs = bnode->ndNRecs;
-	size = bnode_rsize(bnode, rec);
-	tomove = bnode_offset(bnode, nrecs+1) - bnode_offset(bnode, rec+1);
-	
-	/* adjust the record table */
-	for (i = rec+1; i <= nrecs; ++i) {
-		hfs_put_hs(bnode_offset(bnode,i+1) - size, RECTBL(bnode,i));
-	}
-
-	/* move it down */
-	start = bnode_key(bnode, rec);
-	memmove(start, start + size, tomove);
-
-	/* update record count */
-	--bnode->ndNRecs;
-}
-
-/*
- * del_root()
- *
- * Description:
- *   Delete the current root bnode.
- * Input Variable(s):
- *   struct hfs_bnode_ref *root: reference to the root bnode
- * Output Variable(s):
- *   NONE
- * Returns:
- *   int: 0 on success, error code on failure
- * Preconditions:
- *   'root' refers to the root bnode with HFS_LOCK_WRITE access.
- *   None of 'root's children are held with HFS_LOCK_WRITE access.
- * Postconditions:
- *   The current 'root' node is removed from the tree and the depth
- *    of the tree is reduced by one.
- *   If 'root' is an index node with exactly one child, then that
- *    child becomes the new root of the tree.
- *   If 'root' is an empty leaf node the tree becomes empty.
- *   Upon return access to 'root' is relinquished.
- */
-static int del_root(struct hfs_bnode_ref *root)
-{
-	struct hfs_btree *tree = root->bn->tree;
-	struct hfs_bnode_ref child;
-	hfs_u32 node;
-
-	if (root->bn->ndNRecs > 1) {
-		return 0;
-	} else if (root->bn->ndNRecs == 0) {
-		/* tree is empty */
-		tree->bthRoot = 0;
-		tree->root = NULL;
-		tree->bthRoot = 0;
-		tree->bthFNode = 0;
-		tree->bthLNode = 0;
-		--tree->bthDepth;
-		tree->dirt = 1;
-		if (tree->bthDepth) {
-			hfs_warn("hfs_bdelete: empty tree with bthDepth=%d\n",
-				 tree->bthDepth);
-			goto bail;
-		}
-		return hfs_bnode_free(root);
-	} else if (root->bn->ndType == ndIndxNode) {
-		/* tree is non-empty */
-		node = hfs_get_hl(bkey_record(bnode_datastart(root->bn)));
-
-		child = hfs_bnode_find(tree, node, HFS_LOCK_READ);
-		if (!child.bn) {
-			hfs_warn("hfs_bdelete: can't read child node.\n");
-			goto bail;
-		}
-			
-		child.bn->sticky = HFS_STICKY;
-        	if (child.bn->next) {
-                	child.bn->next->prev = child.bn->prev;
-        	}
-        	if (child.bn->prev) {
-                	child.bn->prev->next = child.bn->next;
-        	}
-        	if (bhash(tree, child.bn->node) == child.bn) {
-                	bhash(tree, child.bn->node) = child.bn->next;
-        	}
-		child.bn->next = NULL;
-		child.bn->prev = NULL;
-
-		tree->bthRoot = child.bn->node;
-		tree->root = child.bn;
-
-		/* re-assign bthFNode and bthLNode if the new root is
-                   a leaf node. */
-		if (child.bn->ndType == ndLeafNode) {
-			tree->bthFNode = node;
-			tree->bthLNode = node;
-		}
-		hfs_bnode_relse(&child);
-
-		tree->bthRoot = node;
-		--tree->bthDepth;
-		tree->dirt = 1;
-		if (!tree->bthDepth) {
-			hfs_warn("hfs_bdelete: non-empty tree with "
-				 "bthDepth == 0\n");
-			goto bail;
-		}
-		return hfs_bnode_free(root);	/* marks tree dirty */
-	}
-	hfs_bnode_relse(root);
-	return 0;
-
-bail:
-	hfs_bnode_relse(root);
-	return -EIO;
-}
-
-
-/*
- * delete_empty_bnode()
- *
- * Description:
- *   Removes an empty non-root bnode from between 'left' and 'right'
- * Input Variable(s):
- *   hfs_u32 left_node: node number of 'left' or zero if 'left' is invalid
- *   struct hfs_bnode_ref *left: reference to the left neighbor of the
- *    bnode to remove, or invalid if no such neighbor exists.
- *   struct hfs_bnode_ref *center: reference to the bnode to remove
- *   hfs_u32 right_node: node number of 'right' or zero if 'right' is invalid
- *   struct hfs_bnode_ref *right: reference to the right neighbor of the
- *    bnode to remove, or invalid if no such neighbor exists.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'left_node' is as described above.
- *   'left' points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE
- *    access and referring to the left neighbor of 'center' if such a
- *    neighbor exists, or invalid if no such neighbor exists.
- *   'center' points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE
- *    access and referring to the bnode to delete.
- *   'right_node' is as described above.
- *   'right' points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE
- *    access and referring to the right neighbor of 'center' if such a
- *    neighbor exists, or invalid if no such neighbor exists.
- * Postconditions:
- *   If 'left' is valid its 'ndFLink' field becomes 'right_node'.
- *   If 'right' is valid its 'ndBLink' field becomes 'left_node'.
- *   If 'center' was the first leaf node then the tree's 'bthFNode'
- *    field becomes 'right_node' 
- *   If 'center' was the last leaf node then the tree's 'bthLNode'
- *    field becomes 'left_node' 
- *   'center' is NOT freed and access to the nodes is NOT relinquished.
- */
-static void delete_empty_bnode(hfs_u32 left_node, struct hfs_bnode_ref *left,
-			       struct hfs_bnode_ref *center,
-			       hfs_u32 right_node, struct hfs_bnode_ref *right)
-{
-	struct hfs_bnode *bnode = center->bn;
-
-	if (left_node) {
-		left->bn->ndFLink = right_node;
-	} else if (bnode->ndType == ndLeafNode) {
-		bnode->tree->bthFNode = right_node;
-		bnode->tree->dirt = 1;
-	}
-
-	if (right_node) {
-		right->bn->ndBLink = left_node;
-	} else if (bnode->ndType == ndLeafNode) {
-		bnode->tree->bthLNode = left_node;
-		bnode->tree->dirt = 1;
-	}
-}
-
-/*
- * balance()
- *
- * Description:
- *   Attempt to equalize space usage in neighboring bnodes.
- * Input Variable(s):
- *   struct hfs_bnode *left: the left bnode.
- *   struct hfs_bnode *right: the right bnode.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'left' and 'right' point to valid (struct hfs_bnode)s obtained
- *    with HFS_LOCK_WRITE access, and are neighbors.
- * Postconditions:
- *   Records are shifted either left or right to make the space usage
- *   nearly equal.  When exact equality is not possible the break
- *   point is chosen to reduce data movement.
- *   The key corresponding to 'right' in its parent is NOT updated.
- */
-static void balance(struct hfs_bnode *left, struct hfs_bnode *right)
-{
-	int index, left_free, right_free, half;
-
-	left_free = bnode_freespace(left);
-	right_free = bnode_freespace(right);
-	half = (left_free + right_free)/2;
-
-	if (left_free < right_free) {
-		/* shift right to balance */
-		index = left->ndNRecs + 1;
-		while (right_free >= half) {
-			--index;
-			right_free -= bnode_rsize(left,index)+sizeof(hfs_u16);
-		}
-		if (index < left->ndNRecs) {
-#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
-			hfs_warn("shifting %d of %d recs right to balance: ",
-			       left->ndNRecs - index, left->ndNRecs);
-#endif
-			hfs_bnode_shift_right(left, right, index+1);
-#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
-			hfs_warn("%d,%d\n", left->ndNRecs, right->ndNRecs);
-#endif
-		}
-	} else {
-		/* shift left to balance */
-		index = 0;
-		while (left_free >= half) {
-			++index;
-			left_free -= bnode_rsize(right,index)+sizeof(hfs_u16);
-		}
-		if (index > 1) {
-#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
-			hfs_warn("shifting %d of %d recs left to balance: ",
-			       index-1, right->ndNRecs);
-#endif
-			hfs_bnode_shift_left(left, right, index-1);
-#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
-			hfs_warn("%d,%d\n", left->ndNRecs, right->ndNRecs);
-#endif
-		}
-	}
-}
-
-/*
- * bdelete()
- *
- * Delete the given record from a B-tree.
- */
-static int bdelete(struct hfs_brec *brec)
-{
-	struct hfs_btree *tree = brec->tree;
-	struct hfs_belem *belem = brec->bottom;
-	struct hfs_belem *parent = (belem-1);
-	struct hfs_bnode *bnode;
-	hfs_u32 left_node, right_node;
-	struct hfs_bnode_ref left, right;
-	int left_space, right_space, min_space;
-	int fix_right_key;
-	int fix_key;
-	
-	while ((belem > brec->top) &&
-	       (belem->flags & (HFS_BPATH_UNDERFLOW | HFS_BPATH_FIRST))) {
-		bnode = belem->bnr.bn;
-		fix_key = belem->flags & HFS_BPATH_FIRST;
-		fix_right_key = 0;
-
-		bdelete_nonempty(brec, belem);
-
-		if (bnode->node == tree->root->node) {
-			del_root(&belem->bnr);
-			--brec->bottom;
-			goto done;
-		}
-
-		/* check for btree corruption which could lead to deadlock */
-		left_node = bnode->ndBLink;
-		right_node = bnode->ndFLink;
-		if ((left_node && hfs_bnode_in_brec(left_node, brec)) ||
-		    (right_node && hfs_bnode_in_brec(right_node, brec)) ||
-		    (left_node == right_node)) {
-			hfs_warn("hfs_bdelete: corrupt btree\n");
-			hfs_brec_relse(brec, NULL);
-			return -EIO;
-		}
-
-		/* grab the left neighbor if it exists */
-		if (left_node) {
-			hfs_bnode_lock(&belem->bnr, HFS_LOCK_RESRV);
-			left = hfs_bnode_find(tree,left_node,HFS_LOCK_WRITE);
-			if (!left.bn) {
-				hfs_warn("hfs_bdelete: unable to read left "
-					 "neighbor.\n");
-				hfs_brec_relse(brec, NULL);
-				return -EIO;
-			}
-			hfs_bnode_lock(&belem->bnr, HFS_LOCK_WRITE);
-			if (parent->record != 1) {
-				left_space = bnode_freespace(left.bn);
-			} else {
-				left_space = NO_SPACE;
-			}
-		} else {
-			left.bn = NULL;
-			left_space = NO_SPACE;
-		}
-
-		/* grab the right neighbor if it exists */
-		if (right_node) {
-			right = hfs_bnode_find(tree,right_node,HFS_LOCK_WRITE);
-			if (!right.bn) {
-				hfs_warn("hfs_bdelete: unable to read right "
-					 "neighbor.\n");
-				hfs_bnode_relse(&left);
-				hfs_brec_relse(brec, NULL);
-				return -EIO;
-			}
-			if (parent->record < parent->bnr.bn->ndNRecs) {
-				right_space = bnode_freespace(right.bn);
-			} else {
-				right_space = NO_SPACE;
-			}
-		} else {
-			right.bn = NULL;
-			right_space = NO_SPACE;
-		}
-
-		if (left_space < right_space) {
-			min_space = left_space;
-		} else {
-			min_space = right_space;
-		}
-
-		if (min_space == NO_SPACE) {
-			hfs_warn("hfs_bdelete: no siblings?\n");
-			hfs_brec_relse(brec, NULL);
-			return -EIO;
-		}
-
-		if (bnode->ndNRecs == 0) {
-			delete_empty_bnode(left_node, &left, &belem->bnr,
-					   right_node, &right);
-		} else if (min_space + bnode_freespace(bnode) >= FULL) {
-			if ((right_space == NO_SPACE) ||
-			    ((right_space == min_space) &&
-			     (left_space != NO_SPACE))) {
-				hfs_bnode_shift_left(left.bn, bnode,
-						     bnode->ndNRecs);
-			} else {
-				hfs_bnode_shift_right(bnode, right.bn, 1);
-				fix_right_key = 1;
-			}
-			delete_empty_bnode(left_node, &left, &belem->bnr,
-					   right_node, &right);
-		} else if (min_space == right_space) {
-			balance(bnode, right.bn);
-			fix_right_key = 1;
-		} else {
-			balance(left.bn, bnode);
-			fix_key = 1;
-		}
-
-		if (fix_right_key) {
-			hfs_bnode_update_key(brec, belem, right.bn, 1);
-		}
-
-		hfs_bnode_relse(&left);
-		hfs_bnode_relse(&right);
-
-		if (bnode->ndNRecs) {
-			if (fix_key) {
-				hfs_bnode_update_key(brec, belem, bnode, 0);
-			}
-			goto done;
-		}
-
-		hfs_bnode_free(&belem->bnr);
-		--brec->bottom;
-		belem = parent;
-		--parent;
-	}
-
-	if (belem < brec->top) {
-		hfs_warn("hfs_bdelete: Missing parent.\n");
-		hfs_brec_relse(brec, NULL);
-		return -EIO;
-	}
-
-	bdelete_nonempty(brec, belem);
-
-done:
-	hfs_brec_relse(brec, NULL);
-	return 0;
-}
-
-/*================ Global functions ================*/
-
-/*
- * hfs_bdelete()
- *
- * Delete the requested record from a B-tree.
- */
-int hfs_bdelete(struct hfs_btree *tree, const struct hfs_bkey *key)
-{ 
-	struct hfs_belem *belem;
-	struct hfs_bnode *bnode;
-	struct hfs_brec brec;
-	int retval;
-
-	if (!tree || (tree->magic != HFS_BTREE_MAGIC) || !key) {
-		hfs_warn("hfs_bdelete: invalid arguments.\n");
-		return -EINVAL;
-	}
-
-	retval = hfs_bfind(&brec, tree, key, HFS_BFIND_DELETE);
-	if (!retval) {
-		belem = brec.bottom;
-		bnode = belem->bnr.bn;
-
-		belem->flags = 0;
-        	if ((bnode->ndNRecs * sizeof(hfs_u16) + bnode_end(bnode) -
-		     bnode_rsize(bnode, belem->record)) < FULL/2) {
-			belem->flags |= HFS_BPATH_UNDERFLOW;
-		}
-		if (belem->record == 1) {
-			belem->flags |= HFS_BPATH_FIRST;
-		}
-
-		if (!belem->flags) {
-			hfs_brec_lock(&brec, brec.bottom);
-		} else {
-			hfs_brec_lock(&brec, NULL);
-		}
-
-		retval = bdelete(&brec);
-		if (!retval) {
-			--brec.tree->bthNRecs;
-			brec.tree->dirt = 1;
-		}
-		hfs_brec_relse(&brec, NULL);
-	}
-	return retval;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/bfind.c linuxppc-2.5-benh/fs/hfs/bfind.c
--- /dev/shm/linux-2.5/fs/hfs/bfind.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bfind.c	2003-12-24 03:48:17.000000000 +0000
@@ -1,322 +1,209 @@
 /*
- * linux/fs/hfs/bfind.c
+ *  linux/fs/hfs/bfind.c
  *
- * Copyright (C) 1995, 1996  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
  *
- * This file contains the code to access records in a btree.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
+ * Search routines for btrees
  */
 
-#include "hfs_btree.h"
+#include <linux/slab.h>
+#include "btree.h"
 
-/*================ Global functions ================*/
-
-/*
- * hfs_brec_relse()
- *
- * Description:
- *   This function releases some of the nodes associated with a brec.
- * Input Variable(s):
- *   struct hfs_brec *brec: pointer to the brec to release some nodes from.
- *   struct hfs_belem *elem: the last node to release or NULL for all
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'brec' points to a "valid" (struct hfs_brec)
- * Postconditions: 
- *   All nodes between the indicated node and the beginning of the path
- *    are released.
- */
-void hfs_brec_relse(struct hfs_brec *brec, struct hfs_belem *elem)
+int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)
 {
-	if (!elem) {
-		elem = brec->bottom;
-	}
+	void *ptr;
 
-	while (brec->top <= elem) {
-		hfs_bnode_relse(&brec->top->bnr);
-		++brec->top;
-	}
+	fd->tree = tree;
+	fd->bnode = NULL;
+	ptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	fd->search_key = ptr;
+	fd->key = ptr + tree->max_key_len + 2;
+	dprint(DBG_BNODE_REFS, "find_init: %d (%p)\n", tree->cnid, __builtin_return_address(0));
+	down(&tree->tree_lock);
+	return 0;
 }
 
-/*
- * hfs_bfind()
- *
- * Description:
- *   This function has sole responsibility for locating existing
- *   records in a B-tree.  Given a B-tree and a key it locates the
- *   "greatest" record "less than or equal to" the given key.  The
- *   exact behavior is determined by the bits of the flags variable as
- *   follows:
- *     ('flags' & HFS_LOCK_MASK):
- *      The lock_type argument to be used when calling hfs_bnode_find().
- *     HFS_BFIND_EXACT: only accept an exact match, otherwise take the
- *	"largest" record less than 'target' as a "match"
- *     HFS_BFIND_LOCK: request HFS_LOCK_WRITE access to the node containing
- *	the "matching" record when it is located
- *     HFS_BPATH_FIRST: keep access to internal nodes when accessing their
- *      first child.
- *     HFS_BPATH_OVERFLOW: keep access to internal nodes when the accessed
- *      child is too full to insert another pointer record.
- *     HFS_BPATH_UNDERFLOW: keep access to internal nodes when the accessed
- *      child is would be less than half full upon removing a pointer record.
- * Input Variable(s):
- *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to hold
- *    the search results.
- *   struct hfs_bkey *target: pointer to the (struct hfs_bkey)
- *    to search for
- *   int flags: bitwise OR of flags which determine the function's behavior
- * Output Variable(s):
- *   'brec' contains the results of the search on success or is invalid
- *    on failure.
- * Returns:
- *   int: 0 or 1 on success or an error code on failure:
- *     -EINVAL: one of the input variables was NULL.
- *     -ENOENT: tree is valid but empty or no "matching" record was located.
- *	 If the HFS_BFIND_EXACT bit of 'flags' is not set then the case of no
- *	 matching record will give a 'brec' with a 'record' field of zero
- *	 rather than returning this error.
- *     -EIO: an I/O operation or an assertion about the structure of a
- *       valid B-tree failed indicating corruption of either the B-tree
- *       structure on the disk or one of the in-core structures representing
- *       the B-tree.
- *	 (This could also be returned if a kmalloc() call failed in a
- *	 subordinate routine that is intended to get the data from the
- *	 disk or the buffer cache.)
- * Preconditions:
- *   'brec' is NULL or points to a (struct hfs_brec) with a 'tree' field
- *    which points to a valid (struct hfs_btree).
- *   'target' is NULL or points to a "valid" (struct hfs_bkey)
- * Postconditions:
- *   If 'brec', 'brec->tree' or 'target' is NULL then -EINVAL is returned.
- *   If 'brec', 'brec->tree' and 'target' are non-NULL but the tree
- *   is empty then -ENOENT is returned.
- *   If 'brec', 'brec->tree' and 'target' are non-NULL but the call to
- *   hfs_brec_init() fails then '*brec' is NULL and -EIO is returned.
- *   If 'brec', 'brec->tree' and 'target' are non-NULL and the tree is
- *   non-empty then the tree is searched as follows:
- *    If any call to hfs_brec_next() fails or returns a node that is
- *     neither an index node nor a leaf node then -EIO is returned to
- *     indicate that the B-tree or buffer-cache are corrupted.
- *    If every record in the tree is "greater than" the given key
- *     and the HFS_BFIND_EXACT bit of 'flags' is set then -ENOENT is returned.
- *    If every record in the tree is "greater than" the given key
- *     and the HFS_BFIND_EXACT bit of 'flags' is clear then 'brec' refers
- *     to the first leaf node in the tree and has a 'record' field of
- *     zero, and 1 is returned.
- *    If a "matching" record is located with key "equal to" 'target'
- *     then the return value is 0 and 'brec' indicates the record.
- *    If a "matching" record is located with key "greater than" 'target'
- *     then the behavior is determined as follows:
- *	If the HFS_BFIND_EXACT bit of 'flags' is not set then 1 is returned
- *       and 'brec' refers to the "matching" record.
- *	If the HFS_BFIND_EXACT bit of 'flags' is set then -ENOENT is returned.
- *    If the return value is non-negative and the HFS_BFIND_LOCK bit of
- *     'flags' is set then hfs_brec_lock() is called on the bottom element
- *     of 'brec' before returning.
- */
-int hfs_bfind(struct hfs_brec *brec, struct hfs_btree *tree,
-	      const struct hfs_bkey *target, int flags)
+void hfs_find_exit(struct hfs_find_data *fd)
 {
-	struct hfs_belem *curr;
-	struct hfs_bkey *key;
-	struct hfs_bnode *bn;
-	int result, ntype;
-
-	/* check for invalid arguments */
-	if (!brec || (tree->magic != HFS_BTREE_MAGIC) || !target) {
-		return -EINVAL;
-	}
-
-	/* check for empty tree */
-	if (!tree->root || !tree->bthNRecs) {
-		return -ENOENT;
-	}
-
-	/* start search at root of tree */
-	if (!(curr = hfs_brec_init(brec, tree, flags))) {
-		return -EIO;
-	}
+	hfs_bnode_put(fd->bnode);
+	kfree(fd->search_key);
+	dprint(DBG_BNODE_REFS, "find_exit: %d (%p)\n", fd->tree->cnid, __builtin_return_address(0));
+	up(&fd->tree->tree_lock);
+	fd->tree = NULL;
+}
 
-	/* traverse the tree */
+/* Find the record in bnode that best matches key (not greater than...)*/
+int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd)
+{
+	int cmpval;
+	u16 off, len, keylen;
+	int rec;
+	int b, e;
+	int res;
+
+	b = 0;
+	e = bnode->num_recs - 1;
+	res = -ENOENT;
 	do {
-		bn = curr->bnr.bn;
-
-		if (!curr->record) {
-			hfs_warn("hfs_bfind: empty bnode\n");
-			hfs_brec_relse(brec, NULL);
-			return -EIO;
-		}
-
-		/* reverse linear search yielding largest key "less
-		   than or equal to" 'target'.
-		   It is questionable whether a binary search would be
-		   significantly faster */
-		do {
-			key = belem_key(curr);
-			if (!key->KeyLen) {
-				hfs_warn("hfs_bfind: empty key\n");
-				hfs_brec_relse(brec, NULL);
-				return -EIO;
-			}
-			result = (tree->compare)(target, key);
-		} while ((result<0) && (--curr->record));
-
-		ntype = bn->ndType;
-
-		/* see if all keys > target */
-		if (!curr->record) {
-			if (bn->ndBLink) {
-				/* at a node other than the left-most at a
-				   given level it means the parent had an
-				   incorrect key for this child */
-				hfs_brec_relse(brec, NULL);
-				hfs_warn("hfs_bfind: corrupted b-tree %d.\n",
-					 (int)ntohl(tree->entry.cnid));
-				return -EIO;
-			}
-			if (flags & HFS_BFIND_EXACT) {
-				/* we're not going to find it */
-				hfs_brec_relse(brec, NULL);
-				return -ENOENT;
-			}
-			if (ntype == ndIndxNode) {
-				/* since we are at the left-most node at
-				   the current level and looking for the
-				   predecessor of 'target' keep going down */
-				curr->record = 1;
-			} else {
-				/* we're at first leaf so fall through */
-			}
+		rec = (e + b) / 2;
+		len = hfs_brec_lenoff(bnode, rec, &off);
+		keylen = hfs_brec_keylen(bnode, rec);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+		cmpval = bnode->tree->keycmp(fd->key, fd->search_key);
+		if (!cmpval) {
+			e = rec;
+			res = 0;
+			goto done;
 		}
+		if (cmpval < 0)
+			b = rec + 1;
+		else
+			e = rec - 1;
+	} while (b <= e);
+	//printk("%d: %d,%d,%d\n", bnode->this, b, e, rec);
+	if (rec != e && e >= 0) {
+		len = hfs_brec_lenoff(bnode, e, &off);
+		keylen = hfs_brec_keylen(bnode, e);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+	}
+done:
+	fd->record = e;
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	return res;
+}
 
-		/* get next node if necessary */
-		if ((ntype == ndIndxNode) && !(curr = hfs_brec_next(brec))) {
-			return -EIO;
-		}
-	} while (ntype == ndIndxNode);
-
-	if (key->KeyLen > tree->bthKeyLen) {
-		hfs_warn("hfs_bfind: oversized key\n");
-		hfs_brec_relse(brec, NULL);
-		return -EIO;
-	}
-
-	if (ntype != ndLeafNode) {
-		hfs_warn("hfs_bfind: invalid node type %02x in node %d of "
-		         "btree %d\n", bn->ndType, bn->node,
-		         (int)ntohl(tree->entry.cnid));
-		hfs_brec_relse(brec, NULL);
-		return -EIO;
-	}
-
-	if ((flags & HFS_BFIND_EXACT) && result) {
-		hfs_brec_relse(brec, NULL);
+/* Traverse a B*Tree from the root to a leaf finding best fit to key */
+/* Return allocated copy of node found, set recnum to best record */
+int hfs_brec_find(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	u32 data, nidx, parent;
+	int height, res;
+
+	tree = fd->tree;
+	if (fd->bnode)
+		hfs_bnode_put(fd->bnode);
+	fd->bnode = NULL;
+	nidx = tree->root;
+	if (!nidx)
 		return -ENOENT;
-	}
-
-	if (!(flags & HFS_BPATH_MASK)) {
-		hfs_brec_relse(brec, brec->bottom-1);
-	}
-
-	if (flags & HFS_BFIND_LOCK) {
-		hfs_brec_lock(brec, brec->bottom);
-	}
+	height = tree->depth;
+	res = 0;
+	parent = 0;
+	for (;;) {
+		bnode = hfs_bnode_find(tree, nidx);
+		if (IS_ERR(bnode)) {
+			res = PTR_ERR(bnode);
+			bnode = NULL;
+			break;
+		}
+		if (bnode->height != height)
+			goto invalid;
+		if (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))
+			goto invalid;
+		bnode->parent = parent;
 
-	brec->key  = brec_key(brec);
-	brec->data = bkey_record(brec->key);
+		res = __hfs_brec_find(bnode, fd);
+		if (!height)
+			break;
+		if (fd->record < 0)
+			goto release;
 
-	return result ? 1 : 0;
+		parent = nidx;
+		hfs_bnode_read(bnode, &data, fd->entryoffset, 4);
+		nidx = be32_to_cpu(data);
+		hfs_bnode_put(bnode);
+	}
+	fd->bnode = bnode;
+	return res;
+
+invalid:
+	printk("HFS+-fs: inconsistency in B*Tree (%d,%d,%d,%u,%u)\n",
+		height, bnode->height, bnode->type, nidx, parent);
+	res = -EIO;
+release:
+	hfs_bnode_put(bnode);
+	return res;
 }
 
-/*
- * hfs_bsucc()
- *
- * Description:
- *   This function overwrites '*brec' with its successor in the B-tree,
- *   obtaining the same type of access.
- * Input Variable(s):
- *   struct hfs_brec *brec: address of the (struct hfs_brec) to overwrite
- *    with its successor
- * Output Variable(s):
- *   struct hfs_brec *brec: address of the successor of the original
- *    '*brec' or to invalid data
- * Returns:
- *   int: 0 on success, or one of -EINVAL, -EIO, or -EINVAL on failure
- * Preconditions:
- *   'brec' pointers to a "valid" (struct hfs_brec)
- * Postconditions:
- *   If the given '*brec' is not "valid" -EINVAL is returned and
- *    '*brec' is unchanged.
- *   If the given 'brec' is "valid" but has no successor then -ENOENT
- *    is returned and '*brec' is invalid.
- *   If a call to hfs_bnode_find() is necessary to find the successor,
- *    but fails then -EIO is returned and '*brec' is invalid.
- *   If none of the three previous conditions prevents finding the
- *    successor of '*brec', then 0 is returned, and '*brec' is overwritten
- *    with the (struct hfs_brec) for its successor.
- *   In the cases when '*brec' is invalid, the old records is freed.
- */
-int hfs_bsucc(struct hfs_brec *brec, int count)
+int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)
 {
-	struct hfs_belem *belem;
-	struct hfs_bnode *bn;
+	int res;
 
-	if (!brec || !(belem = brec->bottom) || (belem != brec->top) ||
-	    !(bn = belem->bnr.bn) || (bn->magic != HFS_BNODE_MAGIC) ||
-	    !bn->tree || (bn->tree->magic != HFS_BTREE_MAGIC) ||
-	    !hfs_buffer_ok(bn->buf)) {
-		hfs_warn("hfs_bsucc: invalid/corrupt arguments.\n");
+	res = hfs_brec_find(fd);
+	if (res)
+		return res;
+	if (fd->entrylength > rec_len)
 		return -EINVAL;
-	}
-
-	while (count) {
-		int left = bn->ndNRecs - belem->record;
+	hfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);
+	return 0;
+}
 
-		if (left < count) {
-			struct hfs_bnode_ref old;
-			hfs_u32 node;
-
-			/* Advance to next node */
-			if (!(node = bn->ndFLink)) {
-				hfs_brec_relse(brec, belem);
-				return -ENOENT;
-			}
-			if (node == bn->node) {
-				hfs_warn("hfs_bsucc: corrupt btree\n");
-				hfs_brec_relse(brec, belem);
-				return -EIO;
+int hfs_brec_goto(struct hfs_find_data *fd, int cnt)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	int idx, res = 0;
+	u16 off, len, keylen;
+
+	bnode = fd->bnode;
+	tree = bnode->tree;
+
+	if (cnt < 0) {
+		cnt = -cnt;
+		while (cnt > fd->record) {
+			cnt -= fd->record + 1;
+			fd->record = bnode->num_recs - 1;
+			idx = bnode->prev;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(bnode);
+			bnode = hfs_bnode_find(tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
 			}
-			old = belem->bnr;
-			belem->bnr = hfs_bnode_find(brec->tree, node,
-						    belem->bnr.lock_type);
-			hfs_bnode_relse(&old);
-			if (!(bn = belem->bnr.bn)) {
-				return -EIO;
+		}
+		fd->record -= cnt;
+	} else {
+		while (cnt >= bnode->num_recs - fd->record) {
+			cnt -= bnode->num_recs - fd->record;
+			fd->record = 0;
+			idx = bnode->next;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(bnode);
+			bnode = hfs_bnode_find(tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
 			}
-			belem->record = 1;
-			count -= (left + 1);
-		} else {
-			belem->record += count;
-			break;
 		}
+		fd->record += cnt;
 	}
-	brec->key  = belem_key(belem);
-	brec->data = bkey_record(brec->key);
 
-	if (brec->key->KeyLen > brec->tree->bthKeyLen) {
-		hfs_warn("hfs_bsucc: oversized key\n");
-		hfs_brec_relse(brec, NULL);
-		return -EIO;
-	}
-
-	return 0;
+	len = hfs_brec_lenoff(bnode, fd->record, &off);
+	keylen = hfs_brec_keylen(bnode, fd->record);
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	hfs_bnode_read(bnode, fd->key, off, keylen);
+out:
+	fd->bnode = bnode;
+	return res;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/bins_del.c linuxppc-2.5-benh/fs/hfs/bins_del.c
--- /dev/shm/linux-2.5/fs/hfs/bins_del.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bins_del.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,231 +0,0 @@
-/*
- * linux/fs/hfs/bins_del.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the code common to inserting and deleting records
- * in a B-tree.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs_btree.h"
-
-/*================ File-local functions ================*/
-
-/*
- * hfs_bnode_update_key()
- *
- * Description:
- *   Updates the key for a bnode in its parent.
- *   The key change is propagated up the tree as necessary.
- * Input Variable(s):
- *   struct hfs_brec *brec: the search path to update keys in
- *   struct hfs_belem *belem: the search path element with the changed key
- *   struct hfs_bnode *bnode: the bnode with the changed key
- *   int offset: the "distance" from 'belem->bn' to 'bnode':
- *    0 if the change is in 'belem->bn',
- *    1 if the change is in its right sibling, etc.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'brec' points to a valid (struct hfs_brec)
- *   'belem' points to a valid (struct hfs_belem) in 'brec'.
- *   'bnode' points to a valid (struct hfs_bnode) which is non-empty
- *    and is 'belem->bn' or one of its siblings.
- *   'offset' is as described above.
- * Postconditions:
- *   The key change is propagated up the tree as necessary.
- */
-void hfs_bnode_update_key(struct hfs_brec *brec, struct hfs_belem *belem,
-			  struct hfs_bnode *bnode, int offset)
-{
-	int record = (--belem)->record + offset;
-	void *key = bnode_datastart(bnode) + 1;
-	int keysize = brec->tree->bthKeyLen;
-	struct hfs_belem *limit;
-
-  	memcpy(1+bnode_key(belem->bnr.bn, record), key, keysize);
-
-	/* don't trash the header */
-	if (brec->top > &brec->elem[1]) {
-		limit = brec->top;
-	} else {
-		limit = &brec->elem[1];
-	}
-
-	while ((belem > limit) && (record == 1)) {
-		record = (--belem)->record;
-		memcpy(1+belem_key(belem), key, keysize);
-	}
-}
-
-/*
- * hfs_bnode_shift_right()
- *
- * Description:
- *   Shifts some records from a node to its right neighbor.
- * Input Variable(s):
- *   struct hfs_bnode* left: the node to shift records from
- *   struct hfs_bnode* right: the node to shift records to
- *   hfs_u16 first: the number of the first record in 'left' to move to 'right'
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'left' and 'right' point to valid (struct hfs_bnode)s.
- *   'left' contains at least 'first' records.
- *   'right' has enough free space to hold the records to be moved from 'left'
- * Postconditions:
- *   The record numbered 'first' and all records after it in 'left' are
- *   placed at the beginning of 'right'.
- *   The key corresponding to 'right' in its parent is NOT updated.
- */
-void hfs_bnode_shift_right(struct hfs_bnode *left, struct hfs_bnode *right,
-			   int first)
-{
-	int i, adjust, nrecs;
-	unsigned size;
-	hfs_u16 *to, *from;
-
-	if ((first <= 0) || (first > left->ndNRecs)) {
-		hfs_warn("bad argument to shift_right: first=%d, nrecs=%d\n",
-		       first, left->ndNRecs);
-		return;
-	}
-
-	/* initialize variables */
-	nrecs = left->ndNRecs + 1 - first;
-	size = bnode_end(left) - bnode_offset(left, first);
-
-	/* move (possibly empty) contents of right node forward */
-	memmove(bnode_datastart(right) + size,
-		bnode_datastart(right), 
-		bnode_end(right) - sizeof(struct NodeDescriptor));
-
-	/* copy in new records */
-	memcpy(bnode_datastart(right), bnode_key(left,first), size);
-
-	/* fix up offsets in right node */
-	i = right->ndNRecs + 1;
-	from = RECTBL(right, i);
-	to = from - nrecs;
-	while (i--) {
-		hfs_put_hs(hfs_get_hs(from++) + size, to++);
-	}
-	adjust = sizeof(struct NodeDescriptor) - bnode_offset(left, first);
-	i = nrecs-1;
-	from = RECTBL(left, first+i);
-	while (i--) {
-		hfs_put_hs(hfs_get_hs(from++) + adjust, to++);
-	}
-
-	/* fix record counts */
-	left->ndNRecs -= nrecs;
-	right->ndNRecs += nrecs;
-}
-
-/*
- * hfs_bnode_shift_left()
- *
- * Description:
- *   Shifts some records from a node to its left neighbor.
- * Input Variable(s):
- *   struct hfs_bnode* left: the node to shift records to
- *   struct hfs_bnode* right: the node to shift records from
- *   hfs_u16 last: the number of the last record in 'right' to move to 'left'
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'left' and 'right' point to valid (struct hfs_bnode)s.
- *   'right' contains at least 'last' records.
- *   'left' has enough free space to hold the records to be moved from 'right'
- * Postconditions:
- *   The record numbered 'last' and all records before it in 'right' are
- *   placed at the end of 'left'.
- *   The key corresponding to 'right' in its parent is NOT updated.
- */
-void hfs_bnode_shift_left(struct hfs_bnode *left, struct hfs_bnode *right,
-			  int last)
-{
-	int i, adjust, nrecs;
-	unsigned size;
-	hfs_u16 *to, *from;
-
-	if ((last <= 0) || (last > right->ndNRecs)) {
-		hfs_warn("bad argument to shift_left: last=%d, nrecs=%d\n",
-		       last, right->ndNRecs);
-		return;
-	}
-
-	/* initialize variables */
-	size = bnode_offset(right, last + 1) - sizeof(struct NodeDescriptor);
-
-	/* copy records to left node */
-	memcpy(bnode_dataend(left), bnode_datastart(right), size);
-
-	/* move (possibly empty) remainder of right node backward */
-	memmove(bnode_datastart(right), bnode_datastart(right) + size, 
-			bnode_end(right) - bnode_offset(right, last + 1));
-
-	/* fix up offsets */
-	nrecs = left->ndNRecs;
-	i = last;
-	from = RECTBL(right, 2);
-	to = RECTBL(left, nrecs + 2);
-	adjust = bnode_offset(left, nrecs + 1) - sizeof(struct NodeDescriptor);
-	while (i--) {
-		hfs_put_hs(hfs_get_hs(from--) + adjust, to--);
-	}
-	i = right->ndNRecs + 1 - last;
-	++from;
-	to = RECTBL(right, 1);
-	while (i--) {
-		hfs_put_hs(hfs_get_hs(from--) - size, to--);
-	}
-
-	/* fix record counts */
-	left->ndNRecs += last;
-	right->ndNRecs -= last;
-}
-
-/*
- * hfs_bnode_in_brec()
- *
- * Description:
- *   Determines whethet a given bnode is part of a given brec.
- *   This is used to avoid deadlock in the case of a corrupted b-tree.
- * Input Variable(s):
- *   hfs_u32 node: the number of the node to check for.
- *   struct hfs_brec* brec: the brec to check in.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   int: 1 it found, 0 if not
- * Preconditions:
- *   'brec' points to a valid struct hfs_brec.
- * Postconditions:
- *   'brec' is unchanged.
- */
-int hfs_bnode_in_brec(hfs_u32 node, const struct hfs_brec *brec)
-{
-	const struct hfs_belem *belem = brec->bottom;
-
-	while (belem && (belem >= brec->top)) {
-		if (belem->bnr.bn && (belem->bnr.bn->node == node)) {
-			return 1;
-		}
-		--belem;
-	}
-	return 0;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/binsert.c linuxppc-2.5-benh/fs/hfs/binsert.c
--- /dev/shm/linux-2.5/fs/hfs/binsert.c	2002-07-20 17:49:48.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/binsert.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,536 +0,0 @@
-/*
- * linux/fs/hfs/binsert.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the code to insert records in a B-tree.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs_btree.h"
-
-/*================ File-local functions ================*/
-/*
- * binsert_nonfull()
- *
- * Description:
- *   Inserts a record in a given bnode known to have sufficient space.
- * Input Variable(s):
- *   struct hfs_brec* brec: pointer to the brec for the insertion
- *   struct hfs_belem* belem: the element in the search path to insert in
- *   struct hfs_bkey* key: pointer to the key for the record to insert
- *   void* data: pointer to the record to insert
- *   hfs_u16 keysize: size of the key to insert
- *   hfs_u16 datasize: size of the record to insert
- * Output Variable(s):
- *   NONE
- * Returns:
- *   NONE
- * Preconditions:
- *   'brec' points to a valid (struct hfs_brec).
- *   'belem' points to a valid (struct hfs_belem) in 'brec', the node
- *    of which has enough free space to insert 'key' and 'data'.
- *   'key' is a pointer to a valid (struct hfs_bkey) of length 'keysize'
- *    which, in sorted order, belongs at the location indicated by 'brec'.
- *   'data' is non-NULL an points to appropriate data of length 'datasize'
- * Postconditions:
- *   The record has been inserted in the position indicated by 'brec'.
- */
-static void binsert_nonfull(struct hfs_brec *brec, struct hfs_belem *belem,
-			    const struct hfs_bkey *key, const void *data,
-			    hfs_u8 keysize, hfs_u16 datasize)
-{
-	int i, rec, nrecs, size, tomove;
-	hfs_u8 *start;
-	struct hfs_bnode *bnode = belem->bnr.bn;
-
-	rec = ++(belem->record);
-	size = ROUND(keysize+1) + datasize;
-	nrecs = bnode->ndNRecs + 1;
-	tomove = bnode_offset(bnode, nrecs) - bnode_offset(bnode, rec);
-	
-	/* adjust the record table */
-	for (i = nrecs; i >= rec; --i) {
-		hfs_put_hs(bnode_offset(bnode,i) + size, RECTBL(bnode,i+1));
-	}
-
-	/* make room */
-	start = bnode_key(bnode, rec);
-	memmove(start + size, start, tomove);
-
-	/* copy in the key and the data*/
-	*start = keysize;
-	keysize = ROUND(keysize+1);
-	memcpy(start + 1, (hfs_u8 *)key + 1, keysize-1);
-	memcpy(start + keysize, data, datasize);
-
-	/* update record count */
-	++bnode->ndNRecs;
-}
-
-/*
- * add_root()
- *
- * Description:
- *   Adds a new root to a B*-tree, increasing its height.
- * Input Variable(s):
- *   struct hfs_btree *tree: the tree to add a new root to
- *   struct hfs_bnode *left: the new root's first child or NULL
- *   struct hfs_bnode *right: the new root's second child or NULL
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'tree' points to a valid (struct hfs_btree).
- *   'left' and 'right' point to valid (struct hfs_bnode)s, which
- *    resulted from splitting the old root node, or are both NULL
- *    if there was no root node before.
- * Postconditions:
- *   Upon success a new root node is added to 'tree' with either
- *    two children ('left' and 'right') or none.
- */
-static void add_root(struct hfs_btree *tree,
-		     struct hfs_bnode *left,
-		     struct hfs_bnode *right)
-{
-	struct hfs_bnode_ref bnr;
-	struct hfs_bnode *root;
-	struct hfs_bkey *key;
-	int keylen = tree->bthKeyLen;
-
-	if (left && !right) {
-		hfs_warn("add_root: LEFT but no RIGHT\n");
-		return;
-	}
-
-	bnr = hfs_bnode_alloc(tree);
-	if (!(root = bnr.bn)) {
-		return;
-	}
-
-	root->sticky = HFS_STICKY;
-	tree->root = root;
-	tree->bthRoot = root->node;
-	++tree->bthDepth;
-
-	root->ndNHeight = tree->bthDepth;
-	root->ndFLink = 0;
-	root->ndBLink = 0;
-
-	if (!left) {
-		/* tree was empty */
-		root->ndType  = ndLeafNode;
-		root->ndNRecs = 0;
-
-		tree->bthFNode = root->node;
-		tree->bthLNode = root->node;
-	} else {
-		root->ndType  = ndIndxNode;
-		root->ndNRecs = 2;
-
-		hfs_put_hs(sizeof(struct NodeDescriptor) + ROUND(1+keylen) +
-			   sizeof(hfs_u32), RECTBL(root, 2));
-		key = bnode_key(root, 1);
-		key->KeyLen = keylen;
-		memcpy(key->value,
-		       ((struct hfs_bkey *)bnode_key(left, 1))->value, keylen);
-		hfs_put_hl(left->node, bkey_record(key));
-		
-		hfs_put_hs(sizeof(struct NodeDescriptor) + 2*ROUND(1+keylen) +
-			   2*sizeof(hfs_u32), RECTBL(root, 3));
-		key = bnode_key(root, 2);
-		key->KeyLen = keylen;
-		memcpy(key->value,
-		       ((struct hfs_bkey *)bnode_key(right, 1))->value, keylen);
-		hfs_put_hl(right->node, bkey_record(key));
-
-		/* the former root (left) is now just a normal node */
-		left->sticky = HFS_NOT_STICKY;
-		if ((left->next = bhash(tree, left->node))) {
-			left->next->prev = left;
-		}
-		bhash(tree, left->node) = left;
-	}
-	hfs_bnode_relse(&bnr);
-	tree->dirt = 1;
-}
-
-/*
- * insert_empty_bnode()
- *
- * Description:
- *   Adds an empty node to the right of 'left'.
- * Input Variable(s):
- *   struct hfs_btree *tree: the tree to add a node to
- *   struct hfs_bnode *left: the node to add a node after
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_bnode_ref *: reference to the new bnode.
- * Preconditions:
- *   'tree' points to a valid (struct hfs_btree) with at least 1 free node.
- *   'left' points to a valid (struct hfs_bnode) belonging to 'tree'.
- * Postconditions:
- *   If NULL is returned then 'tree' and 'left' are unchanged.
- *   Otherwise a node with 0 records is inserted in the tree to the right
- *   of the node 'left'.  The 'ndFLink' of 'left' and the 'ndBLink' of
- *   the former right-neighbor of 'left' (if one existed) point to the
- *   new node.	If 'left' had no right neighbor and is a leaf node the
- *   the 'bthLNode' of 'tree' points to the new node.  The free-count and
- *   bitmap for 'tree' are kept current by hfs_bnode_alloc() which supplies
- *   the required node.
- */
-static struct hfs_bnode_ref insert_empty_bnode(struct hfs_btree *tree,
-					       struct hfs_bnode *left)
-{
-	struct hfs_bnode_ref retval;
-	struct hfs_bnode_ref right;
-
-	retval = hfs_bnode_alloc(tree);
-	if (!retval.bn) {
-		hfs_warn("hfs_binsert: out of bnodes?.\n");
-		goto done;
-	}
-	retval.bn->sticky = HFS_NOT_STICKY;
-	if ((retval.bn->next = bhash(tree, retval.bn->node))) {
-		retval.bn->next->prev = retval.bn;
-	}
-	bhash(tree, retval.bn->node) = retval.bn;
-
-	if (left->ndFLink) {
-		right = hfs_bnode_find(tree, left->ndFLink, HFS_LOCK_WRITE);
-		if (!right.bn) {
-			hfs_warn("hfs_binsert: corrupt btree.\n");
-			hfs_bnode_bitop(tree, retval.bn->node, 0);
-			hfs_bnode_relse(&retval);
-			goto done;
-		}
-		right.bn->ndBLink = retval.bn->node;
-		hfs_bnode_relse(&right);
-	} else if (left->ndType == ndLeafNode) {
-		tree->bthLNode = retval.bn->node;
-		tree->dirt = 1;
-	}
-
-	retval.bn->ndFLink   = left->ndFLink;
-	retval.bn->ndBLink   = left->node;
-	retval.bn->ndType    = left->ndType;
-	retval.bn->ndNHeight = left->ndNHeight;
-	retval.bn->ndNRecs   = 0;
-
-	left->ndFLink = retval.bn->node;
-
- done:
-	return retval;
-}
-
-/*
- * split()
- *
- * Description:
- *   Splits an over full node during insertion.
- *   Picks the split point that results in the most-nearly equal
- *   space usage in the new and old nodes.
- * Input Variable(s):
- *   struct hfs_belem *elem: the over full node.
- *   int size: the number of bytes to be used by the new record and its key.
- * Output Variable(s):
- *   struct hfs_belem *elem: changed to indicate where the new record
- *    should be inserted.
- * Returns:
- *   struct hfs_bnode_ref: reference to the new bnode.
- * Preconditions:
- *   'elem' points to a valid path element corresponding to the over full node.
- *   'size' is positive.
- * Postconditions:
- *   The records in the node corresponding to 'elem' are redistributed across
- *   the old and new nodes so that after inserting the new record, the space
- *   usage in these two nodes is as equal as possible.
- *   'elem' is updated so that a call to binsert_nonfull() will insert the
- *   new record in the correct location.
- */
-static inline struct hfs_bnode_ref split(struct hfs_belem *elem, int size)
-{
-	struct hfs_bnode *bnode = elem->bnr.bn;
-	int nrecs, cutoff, index, tmp, used, in_right;
-	struct hfs_bnode_ref right;
-
-	right = insert_empty_bnode(bnode->tree, bnode);
-	if (right.bn) {
-		nrecs = bnode->ndNRecs;
-		cutoff = (size + bnode_end(bnode) -
-			      sizeof(struct NodeDescriptor) +
-			      (nrecs+1)*sizeof(hfs_u16))/2;
-		used = 0;
-		in_right = 1;
-		/* note that this only works because records sizes are even */
-		for (index=1; index <= elem->record; ++index) {
-			tmp = (sizeof(hfs_u16) + bnode_rsize(bnode, index))/2;
-			used += tmp;
-			if (used > cutoff) {
-				goto found;
-			}
-			used += tmp;
-		}
-		tmp = (size + sizeof(hfs_u16))/2;
-		used += tmp;
-		if (used > cutoff) {
-			goto found;
-		}
-		in_right = 0;
-		used += tmp;
-		for (; index <= nrecs; ++index) {
-			tmp = (sizeof(hfs_u16) + bnode_rsize(bnode, index))/2;
-			used += tmp;
-			if (used > cutoff) {
-				goto found;
-			}
-			used += tmp;
-		}
-		/* couldn't find the split point! */
-		hfs_bnode_relse(&right);
-	}
-	return right;
-
-found:
-	if (in_right) {
-		elem->bnr = right;
-		elem->record -= index-1;
-	}
-	hfs_bnode_shift_right(bnode, right.bn, index);
-
-	return right;
-}
-
-/*
- * binsert()
- *
- * Description:
- *   Inserts a record in a tree known to have enough room, even if the
- *   insertion requires the splitting of nodes.
- * Input Variable(s):
- *    struct hfs_brec *brec: partial path to the node to insert in
- *    const struct hfs_bkey *key: key for the new record
- *    const void *data: data for the new record
- *    hfs_u8 keysize: size of the key
- *    hfs_u16 datasize: size of the data
- *    int reserve: number of nodes reserved in case of splits
- * Output Variable(s):
- *    *brec = NULL
- * Returns:
- *    int: 0 on success, error code on failure
- * Preconditions:
- *    'brec' points to a valid (struct hfs_brec) corresponding to a
- *     record in a leaf node, after which a record is to be inserted,
- *     or to "record 0" of the leaf node if the record is to be inserted
- *     before all existing records in the node.	 The (struct hfs_brec)
- *     includes all ancestors of the leaf node that are needed to
- *     complete the insertion including the parents of any nodes that
- *     will be split.
- *    'key' points to a valid (struct hfs_bkey) which is appropriate
- *     to this tree, and which belongs at the insertion point.
- *    'data' points data appropriate for the indicated node.
- *    'keysize' gives the size in bytes of the key.
- *    'datasize' gives the size in bytes of the data.
- *    'reserve' gives the number of nodes that have been reserved in the
- *     tree to allow for splitting of nodes.
- * Postconditions:
- *    All 'reserve'd nodes have been either used or released.
- *    *brec = NULL
- *    On success the key and data have been inserted at the indicated
- *    location in the tree, all appropriate fields of the in-core data
- *    structures have been changed and updated versions of the on-disk
- *    data structures have been scheduled for write-back to disk.
- *    On failure the B*-tree is probably invalid both on disk and in-core.
- *
- *    XXX: Some attempt at repair might be made in the event of failure,
- *    or the fs should be remounted read-only so things don't get worse.
- */
-static int binsert(struct hfs_brec *brec, const struct hfs_bkey *key,
-		   const void *data, hfs_u8 keysize, hfs_u16 datasize,
-		   int reserve)
-{
-	struct hfs_bnode_ref left, right, other;
-	struct hfs_btree *tree = brec->tree;
-	struct hfs_belem *belem = brec->bottom;
-	int tmpsize = 1 + tree->bthKeyLen;
-	struct hfs_bkey *tmpkey = hfs_malloc(tmpsize);
-	hfs_u32 node;
-	
-	while ((belem >= brec->top) && (belem->flags & HFS_BPATH_OVERFLOW)) {
-		left = belem->bnr;
-		if (left.bn->ndFLink &&
-                    hfs_bnode_in_brec(left.bn->ndFLink, brec)) {
-			hfs_warn("hfs_binsert: corrupt btree\n");
-			tree->reserved -= reserve;
-			hfs_free(tmpkey, tmpsize);
-			return -EIO;
-		}
-			
-		right = split(belem, ROUND(keysize+1) + ROUND(datasize));
-		--reserve;
-		--tree->reserved;
-		if (!right.bn) {
-			hfs_warn("hfs_binsert: unable to split node!\n");
-			tree->reserved -= reserve;
-			hfs_free(tmpkey, tmpsize);
-			return -ENOSPC;
-		}
-		binsert_nonfull(brec, belem, key, data, keysize, datasize);
-	
-		if (belem->bnr.bn == left.bn) {
-			other = right;
-			if (belem->record == 1) {
-				hfs_bnode_update_key(brec, belem, left.bn, 0);
-			}
-		} else {
-			other = left;
-		}
-
-		if (left.bn->node == tree->root->node) {
-			add_root(tree, left.bn, right.bn);
-			hfs_bnode_relse(&other);
-			goto done;
-		}
-
-		data = &node;
-		datasize = sizeof(node);
-		node = htonl(right.bn->node);
-		key = tmpkey;
-		keysize = tree->bthKeyLen;
-		memcpy(tmpkey, bnode_key(right.bn, 1), keysize+1);
-		hfs_bnode_relse(&other);
-		
-		--belem;
-	}
-
-	if (belem < brec->top) {
-		hfs_warn("hfs_binsert: Missing parent.\n");
-		tree->reserved -= reserve;
-		hfs_free(tmpkey, tmpsize);
-		return -EIO;
-	}
-
-	binsert_nonfull(brec, belem, key, data, keysize, datasize);
-
-done:
-	tree->reserved -= reserve;
-	hfs_free(tmpkey, tmpsize);
-	return 0;
-}
-
-/*================ Global functions ================*/
-
-/*
- * hfs_binsert()
- *
- * Description:
- *   This function inserts a new record into a b-tree.
- * Input Variable(s):
- *   struct hfs_btree *tree: pointer to the (struct hfs_btree) to insert in
- *   struct hfs_bkey *key: pointer to the (struct hfs_bkey) to insert
- *   void *data: pointer to the data to associate with 'key' in the b-tree
- *   unsigned int datasize: the size of the data
- * Output Variable(s):
- *   NONE
- * Returns:
- *   int: 0 on success, error code on failure
- * Preconditions:
- *   'tree' points to a valid (struct hfs_btree)
- *   'key' points to a valid (struct hfs_bkey)
- *   'data' points to valid memory of length 'datasize'
- * Postconditions:
- *   If zero is returned then the record has been inserted in the
- *    indicated location updating all in-core data structures and
- *    scheduling all on-disk data structures for write-back.
- */
-int hfs_binsert(struct hfs_btree *tree, const struct hfs_bkey *key,
-		const void *data, hfs_u16 datasize)
-{ 
-	struct hfs_brec brec;
-	struct hfs_belem *belem;
-	int err, reserve, retval;
-	hfs_u8 keysize;
-
-	if (!tree || (tree->magic != HFS_BTREE_MAGIC) || !key || !data) {
-		hfs_warn("hfs_binsert: invalid arguments.\n");
-		return -EINVAL;
-	}
-
-	if (key->KeyLen > tree->bthKeyLen) {
-		hfs_warn("hfs_binsert: oversized key\n");
-		return -EINVAL;
-	}
-
-restart:
-	if (!tree->bthNRecs) {
-		/* create the root bnode */
-		add_root(tree, NULL, NULL);
-		if (!hfs_brec_init(&brec, tree, HFS_BFIND_INSERT)) {
-			hfs_warn("hfs_binsert: failed to create root.\n");
-			return -ENOSPC;
-		}
-	} else {
-		err = hfs_bfind(&brec, tree, key, HFS_BFIND_INSERT);
-		if (err < 0) {
-			hfs_warn("hfs_binsert: hfs_brec_find failed.\n");
-			return err;
-		} else if (err == 0) {
-			hfs_brec_relse(&brec, NULL);
-			return -EEXIST;
-		}
-	}
-
-	keysize = key->KeyLen;
-	datasize = ROUND(datasize);
-	belem = brec.bottom;
-	belem->flags = 0;
-	if (bnode_freespace(belem->bnr.bn) <
-			    (sizeof(hfs_u16) + ROUND(keysize+1) + datasize)) {
-		belem->flags |= HFS_BPATH_OVERFLOW;
-	}
-	if (belem->record == 0) {
-		belem->flags |= HFS_BPATH_FIRST;
-	}
-
-	if (!belem->flags) {
-		hfs_brec_lock(&brec, brec.bottom);
-		reserve = 0;
-	} else {
-		reserve = brec.bottom - brec.top;
-		if (brec.top == 0) {
-			++reserve;
-		}
-		/* make certain we have enough nodes to proceed */
-		if ((tree->bthFree - tree->reserved) < reserve) {
-			hfs_brec_relse(&brec, NULL);
-			down(&tree->sem);
-			if ((tree->bthFree - tree->reserved) < reserve) {
-				hfs_btree_extend(tree);
-			}
-			up(&tree->sem);
-			if ((tree->bthFree - tree->reserved) < reserve) {
-				return -ENOSPC;
-			} else {
-				goto restart;
-			}
-		}
-		tree->reserved += reserve;
-		hfs_brec_lock(&brec, NULL);
-	}
-
-	retval = binsert(&brec, key, data, keysize, datasize, reserve);
-	hfs_brec_relse(&brec, NULL);
-	if (!retval) {
-		++tree->bthNRecs;
-		tree->dirt = 1;
-	}
-	return retval;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/bitmap.c linuxppc-2.5-benh/fs/hfs/bitmap.c
--- /dev/shm/linux-2.5/fs/hfs/bitmap.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bitmap.c	2003-12-24 03:48:17.000000000 +0000
@@ -16,69 +16,101 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
-
-/*================ Global functions ================*/
+#include "hfs_fs.h"
 
 /*
- * hfs_vbm_count_free()
+ * hfs_find_zero_bit()
  *
  * Description:
- *   Count the number of consecutive cleared bits in the bitmap blocks of
- *   the hfs MDB starting at bit number 'start'.  'mdb' had better
- *   be locked or the indicated number of blocks may be no longer free,
- *   when this functions returns!
- * Input Variable(s):
- *   struct hfs_mdb *mdb: Pointer to the hfs MDB
- *   hfs_u16 start: bit number to start at
- * Output Variable(s):
- *   NONE
- * Returns:
- *   The number of consecutive cleared bits starting at bit 'start'
- * Preconditions:
- *   'mdb' points to a "valid" (struct hfs_mdb).
- * Postconditions:
- *   NONE
+ *  Given a block of memory, its length in bits, and a starting bit number,
+ *  determine the number of the first zero bits (in left-to-right ordering)
+ *  in that range.
+ *
+ *  Returns >= 'size' if no zero bits are found in the range.
+ *
+ *  Accesses memory in 32-bit aligned chunks of 32-bits and thus
+ *  may read beyond the 'size'th bit.
  */
-hfs_u16 hfs_vbm_count_free(const struct hfs_mdb *mdb, hfs_u16 start)
+static u32 hfs_find_set_zero_bits(u32 *bitmap, u32 size, u32 offset, u32 *max)
 {
-	hfs_u16 block_nr;	/* index of the current bitmap block */
-	hfs_u16 bit_nr;		/* index of the current bit in block */
-	hfs_u16 count;		/* number of bits found so far */
-	hfs_u16 len;		/* number of bits found in this block */
-	hfs_u16 max_block;	/* index of last bitmap block */
-	hfs_u16 max_bits;	/* index of last bit in block */
-
-	/* is this a valid HFS MDB? */
-	if (!mdb) {
-		return 0;
+	u32 *curr, *end;
+	u32 val, mask, start, len;
+	int i;
+
+	len = *max;
+	if (!len)
+		return size;
+
+	curr = bitmap + (offset / 32);
+	end = bitmap + ((size + 31) / 32);
+
+	/* scan the first partial u32 for zero bits */
+	val = *curr;
+	if (~val) {
+		val = be32_to_cpu(val);
+		i = offset % 32;
+		mask = (1U << 31) >> i;
+		for (; i < 32; mask >>= 1, i++) {
+			if (!(val & mask))
+				goto found;
+		}
 	}
 
-	block_nr = start / HFS_BM_BPB;
-	bit_nr	 = start % HFS_BM_BPB;
-	max_block = (mdb->fs_ablocks + HFS_BM_BPB - 1) / HFS_BM_BPB - 1;
-
-	count = 0;
-	while (block_nr <= max_block) {
-		if (block_nr != max_block) {
-			max_bits = HFS_BM_BPB;
-		} else {
-			max_bits = mdb->fs_ablocks % HFS_BM_BPB;
+	/* scan complete u32s for the first zero bit */
+	while (++curr < end) {
+		val = *curr;
+		if (~val) {
+			val = be32_to_cpu(val);
+			mask = 1 << 31;
+			for (i = 0; i < 32; mask >>= 1, i++) {
+				if (!(val & mask))
+					goto found;
+			}
 		}
+	}
+	return size;
 
-		len=hfs_count_zero_bits(hfs_buffer_data(mdb->bitmap[block_nr]),
-					max_bits, bit_nr);
-		count += len;
-
-		/* see if we fell short of the end of this block */
-		if ((len + bit_nr) < max_bits) {
+found:
+	start = (curr - bitmap) * 32 + i;
+	if (start >= size)
+		return start;
+	/* do any partial u32 at the start */
+	len = min(size - start, len);
+	while (1) {
+		val |= mask;
+		if (++i >= 32)
+			break;
+		mask >>= 1;
+		if (!--len || val & mask)
+			goto done;
+	}
+	if (!--len)
+		goto done;
+	*curr++ = cpu_to_be32(val);
+	/* do full u32s */
+	while (1) {
+		val = be32_to_cpu(*curr);
+		if (len < 32)
+			break;
+		if (val) {
+			len = 32;
 			break;
 		}
-
-		++block_nr;
-		bit_nr = 0;
+		*curr++ = 0xffffffffU;
+		len -= 32;
 	}
-	return count;
+	/* do any partial u32 at end */
+	mask = 1U << 31;
+	for (i = 0; i < len; i++) {
+		if (val & mask)
+			break;
+		val |= mask;
+		mask >>= 1;
+	}
+done:
+	*curr = cpu_to_be32(val);
+	*max = (curr - bitmap) * 32 + i - start;
+	return start;
 }
 
 /*
@@ -92,10 +124,10 @@ hfs_u16 hfs_vbm_count_free(const struct 
  *   the bit number stored in 's_alloc_ptr' of the MDB.
  * Input Variable(s):
  *   struct hfs_mdb *mdb: Pointer to the hfs MDB
- *   hfs_u16 *num_bits: Pointer to the number of cleared bits
+ *   u16 *num_bits: Pointer to the number of cleared bits
  *     to search for
  * Output Variable(s):
- *   hfs_u16 *num_bits: The number of consecutive clear bits of the
+ *   u16 *num_bits: The number of consecutive clear bits of the
  *     returned range. If the bitmap is fragmented, this will be less than
  *     requested and it will be zero, when the disk is full.
  * Returns:
@@ -103,198 +135,42 @@ hfs_u16 hfs_vbm_count_free(const struct 
  *   found. When 'num_bits' is zero, this is invalid!
  * Preconditions:
  *   'mdb' points to a "valid" (struct hfs_mdb).
- *   'num_bits' points to a variable of type (hfs_u16), which contains
+ *   'num_bits' points to a variable of type (u16), which contains
  *	the number of cleared bits to find.
  * Postconditions:
  *   'num_bits' is set to the length of the found sequence.
  */
-hfs_u16 hfs_vbm_search_free(const struct hfs_mdb *mdb, hfs_u16 *num_bits)
+u32 hfs_vbm_search_free(struct super_block *sb, u32 goal, u32 *num_bits)
 {
-	hfs_u16 block_nr; /* index of the current bitmap block */
-
-	/* position and length of current portion of a run */
-	hfs_u16 cur_pos, cur_len;
+	void *bitmap;
+	u32 pos;
 
-	/* position and length of current complete run */
-	hfs_u16 pos=0, len=0;
-	
-	/* position and length of longest complete run */
-	hfs_u16 longest_pos=0, longest_len=0;
-
-	void *bitmap; /* contents of the current bitmap block */
-	hfs_u16 max_block; /* upper limit of outer loop */
-	hfs_u16 max_bits; /* upper limit of inner loop */
-
-	/* is this a valid HFS MDB? */
-	if (!mdb) {
-		*num_bits = 0;
-		hfs_warn("hfs_vbm_search_free: not a valid MDB\n");
-		return 0;
-	}
-	
 	/* make sure we have actual work to perform */
-	if (!(*num_bits)) {
+	if (!*num_bits)
 		return 0;
-	}
 
-	max_block = (mdb->fs_ablocks+HFS_BM_BPB-1) / HFS_BM_BPB - 1;
-	
-	/* search all bitmap blocks */
-	for (block_nr = 0; block_nr <= max_block; block_nr++) {
-		bitmap = hfs_buffer_data(mdb->bitmap[block_nr]);
-
-		if (block_nr != max_block) {
-			max_bits = HFS_BM_BPB;
-		} else {
-			max_bits = mdb->fs_ablocks % HFS_BM_BPB;
-		}
-
-		cur_pos = 0;
-		do {
-			cur_len = hfs_count_zero_bits(bitmap, max_bits,
-						      cur_pos);
-			len += cur_len;
-			if (len > longest_len) {
-				longest_pos = pos;
-				longest_len = len;
-				if (len >= *num_bits) {
-					goto search_end;
-				}
-			}
-			if ((cur_pos + cur_len) == max_bits) {
-				break; /* zeros may continue into next block */
-			}
-
-			/* find start of next run of zeros */
-			cur_pos = hfs_find_zero_bit(bitmap, max_bits,
-						    cur_pos + cur_len);
-			pos = cur_pos + HFS_BM_BPB*block_nr;
-			len = 0;
-		} while (cur_pos < max_bits);
-	}
+	down(&HFS_SB(sb)->bitmap_lock);
+	bitmap = HFS_SB(sb)->bitmap;
 
-search_end:
-	*num_bits = longest_len;
-	return longest_pos;
-}
-
-
-/*
- * hfs_set_vbm_bits()
- *
- * Description:
- *   Set the requested bits in the volume bitmap of the hfs filesystem
- * Input Variable(s):
- *   struct hfs_mdb *mdb: Pointer to the hfs MDB
- *   hfs_u16 start: The offset of the first bit
- *   hfs_u16 count: The number of bits
- * Output Variable(s):
- *   None
- * Returns:
- *    0: no error
- *   -1: One of the bits was already set.  This is a strange
- *	 error and when it happens, the filesystem must be repaired!
- *   -2: One or more of the bits are out of range of the bitmap.
- *   -3: The 's_magic' field of the MDB does not match
- * Preconditions:
- *   'mdb' points to a "valid" (struct hfs_mdb).
- * Postconditions:
- *   Starting with bit number 'start', 'count' bits in the volume bitmap
- *   are set. The affected bitmap blocks are marked "dirty", the free
- *   block count of the MDB is updated and the MDB is marked dirty.
- */
-int hfs_set_vbm_bits(struct hfs_mdb *mdb, hfs_u16 start, hfs_u16 count)
-{
-	hfs_u16 block_nr;	/* index of the current bitmap block */
-	hfs_u16 u32_nr;		/* index of the current hfs_u32 in block */
-	hfs_u16 bit_nr;		/* index of the current bit in hfs_u32 */
-	hfs_u16 left = count;	/* number of bits left to be set */
-	hfs_u32 *bitmap;	/* the current bitmap block's contents */
-
-	/* is this a valid HFS MDB? */
-	if (!mdb) {
-		return -3;
-	}
-
-	/* is there any actual work to be done? */
-	if (!count) {
-		return 0;
-	}
-
-	/* are all of the bits in range? */
-	if ((start + count) > mdb->fs_ablocks) {
-		return -2;
-	}
-
-	block_nr = start / HFS_BM_BPB;
-	u32_nr = (start % HFS_BM_BPB) / 32;
-	bit_nr = start % 32;
-
-	/* bitmap is always on a 32-bit boundary */
-	bitmap = (hfs_u32 *)hfs_buffer_data(mdb->bitmap[block_nr]);
-
-	/* do any partial hfs_u32 at the start */
-	if (bit_nr != 0) {
-		while ((bit_nr < 32) && left) {
-			if (hfs_set_bit(bit_nr, bitmap + u32_nr)) {
-				hfs_buffer_dirty(mdb->bitmap[block_nr]);
-				return -1;
-			}
-			++bit_nr;
-			--left;
-		}
-		bit_nr=0;
-
-		/* advance u32_nr and check for end of this block */
-		if (++u32_nr > 127) {
-			u32_nr = 0;
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			++block_nr;
-			/* bitmap is always on a 32-bit boundary */
-			bitmap = (hfs_u32 *)
-					hfs_buffer_data(mdb->bitmap[block_nr]);
-		}
-	}
-
-	/* do full hfs_u32s */
-	while (left > 31) {
-		if (bitmap[u32_nr] != ((hfs_u32)0)) {
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			return -1;
-		}
-		bitmap[u32_nr] = ~((hfs_u32)0);
-		left -= 32;
-
-		/* advance u32_nr and check for end of this block */
-		if (++u32_nr > 127) {
-			u32_nr = 0;
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			++block_nr;
-			/* bitmap is always on a 32-bit boundary */
-			bitmap = (hfs_u32 *)
-					hfs_buffer_data(mdb->bitmap[block_nr]);
+	pos = hfs_find_set_zero_bits(bitmap, HFS_SB(sb)->fs_ablocks, goal, num_bits);
+	if (pos >= HFS_SB(sb)->fs_ablocks) {
+		if (goal)
+			pos = hfs_find_set_zero_bits(bitmap, goal, 0, num_bits);
+		if (pos >= HFS_SB(sb)->fs_ablocks) {
+			*num_bits = pos = 0;
+			goto out;
 		}
 	}
 
-			
-	/* do any partial hfs_u32 at end */
-	while (left) {
-		if (hfs_set_bit(bit_nr, bitmap + u32_nr)) {
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			return -1;
-		}
-		++bit_nr;
-		--left;
-	}
-
-	hfs_buffer_dirty(mdb->bitmap[block_nr]);
-	mdb->free_ablocks -= count;
-
-	/* successful completion */
-	hfs_mdb_dirty(mdb->sys_mdb);
-	return 0;
+	dprint(DBG_BITMAP, "alloc_bits: %u,%u\n", pos, *num_bits);
+	HFS_SB(sb)->free_ablocks -= *num_bits;
+	hfs_bitmap_dirty(sb);
+out:
+	up(&HFS_SB(sb)->bitmap_lock);
+	return pos;
 }
 
+
 /*
  * hfs_clear_vbm_bits()
  *
@@ -302,8 +178,8 @@ int hfs_set_vbm_bits(struct hfs_mdb *mdb
  *   Clear the requested bits in the volume bitmap of the hfs filesystem
  * Input Variable(s):
  *   struct hfs_mdb *mdb: Pointer to the hfs MDB
- *   hfs_u16 start: The offset of the first bit
- *   hfs_u16 count: The number of bits
+ *   u16 start: The offset of the first bit
+ *   u16 count: The number of bits
  * Output Variable(s):
  *   None
  * Returns:
@@ -311,7 +187,6 @@ int hfs_set_vbm_bits(struct hfs_mdb *mdb
  *   -1: One of the bits was already clear.  This is a strange
  *	 error and when it happens, the filesystem must be repaired!
  *   -2: One or more of the bits are out of range of the bitmap.
- *   -3: The 's_magic' field of the MDB does not match
  * Preconditions:
  *   'mdb' points to a "valid" (struct hfs_mdb).
  * Postconditions:
@@ -319,94 +194,54 @@ int hfs_set_vbm_bits(struct hfs_mdb *mdb
  *   are cleared. The affected bitmap blocks are marked "dirty", the free
  *   block count of the MDB is updated and the MDB is marked dirty.
  */
-int hfs_clear_vbm_bits(struct hfs_mdb *mdb, hfs_u16 start, hfs_u16 count)
+int hfs_clear_vbm_bits(struct super_block *sb, u16 start, u16 count)
 {
-	hfs_u16 block_nr;	/* index of the current bitmap block */
-	hfs_u16 u32_nr;		/* index of the current hfs_u32 in block */
-	hfs_u16 bit_nr;		/* index of the current bit in hfs_u32 */
-	hfs_u16 left = count;	/* number of bits left to be set */
-	hfs_u32 *bitmap;	/* the current bitmap block's contents */
-
-	/* is this a valid HFS MDB? */
-	if (!mdb) {
-		return -3;
-	}
+	u32 *curr;
+	u32 mask;
+	int i, len;
 
 	/* is there any actual work to be done? */
-	if (!count) {
+	if (!count)
 		return 0;
-	}
 
+	dprint(DBG_BITMAP, "clear_bits: %u,%u\n", start, count);
 	/* are all of the bits in range? */
-	if ((start + count) > mdb->fs_ablocks) {
+	if ((start + count) > HFS_SB(sb)->fs_ablocks)
 		return -2;
-	}
-
-	block_nr = start / HFS_BM_BPB;
-	u32_nr = (start % HFS_BM_BPB) / 32;
-	bit_nr = start % 32;
 
+	down(&HFS_SB(sb)->bitmap_lock);
 	/* bitmap is always on a 32-bit boundary */
-	bitmap = (hfs_u32 *)hfs_buffer_data(mdb->bitmap[block_nr]);
-
-	/* do any partial hfs_u32 at the start */
-	if (bit_nr != 0) {
-		while ((bit_nr < 32) && left) {
-			if (!hfs_clear_bit(bit_nr, bitmap + u32_nr)) {
-				hfs_buffer_dirty(mdb->bitmap[block_nr]);
-				return -1;
-			}
-			++bit_nr;
-			--left;
-		}
-		bit_nr=0;
-
-		/* advance u32_nr and check for end of this block */
-		if (++u32_nr > 127) {
-			u32_nr = 0;
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			++block_nr;
-			/* bitmap is always on a 32-bit boundary */
-			bitmap = (hfs_u32 *)
-					hfs_buffer_data(mdb->bitmap[block_nr]);
-		}
-	}
-
-	/* do full hfs_u32s */
-	while (left > 31) {
-		if (bitmap[u32_nr] != ~((hfs_u32)0)) {
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			return -1;
-		}
-		bitmap[u32_nr] = ((hfs_u32)0);
-		left -= 32;
-
-		/* advance u32_nr and check for end of this block */
-		if (++u32_nr > 127) {
-			u32_nr = 0;
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			++block_nr;
-			/* bitmap is always on a 32-bit boundary */
-			bitmap = (hfs_u32 *)
-					hfs_buffer_data(mdb->bitmap[block_nr]);
-		}
-	}
-
-			
-	/* do any partial hfs_u32 at end */
-	while (left) {
-		if (!hfs_clear_bit(bit_nr, bitmap + u32_nr)) {
-			hfs_buffer_dirty(mdb->bitmap[block_nr]);
-			return -1;
-		}
-		++bit_nr;
-		--left;
-	}
+	curr = HFS_SB(sb)->bitmap + (start / 32);
+	len = count;
 
-	hfs_buffer_dirty(mdb->bitmap[block_nr]);
-	mdb->free_ablocks += count;
+	/* do any partial u32 at the start */
+	i = start % 32;
+	if (i) {
+		int j = 32 - i;
+		mask = 0xffffffffU << j;
+		if (j > count) {
+			mask |= 0xffffffffU >> (i + count);
+			*curr &= cpu_to_be32(mask);
+			goto out;
+		}
+		*curr++ &= cpu_to_be32(mask);
+		count -= j;
+	}
+
+	/* do full u32s */
+	while (count >= 32) {
+		*curr++ = 0;
+		count -= 32;
+	}
+	/* do any partial u32 at end */
+	if (count) {
+		mask = 0xffffffffU >> count;
+		*curr &= cpu_to_be32(mask);
+	}
+out:
+	HFS_SB(sb)->free_ablocks += len;
+	up(&HFS_SB(sb)->bitmap_lock);
+	hfs_bitmap_dirty(sb);
 
-	/* successful completion */
-	hfs_mdb_dirty(mdb->sys_mdb);
 	return 0;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/bitops.c linuxppc-2.5-benh/fs/hfs/bitops.c
--- /dev/shm/linux-2.5/fs/hfs/bitops.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bitops.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,124 +0,0 @@
-/*
- * linux/fs/hfs/bitops.c
- *
- * Copyright (C) 1996  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains functions to handle bitmaps in "left-to-right"
- * bit-order such that the MSB of a 32-bit big-endian word is bit 0.
- * (This corresponds to bit 7 of a 32-bit little-endian word.)
- *
- * I have tested and confirmed that the results are identical on the
- * Intel x86, PowerPC and DEC Alpha processors.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- */
-
-#include "hfs.h"
-
-/*================ Global functions ================*/
-
-/*
- * hfs_find_zero_bit()
- *
- * Description:
- *  Given a block of memory, its length in bits, and a starting bit number,
- *  determine the number of the first zero bits (in left-to-right ordering)
- *  in that range.
- *
- *  Returns >= 'size' if no zero bits are found in the range.
- *
- *  Accesses memory in 32-bit aligned chunks of 32-bits and thus
- *  may read beyond the 'size'th bit.
- */
-hfs_u32 hfs_find_zero_bit(const hfs_u32 *start, hfs_u32 size, hfs_u32 offset)
-{
-	const hfs_u32 *end   = start + ((size + 31) >> 5);
-	const hfs_u32 *curr  = start + (offset >> 5);
-	int bit = offset % 32;
-	
-	if (offset < size) {
-		/* scan the first partial hfs_u32 for zero bits */
-		if (bit != 0) {
-			do {
-				if (!hfs_test_bit(bit, curr)) {
-					goto done;
-				}
-				++bit;
-			} while (bit < 32);
-			bit = 0;
-			++curr;
-		}
-	
-		/* scan complete hfs_u32s for the first zero bit */
-		while (curr < end) {
-			if (*curr == ~((hfs_u32)0)) {
-				++curr;
-			} else {
-				while (hfs_test_bit(bit, curr)) {
-					++bit;
-				}
-				break;
-			}
-		}
-
-done:
-		bit |= (curr - start) << 5;
-		return bit;
-	} else {
-		return size;
-	}
-}
-
-/*
- * hfs_count_zero_bits()
- *
- * Description:
- *  Given a block of memory, its length in bits, and a starting bit number,
- *  determine the number of consecutive zero bits (in left-to-right ordering)
- *  in that range.
- *
- *  Accesses memory in 32-bit aligned chunks of 32-bits and thus
- *  may read beyond the 'size'th bit.
- */
-hfs_u32 hfs_count_zero_bits(const hfs_u32 *start, hfs_u32 size, hfs_u32 offset)
-{
-	const hfs_u32 *end   = start + ((size + 31) >> 5);
-	const hfs_u32 *curr  = start + (offset >> 5);
-	int bit = offset % 32;
-
-	if (offset < size) {
-		/* scan the first partial hfs_u32 for one bits */
-		if (bit != 0) {
-			do {
-				if (hfs_test_bit(bit, curr)) {
-					goto done;
-				}
-				++bit;
-			} while (bit < 32);
-			bit = 0;
-			++curr;
-		}
-	
-		/* scan complete hfs_u32s for the first one bit */
-		while (curr < end) {
-			if (*curr == ((hfs_u32)0)) {
-				++curr;
-			} else {
-				while (!hfs_test_bit(bit, curr)) {
-					++bit;
-				}
-				break;
-			}
-		}
-
-done:
-		bit |= (curr - start) << 5;
-		if (bit > size) {
-			bit = size;
-		}
-		return bit - offset;
-	} else {
-		return 0;
-	}
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/bnode.c linuxppc-2.5-benh/fs/hfs/bnode.c
--- /dev/shm/linux-2.5/fs/hfs/bnode.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/bnode.c	2003-12-24 03:48:17.000000000 +0000
@@ -1,544 +1,486 @@
 /*
- * linux/fs/hfs/bnode.c
+ *  linux/fs/hfs/bnode.c
  *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
  *
- * This file contains the code to access nodes in the B-tree structure.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- *
- * The code in this file initializes some structures which contain
- * pointers by calling memset(&foo, 0, sizeof(foo)).
- * This produces the desired behavior only due to the non-ANSI
- * assumption that the machine representation of NULL is all zeros.
+ * Handle basic btree node operations
  */
 
-#include "hfs_btree.h"
+#include <linux/pagemap.h>
+#include <linux/swap.h>
 
-/*================ File-local variables ================*/
- 
-/* debugging statistics */
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-int bnode_count = 0;
-#endif
+#include "btree.h"
 
-/*================ Global functions ================*/
+#define REF_PAGES	0
 
-/*
- * hfs_bnode_delete()
- *
- * Description:
- *   This function is called to remove a bnode from the cache and
- *   release its resources.
- * Input Variable(s):
- *   struct hfs_bnode *bn: Pointer to the (struct hfs_bnode) to be
- *   removed from the cache.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'bn' points to a "valid" (struct hfs_bnode).
- * Postconditions:
- *   The node 'bn' is removed from the cache, its memory freed and its
- *   buffer (if any) released.
- */
-void hfs_bnode_delete(struct hfs_bnode *bn)
+void hfs_bnode_read(struct hfs_bnode *node, void *buf,
+		int off, int len)
 {
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	--bnode_count;
-#endif
-	/* join neighbors */
-	if (bn->next) {
-		bn->next->prev = bn->prev;
-	}
-	if (bn->prev) {
-		bn->prev->next = bn->next;
-	}
-	/* fix cache slot if necessary */
-	if (bhash(bn->tree, bn->node) == bn) {
-		bhash(bn->tree, bn->node) = bn->next;
-	}
-	/* release resources */
-	hfs_buffer_put(bn->buf); /* safe: checks for NULL argument */
-	HFS_DELETE(bn);
+	struct page *page;
+
+	off += node->page_offset;
+	page = node->page[0];
+
+	memcpy(buf, kmap(page) + off, len);
+	kunmap(page);
 }
 
+u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)
+{
+	u16 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 2);
+	return be16_to_cpu(data);
+}
 
-/*
- * hfs_bnode_read()
- *
- * Description: 
- *   This function creates a (struct hfs_bnode) and, if appropriate,
- *   inserts it in the cache.
- * Input Variable(s):
- *   struct hfs_bnode *bnode: pointer to the new bnode.
- *   struct hfs_btree *tree: pointer to the (struct hfs_btree)
- *    containing the desired node
- *   hfs_u32 node: the number of the desired node.
- *   int sticky: the value to assign to the 'sticky' field.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   (struct hfs_bnode *) pointing to the newly created bnode or NULL.
- * Preconditions:
- *   'bnode' points to a "valid" (struct hfs_bnode).
- *   'tree' points to a "valid" (struct hfs_btree).
- *   'node' is an existing node number in the B-tree.
- * Postconditions:
- *   The following are true of 'bnode' upon return:
- *    The 'magic' field is set to indicate a valid (struct hfs_bnode). 
- *    The 'sticky', 'tree' and 'node' fields are initialized to the
- *    values of the of the corresponding arguments.
- *    If the 'sticky' argument is zero then the fields 'prev' and
- *    'next' are initialized by inserting the (struct hfs_bnode) in the
- *    linked list of the appropriate cache slot; otherwise they are
- *    initialized to NULL.
- *    The data is read from disk (or buffer cache) and the 'buf' field
- *    points to the buffer for that data.
- *    If no other processes tried to access this node while this
- *    process was waiting on disk I/O (if necessary) then the
- *    remaining fields are zero ('count', 'resrv', 'lock') or NULL
- *    ('wqueue', 'rqueue') corresponding to no accesses.
- *    If there were access attempts during I/O then they were blocked
- *    until the I/O was complete, and the fields 'count', 'resrv',
- *    'lock', 'wqueue' and 'rqueue' reflect the results of unblocking
- *    those processes when the I/O was completed.
- */
-void hfs_bnode_read(struct hfs_bnode *bnode, struct hfs_btree *tree,
-		    hfs_u32 node, int sticky)
+u8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)
 {
-	struct NodeDescriptor *nd;
-	int block, lcv;
-	hfs_u16 curr, prev, limit;
-
-	/* Initialize the structure */
-	memset(bnode, 0, sizeof(*bnode));
-	bnode->magic = HFS_BNODE_MAGIC;
-	bnode->tree = tree;
-	bnode->node = node;
-	bnode->sticky = sticky;
-	hfs_init_waitqueue(&bnode->rqueue);
-	hfs_init_waitqueue(&bnode->wqueue);
-
-	if (sticky == HFS_NOT_STICKY) {
-		/* Insert it in the cache if appropriate */
-		if ((bnode->next = bhash(tree, node))) {
-			bnode->next->prev = bnode;
-		}
-		bhash(tree, node) = bnode;
-	}
+	u8 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 1);
+	return data;
+}
 
-	/* Make the bnode look like it is being
-	   modified so other processes will wait for
-	   the I/O to complete */
-	bnode->count = bnode->resrv = bnode->lock = 1;
-
-	/* Read in the node, possibly causing a schedule()
-	   call.  If the I/O fails then emit a warning.	 Each
-	   process that was waiting on the bnode (including
-	   the current one) will notice the failure and
-	   hfs_bnode_relse() the node.	The last hfs_bnode_relse()
-	   will call hfs_bnode_delete() and discard the bnode.	*/
-
-	block = hfs_extent_map(&tree->entry.u.file.data_fork, node, 0);
-	if (!block) {
-		hfs_warn("hfs_bnode_read: bad node number 0x%08x\n", node);
-	} else if (hfs_buffer_ok(bnode->buf =
-				 hfs_buffer_get(tree->sys_mdb, block, 1))) {
-		/* read in the NodeDescriptor */
-		nd = (struct NodeDescriptor *)hfs_buffer_data(bnode->buf);
-		bnode->ndFLink    = hfs_get_hl(nd->ndFLink);
-		bnode->ndBLink    = hfs_get_hl(nd->ndBLink);
-		bnode->ndType     = nd->ndType;
-		bnode->ndNHeight  = nd->ndNHeight;
-		bnode->ndNRecs    = hfs_get_hs(nd->ndNRecs);
-
-		/* verify the integrity of the node */
-		prev = sizeof(struct NodeDescriptor);
-		limit = HFS_SECTOR_SIZE - sizeof(hfs_u16)*(bnode->ndNRecs + 1);
-		for (lcv=1; lcv <= (bnode->ndNRecs + 1); ++lcv) {
-			curr = hfs_get_hs(RECTBL(bnode, lcv));
-			if ((curr < prev) || (curr > limit)) {
-				hfs_warn("hfs_bnode_read: corrupt node "
-					 "number 0x%08x\n", node);
-				hfs_buffer_put(bnode->buf);
-				bnode->buf = NULL;
-				break;
-			}
-			prev = curr;
-		}
-	}
+void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)
+{
+	struct hfs_btree *tree;
+	int key_len;
 
-	/* Undo our fakery with the lock state and
-	   hfs_wake_up() anyone who we managed to trick */
-	--bnode->count;
-	bnode->resrv = bnode->lock = 0;
-	hfs_wake_up(&bnode->rqueue);
+	tree = node->tree;
+	if (node->type == HFS_NODE_LEAF ||
+	    tree->attributes & HFS_TREE_VARIDXKEYS)
+		key_len = hfs_bnode_read_u8(node, off) + 1;
+	else
+		key_len = tree->max_key_len + 1;
+
+	hfs_bnode_read(node, key, off, key_len);
 }
 
-/*
- * hfs_bnode_lock()
- *
- * Description:
- *   This function does the locking of a bnode.
- * Input Variable(s):
- *   struct hfs_bnode *bn: pointer to the (struct hfs_bnode) to lock
- *   int lock_type: the type of lock desired
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'bn' points to a "valid" (struct hfs_bnode).
- *   'lock_type' is a valid hfs_lock_t
- * Postconditions:
- *   The 'count' field of 'bn' is incremented by one.  If 'lock_type'
- *   is HFS_LOCK_RESRV the 'resrv' field is also incremented.
- */
-void hfs_bnode_lock(struct hfs_bnode_ref *bnr, int lock_type)
+void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)
+{
+	struct page *page;
+
+	off += node->page_offset;
+	page = node->page[0];
+
+	memcpy(kmap(page) + off, buf, len);
+	kunmap(page);
+	set_page_dirty(page);
+}
+
+void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)
+{
+	data = cpu_to_be16(data);
+	// optimize later...
+	hfs_bnode_write(node, &data, off, 2);
+}
+
+void hfs_bnode_write_u8(struct hfs_bnode *node, int off, u8 data)
+{
+	// optimize later...
+	hfs_bnode_write(node, &data, off, 1);
+}
+
+void hfs_bnode_clear(struct hfs_bnode *node, int off, int len)
 {
-	struct hfs_bnode *bn = bnr->bn;
+	struct page *page;
+
+	off += node->page_offset;
+	page = node->page[0];
+
+	memset(kmap(page) + off, 0, len);
+	kunmap(page);
+	set_page_dirty(page);
+}
 
-	if ((lock_type == bnr->lock_type) || !bn) {
+void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,
+		struct hfs_bnode *src_node, int src, int len)
+{
+	struct hfs_btree *tree;
+	struct page *src_page, *dst_page;
+
+	dprint(DBG_BNODE_MOD, "copybytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
 		return;
-	}
+	tree = src_node->tree;
+	src += src_node->page_offset;
+	dst += dst_node->page_offset;
+	src_page = src_node->page[0];
+	dst_page = dst_node->page[0];
+
+	memcpy(kmap(dst_page) + dst, kmap(src_page) + src, len);
+	kunmap(src_page);
+	kunmap(dst_page);
+	set_page_dirty(dst_page);
+}
 
-	if (bnr->lock_type == HFS_LOCK_WRITE) {
-		hfs_bnode_commit(bnr->bn);
-	}
+void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)
+{
+	struct page *page;
+	void *ptr;
 
-	switch (lock_type) {
-	default:
-		goto bail;
-		break;
+	dprint(DBG_BNODE_MOD, "movebytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
+		return;
+	src += node->page_offset;
+	dst += node->page_offset;
+	page = node->page[0];
+	ptr = kmap(page);
+	memmove(ptr + dst, ptr + src, len);
+	kunmap(page);
+	set_page_dirty(page);
+}
 
-	case HFS_LOCK_READ:
-		/* We may not obtain read access if any process is
-		   currently modifying or waiting to modify this node.
-		   If we can't obtain access we wait on the rqueue
-		   wait queue to be woken up by the modifying process
-		   when it relinquishes its lock. */
-		switch (bnr->lock_type) {
-		default:
-			goto bail;
-			break;
-
-		case HFS_LOCK_NONE:
-			while (bn->lock || waitqueue_active(&bn->wqueue)) {
-				hfs_sleep_on(&bn->rqueue);
-			}
-			++bn->count;
-			break;
-		}
-		break;
-			
-	case HFS_LOCK_RESRV:
-		/* We may not obtain a reservation (read access with
-		   an option to write later), if any process currently
-		   holds a reservation on this node.  That includes
-		   any process which is currently modifying this node.
-		   If we can't obtain access, then we wait on the
-		   rqueue wait queue to e woken up by the
-		   reservation-holder when it calls hfs_bnode_relse. */
-		switch (bnr->lock_type) {
-		default:
-			goto bail;
-			break;
-
-		case HFS_LOCK_NONE:
-			while (bn->resrv) {
-				hfs_sleep_on(&bn->rqueue);
-			}
-			bn->resrv = 1;
-			++bn->count;
-			break;
-
-		case HFS_LOCK_WRITE:
-			bn->lock = 0;
-			hfs_wake_up(&bn->rqueue);
-			break;
-		}
-		break;
-		
-	case HFS_LOCK_WRITE:
-		switch (bnr->lock_type) {
-		default:
-			goto bail;
-			break;
-
-		case HFS_LOCK_NONE:
-			while (bn->resrv) {
-				hfs_sleep_on(&bn->rqueue);
-			}
-			bn->resrv = 1;
-			++bn->count;
-		case HFS_LOCK_RESRV:
-			while (bn->count > 1) {
-				hfs_sleep_on(&bn->wqueue);
-			}
-			bn->lock = 1;
-			break;
-		}
-		break;
+void hfs_bnode_dump(struct hfs_bnode *node)
+{
+	struct hfs_bnode_desc desc;
+	u32 cnid;
+	int i, off, key_off;
+
+	dprint(DBG_BNODE_MOD, "bnode: %d\n", node->this);
+	hfs_bnode_read(node, &desc, 0, sizeof(desc));
+	dprint(DBG_BNODE_MOD, "%d, %d, %d, %d, %d\n",
+		be32_to_cpu(desc.next), be32_to_cpu(desc.prev),
+		desc.type, desc.height, be16_to_cpu(desc.num_recs));
+
+	off = node->tree->node_size - 2;
+	for (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {
+		key_off = hfs_bnode_read_u16(node, off);
+		dprint(DBG_BNODE_MOD, " %d", key_off);
+		if (i && node->type == HFS_NODE_INDEX) {
+			int tmp;
+
+			if (node->tree->attributes & HFS_TREE_VARIDXKEYS)
+				tmp = (hfs_bnode_read_u8(node, key_off) | 1) + 1;
+			else
+				tmp = node->tree->max_key_len + 1;
+			dprint(DBG_BNODE_MOD, " (%d,%d", tmp, hfs_bnode_read_u8(node, key_off));
+			hfs_bnode_read(node, &cnid, key_off + tmp, 4);
+			dprint(DBG_BNODE_MOD, ",%d)", be32_to_cpu(cnid));
+		} else if (i && node->type == HFS_NODE_LEAF) {
+			int tmp;
 
-	case HFS_LOCK_NONE:
-		switch (bnr->lock_type) {
-		default:
-			goto bail;
-			break;
-
-		case HFS_LOCK_READ:
-			/* This process was reading this node.	If
-			   there is now exactly one other process using
-			   the node then hfs_wake_up() a (potentially
-			   nonexistent) waiting process.  Note that I
-			   refer to "a" process since the reservation
-			   system ensures that only one process can
-			   get itself on the wait queue.  */
-			if (bn->count == 2) {
-				hfs_wake_up(&bn->wqueue);
-			}
-			break;
-
-		case HFS_LOCK_WRITE:
-			/* This process was modifying this node.
-			   Unlock the node and fall-through to the
-			   HFS_LOCK_RESRV case, since a 'reservation'
-			   is a prerequisite for HFS_LOCK_WRITE.  */
-			bn->lock = 0;
-		case HFS_LOCK_RESRV:
-			/* This process had placed a 'reservation' on
-			   this node, indicating an intention to
-			   possibly modify the node.  We can get to
-			   this spot directly (if the 'reservation'
-			   not converted to a HFS_LOCK_WRITE), or by
-			   falling through from the above case if the
-			   reservation was converted.
-			   Since HFS_LOCK_RESRV and HFS_LOCK_WRITE
-			   both block processes that want access
-			   (HFS_LOCK_RESRV blocks other processes that
-			   want reservations but allow HFS_LOCK_READ
-			   accesses, while HFS_LOCK_WRITE must have
-			   exclusive access and thus blocks both
-			   types) we hfs_wake_up() any processes that
-			   might be waiting for access.	 If multiple
-			   processes are waiting for a reservation
-			   then the magic of process scheduling will
-			   settle the dispute. */
-			bn->resrv = 0;
-			hfs_wake_up(&bn->rqueue);
-			break;
+			tmp = hfs_bnode_read_u8(node, key_off);
+			dprint(DBG_BNODE_MOD, " (%d)", tmp);
 		}
-		--bn->count;
-		break;
 	}
-	bnr->lock_type = lock_type;
-	return;
+	dprint(DBG_BNODE_MOD, "\n");
+}
 
-bail:
-	hfs_warn("hfs_bnode_lock: invalid lock change: %d->%d.\n",
-		bnr->lock_type, lock_type);
-	return;
+void hfs_bnode_unlink(struct hfs_bnode *node)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *tmp;
+	u32 cnid;
+
+	tree = node->tree;
+	if (node->prev) {
+		tmp = hfs_bnode_find(tree, node->prev);
+		if (IS_ERR(tmp))
+			return;
+		tmp->next = node->next;
+		cnid = cpu_to_be32(tmp->next);
+		hfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+		hfs_bnode_put(tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_head = node->next;
+
+	if (node->next) {
+		tmp = hfs_bnode_find(tree, node->next);
+		if (IS_ERR(tmp))
+			return;
+		tmp->prev = node->prev;
+		cnid = cpu_to_be32(tmp->prev);
+		hfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, prev), 4);
+		hfs_bnode_put(tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_tail = node->prev;
+
+	// move down?
+	if (!node->prev && !node->next) {
+		printk("hfs_btree_del_level\n");
+	}
+	if (!node->parent) {
+		tree->root = 0;
+		tree->depth = 0;
+	}
+	set_bit(HFS_BNODE_DELETED, &node->flags);
 }
 
-/*
- * hfs_bnode_relse()
- *
- * Description:
- *   This function is called when a process is done using a bnode.  If
- *   the proper conditions are met then we call hfs_bnode_delete() to remove
- *   it from the cache.	 If it is not deleted then we update its state
- *   to reflect one less process using it.
- * Input Variable(s):
- *   struct hfs_bnode *bn: pointer to the (struct hfs_bnode) to release.
- *   int lock_type: The type of lock held by the process releasing this node.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'bn' is NULL or points to a "valid" (struct hfs_bnode).
- * Postconditions:
- *   If 'bn' meets the appropriate conditions (see below) then it is
- *   kept in the cache and all fields are set to consistent values
- *   which reflect one less process using the node than upon entry.
- *   If 'bn' does not meet the conditions then it is deleted (see
- *   hfs_bnode_delete() for postconditions).
- *   In either case, if 'lock_type' is HFS_LOCK_WRITE
- *   then the corresponding buffer is dirtied.
- */
-void hfs_bnode_relse(struct hfs_bnode_ref *bnr)
+static inline int hfs_bnode_hash(u32 num)
 {
-	struct hfs_bnode *bn;
+	num = (num >> 16) + num;
+	num += num >> 8;
+	return num & (NODE_HASH_SIZE - 1);
+}
 
-	if (!bnr || !(bn = bnr->bn)) {
-		return;
+struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)
+{
+	struct hfs_bnode *node;
+
+	if (cnid >= tree->node_count) {
+		printk("HFS+-fs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
 	}
 
-	/* We update the lock state of the node if it is still in use
-	   or if it is "sticky" (such as the B-tree head and root).
-	   Otherwise we just delete it.	 */
-	if ((bn->count > 1) || (waitqueue_active(&bn->rqueue)) || (bn->sticky != HFS_NOT_STICKY)) {
-		hfs_bnode_lock(bnr, HFS_LOCK_NONE);
-	} else {
-		/* dirty buffer if we (might) have modified it */
-		if (bnr->lock_type == HFS_LOCK_WRITE) {
-			hfs_bnode_commit(bn);
+	for (node = tree->node_hash[hfs_bnode_hash(cnid)];
+	     node; node = node->next_hash) {
+		if (node->this == cnid) {
+			return node;
 		}
-		hfs_bnode_delete(bn);
-		bnr->lock_type = HFS_LOCK_NONE;
 	}
-	bnr->bn = NULL;
+	return NULL;
 }
 
-/*
- * hfs_bnode_find()
- *
- * Description:
- *   This function is called to obtain a bnode.  The cache is
- *   searched for the node.  If it not found there it is added to
- *   the cache by hfs_bnode_read().  There are two special cases node=0
- *   (the header node) and node='tree'->bthRoot (the root node), in
- *   which the nodes are obtained from fields of 'tree' without
- *   consulting or modifying the cache.
- * Input Variable(s):
- *   struct hfs_tree *tree: pointer to the (struct hfs_btree) from
- *    which to get a node.
- *   int node: the node number to get from 'tree'.
- *   int lock_type: The kind of access (HFS_LOCK_READ, or
- *    HFS_LOCK_RESRV) to obtain to the node
- * Output Variable(s):
- *   NONE
- * Returns:
- *   (struct hfs_bnode_ref) Reference to the requested node.
- * Preconditions:
- *   'tree' points to a "valid" (struct hfs_btree).
- * Postconditions:
- *   If 'node' refers to a valid node in 'tree' and 'lock_type' has
- *   one of the values listed above and no I/O errors occur then the
- *   value returned refers to a valid (struct hfs_bnode) corresponding
- *   to the requested node with the requested access type.  The node
- *   is also added to the cache if not previously present and not the
- *   root or header.
- *   If the conditions given above are not met, the bnode in the
- *   returned reference is NULL.
- */
-struct hfs_bnode_ref hfs_bnode_find(struct hfs_btree *tree,
-				    hfs_u32 node, int lock_type)
+static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)
 {
-	struct hfs_bnode *bn;
-	struct hfs_bnode *empty = NULL;
-	struct hfs_bnode_ref bnr;
-
-	bnr.lock_type = HFS_LOCK_NONE;
-	bnr.bn = NULL;
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	hfs_warn("hfs_bnode_find: %c %d:%d\n",
-		 lock_type==HFS_LOCK_READ?'R':
-			(lock_type==HFS_LOCK_RESRV?'V':'W'),
-		 (int)ntohl(tree->entry.cnid), node);
+	struct super_block *sb;
+	struct hfs_bnode *node, *node2;
+	struct address_space *mapping;
+	struct page *page;
+	int size, block, i, hash;
+	loff_t off;
+
+	if (cnid >= tree->node_count) {
+		printk("HFS+-fs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
+	}
+
+	sb = tree->inode->i_sb;
+	size = sizeof(struct hfs_bnode) + tree->pages_per_bnode *
+		sizeof(struct page *);
+	node = kmalloc(size, GFP_KERNEL);
+	if (!node)
+		return NULL;
+	memset(node, 0, size);
+	node->tree = tree;
+	node->this = cnid;
+	set_bit(HFS_BNODE_NEW, &node->flags);
+	atomic_set(&node->refcnt, 1);
+	dprint(DBG_BNODE_REFS, "new_node(%d:%d): 1\n",
+	       node->tree->cnid, node->this);
+	init_waitqueue_head(&node->lock_wq);
+	spin_lock(&tree->hash_lock);
+	node2 = hfs_bnode_findhash(tree, cnid);
+	if (!node2) {
+		hash = hfs_bnode_hash(cnid);
+		node->next_hash = tree->node_hash[hash];
+		tree->node_hash[hash] = node;
+		tree->node_hash_cnt++;
+	} else {
+		spin_unlock(&tree->hash_lock);
+		kfree(node);
+		wait_event(node2->lock_wq, !test_bit(HFS_BNODE_NEW, &node2->flags));
+		return node2;
+	}
+	spin_unlock(&tree->hash_lock);
+
+	mapping = tree->inode->i_mapping;
+	off = (loff_t)cnid * tree->node_size;
+	block = off >> PAGE_CACHE_SHIFT;
+	node->page_offset = off & ~PAGE_CACHE_MASK;
+	for (i = 0; i < tree->pages_per_bnode; i++) {
+		page = read_cache_page(mapping, block++, (filler_t *)mapping->a_ops->readpage, NULL);
+		if (IS_ERR(page))
+			goto fail;
+#if !REF_PAGES
+		page_cache_release(page);
 #endif
+		node->page[i] = page;
+	}
 
-	/* check special cases */
-	if (!node) {
-		bn = &tree->head;
-		goto return_it;
-	} else if (node == tree->bthRoot) {
-		bn = tree->root;
-		goto return_it;
-	} 
-
-restart:
-	/* look for the node in the cache. */
-	bn = bhash(tree, node);
-	while (bn && (bn->magic == HFS_BNODE_MAGIC)) {
-		if (bn->node == node) {
-			goto found_it;
-		}
-		bn = bn->next;
+	return node;
+fail:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	return node;
+}
+
+void hfs_bnode_unhash(struct hfs_bnode *node)
+{
+	struct hfs_bnode **p;
+
+	dprint(DBG_BNODE_REFS, "remove_node(%d:%d): %d\n",
+		node->tree->cnid, node->this, atomic_read(&node->refcnt));
+	for (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];
+	     *p && *p != node; p = &(*p)->next_hash)
+		;
+	if (!*p)
+		BUG();
+	*p = node->next_hash;
+	node->tree->node_hash_cnt--;
+}
+
+/* Load a particular node out of a tree */
+struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc *desc;
+	int i, rec_off, off, next_off;
+	int entry_size, key_size;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	if (node) {
+		hfs_bnode_get(node);
+		spin_unlock(&tree->hash_lock);
+		wait_event(node->lock_wq, !test_bit(HFS_BNODE_NEW, &node->flags));
+		return node;
+	}
+	spin_unlock(&tree->hash_lock);
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+	if (!test_bit(HFS_BNODE_NEW, &node->flags))
+		return node;
+
+	desc = (struct hfs_bnode_desc *)(kmap(node->page[0]) + node->page_offset);
+	node->prev = be32_to_cpu(desc->prev);
+	node->next = be32_to_cpu(desc->next);
+	node->num_recs = be16_to_cpu(desc->num_recs);
+	node->type = desc->type;
+	node->height = desc->height;
+	kunmap(node->page[0]);
+
+	switch (node->type) {
+	case HFS_NODE_HEADER:
+	case HFS_NODE_MAP:
+		if (node->height != 0)
+			goto node_error;
+		break;
+	case HFS_NODE_LEAF:
+		if (node->height != 1)
+			goto node_error;
+		break;
+	case HFS_NODE_INDEX:
+		if (node->height <= 1 || node->height > tree->depth)
+			goto node_error;
+		break;
+	default:
+		goto node_error;
 	}
 
-	if (!empty) {
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-		++bnode_count;
-#endif
-		if (HFS_NEW(empty)) {
-			goto restart;
-		}
-		return bnr;
+	rec_off = tree->node_size - 2;
+	off = hfs_bnode_read_u16(node, rec_off);
+	if (off != sizeof(struct hfs_bnode_desc))
+		goto node_error;
+	for (i = 1; i <= node->num_recs; off = next_off, i++) {
+		rec_off -= 2;
+		next_off = hfs_bnode_read_u16(node, rec_off);
+		if (next_off <= off ||
+		    next_off > tree->node_size ||
+		    next_off & 1)
+			goto node_error;
+		entry_size = next_off - off;
+		if (node->type != HFS_NODE_INDEX &&
+		    node->type != HFS_NODE_LEAF)
+			continue;
+		key_size = hfs_bnode_read_u8(node, off) + 1;
+		if (key_size >= entry_size /*|| key_size & 1*/)
+			goto node_error;
+	}
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	return node;
+
+node_error:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	hfs_bnode_put(node);
+	return ERR_PTR(-EIO);
+}
+
+void hfs_bnode_free(struct hfs_bnode *node)
+{
+	//int i;
+
+	//for (i = 0; i < node->tree->pages_per_bnode; i++)
+	//	if (node->page[i])
+	//		page_cache_release(node->page[i]);
+	kfree(node);
+}
+
+struct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct page **pagep;
+	int i;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	spin_unlock(&tree->hash_lock);
+	if (node)
+		BUG();
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+
+	pagep = node->page;
+	memset(kmap(*pagep) + node->page_offset, 0,
+	       min((int)PAGE_CACHE_SIZE, (int)tree->node_size));
+	set_page_dirty(*pagep);
+	kunmap(*pagep);
+	for (i = 1; i < tree->pages_per_bnode; i++) {
+		memset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);
+		set_page_dirty(*pagep);
+		kunmap(*pagep);
 	}
-	bn = empty;
-	hfs_bnode_read(bn, tree, node, HFS_NOT_STICKY);
-	goto return_it;
-
-found_it:
-	/* check validity */
-	if (bn->magic != HFS_BNODE_MAGIC) {
-		/* If we find a corrupt bnode then we return
-		   NULL.  However, we don't try to remove it
-		   from the cache or release its resources
-		   since we have no idea what kind of trouble
-		   we could get into that way. */
-		hfs_warn("hfs_bnode_find: bnode cache is corrupt.\n");
-		return bnr;
-	} 
-	if (empty) {
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-		--bnode_count;
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+
+	return node;
+}
+
+void hfs_bnode_get(struct hfs_bnode *node)
+{
+	if (node) {
+		atomic_inc(&node->refcnt);
+#if REF_PAGES
+		{
+		int i;
+		for (i = 0; i < node->tree->pages_per_bnode; i++)
+			get_page(node->page[i]);
+		}
 #endif
-		HFS_DELETE(empty);
-	}
-	
-return_it:
-	/* Wait our turn */
-	bnr.bn = bn;
-	hfs_bnode_lock(&bnr, lock_type);
-
-	/* Check for failure to read the node from disk */
-	if (!hfs_buffer_ok(bn->buf)) {
-		hfs_bnode_relse(&bnr);
-	}
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	if (!bnr.bn) {
-		hfs_warn("hfs_bnode_find: failed\n");
-	} else {
-		hfs_warn("hfs_bnode_find: use %d(%d) lvl %d [%d]\n", bn->count,
-			 bn->buf->b_count, bn->ndNHeight, bnode_count);
-		hfs_warn("hfs_bnode_find: blnk %u flnk %u recs %u\n", 
-			 bn->ndBLink, bn->ndFLink, bn->ndNRecs);
+		dprint(DBG_BNODE_REFS, "get_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
 	}
-#endif
-
-	return bnr;
 }
 
-/*
- * hfs_bnode_commit()
- *
- * Called to write a possibly dirty bnode back to disk.
- */
-void hfs_bnode_commit(struct hfs_bnode *bn)
+/* Dispose of resources used by a node */
+void hfs_bnode_put(struct hfs_bnode *node)
 {
-	if (hfs_buffer_ok(bn->buf)) {
-		struct NodeDescriptor *nd;
-		nd = (struct NodeDescriptor *)hfs_buffer_data(bn->buf);
-
-		hfs_put_hl(bn->ndFLink, nd->ndFLink);
-		hfs_put_hl(bn->ndBLink, nd->ndBLink);
-		nd->ndType    = bn->ndType;
-		nd->ndNHeight = bn->ndNHeight;
-		hfs_put_hs(bn->ndNRecs, nd->ndNRecs);
-		hfs_buffer_dirty(bn->buf);
+	if (node) {
+		struct hfs_btree *tree = node->tree;
+		int i;
+
+		dprint(DBG_BNODE_REFS, "put_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
+		if (!atomic_read(&node->refcnt))
+			BUG();
+		if (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock)) {
+#if REF_PAGES
+			for (i = 0; i < tree->pages_per_bnode; i++)
+				put_page(node->page[i]);
+#endif
+			return;
+		}
+		for (i = 0; i < tree->pages_per_bnode; i++) {
+			mark_page_accessed(node->page[i]);
+#if REF_PAGES
+			put_page(node->page[i]);
+#endif
+		}
 
-		/* increment write count */
-		hfs_mdb_dirty(bn->tree->sys_mdb);
+		if (test_bit(HFS_BNODE_DELETED, &node->flags)) {
+			hfs_bnode_unhash(node);
+			spin_unlock(&tree->hash_lock);
+			hfs_bmap_free(node);
+			hfs_bnode_free(node);
+			return;
+		}
+		spin_unlock(&tree->hash_lock);
 	}
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/brec.c linuxppc-2.5-benh/fs/hfs/brec.c
--- /dev/shm/linux-2.5/fs/hfs/brec.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/brec.c	2003-12-24 03:48:17.000000000 +0000
@@ -1,239 +1,492 @@
 /*
- * linux/fs/hfs/brec.c
+ *  linux/fs/hfsplus/brec.c
  *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
  *
- * This file contains the code to access records in a btree.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
+ * Handle individual btree records
  */
 
-#include "hfs_btree.h"
-
-/*================ File-local functions ================*/
+#include "btree.h"
 
-/*
- * first()
- *
- * returns HFS_BPATH_FIRST if elem->record == 1, 0 otherwise
- */
-static inline int first(const struct hfs_belem *elem)
+/* Get the length and offset of the given record in the given node */
+u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)
 {
-	return (elem->record == 1) ? HFS_BPATH_FIRST : 0;
+	u16 retval[2];
+	u16 dataoff;
+
+	dataoff = node->tree->node_size - (rec + 2) * 2;
+	hfs_bnode_read(node, retval, dataoff, 4);
+	*off = be16_to_cpu(retval[1]);
+	return be16_to_cpu(retval[0]) - *off;
 }
 
-/*
- * overflow()
- *
- * return HFS_BPATH_OVERFLOW if the node has no room for an 
- * additional pointer record, 0 otherwise.
- */
-static inline int overflow(const struct hfs_btree *tree,
-			   const struct hfs_bnode *bnode)
+/* Get the length of the key from a keyed record */
+u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)
 {
-	/* there is some algebra involved in getting this form */
-	return ((HFS_SECTOR_SIZE - sizeof(hfs_u32)) <
-		 (bnode_end(bnode) + (2+bnode->ndNRecs)*sizeof(hfs_u16) +
-		  ROUND(tree->bthKeyLen+1))) ?  HFS_BPATH_OVERFLOW : 0;
+	u16 retval, recoff;
+
+	if (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)
+		return 0;
+
+	if ((node->type == HFS_NODE_INDEX) &&
+	   !(node->tree->attributes & HFS_TREE_VARIDXKEYS)) {
+		if (node->tree->attributes & HFS_TREE_BIGKEYS)
+			retval = node->tree->max_key_len + 2;
+		else
+			retval = node->tree->max_key_len + 1;
+	} else {
+		recoff = hfs_bnode_read_u16(node, node->tree->node_size - (rec + 1) * 2);
+		if (!recoff)
+			return 0;
+		if (node->tree->attributes & HFS_TREE_BIGKEYS)
+			retval = hfs_bnode_read_u16(node, recoff) + 2;
+		else
+			retval = (hfs_bnode_read_u8(node, recoff) | 1) + 1;
+	}
+	return retval;
 }
 
-/*
- * underflow()
- *
- * return HFS_BPATH_UNDERFLOW if the node will be less that 1/2 full
- * upon removal of a pointer record, 0 otherwise.
- */
-static inline int underflow(const struct hfs_btree *tree,
-			    const struct hfs_bnode *bnode)
+int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)
 {
-	return ((bnode->ndNRecs * sizeof(hfs_u16) +
-		 bnode_offset(bnode, bnode->ndNRecs)) <
-		(HFS_SECTOR_SIZE - sizeof(struct NodeDescriptor))/2) ?
-		HFS_BPATH_UNDERFLOW : 0;
-}
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	int size, key_len, rec;
+	int data_off, end_off;
+	int idx_rec_off, data_rec_off, end_rec_off;
+	u32 cnid;
+
+	tree = fd->tree;
+	if (!fd->bnode) {
+		if (!tree->root)
+			hfs_btree_inc_height(tree);
+		fd->bnode = hfs_bnode_find(tree, tree->leaf_head);
+		if (IS_ERR(fd->bnode))
+			return PTR_ERR(fd->bnode);
+		fd->record = -1;
+	}
+	new_node = NULL;
+	key_len = (fd->search_key->key_len | 1) + 1;
+again:
+	/* new record idx and complete record size */
+	rec = fd->record + 1;
+	size = key_len + entry_len;
+
+	node = fd->bnode;
+	hfs_bnode_dump(node);
+	/* get last offset */
+	end_rec_off = tree->node_size - (node->num_recs + 1) * 2;
+	end_off = hfs_bnode_read_u16(node, end_rec_off);
+	end_rec_off -= 2;
+	dprint(DBG_BNODE_MOD, "insert_rec: %d, %d, %d, %d\n", rec, size, end_off, end_rec_off);
+	if (size > end_rec_off - end_off) {
+		if (new_node)
+			panic("not enough room!\n");
+		new_node = hfs_bnode_split(fd);
+		if (IS_ERR(new_node))
+			return PTR_ERR(new_node);
+		goto again;
+	}
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count++;
+		mark_inode_dirty(tree->inode);
+	}
+	node->num_recs++;
+	/* write new last offset */
+	hfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+	hfs_bnode_write_u16(node, end_rec_off, end_off + size);
+	data_off = end_off;
+	data_rec_off = end_rec_off + 2;
+	idx_rec_off = tree->node_size - (rec + 1) * 2;
+	if (idx_rec_off == data_rec_off)
+		goto skip;
+	/* move all following entries */
+	do {
+		data_off = hfs_bnode_read_u16(node, data_rec_off + 2);
+		hfs_bnode_write_u16(node, data_rec_off, data_off + size);
+		data_rec_off += 2;
+	} while (data_rec_off < idx_rec_off);
+
+	/* move data away */
+	hfs_bnode_move(node, data_off + size, data_off,
+		       end_off - data_off);
+
+skip:
+	hfs_bnode_write(node, fd->search_key, data_off, key_len);
+	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
+	hfs_bnode_dump(node);
+
+	if (new_node) {
+		/* update parent key if we inserted a key
+		 * at the start of the first node
+		 */
+		if (!rec && new_node != node)
+			hfs_brec_update_parent(fd);
+
+		hfs_bnode_put(fd->bnode);
+		if (!new_node->parent) {
+			hfs_btree_inc_height(tree);
+			new_node->parent = tree->root;
+		}
+		fd->bnode = hfs_bnode_find(tree, new_node->parent);
+
+		/* create index data entry */
+		cnid = cpu_to_be32(new_node->this);
+		entry = &cnid;
+		entry_len = sizeof(cnid);
+
+		/* get index key */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		__hfs_brec_find(fd->bnode, fd);
+
+		hfs_bnode_put(new_node);
+		new_node = NULL;
+
+		if (tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_len = fd->search_key->key_len + 1;
+		else {
+			fd->search_key->key_len = tree->max_key_len;
+			key_len = tree->max_key_len + 1;
+		}
+		goto again;
+	}
 
-/*================ Global functions ================*/
+	if (!rec)
+		hfs_brec_update_parent(fd);
 
-/*
- * hfs_brec_next()
- *
- * Description:
- *   Obtain access to a child of an internal node in a B-tree.
- * Input Variable(s):
- *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to
- *    add an element to.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_belem *: pointer to the new path element or NULL
- * Preconditions:
- *   'brec' points to a "valid" (struct hfs_brec), the last element of
- *   which corresponds to a record in a bnode of type ndIndxNode and the
- *   'record' field indicates the index record for the desired child.
- * Postconditions:
- *   If the call to hfs_bnode_find() fails then 'brec' is released
- *   and a NULL is returned.
- *   Otherwise:
- *    Any ancestors in 'brec' that are not needed (as determined by the
- *     'keep_flags' field of 'brec) are released from 'brec'.
- *    A new element is added to 'brec' corresponding to the desired
- *     child.
- *    The child is obtained with the same 'lock_type' field as its
- *     parent.
- *    The 'record' field is initialized to the last record.
- *    A pointer to the new path element is returned.
- */
-struct hfs_belem *hfs_brec_next(struct hfs_brec *brec)
+	return 0;
+}
+
+int hfs_brec_remove(struct hfs_find_data *fd)
 {
-	struct hfs_belem *elem = brec->bottom;
-	hfs_u32 node;
-	int lock_type;
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *parent;
+	int end_off, rec_off, data_off, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+again:
+	rec_off = tree->node_size - (fd->record + 2) * 2;
+	end_off = tree->node_size - (node->num_recs + 1) * 2;
+
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count--;
+		mark_inode_dirty(tree->inode);
+	}
+	hfs_bnode_dump(node);
+	dprint(DBG_BNODE_MOD, "remove_rec: %d, %d\n", fd->record, fd->keylength + fd->entrylength);
+	if (!--node->num_recs) {
+		hfs_bnode_unlink(node);
+		if (!node->parent)
+			return 0;
+		parent = hfs_bnode_find(tree, node->parent);
+		if (IS_ERR(parent))
+			return PTR_ERR(parent);
+		hfs_bnode_put(node);
+		node = fd->bnode = parent;
 
-	/* release unneeded ancestors */
-	elem->flags = first(elem) |
-		      overflow(brec->tree, elem->bnr.bn) |
-		      underflow(brec->tree, elem->bnr.bn);
-	if (!(brec->keep_flags & elem->flags)) {
-		hfs_brec_relse(brec, brec->bottom-1);
-	} else if ((brec->bottom-2 >= brec->top) &&
-		   !(elem->flags & (elem-1)->flags)) {
-		hfs_brec_relse(brec, brec->bottom-2);
+		__hfs_brec_find(node, fd);
+		goto again;
 	}
+	hfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+
+	if (rec_off == end_off)
+		goto skip;
+	size = fd->keylength + fd->entrylength;
+
+	do {
+		data_off = hfs_bnode_read_u16(node, rec_off);
+		hfs_bnode_write_u16(node, rec_off + 2, data_off - size);
+		rec_off -= 2;
+	} while (rec_off >= end_off);
+
+	/* fill hole */
+	hfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,
+		       data_off - fd->keyoffset - size);
+skip:
+	hfs_bnode_dump(node);
+	if (!fd->record)
+		hfs_brec_update_parent(fd);
+	return 0;
+}
 
-	node = hfs_get_hl(belem_record(elem));
-	lock_type = elem->bnr.lock_type;
+struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int num_recs, new_rec_off, new_off, old_rec_off;
+	int data_start, data_end, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = hfs_bmap_alloc(tree);
+	if (IS_ERR(new_node))
+		return new_node;
+	hfs_bnode_get(node);
+	dprint(DBG_BNODE_MOD, "split_nodes: %d - %d - %d\n",
+		node->this, new_node->this, node->next);
+	new_node->next = node->next;
+	new_node->prev = node->this;
+	new_node->parent = node->parent;
+	new_node->type = node->type;
+	new_node->height = node->height;
+
+	size = tree->node_size / 2 - node->num_recs * 2 - 14;
+	old_rec_off = tree->node_size - 4;
+	num_recs = 1;
+	for (;;) {
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+		if (data_start > size)
+			break;
+		old_rec_off -= 2;
+		if (++num_recs < node->num_recs)
+			continue;
+		/* panic? */
+		hfs_bnode_put(node);
+		hfs_bnode_put(new_node);
+		return ERR_PTR(-ENOSPC);
+	}
 
-	if (!node || hfs_bnode_in_brec(node, brec)) {
-		hfs_warn("hfs_bfind: corrupt btree\n");
-		hfs_brec_relse(brec, NULL);
-		return NULL;
+	if (fd->record + 1 < num_recs) {
+		/* new record is in the lower half,
+		 * so leave some more space there
+		 */
+		old_rec_off += 2;
+		num_recs--;
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+	} else {
+		hfs_bnode_put(node);
+		hfs_bnode_get(new_node);
+		fd->bnode = new_node;
+		fd->record -= num_recs;
+		fd->keyoffset -= data_start - 14;
+		fd->entryoffset -= data_start - 14;
 	}
+	new_node->num_recs = node->num_recs - num_recs;
+	node->num_recs = num_recs;
 
-	++elem;
-	++brec->bottom;
+	new_rec_off = tree->node_size - 2;
+	new_off = 14;
+	size = data_start - new_off;
+	num_recs = new_node->num_recs;
+	data_end = data_start;
+	while (num_recs) {
+		hfs_bnode_write_u16(new_node, new_rec_off, new_off);
+		old_rec_off -= 2;
+		new_rec_off -= 2;
+		data_end = hfs_bnode_read_u16(node, old_rec_off);
+		new_off = data_end - size;
+		num_recs--;
+	}
+	hfs_bnode_write_u16(new_node, new_rec_off, new_off);
+	hfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);
 
-	elem->bnr = hfs_bnode_find(brec->tree, node, lock_type);
-	if (!elem->bnr.bn) {
-		hfs_brec_relse(brec, NULL);
-		return NULL;
+	/* update new bnode header */
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));
+
+	/* update previous bnode header */
+	node->next = new_node->this;
+	hfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));
+	node_desc.next = cpu_to_be32(node->next);
+	node_desc.num_recs = cpu_to_be16(node->num_recs);
+	hfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));
+
+	/* update next bnode header */
+	if (new_node->next) {
+		struct hfs_bnode *next_node = hfs_bnode_find(tree, new_node->next);
+		next_node->prev = new_node->this;
+		hfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));
+		node_desc.prev = cpu_to_be32(next_node->prev);
+		hfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));
+		hfs_bnode_put(next_node);
+	} else if (node->this == tree->leaf_tail) {
+		/* if there is no next node, this might be the new tail */
+		tree->leaf_tail = new_node->this;
+		mark_inode_dirty(tree->inode);
 	}
-	elem->record = elem->bnr.bn->ndNRecs;
 
-	return elem;
+	hfs_bnode_dump(node);
+	hfs_bnode_dump(new_node);
+	hfs_bnode_put(node);
+
+	return new_node;
 }
 
-/*
- * hfs_brec_lock()
- *
- * Description:
- *   This function obtains HFS_LOCK_WRITE access to the bnode
- *   containing this hfs_brec.	All descendents in the path from this
- *   record to the leaf are given HFS_LOCK_WRITE access and all
- *   ancestors in the path from the root to here are released.
- * Input Variable(s):
- *   struct hfs_brec *brec: pointer to the brec to obtain
- *    HFS_LOCK_WRITE access to some of the nodes of.
- *   struct hfs_belem *elem: the first node to lock or NULL for all
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'brec' points to a "valid" (struct hfs_brec)
- * Postconditions: 
- *   All nodes between the indicated node and the beginning of the path
- *    are released.  hfs_bnode_lock() is called in turn on each node
- *    from the indicated node to the leaf node of the path, with a
- *    lock_type argument of HFS_LOCK_WRITE.  If one of those calls
- *    results in deadlock, then this function will never return.
- */
-void hfs_brec_lock(struct hfs_brec *brec, struct hfs_belem *elem) 
+int hfs_brec_update_parent(struct hfs_find_data *fd)
 {
-	if (!elem) {
-		elem = brec->top;
-	} else if (elem > brec->top) {
-		hfs_brec_relse(brec, elem-1);
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node, *parent;
+	int newkeylen, diff;
+	int rec, rec_off, end_rec_off;
+	int start_off, end_off;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = NULL;
+	if (!node->parent)
+		return 0;
+
+again:
+	parent = hfs_bnode_find(tree, node->parent);
+	if (IS_ERR(parent))
+		return PTR_ERR(parent);
+	__hfs_brec_find(parent, fd);
+	hfs_bnode_dump(parent);
+	rec = fd->record;
+
+	/* size difference between old and new key */
+	if (tree->attributes & HFS_TREE_VARIDXKEYS)
+		newkeylen = (hfs_bnode_read_u8(node, 14) | 1) + 1;
+	else
+		fd->keylength = newkeylen = tree->max_key_len + 1;
+	dprint(DBG_BNODE_MOD, "update_rec: %d, %d, %d\n", rec, fd->keylength, newkeylen);
+
+	rec_off = tree->node_size - (rec + 2) * 2;
+	end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+	diff = newkeylen - fd->keylength;
+	if (!diff)
+		goto skip;
+	if (diff > 0) {
+		end_off = hfs_bnode_read_u16(parent, end_rec_off);
+		if (end_rec_off - end_off < diff) {
+
+			printk("splitting index node...\n");
+			fd->bnode = parent;
+			new_node = hfs_bnode_split(fd);
+			if (IS_ERR(new_node))
+				return PTR_ERR(new_node);
+			parent = fd->bnode;
+			rec = fd->record;
+			rec_off = tree->node_size - (rec + 2) * 2;
+			end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+		}
 	}
 
-	while (elem <= brec->bottom) {
-		hfs_bnode_lock(&elem->bnr, HFS_LOCK_WRITE);
-		++elem;
+	end_off = start_off = hfs_bnode_read_u16(parent, rec_off);
+	hfs_bnode_write_u16(parent, rec_off, start_off + diff);
+	start_off -= 4;	/* move previous cnid too */
+
+	while (rec_off > end_rec_off) {
+		rec_off -= 2;
+		end_off = hfs_bnode_read_u16(parent, rec_off);
+		hfs_bnode_write_u16(parent, rec_off, end_off + diff);
+	}
+	hfs_bnode_move(parent, start_off + diff, start_off,
+		       end_off - start_off);
+skip:
+	hfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);
+	if (!(tree->attributes & HFS_TREE_VARIDXKEYS))
+		hfs_bnode_write_u8(parent, fd->keyoffset, newkeylen - 1);
+	hfs_bnode_dump(parent);
+
+	hfs_bnode_put(node);
+	node = parent;
+
+	if (new_node) {
+		u32 cnid;
+
+		fd->bnode = hfs_bnode_find(tree, new_node->parent);
+		/* create index key and entry */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		cnid = cpu_to_be32(new_node->this);
+
+		__hfs_brec_find(fd->bnode, fd);
+		hfs_brec_insert(fd, &cnid, sizeof(cnid));
+		hfs_bnode_put(fd->bnode);
+		hfs_bnode_put(new_node);
+
+		if (!rec) {
+			if (new_node == node)
+				goto out;
+			/* restore search_key */
+			hfs_bnode_read_key(node, fd->search_key, 14);
+		}
 	}
+
+	if (!rec && node->parent)
+		goto again;
+out:
+	fd->bnode = node;
+	return 0;
 }
 
-/*
- * hfs_brec_init()
- *
- * Description:
- *   Obtain access to the root node of a B-tree.
- *   Note that this first must obtain access to the header node.
- * Input Variable(s):
- *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to
- *    initialize
- *   struct hfs_btree *btree: pointer to the (struct hfs_btree)
- *   int lock_type: the type of access to get to the nodes.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   struct hfs_belem *: pointer to the root path element or NULL
- * Preconditions:
- *   'brec' points to a (struct hfs_brec).
- *   'tree' points to a valid (struct hfs_btree).
- * Postconditions:
- *   If the two calls to brec_bnode_find() succeed then the return value
- *   points to a (struct hfs_belem) which corresponds to the root node
- *   of 'brec->tree'.
- *   Both the root and header nodes are obtained with the type of lock
- *   given by (flags & HFS_LOCK_MASK).
- *   The fields 'record' field of the root is set to its last record.
- *   If the header node is not needed to complete the appropriate
- *   operation (as determined by the 'keep_flags' field of 'brec') then
- *   it is released before this function returns.
- *   If either call to brec_bnode_find() fails, NULL is returned and the
- *   (struct hfs_brec) pointed to by 'brec' is invalid.
- */
-struct hfs_belem *hfs_brec_init(struct hfs_brec *brec, struct hfs_btree *tree,
-				int flags)
+int hfs_btree_inc_height(struct hfs_btree *tree)
 {
-	struct hfs_belem *head = &brec->elem[0];
-	struct hfs_belem *root = &brec->elem[1];
-	int lock_type = flags & HFS_LOCK_MASK;
-
-	brec->tree = tree;
-
-	head->bnr = hfs_bnode_find(tree, 0, lock_type);
-	if (!head->bnr.bn) {
-		return NULL;
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int key_size, rec;
+	u32 cnid;
+
+	node = NULL;
+	if (tree->root) {
+		node = hfs_bnode_find(tree, tree->root);
+		if (IS_ERR(node))
+			return PTR_ERR(node);
 	}
-
-	root->bnr = hfs_bnode_find(tree, tree->bthRoot, lock_type);
-	if (!root->bnr.bn) {
-		hfs_bnode_relse(&head->bnr);
-		return NULL;
+	new_node = hfs_bmap_alloc(tree);
+	if (IS_ERR(new_node)) {
+		hfs_bnode_put(node);
+		return PTR_ERR(new_node);
 	}
 
-	root->record = root->bnr.bn->ndNRecs;
-	
-	brec->top = head;
-	brec->bottom = root;
-	
-	brec->keep_flags = flags & HFS_BPATH_MASK;
-
-	/* HFS_BPATH_FIRST not applicable for root */
-	/* and HFS_BPATH_UNDERFLOW is different */
-	root->flags = overflow(tree, root->bnr.bn);
-	if (root->record < 3) {
-		root->flags |= HFS_BPATH_UNDERFLOW;
+	tree->root = new_node->this;
+	if (!tree->depth) {
+		tree->leaf_head = tree->leaf_tail = new_node->this;
+		new_node->type = HFS_NODE_LEAF;
+		new_node->num_recs = 0;
+	} else {
+		new_node->type = HFS_NODE_INDEX;
+		new_node->num_recs = 1;
 	}
+	new_node->parent = 0;
+	new_node->next = 0;
+	new_node->prev = 0;
+	new_node->height = ++tree->depth;
+
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));
+
+	rec = tree->node_size - 2;
+	hfs_bnode_write_u16(new_node, rec, 14);
+
+	if (node) {
+		/* insert old root idx into new root */
+		node->parent = tree->root;
+		if (node->type == HFS_NODE_LEAF ||
+		    tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_size = hfs_bnode_read_u8(node, 14) + 1;
+		else
+			key_size = tree->max_key_len + 1;
+		hfs_bnode_copy(new_node, 14, node, 14, key_size);
+
+		if (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {
+			key_size = tree->max_key_len + 1;
+			hfs_bnode_write_u8(new_node, 14, tree->max_key_len);
+		}
+		key_size = (key_size + 1) & -2;
+		cnid = cpu_to_be32(node->this);
+		hfs_bnode_write(new_node, &cnid, 14 + key_size, 4);
+
+		rec -= 2;
+		hfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);
 
-	if (!(root->flags & brec->keep_flags)) {
-		hfs_brec_relse(brec, head);
+		hfs_bnode_put(node);
 	}
+	hfs_bnode_put(new_node);
+	mark_inode_dirty(tree->inode);
 
-	return root;
+	return 0;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/btree.c linuxppc-2.5-benh/fs/hfs/btree.c
--- /dev/shm/linux-2.5/fs/hfs/btree.c	2002-07-20 17:49:48.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/btree.c	2003-12-24 03:48:17.000000000 +0000
@@ -1,323 +1,333 @@
 /*
- * linux/fs/hfs/btree.c
+ *  linux/fs/hfsplus/btree.c
  *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
  *
- * This file contains the code to manipulate the B-tree structure.
- * The catalog and extents files are both B-trees.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- *
- * The code in this file initializes some structures which contain
- * pointers by calling memset(&foo, 0, sizeof(foo)).
- * This produces the desired behavior only due to the non-ANSI
- * assumption that the machine representation of NULL is all zeros.
+ * Handle opening/closing btree
  */
 
-#include "hfs_btree.h"
-
-/*================ File-local functions ================*/
+#include <linux/pagemap.h>
 
-/*
- * hfs_bnode_ditch() 
- *
- * Description:
- *   This function deletes an entire linked list of bnodes, so it
- *   does not need to keep the linked list consistent as
- *   hfs_bnode_delete() does.
- *   Called by hfs_btree_init() for error cleanup and by hfs_btree_free().
- * Input Variable(s):
- *   struct hfs_bnode *bn: pointer to the first (struct hfs_bnode) in
- *    the linked list to be deleted.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'bn' is NULL or points to a "valid" (struct hfs_bnode) with a 'prev'
- *    field of NULL.
- * Postconditions:
- *   'bn' and all (struct hfs_bnode)s in the chain of 'next' pointers
- *   are deleted, freeing the associated memory and hfs_buffer_put()ing
- *   the associated buffer.
- */
-static void hfs_bnode_ditch(struct hfs_bnode *bn) {
-	struct hfs_bnode *tmp;
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-	extern int bnode_count;
-#endif
+#include "btree.h"
 
-	while (bn != NULL) {
-		tmp = bn->next;
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-		hfs_warn("deleting node %d from tree %d with count %d\n",
-		         bn->node, (int)ntohl(bn->tree->entry.cnid), bn->count);
-		--bnode_count;
+/* Get a reference to a B*Tree and do some initial checks */
+struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp)
+{
+	struct hfs_btree *tree;
+	struct hfs_btree_header_rec *head;
+	struct address_space *mapping;
+	struct page *page;
+	unsigned int shift, size;
+
+	tree = kmalloc(sizeof(*tree), GFP_KERNEL);
+	if (!tree)
+		return NULL;
+	memset(tree, 0, sizeof(*tree));
+
+	init_MUTEX(&tree->tree_lock);
+	spin_lock_init(&tree->hash_lock);
+	/* Set the correct compare function */
+	tree->sb = sb;
+	tree->cnid = id;
+	tree->keycmp = keycmp;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	tree->inode = iget_locked(sb, id);
+	if (!tree->inode)
+		goto free_tree;
+	if (!(tree->inode->i_state & I_NEW))
+		BUG();
+	{
+	struct hfs_mdb *mdb = HFS_SB(sb)->mdb;
+	HFS_I(tree->inode)->flags = 0;
+	init_MUTEX(&HFS_I(tree->inode)->extents_lock);
+	switch (id) {
+	case HFS_EXT_CNID:
+		hfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,
+				    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));
+		tree->inode->i_mapping->a_ops = &hfs_btree_aops;
+		break;
+	case HFS_CAT_CNID:
+		hfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,
+				    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));
+		tree->inode->i_mapping->a_ops = &hfs_btree_aops;
+		break;
+	default:
+		BUG();
+	}
+	}
+	unlock_new_inode(tree->inode);
+#else
+	tree->inode = iget(sb, id);
+	if (!tree->inode)
+		goto free_tree;
 #endif
-		hfs_buffer_put(bn->buf); /* safe: checks for NULL argument */
 
-		/* free all but the header */
-		if (bn->node) {
-			HFS_DELETE(bn);
-		}
-		bn = tmp;
-	}
+	mapping = tree->inode->i_mapping;
+	page = read_cache_page(mapping, 0, (filler_t *)mapping->a_ops->readpage, NULL);
+	if (IS_ERR(page))
+		goto free_tree;
+
+	/* Load the header */
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+	tree->root = be32_to_cpu(head->root);
+	tree->leaf_count = be32_to_cpu(head->leaf_count);
+	tree->leaf_head = be32_to_cpu(head->leaf_head);
+	tree->leaf_tail = be32_to_cpu(head->leaf_tail);
+	tree->node_count = be32_to_cpu(head->node_count);
+	tree->free_nodes = be32_to_cpu(head->free_nodes);
+	tree->attributes = be32_to_cpu(head->attributes);
+	tree->node_size = be16_to_cpu(head->node_size);
+	tree->max_key_len = be16_to_cpu(head->max_key_len);
+	tree->depth = be16_to_cpu(head->depth);
+
+	size = tree->node_size;
+	if (!size || size & (size - 1))
+		goto fail_page;
+	if (!tree->node_count)
+		goto fail_page;
+	for (shift = 0; size >>= 1; shift += 1)
+		;
+	tree->node_size_shift = shift;
+
+	tree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+
+	kunmap(page);
+	page_cache_release(page);
+	return tree;
+
+ fail_page:
+	tree->inode->i_mapping->a_ops = &hfs_aops;
+	page_cache_release(page);
+ free_tree:
+	iput(tree->inode);
+	kfree(tree);
+	return NULL;
 }
 
-/*================ Global functions ================*/
-
-/*
- * hfs_btree_free()
- *
- * Description:
- *   This function frees a (struct hfs_btree) obtained from hfs_btree_init().
- *   Called by hfs_put_super().
- * Input Variable(s):
- *   struct hfs_btree *bt: pointer to the (struct hfs_btree) to free
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'bt' is NULL or points to a "valid" (struct hfs_btree)
- * Postconditions:
- *   If 'bt' points to a "valid" (struct hfs_btree) then all (struct
- *    hfs_bnode)s associated with 'bt' are freed by calling
- *    hfs_bnode_ditch() and the memory associated with the (struct
- *    hfs_btree) is freed.
- *   If 'bt' is NULL or not "valid" an error is printed and nothing
- *    is changed.
- */
-void hfs_btree_free(struct hfs_btree *bt)
+/* Release resources used by a btree */
+void hfs_btree_close(struct hfs_btree *tree)
 {
-	int lcv;
+	struct hfs_bnode *node;
+	int i;
 
-	if (bt && (bt->magic == HFS_BTREE_MAGIC)) {
-		hfs_extent_free(&bt->entry.u.file.data_fork);
+	if (!tree)
+		return;
 
-		for (lcv=0; lcv<HFS_CACHELEN; ++lcv) {
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-			hfs_warn("deleting nodes from bucket %d:\n", lcv);
-#endif
-			hfs_bnode_ditch(bt->cache[lcv]);
+	for (i = 0; i < NODE_HASH_SIZE; i++) {
+		while ((node = tree->node_hash[i])) {
+			tree->node_hash[i] = node->next_hash;
+			if (atomic_read(&node->refcnt))
+				printk("HFS+: node %d:%d still has %d user(s)!\n",
+					node->tree->cnid, node->this, atomic_read(&node->refcnt));
+			hfs_bnode_free(node);
+			tree->node_hash_cnt--;
 		}
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-		hfs_warn("deleting header and bitmap nodes\n");
-#endif
-		hfs_bnode_ditch(&bt->head);
-
-#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
-		hfs_warn("deleting root node\n");
-#endif
-		hfs_bnode_ditch(bt->root);
-
-		HFS_DELETE(bt);
-	} else if (bt) {
-		hfs_warn("hfs_btree_free: corrupted hfs_btree.\n");
 	}
+	iput(tree->inode);
+	kfree(tree);
 }
 
-/*
- * hfs_btree_init()
- *
- * Description:
- *   Given some vital information from the MDB (HFS superblock),
- *   initializes the fields of a (struct hfs_btree).
- * Input Variable(s):
- *   struct hfs_mdb *mdb: pointer to the MDB
- *   ino_t cnid: the CNID (HFS_CAT_CNID or HFS_EXT_CNID) of the B-tree
- *   hfs_u32 tsize: the size, in bytes, of the B-tree
- *   hfs_u32 csize: the size, in bytes, of the clump size for the B-tree
- * Output Variable(s):
- *   NONE
- * Returns:
- *   (struct hfs_btree *): pointer to the initialized hfs_btree on success,
- *    or NULL on failure
- * Preconditions:
- *   'mdb' points to a "valid" (struct hfs_mdb)
- * Postconditions:
- *   Assuming the inputs are what they claim to be, no errors occur
- *   reading from disk, and no inconsistencies are noticed in the data
- *   read from disk, the return value is a pointer to a "valid"
- *   (struct hfs_btree).  If there are errors reading from disk or
- *   inconsistencies are noticed in the data read from disk, then and
- *   all resources that were allocated are released and NULL is
- *   returned.	If the inputs are not what they claim to be or if they
- *   are unnoticed inconsistencies in the data read from disk then the
- *   returned hfs_btree is probably going to lead to errors when it is
- *   used in a non-trivial way.
- */
-struct hfs_btree * hfs_btree_init(struct hfs_mdb *mdb, ino_t cnid,
-				  hfs_byte_t ext[12],
-				  hfs_u32 tsize, hfs_u32 csize)
+void hfs_btree_write(struct hfs_btree *tree)
 {
-	struct hfs_btree * bt;
-	struct BTHdrRec * th;
-	struct hfs_bnode * tmp;
-	unsigned int next;
-#if defined(DEBUG_HEADER) || defined(DEBUG_ALL)
-	unsigned char *p, *q;
-#endif
-
-	if (!mdb || !ext || !HFS_NEW(bt)) {
-		goto bail3;
-	}
-
-	bt->magic = HFS_BTREE_MAGIC;
-	bt->sys_mdb = mdb->sys_mdb;
-	bt->reserved = 0;
-	sema_init(&bt->sem, 1);
-	bt->dirt = 0;
-	memset(bt->cache, 0, sizeof(bt->cache));
-
-#if 0   /* this is a fake entry. so we don't need to initialize it. */
-	memset(&bt->entry, 0, sizeof(bt->entry));
-	hfs_init_waitqueue(&bt->entry.wait);
-	INIT_LIST_HEAD(&bt->entry.hash);
-	INIT_LIST_HEAD(&bt->entry.list);
-#endif
-
-	bt->entry.mdb = mdb;
-	bt->entry.cnid = cnid;
-	bt->entry.type = HFS_CDR_FIL;
-	bt->entry.u.file.magic = HFS_FILE_MAGIC;
-	bt->entry.u.file.clumpablks = (csize / mdb->alloc_blksz)
-						>> HFS_SECTOR_SIZE_BITS;
-	bt->entry.u.file.data_fork.entry = &bt->entry;
-	bt->entry.u.file.data_fork.lsize = tsize;
-	bt->entry.u.file.data_fork.psize = tsize >> HFS_SECTOR_SIZE_BITS;
-	bt->entry.u.file.data_fork.fork = HFS_FK_DATA;
-	hfs_extent_in(&bt->entry.u.file.data_fork, ext);
-
-	hfs_bnode_read(&bt->head, bt, 0, HFS_STICKY);
-	if (!hfs_buffer_ok(bt->head.buf)) {
-		goto bail2;
-	}
-	th = (struct BTHdrRec *)((char *)hfs_buffer_data(bt->head.buf) +
-						sizeof(struct NodeDescriptor));
+	struct hfs_btree_header_rec *head;
+	struct hfs_bnode *node;
+	struct page *page;
+
+	node = hfs_bnode_find(tree, 0);
+	if (IS_ERR(node))
+		/* panic? */
+		return;
+	/* Load the header */
+	page = node->page[0];
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+
+	head->root = cpu_to_be32(tree->root);
+	head->leaf_count = cpu_to_be32(tree->leaf_count);
+	head->leaf_head = cpu_to_be32(tree->leaf_head);
+	head->leaf_tail = cpu_to_be32(tree->leaf_tail);
+	head->node_count = cpu_to_be32(tree->node_count);
+	head->free_nodes = cpu_to_be32(tree->free_nodes);
+	head->attributes = cpu_to_be32(tree->attributes);
+	head->depth = cpu_to_be16(tree->depth);
+
+	kunmap(page);
+	set_page_dirty(page);
+	hfs_bnode_put(node);
+}
 
-	/* read in the bitmap nodes (if any) */
-	tmp = &bt->head;
-	while ((next = tmp->ndFLink)) {
-		if (!HFS_NEW(tmp->next)) {
-			goto bail2;
-		}
-		hfs_bnode_read(tmp->next, bt, next, HFS_STICKY);
-		if (!hfs_buffer_ok(tmp->next->buf)) {
-			goto bail2;
-		}
-		tmp->next->prev = tmp;
-		tmp = tmp->next;
-	}
+static struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)
+{
+	struct hfs_btree *tree = prev->tree;
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc desc;
+	u32 cnid;
+
+	node = hfs_bnode_create(tree, idx);
+	if (IS_ERR(node))
+		return node;
+
+	if (!tree->free_nodes)
+		panic("FIXME!!!");
+	tree->free_nodes--;
+	prev->next = idx;
+	cnid = cpu_to_be32(idx);
+	hfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+
+	node->type = HFS_NODE_MAP;
+	node->num_recs = 1;
+	hfs_bnode_clear(node, 0, tree->node_size);
+	desc.next = 0;
+	desc.prev = 0;
+	desc.type = HFS_NODE_MAP;
+	desc.height = 0;
+	desc.num_recs = cpu_to_be16(1);
+	desc.reserved = 0;
+	hfs_bnode_write(node, &desc, 0, sizeof(desc));
+	hfs_bnode_write_u16(node, 14, 0x8000);
+	hfs_bnode_write_u16(node, tree->node_size - 2, 14);
+	hfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);
 
-	if (hfs_get_ns(th->bthNodeSize) != htons(HFS_SECTOR_SIZE)) {
-		hfs_warn("hfs_btree_init: bthNodeSize!=512 not supported\n");
-		goto bail2;
-	}
+	return node;
+}
 
-	if (cnid == htonl(HFS_CAT_CNID)) {
-		bt->compare = (hfs_cmpfn)hfs_cat_compare;
-	} else if (cnid == htonl(HFS_EXT_CNID)) {
-		bt->compare = (hfs_cmpfn)hfs_ext_compare;
-	} else {
-		goto bail2;
-	}
-	bt->bthDepth  = hfs_get_hs(th->bthDepth);
-	bt->bthRoot   = hfs_get_hl(th->bthRoot);
-	bt->bthNRecs  = hfs_get_hl(th->bthNRecs);
-	bt->bthFNode  = hfs_get_hl(th->bthFNode);
-	bt->bthLNode  = hfs_get_hl(th->bthLNode);
-	bt->bthNNodes = hfs_get_hl(th->bthNNodes);
-	bt->bthFree   = hfs_get_hl(th->bthFree);
-	bt->bthKeyLen = hfs_get_hs(th->bthKeyLen);
-
-#if defined(DEBUG_HEADER) || defined(DEBUG_ALL)
-	hfs_warn("bthDepth %d\n", bt->bthDepth);
-	hfs_warn("bthRoot %d\n", bt->bthRoot);
-	hfs_warn("bthNRecs %d\n", bt->bthNRecs);
-	hfs_warn("bthFNode %d\n", bt->bthFNode);
-	hfs_warn("bthLNode %d\n", bt->bthLNode);
-	hfs_warn("bthKeyLen %d\n", bt->bthKeyLen);
-	hfs_warn("bthNNodes %d\n", bt->bthNNodes);
-	hfs_warn("bthFree %d\n", bt->bthFree);
-	p = (unsigned char *)hfs_buffer_data(bt->head.buf);
-	q = p + HFS_SECTOR_SIZE;
-	while (p < q) {
-		hfs_warn("%02x %02x %02x %02x %02x %02x %02x %02x "
-		         "%02x %02x %02x %02x %02x %02x %02x %02x\n",
-			 *p++, *p++, *p++, *p++, *p++, *p++, *p++, *p++,
-			 *p++, *p++, *p++, *p++, *p++, *p++, *p++, *p++);
+struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)
+{
+	struct hfs_bnode *node, *next_node;
+	struct page **pagep;
+	u32 nidx, idx;
+	u16 off, len;
+	u8 *data, byte, m;
+	int i;
+
+	while (!tree->free_nodes) {
+		struct inode *inode = tree->inode;
+		u32 count;
+		int res;
+
+		res = hfs_extend_file(inode);
+		if (res)
+			return ERR_PTR(res);
+		inode->i_blocks = HFS_I(inode)->alloc_blocks *
+				  HFS_SB(tree->sb)->fs_div;
+		HFS_I(inode)->phys_size = inode->i_size =
+			(loff_t)inode->i_blocks << tree->sb->s_blocksize_bits;
+		count = inode->i_size >> tree->node_size_shift;
+		tree->free_nodes = count - tree->node_count;
+		tree->node_count = count;
 	}
-#endif
 
-	/* Read in the root if it exists.
-	   The header always exists, but the root exists only if the
-	   tree is non-empty */
-	if (bt->bthDepth && bt->bthRoot) {
-		if (!HFS_NEW(bt->root)) {
-			goto bail2;
+	nidx = 0;
+	node = hfs_bnode_find(tree, nidx);
+	if (IS_ERR(node))
+		return node;
+	len = hfs_brec_lenoff(node, 2, &off);
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	data = kmap(*pagep);
+	off &= ~PAGE_CACHE_MASK;
+	idx = 0;
+
+	for (;;) {
+		while (len) {
+			byte = data[off];
+			if (byte != 0xff) {
+				for (m = 0x80, i = 0; i < 8; m >>= 1, i++) {
+					if (!(byte & m)) {
+						idx += i;
+						data[off] |= m;
+						set_page_dirty(*pagep);
+						kunmap(*pagep);
+						tree->free_nodes--;
+						mark_inode_dirty(tree->inode);
+						hfs_bnode_put(node);
+						return hfs_bnode_create(tree, idx);
+					}
+				}
+			}
+			if (++off >= PAGE_CACHE_SIZE) {
+				kunmap(*pagep);
+				data = kmap(*++pagep);
+				off = 0;
+			}
+			idx += 8;
+			len--;
 		}
-		hfs_bnode_read(bt->root, bt, bt->bthRoot, HFS_STICKY);
-		if (!hfs_buffer_ok(bt->root->buf)) {
-			goto bail1;
-		}
-	} else {
-		bt->root = NULL;
+		kunmap(*pagep);
+		nidx = node->next;
+		if (!nidx) {
+			printk("create new bmap node...\n");
+			next_node = hfs_bmap_new_bmap(node, idx);
+		} else
+			next_node = hfs_bnode_find(tree, nidx);
+		hfs_bnode_put(node);
+		if (IS_ERR(next_node))
+			return next_node;
+		node = next_node;
+
+		len = hfs_brec_lenoff(node, 0, &off);
+		off += node->page_offset;
+		pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+		data = kmap(*pagep);
+		off &= ~PAGE_CACHE_MASK;
 	}
-
-	return bt;
-
- bail1:
-	hfs_bnode_ditch(bt->root);
- bail2:
-	hfs_bnode_ditch(&bt->head);
-	HFS_DELETE(bt);
- bail3:
-	return NULL;
 }
 
-/*
- * hfs_btree_commit()
- *
- * Called to write a possibly dirty btree back to disk.
- */
-void hfs_btree_commit(struct hfs_btree *bt, hfs_byte_t ext[12], hfs_lword_t size)
+void hfs_bmap_free(struct hfs_bnode *node)
 {
-	if (bt->dirt) {
-		struct BTHdrRec *th;
-		th = (struct BTHdrRec *)((char *)hfs_buffer_data(bt->head.buf) +
-						 sizeof(struct NodeDescriptor));
-
-		hfs_put_hs(bt->bthDepth,  th->bthDepth);
-		hfs_put_hl(bt->bthRoot,   th->bthRoot);
-		hfs_put_hl(bt->bthNRecs,  th->bthNRecs);
-		hfs_put_hl(bt->bthFNode,  th->bthFNode);
-		hfs_put_hl(bt->bthLNode,  th->bthLNode);
-		hfs_put_hl(bt->bthNNodes, th->bthNNodes);
-		hfs_put_hl(bt->bthFree,   th->bthFree);
-		hfs_buffer_dirty(bt->head.buf);
-
-		/*
-		 * Commit the bnodes which are not cached.
-		 * The map nodes don't need to be committed here because
-		 * they are committed every time they are changed.
-		 */
-		hfs_bnode_commit(&bt->head);
-		if (bt->root) {
-			hfs_bnode_commit(bt->root);
+	struct hfs_btree *tree;
+	struct page *page;
+	u16 off, len;
+	u32 nidx;
+	u8 *data, byte, m;
+
+	dprint(DBG_BNODE_MOD, "btree_free_node: %u\n", node->this);
+	tree = node->tree;
+	nidx = node->this;
+	node = hfs_bnode_find(tree, 0);
+	if (IS_ERR(node))
+		return;
+	len = hfs_brec_lenoff(node, 2, &off);
+	while (nidx >= len * 8) {
+		u32 i;
+
+		nidx -= len * 8;
+		i = node->next;
+		hfs_bnode_put(node);
+		if (!i) {
+			/* panic */;
+			printk("HFS: unable to free bnode %u. bmap not found!\n", node->this);
+			return;
 		}
-
-	
-		hfs_put_hl(bt->bthNNodes << HFS_SECTOR_SIZE_BITS, size);
-		hfs_extent_out(&bt->entry.u.file.data_fork, ext);
-		/* hfs_buffer_dirty(mdb->buf); (Done by caller) */
-
-		bt->dirt = 0;
+		node = hfs_bnode_find(tree, i);
+		if (IS_ERR(node))
+			return;
+		if (node->type != HFS_NODE_MAP) {
+			/* panic */;
+			printk("HFS: invalid bmap found! (%u,%d)\n", node->this, node->type);
+			hfs_bnode_put(node);
+			return;
+		}
+		len = hfs_brec_lenoff(node, 0, &off);
+	}
+	off += node->page_offset + nidx / 8;
+	page = node->page[off >> PAGE_CACHE_SHIFT];
+	data = kmap(page);
+	off &= ~PAGE_CACHE_MASK;
+	m = 1 << (~nidx & 7);
+	byte = data[off];
+	if (!(byte & m)) {
+		printk("HFS: trying to free free bnode %u(%d)\n", node->this, node->type);
+		kunmap(page);
+		hfs_bnode_put(node);
+		return;
 	}
+	data[off] = byte & ~m;
+	set_page_dirty(page);
+	kunmap(page);
+	hfs_bnode_put(node);
+	tree->free_nodes++;
+	mark_inode_dirty(tree->inode);
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/btree.h linuxppc-2.5-benh/fs/hfs/btree.h
--- /dev/shm/linux-2.5/fs/hfs/btree.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/btree.h	2003-12-24 03:25:25.000000000 +0000
@@ -0,0 +1,164 @@
+
+#include "hfs_fs.h"
+
+typedef int (*btree_keycmp)(const btree_key *, const btree_key *);
+
+#define NODE_HASH_SIZE  256
+
+/* An HFS+ BTree held in memory */
+struct hfs_btree {
+	struct super_block *sb;
+	struct inode *inode;
+	btree_keycmp keycmp;
+
+	u32 cnid;
+	u32 root;
+	u32 leaf_count;
+	u32 leaf_head;
+	u32 leaf_tail;
+	u32 node_count;
+	u32 free_nodes;
+	u32 attributes;
+
+	unsigned int node_size;
+	unsigned int node_size_shift;
+	unsigned int max_key_len;
+	unsigned int depth;
+
+	//unsigned int map1_size, map_size;
+	struct semaphore tree_lock;
+
+	unsigned int pages_per_bnode;
+	spinlock_t hash_lock;
+	struct hfs_bnode *node_hash[NODE_HASH_SIZE];
+	int node_hash_cnt;
+};
+
+/* An HFS+ BTree node in memory */
+struct hfs_bnode {
+	struct hfs_btree *tree;
+
+	u32 prev;
+	u32 this;
+	u32 next;
+	u32 parent;
+
+	u16 num_recs;
+	u8 type;
+	u8 height;
+
+	struct hfs_bnode *next_hash;
+	unsigned long flags;
+	wait_queue_head_t lock_wq;
+	atomic_t refcnt;
+	unsigned int page_offset;
+	struct page *page[0];
+};
+
+#define HFS_BNODE_ERROR		0
+#define HFS_BNODE_NEW		1
+#define HFS_BNODE_DELETED	2
+
+struct hfs_find_data {
+	btree_key *key;
+	btree_key *search_key;
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	int record;
+	int keyoffset, keylength;
+	int entryoffset, entrylength;
+};
+
+
+/* btree.c */
+extern struct hfs_btree *hfs_btree_open(struct super_block *, u32, btree_keycmp);
+extern void hfs_btree_close(struct hfs_btree *);
+extern void hfs_btree_write(struct hfs_btree *);
+extern struct hfs_bnode * hfs_bmap_alloc(struct hfs_btree *);
+extern void hfs_bmap_free(struct hfs_bnode *node);
+
+/* bnode.c */
+extern void hfs_bnode_read(struct hfs_bnode *, void *, int, int);
+extern u16 hfs_bnode_read_u16(struct hfs_bnode *, int);
+extern u8 hfs_bnode_read_u8(struct hfs_bnode *, int);
+extern void hfs_bnode_read_key(struct hfs_bnode *, void *, int);
+extern void hfs_bnode_write(struct hfs_bnode *, void *, int, int);
+extern void hfs_bnode_write_u16(struct hfs_bnode *, int, u16);
+extern void hfs_bnode_write_u8(struct hfs_bnode *, int, u8);
+extern void hfs_bnode_clear(struct hfs_bnode *, int, int);
+extern void hfs_bnode_copy(struct hfs_bnode *, int,
+			   struct hfs_bnode *, int, int);
+extern void hfs_bnode_move(struct hfs_bnode *, int, int, int);
+extern void hfs_bnode_dump(struct hfs_bnode *);
+extern void hfs_bnode_unlink(struct hfs_bnode *);
+extern struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *, u32);
+extern struct hfs_bnode *hfs_bnode_find(struct hfs_btree *, u32);
+extern void hfs_bnode_unhash(struct hfs_bnode *);
+extern void hfs_bnode_free(struct hfs_bnode *);
+extern struct hfs_bnode *hfs_bnode_create(struct hfs_btree *, u32);
+extern void hfs_bnode_get(struct hfs_bnode *);
+extern void hfs_bnode_put(struct hfs_bnode *);
+
+/* brec.c */
+extern u16 hfs_brec_lenoff(struct hfs_bnode *, u16, u16 *);
+extern u16 hfs_brec_keylen(struct hfs_bnode *, u16);
+extern int hfs_brec_insert(struct hfs_find_data *, void *, int);
+extern int hfs_brec_remove(struct hfs_find_data *);
+extern struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *);
+extern int hfs_brec_update_parent(struct hfs_find_data *);
+extern int hfs_btree_inc_height(struct hfs_btree *);
+
+/* bfind.c */
+extern int hfs_find_init(struct hfs_btree *, struct hfs_find_data *);
+extern void hfs_find_exit(struct hfs_find_data *);
+extern int __hfs_brec_find(struct hfs_bnode *, struct hfs_find_data *);
+extern int hfs_brec_find(struct hfs_find_data *);
+extern int hfs_brec_read(struct hfs_find_data *, void *, int);
+extern int hfs_brec_goto(struct hfs_find_data *, int);
+
+
+struct hfs_bnode_desc {
+	u32 next;		/* (V) Number of the next node at this level */
+	u32 prev;		/* (V) Number of the prev node at this level */
+	u8 type;		/* (F) The type of node */
+	u8 height;		/* (F) The level of this node (leaves=1) */
+	u16 num_recs;		/* (V) The number of records in this node */
+	u16 reserved;
+} __packed;
+
+#define HFS_NODE_INDEX	0x00	/* An internal (index) node */
+#define HFS_NODE_HEADER	0x01	/* The tree header node (node 0) */
+#define HFS_NODE_MAP	0x02	/* Holds part of the bitmap of used nodes */
+#define HFS_NODE_LEAF	0xFF	/* A leaf (ndNHeight==1) node */
+
+struct hfs_btree_header_rec {
+	u16 depth;		/* (V) The number of levels in this B-tree */
+	u32 root;		/* (V) The node number of the root node */
+	u32 leaf_count;		/* (V) The number of leaf records */
+	u32 leaf_head;		/* (V) The number of the first leaf node */
+	u32 leaf_tail;		/* (V) The number of the last leaf node */
+	u16 node_size;		/* (F) The number of bytes in a node (=512) */
+	u16 max_key_len;	/* (F) The length of a key in an index node */
+	u32 node_count;		/* (V) The total number of nodes */
+	u32 free_nodes;		/* (V) The number of unused nodes */
+	u16 reserved1;
+	u32 clump_size;		/* (F) clump size. not usually used. */
+	u8 btree_type;		/* (F) BTree type */
+	u8 reserved2;
+	u32 attributes;		/* (F) attributes */
+	u32 reserved3[16];
+} __packed;
+
+#define HFS_NODE_INDEX	0x00	/* An internal (index) node */
+#define HFS_NODE_HEADER	0x01	/* The tree header node (node 0) */
+#define HFS_NODE_MAP		0x02	/* Holds part of the bitmap of used nodes */
+#define HFS_NODE_LEAF		0xFF	/* A leaf (ndNHeight==1) node */
+
+#define BTREE_ATTR_BADCLOSE	0x00000001	/* b-tree not closed properly. not
+						   used by hfsplus. */
+#define HFS_TREE_BIGKEYS	0x00000002	/* key length is u16 instead of u8.
+						   used by hfsplus. */
+#define HFS_TREE_VARIDXKEYS	0x00000004	/* variable key length instead of
+						   max key length. use din catalog
+						   b-tree but not in extents
+						   b-tree (hfsplus). */
diff -purN /dev/shm/linux-2.5/fs/hfs/catalog.c linuxppc-2.5-benh/fs/hfs/catalog.c
--- /dev/shm/linux-2.5/fs/hfs/catalog.c	2002-10-07 14:40:26.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/catalog.c	2003-12-24 03:48:17.000000000 +0000
@@ -8,7 +8,7 @@
  *
  * "XXX" in a comment is a note to myself to consider changing something.
  *
- * Cache code shamelessly stolen from 
+ * Cache code shamelessly stolen from
  *     linux/fs/inode.c Copyright (C) 1991, 1992  Linus Torvalds
  *     re-shamelessly stolen Copyright (C) 1997 Linus Torvalds
  *
@@ -21,621 +21,64 @@
  * only due to the non-ANSI assumption that the machine representation
  */
 
-#include "hfs.h"
-
-/*================ Variable-like macros ================*/
-
-/* Number of hash table slots */
-#define C_HASHBITS  10
-#define C_HASHSIZE  (1UL << C_HASHBITS)
-#define C_HASHMASK  (C_HASHSIZE - 1)
-
-/* Number of entries to fit in a single page on an i386.
- * Actually, now it's used to increment the free entry pool. */
-#define CCACHE_INC (PAGE_SIZE/sizeof(struct hfs_cat_entry))
-#define CCACHE_MAX (CCACHE_INC * 8)
-
-/*================ File-local data types ================*/
-
-/* The catalog record for a file */
-typedef struct {
-	hfs_byte_t	Flags;		/* Flags such as read-only */
-	hfs_byte_t	Typ;		/* file version number = 0 */
-	hfs_finfo_t	UsrWds;		/* data used by the Finder */
-	hfs_lword_t	FlNum;		/* The CNID */
-	hfs_word_t	StBlk;		/* obsolete */
-	hfs_lword_t	LgLen;		/* The logical EOF of the data fork*/
-	hfs_lword_t	PyLen;		/* The physical EOF of the data fork */
-	hfs_word_t	RStBlk;		/* obsolete */
-	hfs_lword_t	RLgLen;		/* The logical EOF of the rsrc fork */
-	hfs_lword_t	RPyLen;		/* The physical EOF of the rsrc fork */
-	hfs_lword_t	CrDat;		/* The creation date */
-	hfs_lword_t	MdDat;		/* The modified date */
-	hfs_lword_t	BkDat;		/* The last backup date */
-	hfs_fxinfo_t	FndrInfo;	/* more data for the Finder */
-	hfs_word_t	ClpSize;	/* number of bytes to allocate
-					   when extending files */
-	hfs_byte_t	ExtRec[12];	/* first extent record
-					   for the data fork */
-	hfs_byte_t	RExtRec[12];	/* first extent record
-					   for the resource fork */
-	hfs_lword_t	Resrv;		/* reserved by Apple */
-} __attribute__((packed)) FIL_REC;
-
-/* the catalog record for a directory */
-typedef struct {
-	hfs_word_t	Flags;		/* flags */
-	hfs_word_t	Val;		/* Valence: number of files and
-					   dirs in the directory */
-	hfs_lword_t	DirID;		/* The CNID */
-	hfs_lword_t	CrDat;		/* The creation date */
-	hfs_lword_t	MdDat;		/* The modification date */
-	hfs_lword_t	BkDat;		/* The last backup date */
-	hfs_dinfo_t	UsrInfo;	/* data used by the Finder */
-	hfs_dxinfo_t	FndrInfo;	/* more data used by Finder */
-	hfs_byte_t	Resrv[16];	/* reserved by Apple */
-} __attribute__((packed)) DIR_REC;
-
-/* the catalog record for a thread */
-typedef struct {
-	hfs_byte_t		Reserv[8];	/* reserved by Apple */
-	hfs_lword_t		ParID;		/* CNID of parent directory */
-	struct hfs_name		CName;		/* The name of this entry */
-}  __attribute__((packed)) THD_REC;
-
-/* A catalog tree record */
-struct hfs_cat_rec {
-	hfs_byte_t		cdrType;	/* The type of entry */
-	hfs_byte_t		cdrResrv2;	/* padding */
-	union {
-		FIL_REC fil;
-		DIR_REC dir;
-		THD_REC thd;
-	} u;
-} __attribute__((packed));
-
-/*================ File-local variables ================*/
- 
-static LIST_HEAD(entry_in_use);
-static LIST_HEAD(entry_unused);
-static struct list_head hash_table[C_HASHSIZE];
-
-static spinlock_t entry_lock = SPIN_LOCK_UNLOCKED;
-
-static struct {
-        int nr_entries;
-        int nr_free_entries;
-} entries_stat;
-
-/*================ File-local functions ================*/
-
-/*
- * brec_to_id
- *
- * Get the CNID from a brec
- */
-static inline hfs_u32 brec_to_id(struct hfs_brec *brec)
-{
-	struct hfs_cat_rec *rec = brec->data;
-
-	return hfs_get_nl((rec->cdrType==HFS_CDR_FIL) ?
-				rec->u.fil.FlNum : rec->u.dir.DirID);
-}
-
-/*
- * hashfn()
- *
- * hash an (struct mdb *) and a (struct hfs_cat_key *) to an integer.
- */
-static inline unsigned int hashfn(const struct hfs_mdb *mdb,
-				  const struct hfs_cat_key *key)
-{
-	unsigned int hash;
-	
-	hash = (unsigned long) mdb | (unsigned long) key->ParID[3] | 
-		hfs_strhash(key->CName.Name, key->CName.Len);
-	hash = hash ^ (hash >> C_HASHBITS) ^ (hash >> C_HASHBITS*2);
-	return hash & C_HASHMASK;
-}
-
-/*
- * hash()
- *
- * hash an (struct mdb *) and a (struct hfs_cat_key *)
- * to a pointer to a slot in the hash table.
- */
-static inline struct list_head *hash(struct hfs_mdb *mdb,
-				     const struct hfs_cat_key *key)
-{
-	return hash_table + hashfn(mdb, key);
-}
-
-static inline void insert_hash(struct hfs_cat_entry *entry)
-{
-	struct list_head *head = hash(entry->mdb, &entry->key);
-	list_add(&entry->hash, head);
-}
-
-static inline void remove_hash(struct hfs_cat_entry *entry)
-{
-	list_del_init(&entry->hash);
-}
-
-/*
- * wait_on_entry()
- *
- * Sleep until a locked entry is unlocked.
- */
-static inline void wait_on_entry(struct hfs_cat_entry * entry)
-{
-	while ((entry->state & HFS_LOCK)) {
-		hfs_sleep_on(&entry->wait);
-	}
-}
+#include "hfs_fs.h"
+#include "btree.h"
 
 /*
- * lock_entry()
- *
- * Obtain an exclusive lock on an entry.
- */
-static void lock_entry(struct hfs_cat_entry * entry)
-{
-	wait_on_entry(entry);
-	spin_lock(&entry_lock);
-	entry->state |= HFS_LOCK;
-	spin_unlock(&entry_lock);
-}
-
-/*
- * lock_entry()
- *
- * Relinquish an exclusive lock on an entry.
- */
-static void unlock_entry(struct hfs_cat_entry * entry)
-{
-	spin_lock(&entry_lock);
-	entry->state &= ~HFS_LOCK;
-	spin_unlock(&entry_lock);
-	hfs_wake_up(&entry->wait);
-}
-
-/* put entry on mdb dirty list. */
-void hfs_cat_mark_dirty(struct hfs_cat_entry *entry)
-{
-        struct hfs_mdb *mdb = entry->mdb;
-
-	spin_lock(&entry_lock);
-	if (!(entry->state & HFS_DIRTY)) {
-	        entry->state |= HFS_DIRTY;
-
-		/* Only add valid (ie hashed) entries to the dirty list. */
-		if (!list_empty(&entry->hash)) {
-		        list_del(&entry->list);
-			list_add(&entry->list, &mdb->entry_dirty);
-		}
-	}
-	spin_unlock(&entry_lock);
-}
-
-/* delete an entry and remove it from the hash table. */
-static void delete_entry(struct hfs_cat_entry *entry)
-{
-        if (!(entry->state & HFS_DELETED)) {
-	        entry->state |= HFS_DELETED;
-		list_del_init(&entry->hash);
-
-	        if (entry->type == HFS_CDR_FIL) {
-		  /* free all extents */
-		  entry->u.file.data_fork.lsize = 0;
-		  hfs_extent_adj(&entry->u.file.data_fork);
-		  entry->u.file.rsrc_fork.lsize = 0;
-		  hfs_extent_adj(&entry->u.file.rsrc_fork);
-		}
-	}
-}
-
-
-static inline void init_entry(struct hfs_cat_entry *entry)
-{
-	memset(entry, 0, sizeof(*entry));
-	hfs_init_waitqueue(&entry->wait);
-	INIT_LIST_HEAD(&entry->hash);
-	INIT_LIST_HEAD(&entry->list);
-}
-
-/*
- * hfs_cat_alloc()
- *
- * Try to allocate another entry. 
- */
-static inline struct hfs_cat_entry *hfs_cat_alloc(void)
-{
-        struct hfs_cat_entry *entry;
-
-	if (!HFS_NEW(entry))
-	        return NULL;
-
-	init_entry(entry);
-	return entry;
-}
-
-/* this gets called with the spinlock held. */
-static int grow_entries(void)
-{
-        struct hfs_cat_entry *entry;
-	int i;
-	
-	for (i = 0; i < CCACHE_INC; i++) {
-	        if (!(entry = hfs_cat_alloc()))
-		        break;
-		list_add(&entry->list, &entry_unused);
-	}
-
-	entries_stat.nr_entries += i;
-	entries_stat.nr_free_entries += i;
-	        
-	return i;
-}
-
-/*
- * __read_entry()
+ * hfs_cat_build_key()
  *
- * Convert a (struct hfs_cat_rec) to a (struct hfs_cat_entry).
+ * Given the ID of the parent and the name build a search key.
  */
-static void __read_entry(struct hfs_cat_entry *entry,
-			 const struct hfs_cat_rec *cat)
+void hfs_cat_build_key(btree_key *key, u32 parent, struct qstr *name)
 {
-	entry->type = cat->cdrType;
-
-	if (cat->cdrType == HFS_CDR_DIR) {
-		struct hfs_dir *dir = &entry->u.dir;
-
-		entry->cnid = hfs_get_nl(cat->u.dir.DirID);
-
-		dir->magic = HFS_DIR_MAGIC;
-		dir->flags = hfs_get_ns(cat->u.dir.Flags);
-		memcpy(&entry->info.dir.dinfo, &cat->u.dir.UsrInfo, 16);
-		memcpy(&entry->info.dir.dxinfo, &cat->u.dir.FndrInfo, 16);
-		entry->create_date = hfs_get_nl(cat->u.dir.CrDat);
-		entry->modify_date = hfs_get_nl(cat->u.dir.MdDat);
-		entry->backup_date = hfs_get_nl(cat->u.dir.BkDat);
-		dir->dirs = dir->files = 0;
-		init_rwsem(&dir->sem);
-	} else if (cat->cdrType == HFS_CDR_FIL) {
-		struct hfs_file *fil = &entry->u.file;
-
-		entry->cnid = hfs_get_nl(cat->u.fil.FlNum);
-
-		fil->magic = HFS_FILE_MAGIC;
-
-		fil->data_fork.fork = HFS_FK_DATA;
-		fil->data_fork.entry = entry;
-		fil->data_fork.lsize = hfs_get_hl(cat->u.fil.LgLen);
-		fil->data_fork.psize = hfs_get_hl(cat->u.fil.PyLen) >>
-						     HFS_SECTOR_SIZE_BITS;
-		hfs_extent_in(&fil->data_fork, cat->u.fil.ExtRec);
-
-		fil->rsrc_fork.fork = HFS_FK_RSRC;
-		fil->rsrc_fork.entry = entry;
-		fil->rsrc_fork.lsize = hfs_get_hl(cat->u.fil.RLgLen);
-		fil->rsrc_fork.psize = hfs_get_hl(cat->u.fil.RPyLen) >>
-						     HFS_SECTOR_SIZE_BITS;
-		hfs_extent_in(&fil->rsrc_fork, cat->u.fil.RExtRec);
-
-		memcpy(&entry->info.file.finfo, &cat->u.fil.UsrWds, 16);
-		memcpy(&entry->info.file.fxinfo, &cat->u.fil.FndrInfo, 16);
-
-		entry->create_date = hfs_get_nl(cat->u.fil.CrDat);
-		entry->modify_date = hfs_get_nl(cat->u.fil.MdDat);
-		entry->backup_date = hfs_get_nl(cat->u.fil.BkDat);
-		fil->clumpablks = (hfs_get_hs(cat->u.fil.ClpSize)
-					/ entry->mdb->alloc_blksz)
-						>> HFS_SECTOR_SIZE_BITS;
-		fil->flags = cat->u.fil.Flags;
+	key->cat.reserved = 0;
+	key->cat.ParID = cpu_to_be32(parent);
+	if (name) {
+		hfs_triv2mac(&key->cat.CName, name);
+		key->key_len = 6 + key->cat.CName.len;
 	} else {
-		hfs_warn("hfs_fs: entry is neither file nor directory!\n");
-	}
-}
-
-/*
- * count_dir_entries()
- *
- * Count the number of files and directories in a given directory.
- */
-static inline void count_dir_entries(struct hfs_cat_entry *entry,
-				     struct hfs_brec *brec)
-{
-	int error = 0;
-	hfs_u32 cnid;
-	hfs_u8 type;
-
-	if (!hfs_cat_open(entry, brec)) {
-		while (!(error = hfs_cat_next(entry, brec, 1, &cnid, &type))) {
-			if (type == HFS_CDR_FIL) {
-				++entry->u.dir.files;
-			} else if (type == HFS_CDR_DIR) {
-				++entry->u.dir.dirs;
-			}
-		} /* -ENOENT is normal termination */
-	}
-	if (error != -ENOENT) {
-		entry->cnid = 0;
-	}
-}
-
-/*
- * read_entry()
- *
- * Convert a (struct hfs_brec) to a (struct hfs_cat_entry).
- */
-static inline void read_entry(struct hfs_cat_entry *entry,
-			      struct hfs_brec *brec)
-{
-	int need_count;
-	struct hfs_cat_rec *rec = brec->data;
-
-	__read_entry(entry, rec);
-
-	need_count = (rec->cdrType == HFS_CDR_DIR) && rec->u.dir.Val;
-
-	hfs_brec_relse(brec, NULL);
-
-	if (need_count) {
-		count_dir_entries(entry, brec);
+		memset(&key->cat.CName, 0, sizeof(struct hfs_name));
+		key->key_len = 6;
 	}
 }
 
-/*
- * __write_entry()
- *
- * Convert a (struct hfs_cat_entry) to a (struct hfs_cat_rec).
- */
-static void __write_entry(const struct hfs_cat_entry *entry,
-			  struct hfs_cat_rec *cat)
+int hfs_cat_build_record(hfs_cat_rec *rec, u32 cnid, struct inode *inode)
 {
-	if (entry->type == HFS_CDR_DIR) {
-		const struct hfs_dir *dir = &entry->u.dir;
+	u32 mtime = hfs_mtime();
 
-		hfs_put_ns(dir->flags,             cat->u.dir.Flags);
-		hfs_put_hs(dir->dirs + dir->files, cat->u.dir.Val);
-		hfs_put_nl(entry->cnid,            cat->u.dir.DirID);
-		hfs_put_nl(entry->create_date,     cat->u.dir.CrDat);
-		hfs_put_nl(entry->modify_date,     cat->u.dir.MdDat);
-		hfs_put_nl(entry->backup_date,     cat->u.dir.BkDat);
-		memcpy(&cat->u.dir.UsrInfo, &entry->info.dir.dinfo, 16);
-		memcpy(&cat->u.dir.FndrInfo, &entry->info.dir.dxinfo, 16);
-	} else if (entry->type == HFS_CDR_FIL) {
-		const struct hfs_file *fil = &entry->u.file;
-
-		cat->u.fil.Flags = fil->flags;
-		hfs_put_nl(entry->cnid,            cat->u.fil.FlNum);
-		memcpy(&cat->u.fil.UsrWds, &entry->info.file.finfo, 16);
-		hfs_put_hl(fil->data_fork.lsize, cat->u.fil.LgLen);
-		hfs_put_hl(fil->data_fork.psize << HFS_SECTOR_SIZE_BITS,
- 							cat->u.fil.PyLen);
-		hfs_put_hl(fil->rsrc_fork.lsize, cat->u.fil.RLgLen);
-		hfs_put_hl(fil->rsrc_fork.psize << HFS_SECTOR_SIZE_BITS,
- 							cat->u.fil.RPyLen);
-		hfs_put_nl(entry->create_date,     cat->u.fil.CrDat);
-		hfs_put_nl(entry->modify_date,     cat->u.fil.MdDat);
-		hfs_put_nl(entry->backup_date,     cat->u.fil.BkDat);
-		memcpy(&cat->u.fil.FndrInfo, &entry->info.file.fxinfo, 16);
-		hfs_put_hs((fil->clumpablks * entry->mdb->alloc_blksz)
-				<< HFS_SECTOR_SIZE_BITS, cat->u.fil.ClpSize);
-		hfs_extent_out(&fil->data_fork, cat->u.fil.ExtRec);
-		hfs_extent_out(&fil->rsrc_fork, cat->u.fil.RExtRec);
+	memset(rec, 0, sizeof(*rec));
+	if (S_ISDIR(inode->i_mode)) {
+		rec->type = HFS_CDR_DIR;
+		rec->dir.DirID = cpu_to_be32(cnid);
+		rec->dir.CrDat = mtime;
+		rec->dir.MdDat = mtime;
+		rec->dir.BkDat = 0;
+		rec->dir.UsrInfo.frView = cpu_to_be16(0xff);
+		return sizeof(struct hfs_cat_dir);
 	} else {
-		hfs_warn("__write_entry: invalid entry\n");
-	}
-}
-
-/*
- * write_entry()
- *
- * Write a modified entry back to the catalog B-tree. this gets called
- * with the entry locked.
- */
-static void write_entry(struct hfs_cat_entry * entry)
-{
-	struct hfs_brec brec;
-	int error;
-
-	if (!(entry->state & HFS_DELETED)) {
-		error = hfs_bfind(&brec, entry->mdb->cat_tree,
-				  HFS_BKEY(&entry->key), HFS_BFIND_WRITE);
-		if (!error) {
-			if ((entry->state & HFS_KEYDIRTY)) {
-				/* key may have changed case due to a rename */
-				entry->state &= ~HFS_KEYDIRTY;
-				if (brec.key->KeyLen != entry->key.KeyLen) {
-					hfs_warn("hfs_write_entry: key length "
-						 "changed!\n");
-					error = 1;
-				} else {
-					memcpy(brec.key, &entry->key,
-					       entry->key.KeyLen);
-				}
-			} else if (entry->cnid != brec_to_id(&brec)) {
-				hfs_warn("hfs_write_entry: CNID "
-					 "changed unexpectedly!\n");
-				error = 1;
-			}
-			if (!error) {
-				__write_entry(entry, brec.data);
-			}
-			hfs_brec_relse(&brec, NULL);
-		}
-		if (error) {
-			hfs_warn("hfs_write_entry: unable to write "
-				 "entry %08x\n", entry->cnid);
-		}
+		/* init some fields for the file record */
+		rec->type = HFS_CDR_FIL;
+		rec->file.Flags = HFS_FIL_USED | HFS_FIL_THD;
+		if (!(inode->i_mode & S_IWUSR))
+			rec->file.Flags |= HFS_FIL_LOCK;
+		rec->file.FlNum = cpu_to_be32(cnid);
+		rec->file.CrDat = mtime;
+		rec->file.MdDat = mtime;
+		rec->file.BkDat = 0;
+		rec->file.UsrWds.fdType = HFS_SB(inode->i_sb)->s_type;
+		rec->file.UsrWds.fdCreator = HFS_SB(inode->i_sb)->s_creator;
+		return sizeof(struct hfs_cat_file);
 	}
 }
 
-
-/* this gets called with the spinlock held. */
-static struct hfs_cat_entry *find_entry(struct hfs_mdb *mdb,
-					const struct hfs_cat_key *key)
-{
-	struct list_head *tmp, *head = hash(mdb, key);
-	struct hfs_cat_entry * entry;
-
-	tmp = head;
-	for (;;) {
-		tmp = tmp->next;
-		entry = NULL;
-		if (tmp == head)
-			break;
-		entry = list_entry(tmp, struct hfs_cat_entry, hash);
-		if (entry->mdb != mdb)
-			continue;
-		if (hfs_cat_compare(&entry->key, key)) {
-			continue;
-		}
-		entry->count++;
-		break;
-	}
-
-	return entry;
-}
-
-
-/* be careful. this gets called with the spinlock held. */
-static struct hfs_cat_entry *get_new_entry(struct hfs_mdb *mdb,
-					   const struct hfs_cat_key *key,
-					   const int read)
-{
-	struct hfs_cat_entry *entry;
-	struct list_head *head = hash(mdb, key);
-	struct list_head *tmp;
-
-add_new_entry:
-	tmp = entry_unused.next;
-	if ((tmp != &entry_unused) ) {
-		list_del(tmp);
-		entries_stat.nr_free_entries--;
-		entry = list_entry(tmp, struct hfs_cat_entry, list);
-		list_add(&entry->list, &entry_in_use);
-		list_add(&entry->hash, head);
-		entry->mdb = mdb;
-		entry->count = 1;
-		memcpy(&entry->key, key, sizeof(*key));
-		entry->state = HFS_LOCK;
-		spin_unlock(&entry_lock);
-
-		if (read) {
-		   struct hfs_brec brec;
-
-		   if (hfs_bfind(&brec, mdb->cat_tree,
-				 HFS_BKEY(key), HFS_BFIND_READ_EQ)) {
-		        /* uh oh. we failed to read the record.
-			 * the entry doesn't actually exist. */
-		        goto read_fail;
-		   }
-
-		   read_entry(entry, &brec);
-		   
-		   /* error */
-		   if (!entry->cnid) {
-		        goto read_fail;
-		   }
-
-		   /* we don't have to acquire a spinlock here or
-		    * below for the unlocking bits as we're the first
-		    * user of this entry. */
-		   entry->state &= ~HFS_LOCK;
-		   hfs_wake_up(&entry->wait);
-		}
-
-		return entry;
-	}
-
-
-	/* try to allocate more entries. grow_entries() doesn't release
-	 * the spinlock. */
-	if (grow_entries())
-	        goto add_new_entry;
-
-	spin_unlock(&entry_lock);
-	return NULL;
-
-read_fail: 
-	/* short-cut hfs_cat_put by doing everything here. */
-	spin_lock(&entry_lock);
-	list_del(&entry->hash);
-	list_del(&entry->list);
-	init_entry(entry);
-	list_add(&entry->list, &entry_unused);
-	entries_stat.nr_free_entries++;
-	spin_unlock(&entry_lock);
-	return NULL;
-}
-
-/*
- * get_entry()
- *
- * Try to return an entry for the indicated file or directory.
- * If ('read' == 0) then no attempt will be made to read it from disk
- * and a locked, but uninitialized, entry is returned.
- */
-static struct hfs_cat_entry *get_entry(struct hfs_mdb *mdb,
-				       const struct hfs_cat_key *key,
-				       const int read)
-{
-	struct hfs_cat_entry * entry;
-
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-	hfs_warn("hfs_get_entry: mdb=%p key=%s read=%d\n",
-		 mdb, key->CName.Name, read);
-#endif
-
-	spin_lock(&entry_lock);
-	entry = find_entry(mdb, key);
-	if (!entry) {
-	        return get_new_entry(mdb, key, read);
-	}
-	spin_unlock(&entry_lock);
-	wait_on_entry(entry);
-	return entry;
-}
-
-/* 
- * new_cnid()
- *
- * Allocate a CNID to use for a new file or directory.
- */
-static inline hfs_u32 new_cnid(struct hfs_mdb *mdb)
-{
-	/* If the create succeeds then the mdb will get dirtied */
-	return htonl(mdb->next_id++);
-}
-
-/*
- * update_dir()
- *
- * Update counts, times and dirt on a changed directory
- */
-static void update_dir(struct hfs_mdb *mdb, struct hfs_cat_entry *dir,
-		       int is_dir, int count)
-{
-	/* update counts */
-	if (is_dir) {
-		mdb->dir_count += count;
-		dir->u.dir.dirs += count;
-		if (dir->cnid == htonl(HFS_ROOT_CNID)) {
-			mdb->root_dirs += count;
-		}
-	} else {
-		mdb->file_count += count;
-		dir->u.dir.files += count;
-		if (dir->cnid == htonl(HFS_ROOT_CNID)) {
-			mdb->root_files += count;
-		}
-	}
-	
-	/* update times and dirt */
-	dir->modify_date = hfs_time();
-	hfs_cat_mark_dirty(dir);
+static int hfs_cat_build_thread(hfs_cat_rec *rec, int type,
+				u32 parentid, struct qstr *name)
+{
+	rec->type = type;
+	memset(rec->thread.reserved, 0, sizeof(rec->thread.reserved));
+	rec->thread.ParID = cpu_to_be32(parentid);
+	hfs_triv2mac(&rec->thread.CName, name);
+	return sizeof(struct hfs_cat_thread);
 }
 
 /*
@@ -644,301 +87,53 @@ static void update_dir(struct hfs_mdb *m
  * Add a new file or directory to the catalog B-tree and
  * return a (struct hfs_cat_entry) for it in '*result'.
  */
-static int create_entry(struct hfs_cat_entry *parent, struct hfs_cat_key *key,
-			const struct hfs_cat_rec *record, int is_dir,
-			hfs_u32 cnid, struct hfs_cat_entry **result)
+int hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)
 {
-	struct hfs_mdb *mdb = parent->mdb;
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_key thd_key;
-	struct hfs_cat_rec thd_rec;
-	int error, has_thread;
-
-	if (result) {
-		*result = NULL;
+	struct hfs_find_data fd;
+	struct super_block *sb;
+	union hfs_cat_rec entry;
+	int entry_size;
+	int err;
+
+	dprint(DBG_CAT_MOD, "create_cat: %s,%u(%d)\n", str->name, cnid, inode->i_nlink);
+	if (dir->i_size >= HFS_MAX_VALENCE)
+		return -ENOSPC;
+
+	sb = dir->i_sb;
+	hfs_find_init(HFS_SB(sb)->cat_tree, &fd);
+
+	hfs_cat_build_key(fd.search_key, cnid, NULL);
+	entry_size = hfs_cat_build_thread(&entry, S_ISDIR(inode->i_mode) ?
+			HFS_CDR_THD : HFS_CDR_FTH,
+			dir->i_ino, str);
+	err = hfs_brec_find(&fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&fd, &entry, entry_size);
+	if (err)
+		goto out;
+
+	hfs_cat_build_key(fd.search_key, dir->i_ino, str);
+	entry_size = hfs_cat_build_record(&entry, cnid, inode);
+	err = hfs_brec_find(&fd);
+	if (err != -ENOENT) {
+		/* panic? */
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&fd, &entry, entry_size);
+	if (!err) {
+		dir->i_size++;
+		mark_inode_dirty(dir);
 	}
+out:
+	hfs_find_exit(&fd);
 
-	/* keep readers from getting confused by changing dir size */
-	down_write(&parent->u.dir.sem);
-
-	/* create a locked entry in the cache */
-	entry = get_entry(mdb, key, 0);
-	if (!entry) {
-		/* The entry exists but can't be read */
-		error = -EIO;
-		goto done;
-	}
-
-	if (entry->cnid) {
-		/* The (unlocked) entry exists in the cache */
-		error = -EEXIST;
-		goto bail2;
-	}
-
-	/* limit directory valence to signed 16-bit integer */
-        if ((parent->u.dir.dirs + parent->u.dir.files) >= HFS_MAX_VALENCE) {
-		error = -ENOSPC;
-		goto bail1;
-	}
-
-	has_thread = is_dir || (record->u.fil.Flags & HFS_FIL_THD);
-
-	if (has_thread) {
-		/* init some fields for the thread record */
-		memset(&thd_rec, 0, sizeof(thd_rec));
-		thd_rec.cdrType = is_dir ? HFS_CDR_THD : HFS_CDR_FTH;
-		memcpy(&thd_rec.u.thd.ParID, &key->ParID,
-		       sizeof(hfs_u32) + sizeof(struct hfs_name));
-
-		/* insert the thread record */
-		hfs_cat_build_key(cnid, NULL, &thd_key);
-		error = hfs_binsert(mdb->cat_tree, HFS_BKEY(&thd_key),
-				    &thd_rec, 2 + sizeof(THD_REC));
-		if (error) {
-			goto bail1;
-		}
-	}
-
-	/* insert the record */
-	error = hfs_binsert(mdb->cat_tree, HFS_BKEY(key), record,
-				is_dir ?  2 + sizeof(DIR_REC) :
-					  2 + sizeof(FIL_REC));
-	if (error) {
-		if (has_thread && (error != -EIO)) {
-			/* at least TRY to remove the thread record */
-			(void)hfs_bdelete(mdb->cat_tree, HFS_BKEY(&thd_key));
-		}
-		goto bail1;
-	}
-
-	/* update the parent directory */
-	update_dir(mdb, parent, is_dir, 1);
-
-	/* complete the cache entry and return success */
-	__read_entry(entry, record);
-	unlock_entry(entry);
-
-	if (result) {
-		*result = entry;
-	} else {
-		hfs_cat_put(entry);
-	}
-	goto done;
-
-bail1:
-	/* entry really didn't exist, so we don't need to really delete it.
-	 * we do need to remove it from the hash, though. */
-	entry->state |= HFS_DELETED;
-	remove_hash(entry);
-	unlock_entry(entry);
-bail2:
-	hfs_cat_put(entry);
-done:
-	up_write(&parent->u.dir.sem);
-	return error;
-}
-
-/*================ Global functions ================*/
-
-/* 
- * hfs_cat_put()
- *
- * Release an entry we aren't using anymore.
- *
- * nothing in hfs_cat_put goes to sleep now except on the initial entry.  
- */
-void hfs_cat_put(struct hfs_cat_entry * entry)
-{
-	if (entry) {
-	        wait_on_entry(entry);
-
-		/* just in case. this should never happen. */
-		if (!entry->count) { 
-		  hfs_warn("hfs_cat_put: trying to free free entry: %p\n",
-			   entry);
-		  return;
-		}
-
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-		hfs_warn("hfs_cat_put: %p(%u) type=%d state=%lu\n", 
-			 entry, entry->count, entry->type, entry->state);
-#endif
-		spin_lock(&entry_lock);
-		if (!--entry->count) {
-			if ((entry->state & HFS_DELETED))
-			        goto entry_deleted;
-
-			if ((entry->type == HFS_CDR_FIL)) {
-		                /* clear out any cached extents */
-			        if (entry->u.file.data_fork.first.next) {
-				  hfs_extent_free(&entry->u.file.data_fork);
-				}
-				if (entry->u.file.rsrc_fork.first.next) {
-				  hfs_extent_free(&entry->u.file.rsrc_fork);
-				}
-			}
-
-			/* if we put a dirty entry, write it out. */
-			if ((entry->state & HFS_DIRTY)) {
-			        entry->state ^= HFS_DIRTY | HFS_LOCK;
-				write_entry(entry);
-				entry->state &= ~HFS_LOCK;
-			}
-
-			list_del(&entry->hash);
-entry_deleted: 		/* deleted entries have already been removed
-			 * from the hash list. */
-			list_del(&entry->list);
-			if (entries_stat.nr_free_entries > CCACHE_MAX) {
-			        HFS_DELETE(entry);
-				entries_stat.nr_entries--;
-			} else {
-				init_entry(entry);
-				list_add(&entry->list, &entry_unused);
-				entries_stat.nr_free_entries++;
-			}
-		}
-		spin_unlock(&entry_lock);
-	}
-}
-
-/* 
- * hfs_cat_get()
- *
- * Wrapper for get_entry() which always calls with ('read'==1).
- * Used for access to get_entry() from outside this file.
- */
-struct hfs_cat_entry *hfs_cat_get(struct hfs_mdb *mdb,
-				  const struct hfs_cat_key *key)
-{
-	return get_entry(mdb, key, 1);
-}
-
-/* invalidate all entries for a device */
-static void invalidate_list(struct list_head *head, struct hfs_mdb *mdb,
-			    struct list_head *dispose)
-{
-        struct list_head *next;
-
-	next = head->next;
-	for (;;) {
-	        struct list_head *tmp = next;
-		struct hfs_cat_entry * entry;
-		
-		next = next->next;
-		if (tmp == head)
-		        break;
-		entry = list_entry(tmp, struct hfs_cat_entry, list);
-		if (entry->mdb != mdb) {
-			continue;
-		}
-
-		if (!entry->count) {
-		        list_del_init(&entry->hash);
-			list_del(&entry->list);
-			list_add(&entry->list, dispose);
-			continue;
-		}
-		
-		hfs_warn("hfs_fs: entry %p(%u) busy on removed device %s.\n",
-			 entry, entry->count, 
-			 hfs_mdb_name(entry->mdb->sys_mdb));
-	}
-}
-
-/* delete entries from a list */
-static void delete_list(struct list_head *head) 
-{
-	struct list_head *next = head->next;
-	struct hfs_cat_entry *entry;
-	
-	for (;;) {
-		struct list_head * tmp = next;
-
-		next = next->next;
-		if (tmp == head) {
-			break;
-		}
-		entry = list_entry(tmp, struct hfs_cat_entry, list);
-		HFS_DELETE(entry);
-	}
-}
-
-/* 
- * hfs_cat_invalidate()
- *
- * Called by hfs_mdb_put() to remove all the entries
- * in the cache that are associated with a given MDB.
- */
-void hfs_cat_invalidate(struct hfs_mdb *mdb)
-{
-	LIST_HEAD(throw_away);
-
-	spin_lock(&entry_lock);
-	invalidate_list(&entry_in_use, mdb, &throw_away);
-	invalidate_list(&mdb->entry_dirty, mdb, &throw_away);
-	spin_unlock(&entry_lock);
-
-	delete_list(&throw_away);
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-	hfs_warn("hfs_cat_invalidate: free=%d total=%d\n",
-		 entries_stat.nr_free_entries,
-		 entries_stat.nr_entries);
-#endif
-}
-
-/*
- * hfs_cat_commit()
- *
- * Called by hfs_mdb_commit() to write dirty entries to the disk buffers.
- */
-void hfs_cat_commit(struct hfs_mdb *mdb)
-{
-        struct list_head *tmp, *head = &mdb->entry_dirty;
-	struct hfs_cat_entry *entry;
-
-	spin_lock(&entry_lock);
-	while ((tmp = head->prev) != head) {
-	        entry = list_entry(tmp, struct hfs_cat_entry, list);
-		  
-		if ((entry->state & HFS_LOCK)) {
-		        spin_unlock(&entry_lock);
-			wait_on_entry(entry);
-			spin_lock(&entry_lock);
-		} else {
-		       struct list_head *insert = &entry_in_use;
-
-		       if (!entry->count)
-			        insert = entry_in_use.prev;
-
-		       /* add to in_use list */
-		       list_del(&entry->list);
-		       list_add(&entry->list, insert);
-
-		       /* reset DIRTY, set LOCK */
-		       entry->state ^= HFS_DIRTY | HFS_LOCK;
-		       spin_unlock(&entry_lock);
-		       write_entry(entry);
-		       spin_lock(&entry_lock);
-		       entry->state &= ~HFS_LOCK;
-		       hfs_wake_up(&entry->wait);
-		}
-	}
-	spin_unlock(&entry_lock);
-}
-
-/*
- * hfs_cat_free()
- *
- * Releases all the memory allocated in grow_entries().
- * Must call hfs_cat_invalidate() on all MDBs before calling this.
- * This only gets rid of the unused pool of entries. all the other
- * entry references should have either been freed by cat_invalidate
- * or moved onto the unused list.
- */
-void hfs_cat_free(void)
-{
-	delete_list(&entry_unused);
+	return err;
 }
 
 /*
@@ -962,223 +157,43 @@ void hfs_cat_free(void)
  * Postconditions:
  *   This function has no side-effects
  */
-int hfs_cat_compare(const struct hfs_cat_key *key1,
-		    const struct hfs_cat_key *key2)
+int hfs_cat_keycmp(const btree_key *key1, const btree_key *key2)
 {
-	unsigned int parents;
 	int retval;
 
-	parents = hfs_get_hl(key1->ParID) - hfs_get_hl(key2->ParID);
-	if (parents != 0) {
-		retval = (int)parents;
-	} else {
-		retval = hfs_strcmp(key1->CName.Name, key1->CName.Len,
-				    key2->CName.Name, key2->CName.Len);
-	}
-	return retval;
-}
-
-/*
- * hfs_cat_build_key()
- *
- * Given the ID of the parent and the name build a search key.
- */
-void hfs_cat_build_key(hfs_u32 parent, const struct hfs_name *cname,
-		       struct hfs_cat_key *key)
-{
-	hfs_put_nl(parent, key->ParID);
-
-	if (cname) {
-		key->KeyLen = 6 + cname->Len;
-		memcpy(&key->CName, cname, sizeof(*cname));
-	} else {
-		key->KeyLen = 6;
-		memset(&key->CName, 0, sizeof(*cname));
-	}
-}
+	retval = be32_to_cpu(key1->cat.ParID) - be32_to_cpu(key2->cat.ParID);
+	if (!retval)
+		retval = hfs_strcmp(key1->cat.CName.name, key1->cat.CName.len,
+				    key2->cat.CName.name, key2->cat.CName.len);
 
-/*
- * hfs_cat_open()
- *
- * Given a directory on an HFS filesystem get its thread and
- * lock the directory against insertions and deletions.
- * Return 0 on success or an error code on failure.
- */
-int hfs_cat_open(struct hfs_cat_entry *dir, struct hfs_brec *brec)
-{
-	struct hfs_cat_key key;
-	int error;
-
-	if (dir->type != HFS_CDR_DIR)
-		return -EINVAL;
-	
-	/* Block writers */
-	down_read(&dir->u.dir.sem);
-
-	/* Find the directory */
-	hfs_cat_build_key(dir->cnid, NULL, &key);
-	error = hfs_bfind(brec, dir->mdb->cat_tree,
-			  HFS_BKEY(&key), HFS_BFIND_READ_EQ);
-
-	if (error)
-		up_read(&dir->u.dir.sem);
-
-	return error;
-}
-
-/*
- * hfs_cat_next()
- *
- * Given a catalog brec structure, replace it with the count'th next brec
- * in the same directory.
- * Return an error code if there is a problem, 0 if OK.
- * Note that an error code of -ENOENT means there are no more entries
- * in this directory.
- * The directory is "closed" on an error.
- */
-int hfs_cat_next(struct hfs_cat_entry *dir, struct hfs_brec *brec,
-		 hfs_u16 count, hfs_u32 *cnid, hfs_u8 *type)
-{
-	int error;
-
-	if (!dir || !brec) {
-		return -EINVAL;
-	}
-
-	/* Get the count'th next catalog tree entry */
-	error = hfs_bsucc(brec, count);
-	if (!error) {
-		struct hfs_cat_key *key = (struct hfs_cat_key *)brec->key;
-		if (hfs_get_nl(key->ParID) != dir->cnid) {
-			hfs_brec_relse(brec, NULL);
-			error = -ENOENT;
-		}
-	}
-	if (!error) {
-		*type = ((struct hfs_cat_rec *)brec->data)->cdrType;
-		*cnid = brec_to_id(brec);
-	} else {
-		up_read(&dir->u.dir.sem);
-	}
-	return error;
-}
-
-/*
- * hfs_cat_close()
- *
- * Given a catalog brec structure, replace it with the count'th next brec
- * in the same directory.
- * Return an error code if there is a problem, 0 if OK.
- * Note that an error code of -ENOENT means there are no more entries
- * in this directory.
- */
-void hfs_cat_close(struct hfs_cat_entry *dir, struct hfs_brec *brec)
-{
-	if (dir && brec) {
-		hfs_brec_relse(brec, NULL);
-		up_read(&dir->u.dir.sem);
-	}
-}
-
-/*
- * hfs_cat_parent()
- *
- * Given a catalog entry, return the entry for its parent.
- * Uses catalog key for the entry to get its parent's ID
- * and then uses the parent's thread record to locate the
- * parent's actual catalog entry.
- */
-struct hfs_cat_entry *hfs_cat_parent(struct hfs_cat_entry *entry)
-{
-	struct hfs_cat_entry *retval = NULL;
-	struct hfs_mdb *mdb = entry->mdb;
-	struct hfs_brec brec;
-	struct hfs_cat_key key;
-	int error;
-
-	lock_entry(entry);
-	if (!(entry->state & HFS_DELETED)) {
-		hfs_cat_build_key(hfs_get_nl(entry->key.ParID), NULL, &key);
-		error = hfs_bfind(&brec, mdb->cat_tree,
-				  HFS_BKEY(&key), HFS_BFIND_READ_EQ);
-		if (!error) {
-			/* convert thread record to key */
-			struct hfs_cat_rec *rec = brec.data;
-			key.KeyLen = 6 + rec->u.thd.CName.Len;
-			memcpy(&key.ParID, &rec->u.thd.ParID,
-                       	       sizeof(hfs_u32) + sizeof(struct hfs_name));
-
-                	hfs_brec_relse(&brec, NULL);
-
-			retval = hfs_cat_get(mdb, &key);
-		}
-	}
-	unlock_entry(entry);
 	return retval;
 }
-	
-/*
- * hfs_cat_create()
- *
- * Create a new file with the indicated name in the indicated directory.
- * The file will have the indicated flags, type and creator.
- * If successful an (struct hfs_cat_entry) is returned in '*result'.
- */
-int hfs_cat_create(struct hfs_cat_entry *parent, struct hfs_cat_key *key,
-		   hfs_u8 flags, hfs_u32 type, hfs_u32 creator,
-		   struct hfs_cat_entry **result)
-{
-	struct hfs_cat_rec record;
-	hfs_u32 id = new_cnid(parent->mdb);
-	hfs_u32 mtime = hfs_time();
-
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-	hfs_warn("hfs_cat_create: %p/%s flags=%d res=%p\n",
-		 parent, key->CName.Name, flags, result);
-#endif
-	/* init some fields for the file record */
-	memset(&record, 0, sizeof(record));
-	record.cdrType = HFS_CDR_FIL;
-	record.u.fil.Flags = flags | HFS_FIL_USED;
-	hfs_put_nl(id,      record.u.fil.FlNum);
-	hfs_put_nl(mtime,   record.u.fil.CrDat);
-	hfs_put_nl(mtime,   record.u.fil.MdDat);
-	hfs_put_nl(0,       record.u.fil.BkDat);
-	hfs_put_nl(type,    record.u.fil.UsrWds.fdType);
-	hfs_put_nl(creator, record.u.fil.UsrWds.fdCreator);
 
-	return create_entry(parent, key, &record, 0, id, result);
+/* Try to get a catalog entry for given catalog id */
+// move to read_super???
+int hfs_cat_find_brec(struct super_block *sb, u32 cnid,
+		      struct hfs_find_data *fd)
+{
+	hfs_cat_rec rec;
+	int res, len, type;
+
+	hfs_cat_build_key(fd->search_key, cnid, NULL);
+	res = hfs_brec_read(fd, &rec, sizeof(rec));
+	if (res)
+		return res;
+
+	type = rec.type;
+	if (type != HFS_CDR_THD && type != HFS_CDR_FTH) {
+		printk("HFS-fs: Found bad thread record in catalog\n");
+		return -EIO;
+	}
+
+	fd->search_key->cat.ParID = rec.thread.ParID;
+	len = fd->search_key->cat.CName.len = rec.thread.CName.len;
+	memcpy(fd->search_key->cat.CName.name, rec.thread.CName.name, len);
+	return hfs_brec_find(fd);
 }
 
-/*
- * hfs_cat_mkdir()
- *
- * Create a new directory with the indicated name in the indicated directory.
- * If successful an (struct hfs_cat_entry) is returned in '*result'.
- */
-int hfs_cat_mkdir(struct hfs_cat_entry *parent, struct hfs_cat_key *key,
-		  struct hfs_cat_entry **result)
-{
-	struct hfs_cat_rec record;
-	hfs_u32 id = new_cnid(parent->mdb);
-	hfs_u32 mtime = hfs_time();
-
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-	hfs_warn("hfs_cat_mkdir: %p/%s res=%p\n", parent, key->CName.Name,
-		 result);
-#endif
-
-	/* init some fields for the directory record */
-	memset(&record, 0, sizeof(record));
-	record.cdrType = HFS_CDR_DIR;
-	hfs_put_nl(id,     record.u.dir.DirID);
-	hfs_put_nl(mtime, record.u.dir.CrDat);
-	hfs_put_nl(mtime, record.u.dir.MdDat);
-	hfs_put_nl(0,     record.u.dir.BkDat);
-	hfs_put_hs(0xff,  record.u.dir.UsrInfo.frView);
-
-	return create_entry(parent, key, &record, 1, id, result);
-}
 
 /*
  * hfs_cat_delete()
@@ -1186,72 +201,60 @@ int hfs_cat_mkdir(struct hfs_cat_entry *
  * Delete the indicated file or directory.
  * The associated thread is also removed unless ('with_thread'==0).
  */
-int hfs_cat_delete(struct hfs_cat_entry *parent, struct hfs_cat_entry *entry,
-		   int with_thread)
+int hfs_cat_delete(u32 cnid, struct inode *dir, struct qstr *str)
 {
-	struct hfs_cat_key key;
-	struct hfs_mdb *mdb = parent->mdb;
-	int is_dir, error = 0;
-
-#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
-	hfs_warn("hfs_cat_delete: %p/%p type=%d state=%lu, thread=%d\n",
-		 parent, entry, entry->type, entry->state, with_thread);
+	struct super_block *sb;
+	struct hfs_find_data fd;
+	struct list_head *pos;
+	int res, type;
+
+	dprint(DBG_CAT_MOD, "delete_cat: %s,%u\n", str ? str->name : NULL, cnid);
+	sb = dir->i_sb;
+	hfs_find_init(HFS_SB(sb)->cat_tree, &fd);
+
+	hfs_cat_build_key(fd.search_key, dir->i_ino, str);
+	res = hfs_brec_find(&fd);
+	if (res)
+		goto out;
+
+	type = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);
+	if (type == HFS_CDR_FIL) {
+		struct hfs_cat_file file;
+		hfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));
+		if (be32_to_cpu(file.FlNum) == cnid) {
+#if 0
+			hfs_free_fork(sb, &file, HFS_FK_DATA);
 #endif
-	if (parent->mdb != entry->mdb) {
-		return -EINVAL;
-	}
-
-	if (entry->type == HFS_CDR_FIL) {
-		with_thread = (entry->u.file.flags&HFS_FIL_THD) && with_thread;
-		is_dir = 0;
-	} else {
-		is_dir = 1;
-	}
-
-	/* keep readers from getting confused by changing dir size */
-	down_write(&parent->u.dir.sem);
-
-	/* don't delete a busy directory */
-	if (entry->type == HFS_CDR_DIR) {
-		down_read(&entry->u.dir.sem);
-
-		error = -ENOTEMPTY;
-		if (entry->u.dir.files || entry->u.dir.dirs) 
-			goto hfs_delete_end;
+			hfs_free_fork(sb, &file, HFS_FK_RSRC);
+		}
 	}
 
-	/* try to delete the file or directory */
-	lock_entry(entry);
-	error = -ENOENT;
-	if ((entry->state & HFS_DELETED)) {
-		/* somebody beat us to it. */
-		goto hfs_delete_unlock;
-	}
-		
-	/* delete the catalog record */
-	if ((error = hfs_bdelete(mdb->cat_tree, HFS_BKEY(&entry->key)))) {
-		goto hfs_delete_unlock;
+	list_for_each(pos, &HFS_I(dir)->open_dir_list) {
+		struct hfs_readdir_data *rd =
+			list_entry(pos, struct hfs_readdir_data, list);
+		if (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)
+			rd->file->f_pos--;
 	}
 
-	/* Mark the entry deleted and remove it from the cache */
-	delete_entry(entry);
+	res = hfs_brec_remove(&fd);
+	if (res)
+		goto out;
 
-	/* try to delete the thread entry if it exists */
-	if (with_thread) {
-		hfs_cat_build_key(entry->cnid, NULL, &key);
-		(void)hfs_bdelete(mdb->cat_tree, HFS_BKEY(&key));
+	hfs_cat_build_key(fd.search_key, cnid, NULL);
+	res = hfs_brec_find(&fd);
+	if (!res) {
+		res = hfs_brec_remove(&fd);
+		if (res)
+			goto out;
 	}
-	
-	update_dir(mdb, parent, is_dir, -1);
 
-hfs_delete_unlock:
-	unlock_entry(entry);
+	dir->i_size--;
+	mark_inode_dirty(dir);
+	res = 0;
+out:
+	hfs_find_exit(&fd);
 
-hfs_delete_end:
-	if (entry->type == HFS_CDR_DIR)
-		up_read(&entry->u.dir.sem);
-	up_write(&parent->u.dir.sem);
-	return error;
+	return res;
 }
 
 /*
@@ -1261,267 +264,82 @@ hfs_delete_end:
  * If the destination exists it is removed and a
  * (struct hfs_cat_entry) for it is returned in '*result'.
  */
-int hfs_cat_move(struct hfs_cat_entry *old_dir, struct hfs_cat_entry *new_dir,
-		 struct hfs_cat_entry *entry, struct hfs_cat_key *new_key,
-		 struct hfs_cat_entry **removed)
-{
-	struct hfs_cat_entry *dest;
-	struct hfs_mdb *mdb;
-	int error = 0;
-	int is_dir, has_thread;
-
-	if (removed) {
-		*removed = NULL;
-	}
-
-	/* sanity checks */
-	if (!old_dir || !new_dir) {
-		return -EINVAL;
-	}
-	mdb = old_dir->mdb;
-	if (mdb != new_dir->mdb) {
-		return -EXDEV;
-	}
-
-	/* precompute a few things */
-	if (entry->type == HFS_CDR_DIR) {
-		is_dir = 1;
-		has_thread = 1;
-	} else if (entry->type == HFS_CDR_FIL) {
-		is_dir = 0;
-		has_thread = entry->u.file.flags & HFS_FIL_THD;
-	} else {
-		return -EINVAL;
-	}
-
-	/* keep readers from getting confused by changing dir size */
-	down_write(&new_dir->u.dir.sem);
-	/* AV: smells like a deadlock */
-	if (old_dir != new_dir)
-		down_write(&old_dir->u.dir.sem);
-
-	/* Don't move a directory inside itself */
-	if (is_dir) {
-		struct hfs_cat_key thd_key;
-		struct hfs_brec brec;
-
-		hfs_u32 id = new_dir->cnid;
-		while (id != htonl(HFS_ROOT_CNID)) {
-			if (id == entry->cnid) {
-				error = -EINVAL;
-			} else {
-				hfs_cat_build_key(id, NULL, &thd_key);
-				error = hfs_bfind(&brec, mdb->cat_tree,
-						  HFS_BKEY(&thd_key),
-						  HFS_BFIND_READ_EQ);
-			}
-			if (error) {
-				goto done;
-			} else {
-				struct hfs_cat_rec *rec = brec.data;
-				id = hfs_get_nl(rec->u.thd.ParID);
-				hfs_brec_relse(&brec, NULL);
-			}
-		}
-	}
-
-restart:
-	/* see if the destination exists, getting it if it does */
-	dest = hfs_cat_get(mdb, new_key);
-	if (!dest) {
-		/* destination doesn't exist, so create it */
-		struct hfs_cat_rec new_record;
-
-		/* create a locked entry in the cache */
-		dest = get_entry(mdb, new_key, 0);
-		if (!dest) {
-			error = -EIO;
-			goto done;
-		}
-		if (dest->cnid) {
-			/* The (unlocked) entry exists in the cache */
-			goto have_distinct;
-		}
-
-		/* limit directory valence to signed 16-bit integer */
-        	if ((new_dir->u.dir.dirs + new_dir->u.dir.files) >=
-							HFS_MAX_VALENCE) {
-			error = -ENOSPC;
-			goto bail3;
-		}
-
-		/* build the new record. make sure to zero out the
-                   record. */
-		memset(&new_record, 0, sizeof(new_record));
-		new_record.cdrType = entry->type;
-		__write_entry(entry, &new_record);
-
-		/* insert the new record */
-		error = hfs_binsert(mdb->cat_tree, HFS_BKEY(new_key),
-				    &new_record, is_dir ? 2 + sizeof(DIR_REC) :
-				    2 + sizeof(FIL_REC));
-		if (error == -EEXIST) {
-			delete_entry(dest);
-			unlock_entry(dest);
-			hfs_cat_put(dest);
-			goto restart;
-		} else if (error) {
-			goto bail3;
-		}
-
-		/* update the destination directory */
-		update_dir(mdb, new_dir, is_dir, 1);
-	} else if (entry != dest) {
-have_distinct:
-		/* The destination exists and is not same as source */
-		lock_entry(dest);
-		if ((dest->state & HFS_DELETED)) {
-		        unlock_entry(dest);
-			hfs_cat_put(dest);
-			goto restart;
-		}
-		if (dest->type != entry->type) {
-			/* can't move a file on top
-			   of a dir nor vice versa. */
-			error = is_dir ? -ENOTDIR : -EISDIR;
-		} else if (is_dir && (dest->u.dir.dirs || dest->u.dir.files)) {
-			/* directory to replace is not empty */
-			error = -ENOTEMPTY;
-		}
-
-		if (error) {
-			goto bail2;
-		}
-	} else {
-		/* The destination exists but is same as source */
-	        --entry->count;
-		dest = NULL;
-	}
-
-	/* lock the entry */
-	lock_entry(entry);
-	if ((entry->state & HFS_DELETED)) {
-		error = -ENOENT;
-		goto bail1;
-	}
-
-	if (dest) {
-		/* remove the old entry */
-		error = hfs_bdelete(mdb->cat_tree, HFS_BKEY(&entry->key));
-
-		if (error) {
-			/* We couldn't remove the entry for the
-			   original file, so nothing has changed. */
-			goto bail1;
-		}
-		update_dir(mdb, old_dir, is_dir, -1);
-	}
-
-	/* update the thread of the dir/file we're moving */
-	if (has_thread) {
-		struct hfs_cat_key thd_key;
-		struct hfs_brec brec;
-
-		hfs_cat_build_key(entry->cnid, NULL, &thd_key);
-		error = hfs_bfind(&brec, mdb->cat_tree,
-				  HFS_BKEY(&thd_key), HFS_BFIND_WRITE);
-		if (error == -ENOENT) {
-			if (is_dir) {
-				/* directory w/o a thread! */
-				error = -EIO;
-			} else {
-				/* We were lied to! */
-				entry->u.file.flags &= ~HFS_FIL_THD;
-				hfs_cat_mark_dirty(entry);
-			}
-		}
-		if (!error) {
-			struct hfs_cat_rec *rec = brec.data;
-			memcpy(&rec->u.thd.ParID, &new_key->ParID,
-			       sizeof(hfs_u32) + sizeof(struct hfs_name));
-			hfs_brec_relse(&brec, NULL);
-		} else if (error == -ENOENT) {
-			error = 0;
-		} else if (!dest) {
-			/* Nothing was changed */
-			unlock_entry(entry);
-			goto done;
-		} else {
-			/* Something went seriously wrong.
-			   The dir/file has been deleted. */
-			/* XXX try some recovery? */
-			delete_entry(entry);
-			goto bail1;
-		}
-	}
-
-	/* TRY to remove the thread for the pre-existing entry */
-	if (dest && dest->cnid &&
-	    (is_dir || (dest->u.file.flags & HFS_FIL_THD))) {
-		struct hfs_cat_key thd_key;
-
-		hfs_cat_build_key(dest->cnid, NULL, &thd_key);
-		(void)hfs_bdelete(mdb->cat_tree, HFS_BKEY(&thd_key));
-	}
-
-	/* update directories */
-	new_dir->modify_date = hfs_time();
-	hfs_cat_mark_dirty(new_dir);
-
-	/* update key */
-	remove_hash(entry);
-	memcpy(&entry->key, new_key, sizeof(*new_key));
-	/* KEYDIRTY as case might differ */
-	entry->state |= HFS_KEYDIRTY;
-	insert_hash(entry);
-	hfs_cat_mark_dirty(entry);
-	unlock_entry(entry);
-
-	/* delete any pre-existing or place-holder entry */
-	if (dest) {
-		delete_entry(dest);
-		unlock_entry(dest);
-		if (removed && dest->cnid) {
-			*removed = dest;
-		} else {
-			hfs_cat_put(dest);
-		}
-	}
-	goto done;
-
-bail1:
-	unlock_entry(entry);
-bail2:
-	if (dest) {
-		if (!dest->cnid) {
-			/* TRY to remove the new entry */
-			(void)hfs_bdelete(mdb->cat_tree, HFS_BKEY(new_key));
-			update_dir(mdb, new_dir, is_dir, -1);
-bail3:
-			delete_entry(dest);
-		}
-		unlock_entry(dest);
-		hfs_cat_put(dest);
-	}
-done:
-	if (new_dir != old_dir)
-		up_write(&old_dir->u.dir.sem);
-	up_write(&new_dir->u.dir.sem);
-	return error;
-}
-
-/*
- * Initialize the hash tables
- */
-void hfs_cat_init(void)
+int hfs_cat_move(u32 cnid, struct inode *src_dir, struct qstr *src_name,
+		 struct inode *dst_dir, struct qstr *dst_name)
 {
-	int i;
-	struct list_head *head = hash_table;
-
-        i = C_HASHSIZE;
-        do {
-                INIT_LIST_HEAD(head);
-                head++;
-                i--;
-        } while (i);
+	struct super_block *sb;
+	struct hfs_find_data src_fd, dst_fd;
+	union hfs_cat_rec entry;
+	int entry_size, type;
+	int err;
+
+	dprint(DBG_CAT_MOD, "rename_cat: %u - %lu,%s - %lu,%s\n", cnid, src_dir->i_ino, src_name->name,
+		dst_dir->i_ino, dst_name->name);
+	sb = src_dir->i_sb;
+	hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);
+	dst_fd = src_fd;
+
+	/* find the old dir entry and read the data */
+	hfs_cat_build_key(src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+
+	hfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,
+			    src_fd.entrylength);
+
+	/* create new dir entry with the data from the old entry */
+	hfs_cat_build_key(dst_fd.search_key, dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(&dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+
+	err = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);
+	if (err)
+		goto out;
+	dst_dir->i_size++;
+	mark_inode_dirty(dst_dir);
+
+	/* finally remove the old entry */
+	hfs_cat_build_key(src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+	err = hfs_brec_remove(&src_fd);
+	if (err)
+		goto out;
+	src_dir->i_size--;
+	mark_inode_dirty(src_dir);
+
+	type = entry.type;
+	if (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))
+		goto out;
+
+	/* remove old thread entry */
+	hfs_cat_build_key(src_fd.search_key, cnid, NULL);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+	err = hfs_brec_remove(&src_fd);
+	if (err)
+		goto out;
+
+	/* create new thread entry */
+	hfs_cat_build_key(dst_fd.search_key, cnid, NULL);
+	entry_size = hfs_cat_build_thread(&entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,
+					dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(&dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&dst_fd, &entry, entry_size);
+out:
+	hfs_bnode_put(dst_fd.bnode);
+	hfs_find_exit(&src_fd);
+	return err;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/dir.c linuxppc-2.5-benh/fs/hfs/dir.c
--- /dev/shm/linux-2.5/fs/hfs/dir.c	2003-06-30 06:49:04.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/dir.c	2003-12-24 03:48:17.000000000 +0000
@@ -16,145 +16,180 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/*================ File-local functions ================*/
+#include "hfs_fs.h"
+#include "btree.h"
 
 /*
- * build_key()
- *
- * Build a key for a file by the given name in the given directory.
- * If the name matches one of the reserved names returns 1 otherwise 0.
+ * hfs_lookup()
  */
-static int build_key(struct hfs_cat_key *key, struct inode *dir,
-		     const char *name, int len)
+struct dentry *hfs_lookup(struct inode *dir, struct dentry *dentry
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
 {
-	struct hfs_name cname;
-	const struct hfs_name *reserved;
-
-	/* mangle the name */
-	hfs_nameout(dir, &cname, name, len);
-
-	/* check against reserved names */
-	reserved = HFS_SB(dir->i_sb)->s_reserved1;
-	while (reserved->Len) {
-		if (hfs_streq(reserved->Name, reserved->Len, 
-			      cname.Name, cname.Len)) {
-			return 1;
+	hfs_cat_rec rec;
+	struct hfs_find_data fd;
+	struct inode *inode = NULL;
+	int res;
+
+	dentry->d_op = &hfs_dentry_operations;
+
+	hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);
+	hfs_cat_build_key(fd.search_key, dir->i_ino, &dentry->d_name);
+	res = hfs_brec_read(&fd, &rec, sizeof(rec));
+	if (res) {
+		hfs_find_exit(&fd);
+		if (res == -ENOENT) {
+			/* No such entry */
+			inode = NULL;
+			goto done;
 		}
-		++reserved;
+		return ERR_PTR(res);
 	}
-
-	/* check against the names reserved only in the root directory */
-	if (HFS_I(dir)->entry->cnid == htonl(HFS_ROOT_CNID)) {
-		reserved = HFS_SB(dir->i_sb)->s_reserved2;
-		while (reserved->Len) {
-			if (hfs_streq(reserved->Name, reserved->Len,
-				      cname.Name, cname.Len)) {
-				return 1;
-			}
-			++reserved;
-		}
-	}
-
-	/* build the key */
-	hfs_cat_build_key(HFS_I(dir)->entry->cnid, &cname, key);
-
-	return 0;
+	inode = hfs_iget(dir->i_sb, &fd.search_key->cat, &rec);
+	hfs_find_exit(&fd);
+	if (!inode)
+		return ERR_PTR(-EACCES);
+done:
+	d_add(dentry, inode);
+	return NULL;
 }
 
 /*
- * update_dirs_plus()
- *
- * Update the fields 'i_size', 'i_nlink', 'i_ctime' and 'i_mtime'
- * of the inodes associated with a directory that has
- * had a file ('is_dir'==0) or directory ('is_dir'!=0) added to it.
+ * hfs_readdir
  */
-static inline void update_dirs_plus(struct hfs_cat_entry *dir, int is_dir)
+int hfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	int i;
-
-	for (i = 0; i < 4; ++i) {
-		struct dentry *de = dir->sys_entry[i];
-		if (de) {
-		        struct inode *tmp = de->d_inode;
-			if (S_ISDIR(tmp->i_mode)) {
-				if (is_dir &&
-				    (i == HFS_ITYPE_TO_INT(HFS_ITYPE_NORM))) {
-					/* In "normal" directory only */
-					++(tmp->i_nlink);
-				}
-				tmp->i_size += HFS_I(tmp)->dir_size;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	int len, err;
+	char strbuf[HFS_NAMELEN + 1];
+	union hfs_cat_rec entry;
+	struct hfs_find_data fd;
+	struct hfs_readdir_data *rd;
+	u16 type;
+
+	if (filp->f_pos >= inode->i_size)
+		return 0;
+
+	hfs_find_init(HFS_SB(sb)->cat_tree, &fd);
+	hfs_cat_build_key(fd.search_key, inode->i_ino, NULL);
+	err = hfs_brec_find(&fd);
+	if (err)
+		goto out;
+
+	switch ((u32)filp->f_pos) {
+	case 0:
+		/* This is completely artificial... */
+		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	case 1:
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		if (entry.type != HFS_CDR_THD) {
+			printk("HFS+-fs: bad catalog folder thread\n");
+			err = -EIO;
+			goto out;
+		}
+		//if (fd.entrylength < HFS_MIN_THREAD_SZ) {
+		//	printk("HFS+-fs: truncated catalog thread\n");
+		//	err = -EIO;
+		//	goto out;
+		//}
+		if (filldir(dirent, "..", 2, 1,
+			    be32_to_cpu(entry.thread.ParID), DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	default:
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&fd, filp->f_pos - 1);
+		if (err)
+			goto out;
+	}
+
+	for (;;) {
+		if (be32_to_cpu(fd.key->cat.ParID) != inode->i_ino) {
+			printk("HFS+-fs: walked past end of dir\n");
+			err = -EIO;
+			goto out;
+		}
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		type = entry.type;
+		len = hfs_mac2triv(strbuf, &fd.key->cat.CName);
+		if (type == HFS_CDR_DIR) {
+			if (fd.entrylength < sizeof(struct hfs_cat_dir)) {
+				printk("HFS+-fs: small dir entry\n");
+				err = -EIO;
+				goto out;
 			}
-			tmp->i_ctime = tmp->i_mtime = CURRENT_TIME;
-			mark_inode_dirty(tmp);
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.dir.DirID), DT_DIR))
+				break;
+		} else if (type == HFS_CDR_FIL) {
+			if (fd.entrylength < sizeof(struct hfs_cat_file)) {
+				printk("HFS+-fs: small file entry\n");
+				err = -EIO;
+				goto out;
+			}
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.file.FlNum), DT_REG))
+				break;
+		} else {
+			printk("HFS: bad catalog entry type %d\n", type);
+			err = -EIO;
+			goto out;
 		}
-	}
+		filp->f_pos++;
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&fd, 1);
+		if (err)
+			goto out;
+	}
+	rd = filp->private_data;
+	if (!rd) {
+		rd = kmalloc(sizeof(struct hfs_readdir_data), GFP_KERNEL);
+		if (!rd) {
+			err = -ENOMEM;
+			goto out;
+		}
+		filp->private_data = rd;
+		rd->file = filp;
+		list_add(&rd->list, &HFS_I(inode)->open_dir_list);
+	}
+	memcpy(&rd->key, &fd.key, sizeof(struct hfs_cat_key));
+out:
+	hfs_find_exit(&fd);
+	return err;
 }
 
-/*
- * update_dirs_minus()
- *
- * Update the fields 'i_size', 'i_nlink', 'i_ctime', 'i_mtime' and
- * of the inodes associated with a directory that has
- * had a file ('is_dir'==0) or directory ('is_dir'!=0) removed.
- */
-static inline void update_dirs_minus(struct hfs_cat_entry *dir, int is_dir)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static loff_t hfs_seek_dir(struct file *file, loff_t offset, int origin)
 {
-	int i;
+	loff_t res;
 
-	for (i = 0; i < 4; ++i) {
-		struct dentry *de = dir->sys_entry[i];
-		if (de) {
-		        struct inode *tmp = de->d_inode;
-			if (S_ISDIR(tmp->i_mode)) {
-				if (is_dir &&
-				    (i == HFS_ITYPE_TO_INT(HFS_ITYPE_NORM))) {
-					/* In "normal" directory only */
-					--(tmp->i_nlink);
-				}
-				tmp->i_size -= HFS_I(tmp)->dir_size;
-			}
-			tmp->i_ctime = tmp->i_mtime = CURRENT_TIME;
-			mark_inode_dirty(tmp);
-		}
-	}
+	down(&file->f_dentry->d_inode->i_sem);
+	res = default_llseek(file, offset, origin);
+	up(&file->f_dentry->d_inode->i_sem);
+
+	return res;
 }
+#endif
 
-/*
- * mark_inodes_deleted()
- *
- * Update inodes associated with a deleted entry to reflect its deletion.
- * Well, we really just drop the dentry.
- *
- * XXX: we should be using delete_inode for some of this stuff.
- */
-static inline void mark_inodes_deleted(struct hfs_cat_entry *entry, 
-				       struct dentry *dentry)
+static int hfs_dir_release(struct inode *inode, struct file *file)
 {
-	struct dentry *de;
-	struct inode *tmp;
-	int i;
-
-	for (i = 0; i < 4; ++i) {
-		if ((de = entry->sys_entry[i]) && (dentry != de)) {
-		      dget(de);
-		      tmp = de->d_inode;
-		      tmp->i_nlink = 0;
-		      tmp->i_ctime = CURRENT_TIME;
-		      mark_inode_dirty(tmp);
-		      d_delete(de);
-		      dput(de);
-		}
+	struct hfs_readdir_data *rd = file->private_data;
+	if (rd) {
+		list_del(&rd->list);
+		kfree(rd);
 	}
+	return 0;
 }
 
-/*================ Global functions ================*/
-
 /*
  * hfs_create()
  *
@@ -163,47 +198,28 @@ static inline void mark_inodes_deleted(s
  * a directory and return a corresponding inode, given the inode for
  * the directory and the name (and its length) of the new file.
  */
-int hfs_create(struct inode * dir, struct dentry *dentry, int mode, struct nameidata *nd)
+int hfs_create(struct inode *dir, struct dentry *dentry, int mode
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
 {
-	struct hfs_cat_entry *entry = HFS_I(dir)->entry;
-	struct hfs_cat_entry *new;
-	struct hfs_cat_key key;
 	struct inode *inode;
-	int error;
+	int res;
 
-	lock_kernel();
-	/* build the key, checking against reserved names */
-	if (build_key(&key, dir, dentry->d_name.name, dentry->d_name.len)) {
-		unlock_kernel();
-		return -EEXIST;
+	inode = hfs_new_inode(dir, &dentry->d_name, mode);
+	if (!inode)
+		return -ENOSPC;
+
+	res = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		hfs_delete_inode(inode);
+		iput(inode);
+		return res;
 	}
-
-	if ((error = hfs_cat_create(entry, &key, 
-			       (mode & S_IWUSR) ? 0 : HFS_FIL_LOCK,
-			       HFS_SB(dir->i_sb)->s_type,
-			       HFS_SB(dir->i_sb)->s_creator, &new))) {
-		unlock_kernel();
-		return error;
-	}
-
-	/* create an inode for the new file. back out if we run
-	 * into trouble. */
-	new->count++; /* hfs_iget() eats one */
-	if (!(inode = hfs_iget(new, HFS_I(dir)->file_type, dentry))) {
-		hfs_cat_delete(entry, new, 1);
-		hfs_cat_put(new);
-		unlock_kernel();
-		return -EIO;
-	}
-
-	hfs_cat_put(new);
-	update_dirs_plus(entry, 0);
-	/* toss any relevant negative dentries */
-	if (HFS_I(dir)->d_drop_op)
-		HFS_I(dir)->d_drop_op(dentry, HFS_I(dir)->file_type);
-	mark_inode_dirty(inode);
-	unlock_kernel();
 	d_instantiate(dentry, inode);
+	mark_inode_dirty(inode);
 	return 0;
 }
 
@@ -215,43 +231,24 @@ int hfs_create(struct inode * dir, struc
  * in a directory, given the inode for the parent directory and the
  * name (and its length) of the new directory.
  */
-int hfs_mkdir(struct inode * parent, struct dentry *dentry, int mode)
+int hfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_entry *new;
-	struct hfs_cat_key key;
 	struct inode *inode;
-	int error;
-
-	lock_kernel();
-	entry = HFS_I(parent)->entry;
-	/* build the key, checking against reserved names */
-	if (build_key(&key, parent, dentry->d_name.name, 
-		      dentry->d_name.len)) {
-		unlock_kernel();
-		return -EEXIST;
-	}
-
-	/* try to create the directory */
-	if ((error = hfs_cat_mkdir(entry, &key, &new))) {
-		unlock_kernel();
-		return error;
-	}
+	int res;
 
-	/* back out if we run into trouble */
-	new->count++; /* hfs_iget eats one */
-	if (!(inode = hfs_iget(new, HFS_I(parent)->file_type, dentry))) {
-		hfs_cat_delete(entry, new, 1);
-		hfs_cat_put(new);
-		unlock_kernel();
-		return -EIO;
+	inode = hfs_new_inode(dir, &dentry->d_name, S_IFDIR | mode);
+	if (!inode)
+		return -ENOSPC;
+
+	res = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		hfs_delete_inode(inode);
+		iput(inode);
+		return res;
 	}
-
-	hfs_cat_put(new);
-	update_dirs_plus(entry, 1);
-	mark_inode_dirty(inode);
 	d_instantiate(dentry, inode);
-	unlock_kernel();
+	mark_inode_dirty(inode);
 	return 0;
 }
 
@@ -263,44 +260,22 @@ int hfs_mkdir(struct inode * parent, str
  * file, given the inode for the parent directory and the name
  * (and its length) of the existing file.
  */
-int hfs_unlink(struct inode * dir, struct dentry *dentry)
+int hfs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct hfs_cat_entry *entry = HFS_I(dir)->entry;
-	struct hfs_cat_entry *victim = NULL;
-	struct hfs_cat_key key;
-	int error;
-
-	lock_kernel();
-	entry = HFS_I(dir)->entry;
-	if (build_key(&key, dir, dentry->d_name.name,
-		      dentry->d_name.len)) {
-		unlock_kernel();
-		return -EPERM;
-	}
+	struct inode *inode;
+	int res;
 
-	if (!(victim = hfs_cat_get(entry->mdb, &key))) {
-		unlock_kernel();
-		return -ENOENT;
-	}
+	inode = dentry->d_inode;
+	res = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);
+	if (res)
+		return res;
 
-	error = -EPERM;
-	if (victim->type != HFS_CDR_FIL)
-		goto hfs_unlink_put;
-
-	if (!(error = hfs_cat_delete(entry, victim, 1))) {
-		struct inode *inode = dentry->d_inode;
-
-		mark_inodes_deleted(victim, dentry);
-		inode->i_nlink--; 
-		inode->i_ctime = CURRENT_TIME;
-		mark_inode_dirty(inode);
-		update_dirs_minus(entry, 0);
-	}
+	inode->i_nlink--;
+	hfs_delete_inode(inode);
+	inode->i_ctime = CURRENT_TIME;
+	mark_inode_dirty(inode);
 
-hfs_unlink_put:
-	hfs_cat_put(victim);	/* Note that hfs_cat_put(NULL) is safe. */
-	unlock_kernel();
-	return error;
+	return res;
 }
 
 /*
@@ -311,55 +286,22 @@ hfs_unlink_put:
  * directory, given the inode for the parent directory and the name
  * (and its length) of the existing directory.
  */
-int hfs_rmdir(struct inode * parent, struct dentry *dentry)
+int hfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_entry *victim = NULL;
-	struct inode *inode = dentry->d_inode;
-	struct hfs_cat_key key;
-	int error;
-
-	lock_kernel();
-	entry = HFS_I(parent)->entry;
-	if (build_key(&key, parent, dentry->d_name.name,
-		      dentry->d_name.len)) {
-		unlock_kernel();
-		return -EPERM;
-	}
-
-	if (!(victim = hfs_cat_get(entry->mdb, &key))) {
-		unlock_kernel();
-		return -ENOENT;
-	}
-
-	error = -ENOTDIR;
-	if (victim->type != HFS_CDR_DIR) 
-		goto hfs_rmdir_put;
-
-	error = -EBUSY;
-	if (!d_unhashed(dentry))
-		goto hfs_rmdir_put;
-
-	/* we only have to worry about 2 and 3 for mount points */
-	if (victim->sys_entry[2] && d_mountpoint(victim->sys_entry[2]))
-		goto hfs_rmdir_put;
-	if (victim->sys_entry[3] && d_mountpoint(victim->sys_entry[3])) 
-		goto hfs_rmdir_put;
-
-	
-	if ((error = hfs_cat_delete(entry, victim, 1)))
-		goto hfs_rmdir_put;
+	struct inode *inode;
+	int res;
 
-	mark_inodes_deleted(victim, dentry);
+	inode = dentry->d_inode;
+	if (inode->i_size != 2)
+		return -ENOTEMPTY;
+	res = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);
+	if (res)
+		return res;
 	inode->i_nlink = 0;
 	inode->i_ctime = CURRENT_TIME;
+	hfs_delete_inode(inode);
 	mark_inode_dirty(inode);
-	update_dirs_minus(entry, 1);
-	 
-hfs_rmdir_put:
-	hfs_cat_put(victim);	/* Note that hfs_cat_put(NULL) is safe. */
-	unlock_kernel();
-	return error;
+	return 0;
 }
 
 /*
@@ -376,55 +318,38 @@ hfs_rmdir_put:
 int hfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	       struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct hfs_cat_entry *old_parent;
-	struct hfs_cat_entry *new_parent;
-	struct hfs_cat_entry *victim = NULL;
-	struct hfs_cat_entry *deleted;
-	struct hfs_cat_key key;
-	int error;
-
-	lock_kernel();
-	old_parent = HFS_I(old_dir)->entry;
-	new_parent = HFS_I(new_dir)->entry;
-	if (build_key(&key, old_dir, old_dentry->d_name.name,
-		      old_dentry->d_name.len) ||
-	    (HFS_ITYPE(old_dir->i_ino) != HFS_ITYPE(new_dir->i_ino))) {
-		unlock_kernel();
-		return -EPERM;
-	}
-
-	if (!(victim = hfs_cat_get(old_parent->mdb, &key))) {
-		unlock_kernel();
-		return -ENOENT;
-	}
+	int res;
 
-	error = -EPERM;
-	if (build_key(&key, new_dir, new_dentry->d_name.name,
-			     new_dentry->d_name.len)) 
-		goto hfs_rename_put;
-
-	if (!(error = hfs_cat_move(old_parent, new_parent,
-				   victim, &key, &deleted))) {
-		int is_dir = (victim->type == HFS_CDR_DIR);
-		
-		/* drop the old dentries */
-		mark_inodes_deleted(victim, old_dentry);
-		update_dirs_minus(old_parent, is_dir);
-		if (deleted) {
-			mark_inodes_deleted(deleted, new_dentry);
-			hfs_cat_put(deleted);
-		} else {
-			/* no existing inodes. just drop negative dentries */
-			if (HFS_I(new_dir)->d_drop_op) 
-				HFS_I(new_dir)->d_drop_op(new_dentry, 
-					  HFS_I(new_dir)->file_type);
-			update_dirs_plus(new_parent, is_dir);
-		}
-	
+	/* Unlink destination if it already exists */
+	if (new_dentry->d_inode) {
+		res = hfs_unlink(new_dir, new_dentry);
+		if (res)
+			return res;
 	}
 
-hfs_rename_put:
-	hfs_cat_put(victim);	/* Note that hfs_cat_put(NULL) is safe. */
-	unlock_kernel();
-	return error;
+	res = hfs_cat_move(old_dentry->d_inode->i_ino,
+			   old_dir, &old_dentry->d_name,
+			   new_dir, &new_dentry->d_name);
+	return res;
 }
+
+struct file_operations hfs_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= hfs_readdir,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	.llseek		= hfs_seek_dir,
+#else
+	.llseek		= generic_file_llseek,
+#endif
+	.release	= hfs_dir_release,
+};
+
+struct inode_operations hfs_dir_inode_operations = {
+	.create		= hfs_create,
+	.lookup		= hfs_lookup,
+	.unlink		= hfs_unlink,
+	.mkdir		= hfs_mkdir,
+	.rmdir		= hfs_rmdir,
+	.rename		= hfs_rename,
+	.setattr	= hfs_inode_setattr,
+};
diff -purN /dev/shm/linux-2.5/fs/hfs/dir_cap.c linuxppc-2.5-benh/fs/hfs/dir_cap.c
--- /dev/shm/linux-2.5/fs/hfs/dir_cap.c	2003-07-03 13:36:44.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/dir_cap.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,335 +0,0 @@
-/*
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the inode_operations and file_operations
- * structures for HFS directories under the CAP scheme.
- *
- * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds
- *
- * The source code distribution of the Columbia AppleTalk Package for
- * UNIX, version 6.0, (CAP) was used as a specification of the
- * location and format of files used by CAP's Aufs.  No code from CAP
- * appears in hfs_fs.  hfs_fs is not a work ``derived'' from CAP in
- * the sense of intellectual property law.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/*================ Forward declarations ================*/
-
-static struct dentry *cap_lookup(struct inode *, struct dentry *, struct nameidata *);
-static int cap_readdir(struct file *, void *, filldir_t);
-
-/*================ Global variables ================*/
-
-#define DOT_LEN			1
-#define DOT_DOT_LEN		2
-#define DOT_RESOURCE_LEN	9
-#define DOT_FINDERINFO_LEN	11
-#define DOT_ROOTINFO_LEN	9
-
-const struct hfs_name hfs_cap_reserved1[] = {
-	{DOT_LEN,		"."},
-	{DOT_DOT_LEN,		".."},
-	{DOT_RESOURCE_LEN,	".resource"},
-	{DOT_FINDERINFO_LEN,	".finderinfo"},
-	{0,			""},
-};
-
-const struct hfs_name hfs_cap_reserved2[] = {
-	{DOT_ROOTINFO_LEN,	".rootinfo"},
-	{0,			""},
-};
-
-#define DOT		(&hfs_cap_reserved1[0])
-#define DOT_DOT		(&hfs_cap_reserved1[1])
-#define DOT_RESOURCE	(&hfs_cap_reserved1[2])
-#define DOT_FINDERINFO	(&hfs_cap_reserved1[3])
-#define DOT_ROOTINFO	(&hfs_cap_reserved2[0])
-
-struct file_operations hfs_cap_dir_operations = {
-	.read		= generic_read_dir,
-	.readdir	= cap_readdir,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_cap_ndir_inode_operations = {
-	.create		= hfs_create,
-	.lookup		= cap_lookup,
-	.unlink		= hfs_unlink,
-	.mkdir		= hfs_mkdir,
-	.rmdir		= hfs_rmdir,
-	.rename		= hfs_rename,
-	.setattr	= hfs_notify_change,
-};
-
-struct inode_operations hfs_cap_fdir_inode_operations = {
-	.lookup		= cap_lookup,
-	.setattr	= hfs_notify_change,
-};
-
-struct inode_operations hfs_cap_rdir_inode_operations = {
-	.create		= hfs_create,
-	.lookup		= cap_lookup,
-	.setattr	= hfs_notify_change,
-};
-
-/*================ File-local functions ================*/
-
-/*
- * cap_lookup()
- *
- * This is the lookup() entry in the inode_operations structure for
- * HFS directories in the CAP scheme.  The purpose is to generate the
- * inode corresponding to an entry in a directory, given the inode for
- * the directory and the name (and its length) of the entry.
- */
-static struct dentry *cap_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
-{
-	ino_t dtype;
-	struct hfs_name cname;
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_key key;
-	struct inode *inode = NULL;
-
-	lock_kernel();
-
-	dentry->d_op = &hfs_dentry_operations;
-	entry = HFS_I(dir)->entry;
-	dtype = HFS_ITYPE(dir->i_ino);
-
-	/* Perform name-mangling */
-	hfs_nameout(dir, &cname, dentry->d_name.name, 
-		    dentry->d_name.len);
-
-	/* no need to check for "."  or ".." */
-
-	/* Check for epecial directories if in a normal directory.
-	   Note that cap_dupdir() does an iput(dir). */
-	if (dtype==HFS_CAP_NDIR) {
-		/* Check for ".resource", ".finderinfo" and ".rootinfo" */
-		if (hfs_streq(cname.Name, cname.Len, 
-			      DOT_RESOURCE->Name, DOT_RESOURCE_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_CAP_RDIR, dentry);
-			goto done;
-		} else if (hfs_streq(cname.Name, cname.Len, 
-				     DOT_FINDERINFO->Name, 
-				     DOT_FINDERINFO_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_CAP_FDIR, dentry);
-			goto done;
-		} else if ((entry->cnid == htonl(HFS_ROOT_CNID)) &&
-			   hfs_streq(cname.Name, cname.Len, 
-				     DOT_ROOTINFO->Name, DOT_ROOTINFO_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_CAP_FNDR, dentry);
-			goto done;
-		}
-	}
-
-	/* Do an hfs_iget() on the mangled name. */
-	hfs_cat_build_key(entry->cnid, &cname, &key);
-	inode = hfs_iget(hfs_cat_get(entry->mdb, &key),
-			 HFS_I(dir)->file_type, dentry);
-
-	/* Don't return a resource fork for a directory */
-	if (inode && (dtype == HFS_CAP_RDIR) && 
-	    (HFS_I(inode)->entry->type == HFS_CDR_DIR)) {
-	        iput(inode); /* this does an hfs_cat_put */
-		inode = NULL;
-	}
-
-done:
-	unlock_kernel();
-	d_add(dentry, inode);
-	return NULL;
-}
-
-/*
- * cap_readdir()
- *
- * This is the readdir() entry in the file_operations structure for
- * HFS directories in the CAP scheme.  The purpose is to enumerate the
- * entries in a directory, given the inode of the directory and a
- * (struct file *), the 'f_pos' field of which indicates the location
- * in the directory.  The (struct file *) is updated so that the next
- * call with the same 'dir' and 'filp' arguments will produce the next
- * directory entry.  The entries are returned in 'dirent', which is
- * "filled-in" by calling filldir().  This allows the same readdir()
- * function be used for different dirent formats.  We try to read in
- * as many entries as we can before filldir() refuses to take any more.
- *
- * XXX: In the future it may be a good idea to consider not generating
- * metadata files for covered directories since the data doesn't
- * correspond to the mounted directory.	 However this requires an
- * iget() for every directory which could be considered an excessive
- * amount of overhead.	Since the inode for a mount point is always
- * in-core this is another argument for a call to get an inode if it
- * is in-core or NULL if it is not.
- */
-static int cap_readdir(struct file * filp,
-		       void * dirent, filldir_t filldir)
-{
-	ino_t type;
-	int skip_dirs;
-	struct hfs_brec brec;
-        struct hfs_cat_entry *entry;
-	struct inode *dir = filp->f_dentry->d_inode;
-
-	lock_kernel();
-
-	entry = HFS_I(dir)->entry;
-	type = HFS_ITYPE(dir->i_ino);
-	skip_dirs = (type == HFS_CAP_RDIR);
-
-	if (filp->f_pos == 0) {
-		/* Entry 0 is for "." */
-		if (filldir(dirent, DOT->Name, DOT_LEN, 0, dir->i_ino, DT_DIR)) {
-			goto out;
-		}
-		filp->f_pos = 1;
-	}
-
-	if (filp->f_pos == 1) {
-		/* Entry 1 is for ".." */
-		hfs_u32 cnid;
-
-		if (type == HFS_CAP_NDIR) {
-			cnid = hfs_get_nl(entry->key.ParID);
-		} else {
-			cnid = entry->cnid;
-		}
-
-		if (filldir(dirent, DOT_DOT->Name,
-			    DOT_DOT_LEN, 1, ntohl(cnid), DT_DIR)) {
-			goto out;
-		}
-		filp->f_pos = 2;
-	}
-
-	if (filp->f_pos < (dir->i_size - 3)) {
-		hfs_u32 cnid;
-		hfs_u8 type;
-
-	    	if (hfs_cat_open(entry, &brec) ||
-	    	    hfs_cat_next(entry, &brec, filp->f_pos - 2, &cnid, &type)) {
-			goto out;
-		}
-		while (filp->f_pos < (dir->i_size - 3)) {
-			if (hfs_cat_next(entry, &brec, 1, &cnid, &type)) {
-				goto out;
-			}
-			if (!skip_dirs || (type != HFS_CDR_DIR)) {
-				ino_t ino;
-				unsigned int len;
-				unsigned char tmp_name[HFS_NAMEMAX];
-
-				ino = ntohl(cnid) | HFS_I(dir)->file_type;
-				len = hfs_namein(dir, tmp_name,
-				    &((struct hfs_cat_key *)brec.key)->CName);
-				if (filldir(dirent, tmp_name, len,
-					    filp->f_pos, ino, DT_UNKNOWN)) {
-					hfs_cat_close(entry, &brec);
-					goto out;
-				}
-			}
-			++filp->f_pos;
-		}
-		hfs_cat_close(entry, &brec);
-	}
-
-	if (filp->f_pos == (dir->i_size - 3)) {
-		if ((entry->cnid == htonl(HFS_ROOT_CNID)) &&
-		    (type == HFS_CAP_NDIR)) {
-			/* In root dir last-2 entry is for ".rootinfo" */
-			if (filldir(dirent, DOT_ROOTINFO->Name,
-				    DOT_ROOTINFO_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_CAP_FNDR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-	if (filp->f_pos == (dir->i_size - 2)) {
-		if (type == HFS_CAP_NDIR) {
-			/* In normal dirs last-1 entry is for ".finderinfo" */
-			if (filldir(dirent, DOT_FINDERINFO->Name,
-				    DOT_FINDERINFO_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_CAP_FDIR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-	if (filp->f_pos == (dir->i_size - 1)) {
-		if (type == HFS_CAP_NDIR) {
-			/* In normal dirs last entry is for ".resource" */
-			if (filldir(dirent, DOT_RESOURCE->Name,
-				    DOT_RESOURCE_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_CAP_RDIR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-out:
-	unlock_kernel();
-	return 0;
-}
-
-
-/* due to the dcache caching negative dentries for non-existent files,
- * we need to drop those entries when a file silently gets created.
- * as far as i can tell, the calls that need to do this are the file
- * related calls (create, rename, and mknod). the directory calls
- * should be immune. the relevant calls in dir.c call drop_dentry 
- * upon successful completion. */
-void hfs_cap_drop_dentry(struct dentry *dentry, const ino_t type)
-{
-  if (type == HFS_CAP_DATA) { /* given name */
-    hfs_drop_special(dentry->d_parent, DOT_FINDERINFO, dentry);
-    hfs_drop_special(dentry->d_parent, DOT_RESOURCE, dentry);
-  } else {
-    struct dentry *de;
-
-    /* given {.resource,.finderinfo}/name, look for name */
-    if ((de = hfs_lookup_dentry(dentry->d_parent->d_parent,
-				dentry->d_name.name, dentry->d_name.len))) {
-      if (!de->d_inode)
-	d_drop(de);
-      dput(de);
-    }
-    
-    switch (type) {
-    case HFS_CAP_RSRC: /* given .resource/name */
-       /* look for .finderinfo/name */
-      hfs_drop_special(dentry->d_parent->d_parent, DOT_FINDERINFO, 
-		       dentry);
-      break;
-    case HFS_CAP_FNDR: /* given .finderinfo/name. i don't this 
-			* happens. */
-      /* look for .resource/name */
-      hfs_drop_special(dentry->d_parent->d_parent, DOT_RESOURCE, 
-		       dentry);
-      break;
-    }
-  }
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/dir_dbl.c linuxppc-2.5-benh/fs/hfs/dir_dbl.c
--- /dev/shm/linux-2.5/fs/hfs/dir_dbl.c	2003-06-30 06:49:04.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/dir_dbl.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,421 +0,0 @@
-/*
- * linux/fs/hfs/dir_dbl.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the inode_operations and file_operations
- * structures for HFS directories.
- *
- * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/*================ Forward declarations ================*/
-
-static struct dentry *dbl_lookup(struct inode *, struct dentry *, struct nameidata *);
-static int dbl_readdir(struct file *, void *, filldir_t);
-static int dbl_create(struct inode *, struct dentry *, int, struct nameidata *);
-static int dbl_mkdir(struct inode *, struct dentry *, int);
-static int dbl_unlink(struct inode *, struct dentry *);
-static int dbl_rmdir(struct inode *, struct dentry *);
-static int dbl_rename(struct inode *, struct dentry *,
-		      struct inode *, struct dentry *);
-
-/*================ Global variables ================*/
-
-#define DOT_LEN			1
-#define DOT_DOT_LEN		2
-#define ROOTINFO_LEN		8
-#define PCNT_ROOTINFO_LEN	9
-
-const struct hfs_name hfs_dbl_reserved1[] = {
-	{DOT_LEN,		"."},
-	{DOT_DOT_LEN,		".."},
-	{0,			""},
-};
-
-const struct hfs_name hfs_dbl_reserved2[] = {
-	{ROOTINFO_LEN,		"RootInfo"},
-	{PCNT_ROOTINFO_LEN,	"%RootInfo"},
-	{0,			""},
-};
-
-#define DOT		(&hfs_dbl_reserved1[0])
-#define DOT_DOT		(&hfs_dbl_reserved1[1])
-#define ROOTINFO	(&hfs_dbl_reserved2[0])
-#define PCNT_ROOTINFO	(&hfs_dbl_reserved2[1])
-
-struct file_operations hfs_dbl_dir_operations = {
-	.read		= generic_read_dir,
-	.readdir	= dbl_readdir,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_dbl_dir_inode_operations = {
-	.create		= dbl_create,
-	.lookup		= dbl_lookup,
-	.unlink		= dbl_unlink,
-	.mkdir		= dbl_mkdir,
-	.rmdir		= dbl_rmdir,
-	.rename		= dbl_rename,
-	.setattr	= hfs_notify_change,
-};
-
-
-/*================ File-local functions ================*/
-
-/*
- * is_hdr()
- */
-static int is_hdr(struct inode *dir, const char *name, int len)
-{
-	int retval = 0;
-
-	if (name[0] == '%') {
-		struct hfs_cat_entry *entry = HFS_I(dir)->entry;
-		struct hfs_cat_entry *victim;
-		struct hfs_name cname;
-		struct hfs_cat_key key;
-
-		hfs_nameout(dir, &cname, name+1, len-1);
-		hfs_cat_build_key(entry->cnid, &cname, &key);
-		if ((victim = hfs_cat_get(entry->mdb, &key))) {
-			hfs_cat_put(victim);
-			retval = 1;
-		}
-	}
-	return retval;
-}
-
-/*
- * dbl_lookup()
- *
- * This is the lookup() entry in the inode_operations structure for
- * HFS directories in the AppleDouble scheme.  The purpose is to
- * generate the inode corresponding to an entry in a directory, given
- * the inode for the directory and the name (and its length) of the
- * entry.
- */
-static struct dentry *dbl_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
-{
-	struct hfs_name cname;
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_key key;
-	struct inode *inode = NULL;
-
-	lock_kernel();
-	dentry->d_op = &hfs_dentry_operations;
-	entry = HFS_I(dir)->entry;
-	
-	/* Perform name-mangling */
-	hfs_nameout(dir, &cname, dentry->d_name.name, dentry->d_name.len);
- 
-	/* no need to check for "."  or ".." */
-
-	/* Check for "%RootInfo" if in the root directory. */
-	if ((entry->cnid == htonl(HFS_ROOT_CNID)) &&
-	    hfs_streq(cname.Name, cname.Len, 
-		      PCNT_ROOTINFO->Name, PCNT_ROOTINFO_LEN)) {
-		++entry->count; /* __hfs_iget() eats one */
-		inode = hfs_iget(entry, HFS_DBL_HDR, dentry);
-		goto done;
-	}
-
-	/* Do an hfs_iget() on the mangled name. */
-	hfs_cat_build_key(entry->cnid, &cname, &key);
-	inode = hfs_iget(hfs_cat_get(entry->mdb, &key), HFS_DBL_NORM, dentry);
-
-	/* Try as a header if not found and first character is '%' */
-	if (!inode && (dentry->d_name.name[0] == '%')) {
-		hfs_nameout(dir, &cname, dentry->d_name.name+1,
-			    dentry->d_name.len-1);
-		hfs_cat_build_key(entry->cnid, &cname, &key);
-		inode = hfs_iget(hfs_cat_get(entry->mdb, &key),
-				 HFS_DBL_HDR, dentry);
-	}
-	
-done:
-	unlock_kernel();
-	d_add(dentry, inode);
-	return NULL;
-}
-
-/*
- * dbl_readdir()
- *
- * This is the readdir() entry in the file_operations structure for
- * HFS directories in the AppleDouble scheme.  The purpose is to
- * enumerate the entries in a directory, given the inode of the
- * directory and a (struct file *), the 'f_pos' field of which
- * indicates the location in the directory.  The (struct file *) is
- * updated so that the next call with the same 'dir' and 'filp'
- * arguments will produce the next directory entry.  The entries are
- * returned in 'dirent', which is "filled-in" by calling filldir().
- * This allows the same readdir() function be used for different
- * formats.  We try to read in as many entries as we can before
- * filldir() refuses to take any more.
- *
- * XXX: In the future it may be a good idea to consider not generating
- * metadata files for covered directories since the data doesn't
- * correspond to the mounted directory.	 However this requires an
- * iget() for every directory which could be considered an excessive
- * amount of overhead.	Since the inode for a mount point is always
- * in-core this is another argument for a call to get an inode if it
- * is in-core or NULL if it is not.
- */
-static int dbl_readdir(struct file * filp,
-		       void * dirent, filldir_t filldir)
-{
-	struct hfs_brec brec;
-        struct hfs_cat_entry *entry;
-	struct inode *dir = filp->f_dentry->d_inode;
-
-	lock_kernel();
-
-	entry = HFS_I(dir)->entry;
-
-	if (filp->f_pos == 0) {
-		/* Entry 0 is for "." */
-		if (filldir(dirent, DOT->Name, DOT_LEN, 0, dir->i_ino,
-			    DT_DIR)) {
-			goto out;
-		}
-		filp->f_pos = 1;
-	}
-
-	if (filp->f_pos == 1) {
-		/* Entry 1 is for ".." */
-		if (filldir(dirent, DOT_DOT->Name, DOT_DOT_LEN, 1,
-			    hfs_get_hl(entry->key.ParID), DT_DIR)) {
-			goto out;	
-		}
-		filp->f_pos = 2;
-	}
-
-	if (filp->f_pos < (dir->i_size - 1)) {
-                hfs_u32 cnid;
-                hfs_u8 type;
-
-		if (hfs_cat_open(entry, &brec) ||
-		    hfs_cat_next(entry, &brec, (filp->f_pos - 1) >> 1,
-				 &cnid, &type)) {
-			goto out;
-		}
-
-		while (filp->f_pos < (dir->i_size - 1)) {
-			unsigned char tmp_name[HFS_NAMEMAX + 1];
-			ino_t ino;
-			int is_hdr = (filp->f_pos & 1);
-			unsigned int len;
-
-			if (is_hdr) {
-				ino = ntohl(cnid) | HFS_DBL_HDR;
-				tmp_name[0] = '%';
-				len = 1 + hfs_namein(dir, tmp_name + 1,
-				    &((struct hfs_cat_key *)brec.key)->CName);
-			} else {
-				if (hfs_cat_next(entry, &brec, 1,
-							&cnid, &type)) {
-					goto out;
-				}
-				ino = ntohl(cnid);
-				len = hfs_namein(dir, tmp_name,
-				    &((struct hfs_cat_key *)brec.key)->CName);
-			}
-
-			if (filldir(dirent, tmp_name, len, filp->f_pos, ino,
-				    DT_UNKNOWN)) {
-				hfs_cat_close(entry, &brec);
-				goto out;
-			}
-			++filp->f_pos;
-		}
-		hfs_cat_close(entry, &brec);
-	}
-
-	if (filp->f_pos == (dir->i_size - 1)) {
-		if (entry->cnid == htonl(HFS_ROOT_CNID)) {
-			/* In root dir last entry is for "%RootInfo" */
-			if (filldir(dirent, PCNT_ROOTINFO->Name,
-				    PCNT_ROOTINFO_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_DBL_HDR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-out:
-	unlock_kernel();
-	return 0;
-}
-
-/*
- * dbl_create()
- *
- * This is the create() entry in the inode_operations structure for
- * AppleDouble directories.  The purpose is to create a new file in
- * a directory and return a corresponding inode, given the inode for
- * the directory and the name (and its length) of the new file.
- */
-static int dbl_create(struct inode * dir, struct dentry *dentry,
-		      int mode, struct nameidata *nd)
-{
-	int error;
-
-	lock_kernel();
-	if (is_hdr(dir, dentry->d_name.name, dentry->d_name.len)) {
-		error = -EEXIST;
-	} else {
-		error = hfs_create(dir, dentry, mode, nd);
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * dbl_mkdir()
- *
- * This is the mkdir() entry in the inode_operations structure for
- * AppleDouble directories.  The purpose is to create a new directory
- * in a directory, given the inode for the parent directory and the
- * name (and its length) of the new directory.
- */
-static int dbl_mkdir(struct inode * parent, struct dentry *dentry,
-		     int mode)
-{
-	int error;
-
-	lock_kernel();
-	if (is_hdr(parent, dentry->d_name.name, dentry->d_name.len)) {
-		error = -EEXIST;
-	} else {
-		error = hfs_mkdir(parent, dentry, mode);
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * dbl_unlink()
- *
- * This is the unlink() entry in the inode_operations structure for
- * AppleDouble directories.  The purpose is to delete an existing
- * file, given the inode for the parent directory and the name
- * (and its length) of the existing file.
- */
-static int dbl_unlink(struct inode * dir, struct dentry *dentry)
-{
-	int error;
-
-	lock_kernel();
-	error = hfs_unlink(dir, dentry);
-	if ((error == -ENOENT) && is_hdr(dir, dentry->d_name.name,
-					 dentry->d_name.len)) {
-		error = -EPERM;
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * dbl_rmdir()
- *
- * This is the rmdir() entry in the inode_operations structure for
- * AppleDouble directories.  The purpose is to delete an existing
- * directory, given the inode for the parent directory and the name
- * (and its length) of the existing directory.
- */
-static int dbl_rmdir(struct inode * parent, struct dentry *dentry)
-{
-	int error;
-
-	lock_kernel();
-	error = hfs_rmdir(parent, dentry);
-	if ((error == -ENOENT) && is_hdr(parent, dentry->d_name.name,
-					 dentry->d_name.len)) {
-		error = -ENOTDIR;
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * dbl_rename()
- *
- * This is the rename() entry in the inode_operations structure for
- * AppleDouble directories.  The purpose is to rename an existing
- * file or directory, given the inode for the current directory and
- * the name (and its length) of the existing file/directory and the
- * inode for the new directory and the name (and its length) of the
- * new file/directory.
- * 
- * XXX: how do we handle must_be_dir?
- */
-static int dbl_rename(struct inode *old_dir, struct dentry *old_dentry,
-		      struct inode *new_dir, struct dentry *new_dentry)
-{
-	int error;
-
-	lock_kernel();
-	if (is_hdr(new_dir, new_dentry->d_name.name,
-		   new_dentry->d_name.len)) {
-		error = -EPERM;
-	} else {
-		error = hfs_rename(old_dir, old_dentry,
-				   new_dir, new_dentry);
-		if ((error == -ENOENT) /*&& !must_be_dir*/ &&
-		    is_hdr(old_dir, old_dentry->d_name.name,
-			   old_dentry->d_name.len)) {
-			error = -EPERM;
-		}
-	}
-	unlock_kernel();
-	return error;
-}
-
-
-/* due to the dcache caching negative dentries for non-existent files,
- * we need to drop those entries when a file silently gets created.
- * as far as i can tell, the calls that need to do this are the file
- * related calls (create, rename, and mknod). the directory calls
- * should be immune. the relevant calls in dir.c call drop_dentry 
- * upon successful completion. */
-void hfs_dbl_drop_dentry(struct dentry *dentry, const ino_t type)
-{
-  unsigned char tmp_name[HFS_NAMEMAX + 1];
-  struct dentry *de = NULL;
-
-  switch (type) {
-  case HFS_DBL_HDR:
-   /* given %name, look for name. i don't think this happens. */
-   de = hfs_lookup_dentry(dentry->d_parent,
-			  dentry->d_name.name + 1, dentry->d_name.len - 1);
-    break;
-  case HFS_DBL_DATA:
-    /* given name, look for %name */
-    tmp_name[0] = '%';
-    strncpy(tmp_name + 1, dentry->d_name.name, HFS_NAMELEN - 1);
-    de = hfs_lookup_dentry(dentry->d_parent, 
-			   tmp_name, dentry->d_name.len + 1);
-  }
-
-  if (de) {
-    if (!de->d_inode)
-      d_drop(de);
-    dput(de);
-  }
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/dir_nat.c linuxppc-2.5-benh/fs/hfs/dir_nat.c
--- /dev/shm/linux-2.5/fs/hfs/dir_nat.c	2003-07-03 13:36:44.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/dir_nat.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,467 +0,0 @@
-/*
- * linux/fs/hfs/dir_nat.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the inode_operations and file_operations
- * structures for HFS directories.
- *
- * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds
- *
- * The source code distributions of Netatalk, versions 1.3.3b2 and
- * 1.4b2, were used as a specification of the location and format of
- * files used by Netatalk's afpd.  No code from Netatalk appears in
- * hfs_fs.  hfs_fs is not a work ``derived'' from Netatalk in the
- * sense of intellectual property law.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/*================ Forward declarations ================*/
-
-static struct dentry *nat_lookup(struct inode *, struct dentry *, struct nameidata *);
-static int nat_readdir(struct file *, void *, filldir_t);
-static int nat_rmdir(struct inode *, struct dentry *);
-static int nat_hdr_unlink(struct inode *, struct dentry *);
-static int nat_hdr_rename(struct inode *, struct dentry *,
-			  struct inode *, struct dentry *);
-
-/*================ Global variables ================*/
-
-#define DOT_LEN			1
-#define DOT_DOT_LEN		2
-#define DOT_APPLEDOUBLE_LEN	12
-#define DOT_PARENT_LEN		7
-#define ROOTINFO_LEN            8
-
-const struct hfs_name hfs_nat_reserved1[] = {
-	{DOT_LEN,		"."},
-	{DOT_DOT_LEN,		".."},
-	{DOT_APPLEDOUBLE_LEN,	".AppleDouble"},
-	{DOT_PARENT_LEN,	".Parent"},
-	{0,			""},
-};
-
-const struct hfs_name hfs_nat_reserved2[] = {
-	{ROOTINFO_LEN,			"RootInfo"},
-};
-
-#define DOT		(&hfs_nat_reserved1[0])
-#define DOT_DOT		(&hfs_nat_reserved1[1])
-#define DOT_APPLEDOUBLE	(&hfs_nat_reserved1[2])
-#define DOT_PARENT	(&hfs_nat_reserved1[3])
-#define ROOTINFO        (&hfs_nat_reserved2[0])
-
-struct file_operations hfs_nat_dir_operations = {
-	.read		= generic_read_dir,
-	.readdir	= nat_readdir,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_nat_ndir_inode_operations = {
-	.create		= hfs_create,
-	.lookup		= nat_lookup,
-	.unlink		= hfs_unlink,
-	.mkdir		= hfs_mkdir,
-	.rmdir		= nat_rmdir,
-	.rename		= hfs_rename,
-	.setattr	= hfs_notify_change,
-};
-
-struct inode_operations hfs_nat_hdir_inode_operations = {
-	.create		= hfs_create,
-	.lookup		= nat_lookup,
-	.unlink		= nat_hdr_unlink,
-	.rename		= nat_hdr_rename,
-	.setattr	= hfs_notify_change,
-};
-
-/*================ File-local functions ================*/
-
-/*
- * nat_lookup()
- *
- * This is the lookup() entry in the inode_operations structure for
- * HFS directories in the Netatalk scheme.  The purpose is to generate
- * the inode corresponding to an entry in a directory, given the inode
- * for the directory and the name (and its length) of the entry.
- */
-static struct dentry *nat_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
-{
-	ino_t dtype;
-	struct hfs_name cname;
-	struct hfs_cat_entry *entry;
-	struct hfs_cat_key key;
-	struct inode *inode = NULL;
-
-	lock_kernel();
-	dentry->d_op = &hfs_dentry_operations;
-	entry = HFS_I(dir)->entry;
-	dtype = HFS_ITYPE(dir->i_ino);
-
-	/* Perform name-mangling */
-	hfs_nameout(dir, &cname, dentry->d_name.name, dentry->d_name.len);
-
-	/* no need to check for "."  or ".." */
-
-	/* Check for ".AppleDouble" if in a normal directory,
-	   and for ".Parent" in ".AppleDouble". */
-	if (dtype==HFS_NAT_NDIR) {
-		/* Check for ".AppleDouble" */
-		if (hfs_streq(cname.Name, cname.Len, 
-			      DOT_APPLEDOUBLE->Name, DOT_APPLEDOUBLE_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_NAT_HDIR, dentry);
-			goto done;
-		}
-	} else if (dtype==HFS_NAT_HDIR) {
-		if (hfs_streq(cname.Name, cname.Len, 
-			      DOT_PARENT->Name, DOT_PARENT_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_NAT_HDR, dentry);
-			goto done;
-		}
-
-		if ((entry->cnid == htonl(HFS_ROOT_CNID)) &&
-		    hfs_streq(cname.Name, cname.Len, 
-			      ROOTINFO->Name, ROOTINFO_LEN)) {
-			++entry->count; /* __hfs_iget() eats one */
-			inode = hfs_iget(entry, HFS_NAT_HDR, dentry);
-                        goto done;
-		}
-	}
-
-	/* Do an hfs_iget() on the mangled name. */
-	hfs_cat_build_key(entry->cnid, &cname, &key);
-	inode = hfs_iget(hfs_cat_get(entry->mdb, &key), 
-			 HFS_I(dir)->file_type, dentry);
-
-	/* Don't return a header file for a directory other than .Parent */
-	if (inode && (dtype == HFS_NAT_HDIR) &&
-	    (HFS_I(inode)->entry != entry) &&
-	    (HFS_I(inode)->entry->type == HFS_CDR_DIR)) {
-	        iput(inode); /* this does an hfs_cat_put */
-		inode = NULL;
-	}
-
-done:
-	unlock_kernel();
-	d_add(dentry, inode);
-	return NULL;
-}
-
-/*
- * nat_readdir()
- *
- * This is the readdir() entry in the file_operations structure for
- * HFS directories in the netatalk scheme.  The purpose is to
- * enumerate the entries in a directory, given the inode of the
- * directory and a struct file which indicates the location in the
- * directory.  The struct file is updated so that the next call with
- * the same dir and filp will produce the next directory entry.	 The
- * entries are returned in dirent, which is "filled-in" by calling
- * filldir().  This allows the same readdir() function be used for
- * different dirent formats.  We try to read in as many entries as we
- * can before filldir() refuses to take any more.
- *
- * Note that the Netatalk format doesn't have the problem with
- * metadata for covered directories that exists in the other formats,
- * since the metadata is contained within the directory.
- */
-static int nat_readdir(struct file * filp,
-		       void * dirent, filldir_t filldir)
-{
-	ino_t type;
-	int skip_dirs;
-	struct hfs_brec brec;
-        struct hfs_cat_entry *entry;
-	struct inode *dir = filp->f_dentry->d_inode;
-
-	lock_kernel();
-	
-	entry = HFS_I(dir)->entry;
-	type = HFS_ITYPE(dir->i_ino);
-	skip_dirs = (type == HFS_NAT_HDIR);
-
-	if (filp->f_pos == 0) {
-		/* Entry 0 is for "." */
-		if (filldir(dirent, DOT->Name, DOT_LEN, 0, dir->i_ino,
-			    DT_DIR)) {
-			goto out;
-		}
-		filp->f_pos = 1;
-	}
-
-	if (filp->f_pos == 1) {
-		/* Entry 1 is for ".." */
-		hfs_u32 cnid;
-
-		if (type == HFS_NAT_NDIR) {
-			cnid = hfs_get_nl(entry->key.ParID);
-		} else {
-			cnid = entry->cnid;
-		}
-
-		if (filldir(dirent, DOT_DOT->Name,
-			    DOT_DOT_LEN, 1, ntohl(cnid), DT_DIR)) {
-			goto out;
-		}
-		filp->f_pos = 2;
-	}
-
-	if (filp->f_pos < (dir->i_size - 2)) {
-		hfs_u32 cnid;
-		hfs_u8 type;
-
-	    	if (hfs_cat_open(entry, &brec) ||
-		    hfs_cat_next(entry, &brec, filp->f_pos - 2, &cnid, &type)) {
-			goto out;
-		}
-		while (filp->f_pos < (dir->i_size - 2)) {
-			if (hfs_cat_next(entry, &brec, 1, &cnid, &type)) {
-				goto out;
-			}
-			if (!skip_dirs || (type != HFS_CDR_DIR)) {
-				ino_t ino;
-				unsigned int len;
-				unsigned char tmp_name[HFS_NAMEMAX];
-
-				ino = ntohl(cnid) | HFS_I(dir)->file_type;
-				len = hfs_namein(dir, tmp_name,
-				    &((struct hfs_cat_key *)brec.key)->CName);
-				if (filldir(dirent, tmp_name, len,
-					    filp->f_pos, ino, DT_UNKNOWN)) {
-					hfs_cat_close(entry, &brec);
-					goto out;
-				}
-			}
-			++filp->f_pos;
-		}
-		hfs_cat_close(entry, &brec);
-	}
-
-	if (filp->f_pos == (dir->i_size - 2)) {
-		if (type == HFS_NAT_NDIR) {
-			/* In normal dirs entry 2 is for ".AppleDouble" */
-			if (filldir(dirent, DOT_APPLEDOUBLE->Name,
-				    DOT_APPLEDOUBLE_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_NAT_HDIR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		} else if (type == HFS_NAT_HDIR) {
-			/* In .AppleDouble entry 2 is for ".Parent" */
-			if (filldir(dirent, DOT_PARENT->Name,
-				    DOT_PARENT_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_NAT_HDR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-	if (filp->f_pos == (dir->i_size - 1)) {
-		/* handle ROOT/.AppleDouble/RootInfo as the last entry. */
-		if ((entry->cnid == htonl(HFS_ROOT_CNID)) &&
-		    (type == HFS_NAT_HDIR)) {
-			if (filldir(dirent, ROOTINFO->Name,
-				    ROOTINFO_LEN, filp->f_pos,
-				    ntohl(entry->cnid) | HFS_NAT_HDR,
-				    DT_UNKNOWN)) {
-				goto out;
-			}
-		}
-		++filp->f_pos;
-	}
-
-out:
-	unlock_kernel();
-	return 0;
-}
-
-/* due to the dcache caching negative dentries for non-existent files,
- * we need to drop those entries when a file silently gets created.
- * as far as i can tell, the calls that need to do this are the file
- * related calls (create, rename, and mknod). the directory calls
- * should be immune. the relevant calls in dir.c call drop_dentry 
- * upon successful completion. */
-void hfs_nat_drop_dentry(struct dentry *dentry, const ino_t type)
-{
-  struct dentry *de;
-  
-  switch (type) {
-  case HFS_NAT_HDR: /* given .AppleDouble/name */
-    /* look for name */
-    de = hfs_lookup_dentry(dentry->d_parent->d_parent,
-			   dentry->d_name.name, dentry->d_name.len);
-
-    if (de) {
-      if (!de->d_inode)
-	d_drop(de);
-      dput(de);
-    }
-    break;
-  case HFS_NAT_DATA: /* given name */
-    /* look for .AppleDouble/name */
-    hfs_drop_special(dentry->d_parent, DOT_APPLEDOUBLE, dentry);
-    break;
-  }
-
-}
-
-/*
- * nat_rmdir()
- *
- * This is the rmdir() entry in the inode_operations structure for
- * Netatalk directories.  The purpose is to delete an existing
- * directory, given the inode for the parent directory and the name
- * (and its length) of the existing directory.
- *
- * We handle .AppleDouble and call hfs_rmdir() for all other cases.
- */
-static int nat_rmdir(struct inode *parent, struct dentry *dentry)
-{
-	struct hfs_cat_entry *entry = HFS_I(parent)->entry;
-	struct hfs_name cname;
-	int error;
-
-	lock_kernel();
-	hfs_nameout(parent, &cname, dentry->d_name.name, dentry->d_name.len);
-	if (hfs_streq(cname.Name, cname.Len,
-		      DOT_APPLEDOUBLE->Name, DOT_APPLEDOUBLE_LEN)) {
-		if (!HFS_SB(parent->i_sb)->s_afpd) {
-			/* Not in AFPD compatibility mode */
-			error = -EPERM;
-		} else if (entry->u.dir.files || entry->u.dir.dirs) {
-			/* AFPD compatible, but the directory is not empty */
-			error = -ENOTEMPTY;
-		} else {
-			/* AFPD compatible, so pretend to succeed */
-			error = 0;
-		}
-	} else {
-		error = hfs_rmdir(parent, dentry);
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * nat_hdr_unlink()
- *
- * This is the unlink() entry in the inode_operations structure for
- * Netatalk .AppleDouble directories.  The purpose is to delete an
- * existing file, given the inode for the parent directory and the name
- * (and its length) of the existing file.
- *
- * WE DON'T ACTUALLY DELETE HEADER THE FILE.
- * In non-afpd-compatible mode:
- *   We return -EPERM.
- * In afpd-compatible mode:
- *   We return success if the file exists or is .Parent.
- *   Otherwise we return -ENOENT.
- */
-static int nat_hdr_unlink(struct inode *dir, struct dentry *dentry)
-{
-	struct hfs_cat_entry *entry;
-	int error = 0;
-
-	lock_kernel();
-	entry = HFS_I(dir)->entry;
-	if (!HFS_SB(dir->i_sb)->s_afpd) {
-		/* Not in AFPD compatibility mode */
-		error = -EPERM;
-	} else {
-		struct hfs_name cname;
-
-		hfs_nameout(dir, &cname, dentry->d_name.name, 
-			    dentry->d_name.len);
-		if (!hfs_streq(cname.Name, cname.Len,
-			       DOT_PARENT->Name, DOT_PARENT_LEN)) {
-			struct hfs_cat_entry *victim;
-			struct hfs_cat_key key;
-
-			hfs_cat_build_key(entry->cnid, &cname, &key);
-			victim = hfs_cat_get(entry->mdb, &key);
-
-			if (victim) {
-				/* pretend to succeed */
-				hfs_cat_put(victim);
-			} else {
-				error = -ENOENT;
-			}
-		}
-	}
-	unlock_kernel();
-	return error;
-}
-
-/*
- * nat_hdr_rename()
- *
- * This is the rename() entry in the inode_operations structure for
- * Netatalk header directories.  The purpose is to rename an existing
- * file given the inode for the current directory and the name 
- * (and its length) of the existing file and the inode for the new
- * directory and the name (and its length) of the new file/directory.
- *
- * WE NEVER MOVE ANYTHING.
- * In non-afpd-compatible mode:
- *   We return -EPERM.
- * In afpd-compatible mode:
- *   If the source header doesn't exist, we return -ENOENT.
- *   If the destination is not a header directory we return -EPERM.
- *   We return success if the destination is also a header directory
- *    and the header exists or is ".Parent".
- */
-static int nat_hdr_rename(struct inode *old_dir, struct dentry *old_dentry,
-			  struct inode *new_dir, struct dentry *new_dentry)
-{
-	struct hfs_cat_entry *entry;
-	int error = 0;
-
-	lock_kernel();
-	entry = HFS_I(old_dir)->entry;
-	if (!HFS_SB(old_dir->i_sb)->s_afpd) {
-		/* Not in AFPD compatibility mode */
-		error = -EPERM;
-	} else {
-		struct hfs_name cname;
-
-		hfs_nameout(old_dir, &cname, old_dentry->d_name.name,
-			    old_dentry->d_name.len);
-		if (!hfs_streq(cname.Name, cname.Len, 
-			       DOT_PARENT->Name, DOT_PARENT_LEN)) {
-			struct hfs_cat_entry *victim;
-			struct hfs_cat_key key;
-
-			hfs_cat_build_key(entry->cnid, &cname, &key);
-			victim = hfs_cat_get(entry->mdb, &key);
-
-			if (victim) {
-				/* pretend to succeed */
-				hfs_cat_put(victim);
-			} else {
-				error = -ENOENT;
-			}
-		}
-
-		if (!error && (HFS_ITYPE(new_dir->i_ino) != HFS_NAT_HDIR)) {
-			error = -EPERM;
-		}
-	}
-	unlock_kernel();
-	return error;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/extent.c linuxppc-2.5-benh/fs/hfs/extent.c
--- /dev/shm/linux-2.5/fs/hfs/extent.c	2002-02-06 18:53:12.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/extent.c	2004-01-29 04:53:41.000000000 +0000
@@ -13,620 +13,25 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
+#include <linux/pagemap.h>
 
-/*================ File-local data type ================*/
-
-/* An extent record on disk*/
-struct hfs_raw_extent {
-	hfs_word_t	block1;
-	hfs_word_t	length1;
-	hfs_word_t	block2;
-	hfs_word_t	length2;
-	hfs_word_t	block3;
-	hfs_word_t	length3;
-};
+#include "hfs_fs.h"
+#include "btree.h"
 
 /*================ File-local functions ================*/
 
 /*
  * build_key
  */
-static inline void build_key(struct hfs_ext_key *key,
-			     const struct hfs_fork *fork, hfs_u16 block)
-{
-	key->KeyLen = 7;
-	key->FkType = fork->fork;
-	hfs_put_nl(fork->entry->cnid, key->FNum);
-	hfs_put_hs(block,             key->FABN);
-}
-
-
-/*
- * lock_bitmap()
- *
- * Get an exclusive lock on the B-tree bitmap.
- */
-static inline void lock_bitmap(struct hfs_mdb *mdb) {
-	down(&mdb->bitmap_sem);
-}
-
-/*
- * unlock_bitmap()
- *
- * Relinquish an exclusive lock on the B-tree bitmap.
- */
-static inline void unlock_bitmap(struct hfs_mdb *mdb) {
-	up(&mdb->bitmap_sem);
-}
-
-/*
- * dump_ext()
- *
- * prints the content of a extent for debugging purposes.
- */
-#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
-static void dump_ext(const char *msg, const struct hfs_extent *e) {
-	if (e) {
-		hfs_warn("%s (%d-%d) (%d-%d) (%d-%d)\n", msg,
-			 e->start,
-			 e->start + e->length[0] - 1,
-			 e->start + e->length[0],
-			 e->start + e->length[0] + e->length[1] - 1,
-			 e->start + e->length[0] + e->length[1],
-			 e->end);
-	} else {
-		hfs_warn("%s NULL\n", msg);
-	}
-}
-#else
-#define dump_ext(A,B) {}
-#endif
-
-/*
- * read_extent()
- * 
- * Initializes a (struct hfs_extent) from a (struct hfs_raw_extent) and
- * the number of the starting block for the extent.
- *
- * Note that the callers must check that to,from != NULL
- */
-static void read_extent(struct hfs_extent *to,
-			const struct hfs_raw_extent *from,
-			hfs_u16 start)
-{
-	to->start = start;
-	to->block[0]  = hfs_get_hs(from->block1);
-	to->length[0] = hfs_get_hs(from->length1);
-	to->block[1]  = hfs_get_hs(from->block2);
-	to->length[1] = hfs_get_hs(from->length2);
-	to->block[2]  = hfs_get_hs(from->block3);
-	to->length[2] = hfs_get_hs(from->length3);
-	to->end = start + to->length[0] + to->length[1] + to->length[2] - 1;
-	to->next = to->prev = NULL;
-	to->count = 0;
-}
-
-/*
- * write_extent()
- * 
- * Initializes a (struct hfs_raw_extent) from a (struct hfs_extent).
- *
- * Note that the callers must check that to,from != NULL
- */
-static void write_extent(struct hfs_raw_extent *to,
-			 const struct hfs_extent *from)
+static void hfs_ext_build_key(hfs_btree_key *key, u32 cnid, u16 block, u8 type)
 {
-	hfs_put_hs(from->block[0], to->block1);
-	hfs_put_hs(from->length[0], to->length1);
-	hfs_put_hs(from->block[1], to->block2);
-	hfs_put_hs(from->length[1], to->length2);
-	hfs_put_hs(from->block[2], to->block3);
-	hfs_put_hs(from->length[2], to->length3);
+	key->key_len = 7;
+	key->ext.FkType = type;
+	key->ext.FNum = cpu_to_be32(cnid);
+	key->ext.FABN = cpu_to_be16(block);
 }
 
 /*
- * decode_extent()
- *
- * Given an extent record and allocation block offset into the file,
- * return the number of the corresponding allocation block on disk,
- * or -1 if the desired block is not mapped by the given extent.
- *
- * Note that callers must check that extent != NULL
- */
-static int decode_extent(const struct hfs_extent * extent, int block)
-{
-	if (!extent || (block < extent->start) || (block > extent->end) ||
-	    (extent->end == (hfs_u16)(extent->start - 1))) {
-		return -1;
-	}
-	block -= extent->start;
-	if (block < extent->length[0]) {
-		return block + extent->block[0];
-	}
-	block -= extent->length[0];
-	if (block < extent->length[1]) {
-		return block + extent->block[1];
-	}
-	return block + extent->block[2] - extent->length[1];
-}
-
-/*
- * relse_ext()
- *
- * Reduce the reference count of an in-core extent record by one,
- * removing it from memory if the count falls to zero.
- */
-static void relse_ext(struct hfs_extent *ext)
-{
-	if (--ext->count || !ext->start) {
-		return;
-	}
-	ext->prev->next = ext->next;
-	if (ext->next) {
-		ext->next->prev = ext->prev;
-	}
-	HFS_DELETE(ext);
-}
-
-/*
- * set_cache()
- * 
- * Changes the 'cache' field of the fork.
- */
-static inline void set_cache(struct hfs_fork *fork, struct hfs_extent *ext)
-{
-	struct hfs_extent *tmp = fork->cache;
-
-	++ext->count;
-	fork->cache = ext;
-	relse_ext(tmp);
-}
-
-/*
- * find_ext()
- *
- * Given a pointer to a (struct hfs_file) and an allocation block
- * number in the file, find the extent record containing that block.
- * Returns a pointer to the extent record on success or NULL on failure.
- * The 'cache' field of 'fil' also points to the extent so it has a
- * reference count of at least 2.
- *
- * Callers must check that fil != NULL
- */
-static struct hfs_extent * find_ext(struct hfs_fork *fork, int alloc_block)
-{
-        struct hfs_cat_entry *entry = fork->entry;
-	struct hfs_btree *tr= entry->mdb->ext_tree;
-	struct hfs_ext_key target, *key;
-	struct hfs_brec brec;
-	struct hfs_extent *ext, *ptr;
-	int tmp;
-
-	if (alloc_block < 0) {
-		ext = &fork->first;
-		goto found;
-	}
-
-	ext = fork->cache;
-	if (!ext || (alloc_block < ext->start)) {
-		ext = &fork->first;
-	}
-	while (ext->next && (alloc_block > ext->end)) {
-		ext = ext->next;
-	}
-	if ((alloc_block <= ext->end) && (alloc_block >= ext->start)) {
-		goto found;
-	}
-
-	/* time to read more extents */
-	if (!HFS_NEW(ext)) {
-		goto bail3;
-	}
-
-	build_key(&target, fork, alloc_block);
-
-	tmp = hfs_bfind(&brec, tr, HFS_BKEY(&target), HFS_BFIND_READ_LE);
-	if (tmp < 0) {
-		goto bail2;
-	}
-
-	key = (struct hfs_ext_key *)brec.key;
-	if ((hfs_get_nl(key->FNum) != hfs_get_nl(target.FNum)) ||
-	    (key->FkType != fork->fork)) {
-		goto bail1;
-	}
-		
-	read_extent(ext, brec.data, hfs_get_hs(key->FABN));
-	hfs_brec_relse(&brec, NULL);
-
-	if ((alloc_block > ext->end) && (alloc_block < ext->start)) {
-		/* something strange happened */
-		goto bail2;
-	}
-
-	ptr = fork->cache;
-	if (!ptr || (alloc_block < ptr->start)) {
-		ptr = &fork->first;
-	}
-	while (ptr->next && (alloc_block > ptr->end)) {
-		ptr = ptr->next;
-	}
-	if (ext->start == ptr->start) {
-		/* somebody beat us to it. */
-		HFS_DELETE(ext);
-		ext = ptr;
-	} else if (ext->start < ptr->start) {
-		/* insert just before ptr */
-		ptr->prev->next = ext;
-		ext->prev = ptr->prev;
-		ext->next = ptr;
-		ptr->prev = ext;
-	} else {
-		/* insert at end */
-		ptr->next = ext;
-		ext->prev = ptr;
-	}
- found:
-	++ext->count; /* for return value */
-	set_cache(fork, ext);
-	return ext;
-
- bail1:
-	hfs_brec_relse(&brec, NULL);
- bail2:
-	HFS_DELETE(ext);
- bail3:
-	return NULL;
-}
-
-/*
- * delete_extent()
- *
- * Description:
- *   Deletes an extent record from a fork, reducing its physical length.
- * Input Variable(s):
- *   struct hfs_fork *fork: the fork
- *   struct hfs_extent *ext: the current last extent for 'fork'
- * Output Variable(s):
- *   NONE
- * Returns:
- *   void
- * Preconditions:
- *   'fork' points to a valid (struct hfs_fork)
- *   'ext' point to a valid (struct hfs_extent) which is the last in 'fork'
- *    and which is not also the first extent in 'fork'.
- * Postconditions:
- *   The extent record has been removed if possible, and a warning has been
- *   printed otherwise.
- */
-static void delete_extent(struct hfs_fork *fork, struct hfs_extent *ext)
-{
-	struct hfs_mdb *mdb = fork->entry->mdb;
-	struct hfs_ext_key key;
-	int error;
-
-	if (fork->cache == ext) {
-		set_cache(fork, ext->prev);
-	}
-	ext->prev->next = NULL;
-	if (ext->count != 1) {
-		hfs_warn("hfs_truncate: extent has count %d.\n", ext->count);
-	}
-
-	lock_bitmap(mdb);
-	error = hfs_clear_vbm_bits(mdb, ext->block[2], ext->length[2]);
-	if (error) {
-		hfs_warn("hfs_truncate: error %d freeing blocks.\n", error);
-	}
-	error = hfs_clear_vbm_bits(mdb, ext->block[1], ext->length[1]);
-	if (error) {
-		hfs_warn("hfs_truncate: error %d freeing blocks.\n", error);
-	}
-	error = hfs_clear_vbm_bits(mdb, ext->block[0], ext->length[0]);
-	if (error) {
-		hfs_warn("hfs_truncate: error %d freeing blocks.\n", error);
-	}
-	unlock_bitmap(mdb);
-
-	build_key(&key, fork, ext->start);
-
-	error = hfs_bdelete(mdb->ext_tree, HFS_BKEY(&key));
-	if (error) {
-		hfs_warn("hfs_truncate: error %d deleting an extent.\n", error);
-	}
-
-	HFS_DELETE(ext);
-}
-
-/*
- * new_extent()
- *
- * Description:
- *   Adds a new extent record to a fork, extending its physical length.
- * Input Variable(s):
- *   struct hfs_fork *fork: the fork to extend
- *   struct hfs_extent *ext: the current last extent for 'fork'
- *   hfs_u16 ablock: the number of allocation blocks in 'fork'.
- *   hfs_u16 start: first allocation block to add to 'fork'.
- *   hfs_u16 len: the number of allocation blocks to add to 'fork'.
- *   hfs_u32 ablksz: number of sectors in an allocation block.
- * Output Variable(s):
- *   NONE
- * Returns:
- *   (struct hfs_extent *) the new extent or NULL
- * Preconditions:
- *   'fork' points to a valid (struct hfs_fork)
- *   'ext' point to a valid (struct hfs_extent) which is the last in 'fork'
- *   'ablock', 'start', 'len' and 'ablksz' are what they claim to be.
- * Postconditions:
- *   If NULL is returned then no changes have been made to 'fork'.
- *   If the return value is non-NULL that it is the extent that has been
- *   added to 'fork' both in memory and on disk.  The 'psize' field of
- *   'fork' has been updated to reflect the new physical size.
- */
-static struct hfs_extent *new_extent(struct hfs_fork *fork,
-				     struct hfs_extent *ext,
-				     hfs_u16 ablock, hfs_u16 start,
-				     hfs_u16 len, hfs_u16 ablksz)
-{
-	struct hfs_raw_extent raw;
-	struct hfs_ext_key key;
-	int error;
-
-	if (fork->entry->cnid == htonl(HFS_EXT_CNID)) {
-		/* Limit extents tree to the record in the MDB */
-		return NULL;
-	}
-
-	if (!HFS_NEW(ext->next)) {
-		return NULL;
-	}
-	ext->next->prev = ext;
-	ext->next->next = NULL;
-	ext = ext->next;
-	relse_ext(ext->prev);
-
-	ext->start = ablock;
-	ext->block[0] = start;
-	ext->length[0] = len;
-	ext->block[1] = 0;
-	ext->length[1] = 0;
-	ext->block[2] = 0;
-	ext->length[2] = 0;
-	ext->end = ablock + len - 1;
-	ext->count = 1;
-
-	write_extent(&raw, ext);
-	
-	build_key(&key, fork, ablock);
-
-	error = hfs_binsert(fork->entry->mdb->ext_tree, 
-			    HFS_BKEY(&key), &raw, sizeof(raw));
-	if (error) {
-		ext->prev->next = NULL;
-		HFS_DELETE(ext);
-		return NULL;
-	}
-	set_cache(fork, ext);
-	return ext;
-}
-
-/*
- * update_ext()
- *
- * Given a (struct hfs_fork) write an extent record back to disk.
- */
-static void update_ext(struct hfs_fork *fork, struct hfs_extent *ext)
-{
-	struct hfs_ext_key target;
-	struct hfs_brec brec;
-
-	if (ext->start) {
-		build_key(&target, fork, ext->start);
-
-		if (!hfs_bfind(&brec, fork->entry->mdb->ext_tree,
-			       HFS_BKEY(&target), HFS_BFIND_WRITE)) {
-			write_extent(brec.data, ext);
-			hfs_brec_relse(&brec, NULL);
-		}
-	}
-}
-
-/*
- * zero_blocks()
- * 
- * Zeros-out 'num' allocation blocks beginning with 'start'.
- */
-static int zero_blocks(struct hfs_mdb *mdb, int start, int num) {
-	hfs_buffer buf;
-	int end;
-	int j;
-
-	start = mdb->fs_start + start * mdb->alloc_blksz;
-	end = start + num * mdb->alloc_blksz;
-
-	for (j=start; j<end; ++j) {
-		if (hfs_buffer_ok(buf = hfs_buffer_get(mdb->sys_mdb, j, 0))) {
-			memset(hfs_buffer_data(buf), 0, HFS_SECTOR_SIZE);
-			hfs_buffer_dirty(buf);
-			hfs_buffer_put(buf);
-		}
-	}
-	return 0;
-}
-
-/*
- * shrink_fork()
- *
- * Try to remove enough allocation blocks from 'fork'
- * so that it is 'ablocks' allocation blocks long. 
- */
-static void shrink_fork(struct hfs_fork *fork, int ablocks)
-{
-	struct hfs_mdb *mdb = fork->entry->mdb;
-	struct hfs_extent *ext;
-	int i, error, next, count;
-	hfs_u32 ablksz = mdb->alloc_blksz;
-
-	next =  (fork->psize / ablksz) - 1;
-	ext = find_ext(fork, next);
-	while (ext && ext->start && (ext->start >= ablocks)) {
-		next = ext->start - 1;
-		delete_extent(fork, ext);
-		ext = find_ext(fork, next);
-	}
-	if (!ext) {
-		fork->psize = (next + 1) * ablksz;
-		return;
-	}
-
-	if ((count = next + 1 - ablocks) > 0) {
-		for (i=2; (i>=0) && !ext->length[i]; --i) {};
-		lock_bitmap(mdb);
-		while (count && (ext->length[i] <= count)) {
-			ext->end -= ext->length[i];
-			count -= ext->length[i];
-			error = hfs_clear_vbm_bits(mdb, ext->block[i],
-						   ext->length[i]);
-			if (error) {
-				hfs_warn("hfs_truncate: error %d freeing "
-				       "blocks.\n", error);
-			}
-			ext->block[i] = ext->length[i] = 0;
-			--i;
-		}
-		if (count) {
-			ext->end -= count;
-			ext->length[i] -= count;
-			error = hfs_clear_vbm_bits(mdb, ext->block[i] +
-						       ext->length[i], count);
-			if (error) {
-				hfs_warn("hfs_truncate: error %d freeing "
-				       "blocks.\n", error);
-			}
-		}
-		unlock_bitmap(mdb);
-		update_ext(fork, ext);
-	}
-
-	fork->psize = ablocks * ablksz;
-}
-
-/*
- * grow_fork()
- *
- * Try to add enough allocation blocks to 'fork'
- * so that it is 'ablock' allocation blocks long. 
- */
-static int grow_fork(struct hfs_fork *fork, int ablocks)
-{
-	struct hfs_cat_entry *entry = fork->entry;
-	struct hfs_mdb *mdb = entry->mdb;
-	struct hfs_extent *ext;
-	int i, start, err;
-	hfs_u16 need, len=0;
-	hfs_u32 ablksz = mdb->alloc_blksz;
-	hfs_u32 blocks, clumpablks;
-
-	blocks = fork->psize;
-	need = ablocks - blocks/ablksz;
-	if (need < 1) { /* no need to grow the fork */
-		return 0;
-	}
-
-	/* round up to clumpsize */
-	if (entry->u.file.clumpablks) {
-		clumpablks = entry->u.file.clumpablks;
-	} else {
-		clumpablks = mdb->clumpablks;
-	}
-	need = ((need + clumpablks - 1) / clumpablks) * clumpablks;
-
-	/* find last extent record and try to extend it */
-	if (!(ext = find_ext(fork, blocks/ablksz - 1))) {
-		/* somehow we couldn't find the end of the file! */
-		return -1;
-	}
-
-	/* determine which is the last used extent in the record */
-	/* then try to allocate the blocks immediately following it */
-	for (i=2; (i>=0) && !ext->length[i]; --i) {};
-	if (i>=0) {
-		/* try to extend the last extent */
-		start = ext->block[i] + ext->length[i];
-
-		err = 0;
-		lock_bitmap(mdb);
-		len = hfs_vbm_count_free(mdb, start);
-		if (!len) {
-			unlock_bitmap(mdb);
-			goto more_extents;
-		}
-		if (need < len) {
-			len = need;
-		}
-		err = hfs_set_vbm_bits(mdb, start, len);
-		unlock_bitmap(mdb);
-		if (err) {
-			relse_ext(ext);
-			return -1;
-		}
-	
-		zero_blocks(mdb, start, len);
-	
-		ext->length[i] += len;
-		ext->end += len;
-		blocks = (fork->psize += len * ablksz);
-		need -= len;
-		update_ext(fork, ext);
-	}
-
-more_extents:
-	/* add some more extents */
-	while (need) {
-		len = need;
-		err = 0;
-		lock_bitmap(mdb);
-		start = hfs_vbm_search_free(mdb, &len);
-		if (need < len) {
-			len = need;
-		}
-		err = hfs_set_vbm_bits(mdb, start, len);
-		unlock_bitmap(mdb);
-		if (!len || err) {
-			relse_ext(ext);
-			return -1;
-		}
-		zero_blocks(mdb, start, len);
-
-		/* determine which is the first free extent in the record */
-		for (i=0; (i<3) && ext->length[i]; ++i) {};
-		if (i < 3) {
-			ext->block[i] = start;
-			ext->length[i] = len;
-			ext->end += len;
-			update_ext(fork, ext);
-		} else {
-			if (!(ext = new_extent(fork, ext, blocks/ablksz,
-					       start, len, ablksz))) {
-				lock_bitmap(mdb);
-				hfs_clear_vbm_bits(mdb, start, len);
-				unlock_bitmap(mdb);
-				return -1;
-			}
-		}
-		blocks = (fork->psize += len * ablksz);
-		need -= len;
-	}
-	set_cache(fork, ext);
-	relse_ext(ext);
-	return 0;
-}
-
-/*================ Global functions ================*/
-
-/*
  * hfs_ext_compare()
  *
  * Description:
@@ -647,159 +52,480 @@ more_extents:
  *   key1 and key2 point to "valid" (struct hfs_ext_key)s.
  * Postconditions:
  *   This function has no side-effects */
-int hfs_ext_compare(const struct hfs_ext_key *key1,
-		    const struct hfs_ext_key *key2)
+int hfs_ext_keycmp(const btree_key *key1, const btree_key *key2)
 {
 	unsigned int tmp;
 	int retval;
 
-	tmp = hfs_get_hl(key1->FNum) - hfs_get_hl(key2->FNum);
+	tmp = be32_to_cpu(key1->ext.FNum) - be32_to_cpu(key2->ext.FNum);
 	if (tmp != 0) {
 		retval = (int)tmp;
 	} else {
-		tmp = (unsigned char)key1->FkType - (unsigned char)key2->FkType;
+		tmp = (unsigned char)key1->ext.FkType - (unsigned char)key2->ext.FkType;
 		if (tmp != 0) {
 			retval = (int)tmp;
 		} else {
-			retval = (int)(hfs_get_hs(key1->FABN)
-				       - hfs_get_hs(key2->FABN));
+			retval = (int)(be16_to_cpu(key1->ext.FABN)
+				       - be16_to_cpu(key2->ext.FABN));
 		}
 	}
 	return retval;
 }
 
 /*
- * hfs_extent_adj()
+ * hfs_ext_find_block
  *
- * Given an hfs_fork shrink or grow the fork to hold the
- * forks logical size.
+ * Find a block within an extent record
  */
-void hfs_extent_adj(struct hfs_fork *fork)
+static u16 hfs_ext_find_block(struct hfs_extent *ext, u16 off)
 {
-	if (fork) {
-		hfs_u32 blks, ablocks, ablksz;
+	int i;
+	u16 count;
 
-		if (fork->lsize > HFS_FORK_MAX) {
-			fork->lsize = HFS_FORK_MAX;
-		}
-
-		blks = (fork->lsize+HFS_SECTOR_SIZE-1) >> HFS_SECTOR_SIZE_BITS;
-		ablksz = fork->entry->mdb->alloc_blksz;
-		ablocks = (blks + ablksz - 1) / ablksz;
-
-		if (blks > fork->psize) {
-			grow_fork(fork, ablocks);
-			if (blks > fork->psize) {
-				fork->lsize =
-					fork->psize >> HFS_SECTOR_SIZE_BITS;
-			}
-		} else if (blks < fork->psize) {
-			shrink_fork(fork, ablocks);
-		}
+	for (i = 0; i < 3; ext++, i++) {
+		count = be16_to_cpu(ext->count);
+		if (off < count)
+			return be16_to_cpu(ext->block) + off;
+		off -= count;
 	}
+	/* panic? */
+	return 0;
 }
 
-/*
- * hfs_extent_map()
- *
- * Given an hfs_fork and a block number within the fork, return the
- * number of the corresponding physical block on disk, or zero on
- * error.
- */
-int hfs_extent_map(struct hfs_fork *fork, int block, int create) 
+static int hfs_ext_block_count(struct hfs_extent *ext)
 {
-	int ablksz, ablock, offset, tmp;
-	struct hfs_extent *ext;
+	int i;
+	u16 count = 0;
 
-	if (!fork || !fork->entry || !fork->entry->mdb) {
-		return 0;
-	}
+	for (i = 0; i < 3; ext++, i++)
+		count += be16_to_cpu(ext->count);
+	return count;
+}
 
-#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
-	hfs_warn("hfs_extent_map: ablock %d of file %d, fork %d\n",
-		 block, fork->entry->cnid, fork->fork);
-#endif
+static u16 hfs_ext_lastblock(struct hfs_extent *ext)
+{
+	int i;
 
-	if (block < 0) {
-		hfs_warn("hfs_extent_map: block < 0\n");
-		return 0;
-	}
-	if (block > (HFS_FORK_MAX >> HFS_SECTOR_SIZE_BITS)) {
-		hfs_warn("hfs_extent_map: block(0x%08x) > big; cnid=%d "
-			 "fork=%d\n", block, fork->entry->cnid, fork->fork);
-		return 0;
+	ext += 2;
+	for (i = 0; i < 2; ext--, i++)
+		if (ext->count)
+			break;
+	return be16_to_cpu(ext->block) + be16_to_cpu(ext->count);
+}
+
+static void __hfs_ext_write_extent(struct inode *inode, struct hfs_find_data *fd)
+{
+	int res;
+
+	hfs_ext_build_key(fd->search_key, inode->i_ino, HFS_I(inode)->cached_start,
+			  HFS_IS_RSRC(inode) ?  HFS_FK_RSRC : HFS_FK_DATA);
+	res = hfs_brec_find(fd);
+	if (HFS_I(inode)->flags & HFS_FLG_EXT_NEW) {
+		if (res != -ENOENT)
+			return;
+		hfs_brec_insert(fd, HFS_I(inode)->cached_extents, sizeof(hfs_extent_rec));
+		HFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);
+	} else {
+		if (res)
+			return;
+		hfs_bnode_write(fd->bnode, HFS_I(inode)->cached_extents, fd->entryoffset, fd->entrylength);
+		HFS_I(inode)->flags &= ~HFS_FLG_EXT_DIRTY;
 	}
-	ablksz = fork->entry->mdb->alloc_blksz;
-	offset = fork->entry->mdb->fs_start + (block % ablksz);
-	ablock = block / ablksz;
-	
-	if (block >= fork->psize) {
-		if (!create || (grow_fork(fork, ablock + 1) < 0))
-			return 0;
+}
+
+void hfs_ext_write_extent(struct inode *inode)
+{
+	struct hfs_find_data fd;
+
+	if (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY) {
+		hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);
+		__hfs_ext_write_extent(inode, &fd);
+		hfs_find_exit(&fd);
 	}
+}
 
-#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
-	hfs_warn("(lblock %d offset %d)\n", ablock, offset);
-#endif
-
-	if ((ext = find_ext(fork, ablock))) {
-		dump_ext("trying new: ", ext);
-		tmp = decode_extent(ext, ablock);
-		relse_ext(ext);
-		if (tmp >= 0) {
-			return tmp*ablksz + offset;
-		}
-	} 
+static inline int __hfs_ext_read_extent(struct hfs_find_data *fd, struct hfs_extent *extent,
+					u32 cnid, u32 block, u8 type)
+{
+	int res;
 
+	hfs_ext_build_key(fd->search_key, cnid, block, type);
+	fd->key->ext.FNum = 0;
+	res = hfs_brec_find(fd);
+	if (res && res != -ENOENT)
+		return res;
+	if (fd->key->ext.FNum != fd->search_key->ext.FNum ||
+	    fd->key->ext.FkType != fd->search_key->ext.FkType)
+		return -ENOENT;
+	if (fd->entrylength != sizeof(hfs_extent_rec))
+		return -EIO;
+	hfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfs_extent_rec));
 	return 0;
 }
 
-/*
- * hfs_extent_out()
- *
- * Copy the first extent record from a (struct hfs_fork) to a (struct
- * raw_extent), record (normally the one in the catalog entry).
- */
-void hfs_extent_out(const struct hfs_fork *fork, hfs_byte_t dummy[12])
+static inline int __hfs_ext_cache_extent(struct hfs_find_data *fd, struct inode *inode, u32 block)
 {
-	struct hfs_raw_extent *ext = (struct hfs_raw_extent *)dummy;
+	int res;
+
+	if (HFS_I(inode)->flags & HFS_FLG_EXT_DIRTY)
+		__hfs_ext_write_extent(inode, fd);
 
-	if (fork && ext) {
-		write_extent(ext, &fork->first);
-		dump_ext("extent out: ", &fork->first);
+	res = __hfs_ext_read_extent(fd, HFS_I(inode)->cached_extents, inode->i_ino,
+				    block, HFS_IS_RSRC(inode) ? HFS_FK_RSRC : HFS_FK_DATA);
+	if (!res) {
+		HFS_I(inode)->cached_start = be16_to_cpu(fd->key->ext.FABN);
+		HFS_I(inode)->cached_blocks = hfs_ext_block_count(HFS_I(inode)->cached_extents);
+	} else {
+		HFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;
+		HFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);
 	}
+	return res;
 }
 
-/*
- * hfs_extent_in()
- *
- * Copy an raw_extent to the 'first' and 'cache' fields of an hfs_fork.
- */
-void hfs_extent_in(struct hfs_fork *fork, const hfs_byte_t dummy[12])
+static int hfs_ext_read_extent(struct inode *inode, u16 block)
 {
-	const struct hfs_raw_extent *ext =
-		(const struct hfs_raw_extent *)dummy;
+	struct hfs_find_data fd;
+	int res;
+
+	if (block >= HFS_I(inode)->cached_start &&
+	    block < HFS_I(inode)->cached_start + HFS_I(inode)->cached_blocks)
+		return 0;
 
-	if (fork && ext) {
-		read_extent(&fork->first, ext, 0);
-		fork->cache = &fork->first;
-		fork->first.count = 2;
-		dump_ext("extent in: ", &fork->first);
+	hfs_find_init(HFS_SB(inode->i_sb)->ext_tree, &fd);
+	res = __hfs_ext_cache_extent(&fd, inode, block);
+	hfs_find_exit(&fd);
+	return res;
+}
+
+static void hfs_dump_extent(struct hfs_extent *extent)
+{
+	int i;
+
+	dprint(DBG_EXTENT, "   ");
+	for (i = 0; i < 3; i++)
+		dprint(DBG_EXTENT, " %u:%u", be16_to_cpu(extent[i].block),
+				 be16_to_cpu(extent[i].count));
+	dprint(DBG_EXTENT, "\n");
+}
+
+static int hfs_add_extent(struct hfs_extent *extent, u16 offset,
+			  u16 alloc_block, u16 block_count)
+{
+	u16 count, start;
+	int i;
+
+	hfs_dump_extent(extent);
+	for (i = 0; i < 3; extent++, i++) {
+		count = be16_to_cpu(extent->count);
+		if (offset == count) {
+			start = be16_to_cpu(extent->block);
+			if (alloc_block != start + count) {
+				if (++i >= 3)
+					return -ENOSPC;
+				extent++;
+				extent->block = cpu_to_be16(alloc_block);
+			} else
+				block_count += count;
+			extent->count = cpu_to_be16(block_count);
+			return 0;
+		} else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+}
+
+int hfs_free_extents(struct super_block *sb, struct hfs_extent *extent,
+		     u16 offset, u16 block_nr)
+{
+	u16 count, start;
+	int i;
+
+	hfs_dump_extent(extent);
+	for (i = 0; i < 3; extent++, i++) {
+		count = be16_to_cpu(extent->count);
+		if (offset == count)
+			goto found;
+		else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+found:
+	for (;;) {
+		start = be16_to_cpu(extent->block);
+		if (count <= block_nr) {
+			hfs_clear_vbm_bits(sb, start, count);
+			extent->block = 0;
+			extent->count = 0;
+			block_nr -= count;
+		} else {
+			count -= block_nr;
+			hfs_clear_vbm_bits(sb, start + count, block_nr);
+			extent->count = cpu_to_be16(count);
+			block_nr = 0;
+		}
+		if (!block_nr || !i)
+			return 0;
+		i--;
+		extent--;
+		count = be16_to_cpu(extent->count);
 	}
 }
 
-/* 
- * hfs_extent_free()
- *
- * Removes from memory all extents associated with 'fil'.
- */
-void hfs_extent_free(struct hfs_fork *fork)
+int hfs_free_fork(struct super_block *sb, struct hfs_cat_file *file, int type)
 {
-	if (fork) {
-		set_cache(fork, &fork->first);
+	struct hfs_find_data fd;
+	u32 total_blocks, blocks, start;
+	u32 cnid = be32_to_cpu(file->FlNum);
+	struct hfs_extent *extent;
+	int res, i;
 
-	        if (fork->first.next) {
-		        hfs_warn("hfs_extent_free: extents in use!\n");
+	if (type == HFS_FK_DATA) {
+		total_blocks = file->PyLen;
+		extent = file->ExtRec;
+	} else {
+		total_blocks = file->RPyLen;
+		extent = file->RExtRec;
+	}
+	total_blocks = be32_to_cpu(total_blocks) / HFS_SB(sb)->alloc_blksz;
+	if (!total_blocks)
+		return 0;
+
+	blocks = 0;
+	for (i = 0; i < 3; extent++, i++)
+		blocks += be16_to_cpu(extent[i].count);
+
+	res = hfs_free_extents(sb, extent, blocks, blocks);
+	if (res)
+		return res;
+	if (total_blocks == blocks)
+		return 0;
+
+	hfs_find_init(HFS_SB(sb)->ext_tree, &fd);
+	do {
+		res = __hfs_ext_read_extent(&fd, extent, cnid, total_blocks, type);
+		if (res)
+			break;
+		start = be16_to_cpu(fd.key->ext.FABN);
+		hfs_free_extents(sb, extent, total_blocks - start, total_blocks);
+		hfs_brec_remove(&fd);
+		total_blocks = start;
+	} while (total_blocks > blocks);
+	hfs_find_exit(&fd);
+
+	return res;
+}
+
+/*
+ * hfs_get_block
+ */
+int hfs_get_block(struct inode *inode, sector_t block,
+		  struct buffer_head *bh_result, int create)
+{
+	struct super_block *sb;
+	u16 dblock, ablock;
+	int res;
+
+	sb = inode->i_sb;
+	/* Convert inode block to disk allocation block */
+	ablock = (u32)block / HFS_SB(sb)->fs_div;
+
+	if (block >= inode->i_blocks) {
+		if (block > inode->i_blocks || !create)
+			return -EIO;
+		if (ablock >= HFS_I(inode)->alloc_blocks) {
+			res = hfs_extend_file(inode);
+			if (res)
+				return res;
+		}
+	} else
+		create = 0;
+
+	if (ablock < HFS_I(inode)->first_blocks) {
+		dblock = hfs_ext_find_block(HFS_I(inode)->first_extents, ablock);
+		goto done;
+	}
+
+	down(&HFS_I(inode)->extents_lock);
+	res = hfs_ext_read_extent(inode, ablock);
+	if (!res)
+		dblock = hfs_ext_find_block(HFS_I(inode)->cached_extents,
+					    ablock - HFS_I(inode)->cached_start);
+	else {
+		up(&HFS_I(inode)->extents_lock);
+		return -EIO;
+	}
+	up(&HFS_I(inode)->extents_lock);
+
+done:
+	map_bh(bh_result, sb, HFS_SB(sb)->fs_start +
+	       dblock * HFS_SB(sb)->fs_div +
+	       (u32)block % HFS_SB(sb)->fs_div);
+
+	if (create) {
+		set_buffer_new(bh_result);
+		HFS_I(inode)->phys_size += sb->s_blocksize;
+		inode->i_blocks++;
+		mark_inode_dirty(inode);
+	}
+	return 0;
+}
+
+int hfs_extend_file(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	u32 start, len, goal;
+	int res;
+
+	down(&HFS_I(inode)->extents_lock);
+	if (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks)
+		goal = hfs_ext_lastblock(HFS_I(inode)->first_extents);
+	else {
+		res = hfs_ext_read_extent(inode, HFS_I(inode)->alloc_blocks);
+		if (res)
+			goto out;
+		goal = hfs_ext_lastblock(HFS_I(inode)->cached_extents);
+	}
+
+	len = HFS_I(inode)->clump_blocks;
+	start = hfs_vbm_search_free(sb, goal, &len);
+	if (!len) {
+		res = -ENOSPC;
+		goto out;
+	}
+
+	dprint(DBG_EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);
+	if (HFS_I(inode)->alloc_blocks == HFS_I(inode)->first_blocks) {
+		if (!HFS_I(inode)->first_blocks) {
+			dprint(DBG_EXTENT, "first extents\n");
+			/* no extents yet */
+			HFS_I(inode)->first_extents[0].block = cpu_to_be16(start);
+			HFS_I(inode)->first_extents[0].count = cpu_to_be16(len);
+			res = 0;
+		} else {
+			/* try to append to extents in inode */
+			res = hfs_add_extent(HFS_I(inode)->first_extents,
+					     HFS_I(inode)->alloc_blocks,
+					     start, len);
+			if (res == -ENOSPC)
+				goto insert_extent;
+		}
+		if (!res) {
+			hfs_dump_extent(HFS_I(inode)->first_extents);
+			HFS_I(inode)->first_blocks += len;
 		}
+	} else {
+		res = hfs_add_extent(HFS_I(inode)->cached_extents,
+				     HFS_I(inode)->alloc_blocks -
+				     HFS_I(inode)->cached_start,
+				     start, len);
+		if (!res) {
+			hfs_dump_extent(HFS_I(inode)->cached_extents);
+			HFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;
+			HFS_I(inode)->cached_blocks += len;
+		} else if (res == -ENOSPC)
+			goto insert_extent;
+	}
+out:
+	up(&HFS_I(inode)->extents_lock);
+	if (!res) {
+		HFS_I(inode)->alloc_blocks += len;
+		mark_inode_dirty(inode);
+		if (inode->i_ino < HFS_FIRSTUSER_CNID)
+			set_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags);
+		set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
+		sb->s_dirt = 1;
+	}
+	return res;
+
+insert_extent:
+	dprint(DBG_EXTENT, "insert new extent\n");
+	hfs_ext_write_extent(inode);
+
+	memset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));
+	HFS_I(inode)->cached_extents[0].block = cpu_to_be16(start);
+	HFS_I(inode)->cached_extents[0].count = cpu_to_be16(len);
+	hfs_dump_extent(HFS_I(inode)->cached_extents);
+	HFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW;
+	HFS_I(inode)->cached_start = HFS_I(inode)->alloc_blocks;
+	HFS_I(inode)->cached_blocks = len;
+
+	res = 0;
+	goto out;
+}
+
+void hfs_file_truncate(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct hfs_find_data fd;
+	u16 blk_cnt, alloc_cnt, start;
+	u32 size;
+	int res;
+
+	dprint(DBG_INODE, "truncate: %lu, %Lu -> %Lu\n", inode->i_ino,
+	       (long long)HFS_I(inode)->phys_size, inode->i_size);
+	if (inode->i_size > HFS_I(inode)->phys_size) {
+		struct address_space *mapping = inode->i_mapping;
+		struct page *page;
+		int res;
+
+		size = inode->i_size - 1;
+		page = grab_cache_page(mapping, size >> PAGE_CACHE_SHIFT);
+		if (!page)
+			return;
+		size &= PAGE_CACHE_SIZE - 1;
+		size++;
+		res = mapping->a_ops->prepare_write(NULL, page, size, size);
+		if (!res)
+			res = mapping->a_ops->commit_write(NULL, page, size, size);
+		if (res)
+			inode->i_size = HFS_I(inode)->phys_size;
+		unlock_page(page);
+		page_cache_release(page);
+		mark_inode_dirty(inode);
+		return;
 	}
+	size = inode->i_size + HFS_SB(sb)->alloc_blksz - 1;
+	blk_cnt = size / HFS_SB(sb)->alloc_blksz;
+	alloc_cnt = HFS_I(inode)->alloc_blocks;
+	if (blk_cnt == alloc_cnt)
+		goto out;
+
+	down(&HFS_I(inode)->extents_lock);
+	hfs_find_init(HFS_SB(sb)->ext_tree, &fd);
+	while (1) {
+		if (alloc_cnt == HFS_I(inode)->first_blocks) {
+			hfs_free_extents(sb, HFS_I(inode)->first_extents,
+					 alloc_cnt, alloc_cnt - blk_cnt);
+			hfs_dump_extent(HFS_I(inode)->first_extents);
+			HFS_I(inode)->first_blocks = blk_cnt;
+			break;
+		}
+		res = __hfs_ext_cache_extent(&fd, inode, alloc_cnt);
+		if (res)
+			break;
+		start = HFS_I(inode)->cached_start;
+		hfs_free_extents(sb, HFS_I(inode)->cached_extents,
+				 alloc_cnt - start, alloc_cnt - blk_cnt);
+		hfs_dump_extent(HFS_I(inode)->cached_extents);
+		if (blk_cnt > start) {
+			HFS_I(inode)->flags |= HFS_FLG_EXT_DIRTY;
+			break;
+		}
+		alloc_cnt = start;
+		HFS_I(inode)->cached_start = HFS_I(inode)->cached_blocks = 0;
+		HFS_I(inode)->flags &= ~(HFS_FLG_EXT_DIRTY|HFS_FLG_EXT_NEW);
+		hfs_brec_remove(&fd);
+	}
+	hfs_find_exit(&fd);
+	up(&HFS_I(inode)->extents_lock);
+
+	HFS_I(inode)->alloc_blocks = blk_cnt;
+out:
+	HFS_I(inode)->phys_size = inode->i_size;
+	mark_inode_dirty(inode);
+	inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/file.c linuxppc-2.5-benh/fs/hfs/file.c
--- /dev/shm/linux-2.5/fs/hfs/file.c	2003-09-29 01:12:49.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/file.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,527 +0,0 @@
-/*
- * linux/fs/hfs/file.c
- *
- * Copyright (C) 1995, 1996  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the file-related functions which are independent of
- * which scheme is being used to represent forks.
- *
- * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/buffer_head.h>
-#include <linux/smp_lock.h>
-
-/*================ Forward declarations ================*/
-
-static hfs_rwret_t hfs_file_read(struct file *, char __user *, hfs_rwarg_t,
-				 loff_t *);
-static hfs_rwret_t hfs_file_write(struct file *, const char __user *,
-				  hfs_rwarg_t, loff_t *);
-static void hfs_file_truncate(struct inode *);
-
-/*================ Global variables ================*/
-
-struct file_operations hfs_file_operations = {
-	.llseek		= generic_file_llseek,
-	.read		= hfs_file_read,
-	.write		= hfs_file_write,
-	.mmap		= generic_file_mmap,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_file_inode_operations = {
-	.truncate	= hfs_file_truncate,
-	.setattr	= hfs_notify_change,
-};
-
-/*================ Variable-like macros ================*/
-
-/* maximum number of blocks to try to read in at once */
-#define NBUF 32
-
-/*================ File-local functions ================*/
-
-/*
- * hfs_getblk()
- *
- * Given an hfs_fork and a block number return the buffer_head for
- * that block from the fork.  If 'create' is non-zero then allocate
- * the necessary block(s) to the fork.
- */
-struct buffer_head *hfs_getblk(struct hfs_fork *fork, int block, int create)
-{
-	int tmp;
-	struct super_block *sb = fork->entry->mdb->sys_mdb;
-
-	tmp = hfs_extent_map(fork, block, create);
-
-	if (create) {
-		/* If writing the block, then we have exclusive access
-		   to the file until we return, so it can't have moved.
-		*/
-		if (tmp) {
-			hfs_cat_mark_dirty(fork->entry);
-			return sb_getblk(sb, tmp);
-		}
-		return NULL;
-	} else {
-		/* If reading the block, then retry since the
-		   location on disk could have changed while
-		   we waited on the I/O in getblk to complete.
-		*/
-		do {
-			struct buffer_head *bh = sb_getblk(sb, tmp);
-			int tmp2 = hfs_extent_map(fork, block, 0);
-
-			if (tmp2 == tmp) {
-				return bh;
-			} else {
-				/* The block moved or no longer exists. */
-				brelse(bh);
-				tmp = tmp2;
-			}
-		} while (tmp != 0);
-
-		/* The block no longer exists. */
-		return NULL;
-	}
-}
-
-/*
- * hfs_get_block
- *
- * This is the hfs_get_block() field in the inode_operations structure for
- * "regular" (non-header) files.  The purpose is to translate an inode
- * and a block number within the corresponding file into a physical
- * block number.  This function just calls hfs_extent_map() to do the
- * real work and then stuffs the appropriate info into the buffer_head.
- */
-int hfs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)
-{
-	unsigned long phys;
-
-	phys = hfs_extent_map(HFS_I(inode)->fork, iblock, create);
-	if (phys) {
-		if (create)
-			set_buffer_new(bh_result);
-		map_bh(bh_result, inode->i_sb, phys);
-		return 0;
-	}
-
-	if (!create)
-		return 0;
-
-	/* we tried to add stuff, but we couldn't. send back an out-of-space
-	 * error. */
-	return -ENOSPC;
-}
-
-
-/*
- * hfs_file_read()
- *
- * This is the read field in the inode_operations structure for
- * "regular" (non-header) files.  The purpose is to transfer up to
- * 'count' bytes from the file corresponding to 'inode', beginning at
- * 'filp->offset' bytes into the file.	The data is transferred to
- * user-space at the address 'buf'.  Returns the number of bytes
- * successfully transferred.  This function checks the arguments, does
- * some setup and then calls hfs_do_read() to do the actual transfer.  */
-static hfs_rwret_t hfs_file_read(struct file *filp, char __user *buf, 
-				 hfs_rwarg_t count, loff_t *ppos)
-{
-        struct inode *inode = filp->f_dentry->d_inode;
-	hfs_s32 read, left, pos, size;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_file_read: mode = %07o\n",inode->i_mode);
-		return -EINVAL;
-	}
-	pos = *ppos;
-	if (pos >= HFS_FORK_MAX) {
-		return 0;
-	}
-	size = inode->i_size;
-	if (pos > size) {
-		left = 0;
-	} else {
-		left = size - pos;
-	}
-	if (left > count) {
-		left = count;
-	}
-	if (left <= 0) {
-		return 0;
-	}
-	if ((read = hfs_do_read(inode, HFS_I(inode)->fork, pos, buf, left)) > 0) {
-	        *ppos += read;
-	}
-
-	return read;
-}
-
-/*
- * hfs_file_write()
- *
- * This is the write() entry in the file_operations structure for
- * "regular" files.  The purpose is to transfer up to 'count' bytes
- * to the file corresponding to 'inode' beginning at offset
- * 'file->f_pos' from user-space at the address 'buf'.  The return
- * value is the number of bytes actually transferred.
- */
-static hfs_rwret_t hfs_file_write(struct file *filp, const char __user *buf,
-				  hfs_rwarg_t count, loff_t *ppos)
-{
-        struct inode    *inode = filp->f_dentry->d_inode;
-	struct hfs_fork *fork = HFS_I(inode)->fork;
-	hfs_s32 written, pos;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_file_write: mode = %07o\n", inode->i_mode);
-		return -EINVAL;
-	}
-
-	pos = (filp->f_flags & O_APPEND) ? inode->i_size : *ppos;
-
-	if (pos >= HFS_FORK_MAX) {
-		return 0;
-	}
-	if (count > HFS_FORK_MAX) {
-		count = HFS_FORK_MAX;
-	}
-	if ((written = hfs_do_write(inode, fork, pos, buf, count)) > 0)
-	        pos += written;
-
-	*ppos = pos;
-	if (*ppos > inode->i_size) {
-	        inode->i_size = *ppos;
-		mark_inode_dirty(inode);
-	}
-
-	return written;
-}
-
-/*
- * hfs_file_truncate()
- *
- * This is the truncate() entry in the file_operations structure for
- * "regular" files.  The purpose is to change the length of the file
- * corresponding to the given inode.  Changes can either lengthen or
- * shorten the file.
- */
-static void hfs_file_truncate(struct inode * inode)
-{
-	struct hfs_fork *fork;
-
-	lock_kernel();
-	fork = HFS_I(inode)->fork;
-	fork->lsize = inode->i_size;
-	hfs_extent_adj(fork);
-	hfs_cat_mark_dirty(HFS_I(inode)->entry);
-
-	inode->i_size = fork->lsize;
-	inode->i_blocks = fork->psize;
-	mark_inode_dirty(inode);
-	unlock_kernel();
-}
-
-/*
- * xlate_to_user()
- *
- * Like copy_to_user() while translating CR->NL.
- */
-static inline void xlate_to_user(char __user *buf, const char *data, int count)
-{
-	char ch;
-
-	while (count--) {
-		ch = *(data++);
-		put_user((ch == '\r') ? '\n' : ch, buf++);
-	}
-}
-
-/*
- * xlate_from_user()
- *
- * Like copy_from_user() while translating NL->CR;
- */
-static inline
-int xlate_from_user(char *data, const char __user *buf, int count)
-{
-	int i;
-
-	i = copy_from_user(data, buf, count);
-	count -= i;
-	while (count--) {
-		if (*data == '\n') {
-			*data = '\r';
-		}
-		++data;
-	}
-	return i;
-}
-
-/*================ Global functions ================*/
-
-/*
- * hfs_do_read()
- *
- * This function transfers actual data from disk to user-space memory,
- * returning the number of bytes successfully transferred.  'fork' tells
- * which file on the disk to read from.  'pos' gives the offset into
- * the Linux file at which to begin the transfer.  Note that this will
- * differ from 'filp->offset' in the case of an AppleDouble header file
- * due to the block of metadata at the beginning of the file, which has
- * no corresponding place in the HFS file.  'count' tells how many
- * bytes to transfer.  'buf' gives an address in user-space to transfer
- * the data to.
- * 
- * This is based on Linus's minix_file_read().
- * It has been changed to take into account that HFS files have no holes.
- */
-hfs_s32 hfs_do_read(struct inode *inode, struct hfs_fork *fork, hfs_u32 pos,
-		    char __user *buf, hfs_u32 count)
-{
-	hfs_s32 size, chars, offset, block, blocks, read = 0;
-	int bhrequest, uptodate;
-	int convert = HFS_I(inode)->convert;
-	struct buffer_head ** bhb, ** bhe;
-	struct buffer_head * bhreq[NBUF];
-	struct buffer_head * buflist[NBUF];
-
-	/* split 'pos' in to block and (byte) offset components */
-	block = pos >> HFS_SECTOR_SIZE_BITS;
-	offset = pos & (HFS_SECTOR_SIZE-1);
-
-	/* compute the logical size of the fork in blocks */
-	size = (fork->lsize + (HFS_SECTOR_SIZE-1)) >> HFS_SECTOR_SIZE_BITS;
-
-	/* compute the number of physical blocks to be transferred */
-	blocks = (count+offset+HFS_SECTOR_SIZE-1) >> HFS_SECTOR_SIZE_BITS;
-
-	bhb = bhe = buflist;
-
-	/* We do this in a two stage process.  We first try and
-	   request as many blocks as we can, then we wait for the
-	   first one to complete, and then we try and wrap up as many
-	   as are actually done.
-	   
-	   This routine is optimized to make maximum use of the
-	   various buffers and caches. */
-
-	do {
-		bhrequest = 0;
-		uptodate = 1;
-		while (blocks) {
-			--blocks;
-			*bhb = hfs_getblk(fork, block++, 0);
-
-			if (!(*bhb)) {
-				/* Since there are no holes in HFS files
-				   we must have encountered an error.
-				   So, stop adding blocks to the queue. */
-				blocks = 0;
-				break;
-			}
-
-			if (!buffer_uptodate(*bhb)) {
-				uptodate = 0;
-				bhreq[bhrequest++] = *bhb;
-			}
-
-			if (++bhb == &buflist[NBUF]) {
-				bhb = buflist;
-			}
-
-			/* If the block we have on hand is uptodate,
-			   go ahead and complete processing. */
-			if (uptodate) {
-				break;
-			}
-			if (bhb == bhe) {
-				break;
-			}
-		}
-
-		/* If the only block in the queue is bad then quit */
-		if (!(*bhe)) {
-			break;
-		}
-
-		/* Now request them all */
-		if (bhrequest) {
-			ll_rw_block(READ, bhrequest, bhreq);
-		}
-
-		do {  /* Finish off all I/O that has actually completed */
-			char *p;
-
-			wait_on_buffer(*bhe);
-
-			if (!buffer_uptodate(*bhe)) {
-				/* read error? */
-				brelse(*bhe);
-				if (++bhe == &buflist[NBUF]) {
-					bhe = buflist;
-				}
-				count = 0;
-				break;
-			}
-
-			if (count < HFS_SECTOR_SIZE - offset) {
-				chars = count;
-			} else {
-				chars = HFS_SECTOR_SIZE - offset;
-			}
-			p = (*bhe)->b_data + offset;
-			if (convert) {
-				xlate_to_user(buf, p, chars);
-			} else {
-				chars -= copy_to_user(buf, p, chars);
-				if (!chars) {
-					brelse(*bhe);
-					count = 0;
-					if (!read)
-						read = -EFAULT;
-					break;
-				}
-			}
-			brelse(*bhe);
-			count -= chars;
-			buf += chars;
-			read += chars;
-			offset = 0;
-			if (++bhe == &buflist[NBUF]) {
-				bhe = buflist;
-			}
-		} while (count && (bhe != bhb) && !buffer_locked(*bhe));
-	} while (count);
-
-	/* Release the read-ahead blocks */
-	while (bhe != bhb) {
-		brelse(*bhe);
-		if (++bhe == &buflist[NBUF]) {
-			bhe = buflist;
-		}
-	}
-	if (!read) {
-		return -EIO;
-	}
-	return read;
-}
- 
-/*
- * hfs_do_write()
- *
- * This function transfers actual data from user-space memory to disk,
- * returning the number of bytes successfully transferred.  'fork' tells
- * which file on the disk to write to.  'pos' gives the offset into
- * the Linux file at which to begin the transfer.  Note that this will
- * differ from 'filp->offset' in the case of an AppleDouble header file
- * due to the block of metadata at the beginning of the file, which has
- * no corresponding place in the HFS file.  'count' tells how many
- * bytes to transfer.  'buf' gives an address in user-space to transfer
- * the data from.
- * 
- * This is just a minor edit of Linus's minix_file_write().
- */
-hfs_s32 hfs_do_write(struct inode *inode, struct hfs_fork *fork, hfs_u32 pos,
-		     const char __user *buf, hfs_u32 count)
-{
-	hfs_s32 written, c;
-	struct buffer_head * bh;
-	char * p;
-	int convert = HFS_I(inode)->convert;
-
-	written = 0;
-	while (written < count) {
-		bh = hfs_getblk(fork, pos/HFS_SECTOR_SIZE, 1);
-		if (!bh) {
-			if (!written) {
-				written = -ENOSPC;
-			}
-			break;
-		}
-		c = HFS_SECTOR_SIZE - (pos % HFS_SECTOR_SIZE);
-		if (c > count - written) {
-			c = count - written;
-		}
-		if (c != HFS_SECTOR_SIZE && !buffer_uptodate(bh)) {
-			ll_rw_block(READ, 1, &bh);
-			wait_on_buffer(bh);
-			if (!buffer_uptodate(bh)) {
-				brelse(bh);
-				if (!written) {
-					written = -EIO;
-				}
-				break;
-			}
-		}
-		p = (pos % HFS_SECTOR_SIZE) + bh->b_data;
-		c -= convert ? xlate_from_user(p, buf, c) :
-			copy_from_user(p, buf, c);
-		if (!c) {
-			brelse(bh);
-			if (!written)
-				written = -EFAULT;
-			break;
-		}
-		pos += c;
-		written += c;
-		buf += c;
-		set_buffer_uptodate(bh);
-		mark_buffer_dirty(bh);
-		brelse(bh);
-	}
-	if (written > 0) {
-		struct hfs_cat_entry *entry = fork->entry;
-
-		inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-		if (pos > fork->lsize) {
-			fork->lsize = pos;
-		}
-		entry->modify_date = hfs_u_to_mtime(get_seconds());
-		hfs_cat_mark_dirty(entry);
-	}
-	return written;
-}
-
-/*
- * hfs_file_fix_mode()
- *
- * Fixes up the permissions on a file after changing the write-inhibit bit.
- */
-void hfs_file_fix_mode(struct hfs_cat_entry *entry)
-{
-	struct dentry **de = entry->sys_entry;
-	int i;
-
-	if (entry->u.file.flags & HFS_FIL_LOCK) {
-		for (i = 0; i < 4; ++i) {
-			if (de[i]) {
-				de[i]->d_inode->i_mode &= ~S_IWUGO;
-			}
-		}
-	} else {
-		for (i = 0; i < 4; ++i) {
-			if (de[i]) {
-			        struct inode *inode = de[i]->d_inode;
-				inode->i_mode |= S_IWUGO;
-				inode->i_mode &= 
-				  ~HFS_SB(inode->i_sb)->s_umask;
-			}
-		}
-	}
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/file_cap.c linuxppc-2.5-benh/fs/hfs/file_cap.c
--- /dev/shm/linux-2.5/fs/hfs/file_cap.c	2003-09-29 01:12:49.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/file_cap.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,280 +0,0 @@
-/*
- * linux/fs/hfs/file_cap.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the file_ops and inode_ops for the metadata
- * files under the CAP representation.
- *
- * The source code distribution of the Columbia AppleTalk Package for
- * UNIX, version 6.0, (CAP) was used as a specification of the
- * location and format of files used by CAP's Aufs.  No code from CAP
- * appears in hfs_fs.  hfs_fs is not a work ``derived'' from CAP in
- * the sense of intellectual property law.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/*================ Forward declarations ================*/
-static loff_t      cap_info_llseek(struct file *, loff_t,
-                                   int);
-static hfs_rwret_t cap_info_read(struct file *, char __user *,
-				 hfs_rwarg_t, loff_t *);
-static hfs_rwret_t cap_info_write(struct file *, const char __user *,
-				  hfs_rwarg_t, loff_t *);
-/*================ Function-like macros ================*/
-
-/*
- * OVERLAPS()
- *
- * Determines if a given range overlaps the specified structure member
- */
-#define OVERLAPS(START, END, TYPE, MEMB) \
-	((END > offsetof(TYPE, MEMB)) && \
-	 (START < offsetof(TYPE, MEMB) + sizeof(((TYPE *)0)->MEMB)))
-
-/*================ Global variables ================*/
-
-struct file_operations hfs_cap_info_operations = {
-	.llseek		= cap_info_llseek,
-	.read		= cap_info_read,
-	.write		= cap_info_write,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_cap_info_inode_operations = {
-	.setattr	= hfs_notify_change_cap,
-};
-
-/*================ File-local functions ================*/
-
-/*
- * cap_build_meta()
- *
- * Build the metadata structure.
- */
-static void cap_build_meta(struct hfs_cap_info *meta,
-			   struct hfs_cat_entry *entry)
-{
-	memset(meta, 0, sizeof(*meta));
-	memcpy(meta->fi_fndr, &entry->info, 32);
-	if ((entry->type == HFS_CDR_FIL) &&
-	    (entry->u.file.flags & HFS_FIL_LOCK)) {
-		/* Couple the locked bit of the file to the
-		   AFP {write,rename,delete} inhibit bits. */
-		hfs_put_hs(HFS_AFP_RDONLY, meta->fi_attr);
-	}
-	meta->fi_magic1 = HFS_CAP_MAGIC1;
-	meta->fi_version = HFS_CAP_VERSION;
-	meta->fi_magic = HFS_CAP_MAGIC;
-	meta->fi_bitmap = HFS_CAP_LONGNAME;
-	memcpy(meta->fi_macfilename, entry->key.CName.Name,
-	       entry->key.CName.Len);
-	meta->fi_datemagic = HFS_CAP_DMAGIC;
-	meta->fi_datevalid = HFS_CAP_MDATE | HFS_CAP_CDATE;
-	hfs_put_nl(hfs_m_to_htime(entry->create_date), meta->fi_ctime);
-	hfs_put_nl(hfs_m_to_htime(entry->modify_date), meta->fi_mtime);
-	hfs_put_nl(get_seconds(),                       meta->fi_utime);
-}
-
-static loff_t cap_info_llseek(struct file *file, loff_t offset, int origin)
-{
-	long long retval;
-
-	lock_kernel();
-
-	switch (origin) {
-		case 2:
-			offset += file->f_dentry->d_inode->i_size;
-			break;
-		case 1:
-			offset += file->f_pos;
-	}
-	retval = -EINVAL;
-	if (offset>=0 && offset<=HFS_FORK_MAX) {
-		if (offset != file->f_pos) {
-			file->f_pos = offset;
-		}
-		retval = offset;
-	}
-	unlock_kernel();
-	return retval;
-}
-
-/*
- * cap_info_read()
- *
- * This is the read() entry in the file_operations structure for CAP
- * metadata files.  The purpose is to transfer up to 'count' bytes
- * from the file corresponding to 'inode' beginning at offset
- * 'file->f_pos' to user-space at the address 'buf'.  The return value
- * is the number of bytes actually transferred.
- */
-static hfs_rwret_t cap_info_read(struct file *filp, char __user *buf,
-				 hfs_rwarg_t count, loff_t *ppos)
-{
-	struct inode *inode = filp->f_dentry->d_inode;
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-	hfs_s32 left, size, read = 0;
-	hfs_u32 pos;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_cap_info_read: mode = %07o\n", inode->i_mode);
-		return -EINVAL;
-	}
-
-	pos = *ppos;
-	if (pos > HFS_FORK_MAX) {
-		return 0;
-	}
-	size = inode->i_size;
-	if (pos > size) {
-		left = 0;
-	} else {
-		left = size - pos;
-	}
-	if (left > count) {
-		left = count;
-	}
-	if (left <= 0) {
-		return 0;
-	}
-
-	if (pos < sizeof(struct hfs_cap_info)) {
-		int memcount = sizeof(struct hfs_cap_info) - pos;
-		struct hfs_cap_info meta;
-
-		if (memcount > left) {
-			memcount = left;
-		}
-		cap_build_meta(&meta, entry);
-		memcount -= copy_to_user(buf, ((char *)&meta) + pos, memcount);
-		left -= memcount;
-		read += memcount;
-		pos += memcount;
-		buf += memcount;
-	}
-
-	if (left > 0) {
-		clear_user(buf, left);
-	        pos += left;
-	}
-
-	if (read) {
-		inode->i_atime = CURRENT_TIME;
-		*ppos = pos;
-		mark_inode_dirty(inode);
-	}
-
-	return read;
-}
-
-/*
- * cap_info_write()
- *
- * This is the write() entry in the file_operations structure for CAP
- * metadata files.  The purpose is to transfer up to 'count' bytes
- * to the file corresponding to 'inode' beginning at offset
- * '*ppos' from user-space at the address 'buf'.
- * The return value is the number of bytes actually transferred.
- */
-static hfs_rwret_t cap_info_write(struct file *filp, const char __user *buf, 
-				  hfs_rwarg_t count, loff_t *ppos)
-{
-        struct inode *inode = filp->f_dentry->d_inode;
-	hfs_u32 pos;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_file_write: mode = %07o\n", inode->i_mode);
-		return -EINVAL;
-	}
-	if (count <= 0) {
-		return 0;
-	}
-	
-	pos = (filp->f_flags & O_APPEND) ? inode->i_size : *ppos;
-
-	if (pos > HFS_FORK_MAX) {
-		return 0;
-	}
-
-	*ppos += count;
-	if (*ppos > HFS_FORK_MAX) {
-		*ppos = HFS_FORK_MAX;
-		count = HFS_FORK_MAX - pos;
-	}
-
-	if (*ppos > inode->i_size)
-	        inode->i_size = *ppos;
-
-	/* Only deal with the part we store in memory */
-	if (pos < sizeof(struct hfs_cap_info)) {
-		int end, mem_count;
-		struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-		struct hfs_cap_info meta;
-
-		mem_count = sizeof(struct hfs_cap_info) - pos;
-		if (mem_count > count) {
-			mem_count = count;
-		}
-		end = pos + mem_count;
-
-		cap_build_meta(&meta, entry);
-		mem_count -= copy_from_user(((char *)&meta) + pos, buf, mem_count);
-
-		/* Update finder attributes if changed */
-		if (OVERLAPS(pos, end, struct hfs_cap_info, fi_fndr)) {
-			memcpy(&entry->info, meta.fi_fndr, 32);
-			hfs_cat_mark_dirty(entry);
-		}
-
-		/* Update file flags if changed */
-		if (OVERLAPS(pos, end, struct hfs_cap_info, fi_attr) &&
-		    (entry->type == HFS_CDR_FIL)) {
-			int locked = hfs_get_ns(&meta.fi_attr) &
-							htons(HFS_AFP_WRI);
-			hfs_u8 new_flags;
-
-			if (locked) {
-				new_flags = entry->u.file.flags | HFS_FIL_LOCK;
-			} else {
-				new_flags = entry->u.file.flags & ~HFS_FIL_LOCK;
-			}
-
-			if (new_flags != entry->u.file.flags) {
-				entry->u.file.flags = new_flags;
-				hfs_cat_mark_dirty(entry);
-				hfs_file_fix_mode(entry);
-			}
-		}
-
-		/* Update CrDat if changed */
-		if (OVERLAPS(pos, end, struct hfs_cap_info, fi_ctime)) {
-			entry->create_date =
-				hfs_h_to_mtime(hfs_get_nl(meta.fi_ctime));
-			hfs_cat_mark_dirty(entry);
-		}
-
-		/* Update MdDat if changed */
-		if (OVERLAPS(pos, end, struct hfs_cap_info, fi_mtime)) {
-			entry->modify_date =
-				hfs_h_to_mtime(hfs_get_nl(meta.fi_mtime));
-			hfs_cat_mark_dirty(entry);
-		}
-	}
-
-	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-	mark_inode_dirty(inode);
-	return count;
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/file_hdr.c linuxppc-2.5-benh/fs/hfs/file_hdr.c
--- /dev/shm/linux-2.5/fs/hfs/file_hdr.c	2004-02-04 05:29:22.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/file_hdr.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1033 +0,0 @@
-/*
- * linux/fs/hfs/file_hdr.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the file_ops and inode_ops for the metadata
- * files under the AppleDouble and Netatalk representations.
- *
- * The source code distributions of Netatalk, versions 1.3.3b2 and
- * 1.4b2, were used as a specification of the location and format of
- * files used by Netatalk's afpd.  No code from Netatalk appears in
- * hfs_fs.  hfs_fs is not a work ``derived'' from Netatalk in the
- * sense of intellectual property law.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- *
- * XXX: Note the reason that there is not bmap() for AppleDouble
- * header files is that dynamic nature of their structure make it
- * very difficult to safely mmap them.  Maybe in the distant future
- * I'll get bored enough to implement it.
- */
-
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-/* prodos types */
-#define PRODOSI_FTYPE_DIR   0x0F
-#define PRODOSI_FTYPE_TEXT  0x04
-#define PRODOSI_FTYPE_8BIT  0xFF
-#define PRODOSI_FTYPE_16BIT 0xB3
-
-#define PRODOSI_AUXTYPE_DIR 0x0200
-
-/*================ Forward declarations ================*/
-static loff_t      hdr_llseek(struct file *, loff_t, int);
-static hfs_rwret_t hdr_read(struct file *, char __user *,
-			    hfs_rwarg_t, loff_t *);
-static hfs_rwret_t hdr_write(struct file *, const char __user *,
-			     hfs_rwarg_t, loff_t *);
-/*================ Global variables ================*/
-
-struct file_operations hfs_hdr_operations = {
-	.llseek		= hdr_llseek,
-	.read		= hdr_read,
-	.write		= hdr_write,
-	.fsync		= file_fsync,
-};
-
-struct inode_operations hfs_hdr_inode_operations = {
-	.setattr	= hfs_notify_change_hdr,
-};
-
-const struct hfs_hdr_layout hfs_dbl_fil_hdr_layout = {
-	.magic		= __constant_htonl(HFS_DBL_MAGIC),	/* magic   */
-	.version	= __constant_htonl(HFS_HDR_VERSION_2),	/* version */
-	.entries	= 6,					/* entries */
-	{					/* descr[] */
-		{HFS_HDR_FNAME, offsetof(struct hfs_dbl_hdr, real_name),   ~0},
-		{HFS_HDR_DATES, offsetof(struct hfs_dbl_hdr, create_time), 16},
-		{HFS_HDR_FINFO, offsetof(struct hfs_dbl_hdr, finderinfo),  32},
-		{HFS_HDR_MACI,  offsetof(struct hfs_dbl_hdr, fileinfo),     4},
-		{HFS_HDR_DID,   offsetof(struct hfs_dbl_hdr, cnid),         4},
-		{HFS_HDR_RSRC,  HFS_DBL_HDR_LEN,                           ~0}
-	},
-	{					/* order[] */
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[0],
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[1],
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[2],
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[3],
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[4],
-		(struct hfs_hdr_descr *)&hfs_dbl_fil_hdr_layout.descr[5]
-	}
-};
-
-const struct hfs_hdr_layout hfs_dbl_dir_hdr_layout = {
-	.magic		= __constant_htonl(HFS_DBL_MAGIC),	/* magic   */
-	.version	= __constant_htonl(HFS_HDR_VERSION_2),	/* version */
-	.entries	= 5,					/* entries */
-	{					/* descr[] */
-		{HFS_HDR_FNAME, offsetof(struct hfs_dbl_hdr, real_name),   ~0},
-		{HFS_HDR_DATES, offsetof(struct hfs_dbl_hdr, create_time), 16},
-		{HFS_HDR_FINFO, offsetof(struct hfs_dbl_hdr, finderinfo),  32},
-		{HFS_HDR_MACI,  offsetof(struct hfs_dbl_hdr, fileinfo),     4},
-		{HFS_HDR_DID,   offsetof(struct hfs_dbl_hdr, cnid),         4}
-	},
-	{					/* order[] */
-		(struct hfs_hdr_descr *)&hfs_dbl_dir_hdr_layout.descr[0],
-		(struct hfs_hdr_descr *)&hfs_dbl_dir_hdr_layout.descr[1],
-		(struct hfs_hdr_descr *)&hfs_dbl_dir_hdr_layout.descr[2],
-		(struct hfs_hdr_descr *)&hfs_dbl_dir_hdr_layout.descr[3],
-		(struct hfs_hdr_descr *)&hfs_dbl_dir_hdr_layout.descr[4]
-	}
-};
-
-const struct hfs_hdr_layout hfs_nat2_hdr_layout = {
-	.magic		= __constant_htonl(HFS_DBL_MAGIC),	/* magic   */
-	.version	= __constant_htonl(HFS_HDR_VERSION_2),	/* version */
-	.entries	= 9,					/* entries */
-	{					/* descr[] */
-		{HFS_HDR_FNAME, offsetof(struct hfs_dbl_hdr, real_name),   ~0},
-		{HFS_HDR_COMNT, offsetof(struct hfs_dbl_hdr, comment),      0},
-		{HFS_HDR_DATES, offsetof(struct hfs_dbl_hdr, create_time), 16},
-		{HFS_HDR_FINFO, offsetof(struct hfs_dbl_hdr, finderinfo),  32},
-		{HFS_HDR_AFPI,  offsetof(struct hfs_dbl_hdr, fileinfo),     4},
-		{HFS_HDR_DID,   offsetof(struct hfs_dbl_hdr, cnid),         4},
-		{HFS_HDR_SNAME,  offsetof(struct hfs_dbl_hdr, short_name), ~0},
-		{HFS_HDR_PRODOSI,  offsetof(struct hfs_dbl_hdr, prodosi),   8},
-		{HFS_HDR_RSRC,  HFS_NAT_HDR_LEN,                           ~0}
-	},
-	{					/* order[] */
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[0],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[1],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[2],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[3],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[4],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[5],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[6],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[7],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[8]
-	}
-};
-
-const struct hfs_hdr_layout hfs_nat_hdr_layout = {
-	.magic		= __constant_htonl(HFS_DBL_MAGIC),	/* magic   */
-	.version	= __constant_htonl(HFS_HDR_VERSION_1),	/* version */
-	.entries	= 5,					/* entries */
-	{					/* descr[] */
-		{HFS_HDR_FNAME, offsetof(struct hfs_dbl_hdr, real_name),   ~0},
-		{HFS_HDR_COMNT, offsetof(struct hfs_dbl_hdr, comment),      0},
-		{HFS_HDR_OLDI,  offsetof(struct hfs_dbl_hdr, create_time), 16},
-		{HFS_HDR_FINFO, offsetof(struct hfs_dbl_hdr, finderinfo),  32},
-		{HFS_HDR_RSRC,  HFS_NAT_HDR_LEN,                           ~0},
-	},
-	{					/* order[] */
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[0],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[1],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[2],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[3],
-		(struct hfs_hdr_descr *)&hfs_nat_hdr_layout.descr[4]
-	}
-};
-
-/*================ File-local variables ================*/
-
-static const char fstype[16] =
-	{'M','a','c','i','n','t','o','s','h',' ',' ',' ',' ',' ',' ',' '};
-
-/*================ File-local data types ================*/
-
-struct hdr_hdr {
-        hfs_lword_t	magic;
-        hfs_lword_t	version;
-        hfs_byte_t	filler[16];
-        hfs_word_t	entries;
-        hfs_byte_t	descrs[12*HFS_HDR_MAX];
-}  __attribute__((packed));
-
-/*================ File-local functions ================*/
-
-/*
- * dlength()
- */
-static int dlength(const struct hfs_hdr_descr *descr,
-		   const struct hfs_cat_entry *entry)
-{
-	hfs_u32 length = descr->length;
-
-	/* handle auto-sized entries */
-	if (length == ~0) {
-		switch (descr->id) {
-		case HFS_HDR_DATA:
-			if (entry->type == HFS_CDR_FIL) {
-				length = entry->u.file.data_fork.lsize;
-			} else {
-				length = 0;
-			}
-			break;
-
-		case HFS_HDR_RSRC:
-			if (entry->type == HFS_CDR_FIL) {
-				length = entry->u.file.rsrc_fork.lsize;
-			} else {
-				length = 0;
-			}
-			break;
-
-		case HFS_HDR_FNAME:
-			length = entry->key.CName.Len;
-			break;
-
-		case HFS_HDR_SNAME:
-		default:
-			length = 0;
-		}
-	}
-	return length;
-}
-
-/*
- * hdr_build_meta()
- */
-static void hdr_build_meta(struct hdr_hdr *meta,
-			   const struct hfs_hdr_layout *layout,
-			   const struct hfs_cat_entry *entry)
-{
-	const struct hfs_hdr_descr *descr;
-	hfs_byte_t *ptr;
-	int lcv;
-
-	hfs_put_nl(layout->magic,   meta->magic);
-	hfs_put_nl(layout->version, meta->version);
-	if (layout->version == htonl(HFS_HDR_VERSION_1)) {
-		memcpy(meta->filler, fstype, 16);
-	} else {
-		memset(meta->filler, 0, 16);
-	}
-	hfs_put_hs(layout->entries, meta->entries);
-	memset(meta->descrs, 0, sizeof(meta->descrs));
-	for (lcv = 0, descr = layout->descr, ptr = meta->descrs;
-	     lcv < layout->entries; ++lcv, ++descr, ptr += 12) {
-		hfs_put_hl(descr->id,             ptr);
-		hfs_put_hl(descr->offset,         ptr + 4);
-		hfs_put_hl(dlength(descr, entry), ptr + 8);
-	}
-}
-
-/*
- * dup_layout ()
- */
-static struct hfs_hdr_layout *dup_layout(const struct hfs_hdr_layout *old)
-{
-	struct hfs_hdr_layout *new;
-	int lcv;
-
-	if (HFS_NEW(new)) {
-		memcpy(new, old, sizeof(*new));
-		for (lcv = 0; lcv < new->entries; ++lcv) {
-			new->order[lcv] = (struct hfs_hdr_descr *)
-			((char *)new->order[lcv] + ((char *)new - (char *)old));
-		}
-	}
-	return new;
-}
-
-/*
- * init_layout()
- */
-static inline void init_layout(struct hfs_hdr_layout *layout,
-			       const hfs_byte_t *descrs)
-{
-	struct hfs_hdr_descr **base, **p, **q, *tmp;
-	int lcv, entries = layout->entries;
-
-	for (lcv = 0; lcv < entries; ++lcv, descrs += 12) {
-		layout->order[lcv] = &layout->descr[lcv];
-		layout->descr[lcv].id     = hfs_get_hl(descrs);
-		layout->descr[lcv].offset = hfs_get_hl(descrs + 4);
-		layout->descr[lcv].length = hfs_get_hl(descrs + 8);
-	}
-	for (lcv = layout->entries; lcv < HFS_HDR_MAX; ++lcv) {
-		layout->order[lcv] = NULL;
-		layout->descr[lcv].id     = 0;
-		layout->descr[lcv].offset = 0;
-		layout->descr[lcv].length = 0;
-	}
-
-	/* Sort the 'order' array using an insertion sort */
-	base = &layout->order[0];
-	for (p = (base+1); p < (base+entries); ++p) {
-		q=p;
-		while ((*q)->offset < (*(q-1))->offset) {
-			tmp = *q;
-			*q = *(q-1);
-			*(--q) = tmp;
-			if (q == base) break;
-		}
-	}
-}
-
-/*
- * adjust_forks()
- */
-static inline void adjust_forks(struct hfs_cat_entry *entry,
-				const struct hfs_hdr_layout *layout)
-{
-	int lcv;
-
-	for (lcv = 0; lcv < layout->entries; ++lcv) {
-		const struct hfs_hdr_descr *descr = &layout->descr[lcv];
-
-		if ((descr->id == HFS_HDR_DATA) &&
-		    (descr->length != entry->u.file.data_fork.lsize)) {
-			entry->u.file.data_fork.lsize = descr->length;
-			hfs_extent_adj(&entry->u.file.data_fork);
-		} else if ((descr->id == HFS_HDR_RSRC) &&
-			   (descr->length != entry->u.file.rsrc_fork.lsize)) {
-			entry->u.file.rsrc_fork.lsize = descr->length;
-			hfs_extent_adj(&entry->u.file.rsrc_fork);
-		}
-	}
-}
-
-/*
- * get_dates()
- */
-static void get_dates(const struct hfs_cat_entry *entry,
-		      const struct inode *inode,  hfs_u32 dates[3])
-{
-	dates[0] = hfs_m_to_htime(entry->create_date);
-	dates[1] = hfs_m_to_htime(entry->modify_date);
-	dates[2] = hfs_m_to_htime(entry->backup_date);
-}
-
-/*
- * set_dates()
- */
-static void set_dates(struct hfs_cat_entry *entry, struct inode *inode,
-		      const hfs_u32 *dates)
-{
-	hfs_u32 tmp;
-
-	tmp = hfs_h_to_mtime(dates[0]);
-	if (entry->create_date != tmp) {
-		entry->create_date = tmp;
-		hfs_cat_mark_dirty(entry);
-	}
-	tmp = hfs_h_to_mtime(dates[1]);
-	if (entry->modify_date != tmp) {
-		entry->modify_date = tmp;
-		inode->i_ctime.tv_sec = inode->i_atime.tv_sec = inode->i_mtime.tv_sec = 
-			hfs_h_to_utime(dates[1]);
-		inode->i_ctime.tv_nsec = 0;
-		inode->i_mtime.tv_nsec = 0;
-		inode->i_atime.tv_nsec = 0;
-		hfs_cat_mark_dirty(entry);
-	}
-	tmp = hfs_h_to_mtime(dates[2]);
-	if (entry->backup_date != tmp) {
-		entry->backup_date = tmp;
-		hfs_cat_mark_dirty(entry);
-	}
-}
-
-loff_t hdr_llseek(struct file *file, loff_t offset, int origin)
-{
-	long long retval;
-
-	lock_kernel();
-
-	switch (origin) {
-		case 2:
-			offset += file->f_dentry->d_inode->i_size;
-			break;
-		case 1:
-			offset += file->f_pos;
-	}
-	retval = -EINVAL;
-	if (offset>=0 && offset<file->f_dentry->d_inode->i_size) {
-		if (offset != file->f_pos) {
-			file->f_pos = offset;
-		}
-		retval = offset;
-	}
-	unlock_kernel();
-	return retval;
-}
-
-/*
- * hdr_read()
- *
- * This is the read field in the inode_operations structure for
- * header files.  The purpose is to transfer up to 'count' bytes
- * from the file corresponding to 'inode', beginning at
- * 'filp->offset' bytes into the file.	The data is transferred to
- * user-space at the address 'buf'.  Returns the number of bytes
- * successfully transferred.
- */
-/* XXX: what about the entry count changing on us? */
-static hfs_rwret_t hdr_read(struct file *filp, char __user *buf, 
-			    hfs_rwarg_t count, loff_t *ppos)
-{
-	struct inode *inode = filp->f_dentry->d_inode;
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-	const struct hfs_hdr_layout *layout;
-	off_t start, length, offset;
-	off_t pos = *ppos;
-	int left, lcv, read = 0;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_hdr_read: mode = %07o\n",inode->i_mode);
-		return -EINVAL;
-	}
-
-	if (HFS_I(inode)->layout) {
-		layout = HFS_I(inode)->layout;
-	} else {
-		layout = HFS_I(inode)->default_layout;
-	}
-
-	/* Adjust count to fit within the bounds of the file */
-	if ((pos >= inode->i_size) || (count <= 0)) {
-		return 0;
-	} else if (count > inode->i_size - pos) {
-		count = inode->i_size - pos;
-	}
-
-	/* Handle the fixed-location portion */
-	length = sizeof(hfs_u32) + sizeof(hfs_u32) + 16 +
-		 sizeof(hfs_u16) + layout->entries * (3 * sizeof(hfs_u32));
-	if (pos < length) {
-		struct hdr_hdr meta;
-
-		left = length - pos;
-		if (left > count) {
-			left = count;
-		}
-
-		hdr_build_meta(&meta, layout, entry);
-		left -= copy_to_user(buf, ((char *)&meta) + pos, left);
-		count -= left;
-		read += left;
-		pos += left;
-		buf += left;
-	}
-	if (!count) {
-		goto done;
-	}
-
-	/* Handle the actual data */
-	for (lcv = 0; count && (lcv < layout->entries); ++lcv) {
-		const struct hfs_hdr_descr *descr = layout->order[lcv];
-		struct hfs_fork *fork;
-		char tmp[16], *p;
-		off_t limit;
-
-		/* stop reading if we run out of descriptors early */
-		if (!descr) {
-			break;
-		}
-
-		/* find start and length of this entry */
-		start = descr->offset;
-		length = dlength(descr, entry);
-
-		/* Skip to next entry if this one is empty or isn't needed */
-		if (!length || (pos >= start + length)) {
-			continue;
-		}
-
-		/* Pad with zeros to the start of this entry if needed */
-		if (pos < start) {
-			left = start - pos;
-			if (left > count) {
-				left = count;
-			}
-			clear_user(buf, left);
-			count -= left;
-			read += left;
-			pos += left;
-			buf += left;
-		}
-		if (!count) {
-			goto done;
-		}
-
-		/* locate and/or construct the data for this entry */
-		fork = NULL;
-		p = NULL;
-		switch (descr->id) {
-		case HFS_HDR_DATA:
-			fork = &entry->u.file.data_fork;
-			limit = fork->lsize;
-			break;
-
-		case HFS_HDR_RSRC:
-			fork = &entry->u.file.rsrc_fork;
-			limit = fork->lsize;
-			break;
-
-		case HFS_HDR_FNAME:
-			p = entry->key.CName.Name;
-			limit = entry->key.CName.Len;
-			break;
-
-		case HFS_HDR_OLDI:
-		case HFS_HDR_DATES:
-			get_dates(entry, inode, (hfs_u32 *)tmp);
-			if (descr->id == HFS_HDR_DATES) {
-				/* XXX: access date. hfsplus actually
-                                   has this. */
-				memcpy(tmp + 12, tmp + 4, 4);
-			} else if ((entry->type == HFS_CDR_FIL) &&
-				   (entry->u.file.flags & HFS_FIL_LOCK)) {
-				hfs_put_hl(HFS_AFP_RDONLY, tmp + 12);
-			} else {
-				hfs_put_nl(0, tmp + 12);
-			}
-			p = tmp;
-			limit = 16;
-			break;
-
-		case HFS_HDR_FINFO:
-			p = (char *)&entry->info;
-			limit = 32;
-			break;
-
-		case HFS_HDR_AFPI:
-			/* XXX: this needs to do more mac->afp mappings */
-			hfs_put_ns(0, tmp);
-			if ((entry->type == HFS_CDR_FIL) &&
-			    (entry->u.file.flags & HFS_FIL_LOCK)) {
-				hfs_put_hs(HFS_AFP_RDONLY, tmp + 2);
-			} else {
-				hfs_put_ns(0, tmp + 2);
-			}
-			p = tmp;
-			limit = 4;
-		        break;
-
-		case HFS_HDR_PRODOSI:
-			/* XXX: this needs to do mac->prodos translations */
-			memset(tmp, 0, 8);
-#if 0
-			hfs_put_ns(0, tmp); /* access */
-			hfs_put_ns(0, tmp); /* type */
-			hfs_put_nl(0, tmp); /* aux type */
-#endif
-			p = tmp;
-			limit = 8;
-		        break;
-
-		case HFS_HDR_MACI:
-			hfs_put_ns(0, tmp);
-			if (entry->type == HFS_CDR_FIL) {
-				hfs_put_hs(entry->u.file.flags, tmp + 2);
-			} else {
-				hfs_put_ns(entry->u.dir.flags, tmp + 2);
-			}
-			p = tmp;
-			limit = 4;
-			break;
-
-		case HFS_HDR_DID:
-		        /* if it's rootinfo, stick the next available did in
-			 * the did slot. */
-			limit = 4;
-			if (entry->cnid == htonl(HFS_ROOT_CNID)) {
-				struct hfs_mdb *mdb = entry->mdb;
-				const struct hfs_name *reserved = 
-				HFS_SB(mdb->sys_mdb)->s_reserved2;
-				
-				while (reserved->Len) {
-					if (hfs_streq(reserved->Name,
-						      reserved->Len,
-						      entry->key.CName.Name,
-						      entry->key.CName.Len)) {
-						hfs_put_hl(mdb->next_id, tmp);
-						p = tmp;
-						goto hfs_did_done;
-					}
-					reserved++;
-				}
-			}
-			p = (char *) &entry->cnid;
-hfs_did_done:
-			break;
-
-		case HFS_HDR_SNAME:
-		default:
-			limit = 0;
-		}
-		
-		/* limit the transfer to the available data
-		   of to the stated length of the entry. */
-		if (length > limit) {
-			length = limit;
-		}
-		offset = pos - start;
-		left = length - offset;
-		if (left > count) {
-			left = count;
-		}
-		if (left <= 0) {
-			continue;
-		}
-
-		/* transfer the data */
-		if (p) {
-			left -= copy_to_user(buf, p + offset, left);
-		} else if (fork) {
-			left = hfs_do_read(inode, fork, offset, buf, left);
-			if (left > 0) {
-			} else if (!read) {
-				return left;
-			} else {
-				goto done;
-			}
-		}
-		count -= left;
-		read += left;
-		pos += left;
-		buf += left;
-	}
-
-	/* Pad the file out with zeros */
-	if (count) {
-		clear_user(buf, count);
-		read += count;
-		pos += count;
-	}
-		
-done:
-	if (read) {
-		inode->i_atime = CURRENT_TIME;
-		*ppos = pos;
-		mark_inode_dirty(inode);
-	}
-	return read;
-}
-
-/*
- * hdr_write()
- *
- * This is the write() entry in the file_operations structure for
- * header files.  The purpose is to transfer up to 'count' bytes
- * to the file corresponding to 'inode' beginning at offset
- * '*ppos' from user-space at the address 'buf'.
- * The return value is the number of bytes actually transferred.
- */
-static hfs_rwret_t hdr_write(struct file *filp, const char __user *buf,
-			     hfs_rwarg_t count, loff_t *ppos)
-{
-	struct inode *inode = filp->f_dentry->d_inode;
-        struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-        struct hfs_hdr_layout *layout;
-        off_t start, length, offset;
-        int left, lcv, written = 0;
-	struct hdr_hdr meta;
-	int built_meta = 0;
-        off_t pos;
-
-	if (!S_ISREG(inode->i_mode)) {
-		hfs_warn("hfs_hdr_write: mode = %07o\n", inode->i_mode);
-		return -EINVAL;
-	}
-	if (count <= 0) {
-		return 0;
-	}
-
-	pos = (filp->f_flags & O_APPEND) ? inode->i_size : *ppos;
-
-	if (!HFS_I(inode)->layout) {
-		HFS_I(inode)->layout = dup_layout(HFS_I(inode)->default_layout);
-	}
-	layout = HFS_I(inode)->layout;
-
-	/* Handle the 'magic', 'version', 'filler' and 'entries' fields */
-	length = sizeof(hfs_u32) + sizeof(hfs_u32) + 16 + sizeof(hfs_u16);
-	if (pos < length) {
-		hdr_build_meta(&meta, layout, entry);
-		built_meta = 1;
-
-		left = length - pos;
-		if (left > count) {
-			left = count;
-		}
-
-		left -= copy_from_user(((char *)&meta) + pos, buf, left);
-		layout->magic   = hfs_get_nl(meta.magic);
-		layout->version = hfs_get_nl(meta.version);
-		layout->entries = hfs_get_hs(meta.entries);
-		if (layout->entries > HFS_HDR_MAX) {
-			/* XXX: should allocate slots dynamically */
-			hfs_warn("hfs_hdr_write: TRUNCATING TO %d "
-				 "DESCRIPTORS\n", HFS_HDR_MAX);
-			layout->entries = HFS_HDR_MAX;
-		}
-
-		count -= left;
-		written += left;
-		pos += left;
-		buf += left;
-	}
-	if (!count) {
-		goto done;
-	}
-
-	/* We know for certain how many entries we have, so process them */
-	length += layout->entries * 3 * sizeof(hfs_u32);
-	if (pos < length) {
-		if (!built_meta) {
-			hdr_build_meta(&meta, layout, entry);
-		}
-
-		left = length - pos;
-		if (left > count) {
-			left = count;
-		}
-
-		left -= copy_from_user(((char *)&meta) + pos, buf, left);
-		init_layout(layout, meta.descrs);
-
-		count -= left;
-		written += left;
-		pos += left;
-		buf += left;
-
-		/* Handle possible size changes for the forks */
-		if (entry->type == HFS_CDR_FIL) {
-			adjust_forks(entry, layout);
-			hfs_cat_mark_dirty(entry);
-		}
-	}
-
-	/* Handle the actual data */
-	for (lcv = 0; count && (lcv < layout->entries); ++lcv) {
-		struct hfs_hdr_descr *descr = layout->order[lcv];
-		struct hfs_fork *fork;
-		char tmp[16], *p;
-		off_t limit;
-
-		/* stop writing if we run out of descriptors early */
-		if (!descr) {
-			break;
-		}
-
-		/* find start and length of this entry */
-		start = descr->offset;
-		if ((descr->id == HFS_HDR_DATA) ||
-		    (descr->id == HFS_HDR_RSRC)) {
-			if (entry->type == HFS_CDR_FIL) {
-				length = 0x7fffffff - start;
-			} else {
-				continue;
-			}
-		} else {
-			length = dlength(descr, entry);
-		}
-
-		/* Trim length to avoid overlap with the next entry */
-		if (layout->order[lcv+1] &&
-		    ((start + length) > layout->order[lcv+1]->offset)) {
-			length = layout->order[lcv+1]->offset - start;
-		}
-
-		/* Skip to next entry if this one is empty or isn't needed */
-		if (!length || (pos >= start + length)) {
-			continue;
-		}
-
-		/* Skip any padding that may exist between entries */
-		if (pos < start) {
-			left = start - pos;
-			if (left > count) {
-				left = count;
-			}
-			count -= left;
-			written += left;
-			pos += left;
-			buf += left;
-		}
-		if (!count) {
-			goto done;
-		}
-
-		/* locate and/or construct the data for this entry */
-		fork = NULL;
-		p = NULL;
-		switch (descr->id) {
-		case HFS_HDR_DATA:
-#if 0
-/* Can't yet write to the data fork via a header file, since there is the
- * possibility to write via the data file, and the only locking is at the
- * inode level.
- */
-			fork = &entry->u.file.data_fork;
-			limit = length;
-#else
-			limit = 0;
-#endif
-			break;
-
-		case HFS_HDR_RSRC:
-			fork = &entry->u.file.rsrc_fork;
-			limit = length;
-			break;
-
-		case HFS_HDR_OLDI:
-		case HFS_HDR_DATES:
-			get_dates(entry, inode, (hfs_u32 *)tmp);
-			if (descr->id == HFS_HDR_DATES) {
-				memcpy(tmp + 12, tmp + 4, 4);
-			} else if ((entry->type == HFS_CDR_FIL) &&
-				   (entry->u.file.flags & HFS_FIL_LOCK)) {
-				hfs_put_hl(HFS_AFP_RDONLY, tmp + 12);
-			} else {
-				hfs_put_nl(0, tmp + 12);
-			}
-			p = tmp;
-			limit = 16;
-			break;
-
-		case HFS_HDR_FINFO:
-			p = (char *)&entry->info;
-			limit = 32;
-			break;
-
-		case HFS_HDR_AFPI:
-			hfs_put_ns(0, tmp);
-			if ((entry->type == HFS_CDR_FIL) &&
-			    (entry->u.file.flags & HFS_FIL_LOCK)) {
-				hfs_put_hs(HFS_AFP_RDONLY, tmp + 2);
-			} else {
-				hfs_put_ns(0, tmp + 2);
-			}			
-			p = tmp;
-			limit = 4;
-			break;
-
-		case HFS_HDR_PRODOSI:
-			/* XXX: this needs to do mac->prodos translations */
-			memset(tmp, 0, 8); 
-#if 0
-			hfs_put_ns(0, tmp); /* access */
-			hfs_put_ns(0, tmp); /* type */
-			hfs_put_nl(0, tmp); /* aux type */
-#endif
-			p = tmp;
-			limit = 8;
-		        break;
-
-		case HFS_HDR_MACI:
-			hfs_put_ns(0, tmp);
-			if (entry->type == HFS_CDR_FIL) {
-				hfs_put_hs(entry->u.file.flags, tmp + 2);
-			} else {
-				hfs_put_ns(entry->u.dir.flags, tmp + 2);
-			}
-			p = tmp;
-			limit = 4;
-			break;
-
-		case HFS_HDR_FNAME:	/* Can't rename a file this way */
-		case HFS_HDR_DID:       /* can't specify a did this way */
-		default:
-			limit = 0;
-		}
-		
-		/* limit the transfer to the available data
-		   of to the stated length of the entry. */
-		if (length > limit) {
-			length = limit;
-		}
-		offset = pos - start;
-		left = length - offset;
-		if (left > count) {
-			left = count;
-		}
-		if (left <= 0) {
-			continue;
-		}
-
-		/* transfer the data from user space */
-		if (p) {
-			left -= copy_from_user(p + offset, buf, left);
-		} else if (fork) {
-			left = hfs_do_write(inode, fork, offset, buf, left);
-		}
-
-		/* process the data */
-		switch (descr->id) {
-		case HFS_HDR_OLDI:
-			set_dates(entry, inode, (hfs_u32 *)tmp);
-			if (entry->type == HFS_CDR_FIL) {
-				hfs_u8 new_flags = entry->u.file.flags;
-
-				if (hfs_get_nl(tmp+12) & htonl(HFS_AFP_WRI)) {
-					new_flags |= HFS_FIL_LOCK;
-				} else {
-					new_flags &= ~HFS_FIL_LOCK;
-				}
-
-				if (new_flags != entry->u.file.flags) {
-					entry->u.file.flags = new_flags;
-					hfs_cat_mark_dirty(entry);
-					hfs_file_fix_mode(entry);
-				}
-			}
-			break;
-
-		case HFS_HDR_DATES:
-			set_dates(entry, inode, (hfs_u32 *)tmp);
-			break;
-
-		case HFS_HDR_FINFO:
-			hfs_cat_mark_dirty(entry);
-			break;
-
-		case HFS_HDR_MACI:
-			if (entry->type == HFS_CDR_DIR) {
-				hfs_u16 new_flags = hfs_get_ns(tmp + 2);
-
-				if (entry->u.dir.flags != new_flags) {
-					entry->u.dir.flags = new_flags;
-					hfs_cat_mark_dirty(entry);
-				}
-			} else {
-				hfs_u8 new_flags = tmp[3];
-				hfs_u8 changed = entry->u.file.flags^new_flags;
-				
-				if (changed) {
-					entry->u.file.flags = new_flags;
-					hfs_cat_mark_dirty(entry);
-					if (changed & HFS_FIL_LOCK) {
-						hfs_file_fix_mode(entry);
-					}
-				}
-			}
-			break;
-
-		case HFS_HDR_DATA:
-		case HFS_HDR_RSRC:
-			if (left <= 0) {
-				if (!written) {
-					return left;
-				} else {
-					goto done;
-				}
-			} else if (fork->lsize > descr->length) {
-				descr->length = fork->lsize;
-			}
-			break;
-
-		case HFS_HDR_FNAME:	/* Can't rename a file this way */
-		case HFS_HDR_DID:       /* Can't specify a did this way */
-		case HFS_HDR_PRODOSI:   /* not implemented yet */
-		case HFS_HDR_AFPI:      /* ditto */
-		default:
-			break;
-		}
-
-		count -= left;
-		written += left;
-		pos += left;
-		buf += left;
-	}
-
-	/* Skip any padding at the end */
-	if (count) {
-		written += count;
-		pos += count;
-	}
-		
-done:
-	*ppos = pos;
-	if (written > 0) {
-	        if (pos > inode->i_size)
-		        inode->i_size = pos;
-	        inode->i_mtime = inode->i_atime = CURRENT_TIME;
-		mark_inode_dirty(inode);
-	}
-	return written;
-}
-
-/*
- * hdr_truncate()
- *
- * This is the truncate field in the inode_operations structure for
- * header files.  The purpose is to allocate or release blocks as needed
- * to satisfy a change in file length.
- */
-void hdr_truncate(struct inode *inode, size_t size)
-{
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-	struct hfs_hdr_layout *layout;
-	int lcv, last;
-
-	inode->i_size = size;
-	if (!HFS_I(inode)->layout) {
-		HFS_I(inode)->layout = dup_layout(HFS_I(inode)->default_layout);
-	}
-	layout = HFS_I(inode)->layout;
-
-	last = layout->entries - 1;
-	for (lcv = 0; lcv <= last; ++lcv) {
-		struct hfs_hdr_descr *descr = layout->order[lcv];
-		struct hfs_fork *fork;
-		hfs_u32 offset;
-
-		if (!descr) {
-			break;
-		}
-
-		if (descr->id == HFS_HDR_RSRC) {
-			fork = &entry->u.file.rsrc_fork;
-#if 0
-/* Can't yet truncate the data fork via a header file, since there is the
- * possibility to truncate via the data file, and the only locking is at
- * the inode level.
- */
-		} else if (descr->id == HFS_HDR_DATA) {
-			fork = &entry->u.file.data_fork;
-#endif
-		} else {
-			continue;
-		}
-
-		offset = descr->offset;
-
-		if ((lcv != last) && ((offset + descr->length) <= size)) {
-			continue;
-		}
-
-		if (offset < size) {
-			descr->length = size - offset;
-		} else {
-			descr->length = 0;
-		}
-		if (fork->lsize != descr->length) {
-			fork->lsize = descr->length;
-			hfs_extent_adj(fork);
-			hfs_cat_mark_dirty(entry);
-		}
-	}
-}
diff -purN /dev/shm/linux-2.5/fs/hfs/hfs.h linuxppc-2.5-benh/fs/hfs/hfs.h
--- /dev/shm/linux-2.5/fs/hfs/hfs.h	2002-07-20 17:49:48.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/hfs.h	2003-12-24 03:48:17.000000000 +0000
@@ -1,4 +1,4 @@
-/* 
+/*
  * linux/fs/hfs/hfs.h
  *
  * Copyright (C) 1995-1997  Paul H. Hargrove
@@ -10,12 +10,6 @@
 #ifndef _HFS_H
 #define _HFS_H
 
-#include <linux/hfs_sysdep.h>
-
-#define HFS_NEW(X)	((X) = hfs_malloc(sizeof(*(X))))
-#define HFS_DELETE(X)	do { hfs_free((X), sizeof(*(X))); (X) = NULL; } \
-                        while (0)
- 
 /* offsets to various blocks */
 #define HFS_DD_BLK		0 /* Driver Descriptor block */
 #define HFS_PMAP_BLK		1 /* First block of partition map */
@@ -28,46 +22,31 @@
 #define HFS_SUPER_MAGIC		0x4244 /* "BD": HFS MDB (super block) */
 #define HFS_MFS_SUPER_MAGIC	0xD2D7 /* MFS MDB (super block) */
 
-/* magic numbers for various internal structures */
-#define HFS_FILE_MAGIC		0x4801
-#define HFS_DIR_MAGIC		0x4802
-#define HFS_MDB_MAGIC		0x4803
-#define HFS_EXT_MAGIC		0x4804 /* XXX currently unused */
-#define HFS_BREC_MAGIC		0x4811 /* XXX currently unused */
-#define HFS_BTREE_MAGIC		0x4812
-#define HFS_BNODE_MAGIC		0x4813
-
 /* various FIXED size parameters */
 #define HFS_SECTOR_SIZE		512    /* size of an HFS sector */
 #define HFS_SECTOR_SIZE_BITS	9      /* log_2(HFS_SECTOR_SIZE) */
 #define HFS_NAMELEN		31     /* maximum length of an HFS filename */
-#define HFS_NAMEMAX		(3*31) /* max size of ENCODED filename */
-#define HFS_BM_MAXBLOCKS	(16)   /* max number of bitmap blocks */
-#define HFS_BM_BPB (8*HFS_SECTOR_SIZE) /* number of bits per bitmap block */
 #define HFS_MAX_VALENCE		32767U
-#define HFS_FORK_MAX		(0x7FFFFFFF)
 
 /* Meanings of the drAtrb field of the MDB,
  * Reference: _Inside Macintosh: Files_ p. 2-61
  */
-#define HFS_SB_ATTRIB_HLOCK 0x0080
-#define HFS_SB_ATTRIB_CLEAN 0x0100
-#define HFS_SB_ATTRIB_SPARED 0x0200
-#define HFS_SB_ATTRIB_SLOCK 0x8000
-
-/* 2**16 - 1 */
-#define HFS_USHRT_MAX	65535
+#define HFS_SB_ATTRIB_HLOCK	0x0080
+#define HFS_SB_ATTRIB_CLEAN	0x0100
+#define HFS_SB_ATTRIB_SPARED	0x0200
+#define HFS_SB_ATTRIB_SLOCK	0x8000
 
 /* Some special File ID numbers */
-#define HFS_POR_CNID	1	/* Parent Of the Root */
-#define HFS_ROOT_CNID	2	/* ROOT directory */
-#define HFS_EXT_CNID	3	/* EXTents B-tree */
-#define HFS_CAT_CNID	4	/* CATalog B-tree */
-#define HFS_BAD_CNID	5	/* BAD blocks file */
-#define HFS_ALLOC_CNID  6       /* ALLOCation file (HFS+) */
-#define HFS_START_CNID  7       /* STARTup file (HFS+) */
-#define HFS_ATTR_CNID   8       /* ATTRibutes file (HFS+) */
-#define HFS_EXCH_CNID  15       /* ExchangeFiles temp id */
+#define HFS_POR_CNID		1	/* Parent Of the Root */
+#define HFS_ROOT_CNID		2	/* ROOT directory */
+#define HFS_EXT_CNID		3	/* EXTents B-tree */
+#define HFS_CAT_CNID		4	/* CATalog B-tree */
+#define HFS_BAD_CNID		5	/* BAD blocks file */
+#define HFS_ALLOC_CNID		6	/* ALLOCation file (HFS+) */
+#define HFS_START_CNID		7	/* STARTup file (HFS+) */
+#define HFS_ATTR_CNID		8	/* ATTRibutes file (HFS+) */
+#define HFS_EXCH_CNID		15	/* ExchangeFiles temp id */
+#define HFS_FIRSTUSER_CNID	16
 
 /* values for hfs_cat_rec.cdrType */
 #define HFS_CDR_DIR    0x01    /* folder (directory) */
@@ -85,7 +64,6 @@
 #define HFS_FIL_DOPEN   0x04  /* data fork open */
 #define HFS_FIL_ROPEN   0x08  /* resource fork open */
 #define HFS_FIL_DIR     0x10  /* directory (always clear) */
-#define HFS_FIL_RSRV1   0x20  /* reserved */
 #define HFS_FIL_NOCOPY  0x40  /* copy-protected file */
 #define HFS_FIL_USED	0x80  /* open */
 
@@ -96,449 +74,214 @@
 #define HFS_DIR_MOUNTED     0x08  /* mounted */
 #define HFS_DIR_DIR         0x10  /* directory (always set) */
 #define HFS_DIR_EXPFOLDER   0x20  /* share point */
-#define HFS_DIR_RSRV1       0x40  /* reserved */
-#define HFS_DIR_RSRV2       0x80  /* reserved */
 
-/* Access types used when requesting access to a B-node */
-#define HFS_LOCK_NONE	0x0000	/* Illegal */
-#define HFS_LOCK_READ	0x0001	/* read-only access */
-#define HFS_LOCK_RESRV	0x0002	/* might potentially modify */
-#define HFS_LOCK_WRITE	0x0003	/* will modify now (exclusive access) */
-#define HFS_LOCK_MASK	0x000f
-
-/* Flags field of the hfs_path_elem */
-#define HFS_BPATH_FIRST		0x0100
-#define HFS_BPATH_OVERFLOW	0x0200
-#define HFS_BPATH_UNDERFLOW	0x0400
-#define HFS_BPATH_MASK		0x0f00
-
-/* Flags for hfs_bfind() */
-#define HFS_BFIND_EXACT		0x0010
-#define HFS_BFIND_LOCK		0x0020
-
-/* Modes for hfs_bfind() */
-#define HFS_BFIND_WRITE   (HFS_LOCK_RESRV|HFS_BFIND_EXACT|HFS_BFIND_LOCK)
-#define HFS_BFIND_READ_EQ (HFS_LOCK_READ|HFS_BFIND_EXACT)
-#define HFS_BFIND_READ_LE (HFS_LOCK_READ)
-#define HFS_BFIND_INSERT  (HFS_LOCK_RESRV|HFS_BPATH_FIRST|HFS_BPATH_OVERFLOW)
-#define HFS_BFIND_DELETE \
-	 (HFS_LOCK_RESRV|HFS_BFIND_EXACT|HFS_BPATH_FIRST|HFS_BPATH_UNDERFLOW)
+/* bits hfs_finfo.fdFlags */
+#define HFS_FLG_INITED		0x0100
+#define HFS_FLG_LOCKED		0x1000
+#define HFS_FLG_INVISIBLE	0x4000
 
 /*======== HFS structures as they appear on the disk ========*/
 
+#define __packed __attribute__ ((packed))
+
 /* Pascal-style string of up to 31 characters */
 struct hfs_name {
-	hfs_byte_t	Len;
-	hfs_byte_t	Name[31];
-} __attribute__((packed));
-
-typedef struct {
-	hfs_word_t	v;
-	hfs_word_t	h;
-} hfs_point_t;
-
-typedef struct {
-	hfs_word_t	top;
-	hfs_word_t	left;
-	hfs_word_t	bottom;
-	hfs_word_t	right;
-} hfs_rect_t;
-
-typedef struct {
-	hfs_lword_t	 fdType;
-	hfs_lword_t	 fdCreator;
-	hfs_word_t	 fdFlags;
-	hfs_point_t	 fdLocation;
-	hfs_word_t	 fdFldr;
-} __attribute__((packed)) hfs_finfo_t;
-
-typedef struct {
-	hfs_word_t	fdIconID;
-	hfs_byte_t	fdUnused[8];
-	hfs_word_t	fdComment;
-	hfs_lword_t	fdPutAway;
-} __attribute__((packed)) hfs_fxinfo_t;
-
-typedef struct {
-	hfs_rect_t	frRect;
-	hfs_word_t	frFlags;
-	hfs_point_t	frLocation;
-	hfs_word_t	frView;
-} __attribute__((packed)) hfs_dinfo_t;
-
-typedef struct {
-	hfs_point_t	frScroll;
-	hfs_lword_t	frOpenChain;
-	hfs_word_t	frUnused;
-	hfs_word_t	frComment;
-	hfs_lword_t	frPutAway;
-} __attribute__((packed)) hfs_dxinfo_t;
+	u8 len;
+	u8 name[HFS_NAMELEN];
+} __packed;
+
+struct hfs_point {
+	u16 v;
+	u16 h;
+} __packed;
+
+struct hfs_rect {
+	u16 top;
+	u16 left;
+	u16 bottom;
+	u16 right;
+} __packed;
+
+struct hfs_finfo {
+	u32 fdType;
+	u32 fdCreator;
+	u16 fdFlags;
+	struct hfs_point fdLocation;
+	u16 fdFldr;
+} __packed;
+
+struct hfs_fxinfo {
+	u16 fdIconID;
+	u8 fdUnused[8];
+	u16 fdComment;
+	u32 fdPutAway;
+} __packed;
+
+struct hfs_dinfo {
+	struct hfs_rect frRect;
+	u16 frFlags;
+	struct hfs_point frLocation;
+	u16 frView;
+} __packed;
+
+struct hfs_dxinfo {
+	struct hfs_point frScroll;
+	u32 frOpenChain;
+	u16 frUnused;
+	u16 frComment;
+	u32 frPutAway;
+} __packed;
 
 union hfs_finder_info {
 	struct {
-		hfs_finfo_t	finfo;
-		hfs_fxinfo_t	fxinfo;
+		struct hfs_finfo finfo;
+		struct hfs_fxinfo fxinfo;
 	} file;
 	struct {
-		hfs_dinfo_t	dinfo;
-		hfs_dxinfo_t	dxinfo;
+		struct hfs_dinfo dinfo;
+		struct hfs_dxinfo dxinfo;
 	} dir;
-};
-
-/* A btree record key on disk */
-struct hfs_bkey {
-	hfs_byte_t	KeyLen;		/* number of bytes in the key */
-	hfs_byte_t	value[1];	/* (KeyLen) bytes of key */
-} __attribute__((packed));
+} __packed;
 
 /* Cast to a pointer to a generic bkey */
 #define	HFS_BKEY(X)	(((void)((X)->KeyLen)), ((struct hfs_bkey *)(X)))
 
 /* The key used in the catalog b-tree: */
 struct hfs_cat_key {
-	hfs_byte_t	KeyLen;	/* number of bytes in the key */
-	hfs_byte_t	Resrv1;	/* padding */
-	hfs_lword_t	ParID;	/* CNID of the parent dir */
+	u8 key_len;		/* number of bytes in the key */
+	u8 reserved;		/* padding */
+	u32 ParID;		/* CNID of the parent dir */
 	struct hfs_name	CName;	/* The filename of the entry */
-} __attribute__((packed));
+} __packed;
 
 /* The key used in the extents b-tree: */
 struct hfs_ext_key {
-	hfs_byte_t	KeyLen;	/* number of bytes in the key */
-	hfs_byte_t	FkType;	/* HFS_FK_{DATA,RSRC} */
-	hfs_lword_t	FNum;	/* The File ID of the file */
-	hfs_word_t	FABN;	/* allocation blocks number*/
-} __attribute__((packed));
+	u8 key_len;		/* number of bytes in the key */
+	u8 FkType;		/* HFS_FK_{DATA,RSRC} */
+	u32 FNum;		/* The File ID of the file */
+	u16 FABN;		/* allocation blocks number*/
+} __packed;
+
+typedef union hfs_btree_key {
+	u8 key_len;			/* number of bytes in the key */
+	struct hfs_cat_key cat;
+	struct hfs_ext_key ext;
+} hfs_btree_key;
 
-/*======== Data structures kept in memory ========*/
-
-/*
- * struct hfs_mdb
- *
- * The fields from the MDB of an HFS filesystem
- */
-struct hfs_mdb {
-	int			magic;		/* A magic number */
-	unsigned char		vname[28];	/* The volume name */
-	hfs_sysmdb		sys_mdb;	/* superblock */
-	hfs_buffer		buf;		/* The hfs_buffer
-						   holding the real
-						   superblock (aka VIB
-						   or MDB) */
-	hfs_buffer		alt_buf;	/* The hfs_buffer holding
-						   the alternate superblock */
-	hfs_buffer		bitmap[16];	/* The hfs_buffer holding the
-						   allocation bitmap */
-	struct hfs_btree *	ext_tree;	/* Information about
-						   the extents b-tree */
-	struct hfs_btree *	cat_tree;	/* Information about
-						   the catalog b-tree */
-	hfs_u32			file_count;	/* The number of
-						   regular files in
-						   the filesystem */
-	hfs_u32			dir_count;	/* The number of
-						   directories in the
-						   filesystem */
-	hfs_u32			next_id;	/* The next available
-						   file id number */
-	hfs_u32			clumpablks;	/* The number of allocation
-						   blocks to try to add when
-						   extending a file */
-	hfs_u32			write_count;	/* The number of MDB
-						   writes (a sort of
-						   version number) */
-	hfs_u32			fs_start;	/* The first 512-byte
-						   block represented
-						   in the bitmap */
-	hfs_u32			create_date;	/* In network byte-order */
-	hfs_u32			modify_date;	/* In network byte-order */
-	hfs_u32			backup_date;	/* In network byte-order */
-	hfs_u16			root_files;	/* The number of
-						   regular
-						   (non-directory)
-						   files in the root
-						   directory */
-	hfs_u16			root_dirs;	/* The number of
-						   directories in the
-						   root directory */
-	hfs_u16			fs_ablocks;	/* The number of
-						   allocation blocks
-						   in the filesystem */
-	hfs_u16			free_ablocks;	/* The number of unused
-						   allocation blocks
-						   in the filesystem */
-	hfs_u32			alloc_blksz;	/* The number of
-						   512-byte blocks per
-						   "allocation block" */
-	hfs_u16			attrib;		/* Attribute word */
-	struct semaphore	bitmap_sem;
-        struct list_head        entry_dirty;
-};
+typedef union hfs_btree_key btree_key;
 
-/*
- * struct hfs_extent
- *
- * The offset to allocation block mapping for a given file is
- * contained in a series of these structures.  Each (struct
- * hfs_extent) records up to three runs of contiguous allocation
- * blocks.  An allocation block is a contiguous group of physical
- * blocks.
- */
 struct hfs_extent {
-	int		   magic;     /* A magic number */
-	unsigned short	   start;     /* Where in the file this record
-					 begins (in allocation blocks) */
-	unsigned short	   end;	      /* Where in the file this record
-					 ends (in allocation blocks) */
-	unsigned short	   block[3];  /* The allocation block on disk which
-					 begins this extent */
-	unsigned short	   length[3]; /* The number of allocation blocks
-					 in this extent */
-	struct hfs_extent  *next;     /* Next extent record for this file */
-	struct hfs_extent  *prev;     /* Previous extent record for this file */
-	int		   count;     /* Number of times it is used */
+	u16 block;
+	u16 count;
 };
+typedef struct hfs_extent hfs_extent_rec[3];
 
-/*
- * struct hfs_dir 
- *
- * This structure holds information specific
- * to a directory in an HFS filesystem.
- */
-struct hfs_dir {		
-	int		magic;		/* A magic number */
-	hfs_u16		flags;
-	hfs_u16		dirs;		/* Number of directories in this one */
-	hfs_u16		files;		/* Number of files in this directory */
-	struct rw_semaphore	sem;
-};
+/* The catalog record for a file */
+struct hfs_cat_file {
+	s8 type;			/* The type of entry */
+	u8 reserved;
+	u8 Flags;			/* Flags such as read-only */
+	s8 Typ;				/* file version number = 0 */
+	struct hfs_finfo UsrWds;	/* data used by the Finder */
+	u32 FlNum;			/* The CNID */
+	u16 StBlk;			/* obsolete */
+	u32 LgLen;			/* The logical EOF of the data fork*/
+	u32 PyLen;			/* The physical EOF of the data fork */
+	u16 RStBlk;			/* obsolete */
+	u32 RLgLen;			/* The logical EOF of the rsrc fork */
+	u32 RPyLen;			/* The physical EOF of the rsrc fork */
+	u32 CrDat;			/* The creation date */
+	u32 MdDat;			/* The modified date */
+	u32 BkDat;			/* The last backup date */
+	struct hfs_fxinfo FndrInfo;	/* more data for the Finder */
+	u16 ClpSize;			/* number of bytes to allocate
+					   when extending files */
+	hfs_extent_rec ExtRec;		/* first extent record
+					   for the data fork */
+	hfs_extent_rec RExtRec;		/* first extent record
+					   for the resource fork */
+	u32 Resrv;			/* reserved by Apple */
+} __packed;
+
+/* the catalog record for a directory */
+struct hfs_cat_dir {
+	s8 type;			/* The type of entry */
+	u8 reserved;
+	u16 Flags;			/* flags */
+	u16 Val;			/* Valence: number of files and
+					   dirs in the directory */
+	u32 DirID;			/* The CNID */
+	u32 CrDat;			/* The creation date */
+	u32 MdDat;			/* The modification date */
+	u32 BkDat;			/* The last backup date */
+	struct hfs_dinfo UsrInfo;	/* data used by the Finder */
+	struct hfs_dxinfo FndrInfo;	/* more data used by Finder */
+	u8 Resrv[16];			/* reserved by Apple */
+} __packed;
+
+/* the catalog record for a thread */
+struct hfs_cat_thread {
+	s8 type;			/* The type of entry */
+	u8 reserved[9];			/* reserved by Apple */
+	u32 ParID;			/* CNID of parent directory */
+	struct hfs_name CName;		/* The name of this entry */
+}  __packed;
+
+/* A catalog tree record */
+typedef union hfs_cat_rec {
+	s8 type;			/* The type of entry */
+	struct hfs_cat_file file;
+	struct hfs_cat_dir dir;
+	struct hfs_cat_thread thread;
+} hfs_cat_rec;
 
-/*
- * struct hfs_fork
- *
- * This structure holds the information
- * specific to a single fork of a file.
- */
-struct hfs_fork {
-	struct hfs_cat_entry	*entry;    /* The file this fork is part of */
-	struct hfs_extent	first;     /* The first extent record for
-						 this fork */
-	struct hfs_extent	*cache;    /* The most-recently accessed
-						 extent record for this fork */
-	hfs_u32			lsize;     /* The logical size in bytes */
-	hfs_u32			psize;     /* The phys size (512-byte blocks) */
-        hfs_u8			fork;      /* Which fork is this? */
-};
-
-/*
- * struct hfs_file 
- *
- * This structure holds information specific
- * to a file in an HFS filesystem.
- */
-struct hfs_file {
-	int		   magic;
-	struct hfs_fork    data_fork;
-	struct hfs_fork    rsrc_fork;
-	hfs_u16		   clumpablks;
-	hfs_u8		   flags;
-};
-
-/*
- * struct hfs_file 
- *
- * This structure holds information about a
- * file or directory in an HFS filesystem.
- *
- * 'wait' must remain 1st and 'hash' 2nd since we do some pointer arithmetic.
- */
-struct hfs_cat_entry {
-	hfs_wait_queue		wait;
-        struct list_head        hash;
-        struct list_head        list;
-	struct hfs_mdb		*mdb;
-	hfs_sysentry		sys_entry;
-	struct hfs_cat_key	key;
-	union hfs_finder_info	info;
-	hfs_u32			cnid;		/* In network byte-order */
-	hfs_u32			create_date;	/* In network byte-order */
-	hfs_u32			modify_date;	/* In network byte-order */
-	hfs_u32			backup_date;	/* In network byte-order */
-	unsigned short		count;
-        unsigned long           state;
-	hfs_u8			type;
-	union {
-		struct hfs_dir	dir;
-		struct hfs_file file;
-	} u;
-};
-
-/* hfs entry state bits */
-#define HFS_DIRTY        1
-#define HFS_KEYDIRTY     2
-#define HFS_LOCK         4
-#define HFS_DELETED      8
-
-/* 
- * struct hfs_bnode_ref
- *
- * A pointer to a (struct hfs_bnode) and the type of lock held on it.
- */
-struct hfs_bnode_ref {
-        struct hfs_bnode *bn;
-        int lock_type;
-};
+struct hfs_mdb {
+	u16 drSigWord;			/* Signature word indicating fs type */
+	u32 drCrDate;			/* fs creation date/time */
+	u32 drLsMod;			/* fs modification date/time */
+	u16 drAtrb;			/* fs attributes */
+	u16 drNmFls;			/* number of files in root directory */
+	u16 drVBMSt;			/* location (in 512-byte blocks)
+					   of the volume bitmap */
+	u16 drAllocPtr;			/* location (in allocation blocks)
+					   to begin next allocation search */
+	u16 drNmAlBlks;			/* number of allocation blocks */
+	u32 drAlBlkSiz;			/* bytes in an allocation block */
+	u32 drClpSiz;			/* clumpsize, the number of bytes to
+					   allocate when extending a file */
+	u16 drAlBlSt;			/* location (in 512-byte blocks)
+					   of the first allocation block */
+	u32 drNxtCNID;			/* CNID to assign to the next
+					   file or directory created */
+	u16 drFreeBks;			/* number of free allocation blocks */
+	u8 drVN[28];			/* the volume label */
+	u32 drVolBkUp;			/* fs backup date/time */
+	u16 drVSeqNum;			/* backup sequence number */
+	u32 drWrCnt;			/* fs write count */
+	u32 drXTClpSiz;			/* clumpsize for the extents B-tree */
+	u32 drCTClpSiz;			/* clumpsize for the catalog B-tree */
+	u16 drNmRtDirs;			/* number of directories in
+					   the root directory */
+	u32 drFilCnt;			/* number of files in the fs */
+	u32 drDirCnt;			/* number of directories in the fs */
+	u8 drFndrInfo[32];		/* data used by the Finder */
+	u16 drEmbedSigWord;		/* embedded volume signature */
+	u32 drEmbedExtent;		/* starting block number (xdrStABN)
+					   and number of allocation blocks
+					   (xdrNumABlks) occupied by embedded
+					   volume */
+	u32 drXTFlSize;			/* bytes in the extents B-tree */
+	hfs_extent_rec drXTExtRec;	/* extents B-tree's first 3 extents */
+	u32 drCTFlSize;			/* bytes in the catalog B-tree */
+	hfs_extent_rec drCTExtRec;	/* catalog B-tree's first 3 extents */
+} __packed;
 
-/*
- * struct hfs_belem
- *
- * An element of the path from the root of a B-tree to a leaf.
- * Includes the reference to a (struct hfs_bnode), the index of
- * the appropriate record in that node, and some flags.
- */
-struct hfs_belem {
-	struct hfs_bnode_ref	bnr;
-	int			record;
-	int			flags;
-};
+/*======== Data structures kept in memory ========*/
 
-/*
- * struct hfs_brec
- *
- * The structure returned by hfs_bfind() to describe the requested record.
- */
-struct hfs_brec {
-	int			keep_flags;
-	struct hfs_btree	*tree;
-	struct hfs_belem	*top;
-	struct hfs_belem	*bottom;
-	struct hfs_belem	elem[9];
-	struct hfs_bkey		*key;
-	void			*data;	/* The actual data */
+struct hfs_readdir_data {
+	struct list_head list;
+	struct file *file;
+	struct hfs_cat_key key;
 };
 
-/*================ Function prototypes ================*/
-
-/* bdelete.c */
-extern int hfs_bdelete(struct hfs_btree *, const struct hfs_bkey *);
-
-/* bfind.c */
-extern void hfs_brec_relse(struct hfs_brec *, struct hfs_belem *);
-extern int hfs_bsucc(struct hfs_brec *, int);
-extern int hfs_bfind(struct hfs_brec *, struct hfs_btree *,
-		     const struct hfs_bkey *, int);
- 
-/* binsert.c */
-extern int hfs_binsert(struct hfs_btree *, const struct hfs_bkey *,
-		       const void *, hfs_u16);
-
-/* bitmap.c */
-extern hfs_u16 hfs_vbm_count_free(const struct hfs_mdb *, hfs_u16);
-extern hfs_u16 hfs_vbm_search_free(const struct hfs_mdb *, hfs_u16 *);
-extern int hfs_set_vbm_bits(struct hfs_mdb *, hfs_u16, hfs_u16);
-extern int hfs_clear_vbm_bits(struct hfs_mdb *, hfs_u16, hfs_u16);
-
-/* bitops.c */
-extern hfs_u32 hfs_find_zero_bit(const hfs_u32 *, hfs_u32, hfs_u32);
-extern hfs_u32 hfs_count_zero_bits(const hfs_u32 *, hfs_u32, hfs_u32);
-
-/* btree.c */
-extern struct hfs_btree *hfs_btree_init(struct hfs_mdb *, ino_t,
-				        hfs_byte_t *, hfs_u32, hfs_u32);
-extern void hfs_btree_free(struct hfs_btree *);
-extern void hfs_btree_commit(struct hfs_btree *, hfs_byte_t *, hfs_lword_t);
-
-/* catalog.c */
-extern void hfs_cat_init(void);
-extern void hfs_cat_put(struct hfs_cat_entry *);
-extern void hfs_cat_mark_dirty(struct hfs_cat_entry *);
-extern struct hfs_cat_entry *hfs_cat_get(struct hfs_mdb *,
-					 const struct hfs_cat_key *);
-
-extern void hfs_cat_invalidate(struct hfs_mdb *);
-extern void hfs_cat_commit(struct hfs_mdb *);
-extern void hfs_cat_free(void);
-
-extern int hfs_cat_compare(const struct hfs_cat_key *,
-			   const struct hfs_cat_key *);
-extern void hfs_cat_build_key(hfs_u32, const struct hfs_name *,
-			      struct hfs_cat_key *);
-extern struct hfs_cat_entry *hfs_cat_parent(struct hfs_cat_entry *);
-
-extern int hfs_cat_open(struct hfs_cat_entry *, struct hfs_brec *);
-extern int hfs_cat_next(struct hfs_cat_entry *, struct hfs_brec *,
-			hfs_u16, hfs_u32 *, hfs_u8 *);
-extern void hfs_cat_close(struct hfs_cat_entry *, struct hfs_brec *);
-
-extern int hfs_cat_create(struct hfs_cat_entry *, struct hfs_cat_key *,
-			  hfs_u8, hfs_u32, hfs_u32, struct hfs_cat_entry **);
-extern int hfs_cat_mkdir(struct hfs_cat_entry *, struct hfs_cat_key *,
-			 struct hfs_cat_entry **);
-extern int hfs_cat_delete(struct hfs_cat_entry *, struct hfs_cat_entry *, int);
-extern int hfs_cat_move(struct hfs_cat_entry *, struct hfs_cat_entry *,
-			struct hfs_cat_entry *, struct hfs_cat_key *,
-			struct hfs_cat_entry **);
-
-/* extent.c */
-extern int hfs_ext_compare(const struct hfs_ext_key *,
-			   const struct hfs_ext_key *);
-extern void hfs_extent_in(struct hfs_fork *, const hfs_byte_t *);
-extern void hfs_extent_out(const struct hfs_fork *, hfs_byte_t *);
-extern int hfs_extent_map(struct hfs_fork *, int, int);
-extern void hfs_extent_adj(struct hfs_fork *);
-extern void hfs_extent_free(struct hfs_fork *);
-
-/* file.c */
-extern int hfs_get_block(struct inode *, sector_t, struct buffer_head *, int);
-
-/* mdb.c */
-extern struct hfs_mdb *hfs_mdb_get(hfs_sysmdb, int, hfs_s32);
-extern void hfs_mdb_commit(struct hfs_mdb *, int);
-extern void hfs_mdb_put(struct hfs_mdb *, int);
-
-/* part_tbl.c */
-extern int hfs_part_find(hfs_sysmdb, int, int, hfs_s32 *, hfs_s32 *);
-
-/* string.c */
-extern unsigned int hfs_strhash(const unsigned char *, unsigned int);
-extern int hfs_strcmp(const unsigned char *, unsigned int, 
-		      const unsigned char *, unsigned int);
-extern int hfs_streq(const unsigned char *, unsigned int, 
-		     const unsigned char *, unsigned int);
-extern void hfs_tolower(unsigned char *, int);
-
-static __inline__ struct dentry 
-*hfs_lookup_dentry(struct dentry *base, const char *name, const int len)
-{
-  struct qstr this;
-
-  this.name = name;
-  this.len = len;
-  this.hash = hfs_strhash(name, len);
-
-  return d_lookup(base, &this);
-}
-
-/* drop a dentry for one of the special directories.
- * it's in the form of base/name/dentry. */
-static __inline__ void hfs_drop_special(struct dentry *base,
-					const struct hfs_name *name,
-					struct dentry *dentry)
-{
-  struct dentry *dparent, *de;
-  
-  dparent = hfs_lookup_dentry(base, name->Name, name->Len);
-  if (dparent) {
-	  de = hfs_lookup_dentry(dparent, dentry->d_name.name, 
-				 dentry->d_name.len);
-	  if (de) {
-		  if (!de->d_inode)
-			  d_drop(de);
-		  dput(de);
-	  }
-	  dput(dparent);
-  }
-}
-
-extern struct dentry_operations hfs_dentry_operations;
 #endif
diff -purN /dev/shm/linux-2.5/fs/hfs/hfs_btree.h linuxppc-2.5-benh/fs/hfs/hfs_btree.h
--- /dev/shm/linux-2.5/fs/hfs/hfs_btree.h	2002-07-20 17:49:48.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/hfs_btree.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,289 +0,0 @@
-/*
- * linux/fs/hfs/hfs_btree.h
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the declarations of the private B-tree
- * structures and functions.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- */
-
-#ifndef _HFS_BTREE_H
-#define _HFS_BTREE_H
-
-#include "hfs.h"
-
-/*================ Variable-like macros ================*/
-
-/* The stickiness of a (struct hfs_bnode) */
-#define HFS_NOT_STICKY	0
-#define HFS_STICKY	1
-
-/* The number of hash buckets in a B-tree's bnode cache */
-#define HFS_CACHELEN	17	/* primes are best? */
-
-/*
- * Legal values for the 'ndType' field of a (struct NodeDescriptor)
- *
- * Reference: _Inside Macintosh: Files_ p. 2-65
- */
-#define ndIndxNode	0x00	/* An internal (index) node */
-#define ndHdrNode	0x01	/* The tree header node (node 0) */
-#define ndMapNode	0x02	/* Holds part of the bitmap of used nodes */
-#define ndLeafNode	0xFF	/* A leaf (ndNHeight==1) node */
-
-/*
- * Legal values for the bthAtrb field of a (struct BTHdrRec)
- *
- * Reference: TN 1150
- */
-#define bthBadClose     0x00000001  /* b-tree not closed properly. not
-                                       used by hfsplus. */
-#define bthBigKeys      0x00000002  /* key length is u16 instead of u8.
-				       used by hfsplus. */
-#define bthVarIndxKeys  0x00000004  /* variable key length instead of
-                                       max key length. use din catalog
-                                       b-tree but not in extents
-                                       b-tree (hfsplus). */
-
-/*================ Function-like macros ================*/
-
-/* Access the cache slot which should contain the desired node */
-#define bhash(tree, node) ((tree)->cache[(node) % HFS_CACHELEN])
-
-/* round up to multiple of sizeof(hfs_u16) */
-#define ROUND(X) ((X + sizeof(hfs_u16) - 1) & ~(sizeof(hfs_u16)-1))
-
-/* Refer to the (base-1) array of offsets in a bnode */
-#define RECTBL(X,N) \
-	(((hfs_u16 *)(hfs_buffer_data((X)->buf)+HFS_SECTOR_SIZE))-(N))
-
-/*================ Private data types ================*/
-
-/*
- * struct BTHdrRec
- *
- * The B-tree header record
- *
- * This data structure is stored in the first node (512-byte block) of
- * each B-tree file.  It contains important information about the
- * B-tree.  Most fields vary over the life of the tree and are
- * indicated by a 'V' in the comments.	The other fields are fixed for
- * the life of the tree and are indicated by a 'F'.
- *
- * Reference: _Inside Macintosh: Files_ pp. 2-68 through 2-69 */
-struct BTHdrRec {
-	hfs_word_t  bthDepth;	/* (V) The number of levels in this B-tree */
-	hfs_lword_t bthRoot;	/* (V) The node number of the root node */
-	hfs_lword_t bthNRecs;	/* (V) The number of leaf records */
-	hfs_lword_t bthFNode;	/* (V) The number of the first leaf node */
-	hfs_lword_t bthLNode;	/* (V) The number of the last leaf node */
-	hfs_word_t  bthNodeSize;	/* (F) The number of bytes in a node (=512) */
-	hfs_word_t  bthKeyLen;	/* (F) The length of a key in an index node */
-	hfs_lword_t bthNNodes;	/* (V) The total number of nodes */
-	hfs_lword_t bthFree;	/* (V) The number of unused nodes */
-        hfs_word_t  bthResv1;   /* reserved */
-        hfs_lword_t bthClpSiz;  /* (F) clump size. not usually used. */
-        hfs_byte_t  bthType;    /* (F) BTree type */
-        hfs_byte_t  bthResv2;   /* reserved */
-        hfs_lword_t bthAtrb;    /* (F) attributes */
-        hfs_lword_t bthResv3[16]; /* Reserved */
-} __attribute__((packed));
-
-/*
- * struct NodeDescriptor
- *
- * The B-tree node descriptor.
- *
- * This structure begins each node in the B-tree file.	It contains
- * important information about the node's contents.  'V' and 'F' in
- * the comments indicate fields that are variable or fixed over the
- * life of a node, where the 'life' of a node is defined as the period
- * between leaving and reentering the free pool.
- *
- * Reference: _Inside Macintosh: Files_ p. 2-64
- */
-struct NodeDescriptor {
-	hfs_lword_t ndFLink;	/* (V) Number of the next node at this level */
-	hfs_lword_t ndBLink;	/* (V) Number of the prev node at this level */
-	hfs_byte_t  ndType;	/* (F) The type of node */
-	hfs_byte_t  ndNHeight;	/* (F) The level of this node (leaves=1) */
-	hfs_word_t  ndNRecs;	/* (V) The number of records in this node */
-	hfs_word_t  ndResv2;	/* Reserved */
-} __attribute__((packed));
-
-/*
- * typedef hfs_cmpfn
- *
- * The type 'hfs_cmpfn' is a comparison function taking 2 keys and
- * returning a positive, negative or zero integer according to the
- * ordering of the two keys (just like strcmp() does for strings).
- */
-typedef int (*hfs_cmpfn)(const void *, const void *);
-
-/*
- * struct hfs_bnode
- *
- * An in-core B-tree node
- *
- * This structure holds information from the NodeDescriptor in native
- * byte-order, a pointer to the buffer which contains the actual
- * node and fields necessary for locking access to the node during
- * updates.  The use of the locking fields is explained with the
- * locking functions.
- */
-struct hfs_bnode {
-	int		    magic;   /* Magic number to guard against
-					wild pointers */
-	hfs_buffer	    buf;     /* The buffer containing the
-					actual node */
-	struct hfs_btree    *tree;   /* The tree to which this node
-					belongs */
-	struct hfs_bnode    *prev;   /* Next node in this hash bucket */
-	struct hfs_bnode    *next;   /* Previous node in this hash
-					bucket */
-	int		    sticky;  /* Boolean: non-zero means keep
-					this node in-core (set for
-					root and head) */
-	hfs_u32		    node;    /* Node number */
-	hfs_u16             nodeSize; /* node size */
-        hfs_u16             keyLen;  /* key length */
-	/* locking related fields: */
-	hfs_wait_queue	    wqueue;  /* Wait queue for write access */
-	hfs_wait_queue	    rqueue;  /* Wait queue for read or reserve
-					access */
-	int		    count;   /* Number of processes accessing
-					this node */
-	int		    resrv;   /* Boolean, true means a process
-					had placed a 'reservation' on
-					this node */
-	int		    lock;    /* Boolean, true means some
-					process has exclusive access,
-					so KEEP OUT */
-	/* fields from the NodeDescriptor in native byte-order: */
-	hfs_u32		    ndFLink;
-	hfs_u32		    ndBLink;
-	hfs_u16		    ndNRecs;
-	hfs_u8		    ndType;
-	hfs_u8		    ndNHeight;
-};
-
-/*
- * struct hfs_btree
- *
- * An in-core B-tree.
- *
- * This structure holds information from the BTHdrRec, MDB
- * (superblock) and other information needed to work with the B-tree.
- */
-struct hfs_btree {
-	int			magic;	       /* Magic number to
-						  guard against wild
-						  pointers */
-	hfs_cmpfn		compare;       /* Comparison function
-						  for this tree */
-	struct hfs_bnode	head;	       /* in-core copy of node 0 */
-	struct hfs_bnode	*root;	       /* Pointer to the in-core
-						  copy of the root node */
-	hfs_sysmdb		sys_mdb;       /* The "device" holding
-						  the filesystem */
-	int			reserved;      /* bnodes claimed but
-						  not yet used */
-	struct hfs_bnode		       /* The bnode cache */
-				*cache[HFS_CACHELEN];
-	struct hfs_cat_entry	entry;	       /* Fake catalog entry */
-	struct semaphore	sem;
-	int			dirt;
-	int                     keySize;   
-	/* Fields from the BTHdrRec in native byte-order: */
-	hfs_u32			bthRoot;
-	hfs_u32			bthNRecs;
-	hfs_u32			bthFNode;
-	hfs_u32			bthLNode;
-	hfs_u32			bthNNodes;
-	hfs_u32			bthFree;
-	hfs_u16			bthKeyLen;
-	hfs_u16			bthDepth;
-};
-
-/*================ Global functions ================*/
-
-/* Convert a (struct hfs_bnode *) and an index to the value of the
-   n-th offset in the bnode (N >= 1) to the offset */
-extern inline hfs_u16 bnode_offset(const struct hfs_bnode *bnode, int n)
-{ return hfs_get_hs(RECTBL(bnode,n)); }
-
-/* Convert a (struct hfs_bnode *) and an index to the size of the
-   n-th record in the bnode (N >= 1) */
-extern inline hfs_u16 bnode_rsize(const struct hfs_bnode *bnode, int n)
-{ return bnode_offset(bnode, n+1) - bnode_offset(bnode, n); }
-
-/* Convert a (struct hfs_bnode *) to the offset of the empty part */
-extern inline hfs_u16 bnode_end(const struct hfs_bnode *bnode)
-{ return bnode_offset(bnode, bnode->ndNRecs + 1); }
-
-/* Convert a (struct hfs_bnode *) to the number of free bytes it contains */
-extern inline hfs_u16 bnode_freespace(const struct hfs_bnode *bnode)
-{ return HFS_SECTOR_SIZE - bnode_end(bnode)
-	  - (bnode->ndNRecs + 1)*sizeof(hfs_u16); }
-
-/* Convert a (struct hfs_bnode *) X and an index N to
-   the address of the record N in the bnode (N >= 1) */
-extern inline void *bnode_datastart(const struct hfs_bnode *bnode)
-{ return (void *)(hfs_buffer_data(bnode->buf)+sizeof(struct NodeDescriptor)); }
-
-/* Convert a (struct hfs_bnode *) to the address of the empty part */
-extern inline void *bnode_dataend(const struct hfs_bnode *bnode)
-{ return (void *)(hfs_buffer_data(bnode->buf) + bnode_end(bnode)); }
-
-/* Convert various pointers to address of record's key */
-extern inline void *bnode_key(const struct hfs_bnode *bnode, int n)
-{ return (void *)(hfs_buffer_data(bnode->buf) + bnode_offset(bnode, n)); }
-extern inline void *belem_key(const struct hfs_belem *elem)
-{ return bnode_key(elem->bnr.bn, elem->record); }
-extern inline void *brec_key(const struct hfs_brec *brec)
-{ return belem_key(brec->bottom); }
-
-/* Convert various pointers to the address of a record */
-extern inline void *bkey_record(const struct hfs_bkey *key)
-{ return (void *)key + ROUND(key->KeyLen + 1); }
-extern inline void *bnode_record(const struct hfs_bnode *bnode, int n)
-{ return bkey_record(bnode_key(bnode, n)); }
-extern inline void *belem_record(const struct hfs_belem *elem)
-{ return bkey_record(belem_key(elem)); }
-extern inline void *brec_record(const struct hfs_brec *brec)
-{ return bkey_record(brec_key(brec)); }
-
-/*================ Function Prototypes ================*/
-
-/* balloc.c */
-extern int hfs_bnode_bitop(struct hfs_btree *, hfs_u32, int);
-extern struct hfs_bnode_ref hfs_bnode_alloc(struct hfs_btree *);
-extern int hfs_bnode_free(struct hfs_bnode_ref *);
-extern void hfs_btree_extend(struct hfs_btree *);
-
-/* bins_del.c */
-extern void hfs_bnode_update_key(struct hfs_brec *, struct hfs_belem *,
-				 struct hfs_bnode *, int);
-extern void hfs_bnode_shift_right(struct hfs_bnode *, struct hfs_bnode *, int);
-extern void hfs_bnode_shift_left(struct hfs_bnode *, struct hfs_bnode *, int);
-extern int hfs_bnode_in_brec(hfs_u32 node, const struct hfs_brec *brec);
-
-/* bnode.c */
-extern void hfs_bnode_read(struct hfs_bnode *, struct hfs_btree *,
-			   hfs_u32, int);
-extern void hfs_bnode_relse(struct hfs_bnode_ref *);
-extern struct hfs_bnode_ref hfs_bnode_find(struct hfs_btree *, hfs_u32, int);
-extern void hfs_bnode_lock(struct hfs_bnode_ref *, int);
-extern void hfs_bnode_delete(struct hfs_bnode *);
-extern void hfs_bnode_commit(struct hfs_bnode *);
-
-/* brec.c */
-extern void hfs_brec_lock(struct hfs_brec *, struct hfs_belem *);
-extern struct hfs_belem *hfs_brec_init(struct hfs_brec *, struct hfs_btree *,
-				       int);
-extern struct hfs_belem *hfs_brec_next(struct hfs_brec *);
-
-#endif
diff -purN /dev/shm/linux-2.5/fs/hfs/hfs_fs.h linuxppc-2.5-benh/fs/hfs/hfs_fs.h
--- /dev/shm/linux-2.5/fs/hfs/hfs_fs.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/hfs_fs.h	2003-12-24 03:24:13.000000000 +0000
@@ -0,0 +1,361 @@
+/*
+ * linux/include/linux/hfs_fs.h
+ *
+ * Copyright (C) 1995-1997  Paul H. Hargrove
+ * This file may be distributed under the terms of the GNU General Public License.
+ *
+ * The source code distribution of the Columbia AppleTalk Package for
+ * UNIX, version 6.0, (CAP) was used as a specification of the
+ * location and format of files used by CAP's Aufs.  No code from CAP
+ * appears in hfs_fs.  hfs_fs is not a work ``derived'' from CAP in
+ * the sense of intellectual property law.
+ *
+ * The source code distributions of Netatalk, versions 1.3.3b2 and
+ * 1.4b2, were used as a specification of the location and format of
+ * files used by Netatalk's afpd.  No code from Netatalk appears in
+ * hfs_fs.  hfs_fs is not a work ``derived'' from Netatalk in the
+ * sense of intellectual property law.
+ */
+
+#ifndef _LINUX_HFS_FS_H
+#define _LINUX_HFS_FS_H
+
+#include <linux/version.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/locks.h>
+#else
+#include <linux/buffer_head.h>
+#endif
+#include <linux/fs.h>
+
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+
+#include "hfs.h"
+
+#define DBG_BNODE_REFS	0x00000001
+#define DBG_BNODE_MOD	0x00000002
+#define DBG_CAT_MOD	0x00000004
+#define DBG_INODE	0x00000008
+#define DBG_SUPER	0x00000010
+#define DBG_EXTENT	0x00000020
+#define DBG_BITMAP	0x00000040
+
+//#define DBG_MASK	(DBG_EXTENT|DBG_INODE|DBG_BNODE_MOD|DBG_CAT_MOD|DBG_BITMAP)
+//#define DBG_MASK	(DBG_BNODE_MOD|DBG_CAT_MOD|DBG_INODE)
+//#define DBG_MASK	(DBG_CAT_MOD|DBG_BNODE_REFS|DBG_INODE|DBG_EXTENT)
+#define DBG_MASK	(0)
+
+#define dprint(flg, fmt, args...) \
+	if (flg & DBG_MASK) printk(fmt , ## args)
+
+#define hfs_warn(format, args...) printk(KERN_WARNING format , ## args)
+#define hfs_error(format, args...) printk(KERN_ERR format , ## args)
+
+/*
+ * struct hfs_inode_info
+ *
+ * The HFS-specific part of a Linux (struct inode)
+ */
+struct hfs_inode_info {
+	atomic_t opencnt;
+
+	unsigned int flags;
+
+	/* to deal with localtime ugliness */
+	int tz_secondswest;
+
+	struct hfs_cat_key cat_key;
+
+	struct list_head open_dir_list;
+	struct inode *rsrc_inode;
+
+	struct semaphore extents_lock;
+
+	u16 alloc_blocks, clump_blocks;
+	/* Allocation extents from catlog record or volume header */
+	hfs_extent_rec first_extents;
+	u16 first_blocks;
+	hfs_extent_rec cached_extents;
+	u16 cached_start, cached_blocks;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	unsigned long phys_size;
+#else
+	loff_t phys_size;
+	struct inode vfs_inode;
+#endif
+};
+
+#define HFS_FLG_RSRC		0x0001
+#define HFS_FLG_EXT_DIRTY	0x0002
+#define HFS_FLG_EXT_NEW		0x0004
+
+#define HFS_IS_RSRC(inode)	(HFS_I(inode)->flags & HFS_FLG_RSRC)
+
+/*
+ * struct hfs_sb_info
+ *
+ * The HFS-specific part of a Linux (struct super_block)
+ */
+struct hfs_sb_info {
+	struct buffer_head *mdb_bh;		/* The hfs_buffer
+						   holding the real
+						   superblock (aka VIB
+						   or MDB) */
+	struct hfs_mdb *mdb;
+	struct buffer_head *alt_mdb_bh;		/* The hfs_buffer holding
+						   the alternate superblock */
+	struct hfs_mdb *alt_mdb;
+	u32 *bitmap;				/* The page holding the
+						   allocation bitmap */
+	struct hfs_btree *ext_tree;			/* Information about
+						   the extents b-tree */
+	struct hfs_btree *cat_tree;			/* Information about
+						   the catalog b-tree */
+	u32 file_count;				/* The number of
+						   regular files in
+						   the filesystem */
+	u32 folder_count;			/* The number of
+						   directories in the
+						   filesystem */
+	u32 next_id;				/* The next available
+						   file id number */
+	u32 clumpablks;				/* The number of allocation
+						   blocks to try to add when
+						   extending a file */
+	u32 fs_start;				/* The first 512-byte
+						   block represented
+						   in the bitmap */
+	u32 part_start;
+	u16 root_files;				/* The number of
+						   regular
+						   (non-directory)
+						   files in the root
+						   directory */
+	u16 root_dirs;				/* The number of
+						   directories in the
+						   root directory */
+	u16 fs_ablocks;				/* The number of
+						   allocation blocks
+						   in the filesystem */
+	u16 free_ablocks;			/* the number of unused
+						   allocation blocks
+						   in the filesystem */
+	u32 alloc_blksz;			/* The size of an
+						   "allocation block" */
+	int s_quiet;				/* Silent failure when
+						   changing owner or mode? */
+	u32 s_type;				/* Type for new files */
+	u32 s_creator;				/* Creator for new files */
+	umode_t s_file_umask;			/* The umask applied to the
+						   permissions on all files */
+	umode_t s_dir_umask;			/* The umask applied to the
+						   permissions on all dirs */
+	uid_t s_uid;				/* The uid of all files */
+	gid_t s_gid;				/* The gid of all files */
+
+	int session, part;
+
+	struct semaphore bitmap_lock;
+
+	unsigned long flags;
+
+	u16 blockoffset;
+
+	int fs_div;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	struct list_head rsrc_inodes;
+#else
+	struct hlist_head rsrc_inodes;
+#endif
+};
+
+#define HFS_FLG_BITMAP_DIRTY	0
+#define HFS_FLG_MDB_DIRTY	1
+#define HFS_FLG_ALT_MDB_DIRTY	2
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+typedef long sector_t;
+#endif
+
+/* bitmap.c */
+extern u32 hfs_vbm_search_free(struct super_block *, u32, u32 *);
+extern int hfs_clear_vbm_bits(struct super_block *, u16, u16);
+
+/* catalog.c */
+extern int hfs_cat_keycmp(const btree_key *, const btree_key *);
+struct hfs_find_data;
+extern int hfs_cat_find_brec(struct super_block *, u32, struct hfs_find_data *);
+extern int hfs_cat_create(u32, struct inode *, struct qstr *, struct inode *);
+extern int hfs_cat_delete(u32, struct inode *, struct qstr *);
+extern int hfs_cat_move(u32, struct inode *, struct qstr *,
+			struct inode *, struct qstr *);
+extern void hfs_cat_build_key(btree_key *, u32, struct qstr *);
+
+/* dir.c */
+extern struct file_operations hfs_dir_operations;
+extern struct inode_operations hfs_dir_inode_operations;
+
+extern int hfs_mkdir(struct inode *, struct dentry *, int);
+extern int hfs_unlink(struct inode *, struct dentry *);
+extern int hfs_rmdir(struct inode *, struct dentry *);
+extern int hfs_rename(struct inode *, struct dentry *,
+		      struct inode *, struct dentry *);
+
+/* extent.c */
+extern int hfs_ext_keycmp(const btree_key *, const btree_key *);
+extern int hfs_free_fork(struct super_block *, struct hfs_cat_file *, int);
+extern void hfs_ext_write_extent(struct inode *);
+extern int hfs_extend_file(struct inode *);
+extern void hfs_file_truncate(struct inode *);
+
+/* file.c */
+extern struct inode_operations hfs_file_inode_operations;
+extern struct file_operations hfs_file_operations;
+
+extern int hfs_get_block(struct inode *, sector_t, struct buffer_head *, int);
+
+/* inode.c */
+extern struct address_space_operations hfs_aops;
+extern struct address_space_operations hfs_btree_aops;
+
+extern struct inode *hfs_new_inode(struct inode *, struct qstr *, int);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+extern void hfs_read_inode(struct inode *, void *);
+#endif
+extern void hfs_inode_write_fork(struct inode *, struct hfs_extent *, u32 *, u32 *);
+extern void hfs_write_inode(struct inode *, int);
+extern int hfs_inode_setattr(struct dentry *, struct iattr *);
+extern void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,
+				u32 log_size, u32 phys_size, u32 clump_size);
+extern struct inode *hfs_iget(struct super_block *, struct hfs_cat_key *, hfs_cat_rec *);
+extern void hfs_clear_inode(struct inode *);
+extern void hfs_delete_inode(struct inode *);
+
+/* mdb.c */
+extern int hfs_mdb_get(struct super_block *);
+extern void hfs_mdb_commit(struct super_block *);
+extern void hfs_mdb_close(struct super_block *);
+extern void hfs_mdb_put(struct super_block *);
+
+/* part_tbl.c */
+extern int hfs_part_find(struct super_block *, sector_t *, sector_t *);
+
+/* string.c */
+extern struct dentry_operations hfs_dentry_operations;
+
+extern int hfs_hash_dentry(struct dentry *, struct qstr *);
+extern int hfs_strcmp(const unsigned char *, unsigned int,
+		      const unsigned char *, unsigned int);
+extern int hfs_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
+
+/* super.c */
+extern struct super_block *hfs_read_super(struct super_block *,void *,int);
+
+/* trans.c */
+extern void hfs_triv2mac(struct hfs_name *, struct qstr *);
+extern int hfs_mac2triv(char *, const struct hfs_name *);
+
+extern struct timezone sys_tz;
+
+/*
+ * There are two time systems.  Both are based on seconds since
+ * a particular time/date.
+ *	Unix:	unsigned lil-endian since 00:00 GMT, Jan. 1, 1970
+ *	mac:	unsigned big-endian since 00:00 GMT, Jan. 1, 1904
+ *
+ */
+#define __hfs_u_to_mtime(sec)	cpu_to_be32(sec + 2082844800U - sys_tz.tz_minuteswest * 60)
+#define __hfs_m_to_utime(sec)	(be32_to_cpu(sec) - 2082844800U  + sys_tz.tz_minuteswest * 60)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define	HFS_I(inode)	((struct hfs_inode_info *)&(inode)->u)
+#define	HFS_SB(sb)	((struct hfs_sb_info *)&(sb)->u)
+
+#define PageUptodate(page)	Page_Uptodate(page)
+#define wait_on_page_locked(page) wait_on_page(page)
+
+#define map_bh(bh, sb, block) ({				\
+	bh->b_dev = kdev_t_to_nr(sb->s_dev);			\
+	bh->b_blocknr = block;					\
+	bh->b_state |= (1UL << BH_Mapped);			\
+})
+#define set_buffer_new(bh)	(bh->b_state |= (1UL << BH_New))
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,21)
+#define new_inode(sb) ({					\
+	struct inode *__inode = get_empty_inode();		\
+	if (__inode) {						\
+		__inode->i_sb = sb;				\
+		__inode->i_dev = sb->s_dev;			\
+		__inode->i_blkbits = sb->s_blocksize_bits;	\
+	}							\
+	__inode;						\
+})
+#endif
+
+#define hfs_m_to_utime(time)	__hfs_m_to_utime(time)
+#define hfs_u_to_mtime(time)	__hfs_u_to_mtime(time)
+#define hfs_mtime()		__hfs_u_to_mtime(CURRENT_TIME)
+
+static inline const char *hfs_mdb_name(struct super_block *sb)
+{
+	return kdevname(sb->s_dev);
+}
+
+#else
+
+#define HFS_I(inode)	(list_entry(inode, struct hfs_inode_info, vfs_inode))
+#define HFS_SB(sb)	((struct hfs_sb_info *)(sb)->s_fs_info)
+
+#define hfs_m_to_utime(time)	(struct timespec){ .tv_sec = __hfs_m_to_utime(time) }
+#define hfs_u_to_mtime(time)	__hfs_u_to_mtime((time).tv_sec)
+#define hfs_mtime()		__hfs_u_to_mtime(get_seconds())
+
+static inline const char *hfs_mdb_name(struct super_block *sb)
+{
+	return sb->s_id;
+}
+
+#endif
+
+static inline void hfs_bitmap_dirty(struct super_block *sb)
+{
+	set_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags);
+	sb->s_dirt = 1;
+}
+
+static inline void hfs_buffer_sync(struct buffer_head *bh)
+{
+	while (buffer_locked(bh)) {
+		wait_on_buffer(bh);
+	}
+	if (buffer_dirty(bh)) {
+		ll_rw_block(WRITE, 1, &bh);
+		wait_on_buffer(bh);
+	}
+}
+
+#define sb_bread512(sb, sec, data) ({			\
+	struct buffer_head *__bh;			\
+	sector_t __block;				\
+	loff_t __start;					\
+	int __offset;					\
+							\
+	__start = (loff_t)(sec) << HFS_SECTOR_SIZE_BITS;\
+	__block = __start >> (sb)->s_blocksize_bits;	\
+	__offset = __start & ((sb)->s_blocksize - 1);	\
+	__bh = sb_bread((sb), __block);			\
+	if (likely(__bh != NULL))			\
+		data = (void *)(__bh->b_data + __offset);\
+	else						\
+		data = NULL;				\
+	__bh;						\
+})
+
+#endif
diff -purN /dev/shm/linux-2.5/fs/hfs/inode.c linuxppc-2.5-benh/fs/hfs/inode.c
--- /dev/shm/linux-2.5/fs/hfs/inode.c	2003-09-05 11:31:49.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/inode.c	2003-12-24 03:48:17.000000000 +0000
@@ -16,244 +16,389 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
 #include <linux/pagemap.h>
-#include <linux/smp_lock.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/mpage.h>
+#endif
+
+#include "hfs_fs.h"
+#include "btree.h"
 
 /*================ Variable-like macros ================*/
 
 #define HFS_VALID_MODE_BITS  (S_IFREG | S_IFDIR | S_IRWXUGO)
 
-/*================ File-local functions ================*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int hfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page, hfs_get_block, wbc);
+}
+#else
+static int hfs_writepage(struct page *page)
+{
+	return block_write_full_page(page, hfs_get_block);
+}
+#endif
 
-/*
- * init_file_inode()
- *
- * Given an HFS catalog entry initialize an inode for a file.
- */
-static void init_file_inode(struct inode *inode, hfs_u8 fork)
+static int hfs_readpage(struct file *file, struct page *page)
 {
-	struct hfs_fork *fk;
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
+	return block_read_full_page(page, hfs_get_block);
+}
 
-	if (fork == HFS_FK_DATA) {
-		inode->i_mode = S_IRWXUGO | S_IFREG;
-	} else {
-		inode->i_mode = S_IRUGO | S_IWUGO | S_IFREG;
-	}
+static int hfs_prepare_write(struct file *file, struct page *page, unsigned from, unsigned to)
+{
+	return cont_prepare_write(page, from, to, hfs_get_block,
+				  &HFS_I(page->mapping->host)->phys_size);
+}
 
-	if (fork == HFS_FK_DATA) {
-#if 0 /* XXX: disable crlf translations for now */
-		hfs_u32 type = hfs_get_nl(entry->info.file.finfo.fdType);
-
-		HFS_I(inode)->convert =
-			((HFS_SB(inode->i_sb)->s_conv == 't') ||
-			 ((HFS_SB(inode->i_sb)->s_conv == 'a') &&
-			  ((type == htonl(0x54455854)) ||   /* "TEXT" */
-			   (type == htonl(0x7474726f)))));  /* "ttro" */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfs_bmap(struct address_space *mapping, long block)
 #else
-		HFS_I(inode)->convert = 0;
+static sector_t hfs_bmap(struct address_space *mapping, sector_t block)
 #endif
-		fk = &entry->u.file.data_fork;
+{
+	return generic_block_bmap(mapping, block, hfs_get_block);
+}
+
+int hfs_releasepage(struct page *page, int mask)
+{
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct hfs_btree *tree;
+	struct hfs_bnode *node;
+	u32 nidx;
+	int i, res = 1;
+
+	switch (inode->i_ino) {
+	case HFS_EXT_CNID:
+		tree = HFS_SB(sb)->ext_tree;
+		break;
+	case HFS_CAT_CNID:
+		tree = HFS_SB(sb)->cat_tree;
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+	if (tree->node_size >= PAGE_CACHE_SIZE) {
+		nidx = page->index >> (tree->node_size_shift - PAGE_CACHE_SHIFT);
+		spin_lock(&tree->hash_lock);
+		node = hfs_bnode_findhash(tree, nidx);
+		if (!node)
+			;
+		else if (atomic_read(&node->refcnt))
+			res = 0;
+		else for (i = 0; i < tree->pages_per_bnode; i++) {
+			if (PageActive(node->page[i])) {
+				res = 0;
+				break;
+			}
+		}
+		if (res && node) {
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		}
+		spin_unlock(&tree->hash_lock);
 	} else {
-		fk = &entry->u.file.rsrc_fork;
-		HFS_I(inode)->convert = 0;
-	}
-	HFS_I(inode)->fork = fk;
-	inode->i_size = fk->lsize;
-	inode->i_blocks = fk->psize;
-	inode->i_nlink = 1;
+		nidx = page->index << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		i = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		spin_lock(&tree->hash_lock);
+		do {
+			node = hfs_bnode_findhash(tree, nidx++);
+			if (!node)
+				continue;
+			if (atomic_read(&node->refcnt)) {
+				res = 0;
+				break;
+			}
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		} while (--i);
+		spin_unlock(&tree->hash_lock);
+	}
+	//printk("releasepage: %lu,%x = %d\n", page->index, mask, res);
+	return res;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfs_direct_IO(int rw, struct inode *inode, struct kiobuf *iobuf,
+			 unsigned long blocknr, int blocksize)
+{
+	return generic_direct_IO(rw, inode, iobuf, blocknr,
+				 blocksize, hfs_get_block);
 }
+#else
+static int hfs_get_blocks(struct inode *inode, sector_t iblock, unsigned long max_blocks,
+			  struct buffer_head *bh_result, int create)
+{
+	int ret;
 
-/*================ Global functions ================*/
+	ret = hfs_get_block(inode, iblock, bh_result, create);
+	if (!ret)
+		bh_result->b_size = (1 << inode->i_blkbits);
+	return ret;
+}
 
-/*
- * hfs_put_inode()
- *
- * This is the put_inode() entry in the super_operations for HFS
- * filesystems.  The purpose is to perform any filesystem-dependent 
- * cleanup necessary when the use-count of an inode falls to zero.
- */
-void hfs_put_inode(struct inode * inode)
+static int hfs_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
+			 loff_t offset, unsigned long nr_segs)
 {
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
+	struct file *file = iocb->ki_filp;
+	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
 
-	lock_kernel();
-	hfs_cat_put(entry);
-	if (atomic_read(&inode->i_count) == 1) {
-	  struct hfs_hdr_layout *tmp = HFS_I(inode)->layout;
+	return blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+				  offset, nr_segs, hfs_get_blocks, NULL);
+}
 
-	  if (tmp) {
-		HFS_I(inode)->layout = NULL;
-		HFS_DELETE(tmp);
-	  }
-	}
-	unlock_kernel();
+static int hfs_writepages(struct address_space *mapping,
+			  struct writeback_control *wbc)
+{
+	return mpage_writepages(mapping, wbc, hfs_get_block);
 }
+#endif
+
+struct address_space_operations hfs_btree_aops = {
+	.readpage	= hfs_readpage,
+	.writepage	= hfs_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= hfs_prepare_write,
+	.commit_write	= generic_commit_write,
+	.bmap		= hfs_bmap,
+	.releasepage	= hfs_releasepage,
+};
+
+struct address_space_operations hfs_aops = {
+	.readpage	= hfs_readpage,
+	.writepage	= hfs_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= hfs_prepare_write,
+	.commit_write	= generic_commit_write,
+	.bmap		= hfs_bmap,
+	.direct_IO	= hfs_direct_IO,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	.writepages	= hfs_writepages,
+#endif
+};
 
 /*
- * hfs_notify_change()
- *
- * Based very closely on fs/msdos/inode.c by Werner Almesberger
- *
- * This is the notify_change() field in the super_operations structure
- * for HFS file systems.  The purpose is to take that changes made to
- * an inode and apply then in a filesystem-dependent manner.  In this
- * case the process has a few of tasks to do:
- *  1) prevent changes to the i_uid and i_gid fields.
- *  2) map file permissions to the closest allowable permissions
- *  3) Since multiple Linux files can share the same on-disk inode under
- *     HFS (for instance the data and resource forks of a file) a change
- *     to permissions must be applied to all other in-core inodes which 
- *     correspond to the same HFS file.
+ * hfs_new_inode
  */
-enum {HFS_NORM, HFS_HDR, HFS_CAP};
-
-static int __hfs_notify_change(struct dentry *dentry, struct iattr * attr, int kind)
+struct inode *hfs_new_inode(struct inode *dir, struct qstr *name, int mode)
 {
-	struct inode *inode = dentry->d_inode;
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-	struct dentry **de = entry->sys_entry;
-	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
-	int error=0, i;
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode = new_inode(sb);
+	if (!inode)
+		return NULL;
 
-	lock_kernel();
+	init_MUTEX(&HFS_I(inode)->extents_lock);
+	INIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);
+	hfs_cat_build_key((btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);
+	inode->i_ino = HFS_SB(sb)->next_id++;
+	inode->i_mode = mode;
+	inode->i_uid = current->fsuid;
+	inode->i_gid = current->fsgid;
+	inode->i_nlink = 1;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+	HFS_I(inode)->flags = 0;
+	HFS_I(inode)->rsrc_inode = NULL;
+	if (S_ISDIR(inode->i_mode)) {
+		inode->i_size = 2;
+		HFS_SB(sb)->folder_count++;
+		if (dir->i_ino == HFS_ROOT_CNID)
+			HFS_SB(sb)->root_dirs++;
+		inode->i_op = &hfs_dir_inode_operations;
+		inode->i_fop = &hfs_dir_operations;
+		//INIT_LIST_HEAD(&HFS_I(inode).open_dir_list);
+	} else if (S_ISREG(inode->i_mode)) {
+		HFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;
+		HFS_SB(sb)->file_count++;
+		if (dir->i_ino == HFS_ROOT_CNID)
+			HFS_SB(sb)->root_files++;
+		inode->i_op = &hfs_file_inode_operations;
+		inode->i_fop = &hfs_file_operations;
+		inode->i_mapping->a_ops = &hfs_aops;
+		HFS_I(inode)->phys_size = 0;
+		HFS_I(inode)->alloc_blocks = 0;
+		HFS_I(inode)->first_blocks = 0;
+		HFS_I(inode)->cached_start = 0;
+		HFS_I(inode)->cached_blocks = 0;
+		memset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));
+		memset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));
+	}
+	insert_inode_hash(inode);
+	mark_inode_dirty(inode);
+	set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
+	sb->s_dirt = 1;
 
-	error = inode_change_ok(inode, attr); /* basic permission checks */
-	if (error) {
-		/* Let netatalk's afpd think chmod() always succeeds */
-		if (hsb->s_afpd &&
-		    (attr->ia_valid == (ATTR_MODE | ATTR_CTIME))) {
-			error = 0;
-		}
-		goto out; 
-	}
+	return inode;
+}
 
-	/* no uig/gid changes and limit which mode bits can be set */
-	if (((attr->ia_valid & ATTR_UID) && 
-	     (attr->ia_uid != hsb->s_uid)) ||
-	    ((attr->ia_valid & ATTR_GID) && 
-	     (attr->ia_gid != hsb->s_gid)) ||
-	    ((attr->ia_valid & ATTR_MODE) &&
-	     (((entry->type == HFS_CDR_DIR) &&
-	       (attr->ia_mode != inode->i_mode))||
-	      (attr->ia_mode & ~HFS_VALID_MODE_BITS)))) {
-		if( hsb->s_quiet ) { 
-			error = 0;
-			goto out;
-		}
-	}
-	
-	if (entry->type == HFS_CDR_DIR) {
-		attr->ia_valid &= ~ATTR_MODE;
-	} else if (attr->ia_valid & ATTR_MODE) {
-		/* Only the 'w' bits can ever change and only all together. */
-		if (attr->ia_mode & S_IWUSR) {
-			attr->ia_mode = inode->i_mode | S_IWUGO;
-		} else {
-			attr->ia_mode = inode->i_mode & ~S_IWUGO;
-		}
-		attr->ia_mode &= ~hsb->s_umask;
-	}
-	/*
-	 * Normal files handle size change in normal way.
-	 * Oddballs are served here.
-	 */
-	if (attr->ia_valid & ATTR_SIZE) {
-		if (kind == HFS_CAP) {
-			inode->i_size = attr->ia_size;
-			if (inode->i_size > HFS_FORK_MAX)
-				inode->i_size = HFS_FORK_MAX;
-			mark_inode_dirty(inode);
-			attr->ia_valid &= ~ATTR_SIZE;
-		} else if (kind == HFS_HDR) {
-			hdr_truncate(inode, attr->ia_size);
-			attr->ia_valid &= ~ATTR_SIZE;
-		}
-	}
-	error = inode_setattr(inode, attr);
-	if (error) 
-		goto out;
-	
-	/* We wouldn't want to mess with the sizes of the other fork */
-	attr->ia_valid &= ~ATTR_SIZE;
-
-	/* We must change all in-core inodes corresponding to this file. */
-	for (i = 0; i < 4; ++i) {
-	  if (de[i] && (de[i] != dentry)) {
-		inode_setattr(de[i]->d_inode, attr);
-	  }
-	}
+void hfs_delete_inode(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
 
-	/* Change the catalog entry if needed */
-	if (attr->ia_valid & ATTR_MTIME) {
-		entry->modify_date = hfs_u_to_mtime(inode->i_mtime.tv_sec);
-		hfs_cat_mark_dirty(entry);
-	}
-	if (attr->ia_valid & ATTR_MODE) {
-		hfs_u8 new_flags;
+	dprint(DBG_INODE, "delete_inode: %lu\n", inode->i_ino);
+	if (S_ISDIR(inode->i_mode)) {
+		HFS_SB(sb)->folder_count--;
+		if (HFS_I(inode)->cat_key.ParID == be32_to_cpu(HFS_ROOT_CNID))
+			HFS_SB(sb)->root_dirs--;
+		set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
+		sb->s_dirt = 1;
+		return;
+	}
+	HFS_SB(sb)->file_count--;
+	if (HFS_I(inode)->cat_key.ParID == be32_to_cpu(HFS_ROOT_CNID))
+		HFS_SB(sb)->root_files--;
+	if (S_ISREG(inode->i_mode)) {
+		if (!inode->i_nlink) {
+			inode->i_size = 0;
+			hfs_file_truncate(inode);
+		}
+	}
+	set_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);
+	sb->s_dirt = 1;
+}
+
+void hfs_inode_read_fork(struct inode *inode, struct hfs_extent *ext,
+			 u32 log_size, u32 phys_size, u32 clump_size)
+{
+	struct super_block *sb = inode->i_sb;
+	u16 count;
+	int i;
+
+	memcpy(HFS_I(inode)->first_extents, ext, sizeof(hfs_extent_rec));
+	for (count = 0, i = 0; i < 3; i++)
+		count += be16_to_cpu(ext[i].count);
+	HFS_I(inode)->first_blocks = count;
+
+	log_size = be32_to_cpu(log_size);
+	inode->i_size = HFS_I(inode)->phys_size = log_size;
+	inode->i_blocks = (log_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	HFS_I(inode)->alloc_blocks = be32_to_cpu(phys_size) /
+				     HFS_SB(sb)->alloc_blksz;
+	HFS_I(inode)->clump_blocks = clump_size / HFS_SB(sb)->alloc_blksz;
+	if (!HFS_I(inode)->clump_blocks)
+		HFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;
+}
+
+struct hfs_iget_data {
+	struct hfs_cat_key *key;
+	hfs_cat_rec *rec;
+};
 
-		if (inode->i_mode & S_IWUSR) {
-			new_flags = entry->u.file.flags & ~HFS_FIL_LOCK;
-		} else {
-			new_flags = entry->u.file.flags | HFS_FIL_LOCK;
-		}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+int hfs_test_inode(struct inode *inode, void *data)
+{
+	struct hfs_iget_data *idata = data;
+	hfs_cat_rec *rec;
 
-		if (new_flags != entry->u.file.flags) {
-			entry->u.file.flags = new_flags;
-			hfs_cat_mark_dirty(entry);
-		}
+	rec = idata->rec;
+	switch (rec->type) {
+	case HFS_CDR_DIR:
+		return inode->i_ino == be32_to_cpu(rec->dir.DirID);
+	case HFS_CDR_FIL:
+		return inode->i_ino == be32_to_cpu(rec->file.FlNum);
+	default:
+		BUG();
+		return 1;
 	}
-	/* size changes handled in hfs_extent_adj() */
-
-out:
-	unlock_kernel();
-	return error;
 }
+#endif
 
-int hfs_notify_change(struct dentry *dentry, struct iattr * attr)
+/*
+ * hfs_read_inode
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+void hfs_read_inode(struct inode *inode, void *data)
+#else
+int hfs_read_inode(struct inode *inode, void *data)
+#endif
 {
-	return __hfs_notify_change(dentry, attr, HFS_NORM);
-}
+	struct hfs_iget_data *idata = data;
+	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
+	hfs_cat_rec *rec;
 
-int hfs_notify_change_cap(struct dentry *dentry, struct iattr * attr)
-{
-	return __hfs_notify_change(dentry, attr, HFS_CAP);
-}
+	HFS_I(inode)->flags = 0;
+	HFS_I(inode)->rsrc_inode = NULL;
+	init_MUTEX(&HFS_I(inode)->extents_lock);
+	INIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	if (inode->i_ino < HFS_FIRSTUSER_CNID) {
+		struct hfs_mdb *mdb = HFS_SB(inode->i_sb)->mdb;
+
+		switch (inode->i_ino) {
+		case HFS_ROOT_CNID:
+			break;
+		case HFS_EXT_CNID:
+			hfs_inode_read_fork(inode, mdb->drXTExtRec, mdb->drXTFlSize,
+					    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));
+			inode->i_mapping->a_ops = &hfs_btree_aops;
+			return;
+		case HFS_CAT_CNID:
+			hfs_inode_read_fork(inode, mdb->drCTExtRec, mdb->drCTFlSize,
+					    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));
+			inode->i_mapping->a_ops = &hfs_btree_aops;
+			return;
+		default:
+			make_bad_inode(inode);
+			return;
+		}
+	}
+#endif
 
-int hfs_notify_change_hdr(struct dentry *dentry, struct iattr * attr)
-{
-	return __hfs_notify_change(dentry, attr, HFS_HDR);
-}
+	/* Initialize the inode */
+	inode->i_uid = hsb->s_uid;
+	inode->i_gid = hsb->s_gid;
+	inode->i_nlink = 1;
 
-static int hfs_writepage(struct page *page, struct writeback_control *wbc)
-{
-	return block_write_full_page(page,hfs_get_block, wbc);
-}
-static int hfs_readpage(struct file *file, struct page *page)
-{
-	return block_read_full_page(page,hfs_get_block);
-}
-static int hfs_prepare_write(struct file *file, struct page *page, unsigned from, unsigned to)
-{
-	return cont_prepare_write(page,from,to,hfs_get_block,
-		&HFS_I(page->mapping->host)->mmu_private);
-}
-static sector_t hfs_bmap(struct address_space *mapping, sector_t block)
-{
-	return generic_block_bmap(mapping,block,hfs_get_block);
+	if (idata->key)
+		HFS_I(inode)->cat_key = *idata->key;
+	else
+		HFS_I(inode)->flags |= HFS_FLG_RSRC;
+	HFS_I(inode)->tz_secondswest = sys_tz.tz_minuteswest * 60;
+
+	rec = idata->rec;
+	switch (rec->type) {
+	case HFS_CDR_FIL:
+		if (!HFS_IS_RSRC(inode)) {
+			hfs_inode_read_fork(inode, rec->file.ExtRec, rec->file.LgLen,
+					    rec->file.PyLen, be16_to_cpu(rec->file.ClpSize));
+		} else {
+			hfs_inode_read_fork(inode, rec->file.RExtRec, rec->file.RLgLen,
+					    rec->file.RPyLen, be16_to_cpu(rec->file.ClpSize));
+		}
+
+		inode->i_ino = be32_to_cpu(rec->file.FlNum);
+		inode->i_mode = S_IRUGO | S_IXUGO;
+		if (!(rec->file.Flags & HFS_FIL_LOCK))
+			inode->i_mode |= S_IWUGO;
+		inode->i_mode &= hsb->s_file_umask;
+		inode->i_mode |= S_IFREG;
+		inode->i_ctime = inode->i_atime = inode->i_mtime =
+				hfs_m_to_utime(rec->file.MdDat);
+		inode->i_op = &hfs_file_inode_operations;
+		inode->i_fop = &hfs_file_operations;
+		inode->i_mapping->a_ops = &hfs_aops;
+		HFS_I(inode)->phys_size = inode->i_size;
+		break;
+	case HFS_CDR_DIR:
+		inode->i_ino = be32_to_cpu(rec->dir.DirID);
+		inode->i_blocks = 0;
+		inode->i_size = be16_to_cpu(rec->dir.Val) + 2;
+		inode->i_mode = S_IFDIR | (S_IRWXUGO & hsb->s_dir_umask);
+		inode->i_ctime = inode->i_atime = inode->i_mtime =
+				hfs_m_to_utime(rec->file.MdDat);
+		inode->i_op = &hfs_dir_inode_operations;
+		inode->i_fop = &hfs_dir_operations;
+		break;
+	default:
+		make_bad_inode(inode);
+	}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	return 0;
+#endif
 }
-struct address_space_operations hfs_aops = {
-	.readpage = hfs_readpage,
-	.writepage = hfs_writepage,
-	.sync_page = block_sync_page,
-	.prepare_write = hfs_prepare_write,
-	.commit_write = generic_commit_write,
-	.bmap = hfs_bmap
-};
 
 /*
  * __hfs_iget()
@@ -263,253 +408,292 @@ struct address_space_operations hfs_aops
  * inode for that file/directory or NULL.  Note that 'type' indicates
  * whether we want the actual file or directory, or the corresponding
  * metadata (AppleDouble header file or CAP metadata file).
- *
- * In an ideal world we could call iget() and would not need this
- * function.  However, since there is no way to even know the inode
- * number until we've found the file/directory in the catalog B-tree
- * that simply won't happen.
- *
- * The main idea here is to look in the catalog B-tree to get the
- * vital info about the file or directory (including the file id which
- * becomes the inode number) and then to call iget() and return the
- * inode if it is complete.  If it is not then we use the catalog
- * entry to fill in the missing info, by calling the appropriate
- * 'fillin' function.  Note that these fillin functions are
- * essentially hfs_*_read_inode() functions, but since there is no way
- * to pass the catalog entry through iget() to such a read_inode()
- * function, we have to call them after iget() returns an incomplete
- * inode to us.	 This is pretty much the same problem faced in the NFS
- * code, and pretty much the same solution. The SMB filesystem deals
- * with this in a different way: by using the address of the
- * kmalloc()'d space which holds the data as the inode number.
- *
- * XXX: Both this function and NFS's corresponding nfs_fhget() would
- * benefit from a way to pass an additional (void *) through iget() to
- * the VFS read_inode() function.
- *
- * this will hfs_cat_put() the entry if it fails.
  */
-struct inode *hfs_iget(struct hfs_cat_entry *entry, ino_t type,
-		       struct dentry *dentry)
+struct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)
 {
-	struct dentry **sys_entry;
-	struct super_block *sb;
+	struct hfs_iget_data data = { key, rec };
 	struct inode *inode;
+	u32 cnid;
 
-	if (!entry) {
+	switch (rec->type) {
+	case HFS_CDR_DIR:
+		cnid = be32_to_cpu(rec->dir.DirID);
+		break;
+	case HFS_CDR_FIL:
+		cnid = be32_to_cpu(rec->file.FlNum);
+		break;
+	default:
 		return NULL;
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	inode = iget4(sb, cnid, NULL, &data);
+	return inode;
+#else
+	inode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);
+	if (inode && (inode->i_state & I_NEW))
+		unlock_new_inode(inode);
+#endif
+	return inode;
+}
 
-	/* If there are several processes all calling __iget() for
-	   the same inode then they will all get the same one back.
-	   The first one to return from __iget() will notice that the
-	   i_mode field of the inode is blank and KNOW that it is
-	   the first to return.  Therefore, it will set the appropriate
-	   'sys_entry' field in the entry and initialize the inode.
-	   All the initialization must be done without sleeping,
-	   or else other processes could end up using a partially
-	   initialized inode.				*/
-
-	sb = entry->mdb->sys_mdb;
-	sys_entry = &entry->sys_entry[HFS_ITYPE_TO_INT(type)];
-
-	if (!(inode = iget(sb, ntohl(entry->cnid) | type))) {
-	        hfs_cat_put(entry);
-	        return NULL;
-	}
-
-	if (!inode->i_mode || (*sys_entry == NULL)) {
-		/* Initialize the inode */
-		struct hfs_sb_info *hsb = HFS_SB(sb);
-
-		inode->i_ctime.tv_sec = inode->i_atime.tv_sec = inode->i_mtime.tv_sec =
-					hfs_m_to_utime(entry->modify_date);
-		inode->i_ctime.tv_nsec = 0;
-		inode->i_mtime.tv_nsec = 0;
-		inode->i_atime.tv_nsec = 0;
-		inode->i_blksize = HFS_SECTOR_SIZE;
-		inode->i_uid = hsb->s_uid;
-		inode->i_gid = hsb->s_gid;
-
-		HFS_I(inode)->mmu_private = 0;
-		HFS_I(inode)->fork = NULL;
-		HFS_I(inode)->convert = 0;
-		HFS_I(inode)->file_type = 0;
-		HFS_I(inode)->dir_size = 0;
-		HFS_I(inode)->default_layout = NULL;
-		HFS_I(inode)->layout = NULL;
-		HFS_I(inode)->magic = HFS_INO_MAGIC;
-		HFS_I(inode)->entry = entry;
-		HFS_I(inode)->tz_secondswest = hfs_to_utc(0);
-
-		hsb->s_ifill(inode, type, hsb->s_version);
-		if (!hsb->s_afpd && (entry->type == HFS_CDR_FIL) &&
-		    (entry->u.file.flags & HFS_FIL_LOCK)) {
-			inode->i_mode &= ~S_IWUGO;
-		}
-		inode->i_mode &= ~hsb->s_umask;
+void hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,
+			  u32 *log_size, u32 *phys_size)
+{
+	memcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));
+
+	if (log_size)
+		*log_size = cpu_to_be32(inode->i_size);
+	if (phys_size)
+		*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *
+					 HFS_SB(inode->i_sb)->alloc_blksz);
+}
+
+void hfs_write_inode(struct inode *inode, int unused)
+{
+	struct hfs_find_data fd;
+	hfs_cat_rec rec;
 
-		if (!inode->i_mode) {
-			iput(inode); /* does an hfs_cat_put */
-			inode = NULL;
-		} else
-			*sys_entry = dentry; /* cache dentry */
+	dprint(DBG_INODE, "hfs_write_inode: %lu\n", inode->i_ino);
+	hfs_ext_write_extent(inode);
 
+	if (inode->i_ino < HFS_FIRSTUSER_CNID) {
+		switch (inode->i_ino) {
+		case HFS_ROOT_CNID:
+			break;
+		case HFS_EXT_CNID:
+			hfs_btree_write(HFS_SB(inode->i_sb)->ext_tree);
+			return;
+		case HFS_CAT_CNID:
+			hfs_btree_write(HFS_SB(inode->i_sb)->cat_tree);
+			return;
+		default:
+			BUG();
+			return;
+		}
 	}
 
-	return inode;
-}
+	if (HFS_IS_RSRC(inode)) {
+		mark_inode_dirty(HFS_I(inode)->rsrc_inode);
+		return;
+	}
 
-/*================ Scheme-specific functions ================*/
+	if (!inode->i_nlink)
+		return;
 
-/* 
- * hfs_cap_ifill()
- *
- * This function serves the same purpose as a read_inode() function does
- * in other filesystems.  It is called by __hfs_iget() to fill in
- * the missing fields of an uninitialized inode under the CAP scheme.
- */
-void hfs_cap_ifill(struct inode * inode, ino_t type, const int version)
-{
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
+	if (hfs_find_init(HFS_SB(inode->i_sb)->cat_tree, &fd))
+		/* panic? */
+		return;
 
-	HFS_I(inode)->d_drop_op = hfs_cap_drop_dentry;
-	if (type == HFS_CAP_FNDR) {
-		inode->i_size = sizeof(struct hfs_cap_info);
-		inode->i_blocks = 0;
-		inode->i_nlink = 1;
-		inode->i_mode = S_IRUGO | S_IWUGO | S_IFREG;
-		inode->i_op = &hfs_cap_info_inode_operations;
-		inode->i_fop = &hfs_cap_info_operations;
-	} else if (entry->type == HFS_CDR_FIL) {
-		init_file_inode(inode, (type == HFS_CAP_DATA) ?
-						HFS_FK_DATA : HFS_FK_RSRC);
-		inode->i_op = &hfs_file_inode_operations;
-		inode->i_fop = &hfs_file_operations;
-		inode->i_mapping->a_ops = &hfs_aops;
-		HFS_I(inode)->mmu_private = inode->i_size;
-	} else { /* Directory */
-		struct hfs_dir *hdir = &entry->u.dir;
+	fd.search_key->cat = HFS_I(inode)->cat_key;
+	if (hfs_brec_find(&fd))
+		/* panic? */
+		goto out;
 
-		inode->i_blocks = 0;
-		inode->i_size = hdir->files + hdir->dirs + 5;
-		HFS_I(inode)->dir_size = 1;
-		if (type == HFS_CAP_NDIR) {
-			inode->i_mode = S_IRWXUGO | S_IFDIR;
-			inode->i_nlink = hdir->dirs + 4;
-			inode->i_op = &hfs_cap_ndir_inode_operations;
-			inode->i_fop = &hfs_cap_dir_operations;
-			HFS_I(inode)->file_type = HFS_CAP_NORM;
-		} else if (type == HFS_CAP_FDIR) {
-			inode->i_mode = S_IRUGO | S_IXUGO | S_IFDIR;
-			inode->i_nlink = 2;
-			inode->i_op = &hfs_cap_fdir_inode_operations;
-			inode->i_fop = &hfs_cap_dir_operations;
-			HFS_I(inode)->file_type = HFS_CAP_FNDR;
-		} else if (type == HFS_CAP_RDIR) {
-			inode->i_mode = S_IRUGO | S_IXUGO | S_IFDIR;
-			inode->i_nlink = 2;
-			inode->i_op = &hfs_cap_rdir_inode_operations;
-			inode->i_fop = &hfs_cap_dir_operations;
-			HFS_I(inode)->file_type = HFS_CAP_RSRC;
+	if (S_ISDIR(inode->i_mode)) {
+		if (fd.entrylength < sizeof(struct hfs_cat_dir))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &rec, fd.entryoffset,
+			   sizeof(struct hfs_cat_dir));
+		if (rec.type != HFS_CDR_DIR ||
+		    be32_to_cpu(rec.dir.DirID) != inode->i_ino) {
 		}
+
+		rec.dir.MdDat = hfs_u_to_mtime(inode->i_mtime);
+		rec.dir.Val = cpu_to_be16(inode->i_size - 2);
+
+		hfs_bnode_write(fd.bnode, &rec, fd.entryoffset,
+			    sizeof(struct hfs_cat_dir));
+	} else {
+		if (fd.entrylength < sizeof(struct hfs_cat_file))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &rec, fd.entryoffset,
+			   sizeof(struct hfs_cat_file));
+		if (rec.type != HFS_CDR_FIL ||
+		    be32_to_cpu(rec.file.FlNum) != inode->i_ino) {
+		}
+
+		if (inode->i_mode & S_IWUSR)
+			rec.file.Flags &= ~HFS_FIL_LOCK;
+		else
+			rec.file.Flags |= HFS_FIL_LOCK;
+		hfs_inode_write_fork(inode, rec.file.ExtRec, &rec.file.LgLen, &rec.file.PyLen);
+		if (HFS_I(inode)->rsrc_inode)
+			hfs_inode_write_fork(HFS_I(inode)->rsrc_inode, rec.file.RExtRec,
+					     &rec.file.RLgLen, &rec.file.RPyLen);
+		rec.file.MdDat = hfs_u_to_mtime(inode->i_mtime);
+
+		hfs_bnode_write(fd.bnode, &rec, fd.entryoffset,
+			    sizeof(struct hfs_cat_file));
 	}
+out:
+	hfs_find_exit(&fd);
 }
 
-/* 
- * hfs_dbl_ifill()
- *
- * This function serves the same purpose as a read_inode() function does
- * in other filesystems.  It is called by __hfs_iget() to fill in
- * the missing fields of an uninitialized inode under the AppleDouble
- * scheme.
- */
-void hfs_dbl_ifill(struct inode * inode, ino_t type, const int version)
+static struct dentry *hfs_file_lookup(struct inode *dir, struct dentry *dentry
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
 {
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
+	struct inode *inode = NULL;
+	hfs_cat_rec rec;
+	struct hfs_find_data fd;
+	int res;
 
-	HFS_I(inode)->d_drop_op = hfs_dbl_drop_dentry;
-	if (type == HFS_DBL_HDR) {
-		if (entry->type == HFS_CDR_FIL) {
-			init_file_inode(inode, HFS_FK_RSRC);
-			inode->i_size += HFS_DBL_HDR_LEN;
-			HFS_I(inode)->default_layout = &hfs_dbl_fil_hdr_layout;
-		} else {
-			inode->i_size = HFS_DBL_HDR_LEN;
-			inode->i_mode = S_IRUGO | S_IWUGO | S_IFREG;
-			inode->i_nlink = 1;
-			HFS_I(inode)->default_layout = &hfs_dbl_dir_hdr_layout;
-		}
-		inode->i_op = &hfs_hdr_inode_operations;
-		inode->i_fop = &hfs_hdr_operations;
-	} else if (entry->type == HFS_CDR_FIL) {
-		init_file_inode(inode, HFS_FK_DATA);
-		inode->i_op = &hfs_file_inode_operations;
-		inode->i_fop = &hfs_file_operations;
-		inode->i_mapping->a_ops = &hfs_aops;
-		HFS_I(inode)->mmu_private = inode->i_size;
-	} else { /* Directory */
-		struct hfs_dir *hdir = &entry->u.dir;
+	if (HFS_IS_RSRC(dir) || strcmp(dentry->d_name.name, "rsrc"))
+		goto out;
 
-		inode->i_blocks = 0;
-		inode->i_nlink = hdir->dirs + 2;
-		inode->i_size = 3 + 2 * (hdir->dirs + hdir->files);
-		inode->i_mode = S_IRWXUGO | S_IFDIR;
-		inode->i_op = &hfs_dbl_dir_inode_operations;
-		inode->i_fop = &hfs_dbl_dir_operations;
-		HFS_I(inode)->file_type = HFS_DBL_NORM;
-		HFS_I(inode)->dir_size = 2;
+	inode = HFS_I(dir)->rsrc_inode;
+	if (inode)
+		goto out;
+
+	inode = new_inode(dir->i_sb);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);
+	fd.search_key->cat = HFS_I(dir)->cat_key;
+	res = hfs_brec_read(&fd, &rec, sizeof(rec));
+	if (!res) {
+		struct hfs_iget_data idata = { NULL, &rec };
+		hfs_read_inode(inode, &idata);
+	}
+	hfs_find_exit(&fd);
+	if (res) {
+		iput(inode);
+		return ERR_PTR(res);
+	}
+	HFS_I(inode)->rsrc_inode = dir;
+	HFS_I(dir)->rsrc_inode = inode;
+	igrab(dir);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	list_add(&inode->i_hash, &HFS_SB(dir->i_sb)->rsrc_inodes);
+#else
+	hlist_add_head(&inode->i_hash, &HFS_SB(dir->i_sb)->rsrc_inodes);
+#endif
+	mark_inode_dirty(inode);
+out:
+	d_add(dentry, inode);
+	return NULL;
+}
+
+void hfs_clear_inode(struct inode *inode)
+{
+	if (HFS_IS_RSRC(inode) && HFS_I(inode)->rsrc_inode) {
+		HFS_I(HFS_I(inode)->rsrc_inode)->rsrc_inode = NULL;
+		iput(HFS_I(inode)->rsrc_inode);
+	}
+}
+
+static int hfs_permission(struct inode *inode, int mask
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
+{
+	if (S_ISREG(inode->i_mode) && mask & MAY_EXEC)
+		return 0;
+	return vfs_permission(inode, mask);
+}
+
+static int hfs_file_open(struct inode *inode, struct file *file)
+{
+	if (HFS_IS_RSRC(inode))
+		inode = HFS_I(inode)->rsrc_inode;
+	if (atomic_read(&file->f_count) != 1)
+		return 0;
+	atomic_inc(&HFS_I(inode)->opencnt);
+	return 0;
+}
+
+static int hfs_file_release(struct inode *inode, struct file *file)
+{
+	//struct super_block *sb = inode->i_sb;
+
+	if (HFS_IS_RSRC(inode))
+		inode = HFS_I(inode)->rsrc_inode;
+	if (atomic_read(&file->f_count) != 0)
+		return 0;
+	if (atomic_dec_and_test(&HFS_I(inode)->opencnt)) {
+		down(&inode->i_sem);
+		hfs_file_truncate(inode);
+		//if (inode->i_flags & S_DEAD) {
+		//	hfs_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);
+		//	hfs_delete_inode(inode);
+		//}
+		up(&inode->i_sem);
 	}
+	return 0;
 }
 
-/* 
- * hfs_nat_ifill()
+/*
+ * hfs_notify_change()
+ *
+ * Based very closely on fs/msdos/inode.c by Werner Almesberger
  *
- * This function serves the same purpose as a read_inode() function does
- * in other filesystems.  It is called by __hfs_iget() to fill in
- * the missing fields of an uninitialized inode under the Netatalk
- * scheme.
+ * This is the notify_change() field in the super_operations structure
+ * for HFS file systems.  The purpose is to take that changes made to
+ * an inode and apply then in a filesystem-dependent manner.  In this
+ * case the process has a few of tasks to do:
+ *  1) prevent changes to the i_uid and i_gid fields.
+ *  2) map file permissions to the closest allowable permissions
+ *  3) Since multiple Linux files can share the same on-disk inode under
+ *     HFS (for instance the data and resource forks of a file) a change
+ *     to permissions must be applied to all other in-core inodes which
+ *     correspond to the same HFS file.
  */
-void hfs_nat_ifill(struct inode * inode, ino_t type, const int version)
+
+int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)
 {
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
+	struct inode *inode = dentry->d_inode;
+	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
+	int error;
 
-	HFS_I(inode)->d_drop_op = hfs_nat_drop_dentry;
-	if (type == HFS_NAT_HDR) {
-		if (entry->type == HFS_CDR_FIL) {
-			init_file_inode(inode, HFS_FK_RSRC);
-			inode->i_size += HFS_NAT_HDR_LEN;
-		} else {
-			inode->i_size = HFS_NAT_HDR_LEN;
-			inode->i_mode = S_IRUGO | S_IWUGO | S_IFREG;
-			inode->i_nlink = 1;
-		}
-		inode->i_op = &hfs_hdr_inode_operations;
-		inode->i_fop = &hfs_hdr_operations;
-		HFS_I(inode)->default_layout = (version == 2) ?
-			&hfs_nat2_hdr_layout : &hfs_nat_hdr_layout;
-	} else if (entry->type == HFS_CDR_FIL) {
-		init_file_inode(inode, HFS_FK_DATA);
-		inode->i_op = &hfs_file_inode_operations;
-		inode->i_fop = &hfs_file_operations;
-		inode->i_mapping->a_ops = &hfs_aops;
-		HFS_I(inode)->mmu_private = inode->i_size;
-	} else { /* Directory */
-		struct hfs_dir *hdir = &entry->u.dir;
+	error = inode_change_ok(inode, attr); /* basic permission checks */
+	if (error)
+		return error;
 
-		inode->i_blocks = 0;
-		inode->i_size = hdir->files + hdir->dirs + 4;
-		inode->i_mode = S_IRWXUGO | S_IFDIR;
-		HFS_I(inode)->dir_size = 1;
-		if (type == HFS_NAT_NDIR) {
-			inode->i_nlink = hdir->dirs + 3;
-			inode->i_op = &hfs_nat_ndir_inode_operations;
-			HFS_I(inode)->file_type = HFS_NAT_NORM;
-		} else if (type == HFS_NAT_HDIR) {
-			inode->i_nlink = 2;
-			inode->i_op = &hfs_nat_hdir_inode_operations;
-			HFS_I(inode)->file_type = HFS_NAT_HDR;
-		}
-		inode->i_fop = &hfs_nat_dir_operations;
+	/* no uig/gid changes and limit which mode bits can be set */
+	if (((attr->ia_valid & ATTR_UID) &&
+	     (attr->ia_uid != hsb->s_uid)) ||
+	    ((attr->ia_valid & ATTR_GID) &&
+	     (attr->ia_gid != hsb->s_gid)) ||
+	    ((attr->ia_valid & ATTR_MODE) &&
+	     ((S_ISDIR(inode->i_mode) &&
+	       (attr->ia_mode != inode->i_mode)) ||
+	      (attr->ia_mode & ~HFS_VALID_MODE_BITS)))) {
+		return hsb->s_quiet ? 0 : error;
+	}
+
+	if (attr->ia_valid & ATTR_MODE) {
+		/* Only the 'w' bits can ever change and only all together. */
+		if (attr->ia_mode & S_IWUSR)
+			attr->ia_mode = inode->i_mode | S_IWUGO;
+		else
+			attr->ia_mode = inode->i_mode & ~S_IWUGO;
+		attr->ia_mode &= S_ISDIR(inode->i_mode) ? ~hsb->s_dir_umask: ~hsb->s_file_umask;
 	}
+	error = inode_setattr(inode, attr);
+	if (error)
+		return error;
+
+	return 0;
 }
+
+
+struct file_operations hfs_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_file_read,
+	.write		= generic_file_write,
+	.mmap		= generic_file_mmap,
+	.fsync		= file_fsync,
+	.open		= hfs_file_open,
+	.release	= hfs_file_release,
+};
+
+struct inode_operations hfs_file_inode_operations = {
+	.lookup		= hfs_file_lookup,
+	.truncate	= hfs_file_truncate,
+	.setattr	= hfs_inode_setattr,
+	.permission	= hfs_permission,
+};
diff -purN /dev/shm/linux-2.5/fs/hfs/mdb.c linuxppc-2.5-benh/fs/hfs/mdb.c
--- /dev/shm/linux-2.5/fs/hfs/mdb.c	2002-02-06 18:53:12.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/mdb.c	2003-12-24 03:48:17.000000000 +0000
@@ -6,23 +6,20 @@
  *
  * This file contains functions for reading/writing the MDB.
  *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
  * In function preconditions the term "valid" applied to a pointer to
  * a structure means that the pointer is non-NULL and the structure it
  * points to has all fields initialized to consistent values.
- *
- * The code in this file initializes some structures which contain
- * pointers by calling memset(&foo, 0, sizeof(foo)).
- * This produces the desired behavior only due to the non-ANSI
- * assumption that the machine representation of NULL is all zeros.
  */
 
-#include "hfs.h"
+#include <linux/cdrom.h>
+#include <linux/genhd.h>
+
+#include "hfs_fs.h"
+#include "btree.h"
 
 /*================ File-local data types ================*/
 
-/* 
+/*
  * The HFS Master Directory Block (MDB).
  *
  * Also known as the Volume Information Block (VIB), this structure is
@@ -32,48 +29,57 @@
  *
  * modified for HFS Extended
  */
-struct raw_mdb {
-	hfs_word_t	drSigWord;	/* Signature word indicating fs type */
-	hfs_lword_t	drCrDate;	/* fs creation date/time */
-	hfs_lword_t	drLsMod;	/* fs modification date/time */
-	hfs_word_t	drAtrb;		/* fs attributes */
-	hfs_word_t	drNmFls;	/* number of files in root directory */
-	hfs_word_t	drVBMSt;	/* location (in 512-byte blocks)
-					   of the volume bitmap */
-	hfs_word_t	drAllocPtr;	/* location (in allocation blocks)
-					   to begin next allocation search */
-	hfs_word_t	drNmAlBlks;	/* number of allocation blocks */
-	hfs_lword_t	drAlBlkSiz;	/* bytes in an allocation block */
-	hfs_lword_t	drClpSiz;	/* clumpsize, the number of bytes to
-					   allocate when extending a file */
-	hfs_word_t	drAlBlSt;	/* location (in 512-byte blocks)
-					   of the first allocation block */
-	hfs_lword_t	drNxtCNID;	/* CNID to assign to the next
-					   file or directory created */
-	hfs_word_t	drFreeBks;	/* number of free allocation blocks */
-	hfs_byte_t	drVN[28];	/* the volume label */
-	hfs_lword_t	drVolBkUp;	/* fs backup date/time */
-	hfs_word_t	drVSeqNum;	/* backup sequence number */
-	hfs_lword_t	drWrCnt;	/* fs write count */
-	hfs_lword_t	drXTClpSiz;	/* clumpsize for the extents B-tree */
-	hfs_lword_t	drCTClpSiz;	/* clumpsize for the catalog B-tree */
-	hfs_word_t	drNmRtDirs;	/* number of directories in
-					   the root directory */
-	hfs_lword_t	drFilCnt;	/* number of files in the fs */
-	hfs_lword_t	drDirCnt;	/* number of directories in the fs */
-	hfs_byte_t	drFndrInfo[32];	/* data used by the Finder */
-	hfs_word_t	drEmbedSigWord;	/* embedded volume signature */
-	hfs_lword_t     drEmbedExtent;  /* starting block number (xdrStABN) 
-					   and number of allocation blocks 
-					   (xdrNumABlks) occupied by embedded
-					   volume */
-	hfs_lword_t	drXTFlSize;	/* bytes in the extents B-tree */
-	hfs_byte_t	drXTExtRec[12];	/* extents B-tree's first 3 extents */
-	hfs_lword_t	drCTFlSize;	/* bytes in the catalog B-tree */
-	hfs_byte_t	drCTExtRec[12];	/* catalog B-tree's first 3 extents */
-} __attribute__((packed));
 
-/*================ Global functions ================*/
+static int hfs_get_last_session(struct super_block *sb,
+				sector_t *start, sector_t *size)
+{
+	struct cdrom_multisession ms_info;
+	struct cdrom_tocentry te;
+	int res;
+
+	/* default values */
+	*start = 0;
+	*size = sb->s_bdev->bd_inode->i_size >> 9;
+	{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev);
+		if (gd && gd->part) {
+			printk("size: %ld,%ld\n", *size,
+				gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects);
+			*size = gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects;
+		}
+#else
+		int part;
+		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev, &part);
+		if (gd && part && gd->part) {
+			printk("size: %ld,%ld\n", *size,
+				gd->part[part-1]->nr_sects);
+			//*size = gd->part[part-1]->nr_sects;
+		} else if (gd && !part) {
+			printk("size: %d,%ld,%ld\n", part, *size,
+				gd->capacity);
+		}
+		put_disk(gd);
+#endif
+	}
+
+	if (HFS_SB(sb)->session >= 0) {
+		te.cdte_track = HFS_SB(sb)->session;
+		te.cdte_format = CDROM_LBA;
+		res = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);
+		if (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {
+			*start = (sector_t)te.cdte_addr.lba << 2;
+			return 0;
+		}
+		printk(KERN_ERR "HFS: Invalid session number or type of track\n");
+		return -EINVAL;
+	}
+	ms_info.addr_format = CDROM_LBA;
+	res = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);
+	if (!res && ms_info.xa_flag)
+		*start = (sector_t)ms_info.addr.lba << 2;
+	return 0;
+}
 
 /*
  * hfs_mdb_get()
@@ -81,135 +87,163 @@ struct raw_mdb {
  * Build the in-core MDB for a filesystem, including
  * the B-trees and the volume bitmap.
  */
-struct hfs_mdb *hfs_mdb_get(hfs_sysmdb sys_mdb, int readonly,
-			    hfs_s32 part_start)
+int hfs_mdb_get(struct super_block *sb)
 {
-	struct hfs_mdb *mdb;
-	hfs_buffer buf;
-	struct raw_mdb *raw;
-	unsigned int bs, block;
-	int lcv, limit;
-	hfs_buffer *bmbuf;
-
-	if (!HFS_NEW(mdb)) {
-		hfs_warn("hfs_fs: out of memory\n");
-		return NULL;
-	}
-
-	memset(mdb, 0, sizeof(*mdb));
-	mdb->magic = HFS_MDB_MAGIC;
-	mdb->sys_mdb = sys_mdb;
-	INIT_LIST_HEAD(&mdb->entry_dirty);
-	init_MUTEX(&mdb->bitmap_sem);
-
-	/* See if this is an HFS filesystem */
-	buf = hfs_buffer_get(sys_mdb, part_start + HFS_MDB_BLK, 1);
-	if (!hfs_buffer_ok(buf)) {
-		hfs_warn("hfs_fs: Unable to read superblock\n");
-		HFS_DELETE(mdb);
-		goto bail2;
-	}
-
-	raw = (struct raw_mdb *)hfs_buffer_data(buf);
-	if (hfs_get_ns(raw->drSigWord) != htons(HFS_SUPER_MAGIC)) {
-		hfs_buffer_put(buf);
-		HFS_DELETE(mdb);
-		goto bail2;
-	}
-	mdb->buf = buf;
-	
-	bs = hfs_get_hl(raw->drAlBlkSiz);
-	if (!bs || (bs & (HFS_SECTOR_SIZE-1))) {
-		hfs_warn("hfs_fs: bad allocation block size %d != 512\n", bs);
-		hfs_buffer_put(buf);
-		HFS_DELETE(mdb);
-		goto bail2;
-	}
-	mdb->alloc_blksz = bs >> HFS_SECTOR_SIZE_BITS;
+	struct buffer_head *bh;
+	struct hfs_mdb *mdb, *mdb2;
+	unsigned int block;
+	char *ptr;
+	int off2, len, size, sect;
+	sector_t part_start, part_size;
+	loff_t off;
+	u16 attrib;
+
+	/* set the device driver to 512-byte blocks */
+	size = sb_min_blocksize(sb, HFS_SECTOR_SIZE);
+	if (!size)
+		return -EINVAL;
+
+	if (hfs_get_last_session(sb, &part_start, &part_size))
+		return -EINVAL;
+	while (1) {
+		/* See if this is an HFS filesystem */
+		bh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);
+		if (!bh)
+			goto out;
+
+		if (mdb->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC))
+			break;
+		brelse(bh);
+
+		/* check for a partition block
+		 * (should do this only for cdrom/loop though)
+		 */
+		if (hfs_part_find(sb, &part_start, &part_size))
+			goto out;
+	}
+
+	HFS_SB(sb)->alloc_blksz = size = be32_to_cpu(mdb->drAlBlkSiz);
+	if (!size || (size & (HFS_SECTOR_SIZE - 1))) {
+		hfs_warn("hfs_fs: bad allocation block size %d\n", size);
+		goto out_bh;
+	}
+
+	size = min(HFS_SB(sb)->alloc_blksz, (u32)PAGE_SIZE);
+	sect = be16_to_cpu(mdb->drAlBlSt) + part_start;
+	/* align block size to first sector */
+	while (sect & ((size - 1) >> HFS_SECTOR_SIZE_BITS))
+		size >>= 1;
+	/* align block size to weird alloc size */
+	while (HFS_SB(sb)->alloc_blksz & (size - 1))
+		size >>= 1;
+	brelse(bh);
+	if (!sb_set_blocksize(sb, size)) {
+		printk("hfs_fs: unable to set blocksize to %u\n", size);
+		goto out;
+	}
+	printk("bs: %u\n", size);
+
+	bh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);
+	if (!bh)
+		goto out;
+	if (mdb->drSigWord != cpu_to_be16(HFS_SUPER_MAGIC))
+		goto out_bh;
+
+	HFS_SB(sb)->mdb_bh = bh;
+	HFS_SB(sb)->mdb = mdb;
 
 	/* These parameters are read from the MDB, and never written */
-	mdb->create_date = hfs_get_hl(raw->drCrDate);
-	mdb->fs_ablocks  = hfs_get_hs(raw->drNmAlBlks);
-	mdb->fs_start    = hfs_get_hs(raw->drAlBlSt) + part_start;
-	mdb->backup_date = hfs_get_hl(raw->drVolBkUp);
-	mdb->clumpablks  = (hfs_get_hl(raw->drClpSiz) / mdb->alloc_blksz)
-						 >> HFS_SECTOR_SIZE_BITS;
-	memcpy(mdb->vname, raw->drVN, sizeof(raw->drVN));
+	HFS_SB(sb)->part_start = part_start;
+	HFS_SB(sb)->fs_ablocks = be16_to_cpu(mdb->drNmAlBlks);
+	HFS_SB(sb)->fs_div = HFS_SB(sb)->alloc_blksz >> sb->s_blocksize_bits;
+	HFS_SB(sb)->clumpablks = be32_to_cpu(mdb->drClpSiz) /
+				 HFS_SB(sb)->alloc_blksz;
+	if (!HFS_SB(sb)->clumpablks)
+		HFS_SB(sb)->clumpablks = 1;
+	HFS_SB(sb)->fs_start = (be16_to_cpu(mdb->drAlBlSt) + part_start) >>
+			       (sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS);
 
 	/* These parameters are read from and written to the MDB */
-	mdb->modify_date  = hfs_get_nl(raw->drLsMod);
-	mdb->attrib       = hfs_get_ns(raw->drAtrb);
-	mdb->free_ablocks = hfs_get_hs(raw->drFreeBks);
-	mdb->next_id      = hfs_get_hl(raw->drNxtCNID);
-	mdb->write_count  = hfs_get_hl(raw->drWrCnt);
-	mdb->root_files   = hfs_get_hs(raw->drNmFls);
-	mdb->root_dirs    = hfs_get_hs(raw->drNmRtDirs);
-	mdb->file_count   = hfs_get_hl(raw->drFilCnt);
-	mdb->dir_count    = hfs_get_hl(raw->drDirCnt);
+	HFS_SB(sb)->free_ablocks = be16_to_cpu(mdb->drFreeBks);
+	HFS_SB(sb)->next_id = be32_to_cpu(mdb->drNxtCNID);
+	HFS_SB(sb)->root_files = be16_to_cpu(mdb->drNmFls);
+	HFS_SB(sb)->root_dirs = be16_to_cpu(mdb->drNmRtDirs);
+	HFS_SB(sb)->file_count = be32_to_cpu(mdb->drFilCnt);
+	HFS_SB(sb)->folder_count = be32_to_cpu(mdb->drDirCnt);
 
 	/* TRY to get the alternate (backup) MDB. */
-	lcv = mdb->fs_start + mdb->fs_ablocks * mdb->alloc_blksz;
-	limit = lcv + mdb->alloc_blksz;
-	for (; lcv < limit; ++lcv) {
-		buf = hfs_buffer_get(sys_mdb, lcv, 1);
-		if (hfs_buffer_ok(buf)) {
-			struct raw_mdb *tmp =
-				(struct raw_mdb *)hfs_buffer_data(buf);
-			
-			if (hfs_get_ns(tmp->drSigWord) ==
-			    htons(HFS_SUPER_MAGIC)) {
-				mdb->alt_buf = buf;
-				break;
-			}
-		}
-		hfs_buffer_put(buf);
+	sect = part_start + part_size - 2;
+	bh = sb_bread512(sb, sect, mdb2);
+	if (bh) {
+		if (mdb2->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC)) {
+			HFS_SB(sb)->alt_mdb_bh = bh;
+			HFS_SB(sb)->alt_mdb = mdb2;
+		} else
+			brelse(bh);
 	}
-	
-	if (mdb->alt_buf == NULL) {
+
+	if (!HFS_SB(sb)->alt_mdb) {
 		hfs_warn("hfs_fs: unable to locate alternate MDB\n");
 		hfs_warn("hfs_fs: continuing without an alternate MDB\n");
 	}
-	
+
+	HFS_SB(sb)->bitmap = (u32 *)__get_free_pages(GFP_KERNEL, PAGE_SIZE < 8192 ? 1 : 0);
+	if (!HFS_SB(sb)->bitmap)
+		goto out;
+
 	/* read in the bitmap */
-	block = hfs_get_hs(raw->drVBMSt) + part_start;
-	bmbuf = mdb->bitmap;
-	lcv = (mdb->fs_ablocks + 4095) / 4096;
-	for ( ; lcv; --lcv, ++bmbuf, ++block) {
-		if (!hfs_buffer_ok(*bmbuf =
-				   hfs_buffer_get(sys_mdb, block, 1))) {
+	block = be16_to_cpu(mdb->drVBMSt) + part_start;
+	off = (loff_t)block << HFS_SECTOR_SIZE_BITS;
+	size = (HFS_SB(sb)->fs_ablocks + 8) / 8;
+	ptr = (u8 *)HFS_SB(sb)->bitmap;
+	while (size) {
+		bh = sb_bread(sb, off >> sb->s_blocksize_bits);
+		if (!bh) {
 			hfs_warn("hfs_fs: unable to read volume bitmap\n");
-			goto bail1;
+			goto out;
 		}
+		off2 = off & (sb->s_blocksize - 1);
+		len = min((int)sb->s_blocksize - off2, size);
+		memcpy(ptr, bh->b_data + off2, len);
+		brelse(bh);
+		ptr += len;
+		off += len;
+		size -= len;
+	}
+
+	HFS_SB(sb)->ext_tree = hfs_btree_open(sb, HFS_EXT_CNID, hfs_ext_keycmp);
+	if (!HFS_SB(sb)->ext_tree) {
+		hfs_warn("hfs_fs: unable to open extent tree\n");
+		goto out;
+	}
+	HFS_SB(sb)->cat_tree = hfs_btree_open(sb, HFS_CAT_CNID, hfs_cat_keycmp);
+	if (!HFS_SB(sb)->cat_tree) {
+		hfs_warn("hfs_fs: unable to open catalog tree\n");
+		goto out;
 	}
 
-	if (!(mdb->ext_tree = hfs_btree_init(mdb, htonl(HFS_EXT_CNID),
-					     raw->drXTExtRec,
-					     hfs_get_hl(raw->drXTFlSize),
-					     hfs_get_hl(raw->drXTClpSiz))) ||
-	    !(mdb->cat_tree = hfs_btree_init(mdb, htonl(HFS_CAT_CNID),
-					     raw->drCTExtRec,
-					     hfs_get_hl(raw->drCTFlSize),
-					     hfs_get_hl(raw->drCTClpSiz)))) {
-		hfs_warn("hfs_fs: unable to initialize data structures\n");
-		goto bail1;
-	}
-
-	if (!(mdb->attrib & htons(HFS_SB_ATTRIB_CLEAN))) {
+	attrib = mdb->drAtrb;
+	if (!(attrib & cpu_to_be16(HFS_SB_ATTRIB_CLEAN))) {
 		hfs_warn("hfs_fs: WARNING: mounting unclean filesystem.\n");
-	} else if (!readonly) {
+		sb->s_flags |= MS_RDONLY;
+	}
+	if (!(sb->s_flags & MS_RDONLY)) {
 		/* Mark the volume uncleanly unmounted in case we crash */
-		hfs_put_ns(mdb->attrib & htons(~HFS_SB_ATTRIB_CLEAN),
-			   raw->drAtrb);
-		hfs_buffer_dirty(mdb->buf);
-		hfs_buffer_sync(mdb->buf);
+		mdb->drAtrb = attrib & cpu_to_be16(~HFS_SB_ATTRIB_CLEAN);
+		mdb->drWrCnt = cpu_to_be32(be32_to_cpu(mdb->drWrCnt) + 1);
+		mdb->drLsMod = hfs_mtime();
+
+		mark_buffer_dirty(HFS_SB(sb)->mdb_bh);
+		hfs_buffer_sync(HFS_SB(sb)->mdb_bh);
 	}
 
-	return mdb;
-
-bail1:
-	hfs_mdb_put(mdb, readonly);
-bail2:
-	return NULL;
+	return 0;
+
+out_bh:
+	brelse(bh);
+out:
+	hfs_mdb_put(sb);
+	return -EIO;
 }
 
 /*
@@ -236,84 +270,88 @@ bail2:
  *   If 'backup' is non-zero then the alternate MDB is also written
  *   and the function doesn't return until it is actually on disk.
  */
-void hfs_mdb_commit(struct hfs_mdb *mdb, int backup)
+void hfs_mdb_commit(struct super_block *sb)
 {
-	struct raw_mdb *raw = (struct raw_mdb *)hfs_buffer_data(mdb->buf);
-
-	/* Commit catalog entries to buffers */
-	hfs_cat_commit(mdb);
+	struct hfs_mdb *mdb = HFS_SB(sb)->mdb;
 
-	/* Commit B-tree data to buffers */
-	hfs_btree_commit(mdb->cat_tree, raw->drCTExtRec, raw->drCTFlSize);
-	hfs_btree_commit(mdb->ext_tree, raw->drXTExtRec, raw->drXTFlSize);
-
-	/* Update write_count and modify_date */
-	++mdb->write_count;
-	mdb->modify_date = hfs_time();
-
-	/* These parameters may have been modified, so write them back */
-	hfs_put_nl(mdb->modify_date,   raw->drLsMod);
-	hfs_put_hs(mdb->free_ablocks,  raw->drFreeBks);
-	hfs_put_hl(mdb->next_id,       raw->drNxtCNID);
-	hfs_put_hl(mdb->write_count,   raw->drWrCnt);
-	hfs_put_hs(mdb->root_files,    raw->drNmFls);
-	hfs_put_hs(mdb->root_dirs,     raw->drNmRtDirs);
-	hfs_put_hl(mdb->file_count,    raw->drFilCnt);
-	hfs_put_hl(mdb->dir_count,     raw->drDirCnt);
-
-	/* write MDB to disk */
-	hfs_buffer_dirty(mdb->buf);
-
-       	/* write the backup MDB, not returning until it is written. 
-         * we only do this when either the catalog or extents overflow
-         * files grow. */
-        if (backup && hfs_buffer_ok(mdb->alt_buf)) {
-		struct raw_mdb *tmp = (struct raw_mdb *)
-			hfs_buffer_data(mdb->alt_buf);
-		
-		if ((hfs_get_hl(tmp->drCTFlSize) < 
-		     hfs_get_hl(raw->drCTFlSize)) ||
-		    (hfs_get_hl(tmp->drXTFlSize) <
-		     hfs_get_hl(raw->drXTFlSize))) {
-			memcpy(hfs_buffer_data(mdb->alt_buf), 
-			       hfs_buffer_data(mdb->buf), HFS_SECTOR_SIZE); 
-			hfs_buffer_dirty(mdb->alt_buf);
-			hfs_buffer_sync(mdb->alt_buf);
+	if (test_and_clear_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags)) {
+		/* These parameters may have been modified, so write them back */
+		mdb->drLsMod = hfs_mtime();
+		mdb->drFreeBks = cpu_to_be16(HFS_SB(sb)->free_ablocks);
+		mdb->drNxtCNID = cpu_to_be32(HFS_SB(sb)->next_id);
+		mdb->drNmFls = cpu_to_be16(HFS_SB(sb)->root_files);
+		mdb->drNmRtDirs = cpu_to_be16(HFS_SB(sb)->root_dirs);
+		mdb->drFilCnt = cpu_to_be32(HFS_SB(sb)->file_count);
+		mdb->drDirCnt = cpu_to_be32(HFS_SB(sb)->folder_count);
+
+		/* write MDB to disk */
+		mark_buffer_dirty(HFS_SB(sb)->mdb_bh);
+	}
+
+	/* write the backup MDB, not returning until it is written.
+	 * we only do this when either the catalog or extents overflow
+	 * files grow. */
+	if (test_and_clear_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags) &&
+	    HFS_SB(sb)->alt_mdb) {
+		hfs_inode_write_fork(HFS_SB(sb)->ext_tree->inode, mdb->drXTExtRec,
+				     &mdb->drXTFlSize, NULL);
+		hfs_inode_write_fork(HFS_SB(sb)->cat_tree->inode, mdb->drCTExtRec,
+				     &mdb->drCTFlSize, NULL);
+		memcpy(HFS_SB(sb)->alt_mdb, HFS_SB(sb)->mdb, HFS_SECTOR_SIZE);
+		HFS_SB(sb)->alt_mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_CLEAN);
+		mark_buffer_dirty(HFS_SB(sb)->alt_mdb_bh);
+		hfs_buffer_sync(HFS_SB(sb)->alt_mdb_bh);
+	}
+
+	if (test_and_clear_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags)) {
+		struct buffer_head *bh;
+		sector_t block;
+		char *ptr;
+		int off, size, len;
+
+		block = be16_to_cpu(HFS_SB(sb)->mdb->drVBMSt) + HFS_SB(sb)->part_start;
+		off = (block << HFS_SECTOR_SIZE_BITS) & (sb->s_blocksize - 1);
+		block >>= sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS;
+		size = (HFS_SB(sb)->fs_ablocks + 7) / 8;
+		ptr = (u8 *)HFS_SB(sb)->bitmap;
+		while (size) {
+			bh = sb_bread(sb, block);
+			if (!bh) {
+				hfs_warn("hfs_fs: unable to read volume bitmap\n");
+				break;
+			}
+			len = min((int)sb->s_blocksize - off, size);
+			memcpy(bh->b_data + off, ptr, len);
+			mark_buffer_dirty(bh);
+			brelse(bh);
+			block++;
+			off = 0;
+			ptr += len;
+			size -= len;
 		}
-        }
+	}
+}
+
+void hfs_mdb_close(struct super_block *sb)
+{
+	/* update volume attributes */
+	if (sb->s_flags & MS_RDONLY)
+		return;
+	HFS_SB(sb)->mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_CLEAN);
+	mark_buffer_dirty(HFS_SB(sb)->mdb_bh);
 }
 
 /*
  * hfs_mdb_put()
  *
  * Release the resources associated with the in-core MDB.  */
-void hfs_mdb_put(struct hfs_mdb *mdb, int readonly) {
-	int lcv;
-
-	/* invalidate cached catalog entries */
-	hfs_cat_invalidate(mdb);
-
+void hfs_mdb_put(struct super_block *sb)
+{
 	/* free the B-trees */
-	hfs_btree_free(mdb->ext_tree);
-	hfs_btree_free(mdb->cat_tree);
-
-	/* free the volume bitmap */
-	for (lcv = 0; lcv < HFS_BM_MAXBLOCKS; ++lcv) {
-		hfs_buffer_put(mdb->bitmap[lcv]);
-	}
-
-	/* update volume attributes */
-	if (!readonly) {
-		struct raw_mdb *raw = 
-				(struct raw_mdb *)hfs_buffer_data(mdb->buf);
-		hfs_put_ns(mdb->attrib, raw->drAtrb);
-		hfs_buffer_dirty(mdb->buf);
-	}
+	hfs_btree_close(HFS_SB(sb)->ext_tree);
+	hfs_btree_close(HFS_SB(sb)->cat_tree);
 
 	/* free the buffers holding the primary and alternate MDBs */
-	hfs_buffer_put(mdb->buf);
-	hfs_buffer_put(mdb->alt_buf);
-
-	/* free the MDB */
-	HFS_DELETE(mdb);
+	brelse(HFS_SB(sb)->mdb_bh);
+	brelse(HFS_SB(sb)->alt_mdb_bh);
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/part_tbl.c linuxppc-2.5-benh/fs/hfs/part_tbl.c
--- /dev/shm/linux-2.5/fs/hfs/part_tbl.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/part_tbl.c	2003-12-24 03:48:17.000000000 +0000
@@ -7,34 +7,15 @@
  * Original code to handle the new style Mac partition table based on
  * a patch contributed by Holger Schemel (aeglos@valinor.owl.de).
  *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
  * In function preconditions the term "valid" applied to a pointer to
  * a structure means that the pointer is non-NULL and the structure it
  * points to has all fields initialized to consistent values.
  *
- * The code in this file initializes some structures which contain
- * pointers by calling memset(&foo, 0, sizeof(foo)).
- * This produces the desired behavior only due to the non-ANSI
- * assumption that the machine representation of NULL is all zeros.
  */
 
-#include "hfs.h"
-
-/*================ File-local data types ================*/
+#include "hfs_fs.h"
 
 /*
- * The Macintosh Driver Descriptor Block
- *
- * On partitioned Macintosh media this is block 0.
- * We really only need the "magic number" to check for partitioned media.
- */
-struct hfs_drvr_desc {
-	hfs_word_t	ddSig;		/* The signature word */
-	/* a bunch more stuff we don't need */
-};
-
-/* 
  * The new style Mac partition map
  *
  * For each partition on the media there is a physical block (512-byte
@@ -42,28 +23,21 @@ struct hfs_drvr_desc {
  * contiguous starting at block 1.
  */
 struct new_pmap {
-	hfs_word_t	pmSig;		/* Signature bytes to verify
-					   that this is a partition
-					   map block */
-	hfs_word_t	reSigPad;	/* padding */
-	hfs_lword_t	pmMapBlkCnt;	/* (At least in block 1) this
-					   is the number of partition
-					   map blocks */
-	hfs_lword_t	pmPyPartStart;	/* The physical block number
-					   of the first block in this
-					   partition */
-	hfs_lword_t	pmPartBlkCnt;	/* The number of physical
-					   blocks in this partition */
-	hfs_byte_t	pmPartName[32];	/* (null terminated?) string
-					   giving the name of this
-					   partition */
-	hfs_byte_t	pmPartType[32];	/* (null terminated?) string
-					   giving the type of this
-					   partition */
+	u16	pmSig;		/* signature */
+	u16	reSigPad;	/* padding */
+	u32	pmMapBlkCnt;	/* partition blocks count */
+	u32	pmPyPartStart;	/* physical block start of partition */
+	u32	pmPartBlkCnt;	/* physical block count of partition */
+	u8	pmPartName[32];	/* (null terminated?) string
+				   giving the name of this
+				   partition */
+	u8	pmPartType[32];	/* (null terminated?) string
+				   giving the type of this
+				   partition */
 	/* a bunch more stuff we don't need */
-};
+} __packed;
 
-/* 
+/*
  * The old style Mac partition map
  *
  * The partition map consists for a 2-byte signature followed by an
@@ -71,95 +45,13 @@ struct new_pmap {
  * one of these.
  */
 struct old_pmap {
-	hfs_word_t		pdSig;	/* Signature bytes */
+	u16		pdSig;	/* Signature bytes */
 	struct 	old_pmap_entry {
-		hfs_lword_t	pdStart;
-		hfs_lword_t	pdSize;
-		hfs_lword_t	pdFSID;
+		u32	pdStart;
+		u32	pdSize;
+		u32	pdFSID;
 	}	pdEntry[42];
-} __attribute__((packed));
-
-/*================ File-local functions ================*/
-
-/*
- * parse_new_part_table()
- *
- * Parse a new style partition map looking for the
- * start and length of the 'part'th HFS partition.
- */
-static int parse_new_part_table(hfs_sysmdb sys_mdb, hfs_buffer buf,
-				int part, hfs_s32 *size, hfs_s32 *start)
-{
-	struct new_pmap *pm = (struct new_pmap *)hfs_buffer_data(buf);
-	hfs_u32 pmap_entries = hfs_get_hl(pm->pmMapBlkCnt);
-	int hfs_part = 0;
-	int entry;
-
-	for (entry = 0; (entry < pmap_entries) && !(*start); ++entry) {
-		if (entry) {
-			/* read the next partition map entry */
-			buf = hfs_buffer_get(sys_mdb, HFS_PMAP_BLK + entry, 1);
-			if (!hfs_buffer_ok(buf)) {
-				hfs_warn("hfs_fs: unable to "
-				         "read partition map.\n");
-				goto bail;
-			}
-			pm = (struct new_pmap *)hfs_buffer_data(buf);
-			if (hfs_get_ns(pm->pmSig) !=
-						htons(HFS_NEW_PMAP_MAGIC)) {
-				hfs_warn("hfs_fs: invalid "
-				         "entry in partition map\n");
-				hfs_buffer_put(buf);
-				goto bail;
-			}
-		}
-
-		/* look for an HFS partition */
-		if (!memcmp(pm->pmPartType,"Apple_HFS",9) && 
-		    ((hfs_part++) == part)) {
-			/* Found it! */
-			*start = hfs_get_hl(pm->pmPyPartStart);
-			*size = hfs_get_hl(pm->pmPartBlkCnt);
-		}
-
-		hfs_buffer_put(buf);
-	}
-
-	return 0;
-
-bail:
-	return 1;
-}
-
-/*
- * parse_old_part_table()
- *
- * Parse a old style partition map looking for the
- * start and length of the 'part'th HFS partition.
- */
-static int parse_old_part_table(hfs_sysmdb sys_mdb, hfs_buffer buf,
-				int part, hfs_s32 *size, hfs_s32 *start)
-{
-	struct old_pmap *pm = (struct old_pmap *)hfs_buffer_data(buf);
-	struct old_pmap_entry *p = &pm->pdEntry[0];
-	int hfs_part = 0;
-
-	while ((p->pdStart || p->pdSize || p->pdFSID) && !(*start)) {
-		/* look for an HFS partition */
-		if ((hfs_get_nl(p->pdFSID) == htonl(0x54465331)/*"TFS1"*/) &&
-		    ((hfs_part++) == part)) {
-			/* Found it! */
-			*start = hfs_get_hl(p->pdStart);
-			*size = hfs_get_hl(p->pdSize);
-		}
-		++p;
-	}
-	hfs_buffer_put(buf);
-
-	return 0;
-}
-
-/*================ Global functions ================*/
+} __packed;
 
 /*
  * hfs_part_find()
@@ -167,78 +59,63 @@ static int parse_old_part_table(hfs_sysm
  * Parse the partition map looking for the
  * start and length of the 'part'th HFS partition.
  */
-int hfs_part_find(hfs_sysmdb sys_mdb, int part, int silent,
-		  hfs_s32 *size, hfs_s32 *start)
+int hfs_part_find(struct super_block *sb,
+		  sector_t *part_start, sector_t *part_size)
 {
-	hfs_buffer buf;
-	hfs_u16 sig;
-	int dd_found = 0;
-	int retval = 1;
-
-	/* Read block 0 to see if this media is partitioned */
-	buf = hfs_buffer_get(sys_mdb, HFS_DD_BLK, 1);
-	if (!hfs_buffer_ok(buf)) {
-		hfs_warn("hfs_fs: Unable to read block 0.\n");
-		goto done;
-	}
-	sig = hfs_get_ns(((struct hfs_drvr_desc *)hfs_buffer_data(buf))->ddSig);
-	hfs_buffer_put(buf);
-
-        if (sig == htons(HFS_DRVR_DESC_MAGIC)) {
-		/* We are definitely on partitioned media. */
-		dd_found = 1;
-	}
-
-	buf = hfs_buffer_get(sys_mdb, HFS_PMAP_BLK, 1);
-	if (!hfs_buffer_ok(buf)) {
-		hfs_warn("hfs_fs: Unable to read block 1.\n");
-		goto done;
-	}
-
-	*size = *start = 0;
-
-	switch (hfs_get_ns(hfs_buffer_data(buf))) {
-	case __constant_htons(HFS_OLD_PMAP_MAGIC):
-		retval = parse_old_part_table(sys_mdb, buf, part, size, start);
-		break;
-
-	case __constant_htons(HFS_NEW_PMAP_MAGIC):
-		retval = parse_new_part_table(sys_mdb, buf, part, size, start);
-		break;
-
-	default:
-		if (dd_found) {
-			/* The media claimed to have a partition map */
-			if (!silent) {
-				hfs_warn("hfs_fs: This disk has an "
-					 "unrecognized partition map type.\n");
+	struct buffer_head *bh;
+	u16 *data;
+	int i, size, res;
+
+	res = -ENOENT;
+	bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK, data);
+	if (!bh)
+		return -EIO;
+
+	switch (be16_to_cpu(*data)) {
+	case HFS_OLD_PMAP_MAGIC:
+	  {
+		struct old_pmap *pm;
+		struct old_pmap_entry *p;
+
+		pm = (struct old_pmap *)bh->b_data;
+		p = pm->pdEntry;
+		size = 42;
+		for (i = 0; i < size; p++, i++) {
+			if (p->pdStart && p->pdSize &&
+			    p->pdFSID == cpu_to_be32(0x54465331)/*"TFS1"*/ &&
+			    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {
+				*part_start += be32_to_cpu(p->pdStart);
+				*part_size = be32_to_cpu(p->pdSize);
+				res = 0;
 			}
-		} else {
-			/* Conclude that the media is not partitioned */
-			retval = 0;
 		}
-		goto done;
-	}
-
-	if (!retval) {
-		if (*start == 0) {
-			if (part) {
-				hfs_warn("hfs_fs: unable to locate "
-				         "HFS partition number %d.\n", part);
-			} else {
-				hfs_warn("hfs_fs: unable to locate any "
-					 "HFS partitions.\n");
+		break;
+	  }
+	case HFS_NEW_PMAP_MAGIC:
+	  {
+		struct new_pmap *pm;
+
+		pm = (struct new_pmap *)bh->b_data;
+		size = be32_to_cpu(pm->pmMapBlkCnt);
+		for (i = 0; i < size;) {
+			if (!memcmp(pm->pmPartType,"Apple_HFS", 9) &&
+			    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {
+				*part_start += be32_to_cpu(pm->pmPyPartStart);
+				*part_size = be32_to_cpu(pm->pmPartBlkCnt);
+				res = 0;
+				break;
 			}
-			retval = 1;
-		} else if (*size < 0) {
-			hfs_warn("hfs_fs: Partition size > 1 Terabyte.\n");
-			retval = 1;
-		} else if (*start < 0) {
-			hfs_warn("hfs_fs: Partition begins beyond 1 "
-				 "Terabyte.\n");
-			retval = 1;
+			brelse(bh);
+			bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK + ++i, pm);
+			if (!bh)
+				return -EIO;
+			if (pm->pmSig != cpu_to_be16(HFS_NEW_PMAP_MAGIC))
+				break;
 		}
+		break;
+	  }
 	}
-done:
-	return retval;
+	brelse(bh);
+
+	return res;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/string.c linuxppc-2.5-benh/fs/hfs/string.c
--- /dev/shm/linux-2.5/fs/hfs/string.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/string.c	2003-12-24 03:48:17.000000000 +0000
@@ -18,7 +18,8 @@
  * "XXX" in a comment is a note to myself to consider changing something.
  */
 
-#include "hfs.h"
+#include "hfs_fs.h"
+#include <linux/dcache.h>
 
 /*================ File-local variables ================*/
 
@@ -32,48 +33,22 @@
  * special case for those two characters.
  */
 static unsigned char caseorder[256] = {
-0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
-0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
-0x20,0x22,0x23,0x28,0x29,0x2A,0x2B,0x2C,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,
-0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,
-0x47,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,
-0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xA9,0xAA,0xAB,0xAC,0xAD,
-0x4E,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,
-0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xAF,0xB0,0xB1,0xB2,0xB3,
-0x4A,0x4C,0x5A,0x60,0x7B,0x7F,0x98,0x4F,0x49,0x51,0x4A,0x4B,0x4C,0x5A,0x60,0x63,
-0x64,0x65,0x6E,0x6F,0x70,0x71,0x7B,0x84,0x85,0x86,0x7F,0x80,0x9A,0x9B,0x9C,0x98,
-0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0x94,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0x4D,0x81,
-0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x55,0x8A,0xCC,0x4D,0x81,
-0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0x26,0x27,0xD4,0x20,0x49,0x4B,0x80,0x82,0x82,
-0xD5,0xD6,0x24,0x25,0x2D,0x2E,0xD7,0xD8,0xA6,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
-0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
-0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
-};
-
-/*
- * unsigned char casefold[]
- *
- * Defines the mapping to lowercase characters on the Macintosh
- *
- * "Inverse" of the 'casefold' from ARDI's code.
- */
-static unsigned char casefold[256] = {
-0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
-0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
-0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
-0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
-0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
-0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x5B,0x5C,0x5D,0x5E,0x5F,
-0x41,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
-0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
-0x8A,0x8C,0x8D,0x8E,0x96,0x9A,0x9F,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
-0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
-0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xBE,0xBF,
-0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
-0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0x88,0x8B,0x9B,0xCF,0xCF,
-0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
-0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
-0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
+	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
+	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
+	0x20,0x22,0x23,0x28,0x29,0x2A,0x2B,0x2C,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,0x36,
+	0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,0x45,0x46,
+	0x47,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,
+	0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xA9,0xAA,0xAB,0xAC,0xAD,
+	0x4E,0x48,0x57,0x59,0x5D,0x5F,0x66,0x68,0x6A,0x6C,0x72,0x74,0x76,0x78,0x7A,0x7E,
+	0x8C,0x8E,0x90,0x92,0x95,0x97,0x9E,0xA0,0xA2,0xA4,0xA7,0xAF,0xB0,0xB1,0xB2,0xB3,
+	0x4A,0x4C,0x5A,0x60,0x7B,0x7F,0x98,0x4F,0x49,0x51,0x4A,0x4B,0x4C,0x5A,0x60,0x63,
+	0x64,0x65,0x6E,0x6F,0x70,0x71,0x7B,0x84,0x85,0x86,0x7F,0x80,0x9A,0x9B,0x9C,0x98,
+	0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0x94,0xBB,0xBC,0xBD,0xBE,0xBF,0xC0,0x4D,0x81,
+	0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0x55,0x8A,0xCC,0x4D,0x81,
+	0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0x26,0x27,0xD4,0x20,0x49,0x4B,0x80,0x82,0x82,
+	0xD5,0xD6,0x24,0x25,0x2D,0x2E,0xD7,0xD8,0xA6,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
+	0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
+	0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
 };
 
 /*================ Global functions ================*/
@@ -81,14 +56,19 @@ static unsigned char casefold[256] = {
 /*
  * Hash a string to an integer in a case-independent way
  */
-unsigned int hfs_strhash(const unsigned char *name, unsigned int len)
+int hfs_hash_dentry(struct dentry *dentry, struct qstr *this)
 {
-	unsigned long hash = init_name_hash();
+	const unsigned char *name = this->name;
+	unsigned int hash, len = this->len;
+
+	if (len > HFS_NAMELEN)
+		len = HFS_NAMELEN;
 
-	while (len--)
-	        hash = partial_name_hash(caseorder[*name++],
-					 hash);
-	return end_name_hash(hash);
+	hash = init_name_hash();
+	for (; len; len--)
+		hash = partial_name_hash(caseorder[*name++], hash);
+	this->hash = end_name_hash(hash);
+	return 0;
 }
 
 /*
@@ -106,39 +86,35 @@ int hfs_strcmp(const unsigned char *s1, 
 	len = (len1 > len2) ? len2 : len1;
 
 	while (len--) {
-		if ((tmp = (int)caseorder[*(s1++)] -
-		     (int)caseorder[*(s2++)])) {
+		tmp = (int)caseorder[*(s1++)] - (int)caseorder[*(s2++)];
+		if (tmp)
 			return tmp;
-		}
 	}
 	return len1 - len2;
 }
 
 /*
  * Test for equality of two strings in the HFS filename character ordering.
+ * return 1 on failure and 0 on success
  */
-int hfs_streq(const unsigned char *s1, unsigned int len1,
-	      const unsigned char *s2, unsigned int len2)
+int hfs_compare_dentry(struct dentry *dentry, struct qstr *s1, struct qstr *s2)
 {
-	if (len1 != len2) {
-		return 0;
-	}
+	const unsigned char *n1, *n2;
+	int len;
 
-	while (len1--) {
-		if (caseorder[*(s1++)] != caseorder[*(s2++)]) {
-			return 0;
-		}
-	}
-	return 1;
-}
+	len = s1->len;
+	if (len >= HFS_NAMELEN) {
+		if (s2->len < HFS_NAMELEN)
+			return 1;
+		len = HFS_NAMELEN;
+	} else if (len != s2->len)
+		return 1;
 
-/*
- * Convert a string to the Macintosh version of lower case.
- */
-void hfs_tolower(unsigned char *p, int len)
-{
+	n1 = s1->name;
+	n2 = s2->name;
 	while (len--) {
-		*p = casefold[*p];
-		++p;
+		if (caseorder[*n1++] != caseorder[*n2++])
+			return 1;
 	}
+	return 0;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/super.c linuxppc-2.5-benh/fs/hfs/super.c
--- /dev/shm/linux-2.5/fs/hfs/super.c	2003-10-02 07:12:01.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/super.c	2003-12-24 03:48:17.000000000 +0000
@@ -22,110 +22,20 @@
  * assumption that the machine representation of NULL is all zeros.
  */
 
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-
-#include <linux/config.h> /* for CONFIG_MAC_PARTITION */
-#include <linux/blkdev.h>
+#include <linux/config.h>
 #include <linux/module.h>
+#include <linux/blkdev.h>
 #include <linux/init.h>
-#include <linux/parser.h>
-#include <linux/smp_lock.h>
 #include <linux/vfs.h>
 
-MODULE_LICENSE("GPL");
-
-/*================ Forward declarations ================*/
-
-static void hfs_read_inode(struct inode *);
-static void hfs_put_super(struct super_block *);
-static int hfs_statfs(struct super_block *, struct kstatfs *);
-static void hfs_write_super(struct super_block *);
-
-static kmem_cache_t * hfs_inode_cachep;
-
-static struct inode *hfs_alloc_inode(struct super_block *sb)
-{
-	struct hfs_inode_info *ei;
-	ei = (struct hfs_inode_info *)kmem_cache_alloc(hfs_inode_cachep, SLAB_KERNEL);
-	if (!ei)
-		return NULL;
-	return &ei->vfs_inode;
-}
-
-static void hfs_destroy_inode(struct inode *inode)
-{
-	kmem_cache_free(hfs_inode_cachep, HFS_I(inode));
-}
-
-static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
-{
-	struct hfs_inode_info *ei = (struct hfs_inode_info *) foo;
-
-	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
-	    SLAB_CTOR_CONSTRUCTOR)
-		inode_init_once(&ei->vfs_inode);
-}
- 
-static int init_inodecache(void)
-{
-	hfs_inode_cachep = kmem_cache_create("hfs_inode_cache",
-					     sizeof(struct hfs_inode_info),
-					     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
-					     init_once, NULL);
-	if (hfs_inode_cachep == NULL)
-		return -ENOMEM;
-	return 0;
-}
-
-static void destroy_inodecache(void)
-{
-	if (kmem_cache_destroy(hfs_inode_cachep))
-		printk(KERN_INFO "hfs_inode_cache: not all structures were freed\n");
-}
-
-/*================ Global variables ================*/
-
-static struct super_operations hfs_super_operations = { 
-	.alloc_inode	= hfs_alloc_inode,
-	.destroy_inode	= hfs_destroy_inode,
-	.read_inode	= hfs_read_inode,
-	.put_inode	= hfs_put_inode,
-	.put_super	= hfs_put_super,
-	.write_super	= hfs_write_super,
-	.statfs		= hfs_statfs,
-};
-
-/*================ File-local variables ================*/
-
-static struct super_block *hfs_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data)
-{
-	return get_sb_bdev(fs_type, flags, dev_name, data, hfs_fill_super);
-}
+#include "hfs_fs.h"
+#include "btree.h"
 
-static struct file_system_type hfs_fs = {
-	.owner		= THIS_MODULE,
-	.name		= "hfs",
-	.get_sb		= hfs_get_sb,
-	.kill_sb	= kill_block_super,
-	.fs_flags	= FS_REQUIRES_DEV,
-};
+const char hfs_version[]="0.96";
 
-/*================ File-local functions ================*/
+static kmem_cache_t *hfs_inode_cachep;
 
-/* 
- * hfs_read_inode()
- *
- * this doesn't actually do much. hfs_iget actually fills in the 
- * necessary inode information.
- */
-static void hfs_read_inode(struct inode *inode)
-{
-  inode->i_mode = 0;
-}
+MODULE_LICENSE("GPL");
 
 /*
  * hfs_write_super()
@@ -148,20 +58,11 @@ static void hfs_read_inode(struct inode 
  */
 static void hfs_write_super(struct super_block *sb)
 {
-	struct hfs_mdb *mdb = HFS_SB(sb)->s_mdb;
-	lock_kernel();
-	/* is this a valid hfs superblock? */
-	if (!sb || sb->s_magic != HFS_SUPER_MAGIC) {
-		unlock_kernel();
-		return;
-	}
-
-	if (!(sb->s_flags & MS_RDONLY)) {
-		/* sync everything to the buffers */
-		hfs_mdb_commit(mdb, 0);
-	}
 	sb->s_dirt = 0;
-	unlock_kernel();
+	if (sb->s_flags & MS_RDONLY)
+		return;
+	/* sync everything to the buffers */
+	hfs_mdb_commit(sb);
 }
 
 /*
@@ -173,18 +74,9 @@ static void hfs_write_super(struct super
  */
 static void hfs_put_super(struct super_block *sb)
 {
-	struct hfs_mdb *mdb = HFS_SB(sb)->s_mdb;
- 
-	if (!(sb->s_flags & MS_RDONLY)) {
-		hfs_mdb_commit(mdb, 0);
-		sb->s_dirt = 0;
-	}
-
+	hfs_mdb_close(sb);
 	/* release the MDB's resources */
-	hfs_mdb_put(mdb, sb->s_flags & MS_RDONLY);
-
-	kfree(sb->s_fs_info);
-	sb->s_fs_info = NULL;
+	hfs_mdb_put(sb);
 }
 
 /*
@@ -196,296 +88,157 @@ static void hfs_put_super(struct super_b
  *
  * changed f_files/f_ffree to reflect the fs_ablock/free_ablocks.
  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfs_statfs(struct super_block *sb, struct statfs *buf)
+#else
 static int hfs_statfs(struct super_block *sb, struct kstatfs *buf)
+#endif
 {
-	struct hfs_mdb *mdb = HFS_SB(sb)->s_mdb;
-
 	buf->f_type = HFS_SUPER_MAGIC;
-	buf->f_bsize = HFS_SECTOR_SIZE;
-	buf->f_blocks = mdb->alloc_blksz * mdb->fs_ablocks;
-	buf->f_bfree = mdb->alloc_blksz * mdb->free_ablocks;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_blocks = (u32)HFS_SB(sb)->fs_ablocks * HFS_SB(sb)->fs_div;
+	buf->f_bfree = (u32)HFS_SB(sb)->free_ablocks * HFS_SB(sb)->fs_div;
 	buf->f_bavail = buf->f_bfree;
-	buf->f_files = mdb->fs_ablocks;  
-	buf->f_ffree = mdb->free_ablocks;
+	buf->f_files = HFS_SB(sb)->fs_ablocks;
+	buf->f_ffree = HFS_SB(sb)->free_ablocks;
 	buf->f_namelen = HFS_NAMELEN;
 
 	return 0;
 }
 
-enum {
-	Opt_version, Opt_uid, Opt_gid, Opt_umask, Opt_part,
-	Opt_type, Opt_creator, Opt_quiet, Opt_afpd,
-	Opt_names_netatalk, Opt_names_trivial, Opt_names_alpha, Opt_names_latin,
-	Opt_names_7bit, Opt_names_8bit, Opt_names_cap,
-	Opt_fork_netatalk, Opt_fork_single, Opt_fork_double, Opt_fork_cap,
-	Opt_case_lower, Opt_case_asis,
-	Opt_conv_binary, Opt_conv_text, Opt_conv_auto,
-};
+static struct inode *hfs_alloc_inode(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return kmem_cache_alloc(hfs_inode_cachep, SLAB_KERNEL);
+#else
+	struct hfs_inode_info *i;
+
+	i = kmem_cache_alloc(hfs_inode_cachep, SLAB_KERNEL);
+	return i ? &i->vfs_inode : NULL;
+#endif
+}
+
+static void hfs_destroy_inode(struct inode *inode)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	kmem_cache_free(hfs_inode_cachep, inode);
+#else
+	kmem_cache_free(hfs_inode_cachep, HFS_I(inode));
+#endif
+}
 
-static match_table_t tokens = {
-	{Opt_version, "version=%u"},
-	{Opt_uid, "uid=%u"},
-	{Opt_gid, "gid=%u"},
-	{Opt_umask, "umask=%o"},
-	{Opt_part, "part=%u"},
-	{Opt_type, "type=%s"},
-	{Opt_creator, "creator=%s"},
-	{Opt_quiet, "quiet"},
-	{Opt_afpd, "afpd"},
-	{Opt_names_netatalk, "names=netatalk"},
-	{Opt_names_trivial, "names=trivial"},
-	{Opt_names_alpha, "names=alpha"},
-	{Opt_names_latin, "names=latin"},
-	{Opt_names_7bit, "names=7bit"},
-	{Opt_names_8bit, "names=8bit"},
-	{Opt_names_cap, "names=cap"},
-	{Opt_names_netatalk, "names=n"},
-	{Opt_names_trivial, "names=t"},
-	{Opt_names_alpha, "names=a"},
-	{Opt_names_latin, "names=l"},
-	{Opt_names_7bit, "names=7"},
-	{Opt_names_8bit, "names=8"},
-	{Opt_names_cap, "names=c"},
-	{Opt_fork_netatalk, "fork=netatalk"},
-	{Opt_fork_single, "fork=single"},
-	{Opt_fork_double, "fork=double"},
-	{Opt_fork_cap, "fork=cap"},
-	{Opt_fork_netatalk, "fork=n"},
-	{Opt_fork_single, "fork=s"},
-	{Opt_fork_double, "fork=d"},
-	{Opt_fork_cap, "fork=c"},
-	{Opt_case_lower, "case=lower"},
-	{Opt_case_asis, "case=asis"},
-	{Opt_case_lower, "case=l"},
-	{Opt_case_asis, "case=a"},
-	{Opt_conv_binary, "conv=binary"},
-	{Opt_conv_text, "conv=text"},
-	{Opt_conv_auto, "conv=auto"},
-	{Opt_conv_binary, "conv=b"},
-	{Opt_conv_text, "conv=t"},
-	{Opt_conv_auto, "conv=a"},
+static struct super_operations hfs_super_operations = {
+	.alloc_inode	= hfs_alloc_inode,
+	.destroy_inode	= hfs_destroy_inode,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	.read_inode2	= hfs_read_inode,
+#endif
+	.write_inode	= hfs_write_inode,
+	.clear_inode	= hfs_clear_inode,
+	.put_super	= hfs_put_super,
+	.write_super	= hfs_write_super,
+	.statfs		= hfs_statfs,
 };
 
 /*
  * parse_options()
- * 
+ *
  * adapted from linux/fs/msdos/inode.c written 1992,93 by Werner Almesberger
  * This function is called by hfs_read_super() to parse the mount options.
  */
-static int parse_options(char *options, struct hfs_sb_info *hsb, int *part)
+static int parse_options(char *options, struct hfs_sb_info *hsb)
 {
-	char *p;
-	char names, fork;
-	substring_t args[MAX_OPT_ARGS];
-	int option;
+	char *this_char, *value;
 
 	/* initialize the sb with defaults */
-	memset(hsb, 0, sizeof(*hsb));
-	hsb->magic = HFS_SB_MAGIC;
-	hsb->s_uid   = current->uid;
-	hsb->s_gid   = current->gid;
-	hsb->s_umask = current->fs->umask;
-	hsb->s_type    = 0x3f3f3f3f;	/* == '????' */
+	hsb->s_uid = current->uid;
+	hsb->s_gid = current->gid;
+	hsb->s_file_umask = 0644;
+	hsb->s_dir_umask = 0755;
+	hsb->s_type = 0x3f3f3f3f;	/* == '????' */
 	hsb->s_creator = 0x3f3f3f3f;	/* == '????' */
-	hsb->s_lowercase = 0;
-	hsb->s_quiet     = 0;
-	hsb->s_afpd      = 0;
-        /* default version. 0 just selects the defaults */
-	hsb->s_version   = 0; 
-	hsb->s_conv = 'b';
-	names = '?';
-	fork = '?';
-	*part = 0;
+	hsb->s_quiet = 0;
+	hsb->part = -1;
+	hsb->session = -1;
 
-	if (!options) {
-		goto done;
-	}
-	while ((p = strsep(&options,",")) != NULL) {
-		int token;
-		if (!*p)
-			continue;
+	if (!options)
+		return 1;
 
-		token = match_token(p, tokens, args);
-		switch (token) {
-		/* Numeric-valued options */
-		case Opt_version:
-			if (match_int(&args[0], &option))
-				return 0;
-			hsb->s_version = option;
-			break;
-		case Opt_uid:
-			if (match_int(&args[0], &option))
-				return 0;
-			hsb->s_uid = option;
-			break;
-		case Opt_gid:
-			if (match_int(&args[0], &option))
-				return 0;
-			hsb->s_gid = option;
-			break;
-		case Opt_umask:
-			if (match_octal(&args[0], &option))
-				return 0;
-			hsb->s_umask = option;
-			break;
-		case Opt_part:
-			if (match_int(&args[0], &option))
-				return 0;
-			*part = option;
-			break;
-		/* String-valued options */
-		case Opt_type:
-			if (strlen(args[0].from) != 4) {
-				return 0;
-			}
-			hsb->s_type = hfs_get_nl(args[0].from);
-			break;
-		case Opt_creator:
-			if (strlen(args[0].from) != 4) {
-				return 0;
-			}
-			hsb->s_creator = hfs_get_nl(args[0].from);
-			break;
-		/* Boolean-valued options */
-		case Opt_quiet:
+	while ((this_char = strsep(&options, ","))) {
+		if (!*this_char)
+			continue;
+		value = strchr(this_char, '=');
+		if (value)
+			*value++ = 0;
+
+	/* Numeric-valued options */
+		if (!strcmp(this_char, "uid")) {
+			if (!value || !*value)
+				return 0;
+			hsb->s_uid = simple_strtoul(value, &value, 0);
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "gid")) {
+			if (!value || !*value)
+				return 0;
+			hsb->s_gid = simple_strtoul(value, &value, 0);
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "umask")) {
+			if (!value || !*value)
+				return 0;
+			hsb->s_file_umask = simple_strtoul(value, &value, 8);
+			hsb->s_dir_umask = hsb->s_file_umask;
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "file_umask")) {
+			if (!value || !*value)
+				return 0;
+			hsb->s_file_umask = simple_strtoul(value, &value, 8);
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "dir_umask")) {
+			if (!value || !*value)
+				return 0;
+			hsb->s_dir_umask = simple_strtoul(value, &value, 8);
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "part")) {
+			if (!value || !*value)
+				return 0;
+			hsb->part = simple_strtoul(value, &value, 0);
+			if (*value)
+				return 0;
+		} else if (!strcmp(this_char, "session")) {
+			if (!value || !*value)
+				return 0;
+			hsb->session = simple_strtoul(value, &value, 0);
+			if (*value)
+				return 0;
+	/* String-valued options */
+		} else if (!strcmp(this_char, "type") && value) {
+			if (strlen(value) != 4)
+				return 0;
+			hsb->s_type = *(u32 *)value;
+		} else if (!strcmp(this_char, "creator") && value) {
+			if (strlen(value) != 4)
+				return 0;
+			hsb->s_creator = *(u32 *)value;
+	/* Boolean-valued options */
+		} else if (!strcmp(this_char, "quiet")) {
+			if (value)
+				return 0;
 			hsb->s_quiet = 1;
-			break;
-		case Opt_afpd:
-			hsb->s_afpd = 1;
-			break;
-		/* Multiple choice options */
-		case Opt_names_netatalk:
-			names = 'n';
-			break;
-		case Opt_names_trivial:
-			names = 't';
-			break;
-		case Opt_names_alpha:
-			names = 'a';
-			break;
-		case Opt_names_latin:
-			names = 'l';
-			break;
-		case Opt_names_7bit:
-			names = '7';
-			break;
-		case Opt_names_8bit:
-			names = '8';
-			break;
-		case Opt_names_cap:
-			names = 'c';
-			break;
-		case Opt_fork_netatalk:
-			fork = 'n';
-			break;
-		case Opt_fork_single:
-			fork = 's';
-			break;
-		case Opt_fork_double:
-			fork = 'd';
-			break;
-		case Opt_fork_cap:
-			fork = 'c';
-			break;
-		case Opt_case_lower:
-			hsb->s_lowercase = 1;
-			break;
-		case Opt_case_asis:
-			hsb->s_lowercase = 0;
-			break;
-		case Opt_conv_binary:
-			hsb->s_conv = 'b';
-			break;
-		case Opt_conv_text:
-			hsb->s_conv = 't';
-			break;
-		case Opt_conv_auto:
-			hsb->s_conv = 'a';
-			break;
-		default:
+		} else
 			return 0;
-		}
-	}
-
-done:
-	/* Parse the "fork" and "names" options */
-	if (fork == '?') {
-		fork = hsb->s_afpd ? 'n' : 'c';
-	}
-	switch (fork) {
-	default:
-	case 'c':
-		hsb->s_ifill = hfs_cap_ifill;
-		hsb->s_reserved1 = hfs_cap_reserved1;
-		hsb->s_reserved2 = hfs_cap_reserved2;
-		break;
-
-	case 's':
-		hfs_warn("hfs_fs: AppleSingle not yet implemented.\n");
-		return 0;
-		/* break; */
-	
-	case 'd':
-		hsb->s_ifill = hfs_dbl_ifill;
-		hsb->s_reserved1 = hfs_dbl_reserved1;
-		hsb->s_reserved2 = hfs_dbl_reserved2;
-		break;
-
-	case 'n':
-		hsb->s_ifill = hfs_nat_ifill;
-		hsb->s_reserved1 = hfs_nat_reserved1;
-		hsb->s_reserved2 = hfs_nat_reserved2;
-		break;
 	}
 
-	if (names == '?') {
-		names = fork;
-	}
-	switch (names) {
-	default:
-	case 'n':
-		hsb->s_nameout = hfs_colon2mac;
-		hsb->s_namein = hfs_mac2nat;
-		break;
-
-	case 'c':
-		hsb->s_nameout = hfs_colon2mac;
-		hsb->s_namein = hfs_mac2cap;
-		break;
-
-	case 't':
-		hsb->s_nameout = hfs_triv2mac;
-		hsb->s_namein = hfs_mac2triv;
-		break;
-
-	case '7':
-		hsb->s_nameout = hfs_prcnt2mac;
-		hsb->s_namein = hfs_mac2seven;
-		break;
-
-	case '8':
-		hsb->s_nameout = hfs_prcnt2mac;
-		hsb->s_namein = hfs_mac2eight;
-		break;
-
-	case 'l':
-		hsb->s_nameout = hfs_latin2mac;
-		hsb->s_namein = hfs_mac2latin;
-		break;
-
- 	case 'a':	/* 's' and 'd' are unadvertised aliases for 'alpha', */
- 	case 's':	/* since 'alpha' is the default if fork=s or fork=d. */
- 	case 'd':	/* (It is also helpful for poor typists!)           */
-		hsb->s_nameout = hfs_prcnt2mac;
-		hsb->s_namein = hfs_mac2alpha;
-		break;
-	}
+	hsb->s_dir_umask &= 0777;
+	hsb->s_file_umask &= 0777;
 
 	return 1;
 }
 
-/*================ Global functions ================*/
-
 /*
  * hfs_read_super()
  *
@@ -497,122 +250,152 @@ done:
  * hfs_btree_init() to get the necessary data about the extents and
  * catalog B-trees and, finally, reading the root inode into memory.
  */
-int hfs_fill_super(struct super_block *s, void *data, int silent)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+struct super_block *hfs_read_super(struct super_block *sb, void *data,
+				   int silent)
+#else
+static int hfs_fill_super(struct super_block *sb, void *data, int silent)
+#endif
 {
 	struct hfs_sb_info *sbi;
-	struct hfs_mdb *mdb;
-	struct hfs_cat_key key;
-	hfs_s32 part_size, part_start;
+	struct hfs_find_data fd;
+	hfs_cat_rec rec;
 	struct inode *root_inode;
-	int part;
+	int res;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	sbi = HFS_SB(sb);
+	memset(sbi, 0, sizeof(struct hfs_sb_info));
+	INIT_LIST_HEAD(&sbi->rsrc_inodes);
+#else
 	sbi = kmalloc(sizeof(struct hfs_sb_info), GFP_KERNEL);
 	if (!sbi)
 		return -ENOMEM;
-	s->s_fs_info = sbi;
+	sb->s_fs_info = sbi;
 	memset(sbi, 0, sizeof(struct hfs_sb_info));
-
-	if (!parse_options((char *)data, sbi, &part)) {
+	INIT_HLIST_HEAD(&sbi->rsrc_inodes);
+#endif
+	res = -EINVAL;
+	if (!parse_options((char *)data, sbi)) {
 		hfs_warn("hfs_fs: unable to parse mount options.\n");
-		goto bail2;
-	}
-
-	/* set the device driver to 512-byte blocks */
-	sb_set_blocksize(s, HFS_SECTOR_SIZE);
-
-#ifdef CONFIG_MAC_PARTITION
-	/* check to see if we're in a partition */
-	mdb = hfs_mdb_get(s, s->s_flags & MS_RDONLY, 0);
-
-	/* erk. try parsing the partition table ourselves */
-	if (!mdb) {
-		if (hfs_part_find(s, part, silent, &part_size, &part_start)) {
-	    		goto bail2;
-	  	}
-	  	mdb = hfs_mdb_get(s, s->s_flags & MS_RDONLY, part_start);
-	}
-#else
-	if (hfs_part_find(s, part, silent, &part_size, &part_start)) {
-		goto bail2;
+		goto bail3;
 	}
 
-	mdb = hfs_mdb_get(s, s->s_flags & MS_RDONLY, part_start);
-#endif
+	sb->s_op = &hfs_super_operations;
+	init_MUTEX(&sbi->bitmap_lock);
 
-	if (!mdb) {
-		if (!silent) {
+	res = hfs_mdb_get(sb);
+	if (res) {
+		if (!silent)
 			hfs_warn("VFS: Can't find a HFS filesystem on dev %s.\n",
-			       s->s_id);
-		}
+				hfs_mdb_name(sb));
 		goto bail2;
 	}
 
-	sbi->s_mdb = mdb;
-	if (HFS_ITYPE(mdb->next_id) != 0) {
-		hfs_warn("hfs_fs: too many files.\n");
-		goto bail1;
-	}
-
-	s->s_magic = HFS_SUPER_MAGIC;
-	s->s_op = &hfs_super_operations;
-
 	/* try to get the root inode */
-	hfs_cat_build_key(htonl(HFS_POR_CNID),
-			  (struct hfs_name *)(mdb->vname), &key);
-
-	root_inode = hfs_iget(hfs_cat_get(mdb, &key), HFS_ITYPE_NORM, NULL);
-	if (!root_inode) 
+	hfs_find_init(HFS_SB(sb)->cat_tree, &fd);
+	res = hfs_cat_find_brec(sb, HFS_ROOT_CNID, &fd);
+	if (!res)
+		hfs_bnode_read(fd.bnode, &rec, fd.entryoffset, fd.entrylength);
+	if (res) {
+		hfs_find_exit(&fd);
+		goto bail_no_root;
+	}
+	root_inode = hfs_iget(sb, &fd.search_key->cat, &rec);
+	hfs_find_exit(&fd);
+	if (!root_inode)
 		goto bail_no_root;
-	  
-	s->s_root = d_alloc_root(root_inode);
-	if (!s->s_root) 
+
+	sb->s_root = d_alloc_root(root_inode);
+	if (!sb->s_root)
 		goto bail_no_root;
 
-	/* fix up pointers. */
-	HFS_I(root_inode)->entry->sys_entry[HFS_ITYPE_TO_INT(HFS_ITYPE_NORM)] =
-	  s->s_root;
-	s->s_root->d_op = &hfs_dentry_operations;
+	sb->s_root->d_op = &hfs_dentry_operations;
 
 	/* everything's okay */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return sb;
+#else
 	return 0;
+#endif
 
-bail_no_root: 
+bail_no_root:
 	hfs_warn("hfs_fs: get root inode failed.\n");
-	iput(root_inode);
-bail1:
-	hfs_mdb_put(mdb, s->s_flags & MS_RDONLY);
+	hfs_mdb_put(sb);
 bail2:
+bail3:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return NULL;
+#else
 	kfree(sbi);
-	s->s_fs_info = NULL;
-	return -EINVAL;	
+	return res;
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define HFS_INODE_SIZE      max(sizeof(struct inode), (sizeof(struct hfs_inode_info) + offsetof(struct inode, u)))
+
+static DECLARE_FSTYPE_DEV(hfs_fs_type, "hfs", hfs_read_super);
+
+EXPORT_NO_SYMBOLS;
+
+#else
+
+#define HFS_INODE_SIZE      sizeof(struct hfs_inode_info)
+
+static struct super_block *hfs_get_sb(struct file_system_type *fs_type,
+				      int flags, const char *dev_name, void *data)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, hfs_fill_super);
+}
+
+static struct file_system_type hfs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "hfs",
+	.get_sb		= hfs_get_sb,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+#endif
+
+static void hfs_init_once(void *p, kmem_cache_t *cachep, unsigned long flags)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	struct inode *i = p;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) == SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(i);
+#else
+	struct hfs_inode_info *i = p;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) == SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&i->vfs_inode);
+#endif
 }
 
 static int __init init_hfs_fs(void)
 {
-	int err = init_inodecache();
-	if (err)
-		goto out1;
-        hfs_cat_init();
-	err = register_filesystem(&hfs_fs);
+	int err;
+
+	hfs_inode_cachep = kmem_cache_create("hfs_inode_cache",
+		HFS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN,
+		hfs_init_once, NULL);
+	if (!hfs_inode_cachep)
+		return -ENOMEM;
+	err = register_filesystem(&hfs_fs_type);
 	if (err)
-		goto out;
-	return 0;
-out:
-	hfs_cat_free();
-	destroy_inodecache();
-out1:
+		kmem_cache_destroy(hfs_inode_cachep);
 	return err;
 }
 
-static void __exit exit_hfs_fs(void) {
-	hfs_cat_free();
-	unregister_filesystem(&hfs_fs);
-	destroy_inodecache();
+static void __exit exit_hfs_fs(void)
+{
+	unregister_filesystem(&hfs_fs_type);
+	if (kmem_cache_destroy(hfs_inode_cachep))
+		printk(KERN_INFO "hfs_inode_cache: not all structures were freed\n");
 }
 
 module_init(init_hfs_fs)
 module_exit(exit_hfs_fs)
-
-#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
-long int hfs_alloc = 0;
-#endif
diff -purN /dev/shm/linux-2.5/fs/hfs/sysdep.c linuxppc-2.5-benh/fs/hfs/sysdep.c
--- /dev/shm/linux-2.5/fs/hfs/sysdep.c	2003-07-03 13:36:44.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/sysdep.c	2003-12-24 03:48:17.000000000 +0000
@@ -13,97 +13,45 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-#include <linux/smp_lock.h>
-
-static int hfs_revalidate_dentry(struct dentry *, struct nameidata *);
-static int hfs_hash_dentry(struct dentry *, struct qstr *);
-static int hfs_compare_dentry(struct dentry *, struct qstr *, struct qstr *);
-static void hfs_dentry_iput(struct dentry *, struct inode *);
-struct dentry_operations hfs_dentry_operations =
-{
-	.d_revalidate	= hfs_revalidate_dentry,	
-	.d_hash		= hfs_hash_dentry,
-	.d_compare	= hfs_compare_dentry,
-	.d_iput		= hfs_dentry_iput,
-};
-
-/*
- * hfs_buffer_get()
- *
- * Return a buffer for the 'block'th block of the media.
- * If ('read'==0) then the buffer is not read from disk.
- */
-hfs_buffer hfs_buffer_get(hfs_sysmdb sys_mdb, int block, int read) {
-	hfs_buffer tmp = HFS_BAD_BUFFER;
-
-	if (read) {
-		tmp = sb_bread(sys_mdb, block);
-	} else {
-		tmp = sb_getblk(sys_mdb, block);
-		if (tmp) {
-			set_buffer_uptodate(tmp);
-		}
-	}
-	if (!tmp) {
-		hfs_error("hfs_fs: unable to read block 0x%08x from dev %s\n",
-			  block, hfs_mdb_name(sys_mdb));
-	}
-
-	return tmp;
-}
+#include "hfs_fs.h"
 
 /* dentry case-handling: just lowercase everything */
 
-/* hfs_strhash now uses the same hashing function as the dcache. */
-static int hfs_hash_dentry(struct dentry *dentry, struct qstr *this)
-{
-	if (this->len > HFS_NAMELEN)
-	        return 0;
-	
-	this->hash = hfs_strhash(this->name, this->len);
-	return 0;
-}
-
-/* return 1 on failure and 0 on success */
-static int hfs_compare_dentry(struct dentry *dentry, struct qstr *a, 
-			      struct qstr *b)
-{
-	if (a->len != b->len) return 1;
-
-	if (a->len > HFS_NAMELEN)
-	  return 1;
-
-	return !hfs_streq(a->name, a->len, b->name, b->len);
-}
-
-static void hfs_dentry_iput(struct dentry *dentry, struct inode *inode)
-{
-	struct hfs_cat_entry *entry = HFS_I(inode)->entry;
-
-	lock_kernel();
-	entry->sys_entry[HFS_ITYPE_TO_INT(HFS_ITYPE(inode->i_ino))] = NULL;
-	unlock_kernel();
-	iput(inode);
-}
-
-static int hfs_revalidate_dentry(struct dentry *dentry, struct nameidata *nd)
+static int hfs_revalidate_dentry(struct dentry *dentry,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		struct nameidata *nd
+#else
+		int flags
+#endif
+		)
 {
 	struct inode *inode = dentry->d_inode;
 	int diff;
 
+	if(!inode)
+		return 1;
+
 	/* fix up inode on a timezone change */
-	lock_kernel();
-	if (inode && 
-	    (diff = (hfs_to_utc(0) - HFS_I(inode)->tz_secondswest))) {
+	diff = sys_tz.tz_minuteswest * 60 - HFS_I(inode)->tz_secondswest;
+	if (diff) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		inode->i_ctime.tv_sec += diff;
 		inode->i_atime.tv_sec += diff;
 		inode->i_mtime.tv_sec += diff;
+#else
+		inode->i_ctime += diff;
+		inode->i_atime += diff;
+		inode->i_mtime += diff;
+#endif
 		HFS_I(inode)->tz_secondswest += diff;
 	}
-	unlock_kernel();
 	return 1;
 }
+
+struct dentry_operations hfs_dentry_operations =
+{
+	.d_revalidate	= hfs_revalidate_dentry,
+	.d_hash		= hfs_hash_dentry,
+	.d_compare	= hfs_compare_dentry,
+};
+
diff -purN /dev/shm/linux-2.5/fs/hfs/trans.c linuxppc-2.5-benh/fs/hfs/trans.c
--- /dev/shm/linux-2.5/fs/hfs/trans.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/trans.c	2003-12-24 03:48:17.000000000 +0000
@@ -29,278 +29,11 @@
  * points to has all fields initialized to consistent values.
  */
 
-#include "hfs.h"
-#include <linux/hfs_fs_sb.h>
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs.h>
-
-/*================ File-local variables ================*/
-
-/* int->ASCII map for a single hex digit */
-static char hex[16] = {'0','1','2','3','4','5','6','7',
-		       '8','9','a','b','c','d','e','f'};
-/*
- * Latin-1 to Mac character set map
- *
- * For the sake of consistency this map is generated from the Mac to
- * Latin-1 map the first time it is needed.  This means there is just
- * one map to maintain.
- */
-static unsigned char latin2mac_map[128]; /* initially all zero */
-
-/*
- * Mac to Latin-1 map for the upper 128 characters (both have ASCII in
- * the lower 128 positions)
- */
-static unsigned char mac2latin_map[128] = {
-	0xC4, 0xC5, 0xC7, 0xC9, 0xD1, 0xD6, 0xDC, 0xE1,
-	0xE0, 0xE2, 0xE4, 0xE3, 0xE5, 0xE7, 0xE9, 0xE8,
-	0xEA, 0xEB, 0xED, 0xEC, 0xEE, 0xEF, 0xF1, 0xF3,
-	0xF2, 0xF4, 0xF6, 0xF5, 0xFA, 0xF9, 0xFB, 0xFC,
-	0x00, 0xB0, 0xA2, 0xA3, 0xA7, 0xB7, 0xB6, 0xDF,
-	0xAE, 0xA9, 0x00, 0xB4, 0xA8, 0x00, 0xC6, 0xD8,
-	0x00, 0xB1, 0x00, 0x00, 0xA5, 0xB5, 0xF0, 0x00, 
-	0x00, 0x00, 0x00, 0xAA, 0xBA, 0x00, 0xE6, 0xF8,
-	0xBF, 0xA1, 0xAC, 0x00, 0x00, 0x00, 0x00, 0xAB,
-	0xBB, 0x00, 0xA0, 0xC0, 0xC3, 0xD5, 0x00, 0x00, 
-	0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x00, 
-	0xFF, 0x00, 0x00, 0xA4, 0x00, 0x00, 0x00, 0x00, 
-	0x00, 0x00, 0xB8, 0x00, 0x00, 0xC2, 0xCA, 0xC1,
-	0xCB, 0xC8, 0xCD, 0xCE, 0xCF, 0xCC, 0xD3, 0xD4,
-	0x00, 0xD2, 0xDA, 0xDB, 0xD9, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
-};
-
-/*================ File-local functions ================*/
-
-/*
- * dehex()
- *
- * Given a hexadecimal digit in ASCII, return the integer representation.
- */
-static inline const unsigned char dehex(char c) {
-	if ((c>='0')&&(c<='9')) {
-		return c-'0';
-	}
-	if ((c>='a')&&(c<='f')) {
-		return c-'a'+10;
-	}
-	if ((c>='A')&&(c<='F')) {
-		return c-'A'+10;
-	}
-	return 0xff;
-}
+#include "hfs_fs.h"
 
 /*================ Global functions ================*/
 
 /*
- * hfs_mac2nat()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the Netatalk name-mangling scheme, returning the length of the
- * mangled filename.  Note that the output string is not NULL terminated.
- *
- * The name-mangling works as follows:
- * Characters 32-126 (' '-'~') except '/' and any initial '.' are passed
- * unchanged from input to output.  The remaining characters are replaced
- * by three characters: ':xx' where xx is the hexadecimal representation
- * of the character, using lowercase 'a' through 'f'.
- */
-int hfs_mac2nat(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-
-	/* Special case for .AppleDesktop which in the
-	   distant future may be a pseudodirectory. */
-	if (strncmp(".AppleDesktop", p, len) == 0) {
-		strncpy(out, p, 13);
-		return 13;
-	}
-
-	while (len--) {
-		c = *p++;
-		if ((c<32) || (c=='/') || (c>126) || (!count && (c=='.'))) {
-			*out++ = ':';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		} else {
-			*out++ = c;
-			count++;
-		}
-	}
-	return count;
-}
-
-/*
- * hfs_mac2cap()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the CAP name-mangling scheme, returning the length of the mangled
- * filename.  Note that the output string is not NULL terminated.
- *
- * The name-mangling works as follows:
- * Characters 32-126 (' '-'~') except '/' are passed unchanged from
- * input to output.  The remaining characters are replaced by three
- * characters: ':xx' where xx is the hexadecimal representation of the
- * character, using lowercase 'a' through 'f'.
- */
-int hfs_mac2cap(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-
-	while (len--) {
-		c = *p++;
-		if ((c<32) || (c=='/') || (c>126)) {
-			*out++ = ':';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		} else {
-			*out++ = c;
-			count++;
-		}
-	}
-	return count;
-}
-
-/*
- * hfs_mac2eight()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the '8-bit' name-mangling scheme, returning the length of the
- * mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * This is one of the three recommended naming conventions described
- * in Apple's document "AppleSingle/AppleDouble Formats: Developer's
- * Note (9/94)"
- *
- * The name-mangling works as follows:
- * Characters 0, '%' and '/' are replaced by three characters: '%xx'
- * where xx is the hexadecimal representation of the character, using
- * lowercase 'a' through 'f'.  All other characters are passed
- * unchanged from input to output.  Note that this format is mainly
- * implemented for completeness and is rather hard to read.
- */
-int hfs_mac2eight(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-
-	while (len--) {
-		c = *p++;
-		if (!c || (c=='/') || (c=='%')) {
-			*out++ = '%';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		} else {
-			*out++ = c;
-			count++;
-		}
-	}
-	return count;
-}
-
-/*
- * hfs_mac2seven()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the '7-bit ASCII' name-mangling scheme, returning the length of the
- * mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * This is one of the three recommended naming conventions described
- * in Apple's document "AppleSingle/AppleDouble Formats: Developer's
- * Note (9/94)"
- *
- * The name-mangling works as follows:
- * Characters 0, '%', '/' and 128-255 are replaced by three
- * characters: '%xx' where xx is the hexadecimal representation of the
- * character, using lowercase 'a' through 'f'.	All other characters
- * are passed unchanged from input to output.  Note that control
- * characters (including newline) and space are unchanged make reading
- * these filenames difficult.
- */
-int hfs_mac2seven(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-
-	while (len--) {
-		c = *p++;
-		if (!c || (c=='/') || (c=='%') || (c&0x80)) {
-			*out++ = '%';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		} else {
-			*out++ = c;
-			count++;
-		}
-	}
-	return count;
-}
-
-/*
- * hfs_mac2alpha()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the '7-bit alphanumeric' name-mangling scheme, returning the length
- * of the mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * This is one of the three recommended naming conventions described
- * in Apple's document "AppleSingle/AppleDouble Formats: Developer's
- * Note (9/94)"
- *
- * The name-mangling works as follows:
- * The characters 'a'-'z', 'A'-'Z', '0'-'9', '_' and the last '.' in
- * the filename are passed unchanged from input to output.  All
- * remaining characters (including any '.'s other than the last) are
- * replaced by three characters: '%xx' where xx is the hexadecimal
- * representation of the character, using lowercase 'a' through 'f'.
- */
-int hfs_mac2alpha(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-	const unsigned char *lp;	/* last period */
-
-	/* strrchr() would be good here, but 'in' is not null-terminated */
-	for (lp=p+len-1; (lp>=p)&&(*lp!='.'); --lp) {}
-	++lp;
-
-	while (len--) {
-		c = *p++;
-		if ((p==lp) || ((c>='0')&&(c<='9')) || ((c>='A')&&(c<='Z')) ||
-				((c>='a')&&(c<='z')) || (c=='_')) {
-			*out++ = c;
-			count++;
-		} else {
-			*out++ = '%';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		}
-	}
-	return count;
-}
-
-/*
  * hfs_mac2triv()
  *
  * Given a 'Pascal String' (a string preceded by a length byte) in
@@ -314,154 +47,19 @@ int hfs_mac2alpha(char *out, const struc
  * by ':' which never appears in HFS filenames.	 All other characters
  * are passed unchanged from input to output.
  */
-int hfs_mac2triv(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
-
-	while (len--) {
-		c = *p++;
-		if (c=='/') {
-			*out++ = ':';
-		} else {
-			*out++ = c;
-		}
-		count++;
-	}
-	return count;
-}
-
-/*
- * hfs_mac2latin()
- *
- * Given a 'Pascal String' (a string preceded by a length byte) in
- * the Macintosh character set produce the corresponding filename using
- * the 'Latin-1' name-mangling scheme, returning the length of the
- * mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * The Macintosh character set and Latin-1 are both extensions of the
- * ASCII character set.	 Some, but certainly not all, of the characters
- * in the Macintosh character set are also in Latin-1 but not with the
- * same encoding.  This name-mangling scheme replaces the characters in
- * the Macintosh character set that have Latin-1 equivalents by those
- * equivalents; the characters 32-126, excluding '/' and '%', are
- * passed unchanged from input to output.  The remaining characters
- * are replaced by three characters: '%xx' where xx is the hexadecimal
- * representation of the character, using lowercase 'a' through 'f'.
- *
- * The array mac2latin_map[] indicates the correspondence between the
- * two character sets.	The byte in element x-128 gives the Latin-1
- * encoding of the character with encoding x in the Macintosh
- * character set.  A value of zero indicates Latin-1 has no
- * corresponding character.
- */
-int hfs_mac2latin(char *out, const struct hfs_name *in) {
-	unsigned char c;
-	const unsigned char *p = in->Name;
-	int len = in->Len;
-	int count = 0;
+int hfs_mac2triv(char *out, const struct hfs_name *in)
+{
+	const char *p;
+	char c;
+	int i, len;
 
-	while (len--) {
+	len = in->len;
+	p = in->name;
+	for (i = 0; i < len; i++) {
 		c = *p++;
-
-		if ((c & 0x80) && mac2latin_map[c & 0x7f]) {
-			*out++ = mac2latin_map[c & 0x7f];
-			count++;
-		} else if ((c>=32) && (c<=126) && (c!='/') && (c!='%')) {
-			*out++ =  c;
-			count++;
-		} else {
-			*out++ = '%';
-			*out++ = hex[(c>>4) & 0xf];
-			*out++ = hex[c & 0xf];
-			count += 3;
-		}
-	}
-	return count;
-}
-
-/*
- * hfs_colon2mac()
- *
- * Given an ASCII string (not null-terminated) and its length,
- * generate the corresponding filename in the Macintosh character set
- * using the 'CAP' name-mangling scheme, returning the length of the
- * mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * This routine is a inverse to hfs_mac2cap() and hfs_mac2nat().
- * A ':' not followed by a 2-digit hexadecimal number (or followed
- * by the codes for NULL or ':') is replaced by a '|'.
- */
-void hfs_colon2mac(struct hfs_name *out, const char *in, int len) {
-	int hi, lo;
-	unsigned char code, c, *count;
-	unsigned char *p = out->Name;
-
-	out->Len = 0;
-	count = &out->Len;
-	while (len-- && (*count < HFS_NAMELEN)) {
-		c = *in++;
-		(*count)++;
-		if (c!=':') {
-			*p++ = c;
-		} else if ((len<2) ||
-			   ((hi=dehex(in[0])) & 0xf0) ||
-			   ((lo=dehex(in[1])) & 0xf0) ||
-			   !(code = (hi << 4) | lo) ||
-			   (code == ':')) {
-			*p++ = '|';
-		} else {
-			*p++ = code;
-			len -= 2;
-			in += 2;
-		}
-	}
-}
-
-/*
- * hfs_prcnt2mac()
- *
- * Given an ASCII string (not null-terminated) and its length,
- * generate the corresponding filename in the Macintosh character set
- * using Apple's three recommended name-mangling schemes, returning
- * the length of the mangled filename.	Note that the output string is
- * not NULL terminated.
- *
- * This routine is a inverse to hfs_mac2alpha(), hfs_mac2seven() and
- * hfs_mac2eight().
- * A '%' not followed by a 2-digit hexadecimal number (or followed
- * by the code for NULL or ':') is unchanged.
- * A ':' is replaced by a '|'.
- */
-void hfs_prcnt2mac(struct hfs_name *out, const char *in, int len) {
-	int hi, lo;
-	unsigned char code, c, *count;
-	unsigned char *p = out->Name;
-
-	out->Len = 0;
-	count = &out->Len;
-	while (len-- && (*count < HFS_NAMELEN)) {
-		c = *in++;
-		(*count)++;
-		if (c==':') {
-			*p++ = '|';
-		} else if (c!='%') {
-			*p++ = c;
-		} else if ((len<2) ||
-			   ((hi=dehex(in[0])) & 0xf0) ||
-			   ((lo=dehex(in[1])) & 0xf0) ||
-			   !(code = (hi << 4) | lo) ||
-			   (code == ':')) {
-			*p++ = '%';
-		} else {
-			*p++ = code;
-			len -= 2;
-			in += 2;
-		}
+		*out++ = c == '/' ? ':' : c;
 	}
+	return i;
 }
 
 /*
@@ -476,81 +74,19 @@ void hfs_prcnt2mac(struct hfs_name *out,
  * This routine is a inverse to hfs_mac2triv().
  * A ':' is replaced by a '/'.
  */
-void hfs_triv2mac(struct hfs_name *out, const char *in, int len) {
-	unsigned char c, *count;
-	unsigned char *p = out->Name;
-
-	out->Len = 0;
-	count = &out->Len;
-	while (len-- && (*count < HFS_NAMELEN)) {
-		c = *in++;
-		(*count)++;
-		if (c==':') {
-			*p++ = '/';
-		} else {
-			*p++ = c;
-		}
-	}
-}
-
-/*
- * hfs_latin2mac()
- *
- * Given an Latin-1 string (not null-terminated) and its length,
- * generate the corresponding filename in the Macintosh character set
- * using the 'Latin-1' name-mangling scheme, returning the length of
- * the mangled filename.  Note that the output string is not NULL
- * terminated.
- *
- * This routine is a inverse to hfs_latin2cap().
- * A '%' not followed by a 2-digit hexadecimal number (or followed
- * by the code for NULL or ':') is unchanged.
- * A ':' is replaced by a '|'.
- *
- * Note that the character map is built the first time it is needed.
- */
-void hfs_latin2mac(struct hfs_name *out, const char *in, int len)
+void hfs_triv2mac(struct hfs_name *out, struct qstr *in)
 {
-	int hi, lo;
-	unsigned char code, c, *count;
-	unsigned char *p = out->Name;
-	static int map_initialized;
-
-	if (!map_initialized) {
-		int i;
-
-		/* build the inverse mapping at run time */
-		for (i = 0; i < 128; i++) {
-			if ((c = mac2latin_map[i])) {
-				latin2mac_map[(int)c - 128] = i + 128;
-			}
-		}
-		map_initialized = 1;
-	}
-
-	out->Len = 0;
-	count = &out->Len;
-	while (len-- && (*count < HFS_NAMELEN)) {
-		c = *in++;
-		(*count)++;
-
-		if (c==':') {
-			*p++ = '|';
-		} else if (c!='%') {
-			if (c<128 || !(*p = latin2mac_map[c-128])) {
-				*p = c;
-			}
-			p++;
-		} else if ((len<2) ||
-			   ((hi=dehex(in[0])) & 0xf0) ||
-			   ((lo=dehex(in[1])) & 0xf0) ||
-			   !(code = (hi << 4) | lo) ||
-			   (code == ':')) {
-			*p++ = '%';
-		} else {
-			*p++ = code;
-			len -= 2;
-			in += 2;
-		}
+	const char *src;
+	char *dst, c;
+	int i, len;
+
+	out->len = len = min((unsigned int)HFS_NAMELEN, in->len);
+	src = in->name;
+	dst = out->name;
+	for (i = 0; i < len; i++) {
+		c = *src++;
+		*dst++ = c == ':' ? '/' : c;
 	}
+	for (; i < HFS_NAMELEN; i++)
+		*dst++ = 0;
 }
diff -purN /dev/shm/linux-2.5/fs/hfs/version.c linuxppc-2.5-benh/fs/hfs/version.c
--- /dev/shm/linux-2.5/fs/hfs/version.c	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfs/version.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-/*
- * linux/fs/hfs/version.c
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains the version string for this release.
- */
-
-const char hfs_version[]="0.96";
diff -purN /dev/shm/linux-2.5/fs/hfsplus/Makefile linuxppc-2.5-benh/fs/hfsplus/Makefile
--- /dev/shm/linux-2.5/fs/hfsplus/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/Makefile	2003-11-01 02:03:27.000000000 +0000
@@ -0,0 +1,36 @@
+#KERNELSRC=/usr/src/linux
+EXTRA_CFLAGS = -g #-fno-inline
+
+hfsplus-objs := super.o options.o inode.o extents.o catalog.o dir.o btree.o \
+		bnode.o brec.o bfind.o tables.o unicode.o wrapper.o bitmap.o part_tbl.o
+
+ifeq ($(PATCHLEVEL),4)
+O_TARGET	:= hfsplus.o
+obj-y		:= $(hfsplus-objs)
+endif
+
+obj-$(CONFIG_HFSPLUS_FS) += hfsplus.o
+
+ifeq ("$(TOPDIR)","")
+ifeq ("$(KERNELSRC)","")
+all install:
+	@echo 'use "make KERNELSRC=..."'
+else
+all:
+	make modules -C $(KERNELSRC) SUBDIRS=$$PWD CONFIG_HFSPLUS_FS=m
+
+install:
+	@eval `sed -n '1,5s/^\([A-Z]*\) *= *\(.*\)$$/\1=\2/p' $(KERNELSRC)/Makefile`; \
+	KERNELRELEASE=$$VERSION.$$PATCHLEVEL.$$SUBLEVEL$$EXTRAVERSION; \
+	mkdir -pv $(INSTALL_MOD_PATH)/lib/modules/$$KERNELRELEASE/kernel/fs/hfsplus; \
+	mod=hfsplus.o; test -f hfsplus.ko && mod=hfsplus.ko; \
+	cp -v $$mod $(INSTALL_MOD_PATH)/lib/modules/$$KERNELRELEASE/kernel/fs/hfsplus
+
+
+endif
+endif
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f hfsplus.o hfsplus.ko $(hfsplus-objs) .*.flags .*.cmd *.mod.?
diff -purN /dev/shm/linux-2.5/fs/hfsplus/bfind.c linuxppc-2.5-benh/fs/hfsplus/bfind.c
--- /dev/shm/linux-2.5/fs/hfsplus/bfind.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/bfind.c	2003-11-01 02:03:28.000000000 +0000
@@ -0,0 +1,209 @@
+/*
+ *  linux/fs/hfsplus/bfind.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Search routines for btrees
+ */
+
+#include <linux/slab.h>
+#include "hfsplus_fs.h"
+
+int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)
+{
+	void *ptr;
+
+	fd->tree = tree;
+	fd->bnode = NULL;
+	ptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+	fd->search_key = ptr;
+	fd->key = ptr + tree->max_key_len + 2;
+	dprint(DBG_BNODE_REFS, "find_init: %d (%p)\n", tree->cnid, __builtin_return_address(0));
+	down(&tree->tree_lock);
+	return 0;
+}
+
+void hfs_find_exit(struct hfs_find_data *fd)
+{
+	hfs_bnode_put(fd->bnode);
+	kfree(fd->search_key);
+	dprint(DBG_BNODE_REFS, "find_exit: %d (%p)\n", fd->tree->cnid, __builtin_return_address(0));
+	up(&fd->tree->tree_lock);
+	fd->tree = NULL;
+}
+
+/* Find the record in bnode that best matches key (not greater than...)*/
+int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd)
+{
+	int cmpval;
+	u16 off, len, keylen;
+	int rec;
+	int b, e;
+	int res;
+
+	b = 0;
+	e = bnode->num_recs - 1;
+	res = -ENOENT;
+	do {
+		rec = (e + b) / 2;
+		len = hfs_brec_lenoff(bnode, rec, &off);
+		keylen = hfs_brec_keylen(bnode, rec);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+		cmpval = bnode->tree->keycmp(fd->key, fd->search_key);
+		if (!cmpval) {
+			e = rec;
+			res = 0;
+			goto done;
+		}
+		if (cmpval < 0)
+			b = rec + 1;
+		else
+			e = rec - 1;
+	} while (b <= e);
+	//printk("%d: %d,%d,%d\n", bnode->this, b, e, rec);
+	if (rec != e && e >= 0) {
+		len = hfs_brec_lenoff(bnode, e, &off);
+		keylen = hfs_brec_keylen(bnode, e);
+		hfs_bnode_read(bnode, fd->key, off, keylen);
+	}
+done:
+	fd->record = e;
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	return res;
+}
+
+/* Traverse a B*Tree from the root to a leaf finding best fit to key */
+/* Return allocated copy of node found, set recnum to best record */
+int hfs_brec_find(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	u32 data, nidx, parent;
+	int height, res;
+
+	tree = fd->tree;
+	if (fd->bnode)
+		hfs_bnode_put(fd->bnode);
+	fd->bnode = NULL;
+	nidx = tree->root;
+	if (!nidx)
+		return -ENOENT;
+	height = tree->depth;
+	res = 0;
+	parent = 0;
+	for (;;) {
+		bnode = hfs_bnode_find(tree, nidx);
+		if (IS_ERR(bnode)) {
+			res = PTR_ERR(bnode);
+			bnode = NULL;
+			break;
+		}
+		if (bnode->height != height)
+			goto invalid;
+		if (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))
+			goto invalid;
+		bnode->parent = parent;
+
+		res = __hfs_brec_find(bnode, fd);
+		if (!height)
+			break;
+		if (fd->record < 0)
+			goto release;
+
+		parent = nidx;
+		hfs_bnode_read(bnode, &data, fd->entryoffset, 4);
+		nidx = be32_to_cpu(data);
+		hfs_bnode_put(bnode);
+	}
+	fd->bnode = bnode;
+	return res;
+
+invalid:
+	printk("HFS+-fs: inconsistency in B*Tree (%d,%d,%d,%u,%u)\n",
+		height, bnode->height, bnode->type, nidx, parent);
+	res = -EIO;
+release:
+	hfs_bnode_put(bnode);
+	return res;
+}
+
+int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)
+{
+	int res;
+
+	res = hfs_brec_find(fd);
+	if (res)
+		return res;
+	if (fd->entrylength > rec_len)
+		return -EINVAL;
+	hfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);
+	return 0;
+}
+
+int hfs_brec_goto(struct hfs_find_data *fd, int cnt)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	int idx, res = 0;
+	u16 off, len, keylen;
+
+	bnode = fd->bnode;
+	tree = bnode->tree;
+
+	if (cnt < 0) {
+		cnt = -cnt;
+		while (cnt > fd->record) {
+			cnt -= fd->record + 1;
+			fd->record = bnode->num_recs - 1;
+			idx = bnode->prev;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(bnode);
+			bnode = hfs_bnode_find(tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
+			}
+		}
+		fd->record -= cnt;
+	} else {
+		while (cnt >= bnode->num_recs - fd->record) {
+			cnt -= bnode->num_recs - fd->record;
+			fd->record = 0;
+			idx = bnode->next;
+			if (!idx) {
+				res = -ENOENT;
+				goto out;
+			}
+			hfs_bnode_put(bnode);
+			bnode = hfs_bnode_find(tree, idx);
+			if (IS_ERR(bnode)) {
+				res = PTR_ERR(bnode);
+				bnode = NULL;
+				goto out;
+			}
+		}
+		fd->record += cnt;
+	}
+
+	len = hfs_brec_lenoff(bnode, fd->record, &off);
+	keylen = hfs_brec_keylen(bnode, fd->record);
+	fd->keyoffset = off;
+	fd->keylength = keylen;
+	fd->entryoffset = off + keylen;
+	fd->entrylength = len - keylen;
+	hfs_bnode_read(bnode, fd->key, off, keylen);
+out:
+	fd->bnode = bnode;
+	return res;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/bitmap.c linuxppc-2.5-benh/fs/hfsplus/bitmap.c
--- /dev/shm/linux-2.5/fs/hfsplus/bitmap.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/bitmap.c	2003-11-01 02:03:30.000000000 +0000
@@ -0,0 +1,220 @@
+/*
+ *  linux/fs/hfsplus/bitmap.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of allocation file
+ */
+
+#include <linux/pagemap.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+#define PAGE_CACHE_BITS	(PAGE_CACHE_SIZE * 8)
+
+int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)
+{
+	struct page *page;
+	struct address_space *mapping;
+	u32 *pptr, *curr, *end;
+	u32 val, mask, start, len;
+	int i;
+
+	len = *max;
+	if (!len)
+		return size;
+
+	dprint(DBG_BITMAP, "block_allocate: %u,%u,%u\n", size, offset, len);
+	down(&HFSPLUS_SB(sb).alloc_file->i_sem);
+	mapping = HFSPLUS_SB(sb).alloc_file->i_mapping;
+	page = read_cache_page(mapping, offset / PAGE_CACHE_BITS,
+			       (filler_t *)mapping->a_ops->readpage, NULL);
+	pptr = kmap(page);
+	curr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;
+	i = offset % 32;
+	offset &= ~(PAGE_CACHE_BITS - 1);
+	if ((size ^ offset) / PAGE_CACHE_BITS)
+		end = pptr + PAGE_CACHE_BITS / 32;
+	else
+		end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;
+
+	/* scan the first partial u32 for zero bits */
+	val = *curr;
+	if (~val) {
+		val = be32_to_cpu(val);
+		mask = (1U << 31) >> i;
+		for (; i < 32; mask >>= 1, i++) {
+			if (!(val & mask))
+				goto found;
+		}
+	}
+	curr++;
+
+	/* scan complete u32s for the first zero bit */
+	while (1) {
+		while (curr < end) {
+			val = *curr;
+			if (~val) {
+				val = be32_to_cpu(val);
+				mask = 1 << 31;
+				for (i = 0; i < 32; mask >>= 1, i++) {
+					if (!(val & mask))
+						goto found;
+				}
+			}
+			curr++;
+		}
+		kunmap(page);
+		offset += PAGE_CACHE_BITS;
+		if (offset >= size)
+			break;
+		page = read_cache_page(mapping, offset / PAGE_CACHE_BITS,
+				       (filler_t *)mapping->a_ops->readpage, NULL);
+		curr = pptr = kmap(page);
+		if ((size ^ offset) / PAGE_CACHE_BITS)
+			end = pptr + PAGE_CACHE_BITS / 32;
+		else
+			end = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;
+	}
+	dprint(DBG_BITMAP, "bitmap full\n");
+	start = size;
+	goto out;
+
+found:
+	start = offset + (curr - pptr) * 32 + i;
+	if (start >= size) {
+		dprint(DBG_BITMAP, "bitmap full\n");
+		goto out;
+	}
+	/* do any partial u32 at the start */
+	len = min(size - start, len);
+	while (1) {
+		val |= mask;
+		if (++i >= 32)
+			break;
+		mask >>= 1;
+		if (!--len || val & mask)
+			goto done;
+	}
+	if (!--len)
+		goto done;
+	*curr++ = cpu_to_be32(val);
+	/* do full u32s */
+	while (1) {
+		while (curr < end) {
+			val = be32_to_cpu(*curr);
+			if (len < 32)
+				goto last;
+			if (val) {
+				len = 32;
+				goto last;
+			}
+			*curr++ = 0xffffffffU;
+			len -= 32;
+		}
+		set_page_dirty(page);
+		kunmap(page);
+		offset += PAGE_CACHE_BITS;
+		page = read_cache_page(mapping, offset / PAGE_CACHE_BITS,
+				       (filler_t *)mapping->a_ops->readpage, NULL);
+		pptr = kmap(page);
+		curr = pptr;
+		end = pptr + PAGE_CACHE_BITS / 32;
+	}
+last:
+	/* do any partial u32 at end */
+	mask = 1U << 31;
+	for (i = 0; i < len; i++) {
+		if (val & mask)
+			break;
+		val |= mask;
+		mask >>= 1;
+	}
+done:
+	*curr = cpu_to_be32(val);
+	set_page_dirty(page);
+	kunmap(page);
+	*max = offset + (curr - pptr) * 32 + i - start;
+	HFSPLUS_SB(sb).free_blocks -= *max;
+	sb->s_dirt = 1;
+	dprint(DBG_BITMAP, "-> %u,%u\n", start, *max);
+out:
+	up(&HFSPLUS_SB(sb).alloc_file->i_sem);
+	return start;
+}
+
+int hfsplus_block_free(struct super_block *sb, u32 offset, u32 count)
+{
+	struct page *page;
+	struct address_space *mapping;
+	u32 *pptr, *curr, *end;
+	u32 mask, len, pnr;
+	int i;
+
+	/* is there any actual work to be done? */
+	if (!count)
+		return 0;
+
+	dprint(DBG_BITMAP, "block_free: %u,%u\n", offset, count);
+	/* are all of the bits in range? */
+	if ((offset + count) > HFSPLUS_SB(sb).total_blocks)
+		return -2;
+
+	down(&HFSPLUS_SB(sb).alloc_file->i_sem);
+	mapping = HFSPLUS_SB(sb).alloc_file->i_mapping;
+	pnr = offset / PAGE_CACHE_BITS;
+	page = read_cache_page(mapping, pnr, (filler_t *)mapping->a_ops->readpage, NULL);
+	pptr = kmap(page);
+	curr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;
+	end = pptr + PAGE_CACHE_BITS / 32;
+	len = count;
+
+	/* do any partial u32 at the start */
+	i = offset % 32;
+	if (i) {
+		int j = 32 - i;
+		mask = 0xffffffffU << j;
+		if (j > count) {
+			mask |= 0xffffffffU >> (i + count);
+			*curr++ &= cpu_to_be32(mask);
+			goto out;
+		}
+		*curr++ &= cpu_to_be32(mask);
+		count -= j;
+	}
+
+	/* do full u32s */
+	while (1) {
+		while (curr < end) {
+			if (count < 32)
+				goto done;
+			*curr++ = 0;
+			count -= 32;
+		}
+		if (!count)
+			break;
+		set_page_dirty(page);
+		kunmap(page);
+		page = read_cache_page(mapping, ++pnr, (filler_t *)mapping->a_ops->readpage, NULL);
+		pptr = kmap(page);
+		curr = pptr;
+		end = pptr + PAGE_CACHE_BITS / 32;
+	}
+done:
+	/* do any partial u32 at end */
+	if (count) {
+		mask = 0xffffffffU >> count;
+		*curr &= cpu_to_be32(mask);
+	}
+out:
+	set_page_dirty(page);
+	kunmap(page);
+	HFSPLUS_SB(sb).free_blocks += len;
+	sb->s_dirt = 1;
+	up(&HFSPLUS_SB(sb).alloc_file->i_sem);
+
+	return 0;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/bnode.c linuxppc-2.5-benh/fs/hfsplus/bnode.c
--- /dev/shm/linux-2.5/fs/hfsplus/bnode.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/bnode.c	2003-11-01 02:03:31.000000000 +0000
@@ -0,0 +1,661 @@
+/*
+ *  linux/fs/hfsplus/bnode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle basic btree node operations
+ */
+
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/swap.h>
+#include <linux/version.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+#define REF_PAGES	0
+
+/* Copy a specified range of bytes from the raw data of a node */
+void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memcpy(buf, kmap(*pagep) + off, l);
+	kunmap(*pagep);
+
+	while ((len -= l)) {
+		buf += l;
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memcpy(buf, kmap(*++pagep), l);
+		kunmap(*pagep);
+	}
+}
+
+u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)
+{
+	u16 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 2);
+	return be16_to_cpu(data);
+}
+
+u8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)
+{
+	u8 data;
+	// optimize later...
+	hfs_bnode_read(node, &data, off, 1);
+	return be16_to_cpu(data);
+}
+
+void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)
+{
+	struct hfs_btree *tree;
+	int key_len;
+
+	tree = node->tree;
+	if (node->type == HFS_NODE_LEAF ||
+	    tree->attributes & HFS_TREE_VARIDXKEYS)
+		key_len = hfs_bnode_read_u16(node, off) + 2;
+	else
+		key_len = tree->max_key_len + 2;
+
+	hfs_bnode_read(node, key, off, key_len);
+}
+
+void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memcpy(kmap(*pagep) + off, buf, l);
+	set_page_dirty(*pagep);
+	kunmap(*pagep);
+
+	while ((len -= l)) {
+		buf += l;
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memcpy(kmap(*++pagep), buf, l);
+		set_page_dirty(*pagep);
+		kunmap(*pagep);
+	}
+}
+
+void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)
+{
+	data = cpu_to_be16(data);
+	// optimize later...
+	hfs_bnode_write(node, &data, off, 2);
+}
+
+void hfs_bnode_clear(struct hfs_bnode *node, int off, int len)
+{
+	struct page **pagep;
+	int l;
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	off &= ~PAGE_CACHE_MASK;
+
+	l = min(len, (int)PAGE_CACHE_SIZE - off);
+	memset(kmap(*pagep) + off, 0, l);
+	set_page_dirty(*pagep);
+	kunmap(*pagep);
+
+	while ((len -= l)) {
+		l = min(len, (int)PAGE_CACHE_SIZE);
+		memset(kmap(*++pagep), 0, l);
+		set_page_dirty(*pagep);
+		kunmap(*pagep);
+	}
+}
+
+void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,
+		    struct hfs_bnode *src_node, int src, int len)
+{
+	struct hfs_btree *tree;
+	struct page **src_page, **dst_page;
+	int l;
+
+	dprint(DBG_BNODE_MOD, "copybytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
+		return;
+	tree = src_node->tree;
+	src += src_node->page_offset;
+	dst += dst_node->page_offset;
+	src_page = src_node->page + (src >> PAGE_CACHE_SHIFT);
+	src &= ~PAGE_CACHE_MASK;
+	dst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);
+	dst &= ~PAGE_CACHE_MASK;
+
+	if (src == dst) {
+		l = min(len, (int)PAGE_CACHE_SIZE - src);
+		memcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);
+		kunmap(*src_page);
+		set_page_dirty(*dst_page);
+		kunmap(*dst_page);
+
+		while ((len -= l)) {
+			l = min(len, (int)PAGE_CACHE_SIZE);
+			memcpy(kmap(*++dst_page), kmap(*++src_page), l);
+			kunmap(*src_page);
+			set_page_dirty(*dst_page);
+			kunmap(*dst_page);
+		}
+	} else {
+		void *src_ptr, *dst_ptr;
+
+		do {
+			src_ptr = kmap(*src_page) + src;
+			dst_ptr = kmap(*dst_page) + dst;
+			if (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {
+				l = PAGE_CACHE_SIZE - src;
+				src = 0;
+				dst += l;
+			} else {
+				l = PAGE_CACHE_SIZE - dst;
+				src += l;
+				dst = 0;
+			}
+			l = min(len, l);
+			memcpy(dst_ptr, src_ptr, l);
+			kunmap(*src_page);
+			set_page_dirty(*dst_page);
+			kunmap(*dst_page);
+			if (!dst)
+				dst_page++;
+			else
+				src_page++;
+		} while ((len -= l));
+	}
+}
+
+void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)
+{
+	struct page **src_page, **dst_page;
+	int l;
+
+	dprint(DBG_BNODE_MOD, "movebytes: %u,%u,%u\n", dst, src, len);
+	if (!len)
+		return;
+	src += node->page_offset;
+	dst += node->page_offset;
+	if (dst > src) {
+		src += len - 1;
+		src_page = node->page + (src >> PAGE_CACHE_SHIFT);
+		src = (src & ~PAGE_CACHE_MASK) + 1;
+		dst += len - 1;
+		dst_page = node->page + (dst >> PAGE_CACHE_SHIFT);
+		dst = (dst & ~PAGE_CACHE_MASK) + 1;
+
+		if (src == dst) {
+			while (src < len) {
+				memmove(kmap(*dst_page), kmap(*src_page), src);
+				kunmap(*src_page);
+				set_page_dirty(*dst_page);
+				kunmap(*dst_page);
+				len -= src;
+				src = PAGE_CACHE_SIZE;
+				src_page--;
+				dst_page--;
+			}
+			src -= len;
+			memmove(kmap(*dst_page) + src, kmap(*src_page) + src, len);
+			kunmap(*src_page);
+			set_page_dirty(*dst_page);
+			kunmap(*dst_page);
+		} else {
+			void *src_ptr, *dst_ptr;
+
+			do {
+				src_ptr = kmap(*src_page) + src;
+				dst_ptr = kmap(*dst_page) + dst;
+				if (src < dst) {
+					l = src;
+					src = PAGE_CACHE_SIZE;
+					dst -= l;
+				} else {
+					l = dst;
+					src -= l;
+					dst = PAGE_CACHE_SIZE;
+				}
+				l = min(len, l);
+				memmove(dst_ptr - l, src_ptr - l, l);
+				kunmap(*src_page);
+				set_page_dirty(*dst_page);
+				kunmap(*dst_page);
+				if (dst == PAGE_CACHE_SIZE)
+					dst_page--;
+				else
+					src_page--;
+			} while ((len -= l));
+		}
+	} else {
+		src_page = node->page + (src >> PAGE_CACHE_SHIFT);
+		src &= ~PAGE_CACHE_MASK;
+		dst_page = node->page + (dst >> PAGE_CACHE_SHIFT);
+		dst &= ~PAGE_CACHE_MASK;
+
+		if (src == dst) {
+			l = min(len, (int)PAGE_CACHE_SIZE - src);
+			memmove(kmap(*dst_page) + src, kmap(*src_page) + src, l);
+			kunmap(*src_page);
+			set_page_dirty(*dst_page);
+			kunmap(*dst_page);
+
+			while ((len -= l)) {
+				l = min(len, (int)PAGE_CACHE_SIZE);
+				memmove(kmap(*++dst_page), kmap(*++src_page), l);
+				kunmap(*src_page);
+				set_page_dirty(*dst_page);
+				kunmap(*dst_page);
+			}
+		} else {
+			void *src_ptr, *dst_ptr;
+
+			do {
+				src_ptr = kmap(*src_page) + src;
+				dst_ptr = kmap(*dst_page) + dst;
+				if (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {
+					l = PAGE_CACHE_SIZE - src;
+					src = 0;
+					dst += l;
+				} else {
+					l = PAGE_CACHE_SIZE - dst;
+					src += l;
+					dst = 0;
+				}
+				l = min(len, l);
+				memmove(dst_ptr, src_ptr, l);
+				kunmap(*src_page);
+				set_page_dirty(*dst_page);
+				kunmap(*dst_page);
+				if (!dst)
+					dst_page++;
+				else
+					src_page++;
+			} while ((len -= l));
+		}
+	}
+}
+
+void hfs_bnode_dump(struct hfs_bnode *node)
+{
+	struct hfs_bnode_desc desc;
+	u32 cnid;
+	int i, off, key_off;
+
+	dprint(DBG_BNODE_MOD, "bnode: %d\n", node->this);
+	hfs_bnode_read(node, &desc, 0, sizeof(desc));
+	dprint(DBG_BNODE_MOD, "%d, %d, %d, %d, %d\n",
+		be32_to_cpu(desc.next), be32_to_cpu(desc.prev),
+		desc.type, desc.height, be16_to_cpu(desc.num_recs));
+
+	off = node->tree->node_size - 2;
+	for (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {
+		key_off = hfs_bnode_read_u16(node, off);
+		dprint(DBG_BNODE_MOD, " %d", key_off);
+		if (i && node->type == HFS_NODE_INDEX) {
+			int tmp;
+
+			if (node->tree->attributes & HFS_TREE_VARIDXKEYS)
+				tmp = hfs_bnode_read_u16(node, key_off) + 2;
+			else
+				tmp = node->tree->max_key_len + 2;
+			dprint(DBG_BNODE_MOD, " (%d", tmp);
+			hfs_bnode_read(node, &cnid, key_off + tmp, 4);
+			dprint(DBG_BNODE_MOD, ",%d)", be32_to_cpu(cnid));
+		} else if (i && node->type == HFS_NODE_LEAF) {
+			int tmp;
+
+			tmp = hfs_bnode_read_u16(node, key_off);
+			dprint(DBG_BNODE_MOD, " (%d)", tmp);
+		}
+	}
+	dprint(DBG_BNODE_MOD, "\n");
+}
+
+void hfs_bnode_unlink(struct hfs_bnode *node)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *tmp;
+	u32 cnid;
+
+	tree = node->tree;
+	if (node->prev) {
+		tmp = hfs_bnode_find(tree, node->prev);
+		if (IS_ERR(tmp))
+			return;
+		tmp->next = node->next;
+		cnid = cpu_to_be32(tmp->next);
+		hfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+		hfs_bnode_put(tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_head = node->next;
+
+	if (node->next) {
+		tmp = hfs_bnode_find(tree, node->next);
+		if (IS_ERR(tmp))
+			return;
+		tmp->prev = node->prev;
+		cnid = cpu_to_be32(tmp->prev);
+		hfs_bnode_write(tmp, &cnid, offsetof(struct hfs_bnode_desc, prev), 4);
+		hfs_bnode_put(tmp);
+	} else if (node->type == HFS_NODE_LEAF)
+		tree->leaf_tail = node->prev;
+
+	// move down?
+	if (!node->prev && !node->next) {
+		printk("hfs_btree_del_level\n");
+	}
+	if (!node->parent) {
+		tree->root = 0;
+		tree->depth = 0;
+	}
+	set_bit(HFS_BNODE_DELETED, &node->flags);
+}
+
+static inline int hfs_bnode_hash(u32 num)
+{
+	num = (num >> 16) + num;
+	num += num >> 8;
+	return num & (NODE_HASH_SIZE - 1);
+}
+
+struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)
+{
+	struct hfs_bnode *node;
+
+	if (cnid >= tree->node_count) {
+		printk("HFS+-fs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
+	}
+
+	for (node = tree->node_hash[hfs_bnode_hash(cnid)];
+	     node; node = node->next_hash) {
+		if (node->this == cnid) {
+			return node;
+		}
+	}
+	return NULL;
+}
+
+static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)
+{
+	struct super_block *sb;
+	struct hfs_bnode *node, *node2;
+	struct address_space *mapping;
+	struct page *page;
+	int size, block, i, hash;
+	loff_t off;
+
+	if (cnid >= tree->node_count) {
+		printk("HFS+-fs: request for non-existent node %d in B*Tree\n", cnid);
+		return NULL;
+	}
+
+	sb = tree->inode->i_sb;
+	size = sizeof(struct hfs_bnode) + tree->pages_per_bnode *
+		sizeof(struct page *);
+	node = kmalloc(size, GFP_KERNEL);
+	if (!node)
+		return NULL;
+	memset(node, 0, size);
+	node->tree = tree;
+	node->this = cnid;
+	set_bit(HFS_BNODE_NEW, &node->flags);
+	atomic_set(&node->refcnt, 1);
+	dprint(DBG_BNODE_REFS, "new_node(%d:%d): 1\n",
+	       node->tree->cnid, node->this);
+	init_waitqueue_head(&node->lock_wq);
+	spin_lock(&tree->hash_lock);
+	node2 = hfs_bnode_findhash(tree, cnid);
+	if (!node2) {
+		hash = hfs_bnode_hash(cnid);
+		node->next_hash = tree->node_hash[hash];
+		tree->node_hash[hash] = node;
+		tree->node_hash_cnt++;
+	} else {
+		spin_unlock(&tree->hash_lock);
+		kfree(node);
+		wait_event(node2->lock_wq, !test_bit(HFS_BNODE_NEW, &node2->flags));
+		return node2;
+	}
+	spin_unlock(&tree->hash_lock);
+
+	mapping = tree->inode->i_mapping;
+	off = (loff_t)cnid << tree->node_size_shift;
+	block = off >> PAGE_CACHE_SHIFT;
+	node->page_offset = off & ~PAGE_CACHE_MASK;
+	for (i = 0; i < tree->pages_per_bnode; block++, i++) {
+		page = read_cache_page(mapping, block, (filler_t *)mapping->a_ops->readpage, NULL);
+		if (IS_ERR(page))
+			goto fail;
+#if !REF_PAGES
+		page_cache_release(page);
+#endif
+		node->page[i] = page;
+	}
+
+	return node;
+fail:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	return node;
+}
+
+void hfs_bnode_unhash(struct hfs_bnode *node)
+{
+	struct hfs_bnode **p;
+
+	dprint(DBG_BNODE_REFS, "remove_node(%d:%d): %d\n",
+		node->tree->cnid, node->this, atomic_read(&node->refcnt));
+	for (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];
+	     *p && *p != node; p = &(*p)->next_hash)
+		;
+	if (!*p)
+		BUG();
+	*p = node->next_hash;
+	node->tree->node_hash_cnt--;
+}
+
+/* Load a particular node out of a tree */
+struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc *desc;
+	int i, rec_off, off, next_off;
+	int entry_size, key_size;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	if (node) {
+		hfs_bnode_get(node);
+		spin_unlock(&tree->hash_lock);
+		wait_event(node->lock_wq, !test_bit(HFS_BNODE_NEW, &node->flags));
+		return node;
+	}
+	spin_unlock(&tree->hash_lock);
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+	if (!test_bit(HFS_BNODE_NEW, &node->flags))
+		return node;
+
+	desc = (struct hfs_bnode_desc *)(kmap(node->page[0]) + node->page_offset);
+	node->prev = be32_to_cpu(desc->prev);
+	node->next = be32_to_cpu(desc->next);
+	node->num_recs = be16_to_cpu(desc->num_recs);
+	node->type = desc->type;
+	node->height = desc->height;
+	kunmap(node->page[0]);
+
+	switch (node->type) {
+	case HFS_NODE_HEADER:
+	case HFS_NODE_MAP:
+		if (node->height != 0)
+			goto node_error;
+		break;
+	case HFS_NODE_LEAF:
+		if (node->height != 1)
+			goto node_error;
+		break;
+	case HFS_NODE_INDEX:
+		if (node->height <= 1 || node->height > tree->depth)
+			goto node_error;
+		break;
+	default:
+		goto node_error;
+	}
+
+	rec_off = tree->node_size - 2;
+	off = hfs_bnode_read_u16(node, rec_off);
+	if (off != sizeof(struct hfs_bnode_desc))
+		goto node_error;
+	for (i = 1; i <= node->num_recs; off = next_off, i++) {
+		rec_off -= 2;
+		next_off = hfs_bnode_read_u16(node, rec_off);
+		if (next_off <= off ||
+		    next_off > tree->node_size ||
+		    next_off & 1)
+			goto node_error;
+		entry_size = next_off - off;
+		if (node->type != HFS_NODE_INDEX &&
+		    node->type != HFS_NODE_LEAF)
+			continue;
+		key_size = hfs_bnode_read_u16(node, off) + 2;
+		if (key_size >= entry_size || key_size & 1)
+			goto node_error;
+	}
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	return node;
+
+node_error:
+	set_bit(HFS_BNODE_ERROR, &node->flags);
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+	hfs_bnode_put(node);
+	return ERR_PTR(-EIO);
+}
+
+void hfs_bnode_free(struct hfs_bnode *node)
+{
+	//int i;
+
+	//for (i = 0; i < node->tree->pages_per_bnode; i++)
+	//	if (node->page[i])
+	//		page_cache_release(node->page[i]);
+	kfree(node);
+}
+
+struct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)
+{
+	struct hfs_bnode *node;
+	struct page **pagep;
+	int i;
+
+	spin_lock(&tree->hash_lock);
+	node = hfs_bnode_findhash(tree, num);
+	spin_unlock(&tree->hash_lock);
+	if (node) {
+		printk("new node %u already hashed?\n", num);
+		BUG();
+	}
+	node = __hfs_bnode_create(tree, num);
+	if (!node)
+		return ERR_PTR(-ENOMEM);
+
+	pagep = node->page;
+	memset(kmap(*pagep) + node->page_offset, 0,
+	       min((int)PAGE_CACHE_SIZE, (int)tree->node_size));
+	set_page_dirty(*pagep);
+	kunmap(*pagep);
+	for (i = 1; i < tree->pages_per_bnode; i++) {
+		memset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);
+		set_page_dirty(*pagep);
+		kunmap(*pagep);
+	}
+	clear_bit(HFS_BNODE_NEW, &node->flags);
+	wake_up(&node->lock_wq);
+
+	return node;
+}
+
+void hfs_bnode_get(struct hfs_bnode *node)
+{
+	if (node) {
+		atomic_inc(&node->refcnt);
+#if REF_PAGES
+		{
+		int i;
+		for (i = 0; i < node->tree->pages_per_bnode; i++)
+			get_page(node->page[i]);
+		}
+#endif
+		dprint(DBG_BNODE_REFS, "get_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
+	}
+}
+
+/* Dispose of resources used by a node */
+void hfs_bnode_put(struct hfs_bnode *node)
+{
+	if (node) {
+		struct hfs_btree *tree = node->tree;
+		int i;
+
+		dprint(DBG_BNODE_REFS, "put_node(%d:%d): %d\n",
+		       node->tree->cnid, node->this, atomic_read(&node->refcnt));
+		if (!atomic_read(&node->refcnt))
+			BUG();
+		if (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock)) {
+#if REF_PAGES
+			for (i = 0; i < tree->pages_per_bnode; i++)
+				put_page(node->page[i]);
+#endif
+			return;
+		}
+		for (i = 0; i < tree->pages_per_bnode; i++) {
+			mark_page_accessed(node->page[i]);
+#if REF_PAGES
+			put_page(node->page[i]);
+#endif
+		}
+
+		if (test_bit(HFS_BNODE_DELETED, &node->flags)) {
+			hfs_bnode_unhash(node);
+			spin_unlock(&tree->hash_lock);
+			hfs_bmap_free(node);
+			hfs_bnode_free(node);
+			return;
+		}
+		spin_unlock(&tree->hash_lock);
+	}
+}
+
+void hfsplus_lock_bnode(struct hfs_bnode *node)
+{
+	wait_event(node->lock_wq, !test_and_set_bit(HFS_BNODE_LOCK, &node->flags));
+}
+
+void hfsplus_unlock_bnode(struct hfs_bnode *node)
+{
+	clear_bit(HFS_BNODE_LOCK, &node->flags);
+	if (waitqueue_active(&node->lock_wq))
+		wake_up(&node->lock_wq);
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/brec.c linuxppc-2.5-benh/fs/hfsplus/brec.c
--- /dev/shm/linux-2.5/fs/hfsplus/brec.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/brec.c	2003-11-01 02:03:32.000000000 +0000
@@ -0,0 +1,487 @@
+/*
+ *  linux/fs/hfsplus/brec.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle individual btree records
+ */
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Get the length and offset of the given record in the given node */
+u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)
+{
+	u16 retval[2];
+	u16 dataoff;
+
+	dataoff = node->tree->node_size - (rec + 2) * 2;
+	hfs_bnode_read(node, retval, dataoff, 4);
+	*off = be16_to_cpu(retval[1]);
+	return be16_to_cpu(retval[0]) - *off;
+}
+
+/* Get the length of the key from a keyed record */
+u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)
+{
+	u16 retval, recoff;
+
+	if (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)
+		return 0;
+
+	if ((node->type == HFS_NODE_INDEX) &&
+	   !(node->tree->attributes & HFS_TREE_VARIDXKEYS)) {
+		retval = node->tree->max_key_len;
+	} else {
+		recoff = hfs_bnode_read_u16(node, node->tree->node_size - (rec + 1) * 2);
+		if (!recoff)
+			return 0;
+		if (node->tree->attributes & HFS_TREE_BIGKEYS)
+			retval = hfs_bnode_read_u16(node, recoff) + 2;
+		else
+			retval = (hfs_bnode_read_u8(node, recoff) | 1) + 1;
+	}
+	return retval;
+}
+
+int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	int size, key_len, rec;
+	int data_off, end_off;
+	int idx_rec_off, data_rec_off, end_rec_off;
+	u32 cnid;
+
+	tree = fd->tree;
+	if (!fd->bnode) {
+		if (!tree->root)
+			hfs_btree_inc_height(tree);
+		fd->bnode = hfs_bnode_find(tree, tree->leaf_head);
+		if (IS_ERR(fd->bnode))
+			return PTR_ERR(fd->bnode);
+		fd->record = -1;
+	}
+	new_node = NULL;
+	key_len = be16_to_cpu(fd->search_key->key_len) + 2;
+again:
+	/* new record idx and complete record size */
+	rec = fd->record + 1;
+	size = key_len + entry_len;
+
+	node = fd->bnode;
+	hfs_bnode_dump(node);
+	/* get last offset */
+	end_rec_off = tree->node_size - (node->num_recs + 1) * 2;
+	end_off = hfs_bnode_read_u16(node, end_rec_off);
+	end_rec_off -= 2;
+	dprint(DBG_BNODE_MOD, "insert_rec: %d, %d, %d, %d\n", rec, size, end_off, end_rec_off);
+	if (size > end_rec_off - end_off) {
+		if (new_node)
+			panic("not enough room!\n");
+		new_node = hfs_bnode_split(fd);
+		if (IS_ERR(new_node))
+			return PTR_ERR(new_node);
+		goto again;
+	}
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count++;
+		mark_inode_dirty(tree->inode);
+	}
+	node->num_recs++;
+	/* write new last offset */
+	hfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+	hfs_bnode_write_u16(node, end_rec_off, end_off + size);
+	data_off = end_off;
+	data_rec_off = end_rec_off + 2;
+	idx_rec_off = tree->node_size - (rec + 1) * 2;
+	if (idx_rec_off == data_rec_off)
+		goto skip;
+	/* move all following entries */
+	do {
+		data_off = hfs_bnode_read_u16(node, data_rec_off + 2);
+		hfs_bnode_write_u16(node, data_rec_off, data_off + size);
+		data_rec_off += 2;
+	} while (data_rec_off < idx_rec_off);
+
+	/* move data away */
+	hfs_bnode_move(node, data_off + size, data_off,
+		       end_off - data_off);
+
+skip:
+	hfs_bnode_write(node, fd->search_key, data_off, key_len);
+	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
+	hfs_bnode_dump(node);
+
+	if (new_node) {
+		/* update parent key if we inserted a key
+		 * at the start of the first node
+		 */
+		if (!rec && new_node != node)
+			hfs_brec_update_parent(fd);
+
+		hfs_bnode_put(fd->bnode);
+		if (!new_node->parent) {
+			hfs_btree_inc_height(tree);
+			new_node->parent = tree->root;
+		}
+		fd->bnode = hfs_bnode_find(tree, new_node->parent);
+
+		/* create index data entry */
+		cnid = cpu_to_be32(new_node->this);
+		entry = &cnid;
+		entry_len = sizeof(cnid);
+
+		/* get index key */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		__hfs_brec_find(fd->bnode, fd);
+
+		hfs_bnode_put(new_node);
+		new_node = NULL;
+
+		if (tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_len = be16_to_cpu(fd->search_key->key_len) + 2;
+		else {
+			fd->search_key->key_len = tree->max_key_len;
+			key_len = tree->max_key_len + 2;
+		}
+		goto again;
+	}
+
+	if (!rec)
+		hfs_brec_update_parent(fd);
+
+	return 0;
+}
+
+int hfs_brec_remove(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *parent;
+	int end_off, rec_off, data_off, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+again:
+	rec_off = tree->node_size - (fd->record + 2) * 2;
+	end_off = tree->node_size - (node->num_recs + 1) * 2;
+
+	if (node->type == HFS_NODE_LEAF) {
+		tree->leaf_count--;
+		mark_inode_dirty(tree->inode);
+	}
+	hfs_bnode_dump(node);
+	dprint(DBG_BNODE_MOD, "remove_rec: %d, %d\n", fd->record, fd->keylength + fd->entrylength);
+	if (!--node->num_recs) {
+		hfs_bnode_unlink(node);
+		if (!node->parent)
+			return 0;
+		parent = hfs_bnode_find(tree, node->parent);
+		if (IS_ERR(parent))
+			return PTR_ERR(parent);
+		hfs_bnode_put(node);
+		node = fd->bnode = parent;
+
+		__hfs_brec_find(node, fd);
+		goto again;
+	}
+	hfs_bnode_write_u16(node, offsetof(struct hfs_bnode_desc, num_recs), node->num_recs);
+
+	if (rec_off == end_off)
+		goto skip;
+	size = fd->keylength + fd->entrylength;
+
+	do {
+		data_off = hfs_bnode_read_u16(node, rec_off);
+		hfs_bnode_write_u16(node, rec_off + 2, data_off - size);
+		rec_off -= 2;
+	} while (rec_off >= end_off);
+
+	/* fill hole */
+	hfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,
+		       data_off - fd->keyoffset - size);
+skip:
+	hfs_bnode_dump(node);
+	if (!fd->record)
+		hfs_brec_update_parent(fd);
+	return 0;
+}
+
+struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int num_recs, new_rec_off, new_off, old_rec_off;
+	int data_start, data_end, size;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = hfs_bmap_alloc(tree);
+	if (IS_ERR(new_node))
+		return new_node;
+	hfs_bnode_get(node);
+	dprint(DBG_BNODE_MOD, "split_nodes: %d - %d - %d\n",
+		node->this, new_node->this, node->next);
+	new_node->next = node->next;
+	new_node->prev = node->this;
+	new_node->parent = node->parent;
+	new_node->type = node->type;
+	new_node->height = node->height;
+
+	size = tree->node_size / 2 - node->num_recs * 2 - 14;
+	old_rec_off = tree->node_size - 4;
+	num_recs = 1;
+	for (;;) {
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+		if (data_start > size)
+			break;
+		old_rec_off -= 2;
+		if (++num_recs < node->num_recs)
+			continue;
+		/* panic? */
+		hfs_bnode_put(node);
+		hfs_bnode_put(new_node);
+		return ERR_PTR(-ENOSPC);
+	}
+
+	if (fd->record + 1 < num_recs) {
+		/* new record is in the lower half,
+		 * so leave some more space there
+		 */
+		old_rec_off += 2;
+		num_recs--;
+		data_start = hfs_bnode_read_u16(node, old_rec_off);
+	} else {
+		hfs_bnode_put(node);
+		hfs_bnode_get(new_node);
+		fd->bnode = new_node;
+		fd->record -= num_recs;
+		fd->keyoffset -= data_start - 14;
+		fd->entryoffset -= data_start - 14;
+	}
+	new_node->num_recs = node->num_recs - num_recs;
+	node->num_recs = num_recs;
+
+	new_rec_off = tree->node_size - 2;
+	new_off = 14;
+	size = data_start - new_off;
+	num_recs = new_node->num_recs;
+	data_end = data_start;
+	while (num_recs) {
+		hfs_bnode_write_u16(new_node, new_rec_off, new_off);
+		old_rec_off -= 2;
+		new_rec_off -= 2;
+		data_end = hfs_bnode_read_u16(node, old_rec_off);
+		new_off = data_end - size;
+		num_recs--;
+	}
+	hfs_bnode_write_u16(new_node, new_rec_off, new_off);
+	hfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);
+
+	/* update new bnode header */
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));
+
+	/* update previous bnode header */
+	node->next = new_node->this;
+	hfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));
+	node_desc.next = cpu_to_be32(node->next);
+	node_desc.num_recs = cpu_to_be16(node->num_recs);
+	hfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));
+
+	/* update next bnode header */
+	if (new_node->next) {
+		struct hfs_bnode *next_node = hfs_bnode_find(tree, new_node->next);
+		next_node->prev = new_node->this;
+		hfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));
+		node_desc.prev = cpu_to_be32(next_node->prev);
+		hfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));
+		hfs_bnode_put(next_node);
+	} else if (node->this == tree->leaf_tail) {
+		/* if there is no next node, this might be the new tail */
+		tree->leaf_tail = new_node->this;
+		mark_inode_dirty(tree->inode);
+	}
+
+	hfs_bnode_dump(node);
+	hfs_bnode_dump(new_node);
+	hfs_bnode_put(node);
+
+	return new_node;
+}
+
+int hfs_brec_update_parent(struct hfs_find_data *fd)
+{
+	struct hfs_btree *tree;
+	struct hfs_bnode *node, *new_node, *parent;
+	int newkeylen, diff;
+	int rec, rec_off, end_rec_off;
+	int start_off, end_off;
+
+	tree = fd->tree;
+	node = fd->bnode;
+	new_node = NULL;
+	if (!node->parent)
+		return 0;
+
+again:
+	parent = hfs_bnode_find(tree, node->parent);
+	if (IS_ERR(parent))
+		return PTR_ERR(parent);
+	__hfs_brec_find(parent, fd);
+	hfs_bnode_dump(parent);
+	rec = fd->record;
+
+	/* size difference between old and new key */
+	if (tree->attributes & HFS_TREE_VARIDXKEYS)
+		newkeylen = hfs_bnode_read_u16(node, 14) + 2;
+	else
+		fd->keylength = newkeylen = tree->max_key_len + 2;
+	dprint(DBG_BNODE_MOD, "update_rec: %d, %d, %d\n", rec, fd->keylength, newkeylen);
+
+	rec_off = tree->node_size - (rec + 2) * 2;
+	end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+	diff = newkeylen - fd->keylength;
+	if (!diff)
+		goto skip;
+	if (diff > 0) {
+		end_off = hfs_bnode_read_u16(parent, end_rec_off);
+		if (end_rec_off - end_off < diff) {
+
+			printk("splitting index node...\n");
+			fd->bnode = parent;
+			new_node = hfs_bnode_split(fd);
+			if (IS_ERR(new_node))
+				return PTR_ERR(new_node);
+			parent = fd->bnode;
+			rec = fd->record;
+			rec_off = tree->node_size - (rec + 2) * 2;
+			end_rec_off = tree->node_size - (parent->num_recs + 1) * 2;
+		}
+	}
+
+	end_off = start_off = hfs_bnode_read_u16(parent, rec_off);
+	hfs_bnode_write_u16(parent, rec_off, start_off + diff);
+	start_off -= 4;	/* move previous cnid too */
+
+	while (rec_off > end_rec_off) {
+		rec_off -= 2;
+		end_off = hfs_bnode_read_u16(parent, rec_off);
+		hfs_bnode_write_u16(parent, rec_off, end_off + diff);
+	}
+	hfs_bnode_move(parent, start_off + diff, start_off,
+		       end_off - start_off);
+skip:
+	hfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);
+	hfs_bnode_dump(parent);
+
+	hfs_bnode_put(node);
+	node = parent;
+
+	if (new_node) {
+		u32 cnid;
+
+		fd->bnode = hfs_bnode_find(tree, new_node->parent);
+		/* create index key and entry */
+		hfs_bnode_read_key(new_node, fd->search_key, 14);
+		cnid = cpu_to_be32(new_node->this);
+
+		__hfs_brec_find(fd->bnode, fd);
+		hfs_brec_insert(fd, &cnid, sizeof(cnid));
+		hfs_bnode_put(fd->bnode);
+		hfs_bnode_put(new_node);
+
+		if (!rec) {
+			if (new_node == node)
+				goto out;
+			/* restore search_key */
+			hfs_bnode_read_key(node, fd->search_key, 14);
+		}
+	}
+
+	if (!rec && node->parent)
+		goto again;
+out:
+	fd->bnode = node;
+	return 0;
+}
+
+int hfs_btree_inc_height(struct hfs_btree *tree)
+{
+	struct hfs_bnode *node, *new_node;
+	struct hfs_bnode_desc node_desc;
+	int key_size, rec;
+	u32 cnid;
+
+	node = NULL;
+	if (tree->root) {
+		node = hfs_bnode_find(tree, tree->root);
+		if (IS_ERR(node))
+			return PTR_ERR(node);
+	}
+	new_node = hfs_bmap_alloc(tree);
+	if (IS_ERR(new_node)) {
+		hfs_bnode_put(node);
+		return PTR_ERR(new_node);
+	}
+
+	tree->root = new_node->this;
+	if (!tree->depth) {
+		tree->leaf_head = tree->leaf_tail = new_node->this;
+		new_node->type = HFS_NODE_LEAF;
+		new_node->num_recs = 0;
+	} else {
+		new_node->type = HFS_NODE_INDEX;
+		new_node->num_recs = 1;
+	}
+	new_node->parent = 0;
+	new_node->next = 0;
+	new_node->prev = 0;
+	new_node->height = ++tree->depth;
+
+	node_desc.next = cpu_to_be32(new_node->next);
+	node_desc.prev = cpu_to_be32(new_node->prev);
+	node_desc.type = new_node->type;
+	node_desc.height = new_node->height;
+	node_desc.num_recs = cpu_to_be16(new_node->num_recs);
+	node_desc.reserved = 0;
+	hfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));
+
+	rec = tree->node_size - 2;
+	hfs_bnode_write_u16(new_node, rec, 14);
+
+	if (node) {
+		/* insert old root idx into new root */
+		node->parent = tree->root;
+		if (node->type == HFS_NODE_LEAF ||
+		    tree->attributes & HFS_TREE_VARIDXKEYS)
+			key_size = hfs_bnode_read_u16(node, 14) + 2;
+		else
+			key_size = tree->max_key_len + 2;
+		hfs_bnode_copy(new_node, 14, node, 14, key_size);
+
+		if (!(tree->attributes & HFS_TREE_VARIDXKEYS)) {
+			key_size = tree->max_key_len + 2;
+			hfs_bnode_write_u16(new_node, 14, tree->max_key_len);
+		}
+		cnid = cpu_to_be32(node->this);
+		hfs_bnode_write(new_node, &cnid, 14 + key_size, 4);
+
+		rec -= 2;
+		hfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);
+
+		hfs_bnode_put(node);
+	}
+	hfs_bnode_put(new_node);
+	mark_inode_dirty(tree->inode);
+
+	return 0;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/btree.c linuxppc-2.5-benh/fs/hfsplus/btree.c
--- /dev/shm/linux-2.5/fs/hfsplus/btree.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/btree.c	2003-11-01 02:03:34.000000000 +0000
@@ -0,0 +1,319 @@
+/*
+ *  linux/fs/hfsplus/btree.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handle opening/closing btree
+ */
+
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+
+/* Get a reference to a B*Tree and do some initial checks */
+struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id)
+{
+	struct hfs_btree *tree;
+	struct hfs_btree_header_rec *head;
+	struct address_space *mapping;
+	struct page *page;
+	unsigned int shift, size;
+
+	tree = kmalloc(sizeof(*tree), GFP_KERNEL);
+	if (!tree)
+		return NULL;
+	memset(tree, 0, sizeof(*tree));
+
+	init_MUTEX(&tree->tree_lock);
+	spin_lock_init(&tree->hash_lock);
+	/* Set the correct compare function */
+	tree->sb = sb;
+	tree->cnid = id;
+	if (id == HFSPLUS_EXT_CNID) {
+		tree->keycmp = hfsplus_ext_cmp_key;
+	} else if (id == HFSPLUS_CAT_CNID) {
+		tree->keycmp = hfsplus_cat_cmp_key;
+	} else {
+		printk("HFS+-fs: unknown B*Tree requested\n");
+		goto free_tree;
+	}
+	tree->inode = iget(sb, id);
+	if (!tree->inode)
+		goto free_tree;
+
+	mapping = tree->inode->i_mapping;
+	page = read_cache_page(mapping, 0, (filler_t *)mapping->a_ops->readpage, NULL);
+	if (IS_ERR(page))
+		goto free_tree;
+
+	/* Load the header */
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+	tree->root = be32_to_cpu(head->root);
+	tree->leaf_count = be32_to_cpu(head->leaf_count);
+	tree->leaf_head = be32_to_cpu(head->leaf_head);
+	tree->leaf_tail = be32_to_cpu(head->leaf_tail);
+	tree->node_count = be32_to_cpu(head->node_count);
+	tree->free_nodes = be32_to_cpu(head->free_nodes);
+	tree->attributes = be32_to_cpu(head->attributes);
+	tree->node_size = be16_to_cpu(head->node_size);
+	tree->max_key_len = be16_to_cpu(head->max_key_len);
+	tree->depth = be16_to_cpu(head->depth);
+
+	size = tree->node_size;
+	if (!size || size & (size - 1))
+		goto fail_page;
+	if (!tree->node_count)
+		goto fail_page;
+	for (shift = 0; size >>= 1; shift += 1)
+		;
+	tree->node_size_shift = shift;
+
+	tree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+
+	kunmap(page);
+	page_cache_release(page);
+	return tree;
+
+ fail_page:
+	tree->inode->i_mapping->a_ops = &hfsplus_aops;
+	page_cache_release(page);
+ free_tree:
+	iput(tree->inode);
+	kfree(tree);
+	return NULL;
+}
+
+/* Release resources used by a btree */
+void hfs_btree_close(struct hfs_btree *tree)
+{
+	struct hfs_bnode *node;
+	int i;
+
+	if (!tree)
+		return;
+
+	for (i = 0; i < NODE_HASH_SIZE; i++) {
+		while ((node = tree->node_hash[i])) {
+			tree->node_hash[i] = node->next_hash;
+			if (atomic_read(&node->refcnt))
+				printk("HFS+: node %d:%d still has %d user(s)!\n",
+					node->tree->cnid, node->this, atomic_read(&node->refcnt));
+			hfs_bnode_free(node);
+			tree->node_hash_cnt--;
+		}
+	}
+	iput(tree->inode);
+	kfree(tree);
+}
+
+void hfs_btree_write(struct hfs_btree *tree)
+{
+	struct hfs_btree_header_rec *head;
+	struct hfs_bnode *node;
+	struct page *page;
+
+	node = hfs_bnode_find(tree, 0);
+	if (IS_ERR(node))
+		/* panic? */
+		return;
+	/* Load the header */
+	page = node->page[0];
+	head = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));
+
+	head->root = cpu_to_be32(tree->root);
+	head->leaf_count = cpu_to_be32(tree->leaf_count);
+	head->leaf_head = cpu_to_be32(tree->leaf_head);
+	head->leaf_tail = cpu_to_be32(tree->leaf_tail);
+	head->node_count = cpu_to_be32(tree->node_count);
+	head->free_nodes = cpu_to_be32(tree->free_nodes);
+	head->attributes = cpu_to_be32(tree->attributes);
+	head->depth = cpu_to_be16(tree->depth);
+
+	kunmap(page);
+	set_page_dirty(page);
+	hfs_bnode_put(node);
+}
+
+static struct hfs_bnode *hfs_bmap_new_bmap(struct hfs_bnode *prev, u32 idx)
+{
+	struct hfs_btree *tree = prev->tree;
+	struct hfs_bnode *node;
+	struct hfs_bnode_desc desc;
+	u32 cnid;
+
+	node = hfs_bnode_create(tree, idx);
+	if (IS_ERR(node))
+		return node;
+
+	tree->free_nodes--;
+	prev->next = idx;
+	cnid = cpu_to_be32(idx);
+	hfs_bnode_write(prev, &cnid, offsetof(struct hfs_bnode_desc, next), 4);
+
+	node->type = HFS_NODE_MAP;
+	node->num_recs = 1;
+	hfs_bnode_clear(node, 0, tree->node_size);
+	desc.next = 0;
+	desc.prev = 0;
+	desc.type = HFS_NODE_MAP;
+	desc.height = 0;
+	desc.num_recs = cpu_to_be16(1);
+	desc.reserved = 0;
+	hfs_bnode_write(node, &desc, 0, sizeof(desc));
+	hfs_bnode_write_u16(node, 14, 0x8000);
+	hfs_bnode_write_u16(node, tree->node_size - 2, 14);
+	hfs_bnode_write_u16(node, tree->node_size - 4, tree->node_size - 6);
+
+	return node;
+}
+
+struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)
+{
+	struct hfs_bnode *node, *next_node;
+	struct page **pagep;
+	u32 nidx, idx;
+	u16 off, len;
+	u8 *data, byte, m;
+	int i;
+
+	while (!tree->free_nodes) {
+		struct inode *inode = tree->inode;
+		u32 count;
+		int res;
+
+		res = hfsplus_file_extend(inode);
+		if (res)
+			return ERR_PTR(res);
+		inode->i_blocks = HFSPLUS_I(inode).alloc_blocks <<
+				  HFSPLUS_SB(tree->sb).fs_shift;
+		HFSPLUS_I(inode).phys_size = inode->i_size =
+			(loff_t)inode->i_blocks << tree->sb->s_blocksize_bits;
+		count = inode->i_size >> tree->node_size_shift;
+		tree->free_nodes = count - tree->node_count;
+		tree->node_count = count;
+	}
+
+	nidx = 0;
+	node = hfs_bnode_find(tree, nidx);
+	if (IS_ERR(node))
+		return node;
+	len = hfs_brec_lenoff(node, 2, &off);
+
+	off += node->page_offset;
+	pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+	data = kmap(*pagep);
+	off &= ~PAGE_CACHE_MASK;
+	idx = 0;
+
+	for (;;) {
+		while (len) {
+			byte = data[off];
+			if (byte != 0xff) {
+				for (m = 0x80, i = 0; i < 8; m >>= 1, i++) {
+					if (!(byte & m)) {
+						idx += i;
+						data[off] |= m;
+						set_page_dirty(*pagep);
+						kunmap(*pagep);
+						tree->free_nodes--;
+						mark_inode_dirty(tree->inode);
+						hfs_bnode_put(node);
+						if (!idx) {
+							printk("unexpected idx %u (%u)\n", idx, node->this);
+							BUG();
+						}
+						return hfs_bnode_create(tree, idx);
+					}
+				}
+			}
+			if (++off >= PAGE_CACHE_SIZE) {
+				kunmap(*pagep);
+				data = kmap(*++pagep);
+				off = 0;
+			}
+			idx += 8;
+			len--;
+		}
+		kunmap(*pagep);
+		nidx = node->next;
+		if (!nidx) {
+			printk("create new bmap node...\n");
+			next_node = hfs_bmap_new_bmap(node, idx);
+		} else
+			next_node = hfs_bnode_find(tree, nidx);
+		hfs_bnode_put(node);
+		if (IS_ERR(next_node))
+			return next_node;
+		node = next_node;
+
+		len = hfs_brec_lenoff(node, 0, &off);
+		off += node->page_offset;
+		pagep = node->page + (off >> PAGE_CACHE_SHIFT);
+		data = kmap(*pagep);
+		off &= ~PAGE_CACHE_MASK;
+	}
+}
+
+void hfs_bmap_free(struct hfs_bnode *node)
+{
+	struct hfs_btree *tree;
+	struct page *page;
+	u16 off, len;
+	u32 nidx;
+	u8 *data, byte, m;
+
+	dprint(DBG_BNODE_MOD, "btree_free_node: %u\n", node->this);
+	if (!node->this)
+		BUG();
+	tree = node->tree;
+	nidx = node->this;
+	node = hfs_bnode_find(tree, 0);
+	if (IS_ERR(node))
+		return;
+	len = hfs_brec_lenoff(node, 2, &off);
+	while (nidx >= len * 8) {
+		u32 i;
+
+		nidx -= len * 8;
+		i = node->next;
+		hfs_bnode_put(node);
+		if (!i) {
+			/* panic */;
+			printk("HFS: unable to free bnode %u. bmap not found!\n", node->this);
+			return;
+		}
+		node = hfs_bnode_find(tree, i);
+		if (IS_ERR(node))
+			return;
+		if (node->type != HFS_NODE_MAP) {
+			/* panic */;
+			printk("HFS: invalid bmap found! (%u,%d)\n", node->this, node->type);
+			hfs_bnode_put(node);
+			return;
+		}
+		len = hfs_brec_lenoff(node, 0, &off);
+	}
+	off += node->page_offset + nidx / 8;
+	page = node->page[off >> PAGE_CACHE_SHIFT];
+	data = kmap(page);
+	off &= ~PAGE_CACHE_MASK;
+	m = 1 << (~nidx & 7);
+	byte = data[off];
+	if (!(byte & m)) {
+		printk("HFS: trying to free free bnode %u(%d)\n", node->this, node->type);
+		kunmap(page);
+		hfs_bnode_put(node);
+		return;
+	}
+	data[off] = byte & ~m;
+	set_page_dirty(page);
+	kunmap(page);
+	hfs_bnode_put(node);
+	tree->free_nodes++;
+	mark_inode_dirty(tree->inode);
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/catalog.c linuxppc-2.5-benh/fs/hfsplus/catalog.c
--- /dev/shm/linux-2.5/fs/hfsplus/catalog.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/catalog.c	2003-11-01 02:03:36.000000000 +0000
@@ -0,0 +1,333 @@
+/*
+ *  linux/fs/hfsplus/catalog.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of catalog records
+ */
+
+#include <linux/sched.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+int hfsplus_cat_cmp_key(hfsplus_btree_key *k1, hfsplus_btree_key *k2)
+{
+	u32 k1p, k2p;
+
+	k1p = k1->cat.parent;
+	k2p = k2->cat.parent;
+	if (k1p != k2p)
+		return be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;
+
+	return hfsplus_unistrcmp(&k1->cat.name, &k2->cat.name);
+}
+
+void hfsplus_cat_build_key(hfsplus_btree_key *key, u32 parent,
+			  struct qstr *str)
+{
+	int len;
+
+	key->cat.parent = cpu_to_be32(parent);
+	if (str) {
+		hfsplus_asc2uni(&key->cat.name, str->name, str->len);
+		len = be16_to_cpu(key->cat.name.length);
+	} else
+		len = key->cat.name.length = 0;
+	key->key_len = cpu_to_be16(6 + 2 * len);
+}
+
+static void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,
+				      struct hfsplus_unistr *name)
+{
+	int ustrlen;
+
+	ustrlen = be16_to_cpu(name->length);
+	key->cat.parent = cpu_to_be32(parent);
+	key->cat.name.length = cpu_to_be16(ustrlen);
+	ustrlen *= 2;
+	memcpy(key->cat.name.unicode, name->unicode, ustrlen);
+	key->key_len = cpu_to_be16(6 + ustrlen);
+}
+
+static void hfsplus_set_perms(struct inode *inode, struct hfsplus_perm *perms)
+{
+	perms->mode = cpu_to_be32(inode->i_mode);
+	perms->owner = cpu_to_be32(inode->i_uid);
+	perms->group = cpu_to_be32(inode->i_gid);
+}
+
+static int hfsplus_cat_build_record(hfsplus_cat_entry *entry, u32 cnid, struct inode *inode)
+{
+	if (S_ISDIR(inode->i_mode)) {
+		struct hfsplus_cat_folder *folder;
+
+		folder = &entry->folder;
+		memset(folder, 0, sizeof(*folder));
+		folder->type = cpu_to_be16(HFSPLUS_FOLDER);
+		folder->id = cpu_to_be32(inode->i_ino);
+		folder->create_date = folder->content_mod_date =
+			folder->attribute_mod_date = folder->access_date =
+			hfsp_now2mt();
+		hfsplus_set_perms(inode, &folder->permissions);
+		if (inode == HFSPLUS_SB(inode->i_sb).hidden_dir)
+			/* invisible and namelocked */
+			folder->user_info.frFlags = cpu_to_be16(0x5000);
+		return sizeof(*folder);
+	} else {
+		struct hfsplus_cat_file *file;
+
+		file = &entry->file;
+		memset(file, 0, sizeof(*file));
+		file->type = cpu_to_be16(HFSPLUS_FILE);
+		file->id = cpu_to_be32(cnid);
+		file->create_date = file->content_mod_date =
+			file->attribute_mod_date = file->access_date =
+			hfsp_now2mt();
+		if (cnid == inode->i_ino) {
+			hfsplus_set_perms(inode, &file->permissions);
+			file->user_info.fdType = cpu_to_be32(HFSPLUS_SB(inode->i_sb).type);
+			file->user_info.fdCreator = cpu_to_be32(HFSPLUS_SB(inode->i_sb).creator);
+		} else {
+			file->user_info.fdType = cpu_to_be32(HFSP_HARDLINK_TYPE);
+			file->user_info.fdCreator = cpu_to_be32(HFSP_HFSPLUS_CREATOR);
+			file->user_info.fdFlags = cpu_to_be16(0x100);
+			file->permissions.dev = cpu_to_be32(HFSPLUS_I(inode).dev);
+		}
+		return sizeof(*file);
+	}
+}
+
+static int hfsplus_fill_cat_thread(hfsplus_cat_entry *entry, int type,
+				   u32 parentid, struct qstr *str)
+{
+	entry->type = cpu_to_be16(type);
+	entry->thread.reserved = 0;
+	entry->thread.parentID = cpu_to_be32(parentid);
+	hfsplus_asc2uni(&entry->thread.nodeName, str->name, str->len);
+	return 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;
+}
+
+/* Try to get a catalog entry for given catalog id */
+int hfsplus_find_cat(struct super_block *sb, u32 cnid,
+		     struct hfs_find_data *fd)
+{
+	hfsplus_cat_entry tmp;
+	int err;
+	u16 type;
+
+	hfsplus_cat_build_key(fd->search_key, cnid, NULL);
+	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
+	if (err)
+		return err;
+
+	type = be16_to_cpu(tmp.type);
+	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
+		printk("HFS+-fs: Found bad thread record in catalog\n");
+		return -EIO;
+	}
+
+	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
+				 &tmp.thread.nodeName);
+	return hfs_brec_find(fd);
+}
+
+int hfsplus_create_cat(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)
+{
+	struct hfs_find_data fd;
+	struct super_block *sb;
+	hfsplus_cat_entry entry;
+	int entry_size;
+	int err;
+
+	dprint(DBG_CAT_MOD, "create_cat: %s,%u(%d)\n", str->name, cnid, inode->i_nlink);
+	sb = dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+
+	hfsplus_cat_build_key(fd.search_key, cnid, NULL);
+	entry_size = hfsplus_fill_cat_thread(&entry, S_ISDIR(inode->i_mode) ?
+			HFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,
+			dir->i_ino, str);
+	err = hfs_brec_find(&fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&fd, &entry, entry_size);
+	if (err)
+		goto out;
+
+	hfsplus_cat_build_key(fd.search_key, dir->i_ino, str);
+	entry_size = hfsplus_cat_build_record(&entry, cnid, inode);
+	err = hfs_brec_find(&fd);
+	if (err != -ENOENT) {
+		/* panic? */
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&fd, &entry, entry_size);
+	if (!err) {
+		dir->i_size++;
+		mark_inode_dirty(dir);
+	}
+out:
+	hfs_find_exit(&fd);
+
+	return err;
+}
+
+int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)
+{
+	struct super_block *sb;
+	struct hfs_find_data fd;
+	struct hfsplus_fork_raw fork;
+	struct list_head *pos;
+	int err, off;
+	u16 type;
+
+	dprint(DBG_CAT_MOD, "delete_cat: %s,%u\n", str ? str->name : NULL, cnid);
+	sb = dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+
+	if (!str) {
+		int len;
+
+		hfsplus_cat_build_key(fd.search_key, cnid, NULL);
+		err = hfs_brec_find(&fd);
+		if (err)
+			goto out;
+
+		off = fd.entryoffset + offsetof(struct hfsplus_cat_thread, nodeName);
+		fd.search_key->cat.parent = cpu_to_be32(dir->i_ino);
+		hfs_bnode_read(fd.bnode, &fd.search_key->cat.name.length, off, 2);
+		len = be16_to_cpu(fd.search_key->cat.name.length) * 2;
+		hfs_bnode_read(fd.bnode, &fd.search_key->cat.name.unicode, off + 2, len);
+		fd.search_key->key_len = cpu_to_be16(6 + len);
+	} else
+		hfsplus_cat_build_key(fd.search_key, dir->i_ino, str);
+
+	err = hfs_brec_find(&fd);
+	if (err)
+		goto out;
+
+	type = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);
+	if (type == HFSPLUS_FILE) {
+#if 0
+		off = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);
+		hfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));
+		hfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);
+#endif
+
+		off = fd.entryoffset + offsetof(struct hfsplus_cat_file, rsrc_fork);
+		hfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));
+		hfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);
+	}
+
+	list_for_each(pos, &HFSPLUS_I(dir).open_dir_list) {
+		struct hfsplus_readdir_data *rd =
+			list_entry(pos, struct hfsplus_readdir_data, list);
+		if (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)
+			rd->file->f_pos--;
+	}
+
+	err = hfs_brec_remove(&fd);
+	if (err)
+		goto out;
+
+	hfsplus_cat_build_key(fd.search_key, cnid, NULL);
+	err = hfs_brec_find(&fd);
+	if (err)
+		goto out;
+
+	err = hfs_brec_remove(&fd);
+	if (err)
+		goto out;
+
+	dir->i_size--;
+	mark_inode_dirty(dir);
+out:
+	hfs_find_exit(&fd);
+
+	return err;
+}
+
+int hfsplus_rename_cat(u32 cnid,
+		       struct inode *src_dir, struct qstr *src_name,
+		       struct inode *dst_dir, struct qstr *dst_name)
+{
+	struct super_block *sb;
+	struct hfs_find_data src_fd, dst_fd;
+	hfsplus_cat_entry entry;
+	int entry_size, type;
+	int err = 0;
+
+	dprint(DBG_CAT_MOD, "rename_cat: %u - %lu,%s - %lu,%s\n", cnid, src_dir->i_ino, src_name->name,
+		dst_dir->i_ino, dst_name->name);
+	sb = src_dir->i_sb;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &src_fd);
+	dst_fd = src_fd;
+
+	/* find the old dir entry and read the data */
+	hfsplus_cat_build_key(src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+
+	hfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,
+				src_fd.entrylength);
+
+	/* create new dir entry with the data from the old entry */
+	hfsplus_cat_build_key(dst_fd.search_key, dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(&dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+
+	err = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);
+	if (err)
+		goto out;
+	dst_dir->i_size++;
+	mark_inode_dirty(dst_dir);
+
+	/* finally remove the old entry */
+	hfsplus_cat_build_key(src_fd.search_key, src_dir->i_ino, src_name);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+	err = hfs_brec_remove(&src_fd);
+	if (err)
+		goto out;
+	src_dir->i_size--;
+	mark_inode_dirty(src_dir);
+
+	/* remove old thread entry */
+	hfsplus_cat_build_key(src_fd.search_key, cnid, NULL);
+	err = hfs_brec_find(&src_fd);
+	if (err)
+		goto out;
+	type = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);
+	err = hfs_brec_remove(&src_fd);
+	if (err)
+		goto out;
+
+	/* create new thread entry */
+	hfsplus_cat_build_key(dst_fd.search_key, cnid, NULL);
+	entry_size = hfsplus_fill_cat_thread(&entry, type, dst_dir->i_ino, dst_name);
+	err = hfs_brec_find(&dst_fd);
+	if (err != -ENOENT) {
+		if (!err)
+			err = -EEXIST;
+		goto out;
+	}
+	err = hfs_brec_insert(&dst_fd, &entry, entry_size);
+out:
+	hfs_bnode_put(dst_fd.bnode);
+	hfs_find_exit(&src_fd);
+	return err;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/dir.c linuxppc-2.5-benh/fs/hfsplus/dir.c
--- /dev/shm/linux-2.5/fs/hfsplus/dir.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/dir.c	2003-12-24 03:48:17.000000000 +0000
@@ -0,0 +1,497 @@
+/*
+ *  linux/fs/hfsplus/dir.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of directories
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/version.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Find the entry inside dir named dentry->d_name */
+static struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+				     ,struct nameidata *nd
+#endif
+				     )
+{
+	struct inode *inode = NULL;
+	struct hfs_find_data fd;
+	struct super_block *sb;
+	hfsplus_cat_entry entry;
+	int err;
+	u32 cnid, linkid = 0;
+	u16 type;
+
+	sb = dir->i_sb;
+	dentry->d_fsdata = NULL;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(fd.search_key, dir->i_ino, &dentry->d_name);
+again:
+	err = hfs_brec_read(&fd, &entry, sizeof(entry));
+	if (err) {
+		if (err == -ENOENT) {
+			hfs_find_exit(&fd);
+			/* No such entry */
+			inode = NULL;
+			goto out;
+		}
+		goto fail;
+	}
+	type = be16_to_cpu(entry.type);
+	if (type == HFSPLUS_FOLDER) {
+		if (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {
+			err = -EIO;
+			goto fail;
+		}
+		cnid = be32_to_cpu(entry.folder.id);
+	} else if (type == HFSPLUS_FILE) {
+		if (fd.entrylength < sizeof(struct hfsplus_cat_file)) {
+			err = -EIO;
+			goto fail;
+		}
+		cnid = be32_to_cpu(entry.file.id);
+		if (entry.file.user_info.fdType == cpu_to_be32(HFSP_HARDLINK_TYPE) &&
+		    entry.file.user_info.fdCreator == cpu_to_be32(HFSP_HFSPLUS_CREATOR)) {
+			struct qstr str;
+			char name[32];
+
+			if (dentry->d_fsdata) {
+				err = -ENOENT;
+				inode = NULL;
+				goto out;
+			}
+			dentry->d_fsdata = (void *)(unsigned long)cnid;
+			linkid = be32_to_cpu(entry.file.permissions.dev);
+			str.len = sprintf(name, "iNode%d", linkid);
+			str.name = name;
+			hfsplus_cat_build_key(fd.search_key, HFSPLUS_SB(sb).hidden_dir->i_ino, &str);
+			goto again;
+		} else if (!dentry->d_fsdata)
+			dentry->d_fsdata = (void *)(unsigned long)cnid;
+	} else {
+		printk("HFS+-fs: Illegal catalog entry type in lookup\n");
+		err = -EIO;
+		goto fail;
+	}
+	hfs_find_exit(&fd);
+	inode = iget(dir->i_sb, cnid);
+	if (!inode)
+		return ERR_PTR(-EACCES);
+	if (S_ISREG(inode->i_mode))
+		HFSPLUS_I(inode).dev = linkid;
+out:
+	d_add(dentry, inode);
+	return NULL;
+fail:
+	hfs_find_exit(&fd);
+	return ERR_PTR(err);
+}
+
+static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct super_block *sb = inode->i_sb;
+	int len, err;
+	char strbuf[HFSPLUS_MAX_STRLEN + 1];
+	hfsplus_cat_entry entry;
+	struct hfs_find_data fd;
+	struct hfsplus_readdir_data *rd;
+	u16 type;
+
+	if (filp->f_pos >= inode->i_size)
+		return 0;
+
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(fd.search_key, inode->i_ino, NULL);
+	err = hfs_brec_find(&fd);
+	if (err)
+		goto out;
+
+	switch ((u32)filp->f_pos) {
+	case 0:
+		/* This is completely artificial... */
+		if (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	case 1:
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		if (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {
+			printk("HFS+-fs: bad catalog folder thread\n");
+			err = -EIO;
+			goto out;
+		}
+		if (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {
+			printk("HFS+-fs: truncated catalog thread\n");
+			err = -EIO;
+			goto out;
+		}
+		if (filldir(dirent, "..", 2, 1,
+			    be32_to_cpu(entry.thread.parentID), DT_DIR))
+			goto out;
+		filp->f_pos++;
+		/* fall through */
+	default:
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&fd, filp->f_pos - 1);
+		if (err)
+			goto out;
+	}
+
+	for (;;) {
+		if (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {
+			printk("HFS+-fs: walked past end of dir\n");
+			err = -EIO;
+			goto out;
+		}
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);
+		type = be16_to_cpu(entry.type);
+		len = HFSPLUS_MAX_STRLEN;
+		err = hfsplus_uni2asc(&fd.key->cat.name, strbuf, &len);
+		if (err)
+			goto out;
+		if (type == HFSPLUS_FOLDER) {
+			if (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {
+				printk("HFS+-fs: small dir entry\n");
+				err = -EIO;
+				goto out;
+			}
+			if (HFSPLUS_SB(sb).hidden_dir &&
+			    HFSPLUS_SB(sb).hidden_dir->i_ino == be32_to_cpu(entry.folder.id))
+				goto next;
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.folder.id), DT_DIR))
+				break;
+		} else if (type == HFSPLUS_FILE) {
+			if (fd.entrylength < sizeof(struct hfsplus_cat_file)) {
+				printk("HFS+-fs: small file entry\n");
+				err = -EIO;
+				goto out;
+			}
+			if (filldir(dirent, strbuf, len, filp->f_pos,
+				    be32_to_cpu(entry.file.id), DT_REG))
+				break;
+		} else {
+			printk("HFS+-fs: bad catalog entry type\n");
+			err = -EIO;
+			goto out;
+		}
+	next:
+		filp->f_pos++;
+		if (filp->f_pos >= inode->i_size)
+			goto out;
+		err = hfs_brec_goto(&fd, 1);
+		if (err)
+			goto out;
+	}
+	rd = filp->private_data;
+	if (!rd) {
+		rd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);
+		if (!rd) {
+			err = -ENOMEM;
+			goto out;
+		}
+		filp->private_data = rd;
+		rd->file = filp;
+		list_add(&rd->list, &HFSPLUS_I(inode).open_dir_list);
+	}
+	memcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));
+out:
+	hfs_find_exit(&fd);
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static loff_t hfsplus_seek_dir(struct file *file, loff_t offset, int origin)
+{
+	loff_t res;
+
+	down(&file->f_dentry->d_inode->i_sem);
+	res = default_llseek(file, offset, origin);
+	up(&file->f_dentry->d_inode->i_sem);
+
+	return res;
+}
+#endif
+
+static int hfsplus_dir_release(struct inode *inode, struct file *file)
+{
+	struct hfsplus_readdir_data *rd = file->private_data;
+	if (rd) {
+		list_del(&rd->list);
+		kfree(rd);
+	}
+	return 0;
+}
+
+int hfsplus_create(struct inode *dir, struct dentry *dentry, int mode
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
+{
+	struct inode *inode;
+	int res;
+
+	inode = hfsplus_new_inode(dir->i_sb, mode);
+	if (!inode)
+		return -ENOSPC;
+
+	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		iput(inode);
+		return res;
+	}
+	dentry->d_fsdata = (void *)inode->i_ino;
+	d_instantiate(dentry, inode);
+	mark_inode_dirty(inode);
+	return 0;
+}
+
+int hfsplus_link(struct dentry *src_dentry, struct inode *dst_dir, struct dentry *dst_dentry)
+{
+	struct super_block *sb = dst_dir->i_sb;
+	struct inode *inode = src_dentry->d_inode;
+	struct inode *src_dir = src_dentry->d_parent->d_inode;
+	struct qstr str;
+	char name[32];
+	u32 cnid, id;
+	int res;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		return -EPERM;
+
+	if (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {
+		for (;;) {
+			get_random_bytes(&id, sizeof(cnid));
+			id &= 0x3fffffff;
+			str.name = name;
+			str.len = sprintf(name, "iNode%d", id);
+			res = hfsplus_rename_cat(inode->i_ino,
+						 src_dir, &src_dentry->d_name,
+						 HFSPLUS_SB(sb).hidden_dir, &str);
+			if (!res)
+				break;
+			if (res != -EEXIST)
+				return res;
+		}
+		HFSPLUS_I(inode).dev = id;
+		cnid = HFSPLUS_SB(sb).next_cnid++;
+		src_dentry->d_fsdata = (void *)(unsigned long)cnid;
+		res = hfsplus_create_cat(cnid, src_dir, &src_dentry->d_name, inode);
+		if (res)
+			/* panic? */
+			return res;
+		HFSPLUS_SB(sb).file_count++;
+	}
+	cnid = HFSPLUS_SB(sb).next_cnid++;
+	res = hfsplus_create_cat(cnid, dst_dir, &dst_dentry->d_name, inode);
+	if (res)
+		return res;
+
+	inode->i_nlink++;
+	dst_dentry->d_fsdata = (void *)(unsigned long)cnid;
+	d_instantiate(dst_dentry, inode);
+	atomic_inc(&inode->i_count);
+	inode->i_ctime = CURRENT_TIME;
+	mark_inode_dirty(inode);
+	HFSPLUS_SB(sb).file_count++;
+	sb->s_dirt = 1;
+
+	return 0;
+}
+
+int hfsplus_unlink(struct inode *dir, struct dentry *dentry)
+{
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode = dentry->d_inode;
+	struct qstr str;
+	char name[32];
+	u32 cnid;
+	int res;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		return -EPERM;
+
+	cnid = (u32)(unsigned long)dentry->d_fsdata;
+	if (inode->i_ino == cnid &&
+	    atomic_read(&HFSPLUS_I(inode).opencnt)) {
+		str.name = name;
+		str.len = sprintf(name, "temp%lu", inode->i_ino);
+		res = hfsplus_rename_cat(inode->i_ino,
+					 dir, &dentry->d_name,
+					 HFSPLUS_SB(sb).hidden_dir, &str);
+		if (!res)
+			inode->i_flags |= S_DEAD;
+		return res;
+	}
+	res = hfsplus_delete_cat(cnid, dir, &dentry->d_name);
+	if (res)
+		return res;
+
+	inode->i_nlink--;
+	hfsplus_delete_inode(inode);
+	if (inode->i_ino != cnid && !inode->i_nlink) {
+		if (!atomic_read(&HFSPLUS_I(inode).opencnt)) {
+			res = hfsplus_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);
+			if (!res)
+				hfsplus_delete_inode(inode);
+		} else
+			inode->i_flags |= S_DEAD;
+	}
+	inode->i_ctime = CURRENT_TIME;
+	mark_inode_dirty(inode);
+
+	return res;
+}
+
+int hfsplus_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct inode *inode;
+	int res;
+
+	inode = hfsplus_new_inode(dir->i_sb, S_IFDIR | mode);
+	if (!inode)
+		return -ENOSPC;
+
+	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		iput(inode);
+		return res;
+	}
+	d_instantiate(dentry, inode);
+	mark_inode_dirty(inode);
+	return 0;
+}
+
+int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode;
+	int res;
+
+	inode = dentry->d_inode;
+	if (inode->i_size != 2)
+		return -ENOTEMPTY;
+	res = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);
+	if (res)
+		return res;
+	inode->i_nlink = 0;
+	inode->i_ctime = CURRENT_TIME;
+	hfsplus_delete_inode(inode);
+	mark_inode_dirty(inode);
+	return 0;
+}
+
+int hfsplus_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
+{
+	struct super_block *sb;
+	struct inode *inode;
+	int res;
+
+	sb = dir->i_sb;
+	inode = hfsplus_new_inode(sb, S_IFLNK | S_IRWXUGO);
+	if (!inode)
+		return -ENOSPC;
+
+	res = page_symlink(inode, symname, strlen(symname) + 1);
+	if (res) {
+		inode->i_nlink = 0;
+		iput (inode);
+		return res;
+	}
+
+	mark_inode_dirty(inode);
+	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
+
+	if (!res) {
+		d_instantiate(dentry, inode);
+		mark_inode_dirty(inode);
+	}
+
+	return res;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+int hfsplus_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t rdev)
+#else
+int hfsplus_mknod(struct inode *dir, struct dentry *dentry, int mode, int rdev)
+#endif
+{
+	struct super_block *sb;
+	struct inode *inode;
+	int res;
+
+	sb = dir->i_sb;
+	inode = hfsplus_new_inode(sb, mode);
+	if (!inode)
+		return -ENOSPC;
+
+	res = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);
+	if (res) {
+		inode->i_nlink = 0;
+		iput(inode);
+		return res;
+	}
+	init_special_inode(inode, mode, rdev);
+	d_instantiate(dentry, inode);
+	mark_inode_dirty(inode);
+
+	return 0;
+}
+
+int hfsplus_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int res;
+
+	/* Unlink destination if it already exists */
+	if (new_dentry->d_inode) {
+		res = hfsplus_unlink(new_dir, new_dentry);
+		if (res)
+			return res;
+	}
+
+	res = hfsplus_rename_cat((u32)(unsigned long)old_dentry->d_fsdata,
+				 old_dir, &old_dentry->d_name,
+				 new_dir, &new_dentry->d_name);
+	if (!res)
+		new_dentry->d_fsdata = old_dentry->d_fsdata;
+	return res;
+}
+
+struct inode_operations hfsplus_dir_inode_operations = {
+	.lookup		= hfsplus_lookup,
+	.create		= hfsplus_create,
+	.link		= hfsplus_link,
+	.unlink		= hfsplus_unlink,
+	.mkdir		= hfsplus_mkdir,
+	.rmdir		= hfsplus_rmdir,
+	.symlink	= hfsplus_symlink,
+	.mknod		= hfsplus_mknod,
+	.rename		= hfsplus_rename,
+};
+
+struct file_operations hfsplus_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= hfsplus_readdir,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	.llseek		= hfsplus_seek_dir,
+#else
+	.llseek		= generic_file_llseek,
+#endif
+	.release	= hfsplus_dir_release,
+};
diff -purN /dev/shm/linux-2.5/fs/hfsplus/extents.c linuxppc-2.5-benh/fs/hfsplus/extents.c
--- /dev/shm/linux-2.5/fs/hfsplus/extents.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/extents.c	2003-11-01 02:03:40.000000000 +0000
@@ -0,0 +1,502 @@
+/*
+ *  linux/fs/hfsplus/extents.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of Extents both in catalog and extents overflow trees
+ */
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/version.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Compare two extents keys, returns 0 on same, pos/neg for difference */
+int hfsplus_ext_cmp_key(hfsplus_btree_key *k1, hfsplus_btree_key *k2)
+{
+	u32 k1id, k2id;
+	u32 k1s, k2s;
+
+	k1id = k1->ext.cnid;
+	k2id = k2->ext.cnid;
+	if (k1id != k2id)
+		return be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;
+
+	if (k1->ext.fork_type != k2->ext.fork_type)
+		return k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;
+
+	k1s = k1->ext.start_block;
+	k2s = k2->ext.start_block;
+	if (k1s == k2s)
+		return 0;
+	return be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;
+}
+
+void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,
+			  u32 block, u8 type)
+{
+	key->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);
+	key->ext.cnid = cpu_to_be32(cnid);
+	key->ext.start_block = cpu_to_be32(block);
+	key->ext.fork_type = type;
+	key->ext.pad = 0;
+}
+
+static u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)
+{
+	int i;
+	u32 count;
+
+	for (i = 0; i < 8; ext++, i++) {
+		count = be32_to_cpu(ext->block_count);
+		if (off < count)
+			return be32_to_cpu(ext->start_block) + off;
+		off -= count;
+	}
+	/* panic? */
+	return 0;
+}
+
+static int hfsplus_ext_block_count(struct hfsplus_extent *ext)
+{
+	int i;
+	u32 count = 0;
+
+	for (i = 0; i < 8; ext++, i++)
+		count += be32_to_cpu(ext->block_count);
+	return count;
+}
+
+static u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)
+{
+	int i;
+
+	ext += 7;
+	for (i = 0; i < 7; ext--, i++)
+		if (ext->block_count)
+			break;
+	return be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);
+}
+
+static void __hfsplus_ext_write_extent(struct inode *inode, struct hfs_find_data *fd)
+{
+	int res;
+
+	hfsplus_ext_build_key(fd->search_key, inode->i_ino, HFSPLUS_I(inode).cached_start,
+			      HFSPLUS_IS_RSRC(inode) ?  HFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);
+	res = hfs_brec_find(fd);
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_NEW) {
+		if (res != -ENOENT)
+			return;
+		hfs_brec_insert(fd, HFSPLUS_I(inode).cached_extents, sizeof(hfsplus_extent_rec));
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+	} else {
+		if (res)
+			return;
+		hfs_bnode_write(fd->bnode, HFSPLUS_I(inode).cached_extents, fd->entryoffset, fd->entrylength);
+		HFSPLUS_I(inode).flags &= ~HFSPLUS_FLG_EXT_DIRTY;
+	}
+}
+
+void hfsplus_ext_write_extent(struct inode *inode)
+{
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_DIRTY) {
+		struct hfs_find_data fd;
+
+		hfs_find_init(HFSPLUS_SB(inode->i_sb).ext_tree, &fd);
+		__hfsplus_ext_write_extent(inode, &fd);
+		hfs_find_exit(&fd);
+	}
+}
+
+static inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,
+					    struct hfsplus_extent *extent,
+					    u32 cnid, u32 block, u8 type)
+{
+	int res;
+
+	hfsplus_ext_build_key(fd->search_key, cnid, block, type);
+	fd->key->ext.cnid = 0;
+	res = hfs_brec_find(fd);
+	if (res && res != -ENOENT)
+		return res;
+	if (fd->key->ext.cnid != fd->search_key->ext.cnid ||
+	    fd->key->ext.fork_type != fd->search_key->ext.fork_type)
+		return -ENOENT;
+	if (fd->entrylength != sizeof(hfsplus_extent_rec))
+		return -EIO;
+	hfs_bnode_read(fd->bnode, extent, fd->entryoffset, sizeof(hfsplus_extent_rec));
+	return 0;
+}
+
+static inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd, struct inode *inode, u32 block)
+{
+	int res;
+
+	if (HFSPLUS_I(inode).flags & HFSPLUS_FLG_EXT_DIRTY)
+		__hfsplus_ext_write_extent(inode, fd);
+
+	res = __hfsplus_ext_read_extent(fd, HFSPLUS_I(inode).cached_extents, inode->i_ino,
+					block, HFSPLUS_IS_RSRC(inode) ? HFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);
+	if (!res) {
+		HFSPLUS_I(inode).cached_start = be32_to_cpu(fd->key->ext.start_block);
+		HFSPLUS_I(inode).cached_blocks = hfsplus_ext_block_count(HFSPLUS_I(inode).cached_extents);
+	} else {
+		HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).cached_blocks = 0;
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+	}
+	return res;
+}
+
+static int hfsplus_ext_read_extent(struct inode *inode, u32 block)
+{
+	struct hfs_find_data fd;
+	int res;
+
+	if (block >= HFSPLUS_I(inode).cached_start &&
+	    block < HFSPLUS_I(inode).cached_start + HFSPLUS_I(inode).cached_blocks)
+		return 0;
+
+	hfs_find_init(HFSPLUS_SB(inode->i_sb).ext_tree, &fd);
+	res = __hfsplus_ext_cache_extent(&fd, inode, block);
+	hfs_find_exit(&fd);
+	return res;
+}
+
+/* Get a block at iblock for inode, possibly allocating if create */
+int hfsplus_get_block(struct inode *inode, sector_t iblock,
+		      struct buffer_head *bh_result, int create)
+{
+	struct super_block *sb;
+	int res = -EIO;
+	u32 ablock, dblock, mask;
+	int shift;
+
+	sb = inode->i_sb;
+
+	/* Convert inode block to disk allocation block */
+	shift = HFSPLUS_SB(sb).alloc_blksz_shift - sb->s_blocksize_bits;
+	ablock = iblock >> HFSPLUS_SB(sb).fs_shift;
+
+	if (iblock >= inode->i_blocks) {
+		if (iblock > inode->i_blocks || !create)
+			return -EIO;
+		if (ablock >= HFSPLUS_I(inode).alloc_blocks) {
+			res = hfsplus_file_extend(inode);
+			if (res)
+				return res;
+		}
+	} else
+		create = 0;
+
+	if (ablock < HFSPLUS_I(inode).first_blocks) {
+		dblock = hfsplus_ext_find_block(HFSPLUS_I(inode).first_extents, ablock);
+		goto done;
+	}
+
+	down(&HFSPLUS_I(inode).extents_lock);
+	res = hfsplus_ext_read_extent(inode, ablock);
+	if (!res) {
+		dblock = hfsplus_ext_find_block(HFSPLUS_I(inode).cached_extents, ablock -
+					     HFSPLUS_I(inode).cached_start);
+	} else {
+		up(&HFSPLUS_I(inode).extents_lock);
+		return -EIO;
+	}
+	up(&HFSPLUS_I(inode).extents_lock);
+
+done:
+	dprint(DBG_EXTENT, "get_block(%lu): %lu - %u\n", inode->i_ino, iblock, dblock);
+	mask = (1 << HFSPLUS_SB(sb).fs_shift) - 1;
+	map_bh(bh_result, sb, (dblock << HFSPLUS_SB(sb).fs_shift) + HFSPLUS_SB(sb).blockoffset + (iblock & mask));
+	if (create) {
+		set_buffer_new(bh_result);
+		HFSPLUS_I(inode).phys_size += sb->s_blocksize;
+		inode->i_blocks++;
+		mark_inode_dirty(inode);
+	}
+	return 0;
+}
+
+static void hfsplus_dump_extent(struct hfsplus_extent *extent)
+{
+	int i;
+
+	dprint(DBG_EXTENT, "   ");
+	for (i = 0; i < 8; i++)
+		dprint(DBG_EXTENT, " %u:%u", be32_to_cpu(extent[i].start_block),
+				 be32_to_cpu(extent[i].block_count));
+	dprint(DBG_EXTENT, "\n");
+}
+
+static int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,
+			      u32 alloc_block, u32 block_count)
+{
+	u32 count, start;
+	int i;
+
+	hfsplus_dump_extent(extent);
+	for (i = 0; i < 8; extent++, i++) {
+		count = be32_to_cpu(extent->block_count);
+		if (offset == count) {
+			start = be32_to_cpu(extent->start_block);
+			if (alloc_block != start + count) {
+				if (++i >= 8)
+					return -ENOSPC;
+				extent++;
+				extent->start_block = cpu_to_be32(alloc_block);
+			} else
+				block_count += count;
+			extent->block_count = cpu_to_be32(block_count);
+			return 0;
+		} else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+}
+
+int hfsplus_free_extents(struct super_block *sb, struct hfsplus_extent *extent,
+			 u32 offset, u32 block_nr)
+{
+	u32 count, start;
+	int i;
+
+	hfsplus_dump_extent(extent);
+	for (i = 0; i < 8; extent++, i++) {
+		count = be32_to_cpu(extent->block_count);
+		if (offset == count)
+			goto found;
+		else if (offset < count)
+			break;
+		offset -= count;
+	}
+	/* panic? */
+	return -EIO;
+found:
+	for (;;) {
+		start = be32_to_cpu(extent->start_block);
+		if (count <= block_nr) {
+			hfsplus_block_free(sb, start, count);
+			extent->block_count = 0;
+			extent->start_block = 0;
+			block_nr -= count;
+		} else {
+			count -= block_nr;
+			hfsplus_block_free(sb, start + count, block_nr);
+			extent->block_count = cpu_to_be32(count);
+			block_nr = 0;
+		}
+		if (!block_nr || !i)
+			return 0;
+		i--;
+		extent--;
+		count = be32_to_cpu(extent->block_count);
+	}
+}
+
+int hfsplus_free_fork(struct super_block *sb, u32 cnid, struct hfsplus_fork_raw *fork, int type)
+{
+	struct hfs_find_data fd;
+	hfsplus_extent_rec ext_entry;
+	u32 total_blocks, blocks, start;
+	int res, i;
+
+	total_blocks = be32_to_cpu(fork->total_blocks);
+	if (!total_blocks)
+		return 0;
+
+	blocks = 0;
+	for (i = 0; i < 8; i++)
+		blocks += be32_to_cpu(fork->extents[i].block_count);
+
+	res = hfsplus_free_extents(sb, fork->extents, blocks, blocks);
+	if (res)
+		return res;
+	if (total_blocks == blocks)
+		return 0;
+
+	hfs_find_init(HFSPLUS_SB(sb).ext_tree, &fd);
+	do {
+		res = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,
+						total_blocks, type);
+		if (res)
+			break;
+		start = be32_to_cpu(fd.key->ext.start_block);
+		hfsplus_free_extents(sb, ext_entry,
+				     total_blocks - start,
+				     total_blocks);
+		hfs_brec_remove(&fd);
+		total_blocks = start;
+	} while (total_blocks > blocks);
+	hfs_find_exit(&fd);
+
+	return res;
+}
+
+int hfsplus_file_extend(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	u32 start, len, goal;
+	int res;
+
+	if (HFSPLUS_SB(sb).alloc_file->i_size * 8 < HFSPLUS_SB(sb).total_blocks - HFSPLUS_SB(sb).free_blocks + 8) {
+		// extend alloc file
+		printk("extend alloc file! (%Lu,%u,%u)\n", HFSPLUS_SB(sb).alloc_file->i_size * 8,
+			HFSPLUS_SB(sb).total_blocks, HFSPLUS_SB(sb).free_blocks);
+		return -ENOSPC;
+		//BUG();
+	}
+
+	down(&HFSPLUS_I(inode).extents_lock);
+	if (HFSPLUS_I(inode).alloc_blocks == HFSPLUS_I(inode).first_blocks)
+		goal = hfsplus_ext_lastblock(HFSPLUS_I(inode).first_extents);
+	else {
+		res = hfsplus_ext_read_extent(inode, HFSPLUS_I(inode).alloc_blocks);
+		if (res)
+			goto out;
+		goal = hfsplus_ext_lastblock(HFSPLUS_I(inode).cached_extents);
+	}
+
+	len = HFSPLUS_I(inode).clump_blocks;
+	start = hfsplus_block_allocate(sb, HFSPLUS_SB(sb).total_blocks, goal, &len);
+	if (start >= HFSPLUS_SB(sb).total_blocks) {
+		start = hfsplus_block_allocate(sb, goal, 0, &len);
+		if (start >= goal) {
+			res = -ENOSPC;
+			goto out;
+		}
+	}
+
+	dprint(DBG_EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);
+	if (HFSPLUS_I(inode).alloc_blocks <= HFSPLUS_I(inode).first_blocks) {
+		if (!HFSPLUS_I(inode).first_blocks) {
+			dprint(DBG_EXTENT, "first extents\n");
+			/* no extents yet */
+			HFSPLUS_I(inode).first_extents[0].start_block = cpu_to_be32(start);
+			HFSPLUS_I(inode).first_extents[0].block_count = cpu_to_be32(len);
+			res = 0;
+		} else {
+			/* try to append to extents in inode */
+			res = hfsplus_add_extent(HFSPLUS_I(inode).first_extents,
+						 HFSPLUS_I(inode).alloc_blocks,
+						 start, len);
+			if (res == -ENOSPC)
+				goto insert_extent;
+		}
+		if (!res) {
+			hfsplus_dump_extent(HFSPLUS_I(inode).first_extents);
+			HFSPLUS_I(inode).first_blocks += len;
+		}
+	} else {
+		res = hfsplus_add_extent(HFSPLUS_I(inode).cached_extents,
+					 HFSPLUS_I(inode).alloc_blocks -
+					 HFSPLUS_I(inode).cached_start,
+					 start, len);
+		if (!res) {
+			hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+			HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY;
+			HFSPLUS_I(inode).cached_blocks += len;
+		} else if (res == -ENOSPC)
+			goto insert_extent;
+	}
+out:
+	up(&HFSPLUS_I(inode).extents_lock);
+	if (!res) {
+		HFSPLUS_I(inode).alloc_blocks += len;
+		mark_inode_dirty(inode);
+	}
+	return res;
+
+insert_extent:
+	dprint(DBG_EXTENT, "insert new extent\n");
+	hfsplus_ext_write_extent(inode);
+
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).cached_extents[0].start_block = cpu_to_be32(start);
+	HFSPLUS_I(inode).cached_extents[0].block_count = cpu_to_be32(len);
+	hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+	HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW;
+	HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).alloc_blocks;
+	HFSPLUS_I(inode).cached_blocks = len;
+
+	res = 0;
+	goto out;
+}
+
+void hfsplus_file_truncate(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+	struct hfs_find_data fd;
+	u32 alloc_cnt, blk_cnt, start;
+	int res;
+
+	dprint(DBG_INODE, "truncate: %lu, %Lu -> %Lu\n", inode->i_ino,
+	       (long long)HFSPLUS_I(inode).phys_size, inode->i_size);
+	if (inode->i_size > HFSPLUS_I(inode).phys_size) {
+		struct address_space *mapping = inode->i_mapping;
+		struct page *page;
+		u32 size = inode->i_size - 1;
+		int res;
+
+		page = grab_cache_page(mapping, size >> PAGE_CACHE_SHIFT);
+		if (!page)
+			return;
+		size &= PAGE_CACHE_SIZE - 1;
+		size++;
+		res = mapping->a_ops->prepare_write(NULL, page, size, size);
+		if (!res)
+			res = mapping->a_ops->commit_write(NULL, page, size, size);
+		if (res)
+			inode->i_size = HFSPLUS_I(inode).phys_size;
+		unlock_page(page);
+		page_cache_release(page);
+		mark_inode_dirty(inode);
+		return;
+	}
+	blk_cnt = (inode->i_size + HFSPLUS_SB(sb).alloc_blksz - 1) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	alloc_cnt = HFSPLUS_I(inode).alloc_blocks;
+	if (blk_cnt == alloc_cnt)
+		goto out;
+
+	down(&HFSPLUS_I(inode).extents_lock);
+	hfs_find_init(HFSPLUS_SB(sb).ext_tree, &fd);
+	while (1) {
+		if (alloc_cnt == HFSPLUS_I(inode).first_blocks) {
+			hfsplus_free_extents(sb, HFSPLUS_I(inode).first_extents,
+					     alloc_cnt, alloc_cnt - blk_cnt);
+			hfsplus_dump_extent(HFSPLUS_I(inode).first_extents);
+			HFSPLUS_I(inode).first_blocks = blk_cnt;
+			break;
+		}
+		res = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);
+		if (res)
+			break;
+		start = HFSPLUS_I(inode).cached_start;
+		hfsplus_free_extents(sb, HFSPLUS_I(inode).cached_extents,
+				     alloc_cnt - start, alloc_cnt - blk_cnt);
+		hfsplus_dump_extent(HFSPLUS_I(inode).cached_extents);
+		if (blk_cnt > start) {
+			HFSPLUS_I(inode).flags |= HFSPLUS_FLG_EXT_DIRTY;
+			break;
+		}
+		alloc_cnt = start;
+		HFSPLUS_I(inode).cached_start = HFSPLUS_I(inode).cached_blocks = 0;
+		HFSPLUS_I(inode).flags &= ~(HFSPLUS_FLG_EXT_DIRTY | HFSPLUS_FLG_EXT_NEW);
+		hfs_brec_remove(&fd);
+	}
+	hfs_find_exit(&fd);
+	up(&HFSPLUS_I(inode).extents_lock);
+
+	HFSPLUS_I(inode).alloc_blocks = blk_cnt;
+out:
+	HFSPLUS_I(inode).phys_size = inode->i_size;
+	mark_inode_dirty(inode);
+	inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/hfsplus_fs.h linuxppc-2.5-benh/fs/hfsplus/hfsplus_fs.h
--- /dev/shm/linux-2.5/fs/hfsplus/hfsplus_fs.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/hfsplus_fs.h	2003-11-01 02:03:42.000000000 +0000
@@ -0,0 +1,438 @@
+/*
+ *  linux/include/linux/hfsplus_fs.h
+ *
+ * Copyright (C) 1999
+ * Brad Boyer (flar@pants.nu)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ */
+
+#ifndef _LINUX_HFSPLUS_FS_H
+#define _LINUX_HFSPLUS_FS_H
+
+#include <linux/fs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include <linux/locks.h>
+#else
+#include <linux/buffer_head.h>
+#endif
+#include "hfsplus_raw.h"
+
+#define DBG_BNODE_REFS	0x00000001
+#define DBG_BNODE_MOD	0x00000002
+#define DBG_CAT_MOD	0x00000004
+#define DBG_INODE	0x00000008
+#define DBG_SUPER	0x00000010
+#define DBG_EXTENT	0x00000020
+#define DBG_BITMAP	0x00000040
+
+//#define DBG_MASK	(DBG_EXTENT|DBG_INODE|DBG_BNODE_MOD)
+//#define DBG_MASK	(DBG_BNODE_MOD|DBG_CAT_MOD|DBG_INODE)
+//#define DBG_MASK	(DBG_CAT_MOD|DBG_BNODE_REFS|DBG_INODE|DBG_EXTENT)
+#define DBG_MASK	(0)
+
+#define dprint(flg, fmt, args...) \
+	if (flg & DBG_MASK) printk(fmt , ## args)
+
+/* Runtime config options */
+#define HFSPLUS_DEF_CR_TYPE    0x3F3F3F3F  /* '????' */
+
+#define HFSPLUS_TYPE_DATA 0x00
+#define HFSPLUS_TYPE_RSRC 0xFF
+
+typedef int (*btree_keycmp)(hfsplus_btree_key *, hfsplus_btree_key *);
+
+#define NODE_HASH_SIZE	256
+
+/* An HFS+ BTree held in memory */
+struct hfs_btree {
+	struct super_block *sb;
+	struct inode *inode;
+	btree_keycmp keycmp;
+
+	u32 cnid;
+	u32 root;
+	u32 leaf_count;
+	u32 leaf_head;
+	u32 leaf_tail;
+	u32 node_count;
+	u32 free_nodes;
+	u32 attributes;
+
+	unsigned int node_size;
+	unsigned int node_size_shift;
+	unsigned int max_key_len;
+	unsigned int depth;
+
+	//unsigned int map1_size, map_size;
+	struct semaphore tree_lock;
+
+	unsigned int pages_per_bnode;
+	spinlock_t hash_lock;
+	struct hfs_bnode *node_hash[NODE_HASH_SIZE];
+	int node_hash_cnt;
+};
+
+struct page;
+
+/* An HFS+ BTree node in memory */
+struct hfs_bnode {
+	struct hfs_btree *tree;
+
+	u32 prev;
+	u32 this;
+	u32 next;
+	u32 parent;
+
+	u16 num_recs;
+	u8 type;
+	u8 height;
+
+	struct hfs_bnode *next_hash;
+	unsigned long flags;
+	wait_queue_head_t lock_wq;
+	atomic_t refcnt;
+	unsigned int page_offset;
+	struct page *page[0];
+};
+
+#define HFS_BNODE_LOCK		0
+#define HFS_BNODE_ERROR		1
+#define HFS_BNODE_NEW		2
+#define HFS_BNODE_DIRTY		3
+#define HFS_BNODE_DELETED	4
+
+/*
+ * HFS+ superblock info (built from Volume Header on disk)
+ */
+
+struct hfsplus_vh;
+struct hfs_btree;
+
+struct hfsplus_sb_info {
+	struct buffer_head *s_vhbh;
+	struct hfsplus_vh *s_vhdr;
+	struct hfs_btree *ext_tree;
+	struct hfs_btree *cat_tree;
+	struct hfs_btree *attr_tree;
+	struct inode *alloc_file;
+	struct inode *hidden_dir;
+
+	/* Runtime variables */
+	u32 blockoffset;
+	u32 sect_count;
+	int fs_shift;
+
+	/* Stuff in host order from Vol Header */
+	u32 alloc_blksz;
+	int alloc_blksz_shift;
+	u32 total_blocks;
+	u32 free_blocks;
+	u32 next_alloc;
+	u32 next_cnid;
+	u32 file_count;
+	u32 folder_count;
+	u32 data_clump_blocks, rsrc_clump_blocks;
+
+	/* Config options */
+	u32 creator;
+	u32 type;
+
+	umode_t umask;
+	uid_t uid;
+	gid_t gid;
+
+	int part, session;
+
+	unsigned long flags;
+
+	atomic_t inode_cnt;
+	u32 last_inode_cnt;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	struct list_head rsrc_inodes;
+#else
+	struct hlist_head rsrc_inodes;
+#endif
+};
+
+#define HFSPLUS_SB_WRITEBACKUP	0x0001
+
+
+struct hfsplus_inode_info {
+	/* Device number in hfsplus_permissions in catalog */
+	u32 dev;
+	struct semaphore extents_lock;
+	u32 clump_blocks, alloc_blocks;
+	/* Allocation extents from catalog record or volume header */
+	hfsplus_extent_rec first_extents;
+	u32 first_blocks;
+	hfsplus_extent_rec cached_extents;
+	u32 cached_start, cached_blocks;
+	atomic_t opencnt;
+
+	struct inode *rsrc_inode;
+	unsigned long flags;
+
+	struct list_head open_dir_list;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	unsigned long phys_size;
+#else
+	loff_t phys_size;
+	struct inode vfs_inode;
+#endif
+};
+
+#define HFSPLUS_FLG_RSRC	0x0001
+#define HFSPLUS_FLG_EXT_DIRTY	0x0002
+#define HFSPLUS_FLG_EXT_NEW	0x0004
+
+#define HFSPLUS_IS_DATA(inode)   (!(HFSPLUS_I(inode).flags & HFSPLUS_FLG_RSRC))
+#define HFSPLUS_IS_RSRC(inode)   (HFSPLUS_I(inode).flags & HFSPLUS_FLG_RSRC)
+
+struct hfs_find_data {
+	/* filled by caller */
+	hfsplus_btree_key *search_key;
+	hfsplus_btree_key *key;
+	/* filled by find */
+	struct hfs_btree *tree;
+	struct hfs_bnode *bnode;
+	/* filled by findrec */
+	int record;
+	int keyoffset, keylength;
+	int entryoffset, entrylength;
+};
+
+struct hfsplus_readdir_data {
+	struct list_head list;
+	struct file *file;
+	struct hfsplus_cat_key key;
+};
+
+#define hfs_btree_open hfsplus_btree_open
+#define hfs_btree_close hfsplus_btree_close
+#define hfs_btree_write hfsplus_btree_write
+#define hfs_bmap_alloc hfsplus_bmap_alloc
+#define hfs_bmap_free hfsplus_bmap_free
+#define hfs_bnode_read hfsplus_bnode_read
+#define hfs_bnode_read_u16 hfsplus_bnode_read_u16
+#define hfs_bnode_read_u8 hfsplus_bnode_read_u8
+#define hfs_bnode_read_key hfsplus_bnode_read_key
+#define hfs_bnode_write hfsplus_bnode_write
+#define hfs_bnode_write_u16 hfsplus_bnode_write_u16
+#define hfs_bnode_clear hfsplus_bnode_clear
+#define hfs_bnode_copy hfsplus_bnode_copy
+#define hfs_bnode_move hfsplus_bnode_move
+#define hfs_bnode_dump hfsplus_bnode_dump
+#define hfs_bnode_unlink hfsplus_bnode_unlink
+#define hfs_bnode_findhash hfsplus_bnode_findhash
+#define hfs_bnode_find hfsplus_bnode_find
+#define hfs_bnode_unhash hfsplus_bnode_unhash
+#define hfs_bnode_free hfsplus_bnode_free
+#define hfs_bnode_create hfsplus_bnode_create
+#define hfs_bnode_get hfsplus_bnode_get
+#define hfs_bnode_put hfsplus_bnode_put
+#define hfs_brec_lenoff hfsplus_brec_lenoff
+#define hfs_brec_keylen hfsplus_brec_keylen
+#define hfs_brec_insert hfsplus_brec_insert
+#define hfs_brec_remove hfsplus_brec_remove
+#define hfs_bnode_split hfsplus_bnode_split
+#define hfs_brec_update_parent hfsplus_brec_update_parent
+#define hfs_btree_inc_height hfsplus_btree_inc_height
+#define hfs_find_init hfsplus_find_init
+#define hfs_find_exit hfsplus_find_exit
+#define __hfs_brec_find __hplusfs_brec_find
+#define hfs_brec_find hfsplus_brec_find
+#define hfs_brec_read hfsplus_brec_read
+#define hfs_brec_goto hfsplus_brec_goto
+#define hfs_part_find hfsplus_part_find
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+typedef long sector_t;
+#endif
+
+/*
+ * Functions in any *.c used in other files
+ */
+
+/* bitmap.c */
+int hfsplus_block_allocate(struct super_block *, u32, u32, u32 *);
+int hfsplus_block_free(struct super_block *, u32, u32);
+
+/* btree.c */
+struct hfs_btree *hfs_btree_open(struct super_block *, u32);
+void hfs_btree_close(struct hfs_btree *);
+void hfs_btree_write(struct hfs_btree *);
+struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *);
+void hfs_bmap_free(struct hfs_bnode *);
+
+/* bnode.c */
+void hfs_bnode_read(struct hfs_bnode *, void *, int, int);
+u16 hfs_bnode_read_u16(struct hfs_bnode *, int);
+u8 hfs_bnode_read_u8(struct hfs_bnode *, int);
+void hfs_bnode_read_key(struct hfs_bnode *, void *, int);
+void hfs_bnode_write(struct hfs_bnode *, void *, int, int);
+void hfs_bnode_write_u16(struct hfs_bnode *, int, u16);
+void hfs_bnode_clear(struct hfs_bnode *, int, int);
+void hfs_bnode_copy(struct hfs_bnode *, int,
+		    struct hfs_bnode *, int, int);
+void hfs_bnode_move(struct hfs_bnode *, int, int, int);
+void hfs_bnode_dump(struct hfs_bnode *);
+void hfs_bnode_unlink(struct hfs_bnode *);
+struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *, u32);
+struct hfs_bnode *hfs_bnode_find(struct hfs_btree *, u32);
+void hfs_bnode_unhash(struct hfs_bnode *);
+void hfs_bnode_free(struct hfs_bnode *);
+struct hfs_bnode *hfs_bnode_create(struct hfs_btree *, u32);
+void hfs_bnode_get(struct hfs_bnode *);
+void hfs_bnode_put(struct hfs_bnode *);
+
+/* brec.c */
+u16 hfs_brec_lenoff(struct hfs_bnode *, u16, u16 *);
+u16 hfs_brec_keylen(struct hfs_bnode *, u16);
+int hfs_brec_insert(struct hfs_find_data *, void *, int);
+int hfs_brec_remove(struct hfs_find_data *);
+struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *);
+int hfs_brec_update_parent(struct hfs_find_data *);
+int hfs_btree_inc_height(struct hfs_btree *);
+
+/* bfind.c */
+int hfs_find_init(struct hfs_btree *, struct hfs_find_data *);
+void hfs_find_exit(struct hfs_find_data *);
+int __hfs_brec_find(struct hfs_bnode *, struct hfs_find_data *);
+int hfs_brec_find(struct hfs_find_data *);
+int hfs_brec_read(struct hfs_find_data *, void *, int);
+int hfs_brec_goto(struct hfs_find_data *, int);
+
+/* catalog.c */
+int hfsplus_cat_cmp_key(hfsplus_btree_key *, hfsplus_btree_key *);
+void hfsplus_cat_build_key(hfsplus_btree_key *, u32, struct qstr *);
+int hfsplus_find_cat(struct super_block *, u32, struct hfs_find_data *);
+int hfsplus_create_cat(u32, struct inode *, struct qstr *, struct inode *);
+int hfsplus_delete_cat(u32, struct inode *, struct qstr *);
+int hfsplus_rename_cat(u32, struct inode *, struct qstr *,
+		       struct inode *, struct qstr *);
+
+/* extents.c */
+int hfsplus_ext_cmp_key(hfsplus_btree_key *, hfsplus_btree_key *);
+void hfsplus_ext_build_key(hfsplus_btree_key *, u32, u32, u8);
+void hfsplus_ext_write_extent(struct inode *);
+int hfsplus_get_block(struct inode *, sector_t, struct buffer_head *, int);
+int hfsplus_free_fork(struct super_block *, u32, struct hfsplus_fork_raw *, int);
+int hfsplus_file_extend(struct inode *);
+void hfsplus_file_truncate(struct inode *);
+
+/* inode.c */
+extern struct address_space_operations hfsplus_aops;
+
+void hfsplus_inode_read_fork(struct inode *, struct hfsplus_fork_raw *);
+void hfsplus_inode_write_fork(struct inode *, struct hfsplus_fork_raw *);
+int hfsplus_cat_read_inode(struct inode *, struct hfs_find_data *);
+void hfsplus_cat_write_inode(struct inode *);
+struct inode *hfsplus_new_inode(struct super_block *, int);
+void hfsplus_delete_inode(struct inode *);
+
+extern struct address_space_operations hfsplus_btree_aops;
+
+/* options.c */
+int parse_options(char *, struct hfsplus_sb_info *);
+void fill_defaults(struct hfsplus_sb_info *);
+void fill_current(struct hfsplus_sb_info *, struct hfsplus_sb_info *);
+
+/* tables.c */
+extern u16 case_fold_table[];
+
+/* unicode.c */
+int hfsplus_unistrcmp(const struct hfsplus_unistr *, const struct hfsplus_unistr *);
+int hfsplus_uni2asc(const struct hfsplus_unistr *, char *, int *);
+int hfsplus_asc2uni(struct hfsplus_unistr *, const char *, int);
+
+/* wrapper.c */
+int hfsplus_read_wrapper(struct super_block *);
+
+int hfs_part_find(struct super_block *, sector_t *, sector_t *);
+
+/* access macros */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define HFSPLUS_SB(sb)		(*(struct hfsplus_sb_info *)&(sb)->u)
+#define HFSPLUS_I(inode)	(*(struct hfsplus_inode_info *)&(inode)->u)
+#else
+/*
+static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)
+{
+	return list_entry(inode, struct hfsplus_inode_info, vfs_inode);
+}
+*/
+#define HFSPLUS_SB(super)	(*(struct hfsplus_sb_info *)(super)->s_fs_info)
+#define HFSPLUS_I(inode)	(*list_entry(inode, struct hfsplus_inode_info, vfs_inode))
+#endif
+
+#if 1
+#define hfsplus_kmap(p)		({ struct page *__p = (p); kmap(__p); })
+#define hfsplus_kunmap(p)	({ struct page *__p = (p); kunmap(__p); __p; })
+#else
+#define hfsplus_kmap(p)		kmap(p)
+#define hfsplus_kunmap(p)	kunmap(p)
+#endif
+
+#define sb_bread512(sb, sec, data) ({			\
+	struct buffer_head *__bh;			\
+	sector_t __block;				\
+	loff_t __start;					\
+	int __offset;					\
+							\
+	__start = (loff_t)(sec) << HFSPLUS_SECTOR_SHIFT;\
+	__block = __start >> (sb)->s_blocksize_bits;	\
+	__offset = __start & ((sb)->s_blocksize - 1);	\
+	__bh = sb_bread((sb), __block);			\
+	if (likely(__bh != NULL))			\
+		data = (void *)(__bh->b_data + __offset);\
+	else						\
+		data = NULL;				\
+	__bh;						\
+})
+
+/* time macros */
+#define __hfsp_mt2ut(t)		(be32_to_cpu(t) - 2082844800U)
+#define __hfsp_ut2mt(t)		(cpu_to_be32(t + 2082844800U))
+
+/* compatibility */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define PageUptodate(page)	Page_Uptodate(page)
+#define wait_on_page_locked(page) wait_on_page(page)
+#define get_seconds()		CURRENT_TIME
+#define page_symlink(i,n,l)		block_symlink(i,n,l)
+#define map_bh(bh, sb, block) ({				\
+	bh->b_dev = kdev_t_to_nr(sb->s_dev);			\
+	bh->b_blocknr = block;					\
+	bh->b_state |= (1UL << BH_Mapped);			\
+})
+#define set_buffer_new(bh)	(bh->b_state |= (1UL << BH_New))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,21)
+#define new_inode(sb) ({					\
+	struct inode *inode = get_empty_inode();		\
+	if (inode) {						\
+		inode->i_sb = sb;				\
+		inode->i_dev = sb->s_dev;			\
+		inode->i_blkbits = sb->s_blocksize_bits;	\
+	}							\
+	inode;							\
+})
+#endif
+#define	hfsp_mt2ut(t)		__hfsp_mt2ut(t)
+#define hfsp_ut2mt(t)		__hfsp_ut2mt(t)
+#define hfsp_now2mt()		__hfsp_ut2mt(CURRENT_TIME)
+#else
+#define hfsp_mt2ut(t)		(struct timespec){ .tv_sec = __hfsp_mt2ut(t) }
+#define hfsp_ut2mt(t)		__hfsp_ut2mt((t).tv_sec)
+#define hfsp_now2mt()		__hfsp_ut2mt(get_seconds())
+
+#define kdev_t_to_nr(x)		(x)
+#endif
+
+#endif
diff -purN /dev/shm/linux-2.5/fs/hfsplus/hfsplus_raw.h linuxppc-2.5-benh/fs/hfsplus/hfsplus_raw.h
--- /dev/shm/linux-2.5/fs/hfsplus/hfsplus_raw.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/hfsplus_raw.h	2003-11-01 02:03:44.000000000 +0000
@@ -0,0 +1,322 @@
+/*
+ *  linux/include/linux/hfsplus_raw.h
+ *
+ * Copyright (C) 1999
+ * Brad Boyer (flar@pants.nu)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Format of structures on disk
+ * Information taken from Apple Technote #1150 (HFS Plus Volume Format)
+ *
+ */
+
+#ifndef _LINUX_HFSPLUS_RAW_H
+#define _LINUX_HFSPLUS_RAW_H
+
+#include <linux/types.h>
+
+#define __packed __attribute__ ((packed))
+
+/* Some constants */
+#define HFSPLUS_SECTOR_SIZE        512
+#define HFSPLUS_SECTOR_SHIFT         9
+#define HFSPLUS_VOLHEAD_SECTOR       2
+#define HFSPLUS_VOLHEAD_SIG     0x482b
+#define HFSPLUS_SUPER_MAGIC     0x482b
+#define HFSPLUS_CURRENT_VERSION      4
+
+#define HFSP_WRAP_MAGIC         0x4244
+#define HFSP_WRAP_ATTRIB_SLOCK  0x8000
+#define HFSP_WRAP_ATTRIB_SPARED 0x0200
+
+#define HFSP_WRAPOFF_SIG          0x00
+#define HFSP_WRAPOFF_ATTRIB       0x0A
+#define HFSP_WRAPOFF_ABLKSIZE     0x14
+#define HFSP_WRAPOFF_ABLKSTART    0x1C
+#define HFSP_WRAPOFF_EMBEDSIG     0x7C
+#define HFSP_WRAPOFF_EMBEDEXT     0x7E
+
+#define HFSP_HIDDENDIR_NAME	"\xe2\x90\x80\xe2\x90\x80\xe2\x90\x80\xe2\x90\x80HFS+ Private Data"
+
+#define HFSP_HARDLINK_TYPE	0x686c6e6b	/* 'hlnk' */
+#define HFSP_HFSPLUS_CREATOR	0x6866732b	/* 'hfs+' */
+
+#define HFSP_MOUNT_VERSION	0x482b4c78	/* 'H+Lx' */
+
+/* Structures used on disk */
+
+typedef u32 hfsplus_cnid;
+typedef u16 hfsplus_unichr;
+
+/* A "string" as used in filenames, etc. */
+struct hfsplus_unistr {
+	u16 length;
+	hfsplus_unichr unicode[255];
+} __packed;
+
+#define HFSPLUS_MAX_STRLEN 255
+
+/* POSIX permissions */
+struct hfsplus_perm {
+	u32 owner;
+	u32 group;
+	u32 mode;
+	u32 dev;
+} __packed;
+
+/* A single contiguous area of a file */
+struct hfsplus_extent {
+	u32 start_block;
+	u32 block_count;
+} __packed;
+typedef struct hfsplus_extent hfsplus_extent_rec[8];
+
+/* Information for a "Fork" in a file */
+struct hfsplus_fork_raw {
+	u64 total_size;
+	u32 clump_size;
+	u32 total_blocks;
+	hfsplus_extent_rec extents;
+} __packed;
+
+/* HFS+ Volume Header */
+struct hfsplus_vh {
+	u16 signature;
+	u16 version;
+	u32 attributes;
+	u32 last_mount_vers;
+	u32 reserved;
+
+	u32 create_date;
+	u32 modify_date;
+	u32 backup_date;
+	u32 checked_date;
+
+	u32 file_count;
+	u32 folder_count;
+
+	u32 blocksize;
+	u32 total_blocks;
+	u32 free_blocks;
+
+	u32 next_alloc;
+	u32 rsrc_clump_sz;
+	u32 data_clump_sz;
+	hfsplus_cnid next_cnid;
+
+	u32 write_count;
+	u64 encodings_bmp;
+
+	u8 finder_info[32];
+
+	struct hfsplus_fork_raw alloc_file;
+	struct hfsplus_fork_raw ext_file;
+	struct hfsplus_fork_raw cat_file;
+	struct hfsplus_fork_raw attr_file;
+	struct hfsplus_fork_raw start_file;
+} __packed;
+
+/* HFS+ volume attributes */
+#define HFSPLUS_VOL_UNMNT     (1 << 8)
+#define HFSPLUS_VOL_SPARE_BLK (1 << 9)
+#define HFSPLUS_VOL_NOCACHE   (1 << 10)
+#define HFSPLUS_VOL_INCNSTNT  (1 << 11)
+#define HFSPLUS_VOL_SOFTLOCK  (1 << 15)
+
+/* HFS+ BTree node descriptor */
+struct hfs_bnode_desc {
+	u32 next;
+	u32 prev;
+	s8 type;
+	u8 height;
+	u16 num_recs;
+	u16 reserved;
+} __packed;
+
+/* HFS+ BTree node types */
+#define HFS_NODE_INDEX	0x00
+#define HFS_NODE_HEADER	0x01
+#define HFS_NODE_MAP	0x02
+#define HFS_NODE_LEAF	0xFF
+
+/* HFS+ BTree header */
+struct hfs_btree_header_rec {
+	u16 depth;
+	u32 root;
+	u32 leaf_count;
+	u32 leaf_head;
+	u32 leaf_tail;
+	u16 node_size;
+	u16 max_key_len;
+	u32 node_count;
+	u32 free_nodes;
+	u16 reserved1;
+	u32 clump_size;
+	u8 btree_type;
+	u8 reserved2;
+	u32 attributes;
+	u32 reserved3[16];
+} __packed;
+
+/* BTree attributes */
+#define HFS_TREE_BIGKEYS	2
+#define HFS_TREE_VARIDXKEYS	4
+
+/* HFS+ BTree misc info */
+#define HFSPLUS_TREE_HEAD 0
+#define HFSPLUS_NODE_MXSZ 32768
+
+/* Some special File ID numbers (stolen from hfs.h) */
+#define HFSPLUS_POR_CNID		1	/* Parent Of the Root */
+#define HFSPLUS_ROOT_CNID		2	/* ROOT directory */
+#define HFSPLUS_EXT_CNID		3	/* EXTents B-tree */
+#define HFSPLUS_CAT_CNID		4	/* CATalog B-tree */
+#define HFSPLUS_BAD_CNID		5	/* BAD blocks file */
+#define HFSPLUS_ALLOC_CNID		6	/* ALLOCation file */
+#define HFSPLUS_START_CNID		7	/* STARTup file */
+#define HFSPLUS_ATTR_CNID		8	/* ATTRibutes file */
+#define HFSPLUS_EXCH_CNID		15	/* ExchangeFiles temp id */
+#define HFSPLUS_FIRSTUSER_CNID		16	/* first available user id */
+
+/* HFS+ catalog entry key */
+struct hfsplus_cat_key {
+	u16 key_len;
+	hfsplus_cnid parent;
+	struct hfsplus_unistr name;
+} __packed;
+
+
+/* Structs from hfs.h */
+struct hfsp_point {
+	u16 v;
+	u16 h;
+} __packed;
+
+struct hfsp_rect {
+	u16 top;
+	u16 left;
+	u16 bottom;
+	u16 right;
+} __packed;
+
+
+/* HFS directory info (stolen from hfs.h */
+struct DInfo {
+	struct hfsp_rect frRect;
+	u16 frFlags;
+	struct hfsp_point frLocation;
+	u16 frView;
+} __packed;
+
+struct DXInfo {
+	struct hfsp_point frScroll;
+	u32 frOpenChain;
+	u16 frUnused;
+	u16 frComment;
+	u32 frPutAway;
+} __packed;
+
+/* HFS+ folder data (part of an hfsplus_cat_entry) */
+struct hfsplus_cat_folder {
+	s16 type;
+	u16 flags;
+	u32 valence;
+	hfsplus_cnid id;
+	u32 create_date;
+	u32 content_mod_date;
+	u32 attribute_mod_date;
+	u32 access_date;
+	u32 backup_date;
+	struct hfsplus_perm permissions;
+	struct DInfo user_info;
+	struct DXInfo finder_info;
+	u32 text_encoding;
+	u32 reserved;
+} __packed;
+
+/* HFS file info (stolen from hfs.h) */
+struct FInfo {
+	u32 fdType;
+	u32 fdCreator;
+	u16 fdFlags;
+	struct hfsp_point fdLocation;
+	u16 fdFldr;
+} __packed;
+
+struct FXInfo {
+	u16 fdIconID;
+	u8 fdUnused[8];
+	u16 fdComment;
+	u32 fdPutAway;
+} __packed;
+
+/* HFS+ file data (part of a cat_entry) */
+struct hfsplus_cat_file {
+	s16 type;
+	u16 flags;
+	u32 reserved1;
+	hfsplus_cnid id;
+	u32 create_date;
+	u32 content_mod_date;
+	u32 attribute_mod_date;
+	u32 access_date;
+	u32 backup_date;
+	struct hfsplus_perm permissions;
+	struct FInfo user_info;
+	struct FXInfo finder_info;
+	u32 text_encoding;
+	u32 reserved2;
+
+	struct hfsplus_fork_raw data_fork;
+	struct hfsplus_fork_raw rsrc_fork;
+} __packed;
+
+/* File attribute bits */
+#define kHFSFileLockedBit       0x0000
+#define kHFSFileLockedMask      0x0001
+#define kHFSThreadExistsBit     0x0001
+#define kHFSThreadExistsMask    0x0002
+
+/* HFS+ catalog thread (part of a cat_entry) */
+struct hfsplus_cat_thread {
+	s16 type;
+	s16 reserved;
+	hfsplus_cnid parentID;
+	struct hfsplus_unistr nodeName;
+} __packed;
+
+#define HFSPLUS_MIN_THREAD_SZ 10
+
+/* A data record in the catalog tree */
+typedef union {
+	s16 type;
+	struct hfsplus_cat_folder folder;
+	struct hfsplus_cat_file file;
+	struct hfsplus_cat_thread thread;
+} __packed hfsplus_cat_entry;
+
+/* HFS+ catalog entry type */
+#define HFSPLUS_FOLDER         0x0001
+#define HFSPLUS_FILE           0x0002
+#define HFSPLUS_FOLDER_THREAD  0x0003
+#define HFSPLUS_FILE_THREAD    0x0004
+
+/* HFS+ extents tree key */
+struct hfsplus_ext_key {
+	u16 key_len;
+	u8 fork_type;
+	u8 pad;
+	hfsplus_cnid cnid;
+	u32 start_block;
+} __packed;
+
+#define HFSPLUS_EXT_KEYLEN 12
+
+/* HFS+ generic BTree key */
+typedef union {
+	u16 key_len;
+	struct hfsplus_cat_key cat;
+	struct hfsplus_ext_key ext;
+} __packed hfsplus_btree_key;
+
+#endif
diff -purN /dev/shm/linux-2.5/fs/hfsplus/inode.c linuxppc-2.5-benh/fs/hfsplus/inode.c
--- /dev/shm/linux-2.5/fs/hfsplus/inode.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/inode.c	2003-12-24 03:48:17.000000000 +0000
@@ -0,0 +1,561 @@
+/*
+ *  linux/fs/hfsplus/inode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Inode handling routines
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/mpage.h>
+#endif
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+static int hfsplus_readpage(struct file *file, struct page *page)
+{
+	//printk("readpage: %lu\n", page->index);
+	return block_read_full_page(page, hfsplus_get_block);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int hfsplus_writepage(struct page *page, struct writeback_control *wbc)
+{
+	//printk("writepage: %lu\n", page->index);
+	return block_write_full_page(page, hfsplus_get_block, wbc);
+}
+#else
+static int hfsplus_writepage(struct page *page)
+{
+	//printk("writepage: %lu\n", page->index);
+	return block_write_full_page(page, hfsplus_get_block);
+}
+#endif
+
+static int hfsplus_prepare_write(struct file *file, struct page *page, unsigned from, unsigned to)
+{
+	return cont_prepare_write(page, from, to, hfsplus_get_block,
+		&HFSPLUS_I(page->mapping->host).phys_size);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfsplus_bmap(struct address_space *mapping, long block)
+#else
+static sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)
+#endif
+{
+	return generic_block_bmap(mapping, block, hfsplus_get_block);
+}
+
+int hfsplus_releasepage(struct page *page, int mask)
+{
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct hfs_btree *tree;
+	struct hfs_bnode *node;
+	u32 nidx;
+	int i, res = 1;
+
+	switch (inode->i_ino) {
+	case HFSPLUS_EXT_CNID:
+		tree = HFSPLUS_SB(sb).ext_tree;
+		break;
+	case HFSPLUS_CAT_CNID:
+		tree = HFSPLUS_SB(sb).cat_tree;
+		break;
+	case HFSPLUS_ATTR_CNID:
+		tree = HFSPLUS_SB(sb).attr_tree;
+		break;
+	default:
+		BUG();
+		return 0;
+	}
+	if (tree->node_size >= PAGE_CACHE_SIZE) {
+		nidx = page->index >> (tree->node_size_shift - PAGE_CACHE_SHIFT);
+		spin_lock(&tree->hash_lock);
+		node = hfs_bnode_findhash(tree, nidx);
+		if (!node)
+			;
+		else if (atomic_read(&node->refcnt))
+			res = 0;
+		else for (i = 0; i < tree->pages_per_bnode; i++) {
+			if (PageActive(node->page[i])) {
+				res = 0;
+				break;
+			}
+		}
+		if (res && node) {
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		}
+		spin_unlock(&tree->hash_lock);
+	} else {
+		nidx = page->index << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		i = 1 << (PAGE_CACHE_SHIFT - tree->node_size_shift);
+		spin_lock(&tree->hash_lock);
+		do {
+			node = hfs_bnode_findhash(tree, nidx++);
+			if (!node)
+				continue;
+			if (atomic_read(&node->refcnt)) {
+				res = 0;
+				break;
+			}
+			hfs_bnode_unhash(node);
+			hfs_bnode_free(node);
+		} while (--i);
+		spin_unlock(&tree->hash_lock);
+	}
+	//printk("releasepage: %lu,%x = %d\n", page->index, mask, res);
+	return res;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfsplus_direct_IO(int rw, struct inode *inode, struct kiobuf *iobuf,
+			     unsigned long blocknr, int blocksize)
+{
+	return generic_direct_IO(rw, inode, iobuf, blocknr,
+				 blocksize, hfsplus_get_block);
+}
+#else
+static int hfsplus_get_blocks(struct inode *inode, sector_t iblock, unsigned long max_blocks,
+			      struct buffer_head *bh_result, int create)
+{
+	int ret;
+
+	ret = hfsplus_get_block(inode, iblock, bh_result, create);
+	if (!ret)
+		bh_result->b_size = (1 << inode->i_blkbits);
+	return ret;
+}
+
+static int hfsplus_direct_IO(int rw, struct kiocb *iocb, const struct iovec *iov,
+			  loff_t offset, unsigned long nr_segs)
+{
+	struct file *file = iocb->ki_filp;
+	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
+
+	return blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+				  offset, nr_segs, hfsplus_get_blocks, NULL);
+}
+
+static int hfsplus_writepages(struct address_space *mapping,
+			      struct writeback_control *wbc)
+{
+	return mpage_writepages(mapping, wbc, hfsplus_get_block);
+}
+#endif
+
+struct address_space_operations hfsplus_btree_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= hfsplus_prepare_write,
+	.commit_write	= generic_commit_write,
+	.bmap		= hfsplus_bmap,
+	.releasepage	= hfsplus_releasepage,
+};
+
+struct address_space_operations hfsplus_aops = {
+	.readpage	= hfsplus_readpage,
+	.writepage	= hfsplus_writepage,
+	.sync_page	= block_sync_page,
+	.prepare_write	= hfsplus_prepare_write,
+	.commit_write	= generic_commit_write,
+	.bmap		= hfsplus_bmap,
+	.direct_IO	= hfsplus_direct_IO,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	.writepages	= hfsplus_writepages,
+#endif
+};
+
+static struct dentry *hfsplus_file_lookup(struct inode *dir, struct dentry *dentry
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+					  ,struct nameidata *nd
+#endif
+		)
+{
+	struct hfs_find_data fd;
+	struct super_block *sb = dir->i_sb;
+	struct inode *inode = NULL;
+	int err;
+
+	if (HFSPLUS_IS_RSRC(dir) || strcmp(dentry->d_name.name, "rsrc"))
+		goto out;
+
+	inode = HFSPLUS_I(dir).rsrc_inode;
+	if (inode)
+		goto out;
+
+	inode = new_inode(sb);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	inode->i_ino = dir->i_ino;
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	init_MUTEX(&HFSPLUS_I(inode).extents_lock);
+	HFSPLUS_I(inode).flags = HFSPLUS_FLG_RSRC;
+
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	err = hfsplus_find_cat(sb, dir->i_ino, &fd);
+	if (!err)
+		err = hfsplus_cat_read_inode(inode, &fd);
+	hfs_find_exit(&fd);
+	if (err) {
+		iput(inode);
+		return ERR_PTR(err);
+	}
+	HFSPLUS_I(inode).rsrc_inode = dir;
+	HFSPLUS_I(dir).rsrc_inode = inode;
+	igrab(dir);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	list_add(&inode->i_hash, &HFSPLUS_SB(sb).rsrc_inodes);
+#else
+	hlist_add_head(&inode->i_hash, &HFSPLUS_SB(sb).rsrc_inodes);
+#endif
+	mark_inode_dirty(inode);
+	{
+	void hfsplus_inode_check(struct super_block *sb);
+	atomic_inc(&HFSPLUS_SB(sb).inode_cnt);
+	hfsplus_inode_check(sb);
+	}
+out:
+	d_add(dentry, inode);
+	return NULL;
+}
+
+static void hfsplus_get_perms(struct inode *inode, struct hfsplus_perm *perms, int dir)
+{
+	struct super_block *sb = inode->i_sb;
+	int mode;
+
+	mode = be32_to_cpu(perms->mode) & 0xffff;
+
+	inode->i_uid = be32_to_cpu(perms->owner);
+	if (!inode->i_uid && !mode)
+		inode->i_uid = HFSPLUS_SB(sb).uid;
+
+	inode->i_gid = be32_to_cpu(perms->group);
+	if (!inode->i_gid && !mode)
+		inode->i_gid = HFSPLUS_SB(sb).gid;
+
+	if (dir) {
+		mode = mode ? (mode & S_IALLUGO) :
+			(S_IRWXUGO & ~(HFSPLUS_SB(sb).umask));
+		mode |= S_IFDIR;
+	} else if (!mode)
+		mode = S_IFREG | ((S_IRUGO|S_IWUGO) &
+			~(HFSPLUS_SB(sb).umask));
+	inode->i_mode = mode;
+}
+
+static void hfsplus_set_perms(struct inode *inode, struct hfsplus_perm *perms)
+{
+	perms->mode = cpu_to_be32(inode->i_mode);
+	perms->owner = cpu_to_be32(inode->i_uid);
+	perms->group = cpu_to_be32(inode->i_gid);
+	perms->dev = cpu_to_be32(HFSPLUS_I(inode).dev);
+}
+
+static int hfsplus_permission(struct inode *inode, int mask
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+		, struct nameidata *nd
+#endif
+		)
+{
+	/* MAY_EXEC is also used for lookup, if no x bit is set allow lookup,
+	 * open_exec has the same test, so it's still not executable, if a x bit
+	 * is set fall back to standard permission check.
+	 */
+	if (S_ISREG(inode->i_mode) && mask & MAY_EXEC && !(inode->i_mode & 0111))
+		return 0;
+	return vfs_permission(inode, mask);
+}
+
+
+static int hfsplus_file_open(struct inode *inode, struct file *file)
+{
+	if (HFSPLUS_IS_RSRC(inode))
+		inode = HFSPLUS_I(inode).rsrc_inode;
+	if (atomic_read(&file->f_count) != 1)
+		return 0;
+	atomic_inc(&HFSPLUS_I(inode).opencnt);
+	return 0;
+}
+
+static int hfsplus_file_release(struct inode *inode, struct file *file)
+{
+	struct super_block *sb = inode->i_sb;
+
+	if (HFSPLUS_IS_RSRC(inode))
+		inode = HFSPLUS_I(inode).rsrc_inode;
+	if (atomic_read(&file->f_count) != 0)
+		return 0;
+	if (atomic_dec_and_test(&HFSPLUS_I(inode).opencnt)) {
+		down(&inode->i_sem);
+		hfsplus_file_truncate(inode);
+		if (inode->i_flags & S_DEAD) {
+			hfsplus_delete_cat(inode->i_ino, HFSPLUS_SB(sb).hidden_dir, NULL);
+			hfsplus_delete_inode(inode);
+		}
+		up(&inode->i_sem);
+	}
+	return 0;
+}
+
+extern struct inode_operations hfsplus_dir_inode_operations;
+extern struct file_operations hfsplus_dir_operations;
+
+struct inode_operations hfsplus_file_inode_operations = {
+	.lookup		= hfsplus_file_lookup,
+	.truncate	= hfsplus_file_truncate,
+	.permission	= hfsplus_permission,
+};
+
+struct file_operations hfsplus_file_operations = {
+	.llseek 	= generic_file_llseek,
+	.read		= generic_file_read,
+	//.write	= hfsplus_file_write,
+	.write		= generic_file_write,
+	.mmap		= generic_file_mmap,
+	.fsync		= file_fsync,
+	.open		= hfsplus_file_open,
+	.release	= hfsplus_file_release,
+};
+
+struct inode *hfsplus_new_inode(struct super_block *sb, int mode)
+{
+	struct inode *inode = new_inode(sb);
+	if (!inode)
+		return NULL;
+
+	{
+	void hfsplus_inode_check(struct super_block *sb);
+	atomic_inc(&HFSPLUS_SB(sb).inode_cnt);
+	hfsplus_inode_check(sb);
+	}
+	inode->i_ino = HFSPLUS_SB(sb).next_cnid++;
+	inode->i_mode = mode;
+	inode->i_uid = current->fsuid;
+	inode->i_gid = current->fsgid;
+	inode->i_nlink = 1;
+	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	init_MUTEX(&HFSPLUS_I(inode).extents_lock);
+	atomic_set(&HFSPLUS_I(inode).opencnt, 0);
+	HFSPLUS_I(inode).flags = 0;
+	if (S_ISDIR(inode->i_mode)) {
+		inode->i_size = 2;
+		HFSPLUS_SB(sb).folder_count++;
+		inode->i_op = &hfsplus_dir_inode_operations;
+		inode->i_fop = &hfsplus_dir_operations;
+	} else if (S_ISREG(inode->i_mode)) {
+		HFSPLUS_SB(sb).file_count++;
+		inode->i_op = &hfsplus_file_inode_operations;
+		inode->i_fop = &hfsplus_file_operations;
+		inode->i_mapping->a_ops = &hfsplus_aops;
+		HFSPLUS_I(inode).clump_blocks = HFSPLUS_SB(sb).data_clump_blocks;
+		memset(HFSPLUS_I(inode).first_extents, 0, sizeof(hfsplus_extent_rec));
+		memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+		HFSPLUS_I(inode).alloc_blocks = 0;
+		HFSPLUS_I(inode).first_blocks = 0;
+		HFSPLUS_I(inode).cached_start = 0;
+		HFSPLUS_I(inode).cached_blocks = 0;
+		HFSPLUS_I(inode).phys_size = 0;
+		HFSPLUS_I(inode).rsrc_inode = 0;
+	} else if (S_ISLNK(inode->i_mode)) {
+		HFSPLUS_SB(sb).file_count++;
+		inode->i_op = &page_symlink_inode_operations;
+		inode->i_mapping->a_ops = &hfsplus_aops;
+		HFSPLUS_I(inode).clump_blocks = 1;
+	} else
+		HFSPLUS_SB(sb).file_count++;
+	insert_inode_hash(inode);
+	mark_inode_dirty(inode);
+	sb->s_dirt = 1;
+
+	return inode;
+}
+
+void hfsplus_delete_inode(struct inode *inode)
+{
+	struct super_block *sb = inode->i_sb;
+
+	if (S_ISDIR(inode->i_mode)) {
+		HFSPLUS_SB(sb).folder_count--;
+		sb->s_dirt = 1;
+		return;
+	}
+	HFSPLUS_SB(sb).file_count--;
+	if (S_ISREG(inode->i_mode)) {
+		if (!inode->i_nlink) {
+			inode->i_size = 0;
+			hfsplus_file_truncate(inode);
+		}
+	} else if (S_ISLNK(inode->i_mode)) {
+		inode->i_size = 0;
+		hfsplus_file_truncate(inode);
+	}
+	sb->s_dirt = 1;
+}
+
+void hfsplus_inode_read_fork(struct inode *inode, struct hfsplus_fork_raw *fork)
+{
+	struct super_block *sb = inode->i_sb;
+	u32 count;
+	int i;
+
+	memcpy(&HFSPLUS_I(inode).first_extents, &fork->extents,
+	       sizeof(hfsplus_extent_rec));
+	for (count = 0, i = 0; i < 8; i++)
+		count += be32_to_cpu(fork->extents[i].block_count);
+	HFSPLUS_I(inode).first_blocks = count;
+	memset(HFSPLUS_I(inode).cached_extents, 0, sizeof(hfsplus_extent_rec));
+	HFSPLUS_I(inode).cached_start = 0;
+	HFSPLUS_I(inode).cached_blocks = 0;
+
+	HFSPLUS_I(inode).alloc_blocks = be32_to_cpu(fork->total_blocks);
+	inode->i_size = HFSPLUS_I(inode).phys_size = be64_to_cpu(fork->total_size);
+	inode->i_blocks = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+	HFSPLUS_I(inode).clump_blocks = be32_to_cpu(fork->clump_size) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_I(inode).clump_blocks)
+		HFSPLUS_I(inode).clump_blocks = HFSPLUS_IS_RSRC(inode) ? HFSPLUS_SB(sb).rsrc_clump_blocks :
+				HFSPLUS_SB(sb).data_clump_blocks;
+}
+
+void hfsplus_inode_write_fork(struct inode *inode, struct hfsplus_fork_raw *fork)
+{
+	memcpy(&fork->extents, &HFSPLUS_I(inode).first_extents,
+	       sizeof(hfsplus_extent_rec));
+	fork->total_size = cpu_to_be64(inode->i_size);
+	fork->total_blocks = cpu_to_be32(HFSPLUS_I(inode).alloc_blocks);
+}
+
+int hfsplus_cat_read_inode(struct inode *inode, struct hfs_find_data *fd)
+{
+	hfsplus_cat_entry entry;
+	int res = 0;
+	u16 type;
+
+	type = hfs_bnode_read_u16(fd->bnode, fd->entryoffset);
+
+	HFSPLUS_I(inode).dev = 0;
+	inode->i_blksize = PAGE_SIZE; /* Doesn't seem to be useful... */
+	if (type == HFSPLUS_FOLDER) {
+		struct hfsplus_cat_folder *folder = &entry.folder;
+
+		if (fd->entrylength < sizeof(struct hfsplus_cat_folder))
+			/* panic? */;
+		hfs_bnode_read(fd->bnode, &entry, fd->entryoffset,
+					sizeof(struct hfsplus_cat_folder));
+		hfsplus_get_perms(inode, &folder->permissions, 1);
+		inode->i_nlink = 1;
+		inode->i_size = 2 + be32_to_cpu(folder->valence);
+		inode->i_atime = hfsp_mt2ut(folder->access_date);
+		inode->i_mtime = hfsp_mt2ut(folder->content_mod_date);
+		inode->i_ctime = inode->i_mtime;
+		inode->i_blocks = 0;
+		inode->i_op = &hfsplus_dir_inode_operations;
+		inode->i_fop = &hfsplus_dir_operations;
+	} else if (type == HFSPLUS_FILE) {
+		struct hfsplus_cat_file *file = &entry.file;
+
+		if (fd->entrylength < sizeof(struct hfsplus_cat_file))
+			/* panic? */;
+		hfs_bnode_read(fd->bnode, &entry, fd->entryoffset,
+					sizeof(struct hfsplus_cat_file));
+
+		hfsplus_inode_read_fork(inode, HFSPLUS_IS_DATA(inode) ?
+					&file->data_fork : &file->rsrc_fork);
+		hfsplus_get_perms(inode, &file->permissions, 0);
+		inode->i_nlink = 1;
+		if (S_ISREG(inode->i_mode)) {
+			if (file->permissions.dev)
+				inode->i_nlink = be32_to_cpu(file->permissions.dev);
+			inode->i_op = &hfsplus_file_inode_operations;
+			inode->i_fop = &hfsplus_file_operations;
+			inode->i_mapping->a_ops = &hfsplus_aops;
+		} else if (S_ISLNK(inode->i_mode)) {
+			inode->i_op = &page_symlink_inode_operations;
+			inode->i_mapping->a_ops = &hfsplus_aops;
+		} else {
+			init_special_inode(inode, inode->i_mode,
+					   be32_to_cpu(file->permissions.dev));
+		}
+		inode->i_atime = hfsp_mt2ut(file->access_date);
+		inode->i_mtime = hfsp_mt2ut(file->content_mod_date);
+		inode->i_ctime = inode->i_mtime;
+	} else {
+		printk("HFS+-fs: bad catalog entry used to create inode\n");
+		res = -EIO;
+	}
+	return res;
+}
+
+void hfsplus_cat_write_inode(struct inode *inode)
+{
+	struct hfs_find_data fd;
+	hfsplus_cat_entry entry;
+
+	if (HFSPLUS_IS_RSRC(inode)) {
+		mark_inode_dirty(HFSPLUS_I(inode).rsrc_inode);
+		return;
+	}
+
+	if (!inode->i_nlink)
+		return;
+
+	if (hfs_find_init(HFSPLUS_SB(inode->i_sb).cat_tree, &fd))
+		/* panic? */
+		return;
+
+	if (hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd))
+		/* panic? */
+		goto out;
+
+	if (S_ISDIR(inode->i_mode)) {
+		struct hfsplus_cat_folder *folder = &entry.folder;
+
+		if (fd.entrylength < sizeof(struct hfsplus_cat_folder))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+					sizeof(struct hfsplus_cat_folder));
+		/* simple node checks? */
+		hfsplus_set_perms(inode, &folder->permissions);
+		folder->access_date = hfsp_ut2mt(inode->i_atime);
+		folder->content_mod_date = hfsp_ut2mt(inode->i_mtime);
+		folder->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
+		folder->valence = cpu_to_be32(inode->i_size - 2);
+		hfs_bnode_write(fd.bnode, &entry, fd.entryoffset,
+					 sizeof(struct hfsplus_cat_folder));
+	} else {
+		struct hfsplus_cat_file *file = &entry.file;
+
+		if (fd.entrylength < sizeof(struct hfsplus_cat_file))
+			/* panic? */;
+		hfs_bnode_read(fd.bnode, &entry, fd.entryoffset,
+					sizeof(struct hfsplus_cat_file));
+		hfsplus_inode_write_fork(inode, &file->data_fork);
+		if (HFSPLUS_I(inode).rsrc_inode)
+			hfsplus_inode_write_fork(HFSPLUS_I(inode).rsrc_inode, &file->rsrc_fork);
+		if (S_ISREG(inode->i_mode))
+			HFSPLUS_I(inode).dev = inode->i_nlink;
+		if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
+			HFSPLUS_I(inode).dev = kdev_t_to_nr(inode->i_rdev);
+		hfsplus_set_perms(inode, &file->permissions);
+		file->access_date = hfsp_ut2mt(inode->i_atime);
+		file->content_mod_date = hfsp_ut2mt(inode->i_mtime);
+		file->attribute_mod_date = hfsp_ut2mt(inode->i_ctime);
+		hfs_bnode_write(fd.bnode, &entry, fd.entryoffset,
+					 sizeof(struct hfsplus_cat_file));
+	}
+out:
+	hfs_find_exit(&fd);
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/options.c linuxppc-2.5-benh/fs/hfsplus/options.c
--- /dev/shm/linux-2.5/fs/hfsplus/options.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/options.c	2003-11-01 02:03:47.000000000 +0000
@@ -0,0 +1,145 @@
+/*
+ *  linux/fs/hfsplus/options.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Option parsing
+ */
+
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include "hfsplus_fs.h"
+
+/* Initialize an options object to reasonable defaults */
+void fill_defaults(struct hfsplus_sb_info *opts)
+{
+	if (!opts)
+		return;
+
+	opts->creator = HFSPLUS_DEF_CR_TYPE;
+	opts->type = HFSPLUS_DEF_CR_TYPE;
+	opts->umask = current->fs->umask;
+	opts->uid = current->uid;
+	opts->gid = current->gid;
+	opts->part = -1;
+	opts->session = -1;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* Copy settings from one hfsplus_sb_info object to another */
+void fill_current(struct hfsplus_sb_info *curopts,
+		  struct hfsplus_sb_info *opts)
+{
+	if (!curopts || !opts)
+		return;
+
+	opts->creator = curopts->creator;
+	opts->type = curopts->type;
+	opts->umask = curopts->umask;
+	opts->uid = curopts->uid;
+	opts->gid = curopts->gid;
+	opts->part = curopts->part;
+	opts->session = curopts->session;
+}
+#endif
+
+/* convert a "four byte character" to a 32 bit int with error checks */
+static int fill_fourchar(u32 *result, char *input)
+{
+	u32 out;
+	int i;
+
+	if (!result || !input || !*input || (strlen(input) != 4))
+		return 0;
+
+	for (out = 0, i = 0; i < 4; i++) {
+		out <<= 8;
+		out |= ((int)(input[i])) & 0xFF;
+	}
+	*result = out;
+	return 1;
+}
+
+/* convert a string to int with error checks */
+static int fill_int(int *result, char *input, int base)
+{
+	char *tmp = input;
+	int intval;
+
+	if (!result || !input || !*input)
+		return 0;
+
+	intval = simple_strtoul(tmp, &tmp, base);
+	if (*tmp)
+		return 0;
+
+	*result = intval;
+	return 1;
+}
+
+/* Parse options from mount. Returns 0 on failure */
+/* input is the options passed to mount() as a string */
+int parse_options(char *input, struct hfsplus_sb_info *results)
+{
+	char *curropt, *value;
+	int tmp;
+
+	if (!input)
+		return 1;
+
+	while ((curropt = strsep(&input,",")) != NULL) {
+		if (!*curropt)
+			continue;
+
+		if ((value = strchr(curropt, '=')) != NULL)
+			*value++ = '\0';
+
+		if (!strcmp(curropt, "creator")) {
+			if (!fill_fourchar(&(results->creator), value)) {
+				printk("HFS+-fs: creator requires a 4 character value\n");
+				return 0;
+			}
+		} else if (!strcmp(curropt, "type")) {
+			if (!fill_fourchar(&(results->type), value)) {
+				printk("HFS+-fs: type requires a 4 character value\n");
+				return 0;
+			}
+		} else if (!strcmp(curropt, "umask")) {
+			if (!fill_int(&tmp, value, 8)) {
+				printk("HFS+-fs: umask requires a value\n");
+				return 0;
+			}
+			results->umask = (umode_t)tmp;
+		} else if (!strcmp(curropt, "uid")) {
+			if (!fill_int(&tmp, value, 0)) {
+				printk("HFS+-fs: uid requires an argument\n");
+				return 0;
+			}
+			results->uid = (uid_t)tmp;
+		} else if (!strcmp(curropt, "gid")) {
+			if (!fill_int(&tmp, value, 0)) {
+				printk("HFS+-fs: gid requires an argument\n");
+				return 0;
+			}
+			results->gid = (gid_t)tmp;
+		} else if (!strcmp(curropt, "part")) {
+			if (!fill_int(&results->part, value, 0)) {
+				printk("HFS+-fs: part requires an argument\n");
+				return 0;
+			}
+		} else if (!strcmp(curropt, "session")) {
+			if (!fill_int(&results->session, value, 0)) {
+				printk("HFS+-fs: session requires an argument\n");
+				return 0;
+			}
+		} else {
+			printk("HFS+-fs: unknown option %s\n", curropt);
+			return 0;
+		}
+	}
+
+	return 1;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/part_tbl.c linuxppc-2.5-benh/fs/hfsplus/part_tbl.c
--- /dev/shm/linux-2.5/fs/hfsplus/part_tbl.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/part_tbl.c	2003-11-01 02:03:48.000000000 +0000
@@ -0,0 +1,133 @@
+/*
+ * linux/fs/hfs/part_tbl.c
+ *
+ * Copyright (C) 1996-1997  Paul H. Hargrove
+ * This file may be distributed under the terms of the GNU General Public License.
+ *
+ * Original code to handle the new style Mac partition table based on
+ * a patch contributed by Holger Schemel (aeglos@valinor.owl.de).
+ *
+ * In function preconditions the term "valid" applied to a pointer to
+ * a structure means that the pointer is non-NULL and the structure it
+ * points to has all fields initialized to consistent values.
+ *
+ */
+
+#include "hfsplus_fs.h"
+
+/* offsets to various blocks */
+#define HFS_DD_BLK		0 /* Driver Descriptor block */
+#define HFS_PMAP_BLK		1 /* First block of partition map */
+#define HFS_MDB_BLK		2 /* Block (w/i partition) of MDB */
+
+/* magic numbers for various disk blocks */
+#define HFS_DRVR_DESC_MAGIC	0x4552 /* "ER": driver descriptor map */
+#define HFS_OLD_PMAP_MAGIC	0x5453 /* "TS": old-type partition map */
+#define HFS_NEW_PMAP_MAGIC	0x504D /* "PM": new-type partition map */
+#define HFS_SUPER_MAGIC		0x4244 /* "BD": HFS MDB (super block) */
+#define HFS_MFS_SUPER_MAGIC	0xD2D7 /* MFS MDB (super block) */
+
+/*
+ * The new style Mac partition map
+ *
+ * For each partition on the media there is a physical block (512-byte
+ * block) containing one of these structures.  These blocks are
+ * contiguous starting at block 1.
+ */
+struct new_pmap {
+	u16	pmSig;		/* signature */
+	u16	reSigPad;	/* padding */
+	u32	pmMapBlkCnt;	/* partition blocks count */
+	u32	pmPyPartStart;	/* physical block start of partition */
+	u32	pmPartBlkCnt;	/* physical block count of partition */
+	u8	pmPartName[32];	/* (null terminated?) string
+				   giving the name of this
+				   partition */
+	u8	pmPartType[32];	/* (null terminated?) string
+				   giving the type of this
+				   partition */
+	/* a bunch more stuff we don't need */
+} __packed;
+
+/*
+ * The old style Mac partition map
+ *
+ * The partition map consists for a 2-byte signature followed by an
+ * array of these structures.  The map is terminated with an all-zero
+ * one of these.
+ */
+struct old_pmap {
+	u16		pdSig;	/* Signature bytes */
+	struct 	old_pmap_entry {
+		u32	pdStart;
+		u32	pdSize;
+		u32	pdFSID;
+	}	pdEntry[42];
+} __packed;
+
+/*
+ * hfs_part_find()
+ *
+ * Parse the partition map looking for the
+ * start and length of the 'part'th HFS partition.
+ */
+int hfs_part_find(struct super_block *sb,
+		  sector_t *part_start, sector_t *part_size)
+{
+	struct buffer_head *bh;
+	u16 *data;
+	int i, size, res;
+
+	res = -ENOENT;
+	bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK, data);
+	if (!bh)
+		return -EIO;
+
+	switch (be16_to_cpu(*data)) {
+	case HFS_OLD_PMAP_MAGIC:
+	  {
+		struct old_pmap *pm;
+		struct old_pmap_entry *p;
+
+		pm = (struct old_pmap *)bh->b_data;
+		p = pm->pdEntry;
+		size = 42;
+		for (i = 0; i < size; p++, i++) {
+			if (p->pdStart && p->pdSize &&
+			    p->pdFSID == cpu_to_be32(0x54465331)/*"TFS1"*/ &&
+			    (HFSPLUS_SB(sb).part < 0 || HFSPLUS_SB(sb).part == i)) {
+				*part_start += be32_to_cpu(p->pdStart);
+				*part_size = be32_to_cpu(p->pdSize);
+				res = 0;
+			}
+		}
+		break;
+	  }
+	case HFS_NEW_PMAP_MAGIC:
+	  {
+		struct new_pmap *pm;
+
+		pm = (struct new_pmap *)bh->b_data;
+		size = be32_to_cpu(pm->pmMapBlkCnt);
+		for (i = 0; i < size;) {
+			if (!memcmp(pm->pmPartType,"Apple_HFS", 9) &&
+			    (HFSPLUS_SB(sb).part < 0 || HFSPLUS_SB(sb).part == i)) {
+				*part_start += be32_to_cpu(pm->pmPyPartStart);
+				*part_size = be32_to_cpu(pm->pmPartBlkCnt);
+				res = 0;
+				break;
+			}
+			brelse(bh);
+			bh = sb_bread512(sb, *part_start + HFS_PMAP_BLK + ++i, pm);
+			if (!bh)
+				return -EIO;
+			if (pm->pmSig != cpu_to_be16(HFS_NEW_PMAP_MAGIC))
+				break;
+		}
+		break;
+	  }
+	}
+	brelse(bh);
+
+	return res;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/super.c linuxppc-2.5-benh/fs/hfsplus/super.c
--- /dev/shm/linux-2.5/fs/hfsplus/super.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/super.c	2003-12-24 03:48:17.000000000 +0000
@@ -0,0 +1,540 @@
+/*
+ *  linux/fs/hfsplus/super.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/vfs.h>
+
+static struct inode *hfsplus_alloc_inode(struct super_block *sb);
+static void hfsplus_destroy_inode(struct inode *inode);
+
+#include "hfsplus_fs.h"
+
+void hfsplus_inode_check(struct super_block *sb)
+{
+#if 0
+	u32 cnt = atomic_read(&HFSPLUS_SB(sb).inode_cnt);
+	u32 last_cnt = HFSPLUS_SB(sb).last_inode_cnt;
+
+	if (cnt <= (last_cnt / 2) ||
+	    cnt >= (last_cnt * 2)) {
+		HFSPLUS_SB(sb).last_inode_cnt = cnt;
+		printk("inode_check: %u,%u,%u\n", cnt, last_cnt,
+			HFSPLUS_SB(sb).cat_tree ? HFSPLUS_SB(sb).cat_tree->node_hash_cnt : 0);
+	}
+#endif
+}
+
+static void hfsplus_read_inode(struct inode *inode)
+{
+	struct hfs_find_data fd;
+	struct hfsplus_vh *vhdr;
+	int err;
+
+	atomic_inc(&HFSPLUS_SB(inode->i_sb).inode_cnt);
+	hfsplus_inode_check(inode->i_sb);
+	INIT_LIST_HEAD(&HFSPLUS_I(inode).open_dir_list);
+	init_MUTEX(&HFSPLUS_I(inode).extents_lock);
+	HFSPLUS_I(inode).flags = 0;
+	HFSPLUS_I(inode).rsrc_inode = NULL;
+
+	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID) {
+	read_inode:
+		hfs_find_init(HFSPLUS_SB(inode->i_sb).cat_tree, &fd);
+		err = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);
+		if (!err)
+			err = hfsplus_cat_read_inode(inode, &fd);
+		hfs_find_exit(&fd);
+		if (err)
+			goto bad_inode;
+		return;
+	}
+	vhdr = HFSPLUS_SB(inode->i_sb).s_vhdr;
+	switch(inode->i_ino) {
+	case HFSPLUS_ROOT_CNID:
+		goto read_inode;
+	case HFSPLUS_EXT_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->ext_file);
+		inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	case HFSPLUS_CAT_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->cat_file);
+		inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	case HFSPLUS_ALLOC_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->alloc_file);
+		inode->i_mapping->a_ops = &hfsplus_aops;
+		break;
+	case HFSPLUS_START_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->start_file);
+		break;
+	case HFSPLUS_ATTR_CNID:
+		hfsplus_inode_read_fork(inode, &vhdr->attr_file);
+		inode->i_mapping->a_ops = &hfsplus_btree_aops;
+		break;
+	default:
+		goto bad_inode;
+	}
+
+	return;
+
+ bad_inode:
+	make_bad_inode(inode);
+}
+
+void hfsplus_write_inode(struct inode *inode, int unused)
+{
+	struct hfsplus_vh *vhdr;
+
+	dprint(DBG_INODE, "hfsplus_write_inode: %lu\n", inode->i_ino);
+	hfsplus_ext_write_extent(inode);
+	if (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID) {
+		hfsplus_cat_write_inode(inode);
+		return;
+	}
+	vhdr = HFSPLUS_SB(inode->i_sb).s_vhdr;
+	switch (inode->i_ino) {
+	case HFSPLUS_ROOT_CNID:
+		hfsplus_cat_write_inode(inode);
+		break;
+	case HFSPLUS_EXT_CNID:
+		if (vhdr->ext_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->ext_file);
+		hfs_btree_write(HFSPLUS_SB(inode->i_sb).ext_tree);
+		break;
+	case HFSPLUS_CAT_CNID:
+		if (vhdr->cat_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->cat_file);
+		hfs_btree_write(HFSPLUS_SB(inode->i_sb).cat_tree);
+		break;
+	case HFSPLUS_ALLOC_CNID:
+		if (vhdr->alloc_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->alloc_file);
+		break;
+	case HFSPLUS_START_CNID:
+		if (vhdr->start_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->start_file);
+		break;
+	case HFSPLUS_ATTR_CNID:
+		if (vhdr->attr_file.total_size != cpu_to_be64(inode->i_size)) {
+			HFSPLUS_SB(inode->i_sb).flags |= HFSPLUS_SB_WRITEBACKUP;
+			inode->i_sb->s_dirt = 1;
+		}
+		hfsplus_inode_write_fork(inode, &vhdr->attr_file);
+		hfs_btree_write(HFSPLUS_SB(inode->i_sb).attr_tree);
+		break;
+	}
+}
+
+static void hfsplus_clear_inode(struct inode *inode)
+{
+	dprint(DBG_INODE, "hfsplus_clear_inode: %lu\n", inode->i_ino);
+	atomic_dec(&HFSPLUS_SB(inode->i_sb).inode_cnt);
+	if (HFSPLUS_IS_RSRC(inode)) {
+		HFSPLUS_I(HFSPLUS_I(inode).rsrc_inode).rsrc_inode = NULL;
+		iput(HFSPLUS_I(inode).rsrc_inode);
+	}
+	hfsplus_inode_check(inode->i_sb);
+}
+
+static void hfsplus_write_super(struct super_block *sb)
+{
+	struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+	dprint(DBG_SUPER, "hfsplus_write_super\n");
+	sb->s_dirt = 0;
+	if (sb->s_flags & MS_RDONLY)
+		/* warn? */
+		return;
+
+	vhdr->free_blocks = cpu_to_be32(HFSPLUS_SB(sb).free_blocks);
+	vhdr->next_alloc = cpu_to_be32(HFSPLUS_SB(sb).next_alloc);
+	vhdr->next_cnid = cpu_to_be32(HFSPLUS_SB(sb).next_cnid);
+	vhdr->folder_count = cpu_to_be32(HFSPLUS_SB(sb).folder_count);
+	vhdr->file_count = cpu_to_be32(HFSPLUS_SB(sb).file_count);
+
+	mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+	if (HFSPLUS_SB(sb).flags & HFSPLUS_SB_WRITEBACKUP) {
+		if (HFSPLUS_SB(sb).sect_count) {
+			struct buffer_head *bh;
+			u32 block, offset;
+
+			block = HFSPLUS_SB(sb).blockoffset;
+			block += (HFSPLUS_SB(sb).sect_count - 2) >> (sb->s_blocksize_bits - 9);
+			offset = ((HFSPLUS_SB(sb).sect_count - 2) << 9) & (sb->s_blocksize - 1);
+			printk("backup: %u,%u,%u,%u\n", HFSPLUS_SB(sb).blockoffset,
+				HFSPLUS_SB(sb).sect_count, block, offset);
+			bh = sb_bread(sb, block);
+			if (bh) {
+				vhdr = (struct hfsplus_vh *)(bh->b_data + offset);
+				if (be16_to_cpu(vhdr->signature) == HFSPLUS_VOLHEAD_SIG) {
+					memcpy(vhdr, HFSPLUS_SB(sb).s_vhdr, sizeof(*vhdr));
+					mark_buffer_dirty(bh);
+					brelse(bh);
+				} else
+					printk("backup not found!\n");
+			}
+		}
+		HFSPLUS_SB(sb).flags &= ~HFSPLUS_SB_WRITEBACKUP;
+	}
+}
+
+static void hfsplus_put_super(struct super_block *sb)
+{
+	dprint(DBG_SUPER, "hfsplus_put_super\n");
+	if (!(sb->s_flags & MS_RDONLY)) {
+		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+		vhdr->modify_date = hfsp_now2mt();
+		vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_UNMNT);
+		vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_INCNSTNT);
+		mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+		ll_rw_block(WRITE, 1, &HFSPLUS_SB(sb).s_vhbh);
+		wait_on_buffer(HFSPLUS_SB(sb).s_vhbh);
+	}
+
+	hfs_btree_close(HFSPLUS_SB(sb).cat_tree);
+	hfs_btree_close(HFSPLUS_SB(sb).ext_tree);
+	iput(HFSPLUS_SB(sb).alloc_file);
+	iput(HFSPLUS_SB(sb).hidden_dir);
+	brelse(HFSPLUS_SB(sb).s_vhbh);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int hfsplus_statfs(struct super_block *sb, struct statfs *buf)
+#else
+static int hfsplus_statfs(struct super_block *sb, struct kstatfs *buf)
+#endif
+{
+	buf->f_type = HFSPLUS_SUPER_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_blocks = HFSPLUS_SB(sb).total_blocks << HFSPLUS_SB(sb).fs_shift;
+	buf->f_bfree = HFSPLUS_SB(sb).free_blocks << HFSPLUS_SB(sb).fs_shift;
+	buf->f_bavail = buf->f_bfree;
+	buf->f_files = 0xFFFFFFFF;
+	buf->f_ffree = 0xFFFFFFFF - HFSPLUS_SB(sb).next_cnid;
+	buf->f_namelen = HFSPLUS_MAX_STRLEN;
+
+	return 0;
+}
+
+int hfsplus_remount(struct super_block *sb, int *flags, char *data)
+{
+	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
+		return 0;
+	if (!(*flags & MS_RDONLY)) {
+		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+		if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_INCNSTNT)) ||
+		    !(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+			printk("HFS+-fs warning: Filesystem was not cleanly unmounted, "
+			       "running fsck.hfsplus is recommended.  leaving read-only.\n");
+			sb->s_flags |= MS_RDONLY;
+			*flags |= MS_RDONLY;
+		} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {
+			printk("HFS+-fs: Filesystem is marked locked, leaving read-only.\n");
+			sb->s_flags |= MS_RDONLY;
+			*flags |= MS_RDONLY;
+		}
+	}
+	return 0;
+}
+
+static struct super_operations hfsplus_sops = {
+	.alloc_inode	= hfsplus_alloc_inode,
+	.destroy_inode	= hfsplus_destroy_inode,
+	.read_inode	= hfsplus_read_inode,
+	.write_inode	= hfsplus_write_inode,
+	.clear_inode	= hfsplus_clear_inode,
+	.put_super	= hfsplus_put_super,
+	.write_super	= hfsplus_write_super,
+	.statfs		= hfsplus_statfs,
+	.remount_fs	= hfsplus_remount,
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+struct super_block *hfsplus_read_super(struct super_block *sb, void *data,
+				       int silent)
+#else
+static int hfsplus_fill_super(struct super_block *sb, void *data, int silent)
+#endif
+{
+	struct hfsplus_vh *vhdr;
+	struct hfsplus_sb_info *sbi;
+	hfsplus_cat_entry entry;
+	struct hfs_find_data fd;
+	struct qstr str;
+	int err = -EINVAL;
+
+	sbi = kmalloc(sizeof(struct hfsplus_sb_info), GFP_KERNEL);
+	if (!sbi) {
+		err = -ENOMEM;
+		goto out2;
+	}
+	memset(sbi, 0, sizeof(HFSPLUS_SB(sb)));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	INIT_LIST_HEAD(&HFSPLUS_SB(sb).rsrc_inodes);
+#else
+	sb->s_fs_info = sbi;
+	INIT_HLIST_HEAD(&sbi->rsrc_inodes);
+#endif
+	fill_defaults(sbi);
+	if (!parse_options(data, sbi)) {
+		if (!silent)
+			printk("HFS+-fs: unable to parse mount options\n");
+		err = -EINVAL;
+		goto out2;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	fill_current(sbi, &HFSPLUS_SB(sb));
+	kfree(sbi);
+#endif
+
+	/* Grab the volume header */
+	if (hfsplus_read_wrapper(sb)) {
+		if (!silent)
+			printk("HFS+-fs: unable to find HFS+ superblock\n");
+		err = -EINVAL;
+		goto out2;
+	}
+	vhdr = HFSPLUS_SB(sb).s_vhdr;
+
+	/* Copy parts of the volume header into the superblock */
+	sb->s_magic = be16_to_cpu(vhdr->signature);
+	if (be16_to_cpu(vhdr->version) != HFSPLUS_CURRENT_VERSION) {
+		if (!silent)
+			printk("HFS+-fs: wrong filesystem version\n");
+		goto cleanup;
+	}
+	HFSPLUS_SB(sb).total_blocks = be32_to_cpu(vhdr->total_blocks);
+	HFSPLUS_SB(sb).free_blocks = be32_to_cpu(vhdr->free_blocks);
+	HFSPLUS_SB(sb).next_alloc = be32_to_cpu(vhdr->next_alloc);
+	HFSPLUS_SB(sb).next_cnid = be32_to_cpu(vhdr->next_cnid);
+	HFSPLUS_SB(sb).file_count = be32_to_cpu(vhdr->file_count);
+	HFSPLUS_SB(sb).folder_count = be32_to_cpu(vhdr->folder_count);
+	HFSPLUS_SB(sb).data_clump_blocks = be32_to_cpu(vhdr->data_clump_sz) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_SB(sb).data_clump_blocks)
+		HFSPLUS_SB(sb).data_clump_blocks = 1;
+	HFSPLUS_SB(sb).rsrc_clump_blocks = be32_to_cpu(vhdr->rsrc_clump_sz) >> HFSPLUS_SB(sb).alloc_blksz_shift;
+	if (!HFSPLUS_SB(sb).rsrc_clump_blocks)
+		HFSPLUS_SB(sb).rsrc_clump_blocks = 1;
+
+	/* Set up operations so we can load metadata */
+	sb->s_op = &hfsplus_sops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	sb->s_maxbytes = (1ULL << 32) - 1;
+#else
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+#endif
+
+	if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_INCNSTNT)) ||
+	    !(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+		if (!silent)
+			printk("HFS+-fs warning: Filesystem was not cleanly unmounted, "
+			       "running fsck.hfsplus is recommended.  mounting read-only.\n");
+		sb->s_flags |= MS_RDONLY;
+	} else if (vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_SOFTLOCK)) {
+		if (!silent)
+			printk("HFS+-fs: Filesystem is marked locked, mounting read-only.\n");
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	/* Load metadata objects (B*Trees) */
+	HFSPLUS_SB(sb).ext_tree = hfs_btree_open(sb, HFSPLUS_EXT_CNID);
+	if (!HFSPLUS_SB(sb).ext_tree) {
+		if (!silent)
+			printk("HFS+-fs: failed to load extents file\n");
+		goto cleanup;
+	}
+	HFSPLUS_SB(sb).cat_tree = hfs_btree_open(sb, HFSPLUS_CAT_CNID);
+	if (!HFSPLUS_SB(sb).cat_tree) {
+		if (!silent)
+			printk("HFS+-fs: failed to load catalog file\n");
+		goto cleanup;
+	}
+
+	HFSPLUS_SB(sb).alloc_file = iget(sb, HFSPLUS_ALLOC_CNID);
+	if (!HFSPLUS_SB(sb).alloc_file) {
+		if (!silent)
+			printk("HFS+-fs: failed to load allocation file\n");
+		goto cleanup;
+	}
+
+	/* Load the root directory */
+	sb->s_root = d_alloc_root(iget(sb, HFSPLUS_ROOT_CNID));
+	if (!sb->s_root) {
+		if (!silent)
+			printk("HFS+-fs: failed to load root directory\n");
+		goto cleanup;
+	}
+
+	str.len = sizeof(HFSP_HIDDENDIR_NAME) - 1;
+	str.name = HFSP_HIDDENDIR_NAME;
+	hfs_find_init(HFSPLUS_SB(sb).cat_tree, &fd);
+	hfsplus_cat_build_key(fd.search_key, HFSPLUS_ROOT_CNID, &str);
+	if (!hfs_brec_read(&fd, &entry, sizeof(entry))) {
+		hfs_find_exit(&fd);
+		if (entry.type != cpu_to_be16(HFSPLUS_FOLDER))
+			goto cleanup;
+		HFSPLUS_SB(sb).hidden_dir = iget(sb, be32_to_cpu(entry.folder.id));
+		if (!HFSPLUS_SB(sb).hidden_dir)
+			goto cleanup;
+	} else
+		hfs_find_exit(&fd);
+
+	if (sb->s_flags & MS_RDONLY)
+		goto out;
+
+	/* H+LX == hfsplusutils, H+Lx == this driver, H+lx is unused
+	 * all three are registered with Apple for our use
+	 */
+	vhdr->last_mount_vers = cpu_to_be32(HFSP_MOUNT_VERSION);
+	vhdr->modify_date = hfsp_now2mt();
+	vhdr->write_count = cpu_to_be32(be32_to_cpu(vhdr->write_count) + 1);
+	vhdr->attributes &= cpu_to_be32(~HFSPLUS_VOL_UNMNT);
+	vhdr->attributes |= cpu_to_be32(HFSPLUS_VOL_INCNSTNT);
+	mark_buffer_dirty(HFSPLUS_SB(sb).s_vhbh);
+	ll_rw_block(WRITE, 1, &HFSPLUS_SB(sb).s_vhbh);
+	wait_on_buffer(HFSPLUS_SB(sb).s_vhbh);
+
+	if (!HFSPLUS_SB(sb).hidden_dir) {
+		printk("HFS+: create hidden dir...\n");
+		HFSPLUS_SB(sb).hidden_dir = hfsplus_new_inode(sb, S_IFDIR);
+		hfsplus_create_cat(HFSPLUS_SB(sb).hidden_dir->i_ino, sb->s_root->d_inode,
+				   &str, HFSPLUS_SB(sb).hidden_dir);
+		mark_inode_dirty(HFSPLUS_SB(sb).hidden_dir);
+	}
+out:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return sb;
+#else
+	return 0;
+#endif
+
+cleanup:
+	hfsplus_put_super(sb);
+out2:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return NULL;
+#else
+	return err;
+#endif
+}
+
+MODULE_AUTHOR("Brad Boyer");
+MODULE_DESCRIPTION("Extended Macintosh Filesystem");
+MODULE_LICENSE("GPL");
+
+static kmem_cache_t *hfsplus_inode_cachep;
+
+static struct inode *hfsplus_alloc_inode(struct super_block *sb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	return kmem_cache_alloc(hfsplus_inode_cachep, SLAB_KERNEL);
+#else
+	struct hfsplus_inode_info *i;
+
+	i = kmem_cache_alloc(hfsplus_inode_cachep, SLAB_KERNEL);
+	return i ? &i->vfs_inode : NULL;
+#endif
+}
+
+static void hfsplus_destroy_inode(struct inode *inode)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	kmem_cache_free(hfsplus_inode_cachep, inode);
+#else
+	kmem_cache_free(hfsplus_inode_cachep, &HFSPLUS_I(inode));
+#endif
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define HFSPLUS_INODE_SIZE	(sizeof(struct hfsplus_inode_info) + offsetof(struct inode, u) + 8)
+
+static DECLARE_FSTYPE_DEV(hfsplus_fs_type, "hfsplus", hfsplus_read_super);
+
+EXPORT_NO_SYMBOLS;
+
+#else
+
+#define HFSPLUS_INODE_SIZE	sizeof(struct hfsplus_inode_info)
+
+static struct super_block *hfsplus_get_sb(struct file_system_type *fs_type,
+					  int flags, const char *dev_name, void *data)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super);
+}
+
+static struct file_system_type hfsplus_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "hfsplus",
+	.get_sb		= hfsplus_get_sb,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+#endif
+
+static void hfsplus_init_once(void *p, kmem_cache_t *cachep, unsigned long flags)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	struct inode *i = p;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) == SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(i);
+#else
+	struct hfsplus_inode_info *i = p;
+
+	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) == SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&i->vfs_inode);
+#endif
+}
+
+static int __init init_hfsplus_fs(void)
+{
+	int err;
+
+	hfsplus_inode_cachep = kmem_cache_create("hfsplus_icache",
+		HFSPLUS_INODE_SIZE, 0, SLAB_HWCACHE_ALIGN,
+		hfsplus_init_once, NULL);
+	if (!hfsplus_inode_cachep)
+		return -ENOMEM;
+	err = register_filesystem(&hfsplus_fs_type);
+	if (err)
+		kmem_cache_destroy(hfsplus_inode_cachep);
+	return err;
+}
+
+static void __exit exit_hfsplus_fs(void)
+{
+	unregister_filesystem(&hfsplus_fs_type);
+	if (kmem_cache_destroy(hfsplus_inode_cachep))
+		printk(KERN_INFO "hfsplus_inode_cache: not all structures were freed\n");
+}
+
+module_init(init_hfsplus_fs)
+module_exit(exit_hfsplus_fs)
diff -purN /dev/shm/linux-2.5/fs/hfsplus/tables.c linuxppc-2.5-benh/fs/hfsplus/tables.c
--- /dev/shm/linux-2.5/fs/hfsplus/tables.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/tables.c	2003-11-01 02:03:52.000000000 +0000
@@ -0,0 +1,408 @@
+/*
+ * linux/fs/hfsplus/tables.c
+ *
+ * Various data tables
+ */
+
+#include "hfsplus_fs.h"
+
+/*
+ *  Unicode case folding table taken from Apple Technote #1150
+ *  (HFS Plus Volume Format)
+ */
+
+u16 case_fold_table[] = {
+/*
+ *  The lower case table consists of a 256-entry high-byte table followed by
+ *  some number of 256-entry subtables. The high-byte table contains either an
+ *  offset to the subtable for characters with that high byte or zero, which
+ *  means that there are no case mappings or ignored characters in that block.
+ *  Ignored characters are mapped to zero.
+ */
+
+    // High-byte indices ( == 0 iff no case mapping and no ignorables )
+
+
+    /* 0 */ 0x0100, 0x0200, 0x0000, 0x0300, 0x0400, 0x0500, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 1 */ 0x0600, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 2 */ 0x0700, 0x0800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 3 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 4 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 5 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 6 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 7 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 8 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 9 */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* A */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* B */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* C */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* D */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* E */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* F */ 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+            0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0900, 0x0A00,
+
+    // Table 1 (for high byte 0x00)
+
+    /* 0 */ 0xFFFF, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+            0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
+    /* 1 */ 0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+            0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
+    /* 2 */ 0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+            0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
+    /* 3 */ 0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
+            0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
+    /* 4 */ 0x0040, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+            0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
+    /* 5 */ 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+            0x0078, 0x0079, 0x007A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
+    /* 6 */ 0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
+            0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
+    /* 7 */ 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
+            0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x007F,
+    /* 8 */ 0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+            0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x008D, 0x008E, 0x008F,
+    /* 9 */ 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+            0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F,
+    /* A */ 0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7,
+            0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
+    /* B */ 0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7,
+            0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF,
+    /* C */ 0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00E6, 0x00C7,
+            0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF,
+    /* D */ 0x00F0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7,
+            0x00F8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00FE, 0x00DF,
+    /* E */ 0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7,
+            0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF,
+    /* F */ 0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
+            0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
+
+    // Table 2 (for high byte 0x01)
+
+    /* 0 */ 0x0100, 0x0101, 0x0102, 0x0103, 0x0104, 0x0105, 0x0106, 0x0107,
+            0x0108, 0x0109, 0x010A, 0x010B, 0x010C, 0x010D, 0x010E, 0x010F,
+    /* 1 */ 0x0111, 0x0111, 0x0112, 0x0113, 0x0114, 0x0115, 0x0116, 0x0117,
+            0x0118, 0x0119, 0x011A, 0x011B, 0x011C, 0x011D, 0x011E, 0x011F,
+    /* 2 */ 0x0120, 0x0121, 0x0122, 0x0123, 0x0124, 0x0125, 0x0127, 0x0127,
+            0x0128, 0x0129, 0x012A, 0x012B, 0x012C, 0x012D, 0x012E, 0x012F,
+    /* 3 */ 0x0130, 0x0131, 0x0133, 0x0133, 0x0134, 0x0135, 0x0136, 0x0137,
+            0x0138, 0x0139, 0x013A, 0x013B, 0x013C, 0x013D, 0x013E, 0x0140,
+    /* 4 */ 0x0140, 0x0142, 0x0142, 0x0143, 0x0144, 0x0145, 0x0146, 0x0147,
+            0x0148, 0x0149, 0x014B, 0x014B, 0x014C, 0x014D, 0x014E, 0x014F,
+    /* 5 */ 0x0150, 0x0151, 0x0153, 0x0153, 0x0154, 0x0155, 0x0156, 0x0157,
+            0x0158, 0x0159, 0x015A, 0x015B, 0x015C, 0x015D, 0x015E, 0x015F,
+    /* 6 */ 0x0160, 0x0161, 0x0162, 0x0163, 0x0164, 0x0165, 0x0167, 0x0167,
+            0x0168, 0x0169, 0x016A, 0x016B, 0x016C, 0x016D, 0x016E, 0x016F,
+    /* 7 */ 0x0170, 0x0171, 0x0172, 0x0173, 0x0174, 0x0175, 0x0176, 0x0177,
+            0x0178, 0x0179, 0x017A, 0x017B, 0x017C, 0x017D, 0x017E, 0x017F,
+    /* 8 */ 0x0180, 0x0253, 0x0183, 0x0183, 0x0185, 0x0185, 0x0254, 0x0188,
+            0x0188, 0x0256, 0x0257, 0x018C, 0x018C, 0x018D, 0x01DD, 0x0259,
+    /* 9 */ 0x025B, 0x0192, 0x0192, 0x0260, 0x0263, 0x0195, 0x0269, 0x0268,
+            0x0199, 0x0199, 0x019A, 0x019B, 0x026F, 0x0272, 0x019E, 0x0275,
+    /* A */ 0x01A0, 0x01A1, 0x01A3, 0x01A3, 0x01A5, 0x01A5, 0x01A6, 0x01A8,
+            0x01A8, 0x0283, 0x01AA, 0x01AB, 0x01AD, 0x01AD, 0x0288, 0x01AF,
+    /* B */ 0x01B0, 0x028A, 0x028B, 0x01B4, 0x01B4, 0x01B6, 0x01B6, 0x0292,
+            0x01B9, 0x01B9, 0x01BA, 0x01BB, 0x01BD, 0x01BD, 0x01BE, 0x01BF,
+    /* C */ 0x01C0, 0x01C1, 0x01C2, 0x01C3, 0x01C6, 0x01C6, 0x01C6, 0x01C9,
+            0x01C9, 0x01C9, 0x01CC, 0x01CC, 0x01CC, 0x01CD, 0x01CE, 0x01CF,
+    /* D */ 0x01D0, 0x01D1, 0x01D2, 0x01D3, 0x01D4, 0x01D5, 0x01D6, 0x01D7,
+            0x01D8, 0x01D9, 0x01DA, 0x01DB, 0x01DC, 0x01DD, 0x01DE, 0x01DF,
+    /* E */ 0x01E0, 0x01E1, 0x01E2, 0x01E3, 0x01E5, 0x01E5, 0x01E6, 0x01E7,
+            0x01E8, 0x01E9, 0x01EA, 0x01EB, 0x01EC, 0x01ED, 0x01EE, 0x01EF,
+    /* F */ 0x01F0, 0x01F3, 0x01F3, 0x01F3, 0x01F4, 0x01F5, 0x01F6, 0x01F7,
+            0x01F8, 0x01F9, 0x01FA, 0x01FB, 0x01FC, 0x01FD, 0x01FE, 0x01FF,
+
+    // Table 3 (for high byte 0x03)
+
+    /* 0 */ 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0305, 0x0306, 0x0307,
+            0x0308, 0x0309, 0x030A, 0x030B, 0x030C, 0x030D, 0x030E, 0x030F,
+    /* 1 */ 0x0310, 0x0311, 0x0312, 0x0313, 0x0314, 0x0315, 0x0316, 0x0317,
+            0x0318, 0x0319, 0x031A, 0x031B, 0x031C, 0x031D, 0x031E, 0x031F,
+    /* 2 */ 0x0320, 0x0321, 0x0322, 0x0323, 0x0324, 0x0325, 0x0326, 0x0327,
+            0x0328, 0x0329, 0x032A, 0x032B, 0x032C, 0x032D, 0x032E, 0x032F,
+    /* 3 */ 0x0330, 0x0331, 0x0332, 0x0333, 0x0334, 0x0335, 0x0336, 0x0337,
+            0x0338, 0x0339, 0x033A, 0x033B, 0x033C, 0x033D, 0x033E, 0x033F,
+    /* 4 */ 0x0340, 0x0341, 0x0342, 0x0343, 0x0344, 0x0345, 0x0346, 0x0347,
+            0x0348, 0x0349, 0x034A, 0x034B, 0x034C, 0x034D, 0x034E, 0x034F,
+    /* 5 */ 0x0350, 0x0351, 0x0352, 0x0353, 0x0354, 0x0355, 0x0356, 0x0357,
+            0x0358, 0x0359, 0x035A, 0x035B, 0x035C, 0x035D, 0x035E, 0x035F,
+    /* 6 */ 0x0360, 0x0361, 0x0362, 0x0363, 0x0364, 0x0365, 0x0366, 0x0367,
+            0x0368, 0x0369, 0x036A, 0x036B, 0x036C, 0x036D, 0x036E, 0x036F,
+    /* 7 */ 0x0370, 0x0371, 0x0372, 0x0373, 0x0374, 0x0375, 0x0376, 0x0377,
+            0x0378, 0x0379, 0x037A, 0x037B, 0x037C, 0x037D, 0x037E, 0x037F,
+    /* 8 */ 0x0380, 0x0381, 0x0382, 0x0383, 0x0384, 0x0385, 0x0386, 0x0387,
+            0x0388, 0x0389, 0x038A, 0x038B, 0x038C, 0x038D, 0x038E, 0x038F,
+    /* 9 */ 0x0390, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
+            0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
+    /* A */ 0x03C0, 0x03C1, 0x03A2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
+            0x03C8, 0x03C9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
+    /* B */ 0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7,
+            0x03B8, 0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF,
+    /* C */ 0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
+            0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0x03CF,
+    /* D */ 0x03D0, 0x03D1, 0x03D2, 0x03D3, 0x03D4, 0x03D5, 0x03D6, 0x03D7,
+            0x03D8, 0x03D9, 0x03DA, 0x03DB, 0x03DC, 0x03DD, 0x03DE, 0x03DF,
+    /* E */ 0x03E0, 0x03E1, 0x03E3, 0x03E3, 0x03E5, 0x03E5, 0x03E7, 0x03E7,
+            0x03E9, 0x03E9, 0x03EB, 0x03EB, 0x03ED, 0x03ED, 0x03EF, 0x03EF,
+    /* F */ 0x03F0, 0x03F1, 0x03F2, 0x03F3, 0x03F4, 0x03F5, 0x03F6, 0x03F7,
+            0x03F8, 0x03F9, 0x03FA, 0x03FB, 0x03FC, 0x03FD, 0x03FE, 0x03FF,
+
+    // Table 4 (for high byte 0x04)
+
+    /* 0 */ 0x0400, 0x0401, 0x0452, 0x0403, 0x0454, 0x0455, 0x0456, 0x0407,
+            0x0458, 0x0459, 0x045A, 0x045B, 0x040C, 0x040D, 0x040E, 0x045F,
+    /* 1 */ 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
+            0x0438, 0x0419, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+    /* 2 */ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
+            0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+    /* 3 */ 0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
+            0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
+    /* 4 */ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
+            0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
+    /* 5 */ 0x0450, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
+            0x0458, 0x0459, 0x045A, 0x045B, 0x045C, 0x045D, 0x045E, 0x045F,
+    /* 6 */ 0x0461, 0x0461, 0x0463, 0x0463, 0x0465, 0x0465, 0x0467, 0x0467,
+            0x0469, 0x0469, 0x046B, 0x046B, 0x046D, 0x046D, 0x046F, 0x046F,
+    /* 7 */ 0x0471, 0x0471, 0x0473, 0x0473, 0x0475, 0x0475, 0x0476, 0x0477,
+            0x0479, 0x0479, 0x047B, 0x047B, 0x047D, 0x047D, 0x047F, 0x047F,
+    /* 8 */ 0x0481, 0x0481, 0x0482, 0x0483, 0x0484, 0x0485, 0x0486, 0x0487,
+            0x0488, 0x0489, 0x048A, 0x048B, 0x048C, 0x048D, 0x048E, 0x048F,
+    /* 9 */ 0x0491, 0x0491, 0x0493, 0x0493, 0x0495, 0x0495, 0x0497, 0x0497,
+            0x0499, 0x0499, 0x049B, 0x049B, 0x049D, 0x049D, 0x049F, 0x049F,
+    /* A */ 0x04A1, 0x04A1, 0x04A3, 0x04A3, 0x04A5, 0x04A5, 0x04A7, 0x04A7,
+            0x04A9, 0x04A9, 0x04AB, 0x04AB, 0x04AD, 0x04AD, 0x04AF, 0x04AF,
+    /* B */ 0x04B1, 0x04B1, 0x04B3, 0x04B3, 0x04B5, 0x04B5, 0x04B7, 0x04B7,
+            0x04B9, 0x04B9, 0x04BB, 0x04BB, 0x04BD, 0x04BD, 0x04BF, 0x04BF,
+    /* C */ 0x04C0, 0x04C1, 0x04C2, 0x04C4, 0x04C4, 0x04C5, 0x04C6, 0x04C8,
+            0x04C8, 0x04C9, 0x04CA, 0x04CC, 0x04CC, 0x04CD, 0x04CE, 0x04CF,
+    /* D */ 0x04D0, 0x04D1, 0x04D2, 0x04D3, 0x04D4, 0x04D5, 0x04D6, 0x04D7,
+            0x04D8, 0x04D9, 0x04DA, 0x04DB, 0x04DC, 0x04DD, 0x04DE, 0x04DF,
+    /* E */ 0x04E0, 0x04E1, 0x04E2, 0x04E3, 0x04E4, 0x04E5, 0x04E6, 0x04E7,
+            0x04E8, 0x04E9, 0x04EA, 0x04EB, 0x04EC, 0x04ED, 0x04EE, 0x04EF,
+    /* F */ 0x04F0, 0x04F1, 0x04F2, 0x04F3, 0x04F4, 0x04F5, 0x04F6, 0x04F7,
+            0x04F8, 0x04F9, 0x04FA, 0x04FB, 0x04FC, 0x04FD, 0x04FE, 0x04FF,
+
+    // Table 5 (for high byte 0x05)
+
+    /* 0 */ 0x0500, 0x0501, 0x0502, 0x0503, 0x0504, 0x0505, 0x0506, 0x0507,
+            0x0508, 0x0509, 0x050A, 0x050B, 0x050C, 0x050D, 0x050E, 0x050F,
+    /* 1 */ 0x0510, 0x0511, 0x0512, 0x0513, 0x0514, 0x0515, 0x0516, 0x0517,
+            0x0518, 0x0519, 0x051A, 0x051B, 0x051C, 0x051D, 0x051E, 0x051F,
+    /* 2 */ 0x0520, 0x0521, 0x0522, 0x0523, 0x0524, 0x0525, 0x0526, 0x0527,
+            0x0528, 0x0529, 0x052A, 0x052B, 0x052C, 0x052D, 0x052E, 0x052F,
+    /* 3 */ 0x0530, 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
+            0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F,
+    /* 4 */ 0x0570, 0x0571, 0x0572, 0x0573, 0x0574, 0x0575, 0x0576, 0x0577,
+            0x0578, 0x0579, 0x057A, 0x057B, 0x057C, 0x057D, 0x057E, 0x057F,
+    /* 5 */ 0x0580, 0x0581, 0x0582, 0x0583, 0x0584, 0x0585, 0x0586, 0x0557,
+            0x0558, 0x0559, 0x055A, 0x055B, 0x055C, 0x055D, 0x055E, 0x055F,
+    /* 6 */ 0x0560, 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
+            0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F,
+    /* 7 */ 0x0570, 0x0571, 0x0572, 0x0573, 0x0574, 0x0575, 0x0576, 0x0577,
+            0x0578, 0x0579, 0x057A, 0x057B, 0x057C, 0x057D, 0x057E, 0x057F,
+    /* 8 */ 0x0580, 0x0581, 0x0582, 0x0583, 0x0584, 0x0585, 0x0586, 0x0587,
+            0x0588, 0x0589, 0x058A, 0x058B, 0x058C, 0x058D, 0x058E, 0x058F,
+    /* 9 */ 0x0590, 0x0591, 0x0592, 0x0593, 0x0594, 0x0595, 0x0596, 0x0597,
+            0x0598, 0x0599, 0x059A, 0x059B, 0x059C, 0x059D, 0x059E, 0x059F,
+    /* A */ 0x05A0, 0x05A1, 0x05A2, 0x05A3, 0x05A4, 0x05A5, 0x05A6, 0x05A7,
+            0x05A8, 0x05A9, 0x05AA, 0x05AB, 0x05AC, 0x05AD, 0x05AE, 0x05AF,
+    /* B */ 0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7,
+            0x05B8, 0x05B9, 0x05BA, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF,
+    /* C */ 0x05C0, 0x05C1, 0x05C2, 0x05C3, 0x05C4, 0x05C5, 0x05C6, 0x05C7,
+            0x05C8, 0x05C9, 0x05CA, 0x05CB, 0x05CC, 0x05CD, 0x05CE, 0x05CF,
+    /* D */ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7,
+            0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
+    /* E */ 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
+            0x05E8, 0x05E9, 0x05EA, 0x05EB, 0x05EC, 0x05ED, 0x05EE, 0x05EF,
+    /* F */ 0x05F0, 0x05F1, 0x05F2, 0x05F3, 0x05F4, 0x05F5, 0x05F6, 0x05F7,
+            0x05F8, 0x05F9, 0x05FA, 0x05FB, 0x05FC, 0x05FD, 0x05FE, 0x05FF,
+
+    // Table 6 (for high byte 0x10)
+
+    /* 0 */ 0x1000, 0x1001, 0x1002, 0x1003, 0x1004, 0x1005, 0x1006, 0x1007,
+            0x1008, 0x1009, 0x100A, 0x100B, 0x100C, 0x100D, 0x100E, 0x100F,
+    /* 1 */ 0x1010, 0x1011, 0x1012, 0x1013, 0x1014, 0x1015, 0x1016, 0x1017,
+            0x1018, 0x1019, 0x101A, 0x101B, 0x101C, 0x101D, 0x101E, 0x101F,
+    /* 2 */ 0x1020, 0x1021, 0x1022, 0x1023, 0x1024, 0x1025, 0x1026, 0x1027,
+            0x1028, 0x1029, 0x102A, 0x102B, 0x102C, 0x102D, 0x102E, 0x102F,
+    /* 3 */ 0x1030, 0x1031, 0x1032, 0x1033, 0x1034, 0x1035, 0x1036, 0x1037,
+            0x1038, 0x1039, 0x103A, 0x103B, 0x103C, 0x103D, 0x103E, 0x103F,
+    /* 4 */ 0x1040, 0x1041, 0x1042, 0x1043, 0x1044, 0x1045, 0x1046, 0x1047,
+            0x1048, 0x1049, 0x104A, 0x104B, 0x104C, 0x104D, 0x104E, 0x104F,
+    /* 5 */ 0x1050, 0x1051, 0x1052, 0x1053, 0x1054, 0x1055, 0x1056, 0x1057,
+            0x1058, 0x1059, 0x105A, 0x105B, 0x105C, 0x105D, 0x105E, 0x105F,
+    /* 6 */ 0x1060, 0x1061, 0x1062, 0x1063, 0x1064, 0x1065, 0x1066, 0x1067,
+            0x1068, 0x1069, 0x106A, 0x106B, 0x106C, 0x106D, 0x106E, 0x106F,
+    /* 7 */ 0x1070, 0x1071, 0x1072, 0x1073, 0x1074, 0x1075, 0x1076, 0x1077,
+            0x1078, 0x1079, 0x107A, 0x107B, 0x107C, 0x107D, 0x107E, 0x107F,
+    /* 8 */ 0x1080, 0x1081, 0x1082, 0x1083, 0x1084, 0x1085, 0x1086, 0x1087,
+            0x1088, 0x1089, 0x108A, 0x108B, 0x108C, 0x108D, 0x108E, 0x108F,
+    /* 9 */ 0x1090, 0x1091, 0x1092, 0x1093, 0x1094, 0x1095, 0x1096, 0x1097,
+            0x1098, 0x1099, 0x109A, 0x109B, 0x109C, 0x109D, 0x109E, 0x109F,
+    /* A */ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10D7,
+            0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10DD, 0x10DE, 0x10DF,
+    /* B */ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7,
+            0x10E8, 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10EF,
+    /* C */ 0x10F0, 0x10F1, 0x10F2, 0x10F3, 0x10F4, 0x10F5, 0x10C6, 0x10C7,
+            0x10C8, 0x10C9, 0x10CA, 0x10CB, 0x10CC, 0x10CD, 0x10CE, 0x10CF,
+    /* D */ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10D7,
+            0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10DD, 0x10DE, 0x10DF,
+    /* E */ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7,
+            0x10E8, 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10EF,
+    /* F */ 0x10F0, 0x10F1, 0x10F2, 0x10F3, 0x10F4, 0x10F5, 0x10F6, 0x10F7,
+            0x10F8, 0x10F9, 0x10FA, 0x10FB, 0x10FC, 0x10FD, 0x10FE, 0x10FF,
+
+    // Table 7 (for high byte 0x20)
+
+    /* 0 */ 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007,
+            0x2008, 0x2009, 0x200A, 0x200B, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 1 */ 0x2010, 0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 0x2017,
+            0x2018, 0x2019, 0x201A, 0x201B, 0x201C, 0x201D, 0x201E, 0x201F,
+    /* 2 */ 0x2020, 0x2021, 0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027,
+            0x2028, 0x2029, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x202F,
+    /* 3 */ 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037,
+            0x2038, 0x2039, 0x203A, 0x203B, 0x203C, 0x203D, 0x203E, 0x203F,
+    /* 4 */ 0x2040, 0x2041, 0x2042, 0x2043, 0x2044, 0x2045, 0x2046, 0x2047,
+            0x2048, 0x2049, 0x204A, 0x204B, 0x204C, 0x204D, 0x204E, 0x204F,
+    /* 5 */ 0x2050, 0x2051, 0x2052, 0x2053, 0x2054, 0x2055, 0x2056, 0x2057,
+            0x2058, 0x2059, 0x205A, 0x205B, 0x205C, 0x205D, 0x205E, 0x205F,
+    /* 6 */ 0x2060, 0x2061, 0x2062, 0x2063, 0x2064, 0x2065, 0x2066, 0x2067,
+            0x2068, 0x2069, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    /* 7 */ 0x2070, 0x2071, 0x2072, 0x2073, 0x2074, 0x2075, 0x2076, 0x2077,
+            0x2078, 0x2079, 0x207A, 0x207B, 0x207C, 0x207D, 0x207E, 0x207F,
+    /* 8 */ 0x2080, 0x2081, 0x2082, 0x2083, 0x2084, 0x2085, 0x2086, 0x2087,
+            0x2088, 0x2089, 0x208A, 0x208B, 0x208C, 0x208D, 0x208E, 0x208F,
+    /* 9 */ 0x2090, 0x2091, 0x2092, 0x2093, 0x2094, 0x2095, 0x2096, 0x2097,
+            0x2098, 0x2099, 0x209A, 0x209B, 0x209C, 0x209D, 0x209E, 0x209F,
+    /* A */ 0x20A0, 0x20A1, 0x20A2, 0x20A3, 0x20A4, 0x20A5, 0x20A6, 0x20A7,
+            0x20A8, 0x20A9, 0x20AA, 0x20AB, 0x20AC, 0x20AD, 0x20AE, 0x20AF,
+    /* B */ 0x20B0, 0x20B1, 0x20B2, 0x20B3, 0x20B4, 0x20B5, 0x20B6, 0x20B7,
+            0x20B8, 0x20B9, 0x20BA, 0x20BB, 0x20BC, 0x20BD, 0x20BE, 0x20BF,
+    /* C */ 0x20C0, 0x20C1, 0x20C2, 0x20C3, 0x20C4, 0x20C5, 0x20C6, 0x20C7,
+            0x20C8, 0x20C9, 0x20CA, 0x20CB, 0x20CC, 0x20CD, 0x20CE, 0x20CF,
+    /* D */ 0x20D0, 0x20D1, 0x20D2, 0x20D3, 0x20D4, 0x20D5, 0x20D6, 0x20D7,
+            0x20D8, 0x20D9, 0x20DA, 0x20DB, 0x20DC, 0x20DD, 0x20DE, 0x20DF,
+    /* E */ 0x20E0, 0x20E1, 0x20E2, 0x20E3, 0x20E4, 0x20E5, 0x20E6, 0x20E7,
+            0x20E8, 0x20E9, 0x20EA, 0x20EB, 0x20EC, 0x20ED, 0x20EE, 0x20EF,
+    /* F */ 0x20F0, 0x20F1, 0x20F2, 0x20F3, 0x20F4, 0x20F5, 0x20F6, 0x20F7,
+            0x20F8, 0x20F9, 0x20FA, 0x20FB, 0x20FC, 0x20FD, 0x20FE, 0x20FF,
+
+    // Table 8 (for high byte 0x21)
+
+    /* 0 */ 0x2100, 0x2101, 0x2102, 0x2103, 0x2104, 0x2105, 0x2106, 0x2107,
+            0x2108, 0x2109, 0x210A, 0x210B, 0x210C, 0x210D, 0x210E, 0x210F,
+    /* 1 */ 0x2110, 0x2111, 0x2112, 0x2113, 0x2114, 0x2115, 0x2116, 0x2117,
+            0x2118, 0x2119, 0x211A, 0x211B, 0x211C, 0x211D, 0x211E, 0x211F,
+    /* 2 */ 0x2120, 0x2121, 0x2122, 0x2123, 0x2124, 0x2125, 0x2126, 0x2127,
+            0x2128, 0x2129, 0x212A, 0x212B, 0x212C, 0x212D, 0x212E, 0x212F,
+    /* 3 */ 0x2130, 0x2131, 0x2132, 0x2133, 0x2134, 0x2135, 0x2136, 0x2137,
+            0x2138, 0x2139, 0x213A, 0x213B, 0x213C, 0x213D, 0x213E, 0x213F,
+    /* 4 */ 0x2140, 0x2141, 0x2142, 0x2143, 0x2144, 0x2145, 0x2146, 0x2147,
+            0x2148, 0x2149, 0x214A, 0x214B, 0x214C, 0x214D, 0x214E, 0x214F,
+    /* 5 */ 0x2150, 0x2151, 0x2152, 0x2153, 0x2154, 0x2155, 0x2156, 0x2157,
+            0x2158, 0x2159, 0x215A, 0x215B, 0x215C, 0x215D, 0x215E, 0x215F,
+    /* 6 */ 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177,
+            0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F,
+    /* 7 */ 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177,
+            0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F,
+    /* 8 */ 0x2180, 0x2181, 0x2182, 0x2183, 0x2184, 0x2185, 0x2186, 0x2187,
+            0x2188, 0x2189, 0x218A, 0x218B, 0x218C, 0x218D, 0x218E, 0x218F,
+    /* 9 */ 0x2190, 0x2191, 0x2192, 0x2193, 0x2194, 0x2195, 0x2196, 0x2197,
+            0x2198, 0x2199, 0x219A, 0x219B, 0x219C, 0x219D, 0x219E, 0x219F,
+    /* A */ 0x21A0, 0x21A1, 0x21A2, 0x21A3, 0x21A4, 0x21A5, 0x21A6, 0x21A7,
+            0x21A8, 0x21A9, 0x21AA, 0x21AB, 0x21AC, 0x21AD, 0x21AE, 0x21AF,
+    /* B */ 0x21B0, 0x21B1, 0x21B2, 0x21B3, 0x21B4, 0x21B5, 0x21B6, 0x21B7,
+            0x21B8, 0x21B9, 0x21BA, 0x21BB, 0x21BC, 0x21BD, 0x21BE, 0x21BF,
+    /* C */ 0x21C0, 0x21C1, 0x21C2, 0x21C3, 0x21C4, 0x21C5, 0x21C6, 0x21C7,
+            0x21C8, 0x21C9, 0x21CA, 0x21CB, 0x21CC, 0x21CD, 0x21CE, 0x21CF,
+    /* D */ 0x21D0, 0x21D1, 0x21D2, 0x21D3, 0x21D4, 0x21D5, 0x21D6, 0x21D7,
+            0x21D8, 0x21D9, 0x21DA, 0x21DB, 0x21DC, 0x21DD, 0x21DE, 0x21DF,
+    /* E */ 0x21E0, 0x21E1, 0x21E2, 0x21E3, 0x21E4, 0x21E5, 0x21E6, 0x21E7,
+            0x21E8, 0x21E9, 0x21EA, 0x21EB, 0x21EC, 0x21ED, 0x21EE, 0x21EF,
+    /* F */ 0x21F0, 0x21F1, 0x21F2, 0x21F3, 0x21F4, 0x21F5, 0x21F6, 0x21F7,
+            0x21F8, 0x21F9, 0x21FA, 0x21FB, 0x21FC, 0x21FD, 0x21FE, 0x21FF,
+
+    // Table 9 (for high byte 0xFE)
+
+    /* 0 */ 0xFE00, 0xFE01, 0xFE02, 0xFE03, 0xFE04, 0xFE05, 0xFE06, 0xFE07,
+            0xFE08, 0xFE09, 0xFE0A, 0xFE0B, 0xFE0C, 0xFE0D, 0xFE0E, 0xFE0F,
+    /* 1 */ 0xFE10, 0xFE11, 0xFE12, 0xFE13, 0xFE14, 0xFE15, 0xFE16, 0xFE17,
+            0xFE18, 0xFE19, 0xFE1A, 0xFE1B, 0xFE1C, 0xFE1D, 0xFE1E, 0xFE1F,
+    /* 2 */ 0xFE20, 0xFE21, 0xFE22, 0xFE23, 0xFE24, 0xFE25, 0xFE26, 0xFE27,
+            0xFE28, 0xFE29, 0xFE2A, 0xFE2B, 0xFE2C, 0xFE2D, 0xFE2E, 0xFE2F,
+    /* 3 */ 0xFE30, 0xFE31, 0xFE32, 0xFE33, 0xFE34, 0xFE35, 0xFE36, 0xFE37,
+            0xFE38, 0xFE39, 0xFE3A, 0xFE3B, 0xFE3C, 0xFE3D, 0xFE3E, 0xFE3F,
+    /* 4 */ 0xFE40, 0xFE41, 0xFE42, 0xFE43, 0xFE44, 0xFE45, 0xFE46, 0xFE47,
+            0xFE48, 0xFE49, 0xFE4A, 0xFE4B, 0xFE4C, 0xFE4D, 0xFE4E, 0xFE4F,
+    /* 5 */ 0xFE50, 0xFE51, 0xFE52, 0xFE53, 0xFE54, 0xFE55, 0xFE56, 0xFE57,
+            0xFE58, 0xFE59, 0xFE5A, 0xFE5B, 0xFE5C, 0xFE5D, 0xFE5E, 0xFE5F,
+    /* 6 */ 0xFE60, 0xFE61, 0xFE62, 0xFE63, 0xFE64, 0xFE65, 0xFE66, 0xFE67,
+            0xFE68, 0xFE69, 0xFE6A, 0xFE6B, 0xFE6C, 0xFE6D, 0xFE6E, 0xFE6F,
+    /* 7 */ 0xFE70, 0xFE71, 0xFE72, 0xFE73, 0xFE74, 0xFE75, 0xFE76, 0xFE77,
+            0xFE78, 0xFE79, 0xFE7A, 0xFE7B, 0xFE7C, 0xFE7D, 0xFE7E, 0xFE7F,
+    /* 8 */ 0xFE80, 0xFE81, 0xFE82, 0xFE83, 0xFE84, 0xFE85, 0xFE86, 0xFE87,
+            0xFE88, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C, 0xFE8D, 0xFE8E, 0xFE8F,
+    /* 9 */ 0xFE90, 0xFE91, 0xFE92, 0xFE93, 0xFE94, 0xFE95, 0xFE96, 0xFE97,
+            0xFE98, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C, 0xFE9D, 0xFE9E, 0xFE9F,
+    /* A */ 0xFEA0, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4, 0xFEA5, 0xFEA6, 0xFEA7,
+            0xFEA8, 0xFEA9, 0xFEAA, 0xFEAB, 0xFEAC, 0xFEAD, 0xFEAE, 0xFEAF,
+    /* B */ 0xFEB0, 0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4, 0xFEB5, 0xFEB6, 0xFEB7,
+            0xFEB8, 0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC, 0xFEBD, 0xFEBE, 0xFEBF,
+    /* C */ 0xFEC0, 0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4, 0xFEC5, 0xFEC6, 0xFEC7,
+            0xFEC8, 0xFEC9, 0xFECA, 0xFECB, 0xFECC, 0xFECD, 0xFECE, 0xFECF,
+    /* D */ 0xFED0, 0xFED1, 0xFED2, 0xFED3, 0xFED4, 0xFED5, 0xFED6, 0xFED7,
+            0xFED8, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC, 0xFEDD, 0xFEDE, 0xFEDF,
+    /* E */ 0xFEE0, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4, 0xFEE5, 0xFEE6, 0xFEE7,
+            0xFEE8, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC, 0xFEED, 0xFEEE, 0xFEEF,
+    /* F */ 0xFEF0, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4, 0xFEF5, 0xFEF6, 0xFEF7,
+            0xFEF8, 0xFEF9, 0xFEFA, 0xFEFB, 0xFEFC, 0xFEFD, 0xFEFE, 0x0000,
+
+    // Table 10 (for high byte 0xFF)
+
+    /* 0 */ 0xFF00, 0xFF01, 0xFF02, 0xFF03, 0xFF04, 0xFF05, 0xFF06, 0xFF07,
+            0xFF08, 0xFF09, 0xFF0A, 0xFF0B, 0xFF0C, 0xFF0D, 0xFF0E, 0xFF0F,
+    /* 1 */ 0xFF10, 0xFF11, 0xFF12, 0xFF13, 0xFF14, 0xFF15, 0xFF16, 0xFF17,
+            0xFF18, 0xFF19, 0xFF1A, 0xFF1B, 0xFF1C, 0xFF1D, 0xFF1E, 0xFF1F,
+    /* 2 */ 0xFF20, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47,
+            0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F,
+    /* 3 */ 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57,
+            0xFF58, 0xFF59, 0xFF5A, 0xFF3B, 0xFF3C, 0xFF3D, 0xFF3E, 0xFF3F,
+    /* 4 */ 0xFF40, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47,
+            0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F,
+    /* 5 */ 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57,
+            0xFF58, 0xFF59, 0xFF5A, 0xFF5B, 0xFF5C, 0xFF5D, 0xFF5E, 0xFF5F,
+    /* 6 */ 0xFF60, 0xFF61, 0xFF62, 0xFF63, 0xFF64, 0xFF65, 0xFF66, 0xFF67,
+            0xFF68, 0xFF69, 0xFF6A, 0xFF6B, 0xFF6C, 0xFF6D, 0xFF6E, 0xFF6F,
+    /* 7 */ 0xFF70, 0xFF71, 0xFF72, 0xFF73, 0xFF74, 0xFF75, 0xFF76, 0xFF77,
+            0xFF78, 0xFF79, 0xFF7A, 0xFF7B, 0xFF7C, 0xFF7D, 0xFF7E, 0xFF7F,
+    /* 8 */ 0xFF80, 0xFF81, 0xFF82, 0xFF83, 0xFF84, 0xFF85, 0xFF86, 0xFF87,
+            0xFF88, 0xFF89, 0xFF8A, 0xFF8B, 0xFF8C, 0xFF8D, 0xFF8E, 0xFF8F,
+    /* 9 */ 0xFF90, 0xFF91, 0xFF92, 0xFF93, 0xFF94, 0xFF95, 0xFF96, 0xFF97,
+            0xFF98, 0xFF99, 0xFF9A, 0xFF9B, 0xFF9C, 0xFF9D, 0xFF9E, 0xFF9F,
+    /* A */ 0xFFA0, 0xFFA1, 0xFFA2, 0xFFA3, 0xFFA4, 0xFFA5, 0xFFA6, 0xFFA7,
+            0xFFA8, 0xFFA9, 0xFFAA, 0xFFAB, 0xFFAC, 0xFFAD, 0xFFAE, 0xFFAF,
+    /* B */ 0xFFB0, 0xFFB1, 0xFFB2, 0xFFB3, 0xFFB4, 0xFFB5, 0xFFB6, 0xFFB7,
+            0xFFB8, 0xFFB9, 0xFFBA, 0xFFBB, 0xFFBC, 0xFFBD, 0xFFBE, 0xFFBF,
+    /* C */ 0xFFC0, 0xFFC1, 0xFFC2, 0xFFC3, 0xFFC4, 0xFFC5, 0xFFC6, 0xFFC7,
+            0xFFC8, 0xFFC9, 0xFFCA, 0xFFCB, 0xFFCC, 0xFFCD, 0xFFCE, 0xFFCF,
+    /* D */ 0xFFD0, 0xFFD1, 0xFFD2, 0xFFD3, 0xFFD4, 0xFFD5, 0xFFD6, 0xFFD7,
+            0xFFD8, 0xFFD9, 0xFFDA, 0xFFDB, 0xFFDC, 0xFFDD, 0xFFDE, 0xFFDF,
+    /* E */ 0xFFE0, 0xFFE1, 0xFFE2, 0xFFE3, 0xFFE4, 0xFFE5, 0xFFE6, 0xFFE7,
+            0xFFE8, 0xFFE9, 0xFFEA, 0xFFEB, 0xFFEC, 0xFFED, 0xFFEE, 0xFFEF,
+    /* F */ 0xFFF0, 0xFFF1, 0xFFF2, 0xFFF3, 0xFFF4, 0xFFF5, 0xFFF6, 0xFFF7,
+            0xFFF8, 0xFFF9, 0xFFFA, 0xFFFB, 0xFFFC, 0xFFFD, 0xFFFE, 0xFFFF,
+};
diff -purN /dev/shm/linux-2.5/fs/hfsplus/unicode.c linuxppc-2.5-benh/fs/hfsplus/unicode.c
--- /dev/shm/linux-2.5/fs/hfsplus/unicode.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/unicode.c	2003-11-01 02:03:53.000000000 +0000
@@ -0,0 +1,140 @@
+/*
+ *  linux/fs/hfsplus/unicode.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handler routines for unicode strings
+ */
+
+#include <linux/types.h>
+#include <linux/nls.h>
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+/* Fold the case of a unicode char, given the 16 bit value */
+/* Returns folded char, or 0 if ignorable */
+static inline u16 case_fold(u16 c)
+{
+        u16 tmp;
+
+        tmp = case_fold_table[(c>>8)];
+        if (tmp)
+                tmp = case_fold_table[tmp + (c & 0xFF)];
+        else
+                tmp = c;
+        return tmp;
+}
+
+/* Compare unicode strings, return values like normal strcmp */
+int hfsplus_unistrcmp(const struct hfsplus_unistr *s1, const struct hfsplus_unistr *s2)
+{
+	u16 len1, len2, c1, c2;
+	const hfsplus_unichr *p1, *p2;
+
+	len1 = be16_to_cpu(s1->length);
+	len2 = be16_to_cpu(s2->length);
+	p1 = s1->unicode;
+	p2 = s2->unicode;
+
+	while (1) {
+		c1 = c2 = 0;
+
+		while (len1 && !c1) {
+			c1 = case_fold(be16_to_cpu(*p1));
+			p1++;
+			len1--;
+		}
+		while (len2 && !c2) {
+			c2 = case_fold(be16_to_cpu(*p2));
+			p2++;
+			len2--;
+		}
+
+		if (c1 != c2)
+			return (c1 < c2) ? -1 : 1;
+		if (!c1 && !c2)
+			return 0;
+	}
+}
+
+int hfsplus_uni2asc(const struct hfsplus_unistr *ustr, char *astr, int *len)
+{
+	const hfsplus_unichr *ip;
+	u8 *op;
+	u16 ustrlen, cc;
+	int size, tmp;
+
+	op = astr;
+	ip = ustr->unicode;
+	ustrlen = be16_to_cpu(ustr->length);
+	tmp = *len;
+	while (ustrlen > 0 && tmp > 0) {
+		cc = be16_to_cpu(*ip);
+		switch (cc) {
+		case 0:
+			cc = 0x2400;
+			break;
+		case '/':
+			cc = ':';
+			break;
+		}
+		if (cc > 0x7f) {
+			size = utf8_wctomb(op, cc, tmp);
+			if (size == -1) {
+				/* ignore */
+			} else {
+				op += size;
+				tmp -= size;
+			}
+		} else {
+			*op++ = (u8) cc;
+			tmp--;
+		}
+		ip++;
+		ustrlen--;
+	}
+	*len = (char *)op - astr;
+	if (ustrlen)
+		return -ENAMETOOLONG;
+	return 0;
+}
+
+int hfsplus_asc2uni(struct hfsplus_unistr *ustr, const char *astr, int len)
+{
+	int tmp;
+	wchar_t c;
+	u16 outlen = 0;
+
+	while (outlen <= HFSPLUS_MAX_STRLEN && len > 0) {
+		if (*astr & 0x80) {
+			tmp = utf8_mbtowc(&c, astr, len);
+			if (tmp < 0) {
+				astr++;
+				len--;
+				continue;
+			} else {
+				astr += tmp;
+				len -= tmp;
+			}
+		} else {
+			c = *astr++;
+			len--;
+		}
+		switch (c) {
+		case 0x2400:
+			c = 0;
+			break;
+		case ':':
+			c = '/';
+			break;
+		}
+		ustr->unicode[outlen] = cpu_to_be16(c);
+		outlen++;
+	}
+	ustr->length = cpu_to_be16(outlen);
+	if (len > 0)
+		return -ENAMETOOLONG;
+	return 0;
+}
diff -purN /dev/shm/linux-2.5/fs/hfsplus/wrapper.c linuxppc-2.5-benh/fs/hfsplus/wrapper.c
--- /dev/shm/linux-2.5/fs/hfsplus/wrapper.c	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/fs/hfsplus/wrapper.c	2003-11-01 02:03:55.000000000 +0000
@@ -0,0 +1,192 @@
+/*
+ *  linux/fs/hfsplus/wrapper.c
+ *
+ * Copyright (C) 2001
+ * Brad Boyer (flar@allandria.com)
+ * (C) 2003 Ardis Technologies <roman@ardistech.com>
+ *
+ * Handling of HFS wrappers around HFS+ volumes
+ */
+
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/cdrom.h>
+#include <linux/genhd.h>
+#include <linux/version.h>
+
+#include "hfsplus_fs.h"
+#include "hfsplus_raw.h"
+
+struct hfsplus_wd {
+	u32 ablk_size;
+	u16 ablk_start;
+	u16 embed_start;
+	u16 embed_count;
+};
+
+static int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)
+{
+	u32 extent;
+	u16 attrib;
+
+	if (be16_to_cpu(*(u16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG)) != HFSPLUS_VOLHEAD_SIG)
+		return 0;
+
+	attrib = be16_to_cpu(*(u16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));
+	if (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||
+	   !(attrib & HFSP_WRAP_ATTRIB_SPARED))
+		return 0;
+
+	wd->ablk_size = be32_to_cpu(*(u32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));
+	if (wd->ablk_size < HFSPLUS_SECTOR_SIZE)
+		return 0;
+	if (wd->ablk_size % HFSPLUS_SECTOR_SIZE)
+		return 0;
+	wd->ablk_start = be16_to_cpu(*(u16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));
+
+	extent = be32_to_cpu(*(u32 *)(bufptr + HFSP_WRAPOFF_EMBEDEXT));
+	wd->embed_start = (extent >> 16) & 0xFFFF;
+	wd->embed_count = extent & 0xFFFF;
+
+	return 1;
+}
+
+static int hfsplus_get_last_session(struct super_block *sb,
+				    sector_t *start, sector_t *size)
+{
+	struct cdrom_multisession ms_info;
+	struct cdrom_tocentry te;
+	int res;
+
+	/* default values */
+	*start = 0;
+	*size = sb->s_bdev->bd_inode->i_size >> 9;
+	{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev);
+		if (gd && gd->part) {
+			printk("size: %ld,%ld\n", *size,
+				gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects);
+			*size = gd->part[MINOR(sb->s_bdev->bd_inode->i_rdev)].nr_sects;
+		}
+#else
+		int part;
+		struct gendisk *gd = get_gendisk(sb->s_bdev->bd_inode->i_rdev, &part);
+		if (gd && part && gd->part) {
+			printk("size: %d,%ld,%ld\n", part, *size,
+				gd->part[part-1]->nr_sects);
+			//*size = gd->part[part-1]->nr_sects;
+		} else if (gd && !part) {
+			printk("size: %d,%ld,%ld\n", part, *size,
+				gd->capacity);
+		}
+		put_disk(gd);
+#endif
+	}
+
+	if (HFSPLUS_SB(sb).session >= 0) {
+		te.cdte_track = HFSPLUS_SB(sb).session;
+		te.cdte_format = CDROM_LBA;
+		res = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);
+		if (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {
+			*start = (sector_t)te.cdte_addr.lba << 2;
+			return 0;
+		}
+		printk(KERN_ERR "HFS: Invalid session number or type of track\n");
+		return -EINVAL;
+	}
+	ms_info.addr_format = CDROM_LBA;
+	res = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);
+	if (!res && ms_info.xa_flag)
+		*start = (sector_t)ms_info.addr.lba << 2;
+	return 0;
+}
+
+/* Find the volume header and fill in some minimum bits in superblock */
+/* Takes in super block, returns true if good data read */
+int hfsplus_read_wrapper(struct super_block *sb)
+{
+	struct buffer_head *bh;
+	struct hfsplus_vh *vhdr;
+	struct hfsplus_wd wd;
+	sector_t part_start, part_size;
+	u32 blocksize;
+
+	blocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);
+	if (!blocksize)
+		return -EINVAL;
+
+	if (hfsplus_get_last_session(sb, &part_start, &part_size))
+		return -EINVAL;
+	while (1) {
+		bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+		if (!bh)
+			return -EIO;
+
+		if (vhdr->signature == cpu_to_be16(HFSP_WRAP_MAGIC)) {
+			if (!hfsplus_read_mdb(vhdr, &wd))
+				goto error;
+			wd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;
+			part_start += wd.ablk_start + wd.embed_start * wd.ablk_size;
+			part_size = wd.embed_count * wd.ablk_size;
+			brelse(bh);
+			bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+			if (!bh)
+				return -EIO;
+		}
+		if (vhdr->signature == cpu_to_be16(HFSPLUS_VOLHEAD_SIG))
+			break;
+		brelse(bh);
+
+		/* check for a partition block
+		 * (should do this only for cdrom/loop though)
+		 */
+		if (hfs_part_find(sb, &part_start, &part_size))
+			return -EINVAL;
+	}
+
+	blocksize = be32_to_cpu(vhdr->blocksize);
+	brelse(bh);
+
+	/* block size must be at least as large as a sector
+	 * and a multiple of 2
+	 */
+	if (blocksize < HFSPLUS_SECTOR_SIZE ||
+	    ((blocksize - 1) & blocksize))
+		return -EINVAL;
+	HFSPLUS_SB(sb).alloc_blksz = blocksize;
+	HFSPLUS_SB(sb).alloc_blksz_shift = 0;
+	while (blocksize >>= 1)
+		HFSPLUS_SB(sb).alloc_blksz_shift++;
+	blocksize = min(HFSPLUS_SB(sb).alloc_blksz, (u32)PAGE_SIZE);
+
+	/* align block size to block offset */
+	while (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))
+		blocksize >>= 1;
+
+	if (sb_set_blocksize(sb, blocksize) != blocksize) {
+		printk("HFS+: unable to blocksize to %u!\n", blocksize);
+		return -EINVAL;
+	}
+
+	HFSPLUS_SB(sb).blockoffset = part_start >>
+			(sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);
+	HFSPLUS_SB(sb).sect_count = part_size;
+	HFSPLUS_SB(sb).fs_shift = HFSPLUS_SB(sb).alloc_blksz_shift -
+			sb->s_blocksize_bits;
+
+	bh = sb_bread512(sb, part_start + HFSPLUS_VOLHEAD_SECTOR, vhdr);
+	if (!bh)
+		return -EIO;
+
+	/* should still be the same... */
+	if (be16_to_cpu(vhdr->signature) != HFSPLUS_VOLHEAD_SIG)
+		goto error;
+	HFSPLUS_SB(sb).s_vhbh = bh;
+	HFSPLUS_SB(sb).s_vhdr = vhdr;
+
+	return 0;
+ error:
+	brelse(bh);
+	return -EINVAL;
+}
diff -purN /dev/shm/linux-2.5/include/asm-ppc/delay.h linuxppc-2.5-benh/include/asm-ppc/delay.h
--- /dev/shm/linux-2.5/include/asm-ppc/delay.h	2003-04-27 12:18:09.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/delay.h	2003-05-01 10:52:19.000000000 +0000
@@ -30,8 +30,8 @@ extern void __delay(unsigned int loops);
  * (which corresponds to ~3800 bogomips at HZ = 100).
  *  -- paulus
  */
-#define __MAX_UDELAY	(226050910/HZ)	/* maximum udelay argument */
-#define __MAX_NDELAY	(2147483647/HZ)	/* maximum ndelay argument */
+#define __MAX_UDELAY	(226050910UL/HZ)	/* maximum udelay argument */
+#define __MAX_NDELAY	(4294967295UL/HZ)	/* maximum ndelay argument */
 
 extern __inline__ void __udelay(unsigned int x)
 {
diff -purN /dev/shm/linux-2.5/include/asm-ppc/dma.h linuxppc-2.5-benh/include/asm-ppc/dma.h
--- /dev/shm/linux-2.5/include/asm-ppc/dma.h	2003-06-05 03:11:02.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/dma.h	2003-07-23 23:59:46.000000000 +0000
@@ -9,8 +9,10 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
-#include <asm/io.h>
 #include <linux/spinlock.h>
+#include <linux/sched.h>
+
+#include <asm/io.h>
 #include <asm/system.h>
 
 /*
@@ -25,14 +27,9 @@
  * with a grain of salt.
  */
 
-
 #ifndef _ASM_DMA_H
 #define _ASM_DMA_H
 
-#ifndef MAX_DMA_CHANNELS
-#define MAX_DMA_CHANNELS	8
-#endif
-
 /* The maximum address that we can perform a DMA transfer to on this platform */
 /* Doesn't really apply... */
 #define MAX_DMA_ADDRESS		0xFFFFFFFF
@@ -192,9 +189,9 @@ static __inline__ void release_dma_lock(
 /* enable/disable a specific DMA channel */
 static __inline__ void enable_dma(unsigned int dmanr)
 {
-	unsigned char ucDmaCmd=0x00;
+	unsigned char ucDmaCmd = 0x00;
 
-	if (dmanr != 4)	{
+	if (dmanr != 4) {
 		dma_outb(0, DMA2_MASK_REG);	/* This may not be enabled */
 		dma_outb(ucDmaCmd, DMA2_CMD_REG);	/* Enable group */
 	}
@@ -244,60 +241,58 @@ static __inline__ void set_dma_mode(unsi
  */
 static __inline__ void set_dma_page(unsigned int dmanr, int pagenr)
 {
-	switch(dmanr) {
-		case 0:
-			dma_outb(pagenr, DMA_LO_PAGE_0);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_0);
-			break;
-		case 1:
-			dma_outb(pagenr, DMA_LO_PAGE_1);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_1);
-			break;
-		case 2:
-			dma_outb(pagenr, DMA_LO_PAGE_2);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_2);
-			break;
-		case 3:
-			dma_outb(pagenr, DMA_LO_PAGE_3);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_3);
-			break;
-		case 5:
-			if (SND_DMA1 == 5 || SND_DMA2 == 5)
-				dma_outb(pagenr, DMA_LO_PAGE_5);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_5);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_5);
-			break;
-		case 6:
-			if (SND_DMA1 == 6 || SND_DMA2 == 6)
-				dma_outb(pagenr, DMA_LO_PAGE_6);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_6);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_6);
-			break;
-		case 7:
-			if (SND_DMA1 == 7 || SND_DMA2 == 7)
-				dma_outb(pagenr, DMA_LO_PAGE_7);
-			else
-				dma_outb(pagenr & 0xfe, DMA_LO_PAGE_7);
-			dma_outb(pagenr >> 8, DMA_HI_PAGE_7);
-			break;
+	switch (dmanr) {
+	case 0:
+		dma_outb(pagenr, DMA_LO_PAGE_0);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_0);
+		break;
+	case 1:
+		dma_outb(pagenr, DMA_LO_PAGE_1);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_1);
+		break;
+	case 2:
+		dma_outb(pagenr, DMA_LO_PAGE_2);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_2);
+		break;
+	case 3:
+		dma_outb(pagenr, DMA_LO_PAGE_3);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_3);
+		break;
+	case 5:
+		if (SND_DMA1 == 5 || SND_DMA2 == 5)
+			dma_outb(pagenr, DMA_LO_PAGE_5);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_5);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_5);
+		break;
+	case 6:
+		if (SND_DMA1 == 6 || SND_DMA2 == 6)
+			dma_outb(pagenr, DMA_LO_PAGE_6);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_6);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_6);
+		break;
+	case 7:
+		if (SND_DMA1 == 7 || SND_DMA2 == 7)
+			dma_outb(pagenr, DMA_LO_PAGE_7);
+		else
+			dma_outb(pagenr & 0xfe, DMA_LO_PAGE_7);
+		dma_outb(pagenr >> 8, DMA_HI_PAGE_7);
+		break;
 	}
 }
 
-
 /* Set transfer address & page bits for specific DMA channel.
  * Assumes dma flipflop is clear.
  */
 static __inline__ void set_dma_addr(unsigned int dmanr, unsigned int phys)
 {
 	if (dmanr <= 3) {
-		dma_outb(phys & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE );
+		dma_outb(phys & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);
 		dma_outb((phys >> 8) & 0xff, ((dmanr & 3) << 1) + IO_DMA1_BASE);
 	} else if (dmanr == SND_DMA1 || dmanr == SND_DMA2) {
-		dma_outb(phys  & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE );
-		dma_outb((phys >> 8)  & 0xff, ((dmanr & 3) << 2) +
-				IO_DMA2_BASE);
+		dma_outb(phys & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
+		dma_outb((phys >> 8) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
 		dma_outb((dmanr & 3), DMA2_EXT_REG);
 	} else {
 		dma_outb((phys >> 1) & 0xff, ((dmanr & 3) << 2) + IO_DMA2_BASE);
@@ -306,7 +301,6 @@ static __inline__ void set_dma_addr(unsi
 	set_dma_page(dmanr, phys >> 16);
 }
 
-
 /* Set transfer size (max 64k for DMA1..3, 128k for DMA5..7) for
  * a specific DMA channel.
  * You must ensure the parameters are valid.
@@ -321,16 +315,16 @@ static __inline__ void set_dma_count(uns
 	if (dmanr <= 3) {
 		dma_outb(count & 0xff, ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE);
 		dma_outb((count >> 8) & 0xff, ((dmanr & 3) << 1) + 1 +
-				IO_DMA1_BASE);
+			 IO_DMA1_BASE);
 	} else if (dmanr == SND_DMA1 || dmanr == SND_DMA2) {
-		dma_outb( count & 0xff, ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);
-		dma_outb( (count >> 8) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+		dma_outb(count & 0xff, ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE);
+		dma_outb((count >> 8) & 0xff, ((dmanr & 3) << 2) + 2 +
+			 IO_DMA2_BASE);
 	} else {
 		dma_outb((count >> 1) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+			 IO_DMA2_BASE);
 		dma_outb((count >> 9) & 0xff, ((dmanr & 3) << 2) + 2 +
-				IO_DMA2_BASE);
+			 IO_DMA2_BASE);
 	}
 }
 
@@ -345,8 +339,8 @@ static __inline__ void set_dma_count(uns
 static __inline__ int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port = (dmanr <= 3) ?
-		((dmanr & 3) << 1) + 1 + IO_DMA1_BASE
-		: ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE;
+	    ((dmanr & 3) << 1) + 1 + IO_DMA1_BASE
+	    : ((dmanr & 3) << 2) + 2 + IO_DMA2_BASE;
 
 	/* using short to get 16-bit wrap around */
 	unsigned short count;
@@ -355,21 +349,25 @@ static __inline__ int get_dma_residue(un
 	count += dma_inb(io_port) << 8;
 
 	return (dmanr <= 3 || dmanr == SND_DMA1 || dmanr == SND_DMA2)
-		? count : (count<<1);
+	    ? count : (count << 1);
 
 }
 
 /* These are in kernel/dma.c: */
 
 /* reserve a DMA channel */
-extern int request_dma(unsigned int dmanr, const char * device_id);
+extern int request_dma(unsigned int dmanr, const char *device_id);
 /* release it again */
 extern void free_dma(unsigned int dmanr);
 
+#ifndef MAX_DMA_CHANNELS
+#define MAX_DMA_CHANNELS	8
+#endif
 #ifdef CONFIG_PCI
 extern int isa_dma_bridge_buggy;
 #else
 #define isa_dma_bridge_buggy	(0)
 #endif
+
 #endif /* _ASM_DMA_H */
 #endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/ibm4xx.h linuxppc-2.5-benh/include/asm-ppc/ibm4xx.h
--- /dev/shm/linux-2.5/include/asm-ppc/ibm4xx.h	2004-01-19 06:28:33.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/ibm4xx.h	2004-01-21 00:29:29.000000000 +0000
@@ -38,6 +38,14 @@
 #include <platforms/4xx/oak.h>
 #endif
 
+#if defined(CONFIG_XILINX_ML300)
+#include <platforms/4xx/xilinx_ml300.h>
+#endif
+
+#if defined(CONFIG_RAINIER)
+#include <platforms/4xx/rainier.h>
+#endif
+
 #if defined(CONFIG_REDWOOD_4)
 #include <platforms/4xx/redwood.h>
 #endif
@@ -46,18 +54,27 @@
 #include <platforms/4xx/redwood5.h>
 #endif
 
+#if defined(CONFIG_REDWOOD_6)
+#include <platforms/4xx/redwood6.h>
+#endif
+
 #if defined(CONFIG_WALNUT)
 #include <platforms/4xx/walnut.h>
 #endif
 
-#ifndef __ASSEMBLY__
+#if defined(CONFIG_BEECH)
+#include <platforms/4xx/beech.h>
+#endif
 
-/*
- * The "residual" board information structure the boot loader passes
- * into the kernel.
- */
-extern bd_t __res;
+#if defined(CONFIG_ARCTIC2)
+#include <platforms/4xx/arctic2.h>
+#endif
+
+#if defined(CONFIG_SYCAMORE)
+#include <platforms/4xx/sycamore.h>
+#endif
 
+#ifndef __ASSEMBLY__
 void ppc4xx_setup_arch(void);
 void ppc4xx_map_io(void);
 void ppc4xx_init_IRQ(void);
diff -purN /dev/shm/linux-2.5/include/asm-ppc/ibm_ocp_gpio.h linuxppc-2.5-benh/include/asm-ppc/ibm_ocp_gpio.h
--- /dev/shm/linux-2.5/include/asm-ppc/ibm_ocp_gpio.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/ibm_ocp_gpio.h	2003-01-06 08:38:18.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ocp_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ocp_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ocp_gpio_ioctl_data)
+
+#endif
diff -purN /dev/shm/linux-2.5/include/asm-ppc/irq.h linuxppc-2.5-benh/include/asm-ppc/irq.h
--- /dev/shm/linux-2.5/include/asm-ppc/irq.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/irq.h	2003-09-12 17:39:40.000000000 +0000
@@ -3,6 +3,7 @@
 #define _ASM_IRQ_H
 
 #include <linux/config.h>
+#include <linux/sched.h>
 #include <asm/machdep.h>		/* ppc_md */
 #include <asm/atomic.h>
 
diff -purN /dev/shm/linux-2.5/include/asm-ppc/keylargo.h linuxppc-2.5-benh/include/asm-ppc/keylargo.h
--- /dev/shm/linux-2.5/include/asm-ppc/keylargo.h	2003-03-27 06:21:30.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/keylargo.h	2003-11-16 23:56:04.000000000 +0000
@@ -18,6 +18,13 @@
 #define KEYLARGO_FCR4		0x48
 #define KEYLARGO_FCR5		0x4c	/* Pangea only */
 
+/* K2 aditional FCRs */
+#define K2_FCR6			0x34
+#define K2_FCR7			0x30
+#define K2_FCR8			0x2c
+#define K2_FCR9			0x28
+#define K2_FCR10		0x24
+
 /* GPIO registers */
 #define KEYLARGO_GPIO_LEVELS0		0x50
 #define KEYLARGO_GPIO_LEVELS1		0x54
@@ -30,6 +37,10 @@
 #define KEYLARGO_GPIO_OUTOUT_DATA	0x01
 #define KEYLARGO_GPIO_INPUT_DATA	0x02
 
+/* K2 does only extint GPIOs and does 51 of them */
+#define K2_GPIO_EXTINT_0		0x58
+#define K2_GPIO_EXTINT_CNT		51
+
 /* Specific GPIO regs */
 
 #define KL_GPIO_MODEM_RESET		(KEYLARGO_GPIO_0+0x03)
@@ -67,7 +78,8 @@
 #define KL_GPIO_AIRPORT_4		(KEYLARGO_GPIO_0+0x0f)
 
 /*
- * Bits in feature control register
+ * Bits in feature control register. Those bits different for K2 are
+ * listed separately
  */
 #define KL_MBCR_MB0_PCI_ENABLE		0x00000800	/* exist ? */
 #define KL_MBCR_MB0_IDE_ENABLE		0x00001000
@@ -202,9 +214,30 @@
 #define KL4_PORT_DISCONNECT_STAT(p)	(0x00000010 << ((p)<<3))
 
 /* Pangea and Intrepid only */
-#define KL5_VIA_USE_CLK31		0x000000001	/* Pangea Only */
-#define KL5_SCC_USE_CLK31		0x000000002	/* Pangea Only */
-#define KL5_PWM_CLK32_EN		0x000000004
-#define KL5_CLK3_68_EN			0x000000010
-#define KL5_CLK32_EN			0x000000020
+#define KL5_VIA_USE_CLK31		0000000001	/* Pangea Only */
+#define KL5_SCC_USE_CLK31		0x00000002	/* Pangea Only */
+#define KL5_PWM_CLK32_EN		0x00000004
+#define KL5_CLK3_68_EN			0x00000010
+#define KL5_CLK32_EN			0x00000020
+
+
+/* K2 definitions */
+#define K2_FCR0_USB0_SWRESET		0x00200000
+#define K2_FCR0_USB1_SWRESET		0x02000000
+#define K2_FCR0_RING_PME_DISABLE	0x08000000
+
+#define K2_FCR1_PCI1_BUS_RESET_N	0x00000010
+#define K2_FCR1_PCI1_SLEEP_RESET_EN	0x00000020
+#define K2_FCR1_PCI1_CLK_ENABLE		0x00004000
+#define K2_FCR1_FW_CLK_ENABLE		0x00008000
+#define K2_FCR1_FW_RESET_N		0x00010000
+#define K2_FCR1_GMAC_CLK_ENABLE		0x00400000
+#define K2_FCR1_GMAC_POWER_DOWN		0x00800000
+#define K2_FCR1_GMAC_RESET_N		0x01000000
+#define K2_FCR1_SATA_CLK_ENABLE		0x02000000
+#define K2_FCR1_SATA_POWER_DOWN		0x04000000
+#define K2_FCR1_SATA_RESET_N		0x08000000
+#define K2_FCR1_UATA_CLK_ENABLE		0x10000000
+#define K2_FCR1_UATA_RESET_N		0x40000000
+#define K2_FCR1_UATA_CHOOSE_CLK66	0x80000000
 
diff -purN /dev/shm/linux-2.5/include/asm-ppc/kmap_types.h linuxppc-2.5-benh/include/asm-ppc/kmap_types.h
--- /dev/shm/linux-2.5/include/asm-ppc/kmap_types.h	2003-02-03 07:34:59.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/kmap_types.h	2003-11-17 17:12:45.000000000 +0000
@@ -16,6 +16,7 @@ enum km_type {
 	KM_IRQ1,
 	KM_SOFTIRQ0,
 	KM_SOFTIRQ1,
+	KM_PPC_SYNC_PAGE,
 	KM_TYPE_NR
 };
 
diff -purN /dev/shm/linux-2.5/include/asm-ppc/machdep.h linuxppc-2.5-benh/include/asm-ppc/machdep.h
--- /dev/shm/linux-2.5/include/asm-ppc/machdep.h	2004-02-04 05:28:09.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/machdep.h	2004-02-05 10:07:36.000000000 +0000
@@ -52,11 +52,13 @@ struct machdep_calls {
 	unsigned long	(*find_end_of_memory)(void);
 	void		(*setup_io_mappings)(void);
 
+	void		(*early_serial_map)(void);
   	void		(*progress)(char *, unsigned short);
 	void		(*kgdb_map_scc)(void);
 
 	unsigned char 	(*nvram_read_val)(int addr);
 	void		(*nvram_write_val)(int addr, unsigned char val);
+	void		(*nvram_sync)(void);
 
 	/*
 	 * optional PCI "hooks"
@@ -94,7 +96,7 @@ struct machdep_calls {
 	 * hook used to control some machine specific features (like reset
 	 * lines, chip power control, etc...).
 	 */
-	int (*feature_call)(unsigned int feature, ...);
+	long (*feature_call)(unsigned int feature, ...);
 
 #ifdef CONFIG_SMP
 	/* functions for dealing with other cpus */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/macio.h linuxppc-2.5-benh/include/asm-ppc/macio.h
--- /dev/shm/linux-2.5/include/asm-ppc/macio.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/macio.h	2003-10-03 09:56:18.000000000 +0000
@@ -9,7 +9,7 @@ extern struct bus_type macio_bus_type;
 struct macio_driver;
 struct macio_chip;
 
-#define MACIO_DEV_COUNT_RESOURCE	8
+#define MACIO_DEV_COUNT_RESOURCES	8
 #define MACIO_DEV_COUNT_IRQS		8
 
 /*
@@ -38,6 +38,10 @@ struct macio_dev
 	struct macio_bus	*bus;		/* macio bus this device is on */
 	struct macio_dev	*media_bay;	/* Device is part of a media bay */
 	struct of_device	ofdev;
+	int			n_resources;
+	struct resource		resource[MACIO_DEV_COUNT_RESOURCES];
+	int			n_interrupts;
+	struct resource		interrupt[MACIO_DEV_COUNT_IRQS];
 };
 #define	to_macio_device(d) container_of(d, struct macio_dev, ofdev.dev)
 #define	of_to_macio_device(d) container_of(d, struct macio_dev, ofdev)
@@ -46,6 +50,71 @@ extern struct macio_dev *macio_dev_get(s
 extern void macio_dev_put(struct macio_dev *dev);
 
 /*
+ * Accessors to resources & interrupts and other device
+ * fields
+ */
+
+static inline int macio_resource_count(struct macio_dev *dev)
+{
+	return dev->n_resources;
+}
+
+static inline unsigned long macio_resource_start(struct macio_dev *dev, int resource_no)
+{
+	return dev->resource[resource_no].start;
+}
+
+static inline unsigned long macio_resource_end(struct macio_dev *dev, int resource_no)
+{
+	return dev->resource[resource_no].end;
+}
+
+static inline unsigned long macio_resource_len(struct macio_dev *dev, int resource_no)
+{
+	struct resource *res = &dev->resource[resource_no];
+	if (res->start == 0 || res->end == 0 || res->end < res->start)
+		return 0;
+	return res->end - res->start + 1;
+}
+
+extern int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name);
+extern void macio_release_resource(struct macio_dev *dev, int resource_no);
+extern int macio_request_resources(struct macio_dev *dev, const char *name);
+extern void macio_release_resources(struct macio_dev *dev);
+
+static inline int macio_irq_count(struct macio_dev *dev)
+{
+	return dev->n_interrupts;
+}
+
+static inline int macio_irq(struct macio_dev *dev, int irq_no)
+{
+	return dev->interrupt[irq_no].start;
+}
+
+static inline void macio_set_drvdata(struct macio_dev *dev, void *data)
+{
+	dev_set_drvdata(&dev->ofdev.dev, data);
+}
+
+static inline void* macio_get_drvdata(struct macio_dev *dev)
+{
+	return dev_get_drvdata(&dev->ofdev.dev);
+}
+
+static inline struct device_node *macio_get_of_node(struct macio_dev *mdev)
+{
+	return mdev->ofdev.node;
+}
+
+#ifdef CONFIG_PCI
+static inline struct pci_dev *macio_get_pci_dev(struct macio_dev *mdev)
+{
+	return mdev->bus->pdev;
+}
+#endif
+
+/*
  * A driver for a mac-io chip based device
  */
 struct macio_driver
diff -purN /dev/shm/linux-2.5/include/asm-ppc/nvram.h linuxppc-2.5-benh/include/asm-ppc/nvram.h
--- /dev/shm/linux-2.5/include/asm-ppc/nvram.h	2003-01-07 19:45:19.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/nvram.h	2003-11-01 01:36:52.000000000 +0000
@@ -34,23 +34,40 @@ enum {
 /* Return partition offset in nvram */
 extern int	pmac_get_partition(int partition);
 
-/* Direct access to XPRAM */
+/* Direct access to XPRAM on PowerMacs */
 extern u8	pmac_xpram_read(int xpaddr);
 extern void	pmac_xpram_write(int xpaddr, u8 data);
 
+/* Synchronize NVRAM */
+extern void	nvram_sync(void);
+
+/* Normal access to NVRAM */
+extern unsigned char nvram_read_byte(int i);
+extern void nvram_write_byte(unsigned char c, int i);
+
 /* Some offsets in XPRAM */
 #define PMAC_XPRAM_MACHINE_LOC	0xe4
 #define PMAC_XPRAM_SOUND_VOLUME	0x08
 
-/* Machine location structure in XPRAM */
+/* Machine location structure in PowerMac XPRAM */
 struct pmac_machine_location {
 	unsigned int	latitude;	/* 2+30 bit Fractional number */
 	unsigned int	longitude;	/* 2+30 bit Fractional number */
 	unsigned int	delta;		/* mix of GMT delta and DLS */
 };
 
-/* /dev/nvram ioctls */
-#define PMAC_NVRAM_GET_OFFSET	_IOWR('p', 0x40, int) /* Get NVRAM partition offset */
+/*
+ * /dev/nvram ioctls
+ *
+ * Note that PMAC_NVRAM_GET_OFFSET is still supported, but is
+ * definitely obsolete. Do not use it if you can avoid it
+ */
+
+#define OBSOLETE_PMAC_NVRAM_GET_OFFSET \
+				_IOWR('p', 0x40, int)
+
+#define IOC_NVRAM_GET_OFFSET	_IOWR('p', 0x42, int)	/* Get NVRAM partition offset */
+#define IOC_NVRAM_SYNC		_IO('p', 0x43)		/* Sync NVRAM image */
 
 #endif
 #endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/open_pic.h linuxppc-2.5-benh/include/asm-ppc/open_pic.h
--- /dev/shm/linux-2.5/include/asm-ppc/open_pic.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/open_pic.h	2003-10-30 03:25:31.000000000 +0000
@@ -21,8 +21,12 @@
  *  Non-offset'ed vector numbers
  */
 
-#define OPENPIC_VEC_TIMER	64	/* and up */
-#define OPENPIC_VEC_IPI		72	/* and up */
+//#define OPENPIC_VEC_TIMER	64	/* and up */
+//#define OPENPIC_VEC_IPI      	72	/* and up */
+//#define OPENPIC_VEC_SPURIOUS	127
+
+#define OPENPIC_VEC_TIMER	110	/* and up */
+#define OPENPIC_VEC_IPI		118	/* and up */
 #define OPENPIC_VEC_SPURIOUS	127
 
 /* OpenPIC IRQ controller structure */
@@ -51,6 +55,7 @@ extern void openpic_setup_ISU(int isu_nu
 extern void openpic_cause_IPI(u_int ipi, u_int cpumask);
 extern void smp_openpic_message_pass(int target, int msg, unsigned long data,
 				     int wait);
+extern void openpic_set_k2_cascade(int irq);
 
 extern inline int openpic_to_irq(int irq)
 {
@@ -64,5 +69,25 @@ extern inline int openpic_to_irq(int irq
 		return 0;
 	}
 }
-/*extern int open_pic_irq_offset;*/
+/* Support for second openpic on G5 macs */
+
+// FIXME: To be replaced by sane cascaded controller management */
+
+#define PMAC_OPENPIC2_OFFSET	128
+
+#define OPENPIC2_VEC_TIMER	110	/* and up */
+#define OPENPIC2_VEC_IPI	118	/* and up */
+#define OPENPIC2_VEC_SPURIOUS	127
+
+
+extern void* OpenPIC2_Addr;
+
+/* Exported functions */
+extern void openpic2_set_sources(int first_irq, int num_irqs, void *isr);
+extern void openpic2_init(int linux_irq_offset);
+extern void openpic2_init_nmi_irq(u_int irq);
+extern u_int openpic2_irq(void);
+extern void openpic2_eoi(void);
+extern int openpic2_get_irq(struct pt_regs *regs);
+extern void openpic2_setup_ISU(int isu_num, unsigned long addr);
 #endif /* _PPC_KERNEL_OPEN_PIC_H */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/pccf_4xx.h linuxppc-2.5-benh/include/asm-ppc/pccf_4xx.h
--- /dev/shm/linux-2.5/include/asm-ppc/pccf_4xx.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/pccf_4xx.h	2003-06-12 22:25:47.000000000 +0000
@@ -0,0 +1,27 @@
+#ifndef __ASM_PCCF_4XX_H
+#define __ASM_PCCF_4XX_H
+
+/* Areas that we ioremap() are mapped only as large as necessary to get the job
+   done: Only a few locations of the macro space are used, and legacy IO space
+   is only 64 KB. There is 1 memory window, and 2 virtual IO windows. */
+
+#define PCCF_4XX_MACRO_OFFSET	0x00000000
+#define PCCF_4XX_MACRO_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_MACRO_OFFSET)
+#define PCCF_4XX_MACRO_WINSIZE	PAGE_SIZE
+
+#define PCCF_4XX_MEM_OFFSET	0x01000000
+#define PCCF_4XX_MEM_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_MEM_OFFSET)
+#define PCCF_4XX_MEM_WINSIZE	(8 * 1024 * 1024)
+
+#define PCCF_4XX_IO_OFFSET	0x01800000
+#define PCCF_4XX_IO_PADDR	(PCCF_4XX_PADDR + PCCF_4XX_IO_OFFSET)
+#define PCCF_4XX_IO_WINSIZE	0x00010000
+
+/* These are declared here, since the pccf_4xx driver needs them, but
+ * must be defined and initialized by the board setup code. */
+extern volatile u16 *pccf_4xx_macro_vaddr;
+extern unsigned long pccf_4xx_io_base;
+extern unsigned long pccf_4xx_mem_base;
+
+#endif /* __ASM_PCCF_4XX_H */
+
diff -purN /dev/shm/linux-2.5/include/asm-ppc/pgtable.h linuxppc-2.5-benh/include/asm-ppc/pgtable.h
--- /dev/shm/linux-2.5/include/asm-ppc/pgtable.h	2004-02-04 05:31:18.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/pgtable.h	2004-02-05 10:07:37.000000000 +0000
@@ -511,9 +511,21 @@ static inline void set_pte(pte_t *ptep, 
 #endif
 }
 
+extern void flush_hash_one_pte(pte_t *ptep);
+
+/*
+ * 2.6 calles this without flushing the TLB entry, this is wrong
+ * for our hash-based implementation, we fix that up here
+ */
 static inline int ptep_test_and_clear_young(pte_t *ptep)
 {
-	return (pte_update(ptep, _PAGE_ACCESSED, 0) & _PAGE_ACCESSED) != 0;
+	unsigned long old;
+	old = (pte_update(ptep, _PAGE_ACCESSED, 0) & _PAGE_ACCESSED);
+#if _PAGE_HASHPTE != 0
+	if (old & _PAGE_HASHPTE)
+		flush_hash_one_pte(ptep);
+#endif
+	return old != 0;
 }
 
 static inline int ptep_test_and_clear_dirty(pte_t *ptep)
diff -purN /dev/shm/linux-2.5/include/asm-ppc/pmac_feature.h linuxppc-2.5-benh/include/asm-ppc/pmac_feature.h
--- /dev/shm/linux-2.5/include/asm-ppc/pmac_feature.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/pmac_feature.h	2003-11-17 05:24:45.000000000 +0000
@@ -112,6 +112,10 @@
  */
 #define PMAC_TYPE_UNKNOWN_INTREPID	0x11f	/* Generic */
 
+/* MacRISC4 / G5 machines
+ */
+#define PMAC_TYPE_POWERMAC_G5		0x150	/* First tower */
+
 /*
  * Motherboard flags
  */
@@ -131,8 +135,8 @@
  */
 struct device_node;
 
-static inline int pmac_call_feature(int selector, struct device_node* node,
-					int param, int value)
+static inline long pmac_call_feature(int selector, struct device_node* node,
+					long param, long value)
 {
 	if (!ppc_md.feature_call)
 		return -ENODEV;
@@ -262,9 +266,15 @@ static inline int pmac_call_feature(int 
  */
 #define PMAC_FTR_WRITE_GPIO		PMAC_FTR_DEF(18)
 
+/* PMAC_FTR_ENABLE_MPIC
+ *
+ * Enable the MPIC cell
+ */
+#define PMAC_FTR_ENABLE_MPIC		PMAC_FTR_DEF(19)
+
 
 /* Don't use those directly, they are for the sake of pmac_setup.c */
-extern int pmac_do_feature_call(unsigned int selector, ...);
+extern long pmac_do_feature_call(unsigned int selector, ...);
 extern void pmac_feature_init(void);
 
 #define PMAC_FTR_DEF(x) ((_MACH_Pmac << 16) | (x))
@@ -289,6 +299,7 @@ enum {
 	macio_keylargo,
 	macio_pangea,
 	macio_intrepid,
+	macio_keylargo2,
 };
 
 struct macio_chip
diff -purN /dev/shm/linux-2.5/include/asm-ppc/pmac_low_i2c.h linuxppc-2.5-benh/include/asm-ppc/pmac_low_i2c.h
--- /dev/shm/linux-2.5/include/asm-ppc/pmac_low_i2c.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/pmac_low_i2c.h	2003-12-31 03:57:55.000000000 +0000
@@ -0,0 +1,43 @@
+/* 
+ *  include/asm-ppc/pmac_low_i2c.h
+ *
+ *  Copyright (C) 2003 Ben. Herrenschmidt (benh@kernel.crashing.org)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+#ifndef __PMAC_LOW_I2C_H__
+#define __PMAC_LOW_I2C_H__
+
+/* i2c mode (based on the platform functions format) */
+enum {
+	pmac_low_i2c_mode_dumb		= 1,
+	pmac_low_i2c_mode_std		= 2,
+	pmac_low_i2c_mode_stdsub	= 3,
+	pmac_low_i2c_mode_combined	= 4,
+};
+
+/* RW bit in address */
+enum {
+	pmac_low_i2c_read		= 0x01,
+	pmac_low_i2c_write		= 0x00
+};
+
+/* Init, called early during boot */
+extern void pmac_init_low_i2c(void);
+
+/* Locking functions exposed to i2c-keywest */
+int pmac_low_i2c_lock(struct device_node *np);
+int pmac_low_i2c_unlock(struct device_node *np);
+
+/* Access functions for platform code */
+int pmac_low_i2c_open(struct device_node *np, int channel);
+int pmac_low_i2c_close(struct device_node *np);
+int pmac_low_i2c_setmode(struct device_node *np, int mode);
+int pmac_low_i2c_xfer(struct device_node *np, u8 addrdir, u8 subaddr, u8 *data, int len);
+
+
+#endif /* __PMAC_LOW_I2C_H__ */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/ppc4xx_dma.h linuxppc-2.5-benh/include/asm-ppc/ppc4xx_dma.h
--- /dev/shm/linux-2.5/include/asm-ppc/ppc4xx_dma.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/ppc4xx_dma.h	2003-06-26 23:17:09.000000000 +0000
@@ -0,0 +1,593 @@
+/*
+ * include/asm-ppc/ppc4xx_dma.h
+ *
+ * IBM PPC4xx DMA engine library
+ *
+ * Copyright 2000-2003 MontaVista Software Inc.
+ *
+ * Cleaned by Matt Porter <mporter@mvista.com>
+ *
+ * Original code by Armin Kuster <akuster@mvista.com>
+ * and Pete Popov <ppopov@mvista.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASMPPC_PPC4xx_DMA_H
+#define __ASMPPC_PPC4xx_DMA_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <asm/mmu.h>
+#include <asm/ibm4xx.h>
+
+#undef DEBUG_4xxDMA
+
+#define MAX_PPC4xx_DMA_CHANNELS		4
+
+/* in arch/ppc/kernel/setup.c -- Cort */
+extern unsigned long DMA_MODE_WRITE, DMA_MODE_READ;
+
+/* 
+ * Function return status codes
+ * These values are used to indicate whether or not the function
+ * call was successful, or a bad/invalid parameter was passed.
+ */
+#define DMA_STATUS_GOOD			0
+#define DMA_STATUS_BAD_CHANNEL		1
+#define DMA_STATUS_BAD_HANDLE		2
+#define DMA_STATUS_BAD_MODE		3
+#define DMA_STATUS_NULL_POINTER		4
+#define DMA_STATUS_OUT_OF_MEMORY	5
+#define DMA_STATUS_SGL_LIST_EMPTY	6
+#define DMA_STATUS_GENERAL_ERROR	7
+#define DMA_STATUS_CHANNEL_NOTFREE	8
+
+#define DMA_CHANNEL_BUSY		0x80000000
+
+/*
+ * These indicate status as returned from the DMA Status Register.
+ */
+#define DMA_STATUS_NO_ERROR	0
+#define DMA_STATUS_CS		1	/* Count Status        */
+#define DMA_STATUS_TS		2	/* Transfer Status     */
+#define DMA_STATUS_DMA_ERROR	3	/* DMA Error Occurred  */
+#define DMA_STATUS_DMA_BUSY	4	/* The channel is busy */
+
+
+/*
+ * DMA Channel Control Registers
+ */
+
+#ifdef CONFIG_44x
+#define	PPC4xx_DMA_64BIT
+#define DMA_CR_OFFSET 1
+#else
+#define DMA_CR_OFFSET 0
+#endif
+
+#define DMA_CE_ENABLE        (1<<31)	/* DMA Channel Enable */
+#define SET_DMA_CE_ENABLE(x) (((x)&0x1)<<31)
+#define GET_DMA_CE_ENABLE(x) (((x)&DMA_CE_ENABLE)>>31)
+
+#define DMA_CIE_ENABLE        (1<<30)	/* DMA Channel Interrupt Enable */
+#define SET_DMA_CIE_ENABLE(x) (((x)&0x1)<<30)
+#define GET_DMA_CIE_ENABLE(x) (((x)&DMA_CIE_ENABLE)>>30)
+
+#define DMA_TD                (1<<29)
+#define SET_DMA_TD(x)         (((x)&0x1)<<29)
+#define GET_DMA_TD(x)         (((x)&DMA_TD)>>29)
+
+#define DMA_PL                (1<<28)	/* Peripheral Location */
+#define SET_DMA_PL(x)         (((x)&0x1)<<28)
+#define GET_DMA_PL(x)         (((x)&DMA_PL)>>28)
+
+#define EXTERNAL_PERIPHERAL    0
+#define INTERNAL_PERIPHERAL    1
+
+#define SET_DMA_PW(x)     (((x)&0x3)<<(26-DMA_CR_OFFSET))	/* Peripheral Width */
+#define DMA_PW_MASK       SET_DMA_PW(3)
+#define   PW_8                 0
+#define   PW_16                1
+#define   PW_32                2
+#define   PW_64                3
+/* FIXME: Add PW_128 support for 440GP DMA block */
+#define GET_DMA_PW(x)     (((x)&DMA_PW_MASK)>>(26-DMA_CR_OFFSET))
+
+#define DMA_DAI           (1<<(25-DMA_CR_OFFSET))	/* Destination Address Increment */
+#define SET_DMA_DAI(x)    (((x)&0x1)<<(25-DMA_CR_OFFSET))
+
+#define DMA_SAI           (1<<(24-DMA_CR_OFFSET))	/* Source Address Increment */
+#define SET_DMA_SAI(x)    (((x)&0x1)<<(24-DMA_CR_OFFSET))
+
+#define DMA_BEN           (1<<(23-DMA_CR_OFFSET))	/* Buffer Enable */
+#define SET_DMA_BEN(x)    (((x)&0x1)<<(23-DMA_CR_OFFSET))
+
+#define SET_DMA_TM(x)     (((x)&0x3)<<(21-DMA_CR_OFFSET))	/* Transfer Mode */
+#define DMA_TM_MASK       SET_DMA_TM(3)
+#define   TM_PERIPHERAL        0	/* Peripheral */
+#define   TM_RESERVED          1	/* Reserved */
+#define   TM_S_MM              2	/* Memory to Memory */
+#define   TM_D_MM              3	/* Device Paced Memory to Memory */
+#define GET_DMA_TM(x)     (((x)&DMA_TM_MASK)>>(21-DMA_CR_OFFSET))
+
+#define SET_DMA_PSC(x)    (((x)&0x3)<<(19-DMA_CR_OFFSET))	/* Peripheral Setup Cycles */
+#define DMA_PSC_MASK      SET_DMA_PSC(3)
+#define GET_DMA_PSC(x)    (((x)&DMA_PSC_MASK)>>(19-DMA_CR_OFFSET))
+
+#define SET_DMA_PWC(x)    (((x)&0x3F)<<(13-DMA_CR_OFFSET))	/* Peripheral Wait Cycles */
+#define DMA_PWC_MASK      SET_DMA_PWC(0x3F)
+#define GET_DMA_PWC(x)    (((x)&DMA_PWC_MASK)>>(13-DMA_CR_OFFSET))
+
+#define SET_DMA_PHC(x)    (((x)&0x7)<<(10-DMA_CR_OFFSET))	/* Peripheral Hold Cycles */
+#define DMA_PHC_MASK      SET_DMA_PHC(0x7)
+#define GET_DMA_PHC(x)    (((x)&DMA_PHC_MASK)>>(10-DMA_CR_OFFSET))
+
+#define DMA_ETD_OUTPUT     (1<<(9-DMA_CR_OFFSET))	/* EOT pin is a TC output */
+#define SET_DMA_ETD(x)     (((x)&0x1)<<(9-DMA_CR_OFFSET))
+
+#define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
+#define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
+
+#define DMA_DEC            (1<<(2)	/* Address Decrement */
+#define SET_DMA_DEC(x)     (((x)&0x1)<<2)
+#define GET_DMA_DEC(x)     (((x)&DMA_DEC)>>2)
+
+/*
+ * Transfer Modes
+ * These modes are defined in a way that makes it possible to
+ * simply "or" in the value in the control register.
+ */
+
+#define DMA_MODE_MM		(SET_DMA_TM(TM_S_MM))	/* memory to memory */
+
+				/* Device-paced memory to memory, */
+				/* device is at source address    */
+#define DMA_MODE_MM_DEVATSRC	(DMA_TD | SET_DMA_TM(TM_D_MM))
+
+				/* Device-paced memory to memory,      */
+				/* device is at destination address    */
+#define DMA_MODE_MM_DEVATDST	(SET_DMA_TM(TM_D_MM))
+
+/* 405gp/440gp */
+#define SET_DMA_PREFETCH(x)   (((x)&0x3)<<(4-DMA_CR_OFFSET))	/* Memory Read Prefetch */
+#define DMA_PREFETCH_MASK      SET_DMA_PREFETCH(3)
+#define   PREFETCH_1           0	/* Prefetch 1 Double Word */
+#define   PREFETCH_2           1
+#define   PREFETCH_4           2
+#define GET_DMA_PREFETCH(x) (((x)&DMA_PREFETCH_MASK)>>(4-DMA_CR_OFFSET))
+
+#define DMA_PCE            (1<<(3-DMA_CR_OFFSET))	/* Parity Check Enable */
+#define SET_DMA_PCE(x)     (((x)&0x1)<<(3-DMA_CR_OFFSET))
+#define GET_DMA_PCE(x)     (((x)&DMA_PCE)>>(3-DMA_CR_OFFSET))
+
+/* stb3x */
+
+#define DMA_ECE_ENABLE (1<<5)
+#define SET_DMA_ECE(x) (((x)&0x1)<<5)
+#define GET_DMA_ECE(x) (((x)&DMA_ECE_ENABLE)>>5)
+
+#define DMA_TCD_DISABLE	(1<<4)
+#define SET_DMA_TCD(x) (((x)&0x1)<<4)
+#define GET_DMA_TCD(x) (((x)&DMA_TCD_DISABLE)>>4)
+
+typedef uint32_t sgl_handle_t;
+
+#ifdef CONFIG_PPC4xx_EDMA
+
+#define SGL_LIST_SIZE 4096
+#define DMA_PPC4xx_SIZE SGL_LIST_SIZE
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x3)<<(6-DMA_CR_OFFSET))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK SET_DMA_PRIORITY(3)
+#define PRIORITY_LOW           0
+#define PRIORITY_MID_LOW       1
+#define PRIORITY_MID_HIGH      2
+#define PRIORITY_HIGH          3
+#define GET_DMA_PRIORITY(x) (((x)&DMA_PRIORITY_MASK)>>(6-DMA_CR_OFFSET))
+
+/* 
+ * DMA Polarity Configuration Register
+ */
+
+#define DMAReq0_ActiveLow (1<<31)
+#define DMAAck0_ActiveLow (1<<30)
+#define EOT0_ActiveLow    (1<<29)	/* End of Transfer      */
+
+#define DMAReq1_ActiveLow (1<<28)
+#define DMAAck1_ActiveLow (1<<27)
+#define EOT1_ActiveLow    (1<<26)
+
+#define DMAReq2_ActiveLow (1<<25)
+#define DMAAck2_ActiveLow (1<<24)
+#define EOT2_ActiveLow    (1<<23)
+
+#define DMAReq3_ActiveLow (1<<22)
+#define DMAAck3_ActiveLow (1<<21)
+#define EOT3_ActiveLow    (1<<20)
+
+/*
+ * DMA Sleep Mode Register
+ */
+#define SLEEP_MODE_ENABLE (1<<21)
+
+/*
+ * DMA Status Register
+ */
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_IN_DMA_REQ0   (1<<19)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<18)
+#define DMA_IN_DMA_REQ2   (1<<17)
+#define DMA_IN_DMA_REQ3   (1<<16)
+
+#define DMA_EXT_DMA_REQ0  (1<<15)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<14)
+#define DMA_EXT_DMA_REQ2  (1<<13)
+#define DMA_EXT_DMA_REQ3  (1<<12)
+
+#define DMA_CH0_BUSY      (1<<11)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<10)
+#define DMA_CH2_BUSY       (1<<9)
+#define DMA_CH3_BUSY       (1<<8)
+
+#define DMA_SG0            (1<<7)	/* DMA Channel 0 Scatter/Gather in progress */
+#define DMA_SG1            (1<<6)
+#define DMA_SG2            (1<<5)
+#define DMA_SG3            (1<<4)
+
+/*
+ * DMA SG Command Register
+ */
+#define SSG0_ENABLE        (1<<31)	/* Start Scatter Gather */
+#define SSG1_ENABLE        (1<<30)
+#define SSG2_ENABLE        (1<<29)
+#define SSG3_ENABLE        (1<<28)
+#define SSG0_MASK_ENABLE   (1<<15)	/* Enable writing to SSG0 bit */
+#define SSG1_MASK_ENABLE   (1<<14)
+#define SSG2_MASK_ENABLE   (1<<13)
+#define SSG3_MASK_ENABLE   (1<<12)
+
+/*
+ * DMA Scatter/Gather Descriptor Bit fields 
+ */
+#define SG_LINK            (1<<31)	/* Link */
+#define SG_TCI_ENABLE      (1<<29)	/* Enable Terminal Count Interrupt */
+#define SG_ETI_ENABLE      (1<<28)	/* Enable End of Transfer Interrupt */
+#define SG_ERI_ENABLE      (1<<27)	/* Enable Error Interrupt */
+#define SG_COUNT_MASK       0xFFFF	/* Count Field */
+
+#define SET_DMA_CONTROL \
+ 		(SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */ \
+ 		SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */\
+		SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */ \
+	       	SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */ \
+                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */ \
+                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */ \
+                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */ \
+                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */ \
+                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */)
+
+#define GET_DMA_POLARITY(chan) (DMAReq##chan##_ActiveLow | DMAAck##chan##_ActiveLow | EOT##chan##_ActiveLow)
+
+#elif defined(CONFIG_STBXXX_DMA)		/* stb03xxx */
+
+#define DMA_PPC4xx_SIZE	4096
+
+/*
+ * DMA Status Register
+ */
+
+#define SET_DMA_PRIORITY(x)   (((x)&0x00800001))	/* DMA Channel Priority */
+#define DMA_PRIORITY_MASK	0x00800001
+#define   PRIORITY_LOW         	0x00000000
+#define   PRIORITY_MID_LOW     	0x00000001
+#define   PRIORITY_MID_HIGH    	0x00800000
+#define   PRIORITY_HIGH        	0x00800001
+#define GET_DMA_PRIORITY(x) (((((x)&DMA_PRIORITY_MASK) &0x00800000) >> 22 ) | (((x)&DMA_PRIORITY_MASK) &0x00000001))
+
+#define DMA_CS0           (1<<31)	/* Terminal Count has been reached */
+#define DMA_CS1           (1<<30)
+#define DMA_CS2           (1<<29)
+#define DMA_CS3           (1<<28)
+
+#define DMA_TS0           (1<<27)	/* End of Transfer has been requested */
+#define DMA_TS1           (1<<26)
+#define DMA_TS2           (1<<25)
+#define DMA_TS3           (1<<24)
+
+#define DMA_CH0_ERR       (1<<23)	/* DMA Chanel 0 Error */
+#define DMA_CH1_ERR       (1<<22)
+#define DMA_CH2_ERR       (1<<21)
+#define DMA_CH3_ERR       (1<<20)
+
+#define DMA_CT0		  (1<<19)	/* Chained transfere */
+
+#define DMA_IN_DMA_REQ0   (1<<18)	/* Internal DMA Request is pending */
+#define DMA_IN_DMA_REQ1   (1<<17)
+#define DMA_IN_DMA_REQ2   (1<<16)
+#define DMA_IN_DMA_REQ3   (1<<15)
+
+#define DMA_EXT_DMA_REQ0  (1<<14)	/* External DMA Request is pending */
+#define DMA_EXT_DMA_REQ1  (1<<13)
+#define DMA_EXT_DMA_REQ2  (1<<12)
+#define DMA_EXT_DMA_REQ3  (1<<11)
+
+#define DMA_CH0_BUSY      (1<<10)	/* DMA Channel 0 Busy */
+#define DMA_CH1_BUSY      (1<<9)
+#define DMA_CH2_BUSY       (1<<8)
+#define DMA_CH3_BUSY       (1<<7)
+
+#define DMA_CT1            (1<<6)	/* Chained transfere */
+#define DMA_CT2            (1<<5)
+#define DMA_CT3            (1<<4)
+
+#define DMA_CH_ENABLE (1<<7)
+#define SET_DMA_CH(x) (((x)&0x1)<<7)
+#define GET_DMA_CH(x) (((x)&DMA_CH_ENABLE)>>7)
+
+/* STBx25xxx dma unique */
+/* enable device port on a dma channel 
+ * example ext 0 on dma 1
+ */
+
+#define	SSP0_RECV	15
+#define	SSP0_XMIT	14
+#define EXT_DMA_0	12
+#define	SC1_XMIT	11
+#define SC1_RECV	10
+#define EXT_DMA_2	9 
+#define	EXT_DMA_3	8 
+#define SERIAL2_XMIT	7
+#define SERIAL2_RECV	6
+#define SC0_XMIT 	5
+#define	SC0_RECV	4
+#define	SERIAL1_XMIT	3 
+#define SERIAL1_RECV	2
+#define	SERIAL0_XMIT	1
+#define SERIAL0_RECV	0
+
+#define DMA_CHAN_0	1
+#define DMA_CHAN_1	2
+#define DMA_CHAN_2	3
+#define DMA_CHAN_3	4
+
+/* end STBx25xx */
+
+/*
+ * Bit 30 must be one for Redwoods, otherwise transfers may receive errors.
+ */
+#define DMA_CR_MB0 0x2
+
+#define SET_DMA_CONTROL \
+       		(SET_DMA_CIE_ENABLE(p_init->int_enable) |  /* interrupt enable         */ \
+		SET_DMA_ETD(p_init->etd_output)        |  /* end of transfer pin      */ \
+		SET_DMA_TCE(p_init->tce_enable)        |  /* terminal count enable    */ \
+		SET_DMA_PL(p_init->pl)                 |  /* peripheral location      */ \
+		SET_DMA_DAI(p_init->dai)               |  /* dest addr increment      */ \
+		SET_DMA_SAI(p_init->sai)               |  /* src addr increment       */ \
+		SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */  \
+		SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
+		SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
+		SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
+		SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
+		SET_DMA_TCD(p_init->tcd_disable)	  |  /* TC chain mode disable   */ \
+		SET_DMA_ECE(p_init->ece_enable)	  |  /* ECE chanin mode enable  */ \
+		SET_DMA_CH(p_init->ch_enable)	|    /* Chain enable 	        */ \
+		DMA_CR_MB0				/* must be one */)
+
+#define GET_DMA_POLARITY(chan) chan
+
+#endif
+
+typedef struct {
+	unsigned short in_use;	/* set when channel is being used, clr when
+				 * available.
+				 */
+	/* 
+	 * Valid polarity settings:
+	 *   DMAReq0_ActiveLow
+	 *   DMAAck0_ActiveLow
+	 *   EOT0_ActiveLow
+	 *
+	 *   DMAReq1_ActiveLow
+	 *   DMAAck1_ActiveLow
+	 *   EOT1_ActiveLow
+	 * 
+	 *   DMAReq2_ActiveLow
+	 *   DMAAck2_ActiveLow
+	 *   EOT2_ActiveLow
+	 *
+	 *   DMAReq3_ActiveLow 
+	 *   DMAAck3_ActiveLow
+	 *   EOT3_ActiveLow
+	 */
+	unsigned int polarity;
+
+	char buffer_enable;	/* Boolean: buffer enable            */
+	char tce_enable;	/* Boolean: terminal count enable    */
+	char etd_output;	/* Boolean: eot pin is a tc output   */
+	char pce;		/* Boolean: parity check enable      */
+
+	/*
+	 * Peripheral location:
+	 * INTERNAL_PERIPHERAL (UART0 on the 405GP)
+	 * EXTERNAL_PERIPHERAL
+	 */
+	char pl;		/* internal/external peripheral      */
+
+	/*
+	 * Valid pwidth settings:
+	 *   PW_8
+	 *   PW_16
+	 *   PW_32
+	 *   PW_64
+	 */
+	unsigned int pwidth;
+
+	char dai;		/* Boolean: dst address increment   */
+	char sai;		/* Boolean: src address increment   */
+
+	/*
+	 * Valid psc settings: 0-3
+	 */
+	unsigned int psc;	/* Peripheral Setup Cycles         */
+
+	/*
+	 * Valid pwc settings:
+	 * 0-63
+	 */
+	unsigned int pwc;	/* Peripheral Wait Cycles          */
+
+	/*
+	 * Valid phc settings:
+	 * 0-7
+	 */
+	unsigned int phc;	/* Peripheral Hold Cycles          */
+
+	/*
+	 * Valid cp (channel priority) settings:
+	 *   PRIORITY_LOW
+	 *   PRIORITY_MID_LOW
+	 *   PRIORITY_MID_HIGH
+	 *   PRIORITY_HIGH
+	 */
+	unsigned int cp;	/* channel priority                */
+
+	/*
+	 * Valid pf (memory read prefetch) settings:
+	 *
+	 *   PREFETCH_1
+	 *   PREFETCH_2
+	 *   PREFETCH_4
+	 */
+	unsigned int pf;	/* memory read prefetch            */
+
+	/*
+	 * Boolean: channel interrupt enable
+	 * NOTE: for sgl transfers, only the last descriptor will be setup to
+	 * interrupt.
+	 */
+	char int_enable;
+
+	char shift;		/* easy access to byte_count shift, based on */
+	/* the width of the channel                  */
+
+	uint32_t control;	/* channel control word                      */
+
+	/* These variabled are used ONLY in single dma transfers              */
+	unsigned int mode;	/* transfer mode                     */
+	phys_addr_t addr;
+	char ce;		/* channel enable */
+#ifdef CONFIG_STB03xxx
+	char ch_enable;
+	char tcd_disable;
+	char ece_enable;
+	char td;		/* transfer direction */
+#endif
+
+} ppc_dma_ch_t;
+
+/*
+ * PPC44x DMA implementations have a slightly different
+ * descriptor layout.  Probably moved about due to the
+ * change to 64-bit addresses and link pointer. I don't
+ * know why they didn't just leave control_count after
+ * the dst_addr.
+ */
+#ifdef PPC4xx_DMA_64BIT
+typedef struct {
+	uint32_t control;
+	uint32_t control_count;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	phys_addr_t next;
+} ppc_sgl_t;
+#else
+typedef struct {
+	uint32_t control;
+	phys_addr_t src_addr;
+	phys_addr_t dst_addr;
+	uint32_t control_count;
+	uint32_t next;
+} ppc_sgl_t;
+#endif
+
+typedef struct {
+	unsigned int dmanr;
+	uint32_t control;	/* channel ctrl word; loaded from each descrptr */
+	uint32_t sgl_control;	/* LK, TCI, ETI, and ERI bits in sgl descriptor */
+	dma_addr_t dma_addr;	/* dma (physical) address of this list          */
+	ppc_sgl_t *phead;
+	ppc_sgl_t *ptail;
+	uint32_t pad32[2];
+
+} sgl_list_info_t;
+
+typedef struct {
+	phys_addr_t *src_addr;
+	phys_addr_t *dst_addr;
+	phys_addr_t dma_src_addr;
+	phys_addr_t dma_dst_addr;
+} pci_alloc_desc_t;
+
+extern ppc_dma_ch_t dma_channels[];
+
+/*
+ * The DMA API are in ppc4xx_dma.c and ppc4xx_sgdma.c
+ */
+extern int ppc4xx_init_dma_channel(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_get_channel_config(unsigned int, ppc_dma_ch_t *);
+extern int ppc4xx_set_channel_priority(unsigned int, unsigned int);
+extern unsigned int ppc4xx_get_peripheral_width(unsigned int);
+extern int ppc4xx_alloc_dma_handle(sgl_handle_t *, unsigned int, unsigned int);
+extern void ppc4xx_free_dma_handle(sgl_handle_t);
+extern int ppc4xx_get_dma_status(void);
+extern void ppc4xx_set_src_addr(int dmanr, phys_addr_t src_addr);
+extern void ppc4xx_set_dst_addr(int dmanr, phys_addr_t dst_addr);
+extern void ppc4xx_enable_dma(unsigned int dmanr);
+extern void ppc4xx_disable_dma(unsigned int dmanr);
+extern void ppc4xx_set_dma_count(unsigned int dmanr, unsigned int count);
+extern int ppc4xx_get_dma_residue(unsigned int dmanr);
+extern void ppc4xx_set_dma_addr2(unsigned int dmanr, phys_addr_t src_dma_addr,
+				 phys_addr_t dst_dma_addr);
+extern int ppc4xx_enable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_disable_dma_interrupt(unsigned int dmanr);
+extern int ppc4xx_clr_dma_status(unsigned int dmanr);
+extern int ppc4xx_map_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_disable_dma_port(unsigned int dmanr, unsigned int ocp_dma,short dma_chan);
+extern int ppc4xx_set_dma_mode(unsigned int dmanr, unsigned int mode);
+
+/* These are in kernel/dma.c: */
+
+/* reserve a DMA channel */
+extern int request_dma(unsigned int dmanr, const char *device_id);
+/* release it again */
+extern void free_dma(unsigned int dmanr);
+#endif
+#endif				/* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/reg.h linuxppc-2.5-benh/include/asm-ppc/reg.h
--- /dev/shm/linux-2.5/include/asm-ppc/reg.h	2003-10-11 14:12:15.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/reg.h	2003-11-17 01:29:58.000000000 +0000
@@ -86,11 +86,16 @@
 /* Special Purpose Registers (SPRNs)*/
 #define SPRN_CTR	0x009	/* Count Register */
 #define SPRN_DABR	0x3F5	/* Data Address Breakpoint Register */
+#if !defined(SPRN_DAC1) && !defined(SPRN_DAC2)
+#define SPRN_DAC1	0x3F6	/* Data Address Compare 1 */
+#define SPRN_DAC2	0x3F7	/* Data Address Compare 2 */
+#endif
 #define SPRN_DAR	0x013	/* Data Address Register */
 #define SPRN_TBRL	0x10C	/* Time Base Read Lower Register (user, R/O) */
 #define SPRN_TBRU	0x10D	/* Time Base Read Upper Register (user, R/O) */
 #define SPRN_TBWL	0x11C	/* Time Base Lower Register (super, R/W) */
 #define SPRN_TBWU	0x11D	/* Time Base Upper Register (super, R/W) */
+#define SPRN_HIOR	0x137	/* 970 Hypervisor interrupt offset */
 #define SPRN_DBAT0L	0x219	/* Data BAT 0 Lower Register */
 #define SPRN_DBAT0U	0x218	/* Data BAT 0 Upper Register */
 #define SPRN_DBAT1L	0x21B	/* Data BAT 1 Lower Register */
@@ -179,7 +184,10 @@
 #define HID1_PC3	(1<<13)		/* 7450 PLL_CFG[3] */
 #define HID1_SYNCBE	(1<<11)		/* 7450 ABE for sync, eieio */
 #define HID1_ABE	(1<<10)		/* 7450 Address Broadcast Enable */
+#define SPRN_HID2	0x3F8		/* Hardware Implementation Register 2 */
 #define SPRN_IABR	0x3F2	/* Instruction Address Breakpoint Register */
+#define SPRN_HID4	0x3F4		/* 970 HID4 */
+#define SPRN_HID5	0x3F6		/* 970 HID5 */
 #if !defined(SPRN_IAC1) && !defined(SPRN_IAC2)
 #define SPRN_IAC1	0x3F4		/* Instruction Address Compare 1 */
 #define SPRN_IAC2	0x3F5		/* Instruction Address Compare 2 */
@@ -290,6 +298,8 @@
 #define SPRN_SPRG7	0x117	/* Special Purpose Register General 7 */
 #define SPRN_SRR0	0x01A	/* Save/Restore Register 0 */
 #define SPRN_SRR1	0x01B	/* Save/Restore Register 1 */
+#define SPRN_SRR2	0x3DE	/* Save/Restore Register 2 */
+#define SPRN_SRR3	0x3DF	/* Save/Restore Register 3 */
 #define SPRN_THRM1	0x3FC		/* Thermal Management Register 1 */
 /* these bits were defined in inverted endian sense originally, ugh, confusing */
 #define THRM1_TIN	(1 << 31)
diff -purN /dev/shm/linux-2.5/include/asm-ppc/serial.h linuxppc-2.5-benh/include/asm-ppc/serial.h
--- /dev/shm/linux-2.5/include/asm-ppc/serial.h	2003-09-15 20:59:05.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/serial.h	2003-10-14 07:28:08.000000000 +0000
@@ -20,6 +20,8 @@
 #include <platforms/mcpn765_serial.h>
 #elif defined(CONFIG_MVME5100)
 #include <platforms/mvme5100_serial.h>
+#elif defined(CONFIG_PAL4)
+#include <platforms/pal4_serial.h>
 #elif defined(CONFIG_PRPMC750)
 #include <platforms/prpmc750_serial.h>
 #elif defined(CONFIG_PRPMC800)
diff -purN /dev/shm/linux-2.5/include/asm-ppc/termios.h linuxppc-2.5-benh/include/asm-ppc/termios.h
--- /dev/shm/linux-2.5/include/asm-ppc/termios.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/termios.h	2003-09-15 15:45:47.000000000 +0000
@@ -150,6 +150,8 @@ struct termio {
 #define _VSWTC	9
 
 #ifdef __KERNEL__
+#include <linux/module.h>
+
 /*                   ^C  ^\ del  ^U  ^D   1   0   0   0   0  ^W  ^R  ^Z  ^Q  ^S  ^V  ^U  */
 #define INIT_C_CC "\003\034\177\025\004\001\000\000\000\000\027\022\032\021\023\026\025"
 #endif	/* __KERNEL__ */
@@ -227,6 +229,8 @@ struct termio {
 #define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios))
 #define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios))
 
+#define MODULE_ALIAS_LDISC(ldisc) \
+	MODULE_ALIAS("tty-ldisc-" __stringify(ldisc))
 #endif	/* __KERNEL__ */
 
 #endif	/* _PPC_TERMIOS_H */
diff -purN /dev/shm/linux-2.5/include/asm-ppc/uninorth.h linuxppc-2.5-benh/include/asm-ppc/uninorth.h
--- /dev/shm/linux-2.5/include/asm-ppc/uninorth.h	2003-09-12 16:26:56.000000000 +0000
+++ linuxppc-2.5-benh/include/asm-ppc/uninorth.h	2003-12-24 05:33:05.000000000 +0000
@@ -1,6 +1,8 @@
 /*
  * uninorth.h: definitions for using the "UniNorth" host bridge chip
  *             from Apple. This chip is used on "Core99" machines
+ *	       This also includes U2 used on more recent MacRISC2/3
+ *             machines and U3 (G5) 
  *
  */
 #ifdef __KERNEL__
@@ -8,23 +10,26 @@
 #define __ASM_UNINORTH_H__
 
 /*
- * Uni-N config space reg. definitions
+ * Uni-N and U3 config space reg. definitions
  *
  * (Little endian)
  */
 
 /* Address ranges selection. This one should work with Bandit too */
+/* Not U3 */
 #define UNI_N_ADDR_SELECT		0x48
 #define UNI_N_ADDR_COARSE_MASK		0xffff0000	/* 256Mb regions at *0000000 */
 #define UNI_N_ADDR_FINE_MASK		0x0000ffff	/*  16Mb regions at f*000000 */
 
 /* AGP registers */
+/* Not U3 */
 #define UNI_N_CFG_GART_BASE		0x8c
 #define UNI_N_CFG_AGP_BASE		0x90
 #define UNI_N_CFG_GART_CTRL		0x94
 #define UNI_N_CFG_INTERNAL_STATUS	0x98
 
 /* UNI_N_CFG_GART_CTRL bits definitions */
+/* Not U3 */
 #define UNI_N_CFG_GART_INVAL		0x00000001
 #define UNI_N_CFG_GART_ENABLE		0x00000100
 #define UNI_N_CFG_GART_2xRESET		0x00010000
@@ -90,6 +95,14 @@
 /* Version of the UniNorth chip */
 #define UNI_N_VERSION			0x0000		/* Known versions: 3,7 and 8 */
 
+#define UNI_N_VERSION_107		0x0003		/* 1.0.7 */
+#define UNI_N_VERSION_10A		0x0007		/* 1.0.10 */
+#define UNI_N_VERSION_150		0x0011		/* 1.5 */
+#define UNI_N_VERSION_200		0x0024		/* 2.0 */
+#define UNI_N_VERSION_PANGEA		0x00C0		/* Integrated U1 + K */
+#define UNI_N_VERSION_INTREPID		0x00D2		/* Integrated U2 + K */
+#define UNI_N_VERSION_300		0x0030		/* 3.0 (U3 on G5) */
+
 /* This register is used to enable/disable various clocks */
 #define UNI_N_CLOCK_CNTL		0x0020
 #define UNI_N_CLOCK_CNTL_PCI		0x00000001	/* PCI2 clock control */
@@ -131,5 +144,26 @@
 
 /* Uninorth 1.5 rev. has additional perf. monitor registers at 0xf00-0xf50 */
 
+
+/*
+ * U3 specific registers
+ */
+
+
+/* U3 Toggle */
+#define U3_TOGGLE_REG			0x00e0
+#define U3_PMC_START_STOP		0x0001
+#define U3_MPIC_RESET			0x0002
+#define U3_MPIC_OUTPUT_ENABLE		0x0004
+
+/* U3 API PHY Config 1 */
+#define U3_API_PHY_CONFIG_1		0x23030
+
+/* U3 HyperTransport registers */
+#define U3_HT_CONFIG_BASE      		0x70000
+#define U3_HT_LINK_COMMAND		0x100
+#define U3_HT_LINK_CONFIG		0x110
+#define U3_HT_LINK_FREQ			0x120
+
 #endif /* __ASM_UNINORTH_H__ */
 #endif /* __KERNEL__ */
diff -purN /dev/shm/linux-2.5/include/linux/fb.h linuxppc-2.5-benh/include/linux/fb.h
--- /dev/shm/linux-2.5/include/linux/fb.h	2003-04-24 10:30:41.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/fb.h	2003-12-24 10:31:18.000000000 +0000
@@ -150,6 +150,7 @@ struct fb_bitfield {
 #define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
 #define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
 #define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_FIND	3	/* don't set, find an approaching mode */
 #define FB_ACTIVATE_MASK       15
 					/* values			*/
 #define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
@@ -352,6 +353,44 @@ struct fb_pixmap {
 struct fb_info;
 struct vm_area_struct;
 struct file;
+struct fb_client;
+
+	/*
+	 * Framebuffer clients. Currently, this is only used
+	 * by fbcon to get notified of events on the framebuffer,
+	 * though that should be extended to the userland interface
+	 * some way.
+	 * 
+	 * We should also add more callbacks to better deal with
+	 * hotplug displays (add/removal notification). This is
+	 * not to replaced by a device class, though it could be
+	 * wrapped in a device interface according to the driver
+	 * model, I have to think more about it.
+	 * 
+	 * Locking rules: The callback should not take the console
+	 * semaphore explicitely (call acquire_console_sem()) as it
+	 * will typically already be owned.
+	 * 
+	 */ 
+struct fb_client_ops {	
+	struct module *owner;
+
+	/* Userland initiated mode change */
+	void	(*mode_changed)(void *data, struct fb_info *info);
+	/* The device is beeing suspended, do not access from
+	 * that point
+	 */
+	void	(*suspended)(void *data, struct fb_info *info);
+	/* The device is back to life, refresh screen
+	 */
+	void	(*resumed)(void *data, struct fb_info *info);
+};
+
+struct fb_client {
+	struct list_head	link;
+	struct fb_client_ops	*ops;
+	void			*data;
+};
 
     /*
      *  Frame buffer operations
@@ -399,6 +438,7 @@ struct fb_info {
    int node;
    int flags;
    int open;                            /* Has this been open already ? */
+   int suspended;			/* Is this currently suspended ? */
 #define FBINFO_FLAG_MODULE	1	/* Low-level driver is a module */
    struct fb_var_screeninfo var;        /* Current var */
    struct fb_fix_screeninfo fix;        /* Current fix */
@@ -475,6 +516,10 @@ extern int soft_cursor(struct fb_info *i
 extern void cfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect); 
 extern void cfb_copyarea(struct fb_info *info, const struct fb_copyarea *area); 
 extern void cfb_imageblit(struct fb_info *info, const struct fb_image *image);
+extern int fb_dummy_cursor(struct fb_info *info, struct fb_cursor *cursor);
+extern void fb_dummy_fillrect(struct fb_info *info, const struct fb_fillrect *rect); 
+extern void fb_dummy_copyarea(struct fb_info *info, const struct fb_copyarea *area); 
+extern void fb_dummy_imageblit(struct fb_info *info, const struct fb_image *image);
 
 /* drivers/video/fbmem.c */
 extern int register_framebuffer(struct fb_info *fb_info);
@@ -502,7 +547,7 @@ extern int fbmon_valid_timings(u_int pix
 extern int fbmon_dpms(const struct fb_info *fb_info);
 extern int fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,
 		       struct fb_info *info);
-extern int fb_validate_mode(struct fb_var_screeninfo *var,
+extern int fb_validate_mode(const struct fb_var_screeninfo *var,
 			    struct fb_info *info);
 extern int parse_edid(unsigned char *edid, struct fb_var_screeninfo *var);
 extern int fb_get_monitor_limits(unsigned char *edid, struct fb_monspecs *specs);
@@ -575,6 +620,22 @@ extern int __init fb_find_mode(struct fb
 			       unsigned int default_bpp);
 #endif
 
+/* Power Management: called by low driver to notify other layers,
+ * driver should have acquired the console semaphore prior to
+ * calling this
+ */
+extern int fb_set_suspend(struct fb_info *info, int suspended);
+
+/*
+ * fb_client operations
+ */
+
+extern int register_fb_client(struct fb_client_ops *ops, void *data);
+extern int unregister_fb_client(struct fb_client_ops *ops);
+extern int fb_clients_call_mode_changed(struct fb_info *info);
+extern int fb_clients_call_suspended(struct fb_info *info);
+extern int fb_clients_call_resumed(struct fb_info *info);
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_FB_H */
diff -purN /dev/shm/linux-2.5/include/linux/hfs_fs.h linuxppc-2.5-benh/include/linux/hfs_fs.h
--- /dev/shm/linux-2.5/include/linux/hfs_fs.h	2003-09-29 01:12:49.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/hfs_fs.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,348 +0,0 @@
-/* 
- * linux/include/linux/hfs_fs.h
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * The source code distribution of the Columbia AppleTalk Package for
- * UNIX, version 6.0, (CAP) was used as a specification of the
- * location and format of files used by CAP's Aufs.  No code from CAP
- * appears in hfs_fs.  hfs_fs is not a work ``derived'' from CAP in
- * the sense of intellectual property law.
- *
- * The source code distributions of Netatalk, versions 1.3.3b2 and
- * 1.4b2, were used as a specification of the location and format of
- * files used by Netatalk's afpd.  No code from Netatalk appears in
- * hfs_fs.  hfs_fs is not a work ``derived'' from Netatalk in the
- * sense of intellectual property law.
- */
-
-#ifndef _LINUX_HFS_FS_H
-#define _LINUX_HFS_FS_H
-
-#include <linux/hfs_sysdep.h>
-
-/* magic numbers for Apple Double header files */
-#define HFS_DBL_MAGIC		0x00051607
-#define HFS_SNGL_MAGIC		0x00051600
-#define HFS_HDR_VERSION_1	0x00010000
-#define HFS_HDR_VERSION_2	0x00020000
-
-/* magic numbers for various internal structures */
-#define HFS_INO_MAGIC		0x4821
-#define HFS_SB_MAGIC		0x4822
-
-/* The space used for the AppleDouble or AppleSingle headers */
-#define HFS_DBL_HDR_LEN		1024
-
-/* The space used for the Netatalk header */
-#define HFS_NAT_HDR_LEN		1024  /* 589 for an exact match */
-
-/* Macros to extract CNID and file "type" from the Linux inode number */
-#define HFS_CNID(X)	((X) & 0x3FFFFFFF)
-#define HFS_ITYPE(X)	((X) & 0xC0000000)
-
-/* Macros to enumerate types */
-#define HFS_ITYPE_TO_INT(X)	((X) >> 30)
-#define HFS_INT_TO_ITYPE(X)	((X) << 30)
-
-/* generic ITYPEs */
-#define HFS_ITYPE_0	0x00000000
-#define HFS_ITYPE_1	0x40000000
-#define HFS_ITYPE_2	0x80000000
-#define HFS_ITYPE_3	0xC0000000
-#define HFS_ITYPE_NORM	HFS_ITYPE_0	/* "normal" directory or file */
-
-/* ITYPEs for CAP */
-#define HFS_CAP_NORM	HFS_ITYPE_0	/* data fork or normal directory */
-#define HFS_CAP_DATA	HFS_ITYPE_0	/* data fork of file */
-#define HFS_CAP_NDIR	HFS_ITYPE_0	/* normal directory */
-#define HFS_CAP_FNDR	HFS_ITYPE_1	/* finder info for file or dir */
-#define HFS_CAP_RSRC	HFS_ITYPE_2	/* resource fork of file */
-#define HFS_CAP_RDIR	HFS_ITYPE_2	/* .resource directory */
-#define HFS_CAP_FDIR	HFS_ITYPE_3	/* .finderinfo directory */
-
-/* ITYPEs for Apple Double */
-#define HFS_DBL_NORM	HFS_ITYPE_0	/* data fork or directory */
-#define HFS_DBL_DATA	HFS_ITYPE_0	/* data fork of file */
-#define HFS_DBL_DIR	HFS_ITYPE_0	/* directory */
-#define HFS_DBL_HDR	HFS_ITYPE_1	/* AD header of file or dir */
-
-/* ITYPEs for netatalk */
-#define HFS_NAT_NORM	HFS_ITYPE_0	/* data fork or directory */
-#define HFS_NAT_DATA	HFS_ITYPE_0	/* data fork of file */
-#define HFS_NAT_NDIR	HFS_ITYPE_0	/* normal directory */
-#define HFS_NAT_HDR	HFS_ITYPE_1	/* AD header of file or dir */
-#define HFS_NAT_HDIR	HFS_ITYPE_2	/* directory holding AD headers */
-
-/* ITYPEs for Apple Single */
-#define HFS_SGL_NORM	HFS_ITYPE_0	/* AppleSingle file or directory */
-#define HFS_SGL_SNGL	HFS_ITYPE_0	/* AppleSingle file */
-#define HFS_SGL_DIR	HFS_ITYPE_0	/* directory */
-#define HFS_SGL_DINF	HFS_ITYPE_1	/* %DirInfo for directory */
-
-/* IDs for elements of an AppleDouble or AppleSingle header */
-#define HFS_HDR_DATA	1   /* data fork */
-#define HFS_HDR_RSRC	2   /* resource fork */
-#define HFS_HDR_FNAME	3   /* full (31-character) name */
-#define HFS_HDR_COMNT	4   /* comment */
-#define HFS_HDR_BWICN	5   /* b/w icon */
-#define HFS_HDR_CICON	6   /* color icon info */
-#define HFS_HDR_OLDI	7   /* old file info */
-#define HFS_HDR_DATES	8   /* file dates info */
-#define HFS_HDR_FINFO	9   /* Finder info */
-#define HFS_HDR_MACI	10  /* Macintosh info */
-#define HFS_HDR_PRODOSI 11  /* ProDOS info */
-#define HFS_HDR_MSDOSI  12  /* MSDOS info */
-#define HFS_HDR_SNAME   13  /* short name */
-#define HFS_HDR_AFPI    14  /* AFP file info */
-#define HFS_HDR_DID     15  /* directory id */
-#define HFS_HDR_MAX	16
-
-/*
- * There are three time systems.  All three are based on seconds since
- * a particular time/date.
- *	Unix:	unsigned lil-endian since 00:00 GMT, Jan. 1, 1970
- *	mac:	unsigned big-endian since 00:00 GMT, Jan. 1, 1904
- *	header:	  SIGNED big-endian since 00:00 GMT, Jan. 1, 2000
- *
- */
-#define hfs_h_to_mtime(ARG)	htonl((hfs_s32)ntohl(ARG)+3029529600U)
-#define hfs_m_to_htime(ARG)	((hfs_s32)htonl(ntohl(ARG)-3029529600U))
-#define hfs_h_to_utime(ARG)	((hfs_s32)hfs_to_utc(ntohl(ARG)+946684800U))
-#define hfs_u_to_htime(ARG)	((hfs_s32)htonl(hfs_from_utc(ARG)-946684800U))
-#define hfs_u_to_mtime(ARG)	htonl(hfs_from_utc(ARG)+2082844800U)
-#define hfs_m_to_utime(ARG)	(hfs_to_utc(ntohl(ARG)-2082844800U))
-
-/*======== Data structures kept in memory ========*/
-
-/*
- * A descriptor for a single entry within the header of an
- * AppleDouble or AppleSingle header file.
- * An array of these make up a table of contents for the file.
- */
-struct hfs_hdr_descr {
-	hfs_u32	id;	/* The Apple assigned ID for the entry type */
-	hfs_u32	offset;	/* The offset to reach the entry */
-	hfs_u32	length;	/* The length of the entry */
-};
-
-/*
- * The info needed to reconstruct a given header layout
- */
-struct hfs_hdr_layout {
-	hfs_u32		magic;			/* AppleSingle or AppleDouble */
-	hfs_u32		version;		/* 0x00010000 or 0x00020000 */
-	hfs_u16		entries;		/* How many entries used */
-	struct hfs_hdr_descr	
-			descr[HFS_HDR_MAX];	/* Descriptors */
-	struct hfs_hdr_descr	
-			*order[HFS_HDR_MAX];	/* 'descr' ordered by offset */
-};
-
-/* header layout for netatalk's v1 appledouble file format */
-struct hfs_nat_hdr {
-	hfs_lword_t	magic;
-	hfs_lword_t	version;
-	hfs_byte_t	homefs[16];
-	hfs_word_t	entries;
-	hfs_byte_t	descrs[12*5];
-	hfs_byte_t	real_name[255];	/* id=3 */
-	hfs_byte_t	comment[200];	/* id=4 XXX: not yet implemented */
-	hfs_byte_t	old_info[16];	/* id=7 */
-	hfs_u8		finderinfo[32]; /* id=9 */
-};
-
-/* 
- * Default header layout for Netatalk and AppleDouble
- */
-struct hfs_dbl_hdr {
-	hfs_lword_t	magic;
-	hfs_lword_t	version;
-	hfs_byte_t	filler[16];
-	hfs_word_t	entries;
-	hfs_byte_t	descrs[12*HFS_HDR_MAX];
-	hfs_byte_t	real_name[255];	/* id=3 */
-	hfs_byte_t	comment[200];	/* id=4 XXX: not yet implemented */
-	hfs_u32		create_time;	/* \	          */
-	hfs_u32		modify_time;	/*  | id=8 (or 7) */
-	hfs_u32		backup_time;	/*  |	          */
-	hfs_u32         access_time;    /* /  (attributes with id=7) */
-	hfs_u8		finderinfo[32]; /* id=9 */
-	hfs_u32		fileinfo;	/* id=10 */
-        hfs_u32         cnid;           /* id=15 */
-	hfs_u8          short_name[12]; /* id=13 */
-	hfs_u8          prodosi[8];     /* id=11 */
-};
-
-
-/* finder metadata for CAP */
-struct hfs_cap_info {
-	hfs_byte_t	fi_fndr[32];	/* Finder's info */
-	hfs_word_t	fi_attr;	/* AFP attributes (f=file/d=dir) */
-#define HFS_AFP_INV             0x001   /* Invisible bit (f/d) */
-#define HFS_AFP_EXPFOLDER       0x002   /* exported folder (d) */
-#define HFS_AFP_MULTI           0x002   /* Multiuser bit (f) */
-#define HFS_AFP_SYS             0x004   /* System bit (f/d) */
-#define HFS_AFP_DOPEN           0x008   /* data fork already open (f) */
-#define HFS_AFP_MOUNTED         0x008   /* mounted folder (d) */
-#define HFS_AFP_ROPEN           0x010   /* resource fork already open (f) */
-#define HFS_AFP_INEXPFOLDER     0x010   /* folder in shared area (d) */
-#define HFS_AFP_WRI		0x020	/* Write inhibit bit (readonly) (f) */
-#define HFS_AFP_BACKUP          0x040   /* backup needed bit (f/d)  */
-#define HFS_AFP_RNI		0x080	/* Rename inhibit bit (f/d) */
-#define HFS_AFP_DEI		0x100	/* Delete inhibit bit (f/d) */
-#define HFS_AFP_NOCOPY          0x400   /* Copy protect bit (f) */
-#define HFS_AFP_RDONLY	(	HFS_AFP_WRI|HFS_AFP_RNI|HFS_AFP_DEI)
-	hfs_byte_t	fi_magic1;	/* Magic number: */
-#define HFS_CAP_MAGIC1		0xFF
-	hfs_byte_t	fi_version;	/* Version of this structure: */
-#define HFS_CAP_VERSION		0x10
-	hfs_byte_t	fi_magic;	/* Another magic number: */
-#define HFS_CAP_MAGIC		0xDA
-	hfs_byte_t	fi_bitmap;	/* Bitmap of which names are valid: */
-#define HFS_CAP_SHORTNAME	0x01
-#define HFS_CAP_LONGNAME	0x02
-	hfs_byte_t	fi_shortfilename[12+1];	/* "short name" (unused) */
-	hfs_byte_t	fi_macfilename[32+1];	/* Original (Macintosh) name */
-	hfs_byte_t	fi_comln;	/* Length of comment (always 0) */
-	hfs_byte_t	fi_comnt[200];	/* Finder comment (unused) */
-	/* optional: 	used by aufs only if compiled with USE_MAC_DATES */
-	hfs_byte_t	fi_datemagic;	/* Magic number for dates extension: */
-#define HFS_CAP_DMAGIC		0xDA
-	hfs_byte_t	fi_datevalid;	/* Bitmap of which dates are valid: */
-#define HFS_CAP_MDATE		0x01
-#define HFS_CAP_CDATE		0x02
-	hfs_lword_t	fi_ctime;	/* Creation date (in AFP format) */
-	hfs_lword_t	fi_mtime;	/* Modify date (in AFP format) */
-	hfs_lword_t	fi_utime;	/* Un*x time of last mtime change */
-	hfs_byte_t	pad;
-};
-
-#ifdef __KERNEL__
-
-typedef ssize_t hfs_rwret_t;
-typedef size_t hfs_rwarg_t;
-
-#include <asm/uaccess.h>
-
-/* Some forward declarations */
-struct hfs_fork;
-struct hfs_cat_key;
-struct hfs_cat_entry;
-extern struct hfs_cat_entry *hfs_cat_get(struct hfs_mdb *,
-					 const struct hfs_cat_key *);
-
-/* dir.c */
-extern int hfs_create(struct inode *, struct dentry *, int, struct nameidata *);
-extern int hfs_mkdir(struct inode *, struct dentry *, int);
-extern int hfs_unlink(struct inode *, struct dentry *);
-extern int hfs_rmdir(struct inode *, struct dentry *);
-extern int hfs_rename(struct inode *, struct dentry *,
-		      struct inode *, struct dentry *);
-
-/* dir_cap.c */
-extern const struct hfs_name hfs_cap_reserved1[];
-extern const struct hfs_name hfs_cap_reserved2[];
-extern struct inode_operations hfs_cap_ndir_inode_operations;
-extern struct inode_operations hfs_cap_fdir_inode_operations;
-extern struct inode_operations hfs_cap_rdir_inode_operations;
-extern struct file_operations hfs_cap_dir_operations;
-extern void hfs_cap_drop_dentry(struct dentry *, const ino_t);
-
-/* dir_dbl.c */
-extern const struct hfs_name hfs_dbl_reserved1[];
-extern const struct hfs_name hfs_dbl_reserved2[];
-extern struct inode_operations hfs_dbl_dir_inode_operations;
-extern struct file_operations hfs_dbl_dir_operations;
-extern void hfs_dbl_drop_dentry(struct dentry *, const ino_t);
-
-/* dir_nat.c */
-extern const struct hfs_name hfs_nat_reserved1[];
-extern const struct hfs_name hfs_nat_reserved2[];
-extern struct inode_operations hfs_nat_ndir_inode_operations;
-extern struct inode_operations hfs_nat_hdir_inode_operations;
-extern struct file_operations hfs_nat_dir_operations;
-extern void hfs_nat_drop_dentry(struct dentry *, const ino_t);
-
-/* file.c */
-extern hfs_s32 hfs_do_read(struct inode *, struct hfs_fork *, hfs_u32,
-			   char __user *, hfs_u32);
-extern hfs_s32 hfs_do_write(struct inode *, struct hfs_fork *, hfs_u32,
-			    const char __user *, hfs_u32);
-extern void hfs_file_fix_mode(struct hfs_cat_entry *entry);
-extern struct inode_operations hfs_file_inode_operations;
-extern struct file_operations hfs_file_operations;
-
-/* file_cap.c */
-extern struct inode_operations hfs_cap_info_inode_operations;
-extern struct file_operations hfs_cap_info_operations;
-
-/* file_hdr.c */
-extern struct inode_operations hfs_hdr_inode_operations;
-extern struct file_operations hfs_hdr_operations;
-extern const struct hfs_hdr_layout hfs_dbl_fil_hdr_layout;
-extern const struct hfs_hdr_layout hfs_dbl_dir_hdr_layout;
-extern const struct hfs_hdr_layout hfs_nat_hdr_layout;
-extern const struct hfs_hdr_layout hfs_nat2_hdr_layout;
-extern const struct hfs_hdr_layout hfs_sngl_hdr_layout;
-extern void hdr_truncate(struct inode *,size_t);
-
-/* inode.c */
-extern void hfs_put_inode(struct inode *);
-extern int hfs_notify_change(struct dentry *, struct iattr *);
-extern int hfs_notify_change_cap(struct dentry *, struct iattr *);
-extern int hfs_notify_change_hdr(struct dentry *, struct iattr *);
-extern struct inode *hfs_iget(struct hfs_cat_entry *, ino_t, struct dentry *);
-
-extern void hfs_cap_ifill(struct inode *, ino_t, const int);
-extern void hfs_dbl_ifill(struct inode *, ino_t, const int);
-extern void hfs_nat_ifill(struct inode *, ino_t, const int);
-extern void hfs_sngl_ifill(struct inode *, ino_t, const int);
-
-/* super.c */
-extern int hfs_fill_super(struct super_block *,void *,int);
-
-/* trans.c */
-extern void hfs_colon2mac(struct hfs_name *, const char *, int);
-extern void hfs_prcnt2mac(struct hfs_name *, const char *, int);
-extern void hfs_triv2mac(struct hfs_name *, const char *, int);
-extern void hfs_latin2mac(struct hfs_name *, const char *, int);
-extern int hfs_mac2cap(char *, const struct hfs_name *);
-extern int hfs_mac2nat(char *, const struct hfs_name *);
-extern int hfs_mac2latin(char *, const struct hfs_name *);
-extern int hfs_mac2seven(char *, const struct hfs_name *);
-extern int hfs_mac2eight(char *, const struct hfs_name *);
-extern int hfs_mac2alpha(char *, const struct hfs_name *);
-extern int hfs_mac2triv(char *, const struct hfs_name *);
-extern void hfs_tolower(unsigned char *, int);
-
-#include <linux/hfs_fs_i.h>
-#include <linux/hfs_fs_sb.h>
-
-static inline struct hfs_inode_info *HFS_I(struct inode *inode)
-{
-	return container_of(inode, struct hfs_inode_info, vfs_inode);
-}
-
-static inline struct hfs_sb_info *HFS_SB(struct super_block *sb)
-{
-	return sb->s_fs_info;
-}
-
-static inline void hfs_nameout(struct inode *dir, struct hfs_name *out,
-				   const char *in, int len) {
-	HFS_SB(dir->i_sb)->s_nameout(out, in, len);
-}
-
-static inline int hfs_namein(struct inode *dir, char *out,
-				 const struct hfs_name *in) {
-	int len = HFS_SB(dir->i_sb)->s_namein(out, in);
-	if (HFS_SB(dir->i_sb)->s_lowercase) {
-		hfs_tolower(out, len);
-	}
-	return len;
-}
-
-#endif /* __KERNEL__ */
-#endif
diff -purN /dev/shm/linux-2.5/include/linux/hfs_fs_i.h linuxppc-2.5-benh/include/linux/hfs_fs_i.h
--- /dev/shm/linux-2.5/include/linux/hfs_fs_i.h	2002-07-19 00:18:05.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/hfs_fs_i.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,45 +0,0 @@
-/* 
- * linux/include/linux/hfs_fs_i.h
- *
- * Copyright (C) 1995, 1996  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file defines the type (struct hfs_inode_info) and the two
- * subordinate types hfs_extent and hfs_file.
- */
-
-#ifndef _LINUX_HFS_FS_I_H
-#define _LINUX_HFS_FS_I_H
-
-/*
- * struct hfs_inode_info
- *
- * The HFS-specific part of a Linux (struct inode)
- */
-struct hfs_inode_info {
-	int				magic;     /* A magic number */
-
-	loff_t				mmu_private;
-	struct hfs_cat_entry		*entry;
-
-	/* For a regular or header file */
-	struct hfs_fork 		*fork;
-	int				convert;
-
-	/* For a directory */
-	ino_t				file_type;
-	char				dir_size;
-
-	/* For header files */
-	const struct hfs_hdr_layout	*default_layout;
-	struct hfs_hdr_layout		*layout;
-
-	/* to deal with localtime ugliness */
-	int                             tz_secondswest;
-
-        /* for dentry cleanup */
-        void (*d_drop_op)(struct dentry *, const ino_t);
-	struct inode vfs_inode;
-};
-
-#endif
diff -purN /dev/shm/linux-2.5/include/linux/hfs_fs_sb.h linuxppc-2.5-benh/include/linux/hfs_fs_sb.h
--- /dev/shm/linux-2.5/include/linux/hfs_fs_sb.h	2002-02-05 07:37:28.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/hfs_fs_sb.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,53 +0,0 @@
-/* 
- * linux/include/linux/hfs_fs_sb.h
- *
- * Copyright (C) 1995-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file defines the type (struct hfs_sb_info) which contains the
- * HFS-specific information in the in-core superblock.
- */
-
-#ifndef _LINUX_HFS_FS_SB_H
-#define _LINUX_HFS_FS_SB_H
-
-/* forward declaration: */
-struct hfs_name;
-
-typedef int (*hfs_namein_fn) (char *, const struct hfs_name *);
-typedef void (*hfs_nameout_fn) (struct hfs_name *, const char *, int);
-typedef void (*hfs_ifill_fn) (struct inode *, ino_t, const int);
-
-/*
- * struct hfs_sb_info
- *
- * The HFS-specific part of a Linux (struct super_block)
- */
-struct hfs_sb_info {
-	int			magic;		/* A magic number */
-	struct hfs_mdb		*s_mdb;		/* The HFS MDB */
-	int			s_quiet;	/* Silent failure when 
-						   changing owner or mode? */
-	int			s_lowercase;	/* Map names to lowercase? */
-	int			s_afpd;		/* AFPD compatible mode? */
-	int                     s_version;      /* version info */
-	hfs_namein_fn		s_namein;	/* The function used to
-						   map Mac filenames to
-						   Linux filenames */
-	hfs_nameout_fn		s_nameout;	/* The function used to
-						    map Linux filenames
-						    to Mac filenames */
-	hfs_ifill_fn		s_ifill;	/* The function used
-						   to fill in inode fields */
-	const struct hfs_name	*s_reserved1;	/* Reserved names */
-	const struct hfs_name	*s_reserved2;	/* Reserved names */
-	__u32			s_type;		/* Type for new files */
-	__u32			s_creator;	/* Creator for new files */
-	umode_t			s_umask;	/* The umask applied to the
-						   permissions on all files */
-	uid_t			s_uid;		/* The uid of all files */
-	gid_t			s_gid;		/* The gid of all files */
-	char			s_conv;		/* Type of text conversion */
-};
-
-#endif
diff -purN /dev/shm/linux-2.5/include/linux/hfs_sysdep.h linuxppc-2.5-benh/include/linux/hfs_sysdep.h
--- /dev/shm/linux-2.5/include/linux/hfs_sysdep.h	2003-07-18 05:30:39.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/hfs_sysdep.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,238 +0,0 @@
-/*
- * linux/include/linux/hfs_sysdep.h
- *
- * Copyright (C) 1996-1997  Paul H. Hargrove
- * This file may be distributed under the terms of the GNU General Public License.
- *
- * This file contains constants, types and inline
- * functions for various system dependent things.
- *
- * "XXX" in a comment is a note to myself to consider changing something.
- *
- * In function preconditions the term "valid" applied to a pointer to
- * a structure means that the pointer is non-NULL and the structure it
- * points to has all fields initialized to consistent values.
- */
-
-#ifndef _HFS_SYSDEP_H
-#define _HFS_SYSDEP_H
-
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/buffer_head.h>
-
-#include <asm/byteorder.h>
-#include <asm/unaligned.h>
-
-extern struct timezone sys_tz;
-
-/* Typedefs for integer types by size and signedness */
-typedef __u8            hfs_u8;
-typedef __u16           hfs_u16;
-typedef __u32           hfs_u32;
-typedef __s8            hfs_s8;
-typedef __s16           hfs_s16;
-typedef __s32           hfs_s32;
-
-/* Typedefs for unaligned integer types */
-typedef unsigned char hfs_byte_t;
-typedef unsigned char hfs_word_t[2];
-typedef unsigned char hfs_lword_t[4];
-
-/* these funny looking things are GCC variable argument macros */
-#define hfs_warn(format, args...) printk(KERN_WARNING format , ## args)
-#define hfs_error(format, args...) printk(KERN_ERR format , ## args)
-
-
-#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
-extern long int hfs_alloc;
-#endif
-
-static inline void *hfs_malloc(unsigned int size) {
-#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
-	hfs_warn("%ld bytes allocation at %s:%u\n",
-		 (hfs_alloc += size), __FILE__, __LINE__);
-#endif
-	return kmalloc(size, GFP_KERNEL);
-}
-
-static inline void hfs_free(void *ptr, unsigned int size) {
-	kfree(ptr);
-#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
-	hfs_warn("%ld bytes allocation at %s:%u\n",
-		  (hfs_alloc -= ptr ? size : 0), __FILE__, __LINE__);
-#endif
-}
-
-
-/* handle conversion between times. 
- *
- * NOTE: hfs+ doesn't need this. also, we don't use tz_dsttime as that's
- *       not a good thing to do. instead, we depend upon tz_minuteswest
- *       having the correct daylight savings correction. 
- */
-static inline hfs_u32 hfs_from_utc(hfs_s32 time)
-{
-	return time - sys_tz.tz_minuteswest*60; 
-}
-
-static inline hfs_s32 hfs_to_utc(hfs_u32 time)
-{
-	return time + sys_tz.tz_minuteswest*60;
-}
-
-static inline hfs_u32 hfs_time(void) {
-	return htonl(hfs_from_utc(get_seconds())+2082844800U);
-}
-
-
-/*
- * hfs_wait_queue 
- */
-typedef wait_queue_head_t hfs_wait_queue;
-
-static inline void hfs_init_waitqueue(hfs_wait_queue *queue) {
-        init_waitqueue_head(queue);
-}
-
-static inline void hfs_sleep_on(hfs_wait_queue *queue) {
-	sleep_on(queue);
-}
-
-static inline void hfs_wake_up(hfs_wait_queue *queue) {
-	wake_up(queue);
-}
-
-static inline void hfs_relinquish(void) {
-	schedule();
-}
-
-
-/*
- * hfs_sysmdb 
- */
-typedef struct super_block *hfs_sysmdb;
-
-static inline void hfs_mdb_dirty(hfs_sysmdb sys_mdb) {
-	sys_mdb->s_dirt = 1;
-}
-
-static inline const char *hfs_mdb_name(hfs_sysmdb sys_mdb) {
-	return sys_mdb->s_id;
-}
-
-
-/*
- * hfs_sysentry
- */
-typedef struct dentry *hfs_sysentry[4];
-
-/*
- * hfs_buffer
- */
-typedef struct buffer_head *hfs_buffer;
-
-#define HFS_BAD_BUFFER NULL
-
-/* In sysdep.c, since it needs HFS_SECTOR_SIZE */
-extern hfs_buffer hfs_buffer_get(hfs_sysmdb, int, int);
-
-static inline int hfs_buffer_ok(hfs_buffer buffer) {
-	return (buffer != NULL);
-}
-
-static inline void hfs_buffer_put(hfs_buffer buffer) {
-	brelse(buffer);
-}
-
-static inline void hfs_buffer_dirty(hfs_buffer buffer) {
-	mark_buffer_dirty(buffer);
-}
-
-static inline void hfs_buffer_sync(hfs_buffer buffer) {
-	if (buffer_dirty(buffer))
-		sync_dirty_buffer(buffer);
-}
-
-static inline void *hfs_buffer_data(const hfs_buffer buffer) {
-	return buffer->b_data;
-}
-
-
-/*
- * bit operations
- */
-
-#undef BITNR
-#if defined(__BIG_ENDIAN)
-#	define BITNR(X)	((X)^31)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) (x)
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) (x)
-#	endif
-#elif defined(__LITTLE_ENDIAN)
-#	define BITNR(X)	((X)^7)
-#	if !defined(__constant_htonl)
-#		define __constant_htonl(x) \
-        ((unsigned long int)((((unsigned long int)(x) & 0x000000ffU) << 24) | \
-                             (((unsigned long int)(x) & 0x0000ff00U) <<  8) | \
-                             (((unsigned long int)(x) & 0x00ff0000U) >>  8) | \
-                             (((unsigned long int)(x) & 0xff000000U) >> 24)))
-#	endif
-#	if !defined(__constant_htons)
-#		define __constant_htons(x) \
-        ((unsigned short int)((((unsigned short int)(x) & 0x00ff) << 8) | \
-                              (((unsigned short int)(x) & 0xff00) >> 8)))
-#	endif
-#else
-#	error "Don't know if bytes are big- or little-endian!"
-#endif
-
-static inline int hfs_clear_bit(int bitnr, hfs_u32 *lword) {
-	return test_and_clear_bit(BITNR(bitnr), (unsigned long *)lword);
-}
-
-static inline int hfs_set_bit(int bitnr, hfs_u32 *lword) {
-	return test_and_set_bit(BITNR(bitnr), (unsigned long *)lword);
-}
-
-static inline int hfs_test_bit(int bitnr, const hfs_u32 *lword) {
-	/* the kernel should declare the second arg of test_bit as const */
-	return test_bit(BITNR(bitnr), (unsigned long *)lword);
-}
-
-#undef BITNR
-
-/*
- * HFS structures have fields aligned to 16-bit boundaries.
- * So, 16-bit get/put are easy while 32-bit get/put need
- * some care on architectures like the DEC Alpha.
- *
- * In what follows:
- *	ns  = 16-bit integer in network byte-order w/ 16-bit alignment
- *	hs  = 16-bit integer in host byte-order w/ 16-bit alignment
- *	nl  = 32-bit integer in network byte-order w/ unknown alignment
- *	hl  = 32-bit integer in host byte-order w/ unknown alignment
- *	anl = 32-bit integer in network byte-order w/ 32-bit alignment
- *	ahl = 32-bit integer in host byte-order w/ 32-bit alignment
- * Example: hfs_get_hl() gets an unaligned 32-bit integer converting
- *	it to host byte-order.
- */
-#define hfs_get_hs(addr)	ntohs(*((hfs_u16 *)(addr)))
-#define hfs_get_ns(addr)	(*((hfs_u16 *)(addr)))
-#define hfs_get_hl(addr)	ntohl(get_unaligned((hfs_u32 *)(addr)))
-#define hfs_get_nl(addr)	get_unaligned((hfs_u32 *)(addr))
-#define hfs_get_ahl(addr)	ntohl(*((hfs_u32 *)(addr)))
-#define hfs_get_anl(addr)	(*((hfs_u32 *)(addr)))
-#define hfs_put_hs(val, addr) 	((void)(*((hfs_u16 *)(addr)) = ntohs(val)))
-#define hfs_put_ns(val, addr) 	((void)(*((hfs_u16 *)(addr)) = (val)))
-#define hfs_put_hl(val, addr) 	put_unaligned(htonl(val), (hfs_u32 *)(addr))
-#define hfs_put_nl(val, addr) 	put_unaligned((val), (hfs_u32 *)(addr))
-#define hfs_put_ahl(val, addr) 	((void)(*((hfs_u32 *)(addr)) = ntohl(val)))
-#define hfs_put_anl(val, addr) 	((void)(*((hfs_u32 *)(addr)) = (val)))
-
-#endif
diff -purN /dev/shm/linux-2.5/include/linux/ibm_gpio.h linuxppc-2.5-benh/include/linux/ibm_gpio.h
--- /dev/shm/linux-2.5/include/linux/ibm_gpio.h	1970-01-01 00:00:00.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/ibm_gpio.h	2003-07-21 22:46:47.000000000 +0000
@@ -0,0 +1,66 @@
+/*
+ * FILE NAME ibm_ocp_gpio.h
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Generic gpio.
+ *
+ *  Armin Kuster akuster@pacbell.net
+ *  Sept, 2001
+ *
+ *  Orignial driver
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Frank Rowand <frank_rowand@mvista.com>
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __IBM_OCP_GPIO_H
+#define __IBM_OCP_GPIO_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+typedef struct gpio_regs {
+	u32 or;
+	u32 tcr;
+	u32 pad[4];
+	u32 odr;
+	u32 ir;
+} gpio_t;
+
+#define IBMGPIO_IOCTL_BASE	'Z'
+
+struct ibm_gpio_ioctl_data {
+	__u32 device;
+	__u32 mask;
+	__u32 data;
+};
+
+#define GPIO_MINOR             185
+#define IBMGPIO_IN		_IOWR(IBMGPIO_IOCTL_BASE, 0, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OUT		_IOW (IBMGPIO_IOCTL_BASE, 1, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_OPEN_DRAIN	_IOW (IBMGPIO_IOCTL_BASE, 2, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_TRISTATE	_IOW (IBMGPIO_IOCTL_BASE, 3, struct ibm_gpio_ioctl_data)
+#define IBMGPIO_CFG		_IOW (IBMGPIO_IOCTL_BASE, 4, struct ibm_gpio_ioctl_data)
+
+#endif
diff -purN /dev/shm/linux-2.5/include/linux/pci_ids.h linuxppc-2.5-benh/include/linux/pci_ids.h
--- /dev/shm/linux-2.5/include/linux/pci_ids.h	2004-01-19 23:38:05.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/pci_ids.h	2004-01-21 00:29:31.000000000 +0000
@@ -267,9 +267,18 @@
 #define PCI_DEVICE_ID_ATI_RADEON_QE	0x5145
 #define PCI_DEVICE_ID_ATI_RADEON_QF	0x5146
 #define PCI_DEVICE_ID_ATI_RADEON_QG	0x5147
+#define PCI_DEVICE_ID_ATI_RADEON_QH	0x5148
+#define PCI_DEVICE_ID_ATI_RADEON_QI	0x5149
+#define PCI_DEVICE_ID_ATI_RADEON_QJ	0x514a
+#define PCI_DEVICE_ID_ATI_RADEON_QK	0x514b
 /* Radeon RV100 (VE) */
 #define PCI_DEVICE_ID_ATI_RADEON_QY	0x5159
 #define PCI_DEVICE_ID_ATI_RADEON_QZ	0x515a
+#define PCI_DEVICE_ID_ATI_RADEON_Qh	0x5168
+#define PCI_DEVICE_ID_ATI_RADEON_Qi	0x5169
+#define PCI_DEVICE_ID_ATI_RADEON_Qj	0x516a
+#define PCI_DEVICE_ID_ATI_RADEON_Qk	0x516b
+#define PCI_DEVICE_ID_ATI_RADEON_Ql	0x516c
 /* Radeon R200 (8500) */
 #define PCI_DEVICE_ID_ATI_RADEON_QL	0x514c
 #define PCI_DEVICE_ID_ATI_RADEON_QN	0x514e
@@ -289,6 +298,7 @@
 #define PCI_DEVICE_ID_ATI_RADEON_Ie	0x4965
 #define PCI_DEVICE_ID_ATI_RADEON_If	0x4966
 #define PCI_DEVICE_ID_ATI_RADEON_Ig	0x4967
+#define PCI_DEVICE_ID_ATI_RADEON_In	0x496e
 /* Radeon RV280 (9200) */
 #define PCI_DEVICE_ID_ATI_RADEON_Y_	0x5960
 #define PCI_DEVICE_ID_ATI_RADEON_Yd	0x5964
@@ -299,11 +309,36 @@
 #define PCI_DEVICE_ID_ATI_RADEON_NE	0x4e45
 #define PCI_DEVICE_ID_ATI_RADEON_NF	0x4e46
 #define PCI_DEVICE_ID_ATI_RADEON_NG	0x4e47
+#define PCI_DEVICE_ID_ATI_RADEON_Nd	0x4e64
+#define PCI_DEVICE_ID_ATI_RADEON_Ne	0x4e65
+#define PCI_DEVICE_ID_ATI_RADEON_Nf	0x4e66
+#define PCI_DEVICE_ID_ATI_RADEON_Ng	0x4e67
+#define PCI_DEVICE_ID_ATI_RADEON_A6	0x4136
+#define PCI_DEVICE_ID_ATI_RADEON_A7	0x4137
+#define PCI_DEVICE_ID_ATI_RADEON_AD	0x4144
 #define PCI_DEVICE_ID_ATI_RADEON_AE	0x4145
 #define PCI_DEVICE_ID_ATI_RADEON_AF	0x4146
+#define PCI_DEVICE_ID_ATI_RADEON_AG	0x4147
+#define PCI_DEVICE_ID_ATI_RADEON_Ad	0x4164
+#define PCI_DEVICE_ID_ATI_RADEON_B7	0x4237
+#define PCI_DEVICE_ID_ATI_RADEON_BB	0x4242
+#define PCI_DEVICE_ID_ATI_RADEON_C6	0x4336
+#define PCI_DEVICE_ID_ATI_RADEON_C7	0x4337
+#define PCI_DEVICE_ID_ATI_RADEON_D7	0x4337
+/* Radeon RS300 */
+#define PCI_DEVICE_ID_ATI_RADEON_X0	0x5830
+#define PCI_DEVICE_ID_ATI_RADEON_X1	0x5831
+#define PCI_DEVICE_ID_ATI_RADEON_X2	0x5832
+#define PCI_DEVICE_ID_ATI_RADEON_X3	0x5833
+#define PCI_DEVICE_ID_ATI_RADEON_X4	0x5834
+#define PCI_DEVICE_ID_ATI_RADEON_X5	0x5835
+#define PCI_DEVICE_ID_ATI_RADEON_X6	0x5836
+#define PCI_DEVICE_ID_ATI_RADEON_X7	0x5837
 /* Radeon R350 (9800) */
 #define PCI_DEVICE_ID_ATI_RADEON_NH	0x4e48
+#define PCI_DEVICE_ID_ATI_RADEON_Nh	0x4e68
 #define PCI_DEVICE_ID_ATI_RADEON_NI	0x4e49
+#define PCI_DEVICE_ID_ATI_RADEON_Ni	0x4e69
 /* Radeon RV350 (9600) */
 #define PCI_DEVICE_ID_ATI_RADEON_AP	0x4150
 #define PCI_DEVICE_ID_ATI_RADEON_AR	0x4152
@@ -318,6 +353,7 @@
 #define PCI_DEVICE_ID_ATI_RADEON_Le	0x4c65
 #define PCI_DEVICE_ID_ATI_RADEON_Lf	0x4c66
 #define PCI_DEVICE_ID_ATI_RADEON_Lg	0x4c67
+#define PCI_DEVICE_ID_ATI_RADEON_Ln	0x4c6e
 /* Radeon */
 #define PCI_DEVICE_ID_ATI_RADEON_RA	0x5144
 #define PCI_DEVICE_ID_ATI_RADEON_RB	0x5145
@@ -709,6 +741,7 @@
 #define PCI_DEVICE_ID_TI_1410		0xac50
 #define PCI_DEVICE_ID_TI_1420		0xac51
 #define PCI_DEVICE_ID_TI_1520		0xac55
+#define PCI_DEVICE_ID_TI_1510		0xac56
 
 #define PCI_VENDOR_ID_SONY		0x104d
 #define PCI_DEVICE_ID_SONY_CXD3222	0x8039
@@ -804,9 +837,12 @@
 #define PCI_DEVICE_ID_APPLE_UNI_N_AGP15	0x002d
 #define PCI_DEVICE_ID_APPLE_UNI_N_FW2	0x0030
 #define PCI_DEVICE_ID_APPLE_UNI_N_GMAC2	0x0032
+#define PCI_DEVIEC_ID_APPLE_UNI_N_ATA	0x0033
 #define PCI_DEVICE_ID_APPLE_UNI_N_AGP2	0x0034
-#define PCI_DEVICE_ID_APPLE_KAUAI_ATA	0x003b
+#define PCI_DEVICE_ID_APPLE_IPID_ATA100	0x003b
 #define PCI_DEVICE_ID_APPLE_KEYLARGO_I	0x003e
+#define PCI_DEVICE_ID_APPLE_K2_ATA100	0x0043
+#define PCI_DEVICE_ID_APPLE_K2_GMAC	0x004c
 #define PCI_DEVICE_ID_APPLE_TIGON3	0x1645
 
 #define PCI_VENDOR_ID_YAMAHA		0x1073
diff -purN /dev/shm/linux-2.5/include/linux/pm.h linuxppc-2.5-benh/include/linux/pm.h
--- /dev/shm/linux-2.5/include/linux/pm.h	2003-08-21 18:47:27.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/pm.h	2003-08-25 20:03:37.000000000 +0000
@@ -63,6 +63,7 @@ enum
 	PM_SCSI_DEV,	    /* SCSI device */
 	PM_ISA_DEV,	    /* ISA device */
 	PM_MTD_DEV,	    /* Memory Technology Device */
+	PM_OCP_DEV,	    /* On Chip Device */
 };
 
 typedef int pm_dev_t;
diff -purN /dev/shm/linux-2.5/include/linux/timer.h linuxppc-2.5-benh/include/linux/timer.h
--- /dev/shm/linux-2.5/include/linux/timer.h	2003-08-15 01:16:51.000000000 +0000
+++ linuxppc-2.5-benh/include/linux/timer.h	2003-08-20 17:32:38.000000000 +0000
@@ -2,6 +2,7 @@
 #define _LINUX_TIMER_H
 
 #include <linux/config.h>
+#include <linux/stddef.h>
 #include <linux/list.h>
 #include <linux/spinlock.h>
 
diff -purN /dev/shm/linux-2.5/include/video/mach64.h linuxppc-2.5-benh/include/video/mach64.h
--- /dev/shm/linux-2.5/include/video/mach64.h	2003-05-01 16:32:15.000000000 +0000
+++ linuxppc-2.5-benh/include/video/mach64.h	2003-11-28 01:30:32.000000000 +0000
@@ -1148,6 +1148,11 @@
 #define APC_LUT_MN		0x39
 #define APC_LUT_OP		0x3A
 
+/* Values in LCD_GEN_CTRL */
+#define LCD_GCTL_CRT_ON   	0x00000001
+#define LCD_GCTL_LCD_ON		0x00000002
+#define LCD_GCTL_CRTC_RW_SEL	0x08000000
+#define LCD_GCTL_SHADOW_RW_EN	0x80000000
 
 /* Values in LCD_MISC_CNTL */
 #define BIAS_MOD_LEVEL_MASK	0x0000ff00
diff -purN /dev/shm/linux-2.5/include/video/radeon.h linuxppc-2.5-benh/include/video/radeon.h
--- /dev/shm/linux-2.5/include/video/radeon.h	2002-12-28 22:39:38.000000000 +0000
+++ linuxppc-2.5-benh/include/video/radeon.h	2004-02-04 06:58:21.000000000 +0000
@@ -365,6 +365,9 @@
 #define DSTCACHE_CTLSTAT                       0x1714  
 #define DEFAULT_PITCH_OFFSET                   0x16E0  
 #define DEFAULT_SC_BOTTOM_RIGHT                0x16E8  
+#define DEFAULT_SC_TOP_LEFT                    0x16EC
+#define SRC_PITCH_OFFSET                       0x1428
+#define DST_PITCH_OFFSET                       0x142C
 #define DP_GUI_MASTER_CNTL                     0x146C  
 #define SC_TOP_LEFT                            0x16EC  
 #define SC_BOTTOM_RIGHT                        0x16F0  
@@ -373,18 +376,23 @@
 #define RB2D_DSTCACHE_CTLSTAT		       0x342C
 #define LVDS_GEN_CNTL			       0x02d0
 #define LVDS_PLL_CNTL			       0x02d4
+#define FP2_GEN_CNTL                           0x0288
+#define TMDS_CNTL                              0x0294
 #define TMDS_CRC			       0x02a0
 #define TMDS_TRANSMITTER_CNTL		       0x02a4
+#define MPP_TB_CONFIG            	       0x01c0
 
-#define RADEON_BASE_CODE		       0x0f0b
-#define RADEON_BIOS_0_SCRATCH		       0x0010
-#define RADEON_BIOS_1_SCRATCH		       0x0014
-#define RADEON_BIOS_2_SCRATCH		       0x0018
-#define RADEON_BIOS_3_SCRATCH		       0x001c
-#define RADEON_BIOS_4_SCRATCH		       0x0020
-#define RADEON_BIOS_5_SCRATCH		       0x0024
-#define RADEON_BIOS_6_SCRATCH		       0x0028
-#define RADEON_BIOS_7_SCRATCH		       0x002c
+//#define BASE_CODE			       0x0f0b
+#define BIOS_0_SCRATCH			       0x0010
+#define BIOS_1_SCRATCH			       0x0014
+#define BIOS_2_SCRATCH			       0x0018
+#define BIOS_3_SCRATCH			       0x001c
+#define BIOS_4_SCRATCH			       0x0020
+#define BIOS_5_SCRATCH			       0x0024
+#define BIOS_6_SCRATCH			       0x0028
+#define BIOS_7_SCRATCH			       0x002c
+
+#define HDP_SOFT_RESET                         (1 << 26)
 
 #define TV_DAC_CNTL                            0x088c
 #define GPIOPAD_MASK                           0x0198
@@ -406,7 +414,7 @@
 #define PPLL_DIV_3                                 0x0007
 #define VCLK_ECP_CNTL                              0x0008
 #define HTOTAL_CNTL                                0x0009
-#define M_SPLL_REF_FB_DIV                          0x000a
+#define X_MPLL_REF_FB_DIV                          0x000a
 #define AGP_PLL_CNTL                               0x000b
 #define SPLL_CNTL                                  0x000c
 #define SCLK_CNTL                                  0x000d
@@ -422,6 +430,7 @@
 #define P2PLL_CNTL                                 0x002a
 #define P2PLL_REF_DIV                              0x002b
 #define PIXCLKS_CNTL                               0x002d
+#define SCLK_MORE_CNTL				   0x0035
 
 /* MCLK_CNTL bit constants */
 #define FORCEON_MCLKA				   (1 << 16)
@@ -431,6 +440,13 @@
 #define FORCEON_MC            		   	   (1 << 20)
 #define FORCEON_AIC           		   	   (1 << 21)
 
+/* SCLK_CNTL bit constants */
+#define DYN_STOP_LAT_MASK			   0x00007ff8
+#define CP_MAX_DYN_STOP_LAT			   0x0008
+#define SCLK_FORCEON_MASK			   0xffff8000
+
+/* SCLK_MORE_CNTL bit constants */
+#define SCLK_MORE_FORCEON			   0x0700
 
 /* BUS_CNTL bit constants */
 #define BUS_DBL_RESYNC                             0x00000001
@@ -457,12 +473,26 @@
 #define BUS_READ_BURST                             0x40000000
 #define BUS_RDY_READ_DLY                           0x80000000
 
+/* PIXCLKS_CNTL */
+#define PIX2CLK_SRC_SEL_MASK                       0x03
+#define PIX2CLK_SRC_SEL_CPUCLK                     0x00
+#define PIX2CLK_SRC_SEL_PSCANCLK                   0x01
+#define PIX2CLK_SRC_SEL_BYTECLK                    0x02
+#define PIX2CLK_SRC_SEL_P2PLLCLK                   0x03
+#define PIX2CLK_ALWAYS_ONb                         (1<<6)
+#define PIX2CLK_DAC_ALWAYS_ONb                     (1<<7)
+#define PIXCLK_TV_SRC_SEL                          (1 << 8)
+#define PIXCLK_LVDS_ALWAYS_ONb                     (1 << 14)
+#define PIXCLK_TMDS_ALWAYS_ONb                     (1 << 15)
+
 
 /* CLOCK_CNTL_INDEX bit constants */
 #define PLL_WR_EN                                  0x00000080
 
 /* CONFIG_CNTL bit constants */
 #define CFG_VGA_RAM_EN                             0x00000100
+#define CFG_ATI_REV_ID_MASK			   (0xf << 16)
+#define CFG_ATI_REV_A11				   (0 << 16)
 
 /* CRTC_EXT_CNTL bit constants */
 #define VGA_ATI_LINEAR                             0x00000008
@@ -484,6 +514,7 @@
 #define CRTC_DBL_SCAN_EN                           0x00000001
 #define CRTC_CUR_EN                                0x00010000
 #define CRTC_INTERLACE_EN			   (1 << 1)
+#define CRTC_BYPASS_LUT_EN     			   (1 << 14)
 #define CRTC_EXT_DISP_EN      			   (1 << 24)
 #define CRTC_EN					   (1 << 25)
 #define CRTC_DISP_REQ_EN_B                         (1 << 26)
@@ -500,6 +531,22 @@
 /* CUR_OFFSET, CUR_HORZ_VERT_POSN, CUR_HORZ_VERT_OFF bit constants */
 #define CUR_LOCK                                   0x80000000
 
+/* GPIO bit constants */
+#define GPIO_A_0		(1 <<  0)
+#define GPIO_A_1		(1 <<  1)
+#define GPIO_Y_0		(1 <<  8)
+#define GPIO_Y_1		(1 <<  9)
+#define GPIO_EN_0		(1 << 16)
+#define GPIO_EN_1		(1 << 17)
+#define GPIO_MASK_0		(1 << 24)
+#define GPIO_MASK_1		(1 << 25)
+#define VGA_DDC_DATA_OUTPUT	GPIO_A_0
+#define VGA_DDC_CLK_OUTPUT	GPIO_A_1
+#define VGA_DDC_DATA_INPUT	GPIO_Y_0
+#define VGA_DDC_CLK_INPUT	GPIO_Y_1
+#define VGA_DDC_DATA_OUT_EN	GPIO_EN_0
+#define VGA_DDC_CLK_OUT_EN	GPIO_EN_1
+
 
 /* FP bit constants */
 #define FP_CRTC_H_TOTAL_MASK			   0x000003ff
@@ -536,6 +583,25 @@
 #define FP_USE_SHADOW_EN			   (1 << 24)
 #define FP_CRT_SYNC_ALT				   (1 << 26)
 
+/* FP2_GEN_CNTL bit constants */
+#define FP2_BLANK_EN             (1 <<  1)
+#define FP2_ON                   (1 <<  2)
+#define FP2_PANEL_FORMAT         (1 <<  3)
+#define FP2_SOURCE_SEL_MASK      (3 << 10)
+#define FP2_SOURCE_SEL_CRTC2     (1 << 10)
+#define FP2_SRC_SEL_MASK         (3 << 13)
+#define FP2_SRC_SEL_CRTC2        (1 << 13)
+#define FP2_FP_POL               (1 << 16)
+#define FP2_LP_POL               (1 << 17)
+#define FP2_SCK_POL              (1 << 18)
+#define FP2_LCD_CNTL_MASK        (7 << 19)
+#define FP2_PAD_FLOP_EN          (1 << 22)
+#define FP2_CRC_EN               (1 << 23)
+#define FP2_CRC_READ_EN          (1 << 24)
+#define FP2_DV0_EN               (1 << 25)
+#define FP2_DV0_RATE_SEL_SDR     (1 << 26)
+
+
 /* LVDS_GEN_CNTL bit constants */
 #define LVDS_ON					   (1 << 0)
 #define LVDS_DISPLAY_DIS			   (1 << 1)
@@ -560,7 +626,7 @@
 #define TMDS_PLL_EN				   (1 << 0)
 #define TMDS_PLLRST				   (1 << 1)
 #define TMDS_RAN_PAT_RST			   (1 << 7)
-#define ICHCSEL					   (1 << 28)
+#define TMDS_ICHCSEL				   (1 << 28)
 
 /* FP_HORZ_STRETCH bit constants */
 #define HORZ_STRETCH_RATIO_MASK			   0xffff
@@ -592,14 +658,25 @@
 #define DAC_4BPP_PIX_ORDER                         0x00000200
 #define DAC_CRC_EN                                 0x00080000
 #define DAC_MASK_ALL				   (0xff << 24)
+#define DAC_PDWN                                   (1 << 15)
 #define DAC_EXPAND_MODE				   (1 << 14)
 #define DAC_VGA_ADR_EN				   (1 << 13)
-#define DAC_RANGE_CNTL				   (3 << 0)
-#define DAC_BLANKING				   (1 << 2)
-#define DAC_CMP_EN                                 (1 << 3)
+#define DAC_RANGE_CNTL				   (3 <<  0)
+#define DAC_RANGE_CNTL_MASK    			   0x03
+#define DAC_BLANKING				   (1 <<  2)
+#define DAC_CMP_EN                                 (1 <<  3)
+#define DAC_CMP_OUTPUT                             (1 <<  7)
 
 /* DAC_CNTL2 bit constants */   
 #define DAC2_CMP_EN                                (1 << 7)
+#define DAC2_PALETTE_ACCESS_CNTL                   (1 << 5)
+
+/* DAC_EXT_CNTL bit constants */
+#define DAC_FORCE_BLANK_OFF_EN                     (1 << 4)
+#define DAC_FORCE_DATA_EN                          (1 << 5)
+#define DAC_FORCE_DATA_SEL_MASK                    (3 << 6)
+#define DAC_FORCE_DATA_MASK                        0x0003ff00
+#define DAC_FORCE_DATA_SHIFT                       8
 
 /* GEN_RESET_CNTL bit constants */
 #define SOFT_RESET_GUI                             0x00000001
@@ -796,6 +873,11 @@
 #define MRDCKA1_RESET                              0x00020000
 
 /* VCLK_ECP_CNTL constants */
+#define VCLK_SRC_SEL_MASK                          0x03
+#define VCLK_SRC_SEL_CPUCLK                        0x00
+#define VCLK_SRC_SEL_PSCANCLK                      0x01
+#define VCLK_SRC_SEL_BYTECLK	                   0x02
+#define VCLK_SRC_SEL_PPLLCLK			   0x03
 #define PIXCLK_ALWAYS_ONb                          0x00000040
 #define PIXCLK_DAC_ALWAYS_ONb                      0x00000080
 
@@ -862,6 +944,7 @@
 #define DEFAULT_TILE_MASK		0xc0000000
 #define	PPLL_DIV_SEL_MASK		0x00000300
 #define	PPLL_RESET			0x00000001
+#define	PPLL_SLEEP			0x00000002
 #define PPLL_ATOMIC_UPDATE_EN		0x00010000
 #define PPLL_REF_DIV_MASK		0x000003ff
 #define	PPLL_FB3_DIV_MASK		0x000007ff
@@ -869,8 +952,999 @@
 #define PPLL_ATOMIC_UPDATE_R		0x00008000
 #define PPLL_ATOMIC_UPDATE_W		0x00008000
 #define	PPLL_VGA_ATOMIC_UPDATE_EN	0x00020000
+#define R300_PPLL_REF_DIV_ACC_MASK	(0x3ff << 18)
+#define R300_PPLL_REF_DIV_ACC_SHIFT	18
 
 #define GUI_ACTIVE			0x80000000
 
+
+#define MC_IND_INDEX                           0x01F8
+#define MC_IND_DATA                            0x01FC
+#define MEM_REFRESH_CNTL                       0x0178
+
+// CLK_PIN_CNTL
+#define CLK_PIN_CNTL__OSC_EN_MASK                          0x00000001L
+#define CLK_PIN_CNTL__OSC_EN                               0x00000001L
+#define CLK_PIN_CNTL__XTL_LOW_GAIN_MASK                    0x00000004L
+#define CLK_PIN_CNTL__XTL_LOW_GAIN                         0x00000004L
+#define CLK_PIN_CNTL__DONT_USE_XTALIN_MASK                 0x00000010L
+#define CLK_PIN_CNTL__DONT_USE_XTALIN                      0x00000010L
+#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE_MASK               0x00000020L
+#define CLK_PIN_CNTL__SLOW_CLOCK_SOURCE                    0x00000020L
+#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN_MASK                0x00000800L
+#define CLK_PIN_CNTL__CG_CLK_TO_OUTPIN                     0x00000800L
+#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN_MASK           0x00001000L
+#define CLK_PIN_CNTL__CG_COUNT_UP_TO_OUTPIN                0x00001000L
+#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND_MASK          0x00002000L
+#define CLK_PIN_CNTL__ACCESS_REGS_IN_SUSPEND               0x00002000L
+#define CLK_PIN_CNTL__CG_SPARE_MASK                        0x00004000L
+#define CLK_PIN_CNTL__CG_SPARE                             0x00004000L
+#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL_MASK             0x00008000L
+#define CLK_PIN_CNTL__SCLK_DYN_START_CNTL                  0x00008000L
+#define CLK_PIN_CNTL__CP_CLK_RUNNING_MASK                  0x00010000L
+#define CLK_PIN_CNTL__CP_CLK_RUNNING                       0x00010000L
+#define CLK_PIN_CNTL__CG_SPARE_RD_MASK                     0x00060000L
+#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb_MASK               0x00080000L
+#define CLK_PIN_CNTL__XTALIN_ALWAYS_ONb                    0x00080000L
+#define CLK_PIN_CNTL__PWRSEQ_DELAY_MASK                    0xff000000L
+
+// CLK_PWRMGT_CNTL_M6
+#define	CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF__SHIFT         0x00000000
+#define	CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF__SHIFT         0x00000001
+#define	CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF__SHIFT         0x00000002
+#define	CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF__SHIFT        0x00000003
+#define	CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF__SHIFT            0x00000004
+#define	CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF__SHIFT            0x00000005
+#define	CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF__SHIFT            0x00000006
+#define	CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF__SHIFT           0x00000007
+#define	CLK_PWRMGT_CNTL_M6__MC_CH_MODE__SHIFT              0x00000008
+#define	CLK_PWRMGT_CNTL_M6__TEST_MODE__SHIFT               0x00000009
+#define	CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN__SHIFT          0x0000000a
+#define	CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE__SHIFT      0x0000000c
+#define	CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT__SHIFT         0x0000000d
+#define	CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT__SHIFT       0x0000000f
+#define	CLK_PWRMGT_CNTL_M6__MC_BUSY__SHIFT                 0x00000010
+#define	CLK_PWRMGT_CNTL_M6__MC_INT_CNTL__SHIFT             0x00000011
+#define	CLK_PWRMGT_CNTL_M6__MC_SWITCH__SHIFT               0x00000012
+#define	CLK_PWRMGT_CNTL_M6__DLL_READY__SHIFT               0x00000013
+#define	CLK_PWRMGT_CNTL_M6__DISP_PM__SHIFT                 0x00000014
+#define	CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE__SHIFT           0x00000015
+#define	CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG__SHIFT            0x00000018
+#define	CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF__SHIFT        0x0000001e
+#define	CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF__SHIFT           0x0000001f
+
+// P2PLL_CNTL
+#define P2PLL_CNTL__P2PLL_RESET_MASK                       0x00000001L
+#define P2PLL_CNTL__P2PLL_RESET                            0x00000001L
+#define P2PLL_CNTL__P2PLL_SLEEP_MASK                       0x00000002L
+#define P2PLL_CNTL__P2PLL_SLEEP                            0x00000002L
+#define P2PLL_CNTL__P2PLL_TST_EN_MASK                      0x00000004L
+#define P2PLL_CNTL__P2PLL_TST_EN                           0x00000004L
+#define P2PLL_CNTL__P2PLL_REFCLK_SEL_MASK                  0x00000010L
+#define P2PLL_CNTL__P2PLL_REFCLK_SEL                       0x00000010L
+#define P2PLL_CNTL__P2PLL_FBCLK_SEL_MASK                   0x00000020L
+#define P2PLL_CNTL__P2PLL_FBCLK_SEL                        0x00000020L
+#define P2PLL_CNTL__P2PLL_TCPOFF_MASK                      0x00000040L
+#define P2PLL_CNTL__P2PLL_TCPOFF                           0x00000040L
+#define P2PLL_CNTL__P2PLL_TVCOMAX_MASK                     0x00000080L
+#define P2PLL_CNTL__P2PLL_TVCOMAX                          0x00000080L
+#define P2PLL_CNTL__P2PLL_PCP_MASK                         0x00000700L
+#define P2PLL_CNTL__P2PLL_PVG_MASK                         0x00003800L
+#define P2PLL_CNTL__P2PLL_PDC_MASK                         0x0000c000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN_MASK            0x00010000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_EN                 0x00010000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC_MASK          0x00040000L
+#define P2PLL_CNTL__P2PLL_ATOMIC_UPDATE_SYNC               0x00040000L
+#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET_MASK          0x00080000L
+#define P2PLL_CNTL__P2PLL_DISABLE_AUTO_RESET               0x00080000L
+
+// PIXCLKS_CNTL
+#define	PIXCLKS_CNTL__PIX2CLK_SRC_SEL__SHIFT               0x00000000
+#define	PIXCLKS_CNTL__PIX2CLK_INVERT__SHIFT                0x00000004
+#define	PIXCLKS_CNTL__PIX2CLK_SRC_INVERT__SHIFT            0x00000005
+#define	PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb__SHIFT            0x00000006
+#define	PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb__SHIFT        0x00000007
+#define	PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL__SHIFT             0x00000008
+#define	PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb__SHIFT       0x0000000b
+#define	PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb__SHIFT          0x0000000c
+#define	PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb__SHIFT    0x0000000d
+#define	PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb__SHIFT        0x0000000e
+#define	PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb__SHIFT        0x0000000f
+
+
+// PIXCLKS_CNTL
+#define PIXCLKS_CNTL__PIX2CLK_SRC_SEL_MASK                 0x00000003L
+#define PIXCLKS_CNTL__PIX2CLK_INVERT_MASK                  0x00000010L
+#define PIXCLKS_CNTL__PIX2CLK_INVERT                       0x00000010L
+#define PIXCLKS_CNTL__PIX2CLK_SRC_INVERT_MASK              0x00000020L
+#define PIXCLKS_CNTL__PIX2CLK_SRC_INVERT                   0x00000020L
+#define PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb_MASK              0x00000040L
+#define PIXCLKS_CNTL__PIX2CLK_ALWAYS_ONb                   0x00000040L
+#define PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb_MASK          0x00000080L
+#define PIXCLKS_CNTL__PIX2CLK_DAC_ALWAYS_ONb               0x00000080L
+#define PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL_MASK               0x00000100L
+#define PIXCLKS_CNTL__PIXCLK_TV_SRC_SEL                    0x00000100L
+#define PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb_MASK         0x00000800L
+#define PIXCLKS_CNTL__PIXCLK_BLEND_ALWAYS_ONb              0x00000800L
+#define PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb_MASK            0x00001000L
+#define PIXCLKS_CNTL__PIXCLK_GV_ALWAYS_ONb                 0x00001000L
+#define PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb_MASK      0x00002000L
+#define PIXCLKS_CNTL__PIXCLK_DIG_TMDS_ALWAYS_ONb           0x00002000L
+#define PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb_MASK          0x00004000L
+#define PIXCLKS_CNTL__PIXCLK_LVDS_ALWAYS_ONb               0x00004000L
+#define PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb_MASK          0x00008000L
+#define PIXCLKS_CNTL__PIXCLK_TMDS_ALWAYS_ONb               0x00008000L
+
+
+// P2PLL_DIV_0
+#define P2PLL_DIV_0__P2PLL_FB_DIV_MASK                     0x000007ffL
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W_MASK            0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_W                 0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R_MASK            0x00008000L
+#define P2PLL_DIV_0__P2PLL_ATOMIC_UPDATE_R                 0x00008000L
+#define P2PLL_DIV_0__P2PLL_POST_DIV_MASK                   0x00070000L
+
+// SCLK_CNTL_M6
+#define SCLK_CNTL_M6__SCLK_SRC_SEL_MASK                    0x00000007L
+#define SCLK_CNTL_M6__CP_MAX_DYN_STOP_LAT_MASK             0x00000008L
+#define SCLK_CNTL_M6__CP_MAX_DYN_STOP_LAT                  0x00000008L
+#define SCLK_CNTL_M6__HDP_MAX_DYN_STOP_LAT_MASK            0x00000010L
+#define SCLK_CNTL_M6__HDP_MAX_DYN_STOP_LAT                 0x00000010L
+#define SCLK_CNTL_M6__TV_MAX_DYN_STOP_LAT_MASK             0x00000020L
+#define SCLK_CNTL_M6__TV_MAX_DYN_STOP_LAT                  0x00000020L
+#define SCLK_CNTL_M6__E2_MAX_DYN_STOP_LAT_MASK             0x00000040L
+#define SCLK_CNTL_M6__E2_MAX_DYN_STOP_LAT                  0x00000040L
+#define SCLK_CNTL_M6__SE_MAX_DYN_STOP_LAT_MASK             0x00000080L
+#define SCLK_CNTL_M6__SE_MAX_DYN_STOP_LAT                  0x00000080L
+#define SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT_MASK           0x00000100L
+#define SCLK_CNTL_M6__IDCT_MAX_DYN_STOP_LAT                0x00000100L
+#define SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT_MASK            0x00000200L
+#define SCLK_CNTL_M6__VIP_MAX_DYN_STOP_LAT                 0x00000200L
+#define SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT_MASK             0x00000400L
+#define SCLK_CNTL_M6__RE_MAX_DYN_STOP_LAT                  0x00000400L
+#define SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT_MASK             0x00000800L
+#define SCLK_CNTL_M6__PB_MAX_DYN_STOP_LAT                  0x00000800L
+#define SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT_MASK            0x00001000L
+#define SCLK_CNTL_M6__TAM_MAX_DYN_STOP_LAT                 0x00001000L
+#define SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT_MASK            0x00002000L
+#define SCLK_CNTL_M6__TDM_MAX_DYN_STOP_LAT                 0x00002000L
+#define SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT_MASK             0x00004000L
+#define SCLK_CNTL_M6__RB_MAX_DYN_STOP_LAT                  0x00004000L
+#define SCLK_CNTL_M6__FORCE_DISP2_MASK                     0x00008000L
+#define SCLK_CNTL_M6__FORCE_DISP2                          0x00008000L
+#define SCLK_CNTL_M6__FORCE_CP_MASK                        0x00010000L
+#define SCLK_CNTL_M6__FORCE_CP                             0x00010000L
+#define SCLK_CNTL_M6__FORCE_HDP_MASK                       0x00020000L
+#define SCLK_CNTL_M6__FORCE_HDP                            0x00020000L
+#define SCLK_CNTL_M6__FORCE_DISP1_MASK                     0x00040000L
+#define SCLK_CNTL_M6__FORCE_DISP1                          0x00040000L
+#define SCLK_CNTL_M6__FORCE_TOP_MASK                       0x00080000L
+#define SCLK_CNTL_M6__FORCE_TOP                            0x00080000L
+#define SCLK_CNTL_M6__FORCE_E2_MASK                        0x00100000L
+#define SCLK_CNTL_M6__FORCE_E2                             0x00100000L
+#define SCLK_CNTL_M6__FORCE_SE_MASK                        0x00200000L
+#define SCLK_CNTL_M6__FORCE_SE                             0x00200000L
+#define SCLK_CNTL_M6__FORCE_IDCT_MASK                      0x00400000L
+#define SCLK_CNTL_M6__FORCE_IDCT                           0x00400000L
+#define SCLK_CNTL_M6__FORCE_VIP_MASK                       0x00800000L
+#define SCLK_CNTL_M6__FORCE_VIP                            0x00800000L
+#define SCLK_CNTL_M6__FORCE_RE_MASK                        0x01000000L
+#define SCLK_CNTL_M6__FORCE_RE                             0x01000000L
+#define SCLK_CNTL_M6__FORCE_PB_MASK                        0x02000000L
+#define SCLK_CNTL_M6__FORCE_PB                             0x02000000L
+#define SCLK_CNTL_M6__FORCE_TAM_MASK                       0x04000000L
+#define SCLK_CNTL_M6__FORCE_TAM                            0x04000000L
+#define SCLK_CNTL_M6__FORCE_TDM_MASK                       0x08000000L
+#define SCLK_CNTL_M6__FORCE_TDM                            0x08000000L
+#define SCLK_CNTL_M6__FORCE_RB_MASK                        0x10000000L
+#define SCLK_CNTL_M6__FORCE_RB                             0x10000000L
+#define SCLK_CNTL_M6__FORCE_TV_SCLK_MASK                   0x20000000L
+#define SCLK_CNTL_M6__FORCE_TV_SCLK                        0x20000000L
+#define SCLK_CNTL_M6__FORCE_SUBPIC_MASK                    0x40000000L
+#define SCLK_CNTL_M6__FORCE_SUBPIC                         0x40000000L
+#define SCLK_CNTL_M6__FORCE_OV0_MASK                       0x80000000L
+#define SCLK_CNTL_M6__FORCE_OV0                            0x80000000L
+
+// SCLK_MORE_CNTL
+#define SCLK_MORE_CNTL__DISPREGS_MAX_DYN_STOP_LAT_MASK     0x00000001L
+#define SCLK_MORE_CNTL__DISPREGS_MAX_DYN_STOP_LAT          0x00000001L
+#define SCLK_MORE_CNTL__MC_GUI_MAX_DYN_STOP_LAT_MASK       0x00000002L
+#define SCLK_MORE_CNTL__MC_GUI_MAX_DYN_STOP_LAT            0x00000002L
+#define SCLK_MORE_CNTL__MC_HOST_MAX_DYN_STOP_LAT_MASK      0x00000004L
+#define SCLK_MORE_CNTL__MC_HOST_MAX_DYN_STOP_LAT           0x00000004L
+#define SCLK_MORE_CNTL__FORCE_DISPREGS_MASK                0x00000100L
+#define SCLK_MORE_CNTL__FORCE_DISPREGS                     0x00000100L
+#define SCLK_MORE_CNTL__FORCE_MC_GUI_MASK                  0x00000200L
+#define SCLK_MORE_CNTL__FORCE_MC_GUI                       0x00000200L
+#define SCLK_MORE_CNTL__FORCE_MC_HOST_MASK                 0x00000400L
+#define SCLK_MORE_CNTL__FORCE_MC_HOST                      0x00000400L
+#define SCLK_MORE_CNTL__STOP_SCLK_EN_MASK                  0x00001000L
+#define SCLK_MORE_CNTL__STOP_SCLK_EN                       0x00001000L
+#define SCLK_MORE_CNTL__STOP_SCLK_A_MASK                   0x00002000L
+#define SCLK_MORE_CNTL__STOP_SCLK_A                        0x00002000L
+#define SCLK_MORE_CNTL__STOP_SCLK_B_MASK                   0x00004000L
+#define SCLK_MORE_CNTL__STOP_SCLK_B                        0x00004000L
+#define SCLK_MORE_CNTL__STOP_SCLK_C_MASK                   0x00008000L
+#define SCLK_MORE_CNTL__STOP_SCLK_C                        0x00008000L
+#define SCLK_MORE_CNTL__HALF_SPEED_SCLK_MASK               0x00010000L
+#define SCLK_MORE_CNTL__HALF_SPEED_SCLK                    0x00010000L
+#define SCLK_MORE_CNTL__IO_CG_VOLTAGE_DROP_MASK            0x00020000L
+#define SCLK_MORE_CNTL__IO_CG_VOLTAGE_DROP                 0x00020000L
+#define SCLK_MORE_CNTL__TVFB_SOFT_RESET_MASK               0x00040000L
+#define SCLK_MORE_CNTL__TVFB_SOFT_RESET                    0x00040000L
+#define SCLK_MORE_CNTL__VOLTAGE_DROP_SYNC_MASK             0x00080000L
+#define SCLK_MORE_CNTL__VOLTAGE_DROP_SYNC                  0x00080000L
+#define SCLK_MORE_CNTL__VOLTAGE_DELAY_SEL_MASK             0x00300000L
+#define SCLK_MORE_CNTL__IDLE_DELAY_HALF_SCLK_MASK          0x00400000L
+#define SCLK_MORE_CNTL__IDLE_DELAY_HALF_SCLK               0x00400000L
+#define SCLK_MORE_CNTL__AGP_BUSY_HALF_SCLK_MASK            0x00800000L
+#define SCLK_MORE_CNTL__AGP_BUSY_HALF_SCLK                 0x00800000L
+#define SCLK_MORE_CNTL__CG_SPARE_RD_C_MASK                 0xff000000L
+
+// MCLK_CNTL_M6
+#define MCLK_CNTL_M6__MCLKA_SRC_SEL_MASK                   0x00000007L
+#define MCLK_CNTL_M6__YCLKA_SRC_SEL_MASK                   0x00000070L
+#define MCLK_CNTL_M6__MCLKB_SRC_SEL_MASK                   0x00000700L
+#define MCLK_CNTL_M6__YCLKB_SRC_SEL_MASK                   0x00007000L
+#define MCLK_CNTL_M6__FORCE_MCLKA_MASK                     0x00010000L
+#define MCLK_CNTL_M6__FORCE_MCLKA                          0x00010000L
+#define MCLK_CNTL_M6__FORCE_MCLKB_MASK                     0x00020000L
+#define MCLK_CNTL_M6__FORCE_MCLKB                          0x00020000L
+#define MCLK_CNTL_M6__FORCE_YCLKA_MASK                     0x00040000L
+#define MCLK_CNTL_M6__FORCE_YCLKA                          0x00040000L
+#define MCLK_CNTL_M6__FORCE_YCLKB_MASK                     0x00080000L
+#define MCLK_CNTL_M6__FORCE_YCLKB                          0x00080000L
+#define MCLK_CNTL_M6__FORCE_MC_MASK                        0x00100000L
+#define MCLK_CNTL_M6__FORCE_MC                             0x00100000L
+#define MCLK_CNTL_M6__FORCE_AIC_MASK                       0x00200000L
+#define MCLK_CNTL_M6__FORCE_AIC                            0x00200000L
+#define MCLK_CNTL_M6__MRDCKA0_SOUTSEL_MASK                 0x03000000L
+#define MCLK_CNTL_M6__MRDCKA1_SOUTSEL_MASK                 0x0c000000L
+#define MCLK_CNTL_M6__MRDCKB0_SOUTSEL_MASK                 0x30000000L
+#define MCLK_CNTL_M6__MRDCKB1_SOUTSEL_MASK                 0xc0000000L
+
+// MCLK_MISC
+#define MCLK_MISC__SCLK_SOURCED_FROM_MPLL_SEL_MASK         0x00000003L
+#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL_MASK             0x00000004L
+#define MCLK_MISC__MCLK_FROM_SPLL_DIV_SEL                  0x00000004L
+#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL_MASK              0x00000008L
+#define MCLK_MISC__ENABLE_SCLK_FROM_MPLL                   0x00000008L
+#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN_MASK         0x00000010L
+#define MCLK_MISC__MPLL_MODEA_MODEC_HW_SEL_EN              0x00000010L
+#define MCLK_MISC__DLL_READY_LAT_MASK                      0x00000100L
+#define MCLK_MISC__DLL_READY_LAT                           0x00000100L
+#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT_MASK           0x00001000L
+#define MCLK_MISC__MC_MCLK_MAX_DYN_STOP_LAT                0x00001000L
+#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT_MASK           0x00002000L
+#define MCLK_MISC__IO_MCLK_MAX_DYN_STOP_LAT                0x00002000L
+#define MCLK_MISC__MC_MCLK_DYN_ENABLE_MASK                 0x00004000L
+#define MCLK_MISC__MC_MCLK_DYN_ENABLE                      0x00004000L
+#define MCLK_MISC__IO_MCLK_DYN_ENABLE_MASK                 0x00008000L
+#define MCLK_MISC__IO_MCLK_DYN_ENABLE                      0x00008000L
+#define MCLK_MISC__CGM_CLK_TO_OUTPIN_MASK                  0x00010000L
+#define MCLK_MISC__CGM_CLK_TO_OUTPIN                       0x00010000L
+#define MCLK_MISC__CLK_OR_COUNT_SEL_MASK                   0x00020000L
+#define MCLK_MISC__CLK_OR_COUNT_SEL                        0x00020000L
+#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND_MASK        0x00040000L
+#define MCLK_MISC__EN_MCLK_TRISTATE_IN_SUSPEND             0x00040000L
+#define MCLK_MISC__CGM_SPARE_RD_MASK                       0x00300000L
+#define MCLK_MISC__CGM_SPARE_A_RD_MASK                     0x00c00000L
+#define MCLK_MISC__TCLK_TO_YCLKB_EN_MASK                   0x01000000L
+#define MCLK_MISC__TCLK_TO_YCLKB_EN                        0x01000000L
+#define MCLK_MISC__CGM_SPARE_A_MASK                        0x0e000000L
+
+// VCLK_ECP_CNTL
+#define VCLK_ECP_CNTL__VCLK_SRC_SEL_MASK                   0x00000003L
+#define VCLK_ECP_CNTL__VCLK_INVERT_MASK                    0x00000010L
+#define VCLK_ECP_CNTL__VCLK_INVERT                         0x00000010L
+#define VCLK_ECP_CNTL__PIXCLK_SRC_INVERT_MASK              0x00000020L
+#define VCLK_ECP_CNTL__PIXCLK_SRC_INVERT                   0x00000020L
+#define VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb_MASK              0x00000040L
+#define VCLK_ECP_CNTL__PIXCLK_ALWAYS_ONb                   0x00000040L
+#define VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb_MASK          0x00000080L
+#define VCLK_ECP_CNTL__PIXCLK_DAC_ALWAYS_ONb               0x00000080L
+#define VCLK_ECP_CNTL__ECP_DIV_MASK                        0x00000300L
+#define VCLK_ECP_CNTL__ECP_FORCE_ON_MASK                   0x00040000L
+#define VCLK_ECP_CNTL__ECP_FORCE_ON                        0x00040000L
+#define VCLK_ECP_CNTL__SUBCLK_FORCE_ON_MASK                0x00080000L
+#define VCLK_ECP_CNTL__SUBCLK_FORCE_ON                     0x00080000L
+
+// PLL_PWRMGT_CNTL
+#define PLL_PWRMGT_CNTL__MPLL_TURNOFF_MASK                 0x00000001L
+#define PLL_PWRMGT_CNTL__MPLL_TURNOFF                      0x00000001L
+#define PLL_PWRMGT_CNTL__SPLL_TURNOFF_MASK                 0x00000002L
+#define PLL_PWRMGT_CNTL__SPLL_TURNOFF                      0x00000002L
+#define PLL_PWRMGT_CNTL__PPLL_TURNOFF_MASK                 0x00000004L
+#define PLL_PWRMGT_CNTL__PPLL_TURNOFF                      0x00000004L
+#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF_MASK                0x00000008L
+#define PLL_PWRMGT_CNTL__P2PLL_TURNOFF                     0x00000008L
+#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF_MASK                0x00000010L
+#define PLL_PWRMGT_CNTL__TVPLL_TURNOFF                     0x00000010L
+#define PLL_PWRMGT_CNTL__AGPCLK_DYN_STOP_LAT_MASK          0x000001e0L
+#define PLL_PWRMGT_CNTL__APM_POWER_STATE_MASK              0x00000600L
+#define PLL_PWRMGT_CNTL__APM_PWRSTATE_RD_MASK              0x00001800L
+#define PLL_PWRMGT_CNTL__PM_MODE_SEL_MASK                  0x00002000L
+#define PLL_PWRMGT_CNTL__PM_MODE_SEL                       0x00002000L
+#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND_MASK          0x00004000L
+#define PLL_PWRMGT_CNTL__EN_PWRSEQ_DONE_COND               0x00004000L
+#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND_MASK          0x00008000L
+#define PLL_PWRMGT_CNTL__EN_DISP_PARKED_COND               0x00008000L
+#define PLL_PWRMGT_CNTL__MOBILE_SU_MASK                    0x00010000L
+#define PLL_PWRMGT_CNTL__MOBILE_SU                         0x00010000L
+#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK_MASK             0x00020000L
+#define PLL_PWRMGT_CNTL__SU_SCLK_USE_BCLK                  0x00020000L
+#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK_MASK             0x00040000L
+#define PLL_PWRMGT_CNTL__SU_MCLK_USE_BCLK                  0x00040000L
+#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE_MASK           0x00080000L
+#define PLL_PWRMGT_CNTL__SU_SUSTAIN_DISABLE                0x00080000L
+#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE_MASK           0x00100000L
+#define PLL_PWRMGT_CNTL__TCL_BYPASS_DISABLE                0x00100000L
+#define PLL_PWRMGT_CNTL__TCL_CLOCK_ACTIVE_RD_MASK          0x00200000L
+#define PLL_PWRMGT_CNTL__TCL_CLOCK_ACTIVE_RD               0x00200000L
+#define PLL_PWRMGT_CNTL__CG_NO2_DEBUG_MASK                 0xff000000L
+
+// CLK_PWRMGT_CNTL_M6
+#define CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF_MASK           0x00000001L
+#define CLK_PWRMGT_CNTL_M6__MPLL_PWRMGT_OFF                0x00000001L
+#define CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF_MASK           0x00000002L
+#define CLK_PWRMGT_CNTL_M6__SPLL_PWRMGT_OFF                0x00000002L
+#define CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF_MASK           0x00000004L
+#define CLK_PWRMGT_CNTL_M6__PPLL_PWRMGT_OFF                0x00000004L
+#define CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF_MASK          0x00000008L
+#define CLK_PWRMGT_CNTL_M6__P2PLL_PWRMGT_OFF               0x00000008L
+#define CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF_MASK              0x00000010L
+#define CLK_PWRMGT_CNTL_M6__MCLK_TURNOFF                   0x00000010L
+#define CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF_MASK              0x00000020L
+#define CLK_PWRMGT_CNTL_M6__SCLK_TURNOFF                   0x00000020L
+#define CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF_MASK              0x00000040L
+#define CLK_PWRMGT_CNTL_M6__PCLK_TURNOFF                   0x00000040L
+#define CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF_MASK             0x00000080L
+#define CLK_PWRMGT_CNTL_M6__P2CLK_TURNOFF                  0x00000080L
+#define CLK_PWRMGT_CNTL_M6__MC_CH_MODE_MASK                0x00000100L
+#define CLK_PWRMGT_CNTL_M6__MC_CH_MODE                     0x00000100L
+#define CLK_PWRMGT_CNTL_M6__TEST_MODE_MASK                 0x00000200L
+#define CLK_PWRMGT_CNTL_M6__TEST_MODE                      0x00000200L
+#define CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN_MASK            0x00000400L
+#define CLK_PWRMGT_CNTL_M6__GLOBAL_PMAN_EN                 0x00000400L
+#define CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE_MASK        0x00001000L
+#define CLK_PWRMGT_CNTL_M6__ENGINE_DYNCLK_MODE             0x00001000L
+#define CLK_PWRMGT_CNTL_M6__ACTIVE_HILO_LAT_MASK           0x00006000L
+#define CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT_MASK         0x00008000L
+#define CLK_PWRMGT_CNTL_M6__DISP_DYN_STOP_LAT              0x00008000L
+#define CLK_PWRMGT_CNTL_M6__MC_BUSY_MASK                   0x00010000L
+#define CLK_PWRMGT_CNTL_M6__MC_BUSY                        0x00010000L
+#define CLK_PWRMGT_CNTL_M6__MC_INT_CNTL_MASK               0x00020000L
+#define CLK_PWRMGT_CNTL_M6__MC_INT_CNTL                    0x00020000L
+#define CLK_PWRMGT_CNTL_M6__MC_SWITCH_MASK                 0x00040000L
+#define CLK_PWRMGT_CNTL_M6__MC_SWITCH                      0x00040000L
+#define CLK_PWRMGT_CNTL_M6__DLL_READY_MASK                 0x00080000L
+#define CLK_PWRMGT_CNTL_M6__DLL_READY                      0x00080000L
+#define CLK_PWRMGT_CNTL_M6__DISP_PM_MASK                   0x00100000L
+#define CLK_PWRMGT_CNTL_M6__DISP_PM                        0x00100000L
+#define CLK_PWRMGT_CNTL_M6__DYN_STOP_MODE_MASK             0x00e00000L
+#define CLK_PWRMGT_CNTL_M6__CG_NO1_DEBUG_MASK              0x3f000000L
+#define CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF_MASK          0x40000000L
+#define CLK_PWRMGT_CNTL_M6__TVPLL_PWRMGT_OFF               0x40000000L
+#define CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF_MASK             0x80000000L
+#define CLK_PWRMGT_CNTL_M6__TVCLK_TURNOFF                  0x80000000L
+
+// BUS_CNTL1
+#define BUS_CNTL1__PMI_IO_DISABLE_MASK                     0x00000001L
+#define BUS_CNTL1__PMI_IO_DISABLE                          0x00000001L
+#define BUS_CNTL1__PMI_MEM_DISABLE_MASK                    0x00000002L
+#define BUS_CNTL1__PMI_MEM_DISABLE                         0x00000002L
+#define BUS_CNTL1__PMI_BM_DISABLE_MASK                     0x00000004L
+#define BUS_CNTL1__PMI_BM_DISABLE                          0x00000004L
+#define BUS_CNTL1__PMI_INT_DISABLE_MASK                    0x00000008L
+#define BUS_CNTL1__PMI_INT_DISABLE                         0x00000008L
+#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE_MASK         0x00000020L
+#define BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE              0x00000020L
+#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS_MASK         0x00000100L
+#define BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS              0x00000100L
+#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS_MASK         0x00000200L
+#define BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS              0x00000200L
+#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS_MASK         0x00000400L
+#define BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS              0x00000400L
+#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS_MASK   0x00000800L
+#define BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS        0x00000800L
+#define BUS_CNTL1__MOBILE_PLATFORM_SEL_MASK                0x0c000000L
+#define BUS_CNTL1__SEND_SBA_LATENCY_MASK                   0x70000000L
+#define BUS_CNTL1__AGPCLK_VALID_MASK                       0x80000000L
+#define BUS_CNTL1__AGPCLK_VALID                            0x80000000L
+
+// BUS_CNTL1
+#define	BUS_CNTL1__PMI_IO_DISABLE__SHIFT                   0x00000000
+#define	BUS_CNTL1__PMI_MEM_DISABLE__SHIFT                  0x00000001
+#define	BUS_CNTL1__PMI_BM_DISABLE__SHIFT                   0x00000002
+#define	BUS_CNTL1__PMI_INT_DISABLE__SHIFT                  0x00000003
+#define	BUS_CNTL1__BUS2_IMMEDIATE_PMI_DISABLE__SHIFT       0x00000005
+#define	BUS_CNTL1__BUS2_VGA_REG_COHERENCY_DIS__SHIFT       0x00000008
+#define	BUS_CNTL1__BUS2_VGA_MEM_COHERENCY_DIS__SHIFT       0x00000009
+#define	BUS_CNTL1__BUS2_HDP_REG_COHERENCY_DIS__SHIFT       0x0000000a
+#define	BUS_CNTL1__BUS2_GUI_INITIATOR_COHERENCY_DIS__SHIFT 0x0000000b
+#define	BUS_CNTL1__MOBILE_PLATFORM_SEL__SHIFT              0x0000001a
+#define	BUS_CNTL1__SEND_SBA_LATENCY__SHIFT                 0x0000001c
+#define	BUS_CNTL1__AGPCLK_VALID__SHIFT                     0x0000001f
+
+// CRTC_OFFSET_CNTL
+#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_MASK              0x0000000fL
+#define CRTC_OFFSET_CNTL__CRTC_TILE_LINE_RIGHT_MASK        0x000000f0L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT_MASK          0x00004000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_RIGHT               0x00004000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN_MASK                0x00008000L
+#define CRTC_OFFSET_CNTL__CRTC_TILE_EN                     0x00008000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL_MASK       0x00010000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_FLIP_CNTL            0x00010000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN_MASK       0x00020000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_OFFSET_EN            0x00020000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_EN_MASK         0x000c0000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN_MASK     0x00100000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_OUT_EN          0x00100000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC_MASK            0x00200000L
+#define CRTC_OFFSET_CNTL__CRTC_STEREO_SYNC                 0x00200000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN_MASK 0x10000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_LEFT_EN     0x10000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN_MASK 0x20000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_RIGHT_EN    0x20000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET_MASK        0x40000000L
+#define CRTC_OFFSET_CNTL__CRTC_GUI_TRIG_OFFSET             0x40000000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK_MASK            0x80000000L
+#define CRTC_OFFSET_CNTL__CRTC_OFFSET_LOCK                 0x80000000L
+
+// CRTC_GEN_CNTL
+#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN_MASK               0x00000001L
+#define CRTC_GEN_CNTL__CRTC_DBL_SCAN_EN                    0x00000001L
+#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN_MASK              0x00000002L
+#define CRTC_GEN_CNTL__CRTC_INTERLACE_EN                   0x00000002L
+#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN_MASK                 0x00000010L
+#define CRTC_GEN_CNTL__CRTC_C_SYNC_EN                      0x00000010L
+#define CRTC_GEN_CNTL__CRTC_PIX_WIDTH_MASK                 0x00000f00L
+#define CRTC_GEN_CNTL__CRTC_ICON_EN_MASK                   0x00008000L
+#define CRTC_GEN_CNTL__CRTC_ICON_EN                        0x00008000L
+#define CRTC_GEN_CNTL__CRTC_CUR_EN_MASK                    0x00010000L
+#define CRTC_GEN_CNTL__CRTC_CUR_EN                         0x00010000L
+#define CRTC_GEN_CNTL__CRTC_VSTAT_MODE_MASK                0x00060000L
+#define CRTC_GEN_CNTL__CRTC_CUR_MODE_MASK                  0x00700000L
+#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN_MASK               0x01000000L
+#define CRTC_GEN_CNTL__CRTC_EXT_DISP_EN                    0x01000000L
+#define CRTC_GEN_CNTL__CRTC_EN_MASK                        0x02000000L
+#define CRTC_GEN_CNTL__CRTC_EN                             0x02000000L
+#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B_MASK             0x04000000L
+#define CRTC_GEN_CNTL__CRTC_DISP_REQ_EN_B                  0x04000000L
+
+// CRTC2_GEN_CNTL
+#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN_MASK             0x00000001L
+#define CRTC2_GEN_CNTL__CRTC2_DBL_SCAN_EN                  0x00000001L
+#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN_MASK            0x00000002L
+#define CRTC2_GEN_CNTL__CRTC2_INTERLACE_EN                 0x00000002L
+#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE_MASK           0x00000010L
+#define CRTC2_GEN_CNTL__CRTC2_SYNC_TRISTATE                0x00000010L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE_MASK          0x00000020L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_TRISTATE               0x00000020L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE_MASK          0x00000040L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_TRISTATE               0x00000040L
+#define CRTC2_GEN_CNTL__CRT2_ON_MASK                       0x00000080L
+#define CRTC2_GEN_CNTL__CRT2_ON                            0x00000080L
+#define CRTC2_GEN_CNTL__CRTC2_PIX_WIDTH_MASK               0x00000f00L
+#define CRTC2_GEN_CNTL__CRTC2_ICON_EN_MASK                 0x00008000L
+#define CRTC2_GEN_CNTL__CRTC2_ICON_EN                      0x00008000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_EN_MASK                  0x00010000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_EN                       0x00010000L
+#define CRTC2_GEN_CNTL__CRTC2_CUR_MODE_MASK                0x00700000L
+#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS_MASK             0x00800000L
+#define CRTC2_GEN_CNTL__CRTC2_DISPLAY_DIS                  0x00800000L
+#define CRTC2_GEN_CNTL__CRTC2_EN_MASK                      0x02000000L
+#define CRTC2_GEN_CNTL__CRTC2_EN                           0x02000000L
+#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B_MASK           0x04000000L
+#define CRTC2_GEN_CNTL__CRTC2_DISP_REQ_EN_B                0x04000000L
+#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN_MASK               0x08000000L
+#define CRTC2_GEN_CNTL__CRTC2_C_SYNC_EN                    0x08000000L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS_MASK               0x10000000L
+#define CRTC2_GEN_CNTL__CRTC2_HSYNC_DIS                    0x10000000L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS_MASK               0x20000000L
+#define CRTC2_GEN_CNTL__CRTC2_VSYNC_DIS                    0x20000000L
+
+// AGP_CNTL
+#define AGP_CNTL__MAX_IDLE_CLK_MASK                        0x000000ffL
+#define AGP_CNTL__HOLD_RD_FIFO_MASK                        0x00000100L
+#define AGP_CNTL__HOLD_RD_FIFO                             0x00000100L
+#define AGP_CNTL__HOLD_RQ_FIFO_MASK                        0x00000200L
+#define AGP_CNTL__HOLD_RQ_FIFO                             0x00000200L
+#define AGP_CNTL__EN_2X_STBB_MASK                          0x00000400L
+#define AGP_CNTL__EN_2X_STBB                               0x00000400L
+#define AGP_CNTL__FORCE_FULL_SBA_MASK                      0x00000800L
+#define AGP_CNTL__FORCE_FULL_SBA                           0x00000800L
+#define AGP_CNTL__SBA_DIS_MASK                             0x00001000L
+#define AGP_CNTL__SBA_DIS                                  0x00001000L
+#define AGP_CNTL__AGP_REV_ID_MASK                          0x00002000L
+#define AGP_CNTL__AGP_REV_ID                               0x00002000L
+#define AGP_CNTL__REG_CRIPPLE_AGP4X_MASK                   0x00004000L
+#define AGP_CNTL__REG_CRIPPLE_AGP4X                        0x00004000L
+#define AGP_CNTL__REG_CRIPPLE_AGP2X4X_MASK                 0x00008000L
+#define AGP_CNTL__REG_CRIPPLE_AGP2X4X                      0x00008000L
+#define AGP_CNTL__FORCE_INT_VREF_MASK                      0x00010000L
+#define AGP_CNTL__FORCE_INT_VREF                           0x00010000L
+#define AGP_CNTL__PENDING_SLOTS_VAL_MASK                   0x00060000L
+#define AGP_CNTL__PENDING_SLOTS_SEL_MASK                   0x00080000L
+#define AGP_CNTL__PENDING_SLOTS_SEL                        0x00080000L
+#define AGP_CNTL__EN_EXTENDED_AD_STB_2X_MASK               0x00100000L
+#define AGP_CNTL__EN_EXTENDED_AD_STB_2X                    0x00100000L
+#define AGP_CNTL__DIS_QUEUED_GNT_FIX_MASK                  0x00200000L
+#define AGP_CNTL__DIS_QUEUED_GNT_FIX                       0x00200000L
+#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET_MASK             0x00400000L
+#define AGP_CNTL__EN_RDATA2X4X_MULTIRESET                  0x00400000L
+#define AGP_CNTL__EN_RBFCALM_MASK                          0x00800000L
+#define AGP_CNTL__EN_RBFCALM                               0x00800000L
+#define AGP_CNTL__FORCE_EXT_VREF_MASK                      0x01000000L
+#define AGP_CNTL__FORCE_EXT_VREF                           0x01000000L
+#define AGP_CNTL__DIS_RBF_MASK                             0x02000000L
+#define AGP_CNTL__DIS_RBF                                  0x02000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_EN_MASK                  0x04000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_EN                       0x04000000L
+#define AGP_CNTL__DELAY_FIRST_SBA_VAL_MASK                 0x38000000L
+#define AGP_CNTL__AGP_MISC_MASK                            0xc0000000L
+
+// AGP_CNTL
+#define	AGP_CNTL__MAX_IDLE_CLK__SHIFT                      0x00000000
+#define	AGP_CNTL__HOLD_RD_FIFO__SHIFT                      0x00000008
+#define	AGP_CNTL__HOLD_RQ_FIFO__SHIFT                      0x00000009
+#define	AGP_CNTL__EN_2X_STBB__SHIFT                        0x0000000a
+#define	AGP_CNTL__FORCE_FULL_SBA__SHIFT                    0x0000000b
+#define	AGP_CNTL__SBA_DIS__SHIFT                           0x0000000c
+#define	AGP_CNTL__AGP_REV_ID__SHIFT                        0x0000000d
+#define	AGP_CNTL__REG_CRIPPLE_AGP4X__SHIFT                 0x0000000e
+#define	AGP_CNTL__REG_CRIPPLE_AGP2X4X__SHIFT               0x0000000f
+#define	AGP_CNTL__FORCE_INT_VREF__SHIFT                    0x00000010
+#define	AGP_CNTL__PENDING_SLOTS_VAL__SHIFT                 0x00000011
+#define	AGP_CNTL__PENDING_SLOTS_SEL__SHIFT                 0x00000013
+#define	AGP_CNTL__EN_EXTENDED_AD_STB_2X__SHIFT             0x00000014
+#define	AGP_CNTL__DIS_QUEUED_GNT_FIX__SHIFT                0x00000015
+#define	AGP_CNTL__EN_RDATA2X4X_MULTIRESET__SHIFT           0x00000016
+#define	AGP_CNTL__EN_RBFCALM__SHIFT                        0x00000017
+#define	AGP_CNTL__FORCE_EXT_VREF__SHIFT                    0x00000018
+#define	AGP_CNTL__DIS_RBF__SHIFT                           0x00000019
+#define	AGP_CNTL__DELAY_FIRST_SBA_EN__SHIFT                0x0000001a
+#define	AGP_CNTL__DELAY_FIRST_SBA_VAL__SHIFT               0x0000001b
+#define	AGP_CNTL__AGP_MISC__SHIFT                          0x0000001e
+
+// DISP_MISC_CNTL
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP_MASK            0x00000001L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_PP                 0x00000001L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP_MASK          0x00000002L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_PP               0x00000002L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP_MASK             0x00000004L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_PP                  0x00000004L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK_MASK          0x00000010L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH_SCLK               0x00000010L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK_MASK        0x00000020L
+#define DISP_MISC_CNTL__SOFT_RESET_SUBPIC_SCLK             0x00000020L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK_MASK           0x00000040L
+#define DISP_MISC_CNTL__SOFT_RESET_OV0_SCLK                0x00000040L
+#define DISP_MISC_CNTL__SYNC_STRENGTH_MASK                 0x00000300L
+#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN_MASK              0x00000400L
+#define DISP_MISC_CNTL__SYNC_PAD_FLOP_EN                   0x00000400L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP_MASK           0x00001000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_PP                0x00001000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK_MASK         0x00008000L
+#define DISP_MISC_CNTL__SOFT_RESET_GRPH2_SCLK              0x00008000L
+#define DISP_MISC_CNTL__SOFT_RESET_LVDS_MASK               0x00010000L
+#define DISP_MISC_CNTL__SOFT_RESET_LVDS                    0x00010000L
+#define DISP_MISC_CNTL__SOFT_RESET_TMDS_MASK               0x00020000L
+#define DISP_MISC_CNTL__SOFT_RESET_TMDS                    0x00020000L
+#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS_MASK           0x00040000L
+#define DISP_MISC_CNTL__SOFT_RESET_DIG_TMDS                0x00040000L
+#define DISP_MISC_CNTL__SOFT_RESET_TV_MASK                 0x00080000L
+#define DISP_MISC_CNTL__SOFT_RESET_TV                      0x00080000L
+#define DISP_MISC_CNTL__PALETTE2_MEM_RD_MARGIN_MASK        0x00f00000L
+#define DISP_MISC_CNTL__PALETTE_MEM_RD_MARGIN_MASK         0x0f000000L
+#define DISP_MISC_CNTL__RMX_BUF_MEM_RD_MARGIN_MASK         0xf0000000L
+
+// DISP_PWR_MAN
+#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN_MASK         0x00000001L
+#define DISP_PWR_MAN__DISP_PWR_MAN_D3_CRTC_EN              0x00000001L
+#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN_MASK       0x00000010L
+#define DISP_PWR_MAN__DISP2_PWR_MAN_D3_CRTC2_EN            0x00000010L
+#define DISP_PWR_MAN__DISP_PWR_MAN_DPMS_MASK               0x00000300L
+#define DISP_PWR_MAN__DISP_D3_RST_MASK                     0x00010000L
+#define DISP_PWR_MAN__DISP_D3_RST                          0x00010000L
+#define DISP_PWR_MAN__DISP_D3_REG_RST_MASK                 0x00020000L
+#define DISP_PWR_MAN__DISP_D3_REG_RST                      0x00020000L
+#define DISP_PWR_MAN__DISP_D3_GRPH_RST_MASK                0x00040000L
+#define DISP_PWR_MAN__DISP_D3_GRPH_RST                     0x00040000L
+#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST_MASK              0x00080000L
+#define DISP_PWR_MAN__DISP_D3_SUBPIC_RST                   0x00080000L
+#define DISP_PWR_MAN__DISP_D3_OV0_RST_MASK                 0x00100000L
+#define DISP_PWR_MAN__DISP_D3_OV0_RST                      0x00100000L
+#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST_MASK              0x00200000L
+#define DISP_PWR_MAN__DISP_D1D2_GRPH_RST                   0x00200000L
+#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST_MASK            0x00400000L
+#define DISP_PWR_MAN__DISP_D1D2_SUBPIC_RST                 0x00400000L
+#define DISP_PWR_MAN__DISP_D1D2_OV0_RST_MASK               0x00800000L
+#define DISP_PWR_MAN__DISP_D1D2_OV0_RST                    0x00800000L
+#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST_MASK             0x01000000L
+#define DISP_PWR_MAN__DIG_TMDS_ENABLE_RST                  0x01000000L
+#define DISP_PWR_MAN__TV_ENABLE_RST_MASK                   0x02000000L
+#define DISP_PWR_MAN__TV_ENABLE_RST                        0x02000000L
+#define DISP_PWR_MAN__AUTO_PWRUP_EN_MASK                   0x04000000L
+#define DISP_PWR_MAN__AUTO_PWRUP_EN                        0x04000000L
+
+// MC_IND_INDEX
+#define MC_IND_INDEX__MC_IND_ADDR_MASK                     0x0000001fL
+#define MC_IND_INDEX__MC_IND_WR_EN_MASK                    0x00000100L
+#define MC_IND_INDEX__MC_IND_WR_EN                         0x00000100L
+
+// MC_IND_DATA
+#define MC_IND_DATA__MC_IND_DATA_MASK                      0xffffffffL
+
+// MC_CHP_IO_CNTL_A1
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA__SHIFT            0x00000000
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA__SHIFT             0x00000001
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA__SHIFT           0x00000002
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA__SHIFT           0x00000003
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA__SHIFT            0x00000004
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA__SHIFT             0x00000005
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA__SHIFT           0x00000006
+#define	MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA__SHIFT           0x00000007
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA__SHIFT            0x00000008
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA__SHIFT          0x00000009
+#define	MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA__SHIFT          0x0000000a
+#define	MC_CHP_IO_CNTL_A1__MEM_IO_MODEA__SHIFT             0x0000000c
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_CKA__SHIFT              0x0000000e
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_AA__SHIFT               0x00000010
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQMA__SHIFT             0x00000012
+#define	MC_CHP_IO_CNTL_A1__MEM_REC_DQSA__SHIFT             0x00000014
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA__SHIFT          0x00000016
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA__SHIFT         0x00000017
+#define	MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA__SHIFT             0x00000018
+#define	MC_CHP_IO_CNTL_A1__MEM_CLK_SELA__SHIFT             0x0000001a
+#define	MC_CHP_IO_CNTL_A1__MEM_CLK_INVA__SHIFT             0x0000001c
+#define	MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A__SHIFT         0x0000001e
+#define	MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A__SHIFT         0x0000001f
+
+// MC_CHP_IO_CNTL_B1
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB__SHIFT            0x00000000
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB__SHIFT             0x00000001
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB__SHIFT           0x00000002
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB__SHIFT           0x00000003
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB__SHIFT            0x00000004
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB__SHIFT             0x00000005
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB__SHIFT           0x00000006
+#define	MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB__SHIFT           0x00000007
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB__SHIFT            0x00000008
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB__SHIFT          0x00000009
+#define	MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB__SHIFT          0x0000000a
+#define	MC_CHP_IO_CNTL_B1__MEM_IO_MODEB__SHIFT             0x0000000c
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_CKB__SHIFT              0x0000000e
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_AB__SHIFT               0x00000010
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQMB__SHIFT             0x00000012
+#define	MC_CHP_IO_CNTL_B1__MEM_REC_DQSB__SHIFT             0x00000014
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB__SHIFT          0x00000016
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB__SHIFT         0x00000017
+#define	MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB__SHIFT             0x00000018
+#define	MC_CHP_IO_CNTL_B1__MEM_CLK_SELB__SHIFT             0x0000001a
+#define	MC_CHP_IO_CNTL_B1__MEM_CLK_INVB__SHIFT             0x0000001c
+#define	MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B__SHIFT         0x0000001e
+#define	MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B__SHIFT         0x0000001f
+
+// MC_CHP_IO_CNTL_A1
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA_MASK              0x00000001L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_CKA                   0x00000001L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA_MASK               0x00000002L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_AA                    0x00000002L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA_MASK             0x00000004L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQMA                  0x00000004L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA_MASK             0x00000008L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWN_DQSA                  0x00000008L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA_MASK              0x00000010L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_CKA                   0x00000010L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA_MASK               0x00000020L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_AA                    0x00000020L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA_MASK             0x00000040L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQMA                  0x00000040L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA_MASK             0x00000080L
+#define MC_CHP_IO_CNTL_A1__MEM_SLEWP_DQSA                  0x00000080L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA_MASK              0x00000100L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_AA                   0x00000100L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA_MASK            0x00000200L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQMA                 0x00000200L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA_MASK            0x00000400L
+#define MC_CHP_IO_CNTL_A1__MEM_PREAMP_DQSA                 0x00000400L
+#define MC_CHP_IO_CNTL_A1__MEM_IO_MODEA_MASK               0x00003000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_CKA_MASK                0x0000c000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_AA_MASK                 0x00030000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_DQMA_MASK               0x000c0000L
+#define MC_CHP_IO_CNTL_A1__MEM_REC_DQSA_MASK               0x00300000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA_MASK            0x00400000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_PHASEA                 0x00400000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA_MASK           0x00800000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_CENTERA                0x00800000L
+#define MC_CHP_IO_CNTL_A1__MEM_SYNC_ENA_MASK               0x03000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_SELA_MASK               0x0c000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA_MASK               0x10000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CLK_INVA                    0x10000000L
+#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A_MASK           0x40000000L
+#define MC_CHP_IO_CNTL_A1__MEM_DATA_ENIMP_A                0x40000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A_MASK           0x80000000L
+#define MC_CHP_IO_CNTL_A1__MEM_CNTL_ENIMP_A                0x80000000L
+
+// MC_CHP_IO_CNTL_B1
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB_MASK              0x00000001L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_CKB                   0x00000001L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB_MASK               0x00000002L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_AB                    0x00000002L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB_MASK             0x00000004L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQMB                  0x00000004L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB_MASK             0x00000008L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWN_DQSB                  0x00000008L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB_MASK              0x00000010L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_CKB                   0x00000010L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB_MASK               0x00000020L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_AB                    0x00000020L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB_MASK             0x00000040L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQMB                  0x00000040L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB_MASK             0x00000080L
+#define MC_CHP_IO_CNTL_B1__MEM_SLEWP_DQSB                  0x00000080L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB_MASK              0x00000100L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_AB                   0x00000100L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB_MASK            0x00000200L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQMB                 0x00000200L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB_MASK            0x00000400L
+#define MC_CHP_IO_CNTL_B1__MEM_PREAMP_DQSB                 0x00000400L
+#define MC_CHP_IO_CNTL_B1__MEM_IO_MODEB_MASK               0x00003000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_CKB_MASK                0x0000c000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_AB_MASK                 0x00030000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_DQMB_MASK               0x000c0000L
+#define MC_CHP_IO_CNTL_B1__MEM_REC_DQSB_MASK               0x00300000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB_MASK            0x00400000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_PHASEB                 0x00400000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB_MASK           0x00800000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_CENTERB                0x00800000L
+#define MC_CHP_IO_CNTL_B1__MEM_SYNC_ENB_MASK               0x03000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_SELB_MASK               0x0c000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB_MASK               0x10000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CLK_INVB                    0x10000000L
+#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B_MASK           0x40000000L
+#define MC_CHP_IO_CNTL_B1__MEM_DATA_ENIMP_B                0x40000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B_MASK           0x80000000L
+#define MC_CHP_IO_CNTL_B1__MEM_CNTL_ENIMP_B                0x80000000L
+
+// MEM_SDRAM_MODE_REG
+#define MEM_SDRAM_MODE_REG__MEM_MODE_REG_MASK              0x00007fffL
+#define MEM_SDRAM_MODE_REG__MEM_WR_LATENCY_MASK            0x000f0000L
+#define MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY_MASK           0x00700000L
+#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY_MASK           0x00800000L
+#define MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY                0x00800000L
+#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY_MASK           0x01000000L
+#define MEM_SDRAM_MODE_REG__MEM_STR_LATENCY                0x01000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD_MASK          0x02000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD               0x02000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA_MASK         0x04000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA              0x04000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR_MASK          0x08000000L
+#define MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR               0x08000000L
+#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE_MASK          0x10000000L
+#define MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE               0x10000000L
+#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL_MASK               0x20000000L
+#define MEM_SDRAM_MODE_REG__MEM_DDR_DLL                    0x20000000L
+#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE_MASK              0x40000000L
+#define MEM_SDRAM_MODE_REG__MEM_CFG_TYPE                   0x40000000L
+#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET_MASK           0x80000000L
+#define MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET                0x80000000L
+
+// MEM_SDRAM_MODE_REG
+#define	MEM_SDRAM_MODE_REG__MEM_MODE_REG__SHIFT            0x00000000
+#define	MEM_SDRAM_MODE_REG__MEM_WR_LATENCY__SHIFT          0x00000010
+#define	MEM_SDRAM_MODE_REG__MEM_CAS_LATENCY__SHIFT         0x00000014
+#define	MEM_SDRAM_MODE_REG__MEM_CMD_LATENCY__SHIFT         0x00000017
+#define	MEM_SDRAM_MODE_REG__MEM_STR_LATENCY__SHIFT         0x00000018
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_CMD__SHIFT        0x00000019
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_DATA__SHIFT       0x0000001a
+#define	MEM_SDRAM_MODE_REG__MEM_FALL_OUT_STR__SHIFT        0x0000001b
+#define	MEM_SDRAM_MODE_REG__MC_INIT_COMPLETE__SHIFT        0x0000001c
+#define	MEM_SDRAM_MODE_REG__MEM_DDR_DLL__SHIFT             0x0000001d
+#define	MEM_SDRAM_MODE_REG__MEM_CFG_TYPE__SHIFT            0x0000001e
+#define	MEM_SDRAM_MODE_REG__MEM_SDRAM_RESET__SHIFT         0x0000001f
+
+// MEM_REFRESH_CNTL
+#define MEM_REFRESH_CNTL__MEM_REFRESH_RATE_MASK            0x000000ffL
+#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS_MASK             0x00000100L
+#define MEM_REFRESH_CNTL__MEM_REFRESH_DIS                  0x00000100L
+#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE_MASK             0x00000200L
+#define MEM_REFRESH_CNTL__MEM_DYNAMIC_CKE                  0x00000200L
+#define MEM_REFRESH_CNTL__MEM_TRFC_MASK                    0x0000f000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE_MASK            0x00010000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0_ENABLE                 0x00010000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE_MASK           0x00020000L
+#define MEM_REFRESH_CNTL__MEM_CLKA0b_ENABLE                0x00020000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE_MASK            0x00040000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1_ENABLE                 0x00040000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE_MASK           0x00080000L
+#define MEM_REFRESH_CNTL__MEM_CLKA1b_ENABLE                0x00080000L
+#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE_MASK           0x00100000L
+#define MEM_REFRESH_CNTL__MEM_CLKAFB_ENABLE                0x00100000L
+#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKA_MASK             0x00c00000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE_MASK            0x01000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0_ENABLE                 0x01000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE_MASK           0x02000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB0b_ENABLE                0x02000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE_MASK            0x04000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1_ENABLE                 0x04000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE_MASK           0x08000000L
+#define MEM_REFRESH_CNTL__MEM_CLKB1b_ENABLE                0x08000000L
+#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE_MASK           0x10000000L
+#define MEM_REFRESH_CNTL__MEM_CLKBFB_ENABLE                0x10000000L
+#define MEM_REFRESH_CNTL__DLL_FB_SLCT_CKB_MASK             0xc0000000L
+
+// MC_STATUS
+#define MC_STATUS__MEM_PWRUP_COMPL_A_MASK                  0x00000001L
+#define MC_STATUS__MEM_PWRUP_COMPL_A                       0x00000001L
+#define MC_STATUS__MEM_PWRUP_COMPL_B_MASK                  0x00000002L
+#define MC_STATUS__MEM_PWRUP_COMPL_B                       0x00000002L
+#define MC_STATUS__MC_IDLE_MASK                            0x00000004L
+#define MC_STATUS__MC_IDLE                                 0x00000004L
+#define MC_STATUS__IMP_N_VALUE_R_BACK_MASK                 0x00000078L
+#define MC_STATUS__IMP_P_VALUE_R_BACK_MASK                 0x00000780L
+#define MC_STATUS__TEST_OUT_R_BACK_MASK                    0x00000800L
+#define MC_STATUS__TEST_OUT_R_BACK                         0x00000800L
+#define MC_STATUS__DUMMY_OUT_R_BACK_MASK                   0x00001000L
+#define MC_STATUS__DUMMY_OUT_R_BACK                        0x00001000L
+#define MC_STATUS__IMP_N_VALUE_A_R_BACK_MASK               0x0001e000L
+#define MC_STATUS__IMP_P_VALUE_A_R_BACK_MASK               0x001e0000L
+#define MC_STATUS__IMP_N_VALUE_CK_R_BACK_MASK              0x01e00000L
+#define MC_STATUS__IMP_P_VALUE_CK_R_BACK_MASK              0x1e000000L
+
+// MDLL_CKO
+#define MDLL_CKO__MCKOA_SLEEP_MASK                         0x00000001L
+#define MDLL_CKO__MCKOA_SLEEP                              0x00000001L
+#define MDLL_CKO__MCKOA_RESET_MASK                         0x00000002L
+#define MDLL_CKO__MCKOA_RESET                              0x00000002L
+#define MDLL_CKO__MCKOA_RANGE_MASK                         0x0000000cL
+#define MDLL_CKO__ERSTA_SOUTSEL_MASK                       0x00000030L
+#define MDLL_CKO__MCKOA_FB_SEL_MASK                        0x000000c0L
+#define MDLL_CKO__MCKOA_REF_SKEW_MASK                      0x00000700L
+#define MDLL_CKO__MCKOA_FB_SKEW_MASK                       0x00007000L
+#define MDLL_CKO__MCKOA_BP_SEL_MASK                        0x00008000L
+#define MDLL_CKO__MCKOA_BP_SEL                             0x00008000L
+#define MDLL_CKO__MCKOB_SLEEP_MASK                         0x00010000L
+#define MDLL_CKO__MCKOB_SLEEP                              0x00010000L
+#define MDLL_CKO__MCKOB_RESET_MASK                         0x00020000L
+#define MDLL_CKO__MCKOB_RESET                              0x00020000L
+#define MDLL_CKO__MCKOB_RANGE_MASK                         0x000c0000L
+#define MDLL_CKO__ERSTB_SOUTSEL_MASK                       0x00300000L
+#define MDLL_CKO__MCKOB_FB_SEL_MASK                        0x00c00000L
+#define MDLL_CKO__MCKOB_REF_SKEW_MASK                      0x07000000L
+#define MDLL_CKO__MCKOB_FB_SKEW_MASK                       0x70000000L
+#define MDLL_CKO__MCKOB_BP_SEL_MASK                        0x80000000L
+#define MDLL_CKO__MCKOB_BP_SEL                             0x80000000L
+
+// MDLL_RDCKA
+#define MDLL_RDCKA__MRDCKA0_SLEEP_MASK                     0x00000001L
+#define MDLL_RDCKA__MRDCKA0_SLEEP                          0x00000001L
+#define MDLL_RDCKA__MRDCKA0_RESET_MASK                     0x00000002L
+#define MDLL_RDCKA__MRDCKA0_RESET                          0x00000002L
+#define MDLL_RDCKA__MRDCKA0_RANGE_MASK                     0x0000000cL
+#define MDLL_RDCKA__MRDCKA0_REF_SEL_MASK                   0x00000030L
+#define MDLL_RDCKA__MRDCKA0_FB_SEL_MASK                    0x000000c0L
+#define MDLL_RDCKA__MRDCKA0_REF_SKEW_MASK                  0x00000700L
+#define MDLL_RDCKA__MRDCKA0_SINSEL_MASK                    0x00000800L
+#define MDLL_RDCKA__MRDCKA0_SINSEL                         0x00000800L
+#define MDLL_RDCKA__MRDCKA0_FB_SKEW_MASK                   0x00007000L
+#define MDLL_RDCKA__MRDCKA0_BP_SEL_MASK                    0x00008000L
+#define MDLL_RDCKA__MRDCKA0_BP_SEL                         0x00008000L
+#define MDLL_RDCKA__MRDCKA1_SLEEP_MASK                     0x00010000L
+#define MDLL_RDCKA__MRDCKA1_SLEEP                          0x00010000L
+#define MDLL_RDCKA__MRDCKA1_RESET_MASK                     0x00020000L
+#define MDLL_RDCKA__MRDCKA1_RESET                          0x00020000L
+#define MDLL_RDCKA__MRDCKA1_RANGE_MASK                     0x000c0000L
+#define MDLL_RDCKA__MRDCKA1_REF_SEL_MASK                   0x00300000L
+#define MDLL_RDCKA__MRDCKA1_FB_SEL_MASK                    0x00c00000L
+#define MDLL_RDCKA__MRDCKA1_REF_SKEW_MASK                  0x07000000L
+#define MDLL_RDCKA__MRDCKA1_SINSEL_MASK                    0x08000000L
+#define MDLL_RDCKA__MRDCKA1_SINSEL                         0x08000000L
+#define MDLL_RDCKA__MRDCKA1_FB_SKEW_MASK                   0x70000000L
+#define MDLL_RDCKA__MRDCKA1_BP_SEL_MASK                    0x80000000L
+#define MDLL_RDCKA__MRDCKA1_BP_SEL                         0x80000000L
+
+// MDLL_RDCKB
+#define MDLL_RDCKB__MRDCKB0_SLEEP_MASK                     0x00000001L
+#define MDLL_RDCKB__MRDCKB0_SLEEP                          0x00000001L
+#define MDLL_RDCKB__MRDCKB0_RESET_MASK                     0x00000002L
+#define MDLL_RDCKB__MRDCKB0_RESET                          0x00000002L
+#define MDLL_RDCKB__MRDCKB0_RANGE_MASK                     0x0000000cL
+#define MDLL_RDCKB__MRDCKB0_REF_SEL_MASK                   0x00000030L
+#define MDLL_RDCKB__MRDCKB0_FB_SEL_MASK                    0x000000c0L
+#define MDLL_RDCKB__MRDCKB0_REF_SKEW_MASK                  0x00000700L
+#define MDLL_RDCKB__MRDCKB0_SINSEL_MASK                    0x00000800L
+#define MDLL_RDCKB__MRDCKB0_SINSEL                         0x00000800L
+#define MDLL_RDCKB__MRDCKB0_FB_SKEW_MASK                   0x00007000L
+#define MDLL_RDCKB__MRDCKB0_BP_SEL_MASK                    0x00008000L
+#define MDLL_RDCKB__MRDCKB0_BP_SEL                         0x00008000L
+#define MDLL_RDCKB__MRDCKB1_SLEEP_MASK                     0x00010000L
+#define MDLL_RDCKB__MRDCKB1_SLEEP                          0x00010000L
+#define MDLL_RDCKB__MRDCKB1_RESET_MASK                     0x00020000L
+#define MDLL_RDCKB__MRDCKB1_RESET                          0x00020000L
+#define MDLL_RDCKB__MRDCKB1_RANGE_MASK                     0x000c0000L
+#define MDLL_RDCKB__MRDCKB1_REF_SEL_MASK                   0x00300000L
+#define MDLL_RDCKB__MRDCKB1_FB_SEL_MASK                    0x00c00000L
+#define MDLL_RDCKB__MRDCKB1_REF_SKEW_MASK                  0x07000000L
+#define MDLL_RDCKB__MRDCKB1_SINSEL_MASK                    0x08000000L
+#define MDLL_RDCKB__MRDCKB1_SINSEL                         0x08000000L
+#define MDLL_RDCKB__MRDCKB1_FB_SKEW_MASK                   0x70000000L
+#define MDLL_RDCKB__MRDCKB1_BP_SEL_MASK                    0x80000000L
+#define MDLL_RDCKB__MRDCKB1_BP_SEL                         0x80000000L
+
+#define pllVCLK_ECP_CNTL                            0x0008
+#define pllDISP_TEST_MACRO_RW_WRITE                 0x001A
+#define pllDISP_TEST_MACRO_RW_READ                  0x001B
+#define pllDISP_TEST_MACRO_RW_DATA                  0x001C
+#define pllDISP_TEST_MACRO_RW_CNTL                  0x001D
+#define pllPIXCLKS_CNTL                             0x002D
+#define pllPPLL_DIV_0                               0x0004
+#define pllPPLL_DIV_1                               0x0005
+#define pllPPLL_DIV_2                               0x0006
+#define pllPPLL_DIV_3                               0x0007
+#define pllHTOTAL_CNTL                              0x0009
+#define pllPLL_TEST_CNTL_M6                         0x0013
+#define pllP2PLL_DIV_0                              0x002C
+#define pllHTOTAL2_CNTL                             0x002E
+#define pllCLK_PIN_CNTL                             0x0001
+#define pllPPLL_CNTL                                0x0002
+#define pllPPLL_REF_DIV                             0x0003
+#define pllSPLL_CNTL                                0x000C
+#define pllSPLL_AUX_CNTL                            0x0024
+#define pllSCLK_CNTL_M6                             0x000D
+#define pllAGP_PLL_CNTL                             0x000B
+#define pllTV_PLL_FINE_CNTL                         0x0020
+#define pllTV_PLL_CNTL                              0x0021
+#define pllTV_PLL_CNTL1                             0x0022
+#define pllTV_DTO_INCREMENTS                        0x0023
+#define pllP2PLL_CNTL                               0x002A
+#define pllP2PLL_REF_DIV                            0x002B
+#define pllSSPLL_CNTL                               0x0030
+#define pllSSPLL_REF_DIV                            0x0031
+#define pllSSPLL_DIV_0                              0x0032
+#define pllSS_INT_CNTL                              0x0033
+#define pllSS_TST_CNTL                              0x0034
+#define pllSCLK_MORE_CNTL                           0x0035
+#define pllCLK_PWRMGT_CNTL_M6                       0x0014
+#define pllPLL_PWRMGT_CNTL                          0x0015
+#define pllM_SPLL_REF_FB_DIV                        0x000A
+#define pllMPLL_CNTL                                0x000E
+#define pllMPLL_AUX_CNTL                            0x0025
+#define pllMDLL_CKO                                 0x000F
+#define pllMDLL_RDCKA                               0x0010
+#define pllMDLL_RDCKB                               0x0011
+#define pllMCLK_CNTL_M6                             0x0012
+#define pllMCLK_MISC                                0x001F
+#define pllCG_TEST_MACRO_RW_WRITE                   0x0016
+#define pllCG_TEST_MACRO_RW_READ                    0x0017
+#define pllCG_TEST_MACRO_RW_DATA                    0x0018
+#define pllCG_TEST_MACRO_RW_CNTL                    0x0019
+
+#define ixMC_PERF_CNTL                             0x0000
+#define ixMC_PERF_SEL                              0x0001
+#define ixMC_PERF_REGION_0                         0x0002
+#define ixMC_PERF_REGION_1                         0x0003
+#define ixMC_PERF_COUNT_0                          0x0004
+#define ixMC_PERF_COUNT_1                          0x0005
+#define ixMC_PERF_COUNT_2                          0x0006
+#define ixMC_PERF_COUNT_3                          0x0007
+#define ixMC_PERF_COUNT_MEMCH_A                    0x0008
+#define ixMC_PERF_COUNT_MEMCH_B                    0x0009
+#define ixMC_IMP_CNTL                              0x000A
+#define ixMC_CHP_IO_CNTL_A0                        0x000B
+#define ixMC_CHP_IO_CNTL_A1                        0x000C
+#define ixMC_CHP_IO_CNTL_B0                        0x000D
+#define ixMC_CHP_IO_CNTL_B1                        0x000E
+#define ixMC_IMP_CNTL_0                            0x000F
+#define ixTC_MISMATCH_1                            0x0010
+#define ixTC_MISMATCH_2                            0x0011
+#define ixMC_BIST_CTRL                             0x0012
+#define ixREG_COLLAR_WRITE                         0x0013
+#define ixREG_COLLAR_READ                          0x0014
+
+
+
+
 #endif	/* _RADEON_H */
 
diff -purN /dev/shm/linux-2.5/init/main.c linuxppc-2.5-benh/init/main.c
--- /dev/shm/linux-2.5/init/main.c	2004-02-04 05:28:11.000000000 +0000
+++ linuxppc-2.5-benh/init/main.c	2004-02-05 10:07:37.000000000 +0000
@@ -174,7 +174,7 @@ EXPORT_SYMBOL(loops_per_jiffy);
    better than 1% */
 #define LPS_PREC 8
 
-void __init calibrate_delay(void)
+void /* __init*/ calibrate_delay(void)
 {
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
diff -purN /dev/shm/linux-2.5/kernel/printk.c linuxppc-2.5-benh/kernel/printk.c
--- /dev/shm/linux-2.5/kernel/printk.c	2004-02-04 05:28:11.000000000 +0000
+++ linuxppc-2.5-benh/kernel/printk.c	2004-02-05 10:07:37.000000000 +0000
@@ -33,6 +33,11 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_BOOTX_TEXT
+#include <asm/btext.h>
+#endif
+
+
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
 /* printk's without a loglevel use this.. */
@@ -488,6 +493,9 @@ asmlinkage int printk(const char *fmt, .
 	char *p;
 	static char printk_buf[1024];
 	static int log_level_unknown = 1;
+#ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
+#endif
 
 	if (oops_in_progress) {
 		/* If a crash is occurring, make sure we can't deadlock */
@@ -503,6 +511,10 @@ asmlinkage int printk(const char *fmt, .
 	va_start(args, fmt);
 	printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
+#ifdef CONFIG_BOOTX_TEXT
+	if (force_printk_to_btext)
+		btext_drawstring(printk_buf);
+#endif /* CONFIG_BOOTX_TEXT */
 
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/dmasound.h linuxppc-2.5-benh/sound/oss/dmasound/dmasound.h
--- /dev/shm/linux-2.5/sound/oss/dmasound/dmasound.h	2003-09-04 13:21:03.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/dmasound.h	2003-12-05 00:45:49.000000000 +0000
@@ -273,4 +273,11 @@ static inline void wait_ms(unsigned int 
 	schedule_timeout(1 + ms * HZ / 1000);
 }
 
+#define SW_INPUT_VOLUME_SCALE	4
+#define SW_INPUT_VOLUME_DEFAULT	(128 / SW_INPUT_VOLUME_SCALE)
+
+extern int expand_bal;	/* Balance factor for expanding (not volume!) */
+extern int expand_read_bal;	/* Balance factor for reading */
+extern uint software_input_volume; /* software implemented recording volume! */
+
 #endif /* _dmasound_h_ */
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/dmasound_awacs.c linuxppc-2.5-benh/sound/oss/dmasound/dmasound_awacs.c
--- /dev/shm/linux-2.5/sound/oss/dmasound/dmasound_awacs.c	2003-09-09 19:11:28.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/dmasound_awacs.c	2003-12-29 06:44:00.000000000 +0000
@@ -52,6 +52,10 @@
  *	        - Support for snapper & better tumbler integration by Toby Sargeant
  *	        - Headphone detect for scremer by Julien Blache
  *	        - More tumbler fixed by Andreas Schwab
+ *	11/29/2003 [0.8.1] - Renzo Davoli (King Enzo)
+ *		- Support for Snapper line in
+ *		- snapper input resampling (for rates < 44100)
+ *		- software line gain control
  */
 
 /* GENERAL FIXME/TODO: check that the assumptions about what is written to
@@ -76,6 +80,7 @@
 #include <linux/spinlock.h>
 #include <linux/kmod.h>
 #include <linux/interrupt.h>
+#include <linux/input.h>
 #include <asm/semaphore.h>
 #ifdef CONFIG_ADB_CUDA
 #include <linux/cuda.h>
@@ -119,7 +124,6 @@ static volatile u32 *i2s;
 static volatile struct dbdma_regs *awacs_txdma, *awacs_rxdma;
 static int awacs_rate_index;
 static int awacs_subframe;
-static int awacs_spkr_vol;
 static struct device_node* awacs_node;
 static struct device_node* i2s_node;
 
@@ -264,6 +268,7 @@ struct pmu_sleep_notifier awacs_sleep_no
 
 /* for (soft) sample rate translations */
 int expand_bal;		/* Balance factor for expanding (not volume!) */
+int expand_read_bal;	/* Balance factor for expanding reads (not volume!) */
 
 /*** Low level stuff *********************************************************/
 
@@ -285,8 +290,6 @@ static irqreturn_t pmac_awacs_intr(int i
 static void awacs_write(int val);
 static int awacs_get_volume(int reg, int lshift);
 static int awacs_volume_setter(int volume, int n, int mute, int lshift);
-static void awacs_mksound(unsigned int hz, unsigned int ticks);
-static void awacs_nosound(unsigned long xx);
 
 
 /*** Mid level stuff **********************************************************/
@@ -299,6 +302,7 @@ static void PMacAbortRead(void);
 extern TRANS transAwacsNormal ;
 extern TRANS transAwacsExpand ;
 extern TRANS transAwacsNormalRead ;
+extern TRANS transAwacsExpandRead ;
 
 extern int daca_init(void);
 extern void daca_cleanup(void);
@@ -545,11 +549,15 @@ tas_mixer_ioctl(u_int cmd, u_long arg)
 		rc = IOCTL_OUT(arg, 0);
 		break;
 	case SOUND_MIXER_READ_RECMASK:
-		data = 0;
+		// XXX FIXME: find a way to check what is really available */
+		data = SOUND_MASK_LINE | SOUND_MASK_MIC;
 		rc = IOCTL_OUT(arg, data);
 		break;
 	case SOUND_MIXER_READ_RECSRC:
-		data = 0;
+		if (awacs_reg[0] & MASK_MUX_AUDIN)
+			data |= SOUND_MASK_LINE;
+		if (awacs_reg[0] & MASK_MUX_MIC)
+			data |= SOUND_MASK_MIC;
 		rc = IOCTL_OUT(arg, data);
 		break;
 	case SOUND_MIXER_WRITE_RECSRC:
@@ -799,11 +807,13 @@ static void PMacInit(void)
 	set_frame_rate(dmasound.soft.speed, catchRadius) ;
 
 	tolerance = (catchRadius * dmasound.hard.speed) / 100;
-	if (dmasound.soft.speed >= dmasound.hard.speed - tolerance)
+	if (dmasound.soft.speed >= dmasound.hard.speed - tolerance) {
 		dmasound.trans_write = &transAwacsNormal;
-	else
+		dmasound.trans_read = &transAwacsNormalRead;
+	} else {
 		dmasound.trans_write = &transAwacsExpand;
-	dmasound.trans_read = &transAwacsNormalRead;
+		dmasound.trans_read = &transAwacsExpandRead;
+	}
 
 	if (awacs) {
 		if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE))
@@ -813,6 +823,7 @@ static void PMacInit(void)
 	}
 	
 	expand_bal = -dmasound.soft.speed;
+	expand_read_bal = -dmasound.soft.speed;
 }
 
 static int PMacSetFormat(int format)
@@ -1280,15 +1291,14 @@ static void awacs_nosound(unsigned long 
 	spin_unlock_irqrestore(&dmasound.lock, flags);
 }
 
-static struct timer_list beep_timer = TIMER_INITIALIZER(awacs_nosound, 0, 0);
-
-#if 0 /* would need to go through the input layer in 2.6, later..  --hch */
-/* we generate the beep with a single dbdma command that loops a buffer
-   forever - without generating interrupts.
-   So, to stop it you have to stop dma output as per awacs_nosound.
-*/
-
-static void awacs_mksound(unsigned int hz, unsigned int ticks)
+/*
+ * We generate the beep with a single dbdma command that loops a buffer
+ * forever - without generating interrupts.
+ *
+ * So, to stop it you have to stop dma output as per awacs_nosound.
+ */
+static int awacs_beep_event(struct input_dev *dev, unsigned int type,
+		unsigned int code, int hz)
 {
 	unsigned long flags;
 	int beep_speed = 0;
@@ -1300,8 +1310,21 @@ static void awacs_mksound(unsigned int h
 	static int beep_nsamples_cache;
 	static int beep_volume_cache;
 
+	if (type != EV_SND)
+		return -1;
+	switch (code) {
+	case SND_BELL:
+		if (hz)
+			hz = 1000;
+		break;
+	case SND_TONE:
+		break;
+	default:
+		return -1;
+	}
+
 	if (beep_buf == NULL)
-		return;
+		return -1;
 
 	/* quick-hack fix for DACA, Burgundy & Tumbler */
 
@@ -1313,26 +1336,17 @@ static void awacs_mksound(unsigned int h
 				beep_speed = i;
 		srate = awacs_freqs[beep_speed];
 	}
+
 	if (hz <= srate / BEEP_BUFLEN || hz > srate / 2) {
-#if 1
-		/* this is a hack for broken X server code */
-		hz = 750;
-		ticks = 12;
-#else
 		/* cancel beep currently playing */
 		awacs_nosound(0);
-		return;
-#endif
+		return 0;
 	}
+
 	spin_lock_irqsave(&dmasound.lock, flags);
-	del_timer(&beep_timer);
-	if (ticks) {
-		beep_timer.expires = jiffies + ticks;
-		add_timer(&beep_timer);
-	}
 	if (beep_playing || write_sq.active || beep_buf == NULL) {
 		spin_unlock_irqrestore(&dmasound.lock, flags);
-		return;		/* too hard, sorry :-( */
+		return -1;		/* too hard, sorry :-( */
 	}
 	beep_playing = 1;
 	st_le16(&beep_dbdma_cmd->command, OUTPUT_MORE + BR_ALWAYS);
@@ -1375,8 +1389,9 @@ static void awacs_mksound(unsigned int h
 		out_le32(&awacs_txdma->control, RUN | (RUN << 16));
 	}
 	spin_unlock_irqrestore(&dmasound.lock, flags);
+
+	return 0;
 }
-#endif
 
 /* used in init and for wake-up */
 
@@ -1764,7 +1779,6 @@ awacs_enable_amp(int spkr_vol)
 #ifdef CONFIG_ADB_CUDA
 	struct adb_request req;
 
-	awacs_spkr_vol = spkr_vol;
 	if (sys_ctrler != SYS_CTRLER_CUDA)
 		return;
 
@@ -2797,6 +2811,17 @@ __init setup_beep(void)
 	return 0 ;
 }
 
+static struct input_dev awacs_beep_dev = {
+	.evbit		= { BIT(EV_SND) },
+	.sndbit		= { BIT(SND_BELL) | BIT(SND_TONE) },
+	.event		= awacs_beep_event,
+	.name		= "dmasound beeper",
+	.phys		= "macio/input0", /* what the heck is this?? */
+	.id		= {
+		.bustype	= BUS_HOST,
+	},
+};
+
 int __init dmasound_awacs_init(void)
 {
 	struct device_node *io = NULL, *info = NULL;
@@ -3086,13 +3111,9 @@ printk("dmasound_pmac: Awacs/Screamer Co
 	/* shut out chips that do output only.
 	 * may need to extend this to machines which have no inputs - even tho'
 	 * they use screamer - IIRC one of the powerbooks is like this.
-	 *
-	 * FIXME: Actually, some TUMBLER and SNAPPER do have inputs...  
 	 */
 
-	if (awacs_revision != AWACS_TUMBLER &&
-            awacs_revision != AWACS_SNAPPER &&
-            awacs_revision != AWACS_DACA) {
+	if (awacs_revision != AWACS_DACA) {
 		dmasound.mach.capabilities = DSP_CAP_DUPLEX ;
 		dmasound.mach.record = PMacRecord ;
 	}
@@ -3122,11 +3143,19 @@ printk("dmasound_pmac: Awacs/Screamer Co
 			break ;
 	}
 
+	/*
+	 * XXX: we should handle errors here, but that would mean
+	 * rewriting the whole init code.  later..
+	 */
+	input_register_device(&awacs_beep_dev);
+
 	return dmasound_init();
 }
 
 static void __exit dmasound_awacs_cleanup(void)
 {
+	input_unregister_device(&awacs_beep_dev);
+
 	switch (awacs_revision) {
 		case AWACS_TUMBLER:
 		case AWACS_SNAPPER:
@@ -3138,6 +3167,7 @@ static void __exit dmasound_awacs_cleanu
 			break;
 	}
 	dmasound_deinit();
+
 }
 
 MODULE_DESCRIPTION("PowerMac built-in audio driver.");
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/dmasound_core.c linuxppc-2.5-benh/sound/oss/dmasound/dmasound_core.c
--- /dev/shm/linux-2.5/sound/oss/dmasound/dmasound_core.c	2003-09-04 13:21:04.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/dmasound_core.c	2003-12-29 06:44:00.000000000 +0000
@@ -218,6 +218,10 @@ static int state_unit = -1;
 static int irq_installed;
 #endif /* MODULE */
 
+/* software implemented recording volume! */
+uint software_input_volume = SW_INPUT_VOLUME_SCALE * SW_INPUT_VOLUME_DEFAULT;
+EXPORT_SYMBOL(software_input_volume);
+
 /* control over who can modify resources shared between play/record */
 static mode_t shared_resource_owner;
 static int shared_resources_initialised;
@@ -238,6 +242,7 @@ static inline int sound_set_format(int f
 	return dmasound.mach.setFormat(format);
 }
 
+
 static int sound_set_speed(int speed)
 {
 	if (speed < 0)
@@ -1264,15 +1269,13 @@ static int sq_ioctl(struct inode *inode,
 			result = IOCTL_OUT(arg, format);
 			if (result < 0)
 				return result;
-			if (format != data)
+			if (format != data && data != AFMT_QUERY)
 				return -EINVAL;
 			return 0;
 		} else
 			return -EINVAL ;
-		break ;
 	case SNDCTL_DSP_SUBDIVIDE:
 		return -EINVAL ;
-		break;
 	case SNDCTL_DSP_SETFRAGMENT:
 		/* we can do this independently for the two queues - with the
 		   proviso that for fds opened O_RDWR we cannot separate the
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/tas3004.c linuxppc-2.5-benh/sound/oss/dmasound/tas3004.c
--- /dev/shm/linux-2.5/sound/oss/dmasound/tas3004.c	2003-09-30 00:25:28.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/tas3004.c	2003-12-05 00:45:49.000000000 +0000
@@ -5,11 +5,7 @@
  * Tobias Sargeant <tobias.sargeant@bigpond.com>
  * Based upon tas3001c.c by Christopher C. Chimelis <chris@debian.org>:
  *
- *   TODO:
- *   -----
- *   * Enable control over input line 2 (is this connected?)
- *   * Implement sleep support (at least mute everything and
- *   * set gains to minimum during sleep)
+ * Input support by Renzo Davoli <renzo@cs.unibo.it>
  *
  */
 
@@ -293,7 +289,8 @@ tas3004_write_register(	struct tas3004_d
 {
 	if (reg_num==TAS3004_REG_MCR ||
 	    reg_num==TAS3004_REG_BASS ||
-	    reg_num==TAS3004_REG_TREBLE) {
+	    reg_num==TAS3004_REG_TREBLE ||
+	    reg_num==TAS3004_REG_ANALOG_CTRL) {
 		return tas_write_byte_register(&self->super,
 					       (uint)reg_num,
 					       *data,
@@ -313,7 +310,8 @@ tas3004_sync_register(	struct tas3004_da
 {
 	if (reg_num==TAS3004_REG_MCR ||
 	    reg_num==TAS3004_REG_BASS ||
-	    reg_num==TAS3004_REG_TREBLE) {
+	    reg_num==TAS3004_REG_TREBLE ||
+	    reg_num==TAS3004_REG_ANALOG_CTRL) {
 		return tas_sync_byte_register(&self->super,
 					      (uint)reg_num,
 					      register_width(reg_num));
@@ -354,7 +352,9 @@ tas3004_supported_mixers(struct tas3004_
 		SOUND_MASK_ALTPCM |
 		SOUND_MASK_IMIX |
 		SOUND_MASK_TREBLE |
-		SOUND_MASK_BASS;
+		SOUND_MASK_BASS |
+		SOUND_MASK_MIC |
+		SOUND_MASK_LINE;
 }
 
 static int
@@ -447,6 +447,28 @@ tas3004_set_mixer_level(struct tas3004_d
 		shadow[TAS3004_REG_BASS][0]=temp&0xff;
 		rc = tas3004_sync_register(self,TAS3004_REG_BASS);
 		break;
+	case SOUND_MIXER_MIC:
+		if ((level&0xff)>0) {
+			software_input_volume = SW_INPUT_VOLUME_SCALE * (level&0xff); 
+			if (self->super.mixer[mixer] == 0) {
+				self->super.mixer[SOUND_MIXER_LINE] = 0;
+				shadow[TAS3004_REG_ANALOG_CTRL][0]=0xc2;
+				rc = tas3004_sync_register(self,TAS3004_REG_ANALOG_CTRL);
+			} else rc=0;
+		} else {
+			self->super.mixer[SOUND_MIXER_LINE] = SW_INPUT_VOLUME_DEFAULT;
+			software_input_volume = SW_INPUT_VOLUME_SCALE *
+				(self->super.mixer[SOUND_MIXER_LINE]&0xff); 
+			shadow[TAS3004_REG_ANALOG_CTRL][0]=0x00;
+			rc = tas3004_sync_register(self,TAS3004_REG_ANALOG_CTRL);
+		} 
+		break;
+	case SOUND_MIXER_LINE:
+		if (self->super.mixer[SOUND_MIXER_MIC] == 0) { 
+			software_input_volume = SW_INPUT_VOLUME_SCALE * (level&0xff); 
+			rc=0;
+		}
+		break;
 	default:
 		rc = -1;
 		break;
@@ -496,6 +518,7 @@ tas3004_leave_sleep(struct tas3004_data_
 	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_MIXER);
 	(void)tas3004_sync_register(self,TAS3004_REG_TREBLE);
 	(void)tas3004_sync_register(self,TAS3004_REG_BASS);
+	(void)tas3004_sync_register(self,TAS3004_REG_ANALOG_CTRL);
 
 	return 0;
 }
@@ -1050,6 +1073,8 @@ tas3004_init_mixer(struct tas3004_data_t
 	tas3004_set_mixer_level(self, SOUND_MIXER_BASS, BASS_DEFAULT);
 	tas3004_set_mixer_level(self, SOUND_MIXER_TREBLE, TREBLE_DEFAULT);
 
+	tas3004_set_mixer_level(self, SOUND_MIXER_LINE,SW_INPUT_VOLUME_DEFAULT);
+
 	return 0;
 }
 
@@ -1064,6 +1089,8 @@ tas3004_uninit_mixer(struct tas3004_data
 	tas3004_set_mixer_level(self, SOUND_MIXER_BASS, 0);
 	tas3004_set_mixer_level(self, SOUND_MIXER_TREBLE, 0);
 
+	tas3004_set_mixer_level(self, SOUND_MIXER_LINE, 0);
+
 	return 0;
 }
 
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/tas_common.c linuxppc-2.5-benh/sound/oss/dmasound/tas_common.c
--- /dev/shm/linux-2.5/sound/oss/dmasound/tas_common.c	2003-09-30 00:25:28.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/tas_common.c	2003-12-05 00:45:49.000000000 +0000
@@ -195,6 +195,9 @@ tas_init(int driver_id, const char *driv
 
 	printk(KERN_INFO "tas driver [%s])\n", driver_name);
 
+#ifndef CONFIG_I2C_KEYWEST
+	request_module("i2c-keywest");
+#endif
 	tas_node = find_devices("deq");
 	if (tas_node == NULL)
 		return -ENODEV;
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/tas_common.h linuxppc-2.5-benh/sound/oss/dmasound/tas_common.h
--- /dev/shm/linux-2.5/sound/oss/dmasound/tas_common.h	2003-09-09 19:09:48.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/tas_common.h	2003-12-05 00:45:49.000000000 +0000
@@ -87,7 +87,7 @@ struct tas_gain_t
   unsigned int *mixer;
 };
 
-typedef char tas_shadow_t[16];
+typedef char tas_shadow_t[0x45];
 
 struct tas_data_t
 {
diff -purN /dev/shm/linux-2.5/sound/oss/dmasound/trans_16.c linuxppc-2.5-benh/sound/oss/dmasound/trans_16.c
--- /dev/shm/linux-2.5/sound/oss/dmasound/trans_16.c	2004-02-04 05:36:39.000000000 +0000
+++ linuxppc-2.5-benh/sound/oss/dmasound/trans_16.c	2004-02-05 10:21:35.000000000 +0000
@@ -8,6 +8,9 @@
  *
  *  08/02/2001 Iain Sandoe
  *		split from dmasound_awacs.c
+ *  11/29/2003 Renzo Davoli (King Enzo)
+ *  	- input resampling (for soft rate < hard rate)
+ *  	- software line in gain control
  */
 
 #include <linux/soundcard.h>
@@ -461,11 +464,13 @@ static ssize_t pmac_ct_s8_read(const u_c
 		u_char data;
 
 		val = *p++;
+		val = (val * software_input_volume) >> 7;
 		data = val >> 8;
 		if (put_user(data, (u_char *)userPtr++))
 			return -EFAULT;
 		if (stereo) {
 			val = *p;
+			val = (val * software_input_volume) >> 7;
 			data = val >> 8;
 			if (put_user(data, (u_char *)userPtr++))
 				return -EFAULT;
@@ -494,11 +499,13 @@ static ssize_t pmac_ct_u8_read(const u_c
 		u_char data;
 
 		val = *p++;
+		val = (val * software_input_volume) >> 7;
 		data = (val >> 8) ^ 0x80;
 		if (put_user(data, (u_char *)userPtr++))
 			return -EFAULT;
 		if (stereo) {
 			val = *p;
+			val = (val * software_input_volume) >> 7;
 			data = (val >> 8) ^ 0x80;
 			if (put_user(data, (u_char *)userPtr++))
 				return -EFAULT;
@@ -517,24 +524,27 @@ static ssize_t pmac_ct_s16_read(const u_
 	ssize_t count, used;
 	int stereo = dmasound.soft.stereo;
 	short *fp = (short *) &frame[*frameUsed];
+	short *up = (short *) userPtr;
 
 	frameLeft >>= 2;
 	userCount >>= (stereo? 2: 1);
 	used = count = min_t(unsigned long, userCount, frameLeft);
-	if (!stereo) {
-		short *up = (short *) userPtr;
-		while (count > 0) {
-			short data;
+	while (count > 0) {
+		short data;
+
+		data = *fp++;
+		data = (data * software_input_volume) >> 7;
+		if (put_user(data, up++))
+			return -EFAULT;
+		if (stereo) {
 			data = *fp;
+			data = (data * software_input_volume) >> 7;
 			if (put_user(data, up++))
 				return -EFAULT;
-			fp+=2;
-			count--;
 		}
-	} else {
-		if (copy_to_user((u_char *)userPtr, fp, count * 4))
-			return -EFAULT;
-	}
+		fp++;
+		count--;
+ 	}
 	*frameUsed += used * 4;
 	return stereo? used * 4: used * 2;
 }
@@ -556,11 +566,13 @@ static ssize_t pmac_ct_u16_read(const u_
 		int data;
 
 		data = *fp++;
+		data = (data * software_input_volume) >> 7;
 		data ^= mask;
 		if (put_user(data, up++))
 			return -EFAULT;
 		if (stereo) {
 			data = *fp;
+			data = (data * software_input_volume) >> 7;
 			data ^= mask;
 			if (put_user(data, up++))
 				return -EFAULT;
@@ -572,6 +584,204 @@ static ssize_t pmac_ct_u16_read(const u_
 	return stereo? used * 4: used * 2;
 }
 
+/* data in routines (reducing speed)... */
+
+static ssize_t pmac_ctx_s8_read(const u_char *userPtr, size_t userCount,
+			  u_char frame[], ssize_t *frameUsed,
+			  ssize_t frameLeft)
+{
+	short *p = (short *) &frame[*frameUsed];
+	int bal = expand_read_bal;
+	int vall,valr, stereo = dmasound.soft.stereo;
+	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
+	int utotal, ftotal;
+
+	frameLeft >>= 2;
+	if (stereo)
+		userCount >>= 1;
+	ftotal = frameLeft;
+	utotal = userCount;
+	while (frameLeft) {
+		u_char data;
+
+		if (bal<0 && userCount == 0)
+			break;
+		vall = *p++;
+		vall = (vall * software_input_volume) >> 7;
+		if (stereo) {
+			valr = *p;
+			valr = (valr * software_input_volume) >> 7;
+		}
+		p++;
+		if (bal < 0) {
+			data = vall >> 8;
+			if (put_user(data, (u_char *)userPtr++))
+				return -EFAULT;
+			if (stereo) {
+				data = valr >> 8;
+				if (put_user(data, (u_char *)userPtr++))
+					return -EFAULT;
+			}
+			userCount--;
+			bal += hSpeed;
+		}
+		frameLeft--;
+		bal -= sSpeed;
+	}
+	expand_read_bal=bal;
+	*frameUsed += (ftotal - frameLeft) * 4;
+	utotal -= userCount;
+	return stereo? utotal * 2: utotal;
+}
+
+
+static ssize_t pmac_ctx_u8_read(const u_char *userPtr, size_t userCount,
+			  u_char frame[], ssize_t *frameUsed,
+			  ssize_t frameLeft)
+{
+	short *p = (short *) &frame[*frameUsed];
+	int bal = expand_read_bal;
+	int vall,valr, stereo = dmasound.soft.stereo;
+	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
+	int utotal, ftotal;
+
+	frameLeft >>= 2;
+	if (stereo)
+		userCount >>= 1;
+	ftotal = frameLeft;
+	utotal = userCount;
+	while (frameLeft) {
+		u_char data;
+
+		if (bal<0 && userCount == 0)
+			break;
+
+		vall = *p++;
+		vall = (vall * software_input_volume) >> 7;
+		if (stereo) {
+			valr = *p;
+			valr = (valr * software_input_volume) >> 7;
+		}
+		p++;
+		if (bal < 0) {
+			data = (vall >> 8) ^ 0x80;
+			if (put_user(data, (u_char *)userPtr++))
+				return -EFAULT;
+			if (stereo) {
+				data = (valr >> 8) ^ 0x80;
+				if (put_user(data, (u_char *)userPtr++))
+					return -EFAULT;
+			}
+			userCount--;
+			bal += hSpeed;
+		}
+		frameLeft--;
+		bal -= sSpeed;
+	}
+	expand_read_bal=bal;
+	*frameUsed += (ftotal - frameLeft) * 4;
+	utotal -= userCount;
+	return stereo? utotal * 2: utotal;
+}
+
+static ssize_t pmac_ctx_s16_read(const u_char *userPtr, size_t userCount,
+			   u_char frame[], ssize_t *frameUsed,
+			   ssize_t frameLeft)
+{
+	int bal = expand_read_bal;
+	short *fp = (short *) &frame[*frameUsed];
+	short *up = (short *) userPtr;
+	int stereo = dmasound.soft.stereo;
+	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
+	int utotal, ftotal;
+
+	frameLeft >>= 2;
+	userCount >>= (stereo? 2: 1);
+	ftotal = frameLeft;
+	utotal = userCount;
+	while (frameLeft) {
+		int datal,datar;
+
+		if (bal<0 && userCount == 0)
+			break;
+
+		datal = *fp++;
+		datal = (datal * software_input_volume) >> 7;
+		if (stereo) {
+			datar = *fp;
+			datar = (datar * software_input_volume) >> 7;
+		}
+		fp++;
+		if (bal < 0) {
+			if (put_user(datal, up++))
+				return -EFAULT;
+			if (stereo) {
+				if (put_user(datar, up++))
+					return -EFAULT;
+			}
+			userCount--;
+			bal += hSpeed;
+		}
+		frameLeft--;
+		bal -= sSpeed;
+	}
+	expand_read_bal=bal;
+	*frameUsed += (ftotal - frameLeft) * 4;
+	utotal -= userCount;
+	return stereo? utotal * 4: utotal * 2;
+}
+
+static ssize_t pmac_ctx_u16_read(const u_char *userPtr, size_t userCount,
+			   u_char frame[], ssize_t *frameUsed,
+			   ssize_t frameLeft)
+{
+	int bal = expand_read_bal;
+	int mask = (dmasound.soft.format == AFMT_U16_LE? 0x0080: 0x8000);
+	short *fp = (short *) &frame[*frameUsed];
+	short *up = (short *) userPtr;
+	int stereo = dmasound.soft.stereo;
+	int hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;
+	int utotal, ftotal;
+
+	frameLeft >>= 2;
+	userCount >>= (stereo? 2: 1);
+	ftotal = frameLeft;
+	utotal = userCount;
+	while (frameLeft) {
+		int datal,datar;
+
+		if (bal<0 && userCount == 0)
+			break;
+
+		datal = *fp++;
+		datal = (datal * software_input_volume) >> 7;
+		datal ^= mask;
+		if (stereo) {
+			datar = *fp;
+			datar = (datar * software_input_volume) >> 7;
+			datar ^= mask;
+		}
+		fp++;
+		if (bal < 0) {
+			if (put_user(datal, up++))
+				return -EFAULT;
+			if (stereo) {
+				if (put_user(datar, up++))
+					return -EFAULT;
+			}
+			userCount--;
+			bal += hSpeed;
+		}
+		frameLeft--;
+		bal -= sSpeed;
+	}
+	expand_read_bal=bal;
+	*frameUsed += (ftotal - frameLeft) * 4;
+	utotal -= userCount;
+	return stereo? utotal * 4: utotal * 2;
+}
+
+
 TRANS transAwacsNormal = {
 	.ct_ulaw=	pmac_ct_law,
 	.ct_alaw=	pmac_ct_law,
@@ -603,6 +813,15 @@ TRANS transAwacsNormalRead = {
 	.ct_u16le=	pmac_ct_u16_read,
 };
 
+TRANS transAwacsExpandRead = {
+	ct_s8:		pmac_ctx_s8_read,
+	ct_u8:		pmac_ctx_u8_read,
+	ct_s16be:	pmac_ctx_s16_read,
+	ct_u16be:	pmac_ctx_u16_read,
+	ct_s16le:	pmac_ctx_s16_read,
+	ct_u16le:	pmac_ctx_u16_read,
+};
+
 /* translation tables */
 /* 16 bit mu-law */
 
diff -purN /dev/shm/linux-2.5/sound/ppc/tumbler.c linuxppc-2.5-benh/sound/ppc/tumbler.c
--- /dev/shm/linux-2.5/sound/ppc/tumbler.c	2003-08-27 09:44:23.000000000 +0000
+++ linuxppc-2.5-benh/sound/ppc/tumbler.c	2003-09-26 09:36:51.000000000 +0000
@@ -952,6 +952,7 @@ static int __init tumbler_init(pmac_t *c
 	tumbler_reset_audio(chip);
 
 	/* activate headphone status interrupts */
+	/* XXX FIXME: disable that IRQ on suspend --BenH */
   	if (irq >= 0) {
 		unsigned char val;
 		if ((err = request_irq(irq, headphone_intr, 0,

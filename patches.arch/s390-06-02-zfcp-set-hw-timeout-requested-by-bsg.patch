Subject: zfcp: set HW timeout requested by BSG request
References: BNC#572659
From: Gerald Schaefer <geraldsc@de.ibm.com>
Patch-mainline: not yet

Description: zfcp: set HW timeout requested by BSG request
Symptom:     BSG request with a different request timeout then the standard
             FC requests would return a false completion code.
Problem:     The hardware used with zfcp provides a timer for CT and ELS
             requests instead of an abort capability for these commands.
Solution:    To correctly handle the FC BSG timeouts, pass the timeout from 
             the BSG requests to the hardware.
Acked-by: John Jolly <jjolly@suse.de>

---
 drivers/s390/scsi/zfcp_ext.h |    4 ++--
 drivers/s390/scsi/zfcp_fc.c  |   12 +++++++-----
 drivers/s390/scsi/zfcp_fsf.c |   17 ++++++++++-------
 3 files changed, 19 insertions(+), 14 deletions(-)

Index: linux-rhel6/drivers/s390/scsi/zfcp_ext.h
===================================================================
--- linux-rhel6.orig/drivers/s390/scsi/zfcp_ext.h
+++ linux-rhel6/drivers/s390/scsi/zfcp_ext.h
@@ -125,8 +125,8 @@ extern struct zfcp_fsf_req *zfcp_fsf_con
 extern void zfcp_fsf_req_dismiss_all(struct zfcp_adapter *);
 extern int zfcp_fsf_status_read(struct zfcp_qdio *);
 extern int zfcp_status_read_refill(struct zfcp_adapter *adapter);
-extern int zfcp_fsf_send_ct(struct zfcp_send_ct *, mempool_t *);
-extern int zfcp_fsf_send_els(struct zfcp_send_els *);
+extern int zfcp_fsf_send_ct(struct zfcp_send_ct *, mempool_t *, unsigned int);
+extern int zfcp_fsf_send_els(struct zfcp_send_els *, unsigned int);
 extern int zfcp_fsf_send_fcp_command_task(struct zfcp_unit *,
 					  struct scsi_cmnd *);
 extern void zfcp_fsf_req_free(struct zfcp_fsf_req *);
Index: linux-rhel6/drivers/s390/scsi/zfcp_fc.c
===================================================================
--- linux-rhel6.orig/drivers/s390/scsi/zfcp_fc.c
+++ linux-rhel6/drivers/s390/scsi/zfcp_fc.c
@@ -39,6 +39,7 @@ struct gpn_ft_resp_acc {
 #define ZFCP_GPN_FT_MAX_SIZE (ZFCP_GPN_FT_BUFFERS * PAGE_SIZE \
 				- sizeof(struct ct_hdr))
 #define ZFCP_GPN_FT_MAX_ENTRIES ZFCP_GPN_FT_BUFFERS * (ZFCP_GPN_FT_ENTRIES + 1)
+#define ZFCP_FC_CTELS_TMO      (2 * R_A_TOV)
 
 struct ct_iu_gpn_ft_resp {
 	struct ct_hdr header;
@@ -302,7 +303,8 @@ static int zfcp_fc_ns_gid_pn_request(str
 	init_completion(&compl_rec.done);
 	compl_rec.handler = zfcp_fc_ns_gid_pn_eval;
 	compl_rec.handler_data = (unsigned long) gid_pn;
-	ret = zfcp_fsf_send_ct(&gid_pn->ct, adapter->pool.gid_pn_req);
+	ret = zfcp_fsf_send_ct(&gid_pn->ct, adapter->pool.gid_pn_req,
+			       ZFCP_FC_CTELS_TMO);
 	if (!ret)
 		wait_for_completion(&compl_rec.done);
 	return ret;
@@ -453,7 +455,7 @@ static int zfcp_fc_adisc(struct zfcp_por
 	adisc->ls_adisc.wwnn = fc_host_node_name(adapter->scsi_host);
 	adisc->ls_adisc.nport_id = fc_host_port_id(adapter->scsi_host);
 
-	ret = zfcp_fsf_send_els(&adisc->els);
+	ret = zfcp_fsf_send_els(&adisc->els, ZFCP_FC_CTELS_TMO);
 	if (ret)
 		kmem_cache_free(zfcp_data.adisc_cache, adisc);
 
@@ -568,7 +570,7 @@ static int zfcp_fc_send_gpn_ft(struct zf
 
 	init_completion(&compl_rec.done);
 	compl_rec.handler = NULL;
-	ret = zfcp_fsf_send_ct(ct, NULL);
+	ret = zfcp_fsf_send_ct(ct, NULL, ZFCP_FC_CTELS_TMO);
 	if (!ret)
 		wait_for_completion(&compl_rec.done);
 	return ret;
@@ -771,7 +773,7 @@ int zfcp_fc_execute_els_fc_job(struct fc
 	els_fc_job->els.handler_data = (unsigned long) els_fc_job;
 	els_fc_job->job = job;
 
-	return zfcp_fsf_send_els(&els_fc_job->els);
+	return zfcp_fsf_send_els(&els_fc_job->els, job->req->timeout / HZ);
 }
 
 struct zfcp_ct_fc_job {
@@ -849,7 +851,7 @@ int zfcp_fc_execute_ct_fc_job(struct fc_
 	ct_fc_job->ct.completion = NULL;
 	ct_fc_job->job = job;
 
-	ret = zfcp_fsf_send_ct(&ct_fc_job->ct, NULL);
+	ret = zfcp_fsf_send_ct(&ct_fc_job->ct, NULL, job->req->timeout / HZ);
 	if (ret) {
 		kfree(ct_fc_job);
 		zfcp_fc_wka_port_put(ct_fc_job->ct.wka_port);
Index: linux-rhel6/drivers/s390/scsi/zfcp_fsf.c
===================================================================
--- linux-rhel6.orig/drivers/s390/scsi/zfcp_fsf.c
+++ linux-rhel6/drivers/s390/scsi/zfcp_fsf.c
@@ -1063,7 +1063,7 @@ static int zfcp_fsf_setup_ct_els_sbals(s
 static int zfcp_fsf_setup_ct_els(struct zfcp_fsf_req *req,
 				 struct scatterlist *sg_req,
 				 struct scatterlist *sg_resp,
-				 int max_sbals)
+				 int max_sbals, unsigned int timeout)
 {
 	int ret;
 
@@ -1073,8 +1073,10 @@ static int zfcp_fsf_setup_ct_els(struct 
 
 	/* common settings for ct/gs and els requests */
 	req->qtcb->bottom.support.service_class = FSF_CLASS_3;
-	req->qtcb->bottom.support.timeout = 2 * R_A_TOV;
-	zfcp_fsf_start_timer(req, (2 * R_A_TOV + 10) * HZ);
+	if (timeout > 255)
+		timeout = 255; /* max value accepted by hardware */
+	req->qtcb->bottom.support.timeout = timeout;
+	zfcp_fsf_start_timer(req, (timeout + 10) * HZ);
 
 	return 0;
 }
@@ -1084,7 +1086,8 @@ static int zfcp_fsf_setup_ct_els(struct 
  * @ct: pointer to struct zfcp_send_ct with data for request
  * @pool: if non-null this mempool is used to allocate struct zfcp_fsf_req
  */
-int zfcp_fsf_send_ct(struct zfcp_send_ct *ct, mempool_t *pool)
+int zfcp_fsf_send_ct(struct zfcp_send_ct *ct, mempool_t *pool,
+		     unsigned int timeout)
 {
 	struct zfcp_wka_port *wka_port = ct->wka_port;
 	struct zfcp_qdio *qdio = wka_port->adapter->qdio;
@@ -1104,7 +1107,7 @@ int zfcp_fsf_send_ct(struct zfcp_send_ct
 
 	req->status |= ZFCP_STATUS_FSFREQ_CLEANUP;
 	ret = zfcp_fsf_setup_ct_els(req, ct->req, ct->resp,
-				    FSF_MAX_SBALS_PER_REQ);
+				    FSF_MAX_SBALS_PER_REQ, timeout);
 	if (ret)
 		goto failed_send;
 
@@ -1183,7 +1186,7 @@ skip_fsfstatus:
  * zfcp_fsf_send_els - initiate an ELS command (FC-FS)
  * @els: pointer to struct zfcp_send_els with data for the command
  */
-int zfcp_fsf_send_els(struct zfcp_send_els *els)
+int zfcp_fsf_send_els(struct zfcp_send_els *els, unsigned int timeout)
 {
 	struct zfcp_fsf_req *req;
 	struct zfcp_qdio *qdio = els->adapter->qdio;
@@ -1201,7 +1204,7 @@ int zfcp_fsf_send_els(struct zfcp_send_e
 	}
 
 	req->status |= ZFCP_STATUS_FSFREQ_CLEANUP;
-	ret = zfcp_fsf_setup_ct_els(req, els->req, els->resp, 2);
+	ret = zfcp_fsf_setup_ct_els(req, els->req, els->resp, 2, timeout);
 
 	if (ret)
 		goto failed_send;

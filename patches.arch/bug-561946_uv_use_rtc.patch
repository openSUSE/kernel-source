From: Dimitri Sivanich <sivanich@sgi.com>
Subject: x86: UV RTC: Always enable RTC clocksource
References: bnc#561946, fate#306952
Patch-mainline: 2.6.33-rc1
Git-commit: 581f202bcd60acbc3af1f5faa429e570c512f8a3

Always enable the RTC clocksource on UV systems.

Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---

 arch/x86/kernel/uv_time.c |   17 ++++++-----------
 1 file changed, 6 insertions(+), 11 deletions(-)

Index: linux-2.6.32-master/arch/x86/kernel/uv_time.c
===================================================================
--- linux-2.6.32-master.orig/arch/x86/kernel/uv_time.c
+++ linux-2.6.32-master/arch/x86/kernel/uv_time.c
@@ -74,7 +74,6 @@ struct uv_rtc_timer_head {
  */
 static struct uv_rtc_timer_head		**blade_info __read_mostly;
 
-static int				uv_rtc_enable;
 static int				uv_rtc_evt_enable;
 
 /*
@@ -335,14 +334,6 @@ static void uv_rtc_interrupt(void)
 	ced->event_handler(ced);
 }
 
-static int __init uv_enable_rtc(char *str)
-{
-	uv_rtc_enable = 1;
-
-	return 1;
-}
-__setup("uvrtc", uv_enable_rtc);
-
 static int __init uv_enable_evt_rtc(char *str)
 {
 	uv_rtc_evt_enable = 1;
@@ -364,12 +355,16 @@ static __init int uv_rtc_setup_clock(voi
 {
 	int rc;
 
-	if (!uv_rtc_enable || !is_uv_system() || x86_platform_ipi_callback)
+	if (!is_uv_system())
 		return -ENODEV;
 
 	clocksource_uv.mult = clocksource_hz2mult(sn_rtc_cycles_per_second,
 				clocksource_uv.shift);
 
+	/* If single blade, prefer tsc */
+	if (uv_num_possible_blades() == 1)
+		clocksource_uv.rating = 250;
+
 	rc = clocksource_register(&clocksource_uv);
 	if (rc)
 		printk(KERN_INFO "UV RTC clocksource failed rc %d\n", rc);
@@ -377,7 +372,7 @@ static __init int uv_rtc_setup_clock(voi
 		printk(KERN_INFO "UV RTC clocksource registered freq %lu MHz\n",
 			sn_rtc_cycles_per_second/(unsigned long)1E6);
 
-	if (rc || !uv_rtc_evt_enable)
+	if (rc || !uv_rtc_evt_enable || x86_platform_ipi_callback)
 		return rc;
 
 	/* Setup and register clockevents */

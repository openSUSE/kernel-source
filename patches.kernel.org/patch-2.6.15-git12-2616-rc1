From: mainline
Subject: 2.6.16-rc1

Acked-by: olh@suse.de

diff -purN linux-2.6.15-git12/Documentation/block/barrier.txt linux-2.6.16-rc1/Documentation/block/barrier.txt
--- linux-2.6.15-git12/Documentation/block/barrier.txt	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/Documentation/block/barrier.txt	2006-01-17 08:22:41.708440661 +0000
@@ -0,0 +1,271 @@
+I/O Barriers
+============
+Tejun Heo <htejun@gmail.com>, July 22 2005
+
+I/O barrier requests are used to guarantee ordering around the barrier
+requests.  Unless you're crazy enough to use disk drives for
+implementing synchronization constructs (wow, sounds interesting...),
+the ordering is meaningful only for write requests for things like
+journal checkpoints.  All requests queued before a barrier request
+must be finished (made it to the physical medium) before the barrier
+request is started, and all requests queued after the barrier request
+must be started only after the barrier request is finished (again,
+made it to the physical medium).
+
+In other words, I/O barrier requests have the following two properties.
+
+1. Request ordering
+
+Requests cannot pass the barrier request.  Preceding requests are
+processed before the barrier and following requests after.
+
+Depending on what features a drive supports, this can be done in one
+of the following three ways.
+
+i. For devices which have queue depth greater than 1 (TCQ devices) and
+support ordered tags, block layer can just issue the barrier as an
+ordered request and the lower level driver, controller and drive
+itself are responsible for making sure that the ordering contraint is
+met.  Most modern SCSI controllers/drives should support this.
+
+NOTE: SCSI ordered tag isn't currently used due to limitation in the
+      SCSI midlayer, see the following random notes section.
+
+ii. For devices which have queue depth greater than 1 but don't
+support ordered tags, block layer ensures that the requests preceding
+a barrier request finishes before issuing the barrier request.  Also,
+it defers requests following the barrier until the barrier request is
+finished.  Older SCSI controllers/drives and SATA drives fall in this
+category.
+
+iii. Devices which have queue depth of 1.  This is a degenerate case
+of ii.  Just keeping issue order suffices.  Ancient SCSI
+controllers/drives and IDE drives are in this category.
+
+2. Forced flushing to physcial medium
+
+Again, if you're not gonna do synchronization with disk drives (dang,
+it sounds even more appealing now!), the reason you use I/O barriers
+is mainly to protect filesystem integrity when power failure or some
+other events abruptly stop the drive from operating and possibly make
+the drive lose data in its cache.  So, I/O barriers need to guarantee
+that requests actually get written to non-volatile medium in order.
+
+There are four cases,
+
+i. No write-back cache.  Keeping requests ordered is enough.
+
+ii. Write-back cache but no flush operation.  There's no way to
+gurantee physical-medium commit order.  This kind of devices can't to
+I/O barriers.
+
+iii. Write-back cache and flush operation but no FUA (forced unit
+access).  We need two cache flushes - before and after the barrier
+request.
+
+iv. Write-back cache, flush operation and FUA.  We still need one
+flush to make sure requests preceding a barrier are written to medium,
+but post-barrier flush can be avoided by using FUA write on the
+barrier itself.
+
+
+How to support barrier requests in drivers
+------------------------------------------
+
+All barrier handling is done inside block layer proper.  All low level
+drivers have to are implementing its prepare_flush_fn and using one
+the following two functions to indicate what barrier type it supports
+and how to prepare flush requests.  Note that the term 'ordered' is
+used to indicate the whole sequence of performing barrier requests
+including draining and flushing.
+
+typedef void (prepare_flush_fn)(request_queue_t *q, struct request *rq);
+
+int blk_queue_ordered(request_queue_t *q, unsigned ordered,
+		      prepare_flush_fn *prepare_flush_fn,
+		      unsigned gfp_mask);
+
+int blk_queue_ordered_locked(request_queue_t *q, unsigned ordered,
+			     prepare_flush_fn *prepare_flush_fn,
+			     unsigned gfp_mask);
+
+The only difference between the two functions is whether or not the
+caller is holding q->queue_lock on entry.  The latter expects the
+caller is holding the lock.
+
+@q			: the queue in question
+@ordered		: the ordered mode the driver/device supports
+@prepare_flush_fn	: this function should prepare @rq such that it
+			  flushes cache to physical medium when executed
+@gfp_mask		: gfp_mask used when allocating data structures
+			  for ordered processing
+
+For example, SCSI disk driver's prepare_flush_fn looks like the
+following.
+
+static void sd_prepare_flush(request_queue_t *q, struct request *rq)
+{
+	memset(rq->cmd, 0, sizeof(rq->cmd));
+	rq->flags |= REQ_BLOCK_PC;
+	rq->timeout = SD_TIMEOUT;
+	rq->cmd[0] = SYNCHRONIZE_CACHE;
+}
+
+The following seven ordered modes are supported.  The following table
+shows which mode should be used depending on what features a
+device/driver supports.  In the leftmost column of table,
+QUEUE_ORDERED_ prefix is omitted from the mode names to save space.
+
+The table is followed by description of each mode.  Note that in the
+descriptions of QUEUE_ORDERED_DRAIN*, '=>' is used whereas '->' is
+used for QUEUE_ORDERED_TAG* descriptions.  '=>' indicates that the
+preceding step must be complete before proceeding to the next step.
+'->' indicates that the next step can start as soon as the previous
+step is issued.
+
+	    write-back cache	ordered tag	flush		FUA
+-----------------------------------------------------------------------
+NONE		yes/no		N/A		no		N/A
+DRAIN		no		no		N/A		N/A
+DRAIN_FLUSH	yes		no		yes		no
+DRAIN_FUA	yes		no		yes		yes
+TAG		no		yes		N/A		N/A
+TAG_FLUSH	yes		yes		yes		no
+TAG_FUA		yes		yes		yes		yes
+
+
+QUEUE_ORDERED_NONE
+	I/O barriers are not needed and/or supported.
+
+	Sequence: N/A
+
+QUEUE_ORDERED_DRAIN
+	Requests are ordered by draining the request queue and cache
+	flushing isn't needed.
+
+	Sequence: drain => barrier
+
+QUEUE_ORDERED_DRAIN_FLUSH
+	Requests are ordered by draining the request queue and both
+	pre-barrier and post-barrier cache flushings are needed.
+
+	Sequence: drain => preflush => barrier => postflush
+
+QUEUE_ORDERED_DRAIN_FUA
+	Requests are ordered by draining the request queue and
+	pre-barrier cache flushing is needed.  By using FUA on barrier
+	request, post-barrier flushing can be skipped.
+
+	Sequence: drain => preflush => barrier
+
+QUEUE_ORDERED_TAG
+	Requests are ordered by ordered tag and cache flushing isn't
+	needed.
+
+	Sequence: barrier
+
+QUEUE_ORDERED_TAG_FLUSH
+	Requests are ordered by ordered tag and both pre-barrier and
+	post-barrier cache flushings are needed.
+
+	Sequence: preflush -> barrier -> postflush
+
+QUEUE_ORDERED_TAG_FUA
+	Requests are ordered by ordered tag and pre-barrier cache
+	flushing is needed.  By using FUA on barrier request,
+	post-barrier flushing can be skipped.
+
+	Sequence: preflush -> barrier
+
+
+Random notes/caveats
+--------------------
+
+* SCSI layer currently can't use TAG ordering even if the drive,
+controller and driver support it.  The problem is that SCSI midlayer
+request dispatch function is not atomic.  It releases queue lock and
+switch to SCSI host lock during issue and it's possible and likely to
+happen in time that requests change their relative positions.  Once
+this problem is solved, TAG ordering can be enabled.
+
+* Currently, no matter which ordered mode is used, there can be only
+one barrier request in progress.  All I/O barriers are held off by
+block layer until the previous I/O barrier is complete.  This doesn't
+make any difference for DRAIN ordered devices, but, for TAG ordered
+devices with very high command latency, passing multiple I/O barriers
+to low level *might* be helpful if they are very frequent.  Well, this
+certainly is a non-issue.  I'm writing this just to make clear that no
+two I/O barrier is ever passed to low-level driver.
+
+* Completion order.  Requests in ordered sequence are issued in order
+but not required to finish in order.  Barrier implementation can
+handle out-of-order completion of ordered sequence.  IOW, the requests
+MUST be processed in order but the hardware/software completion paths
+are allowed to reorder completion notifications - eg. current SCSI
+midlayer doesn't preserve completion order during error handling.
+
+* Requeueing order.  Low-level drivers are free to requeue any request
+after they removed it from the request queue with
+blkdev_dequeue_request().  As barrier sequence should be kept in order
+when requeued, generic elevator code takes care of putting requests in
+order around barrier.  See blk_ordered_req_seq() and
+ELEVATOR_INSERT_REQUEUE handling in __elv_add_request() for details.
+
+Note that block drivers must not requeue preceding requests while
+completing latter requests in an ordered sequence.  Currently, no
+error checking is done against this.
+
+* Error handling.  Currently, block layer will report error to upper
+layer if any of requests in an ordered sequence fails.  Unfortunately,
+this doesn't seem to be enough.  Look at the following request flow.
+QUEUE_ORDERED_TAG_FLUSH is in use.
+
+ [0] [1] [2] [3] [pre] [barrier] [post] < [4] [5] [6] ... >
+					  still in elevator
+
+Let's say request [2], [3] are write requests to update file system
+metadata (journal or whatever) and [barrier] is used to mark that
+those updates are valid.  Consider the following sequence.
+
+ i.	Requests [0] ~ [post] leaves the request queue and enters
+	low-level driver.
+ ii.	After a while, unfortunately, something goes wrong and the
+	drive fails [2].  Note that any of [0], [1] and [3] could have
+	completed by this time, but [pre] couldn't have been finished
+	as the drive must process it in order and it failed before
+	processing that command.
+ iii.	Error handling kicks in and determines that the error is
+	unrecoverable and fails [2], and resumes operation.
+ iv.	[pre] [barrier] [post] gets processed.
+ v.	*BOOM* power fails
+
+The problem here is that the barrier request is *supposed* to indicate
+that filesystem update requests [2] and [3] made it safely to the
+physical medium and, if the machine crashes after the barrier is
+written, filesystem recovery code can depend on that.  Sadly, that
+isn't true in this case anymore.  IOW, the success of a I/O barrier
+should also be dependent on success of some of the preceding requests,
+where only upper layer (filesystem) knows what 'some' is.
+
+This can be solved by implementing a way to tell the block layer which
+requests affect the success of the following barrier request and
+making lower lever drivers to resume operation on error only after
+block layer tells it to do so.
+
+As the probability of this happening is very low and the drive should
+be faulty, implementing the fix is probably an overkill.  But, still,
+it's there.
+
+* In previous drafts of barrier implementation, there was fallback
+mechanism such that, if FUA or ordered TAG fails, less fancy ordered
+mode can be selected and the failed barrier request is retried
+automatically.  The rationale for this feature was that as FUA is
+pretty new in ATA world and ordered tag was never used widely, there
+could be devices which report to support those features but choke when
+actually given such requests.
+
+ This was removed for two reasons 1. it's an overkill 2. it's
+impossible to implement properly when TAG ordering is used as low
+level drivers resume after an error automatically.  If it's ever
+needed adding it back and modifying low level drivers accordingly
+shouldn't be difficult.
diff -purN linux-2.6.15-git12/Documentation/filesystems/fuse.txt linux-2.6.16-rc1/Documentation/filesystems/fuse.txt
--- linux-2.6.15-git12/Documentation/filesystems/fuse.txt	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/Documentation/filesystems/fuse.txt	2006-01-17 08:22:41.763432002 +0000
@@ -86,6 +86,62 @@ Mount options
   The default is infinite.  Note that the size of read requests is
   limited anyway to 32 pages (which is 128kbyte on i386).
 
+Sysfs
+~~~~~
+
+FUSE sets up the following hierarchy in sysfs:
+
+  /sys/fs/fuse/connections/N/
+
+where N is an increasing number allocated to each new connection.
+
+For each connection the following attributes are defined:
+
+ 'waiting'
+
+  The number of requests which are waiting to be transfered to
+  userspace or being processed by the filesystem daemon.  If there is
+  no filesystem activity and 'waiting' is non-zero, then the
+  filesystem is hung or deadlocked.
+
+ 'abort'
+
+  Writing anything into this file will abort the filesystem
+  connection.  This means that all waiting requests will be aborted an
+  error returned for all aborted and new requests.
+
+Only a privileged user may read or write these attributes.
+
+Aborting a filesystem connection
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+It is possible to get into certain situations where the filesystem is
+not responding.  Reasons for this may be:
+
+  a) Broken userspace filesystem implementation
+
+  b) Network connection down
+
+  c) Accidental deadlock
+
+  d) Malicious deadlock
+
+(For more on c) and d) see later sections)
+
+In either of these cases it may be useful to abort the connection to
+the filesystem.  There are several ways to do this:
+
+  - Kill the filesystem daemon.  Works in case of a) and b)
+
+  - Kill the filesystem daemon and all users of the filesystem.  Works
+    in all cases except some malicious deadlocks
+
+  - Use forced umount (umount -f).  Works in all cases but only if
+    filesystem is still attached (it hasn't been lazy unmounted)
+
+  - Abort filesystem through the sysfs interface.  Most powerful
+    method, always works.
+
 How do non-privileged mounts work?
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -313,3 +369,10 @@ faulted with get_user_pages().  The 'req
 when the copy is taking place, and interruption is delayed until
 this flag is unset.
 
+Scenario 3 - Tricky deadlock with asynchronous read
+---------------------------------------------------
+
+The same situation as above, except thread-1 will wait on page lock
+and hence it will be uninterruptible as well.  The solution is to
+abort the connection with forced umount (if mount is attached) or
+through the abort attribute in sysfs.
diff -purN linux-2.6.15-git12/Documentation/video4linux/CARDLIST.tuner linux-2.6.16-rc1/Documentation/video4linux/CARDLIST.tuner
--- linux-2.6.15-git12/Documentation/video4linux/CARDLIST.tuner	2006-01-17 08:21:26.182876656 +0000
+++ linux-2.6.16-rc1/Documentation/video4linux/CARDLIST.tuner	2006-01-17 08:22:41.939404295 +0000
@@ -68,3 +68,4 @@ tuner=66 - LG NTSC (TALN mini series)
 tuner=67 - Philips TD1316 Hybrid Tuner
 tuner=68 - Philips TUV1236D ATSC/NTSC dual in
 tuner=69 - Tena TNF 5335 MF
+tuner=70 - Samsung TCPN 2121P30A
diff -purN linux-2.6.15-git12/Makefile linux-2.6.16-rc1/Makefile
--- linux-2.6.15-git12/Makefile	2006-01-17 08:21:26.198874137 +0000
+++ linux-2.6.16-rc1/Makefile	2006-01-17 08:22:41.956401619 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
-SUBLEVEL = 15
-EXTRAVERSION = -git12
+SUBLEVEL = 16
+EXTRAVERSION =-rc1
 NAME=Sliding Snow Leopard
 
 # *DOCUMENTATION*
@@ -106,12 +106,13 @@ KBUILD_OUTPUT := $(shell cd $(KBUILD_OUT
 $(if $(KBUILD_OUTPUT),, \
      $(error output directory "$(saved-output)" does not exist))
 
-.PHONY: $(MAKECMDGOALS)
+.PHONY: $(MAKECMDGOALS) cdbuilddir
+$(MAKECMDGOALS) _all: cdbuilddir
 
-$(filter-out _all,$(MAKECMDGOALS)) _all:
+cdbuilddir:
 	$(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT) \
 	KBUILD_SRC=$(CURDIR) \
-	KBUILD_EXTMOD="$(KBUILD_EXTMOD)" -f $(CURDIR)/Makefile $@
+	KBUILD_EXTMOD="$(KBUILD_EXTMOD)" -f $(CURDIR)/Makefile $(MAKECMDGOALS)
 
 # Leave processing to above invocation of make
 skip-makefile := 1
@@ -262,6 +263,13 @@ export quiet Q KBUILD_VERBOSE
 # cc support functions to be used (only) in arch/$(ARCH)/Makefile
 # See documentation in Documentation/kbuild/makefiles.txt
 
+# as-option
+# Usage: cflags-y += $(call as-option, -Wa$(comma)-isa=foo,)
+
+as-option = $(shell if $(CC) $(CFLAGS) $(1) -Wa,-Z -c -o /dev/null \
+	     -xassembler /dev/null > /dev/null 2>&1; then echo "$(1)"; \
+	     else echo "$(2)"; fi ;)
+
 # cc-option
 # Usage: cflags-y += $(call cc-option, -march=winchip-c6, -march=i586)
 
@@ -337,8 +345,9 @@ AFLAGS		:= -D__ASSEMBLY__
 
 # Read KERNELRELEASE from .kernelrelease (if it exists)
 KERNELRELEASE = $(shell cat .kernelrelease 2> /dev/null)
+KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-export	VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE \
+export	VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION \
 	ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC \
 	CPP AR NM STRIP OBJCOPY OBJDUMP MAKE AWK GENKSYMS PERL UTS_MACHINE \
 	HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
@@ -433,6 +442,7 @@ export KBUILD_DEFCONFIG
 config %config: scripts_basic outputmakefile FORCE
 	$(Q)mkdir -p include/linux
 	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+	$(Q)$(MAKE) .kernelrelease
 
 else
 # ===========================================================================
@@ -542,7 +552,7 @@ export	INSTALL_PATH ?= /boot
 # makefile but the arguement can be passed to make if needed.
 #
 
-MODLIB	:= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
+MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
 export MODLIB
 
 
@@ -783,12 +793,10 @@ endif
 localver-full = $(localver)$(localver-auto)
 
 # Store (new) KERNELRELASE string in .kernelrelease
-kernelrelease = \
-       $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(localver-full)
+kernelrelease = $(KERNELVERSION)$(localver-full)
 .kernelrelease: FORCE
-	$(Q)rm -f .kernelrelease
-	$(Q)echo $(kernelrelease) > .kernelrelease
-	$(Q)echo "  Building kernel $(kernelrelease)"
+	$(Q)rm -f $@
+	$(Q)echo $(kernelrelease) > $@
 
 
 # Things we need to do before we recursively start building the kernel
@@ -898,7 +906,7 @@ define filechk_version.h
 	)
 endef
 
-include/linux/version.h: $(srctree)/Makefile FORCE
+include/linux/version.h: $(srctree)/Makefile .config FORCE
 	$(call filechk,version.h)
 
 # ---------------------------------------------------------------------------
@@ -1301,9 +1309,10 @@ checkstack:
 	$(PERL) $(src)/scripts/checkstack.pl $(ARCH)
 
 kernelrelease:
-	@echo $(KERNELRELEASE)
+	$(if $(wildcard .kernelrelease), $(Q)echo $(KERNELRELEASE), \
+	$(error kernelrelease not valid - run 'make *config' to update it))
 kernelversion:
-	@echo $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+	@echo $(KERNELVERSION)
 
 # FIXME Should go into a make.lib or something 
 # ===========================================================================
diff -purN linux-2.6.15-git12/README linux-2.6.16-rc1/README
--- linux-2.6.15-git12/README	2006-01-17 08:21:26.199873980 +0000
+++ linux-2.6.16-rc1/README	2006-01-17 08:22:41.959401147 +0000
@@ -1,4 +1,4 @@
-	Linux kernel release 2.6.xx
+	Linux kernel release 2.6.xx <http://kernel.org>
 
 These are the release notes for Linux version 2.6.  Read them carefully,
 as they tell you what this is all about, explain how to install the
@@ -6,23 +6,31 @@ kernel, and what to do if something goes
 
 WHAT IS LINUX?
 
-  Linux is a Unix clone written from scratch by Linus Torvalds with
-  assistance from a loosely-knit team of hackers across the Net.
-  It aims towards POSIX compliance. 
-
-  It has all the features you would expect in a modern fully-fledged
-  Unix, including true multitasking, virtual memory, shared libraries,
-  demand loading, shared copy-on-write executables, proper memory
-  management and TCP/IP networking. 
+  Linux is a clone of the operating system Unix, written from scratch by
+  Linus Torvalds with assistance from a loosely-knit team of hackers across
+  the Net. It aims towards POSIX and Single UNIX Specification compliance.
+
+  It has all the features you would expect in a modern fully-fledged Unix,
+  including true multitasking, virtual memory, shared libraries, demand
+  loading, shared copy-on-write executables, proper memory management,
+  and multistack networking including IPv4 and IPv6.
 
   It is distributed under the GNU General Public License - see the
   accompanying COPYING file for more details. 
 
 ON WHAT HARDWARE DOES IT RUN?
 
-  Linux was first developed for 386/486-based PCs.  These days it also
-  runs on ARMs, DEC Alphas, SUN Sparcs, M68000 machines (like Atari and
-  Amiga), MIPS and PowerPC, and others.
+  Although originally developed first for 32-bit x86-based PCs (386 or higher),
+  today Linux also runs on (at least) the Compaq Alpha AXP, Sun SPARC and
+  UltraSPARC, Motorola 68000, PowerPC, PowerPC64, ARM, Hitachi SuperH,
+  IBM S/390, MIPS, HP PA-RISC, Intel IA-64, DEC VAX, AMD x86-64, AXIS CRIS,
+  and Renesas M32R architectures.
+
+  Linux is easily portable to most general-purpose 32- or 64-bit architectures
+  as long as they have a paged memory management unit (PMMU) and a port of the
+  GNU C compiler (gcc) (part of The GNU Compiler Collection, GCC). Linux has
+  also been ported to a number of architectures without a PMMU, although
+  functionality is then obviously somewhat limited.
 
 DOCUMENTATION:
 
diff -purN linux-2.6.15-git12/arch/arm26/kernel/irq.c linux-2.6.16-rc1/arch/arm26/kernel/irq.c
--- linux-2.6.15-git12/arch/arm26/kernel/irq.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/arm26/kernel/irq.c	2006-01-17 08:22:42.434458275 +0000
@@ -141,7 +141,7 @@ int show_interrupts(struct seq_file *p, 
 	if (i < NR_IRQS) {
 	    	action = irq_desc[i].action;
 		if (!action)
-			continue;
+			goto out;
 		seq_printf(p, "%3d: %10u ", i, kstat_irqs(i));
 		seq_printf(p, "  %s", action->name);
 		for (action = action->next; action; action = action->next) {
@@ -152,6 +152,7 @@ int show_interrupts(struct seq_file *p, 
 		show_fiq_list(p, v);
 		seq_printf(p, "Err: %10lu\n", irq_err_count);
 	}
+out:
 	return 0;
 }
 
diff -purN linux-2.6.15-git12/arch/arm26/kernel/ptrace.c linux-2.6.16-rc1/arch/arm26/kernel/ptrace.c
--- linux-2.6.15-git12/arch/arm26/kernel/ptrace.c	2006-01-17 08:21:28.439783000 +0000
+++ linux-2.6.16-rc1/arch/arm26/kernel/ptrace.c	2006-01-17 08:22:42.438457645 +0000
@@ -527,7 +527,7 @@ static int ptrace_getfpregs(struct task_
 static int ptrace_setfpregs(struct task_struct *tsk, void *ufp)
 {
 	set_stopped_child_used_math(tsk);
-	return copy_from_user(&task_threas_info(tsk)->fpstate, ufp,
+	return copy_from_user(&task_thread_info(tsk)->fpstate, ufp,
 			      sizeof(struct user_fp)) ? -EFAULT : 0;
 }
 
diff -purN linux-2.6.15-git12/arch/i386/Makefile linux-2.6.16-rc1/arch/i386/Makefile
--- linux-2.6.15-git12/arch/i386/Makefile	2006-01-17 08:21:28.516770878 +0000
+++ linux-2.6.16-rc1/arch/i386/Makefile	2006-01-17 08:22:42.520444736 +0000
@@ -37,10 +37,7 @@ CFLAGS += $(call cc-option,-mpreferred-s
 # CPU-specific tuning. Anything which can be shared with UML should go here.
 include $(srctree)/arch/i386/Makefile.cpu
 
-# -mregparm=3 works ok on gcc-3.0 and later
-#
-cflags-$(CONFIG_REGPARM) += $(shell if [ $(call cc-version) -ge 0300 ] ; then \
-                            echo "-mregparm=3"; fi ;)
+cflags-$(CONFIG_REGPARM) += -mregparm=3
 
 # Disable unit-at-a-time mode on pre-gcc-4.0 compilers, it makes gcc use
 # a lot more stack due to the lack of sharing of stacklots:
diff -purN linux-2.6.15-git12/arch/i386/kernel/cpu/cpufreq/powernow-k8.c linux-2.6.16-rc1/arch/i386/kernel/cpu/cpufreq/powernow-k8.c
--- linux-2.6.15-git12/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2006-01-17 08:21:28.556764581 +0000
+++ linux-2.6.16-rc1/arch/i386/kernel/cpu/cpufreq/powernow-k8.c	2006-01-17 08:22:42.560438439 +0000
@@ -980,7 +980,7 @@ static int powernowk8_verify(struct cpuf
 }
 
 /* per CPU init entry point to the driver */
-static int __init powernowk8_cpu_init(struct cpufreq_policy *pol)
+static int __cpuinit powernowk8_cpu_init(struct cpufreq_policy *pol)
 {
 	struct powernow_k8_data *data;
 	cpumask_t oldmask = CPU_MASK_ALL;
@@ -1141,7 +1141,7 @@ static struct cpufreq_driver cpufreq_amd
 };
 
 /* driver entry point for init */
-static int __init powernowk8_init(void)
+static int __cpuinit powernowk8_init(void)
 {
 	unsigned int i, supported_cpus = 0;
 
diff -purN linux-2.6.15-git12/arch/i386/mm/init.c linux-2.6.16-rc1/arch/i386/mm/init.c
--- linux-2.6.15-git12/arch/i386/mm/init.c	2006-01-17 08:21:28.628753247 +0000
+++ linux-2.6.16-rc1/arch/i386/mm/init.c	2006-01-17 08:22:42.634426789 +0000
@@ -268,7 +268,7 @@ static void __init permanent_kmaps_init(
 	pkmap_page_table = pte;	
 }
 
-static void __devinit free_new_highpage(struct page *page)
+static void __meminit free_new_highpage(struct page *page)
 {
 	set_page_count(page, 1);
 	__free_page(page);
diff -purN linux-2.6.15-git12/arch/ia64/kernel/perfmon.c linux-2.6.16-rc1/arch/ia64/kernel/perfmon.c
--- linux-2.6.15-git12/arch/ia64/kernel/perfmon.c	2006-01-17 08:21:28.690743487 +0000
+++ linux-2.6.16-rc1/arch/ia64/kernel/perfmon.c	2006-01-17 08:22:42.698416714 +0000
@@ -628,9 +628,11 @@ static int pfm_write_ibr_dbr(int mode, p
 
 #include "perfmon_itanium.h"
 #include "perfmon_mckinley.h"
+#include "perfmon_montecito.h"
 #include "perfmon_generic.h"
 
 static pmu_config_t *pmu_confs[]={
+	&pmu_conf_mont,
 	&pmu_conf_mck,
 	&pmu_conf_ita,
 	&pmu_conf_gen, /* must be last */
diff -purN linux-2.6.15-git12/arch/ia64/kernel/perfmon_montecito.h linux-2.6.16-rc1/arch/ia64/kernel/perfmon_montecito.h
--- linux-2.6.15-git12/arch/ia64/kernel/perfmon_montecito.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/kernel/perfmon_montecito.h	2006-01-17 08:22:42.704415770 +0000
@@ -0,0 +1,269 @@
+/*
+ * This file contains the Montecito PMU register description tables
+ * and pmc checker used by perfmon.c.
+ *
+ * Copyright (c) 2005-2006 Hewlett-Packard Development Company, L.P.
+ *               Contributed by Stephane Eranian <eranian@hpl.hp.com>
+ */
+static int pfm_mont_pmc_check(struct task_struct *task, pfm_context_t *ctx, unsigned int cnum, unsigned long *val, struct pt_regs *regs);
+
+#define RDEP_MONT_ETB	(RDEP(38)|RDEP(39)|RDEP(48)|RDEP(49)|RDEP(50)|RDEP(51)|RDEP(52)|RDEP(53)|RDEP(54)|\
+			 RDEP(55)|RDEP(56)|RDEP(57)|RDEP(58)|RDEP(59)|RDEP(60)|RDEP(61)|RDEP(62)|RDEP(63))
+#define RDEP_MONT_DEAR  (RDEP(32)|RDEP(33)|RDEP(36))
+#define RDEP_MONT_IEAR  (RDEP(34)|RDEP(35))
+
+static pfm_reg_desc_t pfm_mont_pmc_desc[PMU_MAX_PMCS]={
+/* pmc0  */ { PFM_REG_CONTROL , 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc1  */ { PFM_REG_CONTROL , 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc2  */ { PFM_REG_CONTROL , 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc3  */ { PFM_REG_CONTROL , 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc4  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(4),0, 0, 0}, {0,0, 0, 0}},
+/* pmc5  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(5),0, 0, 0}, {0,0, 0, 0}},
+/* pmc6  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(6),0, 0, 0}, {0,0, 0, 0}},
+/* pmc7  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(7),0, 0, 0}, {0,0, 0, 0}},
+/* pmc8  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(8),0, 0, 0}, {0,0, 0, 0}},
+/* pmc9  */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(9),0, 0, 0}, {0,0, 0, 0}},
+/* pmc10 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(10),0, 0, 0}, {0,0, 0, 0}},
+/* pmc11 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(11),0, 0, 0}, {0,0, 0, 0}},
+/* pmc12 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(12),0, 0, 0}, {0,0, 0, 0}},
+/* pmc13 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(13),0, 0, 0}, {0,0, 0, 0}},
+/* pmc14 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(14),0, 0, 0}, {0,0, 0, 0}},
+/* pmc15 */ { PFM_REG_COUNTING, 6, 0x2000000, 0x7c7fff7f, NULL, pfm_mont_pmc_check, {RDEP(15),0, 0, 0}, {0,0, 0, 0}},
+/* pmc16 */ { PFM_REG_NOTIMPL, },
+/* pmc17 */ { PFM_REG_NOTIMPL, },
+/* pmc18 */ { PFM_REG_NOTIMPL, },
+/* pmc19 */ { PFM_REG_NOTIMPL, },
+/* pmc20 */ { PFM_REG_NOTIMPL, },
+/* pmc21 */ { PFM_REG_NOTIMPL, },
+/* pmc22 */ { PFM_REG_NOTIMPL, },
+/* pmc23 */ { PFM_REG_NOTIMPL, },
+/* pmc24 */ { PFM_REG_NOTIMPL, },
+/* pmc25 */ { PFM_REG_NOTIMPL, },
+/* pmc26 */ { PFM_REG_NOTIMPL, },
+/* pmc27 */ { PFM_REG_NOTIMPL, },
+/* pmc28 */ { PFM_REG_NOTIMPL, },
+/* pmc29 */ { PFM_REG_NOTIMPL, },
+/* pmc30 */ { PFM_REG_NOTIMPL, },
+/* pmc31 */ { PFM_REG_NOTIMPL, },
+/* pmc32 */ { PFM_REG_CONFIG,  0, 0x30f01ffffffffff, 0x30f01ffffffffff, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc33 */ { PFM_REG_CONFIG,  0, 0x0,  0x1ffffffffff, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc34 */ { PFM_REG_CONFIG,  0, 0xf01ffffffffff, 0xf01ffffffffff, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc35 */ { PFM_REG_CONFIG,  0, 0x0,  0x1ffffffffff, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc36 */ { PFM_REG_CONFIG,  0, 0xfffffff0, 0xf, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc37 */ { PFM_REG_MONITOR, 4, 0x0, 0x3fff, NULL, pfm_mont_pmc_check, {RDEP_MONT_IEAR, 0, 0, 0}, {0, 0, 0, 0}},
+/* pmc38 */ { PFM_REG_CONFIG,  0, 0xdb6, 0x2492, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc39 */ { PFM_REG_MONITOR, 6, 0x0, 0xffcf, NULL, pfm_mont_pmc_check, {RDEP_MONT_ETB,0, 0, 0}, {0,0, 0, 0}},
+/* pmc40 */ { PFM_REG_MONITOR, 6, 0x2000000, 0xf01cf, NULL, pfm_mont_pmc_check, {RDEP_MONT_DEAR,0, 0, 0}, {0,0, 0, 0}},
+/* pmc41 */ { PFM_REG_CONFIG,  0, 0x00002078fefefefe, 0x1e00018181818, NULL, pfm_mont_pmc_check, {0,0, 0, 0}, {0,0, 0, 0}},
+/* pmc42 */ { PFM_REG_MONITOR, 6, 0x0, 0x7ff4f, NULL, pfm_mont_pmc_check, {RDEP_MONT_ETB,0, 0, 0}, {0,0, 0, 0}},
+	    { PFM_REG_END    , 0, 0x0, -1, NULL, NULL, {0,}, {0,}}, /* end marker */
+};
+
+static pfm_reg_desc_t pfm_mont_pmd_desc[PMU_MAX_PMDS]={
+/* pmd0  */ { PFM_REG_NOTIMPL, }, 
+/* pmd1  */ { PFM_REG_NOTIMPL, },
+/* pmd2  */ { PFM_REG_NOTIMPL, },
+/* pmd3  */ { PFM_REG_NOTIMPL, },
+/* pmd4  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(4),0, 0, 0}},
+/* pmd5  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(5),0, 0, 0}},
+/* pmd6  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(6),0, 0, 0}},
+/* pmd7  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(7),0, 0, 0}},
+/* pmd8  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(8),0, 0, 0}}, 
+/* pmd9  */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(9),0, 0, 0}},
+/* pmd10 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(10),0, 0, 0}},
+/* pmd11 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(11),0, 0, 0}},
+/* pmd12 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(12),0, 0, 0}},
+/* pmd13 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(13),0, 0, 0}},
+/* pmd14 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(14),0, 0, 0}},
+/* pmd15 */ { PFM_REG_COUNTING, 0, 0x0, -1, NULL, NULL, {0,0, 0, 0}, {RDEP(15),0, 0, 0}},
+/* pmd16 */ { PFM_REG_NOTIMPL, },
+/* pmd17 */ { PFM_REG_NOTIMPL, },
+/* pmd18 */ { PFM_REG_NOTIMPL, },
+/* pmd19 */ { PFM_REG_NOTIMPL, },
+/* pmd20 */ { PFM_REG_NOTIMPL, },
+/* pmd21 */ { PFM_REG_NOTIMPL, },
+/* pmd22 */ { PFM_REG_NOTIMPL, },
+/* pmd23 */ { PFM_REG_NOTIMPL, },
+/* pmd24 */ { PFM_REG_NOTIMPL, },
+/* pmd25 */ { PFM_REG_NOTIMPL, },
+/* pmd26 */ { PFM_REG_NOTIMPL, },
+/* pmd27 */ { PFM_REG_NOTIMPL, },
+/* pmd28 */ { PFM_REG_NOTIMPL, },
+/* pmd29 */ { PFM_REG_NOTIMPL, },
+/* pmd30 */ { PFM_REG_NOTIMPL, },
+/* pmd31 */ { PFM_REG_NOTIMPL, },
+/* pmd32 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP(33)|RDEP(36),0, 0, 0}, {RDEP(40),0, 0, 0}},
+/* pmd33 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP(32)|RDEP(36),0, 0, 0}, {RDEP(40),0, 0, 0}},
+/* pmd34 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP(35),0, 0, 0}, {RDEP(37),0, 0, 0}},
+/* pmd35 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP(34),0, 0, 0}, {RDEP(37),0, 0, 0}},
+/* pmd36 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP(32)|RDEP(33),0, 0, 0}, {RDEP(40),0, 0, 0}},
+/* pmd37 */ { PFM_REG_NOTIMPL, },
+/* pmd38 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd39 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd40 */ { PFM_REG_NOTIMPL, },
+/* pmd41 */ { PFM_REG_NOTIMPL, },
+/* pmd42 */ { PFM_REG_NOTIMPL, },
+/* pmd43 */ { PFM_REG_NOTIMPL, },
+/* pmd44 */ { PFM_REG_NOTIMPL, },
+/* pmd45 */ { PFM_REG_NOTIMPL, },
+/* pmd46 */ { PFM_REG_NOTIMPL, },
+/* pmd47 */ { PFM_REG_NOTIMPL, },
+/* pmd48 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd49 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd50 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd51 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd52 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd53 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd54 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd55 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd56 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd57 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd58 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd59 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd60 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd61 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd62 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+/* pmd63 */ { PFM_REG_BUFFER, 0, 0x0, -1, NULL, NULL, {RDEP_MONT_ETB,0, 0, 0}, {RDEP(39),0, 0, 0}},
+	    { PFM_REG_END   , 0, 0x0, -1, NULL, NULL, {0,}, {0,}}, /* end marker */
+};
+
+/*
+ * PMC reserved fields must have their power-up values preserved
+ */
+static int
+pfm_mont_reserved(unsigned int cnum, unsigned long *val, struct pt_regs *regs)
+{
+	unsigned long tmp1, tmp2, ival = *val;
+
+	/* remove reserved areas from user value */
+	tmp1 = ival & PMC_RSVD_MASK(cnum);
+
+	/* get reserved fields values */
+	tmp2 = PMC_DFL_VAL(cnum) & ~PMC_RSVD_MASK(cnum);
+
+	*val = tmp1 | tmp2;
+
+	DPRINT(("pmc[%d]=0x%lx, mask=0x%lx, reset=0x%lx, val=0x%lx\n",
+		  cnum, ival, PMC_RSVD_MASK(cnum), PMC_DFL_VAL(cnum), *val));
+	return 0;
+}
+
+/*
+ * task can be NULL if the context is unloaded
+ */
+static int
+pfm_mont_pmc_check(struct task_struct *task, pfm_context_t *ctx, unsigned int cnum, unsigned long *val, struct pt_regs *regs)
+{
+	int ret = 0;
+	unsigned long val32 = 0, val38 = 0, val41 = 0;
+	unsigned long tmpval;
+	int check_case1 = 0;
+	int is_loaded;
+
+	/* first preserve the reserved fields */
+	pfm_mont_reserved(cnum, val, regs);
+
+	tmpval = *val;
+
+	/* sanity check */
+	if (ctx == NULL) return -EINVAL;
+
+	is_loaded = ctx->ctx_state == PFM_CTX_LOADED || ctx->ctx_state == PFM_CTX_MASKED;
+
+	/*
+	 * we must clear the debug registers if pmc41 has a value which enable
+	 * memory pipeline event constraints. In this case we need to clear the
+	 * the debug registers if they have not yet been accessed. This is required
+	 * to avoid picking stale state.
+	 * PMC41 is "active" if:
+	 * 	one of the pmc41.cfg_dtagXX field is different from 0x3
+	 * AND
+	 * 	at the corresponding pmc41.en_dbrpXX is set.
+	 * AND
+	 *	ctx_fl_using_dbreg == 0  (i.e., dbr not yet used)
+	 */
+	DPRINT(("cnum=%u val=0x%lx, using_dbreg=%d loaded=%d\n", cnum, tmpval, ctx->ctx_fl_using_dbreg, is_loaded));
+
+	if (cnum == 41 && is_loaded 
+	    && (tmpval & 0x1e00000000000) && (tmpval & 0x18181818UL) != 0x18181818UL && ctx->ctx_fl_using_dbreg == 0) {
+
+		DPRINT(("pmc[%d]=0x%lx has active pmc41 settings, clearing dbr\n", cnum, tmpval));
+
+		/* don't mix debug with perfmon */
+		if (task && (task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/*
+		 * a count of 0 will mark the debug registers if:
+		 * AND
+		 */
+		ret = pfm_write_ibr_dbr(PFM_DATA_RR, ctx, NULL, 0, regs);
+		if (ret) return ret;
+	}
+	/*
+	 * we must clear the (instruction) debug registers if:
+	 * 	pmc38.ig_ibrpX is 0 (enabled)
+	 * AND
+	 *	ctx_fl_using_dbreg == 0  (i.e., dbr not yet used)
+	 */
+	if (cnum == 38 && is_loaded && ((tmpval & 0x492UL) != 0x492UL) && ctx->ctx_fl_using_dbreg == 0) {
+
+		DPRINT(("pmc38=0x%lx has active pmc38 settings, clearing ibr\n", tmpval));
+
+		/* don't mix debug with perfmon */
+		if (task && (task->thread.flags & IA64_THREAD_DBG_VALID) != 0) return -EINVAL;
+
+		/*
+		 * a count of 0 will mark the debug registers as in use and also
+		 * ensure that they are properly cleared.
+		 */
+		ret = pfm_write_ibr_dbr(PFM_CODE_RR, ctx, NULL, 0, regs);
+		if (ret) return ret;
+
+	}
+	switch(cnum) {
+		case  32: val32 = *val;
+			  val38 = ctx->ctx_pmcs[38];
+			  val41 = ctx->ctx_pmcs[41];
+			  check_case1 = 1;
+			  break;
+		case  38: val38 = *val;
+			  val32 = ctx->ctx_pmcs[32];
+			  val41 = ctx->ctx_pmcs[41];
+			  check_case1 = 1;
+			  break;
+		case  41: val41 = *val;
+			  val32 = ctx->ctx_pmcs[32];
+			  val38 = ctx->ctx_pmcs[38];
+			  check_case1 = 1;
+			  break;
+	}
+	/* check illegal configuration which can produce inconsistencies in tagging
+	 * i-side events in L1D and L2 caches
+	 */
+	if (check_case1) {
+		ret =   (((val41 >> 45) & 0xf) == 0 && ((val32>>57) & 0x1) == 0)
+		     && ((((val38>>1) & 0x3) == 0x2 || ((val38>>1) & 0x3) == 0)
+		     ||  (((val38>>4) & 0x3) == 0x2 || ((val38>>4) & 0x3) == 0));
+		if (ret) {
+			DPRINT(("invalid config pmc38=0x%lx pmc41=0x%lx pmc32=0x%lx\n", val38, val41, val32));
+			return -EINVAL;
+		}
+	}
+	*val = tmpval;
+	return 0;
+}
+
+/*
+ * impl_pmcs, impl_pmds are computed at runtime to minimize errors!
+ */
+static pmu_config_t pmu_conf_mont={
+	.pmu_name        = "Montecito",
+	.pmu_family      = 0x20,
+	.flags           = PFM_PMU_IRQ_RESEND,
+	.ovfl_val        = (1UL << 47) - 1,
+	.pmd_desc        = pfm_mont_pmd_desc,
+	.pmc_desc        = pfm_mont_pmc_desc,
+	.num_ibrs        = 8,
+	.num_dbrs        = 8,
+	.use_rr_dbregs   = 1 /* debug register are use for range retrictions */
+};
diff -purN linux-2.6.15-git12/arch/ia64/mm/init.c linux-2.6.16-rc1/arch/ia64/mm/init.c
--- linux-2.6.15-git12/arch/ia64/mm/init.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/mm/init.c	2006-01-17 08:22:42.726412306 +0000
@@ -635,3 +635,39 @@ mem_init (void)
 	ia32_mem_init();
 #endif
 }
+
+#ifdef CONFIG_MEMORY_HOTPLUG
+void online_page(struct page *page)
+{
+	ClearPageReserved(page);
+	set_page_count(page, 1);
+	__free_page(page);
+	totalram_pages++;
+	num_physpages++;
+}
+
+int add_memory(u64 start, u64 size)
+{
+	pg_data_t *pgdat;
+	struct zone *zone;
+	unsigned long start_pfn = start >> PAGE_SHIFT;
+	unsigned long nr_pages = size >> PAGE_SHIFT;
+	int ret;
+
+	pgdat = NODE_DATA(0);
+
+	zone = pgdat->node_zones + ZONE_NORMAL;
+	ret = __add_pages(zone, start_pfn, nr_pages);
+
+	if (ret)
+		printk("%s: Problem encountered in __add_pages() as ret=%d\n",
+		       __FUNCTION__,  ret);
+
+	return ret;
+}
+
+int remove_memory(u64 start, u64 size)
+{
+	return -EINVAL;
+}
+#endif
diff -purN linux-2.6.15-git12/arch/ia64/pci/pci.c linux-2.6.16-rc1/arch/ia64/pci/pci.c
--- linux-2.6.15-git12/arch/ia64/pci/pci.c	2006-01-17 08:21:28.713739866 +0000
+++ linux-2.6.16-rc1/arch/ia64/pci/pci.c	2006-01-17 08:22:42.730411676 +0000
@@ -454,14 +454,13 @@ static int __devinit is_valid_resource(s
 	return 0;
 }
 
-static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev)
+static void __devinit
+pcibios_fixup_resources(struct pci_dev *dev, int start, int limit)
 {
 	struct pci_bus_region region;
 	int i;
-	int limit = (dev->hdr_type == PCI_HEADER_TYPE_NORMAL) ? \
-		PCI_BRIDGE_RESOURCES : PCI_NUM_RESOURCES;
 
-	for (i = 0; i < limit; i++) {
+	for (i = start; i < limit; i++) {
 		if (!dev->resource[i].flags)
 			continue;
 		region.start = dev->resource[i].start;
@@ -472,6 +471,16 @@ static void __devinit pcibios_fixup_devi
 	}
 }
 
+static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev)
+{
+	pcibios_fixup_resources(dev, 0, PCI_BRIDGE_RESOURCES);
+}
+
+static void __devinit pcibios_fixup_bridge_resources(struct pci_dev *dev)
+{
+	pcibios_fixup_resources(dev, PCI_BRIDGE_RESOURCES, PCI_NUM_RESOURCES);
+}
+
 /*
  *  Called after each bus is probed, but before its children are examined.
  */
@@ -482,7 +491,7 @@ pcibios_fixup_bus (struct pci_bus *b)
 
 	if (b->self) {
 		pci_read_bridge_bases(b);
-		pcibios_fixup_device_resources(b->self);
+		pcibios_fixup_bridge_resources(b->self);
 	}
 	list_for_each_entry(dev, &b->devices, bus_list)
 		pcibios_fixup_device_resources(dev);
diff -purN linux-2.6.15-git12/arch/ia64/sn/include/xtalk/hubdev.h linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/hubdev.h
--- linux-2.6.15-git12/arch/ia64/sn/include/xtalk/hubdev.h	2006-01-17 08:21:28.714739708 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/hubdev.h	2006-01-17 08:22:42.732411362 +0000
@@ -40,8 +40,8 @@ struct sn_flush_device_common {
 	unsigned long sfdl_force_int_addr;
 	unsigned long sfdl_flush_value;
 	volatile unsigned long *sfdl_flush_addr;
-	uint32_t sfdl_persistent_busnum;
-	uint32_t sfdl_persistent_segment;
+	u32 sfdl_persistent_busnum;
+	u32 sfdl_persistent_segment;
 	struct pcibus_info *sfdl_pcibus_info;
 };
 
@@ -56,7 +56,7 @@ struct sn_flush_device_kernel {
  */
 struct sn_flush_nasid_entry  {
 	struct sn_flush_device_kernel **widget_p; // Used as an array of wid_num
-	uint64_t iio_itte[8];
+	u64 iio_itte[8];
 };
 
 struct hubdev_info {
@@ -70,8 +70,8 @@ struct hubdev_info {
 
 	void				*hdi_nodepda;
 	void				*hdi_node_vertex;
-	uint32_t			max_segment_number;
-	uint32_t			max_pcibus_number;
+	u32				max_segment_number;
+	u32				max_pcibus_number;
 };
 
 extern void hubdev_init_node(nodepda_t *, cnodeid_t);
diff -purN linux-2.6.15-git12/arch/ia64/sn/include/xtalk/xbow.h linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/xbow.h
--- linux-2.6.15-git12/arch/ia64/sn/include/xtalk/xbow.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/xbow.h	2006-01-17 08:22:42.737410574 +0000
@@ -3,7 +3,8 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1992-1997,2000-2004 Silicon Graphics, Inc. All Rights Reserved.
+ * Copyright (C) 1992-1997,2000-2006 Silicon Graphics, Inc. All Rights
+ * Reserved.
  */
 #ifndef _ASM_IA64_SN_XTALK_XBOW_H
 #define _ASM_IA64_SN_XTALK_XBOW_H
@@ -21,94 +22,94 @@
 
 /* Register set for each xbow link */
 typedef volatile struct xb_linkregs_s {
-/* 
+/*
  * we access these through synergy unswizzled space, so the address
  * gets twiddled (i.e. references to 0x4 actually go to 0x0 and vv.)
  * That's why we put the register first and filler second.
  */
-    uint32_t               link_ibf;
-    uint32_t               filler0;	/* filler for proper alignment */
-    uint32_t               link_control;
-    uint32_t               filler1;
-    uint32_t               link_status;
-    uint32_t               filler2;
-    uint32_t               link_arb_upper;
-    uint32_t               filler3;
-    uint32_t               link_arb_lower;
-    uint32_t               filler4;
-    uint32_t               link_status_clr;
-    uint32_t               filler5;
-    uint32_t               link_reset;
-    uint32_t               filler6;
-    uint32_t               link_aux_status;
-    uint32_t               filler7;
+	u32 link_ibf;
+	u32 filler0;	/* filler for proper alignment */
+	u32 link_control;
+	u32 filler1;
+	u32 link_status;
+	u32 filler2;
+	u32 link_arb_upper;
+	u32 filler3;
+	u32 link_arb_lower;
+	u32 filler4;
+	u32 link_status_clr;
+	u32 filler5;
+	u32 link_reset;
+	u32 filler6;
+	u32 link_aux_status;
+	u32 filler7;
 } xb_linkregs_t;
 
 typedef volatile struct xbow_s {
-    /* standard widget configuration                       0x000000-0x000057 */
-    struct widget_cfg            xb_widget;  /* 0x000000 */
+	/* standard widget configuration 0x000000-0x000057 */
+	struct widget_cfg xb_widget;  /* 0x000000 */
 
-    /* helper fieldnames for accessing bridge widget */
+	/* helper fieldnames for accessing bridge widget */
 
-#define xb_wid_id                       xb_widget.w_id
-#define xb_wid_stat                     xb_widget.w_status
-#define xb_wid_err_upper                xb_widget.w_err_upper_addr
-#define xb_wid_err_lower                xb_widget.w_err_lower_addr
-#define xb_wid_control                  xb_widget.w_control
-#define xb_wid_req_timeout              xb_widget.w_req_timeout
-#define xb_wid_int_upper                xb_widget.w_intdest_upper_addr
-#define xb_wid_int_lower                xb_widget.w_intdest_lower_addr
-#define xb_wid_err_cmdword              xb_widget.w_err_cmd_word
-#define xb_wid_llp                      xb_widget.w_llp_cfg
-#define xb_wid_stat_clr                 xb_widget.w_tflush
+#define xb_wid_id 		xb_widget.w_id
+#define xb_wid_stat 		xb_widget.w_status
+#define xb_wid_err_upper 	xb_widget.w_err_upper_addr
+#define xb_wid_err_lower 	xb_widget.w_err_lower_addr
+#define xb_wid_control		xb_widget.w_control
+#define xb_wid_req_timeout 	xb_widget.w_req_timeout
+#define xb_wid_int_upper 	xb_widget.w_intdest_upper_addr
+#define xb_wid_int_lower 	xb_widget.w_intdest_lower_addr
+#define xb_wid_err_cmdword 	xb_widget.w_err_cmd_word
+#define xb_wid_llp 		xb_widget.w_llp_cfg
+#define xb_wid_stat_clr 	xb_widget.w_tflush
 
-/* 
+/*
  * we access these through synergy unswizzled space, so the address
  * gets twiddled (i.e. references to 0x4 actually go to 0x0 and vv.)
  * That's why we put the register first and filler second.
  */
-    /* xbow-specific widget configuration                  0x000058-0x0000FF */
-    uint32_t               xb_wid_arb_reload;  /* 0x00005C */
-    uint32_t               _pad_000058;
-    uint32_t               xb_perf_ctr_a;      /* 0x000064 */
-    uint32_t               _pad_000060;
-    uint32_t               xb_perf_ctr_b;      /* 0x00006c */
-    uint32_t               _pad_000068;
-    uint32_t               xb_nic;     /* 0x000074 */
-    uint32_t               _pad_000070;
-
-    /* Xbridge only */
-    uint32_t               xb_w0_rst_fnc;      /* 0x00007C */
-    uint32_t               _pad_000078;
-    uint32_t               xb_l8_rst_fnc;      /* 0x000084 */
-    uint32_t               _pad_000080;
-    uint32_t               xb_l9_rst_fnc;      /* 0x00008c */
-    uint32_t               _pad_000088;
-    uint32_t               xb_la_rst_fnc;      /* 0x000094 */
-    uint32_t               _pad_000090;
-    uint32_t               xb_lb_rst_fnc;      /* 0x00009c */
-    uint32_t               _pad_000098;
-    uint32_t               xb_lc_rst_fnc;      /* 0x0000a4 */
-    uint32_t               _pad_0000a0;
-    uint32_t               xb_ld_rst_fnc;      /* 0x0000ac */
-    uint32_t               _pad_0000a8;
-    uint32_t               xb_le_rst_fnc;      /* 0x0000b4 */
-    uint32_t               _pad_0000b0;
-    uint32_t               xb_lf_rst_fnc;      /* 0x0000bc */
-    uint32_t               _pad_0000b8;
-    uint32_t               xb_lock;            /* 0x0000c4 */
-    uint32_t               _pad_0000c0;
-    uint32_t               xb_lock_clr;        /* 0x0000cc */
-    uint32_t               _pad_0000c8;
-    /* end of Xbridge only */
-    uint32_t               _pad_0000d0[12];
-
-    /* Link Specific Registers, port 8..15                 0x000100-0x000300 */
-    xb_linkregs_t           xb_link_raw[MAX_XBOW_PORTS];
-#define xb_link(p)      xb_link_raw[(p) & (MAX_XBOW_PORTS - 1)]
+	/* xbow-specific widget configuration    0x000058-0x0000FF */
+	u32 xb_wid_arb_reload; /* 0x00005C */
+	u32 _pad_000058;
+	u32 xb_perf_ctr_a;	/* 0x000064 */
+	u32 _pad_000060;
+	u32 xb_perf_ctr_b;	/* 0x00006c */
+	u32 _pad_000068;
+	u32 xb_nic;		/* 0x000074 */
+	u32 _pad_000070;
+
+	/* Xbridge only */
+	u32 xb_w0_rst_fnc;	/* 0x00007C */
+	u32 _pad_000078;
+	u32 xb_l8_rst_fnc;	/* 0x000084 */
+	u32 _pad_000080;
+	u32 xb_l9_rst_fnc;	/* 0x00008c */
+	u32 _pad_000088;
+	u32 xb_la_rst_fnc;	/* 0x000094 */
+	u32 _pad_000090;
+	u32 xb_lb_rst_fnc;	/* 0x00009c */
+	u32 _pad_000098;
+	u32 xb_lc_rst_fnc;	/* 0x0000a4 */
+	u32 _pad_0000a0;
+	u32 xb_ld_rst_fnc;	/* 0x0000ac */
+	u32 _pad_0000a8;
+	u32 xb_le_rst_fnc;	/* 0x0000b4 */
+	u32 _pad_0000b0;
+	u32 xb_lf_rst_fnc;	/* 0x0000bc */
+	u32 _pad_0000b8;
+	u32 xb_lock;		/* 0x0000c4 */
+	u32 _pad_0000c0;
+	u32 xb_lock_clr;	/* 0x0000cc */
+	u32 _pad_0000c8;
+	/* end of Xbridge only */
+	u32 _pad_0000d0[12];
 
+	/* Link Specific Registers, port 8..15   0x000100-0x000300 */
+	xb_linkregs_t xb_link_raw[MAX_XBOW_PORTS];
 } xbow_t;
 
+#define xb_link(p) xb_link_raw[(p) & (MAX_XBOW_PORTS - 1)]
+
 #define XB_FLAGS_EXISTS		0x1	/* device exists */
 #define XB_FLAGS_MASTER		0x2
 #define XB_FLAGS_SLAVE		0x0
@@ -160,7 +161,7 @@ typedef volatile struct xbow_s {
 /* End of Xbridge only */
 
 /* used only in ide, but defined here within the reserved portion */
-/*              of the widget0 address space (before 0xf4) */
+/* of the widget0 address space (before 0xf4) */
 #define	XBOW_WID_UNDEF		0xe4
 
 /* xbow link register set base, legal value for x is 0x8..0xf */
@@ -179,29 +180,37 @@ typedef volatile struct xbow_s {
 
 /* link_control(x) */
 #define	XB_CTRL_LINKALIVE_IE		0x80000000	/* link comes alive */
-     /* reserved:			0x40000000 */
+/* reserved:			0x40000000 */
 #define	XB_CTRL_PERF_CTR_MODE_MSK	0x30000000	/* perf counter mode */
-#define	XB_CTRL_IBUF_LEVEL_MSK		0x0e000000	/* input packet buffer level */
-#define	XB_CTRL_8BIT_MODE		0x01000000	/* force link into 8 bit mode */
-#define XB_CTRL_BAD_LLP_PKT		0x00800000	/* force bad LLP packet */
-#define XB_CTRL_WIDGET_CR_MSK		0x007c0000	/* LLP widget credit mask */
-#define XB_CTRL_WIDGET_CR_SHFT	18			/* LLP widget credit shift */
-#define XB_CTRL_ILLEGAL_DST_IE		0x00020000	/* illegal destination */
-#define XB_CTRL_OALLOC_IBUF_IE		0x00010000	/* overallocated input buffer */
-     /* reserved:			0x0000fe00 */
+#define	XB_CTRL_IBUF_LEVEL_MSK		0x0e000000	/* input packet buffer
+							   level */
+#define	XB_CTRL_8BIT_MODE		0x01000000	/* force link into 8
+							   bit mode */
+#define XB_CTRL_BAD_LLP_PKT		0x00800000	/* force bad LLP
+							   packet */
+#define XB_CTRL_WIDGET_CR_MSK		0x007c0000	/* LLP widget credit
+							   mask */
+#define XB_CTRL_WIDGET_CR_SHFT	18			/* LLP widget credit
+							   shift */
+#define XB_CTRL_ILLEGAL_DST_IE		0x00020000	/* illegal destination
+							 */
+#define XB_CTRL_OALLOC_IBUF_IE		0x00010000	/* overallocated input
+							   buffer */
+/* reserved:			0x0000fe00 */
 #define XB_CTRL_BNDWDTH_ALLOC_IE	0x00000100	/* bandwidth alloc */
 #define XB_CTRL_RCV_CNT_OFLOW_IE	0x00000080	/* rcv retry overflow */
 #define XB_CTRL_XMT_CNT_OFLOW_IE	0x00000040	/* xmt retry overflow */
 #define XB_CTRL_XMT_MAX_RTRY_IE		0x00000020	/* max transmit retry */
 #define XB_CTRL_RCV_IE			0x00000010	/* receive */
 #define XB_CTRL_XMT_RTRY_IE		0x00000008	/* transmit retry */
-     /* reserved:			0x00000004 */
-#define	XB_CTRL_MAXREQ_TOUT_IE		0x00000002	/* maximum request timeout */
+/* reserved:			0x00000004 */
+#define	XB_CTRL_MAXREQ_TOUT_IE		0x00000002	/* maximum request
+							   timeout */
 #define	XB_CTRL_SRC_TOUT_IE		0x00000001	/* source timeout */
 
 /* link_status(x) */
 #define	XB_STAT_LINKALIVE		XB_CTRL_LINKALIVE_IE
-     /* reserved:			0x7ff80000 */
+/* reserved:			0x7ff80000 */
 #define	XB_STAT_MULTI_ERR		0x00040000	/* multi error */
 #define	XB_STAT_ILLEGAL_DST_ERR		XB_CTRL_ILLEGAL_DST_IE
 #define	XB_STAT_OALLOC_IBUF_ERR		XB_CTRL_OALLOC_IBUF_IE
@@ -211,7 +220,7 @@ typedef volatile struct xbow_s {
 #define	XB_STAT_XMT_MAX_RTRY_ERR	XB_CTRL_XMT_MAX_RTRY_IE
 #define	XB_STAT_RCV_ERR			XB_CTRL_RCV_IE
 #define	XB_STAT_XMT_RTRY_ERR		XB_CTRL_XMT_RTRY_IE
-     /* reserved:			0x00000004 */
+/* reserved:			0x00000004 */
 #define	XB_STAT_MAXREQ_TOUT_ERR		XB_CTRL_MAXREQ_TOUT_IE
 #define	XB_STAT_SRC_TOUT_ERR		XB_CTRL_SRC_TOUT_IE
 
@@ -222,7 +231,7 @@ typedef volatile struct xbow_s {
 #define	XB_AUX_LINKFAIL_RST_BAD	0x00000040
 #define	XB_AUX_STAT_PRESENT	0x00000020
 #define	XB_AUX_STAT_PORT_WIDTH	0x00000010
-     /*	reserved:		0x0000000f */
+/*	reserved:		0x0000000f */
 
 /*
  * link_arb_upper/link_arb_lower(x), (reg) should be the link_arb_upper
@@ -238,7 +247,8 @@ typedef volatile struct xbow_s {
 /* XBOW_WID_STAT */
 #define	XB_WID_STAT_LINK_INTR_SHFT	(24)
 #define	XB_WID_STAT_LINK_INTR_MASK	(0xFF << XB_WID_STAT_LINK_INTR_SHFT)
-#define	XB_WID_STAT_LINK_INTR(x)	(0x1 << (((x)&7) + XB_WID_STAT_LINK_INTR_SHFT))
+#define	XB_WID_STAT_LINK_INTR(x) \
+	(0x1 << (((x)&7) + XB_WID_STAT_LINK_INTR_SHFT))
 #define	XB_WID_STAT_WIDGET0_INTR	0x00800000
 #define XB_WID_STAT_SRCID_MASK		0x000003c0	/* Xbridge only */
 #define	XB_WID_STAT_REG_ACC_ERR		0x00000020
@@ -264,7 +274,7 @@ typedef volatile struct xbow_s {
 #define XXBOW_WIDGET_PART_NUM	0xd000		/* Xbridge */
 #define	XBOW_WIDGET_MFGR_NUM	0x0
 #define	XXBOW_WIDGET_MFGR_NUM	0x0
-#define PXBOW_WIDGET_PART_NUM   0xd100          /* PIC */
+#define PXBOW_WIDGET_PART_NUM   0xd100		/* PIC */
 
 #define	XBOW_REV_1_0		0x1	/* xbow rev 1.0 is "1" */
 #define	XBOW_REV_1_1		0x2	/* xbow rev 1.1 is "2" */
@@ -279,13 +289,13 @@ typedef volatile struct xbow_s {
 #define	XBOW_WID_ARB_RELOAD_INT	0x3f	/* GBR reload interval */
 
 #define IS_XBRIDGE_XBOW(wid) \
-        (XWIDGET_PART_NUM(wid) == XXBOW_WIDGET_PART_NUM && \
-                        XWIDGET_MFG_NUM(wid) == XXBOW_WIDGET_MFGR_NUM)
+	(XWIDGET_PART_NUM(wid) == XXBOW_WIDGET_PART_NUM && \
+	XWIDGET_MFG_NUM(wid) == XXBOW_WIDGET_MFGR_NUM)
 
 #define IS_PIC_XBOW(wid) \
-        (XWIDGET_PART_NUM(wid) == PXBOW_WIDGET_PART_NUM && \
-                        XWIDGET_MFG_NUM(wid) == XXBOW_WIDGET_MFGR_NUM)
+	(XWIDGET_PART_NUM(wid) == PXBOW_WIDGET_PART_NUM && \
+	XWIDGET_MFG_NUM(wid) == XXBOW_WIDGET_MFGR_NUM)
 
 #define XBOW_WAR_ENABLED(pv, widid) ((1 << XWIDGET_REV_NUM(widid)) & pv)
 
-#endif                          /* _ASM_IA64_SN_XTALK_XBOW_H */
+#endif /* _ASM_IA64_SN_XTALK_XBOW_H */
diff -purN linux-2.6.15-git12/arch/ia64/sn/include/xtalk/xwidgetdev.h linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/xwidgetdev.h
--- linux-2.6.15-git12/arch/ia64/sn/include/xtalk/xwidgetdev.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/include/xtalk/xwidgetdev.h	2006-01-17 08:22:42.739410260 +0000
@@ -25,28 +25,28 @@
 
 /* widget configuration registers */
 struct widget_cfg{
-	uint32_t	w_id;	/* 0x04 */
-	uint32_t	w_pad_0;	/* 0x00 */
-	uint32_t	w_status;	/* 0x0c */
-	uint32_t	w_pad_1;	/* 0x08 */
-	uint32_t	w_err_upper_addr;	/* 0x14 */
-	uint32_t	w_pad_2;	/* 0x10 */
-	uint32_t	w_err_lower_addr;	/* 0x1c */
-	uint32_t	w_pad_3;	/* 0x18 */
-	uint32_t	w_control;	/* 0x24 */
-	uint32_t	w_pad_4;	/* 0x20 */
-	uint32_t	w_req_timeout;	/* 0x2c */
-	uint32_t	w_pad_5;	/* 0x28 */
-	uint32_t	w_intdest_upper_addr;	/* 0x34 */
-	uint32_t	w_pad_6;	/* 0x30 */
-	uint32_t	w_intdest_lower_addr;	/* 0x3c */
-	uint32_t	w_pad_7;	/* 0x38 */
-	uint32_t	w_err_cmd_word;	/* 0x44 */
-	uint32_t	w_pad_8;	/* 0x40 */
-	uint32_t	w_llp_cfg;	/* 0x4c */
-	uint32_t	w_pad_9;	/* 0x48 */
-	uint32_t	w_tflush;	/* 0x54 */
-	uint32_t	w_pad_10;	/* 0x50 */
+	u32	w_id;	/* 0x04 */
+	u32	w_pad_0;	/* 0x00 */
+	u32	w_status;	/* 0x0c */
+	u32	w_pad_1;	/* 0x08 */
+	u32	w_err_upper_addr;	/* 0x14 */
+	u32	w_pad_2;	/* 0x10 */
+	u32	w_err_lower_addr;	/* 0x1c */
+	u32	w_pad_3;	/* 0x18 */
+	u32	w_control;	/* 0x24 */
+	u32	w_pad_4;	/* 0x20 */
+	u32	w_req_timeout;	/* 0x2c */
+	u32	w_pad_5;	/* 0x28 */
+	u32	w_intdest_upper_addr;	/* 0x34 */
+	u32	w_pad_6;	/* 0x30 */
+	u32	w_intdest_lower_addr;	/* 0x3c */
+	u32	w_pad_7;	/* 0x38 */
+	u32	w_err_cmd_word;	/* 0x44 */
+	u32	w_pad_8;	/* 0x40 */
+	u32	w_llp_cfg;	/* 0x4c */
+	u32	w_pad_9;	/* 0x48 */
+	u32	w_tflush;	/* 0x54 */
+	u32	w_pad_10;	/* 0x50 */
 };
 
 /*
@@ -63,7 +63,7 @@ struct xwidget_info{
 	struct xwidget_hwid	xwi_hwid;	/* Widget Identification */
 	char			xwi_masterxid;	/* Hub's Widget Port Number */
 	void			*xwi_hubinfo;     /* Hub's provider private info */
-	uint64_t		*xwi_hub_provider; /* prom provider functions */
+	u64			*xwi_hub_provider; /* prom provider functions */
 	void			*xwi_vertex;
 };
 
diff -purN linux-2.6.15-git12/arch/ia64/sn/kernel/io_init.c linux-2.6.16-rc1/arch/ia64/sn/kernel/io_init.c
--- linux-2.6.15-git12/arch/ia64/sn/kernel/io_init.c	2006-01-17 08:21:28.721738606 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/kernel/io_init.c	2006-01-17 08:22:42.745409315 +0000
@@ -132,8 +132,8 @@ static inline u64 sal_get_pcibus_info(u6
  * Retrieve the pci device information given the bus and device|function number.
  */
 static inline u64
-sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev, 
-			u64 sn_irq_info)
+sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,
+		    u64 sn_irq_info)
 {
 	struct ia64_sal_retval ret_stuff;
 	ret_stuff.status = 0;
@@ -141,7 +141,7 @@ sal_get_pcidev_info(u64 segment, u64 bus
 
 	SAL_CALL_NOLOCK(ret_stuff,
 			(u64) SN_SAL_IOIF_GET_PCIDEV_INFO,
-			(u64) segment, (u64) bus_number, (u64) devfn, 
+			(u64) segment, (u64) bus_number, (u64) devfn,
 			(u64) pci_dev,
 			sn_irq_info, 0, 0);
 	return ret_stuff.v0;
@@ -268,7 +268,7 @@ static void sn_fixup_ionodes(void)
  */
 static void
 sn_pci_window_fixup(struct pci_dev *dev, unsigned int count,
-		    int64_t * pci_addrs)
+		    s64 * pci_addrs)
 {
 	struct pci_controller *controller = PCI_CONTROLLER(dev->bus);
 	unsigned int i;
@@ -328,7 +328,7 @@ void sn_pci_fixup_slot(struct pci_dev *d
  	struct pci_bus *host_pci_bus;
  	struct pci_dev *host_pci_dev;
 	struct pcidev_info *pcidev_info;
-	int64_t pci_addrs[PCI_ROM_RESOURCE + 1];
+	s64 pci_addrs[PCI_ROM_RESOURCE + 1];
  	struct sn_irq_info *sn_irq_info;
  	unsigned long size;
  	unsigned int bus_no, devfn;
diff -purN linux-2.6.15-git12/arch/ia64/sn/kernel/irq.c linux-2.6.16-rc1/arch/ia64/sn/kernel/irq.c
--- linux-2.6.15-git12/arch/ia64/sn/kernel/irq.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/kernel/irq.c	2006-01-17 08:22:42.747409000 +0000
@@ -28,7 +28,7 @@ extern int sn_ioif_inited;
 static struct list_head **sn_irq_lh;
 static spinlock_t sn_irq_info_lock = SPIN_LOCK_UNLOCKED; /* non-IRQ lock */
 
-static inline uint64_t sn_intr_alloc(nasid_t local_nasid, int local_widget,
+static inline u64 sn_intr_alloc(nasid_t local_nasid, int local_widget,
 				     u64 sn_irq_info,
 				     int req_irq, nasid_t req_nasid,
 				     int req_slice)
@@ -123,7 +123,7 @@ static void sn_set_affinity_irq(unsigned
 
 	list_for_each_entry_safe(sn_irq_info, sn_irq_info_safe,
 				 sn_irq_lh[irq], list) {
-		uint64_t bridge;
+		u64 bridge;
 		int local_widget, status;
 		nasid_t local_nasid;
 		struct sn_irq_info *new_irq_info;
@@ -134,7 +134,7 @@ static void sn_set_affinity_irq(unsigned
 			break;
 		memcpy(new_irq_info, sn_irq_info, sizeof(struct sn_irq_info));
 
-		bridge = (uint64_t) new_irq_info->irq_bridge;
+		bridge = (u64) new_irq_info->irq_bridge;
 		if (!bridge) {
 			kfree(new_irq_info);
 			break; /* irq is not a device interrupt */
@@ -349,10 +349,10 @@ static void force_interrupt(int irq)
  */
 static void sn_check_intr(int irq, struct sn_irq_info *sn_irq_info)
 {
-	uint64_t regval;
+	u64 regval;
 	int irr_reg_num;
 	int irr_bit;
-	uint64_t irr_reg;
+	u64 irr_reg;
 	struct pcidev_info *pcidev_info;
 	struct pcibus_info *pcibus_info;
 
diff -purN linux-2.6.15-git12/arch/ia64/sn/kernel/tiocx.c linux-2.6.16-rc1/arch/ia64/sn/kernel/tiocx.c
--- linux-2.6.15-git12/arch/ia64/sn/kernel/tiocx.c	2006-01-17 08:21:28.723738292 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/kernel/tiocx.c	2006-01-17 08:22:42.750408528 +0000
@@ -245,7 +245,7 @@ static int cx_device_reload(struct cx_de
 				  cx_dev->bt);
 }
 
-static inline uint64_t tiocx_intr_alloc(nasid_t nasid, int widget,
+static inline u64 tiocx_intr_alloc(nasid_t nasid, int widget,
 					u64 sn_irq_info,
 					int req_irq, nasid_t req_nasid,
 					int req_slice)
@@ -302,7 +302,7 @@ struct sn_irq_info *tiocx_irq_alloc(nasi
 
 void tiocx_irq_free(struct sn_irq_info *sn_irq_info)
 {
-	uint64_t bridge = (uint64_t) sn_irq_info->irq_bridge;
+	u64 bridge = (u64) sn_irq_info->irq_bridge;
 	nasid_t nasid = NASID_GET(bridge);
 	int widget;
 
@@ -313,12 +313,12 @@ void tiocx_irq_free(struct sn_irq_info *
 	}
 }
 
-uint64_t tiocx_dma_addr(uint64_t addr)
+u64 tiocx_dma_addr(u64 addr)
 {
 	return PHYS_TO_TIODMA(addr);
 }
 
-uint64_t tiocx_swin_base(int nasid)
+u64 tiocx_swin_base(int nasid)
 {
 	return TIO_SWIN_BASE(nasid, TIOCX_CORELET);
 }
@@ -335,8 +335,8 @@ EXPORT_SYMBOL(tiocx_swin_base);
 
 static void tio_conveyor_set(nasid_t nasid, int enable_flag)
 {
-	uint64_t ice_frz;
-	uint64_t disable_cb = (1ull << 61);
+	u64 ice_frz;
+	u64 disable_cb = (1ull << 61);
 
 	if (!(nasid & 1))
 		return;
@@ -388,7 +388,7 @@ static int is_fpga_tio(int nasid, int *b
 
 static int bitstream_loaded(nasid_t nasid)
 {
-	uint64_t cx_credits;
+	u64 cx_credits;
 
 	cx_credits = REMOTE_HUB_L(nasid, TIO_ICE_PMI_TX_DYN_CREDIT_STAT_CB3);
 	cx_credits &= TIO_ICE_PMI_TX_DYN_CREDIT_STAT_CB3_CREDIT_CNT_MASK;
@@ -404,14 +404,14 @@ static int tiocx_reload(struct cx_dev *c
 	nasid_t nasid = cx_dev->cx_id.nasid;
 
 	if (bitstream_loaded(nasid)) {
-		uint64_t cx_id;
+		u64 cx_id;
 		int rv;
 
 		rv = ia64_sn_sysctl_tio_clock_reset(nasid);
 		if (rv) {
 			printk(KERN_ALERT "CX port JTAG reset failed.\n");
 		} else {
-			cx_id = *(volatile uint64_t *)
+			cx_id = *(volatile u64 *)
 				(TIO_SWIN_BASE(nasid, TIOCX_CORELET) +
 					  WIDGET_ID);
 			part_num = XWIDGET_PART_NUM(cx_id);
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_ate.c linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_ate.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_ate.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_ate.c	2006-01-17 08:22:42.780403805 +0000
@@ -18,10 +18,10 @@ int pcibr_invalidate_ate = 0;	/* by defa
  * mark_ate: Mark the ate as either free or inuse.
  */
 static void mark_ate(struct ate_resource *ate_resource, int start, int number,
-		     uint64_t value)
+		     u64 value)
 {
 
-	uint64_t *ate = ate_resource->ate;
+	u64 *ate = ate_resource->ate;
 	int index;
 	int length = 0;
 
@@ -38,7 +38,7 @@ static int find_free_ate(struct ate_reso
 			 int count)
 {
 
-	uint64_t *ate = ate_resource->ate;
+	u64 *ate = ate_resource->ate;
 	int index;
 	int start_free;
 
@@ -119,7 +119,7 @@ static inline int alloc_ate_resource(str
 int pcibr_ate_alloc(struct pcibus_info *pcibus_info, int count)
 {
 	int status = 0;
-	uint64_t flag;
+	u64 flag;
 
 	flag = pcibr_lock(pcibus_info);
 	status = alloc_ate_resource(&pcibus_info->pbi_int_ate_resource, count);
@@ -139,7 +139,7 @@ int pcibr_ate_alloc(struct pcibus_info *
  * Setup an Address Translation Entry as specified.  Use either the Bridge
  * internal maps or the external map RAM, as appropriate.
  */
-static inline uint64_t *pcibr_ate_addr(struct pcibus_info *pcibus_info,
+static inline u64 *pcibr_ate_addr(struct pcibus_info *pcibus_info,
 				       int ate_index)
 {
 	if (ate_index < pcibus_info->pbi_int_ate_size) {
@@ -153,7 +153,7 @@ static inline uint64_t *pcibr_ate_addr(s
  */
 void inline
 ate_write(struct pcibus_info *pcibus_info, int ate_index, int count,
-	  volatile uint64_t ate)
+	  volatile u64 ate)
 {
 	while (count-- > 0) {
 		if (ate_index < pcibus_info->pbi_int_ate_size) {
@@ -171,9 +171,9 @@ ate_write(struct pcibus_info *pcibus_inf
 void pcibr_ate_free(struct pcibus_info *pcibus_info, int index)
 {
 
-	volatile uint64_t ate;
+	volatile u64 ate;
 	int count;
-	uint64_t flags;
+	u64 flags;
 
 	if (pcibr_invalidate_ate) {
 		/* For debugging purposes, clear the valid bit in the ATE */
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_dma.c linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_dma.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_dma.c	2006-01-17 08:21:28.753733569 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_dma.c	2006-01-17 08:22:42.783403333 +0000
@@ -41,21 +41,21 @@ extern int sn_ioif_inited;
 
 static dma_addr_t
 pcibr_dmamap_ate32(struct pcidev_info *info,
-		   uint64_t paddr, size_t req_size, uint64_t flags)
+		   u64 paddr, size_t req_size, u64 flags)
 {
 
 	struct pcidev_info *pcidev_info = info->pdi_host_pcidev_info;
 	struct pcibus_info *pcibus_info = (struct pcibus_info *)pcidev_info->
 	    pdi_pcibus_info;
-	uint8_t internal_device = (PCI_SLOT(pcidev_info->pdi_host_pcidev_info->
+	u8 internal_device = (PCI_SLOT(pcidev_info->pdi_host_pcidev_info->
 					    pdi_linux_pcidev->devfn)) - 1;
 	int ate_count;
 	int ate_index;
-	uint64_t ate_flags = flags | PCI32_ATE_V;
-	uint64_t ate;
-	uint64_t pci_addr;
-	uint64_t xio_addr;
-	uint64_t offset;
+	u64 ate_flags = flags | PCI32_ATE_V;
+	u64 ate;
+	u64 pci_addr;
+	u64 xio_addr;
+	u64 offset;
 
 	/* PIC in PCI-X mode does not supports 32bit PageMap mode */
 	if (IS_PIC_SOFT(pcibus_info) && IS_PCIX(pcibus_info)) {
@@ -109,12 +109,12 @@ pcibr_dmamap_ate32(struct pcidev_info *i
 }
 
 static dma_addr_t
-pcibr_dmatrans_direct64(struct pcidev_info * info, uint64_t paddr,
-			uint64_t dma_attributes)
+pcibr_dmatrans_direct64(struct pcidev_info * info, u64 paddr,
+			u64 dma_attributes)
 {
 	struct pcibus_info *pcibus_info = (struct pcibus_info *)
 	    ((info->pdi_host_pcidev_info)->pdi_pcibus_info);
-	uint64_t pci_addr;
+	u64 pci_addr;
 
 	/* Translate to Crosstalk View of Physical Address */
 	pci_addr = (IS_PIC_SOFT(pcibus_info) ? PHYS_TO_DMA(paddr) :
@@ -127,7 +127,7 @@ pcibr_dmatrans_direct64(struct pcidev_in
 	/* Handle Bridge Chipset differences */
 	if (IS_PIC_SOFT(pcibus_info)) {
 		pci_addr |=
-		    ((uint64_t) pcibus_info->
+		    ((u64) pcibus_info->
 		     pbi_hub_xid << PIC_PCI64_ATTR_TARG_SHFT);
 	} else
 		pci_addr |= TIOCP_PCI64_CMDTYPE_MEM;
@@ -142,17 +142,17 @@ pcibr_dmatrans_direct64(struct pcidev_in
 
 static dma_addr_t
 pcibr_dmatrans_direct32(struct pcidev_info * info,
-			uint64_t paddr, size_t req_size, uint64_t flags)
+			u64 paddr, size_t req_size, u64 flags)
 {
 
 	struct pcidev_info *pcidev_info = info->pdi_host_pcidev_info;
 	struct pcibus_info *pcibus_info = (struct pcibus_info *)pcidev_info->
 	    pdi_pcibus_info;
-	uint64_t xio_addr;
+	u64 xio_addr;
 
-	uint64_t xio_base;
-	uint64_t offset;
-	uint64_t endoff;
+	u64 xio_base;
+	u64 offset;
+	u64 endoff;
 
 	if (IS_PCIX(pcibus_info)) {
 		return 0;
@@ -209,14 +209,14 @@ pcibr_dma_unmap(struct pci_dev *hwdev, d
  * unlike the PIC Device(x) Write Request Buffer Flush register.
  */
 
-void sn_dma_flush(uint64_t addr)
+void sn_dma_flush(u64 addr)
 {
 	nasid_t nasid;
 	int is_tio;
 	int wid_num;
 	int i, j;
-	uint64_t flags;
-	uint64_t itte;
+	u64 flags;
+	u64 itte;
 	struct hubdev_info *hubinfo;
 	volatile struct sn_flush_device_kernel *p;
 	volatile struct sn_flush_device_common *common;
@@ -299,8 +299,8 @@ void sn_dma_flush(uint64_t addr)
 		 * If CE ever needs the sn_dma_flush mechanism, we will have
 		 * to account for that here and in tioce_bus_fixup().
 	 	 */
-		uint32_t tio_id = HUB_L(TIO_IOSPACE_ADDR(nasid, TIO_NODE_ID));
-		uint32_t revnum = XWIDGET_PART_REV_NUM(tio_id);
+		u32 tio_id = HUB_L(TIO_IOSPACE_ADDR(nasid, TIO_NODE_ID));
+		u32 revnum = XWIDGET_PART_REV_NUM(tio_id);
 
 		/* TIOCP BRINGUP WAR (PV907516): Don't write buffer flush reg */
 		if ((1 << XWIDGET_PART_REV_NUM_REV(revnum)) & PV907516) {
@@ -315,7 +315,7 @@ void sn_dma_flush(uint64_t addr)
 		*common->sfdl_flush_addr = 0;
 
 		/* force an interrupt. */
-		*(volatile uint32_t *)(common->sfdl_force_int_addr) = 1;
+		*(volatile u32 *)(common->sfdl_force_int_addr) = 1;
 
 		/* wait for the interrupt to come back. */
 		while (*(common->sfdl_flush_addr) != 0x10f)
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_provider.c linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_provider.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_provider.c	2006-01-17 08:21:28.754733411 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_provider.c	2006-01-17 08:22:42.785403018 +0000
@@ -23,7 +23,7 @@ int
 sal_pcibr_slot_enable(struct pcibus_info *soft, int device, void *resp)
 {
 	struct ia64_sal_retval ret_stuff;
-	uint64_t busnum;
+	u64 busnum;
 
 	ret_stuff.status = 0;
 	ret_stuff.v0 = 0;
@@ -40,7 +40,7 @@ sal_pcibr_slot_disable(struct pcibus_inf
 		       void *resp)
 {
 	struct ia64_sal_retval ret_stuff;
-	uint64_t busnum;
+	u64 busnum;
 
 	ret_stuff.status = 0;
 	ret_stuff.v0 = 0;
@@ -56,7 +56,7 @@ sal_pcibr_slot_disable(struct pcibus_inf
 static int sal_pcibr_error_interrupt(struct pcibus_info *soft)
 {
 	struct ia64_sal_retval ret_stuff;
-	uint64_t busnum;
+	u64 busnum;
 	int segment;
 	ret_stuff.status = 0;
 	ret_stuff.v0 = 0;
@@ -159,9 +159,9 @@ pcibr_bus_fixup(struct pcibus_bussoft *p
 	/* Setup the PMU ATE map */
 	soft->pbi_int_ate_resource.lowest_free_index = 0;
 	soft->pbi_int_ate_resource.ate =
-	    kmalloc(soft->pbi_int_ate_size * sizeof(uint64_t), GFP_KERNEL);
+	    kmalloc(soft->pbi_int_ate_size * sizeof(u64), GFP_KERNEL);
 	memset(soft->pbi_int_ate_resource.ate, 0,
- 	       (soft->pbi_int_ate_size * sizeof(uint64_t)));
+ 	       (soft->pbi_int_ate_size * sizeof(u64)));
 
 	if (prom_bussoft->bs_asic_type == PCIIO_ASIC_TYPE_TIOCP) {
 		/* TIO PCI Bridge: find nearest node with CPUs */
@@ -203,7 +203,7 @@ void pcibr_target_interrupt(struct sn_ir
 	struct pcidev_info *pcidev_info;
 	struct pcibus_info *pcibus_info;
 	int bit = sn_irq_info->irq_int_bit;
-	uint64_t xtalk_addr = sn_irq_info->irq_xtalkaddr;
+	u64 xtalk_addr = sn_irq_info->irq_xtalkaddr;
 
 	pcidev_info = (struct pcidev_info *)sn_irq_info->irq_pciioinfo;
 	if (pcidev_info) {
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_reg.c linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_reg.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/pcibr/pcibr_reg.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/pcibr/pcibr_reg.c	2006-01-17 08:22:42.788402546 +0000
@@ -23,7 +23,7 @@ union br_ptr {
 /*
  * Control Register Access -- Read/Write                            0000_0020
  */
-void pcireg_control_bit_clr(struct pcibus_info *pcibus_info, uint64_t bits)
+void pcireg_control_bit_clr(struct pcibus_info *pcibus_info, u64 bits)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -43,7 +43,7 @@ void pcireg_control_bit_clr(struct pcibu
 	}
 }
 
-void pcireg_control_bit_set(struct pcibus_info *pcibus_info, uint64_t bits)
+void pcireg_control_bit_set(struct pcibus_info *pcibus_info, u64 bits)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -66,10 +66,10 @@ void pcireg_control_bit_set(struct pcibu
 /*
  * PCI/PCIX Target Flush Register Access -- Read Only		    0000_0050
  */
-uint64_t pcireg_tflush_get(struct pcibus_info *pcibus_info)
+u64 pcireg_tflush_get(struct pcibus_info *pcibus_info)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
-	uint64_t ret = 0;
+	u64 ret = 0;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -96,10 +96,10 @@ uint64_t pcireg_tflush_get(struct pcibus
 /*
  * Interrupt Status Register Access -- Read Only		    0000_0100
  */
-uint64_t pcireg_intr_status_get(struct pcibus_info * pcibus_info)
+u64 pcireg_intr_status_get(struct pcibus_info * pcibus_info)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
-	uint64_t ret = 0;
+	u64 ret = 0;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -121,7 +121,7 @@ uint64_t pcireg_intr_status_get(struct p
 /*
  * Interrupt Enable Register Access -- Read/Write                   0000_0108
  */
-void pcireg_intr_enable_bit_clr(struct pcibus_info *pcibus_info, uint64_t bits)
+void pcireg_intr_enable_bit_clr(struct pcibus_info *pcibus_info, u64 bits)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -141,7 +141,7 @@ void pcireg_intr_enable_bit_clr(struct p
 	}
 }
 
-void pcireg_intr_enable_bit_set(struct pcibus_info *pcibus_info, uint64_t bits)
+void pcireg_intr_enable_bit_set(struct pcibus_info *pcibus_info, u64 bits)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -165,7 +165,7 @@ void pcireg_intr_enable_bit_set(struct p
  * Intr Host Address Register (int_addr) -- Read/Write  0000_0130 - 0000_0168
  */
 void pcireg_intr_addr_addr_set(struct pcibus_info *pcibus_info, int int_n,
-			       uint64_t addr)
+			       u64 addr)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -217,10 +217,10 @@ void pcireg_force_intr_set(struct pcibus
 /*
  * Device(x) Write Buffer Flush Reg Access -- Read Only 0000_0240 - 0000_0258
  */
-uint64_t pcireg_wrb_flush_get(struct pcibus_info *pcibus_info, int device)
+u64 pcireg_wrb_flush_get(struct pcibus_info *pcibus_info, int device)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
-	uint64_t ret = 0;
+	u64 ret = 0;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
@@ -242,7 +242,7 @@ uint64_t pcireg_wrb_flush_get(struct pci
 }
 
 void pcireg_int_ate_set(struct pcibus_info *pcibus_info, int ate_index,
-			uint64_t val)
+			u64 val)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
 
@@ -262,10 +262,10 @@ void pcireg_int_ate_set(struct pcibus_in
 	}
 }
 
-uint64_t __iomem *pcireg_int_ate_addr(struct pcibus_info *pcibus_info, int ate_index)
+u64 __iomem *pcireg_int_ate_addr(struct pcibus_info *pcibus_info, int ate_index)
 {
 	union br_ptr __iomem *ptr = (union br_ptr __iomem *)pcibus_info->pbi_buscommon.bs_base;
-	uint64_t __iomem *ret = NULL;
+	u64 __iomem *ret = NULL;
 
 	if (pcibus_info) {
 		switch (pcibus_info->pbi_bridge_type) {
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/tioca_provider.c linux-2.6.16-rc1/arch/ia64/sn/pci/tioca_provider.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/tioca_provider.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/tioca_provider.c	2006-01-17 08:22:42.791402073 +0000
@@ -16,7 +16,7 @@
 #include <asm/sn/pcibus_provider_defs.h>
 #include <asm/sn/tioca_provider.h>
 
-uint32_t tioca_gart_found;
+u32 tioca_gart_found;
 EXPORT_SYMBOL(tioca_gart_found);	/* used by agp-sgi */
 
 LIST_HEAD(tioca_list);
@@ -34,8 +34,8 @@ static int tioca_gart_init(struct tioca_
 static int
 tioca_gart_init(struct tioca_kernel *tioca_kern)
 {
-	uint64_t ap_reg;
-	uint64_t offset;
+	u64 ap_reg;
+	u64 offset;
 	struct page *tmp;
 	struct tioca_common *tioca_common;
 	struct tioca __iomem *ca_base;
@@ -214,7 +214,7 @@ void
 tioca_fastwrite_enable(struct tioca_kernel *tioca_kern)
 {
 	int cap_ptr;
-	uint32_t reg;
+	u32 reg;
 	struct tioca __iomem *tioca_base;
 	struct pci_dev *pdev;
 	struct tioca_common *common;
@@ -276,7 +276,7 @@ EXPORT_SYMBOL(tioca_fastwrite_enable);	/
  *                                 We will always use 0x1
  * 55:55 - Swap bytes		   Currently unused
  */
-static uint64_t
+static u64
 tioca_dma_d64(unsigned long paddr)
 {
 	dma_addr_t bus_addr;
@@ -318,15 +318,15 @@ tioca_dma_d64(unsigned long paddr)
  * and so a given CA can only directly target nodes in the range
  * xxx - xxx+255.
  */
-static uint64_t
-tioca_dma_d48(struct pci_dev *pdev, uint64_t paddr)
+static u64
+tioca_dma_d48(struct pci_dev *pdev, u64 paddr)
 {
 	struct tioca_common *tioca_common;
 	struct tioca __iomem *ca_base;
-	uint64_t ct_addr;
+	u64 ct_addr;
 	dma_addr_t bus_addr;
-	uint32_t node_upper;
-	uint64_t agp_dma_extn;
+	u32 node_upper;
+	u64 agp_dma_extn;
 	struct pcidev_info *pcidev_info = SN_PCIDEV_INFO(pdev);
 
 	tioca_common = (struct tioca_common *)pcidev_info->pdi_pcibus_info;
@@ -367,10 +367,10 @@ tioca_dma_d48(struct pci_dev *pdev, uint
  * dma_addr_t is guarenteed to be contiguous in CA bus space.
  */
 static dma_addr_t
-tioca_dma_mapped(struct pci_dev *pdev, uint64_t paddr, size_t req_size)
+tioca_dma_mapped(struct pci_dev *pdev, u64 paddr, size_t req_size)
 {
 	int i, ps, ps_shift, entry, entries, mapsize, last_entry;
-	uint64_t xio_addr, end_xio_addr;
+	u64 xio_addr, end_xio_addr;
 	struct tioca_common *tioca_common;
 	struct tioca_kernel *tioca_kern;
 	dma_addr_t bus_addr = 0;
@@ -514,10 +514,10 @@ tioca_dma_unmap(struct pci_dev *pdev, dm
  * The mapping mode used is based on the devices dma_mask.  As a last resort
  * use the GART mapped mode.
  */
-static uint64_t
-tioca_dma_map(struct pci_dev *pdev, uint64_t paddr, size_t byte_count)
+static u64
+tioca_dma_map(struct pci_dev *pdev, u64 paddr, size_t byte_count)
 {
-	uint64_t mapaddr;
+	u64 mapaddr;
 
 	/*
 	 * If card is 64 or 48 bit addresable, use a direct mapping.  32
@@ -554,8 +554,8 @@ tioca_error_intr_handler(int irq, void *
 {
 	struct tioca_common *soft = arg;
 	struct ia64_sal_retval ret_stuff;
-	uint64_t segment;
-	uint64_t busnum;
+	u64 segment;
+	u64 busnum;
 	ret_stuff.status = 0;
 	ret_stuff.v0 = 0;
 
@@ -620,7 +620,7 @@ tioca_bus_fixup(struct pcibus_bussoft *p
 	INIT_LIST_HEAD(&tioca_kern->ca_dmamaps);
 	tioca_kern->ca_closest_node =
 	    nasid_to_cnodeid(tioca_common->ca_closest_nasid);
-	tioca_common->ca_kernel_private = (uint64_t) tioca_kern;
+	tioca_common->ca_kernel_private = (u64) tioca_kern;
 
 	bus = pci_find_bus(tioca_common->ca_common.bs_persist_segment,
 		tioca_common->ca_common.bs_persist_busnum);
diff -purN linux-2.6.15-git12/arch/ia64/sn/pci/tioce_provider.c linux-2.6.16-rc1/arch/ia64/sn/pci/tioce_provider.c
--- linux-2.6.15-git12/arch/ia64/sn/pci/tioce_provider.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/ia64/sn/pci/tioce_provider.c	2006-01-17 08:22:42.795401444 +0000
@@ -81,10 +81,10 @@
  * 61    - 0 since this is not an MSI transaction
  * 60:54 - reserved, MBZ
  */
-static uint64_t
+static u64
 tioce_dma_d64(unsigned long ct_addr)
 {
-	uint64_t bus_addr;
+	u64 bus_addr;
 
 	bus_addr = ct_addr | (1UL << 63);
 
@@ -141,9 +141,9 @@ pcidev_to_tioce(struct pci_dev *pdev, st
  * length, and if enough resources exist, fill in the ATE's and construct a
  * tioce_dmamap struct to track the mapping.
  */
-static uint64_t
+static u64
 tioce_alloc_map(struct tioce_kernel *ce_kern, int type, int port,
-		uint64_t ct_addr, int len)
+		u64 ct_addr, int len)
 {
 	int i;
 	int j;
@@ -152,11 +152,11 @@ tioce_alloc_map(struct tioce_kernel *ce_
 	int entries;
 	int nates;
 	int pagesize;
-	uint64_t *ate_shadow;
-	uint64_t *ate_reg;
-	uint64_t addr;
+	u64 *ate_shadow;
+	u64 *ate_reg;
+	u64 addr;
 	struct tioce *ce_mmr;
-	uint64_t bus_base;
+	u64 bus_base;
 	struct tioce_dmamap *map;
 
 	ce_mmr = (struct tioce *)ce_kern->ce_common->ce_pcibus.bs_base;
@@ -224,7 +224,7 @@ tioce_alloc_map(struct tioce_kernel *ce_
 
 	addr = ct_addr;
 	for (j = 0; j < nates; j++) {
-		uint64_t ate;
+		u64 ate;
 
 		ate = ATE_MAKE(addr, pagesize);
 		ate_shadow[i + j] = ate;
@@ -252,15 +252,15 @@ tioce_alloc_map(struct tioce_kernel *ce_
  *
  * Map @paddr into 32-bit bus space of the CE associated with @pcidev_info.
  */
-static uint64_t
-tioce_dma_d32(struct pci_dev *pdev, uint64_t ct_addr)
+static u64
+tioce_dma_d32(struct pci_dev *pdev, u64 ct_addr)
 {
 	int dma_ok;
 	int port;
 	struct tioce *ce_mmr;
 	struct tioce_kernel *ce_kern;
-	uint64_t ct_upper;
-	uint64_t ct_lower;
+	u64 ct_upper;
+	u64 ct_lower;
 	dma_addr_t bus_addr;
 
 	ct_upper = ct_addr & ~0x3fffffffUL;
@@ -269,7 +269,7 @@ tioce_dma_d32(struct pci_dev *pdev, uint
 	pcidev_to_tioce(pdev, &ce_mmr, &ce_kern, &port);
 
 	if (ce_kern->ce_port[port].dirmap_refcnt == 0) {
-		uint64_t tmp;
+		u64 tmp;
 
 		ce_kern->ce_port[port].dirmap_shadow = ct_upper;
 		writeq(ct_upper, &ce_mmr->ce_ure_dir_map[port]);
@@ -295,10 +295,10 @@ tioce_dma_d32(struct pci_dev *pdev, uint
  * Given a TIOCE bus address, set the appropriate bit to indicate barrier
  * attributes.
  */
-static uint64_t
-tioce_dma_barrier(uint64_t bus_addr, int on)
+static u64
+tioce_dma_barrier(u64 bus_addr, int on)
 {
-	uint64_t barrier_bit;
+	u64 barrier_bit;
 
 	/* barrier not supported in M40/M40S mode */
 	if (TIOCE_M40_ADDR(bus_addr) || TIOCE_M40S_ADDR(bus_addr))
@@ -351,7 +351,7 @@ tioce_dma_unmap(struct pci_dev *pdev, dm
 
 		list_for_each_entry(map, &ce_kern->ce_dmamap_list,
 				    ce_dmamap_list) {
-			uint64_t last;
+			u64 last;
 
 			last = map->pci_start + map->nbytes - 1;
 			if (bus_addr >= map->pci_start && bus_addr <= last)
@@ -385,17 +385,17 @@ tioce_dma_unmap(struct pci_dev *pdev, dm
  * This is the main wrapper for mapping host physical pages to CE PCI space.
  * The mapping mode used is based on the device's dma_mask.
  */
-static uint64_t
-tioce_do_dma_map(struct pci_dev *pdev, uint64_t paddr, size_t byte_count,
+static u64
+tioce_do_dma_map(struct pci_dev *pdev, u64 paddr, size_t byte_count,
 		 int barrier)
 {
 	unsigned long flags;
-	uint64_t ct_addr;
-	uint64_t mapaddr = 0;
+	u64 ct_addr;
+	u64 mapaddr = 0;
 	struct tioce_kernel *ce_kern;
 	struct tioce_dmamap *map;
 	int port;
-	uint64_t dma_mask;
+	u64 dma_mask;
 
 	dma_mask = (barrier) ? pdev->dev.coherent_dma_mask : pdev->dma_mask;
 
@@ -425,7 +425,7 @@ tioce_do_dma_map(struct pci_dev *pdev, u
 	 * address bits than this device can support.
 	 */
 	list_for_each_entry(map, &ce_kern->ce_dmamap_list, ce_dmamap_list) {
-		uint64_t last;
+		u64 last;
 
 		last = map->ct_start + map->nbytes - 1;
 		if (ct_addr >= map->ct_start &&
@@ -501,8 +501,8 @@ dma_map_done:
  * Simply call tioce_do_dma_map() to create a map with the barrier bit clear
  * in the address.
  */
-static uint64_t
-tioce_dma(struct pci_dev *pdev, uint64_t paddr, size_t byte_count)
+static u64
+tioce_dma(struct pci_dev *pdev, u64 paddr, size_t byte_count)
 {
 	return tioce_do_dma_map(pdev, paddr, byte_count, 0);
 }
@@ -515,8 +515,8 @@ tioce_dma(struct pci_dev *pdev, uint64_t
  *
  * Simply call tioce_do_dma_map() to create a map with the barrier bit set
  * in the address.
- */ static uint64_t
-tioce_dma_consistent(struct pci_dev *pdev, uint64_t paddr, size_t byte_count)
+ */ static u64
+tioce_dma_consistent(struct pci_dev *pdev, u64 paddr, size_t byte_count)
 {
 	return tioce_do_dma_map(pdev, paddr, byte_count, 1);
 }
@@ -551,7 +551,7 @@ tioce_error_intr_handler(int irq, void *
 tioce_kern_init(struct tioce_common *tioce_common)
 {
 	int i;
-	uint32_t tmp;
+	u32 tmp;
 	struct tioce *tioce_mmr;
 	struct tioce_kernel *tioce_kern;
 
@@ -563,7 +563,7 @@ tioce_kern_init(struct tioce_common *tio
 	tioce_kern->ce_common = tioce_common;
 	spin_lock_init(&tioce_kern->ce_lock);
 	INIT_LIST_HEAD(&tioce_kern->ce_dmamap_list);
-	tioce_common->ce_kernel_private = (uint64_t) tioce_kern;
+	tioce_common->ce_kernel_private = (u64) tioce_kern;
 
 	/*
 	 * Determine the secondary bus number of the port2 logical PPB.
@@ -575,7 +575,7 @@ tioce_kern_init(struct tioce_common *tio
 	raw_pci_ops->read(tioce_common->ce_pcibus.bs_persist_segment,
 			  tioce_common->ce_pcibus.bs_persist_busnum,
 			  PCI_DEVFN(2, 0), PCI_SECONDARY_BUS, 1, &tmp);
-	tioce_kern->ce_port1_secondary = (uint8_t) tmp;
+	tioce_kern->ce_port1_secondary = (u8) tmp;
 
 	/*
 	 * Set PMU pagesize to the largest size available, and zero out
@@ -615,7 +615,7 @@ tioce_force_interrupt(struct sn_irq_info
 	struct pcidev_info *pcidev_info;
 	struct tioce_common *ce_common;
 	struct tioce *ce_mmr;
-	uint64_t force_int_val;
+	u64 force_int_val;
 
 	if (!sn_irq_info->irq_bridge)
 		return;
@@ -687,7 +687,7 @@ tioce_target_interrupt(struct sn_irq_inf
 	struct tioce_common *ce_common;
 	struct tioce *ce_mmr;
 	int bit;
-	uint64_t vector;
+	u64 vector;
 
 	pcidev_info = (struct pcidev_info *)sn_irq_info->irq_pciioinfo;
 	if (!pcidev_info)
@@ -699,7 +699,7 @@ tioce_target_interrupt(struct sn_irq_inf
 	bit = sn_irq_info->irq_int_bit;
 
 	__sn_setq_relaxed(&ce_mmr->ce_adm_int_mask, (1UL << bit));
-	vector = (uint64_t)sn_irq_info->irq_irq << INTR_VECTOR_SHFT;
+	vector = (u64)sn_irq_info->irq_irq << INTR_VECTOR_SHFT;
 	vector |= sn_irq_info->irq_xtalkaddr;
 	writeq(vector, &ce_mmr->ce_adm_int_dest[bit]);
 	__sn_clrq_relaxed(&ce_mmr->ce_adm_int_mask, (1UL << bit));
diff -purN linux-2.6.15-git12/arch/mips/kernel/reset.c linux-2.6.16-rc1/arch/mips/kernel/reset.c
--- linux-2.6.15-git12/arch/mips/kernel/reset.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/mips/kernel/reset.c	2006-01-17 08:22:42.976372949 +0000
@@ -12,6 +12,9 @@
 #include <linux/reboot.h>
 #include <asm/reboot.h>
 
+void (*pm_power_off)(void);
+EXPORT_SYMBOL(pm_power_off);
+
 /*
  * Urgs ...  Too many MIPS machines to handle this in a generic way.
  * So handle all using function pointers to machine specific
@@ -33,6 +36,9 @@ void machine_halt(void)
 
 void machine_power_off(void)
 {
+	if (pm_power_off)
+		pm_power_off();
+
 	_machine_power_off();
 }
 
diff -purN linux-2.6.15-git12/arch/sh/Kconfig linux-2.6.16-rc1/arch/sh/Kconfig
--- linux-2.6.15-git12/arch/sh/Kconfig	2006-01-17 08:21:30.113791964 +0000
+++ linux-2.6.16-rc1/arch/sh/Kconfig	2006-01-17 08:22:44.075467592 +0000
@@ -33,9 +33,11 @@ config GENERIC_CALIBRATE_DELAY
 	bool
 	default y
 
+config GENERIC_IOMAP
+	bool
+
 config ARCH_MAY_HAVE_PC_FDC
 	bool
-	default y
 
 source "init/Kconfig"
 
@@ -53,24 +55,28 @@ config SH_SOLUTION_ENGINE
 
 config SH_7751_SOLUTION_ENGINE
 	bool "SolutionEngine7751"
+	select CPU_SUBTYPE_SH7751
 	help
 	  Select 7751 SolutionEngine if configuring for a Hitachi SH7751
 	  evaluation board.
 
 config SH_7300_SOLUTION_ENGINE
 	bool "SolutionEngine7300"
+	select CPU_SUBTYPE_SH7300
 	help
 	  Select 7300 SolutionEngine if configuring for a Hitachi SH7300(SH-Mobile V)
 	  evaluation board.
 
 config SH_73180_SOLUTION_ENGINE
        bool "SolutionEngine73180"
+       select CPU_SUBTYPE_SH73180
        help
          Select 73180 SolutionEngine if configuring for a Hitachi SH73180(SH-Mobile 3)
          evaluation board.
 
 config SH_7751_SYSTEMH
 	bool "SystemH7751R"
+	select CPU_SUBTYPE_SH7751R
 	help
 	  Select SystemH if you are configuring for a Renesas SystemH
 	  7751R evaluation board.
@@ -81,27 +87,13 @@ config SH_STB1_HARP
 config SH_STB1_OVERDRIVE
 	bool "STB1_Overdrive"
 
-config SH_HP620
-	bool "HP620"
+config SH_HP6XX
+	bool "HP6XX"
 	help
-	  Select HP620 if configuring for a HP jornada HP620.
+	  Select HP6XX if configuring for a HP jornada HP6xx.
 	  More information (hardware only) at
 	  <http://www.hp.com/jornada/>.
 
-config SH_HP680
-	bool "HP680"
-	help
-	  Select HP680 if configuring for a HP Jornada HP680.
-	  More information (hardware only) at
-	  <http://www.hp.com/jornada/products/680/>.
-
-config SH_HP690
-	bool "HP690"
-	help
-	  Select HP690 if configuring for a HP Jornada HP690.
-	  More information (hardware only)
-	  at <http://www.hp.com/jornada/products/680/>.
-
 config SH_CQREEK
 	bool "CqREEK"
 	help
@@ -123,11 +115,13 @@ config SH_EC3104
 
 config SH_SATURN
 	bool "Saturn"
+	select CPU_SUBTYPE_SH7604
 	help
 	  Select Saturn if configuring for a SEGA Saturn.
 
 config SH_DREAMCAST
 	bool "Dreamcast"
+	select CPU_SUBTYPE_SH7091
 	help
 	  Select Dreamcast if configuring for a SEGA Dreamcast.
 	  More information at
@@ -142,6 +136,7 @@ config SH_BIGSUR
 
 config SH_SH2000
 	bool "SH2000"
+	select CPU_SUBTYPE_SH7709
 	help
 	  SH-2000 is a single-board computer based around SH7709A chip
 	  intended for embedded applications.
@@ -153,20 +148,22 @@ config SH_ADX
 	bool "ADX"
 
 config SH_MPC1211
-	bool "MPC1211"
+	bool "Interface MPC1211"
+	help
+	  CTP/PCI-SH02 is a CPU module computer that is produced
+	  by Interface Corporation.
+	  More information at <http://www.interface.co.jp>
 
 config SH_SH03
-	bool "SH03"
+	bool "Interface CTP/PCI-SH03"
 	help
-	  CTP/PCI-SH03 is a CPU module computer that produced
+	  CTP/PCI-SH03 is a CPU module computer that is produced
 	  by Interface Corporation.
-	  It is compact and excellent in durability.
-	  It will play an active part in your factory or laboratory
-	  as a FA computer.
 	  More information at <http://www.interface.co.jp>
 
 config SH_SECUREEDGE5410
 	bool "SecureEdge5410"
+	select CPU_SUBTYPE_SH7751R
 	help
 	  Select SecureEdge5410 if configuring for a SnapGear SH board.
 	  This includes both the OEM SecureEdge products as well as the
@@ -174,25 +171,49 @@ config SH_SECUREEDGE5410
 
 config SH_HS7751RVOIP
 	bool "HS7751RVOIP"
+	select CPU_SUBTYPE_SH7751R
 	help
 	  Select HS7751RVOIP if configuring for a Renesas Technology
 	  Sales VoIP board.
 
 config SH_RTS7751R2D
 	bool "RTS7751R2D"
+	select CPU_SUBTYPE_SH7751R
 	help
 	  Select RTS7751R2D if configuring for a Renesas Technology
 	  Sales SH-Graphics board.
 
+config SH_R7780RP
+	bool "R7780RP-1"
+	select CPU_SUBTYPE_SH7780
+	help
+	  Select R7780RP-1 if configuring for a Renesas Solutions
+	  HIGHLANDER board.
+
 config SH_EDOSK7705
 	bool "EDOSK7705"
+	select CPU_SUBTYPE_SH7705
 
 config SH_SH4202_MICRODEV
 	bool "SH4-202 MicroDev"
+	select CPU_SUBTYPE_SH4_202
 	help
 	  Select SH4-202 MicroDev if configuring for a SuperH MicroDev board
 	  with an SH4-202 CPU.
 
+config SH_LANDISK
+	bool "LANDISK"
+	select CPU_SUBTYPE_SH7751R
+	help
+	  I-O DATA DEVICE, INC. "LANDISK Series" support.
+
+config SH_TITAN
+	bool "TITAN"
+	select CPU_SUBTYPE_SH7751R
+	help
+	  Select Titan if you are configuring for a Nimble Microsystems
+	  NetEngine NP51R.
+
 config SH_UNKNOWN
 	bool "BareCPU"
 	help
@@ -207,168 +228,27 @@ config SH_UNKNOWN
 
 endchoice
 
-choice
-	prompt "Processor family"
-	default CPU_SH4
-	help
-	  This option determines the CPU family to compile for. Supported
-	  targets are SH-2, SH-3, and SH-4. These options are independent of
-	  CPU functionality. As such, SH-DSP users will still want to select
-	  their respective processor family in addition to the DSP support
-	  option.
-
-config CPU_SH2
-	bool "SH-2"
-	select SH_WRITETHROUGH
-
-config CPU_SH3
-	bool "SH-3"
-
-config CPU_SH4
-	bool "SH-4"
-
-endchoice
-
-choice
-	prompt "Processor subtype"
-
-config CPU_SUBTYPE_SH7604
-	bool "SH7604"
-	depends on CPU_SH2
-	help
-	  Select SH7604 if you have SH7604
-
-config CPU_SUBTYPE_SH7300
-	bool "SH7300"
-	depends on CPU_SH3
-
-config CPU_SUBTYPE_SH7705
-	bool "SH7705"
-	depends on CPU_SH3
-
-config CPU_SUBTYPE_SH7707
-	bool "SH7707"
-	depends on CPU_SH3
-	help
-	  Select SH7707 if you have a  60 Mhz SH-3 HD6417707 CPU.
-
-config CPU_SUBTYPE_SH7708
-	bool "SH7708"
-	depends on CPU_SH3
-	help
-	  Select SH7708 if you have a  60 Mhz SH-3 HD6417708S or
-	  if you have a 100 Mhz SH-3 HD6417708R CPU.
-
-config CPU_SUBTYPE_SH7709
-	bool "SH7709"
-	depends on CPU_SH3
-	help
-	  Select SH7709 if you have a  80 Mhz SH-3 HD6417709 CPU.
-
-config CPU_SUBTYPE_SH7750
-	bool "SH7750"
-	depends on CPU_SH4
-	help
-	  Select SH7750 if you have a 200 Mhz SH-4 HD6417750 CPU.
-
-config CPU_SUBTYPE_SH7751
-	bool "SH7751/SH7751R"
-	depends on CPU_SH4
-	help
-	  Select SH7751 if you have a 166 Mhz SH-4 HD6417751 CPU,
-	  or if you have a HD6417751R CPU.
-
-config CPU_SUBTYPE_SH7760
-	bool "SH7760"
-	depends on CPU_SH4
-
-config CPU_SUBTYPE_SH73180
-       bool "SH73180"
-       depends on CPU_SH4
-
-config CPU_SUBTYPE_ST40STB1
-       bool "ST40STB1 / ST40RA"
-       depends on CPU_SH4
-       help
-         Select ST40STB1 if you have a ST40RA CPU.
-         This was previously called the ST40STB1, hence the option name.
-
-config CPU_SUBTYPE_ST40GX1
-       bool "ST40GX1"
-       depends on CPU_SH4
-       help
-         Select ST40GX1 if you have a ST40GX1 CPU.
-
-config CPU_SUBTYPE_SH4_202
-	bool "SH4-202"
-	depends on CPU_SH4
-
-endchoice
-
-config SH7705_CACHE_32KB
-    bool "Enable 32KB cache size for SH7705"
-    depends on CPU_SUBTYPE_SH7705
-    default y
-
-config MMU
-        bool "Support for memory management hardware"
-	depends on !CPU_SH2
-	default y
-	help
-	  Early SH processors (such as the SH7604) lack an MMU. In order to
-	  boot on these systems, this option must not be set.
-
-	  On other systems (such as the SH-3 and 4) where an MMU exists,
-	  turning this off will boot the kernel on these machines with the
-	  MMU implicitly switched off.
-
-choice
-	prompt "HugeTLB page size"
-	depends on HUGETLB_PAGE && CPU_SH4 && MMU
-	default HUGETLB_PAGE_SIZE_64K
-
-config HUGETLB_PAGE_SIZE_64K
-	bool "64K"
-
-config HUGETLB_PAGE_SIZE_1MB
-	bool "1MB"
+source "arch/sh/mm/Kconfig"
 
-endchoice
-
-config CMDLINE_BOOL
-	bool "Default bootloader kernel arguments"
-
-config CMDLINE
-	string "Initial kernel command string"
-	depends on CMDLINE_BOOL
-	default "console=ttySC1,115200"
-
-# Platform-specific memory start and size definitions
 config MEMORY_START
-	hex "Physical memory start address" if !MEMORY_SET || MEMORY_OVERRIDE
-	default "0x08000000" if !MEMORY_SET || MEMORY_OVERRIDE || !MEMORY_OVERRIDE && SH_ADX || SH_MPC1211 || SH_SH03 || SH_SECUREEDGE5410 || SH_SH4202_MICRODEV
-	default "0x0c000000" if !MEMORY_OVERRIDE && (SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_73180_SOLUTION_ENGINE || SH_7300_SOLUTION_ENGINE || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_HS7751RVOIP || SH_RTS7751R2D || SH_EDOSK7705)
+	hex "Physical memory start address"
+	default "0x08000000"
 	---help---
 	  Computers built with Hitachi SuperH processors always
 	  map the ROM starting at address zero.  But the processor
 	  does not specify the range that RAM takes.
 
 	  The physical memory (RAM) start address will be automatically
-	  set to 08000000, unless you selected one of the following
-	  processor types: SolutionEngine, Overdrive, HP620, HP680, HP690,
-	  in which case the start address will be set to 0c000000.
+	  set to 08000000. Other platforms, such as the Solution Engine
+	  boards typically map RAM at 0C000000.
 
-	  Tweak this only when porting to a new machine which is not already
-	  known by the config system.  Changing it from the known correct
+	  Tweak this only when porting to a new machine which does not
+	  already have a defconfig. Changing it from the known correct
 	  value on any of the known systems will only lead to disaster.
 
 config MEMORY_SIZE
-	hex "Physical memory size" if !MEMORY_SET || MEMORY_OVERRIDE
-	default "0x00400000" if !MEMORY_SET || MEMORY_OVERRIDE || !MEMORY_OVERRIDE && SH_ADX || !MEMORY_OVERRIDE && (SH_HP600 || SH_BIGSUR || SH_SH2000)
-	default "0x01000000" if !MEMORY_OVERRIDE && SH_DREAMCAST || SH_SECUREEDGE5410 || SH_EDOSK7705
-        default "0x02000000" if !MEMORY_OVERRIDE && (SH_73180_SOLUTION_ENGINE || SH_SOLUTION_ENGINE)
-        default "0x04000000" if !MEMORY_OVERRIDE && (SH_7300_SOLUTION_ENGINE || SH_7751_SOLUTION_ENGINE || SH_HS7751RVOIP || SH_RTS7751R2D || SH_SH4202_MICRODEV)
-	default "0x08000000" if SH_MPC1211 || SH_SH03
+	hex "Physical memory size"
+	default "0x00400000"
 	help
 	  This sets the default memory size assumed by your SH kernel. It can
 	  be overridden as normal by the 'mem=' argument on the kernel command
@@ -376,21 +256,6 @@ config MEMORY_SIZE
 	  as 0x00400000 which was the default value before this became
 	  configurable.
 
-config MEMORY_SET
-	bool
-	depends on !MEMORY_OVERRIDE && (SH_MPC1211 || SH_SH03 || SH_ADX || SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_SECUREEDGE5410 || SH_HS7751RVOIP || SH_RTS7751R2D || SH_SH4202_MICRODEV || SH_EDOSK7705)
-	default y
-	help
-	  This is an option about which you will never be asked a question.
-	  Therefore, I conclude that you do not exist - go away.
-
-	  There is a grue here.
-
-# If none of the above have set memory start/size, ask the user.
-config MEMORY_OVERRIDE
-	bool "Override default load address and memory size"
-
-# XXX: break these out into the board-specific configs below
 config CF_ENABLER
 	bool "Compact Flash Enabler support"
 	depends on SH_ADX || SH_SOLUTION_ENGINE || SH_UNKNOWN || SH_CAT68701 || SH_SH03
@@ -434,10 +299,21 @@ config CF_BASE_ADDR
 	default "0xb8000000" if CF_AREA6
 	default "0xb4000000" if CF_AREA5
 
+menu "Processor features"
+
+config CPU_LITTLE_ENDIAN
+	bool "Little Endian"
+	help
+	  Some SuperH machines can be configured for either little or big
+	  endian byte order. These modes require different kernels. Say Y if
+	  your machine is little endian, N if it's a big endian machine.
+
 # The SH7750 RTC module is disabled in the Dreamcast
 config SH_RTC
 	bool
-	depends on !SH_DREAMCAST && !SH_SATURN && !SH_7300_SOLUTION_ENGINE && !SH_73180_SOLUTION_ENGINE
+	depends on !SH_DREAMCAST && !SH_SATURN && !SH_7300_SOLUTION_ENGINE && \
+		   !SH_73180_SOLUTION_ENGINE && !SH_LANDISK && \
+		   !SH_R7780RP
 	default y
 	help
 	  Selecting this option will allow the Linux kernel to emulate
@@ -476,104 +352,131 @@ config SH_ADC
 
 	  If unsure, say N.
 
-config SH_HP600
+config SH_STORE_QUEUES
+	bool "Support for Store Queues"
+	depends on CPU_SH4
+	help
+	  Selecting this option will enable an in-kernel API for manipulating
+	  the store queues integrated in the SH-4 processors.
+
+config CPU_HAS_INTEVT
 	bool
-	depends on SH_HP620 || SH_HP680 || SH_HP690
-	default y
 
-config CPU_SUBTYPE_ST40
-       bool
-       depends on CPU_SUBTYPE_ST40STB1 || CPU_SUBTYPE_ST40GX1
-       default y
+config CPU_HAS_PINT_IRQ
+	bool
 
-source "mm/Kconfig"
+config CPU_HAS_INTC2_IRQ
+	bool
 
-config ZERO_PAGE_OFFSET
-	hex "Zero page offset"
-	default "0x00001000" if !(SH_MPC1211 || SH_SH03)
-	default "0x00004000" if SH_MPC1211 || SH_SH03
+config CPU_HAS_SR_RB
+	bool "CPU has SR.RB"
+	depends on CPU_SH3 || CPU_SH4
+	default y
 	help
-	  This sets the default offset of zero page.
+	  This will enable the use of SR.RB register bank usage. Processors
+	  that are lacking this bit must have another method in place for
+	  accomplishing what is taken care of by the banked registers.
 
-# XXX: needs to lose subtype for system type
-config ST40_LMI_MEMORY
-	bool "Memory on LMI"
-	depends on CPU_SUBTYPE_ST40STB1
+	  See <file:Documentation/sh/register-banks.txt> for further
+	  information on SR.RB and register banking in the kernel in general.
 
-config MEMORY_START
-	hex
-	depends on CPU_SUBTYPE_ST40STB1 && ST40_LMI_MEMORY
-	default "0x08000000"
+endmenu
 
-config MEMORY_SIZE
-	hex
-	depends on CPU_SUBTYPE_ST40STB1 && ST40_LMI_MEMORY
-	default "0x00400000"
+menu "Timer support"
 
-config MEMORY_SET
-	bool
-	depends on CPU_SUBTYPE_ST40STB1 && ST40_LMI_MEMORY
+config SH_TMU
+	bool "TMU timer support"
 	default y
-
-config BOOT_LINK_OFFSET
-	hex "Link address offset for booting"
-	default "0x00800000"
 	help
-	  This option allows you to set the link address offset of the zImage.
-	  This can be useful if you are on a board which has a small amount of
-	  memory.
+	  This enables the use of the TMU as the system timer.
 
-config CPU_LITTLE_ENDIAN
-	bool "Little Endian"
+endmenu
+
+source "arch/sh/boards/renesas/hs7751rvoip/Kconfig"
+
+source "arch/sh/boards/renesas/rts7751r2d/Kconfig"
+
+config SH_PCLK_FREQ_BOOL
+	bool "Set default pclk frequency"
+	default y if !SH_RTC
+	default n
+
+config SH_PCLK_FREQ
+	int "Peripheral clock frequency (in Hz)"
+	depends on SH_PCLK_FREQ_BOOL
+	default "50000000" if CPU_SUBTYPE_SH7750 || CPU_SUBTYPE_SH7780
+	default "60000000" if CPU_SUBTYPE_SH7751
+	default "33333333" if CPU_SUBTYPE_SH7300 || CPU_SUBTYPE_SH7770 || CPU_SUBTYPE_SH7760
+	default "27000000" if CPU_SUBTYPE_SH73180
+	default "66000000" if CPU_SUBTYPE_SH4_202
 	help
-	  Some SuperH machines can be configured for either little or big
-	  endian byte order. These modes require different kernels. Say Y if
-	  your machine is little endian, N if it's a big endian machine.
+	  This option is used to specify the peripheral clock frequency.
+	  This is necessary for determining the reference clock value on
+	  platforms lacking an RTC.
 
-config PREEMPT
-	bool "Preemptible Kernel (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
+menu "CPU Frequency scaling"
 
-config UBC_WAKEUP
-	bool "Wakeup UBC on startup"
+source "drivers/cpufreq/Kconfig"
+
+config SH_CPU_FREQ
+	tristate "SuperH CPU Frequency driver"
+	depends on CPU_FREQ
+	select CPU_FREQ_TABLE
 	help
-	  Selecting this option will wakeup the User Break Controller (UBC) on
-	  startup. Although the UBC is left in an awake state when the processor
-	  comes up, some boot loaders misbehave by putting the UBC to sleep in a
-	  power saving state, which causes issues with things like ptrace().
+	  This adds the cpufreq driver for SuperH. At present, only
+	  the SH-4 is supported.
+
+	  For details, take a look at <file:Documentation/cpu-freq>.
 
 	  If unsure, say N.
 
-config SH_WRITETHROUGH
-	bool "Use write-through caching"
-	default y if CPU_SH2
-	help
-	  Selecting this option will configure the caches in write-through
-	  mode, as opposed to the default write-back configuration.
-
-	  Since there's sill some aliasing issues on SH-4, this option will
-	  unfortunately still require the majority of flushing functions to
-	  be implemented to deal with aliasing.
+endmenu
 
-	  If unsure, say N.
+source "arch/sh/drivers/dma/Kconfig"
+
+source "arch/sh/cchips/Kconfig"
 
-config SH_OCRAM
-	bool "Operand Cache RAM (OCRAM) support"
+config HEARTBEAT
+	bool "Heartbeat LED"
+	depends on SH_MPC1211 || SH_SH03 || SH_CAT68701 || \
+		   SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || \
+		   SH_7751_SOLUTION_ENGINE || SH_7300_SOLUTION_ENGINE || \
+		   SH_73180_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || \
+		   SH_RTS7751R2D || SH_SH4202_MICRODEV || SH_LANDISK
 	help
-	  Selecting this option will automatically tear down the number of
-	  sets in the dcache by half, which in turn exposes a memory range.
+	  Use the power-on LED on your machine as a load meter.  The exact
+	  behavior is platform-dependent, but normally the flash frequency is
+	  a hyperbolic function of the 5-minute load average.
 
-	  The addresses for the OC RAM base will vary according to the
-	  processor version. Consult vendor documentation for specifics.
+endmenu
 
-	  If unsure, say N.
+config ISA_DMA_API
+	bool
+	depends on MPC1211
+	default y
 
-config SH_STORE_QUEUES
-	bool "Support for Store Queues"
-	depends on CPU_SH4
+menu "Kernel features"
+
+config KEXEC
+	bool "kexec system call (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
 	help
-	  Selecting this option will enable an in-kernel API for manipulating
-	  the store queues integrated in the SH-4 processors.
+	  kexec is a system call that implements the ability to shutdown your
+	  current kernel, and to start another kernel.  It is like a reboot
+	  but it is indepedent of the system firmware.  And like a reboot
+	  you can start any kernel with it, not just Linux.
+
+	  The name comes from the similiarity to the exec system call.
+
+	  It is an ongoing process to be certain the hardware in a machine
+	  is properly shutdown, so do not be surprised if this code does not
+	  initially work for you.  It may help to enable device hotplugging
+	  support.  As of this writing the exact hardware interface is
+	  strongly in flux, so no good recommendation can be made.
+
+config PREEMPT
+	bool "Preemptible Kernel (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
 
 config SMP
 	bool "Symmetric multi-processing support"
@@ -610,87 +513,58 @@ config NR_CPUS
 	  This is purely to save memory - each supported CPU adds
 	  approximately eight kilobytes to the kernel image.
 
-config HS7751RVOIP_CODEC
-	bool "Support VoIP Codec section"
-	depends on SH_HS7751RVOIP
-	help
-	  Selecting this option will support CODEC section.
-
-config RTS7751R2D_REV11
-	bool "RTS7751R2D Rev. 1.1 board support"
-	depends on SH_RTS7751R2D
-	help
-	  Selecting this option will support version rev. 1.1.
-
-config SH_PCLK_CALC
-	bool
-	default n if CPU_SUBTYPE_SH7300 || CPU_SUBTYPE_SH73180
+config CPU_HAS_SR_RB
+	bool "CPU has SR.RB"
+	depends on CPU_SH3 || CPU_SH4
 	default y
 	help
-	  This option will cause the PCLK value to be probed at run-time. It
-	  will display a notification if the probed value has greater than a
-	  1% variance of the hardcoded CONFIG_SH_PCLK_FREQ.
+	  This will enable the use of SR.RB register bank usage. Processors
+	  that are lacking this bit must have another method in place for
+	  accomplishing what is taken care of by the banked registers.
 
-config SH_PCLK_FREQ
-	int "Peripheral clock frequency (in Hz)"
-	default "50000000" if CPU_SUBTYPE_SH7750
-	default "60000000" if CPU_SUBTYPE_SH7751
-	default "33333333" if CPU_SUBTYPE_SH7300
-	default "27000000" if CPU_SUBTYPE_SH73180
-	default "66000000" if CPU_SUBTYPE_SH4_202
-	default "1193182"
-	help
-	  This option is used to specify the peripheral clock frequency. This
-	  option must be set for each processor in order for the kernel to
-	  function reliably. If no sane default exists, we use a default from
-	  the legacy i8254. Any discrepancies will be reported on boot time
-	  with an auto-probed frequency which should be considered the proper
-	  value for your hardware.
+	  See <file:Documentation/sh/register-banks.txt> for further
+	  information on SR.RB and register banking in the kernel in general.
 
-menu "CPU Frequency scaling"
+endmenu
 
-source "drivers/cpufreq/Kconfig"
+menu "Boot options"
 
-config SH_CPU_FREQ
-	tristate "SuperH CPU Frequency driver"
-	depends on CPU_FREQ
-	select CPU_FREQ_TABLE
+config ZERO_PAGE_OFFSET
+	hex "Zero page offset"
+	default "0x00004000" if SH_MPC1211 || SH_SH03
+	default "0x00001000"
 	help
-	  This adds the cpufreq driver for SuperH. At present, only
-	  the SH-4 is supported.
-
-	  For details, take a look at <file:Documentation/cpu-freq>.
-
-	  If unsure, say N.
+	  This sets the default offset of zero page.
 
-endmenu
+config BOOT_LINK_OFFSET
+	hex "Link address offset for booting"
+	default "0x00800000"
+	help
+	  This option allows you to set the link address offset of the zImage.
+	  This can be useful if you are on a board which has a small amount of
+	  memory.
 
-source "arch/sh/drivers/dma/Kconfig"
+config UBC_WAKEUP
+	bool "Wakeup UBC on startup"
+	help
+	  Selecting this option will wakeup the User Break Controller (UBC) on
+	  startup. Although the UBC is left in an awake state when the processor
+	  comes up, some boot loaders misbehave by putting the UBC to sleep in a
+	  power saving state, which causes issues with things like ptrace().
 
-source "arch/sh/cchips/Kconfig"
+	  If unsure, say N.
 
-config HEARTBEAT
-	bool "Heartbeat LED"
-	depends on SH_MPC1211 || SH_SH03 || SH_CAT68701 || SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || SH_7751_SOLUTION_ENGINE || SH_7300_SOLUTION_ENGINE || SH_73180_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_RTS7751R2D || SH_SH4202_MICRODEV
-	help
-	  Use the power-on LED on your machine as a load meter.  The exact
-	  behavior is platform-dependent, but normally the flash frequency is
-	  a hyperbolic function of the 5-minute load average.
+config CMDLINE_BOOL
+	bool "Default bootloader kernel arguments"
 
-config RTC_9701JE
-	tristate "EPSON RTC-9701JE support"
-	depends on SH_RTS7751R2D
-	help
-	  Selecting this option will support EPSON RTC-9701JE.
+config CMDLINE
+	string "Initial kernel command string"
+	depends on CMDLINE_BOOL
+	default "console=ttySC1,115200"
 
 endmenu
 
-config ISA_DMA_API
-	bool
-	depends on MPC1211
-	default y
-
-menu "Bus options (PCI, PCMCIA, EISA, MCA, ISA)"
+menu "Bus options"
 
 # Even on SuperH devices which don't have an ISA bus,
 # this variable helps the PCMCIA modules handle
@@ -701,7 +575,7 @@ menu "Bus options (PCI, PCMCIA, EISA, MC
 # PCMCIA outright. -- PFM.
 config ISA
 	bool
-	default y if PCMCIA || SMC91X
+	default y if PCMCIA
 	help
 	  Find out whether you have ISA slots on your motherboard.  ISA is the
 	  name of a bus system, i.e. the way the CPU talks to the other stuff
@@ -735,10 +609,9 @@ config MCA
 config SBUS
 	bool
 
-config MAPLE
-	tristate "Maple Bus support"
-	depends on SH_DREAMCAST
-	default y
+config SUPERHYWAY
+	tristate "SuperHyway Bus support"
+	depends on CPU_SUBTYPE_SH4_202
 
 source "arch/sh/drivers/pci/Kconfig"
 
diff -purN linux-2.6.15-git12/arch/sh/Kconfig.debug linux-2.6.16-rc1/arch/sh/Kconfig.debug
--- linux-2.6.15-git12/arch/sh/Kconfig.debug	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/Kconfig.debug	2006-01-17 08:22:44.076467435 +0000
@@ -17,7 +17,7 @@ config SH_STANDARD_BIOS
 
 config EARLY_SCIF_CONSOLE
 	bool "Use early SCIF console"
-	depends on CPU_SH4
+	depends on CPU_SH4 || CPU_SH2A && !SH_STANDARD_BIOS
 
 config EARLY_PRINTK
 	bool "Early printk support"
diff -purN linux-2.6.15-git12/arch/sh/Makefile linux-2.6.16-rc1/arch/sh/Makefile
--- linux-2.6.15-git12/arch/sh/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/Makefile	2006-01-17 08:22:44.078467120 +0000
@@ -17,10 +17,30 @@
 cflags-y				:= -mb
 cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	:= -ml
 
+isa-y					:= any
+isa-$(CONFIG_CPU_SH2)			:= sh2
+isa-$(CONFIG_CPU_SH3)			:= sh3
+isa-$(CONFIG_CPU_SH4)			:= sh4
+isa-$(CONFIG_CPU_SH4A)			:= sh4a
+isa-$(CONFIG_CPU_SH2A)			:= sh2a
+
+isa-$(CONFIG_SH_DSP)			:= $(isa-y)-dsp
+
+ifndef CONFIG_MMU
+isa-y			:= $(isa-y)-nommu
+endif
+
+ifndef CONFIG_SH_FPU
+isa-y			:= $(isa-y)-nofpu
+endif
+
+cflags-y	+= $(call as-option,-Wa$(comma)-isa=$(isa-y),)
+
 cflags-$(CONFIG_CPU_SH2)		+= -m2
 cflags-$(CONFIG_CPU_SH3)		+= -m3
 cflags-$(CONFIG_CPU_SH4)		+= -m4 \
 	$(call cc-option,-mno-implicit-fp,-m4-nofpu)
+cflags-$(CONFIG_CPU_SH4A)		+= $(call cc-option,-m4a-nofpu,)
 
 cflags-$(CONFIG_SH_DSP)			+= -Wa,-dsp
 cflags-$(CONFIG_SH_KGDB)		+= -g
@@ -67,9 +87,7 @@ machdir-$(CONFIG_SH_7300_SOLUTION_ENGINE
 machdir-$(CONFIG_SH_73180_SOLUTION_ENGINE)	:= se/73180
 machdir-$(CONFIG_SH_STB1_HARP)			:= harp
 machdir-$(CONFIG_SH_STB1_OVERDRIVE)		:= overdrive
-machdir-$(CONFIG_SH_HP620)			:= hp6xx/hp620
-machdir-$(CONFIG_SH_HP680)			:= hp6xx/hp680
-machdir-$(CONFIG_SH_HP690)			:= hp6xx/hp690
+machdir-$(CONFIG_SH_HP6XX)			:= hp6xx
 machdir-$(CONFIG_SH_CQREEK)			:= cqreek
 machdir-$(CONFIG_SH_DMIDA)			:= dmida
 machdir-$(CONFIG_SH_EC3104)			:= ec3104
@@ -119,31 +137,39 @@ boot := arch/sh/boot
 
 CPPFLAGS_vmlinux.lds := -traditional
 
+ifneq ($(KBUILD_SRC),)
+incdir-prefix	:= $(srctree)/include/asm-sh/
+else
+incdir-prefix	:=
+endif
+
 #	Update machine arch and proc symlinks if something which affects
 #	them changed.  We use .arch and .mach to indicate when they were
 #	updated last, otherwise make uses the target directory mtime.
 
 include/asm-sh/.cpu: $(wildcard include/config/cpu/*.h) include/config/MARKER
 	@echo '  SYMLINK include/asm-sh/cpu -> include/asm-sh/$(cpuincdir-y)'
-ifneq ($(KBUILD_SRC),)
-	$(Q)mkdir -p include/asm-sh
-	$(Q)ln -fsn $(srctree)/include/asm-sh/$(cpuincdir-y) include/asm-sh/cpu
-else
-	$(Q)ln -fsn $(cpuincdir-y) include/asm-sh/cpu
-endif
+	$(Q)if [ ! -d include/asm-sh ]; then mkdir -p include/asm-sh; fi
+	$(Q)ln -fsn $(incdir-prefix)$(cpuincdir-y) include/asm-sh/cpu
 	@touch $@
 
+#	Most boards have their own mach directories.  For the ones that
+#	don't, just reference the parent directory so the semantics are
+#	kept roughly the same.
+
 include/asm-sh/.mach: $(wildcard include/config/sh/*.h) include/config/MARKER
-	@echo '  SYMLINK include/asm-sh/mach -> include/asm-sh/$(incdir-y)'
-ifneq ($(KBUILD_SRC),)
-	$(Q)mkdir -p include/asm-sh
-	$(Q)ln -fsn $(srctree)/include/asm-sh/$(incdir-y) include/asm-sh/mach
-else
-	$(Q)ln -fsn $(incdir-y) include/asm-sh/mach
-endif
+	@echo -n '  SYMLINK include/asm-sh/mach -> '
+	$(Q)if [ ! -d include/asm-sh ]; then mkdir -p include/asm-sh; fi
+	$(Q)if [ -d $(incdir-prefix)$(incdir-y) ]; then \
+		echo -e 'include/asm-sh/$(incdir-y)'; \
+		ln -fsn $(incdir-prefix)$(incdir-y) \
+			include/asm-sh/mach; \
+	else \
+		echo -e 'include/asm-sh'; \
+		ln -fsn $(incdir-prefix) include/asm-sh/mach; \
+	fi
 	@touch $@
 
-
 archprepare: maketools include/asm-sh/.cpu include/asm-sh/.mach
 
 .PHONY: maketools FORCE
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/Makefile linux-2.6.16-rc1/arch/sh/boards/hp6xx/Makefile
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/Makefile	2006-01-17 08:22:44.079466962 +0000
@@ -0,0 +1,6 @@
+#
+# Makefile for the HP6xx specific parts of the kernel
+#
+
+obj-y	 := mach.o setup.o
+
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/Makefile linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/Makefile
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#
-# Makefile for the HP620 specific parts of the kernel
-#
-
-obj-y	 := mach.o setup.o
-
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/mach.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/mach.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/mach.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/mach.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-/*
- * linux/arch/sh/boards/hp6xx/hp620/mach.c
- * 
- * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
- * 
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Machine vector for the HP620
- */
-
-#include <linux/init.h>
-
-#include <asm/machvec.h>
-#include <asm/rtc.h>
-#include <asm/machvec_init.h>
-
-#include <asm/io.h>
-#include <asm/hd64461/hd64461.h>
-#include <asm/irq.h>
-
-/*
- * The Machine Vector
- */
-
-struct sh_machine_vector mv_hp620 __initmv = {
-        .mv_nr_irqs             = HD64461_IRQBASE+HD64461_IRQ_NUM,
-
-        .mv_inb                 = hd64461_inb,
-        .mv_inw                 = hd64461_inw,
-        .mv_inl                 = hd64461_inl,
-        .mv_outb                = hd64461_outb,
-        .mv_outw                = hd64461_outw,
-        .mv_outl                = hd64461_outl,
-
-        .mv_inb_p               = hd64461_inb_p,
-        .mv_inw_p               = hd64461_inw,
-        .mv_inl_p               = hd64461_inl,
-        .mv_outb_p              = hd64461_outb_p,
-        .mv_outw_p              = hd64461_outw,
-        .mv_outl_p              = hd64461_outl,
-
-        .mv_insb                = hd64461_insb,
-        .mv_insw                = hd64461_insw,
-        .mv_insl                = hd64461_insl,
-        .mv_outsb               = hd64461_outsb,
-        .mv_outsw               = hd64461_outsw,
-        .mv_outsl               = hd64461_outsl,
-
-        .mv_irq_demux           = hd64461_irq_demux,
-};
-ALIAS_MV(hp620)
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/setup.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/setup.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp620/setup.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp620/setup.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,45 +0,0 @@
-/*
- * linux/arch/sh/boards/hp6xx/hp620/setup.c
- *
- * Copyright (C) 2002 Andriy Skulysh, 2005 Kristoffer Ericson
- *
- * May be copied or modified under the terms of the GNU General Public
- * License. See Linux/COPYING for more information.
- *
- * Setup code for an HP620.
- * Due to similiarity with hp680/hp690 same inits are done (for now)
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <asm/hd64461/hd64461.h>
-#include <asm/io.h>
-#include <asm/hp6xx/hp6xx.h>
-#include <asm/cpu/dac.h>
-
-const char *get_system_type(void)
-{
-	return "HP620";
-}
-
-int __init platform_setup(void)
-{
-	u16 v;
-
-	v  = inw(HD64461_STBCR);
-	v |= HD64461_STBCR_SURTST | HD64461_STBCR_SIRST  |
-	     HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST |
-	     HD64461_STBCR_SAFEST | HD64461_STBCR_SPC0ST |
-	     HD64461_STBCR_SMIAST | HD64461_STBCR_SAFECKE_OST |
-	     HD64461_STBCR_SAFECKE_IST;
-	outw(v, HD64461_STBCR);
-
-	v  = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER | HD64461_GPADR_PCMCIA0;
-	outw(v, HD64461_GPADR);
-
-	sh_dac_disable(DAC_SPEAKER_VOLUME);
-
-	return 0;
-}
-
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/Makefile linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/Makefile
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#
-# Makefile for the HP680 specific parts of the kernel
-#
-
-obj-y	 := mach.o setup.o
-
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/mach.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/mach.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/mach.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/mach.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,53 +0,0 @@
-/*
- * linux/arch/sh/boards/hp6xx/hp680/mach.c
- *
- * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Machine vector for the HP680
- */
-
-#include <linux/init.h>
-
-#include <asm/machvec.h>
-#include <asm/rtc.h>
-#include <asm/machvec_init.h>
-
-#include <asm/io.h>
-#include <asm/hd64461/hd64461.h>
-#include <asm/hp6xx/io.h>
-#include <asm/irq.h>
-
-struct sh_machine_vector mv_hp680 __initmv = {
-	.mv_nr_irqs = HD64461_IRQBASE + HD64461_IRQ_NUM,
-
-	.mv_inb = hd64461_inb,
-	.mv_inw = hd64461_inw,
-	.mv_inl = hd64461_inl,
-	.mv_outb = hd64461_outb,
-	.mv_outw = hd64461_outw,
-	.mv_outl = hd64461_outl,
-
-	.mv_inb_p = hd64461_inb_p,
-	.mv_inw_p = hd64461_inw,
-	.mv_inl_p = hd64461_inl,
-	.mv_outb_p = hd64461_outb_p,
-	.mv_outw_p = hd64461_outw,
-	.mv_outl_p = hd64461_outl,
-
-	.mv_insb = hd64461_insb,
-	.mv_insw = hd64461_insw,
-	.mv_insl = hd64461_insl,
-	.mv_outsb = hd64461_outsb,
-	.mv_outsw = hd64461_outsw,
-	.mv_outsl = hd64461_outsl,
-
-	.mv_readw = hd64461_readw,
-	.mv_writew = hd64461_writew,
-
-	.mv_irq_demux = hd64461_irq_demux,
-};
-
-ALIAS_MV(hp680)
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/setup.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/setup.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp680/setup.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp680/setup.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,41 +0,0 @@
-/*
- * linux/arch/sh/boards/hp6xx/hp680/setup.c
- *
- * Copyright (C) 2002 Andriy Skulysh
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Setup code for an HP680  (internal peripherials only)
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <asm/hd64461/hd64461.h>
-#include <asm/io.h>
-#include <asm/hp6xx/hp6xx.h>
-#include <asm/cpu/dac.h>
-
-const char *get_system_type(void)
-{
-	return "HP680";
-}
-
-int __init platform_setup(void)
-{
-	u16 v;
-	v = inw(HD64461_STBCR);
-	v |= HD64461_STBCR_SURTST | HD64461_STBCR_SIRST |
-	    HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST |
-	    HD64461_STBCR_SAFEST | HD64461_STBCR_SPC0ST |
-	    HD64461_STBCR_SMIAST | HD64461_STBCR_SAFECKE_OST |
-	    HD64461_STBCR_SAFECKE_IST;
-	outw(v, HD64461_STBCR);
-	v = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER | HD64461_GPADR_PCMCIA0;
-	outw(v, HD64461_GPADR);
-
-	sh_dac_disable(DAC_SPEAKER_VOLUME);
-
-	return 0;
-}
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp690/Makefile linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp690/Makefile
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp690/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp690/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#
-# Makefile for the HP690 specific parts of the kernel
-#
-
-obj-y	 := mach.o
-
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/hp690/mach.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp690/mach.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/hp690/mach.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/hp690/mach.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,48 +0,0 @@
-/*
- * linux/arch/sh/boards/hp6xx/hp690/mach.c
- *
- * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Machine vector for the HP690
- */
-
-#include <linux/init.h>
-
-#include <asm/machvec.h>
-#include <asm/rtc.h>
-#include <asm/machvec_init.h>
-
-#include <asm/io.h>
-#include <asm/hd64461/hd64461.h>
-#include <asm/irq.h>
-
-struct sh_machine_vector mv_hp690 __initmv = {
-        .mv_nr_irqs             = HD64461_IRQBASE+HD64461_IRQ_NUM,
-
-        .mv_inb                 = hd64461_inb,
-        .mv_inw                 = hd64461_inw,
-        .mv_inl                 = hd64461_inl,
-        .mv_outb                = hd64461_outb,
-        .mv_outw                = hd64461_outw,
-        .mv_outl                = hd64461_outl,
-
-        .mv_inb_p               = hd64461_inb_p,
-        .mv_inw_p               = hd64461_inw,
-        .mv_inl_p               = hd64461_inl,
-        .mv_outb_p              = hd64461_outb_p,
-        .mv_outw_p              = hd64461_outw,
-        .mv_outl_p              = hd64461_outl,
-
-        .mv_insb                = hd64461_insb,
-        .mv_insw                = hd64461_insw,
-        .mv_insl                = hd64461_insl,
-        .mv_outsb               = hd64461_outsb,
-        .mv_outsw               = hd64461_outsw,
-        .mv_outsl               = hd64461_outsl,
-
-        .mv_irq_demux           = hd64461_irq_demux,
-};
-ALIAS_MV(hp690)
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/mach.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/mach.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/mach.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/mach.c	2006-01-17 08:22:44.091465073 +0000
@@ -0,0 +1,46 @@
+/*
+ * linux/arch/sh/boards/hp6xx/mach.c
+ *
+ * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Machine vector for the HP680
+ */
+#include <asm/machvec.h>
+#include <asm/hd64461.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+struct sh_machine_vector mv_hp6xx __initmv = {
+	.mv_nr_irqs = HD64461_IRQBASE + HD64461_IRQ_NUM,
+
+	.mv_inb = hd64461_inb,
+	.mv_inw = hd64461_inw,
+	.mv_inl = hd64461_inl,
+	.mv_outb = hd64461_outb,
+	.mv_outw = hd64461_outw,
+	.mv_outl = hd64461_outl,
+
+	.mv_inb_p = hd64461_inb_p,
+	.mv_inw_p = hd64461_inw,
+	.mv_inl_p = hd64461_inl,
+	.mv_outb_p = hd64461_outb_p,
+	.mv_outw_p = hd64461_outw,
+	.mv_outl_p = hd64461_outl,
+
+	.mv_insb = hd64461_insb,
+	.mv_insw = hd64461_insw,
+	.mv_insl = hd64461_insl,
+	.mv_outsb = hd64461_outsb,
+	.mv_outsw = hd64461_outsw,
+	.mv_outsl = hd64461_outsl,
+
+	.mv_readw = hd64461_readw,
+	.mv_writew = hd64461_writew,
+
+	.mv_irq_demux = hd64461_irq_demux,
+};
+
+ALIAS_MV(hp6xx)
diff -purN linux-2.6.15-git12/arch/sh/boards/hp6xx/setup.c linux-2.6.16-rc1/arch/sh/boards/hp6xx/setup.c
--- linux-2.6.15-git12/arch/sh/boards/hp6xx/setup.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/hp6xx/setup.c	2006-01-17 08:22:44.092464916 +0000
@@ -0,0 +1,55 @@
+/*
+ * linux/arch/sh/boards/hp6xx/hp680/setup.c
+ *
+ * Copyright (C) 2002 Andriy Skulysh
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Setup code for an HP680  (internal peripherials only)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/hd64461.h>
+#include <asm/hp6xx/hp6xx.h>
+#include <asm/cpu/dac.h>
+
+const char *get_system_type(void)
+{
+	return "HP6xx";
+}
+
+int __init platform_setup(void)
+{
+	u8 v8;
+	u16 v;
+	v = inw(HD64461_STBCR);
+	v |= HD64461_STBCR_SURTST | HD64461_STBCR_SIRST |
+	    HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST |
+	    HD64461_STBCR_SAFEST | HD64461_STBCR_SPC0ST |
+	    HD64461_STBCR_SMIAST | HD64461_STBCR_SAFECKE_OST |
+	    HD64461_STBCR_SAFECKE_IST;
+#ifndef CONFIG_HD64461_ENABLER
+	v |= HD64461_STBCR_SPC1ST;
+#endif
+	outw(v, HD64461_STBCR);
+	v = inw(HD64461_GPADR);
+	v |= HD64461_GPADR_SPEAKER | HD64461_GPADR_PCMCIA0;
+	outw(v, HD64461_GPADR);
+
+	outw(HD64461_PCCGCR_VCC0 | HD64461_PCCSCR_VCC1, HD64461_PCC0GCR);
+
+#ifndef CONFIG_HD64461_ENABLER
+	outw(HD64461_PCCGCR_VCC0 | HD64461_PCCSCR_VCC1, HD64461_PCC1GCR);
+#endif
+
+	sh_dac_output(0, DAC_SPEAKER_VOLUME);
+	sh_dac_disable(DAC_SPEAKER_VOLUME);
+	v8 = ctrl_inb(DACR);
+	v8 &= ~DACR_DAE;
+	ctrl_outb(v8,DACR);
+
+	return 0;
+}
diff -purN linux-2.6.15-git12/arch/sh/boards/overdrive/Makefile linux-2.6.16-rc1/arch/sh/boards/overdrive/Makefile
--- linux-2.6.15-git12/arch/sh/boards/overdrive/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/overdrive/Makefile	2006-01-17 08:22:44.093464758 +0000
@@ -2,7 +2,7 @@
 # Makefile for the STMicroelectronics Overdrive specific parts of the kernel
 #
 
-obj-y	 := mach.o setup.o io.o irq.o led.o time.o
+obj-y	 := mach.o setup.o io.o irq.o led.o
 
 obj-$(CONFIG_PCI) += fpga.o galileo.o pcidma.o
 
diff -purN linux-2.6.15-git12/arch/sh/boards/overdrive/setup.c linux-2.6.16-rc1/arch/sh/boards/overdrive/setup.c
--- linux-2.6.15-git12/arch/sh/boards/overdrive/setup.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/overdrive/setup.c	2006-01-17 08:22:44.094464601 +0000
@@ -17,8 +17,6 @@
 #include <asm/overdrive/overdrive.h>
 #include <asm/overdrive/fpga.h>
 
-extern void od_time_init(void);
-
 const char *get_system_type(void)
 {
 	return "SH7750 Overdrive";
@@ -31,11 +29,9 @@ int __init platform_setup(void)
 {
 #ifdef CONFIG_PCI
 	init_overdrive_fpga();
-	galileo_init(); 
+	galileo_init();
 #endif
 
-	board_time_init = od_time_init;
-
         /* Enable RS232 receive buffers */
 	writel(0x1e, OVERDRIVE_CTRL);
 }
diff -purN linux-2.6.15-git12/arch/sh/boards/overdrive/time.c linux-2.6.16-rc1/arch/sh/boards/overdrive/time.c
--- linux-2.6.15-git12/arch/sh/boards/overdrive/time.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/boards/overdrive/time.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,119 +0,0 @@
-/*
- * arch/sh/boards/overdrive/time.c
- *
- * Copyright (C) 2000 Stuart Menefy (stuart.menefy@st.com)
- * Copyright (C) 2002 Paul Mundt (lethal@chaoticdreams.org)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * STMicroelectronics Overdrive Support.
- */
-
-void od_time_init(void)
-{
-	struct frqcr_data {
-		unsigned short frqcr;
-		struct {
-			unsigned char multiplier;
-			unsigned char divisor;
-		} factor[3];
-	};
-
-	static struct frqcr_data st40_frqcr_table[] = {		
-		{ 0x000, {{1,1}, {1,1}, {1,2}}},
-		{ 0x002, {{1,1}, {1,1}, {1,4}}},
-		{ 0x004, {{1,1}, {1,1}, {1,8}}},
-		{ 0x008, {{1,1}, {1,2}, {1,2}}},
-		{ 0x00A, {{1,1}, {1,2}, {1,4}}},
-		{ 0x00C, {{1,1}, {1,2}, {1,8}}},
-		{ 0x011, {{1,1}, {2,3}, {1,6}}},
-		{ 0x013, {{1,1}, {2,3}, {1,3}}},
-		{ 0x01A, {{1,1}, {1,2}, {1,4}}},
-		{ 0x01C, {{1,1}, {1,2}, {1,8}}},
-		{ 0x023, {{1,1}, {2,3}, {1,3}}},
-		{ 0x02C, {{1,1}, {1,2}, {1,8}}},
-		{ 0x048, {{1,2}, {1,2}, {1,4}}},
-		{ 0x04A, {{1,2}, {1,2}, {1,6}}},
-		{ 0x04C, {{1,2}, {1,2}, {1,8}}},
-		{ 0x05A, {{1,2}, {1,3}, {1,6}}},
-		{ 0x05C, {{1,2}, {1,3}, {1,6}}},
-		{ 0x063, {{1,2}, {1,4}, {1,4}}},
-		{ 0x06C, {{1,2}, {1,4}, {1,8}}},
-		{ 0x091, {{1,3}, {1,3}, {1,6}}},
-		{ 0x093, {{1,3}, {1,3}, {1,6}}},
-		{ 0x0A3, {{1,3}, {1,6}, {1,6}}},
-		{ 0x0DA, {{1,4}, {1,4}, {1,8}}},
-		{ 0x0DC, {{1,4}, {1,4}, {1,8}}},
-		{ 0x0EC, {{1,4}, {1,8}, {1,8}}},
-		{ 0x123, {{1,4}, {1,4}, {1,8}}},
-		{ 0x16C, {{1,4}, {1,8}, {1,8}}},
-	};
-
-	struct memclk_data {
-		unsigned char multiplier;
-		unsigned char divisor;
-	};
-	static struct memclk_data st40_memclk_table[8] = {
-		{1,1},	// 000
-		{1,2},	// 001
-		{1,3},	// 010
-		{2,3},	// 011
-		{1,4},	// 100
-		{1,6},	// 101
-		{1,8},	// 110
-		{1,8}	// 111
-	};
-
-	unsigned long pvr;
-
-	/* 
-	 * This should probably be moved into the SH3 probing code, and then
-	 * use the processor structure to determine which CPU we are running
-	 * on.
-	 */
-	pvr = ctrl_inl(CCN_PVR);
-	printk("PVR %08x\n", pvr);
-
-	if (((pvr >> CCN_PVR_CHIP_SHIFT) & CCN_PVR_CHIP_MASK) == CCN_PVR_CHIP_ST40STB1) {
-		/* 
-		 * Unfortunatly the STB1 FRQCR values are different from the
-		 * 7750 ones.
-		 */
-		struct frqcr_data *d;
-		int a;
-		unsigned long memclkcr;
-		struct memclk_data *e;
-
-		for (a=0; a<ARRAY_SIZE(st40_frqcr_table); a++) {
-			d = &st40_frqcr_table[a];
-			if (d->frqcr == (frqcr & 0x1ff))
-				break;
-		}
-		if (a == ARRAY_SIZE(st40_frqcr_table)) {
-			d = st40_frqcr_table;
-			printk("ERROR: Unrecognised FRQCR value, using default multipliers\n");
-		}
-
-		memclkcr = ctrl_inl(CLOCKGEN_MEMCLKCR);
-		e = &st40_memclk_table[memclkcr & MEMCLKCR_RATIO_MASK];
-
-		printk("Clock multipliers: CPU: %d/%d Bus: %d/%d Mem: %d/%d Periph: %d/%d\n",
-		       d->factor[0].multiplier, d->factor[0].divisor,
-		       d->factor[1].multiplier, d->factor[1].divisor,
-		       e->multiplier,           e->divisor,
-		       d->factor[2].multiplier, d->factor[2].divisor);
-		
-		current_cpu_data.master_clock = current_cpu_data.module_clock *
-						d->factor[2].divisor /
-						d->factor[2].multiplier;
-		current_cpu_data.bus_clock    = current_cpu_data.master_clock *
-						d->factor[1].multiplier /
-						d->factor[1].divisor;
-		current_cpu_data.memory_clock = current_cpu_data.master_clock *
-						e->multiplier / e->divisor;
-		current_cpu_data.cpu_clock    = current_cpu_data.master_clock *
-						d->factor[0].multiplier /
-						d->factor[0].divisor;
-}
-
diff -purN linux-2.6.15-git12/arch/sh/configs/hp680_defconfig linux-2.6.16-rc1/arch/sh/configs/hp680_defconfig
--- linux-2.6.15-git12/arch/sh/configs/hp680_defconfig	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/configs/hp680_defconfig	1970-01-01 00:00:00.000000000 +0000
@@ -1,554 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-sh
-# Wed Mar  2 15:09:41 2005
-#
-CONFIG_SUPERH=y
-CONFIG_UID16=y
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-# CONFIG_CLEAN_COMPILE is not set
-CONFIG_BROKEN=y
-CONFIG_BROKEN_ON_SMP=y
-
-#
-# General setup
-#
-CONFIG_LOCALVERSION=""
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_SYSCTL is not set
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
-# CONFIG_IKCONFIG is not set
-# CONFIG_EMBEDDED is not set
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
-# CONFIG_TINY_SHMEM is not set
-
-#
-# Loadable module support
-#
-# CONFIG_MODULES is not set
-
-#
-# System type
-#
-# CONFIG_SH_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SOLUTION_ENGINE is not set
-# CONFIG_SH_7300_SOLUTION_ENGINE is not set
-# CONFIG_SH_73180_SOLUTION_ENGINE is not set
-# CONFIG_SH_7751_SYSTEMH is not set
-# CONFIG_SH_STB1_HARP is not set
-# CONFIG_SH_STB1_OVERDRIVE is not set
-# CONFIG_SH_HP620 is not set
-CONFIG_SH_HP680=y
-# CONFIG_SH_HP690 is not set
-# CONFIG_SH_CQREEK is not set
-# CONFIG_SH_DMIDA is not set
-# CONFIG_SH_EC3104 is not set
-# CONFIG_SH_SATURN is not set
-# CONFIG_SH_DREAMCAST is not set
-# CONFIG_SH_CAT68701 is not set
-# CONFIG_SH_BIGSUR is not set
-# CONFIG_SH_SH2000 is not set
-# CONFIG_SH_ADX is not set
-# CONFIG_SH_MPC1211 is not set
-# CONFIG_SH_SH03 is not set
-# CONFIG_SH_SECUREEDGE5410 is not set
-# CONFIG_SH_HS7751RVOIP is not set
-# CONFIG_SH_RTS7751R2D is not set
-# CONFIG_SH_EDOSK7705 is not set
-# CONFIG_SH_SH4202_MICRODEV is not set
-# CONFIG_SH_UNKNOWN is not set
-# CONFIG_CPU_SH2 is not set
-CONFIG_CPU_SH3=y
-# CONFIG_CPU_SH4 is not set
-# CONFIG_CPU_SUBTYPE_SH7604 is not set
-# CONFIG_CPU_SUBTYPE_SH7300 is not set
-# CONFIG_CPU_SUBTYPE_SH7705 is not set
-# CONFIG_CPU_SUBTYPE_SH7707 is not set
-# CONFIG_CPU_SUBTYPE_SH7708 is not set
-CONFIG_CPU_SUBTYPE_SH7709=y
-# CONFIG_CPU_SUBTYPE_SH7750 is not set
-# CONFIG_CPU_SUBTYPE_SH7751 is not set
-# CONFIG_CPU_SUBTYPE_SH7760 is not set
-# CONFIG_CPU_SUBTYPE_SH73180 is not set
-# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
-# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
-# CONFIG_CPU_SUBTYPE_SH4_202 is not set
-CONFIG_MMU=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00400000
-CONFIG_MEMORY_SET=y
-# CONFIG_MEMORY_OVERRIDE is not set
-CONFIG_SH_RTC=y
-# CONFIG_SH_DSP is not set
-CONFIG_SH_ADC=y
-CONFIG_SH_HP600=y
-CONFIG_ZERO_PAGE_OFFSET=0x00001000
-CONFIG_BOOT_LINK_OFFSET=0x00800000
-CONFIG_CPU_LITTLE_ENDIAN=y
-# CONFIG_PREEMPT is not set
-# CONFIG_UBC_WAKEUP is not set
-# CONFIG_SH_WRITETHROUGH is not set
-# CONFIG_SH_OCRAM is not set
-# CONFIG_SMP is not set
-CONFIG_SH_PCLK_CALC=y
-CONFIG_SH_PCLK_FREQ=1193182
-
-#
-# CPU Frequency scaling
-#
-# CONFIG_CPU_FREQ is not set
-
-#
-# DMA support
-#
-# CONFIG_SH_DMA is not set
-
-#
-# Companion Chips
-#
-CONFIG_HD6446X_SERIES=y
-CONFIG_HD64461=y
-# CONFIG_HD64465 is not set
-CONFIG_HD64461_IRQ=36
-# CONFIG_HD64461_ENABLER is not set
-
-#
-# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
-#
-# CONFIG_PCI is not set
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
-# CONFIG_PCCARD is not set
-
-#
-# PC-card bridges
-#
-
-#
-# PCI Hotplug Support
-#
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_FLAT is not set
-# CONFIG_BINFMT_MISC is not set
-
-#
-# SH initrd options
-#
-# CONFIG_EMBEDDED_RAMDISK is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-# CONFIG_STANDALONE is not set
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
-# CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_IDE_MAX_HWIFS=4
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-CONFIG_IDE_SH=y
-# CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# SCSI device support
-#
-# CONFIG_SCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# I2O device support
-#
-
-#
-# Networking support
-#
-# CONFIG_NET is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_SH_SCI is not set
-CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
-
-#
-# IPMI
-#
-# CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
-# CONFIG_DRM is not set
-# CONFIG_RAW_DRIVER is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# Dallas's 1-wire bus
-#
-# CONFIG_W1 is not set
-
-#
-# Misc devices
-#
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-
-#
-# Graphics support
-#
-CONFIG_FB=y
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_EPSON1355 is not set
-CONFIG_FB_HIT=y
-# CONFIG_FB_VIRTUAL is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FONTS=y
-# CONFIG_FONT_8x8 is not set
-# CONFIG_FONT_8x16 is not set
-# CONFIG_FONT_6x11 is not set
-CONFIG_FONT_PEARL_8x8=y
-# CONFIG_FONT_ACORN_8x8 is not set
-# CONFIG_FONT_MINI_4x6 is not set
-# CONFIG_FONT_SUN8x16 is not set
-# CONFIG_FONT_SUN12x22 is not set
-
-#
-# Logo configuration
-#
-# CONFIG_LOGO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
-# USB Gadget Support
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# MMC/SD Card support
-#
-# CONFIG_MMC is not set
-
-#
-# InfiniBand support
-#
-# CONFIG_INFINIBAND is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_JBD is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-
-#
-# XFS support
-#
-# CONFIG_XFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_QUOTA is not set
-CONFIG_DNOTIFY=y
-# CONFIG_AUTOFS_FS is not set
-# CONFIG_AUTOFS4_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
-# CONFIG_TMPFS is not set
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
-# CONFIG_NLS is not set
-
-#
-# Profiling support
-#
-# CONFIG_PROFILING is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_DEBUG_KERNEL is not set
-# CONFIG_FRAME_POINTER is not set
-# CONFIG_SH_STANDARD_BIOS is not set
-# CONFIG_KGDB is not set
-
-#
-# Security options
-#
-# CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Hardware crypto devices
-#
-
-#
-# Library routines
-#
-# CONFIG_CRC_CCITT is not set
-CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
diff -purN linux-2.6.15-git12/arch/sh/configs/hp6xx_defconfig linux-2.6.16-rc1/arch/sh/configs/hp6xx_defconfig
--- linux-2.6.15-git12/arch/sh/configs/hp6xx_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/configs/hp6xx_defconfig	2006-01-17 08:22:44.107462554 +0000
@@ -0,0 +1,743 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.15-sh
+# Wed Jan  4 15:32:56 2006
+#
+CONFIG_SUPERH=y
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_SYSCTL is not set
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# System type
+#
+# CONFIG_SH_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SOLUTION_ENGINE is not set
+# CONFIG_SH_7300_SOLUTION_ENGINE is not set
+# CONFIG_SH_73180_SOLUTION_ENGINE is not set
+# CONFIG_SH_7751_SYSTEMH is not set
+# CONFIG_SH_STB1_HARP is not set
+# CONFIG_SH_STB1_OVERDRIVE is not set
+CONFIG_SH_HP6XX=y
+# CONFIG_SH_CQREEK is not set
+# CONFIG_SH_DMIDA is not set
+# CONFIG_SH_EC3104 is not set
+# CONFIG_SH_SATURN is not set
+# CONFIG_SH_DREAMCAST is not set
+# CONFIG_SH_CAT68701 is not set
+# CONFIG_SH_BIGSUR is not set
+# CONFIG_SH_SH2000 is not set
+# CONFIG_SH_ADX is not set
+# CONFIG_SH_MPC1211 is not set
+# CONFIG_SH_SH03 is not set
+# CONFIG_SH_SECUREEDGE5410 is not set
+# CONFIG_SH_HS7751RVOIP is not set
+# CONFIG_SH_RTS7751R2D is not set
+# CONFIG_SH_EDOSK7705 is not set
+# CONFIG_SH_SH4202_MICRODEV is not set
+# CONFIG_SH_LANDISK is not set
+# CONFIG_SH_TITAN is not set
+# CONFIG_SH_UNKNOWN is not set
+
+#
+# Processor selection
+#
+CONFIG_CPU_SH3=y
+
+#
+# SH-2 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7604 is not set
+
+#
+# SH-3 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7300 is not set
+# CONFIG_CPU_SUBTYPE_SH7705 is not set
+# CONFIG_CPU_SUBTYPE_SH7707 is not set
+# CONFIG_CPU_SUBTYPE_SH7708 is not set
+CONFIG_CPU_SUBTYPE_SH7709=y
+
+#
+# SH-4 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH7750 is not set
+# CONFIG_CPU_SUBTYPE_SH7091 is not set
+# CONFIG_CPU_SUBTYPE_SH7750R is not set
+# CONFIG_CPU_SUBTYPE_SH7750S is not set
+# CONFIG_CPU_SUBTYPE_SH7751 is not set
+# CONFIG_CPU_SUBTYPE_SH7751R is not set
+# CONFIG_CPU_SUBTYPE_SH7760 is not set
+# CONFIG_CPU_SUBTYPE_SH4_202 is not set
+
+#
+# ST40 Processor Support
+#
+# CONFIG_CPU_SUBTYPE_ST40STB1 is not set
+# CONFIG_CPU_SUBTYPE_ST40GX1 is not set
+
+#
+# SH-4A Processor Support
+#
+# CONFIG_CPU_SUBTYPE_SH73180 is not set
+# CONFIG_CPU_SUBTYPE_SH7770 is not set
+# CONFIG_CPU_SUBTYPE_SH7780 is not set
+
+#
+# Memory management options
+#
+CONFIG_MMU=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+
+#
+# Cache configuration
+#
+# CONFIG_SH_DIRECT_MAPPED is not set
+# CONFIG_SH_WRITETHROUGH is not set
+# CONFIG_SH_OCRAM is not set
+CONFIG_MEMORY_START=0x0c000000
+CONFIG_MEMORY_SIZE=0x00400000
+
+#
+# Processor features
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SH_RTC=y
+# CONFIG_SH_DSP is not set
+CONFIG_SH_ADC=y
+
+#
+# Timer support
+#
+CONFIG_SH_TMU=y
+CONFIG_SH_PCLK_FREQ_BOOL=y
+CONFIG_SH_PCLK_FREQ=22110000
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# DMA support
+#
+CONFIG_SH_DMA=y
+CONFIG_NR_ONCHIP_DMA_CHANNELS=4
+# CONFIG_NR_DMA_CHANNELS_BOOL is not set
+# CONFIG_DMA_PAGE_OPS is not set
+
+#
+# Companion Chips
+#
+CONFIG_HD6446X_SERIES=y
+CONFIG_HD64461=y
+# CONFIG_HD64465 is not set
+CONFIG_HD64461_IRQ=36
+CONFIG_HD64461_IOBASE=0xb0000000
+CONFIG_HD64461_ENABLER=y
+
+#
+# Kernel features
+#
+# CONFIG_KEXEC is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# Boot options
+#
+CONFIG_ZERO_PAGE_OFFSET=0x00001000
+CONFIG_BOOT_LINK_OFFSET=0x00800000
+# CONFIG_UBC_WAKEUP is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Bus options
+#
+CONFIG_ISA=y
+# CONFIG_PCI is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+CONFIG_HD64461_PCMCIA=y
+CONFIG_HD64461_PCMCIA_SOCKETS=1
+CONFIG_PCMCIA_PROBE=y
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Networking
+#
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_IDE_MAX_HWIFS=4
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_IDE_SH=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_SH_SCI is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_EPSON1355 is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_HIT=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+CONFIG_FONT_PEARL_8x8=y
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_OBSOLETE_OSS_DRIVER is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_SOUND_SH_DAC_AUDIO=y
+CONFIG_SOUND_SH_DAC_AUDIO_CHANNEL=1
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_SH_STANDARD_BIOS is not set
+# CONFIG_KGDB is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-api.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-api.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-api.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-api.c	2006-01-17 08:22:44.110462082 +0000
@@ -3,7 +3,7 @@
  *
  * SuperH-specific DMA management API
  *
- * Copyright (C) 2003, 2004  Paul Mundt
+ * Copyright (C) 2003, 2004, 2005  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -15,6 +15,7 @@
 #include <linux/spinlock.h>
 #include <linux/proc_fs.h>
 #include <linux/list.h>
+#include <linux/platform_device.h>
 #include <asm/dma.h>
 
 DEFINE_SPINLOCK(dma_spin_lock);
@@ -55,16 +56,14 @@ static LIST_HEAD(registered_dmac_list);
 
 struct dma_info *get_dma_info(unsigned int chan)
 {
-	struct list_head *pos, *tmp;
+	struct dma_info *info;
 	unsigned int total = 0;
 
 	/*
 	 * Look for each DMAC's range to determine who the owner of
 	 * the channel is.
 	 */
-	list_for_each_safe(pos, tmp, &registered_dmac_list) {
-		struct dma_info *info = list_entry(pos, struct dma_info, list);
-
+	list_for_each_entry(info, &registered_dmac_list, list) {
 		total += info->nr_channels;
 		if (chan > total)
 			continue;
@@ -75,6 +74,20 @@ struct dma_info *get_dma_info(unsigned i
 	return NULL;
 }
 
+static unsigned int get_nr_channels(void)
+{
+	struct dma_info *info;
+	unsigned int nr = 0;
+
+	if (unlikely(list_empty(&registered_dmac_list)))
+		return nr;
+
+	list_for_each_entry(info, &registered_dmac_list, list)
+		nr += info->nr_channels;
+
+	return nr;
+}
+
 struct dma_channel *get_dma_channel(unsigned int chan)
 {
 	struct dma_info *info = get_dma_info(chan);
@@ -173,7 +186,7 @@ int dma_xfer(unsigned int chan, unsigned
 static int dma_read_proc(char *buf, char **start, off_t off,
 			 int len, int *eof, void *data)
 {
-	struct list_head *pos, *tmp;
+	struct dma_info *info;
 	char *p = buf;
 
 	if (list_empty(&registered_dmac_list))
@@ -182,8 +195,7 @@ static int dma_read_proc(char *buf, char
 	/*
 	 * Iterate over each registered DMAC
 	 */
-	list_for_each_safe(pos, tmp, &registered_dmac_list) {
-		struct dma_info *info = list_entry(pos, struct dma_info, list);
+	list_for_each_entry(info, &registered_dmac_list, list) {
 		int i;
 
 		/*
@@ -205,9 +217,9 @@ static int dma_read_proc(char *buf, char
 #endif
 
 
-int __init register_dmac(struct dma_info *info)
+int register_dmac(struct dma_info *info)
 {
-	int i;
+	unsigned int total_channels, i;
 
 	INIT_LIST_HEAD(&info->list);
 
@@ -217,6 +229,11 @@ int __init register_dmac(struct dma_info
 
 	BUG_ON((info->flags & DMAC_CHANNELS_CONFIGURED) && !info->channels);
 
+	info->pdev = platform_device_register_simple((char *)info->name, -1,
+						     NULL, 0);
+	if (IS_ERR(info->pdev))
+		return PTR_ERR(info->pdev);
+
 	/*
 	 * Don't touch pre-configured channels
 	 */
@@ -232,10 +249,12 @@ int __init register_dmac(struct dma_info
 		memset(info->channels, 0, size);
 	}
 
+	total_channels = get_nr_channels();
 	for (i = 0; i < info->nr_channels; i++) {
 		struct dma_channel *chan = info->channels + i;
 
 		chan->chan = i;
+		chan->vchan = i + total_channels;
 
 		memcpy(chan->dev_id, "Unused", 7);
 
@@ -245,9 +264,7 @@ int __init register_dmac(struct dma_info
 		init_MUTEX(&chan->sem);
 		init_waitqueue_head(&chan->wait_queue);
 
-#ifdef CONFIG_SYSFS
-		dma_create_sysfs_files(chan);
-#endif
+		dma_create_sysfs_files(chan, info);
 	}
 
 	list_add(&info->list, &registered_dmac_list);
@@ -255,12 +272,18 @@ int __init register_dmac(struct dma_info
 	return 0;
 }
 
-void __exit unregister_dmac(struct dma_info *info)
+void unregister_dmac(struct dma_info *info)
 {
+	unsigned int i;
+
+	for (i = 0; i < info->nr_channels; i++)
+		dma_remove_sysfs_files(info->channels + i, info);
+
 	if (!(info->flags & DMAC_CHANNELS_CONFIGURED))
 		kfree(info->channels);
 
 	list_del(&info->list);
+	platform_device_unregister(info->pdev);
 }
 
 static int __init dma_api_init(void)
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-g2.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-g2.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-g2.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-g2.c	2006-01-17 08:22:44.111461925 +0000
@@ -140,7 +140,7 @@ static struct dma_ops g2_dma_ops = {
 };
 
 static struct dma_info g2_dma_info = {
-	.name		= "G2 DMA",
+	.name		= "g2_dmac",
 	.nr_channels	= 4,
 	.ops		= &g2_dma_ops,
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
@@ -160,6 +160,7 @@ static int __init g2_dma_init(void)
 static void __exit g2_dma_exit(void)
 {
 	free_irq(HW_EVENT_G2_DMA, 0);
+	unregister_dmac(&g2_dma_info);
 }
 
 subsys_initcall(g2_dma_init);
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-isa.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-isa.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-isa.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-isa.c	2006-01-17 08:22:44.112461767 +0000
@@ -25,14 +25,14 @@
  * such, this code is meant for only the simplest of tasks (and shouldn't be
  * used in any new drivers at all).
  *
- * It should also be noted that various functions here are labelled as
- * being deprecated. This is due to the fact that the ops->xfer() method is
- * the preferred way of doing things (as well as just grabbing the spinlock
- * directly). As such, any users of this interface will be warned rather
- * loudly.
+ * NOTE: ops->xfer() is the preferred way of doing things. However, there
+ * are some users of the ISA DMA API that exist in common code that we
+ * don't necessarily want to go out of our way to break, so we still
+ * allow for some compatability at that level. Any new code is strongly
+ * advised to run far away from the ISA DMA API and use the SH DMA API
+ * directly.
  */
-
-unsigned long __deprecated claim_dma_lock(void)
+unsigned long claim_dma_lock(void)
 {
 	unsigned long flags;
 
@@ -42,19 +42,19 @@ unsigned long __deprecated claim_dma_loc
 }
 EXPORT_SYMBOL(claim_dma_lock);
 
-void __deprecated release_dma_lock(unsigned long flags)
+void release_dma_lock(unsigned long flags)
 {
 	spin_unlock_irqrestore(&dma_spin_lock, flags);
 }
 EXPORT_SYMBOL(release_dma_lock);
 
-void __deprecated disable_dma(unsigned int chan)
+void disable_dma(unsigned int chan)
 {
 	/* Nothing */
 }
 EXPORT_SYMBOL(disable_dma);
 
-void __deprecated enable_dma(unsigned int chan)
+void enable_dma(unsigned int chan)
 {
 	struct dma_info *info = get_dma_info(chan);
 	struct dma_channel *channel = &info->channels[chan];
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-pvr2.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-pvr2.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-pvr2.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-pvr2.c	2006-01-17 08:22:44.113461610 +0000
@@ -80,7 +80,7 @@ static struct dma_ops pvr2_dma_ops = {
 };
 
 static struct dma_info pvr2_dma_info = {
-	.name		= "PowerVR 2 DMA",
+	.name		= "pvr2_dmac",
 	.nr_channels	= 1,
 	.ops		= &pvr2_dma_ops,
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
@@ -98,6 +98,7 @@ static void __exit pvr2_dma_exit(void)
 {
 	free_dma(PVR2_CASCADE_CHAN);
 	free_irq(HW_EVENT_PVR2_DMA, 0);
+	unregister_dmac(&pvr2_dma_info);
 }
 
 subsys_initcall(pvr2_dma_init);
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-sh.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sh.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-sh.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sh.c	2006-01-17 08:22:44.117460980 +0000
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 2000 Takashi YOSHII
  * Copyright (C) 2003, 2004 Paul Mundt
+ * Copyright (C) 2005 Andriy Skulysh
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -16,51 +17,28 @@
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <asm/dreamcast/dma.h>
 #include <asm/signal.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"
 
-/*
- * The SuperH DMAC supports a number of transmit sizes, we list them here,
- * with their respective values as they appear in the CHCR registers.
- *
- * Defaults to a 64-bit transfer size.
- */
-enum {
-	XMIT_SZ_64BIT,
-	XMIT_SZ_8BIT,
-	XMIT_SZ_16BIT,
-	XMIT_SZ_32BIT,
-	XMIT_SZ_256BIT,
-};
-
-/*
- * The DMA count is defined as the number of bytes to transfer.
- */
-static unsigned int ts_shift[] = {
-	[XMIT_SZ_64BIT]		= 3,
-	[XMIT_SZ_8BIT]		= 0,
-	[XMIT_SZ_16BIT]		= 1,
-	[XMIT_SZ_32BIT]		= 2,
-	[XMIT_SZ_256BIT]	= 5,
-};
-
 static inline unsigned int get_dmte_irq(unsigned int chan)
 {
-	unsigned int irq;
+	unsigned int irq = 0;
 
 	/*
 	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
 	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
 	 * the SCIF
 	 */
-
 	if (chan < 4) {
 		irq = DMTE0_IRQ + chan;
 	} else {
+#ifdef DMTE4_IRQ
 		irq = DMTE4_IRQ + chan - 4;
+#endif
 	}
 
 	return irq;
@@ -78,9 +56,7 @@ static inline unsigned int calc_xmit_shi
 {
 	u32 chcr = ctrl_inl(CHCR[chan->chan]);
 
-	chcr >>= 4;
-
-	return ts_shift[chcr & 0x0007];
+	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
 }
 
 /*
@@ -109,8 +85,13 @@ static irqreturn_t dma_tei(int irq, void
 
 static int sh_dmac_request_dma(struct dma_channel *chan)
 {
+	char name[32];
+
+	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
+		 chan->chan);
+
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   SA_INTERRUPT, "DMAC Transfer End", chan);
+			   SA_INTERRUPT, name, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
@@ -118,10 +99,18 @@ static void sh_dmac_free_dma(struct dma_
 	free_irq(get_dmte_irq(chan->chan), chan);
 }
 
-static void sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
+static void
+sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 {
 	if (!chcr)
-		chcr = RS_DUAL;
+		chcr = RS_DUAL | CHCR_IE;
+
+	if (chcr & CHCR_IE) {
+		chcr &= ~CHCR_IE;
+		chan->flags |= DMA_TEI_CAPABLE;
+	} else {
+		chan->flags &= ~DMA_TEI_CAPABLE;
+	}
 
 	ctrl_outl(chcr, CHCR[chan->chan]);
 
@@ -130,22 +119,32 @@ static void sh_dmac_configure_channel(st
 
 static void sh_dmac_enable_dma(struct dma_channel *chan)
 {
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
 	u32 chcr;
 
 	chcr = ctrl_inl(CHCR[chan->chan]);
-	chcr |= CHCR_DE | CHCR_IE;
+	chcr |= CHCR_DE;
+
+	if (chan->flags & DMA_TEI_CAPABLE)
+		chcr |= CHCR_IE;
+
 	ctrl_outl(chcr, CHCR[chan->chan]);
 
-	enable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		enable_irq(irq);
+	}
 }
 
 static void sh_dmac_disable_dma(struct dma_channel *chan)
 {
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
 	u32 chcr;
 
-	disable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		disable_irq(irq);
+	}
 
 	chcr = ctrl_inl(CHCR[chan->chan]);
 	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
@@ -158,7 +157,7 @@ static int sh_dmac_xfer_dma(struct dma_c
 	 * If we haven't pre-configured the channel with special flags, use
 	 * the defaults.
 	 */
-	if (!(chan->flags & DMA_CONFIGURED))
+	if (unlikely(!(chan->flags & DMA_CONFIGURED)))
 		sh_dmac_configure_channel(chan, 0);
 
 	sh_dmac_disable_dma(chan);
@@ -178,9 +177,11 @@ static int sh_dmac_xfer_dma(struct dma_c
 	 * cascading to the PVR2 DMAC. In this case, we still need to write
 	 * SAR and DAR, regardless of value, in order for cascading to work.
 	 */
-	if (chan->sar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->sar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
 		ctrl_outl(chan->sar, SAR[chan->chan]);
-	if (chan->dar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->dar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
 		ctrl_outl(chan->dar, DAR[chan->chan]);
 
 	ctrl_outl(chan->count >> calc_xmit_shift(chan), DMATCR[chan->chan]);
@@ -198,17 +199,38 @@ static int sh_dmac_get_dma_residue(struc
 	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
 }
 
-#if defined(CONFIG_CPU_SH4)
-static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#define dmaor_read_reg()	ctrl_inw(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
+#else
+#define dmaor_read_reg()	ctrl_inl(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outl(data, DMAOR)
+#endif
+
+static inline int dmaor_reset(void)
 {
-	unsigned long dmaor = ctrl_inl(DMAOR);
+	unsigned long dmaor = dmaor_read_reg();
+
+	/* Try to clear the error flags first, incase they are set */
+	dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
+	dmaor_write_reg(dmaor);
 
-	printk("DMAE: DMAOR=%lx\n", dmaor);
+	dmaor |= DMAOR_INIT;
+	dmaor_write_reg(dmaor);
 
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_NMIF, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_AE, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)|DMAOR_DME, DMAOR);
+	/* See if we got an error again */
+	if ((dmaor_read_reg() & (DMAOR_AE | DMAOR_NMIF))) {
+		printk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");
+		return -EINVAL;
+	}
 
+	return 0;
+}
+
+#if defined(CONFIG_CPU_SH4)
+static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dmaor_reset();
 	disable_irq(irq);
 
 	return IRQ_HANDLED;
@@ -224,8 +246,8 @@ static struct dma_ops sh_dmac_ops = {
 };
 
 static struct dma_info sh_dmac_info = {
-	.name		= "SuperH DMAC",
-	.nr_channels	= 4,
+	.name		= "sh_dmac",
+	.nr_channels	= CONFIG_NR_ONCHIP_DMA_CHANNELS,
 	.ops		= &sh_dmac_ops,
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
 };
@@ -248,7 +270,13 @@ static int __init sh_dmac_init(void)
 		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
 	}
 
-	ctrl_outl(0x8000 | DMAOR_DME, DMAOR);
+	/*
+	 * Initialize DMAOR, and clean up any error flags that may have
+	 * been set.
+	 */
+	i = dmaor_reset();
+	if (i < 0)
+		return i;
 
 	return register_dmac(info);
 }
@@ -258,10 +286,12 @@ static void __exit sh_dmac_exit(void)
 #ifdef CONFIG_CPU_SH4
 	free_irq(DMAE_IRQ, 0);
 #endif
+	unregister_dmac(&sh_dmac_info);
 }
 
 subsys_initcall(sh_dmac_init);
 module_exit(sh_dmac_exit);
 
+MODULE_AUTHOR("Takashi YOSHII, Paul Mundt, Andriy Skulysh");
+MODULE_DESCRIPTION("SuperH On-Chip DMAC Support");
 MODULE_LICENSE("GPL");
-
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-sh.h linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sh.h
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-sh.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sh.h	2006-01-17 08:22:44.119460665 +0000
@@ -11,6 +11,8 @@
 #ifndef __DMA_SH_H
 #define __DMA_SH_H
 
+#include <asm/cpu/dma.h>
+
 /* Definitions for the SuperH DMAC */
 #define REQ_L	0x00000000
 #define REQ_E	0x00080000
@@ -26,27 +28,47 @@
 #define SM_DEC	0x00002000
 #define RS_IN	0x00000200
 #define RS_OUT	0x00000300
-#define TM_BURST 0x0000080
-#define TS_8	0x00000010
-#define TS_16	0x00000020
-#define TS_32	0x00000030
-#define TS_64	0x00000000
 #define TS_BLK	0x00000040
 #define CHCR_DE 0x00000001
 #define CHCR_TE 0x00000002
 #define CHCR_IE 0x00000004
 
-/* Define the default configuration for dual address memory-memory transfer.
- * The 0x400 value represents auto-request, external->external.
- */
-#define RS_DUAL	(DM_INC | SM_INC | 0x400 | TS_32)
-
-#define DMAOR_COD	0x00000008
+/* DMAOR definitions */
 #define DMAOR_AE	0x00000004
 #define DMAOR_NMIF	0x00000002
 #define DMAOR_DME	0x00000001
 
+/*
+ * Define the default configuration for dual address memory-memory transfer.
+ * The 0x400 value represents auto-request, external->external.
+ */
+#define RS_DUAL	(DM_INC | SM_INC | 0x400 | TS_32)
+
 #define MAX_DMAC_CHANNELS	(CONFIG_NR_ONCHIP_DMA_CHANNELS)
 
+/*
+ * Subtypes that have fewer channels than this simply need to change
+ * CONFIG_NR_ONCHIP_DMA_CHANNELS. Likewise, subtypes with a larger number
+ * of channels should expand on this.
+ *
+ * For most subtypes we can easily figure these values out with some
+ * basic calculation, unfortunately on other subtypes these are more
+ * scattered, so we just leave it unrolled for simplicity.
+ */
+#define SAR	((unsigned long[]){SH_DMAC_BASE + 0x00, SH_DMAC_BASE + 0x10, \
+				   SH_DMAC_BASE + 0x20, SH_DMAC_BASE + 0x30, \
+				   SH_DMAC_BASE + 0x50, SH_DMAC_BASE + 0x60})
+#define DAR	((unsigned long[]){SH_DMAC_BASE + 0x04, SH_DMAC_BASE + 0x14, \
+				   SH_DMAC_BASE + 0x24, SH_DMAC_BASE + 0x34, \
+				   SH_DMAC_BASE + 0x54, SH_DMAC_BASE + 0x64})
+#define DMATCR	((unsigned long[]){SH_DMAC_BASE + 0x08, SH_DMAC_BASE + 0x18, \
+				   SH_DMAC_BASE + 0x28, SH_DMAC_BASE + 0x38, \
+				   SH_DMAC_BASE + 0x58, SH_DMAC_BASE + 0x68})
+#define CHCR	((unsigned long[]){SH_DMAC_BASE + 0x0c, SH_DMAC_BASE + 0x1c, \
+				   SH_DMAC_BASE + 0x2c, SH_DMAC_BASE + 0x3c, \
+				   SH_DMAC_BASE + 0x5c, SH_DMAC_BASE + 0x6c})
+
+#define DMAOR	(SH_DMAC_BASE + 0x40)
+
 #endif /* __DMA_SH_H */
 
diff -purN linux-2.6.15-git12/arch/sh/drivers/dma/dma-sysfs.c linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sysfs.c
--- linux-2.6.15-git12/arch/sh/drivers/dma/dma-sysfs.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/drivers/dma/dma-sysfs.c	2006-01-17 08:22:44.120460508 +0000
@@ -3,7 +3,7 @@
  *
  * sysfs interface for SH DMA API
  *
- * Copyright (C) 2004  Paul Mundt
+ * Copyright (C) 2004, 2005  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -12,7 +12,9 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/sysdev.h>
+#include <linux/platform_device.h>
 #include <linux/module.h>
+#include <linux/err.h>
 #include <linux/string.h>
 #include <asm/dma.h>
 
@@ -77,7 +79,7 @@ static ssize_t dma_store_config(struct s
 	unsigned long config;
 
 	config = simple_strtoul(buf, NULL, 0);
-	dma_configure_channel(channel->chan, config);
+	dma_configure_channel(channel->vchan, config);
 
 	return count;
 }
@@ -111,12 +113,13 @@ static SYSDEV_ATTR(field, S_IRUGO, dma_s
 dma_ro_attr(count, "0x%08x\n");
 dma_ro_attr(flags, "0x%08lx\n");
 
-int __init dma_create_sysfs_files(struct dma_channel *chan)
+int dma_create_sysfs_files(struct dma_channel *chan, struct dma_info *info)
 {
 	struct sys_device *dev = &chan->dev;
+	char name[16];
 	int ret;
 
-	dev->id  = chan->chan;
+	dev->id  = chan->vchan;
 	dev->cls = &dma_sysclass;
 
 	ret = sysdev_register(dev);
@@ -129,6 +132,24 @@ int __init dma_create_sysfs_files(struct
 	sysdev_create_file(dev, &attr_flags);
 	sysdev_create_file(dev, &attr_config);
 
-	return 0;
+	snprintf(name, sizeof(name), "dma%d", chan->chan);
+	return sysfs_create_link(&info->pdev->dev.kobj, &dev->kobj, name);
+}
+
+void dma_remove_sysfs_files(struct dma_channel *chan, struct dma_info *info)
+{
+	struct sys_device *dev = &chan->dev;
+	char name[16];
+
+	sysdev_remove_file(dev, &attr_dev_id);
+	sysdev_remove_file(dev, &attr_count);
+	sysdev_remove_file(dev, &attr_mode);
+	sysdev_remove_file(dev, &attr_flags);
+	sysdev_remove_file(dev, &attr_config);
+
+	snprintf(name, sizeof(name), "dma%d", chan->chan);
+	sysfs_remove_link(&info->pdev->dev.kobj, name);
+
+	sysdev_unregister(dev);
 }
 
diff -purN linux-2.6.15-git12/arch/sh/kernel/Makefile linux-2.6.16-rc1/arch/sh/kernel/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/Makefile	2006-01-17 08:22:44.121460351 +0000
@@ -17,6 +17,4 @@ obj-$(CONFIG_SH_KGDB)		+= kgdb_stub.o kg
 obj-$(CONFIG_SH_CPU_FREQ)	+= cpufreq.o
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
-
-USE_STANDARD_AS_RULE := true
-
+obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/Makefile linux-2.6.16-rc1/arch/sh/kernel/cpu/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/cpu/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/Makefile	2006-01-17 08:22:44.122460193 +0000
@@ -2,15 +2,12 @@
 # Makefile for the Linux/SuperH CPU-specifc backends.
 #
 
-obj-y	:= irq_ipr.o irq_imask.o init.o bus.o
+obj-y	+= irq/ init.o bus.o clock.o
 
 obj-$(CONFIG_CPU_SH2)		+= sh2/
 obj-$(CONFIG_CPU_SH3)		+= sh3/
 obj-$(CONFIG_CPU_SH4)		+= sh4/
 
-obj-$(CONFIG_SH_RTC)            += rtc.o
+obj-$(CONFIG_SH_RTC)		+= rtc.o
 obj-$(CONFIG_UBC_WAKEUP)	+= ubc.o
-obj-$(CONFIG_SH_ADC)            += adc.o
-
-USE_STANDARD_AS_RULE := true
-
+obj-$(CONFIG_SH_ADC)		+= adc.o
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/bus.c linux-2.6.16-rc1/arch/sh/kernel/cpu/bus.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/bus.c	2006-01-17 08:21:30.115791649 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/bus.c	2006-01-17 08:22:44.124459878 +0000
@@ -109,6 +109,8 @@ int sh_device_register(struct sh_dev *de
 	/* This is needed for USB OHCI to work */
 	if (dev->dma_mask)
 		dev->dev.dma_mask = dev->dma_mask;
+	if (dev->coherent_dma_mask)
+		dev->dev.coherent_dma_mask = dev->coherent_dma_mask;
 
 	snprintf(dev->dev.bus_id, BUS_ID_SIZE, "%s%u",
 		 dev->name, dev->dev_id);
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/clock.c linux-2.6.16-rc1/arch/sh/kernel/cpu/clock.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/clock.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/clock.c	2006-01-17 08:22:44.127459406 +0000
@@ -0,0 +1,287 @@
+/*
+ * arch/sh/kernel/cpu/clock.c - SuperH clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This clock framework is derived from the OMAP version by:
+ *
+ *	Copyright (C) 2004 Nokia Corporation
+ *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/kref.h>
+#include <linux/seq_file.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/timer.h>
+
+static LIST_HEAD(clock_list);
+static DEFINE_SPINLOCK(clock_lock);
+static DECLARE_MUTEX(clock_list_sem);
+
+/*
+ * Each subtype is expected to define the init routines for these clocks,
+ * as each subtype (or processor family) will have these clocks at the
+ * very least. These are all provided through the CPG, which even some of
+ * the more quirky parts (such as ST40, SH4-202, etc.) still have.
+ *
+ * The processor-specific code is expected to register any additional
+ * clock sources that are of interest.
+ */
+static struct clk master_clk = {
+	.name		= "master_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+#ifdef CONFIG_SH_PCLK_FREQ_BOOL
+	.rate		= CONFIG_SH_PCLK_FREQ,
+#endif
+};
+
+static struct clk module_clk = {
+	.name		= "module_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk bus_clk = {
+	.name		= "bus_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk cpu_clk = {
+	.name		= "cpu_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED,
+};
+
+/*
+ * The ordering of these clocks matters, do not change it.
+ */
+static struct clk *onchip_clocks[] = {
+	&master_clk,
+	&module_clk,
+	&bus_clk,
+	&cpu_clk,
+};
+
+static void propagate_rate(struct clk *clk)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clock_list, node) {
+		if (likely(clkp->parent != clk))
+			continue;
+		if (likely(clkp->ops && clkp->ops->recalc))
+			clkp->ops->recalc(clkp);
+	}
+}
+
+int __clk_enable(struct clk *clk)
+{
+	/*
+	 * See if this is the first time we're enabling the clock, some
+	 * clocks that are always enabled still require "special"
+	 * initialization. This is especially true if the clock mode
+	 * changes and the clock needs to hunt for the proper set of
+	 * divisors to use before it can effectively recalc.
+	 */
+	if (unlikely(atomic_read(&clk->kref.refcount) == 1))
+		if (clk->ops && clk->ops->init)
+			clk->ops->init(clk);
+
+	if (clk->flags & CLK_ALWAYS_ENABLED)
+		return 0;
+
+	if (likely(clk->ops && clk->ops->enable))
+		clk->ops->enable(clk);
+
+	kref_get(&clk->kref);
+	return 0;
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&clock_lock, flags);
+	ret = __clk_enable(clk);
+	spin_unlock_irqrestore(&clock_lock, flags);
+
+	return ret;
+}
+
+static void clk_kref_release(struct kref *kref)
+{
+	/* Nothing to do */
+}
+
+void __clk_disable(struct clk *clk)
+{
+	if (clk->flags & CLK_ALWAYS_ENABLED)
+		return;
+
+	kref_put(&clk->kref, clk_kref_release);
+}
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&clock_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&clock_lock, flags);
+}
+
+int clk_register(struct clk *clk)
+{
+	down(&clock_list_sem);
+
+	list_add(&clk->node, &clock_list);
+	kref_init(&clk->kref);
+
+	up(&clock_list_sem);
+
+	return 0;
+}
+
+void clk_unregister(struct clk *clk)
+{
+	down(&clock_list_sem);
+	list_del(&clk->node);
+	up(&clock_list_sem);
+}
+
+inline unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (likely(clk->ops && clk->ops->set_rate)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		ret = clk->ops->set_rate(clk, rate);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+
+	return ret;
+}
+
+void clk_recalc_rate(struct clk *clk)
+{
+	if (likely(clk->ops && clk->ops->recalc)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		clk->ops->recalc(clk);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+}
+
+struct clk *clk_get(const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	down(&clock_list_sem);
+	list_for_each_entry(p, &clock_list, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	up(&clock_list_sem);
+
+	return clk;
+}
+
+void clk_put(struct clk *clk)
+{
+	if (clk && !IS_ERR(clk))
+		module_put(clk->owner);
+}
+
+void __init __attribute__ ((weak))
+arch_init_clk_ops(struct clk_ops **ops, int type)
+{
+}
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	if (unlikely(!master_clk.rate))
+		/*
+		 * NOTE: This will break if the default divisor has been
+		 * changed.
+		 *
+		 * No one should be changing the default on us however,
+		 * expect that a sane value for CONFIG_SH_PCLK_FREQ will
+		 * be defined in the event of a different divisor.
+		 */
+		master_clk.rate = get_timer_frequency() * 4;
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		arch_init_clk_ops(&clk->ops, i);
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Kick the child clocks.. */
+	propagate_rate(&master_clk);
+	propagate_rate(&bus_clk);
+
+	return ret;
+}
+
+int show_clocks(struct seq_file *m)
+{
+	struct clk *clk;
+
+	list_for_each_entry_reverse(clk, &clock_list, node) {
+		unsigned long rate = clk_get_rate(clk);
+
+		/*
+		 * Don't bother listing dummy clocks with no ancestry
+		 * that only support enable and disable ops.
+		 */
+		if (unlikely(!rate && !clk->parent))
+			continue;
+
+		seq_printf(m, "%-12s\t: %ld.%02ldMHz\n", clk->name,
+			   rate / 1000000, (rate % 1000000) / 10000);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(clk_register);
+EXPORT_SYMBOL_GPL(clk_unregister);
+EXPORT_SYMBOL_GPL(clk_get);
+EXPORT_SYMBOL_GPL(clk_put);
+EXPORT_SYMBOL_GPL(clk_enable);
+EXPORT_SYMBOL_GPL(clk_disable);
+EXPORT_SYMBOL_GPL(__clk_enable);
+EXPORT_SYMBOL_GPL(__clk_disable);
+EXPORT_SYMBOL_GPL(clk_get_rate);
+EXPORT_SYMBOL_GPL(clk_set_rate);
+EXPORT_SYMBOL_GPL(clk_recalc_rate);
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq/Makefile linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/Makefile	2006-01-17 08:22:44.128459249 +0000
@@ -0,0 +1,7 @@
+#
+# Makefile for the Linux/SuperH CPU-specifc IRQ handlers.
+#
+obj-y	+= ipr.o imask.o
+
+obj-$(CONFIG_CPU_HAS_PINT_IRQ)	+= pint.o
+obj-$(CONFIG_CPU_HAS_INTC2_IRQ)	+= intc2.o
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq/imask.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/imask.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq/imask.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/imask.c	2006-01-17 08:22:44.129459091 +0000
@@ -0,0 +1,110 @@
+/*
+ * arch/sh/kernel/cpu/irq/imask.c
+ *
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ *
+ * Simple interrupt handling using IMASK of SR register.
+ *
+ */
+/* NOTE: Will not work on level 15 */
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/spinlock.h>
+#include <linux/cache.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+
+/* Bitmap of IRQ masked */
+static unsigned long imask_mask = 0x7fff;
+static int interrupt_priority = 0;
+
+static void enable_imask_irq(unsigned int irq);
+static void disable_imask_irq(unsigned int irq);
+static void shutdown_imask_irq(unsigned int irq);
+static void mask_and_ack_imask(unsigned int);
+static void end_imask_irq(unsigned int irq);
+
+#define IMASK_PRIORITY	15
+
+static unsigned int startup_imask_irq(unsigned int irq)
+{
+	/* Nothing to do */
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type imask_irq_type = {
+	.typename = "SR.IMASK",
+	.startup = startup_imask_irq,
+	.shutdown = shutdown_imask_irq,
+	.enable = enable_imask_irq,
+	.disable = disable_imask_irq,
+	.ack = mask_and_ack_imask,
+	.end = end_imask_irq
+};
+
+void static inline set_interrupt_registers(int ip)
+{
+	unsigned long __dummy;
+
+	asm volatile("ldc	%2, r6_bank\n\t"
+		     "stc	sr, %0\n\t"
+		     "and	#0xf0, %0\n\t"
+		     "shlr2	%0\n\t"
+		     "cmp/eq	#0x3c, %0\n\t"
+		     "bt/s	1f	! CLI-ed\n\t"
+		     " stc	sr, %0\n\t"
+		     "and	%1, %0\n\t"
+		     "or	%2, %0\n\t"
+		     "ldc	%0, sr\n"
+		     "1:"
+		     : "=&z" (__dummy)
+		     : "r" (~0xf0), "r" (ip << 4)
+		     : "t");
+}
+
+static void disable_imask_irq(unsigned int irq)
+{
+	clear_bit(irq, &imask_mask);
+	if (interrupt_priority < IMASK_PRIORITY - irq)
+		interrupt_priority = IMASK_PRIORITY - irq;
+
+	set_interrupt_registers(interrupt_priority);
+}
+
+static void enable_imask_irq(unsigned int irq)
+{
+	set_bit(irq, &imask_mask);
+	interrupt_priority = IMASK_PRIORITY - ffz(imask_mask);
+
+	set_interrupt_registers(interrupt_priority);
+}
+
+static void mask_and_ack_imask(unsigned int irq)
+{
+	disable_imask_irq(irq);
+}
+
+static void end_imask_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_imask_irq(irq);
+}
+
+static void shutdown_imask_irq(unsigned int irq)
+{
+	/* Nothing to do */
+}
+
+void make_imask_irq(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+	irq_desc[irq].handler = &imask_irq_type;
+	enable_irq(irq);
+}
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq/intc2.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/intc2.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq/intc2.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/intc2.c	2006-01-17 08:22:44.133458461 +0000
@@ -0,0 +1,284 @@
+/*
+ * Interrupt handling for INTC2-based IRQ.
+ *
+ * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
+ * Copyright (C) 2005, 2006 Paul Mundt (lethal@linux-sh.org)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * These are the "new Hitachi style" interrupts, as present on the
+ * Hitachi 7751, the STM ST40 STB1, SH7760, and SH7780.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+
+struct intc2_data {
+	unsigned char msk_offset;
+	unsigned char msk_shift;
+
+	int (*clear_irq) (int);
+};
+
+static struct intc2_data intc2_data[NR_INTC2_IRQS];
+
+static void enable_intc2_irq(unsigned int irq);
+static void disable_intc2_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_intc2_irq disable_intc2_irq
+
+static void mask_and_ack_intc2(unsigned int);
+static void end_intc2_irq(unsigned int irq);
+
+static unsigned int startup_intc2_irq(unsigned int irq)
+{
+	enable_intc2_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type intc2_irq_type = {
+	.typename	= "INTC2-IRQ",
+	.startup	= startup_intc2_irq,
+	.shutdown	= shutdown_intc2_irq,
+	.enable		= enable_intc2_irq,
+	.disable	= disable_intc2_irq,
+	.ack		= mask_and_ack_intc2,
+	.end		= end_intc2_irq
+};
+
+static void disable_intc2_irq(unsigned int irq)
+{
+	int irq_offset = irq - INTC2_FIRST_IRQ;
+	int msk_shift, msk_offset;
+
+	/* Sanity check */
+	if (unlikely(irq_offset < 0 || irq_offset >= NR_INTC2_IRQS))
+		return;
+
+	msk_shift = intc2_data[irq_offset].msk_shift;
+	msk_offset = intc2_data[irq_offset].msk_offset;
+
+	ctrl_outl(1 << msk_shift,
+		  INTC2_BASE + INTC2_INTMSK_OFFSET + msk_offset);
+}
+
+static void enable_intc2_irq(unsigned int irq)
+{
+	int irq_offset = irq - INTC2_FIRST_IRQ;
+	int msk_shift, msk_offset;
+
+	/* Sanity check */
+	if (unlikely(irq_offset < 0 || irq_offset >= NR_INTC2_IRQS))
+		return;
+
+	msk_shift = intc2_data[irq_offset].msk_shift;
+	msk_offset = intc2_data[irq_offset].msk_offset;
+
+	ctrl_outl(1 << msk_shift,
+		  INTC2_BASE + INTC2_INTMSKCLR_OFFSET + msk_offset);
+}
+
+static void mask_and_ack_intc2(unsigned int irq)
+{
+	disable_intc2_irq(irq);
+}
+
+static void end_intc2_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_intc2_irq(irq);
+
+	if (unlikely(intc2_data[irq - INTC2_FIRST_IRQ].clear_irq))
+		intc2_data[irq - INTC2_FIRST_IRQ].clear_irq(irq);
+}
+
+/*
+ * Setup an INTC2 style interrupt.
+ * NOTE: Unlike IPR interrupts, parameters are not shifted by this code,
+ * allowing the use of the numbers straight out of the datasheet.
+ * For example:
+ *    PIO1 which is INTPRI00[19,16] and INTMSK00[13]
+ * would be:               ^     ^             ^  ^
+ *                         |     |             |  |
+ *    make_intc2_irq(84,   0,   16,            0, 13);
+ */
+void make_intc2_irq(unsigned int irq,
+		    unsigned int ipr_offset, unsigned int ipr_shift,
+		    unsigned int msk_offset, unsigned int msk_shift,
+		    unsigned int priority)
+{
+	int irq_offset = irq - INTC2_FIRST_IRQ;
+	unsigned int flags;
+	unsigned long ipr;
+
+	if (unlikely(irq_offset < 0 || irq_offset >= NR_INTC2_IRQS))
+		return;
+
+	disable_irq_nosync(irq);
+
+	/* Fill the data we need */
+	intc2_data[irq_offset].msk_offset = msk_offset;
+	intc2_data[irq_offset].msk_shift  = msk_shift;
+	intc2_data[irq_offset].clear_irq = NULL;
+
+	/* Set the priority level */
+	local_irq_save(flags);
+
+	ipr = ctrl_inl(INTC2_BASE + INTC2_INTPRI_OFFSET + ipr_offset);
+	ipr &= ~(0xf << ipr_shift);
+	ipr |= priority << ipr_shift;
+	ctrl_outl(ipr, INTC2_BASE + INTC2_INTPRI_OFFSET + ipr_offset);
+
+	local_irq_restore(flags);
+
+	irq_desc[irq].handler = &intc2_irq_type;
+
+	disable_intc2_irq(irq);
+}
+
+static struct intc2_init {
+	unsigned short irq;
+	unsigned char ipr_offset, ipr_shift;
+	unsigned char msk_offset, msk_shift;
+	unsigned char priority;
+} intc2_init_data[]  __initdata = {
+#if defined(CONFIG_CPU_SUBTYPE_ST40)
+	{64,  0,  0, 0,  0, 13},	/* PCI serr */
+	{65,  0,  4, 0,  1, 13},	/* PCI err */
+	{66,  0,  4, 0,  2, 13},	/* PCI ad */
+	{67,  0,  4, 0,  3, 13},	/* PCI pwd down */
+	{72,  0,  8, 0,  5, 13},	/* DMAC INT0 */
+	{73,  0,  8, 0,  6, 13},	/* DMAC INT1 */
+	{74,  0,  8, 0,  7, 13},	/* DMAC INT2 */
+	{75,  0,  8, 0,  8, 13},	/* DMAC INT3 */
+	{76,  0,  8, 0,  9, 13},	/* DMAC INT4 */
+	{78,  0,  8, 0, 11, 13},	/* DMAC ERR */
+	{80,  0, 12, 0, 12, 13},	/* PIO0 */
+	{84,  0, 16, 0, 13, 13},	/* PIO1 */
+	{88,  0, 20, 0, 14, 13},	/* PIO2 */
+	{112, 4,  0, 4,  0, 13},	/* Mailbox */
+ #ifdef CONFIG_CPU_SUBTYPE_ST40GX1
+	{116, 4,  4, 4,  4, 13},	/* SSC0 */
+	{120, 4,  8, 4,  8, 13},	/* IR Blaster */
+	{124, 4, 12, 4, 12, 13},	/* USB host */
+	{128, 4, 16, 4, 16, 13},	/* Video processor BLITTER */
+	{132, 4, 20, 4, 20, 13},	/* UART0 */
+	{134, 4, 20, 4, 22, 13},	/* UART2 */
+	{136, 4, 24, 4, 24, 13},	/* IO_PIO0 */
+	{140, 4, 28, 4, 28, 13},	/* EMPI */
+	{144, 8,  0, 8,  0, 13},	/* MAFE */
+	{148, 8,  4, 8,  4, 13},	/* PWM */
+	{152, 8,  8, 8,  8, 13},	/* SSC1 */
+	{156, 8, 12, 8, 12, 13},	/* IO_PIO1 */
+	{160, 8, 16, 8, 16, 13},	/* USB target */
+	{164, 8, 20, 8, 20, 13},	/* UART1 */
+	{168, 8, 24, 8, 24, 13},	/* Teletext */
+	{172, 8, 28, 8, 28, 13},	/* VideoSync VTG */
+	{173, 8, 28, 8, 29, 13},	/* VideoSync DVP0 */
+	{174, 8, 28, 8, 30, 13},	/* VideoSync DVP1 */
+#endif
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
+/*
+ * SH7760 INTC2-Style interrupts, vectors IRQ48-111 INTEVT 0x800-0xFE0
+ */
+	/* INTPRIO0 | INTMSK0 */
+	{48,  0, 28, 0, 31,  3},	/* IRQ 4 */
+	{49,  0, 24, 0, 30,  3},	/* IRQ 3 */
+	{50,  0, 20, 0, 29,  3},	/* IRQ 2 */
+	{51,  0, 16, 0, 28,  3},	/* IRQ 1 */
+	/* 52-55 (INTEVT 0x880-0x8E0) unused/reserved */
+	/* INTPRIO4 | INTMSK0 */
+	{56,  4, 28, 0, 25,  3},	/* HCAN2_CHAN0 */
+	{57,  4, 24, 0, 24,  3},	/* HCAN2_CHAN1 */
+	{58,  4, 20, 0, 23,  3},	/* I2S_CHAN0   */
+	{59,  4, 16, 0, 22,  3},	/* I2S_CHAN1   */
+	{60,  4, 12, 0, 21,  3},	/* AC97_CHAN0  */
+	{61,  4,  8, 0, 20,  3},	/* AC97_CHAN1  */
+	{62,  4,  4, 0, 19,  3},	/* I2C_CHAN0   */
+	{63,  4,  0, 0, 18,  3},	/* I2C_CHAN1   */
+	/* INTPRIO8 | INTMSK0 */
+	{52,  8, 16, 0, 11,  3},	/* SCIF0_ERI_IRQ */
+	{53,  8, 16, 0, 10,  3},	/* SCIF0_RXI_IRQ */
+	{54,  8, 16, 0,  9,  3},	/* SCIF0_BRI_IRQ */
+	{55,  8, 16, 0,  8,  3},	/* SCIF0_TXI_IRQ */
+	{64,  8, 28, 0, 17,  3},	/* USBHI_IRQ */
+	{65,  8, 24, 0, 16,  3},	/* LCDC      */
+	/* 66, 67 unused */
+	{68,  8, 20, 0, 14, 13},	/* DMABRGI0_IRQ */
+	{69,  8, 20, 0, 13, 13},	/* DMABRGI1_IRQ */
+	{70,  8, 20, 0, 12, 13},	/* DMABRGI2_IRQ */
+	/* 71 unused */
+	{72,  8, 12, 0,  7,  3},	/* SCIF1_ERI_IRQ */
+	{73,  8, 12, 0,  6,  3},	/* SCIF1_RXI_IRQ */
+	{74,  8, 12, 0,  5,  3},	/* SCIF1_BRI_IRQ */
+	{75,  8, 12, 0,  4,  3},	/* SCIF1_TXI_IRQ */
+	{76,  8,  8, 0,  3,  3},	/* SCIF2_ERI_IRQ */
+	{77,  8,  8, 0,  2,  3},	/* SCIF2_RXI_IRQ */
+	{78,  8,  8, 0,  1,  3},	/* SCIF2_BRI_IRQ */
+	{79,  8,  8, 0,  0,  3},	/* SCIF2_TXI_IRQ */
+	/*          | INTMSK4 */
+	{80,  8,  4, 4, 23,  3},	/* SIM_ERI */
+	{81,  8,  4, 4, 22,  3},	/* SIM_RXI */
+	{82,  8,  4, 4, 21,  3},	/* SIM_TXI */
+	{83,  8,  4, 4, 20,  3},	/* SIM_TEI */
+	{84,  8,  0, 4, 19,  3},	/* HSPII */
+	/* INTPRIOC | INTMSK4 */
+	/* 85-87 unused/reserved */
+	{88, 12, 20, 4, 18,  3},	/* MMCI0 */
+	{89, 12, 20, 4, 17,  3},	/* MMCI1 */
+	{90, 12, 20, 4, 16,  3},	/* MMCI2 */
+	{91, 12, 20, 4, 15,  3},	/* MMCI3 */
+	{92, 12, 12, 4,  6,  3},	/* MFI (unsure, bug? in my 7760 manual*/
+	/* 93-107 reserved/undocumented */
+	{108,12,  4, 4,  1,  3},	/* ADC  */
+	{109,12,  0, 4,  0,  3},	/* CMTI */
+	/* 110-111 reserved/unused */
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+	{ TIMER_IRQ, 0, 24, 0, INTC_TMU0_MSK, 2},
+#ifdef CONFIG_SH_RTC
+	{ RTC_IRQ, 4, 0, 0, INTC_RTC_MSK, TIMER_PRIORITY },
+#endif
+	{ SCIF0_ERI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
+	{ SCIF0_RXI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
+	{ SCIF0_BRI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
+	{ SCIF0_TXI_IRQ, 8, 24, 0, INTC_SCIF0_MSK, SCIF0_PRIORITY },
+
+	{ SCIF1_ERI_IRQ, 8, 16, 0, INTC_SCIF1_MSK, SCIF1_PRIORITY },
+	{ SCIF1_RXI_IRQ, 8, 16, 0, INTC_SCIF1_MSK, SCIF1_PRIORITY },
+	{ SCIF1_BRI_IRQ, 8, 16, 0, INTC_SCIF1_MSK, SCIF1_PRIORITY },
+	{ SCIF1_TXI_IRQ, 8, 16, 0, INTC_SCIF1_MSK, SCIF1_PRIORITY },
+
+	{ PCIC0_IRQ, 0x10,  8, 0, INTC_PCIC0_MSK, PCIC0_PRIORITY },
+	{ PCIC1_IRQ, 0x10,  0, 0, INTC_PCIC1_MSK, PCIC1_PRIORITY },
+	{ PCIC2_IRQ, 0x14, 24, 0, INTC_PCIC2_MSK, PCIC2_PRIORITY },
+	{ PCIC3_IRQ, 0x14, 16, 0, INTC_PCIC3_MSK, PCIC3_PRIORITY },
+	{ PCIC4_IRQ, 0x14,  8, 0, INTC_PCIC4_MSK, PCIC4_PRIORITY },
+#endif
+};
+
+void __init init_IRQ_intc2(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(intc2_init_data); i++) {
+		struct intc2_init *p = intc2_init_data + i;
+		make_intc2_irq(p->irq, p->ipr_offset, p->ipr_shift,
+			       p-> msk_offset, p->msk_shift, p->priority);
+	}
+}
+
+/* Adds a termination callback to the interrupt */
+void intc2_add_clear_irq(int irq, int (*fn)(int))
+{
+	if (unlikely(irq < INTC2_FIRST_IRQ))
+		return;
+
+	intc2_data[irq - INTC2_FIRST_IRQ].clear_irq = fn;
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq/ipr.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/ipr.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq/ipr.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/ipr.c	2006-01-17 08:22:44.136457989 +0000
@@ -0,0 +1,206 @@
+/*
+ * arch/sh/kernel/cpu/irq/ipr.c
+ *
+ * Copyright (C) 1999  Niibe Yutaka & Takeshi Yaegashi
+ * Copyright (C) 2000  Kazumoto Kojima
+ * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
+ *
+ * Interrupt handling for IPR-based IRQ.
+ *
+ * Supported system:
+ *	On-chip supporting modules (TMU, RTC, etc.).
+ *	On-chip supporting modules for SH7709/SH7709A/SH7729/SH7300.
+ *	Hitachi SolutionEngine external I/O:
+ *		MS7709SE01, MS7709ASE01, and MS7750SE01
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+
+struct ipr_data {
+	unsigned int addr;	/* Address of Interrupt Priority Register */
+	int shift;		/* Shifts of the 16-bit data */
+	int priority;		/* The priority */
+};
+static struct ipr_data ipr_data[NR_IRQS];
+
+static void enable_ipr_irq(unsigned int irq);
+static void disable_ipr_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_ipr_irq disable_ipr_irq
+
+static void mask_and_ack_ipr(unsigned int);
+static void end_ipr_irq(unsigned int irq);
+
+static unsigned int startup_ipr_irq(unsigned int irq)
+{
+	enable_ipr_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type ipr_irq_type = {
+	.typename = "IPR-IRQ",
+	.startup = startup_ipr_irq,
+	.shutdown = shutdown_ipr_irq,
+	.enable = enable_ipr_irq,
+	.disable = disable_ipr_irq,
+	.ack = mask_and_ack_ipr,
+	.end = end_ipr_irq
+};
+
+static void disable_ipr_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+	unsigned int addr = ipr_data[irq].addr;
+	unsigned short mask = 0xffff ^ (0x0f << ipr_data[irq].shift);
+
+	/* Set the priority in IPR to 0 */
+	local_irq_save(flags);
+	val = ctrl_inw(addr);
+	val &= mask;
+	ctrl_outw(val, addr);
+	local_irq_restore(flags);
+}
+
+static void enable_ipr_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+	unsigned int addr = ipr_data[irq].addr;
+	int priority = ipr_data[irq].priority;
+	unsigned short value = (priority << ipr_data[irq].shift);
+
+	/* Set priority in IPR back to original value */
+	local_irq_save(flags);
+	val = ctrl_inw(addr);
+	val |= value;
+	ctrl_outw(val, addr);
+	local_irq_restore(flags);
+}
+
+static void mask_and_ack_ipr(unsigned int irq)
+{
+	disable_ipr_irq(irq);
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
+	/* This is needed when we use edge triggered setting */
+	/* XXX: Is it really needed? */
+	if (IRQ0_IRQ <= irq && irq <= IRQ5_IRQ) {
+		/* Clear external interrupt request */
+		int a = ctrl_inb(INTC_IRR0);
+		a &= ~(1 << (irq - IRQ0_IRQ));
+		ctrl_outb(a, INTC_IRR0);
+	}
+#endif
+}
+
+static void end_ipr_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_ipr_irq(irq);
+}
+
+void make_ipr_irq(unsigned int irq, unsigned int addr, int pos,
+		  int priority, int maskpos)
+{
+	disable_irq_nosync(irq);
+	ipr_data[irq].addr = addr;
+	ipr_data[irq].shift = pos*4; /* POSition (0-3) x 4 means shift */
+	ipr_data[irq].priority = priority;
+
+	irq_desc[irq].handler = &ipr_irq_type;
+	disable_ipr_irq(irq);
+}
+
+void __init init_IRQ(void)
+{
+#ifndef CONFIG_CPU_SUBTYPE_SH7780
+	make_ipr_irq(TIMER_IRQ, TIMER_IPR_ADDR, TIMER_IPR_POS, TIMER_PRIORITY, 0);
+	make_ipr_irq(TIMER1_IRQ, TIMER1_IPR_ADDR, TIMER1_IPR_POS, TIMER1_PRIORITY, 0);
+#if defined(CONFIG_SH_RTC)
+	make_ipr_irq(RTC_IRQ, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY, 0);
+#endif
+
+#ifdef SCI_ERI_IRQ
+	make_ipr_irq(SCI_ERI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY, 0);
+	make_ipr_irq(SCI_RXI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY, 0);
+	make_ipr_irq(SCI_TXI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY, 0);
+#endif
+
+#ifdef SCIF1_ERI_IRQ
+	make_ipr_irq(SCIF1_ERI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY, 0);
+	make_ipr_irq(SCIF1_RXI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY, 0);
+	make_ipr_irq(SCIF1_BRI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY, 0);
+	make_ipr_irq(SCIF1_TXI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY, 0);
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+	make_ipr_irq(SCIF0_IRQ, SCIF0_IPR_ADDR, SCIF0_IPR_POS, SCIF0_PRIORITY, 0);
+	make_ipr_irq(DMTE2_IRQ, DMA1_IPR_ADDR, DMA1_IPR_POS, DMA1_PRIORITY, 0);
+	make_ipr_irq(DMTE3_IRQ, DMA1_IPR_ADDR, DMA1_IPR_POS, DMA1_PRIORITY, 0);
+	make_ipr_irq(VIO_IRQ, VIO_IPR_ADDR, VIO_IPR_POS, VIO_PRIORITY, 0);
+#endif
+
+#ifdef SCIF_ERI_IRQ
+	make_ipr_irq(SCIF_ERI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY, 0);
+	make_ipr_irq(SCIF_RXI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY, 0);
+	make_ipr_irq(SCIF_BRI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY, 0);
+	make_ipr_irq(SCIF_TXI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY, 0);
+#endif
+
+#ifdef IRDA_ERI_IRQ
+	make_ipr_irq(IRDA_ERI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY, 0);
+	make_ipr_irq(IRDA_RXI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY, 0);
+	make_ipr_irq(IRDA_BRI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY, 0);
+	make_ipr_irq(IRDA_TXI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY, 0);
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
+	/*
+	 * Initialize the Interrupt Controller (INTC)
+	 * registers to their power on values
+	 */
+
+	/*
+	 * Enable external irq (INTC IRQ mode).
+	 * You should set corresponding bits of PFC to "00"
+	 * to enable these interrupts.
+	 */
+	make_ipr_irq(IRQ0_IRQ, IRQ0_IPR_ADDR, IRQ0_IPR_POS, IRQ0_PRIORITY, 0);
+	make_ipr_irq(IRQ1_IRQ, IRQ1_IPR_ADDR, IRQ1_IPR_POS, IRQ1_PRIORITY, 0);
+	make_ipr_irq(IRQ2_IRQ, IRQ2_IPR_ADDR, IRQ2_IPR_POS, IRQ2_PRIORITY, 0);
+	make_ipr_irq(IRQ3_IRQ, IRQ3_IPR_ADDR, IRQ3_IPR_POS, IRQ3_PRIORITY, 0);
+	make_ipr_irq(IRQ4_IRQ, IRQ4_IPR_ADDR, IRQ4_IPR_POS, IRQ4_PRIORITY, 0);
+	make_ipr_irq(IRQ5_IRQ, IRQ5_IPR_ADDR, IRQ5_IPR_POS, IRQ5_PRIORITY, 0);
+#endif
+#endif
+
+#ifdef CONFIG_CPU_HAS_PINT_IRQ
+	init_IRQ_pint();
+#endif
+
+#ifdef CONFIG_CPU_HAS_INTC2_IRQ
+	init_IRQ_intc2();
+#endif
+	/* Perform the machine specific initialisation */
+	if (sh_mv.mv_init_irq != NULL)
+		sh_mv.mv_init_irq();
+}
+
+#if !defined(CONFIG_CPU_HAS_PINT_IRQ)
+int ipr_irq_demux(int irq)
+{
+	return irq;
+}
+#endif
+
+EXPORT_SYMBOL(make_ipr_irq);
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq/pint.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/pint.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq/pint.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq/pint.c	2006-01-17 08:22:44.139457517 +0000
@@ -0,0 +1,169 @@
+/*
+ * arch/sh/kernel/cpu/irq/pint.c - Interrupt handling for PINT-based IRQs.
+ *
+ * Copyright (C) 1999  Niibe Yutaka & Takeshi Yaegashi
+ * Copyright (C) 2000  Kazumoto Kojima
+ * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/machvec.h>
+
+static unsigned char pint_map[256];
+static unsigned long portcr_mask;
+
+static void enable_pint_irq(unsigned int irq);
+static void disable_pint_irq(unsigned int irq);
+
+/* shutdown is same as "disable" */
+#define shutdown_pint_irq disable_pint_irq
+
+static void mask_and_ack_pint(unsigned int);
+static void end_pint_irq(unsigned int irq);
+
+static unsigned int startup_pint_irq(unsigned int irq)
+{
+	enable_pint_irq(irq);
+	return 0; /* never anything pending */
+}
+
+static struct hw_interrupt_type pint_irq_type = {
+	.typename = "PINT-IRQ",
+	.startup = startup_pint_irq,
+	.shutdown = shutdown_pint_irq,
+	.enable = enable_pint_irq,
+	.disable = disable_pint_irq,
+	.ack = mask_and_ack_pint,
+	.end = end_pint_irq
+};
+
+static void disable_pint_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+
+	local_irq_save(flags);
+	val = ctrl_inw(INTC_INTER);
+	val &= ~(1 << (irq - PINT_IRQ_BASE));
+	ctrl_outw(val, INTC_INTER);	/* disable PINTn */
+	portcr_mask &= ~(3 << (irq - PINT_IRQ_BASE)*2);
+	local_irq_restore(flags);
+}
+
+static void enable_pint_irq(unsigned int irq)
+{
+	unsigned long val, flags;
+
+	local_irq_save(flags);
+	val = ctrl_inw(INTC_INTER);
+	val |= 1 << (irq - PINT_IRQ_BASE);
+	ctrl_outw(val, INTC_INTER);	/* enable PINTn */
+	portcr_mask |= 3 << (irq - PINT_IRQ_BASE)*2;
+	local_irq_restore(flags);
+}
+
+static void mask_and_ack_pint(unsigned int irq)
+{
+	disable_pint_irq(irq);
+}
+
+static void end_pint_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_pint_irq(irq);
+}
+
+void make_pint_irq(unsigned int irq)
+{
+	disable_irq_nosync(irq);
+	irq_desc[irq].handler = &pint_irq_type;
+	disable_pint_irq(irq);
+}
+
+void __init init_IRQ_pint(void)
+{
+	int i;
+
+	make_ipr_irq(PINT0_IRQ, PINT0_IPR_ADDR, PINT0_IPR_POS, PINT0_PRIORITY);
+	make_ipr_irq(PINT8_IRQ, PINT8_IPR_ADDR, PINT8_IPR_POS, PINT8_PRIORITY);
+
+	enable_irq(PINT0_IRQ);
+	enable_irq(PINT8_IRQ);
+
+	for(i = 0; i < 16; i++)
+		make_pint_irq(PINT_IRQ_BASE + i);
+
+	for(i = 0; i < 256; i++) {
+		if (i & 1)
+			pint_map[i] = 0;
+		else if (i & 2)
+			pint_map[i] = 1;
+		else if (i & 4)
+			pint_map[i] = 2;
+		else if (i & 8)
+			pint_map[i] = 3;
+		else if (i & 0x10)
+			pint_map[i] = 4;
+		else if (i & 0x20)
+			pint_map[i] = 5;
+		else if (i & 0x40)
+			pint_map[i] = 6;
+		else if (i & 0x80)
+			pint_map[i] = 7;
+	}
+}
+
+int ipr_irq_demux(int irq)
+{
+	unsigned long creg, dreg, d, sav;
+
+	if (irq == PINT0_IRQ) {
+#if defined(CONFIG_CPU_SUBTYPE_SH7707)
+		creg = PORT_PACR;
+		dreg = PORT_PADR;
+#else
+		creg = PORT_PCCR;
+		dreg = PORT_PCDR;
+#endif
+		sav = ctrl_inw(creg);
+		ctrl_outw(sav | portcr_mask, creg);
+		d = (~ctrl_inb(dreg) ^ ctrl_inw(INTC_ICR2)) &
+			ctrl_inw(INTC_INTER) & 0xff;
+		ctrl_outw(sav, creg);
+
+		if (d == 0)
+			return irq;
+
+		return PINT_IRQ_BASE + pint_map[d];
+	} else if (irq == PINT8_IRQ) {
+#if defined(CONFIG_CPU_SUBTYPE_SH7707)
+		creg = PORT_PBCR;
+		dreg = PORT_PBDR;
+#else
+		creg = PORT_PFCR;
+		dreg = PORT_PFDR;
+#endif
+		sav = ctrl_inw(creg);
+		ctrl_outw(sav | (portcr_mask >> 16), creg);
+		d = (~ctrl_inb(dreg) ^ (ctrl_inw(INTC_ICR2) >> 8)) &
+			(ctrl_inw(INTC_INTER) >> 8) & 0xff;
+		ctrl_outw(sav, creg);
+
+		if (d == 0)
+			return irq;
+
+		return PINT_IRQ_BASE + 8 + pint_map[d];
+	}
+
+	return irq;
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq_imask.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq_imask.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq_imask.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq_imask.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,116 +0,0 @@
-/* $Id: irq_imask.c,v 1.1.2.1 2002/11/17 10:53:43 mrbrown Exp $
- *
- * linux/arch/sh/kernel/irq_imask.c
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- *
- * Simple interrupt handling using IMASK of SR register.
- *
- */
-
-/* NOTE: Will not work on level 15 */
-
-
-#include <linux/ptrace.h>
-#include <linux/errno.h>
-#include <linux/kernel_stat.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/bitops.h>
-
-#include <asm/system.h>
-#include <asm/irq.h>
-
-#include <linux/spinlock.h>
-#include <linux/cache.h>
-#include <linux/irq.h>
-
-/* Bitmap of IRQ masked */
-static unsigned long imask_mask = 0x7fff;
-static int interrupt_priority = 0;
-
-static void enable_imask_irq(unsigned int irq);
-static void disable_imask_irq(unsigned int irq);
-static void shutdown_imask_irq(unsigned int irq);
-static void mask_and_ack_imask(unsigned int);
-static void end_imask_irq(unsigned int irq);
-
-#define IMASK_PRIORITY	15
-
-static unsigned int startup_imask_irq(unsigned int irq)
-{ 
-	/* Nothing to do */
-	return 0; /* never anything pending */
-}
-
-static struct hw_interrupt_type imask_irq_type = {
-	.typename = "SR.IMASK",
-	.startup = startup_imask_irq,
-	.shutdown = shutdown_imask_irq,
-	.enable = enable_imask_irq,
-	.disable = disable_imask_irq,
-	.ack = mask_and_ack_imask,
-	.end = end_imask_irq
-};
-
-void static inline set_interrupt_registers(int ip)
-{
-	unsigned long __dummy;
-
-	asm volatile("ldc	%2, r6_bank\n\t"
-		     "stc	sr, %0\n\t"
-		     "and	#0xf0, %0\n\t"
-		     "shlr2	%0\n\t"
-		     "cmp/eq	#0x3c, %0\n\t"
-		     "bt/s	1f	! CLI-ed\n\t"
-		     " stc	sr, %0\n\t"
-		     "and	%1, %0\n\t"
-		     "or	%2, %0\n\t"
-		     "ldc	%0, sr\n"
-		     "1:"
-		     : "=&z" (__dummy)
-		     : "r" (~0xf0), "r" (ip << 4)
-		     : "t");
-}
-
-static void disable_imask_irq(unsigned int irq)
-{
-	clear_bit(irq, &imask_mask);
-	if (interrupt_priority < IMASK_PRIORITY - irq)
-		interrupt_priority = IMASK_PRIORITY - irq;
-
-	set_interrupt_registers(interrupt_priority);
-}
-
-static void enable_imask_irq(unsigned int irq)
-{
-	set_bit(irq, &imask_mask);
-	interrupt_priority = IMASK_PRIORITY - ffz(imask_mask);
-
-	set_interrupt_registers(interrupt_priority);
-}
-
-static void mask_and_ack_imask(unsigned int irq)
-{
-	disable_imask_irq(irq);
-}
-
-static void end_imask_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		enable_imask_irq(irq);
-}
-
-static void shutdown_imask_irq(unsigned int irq)
-{
-	/* Nothing to do */
-}
-
-void make_imask_irq(unsigned int irq)
-{
-	disable_irq_nosync(irq);
-	irq_desc[irq].handler = &imask_irq_type;
-	enable_irq(irq);
-}
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/irq_ipr.c linux-2.6.16-rc1/arch/sh/kernel/cpu/irq_ipr.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/irq_ipr.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/irq_ipr.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,339 +0,0 @@
-/* $Id: irq_ipr.c,v 1.1.2.1 2002/11/17 10:53:43 mrbrown Exp $
- *
- * linux/arch/sh/kernel/irq_ipr.c
- *
- * Copyright (C) 1999  Niibe Yutaka & Takeshi Yaegashi
- * Copyright (C) 2000  Kazumoto Kojima
- * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
- *
- * Interrupt handling for IPR-based IRQ.
- *
- * Supported system:
- *	On-chip supporting modules (TMU, RTC, etc.).
- *	On-chip supporting modules for SH7709/SH7709A/SH7729/SH7300.
- *	Hitachi SolutionEngine external I/O:
- *		MS7709SE01, MS7709ASE01, and MS7750SE01
- *
- */
-
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/module.h>
-
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-
-struct ipr_data {
-	unsigned int addr;	/* Address of Interrupt Priority Register */
-	int shift;		/* Shifts of the 16-bit data */
-	int priority;		/* The priority */
-};
-static struct ipr_data ipr_data[NR_IRQS];
-
-static void enable_ipr_irq(unsigned int irq);
-static void disable_ipr_irq(unsigned int irq);
-
-/* shutdown is same as "disable" */
-#define shutdown_ipr_irq disable_ipr_irq
-
-static void mask_and_ack_ipr(unsigned int);
-static void end_ipr_irq(unsigned int irq);
-
-static unsigned int startup_ipr_irq(unsigned int irq)
-{
-	enable_ipr_irq(irq);
-	return 0; /* never anything pending */
-}
-
-static struct hw_interrupt_type ipr_irq_type = {
-	.typename = "IPR-IRQ",
-	.startup = startup_ipr_irq,
-	.shutdown = shutdown_ipr_irq,
-	.enable = enable_ipr_irq,
-	.disable = disable_ipr_irq,
-	.ack = mask_and_ack_ipr,
-	.end = end_ipr_irq
-};
-
-static void disable_ipr_irq(unsigned int irq)
-{
-	unsigned long val, flags;
-	unsigned int addr = ipr_data[irq].addr;
-	unsigned short mask = 0xffff ^ (0x0f << ipr_data[irq].shift);
-
-	/* Set the priority in IPR to 0 */
-	local_irq_save(flags);
-	val = ctrl_inw(addr);
-	val &= mask;
-	ctrl_outw(val, addr);
-	local_irq_restore(flags);
-}
-
-static void enable_ipr_irq(unsigned int irq)
-{
-	unsigned long val, flags;
-	unsigned int addr = ipr_data[irq].addr;
-	int priority = ipr_data[irq].priority;
-	unsigned short value = (priority << ipr_data[irq].shift);
-
-	/* Set priority in IPR back to original value */
-	local_irq_save(flags);
-	val = ctrl_inw(addr);
-	val |= value;
-	ctrl_outw(val, addr);
-	local_irq_restore(flags);
-}
-
-static void mask_and_ack_ipr(unsigned int irq)
-{
-	disable_ipr_irq(irq);
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
-	/* This is needed when we use edge triggered setting */
-	/* XXX: Is it really needed? */
-	if (IRQ0_IRQ <= irq && irq <= IRQ5_IRQ) {
-		/* Clear external interrupt request */
-		int a = ctrl_inb(INTC_IRR0);
-		a &= ~(1 << (irq - IRQ0_IRQ));
-		ctrl_outb(a, INTC_IRR0);
-	}
-#endif
-}
-
-static void end_ipr_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		enable_ipr_irq(irq);
-}
-
-void make_ipr_irq(unsigned int irq, unsigned int addr, int pos, int priority)
-{
-	disable_irq_nosync(irq);
-	ipr_data[irq].addr = addr;
-	ipr_data[irq].shift = pos*4; /* POSition (0-3) x 4 means shift */
-	ipr_data[irq].priority = priority;
-
-	irq_desc[irq].handler = &ipr_irq_type;
-	disable_ipr_irq(irq);
-}
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7705) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-static unsigned char pint_map[256];
-static unsigned long portcr_mask = 0;
-
-static void enable_pint_irq(unsigned int irq);
-static void disable_pint_irq(unsigned int irq);
-
-/* shutdown is same as "disable" */
-#define shutdown_pint_irq disable_pint_irq
-
-static void mask_and_ack_pint(unsigned int);
-static void end_pint_irq(unsigned int irq);
-
-static unsigned int startup_pint_irq(unsigned int irq)
-{
-	enable_pint_irq(irq);
-	return 0; /* never anything pending */
-}
-
-static struct hw_interrupt_type pint_irq_type = {
-	.typename = "PINT-IRQ",
-	.startup = startup_pint_irq,
-	.shutdown = shutdown_pint_irq,
-	.enable = enable_pint_irq,
-	.disable = disable_pint_irq,
-	.ack = mask_and_ack_pint,
-	.end = end_pint_irq
-};
-
-static void disable_pint_irq(unsigned int irq)
-{
-	unsigned long val, flags;
-
-	local_irq_save(flags);
-	val = ctrl_inw(INTC_INTER);
-	val &= ~(1 << (irq - PINT_IRQ_BASE));
-	ctrl_outw(val, INTC_INTER);	/* disable PINTn */
-	portcr_mask &= ~(3 << (irq - PINT_IRQ_BASE)*2);
-	local_irq_restore(flags);
-}
-
-static void enable_pint_irq(unsigned int irq)
-{
-	unsigned long val, flags;
-
-	local_irq_save(flags);
-	val = ctrl_inw(INTC_INTER);
-	val |= 1 << (irq - PINT_IRQ_BASE);
-	ctrl_outw(val, INTC_INTER);	/* enable PINTn */
-	portcr_mask |= 3 << (irq - PINT_IRQ_BASE)*2;
-	local_irq_restore(flags);
-}
-
-static void mask_and_ack_pint(unsigned int irq)
-{
-	disable_pint_irq(irq);
-}
-
-static void end_pint_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		enable_pint_irq(irq);
-}
-
-void make_pint_irq(unsigned int irq)
-{
-	disable_irq_nosync(irq);
-	irq_desc[irq].handler = &pint_irq_type;
-	disable_pint_irq(irq);
-}
-#endif
-
-void __init init_IRQ(void)
-{
-#if defined(CONFIG_CPU_SUBTYPE_SH7705) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	int i;
-#endif
-
-	make_ipr_irq(TIMER_IRQ, TIMER_IPR_ADDR, TIMER_IPR_POS, TIMER_PRIORITY);
-	make_ipr_irq(TIMER1_IRQ, TIMER1_IPR_ADDR, TIMER1_IPR_POS, TIMER1_PRIORITY);
-#if defined(CONFIG_SH_RTC)
-	make_ipr_irq(RTC_IRQ, RTC_IPR_ADDR, RTC_IPR_POS, RTC_PRIORITY);
-#endif
-
-#ifdef SCI_ERI_IRQ
-	make_ipr_irq(SCI_ERI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY);
-	make_ipr_irq(SCI_RXI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY);
-	make_ipr_irq(SCI_TXI_IRQ, SCI_IPR_ADDR, SCI_IPR_POS, SCI_PRIORITY);
-#endif
-
-#ifdef SCIF1_ERI_IRQ
-	make_ipr_irq(SCIF1_ERI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY);
-	make_ipr_irq(SCIF1_RXI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY);
-	make_ipr_irq(SCIF1_BRI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY);
-	make_ipr_irq(SCIF1_TXI_IRQ, SCIF1_IPR_ADDR, SCIF1_IPR_POS, SCIF1_PRIORITY);
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7300)
-	make_ipr_irq(SCIF0_IRQ, SCIF0_IPR_ADDR, SCIF0_IPR_POS, SCIF0_PRIORITY);
-	make_ipr_irq(DMTE2_IRQ, DMA1_IPR_ADDR, DMA1_IPR_POS, DMA1_PRIORITY);
-	make_ipr_irq(DMTE3_IRQ, DMA1_IPR_ADDR, DMA1_IPR_POS, DMA1_PRIORITY);
-	make_ipr_irq(VIO_IRQ, VIO_IPR_ADDR, VIO_IPR_POS, VIO_PRIORITY);
-#endif
-
-#ifdef SCIF_ERI_IRQ
-	make_ipr_irq(SCIF_ERI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY);
-	make_ipr_irq(SCIF_RXI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY);
-	make_ipr_irq(SCIF_BRI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY);
-	make_ipr_irq(SCIF_TXI_IRQ, SCIF_IPR_ADDR, SCIF_IPR_POS, SCIF_PRIORITY);
-#endif
-
-#ifdef IRDA_ERI_IRQ
-	make_ipr_irq(IRDA_ERI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY);
-	make_ipr_irq(IRDA_RXI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY);
-	make_ipr_irq(IRDA_BRI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY);
-	make_ipr_irq(IRDA_TXI_IRQ, IRDA_IPR_ADDR, IRDA_IPR_POS, IRDA_PRIORITY);
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
-	/*
-	 * Initialize the Interrupt Controller (INTC)
-	 * registers to their power on values
-	 */
-
-	/*
-	 * Enable external irq (INTC IRQ mode).
-	 * You should set corresponding bits of PFC to "00"
-	 * to enable these interrupts.
-	 */
-	make_ipr_irq(IRQ0_IRQ, IRQ0_IPR_ADDR, IRQ0_IPR_POS, IRQ0_PRIORITY);
-	make_ipr_irq(IRQ1_IRQ, IRQ1_IPR_ADDR, IRQ1_IPR_POS, IRQ1_PRIORITY);
-	make_ipr_irq(IRQ2_IRQ, IRQ2_IPR_ADDR, IRQ2_IPR_POS, IRQ2_PRIORITY);
-	make_ipr_irq(IRQ3_IRQ, IRQ3_IPR_ADDR, IRQ3_IPR_POS, IRQ3_PRIORITY);
-	make_ipr_irq(IRQ4_IRQ, IRQ4_IPR_ADDR, IRQ4_IPR_POS, IRQ4_PRIORITY);
-	make_ipr_irq(IRQ5_IRQ, IRQ5_IPR_ADDR, IRQ5_IPR_POS, IRQ5_PRIORITY);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	make_ipr_irq(PINT0_IRQ, PINT0_IPR_ADDR, PINT0_IPR_POS, PINT0_PRIORITY);
-	make_ipr_irq(PINT8_IRQ, PINT8_IPR_ADDR, PINT8_IPR_POS, PINT8_PRIORITY);
-	enable_ipr_irq(PINT0_IRQ);
-	enable_ipr_irq(PINT8_IRQ);
-
-	for(i = 0; i < 16; i++)
-		make_pint_irq(PINT_IRQ_BASE + i);
-	for(i = 0; i < 256; i++)
-	{
-		if(i & 1) pint_map[i] = 0;
-		else if(i & 2) pint_map[i] = 1;
-		else if(i & 4) pint_map[i] = 2;
-		else if(i & 8) pint_map[i] = 3;
-		else if(i & 0x10) pint_map[i] = 4;
-		else if(i & 0x20) pint_map[i] = 5;
-		else if(i & 0x40) pint_map[i] = 6;
-		else if(i & 0x80) pint_map[i] = 7;
-	}
-#endif /* !CONFIG_CPU_SUBTYPE_SH7300 */
-#endif /* CONFIG_CPU_SUBTYPE_SH7707 || CONFIG_CPU_SUBTYPE_SH7709  || CONFIG_CPU_SUBTYPE_SH7300*/
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40
-	init_IRQ_intc2();
-#endif
-
-	/* Perform the machine specific initialisation */
-	if (sh_mv.mv_init_irq != NULL) {
-		sh_mv.mv_init_irq();
-	}
-}
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7300) || defined(CONFIG_CPU_SUBTYPE_SH7705)
-int ipr_irq_demux(int irq)
-{
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	unsigned long creg, dreg, d, sav;
-
-	if(irq == PINT0_IRQ)
-	{
-#if defined(CONFIG_CPU_SUBTYPE_SH7707)
-		creg = PORT_PACR;
-		dreg = PORT_PADR;
-#else
-		creg = PORT_PCCR;
-		dreg = PORT_PCDR;
-#endif
-		sav = ctrl_inw(creg);
-		ctrl_outw(sav | portcr_mask, creg);
-		d = (~ctrl_inb(dreg) ^ ctrl_inw(INTC_ICR2)) & ctrl_inw(INTC_INTER) & 0xff;
-		ctrl_outw(sav, creg);
-		if(d == 0) return irq;
-		return PINT_IRQ_BASE + pint_map[d];
-	}
-	else if(irq == PINT8_IRQ)
-	{
-#if defined(CONFIG_CPU_SUBTYPE_SH7707)
-		creg = PORT_PBCR;
-		dreg = PORT_PBDR;
-#else
-		creg = PORT_PFCR;
-		dreg = PORT_PFDR;
-#endif
-		sav = ctrl_inw(creg);
-		ctrl_outw(sav | (portcr_mask >> 16), creg);
-		d = (~ctrl_inb(dreg) ^ (ctrl_inw(INTC_ICR2) >> 8)) & (ctrl_inw(INTC_INTER) >> 8) & 0xff;
-		ctrl_outw(sav, creg);
-		if(d == 0) return irq;
-		return PINT_IRQ_BASE + 8 + pint_map[d];
-	}
-#endif
-	return irq;
-}
-#endif
-
-EXPORT_SYMBOL(make_ipr_irq);
-
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/Makefile linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/Makefile	2006-01-17 08:22:44.146456415 +0000
@@ -4,3 +4,10 @@
 
 obj-y	:= ex.o probe.o
 
+clock-$(CONFIG_CPU_SH3)			:= clock-sh3.o
+clock-$(CONFIG_CPU_SUBTYPE_SH7300)	:= clock-sh7300.o
+clock-$(CONFIG_CPU_SUBTYPE_SH7705)	:= clock-sh7705.o
+clock-$(CONFIG_CPU_SUBTYPE_SH7709)	:= clock-sh7709.o
+
+obj-y	+= $(clock-y)
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh3.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh3.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh3.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh3.c	2006-01-17 08:22:44.148456100 +0000
@@ -0,0 +1,89 @@
+/*
+ * arch/sh/kernel/cpu/sh3/clock-sh3.c
+ *
+ * Generic SH-3 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * FRQCR parsing hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
+static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
+
+static void master_clk_init(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
+
+	clk->rate *= pfc_divisors[idx];
+}
+
+static struct clk_ops sh3_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
+
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh3_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x8000) >> 13) | ((frqcr & 0x0030) >> 4);
+
+	clk->rate = clk->parent->rate / stc_multipliers[idx];
+}
+
+static struct clk_ops sh3_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x4000) >> 12) | ((frqcr & 0x000c) >> 2);
+
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh3_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh3_clk_ops[] = {
+	&sh3_master_clk_ops,
+	&sh3_module_clk_ops,
+	&sh3_bus_clk_ops,
+	&sh3_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh3_clk_ops))
+		*ops = sh3_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7300.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7300.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7300.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7300.c	2006-01-17 08:22:44.149455943 +0000
@@ -0,0 +1,78 @@
+/*
+ * arch/sh/kernel/cpu/sh3/clock-sh7300.c
+ *
+ * SH7300 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * FRQCR parsing hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int md_table[] = { 1, 2, 3, 4, 6, 8, 12 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= md_table[ctrl_inw(FRQCR) & 0x0007];
+}
+
+static struct clk_ops sh7300_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0007);
+	clk->rate = clk->parent->rate / md_table[idx];
+}
+
+static struct clk_ops sh7300_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0700) >> 8;
+	clk->rate = clk->parent->rate / md_table[idx];
+}
+
+static struct clk_ops sh7300_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0070) >> 4;
+	clk->rate = clk->parent->rate / md_table[idx];
+}
+
+static struct clk_ops sh7300_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh7300_clk_ops[] = {
+	&sh7300_master_clk_ops,
+	&sh7300_module_clk_ops,
+	&sh7300_bus_clk_ops,
+	&sh7300_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh7300_clk_ops))
+		*ops = sh7300_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7705.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7705.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7705.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7705.c	2006-01-17 08:22:44.151455628 +0000
@@ -0,0 +1,84 @@
+/*
+ * arch/sh/kernel/cpu/sh3/clock-sh7705.c
+ *
+ * SH7705 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * FRQCR parsing hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+/*
+ * SH7705 uses the same divisors as the generic SH-3 case, it's just the
+ * FRQCR layout that is a bit different..
+ */
+static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
+static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= pfc_divisors[ctrl_inw(FRQCR) & 0x0003];
+}
+
+static struct clk_ops sh7705_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = ctrl_inw(FRQCR) & 0x0003;
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh7705_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0300) >> 8;
+	clk->rate = clk->parent->rate / stc_multipliers[idx];
+}
+
+static struct clk_ops sh7705_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0030) >> 4;
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh7705_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh7705_clk_ops[] = {
+	&sh7705_master_clk_ops,
+	&sh7705_module_clk_ops,
+	&sh7705_bus_clk_ops,
+	&sh7705_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh7705_clk_ops))
+		*ops = sh7705_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7709.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7709.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh3/clock-sh7709.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh3/clock-sh7709.c	2006-01-17 08:22:44.152455470 +0000
@@ -0,0 +1,96 @@
+/*
+ * arch/sh/kernel/cpu/sh3/clock-sh7709.c
+ *
+ * SH7709 support for the clock framework
+ *
+ *  Copyright (C) 2005  Andriy Skulysh
+ *
+ * Based on arch/sh/kernel/cpu/sh3/clock-sh7705.c
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int stc_multipliers[] = { 1, 2, 4, 8, 3, 6, 1, 1 };
+static int ifc_divisors[]    = { 1, 2, 4, 1, 3, 1, 1, 1 };
+static int pfc_divisors[]    = { 1, 2, 4, 1, 3, 6, 1, 1 };
+
+static void set_bus_parent(struct clk *clk)
+{
+	struct clk *bus_clk = clk_get("bus_clk");
+	clk->parent = bus_clk;
+	clk_put(bus_clk);
+}
+
+static void master_clk_init(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
+
+	clk->rate *= pfc_divisors[idx];
+}
+
+static struct clk_ops sh7709_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
+
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh7709_module_clk_ops = {
+#ifdef CLOCK_MODE_0_1_2_7
+	.init		= set_bus_parent,
+#endif
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = (frqcr & 0x0080) ?
+		((frqcr & 0x8000) >> 13) | ((frqcr & 0x0030) >> 4) : 1;
+
+	clk->rate = clk->parent->rate * stc_multipliers[idx];
+}
+
+static struct clk_ops sh7709_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int frqcr = ctrl_inw(FRQCR);
+	int idx = ((frqcr & 0x4000) >> 12) | ((frqcr & 0x000c) >> 2);
+
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh7709_cpu_clk_ops = {
+	.init		= set_bus_parent,
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh7709_clk_ops[] = {
+	&sh7709_master_clk_ops,
+	&sh7709_module_clk_ops,
+	&sh7709_bus_clk_ops,
+	&sh7709_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh7709_clk_ops))
+		*ops = sh7709_clk_ops[idx];
+}
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/Makefile linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/Makefile	2006-01-17 08:22:44.153455313 +0000
@@ -5,6 +5,15 @@
 obj-y	:= ex.o probe.o
 
 obj-$(CONFIG_SH_FPU)                    += fpu.o
-obj-$(CONFIG_CPU_SUBTYPE_ST40STB1)	+= irq_intc2.o
 obj-$(CONFIG_SH_STORE_QUEUES)		+= sq.o
 
+# Primary on-chip clocks (common)
+clock-$(CONFIG_CPU_SH4)			:= clock-sh4.o
+clock-$(CONFIG_CPU_SUBTYPE_SH73180)	:= clock-sh73180.o
+clock-$(CONFIG_CPU_SUBTYPE_SH7770)	:= clock-sh7770.o
+clock-$(CONFIG_CPU_SUBTYPE_SH7780)	:= clock-sh7780.o
+
+# Additional clocks by subtype
+clock-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= clock-sh4-202.o
+
+obj-y	+= $(clock-y)
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh4-202.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh4-202.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh4-202.c	2006-01-17 08:22:44.156454841 +0000
@@ -0,0 +1,179 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+ *
+ * Additional SH4-202 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CPG2_FRQCR3	0xfe0a0018
+
+static int frqcr3_divisors[] = { 1, 2, 3, 4, 6, 8, 16 };
+static int frqcr3_values[]   = { 0, 1, 2, 3, 4, 5, 6  };
+
+static void emi_clk_recalc(struct clk *clk)
+{
+	int idx = ctrl_inl(CPG2_FRQCR3) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static inline int frqcr3_lookup(struct clk *clk, unsigned long rate)
+{
+	int divisor = clk->parent->rate / rate;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++)
+		if (frqcr3_divisors[i] == divisor)
+			return frqcr3_values[i];
+
+	/* Safe fallback */
+	return 5;
+}
+
+static struct clk_ops sh4202_emi_clk_ops = {
+	.recalc		= emi_clk_recalc,
+};
+
+static struct clk sh4202_emi_clk = {
+	.name		= "emi_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_emi_clk_ops,
+};
+
+static void femi_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(CPG2_FRQCR3) >> 3) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static struct clk_ops sh4202_femi_clk_ops = {
+	.recalc		= femi_clk_recalc,
+};
+
+static struct clk sh4202_femi_clk = {
+	.name		= "femi_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_femi_clk_ops,
+};
+
+static void shoc_clk_init(struct clk *clk)
+{
+	int i;
+
+	/*
+	 * For some reason, the shoc_clk seems to be set to some really
+	 * insane value at boot (values outside of the allowable frequency
+	 * range for instance). We deal with this by scaling it back down
+	 * to something sensible just in case.
+	 *
+	 * Start scaling from the high end down until we find something
+	 * that passes rate verification..
+	 */
+	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++) {
+		int divisor = frqcr3_divisors[i];
+
+		if (clk->ops->set_rate(clk, clk->parent->rate / divisor) == 0)
+			break;
+	}
+
+	WARN_ON(i == ARRAY_SIZE(frqcr3_divisors));	/* Undefined clock */
+}
+
+static void shoc_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(CPG2_FRQCR3) >> 6) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
+{
+	struct clk *bclk = clk_get("bus_clk");
+	unsigned long bclk_rate = clk_get_rate(bclk);
+
+	clk_put(bclk);
+
+	if (rate > bclk_rate)
+		return 1;
+	if (rate > 66000000)
+		return 1;
+
+	return 0;
+}
+
+static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long frqcr3;
+	unsigned int tmp;
+
+	/* Make sure we have something sensible to switch to */
+	if (shoc_clk_verify_rate(clk, rate) != 0)
+		return -EINVAL;
+
+	tmp = frqcr3_lookup(clk, rate);
+
+	frqcr3 = ctrl_inl(CPG2_FRQCR3);
+	frqcr3 &= ~(0x0007 << 6);
+	frqcr3 |= tmp << 6;
+	ctrl_outl(frqcr3, CPG2_FRQCR3);
+
+	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
+
+	return 0;
+}
+
+static struct clk_ops sh4202_shoc_clk_ops = {
+	.init		= shoc_clk_init,
+	.recalc		= shoc_clk_recalc,
+	.set_rate	= shoc_clk_set_rate,
+};
+
+static struct clk sh4202_shoc_clk = {
+	.name		= "shoc_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_shoc_clk_ops,
+};
+
+static struct clk *sh4202_onchip_clocks[] = {
+	&sh4202_emi_clk,
+	&sh4202_femi_clk,
+	&sh4202_shoc_clk,
+};
+
+static int __init sh4202_clk_init(void)
+{
+	struct clk *clk = clk_get("master_clk");
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {
+		struct clk *clkp = sh4202_onchip_clocks[i];
+
+		clkp->parent = clk;
+		clk_register(clkp);
+		clk_enable(clkp);
+	}
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(clk, clk_get_rate(clk));
+
+	clk_put(clk);
+
+	return 0;
+}
+
+arch_initcall(sh4202_clk_init);
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh4.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh4.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh4.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh4.c	2006-01-17 08:22:44.157454683 +0000
@@ -0,0 +1,80 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh4.c
+ *
+ * Generic SH-4 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * FRQCR parsing hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
+#define bfc_divisors ifc_divisors	/* Same */
+static int pfc_divisors[] = { 2, 3, 4, 6, 8, 2, 2, 2 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= pfc_divisors[ctrl_inw(FRQCR) & 0x0007];
+}
+
+static struct clk_ops sh4_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) & 0x0007);
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh4_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) >> 3) & 0x0007;
+	clk->rate = clk->parent->rate / bfc_divisors[idx];
+}
+
+static struct clk_ops sh4_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inw(FRQCR) >> 6) & 0x0007;
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh4_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh4_clk_ops[] = {
+	&sh4_master_clk_ops,
+	&sh4_module_clk_ops,
+	&sh4_bus_clk_ops,
+	&sh4_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh4_clk_ops))
+		*ops = sh4_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh73180.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh73180.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh73180.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh73180.c	2006-01-17 08:22:44.159454368 +0000
@@ -0,0 +1,81 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh73180.c
+ *
+ * SH73180 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * FRQCR parsing hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+/*
+ * SH73180 uses a common set of divisors, so this is quite simple..
+ */
+static int divisors[] = { 1, 2, 3, 4, 6, 8, 12, 16 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= divisors[ctrl_inl(FRQCR) & 0x0007];
+}
+
+static struct clk_ops sh73180_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(FRQCR) & 0x0007);
+	clk->rate = clk->parent->rate / divisors[idx];
+}
+
+static struct clk_ops sh73180_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(FRQCR) >> 12) & 0x0007;
+	clk->rate = clk->parent->rate / divisors[idx];
+}
+
+static struct clk_ops sh73180_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(FRQCR) >> 20) & 0x0007;
+	clk->rate = clk->parent->rate / divisors[idx];
+}
+
+static struct clk_ops sh73180_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh73180_clk_ops[] = {
+	&sh73180_master_clk_ops,
+	&sh73180_module_clk_ops,
+	&sh73180_bus_clk_ops,
+	&sh73180_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh73180_clk_ops))
+		*ops = sh73180_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh7770.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh7770.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh7770.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh7770.c	2006-01-17 08:22:44.160454211 +0000
@@ -0,0 +1,73 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh7770.c
+ *
+ * SH7770 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int ifc_divisors[] = { 1, 1, 1, 1, 1, 1, 1, 1 };
+static int bfc_divisors[] = { 1, 1, 1, 1, 1, 8,12, 1 };
+static int pfc_divisors[] = { 1, 8, 1,10,12,16, 1, 1 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= pfc_divisors[(ctrl_inl(FRQCR) >> 28) & 0x000f];
+}
+
+static struct clk_ops sh7770_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = ((ctrl_inl(FRQCR) >> 28) & 0x000f);
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh7770_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(FRQCR) & 0x000f);
+	clk->rate = clk->parent->rate / bfc_divisors[idx];
+}
+
+static struct clk_ops sh7770_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = ((ctrl_inl(FRQCR) >> 24) & 0x000f);
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh7770_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh7770_clk_ops[] = {
+	&sh7770_master_clk_ops,
+	&sh7770_module_clk_ops,
+	&sh7770_bus_clk_ops,
+	&sh7770_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh7770_clk_ops))
+		*ops = sh7770_clk_ops[idx];
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh7780.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh7780.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/clock-sh7780.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/clock-sh7780.c	2006-01-17 08:22:44.162453896 +0000
@@ -0,0 +1,126 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh7780.c
+ *
+ * SH7780 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+static int ifc_divisors[] = { 2, 4 };
+static int bfc_divisors[] = { 1, 1, 1, 8, 12, 16, 24, 1 };
+static int pfc_divisors[] = { 1, 24, 24, 1 };
+static int cfc_divisors[] = { 1, 1, 4, 1, 6, 1, 1, 1 };
+
+static void master_clk_init(struct clk *clk)
+{
+	clk->rate *= pfc_divisors[ctrl_inl(FRQCR) & 0x0003];
+}
+
+static struct clk_ops sh7780_master_clk_ops = {
+	.init		= master_clk_init,
+};
+
+static void module_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(FRQCR) & 0x0003);
+	clk->rate = clk->parent->rate / pfc_divisors[idx];
+}
+
+static struct clk_ops sh7780_module_clk_ops = {
+	.recalc		= module_clk_recalc,
+};
+
+static void bus_clk_recalc(struct clk *clk)
+{
+	int idx = ((ctrl_inl(FRQCR) >> 16) & 0x0007);
+	clk->rate = clk->parent->rate / bfc_divisors[idx];
+}
+
+static struct clk_ops sh7780_bus_clk_ops = {
+	.recalc		= bus_clk_recalc,
+};
+
+static void cpu_clk_recalc(struct clk *clk)
+{
+	int idx = ((ctrl_inl(FRQCR) >> 24) & 0x0001);
+	clk->rate = clk->parent->rate / ifc_divisors[idx];
+}
+
+static struct clk_ops sh7780_cpu_clk_ops = {
+	.recalc		= cpu_clk_recalc,
+};
+
+static struct clk_ops *sh7780_clk_ops[] = {
+	&sh7780_master_clk_ops,
+	&sh7780_module_clk_ops,
+	&sh7780_bus_clk_ops,
+	&sh7780_cpu_clk_ops,
+};
+
+void __init arch_init_clk_ops(struct clk_ops **ops, int idx)
+{
+	if (idx < ARRAY_SIZE(sh7780_clk_ops))
+		*ops = sh7780_clk_ops[idx];
+}
+
+static void shyway_clk_recalc(struct clk *clk)
+{
+	int idx = ((ctrl_inl(FRQCR) >> 20) & 0x0007);
+	clk->rate = clk->parent->rate / cfc_divisors[idx];
+}
+
+static struct clk_ops sh7780_shyway_clk_ops = {
+	.recalc		= shyway_clk_recalc,
+};
+
+static struct clk sh7780_shyway_clk = {
+	.name		= "shyway_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh7780_shyway_clk_ops,
+};
+
+/*
+ * Additional SH7780-specific on-chip clocks that aren't already part of the
+ * clock framework
+ */
+static struct clk *sh7780_onchip_clocks[] = {
+	&sh7780_shyway_clk,
+};
+
+static int __init sh7780_clk_init(void)
+{
+	struct clk *clk = clk_get("master_clk");
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sh7780_onchip_clocks); i++) {
+		struct clk *clkp = sh7780_onchip_clocks[i];
+
+		clkp->parent = clk;
+		clk_register(clkp);
+		clk_enable(clkp);
+	}
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(clk, clk_get_rate(clk));
+
+	clk_put(clk);
+
+	return 0;
+}
+
+arch_initcall(sh7780_clk_init);
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/irq_intc2.c linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/irq_intc2.c
--- linux-2.6.15-git12/arch/sh/kernel/cpu/sh4/irq_intc2.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/cpu/sh4/irq_intc2.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,222 +0,0 @@
-/*
- * linux/arch/sh/kernel/irq_intc2.c
- *
- * Copyright (C) 2001 David J. Mckay (david.mckay@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.                            
- *
- * Interrupt handling for INTC2-based IRQ.
- *
- * These are the "new Hitachi style" interrupts, as present on the 
- * Hitachi 7751 and the STM ST40 STB1.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-
-
-struct intc2_data {
-	unsigned char msk_offset;
-	unsigned char msk_shift;
-#ifdef CONFIG_CPU_SUBTYPE_ST40
-	int (*clear_irq) (int);
-#endif
-};
-
-
-static struct intc2_data intc2_data[NR_INTC2_IRQS];
-
-static void enable_intc2_irq(unsigned int irq);
-static void disable_intc2_irq(unsigned int irq);
-
-/* shutdown is same as "disable" */
-#define shutdown_intc2_irq disable_intc2_irq
-
-static void mask_and_ack_intc2(unsigned int);
-static void end_intc2_irq(unsigned int irq);
-
-static unsigned int startup_intc2_irq(unsigned int irq)
-{ 
-	enable_intc2_irq(irq);
-	return 0; /* never anything pending */
-}
-
-static struct hw_interrupt_type intc2_irq_type = {
-	.typename = "INTC2-IRQ",
-	.startup = startup_intc2_irq,
-	.shutdown = shutdown_intc2_irq,
-	.enable = enable_intc2_irq,
-	.disable = disable_intc2_irq,
-	.ack = mask_and_ack_intc2,
-	.end = end_intc2_irq
-};
-
-static void disable_intc2_irq(unsigned int irq)
-{
-	int irq_offset = irq - INTC2_FIRST_IRQ;
-	int msk_shift, msk_offset;
-
-	// Sanity check
-	if((irq_offset<0) || (irq_offset>=NR_INTC2_IRQS))
-		return;
-
-	msk_shift = intc2_data[irq_offset].msk_shift;
-	msk_offset = intc2_data[irq_offset].msk_offset;
-
-	ctrl_outl(1<<msk_shift,
-		  INTC2_BASE+INTC2_INTMSK_OFFSET+msk_offset);
-}
-
-static void enable_intc2_irq(unsigned int irq)
-{
-	int irq_offset = irq - INTC2_FIRST_IRQ;
-	int msk_shift, msk_offset;
-
-	/* Sanity check */
-	if((irq_offset<0) || (irq_offset>=NR_INTC2_IRQS))
-		return;
-
-	msk_shift = intc2_data[irq_offset].msk_shift;
-	msk_offset = intc2_data[irq_offset].msk_offset;
-
-	ctrl_outl(1<<msk_shift,
-		  INTC2_BASE+INTC2_INTMSKCLR_OFFSET+msk_offset);
-}
-
-static void mask_and_ack_intc2(unsigned int irq)
-{
-	disable_intc2_irq(irq);
-}
-
-static void end_intc2_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		enable_intc2_irq(irq);
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40
-	if (intc2_data[irq - INTC2_FIRST_IRQ].clear_irq)
-		intc2_data[irq - INTC2_FIRST_IRQ].clear_irq (irq);
-#endif
-}
-
-/*
- * Setup an INTC2 style interrupt.
- * NOTE: Unlike IPR interrupts, parameters are not shifted by this code,
- * allowing the use of the numbers straight out of the datasheet.
- * For example:
- *    PIO1 which is INTPRI00[19,16] and INTMSK00[13]
- * would be:               ^     ^             ^  ^
- *                         |     |             |  |
- *    make_intc2_irq(84,   0,   16,            0, 13);
- */
-void make_intc2_irq(unsigned int irq,
-		    unsigned int ipr_offset, unsigned int ipr_shift,
-		    unsigned int msk_offset, unsigned int msk_shift,
-		    unsigned int priority)
-{
-	int irq_offset = irq - INTC2_FIRST_IRQ;
-	unsigned int flags;
-	unsigned long ipr;
-
-	if((irq_offset<0) || (irq_offset>=NR_INTC2_IRQS))
-		return;
-
-	disable_irq_nosync(irq);
-
-	/* Fill the data we need */
-	intc2_data[irq_offset].msk_offset = msk_offset;
-	intc2_data[irq_offset].msk_shift  = msk_shift;
-#ifdef CONFIG_CPU_SUBTYPE_ST40
-	intc2_data[irq_offset].clear_irq = NULL;
-#endif
-		
-	/* Set the priority level */
-	local_irq_save(flags);
-
-	ipr=ctrl_inl(INTC2_BASE+INTC2_INTPRI_OFFSET+ipr_offset);
-	ipr&=~(0xf<<ipr_shift);
-	ipr|=(priority)<<ipr_shift;
-	ctrl_outl(ipr, INTC2_BASE+INTC2_INTPRI_OFFSET+ipr_offset);
-
-	local_irq_restore(flags);
-
-	irq_desc[irq].handler=&intc2_irq_type;
-
-	disable_intc2_irq(irq);
-}
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40
-
-struct intc2_init {
-	unsigned short irq;
-	unsigned char ipr_offset, ipr_shift;
-	unsigned char msk_offset, msk_shift;
-};
-
-static struct intc2_init intc2_init_data[]  __initdata = {
-	{64,  0,  0, 0,  0},	/* PCI serr */
-	{65,  0,  4, 0,  1},	/* PCI err */
-	{66,  0,  4, 0,  2},	/* PCI ad */
-	{67,  0,  4, 0,  3},	/* PCI pwd down */
-	{72,  0,  8, 0,  5},	/* DMAC INT0 */
-	{73,  0,  8, 0,  6},	/* DMAC INT1 */
-	{74,  0,  8, 0,  7},	/* DMAC INT2 */
-	{75,  0,  8, 0,  8},	/* DMAC INT3 */
-	{76,  0,  8, 0,  9},	/* DMAC INT4 */
-	{78,  0,  8, 0, 11},	/* DMAC ERR */
-	{80,  0, 12, 0, 12},	/* PIO0 */
-	{84,  0, 16, 0, 13},	/* PIO1 */
-	{88,  0, 20, 0, 14},	/* PIO2 */
-	{112, 4,  0, 4,  0},	/* Mailbox */
-#ifdef CONFIG_CPU_SUBTYPE_ST40GX1
-	{116, 4,  4, 4,  4},	/* SSC0 */
-	{120, 4,  8, 4,  8},	/* IR Blaster */
-	{124, 4, 12, 4, 12},	/* USB host */
-	{128, 4, 16, 4, 16},	/* Video processor BLITTER */
-	{132, 4, 20, 4, 20},	/* UART0 */
-	{134, 4, 20, 4, 22},	/* UART2 */
-	{136, 4, 24, 4, 24},	/* IO_PIO0 */
-	{140, 4, 28, 4, 28},	/* EMPI */
-	{144, 8,  0, 8,  0},	/* MAFE */
-	{148, 8,  4, 8,  4},	/* PWM */
-	{152, 8,  8, 8,  8},	/* SSC1 */
-	{156, 8, 12, 8, 12},	/* IO_PIO1 */
-	{160, 8, 16, 8, 16},	/* USB target */
-	{164, 8, 20, 8, 20},	/* UART1 */
-	{168, 8, 24, 8, 24},	/* Teletext */
-	{172, 8, 28, 8, 28},	/* VideoSync VTG */
-	{173, 8, 28, 8, 29},	/* VideoSync DVP0 */
-	{174, 8, 28, 8, 30},	/* VideoSync DVP1 */
-#endif
-};
-
-void __init init_IRQ_intc2(void)
-{
-	struct intc2_init *p;
-
-	printk(KERN_ALERT "init_IRQ_intc2\n");
-
-	for (p = intc2_init_data;
-	     p<intc2_init_data+ARRAY_SIZE(intc2_init_data);
-	     p++) {
-		make_intc2_irq(p->irq, p->ipr_offset, p->ipr_shift,
-			       p-> msk_offset, p->msk_shift, 13);
-	}
-}
-
-/* Adds a termination callback to the interrupt */
-void intc2_add_clear_irq(int irq, int (*fn)(int))
-{
-	if (irq < INTC2_FIRST_IRQ)
-		return;
-
-	intc2_data[irq - INTC2_FIRST_IRQ].clear_irq = fn;
-}
-
-#endif /* CONFIG_CPU_SUBTYPE_ST40 */
diff -purN linux-2.6.15-git12/arch/sh/kernel/io.c linux-2.6.16-rc1/arch/sh/kernel/io.c
--- linux-2.6.15-git12/arch/sh/kernel/io.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/io.c	2006-01-17 08:22:44.167453109 +0000
@@ -2,58 +2,73 @@
  * linux/arch/sh/kernel/io.c
  *
  * Copyright (C) 2000  Stuart Menefy
+ * Copyright (C) 2005  Paul Mundt
  *
  * Provide real functions which expand to whatever the header file defined.
  * Also definitions of machine independent IO functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
-#include <asm/io.h>
 #include <linux/module.h>
+#include <asm/machvec.h>
+#include <asm/io.h>
 
 /*
  * Copy data from IO memory space to "real" memory space.
  * This needs to be optimized.
  */
-void  memcpy_fromio(void * to, unsigned long from, unsigned long count)
+void memcpy_fromio(void *to, volatile void __iomem *from, unsigned long count)
 {
 	char *p = to;
         while (count) {
                 count--;
-                *p = readb(from);
+                *p = readb((void __iomem *)from);
                 p++;
                 from++;
         }
 }
- 
+EXPORT_SYMBOL(memcpy_fromio);
+
 /*
  * Copy data from "real" memory space to IO memory space.
  * This needs to be optimized.
  */
-void  memcpy_toio(unsigned long to, const void * from, unsigned long count)
+void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
 	const char *p = from;
         while (count) {
                 count--;
-                writeb(*p, to);
+                writeb(*p, (void __iomem *)to);
                 p++;
                 to++;
         }
 }
- 
+EXPORT_SYMBOL(memcpy_toio);
+
 /*
  * "memset" on IO memory space.
  * This needs to be optimized.
  */
-void  memset_io(unsigned long dst, int c, unsigned long count)
+void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 {
         while (count) {
                 count--;
-                writeb(c, dst);
+                writeb(c, (void __iomem *)dst);
                 dst++;
         }
 }
-
-EXPORT_SYMBOL(memcpy_fromio);
-EXPORT_SYMBOL(memcpy_toio);
 EXPORT_SYMBOL(memset_io);
 
+void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	return sh_mv.mv_ioport_map(port, nr);
+}
+EXPORT_SYMBOL(ioport_map);
+
+void ioport_unmap(void __iomem *addr)
+{
+	sh_mv.mv_ioport_unmap(addr);
+}
+EXPORT_SYMBOL(ioport_unmap);
diff -purN linux-2.6.15-git12/arch/sh/kernel/io_generic.c linux-2.6.16-rc1/arch/sh/kernel/io_generic.c
--- linux-2.6.15-git12/arch/sh/kernel/io_generic.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/io_generic.c	2006-01-17 08:22:44.171452479 +0000
@@ -3,6 +3,7 @@
  * linux/arch/sh/kernel/io_generic.c
  *
  * Copyright (C) 2000  Niibe Yutaka
+ * Copyright (C) 2005  Paul Mundt
  *
  * Generic I/O routine. These can be used where a machine specific version
  * is not required.
@@ -10,21 +11,20 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
- *
  */
-
+#include <linux/module.h>
 #include <asm/io.h>
 #include <asm/machvec.h>
-#include <linux/module.h>
 
-#if defined(CONFIG_CPU_SH3)
+#ifdef CONFIG_CPU_SH3
+/* SH3 has a PCMCIA bug that needs a dummy read from area 6 for a
+ * workaround. */
 /* I'm not sure SH7709 has this kind of bug */
-#define SH3_PCMCIA_BUG_WORKAROUND 1
-#define DUMMY_READ_AREA6	  0xba000000
+#define dummy_read()	ctrl_inb(0xba000000)
+#else
+#define dummy_read()
 #endif
 
-#define PORT2ADDR(x) (sh_mv.mv_isa_port2addr(x))
-
 unsigned long generic_io_base;
 
 static inline void delay(void)
@@ -32,40 +32,40 @@ static inline void delay(void)
 	ctrl_inw(0xa0000000);
 }
 
-unsigned char generic_inb(unsigned long port)
+u8 generic_inb(unsigned long port)
 {
-	return *(volatile unsigned char*)PORT2ADDR(port);
+	return ctrl_inb((unsigned long __force)ioport_map(port, 1));
 }
 
-unsigned short generic_inw(unsigned long port)
+u16 generic_inw(unsigned long port)
 {
-	return *(volatile unsigned short*)PORT2ADDR(port);
+	return ctrl_inw((unsigned long __force)ioport_map(port, 2));
 }
 
-unsigned int generic_inl(unsigned long port)
+u32 generic_inl(unsigned long port)
 {
-	return *(volatile unsigned long*)PORT2ADDR(port);
+	return ctrl_inl((unsigned long __force)ioport_map(port, 4));
 }
 
-unsigned char generic_inb_p(unsigned long port)
+u8 generic_inb_p(unsigned long port)
 {
-	unsigned long v = *(volatile unsigned char*)PORT2ADDR(port);
+	unsigned long v = generic_inb(port);
 
 	delay();
 	return v;
 }
 
-unsigned short generic_inw_p(unsigned long port)
+u16 generic_inw_p(unsigned long port)
 {
-	unsigned long v = *(volatile unsigned short*)PORT2ADDR(port);
+	unsigned long v = generic_inw(port);
 
 	delay();
 	return v;
 }
 
-unsigned int generic_inl_p(unsigned long port)
+u32 generic_inl_p(unsigned long port)
 {
-	unsigned long v = *(volatile unsigned long*)PORT2ADDR(port);
+	unsigned long v = generic_inl(port);
 
 	delay();
 	return v;
@@ -77,75 +77,70 @@ unsigned int generic_inl_p(unsigned long
  * convert the port address to real address once.
  */
 
-void generic_insb(unsigned long port, void *buffer, unsigned long count)
+void generic_insb(unsigned long port, void *dst, unsigned long count)
 {
-	volatile unsigned char *port_addr;
-	unsigned char *buf=buffer;
-
-	port_addr = (volatile unsigned char *)PORT2ADDR(port);
+	volatile u8 *port_addr;
+	u8 *buf = dst;
 
-	while(count--)
-	    *buf++ = *port_addr;
+	port_addr = (volatile u8 *)ioport_map(port, 1);
+	while (count--)
+		*buf++ = *port_addr;
 }
 
-void generic_insw(unsigned long port, void *buffer, unsigned long count)
+void generic_insw(unsigned long port, void *dst, unsigned long count)
 {
-	volatile unsigned short *port_addr;
-	unsigned short *buf=buffer;
+	volatile u16 *port_addr;
+	u16 *buf = dst;
 
-	port_addr = (volatile unsigned short *)PORT2ADDR(port);
+	port_addr = (volatile u16 *)ioport_map(port, 2);
+	while (count--)
+		*buf++ = *port_addr;
 
-	while(count--)
-	    *buf++ = *port_addr;
-#ifdef SH3_PCMCIA_BUG_WORKAROUND
-	ctrl_inb (DUMMY_READ_AREA6);
-#endif
+	dummy_read();
 }
 
-void generic_insl(unsigned long port, void *buffer, unsigned long count)
+void generic_insl(unsigned long port, void *dst, unsigned long count)
 {
-	volatile unsigned long *port_addr;
-	unsigned long *buf=buffer;
+	volatile u32 *port_addr;
+	u32 *buf = dst;
 
-	port_addr = (volatile unsigned long *)PORT2ADDR(port);
+	port_addr = (volatile u32 *)ioport_map(port, 4);
+	while (count--)
+		*buf++ = *port_addr;
 
-	while(count--)
-	    *buf++ = *port_addr;
-#ifdef SH3_PCMCIA_BUG_WORKAROUND
-	ctrl_inb (DUMMY_READ_AREA6);
-#endif
+	dummy_read();
 }
 
-void generic_outb(unsigned char b, unsigned long port)
+void generic_outb(u8 b, unsigned long port)
 {
-	*(volatile unsigned char*)PORT2ADDR(port) = b;
+	ctrl_outb(b, (unsigned long __force)ioport_map(port, 1));
 }
 
-void generic_outw(unsigned short b, unsigned long port)
+void generic_outw(u16 b, unsigned long port)
 {
-	*(volatile unsigned short*)PORT2ADDR(port) = b;
+	ctrl_outw(b, (unsigned long __force)ioport_map(port, 2));
 }
 
-void generic_outl(unsigned int b, unsigned long port)
+void generic_outl(u32 b, unsigned long port)
 {
-        *(volatile unsigned long*)PORT2ADDR(port) = b;
+	ctrl_outl(b, (unsigned long __force)ioport_map(port, 4));
 }
 
-void generic_outb_p(unsigned char b, unsigned long port)
+void generic_outb_p(u8 b, unsigned long port)
 {
-	*(volatile unsigned char*)PORT2ADDR(port) = b;
+	generic_outb(b, port);
 	delay();
 }
 
-void generic_outw_p(unsigned short b, unsigned long port)
+void generic_outw_p(u16 b, unsigned long port)
 {
-	*(volatile unsigned short*)PORT2ADDR(port) = b;
+	generic_outw(b, port);
 	delay();
 }
 
-void generic_outl_p(unsigned int b, unsigned long port)
+void generic_outl_p(u32 b, unsigned long port)
 {
-	*(volatile unsigned long*)PORT2ADDR(port) = b;
+	generic_outl(b, port);
 	delay();
 }
 
@@ -154,90 +149,77 @@ void generic_outl_p(unsigned int b, unsi
  * address. However as the port address doesn't change we only need to
  * convert the port address to real address once.
  */
-
-void generic_outsb(unsigned long port, const void *buffer, unsigned long count)
+void generic_outsb(unsigned long port, const void *src, unsigned long count)
 {
-	volatile unsigned char *port_addr;
-	const unsigned char *buf=buffer;
+	volatile u8 *port_addr;
+	const u8 *buf = src;
 
-	port_addr = (volatile unsigned char *)PORT2ADDR(port);
+	port_addr = (volatile u8 __force *)ioport_map(port, 1);
 
-	while(count--)
-	    *port_addr = *buf++;
+	while (count--)
+		*port_addr = *buf++;
 }
 
-void generic_outsw(unsigned long port, const void *buffer, unsigned long count)
+void generic_outsw(unsigned long port, const void *src, unsigned long count)
 {
-	volatile unsigned short *port_addr;
-	const unsigned short *buf=buffer;
+	volatile u16 *port_addr;
+	const u16 *buf = src;
 
-	port_addr = (volatile unsigned short *)PORT2ADDR(port);
+	port_addr = (volatile u16 __force *)ioport_map(port, 2);
 
-	while(count--)
-	    *port_addr = *buf++;
+	while (count--)
+		*port_addr = *buf++;
 
-#ifdef SH3_PCMCIA_BUG_WORKAROUND
-	ctrl_inb (DUMMY_READ_AREA6);
-#endif
+	dummy_read();
 }
 
-void generic_outsl(unsigned long port, const void *buffer, unsigned long count)
+void generic_outsl(unsigned long port, const void *src, unsigned long count)
 {
-	volatile unsigned long *port_addr;
-	const unsigned long *buf=buffer;
+	volatile u32 *port_addr;
+	const u32 *buf = src;
 
-	port_addr = (volatile unsigned long *)PORT2ADDR(port);
+	port_addr = (volatile u32 __force *)ioport_map(port, 4);
+	while (count--)
+		*port_addr = *buf++;
 
-	while(count--)
-	    *port_addr = *buf++;
-
-#ifdef SH3_PCMCIA_BUG_WORKAROUND
-	ctrl_inb (DUMMY_READ_AREA6);
-#endif
-}
-
-unsigned char generic_readb(unsigned long addr)
-{
-	return *(volatile unsigned char*)addr;
+	dummy_read();
 }
 
-unsigned short generic_readw(unsigned long addr)
+u8 generic_readb(void __iomem *addr)
 {
-	return *(volatile unsigned short*)addr;
+	return ctrl_inb((unsigned long __force)addr);
 }
 
-unsigned int generic_readl(unsigned long addr)
+u16 generic_readw(void __iomem *addr)
 {
-	return *(volatile unsigned long*)addr;
+	return ctrl_inw((unsigned long __force)addr);
 }
 
-void generic_writeb(unsigned char b, unsigned long addr)
+u32 generic_readl(void __iomem *addr)
 {
-	*(volatile unsigned char*)addr = b;
+	return ctrl_inl((unsigned long __force)addr);
 }
 
-void generic_writew(unsigned short b, unsigned long addr)
+void generic_writeb(u8 b, void __iomem *addr)
 {
-	*(volatile unsigned short*)addr = b;
+	ctrl_outb(b, (unsigned long __force)addr);
 }
 
-void generic_writel(unsigned int b, unsigned long addr)
+void generic_writew(u16 b, void __iomem *addr)
 {
-        *(volatile unsigned long*)addr = b;
+	ctrl_outw(b, (unsigned long __force)addr);
 }
 
-void * generic_ioremap(unsigned long offset, unsigned long size)
+void generic_writel(u32 b, void __iomem *addr)
 {
-	return (void *) P2SEGADDR(offset);
+	ctrl_outl(b, (unsigned long __force)addr);
 }
-EXPORT_SYMBOL(generic_ioremap);
 
-void generic_iounmap(void *addr)
+void __iomem *generic_ioport_map(unsigned long addr, unsigned int size)
 {
+	return (void __iomem *)(addr + generic_io_base);
 }
-EXPORT_SYMBOL(generic_iounmap);
 
-unsigned long generic_isa_port2addr(unsigned long offset)
+void generic_ioport_unmap(void __iomem *addr)
 {
-	return offset + generic_io_base;
 }
diff -purN linux-2.6.15-git12/arch/sh/kernel/irq.c linux-2.6.16-rc1/arch/sh/kernel/irq.c
--- linux-2.6.15-git12/arch/sh/kernel/irq.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/irq.c	2006-01-17 08:22:44.173452164 +0000
@@ -8,38 +8,13 @@
  * SuperH version:  Copyright (C) 1999  Niibe Yutaka
  */
 
-/*
- * IRQs are in fact implemented a bit like signal handlers for the kernel.
- * Naturally it's not a 1:1 relation, but there are similarities.
- */
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/ptrace.h>
-#include <linux/errno.h>
-#include <linux/kernel_stat.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
+#include <linux/irq.h>
 #include <linux/interrupt.h>
-#include <linux/timex.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/random.h>
-#include <linux/smp.h>
-#include <linux/smp_lock.h>
-#include <linux/init.h>
+#include <linux/kernel_stat.h>
 #include <linux/seq_file.h>
-#include <linux/kallsyms.h>
-#include <linux/bitops.h>
-
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/pgalloc.h>
-#include <asm/delay.h>
 #include <asm/irq.h>
-#include <linux/irq.h>
-
+#include <asm/processor.h>
+#include <asm/cpu/mmu_context.h>
 
 /*
  * 'what should we do if we get a hw irq event on an illegal vector'.
@@ -66,7 +41,7 @@ int show_interrupts(struct seq_file *p, 
 		seq_putc(p, '\n');
 	}
 
-	if (i < ACTUAL_NR_IRQS) {
+	if (i < NR_IRQS) {
 		spin_lock_irqsave(&irq_desc[i].lock, flags);
 		action = irq_desc[i].action;
 		if (!action)
@@ -86,19 +61,32 @@ unlock:
 }
 #endif
 
+
 asmlinkage int do_IRQ(unsigned long r4, unsigned long r5,
 		      unsigned long r6, unsigned long r7,
 		      struct pt_regs regs)
-{	
-	int irq;
+{
+	int irq = r4;
 
 	irq_enter();
-	asm volatile("stc	r2_bank, %0\n\t"
-		     "shlr2	%0\n\t"
-		     "shlr2	%0\n\t"
-		     "shlr	%0\n\t"
-		     "add	#-16, %0\n\t"
-		     :"=z" (irq));
+
+#ifdef CONFIG_CPU_HAS_INTEVT
+	__asm__ __volatile__ (
+#ifdef CONFIG_CPU_HAS_SR_RB
+		"stc	r2_bank, %0\n\t"
+#else
+		"mov.l	@%1, %0\n\t"
+#endif
+		"shlr2	%0\n\t"
+		"shlr2	%0\n\t"
+		"shlr	%0\n\t"
+		"add	#-16, %0\n\t"
+		: "=z" (irq), "=r" (r4)
+		: "1" (INTEVT)
+		: "memory"
+	);
+#endif
+
 	irq = irq_demux(irq);
 	__do_IRQ(irq, &regs);
 	irq_exit();
diff -purN linux-2.6.15-git12/arch/sh/kernel/machine_kexec.c linux-2.6.16-rc1/arch/sh/kernel/machine_kexec.c
--- linux-2.6.15-git12/arch/sh/kernel/machine_kexec.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/machine_kexec.c	2006-01-17 08:22:44.175451849 +0000
@@ -0,0 +1,112 @@
+/*
+ * machine_kexec.c - handle transition of Linux booting another kernel
+ * Copyright (C) 2002-2003 Eric Biederman  <ebiederm@xmission.com>
+ *
+ * GameCube/ppc32 port Copyright (C) 2004 Albert Herranz
+ * LANDISK/sh4 supported by kogiidena
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <linux/mm.h>
+#include <linux/kexec.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/mmu_context.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+
+typedef NORET_TYPE void (*relocate_new_kernel_t)(
+				unsigned long indirection_page,
+				unsigned long reboot_code_buffer,
+				unsigned long start_address,
+				unsigned long vbr_reg) ATTRIB_NORET;
+
+const extern unsigned char relocate_new_kernel[];
+const extern unsigned int relocate_new_kernel_size;
+extern void *gdb_vbr_vector;
+
+/*
+ * Provide a dummy crash_notes definition while crash dump arrives to ppc.
+ * This prevents breakage of crash_notes attribute in kernel/ksysfs.c.
+ */
+void *crash_notes = NULL;
+
+void machine_shutdown(void)
+{
+}
+
+void machine_crash_shutdown(struct pt_regs *regs)
+{
+}
+
+/*
+ * Do what every setup is needed on image and the
+ * reboot code buffer to allow us to avoid allocations
+ * later.
+ */
+int machine_kexec_prepare(struct kimage *image)
+{
+	return 0;
+}
+
+void machine_kexec_cleanup(struct kimage *image)
+{
+}
+
+static void kexec_info(struct kimage *image)
+{
+        int i;
+	printk("kexec information\n");
+	for (i = 0; i < image->nr_segments; i++) {
+	        printk("  segment[%d]: 0x%08x - 0x%08x (0x%08x)\n",
+		       i,
+		       (unsigned int)image->segment[i].mem,
+		       (unsigned int)image->segment[i].mem + image->segment[i].memsz,
+		       (unsigned int)image->segment[i].memsz);
+ 	}
+	printk("  start     : 0x%08x\n\n", (unsigned int)image->start);
+}
+
+
+/*
+ * Do not allocate memory (or fail in any way) in machine_kexec().
+ * We are past the point of no return, committed to rebooting now.
+ */
+NORET_TYPE void machine_kexec(struct kimage *image)
+{
+
+	unsigned long page_list;
+	unsigned long reboot_code_buffer;
+	unsigned long vbr_reg;
+	relocate_new_kernel_t rnk;
+
+#if defined(CONFIG_SH_STANDARD_BIOS)
+	vbr_reg = ((unsigned long )gdb_vbr_vector) - 0x100;
+#else
+	vbr_reg = 0x80000000;  // dummy
+#endif
+	/* Interrupts aren't acceptable while we reboot */
+	local_irq_disable();
+
+	page_list = image->head;
+
+	/* we need both effective and real address here */
+	reboot_code_buffer =
+			(unsigned long)page_address(image->control_code_page);
+
+	/* copy our kernel relocation code to the control code page */
+	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
+						relocate_new_kernel_size);
+
+        kexec_info(image);
+	flush_cache_all();
+
+	/* now call it */
+	rnk = (relocate_new_kernel_t) reboot_code_buffer;
+       	(*rnk)(page_list, reboot_code_buffer, image->start, vbr_reg);
+}
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/process.c linux-2.6.16-rc1/arch/sh/kernel/process.c
--- linux-2.6.15-git12/arch/sh/kernel/process.c	2006-01-17 08:21:30.117791334 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/process.c	2006-01-17 08:22:44.178451377 +0000
@@ -71,6 +71,16 @@ void cpu_idle(void)
 
 void machine_restart(char * __unused)
 {
+
+#ifdef CONFIG_KEXEC
+	struct kimage *image;
+	image = xchg(&kexec_image, 0);
+	if (image) {
+		machine_shutdown();
+		machine_kexec(image);
+	}
+#endif
+
 	/* SR.BL=1 and invoke address error to let CPU reset (manual reset) */
 	asm volatile("ldc %0, sr\n\t"
 		     "mov.l @%1, %0" : : "r" (0x10000000), "r" (0x80000001));
diff -purN linux-2.6.15-git12/arch/sh/kernel/relocate_kernel.S linux-2.6.16-rc1/arch/sh/kernel/relocate_kernel.S
--- linux-2.6.15-git12/arch/sh/kernel/relocate_kernel.S	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/relocate_kernel.S	2006-01-17 08:22:44.181450905 +0000
@@ -0,0 +1,102 @@
+/*
+ * relocate_kernel.S - put the kernel image in place to boot
+ * 2005.9.17 kogiidena@eggplant.ddo.jp
+ *
+ * LANDISK/sh4 is supported. Maybe, SH archtecture works well.
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+
+#define PAGE_SIZE      4096 /* must be same value as in <asm/page.h> */
+
+
+		.globl relocate_new_kernel
+relocate_new_kernel:
+	/* r4 = indirection_page   */
+	/* r5 = reboot_code_buffer */
+	/* r6 = start_address      */
+	/* r7 = vbr_reg            */
+
+	mov.l	10f,r8	  /* 4096 */
+	mov.l	11f,r9    /* 0xa0000000 */
+
+	/*  stack setting */
+	add	r8,r5
+	mov	r5,r15
+
+	bra	1f
+	mov	r4,r0	  /* cmd = indirection_page */
+0:
+	mov.l	@r4+,r0	  /* cmd = *ind++ */
+
+1:	/* addr = (cmd | 0xa0000000) & 0xfffffff0 */
+	mov	r0,r2
+	or	r9,r2
+	mov	#-16,r1
+	and	r1,r2
+
+	/* if(cmd & IND_DESTINATION) dst = addr  */
+	tst	#1,r0
+	bt	2f
+	bra	0b
+	mov	r2,r5
+
+2:	/* else if(cmd & IND_INDIRECTION) ind = addr  */
+	tst	#2,r0
+	bt	3f
+	bra	0b
+	mov	r2,r4
+
+3:	/* else if(cmd & IND_DONE) goto 6  */
+	tst	#4,r0
+	bt	4f
+	bra	6f
+	nop
+
+4:	/* else if(cmd & IND_SOURCE) memcpy(dst,addr,PAGE_SIZE) */
+	tst	#8,r0
+	bt	0b
+
+	mov	r8,r3
+	shlr2	r3
+	shlr2	r3
+5:
+	dt	r3
+	mov.l	@r2+,r1   /*  16n+0 */
+	mov.l	r1,@r5
+	add	#4,r5
+	mov.l	@r2+,r1	  /*  16n+4 */
+	mov.l	r1,@r5
+	add	#4,r5
+	mov.l	@r2+,r1   /*  16n+8 */
+	mov.l	r1,@r5
+	add	#4,r5
+	mov.l	@r2+,r1   /*  16n+12 */
+	mov.l	r1,@r5
+	add	#4,r5
+	bf	5b
+
+	bra	0b
+	nop
+6:
+#ifdef CONFIG_SH_STANDARD_BIOS
+	ldc   r7, vbr
+#endif
+	jmp @r6
+	nop
+
+	.align 2
+10:
+	.long	PAGE_SIZE
+11:
+	.long	0xa0000000
+
+relocate_new_kernel_end:
+
+	.globl relocate_new_kernel_size
+relocate_new_kernel_size:
+	.long relocate_new_kernel_end - relocate_new_kernel
diff -purN linux-2.6.15-git12/arch/sh/kernel/time.c linux-2.6.16-rc1/arch/sh/kernel/time.c
--- linux-2.6.15-git12/arch/sh/kernel/time.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/time.c	2006-01-17 08:22:44.190449488 +0000
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002, 2003, 2004, 2005  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
  *
  *  Some code taken from i386 version.
@@ -11,50 +11,21 @@
  */
 
 #include <linux/config.h>
-#include <linux/errno.h>
-#include <linux/module.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/smp.h>
 #include <linux/profile.h>
-
-#include <asm/processor.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/delay.h>
-#include <asm/machvec.h>
+#include <asm/clock.h>
 #include <asm/rtc.h>
-#include <asm/freq.h>
-#include <asm/cpu/timer.h>
-#ifdef CONFIG_SH_KGDB
+#include <asm/timer.h>
 #include <asm/kgdb.h>
-#endif
-
-#include <linux/timex.h>
-#include <linux/irq.h>
-
-#define TMU_TOCR_INIT	0x00
-#define TMU0_TCR_INIT	0x0020
-#define TMU_TSTR_INIT	1
-
-#define TMU0_TCR_CALIB	0x0000
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-#define CLOCKGEN_MEMCLKCR 0xbb040038
-#define MEMCLKCR_RATIO_MASK 0x7
-#endif /* CONFIG_CPU_SUBTYPE_ST40STB1 */
 
 extern unsigned long wall_jiffies;
-#define TICK_SIZE (tick_nsec / 1000)
-DEFINE_SPINLOCK(tmu0_lock);
+struct sys_timer *sys_timer;
+
+/* Move this somewhere more sensible.. */
+DEFINE_SPINLOCK(rtc_lock);
+EXPORT_SYMBOL(rtc_lock);
 
 /* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
  * these routines anywhere... */
@@ -66,98 +37,14 @@ void (*rtc_get_time)(struct timespec *);
 int (*rtc_set_time)(const time_t);
 #endif
 
-#if defined(CONFIG_CPU_SUBTYPE_SH7300)
-static int md_table[] = { 1, 2, 3, 4, 6, 8, 12 };
-#endif
-#if defined(CONFIG_CPU_SH3)
-static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int stc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
-#define bfc_divisors stc_multipliers
-#define bfc_values stc_values
-static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
-static int ifc_values[]      = { 0, 1, 4, 2, 0, 0, 0, 0 };
-static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int pfc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
-#elif defined(CONFIG_CPU_SH4)
-#if defined(CONFIG_CPU_SUBTYPE_SH73180)
-static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 12, 16 };
-static int ifc_values[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
-#define bfc_divisors ifc_divisors	/* Same */
-#define bfc_values ifc_values
-#define pfc_divisors ifc_divisors	/* Same */
-#define pfc_values ifc_values
-#else
-static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
-static int ifc_values[]   = { 0, 1, 2, 3, 0, 4, 0, 5 };
-#define bfc_divisors ifc_divisors	/* Same */
-#define bfc_values ifc_values
-static int pfc_divisors[] = { 2, 3, 4, 6, 8, 2, 2, 2 };
-static int pfc_values[]   = { 0, 0, 1, 2, 0, 3, 0, 4 };
-#endif
-#else
-#error "Unknown ifc/bfc/pfc/stc values for this processor"
-#endif
-
 /*
  * Scheduler clock - returns current time in nanosec units.
  */
-unsigned long long sched_clock(void)
+unsigned long long __attribute__ ((weak)) sched_clock(void)
 {
 	return (unsigned long long)jiffies * (1000000000 / HZ);
 }
 
-static unsigned long do_gettimeoffset(void)
-{
-	int count;
-	unsigned long flags;
-
-	static int count_p = 0x7fffffff;    /* for the first call after boot */
-	static unsigned long jiffies_p = 0;
-
-	/*
-	 * cache volatile jiffies temporarily; we have IRQs turned off.
-	 */
-	unsigned long jiffies_t;
-
-	spin_lock_irqsave(&tmu0_lock, flags);
-	/* timer count may underflow right here */
-	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
-
-	jiffies_t = jiffies;
-
-	/*
-	 * avoiding timer inconsistencies (they are rare, but they happen)...
-	 * there is one kind of problem that must be avoided here:
-	 *  1. the timer counter underflows
-	 */
-
-	if( jiffies_t == jiffies_p ) {
-		if( count > count_p ) {
-			/* the nutcase */
-
-			if(ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
-				/*
-				 * We cannot detect lost timer interrupts ...
-				 * well, that's why we call them lost, don't we? :)
-				 * [hmm, on the Pentium and Alpha we can ... sort of]
-				 */
-				count -= LATCH;
-			} else {
-				printk("do_slow_gettimeoffset(): hardware timer problem?\n");
-			}
-		}
-	} else
-		jiffies_p = jiffies_t;
-
-	count_p = count;
-	spin_unlock_irqrestore(&tmu0_lock, flags);
-
-	count = ((LATCH-1) - count) * TICK_SIZE;
-	count = (count + LATCH/2) / LATCH;
-
-	return count;
-}
-
 void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long seq;
@@ -166,7 +53,7 @@ void do_gettimeofday(struct timeval *tv)
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
-		usec = do_gettimeoffset();
+		usec = get_timer_offset();
 
 		lost = jiffies - wall_jiffies;
 		if (lost)
@@ -202,7 +89,7 @@ int do_settimeofday(struct timespec *tv)
 	 * wall time.  Discover what correction gettimeofday() would have
 	 * made, and then undo it!
 	 */
-	nsec -= 1000 * (do_gettimeoffset() +
+	nsec -= 1000 * (get_timer_offset() +
 				(jiffies - wall_jiffies) * (1000000 / HZ));
 
 	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
@@ -224,10 +111,10 @@ EXPORT_SYMBOL(do_settimeofday);
 static long last_rtc_update;
 
 /*
- * timer_interrupt() needs to keep up the real-time clock,
+ * handle_timer_tick() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-static inline void do_timer_interrupt(int irq, struct pt_regs *regs)
+void handle_timer_tick(struct pt_regs *regs)
 {
 	do_timer(regs);
 #ifndef CONFIG_SMP
@@ -252,337 +139,35 @@ static inline void do_timer_interrupt(in
 		if (rtc_set_time(xtime.tv_sec) == 0)
 			last_rtc_update = xtime.tv_sec;
 		else
-			last_rtc_update = xtime.tv_sec - 600; /* do it again in 60 s */
+			/* do it again in 60s */
+			last_rtc_update = xtime.tv_sec - 600;
 	}
 }
 
-/*
- * This is the same as the above, except we _also_ save the current
- * Time Stamp Counter value at the time of the timer interrupt, so that
- * we later on can estimate the time of day more exactly.
- */
-static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	unsigned long timer_status;
-
-	/* Clear UNF bit */
-	timer_status = ctrl_inw(TMU0_TCR);
-	timer_status &= ~0x100;
-	ctrl_outw(timer_status, TMU0_TCR);
-
-	/*
-	 * Here we are in the timer irq handler. We just have irqs locally
-	 * disabled but we don't know if the timer_bh is running on the other
-	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
-	 * the irq version of write_lock because as just said we have irq
-	 * locally disabled. -arca
-	 */
-	write_seqlock(&xtime_lock);
-	do_timer_interrupt(irq, regs);
-	write_sequnlock(&xtime_lock);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Hah!  We'll see if this works (switching from usecs to nsecs).
- */
-static unsigned int __init get_timer_frequency(void)
-{
-	u32 freq;
-	struct timespec ts1, ts2;
-	unsigned long diff_nsec;
-	unsigned long factor;
-
-	/* Setup the timer:  We don't want to generate interrupts, just
-	 * have it count down at its natural rate.
-	 */
-	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
-#endif
-	ctrl_outw(TMU0_TCR_CALIB, TMU0_TCR);
-	ctrl_outl(0xffffffff, TMU0_TCOR);
-	ctrl_outl(0xffffffff, TMU0_TCNT);
-
-	rtc_get_time(&ts2);
-
-	do {
-		rtc_get_time(&ts1);
-	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
-
-	/* actually start the timer */
-	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
-
-	do {
-		rtc_get_time(&ts2);
-	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
-
-	freq = 0xffffffff - ctrl_inl(TMU0_TCNT);
-	if (ts2.tv_nsec < ts1.tv_nsec) {
-		ts2.tv_nsec += 1000000000;
-		ts2.tv_sec--;
-	}
-
-	diff_nsec = (ts2.tv_sec - ts1.tv_sec) * 1000000000 + (ts2.tv_nsec - ts1.tv_nsec);
-
-	/* this should work well if the RTC has a precision of n Hz, where
-	 * n is an integer.  I don't think we have to worry about the other
-	 * cases. */
-	factor = (1000000000 + diff_nsec/2) / diff_nsec;
-
-	if (factor * diff_nsec > 1100000000 ||
-	    factor * diff_nsec <  900000000)
-		panic("weird RTC (diff_nsec %ld)", diff_nsec);
-
-	return freq * factor;
-}
-
-void (*board_time_init)(void);
-void (*board_timer_setup)(struct irqaction *irq);
-
-static unsigned int sh_pclk_freq __initdata = CONFIG_SH_PCLK_FREQ;
-
-static int __init sh_pclk_setup(char *str)
-{
-        unsigned int freq;
-
-	if (get_option(&str, &freq))
-		sh_pclk_freq = freq;
-
-	return 1;
-}
-__setup("sh_pclk=", sh_pclk_setup);
-
-static struct irqaction irq0  = { timer_interrupt, SA_INTERRUPT, CPU_MASK_NONE, "timer", NULL, NULL};
-
-void get_current_frequency_divisors(unsigned int *ifc, unsigned int *bfc, unsigned int *pfc)
-{
-	unsigned int frqcr = ctrl_inw(FRQCR);
-
-#if defined(CONFIG_CPU_SH3)
-#if defined(CONFIG_CPU_SUBTYPE_SH7300)
-	*ifc = md_table[((frqcr & 0x0070) >> 4)];
-	*bfc = md_table[((frqcr & 0x0700) >> 8)];
-	*pfc = md_table[frqcr & 0x0007];
-#elif defined(CONFIG_CPU_SUBTYPE_SH7705)
-	*bfc = stc_multipliers[(frqcr & 0x0300) >> 8];
-	*ifc = ifc_divisors[(frqcr & 0x0030) >> 4];
-	*pfc = pfc_divisors[frqcr & 0x0003];
-#else
-	unsigned int tmp;
-
-	tmp  = (frqcr & 0x8000) >> 13;
-	tmp |= (frqcr & 0x0030) >>  4;
-	*bfc = stc_multipliers[tmp];
-	tmp  = (frqcr & 0x4000)  >> 12;
-	tmp |= (frqcr & 0x000c) >> 2;
-	*ifc = ifc_divisors[tmp];
-	tmp  = (frqcr & 0x2000) >> 11;
-	tmp |= frqcr & 0x0003;
-	*pfc = pfc_divisors[tmp];
-#endif
-#elif defined(CONFIG_CPU_SH4)
-#if defined(CONFIG_CPU_SUBTYPE_SH73180)
-	*ifc = ifc_divisors[(frqcr>> 20) & 0x0007];
-	*bfc = bfc_divisors[(frqcr>> 12) & 0x0007];
-	*pfc = pfc_divisors[frqcr & 0x0007];
-#else
-	*ifc = ifc_divisors[(frqcr >> 6) & 0x0007];
-	*bfc = bfc_divisors[(frqcr >> 3) & 0x0007];
-	*pfc = pfc_divisors[frqcr & 0x0007];
-#endif
-#endif
-}
-
-/*
- * This bit of ugliness builds up accessor routines to get at both
- * the divisors and the physical values.
- */
-#define _FREQ_TABLE(x) \
-	unsigned int get_##x##_divisor(unsigned int value)	\
-		{ return x##_divisors[value]; }			\
-								\
-	unsigned int get_##x##_value(unsigned int divisor)	\
-		{ return x##_values[(divisor - 1)]; }
-
-_FREQ_TABLE(ifc);
-_FREQ_TABLE(bfc);
-_FREQ_TABLE(pfc);
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-
-/*
- * The ST40 divisors are totally different so we set the cpu data
- * clocks using a different algorithm
- *
- * I've just plugged this from the 2.4 code
- *	- Alex Bennee <kernel-hacker@bennee.com>
- */
-#define CCN_PVR_CHIP_SHIFT 24
-#define CCN_PVR_CHIP_MASK  0xff
-#define CCN_PVR_CHIP_ST40STB1 0x4
-
-
-struct frqcr_data {
-	unsigned short frqcr;
-
-	struct {
-		unsigned char multiplier;
-		unsigned char divisor;
-	} factor[3];
+static struct sysdev_class timer_sysclass = {
+	set_kset_name("timer"),
 };
 
-static struct frqcr_data st40_frqcr_table[] = {
-	{ 0x000, {{1,1}, {1,1}, {1,2}}},
-	{ 0x002, {{1,1}, {1,1}, {1,4}}},
-	{ 0x004, {{1,1}, {1,1}, {1,8}}},
-	{ 0x008, {{1,1}, {1,2}, {1,2}}},
-	{ 0x00A, {{1,1}, {1,2}, {1,4}}},
-	{ 0x00C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x011, {{1,1}, {2,3}, {1,6}}},
-	{ 0x013, {{1,1}, {2,3}, {1,3}}},
-	{ 0x01A, {{1,1}, {1,2}, {1,4}}},
-	{ 0x01C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x023, {{1,1}, {2,3}, {1,3}}},
-	{ 0x02C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x048, {{1,2}, {1,2}, {1,4}}},
-	{ 0x04A, {{1,2}, {1,2}, {1,6}}},
-	{ 0x04C, {{1,2}, {1,2}, {1,8}}},
-	{ 0x05A, {{1,2}, {1,3}, {1,6}}},
-	{ 0x05C, {{1,2}, {1,3}, {1,6}}},
-	{ 0x063, {{1,2}, {1,4}, {1,4}}},
-	{ 0x06C, {{1,2}, {1,4}, {1,8}}},
-	{ 0x091, {{1,3}, {1,3}, {1,6}}},
-	{ 0x093, {{1,3}, {1,3}, {1,6}}},
-	{ 0x0A3, {{1,3}, {1,6}, {1,6}}},
-	{ 0x0DA, {{1,4}, {1,4}, {1,8}}},
-	{ 0x0DC, {{1,4}, {1,4}, {1,8}}},
-	{ 0x0EC, {{1,4}, {1,8}, {1,8}}},
-	{ 0x123, {{1,4}, {1,4}, {1,8}}},
-	{ 0x16C, {{1,4}, {1,8}, {1,8}}},
-};
-
-struct memclk_data {
-	unsigned char multiplier;
-	unsigned char divisor;
-};
-
-static struct memclk_data st40_memclk_table[8] = {
-	{1,1},	// 000
-	{1,2},	// 001
-	{1,3},	// 010
-	{2,3},	// 011
-	{1,4},	// 100
-	{1,6},	// 101
-	{1,8},	// 110
-	{1,8}	// 111
-};
-
-static void st40_specific_time_init(unsigned int module_clock, unsigned short frqcr)
+static int __init timer_init_sysfs(void)
 {
-	unsigned int cpu_clock, master_clock, bus_clock, memory_clock;
-	struct frqcr_data *d;
-	int a;
-	unsigned long memclkcr;
-	struct memclk_data *e;
-
-	for (a = 0; a < ARRAY_SIZE(st40_frqcr_table); a++) {
-		d = &st40_frqcr_table[a];
-
-		if (d->frqcr == (frqcr & 0x1ff))
-			break;
-	}
-
-	if (a == ARRAY_SIZE(st40_frqcr_table)) {
-		d = st40_frqcr_table;
+	int ret = sysdev_class_register(&timer_sysclass);
+	if (ret != 0)
+		return ret;
 
-		printk("ERROR: Unrecognised FRQCR value (0x%x), "
-		       "using default multipliers\n", frqcr);
-	}
+	sys_timer->dev.cls = &timer_sysclass;
+	return sysdev_register(&sys_timer->dev);
+}
 
-	memclkcr = ctrl_inl(CLOCKGEN_MEMCLKCR);
-	e = &st40_memclk_table[memclkcr & MEMCLKCR_RATIO_MASK];
+device_initcall(timer_init_sysfs);
 
-	printk(KERN_INFO "Clock multipliers: CPU: %d/%d Bus: %d/%d "
-	       "Mem: %d/%d Periph: %d/%d\n",
-	       d->factor[0].multiplier, d->factor[0].divisor,
-	       d->factor[1].multiplier, d->factor[1].divisor,
-	       e->multiplier,           e->divisor,
-	       d->factor[2].multiplier, d->factor[2].divisor);
-
-	master_clock = module_clock * d->factor[2].divisor
-				    / d->factor[2].multiplier;
-	bus_clock    = master_clock * d->factor[1].multiplier
-				    / d->factor[1].divisor;
-	memory_clock = master_clock * e->multiplier
-				    / e->divisor;
-	cpu_clock    = master_clock * d->factor[0].multiplier
-				    / d->factor[0].divisor;
-
-	current_cpu_data.cpu_clock    = cpu_clock;
-	current_cpu_data.master_clock = master_clock;
-	current_cpu_data.bus_clock    = bus_clock;
-	current_cpu_data.memory_clock = memory_clock;
-	current_cpu_data.module_clock = module_clock;
-}
-#endif
+void (*board_time_init)(void);
 
 void __init time_init(void)
 {
-	unsigned int timer_freq = 0;
-	unsigned int ifc, pfc, bfc;
-	unsigned long interval;
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	unsigned long pvr;
-	unsigned short frqcr;
-#endif
-
 	if (board_time_init)
 		board_time_init();
 
-	/*
-	 * If we don't have an RTC (such as with the SH7300), don't attempt to
-	 * probe the timer frequency. Rely on an either hardcoded peripheral
-	 * clock value, or on the sh_pclk command line option. Note that we
-	 * still need to have CONFIG_SH_PCLK_FREQ set in order for things like
-	 * CLOCK_TICK_RATE to be sane.
-	 */
-	current_cpu_data.module_clock = sh_pclk_freq;
-
-#ifdef CONFIG_SH_PCLK_CALC
-	/* XXX: Switch this over to a more generic test. */
-	{
-		unsigned int freq;
-
-		/*
-		 * If we've specified a peripheral clock frequency, and we have
-		 * an RTC, compare it against the autodetected value. Complain
-		 * if there's a mismatch.
-		 */
-		timer_freq = get_timer_frequency();
-		freq = timer_freq * 4;
-
-		if (sh_pclk_freq && (sh_pclk_freq/100*99 > freq || sh_pclk_freq/100*101 < freq)) {
-			printk(KERN_NOTICE "Calculated peripheral clock value "
-			       "%d differs from sh_pclk value %d, fixing..\n",
-			       freq, sh_pclk_freq);
-			current_cpu_data.module_clock = freq;
-		}
-	}
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	/* XXX: Update ST40 code to use board_time_init() */
-	pvr = ctrl_inl(CCN_PVR);
-	frqcr = ctrl_inw(FRQCR);
-	printk("time.c ST40 Probe: PVR %08lx, FRQCR %04hx\n", pvr, frqcr);
-
-	if (((pvr >> CCN_PVR_CHIP_SHIFT) & CCN_PVR_CHIP_MASK) == CCN_PVR_CHIP_ST40STB1)
-		st40_specific_time_init(current_cpu_data.module_clock, frqcr);
-	else
-#endif
-		get_current_frequency_divisors(&ifc, &bfc, &pfc);
+	clk_init();
 
 	if (rtc_get_time) {
 		rtc_get_time(&xtime);
@@ -594,51 +179,12 @@ void __init time_init(void)
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
 
-	if (board_timer_setup) {
-		board_timer_setup(&irq0);
-	} else {
-		setup_irq(TIMER_IRQ, &irq0);
-	}
-
 	/*
-	 * for ST40 chips the current_cpu_data should already be set
-	 * so not having valid pfc/bfc/ifc shouldn't be a problem
+	 * Find the timer to use as the system timer, it will be
+	 * initialized for us.
 	 */
-	if (!current_cpu_data.master_clock)
-		current_cpu_data.master_clock = current_cpu_data.module_clock * pfc;
-	if (!current_cpu_data.bus_clock)
-		current_cpu_data.bus_clock = current_cpu_data.master_clock / bfc;
-	if (!current_cpu_data.cpu_clock)
-		current_cpu_data.cpu_clock = current_cpu_data.master_clock / ifc;
-
-	printk("CPU clock: %d.%02dMHz\n",
-	       (current_cpu_data.cpu_clock / 1000000),
-	       (current_cpu_data.cpu_clock % 1000000)/10000);
-	printk("Bus clock: %d.%02dMHz\n",
-	       (current_cpu_data.bus_clock / 1000000),
-	       (current_cpu_data.bus_clock % 1000000)/10000);
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	printk("Memory clock: %d.%02dMHz\n",
-	       (current_cpu_data.memory_clock / 1000000),
-	       (current_cpu_data.memory_clock % 1000000)/10000);
-#endif
-	printk("Module clock: %d.%02dMHz\n",
-	       (current_cpu_data.module_clock / 1000000),
-	       (current_cpu_data.module_clock % 1000000)/10000);
-
-	interval = (current_cpu_data.module_clock/4 + HZ/2) / HZ;
-
-	printk("Interval = %ld\n", interval);
-
-	/* Start TMU0 */
-	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
-#endif
-	ctrl_outw(TMU0_TCR_INIT, TMU0_TCR);
-	ctrl_outl(interval, TMU0_TCOR);
-	ctrl_outl(interval, TMU0_TCNT);
-	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+	sys_timer = get_sys_timer();
+	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
 
 #if defined(CONFIG_SH_KGDB)
 	/*
diff -purN linux-2.6.15-git12/arch/sh/kernel/timers/Makefile linux-2.6.16-rc1/arch/sh/kernel/timers/Makefile
--- linux-2.6.15-git12/arch/sh/kernel/timers/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/timers/Makefile	2006-01-17 08:22:44.191449331 +0000
@@ -0,0 +1,8 @@
+#
+# Makefile for the various Linux/SuperH timers
+#
+
+obj-y	:= timer.o
+
+obj-$(CONFIG_SH_TMU)		+= timer-tmu.o
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/timers/timer-tmu.c linux-2.6.16-rc1/arch/sh/kernel/timers/timer-tmu.c
--- linux-2.6.15-git12/arch/sh/kernel/timers/timer-tmu.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/timers/timer-tmu.c	2006-01-17 08:22:44.194448858 +0000
@@ -0,0 +1,229 @@
+/*
+ * arch/sh/kernel/timers/timer-tmu.c - TMU Timer Support
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * TMU handling code hacked out of arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/seqlock.h>
+#include <asm/timer.h>
+#include <asm/rtc.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/clock.h>
+
+#define TMU_TOCR_INIT	0x00
+#define TMU0_TCR_INIT	0x0020
+#define TMU_TSTR_INIT	1
+
+#define TMU0_TCR_CALIB	0x0000
+
+static DEFINE_SPINLOCK(tmu0_lock);
+
+static unsigned long tmu_timer_get_offset(void)
+{
+	int count;
+	unsigned long flags;
+
+	static int count_p = 0x7fffffff;    /* for the first call after boot */
+	static unsigned long jiffies_p = 0;
+
+	/*
+	 * cache volatile jiffies temporarily; we have IRQs turned off.
+	 */
+	unsigned long jiffies_t;
+
+	spin_lock_irqsave(&tmu0_lock, flags);
+	/* timer count may underflow right here */
+	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
+
+	jiffies_t = jiffies;
+
+	/*
+	 * avoiding timer inconsistencies (they are rare, but they happen)...
+	 * there is one kind of problem that must be avoided here:
+	 *  1. the timer counter underflows
+	 */
+
+	if (jiffies_t == jiffies_p) {
+		if (count > count_p) {
+			/* the nutcase */
+			if (ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
+				count -= LATCH;
+			} else {
+				printk("%s (): hardware timer problem?\n",
+				       __FUNCTION__);
+			}
+		}
+	} else
+		jiffies_p = jiffies_t;
+
+	count_p = count;
+	spin_unlock_irqrestore(&tmu0_lock, flags);
+
+	count = ((LATCH-1) - count) * TICK_SIZE;
+	count = (count + LATCH/2) / LATCH;
+
+	return count;
+}
+
+static irqreturn_t tmu_timer_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	unsigned long timer_status;
+
+	/* Clear UNF bit */
+	timer_status = ctrl_inw(TMU0_TCR);
+	timer_status &= ~0x100;
+	ctrl_outw(timer_status, TMU0_TCR);
+
+	/*
+	 * Here we are in the timer irq handler. We just have irqs locally
+	 * disabled but we don't know if the timer_bh is running on the other
+	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
+	 * the irq version of write_lock because as just said we have irq
+	 * locally disabled. -arca
+	 */
+	write_seqlock(&xtime_lock);
+	handle_timer_tick(regs);
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction tmu_irq = {
+	.name		= "timer",
+	.handler	= tmu_timer_interrupt,
+	.flags		= SA_INTERRUPT,
+	.mask		= CPU_MASK_NONE,
+};
+
+/*
+ * Hah!  We'll see if this works (switching from usecs to nsecs).
+ */
+static unsigned long tmu_timer_get_frequency(void)
+{
+	u32 freq;
+	struct timespec ts1, ts2;
+	unsigned long diff_nsec;
+	unsigned long factor;
+
+	/* Setup the timer:  We don't want to generate interrupts, just
+	 * have it count down at its natural rate.
+	 */
+	ctrl_outb(0, TMU_TSTR);
+#if !defined(CONFIG_CPU_SUBTYPE_SH7300) && !defined(CONFIG_CPU_SUBTYPE_SH7760)
+	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
+#endif
+	ctrl_outw(TMU0_TCR_CALIB, TMU0_TCR);
+	ctrl_outl(0xffffffff, TMU0_TCOR);
+	ctrl_outl(0xffffffff, TMU0_TCNT);
+
+	rtc_get_time(&ts2);
+
+	do {
+		rtc_get_time(&ts1);
+	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
+
+	/* actually start the timer */
+	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+
+	do {
+		rtc_get_time(&ts2);
+	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
+
+	freq = 0xffffffff - ctrl_inl(TMU0_TCNT);
+	if (ts2.tv_nsec < ts1.tv_nsec) {
+		ts2.tv_nsec += 1000000000;
+		ts2.tv_sec--;
+	}
+
+	diff_nsec = (ts2.tv_sec - ts1.tv_sec) * 1000000000 + (ts2.tv_nsec - ts1.tv_nsec);
+
+	/* this should work well if the RTC has a precision of n Hz, where
+	 * n is an integer.  I don't think we have to worry about the other
+	 * cases. */
+	factor = (1000000000 + diff_nsec/2) / diff_nsec;
+
+	if (factor * diff_nsec > 1100000000 ||
+	    factor * diff_nsec <  900000000)
+		panic("weird RTC (diff_nsec %ld)", diff_nsec);
+
+	return freq * factor;
+}
+
+static void tmu_clk_init(struct clk *clk)
+{
+	u8 divisor = TMU0_TCR_INIT & 0x7;
+	ctrl_outw(TMU0_TCR_INIT, TMU0_TCR);
+	clk->rate = clk->parent->rate / (4 << (divisor << 1));
+}
+
+static void tmu_clk_recalc(struct clk *clk)
+{
+	u8 divisor = ctrl_inw(TMU0_TCR) & 0x7;
+	clk->rate = clk->parent->rate / (4 << (divisor << 1));
+}
+
+static struct clk_ops tmu_clk_ops = {
+	.init		= tmu_clk_init,
+	.recalc		= tmu_clk_recalc,
+};
+
+static struct clk tmu0_clk = {
+	.name		= "tmu0_clk",
+	.ops		= &tmu_clk_ops,
+};
+
+static int tmu_timer_init(void)
+{
+	unsigned long interval;
+
+	setup_irq(TIMER_IRQ, &tmu_irq);
+
+	tmu0_clk.parent = clk_get("module_clk");
+
+	/* Start TMU0 */
+	ctrl_outb(0, TMU_TSTR);
+#if !defined(CONFIG_CPU_SUBTYPE_SH7300) && !defined(CONFIG_CPU_SUBTYPE_SH7760)
+	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
+#endif
+
+	clk_register(&tmu0_clk);
+	clk_enable(&tmu0_clk);
+
+	interval = (clk_get_rate(&tmu0_clk) + HZ / 2) / HZ;
+	printk(KERN_INFO "Interval = %ld\n", interval);
+
+	ctrl_outl(interval, TMU0_TCOR);
+	ctrl_outl(interval, TMU0_TCNT);
+
+	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+
+	return 0;
+}
+
+struct sys_timer_ops tmu_timer_ops = {
+	.init		= tmu_timer_init,
+	.get_frequency	= tmu_timer_get_frequency,
+	.get_offset	= tmu_timer_get_offset,
+};
+
+struct sys_timer tmu_timer = {
+	.name	= "tmu",
+	.ops	= &tmu_timer_ops,
+};
+
diff -purN linux-2.6.15-git12/arch/sh/kernel/timers/timer.c linux-2.6.16-rc1/arch/sh/kernel/timers/timer.c
--- linux-2.6.15-git12/arch/sh/kernel/timers/timer.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/kernel/timers/timer.c	2006-01-17 08:22:44.195448701 +0000
@@ -0,0 +1,50 @@
+/*
+ * arch/sh/kernel/timers/timer.c - Common timer code
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <asm/timer.h>
+
+static struct sys_timer *sys_timers[] __initdata = {
+#ifdef CONFIG_SH_TMU
+	&tmu_timer,
+#endif
+	NULL,
+};
+
+static char timer_override[10] __initdata;
+static int __init timer_setup(char *str)
+{
+	if (str)
+		strlcpy(timer_override, str, sizeof(timer_override));
+	return 1;
+}
+__setup("timer=", timer_setup);
+
+struct sys_timer *get_sys_timer(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sys_timers); i++) {
+		struct sys_timer *t = sys_timers[i];
+
+		if (unlikely(!t))
+			break;
+		if (unlikely(timer_override[0]))
+			if ((strcmp(timer_override, t->name) != 0))
+				continue;
+		if (likely(t->ops->init() == 0))
+			return t;
+	}
+
+	return NULL;
+}
+
diff -purN linux-2.6.15-git12/arch/sh/mm/Kconfig linux-2.6.16-rc1/arch/sh/mm/Kconfig
--- linux-2.6.15-git12/arch/sh/mm/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/mm/Kconfig	2006-01-17 08:22:44.198448229 +0000
@@ -0,0 +1,233 @@
+menu "Processor selection"
+
+#
+# Processor families
+#
+config CPU_SH2
+	bool
+	select SH_WRITETHROUGH
+
+config CPU_SH3
+	bool
+	select CPU_HAS_INTEVT
+	select CPU_HAS_SR_RB
+
+config CPU_SH4
+	bool
+	select CPU_HAS_INTEVT
+	select CPU_HAS_SR_RB
+
+config CPU_SH4A
+	bool
+	select CPU_SH4
+	select CPU_HAS_INTC2_IRQ
+
+config CPU_SUBTYPE_ST40
+	bool
+	select CPU_SH4
+	select CPU_HAS_INTC2_IRQ
+
+#
+# Processor subtypes
+#
+
+comment "SH-2 Processor Support"
+
+config CPU_SUBTYPE_SH7604
+	bool "Support SH7604 processor"
+	select CPU_SH2
+
+comment "SH-3 Processor Support"
+
+config CPU_SUBTYPE_SH7300
+	bool "Support SH7300 processor"
+	select CPU_SH3
+
+config CPU_SUBTYPE_SH7705
+	bool "Support SH7705 processor"
+	select CPU_SH3
+	select CPU_HAS_PINT_IRQ
+
+config CPU_SUBTYPE_SH7707
+	bool "Support SH7707 processor"
+	select CPU_SH3
+	select CPU_HAS_PINT_IRQ
+	help
+	  Select SH7707 if you have a  60 Mhz SH-3 HD6417707 CPU.
+
+config CPU_SUBTYPE_SH7708
+	bool "Support SH7708 processor"
+	select CPU_SH3
+	help
+	  Select SH7708 if you have a  60 Mhz SH-3 HD6417708S or
+	  if you have a 100 Mhz SH-3 HD6417708R CPU.
+
+config CPU_SUBTYPE_SH7709
+	bool "Support SH7709 processor"
+	select CPU_SH3
+	select CPU_HAS_PINT_IRQ
+	help
+	  Select SH7709 if you have a  80 Mhz SH-3 HD6417709 CPU.
+
+comment "SH-4 Processor Support"
+
+config CPU_SUBTYPE_SH7750
+	bool "Support SH7750 processor"
+	select CPU_SH4
+	help
+	  Select SH7750 if you have a 200 Mhz SH-4 HD6417750 CPU.
+
+config CPU_SUBTYPE_SH7091
+	bool "Support SH7091 processor"
+	select CPU_SH4
+	select CPU_SUBTYPE_SH7750
+	help
+	  Select SH7091 if you have an SH-4 based Sega device (such as
+	  the Dreamcast, Naomi, and Naomi 2).
+
+config CPU_SUBTYPE_SH7750R
+	bool "Support SH7750R processor"
+	select CPU_SH4
+	select CPU_SUBTYPE_SH7750
+
+config CPU_SUBTYPE_SH7750S
+	bool "Support SH7750S processor"
+	select CPU_SH4
+	select CPU_SUBTYPE_SH7750
+
+config CPU_SUBTYPE_SH7751
+	bool "Support SH7751 processor"
+	select CPU_SH4
+	help
+	  Select SH7751 if you have a 166 Mhz SH-4 HD6417751 CPU,
+	  or if you have a HD6417751R CPU.
+
+config CPU_SUBTYPE_SH7751R
+	bool "Support SH7751R processor"
+	select CPU_SH4
+	select CPU_SUBTYPE_SH7751
+
+config CPU_SUBTYPE_SH7760
+	bool "Support SH7760 processor"
+	select CPU_SH4
+	select CPU_HAS_INTC2_IRQ
+
+config CPU_SUBTYPE_SH4_202
+	bool "Support SH4-202 processor"
+	select CPU_SH4
+
+comment "ST40 Processor Support"
+
+config CPU_SUBTYPE_ST40STB1
+	bool "Support ST40STB1/ST40RA processors"
+	select CPU_SUBTYPE_ST40
+	help
+	  Select ST40STB1 if you have a ST40RA CPU.
+	  This was previously called the ST40STB1, hence the option name.
+
+config CPU_SUBTYPE_ST40GX1
+	bool "Support ST40GX1 processor"
+	select CPU_SUBTYPE_ST40
+	help
+	  Select ST40GX1 if you have a ST40GX1 CPU.
+
+comment "SH-4A Processor Support"
+
+config CPU_SUBTYPE_SH73180
+	bool "Support SH73180 processor"
+	select CPU_SH4A
+
+config CPU_SUBTYPE_SH7770
+	bool "Support SH7770 processor"
+	select CPU_SH4A
+
+config CPU_SUBTYPE_SH7780
+	bool "Support SH7780 processor"
+	select CPU_SH4A
+
+endmenu
+
+menu "Memory management options"
+
+config MMU
+        bool "Support for memory management hardware"
+	depends on !CPU_SH2
+	default y
+	help
+	  Some SH processors (such as SH-2/SH-2A) lack an MMU. In order to
+	  boot on these systems, this option must not be set.
+
+	  On other systems (such as the SH-3 and 4) where an MMU exists,
+	  turning this off will boot the kernel on these machines with the
+	  MMU implicitly switched off.
+
+config 32BIT
+	bool "Support 32-bit physical addressing through PMB"
+	depends on CPU_SH4A
+	default y
+	help
+	  If you say Y here, physical addressing will be extended to
+	  32-bits through the SH-4A PMB. If this is not set, legacy
+	  29-bit physical addressing will be used.
+
+choice
+	prompt "HugeTLB page size"
+	depends on HUGETLB_PAGE && CPU_SH4 && MMU
+	default HUGETLB_PAGE_SIZE_64K
+
+config HUGETLB_PAGE_SIZE_64K
+	bool "64K"
+
+config HUGETLB_PAGE_SIZE_1MB
+	bool "1MB"
+
+endchoice
+
+source "mm/Kconfig"
+
+endmenu
+
+menu "Cache configuration"
+
+config SH7705_CACHE_32KB
+	bool "Enable 32KB cache size for SH7705"
+	depends on CPU_SUBTYPE_SH7705
+	default y
+
+config SH_DIRECT_MAPPED
+	bool "Use direct-mapped caching"
+	default n
+	help
+	  Selecting this option will configure the caches to be direct-mapped,
+	  even if the cache supports a 2 or 4-way mode. This is useful primarily
+	  for debugging on platforms with 2 and 4-way caches (SH7750R/SH7751R,
+	  SH4-202, SH4-501, etc.)
+
+	  Turn this option off for platforms that do not have a direct-mapped
+	  cache, and you have no need to run the caches in such a configuration.
+
+config SH_WRITETHROUGH
+	bool "Use write-through caching"
+	default y if CPU_SH2
+	help
+	  Selecting this option will configure the caches in write-through
+	  mode, as opposed to the default write-back configuration.
+
+	  Since there's sill some aliasing issues on SH-4, this option will
+	  unfortunately still require the majority of flushing functions to
+	  be implemented to deal with aliasing.
+
+	  If unsure, say N.
+
+config SH_OCRAM
+	bool "Operand Cache RAM (OCRAM) support"
+	help
+	  Selecting this option will automatically tear down the number of
+	  sets in the dcache by half, which in turn exposes a memory range.
+
+	  The addresses for the OC RAM base will vary according to the
+	  processor version. Consult vendor documentation for specifics.
+
+	  If unsure, say N.
+
+endmenu
diff -purN linux-2.6.15-git12/arch/sh/mm/ioremap.c linux-2.6.16-rc1/arch/sh/mm/ioremap.c
--- linux-2.6.15-git12/arch/sh/mm/ioremap.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/mm/ioremap.c	2006-01-17 08:22:44.200447914 +0000
@@ -6,13 +6,19 @@
  * 640k-1MB IO memory area on PC's
  *
  * (C) Copyright 1995 1996 Linus Torvalds
+ * (C) Copyright 2005, 2006 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
  */
-
 #include <linux/vmalloc.h>
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #include <asm/pgalloc.h>
+#include <asm/addrspace.h>
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
@@ -80,9 +86,15 @@ int remap_area_pages(unsigned long addre
 	if (address >= end)
 		BUG();
 	do {
+		pud_t *pud;
 		pmd_t *pmd;
-		pmd = pmd_alloc(&init_mm, dir, address);
+
 		error = -ENOMEM;
+
+		pud = pud_alloc(&init_mm, dir, address);
+		if (!pud)
+			break;
+		pmd = pmd_alloc(&init_mm, pud, address);
 		if (!pmd)
 			break;
 		if (remap_area_pmd(pmd, address, end - address,
@@ -97,10 +109,6 @@ int remap_area_pages(unsigned long addre
 }
 
 /*
- * Generic mapping function (not visible outside):
- */
-
-/*
  * Remap an arbitrary physical address space into the kernel virtual
  * address space. Needed when the kernel wants to access high addresses
  * directly.
@@ -109,11 +117,11 @@ int remap_area_pages(unsigned long addre
  * have to convert them into an offset in a page-aligned mapping, but the
  * caller shouldn't need to know that small detail.
  */
-void * p3_ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
+void __iomem *__ioremap(unsigned long phys_addr, unsigned long size,
+			unsigned long flags)
 {
-	void * addr;
 	struct vm_struct * area;
-	unsigned long offset, last_addr;
+	unsigned long offset, last_addr, addr, orig_addr;
 
 	/* Don't allow wraparound or zero size */
 	last_addr = phys_addr + size - 1;
@@ -124,7 +132,7 @@ void * p3_ioremap(unsigned long phys_add
 	 * Don't remap the low PCI/ISA area, it's always mapped..
 	 */
 	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
-		return phys_to_virt(phys_addr);
+		return (void __iomem *)phys_to_virt(phys_addr);
 
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
@@ -146,16 +154,71 @@ void * p3_ioremap(unsigned long phys_add
 	if (!area)
 		return NULL;
 	area->phys_addr = phys_addr;
-	addr = area->addr;
-	if (remap_area_pages((unsigned long) addr, phys_addr, size, flags)) {
-		vunmap(addr);
-		return NULL;
+	orig_addr = addr = (unsigned long)area->addr;
+
+#ifdef CONFIG_32BIT
+	/*
+	 * First try to remap through the PMB once a valid VMA has been
+	 * established. Smaller allocations (or the rest of the size
+	 * remaining after a PMB mapping due to the size not being
+	 * perfectly aligned on a PMB size boundary) are then mapped
+	 * through the UTLB using conventional page tables.
+	 *
+	 * PMB entries are all pre-faulted.
+	 */
+	if (unlikely(size >= 0x1000000)) {
+		unsigned long mapped = pmb_remap(addr, phys_addr, size, flags);
+
+		if (likely(mapped)) {
+			addr		+= mapped;
+			phys_addr	+= mapped;
+			size		-= mapped;
+		}
 	}
-	return (void *) (offset + (char *)addr);
+#endif
+
+	if (likely(size))
+		if (remap_area_pages(addr, phys_addr, size, flags)) {
+			vunmap((void *)orig_addr);
+			return NULL;
+		}
+
+	return (void __iomem *)(offset + (char *)orig_addr);
 }
+EXPORT_SYMBOL(__ioremap);
 
-void p3_iounmap(void *addr)
+void __iounmap(void __iomem *addr)
 {
-	if (addr > high_memory)
-		vfree((void *)(PAGE_MASK & (unsigned long)addr));
+	unsigned long vaddr = (unsigned long __force)addr;
+	struct vm_struct *p;
+
+	if (PXSEG(vaddr) < P3SEG)
+		return;
+
+#ifdef CONFIG_32BIT
+	/*
+	 * Purge any PMB entries that may have been established for this
+	 * mapping, then proceed with conventional VMA teardown.
+	 *
+	 * XXX: Note that due to the way that remove_vm_area() does
+	 * matching of the resultant VMA, we aren't able to fast-forward
+	 * the address past the PMB space until the end of the VMA where
+	 * the page tables reside. As such, unmap_vm_area() will be
+	 * forced to linearly scan over the area until it finds the page
+	 * tables where PTEs that need to be unmapped actually reside,
+	 * which is far from optimal. Perhaps we need to use a separate
+	 * VMA for the PMB mappings?
+	 *					-- PFM.
+	 */
+	pmb_unmap(vaddr);
+#endif
+
+	p = remove_vm_area((void *)(vaddr & PAGE_MASK));
+	if (!p) {
+		printk(KERN_ERR "%s: bad address %p\n", __FUNCTION__, addr);
+		return;
+	}
+
+	kfree(p);
 }
+EXPORT_SYMBOL(__iounmap);
diff -purN linux-2.6.15-git12/arch/sh/tools/mach-types linux-2.6.16-rc1/arch/sh/tools/mach-types
--- linux-2.6.15-git12/arch/sh/tools/mach-types	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/sh/tools/mach-types	2006-01-17 08:22:44.201447756 +0000
@@ -10,10 +10,7 @@ SE			SH_SOLUTION_ENGINE
 7300SE			SH_7300_SOLUTION_ENGINE
 73180SE			SH_73180_SOLUTION_ENGINE
 7751SYSTEMH		SH_7751_SYSTEMH
-HP600			SH_HP600
-HP620			SH_HP620
-HP680			SH_HP680
-HP690			SH_HP690
+HP6XX			SH_HP6XX
 HD64461			HD64461
 HD64465			HD64465
 SH2000			SH_SH2000
diff -purN linux-2.6.15-git12/arch/x86_64/Kconfig linux-2.6.16-rc1/arch/x86_64/Kconfig
--- linux-2.6.15-git12/arch/x86_64/Kconfig	2006-01-17 08:21:30.320759377 +0000
+++ linux-2.6.16-rc1/arch/x86_64/Kconfig	2006-01-17 08:22:44.407415326 +0000
@@ -305,7 +305,11 @@ config ARCH_DISCONTIGMEM_DEFAULT
 
 config ARCH_SPARSEMEM_ENABLE
 	def_bool y
-	depends on NUMA
+	depends on (NUMA || EXPERIMENTAL)
+
+config ARCH_MEMORY_PROBE
+	def_bool y
+	depends on MEMORY_HOTPLUG
 
 config ARCH_FLATMEM_ENABLE
 	def_bool y
@@ -315,6 +319,7 @@ source "mm/Kconfig"
 
 config HAVE_ARCH_EARLY_PFN_TO_NID
 	def_bool y
+	depends on NUMA
 
 config NR_CPUS
 	int "Maximum number of CPUs (2-256)"
@@ -350,7 +355,7 @@ config HPET_TIMER
 	  <http://www.intel.com/hardwaredesign/hpetspec.htm>.
 
 config X86_PM_TIMER
-	bool "PM timer"
+	bool "PM timer" if EMBEDDED
 	depends on ACPI
 	default y
 	help
diff -purN linux-2.6.15-git12/arch/x86_64/defconfig linux-2.6.16-rc1/arch/x86_64/defconfig
--- linux-2.6.15-git12/arch/x86_64/defconfig	2006-01-17 08:21:30.336756859 +0000
+++ linux-2.6.16-rc1/arch/x86_64/defconfig	2006-01-17 08:22:44.425412493 +0000
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.15-git7
-# Wed Jan 11 11:57:36 2006
+# Linux kernel version: 2.6.15-git12
+# Mon Jan 16 13:09:08 2006
 #
 CONFIG_X86_64=y
 CONFIG_64BIT=y
@@ -319,6 +319,11 @@ CONFIG_IPV6=y
 # CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
 # CONFIG_NET_DIVERT is not set
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
@@ -537,8 +542,7 @@ CONFIG_SCSI_SATA_INTEL_COMBINED=y
 # CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX=y
-# CONFIG_SCSI_QLA2XXX_EMBEDDED_FIRMWARE is not set
+# CONFIG_SCSI_QLA_FC is not set
 # CONFIG_SCSI_LPFC is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
@@ -805,6 +809,7 @@ CONFIG_SOFT_WATCHDOG=y
 # CONFIG_W83877F_WDT is not set
 # CONFIG_W83977F_WDT is not set
 # CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
 
 #
 # PCI-based Watchdog Cards
@@ -850,6 +855,12 @@ CONFIG_HPET_MMAP=y
 # CONFIG_I2C is not set
 
 #
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
 # Dallas's 1-wire bus
 #
 # CONFIG_W1 is not set
@@ -992,6 +1003,7 @@ CONFIG_USB_STORAGE=y
 #
 CONFIG_USB_HID=y
 CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
 # CONFIG_HID_FF is not set
 # CONFIG_USB_HIDDEV is not set
 # CONFIG_USB_AIPTEK is not set
@@ -1276,6 +1288,7 @@ CONFIG_DETECT_SOFTLOCKUP=y
 CONFIG_DEBUG_FS=y
 # CONFIG_DEBUG_VM is not set
 # CONFIG_FRAME_POINTER is not set
+# CONFIG_FORCED_INLINING is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_INIT_DEBUG=y
 # CONFIG_DEBUG_RODATA is not set
diff -purN linux-2.6.15-git12/arch/x86_64/ia32/Makefile linux-2.6.16-rc1/arch/x86_64/ia32/Makefile
--- linux-2.6.15-git12/arch/x86_64/ia32/Makefile	2006-01-17 08:21:30.337756701 +0000
+++ linux-2.6.16-rc1/arch/x86_64/ia32/Makefile	2006-01-17 08:22:44.426412335 +0000
@@ -3,7 +3,8 @@
 #
 
 obj-$(CONFIG_IA32_EMULATION) := ia32entry.o sys_ia32.o ia32_signal.o tls32.o \
-	ia32_binfmt.o fpu32.o ptrace32.o syscall32.o syscall32_syscall.o
+	ia32_binfmt.o fpu32.o ptrace32.o syscall32.o syscall32_syscall.o \
+	mmap32.o
 
 sysv-$(CONFIG_SYSVIPC) := ipc32.o
 obj-$(CONFIG_IA32_EMULATION) += $(sysv-y)
diff -purN linux-2.6.15-git12/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.16-rc1/arch/x86_64/ia32/ia32_binfmt.c
--- linux-2.6.15-git12/arch/x86_64/ia32/ia32_binfmt.c	2006-01-17 08:21:30.338756544 +0000
+++ linux-2.6.16-rc1/arch/x86_64/ia32/ia32_binfmt.c	2006-01-17 08:22:44.428412020 +0000
@@ -293,8 +293,6 @@ int ia32_setup_arg_pages(struct linux_bi
 } while(0) 
 
 
-#define elf_map elf32_map
-
 #include <linux/module.h>
 
 MODULE_DESCRIPTION("Binary format loader for compatibility with IA32 ELF binaries."); 
@@ -390,21 +388,6 @@ int ia32_setup_arg_pages(struct linux_bi
 }
 EXPORT_SYMBOL(ia32_setup_arg_pages);
 
-static unsigned long
-elf32_map (struct file *filep, unsigned long addr, struct elf_phdr *eppnt, int prot, int type)
-{
-	unsigned long map_addr;
-	struct task_struct *me = current; 
-
-	down_write(&me->mm->mmap_sem);
-	map_addr = do_mmap(filep, ELF_PAGESTART(addr),
-			   eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr), prot, 
-			   type,
-			   eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr));
-	up_write(&me->mm->mmap_sem);
-	return(map_addr);
-}
-
 #ifdef CONFIG_SYSCTL
 /* Register vsyscall32 into the ABI table */
 #include <linux/sysctl.h>
diff -purN linux-2.6.15-git12/arch/x86_64/ia32/mmap32.c linux-2.6.16-rc1/arch/x86_64/ia32/mmap32.c
--- linux-2.6.15-git12/arch/x86_64/ia32/mmap32.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/x86_64/ia32/mmap32.c	2006-01-17 08:22:44.437410604 +0000
@@ -0,0 +1,78 @@
+/*
+ *  linux/arch/x86_64/ia32/mm/mmap.c
+ *
+ *  flexible mmap layout support
+ *
+ * Based on the i386 version which was
+ *
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * Started by Ingo Molnar <mingo@elte.hu>
+ */
+
+#include <linux/personality.h>
+#include <linux/mm.h>
+#include <linux/random.h>
+
+/*
+ * Top of mmap area (just below the process stack).
+ *
+ * Leave an at least ~128 MB hole.
+ */
+#define MIN_GAP (128*1024*1024)
+#define MAX_GAP (TASK_SIZE/6*5)
+
+static inline unsigned long mmap_base(struct mm_struct *mm)
+{
+	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long random_factor = 0;
+
+	if (current->flags & PF_RANDOMIZE)
+		random_factor = get_random_int() % (1024*1024);
+
+	if (gap < MIN_GAP)
+		gap = MIN_GAP;
+	else if (gap > MAX_GAP)
+		gap = MAX_GAP;
+
+	return PAGE_ALIGN(TASK_SIZE - gap - random_factor);
+}
+
+/*
+ * This function, called very early during the creation of a new
+ * process VM image, sets up which VM layout function to use:
+ */
+void ia32_pick_mmap_layout(struct mm_struct *mm)
+{
+	/*
+	 * Fall back to the standard layout if the personality
+	 * bit is set, or if the expected stack growth is unlimited:
+	 */
+	if (sysctl_legacy_va_layout ||
+			(current->personality & ADDR_COMPAT_LAYOUT) ||
+			current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
+		mm->mmap_base = TASK_UNMAPPED_BASE;
+		mm->get_unmapped_area = arch_get_unmapped_area;
+		mm->unmap_area = arch_unmap_area;
+	} else {
+		mm->mmap_base = mmap_base(mm);
+		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
+		mm->unmap_area = arch_unmap_area_topdown;
+	}
+}
diff -purN linux-2.6.15-git12/arch/x86_64/kernel/apic.c linux-2.6.16-rc1/arch/x86_64/kernel/apic.c
--- linux-2.6.15-git12/arch/x86_64/kernel/apic.c	2006-01-17 08:21:30.361752923 +0000
+++ linux-2.6.16-rc1/arch/x86_64/kernel/apic.c	2006-01-17 08:22:44.454407927 +0000
@@ -499,13 +499,10 @@ static int lapic_resume(struct sys_devic
 	if (!apic_pm_state.active)
 		return 0;
 
-	/* XXX: Pavel needs this for S3 resume, but can't explain why */
-	set_fixmap_nocache(FIX_APIC_BASE, APIC_DEFAULT_PHYS_BASE);
-
 	local_irq_save(flags);
 	rdmsr(MSR_IA32_APICBASE, l, h);
 	l &= ~MSR_IA32_APICBASE_BASE;
-	l |= MSR_IA32_APICBASE_ENABLE | APIC_DEFAULT_PHYS_BASE;
+	l |= MSR_IA32_APICBASE_ENABLE | mp_lapic_addr;
 	wrmsr(MSR_IA32_APICBASE, l, h);
 	apic_write(APIC_LVTERR, ERROR_APIC_VECTOR | APIC_LVT_MASKED);
 	apic_write(APIC_ID, apic_pm_state.apic_id);
diff -purN linux-2.6.15-git12/arch/x86_64/kernel/asm-offsets.c linux-2.6.16-rc1/arch/x86_64/kernel/asm-offsets.c
--- linux-2.6.15-git12/arch/x86_64/kernel/asm-offsets.c	2006-01-17 08:21:30.362752765 +0000
+++ linux-2.6.16-rc1/arch/x86_64/kernel/asm-offsets.c	2006-01-17 08:22:44.455407770 +0000
@@ -43,6 +43,7 @@ int main(void)
 	ENTRY(irqcount);
 	ENTRY(cpunumber);
 	ENTRY(irqstackptr);
+	ENTRY(data_offset);
 	BLANK();
 #undef ENTRY
 #ifdef CONFIG_IA32_EMULATION
@@ -66,8 +67,6 @@ int main(void)
 	DEFINE(pbe_orig_address, offsetof(struct pbe, orig_address));
 	DEFINE(pbe_next, offsetof(struct pbe, next));
 	BLANK();
-#if DEBUG_STKSZ > EXCEPTION_STKSZ
-	DEFINE(DEBUG_IST, DEBUG_STACK);
-#endif
+	DEFINE(TSS_ist, offsetof(struct tss_struct, ist));
 	return 0;
 }
diff -purN linux-2.6.15-git12/arch/x86_64/kernel/entry.S linux-2.6.16-rc1/arch/x86_64/kernel/entry.S
--- linux-2.6.15-git12/arch/x86_64/kernel/entry.S	2006-01-17 08:21:30.372751191 +0000
+++ linux-2.6.16-rc1/arch/x86_64/kernel/entry.S	2006-01-17 08:22:44.465406196 +0000
@@ -41,6 +41,7 @@
 #include <asm/unistd.h>
 #include <asm/thread_info.h>
 #include <asm/hw_irq.h>
+#include <asm/page.h>
 
 	.code64
 
@@ -674,9 +675,6 @@ ENTRY(spurious_interrupt)
 
 	/* error code is on the stack already */
 	/* handle NMI like exceptions that can happen everywhere */
-#ifndef DEBUG_IST
-# define DEBUG_IST 0
-#endif
 	.macro paranoidentry sym, ist=0
 	SAVE_ALL
 	cld
@@ -695,11 +693,11 @@ ENTRY(spurious_interrupt)
 	movq ORIG_RAX(%rsp),%rsi
 	movq $-1,ORIG_RAX(%rsp)
 	.if \ist
-	subq	$EXCEPTION_STACK_SIZE, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	subq	$EXCEPTION_STKSZ, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
 	.endif
 	call \sym
 	.if \ist
-	addq	$EXCEPTION_STACK_SIZE, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	addq	$EXCEPTION_STKSZ, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
 	.endif
 	cli
 	.endm
@@ -918,7 +916,7 @@ KPROBE_ENTRY(debug)
  	INTR_FRAME
 	pushq $0
 	CFI_ADJUST_CFA_OFFSET 8		
-	paranoidentry do_debug, DEBUG_IST
+	paranoidentry do_debug, DEBUG_STACK
 	jmp paranoid_exit
 	CFI_ENDPROC
 	.previous .text
@@ -976,7 +974,7 @@ KPROBE_ENTRY(int3)
  	INTR_FRAME
  	pushq $0
  	CFI_ADJUST_CFA_OFFSET 8
- 	paranoidentry do_int3, DEBUG_IST
+ 	paranoidentry do_int3, DEBUG_STACK
  	jmp paranoid_exit
  	CFI_ENDPROC
 	.previous .text
diff -purN linux-2.6.15-git12/arch/x86_64/kernel/head.S linux-2.6.16-rc1/arch/x86_64/kernel/head.S
--- linux-2.6.15-git12/arch/x86_64/kernel/head.S	2006-01-17 08:21:30.376750562 +0000
+++ linux-2.6.16-rc1/arch/x86_64/kernel/head.S	2006-01-17 08:22:44.471405251 +0000
@@ -241,104 +241,70 @@ ljumpvector:
 ENTRY(stext)
 ENTRY(_stext)
 
-.org 0x1000
-ENTRY(init_level4_pgt)
+	$page = 0
+#define NEXT_PAGE(name) \
+	$page = $page + 1; \
+	.org $page * 0x1000; \
+	phys_/**/name = $page * 0x1000 + __PHYSICAL_START; \
+ENTRY(name)
+
+NEXT_PAGE(init_level4_pgt)
 	/* This gets initialized in x86_64_start_kernel */
 	.fill	512,8,0
 
-.org 0x2000
-ENTRY(level3_ident_pgt)
-	.quad	0x0000000000004007 + __PHYSICAL_START
+NEXT_PAGE(level3_ident_pgt)
+	.quad	phys_level2_ident_pgt | 0x007
 	.fill	511,8,0
 
-.org 0x3000
-ENTRY(level3_kernel_pgt)
+NEXT_PAGE(level3_kernel_pgt)
 	.fill	510,8,0
 	/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */
-	.quad	0x0000000000005007 + __PHYSICAL_START	/* -> level2_kernel_pgt */
+	.quad	phys_level2_kernel_pgt | 0x007
 	.fill	1,8,0
 
-.org 0x4000
-ENTRY(level2_ident_pgt)
+NEXT_PAGE(level2_ident_pgt)
 	/* 40MB for bootup. 	*/
-	.quad	0x0000000000000083
-	.quad	0x0000000000200083
-	.quad	0x0000000000400083
-	.quad	0x0000000000600083
-	.quad	0x0000000000800083
-	.quad	0x0000000000A00083
-	.quad	0x0000000000C00083
-	.quad	0x0000000000E00083
-	.quad	0x0000000001000083
-	.quad	0x0000000001200083
-	.quad	0x0000000001400083
-	.quad	0x0000000001600083
-	.quad	0x0000000001800083
-	.quad	0x0000000001A00083
-	.quad	0x0000000001C00083
-	.quad	0x0000000001E00083
-	.quad	0x0000000002000083
-	.quad	0x0000000002200083
-	.quad	0x0000000002400083
-	.quad	0x0000000002600083
+	i = 0
+	.rept 20
+	.quad	i << 21 | 0x083
+	i = i + 1
+	.endr
 	/* Temporary mappings for the super early allocator in arch/x86_64/mm/init.c */
 	.globl temp_boot_pmds
 temp_boot_pmds:
 	.fill	492,8,0
 	
-.org 0x5000
-ENTRY(level2_kernel_pgt)
+NEXT_PAGE(level2_kernel_pgt)
 	/* 40MB kernel mapping. The kernel code cannot be bigger than that.
 	   When you change this change KERNEL_TEXT_SIZE in page.h too. */
 	/* (2^48-(2*1024*1024*1024)-((2^39)*511)-((2^30)*510)) = 0 */
-	.quad	0x0000000000000183
-	.quad	0x0000000000200183
-	.quad	0x0000000000400183
-	.quad	0x0000000000600183
-	.quad	0x0000000000800183
-	.quad	0x0000000000A00183
-	.quad	0x0000000000C00183
-	.quad	0x0000000000E00183
-	.quad	0x0000000001000183
-	.quad	0x0000000001200183
-	.quad	0x0000000001400183
-	.quad	0x0000000001600183
-	.quad	0x0000000001800183
-	.quad	0x0000000001A00183
-	.quad	0x0000000001C00183
-	.quad	0x0000000001E00183
-	.quad	0x0000000002000183
-	.quad	0x0000000002200183
-	.quad	0x0000000002400183
-	.quad	0x0000000002600183
+	i = 0
+	.rept 20
+	.quad	i << 21 | 0x183
+	i = i + 1
+	.endr
 	/* Module mapping starts here */
 	.fill	492,8,0
 
-.org 0x6000
-ENTRY(empty_zero_page)
-
-.org 0x7000
-ENTRY(empty_bad_page)
+NEXT_PAGE(empty_zero_page)
 
-.org 0x8000
-ENTRY(empty_bad_pte_table)
+NEXT_PAGE(level3_physmem_pgt)
+	.quad	phys_level2_kernel_pgt | 0x007	/* so that __va works even before pagetable_init */
+	.fill	511,8,0
 
-.org 0x9000
-ENTRY(empty_bad_pmd_table)
+#undef NEXT_PAGE
 
-.org 0xa000
-ENTRY(level3_physmem_pgt)
-	.quad	0x0000000000005007 + __PHYSICAL_START	/* -> level2_kernel_pgt (so that __va works even before pagetable_init) */
+	.data
 
-	.org 0xb000
 #ifdef CONFIG_ACPI_SLEEP
+	.align PAGE_SIZE
 ENTRY(wakeup_level4_pgt)
-	.quad	0x0000000000002007 + __PHYSICAL_START	/* -> level3_ident_pgt */
+	.quad	phys_level3_ident_pgt | 0x007
 	.fill	255,8,0
-	.quad	0x000000000000a007 + __PHYSICAL_START
+	.quad	phys_level3_physmem_pgt | 0x007
 	.fill	254,8,0
 	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
-	.quad	0x0000000000003007 + __PHYSICAL_START	/* -> level3_kernel_pgt */
+	.quad	phys_level3_kernel_pgt | 0x007
 #endif
 
 #ifndef CONFIG_HOTPLUG_CPU
@@ -352,12 +318,12 @@ ENTRY(wakeup_level4_pgt)
 	 */
 	.align PAGE_SIZE
 ENTRY(boot_level4_pgt)
-	.quad	0x0000000000002007 + __PHYSICAL_START	/* -> level3_ident_pgt */
+	.quad	phys_level3_ident_pgt | 0x007
 	.fill	255,8,0
-	.quad	0x000000000000a007 + __PHYSICAL_START
+	.quad	phys_level3_physmem_pgt | 0x007
 	.fill	254,8,0
 	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
-	.quad	0x0000000000003007 + __PHYSICAL_START	/* -> level3_kernel_pgt */
+	.quad	phys_level3_kernel_pgt | 0x007
 
 	.data
 
diff -purN linux-2.6.15-git12/arch/x86_64/kernel/setup64.c linux-2.6.16-rc1/arch/x86_64/kernel/setup64.c
--- linux-2.6.15-git12/arch/x86_64/kernel/setup64.c	2006-01-17 08:21:30.429742218 +0000
+++ linux-2.6.16-rc1/arch/x86_64/kernel/setup64.c	2006-01-17 08:22:44.530395963 +0000
@@ -38,7 +38,7 @@ struct desc_ptr idt_descr = { 256 * 16, 
 char boot_cpu_stack[IRQSTACKSIZE] __attribute__((section(".bss.page_aligned")));
 
 unsigned long __supported_pte_mask __read_mostly = ~0UL;
-static int do_not_nx __initdata = 0;
+static int do_not_nx __cpuinitdata = 0;
 
 /* noexec=on|off
 Control non executable mappings for 64bit processes.
diff -purN linux-2.6.15-git12/arch/x86_64/mm/Makefile linux-2.6.16-rc1/arch/x86_64/mm/Makefile
--- linux-2.6.15-git12/arch/x86_64/mm/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/arch/x86_64/mm/Makefile	2006-01-17 08:22:44.564390610 +0000
@@ -2,7 +2,7 @@
 # Makefile for the linux x86_64-specific parts of the memory manager.
 #
 
-obj-y	 := init.o fault.o ioremap.o extable.o pageattr.o
+obj-y	 := init.o fault.o ioremap.o extable.o pageattr.o mmap.o
 obj-$(CONFIG_HUGETLB_PAGE) += hugetlbpage.o
 obj-$(CONFIG_NUMA) += numa.o
 obj-$(CONFIG_K8_NUMA) += k8topology.o
diff -purN linux-2.6.15-git12/arch/x86_64/mm/init.c linux-2.6.16-rc1/arch/x86_64/mm/init.c
--- linux-2.6.15-git12/arch/x86_64/mm/init.c	2006-01-17 08:21:30.466736393 +0000
+++ linux-2.6.16-rc1/arch/x86_64/mm/init.c	2006-01-17 08:22:44.573389193 +0000
@@ -24,6 +24,8 @@
 #include <linux/proc_fs.h>
 #include <linux/pci.h>
 #include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/memory_hotplug.h>
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -180,13 +182,19 @@ static  struct temp_map { 
 	{}
 }; 
 
-static __init void *alloc_low_page(int *index, unsigned long *phys) 
+static __meminit void *alloc_low_page(int *index, unsigned long *phys)
 { 
 	struct temp_map *ti;
 	int i; 
 	unsigned long pfn = table_end++, paddr; 
 	void *adr;
 
+	if (after_bootmem) {
+		adr = (void *)get_zeroed_page(GFP_ATOMIC);
+		*phys = __pa(adr);
+		return adr;
+	}
+
 	if (pfn >= end_pfn) 
 		panic("alloc_low_page: ran out of memory"); 
 	for (i = 0; temp_mappings[i].allocated; i++) {
@@ -199,55 +207,86 @@ static __init void *alloc_low_page(int *
 	ti->allocated = 1; 
 	__flush_tlb(); 	       
 	adr = ti->address + ((pfn << PAGE_SHIFT) & ~PMD_MASK); 
+	memset(adr, 0, PAGE_SIZE);
 	*index = i; 
 	*phys  = pfn * PAGE_SIZE;  
 	return adr; 
 } 
 
-static __init void unmap_low_page(int i)
+static __meminit void unmap_low_page(int i)
 { 
-	struct temp_map *ti = &temp_mappings[i];
+	struct temp_map *ti;
+
+	if (after_bootmem)
+		return;
+
+	ti = &temp_mappings[i];
 	set_pmd(ti->pmd, __pmd(0));
 	ti->allocated = 0; 
 } 
 
-static void __init phys_pud_init(pud_t *pud, unsigned long address, unsigned long end)
+static void __meminit
+phys_pmd_init(pmd_t *pmd, unsigned long address, unsigned long end)
+{
+	int i;
+
+	for (i = 0; i < PTRS_PER_PMD; pmd++, i++, address += PMD_SIZE) {
+		unsigned long entry;
+
+		if (address > end) {
+			for (; i < PTRS_PER_PMD; i++, pmd++)
+				set_pmd(pmd, __pmd(0));
+			break;
+		}
+		entry = _PAGE_NX|_PAGE_PSE|_KERNPG_TABLE|_PAGE_GLOBAL|address;
+		entry &= __supported_pte_mask;
+		set_pmd(pmd, __pmd(entry));
+	}
+}
+
+static void __meminit
+phys_pmd_update(pud_t *pud, unsigned long address, unsigned long end)
+{
+	pmd_t *pmd = pmd_offset(pud, (unsigned long)__va(address));
+
+	if (pmd_none(*pmd)) {
+		spin_lock(&init_mm.page_table_lock);
+		phys_pmd_init(pmd, address, end);
+		spin_unlock(&init_mm.page_table_lock);
+		__flush_tlb_all();
+	}
+}
+
+static void __meminit phys_pud_init(pud_t *pud, unsigned long address, unsigned long end)
 { 
-	long i, j; 
+	long i = pud_index(address);
 
-	i = pud_index(address);
 	pud = pud + i;
+
+	if (after_bootmem && pud_val(*pud)) {
+		phys_pmd_update(pud, address, end);
+		return;
+	}
+
 	for (; i < PTRS_PER_PUD; pud++, i++) {
 		int map; 
 		unsigned long paddr, pmd_phys;
 		pmd_t *pmd;
 
-		paddr = address + i*PUD_SIZE;
-		if (paddr >= end) { 
-			for (; i < PTRS_PER_PUD; i++, pud++) 
-				set_pud(pud, __pud(0)); 
+		paddr = (address & PGDIR_MASK) + i*PUD_SIZE;
+		if (paddr >= end)
 			break;
-		} 
 
-		if (!e820_mapped(paddr, paddr+PUD_SIZE, 0)) { 
+		if (!after_bootmem && !e820_mapped(paddr, paddr+PUD_SIZE, 0)) {
 			set_pud(pud, __pud(0)); 
 			continue;
 		} 
 
 		pmd = alloc_low_page(&map, &pmd_phys);
+		spin_lock(&init_mm.page_table_lock);
 		set_pud(pud, __pud(pmd_phys | _KERNPG_TABLE));
-		for (j = 0; j < PTRS_PER_PMD; pmd++, j++, paddr += PMD_SIZE) {
-			unsigned long pe;
-
-			if (paddr >= end) { 
-				for (; j < PTRS_PER_PMD; j++, pmd++)
-					set_pmd(pmd,  __pmd(0)); 
-				break;
-		}
-			pe = _PAGE_NX|_PAGE_PSE | _KERNPG_TABLE | _PAGE_GLOBAL | paddr;
-			pe &= __supported_pte_mask;
-			set_pmd(pmd, __pmd(pe));
-		}
+		phys_pmd_init(pmd, paddr, end);
+		spin_unlock(&init_mm.page_table_lock);
 		unmap_low_page(map);
 	}
 	__flush_tlb();
@@ -262,30 +301,25 @@ static void __init find_early_table_spac
 	tables = round_up(puds * sizeof(pud_t), PAGE_SIZE) +
 		 round_up(pmds * sizeof(pmd_t), PAGE_SIZE);
 
-	/* Put page tables beyond the DMA zones if possible.
-	   RED-PEN might be better to spread them out more over
-	   memory to avoid hotspots */
-	if (end > MAX_DMA32_PFN<<PAGE_SHIFT)
-		start = MAX_DMA32_PFN << PAGE_SHIFT;
-	else if (end > MAX_DMA_PFN << PAGE_SHIFT)
-		start = MAX_DMA_PFN << PAGE_SHIFT;
-	else
-		start = 0x8000;
-
-	table_start = find_e820_area(start, end, tables);
-	if (table_start == -1)
-		table_start = find_e820_area(0x8000, end, tables);
+ 	/* RED-PEN putting page tables only on node 0 could
+ 	   cause a hotspot and fill up ZONE_DMA. The page tables
+ 	   need roughly 0.5KB per GB. */
+ 	start = 0x8000;
+ 	table_start = find_e820_area(start, end, tables);
 	if (table_start == -1UL)
 		panic("Cannot find space for the kernel page tables");
 
 	table_start >>= PAGE_SHIFT;
 	table_end = table_start;
+
+	early_printk("kernel direct mapping tables up to %lx @ %lx-%lx\n",
+		end, table_start << PAGE_SHIFT, table_end << PAGE_SHIFT);
 }
 
 /* Setup the direct mapping of the physical memory at PAGE_OFFSET.
    This runs before bootmem is initialized and gets pages directly from the 
    physical memory. To access them they are temporarily mapped. */
-void __init init_memory_mapping(unsigned long start, unsigned long end)
+void __meminit init_memory_mapping(unsigned long start, unsigned long end)
 { 
 	unsigned long next; 
 
@@ -297,7 +331,8 @@ void __init init_memory_mapping(unsigned
 	 * mapped.  Unfortunately this is done currently before the nodes are 
 	 * discovered.
 	 */
-	find_early_table_space(end);
+	if (!after_bootmem)
+		find_early_table_space(end);
 
 	start = (unsigned long)__va(start);
 	end = (unsigned long)__va(end);
@@ -305,20 +340,26 @@ void __init init_memory_mapping(unsigned
 	for (; start < end; start = next) {
 		int map;
 		unsigned long pud_phys; 
-		pud_t *pud = alloc_low_page(&map, &pud_phys);
+		pgd_t *pgd = pgd_offset_k(start);
+		pud_t *pud;
+
+		if (after_bootmem)
+			pud = pud_offset_k(pgd, __PAGE_OFFSET);
+		else
+			pud = alloc_low_page(&map, &pud_phys);
+
 		next = start + PGDIR_SIZE;
 		if (next > end) 
 			next = end; 
 		phys_pud_init(pud, __pa(start), __pa(next));
-		set_pgd(pgd_offset_k(start), mk_kernel_pgd(pud_phys));
+		if (!after_bootmem)
+			set_pgd(pgd_offset_k(start), mk_kernel_pgd(pud_phys));
 		unmap_low_page(map);   
 	} 
 
-	asm volatile("movq %%cr4,%0" : "=r" (mmu_cr4_features));
+	if (!after_bootmem)
+		asm volatile("movq %%cr4,%0" : "=r" (mmu_cr4_features));
 	__flush_tlb_all();
-	early_printk("kernel direct mapping tables upto %lx @ %lx-%lx\n", end, 
-	       table_start<<PAGE_SHIFT, 
-	       table_end<<PAGE_SHIFT);
 }
 
 void __cpuinit zap_low_mappings(int cpu)
@@ -393,6 +434,9 @@ size_zones(unsigned long *z, unsigned lo
 void __init paging_init(void)
 {
 	unsigned long zones[MAX_NR_ZONES], holes[MAX_NR_ZONES];
+
+	memory_present(0, 0, end_pfn);
+	sparse_init();
 	size_zones(zones, holes, 0, end_pfn);
 	free_area_init_node(0, NODE_DATA(0), zones,
 			    __pa(PAGE_OFFSET) >> PAGE_SHIFT, holes);
@@ -433,6 +477,50 @@ void __init clear_kernel_mapping(unsigne
 	__flush_tlb_all();
 } 
 
+/*
+ * Memory hotplug specific functions
+ * These are only for non-NUMA machines right now.
+ */
+#ifdef CONFIG_MEMORY_HOTPLUG
+
+void online_page(struct page *page)
+{
+	ClearPageReserved(page);
+	set_page_count(page, 1);
+	__free_page(page);
+	totalram_pages++;
+	num_physpages++;
+}
+
+int add_memory(u64 start, u64 size)
+{
+	struct pglist_data *pgdat = NODE_DATA(0);
+	struct zone *zone = pgdat->node_zones + MAX_NR_ZONES-2;
+	unsigned long start_pfn = start >> PAGE_SHIFT;
+	unsigned long nr_pages = size >> PAGE_SHIFT;
+	int ret;
+
+	ret = __add_pages(zone, start_pfn, nr_pages);
+	if (ret)
+		goto error;
+
+	init_memory_mapping(start, (start + size -1));
+
+	return ret;
+error:
+	printk("%s: Problem encountered in __add_pages!\n", __func__);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(add_memory);
+
+int remove_memory(u64 start, u64 size)
+{
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(remove_memory);
+
+#endif
+
 static struct kcore_list kcore_mem, kcore_vmalloc, kcore_kernel, kcore_modules,
 			 kcore_vsyscall;
 
@@ -539,7 +627,7 @@ void mark_rodata_ro(void)
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
-	if (start < (unsigned long)&_end)
+	if (start >= end)
 		return;
 	printk ("Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
 	for (; start < end; start += PAGE_SIZE) {
diff -purN linux-2.6.15-git12/arch/x86_64/mm/mmap.c linux-2.6.16-rc1/arch/x86_64/mm/mmap.c
--- linux-2.6.15-git12/arch/x86_64/mm/mmap.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/arch/x86_64/mm/mmap.c	2006-01-17 08:22:44.574389036 +0000
@@ -0,0 +1,30 @@
+/* Copyright 2005 Andi Kleen, SuSE Labs.
+ * Licensed under GPL, v.2
+ */
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/random.h>
+#include <asm/ia32.h>
+
+/* Notebook: move the mmap code from sys_x86_64.c over here. */
+
+void arch_pick_mmap_layout(struct mm_struct *mm)
+{
+#ifdef CONFIG_IA32_EMULATION
+	if (current_thread_info()->flags & _TIF_IA32)
+		return ia32_pick_mmap_layout(mm);
+#endif
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+	if (current->flags & PF_RANDOMIZE) {
+		/* Add 28bit randomness which is about 40bits of address space
+		   because mmap base has to be page aligned.
+ 		   or ~1/128 of the total user VM
+	   	   (total user address space is 47bits) */
+		unsigned rnd = get_random_int() & 0xfffffff;
+		mm->mmap_base += ((unsigned long)rnd) << PAGE_SHIFT;
+	}
+	mm->get_unmapped_area = arch_get_unmapped_area;
+	mm->unmap_area = arch_unmap_area;
+}
+
diff -purN linux-2.6.15-git12/block/elevator.c linux-2.6.16-rc1/block/elevator.c
--- linux-2.6.15-git12/block/elevator.c	2006-01-17 08:21:30.495731828 +0000
+++ linux-2.6.16-rc1/block/elevator.c	2006-01-17 08:22:44.605384156 +0000
@@ -149,13 +149,20 @@ static void elevator_setup_default(void)
 	if (!chosen_elevator[0])
 		strcpy(chosen_elevator, CONFIG_DEFAULT_IOSCHED);
 
+	/*
+	 * Be backwards-compatible with previous kernels, so users
+	 * won't get the wrong elevator.
+	 */
+	if (!strcmp(chosen_elevator, "as"))
+		strcpy(chosen_elevator, "anticipatory");
+
  	/*
- 	 * If the given scheduler is not available, fall back to no-op.
+ 	 * If the given scheduler is not available, fall back to the default
  	 */
  	if ((e = elevator_find(chosen_elevator)))
 		elevator_put(e);
 	else
- 		strcpy(chosen_elevator, "noop");
+ 		strcpy(chosen_elevator, CONFIG_DEFAULT_IOSCHED);
 }
 
 static int __init elevator_setup(char *str)
diff -purN linux-2.6.15-git12/drivers/block/ps2esdi.c linux-2.6.16-rc1/drivers/block/ps2esdi.c
--- linux-2.6.15-git12/drivers/block/ps2esdi.c	2006-01-17 08:21:30.727829052 +0000
+++ linux-2.6.16-rc1/drivers/block/ps2esdi.c	2006-01-17 08:22:44.844346531 +0000
@@ -43,6 +43,7 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
+#include <linux/hdreg.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
diff -purN linux-2.6.15-git12/drivers/char/esp.c linux-2.6.16-rc1/drivers/char/esp.c
--- linux-2.6.15-git12/drivers/char/esp.c	2006-01-17 08:21:31.048778518 +0000
+++ linux-2.6.16-rc1/drivers/char/esp.c	2006-01-17 08:22:45.172432801 +0000
@@ -2492,6 +2492,7 @@ static int __init espserial_init(void)
 	}
 
 	memset((void *)info, 0, sizeof(struct esp_struct));
+	spin_lock_init(&info->lock);
 	/* rx_trigger, tx_trigger are needed by autoconfig */
 	info->config.rx_trigger = rx_trigger;
 	info->config.tx_trigger = tx_trigger;
@@ -2528,7 +2529,6 @@ static int __init espserial_init(void)
 		init_waitqueue_head(&info->close_wait);
 		init_waitqueue_head(&info->delta_msr_wait);
 		init_waitqueue_head(&info->break_wait);
-		spin_lock_init(&info->lock);
 		ports = info;
 		printk(KERN_INFO "ttyP%d at 0x%04x (irq = %d) is an ESP ",
 			info->line, info->port, info->irq);
diff -purN linux-2.6.15-git12/drivers/char/rio/brates.h linux-2.6.16-rc1/drivers/char/rio/brates.h
--- linux-2.6.15-git12/drivers/char/rio/brates.h	2006-01-17 08:21:31.188756479 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/brates.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,106 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******		BRATES.H				      *******
- *******                                                              *******
- ****************************************************************************
-
- Author  : Jeremy Rolls
- Date    : 1 Nov 1990
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef _brates_h
-#ifndef lint
-/* static char * _brates_h_sccs = "@(#)brates.h	1.4"; */
-#endif
-#define _brates_h 1
-/* List of baud rate defines. Most are borrowed from /usr/include/sys/termio.h
-*/
-#ifndef INKERNEL
-
-#define	B0	0x00
-#define	B50	0x01
-#define	B75	0x02
-#define	B110	0x03
-#define	B134	0x04
-#define	B150	0x05
-#define	B200	0x06
-#define	B300	0x07
-#define	B600	0x08
-#define	B1200	0x09
-#define	B1800	0x0a
-#define	B2400	0x0b
-#define	B4800	0x0c
-#define	B9600	0x0d
-#define	B19200	0x0e
-#define	B38400	0x0f
-
-#endif
-
-/*
-** The following baudrates may or may not be defined
-** on various UNIX systems.
-** If they are not then we define them.
-** If they are then we do not define them ;-)
-**
-** This is appalling that we use same definitions as UNIX
-** for our own download code as there is no garuntee that
-** B57600 will be defined as 0x11 by a UNIX system....
-** Arghhhhh!!!!!!!!!!!!!!
-*/
-#if !defined(B56000)
-#define	B56000	0x10
-#endif
-
-#if !defined(B57600)
-#define	B57600	0x11
-#endif
-
-#if !defined(B64000)
-#define	B64000	0x12
-#endif
-
-#if !defined(B115200)
-#define	B115200	0x13
-#endif
-
-
-#if !defined(B2000)
-#define B2000	0x14
-#endif
-
-
-#define MAX_RATE B2000
-
-struct baud_rate {		/* Tag for baud rates */
-	/* short    host_rate, *//* As passed by the driver */
-	short divisor,		/* The divisor */
-	 prescaler;		/* The pre-scaler */
-};
-
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/chan.h linux-2.6.16-rc1/drivers/char/rio/chan.h
--- linux-2.6.15-git12/drivers/char/rio/chan.h	2006-01-17 08:21:31.189756322 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/chan.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,33 +0,0 @@
-/*
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#ifndef _chan_h
-#define _chan_h
-
-#ifndef lint
-#ifdef SCCS
-static char *_rio_chan_h_sccs = "@(#)chan.h	1.1";
-#endif
-#endif
-
-#define Link0   0
-#define Link1   1
-#define Link2   2
-#define Link3   3
-
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/cmd.h linux-2.6.16-rc1/drivers/char/rio/cmd.h
--- linux-2.6.15-git12/drivers/char/rio/cmd.h	2006-01-17 08:21:31.196755220 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/cmd.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,83 +0,0 @@
-
-
-/****************************************************************************
- *******                                                              *******
- *******           C O M M A N D   P A C K E T   H E A D E R S
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-
-#ifndef _cmd_h
-#define _cmd_h
-
-#ifndef lint
-#ifdef SCCS
-static char *_rio_cmd_h_sccs = "@(#)cmd.h	1.1";
-#endif
-#endif
-
-
-#define PRE_EMPTIVE_CMD         0x80
-#define INLINE_CMD              ~PRE_EMPTIVE_CMD
-
-#define CMD_IGNORE_PKT          ( (ushort) 0)
-#define CMD_STATUS_REQ          ( (ushort) 1)
-#define CMD_UNIT_STATUS_REQ     ( (ushort) 2)	/* Is this needed ??? */
-#define CMD_CONF_PORT           ( (ushort) 3)
-#define CMD_CONF_UNIT           ( (ushort) 4)
-#define CMD_ROUTE_MAP_REQ       ( (ushort) 5)
-#define CMD_FLUSH_TX            ( (ushort) 6)
-#define CMD_FLUSH_RX            ( (ushort) 7)
-#define CMD_PARTION_PORT        ( (ushort) 8)
-#define CMD_RESET_PORT          ( (ushort) 0x0a)
-#define CMD_BOOT_UNIT           ( (ushort) 0x0b)
-#define CMD_FOUND_UNIT          ( (ushort) 0x0c)
-#define CMD_ATTACHED_RTA_2      ( (ushort) 0x0d)
-#define CMD_PROVIDE_BOOT        ( (ushort) 0x0e)
-#define CMD_CIRRUS              ( (ushort) 0x0f)
-
-#define FORM_STATUS_PKT         ( (ushort) 1 )
-#define FORM_POLL_PKT           ( (ushort) 2 )
-#define FORM_LINK_STATUS_PKT    ( (ushort) 3 )
-
-
-#define CMD_DATA_PORT           ( (ushort) 1 )
-#define CMD_DATA                ( (ushort) 2 )
-
-#define CMD_TX_PART             ( (ushort) 2 )
-#define CMD_RX_PART             ( (ushort) 3 )
-#define CMD_RX_LIMIT            ( (ushort) 4 )
-
-#endif
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/data.h linux-2.6.16-rc1/drivers/char/rio/data.h
--- linux-2.6.15-git12/drivers/char/rio/data.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/data.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,40 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: data.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:09
-**	Retrieved	: 11/6/98 11:34:21
-**
-**  ident @(#)data.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef __rio_datadex__
-#define __rio_datadex__
-
-#ifndef lint
-static char *_data_h_sccs_ = "@(#)data.h	1.2";
-#endif
-
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/debug.h linux-2.6.16-rc1/drivers/char/rio/debug.h
--- linux-2.6.15-git12/drivers/char/rio/debug.h	2006-01-17 08:21:31.205753803 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/debug.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,39 +0,0 @@
-/*
-** File:		debug.h
-**
-** Author:		David Dix
-**
-** Created:		12th March 1993
-**
-** Last modified:	93/04/27
-**
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef _debug_h_
-#define _debug_h_
-
-
-#if defined(DCIRRUS)
-#define	DBPACKET(pkt, opt, str, chn) 	debug_packet((pkt), (opt), (str), (chn))
-#else
-#define	DBPACKET(pkt, opt, str, c)
-#endif				/* DCIRRUS */
-
-
-#endif				/* _debug_h_ */
diff -purN linux-2.6.15-git12/drivers/char/rio/eisa.h linux-2.6.16-rc1/drivers/char/rio/eisa.h
--- linux-2.6.15-git12/drivers/char/rio/eisa.h	2006-01-17 08:21:31.207753488 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/eisa.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,104 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: eisa.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:10
-**	Retrieved	: 11/6/98 11:34:21
-**
-**  ident @(#)eisa.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef __rio_eisa_h__
-#define __rio_eisa_h__
-
-#ifdef SCCS_LABELS
-#ifndef lint
-static char *_eisa_h_sccs_ = "@(#)eisa.h	1.2";
-#endif
-#endif
-
-/*
-** things to do with the EISA bus
-*/
-
-#define RIO_EISA_STRING_ADDRESS 	0xfffd9	/* where EISA is stored */
-
-#define	RIO_MAX_EISA_SLOTS		16	/* how many EISA slots? */
-
-#define	RIO_EISA_IDENT			0x984D	/* Specialix */
-#define	RIO_EISA_PRODUCT_CODE		0x14	/* Code 14 */
-#define	RIO_EISA_ENABLE_BIT		0x01	/* To enable card */
-
-#define	EISA_MEMORY_BASE_LO		0xC00	/* A16-A23 */
-#define	EISA_MEMORY_BASE_HI		0xC01	/* A24-A31 */
-#define	EISA_INTERRUPT_VEC		0xC02	/* see below */
-#define	EISA_CONTROL_PORT		0xC02	/* see below */
-#define	EISA_INTERRUPT_RESET		0xC03	/* read to clear IRQ */
-
-#define	EISA_PRODUCT_IDENT_LO		0xC80	/* where RIO_EISA_IDENT is */
-#define	EISA_PRODUCT_IDENT_HI		0xC81
-#define	EISA_PRODUCT_NUMBER		0xC82	/* where PROD_CODE is */
-#define	EISA_REVISION_NUMBER		0xC83	/* revision (1dp) */
-#define	EISA_ENABLE			0xC84	/* set LSB to enable card */
-#define	EISA_UNIQUE_NUM_0		0xC88	/* vomit */
-#define	EISA_UNIQUE_NUM_1		0xC8A
-#define	EISA_UNIQUE_NUM_2		0xC90	/* bit strangely arranged */
-#define	EISA_UNIQUE_NUM_3		0xC92
-#define	EISA_MANUF_YEAR			0xC98	/* when */
-#define	EISA_MANUF_WEEK			0xC9A	/* more when */
-
-#define	EISA_TP_BOOT_FROM_RAM	0x01
-#define	EISA_TP_BOOT_FROM_LINK	0x00
-#define	EISA_TP_FAST_LINKS	0x02
-#define	EISA_TP_SLOW_LINKS	0x00
-#define	EISA_TP_BUS_ENABLE	0x04
-#define	EISA_TP_BUS_DISABLE	0x00
-#define	EISA_TP_RUN		0x08
-#define	EISA_TP_RESET		0x00
-#define	EISA_POLLED		0x00
-#define	EISA_IRQ_3		0x30
-#define	EISA_IRQ_4		0x40
-#define	EISA_IRQ_5		0x50
-#define	EISA_IRQ_6		0x60
-#define	EISA_IRQ_7		0x70
-#define	EISA_IRQ_9		0x90
-#define	EISA_IRQ_10		0xA0
-#define	EISA_IRQ_11		0xB0
-#define	EISA_IRQ_12		0xC0
-#define	EISA_IRQ_14		0xE0
-#define	EISA_IRQ_15		0xF0
-
-#define	EISA_INTERRUPT_MASK	0xF0
-#define	EISA_CONTROL_MASK	0x0F
-
-#define	RIO_EISA_DEFAULT_MODE	EISA_TP_SLOW_LINKS
-
-#define	RIOEisaToIvec(X)	(uchar )((uchar)((X) & EISA_INTERRUPT_MASK)>>4)
-
-#define	INBZ(z,x)	inb(((z)<<12) | (x))
-#define	OUTBZ(z,x,y)	outb((((z)<<12) | (x)), y)
-
-#endif				/* __rio_eisa_h__ */
diff -purN linux-2.6.15-git12/drivers/char/rio/enable.h linux-2.6.16-rc1/drivers/char/rio/enable.h
--- linux-2.6.15-git12/drivers/char/rio/enable.h	2006-01-17 08:21:31.208753331 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/enable.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,48 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******               E N A B L E   H E A D E R S
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS
-static char *_rio_enable_h_sccs = "@(#)enable.h	1.1";
-#endif
-#endif
-
-
-#define ENABLE_LTT  TRUE
-#define ENABLE_LRT  TRUE
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/formpkt.h linux-2.6.16-rc1/drivers/char/rio/formpkt.h
--- linux-2.6.15-git12/drivers/char/rio/formpkt.h	2006-01-17 08:21:31.212752701 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/formpkt.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,153 +0,0 @@
-
-
-/****************************************************************************
- *******                                                              *******
- *******         F O R M   P A C K E T   H E A D E R   F I L E
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef _formpkt_h
-#define _formpkt_h 1
-
-#ifndef lint
-#ifdef SCCS
-static char *_rio_formpkt_h_sccs = "@(#)formpkt.h	1.1";
-#endif
-#endif
-
-typedef struct FORM_BOOT_PKT_1 FORM_BOOT_PKT_1;
-struct FORM_BOOT_PKT_1 {
-	ushort pkt_number;
-	ushort pkt_total;
-	ushort boot_top;
-};
-
-typedef struct FORM_BOOT_PKT_2 FORM_BOOT_PKT_2;
-struct FORM_BOOT_PKT_2 {
-	ushort pkt_number;
-	char boot_data[10];
-};
-
-
-typedef struct FORM_ATTACH_RTA FORM_ATTACH_RTA;
-struct FORM_ATTACH_RTA {
-	char cmd_code;
-	char booter_serial[4];
-	char booter_link;
-	char bootee_serial[4];
-	char bootee_link;
-};
-
-
-typedef struct FORM_BOOT_ID FORM_BOOT_ID;
-struct FORM_BOOT_ID {
-	char cmd_code;
-	char bootee_serial[4];
-	char bootee_prod_id;
-	char bootee_link;
-};
-
-
-
-typedef struct FORM_ROUTE_1 FORM_ROUTE_1;
-struct FORM_ROUTE_1 {
-	char cmd_code;
-	char pkt_number;
-	char total_in_sequence;
-	char unit_id;
-	char host_unit_id;
-};
-
-typedef struct FORM_ROUTE_2 FORM_ROUTE_2;
-struct FORM_ROUTE_2 {
-	char cmd_code;
-	char pkt_number;
-	char total_in_sequence;
-	char route_data[9];
-};
-
-typedef struct FORM_ROUTE_REQ FORM_ROUTE_REQ;
-struct FORM_ROUTE_REQ {
-	char cmd_code;
-	char pkt_number;
-	char total_in_sequence;
-	char route_data[10];
-};
-
-
-typedef struct FORM_ERROR FORM_ERROR;
-struct FORM_ERROR {
-	char cmd_code;
-	char error_code;
-
-};
-
-typedef struct FORM_STATUS FORM_STATUS;
-struct FORM_STATUS {
-	char cmd_code;
-	char status_code;
-	char last_packet_valid;
-	char tx_buffer;
-	char rx_buffer;
-	char port_status;
-	char phb_status;
-};
-
-
-typedef struct FORM_LINK_STATUS FORM_LINK_STATUS;
-struct FORM_LINK_STATUS {
-	char cmd_code;
-	char status_code;
-	char link_number;
-	ushort rx_errors;
-	ushort tx_errors;
-	ushort csum_errors;
-	ushort disconnects;
-};
-
-
-
-typedef struct FORM_PARTITION FORM_PARTITION;
-struct FORM_PARTITION {
-	char cmd_code;
-	char status_code;
-	char port_number;
-	char tx_max;
-	char rx_max;
-	char rx_limit;
-};
-
-
-#endif
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/hosthw.h linux-2.6.16-rc1/drivers/char/rio/hosthw.h
--- linux-2.6.15-git12/drivers/char/rio/hosthw.h	2006-01-17 08:21:31.218751756 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/hosthw.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******                H O S T      H A R D W A R E
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra / Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_hosthw_h_sccs = "@(#)hosthw.h	1.2";
-#endif
-#endif
-
-#define SET_OTHER_INTERRUPT  ( (volatile u_short *) 0x7c80 )
-#define SET_EISA_INTERRUPT  ( (volatile u_short *) 0x7ef0 )
-
-#define EISA_HOST    0x30
-#define AT_HOST      0xa0
-#define MCA_HOST     0xb0
-#define PCI_HOST     0xd0
-
-#define PRODUCT_MASK 0xf0
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/lrt.h linux-2.6.16-rc1/drivers/char/rio/lrt.h
--- linux-2.6.15-git12/drivers/char/rio/lrt.h	2006-01-17 08:21:31.226750497 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/lrt.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******                      L R T
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra / Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_lrt_h_sccs = "@(#)lrt.h	1.1";
-#endif
-#endif
-
-
-#ifdef DCIRRUS
-#define LRT_STACK       (unsigned short) 600
-#else
-#define LRT_STACK        (ushort) 200
-#endif
-
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/ltt.h linux-2.6.16-rc1/drivers/char/rio/ltt.h
--- linux-2.6.15-git12/drivers/char/rio/ltt.h	2006-01-17 08:21:31.227750339 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/ltt.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******                      L T T
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra / Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_ltt_h_sccs = "@(#)ltt.h	1.1";
-#endif
-#endif
-
-#ifdef DCIRRUS
-#define LTT_STACK       (unsigned short)  600
-#else
-#define LTT_STACK       (ushort) 200
-#endif
-
-
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/lttwake.h linux-2.6.16-rc1/drivers/char/rio/lttwake.h
--- linux-2.6.15-git12/drivers/char/rio/lttwake.h	2006-01-17 08:21:31.228750182 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/lttwake.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
-
-
-
-/****************************************************************************
- *******                                                              *******
- *******            L T T    W A K E U P    H E A D E R
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_lttwake_h_sccs = "@(#)lttwake.h	1.1";
-#endif
-#endif
-
-#define LTT_WAKEUP_STACK          500
-#define LTT_WAKEUP_INTERVAL       (int) (500 * MILLISECOND)
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/mca.h linux-2.6.16-rc1/drivers/char/rio/mca.h
--- linux-2.6.15-git12/drivers/char/rio/mca.h	2006-01-17 08:21:31.230749867 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/mca.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,73 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: mca.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:11
-**	Retrieved	: 11/6/98 11:34:21
-**
-**  ident @(#)mca.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef __rio_mca_h__
-#define	__rio_mca_h__
-
-#ifdef SCCS_LABELS
-static char *_mca_h_sccs_ = "@(#)mca.h	1.2";
-#endif
-
-/*
-** Micro Channel stuff
-*/
-
-#define	McaMaxSlots	8
-#define McaSlotSelect	0x96
-#define	McaSlotEnable	0x08
-#define	McaIdLow	0x100
-#define	McaIdHigh	0x101
-#define	McaIrqEnable	0x102
-#define	McaMemory	0x103
-#define McaRIOId	0x6a5c
-#define	McaIrq9		0x00
-#define	McaIrq3		0x02
-#define	McaIrq4		0x04
-#define	McaIrq7		0x06
-#define	McaIrq10	0x08
-#define	McaIrq11	0x0A
-#define	McaIrq12	0x0C
-#define	McaIrq15	0x0E
-#define McaIrqMask	0x0E
-#define	McaCardEnable	0x01
-#define	McaAddress(X)	(((X)&0xFF)<<16)
-
-#define	McaTpFastLinks	        0x40
-#define	McaTpSlowLinks	        0x00
-#define	McaTpBootFromRam	0x01
-#define	McaTpBootFromLink	0x00
-#define	McaTpBusEnable		0x02
-#define	McaTpBusDisable		0x00
-
-#define	RIO_MCA_DEFAULT_MODE	SLOW_LINKS
-
-#endif				/* __rio_mca_h__ */
diff -purN linux-2.6.15-git12/drivers/char/rio/mesg.h linux-2.6.16-rc1/drivers/char/rio/mesg.h
--- linux-2.6.15-git12/drivers/char/rio/mesg.h	2006-01-17 08:21:31.231749710 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/mesg.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,41 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: mesg.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:12
-**	Retrieved	: 11/6/98 11:34:21
-**
-**  ident @(#)mesg.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef __rio_mesg_h__
-#define	__rio_mesg_h__
-
-#ifdef SCCS_LABELS
-static char *_mesg_h_sccs_ = "@(#)mesg.h	1.2";
-#endif
-
-
-#endif				/* __rio_mesg_h__ */
diff -purN linux-2.6.15-git12/drivers/char/rio/poll.h linux-2.6.16-rc1/drivers/char/rio/poll.h
--- linux-2.6.15-git12/drivers/char/rio/poll.h	2006-01-17 08:21:31.244747663 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/poll.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,73 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******                      P O L L
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra / Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef _poll_h
-#define _poll_h
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_poll_h_sccs = "@(#)poll.h	1.2";
-#endif
-#endif
-
-
-#ifdef HOST
-#define POLL_STACK            100
-#endif
-#ifdef RTA
-#define POLL_STACK            200
-#endif
-
-#define POLL_PERIOD           (int) SECOND
-
-/* The various poll commands */
-#define POLL_POLL             0	/* We are connected and happy.. */
-#define POLL_INTRO            1	/* Introduction packet */
-#define POLL_TOPOLOGY         2	/* Topology update */
-#define POLL_ASSIGN           3	/* ID assign */
-#define POLL_FOAD             4	/* F*** Off And Die */
-#define POLL_LMD	      5	/* Let Me Die */
-#define POLL_DYB	      6	/* Die You Ba***** */
-
-/* The way data fields are split up for POLL packets */
-#define POLL_HOST_SERIAL      2	/* Host who booted me */
-#define POLL_MY_SERIAL        6	/* My serial number */
-#define POLL_YOUR_ID          1	/* Your ID number */
-#define POLL_TOPOLOGY_FIELDS  2	/* Topology maps */
-
-#endif
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/proto.h linux-2.6.16-rc1/drivers/char/rio/proto.h
--- linux-2.6.15-git12/drivers/char/rio/proto.h	2006-01-17 08:21:31.253746246 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/proto.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,244 +0,0 @@
-/*
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-#ifndef	_prototypes_h
-#define _prototypes_h
-
-
-/*
-** boot.c
-*/
-void init_boot(char *p, short stage);
-
-/*
-** disconct.c
-*/
-void kill_boot(LPB * link);
-void disconnected(LPB * link);
-short boot_3(LPB * link, PKT * pkt);
-short send_3_pkt(LPB * link, PKT * pkt);
-
-/*
-** error.c
-*/
-void du_error(void);
-
-/*
-** formpkt.c
-*/
-ushort sum_it(PKT * pkt);
-void form_rup_pkt(RUP * form_rup, PKT * pkt);
-void form_poll_pkt(int type, LPB * link, int node);
-void form_route_pkt(int type, PKT * pkt, LPB * link);
-
-/*
-** idle.c
-*/
-void idle(Process * idle_p);
-
-/*
-** init.c
-*/
-void general_init(void);
-void mem_halt(int error);
-
-/*
-** linkinit.c
-*/
-void initlink(u_short number, LPB * link);
-void runlink(LPB * link);
-
-/*
-** list.c
-*/
-PKT *get_free_start(void);
-void put_free_start(PKT * pkt);
-
-#ifdef HOST
-int can_remove_transmit(PKT ** pkt, PKT * pointer);
-#endif
-
-#ifdef RTA
-int spl7(void);
-int spl0(void);
-Q_BUF *get_free_q(void);
-PKT *get_free_end(void);
-int add_end(PKT * pkt, PHB * phb, int type);
-unsigned short free_packets(PHB * phb, int type);
-int can_remove_start(PKT ** pkt, PHB * phb, int type);
-int can_add_start(PHB * phb, int type);
-int can_add_end(PHB * phb, int type);
-void put_free_end(PKT * pkt);
-int remove_start(PKT ** pkt, PHB * phb, int type);
-#endif
-
-/*
-** Lrt.c
-*/
-void lrt(Process * lrt_p, LPB * link);
-
-#ifdef RTA
-void set_led_red(LPB * link);
-#endif
-
-/*
-** ltt.c
-*/
-void ltt(Process * ltt_p, LPB * link, PHB * phb_ptr[]);
-void send_poll(LPB * link);
-void request_id(LPB * link);
-void send_topology_update(LPB * link);
-void send_topology(LPB * link);
-void supply_id(LPB * link);
-
-#ifdef RTA
-void redirect_queue(LPB * link, ushort flush);
-int obtain_rup(int rup_number, PKT ** pkt_address, LPB * link);
-#endif
-
-#ifdef TESTING_PERF
-int consume_cpu(void);
-#endif
-
-/*
-** lttwake.c
-*/
-#ifdef HOST
-void ltt_wakeup(Process * ltt_wakeup_p);
-#endif
-
-/*
-** mapgen.c
-*/
-void generate_id_map(short mapping, ROUTE_STR route[]);
-void gen_map(int mapping, int looking_at, int come_from, ROUTE_STR route[], int link, int *ttl);
-void adjust_ttl(int mapping, int looking_at, int come_from, ROUTE_STR route[], int link, int *ttl);
-void init_sys_map(void);
-
-/*
-** mmu.c
-*/
-char *rio_malloc(unsigned int amount);
-char *rio_calloc(unsigned int num, unsigned int size);
-ERROR rio_mmu_init(uint total_mem);
-
-/*
-** partn.c
-*/
-void partition_tx(struct PHB *phb, u_short tx_size, u_short rx_size, u_short rx_limit);
-
-/*
-** poll.c
-*/
-void tx_poll(Process * tx_poll_p);
-
-/*
-** process.c
-*/
-int get_proc_space(Process ** pd, int **pws, int wssize);
-
-/*
-** readrom.c
-*/
-void read_serial_number(char *buf);
-
-/*
-** rio.c
-*/
-int main(void);
-
-/*
-** route.c
-*/
-void route_update(PKT * pkt, LPB * link);
-
-/*
-** rtainit.c
-*/
-#if defined(RTA)
-void rta_init(ushort RtaType);
-#endif				/* defined(RTA) */
-
-/*
-** rupboot.c
-*/
-void rup_boot(PKT * pkt, RUP * this_rup, LPB * link);
-
-#ifdef RTA
-void kill_your_neighbour(int link_to_kill);
-#endif
-
-/*
-** rupcmd.c
-*/
-void rup_command(PKT * pkt, struct RUP *this_rup, LPB * link);
-
-/*
-** ruperr.c
-*/
-void rup_error(PKT * pkt, RUP * this_rup, LPB * link);
-void illegal_cmd(PKT * src_pkt);
-
-/*
-** ruppoll.c
-*/
-void rup_poll(PKT * pkt, RUP * this_rup, LPB * link);
-
-/*
-** ruppower.c
-*/
-void rup_power(PKT * pkt, RUP * this_rup, LPB * link);
-
-/*
-** ruprm.c
-*/
-void rup_route_map(PKT * pkt, RUP * this_rup, LPB * link);
-
-/*
-** rupstat.c
-*/
-void rup_status(PKT * pkt, RUP * this_rup, LPB * link);
-
-/*
-** rupsync.c
-*/
-void rup_sync(PKT * pkt);
-
-/*
-** rxpkt.c
-*/
-ERROR rx_pkt(PKT_ptr_ptr pkt_address, LPB * link);
-
-/*
-** sendsts.c
-*/
-void send_status(PKT * requesting_pkt, RUP * this_rup);
-
-/*
-** serial.c
-*/
-void assign_serial(char *ser_in, char *ser_out);
-int cmp_serial(char *ser_1, char *ser_2);
-
-/*
-** txpkt.c
-*/
-ERROR tx_pkt(PKT * pkt, LPB * link);
-short send_sync(LPB * link);
-
-#endif				/* _prototypes_h */
diff -purN linux-2.6.15-git12/drivers/char/rio/rio_linux.c linux-2.6.16-rc1/drivers/char/rio/rio_linux.c
--- linux-2.6.15-git12/drivers/char/rio/rio_linux.c	2006-01-17 08:21:31.277742468 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rio_linux.c	2006-01-17 08:22:45.415394546 +0000
@@ -132,16 +132,6 @@ more than 512 ports.... */
 */
 #define IRQ_RATE_LIMIT 200
 
-#if 0
-/* Not implemented */
-/* 
- * The following defines are mostly for testing purposes. But if you need
- * some nice reporting in your syslog, you can define them also.
- */
-#define RIO_REPORT_FIFO
-#define RIO_REPORT_OVERRUN
-#endif
-
 
 /* These constants are derived from SCO Source */
 static struct Conf
@@ -573,21 +563,6 @@ static void rio_shutdown_port(void *ptr)
 
 	PortP = (struct Port *) ptr;
 	PortP->gs.tty = NULL;
-#if 0
-	port->gs.flags &= ~GS_ACTIVE;
-	if (!port->gs.tty) {
-		rio_dprintk(RIO_DBUG_TTY, "No tty.\n");
-		return;
-	}
-	if (!port->gs.tty->termios) {
-		rio_dprintk(RIO_DEBUG_TTY, "No termios.\n");
-		return;
-	}
-	if (port->gs.tty->termios->c_cflag & HUPCL) {
-		rio_setsignals(port, 0, 0);
-	}
-#endif
-
 	func_exit();
 }
 
@@ -663,11 +638,6 @@ static int rio_ioctl(struct tty_struct *
 
 	rc = 0;
 	switch (cmd) {
-#if 0
-	case TIOCGSOFTCAR:
-		rc = put_user(((tty->termios->c_cflag & CLOCAL) ? 1 : 0), (unsigned int *) arg);
-		break;
-#endif
 	case TIOCSSOFTCAR:
 		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
 			tty->termios->c_cflag = (tty->termios->c_cflag & ~CLOCAL) | (ival ? CLOCAL : 0);
@@ -709,36 +679,6 @@ static int rio_ioctl(struct tty_struct *
 		if (access_ok(VERIFY_READ, (void *) arg, sizeof(struct serial_struct)))
 			rc = gs_setserial(&PortP->gs, (struct serial_struct *) arg);
 		break;
-#if 0
-		/*
-		 * note: these IOCTLs no longer reach here.  Use
-		 * tiocmset/tiocmget driver methods instead.  The
-		 * #if 0 disablement predates this comment.
-		 */
-	case TIOCMGET:
-		rc = -EFAULT;
-		if (access_ok(VERIFY_WRITE, (void *) arg, sizeof(unsigned int))) {
-			rc = 0;
-			ival = rio_getsignals(port);
-			put_user(ival, (unsigned int *) arg);
-		}
-		break;
-	case TIOCMBIS:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			rio_setsignals(port, ((ival & TIOCM_DTR) ? 1 : -1), ((ival & TIOCM_RTS) ? 1 : -1));
-		}
-		break;
-	case TIOCMBIC:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			rio_setsignals(port, ((ival & TIOCM_DTR) ? 0 : -1), ((ival & TIOCM_RTS) ? 0 : -1));
-		}
-		break;
-	case TIOCMSET:
-		if ((rc = get_user(ival, (unsigned int *) arg)) == 0) {
-			rio_setsignals(port, ((ival & TIOCM_DTR) ? 1 : 0), ((ival & TIOCM_RTS) ? 1 : 0));
-		}
-		break;
-#endif
 	default:
 		rc = -ENOIOCTLCMD;
 		break;
diff -purN linux-2.6.15-git12/drivers/char/rio/rioboot.c linux-2.6.16-rc1/drivers/char/rio/rioboot.c
--- linux-2.6.15-git12/drivers/char/rio/rioboot.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rioboot.c	2006-01-17 08:22:45.427392657 +0000
@@ -665,13 +665,6 @@ struct PKT *PacketP; 
 	struct CmdBlk *CmdBlkP;
 	uint sequence;
 
-#ifdef CHECK
-	CheckHost(Host);
-	CheckRup(Rup);
-	CheckHostP(HostP);
-	CheckPacketP(PacketP);
-#endif
-
 	/*
 	** If we haven't been told what to boot, we can't boot it.
 	*/
@@ -956,11 +949,6 @@ static int RIOBootComplete( struct rio_i
 	    MyType = "RTA";
 	    MyName = HostP->Mapping[Rup].Name;
 	}
-#ifdef CHECK
-	CheckString(MyType);
-	CheckString(MyName);
-#endif
-
 	MyLink = RBYTE(PktCmdP->LinkNum);
 
 	/*
@@ -1309,52 +1297,3 @@ struct Host *HostP;
 	}
 }
 
-#if 0
-/*
-	Function:	This function is to disable the disk interrupt 
-    Returns :   Nothing
-*/
-void
-disable_interrupt(vector)
-int	vector;
-{
-	int	ps;
-	int	val;
-
-	disable(ps);
-	if (vector > 40)  {
-		val = 1 << (vector - 40);
-		__outb(S8259+1, __inb(S8259+1) | val);
-	}
-	else {
-		val = 1 << (vector - 32);
-		__outb(M8259+1, __inb(M8259+1) | val);
-	}
-	restore(ps);
-}
-
-/*
-	Function:	This function is to enable the disk interrupt 
-    Returns :   Nothing
-*/
-void
-enable_interrupt(vector)
-int	vector;
-{
-	int	ps;
-	int	val;
-
-	disable(ps);
-	if (vector > 40)  {
-		val = 1 << (vector - 40);
-		val = ~val;
-		__outb(S8259+1, __inb(S8259+1) & val);
-	}
-	else {
-		val = 1 << (vector - 32);
-		val = ~val;
-		__outb(M8259+1, __inb(M8259+1) & val);
-	}
-	restore(ps);
-}
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/riocmd.c linux-2.6.16-rc1/drivers/char/rio/riocmd.c
--- linux-2.6.15-git12/drivers/char/rio/riocmd.c	2006-01-17 08:21:31.302738533 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riocmd.c	2006-01-17 08:22:45.444389981 +0000
@@ -387,12 +387,6 @@ static int RIOCommandRup(struct rio_info
 
 	func_enter();
 
-#ifdef CHECK
-	CheckHost(Host);
-	CheckHostP(HostP);
-	CheckPacketP(PacketP);
-#endif
-
 	/*
 	 ** 16 port RTA note:
 	 ** Command rup packets coming from the RTA will have pkt->data[1] (which
@@ -406,10 +400,6 @@ static int RIOCommandRup(struct rio_info
 	SysPort = UnixRupP->BaseSysPort + (RBYTE(PktCmdP->PhbNum) % (ushort) PORTS_PER_RTA);
 	rio_dprintk(RIO_DEBUG_CMD, "Command on rup %d, port %d\n", rup, SysPort);
 
-#ifdef CHECK
-	CheckRup(rup);
-	CheckUnixRupP(UnixRupP);
-#endif
 	if (UnixRupP->BaseSysPort == NO_PORT) {
 		rio_dprintk(RIO_DEBUG_CMD, "OBSCURE ERROR!\n");
 		rio_dprintk(RIO_DEBUG_CMD, "Diagnostics follow. Please WRITE THESE DOWN and report them to Specialix Technical Support\n");
@@ -429,9 +419,6 @@ static int RIOCommandRup(struct rio_info
 		rio_dprintk(RIO_DEBUG_CMD, "COMMAND information: Host Port Number 0x%x, " "Command Code 0x%x\n", PktCmdP->PhbNum, PktCmdP->Command);
 		return TRUE;
 	}
-#ifdef CHECK
-	CheckSysPort(SysPort);
-#endif
 	PortP = p->RIOPortp[SysPort];
 	rio_spin_lock_irqsave(&PortP->portSem, flags);
 	switch (RBYTE(PktCmdP->Command)) {
@@ -604,11 +591,6 @@ int RIOQueueCmdBlk(struct Host *HostP, u
 	struct UnixRup *UnixRupP;
 	unsigned long flags;
 
-#ifdef CHECK
-	CheckHostP(HostP);
-	CheckRup(Rup);
-	CheckCmdBlkP(CmdBlkP);
-#endif
 	if (Rup >= (ushort) (MAX_RUP + LINKS_PER_UNIT)) {
 		rio_dprintk(RIO_DEBUG_CMD, "Illegal rup number %d in RIOQueueCmdBlk\n", Rup);
 		RIOFreeCmdBlk(CmdBlkP);
@@ -806,9 +788,6 @@ void RIOPollHostCommands(struct rio_info
 			 ** If it returns RIO_FAIL then don't
 			 ** send this command yet!
 			 */
-#ifdef CHECK
-			CheckCmdBlkP(CmdBlkP);
-#endif
 			if (!(CmdBlkP->PreFuncP ? (*CmdBlkP->PreFuncP) (CmdBlkP->PreArg, CmdBlkP) : TRUE)) {
 				rio_dprintk(RIO_DEBUG_CMD, "Not ready to start command 0x%x\n", (int) CmdBlkP);
 			} else {
@@ -816,9 +795,6 @@ void RIOPollHostCommands(struct rio_info
 				/*
 				 ** Whammy! blat that pack!
 				 */
-#ifdef CHECK
-				CheckPacketP((PKT *) RIO_PTR(HostP->Caddr, UnixRupP->RupP->txpkt));
-#endif
 				HostP->Copy((caddr_t) & CmdBlkP->Packet, RIO_PTR(HostP->Caddr, UnixRupP->RupP->txpkt), sizeof(PKT));
 
 				/*
@@ -852,9 +828,6 @@ int RIOWFlushMark(int iPortP, struct Cmd
 	unsigned long flags;
 
 	rio_spin_lock_irqsave(&PortP->portSem, flags);
-#ifdef CHECK
-	CheckPortP(PortP);
-#endif
 	PortP->WflushFlag++;
 	PortP->MagicFlags |= MAGIC_FLUSH;
 	rio_spin_unlock_irqrestore(&PortP->portSem, flags);
@@ -894,9 +867,6 @@ int RIOUnUse(int iPortP, struct CmdBlk *
 
 	rio_spin_lock_irqsave(&PortP->portSem, flags);
 
-#ifdef CHECK
-	CheckPortP(PortP);
-#endif
 	rio_dprintk(RIO_DEBUG_CMD, "Decrement in use count for port\n");
 
 	if (PortP->InUse) {
diff -purN linux-2.6.15-git12/drivers/char/rio/rioctrl.c linux-2.6.16-rc1/drivers/char/rio/rioctrl.c
--- linux-2.6.15-git12/drivers/char/rio/rioctrl.c	2006-01-17 08:21:31.340732551 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rioctrl.c	2006-01-17 08:22:45.482383998 +0000
@@ -308,12 +308,7 @@ int su;
 		}
 
 	case RIO_DEBUG_MEM:
-#ifdef DEBUG_MEM_SUPPORT
-		RIO_DEBUG_CTRL, if (su)
-			return rio_RIODebugMemory(RIO_DEBUG_CTRL, arg);
-		else
-#endif
-			return -EPERM;
+		return -EPERM;
 
 	case RIO_ALL_MODEM:
 		rio_dprintk(RIO_DEBUG_CTRL, "RIO_ALL_MODEM\n");
@@ -591,12 +586,7 @@ int su;
 
 	case RIO_GET_LOG:
 		rio_dprintk(RIO_DEBUG_CTRL, "RIO_GET_LOG\n");
-#ifdef LOGGING
-		RIOGetLog(arg);
-		return 0;
-#else
 		return -EINVAL;
-#endif
 
 	case RIO_GET_MODTYPE:
 		if (copyin((int) arg, (caddr_t) & port, sizeof(uint)) == COPYFAIL) {
@@ -684,52 +674,6 @@ int su;
 		rio_dprintk(RIO_DEBUG_CTRL, "entering loop (%d %d)!\n", PortSetup.From, PortSetup.To);
 		for (loop = PortSetup.From; loop <= PortSetup.To; loop++) {
 			rio_dprintk(RIO_DEBUG_CTRL, "in loop (%d)!\n", loop);
-#if 0
-			PortP = p->RIOPortp[loop];
-			if (!PortP->TtyP)
-				PortP->TtyP = &p->channel[loop];
-
-			rio_spin_lock_irqsave(&PortP->portSem, flags);
-			if (PortSetup.IxAny)
-				PortP->Config |= RIO_IXANY;
-			else
-				PortP->Config &= ~RIO_IXANY;
-			if (PortSetup.IxOn)
-				PortP->Config |= RIO_IXON;
-			else
-				PortP->Config &= ~RIO_IXON;
-
-			/*
-			 ** If the port needs to wait for all a processes output
-			 ** to drain before closing then this flag will be set.
-			 */
-			if (PortSetup.Drain) {
-				PortP->Config |= RIO_WAITDRAIN;
-			} else {
-				PortP->Config &= ~RIO_WAITDRAIN;
-			}
-			/*
-			 ** Store settings if locking or unlocking port or if the
-			 ** port is not locked, when setting the store option.
-			 */
-			if (PortP->Mapped && ((PortSetup.Lock && !PortP->Lock) || (!PortP->Lock && (PortSetup.Store && !PortP->Store)))) {
-				PortP->StoredTty.iflag = PortP->TtyP->tm.c_iflag;
-				PortP->StoredTty.oflag = PortP->TtyP->tm.c_oflag;
-				PortP->StoredTty.cflag = PortP->TtyP->tm.c_cflag;
-				PortP->StoredTty.lflag = PortP->TtyP->tm.c_lflag;
-				PortP->StoredTty.line = PortP->TtyP->tm.c_line;
-				bcopy(PortP->TtyP->tm.c_cc, PortP->StoredTty.cc, NCC + 5);
-			}
-			PortP->Lock = PortSetup.Lock;
-			PortP->Store = PortSetup.Store;
-			PortP->Xprint.XpCps = PortSetup.XpCps;
-			bcopy(PortSetup.XpOn, PortP->Xprint.XpOn, MAX_XP_CTRL_LEN);
-			bcopy(PortSetup.XpOff, PortP->Xprint.XpOff, MAX_XP_CTRL_LEN);
-			PortP->Xprint.XpOn[MAX_XP_CTRL_LEN - 1] = '\0';
-			PortP->Xprint.XpOff[MAX_XP_CTRL_LEN - 1] = '\0';
-			PortP->Xprint.XpLen = RIOStrlen(PortP->Xprint.XpOn) + RIOStrlen(PortP->Xprint.XpOff);
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-#endif
 		}
 		rio_dprintk(RIO_DEBUG_CTRL, "after loop (%d)!\n", loop);
 		rio_dprintk(RIO_DEBUG_CTRL, "Retval:%x\n", retval);
@@ -801,12 +745,6 @@ int su;
 
 		rio_dprintk(RIO_DEBUG_CTRL, "Port %d\n", PortTty.port);
 		PortP = (p->RIOPortp[PortTty.port]);
-#if 0
-		PortTty.Tty.tm.c_iflag = PortP->TtyP->tm.c_iflag;
-		PortTty.Tty.tm.c_oflag = PortP->TtyP->tm.c_oflag;
-		PortTty.Tty.tm.c_cflag = PortP->TtyP->tm.c_cflag;
-		PortTty.Tty.tm.c_lflag = PortP->TtyP->tm.c_lflag;
-#endif
 		if (copyout((caddr_t) & PortTty, (int) arg, sizeof(struct PortTty)) == COPYFAIL) {
 			p->RIOError.Error = COPYOUT_FAILED;
 			return -EFAULT;
@@ -824,15 +762,6 @@ int su;
 			return -ENXIO;
 		}
 		PortP = (p->RIOPortp[PortTty.port]);
-#if 0
-		rio_spin_lock_irqsave(&PortP->portSem, flags);
-		PortP->TtyP->tm.c_iflag = PortTty.Tty.tm.c_iflag;
-		PortP->TtyP->tm.c_oflag = PortTty.Tty.tm.c_oflag;
-		PortP->TtyP->tm.c_cflag = PortTty.Tty.tm.c_cflag;
-		PortP->TtyP->tm.c_lflag = PortTty.Tty.tm.c_lflag;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-#endif
-
 		RIOParam(PortP, CONFIG, PortP->State & RIO_MODEM, OK_TO_SLEEP);
 		return retval;
 
@@ -909,23 +838,6 @@ int su;
 		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
 		return retval;
 
-#ifdef DEBUG_SUPPORTED
-	case RIO_READ_LEVELS:
-		{
-			int num;
-			rio_dprintk(RIO_DEBUG_CTRL, "RIO_READ_LEVELS\n");
-			for (num = 0; RIODbInf[num].Flag; num++);
-			rio_dprintk(RIO_DEBUG_CTRL, "%d levels to copy\n", num);
-			if (copyout((caddr_t) RIODbInf, (int) arg, sizeof(struct DbInf) * (num + 1)) == COPYFAIL) {
-				rio_dprintk(RIO_DEBUG_CTRL, "ReadLevels Copy failed\n");
-				p->RIOError.Error = COPYOUT_FAILED;
-				return -EFAULT;
-			}
-			rio_dprintk(RIO_DEBUG_CTRL, "%d levels to copied\n", num);
-			return retval;
-		}
-#endif
-
 	case RIO_READ_CONFIG:
 		rio_dprintk(RIO_DEBUG_CTRL, "RIO_READ_CONFIG\n");
 		if (copyout((caddr_t) & p->RIOConf, (int) arg, sizeof(struct Conf)) == COPYFAIL) {
@@ -1084,30 +996,13 @@ int su;
 			(void) RIOBoardTest(p->RIOHosts[Host].PaddrP, p->RIOHosts[Host].Caddr, p->RIOHosts[Host].Type, p->RIOHosts[Host].Slot);
 			bzero((caddr_t) & p->RIOHosts[Host].Flags, ((int) &p->RIOHosts[Host].____end_marker____) - ((int) &p->RIOHosts[Host].Flags));
 			p->RIOHosts[Host].Flags = RC_WAITING;
-#if 0
-			RIOSetupDataStructs(p);
-#endif
 		}
 		RIOFoadWakeup(p);
 		p->RIONumBootPkts = 0;
 		p->RIOBooting = 0;
-
-#ifdef RINGBUFFER_SUPPORT
-		for (loop = 0; loop < RIO_PORTS; loop++)
-			if (p->RIOPortp[loop]->TxRingBuffer)
-				sysfree((void *) p->RIOPortp[loop]->TxRingBuffer, RIOBufferSize);
-#endif
-#if 0
-		bzero((caddr_t) & p->RIOPortp[0], RIO_PORTS * sizeof(struct Port));
-#else
 		printk("HEEEEELP!\n");
-#endif
 
 		for (loop = 0; loop < RIO_PORTS; loop++) {
-#if 0
-			p->RIOPortp[loop]->TtyP = &p->channel[loop];
-#endif
-
 			spin_lock_init(&p->RIOPortp[loop]->portSem);
 			p->RIOPortp[loop]->InUse = NOT_INUSE;
 		}
@@ -1653,10 +1548,6 @@ uchar Cmd;
 	ushort rup;
 	int port;
 
-#ifdef CHECK
-	CheckPortP(PortP);
-#endif
-
 	if (PortP->State & RIO_DELETED) {
 		rio_dprintk(RIO_DEBUG_CTRL, "Preemptive command to deleted RTA ignored\n");
 		return RIO_FAIL;
diff -purN linux-2.6.15-git12/drivers/char/rio/rioinit.c linux-2.6.16-rc1/drivers/char/rio/rioinit.c
--- linux-2.6.15-git12/drivers/char/rio/rioinit.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rioinit.c	2006-01-17 08:22:45.500381165 +0000
@@ -87,222 +87,8 @@ static char *_rioinit_c_sccs_ = "@(#)rio
 
 int RIOPCIinit(struct rio_info *p, int Mode);
 
-#if 0
-static void RIOAllocateInterrupts(struct rio_info *);
-static int RIOReport(struct rio_info *);
-static void RIOStopInterrupts(struct rio_info *, int, int);
-#endif
-
 static int RIOScrub(int, BYTE *, int);
 
-#if 0
-extern int	rio_intr();
-
-/*
-**	Init time code.
-*/
-void
-rioinit( p, info )
-struct rio_info		* p;
-struct RioHostInfo	* info;
-{
-	/*
-	** Multi-Host card support - taking the easy way out - sorry !
-	** We allocate and set up the Host and Port structs when the
-	** driver is called to 'install' the first host.
-	** We check for this first 'call' by testing the RIOPortp pointer.
-	*/
-	if ( !p->RIOPortp )
-	{
-		rio_dprintk (RIO_DEBUG_INIT,  "Allocating and setting up driver data structures\n");
-
-		RIOAllocDataStructs(p);		/* allocate host/port structs */
-		RIOSetupDataStructs(p);		/* setup topology structs */
-	}
-
-	RIOInitHosts( p, info );	/* hunt down the hardware */
-
-	RIOAllocateInterrupts(p);	/* allocate interrupts */
-	RIOReport(p);			/* show what we found */
-}
-
-/*
-** Initialise the Cards 
-*/ 
-void
-RIOInitHosts(p, info)
-struct rio_info		* p;
-struct RioHostInfo	* info;
-{
-/*
-** 15.10.1998 ARG - ESIL 0762 part fix
-** If there is no ISA card definition - we always look for PCI cards.
-** As we currently only support one host card this lets an ISA card
-** definition take precedence over PLUG and PLAY.
-** No ISA card - we are PLUG and PLAY with PCI.
-*/
-
-	/*
-	** Note - for PCI both these will be zero, that's okay because
-	** RIOPCIInit() fills them in if a card is found.
-	*/
-	p->RIOHosts[p->RIONumHosts].Ivec	= info->vector;
-	p->RIOHosts[p->RIONumHosts].PaddrP	= info->location;
-
-	/*
-	** Check that we are able to accommodate another host
-	*/
-	if ( p->RIONumHosts >= RIO_HOSTS )
-	{
-		p->RIOFailed++;
-		return;
-	}
-
-	if ( info->bus & ISA_BUS )
-	{
-		rio_dprintk (RIO_DEBUG_INIT,  "initialising card %d (ISA)\n", p->RIONumHosts);
-		RIOISAinit(p, p->mode);
-	}
-	else
-	{
-		rio_dprintk (RIO_DEBUG_INIT,  "initialising card %d (PCI)\n", p->RIONumHosts);
-		RIOPCIinit(p, RIO_PCI_DEFAULT_MODE);
-	}
-
-	rio_dprintk (RIO_DEBUG_INIT,  "Total hosts initialised so far : %d\n", p->RIONumHosts);
-
-
-#ifdef FUTURE_RELEASE
-	if (p->bus & EISA_BUS)
-		/* EISA card */
-		RIOEISAinit(p, RIO_EISA_DEFAULT_MODE);
-
-	if (p->bus & MCA_BUS)
-		/* MCA card */
-		RIOMCAinit(p, RIO_MCA_DEFAULT_MODE);
-#endif
-}
-
-/*
-** go through memory for an AT host that we pass in the device info
-** structure and initialise
-*/
-void
-RIOISAinit(p, mode)
-struct rio_info *	p;
-int					mode;
-{
-
-  /* XXX Need to implement this. */
-#if 0
-	p->intr_tid = iointset(p->RIOHosts[p->RIONumHosts].Ivec,
-					(int (*)())rio_intr, (char*)p->RIONumHosts);
-
-	rio_dprintk (RIO_DEBUG_INIT,  "Set interrupt handler, intr_tid = 0x%x\n", p->intr_tid );
-
-	if (RIODoAT(p, p->RIOHosts[p->RIONumHosts].PaddrP, mode)) {
-		return;
-	}
-	else {
-		rio_dprintk (RIO_DEBUG_INIT, "RIODoAT failed\n");
-		p->RIOFailed++;
-	}
-#endif
-
-}
-
-/*
-** RIODoAT :
-**
-** Map in a boards physical address, check that the board is there,
-** test the board and if everything is okay assign the board an entry
-** in the Rio Hosts structure.
-*/
-int
-RIODoAT(p, Base, mode)
-struct rio_info *	p;
-int		Base;
-int		mode;
-{
-#define	FOUND		1
-#define NOT_FOUND	0
-
-	caddr_t		cardAddr;
-
-	/*
-	** Check to see if we actually have a board at this physical address.
-	*/
-	if ((cardAddr = RIOCheckForATCard(Base)) != 0) {
-		/*
-		** Now test the board to see if it is working.
-		*/
-		if (RIOBoardTest(Base, cardAddr, RIO_AT, 0) == RIO_SUCCESS) {
-			/*
-			** Fill out a slot in the Rio host structure.
-			*/
-			if (RIOAssignAT(p, Base, cardAddr, mode)) {
-				return(FOUND);
-			}
-		}
-		RIOMapout(Base, RIO_AT_MEM_SIZE, cardAddr);
-	}
-	return(NOT_FOUND);
-}
-
-caddr_t
-RIOCheckForATCard(Base)
-int		Base;
-{
-	int				off;
-	struct DpRam	*cardp;		/* (Points at the host) */
-	caddr_t			virtAddr;
-	unsigned char			RIOSigTab[24];
-/*
-** Table of values to search for as prom signature of a host card
-*/
-	strcpy(RIOSigTab, "JBJGPGGHINSMJPJR");
-
-	/*
-	** Hey! Yes, You reading this code! Yo, grab a load a this:
-	**
-	** IF the card is using WORD MODE rather than BYTE MODE
-	** then it will occupy 128K of PHYSICAL memory area. So,
-	** you might think that the following Mapin is wrong. Well,
-	** it isn't, because the SECOND 64K of occupied space is an
-	** EXACT COPY of the FIRST 64K. (good?), so, we need only
-	** map it in in one 64K block.
-	*/
-	if (RIOMapin(Base, RIO_AT_MEM_SIZE, &virtAddr) == -1) {
-		rio_dprintk (RIO_DEBUG_INIT, "RIO-init: Couldn't map the board in!\n");
-		return((caddr_t)0);
-	}
-
-	/*
-	** virtAddr points to the DP ram of the system.
-	** We now cast this to a pointer to a RIO Host,
-	** and have a rummage about in the PROM.
-	*/
-	cardp = (struct DpRam *)virtAddr;
-
-	for (off=0; RIOSigTab[off]; off++) {
-		if ((RBYTE(cardp->DpSignature[off]) & 0xFF) != RIOSigTab[off]) {
-			/*
-			** Signature mismatch - card not at this address
-			*/
-			RIOMapout(Base, RIO_AT_MEM_SIZE, virtAddr);
-			rio_dprintk (RIO_DEBUG_INIT, "RIO-init: Couldn't match the signature 0x%x 0x%x!\n",
-						(int)cardp, off);
-			return((caddr_t)0);
-		}
-	}
-
-	/*
-	** If we get here then we must have found a valid board so return
-	** its virtual address.
-	*/
-	return(virtAddr);
-}
-#endif
 
 /**
 ** RIOAssignAT :
@@ -367,667 +153,6 @@ int		mode;
 	rio_dprintk (RIO_DEBUG_INIT, "RIO-init: Tests Passed at 0x%x\n", Base);
 	return(1);
 }
-#if 0
-#ifdef FUTURE_RELEASE
-int RIOMCAinit(int Mode)
-{
-	uchar SlotNumber;
-	caddr_t Caddr;
-	uint	Paddr;
-	uint	Ivec;
-	int	 Handle;
-	int	 ret = 0;
-
-	/*
-	** Valid mode information for MCA cards
-	** is only FAST LINKS
-	*/
-	Mode = (Mode & FAST_LINKS) ? McaTpFastLinks : McaTpSlowLinks;
-	rio_dprintk (RIO_DEBUG_INIT, "RIOMCAinit(%d)\n",Mode);
-
-
-	/*
-	** Check out each of the slots
-	*/
-	for (SlotNumber = 0; SlotNumber < McaMaxSlots; SlotNumber++) {
-	/*
-	** Enable the slot we want to talk to
-	*/
-	outb( McaSlotSelect, SlotNumber | McaSlotEnable );
-
-	/*
-	** Read the ID word from the slot
-	*/
-	if (((inb(McaIdHigh)<< 8)|inb(McaIdLow)) == McaRIOId)
-	{
-		rio_dprintk (RIO_DEBUG_INIT, "Potential MCA card in slot %d\n", SlotNumber);
-
-		/*
-		** Card appears to be a RIO MCA card!
-		*/
-		RIOMachineType |= (1<<RIO_MCA);
-
-		/*
-		** Just check we haven't found too many wonderful objects
-		*/
-		if ( RIONumHosts >= RIO_HOSTS )
-		{
-		Rprintf(RIOMesgTooManyCards);
-		return(ret);
-		}
-
-		/*
-		** McaIrqEnable contains the interrupt vector, and a card
-		** enable bit.
-		*/
-		Ivec = inb(McaIrqEnable);
-
-		rio_dprintk (RIO_DEBUG_INIT, "Ivec is %x\n", Ivec);
-
-		switch ( Ivec & McaIrqMask )
-		{
-		case McaIrq9:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ9\n");
-		break;
-		case McaIrq3:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ3\n");
-		break;
-		case McaIrq4:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ4\n");
-		break;
-		case McaIrq7:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ7\n");
-		break;
-		case McaIrq10:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ10\n");
-		break;
-		case McaIrq11:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ11\n");
-		break;
-		case McaIrq12:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ12\n");
-		break;
-		case McaIrq15:
-		rio_dprintk (RIO_DEBUG_INIT, "IRQ15\n");
-		break;
-		}
-
-		/*
-		** If the card enable bit isn't set, then set it!
-		*/
-		if ((Ivec & McaCardEnable) != McaCardEnable) {
-			rio_dprintk (RIO_DEBUG_INIT, "McaCardEnable not set - setting!\n");
-			outb(McaIrqEnable,Ivec|McaCardEnable);
-		} else
-			rio_dprintk (RIO_DEBUG_INIT, "McaCardEnable already set\n");
-
-		/*
-		** Convert the IRQ enable mask into something useful
-		*/
-		Ivec = RIOMcaToIvec[Ivec & McaIrqMask];
-
-		/*
-		** Find the physical address
-		*/
-		rio_dprintk (RIO_DEBUG_INIT, "inb(McaMemory) is %x\n", inb(McaMemory));
-		Paddr = McaAddress(inb(McaMemory));
-
-		rio_dprintk (RIO_DEBUG_INIT, "MCA card has Ivec %d Addr %x\n", Ivec, Paddr);
-
-		if ( Paddr != 0 )
-		{
-
-		/*
-		** Tell the memory mapper that we want to talk to it
-		*/
-		Handle = RIOMapin( Paddr, RIO_MCA_MEM_SIZE, &Caddr );
-
-		if ( Handle == -1 ) {
-			rio_dprintk (RIO_DEBUG_INIT, "Couldn't map %d bytes at %x\n", RIO_MCA_MEM_SIZE, Paddr;
-			continue;
-		}
-
-		rio_dprintk (RIO_DEBUG_INIT, "Board mapped to vaddr 0x%x\n", Caddr);
-
-		/*
-		** And check that it is actually there!
-		*/
-		if ( RIOBoardTest( Paddr,Caddr,RIO_MCA,SlotNumber ) == RIO_SUCCESS )
-		{
-			rio_dprintk (RIO_DEBUG_INIT, "Board has passed test\n");
-			rio_dprintk (RIO_DEBUG_INIT, "Slot %d. Type %d. Paddr 0x%x. Caddr 0x%x. Mode 0x%x.\n",
-			                            SlotNumber, RIO_MCA, Paddr, Caddr, Mode);
-
-			/*
-			** Board has passed its scrub test. Fill in all the
-			** transient stuff.
-			*/
-			p->RIOHosts[RIONumHosts].Slot	 = SlotNumber;
-			p->RIOHosts[RIONumHosts].Ivec	 = Ivec;
-			p->RIOHosts[RIONumHosts].Type	 = RIO_MCA;
-			p->RIOHosts[RIONumHosts].Copy	 = bcopy;
-			p->RIOHosts[RIONumHosts].PaddrP   = Paddr;
-			p->RIOHosts[RIONumHosts].Caddr	= Caddr;
-			p->RIOHosts[RIONumHosts].CardP	= (struct DpRam *)Caddr;
-			p->RIOHosts[RIONumHosts].Mode	 = Mode;
-			WBYTE(p->RIOHosts[p->RIONumHosts].ResetInt , 0xff);
-			p->RIOHosts[RIONumHosts].UniqueNum =
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[0])&0xFF)<<0)|
-						((RBYTE(p->RIOHosts[RIONumHosts].Unique[1])&0xFF)<<8)|
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[2])&0xFF)<<16)|
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[3])&0xFF)<<24);
-			RIONumHosts++;
-			ret++;
-		}
-		else
-		{
-			/*
-			** It failed the test, so ignore it.
-			*/
-			rio_dprintk (RIO_DEBUG_INIT, "TEST FAILED\n");
-			RIOMapout(Paddr, RIO_MCA_MEM_SIZE, Caddr );
-		}
-		}
-		else
-		{
-		rio_dprintk (RIO_DEBUG_INIT, "Slot %d - Paddr zero!\n", SlotNumber);
-		}
-	}
-	else
-	{
-		rio_dprintk (RIO_DEBUG_INIT, "Slot %d NOT RIO\n", SlotNumber);
-	}
-	}
-	/*
-	** Now we have checked all the slots, turn off the MCA slot selector
-	*/
-	outb(McaSlotSelect,0);
-	rio_dprintk (RIO_DEBUG_INIT, "Slot %d NOT RIO\n", SlotNumber);
-	return ret;
-}
-
-int RIOEISAinit( int Mode )
-{
-	static int EISADone = 0;
-	uint Paddr;
-	int PollIntMixMsgDone = 0;
-	caddr_t Caddr;
-	ushort Ident;
-	uchar EisaSlot;
-	uchar Ivec;
-	int ret = 0;
-
-	/*
-	** The only valid mode information for EISA hosts is fast or slow
-	** links.
-	*/
-	Mode = (Mode & FAST_LINKS) ? EISA_TP_FAST_LINKS : EISA_TP_SLOW_LINKS;
-
-	if ( EISADone )
-	{
-		rio_dprintk (RIO_DEBUG_INIT, "RIOEISAinit() - already done, return.\n");
-		return(0);
-	}
-
-	EISADone++;
-
-	rio_dprintk (RIO_DEBUG_INIT, "RIOEISAinit()\n");
-
-
-	/*
-	** First check all cards to see if ANY are set for polled mode operation.
-	** If so, set ALL to polled.
-	*/
-
-	for ( EisaSlot=1; EisaSlot<=RIO_MAX_EISA_SLOTS; EisaSlot++ )
-	{
-	Ident = (INBZ(EisaSlot,EISA_PRODUCT_IDENT_HI)<<8) |
-		 INBZ(EisaSlot,EISA_PRODUCT_IDENT_LO);
-
-	if ( Ident == RIO_EISA_IDENT )
-	{
-		rio_dprintk (RIO_DEBUG_INIT, "Found Specialix product\n");
-
-		if ( INBZ(EisaSlot,EISA_PRODUCT_NUMBER) != RIO_EISA_PRODUCT_CODE )
-		{
-		rio_dprintk (RIO_DEBUG_INIT, "Not Specialix RIO - Product number %x\n",
-						INBZ(EisaSlot, EISA_PRODUCT_NUMBER));
-		continue;  /* next slot */
-		}
-		/*
-		** Its a Specialix RIO!
-		*/
-		rio_dprintk (RIO_DEBUG_INIT, "RIO Revision %d\n",
-					INBZ(EisaSlot, EISA_REVISION_NUMBER));
-		
-		RIOMachineType |= (1<<RIO_EISA);
-
-		/*
-		** Just check we haven't found too many wonderful objects
-		*/
-		if ( RIONumHosts >= RIO_HOSTS )
-		{
-		Rprintf(RIOMesgTooManyCards);
-		return 0;
-		}
-
-		/*
-		** Ensure that the enable bit is set!
-		*/
-		OUTBZ( EisaSlot, EISA_ENABLE, RIO_EISA_ENABLE_BIT );
-
-		/*
-		** EISA_INTERRUPT_VEC contains the interrupt vector.
-		*/
-		Ivec = INBZ(EisaSlot,EISA_INTERRUPT_VEC);
-
-#ifdef RIODEBUG
-		switch ( Ivec & EISA_INTERRUPT_MASK )
-		{
-		case EISA_IRQ_3:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 3\n");
-		break;
-		case EISA_IRQ_4:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 4\n");
-		break;
-		case EISA_IRQ_5:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 5\n");
-		break;
-		case EISA_IRQ_6:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 6\n");
-		break;
-		case EISA_IRQ_7:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 7\n");
-		break;
-		case EISA_IRQ_9:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 9\n");
-		break;
-		case EISA_IRQ_10:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 10\n");
-		break;
-		case EISA_IRQ_11:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 11\n");
-		break;
-		case EISA_IRQ_12:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 12\n");
-		break;
-		case EISA_IRQ_14:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 14\n");
-		break;
-		case EISA_IRQ_15:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA IRQ 15\n");
-		break;
-		case EISA_POLLED:
-			rio_dprintk (RIO_DEBUG_INIT, "EISA POLLED\n");
-		break;
-		default:
-			rio_dprintk (RIO_DEBUG_INIT, NULL,DBG_INIT|DBG_FAIL,"Shagged interrupt number!\n");
-		Ivec &= EISA_CONTROL_MASK;
-		}
-#endif
-
-		if ( (Ivec & EISA_INTERRUPT_MASK) ==
-		 EISA_POLLED )
-		{
-		RIOWillPoll = 1;
-		break;		/* From EisaSlot loop */
-		}
-	}
-	}
-
-	/*
-	** Do it all again now we know whether to change all cards to polled
-	** mode or not
-	*/
-
-	for ( EisaSlot=1; EisaSlot<=RIO_MAX_EISA_SLOTS; EisaSlot++ )
-	{
-	Ident = (INBZ(EisaSlot,EISA_PRODUCT_IDENT_HI)<<8) |
-		 INBZ(EisaSlot,EISA_PRODUCT_IDENT_LO);
-
-	if ( Ident == RIO_EISA_IDENT )
-	{
-		if ( INBZ(EisaSlot,EISA_PRODUCT_NUMBER) != RIO_EISA_PRODUCT_CODE )
-		continue;  /* next slot */
-
-		/*
-		** Its a Specialix RIO!
-		*/
-		
-		/*
-		** Ensure that the enable bit is set!
-		*/
-		OUTBZ( EisaSlot, EISA_ENABLE, RIO_EISA_ENABLE_BIT );
-
-		/*
-		** EISA_INTERRUPT_VEC contains the interrupt vector.
-		*/
-		Ivec = INBZ(EisaSlot,EISA_INTERRUPT_VEC);
-
-		if ( RIOWillPoll )
-		{
-			/*
-			** If we are going to operate in polled mode, but this
-			** board is configured to be interrupt driven, display
-			** the message explaining the situation to the punter,
-			** assuming we haven't already done so.
-			*/
-
-			if ( !PollIntMixMsgDone &&
-			 (Ivec & EISA_INTERRUPT_MASK) != EISA_POLLED )
-			{
-			Rprintf(RIOMesgAllPolled);
-			PollIntMixMsgDone = 1;
-			}
-
-			/*
-			** Ungraciously ignore whatever the board reports as its
-			** interrupt vector...
-			*/
-
-			Ivec &= ~EISA_INTERRUPT_MASK;
-
-			/*
-			** ...and force it to dance to the poll tune.
-			*/
-
-			Ivec |= EISA_POLLED;
-		}
-
-		/*
-		** Convert the IRQ enable mask into something useful (0-15)
-		*/
-		Ivec = RIOEisaToIvec(Ivec);
-
-		rio_dprintk (RIO_DEBUG_INIT, "EISA host in slot %d has Ivec 0x%x\n",
-		 EisaSlot, Ivec);
-
-		/*
-		** Find the physical address
-		*/
-		Paddr = (INBZ(EisaSlot,EISA_MEMORY_BASE_HI)<<24) |
-				(INBZ(EisaSlot,EISA_MEMORY_BASE_LO)<<16);
-
-		rio_dprintk (RIO_DEBUG_INIT, "EISA card has Ivec %d Addr %x\n", Ivec, Paddr);
-
-		if ( Paddr == 0 )
-		{
-		rio_dprintk (RIO_DEBUG_INIT,
-		 "Board in slot %d configured for address zero!\n", EisaSlot);
-		continue;
-		}
-
-		/*
-		** Tell the memory mapper that we want to talk to it
-		*/
-		rio_dprintk (RIO_DEBUG_INIT, "About to map EISA card \n");
-
-		if (RIOMapin( Paddr, RIO_EISA_MEM_SIZE, &Caddr) == -1) {
-		rio_dprintk (RIO_DEBUG_INIT, "Couldn't map %d bytes at %x\n",
-							RIO_EISA_MEM_SIZE,Paddr);
-		continue;
-		}
-
-		rio_dprintk (RIO_DEBUG_INIT, "Board mapped to vaddr 0x%x\n", Caddr);
-
-		/*
-		** And check that it is actually there!
-		*/
-		if ( RIOBoardTest( Paddr,Caddr,RIO_EISA,EisaSlot) == RIO_SUCCESS )
-			{
-		rio_dprintk (RIO_DEBUG_INIT, "Board has passed test\n");
-		rio_dprintk (RIO_DEBUG_INIT, 
-		"Slot %d. Ivec %d. Type %d. Paddr 0x%x. Caddr 0x%x. Mode 0x%x.\n",
-			EisaSlot,Ivec,RIO_EISA,Paddr,Caddr,Mode);
-
-		/*
-		** Board has passed its scrub test. Fill in all the
-		** transient stuff.
-		*/
-		p->RIOHosts[RIONumHosts].Slot	 = EisaSlot;
-		p->RIOHosts[RIONumHosts].Ivec	 = Ivec;
-		p->RIOHosts[RIONumHosts].Type	 = RIO_EISA;
-		p->RIOHosts[RIONumHosts].Copy	 = bcopy;
-				p->RIOHosts[RIONumHosts].PaddrP   = Paddr;
-				p->RIOHosts[RIONumHosts].Caddr	= Caddr;
-		p->RIOHosts[RIONumHosts].CardP	= (struct DpRam *)Caddr;
-				p->RIOHosts[RIONumHosts].Mode	 = Mode;
-		/*
-		** because the EISA prom is mapped into IO space, we
-		** need to copy the unqiue number into the memory area
-		** that it would have occupied, so that the download
-		** code can determine its ID and card type.
-		*/
-	 WBYTE(p->RIOHosts[RIONumHosts].Unique[0],INBZ(EisaSlot,EISA_UNIQUE_NUM_0));
-	 WBYTE(p->RIOHosts[RIONumHosts].Unique[1],INBZ(EisaSlot,EISA_UNIQUE_NUM_1));
-	 WBYTE(p->RIOHosts[RIONumHosts].Unique[2],INBZ(EisaSlot,EISA_UNIQUE_NUM_2));
-	 WBYTE(p->RIOHosts[RIONumHosts].Unique[3],INBZ(EisaSlot,EISA_UNIQUE_NUM_3));
-		p->RIOHosts[RIONumHosts].UniqueNum =
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[0])&0xFF)<<0)|
-						((RBYTE(p->RIOHosts[RIONumHosts].Unique[1])&0xFF)<<8)|
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[2])&0xFF)<<16)|
-			((RBYTE(p->RIOHosts[RIONumHosts].Unique[3])&0xFF)<<24);
-		INBZ(EisaSlot,EISA_INTERRUPT_RESET);
-				RIONumHosts++;
-		ret++;
-			}
-		else
-		{
-		/*
-		** It failed the test, so ignore it.
-		*/
-		rio_dprintk (RIO_DEBUG_INIT, "TEST FAILED\n");
-
-		RIOMapout(Paddr, RIO_EISA_MEM_SIZE, Caddr );
-		}
-	}
-	}
-	if (RIOMachineType & RIO_EISA)
-	return ret+1;
-	return ret;
-}
-#endif
-
-
-#ifndef linux
-
-#define CONFIG_ADDRESS	0xcf8
-#define CONFIG_DATA		0xcfc
-#define FORWARD_REG		0xcfa
-
-
-static int
-read_config(int bus_number, int device_num, int r_number) 
-{
-	unsigned int cav;
-	unsigned int val;
-
-/*
-   Build config_address_value:
-
-      31        24 23        16 15      11 10  8 7        0 
-      ------------------------------------------------------
-      |1| 0000000 | bus_number | device # | 000 | register |
-      ------------------------------------------------------
-*/
-
-	cav = r_number & 0xff;
-	cav |= ((device_num & 0x1f) << 11);
-	cav |= ((bus_number & 0xff) << 16);
-	cav |= 0x80000000; /* Enable bit */
-	outpd(CONFIG_ADDRESS,cav);
-	val = inpd(CONFIG_DATA);
-	outpd(CONFIG_ADDRESS,0);
-	return val;
-}
-
-static
-write_config(bus_number,device_num,r_number,val) 
-{
-	unsigned int cav;
-
-/*
-   Build config_address_value:
-
-      31        24 23        16 15      11 10  8 7        0 
-      ------------------------------------------------------
-      |1| 0000000 | bus_number | device # | 000 | register |
-      ------------------------------------------------------
-*/
-
-	cav = r_number & 0xff;
-	cav |= ((device_num & 0x1f) << 11);
-	cav |= ((bus_number & 0xff) << 16);
-	cav |= 0x80000000; /* Enable bit */
-	outpd(CONFIG_ADDRESS, cav);
-	outpd(CONFIG_DATA, val);
-	outpd(CONFIG_ADDRESS, 0);
-	return val;
-}
-#else
-/* XXX Implement these... */
-static int
-read_config(int bus_number, int device_num, int r_number) 
-{
-  return 0;
-}
-
-static int
-write_config(int bus_number, int device_num, int r_number) 
-{
-  return 0;
-}
-
-#endif
-
-int
-RIOPCIinit(p, Mode)
-struct rio_info	*p;
-int 		Mode;
-{
-	#define MAX_PCI_SLOT		32
-	#define RIO_PCI_JET_CARD	0x200011CB
-
-	static int	slot;	/* count of machine's PCI slots searched so far */
-	caddr_t		Caddr;	/* Virtual address of the current PCI host card. */
-	unsigned char	Ivec;	/* interrupt vector for the current PCI host */
-	unsigned long	Paddr;	/* Physical address for the current PCI host */
-	int		Handle;	/* Handle to Virtual memory allocated for current PCI host */
-
-
-	rio_dprintk (RIO_DEBUG_INIT,  "Search for a RIO PCI card - start at slot %d\n", slot);
-
-	/*
-	** Initialise the search status
-	*/
-	p->RIOLastPCISearch	= RIO_FAIL;
-
-	while ( (slot < MAX_PCI_SLOT) & (p->RIOLastPCISearch != RIO_SUCCESS) )
-	{
-		rio_dprintk (RIO_DEBUG_INIT,  "Currently testing slot %d\n", slot);
-
-		if (read_config(0,slot,0) == RIO_PCI_JET_CARD) {
-			p->RIOHosts[p->RIONumHosts].Ivec = 0;
-			Paddr = read_config(0,slot,0x18);
-			Paddr = Paddr - (Paddr & 0x1); /* Mask off the io bit */
-
-			if ( (Paddr == 0) || ((Paddr & 0xffff0000) == 0xffff0000) ) {
-				rio_dprintk (RIO_DEBUG_INIT,  "Goofed up slot\n");	/* what! */
-				slot++;
-				continue;
-			}
-
-			p->RIOHosts[p->RIONumHosts].PaddrP = Paddr;
-			Ivec = (read_config(0,slot,0x3c) & 0xff);
-
-			rio_dprintk (RIO_DEBUG_INIT,  "PCI Host at 0x%x, Intr %d\n", (int)Paddr, Ivec);
-
-			Handle = RIOMapin( Paddr, RIO_PCI_MEM_SIZE, &Caddr );
-			if (Handle == -1) {
-				rio_dprintk (RIO_DEBUG_INIT,  "Couldn't map %d bytes at 0x%x\n", RIO_PCI_MEM_SIZE, (int)Paddr);
-				slot++;
-				continue;
-			}
-			p->RIOHosts[p->RIONumHosts].Ivec = Ivec + 32;
-			p->intr_tid = iointset(p->RIOHosts[p->RIONumHosts].Ivec,
-						(int (*)())rio_intr, (char *)p->RIONumHosts);
-			if (RIOBoardTest( Paddr, Caddr, RIO_PCI, 0 ) == RIO_SUCCESS) {
-				rio_dprintk (RIO_DEBUG_INIT, ("Board has passed test\n");
-				rio_dprintk (RIO_DEBUG_INIT, ("Paddr 0x%x. Caddr 0x%x. Mode 0x%x.\n", Paddr, Caddr, Mode);
-
-				/*
-				** Board has passed its scrub test. Fill in all the
-				** transient stuff.
-				*/
-				p->RIOHosts[p->RIONumHosts].Slot	   = 0;
-				p->RIOHosts[p->RIONumHosts].Ivec	   = Ivec + 32;
-				p->RIOHosts[p->RIONumHosts].Type	   = RIO_PCI;
-				p->RIOHosts[p->RIONumHosts].Copy	   = rio_pcicopy; 
-				p->RIOHosts[p->RIONumHosts].PaddrP	   = Paddr;
-				p->RIOHosts[p->RIONumHosts].Caddr	   = Caddr;
-				p->RIOHosts[p->RIONumHosts].CardP	   = (struct DpRam *)Caddr;
-				p->RIOHosts[p->RIONumHosts].Mode	   = Mode;
-
-#if 0
-				WBYTE(p->RIOHosts[p->RIONumHosts].Control, 
-						BOOT_FROM_RAM | EXTERNAL_BUS_OFF | 
-						p->RIOHosts[p->RIONumHosts].Mode | 
-						INTERRUPT_DISABLE );
-				WBYTE(p->RIOHosts[p->RIONumHosts].ResetInt,0xff);
-				WBYTE(p->RIOHosts[p->RIONumHosts].Control,
-						BOOT_FROM_RAM | EXTERNAL_BUS_OFF | 
-						p->RIOHosts[p->RIONumHosts].Mode |
-						INTERRUPT_DISABLE );
-				WBYTE(p->RIOHosts[p->RIONumHosts].ResetInt,0xff);
-#else
-				WBYTE(p->RIOHosts[p->RIONumHosts].ResetInt, 0xff);
-#endif
-				p->RIOHosts[p->RIONumHosts].UniqueNum  =
-					((RBYTE(p->RIOHosts[p->RIONumHosts].Unique[0])&0xFF)<<0)|
-					((RBYTE(p->RIOHosts[p->RIONumHosts].Unique[1])&0xFF)<<8)|
-					((RBYTE(p->RIOHosts[p->RIONumHosts].Unique[2])&0xFF)<<16)|
-					((RBYTE(p->RIOHosts[p->RIONumHosts].Unique[3])&0xFF)<<24);
-
-				rio_dprintk (RIO_DEBUG_INIT, "Unique no 0x%x.\n", 
-				    p->RIOHosts[p->RIONumHosts].UniqueNum);
-
-				p->RIOLastPCISearch = RIO_SUCCESS;
-				p->RIONumHosts++;
-			}
-		}
-		slot++;
-	}
-
-	if ( slot >= MAX_PCI_SLOT ) {
-		rio_dprintk (RIO_DEBUG_INIT,  "All %d PCI slots have tested for RIO cards !!!\n",
-			     MAX_PCI_SLOT);
-	}
-
-
-	/*
-	** I don't think we want to do this anymore
-	**
-
-	if (!p->RIOLastPCISearch == RIO_FAIL ) {
-		p->RIOFailed++;
-	}
-
-	**
-	*/
-}
-
-#ifdef FUTURE_RELEASE
-void riohalt( void )
-{
-	int host;
-	for ( host=0; host<p->RIONumHosts; host++ )
-	{
-		rio_dprintk (RIO_DEBUG_INIT, "Stop host %d\n", host);
-		(void)RIOBoardTest( p->RIOHosts[host].PaddrP, p->RIOHosts[host].Caddr, p->RIOHosts[host].Type,p->RIOHosts[host].Slot );
-	}
-}
-#endif
-#endif
 
 static	uchar	val[] = {
 #ifdef VERY_LONG_TEST
@@ -1262,200 +387,6 @@ int		size; 
 	return RIO_SUCCESS;
 }
 
-/*
-** try to ensure that every host is either in polled mode
-** or is in interrupt mode. Only allow interrupt mode if
-** all hosts can interrupt (why?)
-** and force into polled mode if told to. Patch up the
-** interrupt vector & salute The Queen when you've done.
-*/
-#if 0
-static void
-RIOAllocateInterrupts(p)
-struct rio_info *	p;
-{
-	int Host;
-
-	/*
-	** Easy case - if we have been told to poll, then we poll.
-	*/
-	if (p->mode & POLLED_MODE) {
-		RIOStopInterrupts(p, 0, 0);
-		return;
-	}
-
-	/*
-	** check - if any host has been set to polled mode, then all must be.
-	*/
-	for (Host=0; Host<p->RIONumHosts; Host++) {
-		if ( (p->RIOHosts[Host].Type != RIO_AT) &&
-				(p->RIOHosts[Host].Ivec == POLLED) ) {
-			RIOStopInterrupts(p, 1, Host );
-			return;
-		}
-	}
-	for (Host=0; Host<p->RIONumHosts; Host++) {
-		if (p->RIOHosts[Host].Type == RIO_AT) {
-			if ( (p->RIOHosts[Host].Ivec - 32) == 0) {
-				RIOStopInterrupts(p, 2, Host );
-				return;
-			}
-		}
-	}
-}
-
-/*
-** something has decided that we can't be doing with these
-** new-fangled interrupt thingies. Set everything up to just
-** poll.
-*/
-static void
-RIOStopInterrupts(p, Reason, Host)
-struct rio_info *	p;
-int	Reason;
-int	Host; 
-{
-#ifdef FUTURE_RELEASE
-	switch (Reason) {
-		case 0:	/* forced into polling by rio_polled */
-			break;
-		case 1:	/* SCU has set 'Host' into polled mode */
-			break;
-		case 2:	/* there aren't enough interrupt vectors for 'Host' */
-			break;
-	}
-#endif
-
-	for (Host=0; Host<p->RIONumHosts; Host++ ) {
-		struct Host *HostP = &p->RIOHosts[Host];
-
-		switch (HostP->Type) {
-			case RIO_AT:
-				/*
-				** The AT host has it's interrupts disabled by clearing the
-				** int_enable bit.
-				*/
-				HostP->Mode &= ~INTERRUPT_ENABLE;
-				HostP->Ivec = POLLED;
-				break;
-#ifdef FUTURE_RELEASE
-			case RIO_EISA:
-				/*
-				** The EISA host has it's interrupts disabled by setting the
-				** Ivec to zero
-				*/
-				HostP->Ivec = POLLED;
-				break;
-#endif
-			case RIO_PCI:
-				/*
-				** The PCI host has it's interrupts disabled by clearing the
-				** int_enable bit, like a regular host card.
-				*/
-				HostP->Mode &= ~RIO_PCI_INT_ENABLE;
-				HostP->Ivec = POLLED;
-				break;
-#ifdef FUTURE_RELEASE
-			case RIO_MCA:
-				/*
-				** There's always one, isn't there?
-				** The MCA host card cannot have it's interrupts disabled.
-				*/
-				RIOPatchVec(HostP);
-				break;
-#endif
-		}
-	}
-}
-
-/*
-** This function is called at init time to setup the data structures.
-*/
-void
-RIOAllocDataStructs(p)
-struct rio_info *	p;
-{
-	int	port,
-		host,
-		tm;
-
-	p->RIOPortp = (struct Port *)sysbrk(RIO_PORTS * sizeof(struct Port));
-	if (!p->RIOPortp) {
-		rio_dprintk (RIO_DEBUG_INIT, "RIO-init: No memory for port structures\n");
-		p->RIOFailed++;
-		return;
-	} 
-	bzero( p->RIOPortp, sizeof(struct Port) * RIO_PORTS );
-	rio_dprintk (RIO_DEBUG_INIT,  "RIO-init: allocated and cleared memory for port structs\n");
-	rio_dprintk (RIO_DEBUG_INIT,  "First RIO port struct @0x%x, size=0x%x bytes\n",
-	    (int)p->RIOPortp, sizeof(struct Port));
-
-	for( port=0; port<RIO_PORTS; port++ ) {
-		p->RIOPortp[port].PortNum = port;
-		p->RIOPortp[port].TtyP = &p->channel[port];
-		sreset (p->RIOPortp[port].InUse);	/* Let the first guy uses it */
-		p->RIOPortp[port].portSem = -1;	/* Let the first guy takes it */
-		p->RIOPortp[port].ParamSem = -1;	/* Let the first guy takes it */
-		p->RIOPortp[port].timeout_id = 0;	/* Let the first guy takes it */
-	}
-
-	p->RIOHosts = (struct Host *)sysbrk(RIO_HOSTS * sizeof(struct Host));
-	if (!p->RIOHosts) {
-		rio_dprintk (RIO_DEBUG_INIT, "RIO-init: No memory for host structures\n");
-		p->RIOFailed++;
-		return;
-	}
-	bzero(p->RIOHosts, sizeof(struct Host)*RIO_HOSTS);
-	rio_dprintk (RIO_DEBUG_INIT,  "RIO-init: allocated and cleared memory for host structs\n");
-	rio_dprintk (RIO_DEBUG_INIT,  "First RIO host struct @0x%x, size=0x%x bytes\n",
-	    (int)p->RIOHosts, sizeof(struct Host));
-
-	for( host=0; host<RIO_HOSTS; host++ ) {
-		spin_lock_init (&p->RIOHosts[host].HostLock);
-		p->RIOHosts[host].timeout_id = 0; /* Let the first guy takes it */
-	}
-	/*
-	** check that the buffer size is valid, round down to the next power of
-	** two if necessary; if the result is zero, then, hey, no double buffers.
-	*/
-	for ( tm = 1; tm && tm <= p->RIOConf.BufferSize; tm <<= 1 )
-		;
-	tm >>= 1;
-	p->RIOBufferSize = tm;
-	p->RIOBufferMask = tm ? tm - 1 : 0;
-}
-
-/*
-** this function gets called whenever the data structures need to be
-** re-setup, for example, after a riohalt (why did I ever invent it?)
-*/
-void
-RIOSetupDataStructs(p)
-struct rio_info	* p;
-{
-	int host, entry, rup;
-
-	for ( host=0; host<RIO_HOSTS; host++ ) {
-		struct Host *HostP = &p->RIOHosts[host];
-		for ( entry=0; entry<LINKS_PER_UNIT; entry++ ) {
-			HostP->Topology[entry].Unit = ROUTE_DISCONNECT;
-			HostP->Topology[entry].Link = NO_LINK;
-		}
-		bcopy("HOST X", HostP->Name, 7);
-		HostP->Name[5] = '1'+host;
-		for (rup=0; rup<(MAX_RUP + LINKS_PER_UNIT); rup++) {
-			if (rup < MAX_RUP) {
-				for (entry=0; entry<LINKS_PER_UNIT; entry++ ) {
-					HostP->Mapping[rup].Topology[entry].Unit = ROUTE_DISCONNECT;
-					HostP->Mapping[rup].Topology[entry].Link = NO_LINK;
-				}
-				RIODefaultName(p, HostP, rup);
-			}
-			spin_lock_init(&HostP->UnixRups[rup].RupLock);
-		}
-	}
-}
-#endif
 
 int
 RIODefaultName(p, HostP, UnitId)
@@ -1463,10 +394,6 @@ struct rio_info *	p;
 struct Host *	HostP;
 uint			UnitId;
 {
-#ifdef CHECK
-	CheckHost( Host );
-	CheckUnitId( UnitId );
-#endif
 	bcopy("UNKNOWN RTA X-XX",HostP->Mapping[UnitId].Name,17);
 	HostP->Mapping[UnitId].Name[12]='1'+(HostP-p->RIOHosts);
 	if ((UnitId+1) > 9) {
@@ -1483,33 +410,6 @@ uint			UnitId;
 #define RIO_RELEASE	"Linux"
 #define RELEASE_ID	"1.0"
 
-#if 0
-static int
-RIOReport(p)
-struct rio_info *	p;
-{
-	char *	RIORelease = RIO_RELEASE;
-	char *	RIORelID = RELEASE_ID;
-	int		host;
-
-	rio_dprintk (RIO_DEBUG_INIT, "RIO : Release: %s ID: %s\n", RIORelease, RIORelID);
-
-	if ( p->RIONumHosts==0 ) {
-		rio_dprintk (RIO_DEBUG_INIT, "\nNo Hosts configured\n");
-		return(0);
-	}
-
-	for ( host=0; host < p->RIONumHosts; host++ ) {
-		struct Host *HostP = &p->RIOHosts[host];
-		switch ( HostP->Type ) {
-			case RIO_AT:
-				rio_dprintk (RIO_DEBUG_INIT, "AT BUS : found the card at 0x%x\n", HostP->PaddrP);
-		}
-	}
-	return 0;
-}
-#endif
-
 static struct rioVersion	stVersion;
 
 struct rioVersion *
@@ -1523,27 +423,6 @@ RIOVersid(void)
     return &stVersion;
 }
 
-#if 0
-int
-RIOMapin(paddr, size, vaddr)
-paddr_t		paddr;
-int			size;
-caddr_t *	vaddr;
-{
-	*vaddr = (caddr_t)permap( (long)paddr, size);
-	return ((int)*vaddr);
-}
-
-void
-RIOMapout(paddr, size, vaddr)
-paddr_t		paddr;
-long		size;
-caddr_t 	vaddr;
-{
-}
-#endif
-
-
 void
 RIOHostReset(Type, DpRamP, Slot)
 uint Type;
@@ -1570,31 +449,6 @@ uint Slot; 
 			WBYTE(DpRamP->DpResetTpu, 0xFF);
 			udelay(3);
 			break;
-#ifdef FUTURE_RELEASE
-	case RIO_EISA:
-	/*
-	** Bet this doesn't work!
-	*/
-	OUTBZ( Slot, EISA_CONTROL_PORT,
-		EISA_TP_RUN		| EISA_TP_BUS_DISABLE   |
-		EISA_TP_SLOW_LINKS | EISA_TP_BOOT_FROM_RAM );
-	OUTBZ( Slot, EISA_CONTROL_PORT,
-		EISA_TP_RESET	  | EISA_TP_BUS_DISABLE   | 
-		EISA_TP_SLOW_LINKS | EISA_TP_BOOT_FROM_RAM );
-	suspend( 3 );
-	OUTBZ( Slot, EISA_CONTROL_PORT,
-		EISA_TP_RUN		| EISA_TP_BUS_DISABLE   | 
-		EISA_TP_SLOW_LINKS | EISA_TP_BOOT_FROM_RAM );
-	break;
-	case RIO_MCA:
-	WBYTE(DpRamP->DpControl  , McaTpBootFromRam | McaTpBusDisable );
-	WBYTE(DpRamP->DpResetTpu , 0xFF );
-	suspend( 3 );
-	WBYTE(DpRamP->DpControl  , McaTpBootFromRam | McaTpBusDisable );
-	WBYTE(DpRamP->DpResetTpu , 0xFF );
-	suspend( 3 );
-		break;
-#endif
 	case RIO_PCI:
 		rio_dprintk (RIO_DEBUG_INIT, " (RIO_PCI)\n");
 		DpRamP->DpControl  = RIO_PCI_BOOT_FROM_RAM;
@@ -1604,12 +458,6 @@ uint Slot; 
 		/* for (i=0; i<6000; i++);  */
 		/* suspend( 3 ); */
 		break;
-#ifdef FUTURE_RELEASE
-	default:
-	Rprintf(RIOMesgNoSupport,Type,DpRamP,Slot);
-	return;
-#endif
-
 	default:
 		rio_dprintk (RIO_DEBUG_INIT, " (UNKNOWN)\n");
 		break;
diff -purN linux-2.6.15-git12/drivers/char/rio/riolocks.h linux-2.6.16-rc1/drivers/char/rio/riolocks.h
--- linux-2.6.15-git12/drivers/char/rio/riolocks.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riolocks.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,43 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: riolocks.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:13
-**	Retrieved	: 11/6/98 11:34:22
-**
-**  ident @(#)riolocks.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef	__rio_riolocks_h__
-#define	__rio_riolocks_h__
-
-#ifdef SCCS_LABELS
-static char *_riolocks_h_sccs_ = "@(#)riolocks.h	1.2";
-#endif
-
-#define LOCKB(lk)		lockb(lk);
-#define UNLOCKB(lk, oldspl)	unlockb(lk, oldspl);
-
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/rioparam.c linux-2.6.16-rc1/drivers/char/rio/rioparam.c
--- linux-2.6.15-git12/drivers/char/rio/rioparam.c	2006-01-17 08:21:31.374727198 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rioparam.c	2006-01-17 08:22:45.532376127 +0000
@@ -195,27 +195,6 @@ int SleepFlag;
 		 ** paramed with OPEN, we want to restore the saved port termio, but
 		 ** only if StoredTermio has been saved, i.e. NOT 1st open after reboot.
 		 */
-#if 0
-		if (PortP->FirstOpen) {
-			PortP->StoredTty.iflag = TtyP->tm.c_iflag;
-			PortP->StoredTty.oflag = TtyP->tm.c_oflag;
-			PortP->StoredTty.cflag = TtyP->tm.c_cflag;
-			PortP->StoredTty.lflag = TtyP->tm.c_lflag;
-			PortP->StoredTty.line = TtyP->tm.c_line;
-			for (i = 0; i < NCC + 5; i++)
-				PortP->StoredTty.cc[i] = TtyP->tm.c_cc[i];
-			PortP->FirstOpen = 0;
-		} else if (PortP->Store || PortP->Lock) {
-			rio_dprintk(RIO_DEBUG_PARAM, "OPEN: Restoring stored/locked params\n");
-			TtyP->tm.c_iflag = PortP->StoredTty.iflag;
-			TtyP->tm.c_oflag = PortP->StoredTty.oflag;
-			TtyP->tm.c_cflag = PortP->StoredTty.cflag;
-			TtyP->tm.c_lflag = PortP->StoredTty.lflag;
-			TtyP->tm.c_line = PortP->StoredTty.line;
-			for (i = 0; i < NCC + 5; i++)
-				TtyP->tm.c_cc[i] = PortP->StoredTty.cc[i];
-		}
-#endif
 	}
 
 	/*
@@ -273,16 +252,6 @@ int SleepFlag;
 	phb_param_ptr = (struct phb_param *) PacketP->data;
 
 
-#if 0
-	/*
-	 ** COR 1
-	 */
-	if (TtyP->tm.c_iflag & INPCK) {
-		rio_dprintk(RIO_DEBUG_PARAM, "Parity checking on input enabled\n");
-		Cor1 |= COR1_INPCK;
-	}
-#endif
-
 	switch (TtyP->termios->c_cflag & CSIZE) {
 	case CS5:
 		{
@@ -524,10 +493,6 @@ int SleepFlag;
 	if (TtyP->termios->c_cflag & XMT1EN)
 		rio_dprintk(RIO_DEBUG_PARAM, "XMT1EN (?)\n");
 #endif
-#if 0
-	if (TtyP->termios->c_cflag & LOBLK)
-		rio_dprintk(RIO_DEBUG_PARAM, "LOBLK - JCL output blocks when not current\n");
-#endif
 	if (TtyP->termios->c_lflag & ISIG)
 		rio_dprintk(RIO_DEBUG_PARAM, "Input character signal generating enabled\n");
 	if (TtyP->termios->c_lflag & ICANON)
@@ -572,14 +537,6 @@ int SleepFlag;
 		rio_dprintk(RIO_DEBUG_PARAM, "Carriage return delay set\n");
 	if (TtyP->termios->c_oflag & TABDLY)
 		rio_dprintk(RIO_DEBUG_PARAM, "Tab delay set\n");
-#if 0
-	if (TtyP->termios->c_oflag & BSDLY)
-		rio_dprintk(RIO_DEBUG_PARAM, "Back-space delay set\n");
-	if (TtyP->termios->c_oflag & VTDLY)
-		rio_dprintk(RIO_DEBUG_PARAM, "Vertical tab delay set\n");
-	if (TtyP->termios->c_oflag & FFDLY)
-		rio_dprintk(RIO_DEBUG_PARAM, "Form-feed delay set\n");
-#endif
 	/*
 	 ** These things are kind of useful in a later life!
 	 */
diff -purN linux-2.6.15-git12/drivers/char/rio/rioroute.c linux-2.6.16-rc1/drivers/char/rio/rioroute.c
--- linux-2.6.15-git12/drivers/char/rio/rioroute.c	2006-01-17 08:21:31.397856481 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rioroute.c	2006-01-17 08:22:45.555372506 +0000
@@ -112,15 +112,6 @@ int RIORouteRup(struct rio_info *p, uint
 	int Lies;
 	unsigned long flags;
 
-#ifdef STACK
-	RIOStackCheck("RIORouteRup");
-#endif
-#ifdef CHECK
-	CheckPacketP(PacketP);
-	CheckHostP(HostP);
-	CheckRup(Rup);
-	CheckHost(Host);
-#endif
 	/*
 	 ** Is this unit telling us it's current link topology?
 	 */
@@ -540,9 +531,6 @@ uint unit;
 
 		for (port = 0; port < PORTS_PER_RTA; port++, PortN++) {
 			ushort dest_port = port + 8;
-#if 0
-			uint PktInt;
-#endif
 			WORD *TxPktP;
 			PKT *Pkt;
 
@@ -623,10 +611,6 @@ uint UnitId;
 	unsigned long flags;
 	rio_spin_lock_irqsave(&HostP->HostLock, flags);
 
-#ifdef CHECK
-	CheckHostP(HostP);
-	CheckUnitId(UnitId);
-#endif
 	if (RIOCheck(HostP, UnitId)) {
 		rio_dprintk(RIO_DEBUG_ROUTE, "Unit %d is NOT isolated\n", UnitId);
 		rio_spin_unlock_irqrestore(&HostP->HostLock, flags);
@@ -651,10 +635,6 @@ uint UnitId;
 {
 	uint link, unit;
 
-#ifdef CHECK
-	CheckHostP(HostP);
-	CheckUnitId(UnitId);
-#endif
 	UnitId--;		/* this trick relies on the Unit Id being UNSIGNED! */
 
 	if (UnitId >= MAX_RUP)	/* dontcha just lurv unsigned maths! */
@@ -684,10 +664,6 @@ uint UnitId;
 {
 	unsigned char link;
 
-#ifdef CHECK
-	CheckHostP(HostP);
-	CheckUnitId(UnitId);
-#endif
 /* 	rio_dprint(RIO_DEBUG_ROUTE, ("Check to see if unit %d has a route to the host\n",UnitId)); */
 	rio_dprintk(RIO_DEBUG_ROUTE, "RIOCheck : UnitID = %d\n", UnitId);
 
diff -purN linux-2.6.15-git12/drivers/char/rio/riotable.c linux-2.6.16-rc1/drivers/char/rio/riotable.c
--- linux-2.6.15-git12/drivers/char/rio/riotable.c	2006-01-17 08:21:31.418853175 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riotable.c	2006-01-17 08:22:45.576369200 +0000
@@ -754,11 +754,6 @@ struct Map *HostMapP;
 	ushort RtaType;
 	unsigned long flags;
 
-#ifdef CHECK
-	CheckHostP(HostP);
-	CheckHostMapP(HostMapP);
-#endif
-
 	rio_dprintk(RIO_DEBUG_TABLE, "Mapping sysport %d to id %d\n", (int) HostMapP->SysPort, HostMapP->ID);
 
 	/*
@@ -784,9 +779,6 @@ struct Map *HostMapP;
 
 		rio_dprintk(RIO_DEBUG_TABLE, "c1 p = %p, p->rioPortp = %p\n", p, p->RIOPortp);
 		PortP = p->RIOPortp[SysPort];
-#if 0
-		PortP->TtyP = &p->channel[SysPort];
-#endif
 		rio_dprintk(RIO_DEBUG_TABLE, "Map port\n");
 
 		/*
diff -purN linux-2.6.15-git12/drivers/char/rio/riotime.h linux-2.6.16-rc1/drivers/char/rio/riotime.h
--- linux-2.6.15-git12/drivers/char/rio/riotime.h	2006-01-17 08:21:31.419853018 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riotime.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******            T I M E
- *******                                                              *******
- ****************************************************************************
-
- Author  : Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
-
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef _riotime_h
-#define _riotime_h 1
-
-#ifndef lint
-#ifdef SCCS
-static char *_rio_riotime_h_sccs = "@(#)riotime.h	1.1";
-#endif
-#endif
-
-#define TWO_POWER_FIFTEEN (ushort)32768
-#define RioTime()    riotime
-#define RioTimeAfter(time1,time2) ((ushort)time1 - (ushort)time2) < TWO_POWER_FIFTEEN
-#define RioTimePlus(time1,time2) ((ushort)time1 + (ushort)time2)
-
-/**************************************
- * Convert a RIO tick (1/10th second)
- * into transputer low priority ticks
- *************************************/
-#define RioTimeToLow(time) (time*(100000 / 64))
-#define RioLowToTime(time) ((time*64)/100000)
-
-#define RIOTENTHSECOND (ushort)1
-#define RIOSECOND (ushort)(RIOTENTHSECOND * 10)
-#endif
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/riotty.c linux-2.6.16-rc1/drivers/char/rio/riotty.c
--- linux-2.6.15-git12/drivers/char/rio/riotty.c	2006-01-17 08:21:31.440849712 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riotty.c	2006-01-17 08:22:45.596366052 +0000
@@ -89,16 +89,9 @@ static char *_riotty_c_sccs_ = "@(#)riot
 #include "list.h"
 #include "sam.h"
 
-#if 0
-static void ttyseth_pv(struct Port *, struct ttystatics *, struct termios *sg, int);
-#endif
-
 static void RIOClearUp(struct Port *PortP);
 int RIOShortCommand(struct rio_info *p, struct Port *PortP, int command, int len, int arg);
 
-#if 0
-static int RIOCookMode(struct ttystatics *);
-#endif
 
 extern int conv_vb[];		/* now defined in ttymgr.c */
 extern int conv_bv[];		/* now defined in ttymgr.c */
@@ -226,33 +219,6 @@ int riotopen(struct tty_struct *tty, str
 	 ** until the RTA is present then we must spin here waiting for
 	 ** the RTA to boot.
 	 */
-#if 0
-	if (!(PortP->HostP->Mapping[PortP->RupNum].Flags & RTA_BOOTED)) {
-		if (PortP->WaitUntilBooted) {
-			rio_dprintk(RIO_DEBUG_TTY, "Waiting for RTA to boot\n");
-			do {
-				if (RIODelay(PortP, HUNDRED_MS) == RIO_FAIL) {
-					rio_dprintk(RIO_DEBUG_TTY, "RTA EINTR in delay \n");
-					func_exit();
-					return -EINTR;
-				}
-				if (repeat_this-- <= 0) {
-					rio_dprintk(RIO_DEBUG_TTY, "Waiting for RTA to boot timeout\n");
-					RIOPreemptiveCmd(p, PortP, FCLOSE);
-					pseterr(EINTR);
-					func_exit();
-					return -EIO;
-				}
-			} while (!(PortP->HostP->Mapping[PortP->RupNum].Flags & RTA_BOOTED));
-			rio_dprintk(RIO_DEBUG_TTY, "RTA has been booted\n");
-		} else {
-			rio_dprintk(RIO_DEBUG_TTY, "RTA never booted\n");
-			pseterr(ENXIO);
-			func_exit();
-			return 0;
-		}
-	}
-#else
 	/* I find the above code a bit hairy. I find the below code
 	   easier to read and shorter. Now, if it works too that would
 	   be great... -- REW 
@@ -281,21 +247,10 @@ int riotopen(struct tty_struct *tty, str
 		}
 	}
 	rio_dprintk(RIO_DEBUG_TTY, "RTA has been booted\n");
-#endif
-#if 0
-	tp = PortP->TtyP;	/* get tty struct */
-#endif
 	rio_spin_lock_irqsave(&PortP->portSem, flags);
 	if (p->RIOHalted) {
 		goto bombout;
 	}
-#if 0
-	retval = gs_init_port(&PortP->gs);
-	if (retval) {
-		func_exit();
-		return retval;
-	}
-#endif
 
 	/*
 	 ** If the port is in the final throws of being closed,
@@ -363,11 +318,6 @@ int riotopen(struct tty_struct *tty, str
 		   command piggybacks the parameters immediately.
 		   -- REW */
 		RIOParam(PortP, OPEN, Modem, OK_TO_SLEEP);	/* Open the port */
-#if 0
-		/* This delay of 1 second was annoying. I removed it. -- REW */
-		RIODelay(PortP, HUNDRED_MS * 10);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);	/* Config the port */
-#endif
 		rio_spin_lock_irqsave(&PortP->portSem, flags);
 
 		/*
@@ -439,9 +389,6 @@ int riotopen(struct tty_struct *tty, str
 				PortP->State |= RIO_WOPEN;
 				rio_spin_unlock_irqrestore(&PortP->portSem, flags);
 				if (RIODelay(PortP, HUNDRED_MS) == RIO_FAIL)
-#if 0
-					if (sleep((caddr_t) & tp->tm.c_canqo, TTIPRI | PCATCH))
-#endif
 					{
 						/*
 						 ** ACTION: verify that this is a good thing
@@ -505,10 +452,6 @@ int riotopen(struct tty_struct *tty, str
 */
 int riotclose(void *ptr)
 {
-#if 0
-	register uint SysPort = dev;
-	struct ttystatics *tp;	/* pointer to our ttystruct */
-#endif
 	struct Port *PortP = ptr;	/* pointer to the port structure */
 	int deleted = 0;
 	int try = -1;		/* Disable the timeouts by setting them to -1 */
@@ -534,13 +477,6 @@ int riotclose(void *ptr)
 		end_time = jiffies + MAX_SCHEDULE_TIMEOUT;
 
 	Modem = rio_ismodem(tty);
-#if 0
-	/* What F.CKING cache? Even then, a higly idle multiprocessor,
-	   system with large caches this won't work . Better find out when 
-	   this doesn't work asap, and fix the cause.  -- REW */
-
-	RIODelay(PortP, HUNDRED_MS * 10);	/* To flush the cache */
-#endif
 	rio_spin_lock_irqsave(&PortP->portSem, flags);
 
 	/*
@@ -703,45 +639,6 @@ int riotclose(void *ptr)
 }
 
 
-/*
-** decide if we need to use the line discipline.
-** This routine can return one of three values:
-** COOK_RAW if no processing has to be done by the line discipline or the card
-** COOK_WELL if the line discipline must be used to do the processing
-** COOK_MEDIUM if the card can do all the processing necessary.
-*/
-#if 0
-static int RIOCookMode(struct ttystatics *tp)
-{
-	/*
-	 ** We can't handle tm.c_mstate != 0 on SCO
-	 ** We can't handle mapping
-	 ** We can't handle non-ttwrite line disc.
-	 ** We can't handle lflag XCASE
-	 ** We can handle oflag OPOST & (OCRNL, ONLCR, TAB3)
-	 */
-
-#ifdef CHECK
-	CheckTtyP(tp);
-#endif
-	if (!(tp->tm.c_oflag & OPOST))	/* No post processing */
-		return COOK_RAW;	/* Raw mode o/p */
-
-	if (tp->tm.c_lflag & XCASE)
-		return COOK_WELL;	/* Use line disc */
-
-	if (tp->tm.c_oflag & ~(OPOST | ONLCR | OCRNL | TAB3))
-		return COOK_WELL;	/* Use line disc for strange modes */
-
-	if (tp->tm.c_oflag == OPOST)	/* If only OPOST is set, do RAW */
-		return COOK_RAW;
-
-	/*
-	 ** So, we need to output process!
-	 */
-	return COOK_MEDIUM;
-}
-#endif
 
 static void RIOClearUp(PortP)
 struct Port *PortP;
@@ -776,11 +673,6 @@ int RIOShortCommand(struct rio_info *p, 
 	unsigned long flags;
 
 	rio_dprintk(RIO_DEBUG_TTY, "entering shortcommand.\n");
-#ifdef CHECK
-	CheckPortP(PortP);
-	if (len < 1 || len > 2)
-		cprintf(("STUPID LENGTH %d\n", len));
-#endif
 
 	if (PortP->State & RIO_DELETED) {
 		rio_dprintk(RIO_DEBUG_TTY, "Short command to deleted RTA ignored\n");
@@ -852,478 +744,3 @@ int RIOShortCommand(struct rio_info *p, 
 }
 
 
-#if 0
-/*
-** This is an ioctl interface. This is the twentieth century. You know what
-** its all about.
-*/
-int riotioctl(struct rio_info *p, struct tty_struct *tty, int cmd, caddr_t arg)
-{
-	register struct Port *PortP;
-	register struct ttystatics *tp;
-	int current;
-	int ParamSemIncremented = 0;
-	int old_oflag, old_cflag, old_iflag, changed, oldcook;
-	int i;
-	unsigned char sio_regs[5];	/* Here be magic */
-	short vpix_cflag;
-	short divisor;
-	int baud;
-	uint SysPort = rio_minor(tty);
-	int Modem = rio_ismodem(tty);
-	int ioctl_processed;
-
-	rio_dprintk(RIO_DEBUG_TTY, "port ioctl SysPort %d command 0x%x argument 0x%x %s\n", SysPort, cmd, arg, Modem ? "Modem" : "tty");
-
-	if (SysPort >= RIO_PORTS) {
-		rio_dprintk(RIO_DEBUG_TTY, "Bad port number %d\n", SysPort);
-		return -ENXIO;
-	}
-
-	PortP = p->RIOPortp[SysPort];
-	tp = PortP->TtyP;
-
-	rio_spin_lock_irqsave(&PortP->portSem, flags);
-
-#ifdef STATS
-	PortP->Stat.IoctlCnt++;
-#endif
-
-	if (PortP->State & RIO_DELETED) {
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return -EIO;
-	}
-
-
-	if (p->RIOHalted) {
-		RIOClearUp(PortP);
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return -EIO;
-	}
-
-	/*
-	 ** Count ioctls for port statistics reporting
-	 */
-	if (PortP->statsGather)
-		PortP->ioctls++;
-
-	/*
-	 ** Specialix RIO Ioctl calls
-	 */
-	switch (cmd) {
-
-	case TCRIOTRIAD:
-		if (arg)
-			PortP->State |= RIO_TRIAD_MODE;
-		else
-			PortP->State &= ~RIO_TRIAD_MODE;
-		/*
-		 ** Normally, when istrip is set on a port, a config is
-		 ** sent to the RTA instructing the CD1400 to do the
-		 ** stripping. In TRIAD mode, the interrupt receive routine
-		 ** must do the stripping instead, since it has to detect
-		 ** an 8 bit function key sequence. If istrip is set with
-		 ** TRIAD mode on(off), and 8 bit data is being read by
-		 ** the port, the user then turns TRIAD mode off(on), the RTA
-		 ** must be reconfigured (not) to do the stripping.
-		 ** Hence we call RIOParam here.
-		 */
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-	case TCRIOTSTATE:
-		rio_dprintk(RIO_DEBUG_TTY, "tbusy/tstop monitoring %sabled\n", arg ? "en" : "dis");
-		/* MonitorTstate = 0 ; */
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-	case TCRIOSTATE:	/* current state of Modem input pins */
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOSTATE\n");
-		if (RIOPreemptiveCmd(p, PortP, MGET) == RIO_FAIL)
-			rio_dprintk(RIO_DEBUG_TTY, "TCRIOSTATE command failed\n");
-		PortP->State |= RIO_BUSY;
-		current = PortP->ModemState;
-		if (copyout((caddr_t) & current, (int) arg, sizeof(current)) == COPYFAIL) {
-			rio_dprintk(RIO_DEBUG_TTY, "Copyout failed\n");
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-			pseterr(EFAULT);
-		}
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOMBIS:	/* Set modem lines */
-	case TCRIOMBIC:	/* Clear modem lines */
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOMBIS/TCRIOMBIC\n");
-		if (cmd == TCRIOMBIS) {
-			uint state;
-			state = (uint) arg;
-			PortP->ModemState |= (ushort) state;
-			PortP->ModemLines = (ulong) arg;
-			if (RIOPreemptiveCmd(p, PortP, MBIS) == RIO_FAIL)
-				rio_dprintk(RIO_DEBUG_TTY, "TCRIOMBIS command failed\n");
-		} else {
-			uint state;
-
-			state = (uint) arg;
-			PortP->ModemState &= ~(ushort) state;
-			PortP->ModemLines = (ulong) arg;
-			if (RIOPreemptiveCmd(p, PortP, MBIC) == RIO_FAIL)
-				rio_dprintk(RIO_DEBUG_TTY, "TCRIOMBIC command failed\n");
-		}
-		PortP->State |= RIO_BUSY;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOXPON:	/* set Xprint ON string */
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOXPON\n");
-		if (copyin((int) arg, (caddr_t) PortP->Xprint.XpOn, MAX_XP_CTRL_LEN) == COPYFAIL) {
-			rio_dprintk(RIO_DEBUG_TTY, "Copyin failed\n");
-			PortP->Xprint.XpOn[0] = '\0';
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-			pseterr(EFAULT);
-		}
-		PortP->Xprint.XpOn[MAX_XP_CTRL_LEN - 1] = '\0';
-		PortP->Xprint.XpLen = strlen(PortP->Xprint.XpOn) + strlen(PortP->Xprint.XpOff);
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOXPOFF:	/* set Xprint OFF string */
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOXPOFF\n");
-		if (copyin((int) arg, (caddr_t) PortP->Xprint.XpOff, MAX_XP_CTRL_LEN) == COPYFAIL) {
-			rio_dprintk(RIO_DEBUG_TTY, "Copyin failed\n");
-			PortP->Xprint.XpOff[0] = '\0';
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-			pseterr(EFAULT);
-		}
-		PortP->Xprint.XpOff[MAX_XP_CTRL_LEN - 1] = '\0';
-		PortP->Xprint.XpLen = strlen(PortP->Xprint.XpOn) + strlen(PortP->Xprint.XpOff);
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOXPCPS:	/* set Xprint CPS string */
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOXPCPS\n");
-		if ((uint) arg > p->RIOConf.MaxXpCps || (uint) arg < p->RIOConf.MinXpCps) {
-			rio_dprintk(RIO_DEBUG_TTY, "%d CPS out of range\n", arg);
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-			pseterr(EINVAL);
-			return 0;
-		}
-		PortP->Xprint.XpCps = (uint) arg;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOXPRINT:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOXPRINT\n");
-		if (copyout((caddr_t) & PortP->Xprint, (int) arg, sizeof(struct Xprint)) == COPYFAIL) {
-			rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-			pseterr(EFAULT);
-		}
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOIXANYON:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOIXANYON\n");
-		PortP->Config |= RIO_IXANY;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOIXANYOFF:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOIXANYOFF\n");
-		PortP->Config &= ~RIO_IXANY;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOIXONON:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOIXONON\n");
-		PortP->Config |= RIO_IXON;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-	case TCRIOIXONOFF:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOIXONOFF\n");
-		PortP->Config &= ~RIO_IXON;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		return 0;
-
-/*
-** 15.10.1998 ARG - ESIL 0761 part fix
-** Added support for CTS and RTS flow control ioctls :
-*/
-	case TCRIOCTSFLOWEN:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOCTSFLOWEN\n");
-		PortP->Config |= RIO_CTSFLOW;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-	case TCRIOCTSFLOWDIS:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIOCTSFLOWDIS\n");
-		PortP->Config &= ~RIO_CTSFLOW;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-	case TCRIORTSFLOWEN:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIORTSFLOWEN\n");
-		PortP->Config |= RIO_RTSFLOW;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-	case TCRIORTSFLOWDIS:
-		rio_dprintk(RIO_DEBUG_TTY, "TCRIORTSFLOWDIS\n");
-		PortP->Config &= ~RIO_RTSFLOW;
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		return 0;
-
-/* end ESIL 0761 part fix */
-
-	}
-
-
-	/* Lynx IOCTLS */
-	switch (cmd) {
-	case TIOCSETP:
-	case TIOCSETN:
-	case OTIOCSETP:
-	case OTIOCSETN:
-		ioctl_processed++;
-		ttyseth(PortP, tp, (struct old_sgttyb *) arg);
-		break;
-	case TCSETA:
-	case TCSETAW:
-	case TCSETAF:
-		ioctl_processed++;
-		rio_dprintk(RIO_DEBUG_TTY, "NON POSIX ioctl\n");
-		ttyseth_pv(PortP, tp, (struct termios *) arg, 0);
-		break;
-	case TCSETAP:		/* posix tcsetattr() */
-	case TCSETAWP:		/* posix tcsetattr() */
-	case TCSETAFP:		/* posix tcsetattr() */
-		rio_dprintk(RIO_DEBUG_TTY, "NON POSIX SYSV ioctl\n");
-		ttyseth_pv(PortP, tp, (struct termios *) arg, 1);
-		ioctl_processed++;
-		break;
-	}
-
-	/*
-	 ** If its any of the commands that require the port to be in the
-	 ** non-busy state wait until all output has drained
-	 */
-	if (!ioctl_processed)
-		switch (cmd) {
-		case TCSETAW:
-		case TCSETAF:
-		case TCSETA:
-		case TCSBRK:
-#define OLD_POSIX ('x' << 8)
-#define OLD_POSIX_SETA (OLD_POSIX | 2)
-#define OLD_POSIX_SETAW (OLD_POSIX | 3)
-#define OLD_POSIX_SETAF (OLD_POSIX | 4)
-#define NEW_POSIX (('i' << 24) | ('X' << 16))
-#define NEW_POSIX_SETA (NEW_POSIX | 2)
-#define NEW_POSIX_SETAW (NEW_POSIX | 3)
-#define NEW_POSIX_SETAF (NEW_POSIX | 4)
-		case OLD_POSIX_SETA:
-		case OLD_POSIX_SETAW:
-		case OLD_POSIX_SETAF:
-		case NEW_POSIX_SETA:
-		case NEW_POSIX_SETAW:
-		case NEW_POSIX_SETAF:
-#ifdef TIOCSETP
-		case TIOCSETP:
-#endif
-		case TIOCSETD:
-		case TIOCSETN:
-			rio_dprintk(RIO_DEBUG_TTY, "wait for non-BUSY, semaphore set\n");
-			/*
-			 ** Wait for drain here, at least as far as the double buffer
-			 ** being empty.
-			 */
-			/* XXX Does the above comment mean that this has
-			   still to be implemented? -- REW */
-			/* XXX Is the locking OK together with locking
-			   in txenable? (Deadlock?) -- REW */
-
-			RIOTxEnable((char *) PortP);
-			break;
-		default:
-			break;
-		}
-
-	old_cflag = tp->tm.c_cflag;
-	old_iflag = tp->tm.c_iflag;
-	old_oflag = tp->tm.c_oflag;
-	oldcook = PortP->CookMode;
-
-	if (p->RIOHalted) {
-		RIOClearUp(PortP);
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		pseterr(EIO);
-		return 0;
-	}
-
-	PortP->FlushCmdBodge = 0;
-
-	/*
-	 ** If the port is locked, and it is reconfigured, we want
-	 ** to restore the state of the tty structure so the change is NOT
-	 ** made.
-	 */
-	if (PortP->Lock) {
-		tp->tm.c_iflag = PortP->StoredTty.iflag;
-		tp->tm.c_oflag = PortP->StoredTty.oflag;
-		tp->tm.c_cflag = PortP->StoredTty.cflag;
-		tp->tm.c_lflag = PortP->StoredTty.lflag;
-		tp->tm.c_line = PortP->StoredTty.line;
-		for (i = 0; i < NCC + 1; i++)
-			tp->tm.c_cc[i] = PortP->StoredTty.cc[i];
-	} else {
-		/*
-		 ** If the port is set to store the parameters, and it is
-		 ** reconfigured, we want to save the current tty struct so it
-		 ** may be restored on the next open.
-		 */
-		if (PortP->Store) {
-			PortP->StoredTty.iflag = tp->tm.c_iflag;
-			PortP->StoredTty.oflag = tp->tm.c_oflag;
-			PortP->StoredTty.cflag = tp->tm.c_cflag;
-			PortP->StoredTty.lflag = tp->tm.c_lflag;
-			PortP->StoredTty.line = tp->tm.c_line;
-			for (i = 0; i < NCC + 1; i++)
-				PortP->StoredTty.cc[i] = tp->tm.c_cc[i];
-		}
-	}
-
-	changed = (tp->tm.c_cflag != old_cflag) || (tp->tm.c_iflag != old_iflag) || (tp->tm.c_oflag != old_oflag);
-
-	PortP->CookMode = RIOCookMode(tp);	/* Set new cooking mode */
-
-	rio_dprintk(RIO_DEBUG_TTY, "RIOIoctl changed %d newcook %d oldcook %d\n", changed, PortP->CookMode, oldcook);
-
-#ifdef MODEM_SUPPORT
-	/*
-	 ** kludge to force CARR_ON if CLOCAL set
-	 */
-	if ((tp->tm.c_cflag & CLOCAL) || (PortP->ModemState & MSVR1_CD)) {
-		tp->tm.c_state |= CARR_ON;
-		wakeup((caddr_t) & tp->tm.c_canq);
-	}
-#endif
-
-	if (p->RIOHalted) {
-		RIOClearUp(PortP);
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		pseterr(EIO);
-		return 0;
-	}
-	/*
-	 ** Re-configure if modes or cooking have changed
-	 */
-	if (changed || oldcook != PortP->CookMode || (ioctl_processed)) {
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		rio_dprintk(RIO_DEBUG_TTY, "Ioctl changing the PORT settings\n");
-		RIOParam(PortP, CONFIG, Modem, OK_TO_SLEEP);
-		rio_spin_lock_irqsave(&PortP->portSem, flags);
-	}
-
-	if (p->RIOHalted) {
-		rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-		RIOClearUp(PortP);
-		pseterr(EIO);
-		return 0;
-	}
-	rio_spin_unlock_irqrestore(&PortP->portSem, flags);
-	return 0;
-}
-
-/*
-	ttyseth -- set hardware dependent tty settings
-*/
-void ttyseth(PortP, s, sg)
-struct Port *PortP;
-struct ttystatics *s;
-struct old_sgttyb *sg;
-{
-	struct old_sgttyb *tsg;
-	struct termios *tp = &s->tm;
-
-	tsg = &s->sg;
-
-	if (sg->sg_flags & (EVENP | ODDP)) {
-		tp->c_cflag &= PARENB;
-		if (sg->sg_flags & EVENP) {
-			if (sg->sg_flags & ODDP) {
-				tp->c_cflag &= V_CS7;
-				tp->c_cflag &= ~PARENB;
-			} else {
-				tp->c_cflag &= V_CS7;
-				tp->c_cflag &= PARENB;
-				tp->c_cflag &= PARODD;
-			}
-		} else if (sg->sg_flags & ODDP) {
-			tp->c_cflag &= V_CS7;
-			tp->c_cflag &= PARENB;
-			tp->c_cflag &= PARODD;
-		} else {
-			tp->c_cflag &= V_CS7;
-			tp->c_cflag &= PARENB;
-		}
-	}
-/*
- * Use ispeed as the desired speed.  Most implementations don't handle 
- * separate input and output speeds very well. If the RIO handles this, 
- * I will have to use separate sets of flags to store them in the 
- * Port structure.
- */
-	if (!sg->sg_ospeed)
-		sg->sg_ospeed = sg->sg_ispeed;
-	else
-		sg->sg_ispeed = sg->sg_ospeed;
-	if (sg->sg_ispeed > V_EXTB)
-		sg->sg_ispeed = V_EXTB;
-	if (sg->sg_ispeed < V_B0)
-		sg->sg_ispeed = V_B0;
-	*tsg = *sg;
-	tp->c_cflag = (tp->c_cflag & ~V_CBAUD) | conv_bv[(int) sg->sg_ispeed];
-}
-
-/*
-	ttyseth_pv -- set hardware dependent tty settings using either the
-			POSIX termios structure or the System V termio structure.
-				sysv = 0 => (POSIX):	 struct termios *sg
-				sysv != 0 => (System V): struct termio *sg
-*/
-static void ttyseth_pv(PortP, s, sg, sysv)
-struct Port *PortP;
-struct ttystatics *s;
-struct termios *sg;
-int sysv;
-{
-	int speed;
-	unsigned char csize;
-	unsigned char cread;
-	unsigned int lcr_flags;
-	int ps;
-
-	if (sysv) {
-		/* sg points to a System V termio structure */
-		csize = ((struct termio *) sg)->c_cflag & CSIZE;
-		cread = ((struct termio *) sg)->c_cflag & CREAD;
-		speed = conv_vb[((struct termio *) sg)->c_cflag & V_CBAUD];
-	} else {
-		/* sg points to a POSIX termios structure */
-		csize = sg->c_cflag & CSIZE;
-		cread = sg->c_cflag & CREAD;
-		speed = conv_vb[sg->c_cflag & V_CBAUD];
-	}
-	if (s->sg.sg_ispeed != speed || s->sg.sg_ospeed != speed) {
-		s->sg.sg_ispeed = speed;
-		s->sg.sg_ospeed = speed;
-		s->tm.c_cflag = (s->tm.c_cflag & ~V_CBAUD) | conv_bv[(int) s->sg.sg_ispeed];
-	}
-}
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/riowinif.h linux-2.6.16-rc1/drivers/char/rio/riowinif.h
--- linux-2.6.15-git12/drivers/char/rio/riowinif.h	2006-01-17 08:21:31.466845619 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riowinif.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,1329 +0,0 @@
-/************************************************************************/
-/*									*/
-/*	Title		:	RIO Shared Memory Window Inteface	*/
-/*									*/
-/*	Author		:	N.P.Vassallo				*/
-/*									*/
-/*	Creation	:	7th June 1999				*/
-/*									*/
-/*	Version		:	1.0.0					*/
-/*									*/
-/*	Copyright	:	(c) Specialix International Ltd. 1999	*
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *									*/
-/*	Description	:	Prototypes, structures and definitions	*/
-/*				describing RIO host card shared	memory	*/
-/*				window interface structures:		*/
-/*					PARMMAP				*/
-/*					RUP				*/
-/*					PHB				*/
-/*					LPB				*/
-/*					PKT				*/
-/*									*/
-/************************************************************************/
-
-/* History...
-
-1.0.0	07/06/99 NPV	Creation. (based on PARMMAP.H)
-
-*/
-
-#ifndef	_riowinif_h		/* If RIOWINDIF.H not already defined */
-#define	_riowinif_h    1
-
-/*****************************************************************************
-********************************             *********************************
-********************************   General   *********************************
-********************************             *********************************
-*****************************************************************************/
-
-#define	TPNULL		((_u16)(0x8000))
-
-/*****************************************************************************
-********************************              ********************************
-********************************   PARM_MAP   ********************************
-********************************              ********************************
-*****************************************************************************/
-
-/* The PARM_MAP structure defines global values relating to the Host Card / RTA
-   and is the main structure from which all other structures are referenced. */
-
-typedef struct _PARM_MAP {
-	_u16 phb_ptr;		/* 0x00 Pointer to the PHB array */
-	_u16 phb_num_ptr;	/* 0x02 Ptr to Number of PHB's */
-	_u16 free_list;		/* 0x04 Free List pointer */
-	_u16 free_list_end;	/* 0x06 Free List End pointer */
-	_u16 q_free_list_ptr;	/* 0x08 Ptr to Q_BUF variable */
-	_u16 unit_id_ptr;	/* 0x0A Unit Id */
-	_u16 link_str_ptr;	/* 0x0C Link Structure Array */
-	_u16 bootloader_1;	/* 0x0E 1st Stage Boot Loader */
-	_u16 bootloader_2;	/* 0x10 2nd Stage Boot Loader */
-	_u16 port_route_map_ptr;	/* 0x12 Port Route Map */
-	_u16 route_ptr;		/* 0x14 Route Map */
-	_u16 map_present;	/* 0x16 Route Map present */
-	_u16 pkt_num;		/* 0x18 Total number of packets */
-	_u16 q_num;		/* 0x1A Total number of Q packets */
-	_u16 buffers_per_port;	/* 0x1C Number of buffers per port */
-	_u16 heap_size;		/* 0x1E Initial size of heap */
-	_u16 heap_left;		/* 0x20 Current Heap left */
-	_u16 error;		/* 0x22 Error code */
-	_u16 tx_max;		/* 0x24 Max number of tx pkts per phb */
-	_u16 rx_max;		/* 0x26 Max number of rx pkts per phb */
-	_u16 rx_limit;		/* 0x28 For high / low watermarks */
-	_u16 links;		/* 0x2A Links to use */
-	_u16 timer;		/* 0x2C Interrupts per second */
-	_u16 rups;		/* 0x2E Pointer to the RUPs */
-	_u16 max_phb;		/* 0x30 Mostly for debugging */
-	_u16 living;		/* 0x32 Just increments!! */
-	_u16 init_done;		/* 0x34 Initialisation over */
-	_u16 booting_link;	/* 0x36 */
-	_u16 idle_count;	/* 0x38 Idle time counter */
-	_u16 busy_count;	/* 0x3A Busy counter */
-	_u16 idle_control;	/* 0x3C Control Idle Process */
-	_u16 tx_intr;		/* 0x3E TX interrupt pending */
-	_u16 rx_intr;		/* 0x40 RX interrupt pending */
-	_u16 rup_intr;		/* 0x42 RUP interrupt pending */
-
-} PARM_MAP;
-
-/* Same thing again, but defined as offsets... */
-
-#define	PM_phb_ptr		0x00	/* 0x00 Pointer to the PHB array */
-#define	PM_phb_num_ptr		0x02	/* 0x02 Ptr to Number of PHB's */
-#define	PM_free_list		0x04	/* 0x04 Free List pointer */
-#define	PM_free_list_end	0x06	/* 0x06 Free List End pointer */
-#define	PM_q_free_list_ptr	0x08	/* 0x08 Ptr to Q_BUF variable */
-#define	PM_unit_id_ptr		0x0A	/* 0x0A Unit Id */
-#define	PM_link_str_ptr		0x0C	/* 0x0C Link Structure Array */
-#define	PM_bootloader_1		0x0E	/* 0x0E 1st Stage Boot Loader */
-#define	PM_bootloader_2		0x10	/* 0x10 2nd Stage Boot Loader */
-#define	PM_port_route_map_ptr	0x12	/* 0x12 Port Route Map */
-#define	PM_route_ptr		0x14	/* 0x14 Route Map */
-#define	PM_map_present		0x16	/* 0x16 Route Map present */
-#define	PM_pkt_num		0x18	/* 0x18 Total number of packets */
-#define	PM_q_num		0x1A	/* 0x1A Total number of Q packets */
-#define	PM_buffers_per_port	0x1C	/* 0x1C Number of buffers per port */
-#define	PM_heap_size		0x1E	/* 0x1E Initial size of heap */
-#define	PM_heap_left		0x20	/* 0x20 Current Heap left */
-#define	PM_error		0x22	/* 0x22 Error code */
-#define	PM_tx_max		0x24	/* 0x24 Max number of tx pkts per phb */
-#define	PM_rx_max		0x26	/* 0x26 Max number of rx pkts per phb */
-#define	PM_rx_limit		0x28	/* 0x28 For high / low watermarks */
-#define	PM_links		0x2A	/* 0x2A Links to use */
-#define	PM_timer		0x2C	/* 0x2C Interrupts per second */
-#define	PM_rups			0x2E	/* 0x2E Pointer to the RUPs */
-#define	PM_max_phb		0x30	/* 0x30 Mostly for debugging */
-#define	PM_living		0x32	/* 0x32 Just increments!! */
-#define	PM_init_done		0x34	/* 0x34 Initialisation over */
-#define	PM_booting_link		0x36	/* 0x36 */
-#define	PM_idle_count		0x38	/* 0x38 Idle time counter */
-#define	PM_busy_count		0x3A	/* 0x3A Busy counter */
-#define	PM_idle_control		0x3C	/* 0x3C Control Idle Process */
-#define	PM_tx_intr		0x3E	/* 0x4E TX interrupt pending */
-#define	PM_rx_intr		0x40	/* 0x40 RX interrupt pending */
-#define	PM_rup_intr		0x42	/* 0x42 RUP interrupt pending */
-#define	sizeof_PARM_MAP		0x44	/* structure size = 0x44 */
-
-/* PARM_MAP.error definitions... */
-#define	E_NO_ERROR		0x00
-#define	E_PROCESS_NOT_INIT	0x01
-#define	E_LINK_TIMEOUT		0x02
-#define	E_NO_ROUTE		0x03
-#define	E_CONFUSED		0x04
-#define	E_HOME			0x05
-#define	E_CSUM_FAIL		0x06
-#define	E_DISCONNECTED		0x07
-#define	E_BAD_RUP		0x08
-#define	E_NO_VIRGIN		0x09
-#define	E_BOOT_RUP_BUSY		0x10
-#define	E_CHANALLOC		0x80
-#define	E_POLL_ALLOC		0x81
-#define	E_LTTWAKE		0x82
-#define	E_LTT_ALLOC		0x83
-#define	E_LRT_ALLOC		0x84
-#define	E_CIRRUS		0x85
-#define	E_MONITOR		0x86
-#define	E_PHB_ALLOC		0x87
-#define	E_ARRAY_ALLOC		0x88
-#define	E_QBUF_ALLOC		0x89
-#define	E_PKT_ALLOC		0x8a
-#define	E_GET_TX_Q_BUF		0x8b
-#define	E_GET_RX_Q_BUF		0x8c
-#define	E_MEM_OUT		0x8d
-#define	E_MMU_INIT		0x8e
-#define	E_LTT_INIT		0x8f
-#define	E_LRT_INIT		0x90
-#define	E_LINK_RUN		0x91
-#define	E_MONITOR_ALLOC		0x92
-#define	E_MONITOR_INIT		0x93
-#define	E_POLL_INIT		0x94
-
-/* PARM_MAP.links definitions... */
-#define	RIO_LINK_ENABLE	0x80FF
-
-/*****************************************************************************
-**********************************         ***********************************
-**********************************   RUP   ***********************************
-**********************************         ***********************************
-*****************************************************************************/
-
-/* The RUP (Remote Unit Port) structure relates to the Remote Terminal Adapters
-   attached to the system and there is normally an array of MAX_RUPS (=16) structures
-   in a host card, defined by PARM_MAP->rup. */
-
-typedef struct _RUP {
-	_u16 txpkt;		/* 0x00 Outgoing packet */
-	_u16 rxpkt;		/* 0x02 ncoming packet */
-	_u16 link;		/* 0x04 Which link to send packet down ? */
-	_u8 rup_dest_unit[2];	/* 0x06 Destination Unit */
-	_u16 handshake;		/* 0x08 Handshaking */
-	_u16 timeout;		/* 0x0A Timeout */
-	_u16 status;		/* 0x0C Status */
-	_u16 txcontrol;		/* 0x0E Transmit control */
-	_u16 rxcontrol;		/* 0x10 Receive control */
-
-} RUP;
-
-/* Same thing again, but defined as offsets... */
-
-#define	RUP_txpkt		0x00	/* 0x00 Outgoing packet */
-#define	RUP_rxpkt		0x02	/* 0x02 Incoming packet */
-#define	RUP_link		0x04	/* 0x04 Which link to send packet down ? */
-#define	RUP_rup_dest_unit	0x06	/* 0x06 Destination Unit */
-#define	RUP_handshake		0x08	/* 0x08 Handshaking */
-#define	RUP_timeout		0x0A	/* 0x0A Timeout */
-#define	RUP_status		0x0C	/* 0x0C Status */
-#define	RUP_txcontrol		0x0E	/* 0x0E Transmit control */
-#define	RUP_rxcontrol		0x10	/* 0x10 Receive control */
-#define	sizeof_RUP		0x12	/* structure size = 0x12 */
-
-#define MAX_RUP			16
-
-/* RUP.txcontrol definitions... */
-#define	TX_RUP_INACTIVE		0	/* Nothing to transmit */
-#define	TX_PACKET_READY		1	/* Transmit packet ready */
-#define	TX_LOCK_RUP		2	/* Transmit side locked */
-
-/* RUP.txcontrol definitions... */
-#define	RX_RUP_INACTIVE		0	/* Nothing received */
-#define	RX_PACKET_READY		1	/* Packet received */
-
-#define	RUP_NO_OWNER		0xFF	/* RUP not owned by any process */
-
-/*****************************************************************************
-**********************************         ***********************************
-**********************************   PHB   ***********************************
-**********************************         ***********************************
-*****************************************************************************/
-
-/* The PHB (Port Header Block) structure relates to the serial ports attached
-   to the system and there is normally an array of MAX_PHBS (=128) structures
-   in a host card, defined by PARM_MAP->phb_ptr and PARM_MAP->phb_num_ptr. */
-
-typedef struct _PHB {
-	_u16 source;		/* 0x00 Location of the PHB in the host card */
-	_u16 handshake;		/* 0x02 Used to manage receive packet flow control */
-	_u16 status;		/* 0x04 Internal port transmit/receive status */
-	_u16 timeout;		/* 0x06 Time period to wait for an ACK */
-	_u16 link;		/* 0x08 The host link associated with the PHB */
-	_u16 destination;	/* 0x0A Location of the remote port on the network */
-
-	_u16 tx_start;		/* 0x0C first entry in the packet array for transmit packets */
-	_u16 tx_end;		/* 0x0E last entry in the packet array for transmit packets */
-	_u16 tx_add;		/* 0x10 position in the packet array for new transmit packets */
-	_u16 tx_remove;		/* 0x12 current position in the packet pointer array */
-
-	_u16 rx_start;		/* 0x14 first entry in the packet array for receive packets */
-	_u16 rx_end;		/* 0x16 last entry in the packet array for receive packets */
-	_u16 rx_add;		/* 0x18 position in the packet array for new receive packets */
-	_u16 rx_remove;		/* 0x1A current position in the packet pointer array */
-
-} PHB;
-
-/* Same thing again, but defined as offsets... */
-
-#define	PHB_source		0x00	/* 0x00 Location of the PHB in the host card */
-#define	PHB_handshake		0x02	/* 0x02 Used to manage receive packet flow control */
-#define	PHB_status		0x04	/* 0x04 Internal port transmit/receive status */
-#define	PHB_timeout		0x06	/* 0x06 Time period to wait for an ACK */
-#define	PHB_link		0x08	/* 0x08 The host link associated with the PHB */
-#define	PHB_destination		0x0A	/* 0x0A Location of the remote port on the network */
-#define	PHB_tx_start		0x0C	/* 0x0C first entry in the packet array for transmit packets */
-#define	PHB_tx_end		0x0E	/* 0x0E last entry in the packet array for transmit packets */
-#define	PHB_tx_add		0x10	/* 0x10 position in the packet array for new transmit packets */
-#define	PHB_tx_remove		0x12	/* 0x12 current position in the packet pointer array */
-#define	PHB_rx_start		0x14	/* 0x14 first entry in the packet array for receive packets */
-#define	PHB_rx_end		0x16	/* 0x16 last entry in the packet array for receive packets */
-#define	PHB_rx_add		0x18	/* 0x18 position in the packet array for new receive packets */
-#define	PHB_rx_remove		0x1A	/* 0x1A current position in the packet pointer array */
-#define	sizeof_PHB		0x1C	/* structure size = 0x1C */
-
-/* PHB.handshake definitions... */
-#define	PHB_HANDSHAKE_SET	0x0001	/* Set by LRT */
-#define	PHB_HANDSHAKE_RESET	0x0002	/* Set by ISR / driver */
-#define	PHB_HANDSHAKE_FLAGS	(PHB_HANDSHAKE_RESET|PHB_HANDSHAKE_SET)
-						/* Reset by ltt */
-
-#define	MAX_PHB			128	/* range 0-127 */
-
-/*****************************************************************************
-**********************************         ***********************************
-**********************************   LPB   ***********************************
-**********************************         ***********************************
-*****************************************************************************/
-
-/* The LPB (Link Parameter Block) structure relates to a RIO Network Link
-   and there is normally an array of MAX_LINKS (=4) structures in a host card,
-   defined by PARM_MAP->link_str_ptr. */
-
-typedef struct _LPB {
-	_u16 link_number;	/* 0x00 Link Number */
-	_u16 in_ch;		/* 0x02 Link In Channel */
-	_u16 out_ch;		/* 0x04 Link Out Channel */
-	_u8 attached_serial[4];	/* 0x06 Attached serial number */
-	_u8 attached_host_serial[4];	/* 0x0A Serial number of Host who booted other end */
-	_u16 descheduled;	/* 0x0E Currently Descheduled */
-	_u16 state;		/* 0x10 Current state */
-	_u16 send_poll;		/* 0x12 Send a Poll Packet */
-	_u16 ltt_p;		/* 0x14 Process Descriptor */
-	_u16 lrt_p;		/* 0x16 Process Descriptor */
-	_u16 lrt_status;	/* 0x18 Current lrt status */
-	_u16 ltt_status;	/* 0x1A Current ltt status */
-	_u16 timeout;		/* 0x1C Timeout value */
-	_u16 topology;		/* 0x1E Topology bits */
-	_u16 mon_ltt;		/* 0x20 */
-	_u16 mon_lrt;		/* 0x22 */
-	_u16 num_pkts;		/* 0x24 */
-	_u16 add_packet_list;	/* 0x26 Add packets to here */
-	_u16 remove_packet_list;	/* 0x28 Send packets from here */
-
-	_u16 lrt_fail_chan;	/* 0x2A Lrt's failure channel */
-	_u16 ltt_fail_chan;	/* 0x2C Ltt's failure channel */
-
-	RUP rup;		/* 0x2E RUP structure for HOST to driver comms */
-	RUP link_rup;		/* 0x40 RUP for the link (POLL, topology etc.) */
-	_u16 attached_link;	/* 0x52 Number of attached link */
-	_u16 csum_errors;	/* 0x54 csum errors */
-	_u16 num_disconnects;	/* 0x56 number of disconnects */
-	_u16 num_sync_rcvd;	/* 0x58 # sync's received */
-	_u16 num_sync_rqst;	/* 0x5A # sync requests */
-	_u16 num_tx;		/* 0x5C Num pkts sent */
-	_u16 num_rx;		/* 0x5E Num pkts received */
-	_u16 module_attached;	/* 0x60 Module tpyes of attached */
-	_u16 led_timeout;	/* 0x62 LED timeout */
-	_u16 first_port;	/* 0x64 First port to service */
-	_u16 last_port;		/* 0x66 Last port to service */
-
-} LPB;
-
-/* Same thing again, but defined as offsets... */
-
-#define	LPB_link_number		0x00	/* 0x00 Link Number */
-#define	LPB_in_ch		0x02	/* 0x02 Link In Channel */
-#define	LPB_out_ch		0x04	/* 0x04 Link Out Channel */
-#define	LPB_attached_serial	0x06	/* 0x06 Attached serial number */
-#define	LPB_attached_host_serial 0x0A	/* 0x0A Serial number of Host who booted other end */
-#define	LPB_descheduled		0x0E	/* 0x0E Currently Descheduled */
-#define	LPB_state		0x10	/* 0x10 Current state */
-#define	LPB_send_poll		0x12	/* 0x12 Send a Poll Packet */
-#define	LPB_ltt_p		0x14	/* 0x14 Process Descriptor */
-#define	LPB_lrt_p		0x16	/* 0x16 Process Descriptor */
-#define	LPB_lrt_status		0x18	/* 0x18 Current lrt status */
-#define	LPB_ltt_status		0x1A	/* 0x1A Current ltt status */
-#define	LPB_timeout		0x1C	/* 0x1C Timeout value */
-#define	LPB_topology		0x1E	/* 0x1E Topology bits */
-#define	LPB_mon_ltt		0x20	/* 0x20 */
-#define	LPB_mon_lrt		0x22	/* 0x22 */
-#define	LPB_num_pkts		0x24	/* 0x24 */
-#define	LPB_add_packet_list	0x26	/* 0x26 Add packets to here */
-#define	LPB_remove_packet_list	0x28	/* 0x28 Send packets from here */
-#define	LPB_lrt_fail_chan	0x2A	/* 0x2A Lrt's failure channel */
-#define	LPB_ltt_fail_chan	0x2C	/* 0x2C Ltt's failure channel */
-#define	LPB_rup			0x2E	/* 0x2E RUP structure for HOST to driver comms */
-#define	LPB_link_rup		0x40	/* 0x40 RUP for the link (POLL, topology etc.) */
-#define	LPB_attached_link	0x52	/* 0x52 Number of attached link */
-#define	LPB_csum_errors		0x54	/* 0x54 csum errors */
-#define	LPB_num_disconnects	0x56	/* 0x56 number of disconnects */
-#define	LPB_num_sync_rcvd	0x58	/* 0x58 # sync's received */
-#define	LPB_num_sync_rqst	0x5A	/* 0x5A # sync requests */
-#define	LPB_num_tx		0x5C	/* 0x5C Num pkts sent */
-#define	LPB_num_rx		0x5E	/* 0x5E Num pkts received */
-#define	LPB_module_attached	0x60	/* 0x60 Module tpyes of attached */
-#define	LPB_led_timeout		0x62	/* 0x62 LED timeout */
-#define	LPB_first_port		0x64	/* 0x64 First port to service */
-#define	LPB_last_port		0x66	/* 0x66 Last port to service */
-#define	sizeof_LPB		0x68	/* structure size = 0x68 */
-
-#define	LINKS_PER_UNIT		4	/* number of links from a host */
-
-/*****************************************************************************
-********************************               *******************************
-********************************   FREE_LIST   *******************************
-********************************               *******************************
-*****************************************************************************/
-
-/* Used to overlay packet headers when allocating/freeing packets from the free list */
-
-typedef struct _FREE_LIST {
-	_u16 next;		/* 0x00 offset of next list item */
-	_u16 prev;		/* 0x02 offset of previous list item */
-
-} FREE_LIST;
-
-/* Same thing again, but defined as offsets... */
-
-#define	FL_next			0x00	/* 0x00 offset of next list item */
-#define	FL_prev			0x02	/* 0x02 offset of previous list item */
-
-/*****************************************************************************
-**********************************         ***********************************
-**********************************   PKT   ***********************************
-**********************************         ***********************************
-*****************************************************************************/
-
-/* The PKT is the main unit of communication between Host Cards and RTAs across
-   the RIO network.  */
-
-#define PKT_MAX_DATA_LEN   72	/* Size of packet data */
-
-typedef struct _PKT {
-	_u8 dest_unit;		/* 0x00 Destination Unit Id */
-	_u8 dest_port;		/* 0x01 Destination Port */
-	_u8 src_unit;		/* 0x02 Source Unit Id */
-	_u8 src_port;		/* 0x03 Source Port */
-	_u8 len;		/* 0x04 Length (in bytes) of data field */
-	_u8 control;		/* 0x05 */
-	_u8 data[PKT_MAX_DATA_LEN];	/* 0x06 Actual data */
-	_u16 csum;		/* 0x4E C-SUM */
-
-} PKT;
-
-/* Same thing again, but defined as offsets... */
-
-#define	PKT_dest_unit		0x00	/* 0x00 Destination Unit Id */
-#define	PKT_dest_port		0x01	/* 0x01 Destination Port */
-#define	PKT_src_unit		0x02	/* 0x02 Source Unit Id */
-#define	PKT_src_port		0x03	/* 0x03 Source Port */
-#define	PKT_len			0x04	/* 0x04 Length (in bytes) of data field */
-#define	PKT_control		0x05	/* 0x05 */
-#define	PKT_data		0x06	/* 0x06 Actual data */
-#define	PKT_csum		0x4E	/* 0x4E C-SUM */
-#define	sizeof_PKT		0x50	/* structure size = 0x50 */
-
-/* PKT.len definitions... */
-#define	PKT_CMD_BIT		0x80
-#define	PKT_CMD_DATA		0x80
-#define	PKT_LEN_MASK		0x7F
-
-/* PKT.control definitions... */
-#define	PKT_ACK			0x40
-#define	PKT_TGL			0x20
-#define	DATA_WNDW		0x10
-#define	PKT_TTL_MASK		0x0F
-#define	MAX_TTL			0x0F
-
-/*****************************************************************************
-*****************************                     ****************************
-*****************************   Control Packets   ****************************
-*****************************                     ****************************
-*****************************************************************************/
-
-/* The following definitions and structures define the control packets sent
-   between the driver and RIO Ports, RTAs and Host Cards. */
-
-#define	PRE_EMPTIVE		0x80	/* Pre-emptive command (sent via port's RUP) */
-
-/* "in-band" and "pre-emptive" port commands... */
-#define	OPEN			0x00	/* Driver->RIO Open a port */
-#define	CONFIG			0x01	/* Driver->RIO Configure a port */
-#define	MOPEN			0x02	/* Driver->RIO Modem open (wait for DCD) */
-#define	CLOSE			0x03	/* Driver->RIO Close a port */
-#define	WFLUSH			(0x04|PRE_EMPTIVE)	/* Driver->RIO Write flush */
-#define	RFLUSH			(0x05|PRE_EMPTIVE)	/* Driver->RIO Read flush */
-#define	RESUME			(0x06|PRE_EMPTIVE)	/* Driver->RIO Behave as if XON received */
-#define	SBREAK			0x07	/* Driver->RIO Start break */
-#define	EBREAK			0x08	/* Driver->RIO End break */
-#define	SUSPEND			(0x09|PRE_EMPTIVE)	/* Driver->RIO Behave as if XOFF received */
-#define	FCLOSE			(0x0A|PRE_EMPTIVE)	/* Driver->RIO Force close */
-#define	XPRINT			0x0B	/* Driver->RIO Xprint packet */
-#define	MBIS			(0x0C|PRE_EMPTIVE)	/* Driver->RIO Set modem lines */
-#define	MBIC			(0x0D|PRE_EMPTIVE)	/* Driver->RIO Clear modem lines */
-#define	MSET			(0x0E|PRE_EMPTIVE)	/* Driver->RIO Set modem lines */
-#define	PCLOSE			0x0F	/* Driver->RIO Pseudo close */
-#define	MGET			(0x10|PRE_EMPTIVE)	/* Driver->RIO Force update of modem status */
-#define	MEMDUMP			(0x11|PRE_EMPTIVE)	/* Driver->RIO DEBUG request for RTA memory */
-#define	READ_REGISTER		(0x12|PRE_EMPTIVE)	/* Driver->RIO DEBUG read CD1400 register */
-
-/* Remote Unit Port (RUP) packet definitions... (specified in PKT.dest_unit and PKT.src_unit) */
-#define	SYNC_RUP		0xFF	/* Download internal */
-#define	COMMAND_RUP		0xFE	/* Command ack/status */
-#define	ERROR_RUP		0xFD	/* Download internal */
-#define	POLL_RUP		0xFC	/* Download internal */
-#define	BOOT_RUP		0xFB	/* Used to boot RTAs */
-#define	ROUTE_RUP		0xFA	/* Used to specify routing/topology */
-#define	STATUS_RUP		0xF9	/* Not used */
-#define	POWER_RUP		0xF8	/* Download internal */
-
-/* COMMAND_RUP definitions... */
-#define	COMPLETE		(0x20|PRE_EMPTIVE)	/* RIO->Driver Command complete */
-#define	BREAK_RECEIVED		(0x21|PRE_EMPTIVE)	/* RIO->Driver Break received */
-#define	MODEM_STATUS		(0x22|PRE_EMPTIVE)	/* RIO->Driver Modem status change */
-
-/* BOOT_RUP definitions... */
-#define	BOOT_REQUEST		0x00	/* RIO->Driver Request for boot */
-#define	BOOT_ABORT		0x01	/* Driver->RIO Abort a boot */
-#define	BOOT_SEQUENCE		0x02	/* Driver->RIO Packet with firmware details */
-#define	BOOT_COMPLETED		0x03	/* RIO->Driver Boot completed */
-#define IFOAD			0x2F	/* Driver->RIO Shutdown/Reboot RTA (Fall Over And Die) */
-#define	IDENTIFY		0x30	/* Driver->RIO Identify RTA */
-#define	ZOMBIE			0x31	/* Driver->RIO Shutdown/Flash LEDs */
-#define	UFOAD			0x32	/* Driver->RIO Shutdown/Reboot neighbouring RTA */
-#define IWAIT			0x33	/* Driver->RIO Pause booting process */
-
-/* ROUTE_RUP definitions... */
-#define	ROUTE_REQUEST		0x00	/* RIO->Driver Request an ID */
-#define	ROUTE_FOAD		0x01	/* Driver->RIO Shutdown/reboot RTA */
-#define	ROUTE_ALREADY		0x02	/* Driver->RIO Not used */
-#define	ROUTE_USED		0x03	/* Driver->RIO Not used */
-#define	ROUTE_ALLOCATE		0x04	/* Driver->RIO Allocate RTA RUP numbers */
-#define	ROUTE_REQ_TOP		0x05	/* Driver->RIO Not used */
-#define ROUTE_TOPOLOGY		0x06	/* RIO->Driver Route/Topology status */
-
-/*****************************************************************************
-**********************************          **********************************
-**********************************   OPEN   **********************************
-**********************************          **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   Sent to open a port. 
-   Structure of configuration info used with OPEN, CONFIG and MOPEN packets... */
-
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_Cor1		(PKT_Data+1)	/* Channel Option Register 1 */
-#define	PKT_Cor2		(PKT_Data+2)	/* Channel Option Register 2 */
-#define	PKT_Cor4		(PKT_Data+3)	/* Channel Option Register 4 */
-#define	PKT_Cor5		(PKT_Data+4)	/* Channel Option Register 5 */
-#define	PKT_TxXon		(PKT_Data+5)	/* Transmit XON character */
-#define	PKT_TxXoff		(PKT_Data+6)	/* Transmit XOFF character */
-#define	PKT_RxXon		(PKT_Data+7)	/* Receive XON character */
-#define	PKT_RxXoff		(PKT_Data+8)	/* Receive XOFF character */
-#define	PKT_Lnext		(PKT_Data+9)	/* Lnext character */
-#define	PKT_TxBaud		(PKT_Data+10)	/* Transmit baud rate */
-#define	PKT_RxBaud		(PKT_Data+11)	/* Receive baud rate */
-
-/* COR1 definitions... */
-#define	COR1_PARITY		0xE0	/* Parity mask */
-#define	COR1_NONE		0x00	/* No parity */
-#define	COR1_SPACE		0x20	/* Space parity */
-#define	COR1_EVEN		0x40	/* Even parity */
-#define	COR1_MARK		0xA0	/* Mark parity */
-#define	COR1_ODD		0xC0	/* Odd parity */
-
-#define	COR1_STOPBITS		0x0C	/* Stop bits mask */
-#define	COR1_STOP1		0x00	/* 1 stop bit */
-#define	COR1_STOP1_5		0x04	/* 1.5 stop bits */
-#define	COR1_STOP2		0x08	/* 2 stop bits */
-
-#define	COR1_DATABITS		0x03	/* Data bits mask */
-#define	COR1_DATA5		0x00	/* 5 data bits */
-#define	COR1_DATA6		0x01	/* 6 data bits */
-#define	COR1_DATA7		0x02	/* 7 data bits */
-#define	COR1_DATA8		0x03	/* 8 data bits */
-
-/* COR2 definitions... */
-#define	COR2_XON_TXFLOW		0x40	/* XON/XOFF Transmit Flow */
-#define	COR2_XANY_TXFLOW	0xC0	/* XON/XANY Transmit Flow */
-#define	COR2_HUPCL		0x20	/* Hang Up On Close */
-#define	COR2_DSR_TXFLOW		0x08	/* DSR Transmit Flow Control */
-#define	COR2_RTS_RXFLOW		0x04	/* RTS Receive Flow Control */
-#define	COR2_CTS_TXFLOW		0x02	/* CTS Transmit Flow Control */
-#define	COR2_XON_RXFLOW		0x01	/* XON/XOFF Receive Flow */
-
-/* COR4 definition... */
-#define	COR4_IGNCR		0x80	/* Discard received CR */
-#define	COR4_ICRNL		0x40	/* Map received CR -> NL */
-#define	COR4_INLCR		0x20	/* Map received NL -> CR */
-#define	COR4_IGNBRK		0x10	/* Ignore Received Break */
-#define	COR4_NBRKINT		0x08	/* No interrupt on rx Break */
-#define	COR4_IGNPAR		0x04	/* ignore rx parity error chars */
-#define	COR4_PARMRK		0x02	/* Mark rx parity error chars */
-#define	COR4_RAISEMOD		0x01	/* Raise modem lines on !0 baud */
-
-/* COR5 definitions... */
-#define	COR5_ISTRIP		0x80	/* Strip input chars to 7 bits */
-#define	COR5_LNE		0x40	/* Enable LNEXT processing */
-#define	COR5_CMOE		0x20	/* Match good & error characters */
-#define	COR5_TAB3		0x10	/* TAB3 mode */
-#define	COR5_TSTATE_ON		0x08	/* Enable tbusy/tstop monitoring */
-#define	COR5_TSTATE_OFF		0x04	/* Disable tbusy/tstop monitoring */
-#define	COR5_ONLCR		0x02	/* NL -> CR NL on output */
-#define	COR5_OCRNL		0x01	/* CR -> NL on output */
-
-/* RxBaud and TxBaud definitions... */
-#define	RIO_B0			0x00	/* RTS / DTR signals dropped */
-#define	RIO_B50			0x01	/* 50 baud */
-#define	RIO_B75			0x02	/* 75 baud */
-#define	RIO_B110		0x03	/* 110 baud */
-#define	RIO_B134		0x04	/* 134.5 baud */
-#define	RIO_B150		0x05	/* 150 baud */
-#define	RIO_B200		0x06	/* 200 baud */
-#define	RIO_B300		0x07	/* 300 baud */
-#define	RIO_B600		0x08	/* 600 baud */
-#define	RIO_B1200		0x09	/* 1200 baud */
-#define	RIO_B1800		0x0A	/* 1800 baud */
-#define	RIO_B2400		0x0B	/* 2400 baud */
-#define	RIO_B4800		0x0C	/* 4800 baud */
-#define	RIO_B9600		0x0D	/* 9600 baud */
-#define	RIO_B19200		0x0E	/* 19200 baud */
-#define	RIO_B38400		0x0F	/* 38400 baud */
-#define	RIO_B56000		0x10	/* 56000 baud */
-#define	RIO_B57600		0x11	/* 57600 baud */
-#define	RIO_B64000		0x12	/* 64000 baud */
-#define	RIO_B115200		0x13	/* 115200 baud */
-#define	RIO_B2000		0x14	/* 2000 baud */
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   CONFIG   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   CONFIG is sent from the driver to configure an already opened port.
-   Packet structure is same as OPEN.  */
-
-/*****************************************************************************
-*********************************           **********************************
-*********************************   MOPEN   **********************************
-*********************************           **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   MOPEN is sent from the driver to open a port attached to a modem. (in-band)
-   Packet structure is same as OPEN.  */
-
-/*****************************************************************************
-*********************************           **********************************
-*********************************   CLOSE   **********************************
-*********************************           **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   CLOSE is sent from the driver to close a previously opened port.
-   No parameters.
- */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-/*****************************************************************************
-*********************************            *********************************
-*********************************   WFLUSH   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   WFLUSH is sent pre-emptively from the driver to flush the write buffers and
-   packets of a port.  (pre-emptive)
-   
-   WFLUSH is also sent in-band from the driver to a port as a marker to end
-   write flushing previously started by a pre-emptive WFLUSH packet. (in-band)
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   RFLUSH   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   RFLUSH is sent pre-emptively from the driver to flush the read buffers and
-   packets of a port.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   RESUME   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   RESUME is sent pre-emptively from the driver to cause a port to resume 
-   transmission of data if blocked by XOFF.  (as if XON had been received)
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   SBREAK   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   SBREAK is sent in-band from the driver to a port to suspend data and start
-   break signal transmission.
-
-   If the break delay is 0, the break signal will be acknowledged with a
-   RUP_COMMAND, COMPLETE packet and continue until an EBREAK packet is received.
-
-   Otherwise, there is no acknowledgement and the break signal will last for the
-   specified number of mS.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_BreakDelay		(PKT_Data+1)	/* Break delay in mS */
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   EBREAK   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   EBREAK is sent in-band from the driver to a port to stop transmission of a
-   break signal.
-
-   No parameters.  */
-
-/*****************************************************************************
-*********************************             ********************************
-*********************************   SUSPEND   ********************************
-*********************************             ********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   SUSPEND is sent pre-emptively from the driver to cause a port to suspend
-   transmission of data.  (as if XOFF had been received)
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   FCLOSE   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   FCLOSE is sent pre-emptively from the driver to force close a port.
-   A force close flushes receive and transmit queues, and also lowers all output
-   modem signals if the COR5_HUPCL (Hang Up On Close) flag is set.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   XPRINT   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   XPRINT is sent as a normal I/O data packet except that the PKT_CMD_BIT of
-   the "len" field is set, and the first "data" byte is XPRINT.
-
-   The I/O data in the XPRINT packet will contain the following:
-   -	Transparent Print Start Sequence
-   -	Transparent Print Data
-   -	Transparent Print Stop Sequence.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-/*****************************************************************************
-**********************************          **********************************
-**********************************   MBIS   **********************************
-**********************************          **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   MBIS is sent pre-emptively from the driver to set a port's modem signals.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-#define	PKT_ModemSet		(PKT_Data+4)	/* Modem set signals mask */
-
-/* ModemSet definitions... */
-#define	MBIS_RTS		0x01	/* RTS modem signal */
-#define	MBIS_DTR		0x02	/* DTR modem signal */
-
-/*****************************************************************************
-**********************************          **********************************
-**********************************   MBIC   **********************************
-**********************************          **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   MBIC is sent pre-emptively from the driver to clear a port's modem signals.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-#define	PKT_ModemClear		(PKT_Data+4)	/* Modem clear signals mask */
-
-/* ModemClear definitions... */
-#define	MBIC_RTS		0x01	/* RTS modem signal */
-#define	MBIC_DTR		0x02	/* DTR modem signal */
-
-/*****************************************************************************
-**********************************          **********************************
-**********************************   MSET   **********************************
-**********************************          **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   MSET is sent pre-emptively from the driver to set/clear a port's modem signals. */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#endif
-
-#define	PKT_ModemSet		(PKT_Data+4)	/* Modem set signals mask */
-
-/* ModemSet definitions... */
-#define	MSET_RTS		0x01	/* RTS modem signal */
-#define	MSET_DTR		0x02	/* DTR modem signal */
-
-/*****************************************************************************
-*********************************            *********************************
-*********************************   PCLOSE   *********************************
-*********************************            *********************************
-*****************************************************************************/
-
-/* (Driver->RIO,in-band)
-
-   PCLOSE is sent from the driver to pseudo close a previously opened port.
-   
-   The port will close when all data has been sent/received, however, the
-   port's transmit / receive and modem signals will be left enabled and the
-   port marked internally as Pseudo Closed. */
-
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-
-/*****************************************************************************
-**********************************          **********************************
-**********************************   MGET   **********************************
-**********************************          **********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   MGET is sent pre-emptively from the driver to request the port's current modem signals. */
-
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-
-/*****************************************************************************
-*********************************             ********************************
-*********************************   MEMDUMP   ********************************
-*********************************             ********************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   MEMDUMP is sent pre-emptively from the driver to request a dump of 32 bytes
-   of the specified port's RTA address space.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-#define	PKT_Address		(PKT_Data+6)	/* Requested address */
-
-/*****************************************************************************
-******************************                   *****************************
-******************************   READ_REGISTER   *****************************
-******************************                   *****************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   READ_REGISTER is sent pre-emptively from the driver to request the contents
-   of the CD1400 register specified in address.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-#define	PKT_Address		(PKT_Data+6)	/* Requested address */
-
-/*****************************************************************************
-************************                            **************************
-************************   COMMAND_RUP - COMPLETE   **************************
-************************                            **************************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - COMPLETE is sent in response to all port I/O control command
-   packets, except MEMDUMP and READ_REGISTER.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#define	PKT_ModemStatus		(PKT_Data+3)	/* Modem signal status */
-#define	PKT_PortStatus		(PKT_Data+4)	/* Port signal status */
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-
-/* ModemStatus definitions... */
-#define	MODEM_DSR		0x80	/* Data Set Ready modem state */
-#define	MODEM_CTS		0x40	/* Clear To Send modem state */
-#define	MODEM_RI		0x20	/* Ring Indicate modem state */
-#define	MODEM_CD		0x10	/* Carrier Detect modem state */
-#define	MODEM_TSTOP		0x08	/* Transmit Stopped state */
-#define	MODEM_TEMPTY		0x04	/* Transmit Empty state */
-#define	MODEM_DTR		0x02	/* DTR modem output state */
-#define	MODEM_RTS		0x01	/* RTS modem output state */
-
-/* PortStatus definitions... */
-#define	PORT_ISOPEN		0x01	/* Port open ? */
-#define	PORT_HUPCL		0x02	/* Hangup on close? */
-#define	PORT_MOPENPEND		0x04	/* Modem open pending */
-#define	PORT_ISPARALLEL		0x08	/* Parallel port */
-#define	PORT_BREAK		0x10	/* Port on break */
-#define	PORT_STATUSPEND		0020	/* Status packet pending */
-#define	PORT_BREAKPEND		0x40	/* Break packet pending */
-#define	PORT_MODEMPEND		0x80	/* Modem status packet pending */
-
-/*****************************************************************************
-************************                            **************************
-************************   COMMAND_RUP - COMPLETE   **************************
-************************                            **************************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - COMPLETE is sent in response to all port I/O control command
-   packets, except MEMDUMP and READ_REGISTER.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#endif
-#define	PKT_ModemStatus		(PKT_Data+3)	/* Modem signal status */
-#define	PKT_PortStatus		(PKT_Data+4)	/* Port signal status */
-#if 0
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-#endif
-
-/* ModemStatus definitions... */
-#define	MODEM_DSR		0x80	/* Data Set Ready modem state */
-#define	MODEM_CTS		0x40	/* Clear To Send modem state */
-#define	MODEM_RI		0x20	/* Ring Indicate modem state */
-#define	MODEM_CD		0x10	/* Carrier Detect modem state */
-#define	MODEM_TSTOP		0x08	/* Transmit Stopped state */
-#define	MODEM_TEMPTY		0x04	/* Transmit Empty state */
-#define	MODEM_DTR		0x02	/* DTR modem output state */
-#define	MODEM_RTS		0x01	/* RTS modem output state */
-
-/* PortStatus definitions... */
-#define	PORT_ISOPEN		0x01	/* Port open ? */
-#define	PORT_HUPCL		0x02	/* Hangup on close? */
-#define	PORT_MOPENPEND		0x04	/* Modem open pending */
-#define	PORT_ISPARALLEL		0x08	/* Parallel port */
-#define	PORT_BREAK		0x10	/* Port on break */
-#define	PORT_STATUSPEND		0020	/* Status packet pending */
-#define	PORT_BREAKPEND		0x40	/* Break packet pending */
-#define	PORT_MODEMPEND		0x80	/* Modem status packet pending */
-
-/*****************************************************************************
-********************                                      ********************
-********************   COMMAND_RUP - COMPLETE - MEMDUMP   ********************
-********************                                      ********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - COMPLETE - MEMDUMP is sent as an acknowledgement for a MEMDUMP
-   port I/O control command packet.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#define	PKT_ModemStatus		(PKT_Data+3)	/* Modem signal status */
-#define	PKT_PortStatus		(PKT_Data+4)	/* Port signal status */
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-#define	PKT_Address		(PKT_Data+6)	/* Requested address */
-#endif
-#define	PKT_Dump		(PKT_Data+8)	/* 32bytes of requested dump data */
-
-/*****************************************************************************
-*****************                                            *****************
-*****************   COMMAND_RUP - COMPLETE - READ_REGISTER   *****************
-*****************                                            *****************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - COMPLETE - READ_REGISTER is sent as an acknowledgement for a
-   READ_REGISTER port I/O control command packet.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/*Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/*Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#endif
-#define	PKT_RegisterValue	(PKT_Data+3)	/* Modem signal status */
-#if 0
-#define	PKT_PortStatus		(PKT_Data+4)	/* Port signal status */
-#define	PKT_SubCmd		(PKT_Data+5)	/* Sub Command */
-#endif
-
-/*****************************************************************************
-*********************                                  ***********************
-*********************   COMMAND_RUP - BREAK_RECEIVED   ***********************
-*********************                                  ***********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - BREAK_RECEIVED packets are sent when the port detects a receive BREAK signal.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#endif
-
-/*****************************************************************************
-*********************                                *************************
-*********************   COMMAND_RUP - MODEM_STATUS   *************************
-*********************                                *************************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   COMMAND_RUP - MODEM_STATUS packets are sent whenever the port detects a
-   change in the input modem signal states.
-
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_PhbNum		(PKT_Data+1)	/* Port number wrt RTA */
-#define	PKT_Cmd2		(PKT_Data+2)	/* Command code copy */
-#define	PKT_ModemStatus		(PKT_Data+3)	/* Modem signal status */
-#endif
-
-/*****************************************************************************
-************************                             *************************
-************************   BOOT_RUP - BOOT_REQUEST   *************************
-************************                             *************************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   BOOT_RUP - BOOT_REQUEST packets are sent to the Driver from RIO to request
-   firmware code to load onto attached RTAs.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-
-/*****************************************************************************
-************************                              ************************
-************************   BOOT_RUP - BOOT_SEQUENCE   ************************
-************************                              ************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - BOOT_SEQUENCE packets are sent from the Driver to RIO in response
-   to a BOOT_RUP - BOOT_REQUEST packet.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_NumPackets		(PKT_Data+2)	/* Packets required to load firmware */
-#define	PKT_LoadBase		(PKT_Data+4)	/* RTA firmware load address */
-#define	PKT_CodeSize		(PKT_Data+6)	/* Size of firmware in bytes */
-#define	PKT_CmdString		(PKT_Data+8)	/* Command string */
-
-/*****************************************************************************
-************************                               ***********************
-************************   BOOT_RUP - BOOT_COMPLETED   ***********************
-************************                               ***********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   BOOT_RUP - BOOT_COMPLETE is sent to the Driver from RIO when downloading of
-   RTA firmware has completed.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_LinkNumber		(PKT_Data+1)	/* Link number RTA booted on */
-#define	PKT_SerialNumber	(PKT_Data+2)	/* 4 byte serial number */
-
-/*****************************************************************************
-************************                               ***********************
-************************   BOOT_RUP - Packet Request   ***********************
-************************                               ***********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   BOOT_RUP packet without the PKT_CMD_BIT set in the PKT->len field is sent
-   from RIO to the Driver as a request for a firmware boot packet. */
-
-#define	PKT_SequenceNumber	(PKT_Data+0)	/* Packet sequence number */
-
-/*****************************************************************************
-***********************                                ***********************
-***********************   BOOT_RUP - Packet Response   ***********************
-***********************                                ***********************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   In response to a BOOT_RUP boot packet request, the driver fills out the response
-   packet with the 70 bytes of the requested sequence.
-   */
-#if 0
-#define	PKT_SequenceNumber	(PKT_Data+0)	/* Packet sequence number */
-#endif
-#define	PKT_FirmwarePacket	(PKT_Data+2)	/* Firmware packet */
-
-/*****************************************************************************
-****************************                      ****************************
-****************************   BOOT_RUP - IFOAD   ****************************
-****************************                      ****************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - IFOAD packets are sent from the Driver to an RTA to cause the
-   RTA to shut down and reboot.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_IfoadId1		(PKT_Data+2)	/* IFOAD Id 1 */
-#define	PKT_IfoadId2		(PKT_Data+3)	/* IFOAD Id 2 */
-
-#define	IFOADID1		0xAD
-#define	IFOADID2		0xF0
-
-/*****************************************************************************
-**************************                         ***************************
-**************************   BOOT_RUP - IDENTIFY   ***************************
-**************************                         ***************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - IDENTIFY packets are sent from the Driver to an RTA to cause the
-   RTA to flash its LEDs for a period of time.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_IdentifyId		(PKT_Data+2)	/* defines pattern to flash */
-
-/*****************************************************************************
-****************************                       ***************************
-****************************   BOOT_RUP - ZOMBIE   ***************************
-****************************                       ***************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - ZOMBIE packets are sent from the Driver to an RTA to cause the
-   RTA to shut down and flash it's LEDs.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_ZombieId1		(PKT_Data+2)	/* ZOMBIE Id 1 */
-#define	PKT_ZombieId2		(PKT_Data+3)	/* ZOMBIE Id 2 */
-
-#define	ZOMBIEID1		0x52
-#define	ZOMBIEID2		0x21
-
-/*****************************************************************************
-****************************                      ****************************
-****************************   BOOT_RUP - UFOAD   ****************************
-****************************                      ****************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - UFOAD packets are sent from the Driver to an RTA to cause the RTA
-   to ask it's neighbouring RTA to shut down and reboot.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_LinkNumber		(PKT_Data+1)	/* Link number of RTA to UFOAD */
-#endif
-#define	PKT_UfoadId1		(PKT_Data+2)	/* UFOAD Id 1 */
-#define	PKT_UfoadId2		(PKT_Data+3)	/* UFOAD Id 2 */
-
-#define	UFOADID1		0x1E
-#define	UFOADID2		0x0D
-
-/*****************************************************************************
-****************************                      ****************************
-****************************   BOOT_RUP - IWAIT   ****************************
-****************************                      ****************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   BOOT_RUP - IWAIT packets are sent from the Driver to an RTA to cause the RTA
-   to pause booting on the specified link for 30 seconds.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#define	PKT_LinkNumber		(PKT_Data+1)	/* Link number of RTA to UFOAD */
-#endif
-#define	PKT_IwaitId1		(PKT_Data+2)	/* IWAIT Id 1 */
-#define	PKT_IwaitId2		(PKT_Data+3)	/* IWAIT Id 2 */
-
-#define	IWAITID1		0xDE
-#define	IWAITID2		0xB1
-
-/*****************************************************************************
-************************                               ***********************
-************************   ROUTE_RUP - ROUTE_REQUEST   ***********************
-************************                               ***********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   ROUTE_RUP - ROUTE_REQUEST packets are sent from a newly booted or connected
-   RTA to a Driver to request an ID (RUP or unit number).
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_SerialNumber	(PKT_Data+2)	/* 4 byte serial number */
-#define	PKT_ModuleTypes		(PKT_Data+6)	/* RTA Module types */
-
-/* ModuleTypes definitions... */
-#define	MOD_BLANK		0x0F	/* Blank plate attached */
-#define	MOD_RS232DB25		0x00	/* RS232 DB25 connector */
-#define	MOD_RS232RJ45		0x01	/* RS232 RJ45 connector */
-#define	MOD_RS422DB25		0x02	/* RS422 DB25 connector */
-#define	MOD_RS485DB25		0x03	/* RS485 DB25 connector */
-#define	MOD_PARALLEL		0x04	/* Centronics parallel */
-
-#define	MOD2			0x08	/* Set to indicate Rev2 module */
-
-/*****************************************************************************
-*************************                            *************************
-*************************   ROUTE_RUP - ROUTE_FOAD   *************************
-*************************                            *************************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   ROUTE_RUP - ROUTE_FOAD packet is sent as a response to a ROUTE_RUP - ROUTE_REQUEST
-   packet to cause the RTA to "Fall Over And Die"., i.e. shutdown and reboot.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_RouteCmdString	(PKT_Data+2)	/* Command string */
-
-/*****************************************************************************
-***********************                                ***********************
-***********************   ROUTE_RUP - ROUTE_ALLOCATE   ***********************
-***********************                                ***********************
-*****************************************************************************/
-
-/* (Driver->RIO,pre-emptive)
-
-   ROUTE_RUP - ROUTE_ALLOCATE packet is sent as a response to a ROUTE_RUP - ROUTE_REQUEST
-   packet to allocate the RTA's Id number (RUP number 1..16)
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_IdNum		(PKT_Data+1)	/* RUP number for ports 1..8 */
-#if 0
-#define	PKT_RouteCmdString	(PKT_Data+2)	/* Command string */
-#endif
-#define	PKT_IdNum2		(PKT_Data+0x17)	/* RUP number for ports 9..16 */
-
-/*****************************************************************************
-***********************                                ***********************
-***********************   ROUTE_RUP - ROUTE_TOPOLOGY   ***********************
-***********************                                ***********************
-*****************************************************************************/
-
-/* (RIO->Driver,pre-emptive)
-
-   ROUTE_RUP - ROUTE_TOPOLOGY packet is sent to inform the driver of an RTA's
-   current link status.
-   */
-#if 0
-#define	PKT_Cmd			(PKT_Data+0)	/* Command code */
-#endif
-#define	PKT_Link1Rup		(PKT_Data+2)	/* Link 1 RUP number */
-#define	PKT_Link1Link		(PKT_Data+3)	/* Link 1 link number */
-#define	PKT_Link2Rup		(PKT_Data+4)	/* Link 2 RUP number */
-#define	PKT_Link2Link		(PKT_Data+5)	/* Link 2 link number */
-#define	PKT_Link3Rup		(PKT_Data+6)	/* Link 3 RUP number */
-#define	PKT_Link3Link		(PKT_Data+7)	/* Link 3 link number */
-#define	PKT_Link4Rup		(PKT_Data+8)	/* Link 4 RUP number */
-#define	PKT_Link4Link		(PKT_Data+9)	/* Link 4 link number */
-#define	PKT_RtaVpdProm		(PKT_Data+10)	/* 32 bytes of RTA VPD PROM Contents */
-
-#endif				/* _sxwinif_h */
-
-/* End of RIOWINIF.H */
diff -purN linux-2.6.15-git12/drivers/char/rio/riscos.h linux-2.6.16-rc1/drivers/char/rio/riscos.h
--- linux-2.6.15-git12/drivers/char/rio/riscos.h	2006-01-17 08:21:31.467845462 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/riscos.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
-/*
-** -----------------------------------------------------------------------------
-**
-**  Perle Specialix driver for Linux
-**  Ported from existing RIO Driver for SCO sources.
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**	Module		: riscos.h
-**	SID		: 1.2
-**	Last Modified	: 11/6/98 11:34:19
-**	Retrieved	: 11/6/98 11:34:22
-**
-**  ident @(#)riscos.h	1.2
-**
-** -----------------------------------------------------------------------------
-*/
-
-#ifndef __rio_riscos_h__
-#define __rio_riscos_h__
-
-#ifdef SCCS_LABELS
-static char *_riscos_h_sccs_ = "@(#)riscos.h	1.2";
-#endif
-
-/*
-** This module used to define all those little itsy bits required for RISC/OS
-** now it's full of null macros.
-*/
-
-/*
-**	RBYTE reads a byte from a location.
-**	RWORD reads a word from a location.
-**	WBYTE writes a byte to a location.
-**	WWORD writes a word to a location.
-**	RINDW reads a word through a pointer.
-**	WINDW writes a word through a pointer.
-**	RIOSWAB swaps the two bytes of a word, if needed.
-*/
-
-#define	RIOSWAB(N)      (N)
-#define	WBYTE(A,V)	(A)=(uchar)(V)
-#define WWORD(A,V)	(A)=(ushort)(V)
-#define RBYTE(A)	(uchar)(A)
-#define RWORD(A)	(ushort)(A)
-#define RINDW(A)	(*(ushort *)(A))
-#define WINDW(A,V)	(*(ushort *)(A)=(ushort)(V))
-
-#endif				/* __rio_riscos_h__ */
diff -purN linux-2.6.15-git12/drivers/char/rio/rtahw.h linux-2.6.16-rc1/drivers/char/rio/rtahw.h
--- linux-2.6.15-git12/drivers/char/rio/rtahw.h	2006-01-17 08:21:31.471844832 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rtahw.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,75 +0,0 @@
-
-/****************************************************************************
- *******                                                              *******
- *******                R T A    H A R D W A R E
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_rtahw_h_sccs = "@(#)rtahw.h	1.5";
-#endif
-#endif
-
-#define	WATCHDOG_ADDR	((unsigned short *)0x7a00)
-#define RTA_LED_ADDR	((unsigned short *)0x7c00)
-#define SERIALNUM_ADDR	((unsigned char *)0x7809)
-#define LATCH_ADDR      ((unsigned char *)0x7800)
-
-/*
-** Here we define where the cd1400 chips are in memory.
-*/
-#define CD1400_ONE_ADDR		(0x7300)
-#define CD1400_TWO_ADDR		(0x7200)
-#define CD1400_THREE_ADDR	(0x7100)
-#define CD1400_FOUR_ADDR	(0x7000)
-
-/*
-** Define the different types of modules we can have
-*/
-enum module {
-	MOD_BLANK = 0x0f,	/* Blank plate attached */
-	MOD_RS232DB25 = 0x00,	/* RS232 DB25 connector */
-	MOD_RS232RJ45 = 0x01,	/* RS232 RJ45 connector */
-	MOD_RS422DB25 = 0x02,	/* RS422 DB25 connector */
-	MOD_RS485DB25 = 0x03,	/* RS485 DB25 connector */
-	MOD_PARALLEL = 0x04	/* Centronics parallel */
-};
-
-#define TYPE_HOST	0
-#define TYPE_RTA8	1
-#define TYPE_RTA16	2
-
-#define	WATCH_DOG	WATCHDOG_ADDR
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/rupstat.h linux-2.6.16-rc1/drivers/char/rio/rupstat.h
--- linux-2.6.15-git12/drivers/char/rio/rupstat.h	2006-01-17 08:21:31.474844360 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/rupstat.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
-/****************************************************************************
- *******                                                              *******
- *******                      RUPSTAT
- *******                                                              *******
- ****************************************************************************
-
- Author  : Jeremy Rolls
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef _rupstat_h
-#define _rupstat_h
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_rupstat_h_sccs = "@(#)rupstat.h	1.1";
-#endif
-#endif
-
-#define    STATUS_SYNC    0
-#define    STATUS_REQ_TOP 1
-#define    STATUS_TOPOLOGY    2
-
-#endif
diff -purN linux-2.6.15-git12/drivers/char/rio/selftest.h linux-2.6.16-rc1/drivers/char/rio/selftest.h
--- linux-2.6.15-git12/drivers/char/rio/selftest.h	2006-01-17 08:21:31.476844045 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/selftest.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,73 +0,0 @@
-/*
-** File:		selftest.h
-**
-** Author:		David Dix
-**
-** Created:		15th March 1993
-**
-** Last modified:	94/06/14
-**
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#ifndef	_selftests_h_
-#define _selftests_h_
-
-/*
-** Selftest identifier...
-*/
-#define SELFTEST_MAGIC	0x5a5a
-
-/*
-** This is the structure of the packet that is sent back after each
-** selftest on a booting RTA.
-*/
-typedef struct {
-	short magic;		/* Identifies packet type */
-	int test;		/* Test number, see below */
-	unsigned int result;	/* Result value */
-	unsigned int dataIn;
-	unsigned int dataOut;
-} selftestStruct;
-
-/*
-** The different tests are identified by the following data values.
-*/
-enum test {
-	TESTS_COMPLETE = 0x00,
-	MEMTEST_ADDR = 0x01,
-	MEMTEST_BIT = 0x02,
-	MEMTEST_FILL = 0x03,
-	MEMTEST_DATABUS = 0x04,
-	MEMTEST_ADDRBUS = 0x05,
-	CD1400_INIT = 0x10,
-	CD1400_LOOP = 0x11,
-	CD1400_INTERRUPT = 0x12
-};
-
-enum result {
-	E_PORT = 0x10,
-	E_TX = 0x11,
-	E_RX = 0x12,
-	E_EXCEPT = 0x13,
-	E_COMPARE = 0x14,
-	E_MODEM = 0x15,
-	E_TIMEOUT = 0x16,
-	E_INTERRUPT = 0x17
-};
-#endif				/* _selftests_h_ */
diff -purN linux-2.6.15-git12/drivers/char/rio/sysmap.h linux-2.6.16-rc1/drivers/char/rio/sysmap.h
--- linux-2.6.15-git12/drivers/char/rio/sysmap.h	2006-01-17 08:21:31.478843730 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/sysmap.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,62 +0,0 @@
-
-/****************************************************************************
- *******                                                              *******
- *******          S Y S T E M   M A P   H E A D E R
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_sysmap_h_sccs = "@(#)sysmap.h	1.1";
-#endif
-#endif
-
-#define SYSTEM_MAP_LEN     64	/* Len of System Map array */
-
-
-typedef struct SYS_MAP SYS_MAP;
-typedef struct SYS_MAP_LINK SYS_MAP_LINK;
-
-struct SYS_MAP_LINK {
-	short id;		/* Unit Id */
-	short link;		/* Id's Link */
-	short been_here;	/* Used by map_gen */
-};
-
-struct SYS_MAP {
-	char serial_num[4];
-	SYS_MAP_LINK link[4];
-};
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/char/rio/timeouts.h linux-2.6.16-rc1/drivers/char/rio/timeouts.h
--- linux-2.6.15-git12/drivers/char/rio/timeouts.h	2006-01-17 08:21:31.479843573 +0000
+++ linux-2.6.16-rc1/drivers/char/rio/timeouts.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
-
-/****************************************************************************
- *******                                                              *******
- *******                     T I M E O U T S
- *******                                                              *******
- ****************************************************************************
-
- Author  : Ian Nandhra
- Date    :
-
- *
- *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.
- *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
- Version : 0.01
-
-
-                            Mods
- ----------------------------------------------------------------------------
-  Date     By                Description
- ----------------------------------------------------------------------------
-
- ***************************************************************************/
-
-#ifndef lint
-#ifdef SCCS_LABELS
-static char *_rio_defaults_h_sccs = "@(#)timeouts.h	1.3";
-#endif
-#endif
-
-#define MILLISECOND           (int) (1000/64)	/* 15.625 low ticks */
-#define SECOND                (int) 15625	/* Low priority ticks */
-
-#define TX_TIMEOUT          (int) (200 * MILLISECOND)
-
-
-/*********** end of file ***********/
diff -purN linux-2.6.15-git12/drivers/ieee1394/amdtp.c linux-2.6.16-rc1/drivers/ieee1394/amdtp.c
--- linux-2.6.15-git12/drivers/ieee1394/amdtp.c	2006-01-17 08:21:31.904776667 +0000
+++ linux-2.6.16-rc1/drivers/ieee1394/amdtp.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1297 +0,0 @@
-/* -*- c-basic-offset: 8 -*-
- *
- * amdtp.c - Audio and Music Data Transmission Protocol Driver
- * Copyright (C) 2001 Kristian Hgsberg
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* OVERVIEW
- * --------
- *
- * The AMDTP driver is designed to expose the IEEE1394 bus as a
- * regular OSS soundcard, i.e. you can link /dev/dsp to /dev/amdtp and
- * then your favourite MP3 player, game or whatever sound program will
- * output to an IEEE1394 isochronous channel.  The signal destination
- * could be a set of IEEE1394 loudspeakers (if and when such things
- * become available) or an amplifier with IEEE1394 input (like the
- * Sony STR-LSA1).  The driver only handles the actual streaming, some
- * connection management is also required for this to actually work.
- * That is outside the scope of this driver, and furthermore it is not
- * really standardized yet.
- *
- * The Audio and Music Data Tranmission Protocol is available at
- *
- *     http://www.1394ta.org/Download/Technology/Specifications/2001/AM20Final-jf2.pdf
- *
- *
- * TODO
- * ----
- *
- * - We should be able to change input sample format between LE/BE, as
- *   we already shift the bytes around when we construct the iso
- *   packets.
- *
- * - Fix DMA stop after bus reset!
- *
- * - Clean up iso context handling in ohci1394.
- *
- *
- * MAYBE TODO
- * ----------
- *
- * - Receive data for local playback or recording.  Playback requires
- *   soft syncing with the sound card.
- *
- * - Signal processing, i.e. receive packets, do some processing, and
- *   transmit them again using the same packet structure and timestamps
- *   offset by processing time.
- *
- * - Maybe make an ALSA interface, that is, create a file_ops
- *   implementation that recognizes ALSA ioctls and uses defaults for
- *   things that can't be controlled through ALSA (iso channel).
- *
- *   Changes:
- *
- * - Audit copy_from_user in amdtp_write.
- *                           Daniele Bellucci <bellucda@tiscali.it>
- *
- */
-
-#include <linux/module.h>
-#include <linux/list.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/fs.h>
-#include <linux/ioctl.h>
-#include <linux/wait.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/compat.h>
-#include <linux/cdev.h>
-#include <asm/uaccess.h>
-#include <asm/atomic.h>
-
-#include "hosts.h"
-#include "highlevel.h"
-#include "ieee1394.h"
-#include "ieee1394_core.h"
-#include "ohci1394.h"
-
-#include "amdtp.h"
-#include "cmp.h"
-
-#define FMT_AMDTP 0x10
-#define FDF_AM824 0x00
-#define FDF_SFC_32KHZ   0x00
-#define FDF_SFC_44K1HZ  0x01
-#define FDF_SFC_48KHZ   0x02
-#define FDF_SFC_88K2HZ  0x03
-#define FDF_SFC_96KHZ   0x04
-#define FDF_SFC_176K4HZ 0x05
-#define FDF_SFC_192KHZ  0x06
-
-struct descriptor_block {
-	struct output_more_immediate {
-		u32 control;
-		u32 pad0;
-		u32 skip;
-		u32 pad1;
-		u32 header[4];
-	} header_desc;
-
-	struct output_last {
-		u32 control;
-		u32 data_address;
-		u32 branch;
-		u32 status;
-	} payload_desc;
-};
-
-struct packet {
-	struct descriptor_block *db;
-	dma_addr_t db_bus;
-	struct iso_packet *payload;
-	dma_addr_t payload_bus;
-};
-
-#include <asm/byteorder.h>
-
-#if defined __BIG_ENDIAN_BITFIELD
-
-struct iso_packet {
-	/* First quadlet */
-	unsigned int dbs      : 8;
-	unsigned int eoh0     : 2;
-	unsigned int sid      : 6;
-
-	unsigned int dbc      : 8;
-	unsigned int fn       : 2;
-	unsigned int qpc      : 3;
-	unsigned int sph      : 1;
-	unsigned int reserved : 2;
-
-	/* Second quadlet */
-	unsigned int fdf      : 8;
-	unsigned int eoh1     : 2;
-	unsigned int fmt      : 6;
-
-	unsigned int syt      : 16;
-
-        quadlet_t data[0];
-};
-
-#elif defined __LITTLE_ENDIAN_BITFIELD
-
-struct iso_packet {
-	/* First quadlet */
-	unsigned int sid      : 6;
-	unsigned int eoh0     : 2;
-	unsigned int dbs      : 8;
-
-	unsigned int reserved : 2;
-	unsigned int sph      : 1;
-	unsigned int qpc      : 3;
-	unsigned int fn       : 2;
-	unsigned int dbc      : 8;
-
-	/* Second quadlet */
-	unsigned int fmt      : 6;
-	unsigned int eoh1     : 2;
-	unsigned int fdf      : 8;
-
-	unsigned int syt      : 16;
-
-	quadlet_t data[0];
-};
-
-#else
-
-#error Unknown bitfield type
-
-#endif
-
-struct fraction {
-	int integer;
-	int numerator;
-	int denominator;
-};
-
-#define PACKET_LIST_SIZE 256
-#define MAX_PACKET_LISTS 4
-
-struct packet_list {
-	struct list_head link;
-	int last_cycle_count;
-	struct packet packets[PACKET_LIST_SIZE];
-};
-
-#define BUFFER_SIZE 128
-
-/* This implements a circular buffer for incoming samples. */
-
-struct buffer {
-	size_t head, tail, length, size;
-	unsigned char data[0];
-};
-
-struct stream {
-	int iso_channel;
-	int format;
-	int rate;
-	int dimension;
-	int fdf;
-	int mode;
-	int sample_format;
-	struct cmp_pcr *opcr;
-
-	/* Input samples are copied here. */
-	struct buffer *input;
-
-	/* ISO Packer state */
-	unsigned char dbc;
-	struct packet_list *current_packet_list;
-	int current_packet;
-	struct fraction ready_samples, samples_per_cycle;
-
-	/* We use these to generate control bits when we are packing
-	 * iec958 data.
-	 */
-	int iec958_frame_count;
-	int iec958_rate_code;
-
-	/* The cycle_count and cycle_offset fields are used for the
-	 * synchronization timestamps (syt) in the cip header.  They
-	 * are incremented by at least a cycle every time we put a
-	 * time stamp in a packet.  As we don't time stamp all
-	 * packages, cycle_count isn't updated in every cycle, and
-	 * sometimes it's incremented by 2.  Thus, we have
-	 * cycle_count2, which is simply incremented by one with each
-	 * packet, so we can compare it to the transmission time
-	 * written back in the dma programs.
-	 */
-	atomic_t cycle_count, cycle_count2;
-	struct fraction cycle_offset, ticks_per_syt_offset;
-	int syt_interval;
-	int stale_count;
-
-	/* Theses fields control the sample output to the DMA engine.
-	 * The dma_packet_lists list holds packet lists currently
-	 * queued for dma; the head of the list is currently being
-	 * processed.  The last program in a packet list generates an
-	 * interrupt, which removes the head from dma_packet_lists and
-	 * puts it back on the free list.
-	 */
-	struct list_head dma_packet_lists;
-	struct list_head free_packet_lists;
-        wait_queue_head_t packet_list_wait;
-	spinlock_t packet_list_lock;
-	struct ohci1394_iso_tasklet iso_tasklet;
-	struct pci_pool *descriptor_pool, *packet_pool;
-
-	/* Streams at a host controller are chained through this field. */
-	struct list_head link;
-	struct amdtp_host *host;
-};
-
-struct amdtp_host {
-	struct hpsb_host *host;
-	struct ti_ohci *ohci;
-	struct list_head stream_list;
-	spinlock_t stream_list_lock;
-};
-
-static struct hpsb_highlevel amdtp_highlevel;
-
-
-/* FIXME: This doesn't belong here... */
-
-#define OHCI1394_CONTEXT_CYCLE_MATCH 0x80000000
-#define OHCI1394_CONTEXT_RUN         0x00008000
-#define OHCI1394_CONTEXT_WAKE        0x00001000
-#define OHCI1394_CONTEXT_DEAD        0x00000800
-#define OHCI1394_CONTEXT_ACTIVE      0x00000400
-
-static void ohci1394_start_it_ctx(struct ti_ohci *ohci, int ctx,
-			   dma_addr_t first_cmd, int z, int cycle_match)
-{
-	reg_write(ohci, OHCI1394_IsoXmitIntMaskSet, 1 << ctx);
-	reg_write(ohci, OHCI1394_IsoXmitCommandPtr + ctx * 16, first_cmd | z);
-	reg_write(ohci, OHCI1394_IsoXmitContextControlClear + ctx * 16, ~0);
-	wmb();
-	reg_write(ohci, OHCI1394_IsoXmitContextControlSet + ctx * 16,
-		  OHCI1394_CONTEXT_CYCLE_MATCH | (cycle_match << 16) |
-		  OHCI1394_CONTEXT_RUN);
-}
-
-static void ohci1394_wake_it_ctx(struct ti_ohci *ohci, int ctx)
-{
-	reg_write(ohci, OHCI1394_IsoXmitContextControlSet + ctx * 16,
-		  OHCI1394_CONTEXT_WAKE);
-}
-
-static void ohci1394_stop_it_ctx(struct ti_ohci *ohci, int ctx, int synchronous)
-{
-	u32 control;
-	int wait;
-
-	reg_write(ohci, OHCI1394_IsoXmitIntMaskClear, 1 << ctx);
-	reg_write(ohci, OHCI1394_IsoXmitContextControlClear + ctx * 16,
-		  OHCI1394_CONTEXT_RUN);
-	wmb();
-
-	if (synchronous) {
-		for (wait = 0; wait < 5; wait++) {
-			control = reg_read(ohci, OHCI1394_IsoXmitContextControlSet + ctx * 16);
-			if ((control & OHCI1394_CONTEXT_ACTIVE) == 0)
-				break;
-
-			schedule_timeout_interruptible(1);
-		}
-	}
-}
-
-/* Note: we can test if free_packet_lists is empty without aquiring
- * the packet_list_lock.  The interrupt handler only adds to the free
- * list, there is no race condition between testing the list non-empty
- * and acquiring the lock.
- */
-
-static struct packet_list *stream_get_free_packet_list(struct stream *s)
-{
-	struct packet_list *pl;
-	unsigned long flags;
-
-	if (list_empty(&s->free_packet_lists))
-		return NULL;
-
-	spin_lock_irqsave(&s->packet_list_lock, flags);
-	pl = list_entry(s->free_packet_lists.next, struct packet_list, link);
-	list_del(&pl->link);
-	spin_unlock_irqrestore(&s->packet_list_lock, flags);
-
-	return pl;
-}
-
-static void stream_start_dma(struct stream *s, struct packet_list *pl)
-{
-	u32 syt_cycle, cycle_count, start_cycle;
-
-	cycle_count = reg_read(s->host->ohci,
-			       OHCI1394_IsochronousCycleTimer) >> 12;
-	syt_cycle = (pl->last_cycle_count - PACKET_LIST_SIZE + 1) & 0x0f;
-
-	/* We program the DMA controller to start transmission at
-	 * least 17 cycles from now - this happens when the lower four
-	 * bits of cycle_count is 0x0f and syt_cycle is 0, in this
-	 * case the start cycle is cycle_count - 15 + 32. */
-	start_cycle = (cycle_count & ~0x0f) + 32 + syt_cycle;
-	if ((start_cycle & 0x1fff) >= 8000)
-		start_cycle = start_cycle - 8000 + 0x2000;
-
-	ohci1394_start_it_ctx(s->host->ohci, s->iso_tasklet.context,
-			      pl->packets[0].db_bus, 3,
-			      start_cycle & 0x7fff);
-}
-
-static void stream_put_dma_packet_list(struct stream *s,
-				       struct packet_list *pl)
-{
-	unsigned long flags;
-	struct packet_list *prev;
-
-	/* Remember the cycle_count used for timestamping the last packet. */
-	pl->last_cycle_count = atomic_read(&s->cycle_count2) - 1;
-	pl->packets[PACKET_LIST_SIZE - 1].db->payload_desc.branch = 0;
-
-	spin_lock_irqsave(&s->packet_list_lock, flags);
-	list_add_tail(&pl->link, &s->dma_packet_lists);
-	spin_unlock_irqrestore(&s->packet_list_lock, flags);
-
-	prev = list_entry(pl->link.prev, struct packet_list, link);
-	if (pl->link.prev != &s->dma_packet_lists) {
-		struct packet *last = &prev->packets[PACKET_LIST_SIZE - 1];
-		last->db->payload_desc.branch = pl->packets[0].db_bus | 3;
-		last->db->header_desc.skip = pl->packets[0].db_bus | 3;
-		ohci1394_wake_it_ctx(s->host->ohci, s->iso_tasklet.context);
-	}
-	else
-		stream_start_dma(s, pl);
-}
-
-static void stream_shift_packet_lists(unsigned long l)
-{
-	struct stream *s = (struct stream *) l;
-	struct packet_list *pl;
-	struct packet *last;
-	int diff;
-
-	if (list_empty(&s->dma_packet_lists)) {
-		HPSB_ERR("empty dma_packet_lists in %s", __FUNCTION__);
-		return;
-	}
-
-	/* Now that we know the list is non-empty, we can get the head
-	 * of the list without locking, because the process context
-	 * only adds to the tail.
-	 */
-	pl = list_entry(s->dma_packet_lists.next, struct packet_list, link);
-	last = &pl->packets[PACKET_LIST_SIZE - 1];
-
-	/* This is weird... if we stop dma processing in the middle of
-	 * a packet list, the dma context immediately generates an
-	 * interrupt if we enable it again later.  This only happens
-	 * when amdtp_release is interrupted while waiting for dma to
-	 * complete, though.  Anyway, we detect this by seeing that
-	 * the status of the dma descriptor that we expected an
-	 * interrupt from is still 0.
-	 */
-	if (last->db->payload_desc.status == 0) {
-		HPSB_INFO("weird interrupt...");
-		return;
-	}
-
-	/* If the last descriptor block does not specify a branch
-	 * address, we have a sample underflow.
-	 */
-	if (last->db->payload_desc.branch == 0)
-		HPSB_INFO("FIXME: sample underflow...");
-
-	/* Here we check when (which cycle) the last packet was sent
-	 * and compare it to what the iso packer was using at the
-	 * time.  If there is a mismatch, we adjust the cycle count in
-	 * the iso packer.  However, there are still up to
-	 * MAX_PACKET_LISTS packet lists queued with bad time stamps,
-	 * so we disable time stamp monitoring for the next
-	 * MAX_PACKET_LISTS packet lists.
-	 */
-	diff = (last->db->payload_desc.status - pl->last_cycle_count) & 0xf;
-	if (diff > 0 && s->stale_count == 0) {
-		atomic_add(diff, &s->cycle_count);
-		atomic_add(diff, &s->cycle_count2);
-		s->stale_count = MAX_PACKET_LISTS;
-	}
-
-	if (s->stale_count > 0)
-		s->stale_count--;
-
-	/* Finally, we move the packet list that was just processed
-	 * back to the free list, and notify any waiters.
-	 */
-	spin_lock(&s->packet_list_lock);
-	list_del(&pl->link);
-	list_add_tail(&pl->link, &s->free_packet_lists);
-	spin_unlock(&s->packet_list_lock);
-
-	wake_up_interruptible(&s->packet_list_wait);
-}
-
-static struct packet *stream_current_packet(struct stream *s)
-{
-	if (s->current_packet_list == NULL &&
-	    (s->current_packet_list = stream_get_free_packet_list(s)) == NULL)
-		return NULL;
-
-	return &s->current_packet_list->packets[s->current_packet];
-}
-
-static void stream_queue_packet(struct stream *s)
-{
-	s->current_packet++;
-	if (s->current_packet == PACKET_LIST_SIZE) {
-		stream_put_dma_packet_list(s, s->current_packet_list);
-		s->current_packet_list = NULL;
-		s->current_packet = 0;
-	}
-}
-
-/* Integer fractional math.  When we transmit a 44k1Hz signal we must
- * send 5 41/80 samples per isochronous cycle, as these occur 8000
- * times a second.  Of course, we must send an integral number of
- * samples in a packet, so we use the integer math to alternate
- * between sending 5 and 6 samples per packet.
- */
-
-static void fraction_init(struct fraction *f, int numerator, int denominator)
-{
-	f->integer = numerator / denominator;
-	f->numerator = numerator % denominator;
-	f->denominator = denominator;
-}
-
-static __inline__ void fraction_add(struct fraction *dst,
-				    struct fraction *src1,
-				    struct fraction *src2)
-{
-	/* assert: src1->denominator == src2->denominator */
-
-	int sum, denom;
-
-	/* We use these two local variables to allow gcc to optimize
-	 * the division and the modulo into only one division. */
-
-	sum = src1->numerator + src2->numerator;
-	denom = src1->denominator;
-	dst->integer = src1->integer + src2->integer + sum / denom;
-	dst->numerator = sum % denom;
-	dst->denominator = denom;
-}
-
-static __inline__ void fraction_sub_int(struct fraction *dst,
-					struct fraction *src, int integer)
-{
-	dst->integer = src->integer - integer;
-	dst->numerator = src->numerator;
-	dst->denominator = src->denominator;
-}
-
-static __inline__ int fraction_floor(struct fraction *frac)
-{
-	return frac->integer;
-}
-
-static __inline__ int fraction_ceil(struct fraction *frac)
-{
-	return frac->integer + (frac->numerator > 0 ? 1 : 0);
-}
-
-static void packet_initialize(struct packet *p, struct packet *next)
-{
-	/* Here we initialize the dma descriptor block for
-	 * transferring one iso packet.  We use two descriptors per
-	 * packet: an OUTPUT_MORE_IMMMEDIATE descriptor for the
-	 * IEEE1394 iso packet header and an OUTPUT_LAST descriptor
-	 * for the payload.
-	 */
-
-	p->db->header_desc.control =
-		DMA_CTL_OUTPUT_MORE | DMA_CTL_IMMEDIATE | 8;
-
-	if (next) {
-		p->db->payload_desc.control =
-			DMA_CTL_OUTPUT_LAST | DMA_CTL_BRANCH;
-		p->db->payload_desc.branch = next->db_bus | 3;
-		p->db->header_desc.skip = next->db_bus | 3;
-	}
-	else {
-		p->db->payload_desc.control =
-			DMA_CTL_OUTPUT_LAST | DMA_CTL_BRANCH |
-			DMA_CTL_UPDATE | DMA_CTL_IRQ;
-		p->db->payload_desc.branch = 0;
-		p->db->header_desc.skip = 0;
-	}
-	p->db->payload_desc.data_address = p->payload_bus;
-	p->db->payload_desc.status = 0;
-}
-
-static struct packet_list *packet_list_alloc(struct stream *s)
-{
-	int i;
-	struct packet_list *pl;
-	struct packet *next;
-
-	pl = kmalloc(sizeof *pl, SLAB_KERNEL);
-	if (pl == NULL)
-		return NULL;
-
-	for (i = 0; i < PACKET_LIST_SIZE; i++) {
-		struct packet *p = &pl->packets[i];
-		p->db = pci_pool_alloc(s->descriptor_pool, SLAB_KERNEL,
-				       &p->db_bus);
-		p->payload = pci_pool_alloc(s->packet_pool, SLAB_KERNEL,
-					    &p->payload_bus);
-	}
-
-	for (i = 0; i < PACKET_LIST_SIZE; i++) {
-		if (i < PACKET_LIST_SIZE - 1)
-			next = &pl->packets[i + 1];
-		else
-			next = NULL;
-		packet_initialize(&pl->packets[i], next);
-	}
-
-	return pl;
-}
-
-static void packet_list_free(struct packet_list *pl, struct stream *s)
-{
-	int i;
-
-	for (i = 0; i < PACKET_LIST_SIZE; i++) {
-		struct packet *p = &pl->packets[i];
-		pci_pool_free(s->descriptor_pool, p->db, p->db_bus);
-		pci_pool_free(s->packet_pool, p->payload, p->payload_bus);
-	}
-	kfree(pl);
-}
-
-static struct buffer *buffer_alloc(int size)
-{
-	struct buffer *b;
-
-	b = kmalloc(sizeof *b + size, SLAB_KERNEL);
-	if (b == NULL)
-		return NULL;
-	b->head = 0;
-	b->tail = 0;
-	b->length = 0;
-	b->size = size;
-
-	return b;
-}
-
-static unsigned char *buffer_get_bytes(struct buffer *buffer, int size)
-{
-	unsigned char *p;
-
-	if (buffer->head + size > buffer->size)
-		BUG();
-
-	p = &buffer->data[buffer->head];
-	buffer->head += size;
-	if (buffer->head == buffer->size)
-		buffer->head = 0;
-	buffer->length -= size;
-
-	return p;
-}
-
-static unsigned char *buffer_put_bytes(struct buffer *buffer,
-				       size_t max, size_t *actual)
-{
-	size_t length;
-	unsigned char *p;
-
-	p = &buffer->data[buffer->tail];
-	length = min(buffer->size - buffer->length, max);
-	if (buffer->tail + length < buffer->size) {
-		*actual = length;
-		buffer->tail += length;
-	}
-	else {
-		*actual = buffer->size - buffer->tail;
-		 buffer->tail = 0;
-	}
-
-	buffer->length += *actual;
-	return p;
-}
-
-static u32 get_iec958_header_bits(struct stream *s, int sub_frame, u32 sample)
-{
-	int csi, parity, shift;
-	int block_start;
-	u32 bits;
-
-	switch (s->iec958_frame_count) {
-	case 1:
-		csi = s->format == AMDTP_FORMAT_IEC958_AC3;
-		break;
-	case 2:
-	case 9:
-		csi = 1;
-		break;
-	case 24 ... 27:
-		csi = (s->iec958_rate_code >> (27 - s->iec958_frame_count)) & 0x01;
-		break;
-	default:
-		csi = 0;
-		break;
-	}
-
-	block_start = (s->iec958_frame_count == 0 && sub_frame == 0);
-
-	/* The parity bit is the xor of the sample bits and the
-	 * channel status info bit. */
-	for (shift = 16, parity = sample ^ csi; shift > 0; shift >>= 1)
-		parity ^= (parity >> shift);
-
-	bits =  (block_start << 5) |		/* Block start bit */
-		((sub_frame == 0) << 4) |	/* Subframe bit */
-		((parity & 1) << 3) |		/* Parity bit */
-		(csi << 2);			/* Channel status info bit */
-
-	return bits;
-}
-
-static u32 get_header_bits(struct stream *s, int sub_frame, u32 sample)
-{
-	switch (s->format) {
-	case AMDTP_FORMAT_IEC958_PCM:
-	case AMDTP_FORMAT_IEC958_AC3:
-		return get_iec958_header_bits(s, sub_frame, sample);
-
-	case AMDTP_FORMAT_RAW:
-		return 0x40;
-
-	default:
-		return 0;
-	}
-}
-
-static void fill_payload_le16(struct stream *s, quadlet_t *data, int nevents)
-{
-	quadlet_t *event, sample, bits;
-	unsigned char *p;
-	int i, j;
-
-	for (i = 0, event = data; i < nevents; i++) {
-
-		for (j = 0; j < s->dimension; j++) {
-			p = buffer_get_bytes(s->input, 2);
-			sample = (p[1] << 16) | (p[0] << 8);
-			bits = get_header_bits(s, j, sample);
-			event[j] = cpu_to_be32((bits << 24) | sample);
-		}
-
-		event += s->dimension;
-		if (++s->iec958_frame_count == 192)
-			s->iec958_frame_count = 0;
-	}
-}
-
-static void fill_packet(struct stream *s, struct packet *packet, int nevents)
-{
-	int syt_index, syt, size;
-	u32 control;
-
-	size = (nevents * s->dimension + 2) * sizeof(quadlet_t);
-
-	/* Update DMA descriptors */
-	packet->db->payload_desc.status = 0;
-	control = packet->db->payload_desc.control & 0xffff0000;
-	packet->db->payload_desc.control = control | size;
-
-	/* Fill IEEE1394 headers */
-	packet->db->header_desc.header[0] =
-		(IEEE1394_SPEED_100 << 16) | (0x01 << 14) |
-		(s->iso_channel << 8) | (TCODE_ISO_DATA << 4);
-	packet->db->header_desc.header[1] = size << 16;
-
-	/* Calculate synchronization timestamp (syt). First we
-	 * determine syt_index, that is, the index in the packet of
-	 * the sample for which the timestamp is valid. */
-	syt_index = (s->syt_interval - s->dbc) & (s->syt_interval - 1);
-	if (syt_index < nevents) {
-		syt = ((atomic_read(&s->cycle_count) << 12) |
-		       s->cycle_offset.integer) & 0xffff;
-		fraction_add(&s->cycle_offset,
-			     &s->cycle_offset, &s->ticks_per_syt_offset);
-
-		/* This next addition should be modulo 8000 (0x1f40),
-		 * but we only use the lower 4 bits of cycle_count, so
-		 * we don't need the modulo. */
-		atomic_add(s->cycle_offset.integer / 3072, &s->cycle_count);
-		s->cycle_offset.integer %= 3072;
-	}
-	else
-		syt = 0xffff;
-
-	atomic_inc(&s->cycle_count2);
-
-	/* Fill cip header */
-	packet->payload->eoh0 = 0;
-	packet->payload->sid = s->host->host->node_id & 0x3f;
-	packet->payload->dbs = s->dimension;
-	packet->payload->fn = 0;
-	packet->payload->qpc = 0;
-	packet->payload->sph = 0;
-	packet->payload->reserved = 0;
-	packet->payload->dbc = s->dbc;
-	packet->payload->eoh1 = 2;
-	packet->payload->fmt = FMT_AMDTP;
-	packet->payload->fdf = s->fdf;
-	packet->payload->syt = cpu_to_be16(syt);
-
-	switch (s->sample_format) {
-	case AMDTP_INPUT_LE16:
-		fill_payload_le16(s, packet->payload->data, nevents);
-		break;
-	}
-
-	s->dbc += nevents;
-}
-
-static void stream_flush(struct stream *s)
-{
-	struct packet *p;
-	int nevents;
-	struct fraction next;
-
-	/* The AMDTP specifies two transmission modes: blocking and
-	 * non-blocking.  In blocking mode you always transfer
-	 * syt_interval or zero samples, whereas in non-blocking mode
-	 * you send as many samples as you have available at transfer
-	 * time.
-	 *
-	 * The fraction samples_per_cycle specifies the number of
-	 * samples that become available per cycle.  We add this to
-	 * the fraction ready_samples, which specifies the number of
-	 * leftover samples from the previous transmission.  The sum,
-	 * stored in the fraction next, specifies the number of
-	 * samples available for transmission, and from this we
-	 * determine the number of samples to actually transmit.
-	 */
-
-	while (1) {
-		fraction_add(&next, &s->ready_samples, &s->samples_per_cycle);
-		if (s->mode == AMDTP_MODE_BLOCKING) {
-			if (fraction_floor(&next) >= s->syt_interval)
-				nevents = s->syt_interval;
-			else
-				nevents = 0;
-		}
-		else
-			nevents = fraction_floor(&next);
-
-		p = stream_current_packet(s);
-		if (s->input->length < nevents * s->dimension * 2 || p == NULL)
-			break;
-
-		fill_packet(s, p, nevents);
-		stream_queue_packet(s);
-
-		/* Now that we have successfully queued the packet for
-		 * transmission, we update the fraction ready_samples. */
-		fraction_sub_int(&s->ready_samples, &next, nevents);
-	}
-}
-
-static int stream_alloc_packet_lists(struct stream *s)
-{
-	int max_nevents, max_packet_size, i;
-
-	if (s->mode == AMDTP_MODE_BLOCKING)
-		max_nevents = s->syt_interval;
-	else
-		max_nevents = fraction_ceil(&s->samples_per_cycle);
-
-	max_packet_size = max_nevents * s->dimension * 4 + 8;
-	s->packet_pool = pci_pool_create("packet pool", s->host->ohci->dev,
-					 max_packet_size, 0, 0);
-
-	if (s->packet_pool == NULL)
-		return -1;
-
-	INIT_LIST_HEAD(&s->free_packet_lists);
-	INIT_LIST_HEAD(&s->dma_packet_lists);
-	for (i = 0; i < MAX_PACKET_LISTS; i++) {
-		struct packet_list *pl = packet_list_alloc(s);
-		if (pl == NULL)
-			break;
-		list_add_tail(&pl->link, &s->free_packet_lists);
-	}
-
-	return i < MAX_PACKET_LISTS ? -1 : 0;
-}
-
-static void stream_free_packet_lists(struct stream *s)
-{
-	struct packet_list *packet_l, *packet_l_next;
-
-	if (s->current_packet_list != NULL)
-		packet_list_free(s->current_packet_list, s);
-	list_for_each_entry_safe(packet_l, packet_l_next, &s->dma_packet_lists, link)
-		packet_list_free(packet_l, s);
-	list_for_each_entry_safe(packet_l, packet_l_next, &s->free_packet_lists, link)
-		packet_list_free(packet_l, s);
-	if (s->packet_pool != NULL)
-		pci_pool_destroy(s->packet_pool);
-
-	s->current_packet_list = NULL;
-	INIT_LIST_HEAD(&s->free_packet_lists);
-	INIT_LIST_HEAD(&s->dma_packet_lists);
-	s->packet_pool = NULL;
-}
-
-static void plug_update(struct cmp_pcr *plug, void *data)
-{
-	struct stream *s = data;
-
-	HPSB_INFO("plug update: p2p_count=%d, channel=%d",
-		  plug->p2p_count, plug->channel);
-	s->iso_channel = plug->channel;
-	if (plug->p2p_count > 0) {
-		struct packet_list *pl;
-
-		pl = list_entry(s->dma_packet_lists.next, struct packet_list, link);
-		stream_start_dma(s, pl);
-	}
-	else {
-		ohci1394_stop_it_ctx(s->host->ohci, s->iso_tasklet.context, 0);
-	}
-}
-
-static int stream_configure(struct stream *s, int cmd, struct amdtp_ioctl *cfg)
-{
-	const int transfer_delay = 9000;
-
-	if (cfg->format <= AMDTP_FORMAT_IEC958_AC3)
-		s->format = cfg->format;
-	else
-		return -EINVAL;
-
-	switch (cfg->rate) {
-	case 32000:
-		s->syt_interval = 8;
-		s->fdf = FDF_SFC_32KHZ;
-		s->iec958_rate_code = 0x0c;
-		break;
-	case 44100:
-		s->syt_interval = 8;
-		s->fdf = FDF_SFC_44K1HZ;
-		s->iec958_rate_code = 0x00;
-		break;
-	case 48000:
-		s->syt_interval = 8;
-		s->fdf = FDF_SFC_48KHZ;
-		s->iec958_rate_code = 0x04;
-		break;
-	case 88200:
-		s->syt_interval = 16;
-		s->fdf = FDF_SFC_88K2HZ;
-		s->iec958_rate_code = 0x00;
-		break;
-	case 96000:
-		s->syt_interval = 16;
-		s->fdf = FDF_SFC_96KHZ;
-		s->iec958_rate_code = 0x00;
-		break;
-	case 176400:
-		s->syt_interval = 32;
-		s->fdf = FDF_SFC_176K4HZ;
-		s->iec958_rate_code = 0x00;
-		break;
-	case 192000:
-		s->syt_interval = 32;
-		s->fdf = FDF_SFC_192KHZ;
-		s->iec958_rate_code = 0x00;
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	s->rate = cfg->rate;
-	fraction_init(&s->samples_per_cycle, s->rate, 8000);
-	fraction_init(&s->ready_samples, 0, 8000);
-
-	/* The ticks_per_syt_offset is initialized to the number of
-	 * ticks between syt_interval events.  The number of ticks per
-	 * second is 24.576e6, so the number of ticks between
-	 * syt_interval events is 24.576e6 * syt_interval / rate.
-	 */
-	fraction_init(&s->ticks_per_syt_offset,
-		      24576000 * s->syt_interval, s->rate);
-	fraction_init(&s->cycle_offset, (transfer_delay % 3072) * s->rate, s->rate);
-	atomic_set(&s->cycle_count, transfer_delay / 3072);
-	atomic_set(&s->cycle_count2, 0);
-
-	s->mode = cfg->mode;
-	s->sample_format = AMDTP_INPUT_LE16;
-
-	/* When using the AM824 raw subformat we can stream signals of
-	 * any dimension.  The IEC958 subformat, however, only
-	 * supports 2 channels.
-	 */
-	if (s->format == AMDTP_FORMAT_RAW || cfg->dimension == 2)
-		s->dimension = cfg->dimension;
-	else
-		return -EINVAL;
-
-	if (s->opcr != NULL) {
-		cmp_unregister_opcr(s->host->host, s->opcr);
-		s->opcr = NULL;
-	}
-
-	switch(cmd) {
-	case AMDTP_IOC_PLUG:
-		s->opcr = cmp_register_opcr(s->host->host, cfg->u.plug,
-					   /*payload*/ 12, plug_update, s);
-		if (s->opcr == NULL)
-			return -EINVAL;
-		s->iso_channel = s->opcr->channel;
-		break;
-
-	case AMDTP_IOC_CHANNEL:
-		if (cfg->u.channel >= 0 && cfg->u.channel < 64)
-			s->iso_channel = cfg->u.channel;
-		else
-			return -EINVAL;
-		break;
-	}
-
-	/* The ioctl settings were all valid, so we realloc the packet
-	 * lists to make sure the packet size is big enough.
-	 */
-	if (s->packet_pool != NULL)
-		stream_free_packet_lists(s);
-
-	if (stream_alloc_packet_lists(s) < 0) {
-		stream_free_packet_lists(s);
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-static struct stream *stream_alloc(struct amdtp_host *host)
-{
-	struct stream *s;
-	unsigned long flags;
-
-        s = kmalloc(sizeof(struct stream), SLAB_KERNEL);
-        if (s == NULL)
-                return NULL;
-
-        memset(s, 0, sizeof(struct stream));
-	s->host = host;
-
-	s->input = buffer_alloc(BUFFER_SIZE);
-	if (s->input == NULL) {
-		kfree(s);
-		return NULL;
-	}
-
-	s->descriptor_pool = pci_pool_create("descriptor pool", host->ohci->dev,
-					     sizeof(struct descriptor_block),
-					     16, 0);
-
-	if (s->descriptor_pool == NULL) {
-		kfree(s->input);
-		kfree(s);
-		return NULL;
-	}
-
-	INIT_LIST_HEAD(&s->free_packet_lists);
-	INIT_LIST_HEAD(&s->dma_packet_lists);
-
-        init_waitqueue_head(&s->packet_list_wait);
-        spin_lock_init(&s->packet_list_lock);
-
-	ohci1394_init_iso_tasklet(&s->iso_tasklet, OHCI_ISO_TRANSMIT,
-				  stream_shift_packet_lists,
-				  (unsigned long) s);
-
-	if (ohci1394_register_iso_tasklet(host->ohci, &s->iso_tasklet) < 0) {
-		pci_pool_destroy(s->descriptor_pool);
-		kfree(s->input);
-		kfree(s);
-		return NULL;
-	}
-
-	spin_lock_irqsave(&host->stream_list_lock, flags);
-	list_add_tail(&s->link, &host->stream_list);
-	spin_unlock_irqrestore(&host->stream_list_lock, flags);
-
-	return s;
-}
-
-static void stream_free(struct stream *s)
-{
-	unsigned long flags;
-
-	/* Stop the DMA.  We wait for the dma packet list to become
-	 * empty and let the dma controller run out of programs.  This
-	 * seems to be more reliable than stopping it directly, since
-	 * that sometimes generates an it transmit interrupt if we
-	 * later re-enable the context.
-	 */
-	wait_event_interruptible(s->packet_list_wait,
-				 list_empty(&s->dma_packet_lists));
-
-	ohci1394_stop_it_ctx(s->host->ohci, s->iso_tasklet.context, 1);
-	ohci1394_unregister_iso_tasklet(s->host->ohci, &s->iso_tasklet);
-
-	if (s->opcr != NULL)
-		cmp_unregister_opcr(s->host->host, s->opcr);
-
-	spin_lock_irqsave(&s->host->stream_list_lock, flags);
-	list_del(&s->link);
-	spin_unlock_irqrestore(&s->host->stream_list_lock, flags);
-
-	kfree(s->input);
-
-	stream_free_packet_lists(s);
-	pci_pool_destroy(s->descriptor_pool);
-
-	kfree(s);
-}
-
-/* File operations */
-
-static ssize_t amdtp_write(struct file *file, const char __user *buffer, size_t count,
-			   loff_t *offset_is_ignored)
-{
-	struct stream *s = file->private_data;
-	unsigned char *p;
-	int i;
-	size_t length;
-
-	if (s->packet_pool == NULL)
-		return -EBADFD;
-
-	/* Fill the circular buffer from the input buffer and call the
-	 * iso packer when the buffer is full.  The iso packer may
-	 * leave bytes in the buffer for two reasons: either the
-	 * remaining bytes wasn't enough to build a new packet, or
-	 * there were no free packet lists.  In the first case we
-	 * re-fill the buffer and call the iso packer again or return
-	 * if we used all the data from userspace.  In the second
-	 * case, the wait_event_interruptible will block until the irq
-	 * handler frees a packet list.
-	 */
-
-	for (i = 0; i < count; i += length) {
-		p = buffer_put_bytes(s->input, count - i, &length);
-		if (copy_from_user(p, buffer + i, length))
-			return -EFAULT;
-		if (s->input->length < s->input->size)
-			continue;
-
-		stream_flush(s);
-
-		if (s->current_packet_list != NULL)
-			continue;
-
-		if (file->f_flags & O_NONBLOCK)
-			return i + length > 0 ? i + length : -EAGAIN;
-
-		if (wait_event_interruptible(s->packet_list_wait,
-					     !list_empty(&s->free_packet_lists)))
-			return -EINTR;
-	}
-
-	return count;
-}
-
-static long amdtp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct stream *s = file->private_data;
-	struct amdtp_ioctl cfg;
-	int err;
-	lock_kernel();
-	switch(cmd)
-	{
-	case AMDTP_IOC_PLUG:
-	case AMDTP_IOC_CHANNEL:
-		if (copy_from_user(&cfg, (struct amdtp_ioctl __user *) arg, sizeof cfg))
-			err = -EFAULT;
-		else
-			err = stream_configure(s, cmd, &cfg);
-		break;
-
-	default:
-		err = -EINVAL;
-		break;
-	}
-	unlock_kernel();
-	return err;
-}
-
-static unsigned int amdtp_poll(struct file *file, poll_table *pt)
-{
-	struct stream *s = file->private_data;
-
-	poll_wait(file, &s->packet_list_wait, pt);
-
-	if (!list_empty(&s->free_packet_lists))
-		return POLLOUT | POLLWRNORM;
-	else
-		return 0;
-}
-
-static int amdtp_open(struct inode *inode, struct file *file)
-{
-	struct amdtp_host *host;
-	int i = ieee1394_file_to_instance(file);
-
-	host = hpsb_get_hostinfo_bykey(&amdtp_highlevel, i);
-	if (host == NULL)
-		return -ENODEV;
-
-	file->private_data = stream_alloc(host);
-	if (file->private_data == NULL)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static int amdtp_release(struct inode *inode, struct file *file)
-{
-	struct stream *s = file->private_data;
-
-	stream_free(s);
-
-	return 0;
-}
-
-static struct cdev amdtp_cdev;
-static struct file_operations amdtp_fops =
-{
-	.owner =	THIS_MODULE,
-	.write =	amdtp_write,
-	.poll =		amdtp_poll,
-	.unlocked_ioctl = amdtp_ioctl,
-	.compat_ioctl = amdtp_ioctl, /* All amdtp ioctls are compatible */
-	.open =		amdtp_open,
-	.release =	amdtp_release
-};
-
-/* IEEE1394 Subsystem functions */
-
-static void amdtp_add_host(struct hpsb_host *host)
-{
-	struct amdtp_host *ah;
-	int minor;
-
-	if (strcmp(host->driver->name, OHCI1394_DRIVER_NAME) != 0)
-		return;
-
-	ah = hpsb_create_hostinfo(&amdtp_highlevel, host, sizeof(*ah));
-	if (!ah) {
-		HPSB_ERR("amdtp: Unable able to alloc hostinfo");
-		return;
-	}
-
-	ah->host = host;
-	ah->ohci = host->hostdata;
-
-	hpsb_set_hostinfo_key(&amdtp_highlevel, host, ah->host->id);
-
-	minor = IEEE1394_MINOR_BLOCK_AMDTP * 16 + ah->host->id;
-
-	INIT_LIST_HEAD(&ah->stream_list);
-	spin_lock_init(&ah->stream_list_lock);
-
-	devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, minor),
-			S_IFCHR|S_IRUSR|S_IWUSR, "amdtp/%d", ah->host->id);
-}
-
-static void amdtp_remove_host(struct hpsb_host *host)
-{
-	struct amdtp_host *ah = hpsb_get_hostinfo(&amdtp_highlevel, host);
-
-	if (ah)
-		devfs_remove("amdtp/%d", ah->host->id);
-
-	return;
-}
-
-static struct hpsb_highlevel amdtp_highlevel = {
-	.name =		"amdtp",
-	.add_host =	amdtp_add_host,
-	.remove_host =	amdtp_remove_host,
-};
-
-/* Module interface */
-
-MODULE_AUTHOR("Kristian Hogsberg <hogsberg@users.sf.net>");
-MODULE_DESCRIPTION("Driver for Audio & Music Data Transmission Protocol "
-		   "on OHCI boards.");
-MODULE_SUPPORTED_DEVICE("amdtp");
-MODULE_LICENSE("GPL");
-
-static int __init amdtp_init_module (void)
-{
-	cdev_init(&amdtp_cdev, &amdtp_fops);
-	amdtp_cdev.owner = THIS_MODULE;
-	kobject_set_name(&amdtp_cdev.kobj, "amdtp");
-	if (cdev_add(&amdtp_cdev, IEEE1394_AMDTP_DEV, 16)) {
-		HPSB_ERR("amdtp: unable to add char device");
- 		return -EIO;
- 	}
-
-	devfs_mk_dir("amdtp");
-
-	hpsb_register_highlevel(&amdtp_highlevel);
-
-	HPSB_INFO("Loaded AMDTP driver");
-
-	return 0;
-}
-
-static void __exit amdtp_exit_module (void)
-{
-        hpsb_unregister_highlevel(&amdtp_highlevel);
-	devfs_remove("amdtp");
-	cdev_del(&amdtp_cdev);
-
-	HPSB_INFO("Unloaded AMDTP driver");
-}
-
-module_init(amdtp_init_module);
-module_exit(amdtp_exit_module);
diff -purN linux-2.6.15-git12/drivers/ieee1394/amdtp.h linux-2.6.16-rc1/drivers/ieee1394/amdtp.h
--- linux-2.6.15-git12/drivers/ieee1394/amdtp.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/ieee1394/amdtp.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,84 +0,0 @@
-/* -*- c-basic-offset: 8 -*- */
-
-#ifndef __AMDTP_H
-#define __AMDTP_H
-
-#include <asm/types.h>
-#include "ieee1394-ioctl.h"
-
-/* The userspace interface for the Audio & Music Data Transmission
- * Protocol driver is really simple. First, open /dev/amdtp, use the
- * ioctl to configure format, rate, dimension and either plug or
- * channel, then start writing samples.
- *
- * The formats supported by the driver are listed below.
- * AMDTP_FORMAT_RAW corresponds to the AM824 raw format, which can
- * carry any number of channels, so use this if you're streaming
- * multichannel audio.  The AMDTP_FORMAT_IEC958_PCM corresponds to the
- * AM824 IEC958 encapsulation without the IEC958 data bit set, using
- * AMDTP_FORMAT_IEC958_AC3 will transmit the samples with the data bit
- * set, suitable for transmitting compressed AC-3 audio.
- *
- * The rate field specifies the transmission rate; supported values
- * are 32000, 44100, 48000, 88200, 96000, 176400 and 192000.
- *
- * The dimension field specifies the dimension of the signal, that is,
- * the number of audio channels.  Only AMDTP_FORMAT_RAW supports
- * settings greater than 2.
- *
- * The mode field specifies which transmission mode to use. The AMDTP
- * specifies two different transmission modes: blocking and
- * non-blocking.  The blocking transmission mode always send a fixed
- * number of samples, typically 8, 16 or 32.  To exactly match the
- * transmission rate, the driver alternates between sending empty and
- * non-empty packets.  In non-blocking mode, the driver transmits as
- * small packets as possible.  For example, for a transmission rate of
- * 44100Hz, the driver should send 5 41/80 samples in every cycle, but
- * this is not possible so instead the driver alternates between
- * sending 5 and 6 samples.
- *
- * The last thing to specify is either the isochronous channel to use
- * or the output plug to connect to.  If you know what channel the
- * destination device will listen on, you can specify the channel
- * directly and use the AMDTP_IOC_CHANNEL ioctl.  However, if the
- * destination device chooses the channel and uses the IEC61883-1 plug
- * mechanism, you can specify an output plug to connect to.  The
- * driver will pick up the channel number from the plug once the
- * destination device locks the output plug control register.  In this
- * case set the plug field and use the AMDTP_IOC_PLUG ioctl.
- *
- * Having configured the interface, the driver now accepts writes of
- * regular 16 bit signed little endian samples, with the channels
- * interleaved.  For example, 4 channels would look like:
- *
- *   | sample 0                                      | sample 1    ...
- *   | ch. 0     | ch. 1     | ch. 2     | ch. 3     | ch. 0     | ...
- *   | lsb | msb | lsb | msb | lsb | msb | lsb | msb | lsb | msb | ...
- *
- */
-
-enum {
-	AMDTP_FORMAT_RAW,
-	AMDTP_FORMAT_IEC958_PCM,
-	AMDTP_FORMAT_IEC958_AC3
-};
-
-enum {
-	AMDTP_MODE_BLOCKING,
-	AMDTP_MODE_NON_BLOCKING,
-};
-
-enum {
-	AMDTP_INPUT_LE16,
-	AMDTP_INPUT_BE16,
-};
-
-struct amdtp_ioctl {
-	__u32 format;
-	__u32 rate;
-	__u32 dimension;
-	__u32 mode;
-	union { __u32 channel; __u32 plug; } u;
-};
-
-#endif /* __AMDTP_H */
diff -purN linux-2.6.15-git12/drivers/ieee1394/cmp.c linux-2.6.16-rc1/drivers/ieee1394/cmp.c
--- linux-2.6.15-git12/drivers/ieee1394/cmp.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/ieee1394/cmp.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,311 +0,0 @@
-/* -*- c-basic-offset: 8 -*-
- *
- * cmp.c - Connection Management Procedures
- * Copyright (C) 2001 Kristian Hgsberg
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* TODO
- * ----
- *
- * - Implement IEC61883-1 output plugs and connection management.
- *   This should probably be part of the general subsystem, as it could
- *   be shared with dv1394.
- *
- * - Add IEC61883 unit directory when loading this module.  This
- *   requires a run-time changeable config rom.
- */
-
-#include <linux/module.h>
-#include <linux/list.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/wait.h>
-#include <linux/interrupt.h>
-
-#include "hosts.h"
-#include "highlevel.h"
-#include "ieee1394.h"
-#include "ieee1394_core.h"
-#include "cmp.h"
-
-struct plug {
-	union {
-		struct cmp_pcr pcr;
-		quadlet_t quadlet;
-	} u;
-	void (*update)(struct cmp_pcr *plug, void *data);
-	void *data;
-};
-
-struct cmp_host {
-	struct hpsb_host *host;
-
-	union {
-		struct cmp_mpr ompr;
-		quadlet_t ompr_quadlet;
-	} u;
-	struct plug opcr[2];
-
-	union {
-		struct cmp_mpr impr;
-		quadlet_t impr_quadlet;
-	} v;
-	struct plug ipcr[2];
-};
-
-enum {
-	CMP_P2P_CONNECTION,
-	CMP_BC_CONNECTION
-};
-
-#define CSR_PCR_MAP      0x900
-#define CSR_PCR_MAP_END  0x9fc
-
-static struct hpsb_highlevel cmp_highlevel;
-
-static void cmp_add_host(struct hpsb_host *host);
-static void cmp_host_reset(struct hpsb_host *host);
-static int pcr_read(struct hpsb_host *host, int nodeid, quadlet_t *buf,
-		    u64 addr, size_t length, u16 flags);
-static int pcr_lock(struct hpsb_host *host, int nodeid, quadlet_t *store,
-		    u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 flags);
-
-static struct hpsb_highlevel cmp_highlevel = {
-	.name =		"cmp",
-	.add_host =	cmp_add_host,
-	.host_reset =	cmp_host_reset,
-};
-
-static struct hpsb_address_ops pcr_ops = {
-	.read =	pcr_read,
-	.lock =	pcr_lock,
-};
-
-
-struct cmp_pcr *
-cmp_register_opcr(struct hpsb_host *host, int opcr_number, int payload,
-		  void (*update)(struct cmp_pcr *pcr, void *data),
-		  void *data)
-{
-	struct cmp_host *ch;
-	struct plug *plug;
-
-	ch = hpsb_get_hostinfo(&cmp_highlevel, host);
-
-	if (opcr_number >= ch->u.ompr.nplugs ||
-	    ch->opcr[opcr_number].update != NULL)
-		return NULL;
-
-	plug = &ch->opcr[opcr_number];
-	plug->u.pcr.online = 1;
-	plug->u.pcr.bcast_count = 0;
-	plug->u.pcr.p2p_count = 0;
-	plug->u.pcr.overhead = 0;
-	plug->u.pcr.payload = payload;
-	plug->update = update;
-	plug->data = data;
-
-	return &plug->u.pcr;
-}
-
-void cmp_unregister_opcr(struct hpsb_host *host, struct cmp_pcr *opcr)
-{
-	struct cmp_host *ch;
-	struct plug *plug;
-
-	ch = hpsb_get_hostinfo(&cmp_highlevel, host);
-	plug = (struct plug *)opcr;
-	if (plug - ch->opcr >= ch->u.ompr.nplugs) BUG();
-
-	plug->u.pcr.online = 0;
-	plug->update = NULL;
-}
-
-static void reset_plugs(struct cmp_host *ch)
-{
-	int i;
-
-	ch->u.ompr.non_persistent_ext = 0xff;
-	for (i = 0; i < ch->u.ompr.nplugs; i++) {
-		ch->opcr[i].u.pcr.bcast_count = 0;
-		ch->opcr[i].u.pcr.p2p_count = 0;
-		ch->opcr[i].u.pcr.overhead = 0;
-	}
-}
-
-static void cmp_add_host(struct hpsb_host *host)
-{
-	struct cmp_host *ch = hpsb_create_hostinfo(&cmp_highlevel, host, sizeof (*ch));
-
-	if (ch == NULL) {
-		HPSB_ERR("Failed to allocate cmp_host");
-		return;
-	}
-
-	hpsb_register_addrspace(&cmp_highlevel, host, &pcr_ops,
-				CSR_REGISTER_BASE + CSR_PCR_MAP,
-				CSR_REGISTER_BASE + CSR_PCR_MAP_END);
-
-	ch->host = host;
-	ch->u.ompr.rate = IEEE1394_SPEED_100;
-	ch->u.ompr.bcast_channel_base = 63;
-	ch->u.ompr.nplugs = 2;
-
-	reset_plugs(ch);
-}
-
-static void cmp_host_reset(struct hpsb_host *host)
-{
-	struct cmp_host *ch;
-
-	ch = hpsb_get_hostinfo(&cmp_highlevel, host);
-	if (ch == NULL) {
-		HPSB_ERR("cmp: Tried to reset unknown host");
-		return;
-	}
-
-	reset_plugs(ch);
-}
-
-static int pcr_read(struct hpsb_host *host, int nodeid, quadlet_t *buf,
-		    u64 addr, size_t length, u16 flags)
-{
-	int csraddr = addr - CSR_REGISTER_BASE;
-	int plug;
-	struct cmp_host *ch;
-
-	if (length != 4)
-		return RCODE_TYPE_ERROR;
-
-	ch = hpsb_get_hostinfo(&cmp_highlevel, host);
-	if (csraddr == 0x900) {
-		*buf = cpu_to_be32(ch->u.ompr_quadlet);
-		return RCODE_COMPLETE;
-	}
-	else if (csraddr < 0x904 + ch->u.ompr.nplugs * 4) {
-		plug = (csraddr - 0x904) / 4;
-		*buf = cpu_to_be32(ch->opcr[plug].u.quadlet);
-		return RCODE_COMPLETE;
-	}
-	else if (csraddr < 0x980) {
-		return RCODE_ADDRESS_ERROR;
-	}
-	else if (csraddr == 0x980) {
-		*buf = cpu_to_be32(ch->v.impr_quadlet);
-		return RCODE_COMPLETE;
-	}
-	else if (csraddr < 0x984 + ch->v.impr.nplugs * 4) {
-		plug = (csraddr - 0x984) / 4;
-		*buf = cpu_to_be32(ch->ipcr[plug].u.quadlet);
-		return RCODE_COMPLETE;
-	}
-	else
-		return RCODE_ADDRESS_ERROR;
-}
-
-static int pcr_lock(struct hpsb_host *host, int nodeid, quadlet_t *store,
-		    u64 addr, quadlet_t data, quadlet_t arg, int extcode, u16 flags)
-{
-	int csraddr = addr - CSR_REGISTER_BASE;
-	int plug;
-	struct cmp_host *ch;
-
-	ch = hpsb_get_hostinfo(&cmp_highlevel, host);
-
-	if (extcode != EXTCODE_COMPARE_SWAP)
-		return RCODE_TYPE_ERROR;
-
-	if (csraddr == 0x900) {
-		/* FIXME: Ignore writes to bits 30-31 and 0-7 */
-		*store = cpu_to_be32(ch->u.ompr_quadlet);
-		if (arg == cpu_to_be32(ch->u.ompr_quadlet))
-			ch->u.ompr_quadlet = be32_to_cpu(data);
-
-		return RCODE_COMPLETE;
-	}
-	if (csraddr < 0x904 + ch->u.ompr.nplugs * 4) {
-		plug = (csraddr - 0x904) / 4;
-		*store = cpu_to_be32(ch->opcr[plug].u.quadlet);
-
-		if (arg == *store)
-			ch->opcr[plug].u.quadlet = be32_to_cpu(data);
-
-		if (be32_to_cpu(*store) != ch->opcr[plug].u.quadlet &&
-		    ch->opcr[plug].update != NULL)
-			ch->opcr[plug].update(&ch->opcr[plug].u.pcr,
-					      ch->opcr[plug].data);
-
-		return RCODE_COMPLETE;
-	}
-	else if (csraddr < 0x980) {
-		return RCODE_ADDRESS_ERROR;
-	}
-	else if (csraddr == 0x980) {
-		/* FIXME: Ignore writes to bits 24-31 and 0-7 */
-		*store = cpu_to_be32(ch->u.ompr_quadlet);
-		if (arg == cpu_to_be32(ch->u.ompr_quadlet))
-			ch->u.ompr_quadlet = be32_to_cpu(data);
-
-		return RCODE_COMPLETE;
-	}
-	else if (csraddr < 0x984 + ch->v.impr.nplugs * 4) {
-		plug = (csraddr - 0x984) / 4;
-		*store = cpu_to_be32(ch->ipcr[plug].u.quadlet);
-
-		if (arg == *store)
-			ch->ipcr[plug].u.quadlet = be32_to_cpu(data);
-
-		if (be32_to_cpu(*store) != ch->ipcr[plug].u.quadlet &&
-		    ch->ipcr[plug].update != NULL)
-			ch->ipcr[plug].update(&ch->ipcr[plug].u.pcr,
-					      ch->ipcr[plug].data);
-
-		return RCODE_COMPLETE;
-	}
-	else
-		return RCODE_ADDRESS_ERROR;
-}
-
-
-/* Module interface */
-
-MODULE_AUTHOR("Kristian Hogsberg <hogsberg@users.sf.net>");
-MODULE_DESCRIPTION("Connection Management Procedures (CMP)");
-MODULE_SUPPORTED_DEVICE("cmp");
-MODULE_LICENSE("GPL");
-
-EXPORT_SYMBOL(cmp_register_opcr);
-EXPORT_SYMBOL(cmp_unregister_opcr);
-
-static int __init cmp_init_module (void)
-{
-	hpsb_register_highlevel (&cmp_highlevel);
-
-	HPSB_INFO("Loaded CMP driver");
-
-	return 0;
-}
-
-static void __exit cmp_exit_module (void)
-{
-        hpsb_unregister_highlevel(&cmp_highlevel);
-
-	HPSB_INFO("Unloaded CMP driver");
-}
-
-module_init(cmp_init_module);
-module_exit(cmp_exit_module);
diff -purN linux-2.6.15-git12/drivers/ieee1394/cmp.h linux-2.6.16-rc1/drivers/ieee1394/cmp.h
--- linux-2.6.15-git12/drivers/ieee1394/cmp.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/ieee1394/cmp.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,31 +0,0 @@
-#ifndef __CMP_H
-#define __CMP_H
-
-struct cmp_mpr {
-	u32 nplugs:5;
-	u32 reserved:3;
-	u32 persistent_ext:8;
-	u32 non_persistent_ext:8;
-	u32 bcast_channel_base:6;
-	u32 rate:2;
-} __attribute__((packed));
-
-struct cmp_pcr {
-	u32 payload:10;
-	u32 overhead:4;
-	u32 speed:2;
-	u32 channel:6;
-	u32 reserved:2;
-	u32 p2p_count:6;
-	u32 bcast_count:1;
-	u32 online:1;
-} __attribute__((packed));
-
-struct cmp_pcr *cmp_register_opcr(struct hpsb_host *host, int plug,
-				  int payload,
-				  void (*update)(struct cmp_pcr *plug,
-						 void *data),
-				  void *data);
-void cmp_unregister_opcr(struct hpsb_host *host, struct cmp_pcr *plug);
-
-#endif /* __CMP_H */
diff -purN linux-2.6.15-git12/drivers/input/touchscreen/Kconfig linux-2.6.16-rc1/drivers/input/touchscreen/Kconfig
--- linux-2.6.15-git12/drivers/input/touchscreen/Kconfig	2006-01-17 08:21:32.192731329 +0000
+++ linux-2.6.16-rc1/drivers/input/touchscreen/Kconfig	2006-01-17 08:22:46.373372480 +0000
@@ -98,7 +98,7 @@ config TOUCHSCREEN_MK712
 
 config TOUCHSCREEN_HP600
 	tristate "HP Jornada 680/690 touchscreen"
-	depends on SH_HP600 && SH_ADC
+	depends on SH_HP6XX && SH_ADC
 	help
 	  Say Y here if you have a HP Jornada 680 or 690 and want to
           support the built-in touchscreen.
diff -purN linux-2.6.15-git12/drivers/md/md.c linux-2.6.16-rc1/drivers/md/md.c
--- linux-2.6.15-git12/drivers/md/md.c	2006-01-17 08:21:32.376831109 +0000
+++ linux-2.6.16-rc1/drivers/md/md.c	2006-01-17 08:22:46.549344773 +0000
@@ -3395,6 +3395,7 @@ static int set_array_info(mddev_t * mdde
 	mddev->ctime         = get_seconds();
 
 	mddev->level         = info->level;
+	mddev->clevel[0]     = 0;
 	mddev->size          = info->size;
 	mddev->raid_disks    = info->raid_disks;
 	/* don't set md_minor, it is determined by which /dev/md* was
diff -purN linux-2.6.15-git12/drivers/media/dvb/bt8xx/bt878.c linux-2.6.16-rc1/drivers/media/dvb/bt8xx/bt878.c
--- linux-2.6.15-git12/drivers/media/dvb/bt8xx/bt878.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/bt8xx/bt878.c	2006-01-17 08:22:46.624332966 +0000
@@ -542,7 +542,7 @@ static struct pci_driver bt878_pci_drive
       .remove	= bt878_remove,
 };
 
-static int bt878_pci_driver_registered = 0;
+static int bt878_pci_driver_registered;
 
 /*******************************/
 /* Module management functions */
diff -purN linux-2.6.15-git12/drivers/media/dvb/bt8xx/dvb-bt8xx.c linux-2.6.16-rc1/drivers/media/dvb/bt8xx/dvb-bt8xx.c
--- linux-2.6.15-git12/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2006-01-17 08:21:32.460817885 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/bt8xx/dvb-bt8xx.c	2006-01-17 08:22:46.633331549 +0000
@@ -893,7 +893,7 @@ static int dvb_bt8xx_probe(struct bttv_s
 	return 0;
 }
 
-static int dvb_bt8xx_remove(struct bttv_sub_device *sub)
+static void dvb_bt8xx_remove(struct bttv_sub_device *sub)
 {
 	struct dvb_bt8xx_card *card = dev_get_drvdata(&sub->dev);
 
@@ -911,8 +911,6 @@ static int dvb_bt8xx_remove(struct bttv_
 	dvb_unregister_adapter(&card->dvb_adapter);
 
 	kfree(card);
-
-	return 0;
 }
 
 static struct bttv_sub_driver driver = {
diff -purN linux-2.6.15-git12/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.16-rc1/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.15-git12/drivers/media/dvb/dvb-core/dvbdev.c	2006-01-17 08:21:32.491813005 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/dvb-core/dvbdev.c	2006-01-17 08:22:46.664326669 +0000
@@ -33,7 +33,7 @@
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/cdev.h>
-
+#include <linux/mutex.h>
 #include "dvbdev.h"
 
 static int dvbdev_debug;
@@ -44,7 +44,7 @@ MODULE_PARM_DESC(dvbdev_debug, "Turn on/
 #define dprintk if (dvbdev_debug) printk
 
 static LIST_HEAD(dvb_adapter_list);
-static DECLARE_MUTEX(dvbdev_register_lock);
+static DEFINE_MUTEX(dvbdev_register_lock);
 
 static const char * const dnames[] = {
 	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
@@ -202,11 +202,11 @@ int dvb_register_device(struct dvb_adapt
 	struct dvb_device *dvbdev;
 	int id;
 
-	if (down_interruptible (&dvbdev_register_lock))
+	if (mutex_lock_interruptible(&dvbdev_register_lock))
 		return -ERESTARTSYS;
 
 	if ((id = dvbdev_get_free_id (adap, type)) < 0) {
-		up (&dvbdev_register_lock);
+		mutex_unlock(&dvbdev_register_lock);
 		*pdvbdev = NULL;
 		printk ("%s: could get find free device id...\n", __FUNCTION__);
 		return -ENFILE;
@@ -215,11 +215,11 @@ int dvb_register_device(struct dvb_adapt
 	*pdvbdev = dvbdev = kmalloc(sizeof(struct dvb_device), GFP_KERNEL);
 
 	if (!dvbdev) {
-		up(&dvbdev_register_lock);
+		mutex_unlock(&dvbdev_register_lock);
 		return -ENOMEM;
 	}
 
-	up (&dvbdev_register_lock);
+	mutex_unlock(&dvbdev_register_lock);
 
 	memcpy(dvbdev, template, sizeof(struct dvb_device));
 	dvbdev->type = type;
@@ -289,11 +289,11 @@ int dvb_register_adapter(struct dvb_adap
 {
 	int num;
 
-	if (down_interruptible (&dvbdev_register_lock))
+	if (mutex_lock_interruptible(&dvbdev_register_lock))
 		return -ERESTARTSYS;
 
 	if ((num = dvbdev_get_free_adapter_num ()) < 0) {
-		up (&dvbdev_register_lock);
+		mutex_unlock(&dvbdev_register_lock);
 		return -ENFILE;
 	}
 
@@ -309,7 +309,7 @@ int dvb_register_adapter(struct dvb_adap
 
 	list_add_tail (&adap->list_head, &dvb_adapter_list);
 
-	up (&dvbdev_register_lock);
+	mutex_unlock(&dvbdev_register_lock);
 
 	return num;
 }
@@ -320,10 +320,10 @@ int dvb_unregister_adapter(struct dvb_ad
 {
 	devfs_remove("dvb/adapter%d", adap->num);
 
-	if (down_interruptible (&dvbdev_register_lock))
+	if (mutex_lock_interruptible(&dvbdev_register_lock))
 		return -ERESTARTSYS;
 	list_del (&adap->list_head);
-	up (&dvbdev_register_lock);
+	mutex_unlock(&dvbdev_register_lock);
 	return 0;
 }
 EXPORT_SYMBOL(dvb_unregister_adapter);
diff -purN linux-2.6.15-git12/drivers/media/dvb/dvb-usb/cxusb.c linux-2.6.16-rc1/drivers/media/dvb/dvb-usb/cxusb.c
--- linux-2.6.15-git12/drivers/media/dvb/dvb-usb/cxusb.c	2006-01-17 08:21:32.502811273 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/dvb-usb/cxusb.c	2006-01-17 08:22:46.674457000 +0000
@@ -691,6 +691,8 @@ module_init (cxusb_module_init);
 module_exit (cxusb_module_exit);
 
 MODULE_AUTHOR("Patrick Boettcher <patrick.boettcher@desy.de>");
+MODULE_AUTHOR("Michael Krufky <mkrufky@m1k.net>");
+MODULE_AUTHOR("Chris Pascoe <c.pascoe@itee.uq.edu.au>");
 MODULE_DESCRIPTION("Driver for Conexant USB2.0 hybrid reference design");
 MODULE_VERSION("1.0-alpha");
 MODULE_LICENSE("GPL");
diff -purN linux-2.6.15-git12/drivers/media/dvb/frontends/dvb-pll.c linux-2.6.16-rc1/drivers/media/dvb/frontends/dvb-pll.c
--- linux-2.6.15-git12/drivers/media/dvb/frontends/dvb-pll.c	2006-01-17 08:21:32.563801671 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/frontends/dvb-pll.c	2006-01-17 08:22:46.731448027 +0000
@@ -333,7 +333,7 @@ struct dvb_pll_desc dvb_pll_tbmv30111in 
 	.name = "Samsung TBMV30111IN",
 	.min = 54000000,
 	.max = 860000000,
-	.count = 4,
+	.count = 6,
 	.entries = {
 		{ 172000000, 44000000, 166666, 0xb4, 0x01 },
 		{ 214000000, 44000000, 166666, 0xb4, 0x02 },
diff -purN linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110.c linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110.c
--- linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110.c	2006-01-17 08:21:32.610794272 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110.c	2006-01-17 08:22:46.776440943 +0000
@@ -81,7 +81,7 @@ static int adac = DVB_ADAC_TI;
 static int hw_sections;
 static int rgb_on;
 static int volume = 255;
-static int budgetpatch = 0;
+static int budgetpatch;
 
 module_param_named(debug, av7110_debug, int, 0644);
 MODULE_PARM_DESC(debug, "debug level (bitmask, default 0)");
@@ -103,7 +103,7 @@ MODULE_PARM_DESC(budgetpatch, "use budge
 
 static void restart_feeds(struct av7110 *av7110);
 
-static int av7110_num = 0;
+static int av7110_num;
 
 #define FE_FUNC_OVERRIDE(fe_func, av7110_copy, av7110_func) \
 {\
diff -purN linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110_hw.c linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110_hw.c
--- linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110_hw.c	2006-01-17 08:21:32.618793012 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110_hw.c	2006-01-17 08:22:46.784439683 +0000
@@ -146,52 +146,52 @@ static int load_dram(struct av7110 *av71
 {
 	int i;
 	int blocks, rest;
-	u32 base, bootblock = BOOT_BLOCK;
+	u32 base, bootblock = AV7110_BOOT_BLOCK;
 
 	dprintk(4, "%p\n", av7110);
 
-	blocks = len / BOOT_MAX_SIZE;
-	rest = len % BOOT_MAX_SIZE;
+	blocks = len / AV7110_BOOT_MAX_SIZE;
+	rest = len % AV7110_BOOT_MAX_SIZE;
 	base = DRAM_START_CODE;
 
 	for (i = 0; i < blocks; i++) {
-		if (waitdebi(av7110, BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
+		if (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
 			printk(KERN_ERR "dvb-ttpci: load_dram(): timeout at block %d\n", i);
 			return -ETIMEDOUT;
 		}
 		dprintk(4, "writing DRAM block %d\n", i);
 		mwdebi(av7110, DEBISWAB, bootblock,
-		       ((char*)data) + i * BOOT_MAX_SIZE, BOOT_MAX_SIZE);
+		       ((char*)data) + i * AV7110_BOOT_MAX_SIZE, AV7110_BOOT_MAX_SIZE);
 		bootblock ^= 0x1400;
-		iwdebi(av7110, DEBISWAB, BOOT_BASE, swab32(base), 4);
-		iwdebi(av7110, DEBINOSWAP, BOOT_SIZE, BOOT_MAX_SIZE, 2);
-		iwdebi(av7110, DEBINOSWAP, BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
-		base += BOOT_MAX_SIZE;
+		iwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);
+		iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, AV7110_BOOT_MAX_SIZE, 2);
+		iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
+		base += AV7110_BOOT_MAX_SIZE;
 	}
 
 	if (rest > 0) {
-		if (waitdebi(av7110, BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
+		if (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
 			printk(KERN_ERR "dvb-ttpci: load_dram(): timeout at last block\n");
 			return -ETIMEDOUT;
 		}
 		if (rest > 4)
 			mwdebi(av7110, DEBISWAB, bootblock,
-			       ((char*)data) + i * BOOT_MAX_SIZE, rest);
+			       ((char*)data) + i * AV7110_BOOT_MAX_SIZE, rest);
 		else
 			mwdebi(av7110, DEBISWAB, bootblock,
-			       ((char*)data) + i * BOOT_MAX_SIZE - 4, rest + 4);
+			       ((char*)data) + i * AV7110_BOOT_MAX_SIZE - 4, rest + 4);
 
-		iwdebi(av7110, DEBISWAB, BOOT_BASE, swab32(base), 4);
-		iwdebi(av7110, DEBINOSWAP, BOOT_SIZE, rest, 2);
-		iwdebi(av7110, DEBINOSWAP, BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
+		iwdebi(av7110, DEBISWAB, AV7110_BOOT_BASE, swab32(base), 4);
+		iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, rest, 2);
+		iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
 	}
-	if (waitdebi(av7110, BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
+	if (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_EMPTY) < 0) {
 		printk(KERN_ERR "dvb-ttpci: load_dram(): timeout after last block\n");
 		return -ETIMEDOUT;
 	}
-	iwdebi(av7110, DEBINOSWAP, BOOT_SIZE, 0, 2);
-	iwdebi(av7110, DEBINOSWAP, BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
-	if (waitdebi(av7110, BOOT_STATE, BOOTSTATE_BOOT_COMPLETE) < 0) {
+	iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_SIZE, 0, 2);
+	iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
+	if (waitdebi(av7110, AV7110_BOOT_STATE, BOOTSTATE_AV7110_BOOT_COMPLETE) < 0) {
 		printk(KERN_ERR "dvb-ttpci: load_dram(): final handshake timeout\n");
 		return -ETIMEDOUT;
 	}
@@ -262,7 +262,7 @@ int av7110_bootarm(struct av7110 *av7110
 	//saa7146_setgpio(dev, 3, SAA7146_GPIO_INPUT);
 
 	mwdebi(av7110, DEBISWAB, DPRAM_BASE, bootcode, sizeof(bootcode));
-	iwdebi(av7110, DEBINOSWAP, BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
+	iwdebi(av7110, DEBINOSWAP, AV7110_BOOT_STATE, BOOTSTATE_BUFFER_FULL, 2);
 
 	if (saa7146_wait_for_debi_done(av7110->dev, 1)) {
 		printk(KERN_ERR "dvb-ttpci: av7110_bootarm(): "
diff -purN linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110_hw.h linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110_hw.h
--- linux-2.6.15-git12/drivers/media/dvb/ttpci/av7110_hw.h	2006-01-17 08:21:32.620792697 +0000
+++ linux-2.6.16-rc1/drivers/media/dvb/ttpci/av7110_hw.h	2006-01-17 08:22:46.786439369 +0000
@@ -18,7 +18,7 @@ enum av7110_bootstate
 {
 	BOOTSTATE_BUFFER_EMPTY	= 0,
 	BOOTSTATE_BUFFER_FULL	= 1,
-	BOOTSTATE_BOOT_COMPLETE	= 2
+	BOOTSTATE_AV7110_BOOT_COMPLETE	= 2
 };
 
 enum av7110_type_rec_play_format
@@ -295,11 +295,11 @@ enum av7110_command_type {
 #define	DPRAM_BASE 0x4000
 
 /* boot protocol area */
-#define BOOT_STATE	(DPRAM_BASE + 0x3F8)
-#define BOOT_SIZE	(DPRAM_BASE + 0x3FA)
-#define BOOT_BASE	(DPRAM_BASE + 0x3FC)
-#define BOOT_BLOCK	(DPRAM_BASE + 0x400)
-#define BOOT_MAX_SIZE	0xc00
+#define AV7110_BOOT_STATE	(DPRAM_BASE + 0x3F8)
+#define AV7110_BOOT_SIZE	(DPRAM_BASE + 0x3FA)
+#define AV7110_BOOT_BASE	(DPRAM_BASE + 0x3FC)
+#define AV7110_BOOT_BLOCK	(DPRAM_BASE + 0x400)
+#define AV7110_BOOT_MAX_SIZE	0xc00
 
 /* firmware command protocol area */
 #define IRQ_STATE	(DPRAM_BASE + 0x0F4)
diff -purN linux-2.6.15-git12/drivers/media/video/Makefile linux-2.6.16-rc1/drivers/media/video/Makefile
--- linux-2.6.15-git12/drivers/media/video/Makefile	2006-01-17 08:21:32.680783252 +0000
+++ linux-2.6.16-rc1/drivers/media/video/Makefile	2006-01-17 08:22:46.841430710 +0000
@@ -8,7 +8,8 @@ bttv-objs	:=	bttv-driver.o bttv-cards.o 
 zoran-objs      :=	zr36120.o zr36120_i2c.o zr36120_mem.o
 zr36067-objs	:=	zoran_procfs.o zoran_device.o \
 			zoran_driver.o zoran_card.o
-tuner-objs	:=	tuner-core.o tuner-simple.o mt20xx.o tda8290.o tea5767.o
+tuner-objs	:=	tuner-core.o tuner-types.o tuner-simple.o \
+			mt20xx.o tda8290.o tea5767.o
 
 msp3400-objs	:=	msp3400-driver.o msp3400-kthreads.o
 
diff -purN linux-2.6.15-git12/drivers/media/video/arv.c linux-2.6.16-rc1/drivers/media/video/arv.c
--- linux-2.6.15-git12/drivers/media/video/arv.c	2006-01-17 08:21:32.686782307 +0000
+++ linux-2.6.16-rc1/drivers/media/video/arv.c	2006-01-17 08:22:46.848429608 +0000
@@ -129,9 +129,9 @@ static unsigned char	yuv[MAX_AR_FRAME_BY
 static int freq = DEFAULT_FREQ;	/* BCLK: available 50 or 70 (MHz) */
 static int vga = 0;		/* default mode(0:QVGA mode, other:VGA mode) */
 static int vga_interlace = 0;	/* 0 is normal mode for, else interlace mode */
-MODULE_PARM(freq, "i");
-MODULE_PARM(vga, "i");
-MODULE_PARM(vga_interlace, "i");
+module_param(freq, int, 0);
+module_param(vga, int, 0);
+module_param(vga_interlace, int, 0);
 
 static int ar_initialize(struct video_device *dev);
 
diff -purN linux-2.6.15-git12/drivers/media/video/bt832.c linux-2.6.16-rc1/drivers/media/video/bt832.c
--- linux-2.6.15-git12/drivers/media/video/bt832.c	2006-01-17 08:21:32.691781520 +0000
+++ linux-2.6.16-rc1/drivers/media/video/bt832.c	2006-01-17 08:22:46.853428821 +0000
@@ -43,7 +43,7 @@ static unsigned short normal_i2c[] = { I
 				       I2C_CLIENT_END };
 I2C_CLIENT_INSMOD;
 
-int debug    = 0;    /* debug output */
+int debug;    /* debug output */
 module_param(debug,            int, 0644);
 
 /* ---------------------------------------------------------------------- */
diff -purN linux-2.6.15-git12/drivers/media/video/btcx-risc.c linux-2.6.16-rc1/drivers/media/video/btcx-risc.c
--- linux-2.6.15-git12/drivers/media/video/btcx-risc.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/video/btcx-risc.c	2006-01-17 08:22:46.856428349 +0000
@@ -37,7 +37,7 @@ MODULE_DESCRIPTION("some code shared by 
 MODULE_AUTHOR("Gerd Knorr");
 MODULE_LICENSE("GPL");
 
-static unsigned int debug = 0;
+static unsigned int debug;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug,"debug messages, default is 0 (no)");
 
diff -purN linux-2.6.15-git12/drivers/media/video/bttv-cards.c linux-2.6.16-rc1/drivers/media/video/bttv-cards.c
--- linux-2.6.15-git12/drivers/media/video/bttv-cards.c	2006-01-17 08:21:32.714777899 +0000
+++ linux-2.6.16-rc1/drivers/media/video/bttv-cards.c	2006-01-17 08:22:46.877425043 +0000
@@ -92,8 +92,8 @@ static void identify_by_eeprom(struct bt
 static int __devinit pvr_boot(struct bttv *btv);
 
 /* config variables */
-static unsigned int triton1=0;
-static unsigned int vsfx=0;
+static unsigned int triton1;
+static unsigned int vsfx;
 static unsigned int latency = UNSET;
 int no_overlay=-1;
 
@@ -106,7 +106,7 @@ static struct bttv  *master[BTTV_MAX] = 
 #ifdef MODULE
 static unsigned int autoload = 1;
 #else
-static unsigned int autoload = 0;
+static unsigned int autoload;
 #endif
 static unsigned int gpiomask = UNSET;
 static unsigned int audioall = UNSET;
diff -purN linux-2.6.15-git12/drivers/media/video/bttv-driver.c linux-2.6.16-rc1/drivers/media/video/bttv-driver.c
--- linux-2.6.15-git12/drivers/media/video/bttv-driver.c	2006-01-17 08:21:32.723776483 +0000
+++ linux-2.6.16-rc1/drivers/media/video/bttv-driver.c	2006-01-17 08:22:46.889423154 +0000
@@ -48,47 +48,46 @@
 unsigned int bttv_num;			/* number of Bt848s in use */
 struct bttv bttvs[BTTV_MAX];
 
-unsigned int bttv_debug = 0;
+unsigned int bttv_debug;
 unsigned int bttv_verbose = 1;
-unsigned int bttv_gpio = 0;
+unsigned int bttv_gpio;
 
 /* config variables */
 #ifdef __BIG_ENDIAN
 static unsigned int bigendian=1;
 #else
-static unsigned int bigendian=0;
+static unsigned int bigendian;
 #endif
 static unsigned int radio[BTTV_MAX];
-static unsigned int irq_debug = 0;
+static unsigned int irq_debug;
 static unsigned int gbuffers = 8;
 static unsigned int gbufsize = 0x208000;
 
 static int video_nr = -1;
 static int radio_nr = -1;
 static int vbi_nr = -1;
-static int debug_latency = 0;
+static int debug_latency;
 
-static unsigned int fdsr = 0;
+static unsigned int fdsr;
 
 /* options */
-static unsigned int combfilter  = 0;
-static unsigned int lumafilter  = 0;
+static unsigned int combfilter;
+static unsigned int lumafilter;
 static unsigned int automute    = 1;
-static unsigned int chroma_agc  = 0;
+static unsigned int chroma_agc;
 static unsigned int adc_crush   = 1;
 static unsigned int whitecrush_upper = 0xCF;
 static unsigned int whitecrush_lower = 0x7F;
-static unsigned int vcr_hack    = 0;
-static unsigned int irq_iswitch = 0;
+static unsigned int vcr_hack;
+static unsigned int irq_iswitch;
 static unsigned int uv_ratio    = 50;
-static unsigned int full_luma_range = 0;
-static unsigned int coring      = 0;
+static unsigned int full_luma_range;
+static unsigned int coring;
 extern int no_overlay;
 
 /* API features (turn on/off stuff for testing) */
 static unsigned int v4l2        = 1;
 
-
 /* insmod args */
 module_param(bttv_verbose,      int, 0644);
 module_param(bttv_gpio,         int, 0644);
@@ -685,16 +684,16 @@ int check_alloc_btres(struct bttv *btv, 
 		return 1;
 
 	/* is it free? */
-	down(&btv->reslock);
+	mutex_lock(&btv->reslock);
 	if (btv->resources & bit) {
 		/* no, someone else uses it */
-		up(&btv->reslock);
+		mutex_unlock(&btv->reslock);
 		return 0;
 	}
 	/* it's free, grab it */
 	fh->resources  |= bit;
 	btv->resources |= bit;
-	up(&btv->reslock);
+	mutex_unlock(&btv->reslock);
 	return 1;
 }
 
@@ -717,10 +716,10 @@ void free_btres(struct bttv *btv, struct
 		/* trying to free ressources not allocated by us ... */
 		printk("bttv: BUG! (btres)\n");
 	}
-	down(&btv->reslock);
+	mutex_lock(&btv->reslock);
 	fh->resources  &= ~bits;
 	btv->resources &= ~bits;
-	up(&btv->reslock);
+	mutex_unlock(&btv->reslock);
 }
 
 /* ----------------------------------------------------------------------- */
@@ -1537,12 +1536,12 @@ static int bttv_common_ioctls(struct btt
 	case VIDIOCSFREQ:
 	{
 		unsigned long *freq = arg;
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		btv->freq=*freq;
 		bttv_call_i2c_clients(btv,VIDIOCSFREQ,freq);
 		if (btv->has_matchbox && btv->radio_user)
 			tea5757_set_freq(btv,*freq);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1572,10 +1571,10 @@ static int bttv_common_ioctls(struct btt
 		if (v->mode >= BTTV_TVNORMS)
 			return -EINVAL;
 
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		set_tvnorm(btv,v->mode);
 		bttv_call_i2c_clients(btv,cmd,v);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1612,17 +1611,17 @@ static int bttv_common_ioctls(struct btt
 		if (v->norm >= BTTV_TVNORMS)
 			return -EINVAL;
 
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		if (channel == btv->input &&
 		    v->norm == btv->tvnorm) {
 			/* nothing to do */
-			up(&btv->lock);
+			mutex_unlock(&btv->lock);
 			return 0;
 		}
 
 		btv->tvnorm = v->norm;
 		set_input(btv,v->channel);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1635,14 +1634,14 @@ static int bttv_common_ioctls(struct btt
 		v->flags |= VIDEO_AUDIO_MUTABLE;
 		v->mode  = VIDEO_SOUND_MONO;
 
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		bttv_call_i2c_clients(btv,cmd,v);
 
 		/* card specific hooks */
 		if (btv->audio_hook)
 			btv->audio_hook(btv,v,0);
 
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 	case VIDIOCSAUDIO:
@@ -1653,7 +1652,7 @@ static int bttv_common_ioctls(struct btt
 		if (audio >= bttv_tvcards[btv->c.type].audio_inputs)
 			return -EINVAL;
 
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		audio_mux(btv, (v->flags&VIDEO_AUDIO_MUTE) ? AUDIO_MUTE : AUDIO_UNMUTE);
 		bttv_call_i2c_clients(btv,cmd,v);
 
@@ -1661,7 +1660,7 @@ static int bttv_common_ioctls(struct btt
 		if (btv->audio_hook)
 			btv->audio_hook(btv,v,1);
 
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1695,10 +1694,10 @@ static int bttv_common_ioctls(struct btt
 		if (i == BTTV_TVNORMS)
 			return -EINVAL;
 
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		set_tvnorm(btv,i);
 		i2c_vidiocschan(btv);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 	case VIDIOC_QUERYSTD:
@@ -1756,9 +1755,9 @@ static int bttv_common_ioctls(struct btt
 
 		if (*i > bttv_tvcards[btv->c.type].video_inputs)
 			return -EINVAL;
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		set_input(btv,*i);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1770,7 +1769,7 @@ static int bttv_common_ioctls(struct btt
 			return -EINVAL;
 		if (0 != t->index)
 			return -EINVAL;
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		memset(t,0,sizeof(*t));
 		strcpy(t->name, "Television");
 		t->type       = V4L2_TUNER_ANALOG_TV;
@@ -1805,7 +1804,7 @@ static int bttv_common_ioctls(struct btt
 			}
 		}
 		/* FIXME: fill capability+audmode */
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 	case VIDIOC_S_TUNER:
@@ -1816,7 +1815,7 @@ static int bttv_common_ioctls(struct btt
 			return -EINVAL;
 		if (0 != t->index)
 			return -EINVAL;
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		{
 			struct video_audio va;
 			memset(&va, 0, sizeof(struct video_audio));
@@ -1833,7 +1832,7 @@ static int bttv_common_ioctls(struct btt
 			if (btv->audio_hook)
 				btv->audio_hook(btv,&va,1);
 		}
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 
@@ -1854,12 +1853,12 @@ static int bttv_common_ioctls(struct btt
 			return -EINVAL;
 		if (unlikely (f->type != V4L2_TUNER_ANALOG_TV))
 			return -EINVAL;
-		down(&btv->lock);
+		mutex_lock(&btv->lock);
 		btv->freq = f->frequency;
 		bttv_call_i2c_clients(btv,VIDIOCSFREQ,&btv->freq);
 		if (btv->has_matchbox && btv->radio_user)
 			tea5757_set_freq(btv,btv->freq);
-		up(&btv->lock);
+		mutex_unlock(&btv->lock);
 		return 0;
 	}
 	case VIDIOC_LOG_STATUS:
@@ -3157,7 +3156,7 @@ static int radio_open(struct inode *inod
 		return -ENODEV;
 
 	dprintk("bttv%d: open called (radio)\n",btv->c.nr);
-	down(&btv->lock);
+	mutex_lock(&btv->lock);
 
 	btv->radio_user++;
 
@@ -3166,7 +3165,7 @@ static int radio_open(struct inode *inod
 	bttv_call_i2c_clients(btv,AUDC_SET_RADIO,&btv->tuner_type);
 	audio_mux(btv,AUDIO_RADIO);
 
-	up(&btv->lock);
+	mutex_unlock(&btv->lock);
 	return 0;
 }
 
@@ -3921,8 +3920,8 @@ static int __devinit bttv_probe(struct p
 	sprintf(btv->c.name,"bttv%d",btv->c.nr);
 
 	/* initialize structs / fill in defaults */
-	init_MUTEX(&btv->lock);
-	init_MUTEX(&btv->reslock);
+	mutex_init(&btv->lock);
+	mutex_init(&btv->reslock);
 	spin_lock_init(&btv->s_lock);
 	spin_lock_init(&btv->gpio_lock);
 	init_waitqueue_head(&btv->gpioq);
diff -purN linux-2.6.15-git12/drivers/media/video/bttv-i2c.c linux-2.6.16-rc1/drivers/media/video/bttv-i2c.c
--- linux-2.6.15-git12/drivers/media/video/bttv-i2c.c	2006-01-17 08:21:32.727775853 +0000
+++ linux-2.6.16-rc1/drivers/media/video/bttv-i2c.c	2006-01-17 08:22:46.893422524 +0000
@@ -41,9 +41,9 @@ static struct i2c_client bttv_i2c_client
 
 static int attach_inform(struct i2c_client *client);
 
-static int i2c_debug = 0;
-static int i2c_hw = 0;
-static int i2c_scan = 0;
+static int i2c_debug;
+static int i2c_hw;
+static int i2c_scan;
 module_param(i2c_debug, int, 0644);
 module_param(i2c_hw,    int, 0444);
 module_param(i2c_scan,  int, 0444);
diff -purN linux-2.6.15-git12/drivers/media/video/bttvp.h linux-2.6.16-rc1/drivers/media/video/bttvp.h
--- linux-2.6.15-git12/drivers/media/video/bttvp.h	2006-01-17 08:21:32.740773806 +0000
+++ linux-2.6.16-rc1/drivers/media/video/bttvp.h	2006-01-17 08:22:46.907420320 +0000
@@ -35,6 +35,7 @@
 #include <linux/videodev.h>
 #include <linux/pci.h>
 #include <linux/input.h>
+#include <linux/mutex.h>
 #include <asm/scatterlist.h>
 #include <asm/io.h>
 
@@ -309,9 +310,9 @@ struct bttv {
 
 	/* locking */
 	spinlock_t s_lock;
-	struct semaphore lock;
+	struct mutex lock;
 	int resources;
-	struct semaphore reslock;
+	struct mutex reslock;
 #ifdef VIDIOC_G_PRIORITY
 	struct v4l2_prio_state prio;
 #endif
diff -purN linux-2.6.15-git12/drivers/media/video/cx25840/cx25840-core.c linux-2.6.16-rc1/drivers/media/video/cx25840/cx25840-core.c
--- linux-2.6.15-git12/drivers/media/video/cx25840/cx25840-core.c	2006-01-17 08:21:32.782767195 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx25840/cx25840-core.c	2006-01-17 08:22:46.949413708 +0000
@@ -43,7 +43,7 @@ MODULE_LICENSE("GPL");
 static unsigned short normal_i2c[] = { 0x88 >> 1, I2C_CLIENT_END };
 
 
-int cx25840_debug = 0;
+static int cx25840_debug;
 
 module_param_named(debug,cx25840_debug, int, 0644);
 
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/Kconfig linux-2.6.16-rc1/drivers/media/video/cx88/Kconfig
--- linux-2.6.15-git12/drivers/media/video/cx88/Kconfig	2006-01-17 08:21:32.789766093 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/Kconfig	2006-01-17 08:22:46.956412606 +0000
@@ -31,8 +31,7 @@ config VIDEO_CX88_DVB
 
 config VIDEO_CX88_ALSA
 	tristate "ALSA DMA audio support"
-	depends on VIDEO_CX88 && SND
-	select SND_PCM_OSS
+	depends on VIDEO_CX88 && SND && EXPERIMENTAL
 	---help---
 	  This is a video4linux driver for direct (DMA) audio on
 	  Conexant 2388x based TV cards.
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/Makefile linux-2.6.16-rc1/drivers/media/video/cx88/Makefile
--- linux-2.6.15-git12/drivers/media/video/cx88/Makefile	2006-01-17 08:21:32.790765935 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/Makefile	2006-01-17 08:22:46.957412449 +0000
@@ -5,6 +5,7 @@ cx8802-objs	:= cx88-mpeg.o
 
 obj-$(CONFIG_VIDEO_CX88) += cx88xx.o cx8800.o cx8802.o cx88-blackbird.o
 obj-$(CONFIG_VIDEO_CX88_DVB) += cx88-dvb.o cx88-vp3054-i2c.o
+obj-$(CONFIG_VIDEO_CX88_ALSA) += cx88-alsa.o
 
 EXTRA_CFLAGS += -I$(src)/..
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/cx88-alsa.c linux-2.6.16-rc1/drivers/media/video/cx88/cx88-alsa.c
--- linux-2.6.15-git12/drivers/media/video/cx88/cx88-alsa.c	2006-01-17 08:21:32.799764518 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/cx88-alsa.c	2006-01-17 08:22:46.965411189 +0000
@@ -116,7 +116,7 @@ MODULE_LICENSE("GPL");
 MODULE_SUPPORTED_DEVICE("{{Conexant,23881},"
 			"{{Conexant,23882},"
 			"{{Conexant,23883}");
-static unsigned int debug = 0;
+static unsigned int debug;
 module_param(debug,int,0644);
 MODULE_PARM_DESC(debug,"enable debug messages");
 
@@ -333,10 +333,10 @@ static snd_pcm_hardware_t snd_cx88_digit
 	.channels_min = 1,
 	.channels_max = 2,
 	.buffer_bytes_max = (2*2048),
-	.period_bytes_min = 256,
+	.period_bytes_min = 2048,
 	.period_bytes_max = 2048,
 	.periods_min = 2,
-	.periods_max = 16,
+	.periods_max = 2,
 };
 
 /*
@@ -653,7 +653,7 @@ static void snd_cx88_dev_free(snd_card_t
  * Alsa Constructor - Component probe
  */
 
-static int devno=0;
+static int devno;
 static int __devinit snd_cx88_create(snd_card_t *card, struct pci_dev *pci,
 				    snd_cx88_card_t **rchip)
 {
@@ -805,7 +805,6 @@ static struct pci_driver cx88_audio_pci_
 	.id_table = cx88_audio_pci_tbl,
 	.probe    = cx88_audio_initdev,
 	.remove   = cx88_audio_finidev,
-	SND_PCI_PM_CALLBACKS
 };
 
 /****************************************************************************
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/cx88-core.c linux-2.6.16-rc1/drivers/media/video/cx88/cx88-core.c
--- linux-2.6.15-git12/drivers/media/video/cx88/cx88-core.c	2006-01-17 08:21:32.813762314 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/cx88-core.c	2006-01-17 08:22:46.980408828 +0000
@@ -32,6 +32,7 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/videodev2.h>
+#include <linux/mutex.h>
 
 #include "cx88.h"
 #include <media/v4l2-common.h>
@@ -75,7 +76,7 @@ MODULE_PARM_DESC(nocomb,"disable comb fi
 
 static unsigned int cx88_devcount;
 static LIST_HEAD(cx88_devlist);
-static DECLARE_MUTEX(devlist);
+static DEFINE_MUTEX(devlist);
 
 #define NO_SYNC_LINE (-1U)
 
@@ -1036,7 +1037,7 @@ struct cx88_core* cx88_core_get(struct p
 	struct list_head *item;
 	int i;
 
-	down(&devlist);
+	mutex_lock(&devlist);
 	list_for_each(item,&cx88_devlist) {
 		core = list_entry(item, struct cx88_core, devlist);
 		if (pci->bus->number != core->pci_bus)
@@ -1047,7 +1048,7 @@ struct cx88_core* cx88_core_get(struct p
 		if (0 != get_ressources(core,pci))
 			goto fail_unlock;
 		atomic_inc(&core->refcount);
-		up(&devlist);
+		mutex_unlock(&devlist);
 		return core;
 	}
 	core = kzalloc(sizeof(*core),GFP_KERNEL);
@@ -1122,13 +1123,13 @@ struct cx88_core* cx88_core_get(struct p
 	cx88_card_setup(core);
 	cx88_ir_init(core,pci);
 
-	up(&devlist);
+	mutex_unlock(&devlist);
 	return core;
 
 fail_free:
 	kfree(core);
 fail_unlock:
-	up(&devlist);
+	mutex_unlock(&devlist);
 	return NULL;
 }
 
@@ -1140,14 +1141,14 @@ void cx88_core_put(struct cx88_core *cor
 	if (!atomic_dec_and_test(&core->refcount))
 		return;
 
-	down(&devlist);
+	mutex_lock(&devlist);
 	cx88_ir_fini(core);
 	if (0 == core->i2c_rc)
 		i2c_bit_del_bus(&core->i2c_adap);
 	list_del(&core->devlist);
 	iounmap(core->lmmio);
 	cx88_devcount--;
-	up(&devlist);
+	mutex_unlock(&devlist);
 	kfree(core);
 }
 
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/cx88-tvaudio.c linux-2.6.16-rc1/drivers/media/video/cx88/cx88-tvaudio.c
--- linux-2.6.15-git12/drivers/media/video/cx88/cx88-tvaudio.c	2006-01-17 08:21:32.827760111 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/cx88-tvaudio.c	2006-01-17 08:22:46.994406624 +0000
@@ -60,6 +60,11 @@ static unsigned int audio_debug = 0;
 module_param(audio_debug, int, 0644);
 MODULE_PARM_DESC(audio_debug, "enable debug messages [audio]");
 
+static unsigned int always_analog = 0;
+module_param(always_analog,int,0644);
+MODULE_PARM_DESC(always_analog,"force analog audio out");
+
+
 #define dprintk(fmt, arg...)	if (audio_debug) \
 	printk(KERN_DEBUG "%s/0: " fmt, core->name , ## arg)
 
@@ -155,7 +160,8 @@ static void set_audio_finish(struct cx88
 		cx_write(AUD_I2SOUTPUTCNTL, 1);
 		cx_write(AUD_I2SCNTL, 0);
 		/* cx_write(AUD_APB_IN_RATE_ADJ, 0); */
-	} else {
+	}
+	if ((always_analog) || (!cx88_boards[core->board].blackbird)) {
 		ctl |= EN_DAC_ENABLE;
 		cx_write(AUD_CTL, ctl);
 	}
diff -purN linux-2.6.15-git12/drivers/media/video/cx88/cx88-vp3054-i2c.c linux-2.6.16-rc1/drivers/media/video/cx88/cx88-vp3054-i2c.c
--- linux-2.6.15-git12/drivers/media/video/cx88/cx88-vp3054-i2c.c	2006-01-17 08:21:32.836758694 +0000
+++ linux-2.6.16-rc1/drivers/media/video/cx88/cx88-vp3054-i2c.c	2006-01-17 08:22:47.003405207 +0000
@@ -32,6 +32,10 @@
 #include "cx88-vp3054-i2c.h"
 
 
+MODULE_DESCRIPTION("driver for cx2388x VP3054 design");
+MODULE_AUTHOR("Chris Pascoe <c.pascoe@itee.uq.edu.au>");
+MODULE_LICENSE("GPL");
+
 /* ----------------------------------------------------------------------- */
 
 static void vp3054_bit_setscl(void *data, int state)
diff -purN linux-2.6.15-git12/drivers/media/video/em28xx/em28xx-input.c linux-2.6.16-rc1/drivers/media/video/em28xx/em28xx-input.c
--- linux-2.6.15-git12/drivers/media/video/em28xx/em28xx-input.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/video/em28xx/em28xx-input.c	2006-01-17 08:22:47.016403160 +0000
@@ -76,6 +76,58 @@ static IR_KEYTAB_TYPE ir_codes_em_terrat
 	[ 0x40 ] = KEY_ZOOM,
 };
 
+static IR_KEYTAB_TYPE ir_codes_em_pinnacle_usb[IR_KEYTAB_SIZE] = {
+	[ 0x3a ] = KEY_KP0,
+	[ 0x31 ] = KEY_KP1,
+	[ 0x32 ] = KEY_KP2,
+	[ 0x33 ] = KEY_KP3,
+	[ 0x34 ] = KEY_KP4,
+	[ 0x35 ] = KEY_KP5,
+	[ 0x36 ] = KEY_KP6,
+	[ 0x37 ] = KEY_KP7,
+	[ 0x38 ] = KEY_KP8,
+	[ 0x39 ] = KEY_KP9,
+
+	[ 0x2f ] = KEY_POWER,
+
+	[ 0x2e ] = KEY_P,
+	[ 0x1f ] = KEY_L,
+	[ 0x2b ] = KEY_I,
+
+	[ 0x2d ] = KEY_ZOOM,
+	[ 0x1e ] = KEY_ZOOM,
+	[ 0x1b ] = KEY_VOLUMEUP,
+	[ 0x0f ] = KEY_VOLUMEDOWN,
+	[ 0x17 ] = KEY_CHANNELUP,
+	[ 0x1c ] = KEY_CHANNELDOWN,
+	[ 0x25 ] = KEY_INFO,
+
+	[ 0x3c ] = KEY_MUTE,
+
+	[ 0x3d ] = KEY_LEFT,
+	[ 0x3b ] = KEY_RIGHT,
+
+	[ 0x3f ] = KEY_UP,
+	[ 0x3e ] = KEY_DOWN,
+	[ 0x1a ] = KEY_PAUSE,
+
+	[ 0x1d ] = KEY_MENU,
+	[ 0x19 ] = KEY_PLAY,
+	[ 0x16 ] = KEY_REWIND,
+	[ 0x13 ] = KEY_FORWARD,
+	[ 0x15 ] = KEY_PAUSE,
+	[ 0x0e ] = KEY_REWIND,
+	[ 0x0d ] = KEY_PLAY,
+	[ 0x0b ] = KEY_STOP,
+	[ 0x07 ] = KEY_FORWARD,
+	[ 0x27 ] = KEY_RECORD,
+	[ 0x26 ] = KEY_TUNER,
+	[ 0x29 ] = KEY_TEXT,
+	[ 0x2a ] = KEY_MEDIA,
+	[ 0x18 ] = KEY_EPG,
+	[ 0x27 ] = KEY_RECORD,
+};
+
 /* ----------------------------------------------------------------------- */
 
 static int get_key_terratec(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
@@ -138,6 +190,28 @@ static int get_key_em_haup(struct IR_i2c
 	return 1;
 }
 
+static int get_key_pinnacle_usb(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
+{
+	unsigned char buf[3];
+
+	/* poll IR chip */
+
+	if (3 != i2c_master_recv(&ir->c,buf,3)) {
+		dprintk("read error\n");
+		return -EIO;
+	}
+
+	dprintk("key %02x\n", buf[2]&0x3f);
+	if (buf[0]!=0x00){
+		return 0;
+	}
+
+	*ir_key = buf[2]&0x3f;
+	*ir_raw = buf[2]&0x3f;
+
+	return 1;
+}
+
 /* ----------------------------------------------------------------------- */
 void em28xx_set_ir(struct em28xx * dev,struct IR_i2c *ir)
 {
@@ -159,6 +233,9 @@ void em28xx_set_ir(struct em28xx * dev,s
 		snprintf(ir->c.name, sizeof(ir->c.name), "i2c IR (EM28XX Terratec)");
 		break;
 	case (EM2820_BOARD_PINNACLE_USB_2):
+		ir->ir_codes = ir_codes_em_pinnacle_usb;
+		ir->get_key = get_key_pinnacle_usb;
+		snprintf(ir->c.name, sizeof(ir->c.name), "i2c IR (EM28XX Pinnacle PCTV)");
 		break;
 	case (EM2820_BOARD_HAUPPAUGE_WINTV_USB_2):
 		ir->ir_codes = ir_codes_hauppauge_new;
diff -purN linux-2.6.15-git12/drivers/media/video/em28xx/em28xx-video.c linux-2.6.16-rc1/drivers/media/video/em28xx/em28xx-video.c
--- linux-2.6.15-git12/drivers/media/video/em28xx/em28xx-video.c	2006-01-17 08:21:32.853756018 +0000
+++ linux-2.6.16-rc1/drivers/media/video/em28xx/em28xx-video.c	2006-01-17 08:22:47.022402216 +0000
@@ -29,6 +29,7 @@
 #include <linux/i2c.h>
 #include <linux/version.h>
 #include <linux/video_decoder.h>
+#include <linux/mutex.h>
 
 #include "em28xx.h"
 #include <media/tuner.h>
@@ -191,7 +192,7 @@ static struct v4l2_queryctrl saa711x_qct
 
 static struct usb_driver em28xx_usb_driver;
 
-static DECLARE_MUTEX(em28xx_sysfs_lock);
+static DEFINE_MUTEX(em28xx_sysfs_lock);
 static DECLARE_RWSEM(em28xx_disconnect);
 
 /*********************  v4l2 interface  ******************************************/
@@ -394,7 +395,7 @@ static int em28xx_v4l2_open(struct inode
 */
 static void em28xx_release_resources(struct em28xx *dev)
 {
-	down(&em28xx_sysfs_lock);
+	mutex_lock(&em28xx_sysfs_lock);
 
 	em28xx_info("V4L2 device /dev/video%d deregistered\n",
 		    dev->vdev->minor);
@@ -403,7 +404,7 @@ static void em28xx_release_resources(str
 /*	video_unregister_device(dev->vbi_dev); */
 	em28xx_i2c_unregister(dev);
 	usb_put_dev(dev->udev);
-	up(&em28xx_sysfs_lock);
+	mutex_unlock(&em28xx_sysfs_lock);
 }
 
 /*
diff -purN linux-2.6.15-git12/drivers/media/video/msp3400-driver.c linux-2.6.16-rc1/drivers/media/video/msp3400-driver.c
--- linux-2.6.15-git12/drivers/media/video/msp3400-driver.c	2006-01-17 08:21:32.889750350 +0000
+++ linux-2.6.16-rc1/drivers/media/video/msp3400-driver.c	2006-01-17 08:22:47.057396706 +0000
@@ -66,12 +66,12 @@ MODULE_LICENSE("GPL");
 
 /* module parameters */
 static int opmode   = OPMODE_AUTO;
-int msp_debug    = 0;    /* msp_debug output */
-int msp_once     = 0;    /* no continous stereo monitoring */
-int msp_amsound  = 0;    /* hard-wire AM sound at 6.5 Hz (france),
-			       the autoscan seems work well only with FM... */
+int msp_debug;		 /* msp_debug output */
+int msp_once;		 /* no continous stereo monitoring */
+int msp_amsound;	 /* hard-wire AM sound at 6.5 Hz (france),
+			    the autoscan seems work well only with FM... */
 int msp_standard = 1;    /* Override auto detect of audio msp_standard, if needed. */
-int msp_dolby    = 0;
+int msp_dolby;
 
 int msp_stereo_thresh = 0x190; /* a2 threshold for stereo/bilingual
 					(msp34xxg only) 0x00a0-0x03c0 */
@@ -1031,8 +1031,8 @@ static int msp_command(struct i2c_client
 	}
 
 	default:
-		/* nothing */
-		break;
+		/* unknown */
+		return -EINVAL;
 	}
 	return 0;
 }
diff -purN linux-2.6.15-git12/drivers/media/video/msp3400.h linux-2.6.16-rc1/drivers/media/video/msp3400.h
--- linux-2.6.15-git12/drivers/media/video/msp3400.h	2006-01-17 08:21:32.925744683 +0000
+++ linux-2.6.16-rc1/drivers/media/video/msp3400.h	2006-01-17 08:22:47.094390881 +0000
@@ -6,14 +6,6 @@
 
 /* ---------------------------------------------------------------------- */
 
-struct msp_matrix {
-  int input;
-  int output;
-};
-
-/* ioctl for MSP_SET_MATRIX will have to be registered */
-#define MSP_SET_MATRIX     _IOW('m',17,struct msp_matrix)
-
 /* This macro is allowed for *constants* only, gcc must calculate it
    at compile time.  Remember -- no floats in kernel mode */
 #define MSP_CARRIER(freq) ((int)((float)(freq / 18.432) * (1 << 24)))
diff -purN linux-2.6.15-git12/drivers/media/video/mt20xx.c linux-2.6.16-rc1/drivers/media/video/mt20xx.c
--- linux-2.6.15-git12/drivers/media/video/mt20xx.c	2006-01-17 08:21:32.927744368 +0000
+++ linux-2.6.16-rc1/drivers/media/video/mt20xx.c	2006-01-17 08:22:47.096390566 +0000
@@ -353,8 +353,8 @@ static int mt2032_init(struct i2c_client
 	} while (xok != 1 );
 	t->xogc=xogc;
 
-	t->tv_freq    = mt2032_set_tv_freq;
-	t->radio_freq = mt2032_set_radio_freq;
+	t->set_tv_freq    = mt2032_set_tv_freq;
+	t->set_radio_freq = mt2032_set_radio_freq;
 	return(1);
 }
 
@@ -481,8 +481,8 @@ static int mt2050_init(struct i2c_client
 	i2c_master_recv(c,buf,1);
 
 	tuner_dbg("mt2050: sro is %x\n",buf[0]);
-	t->tv_freq    = mt2050_set_tv_freq;
-	t->radio_freq = mt2050_set_radio_freq;
+	t->set_tv_freq    = mt2050_set_tv_freq;
+	t->set_radio_freq = mt2050_set_radio_freq;
 	return 0;
 }
 
@@ -494,8 +494,8 @@ int microtune_init(struct i2c_client *c)
 	int company_code;
 
 	memset(buf,0,sizeof(buf));
-	t->tv_freq    = NULL;
-	t->radio_freq = NULL;
+	t->set_tv_freq    = NULL;
+	t->set_radio_freq = NULL;
 	t->standby    = NULL;
 	if (t->std & V4L2_STD_525_60) {
 		tuner_dbg("pinnacle ntsc\n");
diff -purN linux-2.6.15-git12/drivers/media/video/planb.c linux-2.6.16-rc1/drivers/media/video/planb.c
--- linux-2.6.15-git12/drivers/media/video/planb.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/video/planb.c	2006-01-17 08:22:47.111388205 +0000
@@ -76,9 +76,9 @@ static volatile struct planb_registers *
 static int def_norm = PLANB_DEF_NORM;	/* default norm */
 static int video_nr = -1;
 
-MODULE_PARM(def_norm, "i");
+module_param(def_norm, int, 0);
 MODULE_PARM_DESC(def_norm, "Default startup norm (0=PAL, 1=NTSC, 2=SECAM)");
-MODULE_PARM(video_nr,"i");
+module_param(video_nr, int, 0);
 MODULE_LICENSE("GPL");
 
 
diff -purN linux-2.6.15-git12/drivers/media/video/saa6588.c linux-2.6.16-rc1/drivers/media/video/saa6588.c
--- linux-2.6.15-git12/drivers/media/video/saa6588.c	2006-01-17 08:21:32.946741377 +0000
+++ linux-2.6.16-rc1/drivers/media/video/saa6588.c	2006-01-17 08:22:47.120386788 +0000
@@ -50,15 +50,15 @@ static unsigned int rbds = 0;
 static unsigned int plvl = 0;
 static unsigned int bufblocks = 100;
 
-MODULE_PARM(debug, "i");
+module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "enable debug messages");
-MODULE_PARM(xtal, "i");
+module_param(xtal, int, 0);
 MODULE_PARM_DESC(xtal, "select oscillator frequency (0..3), default 0");
-MODULE_PARM(rbds, "i");
+module_param(rbds, int, 0);
 MODULE_PARM_DESC(rbds, "select mode, 0=RDS, 1=RBDS, default 0");
-MODULE_PARM(plvl, "i");
+module_param(plvl, int, 0);
 MODULE_PARM_DESC(plvl, "select pause level (0..3), default 0");
-MODULE_PARM(bufblocks, "i");
+module_param(bufblocks, int, 0);
 MODULE_PARM_DESC(bufblocks, "number of buffered blocks, default 100");
 
 MODULE_DESCRIPTION("v4l2 driver module for SAA6588 RDS decoder");
diff -purN linux-2.6.15-git12/drivers/media/video/saa711x.c linux-2.6.16-rc1/drivers/media/video/saa711x.c
--- linux-2.6.15-git12/drivers/media/video/saa711x.c	2006-01-17 08:21:32.965738386 +0000
+++ linux-2.6.16-rc1/drivers/media/video/saa711x.c	2006-01-17 08:22:47.138383954 +0000
@@ -52,7 +52,7 @@ MODULE_LICENSE("GPL");
 #include <linux/video_decoder.h>
 
 static int debug = 0;
-MODULE_PARM(debug, "i");
+module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, " Set the default Debug level.  Default: 0 (Off) - (0-1)");
 
 
diff -purN linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-cards.c linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-cards.c
--- linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-cards.c	2006-01-17 08:21:32.983735552 +0000
+++ linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-cards.c	2006-01-17 08:22:47.157380963 +0000
@@ -2515,6 +2515,7 @@ struct saa7134_board saa7134_boards[] = 
 		.tuner_addr	= ADDR_UNSET,
 		.radio_addr	= ADDR_UNSET,
 		.mpeg           = SAA7134_MPEG_DVB,
+		.gpiomask       = 1 << 21,
 		.inputs = {{
 			.name   = name_tv,
 			.vmux   = 1,
@@ -2529,6 +2530,11 @@ struct saa7134_board saa7134_boards[] = 
 			.vmux   = 8,
 			.amux   = LINE1,
 		}},
+		.radio = {
+			.name   = name_radio,
+			.amux   = TV,
+			.gpio   = 0x0200000,
+		},
 	},
 	[SAA7134_BOARD_MSI_TVATANYWHERE_PLUS] = {
 		.name           = "MSI TV@Anywhere plus",
diff -purN linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-core.c linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-core.c
--- linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-core.c	2006-01-17 08:21:32.988734765 +0000
+++ linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-core.c	2006-01-17 08:22:47.162380176 +0000
@@ -31,6 +31,7 @@
 #include <linux/sound.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/mutex.h>
 
 #include "saa7134-reg.h"
 #include "saa7134.h"
@@ -84,7 +85,7 @@ MODULE_PARM_DESC(radio_nr, "radio device
 MODULE_PARM_DESC(tuner,    "tuner type");
 MODULE_PARM_DESC(card,     "card type");
 
-static DECLARE_MUTEX(devlist_lock);
+static DEFINE_MUTEX(devlist_lock);
 LIST_HEAD(saa7134_devlist);
 static LIST_HEAD(mops_list);
 static unsigned int saa7134_devcount;
@@ -140,7 +141,7 @@ static int pending_call(struct notifier_
 	return NOTIFY_DONE;
 }
 
-static int pending_registered=0;
+static int pending_registered;
 static struct notifier_block pending_notifier = {
 	.notifier_call = pending_call,
 };
@@ -969,13 +970,13 @@ static int __devinit saa7134_initdev(str
 	pci_set_drvdata(pci_dev,dev);
 	saa7134_devcount++;
 
-	down(&devlist_lock);
+	mutex_lock(&devlist_lock);
 	list_for_each(item,&mops_list) {
 		mops = list_entry(item, struct saa7134_mpeg_ops, next);
 		mpeg_ops_attach(mops, dev);
 	}
 	list_add_tail(&dev->devlist,&saa7134_devlist);
-	up(&devlist_lock);
+	mutex_unlock(&devlist_lock);
 
 	/* check for signal */
 	saa7134_irq_video_intl(dev);
@@ -1031,13 +1032,13 @@ static void __devexit saa7134_finidev(st
 	saa7134_hwfini(dev);
 
 	/* unregister */
-	down(&devlist_lock);
+	mutex_lock(&devlist_lock);
 	list_del(&dev->devlist);
 	list_for_each(item,&mops_list) {
 		mops = list_entry(item, struct saa7134_mpeg_ops, next);
 		mpeg_ops_detach(mops, dev);
 	}
-	up(&devlist_lock);
+	mutex_unlock(&devlist_lock);
 	saa7134_devcount--;
 
 	saa7134_i2c_unregister(dev);
@@ -1071,13 +1072,13 @@ int saa7134_ts_register(struct saa7134_m
 	struct list_head *item;
 	struct saa7134_dev *dev;
 
-	down(&devlist_lock);
+	mutex_lock(&devlist_lock);
 	list_for_each(item,&saa7134_devlist) {
 		dev = list_entry(item, struct saa7134_dev, devlist);
 		mpeg_ops_attach(ops, dev);
 	}
 	list_add_tail(&ops->next,&mops_list);
-	up(&devlist_lock);
+	mutex_unlock(&devlist_lock);
 	return 0;
 }
 
@@ -1086,13 +1087,13 @@ void saa7134_ts_unregister(struct saa713
 	struct list_head *item;
 	struct saa7134_dev *dev;
 
-	down(&devlist_lock);
+	mutex_lock(&devlist_lock);
 	list_del(&ops->next);
 	list_for_each(item,&saa7134_devlist) {
 		dev = list_entry(item, struct saa7134_dev, devlist);
 		mpeg_ops_detach(ops, dev);
 	}
-	up(&devlist_lock);
+	mutex_unlock(&devlist_lock);
 }
 
 EXPORT_SYMBOL(saa7134_ts_register);
diff -purN linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-tvaudio.c linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-tvaudio.c
--- linux-2.6.15-git12/drivers/media/video/saa7134/saa7134-tvaudio.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/video/saa7134/saa7134-tvaudio.c	2006-01-17 08:22:47.176377972 +0000
@@ -180,8 +180,8 @@ static void tvaudio_init(struct saa7134_
 	saa_writeb(SAA7134_AUDIO_CLOCK0,      clock        & 0xff);
 	saa_writeb(SAA7134_AUDIO_CLOCK1,     (clock >>  8) & 0xff);
 	saa_writeb(SAA7134_AUDIO_CLOCK2,     (clock >> 16) & 0xff);
-	// frame locked audio was reported not to be reliable
-	saa_writeb(SAA7134_AUDIO_PLL_CTRL,   0x02);
+	/* frame locked audio is mandatory for NICAM */
+	saa_writeb(SAA7134_AUDIO_PLL_CTRL,   0x01);
 
 	saa_writeb(SAA7134_NICAM_ERROR_LOW,  0x14);
 	saa_writeb(SAA7134_NICAM_ERROR_HIGH, 0x50);
@@ -809,7 +809,12 @@ static int tvaudio_thread_ddep(void *dat
 			dprintk("ddep override: %s\n",stdres[audio_ddep]);
 		} else if (&card(dev).radio == dev->input) {
 			dprintk("FM Radio\n");
-			norms = (0x0f << 2) | 0x01;
+			if (dev->tuner_type == TUNER_PHILIPS_TDA8290) {
+				norms = (0x11 << 2) | 0x01;
+				saa_dsp_writel(dev, 0x42c >> 2, 0x729555);
+			} else {
+				norms = (0x0f << 2) | 0x01;
+			}
 		} else {
 			/* (let chip) scan for sound carrier */
 			norms = 0;
diff -purN linux-2.6.15-git12/drivers/media/video/tda8290.c linux-2.6.16-rc1/drivers/media/video/tda8290.c
--- linux-2.6.15-git12/drivers/media/video/tda8290.c	2006-01-17 08:21:33.042726264 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tda8290.c	2006-01-17 08:22:47.219371203 +0000
@@ -567,8 +567,8 @@ int tda8290_init(struct i2c_client *c)
 	}
 	tuner_info("tuner: type set to %s\n", c->name);
 
-	t->tv_freq    = set_tv_freq;
-	t->radio_freq = set_radio_freq;
+	t->set_tv_freq    = set_tv_freq;
+	t->set_radio_freq = set_radio_freq;
 	t->has_signal = has_signal;
 	t->standby = standby;
 	t->tda827x_lpsel = 0;
diff -purN linux-2.6.15-git12/drivers/media/video/tea5767.c linux-2.6.16-rc1/drivers/media/video/tea5767.c
--- linux-2.6.15-git12/drivers/media/video/tea5767.c	2006-01-17 08:21:33.053724533 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tea5767.c	2006-01-17 08:22:47.231369314 +0000
@@ -62,7 +62,7 @@ extern int tuner_debug;
 
 #define TEA5767_PORT1_HIGH	0x01
 
-/* Forth register */
+/* Fourth register */
 #define TEA5767_PORT2_HIGH	0x80
 /* Chips stops working. Only I2C bus remains on */
 #define TEA5767_STDBY		0x40
@@ -85,7 +85,7 @@ extern int tuner_debug;
 /* If activate PORT 1 indicates SEARCH or else it is used as PORT1 */
 #define TEA5767_SRCH_IND	0x01
 
-/* Fiveth register */
+/* Fifth register */
 
 /* By activating, it will use Xtal at 13 MHz as reference for divider */
 #define TEA5767_PLLREF_ENABLE	0x80
@@ -109,13 +109,13 @@ extern int tuner_debug;
 #define TEA5767_STEREO_MASK	0x80
 #define TEA5767_IF_CNTR_MASK	0x7f
 
-/* Four register */
+/* Fourth register */
 #define TEA5767_ADC_LEVEL_MASK	0xf0
 
 /* should be 0 */
 #define TEA5767_CHIP_ID_MASK	0x0f
 
-/* Fiveth register */
+/* Fifth register */
 /* Reserved for future extensions */
 #define TEA5767_RESERVED_MASK	0xff
 
@@ -220,19 +220,19 @@ static void set_radio_freq(struct i2c_cl
 		tuner_dbg ("TEA5767 radio HIGH LO inject xtal @ 13 MHz\n");
 		buffer[2] |= TEA5767_HIGH_LO_INJECT;
 		buffer[4] |= TEA5767_PLLREF_ENABLE;
-		div = (frq * 4000 / 16 + 700000 + 225000 + 25000) / 50000;
+		div = (frq * (4000 / 16) + 700000 + 225000 + 25000) / 50000;
 		break;
 	case TEA5767_LOW_LO_13MHz:
 		tuner_dbg ("TEA5767 radio LOW LO inject xtal @ 13 MHz\n");
 
 		buffer[4] |= TEA5767_PLLREF_ENABLE;
-		div = (frq * 4000 / 16 - 700000 - 225000 + 25000) / 50000;
+		div = (frq * (4000 / 16) - 700000 - 225000 + 25000) / 50000;
 		break;
 	case TEA5767_LOW_LO_32768:
 		tuner_dbg ("TEA5767 radio LOW LO inject xtal @ 32,768 MHz\n");
 		buffer[3] |= TEA5767_XTAL_32768;
 		/* const 700=4000*175 Khz - to adjust freq to right value */
-		div = ((frq * 4000 / 16 - 700000 - 225000) + 16384) >> 15;
+		div = ((frq * (4000 / 16) - 700000 - 225000) + 16384) >> 15;
 		break;
 	case TEA5767_HIGH_LO_32768:
 	default:
@@ -350,8 +350,8 @@ int tea5767_tuner_init(struct i2c_client
 	tuner_info("type set to %d (%s)\n", t->type, "Philips TEA5767HN FM Radio");
 	strlcpy(c->name, "tea5767", sizeof(c->name));
 
-	t->tv_freq = set_tv_freq;
-	t->radio_freq = set_radio_freq;
+	t->set_tv_freq = set_tv_freq;
+	t->set_radio_freq = set_radio_freq;
 	t->has_signal = tea5767_signal;
 	t->is_stereo = tea5767_stereo;
 	t->standby = tea5767_standby;
diff -purN linux-2.6.15-git12/drivers/media/video/tuner-core.c linux-2.6.16-rc1/drivers/media/video/tuner-core.c
--- linux-2.6.15-git12/drivers/media/video/tuner-core.c	2006-01-17 08:21:33.062723116 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tuner-core.c	2006-01-17 08:22:47.242367582 +0000
@@ -82,7 +82,7 @@ static void set_tv_freq(struct i2c_clien
 		tuner_warn ("tuner type not set\n");
 		return;
 	}
-	if (NULL == t->tv_freq) {
+	if (NULL == t->set_tv_freq) {
 		tuner_warn ("Tuner has no way to set tv freq\n");
 		return;
 	}
@@ -90,8 +90,14 @@ static void set_tv_freq(struct i2c_clien
 		tuner_dbg ("TV freq (%d.%02d) out of range (%d-%d)\n",
 			   freq / 16, freq % 16 * 100 / 16, tv_range[0],
 			   tv_range[1]);
+		/* V4L2 spec: if the freq is not possible then the closest
+		   possible value should be selected */
+		if (freq < tv_range[0] * 16)
+			freq = tv_range[0] * 16;
+		else
+			freq = tv_range[1] * 16;
 	}
-	t->tv_freq(c, freq);
+	t->set_tv_freq(c, freq);
 }
 
 static void set_radio_freq(struct i2c_client *c, unsigned int freq)
@@ -102,18 +108,23 @@ static void set_radio_freq(struct i2c_cl
 		tuner_warn ("tuner type not set\n");
 		return;
 	}
-	if (NULL == t->radio_freq) {
+	if (NULL == t->set_radio_freq) {
 		tuner_warn ("tuner has no way to set radio frequency\n");
 		return;
 	}
-	if (freq <= radio_range[0] * 16000 || freq >= radio_range[1] * 16000) {
+	if (freq < radio_range[0] * 16000 || freq > radio_range[1] * 16000) {
 		tuner_dbg ("radio freq (%d.%02d) out of range (%d-%d)\n",
 			   freq / 16000, freq % 16000 * 100 / 16000,
 			   radio_range[0], radio_range[1]);
+		/* V4L2 spec: if the freq is not possible then the closest
+		   possible value should be selected */
+		if (freq < radio_range[0] * 16000)
+			freq = radio_range[0] * 16000;
+		else
+			freq = radio_range[1] * 16000;
 	}
 
-	t->radio_freq(c, freq);
-	return;
+	t->set_radio_freq(c, freq);
 }
 
 static void set_freq(struct i2c_client *c, unsigned long freq)
@@ -125,15 +136,16 @@ static void set_freq(struct i2c_client *
 		tuner_dbg("radio freq set to %lu.%02lu\n",
 			  freq / 16000, freq % 16000 * 100 / 16000);
 		set_radio_freq(c, freq);
+		t->radio_freq = freq;
 		break;
 	case V4L2_TUNER_ANALOG_TV:
 	case V4L2_TUNER_DIGITAL_TV:
 		tuner_dbg("tv freq set to %lu.%02lu\n",
 			  freq / 16, freq % 16 * 100 / 16);
 		set_tv_freq(c, freq);
+		t->tv_freq = freq;
 		break;
 	}
-	t->freq = freq;
 }
 
 static void set_type(struct i2c_client *c, unsigned int type,
@@ -212,7 +224,7 @@ static void set_type(struct i2c_client *
 	if (t->mode_mask == T_UNINITIALIZED)
 		t->mode_mask = new_mode_mask;
 
-	set_freq(c, t->freq);
+	set_freq(c, (V4L2_TUNER_RADIO == t->mode) ? t->radio_freq : t->tv_freq);
 	tuner_dbg("%s %s I2C addr 0x%02x with type %d used for 0x%02x\n",
 		  c->adapter->name, c->driver->driver.name, c->addr << 1, type,
 		  t->mode_mask);
@@ -377,11 +389,11 @@ static void tuner_status(struct i2c_clie
 		default: p = "undefined"; break;
 	}
 	if (t->mode == V4L2_TUNER_RADIO) {
-		freq = t->freq / 16000;
-		freq_fraction = (t->freq % 16000) * 100 / 16000;
+		freq = t->radio_freq / 16000;
+		freq_fraction = (t->radio_freq % 16000) * 100 / 16000;
 	} else {
-		freq = t->freq / 16;
-		freq_fraction = (t->freq % 16) * 100 / 16;
+		freq = t->tv_freq / 16;
+		freq_fraction = (t->tv_freq % 16) * 100 / 16;
 	}
 	tuner_info("Tuner mode:      %s\n", p);
 	tuner_info("Frequency:       %lu.%02lu MHz\n", freq, freq_fraction);
@@ -456,7 +468,7 @@ static int tuner_attach(struct i2c_adapt
 				t->type = TUNER_TEA5767;
 				t->mode_mask = T_RADIO;
 				t->mode = T_STANDBY;
-				t->freq = 87.5 * 16; /* Sets freq to FM range */
+				t->radio_freq = 87.5 * 16000; /* Sets freq to FM range */
 				default_mode_mask &= ~T_RADIO;
 
 				goto register_client;
@@ -469,7 +481,8 @@ static int tuner_attach(struct i2c_adapt
 	if (default_mode_mask != T_UNINITIALIZED) {
 		tuner_dbg ("Setting mode_mask to 0x%02x\n", default_mode_mask);
 		t->mode_mask = default_mode_mask;
-		t->freq = 400 * 16; /* Sets freq to VHF High */
+		t->tv_freq = 400 * 16; /* Sets freq to VHF High */
+		t->radio_freq = 87.5 * 16000; /* Sets freq to FM range */
 		default_mode_mask = T_UNINITIALIZED;
 	}
 
@@ -565,16 +578,18 @@ static int tuner_command(struct i2c_clie
 		set_addr(client, (struct tuner_setup *)arg);
 		break;
 	case AUDC_SET_RADIO:
-		set_mode(client,t,V4L2_TUNER_RADIO, "AUDC_SET_RADIO");
+		if (set_mode(client, t, V4L2_TUNER_RADIO, "AUDC_SET_RADIO")
+				== EINVAL)
+			return 0;
+		if (t->radio_freq)
+			set_freq(client, t->radio_freq);
 		break;
 	case TUNER_SET_STANDBY:
-		{
-			if (check_mode(t, "TUNER_SET_STANDBY") == EINVAL)
-				return 0;
-			if (t->standby)
-				t->standby (client);
-			break;
-		}
+		if (check_mode(t, "TUNER_SET_STANDBY") == EINVAL)
+			return 0;
+		if (t->standby)
+			t->standby (client);
+		break;
 	case VIDIOCSAUDIO:
 		if (check_mode(t, "VIDIOCSAUDIO") == EINVAL)
 			return 0;
@@ -583,7 +598,6 @@ static int tuner_command(struct i2c_clie
 
 		/* Should be implemented, since bttv calls it */
 		tuner_dbg("VIDIOCSAUDIO not implemented.\n");
-
 		break;
 	/* --- v4l ioctls --- */
 	/* take care: bttv does userspace copying, we'll get a
@@ -609,8 +623,8 @@ static int tuner_command(struct i2c_clie
 			if (vc->norm < ARRAY_SIZE(map))
 				t->std = map[vc->norm];
 			tuner_fixup_std(t);
-			if (t->freq)
-				set_tv_freq(client, t->freq);
+			if (t->tv_freq)
+				set_tv_freq(client, t->tv_freq);
 			return 0;
 		}
 	case VIDIOCSFREQ:
@@ -684,15 +698,14 @@ static int tuner_command(struct i2c_clie
 
 			t->std = *id;
 			tuner_fixup_std(t);
-			if (t->freq)
-				set_freq(client, t->freq);
+			if (t->tv_freq)
+				set_freq(client, t->tv_freq);
 			break;
 		}
 	case VIDIOC_S_FREQUENCY:
 		{
 			struct v4l2_frequency *f = arg;
 
-			t->freq = f->frequency;
 			switch_v4l2();
 			if (V4L2_TUNER_RADIO == f->type &&
 			    V4L2_TUNER_RADIO != t->mode) {
@@ -700,7 +713,7 @@ static int tuner_command(struct i2c_clie
 					    == EINVAL)
 					return 0;
 			}
-			set_freq(client,t->freq);
+			set_freq(client,f->frequency);
 
 			break;
 		}
@@ -712,7 +725,8 @@ static int tuner_command(struct i2c_clie
 				return 0;
 			switch_v4l2();
 			f->type = t->mode;
-			f->frequency = t->freq;
+			f->frequency = (V4L2_TUNER_RADIO == t->mode) ?
+				t->radio_freq : t->tv_freq;
 			break;
 		}
 	case VIDIOC_G_TUNER:
@@ -763,7 +777,7 @@ static int tuner_command(struct i2c_clie
 
 			if (V4L2_TUNER_RADIO == t->mode) {
 				t->audmode = tuner->audmode;
-				set_radio_freq(client, t->freq);
+				set_radio_freq(client, t->radio_freq);
 			}
 			break;
 		}
@@ -791,8 +805,13 @@ static int tuner_resume(struct device *d
 	struct tuner *t = i2c_get_clientdata (c);
 
 	tuner_dbg ("resume\n");
-	if (t->freq)
-		set_freq(c, t->freq);
+	if (V4L2_TUNER_RADIO == t->mode) {
+		if (t->radio_freq)
+			set_freq(c, t->radio_freq);
+	} else {
+		if (t->tv_freq)
+			set_freq(c, t->tv_freq);
+	}
 	return 0;
 }
 
diff -purN linux-2.6.15-git12/drivers/media/video/tuner-simple.c linux-2.6.16-rc1/drivers/media/video/tuner-simple.c
--- linux-2.6.15-git12/drivers/media/video/tuner-simple.c	2006-01-17 08:21:33.073721384 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tuner-simple.c	2006-01-17 08:22:47.248366637 +0000
@@ -79,722 +79,16 @@ MODULE_PARM_DESC(offset,"Allows to speci
 #define TUNER_PLL_LOCKED   0x40
 #define TUNER_STEREO_MK3   0x04
 
-#define TUNER_MAX_RANGES   3
-
-/* ---------------------------------------------------------------------- */
-
-struct tunertype
-{
-	char *name;
-
-	int count;
-	struct {
-		unsigned short thresh;
-		unsigned char cb;
-	} ranges[TUNER_MAX_RANGES];
-	unsigned char config;
-};
-
-/*
- *	The floats in the tuner struct are computed at compile time
- *	by gcc and cast back to integers. Thus we don't violate the
- *	"no float in kernel" rule.
+#define TUNER_PARAM_ANALOG 0  /* to be removed */
+/* FIXME:
+ * Right now, all tuners are using the first tuner_params[] array element
+ * for analog mode. In the future, we will be merging similar tuner
+ * definitions together, such that each tuner definition will have a
+ * tuner_params struct for each available video standard. At that point,
+ * TUNER_PARAM_ANALOG will be removed, and the tuner_params[] array
+ * element will be chosen based on the video standard in use.
+ *
  */
-static struct tunertype tuners[] = {
-	/* 0-9 */
-	[TUNER_TEMIC_PAL] = { /* TEMIC PAL */
-		.name   = "Temic PAL (4002 FH5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 140.25 /*MHz*/, 0x02, },
-			{ 16 * 463.25 /*MHz*/, 0x04, },
-			{ 16 * 999.99        , 0x01, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_PAL_I] = { /* Philips PAL_I */
-		.name   = "Philips PAL_I (FI1246 and compatibles)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 140.25 /*MHz*/, 0xa0, },
-			{ 16 * 463.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_NTSC] = { /* Philips NTSC */
-		.name   = "Philips NTSC (FI1236,FM1236 and compatibles)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0xa0, },
-			{ 16 * 451.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_SECAM] = { /* Philips SECAM */
-		.name   = "Philips (SECAM+PAL_BG) (FI1216MF, FM1216MF, FR1216MF)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 168.25 /*MHz*/, 0xa7, },
-			{ 16 * 447.25 /*MHz*/, 0x97, },
-			{ 16 * 999.99        , 0x37, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ABSENT] = { /* Tuner Absent */
-		.name   = "NoTuner",
-		.count  = 1,
-		.ranges = {
-			{ 0, 0x00, },
-		},
-		.config = 0x00,
-	},
-	[TUNER_PHILIPS_PAL] = { /* Philips PAL */
-		.name   = "Philips PAL_BG (FI1216 and compatibles)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 168.25 /*MHz*/, 0xa0, },
-			{ 16 * 447.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_NTSC] = { /* TEMIC NTSC */
-		.name   = "Temic NTSC (4032 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0x02, },
-			{ 16 * 463.25 /*MHz*/, 0x04, },
-			{ 16 * 999.99        , 0x01, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_PAL_I] = { /* TEMIC PAL_I */
-		.name   = "Temic PAL_I (4062 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0x02, },
-			{ 16 * 450.00 /*MHz*/, 0x04, },
-			{ 16 * 999.99        , 0x01, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4036FY5_NTSC] = { /* TEMIC NTSC */
-		.name   = "Temic NTSC (4036 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0xa0, },
-			{ 16 * 463.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ALPS_TSBH1_NTSC] = { /* TEMIC NTSC */
-		.name   = "Alps HSBH1",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 137.25 /*MHz*/, 0x01, },
-			{ 16 * 385.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 10-19 */
-	[TUNER_ALPS_TSBE1_PAL] = { /* TEMIC PAL */
-		.name   = "Alps TSBE1",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 137.25 /*MHz*/, 0x01, },
-			{ 16 * 385.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ALPS_TSBB5_PAL_I] = { /* Alps PAL_I */
-		.name   = "Alps TSBB5",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 133.25 /*MHz*/, 0x01, },
-			{ 16 * 351.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ALPS_TSBE5_PAL] = { /* Alps PAL */
-		.name   = "Alps TSBE5",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 133.25 /*MHz*/, 0x01, },
-			{ 16 * 351.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ALPS_TSBC5_PAL] = { /* Alps PAL */
-		.name   = "Alps TSBC5",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 133.25 /*MHz*/, 0x01, },
-			{ 16 * 351.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4006FH5_PAL] = { /* TEMIC PAL */
-		.name   = "Temic PAL_BG (4006FH5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_ALPS_TSHC6_NTSC] = { /* Alps NTSC */
-		.name   = "Alps TSCH6",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 137.25 /*MHz*/, 0x14, },
-			{ 16 * 385.25 /*MHz*/, 0x12, },
-			{ 16 * 999.99        , 0x11, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_PAL_DK] = { /* TEMIC PAL */
-		.name   = "Temic PAL_DK (4016 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 168.25 /*MHz*/, 0xa0, },
-			{ 16 * 456.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_NTSC_M] = { /* Philips NTSC */
-		.name   = "Philips NTSC_M (MK2)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4066FY5_PAL_I] = { /* TEMIC PAL_I */
-		.name   = "Temic PAL_I (4066 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 169.00 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4006FN5_MULTI_PAL] = { /* TEMIC PAL */
-		.name   = "Temic PAL* auto (4006 FN5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 169.00 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 20-29 */
-	[TUNER_TEMIC_4009FR5_PAL] = { /* TEMIC PAL */
-		.name   = "Temic PAL_BG (4009 FR5) or PAL_I (4069 FR5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 141.00 /*MHz*/, 0xa0, },
-			{ 16 * 464.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4039FR5_NTSC] = { /* TEMIC NTSC */
-		.name   = "Temic NTSC (4039 FR5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 158.00 /*MHz*/, 0xa0, },
-			{ 16 * 453.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4046FM5] = { /* TEMIC PAL */
-		.name   = "Temic PAL/SECAM multi (4046 FM5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 169.00 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_PAL_DK] = { /* Philips PAL */
-		.name   = "Philips PAL_DK (FI1256 and compatibles)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_FQ1216ME] = { /* Philips PAL */
-		.name   = "Philips PAL/SECAM multi (FQ1216ME)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_PAL_I_FM] = { /* LGINNOTEK PAL_I */
-		.name   = "LG PAL_I+FM (TAPC-I001D)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_PAL_I] = { /* LGINNOTEK PAL_I */
-		.name   = "LG PAL_I (TAPC-I701D)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_NTSC_FM] = { /* LGINNOTEK NTSC */
-		.name   = "LG NTSC+FM (TPI8NSR01F)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 210.00 /*MHz*/, 0xa0, },
-			{ 16 * 497.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_PAL_FM] = { /* LGINNOTEK PAL */
-		.name   = "LG PAL_BG+FM (TPI8PSB01D)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_PAL] = { /* LGINNOTEK PAL */
-		.name   = "LG PAL_BG (TPI8PSB11D)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0xa0, },
-			{ 16 * 450.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 30-39 */
-	[TUNER_TEMIC_4009FN5_MULTI_PAL_FM] = { /* TEMIC PAL */
-		.name   = "Temic PAL* auto + FM (4009 FN5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 141.00 /*MHz*/, 0xa0, },
-			{ 16 * 464.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_SHARP_2U5JF5540_NTSC] = { /* SHARP NTSC */
-		.name   = "SHARP NTSC_JP (2U5JF5540)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 137.25 /*MHz*/, 0x01, },
-			{ 16 * 317.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_Samsung_PAL_TCPM9091PD27] = { /* Samsung PAL */
-		.name   = "Samsung PAL TCPM9091PD27",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 169 /*MHz*/, 0xa0, },
-			{ 16 * 464 /*MHz*/, 0x90, },
-			{ 16 * 999.99     , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_MT2032] = { /* Microtune PAL|NTSC */
-		.name   = "MT20xx universal",
-	  /* see mt20xx.c for details */ },
-	[TUNER_TEMIC_4106FH5] = { /* TEMIC PAL */
-		.name   = "Temic PAL_BG (4106 FH5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 141.00 /*MHz*/, 0xa0, },
-			{ 16 * 464.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4012FY5] = { /* TEMIC PAL */
-		.name   = "Temic PAL_DK/SECAM_L (4012 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 140.25 /*MHz*/, 0x02, },
-			{ 16 * 463.25 /*MHz*/, 0x04, },
-			{ 16 * 999.99        , 0x01, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEMIC_4136FY5] = { /* TEMIC NTSC */
-		.name   = "Temic NTSC (4136 FY5)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 158.00 /*MHz*/, 0xa0, },
-			{ 16 * 453.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_PAL_NEW_TAPC] = { /* LGINNOTEK PAL */
-		.name   = "LG PAL (newer TAPC series)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0x01, },
-			{ 16 * 450.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_FM1216ME_MK3] = { /* Philips PAL */
-		.name   = "Philips PAL/SECAM multi (FM1216ME MK3)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 158.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_NTSC_NEW_TAPC] = { /* LGINNOTEK NTSC */
-		.name   = "LG NTSC (newer TAPC series)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0x01, },
-			{ 16 * 450.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 40-49 */
-	[TUNER_HITACHI_NTSC] = { /* HITACHI NTSC */
-		.name   = "HITACHI V7-J180AT",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0x01, },
-			{ 16 * 450.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_PAL_MK] = { /* Philips PAL */
-		.name   = "Philips PAL_MK (FI1216 MK)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 140.25 /*MHz*/, 0x01, },
-			{ 16 * 463.25 /*MHz*/, 0xc2, },
-			{ 16 * 999.99        , 0xcf, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_ATSC] = { /* Philips ATSC */
-		.name   = "Philips 1236D ATSC/NTSC dual in",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_FM1236_MK3] = { /* Philips NTSC */
-		.name   = "Philips NTSC MK3 (FM1236MK3 or FM1236/F)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_4IN1] = { /* Philips NTSC */
-		.name   = "Philips 4 in 1 (ATI TV Wonder Pro/Conexant)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_MICROTUNE_4049FM5] = { /* Microtune PAL */
-		.name   = "Microtune 4049 FM5",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 141.00 /*MHz*/, 0xa0, },
-			{ 16 * 464.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PANASONIC_VP27] = { /* Panasonic NTSC */
-		.name   = "Panasonic VP27s/ENGE4324D",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 454.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0xce,
-	},
-	[TUNER_LG_NTSC_TAPE] = { /* LGINNOTEK NTSC */
-		.name   = "LG NTSC (TAPE series)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TNF_8831BGFF] = { /* Philips PAL */
-		.name   = "Tenna TNF 8831 BGFF)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 161.25 /*MHz*/, 0xa0, },
-			{ 16 * 463.25 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_MICROTUNE_4042FI5] = { /* Microtune NTSC */
-		.name   = "Microtune 4042 FI5 ATSC/NTSC dual in",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 162.00 /*MHz*/, 0xa2, },
-			{ 16 * 457.00 /*MHz*/, 0x94, },
-			{ 16 * 999.99        , 0x31, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 50-59 */
-	[TUNER_TCL_2002N] = { /* TCL NTSC */
-		.name   = "TCL 2002N",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 172.00 /*MHz*/, 0x01, },
-			{ 16 * 448.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_FM1256_IH3] = { /* Philips PAL */
-		.name   = "Philips PAL/SECAM_D (FM 1256 I-H3)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_THOMSON_DTT7610] = { /* THOMSON ATSC */
-		.name   = "Thomson DTT 7610 (ATSC/NTSC)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0x39, },
-			{ 16 * 454.00 /*MHz*/, 0x3a, },
-			{ 16 * 999.99        , 0x3c, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_FQ1286] = { /* Philips NTSC */
-		.name   = "Philips FQ1286",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x41, },
-			{ 16 * 454.00 /*MHz*/, 0x42, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_TDA8290] = { /* Philips PAL|NTSC */
-		.name   = "tda8290+75",
-	  /* see tda8290.c for details */ },
-	[TUNER_TCL_2002MB] = { /* TCL PAL */
-		.name   = "TCL 2002MB",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 170.00 /*MHz*/, 0x01, },
-			{ 16 * 450.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0xce,
-	},
-	[TUNER_PHILIPS_FQ1216AME_MK4] = { /* Philips PAL */
-		.name   = "Philips PAL/SECAM multi (FQ1216AME MK4)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0xce,
-	},
-	[TUNER_PHILIPS_FQ1236A_MK4] = { /* Philips NTSC */
-		.name   = "Philips FQ1236A MK4",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 442.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_YMEC_TVF_8531MF] = { /* Philips NTSC */
-		.name   = "Ymec TVision TVF-8531MF/8831MF/8731MF",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0xa0, },
-			{ 16 * 454.00 /*MHz*/, 0x90, },
-			{ 16 * 999.99        , 0x30, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_YMEC_TVF_5533MF] = { /* Philips NTSC */
-		.name   = "Ymec TVision TVF-5533MF",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01, },
-			{ 16 * 454.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-
-	/* 60-69 */
-	[TUNER_THOMSON_DTT761X] = { /* THOMSON ATSC */
-		/* DTT 7611 7611A 7612 7613 7613A 7614 7615 7615A */
-		.name   = "Thomson DTT 761X (ATSC/NTSC)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 145.25 /*MHz*/, 0x39, },
-			{ 16 * 415.25 /*MHz*/, 0x3a, },
-			{ 16 * 999.99        , 0x3c, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TENA_9533_DI] = { /* Philips PAL */
-		.name   = "Tena TNF9533-D/IF/TNF9533-B/DF",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.25 /*MHz*/, 0x01, },
-			{ 16 * 464.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_TEA5767] = { /* Philips RADIO */
-		.name   = "Philips TEA5767HN FM Radio",
-	  /* see tea5767.c for details */},
-	[TUNER_PHILIPS_FMD1216ME_MK3] = { /* Philips PAL */
-		.name   = "Philips FMD1216ME MK3 Hybrid Tuner",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x51, },
-			{ 16 * 442.00 /*MHz*/, 0x52, },
-			{ 16 * 999.99        , 0x54, },
-		},
-		.config = 0x86,
-	},
-	[TUNER_LG_TDVS_H062F] = { /* LGINNOTEK ATSC */
-		.name   = "LG TDVS-H062F/TUA6034",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0x01 },
-			{ 16 * 455.00 /*MHz*/, 0x02 },
-			{ 16 * 999.99        , 0x04 },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_YMEC_TVF66T5_B_DFF] = { /* Philips PAL */
-		.name   = "Ymec TVF66T5-B/DFF",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.25 /*MHz*/, 0x01, },
-			{ 16 * 464.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_LG_NTSC_TALN_MINI] = { /* LGINNOTEK NTSC */
-		.name   = "LG NTSC (TALN mini series)",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 137.25 /*MHz*/, 0x01, },
-			{ 16 * 373.25 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x08, },
-		},
-		.config = 0x8e,
-	},
-	[TUNER_PHILIPS_TD1316] = { /* Philips PAL */
-		.name   = "Philips TD1316 Hybrid Tuner",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 160.00 /*MHz*/, 0xa1, },
-			{ 16 * 442.00 /*MHz*/, 0xa2, },
-			{ 16 * 999.99        , 0xa4, },
-		},
-		.config = 0xc8,
-	},
-	[TUNER_PHILIPS_TUV1236D] = { /* Philips ATSC */
-		.name   = "Philips TUV1236D ATSC/NTSC dual in",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0x01, },
-			{ 16 * 454.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0xce,
-	},
-	[TUNER_TNF_5335MF] = { /* Philips NTSC */
-		.name   = "Tena TNF 5335 MF",
-		.count  = 3,
-		.ranges = {
-			{ 16 * 157.25 /*MHz*/, 0x01, },
-			{ 16 * 454.00 /*MHz*/, 0x02, },
-			{ 16 * 999.99        , 0x04, },
-		},
-		.config = 0x8e,
-	},
-};
-
-unsigned const int tuner_count = ARRAY_SIZE(tuners);
 
 /* ---------------------------------------------------------------------- */
 
@@ -842,16 +136,23 @@ static void default_set_tv_freq(struct i
 	u8 config, tuneraddr;
 	u16 div;
 	struct tunertype *tun;
-	unsigned char buffer[4];
-	int rc, IFPCoff, i;
+	u8 buffer[4];
+	int rc, IFPCoff, i, j;
 
 	tun = &tuners[t->type];
-	for (i = 0; i < tun->count; i++) {
-		if (freq > tun->ranges[i].thresh)
+	j = TUNER_PARAM_ANALOG;
+
+	for (i = 0; i < tun->params[j].count; i++) {
+		if (freq > tun->params[j].ranges[i].limit)
 			continue;
 		break;
 	}
-	config = tun->ranges[i].cb;
+	if (i == tun->params[j].count) {
+		tuner_dbg("TV frequency out of range (%d > %d)",
+				freq, tun->params[j].ranges[i - 1].limit);
+		freq = tun->params[j].ranges[--i].limit;
+	}
+	config = tun->params[j].ranges[i].cb;
 	/*  i == 0 -> VHF_LO  */
 	/*  i == 1 -> VHF_HI  */
 	/*  i == 2 -> UHF     */
@@ -914,7 +215,7 @@ static void default_set_tv_freq(struct i
 
 	case TUNER_MICROTUNE_4042FI5:
 		/* Set the charge pump for fast tuning */
-		tun->config |= TUNER_CHARGE_PUMP;
+		tun->params[j].config |= TUNER_CHARGE_PUMP;
 		break;
 
 	case TUNER_PHILIPS_TUV1236D:
@@ -943,20 +244,6 @@ static void default_set_tv_freq(struct i
 		break;
 	}
 
-	/*
-	 * Philips FI1216MK2 remark from specification :
-	 * for channel selection involving band switching, and to ensure
-	 * smooth tuning to the desired channel without causing
-	 * unnecessary charge pump action, it is recommended to consider
-	 * the difference between wanted channel frequency and the
-	 * current channel frequency.  Unnecessary charge pump action
-	 * will result in very low tuning voltage which may drive the
-	 * oscillator to extreme conditions.
-	 *
-	 * Progfou: specification says to send config data before
-	 * frequency in case (wanted frequency < current frequency).
-	 */
-
 	/* IFPCoff = Video Intermediate Frequency - Vif:
 		940  =16*58.75  NTSC/J (Japan)
 		732  =16*45.75  M/N STD
@@ -988,17 +275,18 @@ static void default_set_tv_freq(struct i
 					offset / 16, offset % 16 * 100 / 16,
 					div);
 
-	if (t->type == TUNER_PHILIPS_SECAM && freq < t->freq) {
-		buffer[0] = tun->config;
+	if (tuners[t->type].params->cb_first_if_lower_freq && div < t->last_div) {
+		buffer[0] = tun->params[j].config;
 		buffer[1] = config;
 		buffer[2] = (div>>8) & 0x7f;
 		buffer[3] = div      & 0xff;
 	} else {
 		buffer[0] = (div>>8) & 0x7f;
 		buffer[1] = div      & 0xff;
-		buffer[2] = tun->config;
+		buffer[2] = tun->params[j].config;
 		buffer[3] = config;
 	}
+	t->last_div = div;
 	tuner_dbg("tv 0x%02x 0x%02x 0x%02x 0x%02x\n",
 		  buffer[0],buffer[1],buffer[2],buffer[3]);
 
@@ -1024,10 +312,10 @@ static void default_set_tv_freq(struct i
 		}
 
 		/* Set the charge pump for optimized phase noise figure */
-		tun->config &= ~TUNER_CHARGE_PUMP;
+		tun->params[j].config &= ~TUNER_CHARGE_PUMP;
 		buffer[0] = (div>>8) & 0x7f;
 		buffer[1] = div      & 0xff;
-		buffer[2] = tun->config;
+		buffer[2] = tun->params[j].config;
 		buffer[3] = config;
 		tuner_dbg("tv 0x%02x 0x%02x 0x%02x 0x%02x\n",
 		       buffer[0],buffer[1],buffer[2],buffer[3]);
@@ -1041,13 +329,15 @@ static void default_set_radio_freq(struc
 {
 	struct tunertype *tun;
 	struct tuner *t = i2c_get_clientdata(c);
-	unsigned char buffer[4];
-	unsigned div;
-	int rc;
+	u8 buffer[4];
+	u16 div;
+	int rc, j;
 
 	tun = &tuners[t->type];
+	j = TUNER_PARAM_ANALOG;
+
 	div = (20 * freq / 16000) + (int)(20*10.7); /* IF 10.7 MHz */
-	buffer[2] = (tun->config & ~TUNER_RATIO_MASK) | TUNER_RATIO_SELECT_50; /* 50 kHz step */
+	buffer[2] = (tun->params[j].config & ~TUNER_RATIO_MASK) | TUNER_RATIO_SELECT_50; /* 50 kHz step */
 
 	switch (t->type) {
 	case TUNER_TENA_9533_DI:
@@ -1076,9 +366,19 @@ static void default_set_radio_freq(struc
 	}
 	buffer[0] = (div>>8) & 0x7f;
 	buffer[1] = div      & 0xff;
+	if (tuners[t->type].params->cb_first_if_lower_freq && div < t->last_div) {
+		buffer[0] = buffer[2];
+		buffer[1] = buffer[3];
+		buffer[2] = (div>>8) & 0x7f;
+		buffer[3] = div      & 0xff;
+	} else {
+		buffer[0] = (div>>8) & 0x7f;
+		buffer[1] = div      & 0xff;
+	}
 
 	tuner_dbg("radio 0x%02x 0x%02x 0x%02x 0x%02x\n",
 	       buffer[0],buffer[1],buffer[2],buffer[3]);
+	t->last_div = div;
 
 	if (4 != (rc = i2c_master_send(c,buffer,4)))
 		tuner_warn("i2c i/o error: rc == %d (should be 4)\n",rc);
@@ -1092,10 +392,10 @@ int default_tuner_init(struct i2c_client
 		   t->type, tuners[t->type].name);
 	strlcpy(c->name, tuners[t->type].name, sizeof(c->name));
 
-	t->tv_freq    = default_set_tv_freq;
-	t->radio_freq = default_set_radio_freq;
+	t->set_tv_freq = default_set_tv_freq;
+	t->set_radio_freq = default_set_radio_freq;
 	t->has_signal = tuner_signal;
-	t->is_stereo  = tuner_stereo;
+	t->is_stereo = tuner_stereo;
 	t->standby = NULL;
 
 	return 0;
diff -purN linux-2.6.15-git12/drivers/media/video/tuner-types.c linux-2.6.16-rc1/drivers/media/video/tuner-types.c
--- linux-2.6.15-git12/drivers/media/video/tuner-types.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tuner-types.c	2006-01-17 08:22:47.263364276 +0000
@@ -0,0 +1,1406 @@
+/*
+ *
+ * i2c tv tuner chip device type database.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <media/tuner.h>
+#include <media/tuner-types.h>
+
+/* ---------------------------------------------------------------------- */
+
+/*
+ *	The floats in the tuner struct are computed at compile time
+ *	by gcc and cast back to integers. Thus we don't violate the
+ *	"no float in kernel" rule.
+ *
+ *	A tuner_range may be referenced by multiple tuner_params structs.
+ *	There are many duplicates in here. Reusing tuner_range structs,
+ *	rather than defining new ones for each tuner, will cut down on
+ *	memory usage, and is preferred when possible.
+ *
+ *	Each tuner_params array may contain one or more elements, one
+ *	for each video standard.
+ *
+ *	FIXME: Some tuner_range definitions are duplicated, and
+ *	should be eliminated.
+ *
+ *	FIXME: tunertype struct contains an element, has_tda988x.
+ *	We must set this for all tunertypes that contain a tda988x
+ *	chip, and then we can remove this setting from the various
+ *	card structs.
+ */
+
+/* 0-9 */
+/* ------------ TUNER_TEMIC_PAL - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_pal_ranges[] = {
+	{ 16 * 140.25 /*MHz*/, 0x02, },
+	{ 16 * 463.25 /*MHz*/, 0x04, },
+	{ 16 * 999.99        , 0x01, },
+};
+
+static struct tuner_params tuner_temic_pal_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_PAL_I - Philips PAL_I ------------ */
+
+static struct tuner_range tuner_philips_pal_i_ranges[] = {
+	{ 16 * 140.25 /*MHz*/, 0xa0, },
+	{ 16 * 463.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_pal_i_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_pal_i_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_pal_i_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_NTSC - Philips NTSC ------------ */
+
+static struct tuner_range tuner_philips_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0xa0, },
+	{ 16 * 451.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_ntsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_ntsc_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_SECAM - Philips SECAM ------------ */
+
+static struct tuner_range tuner_philips_secam_ranges[] = {
+	{ 16 * 168.25 /*MHz*/, 0xa7, },
+	{ 16 * 447.25 /*MHz*/, 0x97, },
+	{ 16 * 999.99        , 0x37, },
+};
+
+static struct tuner_params tuner_philips_secam_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_SECAM,
+		.ranges = tuner_philips_secam_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_secam_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_PAL - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_pal_ranges[] = {
+	{ 16 * 168.25 /*MHz*/, 0xa0, },
+	{ 16 * 447.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_pal_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_pal_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_TEMIC_NTSC - TEMIC NTSC ------------ */
+
+static struct tuner_range tuner_temic_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0x02, },
+	{ 16 * 463.25 /*MHz*/, 0x04, },
+	{ 16 * 999.99        , 0x01, },
+};
+
+static struct tuner_params tuner_temic_ntsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_temic_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_PAL_I - TEMIC PAL_I ------------ */
+
+static struct tuner_range tuner_temic_pal_i_ranges[] = {
+	{ 16 * 170.00 /*MHz*/, 0x02, },
+	{ 16 * 450.00 /*MHz*/, 0x04, },
+	{ 16 * 999.99        , 0x01, },
+};
+
+static struct tuner_params tuner_temic_pal_i_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_pal_i_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_pal_i_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4036FY5_NTSC - TEMIC NTSC ------------ */
+
+static struct tuner_range tuner_temic_4036fy5_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0xa0, },
+	{ 16 * 463.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4036fy5_ntsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_temic_4036fy5_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4036fy5_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_ALPS_TSBH1_NTSC - TEMIC NTSC ------------ */
+
+static struct tuner_range tuner_alps_tsb_1_ranges[] = {
+	{ 16 * 137.25 /*MHz*/, 0x01, },
+	{ 16 * 385.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_alps_tsbh1_ntsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_alps_tsb_1_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tsb_1_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 10-19 */
+/* ------------ TUNER_ALPS_TSBE1_PAL - TEMIC PAL ------------ */
+
+static struct tuner_params tuner_alps_tsb_1_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_alps_tsb_1_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tsb_1_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_ALPS_TSBB5_PAL_I - Alps PAL_I ------------ */
+
+static struct tuner_range tuner_alps_tsb_5_pal_ranges[] = {
+	{ 16 * 133.25 /*MHz*/, 0x01, },
+	{ 16 * 351.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_alps_tsbb5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_alps_tsb_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tsb_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_ALPS_TSBE5_PAL - Alps PAL ------------ */
+
+static struct tuner_params tuner_alps_tsbe5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_alps_tsb_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tsb_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_ALPS_TSBC5_PAL - Alps PAL ------------ */
+
+static struct tuner_params tuner_alps_tsbc5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_alps_tsb_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tsb_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4006FH5_PAL - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_4006fh5_pal_ranges[] = {
+	{ 16 * 170.00 /*MHz*/, 0xa0, },
+	{ 16 * 450.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4006fh5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4006fh5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4006fh5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_ALPS_TSHC6_NTSC - Alps NTSC ------------ */
+
+static struct tuner_range tuner_alps_tshc6_ntsc_ranges[] = {
+	{ 16 * 137.25 /*MHz*/, 0x14, },
+	{ 16 * 385.25 /*MHz*/, 0x12, },
+	{ 16 * 999.99        , 0x11, },
+};
+
+static struct tuner_params tuner_alps_tshc6_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_alps_tshc6_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_alps_tshc6_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_PAL_DK - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_pal_dk_ranges[] = {
+	{ 16 * 168.25 /*MHz*/, 0xa0, },
+	{ 16 * 456.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_pal_dk_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_pal_dk_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_pal_dk_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_NTSC_M - Philips NTSC ------------ */
+
+static struct tuner_range tuner_philips_ntsc_m_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0xa0, },
+	{ 16 * 454.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_ntsc_m_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_ntsc_m_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_ntsc_m_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4066FY5_PAL_I - TEMIC PAL_I ------------ */
+
+static struct tuner_range tuner_temic_40x6f_5_pal_ranges[] = {
+	{ 16 * 169.00 /*MHz*/, 0xa0, },
+	{ 16 * 454.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4066fy5_pal_i_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_40x6f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_40x6f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4006FN5_MULTI_PAL - TEMIC PAL ------------ */
+
+static struct tuner_params tuner_temic_4006fn5_multi_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_40x6f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_40x6f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 20-29 */
+/* ------------ TUNER_TEMIC_4009FR5_PAL - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_4009f_5_pal_ranges[] = {
+	{ 16 * 141.00 /*MHz*/, 0xa0, },
+	{ 16 * 464.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4009f_5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4009f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4009f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4039FR5_NTSC - TEMIC NTSC ------------ */
+
+static struct tuner_range tuner_temic_4039fr5_ntsc_ranges[] = {
+	{ 16 * 158.00 /*MHz*/, 0xa0, },
+	{ 16 * 453.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4039fr5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_temic_4039fr5_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4039fr5_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4046FM5 - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_4046fm5_pal_ranges[] = {
+	{ 16 * 169.00 /*MHz*/, 0xa0, },
+	{ 16 * 454.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4046fm5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4046fm5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4046fm5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_PAL_DK - Philips PAL ------------ */
+
+static struct tuner_range tuner_lg_pal_ranges[] = {
+	{ 16 * 170.00 /*MHz*/, 0xa0, },
+	{ 16 * 450.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_pal_dk_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FQ1216ME - Philips PAL ------------ */
+
+static struct tuner_params tuner_philips_fq1216me_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_PAL_I_FM - LGINNOTEK PAL_I ------------ */
+
+static struct tuner_params tuner_lg_pal_i_fm_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_PAL_I - LGINNOTEK PAL_I ------------ */
+
+static struct tuner_params tuner_lg_pal_i_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_NTSC_FM - LGINNOTEK NTSC ------------ */
+
+static struct tuner_range tuner_lg_ntsc_fm_ranges[] = {
+	{ 16 * 210.00 /*MHz*/, 0xa0, },
+	{ 16 * 497.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_lg_ntsc_fm_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_lg_ntsc_fm_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_ntsc_fm_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_PAL_FM - LGINNOTEK PAL ------------ */
+
+static struct tuner_params tuner_lg_pal_fm_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_PAL - LGINNOTEK PAL ------------ */
+
+static struct tuner_params tuner_lg_pal_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 30-39 */
+/* ------------ TUNER_TEMIC_4009FN5_MULTI_PAL_FM - TEMIC PAL ------------ */
+
+static struct tuner_params tuner_temic_4009_fn5_multi_pal_fm_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4009f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4009f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_SHARP_2U5JF5540_NTSC - SHARP NTSC ------------ */
+
+static struct tuner_range tuner_sharp_2u5jf5540_ntsc_ranges[] = {
+	{ 16 * 137.25 /*MHz*/, 0x01, },
+	{ 16 * 317.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_sharp_2u5jf5540_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_sharp_2u5jf5540_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_sharp_2u5jf5540_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_Samsung_PAL_TCPM9091PD27 - Samsung PAL ------------ */
+
+static struct tuner_range tuner_samsung_pal_tcpm9091pd27_ranges[] = {
+	{ 16 * 169 /*MHz*/, 0xa0, },
+	{ 16 * 464 /*MHz*/, 0x90, },
+	{ 16 * 999.99     , 0x30, },
+};
+
+static struct tuner_params tuner_samsung_pal_tcpm9091pd27_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_samsung_pal_tcpm9091pd27_ranges,
+		.count  = ARRAY_SIZE(tuner_samsung_pal_tcpm9091pd27_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4106FH5 - TEMIC PAL ------------ */
+
+static struct tuner_params tuner_temic_4106fh5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4009f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4009f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4012FY5 - TEMIC PAL ------------ */
+
+static struct tuner_range tuner_temic_4012fy5_pal_ranges[] = {
+	{ 16 * 140.25 /*MHz*/, 0x02, },
+	{ 16 * 463.25 /*MHz*/, 0x04, },
+	{ 16 * 999.99        , 0x01, },
+};
+
+static struct tuner_params tuner_temic_4012fy5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4012fy5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4012fy5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TEMIC_4136FY5 - TEMIC NTSC ------------ */
+
+static struct tuner_range tuner_temic_4136_fy5_ntsc_ranges[] = {
+	{ 16 * 158.00 /*MHz*/, 0xa0, },
+	{ 16 * 453.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_temic_4136_fy5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_temic_4136_fy5_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4136_fy5_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_PAL_NEW_TAPC - LGINNOTEK PAL ------------ */
+
+static struct tuner_range tuner_lg_new_tapc_ranges[] = {
+	{ 16 * 170.00 /*MHz*/, 0x01, },
+	{ 16 * 450.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_lg_pal_new_tapc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_lg_new_tapc_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_new_tapc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FM1216ME_MK3 - Philips PAL ------------ */
+
+static struct tuner_range tuner_fm1216me_mk3_pal_ranges[] = {
+	{ 16 * 158.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_fm1216me_mk3_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_fm1216me_mk3_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_fm1216me_mk3_pal_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_LG_NTSC_NEW_TAPC - LGINNOTEK NTSC ------------ */
+
+static struct tuner_params tuner_lg_ntsc_new_tapc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_lg_new_tapc_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_new_tapc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 40-49 */
+/* ------------ TUNER_HITACHI_NTSC - HITACHI NTSC ------------ */
+
+static struct tuner_params tuner_hitachi_ntsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_lg_new_tapc_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_new_tapc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_PAL_MK - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_pal_mk_pal_ranges[] = {
+	{ 16 * 140.25 /*MHz*/, 0x01, },
+	{ 16 * 463.25 /*MHz*/, 0xc2, },
+	{ 16 * 999.99        , 0xcf, },
+};
+
+static struct tuner_params tuner_philips_pal_mk_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_pal_mk_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_pal_mk_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_ATSC - Philips ATSC ------------ */
+
+static struct tuner_range tuner_philips_atsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0xa0, },
+	{ 16 * 454.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_philips_atsc_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_atsc_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_atsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FM1236_MK3 - Philips NTSC ------------ */
+
+static struct tuner_range tuner_fm1236_mk3_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_fm1236_mk3_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_fm1236_mk3_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_fm1236_mk3_ntsc_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_4IN1 - Philips NTSC ------------ */
+
+static struct tuner_range tuner_philips_4in1_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_philips_4in1_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_4in1_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_4in1_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_MICROTUNE_4049FM5 - Microtune PAL ------------ */
+
+static struct tuner_params tuner_microtune_4049_fm5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_temic_4009f_5_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_temic_4009f_5_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PANASONIC_VP27 - Panasonic NTSC ------------ */
+
+static struct tuner_range tuner_panasonic_vp27_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 454.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_panasonic_vp27_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_panasonic_vp27_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_panasonic_vp27_ntsc_ranges),
+		.config = 0xce,
+	},
+};
+
+/* ------------ TUNER_LG_NTSC_TAPE - LGINNOTEK NTSC ------------ */
+
+static struct tuner_range tuner_lg_ntsc_tape_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_lg_ntsc_tape_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_lg_ntsc_tape_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_ntsc_tape_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TNF_8831BGFF - Philips PAL ------------ */
+
+static struct tuner_range tuner_tnf_8831bgff_pal_ranges[] = {
+	{ 16 * 161.25 /*MHz*/, 0xa0, },
+	{ 16 * 463.25 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_tnf_8831bgff_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_tnf_8831bgff_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_tnf_8831bgff_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_MICROTUNE_4042FI5 - Microtune NTSC ------------ */
+
+static struct tuner_range tuner_microtune_4042fi5_ntsc_ranges[] = {
+	{ 16 * 162.00 /*MHz*/, 0xa2, },
+	{ 16 * 457.00 /*MHz*/, 0x94, },
+	{ 16 * 999.99        , 0x31, },
+};
+
+static struct tuner_params tuner_microtune_4042fi5_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_microtune_4042fi5_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_microtune_4042fi5_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 50-59 */
+/* ------------ TUNER_TCL_2002N - TCL NTSC ------------ */
+
+static struct tuner_range tuner_tcl_2002n_ntsc_ranges[] = {
+	{ 16 * 172.00 /*MHz*/, 0x01, },
+	{ 16 * 448.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_tcl_2002n_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_tcl_2002n_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_tcl_2002n_ntsc_ranges),
+		.config = 0x8e,
+		.cb_first_if_lower_freq = 1,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FM1256_IH3 - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_fm1256_ih3_pal_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_philips_fm1256_ih3_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_fm1256_ih3_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_fm1256_ih3_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_THOMSON_DTT7610 - THOMSON ATSC ------------ */
+
+static struct tuner_range tuner_thomson_dtt7610_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0x39, },
+	{ 16 * 454.00 /*MHz*/, 0x3a, },
+	{ 16 * 999.99        , 0x3c, },
+};
+
+static struct tuner_params tuner_thomson_dtt7610_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_thomson_dtt7610_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_thomson_dtt7610_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FQ1286 - Philips NTSC ------------ */
+
+static struct tuner_range tuner_philips_fq1286_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x41, },
+	{ 16 * 454.00 /*MHz*/, 0x42, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_philips_fq1286_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_fq1286_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_fq1286_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TCL_2002MB - TCL PAL ------------ */
+
+static struct tuner_range tuner_tcl_2002mb_pal_ranges[] = {
+	{ 16 * 170.00 /*MHz*/, 0x01, },
+	{ 16 * 450.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_tcl_2002mb_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_tcl_2002mb_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_tcl_2002mb_pal_ranges),
+		.config = 0xce,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FQ1216AME_MK4 - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_fq12_6a___mk4_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 442.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_philips_fq1216ame_mk4_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_fq12_6a___mk4_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_fq12_6a___mk4_ranges),
+		.config = 0xce,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FQ1236A_MK4 - Philips NTSC ------------ */
+
+static struct tuner_params tuner_philips_fq1236a_mk4_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_philips_fq12_6a___mk4_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_fq12_6a___mk4_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_YMEC_TVF_8531MF - Philips NTSC ------------ */
+
+static struct tuner_range tuner_ymec_tvf_8531mf_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0xa0, },
+	{ 16 * 454.00 /*MHz*/, 0x90, },
+	{ 16 * 999.99        , 0x30, },
+};
+
+static struct tuner_params tuner_ymec_tvf_8531mf_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_ymec_tvf_8531mf_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_ymec_tvf_8531mf_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_YMEC_TVF_5533MF - Philips NTSC ------------ */
+
+static struct tuner_range tuner_ymec_tvf_5533mf_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01, },
+	{ 16 * 454.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_ymec_tvf_5533mf_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_ymec_tvf_5533mf_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_ymec_tvf_5533mf_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 60-69 */
+/* ------------ TUNER_THOMSON_DTT761X - THOMSON ATSC ------------ */
+/* DTT 7611 7611A 7612 7613 7613A 7614 7615 7615A */
+
+static struct tuner_range tuner_thomson_dtt761x_ntsc_ranges[] = {
+	{ 16 * 145.25 /*MHz*/, 0x39, },
+	{ 16 * 415.25 /*MHz*/, 0x3a, },
+	{ 16 * 999.99        , 0x3c, },
+};
+
+
+static struct tuner_params tuner_thomson_dtt761x_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_thomson_dtt761x_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_thomson_dtt761x_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_TENA_9533_DI - Philips PAL ------------ */
+
+static struct tuner_range tuner_tuner_tena_9533_di_pal_ranges[] = {
+	{ 16 * 160.25 /*MHz*/, 0x01, },
+	{ 16 * 464.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_tena_9533_di_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_tuner_tena_9533_di_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_tuner_tena_9533_di_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_FMD1216ME_MK3 - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_fmd1216me_mk3_pal_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x51, },
+	{ 16 * 442.00 /*MHz*/, 0x52, },
+	{ 16 * 999.99        , 0x54, },
+};
+
+
+static struct tuner_params tuner_tuner_philips_fmd1216me_mk3_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_fmd1216me_mk3_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_fmd1216me_mk3_pal_ranges),
+		.config = 0x86,
+	},
+};
+
+
+/* ------------ TUNER_LG_TDVS_H062F - INFINEON ATSC ------------ */
+
+static struct tuner_range tuner_tua6034_ntsc_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0x01 },
+	{ 16 * 455.00 /*MHz*/, 0x02 },
+	{ 16 * 999.99        , 0x04 },
+};
+
+
+static struct tuner_params tuner_tua6034_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_tua6034_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_tua6034_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_YMEC_TVF66T5_B_DFF - Philips PAL ------------ */
+
+static struct tuner_range tuner_ymec_tvf66t5_b_dff_pal_ranges[] = {
+	{ 16 * 160.25 /*MHz*/, 0x01, },
+	{ 16 * 464.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_ymec_tvf66t5_b_dff_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_ymec_tvf66t5_b_dff_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_ymec_tvf66t5_b_dff_pal_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_LG_NTSC_TALN_MINI - LGINNOTEK NTSC ------------ */
+
+static struct tuner_range tuner_lg_taln_mini_ntsc_ranges[] = {
+	{ 16 * 137.25 /*MHz*/, 0x01, },
+	{ 16 * 373.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_lg_taln_mini_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_lg_taln_mini_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_lg_taln_mini_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_TD1316 - Philips PAL ------------ */
+
+static struct tuner_range tuner_philips_td1316_pal_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0xa1, },
+	{ 16 * 442.00 /*MHz*/, 0xa2, },
+	{ 16 * 999.99        , 0xa4, },
+};
+
+static struct tuner_params tuner_philips_td1316_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_philips_td1316_pal_ranges,
+		.count  = ARRAY_SIZE(tuner_philips_td1316_pal_ranges),
+		.config = 0xc8,
+	},
+};
+
+/* ------------ TUNER_PHILIPS_TUV1236D - Philips ATSC ------------ */
+
+static struct tuner_range tuner_tuv1236d_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0x01, },
+	{ 16 * 454.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+
+static struct tuner_params tuner_tuner_tuv1236d_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_tuv1236d_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_tuv1236d_ntsc_ranges),
+		.config = 0xce,
+	},
+};
+
+/* ------------ TUNER_TNF_5335MF - Philips NTSC ------------ */
+
+static struct tuner_range tuner_tnf_5335mf_ntsc_ranges[] = {
+	{ 16 * 157.25 /*MHz*/, 0x01, },
+	{ 16 * 454.00 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x04, },
+};
+
+static struct tuner_params tuner_tnf_5335mf_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_tnf_5335mf_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_tnf_5335mf_ntsc_ranges),
+		.config = 0x8e,
+	},
+};
+
+/* 70-79 */
+/* ------------ TUNER_SAMSUNG_TCPN_2121P30A - Samsung NTSC ------------ */
+
+static struct tuner_range tuner_samsung_tcpn_2121p30a_ntsc_ranges[] = {
+	{ 16 * 175.75 /*MHz*/, 0x01, },
+	{ 16 * 410.25 /*MHz*/, 0x02, },
+	{ 16 * 999.99        , 0x08, },
+};
+
+static struct tuner_params tuner_samsung_tcpn_2121p30a_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_NTSC,
+		.ranges = tuner_samsung_tcpn_2121p30a_ntsc_ranges,
+		.count  = ARRAY_SIZE(tuner_samsung_tcpn_2121p30a_ntsc_ranges),
+		.config = 0xce,
+	},
+};
+
+/* --------------------------------------------------------------------- */
+
+struct tunertype tuners[] = {
+	/* 0-9 */
+	[TUNER_TEMIC_PAL] = { /* TEMIC PAL */
+		.name   = "Temic PAL (4002 FH5)",
+		.params = tuner_temic_pal_params,
+	},
+	[TUNER_PHILIPS_PAL_I] = { /* Philips PAL_I */
+		.name   = "Philips PAL_I (FI1246 and compatibles)",
+		.params = tuner_philips_pal_i_params,
+	},
+	[TUNER_PHILIPS_NTSC] = { /* Philips NTSC */
+		.name   = "Philips NTSC (FI1236,FM1236 and compatibles)",
+		.params = tuner_philips_ntsc_params,
+	},
+	[TUNER_PHILIPS_SECAM] = { /* Philips SECAM */
+		.name   = "Philips (SECAM+PAL_BG) (FI1216MF, FM1216MF, FR1216MF)",
+		.params = tuner_philips_secam_params,
+	},
+	[TUNER_ABSENT] = { /* Tuner Absent */
+		.name   = "NoTuner",
+	},
+	[TUNER_PHILIPS_PAL] = { /* Philips PAL */
+		.name   = "Philips PAL_BG (FI1216 and compatibles)",
+		.params = tuner_philips_pal_params,
+	},
+	[TUNER_TEMIC_NTSC] = { /* TEMIC NTSC */
+		.name   = "Temic NTSC (4032 FY5)",
+		.params = tuner_temic_ntsc_params,
+	},
+	[TUNER_TEMIC_PAL_I] = { /* TEMIC PAL_I */
+		.name   = "Temic PAL_I (4062 FY5)",
+		.params = tuner_temic_pal_i_params,
+	},
+	[TUNER_TEMIC_4036FY5_NTSC] = { /* TEMIC NTSC */
+		.name   = "Temic NTSC (4036 FY5)",
+		.params = tuner_temic_4036fy5_ntsc_params,
+	},
+	[TUNER_ALPS_TSBH1_NTSC] = { /* TEMIC NTSC */
+		.name   = "Alps HSBH1",
+		.params = tuner_alps_tsbh1_ntsc_params,
+	},
+
+	/* 10-19 */
+	[TUNER_ALPS_TSBE1_PAL] = { /* TEMIC PAL */
+		.name   = "Alps TSBE1",
+		.params = tuner_alps_tsb_1_params,
+	},
+	[TUNER_ALPS_TSBB5_PAL_I] = { /* Alps PAL_I */
+		.name   = "Alps TSBB5",
+		.params = tuner_alps_tsbb5_params,
+	},
+	[TUNER_ALPS_TSBE5_PAL] = { /* Alps PAL */
+		.name   = "Alps TSBE5",
+		.params = tuner_alps_tsbe5_params,
+	},
+	[TUNER_ALPS_TSBC5_PAL] = { /* Alps PAL */
+		.name   = "Alps TSBC5",
+		.params = tuner_alps_tsbc5_params,
+	},
+	[TUNER_TEMIC_4006FH5_PAL] = { /* TEMIC PAL */
+		.name   = "Temic PAL_BG (4006FH5)",
+		.params = tuner_temic_4006fh5_params,
+	},
+	[TUNER_ALPS_TSHC6_NTSC] = { /* Alps NTSC */
+		.name   = "Alps TSCH6",
+		.params = tuner_alps_tshc6_params,
+	},
+	[TUNER_TEMIC_PAL_DK] = { /* TEMIC PAL */
+		.name   = "Temic PAL_DK (4016 FY5)",
+		.params = tuner_temic_pal_dk_params,
+	},
+	[TUNER_PHILIPS_NTSC_M] = { /* Philips NTSC */
+		.name   = "Philips NTSC_M (MK2)",
+		.params = tuner_philips_ntsc_m_params,
+	},
+	[TUNER_TEMIC_4066FY5_PAL_I] = { /* TEMIC PAL_I */
+		.name   = "Temic PAL_I (4066 FY5)",
+		.params = tuner_temic_4066fy5_pal_i_params,
+	},
+	[TUNER_TEMIC_4006FN5_MULTI_PAL] = { /* TEMIC PAL */
+		.name   = "Temic PAL* auto (4006 FN5)",
+		.params = tuner_temic_4006fn5_multi_params,
+	},
+
+	/* 20-29 */
+	[TUNER_TEMIC_4009FR5_PAL] = { /* TEMIC PAL */
+		.name   = "Temic PAL_BG (4009 FR5) or PAL_I (4069 FR5)",
+		.params = tuner_temic_4009f_5_params,
+	},
+	[TUNER_TEMIC_4039FR5_NTSC] = { /* TEMIC NTSC */
+		.name   = "Temic NTSC (4039 FR5)",
+		.params = tuner_temic_4039fr5_params,
+	},
+	[TUNER_TEMIC_4046FM5] = { /* TEMIC PAL */
+		.name   = "Temic PAL/SECAM multi (4046 FM5)",
+		.params = tuner_temic_4046fm5_params,
+	},
+	[TUNER_PHILIPS_PAL_DK] = { /* Philips PAL */
+		.name   = "Philips PAL_DK (FI1256 and compatibles)",
+		.params = tuner_philips_pal_dk_params,
+	},
+	[TUNER_PHILIPS_FQ1216ME] = { /* Philips PAL */
+		.name   = "Philips PAL/SECAM multi (FQ1216ME)",
+		.params = tuner_philips_fq1216me_params,
+	},
+	[TUNER_LG_PAL_I_FM] = { /* LGINNOTEK PAL_I */
+		.name   = "LG PAL_I+FM (TAPC-I001D)",
+		.params = tuner_lg_pal_i_fm_params,
+	},
+	[TUNER_LG_PAL_I] = { /* LGINNOTEK PAL_I */
+		.name   = "LG PAL_I (TAPC-I701D)",
+		.params = tuner_lg_pal_i_params,
+	},
+	[TUNER_LG_NTSC_FM] = { /* LGINNOTEK NTSC */
+		.name   = "LG NTSC+FM (TPI8NSR01F)",
+		.params = tuner_lg_ntsc_fm_params,
+	},
+	[TUNER_LG_PAL_FM] = { /* LGINNOTEK PAL */
+		.name   = "LG PAL_BG+FM (TPI8PSB01D)",
+		.params = tuner_lg_pal_fm_params,
+	},
+	[TUNER_LG_PAL] = { /* LGINNOTEK PAL */
+		.name   = "LG PAL_BG (TPI8PSB11D)",
+		.params = tuner_lg_pal_params,
+	},
+
+	/* 30-39 */
+	[TUNER_TEMIC_4009FN5_MULTI_PAL_FM] = { /* TEMIC PAL */
+		.name   = "Temic PAL* auto + FM (4009 FN5)",
+		.params = tuner_temic_4009_fn5_multi_pal_fm_params,
+	},
+	[TUNER_SHARP_2U5JF5540_NTSC] = { /* SHARP NTSC */
+		.name   = "SHARP NTSC_JP (2U5JF5540)",
+		.params = tuner_sharp_2u5jf5540_params,
+	},
+	[TUNER_Samsung_PAL_TCPM9091PD27] = { /* Samsung PAL */
+		.name   = "Samsung PAL TCPM9091PD27",
+		.params = tuner_samsung_pal_tcpm9091pd27_params,
+	},
+	[TUNER_MT2032] = { /* Microtune PAL|NTSC */
+		.name   = "MT20xx universal",
+		/* see mt20xx.c for details */ },
+	[TUNER_TEMIC_4106FH5] = { /* TEMIC PAL */
+		.name   = "Temic PAL_BG (4106 FH5)",
+		.params = tuner_temic_4106fh5_params,
+	},
+	[TUNER_TEMIC_4012FY5] = { /* TEMIC PAL */
+		.name   = "Temic PAL_DK/SECAM_L (4012 FY5)",
+		.params = tuner_temic_4012fy5_params,
+	},
+	[TUNER_TEMIC_4136FY5] = { /* TEMIC NTSC */
+		.name   = "Temic NTSC (4136 FY5)",
+		.params = tuner_temic_4136_fy5_params,
+	},
+	[TUNER_LG_PAL_NEW_TAPC] = { /* LGINNOTEK PAL */
+		.name   = "LG PAL (newer TAPC series)",
+		.params = tuner_lg_pal_new_tapc_params,
+	},
+	[TUNER_PHILIPS_FM1216ME_MK3] = { /* Philips PAL */
+		.name   = "Philips PAL/SECAM multi (FM1216ME MK3)",
+		.params = tuner_fm1216me_mk3_params,
+	},
+	[TUNER_LG_NTSC_NEW_TAPC] = { /* LGINNOTEK NTSC */
+		.name   = "LG NTSC (newer TAPC series)",
+		.params = tuner_lg_ntsc_new_tapc_params,
+	},
+
+	/* 40-49 */
+	[TUNER_HITACHI_NTSC] = { /* HITACHI NTSC */
+		.name   = "HITACHI V7-J180AT",
+		.params = tuner_hitachi_ntsc_params,
+	},
+	[TUNER_PHILIPS_PAL_MK] = { /* Philips PAL */
+		.name   = "Philips PAL_MK (FI1216 MK)",
+		.params = tuner_philips_pal_mk_params,
+	},
+	[TUNER_PHILIPS_ATSC] = { /* Philips ATSC */
+		.name   = "Philips 1236D ATSC/NTSC dual in",
+		.params = tuner_philips_atsc_params,
+	},
+	[TUNER_PHILIPS_FM1236_MK3] = { /* Philips NTSC */
+		.name   = "Philips NTSC MK3 (FM1236MK3 or FM1236/F)",
+		.params = tuner_fm1236_mk3_params,
+	},
+	[TUNER_PHILIPS_4IN1] = { /* Philips NTSC */
+		.name   = "Philips 4 in 1 (ATI TV Wonder Pro/Conexant)",
+		.params = tuner_philips_4in1_params,
+	},
+	[TUNER_MICROTUNE_4049FM5] = { /* Microtune PAL */
+		.name   = "Microtune 4049 FM5",
+		.params = tuner_microtune_4049_fm5_params,
+	},
+	[TUNER_PANASONIC_VP27] = { /* Panasonic NTSC */
+		.name   = "Panasonic VP27s/ENGE4324D",
+		.params = tuner_panasonic_vp27_params,
+	},
+	[TUNER_LG_NTSC_TAPE] = { /* LGINNOTEK NTSC */
+		.name   = "LG NTSC (TAPE series)",
+		.params = tuner_lg_ntsc_tape_params,
+	},
+	[TUNER_TNF_8831BGFF] = { /* Philips PAL */
+		.name   = "Tenna TNF 8831 BGFF)",
+		.params = tuner_tnf_8831bgff_params,
+	},
+	[TUNER_MICROTUNE_4042FI5] = { /* Microtune NTSC */
+		.name   = "Microtune 4042 FI5 ATSC/NTSC dual in",
+		.params = tuner_microtune_4042fi5_params,
+	},
+
+	/* 50-59 */
+	[TUNER_TCL_2002N] = { /* TCL NTSC */
+		.name   = "TCL 2002N",
+		.params = tuner_tcl_2002n_params,
+	},
+	[TUNER_PHILIPS_FM1256_IH3] = { /* Philips PAL */
+		.name   = "Philips PAL/SECAM_D (FM 1256 I-H3)",
+		.params = tuner_philips_fm1256_ih3_params,
+	},
+	[TUNER_THOMSON_DTT7610] = { /* THOMSON ATSC */
+		.name   = "Thomson DTT 7610 (ATSC/NTSC)",
+		.params = tuner_thomson_dtt7610_params,
+	},
+	[TUNER_PHILIPS_FQ1286] = { /* Philips NTSC */
+		.name   = "Philips FQ1286",
+		.params = tuner_philips_fq1286_params,
+	},
+	[TUNER_PHILIPS_TDA8290] = { /* Philips PAL|NTSC */
+		.name   = "tda8290+75",
+		/* see tda8290.c for details */ },
+	[TUNER_TCL_2002MB] = { /* TCL PAL */
+		.name   = "TCL 2002MB",
+		.params = tuner_tcl_2002mb_params,
+	},
+	[TUNER_PHILIPS_FQ1216AME_MK4] = { /* Philips PAL */
+		.name   = "Philips PAL/SECAM multi (FQ1216AME MK4)",
+		.params = tuner_philips_fq1216ame_mk4_params,
+	},
+	[TUNER_PHILIPS_FQ1236A_MK4] = { /* Philips NTSC */
+		.name   = "Philips FQ1236A MK4",
+		.params = tuner_philips_fq1236a_mk4_params,
+	},
+	[TUNER_YMEC_TVF_8531MF] = { /* Philips NTSC */
+		.name   = "Ymec TVision TVF-8531MF/8831MF/8731MF",
+		.params = tuner_ymec_tvf_8531mf_params,
+	},
+	[TUNER_YMEC_TVF_5533MF] = { /* Philips NTSC */
+		.name   = "Ymec TVision TVF-5533MF",
+		.params = tuner_ymec_tvf_5533mf_params,
+	},
+
+	/* 60-69 */
+	[TUNER_THOMSON_DTT761X] = { /* THOMSON ATSC */
+		/* DTT 7611 7611A 7612 7613 7613A 7614 7615 7615A */
+		.name   = "Thomson DTT 761X (ATSC/NTSC)",
+		.params = tuner_thomson_dtt761x_params,
+	},
+	[TUNER_TENA_9533_DI] = { /* Philips PAL */
+		.name   = "Tena TNF9533-D/IF/TNF9533-B/DF",
+		.params = tuner_tena_9533_di_params,
+	},
+	[TUNER_TEA5767] = { /* Philips RADIO */
+		.name   = "Philips TEA5767HN FM Radio",
+		/* see tea5767.c for details */
+	},
+	[TUNER_PHILIPS_FMD1216ME_MK3] = { /* Philips PAL */
+		.name   = "Philips FMD1216ME MK3 Hybrid Tuner",
+		.params = tuner_tuner_philips_fmd1216me_mk3_params,
+	},
+	[TUNER_LG_TDVS_H062F] = { /* LGINNOTEK ATSC */
+		.name   = "LG TDVS-H062F/TUA6034",
+		.params = tuner_tua6034_params,
+	},
+	[TUNER_YMEC_TVF66T5_B_DFF] = { /* Philips PAL */
+		.name   = "Ymec TVF66T5-B/DFF",
+		.params = tuner_ymec_tvf66t5_b_dff_params,
+	},
+	[TUNER_LG_NTSC_TALN_MINI] = { /* LGINNOTEK NTSC */
+		.name   = "LG NTSC (TALN mini series)",
+		.params = tuner_lg_taln_mini_params,
+	},
+	[TUNER_PHILIPS_TD1316] = { /* Philips PAL */
+		.name   = "Philips TD1316 Hybrid Tuner",
+		.params = tuner_philips_td1316_params,
+	},
+	[TUNER_PHILIPS_TUV1236D] = { /* Philips ATSC */
+		.name   = "Philips TUV1236D ATSC/NTSC dual in",
+		.params = tuner_tuner_tuv1236d_params,
+	},
+	[TUNER_TNF_5335MF] = { /* Philips NTSC */
+		.name   = "Tena TNF 5335 MF",
+		.params = tuner_tnf_5335mf_params,
+	},
+
+	/* 70-79 */
+	[TUNER_SAMSUNG_TCPN_2121P30A] = { /* Samsung NTSC */
+		.name   = "Samsung TCPN 2121P30A",
+		.params = tuner_samsung_tcpn_2121p30a_params,
+	},
+};
+
+unsigned const int tuner_count = ARRAY_SIZE(tuners);
diff -purN linux-2.6.15-git12/drivers/media/video/tveeprom.c linux-2.6.16-rc1/drivers/media/video/tveeprom.c
--- linux-2.6.15-git12/drivers/media/video/tveeprom.c	2006-01-17 08:21:33.085719495 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tveeprom.c	2006-01-17 08:22:47.275362387 +0000
@@ -190,7 +190,7 @@ hauppauge_tuner[] =
 	{ TUNER_LG_PAL_NEW_TAPC, "TCL 2002MI 3"},
 	{ TUNER_TCL_2002N,     "TCL 2002N 6A"},
 	{ TUNER_PHILIPS_FM1236_MK3, "Philips FQ1236 MK3"},
-	{ TUNER_ABSENT,        "Samsung TCPN 2121P30A"},
+	{ TUNER_SAMSUNG_TCPN_2121P30A, "Samsung TCPN 2121P30A"},
 	{ TUNER_ABSENT,        "Samsung TCPE 4121P30A"},
 	{ TUNER_PHILIPS_FM1216ME_MK3, "TCL MFPE05 2"},
 	/* 90-99 */
diff -purN linux-2.6.15-git12/drivers/media/video/tvp5150.c linux-2.6.16-rc1/drivers/media/video/tvp5150.c
--- linux-2.6.15-git12/drivers/media/video/tvp5150.c	2006-01-17 08:21:33.096717763 +0000
+++ linux-2.6.16-rc1/drivers/media/video/tvp5150.c	2006-01-17 08:22:47.286360655 +0000
@@ -634,7 +634,7 @@ struct i2c_vbi_ram_value {
 	unsigned char values[26];
 };
 
-struct i2c_vbi_ram_value vbi_ram_default[] =
+static struct i2c_vbi_ram_value vbi_ram_default[] =
 {
 	{0x010, /* WST SECAM 6 */
 		{ 0xaa, 0xaa, 0xff, 0xff , 0xe7, 0x2e, 0x20, 0x26, 0xe6, 0xb4, 0x0e, 0x0, 0x0, 0x0, 0x10, 0x0 }
diff -purN linux-2.6.15-git12/drivers/media/video/v4l2-common.c linux-2.6.16-rc1/drivers/media/video/v4l2-common.c
--- linux-2.6.15-git12/drivers/media/video/v4l2-common.c	2006-01-17 08:21:33.105716347 +0000
+++ linux-2.6.16-rc1/drivers/media/video/v4l2-common.c	2006-01-17 08:22:47.295359238 +0000
@@ -306,6 +306,7 @@ static const char *v4l2_int_ioctls[] = {
 #endif
 	[_IOC_NR(AUDC_SET_RADIO)]              = "AUDC_SET_RADIO",
 	[_IOC_NR(AUDC_SET_INPUT)]              = "AUDC_SET_INPUT",
+	[_IOC_NR(MSP_SET_MATRIX)]              = "MSP_SET_MATRIX",
 
 	[_IOC_NR(TUNER_SET_TYPE_ADDR)]         = "TUNER_SET_TYPE_ADDR",
 	[_IOC_NR(TUNER_SET_STANDBY)]           = "TUNER_SET_STANDBY",
diff -purN linux-2.6.15-git12/drivers/media/video/videodev.c linux-2.6.16-rc1/drivers/media/video/videodev.c
--- linux-2.6.15-git12/drivers/media/video/videodev.c	2006-01-17 08:21:33.111715402 +0000
+++ linux-2.6.16-rc1/drivers/media/video/videodev.c	2006-01-17 08:22:47.302358136 +0000
@@ -29,7 +29,6 @@
 #include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
-#include <asm/semaphore.h>
 
 #include <linux/videodev.h>
 
@@ -83,7 +82,7 @@ static struct class video_class = {
  */
 
 static struct video_device *video_device[VIDEO_NUM_DEVICES];
-static DECLARE_MUTEX(videodev_lock);
+static DEFINE_MUTEX(videodev_lock);
 
 struct video_device* video_devdata(struct file *file)
 {
@@ -102,15 +101,15 @@ static int video_open(struct inode *inod
 
 	if(minor>=VIDEO_NUM_DEVICES)
 		return -ENODEV;
-	down(&videodev_lock);
+	mutex_lock(&videodev_lock);
 	vfl=video_device[minor];
 	if(vfl==NULL) {
-		up(&videodev_lock);
+		mutex_unlock(&videodev_lock);
 		request_module("char-major-%d-%d", VIDEO_MAJOR, minor);
-		down(&videodev_lock);
+		mutex_lock(&videodev_lock);
 		vfl=video_device[minor];
 		if (vfl==NULL) {
-			up(&videodev_lock);
+			mutex_unlock(&videodev_lock);
 			return -ENODEV;
 		}
 	}
@@ -123,7 +122,7 @@ static int video_open(struct inode *inod
 		file->f_op = fops_get(old_fops);
 	}
 	fops_put(old_fops);
-	up(&videodev_lock);
+	mutex_unlock(&videodev_lock);
 	return err;
 }
 
@@ -304,12 +303,12 @@ int video_register_device(struct video_d
 	}
 
 	/* pick a minor number */
-	down(&videodev_lock);
+	mutex_lock(&videodev_lock);
 	if (nr >= 0  &&  nr < end-base) {
 		/* use the one the driver asked for */
 		i = base+nr;
 		if (NULL != video_device[i]) {
-			up(&videodev_lock);
+			mutex_unlock(&videodev_lock);
 			return -ENFILE;
 		}
 	} else {
@@ -318,13 +317,13 @@ int video_register_device(struct video_d
 			if (NULL == video_device[i])
 				break;
 		if (i == end) {
-			up(&videodev_lock);
+			mutex_unlock(&videodev_lock);
 			return -ENFILE;
 		}
 	}
 	video_device[i]=vfd;
 	vfd->minor=i;
-	up(&videodev_lock);
+	mutex_unlock(&videodev_lock);
 
 	sprintf(vfd->devfs_name, "v4l/%s%d", name_base, i - base);
 	devfs_mk_cdev(MKDEV(VIDEO_MAJOR, vfd->minor),
@@ -362,14 +361,14 @@ int video_register_device(struct video_d
 
 void video_unregister_device(struct video_device *vfd)
 {
-	down(&videodev_lock);
+	mutex_lock(&videodev_lock);
 	if(video_device[vfd->minor]!=vfd)
 		panic("videodev: bad unregister");
 
 	devfs_remove(vfd->devfs_name);
 	video_device[vfd->minor]=NULL;
 	class_device_unregister(&vfd->class_dev);
-	up(&videodev_lock);
+	mutex_unlock(&videodev_lock);
 }
 
 
diff -purN linux-2.6.15-git12/drivers/mtd/chips/Kconfig linux-2.6.16-rc1/drivers/mtd/chips/Kconfig
--- linux-2.6.15-git12/drivers/mtd/chips/Kconfig	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/mtd/chips/Kconfig	2006-01-17 08:22:47.553457528 +0000
@@ -31,6 +31,7 @@ config MTD_JEDECPROBE
 
 config MTD_GEN_PROBE
 	tristate
+	select OBSOLETE_INTERMODULE
 
 config MTD_CFI_ADV_OPTIONS
 	bool "Flash chip driver advanced configuration options"
@@ -259,7 +260,7 @@ config MTD_ABSENT
 	  with this driver will return -ENODEV upon access.
 
 config MTD_OBSOLETE_CHIPS
-	depends on MTD && BROKEN
+	depends on MTD
 	bool "Older (theoretically obsoleted now) drivers for non-CFI chips"
 	help
 	  This option does not enable any code directly, but will allow you to
@@ -272,7 +273,7 @@ config MTD_OBSOLETE_CHIPS
 
 config MTD_AMDSTD
 	tristate "AMD compatible flash chip support (non-CFI)"
-	depends on MTD && MTD_OBSOLETE_CHIPS
+	depends on MTD && MTD_OBSOLETE_CHIPS && BROKEN
 	help
 	  This option enables support for flash chips using AMD-compatible
 	  commands, including some which are not CFI-compatible and hence
@@ -290,7 +291,7 @@ config MTD_SHARP
 
 config MTD_JEDEC
 	tristate "JEDEC device support"
-	depends on MTD && MTD_OBSOLETE_CHIPS
+	depends on MTD && MTD_OBSOLETE_CHIPS && BROKEN
 	help
 	  Enable older older JEDEC flash interface devices for self
 	  programming flash.  It is commonly used in older AMD chips.  It is
diff -purN linux-2.6.15-git12/drivers/mtd/devices/Kconfig linux-2.6.16-rc1/drivers/mtd/devices/Kconfig
--- linux-2.6.15-git12/drivers/mtd/devices/Kconfig	2006-01-17 08:21:33.374807745 +0000
+++ linux-2.6.16-rc1/drivers/mtd/devices/Kconfig	2006-01-17 08:22:47.555457213 +0000
@@ -218,6 +218,7 @@ config MTD_DOC2001PLUS
 config MTD_DOCPROBE
 	tristate
 	select MTD_DOCECC
+	select OBSOLETE_INTERMODULE
 
 config MTD_DOCECC
 	tristate
diff -purN linux-2.6.15-git12/drivers/net/cs89x0.c linux-2.6.16-rc1/drivers/net/cs89x0.c
--- linux-2.6.15-git12/drivers/net/cs89x0.c	2006-01-17 08:21:33.525783974 +0000
+++ linux-2.6.16-rc1/drivers/net/cs89x0.c	2006-01-17 08:22:47.713432340 +0000
@@ -93,6 +93,9 @@
   Deepak Saxena     : dsaxena@plexity.net
                     : Intel IXDP2351 platform support
 
+  Dmitry Pervushin  : dpervushin@ru.mvista.com
+                    : PNX010X platform support
+
 */
 
 /* Always include 'config.h' first in case the user wants to turn on
diff -purN linux-2.6.15-git12/drivers/video/sbuslib.c linux-2.6.16-rc1/drivers/video/sbuslib.c
--- linux-2.6.15-git12/drivers/video/sbuslib.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/video/sbuslib.c	2006-01-17 08:22:51.141418989 +0000
@@ -216,10 +216,10 @@ static int fbiogetputcmap(struct file *f
 	ret |= put_user(compat_ptr(addr), &p->blue);
 	if (ret)
 		return -EFAULT;
-	return info->fbops->fb_ioctl(file->f_dentry->d_inode, file,
+	return info->fbops->fb_ioctl(info,
 			(cmd == FBIOPUTCMAP32) ?
 			FBIOPUTCMAP_SPARC : FBIOGETCMAP_SPARC,
-			(unsigned long)p, info);
+			(unsigned long)p);
 }
 
 struct fbcursor32 {
@@ -260,12 +260,11 @@ static int fbiogscursor(struct file *fil
 	ret |= put_user(compat_ptr(addr), &p->image);
 	if (ret)
 		return -EFAULT;
-	return info->fbops->fb_ioctl(file->f_dentry->d_inode, file,
-			FBIOSCURSOR, (unsigned long)p, info);
+	return info->fbops->fb_ioctl(info, FBIOSCURSOR, (unsigned long)p);
 }
 
-long sbusfb_compat_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg, struct fb_info *info)
+long sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long arg)
 {
 	switch (cmd) {
 	case FBIOGTYPE:
@@ -278,14 +277,13 @@ long sbusfb_compat_ioctl(struct file *fi
 	case FBIOSCURPOS:
 	case FBIOGCURPOS:
 	case FBIOGCURMAX:
-		return info->fbops->fb_ioctl(file->f_dentry->d_inode,
-				file, cmd, arg, info);
+		return info->fbops->fb_ioctl(info, cmd, arg);
 	case FBIOPUTCMAP32:
-		return fbiogetputcmap(file, info, cmd, arg);
+		return fbiogetputcmap(info, cmd, arg);
 	case FBIOGETCMAP32:
-		return fbiogetputcmap(file, info, cmd, arg);
+		return fbiogetputcmap(info, cmd, arg);
 	case FBIOSCURSOR32:
-		return fbiogscursor(file, info, arg);
+		return fbiogscursor(info, arg);
 	default:
 		return -ENOIOCTLCMD;
 	}
diff -purN linux-2.6.15-git12/drivers/video/sbuslib.h linux-2.6.16-rc1/drivers/video/sbuslib.h
--- linux-2.6.15-git12/drivers/video/sbuslib.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/drivers/video/sbuslib.h	2006-01-17 08:22:51.142418832 +0000
@@ -20,7 +20,7 @@ extern int sbusfb_mmap_helper(struct sbu
 int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
 			struct fb_info *info,
 			int type, int fb_depth, unsigned long fb_size);
-long sbusfb_compat_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg, struct fb_info *info);
+long sbusfb_compat_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long arg);
 
 #endif /* _SBUSLIB_H */
diff -purN linux-2.6.15-git12/fs/buffer.c linux-2.6.16-rc1/fs/buffer.c
--- linux-2.6.15-git12/fs/buffer.c	2006-01-17 08:21:36.823796090 +0000
+++ linux-2.6.16-rc1/fs/buffer.c	2006-01-17 08:22:51.319390967 +0000
@@ -1027,7 +1027,7 @@ try_again:
 		/* Link the buffer to its page */
 		set_bh_page(bh, page, offset);
 
-		bh->b_end_io = NULL;
+		init_buffer(bh, NULL, NULL);
 	}
 	return head;
 /*
diff -purN linux-2.6.15-git12/fs/fuse/dev.c linux-2.6.16-rc1/fs/fuse/dev.c
--- linux-2.6.15-git12/fs/fuse/dev.c	2006-01-17 08:21:36.990769800 +0000
+++ linux-2.6.16-rc1/fs/fuse/dev.c	2006-01-17 08:22:51.477366094 +0000
@@ -21,18 +21,18 @@ MODULE_ALIAS_MISCDEV(FUSE_MINOR);
 
 static kmem_cache_t *fuse_req_cachep;
 
-static inline struct fuse_conn *fuse_get_conn(struct file *file)
+static struct fuse_conn *fuse_get_conn(struct file *file)
 {
 	struct fuse_conn *fc;
 	spin_lock(&fuse_lock);
 	fc = file->private_data;
-	if (fc && !fc->mounted)
+	if (fc && !fc->connected)
 		fc = NULL;
 	spin_unlock(&fuse_lock);
 	return fc;
 }
 
-static inline void fuse_request_init(struct fuse_req *req)
+static void fuse_request_init(struct fuse_req *req)
 {
 	memset(req, 0, sizeof(*req));
 	INIT_LIST_HEAD(&req->list);
@@ -53,7 +53,7 @@ void fuse_request_free(struct fuse_req *
 	kmem_cache_free(fuse_req_cachep, req);
 }
 
-static inline void block_sigs(sigset_t *oldset)
+static void block_sigs(sigset_t *oldset)
 {
 	sigset_t mask;
 
@@ -61,7 +61,7 @@ static inline void block_sigs(sigset_t *
 	sigprocmask(SIG_BLOCK, &mask, oldset);
 }
 
-static inline void restore_sigs(sigset_t *oldset)
+static void restore_sigs(sigset_t *oldset)
 {
 	sigprocmask(SIG_SETMASK, oldset, NULL);
 }
@@ -109,18 +109,24 @@ struct fuse_req *fuse_get_request(struct
 	int intr;
 	sigset_t oldset;
 
+	atomic_inc(&fc->num_waiting);
 	block_sigs(&oldset);
 	intr = down_interruptible(&fc->outstanding_sem);
 	restore_sigs(&oldset);
-	return intr ? NULL : do_get_request(fc);
+	if (intr) {
+		atomic_dec(&fc->num_waiting);
+		return NULL;
+	}
+	return do_get_request(fc);
 }
 
 static void fuse_putback_request(struct fuse_conn *fc, struct fuse_req *req)
 {
 	spin_lock(&fuse_lock);
-	if (req->preallocated)
+	if (req->preallocated) {
+		atomic_dec(&fc->num_waiting);
 		list_add(&req->list, &fc->unused_list);
-	else
+	} else
 		fuse_request_free(req);
 
 	/* If we are in debt decrease that first */
@@ -148,42 +154,23 @@ void fuse_release_background(struct fuse
 	spin_unlock(&fuse_lock);
 }
 
-static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
-{
-	int i;
-	struct fuse_init_out *arg = &req->misc.init_out;
-
-	if (arg->major != FUSE_KERNEL_VERSION)
-		fc->conn_error = 1;
-	else {
-		fc->minor = arg->minor;
-		fc->max_write = arg->minor < 5 ? 4096 : arg->max_write;
-	}
-
-	/* After INIT reply is received other requests can go
-	   out.  So do (FUSE_MAX_OUTSTANDING - 1) number of
-	   up()s on outstanding_sem.  The last up() is done in
-	   fuse_putback_request() */
-	for (i = 1; i < FUSE_MAX_OUTSTANDING; i++)
-		up(&fc->outstanding_sem);
-}
-
 /*
  * This function is called when a request is finished.  Either a reply
  * has arrived or it was interrupted (and not yet sent) or some error
- * occurred during communication with userspace, or the device file was
- * closed.  It decreases the reference count for the request.  In case
- * of a background request the reference to the stored objects are
- * released.  The requester thread is woken up (if still waiting), and
- * finally the request is either freed or put on the unused_list
+ * occurred during communication with userspace, or the device file
+ * was closed.  In case of a background request the reference to the
+ * stored objects are released.  The requester thread is woken up (if
+ * still waiting), the 'end' callback is called if given, else the
+ * reference to the request is released
  *
  * Called with fuse_lock, unlocks it
  */
 static void request_end(struct fuse_conn *fc, struct fuse_req *req)
 {
-	int putback;
-	req->finished = 1;
-	putback = atomic_dec_and_test(&req->count);
+	void (*end) (struct fuse_conn *, struct fuse_req *) = req->end;
+	req->end = NULL;
+	list_del(&req->list);
+	req->state = FUSE_REQ_FINISHED;
 	spin_unlock(&fuse_lock);
 	if (req->background) {
 		down_read(&fc->sbput_sem);
@@ -192,18 +179,10 @@ static void request_end(struct fuse_conn
 		up_read(&fc->sbput_sem);
 	}
 	wake_up(&req->waitq);
-	if (req->in.h.opcode == FUSE_INIT)
-		process_init_reply(fc, req);
-	else if (req->in.h.opcode == FUSE_RELEASE && req->inode == NULL) {
-		/* Special case for failed iget in CREATE */
-		u64 nodeid = req->in.h.nodeid;
-		__fuse_get_request(req);
-		fuse_reset_request(req);
-		fuse_send_forget(fc, req, nodeid, 1);
-		putback = 0;
-	}
-	if (putback)
-		fuse_putback_request(fc, req);
+	if (end)
+		end(fc, req);
+	else
+		fuse_put_request(fc, req);
 }
 
 /*
@@ -254,14 +233,16 @@ static void request_wait_answer(struct f
 
 	spin_unlock(&fuse_lock);
 	block_sigs(&oldset);
-	wait_event_interruptible(req->waitq, req->finished);
+	wait_event_interruptible(req->waitq, req->state == FUSE_REQ_FINISHED);
 	restore_sigs(&oldset);
 	spin_lock(&fuse_lock);
-	if (req->finished)
+	if (req->state == FUSE_REQ_FINISHED && !req->interrupted)
 		return;
 
-	req->out.h.error = -EINTR;
-	req->interrupted = 1;
+	if (!req->interrupted) {
+		req->out.h.error = -EINTR;
+		req->interrupted = 1;
+	}
 	if (req->locked) {
 		/* This is uninterruptible sleep, because data is
 		   being copied to/from the buffers of req.  During
@@ -272,10 +253,10 @@ static void request_wait_answer(struct f
 		wait_event(req->waitq, !req->locked);
 		spin_lock(&fuse_lock);
 	}
-	if (!req->sent && !list_empty(&req->list)) {
+	if (req->state == FUSE_REQ_PENDING) {
 		list_del(&req->list);
 		__fuse_put_request(req);
-	} else if (!req->finished && req->sent)
+	} else if (req->state == FUSE_REQ_SENT)
 		background_request(fc, req);
 }
 
@@ -310,6 +291,7 @@ static void queue_request(struct fuse_co
 			fc->outstanding_debt++;
 	}
 	list_add_tail(&req->list, &fc->pending);
+	req->state = FUSE_REQ_PENDING;
 	wake_up(&fc->waitq);
 }
 
@@ -362,34 +344,12 @@ void request_send_background(struct fuse
 	request_send_nowait(fc, req);
 }
 
-void fuse_send_init(struct fuse_conn *fc)
-{
-	/* This is called from fuse_read_super() so there's guaranteed
-	   to be a request available */
-	struct fuse_req *req = do_get_request(fc);
-	struct fuse_init_in *arg = &req->misc.init_in;
-	arg->major = FUSE_KERNEL_VERSION;
-	arg->minor = FUSE_KERNEL_MINOR_VERSION;
-	req->in.h.opcode = FUSE_INIT;
-	req->in.numargs = 1;
-	req->in.args[0].size = sizeof(*arg);
-	req->in.args[0].value = arg;
-	req->out.numargs = 1;
-	/* Variable length arguement used for backward compatibility
-	   with interface version < 7.5.  Rest of init_out is zeroed
-	   by do_get_request(), so a short reply is not a problem */
-	req->out.argvar = 1;
-	req->out.args[0].size = sizeof(struct fuse_init_out);
-	req->out.args[0].value = &req->misc.init_out;
-	request_send_background(fc, req);
-}
-
 /*
  * Lock the request.  Up to the next unlock_request() there mustn't be
  * anything that could cause a page-fault.  If the request was already
  * interrupted bail out.
  */
-static inline int lock_request(struct fuse_req *req)
+static int lock_request(struct fuse_req *req)
 {
 	int err = 0;
 	if (req) {
@@ -408,7 +368,7 @@ static inline int lock_request(struct fu
  * requester thread is currently waiting for it to be unlocked, so
  * wake it up.
  */
-static inline void unlock_request(struct fuse_req *req)
+static void unlock_request(struct fuse_req *req)
 {
 	if (req) {
 		spin_lock(&fuse_lock);
@@ -444,7 +404,7 @@ static void fuse_copy_init(struct fuse_c
 }
 
 /* Unmap and put previous page of userspace buffer */
-static inline void fuse_copy_finish(struct fuse_copy_state *cs)
+static void fuse_copy_finish(struct fuse_copy_state *cs)
 {
 	if (cs->mapaddr) {
 		kunmap_atomic(cs->mapaddr, KM_USER0);
@@ -493,8 +453,7 @@ static int fuse_copy_fill(struct fuse_co
 }
 
 /* Do as much copy to/from userspace buffer as we can */
-static inline int fuse_copy_do(struct fuse_copy_state *cs, void **val,
-			       unsigned *size)
+static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size)
 {
 	unsigned ncpy = min(*size, cs->len);
 	if (val) {
@@ -514,8 +473,8 @@ static inline int fuse_copy_do(struct fu
  * Copy a page in the request to/from the userspace buffer.  Must be
  * done atomically
  */
-static inline int fuse_copy_page(struct fuse_copy_state *cs, struct page *page,
-				 unsigned offset, unsigned count, int zeroing)
+static int fuse_copy_page(struct fuse_copy_state *cs, struct page *page,
+			  unsigned offset, unsigned count, int zeroing)
 {
 	if (page && zeroing && count < PAGE_SIZE) {
 		void *mapaddr = kmap_atomic(page, KM_USER1);
@@ -597,7 +556,7 @@ static void request_wait(struct fuse_con
 	DECLARE_WAITQUEUE(wait, current);
 
 	add_wait_queue_exclusive(&fc->waitq, &wait);
-	while (fc->mounted && list_empty(&fc->pending)) {
+	while (fc->connected && list_empty(&fc->pending)) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (signal_pending(current))
 			break;
@@ -637,14 +596,15 @@ static ssize_t fuse_dev_readv(struct fil
 		goto err_unlock;
 	request_wait(fc);
 	err = -ENODEV;
-	if (!fc->mounted)
+	if (!fc->connected)
 		goto err_unlock;
 	err = -ERESTARTSYS;
 	if (list_empty(&fc->pending))
 		goto err_unlock;
 
 	req = list_entry(fc->pending.next, struct fuse_req, list);
-	list_del_init(&req->list);
+	req->state = FUSE_REQ_READING;
+	list_move(&req->list, &fc->io);
 
 	in = &req->in;
 	reqsize = in->h.len;
@@ -677,8 +637,8 @@ static ssize_t fuse_dev_readv(struct fil
 	if (!req->isreply)
 		request_end(fc, req);
 	else {
-		req->sent = 1;
-		list_add_tail(&req->list, &fc->processing);
+		req->state = FUSE_REQ_SENT;
+		list_move_tail(&req->list, &fc->processing);
 		spin_unlock(&fuse_lock);
 	}
 	return reqsize;
@@ -766,17 +726,23 @@ static ssize_t fuse_dev_writev(struct fi
 		goto err_finish;
 
 	spin_lock(&fuse_lock);
+	err = -ENOENT;
+	if (!fc->connected)
+		goto err_unlock;
+
 	req = request_find(fc, oh.unique);
 	err = -EINVAL;
 	if (!req)
 		goto err_unlock;
 
-	list_del_init(&req->list);
 	if (req->interrupted) {
-		request_end(fc, req);
+		spin_unlock(&fuse_lock);
 		fuse_copy_finish(&cs);
+		spin_lock(&fuse_lock);
+		request_end(fc, req);
 		return -ENOENT;
 	}
+	list_move(&req->list, &fc->io);
 	req->out.h = oh;
 	req->locked = 1;
 	cs.req = req;
@@ -830,19 +796,90 @@ static unsigned fuse_dev_poll(struct fil
 	return mask;
 }
 
-/* Abort all requests on the given list (pending or processing) */
+/*
+ * Abort all requests on the given list (pending or processing)
+ *
+ * This function releases and reacquires fuse_lock
+ */
 static void end_requests(struct fuse_conn *fc, struct list_head *head)
 {
 	while (!list_empty(head)) {
 		struct fuse_req *req;
 		req = list_entry(head->next, struct fuse_req, list);
-		list_del_init(&req->list);
 		req->out.h.error = -ECONNABORTED;
 		request_end(fc, req);
 		spin_lock(&fuse_lock);
 	}
 }
 
+/*
+ * Abort requests under I/O
+ *
+ * The requests are set to interrupted and finished, and the request
+ * waiter is woken up.  This will make request_wait_answer() wait
+ * until the request is unlocked and then return.
+ *
+ * If the request is asynchronous, then the end function needs to be
+ * called after waiting for the request to be unlocked (if it was
+ * locked).
+ */
+static void end_io_requests(struct fuse_conn *fc)
+{
+	while (!list_empty(&fc->io)) {
+		struct fuse_req *req =
+			list_entry(fc->io.next, struct fuse_req, list);
+		void (*end) (struct fuse_conn *, struct fuse_req *) = req->end;
+
+		req->interrupted = 1;
+		req->out.h.error = -ECONNABORTED;
+		req->state = FUSE_REQ_FINISHED;
+		list_del_init(&req->list);
+		wake_up(&req->waitq);
+		if (end) {
+			req->end = NULL;
+			/* The end function will consume this reference */
+			__fuse_get_request(req);
+			spin_unlock(&fuse_lock);
+			wait_event(req->waitq, !req->locked);
+			end(fc, req);
+			spin_lock(&fuse_lock);
+		}
+	}
+}
+
+/*
+ * Abort all requests.
+ *
+ * Emergency exit in case of a malicious or accidental deadlock, or
+ * just a hung filesystem.
+ *
+ * The same effect is usually achievable through killing the
+ * filesystem daemon and all users of the filesystem.  The exception
+ * is the combination of an asynchronous request and the tricky
+ * deadlock (see Documentation/filesystems/fuse.txt).
+ *
+ * During the aborting, progression of requests from the pending and
+ * processing lists onto the io list, and progression of new requests
+ * onto the pending list is prevented by req->connected being false.
+ *
+ * Progression of requests under I/O to the processing list is
+ * prevented by the req->interrupted flag being true for these
+ * requests.  For this reason requests on the io list must be aborted
+ * first.
+ */
+void fuse_abort_conn(struct fuse_conn *fc)
+{
+	spin_lock(&fuse_lock);
+	if (fc->connected) {
+		fc->connected = 0;
+		end_io_requests(fc);
+		end_requests(fc, &fc->pending);
+		end_requests(fc, &fc->processing);
+		wake_up_all(&fc->waitq);
+	}
+	spin_unlock(&fuse_lock);
+}
+
 static int fuse_dev_release(struct inode *inode, struct file *file)
 {
 	struct fuse_conn *fc;
@@ -853,9 +890,11 @@ static int fuse_dev_release(struct inode
 		fc->connected = 0;
 		end_requests(fc, &fc->pending);
 		end_requests(fc, &fc->processing);
-		fuse_release_conn(fc);
 	}
 	spin_unlock(&fuse_lock);
+	if (fc)
+		kobject_put(&fc->kobj);
+
 	return 0;
 }
 
diff -purN linux-2.6.15-git12/fs/fuse/dir.c linux-2.6.16-rc1/fs/fuse/dir.c
--- linux-2.6.15-git12/fs/fuse/dir.c	2006-01-17 08:21:36.998768540 +0000
+++ linux-2.6.16-rc1/fs/fuse/dir.c	2006-01-17 08:22:51.485364834 +0000
@@ -23,8 +23,7 @@
 /*
  * Calculate the time in jiffies until a dentry/attributes are valid
  */
-static inline unsigned long time_to_jiffies(unsigned long sec,
-					    unsigned long nsec)
+static unsigned long time_to_jiffies(unsigned long sec, unsigned long nsec)
 {
 	struct timespec ts = {sec, nsec};
 	return jiffies + timespec_to_jiffies(&ts);
@@ -157,7 +156,7 @@ static int dir_alias(struct inode *inode
 	return 0;
 }
 
-static inline int invalid_nodeid(u64 nodeid)
+static int invalid_nodeid(u64 nodeid)
 {
 	return !nodeid || nodeid == FUSE_ROOT_ID;
 }
@@ -166,7 +165,7 @@ static struct dentry_operations fuse_den
 	.d_revalidate	= fuse_dentry_revalidate,
 };
 
-static inline int valid_mode(int m)
+static int valid_mode(int m)
 {
 	return S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||
 		S_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);
@@ -763,13 +762,6 @@ static int parse_dirfile(char *buf, size
 	return 0;
 }
 
-static inline size_t fuse_send_readdir(struct fuse_req *req, struct file *file,
-				       struct inode *inode, loff_t pos,
-				       size_t count)
-{
-	return fuse_send_read_common(req, file, inode, pos, count, 1);
-}
-
 static int fuse_readdir(struct file *file, void *dstbuf, filldir_t filldir)
 {
 	int err;
@@ -793,7 +785,9 @@ static int fuse_readdir(struct file *fil
 	}
 	req->num_pages = 1;
 	req->pages[0] = page;
-	nbytes = fuse_send_readdir(req, file, inode, file->f_pos, PAGE_SIZE);
+	fuse_read_fill(req, file, inode, file->f_pos, PAGE_SIZE, FUSE_READDIR);
+	request_send(fc, req);
+	nbytes = req->out.args[0].size;
 	err = req->out.h.error;
 	fuse_put_request(fc, req);
 	if (!err)
diff -purN linux-2.6.15-git12/fs/fuse/file.c linux-2.6.16-rc1/fs/fuse/file.c
--- linux-2.6.15-git12/fs/fuse/file.c	2006-01-17 08:21:37.001768068 +0000
+++ linux-2.6.16-rc1/fs/fuse/file.c	2006-01-17 08:22:51.489364205 +0000
@@ -113,6 +113,14 @@ int fuse_open_common(struct inode *inode
 	return err;
 }
 
+/* Special case for failed iget in CREATE */
+static void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	u64 nodeid = req->in.h.nodeid;
+	fuse_reset_request(req);
+	fuse_send_forget(fc, req, nodeid, 1);
+}
+
 void fuse_send_release(struct fuse_conn *fc, struct fuse_file *ff,
 		       u64 nodeid, struct inode *inode, int flags, int isdir)
 {
@@ -128,6 +136,8 @@ void fuse_send_release(struct fuse_conn 
 	req->in.args[0].size = sizeof(struct fuse_release_in);
 	req->in.args[0].value = inarg;
 	request_send_background(fc, req);
+	if (!inode)
+		req->end = fuse_release_end;
 	kfree(ff);
 }
 
@@ -240,38 +250,35 @@ static int fuse_fsync(struct file *file,
 	return fuse_fsync_common(file, de, datasync, 0);
 }
 
-size_t fuse_send_read_common(struct fuse_req *req, struct file *file,
-			     struct inode *inode, loff_t pos, size_t count,
-			     int isdir)
+void fuse_read_fill(struct fuse_req *req, struct file *file,
+		    struct inode *inode, loff_t pos, size_t count, int opcode)
 {
-	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_file *ff = file->private_data;
-	struct fuse_read_in inarg;
+	struct fuse_read_in *inarg = &req->misc.read_in;
 
-	memset(&inarg, 0, sizeof(struct fuse_read_in));
-	inarg.fh = ff->fh;
-	inarg.offset = pos;
-	inarg.size = count;
-	req->in.h.opcode = isdir ? FUSE_READDIR : FUSE_READ;
+	inarg->fh = ff->fh;
+	inarg->offset = pos;
+	inarg->size = count;
+	req->in.h.opcode = opcode;
 	req->in.h.nodeid = get_node_id(inode);
 	req->inode = inode;
 	req->file = file;
 	req->in.numargs = 1;
 	req->in.args[0].size = sizeof(struct fuse_read_in);
-	req->in.args[0].value = &inarg;
+	req->in.args[0].value = inarg;
 	req->out.argpages = 1;
 	req->out.argvar = 1;
 	req->out.numargs = 1;
 	req->out.args[0].size = count;
-	request_send(fc, req);
-	return req->out.args[0].size;
 }
 
-static inline size_t fuse_send_read(struct fuse_req *req, struct file *file,
-				    struct inode *inode, loff_t pos,
-				    size_t count)
+static size_t fuse_send_read(struct fuse_req *req, struct file *file,
+			     struct inode *inode, loff_t pos, size_t count)
 {
-	return fuse_send_read_common(req, file, inode, pos, count, 0);
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	fuse_read_fill(req, file, inode, pos, count, FUSE_READ);
+	request_send(fc, req);
+	return req->out.args[0].size;
 }
 
 static int fuse_readpage(struct file *file, struct page *page)
@@ -304,21 +311,33 @@ static int fuse_readpage(struct file *fi
 	return err;
 }
 
-static int fuse_send_readpages(struct fuse_req *req, struct file *file,
-			       struct inode *inode)
+static void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)
 {
-	loff_t pos = page_offset(req->pages[0]);
-	size_t count = req->num_pages << PAGE_CACHE_SHIFT;
-	unsigned i;
-	req->out.page_zeroing = 1;
-	fuse_send_read(req, file, inode, pos, count);
+	int i;
+
+	fuse_invalidate_attr(req->pages[0]->mapping->host); /* atime changed */
+
 	for (i = 0; i < req->num_pages; i++) {
 		struct page *page = req->pages[i];
 		if (!req->out.h.error)
 			SetPageUptodate(page);
+		else
+			SetPageError(page);
 		unlock_page(page);
 	}
-	return req->out.h.error;
+	fuse_put_request(fc, req);
+}
+
+static void fuse_send_readpages(struct fuse_req *req, struct file *file,
+				struct inode *inode)
+{
+	struct fuse_conn *fc = get_fuse_conn(inode);
+	loff_t pos = page_offset(req->pages[0]);
+	size_t count = req->num_pages << PAGE_CACHE_SHIFT;
+	req->out.page_zeroing = 1;
+	req->end = fuse_readpages_end;
+	fuse_read_fill(req, file, inode, pos, count, FUSE_READ);
+	request_send_background(fc, req);
 }
 
 struct fuse_readpages_data {
@@ -338,12 +357,12 @@ static int fuse_readpages_fill(void *_da
 	    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||
 	     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||
 	     req->pages[req->num_pages - 1]->index + 1 != page->index)) {
-		int err = fuse_send_readpages(req, data->file, inode);
-		if (err) {
+		fuse_send_readpages(req, data->file, inode);
+		data->req = req = fuse_get_request(fc);
+		if (!req) {
 			unlock_page(page);
-			return err;
+			return -EINTR;
 		}
-		fuse_reset_request(req);
 	}
 	req->pages[req->num_pages] = page;
 	req->num_pages ++;
@@ -368,10 +387,8 @@ static int fuse_readpages(struct file *f
 		return -EINTR;
 
 	err = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);
-	if (!err && data.req->num_pages)
-		err = fuse_send_readpages(data.req, file, inode);
-	fuse_put_request(fc, data.req);
-	fuse_invalidate_attr(inode); /* atime changed */
+	if (!err)
+		fuse_send_readpages(data.req, file, inode);
 	return err;
 }
 
diff -purN linux-2.6.15-git12/fs/fuse/fuse_i.h linux-2.6.16-rc1/fs/fuse/fuse_i.h
--- linux-2.6.15-git12/fs/fuse/fuse_i.h	2006-01-17 08:21:37.002767911 +0000
+++ linux-2.6.16-rc1/fs/fuse/fuse_i.h	2006-01-17 08:22:51.493363575 +0000
@@ -94,6 +94,11 @@ struct fuse_out {
 	/** Header returned from userspace */
 	struct fuse_out_header h;
 
+	/*
+	 * The following bitfields are not changed during the request
+	 * processing
+	 */
+
 	/** Last argument is variable length (can be shorter than
 	    arg->size) */
 	unsigned argvar:1;
@@ -111,12 +116,23 @@ struct fuse_out {
 	struct fuse_arg args[3];
 };
 
+/** The request state */
+enum fuse_req_state {
+	FUSE_REQ_INIT = 0,
+	FUSE_REQ_PENDING,
+	FUSE_REQ_READING,
+	FUSE_REQ_SENT,
+	FUSE_REQ_FINISHED
+};
+
+struct fuse_conn;
+
 /**
  * A request to the client
  */
 struct fuse_req {
-	/** This can be on either unused_list, pending or processing
-	    lists in fuse_conn */
+	/** This can be on either unused_list, pending processing or
+	    io lists in fuse_conn */
 	struct list_head list;
 
 	/** Entry on the background list */
@@ -125,6 +141,12 @@ struct fuse_req {
 	/** refcount */
 	atomic_t count;
 
+	/*
+	 * The following bitfields are either set once before the
+	 * request is queued or setting/clearing them is protected by
+	 * fuse_lock
+	 */
+
 	/** True if the request has reply */
 	unsigned isreply:1;
 
@@ -140,11 +162,8 @@ struct fuse_req {
 	/** Data is being copied to/from the request */
 	unsigned locked:1;
 
-	/** Request has been sent to userspace */
-	unsigned sent:1;
-
-	/** The request is finished */
-	unsigned finished:1;
+	/** State of the request */
+	enum fuse_req_state state;
 
 	/** The request input */
 	struct fuse_in in;
@@ -161,6 +180,7 @@ struct fuse_req {
 		struct fuse_release_in release_in;
 		struct fuse_init_in init_in;
 		struct fuse_init_out init_out;
+		struct fuse_read_in read_in;
 	} misc;
 
 	/** page vector */
@@ -180,6 +200,9 @@ struct fuse_req {
 
 	/** File used in the request (or NULL) */
 	struct file *file;
+
+	/** Request completion callback */
+	void (*end)(struct fuse_conn *, struct fuse_req *);
 };
 
 /**
@@ -190,9 +213,6 @@ struct fuse_req {
  * unmounted.
  */
 struct fuse_conn {
-	/** Reference count */
-	int count;
-
 	/** The user id for this mount */
 	uid_t user_id;
 
@@ -217,6 +237,9 @@ struct fuse_conn {
 	/** The list of requests being processed */
 	struct list_head processing;
 
+	/** The list of requests under I/O */
+	struct list_head io;
+
 	/** Requests put in the background (RELEASE or any other
 	    interrupted request) */
 	struct list_head background;
@@ -238,14 +261,22 @@ struct fuse_conn {
 	u64 reqctr;
 
 	/** Mount is active */
-	unsigned mounted : 1;
-
-	/** Connection established */
-	unsigned connected : 1;
+	unsigned mounted;
 
-	/** Connection failed (version mismatch) */
+	/** Connection established, cleared on umount, connection
+	    abort and device release */
+	unsigned connected;
+
+	/** Connection failed (version mismatch).  Cannot race with
+	    setting other bitfields since it is only set once in INIT
+	    reply, before any other request, and never cleared */
 	unsigned conn_error : 1;
 
+	/*
+	 * The following bitfields are only for optimization purposes
+	 * and hence races in setting them will not cause malfunction
+	 */
+
 	/** Is fsync not implemented by fs? */
 	unsigned no_fsync : 1;
 
@@ -273,21 +304,22 @@ struct fuse_conn {
 	/** Is create not implemented by fs? */
 	unsigned no_create : 1;
 
+	/** The number of requests waiting for completion */
+	atomic_t num_waiting;
+
 	/** Negotiated minor version */
 	unsigned minor;
 
 	/** Backing dev info */
 	struct backing_dev_info bdi;
-};
 
-static inline struct fuse_conn **get_fuse_conn_super_p(struct super_block *sb)
-{
-	return (struct fuse_conn **) &sb->s_fs_info;
-}
+	/** kobject */
+	struct kobject kobj;
+};
 
 static inline struct fuse_conn *get_fuse_conn_super(struct super_block *sb)
 {
-	return *get_fuse_conn_super_p(sb);
+	return sb->s_fs_info;
 }
 
 static inline struct fuse_conn *get_fuse_conn(struct inode *inode)
@@ -295,6 +327,11 @@ static inline struct fuse_conn *get_fuse
 	return get_fuse_conn_super(inode->i_sb);
 }
 
+static inline struct fuse_conn *get_fuse_conn_kobj(struct kobject *obj)
+{
+	return container_of(obj, struct fuse_conn, kobj);
+}
+
 static inline struct fuse_inode *get_fuse_inode(struct inode *inode)
 {
 	return container_of(inode, struct fuse_inode, inode);
@@ -336,11 +373,10 @@ void fuse_send_forget(struct fuse_conn *
 		      unsigned long nodeid, u64 nlookup);
 
 /**
- * Send READ or READDIR request
+ * Initialize READ or READDIR request
  */
-size_t fuse_send_read_common(struct fuse_req *req, struct file *file,
-			     struct inode *inode, loff_t pos, size_t count,
-			     int isdir);
+void fuse_read_fill(struct fuse_req *req, struct file *file,
+		    struct inode *inode, loff_t pos, size_t count, int opcode);
 
 /**
  * Send OPEN or OPENDIR request
@@ -395,12 +431,6 @@ void fuse_init_symlink(struct inode *ino
 void fuse_change_attributes(struct inode *inode, struct fuse_attr *attr);
 
 /**
- * Check if the connection can be released, and if yes, then free the
- * connection structure
- */
-void fuse_release_conn(struct fuse_conn *fc);
-
-/**
  * Initialize the client device
  */
 int fuse_dev_init(void);
@@ -456,6 +486,9 @@ void request_send_background(struct fuse
  */
 void fuse_release_background(struct fuse_req *req);
 
+/* Abort all requests */
+void fuse_abort_conn(struct fuse_conn *fc);
+
 /**
  * Get the attributes of a file
  */
@@ -465,8 +498,3 @@ int fuse_do_getattr(struct inode *inode)
  * Invalidate inode attributes
  */
 void fuse_invalidate_attr(struct inode *inode);
-
-/**
- * Send the INIT message
- */
-void fuse_send_init(struct fuse_conn *fc);
diff -purN linux-2.6.15-git12/fs/fuse/inode.c linux-2.6.16-rc1/fs/fuse/inode.c
--- linux-2.6.15-git12/fs/fuse/inode.c	2006-01-17 08:21:37.004767596 +0000
+++ linux-2.6.16-rc1/fs/fuse/inode.c	2006-01-17 08:22:51.498362788 +0000
@@ -24,6 +24,13 @@ MODULE_LICENSE("GPL");
 
 spinlock_t fuse_lock;
 static kmem_cache_t *fuse_inode_cachep;
+static struct subsystem connections_subsys;
+
+struct fuse_conn_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct fuse_conn *, char *);
+	ssize_t (*store)(struct fuse_conn *, const char *, size_t);
+};
 
 #define FUSE_SUPER_MAGIC 0x65735546
 
@@ -189,6 +196,11 @@ struct inode *fuse_iget(struct super_blo
 	return inode;
 }
 
+static void fuse_umount_begin(struct super_block *sb)
+{
+	fuse_abort_conn(get_fuse_conn_super(sb));
+}
+
 static void fuse_put_super(struct super_block *sb)
 {
 	struct fuse_conn *fc = get_fuse_conn_super(sb);
@@ -200,14 +212,13 @@ static void fuse_put_super(struct super_
 
 	spin_lock(&fuse_lock);
 	fc->mounted = 0;
-	fc->user_id = 0;
-	fc->group_id = 0;
-	fc->flags = 0;
+	fc->connected = 0;
+	spin_unlock(&fuse_lock);
+	up_write(&fc->sbput_sem);
 	/* Flush all readers on this fs */
 	wake_up_all(&fc->waitq);
-	up_write(&fc->sbput_sem);
-	fuse_release_conn(fc);
-	spin_unlock(&fuse_lock);
+	kobject_del(&fc->kobj);
+	kobject_put(&fc->kobj);
 }
 
 static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)
@@ -356,8 +367,10 @@ static int fuse_show_options(struct seq_
 	return 0;
 }
 
-static void free_conn(struct fuse_conn *fc)
+static void fuse_conn_release(struct kobject *kobj)
 {
+	struct fuse_conn *fc = get_fuse_conn_kobj(kobj);
+
 	while (!list_empty(&fc->unused_list)) {
 		struct fuse_req *req;
 		req = list_entry(fc->unused_list.next, struct fuse_req, list);
@@ -367,33 +380,28 @@ static void free_conn(struct fuse_conn *
 	kfree(fc);
 }
 
-/* Must be called with the fuse lock held */
-void fuse_release_conn(struct fuse_conn *fc)
-{
-	fc->count--;
-	if (!fc->count)
-		free_conn(fc);
-}
-
 static struct fuse_conn *new_conn(void)
 {
 	struct fuse_conn *fc;
 
-	fc = kmalloc(sizeof(*fc), GFP_KERNEL);
-	if (fc != NULL) {
+	fc = kzalloc(sizeof(*fc), GFP_KERNEL);
+	if (fc) {
 		int i;
-		memset(fc, 0, sizeof(*fc));
 		init_waitqueue_head(&fc->waitq);
 		INIT_LIST_HEAD(&fc->pending);
 		INIT_LIST_HEAD(&fc->processing);
+		INIT_LIST_HEAD(&fc->io);
 		INIT_LIST_HEAD(&fc->unused_list);
 		INIT_LIST_HEAD(&fc->background);
-		sema_init(&fc->outstanding_sem, 0);
+		sema_init(&fc->outstanding_sem, 1); /* One for INIT */
 		init_rwsem(&fc->sbput_sem);
+		kobj_set_kset_s(fc, connections_subsys);
+		kobject_init(&fc->kobj);
+		atomic_set(&fc->num_waiting, 0);
 		for (i = 0; i < FUSE_MAX_OUTSTANDING; i++) {
 			struct fuse_req *req = fuse_request_alloc();
 			if (!req) {
-				free_conn(fc);
+				kobject_put(&fc->kobj);
 				return NULL;
 			}
 			list_add(&req->list, &fc->unused_list);
@@ -408,25 +416,32 @@ static struct fuse_conn *new_conn(void)
 static struct fuse_conn *get_conn(struct file *file, struct super_block *sb)
 {
 	struct fuse_conn *fc;
+	int err;
 
+	err = -EINVAL;
 	if (file->f_op != &fuse_dev_operations)
-		return ERR_PTR(-EINVAL);
+		goto out_err;
+
+	err = -ENOMEM;
 	fc = new_conn();
-	if (fc == NULL)
-		return ERR_PTR(-ENOMEM);
+	if (!fc)
+		goto out_err;
+
 	spin_lock(&fuse_lock);
-	if (file->private_data) {
-		free_conn(fc);
-		fc = ERR_PTR(-EINVAL);
-	} else {
-		file->private_data = fc;
-		*get_fuse_conn_super_p(sb) = fc;
-		fc->mounted = 1;
-		fc->connected = 1;
-		fc->count = 2;
-	}
+	err = -EINVAL;
+	if (file->private_data)
+		goto out_unlock;
+
+	kobject_get(&fc->kobj);
+	file->private_data = fc;
 	spin_unlock(&fuse_lock);
 	return fc;
+
+ out_unlock:
+	spin_unlock(&fuse_lock);
+	kobject_put(&fc->kobj);
+ out_err:
+	return ERR_PTR(err);
 }
 
 static struct inode *get_root_inode(struct super_block *sb, unsigned mode)
@@ -445,16 +460,74 @@ static struct super_operations fuse_supe
 	.read_inode	= fuse_read_inode,
 	.clear_inode	= fuse_clear_inode,
 	.put_super	= fuse_put_super,
+	.umount_begin	= fuse_umount_begin,
 	.statfs		= fuse_statfs,
 	.show_options	= fuse_show_options,
 };
 
+static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
+{
+	int i;
+	struct fuse_init_out *arg = &req->misc.init_out;
+
+	if (req->out.h.error || arg->major != FUSE_KERNEL_VERSION)
+		fc->conn_error = 1;
+	else {
+		fc->minor = arg->minor;
+		fc->max_write = arg->minor < 5 ? 4096 : arg->max_write;
+	}
+
+	/* After INIT reply is received other requests can go
+	   out.  So do (FUSE_MAX_OUTSTANDING - 1) number of
+	   up()s on outstanding_sem.  The last up() is done in
+	   fuse_putback_request() */
+	for (i = 1; i < FUSE_MAX_OUTSTANDING; i++)
+		up(&fc->outstanding_sem);
+
+	fuse_put_request(fc, req);
+}
+
+static void fuse_send_init(struct fuse_conn *fc)
+{
+	/* This is called from fuse_read_super() so there's guaranteed
+	   to be exactly one request available */
+	struct fuse_req *req = fuse_get_request(fc);
+	struct fuse_init_in *arg = &req->misc.init_in;
+
+	arg->major = FUSE_KERNEL_VERSION;
+	arg->minor = FUSE_KERNEL_MINOR_VERSION;
+	req->in.h.opcode = FUSE_INIT;
+	req->in.numargs = 1;
+	req->in.args[0].size = sizeof(*arg);
+	req->in.args[0].value = arg;
+	req->out.numargs = 1;
+	/* Variable length arguement used for backward compatibility
+	   with interface version < 7.5.  Rest of init_out is zeroed
+	   by do_get_request(), so a short reply is not a problem */
+	req->out.argvar = 1;
+	req->out.args[0].size = sizeof(struct fuse_init_out);
+	req->out.args[0].value = &req->misc.init_out;
+	req->end = process_init_reply;
+	request_send_background(fc, req);
+}
+
+static unsigned long long conn_id(void)
+{
+	static unsigned long long ctr = 1;
+	unsigned long long val;
+	spin_lock(&fuse_lock);
+	val = ctr++;
+	spin_unlock(&fuse_lock);
+	return val;
+}
+
 static int fuse_fill_super(struct super_block *sb, void *data, int silent)
 {
 	struct fuse_conn *fc;
 	struct inode *root;
 	struct fuse_mount_data d;
 	struct file *file;
+	struct dentry *root_dentry;
 	int err;
 
 	if (!parse_fuse_opt((char *) data, &d))
@@ -482,23 +555,42 @@ static int fuse_fill_super(struct super_
 	if (fc->max_read / PAGE_CACHE_SIZE < fc->bdi.ra_pages)
 		fc->bdi.ra_pages = fc->max_read / PAGE_CACHE_SIZE;
 
+	/* Used by get_root_inode() */
+	sb->s_fs_info = fc;
+
 	err = -ENOMEM;
 	root = get_root_inode(sb, d.rootmode);
-	if (root == NULL)
+	if (!root)
 		goto err;
 
-	sb->s_root = d_alloc_root(root);
-	if (!sb->s_root) {
+	root_dentry = d_alloc_root(root);
+	if (!root_dentry) {
 		iput(root);
 		goto err;
 	}
+
+	err = kobject_set_name(&fc->kobj, "%llu", conn_id());
+	if (err)
+		goto err_put_root;
+
+	err = kobject_add(&fc->kobj);
+	if (err)
+		goto err_put_root;
+
+	sb->s_root = root_dentry;
+	spin_lock(&fuse_lock);
+	fc->mounted = 1;
+	fc->connected = 1;
+	spin_unlock(&fuse_lock);
+
 	fuse_send_init(fc);
+
 	return 0;
 
+ err_put_root:
+	dput(root_dentry);
  err:
-	spin_lock(&fuse_lock);
-	fuse_release_conn(fc);
-	spin_unlock(&fuse_lock);
+	kobject_put(&fc->kobj);
 	return err;
 }
 
@@ -516,6 +608,69 @@ static struct file_system_type fuse_fs_t
 	.kill_sb	= kill_anon_super,
 };
 
+static ssize_t fuse_conn_waiting_show(struct fuse_conn *fc, char *page)
+{
+	return sprintf(page, "%i\n", atomic_read(&fc->num_waiting));
+}
+
+static ssize_t fuse_conn_abort_store(struct fuse_conn *fc, const char *page,
+				     size_t count)
+{
+	fuse_abort_conn(fc);
+	return count;
+}
+
+static struct fuse_conn_attr fuse_conn_waiting =
+	__ATTR(waiting, 0400, fuse_conn_waiting_show, NULL);
+static struct fuse_conn_attr fuse_conn_abort =
+	__ATTR(abort, 0600, NULL, fuse_conn_abort_store);
+
+static struct attribute *fuse_conn_attrs[] = {
+	&fuse_conn_waiting.attr,
+	&fuse_conn_abort.attr,
+	NULL,
+};
+
+static ssize_t fuse_conn_attr_show(struct kobject *kobj,
+				   struct attribute *attr,
+				   char *page)
+{
+	struct fuse_conn_attr *fca =
+		container_of(attr, struct fuse_conn_attr, attr);
+
+	if (fca->show)
+		return fca->show(get_fuse_conn_kobj(kobj), page);
+	else
+		return -EACCES;
+}
+
+static ssize_t fuse_conn_attr_store(struct kobject *kobj,
+				    struct attribute *attr,
+				    const char *page, size_t count)
+{
+	struct fuse_conn_attr *fca =
+		container_of(attr, struct fuse_conn_attr, attr);
+
+	if (fca->store)
+		return fca->store(get_fuse_conn_kobj(kobj), page, count);
+	else
+		return -EACCES;
+}
+
+static struct sysfs_ops fuse_conn_sysfs_ops = {
+	.show	= &fuse_conn_attr_show,
+	.store	= &fuse_conn_attr_store,
+};
+
+static struct kobj_type ktype_fuse_conn = {
+	.release	= fuse_conn_release,
+	.sysfs_ops	= &fuse_conn_sysfs_ops,
+	.default_attrs	= fuse_conn_attrs,
+};
+
+static decl_subsys(fuse, NULL, NULL);
+static decl_subsys(connections, &ktype_fuse_conn, NULL);
+
 static void fuse_inode_init_once(void *foo, kmem_cache_t *cachep,
 				 unsigned long flags)
 {
@@ -553,6 +708,34 @@ static void fuse_fs_cleanup(void)
 	kmem_cache_destroy(fuse_inode_cachep);
 }
 
+static int fuse_sysfs_init(void)
+{
+	int err;
+
+	kset_set_kset_s(&fuse_subsys, fs_subsys);
+	err = subsystem_register(&fuse_subsys);
+	if (err)
+		goto out_err;
+
+	kset_set_kset_s(&connections_subsys, fuse_subsys);
+	err = subsystem_register(&connections_subsys);
+	if (err)
+		goto out_fuse_unregister;
+
+	return 0;
+
+ out_fuse_unregister:
+	subsystem_unregister(&fuse_subsys);
+ out_err:
+	return err;
+}
+
+static void fuse_sysfs_cleanup(void)
+{
+	subsystem_unregister(&connections_subsys);
+	subsystem_unregister(&fuse_subsys);
+}
+
 static int __init fuse_init(void)
 {
 	int res;
@@ -569,8 +752,14 @@ static int __init fuse_init(void)
 	if (res)
 		goto err_fs_cleanup;
 
+	res = fuse_sysfs_init();
+	if (res)
+		goto err_dev_cleanup;
+
 	return 0;
 
+ err_dev_cleanup:
+	fuse_dev_cleanup();
  err_fs_cleanup:
 	fuse_fs_cleanup();
  err:
@@ -581,6 +770,7 @@ static void __exit fuse_exit(void)
 {
 	printk(KERN_DEBUG "fuse exit\n");
 
+	fuse_sysfs_cleanup();
 	fuse_fs_cleanup();
 	fuse_dev_cleanup();
 }
diff -purN linux-2.6.15-git12/fs/namespace.c linux-2.6.16-rc1/fs/namespace.c
--- linux-2.6.15-git12/fs/namespace.c	2006-01-17 08:21:37.115750122 +0000
+++ linux-2.6.16-rc1/fs/namespace.c	2006-01-17 08:22:51.601346573 +0000
@@ -48,6 +48,10 @@ static int hash_mask __read_mostly, hash
 static kmem_cache_t *mnt_cache;
 static struct rw_semaphore namespace_sem;
 
+/* /sys/fs */
+decl_subsys(fs, NULL, NULL);
+EXPORT_SYMBOL_GPL(fs_subsys);
+
 static inline unsigned long hash(struct vfsmount *mnt, struct dentry *dentry)
 {
 	unsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);
@@ -1725,6 +1729,7 @@ void __init mnt_init(unsigned long mempa
 		i--;
 	} while (i);
 	sysfs_init();
+	subsystem_register(&fs_subsys);
 	init_rootfs();
 	init_mount_tree();
 }
diff -purN linux-2.6.15-git12/fs/partitions/Kconfig linux-2.6.16-rc1/fs/partitions/Kconfig
--- linux-2.6.15-git12/fs/partitions/Kconfig	2006-01-17 08:21:37.783777865 +0000
+++ linux-2.6.16-rc1/fs/partitions/Kconfig	2006-01-17 08:22:52.252377994 +0000
@@ -222,6 +222,13 @@ config SUN_PARTITION
 	  given by the tar program ("man tar" or preferably "info tar"). If
 	  you don't know what all this is about, say N.
 
+config KARMA_PARTITION
+	bool "Karma Partition support"
+	depends on PARTITION_ADVANCED
+	help
+	  Say Y here if you would like to mount the Rio Karma MP3 player, as it
+	  uses a proprietary partition table.
+
 config EFI_PARTITION
 	bool "EFI GUID Partition support"
 	depends on PARTITION_ADVANCED
diff -purN linux-2.6.15-git12/fs/partitions/Makefile linux-2.6.16-rc1/fs/partitions/Makefile
--- linux-2.6.15-git12/fs/partitions/Makefile	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/fs/partitions/Makefile	2006-01-17 08:22:52.253377836 +0000
@@ -17,3 +17,4 @@ obj-$(CONFIG_SUN_PARTITION) += sun.o
 obj-$(CONFIG_ULTRIX_PARTITION) += ultrix.o
 obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
+obj-$(CONFIG_KARMA_PARTITION) += karma.o
diff -purN linux-2.6.15-git12/fs/partitions/check.c linux-2.6.16-rc1/fs/partitions/check.c
--- linux-2.6.15-git12/fs/partitions/check.c	2006-01-17 08:21:37.785777550 +0000
+++ linux-2.6.16-rc1/fs/partitions/check.c	2006-01-17 08:22:52.255377521 +0000
@@ -35,6 +35,7 @@
 #include "ibm.h"
 #include "ultrix.h"
 #include "efi.h"
+#include "karma.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -103,6 +104,9 @@ static int (*check_part[])(struct parsed
 #ifdef CONFIG_IBM_PARTITION
 	ibm_partition,
 #endif
+#ifdef CONFIG_KARMA_PARTITION
+	karma_partition,
+#endif
 	NULL
 };
  
diff -purN linux-2.6.15-git12/fs/partitions/karma.c linux-2.6.16-rc1/fs/partitions/karma.c
--- linux-2.6.15-git12/fs/partitions/karma.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/fs/partitions/karma.c	2006-01-17 08:22:52.258377049 +0000
@@ -0,0 +1,57 @@
+/*
+ *  fs/partitions/karma.c
+ *  Rio Karma partition info.
+ *
+ *  Copyright (C) 2006 Bob Copeland (me@bobcopeland.com)
+ *  based on osf.c
+ */
+
+#include "check.h"
+#include "karma.h"
+
+int karma_partition(struct parsed_partitions *state, struct block_device *bdev)
+{
+	int i;
+	int slot = 1;
+	Sector sect;
+	unsigned char *data;
+	struct disklabel {
+		u8 d_reserved[270];
+		struct d_partition {
+			__le32 p_res;
+			u8 p_fstype;
+			u8 p_res2[3];
+			__le32 p_offset;
+			__le32 p_size;
+		} d_partitions[2];
+		u8 d_blank[208];
+		__le16 d_magic;
+	} __attribute__((packed)) *label;
+	struct d_partition *p;
+
+	data = read_dev_sector(bdev, 0, &sect);
+	if (!data)
+		return -1;
+
+	label = (struct disklabel *)data;
+	if (le16_to_cpu(label->d_magic) != KARMA_LABEL_MAGIC) {
+		put_dev_sector(sect);
+		return 0;
+	}
+
+	p = label->d_partitions;
+	for (i = 0 ; i < 2; i++, p++) {
+		if (slot == state->limit)
+			break;
+
+		if (p->p_fstype == 0x4d && le32_to_cpu(p->p_size)) {
+			put_partition(state, slot, le32_to_cpu(p->p_offset),
+				le32_to_cpu(p->p_size));
+		}
+		slot++;
+	}
+	printk("\n");
+	put_dev_sector(sect);
+	return 1;
+}
+
diff -purN linux-2.6.15-git12/fs/partitions/karma.h linux-2.6.16-rc1/fs/partitions/karma.h
--- linux-2.6.15-git12/fs/partitions/karma.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/fs/partitions/karma.h	2006-01-17 08:22:52.259376892 +0000
@@ -0,0 +1,8 @@
+/*
+ *  fs/partitions/karma.h
+ */
+
+#define KARMA_LABEL_MAGIC		0xAB56
+
+int karma_partition(struct parsed_partitions *state, struct block_device *bdev);
+
diff -purN linux-2.6.15-git12/include/asm-arm26/cache.h linux-2.6.16-rc1/include/asm-arm26/cache.h
--- linux-2.6.15-git12/include/asm-arm26/cache.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-arm26/cache.h	2006-01-17 08:22:52.886411091 +0000
@@ -4,7 +4,8 @@
 #ifndef __ASMARM_CACHE_H
 #define __ASMARM_CACHE_H
 
-#define        L1_CACHE_BYTES  32
+#define        L1_CACHE_SHIFT  5
+#define        L1_CACHE_BYTES  (1 << L1_CACHE_SHIFT)
 #define        L1_CACHE_ALIGN(x)       (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
 #define        SMP_CACHE_BYTES L1_CACHE_BYTES
 
diff -purN linux-2.6.15-git12/include/asm-arm26/thread_info.h linux-2.6.16-rc1/include/asm-arm26/thread_info.h
--- linux-2.6.15-git12/include/asm-arm26/thread_info.h	2006-01-17 08:21:38.464805406 +0000
+++ linux-2.6.16-rc1/include/asm-arm26/thread_info.h	2006-01-17 08:22:52.892410146 +0000
@@ -80,8 +80,7 @@ static inline struct thread_info *curren
 	return (struct thread_info *)(sp & ~0x1fff);
 }
 
-/* FIXME - PAGE_SIZE < 32K */
-#define THREAD_SIZE		(8*32768) // FIXME - this needs attention (see kernel/fork.c which gets a nice div by zero if this is lower than 8*32768
+#define THREAD_SIZE	PAGE_SIZE
 #define task_pt_regs(task) ((struct pt_regs *)(task_stack_page(task) + THREAD_SIZE - 8) - 1)
 
 extern struct thread_info *alloc_thread_info(struct task_struct *task);
diff -purN linux-2.6.15-git12/include/asm-ia64/pal.h linux-2.6.16-rc1/include/asm-ia64/pal.h
--- linux-2.6.15-git12/include/asm-ia64/pal.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/pal.h	2006-01-17 08:22:53.015390783 +0000
@@ -927,7 +927,7 @@ static inline s64
 ia64_pal_cache_flush (u64 cache_type, u64 invalidate, u64 *progress, u64 *vector)
 {
 	struct ia64_pal_retval iprv;
-	PAL_CALL_IC_OFF(iprv, PAL_CACHE_FLUSH, cache_type, invalidate, *progress);
+	PAL_CALL(iprv, PAL_CACHE_FLUSH, cache_type, invalidate, *progress);
 	if (vector)
 		*vector = iprv.v0;
 	*progress = iprv.v1;
diff -purN linux-2.6.15-git12/include/asm-ia64/processor.h linux-2.6.16-rc1/include/asm-ia64/processor.h
--- linux-2.6.15-git12/include/asm-ia64/processor.h	2006-01-17 08:21:38.570788719 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/processor.h	2006-01-17 08:22:53.017390468 +0000
@@ -25,8 +25,8 @@
  * Limits for PMC and PMD are set to less than maximum architected values
  * but should be sufficient for a while
  */
-#define IA64_NUM_PMC_REGS	32
-#define IA64_NUM_PMD_REGS	32
+#define IA64_NUM_PMC_REGS	64
+#define IA64_NUM_PMD_REGS	64
 
 #define DEFAULT_MAP_BASE	__IA64_UL_CONST(0x2000000000000000)
 #define DEFAULT_TASK_SIZE	__IA64_UL_CONST(0xa000000000000000)
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/intr.h linux-2.6.16-rc1/include/asm-ia64/sn/intr.h
--- linux-2.6.15-git12/include/asm-ia64/sn/intr.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/intr.h	2006-01-17 08:22:53.020389996 +0000
@@ -40,7 +40,7 @@ struct sn_irq_info {
 	int		irq_cpuid;	/* kernel logical cpuid	     */
 	int		irq_irq;	/* the IRQ number */
 	int		irq_int_bit;	/* Bridge interrupt pin */
-	uint64_t	irq_xtalkaddr;	/* xtalkaddr IRQ is sent to  */
+	u64	irq_xtalkaddr;	/* xtalkaddr IRQ is sent to  */
 	int		irq_bridge_type;/* pciio asic type (pciio.h) */
 	void	       *irq_bridge;	/* bridge generating irq     */
 	void	       *irq_pciioinfo;	/* associated pciio_info_t   */
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/pcibr_provider.h linux-2.6.16-rc1/include/asm-ia64/sn/pcibr_provider.h
--- linux-2.6.15-git12/include/asm-ia64/sn/pcibr_provider.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/pcibr_provider.h	2006-01-17 08:22:53.025389208 +0000
@@ -44,9 +44,9 @@
 #define PCI32_MAPPED_BASE               0x40000000
 #define PCI32_DIRECT_BASE               0x80000000
 
-#define IS_PCI32_MAPPED(x)              ((uint64_t)(x) < PCI32_DIRECT_BASE && \
-                                         (uint64_t)(x) >= PCI32_MAPPED_BASE)
-#define IS_PCI32_DIRECT(x)              ((uint64_t)(x) >= PCI32_MAPPED_BASE)
+#define IS_PCI32_MAPPED(x)              ((u64)(x) < PCI32_DIRECT_BASE && \
+                                         (u64)(x) >= PCI32_MAPPED_BASE)
+#define IS_PCI32_DIRECT(x)              ((u64)(x) >= PCI32_MAPPED_BASE)
 
 
 /*
@@ -63,7 +63,7 @@
 	(IOPG(IOPGOFF(addr) + (size) - 1) == IOPG((size) - 1))
 
 #define MINIMAL_ATE_FLAG(addr, size) \
-	(MINIMAL_ATES_REQUIRED((uint64_t)addr, size) ? 1 : 0)
+	(MINIMAL_ATES_REQUIRED((u64)addr, size) ? 1 : 0)
 
 /* bit 29 of the pci address is the SWAP bit */
 #define ATE_SWAPSHIFT                   29
@@ -90,27 +90,27 @@
  * PMU resources.
  */
 struct ate_resource{
-	uint64_t *ate;
-	uint64_t num_ate;
-	uint64_t lowest_free_index;
+	u64 *ate;
+	u64 num_ate;
+	u64 lowest_free_index;
 };
 
 struct pcibus_info {
 	struct pcibus_bussoft	pbi_buscommon;   /* common header */
-	uint32_t                pbi_moduleid;
+	u32                pbi_moduleid;
 	short                   pbi_bridge_type;
 	short                   pbi_bridge_mode;
 
 	struct ate_resource     pbi_int_ate_resource;
-	uint64_t                pbi_int_ate_size;
+	u64                pbi_int_ate_size;
 
-	uint64_t                pbi_dir_xbase;
+	u64                pbi_dir_xbase;
 	char                    pbi_hub_xid;
 
-	uint64_t                pbi_devreg[8];
+	u64                pbi_devreg[8];
 
-	uint32_t		pbi_valid_devices;
-	uint32_t		pbi_enabled_devices;
+	u32		pbi_valid_devices;
+	u32		pbi_enabled_devices;
 
 	spinlock_t              pbi_lock;
 };
@@ -136,22 +136,22 @@ extern void pcibr_dma_unmap(struct pci_d
 /*
  * prototypes for the bridge asic register access routines in pcibr_reg.c
  */
-extern void             pcireg_control_bit_clr(struct pcibus_info *, uint64_t);
-extern void             pcireg_control_bit_set(struct pcibus_info *, uint64_t);
-extern uint64_t         pcireg_tflush_get(struct pcibus_info *);
-extern uint64_t         pcireg_intr_status_get(struct pcibus_info *);
-extern void             pcireg_intr_enable_bit_clr(struct pcibus_info *, uint64_t);
-extern void             pcireg_intr_enable_bit_set(struct pcibus_info *, uint64_t);
-extern void             pcireg_intr_addr_addr_set(struct pcibus_info *, int, uint64_t);
+extern void             pcireg_control_bit_clr(struct pcibus_info *, u64);
+extern void             pcireg_control_bit_set(struct pcibus_info *, u64);
+extern u64         pcireg_tflush_get(struct pcibus_info *);
+extern u64         pcireg_intr_status_get(struct pcibus_info *);
+extern void             pcireg_intr_enable_bit_clr(struct pcibus_info *, u64);
+extern void             pcireg_intr_enable_bit_set(struct pcibus_info *, u64);
+extern void             pcireg_intr_addr_addr_set(struct pcibus_info *, int, u64);
 extern void             pcireg_force_intr_set(struct pcibus_info *, int);
-extern uint64_t         pcireg_wrb_flush_get(struct pcibus_info *, int);
-extern void             pcireg_int_ate_set(struct pcibus_info *, int, uint64_t);
-extern uint64_t *	pcireg_int_ate_addr(struct pcibus_info *, int);
+extern u64         pcireg_wrb_flush_get(struct pcibus_info *, int);
+extern void             pcireg_int_ate_set(struct pcibus_info *, int, u64);
+extern u64 *	pcireg_int_ate_addr(struct pcibus_info *, int);
 extern void 		pcibr_force_interrupt(struct sn_irq_info *sn_irq_info);
 extern void 		pcibr_change_devices_irq(struct sn_irq_info *sn_irq_info);
 extern int 		pcibr_ate_alloc(struct pcibus_info *, int);
 extern void 		pcibr_ate_free(struct pcibus_info *, int);
-extern void 		ate_write(struct pcibus_info *, int, int, uint64_t);
+extern void 		ate_write(struct pcibus_info *, int, int, u64);
 extern int sal_pcibr_slot_enable(struct pcibus_info *soft, int device,
 				 void *resp);
 extern int sal_pcibr_slot_disable(struct pcibus_info *soft, int device,
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/pcibus_provider_defs.h linux-2.6.16-rc1/include/asm-ia64/sn/pcibus_provider_defs.h
--- linux-2.6.15-git12/include/asm-ia64/sn/pcibus_provider_defs.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/pcibus_provider_defs.h	2006-01-17 08:22:53.027388894 +0000
@@ -29,13 +29,13 @@
  */
 
 struct pcibus_bussoft {
-	uint32_t		bs_asic_type;	/* chipset type */
-	uint32_t		bs_xid;		/* xwidget id */
-	uint32_t		bs_persist_busnum; /* Persistent Bus Number */
-	uint32_t		bs_persist_segment; /* Segment Number */
-	uint64_t		bs_legacy_io;	/* legacy io pio addr */
-	uint64_t		bs_legacy_mem;	/* legacy mem pio addr */
-	uint64_t		bs_base;	/* widget base */
+	u32		bs_asic_type;	/* chipset type */
+	u32		bs_xid;		/* xwidget id */
+	u32		bs_persist_busnum; /* Persistent Bus Number */
+	u32		bs_persist_segment; /* Segment Number */
+	u64		bs_legacy_io;	/* legacy io pio addr */
+	u64		bs_legacy_mem;	/* legacy mem pio addr */
+	u64		bs_base;	/* widget base */
 	struct xwidget_info	*bs_xwidget_info;
 };
 
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/pcidev.h linux-2.6.16-rc1/include/asm-ia64/sn/pcidev.h
--- linux-2.6.15-git12/include/asm-ia64/sn/pcidev.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/pcidev.h	2006-01-17 08:22:53.027388894 +0000
@@ -55,8 +55,8 @@ struct sn_pci_controller {
 #define PCIIO_VENDOR_ID_NONE	(-1)
 
 struct pcidev_info {
-	uint64_t		pdi_pio_mapped_addr[7]; /* 6 BARs PLUS 1 ROM */
-	uint64_t		pdi_slot_host_handle;	/* Bus and devfn Host pci_dev */
+	u64		pdi_pio_mapped_addr[7]; /* 6 BARs PLUS 1 ROM */
+	u64		pdi_slot_host_handle;	/* Bus and devfn Host pci_dev */
 
 	struct pcibus_bussoft	*pdi_pcibus_info;	/* Kernel common bus soft */
 	struct pcidev_info	*pdi_host_pcidev_info;	/* Kernel Host pci_dev */
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/pic.h linux-2.6.16-rc1/include/asm-ia64/sn/pic.h
--- linux-2.6.15-git12/include/asm-ia64/sn/pic.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/pic.h	2006-01-17 08:22:53.032388107 +0000
@@ -74,120 +74,120 @@ struct pic {
     /* 0x000000-0x00FFFF -- Local Registers */
 
     /* 0x000000-0x000057 -- Standard Widget Configuration */
-    uint64_t		p_wid_id;			/* 0x000000 */
-    uint64_t		p_wid_stat;			/* 0x000008 */
-    uint64_t		p_wid_err_upper;		/* 0x000010 */
-    uint64_t		p_wid_err_lower;		/* 0x000018 */
+    u64		p_wid_id;			/* 0x000000 */
+    u64		p_wid_stat;			/* 0x000008 */
+    u64		p_wid_err_upper;		/* 0x000010 */
+    u64		p_wid_err_lower;		/* 0x000018 */
     #define p_wid_err p_wid_err_lower
-    uint64_t		p_wid_control;			/* 0x000020 */
-    uint64_t		p_wid_req_timeout;		/* 0x000028 */
-    uint64_t		p_wid_int_upper;		/* 0x000030 */
-    uint64_t		p_wid_int_lower;		/* 0x000038 */
+    u64		p_wid_control;			/* 0x000020 */
+    u64		p_wid_req_timeout;		/* 0x000028 */
+    u64		p_wid_int_upper;		/* 0x000030 */
+    u64		p_wid_int_lower;		/* 0x000038 */
     #define p_wid_int p_wid_int_lower
-    uint64_t		p_wid_err_cmdword;		/* 0x000040 */
-    uint64_t		p_wid_llp;			/* 0x000048 */
-    uint64_t		p_wid_tflush;			/* 0x000050 */
+    u64		p_wid_err_cmdword;		/* 0x000040 */
+    u64		p_wid_llp;			/* 0x000048 */
+    u64		p_wid_tflush;			/* 0x000050 */
 
     /* 0x000058-0x00007F -- Bridge-specific Widget Configuration */
-    uint64_t		p_wid_aux_err;			/* 0x000058 */
-    uint64_t		p_wid_resp_upper;		/* 0x000060 */
-    uint64_t		p_wid_resp_lower;		/* 0x000068 */
+    u64		p_wid_aux_err;			/* 0x000058 */
+    u64		p_wid_resp_upper;		/* 0x000060 */
+    u64		p_wid_resp_lower;		/* 0x000068 */
     #define p_wid_resp p_wid_resp_lower
-    uint64_t		p_wid_tst_pin_ctrl;		/* 0x000070 */
-    uint64_t		p_wid_addr_lkerr;		/* 0x000078 */
+    u64		p_wid_tst_pin_ctrl;		/* 0x000070 */
+    u64		p_wid_addr_lkerr;		/* 0x000078 */
 
     /* 0x000080-0x00008F -- PMU & MAP */
-    uint64_t		p_dir_map;			/* 0x000080 */
-    uint64_t		_pad_000088;			/* 0x000088 */
+    u64		p_dir_map;			/* 0x000080 */
+    u64		_pad_000088;			/* 0x000088 */
 
     /* 0x000090-0x00009F -- SSRAM */
-    uint64_t		p_map_fault;			/* 0x000090 */
-    uint64_t		_pad_000098;			/* 0x000098 */
+    u64		p_map_fault;			/* 0x000090 */
+    u64		_pad_000098;			/* 0x000098 */
 
     /* 0x0000A0-0x0000AF -- Arbitration */
-    uint64_t		p_arb;				/* 0x0000A0 */
-    uint64_t		_pad_0000A8;			/* 0x0000A8 */
+    u64		p_arb;				/* 0x0000A0 */
+    u64		_pad_0000A8;			/* 0x0000A8 */
 
     /* 0x0000B0-0x0000BF -- Number In A Can or ATE Parity Error */
-    uint64_t		p_ate_parity_err;		/* 0x0000B0 */
-    uint64_t		_pad_0000B8;			/* 0x0000B8 */
+    u64		p_ate_parity_err;		/* 0x0000B0 */
+    u64		_pad_0000B8;			/* 0x0000B8 */
 
     /* 0x0000C0-0x0000FF -- PCI/GIO */
-    uint64_t		p_bus_timeout;			/* 0x0000C0 */
-    uint64_t		p_pci_cfg;			/* 0x0000C8 */
-    uint64_t		p_pci_err_upper;		/* 0x0000D0 */
-    uint64_t		p_pci_err_lower;		/* 0x0000D8 */
+    u64		p_bus_timeout;			/* 0x0000C0 */
+    u64		p_pci_cfg;			/* 0x0000C8 */
+    u64		p_pci_err_upper;		/* 0x0000D0 */
+    u64		p_pci_err_lower;		/* 0x0000D8 */
     #define p_pci_err p_pci_err_lower
-    uint64_t		_pad_0000E0[4];			/* 0x0000{E0..F8} */
+    u64		_pad_0000E0[4];			/* 0x0000{E0..F8} */
 
     /* 0x000100-0x0001FF -- Interrupt */
-    uint64_t		p_int_status;			/* 0x000100 */
-    uint64_t		p_int_enable;			/* 0x000108 */
-    uint64_t		p_int_rst_stat;			/* 0x000110 */
-    uint64_t		p_int_mode;			/* 0x000118 */
-    uint64_t		p_int_device;			/* 0x000120 */
-    uint64_t		p_int_host_err;			/* 0x000128 */
-    uint64_t		p_int_addr[8];			/* 0x0001{30,,,68} */
-    uint64_t		p_err_int_view;			/* 0x000170 */
-    uint64_t		p_mult_int;			/* 0x000178 */
-    uint64_t		p_force_always[8];		/* 0x0001{80,,,B8} */
-    uint64_t		p_force_pin[8];			/* 0x0001{C0,,,F8} */
+    u64		p_int_status;			/* 0x000100 */
+    u64		p_int_enable;			/* 0x000108 */
+    u64		p_int_rst_stat;			/* 0x000110 */
+    u64		p_int_mode;			/* 0x000118 */
+    u64		p_int_device;			/* 0x000120 */
+    u64		p_int_host_err;			/* 0x000128 */
+    u64		p_int_addr[8];			/* 0x0001{30,,,68} */
+    u64		p_err_int_view;			/* 0x000170 */
+    u64		p_mult_int;			/* 0x000178 */
+    u64		p_force_always[8];		/* 0x0001{80,,,B8} */
+    u64		p_force_pin[8];			/* 0x0001{C0,,,F8} */
 
     /* 0x000200-0x000298 -- Device */
-    uint64_t		p_device[4];			/* 0x0002{00,,,18} */
-    uint64_t		_pad_000220[4];			/* 0x0002{20,,,38} */
-    uint64_t		p_wr_req_buf[4];		/* 0x0002{40,,,58} */
-    uint64_t		_pad_000260[4];			/* 0x0002{60,,,78} */
-    uint64_t		p_rrb_map[2];			/* 0x0002{80,,,88} */
+    u64		p_device[4];			/* 0x0002{00,,,18} */
+    u64		_pad_000220[4];			/* 0x0002{20,,,38} */
+    u64		p_wr_req_buf[4];		/* 0x0002{40,,,58} */
+    u64		_pad_000260[4];			/* 0x0002{60,,,78} */
+    u64		p_rrb_map[2];			/* 0x0002{80,,,88} */
     #define p_even_resp p_rrb_map[0]			/* 0x000280 */
     #define p_odd_resp  p_rrb_map[1]			/* 0x000288 */
-    uint64_t		p_resp_status;			/* 0x000290 */
-    uint64_t		p_resp_clear;			/* 0x000298 */
+    u64		p_resp_status;			/* 0x000290 */
+    u64		p_resp_clear;			/* 0x000298 */
 
-    uint64_t		_pad_0002A0[12];		/* 0x0002{A0..F8} */
+    u64		_pad_0002A0[12];		/* 0x0002{A0..F8} */
 
     /* 0x000300-0x0003F8 -- Buffer Address Match Registers */
     struct {
-	uint64_t	upper;				/* 0x0003{00,,,F0} */
-	uint64_t	lower;				/* 0x0003{08,,,F8} */
+	u64	upper;				/* 0x0003{00,,,F0} */
+	u64	lower;				/* 0x0003{08,,,F8} */
     } p_buf_addr_match[16];
 
     /* 0x000400-0x0005FF -- Performance Monitor Registers (even only) */
     struct {
-	uint64_t	flush_w_touch;			/* 0x000{400,,,5C0} */
-	uint64_t	flush_wo_touch;			/* 0x000{408,,,5C8} */
-	uint64_t	inflight;			/* 0x000{410,,,5D0} */
-	uint64_t	prefetch;			/* 0x000{418,,,5D8} */
-	uint64_t	total_pci_retry;		/* 0x000{420,,,5E0} */
-	uint64_t	max_pci_retry;			/* 0x000{428,,,5E8} */
-	uint64_t	max_latency;			/* 0x000{430,,,5F0} */
-	uint64_t	clear_all;			/* 0x000{438,,,5F8} */
+	u64	flush_w_touch;			/* 0x000{400,,,5C0} */
+	u64	flush_wo_touch;			/* 0x000{408,,,5C8} */
+	u64	inflight;			/* 0x000{410,,,5D0} */
+	u64	prefetch;			/* 0x000{418,,,5D8} */
+	u64	total_pci_retry;		/* 0x000{420,,,5E0} */
+	u64	max_pci_retry;			/* 0x000{428,,,5E8} */
+	u64	max_latency;			/* 0x000{430,,,5F0} */
+	u64	clear_all;			/* 0x000{438,,,5F8} */
     } p_buf_count[8];
 
 
     /* 0x000600-0x0009FF -- PCI/X registers */
-    uint64_t		p_pcix_bus_err_addr;		/* 0x000600 */
-    uint64_t		p_pcix_bus_err_attr;		/* 0x000608 */
-    uint64_t		p_pcix_bus_err_data;		/* 0x000610 */
-    uint64_t		p_pcix_pio_split_addr;		/* 0x000618 */
-    uint64_t		p_pcix_pio_split_attr;		/* 0x000620 */
-    uint64_t		p_pcix_dma_req_err_attr;	/* 0x000628 */
-    uint64_t		p_pcix_dma_req_err_addr;	/* 0x000630 */
-    uint64_t		p_pcix_timeout;			/* 0x000638 */
+    u64		p_pcix_bus_err_addr;		/* 0x000600 */
+    u64		p_pcix_bus_err_attr;		/* 0x000608 */
+    u64		p_pcix_bus_err_data;		/* 0x000610 */
+    u64		p_pcix_pio_split_addr;		/* 0x000618 */
+    u64		p_pcix_pio_split_attr;		/* 0x000620 */
+    u64		p_pcix_dma_req_err_attr;	/* 0x000628 */
+    u64		p_pcix_dma_req_err_addr;	/* 0x000630 */
+    u64		p_pcix_timeout;			/* 0x000638 */
 
-    uint64_t		_pad_000640[120];		/* 0x000{640,,,9F8} */
+    u64		_pad_000640[120];		/* 0x000{640,,,9F8} */
 
     /* 0x000A00-0x000BFF -- PCI/X Read&Write Buffer */
     struct {
-	uint64_t	p_buf_addr;			/* 0x000{A00,,,AF0} */
-	uint64_t	p_buf_attr;			/* 0X000{A08,,,AF8} */
+	u64	p_buf_addr;			/* 0x000{A00,,,AF0} */
+	u64	p_buf_attr;			/* 0X000{A08,,,AF8} */
     } p_pcix_read_buf_64[16];
 
     struct {
-	uint64_t	p_buf_addr;			/* 0x000{B00,,,BE0} */
-	uint64_t	p_buf_attr;			/* 0x000{B08,,,BE8} */
-	uint64_t	p_buf_valid;			/* 0x000{B10,,,BF0} */
-	uint64_t	__pad1;				/* 0x000{B18,,,BF8} */
+	u64	p_buf_addr;			/* 0x000{B00,,,BE0} */
+	u64	p_buf_attr;			/* 0x000{B08,,,BE8} */
+	u64	p_buf_valid;			/* 0x000{B10,,,BF0} */
+	u64	__pad1;				/* 0x000{B18,,,BF8} */
     } p_pcix_write_buf_64[8];
 
     /* End of Local Registers -- Start of Address Map space */
@@ -195,45 +195,45 @@ struct pic {
     char		_pad_000c00[0x010000 - 0x000c00];
 
     /* 0x010000-0x011fff -- Internal ATE RAM (Auto Parity Generation) */
-    uint64_t		p_int_ate_ram[1024];		/* 0x010000-0x011fff */
+    u64		p_int_ate_ram[1024];		/* 0x010000-0x011fff */
 
     /* 0x012000-0x013fff -- Internal ATE RAM (Manual Parity Generation) */
-    uint64_t		p_int_ate_ram_mp[1024];		/* 0x012000-0x013fff */
+    u64		p_int_ate_ram_mp[1024];		/* 0x012000-0x013fff */
 
     char		_pad_014000[0x18000 - 0x014000];
 
     /* 0x18000-0x197F8 -- PIC Write Request Ram */
-    uint64_t		p_wr_req_lower[256];		/* 0x18000 - 0x187F8 */
-    uint64_t		p_wr_req_upper[256];		/* 0x18800 - 0x18FF8 */
-    uint64_t		p_wr_req_parity[256];		/* 0x19000 - 0x197F8 */
+    u64		p_wr_req_lower[256];		/* 0x18000 - 0x187F8 */
+    u64		p_wr_req_upper[256];		/* 0x18800 - 0x18FF8 */
+    u64		p_wr_req_parity[256];		/* 0x19000 - 0x197F8 */
 
     char		_pad_019800[0x20000 - 0x019800];
 
     /* 0x020000-0x027FFF -- PCI Device Configuration Spaces */
     union {
-	uint8_t		c[0x1000 / 1];			/* 0x02{0000,,,7FFF} */
-	uint16_t	s[0x1000 / 2];			/* 0x02{0000,,,7FFF} */
-	uint32_t	l[0x1000 / 4];			/* 0x02{0000,,,7FFF} */
-	uint64_t	d[0x1000 / 8];			/* 0x02{0000,,,7FFF} */
+	u8		c[0x1000 / 1];			/* 0x02{0000,,,7FFF} */
+	u16	s[0x1000 / 2];			/* 0x02{0000,,,7FFF} */
+	u32	l[0x1000 / 4];			/* 0x02{0000,,,7FFF} */
+	u64	d[0x1000 / 8];			/* 0x02{0000,,,7FFF} */
 	union {
-	    uint8_t	c[0x100 / 1];
-	    uint16_t	s[0x100 / 2];
-	    uint32_t	l[0x100 / 4];
-	    uint64_t	d[0x100 / 8];
+	    u8	c[0x100 / 1];
+	    u16	s[0x100 / 2];
+	    u32	l[0x100 / 4];
+	    u64	d[0x100 / 8];
 	} f[8];
     } p_type0_cfg_dev[8];				/* 0x02{0000,,,7FFF} */
 
     /* 0x028000-0x028FFF -- PCI Type 1 Configuration Space */
     union {
-	uint8_t		c[0x1000 / 1];			/* 0x028000-0x029000 */
-	uint16_t	s[0x1000 / 2];			/* 0x028000-0x029000 */
-	uint32_t	l[0x1000 / 4];			/* 0x028000-0x029000 */
-	uint64_t	d[0x1000 / 8];			/* 0x028000-0x029000 */
+	u8		c[0x1000 / 1];			/* 0x028000-0x029000 */
+	u16	s[0x1000 / 2];			/* 0x028000-0x029000 */
+	u32	l[0x1000 / 4];			/* 0x028000-0x029000 */
+	u64	d[0x1000 / 8];			/* 0x028000-0x029000 */
 	union {
-	    uint8_t	c[0x100 / 1];
-	    uint16_t	s[0x100 / 2];
-	    uint32_t	l[0x100 / 4];
-	    uint64_t	d[0x100 / 8];
+	    u8	c[0x100 / 1];
+	    u16	s[0x100 / 2];
+	    u32	l[0x100 / 4];
+	    u64	d[0x100 / 8];
 	} f[8];
     } p_type1_cfg;					/* 0x028000-0x029000 */
 
@@ -241,20 +241,20 @@ struct pic {
 
     /* 0x030000-0x030007 -- PCI Interrupt Acknowledge Cycle */
     union {
-	uint8_t		c[8 / 1];
-	uint16_t	s[8 / 2];
-	uint32_t	l[8 / 4];
-	uint64_t	d[8 / 8];
+	u8		c[8 / 1];
+	u16	s[8 / 2];
+	u32	l[8 / 4];
+	u64	d[8 / 8];
     } p_pci_iack;					/* 0x030000-0x030007 */
 
     char		_pad_030007[0x040000-0x030008];
 
     /* 0x040000-0x030007 -- PCIX Special Cycle */
     union {
-	uint8_t		c[8 / 1];
-	uint16_t	s[8 / 2];
-	uint32_t	l[8 / 4];
-	uint64_t	d[8 / 8];
+	u8		c[8 / 1];
+	u16	s[8 / 2];
+	u32	l[8 / 4];
+	u64	d[8 / 8];
     } p_pcix_cycle;					/* 0x040000-0x040007 */
 };
 
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/shubio.h linux-2.6.16-rc1/include/asm-ia64/sn/shubio.h
--- linux-2.6.15-git12/include/asm-ia64/sn/shubio.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/shubio.h	2006-01-17 08:22:53.060383699 +0000
@@ -227,13 +227,13 @@
  ************************************************************************/
 
 typedef union ii_wid_u {
-	uint64_t ii_wid_regval;
+	u64 ii_wid_regval;
 	struct {
-		uint64_t w_rsvd_1:1;
-		uint64_t w_mfg_num:11;
-		uint64_t w_part_num:16;
-		uint64_t w_rev_num:4;
-		uint64_t w_rsvd:32;
+		u64 w_rsvd_1:1;
+		u64 w_mfg_num:11;
+		u64 w_part_num:16;
+		u64 w_rev_num:4;
+		u64 w_rsvd:32;
 	} ii_wid_fld_s;
 } ii_wid_u_t;
 
@@ -246,18 +246,18 @@ typedef union ii_wid_u {
  ************************************************************************/
 
 typedef union ii_wstat_u {
-	uint64_t ii_wstat_regval;
+	u64 ii_wstat_regval;
 	struct {
-		uint64_t w_pending:4;
-		uint64_t w_xt_crd_to:1;
-		uint64_t w_xt_tail_to:1;
-		uint64_t w_rsvd_3:3;
-		uint64_t w_tx_mx_rty:1;
-		uint64_t w_rsvd_2:6;
-		uint64_t w_llp_tx_cnt:8;
-		uint64_t w_rsvd_1:8;
-		uint64_t w_crazy:1;
-		uint64_t w_rsvd:31;
+		u64 w_pending:4;
+		u64 w_xt_crd_to:1;
+		u64 w_xt_tail_to:1;
+		u64 w_rsvd_3:3;
+		u64 w_tx_mx_rty:1;
+		u64 w_rsvd_2:6;
+		u64 w_llp_tx_cnt:8;
+		u64 w_rsvd_1:8;
+		u64 w_crazy:1;
+		u64 w_rsvd:31;
 	} ii_wstat_fld_s;
 } ii_wstat_u_t;
 
@@ -269,16 +269,16 @@ typedef union ii_wstat_u {
  ************************************************************************/
 
 typedef union ii_wcr_u {
-	uint64_t ii_wcr_regval;
+	u64 ii_wcr_regval;
 	struct {
-		uint64_t w_wid:4;
-		uint64_t w_tag:1;
-		uint64_t w_rsvd_1:8;
-		uint64_t w_dst_crd:3;
-		uint64_t w_f_bad_pkt:1;
-		uint64_t w_dir_con:1;
-		uint64_t w_e_thresh:5;
-		uint64_t w_rsvd:41;
+		u64 w_wid:4;
+		u64 w_tag:1;
+		u64 w_rsvd_1:8;
+		u64 w_dst_crd:3;
+		u64 w_f_bad_pkt:1;
+		u64 w_dir_con:1;
+		u64 w_e_thresh:5;
+		u64 w_rsvd:41;
 	} ii_wcr_fld_s;
 } ii_wcr_u_t;
 
@@ -310,9 +310,9 @@ typedef union ii_wcr_u {
  ************************************************************************/
 
 typedef union ii_ilapr_u {
-	uint64_t ii_ilapr_regval;
+	u64 ii_ilapr_regval;
 	struct {
-		uint64_t i_region:64;
+		u64 i_region:64;
 	} ii_ilapr_fld_s;
 } ii_ilapr_u_t;
 
@@ -330,9 +330,9 @@ typedef union ii_ilapr_u {
  ************************************************************************/
 
 typedef union ii_ilapo_u {
-	uint64_t ii_ilapo_regval;
+	u64 ii_ilapo_regval;
 	struct {
-		uint64_t i_io_ovrride:64;
+		u64 i_io_ovrride:64;
 	} ii_ilapo_fld_s;
 } ii_ilapo_u_t;
 
@@ -344,12 +344,12 @@ typedef union ii_ilapo_u {
  ************************************************************************/
 
 typedef union ii_iowa_u {
-	uint64_t ii_iowa_regval;
+	u64 ii_iowa_regval;
 	struct {
-		uint64_t i_w0_oac:1;
-		uint64_t i_rsvd_1:7;
-		uint64_t i_wx_oac:8;
-		uint64_t i_rsvd:48;
+		u64 i_w0_oac:1;
+		u64 i_rsvd_1:7;
+		u64 i_wx_oac:8;
+		u64 i_rsvd:48;
 	} ii_iowa_fld_s;
 } ii_iowa_u_t;
 
@@ -363,12 +363,12 @@ typedef union ii_iowa_u {
  ************************************************************************/
 
 typedef union ii_iiwa_u {
-	uint64_t ii_iiwa_regval;
+	u64 ii_iiwa_regval;
 	struct {
-		uint64_t i_w0_iac:1;
-		uint64_t i_rsvd_1:7;
-		uint64_t i_wx_iac:8;
-		uint64_t i_rsvd:48;
+		u64 i_w0_iac:1;
+		u64 i_rsvd_1:7;
+		u64 i_wx_iac:8;
+		u64 i_rsvd:48;
 	} ii_iiwa_fld_s;
 } ii_iiwa_u_t;
 
@@ -392,16 +392,16 @@ typedef union ii_iiwa_u {
  ************************************************************************/
 
 typedef union ii_iidem_u {
-	uint64_t ii_iidem_regval;
+	u64 ii_iidem_regval;
 	struct {
-		uint64_t i_w8_dxs:8;
-		uint64_t i_w9_dxs:8;
-		uint64_t i_wa_dxs:8;
-		uint64_t i_wb_dxs:8;
-		uint64_t i_wc_dxs:8;
-		uint64_t i_wd_dxs:8;
-		uint64_t i_we_dxs:8;
-		uint64_t i_wf_dxs:8;
+		u64 i_w8_dxs:8;
+		u64 i_w9_dxs:8;
+		u64 i_wa_dxs:8;
+		u64 i_wb_dxs:8;
+		u64 i_wc_dxs:8;
+		u64 i_wd_dxs:8;
+		u64 i_we_dxs:8;
+		u64 i_wf_dxs:8;
 	} ii_iidem_fld_s;
 } ii_iidem_u_t;
 
@@ -413,22 +413,22 @@ typedef union ii_iidem_u {
  ************************************************************************/
 
 typedef union ii_ilcsr_u {
-	uint64_t ii_ilcsr_regval;
+	u64 ii_ilcsr_regval;
 	struct {
-		uint64_t i_nullto:6;
-		uint64_t i_rsvd_4:2;
-		uint64_t i_wrmrst:1;
-		uint64_t i_rsvd_3:1;
-		uint64_t i_llp_en:1;
-		uint64_t i_bm8:1;
-		uint64_t i_llp_stat:2;
-		uint64_t i_remote_power:1;
-		uint64_t i_rsvd_2:1;
-		uint64_t i_maxrtry:10;
-		uint64_t i_d_avail_sel:2;
-		uint64_t i_rsvd_1:4;
-		uint64_t i_maxbrst:10;
-		uint64_t i_rsvd:22;
+		u64 i_nullto:6;
+		u64 i_rsvd_4:2;
+		u64 i_wrmrst:1;
+		u64 i_rsvd_3:1;
+		u64 i_llp_en:1;
+		u64 i_bm8:1;
+		u64 i_llp_stat:2;
+		u64 i_remote_power:1;
+		u64 i_rsvd_2:1;
+		u64 i_maxrtry:10;
+		u64 i_d_avail_sel:2;
+		u64 i_rsvd_1:4;
+		u64 i_maxbrst:10;
+		u64 i_rsvd:22;
 
 	} ii_ilcsr_fld_s;
 } ii_ilcsr_u_t;
@@ -441,11 +441,11 @@ typedef union ii_ilcsr_u {
  ************************************************************************/
 
 typedef union ii_illr_u {
-	uint64_t ii_illr_regval;
+	u64 ii_illr_regval;
 	struct {
-		uint64_t i_sn_cnt:16;
-		uint64_t i_cb_cnt:16;
-		uint64_t i_rsvd:32;
+		u64 i_sn_cnt:16;
+		u64 i_cb_cnt:16;
+		u64 i_rsvd:32;
 	} ii_illr_fld_s;
 } ii_illr_u_t;
 
@@ -464,19 +464,19 @@ typedef union ii_illr_u {
  ************************************************************************/
 
 typedef union ii_iidsr_u {
-	uint64_t ii_iidsr_regval;
+	u64 ii_iidsr_regval;
 	struct {
-		uint64_t i_level:8;
-		uint64_t i_pi_id:1;
-		uint64_t i_node:11;
-		uint64_t i_rsvd_3:4;
-		uint64_t i_enable:1;
-		uint64_t i_rsvd_2:3;
-		uint64_t i_int_sent:2;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_pi0_forward_int:1;
-		uint64_t i_pi1_forward_int:1;
-		uint64_t i_rsvd:30;
+		u64 i_level:8;
+		u64 i_pi_id:1;
+		u64 i_node:11;
+		u64 i_rsvd_3:4;
+		u64 i_enable:1;
+		u64 i_rsvd_2:3;
+		u64 i_int_sent:2;
+		u64 i_rsvd_1:2;
+		u64 i_pi0_forward_int:1;
+		u64 i_pi1_forward_int:1;
+		u64 i_rsvd:30;
 	} ii_iidsr_fld_s;
 } ii_iidsr_u_t;
 
@@ -492,13 +492,13 @@ typedef union ii_iidsr_u {
  ************************************************************************/
 
 typedef union ii_igfx0_u {
-	uint64_t ii_igfx0_regval;
+	u64 ii_igfx0_regval;
 	struct {
-		uint64_t i_w_num:4;
-		uint64_t i_pi_id:1;
-		uint64_t i_n_num:12;
-		uint64_t i_p_num:1;
-		uint64_t i_rsvd:46;
+		u64 i_w_num:4;
+		u64 i_pi_id:1;
+		u64 i_n_num:12;
+		u64 i_p_num:1;
+		u64 i_rsvd:46;
 	} ii_igfx0_fld_s;
 } ii_igfx0_u_t;
 
@@ -514,13 +514,13 @@ typedef union ii_igfx0_u {
  ************************************************************************/
 
 typedef union ii_igfx1_u {
-	uint64_t ii_igfx1_regval;
+	u64 ii_igfx1_regval;
 	struct {
-		uint64_t i_w_num:4;
-		uint64_t i_pi_id:1;
-		uint64_t i_n_num:12;
-		uint64_t i_p_num:1;
-		uint64_t i_rsvd:46;
+		u64 i_w_num:4;
+		u64 i_pi_id:1;
+		u64 i_n_num:12;
+		u64 i_p_num:1;
+		u64 i_rsvd:46;
 	} ii_igfx1_fld_s;
 } ii_igfx1_u_t;
 
@@ -532,9 +532,9 @@ typedef union ii_igfx1_u {
  ************************************************************************/
 
 typedef union ii_iscr0_u {
-	uint64_t ii_iscr0_regval;
+	u64 ii_iscr0_regval;
 	struct {
-		uint64_t i_scratch:64;
+		u64 i_scratch:64;
 	} ii_iscr0_fld_s;
 } ii_iscr0_u_t;
 
@@ -546,9 +546,9 @@ typedef union ii_iscr0_u {
  ************************************************************************/
 
 typedef union ii_iscr1_u {
-	uint64_t ii_iscr1_regval;
+	u64 ii_iscr1_regval;
 	struct {
-		uint64_t i_scratch:64;
+		u64 i_scratch:64;
 	} ii_iscr1_fld_s;
 } ii_iscr1_u_t;
 
@@ -580,13 +580,13 @@ typedef union ii_iscr1_u {
  ************************************************************************/
 
 typedef union ii_itte1_u {
-	uint64_t ii_itte1_regval;
+	u64 ii_itte1_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte1_fld_s;
 } ii_itte1_u_t;
 
@@ -618,13 +618,13 @@ typedef union ii_itte1_u {
  ************************************************************************/
 
 typedef union ii_itte2_u {
-	uint64_t ii_itte2_regval;
+	u64 ii_itte2_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte2_fld_s;
 } ii_itte2_u_t;
 
@@ -656,13 +656,13 @@ typedef union ii_itte2_u {
  ************************************************************************/
 
 typedef union ii_itte3_u {
-	uint64_t ii_itte3_regval;
+	u64 ii_itte3_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte3_fld_s;
 } ii_itte3_u_t;
 
@@ -694,13 +694,13 @@ typedef union ii_itte3_u {
  ************************************************************************/
 
 typedef union ii_itte4_u {
-	uint64_t ii_itte4_regval;
+	u64 ii_itte4_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte4_fld_s;
 } ii_itte4_u_t;
 
@@ -732,13 +732,13 @@ typedef union ii_itte4_u {
  ************************************************************************/
 
 typedef union ii_itte5_u {
-	uint64_t ii_itte5_regval;
+	u64 ii_itte5_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte5_fld_s;
 } ii_itte5_u_t;
 
@@ -770,13 +770,13 @@ typedef union ii_itte5_u {
  ************************************************************************/
 
 typedef union ii_itte6_u {
-	uint64_t ii_itte6_regval;
+	u64 ii_itte6_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte6_fld_s;
 } ii_itte6_u_t;
 
@@ -808,13 +808,13 @@ typedef union ii_itte6_u {
  ************************************************************************/
 
 typedef union ii_itte7_u {
-	uint64_t ii_itte7_regval;
+	u64 ii_itte7_regval;
 	struct {
-		uint64_t i_offset:5;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_w_num:4;
-		uint64_t i_iosp:1;
-		uint64_t i_rsvd:51;
+		u64 i_offset:5;
+		u64 i_rsvd_1:3;
+		u64 i_w_num:4;
+		u64 i_iosp:1;
+		u64 i_rsvd:51;
 	} ii_itte7_fld_s;
 } ii_itte7_u_t;
 
@@ -843,22 +843,22 @@ typedef union ii_itte7_u {
  ************************************************************************/
 
 typedef union ii_iprb0_u {
-	uint64_t ii_iprb0_regval;
+	u64 ii_iprb0_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprb0_fld_s;
 } ii_iprb0_u_t;
 
@@ -887,22 +887,22 @@ typedef union ii_iprb0_u {
  ************************************************************************/
 
 typedef union ii_iprb8_u {
-	uint64_t ii_iprb8_regval;
+	u64 ii_iprb8_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprb8_fld_s;
 } ii_iprb8_u_t;
 
@@ -931,22 +931,22 @@ typedef union ii_iprb8_u {
  ************************************************************************/
 
 typedef union ii_iprb9_u {
-	uint64_t ii_iprb9_regval;
+	u64 ii_iprb9_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprb9_fld_s;
 } ii_iprb9_u_t;
 
@@ -975,22 +975,22 @@ typedef union ii_iprb9_u {
  ************************************************************************/
 
 typedef union ii_iprba_u {
-	uint64_t ii_iprba_regval;
+	u64 ii_iprba_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprba_fld_s;
 } ii_iprba_u_t;
 
@@ -1019,22 +1019,22 @@ typedef union ii_iprba_u {
  ************************************************************************/
 
 typedef union ii_iprbb_u {
-	uint64_t ii_iprbb_regval;
+	u64 ii_iprbb_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprbb_fld_s;
 } ii_iprbb_u_t;
 
@@ -1063,22 +1063,22 @@ typedef union ii_iprbb_u {
  ************************************************************************/
 
 typedef union ii_iprbc_u {
-	uint64_t ii_iprbc_regval;
+	u64 ii_iprbc_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprbc_fld_s;
 } ii_iprbc_u_t;
 
@@ -1107,22 +1107,22 @@ typedef union ii_iprbc_u {
  ************************************************************************/
 
 typedef union ii_iprbd_u {
-	uint64_t ii_iprbd_regval;
+	u64 ii_iprbd_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprbd_fld_s;
 } ii_iprbd_u_t;
 
@@ -1151,22 +1151,22 @@ typedef union ii_iprbd_u {
  ************************************************************************/
 
 typedef union ii_iprbe_u {
-	uint64_t ii_iprbe_regval;
+	u64 ii_iprbe_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprbe_fld_s;
 } ii_iprbe_u_t;
 
@@ -1195,22 +1195,22 @@ typedef union ii_iprbe_u {
  ************************************************************************/
 
 typedef union ii_iprbf_u {
-	uint64_t ii_iprbf_regval;
+	u64 ii_iprbf_regval;
 	struct {
-		uint64_t i_c:8;
-		uint64_t i_na:14;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_nb:14;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_m:2;
-		uint64_t i_f:1;
-		uint64_t i_of_cnt:5;
-		uint64_t i_error:1;
-		uint64_t i_rd_to:1;
-		uint64_t i_spur_wr:1;
-		uint64_t i_spur_rd:1;
-		uint64_t i_rsvd:11;
-		uint64_t i_mult_err:1;
+		u64 i_c:8;
+		u64 i_na:14;
+		u64 i_rsvd_2:2;
+		u64 i_nb:14;
+		u64 i_rsvd_1:2;
+		u64 i_m:2;
+		u64 i_f:1;
+		u64 i_of_cnt:5;
+		u64 i_error:1;
+		u64 i_rd_to:1;
+		u64 i_spur_wr:1;
+		u64 i_spur_rd:1;
+		u64 i_rsvd:11;
+		u64 i_mult_err:1;
 	} ii_iprbe_fld_s;
 } ii_iprbf_u_t;
 
@@ -1232,10 +1232,10 @@ typedef union ii_iprbf_u {
  ************************************************************************/
 
 typedef union ii_ixcc_u {
-	uint64_t ii_ixcc_regval;
+	u64 ii_ixcc_regval;
 	struct {
-		uint64_t i_time_out:26;
-		uint64_t i_rsvd:38;
+		u64 i_time_out:26;
+		u64 i_rsvd:38;
 	} ii_ixcc_fld_s;
 } ii_ixcc_u_t;
 
@@ -1256,16 +1256,16 @@ typedef union ii_ixcc_u {
  ************************************************************************/
 
 typedef union ii_imem_u {
-	uint64_t ii_imem_regval;
+	u64 ii_imem_regval;
 	struct {
-		uint64_t i_w0_esd:1;
-		uint64_t i_rsvd_3:3;
-		uint64_t i_b0_esd:1;
-		uint64_t i_rsvd_2:3;
-		uint64_t i_b1_esd:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_clr_precise:1;
-		uint64_t i_rsvd:51;
+		u64 i_w0_esd:1;
+		u64 i_rsvd_3:3;
+		u64 i_b0_esd:1;
+		u64 i_rsvd_2:3;
+		u64 i_b1_esd:1;
+		u64 i_rsvd_1:3;
+		u64 i_clr_precise:1;
+		u64 i_rsvd:51;
 	} ii_imem_fld_s;
 } ii_imem_u_t;
 
@@ -1294,13 +1294,13 @@ typedef union ii_imem_u {
  ************************************************************************/
 
 typedef union ii_ixtt_u {
-	uint64_t ii_ixtt_regval;
+	u64 ii_ixtt_regval;
 	struct {
-		uint64_t i_tail_to:26;
-		uint64_t i_rsvd_1:6;
-		uint64_t i_rrsp_ps:23;
-		uint64_t i_rrsp_to:5;
-		uint64_t i_rsvd:4;
+		u64 i_tail_to:26;
+		u64 i_rsvd_1:6;
+		u64 i_rrsp_ps:23;
+		u64 i_rrsp_to:5;
+		u64 i_rsvd:4;
 	} ii_ixtt_fld_s;
 } ii_ixtt_u_t;
 
@@ -1316,37 +1316,37 @@ typedef union ii_ixtt_u {
  ************************************************************************/
 
 typedef union ii_ieclr_u {
-	uint64_t ii_ieclr_regval;
+	u64 ii_ieclr_regval;
 	struct {
-		uint64_t i_e_prb_0:1;
-		uint64_t i_rsvd:7;
-		uint64_t i_e_prb_8:1;
-		uint64_t i_e_prb_9:1;
-		uint64_t i_e_prb_a:1;
-		uint64_t i_e_prb_b:1;
-		uint64_t i_e_prb_c:1;
-		uint64_t i_e_prb_d:1;
-		uint64_t i_e_prb_e:1;
-		uint64_t i_e_prb_f:1;
-		uint64_t i_e_crazy:1;
-		uint64_t i_e_bte_0:1;
-		uint64_t i_e_bte_1:1;
-		uint64_t i_reserved_1:10;
-		uint64_t i_spur_rd_hdr:1;
-		uint64_t i_cam_intr_to:1;
-		uint64_t i_cam_overflow:1;
-		uint64_t i_cam_read_miss:1;
-		uint64_t i_ioq_rep_underflow:1;
-		uint64_t i_ioq_req_underflow:1;
-		uint64_t i_ioq_rep_overflow:1;
-		uint64_t i_ioq_req_overflow:1;
-		uint64_t i_iiq_rep_overflow:1;
-		uint64_t i_iiq_req_overflow:1;
-		uint64_t i_ii_xn_rep_cred_overflow:1;
-		uint64_t i_ii_xn_req_cred_overflow:1;
-		uint64_t i_ii_xn_invalid_cmd:1;
-		uint64_t i_xn_ii_invalid_cmd:1;
-		uint64_t i_reserved_2:21;
+		u64 i_e_prb_0:1;
+		u64 i_rsvd:7;
+		u64 i_e_prb_8:1;
+		u64 i_e_prb_9:1;
+		u64 i_e_prb_a:1;
+		u64 i_e_prb_b:1;
+		u64 i_e_prb_c:1;
+		u64 i_e_prb_d:1;
+		u64 i_e_prb_e:1;
+		u64 i_e_prb_f:1;
+		u64 i_e_crazy:1;
+		u64 i_e_bte_0:1;
+		u64 i_e_bte_1:1;
+		u64 i_reserved_1:10;
+		u64 i_spur_rd_hdr:1;
+		u64 i_cam_intr_to:1;
+		u64 i_cam_overflow:1;
+		u64 i_cam_read_miss:1;
+		u64 i_ioq_rep_underflow:1;
+		u64 i_ioq_req_underflow:1;
+		u64 i_ioq_rep_overflow:1;
+		u64 i_ioq_req_overflow:1;
+		u64 i_iiq_rep_overflow:1;
+		u64 i_iiq_req_overflow:1;
+		u64 i_ii_xn_rep_cred_overflow:1;
+		u64 i_ii_xn_req_cred_overflow:1;
+		u64 i_ii_xn_invalid_cmd:1;
+		u64 i_xn_ii_invalid_cmd:1;
+		u64 i_reserved_2:21;
 	} ii_ieclr_fld_s;
 } ii_ieclr_u_t;
 
@@ -1360,12 +1360,12 @@ typedef union ii_ieclr_u {
  ************************************************************************/
 
 typedef union ii_ibcr_u {
-	uint64_t ii_ibcr_regval;
+	u64 ii_ibcr_regval;
 	struct {
-		uint64_t i_count:4;
-		uint64_t i_rsvd_1:4;
-		uint64_t i_soft_reset:1;
-		uint64_t i_rsvd:55;
+		u64 i_count:4;
+		u64 i_rsvd_1:4;
+		u64 i_soft_reset:1;
+		u64 i_rsvd:55;
 	} ii_ibcr_fld_s;
 } ii_ibcr_u_t;
 
@@ -1399,22 +1399,22 @@ typedef union ii_ibcr_u {
  ************************************************************************/
 
 typedef union ii_ixsm_u {
-	uint64_t ii_ixsm_regval;
+	u64 ii_ixsm_regval;
 	struct {
-		uint64_t i_byte_en:32;
-		uint64_t i_reserved:1;
-		uint64_t i_tag:3;
-		uint64_t i_alt_pactyp:4;
-		uint64_t i_bo:1;
-		uint64_t i_error:1;
-		uint64_t i_vbpm:1;
-		uint64_t i_gbr:1;
-		uint64_t i_ds:2;
-		uint64_t i_ct:1;
-		uint64_t i_tnum:5;
-		uint64_t i_pactyp:4;
-		uint64_t i_sidn:4;
-		uint64_t i_didn:4;
+		u64 i_byte_en:32;
+		u64 i_reserved:1;
+		u64 i_tag:3;
+		u64 i_alt_pactyp:4;
+		u64 i_bo:1;
+		u64 i_error:1;
+		u64 i_vbpm:1;
+		u64 i_gbr:1;
+		u64 i_ds:2;
+		u64 i_ct:1;
+		u64 i_tnum:5;
+		u64 i_pactyp:4;
+		u64 i_sidn:4;
+		u64 i_didn:4;
 	} ii_ixsm_fld_s;
 } ii_ixsm_u_t;
 
@@ -1426,11 +1426,11 @@ typedef union ii_ixsm_u {
  ************************************************************************/
 
 typedef union ii_ixss_u {
-	uint64_t ii_ixss_regval;
+	u64 ii_ixss_regval;
 	struct {
-		uint64_t i_sideband:8;
-		uint64_t i_rsvd:55;
-		uint64_t i_valid:1;
+		u64 i_sideband:8;
+		u64 i_rsvd:55;
+		u64 i_valid:1;
 	} ii_ixss_fld_s;
 } ii_ixss_u_t;
 
@@ -1447,17 +1447,17 @@ typedef union ii_ixss_u {
  ************************************************************************/
 
 typedef union ii_ilct_u {
-	uint64_t ii_ilct_regval;
+	u64 ii_ilct_regval;
 	struct {
-		uint64_t i_test_seed:20;
-		uint64_t i_test_mask:8;
-		uint64_t i_test_data:20;
-		uint64_t i_test_valid:1;
-		uint64_t i_test_cberr:1;
-		uint64_t i_test_flit:3;
-		uint64_t i_test_clear:1;
-		uint64_t i_test_err_capture:1;
-		uint64_t i_rsvd:9;
+		u64 i_test_seed:20;
+		u64 i_test_mask:8;
+		u64 i_test_data:20;
+		u64 i_test_valid:1;
+		u64 i_test_cberr:1;
+		u64 i_test_flit:3;
+		u64 i_test_clear:1;
+		u64 i_test_err_capture:1;
+		u64 i_rsvd:9;
 	} ii_ilct_fld_s;
 } ii_ilct_u_t;
 
@@ -1482,20 +1482,20 @@ typedef union ii_ilct_u {
  ************************************************************************/
 
 typedef union ii_iieph1_u {
-	uint64_t ii_iieph1_regval;
+	u64 ii_iieph1_regval;
 	struct {
-		uint64_t i_command:7;
-		uint64_t i_rsvd_5:1;
-		uint64_t i_suppl:14;
-		uint64_t i_rsvd_4:1;
-		uint64_t i_source:14;
-		uint64_t i_rsvd_3:1;
-		uint64_t i_err_type:4;
-		uint64_t i_rsvd_2:4;
-		uint64_t i_overrun:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_valid:1;
-		uint64_t i_rsvd:13;
+		u64 i_command:7;
+		u64 i_rsvd_5:1;
+		u64 i_suppl:14;
+		u64 i_rsvd_4:1;
+		u64 i_source:14;
+		u64 i_rsvd_3:1;
+		u64 i_err_type:4;
+		u64 i_rsvd_2:4;
+		u64 i_overrun:1;
+		u64 i_rsvd_1:3;
+		u64 i_valid:1;
+		u64 i_rsvd:13;
 	} ii_iieph1_fld_s;
 } ii_iieph1_u_t;
 
@@ -1511,13 +1511,13 @@ typedef union ii_iieph1_u {
  ************************************************************************/
 
 typedef union ii_iieph2_u {
-	uint64_t ii_iieph2_regval;
+	u64 ii_iieph2_regval;
 	struct {
-		uint64_t i_rsvd_0:3;
-		uint64_t i_address:47;
-		uint64_t i_rsvd_1:10;
-		uint64_t i_tail:1;
-		uint64_t i_rsvd:3;
+		u64 i_rsvd_0:3;
+		u64 i_address:47;
+		u64 i_rsvd_1:10;
+		u64 i_tail:1;
+		u64 i_rsvd:3;
 	} ii_iieph2_fld_s;
 } ii_iieph2_u_t;
 
@@ -1532,9 +1532,9 @@ typedef union ii_iieph2_u {
  ************************************************************************/
 
 typedef union ii_islapr_u {
-	uint64_t ii_islapr_regval;
+	u64 ii_islapr_regval;
 	struct {
-		uint64_t i_region:64;
+		u64 i_region:64;
 	} ii_islapr_fld_s;
 } ii_islapr_u_t;
 
@@ -1547,10 +1547,10 @@ typedef union ii_islapr_u {
  ************************************************************************/
 
 typedef union ii_islapo_u {
-	uint64_t ii_islapo_regval;
+	u64 ii_islapo_regval;
 	struct {
-		uint64_t i_io_sbx_ovrride:56;
-		uint64_t i_rsvd:8;
+		u64 i_io_sbx_ovrride:56;
+		u64 i_rsvd:8;
 	} ii_islapo_fld_s;
 } ii_islapo_u_t;
 
@@ -1563,14 +1563,14 @@ typedef union ii_islapo_u {
  ************************************************************************/
 
 typedef union ii_iwi_u {
-	uint64_t ii_iwi_regval;
+	u64 ii_iwi_regval;
 	struct {
-		uint64_t i_prescale:24;
-		uint64_t i_rsvd:8;
-		uint64_t i_timeout:8;
-		uint64_t i_rsvd1:8;
-		uint64_t i_intrpt_retry_period:8;
-		uint64_t i_rsvd2:8;
+		u64 i_prescale:24;
+		u64 i_rsvd:8;
+		u64 i_timeout:8;
+		u64 i_rsvd1:8;
+		u64 i_intrpt_retry_period:8;
+		u64 i_rsvd2:8;
 	} ii_iwi_fld_s;
 } ii_iwi_u_t;
 
@@ -1582,26 +1582,26 @@ typedef union ii_iwi_u {
  ************************************************************************/
 
 typedef union ii_iwel_u {
-	uint64_t ii_iwel_regval;
+	u64 ii_iwel_regval;
 	struct {
-		uint64_t i_intr_timed_out:1;
-		uint64_t i_rsvd:7;
-		uint64_t i_cam_overflow:1;
-		uint64_t i_cam_read_miss:1;
-		uint64_t i_rsvd1:2;
-		uint64_t i_ioq_rep_underflow:1;
-		uint64_t i_ioq_req_underflow:1;
-		uint64_t i_ioq_rep_overflow:1;
-		uint64_t i_ioq_req_overflow:1;
-		uint64_t i_iiq_rep_overflow:1;
-		uint64_t i_iiq_req_overflow:1;
-		uint64_t i_rsvd2:6;
-		uint64_t i_ii_xn_rep_cred_over_under:1;
-		uint64_t i_ii_xn_req_cred_over_under:1;
-		uint64_t i_rsvd3:6;
-		uint64_t i_ii_xn_invalid_cmd:1;
-		uint64_t i_xn_ii_invalid_cmd:1;
-		uint64_t i_rsvd4:30;
+		u64 i_intr_timed_out:1;
+		u64 i_rsvd:7;
+		u64 i_cam_overflow:1;
+		u64 i_cam_read_miss:1;
+		u64 i_rsvd1:2;
+		u64 i_ioq_rep_underflow:1;
+		u64 i_ioq_req_underflow:1;
+		u64 i_ioq_rep_overflow:1;
+		u64 i_ioq_req_overflow:1;
+		u64 i_iiq_rep_overflow:1;
+		u64 i_iiq_req_overflow:1;
+		u64 i_rsvd2:6;
+		u64 i_ii_xn_rep_cred_over_under:1;
+		u64 i_ii_xn_req_cred_over_under:1;
+		u64 i_rsvd3:6;
+		u64 i_ii_xn_invalid_cmd:1;
+		u64 i_xn_ii_invalid_cmd:1;
+		u64 i_rsvd4:30;
 	} ii_iwel_fld_s;
 } ii_iwel_u_t;
 
@@ -1612,22 +1612,22 @@ typedef union ii_iwel_u {
  ************************************************************************/
 
 typedef union ii_iwc_u {
-	uint64_t ii_iwc_regval;
+	u64 ii_iwc_regval;
 	struct {
-		uint64_t i_dma_byte_swap:1;
-		uint64_t i_rsvd:3;
-		uint64_t i_cam_read_lines_reset:1;
-		uint64_t i_rsvd1:3;
-		uint64_t i_ii_xn_cred_over_under_log:1;
-		uint64_t i_rsvd2:19;
-		uint64_t i_xn_rep_iq_depth:5;
-		uint64_t i_rsvd3:3;
-		uint64_t i_xn_req_iq_depth:5;
-		uint64_t i_rsvd4:3;
-		uint64_t i_iiq_depth:6;
-		uint64_t i_rsvd5:12;
-		uint64_t i_force_rep_cred:1;
-		uint64_t i_force_req_cred:1;
+		u64 i_dma_byte_swap:1;
+		u64 i_rsvd:3;
+		u64 i_cam_read_lines_reset:1;
+		u64 i_rsvd1:3;
+		u64 i_ii_xn_cred_over_under_log:1;
+		u64 i_rsvd2:19;
+		u64 i_xn_rep_iq_depth:5;
+		u64 i_rsvd3:3;
+		u64 i_xn_req_iq_depth:5;
+		u64 i_rsvd4:3;
+		u64 i_iiq_depth:6;
+		u64 i_rsvd5:12;
+		u64 i_force_rep_cred:1;
+		u64 i_force_req_cred:1;
 	} ii_iwc_fld_s;
 } ii_iwc_u_t;
 
@@ -1638,12 +1638,12 @@ typedef union ii_iwc_u {
  ************************************************************************/
 
 typedef union ii_iws_u {
-	uint64_t ii_iws_regval;
+	u64 ii_iws_regval;
 	struct {
-		uint64_t i_xn_rep_iq_credits:5;
-		uint64_t i_rsvd:3;
-		uint64_t i_xn_req_iq_credits:5;
-		uint64_t i_rsvd1:51;
+		u64 i_xn_rep_iq_credits:5;
+		u64 i_rsvd:3;
+		u64 i_xn_req_iq_credits:5;
+		u64 i_rsvd1:51;
 	} ii_iws_fld_s;
 } ii_iws_u_t;
 
@@ -1654,26 +1654,26 @@ typedef union ii_iws_u {
  ************************************************************************/
 
 typedef union ii_iweim_u {
-	uint64_t ii_iweim_regval;
+	u64 ii_iweim_regval;
 	struct {
-		uint64_t i_intr_timed_out:1;
-		uint64_t i_rsvd:7;
-		uint64_t i_cam_overflow:1;
-		uint64_t i_cam_read_miss:1;
-		uint64_t i_rsvd1:2;
-		uint64_t i_ioq_rep_underflow:1;
-		uint64_t i_ioq_req_underflow:1;
-		uint64_t i_ioq_rep_overflow:1;
-		uint64_t i_ioq_req_overflow:1;
-		uint64_t i_iiq_rep_overflow:1;
-		uint64_t i_iiq_req_overflow:1;
-		uint64_t i_rsvd2:6;
-		uint64_t i_ii_xn_rep_cred_overflow:1;
-		uint64_t i_ii_xn_req_cred_overflow:1;
-		uint64_t i_rsvd3:6;
-		uint64_t i_ii_xn_invalid_cmd:1;
-		uint64_t i_xn_ii_invalid_cmd:1;
-		uint64_t i_rsvd4:30;
+		u64 i_intr_timed_out:1;
+		u64 i_rsvd:7;
+		u64 i_cam_overflow:1;
+		u64 i_cam_read_miss:1;
+		u64 i_rsvd1:2;
+		u64 i_ioq_rep_underflow:1;
+		u64 i_ioq_req_underflow:1;
+		u64 i_ioq_rep_overflow:1;
+		u64 i_ioq_req_overflow:1;
+		u64 i_iiq_rep_overflow:1;
+		u64 i_iiq_req_overflow:1;
+		u64 i_rsvd2:6;
+		u64 i_ii_xn_rep_cred_overflow:1;
+		u64 i_ii_xn_req_cred_overflow:1;
+		u64 i_rsvd3:6;
+		u64 i_ii_xn_invalid_cmd:1;
+		u64 i_xn_ii_invalid_cmd:1;
+		u64 i_rsvd4:30;
 	} ii_iweim_fld_s;
 } ii_iweim_u_t;
 
@@ -1688,13 +1688,13 @@ typedef union ii_iweim_u {
  ************************************************************************/
 
 typedef union ii_ipca_u {
-	uint64_t ii_ipca_regval;
+	u64 ii_ipca_regval;
 	struct {
-		uint64_t i_wid:4;
-		uint64_t i_adjust:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_field:2;
-		uint64_t i_rsvd:54;
+		u64 i_wid:4;
+		u64 i_adjust:1;
+		u64 i_rsvd_1:3;
+		u64 i_field:2;
+		u64 i_rsvd:54;
 	} ii_ipca_fld_s;
 } ii_ipca_u_t;
 
@@ -1709,12 +1709,12 @@ typedef union ii_ipca_u {
  ************************************************************************/
 
 typedef union ii_iprte0a_u {
-	uint64_t ii_iprte0a_regval;
+	u64 ii_iprte0a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte0a_fld_s;
 } ii_iprte0a_u_t;
 
@@ -1729,12 +1729,12 @@ typedef union ii_iprte0a_u {
  ************************************************************************/
 
 typedef union ii_iprte1a_u {
-	uint64_t ii_iprte1a_regval;
+	u64 ii_iprte1a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte1a_fld_s;
 } ii_iprte1a_u_t;
 
@@ -1749,12 +1749,12 @@ typedef union ii_iprte1a_u {
  ************************************************************************/
 
 typedef union ii_iprte2a_u {
-	uint64_t ii_iprte2a_regval;
+	u64 ii_iprte2a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte2a_fld_s;
 } ii_iprte2a_u_t;
 
@@ -1769,12 +1769,12 @@ typedef union ii_iprte2a_u {
  ************************************************************************/
 
 typedef union ii_iprte3a_u {
-	uint64_t ii_iprte3a_regval;
+	u64 ii_iprte3a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte3a_fld_s;
 } ii_iprte3a_u_t;
 
@@ -1789,12 +1789,12 @@ typedef union ii_iprte3a_u {
  ************************************************************************/
 
 typedef union ii_iprte4a_u {
-	uint64_t ii_iprte4a_regval;
+	u64 ii_iprte4a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte4a_fld_s;
 } ii_iprte4a_u_t;
 
@@ -1809,12 +1809,12 @@ typedef union ii_iprte4a_u {
  ************************************************************************/
 
 typedef union ii_iprte5a_u {
-	uint64_t ii_iprte5a_regval;
+	u64 ii_iprte5a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte5a_fld_s;
 } ii_iprte5a_u_t;
 
@@ -1829,12 +1829,12 @@ typedef union ii_iprte5a_u {
  ************************************************************************/
 
 typedef union ii_iprte6a_u {
-	uint64_t ii_iprte6a_regval;
+	u64 ii_iprte6a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprte6a_fld_s;
 } ii_iprte6a_u_t;
 
@@ -1849,12 +1849,12 @@ typedef union ii_iprte6a_u {
  ************************************************************************/
 
 typedef union ii_iprte7a_u {
-	uint64_t ii_iprte7a_regval;
+	u64 ii_iprte7a_regval;
 	struct {
-		uint64_t i_rsvd_1:54;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:54;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} ii_iprtea7_fld_s;
 } ii_iprte7a_u_t;
 
@@ -1869,12 +1869,12 @@ typedef union ii_iprte7a_u {
  ************************************************************************/
 
 typedef union ii_iprte0b_u {
-	uint64_t ii_iprte0b_regval;
+	u64 ii_iprte0b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte0b_fld_s;
 } ii_iprte0b_u_t;
 
@@ -1889,12 +1889,12 @@ typedef union ii_iprte0b_u {
  ************************************************************************/
 
 typedef union ii_iprte1b_u {
-	uint64_t ii_iprte1b_regval;
+	u64 ii_iprte1b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte1b_fld_s;
 } ii_iprte1b_u_t;
 
@@ -1909,12 +1909,12 @@ typedef union ii_iprte1b_u {
  ************************************************************************/
 
 typedef union ii_iprte2b_u {
-	uint64_t ii_iprte2b_regval;
+	u64 ii_iprte2b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte2b_fld_s;
 } ii_iprte2b_u_t;
 
@@ -1929,12 +1929,12 @@ typedef union ii_iprte2b_u {
  ************************************************************************/
 
 typedef union ii_iprte3b_u {
-	uint64_t ii_iprte3b_regval;
+	u64 ii_iprte3b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte3b_fld_s;
 } ii_iprte3b_u_t;
 
@@ -1949,12 +1949,12 @@ typedef union ii_iprte3b_u {
  ************************************************************************/
 
 typedef union ii_iprte4b_u {
-	uint64_t ii_iprte4b_regval;
+	u64 ii_iprte4b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte4b_fld_s;
 } ii_iprte4b_u_t;
 
@@ -1969,12 +1969,12 @@ typedef union ii_iprte4b_u {
  ************************************************************************/
 
 typedef union ii_iprte5b_u {
-	uint64_t ii_iprte5b_regval;
+	u64 ii_iprte5b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte5b_fld_s;
 } ii_iprte5b_u_t;
 
@@ -1989,12 +1989,12 @@ typedef union ii_iprte5b_u {
  ************************************************************************/
 
 typedef union ii_iprte6b_u {
-	uint64_t ii_iprte6b_regval;
+	u64 ii_iprte6b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 
 	} ii_iprte6b_fld_s;
 } ii_iprte6b_u_t;
@@ -2010,12 +2010,12 @@ typedef union ii_iprte6b_u {
  ************************************************************************/
 
 typedef union ii_iprte7b_u {
-	uint64_t ii_iprte7b_regval;
+	u64 ii_iprte7b_regval;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_address:47;
-		uint64_t i_init:3;
-		uint64_t i_source:11;
+		u64 i_rsvd_1:3;
+		u64 i_address:47;
+		u64 i_init:3;
+		u64 i_source:11;
 	} ii_iprte7b_fld_s;
 } ii_iprte7b_u_t;
 
@@ -2038,13 +2038,13 @@ typedef union ii_iprte7b_u {
  ************************************************************************/
 
 typedef union ii_ipdr_u {
-	uint64_t ii_ipdr_regval;
+	u64 ii_ipdr_regval;
 	struct {
-		uint64_t i_te:3;
-		uint64_t i_rsvd_1:1;
-		uint64_t i_pnd:1;
-		uint64_t i_init_rpcnt:1;
-		uint64_t i_rsvd:58;
+		u64 i_te:3;
+		u64 i_rsvd_1:1;
+		u64 i_pnd:1;
+		u64 i_init_rpcnt:1;
+		u64 i_rsvd:58;
 	} ii_ipdr_fld_s;
 } ii_ipdr_u_t;
 
@@ -2066,11 +2066,11 @@ typedef union ii_ipdr_u {
  ************************************************************************/
 
 typedef union ii_icdr_u {
-	uint64_t ii_icdr_regval;
+	u64 ii_icdr_regval;
 	struct {
-		uint64_t i_crb_num:4;
-		uint64_t i_pnd:1;
-		uint64_t i_rsvd:59;
+		u64 i_crb_num:4;
+		u64 i_pnd:1;
+		u64 i_rsvd:59;
 	} ii_icdr_fld_s;
 } ii_icdr_u_t;
 
@@ -2092,13 +2092,13 @@ typedef union ii_icdr_u {
  ************************************************************************/
 
 typedef union ii_ifdr_u {
-	uint64_t ii_ifdr_regval;
+	u64 ii_ifdr_regval;
 	struct {
-		uint64_t i_ioq_max_rq:7;
-		uint64_t i_set_ioq_rq:1;
-		uint64_t i_ioq_max_rp:7;
-		uint64_t i_set_ioq_rp:1;
-		uint64_t i_rsvd:48;
+		u64 i_ioq_max_rq:7;
+		u64 i_set_ioq_rq:1;
+		u64 i_ioq_max_rp:7;
+		u64 i_set_ioq_rp:1;
+		u64 i_rsvd:48;
 	} ii_ifdr_fld_s;
 } ii_ifdr_u_t;
 
@@ -2114,12 +2114,12 @@ typedef union ii_ifdr_u {
  ************************************************************************/
 
 typedef union ii_iiap_u {
-	uint64_t ii_iiap_regval;
+	u64 ii_iiap_regval;
 	struct {
-		uint64_t i_rq_mls:6;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_rp_mls:6;
-		uint64_t i_rsvd:50;
+		u64 i_rq_mls:6;
+		u64 i_rsvd_1:2;
+		u64 i_rp_mls:6;
+		u64 i_rsvd:50;
 	} ii_iiap_fld_s;
 } ii_iiap_u_t;
 
@@ -2133,22 +2133,22 @@ typedef union ii_iiap_u {
  ************************************************************************/
 
 typedef union ii_icmr_u {
-	uint64_t ii_icmr_regval;
+	u64 ii_icmr_regval;
 	struct {
-		uint64_t i_sp_msg:1;
-		uint64_t i_rd_hdr:1;
-		uint64_t i_rsvd_4:2;
-		uint64_t i_c_cnt:4;
-		uint64_t i_rsvd_3:4;
-		uint64_t i_clr_rqpd:1;
-		uint64_t i_clr_rppd:1;
-		uint64_t i_rsvd_2:2;
-		uint64_t i_fc_cnt:4;
-		uint64_t i_crb_vld:15;
-		uint64_t i_crb_mark:15;
-		uint64_t i_rsvd_1:2;
-		uint64_t i_precise:1;
-		uint64_t i_rsvd:11;
+		u64 i_sp_msg:1;
+		u64 i_rd_hdr:1;
+		u64 i_rsvd_4:2;
+		u64 i_c_cnt:4;
+		u64 i_rsvd_3:4;
+		u64 i_clr_rqpd:1;
+		u64 i_clr_rppd:1;
+		u64 i_rsvd_2:2;
+		u64 i_fc_cnt:4;
+		u64 i_crb_vld:15;
+		u64 i_crb_mark:15;
+		u64 i_rsvd_1:2;
+		u64 i_precise:1;
+		u64 i_rsvd:11;
 	} ii_icmr_fld_s;
 } ii_icmr_u_t;
 
@@ -2161,13 +2161,13 @@ typedef union ii_icmr_u {
  ************************************************************************/
 
 typedef union ii_iccr_u {
-	uint64_t ii_iccr_regval;
+	u64 ii_iccr_regval;
 	struct {
-		uint64_t i_crb_num:4;
-		uint64_t i_rsvd_1:4;
-		uint64_t i_cmd:8;
-		uint64_t i_pending:1;
-		uint64_t i_rsvd:47;
+		u64 i_crb_num:4;
+		u64 i_rsvd_1:4;
+		u64 i_cmd:8;
+		u64 i_pending:1;
+		u64 i_rsvd:47;
 	} ii_iccr_fld_s;
 } ii_iccr_u_t;
 
@@ -2178,10 +2178,10 @@ typedef union ii_iccr_u {
  ************************************************************************/
 
 typedef union ii_icto_u {
-	uint64_t ii_icto_regval;
+	u64 ii_icto_regval;
 	struct {
-		uint64_t i_timeout:8;
-		uint64_t i_rsvd:56;
+		u64 i_timeout:8;
+		u64 i_rsvd:56;
 	} ii_icto_fld_s;
 } ii_icto_u_t;
 
@@ -2197,10 +2197,10 @@ typedef union ii_icto_u {
  ************************************************************************/
 
 typedef union ii_ictp_u {
-	uint64_t ii_ictp_regval;
+	u64 ii_ictp_regval;
 	struct {
-		uint64_t i_prescale:24;
-		uint64_t i_rsvd:40;
+		u64 i_prescale:24;
+		u64 i_rsvd:40;
 	} ii_ictp_fld_s;
 } ii_ictp_u_t;
 
@@ -2228,14 +2228,14 @@ typedef union ii_ictp_u {
  ************************************************************************/
 
 typedef union ii_icrb0_a_u {
-	uint64_t ii_icrb0_a_regval;
+	u64 ii_icrb0_a_regval;
 	struct {
-		uint64_t ia_iow:1;
-		uint64_t ia_vld:1;
-		uint64_t ia_addr:47;
-		uint64_t ia_tnum:5;
-		uint64_t ia_sidn:4;
-		uint64_t ia_rsvd:6;
+		u64 ia_iow:1;
+		u64 ia_vld:1;
+		u64 ia_addr:47;
+		u64 ia_tnum:5;
+		u64 ia_sidn:4;
+		u64 ia_rsvd:6;
 	} ii_icrb0_a_fld_s;
 } ii_icrb0_a_u_t;
 
@@ -2249,30 +2249,30 @@ typedef union ii_icrb0_a_u {
  ************************************************************************/
 
 typedef union ii_icrb0_b_u {
-	uint64_t ii_icrb0_b_regval;
+	u64 ii_icrb0_b_regval;
 	struct {
-		uint64_t ib_xt_err:1;
-		uint64_t ib_mark:1;
-		uint64_t ib_ln_uce:1;
-		uint64_t ib_errcode:3;
-		uint64_t ib_error:1;
-		uint64_t ib_stall__bte_1:1;
-		uint64_t ib_stall__bte_0:1;
-		uint64_t ib_stall__intr:1;
-		uint64_t ib_stall_ib:1;
-		uint64_t ib_intvn:1;
-		uint64_t ib_wb:1;
-		uint64_t ib_hold:1;
-		uint64_t ib_ack:1;
-		uint64_t ib_resp:1;
-		uint64_t ib_ack_cnt:11;
-		uint64_t ib_rsvd:7;
-		uint64_t ib_exc:5;
-		uint64_t ib_init:3;
-		uint64_t ib_imsg:8;
-		uint64_t ib_imsgtype:2;
-		uint64_t ib_use_old:1;
-		uint64_t ib_rsvd_1:11;
+		u64 ib_xt_err:1;
+		u64 ib_mark:1;
+		u64 ib_ln_uce:1;
+		u64 ib_errcode:3;
+		u64 ib_error:1;
+		u64 ib_stall__bte_1:1;
+		u64 ib_stall__bte_0:1;
+		u64 ib_stall__intr:1;
+		u64 ib_stall_ib:1;
+		u64 ib_intvn:1;
+		u64 ib_wb:1;
+		u64 ib_hold:1;
+		u64 ib_ack:1;
+		u64 ib_resp:1;
+		u64 ib_ack_cnt:11;
+		u64 ib_rsvd:7;
+		u64 ib_exc:5;
+		u64 ib_init:3;
+		u64 ib_imsg:8;
+		u64 ib_imsgtype:2;
+		u64 ib_use_old:1;
+		u64 ib_rsvd_1:11;
 	} ii_icrb0_b_fld_s;
 } ii_icrb0_b_u_t;
 
@@ -2286,17 +2286,17 @@ typedef union ii_icrb0_b_u {
  ************************************************************************/
 
 typedef union ii_icrb0_c_u {
-	uint64_t ii_icrb0_c_regval;
+	u64 ii_icrb0_c_regval;
 	struct {
-		uint64_t ic_source:15;
-		uint64_t ic_size:2;
-		uint64_t ic_ct:1;
-		uint64_t ic_bte_num:1;
-		uint64_t ic_gbr:1;
-		uint64_t ic_resprqd:1;
-		uint64_t ic_bo:1;
-		uint64_t ic_suppl:15;
-		uint64_t ic_rsvd:27;
+		u64 ic_source:15;
+		u64 ic_size:2;
+		u64 ic_ct:1;
+		u64 ic_bte_num:1;
+		u64 ic_gbr:1;
+		u64 ic_resprqd:1;
+		u64 ic_bo:1;
+		u64 ic_suppl:15;
+		u64 ic_rsvd:27;
 	} ii_icrb0_c_fld_s;
 } ii_icrb0_c_u_t;
 
@@ -2310,14 +2310,14 @@ typedef union ii_icrb0_c_u {
  ************************************************************************/
 
 typedef union ii_icrb0_d_u {
-	uint64_t ii_icrb0_d_regval;
+	u64 ii_icrb0_d_regval;
 	struct {
-		uint64_t id_pa_be:43;
-		uint64_t id_bte_op:1;
-		uint64_t id_pr_psc:4;
-		uint64_t id_pr_cnt:4;
-		uint64_t id_sleep:1;
-		uint64_t id_rsvd:11;
+		u64 id_pa_be:43;
+		u64 id_bte_op:1;
+		u64 id_pr_psc:4;
+		u64 id_pr_cnt:4;
+		u64 id_sleep:1;
+		u64 id_rsvd:11;
 	} ii_icrb0_d_fld_s;
 } ii_icrb0_d_u_t;
 
@@ -2331,14 +2331,14 @@ typedef union ii_icrb0_d_u {
  ************************************************************************/
 
 typedef union ii_icrb0_e_u {
-	uint64_t ii_icrb0_e_regval;
+	u64 ii_icrb0_e_regval;
 	struct {
-		uint64_t ie_timeout:8;
-		uint64_t ie_context:15;
-		uint64_t ie_rsvd:1;
-		uint64_t ie_tvld:1;
-		uint64_t ie_cvld:1;
-		uint64_t ie_rsvd_0:38;
+		u64 ie_timeout:8;
+		u64 ie_context:15;
+		u64 ie_rsvd:1;
+		u64 ie_tvld:1;
+		u64 ie_cvld:1;
+		u64 ie_rsvd_0:38;
 	} ii_icrb0_e_fld_s;
 } ii_icrb0_e_u_t;
 
@@ -2351,12 +2351,12 @@ typedef union ii_icrb0_e_u {
  ************************************************************************/
 
 typedef union ii_icsml_u {
-	uint64_t ii_icsml_regval;
+	u64 ii_icsml_regval;
 	struct {
-		uint64_t i_tt_addr:47;
-		uint64_t i_newsuppl_ex:14;
-		uint64_t i_reserved:2;
-		uint64_t i_overflow:1;
+		u64 i_tt_addr:47;
+		u64 i_newsuppl_ex:14;
+		u64 i_reserved:2;
+		u64 i_overflow:1;
 	} ii_icsml_fld_s;
 } ii_icsml_u_t;
 
@@ -2369,10 +2369,10 @@ typedef union ii_icsml_u {
  ************************************************************************/
 
 typedef union ii_icsmm_u {
-	uint64_t ii_icsmm_regval;
+	u64 ii_icsmm_regval;
 	struct {
-		uint64_t i_tt_ack_cnt:11;
-		uint64_t i_reserved:53;
+		u64 i_tt_ack_cnt:11;
+		u64 i_reserved:53;
 	} ii_icsmm_fld_s;
 } ii_icsmm_u_t;
 
@@ -2385,48 +2385,48 @@ typedef union ii_icsmm_u {
  ************************************************************************/
 
 typedef union ii_icsmh_u {
-	uint64_t ii_icsmh_regval;
+	u64 ii_icsmh_regval;
 	struct {
-		uint64_t i_tt_vld:1;
-		uint64_t i_xerr:1;
-		uint64_t i_ft_cwact_o:1;
-		uint64_t i_ft_wact_o:1;
-		uint64_t i_ft_active_o:1;
-		uint64_t i_sync:1;
-		uint64_t i_mnusg:1;
-		uint64_t i_mnusz:1;
-		uint64_t i_plusz:1;
-		uint64_t i_plusg:1;
-		uint64_t i_tt_exc:5;
-		uint64_t i_tt_wb:1;
-		uint64_t i_tt_hold:1;
-		uint64_t i_tt_ack:1;
-		uint64_t i_tt_resp:1;
-		uint64_t i_tt_intvn:1;
-		uint64_t i_g_stall_bte1:1;
-		uint64_t i_g_stall_bte0:1;
-		uint64_t i_g_stall_il:1;
-		uint64_t i_g_stall_ib:1;
-		uint64_t i_tt_imsg:8;
-		uint64_t i_tt_imsgtype:2;
-		uint64_t i_tt_use_old:1;
-		uint64_t i_tt_respreqd:1;
-		uint64_t i_tt_bte_num:1;
-		uint64_t i_cbn:1;
-		uint64_t i_match:1;
-		uint64_t i_rpcnt_lt_34:1;
-		uint64_t i_rpcnt_ge_34:1;
-		uint64_t i_rpcnt_lt_18:1;
-		uint64_t i_rpcnt_ge_18:1;
-		uint64_t i_rpcnt_lt_2:1;
-		uint64_t i_rpcnt_ge_2:1;
-		uint64_t i_rqcnt_lt_18:1;
-		uint64_t i_rqcnt_ge_18:1;
-		uint64_t i_rqcnt_lt_2:1;
-		uint64_t i_rqcnt_ge_2:1;
-		uint64_t i_tt_device:7;
-		uint64_t i_tt_init:3;
-		uint64_t i_reserved:5;
+		u64 i_tt_vld:1;
+		u64 i_xerr:1;
+		u64 i_ft_cwact_o:1;
+		u64 i_ft_wact_o:1;
+		u64 i_ft_active_o:1;
+		u64 i_sync:1;
+		u64 i_mnusg:1;
+		u64 i_mnusz:1;
+		u64 i_plusz:1;
+		u64 i_plusg:1;
+		u64 i_tt_exc:5;
+		u64 i_tt_wb:1;
+		u64 i_tt_hold:1;
+		u64 i_tt_ack:1;
+		u64 i_tt_resp:1;
+		u64 i_tt_intvn:1;
+		u64 i_g_stall_bte1:1;
+		u64 i_g_stall_bte0:1;
+		u64 i_g_stall_il:1;
+		u64 i_g_stall_ib:1;
+		u64 i_tt_imsg:8;
+		u64 i_tt_imsgtype:2;
+		u64 i_tt_use_old:1;
+		u64 i_tt_respreqd:1;
+		u64 i_tt_bte_num:1;
+		u64 i_cbn:1;
+		u64 i_match:1;
+		u64 i_rpcnt_lt_34:1;
+		u64 i_rpcnt_ge_34:1;
+		u64 i_rpcnt_lt_18:1;
+		u64 i_rpcnt_ge_18:1;
+		u64 i_rpcnt_lt_2:1;
+		u64 i_rpcnt_ge_2:1;
+		u64 i_rqcnt_lt_18:1;
+		u64 i_rqcnt_ge_18:1;
+		u64 i_rqcnt_lt_2:1;
+		u64 i_rqcnt_ge_2:1;
+		u64 i_tt_device:7;
+		u64 i_tt_init:3;
+		u64 i_reserved:5;
 	} ii_icsmh_fld_s;
 } ii_icsmh_u_t;
 
@@ -2439,14 +2439,14 @@ typedef union ii_icsmh_u {
  ************************************************************************/
 
 typedef union ii_idbss_u {
-	uint64_t ii_idbss_regval;
+	u64 ii_idbss_regval;
 	struct {
-		uint64_t i_iioclk_core_submenu:3;
-		uint64_t i_rsvd:5;
-		uint64_t i_fsbclk_wrapper_submenu:3;
-		uint64_t i_rsvd_1:5;
-		uint64_t i_iioclk_menu:5;
-		uint64_t i_rsvd_2:43;
+		u64 i_iioclk_core_submenu:3;
+		u64 i_rsvd:5;
+		u64 i_fsbclk_wrapper_submenu:3;
+		u64 i_rsvd_1:5;
+		u64 i_iioclk_menu:5;
+		u64 i_rsvd_2:43;
 	} ii_idbss_fld_s;
 } ii_idbss_u_t;
 
@@ -2466,13 +2466,13 @@ typedef union ii_idbss_u {
  ************************************************************************/
 
 typedef union ii_ibls0_u {
-	uint64_t ii_ibls0_regval;
+	u64 ii_ibls0_regval;
 	struct {
-		uint64_t i_length:16;
-		uint64_t i_error:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_busy:1;
-		uint64_t i_rsvd:43;
+		u64 i_length:16;
+		u64 i_error:1;
+		u64 i_rsvd_1:3;
+		u64 i_busy:1;
+		u64 i_rsvd:43;
 	} ii_ibls0_fld_s;
 } ii_ibls0_u_t;
 
@@ -2487,11 +2487,11 @@ typedef union ii_ibls0_u {
  ************************************************************************/
 
 typedef union ii_ibsa0_u {
-	uint64_t ii_ibsa0_regval;
+	u64 ii_ibsa0_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:42;
-		uint64_t i_rsvd:15;
+		u64 i_rsvd_1:7;
+		u64 i_addr:42;
+		u64 i_rsvd:15;
 	} ii_ibsa0_fld_s;
 } ii_ibsa0_u_t;
 
@@ -2506,11 +2506,11 @@ typedef union ii_ibsa0_u {
  ************************************************************************/
 
 typedef union ii_ibda0_u {
-	uint64_t ii_ibda0_regval;
+	u64 ii_ibda0_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:42;
-		uint64_t i_rsvd:15;
+		u64 i_rsvd_1:7;
+		u64 i_addr:42;
+		u64 i_rsvd:15;
 	} ii_ibda0_fld_s;
 } ii_ibda0_u_t;
 
@@ -2527,14 +2527,14 @@ typedef union ii_ibda0_u {
  ************************************************************************/
 
 typedef union ii_ibct0_u {
-	uint64_t ii_ibct0_regval;
+	u64 ii_ibct0_regval;
 	struct {
-		uint64_t i_zerofill:1;
-		uint64_t i_rsvd_2:3;
-		uint64_t i_notify:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_poison:1;
-		uint64_t i_rsvd:55;
+		u64 i_zerofill:1;
+		u64 i_rsvd_2:3;
+		u64 i_notify:1;
+		u64 i_rsvd_1:3;
+		u64 i_poison:1;
+		u64 i_rsvd:55;
 	} ii_ibct0_fld_s;
 } ii_ibct0_u_t;
 
@@ -2546,11 +2546,11 @@ typedef union ii_ibct0_u {
  ************************************************************************/
 
 typedef union ii_ibna0_u {
-	uint64_t ii_ibna0_regval;
+	u64 ii_ibna0_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:42;
-		uint64_t i_rsvd:15;
+		u64 i_rsvd_1:7;
+		u64 i_addr:42;
+		u64 i_rsvd:15;
 	} ii_ibna0_fld_s;
 } ii_ibna0_u_t;
 
@@ -2563,13 +2563,13 @@ typedef union ii_ibna0_u {
  ************************************************************************/
 
 typedef union ii_ibia0_u {
-	uint64_t ii_ibia0_regval;
+	u64 ii_ibia0_regval;
 	struct {
-		uint64_t i_rsvd_2:1;
-		uint64_t i_node_id:11;
-		uint64_t i_rsvd_1:4;
-		uint64_t i_level:7;
-		uint64_t i_rsvd:41;
+		u64 i_rsvd_2:1;
+		u64 i_node_id:11;
+		u64 i_rsvd_1:4;
+		u64 i_level:7;
+		u64 i_rsvd:41;
 	} ii_ibia0_fld_s;
 } ii_ibia0_u_t;
 
@@ -2589,13 +2589,13 @@ typedef union ii_ibia0_u {
  ************************************************************************/
 
 typedef union ii_ibls1_u {
-	uint64_t ii_ibls1_regval;
+	u64 ii_ibls1_regval;
 	struct {
-		uint64_t i_length:16;
-		uint64_t i_error:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_busy:1;
-		uint64_t i_rsvd:43;
+		u64 i_length:16;
+		u64 i_error:1;
+		u64 i_rsvd_1:3;
+		u64 i_busy:1;
+		u64 i_rsvd:43;
 	} ii_ibls1_fld_s;
 } ii_ibls1_u_t;
 
@@ -2610,11 +2610,11 @@ typedef union ii_ibls1_u {
  ************************************************************************/
 
 typedef union ii_ibsa1_u {
-	uint64_t ii_ibsa1_regval;
+	u64 ii_ibsa1_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:33;
-		uint64_t i_rsvd:24;
+		u64 i_rsvd_1:7;
+		u64 i_addr:33;
+		u64 i_rsvd:24;
 	} ii_ibsa1_fld_s;
 } ii_ibsa1_u_t;
 
@@ -2629,11 +2629,11 @@ typedef union ii_ibsa1_u {
  ************************************************************************/
 
 typedef union ii_ibda1_u {
-	uint64_t ii_ibda1_regval;
+	u64 ii_ibda1_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:33;
-		uint64_t i_rsvd:24;
+		u64 i_rsvd_1:7;
+		u64 i_addr:33;
+		u64 i_rsvd:24;
 	} ii_ibda1_fld_s;
 } ii_ibda1_u_t;
 
@@ -2650,14 +2650,14 @@ typedef union ii_ibda1_u {
  ************************************************************************/
 
 typedef union ii_ibct1_u {
-	uint64_t ii_ibct1_regval;
+	u64 ii_ibct1_regval;
 	struct {
-		uint64_t i_zerofill:1;
-		uint64_t i_rsvd_2:3;
-		uint64_t i_notify:1;
-		uint64_t i_rsvd_1:3;
-		uint64_t i_poison:1;
-		uint64_t i_rsvd:55;
+		u64 i_zerofill:1;
+		u64 i_rsvd_2:3;
+		u64 i_notify:1;
+		u64 i_rsvd_1:3;
+		u64 i_poison:1;
+		u64 i_rsvd:55;
 	} ii_ibct1_fld_s;
 } ii_ibct1_u_t;
 
@@ -2669,11 +2669,11 @@ typedef union ii_ibct1_u {
  ************************************************************************/
 
 typedef union ii_ibna1_u {
-	uint64_t ii_ibna1_regval;
+	u64 ii_ibna1_regval;
 	struct {
-		uint64_t i_rsvd_1:7;
-		uint64_t i_addr:33;
-		uint64_t i_rsvd:24;
+		u64 i_rsvd_1:7;
+		u64 i_addr:33;
+		u64 i_rsvd:24;
 	} ii_ibna1_fld_s;
 } ii_ibna1_u_t;
 
@@ -2686,13 +2686,13 @@ typedef union ii_ibna1_u {
  ************************************************************************/
 
 typedef union ii_ibia1_u {
-	uint64_t ii_ibia1_regval;
+	u64 ii_ibia1_regval;
 	struct {
-		uint64_t i_pi_id:1;
-		uint64_t i_node_id:8;
-		uint64_t i_rsvd_1:7;
-		uint64_t i_level:7;
-		uint64_t i_rsvd:41;
+		u64 i_pi_id:1;
+		u64 i_node_id:8;
+		u64 i_rsvd_1:7;
+		u64 i_level:7;
+		u64 i_rsvd:41;
 	} ii_ibia1_fld_s;
 } ii_ibia1_u_t;
 
@@ -2712,12 +2712,12 @@ typedef union ii_ibia1_u {
  ************************************************************************/
 
 typedef union ii_ipcr_u {
-	uint64_t ii_ipcr_regval;
+	u64 ii_ipcr_regval;
 	struct {
-		uint64_t i_ippr0_c:4;
-		uint64_t i_ippr1_c:4;
-		uint64_t i_icct:8;
-		uint64_t i_rsvd:48;
+		u64 i_ippr0_c:4;
+		u64 i_ippr1_c:4;
+		u64 i_icct:8;
+		u64 i_rsvd:48;
 	} ii_ipcr_fld_s;
 } ii_ipcr_u_t;
 
@@ -2728,10 +2728,10 @@ typedef union ii_ipcr_u {
  ************************************************************************/
 
 typedef union ii_ippr_u {
-	uint64_t ii_ippr_regval;
+	u64 ii_ippr_regval;
 	struct {
-		uint64_t i_ippr0:32;
-		uint64_t i_ippr1:32;
+		u64 i_ippr0:32;
+		u64 i_ippr1:32;
 	} ii_ippr_fld_s;
 } ii_ippr_u_t;
 
@@ -3267,15 +3267,15 @@ typedef ii_icrb0_e_u_t icrbe_t;
 #define IO_PERF_SETS	32
 
 /* Bit for the widget in inbound access register */
-#define IIO_IIWA_WIDGET(_w)	((uint64_t)(1ULL << _w))
+#define IIO_IIWA_WIDGET(_w)	((u64)(1ULL << _w))
 /* Bit for the widget in outbound access register */
-#define IIO_IOWA_WIDGET(_w)	((uint64_t)(1ULL << _w))
+#define IIO_IOWA_WIDGET(_w)	((u64)(1ULL << _w))
 
 /* NOTE: The following define assumes that we are going to get
  * widget numbers from 8 thru F and the device numbers within
  * widget from 0 thru 7.
  */
-#define IIO_IIDEM_WIDGETDEV_MASK(w, d)	((uint64_t)(1ULL << (8 * ((w) - 8) + (d))))
+#define IIO_IIDEM_WIDGETDEV_MASK(w, d)	((u64)(1ULL << (8 * ((w) - 8) + (d))))
 
 /* IO Interrupt Destination Register */
 #define IIO_IIDSR_SENT_SHIFT    28
@@ -3302,9 +3302,9 @@ typedef ii_icrb0_e_u_t icrbe_t;
  */
 
 typedef union hubii_wcr_u {
-	uint64_t wcr_reg_value;
+	u64 wcr_reg_value;
 	struct {
-		uint64_t wcr_widget_id:4,	/* LLP crossbar credit */
+		u64 wcr_widget_id:4,	/* LLP crossbar credit */
 		 wcr_tag_mode:1,	/* Tag mode */
 		 wcr_rsvd1:8,	/* Reserved */
 		 wcr_xbar_crd:3,	/* LLP crossbar credit */
@@ -3324,9 +3324,9 @@ performance registers */
    performed */
 
 typedef union io_perf_sel {
-	uint64_t perf_sel_reg;
+	u64 perf_sel_reg;
 	struct {
-		uint64_t perf_ippr0:4, perf_ippr1:4, perf_icct:8, perf_rsvd:48;
+		u64 perf_ippr0:4, perf_ippr1:4, perf_icct:8, perf_rsvd:48;
 	} perf_sel_bits;
 } io_perf_sel_t;
 
@@ -3334,24 +3334,24 @@ typedef union io_perf_sel {
    hardware problems there is only one counter, not two. */
 
 typedef union io_perf_cnt {
-	uint64_t perf_cnt;
+	u64 perf_cnt;
 	struct {
-		uint64_t perf_cnt:20, perf_rsvd2:12, perf_rsvd1:32;
+		u64 perf_cnt:20, perf_rsvd2:12, perf_rsvd1:32;
 	} perf_cnt_bits;
 
 } io_perf_cnt_t;
 
 typedef union iprte_a {
-	uint64_t entry;
+	u64 entry;
 	struct {
-		uint64_t i_rsvd_1:3;
-		uint64_t i_addr:38;
-		uint64_t i_init:3;
-		uint64_t i_source:8;
-		uint64_t i_rsvd:2;
-		uint64_t i_widget:4;
-		uint64_t i_to_cnt:5;
-		uint64_t i_vld:1;
+		u64 i_rsvd_1:3;
+		u64 i_addr:38;
+		u64 i_init:3;
+		u64 i_source:8;
+		u64 i_rsvd:2;
+		u64 i_widget:4;
+		u64 i_to_cnt:5;
+		u64 i_vld:1;
 	} iprte_fields;
 } iprte_a_t;
 
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/sn_sal.h linux-2.6.16-rc1/include/asm-ia64/sn/sn_sal.h
--- linux-2.6.15-git12/include/asm-ia64/sn/sn_sal.h	2006-01-17 08:21:38.577787617 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/sn_sal.h	2006-01-17 08:22:53.063383226 +0000
@@ -273,7 +273,7 @@ ia64_sn_console_putc(char ch)
 	ret_stuff.v0 = 0;
 	ret_stuff.v1 = 0;
 	ret_stuff.v2 = 0;
-	SAL_CALL_NOLOCK(ret_stuff, SN_SAL_CONSOLE_PUTC, (uint64_t)ch, 0, 0, 0, 0, 0, 0);
+	SAL_CALL_NOLOCK(ret_stuff, SN_SAL_CONSOLE_PUTC, (u64)ch, 0, 0, 0, 0, 0, 0);
 
 	return ret_stuff.status;
 }
@@ -290,7 +290,7 @@ ia64_sn_console_putb(const char *buf, in
 	ret_stuff.v0 = 0; 
 	ret_stuff.v1 = 0;
 	ret_stuff.v2 = 0;
-	SAL_CALL_NOLOCK(ret_stuff, SN_SAL_CONSOLE_PUTB, (uint64_t)buf, (uint64_t)len, 0, 0, 0, 0, 0);
+	SAL_CALL_NOLOCK(ret_stuff, SN_SAL_CONSOLE_PUTB, (u64)buf, (u64)len, 0, 0, 0, 0, 0);
 
 	if ( ret_stuff.status == 0 ) {
 		return ret_stuff.v0;
@@ -310,7 +310,7 @@ ia64_sn_plat_specific_err_print(int (*ho
 	ret_stuff.v0 = 0;
 	ret_stuff.v1 = 0;
 	ret_stuff.v2 = 0;
-	SAL_CALL_REENTRANT(ret_stuff, SN_SAL_PRINT_ERROR, (uint64_t)hook, (uint64_t)rec, 0, 0, 0, 0, 0);
+	SAL_CALL_REENTRANT(ret_stuff, SN_SAL_PRINT_ERROR, (u64)hook, (u64)rec, 0, 0, 0, 0, 0);
 
 	return ret_stuff.status;
 }
@@ -398,7 +398,7 @@ ia64_sn_console_intr_status(void)
  * Enable an interrupt on the SAL console device.
  */
 static inline void
-ia64_sn_console_intr_enable(uint64_t intr)
+ia64_sn_console_intr_enable(u64 intr)
 {
 	struct ia64_sal_retval ret_stuff;
 
@@ -415,7 +415,7 @@ ia64_sn_console_intr_enable(uint64_t int
  * Disable an interrupt on the SAL console device.
  */
 static inline void
-ia64_sn_console_intr_disable(uint64_t intr)
+ia64_sn_console_intr_disable(u64 intr)
 {
 	struct ia64_sal_retval ret_stuff;
 
@@ -441,7 +441,7 @@ ia64_sn_console_xmit_chars(char *buf, in
 	ret_stuff.v1 = 0;
 	ret_stuff.v2 = 0;
 	SAL_CALL_NOLOCK(ret_stuff, SN_SAL_CONSOLE_XMIT_CHARS,
-		 (uint64_t)buf, (uint64_t)len,
+		 (u64)buf, (u64)len,
 		 0, 0, 0, 0, 0);
 
 	if (ret_stuff.status == 0) {
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tioca.h linux-2.6.16-rc1/include/asm-ia64/sn/tioca.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tioca.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tioca.h	2006-01-17 08:22:53.066382754 +0000
@@ -19,47 +19,47 @@
  */
 
 struct tioca {
-	uint64_t	ca_id;				/* 0x000000 */
-	uint64_t	ca_control1;			/* 0x000008 */
-	uint64_t	ca_control2;			/* 0x000010 */
-	uint64_t	ca_status1;			/* 0x000018 */
-	uint64_t	ca_status2;			/* 0x000020 */
-	uint64_t	ca_gart_aperature;		/* 0x000028 */
-	uint64_t	ca_gfx_detach;			/* 0x000030 */
-	uint64_t	ca_inta_dest_addr;		/* 0x000038 */
-	uint64_t	ca_intb_dest_addr;		/* 0x000040 */
-	uint64_t	ca_err_int_dest_addr;		/* 0x000048 */
-	uint64_t	ca_int_status;			/* 0x000050 */
-	uint64_t	ca_int_status_alias;		/* 0x000058 */
-	uint64_t	ca_mult_error;			/* 0x000060 */
-	uint64_t	ca_mult_error_alias;		/* 0x000068 */
-	uint64_t	ca_first_error;			/* 0x000070 */
-	uint64_t	ca_int_mask;			/* 0x000078 */
-	uint64_t	ca_crm_pkterr_type;		/* 0x000080 */
-	uint64_t	ca_crm_pkterr_type_alias;	/* 0x000088 */
-	uint64_t	ca_crm_ct_error_detail_1;	/* 0x000090 */
-	uint64_t	ca_crm_ct_error_detail_2;	/* 0x000098 */
-	uint64_t	ca_crm_tnumto;			/* 0x0000A0 */
-	uint64_t	ca_gart_err;			/* 0x0000A8 */
-	uint64_t	ca_pcierr_type;			/* 0x0000B0 */
-	uint64_t	ca_pcierr_addr;			/* 0x0000B8 */
-
-	uint64_t	ca_pad_0000C0[3];		/* 0x0000{C0..D0} */
-
-	uint64_t	ca_pci_rd_buf_flush;		/* 0x0000D8 */
-	uint64_t	ca_pci_dma_addr_extn;		/* 0x0000E0 */
-	uint64_t	ca_agp_dma_addr_extn;		/* 0x0000E8 */
-	uint64_t	ca_force_inta;			/* 0x0000F0 */
-	uint64_t	ca_force_intb;			/* 0x0000F8 */
-	uint64_t	ca_debug_vector_sel;		/* 0x000100 */
-	uint64_t	ca_debug_mux_core_sel;		/* 0x000108 */
-	uint64_t	ca_debug_mux_pci_sel;		/* 0x000110 */
-	uint64_t	ca_debug_domain_sel;		/* 0x000118 */
+	u64	ca_id;				/* 0x000000 */
+	u64	ca_control1;			/* 0x000008 */
+	u64	ca_control2;			/* 0x000010 */
+	u64	ca_status1;			/* 0x000018 */
+	u64	ca_status2;			/* 0x000020 */
+	u64	ca_gart_aperature;		/* 0x000028 */
+	u64	ca_gfx_detach;			/* 0x000030 */
+	u64	ca_inta_dest_addr;		/* 0x000038 */
+	u64	ca_intb_dest_addr;		/* 0x000040 */
+	u64	ca_err_int_dest_addr;		/* 0x000048 */
+	u64	ca_int_status;			/* 0x000050 */
+	u64	ca_int_status_alias;		/* 0x000058 */
+	u64	ca_mult_error;			/* 0x000060 */
+	u64	ca_mult_error_alias;		/* 0x000068 */
+	u64	ca_first_error;			/* 0x000070 */
+	u64	ca_int_mask;			/* 0x000078 */
+	u64	ca_crm_pkterr_type;		/* 0x000080 */
+	u64	ca_crm_pkterr_type_alias;	/* 0x000088 */
+	u64	ca_crm_ct_error_detail_1;	/* 0x000090 */
+	u64	ca_crm_ct_error_detail_2;	/* 0x000098 */
+	u64	ca_crm_tnumto;			/* 0x0000A0 */
+	u64	ca_gart_err;			/* 0x0000A8 */
+	u64	ca_pcierr_type;			/* 0x0000B0 */
+	u64	ca_pcierr_addr;			/* 0x0000B8 */
+
+	u64	ca_pad_0000C0[3];		/* 0x0000{C0..D0} */
+
+	u64	ca_pci_rd_buf_flush;		/* 0x0000D8 */
+	u64	ca_pci_dma_addr_extn;		/* 0x0000E0 */
+	u64	ca_agp_dma_addr_extn;		/* 0x0000E8 */
+	u64	ca_force_inta;			/* 0x0000F0 */
+	u64	ca_force_intb;			/* 0x0000F8 */
+	u64	ca_debug_vector_sel;		/* 0x000100 */
+	u64	ca_debug_mux_core_sel;		/* 0x000108 */
+	u64	ca_debug_mux_pci_sel;		/* 0x000110 */
+	u64	ca_debug_domain_sel;		/* 0x000118 */
 
-	uint64_t	ca_pad_000120[28];		/* 0x0001{20..F8} */
+	u64	ca_pad_000120[28];		/* 0x0001{20..F8} */
 
-	uint64_t	ca_gart_ptr_table;		/* 0x200 */
-	uint64_t	ca_gart_tlb_addr[8];		/* 0x2{08..40} */
+	u64	ca_gart_ptr_table;		/* 0x200 */
+	u64	ca_gart_tlb_addr[8];		/* 0x2{08..40} */
 };
 
 /*
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tioca_provider.h linux-2.6.16-rc1/include/asm-ia64/sn/tioca_provider.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tioca_provider.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tioca_provider.h	2006-01-17 08:22:53.068382439 +0000
@@ -56,31 +56,31 @@ struct tioca_kernel {
 	/*
 	 * General GART stuff
 	 */
-	uint64_t	ca_ap_size;		/* size of aperature in bytes */
-	uint32_t	ca_gart_entries;	/* # uint64_t entries in gart */
-	uint32_t	ca_ap_pagesize; 	/* aperature page size in bytes */
-	uint64_t	ca_ap_bus_base; 	/* bus address of CA aperature */
-	uint64_t	ca_gart_size;		/* gart size in bytes */
-	uint64_t	*ca_gart;		/* gart table vaddr */
-	uint64_t	ca_gart_coretalk_addr;	/* gart coretalk addr */
-	uint8_t		ca_gart_iscoherent;	/* used in tioca_tlbflush */
+	u64	ca_ap_size;		/* size of aperature in bytes */
+	u32	ca_gart_entries;	/* # u64 entries in gart */
+	u32	ca_ap_pagesize; 	/* aperature page size in bytes */
+	u64	ca_ap_bus_base; 	/* bus address of CA aperature */
+	u64	ca_gart_size;		/* gart size in bytes */
+	u64	*ca_gart;		/* gart table vaddr */
+	u64	ca_gart_coretalk_addr;	/* gart coretalk addr */
+	u8		ca_gart_iscoherent;	/* used in tioca_tlbflush */
 
 	/* PCI GART convenience values */
-	uint64_t	ca_pciap_base;		/* pci aperature bus base address */
-	uint64_t	ca_pciap_size;		/* pci aperature size (bytes) */
-	uint64_t	ca_pcigart_base;	/* gfx GART bus base address */
-	uint64_t	*ca_pcigart;		/* gfx GART vm address */
-	uint32_t	ca_pcigart_entries;
-	uint32_t	ca_pcigart_start;	/* PCI start index in ca_gart */
+	u64	ca_pciap_base;		/* pci aperature bus base address */
+	u64	ca_pciap_size;		/* pci aperature size (bytes) */
+	u64	ca_pcigart_base;	/* gfx GART bus base address */
+	u64	*ca_pcigart;		/* gfx GART vm address */
+	u32	ca_pcigart_entries;
+	u32	ca_pcigart_start;	/* PCI start index in ca_gart */
 	void		*ca_pcigart_pagemap;
 
 	/* AGP GART convenience values */
-	uint64_t	ca_gfxap_base;		/* gfx aperature bus base address */
-	uint64_t	ca_gfxap_size;		/* gfx aperature size (bytes) */
-	uint64_t	ca_gfxgart_base;	/* gfx GART bus base address */
-	uint64_t	*ca_gfxgart;		/* gfx GART vm address */
-	uint32_t	ca_gfxgart_entries;
-	uint32_t	ca_gfxgart_start;	/* agpgart start index in ca_gart */
+	u64	ca_gfxap_base;		/* gfx aperature bus base address */
+	u64	ca_gfxap_size;		/* gfx aperature size (bytes) */
+	u64	ca_gfxgart_base;	/* gfx GART bus base address */
+	u64	*ca_gfxgart;		/* gfx GART vm address */
+	u32	ca_gfxgart_entries;
+	u32	ca_gfxgart_start;	/* agpgart start index in ca_gart */
 };
 
 /*
@@ -93,11 +93,11 @@ struct tioca_kernel {
 struct tioca_common {
 	struct pcibus_bussoft	ca_common;	/* common pciio header */
 
-	uint32_t		ca_rev;
-	uint32_t		ca_closest_nasid;
+	u32		ca_rev;
+	u32		ca_closest_nasid;
 
-	uint64_t		ca_prom_private;
-	uint64_t		ca_kernel_private;
+	u64		ca_prom_private;
+	u64		ca_kernel_private;
 };
 
 /**
@@ -139,9 +139,9 @@ tioca_paddr_to_gart(unsigned long paddr)
  */
 
 static inline unsigned long
-tioca_physpage_to_gart(uint64_t page_addr)
+tioca_physpage_to_gart(u64 page_addr)
 {
-	uint64_t coretalk_addr;
+	u64 coretalk_addr;
 
 	coretalk_addr = PHYS_TO_TIODMA(page_addr);
 	if (!coretalk_addr) {
@@ -161,7 +161,7 @@ tioca_physpage_to_gart(uint64_t page_add
 static inline void
 tioca_tlbflush(struct tioca_kernel *tioca_kernel)
 {
-	volatile uint64_t tmp;
+	volatile u64 tmp;
 	volatile struct tioca *ca_base;
 	struct tioca_common *tioca_common;
 
@@ -200,7 +200,7 @@ tioca_tlbflush(struct tioca_kernel *tioc
 	tmp = __sn_readq_relaxed(&ca_base->ca_control2);
 }
 
-extern uint32_t	tioca_gart_found;
+extern u32	tioca_gart_found;
 extern struct list_head tioca_list;
 extern int tioca_init_provider(void);
 extern void tioca_fastwrite_enable(struct tioca_kernel *tioca_kern);
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tioce.h linux-2.6.16-rc1/include/asm-ia64/sn/tioce.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tioce.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tioce.h	2006-01-17 08:22:53.082380235 +0000
@@ -35,72 +35,72 @@ typedef volatile struct tioce {
 	/*
 	 * ADMIN : Administration Registers
 	 */
-	uint64_t	ce_adm_id;				/* 0x000000 */
-	uint64_t	ce_pad_000008;				/* 0x000008 */
-	uint64_t	ce_adm_dyn_credit_status;		/* 0x000010 */
-	uint64_t	ce_adm_last_credit_status;		/* 0x000018 */
-	uint64_t	ce_adm_credit_limit;			/* 0x000020 */
-	uint64_t	ce_adm_force_credit;			/* 0x000028 */
-	uint64_t	ce_adm_control;				/* 0x000030 */
-	uint64_t	ce_adm_mmr_chn_timeout;			/* 0x000038 */
-	uint64_t	ce_adm_ssp_ure_timeout;			/* 0x000040 */
-	uint64_t	ce_adm_ssp_dre_timeout;			/* 0x000048 */
-	uint64_t	ce_adm_ssp_debug_sel;			/* 0x000050 */
-	uint64_t	ce_adm_int_status;			/* 0x000058 */
-	uint64_t	ce_adm_int_status_alias;		/* 0x000060 */
-	uint64_t	ce_adm_int_mask;			/* 0x000068 */
-	uint64_t	ce_adm_int_pending;			/* 0x000070 */
-	uint64_t	ce_adm_force_int;			/* 0x000078 */
-	uint64_t	ce_adm_ure_ups_buf_barrier_flush;	/* 0x000080 */
-	uint64_t	ce_adm_int_dest[15];	    /* 0x000088 -- 0x0000F8 */
-	uint64_t	ce_adm_error_summary;			/* 0x000100 */
-	uint64_t	ce_adm_error_summary_alias;		/* 0x000108 */
-	uint64_t	ce_adm_error_mask;			/* 0x000110 */
-	uint64_t	ce_adm_first_error;			/* 0x000118 */
-	uint64_t	ce_adm_error_overflow;			/* 0x000120 */
-	uint64_t	ce_adm_error_overflow_alias;		/* 0x000128 */
-	uint64_t	ce_pad_000130[2];	    /* 0x000130 -- 0x000138 */
-	uint64_t	ce_adm_tnum_error;			/* 0x000140 */
-	uint64_t	ce_adm_mmr_err_detail;			/* 0x000148 */
-	uint64_t	ce_adm_msg_sram_perr_detail;		/* 0x000150 */
-	uint64_t	ce_adm_bap_sram_perr_detail;		/* 0x000158 */
-	uint64_t	ce_adm_ce_sram_perr_detail;		/* 0x000160 */
-	uint64_t	ce_adm_ce_credit_oflow_detail;		/* 0x000168 */
-	uint64_t	ce_adm_tx_link_idle_max_timer;		/* 0x000170 */
-	uint64_t	ce_adm_pcie_debug_sel;			/* 0x000178 */
-	uint64_t	ce_pad_000180[16];	    /* 0x000180 -- 0x0001F8 */
-
-	uint64_t	ce_adm_pcie_debug_sel_top;		/* 0x000200 */
-	uint64_t	ce_adm_pcie_debug_lat_sel_lo_top;	/* 0x000208 */
-	uint64_t	ce_adm_pcie_debug_lat_sel_hi_top;	/* 0x000210 */
-	uint64_t	ce_adm_pcie_debug_trig_sel_top;		/* 0x000218 */
-	uint64_t	ce_adm_pcie_debug_trig_lat_sel_lo_top;	/* 0x000220 */
-	uint64_t	ce_adm_pcie_debug_trig_lat_sel_hi_top;	/* 0x000228 */
-	uint64_t	ce_adm_pcie_trig_compare_top;		/* 0x000230 */
-	uint64_t	ce_adm_pcie_trig_compare_en_top;	/* 0x000238 */
-	uint64_t	ce_adm_ssp_debug_sel_top;		/* 0x000240 */
-	uint64_t	ce_adm_ssp_debug_lat_sel_lo_top;	/* 0x000248 */
-	uint64_t	ce_adm_ssp_debug_lat_sel_hi_top;	/* 0x000250 */
-	uint64_t	ce_adm_ssp_debug_trig_sel_top;		/* 0x000258 */
-	uint64_t	ce_adm_ssp_debug_trig_lat_sel_lo_top;	/* 0x000260 */
-	uint64_t	ce_adm_ssp_debug_trig_lat_sel_hi_top;	/* 0x000268 */
-	uint64_t	ce_adm_ssp_trig_compare_top;		/* 0x000270 */
-	uint64_t	ce_adm_ssp_trig_compare_en_top;		/* 0x000278 */
-	uint64_t	ce_pad_000280[48];	    /* 0x000280 -- 0x0003F8 */
-
-	uint64_t	ce_adm_bap_ctrl;			/* 0x000400 */
-	uint64_t	ce_pad_000408[127];	    /* 0x000408 -- 0x0007F8 */
-
-	uint64_t	ce_msg_buf_data63_0[35];    /* 0x000800 -- 0x000918 */
-	uint64_t	ce_pad_000920[29];	    /* 0x000920 -- 0x0009F8 */
+	u64	ce_adm_id;				/* 0x000000 */
+	u64	ce_pad_000008;				/* 0x000008 */
+	u64	ce_adm_dyn_credit_status;		/* 0x000010 */
+	u64	ce_adm_last_credit_status;		/* 0x000018 */
+	u64	ce_adm_credit_limit;			/* 0x000020 */
+	u64	ce_adm_force_credit;			/* 0x000028 */
+	u64	ce_adm_control;				/* 0x000030 */
+	u64	ce_adm_mmr_chn_timeout;			/* 0x000038 */
+	u64	ce_adm_ssp_ure_timeout;			/* 0x000040 */
+	u64	ce_adm_ssp_dre_timeout;			/* 0x000048 */
+	u64	ce_adm_ssp_debug_sel;			/* 0x000050 */
+	u64	ce_adm_int_status;			/* 0x000058 */
+	u64	ce_adm_int_status_alias;		/* 0x000060 */
+	u64	ce_adm_int_mask;			/* 0x000068 */
+	u64	ce_adm_int_pending;			/* 0x000070 */
+	u64	ce_adm_force_int;			/* 0x000078 */
+	u64	ce_adm_ure_ups_buf_barrier_flush;	/* 0x000080 */
+	u64	ce_adm_int_dest[15];	    /* 0x000088 -- 0x0000F8 */
+	u64	ce_adm_error_summary;			/* 0x000100 */
+	u64	ce_adm_error_summary_alias;		/* 0x000108 */
+	u64	ce_adm_error_mask;			/* 0x000110 */
+	u64	ce_adm_first_error;			/* 0x000118 */
+	u64	ce_adm_error_overflow;			/* 0x000120 */
+	u64	ce_adm_error_overflow_alias;		/* 0x000128 */
+	u64	ce_pad_000130[2];	    /* 0x000130 -- 0x000138 */
+	u64	ce_adm_tnum_error;			/* 0x000140 */
+	u64	ce_adm_mmr_err_detail;			/* 0x000148 */
+	u64	ce_adm_msg_sram_perr_detail;		/* 0x000150 */
+	u64	ce_adm_bap_sram_perr_detail;		/* 0x000158 */
+	u64	ce_adm_ce_sram_perr_detail;		/* 0x000160 */
+	u64	ce_adm_ce_credit_oflow_detail;		/* 0x000168 */
+	u64	ce_adm_tx_link_idle_max_timer;		/* 0x000170 */
+	u64	ce_adm_pcie_debug_sel;			/* 0x000178 */
+	u64	ce_pad_000180[16];	    /* 0x000180 -- 0x0001F8 */
+
+	u64	ce_adm_pcie_debug_sel_top;		/* 0x000200 */
+	u64	ce_adm_pcie_debug_lat_sel_lo_top;	/* 0x000208 */
+	u64	ce_adm_pcie_debug_lat_sel_hi_top;	/* 0x000210 */
+	u64	ce_adm_pcie_debug_trig_sel_top;		/* 0x000218 */
+	u64	ce_adm_pcie_debug_trig_lat_sel_lo_top;	/* 0x000220 */
+	u64	ce_adm_pcie_debug_trig_lat_sel_hi_top;	/* 0x000228 */
+	u64	ce_adm_pcie_trig_compare_top;		/* 0x000230 */
+	u64	ce_adm_pcie_trig_compare_en_top;	/* 0x000238 */
+	u64	ce_adm_ssp_debug_sel_top;		/* 0x000240 */
+	u64	ce_adm_ssp_debug_lat_sel_lo_top;	/* 0x000248 */
+	u64	ce_adm_ssp_debug_lat_sel_hi_top;	/* 0x000250 */
+	u64	ce_adm_ssp_debug_trig_sel_top;		/* 0x000258 */
+	u64	ce_adm_ssp_debug_trig_lat_sel_lo_top;	/* 0x000260 */
+	u64	ce_adm_ssp_debug_trig_lat_sel_hi_top;	/* 0x000268 */
+	u64	ce_adm_ssp_trig_compare_top;		/* 0x000270 */
+	u64	ce_adm_ssp_trig_compare_en_top;		/* 0x000278 */
+	u64	ce_pad_000280[48];	    /* 0x000280 -- 0x0003F8 */
+
+	u64	ce_adm_bap_ctrl;			/* 0x000400 */
+	u64	ce_pad_000408[127];	    /* 0x000408 -- 0x0007F8 */
+
+	u64	ce_msg_buf_data63_0[35];    /* 0x000800 -- 0x000918 */
+	u64	ce_pad_000920[29];	    /* 0x000920 -- 0x0009F8 */
 
-	uint64_t	ce_msg_buf_data127_64[35];  /* 0x000A00 -- 0x000B18 */
-	uint64_t	ce_pad_000B20[29];	    /* 0x000B20 -- 0x000BF8 */
+	u64	ce_msg_buf_data127_64[35];  /* 0x000A00 -- 0x000B18 */
+	u64	ce_pad_000B20[29];	    /* 0x000B20 -- 0x000BF8 */
 
-	uint64_t	ce_msg_buf_parity[35];	    /* 0x000C00 -- 0x000D18 */
-	uint64_t	ce_pad_000D20[29];	    /* 0x000D20 -- 0x000DF8 */
+	u64	ce_msg_buf_parity[35];	    /* 0x000C00 -- 0x000D18 */
+	u64	ce_pad_000D20[29];	    /* 0x000D20 -- 0x000DF8 */
 
-	uint64_t	ce_pad_000E00[576];	    /* 0x000E00 -- 0x001FF8 */
+	u64	ce_pad_000E00[576];	    /* 0x000E00 -- 0x001FF8 */
 
 	/*
 	 * LSI : LSI's PCI Express Link Registers (Link#1 and Link#2)
@@ -109,141 +109,141 @@ typedef volatile struct tioce {
 	 */
 	#define ce_lsi(link_num)	ce_lsi[link_num-1]
 	struct ce_lsi_reg {
-		uint64_t	ce_lsi_lpu_id;			/* 0x00z000 */
-		uint64_t	ce_lsi_rst;			/* 0x00z008 */
-		uint64_t	ce_lsi_dbg_stat;		/* 0x00z010 */
-		uint64_t	ce_lsi_dbg_cfg;			/* 0x00z018 */
-		uint64_t	ce_lsi_ltssm_ctrl;		/* 0x00z020 */
-		uint64_t	ce_lsi_lk_stat;			/* 0x00z028 */
-		uint64_t	ce_pad_00z030[2];   /* 0x00z030 -- 0x00z038 */
-		uint64_t	ce_lsi_int_and_stat;		/* 0x00z040 */
-		uint64_t	ce_lsi_int_mask;		/* 0x00z048 */
-		uint64_t	ce_pad_00z050[22];  /* 0x00z050 -- 0x00z0F8 */
-		uint64_t	ce_lsi_lk_perf_cnt_sel;		/* 0x00z100 */
-		uint64_t	ce_pad_00z108;			/* 0x00z108 */
-		uint64_t	ce_lsi_lk_perf_cnt_ctrl;	/* 0x00z110 */
-		uint64_t	ce_pad_00z118;			/* 0x00z118 */
-		uint64_t	ce_lsi_lk_perf_cnt1;		/* 0x00z120 */
-		uint64_t	ce_lsi_lk_perf_cnt1_test;	/* 0x00z128 */
-		uint64_t	ce_lsi_lk_perf_cnt2;		/* 0x00z130 */
-		uint64_t	ce_lsi_lk_perf_cnt2_test;	/* 0x00z138 */
-		uint64_t	ce_pad_00z140[24];  /* 0x00z140 -- 0x00z1F8 */
-		uint64_t	ce_lsi_lk_lyr_cfg;		/* 0x00z200 */
-		uint64_t	ce_lsi_lk_lyr_status;		/* 0x00z208 */
-		uint64_t	ce_lsi_lk_lyr_int_stat;		/* 0x00z210 */
-		uint64_t	ce_lsi_lk_ly_int_stat_test;	/* 0x00z218 */
-		uint64_t	ce_lsi_lk_ly_int_stat_mask;	/* 0x00z220 */
-		uint64_t	ce_pad_00z228[3];   /* 0x00z228 -- 0x00z238 */
-		uint64_t	ce_lsi_fc_upd_ctl;		/* 0x00z240 */
-		uint64_t	ce_pad_00z248[3];   /* 0x00z248 -- 0x00z258 */
-		uint64_t	ce_lsi_flw_ctl_upd_to_timer;	/* 0x00z260 */
-		uint64_t	ce_lsi_flw_ctl_upd_timer0;	/* 0x00z268 */
-		uint64_t	ce_lsi_flw_ctl_upd_timer1;	/* 0x00z270 */
-		uint64_t	ce_pad_00z278[49];  /* 0x00z278 -- 0x00z3F8 */
-		uint64_t	ce_lsi_freq_nak_lat_thrsh;	/* 0x00z400 */
-		uint64_t	ce_lsi_ack_nak_lat_tmr;		/* 0x00z408 */
-		uint64_t	ce_lsi_rply_tmr_thr;		/* 0x00z410 */
-		uint64_t	ce_lsi_rply_tmr;		/* 0x00z418 */
-		uint64_t	ce_lsi_rply_num_stat;		/* 0x00z420 */
-		uint64_t	ce_lsi_rty_buf_max_addr;	/* 0x00z428 */
-		uint64_t	ce_lsi_rty_fifo_ptr;		/* 0x00z430 */
-		uint64_t	ce_lsi_rty_fifo_rd_wr_ptr;	/* 0x00z438 */
-		uint64_t	ce_lsi_rty_fifo_cred;		/* 0x00z440 */
-		uint64_t	ce_lsi_seq_cnt;			/* 0x00z448 */
-		uint64_t	ce_lsi_ack_sent_seq_num;	/* 0x00z450 */
-		uint64_t	ce_lsi_seq_cnt_fifo_max_addr;	/* 0x00z458 */
-		uint64_t	ce_lsi_seq_cnt_fifo_ptr;	/* 0x00z460 */
-		uint64_t	ce_lsi_seq_cnt_rd_wr_ptr;	/* 0x00z468 */
-		uint64_t	ce_lsi_tx_lk_ts_ctl;		/* 0x00z470 */
-		uint64_t	ce_pad_00z478;			/* 0x00z478 */
-		uint64_t	ce_lsi_mem_addr_ctl;		/* 0x00z480 */
-		uint64_t	ce_lsi_mem_d_ld0;		/* 0x00z488 */
-		uint64_t	ce_lsi_mem_d_ld1;		/* 0x00z490 */
-		uint64_t	ce_lsi_mem_d_ld2;		/* 0x00z498 */
-		uint64_t	ce_lsi_mem_d_ld3;		/* 0x00z4A0 */
-		uint64_t	ce_lsi_mem_d_ld4;		/* 0x00z4A8 */
-		uint64_t	ce_pad_00z4B0[2];   /* 0x00z4B0 -- 0x00z4B8 */
-		uint64_t	ce_lsi_rty_d_cnt;		/* 0x00z4C0 */
-		uint64_t	ce_lsi_seq_buf_cnt;		/* 0x00z4C8 */
-		uint64_t	ce_lsi_seq_buf_bt_d;		/* 0x00z4D0 */
-		uint64_t	ce_pad_00z4D8;			/* 0x00z4D8 */
-		uint64_t	ce_lsi_ack_lat_thr;		/* 0x00z4E0 */
-		uint64_t	ce_pad_00z4E8[3];   /* 0x00z4E8 -- 0x00z4F8 */
-		uint64_t	ce_lsi_nxt_rcv_seq_1_cntr;	/* 0x00z500 */
-		uint64_t	ce_lsi_unsp_dllp_rcvd;		/* 0x00z508 */
-		uint64_t	ce_lsi_rcv_lk_ts_ctl;		/* 0x00z510 */
-		uint64_t	ce_pad_00z518[29];  /* 0x00z518 -- 0x00z5F8 */
-		uint64_t	ce_lsi_phy_lyr_cfg;		/* 0x00z600 */
-		uint64_t	ce_pad_00z608;			/* 0x00z608 */
-		uint64_t	ce_lsi_phy_lyr_int_stat;	/* 0x00z610 */
-		uint64_t	ce_lsi_phy_lyr_int_stat_test;	/* 0x00z618 */
-		uint64_t	ce_lsi_phy_lyr_int_mask;	/* 0x00z620 */
-		uint64_t	ce_pad_00z628[11];  /* 0x00z628 -- 0x00z678 */
-		uint64_t	ce_lsi_rcv_phy_cfg;		/* 0x00z680 */
-		uint64_t	ce_lsi_rcv_phy_stat1;		/* 0x00z688 */
-		uint64_t	ce_lsi_rcv_phy_stat2;		/* 0x00z690 */
-		uint64_t	ce_lsi_rcv_phy_stat3;		/* 0x00z698 */
-		uint64_t	ce_lsi_rcv_phy_int_stat;	/* 0x00z6A0 */
-		uint64_t	ce_lsi_rcv_phy_int_stat_test;	/* 0x00z6A8 */
-		uint64_t	ce_lsi_rcv_phy_int_mask;	/* 0x00z6B0 */
-		uint64_t	ce_pad_00z6B8[9];   /* 0x00z6B8 -- 0x00z6F8 */
-		uint64_t	ce_lsi_tx_phy_cfg;		/* 0x00z700 */
-		uint64_t	ce_lsi_tx_phy_stat;		/* 0x00z708 */
-		uint64_t	ce_lsi_tx_phy_int_stat;		/* 0x00z710 */
-		uint64_t	ce_lsi_tx_phy_int_stat_test;	/* 0x00z718 */
-		uint64_t	ce_lsi_tx_phy_int_mask;		/* 0x00z720 */
-		uint64_t	ce_lsi_tx_phy_stat2;		/* 0x00z728 */
-		uint64_t	ce_pad_00z730[10];  /* 0x00z730 -- 0x00z77F */
-		uint64_t	ce_lsi_ltssm_cfg1;		/* 0x00z780 */
-		uint64_t	ce_lsi_ltssm_cfg2;		/* 0x00z788 */
-		uint64_t	ce_lsi_ltssm_cfg3;		/* 0x00z790 */
-		uint64_t	ce_lsi_ltssm_cfg4;		/* 0x00z798 */
-		uint64_t	ce_lsi_ltssm_cfg5;		/* 0x00z7A0 */
-		uint64_t	ce_lsi_ltssm_stat1;		/* 0x00z7A8 */
-		uint64_t	ce_lsi_ltssm_stat2;		/* 0x00z7B0 */
-		uint64_t	ce_lsi_ltssm_int_stat;		/* 0x00z7B8 */
-		uint64_t	ce_lsi_ltssm_int_stat_test;	/* 0x00z7C0 */
-		uint64_t	ce_lsi_ltssm_int_mask;		/* 0x00z7C8 */
-		uint64_t	ce_lsi_ltssm_stat_wr_en;	/* 0x00z7D0 */
-		uint64_t	ce_pad_00z7D8[5];   /* 0x00z7D8 -- 0x00z7F8 */
-		uint64_t	ce_lsi_gb_cfg1;			/* 0x00z800 */
-		uint64_t	ce_lsi_gb_cfg2;			/* 0x00z808 */
-		uint64_t	ce_lsi_gb_cfg3;			/* 0x00z810 */
-		uint64_t	ce_lsi_gb_cfg4;			/* 0x00z818 */
-		uint64_t	ce_lsi_gb_stat;			/* 0x00z820 */
-		uint64_t	ce_lsi_gb_int_stat;		/* 0x00z828 */
-		uint64_t	ce_lsi_gb_int_stat_test;	/* 0x00z830 */
-		uint64_t	ce_lsi_gb_int_mask;		/* 0x00z838 */
-		uint64_t	ce_lsi_gb_pwr_dn1;		/* 0x00z840 */
-		uint64_t	ce_lsi_gb_pwr_dn2;		/* 0x00z848 */
-		uint64_t	ce_pad_00z850[246]; /* 0x00z850 -- 0x00zFF8 */
+		u64	ce_lsi_lpu_id;			/* 0x00z000 */
+		u64	ce_lsi_rst;			/* 0x00z008 */
+		u64	ce_lsi_dbg_stat;		/* 0x00z010 */
+		u64	ce_lsi_dbg_cfg;			/* 0x00z018 */
+		u64	ce_lsi_ltssm_ctrl;		/* 0x00z020 */
+		u64	ce_lsi_lk_stat;			/* 0x00z028 */
+		u64	ce_pad_00z030[2];   /* 0x00z030 -- 0x00z038 */
+		u64	ce_lsi_int_and_stat;		/* 0x00z040 */
+		u64	ce_lsi_int_mask;		/* 0x00z048 */
+		u64	ce_pad_00z050[22];  /* 0x00z050 -- 0x00z0F8 */
+		u64	ce_lsi_lk_perf_cnt_sel;		/* 0x00z100 */
+		u64	ce_pad_00z108;			/* 0x00z108 */
+		u64	ce_lsi_lk_perf_cnt_ctrl;	/* 0x00z110 */
+		u64	ce_pad_00z118;			/* 0x00z118 */
+		u64	ce_lsi_lk_perf_cnt1;		/* 0x00z120 */
+		u64	ce_lsi_lk_perf_cnt1_test;	/* 0x00z128 */
+		u64	ce_lsi_lk_perf_cnt2;		/* 0x00z130 */
+		u64	ce_lsi_lk_perf_cnt2_test;	/* 0x00z138 */
+		u64	ce_pad_00z140[24];  /* 0x00z140 -- 0x00z1F8 */
+		u64	ce_lsi_lk_lyr_cfg;		/* 0x00z200 */
+		u64	ce_lsi_lk_lyr_status;		/* 0x00z208 */
+		u64	ce_lsi_lk_lyr_int_stat;		/* 0x00z210 */
+		u64	ce_lsi_lk_ly_int_stat_test;	/* 0x00z218 */
+		u64	ce_lsi_lk_ly_int_stat_mask;	/* 0x00z220 */
+		u64	ce_pad_00z228[3];   /* 0x00z228 -- 0x00z238 */
+		u64	ce_lsi_fc_upd_ctl;		/* 0x00z240 */
+		u64	ce_pad_00z248[3];   /* 0x00z248 -- 0x00z258 */
+		u64	ce_lsi_flw_ctl_upd_to_timer;	/* 0x00z260 */
+		u64	ce_lsi_flw_ctl_upd_timer0;	/* 0x00z268 */
+		u64	ce_lsi_flw_ctl_upd_timer1;	/* 0x00z270 */
+		u64	ce_pad_00z278[49];  /* 0x00z278 -- 0x00z3F8 */
+		u64	ce_lsi_freq_nak_lat_thrsh;	/* 0x00z400 */
+		u64	ce_lsi_ack_nak_lat_tmr;		/* 0x00z408 */
+		u64	ce_lsi_rply_tmr_thr;		/* 0x00z410 */
+		u64	ce_lsi_rply_tmr;		/* 0x00z418 */
+		u64	ce_lsi_rply_num_stat;		/* 0x00z420 */
+		u64	ce_lsi_rty_buf_max_addr;	/* 0x00z428 */
+		u64	ce_lsi_rty_fifo_ptr;		/* 0x00z430 */
+		u64	ce_lsi_rty_fifo_rd_wr_ptr;	/* 0x00z438 */
+		u64	ce_lsi_rty_fifo_cred;		/* 0x00z440 */
+		u64	ce_lsi_seq_cnt;			/* 0x00z448 */
+		u64	ce_lsi_ack_sent_seq_num;	/* 0x00z450 */
+		u64	ce_lsi_seq_cnt_fifo_max_addr;	/* 0x00z458 */
+		u64	ce_lsi_seq_cnt_fifo_ptr;	/* 0x00z460 */
+		u64	ce_lsi_seq_cnt_rd_wr_ptr;	/* 0x00z468 */
+		u64	ce_lsi_tx_lk_ts_ctl;		/* 0x00z470 */
+		u64	ce_pad_00z478;			/* 0x00z478 */
+		u64	ce_lsi_mem_addr_ctl;		/* 0x00z480 */
+		u64	ce_lsi_mem_d_ld0;		/* 0x00z488 */
+		u64	ce_lsi_mem_d_ld1;		/* 0x00z490 */
+		u64	ce_lsi_mem_d_ld2;		/* 0x00z498 */
+		u64	ce_lsi_mem_d_ld3;		/* 0x00z4A0 */
+		u64	ce_lsi_mem_d_ld4;		/* 0x00z4A8 */
+		u64	ce_pad_00z4B0[2];   /* 0x00z4B0 -- 0x00z4B8 */
+		u64	ce_lsi_rty_d_cnt;		/* 0x00z4C0 */
+		u64	ce_lsi_seq_buf_cnt;		/* 0x00z4C8 */
+		u64	ce_lsi_seq_buf_bt_d;		/* 0x00z4D0 */
+		u64	ce_pad_00z4D8;			/* 0x00z4D8 */
+		u64	ce_lsi_ack_lat_thr;		/* 0x00z4E0 */
+		u64	ce_pad_00z4E8[3];   /* 0x00z4E8 -- 0x00z4F8 */
+		u64	ce_lsi_nxt_rcv_seq_1_cntr;	/* 0x00z500 */
+		u64	ce_lsi_unsp_dllp_rcvd;		/* 0x00z508 */
+		u64	ce_lsi_rcv_lk_ts_ctl;		/* 0x00z510 */
+		u64	ce_pad_00z518[29];  /* 0x00z518 -- 0x00z5F8 */
+		u64	ce_lsi_phy_lyr_cfg;		/* 0x00z600 */
+		u64	ce_pad_00z608;			/* 0x00z608 */
+		u64	ce_lsi_phy_lyr_int_stat;	/* 0x00z610 */
+		u64	ce_lsi_phy_lyr_int_stat_test;	/* 0x00z618 */
+		u64	ce_lsi_phy_lyr_int_mask;	/* 0x00z620 */
+		u64	ce_pad_00z628[11];  /* 0x00z628 -- 0x00z678 */
+		u64	ce_lsi_rcv_phy_cfg;		/* 0x00z680 */
+		u64	ce_lsi_rcv_phy_stat1;		/* 0x00z688 */
+		u64	ce_lsi_rcv_phy_stat2;		/* 0x00z690 */
+		u64	ce_lsi_rcv_phy_stat3;		/* 0x00z698 */
+		u64	ce_lsi_rcv_phy_int_stat;	/* 0x00z6A0 */
+		u64	ce_lsi_rcv_phy_int_stat_test;	/* 0x00z6A8 */
+		u64	ce_lsi_rcv_phy_int_mask;	/* 0x00z6B0 */
+		u64	ce_pad_00z6B8[9];   /* 0x00z6B8 -- 0x00z6F8 */
+		u64	ce_lsi_tx_phy_cfg;		/* 0x00z700 */
+		u64	ce_lsi_tx_phy_stat;		/* 0x00z708 */
+		u64	ce_lsi_tx_phy_int_stat;		/* 0x00z710 */
+		u64	ce_lsi_tx_phy_int_stat_test;	/* 0x00z718 */
+		u64	ce_lsi_tx_phy_int_mask;		/* 0x00z720 */
+		u64	ce_lsi_tx_phy_stat2;		/* 0x00z728 */
+		u64	ce_pad_00z730[10];  /* 0x00z730 -- 0x00z77F */
+		u64	ce_lsi_ltssm_cfg1;		/* 0x00z780 */
+		u64	ce_lsi_ltssm_cfg2;		/* 0x00z788 */
+		u64	ce_lsi_ltssm_cfg3;		/* 0x00z790 */
+		u64	ce_lsi_ltssm_cfg4;		/* 0x00z798 */
+		u64	ce_lsi_ltssm_cfg5;		/* 0x00z7A0 */
+		u64	ce_lsi_ltssm_stat1;		/* 0x00z7A8 */
+		u64	ce_lsi_ltssm_stat2;		/* 0x00z7B0 */
+		u64	ce_lsi_ltssm_int_stat;		/* 0x00z7B8 */
+		u64	ce_lsi_ltssm_int_stat_test;	/* 0x00z7C0 */
+		u64	ce_lsi_ltssm_int_mask;		/* 0x00z7C8 */
+		u64	ce_lsi_ltssm_stat_wr_en;	/* 0x00z7D0 */
+		u64	ce_pad_00z7D8[5];   /* 0x00z7D8 -- 0x00z7F8 */
+		u64	ce_lsi_gb_cfg1;			/* 0x00z800 */
+		u64	ce_lsi_gb_cfg2;			/* 0x00z808 */
+		u64	ce_lsi_gb_cfg3;			/* 0x00z810 */
+		u64	ce_lsi_gb_cfg4;			/* 0x00z818 */
+		u64	ce_lsi_gb_stat;			/* 0x00z820 */
+		u64	ce_lsi_gb_int_stat;		/* 0x00z828 */
+		u64	ce_lsi_gb_int_stat_test;	/* 0x00z830 */
+		u64	ce_lsi_gb_int_mask;		/* 0x00z838 */
+		u64	ce_lsi_gb_pwr_dn1;		/* 0x00z840 */
+		u64	ce_lsi_gb_pwr_dn2;		/* 0x00z848 */
+		u64	ce_pad_00z850[246]; /* 0x00z850 -- 0x00zFF8 */
 	} ce_lsi[2];
 
-	uint64_t	ce_pad_004000[10];	    /* 0x004000 -- 0x004048 */
+	u64	ce_pad_004000[10];	    /* 0x004000 -- 0x004048 */
 
 	/*
 	 * CRM: Coretalk Receive Module Registers
 	 */
-	uint64_t	ce_crm_debug_mux;			/* 0x004050 */
-	uint64_t	ce_pad_004058;				/* 0x004058 */
-	uint64_t	ce_crm_ssp_err_cmd_wrd;			/* 0x004060 */
-	uint64_t	ce_crm_ssp_err_addr;			/* 0x004068 */
-	uint64_t	ce_crm_ssp_err_syn;			/* 0x004070 */
+	u64	ce_crm_debug_mux;			/* 0x004050 */
+	u64	ce_pad_004058;				/* 0x004058 */
+	u64	ce_crm_ssp_err_cmd_wrd;			/* 0x004060 */
+	u64	ce_crm_ssp_err_addr;			/* 0x004068 */
+	u64	ce_crm_ssp_err_syn;			/* 0x004070 */
 
-	uint64_t	ce_pad_004078[499];	    /* 0x004078 -- 0x005008 */
+	u64	ce_pad_004078[499];	    /* 0x004078 -- 0x005008 */
 
 	/*
          * CXM: Coretalk Xmit Module Registers
          */
-	uint64_t	ce_cxm_dyn_credit_status;		/* 0x005010 */
-	uint64_t	ce_cxm_last_credit_status;		/* 0x005018 */
-	uint64_t	ce_cxm_credit_limit;			/* 0x005020 */
-	uint64_t	ce_cxm_force_credit;			/* 0x005028 */
-	uint64_t	ce_cxm_disable_bypass;			/* 0x005030 */
-	uint64_t	ce_pad_005038[3];	    /* 0x005038 -- 0x005048 */
-	uint64_t	ce_cxm_debug_mux;			/* 0x005050 */
+	u64	ce_cxm_dyn_credit_status;		/* 0x005010 */
+	u64	ce_cxm_last_credit_status;		/* 0x005018 */
+	u64	ce_cxm_credit_limit;			/* 0x005020 */
+	u64	ce_cxm_force_credit;			/* 0x005028 */
+	u64	ce_cxm_disable_bypass;			/* 0x005030 */
+	u64	ce_pad_005038[3];	    /* 0x005038 -- 0x005048 */
+	u64	ce_cxm_debug_mux;			/* 0x005050 */
 
-        uint64_t        ce_pad_005058[501];         /* 0x005058 -- 0x005FF8 */
+        u64        ce_pad_005058[501];         /* 0x005058 -- 0x005FF8 */
 
 	/*
 	 * DTL: Downstream Transaction Layer Regs (Link#1 and Link#2)
@@ -258,209 +258,209 @@ typedef volatile struct tioce {
 	#define ce_utl(link_num)	ce_dtl_utl[link_num-1]
 	struct ce_dtl_utl_reg {
 		/* DTL */
-		uint64_t	ce_dtl_dtdr_credit_limit;	/* 0x00y000 */
-		uint64_t	ce_dtl_dtdr_credit_force;	/* 0x00y008 */
-		uint64_t	ce_dtl_dyn_credit_status;	/* 0x00y010 */
-		uint64_t	ce_dtl_dtl_last_credit_stat;	/* 0x00y018 */
-		uint64_t	ce_dtl_dtl_ctrl;		/* 0x00y020 */
-		uint64_t	ce_pad_00y028[5];   /* 0x00y028 -- 0x00y048 */
-		uint64_t	ce_dtl_debug_sel;		/* 0x00y050 */
-		uint64_t	ce_pad_00y058[501]; /* 0x00y058 -- 0x00yFF8 */
+		u64	ce_dtl_dtdr_credit_limit;	/* 0x00y000 */
+		u64	ce_dtl_dtdr_credit_force;	/* 0x00y008 */
+		u64	ce_dtl_dyn_credit_status;	/* 0x00y010 */
+		u64	ce_dtl_dtl_last_credit_stat;	/* 0x00y018 */
+		u64	ce_dtl_dtl_ctrl;		/* 0x00y020 */
+		u64	ce_pad_00y028[5];   /* 0x00y028 -- 0x00y048 */
+		u64	ce_dtl_debug_sel;		/* 0x00y050 */
+		u64	ce_pad_00y058[501]; /* 0x00y058 -- 0x00yFF8 */
 
 		/* UTL */
-		uint64_t	ce_utl_utl_ctrl;		/* 0x00z000 */
-		uint64_t	ce_utl_debug_sel;		/* 0x00z008 */
-		uint64_t	ce_pad_00z010[510]; /* 0x00z010 -- 0x00zFF8 */
+		u64	ce_utl_utl_ctrl;		/* 0x00z000 */
+		u64	ce_utl_debug_sel;		/* 0x00z008 */
+		u64	ce_pad_00z010[510]; /* 0x00z010 -- 0x00zFF8 */
 	} ce_dtl_utl[2];
 
-	uint64_t	ce_pad_00A000[514];	    /* 0x00A000 -- 0x00B008 */
+	u64	ce_pad_00A000[514];	    /* 0x00A000 -- 0x00B008 */
 
 	/*
 	 * URE: Upstream Request Engine
          */
-	uint64_t	ce_ure_dyn_credit_status;		/* 0x00B010 */
-	uint64_t	ce_ure_last_credit_status;		/* 0x00B018 */
-	uint64_t	ce_ure_credit_limit;			/* 0x00B020 */
-	uint64_t	ce_pad_00B028;				/* 0x00B028 */
-	uint64_t	ce_ure_control;				/* 0x00B030 */
-	uint64_t	ce_ure_status;				/* 0x00B038 */
-	uint64_t	ce_pad_00B040[2];	    /* 0x00B040 -- 0x00B048 */
-	uint64_t	ce_ure_debug_sel;			/* 0x00B050 */
-	uint64_t	ce_ure_pcie_debug_sel;			/* 0x00B058 */
-	uint64_t	ce_ure_ssp_err_cmd_wrd;			/* 0x00B060 */
-	uint64_t	ce_ure_ssp_err_addr;			/* 0x00B068 */
-	uint64_t	ce_ure_page_map;			/* 0x00B070 */
-	uint64_t	ce_ure_dir_map[TIOCE_NUM_PORTS];	/* 0x00B078 */
-	uint64_t	ce_ure_pipe_sel1;			/* 0x00B088 */
-	uint64_t	ce_ure_pipe_mask1;			/* 0x00B090 */
-	uint64_t	ce_ure_pipe_sel2;			/* 0x00B098 */
-	uint64_t	ce_ure_pipe_mask2;			/* 0x00B0A0 */
-	uint64_t	ce_ure_pcie1_credits_sent;		/* 0x00B0A8 */
-	uint64_t	ce_ure_pcie1_credits_used;		/* 0x00B0B0 */
-	uint64_t	ce_ure_pcie1_credit_limit;		/* 0x00B0B8 */
-	uint64_t	ce_ure_pcie2_credits_sent;		/* 0x00B0C0 */
-	uint64_t	ce_ure_pcie2_credits_used;		/* 0x00B0C8 */
-	uint64_t	ce_ure_pcie2_credit_limit;		/* 0x00B0D0 */
-	uint64_t	ce_ure_pcie_force_credit;		/* 0x00B0D8 */
-	uint64_t	ce_ure_rd_tnum_val;			/* 0x00B0E0 */
-	uint64_t	ce_ure_rd_tnum_rsp_rcvd;		/* 0x00B0E8 */
-	uint64_t	ce_ure_rd_tnum_esent_timer;		/* 0x00B0F0 */
-	uint64_t	ce_ure_rd_tnum_error;			/* 0x00B0F8 */
-	uint64_t	ce_ure_rd_tnum_first_cl;		/* 0x00B100 */
-	uint64_t	ce_ure_rd_tnum_link_buf;		/* 0x00B108 */
-	uint64_t	ce_ure_wr_tnum_val;			/* 0x00B110 */
-	uint64_t	ce_ure_sram_err_addr0;			/* 0x00B118 */
-	uint64_t	ce_ure_sram_err_addr1;			/* 0x00B120 */
-	uint64_t	ce_ure_sram_err_addr2;			/* 0x00B128 */
-	uint64_t	ce_ure_sram_rd_addr0;			/* 0x00B130 */
-	uint64_t	ce_ure_sram_rd_addr1;			/* 0x00B138 */
-	uint64_t	ce_ure_sram_rd_addr2;			/* 0x00B140 */
-	uint64_t	ce_ure_sram_wr_addr0;			/* 0x00B148 */
-	uint64_t	ce_ure_sram_wr_addr1;			/* 0x00B150 */
-	uint64_t	ce_ure_sram_wr_addr2;			/* 0x00B158 */
-	uint64_t	ce_ure_buf_flush10;			/* 0x00B160 */
-	uint64_t	ce_ure_buf_flush11;			/* 0x00B168 */
-	uint64_t	ce_ure_buf_flush12;			/* 0x00B170 */
-	uint64_t	ce_ure_buf_flush13;			/* 0x00B178 */
-	uint64_t	ce_ure_buf_flush20;			/* 0x00B180 */
-	uint64_t	ce_ure_buf_flush21;			/* 0x00B188 */
-	uint64_t	ce_ure_buf_flush22;			/* 0x00B190 */
-	uint64_t	ce_ure_buf_flush23;			/* 0x00B198 */
-	uint64_t	ce_ure_pcie_control1;			/* 0x00B1A0 */
-	uint64_t	ce_ure_pcie_control2;			/* 0x00B1A8 */
+	u64	ce_ure_dyn_credit_status;		/* 0x00B010 */
+	u64	ce_ure_last_credit_status;		/* 0x00B018 */
+	u64	ce_ure_credit_limit;			/* 0x00B020 */
+	u64	ce_pad_00B028;				/* 0x00B028 */
+	u64	ce_ure_control;				/* 0x00B030 */
+	u64	ce_ure_status;				/* 0x00B038 */
+	u64	ce_pad_00B040[2];	    /* 0x00B040 -- 0x00B048 */
+	u64	ce_ure_debug_sel;			/* 0x00B050 */
+	u64	ce_ure_pcie_debug_sel;			/* 0x00B058 */
+	u64	ce_ure_ssp_err_cmd_wrd;			/* 0x00B060 */
+	u64	ce_ure_ssp_err_addr;			/* 0x00B068 */
+	u64	ce_ure_page_map;			/* 0x00B070 */
+	u64	ce_ure_dir_map[TIOCE_NUM_PORTS];	/* 0x00B078 */
+	u64	ce_ure_pipe_sel1;			/* 0x00B088 */
+	u64	ce_ure_pipe_mask1;			/* 0x00B090 */
+	u64	ce_ure_pipe_sel2;			/* 0x00B098 */
+	u64	ce_ure_pipe_mask2;			/* 0x00B0A0 */
+	u64	ce_ure_pcie1_credits_sent;		/* 0x00B0A8 */
+	u64	ce_ure_pcie1_credits_used;		/* 0x00B0B0 */
+	u64	ce_ure_pcie1_credit_limit;		/* 0x00B0B8 */
+	u64	ce_ure_pcie2_credits_sent;		/* 0x00B0C0 */
+	u64	ce_ure_pcie2_credits_used;		/* 0x00B0C8 */
+	u64	ce_ure_pcie2_credit_limit;		/* 0x00B0D0 */
+	u64	ce_ure_pcie_force_credit;		/* 0x00B0D8 */
+	u64	ce_ure_rd_tnum_val;			/* 0x00B0E0 */
+	u64	ce_ure_rd_tnum_rsp_rcvd;		/* 0x00B0E8 */
+	u64	ce_ure_rd_tnum_esent_timer;		/* 0x00B0F0 */
+	u64	ce_ure_rd_tnum_error;			/* 0x00B0F8 */
+	u64	ce_ure_rd_tnum_first_cl;		/* 0x00B100 */
+	u64	ce_ure_rd_tnum_link_buf;		/* 0x00B108 */
+	u64	ce_ure_wr_tnum_val;			/* 0x00B110 */
+	u64	ce_ure_sram_err_addr0;			/* 0x00B118 */
+	u64	ce_ure_sram_err_addr1;			/* 0x00B120 */
+	u64	ce_ure_sram_err_addr2;			/* 0x00B128 */
+	u64	ce_ure_sram_rd_addr0;			/* 0x00B130 */
+	u64	ce_ure_sram_rd_addr1;			/* 0x00B138 */
+	u64	ce_ure_sram_rd_addr2;			/* 0x00B140 */
+	u64	ce_ure_sram_wr_addr0;			/* 0x00B148 */
+	u64	ce_ure_sram_wr_addr1;			/* 0x00B150 */
+	u64	ce_ure_sram_wr_addr2;			/* 0x00B158 */
+	u64	ce_ure_buf_flush10;			/* 0x00B160 */
+	u64	ce_ure_buf_flush11;			/* 0x00B168 */
+	u64	ce_ure_buf_flush12;			/* 0x00B170 */
+	u64	ce_ure_buf_flush13;			/* 0x00B178 */
+	u64	ce_ure_buf_flush20;			/* 0x00B180 */
+	u64	ce_ure_buf_flush21;			/* 0x00B188 */
+	u64	ce_ure_buf_flush22;			/* 0x00B190 */
+	u64	ce_ure_buf_flush23;			/* 0x00B198 */
+	u64	ce_ure_pcie_control1;			/* 0x00B1A0 */
+	u64	ce_ure_pcie_control2;			/* 0x00B1A8 */
 
-	uint64_t	ce_pad_00B1B0[458];	    /* 0x00B1B0 -- 0x00BFF8 */
+	u64	ce_pad_00B1B0[458];	    /* 0x00B1B0 -- 0x00BFF8 */
 
 	/* Upstream Data Buffer, Port1 */
 	struct ce_ure_maint_ups_dat1_data {
-		uint64_t	data63_0[512];	    /* 0x00C000 -- 0x00CFF8 */
-		uint64_t	data127_64[512];    /* 0x00D000 -- 0x00DFF8 */
-		uint64_t	parity[512];	    /* 0x00E000 -- 0x00EFF8 */
+		u64	data63_0[512];	    /* 0x00C000 -- 0x00CFF8 */
+		u64	data127_64[512];    /* 0x00D000 -- 0x00DFF8 */
+		u64	parity[512];	    /* 0x00E000 -- 0x00EFF8 */
 	} ce_ure_maint_ups_dat1;
 
 	/* Upstream Header Buffer, Port1 */
 	struct ce_ure_maint_ups_hdr1_data {
-		uint64_t	data63_0[512];	    /* 0x00F000 -- 0x00FFF8 */
-		uint64_t	data127_64[512];    /* 0x010000 -- 0x010FF8 */
-		uint64_t	parity[512];	    /* 0x011000 -- 0x011FF8 */
+		u64	data63_0[512];	    /* 0x00F000 -- 0x00FFF8 */
+		u64	data127_64[512];    /* 0x010000 -- 0x010FF8 */
+		u64	parity[512];	    /* 0x011000 -- 0x011FF8 */
 	} ce_ure_maint_ups_hdr1;
 
 	/* Upstream Data Buffer, Port2 */
 	struct ce_ure_maint_ups_dat2_data {
-		uint64_t	data63_0[512];	    /* 0x012000 -- 0x012FF8 */
-		uint64_t	data127_64[512];    /* 0x013000 -- 0x013FF8 */
-		uint64_t	parity[512];	    /* 0x014000 -- 0x014FF8 */
+		u64	data63_0[512];	    /* 0x012000 -- 0x012FF8 */
+		u64	data127_64[512];    /* 0x013000 -- 0x013FF8 */
+		u64	parity[512];	    /* 0x014000 -- 0x014FF8 */
 	} ce_ure_maint_ups_dat2;
 
 	/* Upstream Header Buffer, Port2 */
 	struct ce_ure_maint_ups_hdr2_data {
-		uint64_t	data63_0[512];	    /* 0x015000 -- 0x015FF8 */
-		uint64_t	data127_64[512];    /* 0x016000 -- 0x016FF8 */
-		uint64_t	parity[512];	    /* 0x017000 -- 0x017FF8 */
+		u64	data63_0[512];	    /* 0x015000 -- 0x015FF8 */
+		u64	data127_64[512];    /* 0x016000 -- 0x016FF8 */
+		u64	parity[512];	    /* 0x017000 -- 0x017FF8 */
 	} ce_ure_maint_ups_hdr2;
 
 	/* Downstream Data Buffer */
 	struct ce_ure_maint_dns_dat_data {
-		uint64_t	data63_0[512];	    /* 0x018000 -- 0x018FF8 */
-		uint64_t	data127_64[512];    /* 0x019000 -- 0x019FF8 */
-		uint64_t	parity[512];	    /* 0x01A000 -- 0x01AFF8 */
+		u64	data63_0[512];	    /* 0x018000 -- 0x018FF8 */
+		u64	data127_64[512];    /* 0x019000 -- 0x019FF8 */
+		u64	parity[512];	    /* 0x01A000 -- 0x01AFF8 */
 	} ce_ure_maint_dns_dat;
 
 	/* Downstream Header Buffer */
 	struct	ce_ure_maint_dns_hdr_data {
-		uint64_t	data31_0[64];	    /* 0x01B000 -- 0x01B1F8 */
-		uint64_t	data95_32[64];	    /* 0x01B200 -- 0x01B3F8 */
-		uint64_t	parity[64];	    /* 0x01B400 -- 0x01B5F8 */
+		u64	data31_0[64];	    /* 0x01B000 -- 0x01B1F8 */
+		u64	data95_32[64];	    /* 0x01B200 -- 0x01B3F8 */
+		u64	parity[64];	    /* 0x01B400 -- 0x01B5F8 */
 	} ce_ure_maint_dns_hdr;
 
 	/* RCI Buffer Data */
 	struct	ce_ure_maint_rci_data {
-		uint64_t	data41_0[64];	    /* 0x01B600 -- 0x01B7F8 */
-		uint64_t	data69_42[64];	    /* 0x01B800 -- 0x01B9F8 */
+		u64	data41_0[64];	    /* 0x01B600 -- 0x01B7F8 */
+		u64	data69_42[64];	    /* 0x01B800 -- 0x01B9F8 */
 	} ce_ure_maint_rci;
 
 	/* Response Queue */
-	uint64_t	ce_ure_maint_rspq[64];	    /* 0x01BA00 -- 0x01BBF8 */
+	u64	ce_ure_maint_rspq[64];	    /* 0x01BA00 -- 0x01BBF8 */
 
-	uint64_t	ce_pad_01C000[4224];	    /* 0x01BC00 -- 0x023FF8 */
+	u64	ce_pad_01C000[4224];	    /* 0x01BC00 -- 0x023FF8 */
 
 	/* Admin Build-a-Packet Buffer */
 	struct	ce_adm_maint_bap_buf_data {
-		uint64_t	data63_0[258];	    /* 0x024000 -- 0x024808 */
-		uint64_t	data127_64[258];    /* 0x024810 -- 0x025018 */
-		uint64_t	parity[258];	    /* 0x025020 -- 0x025828 */
+		u64	data63_0[258];	    /* 0x024000 -- 0x024808 */
+		u64	data127_64[258];    /* 0x024810 -- 0x025018 */
+		u64	parity[258];	    /* 0x025020 -- 0x025828 */
 	} ce_adm_maint_bap_buf;
 
-	uint64_t	ce_pad_025830[5370];	    /* 0x025830 -- 0x02FFF8 */
+	u64	ce_pad_025830[5370];	    /* 0x025830 -- 0x02FFF8 */
 
 	/* URE: 40bit PMU ATE Buffer */		    /* 0x030000 -- 0x037FF8 */
-	uint64_t	ce_ure_ate40[TIOCE_NUM_M40_ATES];
+	u64	ce_ure_ate40[TIOCE_NUM_M40_ATES];
 
 	/* URE: 32/40bit PMU ATE Buffer */	    /* 0x038000 -- 0x03BFF8 */
-	uint64_t	ce_ure_ate3240[TIOCE_NUM_M3240_ATES];
+	u64	ce_ure_ate3240[TIOCE_NUM_M3240_ATES];
 
-	uint64_t	ce_pad_03C000[2050];	    /* 0x03C000 -- 0x040008 */
+	u64	ce_pad_03C000[2050];	    /* 0x03C000 -- 0x040008 */
 
 	/*
 	 * DRE: Down Stream Request Engine
          */
-	uint64_t	ce_dre_dyn_credit_status1;		/* 0x040010 */
-	uint64_t	ce_dre_dyn_credit_status2;		/* 0x040018 */
-	uint64_t	ce_dre_last_credit_status1;		/* 0x040020 */
-	uint64_t	ce_dre_last_credit_status2;		/* 0x040028 */
-	uint64_t	ce_dre_credit_limit1;			/* 0x040030 */
-	uint64_t	ce_dre_credit_limit2;			/* 0x040038 */
-	uint64_t	ce_dre_force_credit1;			/* 0x040040 */
-	uint64_t	ce_dre_force_credit2;			/* 0x040048 */
-	uint64_t	ce_dre_debug_mux1;			/* 0x040050 */
-	uint64_t	ce_dre_debug_mux2;			/* 0x040058 */
-	uint64_t	ce_dre_ssp_err_cmd_wrd;			/* 0x040060 */
-	uint64_t	ce_dre_ssp_err_addr;			/* 0x040068 */
-	uint64_t	ce_dre_comp_err_cmd_wrd;		/* 0x040070 */
-	uint64_t	ce_dre_comp_err_addr;			/* 0x040078 */
-	uint64_t	ce_dre_req_status;			/* 0x040080 */
-	uint64_t	ce_dre_config1;				/* 0x040088 */
-	uint64_t	ce_dre_config2;				/* 0x040090 */
-	uint64_t	ce_dre_config_req_status;		/* 0x040098 */
-	uint64_t	ce_pad_0400A0[12];	    /* 0x0400A0 -- 0x0400F8 */
-	uint64_t	ce_dre_dyn_fifo;			/* 0x040100 */
-	uint64_t	ce_pad_040108[3];	    /* 0x040108 -- 0x040118 */
-	uint64_t	ce_dre_last_fifo;			/* 0x040120 */
+	u64	ce_dre_dyn_credit_status1;		/* 0x040010 */
+	u64	ce_dre_dyn_credit_status2;		/* 0x040018 */
+	u64	ce_dre_last_credit_status1;		/* 0x040020 */
+	u64	ce_dre_last_credit_status2;		/* 0x040028 */
+	u64	ce_dre_credit_limit1;			/* 0x040030 */
+	u64	ce_dre_credit_limit2;			/* 0x040038 */
+	u64	ce_dre_force_credit1;			/* 0x040040 */
+	u64	ce_dre_force_credit2;			/* 0x040048 */
+	u64	ce_dre_debug_mux1;			/* 0x040050 */
+	u64	ce_dre_debug_mux2;			/* 0x040058 */
+	u64	ce_dre_ssp_err_cmd_wrd;			/* 0x040060 */
+	u64	ce_dre_ssp_err_addr;			/* 0x040068 */
+	u64	ce_dre_comp_err_cmd_wrd;		/* 0x040070 */
+	u64	ce_dre_comp_err_addr;			/* 0x040078 */
+	u64	ce_dre_req_status;			/* 0x040080 */
+	u64	ce_dre_config1;				/* 0x040088 */
+	u64	ce_dre_config2;				/* 0x040090 */
+	u64	ce_dre_config_req_status;		/* 0x040098 */
+	u64	ce_pad_0400A0[12];	    /* 0x0400A0 -- 0x0400F8 */
+	u64	ce_dre_dyn_fifo;			/* 0x040100 */
+	u64	ce_pad_040108[3];	    /* 0x040108 -- 0x040118 */
+	u64	ce_dre_last_fifo;			/* 0x040120 */
 
-	uint64_t	ce_pad_040128[27];	    /* 0x040128 -- 0x0401F8 */
+	u64	ce_pad_040128[27];	    /* 0x040128 -- 0x0401F8 */
 
 	/* DRE Downstream Head Queue */
 	struct	ce_dre_maint_ds_head_queue {
-		uint64_t	data63_0[32];	    /* 0x040200 -- 0x0402F8 */
-		uint64_t	data127_64[32];	    /* 0x040300 -- 0x0403F8 */
-		uint64_t	parity[32];	    /* 0x040400 -- 0x0404F8 */
+		u64	data63_0[32];	    /* 0x040200 -- 0x0402F8 */
+		u64	data127_64[32];	    /* 0x040300 -- 0x0403F8 */
+		u64	parity[32];	    /* 0x040400 -- 0x0404F8 */
 	} ce_dre_maint_ds_head_q;
 
-	uint64_t	ce_pad_040500[352];	    /* 0x040500 -- 0x040FF8 */
+	u64	ce_pad_040500[352];	    /* 0x040500 -- 0x040FF8 */
 
 	/* DRE Downstream Data Queue */
 	struct	ce_dre_maint_ds_data_queue {
-		uint64_t	data63_0[256];	    /* 0x041000 -- 0x0417F8 */
-		uint64_t	ce_pad_041800[256]; /* 0x041800 -- 0x041FF8 */
-		uint64_t	data127_64[256];    /* 0x042000 -- 0x0427F8 */
-		uint64_t	ce_pad_042800[256]; /* 0x042800 -- 0x042FF8 */
-		uint64_t	parity[256];	    /* 0x043000 -- 0x0437F8 */
-		uint64_t	ce_pad_043800[256]; /* 0x043800 -- 0x043FF8 */
+		u64	data63_0[256];	    /* 0x041000 -- 0x0417F8 */
+		u64	ce_pad_041800[256]; /* 0x041800 -- 0x041FF8 */
+		u64	data127_64[256];    /* 0x042000 -- 0x0427F8 */
+		u64	ce_pad_042800[256]; /* 0x042800 -- 0x042FF8 */
+		u64	parity[256];	    /* 0x043000 -- 0x0437F8 */
+		u64	ce_pad_043800[256]; /* 0x043800 -- 0x043FF8 */
 	} ce_dre_maint_ds_data_q;
 
 	/* DRE URE Upstream Response Queue */
 	struct	ce_dre_maint_ure_us_rsp_queue {
-		uint64_t	data63_0[8];	    /* 0x044000 -- 0x044038 */
-		uint64_t	ce_pad_044040[24];  /* 0x044040 -- 0x0440F8 */
-		uint64_t	data127_64[8];      /* 0x044100 -- 0x044138 */
-		uint64_t	ce_pad_044140[24];  /* 0x044140 -- 0x0441F8 */
-		uint64_t	parity[8];	    /* 0x044200 -- 0x044238 */
-		uint64_t	ce_pad_044240[24];  /* 0x044240 -- 0x0442F8 */
+		u64	data63_0[8];	    /* 0x044000 -- 0x044038 */
+		u64	ce_pad_044040[24];  /* 0x044040 -- 0x0440F8 */
+		u64	data127_64[8];      /* 0x044100 -- 0x044138 */
+		u64	ce_pad_044140[24];  /* 0x044140 -- 0x0441F8 */
+		u64	parity[8];	    /* 0x044200 -- 0x044238 */
+		u64	ce_pad_044240[24];  /* 0x044240 -- 0x0442F8 */
 	} ce_dre_maint_ure_us_rsp_q;
 
-	uint64_t 	ce_dre_maint_us_wrt_rsp[32];/* 0x044300 -- 0x0443F8 */
+	u64 	ce_dre_maint_us_wrt_rsp[32];/* 0x044300 -- 0x0443F8 */
 
-	uint64_t	ce_end_of_struct;			/* 0x044400 */
+	u64	ce_end_of_struct;			/* 0x044400 */
 } tioce_t;
 
 
@@ -625,11 +625,11 @@ typedef volatile struct tioce {
 #define CE_URE_BUS_MASK			(0xFFULL << BUS_SRC_ID_SHFT)
 #define CE_URE_DEV_MASK			(0x1FULL << DEV_SRC_ID_SHFT)
 #define CE_URE_FNC_MASK			(0x07ULL << FNC_SRC_ID_SHFT)
-#define CE_URE_PIPE_BUS(b)		(((uint64_t)(b) << BUS_SRC_ID_SHFT) & \
+#define CE_URE_PIPE_BUS(b)		(((u64)(b) << BUS_SRC_ID_SHFT) & \
 					 CE_URE_BUS_MASK)
-#define CE_URE_PIPE_DEV(d)		(((uint64_t)(d) << DEV_SRC_ID_SHFT) & \
+#define CE_URE_PIPE_DEV(d)		(((u64)(d) << DEV_SRC_ID_SHFT) & \
 					 CE_URE_DEV_MASK)
-#define CE_URE_PIPE_FNC(f)		(((uint64_t)(f) << FNC_SRC_ID_SHFT) & \
+#define CE_URE_PIPE_FNC(f)		(((u64)(f) << FNC_SRC_ID_SHFT) & \
 					 CE_URE_FNC_MASK)
 
 #define CE_URE_SEL1_SHFT		0
@@ -660,9 +660,9 @@ typedef volatile struct tioce {
 #define CE_URE_PN1_MASK			(0xFFULL << CE_URE_PN1_SHFT)
 #define CE_URE_PN2_SHFT			24
 #define CE_URE_PN2_MASK			(0xFFULL << CE_URE_PN2_SHFT)
-#define CE_URE_PN1_SET(n)		(((uint64_t)(n) << CE_URE_PN1_SHFT) & \
+#define CE_URE_PN1_SET(n)		(((u64)(n) << CE_URE_PN1_SHFT) & \
 					 CE_URE_PN1_MASK)
-#define CE_URE_PN2_SET(n)		(((uint64_t)(n) << CE_URE_PN2_SHFT) & \
+#define CE_URE_PN2_SET(n)		(((u64)(n) << CE_URE_PN2_SHFT) & \
 					 CE_URE_PN2_MASK)
 
 /* ce_ure_pcie_control2 register bit masks & shifts */
@@ -681,9 +681,9 @@ typedef volatile struct tioce {
 #define CE_URE_PSN1_MASK		(0x1FFFULL << CE_URE_PSN1_SHFT)
 #define CE_URE_PSN2_SHFT		32
 #define CE_URE_PSN2_MASK		(0x1FFFULL << CE_URE_PSN2_SHFT)
-#define CE_URE_PSN1_SET(n)		(((uint64_t)(n) << CE_URE_PSN1_SHFT) & \
+#define CE_URE_PSN1_SET(n)		(((u64)(n) << CE_URE_PSN1_SHFT) & \
 					 CE_URE_PSN1_MASK)
-#define CE_URE_PSN2_SET(n)		(((uint64_t)(n) << CE_URE_PSN2_SHFT) & \
+#define CE_URE_PSN2_SET(n)		(((u64)(n) << CE_URE_PSN2_SHFT) & \
 					 CE_URE_PSN2_MASK)
 
 /*
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tioce_provider.h linux-2.6.16-rc1/include/asm-ia64/sn/tioce_provider.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tioce_provider.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tioce_provider.h	2006-01-17 08:22:53.083380078 +0000
@@ -21,9 +21,9 @@
 struct tioce_common {
 	struct pcibus_bussoft	ce_pcibus;	/* common pciio header */
 
-	uint32_t		ce_rev;
-	uint64_t		ce_kernel_private;
-	uint64_t		ce_prom_private;
+	u32		ce_rev;
+	u64		ce_kernel_private;
+	u64		ce_prom_private;
 };
 
 struct tioce_kernel {
@@ -31,31 +31,31 @@ struct tioce_kernel {
 	spinlock_t		ce_lock;
 	struct list_head	ce_dmamap_list;
 
-	uint64_t		ce_ate40_shadow[TIOCE_NUM_M40_ATES];
-	uint64_t		ce_ate3240_shadow[TIOCE_NUM_M3240_ATES];
-	uint32_t		ce_ate3240_pagesize;
+	u64		ce_ate40_shadow[TIOCE_NUM_M40_ATES];
+	u64		ce_ate3240_shadow[TIOCE_NUM_M3240_ATES];
+	u32		ce_ate3240_pagesize;
 
-	uint8_t			ce_port1_secondary;
+	u8			ce_port1_secondary;
 
 	/* per-port resources */
 	struct {
 		int 		dirmap_refcnt;
-		uint64_t	dirmap_shadow;
+		u64	dirmap_shadow;
 	} ce_port[TIOCE_NUM_PORTS];
 };
 
 struct tioce_dmamap {
 	struct list_head	ce_dmamap_list;	/* headed by tioce_kernel */
-	uint32_t		refcnt;
+	u32		refcnt;
 
-	uint64_t		nbytes;		/* # bytes mapped */
+	u64		nbytes;		/* # bytes mapped */
 
-	uint64_t		ct_start;	/* coretalk start address */
-	uint64_t		pci_start;	/* bus start address */
+	u64		ct_start;	/* coretalk start address */
+	u64		pci_start;	/* bus start address */
 
-	uint64_t		*ate_hw;	/* hw ptr of first ate in map */
-	uint64_t		*ate_shadow;	/* shadow ptr of firat ate */
-	uint16_t		ate_count;	/* # ate's in the map */
+	u64		*ate_hw;	/* hw ptr of first ate in map */
+	u64		*ate_shadow;	/* shadow ptr of firat ate */
+	u16		ate_count;	/* # ate's in the map */
 };
 
 extern int tioce_init_provider(void);
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tiocp.h linux-2.6.16-rc1/include/asm-ia64/sn/tiocp.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tiocp.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tiocp.h	2006-01-17 08:22:53.089379133 +0000
@@ -21,189 +21,189 @@ struct tiocp{
     /* 0x000000-0x00FFFF -- Local Registers */
 
     /* 0x000000-0x000057 -- (Legacy Widget Space) Configuration */
-    uint64_t		cp_id;				/* 0x000000 */
-    uint64_t		cp_stat;			/* 0x000008 */
-    uint64_t		cp_err_upper;			/* 0x000010 */
-    uint64_t		cp_err_lower;			/* 0x000018 */
+    u64		cp_id;				/* 0x000000 */
+    u64		cp_stat;			/* 0x000008 */
+    u64		cp_err_upper;			/* 0x000010 */
+    u64		cp_err_lower;			/* 0x000018 */
     #define cp_err cp_err_lower
-    uint64_t		cp_control;			/* 0x000020 */
-    uint64_t		cp_req_timeout;			/* 0x000028 */
-    uint64_t		cp_intr_upper;			/* 0x000030 */
-    uint64_t		cp_intr_lower;			/* 0x000038 */
+    u64		cp_control;			/* 0x000020 */
+    u64		cp_req_timeout;			/* 0x000028 */
+    u64		cp_intr_upper;			/* 0x000030 */
+    u64		cp_intr_lower;			/* 0x000038 */
     #define cp_intr cp_intr_lower
-    uint64_t		cp_err_cmdword;			/* 0x000040 */
-    uint64_t		_pad_000048;			/* 0x000048 */
-    uint64_t		cp_tflush;			/* 0x000050 */
+    u64		cp_err_cmdword;			/* 0x000040 */
+    u64		_pad_000048;			/* 0x000048 */
+    u64		cp_tflush;			/* 0x000050 */
 
     /* 0x000058-0x00007F -- Bridge-specific Configuration */
-    uint64_t		cp_aux_err;			/* 0x000058 */
-    uint64_t		cp_resp_upper;			/* 0x000060 */
-    uint64_t		cp_resp_lower;			/* 0x000068 */
+    u64		cp_aux_err;			/* 0x000058 */
+    u64		cp_resp_upper;			/* 0x000060 */
+    u64		cp_resp_lower;			/* 0x000068 */
     #define cp_resp cp_resp_lower
-    uint64_t		cp_tst_pin_ctrl;		/* 0x000070 */
-    uint64_t		cp_addr_lkerr;			/* 0x000078 */
+    u64		cp_tst_pin_ctrl;		/* 0x000070 */
+    u64		cp_addr_lkerr;			/* 0x000078 */
 
     /* 0x000080-0x00008F -- PMU & MAP */
-    uint64_t		cp_dir_map;			/* 0x000080 */
-    uint64_t		_pad_000088;			/* 0x000088 */
+    u64		cp_dir_map;			/* 0x000080 */
+    u64		_pad_000088;			/* 0x000088 */
 
     /* 0x000090-0x00009F -- SSRAM */
-    uint64_t		cp_map_fault;			/* 0x000090 */
-    uint64_t		_pad_000098;			/* 0x000098 */
+    u64		cp_map_fault;			/* 0x000090 */
+    u64		_pad_000098;			/* 0x000098 */
 
     /* 0x0000A0-0x0000AF -- Arbitration */
-    uint64_t		cp_arb;				/* 0x0000A0 */
-    uint64_t		_pad_0000A8;			/* 0x0000A8 */
+    u64		cp_arb;				/* 0x0000A0 */
+    u64		_pad_0000A8;			/* 0x0000A8 */
 
     /* 0x0000B0-0x0000BF -- Number In A Can or ATE Parity Error */
-    uint64_t		cp_ate_parity_err;		/* 0x0000B0 */
-    uint64_t		_pad_0000B8;			/* 0x0000B8 */
+    u64		cp_ate_parity_err;		/* 0x0000B0 */
+    u64		_pad_0000B8;			/* 0x0000B8 */
 
     /* 0x0000C0-0x0000FF -- PCI/GIO */
-    uint64_t		cp_bus_timeout;			/* 0x0000C0 */
-    uint64_t		cp_pci_cfg;			/* 0x0000C8 */
-    uint64_t		cp_pci_err_upper;		/* 0x0000D0 */
-    uint64_t		cp_pci_err_lower;		/* 0x0000D8 */
+    u64		cp_bus_timeout;			/* 0x0000C0 */
+    u64		cp_pci_cfg;			/* 0x0000C8 */
+    u64		cp_pci_err_upper;		/* 0x0000D0 */
+    u64		cp_pci_err_lower;		/* 0x0000D8 */
     #define cp_pci_err cp_pci_err_lower
-    uint64_t		_pad_0000E0[4];			/* 0x0000{E0..F8} */
+    u64		_pad_0000E0[4];			/* 0x0000{E0..F8} */
 
     /* 0x000100-0x0001FF -- Interrupt */
-    uint64_t		cp_int_status;			/* 0x000100 */
-    uint64_t		cp_int_enable;			/* 0x000108 */
-    uint64_t		cp_int_rst_stat;		/* 0x000110 */
-    uint64_t		cp_int_mode;			/* 0x000118 */
-    uint64_t		cp_int_device;			/* 0x000120 */
-    uint64_t		cp_int_host_err;		/* 0x000128 */
-    uint64_t		cp_int_addr[8];			/* 0x0001{30,,,68} */
-    uint64_t		cp_err_int_view;		/* 0x000170 */
-    uint64_t		cp_mult_int;			/* 0x000178 */
-    uint64_t		cp_force_always[8];		/* 0x0001{80,,,B8} */
-    uint64_t		cp_force_pin[8];		/* 0x0001{C0,,,F8} */
+    u64		cp_int_status;			/* 0x000100 */
+    u64		cp_int_enable;			/* 0x000108 */
+    u64		cp_int_rst_stat;		/* 0x000110 */
+    u64		cp_int_mode;			/* 0x000118 */
+    u64		cp_int_device;			/* 0x000120 */
+    u64		cp_int_host_err;		/* 0x000128 */
+    u64		cp_int_addr[8];			/* 0x0001{30,,,68} */
+    u64		cp_err_int_view;		/* 0x000170 */
+    u64		cp_mult_int;			/* 0x000178 */
+    u64		cp_force_always[8];		/* 0x0001{80,,,B8} */
+    u64		cp_force_pin[8];		/* 0x0001{C0,,,F8} */
 
     /* 0x000200-0x000298 -- Device */
-    uint64_t		cp_device[4];			/* 0x0002{00,,,18} */
-    uint64_t		_pad_000220[4];			/* 0x0002{20,,,38} */
-    uint64_t		cp_wr_req_buf[4];		/* 0x0002{40,,,58} */
-    uint64_t		_pad_000260[4];			/* 0x0002{60,,,78} */
-    uint64_t		cp_rrb_map[2];			/* 0x0002{80,,,88} */
+    u64		cp_device[4];			/* 0x0002{00,,,18} */
+    u64		_pad_000220[4];			/* 0x0002{20,,,38} */
+    u64		cp_wr_req_buf[4];		/* 0x0002{40,,,58} */
+    u64		_pad_000260[4];			/* 0x0002{60,,,78} */
+    u64		cp_rrb_map[2];			/* 0x0002{80,,,88} */
     #define cp_even_resp cp_rrb_map[0]			/* 0x000280 */
     #define cp_odd_resp  cp_rrb_map[1]			/* 0x000288 */
-    uint64_t		cp_resp_status;			/* 0x000290 */
-    uint64_t		cp_resp_clear;			/* 0x000298 */
+    u64		cp_resp_status;			/* 0x000290 */
+    u64		cp_resp_clear;			/* 0x000298 */
 
-    uint64_t		_pad_0002A0[12];		/* 0x0002{A0..F8} */
+    u64		_pad_0002A0[12];		/* 0x0002{A0..F8} */
 
     /* 0x000300-0x0003F8 -- Buffer Address Match Registers */
     struct {
-	uint64_t	upper;				/* 0x0003{00,,,F0} */
-	uint64_t	lower;				/* 0x0003{08,,,F8} */
+	u64	upper;				/* 0x0003{00,,,F0} */
+	u64	lower;				/* 0x0003{08,,,F8} */
     } cp_buf_addr_match[16];
 
     /* 0x000400-0x0005FF -- Performance Monitor Registers (even only) */
     struct {
-	uint64_t	flush_w_touch;			/* 0x000{400,,,5C0} */
-	uint64_t	flush_wo_touch;			/* 0x000{408,,,5C8} */
-	uint64_t	inflight;			/* 0x000{410,,,5D0} */
-	uint64_t	prefetch;			/* 0x000{418,,,5D8} */
-	uint64_t	total_pci_retry;		/* 0x000{420,,,5E0} */
-	uint64_t	max_pci_retry;			/* 0x000{428,,,5E8} */
-	uint64_t	max_latency;			/* 0x000{430,,,5F0} */
-	uint64_t	clear_all;			/* 0x000{438,,,5F8} */
+	u64	flush_w_touch;			/* 0x000{400,,,5C0} */
+	u64	flush_wo_touch;			/* 0x000{408,,,5C8} */
+	u64	inflight;			/* 0x000{410,,,5D0} */
+	u64	prefetch;			/* 0x000{418,,,5D8} */
+	u64	total_pci_retry;		/* 0x000{420,,,5E0} */
+	u64	max_pci_retry;			/* 0x000{428,,,5E8} */
+	u64	max_latency;			/* 0x000{430,,,5F0} */
+	u64	clear_all;			/* 0x000{438,,,5F8} */
     } cp_buf_count[8];
 
 
     /* 0x000600-0x0009FF -- PCI/X registers */
-    uint64_t		cp_pcix_bus_err_addr;		/* 0x000600 */
-    uint64_t		cp_pcix_bus_err_attr;		/* 0x000608 */
-    uint64_t		cp_pcix_bus_err_data;		/* 0x000610 */
-    uint64_t		cp_pcix_pio_split_addr;		/* 0x000618 */
-    uint64_t		cp_pcix_pio_split_attr;		/* 0x000620 */
-    uint64_t		cp_pcix_dma_req_err_attr;	/* 0x000628 */
-    uint64_t		cp_pcix_dma_req_err_addr;	/* 0x000630 */
-    uint64_t		cp_pcix_timeout;		/* 0x000638 */
+    u64		cp_pcix_bus_err_addr;		/* 0x000600 */
+    u64		cp_pcix_bus_err_attr;		/* 0x000608 */
+    u64		cp_pcix_bus_err_data;		/* 0x000610 */
+    u64		cp_pcix_pio_split_addr;		/* 0x000618 */
+    u64		cp_pcix_pio_split_attr;		/* 0x000620 */
+    u64		cp_pcix_dma_req_err_attr;	/* 0x000628 */
+    u64		cp_pcix_dma_req_err_addr;	/* 0x000630 */
+    u64		cp_pcix_timeout;		/* 0x000638 */
 
-    uint64_t		_pad_000640[24];		/* 0x000{640,,,6F8} */
+    u64		_pad_000640[24];		/* 0x000{640,,,6F8} */
 
     /* 0x000700-0x000737 -- Debug Registers */
-    uint64_t		cp_ct_debug_ctl;		/* 0x000700 */
-    uint64_t		cp_br_debug_ctl;		/* 0x000708 */
-    uint64_t		cp_mux3_debug_ctl;		/* 0x000710 */
-    uint64_t		cp_mux4_debug_ctl;		/* 0x000718 */
-    uint64_t		cp_mux5_debug_ctl;		/* 0x000720 */
-    uint64_t		cp_mux6_debug_ctl;		/* 0x000728 */
-    uint64_t		cp_mux7_debug_ctl;		/* 0x000730 */
+    u64		cp_ct_debug_ctl;		/* 0x000700 */
+    u64		cp_br_debug_ctl;		/* 0x000708 */
+    u64		cp_mux3_debug_ctl;		/* 0x000710 */
+    u64		cp_mux4_debug_ctl;		/* 0x000718 */
+    u64		cp_mux5_debug_ctl;		/* 0x000720 */
+    u64		cp_mux6_debug_ctl;		/* 0x000728 */
+    u64		cp_mux7_debug_ctl;		/* 0x000730 */
 
-    uint64_t		_pad_000738[89];		/* 0x000{738,,,9F8} */
+    u64		_pad_000738[89];		/* 0x000{738,,,9F8} */
 
     /* 0x000A00-0x000BFF -- PCI/X Read&Write Buffer */
     struct {
-	uint64_t	cp_buf_addr;			/* 0x000{A00,,,AF0} */
-	uint64_t	cp_buf_attr;			/* 0X000{A08,,,AF8} */
+	u64	cp_buf_addr;			/* 0x000{A00,,,AF0} */
+	u64	cp_buf_attr;			/* 0X000{A08,,,AF8} */
     } cp_pcix_read_buf_64[16];
 
     struct {
-	uint64_t	cp_buf_addr;			/* 0x000{B00,,,BE0} */
-	uint64_t	cp_buf_attr;			/* 0x000{B08,,,BE8} */
-	uint64_t	cp_buf_valid;			/* 0x000{B10,,,BF0} */
-	uint64_t	__pad1;				/* 0x000{B18,,,BF8} */
+	u64	cp_buf_addr;			/* 0x000{B00,,,BE0} */
+	u64	cp_buf_attr;			/* 0x000{B08,,,BE8} */
+	u64	cp_buf_valid;			/* 0x000{B10,,,BF0} */
+	u64	__pad1;				/* 0x000{B18,,,BF8} */
     } cp_pcix_write_buf_64[8];
 
     /* End of Local Registers -- Start of Address Map space */
 
-    char		_pad_000c00[0x010000 - 0x000c00];
+    char	_pad_000c00[0x010000 - 0x000c00];
 
     /* 0x010000-0x011FF8 -- Internal ATE RAM (Auto Parity Generation) */
-    uint64_t		cp_int_ate_ram[1024];		/* 0x010000-0x011FF8 */
+    u64		cp_int_ate_ram[1024];		/* 0x010000-0x011FF8 */
 
-    char		_pad_012000[0x14000 - 0x012000];
+    char	_pad_012000[0x14000 - 0x012000];
 
     /* 0x014000-0x015FF8 -- Internal ATE RAM (Manual Parity Generation) */
-    uint64_t		cp_int_ate_ram_mp[1024];	/* 0x014000-0x015FF8 */
+    u64		cp_int_ate_ram_mp[1024];	/* 0x014000-0x015FF8 */
 
-    char		_pad_016000[0x18000 - 0x016000];
+    char	_pad_016000[0x18000 - 0x016000];
 
     /* 0x18000-0x197F8 -- TIOCP Write Request Ram */
-    uint64_t		cp_wr_req_lower[256];		/* 0x18000 - 0x187F8 */
-    uint64_t		cp_wr_req_upper[256];		/* 0x18800 - 0x18FF8 */
-    uint64_t		cp_wr_req_parity[256];		/* 0x19000 - 0x197F8 */
+    u64		cp_wr_req_lower[256];		/* 0x18000 - 0x187F8 */
+    u64		cp_wr_req_upper[256];		/* 0x18800 - 0x18FF8 */
+    u64		cp_wr_req_parity[256];		/* 0x19000 - 0x197F8 */
 
-    char		_pad_019800[0x1C000 - 0x019800];
+    char	_pad_019800[0x1C000 - 0x019800];
 
     /* 0x1C000-0x1EFF8 -- TIOCP Read Response Ram */
-    uint64_t		cp_rd_resp_lower[512];		/* 0x1C000 - 0x1CFF8 */
-    uint64_t		cp_rd_resp_upper[512];		/* 0x1D000 - 0x1DFF8 */
-    uint64_t		cp_rd_resp_parity[512];		/* 0x1E000 - 0x1EFF8 */
+    u64		cp_rd_resp_lower[512];		/* 0x1C000 - 0x1CFF8 */
+    u64		cp_rd_resp_upper[512];		/* 0x1D000 - 0x1DFF8 */
+    u64		cp_rd_resp_parity[512];		/* 0x1E000 - 0x1EFF8 */
 
-    char		_pad_01F000[0x20000 - 0x01F000];
+    char	_pad_01F000[0x20000 - 0x01F000];
 
     /* 0x020000-0x021FFF -- Host Device (CP) Configuration Space (not used)  */
-    char		_pad_020000[0x021000 - 0x20000];
+    char	_pad_020000[0x021000 - 0x20000];
 
     /* 0x021000-0x027FFF -- PCI Device Configuration Spaces */
     union {
-	uint8_t		c[0x1000 / 1];			/* 0x02{0000,,,7FFF} */
-	uint16_t	s[0x1000 / 2];			/* 0x02{0000,,,7FFF} */
-	uint32_t	l[0x1000 / 4];			/* 0x02{0000,,,7FFF} */
-	uint64_t	d[0x1000 / 8];			/* 0x02{0000,,,7FFF} */
+	u8	c[0x1000 / 1];			/* 0x02{0000,,,7FFF} */
+	u16	s[0x1000 / 2];			/* 0x02{0000,,,7FFF} */
+	u32	l[0x1000 / 4];			/* 0x02{0000,,,7FFF} */
+	u64	d[0x1000 / 8];			/* 0x02{0000,,,7FFF} */
 	union {
-	    uint8_t	c[0x100 / 1];
-	    uint16_t	s[0x100 / 2];
-	    uint32_t	l[0x100 / 4];
-	    uint64_t	d[0x100 / 8];
+	    u8	c[0x100 / 1];
+	    u16	s[0x100 / 2];
+	    u32	l[0x100 / 4];
+	    u64	d[0x100 / 8];
 	} f[8];
     } cp_type0_cfg_dev[7];				/* 0x02{1000,,,7FFF} */
 
     /* 0x028000-0x028FFF -- PCI Type 1 Configuration Space */
     union {
-	uint8_t		c[0x1000 / 1];			/* 0x028000-0x029000 */
-	uint16_t	s[0x1000 / 2];			/* 0x028000-0x029000 */
-	uint32_t	l[0x1000 / 4];			/* 0x028000-0x029000 */
-	uint64_t	d[0x1000 / 8];			/* 0x028000-0x029000 */
+	u8	c[0x1000 / 1];			/* 0x028000-0x029000 */
+	u16	s[0x1000 / 2];			/* 0x028000-0x029000 */
+	u32	l[0x1000 / 4];			/* 0x028000-0x029000 */
+	u64	d[0x1000 / 8];			/* 0x028000-0x029000 */
 	union {
-	    uint8_t	c[0x100 / 1];
-	    uint16_t	s[0x100 / 2];
-	    uint32_t	l[0x100 / 4];
-	    uint64_t	d[0x100 / 8];
+	    u8	c[0x100 / 1];
+	    u16	s[0x100 / 2];
+	    u32	l[0x100 / 4];
+	    u64	d[0x100 / 8];
 	} f[8];
     } cp_type1_cfg;					/* 0x028000-0x029000 */
 
@@ -211,30 +211,30 @@ struct tiocp{
 
     /* 0x030000-0x030007 -- PCI Interrupt Acknowledge Cycle */
     union {
-	uint8_t		c[8 / 1];
-	uint16_t	s[8 / 2];
-	uint32_t	l[8 / 4];
-	uint64_t	d[8 / 8];
+	u8	c[8 / 1];
+	u16	s[8 / 2];
+	u32	l[8 / 4];
+	u64	d[8 / 8];
     } cp_pci_iack;					/* 0x030000-0x030007 */
 
     char		_pad_030007[0x040000-0x030008];
 
     /* 0x040000-0x040007 -- PCIX Special Cycle */
     union {
-	uint8_t		c[8 / 1];
-	uint16_t	s[8 / 2];
-	uint32_t	l[8 / 4];
-	uint64_t	d[8 / 8];
+	u8	c[8 / 1];
+	u16	s[8 / 2];
+	u32	l[8 / 4];
+	u64	d[8 / 8];
     } cp_pcix_cycle;					/* 0x040000-0x040007 */
 
     char		_pad_040007[0x200000-0x040008];
 
     /* 0x200000-0x7FFFFF -- PCI/GIO Device Spaces */
     union {
-	uint8_t		c[0x100000 / 1];
-	uint16_t	s[0x100000 / 2];
-	uint32_t	l[0x100000 / 4];
-	uint64_t	d[0x100000 / 8];
+	u8	c[0x100000 / 1];
+	u16	s[0x100000 / 2];
+	u32	l[0x100000 / 4];
+	u64	d[0x100000 / 8];
     } cp_devio_raw[6];					/* 0x200000-0x7FFFFF */
 
     #define cp_devio(n)  cp_devio_raw[((n)<2)?(n*2):(n+2)]
@@ -243,10 +243,10 @@ struct tiocp{
 
     /* 0xA00000-0xBFFFFF -- PCI/GIO Device Spaces w/flush  */
     union {
-	uint8_t		c[0x100000 / 1];
-	uint16_t	s[0x100000 / 2];
-	uint32_t	l[0x100000 / 4];
-	uint64_t	d[0x100000 / 8];
+	u8	c[0x100000 / 1];
+	u16	s[0x100000 / 2];
+	u32	l[0x100000 / 4];
+	u64	d[0x100000 / 8];
     } cp_devio_raw_flush[6];				/* 0xA00000-0xBFFFFF */
 
     #define cp_devio_flush(n)  cp_devio_raw_flush[((n)<2)?(n*2):(n+2)]
diff -purN linux-2.6.15-git12/include/asm-ia64/sn/tiocx.h linux-2.6.16-rc1/include/asm-ia64/sn/tiocx.h
--- linux-2.6.15-git12/include/asm-ia64/sn/tiocx.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-ia64/sn/tiocx.h	2006-01-17 08:22:53.090378976 +0000
@@ -40,10 +40,10 @@ struct cx_drv {
 };
 
 /* create DMA address by stripping AS bits */
-#define TIOCX_DMA_ADDR(a) (uint64_t)((uint64_t)(a) & 0xffffcfffffffffUL)
+#define TIOCX_DMA_ADDR(a) (u64)((u64)(a) & 0xffffcfffffffffUL)
 
-#define TIOCX_TO_TIOCX_DMA_ADDR(a) (uint64_t)(((uint64_t)(a) & 0xfffffffff) |  \
-                                  ((((uint64_t)(a)) & 0xffffc000000000UL) <<2))
+#define TIOCX_TO_TIOCX_DMA_ADDR(a) (u64)(((u64)(a) & 0xfffffffff) |  \
+                                  ((((u64)(a)) & 0xffffc000000000UL) <<2))
 
 #define TIO_CE_ASIC_PARTNUM 0xce00
 #define TIOCX_CORELET 3
@@ -63,10 +63,10 @@ extern int cx_device_unregister(struct c
 extern int cx_device_register(nasid_t, int, int, struct hubdev_info *, int);
 extern int cx_driver_unregister(struct cx_drv *);
 extern int cx_driver_register(struct cx_drv *);
-extern uint64_t tiocx_dma_addr(uint64_t addr);
-extern uint64_t tiocx_swin_base(int nasid);
-extern void tiocx_mmr_store(int nasid, uint64_t offset, uint64_t value);
-extern uint64_t tiocx_mmr_load(int nasid, uint64_t offset);
+extern u64 tiocx_dma_addr(u64 addr);
+extern u64 tiocx_swin_base(int nasid);
+extern void tiocx_mmr_store(int nasid, u64 offset, u64 value);
+extern u64 tiocx_mmr_load(int nasid, u64 offset);
 
 #endif				//  __KERNEL__
 #endif				// _ASM_IA64_SN_TIO_TIOCX__
diff -purN linux-2.6.15-git12/include/asm-sh/bus-sh.h linux-2.6.16-rc1/include/asm-sh/bus-sh.h
--- linux-2.6.15-git12/include/asm-sh/bus-sh.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/bus-sh.h	2006-01-17 08:22:53.459320885 +0000
@@ -21,6 +21,7 @@ struct sh_dev {
 	void		*mapbase;
 	unsigned int	irq[6];
 	u64		*dma_mask;
+	u64		coherent_dma_mask;
 };
 
 #define to_sh_dev(d)	container_of((d), struct sh_dev, dev)
diff -purN linux-2.6.15-git12/include/asm-sh/clock.h linux-2.6.16-rc1/include/asm-sh/clock.h
--- linux-2.6.15-git12/include/asm-sh/clock.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/clock.h	2006-01-17 08:22:53.461320570 +0000
@@ -0,0 +1,61 @@
+#ifndef __ASM_SH_CLOCK_H
+#define __ASM_SH_CLOCK_H
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/seq_file.h>
+
+struct clk;
+
+struct clk_ops {
+	void (*init)(struct clk *clk);
+	void (*enable)(struct clk *clk);
+	void (*disable)(struct clk *clk);
+	void (*recalc)(struct clk *clk);
+	int (*set_rate)(struct clk *clk, unsigned long rate);
+};
+
+struct clk {
+	struct list_head	node;
+	const char		*name;
+
+	struct module		*owner;
+
+	struct clk		*parent;
+	struct clk_ops		*ops;
+
+	struct kref		kref;
+
+	unsigned long		rate;
+	unsigned long		flags;
+};
+
+#define CLK_ALWAYS_ENABLED	(1 << 0)
+#define CLK_RATE_PROPAGATES	(1 << 1)
+
+/* Should be defined by processor-specific code */
+void arch_init_clk_ops(struct clk_ops **, int type);
+
+/* arch/sh/kernel/cpu/clock.c */
+int clk_init(void);
+
+int __clk_enable(struct clk *);
+int clk_enable(struct clk *);
+
+void __clk_disable(struct clk *);
+void clk_disable(struct clk *);
+
+int clk_set_rate(struct clk *, unsigned long rate);
+unsigned long clk_get_rate(struct clk *);
+void clk_recalc_rate(struct clk *);
+
+struct clk *clk_get(const char *id);
+void clk_put(struct clk *);
+
+int clk_register(struct clk *);
+void clk_unregister(struct clk *);
+
+int show_clocks(struct seq_file *m);
+
+#endif /* __ASM_SH_CLOCK_H */
+
diff -purN linux-2.6.15-git12/include/asm-sh/cpu-sh3/dma.h linux-2.6.16-rc1/include/asm-sh/cpu-sh3/dma.h
--- linux-2.6.15-git12/include/asm-sh/cpu-sh3/dma.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/cpu-sh3/dma.h	2006-01-17 08:22:53.462320413 +0000
@@ -3,5 +3,34 @@
 
 #define SH_DMAC_BASE	0xa4000020
 
-#endif /* __ASM_CPU_SH3_DMA_H */
+/* Definitions for the SuperH DMAC */
+#define TM_BURST	0x00000020
+#define TS_8		0x00000000
+#define TS_16		0x00000008
+#define TS_32		0x00000010
+#define TS_128		0x00000018
+
+#define CHCR_TS_MASK	0x18
+#define CHCR_TS_SHIFT	3
+
+#define DMAOR_INIT	DMAOR_DME
 
+/*
+ * The SuperH DMAC supports a number of transmit sizes, we list them here,
+ * with their respective values as they appear in the CHCR registers.
+ */
+enum {
+	XMIT_SZ_8BIT,
+	XMIT_SZ_16BIT,
+	XMIT_SZ_32BIT,
+	XMIT_SZ_128BIT,
+};
+
+static unsigned int ts_shift[] __attribute__ ((used)) = {
+	[XMIT_SZ_8BIT]		= 0,
+	[XMIT_SZ_16BIT]		= 1,
+	[XMIT_SZ_32BIT]		= 2,
+	[XMIT_SZ_128BIT]	= 4,
+};
+
+#endif /* __ASM_CPU_SH3_DMA_H */
diff -purN linux-2.6.15-git12/include/asm-sh/cpu-sh4/dma.h linux-2.6.16-rc1/include/asm-sh/cpu-sh4/dma.h
--- linux-2.6.15-git12/include/asm-sh/cpu-sh4/dma.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/cpu-sh4/dma.h	2006-01-17 08:22:53.463320255 +0000
@@ -1,17 +1,49 @@
 #ifndef __ASM_CPU_SH4_DMA_H
 #define __ASM_CPU_SH4_DMA_H
 
+#ifdef CONFIG_CPU_SH4A
+#define SH_DMAC_BASE	0xfc808020
+#else
 #define SH_DMAC_BASE	0xffa00000
+#endif
 
-#define SAR	((unsigned long[]){SH_DMAC_BASE + 0x00, SH_DMAC_BASE + 0x10, \
-				   SH_DMAC_BASE + 0x20, SH_DMAC_BASE + 0x30})
-#define DAR	((unsigned long[]){SH_DMAC_BASE + 0x04, SH_DMAC_BASE + 0x14, \
-				   SH_DMAC_BASE + 0x24, SH_DMAC_BASE + 0x34})
-#define DMATCR	((unsigned long[]){SH_DMAC_BASE + 0x08, SH_DMAC_BASE + 0x18, \
-				   SH_DMAC_BASE + 0x28, SH_DMAC_BASE + 0x38})
-#define CHCR	((unsigned long[]){SH_DMAC_BASE + 0x0c, SH_DMAC_BASE + 0x1c, \
-				   SH_DMAC_BASE + 0x2c, SH_DMAC_BASE + 0x3c})
-#define DMAOR	(SH_DMAC_BASE + 0x40)
+/* Definitions for the SuperH DMAC */
+#define TM_BURST	0x0000080
+#define TS_8		0x00000010
+#define TS_16		0x00000020
+#define TS_32		0x00000030
+#define TS_64		0x00000000
 
-#endif /* __ASM_CPU_SH4_DMA_H */
+#define CHCR_TS_MASK	0x30
+#define CHCR_TS_SHIFT	4
+
+#define DMAOR_COD	0x00000008
+
+#define DMAOR_INIT	( 0x8000 | DMAOR_DME )
 
+/*
+ * The SuperH DMAC supports a number of transmit sizes, we list them here,
+ * with their respective values as they appear in the CHCR registers.
+ *
+ * Defaults to a 64-bit transfer size.
+ */
+enum {
+	XMIT_SZ_64BIT,
+	XMIT_SZ_8BIT,
+	XMIT_SZ_16BIT,
+	XMIT_SZ_32BIT,
+	XMIT_SZ_256BIT,
+};
+
+/*
+ * The DMA count is defined as the number of bytes to transfer.
+ */
+static unsigned int ts_shift[] __attribute__ ((used)) = {
+	[XMIT_SZ_64BIT]		= 3,
+	[XMIT_SZ_8BIT]		= 0,
+	[XMIT_SZ_16BIT]		= 1,
+	[XMIT_SZ_32BIT]		= 2,
+	[XMIT_SZ_256BIT]	= 5,
+};
+
+#endif /* __ASM_CPU_SH4_DMA_H */
diff -purN linux-2.6.15-git12/include/asm-sh/cpu-sh4/freq.h linux-2.6.16-rc1/include/asm-sh/cpu-sh4/freq.h
--- linux-2.6.15-git12/include/asm-sh/cpu-sh4/freq.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/cpu-sh4/freq.h	2006-01-17 08:22:53.464320098 +0000
@@ -12,6 +12,8 @@
 
 #if defined(CONFIG_CPU_SUBTYPE_SH73180)
 #define FRQCR		        0xa4150000
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define	FRQCR			0xffc80000
 #else
 #define FRQCR			0xffc00000
 #endif
diff -purN linux-2.6.15-git12/include/asm-sh/dma-mapping.h linux-2.6.16-rc1/include/asm-sh/dma-mapping.h
--- linux-2.6.15-git12/include/asm-sh/dma-mapping.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/dma-mapping.h	2006-01-17 08:22:53.465319941 +0000
@@ -4,6 +4,7 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <asm/scatterlist.h>
+#include <asm/cacheflush.h>
 #include <asm/io.h>
 
 extern struct bus_type pci_bus_type;
@@ -141,24 +142,24 @@ static inline void dma_sync_sg(struct de
 	}
 }
 
-static inline void dma_sync_single_for_cpu(struct device *dev,
-					   dma_addr_t dma_handle, size_t size,
-					   enum dma_data_direction dir)
+static void dma_sync_single_for_cpu(struct device *dev,
+				    dma_addr_t dma_handle, size_t size,
+				    enum dma_data_direction dir)
 	__attribute__ ((alias("dma_sync_single")));
 
-static inline void dma_sync_single_for_device(struct device *dev,
-					   dma_addr_t dma_handle, size_t size,
-					   enum dma_data_direction dir)
+static void dma_sync_single_for_device(struct device *dev,
+				       dma_addr_t dma_handle, size_t size,
+				       enum dma_data_direction dir)
 	__attribute__ ((alias("dma_sync_single")));
 
-static inline void dma_sync_sg_for_cpu(struct device *dev,
-				       struct scatterlist *sg, int nelems,
-				       enum dma_data_direction dir)
+static void dma_sync_sg_for_cpu(struct device *dev,
+				struct scatterlist *sg, int nelems,
+				enum dma_data_direction dir)
 	__attribute__ ((alias("dma_sync_sg")));
 
-static inline void dma_sync_sg_for_device(struct device *dev,
-				       struct scatterlist *sg, int nelems,
-				       enum dma_data_direction dir)
+static void dma_sync_sg_for_device(struct device *dev,
+				   struct scatterlist *sg, int nelems,
+				   enum dma_data_direction dir)
 	__attribute__ ((alias("dma_sync_sg")));
 
 static inline int dma_get_cache_alignment(void)
diff -purN linux-2.6.15-git12/include/asm-sh/dma.h linux-2.6.16-rc1/include/asm-sh/dma.h
--- linux-2.6.15-git12/include/asm-sh/dma.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/dma.h	2006-01-17 08:22:53.467319626 +0000
@@ -15,6 +15,7 @@
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/sysdev.h>
+#include <linux/device.h>
 #include <asm/cpu/dma.h>
 #include <asm/semaphore.h>
 
@@ -54,8 +55,8 @@ enum {
  * DMA channel capabilities / flags
  */
 enum {
-	DMA_CONFIGURED			= 0x00,
 	DMA_TEI_CAPABLE			= 0x01,
+	DMA_CONFIGURED			= 0x02,
 };
 
 extern spinlock_t dma_spin_lock;
@@ -74,7 +75,8 @@ struct dma_ops {
 struct dma_channel {
 	char dev_id[16];
 
-	unsigned int chan;
+	unsigned int chan;		/* Physical channel number */
+	unsigned int vchan;		/* Virtual channel number */
 	unsigned int mode;
 	unsigned int count;
 
@@ -91,6 +93,8 @@ struct dma_channel {
 };
 
 struct dma_info {
+	struct platform_device *pdev;
+
 	const char *name;
 	unsigned int nr_channels;
 	unsigned long flags;
@@ -130,7 +134,11 @@ extern void unregister_dmac(struct dma_i
 
 #ifdef CONFIG_SYSFS
 /* arch/sh/drivers/dma/dma-sysfs.c */
-extern int dma_create_sysfs_files(struct dma_channel *);
+extern int dma_create_sysfs_files(struct dma_channel *, struct dma_info *);
+extern void dma_remove_sysfs_files(struct dma_channel *, struct dma_info *);
+#else
+#define dma_create_sysfs_file(channel, info)		do { } while (0)
+#define dma_remove_sysfs_file(channel, info)		do { } while (0)
 #endif
 
 #ifdef CONFIG_PCI
diff -purN linux-2.6.15-git12/include/asm-sh/freq.h linux-2.6.16-rc1/include/asm-sh/freq.h
--- linux-2.6.15-git12/include/asm-sh/freq.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/freq.h	2006-01-17 08:22:53.468319468 +0000
@@ -14,16 +14,5 @@
 
 #include <asm/cpu/freq.h>
 
-/* arch/sh/kernel/time.c */
-extern void get_current_frequency_divisors(unsigned int *ifc, unsigned int *pfc, unsigned int *bfc);
-
-extern unsigned int get_ifc_divisor(unsigned int value);
-extern unsigned int get_ifc_divisor(unsigned int value);
-extern unsigned int get_ifc_divisor(unsigned int value);
-
-extern unsigned int get_ifc_value(unsigned int divisor);
-extern unsigned int get_pfc_value(unsigned int divisor);
-extern unsigned int get_bfc_value(unsigned int divisor);
-
 #endif /* __KERNEL__ */
 #endif /* __ASM_SH_FREQ_H */
diff -purN linux-2.6.15-git12/include/asm-sh/io.h linux-2.6.16-rc1/include/asm-sh/io.h
--- linux-2.6.15-git12/include/asm-sh/io.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/io.h	2006-01-17 08:22:53.475318366 +0000
@@ -11,7 +11,7 @@
  * For read{b,w,l} and write{b,w,l} there are also __raw versions, which
  * do not have a memory barrier after them.
  *
- * In addition, we have 
+ * In addition, we have
  *   ctrl_in{b,w,l}/ctrl_out{b,w,l} for SuperH specific I/O.
  *   which are processor specific.
  */
@@ -23,19 +23,27 @@
  *  inb   by default expands to _inb, but the machine specific code may
  *        define it to __inb if it chooses.
  */
-
+#include <linux/config.h>
 #include <asm/cache.h>
 #include <asm/system.h>
 #include <asm/addrspace.h>
 #include <asm/machvec.h>
-#include <linux/config.h>
+#include <asm/pgtable.h>
+#include <asm-generic/iomap.h>
+
+#ifdef __KERNEL__
 
 /*
  * Depending on which platform we are running on, we need different
  * I/O functions.
  */
+#define __IO_PREFIX	generic
+#include <asm/io_generic.h>
+
+#define maybebadio(port) \
+  printk(KERN_ERR "bad PC-like io %s:%u for port 0x%lx at 0x%08x\n", \
+	 __FUNCTION__, __LINE__, (port), (u32)__builtin_return_address(0))
 
-#ifdef __KERNEL__
 /*
  * Since boards are able to define their own set of I/O routines through
  * their respective machine vector, we always wrap through the mv.
@@ -44,113 +52,120 @@
  * a given routine, it will be wrapped to generic code at run-time.
  */
 
-# define __inb(p)	sh_mv.mv_inb((p))
-# define __inw(p)	sh_mv.mv_inw((p))
-# define __inl(p)	sh_mv.mv_inl((p))
-# define __outb(x,p)	sh_mv.mv_outb((x),(p))
-# define __outw(x,p)	sh_mv.mv_outw((x),(p))
-# define __outl(x,p)	sh_mv.mv_outl((x),(p))
-
-# define __inb_p(p)	sh_mv.mv_inb_p((p))
-# define __inw_p(p)	sh_mv.mv_inw_p((p))
-# define __inl_p(p)	sh_mv.mv_inl_p((p))
-# define __outb_p(x,p)	sh_mv.mv_outb_p((x),(p))
-# define __outw_p(x,p)	sh_mv.mv_outw_p((x),(p))
-# define __outl_p(x,p)	sh_mv.mv_outl_p((x),(p))
-
-# define __insb(p,b,c)	sh_mv.mv_insb((p), (b), (c))
-# define __insw(p,b,c)	sh_mv.mv_insw((p), (b), (c))
-# define __insl(p,b,c)	sh_mv.mv_insl((p), (b), (c))
-# define __outsb(p,b,c)	sh_mv.mv_outsb((p), (b), (c))
-# define __outsw(p,b,c)	sh_mv.mv_outsw((p), (b), (c))
-# define __outsl(p,b,c)	sh_mv.mv_outsl((p), (b), (c))
-
-# define __readb(a)	sh_mv.mv_readb((a))
-# define __readw(a)	sh_mv.mv_readw((a))
-# define __readl(a)	sh_mv.mv_readl((a))
-# define __writeb(v,a)	sh_mv.mv_writeb((v),(a))
-# define __writew(v,a)	sh_mv.mv_writew((v),(a))
-# define __writel(v,a)	sh_mv.mv_writel((v),(a))
-
-# define __ioremap(a,s)	sh_mv.mv_ioremap((a), (s))
-# define __iounmap(a)	sh_mv.mv_iounmap((a))
-
-# define __isa_port2addr(a)	sh_mv.mv_isa_port2addr(a)
-
-# define inb		__inb
-# define inw		__inw
-# define inl		__inl
-# define outb		__outb
-# define outw		__outw
-# define outl		__outl
-
-# define inb_p		__inb_p
-# define inw_p		__inw_p
-# define inl_p		__inl_p
-# define outb_p		__outb_p
-# define outw_p		__outw_p
-# define outl_p		__outl_p
-
-# define insb		__insb
-# define insw		__insw
-# define insl		__insl
-# define outsb		__outsb
-# define outsw		__outsw
-# define outsl		__outsl
-
-# define __raw_readb	__readb
-# define __raw_readw	__readw
-# define __raw_readl	__readl
-# define __raw_writeb	__writeb
-# define __raw_writew	__writew
-# define __raw_writel	__writel
+#define __inb(p)	sh_mv.mv_inb((p))
+#define __inw(p)	sh_mv.mv_inw((p))
+#define __inl(p)	sh_mv.mv_inl((p))
+#define __outb(x,p)	sh_mv.mv_outb((x),(p))
+#define __outw(x,p)	sh_mv.mv_outw((x),(p))
+#define __outl(x,p)	sh_mv.mv_outl((x),(p))
+
+#define __inb_p(p)	sh_mv.mv_inb_p((p))
+#define __inw_p(p)	sh_mv.mv_inw_p((p))
+#define __inl_p(p)	sh_mv.mv_inl_p((p))
+#define __outb_p(x,p)	sh_mv.mv_outb_p((x),(p))
+#define __outw_p(x,p)	sh_mv.mv_outw_p((x),(p))
+#define __outl_p(x,p)	sh_mv.mv_outl_p((x),(p))
+
+#define __insb(p,b,c)	sh_mv.mv_insb((p), (b), (c))
+#define __insw(p,b,c)	sh_mv.mv_insw((p), (b), (c))
+#define __insl(p,b,c)	sh_mv.mv_insl((p), (b), (c))
+#define __outsb(p,b,c)	sh_mv.mv_outsb((p), (b), (c))
+#define __outsw(p,b,c)	sh_mv.mv_outsw((p), (b), (c))
+#define __outsl(p,b,c)	sh_mv.mv_outsl((p), (b), (c))
+
+#define __readb(a)	sh_mv.mv_readb((a))
+#define __readw(a)	sh_mv.mv_readw((a))
+#define __readl(a)	sh_mv.mv_readl((a))
+#define __writeb(v,a)	sh_mv.mv_writeb((v),(a))
+#define __writew(v,a)	sh_mv.mv_writew((v),(a))
+#define __writel(v,a)	sh_mv.mv_writel((v),(a))
+
+#define inb		__inb
+#define inw		__inw
+#define inl		__inl
+#define outb		__outb
+#define outw		__outw
+#define outl		__outl
+
+#define inb_p		__inb_p
+#define inw_p		__inw_p
+#define inl_p		__inl_p
+#define outb_p		__outb_p
+#define outw_p		__outw_p
+#define outl_p		__outl_p
+
+#define insb		__insb
+#define insw		__insw
+#define insl		__insl
+#define outsb		__outsb
+#define outsw		__outsw
+#define outsl		__outsl
+
+#define __raw_readb(a)		__readb((void __iomem *)(a))
+#define __raw_readw(a)		__readw((void __iomem *)(a))
+#define __raw_readl(a)		__readl((void __iomem *)(a))
+#define __raw_writeb(v, a)	__writeb(v, (void __iomem *)(a))
+#define __raw_writew(v, a)	__writew(v, (void __iomem *)(a))
+#define __raw_writel(v, a)	__writel(v, (void __iomem *)(a))
 
 /*
  * The platform header files may define some of these macros to use
  * the inlined versions where appropriate.  These macros may also be
  * redefined by userlevel programs.
  */
-#ifdef __raw_readb
-# define readb(a)	({ unsigned long r_ = __raw_readb((unsigned long)a); mb(); r_; })
+#ifdef __readb
+# define readb(a)	({ unsigned long r_ = __raw_readb(a); mb(); r_; })
 #endif
 #ifdef __raw_readw
-# define readw(a)	({ unsigned long r_ = __raw_readw((unsigned long)a); mb(); r_; })
+# define readw(a)	({ unsigned long r_ = __raw_readw(a); mb(); r_; })
 #endif
 #ifdef __raw_readl
-# define readl(a)	({ unsigned long r_ = __raw_readl((unsigned long)a); mb(); r_; })
+# define readl(a)	({ unsigned long r_ = __raw_readl(a); mb(); r_; })
 #endif
 
 #ifdef __raw_writeb
-# define writeb(v,a)	({ __raw_writeb((v),(unsigned long)(a)); mb(); })
+# define writeb(v,a)	({ __raw_writeb((v),(a)); mb(); })
 #endif
 #ifdef __raw_writew
-# define writew(v,a)	({ __raw_writew((v),(unsigned long)(a)); mb(); })
+# define writew(v,a)	({ __raw_writew((v),(a)); mb(); })
 #endif
 #ifdef __raw_writel
-# define writel(v,a)	({ __raw_writel((v),(unsigned long)(a)); mb(); })
+# define writel(v,a)	({ __raw_writel((v),(a)); mb(); })
 #endif
 
 #define readb_relaxed(a) readb(a)
 #define readw_relaxed(a) readw(a)
 #define readl_relaxed(a) readl(a)
 
-#define mmiowb()
+/* Simple MMIO */
+#define ioread8(a)		readb(a)
+#define ioread16(a)		readw(a)
+#define ioread16be(a)		be16_to_cpu(__raw_readw((a)))
+#define ioread32(a)		readl(a)
+#define ioread32be(a)		be32_to_cpu(__raw_readl((a)))
+
+#define iowrite8(v,a)		writeb((v),(a))
+#define iowrite16(v,a)		writew((v),(a))
+#define iowrite16be(v,a)	__raw_writew(cpu_to_be16((v)),(a))
+#define iowrite32(v,a)		writel((v),(a))
+#define iowrite32be(v,a)	__raw_writel(cpu_to_be32((v)),(a))
+
+#define ioread8_rep(a,d,c)	insb((a),(d),(c))
+#define ioread16_rep(a,d,c)	insw((a),(d),(c))
+#define ioread32_rep(a,d,c)	insl((a),(d),(c))
+
+#define iowrite8_rep(a,s,c)	outsb((a),(s),(c))
+#define iowrite16_rep(a,s,c)	outsw((a),(s),(c))
+#define iowrite32_rep(a,s,c)	outsl((a),(s),(c))
 
-/*
- * If the platform has PC-like I/O, this function converts the offset into
- * an address.
- */
-static __inline__ unsigned long isa_port2addr(unsigned long offset)
-{
-	return __isa_port2addr(offset);
-}
+#define mmiowb()	wmb()	/* synco on SH-4A, otherwise a nop */
 
 /*
  * This function provides a method for the generic case where a board-specific
- * isa_port2addr simply needs to return the port + some arbitrary port base.
+ * ioport_map simply needs to return the port + some arbitrary port base.
  *
  * We use this at board setup time to implicitly set the port base, and
- * as a result, we can use the generic isa_port2addr.
+ * as a result, we can use the generic ioport_map.
  */
 static inline void __set_io_port_base(unsigned long pbase)
 {
@@ -159,51 +174,52 @@ static inline void __set_io_port_base(un
 	generic_io_base = pbase;
 }
 
-#define isa_readb(a) readb(isa_port2addr(a))
-#define isa_readw(a) readw(isa_port2addr(a))
-#define isa_readl(a) readl(isa_port2addr(a))
-#define isa_writeb(b,a) writeb(b,isa_port2addr(a))
-#define isa_writew(w,a) writew(w,isa_port2addr(a))
-#define isa_writel(l,a) writel(l,isa_port2addr(a))
+#define isa_readb(a) readb(ioport_map(a, 1))
+#define isa_readw(a) readw(ioport_map(a, 2))
+#define isa_readl(a) readl(ioport_map(a, 4))
+#define isa_writeb(b,a) writeb(b,ioport_map(a, 1))
+#define isa_writew(w,a) writew(w,ioport_map(a, 2))
+#define isa_writel(l,a) writel(l,ioport_map(a, 4))
+
 #define isa_memset_io(a,b,c) \
-  memset((void *)(isa_port2addr((unsigned long)a)),(b),(c))
+  memset((void *)(ioport_map((unsigned long)(a), 1)),(b),(c))
 #define isa_memcpy_fromio(a,b,c) \
-  memcpy((a),(void *)(isa_port2addr((unsigned long)(b))),(c))
+  memcpy((a),(void *)(ioport_map((unsigned long)(b), 1)),(c))
 #define isa_memcpy_toio(a,b,c) \
-  memcpy((void *)(isa_port2addr((unsigned long)(a))),(b),(c))
+  memcpy((void *)(ioport_map((unsigned long)(a), 1)),(b),(c))
 
 /* We really want to try and get these to memcpy etc */
-extern void memcpy_fromio(void *, unsigned long, unsigned long);
-extern void memcpy_toio(unsigned long, const void *, unsigned long);
-extern void memset_io(unsigned long, int, unsigned long);
+extern void memcpy_fromio(void *, volatile void __iomem *, unsigned long);
+extern void memcpy_toio(volatile void __iomem *, const void *, unsigned long);
+extern void memset_io(volatile void __iomem *, int, unsigned long);
 
 /* SuperH on-chip I/O functions */
-static __inline__ unsigned char ctrl_inb(unsigned long addr)
+static inline unsigned char ctrl_inb(unsigned long addr)
 {
 	return *(volatile unsigned char*)addr;
 }
 
-static __inline__ unsigned short ctrl_inw(unsigned long addr)
+static inline unsigned short ctrl_inw(unsigned long addr)
 {
 	return *(volatile unsigned short*)addr;
 }
 
-static __inline__ unsigned int ctrl_inl(unsigned long addr)
+static inline unsigned int ctrl_inl(unsigned long addr)
 {
 	return *(volatile unsigned long*)addr;
 }
 
-static __inline__ void ctrl_outb(unsigned char b, unsigned long addr)
+static inline void ctrl_outb(unsigned char b, unsigned long addr)
 {
 	*(volatile unsigned char*)addr = b;
 }
 
-static __inline__ void ctrl_outw(unsigned short b, unsigned long addr)
+static inline void ctrl_outw(unsigned short b, unsigned long addr)
 {
 	*(volatile unsigned short*)addr = b;
 }
 
-static __inline__ void ctrl_outl(unsigned int b, unsigned long addr)
+static inline void ctrl_outl(unsigned int b, unsigned long addr)
 {
         *(volatile unsigned long*)addr = b;
 }
@@ -214,12 +230,12 @@ static __inline__ void ctrl_outl(unsigne
  * Change virtual addresses to physical addresses and vv.
  * These are trivial on the 1:1 Linux/SuperH mapping
  */
-static __inline__ unsigned long virt_to_phys(volatile void * address)
+static inline unsigned long virt_to_phys(volatile void *address)
 {
 	return PHYSADDR(address);
 }
 
-static __inline__ void * phys_to_virt(unsigned long address)
+static inline void *phys_to_virt(unsigned long address)
 {
 	return (void *)P1SEGADDR(address);
 }
@@ -234,27 +250,60 @@ static __inline__ void * phys_to_virt(un
  * differently. On the x86 architecture, we just read/write the
  * memory location directly.
  *
- * On SH, we have the whole physical address space mapped at all times
- * (as MIPS does), so "ioremap()" and "iounmap()" do not need to do
- * anything.  (This isn't true for all machines but we still handle
- * these cases with wired TLB entries anyway ...)
+ * On SH, we traditionally have the whole physical address space mapped
+ * at all times (as MIPS does), so "ioremap()" and "iounmap()" do not
+ * need to do anything but place the address in the proper segment. This
+ * is true for P1 and P2 addresses, as well as some P3 ones. However,
+ * most of the P3 addresses and newer cores using extended addressing
+ * need to map through page tables, so the ioremap() implementation
+ * becomes a bit more complicated. See arch/sh/mm/ioremap.c for
+ * additional notes on this.
  *
  * We cheat a bit and always return uncachable areas until we've fixed
- * the drivers to handle caching properly.  
+ * the drivers to handle caching properly.
  */
-static __inline__ void * ioremap(unsigned long offset, unsigned long size)
-{
-	return __ioremap(offset, size);
-}
-
-static __inline__ void iounmap(void *addr)
-{
-	return __iounmap(addr);
-}
-
-#define ioremap_nocache(off,size) ioremap(off,size)
+#ifdef CONFIG_MMU
+void __iomem *__ioremap(unsigned long offset, unsigned long size,
+			unsigned long flags);
+void __iounmap(void __iomem *addr);
+#else
+#define __ioremap(offset, size, flags)	((void __iomem *)(offset))
+#define __iounmap(addr)			do { } while (0)
+#endif /* CONFIG_MMU */
+
+static inline void __iomem *
+__ioremap_mode(unsigned long offset, unsigned long size, unsigned long flags)
+{
+	unsigned long last_addr = offset + size - 1;
+
+	/*
+	 * For P1 and P2 space this is trivial, as everything is already
+	 * mapped. Uncached access for P1 addresses are done through P2.
+	 * In the P3 case or for addresses outside of the 29-bit space,
+	 * mapping must be done by the PMB or by using page tables.
+	 */
+	if (likely(PXSEG(offset) < P3SEG && PXSEG(last_addr) < P3SEG)) {
+		if (unlikely(flags & _PAGE_CACHABLE))
+			return (void __iomem *)P1SEGADDR(offset);
+
+		return (void __iomem *)P2SEGADDR(offset);
+	}
+
+	return __ioremap(offset, size, flags);
+}
+
+#define ioremap(offset, size)				\
+	__ioremap_mode((offset), (size), 0)
+#define ioremap_nocache(offset, size)			\
+	__ioremap_mode((offset), (size), 0)
+#define ioremap_cache(offset, size)			\
+	__ioremap_mode((offset), (size), _PAGE_CACHABLE)
+#define p3_ioremap(offset, size, flags)			\
+	__ioremap((offset), (size), (flags))
+#define iounmap(addr)					\
+	__iounmap((addr))
 
-static __inline__ int check_signature(unsigned long io_addr,
+static inline int check_signature(char __iomem *io_addr,
 			const unsigned char *signature, int length)
 {
 	int retval = 0;
diff -purN linux-2.6.15-git12/include/asm-sh/io_generic.h linux-2.6.16-rc1/include/asm-sh/io_generic.h
--- linux-2.6.15-git12/include/asm-sh/io_generic.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/io_generic.h	2006-01-17 08:22:53.477318051 +0000
@@ -1,51 +1,49 @@
 /*
- * include/asm-sh/io_generic.h
- *
- * Copyright 2000 Stuart Menefy (stuart.menefy@st.com)
- *
- * May be copied or modified under the terms of the GNU General Public
- * License.  See linux/COPYING for more information.
- *
- * Generic IO functions
+ * Trivial I/O routine definitions, intentionally meant to be included
+ * multiple times. Ugly I/O routine concatenation helpers taken from
+ * alpha. Must be included _before_ io.h to avoid preprocessor-induced
+ * routine mismatch.
  */
+#define IO_CONCAT(a,b)	_IO_CONCAT(a,b)
+#define _IO_CONCAT(a,b)	a ## _ ## b
 
-#ifndef _ASM_SH_IO_GENERIC_H
-#define _ASM_SH_IO_GENERIC_H
+#ifndef __IO_PREFIX
+#error "Don't include this header without a valid system prefix"
+#endif
+
+u8 IO_CONCAT(__IO_PREFIX,inb)(unsigned long);
+u16 IO_CONCAT(__IO_PREFIX,inw)(unsigned long);
+u32 IO_CONCAT(__IO_PREFIX,inl)(unsigned long);
+
+void IO_CONCAT(__IO_PREFIX,outb)(u8, unsigned long);
+void IO_CONCAT(__IO_PREFIX,outw)(u16, unsigned long);
+void IO_CONCAT(__IO_PREFIX,outl)(u32, unsigned long);
+
+u8 IO_CONCAT(__IO_PREFIX,inb_p)(unsigned long);
+u16 IO_CONCAT(__IO_PREFIX,inw_p)(unsigned long);
+u32 IO_CONCAT(__IO_PREFIX,inl_p)(unsigned long);
+void IO_CONCAT(__IO_PREFIX,outb_p)(u8, unsigned long);
+void IO_CONCAT(__IO_PREFIX,outw_p)(u16, unsigned long);
+void IO_CONCAT(__IO_PREFIX,outl_p)(u32, unsigned long);
+
+void IO_CONCAT(__IO_PREFIX,insb)(unsigned long, void *dst, unsigned long count);
+void IO_CONCAT(__IO_PREFIX,insw)(unsigned long, void *dst, unsigned long count);
+void IO_CONCAT(__IO_PREFIX,insl)(unsigned long, void *dst, unsigned long count);
+void IO_CONCAT(__IO_PREFIX,outsb)(unsigned long, const void *src, unsigned long count);
+void IO_CONCAT(__IO_PREFIX,outsw)(unsigned long, const void *src, unsigned long count);
+void IO_CONCAT(__IO_PREFIX,outsl)(unsigned long, const void *src, unsigned long count);
+
+u8 IO_CONCAT(__IO_PREFIX,readb)(void __iomem *);
+u16 IO_CONCAT(__IO_PREFIX,readw)(void __iomem *);
+u32 IO_CONCAT(__IO_PREFIX,readl)(void __iomem *);
+void IO_CONCAT(__IO_PREFIX,writeb)(u8, void __iomem *);
+void IO_CONCAT(__IO_PREFIX,writew)(u16, void __iomem *);
+void IO_CONCAT(__IO_PREFIX,writel)(u32, void __iomem *);
 
-extern unsigned long generic_io_base;
+void *IO_CONCAT(__IO_PREFIX,ioremap)(unsigned long offset, unsigned long size);
+void IO_CONCAT(__IO_PREFIX,iounmap)(void *addr);
 
-extern unsigned char generic_inb(unsigned long port);
-extern unsigned short generic_inw(unsigned long port);
-extern unsigned int generic_inl(unsigned long port);
-
-extern void generic_outb(unsigned char value, unsigned long port);
-extern void generic_outw(unsigned short value, unsigned long port);
-extern void generic_outl(unsigned int value, unsigned long port);
-
-extern unsigned char generic_inb_p(unsigned long port);
-extern unsigned short generic_inw_p(unsigned long port);
-extern unsigned int generic_inl_p(unsigned long port);
-extern void generic_outb_p(unsigned char value, unsigned long port);
-extern void generic_outw_p(unsigned short value, unsigned long port);
-extern void generic_outl_p(unsigned int value, unsigned long port);
-
-extern void generic_insb(unsigned long port, void *addr, unsigned long count);
-extern void generic_insw(unsigned long port, void *addr, unsigned long count);
-extern void generic_insl(unsigned long port, void *addr, unsigned long count);
-extern void generic_outsb(unsigned long port, const void *addr, unsigned long count);
-extern void generic_outsw(unsigned long port, const void *addr, unsigned long count);
-extern void generic_outsl(unsigned long port, const void *addr, unsigned long count);
-
-extern unsigned char generic_readb(unsigned long addr);
-extern unsigned short generic_readw(unsigned long addr);
-extern unsigned int generic_readl(unsigned long addr);
-extern void generic_writeb(unsigned char b, unsigned long addr);
-extern void generic_writew(unsigned short b, unsigned long addr);
-extern void generic_writel(unsigned int b, unsigned long addr);
+void __iomem *IO_CONCAT(__IO_PREFIX,ioport_map)(unsigned long addr, unsigned int size);
+void IO_CONCAT(__IO_PREFIX,ioport_unmap)(void __iomem *addr);
 
-extern void *generic_ioremap(unsigned long offset, unsigned long size);
-extern void generic_iounmap(void *addr);
-
-extern unsigned long generic_isa_port2addr(unsigned long offset);
-
-#endif /* _ASM_SH_IO_GENERIC_H */
+#undef __IO_PREFIX
diff -purN linux-2.6.15-git12/include/asm-sh/irq-sh7780.h linux-2.6.16-rc1/include/asm-sh/irq-sh7780.h
--- linux-2.6.15-git12/include/asm-sh/irq-sh7780.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/irq-sh7780.h	2006-01-17 08:22:53.482317264 +0000
@@ -0,0 +1,349 @@
+#ifndef __ASM_SH_IRQ_SH7780_H
+#define __ASM_SH_IRQ_SH7780_H
+
+/*
+ * linux/include/asm-sh/irq-sh7780.h
+ *
+ * Copyright (C) 2004 Takashi SHUDO <shudo@hitachi-ul.co.jp>
+ */
+
+#ifdef CONFIG_IDE
+# ifndef IRQ_CFCARD
+#  define IRQ_CFCARD	14
+# endif
+# ifndef IRQ_PCMCIA
+#  define IRQ_PCMCIA	15
+# endif
+#endif
+
+#define INTC_BASE	0xffd00000
+#define INTC_ICR0	(INTC_BASE+0x0)
+#define INTC_ICR1	(INTC_BASE+0x1c)
+#define INTC_INTPRI	(INTC_BASE+0x10)
+#define INTC_INTREQ	(INTC_BASE+0x24)
+#define INTC_INTMSK0	(INTC_BASE+0x44)
+#define INTC_INTMSK1	(INTC_BASE+0x48)
+#define INTC_INTMSK2	(INTC_BASE+0x40080)
+#define INTC_INTMSKCLR0	(INTC_BASE+0x64)
+#define INTC_INTMSKCLR1	(INTC_BASE+0x68)
+#define INTC_INTMSKCLR2	(INTC_BASE+0x40084)
+#define INTC_NMIFCR	(INTC_BASE+0xc0)
+#define INTC_USERIMASK	(INTC_BASE+0x30000)
+
+#define	INTC_INT2PRI0	(INTC_BASE+0x40000)
+#define	INTC_INT2PRI1	(INTC_BASE+0x40004)
+#define	INTC_INT2PRI2	(INTC_BASE+0x40008)
+#define	INTC_INT2PRI3	(INTC_BASE+0x4000c)
+#define	INTC_INT2PRI4	(INTC_BASE+0x40010)
+#define	INTC_INT2PRI5	(INTC_BASE+0x40014)
+#define	INTC_INT2PRI6	(INTC_BASE+0x40018)
+#define	INTC_INT2PRI7	(INTC_BASE+0x4001c)
+#define	INTC_INT2A0	(INTC_BASE+0x40030)
+#define	INTC_INT2A1	(INTC_BASE+0x40034)
+#define	INTC_INT2MSKR	(INTC_BASE+0x40038)
+#define	INTC_INT2MSKCR	(INTC_BASE+0x4003c)
+#define	INTC_INT2B0	(INTC_BASE+0x40040)
+#define	INTC_INT2B1	(INTC_BASE+0x40044)
+#define	INTC_INT2B2	(INTC_BASE+0x40048)
+#define	INTC_INT2B3	(INTC_BASE+0x4004c)
+#define	INTC_INT2B4	(INTC_BASE+0x40050)
+#define	INTC_INT2B5	(INTC_BASE+0x40054)
+#define	INTC_INT2B6	(INTC_BASE+0x40058)
+#define	INTC_INT2B7	(INTC_BASE+0x4005c)
+#define	INTC_INT2GPIC	(INTC_BASE+0x40090)
+/*
+  NOTE:
+  *_IRQ = (INTEVT2 - 0x200)/0x20
+*/
+/* IRQ 0-7 line external int*/
+#define IRQ0_IRQ	2
+#define IRQ0_IPR_ADDR	INTC_INTPRI
+#define IRQ0_IPR_POS	7
+#define IRQ0_PRIORITY	2
+
+#define IRQ1_IRQ	4
+#define IRQ1_IPR_ADDR	INTC_INTPRI
+#define IRQ1_IPR_POS	6
+#define IRQ1_PRIORITY	2
+
+#define IRQ2_IRQ	6
+#define IRQ2_IPR_ADDR	INTC_INTPRI
+#define IRQ2_IPR_POS	5
+#define IRQ2_PRIORITY	2
+
+#define IRQ3_IRQ	8
+#define IRQ3_IPR_ADDR	INTC_INTPRI
+#define IRQ3_IPR_POS	4
+#define IRQ3_PRIORITY	2
+
+#define IRQ4_IRQ	10
+#define IRQ4_IPR_ADDR	INTC_INTPRI
+#define IRQ4_IPR_POS	3
+#define IRQ4_PRIORITY	2
+
+#define IRQ5_IRQ	12
+#define IRQ5_IPR_ADDR	INTC_INTPRI
+#define IRQ5_IPR_POS	2
+#define IRQ5_PRIORITY	2
+
+#define IRQ6_IRQ	14
+#define IRQ6_IPR_ADDR	INTC_INTPRI
+#define IRQ6_IPR_POS	1
+#define IRQ6_PRIORITY	2
+
+#define IRQ7_IRQ	0
+#define IRQ7_IPR_ADDR	INTC_INTPRI
+#define IRQ7_IPR_POS	0
+#define IRQ7_PRIORITY	2
+
+/* TMU */
+/* ch0 */
+#define TMU_IRQ		28
+#define	TMU_IPR_ADDR	INTC_INT2PRI0
+#define	TMU_IPR_POS	3
+#define TMU_PRIORITY	2
+
+#define TIMER_IRQ	28
+#define	TIMER_IPR_ADDR	INTC_INT2PRI0
+#define	TIMER_IPR_POS	3
+#define TIMER_PRIORITY	2
+
+/* ch 1*/
+#define TMU_CH1_IRQ		29
+#define	TMU_CH1_IPR_ADDR	INTC_INT2PRI0
+#define	TMU_CH1_IPR_POS		2
+#define TMU_CH1_PRIORITY	2
+
+#define TIMER1_IRQ	29
+#define	TIMER1_IPR_ADDR	INTC_INT2PRI0
+#define	TIMER1_IPR_POS	2
+#define TIMER1_PRIORITY	2
+
+/* ch 2*/
+#define TMU_CH2_IRQ		30
+#define	TMU_CH2_IPR_ADDR	INTC_INT2PRI0
+#define	TMU_CH2_IPR_POS		1
+#define TMU_CH2_PRIORITY	2
+/* ch 2 Input capture */
+#define TMU_CH2IC_IRQ		31
+#define	TMU_CH2IC_IPR_ADDR	INTC_INT2PRI0
+#define	TMU_CH2IC_IPR_POS	0
+#define TMU_CH2IC_PRIORITY	2
+/* ch 3 */
+#define TMU_CH3_IRQ		96
+#define	TMU_CH3_IPR_ADDR	INTC_INT2PRI1
+#define	TMU_CH3_IPR_POS		3
+#define TMU_CH3_PRIORITY	2
+/* ch 4 */
+#define TMU_CH4_IRQ		97
+#define	TMU_CH4_IPR_ADDR	INTC_INT2PRI1
+#define	TMU_CH4_IPR_POS		2
+#define TMU_CH4_PRIORITY	2
+/* ch 5*/
+#define TMU_CH5_IRQ		98
+#define	TMU_CH5_IPR_ADDR	INTC_INT2PRI1
+#define	TMU_CH5_IPR_POS		1
+#define TMU_CH5_PRIORITY	2
+
+#define	RTC_IRQ		22
+#define	RTC_IPR_ADDR	INTC_INT2PRI1
+#define	RTC_IPR_POS	0
+#define	RTC_PRIORITY	TIMER_PRIORITY
+
+/* SCIF0 */
+#define SCIF0_ERI_IRQ	40
+#define SCIF0_RXI_IRQ	41
+#define SCIF0_BRI_IRQ	42
+#define SCIF0_TXI_IRQ	43
+#define	SCIF0_IPR_ADDR	INTC_INT2PRI2
+#define	SCIF0_IPR_POS	3
+#define SCIF0_PRIORITY	3
+
+/* SCIF1 */
+#define SCIF1_ERI_IRQ	76
+#define SCIF1_RXI_IRQ	77
+#define SCIF1_BRI_IRQ	78
+#define SCIF1_TXI_IRQ	79
+#define	SCIF1_IPR_ADDR	INTC_INT2PRI2
+#define	SCIF1_IPR_POS	2
+#define SCIF1_PRIORITY	3
+
+#define	WDT_IRQ		27
+#define	WDT_IPR_ADDR	INTC_INT2PRI2
+#define	WDT_IPR_POS	1
+#define	WDT_PRIORITY	2
+
+/* DMAC(0) */
+#define	DMINT0_IRQ	34
+#define	DMINT1_IRQ	35
+#define	DMINT2_IRQ	36
+#define	DMINT3_IRQ	37
+#define	DMINT4_IRQ	44
+#define	DMINT5_IRQ	45
+#define	DMINT6_IRQ	46
+#define	DMINT7_IRQ	47
+#define	DMAE_IRQ	38
+#define	DMA0_IPR_ADDR	INTC_INT2PRI3
+#define	DMA0_IPR_POS	2
+#define	DMA0_PRIORITY	7
+
+/* DMAC(1) */
+#define	DMINT8_IRQ	92
+#define	DMINT9_IRQ	93
+#define	DMINT10_IRQ	94
+#define	DMINT11_IRQ	95
+#define	DMA1_IPR_ADDR	INTC_INT2PRI3
+#define	DMA1_IPR_POS	1
+#define	DMA1_PRIORITY	7
+
+#define	DMTE0_IRQ	DMINT0_IRQ
+#define	DMTE4_IRQ	DMINT4_IRQ
+#define	DMA_IPR_ADDR	DMA0_IPR_ADDR
+#define	DMA_IPR_POS	DMA0_IPR_POS
+#define	DMA_PRIORITY	DMA0_PRIORITY
+
+/* CMT */
+#define	CMT_IRQ		56
+#define	CMT_IPR_ADDR	INTC_INT2PRI4
+#define	CMT_IPR_POS	3
+#define	CMT_PRIORITY	0
+
+/* HAC */
+#define	HAC_IRQ		60
+#define	HAC_IPR_ADDR	INTC_INT2PRI4
+#define	HAC_IPR_POS	2
+#define	CMT_PRIORITY	0
+
+/* PCIC(0) */
+#define	PCIC0_IRQ	64
+#define	PCIC0_IPR_ADDR	INTC_INT2PRI4
+#define	PCIC0_IPR_POS	1
+#define	PCIC0_PRIORITY	2
+
+/* PCIC(1) */
+#define	PCIC1_IRQ	65
+#define	PCIC1_IPR_ADDR	INTC_INT2PRI4
+#define	PCIC1_IPR_POS	0
+#define	PCIC1_PRIORITY	2
+
+/* PCIC(2) */
+#define	PCIC2_IRQ	66
+#define	PCIC2_IPR_ADDR	INTC_INT2PRI5
+#define	PCIC2_IPR_POS	3
+#define	PCIC2_PRIORITY	2
+
+/* PCIC(3) */
+#define	PCIC3_IRQ	67
+#define	PCIC3_IPR_ADDR	INTC_INT2PRI5
+#define	PCIC3_IPR_POS	2
+#define	PCIC3_PRIORITY	2
+
+/* PCIC(4) */
+#define	PCIC4_IRQ	68
+#define	PCIC4_IPR_ADDR	INTC_INT2PRI5
+#define	PCIC4_IPR_POS	1
+#define	PCIC4_PRIORITY	2
+
+/* PCIC(5) */
+#define	PCICERR_IRQ	69
+#define	PCICPWD3_IRQ	70
+#define	PCICPWD2_IRQ	71
+#define	PCICPWD1_IRQ	72
+#define	PCICPWD0_IRQ	73
+#define	PCIC5_IPR_ADDR	INTC_INT2PRI5
+#define	PCIC5_IPR_POS	0
+#define	PCIC5_PRIORITY	2
+
+/* SIOF */
+#define	SIOF_IRQ	80
+#define	SIOF_IPR_ADDR	INTC_INT2PRI6
+#define	SIOF_IPR_POS	3
+#define	SIOF_PRIORITY	3
+
+/* HSPI */
+#define	HSPI_IRQ	84
+#define	HSPI_IPR_ADDR	INTC_INT2PRI6
+#define	HSPI_IPR_POS	2
+#define	HSPI_PRIORITY	3
+
+/* MMCIF */
+#define	MMCIF_FSTAT_IRQ	88
+#define	MMCIF_TRAN_IRQ	89
+#define	MMCIF_ERR_IRQ	90
+#define	MMCIF_FRDY_IRQ	91
+#define	MMCIF_IPR_ADDR	INTC_INT2PRI6
+#define	MMCIF_IPR_POS	1
+#define	HSPI_PRIORITY	3
+
+/* SSI */
+#define	SSI_IRQ		100
+#define	SSI_IPR_ADDR	INTC_INT2PRI6
+#define	SSI_IPR_POS	0
+#define	SSI_PRIORITY	3
+
+/* FLCTL */
+#define	FLCTL_FLSTE_IRQ		104
+#define	FLCTL_FLTEND_IRQ	105
+#define	FLCTL_FLTRQ0_IRQ	106
+#define	FLCTL_FLTRQ1_IRQ	107
+#define	FLCTL_IPR_ADDR		INTC_INT2PRI7
+#define	FLCTL_IPR_POS		3
+#define	FLCTL_PRIORITY		3
+
+/* GPIO */
+#define	GPIO0_IRQ	108
+#define	GPIO1_IRQ	109
+#define	GPIO2_IRQ	110
+#define	GPIO3_IRQ	111
+#define	GPIO_IPR_ADDR	INTC_INT2PRI7
+#define	GPIO_IPR_POS	2
+#define	GPIO_PRIORITY	3
+
+/* ONCHIP_NR_IRQS */
+#define NR_IRQS 150	/* 111 + 16 */
+
+/* In a generic kernel, NR_IRQS is an upper bound, and we should use
+ * ACTUAL_NR_IRQS (which uses the machine vector) to get the correct value.
+ */
+#define ACTUAL_NR_IRQS NR_IRQS
+
+extern void disable_irq(unsigned int);
+extern void disable_irq_nosync(unsigned int);
+extern void enable_irq(unsigned int);
+
+/*
+ * Simple Mask Register Support
+ */
+extern void make_maskreg_irq(unsigned int irq);
+extern unsigned short *irq_mask_register;
+
+/*
+ * Function for "on chip support modules".
+ */
+extern void make_imask_irq(unsigned int irq);
+
+#define	INTC_TMU0_MSK	0
+#define	INTC_TMU3_MSK	1
+#define	INTC_RTC_MSK	2
+#define	INTC_SCIF0_MSK	3
+#define	INTC_SCIF1_MSK	4
+#define	INTC_WDT_MSK	5
+#define	INTC_HUID_MSK	7
+#define	INTC_DMAC0_MSK	8
+#define	INTC_DMAC1_MSK	9
+#define	INTC_CMT_MSK	12
+#define	INTC_HAC_MSK	13
+#define	INTC_PCIC0_MSK	14
+#define	INTC_PCIC1_MSK	15
+#define	INTC_PCIC2_MSK	16
+#define	INTC_PCIC3_MSK	17
+#define	INTC_PCIC4_MSK	18
+#define	INTC_PCIC5_MSK	19
+#define	INTC_SIOF_MSK	20
+#define	INTC_HSPI_MSK	21
+#define	INTC_MMCIF_MSK	22
+#define	INTC_SSI_MSK	23
+#define	INTC_FLCTL_MSK	24
+#define	INTC_GPIO_MSK	25
+
+#endif /* __ASM_SH_IRQ_SH7780_H */
diff -purN linux-2.6.15-git12/include/asm-sh/irq.h linux-2.6.16-rc1/include/asm-sh/irq.h
--- linux-2.6.15-git12/include/asm-sh/irq.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/irq.h	2006-01-17 08:22:53.486316635 +0000
@@ -15,13 +15,20 @@
 #include <asm/machvec.h>
 #include <asm/ptrace.h>		/* for pt_regs */
 
-#if defined(CONFIG_SH_HP600) || \
+#if defined(CONFIG_SH_HP6XX) || \
     defined(CONFIG_SH_RTS7751R2D) || \
     defined(CONFIG_SH_HS7751RVOIP) || \
-    defined(CONFIG_SH_SH03)
+    defined(CONFIG_SH_HS7751RVOIP) || \
+    defined(CONFIG_SH_SH03) || \
+    defined(CONFIG_SH_R7780RP) || \
+    defined(CONFIG_SH_LANDISK)
 #include <asm/mach/ide.h>
 #endif
 
+#ifndef CONFIG_CPU_SUBTYPE_SH7780
+
+#define INTC_DMAC0_MSK	0
+
 #if defined(CONFIG_CPU_SH3)
 #define INTC_IPRA	0xfffffee2UL
 #define INTC_IPRB	0xfffffee4UL
@@ -235,8 +242,9 @@
 #define SCIF1_IPR_ADDR	INTC_IPRB
 #define SCIF1_IPR_POS	1
 #define SCIF1_PRIORITY	3
-#endif
-#endif
+#endif /* ST40STB1 */
+
+#endif /* 775x / SH4-202 / ST40STB1 */
 
 /* NR_IRQS is made from three components:
  *   1. ONCHIP_NR_IRQS - number of IRLS + on-chip peripherial modules
@@ -245,37 +253,35 @@
  */
 
 /* 1. ONCHIP_NR_IRQS */
-#ifdef CONFIG_SH_GENERIC
+#if defined(CONFIG_CPU_SUBTYPE_SH7604)
+# define ONCHIP_NR_IRQS 24	// Actually 21
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707)
+# define ONCHIP_NR_IRQS 64
+# define PINT_NR_IRQS   16
+#elif defined(CONFIG_CPU_SUBTYPE_SH7708)
+# define ONCHIP_NR_IRQS 32
+#elif defined(CONFIG_CPU_SUBTYPE_SH7709) || \
+      defined(CONFIG_CPU_SUBTYPE_SH7705)
+# define ONCHIP_NR_IRQS 64	// Actually 61
+# define PINT_NR_IRQS   16
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750)
+# define ONCHIP_NR_IRQS 48	// Actually 44
+#elif defined(CONFIG_CPU_SUBTYPE_SH7751)
+# define ONCHIP_NR_IRQS 72
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
+# define ONCHIP_NR_IRQS 112	/* XXX */
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_202)
+# define ONCHIP_NR_IRQS 72
+#elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+# define ONCHIP_NR_IRQS 144
+#elif defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define ONCHIP_NR_IRQS 109
+#elif defined(CONFIG_SH_UNKNOWN)	/* Most be last */
 # define ONCHIP_NR_IRQS 144
-#else
-# if defined(CONFIG_CPU_SUBTYPE_SH7604)
-#  define ONCHIP_NR_IRQS 24	// Actually 21
-# elif defined(CONFIG_CPU_SUBTYPE_SH7707)
-#  define ONCHIP_NR_IRQS 64
-#  define PINT_NR_IRQS   16
-# elif defined(CONFIG_CPU_SUBTYPE_SH7708)
-#  define ONCHIP_NR_IRQS 32
-# elif defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-       defined(CONFIG_CPU_SUBTYPE_SH7705)
-#  define ONCHIP_NR_IRQS 64	// Actually 61
-#  define PINT_NR_IRQS   16
-# elif defined(CONFIG_CPU_SUBTYPE_SH7750)
-#  define ONCHIP_NR_IRQS 48	// Actually 44
-# elif defined(CONFIG_CPU_SUBTYPE_SH7751)
-#  define ONCHIP_NR_IRQS 72
-# elif defined(CONFIG_CPU_SUBTYPE_SH7760)
-#  define ONCHIP_NR_IRQS 110
-# elif defined(CONFIG_CPU_SUBTYPE_SH4_202)
-#  define ONCHIP_NR_IRQS 72
-# elif defined(CONFIG_CPU_SUBTYPE_ST40STB1)
-#  define ONCHIP_NR_IRQS 144
-# elif defined(CONFIG_CPU_SUBTYPE_SH7300)
-#  define ONCHIP_NR_IRQS 109
-# endif
 #endif
 
 /* 2. PINT_NR_IRQS */
-#ifdef CONFIG_SH_GENERIC
+#ifdef CONFIG_SH_UNKNOWN
 # define PINT_NR_IRQS 16
 #else
 # ifndef PINT_NR_IRQS
@@ -288,22 +294,22 @@
 #endif
 
 /* 3. OFFCHIP_NR_IRQS */
-#ifdef CONFIG_SH_GENERIC
+#if defined(CONFIG_HD64461)
+# define OFFCHIP_NR_IRQS 18
+#elif defined (CONFIG_SH_BIGSUR) /* must be before CONFIG_HD64465 */
+# define OFFCHIP_NR_IRQS 48
+#elif defined(CONFIG_HD64465)
 # define OFFCHIP_NR_IRQS 16
+#elif defined (CONFIG_SH_EC3104)
+# define OFFCHIP_NR_IRQS 16
+#elif defined (CONFIG_SH_DREAMCAST)
+# define OFFCHIP_NR_IRQS 96
+#elif defined (CONFIG_SH_TITAN)
+# define OFFCHIP_NR_IRQS 4
+#elif defined(CONFIG_SH_UNKNOWN)
+# define OFFCHIP_NR_IRQS 16	/* Must also be last */
 #else
-# if defined(CONFIG_HD64461)
-#  define OFFCHIP_NR_IRQS 18
-# elif defined (CONFIG_SH_BIGSUR) /* must be before CONFIG_HD64465 */
-#  define OFFCHIP_NR_IRQS 48
-# elif defined(CONFIG_HD64465)
-#  define OFFCHIP_NR_IRQS 16
-# elif defined (CONFIG_SH_EC3104)
-#  define OFFCHIP_NR_IRQS 16
-# elif defined (CONFIG_SH_DREAMCAST)
-#  define OFFCHIP_NR_IRQS 96
-# else
-#  define OFFCHIP_NR_IRQS 0
-# endif
+# define OFFCHIP_NR_IRQS 0
 #endif
 
 #if OFFCHIP_NR_IRQS > 0
@@ -313,16 +319,6 @@
 /* NR_IRQS. 1+2+3 */
 #define NR_IRQS (ONCHIP_NR_IRQS + PINT_NR_IRQS + OFFCHIP_NR_IRQS)
 
-/* In a generic kernel, NR_IRQS is an upper bound, and we should use
- * ACTUAL_NR_IRQS (which uses the machine vector) to get the correct value.
- */
-#ifdef CONFIG_SH_GENERIC
-# define ACTUAL_NR_IRQS (sh_mv.mv_nr_irqs)
-#else
-# define ACTUAL_NR_IRQS NR_IRQS
-#endif
-
-
 extern void disable_irq(unsigned int);
 extern void disable_irq_nosync(unsigned int);
 extern void enable_irq(unsigned int);
@@ -542,9 +538,6 @@ extern int ipr_irq_demux(int irq);
 
 extern int ipr_irq_demux(int irq);
 #define __irq_demux(irq) ipr_irq_demux(irq)
-
-#else
-#define __irq_demux(irq) irq
 #endif /* CONFIG_CPU_SUBTYPE_SH7707 || CONFIG_CPU_SUBTYPE_SH7709 */
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751) || \
@@ -557,18 +550,35 @@ extern int ipr_irq_demux(int irq);
 #define INTC_ICR_IRLM	(1<<7)
 #endif
 
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+#else
+#include <asm/irq-sh7780.h>
+#endif
 
+/* SH with INTC2-style interrupts */
+#ifdef CONFIG_CPU_HAS_INTC2_IRQ
+#if defined(CONFIG_CPU_SUBTYPE_ST40STB1)
+#define INTC2_BASE	0xfe080000
 #define INTC2_FIRST_IRQ 64
-#define NR_INTC2_IRQS 25
-
+#define INTC2_INTREQ_OFFSET	0x20
+#define INTC2_INTMSK_OFFSET	0x40
+#define INTC2_INTMSKCLR_OFFSET	0x60
+#define NR_INTC2_IRQS	25
+#elif defined(CONFIG_CPU_SUBTYPE_SH7760)
 #define INTC2_BASE	0xfe080000
-#define INTC2_INTC2MODE	(INTC2_BASE+0x80)
-
-#define INTC2_INTPRI_OFFSET	0x00
+#define INTC2_FIRST_IRQ 48	/* INTEVT 0x800 */
 #define INTC2_INTREQ_OFFSET	0x20
 #define INTC2_INTMSK_OFFSET	0x40
 #define INTC2_INTMSKCLR_OFFSET	0x60
+#define NR_INTC2_IRQS	64
+#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
+#define INTC2_BASE	0xffd40000
+#define INTC2_FIRST_IRQ	22
+#define INTC2_INTMSK_OFFSET	(0x38)
+#define INTC2_INTMSKCLR_OFFSET	(0x3c)
+#define NR_INTC2_IRQS	60
+#endif
+
+#define INTC2_INTPRI_OFFSET	0x00
 
 void make_intc2_irq(unsigned int irq,
 		    unsigned int ipr_offset, unsigned int ipr_shift,
@@ -577,13 +587,16 @@ void make_intc2_irq(unsigned int irq,
 void init_IRQ_intc2(void);
 void intc2_add_clear_irq(int irq, int (*fn)(int));
 
-#endif	/* CONFIG_CPU_SUBTYPE_ST40STB1 */
+#endif
 
 static inline int generic_irq_demux(int irq)
 {
 	return irq;
 }
 
+#ifndef __irq_demux
+#define __irq_demux(irq)	(irq)
+#endif
 #define irq_canonicalize(irq)	(irq)
 #define irq_demux(irq)		__irq_demux(sh_mv.mv_irq_demux(irq))
 
diff -purN linux-2.6.15-git12/include/asm-sh/kexec.h linux-2.6.16-rc1/include/asm-sh/kexec.h
--- linux-2.6.15-git12/include/asm-sh/kexec.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/kexec.h	2006-01-17 08:22:53.487316477 +0000
@@ -0,0 +1,33 @@
+#ifndef _SH_KEXEC_H
+#define _SH_KEXEC_H
+
+/*
+ * KEXEC_SOURCE_MEMORY_LIMIT maximum page get_free_page can return.
+ * I.e. Maximum page that is mapped directly into kernel memory,
+ * and kmap is not required.
+ *
+ * Someone correct me if FIXADDR_START - PAGEOFFSET is not the correct
+ * calculation for the amount of memory directly mappable into the
+ * kernel memory space.
+ */
+
+/* Maximum physical address we can use pages from */
+#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
+/* Maximum address we can reach in physical address mode */
+#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)
+/* Maximum address we can use for the control code buffer */
+#define KEXEC_CONTROL_MEMORY_LIMIT TASK_SIZE
+
+#define KEXEC_CONTROL_CODE_SIZE	4096
+
+/* The native architecture */
+#define KEXEC_ARCH KEXEC_ARCH_SH
+
+#ifndef __ASSEMBLY__
+
+extern void machine_shutdown(void);
+extern void *crash_notes;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _SH_KEXEC_H */
diff -purN linux-2.6.15-git12/include/asm-sh/machvec.h linux-2.6.16-rc1/include/asm-sh/machvec.h
--- linux-2.6.15-git12/include/asm-sh/machvec.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/machvec.h	2006-01-17 08:22:53.489316162 +0000
@@ -18,44 +18,37 @@
 #include <asm/machvec_init.h>
 
 struct device;
-struct timeval;
 
-struct sh_machine_vector
-{
+struct sh_machine_vector {
 	int mv_nr_irqs;
 
-	unsigned char (*mv_inb)(unsigned long);
-	unsigned short (*mv_inw)(unsigned long);
-	unsigned int (*mv_inl)(unsigned long);
-	void (*mv_outb)(unsigned char, unsigned long);
-	void (*mv_outw)(unsigned short, unsigned long);
-	void (*mv_outl)(unsigned int, unsigned long);
-
-	unsigned char (*mv_inb_p)(unsigned long);
-	unsigned short (*mv_inw_p)(unsigned long);
-	unsigned int (*mv_inl_p)(unsigned long);
-	void (*mv_outb_p)(unsigned char, unsigned long);
-	void (*mv_outw_p)(unsigned short, unsigned long);
-	void (*mv_outl_p)(unsigned int, unsigned long);
-
-	void (*mv_insb)(unsigned long port, void *addr, unsigned long count);
-	void (*mv_insw)(unsigned long port, void *addr, unsigned long count);
-	void (*mv_insl)(unsigned long port, void *addr, unsigned long count);
-	void (*mv_outsb)(unsigned long port, const void *addr, unsigned long count);
-	void (*mv_outsw)(unsigned long port, const void *addr, unsigned long count);
-	void (*mv_outsl)(unsigned long port, const void *addr, unsigned long count);
-
-	unsigned char (*mv_readb)(unsigned long);
-	unsigned short (*mv_readw)(unsigned long);
-	unsigned int (*mv_readl)(unsigned long);
-	void (*mv_writeb)(unsigned char, unsigned long);
-	void (*mv_writew)(unsigned short, unsigned long);
-	void (*mv_writel)(unsigned int, unsigned long);
-
-	void* (*mv_ioremap)(unsigned long offset, unsigned long size);
-	void (*mv_iounmap)(void *addr);
-
-	unsigned long (*mv_isa_port2addr)(unsigned long offset);
+	u8 (*mv_inb)(unsigned long);
+	u16 (*mv_inw)(unsigned long);
+	u32 (*mv_inl)(unsigned long);
+	void (*mv_outb)(u8, unsigned long);
+	void (*mv_outw)(u16, unsigned long);
+	void (*mv_outl)(u32, unsigned long);
+
+	u8 (*mv_inb_p)(unsigned long);
+	u16 (*mv_inw_p)(unsigned long);
+	u32 (*mv_inl_p)(unsigned long);
+	void (*mv_outb_p)(u8, unsigned long);
+	void (*mv_outw_p)(u16, unsigned long);
+	void (*mv_outl_p)(u32, unsigned long);
+
+	void (*mv_insb)(unsigned long, void *dst, unsigned long count);
+	void (*mv_insw)(unsigned long, void *dst, unsigned long count);
+	void (*mv_insl)(unsigned long, void *dst, unsigned long count);
+	void (*mv_outsb)(unsigned long, const void *src, unsigned long count);
+	void (*mv_outsw)(unsigned long, const void *src, unsigned long count);
+	void (*mv_outsl)(unsigned long, const void *src, unsigned long count);
+
+	u8 (*mv_readb)(void __iomem *);
+	u16 (*mv_readw)(void __iomem *);
+	u32 (*mv_readl)(void __iomem *);
+	void (*mv_writeb)(u8, void __iomem *);
+	void (*mv_writew)(u16, void __iomem *);
+	void (*mv_writel)(u32, void __iomem *);
 
 	int (*mv_irq_demux)(int irq);
 
@@ -66,6 +59,9 @@ struct sh_machine_vector
 
 	void *(*mv_consistent_alloc)(struct device *, size_t, dma_addr_t *, gfp_t);
 	int (*mv_consistent_free)(struct device *, size_t, void *, dma_addr_t);
+
+	void __iomem *(*mv_ioport_map)(unsigned long port, unsigned int size);
+	void (*mv_ioport_unmap)(void __iomem *);
 };
 
 extern struct sh_machine_vector sh_mv;
diff -purN linux-2.6.15-git12/include/asm-sh/timer.h linux-2.6.16-rc1/include/asm-sh/timer.h
--- linux-2.6.15-git12/include/asm-sh/timer.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-sh/timer.h	2006-01-17 08:22:53.495315218 +0000
@@ -0,0 +1,42 @@
+#ifndef __ASM_SH_TIMER_H
+#define __ASM_SH_TIMER_H
+
+#include <linux/sysdev.h>
+#include <asm/cpu/timer.h>
+
+struct sys_timer_ops {
+	int (*init)(void);
+	unsigned long (*get_offset)(void);
+	unsigned long (*get_frequency)(void);
+};
+
+struct sys_timer {
+	const char		*name;
+
+	struct sys_device	dev;
+	struct sys_timer_ops	*ops;
+};
+
+#define TICK_SIZE (tick_nsec / 1000)
+
+extern struct sys_timer tmu_timer;
+extern struct sys_timer *sys_timer;
+
+static inline unsigned long get_timer_offset(void)
+{
+	return sys_timer->ops->get_offset();
+}
+
+static inline unsigned long get_timer_frequency(void)
+{
+	return sys_timer->ops->get_frequency();
+}
+
+/* arch/sh/kernel/timers/timer.c */
+struct sys_timer *get_sys_timer(void);
+
+/* arch/sh/kernel/time.c */
+void handle_timer_tick(struct pt_regs *);
+
+#endif /* __ASM_SH_TIMER_H */
+
diff -purN linux-2.6.15-git12/include/asm-x86_64/ia32.h linux-2.6.16-rc1/include/asm-x86_64/ia32.h
--- linux-2.6.15-git12/include/asm-x86_64/ia32.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-x86_64/ia32.h	2006-01-17 08:22:53.579301994 +0000
@@ -169,6 +169,8 @@ int ia32_child_tls(struct task_struct *p
 struct linux_binprm;
 extern int ia32_setup_arg_pages(struct linux_binprm *bprm,
 				unsigned long stack_top, int exec_stack);
+struct mm_struct;
+extern void ia32_pick_mmap_layout(struct mm_struct *mm);
 
 #endif
 
diff -purN linux-2.6.15-git12/include/asm-x86_64/irq.h linux-2.6.16-rc1/include/asm-x86_64/irq.h
--- linux-2.6.15-git12/include/asm-x86_64/irq.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/asm-x86_64/irq.h	2006-01-17 08:22:53.586300892 +0000
@@ -36,7 +36,7 @@
 #define NR_IRQ_VECTORS NR_IRQS
 #else
 #define NR_IRQS 224
-#define NR_IRQ_VECTORS 1024
+#define NR_IRQ_VECTORS (32 * NR_CPUS)
 #endif
 
 static __inline__ int irq_canonicalize(int irq)
diff -purN linux-2.6.15-git12/include/asm-x86_64/page.h linux-2.6.16-rc1/include/asm-x86_64/page.h
--- linux-2.6.15-git12/include/asm-x86_64/page.h	2006-01-17 08:21:39.020717878 +0000
+++ linux-2.6.16-rc1/include/asm-x86_64/page.h	2006-01-17 08:22:53.598299003 +0000
@@ -26,6 +26,13 @@
 #define IRQSTACK_ORDER 2
 #define IRQSTACKSIZE (PAGE_SIZE << IRQSTACK_ORDER)
 
+#define STACKFAULT_STACK 1
+#define DOUBLEFAULT_STACK 2
+#define NMI_STACK 3
+#define DEBUG_STACK 4
+#define MCE_STACK 5
+#define N_EXCEPTION_STACKS 5  /* hw limit: 7 */
+
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
 
diff -purN linux-2.6.15-git12/include/asm-x86_64/processor.h linux-2.6.16-rc1/include/asm-x86_64/processor.h
--- linux-2.6.15-git12/include/asm-x86_64/processor.h	2006-01-17 08:21:39.028716619 +0000
+++ linux-2.6.16-rc1/include/asm-x86_64/processor.h	2006-01-17 08:22:53.605297901 +0000
@@ -273,13 +273,6 @@ struct thread_struct {
 #define INIT_MMAP \
 { &init_mm, 0, 0, NULL, PAGE_SHARED, VM_READ | VM_WRITE | VM_EXEC, 1, NULL, NULL }
 
-#define STACKFAULT_STACK 1
-#define DOUBLEFAULT_STACK 2 
-#define NMI_STACK 3 
-#define DEBUG_STACK 4 
-#define MCE_STACK 5
-#define N_EXCEPTION_STACKS 5  /* hw limit: 7 */
-
 #define start_thread(regs,new_rip,new_rsp) do { \
 	asm volatile("movl %0,%%fs; movl %0,%%es; movl %0,%%ds": :"r" (0));	 \
 	load_gs_index(0);							\
@@ -484,4 +477,6 @@ extern unsigned long boot_option_idle_ov
 /* Boot loader type from the setup header */
 extern int bootloader_type;
 
+#define HAVE_ARCH_PICK_MMAP_LAYOUT 1
+
 #endif /* __ASM_X86_64_PROCESSOR_H */
diff -purN linux-2.6.15-git12/include/asm-x86_64/system.h linux-2.6.16-rc1/include/asm-x86_64/system.h
--- linux-2.6.15-git12/include/asm-x86_64/system.h	2006-01-17 08:21:39.034715674 +0000
+++ linux-2.6.16-rc1/include/asm-x86_64/system.h	2006-01-17 08:22:53.612296799 +0000
@@ -354,11 +354,6 @@ static inline unsigned long __cmpxchg(vo
 #define local_irq_disable() 	__asm__ __volatile__("cli": : :"memory")
 #define local_irq_enable()	__asm__ __volatile__("sti": : :"memory")
 
-/* used in the idle loop; sti takes one instruction cycle to complete */
-#define safe_halt()		__asm__ __volatile__("sti; hlt": : :"memory")
-/* used when interrupts are already enabled or to shutdown the processor */
-#define halt()			__asm__ __volatile__("hlt": : :"memory")
-
 #define irqs_disabled()			\
 ({					\
 	unsigned long flags;		\
@@ -370,6 +365,11 @@ static inline unsigned long __cmpxchg(vo
 #define local_irq_save(x) 	do { warn_if_not_ulong(x); __asm__ __volatile__("# local_irq_save \n\t pushfq ; popq %0 ; cli":"=g" (x): /* no input */ :"memory"); } while (0)
 #endif
 
+/* used in the idle loop; sti takes one instruction cycle to complete */
+#define safe_halt()		__asm__ __volatile__("sti; hlt": : :"memory")
+/* used when interrupts are already enabled or to shutdown the processor */
+#define halt()			__asm__ __volatile__("hlt": : :"memory")
+
 void cpu_idle_wait(void);
 
 extern unsigned long arch_align_stack(unsigned long sp);
diff -purN linux-2.6.15-git12/include/linux/fs.h linux-2.6.16-rc1/include/linux/fs.h
--- linux-2.6.15-git12/include/linux/fs.h	2006-01-17 08:21:39.156696468 +0000
+++ linux-2.6.16-rc1/include/linux/fs.h	2006-01-17 08:22:53.709415277 +0000
@@ -1290,6 +1290,9 @@ extern void mnt_set_mountpoint(struct vf
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
 
+/* /sys/fs */
+extern struct subsystem fs_subsys;
+
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 
diff -purN linux-2.6.15-git12/include/linux/i2c-id.h linux-2.6.16-rc1/include/linux/i2c-id.h
--- linux-2.6.15-git12/include/linux/i2c-id.h	2006-01-17 08:21:39.166694894 +0000
+++ linux-2.6.16-rc1/include/linux/i2c-id.h	2006-01-17 08:22:53.721413388 +0000
@@ -104,6 +104,10 @@
 #define I2C_DRIVERID_AKITAIOEXP	74	/* IO Expander on Sharp SL-C1000 */
 #define I2C_DRIVERID_INFRARED	75	/* I2C InfraRed on Video boards */
 #define I2C_DRIVERID_TVP5150	76	/* TVP5150 video decoder        */
+#define I2C_DRIVERID_WM8739	77	/* wm8739 audio processor	*/
+#define I2C_DRIVERID_UPD64083	78	/* upd64083 video processor	*/
+#define I2C_DRIVERID_UPD64031A	79	/* upd64031a video processor	*/
+#define I2C_DRIVERID_SAA717X	80	/* saa717x video encoder	*/
 
 #define I2C_DRIVERID_I2CDEV	900
 #define I2C_DRIVERID_ARP        902    /* SMBus ARP Client              */
diff -purN linux-2.6.15-git12/include/linux/init.h linux-2.6.16-rc1/include/linux/init.h
--- linux-2.6.15-git12/include/linux/init.h	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/include/linux/init.h	2006-01-17 08:22:53.757407721 +0000
@@ -241,6 +241,18 @@ void __init parse_early_param(void);
 #define __cpuexitdata	__exitdata
 #endif
 
+#ifdef CONFIG_MEMORY_HOTPLUG
+#define __meminit
+#define __meminitdata
+#define __memexit
+#define __memexitdata
+#else
+#define __meminit	__init
+#define __meminitdata __initdata
+#define __memexit __exit
+#define __memexitdata	__exitdata
+#endif
+
 /* Functions marked as __devexit may be discarded at kernel link time, depending
    on config options.  Newer versions of binutils detect references from
    retained sections to discarded sections and flag an error.  Pointers to
diff -purN linux-2.6.15-git12/include/linux/kexec.h linux-2.6.16-rc1/include/linux/kexec.h
--- linux-2.6.15-git12/include/linux/kexec.h	2006-01-17 08:21:39.225685606 +0000
+++ linux-2.6.16-rc1/include/linux/kexec.h	2006-01-17 08:22:53.782403785 +0000
@@ -119,6 +119,7 @@ extern struct kimage *kexec_image;
 #define KEXEC_ARCH_PPC64   (21 << 16)
 #define KEXEC_ARCH_IA_64   (50 << 16)
 #define KEXEC_ARCH_S390    (22 << 16)
+#define KEXEC_ARCH_SH      (42 << 16)
 
 #define KEXEC_FLAGS    (KEXEC_ON_CRASH)  /* List of defined/legal kexec flags */
 
diff -purN linux-2.6.15-git12/include/media/tuner-types.h linux-2.6.16-rc1/include/media/tuner-types.h
--- linux-2.6.15-git12/include/media/tuner-types.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.16-rc1/include/media/tuner-types.h	2006-01-17 08:22:54.094354668 +0000
@@ -0,0 +1,55 @@
+/*
+ * descriptions for simple tuners.
+ */
+
+#ifndef __TUNER_TYPES_H__
+#define __TUNER_TYPES_H__
+
+enum param_type {
+	TUNER_PARAM_TYPE_RADIO, \
+	TUNER_PARAM_TYPE_PAL, \
+	TUNER_PARAM_TYPE_SECAM, \
+	TUNER_PARAM_TYPE_NTSC
+};
+
+struct tuner_range {
+	unsigned short limit;
+	unsigned char cb;
+};
+
+struct tuner_params {
+	enum param_type type;
+	/* Many Philips based tuners have a comment like this in their
+	 * datasheet:
+	 *
+	 *   For channel selection involving band switching, and to ensure
+	 *   smooth tuning to the desired channel without causing
+	 *   unnecessary charge pump action, it is recommended to consider
+	 *   the difference between wanted channel frequency and the
+	 *   current channel frequency.  Unnecessary charge pump action
+	 *   will result in very low tuning voltage which may drive the
+	 *   oscillator to extreme conditions.
+	 *
+	 * Set cb_first_if_lower_freq to 1, if this check is
+	 * required for this tuner.
+	 *
+	 * I tested this for PAL by first setting the TV frequency to
+	 * 203 MHz and then switching to 96.6 MHz FM radio. The result was
+	 * static unless the control byte was sent first.
+	 */
+	unsigned int cb_first_if_lower_freq:1;
+	unsigned char config; /* to be moved into struct tuner_range for dvb-pll merge */
+
+	unsigned int count;
+	struct tuner_range *ranges;
+};
+
+struct tunertype {
+	char *name;
+	struct tuner_params *params;
+};
+
+extern struct tunertype tuners[];
+extern unsigned const int tuner_count;
+
+#endif
diff -purN linux-2.6.15-git12/include/media/tuner.h linux-2.6.16-rc1/include/media/tuner.h
--- linux-2.6.15-git12/include/media/tuner.h	2006-01-17 08:21:39.515774857 +0000
+++ linux-2.6.16-rc1/include/media/tuner.h	2006-01-17 08:22:54.097354195 +0000
@@ -23,6 +23,7 @@
 #define _TUNER_H
 
 #include <linux/videodev2.h>
+#include <media/tuner-types.h>
 
 #define ADDR_UNSET (255)
 
@@ -114,6 +115,7 @@
 
 #define TUNER_PHILIPS_TUV1236D		68	/* ATI HDTV Wonder */
 #define TUNER_TNF_5335MF                69	/* Sabrent Bt848   */
+#define TUNER_SAMSUNG_TCPN_2121P30A     70 	/* Hauppauge PVR-500MCE NTSC */
 
 /* tv card specific */
 #define TDA9887_PRESENT 		(1<<0)
@@ -177,7 +179,9 @@ struct tuner {
 	unsigned int mode;
 	unsigned int mode_mask;	/* Combination of allowable modes */
 
-	unsigned int freq;	/* keep track of the current settings */
+	unsigned int tv_freq;	/* keep track of the current settings */
+	unsigned int radio_freq;
+	u16 	     last_div;
 	unsigned int audmode;
 	v4l2_std_id  std;
 
@@ -195,8 +199,8 @@ struct tuner {
 	unsigned int sgIF;
 
 	/* function ptrs */
-	void (*tv_freq)(struct i2c_client *c, unsigned int freq);
-	void (*radio_freq)(struct i2c_client *c, unsigned int freq);
+	void (*set_tv_freq)(struct i2c_client *c, unsigned int freq);
+	void (*set_radio_freq)(struct i2c_client *c, unsigned int freq);
 	int  (*has_signal)(struct i2c_client *c);
 	int  (*is_stereo)(struct i2c_client *c);
 	void (*standby)(struct i2c_client *c);
diff -purN linux-2.6.15-git12/include/media/v4l2-common.h linux-2.6.16-rc1/include/media/v4l2-common.h
--- linux-2.6.15-git12/include/media/v4l2-common.h	2006-01-17 08:21:39.517774542 +0000
+++ linux-2.6.16-rc1/include/media/v4l2-common.h	2006-01-17 08:22:54.100353723 +0000
@@ -120,6 +120,13 @@ enum v4l2_chip_ident {
 /* select from TV,radio,extern,MUTE */
 #define AUDC_SET_INPUT        _IOW('d',89,int)
 
+/* msp3400 ioctl: will be removed in the near future */
+struct msp_matrix {
+  int input;
+  int output;
+};
+#define MSP_SET_MATRIX     _IOW('m',17,struct msp_matrix)
+
 /* tuner ioctls */
 /* Sets tuner type and its I2C addr */
 #define TUNER_SET_TYPE_ADDR          _IOW('d',90,int)
diff -purN linux-2.6.15-git12/init/Kconfig linux-2.6.16-rc1/init/Kconfig
--- linux-2.6.15-git12/init/Kconfig	2006-01-17 08:21:39.850722120 +0000
+++ linux-2.6.16-rc1/init/Kconfig	2006-01-17 08:22:54.457297522 +0000
@@ -427,6 +427,9 @@ config SLOB
 	default !SLAB
 	bool
 
+config OBSOLETE_INTERMODULE
+	tristate
+
 menu "Loadable module support"
 
 config MODULES
diff -purN linux-2.6.15-git12/kernel/Makefile linux-2.6.16-rc1/kernel/Makefile
--- linux-2.6.15-git12/kernel/Makefile	2006-01-17 08:21:39.870718971 +0000
+++ linux-2.6.16-rc1/kernel/Makefile	2006-01-17 08:22:54.480293901 +0000
@@ -6,7 +6,7 @@ obj-y     = sched.o fork.o exec_domain.o
 	    exit.o itimer.o time.o softirq.o resource.o \
 	    sysctl.o capability.o ptrace.o timer.o user.o \
 	    signal.o sys.o kmod.o workqueue.o pid.o \
-	    rcupdate.o intermodule.o extable.o params.o posix-timers.o \
+	    rcupdate.o extable.o params.o posix-timers.o \
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o
 
@@ -17,6 +17,7 @@ obj-$(CONFIG_SMP) += cpu.o spinlock.o
 obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock.o
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += module.o
+obj-$(CONFIG_OBSOLETE_INTERMODULE) += intermodule.o
 obj-$(CONFIG_KALLSYMS) += kallsyms.o
 obj-$(CONFIG_PM) += power/
 obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
diff -purN linux-2.6.15-git12/kernel/hrtimer.c linux-2.6.16-rc1/kernel/hrtimer.c
--- linux-2.6.15-git12/kernel/hrtimer.c	2006-01-17 08:21:39.910712674 +0000
+++ linux-2.6.16-rc1/kernel/hrtimer.c	2006-01-17 08:22:54.522287289 +0000
@@ -272,7 +272,7 @@ void unlock_hrtimer_base(const struct hr
  * @interval:	the interval to forward
  *
  * Forward the timer expiry so it will expire in the future.
- * The number of overruns is added to the overrun field.
+ * Returns the number of overruns.
  */
 unsigned long
 hrtimer_forward(struct hrtimer *timer, ktime_t interval)
@@ -641,7 +641,8 @@ schedule_hrtimer_interruptible(struct hr
 static long __sched
 nanosleep_restart(struct restart_block *restart, clockid_t clockid)
 {
-	struct timespec __user *rmtp, tu;
+	struct timespec __user *rmtp;
+	struct timespec tu;
 	void *rfn_save = restart->fn;
 	struct hrtimer timer;
 	ktime_t rem;
diff -purN linux-2.6.15-git12/mm/page_alloc.c linux-2.6.16-rc1/mm/page_alloc.c
--- linux-2.6.15-git12/mm/page_alloc.c	2006-01-17 08:21:40.138806527 +0000
+++ linux-2.6.16-rc1/mm/page_alloc.c	2006-01-17 08:22:54.762386255 +0000
@@ -1735,7 +1735,7 @@ static void __init calculate_zone_totalp
  * up by free_all_bootmem() once the early boot process is
  * done. Non-atomic initialization, single-pass.
  */
-void __devinit memmap_init_zone(unsigned long size, int nid, unsigned long zone,
+void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,
 		unsigned long start_pfn)
 {
 	struct page *page;
@@ -1788,7 +1788,7 @@ void zonetable_add(struct zone *zone, in
 	memmap_init_zone((size), (nid), (zone), (start_pfn))
 #endif
 
-static int __devinit zone_batchsize(struct zone *zone)
+static int __meminit zone_batchsize(struct zone *zone)
 {
 	int batch;
 
@@ -1882,7 +1882,7 @@ static struct per_cpu_pageset
  * Dynamically allocate memory for the
  * per cpu pageset array in struct zone.
  */
-static int __devinit process_zones(int cpu)
+static int __meminit process_zones(int cpu)
 {
 	struct zone *zone, *dzone;
 
@@ -1923,7 +1923,7 @@ static inline void free_zone_pagesets(in
 	}
 }
 
-static int __devinit pageset_cpuup_callback(struct notifier_block *nfb,
+static int __meminit pageset_cpuup_callback(struct notifier_block *nfb,
 		unsigned long action,
 		void *hcpu)
 {
@@ -1963,7 +1963,7 @@ void __init setup_per_cpu_pageset(void)
 
 #endif
 
-static __devinit
+static __meminit
 void zone_wait_table_init(struct zone *zone, unsigned long zone_size_pages)
 {
 	int i;
@@ -1983,7 +1983,7 @@ void zone_wait_table_init(struct zone *z
 		init_waitqueue_head(zone->wait_table + i);
 }
 
-static __devinit void zone_pcp_init(struct zone *zone)
+static __meminit void zone_pcp_init(struct zone *zone)
 {
 	int cpu;
 	unsigned long batch = zone_batchsize(zone);
@@ -2001,7 +2001,7 @@ static __devinit void zone_pcp_init(stru
 		zone->name, zone->present_pages, batch);
 }
 
-static __devinit void init_currently_empty_zone(struct zone *zone,
+static __meminit void init_currently_empty_zone(struct zone *zone,
 		unsigned long zone_start_pfn, unsigned long size)
 {
 	struct pglist_data *pgdat = zone->zone_pgdat;
diff -purN linux-2.6.15-git12/scripts/kconfig/confdata.c linux-2.6.16-rc1/scripts/kconfig/confdata.c
--- linux-2.6.15-git12/scripts/kconfig/confdata.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/confdata.c	2006-01-17 08:22:56.173296874 +0000
@@ -375,7 +375,7 @@ int conf_write(const char *name)
 		if (!out_h)
 			return 1;
 	}
-	sym = sym_lookup("KERNELRELEASE", 0);
+	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
 	time(&now);
 	env = getenv("KCONFIG_NOTIMESTAMP");
diff -purN linux-2.6.15-git12/scripts/kconfig/gconf.c linux-2.6.16-rc1/scripts/kconfig/gconf.c
--- linux-2.6.15-git12/scripts/kconfig/gconf.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/gconf.c	2006-01-17 08:22:56.176296402 +0000
@@ -276,7 +276,7 @@ void init_main_window(const gchar * glad
 					  NULL);
 
 	sprintf(title, _("Linux Kernel v%s Configuration"),
-		getenv("KERNELRELEASE"));
+		getenv("KERNELVERSION"));
 	gtk_window_set_title(GTK_WINDOW(main_wnd), title);
 
 	gtk_widget_show(main_wnd);
diff -purN linux-2.6.15-git12/scripts/kconfig/lxdialog/Makefile linux-2.6.16-rc1/scripts/kconfig/lxdialog/Makefile
--- linux-2.6.15-git12/scripts/kconfig/lxdialog/Makefile	2006-01-17 08:21:41.487731909 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/lxdialog/Makefile	2006-01-17 08:22:56.179295930 +0000
@@ -1,9 +1,9 @@
 # Makefile to build lxdialog package
 #
 
-check-lxdialog   := $(srctree)/$(src)/check-lxdialog.sh
-HOST_EXTRACFLAGS := $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags)
-HOST_LOADLIBES   := $(shell $(CONFIG_SHELL) $(check-lxdialog) -ldflags)
+check-lxdialog  := $(srctree)/$(src)/check-lxdialog.sh
+HOST_EXTRACFLAGS:= $(shell $(CONFIG_SHELL) $(check-lxdialog) -ccflags)
+HOST_LOADLIBES  := $(shell $(CONFIG_SHELL) $(check-lxdialog) -ldflags $(HOSTCC))
  
 HOST_EXTRACFLAGS += -DLOCALE 
 
diff -purN linux-2.6.15-git12/scripts/kconfig/lxdialog/check-lxdialog.sh linux-2.6.16-rc1/scripts/kconfig/lxdialog/check-lxdialog.sh
--- linux-2.6.15-git12/scripts/kconfig/lxdialog/check-lxdialog.sh	2006-01-17 08:21:41.488731751 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/lxdialog/check-lxdialog.sh	2006-01-17 08:22:56.180295772 +0000
@@ -4,11 +4,22 @@
 # What library to link
 ldflags()
 {
-	if [ `uname` == SunOS ]; then
-		echo '-lcurses'
-	else
+	echo "main() {}" | $cc -lncursesw -xc - -o /dev/null 2> /dev/null
+	if [ $? -eq 0 ]; then
+		echo '-lncursesw'
+		exit
+	fi
+	echo "main() {}" | $cc -lncurses -xc - -o /dev/null 2> /dev/null
+	if [ $? -eq 0 ]; then
 		echo '-lncurses'
+		exit
 	fi
+	echo "main() {}" | $cc -lcurses -xc - -o /dev/null 2> /dev/null
+	if [ $? -eq 0 ]; then
+		echo '-lcurses'
+		exit
+	fi
+	exit 1
 }
 
 # Where is ncurses.h?
@@ -28,7 +39,7 @@ ccflags()
 compiler=""
 # Check if we can link to ncurses
 check() {
-	echo "main() {}" | $compiler -xc -
+	echo "main() {}" | $cc -xc - -o /dev/null 2> /dev/null
 	if [ $? != 0 ]; then
 		echo " *** Unable to find the ncurses libraries."          1>&2
 		echo " *** make menuconfig require the ncurses libraries"  1>&2
@@ -51,13 +62,15 @@ fi
 case "$1" in
 	"-check")
 		shift
-		compiler="$@"
+		cc="$@"
 		check
 		;;
 	"-ccflags")
 		ccflags
 		;;
 	"-ldflags")
+		shift
+		cc="$@"
 		ldflags
 		;;
 	"*")
diff -purN linux-2.6.15-git12/scripts/kconfig/mconf.c linux-2.6.16-rc1/scripts/kconfig/mconf.c
--- linux-2.6.15-git12/scripts/kconfig/mconf.c	2006-01-17 08:21:41.524726084 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/mconf.c	2006-01-17 08:22:56.214290420 +0000
@@ -1051,7 +1051,7 @@ int main(int ac, char **av)
 	conf_parse(av[1]);
 	conf_read(NULL);
 
-	sym = sym_lookup("KERNELRELEASE", 0);
+	sym = sym_lookup("KERNELVERSION", 0);
 	sym_calc_value(sym);
 	sprintf(menu_backtitle, _("Linux Kernel v%s Configuration"),
 		sym_get_string_value(sym));
diff -purN linux-2.6.15-git12/scripts/kconfig/symbol.c linux-2.6.16-rc1/scripts/kconfig/symbol.c
--- linux-2.6.15-git12/scripts/kconfig/symbol.c	2006-01-03 03:21:10.000000000 +0000
+++ linux-2.6.16-rc1/scripts/kconfig/symbol.c	2006-01-17 08:22:56.217289947 +0000
@@ -61,10 +61,10 @@ void sym_init(void)
 	if (p)
 		sym_add_default(sym, p);
 
-	sym = sym_lookup("KERNELRELEASE", 0);
+	sym = sym_lookup("KERNELVERSION", 0);
 	sym->type = S_STRING;
 	sym->flags |= SYMBOL_AUTO;
-	p = getenv("KERNELRELEASE");
+	p = getenv("KERNELVERSION");
 	if (p)
 		sym_add_default(sym, p);
 

From: Jeff Mahoney <jeffm@suse.com>
Subject: Update to 2.6.22-rc4-git6
Patch-mainline: 2.6.22-rc4-git6

 Update to 2.6.22-rc4-git6.

 - Added libertas wireless
 - libata passthru
 - Other misc fixes

 Changes since 2.6.22-rc4-git3:

  - mmc: get back read-only switch function
  - mmc-omap: fix sd response type 6 vs. 1
  - Input: move input-polldev to drivers/input
  - sysfs: fix race condition around sd->s_dentry, take#2
  - sysfs: fix condition check in sysfs_drop_dentry()
  - sysfs: store sysfs inode nrs in s_ino to avoid readdir ...
  - myri10ge: update driver version
  - myri10ge: report when the link partner is running in ...
  - myri10ge: limit the number of recoveries
  - NetXen: Fix link status messages
  - Revert "[netdrvr e100] experiment with doing RX in ...
  - libertas: convert libertas_mpp into anycast ...
  - libertas: actually send mesh frames to mesh ...
  - libertas: deauthenticate from AP in channel ...
  - libertas: pull current channel from firmware ...
  - Input: i8042 - add ULI EV4873 to noloop list
  - Input: i8042 - add ASUS P65UP5 to the noloop list
  - Input: usbtouchscreen - fix fallout caused by move ...
  - libertas: reduce SSID and BSSID mixed-case ...
  - libertas: remove WPA_SUPPLICANT structure
  - libertas: remove structure WLAN_802_11_SSID ...
  - libertas: tweak association debug output
  - libertas: fix big-endian associate command.
  - libertas: don't byte-swap firmware version ...
  - libertas: more endianness fixes, in tx.c this ...
  - libertas: More endianness fixes.
  - libertas: first pass at fixing up endianness ...
  - libertas: sparse fixes
  - libertas: fix character set in README
  - libertas: support for mesh autostart on firmwar ...
  - libertas: split wext for eth and msh
  - libertas: make mac address configuration work ...
  - libertas: updated readme file
  - libertas: Make WPA work through supplicant ...
  - libertas: add more verbose debugging to liberta ...
  - libertas: debug print spacing fixes in assoc.c
  - libertas: send SIOCGIWSCAN event after partial ...
  - libertas: honor specific channel requests durin ...
  - libertas: fix default adhoc channel
  - libertas: fix deadlock SIOCGIWSCAN handler
  - libertas: correct error report paths for wlan ...
  - libertas: correctly balance locking in libertas ...
  - libertas: fix debug enter/leave prints for ...
  - libertas: use compare_ether_addr() rather than ...
  - libertas: use MAC_FMT and MAC_ARG where appropriate
  - libertas: make association paths consistent
  - libertas: move channel changing into associatio ...
  - libertas: fix oops on rmmod
  - libertas: cleanup of fwt_list_route processing
  - libertas: fix 'keep previous scan' behavior
  - libertas: make scan result handling more flexible
  - libertas: updated mesh commands for 5.220.9.p11
  - libertas: version bump (321p0) and cmds update ...
  - libertas: don't tear down netdev in libertas ...
  - libertas: correctly unregister mesh netdev ...
  - libertas: replace 'macaddress' with 'bssid'
  - libertas: call SET_NETDEV_DEV from common code
  - libertas: fixed kernel oops on module/card ...
  - libertas: add URB debug info
  - libertas: fixed incorrect assigment of fcs ...
  - libertas: remove unused variables in wlan_dev_t
  - libertas: let DRV_NAME be overridable
  - libertas: fix RESET logic at unload time
  - libertas: split module into two (libertas.ko ...
  - libertas: move contents of fw.h to decl.h
  - libertas: indirect all hardware access via ...
  - libertas: wakeup both mesh and normal wakeup ...
  - libertas: added transmission failures to mesh ...
  - libertas: fix error handling of card initialization
  - libertas: fixed transmission flow control on ...
  - libertas: split wlan_add_card()
  - libertas: move reset_device() code main.c to ...
  - libertas: changed some occurences of kmalloc() ...
  - libertas: fix SSID output
  - libertas: get rid of libertas_sbi_get_priv()
  - libertas: change debug output of libertas_inter ...
  - libertas: single out mesh code
  - libertas: tune debug code
  - libertas: make debug configurable
  - libertas: exclude non-used code when PROC_DEBUG ...
  - libertas: fix scanning from associate path
  - libertas: make libertas_wlan_data_rates static
  - libertas: move vendor  ...
  - libertas: remove unused/superfluous definitions ...
  - libertas: remove __FILE__ from debug output
  - libertas: remove deprecated pm_register and ...
  - libertas: fix removal of all debugfs files
  - libertas: a debug output was missing a newline
  - libertas: rename wlan_association_worker
  - libertas: scan two channels per scan command
  - [MIPS] Fix smp barriers in test_and_{change,clear,set}_bit
  - [MIPS] Fix IP27 build
  - [MIPS] Fix modpost warnings by making start_secondary ...
  - [MIPS] SMTC: Fix build error caused by nonsense code.
  - [MIPS] SMTC: The MT ASE requires to initialize c0_pagem ...
  - [MIPS] SMTC: Don't continue in set_vi_srs_handler on ...
  - [MIPS] SMTC: Fix warning.
  - [MIPS] Wire up utimensat, signalfd, timerfd, eventfd
  - [MIPS] Atlas: Fix build.
  - [MIPS] Always install the DSP exception handler.
  - [MIPS] SMTC: Don't set and restore irqregs ptr from ...
  - [MIPS] Fix KMODE for the R3000
  - libata: limit post SRST nsect/lbal wait to ~100ms
  - libata: force PIO on IOMEGA ZIP 250 ATAPI
  - libata passthru: update cached device paramters
  - libata passthru: always enforce correct DEV bit
  - libata passthru: map UDMA protocols
  - libata passthru: support PIO multi commands
  - libata passthru: update protocol numbers
  - libata: Correct abuse of language
  - libata-core/sff: Fix multiple assumptions about DMA
  - ahci: Add MCP73/MCP77 support to AHCI driver
  - libata: fix hw_sata_spd_limit initialization
  - libata: print device model and firmware revision for ...
  - libata: fix probe time irq printouts
  - libata: disable NCQ for HITACHI HTS541680J9SA00/SB21C7EP
  - remove unused variable in pata_isapnp
  - net: fix typo in drivers/net/usb/Kconfig
  - phylib: add RGMII-ID mode to the Marvell m88e1111 PHY ...
  - ehea: Fixed possible kernel panic on VLAN packet recv
  - NetXen: Fix compile failure seen on PPC architecture
  - NetXen: Fix ping issue after reboot on Blades with ...
  - typo in via-velocity.c
  - ibmveth: Automatically enable larger rx buffer pools ...
  - ibmveth: Fix h_free_logical_lan error on pool resize

Acked-by: Jeff Mahoney <jeffm@suse.com>
---


 Makefile                                       |    2 
 arch/mips/kernel/scall32-o32.S                 |    6 
 arch/mips/kernel/scall64-64.S                  |    4 
 arch/mips/kernel/scall64-n32.S                 |    4 
 arch/mips/kernel/scall64-o32.S                 |    4 
 arch/mips/kernel/smp.c                         |    2 
 arch/mips/kernel/smtc-asm.S                    |    3 
 arch/mips/kernel/smtc.c                        |    4 
 arch/mips/kernel/traps.c                       |   15 
 arch/mips/mips-boards/atlas/atlas_int.c        |    5 
 arch/mips/mips-boards/generic/time.c           |   16 
 arch/mips/sgi-ip27/ip27-memory.c               |    2 
 drivers/ata/ahci.c                             |   24 
 drivers/ata/libata-core.c                      |   62 -
 drivers/ata/libata-scsi.c                      |   67 -
 drivers/ata/libata-sff.c                       |   37 
 drivers/ata/pata_isapnp.c                      |    1 
 drivers/char/agp/agp.h                         |    6 
 drivers/char/agp/intel-agp.c                   |  576 ++++-----
 drivers/ide/ide-disk.c                         |   12 
 drivers/ide/ide-probe.c                        |   12 
 drivers/ide/ide.c                              |    9 
 drivers/ide/pci/amd74xx.c                      |   12 
 drivers/ide/pci/generic.c                      |   37 
 drivers/ide/pci/hpt366.c                       |    8 
 drivers/ide/pci/it821x.c                       |   34 
 drivers/ide/pci/serverworks.c                  |   51 
 drivers/infiniband/core/cma.c                  |    4 
 drivers/infiniband/hw/mlx4/qp.c                |   33 
 drivers/infiniband/hw/mthca/mthca_cmd.c        |    2 
 drivers/input/Kconfig                          |   13 
 drivers/input/Makefile                         |    1 
 drivers/input/input-polldev.c                  |  176 ++
 drivers/input/misc/Kconfig                     |   11 
 drivers/input/misc/Makefile                    |    1 
 drivers/input/misc/input-polldev.c             |  176 --
 drivers/input/serio/i8042-x86ia64io.h          |   18 
 drivers/input/touchscreen/usbtouchscreen.c     |   44 
 drivers/media/common/Kconfig                   |    1 
 drivers/media/dvb/b2c2/Makefile                |    7 
 drivers/media/dvb/cinergyT2/cinergyT2.c        |    3 
 drivers/media/dvb/frontends/tda10086.c         |   21 
 drivers/media/dvb/frontends/tda826x.c          |    4 
 drivers/media/video/Kconfig                    |    2 
 drivers/media/video/ivtv/ivtv-cards.h          |    2 
 drivers/media/video/ivtv/ivtv-driver.c         |    1 
 drivers/media/video/ivtv/ivtv-driver.h         |   16 
 drivers/media/video/ivtv/ivtv-fileops.c        |   16 
 drivers/media/video/ivtv/ivtv-ioctl.c          |   45 
 drivers/media/video/ivtv/ivtv-irq.c            |  204 ++-
 drivers/media/video/ivtv/ivtv-queue.c          |   31 
 drivers/media/video/ivtv/ivtv-queue.h          |   39 
 drivers/media/video/ivtv/ivtv-streams.c        |    2 
 drivers/media/video/ivtv/ivtv-vbi.c            |    2 
 drivers/media/video/ivtv/ivtv-vbi.h            |    2 
 drivers/media/video/saa7111.c                  |   49 
 drivers/media/video/usbvision/usbvision-core.c |   82 -
 drivers/media/video/usbvision/usbvision.h      |    1 
 drivers/mmc/core/sd.c                          |   41 
 drivers/mmc/host/at91_mci.c                    |    5 
 drivers/mmc/host/au1xmmc.c                     |    3 
 drivers/mmc/host/omap.c                        |   24 
 drivers/net/e100.c                             |   72 +
 drivers/net/ehea/ehea.h                        |    2 
 drivers/net/ehea/ehea_main.c                   |   12 
 drivers/net/ibmveth.c                          |   80 -
 drivers/net/mlx4/cq.c                          |    2 
 drivers/net/mlx4/eq.c                          |    4 
 drivers/net/mlx4/fw.c                          |   27 
 drivers/net/mlx4/intf.c                        |    3 
 drivers/net/mlx4/main.c                        |    2 
 drivers/net/mlx4/mr.c                          |    8 
 drivers/net/myri10ge/myri10ge.c                |   29 
 drivers/net/netxen/netxen_nic.h                |   46 
 drivers/net/netxen/netxen_nic_ethtool.c        |    8 
 drivers/net/netxen/netxen_nic_hw.c             |   12 
 drivers/net/netxen/netxen_nic_init.c           |   44 
 drivers/net/netxen/netxen_nic_isr.c            |   24 
 drivers/net/netxen/netxen_nic_main.c           |    7 
 drivers/net/netxen/netxen_nic_niu.c            |    8 
 drivers/net/phy/marvell.c                      |   62 -
 drivers/net/usb/Kconfig                        |    4 
 drivers/net/via-velocity.c                     |    2 
 drivers/net/wireless/Kconfig                   |   19 
 drivers/net/wireless/libertas/11d.c            |  152 +-
 drivers/net/wireless/libertas/11d.h            |    6 
 drivers/net/wireless/libertas/Makefile         |    4 
 drivers/net/wireless/libertas/README           |   52 
 drivers/net/wireless/libertas/assoc.c          |  358 +++--
 drivers/net/wireless/libertas/assoc.h          |   10 
 drivers/net/wireless/libertas/cmd.c            |  559 ++++-----
 drivers/net/wireless/libertas/cmdresp.c        |  376 ++----
 drivers/net/wireless/libertas/debugfs.c        |  432 +++----
 drivers/net/wireless/libertas/decl.h           |   20 
 drivers/net/wireless/libertas/defs.h           |  101 +
 drivers/net/wireless/libertas/dev.h            |  101 -
 drivers/net/wireless/libertas/ethtool.c        |   57 
 drivers/net/wireless/libertas/fw.c             |  111 -
 drivers/net/wireless/libertas/fw.h             |   13 
 drivers/net/wireless/libertas/host.h           |   17 
 drivers/net/wireless/libertas/hostcmd.h        |  394 +++---
 drivers/net/wireless/libertas/if_bootcmd.c     |    6 
 drivers/net/wireless/libertas/if_usb.c         |  450 +++----
 drivers/net/wireless/libertas/if_usb.h         |   32 
 drivers/net/wireless/libertas/ioctl.c          |  286 +++-
 drivers/net/wireless/libertas/join.c           |  464 +++----
 drivers/net/wireless/libertas/join.h           |   13 
 drivers/net/wireless/libertas/main.c           |  690 ++++-------
 drivers/net/wireless/libertas/rx.c             |   64 -
 drivers/net/wireless/libertas/sbi.h            |   40 
 drivers/net/wireless/libertas/scan.c           | 1537 +++++++++++--------------
 drivers/net/wireless/libertas/scan.h           |   85 -
 drivers/net/wireless/libertas/thread.h         |    8 
 drivers/net/wireless/libertas/tx.c             |   74 -
 drivers/net/wireless/libertas/types.h          |   63 -
 drivers/net/wireless/libertas/wext.c           |  774 ++++++------
 drivers/net/wireless/libertas/wext.h           |   13 
 fs/cifs/cifs_debug.c                           |  248 ++--
 fs/cifs/cifs_unicode.c                         |   12 
 fs/cifs/cifsfs.c                               |    2 
 fs/cifs/cifssmb.c                              |    4 
 fs/cifs/connect.c                              |   16 
 fs/cifs/dir.c                                  |  184 +-
 fs/cifs/fcntl.c                                |   46 
 fs/cifs/inode.c                                |    5 
 fs/cifs/ioctl.c                                |   29 
 fs/cifs/rfc1002pdu.h                           |    2 
 fs/splice.c                                    |   70 -
 fs/sysfs/dir.c                                 |   38 
 fs/sysfs/inode.c                               |   21 
 fs/sysfs/mount.c                               |    1 
 fs/sysfs/sysfs.h                               |    2 
 include/asm-mips/bitops.h                      |   51 
 include/asm-mips/stackframe.h                  |   52 
 include/asm-mips/unistd.h                      |   24 
 include/linux/ata.h                            |    3 
 include/linux/ide.h                            |    1 
 include/linux/libata.h                         |    1 
 include/linux/pci_ids.h                        |    2 
 include/linux/pipe_fs_i.h                      |   30 
 include/linux/videodev2.h                      |    7 
 141 files changed, 5724 insertions(+), 5063 deletions(-)

diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall32-o32.S linux-2.6.22-rc4-git6/arch/mips/kernel/scall32-o32.S
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall32-o32.S	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/scall32-o32.S	2007-06-14 14:14:33.000000000 -0400
@@ -657,7 +657,11 @@ einval:	li	v0, -EINVAL
 	sys	sys_getcpu		3
 	sys	sys_epoll_pwait		6
 	sys	sys_ioprio_set		3
-	sys	sys_ioprio_get		2
+	sys	sys_ioprio_get		2	/* 4315 */
+	sys	sys_utimensat		4
+	sys	sys_signalfd		3
+	sys	sys_timerfd		4
+	sys	sys_eventfd		1
 	.endm
 
 	/* We pre-compute the number of _instruction_ bytes needed to
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-64.S linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-64.S
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-64.S	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-64.S	2007-06-14 14:14:33.000000000 -0400
@@ -473,4 +473,8 @@ sys_call_table:
 	PTR	sys_epoll_pwait
 	PTR	sys_ioprio_set
 	PTR	sys_ioprio_get
+	PTR	sys_utimensat			/* 5275 */
+	PTR	sys_signalfd
+	PTR	sys_timerfd
+	PTR	sys_eventfd
 	.size	sys_call_table,.-sys_call_table
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-n32.S linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-n32.S
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-n32.S	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-n32.S	2007-06-14 14:14:33.000000000 -0400
@@ -399,4 +399,8 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_epoll_pwait
 	PTR	sys_ioprio_set
 	PTR	sys_ioprio_get
+	PTR	compat_sys_utimensat
+	PTR	compat_sys_signalfd		/* 5280 */
+	PTR	compat_sys_timerfd
+	PTR	sys_eventfd
 	.size	sysn32_call_table,.-sysn32_call_table
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-o32.S linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-o32.S
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/scall64-o32.S	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/scall64-o32.S	2007-06-14 14:14:33.000000000 -0400
@@ -521,4 +521,8 @@ sys_call_table:
 	PTR	compat_sys_epoll_pwait
 	PTR	sys_ioprio_set
 	PTR	sys_ioprio_get			/* 4315 */
+	PTR	compat_sys_utimensat
+	PTR	compat_sys_signalfd
+	PTR	compat_sys_timerfd
+	PTR	sys_eventfd
 	.size	sys_call_table,.-sys_call_table
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smp.c linux-2.6.22-rc4-git6/arch/mips/kernel/smp.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smp.c	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/smp.c	2007-06-14 14:14:33.000000000 -0400
@@ -68,7 +68,7 @@ extern ATTRIB_NORET void cpu_idle(void);
  * First C code run on the secondary CPUs after being started up by
  * the master.
  */
-asmlinkage void start_secondary(void)
+asmlinkage __cpuinit void start_secondary(void)
 {
 	unsigned int cpu;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smtc-asm.S linux-2.6.22-rc4-git6/arch/mips/kernel/smtc-asm.S
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smtc-asm.S	2007-06-08 12:07:53.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/smtc-asm.S	2007-06-14 14:14:33.000000000 -0400
@@ -121,10 +121,7 @@ LEAF(self_ipi)
 	subu	t1,sp,PT_SIZE
 	sw	ra,PT_EPC(t1)
 	sw	a0,PT_PADSLOT4(t1)
-	LONG_L	s0, TI_REGS($28)
-	LONG_S	sp, TI_REGS($28)
 	la	t2,ipi_decode
-	LONG_S	s0, TI_REGS($28)
 	sw	t2,PT_PADSLOT5(t1)
 	/* Save pre-disable value of TCStatus */
 	sw	t0,PT_TCSTATUS(t1)
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smtc.c linux-2.6.22-rc4-git6/arch/mips/kernel/smtc.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/smtc.c	2007-06-08 12:08:17.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/smtc.c	2007-06-14 14:14:33.000000000 -0400
@@ -611,12 +611,12 @@ void smtc_cpus_done(void)
 int setup_irq_smtc(unsigned int irq, struct irqaction * new,
 			unsigned long hwmask)
 {
+#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 	unsigned int vpe = current_cpu_data.vpe_id;
 
-	irq_hwmask[irq] = hwmask;
-#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 	vpemask[vpe][irq - MIPSCPU_INT_BASE] = 1;
 #endif
+	irq_hwmask[irq] = hwmask;
 
 	return setup_irq(irq, new);
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/kernel/traps.c linux-2.6.22-rc4-git6/arch/mips/kernel/traps.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/kernel/traps.c	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/kernel/traps.c	2007-06-14 14:14:33.000000000 -0400
@@ -11,6 +11,7 @@
  * Copyright (C) 2000, 01 MIPS Technologies, Inc.
  * Copyright (C) 2002, 2003, 2004, 2005  Maciej W. Rozycki
  */
+#include <linux/bug.h>
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/module.h>
@@ -1190,8 +1191,8 @@ static void *set_vi_srs_handler(int n, v
 
 		memcpy (b, &except_vec_vi, handler_len);
 #ifdef CONFIG_MIPS_MT_SMTC
-		if (n > 7)
-			printk("Vector index %d exceeds SMTC maximum\n", n);
+		BUG_ON(n > 7);	/* Vector index %d exceeds SMTC maximum. */
+
 		w = (u32 *)(b + mori_offset);
 		*w = (*w & 0xffff0000) | (0x100 << n);
 #endif /* CONFIG_MIPS_MT_SMTC */
@@ -1383,6 +1384,13 @@ void __init per_cpu_trap_init(void)
 		cpu_cache_init();
 		tlb_init();
 #ifdef CONFIG_MIPS_MT_SMTC
+	} else if (!secondaryTC) {
+		/*
+		 * First TC in non-boot VPE must do subset of tlb_init()
+		 * for MMU countrol registers.
+		 */
+		write_c0_pagemask(PM_DEFAULT_MASK);
+		write_c0_wired(0);
 	}
 #endif /* CONFIG_MIPS_MT_SMTC */
 }
@@ -1531,8 +1539,7 @@ void __init trap_init(void)
 	if (cpu_has_mipsmt)
 		set_except_vector(25, handle_mt);
 
-	if (cpu_has_dsp)
-		set_except_vector(26, handle_dsp);
+	set_except_vector(26, handle_dsp);
 
 	if (cpu_has_vce)
 		/* Special exception: R4[04]00 uses also the divec space. */
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/mips-boards/atlas/atlas_int.c linux-2.6.22-rc4-git6/arch/mips/mips-boards/atlas/atlas_int.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/mips-boards/atlas/atlas_int.c	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/mips-boards/atlas/atlas_int.c	2007-06-14 14:14:33.000000000 -0400
@@ -248,14 +248,13 @@ void __init arch_init_irq(void)
 	case MIPS_REVISION_CORID_CORE_24K:
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
 		if (cpu_has_veic)
-			init_msc_irqs (MSC01E_INT_BASE,
+			init_msc_irqs (MSC01E_INT_BASE, MSC01E_INT_BASE,
 				       msc_eicirqmap, msc_nr_eicirqs);
 		else
-			init_msc_irqs (MSC01C_INT_BASE,
+			init_msc_irqs (MSC01E_INT_BASE, MSC01C_INT_BASE,
 				       msc_irqmap, msc_nr_irqs);
 	}
 
-
 	if (cpu_has_veic) {
 		set_vi_handler (MSC01E_INT_ATLAS, atlas_hw0_irqdispatch);
 		setup_irq (MSC01E_INT_BASE + MSC01E_INT_ATLAS, &atlasirq);
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/mips-boards/generic/time.c linux-2.6.22-rc4-git6/arch/mips/mips-boards/generic/time.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/mips-boards/generic/time.c	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/mips-boards/generic/time.c	2007-06-14 14:14:33.000000000 -0400
@@ -88,8 +88,6 @@ irqreturn_t mips_timer_interrupt(int irq
 	 *  the general MIPS timer_interrupt routine.
 	 */
 
-	int vpflags;
-
 	/*
 	 * We could be here due to timer interrupt,
 	 * perf counter overflow, or both.
@@ -98,15 +96,6 @@ irqreturn_t mips_timer_interrupt(int irq
 		perf_irq();
 
 	if (read_c0_cause() & (1 << 30)) {
-		/* If timer interrupt, make it de-assert */
-		write_c0_compare (read_c0_count() - 1);
-		/*
-		 * DVPE is necessary so long as cross-VPE interrupts
-		 * are done via read-modify-write of Cause register.
-		 */
-		vpflags = dvpe();
-		clear_c0_cause(CPUCTR_IMASKBIT);
-		evpe(vpflags);
 		/*
 		 * There are things we only want to do once per tick
 		 * in an "MP" system.   One TC of each VPE will take
@@ -115,14 +104,13 @@ irqreturn_t mips_timer_interrupt(int irq
 		 * the tick on VPE 0 to run the full timer_interrupt().
 		 */
 		if (cpu_data[cpu].vpe_id == 0) {
-				timer_interrupt(irq, NULL);
-				smtc_timer_broadcast(cpu_data[cpu].vpe_id);
+			timer_interrupt(irq, NULL);
 		} else {
 			write_c0_compare(read_c0_count() +
 			                 (mips_hpt_frequency/HZ));
 			local_timer_interrupt(irq, dev_id);
-			smtc_timer_broadcast(cpu_data[cpu].vpe_id);
 		}
+		smtc_timer_broadcast(cpu_data[cpu].vpe_id);
 	}
 #else /* CONFIG_MIPS_MT_SMTC */
 	int r2 = cpu_has_mips_r2;
diff -ruNp linux-2.6.22-rc4-git3.orig/arch/mips/sgi-ip27/ip27-memory.c linux-2.6.22-rc4-git6/arch/mips/sgi-ip27/ip27-memory.c
--- linux-2.6.22-rc4-git3.orig/arch/mips/sgi-ip27/ip27-memory.c	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/arch/mips/sgi-ip27/ip27-memory.c	2007-06-14 14:14:33.000000000 -0400
@@ -517,7 +517,7 @@ void __init paging_init(void)
 		pfn_t start_pfn = slot_getbasepfn(node, 0);
 		pfn_t end_pfn = node_getmaxclick(node) + 1;
 
-		zones_size[ZONE_DMA] = end_pfn - start_pfn;
+		zones_size[ZONE_NORMAL] = end_pfn - start_pfn;
 		free_area_init_node(node, NODE_DATA(node),
 				zones_size, start_pfn, NULL);
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ata/ahci.c linux-2.6.22-rc4-git6/drivers/ata/ahci.c
--- linux-2.6.22-rc4-git3.orig/drivers/ata/ahci.c	2007-06-08 12:08:19.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ata/ahci.c	2007-06-14 14:14:33.000000000 -0400
@@ -426,6 +426,30 @@ static const struct pci_device_id ahci_p
 	{ PCI_VDEVICE(NVIDIA, 0x0559), board_ahci },		/* MCP67 */
 	{ PCI_VDEVICE(NVIDIA, 0x055a), board_ahci },		/* MCP67 */
 	{ PCI_VDEVICE(NVIDIA, 0x055b), board_ahci },		/* MCP67 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f0), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f1), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f2), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f3), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f4), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f5), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f6), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f7), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f8), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07f9), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07fa), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x07fb), board_ahci },		/* MCP73 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad0), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad1), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad2), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad3), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad4), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad5), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad6), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad7), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad8), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ad9), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0ada), board_ahci },		/* MCP77 */
+	{ PCI_VDEVICE(NVIDIA, 0x0adb), board_ahci },		/* MCP77 */
 
 	/* SiS */
 	{ PCI_VDEVICE(SI, 0x1184), board_ahci }, /* SiS 966 */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ata/libata-core.c linux-2.6.22-rc4-git6/drivers/ata/libata-core.c
--- linux-2.6.22-rc4-git3.orig/drivers/ata/libata-core.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ata/libata-core.c	2007-06-14 14:14:33.000000000 -0400
@@ -1727,7 +1727,7 @@ int ata_dev_read_id(struct ata_device *d
 
 	/* sanity check */
 	rc = -EINVAL;
-	reason = "device reports illegal type";
+	reason = "device reports invalid type";
 
 	if (class == ATA_DEV_ATA) {
 		if (!ata_id_is_ata(id) && !ata_id_is_cfa(id))
@@ -1900,6 +1900,13 @@ int ata_dev_configure(struct ata_device 
 	if (ata_msg_probe(ap))
 		ata_dump_id(id);
 
+	/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */
+	ata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,
+			sizeof(fwrevbuf));
+
+	ata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,
+			sizeof(modelbuf));
+
 	/* ATA-specific feature tests */
 	if (dev->class == ATA_DEV_ATA) {
 		if (ata_id_is_cfa(id)) {
@@ -1914,13 +1921,6 @@ int ata_dev_configure(struct ata_device 
 
 		dev->n_sectors = ata_id_n_sectors(id);
 
-		/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */
-		ata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,
-				sizeof(fwrevbuf));
-
-		ata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,
-				sizeof(modelbuf));
-
 		if (dev->id[59] & 0x100)
 			dev->multi_count = dev->id[59] & 0xff;
 
@@ -2009,7 +2009,9 @@ int ata_dev_configure(struct ata_device 
 
 		/* print device info to dmesg */
 		if (ata_msg_drv(ap) && print_info)
-			ata_dev_printk(dev, KERN_INFO, "ATAPI, max %s%s\n",
+			ata_dev_printk(dev, KERN_INFO,
+				       "ATAPI: %s, %s, max %s%s\n",
+				       modelbuf, fwrevbuf,
 				       ata_mode_string(xfer_mask),
 				       cdb_intr_string);
 	}
@@ -3059,22 +3061,28 @@ static int ata_bus_post_reset(struct ata
 		}
 	}
 
-	/* if device 1 was found in ata_devchk, wait for
-	 * register access, then wait for BSY to clear
+	/* if device 1 was found in ata_devchk, wait for register
+	 * access briefly, then wait for BSY to clear.
 	 */
-	while (dev1) {
-		u8 nsect, lbal;
+	if (dev1) {
+		int i;
 
 		ap->ops->dev_select(ap, 1);
-		nsect = ioread8(ioaddr->nsect_addr);
-		lbal = ioread8(ioaddr->lbal_addr);
-		if ((nsect == 1) && (lbal == 1))
-			break;
-		if (time_after(jiffies, deadline))
-			return -EBUSY;
-		msleep(50);	/* give drive a breather */
-	}
-	if (dev1) {
+
+		/* Wait for register access.  Some ATAPI devices fail
+		 * to set nsect/lbal after reset, so don't waste too
+		 * much time on it.  We're gonna wait for !BSY anyway.
+		 */
+		for (i = 0; i < 2; i++) {
+			u8 nsect, lbal;
+
+			nsect = ioread8(ioaddr->nsect_addr);
+			lbal = ioread8(ioaddr->lbal_addr);
+			if ((nsect == 1) && (lbal == 1))
+				break;
+			msleep(50);	/* give drive a breather */
+		}
+
 		rc = ata_wait_ready(ap, deadline);
 		if (rc) {
 			if (rc != -ENODEV)
@@ -3769,6 +3777,7 @@ static const struct ata_blacklist_entry 
 	{ "_NEC DV5800A", 	NULL,		ATA_HORKAGE_NODMA },
 	{ "SAMSUNG CD-ROM SN-124","N001",	ATA_HORKAGE_NODMA },
 	{ "Seagate STT20000A", NULL,		ATA_HORKAGE_NODMA },
+	{ "IOMEGA  ZIP 250       ATAPI", NULL,	ATA_HORKAGE_NODMA }, /* temporary fix */
 
 	/* Weird ATAPI devices */
 	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 |
@@ -3791,6 +3800,8 @@ static const struct ata_blacklist_entry 
 	{ "HTS541060G9SA00",    "MB3OC60D",     ATA_HORKAGE_NONCQ, },
 	{ "HTS541080G9SA00",    "MB4OC60D",     ATA_HORKAGE_NONCQ, },
 	{ "HTS541010G9SA00",    "MBZOC60D",     ATA_HORKAGE_NONCQ, },
+	/* Drives which do spurious command completion */
+	{ "HTS541680J9SA00",	"SB2IC7EP",	ATA_HORKAGE_NONCQ, },
 
 	/* Devices with NCQ limits */
 
@@ -6313,7 +6324,8 @@ int ata_host_register(struct ata_host *h
 		/* init sata_spd_limit to the current value */
 		if (sata_scr_read(ap, SCR_CONTROL, &scontrol) == 0) {
 			int spd = (scontrol >> 4) & 0xf;
-			ap->hw_sata_spd_limit &= (1 << spd) - 1;
+			if (spd)
+				ap->hw_sata_spd_limit &= (1 << spd) - 1;
 		}
 		ap->sata_spd_limit = ap->hw_sata_spd_limit;
 
@@ -6433,6 +6445,9 @@ int ata_host_activate(struct ata_host *h
 	if (rc)
 		devm_free_irq(host->dev, irq, host);
 
+	/* Used to print device info at probe */
+	host->irq = irq;
+
 	return rc;
 }
 
@@ -6818,6 +6833,7 @@ EXPORT_SYMBOL_GPL(ata_check_status);
 EXPORT_SYMBOL_GPL(ata_altstatus);
 EXPORT_SYMBOL_GPL(ata_exec_command);
 EXPORT_SYMBOL_GPL(ata_port_start);
+EXPORT_SYMBOL_GPL(ata_sff_port_start);
 EXPORT_SYMBOL_GPL(ata_interrupt);
 EXPORT_SYMBOL_GPL(ata_do_set_mode);
 EXPORT_SYMBOL_GPL(ata_data_xfer);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ata/libata-scsi.c linux-2.6.22-rc4-git6/drivers/ata/libata-scsi.c
--- linux-2.6.22-rc4-git3.orig/drivers/ata/libata-scsi.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ata/libata-scsi.c	2007-06-14 14:14:33.000000000 -0400
@@ -1363,12 +1363,22 @@ static void ata_scsi_qc_complete(struct 
 	 * schedule EH_REVALIDATE operation to update the IDENTIFY DEVICE
 	 * cache
 	 */
-	if (ap->ops->error_handler &&
-	    !need_sense && (qc->tf.command == ATA_CMD_SET_FEATURES) &&
-	    ((qc->tf.feature == SETFEATURES_WC_ON) ||
-	     (qc->tf.feature == SETFEATURES_WC_OFF))) {
-		ap->eh_info.action |= ATA_EH_REVALIDATE;
-		ata_port_schedule_eh(ap);
+	if (ap->ops->error_handler && !need_sense) {
+		switch (qc->tf.command) {
+		case ATA_CMD_SET_FEATURES:
+			if ((qc->tf.feature == SETFEATURES_WC_ON) ||
+			    (qc->tf.feature == SETFEATURES_WC_OFF)) {
+				ap->eh_info.action |= ATA_EH_REVALIDATE;
+				ata_port_schedule_eh(ap);
+			}
+			break;
+
+		case ATA_CMD_INIT_DEV_PARAMS: /* CHS translation changed */
+		case ATA_CMD_SET_MULTI: /* multi_count changed */
+			ap->eh_info.action |= ATA_EH_REVALIDATE;
+			ata_port_schedule_eh(ap);
+			break;
+		}
 	}
 
 	/* For ATA pass thru (SAT) commands, generate a sense block if
@@ -2506,22 +2516,21 @@ ata_scsi_map_proto(u8 byte1)
 			return ATA_PROT_NODATA;
 
 		case 6:		/* DMA */
+		case 10:	/* UDMA Data-in */
+		case 11:	/* UDMA Data-Out */
 			return ATA_PROT_DMA;
 
 		case 4:		/* PIO Data-in */
 		case 5:		/* PIO Data-out */
 			return ATA_PROT_PIO;
 
-		case 10:	/* Device Reset */
 		case 0:		/* Hard Reset */
 		case 1:		/* SRST */
-		case 2:		/* Bus Idle */
-		case 7:		/* Packet */
-		case 8:		/* DMA Queued */
-		case 9:		/* Device Diagnostic */
-		case 11:	/* UDMA Data-in */
-		case 12:	/* UDMA Data-Out */
-		case 13:	/* FPDMA */
+		case 8:		/* Device Diagnostic */
+		case 9:		/* Device Reset */
+		case 7:		/* DMA Queued */
+		case 12:	/* FPDMA */
+		case 15:	/* Return Response Info */
 		default:	/* Reserved */
 			break;
 	}
@@ -2552,10 +2561,6 @@ static unsigned int ata_scsi_pass_thru(s
 	if (tf->protocol == ATA_PROT_DMA && dev->dma_mode == 0)
 		goto invalid_fld;
 
-	if (cdb[1] & 0xe0)
-		/* PIO multi not supported yet */
-		goto invalid_fld;
-
 	/*
 	 * 12 and 16 byte CDBs use different offsets to
 	 * provide the various register values.
@@ -2600,12 +2605,26 @@ static unsigned int ata_scsi_pass_thru(s
 		tf->device = cdb[8];
 		tf->command = cdb[9];
 	}
-	/*
-	 * If slave is possible, enforce correct master/slave bit
-	*/
-	if (qc->ap->flags & ATA_FLAG_SLAVE_POSS)
-		tf->device = qc->dev->devno ?
-			tf->device | ATA_DEV1 : tf->device & ~ATA_DEV1;
+
+	/* enforce correct master/slave bit */
+	tf->device = dev->devno ?
+		tf->device | ATA_DEV1 : tf->device & ~ATA_DEV1;
+
+	/* sanity check for pio multi commands */
+	if ((cdb[1] & 0xe0) && !is_multi_taskfile(tf))
+		goto invalid_fld;
+
+	if (is_multi_taskfile(tf)) {
+		unsigned int multi_count = 1 << (cdb[1] >> 5);
+
+		/* compare the passed through multi_count
+		 * with the cached multi_count of libata
+		 */
+		if (multi_count != dev->multi_count)
+			ata_dev_printk(dev, KERN_WARNING,
+				       "invalid multi_count %u ignored\n",
+				       multi_count);
+	}	
 
 	/* READ/WRITE LONG use a non-standard sect_size */
 	qc->sect_size = ATA_SECT_SIZE;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ata/libata-sff.c linux-2.6.22-rc4-git6/drivers/ata/libata-sff.c
--- linux-2.6.22-rc4-git3.orig/drivers/ata/libata-sff.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ata/libata-sff.c	2007-06-14 14:14:33.000000000 -0400
@@ -80,25 +80,25 @@ u8 ata_dummy_irq_on (struct ata_port *ap
 u8 ata_irq_ack(struct ata_port *ap, unsigned int chk_drq)
 {
 	unsigned int bits = chk_drq ? ATA_BUSY | ATA_DRQ : ATA_BUSY;
-	u8 host_stat, post_stat, status;
+	u8 host_stat = 0, post_stat = 0, status;
 
 	status = ata_busy_wait(ap, bits, 1000);
 	if (status & bits)
 		if (ata_msg_err(ap))
 			printk(KERN_ERR "abnormal status 0x%X\n", status);
 
-	/* get controller status; clear intr, err bits */
-	host_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-	iowrite8(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
-		 ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
-
-	post_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	if (ap->ioaddr.bmdma_addr) {
+		/* get controller status; clear intr, err bits */
+		host_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+		iowrite8(host_stat | ATA_DMA_INTR | ATA_DMA_ERR,
+			 ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
+		post_stat = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
 	if (ata_msg_intr(ap))
 		printk(KERN_INFO "%s: irq ack: host_stat 0x%X, new host_stat 0x%X, drv_stat 0x%X\n",
 			__FUNCTION__,
 			host_stat, post_stat, status);
-
 	return status;
 }
 
@@ -516,6 +516,27 @@ void ata_bmdma_post_internal_cmd(struct 
 		ata_bmdma_stop(qc);
 }
 
+/**
+ *	ata_sff_port_start - Set port up for dma.
+ *	@ap: Port to initialize
+ *
+ *	Called just after data structures for each port are
+ *	initialized.  Allocates space for PRD table if the device
+ *	is DMA capable SFF.
+ *
+ *	May be used as the port_start() entry in ata_port_operations.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+
+int ata_sff_port_start(struct ata_port *ap)
+{
+	if (ap->ioaddr.bmdma_addr)
+		return ata_port_start(ap);
+	return 0;
+}
+
 #ifdef CONFIG_PCI
 
 static int ata_resources_present(struct pci_dev *pdev, int port)
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ata/pata_isapnp.c linux-2.6.22-rc4-git6/drivers/ata/pata_isapnp.c
--- linux-2.6.22-rc4-git3.orig/drivers/ata/pata_isapnp.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ata/pata_isapnp.c	2007-06-14 14:14:33.000000000 -0400
@@ -77,7 +77,6 @@ static int isapnp_init_one(struct pnp_de
 	struct ata_host *host;
 	struct ata_port *ap;
 	void __iomem *cmd_addr, *ctl_addr;
-	int rc;
 
 	if (pnp_port_valid(idev, 0) == 0)
 		return -ENODEV;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/char/agp/agp.h linux-2.6.22-rc4-git6/drivers/char/agp/agp.h
--- linux-2.6.22-rc4-git3.orig/drivers/char/agp/agp.h	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/char/agp/agp.h	2007-06-14 14:14:33.000000000 -0400
@@ -176,7 +176,7 @@ struct agp_bridge_data {
 #define I830_GMCH_MEM_MASK		0x1
 #define I830_GMCH_MEM_64M		0x1
 #define I830_GMCH_MEM_128M		0
-#define I830_GMCH_GMS_MASK		0x70
+#define I830_GMCH_GMS_MASK		0xF0
 #define I830_GMCH_GMS_DISABLED		0x00
 #define I830_GMCH_GMS_LOCAL		0x10
 #define I830_GMCH_GMS_STOLEN_512	0x20
@@ -231,6 +231,10 @@ struct agp_bridge_data {
 #define I965_PGETBL_SIZE_512KB	(0 << 1)
 #define I965_PGETBL_SIZE_256KB	(1 << 1)
 #define I965_PGETBL_SIZE_128KB	(2 << 1)
+#define G33_PGETBL_SIZE_MASK    (3 << 8)
+#define G33_PGETBL_SIZE_1M      (1 << 8)
+#define G33_PGETBL_SIZE_2M      (2 << 8)
+
 #define I810_DRAM_CTL		0x3000
 #define I810_DRAM_ROW_0		0x00000001
 #define I810_DRAM_ROW_0_SDRAM	0x00000001
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/char/agp/intel-agp.c linux-2.6.22-rc4-git6/drivers/char/agp/intel-agp.c
--- linux-2.6.22-rc4-git3.orig/drivers/char/agp/intel-agp.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/char/agp/intel-agp.c	2007-06-14 14:14:33.000000000 -0400
@@ -20,6 +20,14 @@
 #define PCI_DEVICE_ID_INTEL_82965G_IG       0x29A2
 #define PCI_DEVICE_ID_INTEL_82965GM_HB      0x2A00
 #define PCI_DEVICE_ID_INTEL_82965GM_IG      0x2A02
+#define PCI_DEVICE_ID_INTEL_82965GME_IG     0x2A12
+#define PCI_DEVICE_ID_INTEL_82945GME_IG     0x27AE
+#define PCI_DEVICE_ID_INTEL_G33_HB          0x29C0
+#define PCI_DEVICE_ID_INTEL_G33_IG          0x29C2
+#define PCI_DEVICE_ID_INTEL_Q35_HB          0x29B0
+#define PCI_DEVICE_ID_INTEL_Q35_IG          0x29B2
+#define PCI_DEVICE_ID_INTEL_Q33_HB          0x29D0
+#define PCI_DEVICE_ID_INTEL_Q33_IG          0x29D2
 
 #define IS_I965 (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82946GZ_HB || \
                  agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965G_1_HB || \
@@ -27,6 +35,9 @@
                  agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965G_HB || \
                  agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82965GM_HB)
 
+#define IS_G33 (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_G33_HB || \
+		agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_Q35_HB || \
+		agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_Q33_HB)
 
 extern int agp_memory_reserved;
 
@@ -53,6 +64,8 @@ extern int agp_memory_reserved;
 #define I915_PTEADDR	0x1C
 #define I915_GMCH_GMS_STOLEN_48M	(0x6 << 4)
 #define I915_GMCH_GMS_STOLEN_64M	(0x7 << 4)
+#define G33_GMCH_GMS_STOLEN_128M       (0x8 << 4)
+#define G33_GMCH_GMS_STOLEN_256M       (0x9 << 4)
 
 /* Intel 965G registers */
 #define I965_MSAC 0x62
@@ -86,11 +99,18 @@ static struct gatt_mask intel_i810_masks
 	 .type = INTEL_AGP_CACHED_MEMORY}
 };
 
-static struct _intel_i810_private {
-	struct pci_dev *i810_dev;	/* device one */
-	volatile u8 __iomem *registers;
+static struct _intel_private {
+	struct pci_dev *pcidev;	/* device one */
+	u8 __iomem *registers;
+	u32 __iomem *gtt;		/* I915G */
 	int num_dcache_entries;
-} intel_i810_private;
+	/* gtt_entries is the number of gtt entries that are already mapped
+	 * to stolen memory.  Stolen memory is larger than the memory mapped
+	 * through gtt_entries, as it includes some reserved space for the BIOS
+	 * popup and for the GTT.
+	 */
+	int gtt_entries;			/* i830+ */
+} intel_private;
 
 static int intel_i810_fetch_size(void)
 {
@@ -127,32 +147,32 @@ static int intel_i810_configure(void)
 
 	current_size = A_SIZE_FIX(agp_bridge->current_size);
 
-	if (!intel_i810_private.registers) {
-		pci_read_config_dword(intel_i810_private.i810_dev, I810_MMADDR, &temp);
+	if (!intel_private.registers) {
+		pci_read_config_dword(intel_private.pcidev, I810_MMADDR, &temp);
 		temp &= 0xfff80000;
 
-		intel_i810_private.registers = ioremap(temp, 128 * 4096);
-		if (!intel_i810_private.registers) {
+		intel_private.registers = ioremap(temp, 128 * 4096);
+		if (!intel_private.registers) {
 			printk(KERN_ERR PFX "Unable to remap memory.\n");
 			return -ENOMEM;
 		}
 	}
 
-	if ((readl(intel_i810_private.registers+I810_DRAM_CTL)
+	if ((readl(intel_private.registers+I810_DRAM_CTL)
 		& I810_DRAM_ROW_0) == I810_DRAM_ROW_0_SDRAM) {
 		/* This will need to be dynamically assigned */
 		printk(KERN_INFO PFX "detected 4MB dedicated video ram.\n");
-		intel_i810_private.num_dcache_entries = 1024;
+		intel_private.num_dcache_entries = 1024;
 	}
-	pci_read_config_dword(intel_i810_private.i810_dev, I810_GMADDR, &temp);
+	pci_read_config_dword(intel_private.pcidev, I810_GMADDR, &temp);
 	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
-	writel(agp_bridge->gatt_bus_addr | I810_PGETBL_ENABLED, intel_i810_private.registers+I810_PGETBL_CTL);
-	readl(intel_i810_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
+	writel(agp_bridge->gatt_bus_addr | I810_PGETBL_ENABLED, intel_private.registers+I810_PGETBL_CTL);
+	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
 
 	if (agp_bridge->driver->needs_scratch_page) {
 		for (i = 0; i < current_size->num_entries; i++) {
-			writel(agp_bridge->scratch_page, intel_i810_private.registers+I810_PTE_BASE+(i*4));
-			readl(intel_i810_private.registers+I810_PTE_BASE+(i*4));	/* PCI posting. */
+			writel(agp_bridge->scratch_page, intel_private.registers+I810_PTE_BASE+(i*4));
+			readl(intel_private.registers+I810_PTE_BASE+(i*4));	/* PCI posting. */
 		}
 	}
 	global_cache_flush();
@@ -161,9 +181,9 @@ static int intel_i810_configure(void)
 
 static void intel_i810_cleanup(void)
 {
-	writel(0, intel_i810_private.registers+I810_PGETBL_CTL);
-	readl(intel_i810_private.registers);	/* PCI Posting. */
-	iounmap(intel_i810_private.registers);
+	writel(0, intel_private.registers+I810_PGETBL_CTL);
+	readl(intel_private.registers);	/* PCI Posting. */
+	iounmap(intel_private.registers);
 }
 
 static void intel_i810_tlbflush(struct agp_memory *mem)
@@ -261,9 +281,9 @@ static int intel_i810_insert_entries(str
 			global_cache_flush();
 		for (i = pg_start; i < (pg_start + mem->page_count); i++) {
 			writel((i*4096)|I810_PTE_LOCAL|I810_PTE_VALID,
-			       intel_i810_private.registers+I810_PTE_BASE+(i*4));
+			       intel_private.registers+I810_PTE_BASE+(i*4));
 		}
-		readl(intel_i810_private.registers+I810_PTE_BASE+((i-1)*4));
+		readl(intel_private.registers+I810_PTE_BASE+((i-1)*4));
 		break;
 	case AGP_PHYS_MEMORY:
 	case AGP_NORMAL_MEMORY:
@@ -273,9 +293,9 @@ static int intel_i810_insert_entries(str
 			writel(agp_bridge->driver->mask_memory(agp_bridge,
 							       mem->memory[i],
 							       mask_type),
-			       intel_i810_private.registers+I810_PTE_BASE+(j*4));
+			       intel_private.registers+I810_PTE_BASE+(j*4));
 		}
-		readl(intel_i810_private.registers+I810_PTE_BASE+((j-1)*4));
+		readl(intel_private.registers+I810_PTE_BASE+((j-1)*4));
 		break;
 	default:
 		goto out_err;
@@ -298,9 +318,9 @@ static int intel_i810_remove_entries(str
 		return 0;
 
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
-		writel(agp_bridge->scratch_page, intel_i810_private.registers+I810_PTE_BASE+(i*4));
+		writel(agp_bridge->scratch_page, intel_private.registers+I810_PTE_BASE+(i*4));
 	}
-	readl(intel_i810_private.registers+I810_PTE_BASE+((i-1)*4));
+	readl(intel_private.registers+I810_PTE_BASE+((i-1)*4));
 
 	agp_bridge->driver->tlb_flush(mem);
 	return 0;
@@ -354,7 +374,7 @@ static struct agp_memory *intel_i810_all
 	struct agp_memory *new;
 
 	if (type == AGP_DCACHE_MEMORY) {
-		if (pg_count != intel_i810_private.num_dcache_entries)
+		if (pg_count != intel_private.num_dcache_entries)
 			return NULL;
 
 		new = agp_create_memory(1);
@@ -404,18 +424,6 @@ static struct aper_size_info_fixed intel
 	{512, 131072, 7},
 };
 
-static struct _intel_i830_private {
-	struct pci_dev *i830_dev;		/* device one */
-	volatile u8 __iomem *registers;
-	volatile u32 __iomem *gtt;		/* I915G */
-	/* gtt_entries is the number of gtt entries that are already mapped
-	 * to stolen memory.  Stolen memory is larger than the memory mapped
-	 * through gtt_entries, as it includes some reserved space for the BIOS
-	 * popup and for the GTT.
-	 */
-	int gtt_entries;
-} intel_i830_private;
-
 static void intel_i830_init_gtt_entries(void)
 {
 	u16 gmch_ctrl;
@@ -429,7 +437,7 @@ static void intel_i830_init_gtt_entries(
 
 	if (IS_I965) {
 		u32 pgetbl_ctl;
-		pgetbl_ctl = readl(intel_i830_private.registers+I810_PGETBL_CTL);
+		pgetbl_ctl = readl(intel_private.registers+I810_PGETBL_CTL);
 
 		/* The 965 has a field telling us the size of the GTT,
 		 * which may be larger than what is necessary to map the
@@ -451,6 +459,22 @@ static void intel_i830_init_gtt_entries(
 			size = 512;
 		}
 		size += 4; /* add in BIOS popup space */
+	} else if (IS_G33) {
+	/* G33's GTT size defined in gmch_ctrl */
+		switch (gmch_ctrl & G33_PGETBL_SIZE_MASK) {
+		case G33_PGETBL_SIZE_1M:
+			size = 1024;
+			break;
+		case G33_PGETBL_SIZE_2M:
+			size = 2048;
+			break;
+		default:
+			printk(KERN_INFO PFX "Unknown page table size 0x%x, "
+				"assuming 512KB\n",
+				(gmch_ctrl & G33_PGETBL_SIZE_MASK));
+			size = 512;
+		}
+		size += 4;
 	} else {
 		/* On previous hardware, the GTT size was just what was
 		 * required to map the aperture.
@@ -471,7 +495,7 @@ static void intel_i830_init_gtt_entries(
 			gtt_entries = MB(8) - KB(size);
 			break;
 		case I830_GMCH_GMS_LOCAL:
-			rdct = readb(intel_i830_private.registers+I830_RDRAM_CHANNEL_TYPE);
+			rdct = readb(intel_private.registers+I830_RDRAM_CHANNEL_TYPE);
 			gtt_entries = (I830_RDRAM_ND(rdct) + 1) *
 					MB(ddt[I830_RDRAM_DDT(rdct)]);
 			local = 1;
@@ -502,7 +526,8 @@ static void intel_i830_init_gtt_entries(
 			if (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82915G_HB ||
 			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82915GM_HB ||
 			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945G_HB ||
-			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945GM_HB || IS_I965 )
+			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945GM_HB ||
+			    IS_I965 || IS_G33)
 				gtt_entries = MB(48) - KB(size);
 			else
 				gtt_entries = 0;
@@ -512,10 +537,24 @@ static void intel_i830_init_gtt_entries(
 			if (agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82915G_HB ||
 			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82915GM_HB ||
 			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945G_HB ||
-			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945GM_HB || IS_I965)
+			    agp_bridge->dev->device == PCI_DEVICE_ID_INTEL_82945GM_HB ||
+			    IS_I965 || IS_G33)
 				gtt_entries = MB(64) - KB(size);
 			else
 				gtt_entries = 0;
+			break;
+		case G33_GMCH_GMS_STOLEN_128M:
+			if (IS_G33)
+				gtt_entries = MB(128) - KB(size);
+			else
+				gtt_entries = 0;
+			break;
+		case G33_GMCH_GMS_STOLEN_256M:
+			if (IS_G33)
+				gtt_entries = MB(256) - KB(size);
+			else
+				gtt_entries = 0;
+			break;
 		default:
 			gtt_entries = 0;
 			break;
@@ -529,7 +568,7 @@ static void intel_i830_init_gtt_entries(
 		       "No pre-allocated video memory detected.\n");
 	gtt_entries /= KB(4);
 
-	intel_i830_private.gtt_entries = gtt_entries;
+	intel_private.gtt_entries = gtt_entries;
 }
 
 /* The intel i830 automatically initializes the agp aperture during POST.
@@ -547,14 +586,14 @@ static int intel_i830_create_gatt_table(
 	num_entries = size->num_entries;
 	agp_bridge->gatt_table_real = NULL;
 
-	pci_read_config_dword(intel_i830_private.i830_dev,I810_MMADDR,&temp);
+	pci_read_config_dword(intel_private.pcidev,I810_MMADDR,&temp);
 	temp &= 0xfff80000;
 
-	intel_i830_private.registers = ioremap(temp,128 * 4096);
-	if (!intel_i830_private.registers)
+	intel_private.registers = ioremap(temp,128 * 4096);
+	if (!intel_private.registers)
 		return -ENOMEM;
 
-	temp = readl(intel_i830_private.registers+I810_PGETBL_CTL) & 0xfffff000;
+	temp = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
 	global_cache_flush();	/* FIXME: ?? */
 
 	/* we have to call this as early as possible after the MMIO base address is known */
@@ -614,20 +653,20 @@ static int intel_i830_configure(void)
 
 	current_size = A_SIZE_FIX(agp_bridge->current_size);
 
-	pci_read_config_dword(intel_i830_private.i830_dev,I810_GMADDR,&temp);
+	pci_read_config_dword(intel_private.pcidev,I810_GMADDR,&temp);
 	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
 
 	pci_read_config_word(agp_bridge->dev,I830_GMCH_CTRL,&gmch_ctrl);
 	gmch_ctrl |= I830_GMCH_ENABLED;
 	pci_write_config_word(agp_bridge->dev,I830_GMCH_CTRL,gmch_ctrl);
 
-	writel(agp_bridge->gatt_bus_addr|I810_PGETBL_ENABLED, intel_i830_private.registers+I810_PGETBL_CTL);
-	readl(intel_i830_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
+	writel(agp_bridge->gatt_bus_addr|I810_PGETBL_ENABLED, intel_private.registers+I810_PGETBL_CTL);
+	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
 
 	if (agp_bridge->driver->needs_scratch_page) {
-		for (i = intel_i830_private.gtt_entries; i < current_size->num_entries; i++) {
-			writel(agp_bridge->scratch_page, intel_i830_private.registers+I810_PTE_BASE+(i*4));
-			readl(intel_i830_private.registers+I810_PTE_BASE+(i*4));	/* PCI Posting. */
+		for (i = intel_private.gtt_entries; i < current_size->num_entries; i++) {
+			writel(agp_bridge->scratch_page, intel_private.registers+I810_PTE_BASE+(i*4));
+			readl(intel_private.registers+I810_PTE_BASE+(i*4));	/* PCI Posting. */
 		}
 	}
 
@@ -637,7 +676,7 @@ static int intel_i830_configure(void)
 
 static void intel_i830_cleanup(void)
 {
-	iounmap(intel_i830_private.registers);
+	iounmap(intel_private.registers);
 }
 
 static int intel_i830_insert_entries(struct agp_memory *mem,off_t pg_start, int type)
@@ -653,9 +692,9 @@ static int intel_i830_insert_entries(str
 	temp = agp_bridge->current_size;
 	num_entries = A_SIZE_FIX(temp)->num_entries;
 
-	if (pg_start < intel_i830_private.gtt_entries) {
-		printk (KERN_DEBUG PFX "pg_start == 0x%.8lx,intel_i830_private.gtt_entries == 0x%.8x\n",
-				pg_start,intel_i830_private.gtt_entries);
+	if (pg_start < intel_private.gtt_entries) {
+		printk (KERN_DEBUG PFX "pg_start == 0x%.8lx,intel_private.gtt_entries == 0x%.8x\n",
+				pg_start,intel_private.gtt_entries);
 
 		printk (KERN_INFO PFX "Trying to insert into local/stolen memory\n");
 		goto out_err;
@@ -683,9 +722,9 @@ static int intel_i830_insert_entries(str
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		writel(agp_bridge->driver->mask_memory(agp_bridge,
 						       mem->memory[i], mask_type),
-		       intel_i830_private.registers+I810_PTE_BASE+(j*4));
+		       intel_private.registers+I810_PTE_BASE+(j*4));
 	}
-	readl(intel_i830_private.registers+I810_PTE_BASE+((j-1)*4));
+	readl(intel_private.registers+I810_PTE_BASE+((j-1)*4));
 	agp_bridge->driver->tlb_flush(mem);
 
 out:
@@ -703,15 +742,15 @@ static int intel_i830_remove_entries(str
 	if (mem->page_count == 0)
 		return 0;
 
-	if (pg_start < intel_i830_private.gtt_entries) {
+	if (pg_start < intel_private.gtt_entries) {
 		printk (KERN_INFO PFX "Trying to disable local/stolen memory\n");
 		return -EINVAL;
 	}
 
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
-		writel(agp_bridge->scratch_page, intel_i830_private.registers+I810_PTE_BASE+(i*4));
+		writel(agp_bridge->scratch_page, intel_private.registers+I810_PTE_BASE+(i*4));
 	}
-	readl(intel_i830_private.registers+I810_PTE_BASE+((i-1)*4));
+	readl(intel_private.registers+I810_PTE_BASE+((i-1)*4));
 
 	agp_bridge->driver->tlb_flush(mem);
 	return 0;
@@ -734,7 +773,7 @@ static int intel_i915_configure(void)
 
 	current_size = A_SIZE_FIX(agp_bridge->current_size);
 
-	pci_read_config_dword(intel_i830_private.i830_dev, I915_GMADDR, &temp);
+	pci_read_config_dword(intel_private.pcidev, I915_GMADDR, &temp);
 
 	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
 
@@ -742,13 +781,13 @@ static int intel_i915_configure(void)
 	gmch_ctrl |= I830_GMCH_ENABLED;
 	pci_write_config_word(agp_bridge->dev,I830_GMCH_CTRL,gmch_ctrl);
 
-	writel(agp_bridge->gatt_bus_addr|I810_PGETBL_ENABLED, intel_i830_private.registers+I810_PGETBL_CTL);
-	readl(intel_i830_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
+	writel(agp_bridge->gatt_bus_addr|I810_PGETBL_ENABLED, intel_private.registers+I810_PGETBL_CTL);
+	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
 
 	if (agp_bridge->driver->needs_scratch_page) {
-		for (i = intel_i830_private.gtt_entries; i < current_size->num_entries; i++) {
-			writel(agp_bridge->scratch_page, intel_i830_private.gtt+i);
-			readl(intel_i830_private.gtt+i);	/* PCI Posting. */
+		for (i = intel_private.gtt_entries; i < current_size->num_entries; i++) {
+			writel(agp_bridge->scratch_page, intel_private.gtt+i);
+			readl(intel_private.gtt+i);	/* PCI Posting. */
 		}
 	}
 
@@ -758,8 +797,8 @@ static int intel_i915_configure(void)
 
 static void intel_i915_cleanup(void)
 {
-	iounmap(intel_i830_private.gtt);
-	iounmap(intel_i830_private.registers);
+	iounmap(intel_private.gtt);
+	iounmap(intel_private.registers);
 }
 
 static int intel_i915_insert_entries(struct agp_memory *mem,off_t pg_start,
@@ -776,9 +815,9 @@ static int intel_i915_insert_entries(str
 	temp = agp_bridge->current_size;
 	num_entries = A_SIZE_FIX(temp)->num_entries;
 
-	if (pg_start < intel_i830_private.gtt_entries) {
-		printk (KERN_DEBUG PFX "pg_start == 0x%.8lx,intel_i830_private.gtt_entries == 0x%.8x\n",
-				pg_start,intel_i830_private.gtt_entries);
+	if (pg_start < intel_private.gtt_entries) {
+		printk (KERN_DEBUG PFX "pg_start == 0x%.8lx,intel_private.gtt_entries == 0x%.8x\n",
+				pg_start,intel_private.gtt_entries);
 
 		printk (KERN_INFO PFX "Trying to insert into local/stolen memory\n");
 		goto out_err;
@@ -805,10 +844,10 @@ static int intel_i915_insert_entries(str
 
 	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
 		writel(agp_bridge->driver->mask_memory(agp_bridge,
-			mem->memory[i], mask_type), intel_i830_private.gtt+j);
+			mem->memory[i], mask_type), intel_private.gtt+j);
 	}
 
-	readl(intel_i830_private.gtt+j-1);
+	readl(intel_private.gtt+j-1);
 	agp_bridge->driver->tlb_flush(mem);
 
  out:
@@ -826,15 +865,15 @@ static int intel_i915_remove_entries(str
 	if (mem->page_count == 0)
 		return 0;
 
-	if (pg_start < intel_i830_private.gtt_entries) {
+	if (pg_start < intel_private.gtt_entries) {
 		printk (KERN_INFO PFX "Trying to disable local/stolen memory\n");
 		return -EINVAL;
 	}
 
 	for (i = pg_start; i < (mem->page_count + pg_start); i++) {
-		writel(agp_bridge->scratch_page, intel_i830_private.gtt+i);
+		writel(agp_bridge->scratch_page, intel_private.gtt+i);
 	}
-	readl(intel_i830_private.gtt+i-1);
+	readl(intel_private.gtt+i-1);
 
 	agp_bridge->driver->tlb_flush(mem);
 	return 0;
@@ -850,7 +889,7 @@ static int intel_i9xx_fetch_size(void)
 	int aper_size; /* size in megabytes */
 	int i;
 
-	aper_size = pci_resource_len(intel_i830_private.i830_dev, 2) / MB(1);
+	aper_size = pci_resource_len(intel_private.pcidev, 2) / MB(1);
 
 	for (i = 0; i < num_sizes; i++) {
 		if (aper_size == intel_i830_sizes[i].size) {
@@ -878,20 +917,20 @@ static int intel_i915_create_gatt_table(
 	num_entries = size->num_entries;
 	agp_bridge->gatt_table_real = NULL;
 
-	pci_read_config_dword(intel_i830_private.i830_dev, I915_MMADDR, &temp);
-	pci_read_config_dword(intel_i830_private.i830_dev, I915_PTEADDR,&temp2);
+	pci_read_config_dword(intel_private.pcidev, I915_MMADDR, &temp);
+	pci_read_config_dword(intel_private.pcidev, I915_PTEADDR,&temp2);
 
-	intel_i830_private.gtt = ioremap(temp2, 256 * 1024);
-	if (!intel_i830_private.gtt)
+	intel_private.gtt = ioremap(temp2, 256 * 1024);
+	if (!intel_private.gtt)
 		return -ENOMEM;
 
 	temp &= 0xfff80000;
 
-	intel_i830_private.registers = ioremap(temp,128 * 4096);
-	if (!intel_i830_private.registers)
+	intel_private.registers = ioremap(temp,128 * 4096);
+	if (!intel_private.registers)
 		return -ENOMEM;
 
-	temp = readl(intel_i830_private.registers+I810_PGETBL_CTL) & 0xfffff000;
+	temp = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
 	global_cache_flush();	/* FIXME: ? */
 
 	/* we have to call this as early as possible after the MMIO base address is known */
@@ -938,20 +977,20 @@ static int intel_i965_create_gatt_table(
        num_entries = size->num_entries;
        agp_bridge->gatt_table_real = NULL;
 
-       pci_read_config_dword(intel_i830_private.i830_dev, I915_MMADDR, &temp);
+       pci_read_config_dword(intel_private.pcidev, I915_MMADDR, &temp);
 
        temp &= 0xfff00000;
-       intel_i830_private.gtt = ioremap((temp + (512 * 1024)) , 512 * 1024);
+       intel_private.gtt = ioremap((temp + (512 * 1024)) , 512 * 1024);
 
-       if (!intel_i830_private.gtt)
+       if (!intel_private.gtt)
                return -ENOMEM;
 
 
-       intel_i830_private.registers = ioremap(temp,128 * 4096);
-       if (!intel_i830_private.registers)
+       intel_private.registers = ioremap(temp,128 * 4096);
+       if (!intel_private.registers)
                return -ENOMEM;
 
-       temp = readl(intel_i830_private.registers+I810_PGETBL_CTL) & 0xfffff000;
+       temp = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
        global_cache_flush();   /* FIXME: ? */
 
        /* we have to call this as early as possible after the MMIO base address is known */
@@ -1722,41 +1761,126 @@ static const struct agp_bridge_driver in
 	.agp_type_to_mask_type  = agp_generic_type_to_mask_type,
 };
 
-static int find_i810(u16 device)
-{
-	struct pci_dev *i810_dev;
-
-	i810_dev = pci_get_device(PCI_VENDOR_ID_INTEL, device, NULL);
-	if (!i810_dev)
-		return 0;
-	intel_i810_private.i810_dev = i810_dev;
-	return 1;
-}
+static const struct agp_bridge_driver intel_g33_driver = {
+	.owner                  = THIS_MODULE,
+	.aperture_sizes         = intel_i830_sizes,
+	.size_type              = FIXED_APER_SIZE,
+	.num_aperture_sizes     = 4,
+	.needs_scratch_page     = TRUE,
+	.configure              = intel_i915_configure,
+	.fetch_size             = intel_i9xx_fetch_size,
+	.cleanup                = intel_i915_cleanup,
+	.tlb_flush              = intel_i810_tlbflush,
+	.mask_memory            = intel_i965_mask_memory,
+	.masks                  = intel_i810_masks,
+	.agp_enable             = intel_i810_agp_enable,
+	.cache_flush            = global_cache_flush,
+	.create_gatt_table      = intel_i915_create_gatt_table,
+	.free_gatt_table        = intel_i830_free_gatt_table,
+	.insert_memory          = intel_i915_insert_entries,
+	.remove_memory          = intel_i915_remove_entries,
+	.alloc_by_type          = intel_i830_alloc_by_type,
+	.free_by_type           = intel_i810_free_by_type,
+	.agp_alloc_page         = agp_generic_alloc_page,
+	.agp_destroy_page       = agp_generic_destroy_page,
+	.agp_type_to_mask_type  = intel_i830_type_to_mask_type,
+};
 
-static int find_i830(u16 device)
+static int find_gmch(u16 device)
 {
-	struct pci_dev *i830_dev;
+	struct pci_dev *gmch_device;
 
-	i830_dev = pci_get_device(PCI_VENDOR_ID_INTEL, device, NULL);
-	if (i830_dev && PCI_FUNC(i830_dev->devfn) != 0) {
-		i830_dev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				device, i830_dev);
+	gmch_device = pci_get_device(PCI_VENDOR_ID_INTEL, device, NULL);
+	if (gmch_device && PCI_FUNC(gmch_device->devfn) != 0) {
+		gmch_device = pci_get_device(PCI_VENDOR_ID_INTEL,
+                                device, gmch_device);
 	}
 
-	if (!i830_dev)
+	if (!gmch_device)
 		return 0;
 
-	intel_i830_private.i830_dev = i830_dev;
+	intel_private.pcidev = gmch_device;
 	return 1;
 }
 
+/* Table to describe Intel GMCH and AGP/PCIE GART drivers.  At least one of
+ * driver and gmch_driver must be non-null, and find_gmch will determine
+ * which one should be used if a gmch_chip_id is present.
+ */
+static const struct intel_driver_description {
+	unsigned int chip_id;
+	unsigned int gmch_chip_id;
+	char *name;
+	const struct agp_bridge_driver *driver;
+	const struct agp_bridge_driver *gmch_driver;
+} intel_agp_chipsets[] = {
+	{ PCI_DEVICE_ID_INTEL_82443LX_0, 0, "440LX", &intel_generic_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82443BX_0, 0, "440BX", &intel_generic_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82443GX_0, 0, "440GX", &intel_generic_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82810_MC1, PCI_DEVICE_ID_INTEL_82810_IG1, "i810",
+		NULL, &intel_810_driver },
+	{ PCI_DEVICE_ID_INTEL_82810_MC3, PCI_DEVICE_ID_INTEL_82810_IG3, "i810",
+		NULL, &intel_810_driver },
+	{ PCI_DEVICE_ID_INTEL_82810E_MC, PCI_DEVICE_ID_INTEL_82810E_IG, "i810",
+		NULL, &intel_810_driver },
+	{ PCI_DEVICE_ID_INTEL_82815_MC, PCI_DEVICE_ID_INTEL_82815_CGC, "i815",
+		&intel_810_driver, &intel_815_driver },
+	{ PCI_DEVICE_ID_INTEL_82820_HB, 0, "i820", &intel_820_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82820_UP_HB, 0, "i820", &intel_820_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82830_HB, PCI_DEVICE_ID_INTEL_82830_CGC, "830M",
+		&intel_830mp_driver, &intel_830_driver },
+	{ PCI_DEVICE_ID_INTEL_82840_HB, 0, "i840", &intel_840_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82845_HB, 0, "845G", &intel_845_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82845G_HB, PCI_DEVICE_ID_INTEL_82845G_IG, "830M",
+		&intel_845_driver, &intel_830_driver },
+	{ PCI_DEVICE_ID_INTEL_82850_HB, 0, "i850", &intel_850_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82855PM_HB, 0, "855PM", &intel_845_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82855GM_HB, PCI_DEVICE_ID_INTEL_82855GM_IG, "855GM",
+		&intel_845_driver, &intel_830_driver },
+	{ PCI_DEVICE_ID_INTEL_82860_HB, 0, "i860", &intel_860_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82865_HB, PCI_DEVICE_ID_INTEL_82865_IG, "865",
+		&intel_845_driver, &intel_830_driver },
+	{ PCI_DEVICE_ID_INTEL_82875_HB, 0, "i875", &intel_845_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_82915G_HB, PCI_DEVICE_ID_INTEL_82915G_IG, "915G",
+		&intel_845_driver, &intel_915_driver },
+	{ PCI_DEVICE_ID_INTEL_82915GM_HB, PCI_DEVICE_ID_INTEL_82915GM_IG, "915GM",
+		&intel_845_driver, &intel_915_driver },
+	{ PCI_DEVICE_ID_INTEL_82945G_HB, PCI_DEVICE_ID_INTEL_82945G_IG, "945G",
+		&intel_845_driver, &intel_915_driver },
+	{ PCI_DEVICE_ID_INTEL_82945GM_HB, PCI_DEVICE_ID_INTEL_82945GM_IG, "945GM",
+		&intel_845_driver, &intel_915_driver },
+	{ PCI_DEVICE_ID_INTEL_82945GM_HB, PCI_DEVICE_ID_INTEL_82945GME_IG, "945GME",
+		&intel_845_driver, &intel_915_driver },
+	{ PCI_DEVICE_ID_INTEL_82946GZ_HB, PCI_DEVICE_ID_INTEL_82946GZ_IG, "946GZ",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_82965G_1_HB, PCI_DEVICE_ID_INTEL_82965G_1_IG, "965G",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_82965Q_HB, PCI_DEVICE_ID_INTEL_82965Q_IG, "965Q",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_82965G_HB, PCI_DEVICE_ID_INTEL_82965G_IG, "965G",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_82965GM_HB, PCI_DEVICE_ID_INTEL_82965GM_IG, "965GM",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_82965GM_HB, PCI_DEVICE_ID_INTEL_82965GME_IG, "965GME/GLE",
+		&intel_845_driver, &intel_i965_driver },
+	{ PCI_DEVICE_ID_INTEL_7505_0, 0, "E7505", &intel_7505_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_7205_0, 0, "E7205", &intel_7505_driver, NULL },
+	{ PCI_DEVICE_ID_INTEL_G33_HB, PCI_DEVICE_ID_INTEL_G33_IG, "G33",
+		&intel_845_driver, &intel_g33_driver },
+	{ PCI_DEVICE_ID_INTEL_Q35_HB, PCI_DEVICE_ID_INTEL_Q35_IG, "Q35",
+		&intel_845_driver, &intel_g33_driver },
+	{ PCI_DEVICE_ID_INTEL_Q33_HB, PCI_DEVICE_ID_INTEL_Q33_IG, "Q33",
+		&intel_845_driver, &intel_g33_driver },
+	{ 0, 0, NULL, NULL, NULL }
+};
+
 static int __devinit agp_intel_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	char *name = "(unknown)";
 	u8 cap_ptr = 0;
 	struct resource *r;
+	int i;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 
@@ -1764,195 +1888,42 @@ static int __devinit agp_intel_probe(str
 	if (!bridge)
 		return -ENOMEM;
 
-	switch (pdev->device) {
-	case PCI_DEVICE_ID_INTEL_82443LX_0:
-		bridge->driver = &intel_generic_driver;
-		name = "440LX";
-		break;
-	case PCI_DEVICE_ID_INTEL_82443BX_0:
-		bridge->driver = &intel_generic_driver;
-		name = "440BX";
-		break;
-	case PCI_DEVICE_ID_INTEL_82443GX_0:
-		bridge->driver = &intel_generic_driver;
-		name = "440GX";
-		break;
-	case PCI_DEVICE_ID_INTEL_82810_MC1:
-		name = "i810";
-		if (!find_i810(PCI_DEVICE_ID_INTEL_82810_IG1))
-			goto fail;
-		bridge->driver = &intel_810_driver;
-		break;
-	case PCI_DEVICE_ID_INTEL_82810_MC3:
-		name = "i810 DC100";
-		if (!find_i810(PCI_DEVICE_ID_INTEL_82810_IG3))
-			goto fail;
-		bridge->driver = &intel_810_driver;
-		break;
-	case PCI_DEVICE_ID_INTEL_82810E_MC:
-		name = "i810 E";
-		if (!find_i810(PCI_DEVICE_ID_INTEL_82810E_IG))
-			goto fail;
-		bridge->driver = &intel_810_driver;
-		break;
-	 case PCI_DEVICE_ID_INTEL_82815_MC:
-		/*
-		 * The i815 can operate either as an i810 style
-		 * integrated device, or as an AGP4X motherboard.
-		 */
-		if (find_i810(PCI_DEVICE_ID_INTEL_82815_CGC))
-			bridge->driver = &intel_810_driver;
-		else
-			bridge->driver = &intel_815_driver;
-		name = "i815";
-		break;
-	case PCI_DEVICE_ID_INTEL_82820_HB:
-	case PCI_DEVICE_ID_INTEL_82820_UP_HB:
-		bridge->driver = &intel_820_driver;
-		name = "i820";
-		break;
-	case PCI_DEVICE_ID_INTEL_82830_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82830_CGC))
-			bridge->driver = &intel_830_driver;
-		else
-			bridge->driver = &intel_830mp_driver;
-		name = "830M";
-		break;
-	case PCI_DEVICE_ID_INTEL_82840_HB:
-		bridge->driver = &intel_840_driver;
-		name = "i840";
-		break;
-	case PCI_DEVICE_ID_INTEL_82845_HB:
-		bridge->driver = &intel_845_driver;
-		name = "i845";
-		break;
-	case PCI_DEVICE_ID_INTEL_82845G_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82845G_IG))
-			bridge->driver = &intel_830_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "845G";
-		break;
-	case PCI_DEVICE_ID_INTEL_82850_HB:
-		bridge->driver = &intel_850_driver;
-		name = "i850";
-		break;
-	case PCI_DEVICE_ID_INTEL_82855PM_HB:
-		bridge->driver = &intel_845_driver;
-		name = "855PM";
-		break;
-	case PCI_DEVICE_ID_INTEL_82855GM_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82855GM_IG)) {
-			bridge->driver = &intel_830_driver;
-			name = "855";
-		} else {
-			bridge->driver = &intel_845_driver;
-			name = "855GM";
-		}
-		break;
-	case PCI_DEVICE_ID_INTEL_82860_HB:
-		bridge->driver = &intel_860_driver;
-		name = "i860";
-		break;
-	case PCI_DEVICE_ID_INTEL_82865_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82865_IG))
-			bridge->driver = &intel_830_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "865";
-		break;
-	case PCI_DEVICE_ID_INTEL_82875_HB:
-		bridge->driver = &intel_845_driver;
-		name = "i875";
-		break;
-	case PCI_DEVICE_ID_INTEL_82915G_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82915G_IG))
-			bridge->driver = &intel_915_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "915G";
-		break;
-	case PCI_DEVICE_ID_INTEL_82915GM_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82915GM_IG))
-			bridge->driver = &intel_915_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "915GM";
-		break;
-	case PCI_DEVICE_ID_INTEL_82945G_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82945G_IG))
-			bridge->driver = &intel_915_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "945G";
-		break;
-	case PCI_DEVICE_ID_INTEL_82945GM_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82945GM_IG))
-			bridge->driver = &intel_915_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "945GM";
-		break;
-	case PCI_DEVICE_ID_INTEL_82946GZ_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82946GZ_IG))
-			bridge->driver = &intel_i965_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "946GZ";
-		break;
-	case PCI_DEVICE_ID_INTEL_82965G_1_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82965G_1_IG))
-			bridge->driver = &intel_i965_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "965G";
-		break;
-	case PCI_DEVICE_ID_INTEL_82965Q_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82965Q_IG))
-			bridge->driver = &intel_i965_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "965Q";
-		break;
-	case PCI_DEVICE_ID_INTEL_82965G_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82965G_IG))
-			bridge->driver = &intel_i965_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "965G";
-		break;
-	case PCI_DEVICE_ID_INTEL_82965GM_HB:
-		if (find_i830(PCI_DEVICE_ID_INTEL_82965GM_IG))
-			bridge->driver = &intel_i965_driver;
-		else
-			bridge->driver = &intel_845_driver;
-		name = "965GM";
-		break;
-	case PCI_DEVICE_ID_INTEL_7505_0:
-		bridge->driver = &intel_7505_driver;
-		name = "E7505";
-		break;
-	case PCI_DEVICE_ID_INTEL_7205_0:
-		bridge->driver = &intel_7505_driver;
-		name = "E7205";
-		break;
-	default:
+	for (i = 0; intel_agp_chipsets[i].name != NULL; i++) {
+		/* In case that multiple models of gfx chip may
+		   stand on same host bridge type, this can be
+		   sure we detect the right IGD. */
+		if ((pdev->device == intel_agp_chipsets[i].chip_id) &&
+			((intel_agp_chipsets[i].gmch_chip_id == 0) ||
+				find_gmch(intel_agp_chipsets[i].gmch_chip_id)))
+			break;
+	}
+
+	if (intel_agp_chipsets[i].name == NULL) {
 		if (cap_ptr)
-			printk(KERN_WARNING PFX "Unsupported Intel chipset (device id: %04x)\n",
-			    pdev->device);
+			printk(KERN_WARNING PFX "Unsupported Intel chipset"
+                               "(device id: %04x)\n", pdev->device);
 		agp_put_bridge(bridge);
 		return -ENODEV;
-	};
+	}
+
+	if (intel_agp_chipsets[i].gmch_chip_id != 0)
+	    bridge->driver = intel_agp_chipsets[i].gmch_driver;
+	else
+	    bridge->driver = intel_agp_chipsets[i].driver;
+
+	if (bridge->driver == NULL) {
+		printk(KERN_WARNING PFX "Failed to find bridge device "
+			"(chip_id: %04x)\n", intel_agp_chipsets[i].gmch_chip_id);
+		agp_put_bridge(bridge);
+		return -ENODEV;
+        }
 
 	bridge->dev = pdev;
 	bridge->capndx = cap_ptr;
+	bridge->dev_private_data = &intel_private;
 
-	if (bridge->driver == &intel_810_driver)
-		bridge->dev_private_data = &intel_i810_private;
-	else if (bridge->driver == &intel_830_driver)
-		bridge->dev_private_data = &intel_i830_private;
-
-	printk(KERN_INFO PFX "Detected an Intel %s Chipset.\n", name);
+	printk(KERN_INFO PFX "Detected an Intel %s Chipset.\n",
+		intel_agp_chipsets[i].name);
 
 	/*
 	* The following fixes the case where the BIOS has "forgotten" to
@@ -1988,12 +1959,6 @@ static int __devinit agp_intel_probe(str
 
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
-
-fail:
-	printk(KERN_ERR PFX "Detected an Intel %s chipset, "
-		"but could not find the secondary device.\n", name);
-	agp_put_bridge(bridge);
-	return -ENODEV;
 }
 
 static void __devexit agp_intel_remove(struct pci_dev *pdev)
@@ -2002,10 +1967,8 @@ static void __devexit agp_intel_remove(s
 
 	agp_remove_bridge(bridge);
 
-	if (intel_i810_private.i810_dev)
-		pci_dev_put(intel_i810_private.i810_dev);
-	if (intel_i830_private.i830_dev)
-		pci_dev_put(intel_i830_private.i830_dev);
+	if (intel_private.pcidev)
+		pci_dev_put(intel_private.pcidev);
 
 	agp_put_bridge(bridge);
 }
@@ -2021,10 +1984,8 @@ static int agp_intel_resume(struct pci_d
 	 * as host bridge (00:00) resumes before graphics device (02:00),
 	 * then our access to its pci space can work right.
 	 */
-	if (intel_i810_private.i810_dev)
-		pci_restore_state(intel_i810_private.i810_dev);
-	if (intel_i830_private.i830_dev)
-		pci_restore_state(intel_i830_private.i830_dev);
+	if (intel_private.pcidev)
+		pci_restore_state(intel_private.pcidev);
 
 	if (bridge->driver == &intel_generic_driver)
 		intel_configure();
@@ -2087,6 +2048,9 @@ static struct pci_device_id agp_intel_pc
 	ID(PCI_DEVICE_ID_INTEL_82965Q_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965G_HB),
 	ID(PCI_DEVICE_ID_INTEL_82965GM_HB),
+	ID(PCI_DEVICE_ID_INTEL_G33_HB),
+	ID(PCI_DEVICE_ID_INTEL_Q35_HB),
+	ID(PCI_DEVICE_ID_INTEL_Q33_HB),
 	{ }
 };
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/ide.c linux-2.6.22-rc4-git6/drivers/ide/ide.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/ide.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/ide.c	2007-06-14 14:14:33.000000000 -0400
@@ -1010,9 +1010,11 @@ static int generic_ide_resume(struct dev
 {
 	ide_drive_t *drive = dev->driver_data;
 	ide_hwif_t *hwif = HWIF(drive);
+	ide_driver_t *drv = to_ide_driver(dev->driver);
 	struct request rq;
 	struct request_pm_state rqpm;
 	ide_task_t args;
+	int err;
 
 	/* Call ACPI _STM only once */
 	if (!(drive->dn % 2))
@@ -1029,7 +1031,12 @@ static int generic_ide_resume(struct dev
 	rqpm.pm_step = ide_pm_state_start_resume;
 	rqpm.pm_state = PM_EVENT_ON;
 
-	return ide_do_drive_cmd(drive, &rq, ide_head_wait);
+	err = ide_do_drive_cmd(drive, &rq, ide_head_wait);
+
+	if (err == 0 && drv && drv->resume)
+		drv->resume(drive);
+
+	return err;
 }
 
 int generic_ide_ioctl(ide_drive_t *drive, struct file *file, struct block_device *bdev,
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/ide-disk.c linux-2.6.22-rc4-git6/drivers/ide/ide-disk.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/ide-disk.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/ide-disk.c	2007-06-14 14:14:33.000000000 -0400
@@ -1037,6 +1037,17 @@ static void ide_disk_release(struct kref
 
 static int ide_disk_probe(ide_drive_t *drive);
 
+/*
+ * On HPA drives the capacity needs to be
+ * reinitilized on resume otherwise the disk
+ * can not be used and a hard reset is required
+ */
+static void ide_disk_resume(ide_drive_t *drive)
+{
+	if (idedisk_supports_hpa(drive->id))
+		init_idedisk_capacity(drive);
+}
+
 static void ide_device_shutdown(ide_drive_t *drive)
 {
 #ifdef	CONFIG_ALPHA
@@ -1071,6 +1082,7 @@ static ide_driver_t idedisk_driver = {
 	},
 	.probe			= ide_disk_probe,
 	.remove			= ide_disk_remove,
+	.resume			= ide_disk_resume,
 	.shutdown		= ide_device_shutdown,
 	.version		= IDEDISK_VERSION,
 	.media			= ide_disk,
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/ide-probe.c linux-2.6.22-rc4-git6/drivers/ide/ide-probe.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/ide-probe.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/ide-probe.c	2007-06-14 14:14:33.000000000 -0400
@@ -717,7 +717,7 @@ EXPORT_SYMBOL_GPL(ide_undecoded_slave);
  * This routine only knows how to look for drive units 0 and 1
  * on an interface, so any setting of MAX_DRIVES > 2 won't work here.
  */
-static void probe_hwif(ide_hwif_t *hwif)
+static void probe_hwif(ide_hwif_t *hwif, void (*fixup)(ide_hwif_t *hwif))
 {
 	unsigned int unit;
 	unsigned long flags;
@@ -820,6 +820,9 @@ static void probe_hwif(ide_hwif_t *hwif)
 		return;
 	}
 
+	if (fixup)
+		fixup(hwif);
+
 	for (unit = 0; unit < MAX_DRIVES; ++unit) {
 		ide_drive_t *drive = &hwif->drives[unit];
 
@@ -874,10 +877,7 @@ static int hwif_init(ide_hwif_t *hwif);
 
 int probe_hwif_init_with_fixup(ide_hwif_t *hwif, void (*fixup)(ide_hwif_t *hwif))
 {
-	probe_hwif(hwif);
-
-	if (fixup)
-		fixup(hwif);
+	probe_hwif(hwif, fixup);
 
 	if (!hwif_init(hwif)) {
 		printk(KERN_INFO "%s: failed to initialize IDE interface\n",
@@ -1404,7 +1404,7 @@ int ideprobe_init (void)
 
 	for (index = 0; index < MAX_HWIFS; ++index)
 		if (probe[index])
-			probe_hwif(&ide_hwifs[index]);
+			probe_hwif(&ide_hwifs[index], NULL);
 	for (index = 0; index < MAX_HWIFS; ++index)
 		if (probe[index])
 			hwif_init(&ide_hwifs[index]);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/pci/amd74xx.c linux-2.6.22-rc4-git6/drivers/ide/pci/amd74xx.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/pci/amd74xx.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/pci/amd74xx.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * Version 2.13
+ * Version 2.15
  *
  * AMD 755/756/766/8111 and nVidia nForce/2/2s/3/3s/CK804/MCP04
  * IDE driver for Linux.
@@ -76,6 +76,8 @@ static struct amd_ide_chip {
 	{ PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_IDE,	0x50, AMD_UDMA_133 },
 	{ PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_IDE,	0x50, AMD_UDMA_133 },
 	{ PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_IDE,	0x50, AMD_UDMA_133 },
+	{ PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE,	0x50, AMD_UDMA_133 },
+	{ PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE,	0x50, AMD_UDMA_133 },
 	{ PCI_DEVICE_ID_AMD_CS5536_IDE,			0x40, AMD_UDMA_100 },
 	{ 0 }
 };
@@ -494,7 +496,9 @@ static ide_pci_device_t amd74xx_chipsets
 	/* 17 */ DECLARE_NV_DEV("NFORCE-MCP61"),
 	/* 18 */ DECLARE_NV_DEV("NFORCE-MCP65"),
 	/* 19 */ DECLARE_NV_DEV("NFORCE-MCP67"),
-	/* 20 */ DECLARE_AMD_DEV("AMD5536"),
+	/* 20 */ DECLARE_NV_DEV("NFORCE-MCP73"),
+	/* 21 */ DECLARE_NV_DEV("NFORCE-MCP77"),
+	/* 22 */ DECLARE_AMD_DEV("AMD5536"),
 };
 
 static int __devinit amd74xx_probe(struct pci_dev *dev, const struct pci_device_id *id)
@@ -534,7 +538,9 @@ static struct pci_device_id amd74xx_pci_
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_IDE,	PCI_ANY_ID, PCI_ANY_ID, 0, 0, 17 },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_IDE,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 18 },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_IDE,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 19 },
-	{ PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_CS5536_IDE,		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 20 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 20 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE,  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 21 },
+	{ PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_CS5536_IDE,		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 22 },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, amd74xx_pci_tbl);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/pci/generic.c linux-2.6.22-rc4-git6/drivers/ide/pci/generic.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/pci/generic.c	2007-06-08 12:08:10.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/pci/generic.c	2007-06-14 14:14:33.000000000 -0400
@@ -198,32 +198,41 @@ static ide_pci_device_t generic_chipsets
 static int __devinit generic_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	ide_pci_device_t *d = &generic_chipsets[id->driver_data];
-	u16 command;
 	int ret = -ENODEV;
 
 	/* Don't use the generic entry unless instructed to do so */
 	if (id->driver_data == 0 && ide_generic_all == 0)
 			goto out;
 
-	if (dev->vendor == PCI_VENDOR_ID_UMC &&
-	    dev->device == PCI_DEVICE_ID_UMC_UM8886A &&
-	    (!(PCI_FUNC(dev->devfn) & 1)))
-		goto out; /* UM8886A/BF pair */
-
-	if (dev->vendor == PCI_VENDOR_ID_OPTI &&
-	    dev->device == PCI_DEVICE_ID_OPTI_82C558 &&
-	    (!(PCI_FUNC(dev->devfn) & 1)))
-		goto out;
-
-	if (dev->vendor == PCI_VENDOR_ID_JMICRON) {
-		if (dev->device != PCI_DEVICE_ID_JMICRON_JMB368 && PCI_FUNC(dev->devfn) != 1)
+	switch (dev->vendor) {
+	case PCI_VENDOR_ID_UMC:
+		if (dev->device == PCI_DEVICE_ID_UMC_UM8886A &&
+				!(PCI_FUNC(dev->devfn) & 1))
+			goto out; /* UM8886A/BF pair */
+		break;
+	case PCI_VENDOR_ID_OPTI:
+		if (dev->device == PCI_DEVICE_ID_OPTI_82C558 &&
+				!(PCI_FUNC(dev->devfn) & 1))
+			goto out;
+		break;
+	case PCI_VENDOR_ID_JMICRON:
+		if (dev->device != PCI_DEVICE_ID_JMICRON_JMB368 &&
+				PCI_FUNC(dev->devfn) != 1)
+			goto out;
+		break;
+	case PCI_VENDOR_ID_NS:
+		if (dev->device == PCI_DEVICE_ID_NS_87410 &&
+				(dev->class >> 8) != PCI_CLASS_STORAGE_IDE)
 			goto out;
+		break;
 	}
 
 	if (dev->vendor != PCI_VENDOR_ID_JMICRON) {
+		u16 command;
 		pci_read_config_word(dev, PCI_COMMAND, &command);
 		if (!(command & PCI_COMMAND_IO)) {
-			printk(KERN_INFO "Skipping disabled %s IDE controller.\n", d->name);
+			printk(KERN_INFO "Skipping disabled %s IDE "
+					"controller.\n", d->name);
 			goto out;
 		}
 	}
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/pci/hpt366.c linux-2.6.22-rc4-git6/drivers/ide/pci/hpt366.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/pci/hpt366.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/pci/hpt366.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/ide/pci/hpt366.c		Version 1.03	May 4, 2007
+ * linux/drivers/ide/pci/hpt366.c		Version 1.04	Jun 4, 2007
  *
  * Copyright (C) 1999-2003		Andre Hedrick <andre@linux-ide.org>
  * Portions Copyright (C) 2001	        Sun Microsystems, Inc.
@@ -106,7 +106,8 @@
  *   switch  to calculating  PCI clock frequency based on the chip's base DPLL
  *   frequency
  * - switch to using the  DPLL clock and enable UltraATA/133 mode by default on
- *   anything  newer than HPT370/A
+ *   anything  newer than HPT370/A (except HPT374 that is not capable of this
+ *   mode according to the manual)
  * - fold PCI clock detection and DPLL setup code into init_chipset_hpt366(),
  *   also fixing the interchanged 25/40 MHz PCI clock cases for HPT36x chips;
  *   unify HPT36x/37x timing setup code and the speedproc handlers by joining
@@ -365,7 +366,6 @@ static u32 sixty_six_base_hpt37x[] = {
 };
 
 #define HPT366_DEBUG_DRIVE_INFO		0
-#define HPT374_ALLOW_ATA133_6		1
 #define HPT371_ALLOW_ATA133_6		1
 #define HPT302_ALLOW_ATA133_6		1
 #define HPT372_ALLOW_ATA133_6		1
@@ -450,7 +450,7 @@ static struct hpt_info hpt370a __devinit
 
 static struct hpt_info hpt374 __devinitdata = {
 	.chip_type	= HPT374,
-	.max_mode	= HPT374_ALLOW_ATA133_6 ? 4 : 3,
+	.max_mode	= 3,
 	.dpll_clk	= 48,
 	.settings	= hpt37x_settings
 };
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/pci/it821x.c linux-2.6.22-rc4-git6/drivers/ide/pci/it821x.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/pci/it821x.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/pci/it821x.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,6 +1,6 @@
 
 /*
- * linux/drivers/ide/pci/it821x.c		Version 0.10	Mar 10 2007
+ * linux/drivers/ide/pci/it821x.c		Version 0.15	Jun 2 2007
  *
  * Copyright (C) 2004		Red Hat <alan@redhat.com>
  * Copyright (C) 2007		Bartlomiej Zolnierkiewicz
@@ -262,7 +262,7 @@ static int it821x_tunepio(ide_drive_t *d
 	}
 
 	if (itdev->smart)
-		goto set_drive_speed;
+		return 0;
 
 	/* We prefer 66Mhz clock for PIO 0-3, don't care for PIO4 */
 	itdev->want[unit][1] = pio_want[set_pio];
@@ -271,7 +271,6 @@ static int it821x_tunepio(ide_drive_t *d
 	it821x_clock_strategy(drive);
 	it821x_program(drive, itdev->pio[unit]);
 
-set_drive_speed:
 	return ide_config_drive_speed(drive, XFER_PIO_0 + set_pio);
 }
 
@@ -455,12 +454,12 @@ static int it821x_tune_chipset (ide_driv
 			default:
 				return 1;
 		}
+
+		return ide_config_drive_speed(drive, speed);
 	}
-	/*
-	 *	In smart mode the clocking is done by the host controller
-	 * 	snooping the mode we picked. The rest of it is not our problem
-	 */
-	return ide_config_drive_speed(drive, speed);
+
+	/* don't touch anything in the smart mode */
+	return 0;
 }
 
 /**
@@ -559,17 +558,10 @@ static void __devinit it821x_fixups(ide_
 				if(idbits[129] != 1)
 					printk("(%dK stripe)", idbits[146]);
 				printk(".\n");
-			/* Now the core code will have wrongly decided no DMA
-			   so we need to fix this */
-			hwif->dma_off_quietly(drive);
-#ifdef CONFIG_IDEDMA_ONLYDISK
-			if (drive->media == ide_disk)
-#endif
-				ide_set_dma(drive);
 		} else {
 			/* Non RAID volume. Fixups to stop the core code
 			   doing unsupported things */
-			id->field_valid &= 1;
+			id->field_valid &= 3;
 			id->queue_depth = 0;
 			id->command_set_1 = 0;
 			id->command_set_2 &= 0xC400;
@@ -584,6 +576,16 @@ static void __devinit it821x_fixups(ide_
 			printk(KERN_INFO "%s: Performing identify fixups.\n",
 				drive->name);
 		}
+
+		/*
+		 * Set MWDMA0 mode as enabled/support - just to tell
+		 * IDE core that DMA is supported (it821x hardware
+		 * takes care of DMA mode programming).
+		 */
+		if (id->capability & 1) {
+			id->dma_mword |= 0x0101;
+			drive->current_speed = XFER_MW_DMA_0;
+		}
 	}
 
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/ide/pci/serverworks.c linux-2.6.22-rc4-git6/drivers/ide/pci/serverworks.c
--- linux-2.6.22-rc4-git3.orig/drivers/ide/pci/serverworks.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/ide/pci/serverworks.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * linux/drivers/ide/pci/serverworks.c		Version 0.9	Mar 4 2007
+ * linux/drivers/ide/pci/serverworks.c		Version 0.11	Jun 2 2007
  *
  * Copyright (C) 1998-2000 Michel Aubry
  * Copyright (C) 1998-2000 Andrzej Krzysztofowicz
@@ -170,42 +170,55 @@ static int svwks_tune_chipset (ide_drive
 		if (!drive->init_speed) {
 			u8 dma_stat = inb(hwif->dma_status);
 
-dma_pio:
 			if (((ultra_enable << (7-drive->dn) & 0x80) == 0x80) &&
 			    ((dma_stat & (1<<(5+unit))) == (1<<(5+unit)))) {
 				drive->current_speed = drive->init_speed = XFER_UDMA_0 + udma_modes[(ultra_timing >> (4*unit)) & ~(0xF0)];
 				return 0;
 			} else if ((dma_timing) &&
 				   ((dma_stat&(1<<(5+unit)))==(1<<(5+unit)))) {
-				u8 dmaspeed = dma_timing;
+				u8 dmaspeed;
 
-				dma_timing &= ~0xFFU;
-				if ((dmaspeed & 0x20) == 0x20)
+				switch (dma_timing & 0x77) {
+				case 0x20:
 					dmaspeed = XFER_MW_DMA_2;
-				else if ((dmaspeed & 0x21) == 0x21)
+					break;
+				case 0x21:
 					dmaspeed = XFER_MW_DMA_1;
-				else if ((dmaspeed & 0x77) == 0x77)
+					break;
+				case 0x77:
 					dmaspeed = XFER_MW_DMA_0;
-				else
+					break;
+				default:
 					goto dma_pio;
+				}
+
 				drive->current_speed = drive->init_speed = dmaspeed;
 				return 0;
-			} else if (pio_timing) {
-				u8 piospeed = pio_timing;
+			}
+dma_pio:
+			if (pio_timing) {
+				u8 piospeed;
 
-				pio_timing &= ~0xFFU;
-				if ((piospeed & 0x20) == 0x20)
+				switch (pio_timing & 0x7f) {
+				case 0x20:
 					piospeed = XFER_PIO_4;
-				else if ((piospeed & 0x22) == 0x22)
+					break;
+				case 0x22:
 					piospeed = XFER_PIO_3;
-				else if ((piospeed & 0x34) == 0x34)
+					break;
+				case 0x34:
 					piospeed = XFER_PIO_2;
-				else if ((piospeed & 0x47) == 0x47)
+					break;
+				case 0x47:
 					piospeed = XFER_PIO_1;
-				else if ((piospeed & 0x5d) == 0x5d)
+					break;
+				case 0x5d:
 					piospeed = XFER_PIO_0;
-				else
+					break;
+				default:
 					goto oem_setup_failed;
+				}
+
 				drive->current_speed = drive->init_speed = piospeed;
 				return 0;
 			}
@@ -214,8 +227,8 @@ dma_pio:
 
 oem_setup_failed:
 
-	pio_timing	&= ~0xFFU;
-	dma_timing	&= ~0xFFU;
+	pio_timing	= 0;
+	dma_timing	= 0;
 	ultra_timing	&= ~(0x0F << (4*unit));
 	ultra_enable	&= ~(0x01 << drive->dn);
 	csb5_pio	&= ~(0x0F << (4*drive->dn));
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/infiniband/core/cma.c linux-2.6.22-rc4-git6/drivers/infiniband/core/cma.c
--- linux-2.6.22-rc4-git3.orig/drivers/infiniband/core/cma.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/infiniband/core/cma.c	2007-06-14 14:14:33.000000000 -0400
@@ -2773,8 +2773,8 @@ static int cma_init(void)
 	int ret;
 
 	get_random_bytes(&next_port, sizeof next_port);
-	next_port = (next_port % (sysctl_local_port_range[1] -
-				  sysctl_local_port_range[0])) +
+	next_port = ((unsigned int) next_port %
+		    (sysctl_local_port_range[1] - sysctl_local_port_range[0])) +
 		    sysctl_local_port_range[0];
 	cma_wq = create_singlethread_workqueue("rdma_cm");
 	if (!cma_wq)
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/infiniband/hw/mlx4/qp.c linux-2.6.22-rc4-git6/drivers/infiniband/hw/mlx4/qp.c
--- linux-2.6.22-rc4-git3.orig/drivers/infiniband/hw/mlx4/qp.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/infiniband/hw/mlx4/qp.c	2007-06-14 14:14:33.000000000 -0400
@@ -189,18 +189,28 @@ static int send_wqe_overhead(enum ib_qp_
 }
 
 static int set_rq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,
-		       struct mlx4_ib_qp *qp)
+		       int is_user, int has_srq, struct mlx4_ib_qp *qp)
 {
 	/* Sanity check RQ size before proceeding */
 	if (cap->max_recv_wr  > dev->dev->caps.max_wqes  ||
 	    cap->max_recv_sge > dev->dev->caps.max_rq_sg)
 		return -EINVAL;
 
-	qp->rq.max = cap->max_recv_wr ? roundup_pow_of_two(cap->max_recv_wr) : 0;
+	if (has_srq) {
+		/* QPs attached to an SRQ should have no RQ */
+		if (cap->max_recv_wr)
+			return -EINVAL;
+
+		qp->rq.max = qp->rq.max_gs = 0;
+	} else {
+		/* HW requires >= 1 RQ entry with >= 1 gather entry */
+		if (is_user && (!cap->max_recv_wr || !cap->max_recv_sge))
+			return -EINVAL;
 
-	qp->rq.wqe_shift = ilog2(roundup_pow_of_two(cap->max_recv_sge *
-						    sizeof (struct mlx4_wqe_data_seg)));
-	qp->rq.max_gs    = (1 << qp->rq.wqe_shift) / sizeof (struct mlx4_wqe_data_seg);
+		qp->rq.max	 = roundup_pow_of_two(max(1, cap->max_recv_wr));
+		qp->rq.max_gs	 = roundup_pow_of_two(max(1, cap->max_recv_sge));
+		qp->rq.wqe_shift = ilog2(qp->rq.max_gs * sizeof (struct mlx4_wqe_data_seg));
+	}
 
 	cap->max_recv_wr  = qp->rq.max;
 	cap->max_recv_sge = qp->rq.max_gs;
@@ -285,7 +295,7 @@ static int create_qp_common(struct mlx4_
 	qp->sq.head	    = 0;
 	qp->sq.tail	    = 0;
 
-	err = set_rq_size(dev, &init_attr->cap, qp);
+	err = set_rq_size(dev, &init_attr->cap, !!pd->uobject, !!init_attr->srq, qp);
 	if (err)
 		goto err;
 
@@ -762,11 +772,6 @@ static int __mlx4_ib_modify_qp(struct ib
 		optpar |= MLX4_QP_OPTPAR_PKEY_INDEX;
 	}
 
-	if (attr_mask & IB_QP_RNR_RETRY) {
-		context->params1 |= cpu_to_be32(attr->rnr_retry << 13);
-		optpar |= MLX4_QP_OPTPAR_RNR_RETRY;
-	}
-
 	if (attr_mask & IB_QP_AV) {
 		if (mlx4_set_path(dev, &attr->ah_attr, &context->pri_path,
 				  attr_mask & IB_QP_PORT ? attr->port_num : qp->port)) {
@@ -802,6 +807,12 @@ static int __mlx4_ib_modify_qp(struct ib
 
 	context->pd	    = cpu_to_be32(to_mpd(ibqp->pd)->pdn);
 	context->params1    = cpu_to_be32(MLX4_IB_ACK_REQ_FREQ << 28);
+
+	if (attr_mask & IB_QP_RNR_RETRY) {
+		context->params1 |= cpu_to_be32(attr->rnr_retry << 13);
+		optpar |= MLX4_QP_OPTPAR_RNR_RETRY;
+	}
+
 	if (attr_mask & IB_QP_RETRY_CNT) {
 		context->params1 |= cpu_to_be32(attr->retry_cnt << 16);
 		optpar |= MLX4_QP_OPTPAR_RETRY_COUNT;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/infiniband/hw/mthca/mthca_cmd.c linux-2.6.22-rc4-git6/drivers/infiniband/hw/mthca/mthca_cmd.c
--- linux-2.6.22-rc4-git3.orig/drivers/infiniband/hw/mthca/mthca_cmd.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/infiniband/hw/mthca/mthca_cmd.c	2007-06-14 14:14:33.000000000 -0400
@@ -772,7 +772,7 @@ int mthca_QUERY_FW(struct mthca_dev *dev
 
 	MTHCA_GET(dev->fw_ver,   outbox, QUERY_FW_VER_OFFSET);
 	/*
-	 * FW subminor version is at more signifant bits than minor
+	 * FW subminor version is at more significant bits than minor
 	 * version, so swap here.
 	 */
 	dev->fw_ver = (dev->fw_ver & 0xffff00000000ull) |
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/input-polldev.c linux-2.6.22-rc4-git6/drivers/input/input-polldev.c
--- linux-2.6.22-rc4-git3.orig/drivers/input/input-polldev.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.22-rc4-git6/drivers/input/input-polldev.c	2007-06-14 14:14:33.000000000 -0400
@@ -0,0 +1,176 @@
+/*
+ * Generic implementation of a polled input device
+
+ * Copyright (c) 2007 Dmitry Torokhov
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/input-polldev.h>
+
+MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
+MODULE_DESCRIPTION("Generic implementation of a polled input device");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("0.1");
+
+static DEFINE_MUTEX(polldev_mutex);
+static int polldev_users;
+static struct workqueue_struct *polldev_wq;
+
+static int input_polldev_start_workqueue(void)
+{
+	int retval;
+
+	retval = mutex_lock_interruptible(&polldev_mutex);
+	if (retval)
+		return retval;
+
+	if (!polldev_users) {
+		polldev_wq = create_singlethread_workqueue("ipolldevd");
+		if (!polldev_wq) {
+			printk(KERN_ERR "input-polldev: failed to create "
+				"ipolldevd workqueue\n");
+			retval = -ENOMEM;
+			goto out;
+		}
+	}
+
+	polldev_users++;
+
+ out:
+	mutex_unlock(&polldev_mutex);
+	return retval;
+}
+
+static void input_polldev_stop_workqueue(void)
+{
+	mutex_lock(&polldev_mutex);
+
+	if (!--polldev_users)
+		destroy_workqueue(polldev_wq);
+
+	mutex_unlock(&polldev_mutex);
+}
+
+static void input_polled_device_work(struct work_struct *work)
+{
+	struct input_polled_dev *dev =
+		container_of(work, struct input_polled_dev, work.work);
+
+	dev->poll(dev);
+	queue_delayed_work(polldev_wq, &dev->work,
+			   msecs_to_jiffies(dev->poll_interval));
+}
+
+static int input_open_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input->private;
+	int error;
+
+	error = input_polldev_start_workqueue();
+	if (error)
+		return error;
+
+	if (dev->flush)
+		dev->flush(dev);
+
+	queue_delayed_work(polldev_wq, &dev->work,
+			   msecs_to_jiffies(dev->poll_interval));
+
+	return 0;
+}
+
+static void input_close_polled_device(struct input_dev *input)
+{
+	struct input_polled_dev *dev = input->private;
+
+	cancel_rearming_delayed_workqueue(polldev_wq, &dev->work);
+	input_polldev_stop_workqueue();
+}
+
+/**
+ * input_allocate_polled_device - allocated memory polled device
+ *
+ * The function allocates memory for a polled device and also
+ * for an input device associated with this polled device.
+ */
+struct input_polled_dev *input_allocate_polled_device(void)
+{
+	struct input_polled_dev *dev;
+
+	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->input = input_allocate_device();
+	if (!dev->input) {
+		kfree(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL(input_allocate_polled_device);
+
+/**
+ * input_free_polled_device - free memory allocated for polled device
+ * @dev: device to free
+ *
+ * The function frees memory allocated for polling device and drops
+ * reference to the associated input device (if present).
+ */
+void input_free_polled_device(struct input_polled_dev *dev)
+{
+	if (dev) {
+		input_free_device(dev->input);
+		kfree(dev);
+	}
+}
+EXPORT_SYMBOL(input_free_polled_device);
+
+/**
+ * input_register_polled_device - register polled device
+ * @dev: device to register
+ *
+ * The function registers previously initialized polled input device
+ * with input layer. The device should be allocated with call to
+ * input_allocate_polled_device(). Callers should also set up poll()
+ * method and set up capabilities (id, name, phys, bits) of the
+ * corresponing input_dev structure.
+ */
+int input_register_polled_device(struct input_polled_dev *dev)
+{
+	struct input_dev *input = dev->input;
+
+	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
+	if (!dev->poll_interval)
+		dev->poll_interval = 500;
+	input->private = dev;
+	input->open = input_open_polled_device;
+	input->close = input_close_polled_device;
+
+	return input_register_device(input);
+}
+EXPORT_SYMBOL(input_register_polled_device);
+
+/**
+ * input_unregister_polled_device - unregister polled device
+ * @dev: device to unregister
+ *
+ * The function unregisters previously registered polled input
+ * device from input layer. Polling is stopped and device is
+ * ready to be freed with call to input_free_polled_device().
+ * Callers should not attempt to access dev->input pointer
+ * after calling this function.
+ */
+void input_unregister_polled_device(struct input_polled_dev *dev)
+{
+	input_unregister_device(dev->input);
+	dev->input = NULL;
+}
+EXPORT_SYMBOL(input_unregister_polled_device);
+
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/Kconfig linux-2.6.22-rc4-git6/drivers/input/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/input/Kconfig	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -39,6 +39,19 @@ config INPUT_FF_MEMLESS
 	  To compile this driver as a module, choose M here: the
 	  module will be called ff-memless.
 
+config INPUT_POLLDEV
+	tristate "Polled input device skeleton"
+	help
+	  Say Y here if you are using a driver for an input
+	  device that periodically polls hardware state. This
+	  option is only useful for out-of-tree drivers since
+	  in-tree drivers select it automatically.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input-polldev.
+
 comment "Userland interfaces"
 
 config INPUT_MOUSEDEV
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/Makefile linux-2.6.22-rc4-git6/drivers/input/Makefile
--- linux-2.6.22-rc4-git3.orig/drivers/input/Makefile	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/Makefile	2007-06-14 14:14:33.000000000 -0400
@@ -8,6 +8,7 @@ obj-$(CONFIG_INPUT)		+= input-core.o
 input-core-objs := input.o ff-core.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
+obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 
 obj-$(CONFIG_INPUT_MOUSEDEV)	+= mousedev.o
 obj-$(CONFIG_INPUT_JOYDEV)	+= joydev.o
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/misc/input-polldev.c linux-2.6.22-rc4-git6/drivers/input/misc/input-polldev.c
--- linux-2.6.22-rc4-git3.orig/drivers/input/misc/input-polldev.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/misc/input-polldev.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,176 +0,0 @@
-/*
- * Generic implementation of a polled input device
-
- * Copyright (c) 2007 Dmitry Torokhov
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
- */
-
-#include <linux/jiffies.h>
-#include <linux/mutex.h>
-#include <linux/input-polldev.h>
-
-MODULE_AUTHOR("Dmitry Torokhov <dtor@mail.ru>");
-MODULE_DESCRIPTION("Generic implementation of a polled input device");
-MODULE_LICENSE("GPL v2");
-MODULE_VERSION("0.1");
-
-static DEFINE_MUTEX(polldev_mutex);
-static int polldev_users;
-static struct workqueue_struct *polldev_wq;
-
-static int input_polldev_start_workqueue(void)
-{
-	int retval;
-
-	retval = mutex_lock_interruptible(&polldev_mutex);
-	if (retval)
-		return retval;
-
-	if (!polldev_users) {
-		polldev_wq = create_singlethread_workqueue("ipolldevd");
-		if (!polldev_wq) {
-			printk(KERN_ERR "input-polldev: failed to create "
-				"ipolldevd workqueue\n");
-			retval = -ENOMEM;
-			goto out;
-		}
-	}
-
-	polldev_users++;
-
- out:
-	mutex_unlock(&polldev_mutex);
-	return retval;
-}
-
-static void input_polldev_stop_workqueue(void)
-{
-	mutex_lock(&polldev_mutex);
-
-	if (!--polldev_users)
-		destroy_workqueue(polldev_wq);
-
-	mutex_unlock(&polldev_mutex);
-}
-
-static void input_polled_device_work(struct work_struct *work)
-{
-	struct input_polled_dev *dev =
-		container_of(work, struct input_polled_dev, work.work);
-
-	dev->poll(dev);
-	queue_delayed_work(polldev_wq, &dev->work,
-			   msecs_to_jiffies(dev->poll_interval));
-}
-
-static int input_open_polled_device(struct input_dev *input)
-{
-	struct input_polled_dev *dev = input->private;
-	int error;
-
-	error = input_polldev_start_workqueue();
-	if (error)
-		return error;
-
-	if (dev->flush)
-		dev->flush(dev);
-
-	queue_delayed_work(polldev_wq, &dev->work,
-			   msecs_to_jiffies(dev->poll_interval));
-
-	return 0;
-}
-
-static void input_close_polled_device(struct input_dev *input)
-{
-	struct input_polled_dev *dev = input->private;
-
-	cancel_rearming_delayed_workqueue(polldev_wq, &dev->work);
-	input_polldev_stop_workqueue();
-}
-
-/**
- * input_allocate_polled_device - allocated memory polled device
- *
- * The function allocates memory for a polled device and also
- * for an input device associated with this polled device.
- */
-struct input_polled_dev *input_allocate_polled_device(void)
-{
-	struct input_polled_dev *dev;
-
-	dev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	dev->input = input_allocate_device();
-	if (!dev->input) {
-		kfree(dev);
-		return NULL;
-	}
-
-	return dev;
-}
-EXPORT_SYMBOL(input_allocate_polled_device);
-
-/**
- * input_free_polled_device - free memory allocated for polled device
- * @dev: device to free
- *
- * The function frees memory allocated for polling device and drops
- * reference to the associated input device (if present).
- */
-void input_free_polled_device(struct input_polled_dev *dev)
-{
-	if (dev) {
-		input_free_device(dev->input);
-		kfree(dev);
-	}
-}
-EXPORT_SYMBOL(input_free_polled_device);
-
-/**
- * input_register_polled_device - register polled device
- * @dev: device to register
- *
- * The function registers previously initialized polled input device
- * with input layer. The device should be allocated with call to
- * input_allocate_polled_device(). Callers should also set up poll()
- * method and set up capabilities (id, name, phys, bits) of the
- * corresponing input_dev structure.
- */
-int input_register_polled_device(struct input_polled_dev *dev)
-{
-	struct input_dev *input = dev->input;
-
-	INIT_DELAYED_WORK(&dev->work, input_polled_device_work);
-	if (!dev->poll_interval)
-		dev->poll_interval = 500;
-	input->private = dev;
-	input->open = input_open_polled_device;
-	input->close = input_close_polled_device;
-
-	return input_register_device(input);
-}
-EXPORT_SYMBOL(input_register_polled_device);
-
-/**
- * input_unregister_polled_device - unregister polled device
- * @dev: device to unregister
- *
- * The function unregisters previously registered polled input
- * device from input layer. Polling is stopped and device is
- * ready to be freed with call to input_free_polled_device().
- * Callers should not attempt to access dev->input pointer
- * after calling this function.
- */
-void input_unregister_polled_device(struct input_polled_dev *dev)
-{
-	input_unregister_device(dev->input);
-	dev->input = NULL;
-}
-EXPORT_SYMBOL(input_unregister_polled_device);
-
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/misc/Kconfig linux-2.6.22-rc4-git6/drivers/input/misc/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/input/misc/Kconfig	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/misc/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -170,17 +170,6 @@ config INPUT_UINPUT
 	  To compile this driver as a module, choose M here: the
 	  module will be called uinput.
 
-config INPUT_POLLDEV
-	tristate "Polled input device skeleton"
-	help
-	  Say Y here if you are using a driver for an input
-	  device that periodically polls hardware state. This
-	  option is only useful for out-of-tree drivers since
-	  in-tree drivers select it automatically.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called input-polldev.
-
 config HP_SDC_RTC
 	tristate "HP SDC Real Time Clock"
 	depends on GSC || HP300
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/misc/Makefile linux-2.6.22-rc4-git6/drivers/input/misc/Makefile
--- linux-2.6.22-rc4-git3.orig/drivers/input/misc/Makefile	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/misc/Makefile	2007-06-14 14:14:33.000000000 -0400
@@ -4,7 +4,6 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_INPUT_POLLDEV)		+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARCSPKR)		+= sparcspkr.o
 obj-$(CONFIG_INPUT_PCSPKR)		+= pcspkr.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/serio/i8042-x86ia64io.h linux-2.6.22-rc4-git6/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.22-rc4-git3.orig/drivers/input/serio/i8042-x86ia64io.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/serio/i8042-x86ia64io.h	2007-06-14 14:14:33.000000000 -0400
@@ -69,6 +69,15 @@ static inline void i8042_write_command(i
 
 static struct dmi_system_id __initdata i8042_dmi_noloop_table[] = {
 	{
+		/* AUX LOOP command does not raise AUX IRQ */
+		.ident = "ASUS P65UP5",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
+			DMI_MATCH(DMI_BOARD_NAME, "P/I-P65UP5"),
+			DMI_MATCH(DMI_BOARD_VERSION, "REV 2.X"),
+		},
+	},
+	{
 		.ident = "Compaq Proliant 8500",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Compaq"),
@@ -92,6 +101,15 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_VERSION, "00"),
 		},
 	},
+	{
+		/* AUX LOOP does not work properly */
+		.ident = "ULI EV4873",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ULI"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "EV4873"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "5a"),
+		},
+	},
 	{ }
 };
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/input/touchscreen/usbtouchscreen.c linux-2.6.22-rc4-git6/drivers/input/touchscreen/usbtouchscreen.c
--- linux-2.6.22-rc4-git3.orig/drivers/input/touchscreen/usbtouchscreen.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/input/touchscreen/usbtouchscreen.c	2007-06-14 14:14:33.000000000 -0400
@@ -91,7 +91,7 @@ struct usbtouch_usb {
 };
 
 
-#if defined(CONFIG_USB_TOUCHSCREEN_EGALAX) || defined(CONFIG_USB_TOUCHSCREEN_ETURBO)
+#if defined(CONFIG_TOUCHSCREEN_USB_EGALAX) || defined(CONFIG_TOUCHSCREEN_USB_ETURBO)
 #define MULTI_PACKET
 #endif
 
@@ -113,7 +113,7 @@ enum {
 };
 
 static struct usb_device_id usbtouch_devices[] = {
-#ifdef CONFIG_USB_TOUCHSCREEN_EGALAX
+#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX
 	{USB_DEVICE(0x3823, 0x0001), .driver_info = DEVTYPE_EGALAX},
 	{USB_DEVICE(0x3823, 0x0002), .driver_info = DEVTYPE_EGALAX},
 	{USB_DEVICE(0x0123, 0x0001), .driver_info = DEVTYPE_EGALAX},
@@ -123,30 +123,30 @@ static struct usb_device_id usbtouch_dev
 	{USB_DEVICE(0x1234, 0x0002), .driver_info = DEVTYPE_EGALAX},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_PANJIT
+#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT
 	{USB_DEVICE(0x134c, 0x0001), .driver_info = DEVTYPE_PANJIT},
 	{USB_DEVICE(0x134c, 0x0002), .driver_info = DEVTYPE_PANJIT},
 	{USB_DEVICE(0x134c, 0x0003), .driver_info = DEVTYPE_PANJIT},
 	{USB_DEVICE(0x134c, 0x0004), .driver_info = DEVTYPE_PANJIT},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_3M
+#ifdef CONFIG_TOUCHSCREEN_USB_3M
 	{USB_DEVICE(0x0596, 0x0001), .driver_info = DEVTYPE_3M},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_ITM
+#ifdef CONFIG_TOUCHSCREEN_USB_ITM
 	{USB_DEVICE(0x0403, 0xf9e9), .driver_info = DEVTYPE_ITM},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_ETURBO
+#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO
 	{USB_DEVICE(0x1234, 0x5678), .driver_info = DEVTYPE_ETURBO},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_GUNZE
+#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE
 	{USB_DEVICE(0x0637, 0x0001), .driver_info = DEVTYPE_GUNZE},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_DMC_TSC10
+#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10
 	{USB_DEVICE(0x0afa, 0x03e8), .driver_info = DEVTYPE_DMC_TSC10},
 #endif
 
@@ -158,7 +158,7 @@ static struct usb_device_id usbtouch_dev
  * eGalax part
  */
 
-#ifdef CONFIG_USB_TOUCHSCREEN_EGALAX
+#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX
 
 #define EGALAX_PKT_TYPE_MASK		0xFE
 #define EGALAX_PKT_TYPE_REPT		0x80
@@ -197,7 +197,7 @@ static int egalax_get_pkt_len(unsigned c
 /*****************************************************************************
  * PanJit Part
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_PANJIT
+#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT
 static int panjit_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
 {
 	dev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];
@@ -212,7 +212,7 @@ static int panjit_read_data(struct usbto
 /*****************************************************************************
  * 3M/Microtouch Part
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_3M
+#ifdef CONFIG_TOUCHSCREEN_USB_3M
 
 #define MTOUCHUSB_ASYNC_REPORT          1
 #define MTOUCHUSB_RESET                 7
@@ -262,7 +262,7 @@ static int mtouch_init(struct usbtouch_u
 /*****************************************************************************
  * ITM Part
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_ITM
+#ifdef CONFIG_TOUCHSCREEN_USB_ITM
 static int itm_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
 {
 	int touch;
@@ -296,7 +296,7 @@ static int itm_read_data(struct usbtouch
 /*****************************************************************************
  * eTurboTouch part
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_ETURBO
+#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO
 static int eturbo_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
 {
 	unsigned int shift;
@@ -327,7 +327,7 @@ static int eturbo_get_pkt_len(unsigned c
 /*****************************************************************************
  * Gunze part
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_GUNZE
+#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE
 static int gunze_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
 {
 	if (!(pkt[0] & 0x80) || ((pkt[1] | pkt[2] | pkt[3]) & 0x80))
@@ -348,7 +348,7 @@ static int gunze_read_data(struct usbtou
  *   http://www.dmccoltd.com/files/controler/tsc10usb_pi_e.pdf
  *   http://www.dmccoltd.com/files/controler/tsc25_usb_e.pdf
  */
-#ifdef CONFIG_USB_TOUCHSCREEN_DMC_TSC10
+#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10
 
 /* supported data rates. currently using 130 */
 #define TSC10_RATE_POINT	0x50
@@ -419,7 +419,7 @@ static int dmc_tsc10_read_data(struct us
  * the different device descriptors
  */
 static struct usbtouch_device_info usbtouch_dev_info[] = {
-#ifdef CONFIG_USB_TOUCHSCREEN_EGALAX
+#ifdef CONFIG_TOUCHSCREEN_USB_EGALAX
 	[DEVTYPE_EGALAX] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x07ff,
@@ -433,7 +433,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_PANJIT
+#ifdef CONFIG_TOUCHSCREEN_USB_PANJIT
 	[DEVTYPE_PANJIT] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x0fff,
@@ -444,7 +444,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_3M
+#ifdef CONFIG_TOUCHSCREEN_USB_3M
 	[DEVTYPE_3M] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x4000,
@@ -456,7 +456,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_ITM
+#ifdef CONFIG_TOUCHSCREEN_USB_ITM
 	[DEVTYPE_ITM] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x0fff,
@@ -468,7 +468,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_ETURBO
+#ifdef CONFIG_TOUCHSCREEN_USB_ETURBO
 	[DEVTYPE_ETURBO] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x07ff,
@@ -482,7 +482,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_GUNZE
+#ifdef CONFIG_TOUCHSCREEN_USB_GUNZE
 	[DEVTYPE_GUNZE] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x0fff,
@@ -493,7 +493,7 @@ static struct usbtouch_device_info usbto
 	},
 #endif
 
-#ifdef CONFIG_USB_TOUCHSCREEN_DMC_TSC10
+#ifdef CONFIG_TOUCHSCREEN_USB_DMC_TSC10
 	[DEVTYPE_DMC_TSC10] = {
 		.min_xc		= 0x0,
 		.max_xc		= 0x03ff,
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/common/Kconfig linux-2.6.22-rc4-git6/drivers/media/common/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/media/common/Kconfig	2007-06-08 12:08:11.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/common/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -4,5 +4,6 @@ config VIDEO_SAA7146
 
 config VIDEO_SAA7146_VV
 	tristate
+	depends on VIDEO_DEV
 	select VIDEO_BUF
 	select VIDEO_SAA7146
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/dvb/b2c2/Makefile linux-2.6.22-rc4-git6/drivers/media/dvb/b2c2/Makefile
--- linux-2.6.22-rc4-git3.orig/drivers/media/dvb/b2c2/Makefile	2007-06-08 11:09:57.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/dvb/b2c2/Makefile	2007-06-14 14:14:33.000000000 -0400
@@ -1,8 +1,11 @@
 b2c2-flexcop-objs = flexcop.o flexcop-fe-tuner.o flexcop-i2c.o \
-	flexcop-sram.o flexcop-eeprom.o flexcop-misc.o flexcop-hw-filter.o \
-	flexcop-dma.o
+	flexcop-sram.o flexcop-eeprom.o flexcop-misc.o flexcop-hw-filter.o
 obj-$(CONFIG_DVB_B2C2_FLEXCOP) += b2c2-flexcop.o
 
+ifneq ($(CONFIG_DVB_B2C2_FLEXCOP_PCI),)
+b2c2-flexcop-objs += flexcop-dma.o
+endif
+
 b2c2-flexcop-pci-objs = flexcop-pci.o
 obj-$(CONFIG_DVB_B2C2_FLEXCOP_PCI) += b2c2-flexcop-pci.o
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/dvb/cinergyT2/cinergyT2.c linux-2.6.22-rc4-git6/drivers/media/dvb/cinergyT2/cinergyT2.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/dvb/cinergyT2/cinergyT2.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/dvb/cinergyT2/cinergyT2.c	2007-06-14 14:14:33.000000000 -0400
@@ -519,8 +519,7 @@ static int cinergyt2_release (struct ino
 	struct dvb_device *dvbdev = file->private_data;
 	struct cinergyt2 *cinergyt2 = dvbdev->priv;
 
-	if (mutex_lock_interruptible(&cinergyt2->sem))
-		return -ERESTARTSYS;
+	mutex_lock(&cinergyt2->sem);
 
 	if (!cinergyt2->disconnect_pending && (file->f_flags & O_ACCMODE) != O_RDONLY) {
 		cancel_delayed_work(&cinergyt2->query_work);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/dvb/frontends/tda10086.c linux-2.6.22-rc4-git6/drivers/media/dvb/frontends/tda10086.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/dvb/frontends/tda10086.c	2007-06-08 12:08:11.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/dvb/frontends/tda10086.c	2007-06-14 14:14:33.000000000 -0400
@@ -41,6 +41,7 @@ struct tda10086_state {
 	/* private demod data */
 	u32 frequency;
 	u32 symbol_rate;
+	bool has_lock;
 };
 
 static int debug = 0;
@@ -116,7 +117,7 @@ static int tda10086_init(struct dvb_fron
 	// misc setup
 	tda10086_write_byte(state, 0x01, 0x94);
 	tda10086_write_byte(state, 0x02, 0x35); // NOTE: TT drivers appear to disable CSWP
-	tda10086_write_byte(state, 0x03, 0x64);
+	tda10086_write_byte(state, 0x03, 0xe4);
 	tda10086_write_byte(state, 0x04, 0x43);
 	tda10086_write_byte(state, 0x0c, 0x0c);
 	tda10086_write_byte(state, 0x1b, 0xb0); // noise threshold
@@ -146,7 +147,7 @@ static int tda10086_init(struct dvb_fron
 	// setup AGC
 	tda10086_write_byte(state, 0x05, 0x0B);
 	tda10086_write_byte(state, 0x37, 0x63);
-	tda10086_write_byte(state, 0x3f, 0x03); // NOTE: flydvb uses 0x0a and varies it
+	tda10086_write_byte(state, 0x3f, 0x0a); // NOTE: flydvb varies it
 	tda10086_write_byte(state, 0x40, 0x64);
 	tda10086_write_byte(state, 0x41, 0x4f);
 	tda10086_write_byte(state, 0x42, 0x43);
@@ -398,6 +399,10 @@ static int tda10086_set_frontend(struct 
 
 	dprintk ("%s\n", __FUNCTION__);
 
+	// modify parameters for tuning
+	tda10086_write_byte(state, 0x02, 0x35);
+	state->has_lock = false;
+
 	// set params
 	if (fe->ops.tuner_ops.set_params) {
 		fe->ops.tuner_ops.set_params(fe, fe_params);
@@ -542,8 +547,14 @@ static int tda10086_read_status(struct d
 		*fe_status |= FE_HAS_VITERBI;
 	if (val & 0x08)
 		*fe_status |= FE_HAS_SYNC;
-	if (val & 0x10)
+	if (val & 0x10) {
 		*fe_status |= FE_HAS_LOCK;
+		if (!state->has_lock) {
+			state->has_lock = true;
+			// modify parameters for stable reception
+			tda10086_write_byte(state, 0x02, 0x00);
+		}
+	}
 
 	return 0;
 }
@@ -555,7 +566,7 @@ static int tda10086_read_signal_strength
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	_str = tda10086_read_byte(state, 0x43);
+	_str = 0xff - tda10086_read_byte(state, 0x43);
 	*signal = (_str << 8) | _str;
 
 	return 0;
@@ -568,7 +579,7 @@ static int tda10086_read_snr(struct dvb_
 
 	dprintk ("%s\n", __FUNCTION__);
 
-	_snr = tda10086_read_byte(state, 0x1c);
+	_snr = 0xff - tda10086_read_byte(state, 0x1c);
 	*snr = (_snr << 8) | _snr;
 
 	return 0;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/dvb/frontends/tda826x.c linux-2.6.22-rc4-git6/drivers/media/dvb/frontends/tda826x.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/dvb/frontends/tda826x.c	2007-06-08 12:08:04.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/dvb/frontends/tda826x.c	2007-06-14 14:14:33.000000000 -0400
@@ -89,8 +89,8 @@ static int tda826x_set_params(struct dvb
 	buf[2] = (1<<5) | 0x0b; // 1Mhz + 0.45 VCO
 	buf[3] = div >> 7;
 	buf[4] = div << 1;
-	buf[5] = 0xff; // basedband filter to max
-	buf[6] = 0xfe; // gains at max + no RF attenuation
+	buf[5] = 0x77; // baseband cut-off 19 MHz
+	buf[6] = 0xfe; // baseband gain 9 db + no RF attenuation
 	buf[7] = 0x83; // charge pumps at high, tests off
 	buf[8] = 0x80; // recommended value 4 for AMPVCO + disable ports.
 	buf[9] = 0x1a; // normal caltime + recommended values for SELTH + SELVTL
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-cards.h linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-cards.h
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-cards.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-cards.h	2007-06-14 14:14:33.000000000 -0400
@@ -86,7 +86,7 @@
 			  V4L2_CAP_AUDIO | V4L2_CAP_READWRITE | V4L2_CAP_VBI_CAPTURE | \
 			  V4L2_CAP_SLICED_VBI_CAPTURE)
 #define IVTV_CAP_DECODER (V4L2_CAP_VBI_OUTPUT | V4L2_CAP_VIDEO_OUTPUT | \
-			  V4L2_CAP_SLICED_VBI_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_OVERLAY | V4L2_CAP_VIDEO_OUTPUT_POS)
+			  V4L2_CAP_SLICED_VBI_OUTPUT | V4L2_CAP_VIDEO_OUTPUT_OVERLAY)
 
 struct ivtv_card_video_input {
 	u8  video_type; 	/* video input type */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-driver.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-driver.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-driver.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-driver.c	2007-06-14 14:14:33.000000000 -0400
@@ -652,6 +652,7 @@ static int __devinit ivtv_init_struct1(s
 	itv->dma_timer.data = (unsigned long)itv;
 
 	itv->cur_dma_stream = -1;
+	itv->cur_pio_stream = -1;
 	itv->audio_stereo_mode = AUDIO_STEREO;
 	itv->audio_bilingual_mode = AUDIO_MONO_LEFT;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-driver.h linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-driver.h
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-driver.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-driver.h	2007-06-14 14:14:33.000000000 -0400
@@ -237,6 +237,7 @@ extern const u32 yuv_offset[4];
 #define IVTV_IRQ_ENC_VBI_CAP		(0x1 << 29)
 #define IVTV_IRQ_ENC_VIM_RST		(0x1 << 28)
 #define IVTV_IRQ_ENC_DMA_COMPLETE	(0x1 << 27)
+#define IVTV_IRQ_ENC_PIO_COMPLETE	(0x1 << 25)
 #define IVTV_IRQ_DEC_AUD_MODE_CHG	(0x1 << 24)
 #define IVTV_IRQ_DEC_DATA_REQ		(0x1 << 22)
 #define IVTV_IRQ_DEC_DMA_COMPLETE	(0x1 << 20)
@@ -247,7 +248,8 @@ extern const u32 yuv_offset[4];
 #define IVTV_IRQ_DEC_VSYNC		(0x1 << 10)
 
 /* IRQ Masks */
-#define IVTV_IRQ_MASK_INIT (IVTV_IRQ_DMA_ERR|IVTV_IRQ_ENC_DMA_COMPLETE|IVTV_IRQ_DMA_READ)
+#define IVTV_IRQ_MASK_INIT (IVTV_IRQ_DMA_ERR|IVTV_IRQ_ENC_DMA_COMPLETE|\
+		IVTV_IRQ_DMA_READ|IVTV_IRQ_ENC_PIO_COMPLETE)
 
 #define IVTV_IRQ_MASK_CAPTURE (IVTV_IRQ_ENC_START_CAP | IVTV_IRQ_ENC_EOS)
 #define IVTV_IRQ_MASK_DECODE  (IVTV_IRQ_DEC_DATA_REQ|IVTV_IRQ_DEC_AUD_MODE_CHG)
@@ -374,6 +376,9 @@ struct ivtv_mailbox_data {
 #define IVTV_F_S_STREAMOFF	7	/* signal end of stream EOS */
 #define IVTV_F_S_APPL_IO        8	/* this stream is used read/written by an application */
 
+#define IVTV_F_S_PIO_PENDING	9	/* this stream has pending PIO */
+#define IVTV_F_S_PIO_HAS_VBI	1       /* the current PIO request also requests VBI data */
+
 /* per-ivtv, i_flags */
 #define IVTV_F_I_DMA		   0 	/* DMA in progress */
 #define IVTV_F_I_UDMA		   1 	/* UDMA in progress */
@@ -390,8 +395,11 @@ struct ivtv_mailbox_data {
 #define IVTV_F_I_DECODING_YUV	   12 	/* this stream is YUV frame decoding */
 #define IVTV_F_I_ENC_PAUSED	   13 	/* the encoder is paused */
 #define IVTV_F_I_VALID_DEC_TIMINGS 14 	/* last_dec_timing is valid */
-#define IVTV_F_I_WORK_HANDLER_VBI  15	/* there is work to be done for VBI */
-#define IVTV_F_I_WORK_HANDLER_YUV  16	/* there is work to be done for YUV */
+#define IVTV_F_I_HAVE_WORK  	   15	/* Used in the interrupt handler: there is work to be done */
+#define IVTV_F_I_WORK_HANDLER_VBI  16	/* there is work to be done for VBI */
+#define IVTV_F_I_WORK_HANDLER_YUV  17	/* there is work to be done for YUV */
+#define IVTV_F_I_WORK_HANDLER_PIO  18	/* there is work to be done for PIO */
+#define IVTV_F_I_PIO		   19	/* PIO in progress */
 
 /* Event notifications */
 #define IVTV_F_I_EV_DEC_STOPPED	   28	/* decoder stopped event */
@@ -484,6 +492,7 @@ struct ivtv_stream {
 
 	/* Base Dev SG Array for cx23415/6 */
 	struct ivtv_SG_element *SGarray;
+	struct ivtv_SG_element *PIOarray;
 	dma_addr_t SG_handle;
 	int SG_length;
 
@@ -706,6 +715,7 @@ struct ivtv {
 	atomic_t decoding;	/* count number of active decoding streams */
 	u32 irq_rr_idx; /* Round-robin stream index */
 	int cur_dma_stream;	/* index of stream doing DMA */
+	int cur_pio_stream;	/* index of stream doing PIO */
 	u32 dma_data_req_offset;
 	u32 dma_data_req_size;
 	int output_mode;        /* NONE, MPG, YUV, UDMA YUV, passthrough */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-fileops.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-fileops.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-fileops.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-fileops.c	2007-06-14 14:14:33.000000000 -0400
@@ -32,6 +32,8 @@
 #include "ivtv-yuv.h"
 #include "ivtv-controls.h"
 #include "ivtv-ioctl.h"
+#include "ivtv-cards.h"
+#include <media/saa7115.h>
 
 /* This function tries to claim the stream for a specific file descriptor.
    If no one else is using this stream then the stream is claimed and
@@ -786,6 +788,13 @@ int ivtv_v4l2_close(struct inode *inode,
 		ivtv_call_i2c_clients(itv, VIDIOC_S_STD, &itv->std);
 		/* Select correct audio input (i.e. TV tuner or Line in) */
 		ivtv_audio_set_io(itv);
+		if (itv->hw_flags & IVTV_HW_SAA711X)
+		{
+			struct v4l2_crystal_freq crystal_freq;
+			crystal_freq.freq = SAA7115_FREQ_32_11_MHZ;
+			crystal_freq.flags = 0;
+			ivtv_saa7115(itv, VIDIOC_INT_S_CRYSTAL_FREQ, &crystal_freq);
+		}
 		/* Done! Unmute and continue. */
 		ivtv_unmute(itv);
 		ivtv_release_stream(s);
@@ -872,6 +881,13 @@ int ivtv_v4l2_open(struct inode *inode, 
 		set_bit(IVTV_F_I_RADIO_USER, &itv->i_flags);
 		/* Select the correct audio input (i.e. radio tuner) */
 		ivtv_audio_set_io(itv);
+		if (itv->hw_flags & IVTV_HW_SAA711X)
+		{
+			struct v4l2_crystal_freq crystal_freq;
+			crystal_freq.freq = SAA7115_FREQ_32_11_MHZ;
+			crystal_freq.flags = SAA7115_FREQ_FL_APLL;
+			ivtv_saa7115(itv, VIDIOC_INT_S_CRYSTAL_FREQ, &crystal_freq);
+		}
 		/* Done! Unmute and continue. */
 		ivtv_unmute(itv);
 	}
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-ioctl.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-ioctl.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-ioctl.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-ioctl.c	2007-06-14 14:14:33.000000000 -0400
@@ -532,11 +532,6 @@ static int ivtv_try_or_set_fmt(struct iv
 				itv->yuv_info.yuv_forced_update = 1;
 				return 0;
 			}
-			if (!ivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,
-				 r.width, r.height, r.left, r.top))
-				itv->main_rect = r;
-			else
-				return -EINVAL;
 		}
 		return 0;
 	}
@@ -799,9 +794,39 @@ int ivtv_v4l2_ioctls(struct ivtv *itv, s
 		return ivtv_get_fmt(itv, id->type, fmt);
 	}
 
+	case VIDIOC_CROPCAP: {
+		struct v4l2_cropcap *cropcap = arg;
+
+		if (cropcap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+		    cropcap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		cropcap->bounds.top = cropcap->bounds.left = 0;
+		cropcap->bounds.width = 720;
+		if (cropcap->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+			cropcap->bounds.height = itv->is_50hz ? 576 : 480;
+			cropcap->pixelaspect.numerator = itv->is_50hz ? 59 : 10;
+			cropcap->pixelaspect.denominator = itv->is_50hz ? 54 : 11;
+		} else {
+			cropcap->bounds.height = itv->is_out_50hz ? 576 : 480;
+			cropcap->pixelaspect.numerator = itv->is_out_50hz ? 59 : 10;
+			cropcap->pixelaspect.denominator = itv->is_out_50hz ? 54 : 11;
+		}
+		cropcap->defrect = cropcap->bounds;
+		return 0;
+	}
+
 	case VIDIOC_S_CROP: {
 		struct v4l2_crop *crop = arg;
 
+		if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+		    (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)) {
+			if (!ivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,
+				 crop->c.width, crop->c.height, crop->c.left, crop->c.top)) {
+				itv->main_rect = crop->c;
+				return 0;
+			}
+			return -EINVAL;
+		}
 		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 			return -EINVAL;
 		return itv->video_dec_func(itv, VIDIOC_S_CROP, arg);
@@ -810,6 +835,11 @@ int ivtv_v4l2_ioctls(struct ivtv *itv, s
 	case VIDIOC_G_CROP: {
 		struct v4l2_crop *crop = arg;
 
+		if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&
+		    (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)) {
+			crop->c = itv->main_rect;
+			return 0;
+		}
 		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 			return -EINVAL;
 		return itv->video_dec_func(itv, VIDIOC_G_CROP, arg);
@@ -977,7 +1007,7 @@ int ivtv_v4l2_ioctls(struct ivtv *itv, s
 		if (itv->hw_flags & IVTV_HW_CX25840) {
 			itv->vbi.sliced_decoder_line_size = itv->is_60hz ? 272 : 284;
 		}
-		IVTV_DEBUG_INFO("Switching standard to %llx.\n", itv->std);
+		IVTV_DEBUG_INFO("Switching standard to %llx.\n", (unsigned long long)itv->std);
 
 		/* Tuner */
 		ivtv_call_i2c_clients(itv, VIDIOC_S_STD, &itv->std);
@@ -1207,7 +1237,7 @@ int ivtv_v4l2_ioctls(struct ivtv *itv, s
 					(s->buffers - s->q_free.buffers) * 100 / s->buffers,
 					(s->buffers * s->buf_size) / 1024, s->buffers);
 		}
-		IVTV_INFO("Read MPEG/VBI: %lld/%lld bytes\n", itv->mpg_data_received, itv->vbi_data_inserted);
+		IVTV_INFO("Read MPEG/VBI: %lld/%lld bytes\n", (long long)itv->mpg_data_received, (long long)itv->vbi_data_inserted);
 		IVTV_INFO("==================  END STATUS CARD #%d  ==================\n", itv->num);
 		break;
 	}
@@ -1455,6 +1485,7 @@ static int ivtv_v4l2_do_ioctl(struct ino
 	case VIDIOC_S_FMT:
 	case VIDIOC_TRY_FMT:
 	case VIDIOC_ENUM_FMT:
+	case VIDIOC_CROPCAP:
 	case VIDIOC_G_CROP:
 	case VIDIOC_S_CROP:
 	case VIDIOC_G_FREQUENCY:
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-irq.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-irq.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-irq.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-irq.c	2007-06-14 14:14:33.000000000 -0400
@@ -31,8 +31,6 @@
 
 #define DMA_MAGIC_COOKIE 0x000001fe
 
-#define SLICED_VBI_PIO 1
-
 static void ivtv_dma_dec_start(struct ivtv_stream *s);
 
 static const int ivtv_stream_map[] = {
@@ -42,12 +40,40 @@ static const int ivtv_stream_map[] = {
 	IVTV_ENC_STREAM_TYPE_VBI,
 };
 
-static inline int ivtv_use_pio(struct ivtv_stream *s)
+
+static void ivtv_pio_work_handler(struct ivtv *itv)
 {
-	struct ivtv *itv = s->itv;
+	struct ivtv_stream *s = &itv->streams[itv->cur_pio_stream];
+	struct ivtv_buffer *buf;
+	struct list_head *p;
+	int i = 0;
 
-	return s->dma == PCI_DMA_NONE ||
-	    (SLICED_VBI_PIO && s->type == IVTV_ENC_STREAM_TYPE_VBI && itv->vbi.sliced_in->service_set);
+	IVTV_DEBUG_DMA("ivtv_pio_work_handler\n");
+	if (itv->cur_pio_stream < 0 || itv->cur_pio_stream >= IVTV_MAX_STREAMS ||
+			s->v4l2dev == NULL || !ivtv_use_pio(s)) {
+		itv->cur_pio_stream = -1;
+		/* trigger PIO complete user interrupt */
+		write_reg(IVTV_IRQ_ENC_PIO_COMPLETE, 0x44);
+		return;
+	}
+	IVTV_DEBUG_DMA("Process PIO %s\n", s->name);
+	buf = list_entry(s->q_dma.list.next, struct ivtv_buffer, list);
+	list_for_each(p, &s->q_dma.list) {
+		struct ivtv_buffer *buf = list_entry(p, struct ivtv_buffer, list);
+		u32 size = s->PIOarray[i].size & 0x3ffff;
+
+		/* Copy the data from the card to the buffer */
+		if (s->type == IVTV_DEC_STREAM_TYPE_VBI) {
+			memcpy_fromio(buf->buf, itv->dec_mem + s->PIOarray[i].src - IVTV_DECODER_OFFSET, size);
+		}
+		else {
+			memcpy_fromio(buf->buf, itv->enc_mem + s->PIOarray[i].src, size);
+		}
+		if (s->PIOarray[i].size & 0x80000000)
+			break;
+		i++;
+	}
+	write_reg(IVTV_IRQ_ENC_PIO_COMPLETE, 0x44);
 }
 
 void ivtv_irq_work_handler(struct work_struct *work)
@@ -56,8 +82,11 @@ void ivtv_irq_work_handler(struct work_s
 
 	DEFINE_WAIT(wait);
 
+	if (test_and_clear_bit(IVTV_F_I_WORK_HANDLER_PIO, &itv->i_flags))
+		ivtv_pio_work_handler(itv);
+
 	if (test_and_clear_bit(IVTV_F_I_WORK_HANDLER_VBI, &itv->i_flags))
-		vbi_work_handler(itv);
+		ivtv_vbi_work_handler(itv);
 
 	if (test_and_clear_bit(IVTV_F_I_WORK_HANDLER_YUV, &itv->i_flags))
 		ivtv_yuv_work_handler(itv);
@@ -173,8 +202,7 @@ static int stream_enc_dma_append(struct 
 	}
 	s->buffers_stolen = rc;
 
-	/* got the buffers, now fill in SGarray (DMA) or copy the data from the card
-	   to the buffers (PIO). */
+	/* got the buffers, now fill in SGarray (DMA) */
 	buf = list_entry(s->q_predma.list.next, struct ivtv_buffer, list);
 	memset(buf->buf, 0, 128);
 	list_for_each(p, &s->q_predma.list) {
@@ -182,21 +210,11 @@ static int stream_enc_dma_append(struct 
 
 		if (skip_bufs-- > 0)
 			continue;
-		if (!ivtv_use_pio(s)) {
-			s->SGarray[idx].dst = cpu_to_le32(buf->dma_handle);
-			s->SGarray[idx].src = cpu_to_le32(offset);
-			s->SGarray[idx].size = cpu_to_le32(s->buf_size);
-		}
+		s->SGarray[idx].dst = cpu_to_le32(buf->dma_handle);
+		s->SGarray[idx].src = cpu_to_le32(offset);
+		s->SGarray[idx].size = cpu_to_le32(s->buf_size);
 		buf->bytesused = (size < s->buf_size) ? size : s->buf_size;
 
-		/* If PIO, then copy the data from the card to the buffer */
-		if (s->type == IVTV_DEC_STREAM_TYPE_VBI) {
-			memcpy_fromio(buf->buf, itv->dec_mem + offset - IVTV_DECODER_OFFSET, buf->bytesused);
-		}
-		else if (ivtv_use_pio(s)) {
-			memcpy_fromio(buf->buf, itv->enc_mem + offset, buf->bytesused);
-		}
-
 		s->q_predma.bytesused += buf->bytesused;
 		size -= buf->bytesused;
 		offset += s->buf_size;
@@ -224,11 +242,6 @@ static void dma_post(struct ivtv_stream 
 	u32 *u32buf;
 	int x = 0;
 
-	if (ivtv_use_pio(s)) {
-		if (s->q_predma.bytesused)
-			ivtv_queue_move(s, &s->q_predma, NULL, &s->q_dma, s->q_predma.bytesused);
-		s->SG_length = 0;
-	}
 	IVTV_DEBUG_DMA("%s %s completed (%x)\n", ivtv_use_pio(s) ? "PIO" : "DMA",
 			s->name, s->dma_offset);
 	list_for_each(p, &s->q_dma.list) {
@@ -278,10 +291,14 @@ static void dma_post(struct ivtv_stream 
 	if (buf)
 		buf->bytesused += s->dma_last_offset;
 	if (buf && s->type == IVTV_DEC_STREAM_TYPE_VBI) {
-		/* Parse and Groom VBI Data */
-		s->q_dma.bytesused -= buf->bytesused;
-		ivtv_process_vbi_data(itv, buf, 0, s->type);
-		s->q_dma.bytesused += buf->bytesused;
+		list_for_each(p, &s->q_dma.list) {
+			buf = list_entry(p, struct ivtv_buffer, list);
+
+			/* Parse and Groom VBI Data */
+			s->q_dma.bytesused -= buf->bytesused;
+			ivtv_process_vbi_data(itv, buf, 0, s->type);
+			s->q_dma.bytesused += buf->bytesused;
+		}
 		if (s->id == -1) {
 			ivtv_queue_move(s, &s->q_dma, NULL, &s->q_free, 0);
 			return;
@@ -351,10 +368,14 @@ static void ivtv_dma_enc_start(struct iv
 	struct ivtv_stream *s_vbi = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];
 	int i;
 
+	IVTV_DEBUG_DMA("start %s for %s\n", ivtv_use_dma(s) ? "DMA" : "PIO", s->name);
+
 	if (s->q_predma.bytesused)
 		ivtv_queue_move(s, &s->q_predma, NULL, &s->q_dma, s->q_predma.bytesused);
-	IVTV_DEBUG_DMA("start DMA for %s\n", s->name);
-	s->SGarray[s->SG_length - 1].size = cpu_to_le32(le32_to_cpu(s->SGarray[s->SG_length - 1].size) + 256);
+
+	if (ivtv_use_dma(s))
+		s->SGarray[s->SG_length - 1].size =
+			cpu_to_le32(le32_to_cpu(s->SGarray[s->SG_length - 1].size) + 256);
 
 	/* If this is an MPEG stream, and VBI data is also pending, then append the
 	   VBI DMA to the MPEG DMA and transfer both sets of data at once.
@@ -368,7 +389,8 @@ static void ivtv_dma_enc_start(struct iv
 	if (s->type == IVTV_ENC_STREAM_TYPE_MPG && s_vbi->SG_length &&
 			s->SG_length + s_vbi->SG_length <= s->buffers) {
 		ivtv_queue_move(s_vbi, &s_vbi->q_predma, NULL, &s_vbi->q_dma, s_vbi->q_predma.bytesused);
-		s_vbi->SGarray[s_vbi->SG_length - 1].size = cpu_to_le32(le32_to_cpu(s_vbi->SGarray[s->SG_length - 1].size) + 256);
+		if (ivtv_use_dma(s_vbi))
+			s_vbi->SGarray[s_vbi->SG_length - 1].size = cpu_to_le32(le32_to_cpu(s_vbi->SGarray[s->SG_length - 1].size) + 256);
 		for (i = 0; i < s_vbi->SG_length; i++) {
 			s->SGarray[s->SG_length++] = s_vbi->SGarray[i];
 		}
@@ -381,14 +403,26 @@ static void ivtv_dma_enc_start(struct iv
 	/* Mark last buffer size for Interrupt flag */
 	s->SGarray[s->SG_length - 1].size |= cpu_to_le32(0x80000000);
 
-	/* Sync Hardware SG List of buffers */
-	ivtv_stream_sync_for_device(s);
-	write_reg(s->SG_handle, IVTV_REG_ENCDMAADDR);
-	write_reg_sync(read_reg(IVTV_REG_DMAXFER) | 0x02, IVTV_REG_DMAXFER);
-	set_bit(IVTV_F_I_DMA, &itv->i_flags);
-	itv->cur_dma_stream = s->type;
-	itv->dma_timer.expires = jiffies + HZ / 10;
-	add_timer(&itv->dma_timer);
+	if (ivtv_use_pio(s)) {
+		for (i = 0; i < s->SG_length; i++) {
+			s->PIOarray[i].src = le32_to_cpu(s->SGarray[i].src);
+			s->PIOarray[i].size = le32_to_cpu(s->SGarray[i].size);
+		}
+		set_bit(IVTV_F_I_WORK_HANDLER_PIO, &itv->i_flags);
+		set_bit(IVTV_F_I_HAVE_WORK, &itv->i_flags);
+		set_bit(IVTV_F_I_PIO, &itv->i_flags);
+		itv->cur_pio_stream = s->type;
+	}
+	else {
+		/* Sync Hardware SG List of buffers */
+		ivtv_stream_sync_for_device(s);
+		write_reg(s->SG_handle, IVTV_REG_ENCDMAADDR);
+		write_reg_sync(read_reg(IVTV_REG_DMAXFER) | 0x02, IVTV_REG_DMAXFER);
+		set_bit(IVTV_F_I_DMA, &itv->i_flags);
+		itv->cur_dma_stream = s->type;
+		itv->dma_timer.expires = jiffies + HZ / 10;
+		add_timer(&itv->dma_timer);
+	}
 }
 
 static void ivtv_dma_dec_start(struct ivtv_stream *s)
@@ -489,6 +523,40 @@ static void ivtv_irq_enc_dma_complete(st
 	wake_up(&itv->dma_waitq);
 }
 
+static void ivtv_irq_enc_pio_complete(struct ivtv *itv)
+{
+	struct ivtv_stream *s;
+
+	if (itv->cur_pio_stream < 0 || itv->cur_pio_stream >= IVTV_MAX_STREAMS) {
+		itv->cur_pio_stream = -1;
+		return;
+	}
+	s = &itv->streams[itv->cur_pio_stream];
+	IVTV_DEBUG_IRQ("ENC PIO COMPLETE %s\n", s->name);
+	s->SG_length = 0;
+	clear_bit(IVTV_F_I_ENC_VBI, &itv->i_flags);
+	clear_bit(IVTV_F_I_PIO, &itv->i_flags);
+	itv->cur_pio_stream = -1;
+	dma_post(s);
+	if (s->type == IVTV_ENC_STREAM_TYPE_MPG)
+		ivtv_vapi(itv, CX2341X_ENC_SCHED_DMA_TO_HOST, 3, 0, 0, 0);
+	else if (s->type == IVTV_ENC_STREAM_TYPE_YUV)
+		ivtv_vapi(itv, CX2341X_ENC_SCHED_DMA_TO_HOST, 3, 0, 0, 1);
+	else if (s->type == IVTV_ENC_STREAM_TYPE_PCM)
+		ivtv_vapi(itv, CX2341X_ENC_SCHED_DMA_TO_HOST, 3, 0, 0, 2);
+	clear_bit(IVTV_F_I_PIO, &itv->i_flags);
+	if (test_and_clear_bit(IVTV_F_S_DMA_HAS_VBI, &s->s_flags)) {
+		u32 tmp;
+
+		s = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];
+		tmp = s->dma_offset;
+		s->dma_offset = itv->vbi.dma_offset;
+		dma_post(s);
+		s->dma_offset = tmp;
+	}
+	wake_up(&itv->dma_waitq);
+}
+
 static void ivtv_irq_dma_err(struct ivtv *itv)
 {
 	u32 data[CX2341X_MBOX_MAX_DATA];
@@ -532,13 +600,7 @@ static void ivtv_irq_enc_start_cap(struc
 	clear_bit(IVTV_F_I_ENC_VBI, &itv->i_flags);
 	s = &itv->streams[ivtv_stream_map[data[0]]];
 	if (!stream_enc_dma_append(s, data)) {
-		if (ivtv_use_pio(s)) {
-			dma_post(s);
-			ivtv_vapi(itv, CX2341X_ENC_SCHED_DMA_TO_HOST, 3, 0, 0, data[0]);
-		}
-		else {
-			set_bit(IVTV_F_S_DMA_PENDING, &s->s_flags);
-		}
+		set_bit(ivtv_use_pio(s) ? IVTV_F_S_PIO_PENDING : IVTV_F_S_DMA_PENDING, &s->s_flags);
 	}
 }
 
@@ -551,15 +613,6 @@ static void ivtv_irq_enc_vbi_cap(struct 
 	IVTV_DEBUG_IRQ("ENC START VBI CAP\n");
 	s = &itv->streams[IVTV_ENC_STREAM_TYPE_VBI];
 
-	if (ivtv_use_pio(s)) {
-		if (stream_enc_dma_append(s, data))
-			return;
-		if (s->q_predma.bytesused)
-			ivtv_queue_move(s, &s->q_predma, NULL, &s->q_dma, s->q_predma.bytesused);
-		s->SG_length = 0;
-		dma_post(s);
-		return;
-	}
 	/* If more than two VBI buffers are pending, then
 	   clear the old ones and start with this new one.
 	   This can happen during transition stages when MPEG capturing is
@@ -582,11 +635,11 @@ static void ivtv_irq_enc_vbi_cap(struct 
 	if (!stream_enc_dma_append(s, data) &&
 			!test_bit(IVTV_F_S_STREAMING, &s_mpg->s_flags)) {
 		set_bit(IVTV_F_I_ENC_VBI, &itv->i_flags);
-		set_bit(IVTV_F_S_DMA_PENDING, &s->s_flags);
+		set_bit(ivtv_use_pio(s) ? IVTV_F_S_PIO_PENDING : IVTV_F_S_DMA_PENDING, &s->s_flags);
 	}
 }
 
-static void ivtv_irq_dev_vbi_reinsert(struct ivtv *itv)
+static void ivtv_irq_dec_vbi_reinsert(struct ivtv *itv)
 {
 	u32 data[CX2341X_MBOX_MAX_DATA];
 	struct ivtv_stream *s = &itv->streams[IVTV_DEC_STREAM_TYPE_VBI];
@@ -594,7 +647,7 @@ static void ivtv_irq_dev_vbi_reinsert(st
 	IVTV_DEBUG_IRQ("DEC VBI REINSERT\n");
 	if (test_bit(IVTV_F_S_CLAIMED, &s->s_flags) &&
 			!stream_enc_dma_append(s, data)) {
-		dma_post(s);
+		set_bit(IVTV_F_S_PIO_PENDING, &s->s_flags);
 	}
 }
 
@@ -657,7 +710,6 @@ static void ivtv_irq_vsync(struct ivtv *
 	}
 	if (frame != (itv->lastVsyncFrame & 1)) {
 		struct ivtv_stream *s = ivtv_get_output_stream(itv);
-		int work = 0;
 
 		itv->lastVsyncFrame += 1;
 		if (frame == 0) {
@@ -678,7 +730,7 @@ static void ivtv_irq_vsync(struct ivtv *
 		/* Send VBI to saa7127 */
 		if (frame) {
 			set_bit(IVTV_F_I_WORK_HANDLER_VBI, &itv->i_flags);
-			work = 1;
+			set_bit(IVTV_F_I_HAVE_WORK, &itv->i_flags);
 		}
 
 		/* Check if we need to update the yuv registers */
@@ -691,11 +743,9 @@ static void ivtv_irq_vsync(struct ivtv *
 				itv->yuv_info.new_frame_info[last_dma_frame].update = 0;
 				itv->yuv_info.yuv_forced_update = 0;
 				set_bit(IVTV_F_I_WORK_HANDLER_YUV, &itv->i_flags);
-				work = 1;
+				set_bit(IVTV_F_I_HAVE_WORK, &itv->i_flags);
 			}
 		}
-		if (work)
-			queue_work(itv->irq_work_queues, &itv->irq_work_queue);
 	}
 }
 
@@ -755,6 +805,10 @@ irqreturn_t ivtv_irq_handler(int irq, vo
 		ivtv_irq_enc_dma_complete(itv);
 	}
 
+	if (combo & IVTV_IRQ_ENC_PIO_COMPLETE) {
+		ivtv_irq_enc_pio_complete(itv);
+	}
+
 	if (combo & IVTV_IRQ_DMA_ERR) {
 		ivtv_irq_dma_err(itv);
 	}
@@ -768,7 +822,7 @@ irqreturn_t ivtv_irq_handler(int irq, vo
 	}
 
 	if (combo & IVTV_IRQ_DEC_VBI_RE_INSERT) {
-		ivtv_irq_dev_vbi_reinsert(itv);
+		ivtv_irq_dec_vbi_reinsert(itv);
 	}
 
 	if (combo & IVTV_IRQ_ENC_EOS) {
@@ -813,6 +867,22 @@ irqreturn_t ivtv_irq_handler(int irq, vo
 		}
 	}
 
+	if ((combo & IVTV_IRQ_DMA) && !test_bit(IVTV_F_I_PIO, &itv->i_flags)) {
+		for (i = 0; i < IVTV_MAX_STREAMS; i++) {
+			int idx = (i + itv->irq_rr_idx++) % IVTV_MAX_STREAMS;
+			struct ivtv_stream *s = &itv->streams[idx];
+
+			if (!test_and_clear_bit(IVTV_F_S_PIO_PENDING, &s->s_flags))
+				continue;
+			if (s->type == IVTV_DEC_STREAM_TYPE_VBI || s->type < IVTV_DEC_STREAM_TYPE_MPG)
+				ivtv_dma_enc_start(s);
+			break;
+		}
+	}
+
+	if (test_and_clear_bit(IVTV_F_I_HAVE_WORK, &itv->i_flags))
+		queue_work(itv->irq_work_queues, &itv->irq_work_queue);
+
 	spin_unlock(&itv->dma_reg_lock);
 
 	/* If we've just handled a 'forced' vsync, it's safest to say it
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-queue.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-queue.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-queue.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-queue.c	2007-06-14 14:14:33.000000000 -0400
@@ -195,14 +195,26 @@ int ivtv_stream_alloc(struct ivtv_stream
 		s->dma != PCI_DMA_NONE ? "DMA " : "",
 		s->name, s->buffers, s->buf_size, s->buffers * s->buf_size / 1024);
 
-	/* Allocate DMA SG Arrays */
-	if (s->dma != PCI_DMA_NONE) {
-		s->SGarray = (struct ivtv_SG_element *)kzalloc(SGsize, GFP_KERNEL);
-		if (s->SGarray == NULL) {
-			IVTV_ERR("Could not allocate SGarray for %s stream\n", s->name);
+	if (ivtv_might_use_pio(s)) {
+		s->PIOarray = (struct ivtv_SG_element *)kzalloc(SGsize, GFP_KERNEL);
+		if (s->PIOarray == NULL) {
+			IVTV_ERR("Could not allocate PIOarray for %s stream\n", s->name);
 			return -ENOMEM;
 		}
-		s->SG_length = 0;
+	}
+
+	/* Allocate DMA SG Arrays */
+	s->SGarray = (struct ivtv_SG_element *)kzalloc(SGsize, GFP_KERNEL);
+	if (s->SGarray == NULL) {
+		IVTV_ERR("Could not allocate SGarray for %s stream\n", s->name);
+		if (ivtv_might_use_pio(s)) {
+			kfree(s->PIOarray);
+			s->PIOarray = NULL;
+		}
+		return -ENOMEM;
+	}
+	s->SG_length = 0;
+	if (ivtv_might_use_dma(s)) {
 		s->SG_handle = pci_map_single(itv->dev, s->SGarray, SGsize, s->dma);
 		ivtv_stream_sync_for_cpu(s);
 	}
@@ -219,7 +231,7 @@ int ivtv_stream_alloc(struct ivtv_stream
 			break;
 		}
 		INIT_LIST_HEAD(&buf->list);
-		if (s->dma != PCI_DMA_NONE) {
+		if (ivtv_might_use_dma(s)) {
 			buf->dma_handle = pci_map_single(s->itv->dev,
 				buf->buf, s->buf_size + 256, s->dma);
 			ivtv_buf_sync_for_cpu(s, buf);
@@ -242,7 +254,7 @@ void ivtv_stream_free(struct ivtv_stream
 
 	/* empty q_free */
 	while ((buf = ivtv_dequeue(s, &s->q_free))) {
-		if (s->dma != PCI_DMA_NONE)
+		if (ivtv_might_use_dma(s))
 			pci_unmap_single(s->itv->dev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 		kfree(buf->buf);
@@ -256,6 +268,9 @@ void ivtv_stream_free(struct ivtv_stream
 				 sizeof(struct ivtv_SG_element) * s->buffers, PCI_DMA_TODEVICE);
 			s->SG_handle = IVTV_DMA_UNMAPPED;
 		}
+		kfree(s->SGarray);
+		kfree(s->PIOarray);
+		s->PIOarray = NULL;
 		s->SGarray = NULL;
 		s->SG_length = 0;
 	}
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-queue.h linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-queue.h
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-queue.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-queue.h	2007-06-14 14:14:33.000000000 -0400
@@ -20,18 +20,43 @@
  */
 
 #define IVTV_DMA_UNMAPPED	((u32) -1)
+#define SLICED_VBI_PIO 1
 
 /* ivtv_buffer utility functions */
+
+static inline int ivtv_might_use_pio(struct ivtv_stream *s)
+{
+	return s->dma == PCI_DMA_NONE || (SLICED_VBI_PIO && s->type == IVTV_ENC_STREAM_TYPE_VBI);
+}
+
+static inline int ivtv_use_pio(struct ivtv_stream *s)
+{
+	struct ivtv *itv = s->itv;
+
+	return s->dma == PCI_DMA_NONE ||
+	    (SLICED_VBI_PIO && s->type == IVTV_ENC_STREAM_TYPE_VBI && itv->vbi.sliced_in->service_set);
+}
+
+static inline int ivtv_might_use_dma(struct ivtv_stream *s)
+{
+	return s->dma != PCI_DMA_NONE;
+}
+
+static inline int ivtv_use_dma(struct ivtv_stream *s)
+{
+	return !ivtv_use_pio(s);
+}
+
 static inline void ivtv_buf_sync_for_cpu(struct ivtv_stream *s, struct ivtv_buffer *buf)
 {
-	if (s->dma != PCI_DMA_NONE)
+	if (ivtv_use_dma(s))
 		pci_dma_sync_single_for_cpu(s->itv->dev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 }
 
 static inline void ivtv_buf_sync_for_device(struct ivtv_stream *s, struct ivtv_buffer *buf)
 {
-	if (s->dma != PCI_DMA_NONE)
+	if (ivtv_use_dma(s))
 		pci_dma_sync_single_for_device(s->itv->dev, buf->dma_handle,
 				s->buf_size + 256, s->dma);
 }
@@ -53,12 +78,14 @@ void ivtv_stream_free(struct ivtv_stream
 
 static inline void ivtv_stream_sync_for_cpu(struct ivtv_stream *s)
 {
-	pci_dma_sync_single_for_cpu(s->itv->dev, s->SG_handle,
-		sizeof(struct ivtv_SG_element) * s->buffers, PCI_DMA_TODEVICE);
+	if (ivtv_use_dma(s))
+		pci_dma_sync_single_for_cpu(s->itv->dev, s->SG_handle,
+			sizeof(struct ivtv_SG_element) * s->buffers, PCI_DMA_TODEVICE);
 }
 
 static inline void ivtv_stream_sync_for_device(struct ivtv_stream *s)
 {
-	pci_dma_sync_single_for_device(s->itv->dev, s->SG_handle,
-		sizeof(struct ivtv_SG_element) * s->buffers, PCI_DMA_TODEVICE);
+	if (ivtv_use_dma(s))
+		pci_dma_sync_single_for_device(s->itv->dev, s->SG_handle,
+			sizeof(struct ivtv_SG_element) * s->buffers, PCI_DMA_TODEVICE);
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-streams.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-streams.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-streams.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-streams.c	2007-06-14 14:14:33.000000000 -0400
@@ -868,7 +868,7 @@ int ivtv_stop_v4l2_decode_stream(struct 
 	if (!test_bit(IVTV_F_S_STREAMING, &s->s_flags))
 		return 0;
 
-	IVTV_DEBUG_INFO("Stop Decode at %llu, flags: %x\n", pts, flags);
+	IVTV_DEBUG_INFO("Stop Decode at %llu, flags: %x\n", (unsigned long long)pts, flags);
 
 	/* Stop Decoder */
 	if (!(flags & VIDEO_CMD_STOP_IMMEDIATELY) || pts) {
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-vbi.c linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-vbi.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-vbi.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-vbi.c	2007-06-14 14:14:33.000000000 -0400
@@ -450,7 +450,7 @@ void ivtv_disable_vbi(struct ivtv *itv)
 }
 
 
-void vbi_work_handler(struct ivtv *itv)
+void ivtv_vbi_work_handler(struct ivtv *itv)
 {
 	struct v4l2_sliced_vbi_data data;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-vbi.h linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-vbi.h
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/ivtv/ivtv-vbi.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/ivtv/ivtv-vbi.h	2007-06-14 14:14:33.000000000 -0400
@@ -23,4 +23,4 @@ void ivtv_process_vbi_data(struct ivtv *
 int ivtv_used_line(struct ivtv *itv, int line, int field);
 void ivtv_disable_vbi(struct ivtv *itv);
 void ivtv_set_vbi(unsigned long arg);
-void vbi_work_handler(struct ivtv *itv);
+void ivtv_vbi_work_handler(struct ivtv *itv);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/Kconfig linux-2.6.22-rc4-git6/drivers/media/video/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/Kconfig	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -347,7 +347,7 @@ endmenu # encoder / decoder chips
 
 config VIDEO_VIVI
 	tristate "Virtual Video Driver"
-	depends on VIDEO_V4L2 && !SPARC32 && !SPARC64 && PCI
+	depends on VIDEO_V4L2 && !SPARC32 && !SPARC64 && PCI && VIDEO_DEV
 	select VIDEO_BUF
 	default n
 	---help---
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/saa7111.c linux-2.6.22-rc4-git6/drivers/media/video/saa7111.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/saa7111.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/saa7111.c	2007-06-14 14:14:33.000000000 -0400
@@ -75,10 +75,6 @@ struct saa7111 {
 	int norm;
 	int input;
 	int enable;
-	int bright;
-	int contrast;
-	int hue;
-	int sat;
 };
 
 #define   I2C_SAA7111        0x48
@@ -96,6 +92,17 @@ saa7111_write (struct i2c_client *client
 	return i2c_smbus_write_byte_data(client, reg, value);
 }
 
+static inline void
+saa7111_write_if_changed(struct i2c_client *client, u8 reg, u8 value)
+{
+	struct saa7111 *decoder = i2c_get_clientdata(client);
+
+	if (decoder->reg[reg] != value) {
+		decoder->reg[reg] = value;
+		i2c_smbus_write_byte_data(client, reg, value);
+	}
+}
+
 static int
 saa7111_write_block (struct i2c_client *client,
 		     const u8          *data,
@@ -439,28 +446,14 @@ saa7111_command (struct i2c_client *clie
 	{
 		struct video_picture *pic = arg;
 
-		if (decoder->bright != pic->brightness) {
-			/* We want 0 to 255 we get 0-65535 */
-			decoder->bright = pic->brightness;
-			saa7111_write(client, 0x0a, decoder->bright >> 8);
-		}
-		if (decoder->contrast != pic->contrast) {
-			/* We want 0 to 127 we get 0-65535 */
-			decoder->contrast = pic->contrast;
-			saa7111_write(client, 0x0b,
-				      decoder->contrast >> 9);
-		}
-		if (decoder->sat != pic->colour) {
-			/* We want 0 to 127 we get 0-65535 */
-			decoder->sat = pic->colour;
-			saa7111_write(client, 0x0c, decoder->sat >> 9);
-		}
-		if (decoder->hue != pic->hue) {
-			/* We want -128 to 127 we get 0-65535 */
-			decoder->hue = pic->hue;
-			saa7111_write(client, 0x0d,
-				      (decoder->hue - 32768) >> 8);
-		}
+		/* We want 0 to 255 we get 0-65535 */
+		saa7111_write_if_changed(client, 0x0a, pic->brightness >> 8);
+		/* We want 0 to 127 we get 0-65535 */
+		saa7111_write(client, 0x0b, pic->contrast >> 9);
+		/* We want 0 to 127 we get 0-65535 */
+		saa7111_write(client, 0x0c, pic->colour >> 9);
+		/* We want -128 to 127 we get 0-65535 */
+		saa7111_write(client, 0x0d, (pic->hue - 32768) >> 8);
 	}
 		break;
 
@@ -524,10 +517,6 @@ saa7111_detect_client (struct i2c_adapte
 	decoder->norm = VIDEO_MODE_NTSC;
 	decoder->input = 0;
 	decoder->enable = 1;
-	decoder->bright = 32768;
-	decoder->contrast = 32768;
-	decoder->hue = 32768;
-	decoder->sat = 32768;
 	i2c_set_clientdata(client, decoder);
 
 	i = i2c_attach_client(client);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/usbvision/usbvision-core.c linux-2.6.22-rc4-git6/drivers/media/video/usbvision/usbvision-core.c
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/usbvision/usbvision-core.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/usbvision/usbvision-core.c	2007-06-14 14:14:33.000000000 -0400
@@ -1414,6 +1414,11 @@ static void usbvision_isocIrq(struct urb
 	if (!USBVISION_IS_OPERATIONAL(usbvision))
 		return;
 
+	/* any urb with wrong status is ignored without acknowledgement */
+	if (urb->status == -ENOENT) {
+		return;
+	}
+
 	f = &usbvision->curFrame;
 
 	/* Manage streaming interruption */
@@ -1436,18 +1441,21 @@ static void usbvision_isocIrq(struct urb
 	if (usbvision->streaming == Stream_On) {
 
 		/* If we collected enough data let's parse! */
-		if (scratch_len(usbvision) > USBVISION_HEADER_LENGTH) {	/* 12 == header_length */
-			/*If we don't have a frame we're current working on, complain */
-			if(!list_empty(&(usbvision->inqueue))) {
-				if (!(*f)) {
-					(*f) = list_entry(usbvision->inqueue.next,struct usbvision_frame, frame);
-				}
-				usbvision_parse_data(usbvision);
-			}
-			else {
-				PDEBUG(DBG_IRQ, "received data, but no one needs it");
-				scratch_reset(usbvision);
+		if ((scratch_len(usbvision) > USBVISION_HEADER_LENGTH) &&
+		    (!list_empty(&(usbvision->inqueue))) ) {
+			if (!(*f)) {
+				(*f) = list_entry(usbvision->inqueue.next,
+						  struct usbvision_frame,
+						  frame);
 			}
+			usbvision_parse_data(usbvision);
+		}
+		else {
+			/*If we don't have a frame
+			  we're current working on, complain */
+			PDEBUG(DBG_IRQ,
+			       "received data, but no one needs it");
+			scratch_reset(usbvision);
 		}
 	}
 	else {
@@ -1466,10 +1474,10 @@ static void usbvision_isocIrq(struct urb
 	urb->dev = usbvision->dev;
 	errCode = usb_submit_urb (urb, GFP_ATOMIC);
 
-	/* Disable this warning.  By design of the driver. */
-	//	if(errCode) {
-	//		err("%s: usb_submit_urb failed: error %d", __FUNCTION__, errCode);
-	//	}
+	if(errCode) {
+		err("%s: usb_submit_urb failed: error %d",
+		    __FUNCTION__, errCode);
+	}
 
 	return;
 }
@@ -2394,7 +2402,7 @@ int usbvision_init_isoc(struct usb_usbvi
 {
 	struct usb_device *dev = usbvision->dev;
 	int bufIdx, errCode, regValue;
-	const int sb_size = USBVISION_URB_FRAMES * USBVISION_MAX_ISOC_PACKET_SIZE;
+	int sb_size;
 
 	if (!USBVISION_IS_OPERATIONAL(usbvision))
 		return -EFAULT;
@@ -2408,11 +2416,14 @@ int usbvision_init_isoc(struct usb_usbvi
 		usbvision->last_error = errCode;
 		return -EBUSY;
 	}
+	sb_size = USBVISION_URB_FRAMES * usbvision->isocPacketSize;
 
-	regValue = (16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;
+	regValue = (16 - usbvision_read_reg(usbvision,
+					    USBVISION_ALTER_REG)) & 0x0F;
 
 	usbvision->usb_bandwidth = regValue >> 1;
-	PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec", usbvision->usb_bandwidth);
+	PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec",
+	       usbvision->usb_bandwidth);
 
 
 
@@ -2428,7 +2439,11 @@ int usbvision_init_isoc(struct usb_usbvi
 			return -ENOMEM;
 		}
 		usbvision->sbuf[bufIdx].urb = urb;
-		usbvision->sbuf[bufIdx].data = usb_buffer_alloc(usbvision->dev, sb_size, GFP_KERNEL,&urb->transfer_dma);
+		usbvision->sbuf[bufIdx].data =
+			usb_buffer_alloc(usbvision->dev,
+					 sb_size,
+					 GFP_KERNEL,
+					 &urb->transfer_dma);
 		urb->dev = dev;
 		urb->context = usbvision;
 		urb->pipe = usb_rcvisocpipe(dev, usbvision->video_endp);
@@ -2442,21 +2457,26 @@ int usbvision_init_isoc(struct usb_usbvi
 		for (j = k = 0; j < USBVISION_URB_FRAMES; j++,
 		     k += usbvision->isocPacketSize) {
 			urb->iso_frame_desc[j].offset = k;
-			urb->iso_frame_desc[j].length = usbvision->isocPacketSize;
+			urb->iso_frame_desc[j].length =
+				usbvision->isocPacketSize;
 		}
 	}
 
 
 	/* Submit all URBs */
 	for (bufIdx = 0; bufIdx < USBVISION_NUMSBUF; bufIdx++) {
-			errCode = usb_submit_urb(usbvision->sbuf[bufIdx].urb, GFP_KERNEL);
+			errCode = usb_submit_urb(usbvision->sbuf[bufIdx].urb,
+						 GFP_KERNEL);
 		if (errCode) {
-			err("%s: usb_submit_urb(%d) failed: error %d", __FUNCTION__, bufIdx, errCode);
+			err("%s: usb_submit_urb(%d) failed: error %d",
+			    __FUNCTION__, bufIdx, errCode);
 		}
 	}
 
 	usbvision->streaming = Stream_Idle;
-	PDEBUG(DBG_ISOC, "%s: streaming=1 usbvision->video_endp=$%02x", __FUNCTION__, usbvision->video_endp);
+	PDEBUG(DBG_ISOC, "%s: streaming=1 usbvision->video_endp=$%02x",
+	       __FUNCTION__,
+	       usbvision->video_endp);
 	return 0;
 }
 
@@ -2470,7 +2490,7 @@ int usbvision_init_isoc(struct usb_usbvi
 void usbvision_stop_isoc(struct usb_usbvision *usbvision)
 {
 	int bufIdx, errCode, regValue;
-	const int sb_size = USBVISION_URB_FRAMES * USBVISION_MAX_ISOC_PACKET_SIZE;
+	int sb_size = USBVISION_URB_FRAMES * usbvision->isocPacketSize;
 
 	if ((usbvision->streaming == Stream_Off) || (usbvision->dev == NULL))
 		return;
@@ -2499,15 +2519,19 @@ void usbvision_stop_isoc(struct usb_usbv
 		errCode = usb_set_interface(usbvision->dev, usbvision->iface,
 					    usbvision->ifaceAlt);
 		if (errCode < 0) {
-			err("%s: usb_set_interface() failed: error %d", __FUNCTION__, errCode);
+			err("%s: usb_set_interface() failed: error %d",
+			    __FUNCTION__, errCode);
 			usbvision->last_error = errCode;
 		}
-		regValue = (16 - usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;
-		usbvision->isocPacketSize = (regValue == 0) ? 0 : (regValue * 64) - 1;
-		PDEBUG(DBG_ISOC, "ISO Packet Length:%d", usbvision->isocPacketSize);
+		regValue = (16-usbvision_read_reg(usbvision, USBVISION_ALTER_REG)) & 0x0F;
+		usbvision->isocPacketSize =
+			(regValue == 0) ? 0 : (regValue * 64) - 1;
+		PDEBUG(DBG_ISOC, "ISO Packet Length:%d",
+		       usbvision->isocPacketSize);
 
 		usbvision->usb_bandwidth = regValue >> 1;
-		PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec", usbvision->usb_bandwidth);
+		PDEBUG(DBG_ISOC, "USB Bandwidth Usage: %dMbit/Sec",
+		       usbvision->usb_bandwidth);
 	}
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/media/video/usbvision/usbvision.h linux-2.6.22-rc4-git6/drivers/media/video/usbvision/usbvision.h
--- linux-2.6.22-rc4-git3.orig/drivers/media/video/usbvision/usbvision.h	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/media/video/usbvision/usbvision.h	2007-06-14 14:14:33.000000000 -0400
@@ -146,7 +146,6 @@
 #define USBVISION_CLIPMASK_SIZE		(MAX_FRAME_WIDTH * MAX_FRAME_HEIGHT / 8) //bytesize of clipmask
 
 #define USBVISION_URB_FRAMES		32
-#define USBVISION_MAX_ISOC_PACKET_SIZE 	959			// NT1003 Specs Document says 1023
 
 #define USBVISION_NUM_HEADERMARKER	20
 #define USBVISION_NUMFRAMES		3  /* Maximum number of frames an application can get */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/mmc/core/sd.c linux-2.6.22-rc4-git6/drivers/mmc/core/sd.c
--- linux-2.6.22-rc4-git3.orig/drivers/mmc/core/sd.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/mmc/core/sd.c	2007-06-14 14:14:33.000000000 -0400
@@ -15,6 +15,7 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
 
 #include "core.h"
 #include "sysfs.h"
@@ -192,6 +193,16 @@ static int mmc_read_switch(struct mmc_ca
 	int err;
 	u8 *status;
 
+	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
+		return MMC_ERR_NONE;
+
+	if (!(card->csd.cmdclass & CCC_SWITCH)) {
+		printk(KERN_WARNING "%s: card lacks mandatory switch "
+			"function, performance might suffer.\n",
+			mmc_hostname(card->host));
+		return MMC_ERR_NONE;
+	}
+
 	err = MMC_ERR_FAILED;
 
 	status = kmalloc(64, GFP_KERNEL);
@@ -204,10 +215,9 @@ static int mmc_read_switch(struct mmc_ca
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err != MMC_ERR_NONE) {
-		/*
-		 * Card not supporting high-speed will ignore the
-		 * command.
-		 */
+		printk(KERN_WARNING "%s: problem reading switch "
+			"capabilities, performance might suffer.\n",
+			mmc_hostname(card->host));
 		err = MMC_ERR_NONE;
 		goto out;
 	}
@@ -229,6 +239,12 @@ static int mmc_switch_hs(struct mmc_card
 	int err;
 	u8 *status;
 
+	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
+		return MMC_ERR_NONE;
+
+	if (!(card->csd.cmdclass & CCC_SWITCH))
+		return MMC_ERR_NONE;
+
 	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
 		return MMC_ERR_NONE;
 
@@ -402,7 +418,7 @@ static int mmc_sd_init_card(struct mmc_h
 	/*
 	 * Switch to wider bus (if supported).
 	 */
-	if ((host->caps && MMC_CAP_4_BIT_DATA) &&
+	if ((host->caps & MMC_CAP_4_BIT_DATA) &&
 		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
 		err = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);
 		if (err != MMC_ERR_NONE)
@@ -411,6 +427,21 @@ static int mmc_sd_init_card(struct mmc_h
 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
 	}
 
+	/*
+	 * Check if read-only switch is active.
+	 */
+	if (!oldcard) {
+		if (!host->ops->get_ro) {
+			printk(KERN_WARNING "%s: host does not "
+				"support reading read-only "
+				"switch. assuming write-enable.\n",
+				mmc_hostname(host));
+		} else {
+			if (host->ops->get_ro(host))
+				mmc_card_set_readonly(card);
+		}
+	}
+
 	if (!oldcard)
 		host->card = card;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/mmc/host/at91_mci.c linux-2.6.22-rc4-git6/drivers/mmc/host/at91_mci.c
--- linux-2.6.22-rc4-git3.orig/drivers/mmc/host/at91_mci.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/mmc/host/at91_mci.c	2007-06-14 14:14:33.000000000 -0400
@@ -417,7 +417,7 @@ static unsigned int at91_mci_send_comman
 		blocks = 0;
 	}
 
-	if (cmd->opcode == MMC_STOP_TRANSMISSION)
+	if (host->flags & FL_SENT_STOP)
 		cmdr |= AT91_MCI_TRCMD_STOP;
 
 	if (host->bus_mode == MMC_BUSMODE_OPENDRAIN)
@@ -563,8 +563,7 @@ static void at91mci_completed_command(st
 	if (status & (AT91_MCI_RINDE | AT91_MCI_RDIRE | AT91_MCI_RCRCE |
 			AT91_MCI_RENDE | AT91_MCI_RTOE | AT91_MCI_DCRCE |
 			AT91_MCI_DTOE | AT91_MCI_OVRE | AT91_MCI_UNRE)) {
-		if ((status & AT91_MCI_RCRCE) &&
-			((cmd->opcode == MMC_SEND_OP_COND) || (cmd->opcode == SD_APP_OP_COND))) {
+		if ((status & AT91_MCI_RCRCE) && !(mmc_resp_type(cmd) & MMC_RSP_CRC)) {
 			cmd->error = MMC_ERR_NONE;
 		}
 		else {
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/mmc/host/au1xmmc.c linux-2.6.22-rc4-git6/drivers/mmc/host/au1xmmc.c
--- linux-2.6.22-rc4-git3.orig/drivers/mmc/host/au1xmmc.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/mmc/host/au1xmmc.c	2007-06-14 14:14:33.000000000 -0400
@@ -76,8 +76,7 @@ const struct {
 #endif
 };
 
-#define AU1XMMC_CONTROLLER_COUNT \
-	(sizeof(au1xmmc_card_table) / sizeof(au1xmmc_card_table[0]))
+#define AU1XMMC_CONTROLLER_COUNT (ARRAY_SIZE(au1xmmc_card_table))
 
 /* This array stores pointers for the hosts (used by the IRQ handler) */
 struct au1xmmc_host *au1xmmc_hosts[AU1XMMC_CONTROLLER_COUNT];
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/mmc/host/omap.c linux-2.6.22-rc4-git6/drivers/mmc/host/omap.c
--- linux-2.6.22-rc4-git3.orig/drivers/mmc/host/omap.c	2007-06-08 12:08:20.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/mmc/host/omap.c	2007-06-14 14:14:33.000000000 -0400
@@ -522,28 +522,10 @@ static irqreturn_t mmc_omap_irq(int irq,
 		}
 
 		if (status & OMAP_MMC_STAT_CARD_ERR) {
-			if (host->cmd && host->cmd->opcode == MMC_STOP_TRANSMISSION) {
-				u32 response = OMAP_MMC_READ(host, RSP6)
-					| (OMAP_MMC_READ(host, RSP7) << 16);
-				/* STOP sometimes sets must-ignore bits */
-				if (!(response & (R1_CC_ERROR
-								| R1_ILLEGAL_COMMAND
-								| R1_COM_CRC_ERROR))) {
-					end_command = 1;
-					continue;
-				}
-			}
-
-			dev_dbg(mmc_dev(host->mmc), "card status error (CMD%d)\n",
+			dev_dbg(mmc_dev(host->mmc),
+				"ignoring card status error (CMD%d)\n",
 				host->cmd->opcode);
-			if (host->cmd) {
-				host->cmd->error = MMC_ERR_FAILED;
-				end_command = 1;
-			}
-			if (host->data) {
-				host->data->error = MMC_ERR_FAILED;
-				transfer_error = 1;
-			}
+			end_command = 1;
 		}
 
 		/*
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/e100.c linux-2.6.22-rc4-git6/drivers/net/e100.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/e100.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/e100.c	2007-06-14 14:14:33.000000000 -0400
@@ -285,6 +285,12 @@ enum scb_status {
 	rus_mask         = 0x3C,
 };
 
+enum ru_state  {
+	RU_SUSPENDED = 0,
+	RU_RUNNING	 = 1,
+	RU_UNINITIALIZED = -1,
+};
+
 enum scb_stat_ack {
 	stat_ack_not_ours    = 0x00,
 	stat_ack_sw_gen      = 0x04,
@@ -526,6 +532,7 @@ struct nic {
 	struct rx *rx_to_use;
 	struct rx *rx_to_clean;
 	struct rfd blank_rfd;
+	enum ru_state ru_running;
 
 	spinlock_t cb_lock			____cacheline_aligned;
 	spinlock_t cmd_lock;
@@ -947,7 +954,7 @@ static void e100_get_defaults(struct nic
 		((nic->mac >= mac_82558_D101_A4) ? cb_cid : cb_i));
 
 	/* Template for a freshly allocated RFD */
-	nic->blank_rfd.command = cpu_to_le16(cb_el & cb_s);
+	nic->blank_rfd.command = cpu_to_le16(cb_el);
 	nic->blank_rfd.rbd = 0xFFFFFFFF;
 	nic->blank_rfd.size = cpu_to_le16(VLAN_ETH_FRAME_LEN);
 
@@ -1742,11 +1749,19 @@ static int e100_alloc_cbs(struct nic *ni
 	return 0;
 }
 
-static inline void e100_start_receiver(struct nic *nic)
+static inline void e100_start_receiver(struct nic *nic, struct rx *rx)
 {
-	/* Start if RFA is non-NULL */
-	if(nic->rx_to_clean->skb)
-		e100_exec_cmd(nic, ruc_start, nic->rx_to_clean->dma_addr);
+	if(!nic->rxs) return;
+	if(RU_SUSPENDED != nic->ru_running) return;
+
+	/* handle init time starts */
+	if(!rx) rx = nic->rxs;
+
+	/* (Re)start RU if suspended or idle and RFA is non-NULL */
+	if(rx->skb) {
+		e100_exec_cmd(nic, ruc_start, rx->dma_addr);
+		nic->ru_running = RU_RUNNING;
+	}
 }
 
 #define RFD_BUF_LEN (sizeof(struct rfd) + VLAN_ETH_FRAME_LEN)
@@ -1775,7 +1790,7 @@ static int e100_rx_alloc_skb(struct nic 
 		put_unaligned(cpu_to_le32(rx->dma_addr),
 			(u32 *)&prev_rfd->link);
 		wmb();
-		prev_rfd->command &= ~cpu_to_le16(cb_el & cb_s);
+		prev_rfd->command &= ~cpu_to_le16(cb_el);
 		pci_dma_sync_single_for_device(nic->pdev, rx->prev->dma_addr,
 			sizeof(struct rfd), PCI_DMA_TODEVICE);
 	}
@@ -1813,6 +1828,10 @@ static int e100_rx_indicate(struct nic *
 	pci_unmap_single(nic->pdev, rx->dma_addr,
 		RFD_BUF_LEN, PCI_DMA_FROMDEVICE);
 
+	/* this allows for a fast restart without re-enabling interrupts */
+	if(le16_to_cpu(rfd->command) & cb_el)
+		nic->ru_running = RU_SUSPENDED;
+
 	/* Pull off the RFD and put the actual data (minus eth hdr) */
 	skb_reserve(skb, sizeof(struct rfd));
 	skb_put(skb, actual_size);
@@ -1843,18 +1862,45 @@ static void e100_rx_clean(struct nic *ni
 	unsigned int work_to_do)
 {
 	struct rx *rx;
+	int restart_required = 0;
+	struct rx *rx_to_start = NULL;
+
+	/* are we already rnr? then pay attention!!! this ensures that
+	 * the state machine progression never allows a start with a
+	 * partially cleaned list, avoiding a race between hardware
+	 * and rx_to_clean when in NAPI mode */
+	if(RU_SUSPENDED == nic->ru_running)
+		restart_required = 1;
 
 	/* Indicate newly arrived packets */
 	for(rx = nic->rx_to_clean; rx->skb; rx = nic->rx_to_clean = rx->next) {
-		if(e100_rx_indicate(nic, rx, work_done, work_to_do))
+		int err = e100_rx_indicate(nic, rx, work_done, work_to_do);
+		if(-EAGAIN == err) {
+			/* hit quota so have more work to do, restart once
+			 * cleanup is complete */
+			restart_required = 0;
+			break;
+		} else if(-ENODATA == err)
 			break; /* No more to clean */
 	}
 
+	/* save our starting point as the place we'll restart the receiver */
+	if(restart_required)
+		rx_to_start = nic->rx_to_clean;
+
 	/* Alloc new skbs to refill list */
 	for(rx = nic->rx_to_use; !rx->skb; rx = nic->rx_to_use = rx->next) {
 		if(unlikely(e100_rx_alloc_skb(nic, rx)))
 			break; /* Better luck next time (see watchdog) */
 	}
+
+	if(restart_required) {
+		// ack the rnr?
+		writeb(stat_ack_rnr, &nic->csr->scb.stat_ack);
+		e100_start_receiver(nic, rx_to_start);
+		if(work_done)
+			(*work_done)++;
+	}
 }
 
 static void e100_rx_clean_list(struct nic *nic)
@@ -1862,6 +1908,8 @@ static void e100_rx_clean_list(struct ni
 	struct rx *rx;
 	unsigned int i, count = nic->params.rfds.count;
 
+	nic->ru_running = RU_UNINITIALIZED;
+
 	if(nic->rxs) {
 		for(rx = nic->rxs, i = 0; i < count; rx++, i++) {
 			if(rx->skb) {
@@ -1883,6 +1931,7 @@ static int e100_rx_alloc_list(struct nic
 	unsigned int i, count = nic->params.rfds.count;
 
 	nic->rx_to_use = nic->rx_to_clean = NULL;
+	nic->ru_running = RU_UNINITIALIZED;
 
 	if(!(nic->rxs = kcalloc(count, sizeof(struct rx), GFP_ATOMIC)))
 		return -ENOMEM;
@@ -1897,6 +1946,7 @@ static int e100_rx_alloc_list(struct nic
 	}
 
 	nic->rx_to_use = nic->rx_to_clean = nic->rxs;
+	nic->ru_running = RU_SUSPENDED;
 
 	return 0;
 }
@@ -1916,6 +1966,10 @@ static irqreturn_t e100_intr(int irq, vo
 	/* Ack interrupt(s) */
 	iowrite8(stat_ack, &nic->csr->scb.stat_ack);
 
+	/* We hit Receive No Resource (RNR); restart RU after cleaning */
+	if(stat_ack & stat_ack_rnr)
+		nic->ru_running = RU_SUSPENDED;
+
 	if(likely(netif_rx_schedule_prep(netdev))) {
 		e100_disable_irq(nic);
 		__netif_rx_schedule(netdev);
@@ -2007,7 +2061,7 @@ static int e100_up(struct nic *nic)
 	if((err = e100_hw_init(nic)))
 		goto err_clean_cbs;
 	e100_set_multicast_list(nic->netdev);
-	e100_start_receiver(nic);
+	e100_start_receiver(nic, NULL);
 	mod_timer(&nic->watchdog, jiffies);
 	if((err = request_irq(nic->pdev->irq, e100_intr, IRQF_SHARED,
 		nic->netdev->name, nic->netdev)))
@@ -2088,7 +2142,7 @@ static int e100_loopback_test(struct nic
 		mdio_write(nic->netdev, nic->mii.phy_id, MII_BMCR,
 			BMCR_LOOPBACK);
 
-	e100_start_receiver(nic);
+	e100_start_receiver(nic, NULL);
 
 	if(!(skb = netdev_alloc_skb(nic->netdev, ETH_DATA_LEN))) {
 		err = -ENOMEM;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/ehea/ehea.h linux-2.6.22-rc4-git6/drivers/net/ehea/ehea.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/ehea/ehea.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/ehea/ehea.h	2007-06-14 14:14:33.000000000 -0400
@@ -39,7 +39,7 @@
 #include <asm/io.h>
 
 #define DRV_NAME	"ehea"
-#define DRV_VERSION	"EHEA_0061"
+#define DRV_VERSION	"EHEA_0064"
 
 #define EHEA_MSG_DEFAULT (NETIF_MSG_LINK | NETIF_MSG_TIMER \
 	| NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/ehea/ehea_main.c linux-2.6.22-rc4-git6/drivers/net/ehea/ehea_main.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/ehea/ehea_main.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/ehea/ehea_main.c	2007-06-14 14:14:33.000000000 -0400
@@ -451,7 +451,8 @@ static struct ehea_cqe *ehea_proc_rwqes(
 				processed_rq3++;
 			}
 
-			if (cqe->status & EHEA_CQE_VLAN_TAG_XTRACT)
+			if ((cqe->status & EHEA_CQE_VLAN_TAG_XTRACT)
+			    && port->vgrp)
 				vlan_hwaccel_receive_skb(skb, port->vgrp,
 							 cqe->vlan_tag);
 			else
@@ -1910,10 +1911,7 @@ static void ehea_vlan_rx_register(struct
 		goto out;
 	}
 
-	if (grp)
-		memset(cb1->vlan_filter, 0, sizeof(cb1->vlan_filter));
-	else
-		memset(cb1->vlan_filter, 0xFF, sizeof(cb1->vlan_filter));
+	memset(cb1->vlan_filter, 0, sizeof(cb1->vlan_filter));
 
 	hret = ehea_h_modify_ehea_port(adapter->handle, port->logical_port_id,
 				       H_PORT_CB1, H_PORT_CB1_ALL, cb1);
@@ -1947,7 +1945,7 @@ static void ehea_vlan_rx_add_vid(struct 
 	}
 
 	index = (vid / 64);
-	cb1->vlan_filter[index] |= ((u64)(1 << (vid & 0x3F)));
+	cb1->vlan_filter[index] |= ((u64)(0x8000000000000000 >> (vid & 0x3F)));
 
 	hret = ehea_h_modify_ehea_port(adapter->handle, port->logical_port_id,
 				       H_PORT_CB1, H_PORT_CB1_ALL, cb1);
@@ -1982,7 +1980,7 @@ static void ehea_vlan_rx_kill_vid(struct
 	}
 
 	index = (vid / 64);
-	cb1->vlan_filter[index] &= ~((u64)(1 << (vid & 0x3F)));
+	cb1->vlan_filter[index] &= ~((u64)(0x8000000000000000 >> (vid & 0x3F)));
 
 	hret = ehea_h_modify_ehea_port(adapter->handle, port->logical_port_id,
 				       H_PORT_CB1, H_PORT_CB1_ALL, cb1);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/ibmveth.c linux-2.6.22-rc4-git6/drivers/net/ibmveth.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/ibmveth.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/ibmveth.c	2007-06-14 14:14:33.000000000 -0400
@@ -915,17 +915,36 @@ static int ibmveth_change_mtu(struct net
 {
 	struct ibmveth_adapter *adapter = dev->priv;
 	int new_mtu_oh = new_mtu + IBMVETH_BUFF_OH;
-	int i;
+	int reinit = 0;
+	int i, rc;
 
 	if (new_mtu < IBMVETH_MAX_MTU)
 		return -EINVAL;
 
+	for (i = 0; i < IbmVethNumBufferPools; i++)
+		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size)
+			break;
+
+	if (i == IbmVethNumBufferPools)
+		return -EINVAL;
+
 	/* Look for an active buffer pool that can hold the new MTU */
 	for(i = 0; i<IbmVethNumBufferPools; i++) {
-		if (!adapter->rx_buff_pool[i].active)
-			continue;
+		if (!adapter->rx_buff_pool[i].active) {
+			adapter->rx_buff_pool[i].active = 1;
+			reinit = 1;
+		}
+
 		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size) {
-			dev->mtu = new_mtu;
+			if (reinit && netif_running(adapter->netdev)) {
+				adapter->pool_config = 1;
+				ibmveth_close(adapter->netdev);
+				adapter->pool_config = 0;
+				dev->mtu = new_mtu;
+				if ((rc = ibmveth_open(adapter->netdev)))
+					return rc;
+			} else
+				dev->mtu = new_mtu;
 			return 0;
 		}
 	}
@@ -1243,16 +1262,19 @@ const char * buf, size_t count)
 
 	if (attr == &veth_active_attr) {
 		if (value && !pool->active) {
-			if(ibmveth_alloc_buffer_pool(pool)) {
-                                ibmveth_error_printk("unable to alloc pool\n");
-                                return -ENOMEM;
-                        }
-			pool->active = 1;
-			adapter->pool_config = 1;
-			ibmveth_close(netdev);
-			adapter->pool_config = 0;
-			if ((rc = ibmveth_open(netdev)))
-				return rc;
+			if (netif_running(netdev)) {
+				if(ibmveth_alloc_buffer_pool(pool)) {
+					ibmveth_error_printk("unable to alloc pool\n");
+					return -ENOMEM;
+				}
+				pool->active = 1;
+				adapter->pool_config = 1;
+				ibmveth_close(netdev);
+				adapter->pool_config = 0;
+				if ((rc = ibmveth_open(netdev)))
+					return rc;
+			} else
+				pool->active = 1;
 		} else if (!value && pool->active) {
 			int mtu = netdev->mtu + IBMVETH_BUFF_OH;
 			int i;
@@ -1281,23 +1303,29 @@ const char * buf, size_t count)
 		if (value <= 0 || value > IBMVETH_MAX_POOL_COUNT)
 			return -EINVAL;
 		else {
-			adapter->pool_config = 1;
-			ibmveth_close(netdev);
-			adapter->pool_config = 0;
-			pool->size = value;
-			if ((rc = ibmveth_open(netdev)))
-				return rc;
+			if (netif_running(netdev)) {
+				adapter->pool_config = 1;
+				ibmveth_close(netdev);
+				adapter->pool_config = 0;
+				pool->size = value;
+				if ((rc = ibmveth_open(netdev)))
+					return rc;
+			} else
+				pool->size = value;
 		}
 	} else if (attr == &veth_size_attr) {
 		if (value <= IBMVETH_BUFF_OH || value > IBMVETH_MAX_BUF_SIZE)
 			return -EINVAL;
 		else {
-			adapter->pool_config = 1;
-			ibmveth_close(netdev);
-			adapter->pool_config = 0;
-			pool->buff_size = value;
-			if ((rc = ibmveth_open(netdev)))
-				return rc;
+			if (netif_running(netdev)) {
+				adapter->pool_config = 1;
+				ibmveth_close(netdev);
+				adapter->pool_config = 0;
+				pool->buff_size = value;
+				if ((rc = ibmveth_open(netdev)))
+					return rc;
+			} else
+				pool->buff_size = value;
 		}
 	}
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/cq.c linux-2.6.22-rc4-git6/drivers/net/mlx4/cq.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/cq.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/cq.c	2007-06-14 14:14:33.000000000 -0400
@@ -61,7 +61,7 @@ struct mlx4_cq_context {
 	__be32			solicit_producer_index;
 	__be32			consumer_index;
 	__be32			producer_index;
-	u8			reserved6[2];
+	u32			reserved6[2];
 	__be64			db_rec_addr;
 };
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/eq.c linux-2.6.22-rc4-git6/drivers/net/mlx4/eq.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/eq.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/eq.c	2007-06-14 14:14:33.000000000 -0400
@@ -490,9 +490,11 @@ static void mlx4_free_irqs(struct mlx4_d
 
 	if (eq_table->have_irq)
 		free_irq(dev->pdev->irq, dev);
-	for (i = 0; i < MLX4_NUM_EQ; ++i)
+	for (i = 0; i < MLX4_EQ_CATAS; ++i)
 		if (eq_table->eq[i].have_irq)
 			free_irq(eq_table->eq[i].irq, eq_table->eq + i);
+	if (eq_table->eq[MLX4_EQ_CATAS].have_irq)
+		free_irq(eq_table->eq[MLX4_EQ_CATAS].irq, dev);
 }
 
 static int __devinit mlx4_map_clr_int(struct mlx4_dev *dev)
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/fw.c linux-2.6.22-rc4-git6/drivers/net/mlx4/fw.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/fw.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/fw.c	2007-06-14 14:14:33.000000000 -0400
@@ -37,6 +37,10 @@
 #include "fw.h"
 #include "icm.h"
 
+enum {
+	MLX4_COMMAND_INTERFACE_REV	= 1
+};
+
 extern void __buggy_use_of_MLX4_GET(void);
 extern void __buggy_use_of_MLX4_PUT(void);
 
@@ -452,10 +456,12 @@ int mlx4_QUERY_FW(struct mlx4_dev *dev)
 	u32 *outbox;
 	int err = 0;
 	u64 fw_ver;
+	u16 cmd_if_rev;
 	u8 lg;
 
 #define QUERY_FW_OUT_SIZE             0x100
 #define QUERY_FW_VER_OFFSET            0x00
+#define QUERY_FW_CMD_IF_REV_OFFSET     0x0a
 #define QUERY_FW_MAX_CMD_OFFSET        0x0f
 #define QUERY_FW_ERR_START_OFFSET      0x30
 #define QUERY_FW_ERR_SIZE_OFFSET       0x38
@@ -477,21 +483,36 @@ int mlx4_QUERY_FW(struct mlx4_dev *dev)
 
 	MLX4_GET(fw_ver, outbox, QUERY_FW_VER_OFFSET);
 	/*
-	 * FW subminor version is at more signifant bits than minor
+	 * FW subminor version is at more significant bits than minor
 	 * version, so swap here.
 	 */
 	dev->caps.fw_ver = (fw_ver & 0xffff00000000ull) |
 		((fw_ver & 0xffff0000ull) >> 16) |
 		((fw_ver & 0x0000ffffull) << 16);
 
+	MLX4_GET(cmd_if_rev, outbox, QUERY_FW_CMD_IF_REV_OFFSET);
+	if (cmd_if_rev != MLX4_COMMAND_INTERFACE_REV) {
+		mlx4_err(dev, "Installed FW has unsupported "
+			 "command interface revision %d.\n",
+			 cmd_if_rev);
+		mlx4_err(dev, "(Installed FW version is %d.%d.%03d)\n",
+			 (int) (dev->caps.fw_ver >> 32),
+			 (int) (dev->caps.fw_ver >> 16) & 0xffff,
+			 (int) dev->caps.fw_ver & 0xffff);
+		mlx4_err(dev, "This driver version supports only revision %d.\n",
+			 MLX4_COMMAND_INTERFACE_REV);
+		err = -ENODEV;
+		goto out;
+	}
+
 	MLX4_GET(lg, outbox, QUERY_FW_MAX_CMD_OFFSET);
 	cmd->max_cmds = 1 << lg;
 
-	mlx4_dbg(dev, "FW version %d.%d.%03d, max commands %d\n",
+	mlx4_dbg(dev, "FW version %d.%d.%03d (cmd intf rev %d), max commands %d\n",
 		 (int) (dev->caps.fw_ver >> 32),
 		 (int) (dev->caps.fw_ver >> 16) & 0xffff,
 		 (int) dev->caps.fw_ver & 0xffff,
-		 cmd->max_cmds);
+		 cmd_if_rev, cmd->max_cmds);
 
 	MLX4_GET(fw->catas_offset, outbox, QUERY_FW_ERR_START_OFFSET);
 	MLX4_GET(fw->catas_size,   outbox, QUERY_FW_ERR_SIZE_OFFSET);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/intf.c linux-2.6.22-rc4-git6/drivers/net/mlx4/intf.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/intf.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/intf.c	2007-06-14 14:14:33.000000000 -0400
@@ -135,9 +135,6 @@ int mlx4_register_device(struct mlx4_dev
 	struct mlx4_priv *priv = mlx4_priv(dev);
 	struct mlx4_interface *intf;
 
-	INIT_LIST_HEAD(&priv->ctx_list);
-	spin_lock_init(&priv->ctx_lock);
-
 	mutex_lock(&intf_mutex);
 
 	list_add_tail(&priv->dev_list, &dev_list);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/main.c linux-2.6.22-rc4-git6/drivers/net/mlx4/main.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/main.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/main.c	2007-06-14 14:14:33.000000000 -0400
@@ -787,6 +787,8 @@ static int __devinit mlx4_init_one(struc
 
 	dev       = &priv->dev;
 	dev->pdev = pdev;
+	INIT_LIST_HEAD(&priv->ctx_list);
+	spin_lock_init(&priv->ctx_lock);
 
 	/*
 	 * Now reset the HCA before we touch the PCI capabilities or
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/mr.c linux-2.6.22-rc4-git6/drivers/net/mlx4/mr.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/mlx4/mr.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/mlx4/mr.c	2007-06-14 14:14:33.000000000 -0400
@@ -324,15 +324,17 @@ int mlx4_mr_enable(struct mlx4_dev *dev,
 				       MLX4_MPT_FLAG_MIO	 |
 				       MLX4_MPT_FLAG_REGION	 |
 				       mr->access);
-	if (mr->mtt.order < 0)
-		mpt_entry->flags |= cpu_to_be32(MLX4_MPT_FLAG_PHYSICAL);
 
 	mpt_entry->key	       = cpu_to_be32(key_to_hw_index(mr->key));
 	mpt_entry->pd	       = cpu_to_be32(mr->pd);
 	mpt_entry->start       = cpu_to_be64(mr->iova);
 	mpt_entry->length      = cpu_to_be64(mr->size);
 	mpt_entry->entity_size = cpu_to_be32(mr->mtt.page_shift);
-	mpt_entry->mtt_seg     = cpu_to_be64(mlx4_mtt_addr(dev, &mr->mtt));
+	if (mr->mtt.order < 0) {
+		mpt_entry->flags |= cpu_to_be32(MLX4_MPT_FLAG_PHYSICAL);
+		mpt_entry->mtt_seg = 0;
+	} else
+		mpt_entry->mtt_seg = cpu_to_be64(mlx4_mtt_addr(dev, &mr->mtt));
 
 	err = mlx4_SW2HW_MPT(dev, mailbox,
 			     key_to_hw_index(mr->key) & (dev->caps.num_mpts - 1));
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/myri10ge/myri10ge.c linux-2.6.22-rc4-git6/drivers/net/myri10ge/myri10ge.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/myri10ge/myri10ge.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/myri10ge/myri10ge.c	2007-06-14 14:14:33.000000000 -0400
@@ -71,7 +71,7 @@
 #include "myri10ge_mcp.h"
 #include "myri10ge_mcp_gen_header.h"
 
-#define MYRI10GE_VERSION_STR "1.3.0-1.233"
+#define MYRI10GE_VERSION_STR "1.3.1-1.248"
 
 MODULE_DESCRIPTION("Myricom 10G driver (10GbE)");
 MODULE_AUTHOR("Maintainer: help@myri.com");
@@ -279,6 +279,8 @@ static int myri10ge_fill_thresh = 256;
 module_param(myri10ge_fill_thresh, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(myri10ge_fill_thresh, "Number of empty rx slots allowed\n");
 
+static int myri10ge_reset_recover = 1;
+
 static int myri10ge_wcfifo = 0;
 module_param(myri10ge_wcfifo, int, S_IRUGO);
 MODULE_PARM_DESC(myri10ge_wcfifo, "Enable WC Fifo when WC is enabled\n");
@@ -1154,9 +1156,11 @@ static inline void myri10ge_check_statbl
 	struct mcp_irq_data *stats = mgp->fw_stats;
 
 	if (unlikely(stats->stats_updated)) {
-		if (mgp->link_state != stats->link_up) {
-			mgp->link_state = stats->link_up;
-			if (mgp->link_state) {
+		unsigned link_up = ntohl(stats->link_up);
+		if (mgp->link_state != link_up) {
+			mgp->link_state = link_up;
+
+			if (mgp->link_state == MXGEFW_LINK_UP) {
 				if (netif_msg_link(mgp))
 					printk(KERN_INFO
 					       "myri10ge: %s: link up\n",
@@ -1166,8 +1170,11 @@ static inline void myri10ge_check_statbl
 			} else {
 				if (netif_msg_link(mgp))
 					printk(KERN_INFO
-					       "myri10ge: %s: link down\n",
-					       mgp->dev->name);
+					       "myri10ge: %s: link %s\n",
+					       mgp->dev->name,
+					       (link_up == MXGEFW_LINK_MYRINET ?
+						"mismatch (Myrinet detected)" :
+						"down"));
 				netif_carrier_off(mgp->dev);
 				mgp->link_changes++;
 			}
@@ -2730,8 +2737,14 @@ static void myri10ge_watchdog(struct wor
 		 * For now, just report it */
 		reboot = myri10ge_read_reboot(mgp);
 		printk(KERN_ERR
-		       "myri10ge: %s: NIC rebooted (0x%x), resetting\n",
-		       mgp->dev->name, reboot);
+		       "myri10ge: %s: NIC rebooted (0x%x),%s resetting\n",
+		       mgp->dev->name, reboot,
+		       myri10ge_reset_recover ? " " : " not");
+		if (myri10ge_reset_recover == 0)
+			return;
+
+		myri10ge_reset_recover--;
+
 		/*
 		 * A rebooted nic will come back with config space as
 		 * it was after power was applied to PCIe bus.
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_ethtool.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_ethtool.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_ethtool.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_ethtool.c	2007-06-14 14:14:33.000000000 -0400
@@ -94,7 +94,7 @@ static const char netxen_nic_gstrings_te
 
 static int netxen_nic_get_eeprom_len(struct net_device *dev)
 {
-	return FLASH_TOTAL_SIZE;
+	return NETXEN_FLASH_TOTAL_SIZE;
 }
 
 static void
@@ -470,7 +470,7 @@ netxen_nic_set_eeprom(struct net_device 
 		return 0;
 	}
 
-	if (offset == BOOTLD_START) {
+	if (offset == NETXEN_BOOTLD_START) {
 		ret = netxen_flash_erase_primary(adapter);
 		if (ret != FLASH_SUCCESS) {
 			printk(KERN_ERR "%s: Flash erase failed.\n", 
@@ -478,10 +478,10 @@ netxen_nic_set_eeprom(struct net_device 
 			return ret;
 		}
 
-		ret = netxen_rom_se(adapter, USER_START);
+		ret = netxen_rom_se(adapter, NETXEN_USER_START);
 		if (ret != FLASH_SUCCESS)
 			return ret;
-		ret = netxen_rom_se(adapter, FIXED_START);
+		ret = netxen_rom_se(adapter, NETXEN_FIXED_START);
 		if (ret != FLASH_SUCCESS)
 			return ret;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic.h linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic.h	2007-06-14 14:14:33.000000000 -0400
@@ -68,9 +68,10 @@
 #define _NETXEN_NIC_LINUX_SUBVERSION 2
 #define NETXEN_NIC_LINUX_VERSIONID  "3.4.2"
 
-#define NUM_FLASH_SECTORS (64)
-#define FLASH_SECTOR_SIZE (64 * 1024)
-#define FLASH_TOTAL_SIZE  (NUM_FLASH_SECTORS * FLASH_SECTOR_SIZE)
+#define NETXEN_NUM_FLASH_SECTORS (64)
+#define NETXEN_FLASH_SECTOR_SIZE (64 * 1024)
+#define NETXEN_FLASH_TOTAL_SIZE  (NETXEN_NUM_FLASH_SECTORS \
+					* NETXEN_FLASH_SECTOR_SIZE)
 
 #define PHAN_VENDOR_ID 0x4040
 
@@ -677,28 +678,28 @@ struct netxen_new_user_info {
 
 /* Flash memory map */
 typedef enum {
-	CRBINIT_START = 0,	/* Crbinit section */
-	BRDCFG_START = 0x4000,	/* board config */
-	INITCODE_START = 0x6000,	/* pegtune code */
-	BOOTLD_START = 0x10000,	/* bootld */
-	IMAGE_START = 0x43000,	/* compressed image */
-	SECONDARY_START = 0x200000,	/* backup images */
-	PXE_START = 0x3E0000,	/* user defined region */
-	USER_START = 0x3E8000,	/* User defined region for new boards */
-	FIXED_START = 0x3F0000	/* backup of crbinit */
+	NETXEN_CRBINIT_START = 0,	/* Crbinit section */
+	NETXEN_BRDCFG_START = 0x4000,	/* board config */
+	NETXEN_INITCODE_START = 0x6000,	/* pegtune code */
+	NETXEN_BOOTLD_START = 0x10000,	/* bootld */
+	NETXEN_IMAGE_START = 0x43000,	/* compressed image */
+	NETXEN_SECONDARY_START = 0x200000,	/* backup images */
+	NETXEN_PXE_START = 0x3E0000,	/* user defined region */
+	NETXEN_USER_START = 0x3E8000,	/* User defined region for new boards */
+	NETXEN_FIXED_START = 0x3F0000	/* backup of crbinit */
 } netxen_flash_map_t;
 
-#define USER_START_OLD PXE_START	/* for backward compatibility */
+#define NETXEN_USER_START_OLD NETXEN_PXE_START	/* for backward compatibility */
 
-#define FLASH_START		(CRBINIT_START)
-#define INIT_SECTOR		(0)
-#define PRIMARY_START 		(BOOTLD_START)
-#define FLASH_CRBINIT_SIZE 	(0x4000)
-#define FLASH_BRDCFG_SIZE 	(sizeof(struct netxen_board_info))
-#define FLASH_USER_SIZE		(sizeof(struct netxen_user_info)/sizeof(u32))
-#define FLASH_SECONDARY_SIZE 	(USER_START-SECONDARY_START)
-#define NUM_PRIMARY_SECTORS	(0x20)
-#define NUM_CONFIG_SECTORS 	(1)
+#define NETXEN_FLASH_START		(NETXEN_CRBINIT_START)
+#define NETXEN_INIT_SECTOR		(0)
+#define NETXEN_PRIMARY_START 		(NETXEN_BOOTLD_START)
+#define NETXEN_FLASH_CRBINIT_SIZE 	(0x4000)
+#define NETXEN_FLASH_BRDCFG_SIZE 	(sizeof(struct netxen_board_info))
+#define NETXEN_FLASH_USER_SIZE		(sizeof(struct netxen_user_info)/sizeof(u32))
+#define NETXEN_FLASH_SECONDARY_SIZE 	(NETXEN_USER_START-NETXEN_SECONDARY_START)
+#define NETXEN_NUM_PRIMARY_SECTORS	(0x20)
+#define NETXEN_NUM_CONFIG_SECTORS 	(1)
 #define PFX "NetXen: "
 extern char netxen_nic_driver_name[];
 
@@ -1048,6 +1049,7 @@ int netxen_rom_se(struct netxen_adapter 
 int netxen_do_rom_se(struct netxen_adapter *adapter, int addr);
 
 /* Functions from netxen_nic_isr.c */
+int netxen_nic_link_ok(struct netxen_adapter *adapter);
 void netxen_nic_isr_other(struct netxen_adapter *adapter);
 void netxen_indicate_link_status(struct netxen_adapter *adapter, u32 link);
 void netxen_handle_port_int(struct netxen_adapter *adapter, u32 enable);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_hw.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_hw.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_hw.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_hw.c	2007-06-14 14:14:33.000000000 -0400
@@ -257,7 +257,7 @@ u64 ctx_addr_sig_regs[][3] = {
 #define ADDR_IN_RANGE(addr, low, high)	\
 	(((addr) <= (high)) && ((addr) >= (low)))
 
-#define NETXEN_FLASH_BASE	(BOOTLD_START)
+#define NETXEN_FLASH_BASE	(NETXEN_BOOTLD_START)
 #define NETXEN_PHANTOM_MEM_BASE	(NETXEN_FLASH_BASE)
 #define NETXEN_MAX_MTU		8000 + NETXEN_ENET_HEADER_SIZE + NETXEN_ETH_FCS_SIZE
 #define NETXEN_MIN_MTU		64
@@ -611,7 +611,7 @@ int netxen_get_flash_mac_addr(struct net
 	u32 *pmac = (u32 *) & mac[0];
 
 	if (netxen_get_flash_block(adapter,
-				   USER_START +
+				   NETXEN_USER_START +
 				   offsetof(struct netxen_new_user_info,
 					    mac_addr),
 				   FLASH_NUM_PORTS * sizeof(u64), pmac) == -1) {
@@ -619,7 +619,7 @@ int netxen_get_flash_mac_addr(struct net
 	}
 	if (*mac == ~0ULL) {
 		if (netxen_get_flash_block(adapter,
-					   USER_START_OLD +
+					   NETXEN_USER_START_OLD +
 					   offsetof(struct netxen_user_old_info,
 						    mac_addr),
 					   FLASH_NUM_PORTS * sizeof(u64),
@@ -942,7 +942,7 @@ netxen_nic_pci_set_window(struct netxen_
 int
 netxen_nic_erase_pxe(struct netxen_adapter *adapter)
 {
-	if (netxen_rom_fast_write(adapter, PXE_START, 0) == -1) {
+	if (netxen_rom_fast_write(adapter, NETXEN_PXE_START, 0) == -1) {
 		printk(KERN_ERR "%s: erase pxe failed\n", 
 			netxen_nic_driver_name);
 		return -1;
@@ -953,7 +953,7 @@ netxen_nic_erase_pxe(struct netxen_adapt
 int netxen_nic_get_board_info(struct netxen_adapter *adapter)
 {
 	int rv = 0;
-	int addr = BRDCFG_START;
+	int addr = NETXEN_BRDCFG_START;
 	struct netxen_board_info *boardinfo;
 	int index;
 	u32 *ptr32;
@@ -1115,7 +1115,7 @@ void netxen_nic_flash_print(struct netxe
 	u32 fw_build = 0;
 	char brd_name[NETXEN_MAX_SHORT_NAME];
 	struct netxen_new_user_info user_info;
-	int i, addr = USER_START;
+	int i, addr = NETXEN_USER_START;
 	__le32 *ptr32;
 
 	struct netxen_board_info *board_info = &(adapter->ahw.boardcfg);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_init.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_init.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_init.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_init.c	2007-06-14 14:14:33.000000000 -0400
@@ -585,7 +585,7 @@ int netxen_backup_crbinit(struct netxen_
 {
 	int ret = FLASH_SUCCESS;
 	int val;
-	char *buffer = kmalloc(FLASH_SECTOR_SIZE, GFP_KERNEL);
+	char *buffer = kmalloc(NETXEN_FLASH_SECTOR_SIZE, GFP_KERNEL);
 
 	if (!buffer)
 		return -ENOMEM;	
@@ -601,13 +601,13 @@ int netxen_backup_crbinit(struct netxen_
 		goto out_kfree;
 
 	/* copy  sector 0 to sector 63 */
-	ret = netxen_rom_fast_read_words(adapter, CRBINIT_START, 
-						buffer, FLASH_SECTOR_SIZE);
+	ret = netxen_rom_fast_read_words(adapter, NETXEN_CRBINIT_START, 
+					buffer, NETXEN_FLASH_SECTOR_SIZE);
 	if (ret != FLASH_SUCCESS)
 		goto out_kfree;
 
-	ret = netxen_rom_fast_write_words(adapter, FIXED_START, 
-						buffer, FLASH_SECTOR_SIZE);
+	ret = netxen_rom_fast_write_words(adapter, NETXEN_FIXED_START, 
+					buffer, NETXEN_FLASH_SECTOR_SIZE);
 	if (ret != FLASH_SUCCESS)
 		goto out_kfree;
 
@@ -654,7 +654,8 @@ void check_erased_flash(struct netxen_ad
 	int count = 0, erased_errors = 0;
 	int range;
 
-	range = (addr == USER_START) ? FIXED_START : addr + FLASH_SECTOR_SIZE;
+	range = (addr == NETXEN_USER_START) ? 
+		NETXEN_FIXED_START : addr + NETXEN_FLASH_SECTOR_SIZE;
 	
 	for (i = addr; i < range; i += 4) {
 		netxen_rom_fast_read(adapter, i, &val);
@@ -689,7 +690,7 @@ netxen_flash_erase_sections(struct netxe
 	int i;
 
 	for (i = start; i < end; i++) {
-		ret = netxen_rom_se(adapter, i * FLASH_SECTOR_SIZE);
+		ret = netxen_rom_se(adapter, i * NETXEN_FLASH_SECTOR_SIZE);
 		if (ret)
 			break;
 		ret = netxen_rom_wip_poll(adapter);
@@ -706,8 +707,8 @@ netxen_flash_erase_secondary(struct netx
 	int ret = FLASH_SUCCESS;
 	int start, end;
 
-	start = SECONDARY_START / FLASH_SECTOR_SIZE;
-	end   = USER_START / FLASH_SECTOR_SIZE;
+	start = NETXEN_SECONDARY_START / NETXEN_FLASH_SECTOR_SIZE;
+	end   = NETXEN_USER_START / NETXEN_FLASH_SECTOR_SIZE;
 	ret = netxen_flash_erase_sections(adapter, start, end);
 
 	return ret;
@@ -719,8 +720,8 @@ netxen_flash_erase_primary(struct netxen
 	int ret = FLASH_SUCCESS;
 	int start, end;
 
-	start = PRIMARY_START / FLASH_SECTOR_SIZE;
-	end   = SECONDARY_START / FLASH_SECTOR_SIZE;
+	start = NETXEN_PRIMARY_START / NETXEN_FLASH_SECTOR_SIZE;
+	end   = NETXEN_SECONDARY_START / NETXEN_FLASH_SECTOR_SIZE;
 	ret = netxen_flash_erase_sections(adapter, start, end);
 
 	return ret;
@@ -1036,18 +1037,23 @@ void netxen_watchdog_task(struct work_st
 	if ((adapter->portnum  == 0) && netxen_nic_check_temp(adapter))
 		return;
 
+	if (adapter->handle_phy_intr)
+		adapter->handle_phy_intr(adapter);
+
 	netdev = adapter->netdev;
-	if ((netif_running(netdev)) && !netif_carrier_ok(netdev)) {
-		printk(KERN_INFO "%s port %d, %s carrier is now ok\n",
-		       netxen_nic_driver_name, adapter->portnum, netdev->name);
+	if ((netif_running(netdev)) && !netif_carrier_ok(netdev) &&
+			netxen_nic_link_ok(adapter) ) {
+		printk(KERN_INFO "%s %s (port %d), Link is up\n",
+			       netxen_nic_driver_name, netdev->name, adapter->portnum);
 		netif_carrier_on(netdev);
-	}
-
-	if (netif_queue_stopped(netdev))
 		netif_wake_queue(netdev);
+	} else if(!(netif_running(netdev)) && netif_carrier_ok(netdev)) {
+		printk(KERN_ERR "%s %s Link is Down\n",
+				netxen_nic_driver_name, netdev->name);
+		netif_carrier_off(netdev);
+		netif_stop_queue(netdev);
+	}
 
-	if (adapter->handle_phy_intr)
-		adapter->handle_phy_intr(adapter);
 	mod_timer(&adapter->watchdog_timer, jiffies + 2 * HZ);
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_isr.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_isr.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_isr.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_isr.c	2007-06-14 14:14:33.000000000 -0400
@@ -169,6 +169,24 @@ void netxen_nic_gbe_handle_phy_intr(stru
 	netxen_nic_isr_other(adapter);
 }
 
+int netxen_nic_link_ok(struct netxen_adapter *adapter)
+{
+	switch (adapter->ahw.board_type) {
+	case NETXEN_NIC_GBE:
+		return ((adapter->ahw.qg_linksup) & 1);
+
+	case NETXEN_NIC_XGBE:
+		return ((adapter->ahw.xg_linkup) & 1);
+
+	default:
+		printk(KERN_ERR"%s: Function: %s, Unknown board type\n",
+			netxen_nic_driver_name, __FUNCTION__);
+		break;
+	}
+
+	return 0;
+}
+
 void netxen_nic_xgbe_handle_phy_intr(struct netxen_adapter *adapter)
 {
 	struct net_device *netdev = adapter->netdev;
@@ -183,6 +201,10 @@ void netxen_nic_xgbe_handle_phy_intr(str
 		printk(KERN_INFO "%s: %s NIC Link is down\n",
 		       netxen_nic_driver_name, netdev->name);
 		adapter->ahw.xg_linkup = 0;
+		if (netif_running(netdev)) {
+			netif_carrier_off(netdev);
+			netif_stop_queue(netdev);
+		}
 		/* read twice to clear sticky bits */
 		/* WINDOW = 0 */
 		netxen_nic_read_w0(adapter, NETXEN_NIU_XG_STATUS, &val1);
@@ -196,5 +218,7 @@ void netxen_nic_xgbe_handle_phy_intr(str
 		printk(KERN_INFO "%s: %s NIC Link is up\n",
 		       netxen_nic_driver_name, netdev->name);
 		adapter->ahw.xg_linkup = 1;
+		netif_carrier_on(netdev);
+		netif_wake_queue(netdev);
 	}
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_main.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_main.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_main.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_main.c	2007-06-14 14:14:33.000000000 -0400
@@ -542,6 +542,13 @@ netxen_nic_probe(struct pci_dev *pdev, c
 				NETXEN_ROMUSB_GLB_PEGTUNE_DONE));
 		/* Handshake with the card before we register the devices. */
 		netxen_phantom_init(adapter, NETXEN_NIC_PEG_TUNE);
+
+	       /* leave the hw in the same state as reboot */
+	       writel(0, NETXEN_CRB_NORMALIZE(adapter, CRB_CMDPEG_STATE));
+	       netxen_pinit_from_rom(adapter, 0);
+	       udelay(500);
+	       netxen_load_firmware(adapter);
+	       netxen_phantom_init(adapter, NETXEN_NIC_PEG_TUNE);
 	}
 
 	/*
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_niu.c linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_niu.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/netxen/netxen_nic_niu.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/netxen/netxen_nic_niu.c	2007-06-14 14:14:33.000000000 -0400
@@ -454,16 +454,12 @@ int netxen_niu_gbe_init_port(struct netx
 
 int netxen_niu_xg_init_port(struct netxen_adapter *adapter, int port)
 {
-	u32 reg;
 	u32 portnum = physical_port[adapter->portnum];
 
 	netxen_crb_writelit_adapter(adapter,
-		NETXEN_NIU_XGE_CONFIG_0+(0x10000*portnum), 0x5);
-	netxen_nic_hw_read_wx(adapter,
-		NETXEN_NIU_XGE_CONFIG_1+(0x10000*portnum), &reg, 4);
-	reg = (reg & ~0x2000UL);
+		NETXEN_NIU_XGE_CONFIG_1+(0x10000*portnum), 0x1447);
 	netxen_crb_writelit_adapter(adapter,
-		NETXEN_NIU_XGE_CONFIG_1+(0x10000*portnum), reg);
+		NETXEN_NIU_XGE_CONFIG_0+(0x10000*portnum), 0x5);
 
 	return 0;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/phy/marvell.c linux-2.6.22-rc4-git6/drivers/net/phy/marvell.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/phy/marvell.c	2007-06-08 12:08:11.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/phy/marvell.c	2007-06-14 14:14:33.000000000 -0400
@@ -54,6 +54,12 @@
 #define MII_M1111_PHY_LED_CONTROL	0x18
 #define MII_M1111_PHY_LED_DIRECT	0x4100
 #define MII_M1111_PHY_LED_COMBINE	0x411c
+#define MII_M1111_PHY_EXT_CR		0x14
+#define MII_M1111_RX_DELAY		0x80
+#define MII_M1111_TX_DELAY		0x2
+#define MII_M1111_PHY_EXT_SR		0x1b
+#define MII_M1111_HWCFG_MODE_MASK	0xf
+#define MII_M1111_HWCFG_MODE_RGMII	0xb
 
 MODULE_DESCRIPTION("Marvell PHY driver");
 MODULE_AUTHOR("Andy Fleming");
@@ -131,6 +137,45 @@ static int marvell_config_aneg(struct ph
 	return err;
 }
 
+static int m88e1111_config_init(struct phy_device *phydev)
+{
+	int err;
+
+	if ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
+	    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)) {
+		int temp;
+
+		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
+			temp = phy_read(phydev, MII_M1111_PHY_EXT_CR);
+			if (temp < 0)
+				return temp;
+
+			temp |= (MII_M1111_RX_DELAY | MII_M1111_TX_DELAY);
+
+			err = phy_write(phydev, MII_M1111_PHY_EXT_CR, temp);
+			if (err < 0)
+				return err;
+		}
+
+		temp = phy_read(phydev, MII_M1111_PHY_EXT_SR);
+		if (temp < 0)
+			return temp;
+
+		temp &= ~(MII_M1111_HWCFG_MODE_MASK);
+		temp |= MII_M1111_HWCFG_MODE_RGMII;
+
+		err = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);
+		if (err < 0)
+			return err;
+	}
+
+	err = phy_write(phydev, MII_BMCR, BMCR_RESET);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
 static int m88e1145_config_init(struct phy_device *phydev)
 {
 	int err;
@@ -152,7 +197,7 @@ static int m88e1145_config_init(struct p
 	if (err < 0)
 		return err;
 
-	if (phydev->interface == PHY_INTERFACE_MODE_RGMII) {
+	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
 		int temp = phy_read(phydev, MII_M1145_PHY_EXT_CR);
 		if (temp < 0)
 			return temp;
@@ -206,7 +251,7 @@ static struct phy_driver m88e1101_driver
 	.driver = {.owner = THIS_MODULE,},
 };
 
-static struct phy_driver m88e1111s_driver = {
+static struct phy_driver m88e1111_driver = {
 	.phy_id = 0x01410cc0,
 	.phy_id_mask = 0xfffffff0,
 	.name = "Marvell 88E1111",
@@ -216,6 +261,7 @@ static struct phy_driver m88e1111s_drive
 	.read_status = &genphy_read_status,
 	.ack_interrupt = &marvell_ack_interrupt,
 	.config_intr = &marvell_config_intr,
+	.config_init = &m88e1111_config_init,
 	.driver = {.owner = THIS_MODULE,},
 };
 
@@ -241,9 +287,9 @@ static int __init marvell_init(void)
 	if (ret)
 		return ret;
 
-	ret = phy_driver_register(&m88e1111s_driver);
+	ret = phy_driver_register(&m88e1111_driver);
 	if (ret)
-		goto err1111s;
+		goto err1111;
 
 	ret = phy_driver_register(&m88e1145_driver);
 	if (ret)
@@ -251,9 +297,9 @@ static int __init marvell_init(void)
 
 	return 0;
 
-      err1145:
-	phy_driver_unregister(&m88e1111s_driver);
-      err1111s:
+err1145:
+	phy_driver_unregister(&m88e1111_driver);
+err1111:
 	phy_driver_unregister(&m88e1101_driver);
 	return ret;
 }
@@ -261,7 +307,7 @@ static int __init marvell_init(void)
 static void __exit marvell_exit(void)
 {
 	phy_driver_unregister(&m88e1101_driver);
-	phy_driver_unregister(&m88e1111s_driver);
+	phy_driver_unregister(&m88e1111_driver);
 	phy_driver_unregister(&m88e1145_driver);
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/usb/Kconfig linux-2.6.22-rc4-git6/drivers/net/usb/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/net/usb/Kconfig	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/usb/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -313,8 +313,8 @@ config USB_KC2190
 	boolean "KT Technology KC2190 based cables (InstaNet)"
 	depends on USB_NET_CDC_SUBSET && EXPERIMENTAL
 	help
-	 Choose this option if you're using a host-to-host cable
-	 with one of these chips.
+	  Choose this option if you're using a host-to-host cable
+	  with one of these chips.
 
 config USB_NET_ZAURUS
 	tristate "Sharp Zaurus (stock ROMs) and compatible"
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/via-velocity.c linux-2.6.22-rc4-git6/drivers/net/via-velocity.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/via-velocity.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/via-velocity.c	2007-06-14 14:14:33.000000000 -0400
@@ -1562,7 +1562,7 @@ static void velocity_print_link_status(s
 	if (vptr->mii_status & VELOCITY_LINK_FAIL) {
 		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: failed to detect cable link\n", vptr->dev->name);
 	} else if (vptr->options.spd_dpx == SPD_DPX_AUTO) {
-		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: Link autonegation", vptr->dev->name);
+		VELOCITY_PRT(MSG_LEVEL_INFO, KERN_NOTICE "%s: Link auto-negotiation", vptr->dev->name);
 
 		if (vptr->mii_status & VELOCITY_SPEED_1000)
 			VELOCITY_PRT(MSG_LEVEL_INFO, " speed 1000M bps");
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/Kconfig linux-2.6.22-rc4-git6/drivers/net/wireless/Kconfig
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/Kconfig	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/Kconfig	2007-06-14 14:14:33.000000000 -0400
@@ -266,16 +266,23 @@ config IPW2200_DEBUG
 
 	  If you are not sure, say N here.
 
-config LIBERTAS_USB
-	tristate "Marvell Libertas 8388 802.11a/b/g cards"
-	depends on USB && WLAN_80211
+config LIBERTAS
+	tristate "Marvell 8xxx Libertas WLAN driver support"
+	depends on WLAN_80211
+	select IEEE80211
 	select FW_LOADER
 	---help---
+	  A library for Marvell Libertas 8xxx devices.
+
+config LIBERTAS_USB
+	tristate "Marvell Libertas 8388 USB 802.11b/g cards"
+	depends on LIBERTAS && USB
+	---help---
 	  A driver for Marvell Libertas 8388 USB devices.
 
-config LIBERTAS_USB_DEBUG
-	bool "Enable full debugging output in the Libertas USB module."
-	depends on LIBERTAS_USB
+config LIBERTAS_DEBUG
+	bool "Enable full debugging output in the Libertas module."
+	depends on LIBERTAS
 	---help---
 	  Debugging support.
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/11d.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/11d.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/11d.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/11d.c	2007-06-14 14:14:33.000000000 -0400
@@ -95,7 +95,7 @@ static u8 wlan_get_chan_11d(u8 band, u8 
 
 	for (i = 0; i < cfp_no; i++) {
 		if ((cfp + i)->channel == firstchan) {
-			lbs_pr_debug(1, "firstchan found\n");
+			lbs_deb_11d("firstchan found\n");
 			break;
 		}
 	}
@@ -129,12 +129,12 @@ static u8 wlan_channel_known_11d(u8 chan
 
 	for (i = 0; i < nr_chan; i++) {
 		if (chan == chanpwr[i].chan) {
-			lbs_pr_debug(1, "11D: Found Chan:%d\n", chan);
+			lbs_deb_11d("11D: Found Chan:%d\n", chan);
 			return 1;
 		}
 	}
 
-	lbs_pr_debug(1, "11D: Not Find Chan:%d\n", chan);
+	lbs_deb_11d("11D: Not Find Chan:%d\n", chan);
 	return 0;
 }
 
@@ -174,7 +174,7 @@ static int generate_domain_info_11d(stru
 	memcpy(domaininfo->countrycode, parsed_region_chan->countrycode,
 	       COUNTRY_CODE_LEN);
 
-	lbs_pr_debug(1, "11D:nrchan=%d\n", nr_chan);
+	lbs_deb_11d("11D:nrchan=%d\n", nr_chan);
 	lbs_dbg_hex("11D:parsed_region_chan:", (char *)parsed_region_chan,
 		sizeof(struct parsed_region_chan_11d));
 
@@ -212,7 +212,7 @@ static int generate_domain_info_11d(stru
 	}
 	domaininfo->nr_subband = nr_subband;
 
-	lbs_pr_debug(1, "nr_subband=%x\n", domaininfo->nr_subband);
+	lbs_deb_11d("nr_subband=%x\n", domaininfo->nr_subband);
 	lbs_dbg_hex("11D:domaininfo:", (char *)domaininfo,
 		COUNTRY_CODE_LEN + 1 +
 		sizeof(struct ieeetypes_subbandset) * nr_subband);
@@ -233,13 +233,13 @@ static void wlan_generate_parsed_region_
 	struct chan_freq_power *cfp;
 
 	if (region_chan == NULL) {
-		lbs_pr_debug(1, "11D: region_chan is NULL\n");
+		lbs_deb_11d("11D: region_chan is NULL\n");
 		return;
 	}
 
 	cfp = region_chan->CFP;
 	if (cfp == NULL) {
-		lbs_pr_debug(1, "11D: cfp equal NULL \n");
+		lbs_deb_11d("11D: cfp equal NULL \n");
 		return;
 	}
 
@@ -248,19 +248,19 @@ static void wlan_generate_parsed_region_
 	memcpy(parsed_region_chan->countrycode,
 	       wlan_code_2_region(region_chan->region), COUNTRY_CODE_LEN);
 
-	lbs_pr_debug(1, "11D: region[0x%x] band[%d]\n", parsed_region_chan->region,
+	lbs_deb_11d("11D: region[0x%x] band[%d]\n", parsed_region_chan->region,
 	       parsed_region_chan->band);
 
 	for (i = 0; i < region_chan->nrcfp; i++, cfp++) {
 		parsed_region_chan->chanpwr[i].chan = cfp->channel;
 		parsed_region_chan->chanpwr[i].pwr = cfp->maxtxpower;
-		lbs_pr_debug(1, "11D: Chan[%d] Pwr[%d]\n",
+		lbs_deb_11d("11D: Chan[%d] Pwr[%d]\n",
 		       parsed_region_chan->chanpwr[i].chan,
 		       parsed_region_chan->chanpwr[i].pwr);
 	}
 	parsed_region_chan->nr_chan = region_chan->nrcfp;
 
-	lbs_pr_debug(1, "11D: nrchan[%d]\n", parsed_region_chan->nr_chan);
+	lbs_deb_11d("11D: nrchan[%d]\n", parsed_region_chan->nr_chan);
 
 	return;
 }
@@ -277,8 +277,9 @@ static u8 wlan_region_chan_supported_11d
 	struct chan_freq_power *cfp;
 	int cfp_no;
 	u8 idx;
+	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 
 	cfp = libertas_get_region_cfp_table(region, band, &cfp_no);
 	if (cfp == NULL)
@@ -288,16 +289,19 @@ static u8 wlan_region_chan_supported_11d
 		if (chan == (cfp + idx)->channel) {
 			/* If Mrvl Chip Supported? */
 			if ((cfp + idx)->unsupported) {
-				return 0;
+				ret = 0;
 			} else {
-				return 1;
+				ret = 1;
 			}
+			goto done;
 		}
 	}
 
 	/*chan is not in the region table */
-	LEAVE();
-	return 0;
+
+done:
+	lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -321,7 +325,7 @@ static int parse_domain_info_11d(struct 
 
 	u8 j, i;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 
 	/*validation Rules:
 	   1. valid region Code
@@ -337,15 +341,14 @@ static int parse_domain_info_11d(struct 
 	if ((*(countryinfo->countrycode)) == 0
 	    || (countryinfo->len <= COUNTRY_CODE_LEN)) {
 		/* No region Info or Wrong region info: treat as No 11D info */
-		LEAVE();
-		return 0;
+		goto done;
 	}
 
 	/*Step1: check region_code */
 	parsed_region_chan->region = region =
 	    wlan_region_2_code(countryinfo->countrycode);
 
-	lbs_pr_debug(1, "regioncode=%x\n", (u8) parsed_region_chan->region);
+	lbs_deb_11d("regioncode=%x\n", (u8) parsed_region_chan->region);
 	lbs_dbg_hex("CountryCode:", (char *)countryinfo->countrycode,
 		COUNTRY_CODE_LEN);
 
@@ -361,7 +364,7 @@ static int parse_domain_info_11d(struct 
 
 		if (countryinfo->subband[j].firstchan <= lastchan) {
 			/*Step2&3. Check First Chan Num increment and no overlap */
-			lbs_pr_debug(1, "11D: Chan[%d>%d] Overlap\n",
+			lbs_deb_11d("11D: Chan[%d>%d] Overlap\n",
 			       countryinfo->subband[j].firstchan, lastchan);
 			continue;
 		}
@@ -374,7 +377,7 @@ static int parse_domain_info_11d(struct 
 
 			if (!wlan_get_chan_11d(band, firstchan, i, &curchan)) {
 				/* Chan is not found in UN table */
-				lbs_pr_debug(1, "chan is not supported: %d \n", i);
+				lbs_deb_11d("chan is not supported: %d \n", i);
 				break;
 			}
 
@@ -389,7 +392,7 @@ static int parse_domain_info_11d(struct 
 				idx++;
 			} else {
 				/*not supported and ignore the chan */
-				lbs_pr_debug(1,
+				lbs_deb_11d(
 				       "11D:i[%d] chan[%d] unsupported in region[%x] band[%d]\n",
 				       i, curchan, region, band);
 			}
@@ -401,11 +404,12 @@ static int parse_domain_info_11d(struct 
 
 	parsed_region_chan->nr_chan = idx;
 
-	lbs_pr_debug(1, "nrchan=%x\n", parsed_region_chan->nr_chan);
+	lbs_deb_11d("nrchan=%x\n", parsed_region_chan->nr_chan);
 	lbs_dbg_hex("11D:parsed_region_chan:", (u8 *) parsed_region_chan,
 		2 + COUNTRY_CODE_LEN + sizeof(struct parsed_region_chan_11d) * idx);
 
-	LEAVE();
+done:
+	lbs_deb_enter(LBS_DEB_11D);
 	return 0;
 }
 
@@ -420,16 +424,16 @@ u8 libertas_get_scan_type_11d(u8 chan,
 {
 	u8 scan_type = cmd_scan_type_passive;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 
 	if (wlan_channel_known_11d(chan, parsed_region_chan)) {
-		lbs_pr_debug(1, "11D: Found and do Active Scan\n");
+		lbs_deb_11d("11D: Found and do Active Scan\n");
 		scan_type = cmd_scan_type_active;
 	} else {
-		lbs_pr_debug(1, "11D: Not Find and do Passive Scan\n");
+		lbs_deb_11d("11D: Not Find and do Passive Scan\n");
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_11D, "ret scan_type %d", scan_type);
 	return scan_type;
 
 }
@@ -456,7 +460,7 @@ static int wlan_enable_11d(wlan_private 
 				    OID_802_11D_ENABLE,
 				    &priv->adapter->enable11d);
 	if (ret)
-		lbs_pr_debug(1, "11D: Fail to enable 11D \n");
+		lbs_deb_11d("11D: Fail to enable 11D \n");
 
 	return 0;
 }
@@ -471,7 +475,7 @@ static int set_domain_info_11d(wlan_priv
 	int ret;
 
 	if (!priv->adapter->enable11d) {
-		lbs_pr_debug(1, "11D: dnld domain Info with 11d disabled\n");
+		lbs_deb_11d("11D: dnld domain Info with 11d disabled\n");
 		return 0;
 	}
 
@@ -479,7 +483,7 @@ static int set_domain_info_11d(wlan_priv
 				    cmd_act_set,
 				    cmd_option_waitforrsp, 0, NULL);
 	if (ret)
-		lbs_pr_debug(1, "11D: Fail to dnld domain Info\n");
+		lbs_deb_11d("11D: Fail to dnld domain Info\n");
 
 	return ret;
 }
@@ -501,7 +505,7 @@ int libertas_set_universaltable(wlan_pri
 
 	adapter->universal_channel[i].nrcfp =
 	    sizeof(channel_freq_power_UN_BG) / size;
-	lbs_pr_debug(1, "11D: BG-band nrcfp=%d\n",
+	lbs_deb_11d("11D: BG-band nrcfp=%d\n",
 	       adapter->universal_channel[i].nrcfp);
 
 	adapter->universal_channel[i].CFP = channel_freq_power_UN_BG;
@@ -531,9 +535,9 @@ int libertas_cmd_802_11d_domain_info(wla
 	wlan_adapter *adapter = priv->adapter;
 	u8 nr_subband = adapter->domainreg.nr_subband;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 
-	lbs_pr_debug(1, "nr_subband=%x\n", nr_subband);
+	lbs_deb_11d("nr_subband=%x\n", nr_subband);
 
 	cmd->command = cpu_to_le16(cmdno);
 	pdomaininfo->action = cpu_to_le16(cmdoption);
@@ -542,8 +546,7 @@ int libertas_cmd_802_11d_domain_info(wla
 		    cpu_to_le16(sizeof(pdomaininfo->action) + S_DS_GEN);
 		lbs_dbg_hex("11D: 802_11D_DOMAIN_INFO:", (u8 *) cmd,
 			(int)(cmd->size));
-		LEAVE();
-		return 0;
+		goto done;
 	}
 
 	domain->header.type = cpu_to_le16(TLV_TYPE_DOMAIN);
@@ -567,10 +570,10 @@ int libertas_cmd_802_11d_domain_info(wla
 		    cpu_to_le16(sizeof(pdomaininfo->action) + S_DS_GEN);
 	}
 
-	lbs_dbg_hex("11D:802_11D_DOMAIN_INFO:", (u8 *) cmd, (int)(cmd->size));
-
-	LEAVE();
+	lbs_dbg_hex("11D:802_11D_DOMAIN_INFO:", (u8 *) cmd, le16_to_cpu(cmd->size));
 
+done:
+	lbs_deb_enter(LBS_DEB_11D);
 	return 0;
 }
 
@@ -585,17 +588,17 @@ int libertas_cmd_enable_11d(wlan_private
 	int data = 0;
 	int *val;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 	data = SUBCMD_DATA(wrq);
 
-	lbs_pr_debug(1, "enable 11D: %s\n",
+	lbs_deb_11d("enable 11D: %s\n",
 	       (data == 1) ? "enable" : "Disable");
 
 	wlan_enable_11d(priv, data);
 	val = (int *)wrq->u.name;
 	*val = priv->adapter->enable11d;
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_11D);
 	return 0;
 }
 
@@ -608,25 +611,24 @@ int libertas_cmd_enable_11d(wlan_private
 int libertas_ret_802_11d_domain_info(wlan_private * priv,
 				 struct cmd_ds_command *resp)
 {
-	struct cmd_ds_802_11d_domain_info
-	*domaininfo = &resp->params.domaininforesp;
+	struct cmd_ds_802_11d_domain_info *domaininfo = &resp->params.domaininforesp;
 	struct mrvlietypes_domainparamset *domain = &domaininfo->domain;
 	u16 action = le16_to_cpu(domaininfo->action);
 	s16 ret = 0;
 	u8 nr_subband = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 
 	lbs_dbg_hex("11D DOMAIN Info Rsp Data:", (u8 *) resp,
 		(int)le16_to_cpu(resp->size));
 
-	nr_subband = (domain->header.len - 3) / sizeof(struct ieeetypes_subbandset);
-	/* countrycode 3 bytes */
+	nr_subband = (le16_to_cpu(domain->header.len) - COUNTRY_CODE_LEN) /
+		      sizeof(struct ieeetypes_subbandset);
 
-	lbs_pr_debug(1, "11D Domain Info Resp: nr_subband=%d\n", nr_subband);
+	lbs_deb_11d("11D Domain Info Resp: nr_subband=%d\n", nr_subband);
 
 	if (nr_subband > MRVDRV_MAX_SUBBAND_802_11D) {
-		lbs_pr_debug(1, "Invalid Numrer of Subband returned!!\n");
+		lbs_deb_11d("Invalid Numrer of Subband returned!!\n");
 		return -1;
 	}
 
@@ -637,12 +639,12 @@ int libertas_ret_802_11d_domain_info(wla
 	case cmd_act_get:
 		break;
 	default:
-		lbs_pr_debug(1, "Invalid action:%d\n", domaininfo->action);
+		lbs_deb_11d("Invalid action:%d\n", domaininfo->action);
 		ret = -1;
 		break;
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
 	return ret;
 }
 
@@ -651,23 +653,22 @@ int libertas_ret_802_11d_domain_info(wla
  *  @param priv    pointer to wlan_private
  *  @return 	   0; -1
  */
-int libertas_parse_dnld_countryinfo_11d(wlan_private * priv)
+int libertas_parse_dnld_countryinfo_11d(wlan_private * priv,
+                                        struct bss_descriptor * bss)
 {
 	int ret;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_11D);
 	if (priv->adapter->enable11d) {
 		memset(&adapter->parsed_region_chan, 0,
 		       sizeof(struct parsed_region_chan_11d));
-		ret = parse_domain_info_11d(&adapter->pattemptedbssdesc->
-					       countryinfo, 0,
+		ret = parse_domain_info_11d(&bss->countryinfo, 0,
 					       &adapter->parsed_region_chan);
 
 		if (ret == -1) {
-			lbs_pr_debug(1, "11D: Err Parse domain_info from AP..\n");
-			LEAVE();
-			return ret;
+			lbs_deb_11d("11D: Err Parse domain_info from AP..\n");
+			goto done;
 		}
 
 		memset(&adapter->domainreg, 0,
@@ -678,13 +679,15 @@ int libertas_parse_dnld_countryinfo_11d(
 		ret = set_domain_info_11d(priv);
 
 		if (ret) {
-			lbs_pr_debug(1, "11D: Err set domainInfo to FW\n");
-			LEAVE();
-			return ret;
+			lbs_deb_11d("11D: Err set domainInfo to FW\n");
+			goto done;
 		}
 	}
-	LEAVE();
-	return 0;
+	ret = 0;
+
+done:
+	lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -699,8 +702,8 @@ int libertas_create_dnld_countryinfo_11d
 	struct region_channel *region_chan;
 	u8 j;
 
-	ENTER();
-	lbs_pr_debug(1, "11D:curbssparams.band[%d]\n", adapter->curbssparams.band);
+	lbs_deb_enter(LBS_DEB_11D);
+	lbs_deb_11d("11D:curbssparams.band[%d]\n", adapter->curbssparams.band);
 
 	if (priv->adapter->enable11d) {
 		/* update parsed_region_chan_11; dnld domaininf to FW */
@@ -709,7 +712,7 @@ int libertas_create_dnld_countryinfo_11d
 		     sizeof(adapter->region_channel[0]); j++) {
 			region_chan = &adapter->region_channel[j];
 
-			lbs_pr_debug(1, "11D:[%d] region_chan->band[%d]\n", j,
+			lbs_deb_11d("11D:[%d] region_chan->band[%d]\n", j,
 			       region_chan->band);
 
 			if (!region_chan || !region_chan->valid
@@ -722,10 +725,10 @@ int libertas_create_dnld_countryinfo_11d
 
 		if (j >= sizeof(adapter->region_channel) /
 		    sizeof(adapter->region_channel[0])) {
-			lbs_pr_debug(1, "11D:region_chan not found. band[%d]\n",
+			lbs_deb_11d("11D:region_chan not found. band[%d]\n",
 			       adapter->curbssparams.band);
-			LEAVE();
-			return -1;
+			ret = -1;
+			goto done;
 		}
 
 		memset(&adapter->parsed_region_chan, 0,
@@ -742,13 +745,14 @@ int libertas_create_dnld_countryinfo_11d
 		ret = set_domain_info_11d(priv);
 
 		if (ret) {
-			lbs_pr_debug(1, "11D: Err set domainInfo to FW\n");
-			LEAVE();
-			return ret;
+			lbs_deb_11d("11D: Err set domainInfo to FW\n");
+			goto done;
 		}
 
 	}
+	ret = 0;
 
-	LEAVE();
-	return 0;
+done:
+	lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
+	return ret;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/11d.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/11d.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/11d.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/11d.h	2007-06-14 14:14:33.000000000 -0400
@@ -47,7 +47,7 @@ struct mrvlietypes_domainparamset {
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11d_domain_info {
-	u16 action;
+	__le16 action;
 	struct mrvlietypes_domainparamset domain;
 } __attribute__ ((packed));
 
@@ -98,7 +98,9 @@ int libertas_cmd_enable_11d(wlan_private
 int libertas_ret_802_11d_domain_info(wlan_private * priv,
 				 struct cmd_ds_command *resp);
 
-int libertas_parse_dnld_countryinfo_11d(wlan_private * priv);
+struct bss_descriptor;
+int libertas_parse_dnld_countryinfo_11d(wlan_private * priv,
+                                        struct bss_descriptor * bss);
 
 int libertas_create_dnld_countryinfo_11d(wlan_private * priv);
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/assoc.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/assoc.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/assoc.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/assoc.c	2007-06-14 14:14:33.000000000 -0400
@@ -2,6 +2,7 @@
 
 #include <linux/bitops.h>
 #include <net/ieee80211.h>
+#include <linux/etherdevice.h>
 
 #include "assoc.h"
 #include "join.h"
@@ -13,59 +14,88 @@
 static const u8 bssid_any[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
 static const u8 bssid_off[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
+static void print_assoc_req(const char * extra, struct assoc_request * assoc_req)
+{
+	lbs_deb_assoc(
+	       "#### Association Request: %s\n"
+	       "       flags:      0x%08lX\n"
+	       "       SSID:       '%s'\n"
+	       "       channel:    %d\n"
+	       "       band:       %d\n"
+	       "       mode:       %d\n"
+	       "       BSSID:      " MAC_FMT "\n"
+	       "       Encryption:%s%s%s\n"
+	       "       auth:       %d\n",
+	       extra, assoc_req->flags,
+	       escape_essid(assoc_req->ssid, assoc_req->ssid_len),
+	       assoc_req->channel, assoc_req->band, assoc_req->mode,
+	       MAC_ARG(assoc_req->bssid),
+	       assoc_req->secinfo.WPAenabled ? " WPA" : "",
+	       assoc_req->secinfo.WPA2enabled ? " WPA2" : "",
+	       assoc_req->secinfo.wep_enabled ? " WEP" : "",
+	       assoc_req->secinfo.auth_mode);
+}
+
+
 static int assoc_helper_essid(wlan_private *priv,
                               struct assoc_request * assoc_req)
 {
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
-	int i;
+	struct bss_descriptor * bss;
+	int channel = -1;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-	lbs_pr_debug(1, "New SSID requested: %s\n", assoc_req->ssid.ssid);
+	/* FIXME: take channel into account when picking SSIDs if a channel
+	 * is set.
+	 */
+
+	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags))
+		channel = assoc_req->channel;
+
+	lbs_deb_assoc("New SSID requested: '%s'\n",
+	              escape_essid(assoc_req->ssid, assoc_req->ssid_len));
 	if (assoc_req->mode == IW_MODE_INFRA) {
 		if (adapter->prescan) {
-			libertas_send_specific_SSID_scan(priv, &assoc_req->ssid, 1);
+			libertas_send_specific_ssid_scan(priv, assoc_req->ssid,
+				assoc_req->ssid_len, 0);
 		}
 
-		i = libertas_find_SSID_in_list(adapter, &assoc_req->ssid,
-				NULL, IW_MODE_INFRA);
-		if (i >= 0) {
-			lbs_pr_debug(1,
-			       "SSID found in scan list ... associating...\n");
-
-			ret = wlan_associate(priv, &adapter->scantable[i]);
-			if (ret == 0) {
-				memcpy(&assoc_req->bssid,
-				       &adapter->scantable[i].macaddress,
-				       ETH_ALEN);
-			}
+		bss = libertas_find_ssid_in_list(adapter, assoc_req->ssid,
+				assoc_req->ssid_len, NULL, IW_MODE_INFRA, channel);
+		if (bss != NULL) {
+			lbs_deb_assoc("SSID found in scan list, associating\n");
+			memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
+			ret = wlan_associate(priv, assoc_req);
 		} else {
-			lbs_pr_debug(1, "SSID '%s' not found; cannot associate\n",
-				assoc_req->ssid.ssid);
+			lbs_deb_assoc("SSID not found; cannot associate\n");
 		}
 	} else if (assoc_req->mode == IW_MODE_ADHOC) {
 		/* Scan for the network, do not save previous results.  Stale
 		 *   scan data will cause us to join a non-existant adhoc network
 		 */
-		libertas_send_specific_SSID_scan(priv, &assoc_req->ssid, 0);
+		libertas_send_specific_ssid_scan(priv, assoc_req->ssid,
+			assoc_req->ssid_len, 1);
 
 		/* Search for the requested SSID in the scan table */
-		i = libertas_find_SSID_in_list(adapter, &assoc_req->ssid, NULL,
-				IW_MODE_ADHOC);
-		if (i >= 0) {
-			lbs_pr_debug(1, "SSID found at %d in List, so join\n", ret);
-			libertas_join_adhoc_network(priv, &adapter->scantable[i]);
+		bss = libertas_find_ssid_in_list(adapter, assoc_req->ssid,
+				assoc_req->ssid_len, NULL, IW_MODE_ADHOC, channel);
+		if (bss != NULL) {
+			lbs_deb_assoc("SSID found, will join\n");
+			memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
+			libertas_join_adhoc_network(priv, assoc_req);
 		} else {
 			/* else send START command */
-			lbs_pr_debug(1, "SSID not found in list, so creating adhoc"
-				" with SSID '%s'\n", assoc_req->ssid.ssid);
-			libertas_start_adhoc_network(priv, &assoc_req->ssid);
+			lbs_deb_assoc("SSID not found, creating adhoc network\n");
+			memcpy(&assoc_req->bss.ssid, &assoc_req->ssid,
+				IW_ESSID_MAX_SIZE);
+			assoc_req->bss.ssid_len = assoc_req->ssid_len;
+			libertas_start_adhoc_network(priv, assoc_req);
 		}
-		memcpy(&assoc_req->bssid, &adapter->current_addr, ETH_ALEN);
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -74,33 +104,31 @@ static int assoc_helper_bssid(wlan_priva
                               struct assoc_request * assoc_req)
 {
 	wlan_adapter *adapter = priv->adapter;
-	int i, ret = 0;
-
-	ENTER();
+	int ret = 0;
+	struct bss_descriptor * bss;
 
-	lbs_pr_debug(1, "ASSOC: WAP: BSSID = " MAC_FMT "\n",
+	lbs_deb_enter_args(LBS_DEB_ASSOC, "BSSID " MAC_FMT,
 		MAC_ARG(assoc_req->bssid));
 
 	/* Search for index position in list for requested MAC */
-	i = libertas_find_BSSID_in_list(adapter, assoc_req->bssid,
+	bss = libertas_find_bssid_in_list(adapter, assoc_req->bssid,
 			    assoc_req->mode);
-	if (i < 0) {
-		lbs_pr_debug(1, "ASSOC: WAP: BSSID " MAC_FMT " not found, "
+	if (bss == NULL) {
+		lbs_deb_assoc("ASSOC: WAP: BSSID " MAC_FMT " not found, "
 			"cannot associate.\n", MAC_ARG(assoc_req->bssid));
 		goto out;
 	}
 
+	memcpy(&assoc_req->bss, bss, sizeof(struct bss_descriptor));
 	if (assoc_req->mode == IW_MODE_INFRA) {
-		ret = wlan_associate(priv, &adapter->scantable[i]);
-		lbs_pr_debug(1, "ASSOC: return from wlan_associate(bssd) was %d\n", ret);
+		ret = wlan_associate(priv, assoc_req);
+		lbs_deb_assoc("ASSOC: wlan_associate(bssid) returned %d\n", ret);
 	} else if (assoc_req->mode == IW_MODE_ADHOC) {
-		libertas_join_adhoc_network(priv, &adapter->scantable[i]);
+		libertas_join_adhoc_network(priv, assoc_req);
 	}
-	memcpy(&assoc_req->ssid, &adapter->scantable[i].ssid,
-		sizeof(struct WLAN_802_11_SSID));
 
 out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -113,12 +141,12 @@ static int assoc_helper_associate(wlan_p
 	/* If we're given and 'any' BSSID, try associating based on SSID */
 
 	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {
-		if (memcmp(bssid_any, assoc_req->bssid, ETH_ALEN)
-		    && memcmp(bssid_off, assoc_req->bssid, ETH_ALEN)) {
+		if (compare_ether_addr(bssid_any, assoc_req->bssid)
+		    && compare_ether_addr(bssid_off, assoc_req->bssid)) {
 			ret = assoc_helper_bssid(priv, assoc_req);
 			done = 1;
 			if (ret) {
-				lbs_pr_debug(1, "ASSOC: bssid: ret = %d\n", ret);
+				lbs_deb_assoc("ASSOC: bssid: ret = %d\n", ret);
 			}
 		}
 	}
@@ -126,7 +154,7 @@ static int assoc_helper_associate(wlan_p
 	if (!done && test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {
 		ret = assoc_helper_essid(priv, assoc_req);
 		if (ret) {
-			lbs_pr_debug(1, "ASSOC: bssid: ret = %d\n", ret);
+			lbs_deb_assoc("ASSOC: bssid: ret = %d\n", ret);
 		}
 	}
 
@@ -140,12 +168,10 @@ static int assoc_helper_mode(wlan_privat
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-	if (assoc_req->mode == adapter->mode) {
-		LEAVE();
-		return 0;
-	}
+	if (assoc_req->mode == adapter->mode)
+		goto done;
 
 	if (assoc_req->mode == IW_MODE_INFRA) {
 		if (adapter->psstate != PS_STATE_FULL_POWER)
@@ -158,9 +184,81 @@ static int assoc_helper_mode(wlan_privat
 				    cmd_802_11_snmp_mib,
 				    0, cmd_option_waitforrsp,
 				    OID_802_11_INFRASTRUCTURE_MODE,
-				    (void *) (size_t) assoc_req->mode);
+		/* Shoot me now */  (void *) (size_t) assoc_req->mode);
 
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
+	return ret;
+}
+
+
+static int update_channel(wlan_private * priv)
+{
+	/* the channel in f/w could be out of sync, get the current channel */
+	return libertas_prepare_and_send_command(priv, cmd_802_11_rf_channel,
+				    cmd_opt_802_11_rf_channel_get,
+				    cmd_option_waitforrsp, 0, NULL);
+}
+
+void libertas_sync_channel(struct work_struct *work)
+{
+	wlan_private *priv = container_of(work, wlan_private, sync_channel);
+
+	if (update_channel(priv) != 0)
+		lbs_pr_info("Channel synchronization failed.");
+}
+
+static int assoc_helper_channel(wlan_private *priv,
+                                struct assoc_request * assoc_req)
+{
+	wlan_adapter *adapter = priv->adapter;
+	int ret = 0;
+
+	lbs_deb_enter(LBS_DEB_ASSOC);
+
+	ret = update_channel(priv);
+	if (ret < 0) {
+		lbs_deb_assoc("ASSOC: channel: error getting channel.");
+	}
+
+	if (assoc_req->channel == adapter->curbssparams.channel)
+		goto done;
+
+	lbs_deb_assoc("ASSOC: channel: %d -> %d\n",
+	       adapter->curbssparams.channel, assoc_req->channel);
+
+	ret = libertas_prepare_and_send_command(priv, cmd_802_11_rf_channel,
+				cmd_opt_802_11_rf_channel_set,
+				cmd_option_waitforrsp, 0, &assoc_req->channel);
+	if (ret < 0) {
+		lbs_deb_assoc("ASSOC: channel: error setting channel.");
+	}
+
+	ret = update_channel(priv);
+	if (ret < 0) {
+		lbs_deb_assoc("ASSOC: channel: error getting channel.");
+	}
+
+	if (assoc_req->channel != adapter->curbssparams.channel) {
+		lbs_deb_assoc("ASSOC: channel: failed to update channel to %d",
+		              assoc_req->channel);
+		goto done;
+	}
+
+	if (   assoc_req->secinfo.wep_enabled
+	    &&   (assoc_req->wep_keys[0].len
+	       || assoc_req->wep_keys[1].len
+	       || assoc_req->wep_keys[2].len
+	       || assoc_req->wep_keys[3].len)) {
+		/* Make sure WEP keys are re-sent to firmware */
+		set_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags);
+	}
+
+	/* Must restart/rejoin adhoc networks after channel change */
+	set_bit(ASSOC_FLAG_SSID, &assoc_req->flags);
+
+done:
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -172,7 +270,7 @@ static int assoc_helper_wep_keys(wlan_pr
 	int i;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	/* Set or remove WEP keys */
 	if (   assoc_req->wep_keys[0].len
@@ -216,7 +314,7 @@ static int assoc_helper_wep_keys(wlan_pr
 	mutex_unlock(&adapter->lock);
 
 out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -226,14 +324,24 @@ static int assoc_helper_secinfo(wlan_pri
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	memcpy(&adapter->secinfo, &assoc_req->secinfo,
 		sizeof(struct wlan_802_11_security));
 
 	ret = libertas_set_mac_packet_filter(priv);
+	if (ret)
+		goto out;
 
-	LEAVE();
+	/* enable/disable RSN */
+	ret = libertas_prepare_and_send_command(priv,
+				    cmd_802_11_enable_rsn,
+				    cmd_act_set,
+				    cmd_option_waitforrsp,
+				    0, assoc_req);
+
+out:
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -243,16 +351,7 @@ static int assoc_helper_wpa_keys(wlan_pr
 {
 	int ret = 0;
 
-	ENTER();
-
-	/* enable/Disable RSN */
-	ret = libertas_prepare_and_send_command(priv,
-				    cmd_802_11_enable_rsn,
-				    cmd_act_set,
-				    cmd_option_waitforrsp,
-				    0, assoc_req);
-	if (ret)
-		goto out;
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_key_material,
@@ -260,8 +359,7 @@ static int assoc_helper_wpa_keys(wlan_pr
 				    cmd_option_waitforrsp,
 				    0, assoc_req);
 
-out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -272,7 +370,7 @@ static int assoc_helper_wpa_ie(wlan_priv
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	if (assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled) {
 		memcpy(&adapter->wpa_ie, &assoc_req->wpa_ie, assoc_req->wpa_ie_len);
@@ -282,7 +380,7 @@ static int assoc_helper_wpa_ie(wlan_priv
 		adapter->wpa_ie_len = 0;
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_ASSOC, "ret %d", ret);
 	return ret;
 }
 
@@ -294,25 +392,30 @@ static int should_deauth_infrastructure(
 		return 0;
 
 	if (test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {
-		lbs_pr_debug(1, "Deauthenticating due to new SSID in "
+		lbs_deb_assoc("Deauthenticating due to new SSID in "
 			" configuration request.\n");
 		return 1;
 	}
 
 	if (test_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags)) {
 		if (adapter->secinfo.auth_mode != assoc_req->secinfo.auth_mode) {
-			lbs_pr_debug(1, "Deauthenticating due to updated security "
+			lbs_deb_assoc("Deauthenticating due to updated security "
 				"info in configuration request.\n");
 			return 1;
 		}
 	}
 
 	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {
-		lbs_pr_debug(1, "Deauthenticating due to new BSSID in "
+		lbs_deb_assoc("Deauthenticating due to new BSSID in "
 			" configuration request.\n");
 		return 1;
 	}
 
+	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {
+		lbs_deb_assoc("Deauthenticating due to channel switch.\n");
+		return 1;
+	}
+
 	/* FIXME: deal with 'auto' mode somehow */
 	if (test_bit(ASSOC_FLAG_MODE, &assoc_req->flags)) {
 		if (assoc_req->mode != IW_MODE_INFRA)
@@ -329,10 +432,9 @@ static int should_stop_adhoc(wlan_adapte
 	if (adapter->connect_status != libertas_connected)
 		return 0;
 
-	if (adapter->curbssparams.ssid.ssidlength != assoc_req->ssid.ssidlength)
-		return 1;
-	if (memcmp(adapter->curbssparams.ssid.ssid, assoc_req->ssid.ssid,
-			adapter->curbssparams.ssid.ssidlength))
+	if (libertas_ssid_cmp(adapter->curbssparams.ssid,
+	                      adapter->curbssparams.ssid_len,
+	                      assoc_req->ssid, assoc_req->ssid_len) != 0)
 		return 1;
 
 	/* FIXME: deal with 'auto' mode somehow */
@@ -341,11 +443,16 @@ static int should_stop_adhoc(wlan_adapte
 			return 1;
 	}
 
+	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {
+		if (assoc_req->channel != adapter->curbssparams.channel)
+			return 1;
+	}
+
 	return 0;
 }
 
 
-void wlan_association_worker(struct work_struct *work)
+void libertas_association_worker(struct work_struct *work)
 {
 	wlan_private *priv = container_of(work, wlan_private, assoc_work.work);
 	wlan_adapter *adapter = priv->adapter;
@@ -353,40 +460,38 @@ void wlan_association_worker(struct work
 	int ret = 0;
 	int find_any_ssid = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	mutex_lock(&adapter->lock);
-	assoc_req = adapter->assoc_req;
-	adapter->assoc_req = NULL;
+	assoc_req = adapter->pending_assoc_req;
+	adapter->pending_assoc_req = NULL;
+	adapter->in_progress_assoc_req = assoc_req;
 	mutex_unlock(&adapter->lock);
 
-	if (!assoc_req) {
-		LEAVE();
-		return;
-	}
+	if (!assoc_req)
+		goto done;
 
-	lbs_pr_debug(1, "ASSOC: starting new association request: flags = 0x%lX\n",
-		assoc_req->flags);
+	print_assoc_req(__func__, assoc_req);
 
 	/* If 'any' SSID was specified, find an SSID to associate with */
 	if (test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)
-	    && !assoc_req->ssid.ssidlength)
+	    && !assoc_req->ssid_len)
 		find_any_ssid = 1;
 
 	/* But don't use 'any' SSID if there's a valid locked BSSID to use */
 	if (test_bit(ASSOC_FLAG_BSSID, &assoc_req->flags)) {
-		if (memcmp(&assoc_req->bssid, bssid_any, ETH_ALEN)
-		    && memcmp(&assoc_req->bssid, bssid_off, ETH_ALEN))
+		if (compare_ether_addr(assoc_req->bssid, bssid_any)
+		    && compare_ether_addr(assoc_req->bssid, bssid_off))
 			find_any_ssid = 0;
 	}
 
 	if (find_any_ssid) {
 		u8 new_mode;
 
-		ret = libertas_find_best_network_SSID(priv, &assoc_req->ssid,
-				assoc_req->mode, &new_mode);
+		ret = libertas_find_best_network_ssid(priv, assoc_req->ssid,
+				&assoc_req->ssid_len, assoc_req->mode, &new_mode);
 		if (ret) {
-			lbs_pr_debug(1, "Could not find best network\n");
+			lbs_deb_assoc("Could not find best network\n");
 			ret = -ENETUNREACH;
 			goto out;
 		}
@@ -406,7 +511,7 @@ void wlan_association_worker(struct work
 		if (should_deauth_infrastructure(adapter, assoc_req)) {
 			ret = libertas_send_deauthentication(priv);
 			if (ret) {
-				lbs_pr_debug(1, "Deauthentication due to new "
+				lbs_deb_assoc("Deauthentication due to new "
 					"configuration request failed: %d\n",
 					ret);
 			}
@@ -415,7 +520,7 @@ void wlan_association_worker(struct work
 		if (should_stop_adhoc(adapter, assoc_req)) {
 			ret = libertas_stop_adhoc_network(priv);
 			if (ret) {
-				lbs_pr_debug(1, "Teardown of AdHoc network due to "
+				lbs_deb_assoc("Teardown of AdHoc network due to "
 					"new configuration request failed: %d\n",
 					ret);
 			}
@@ -427,7 +532,16 @@ void wlan_association_worker(struct work
 	if (test_bit(ASSOC_FLAG_MODE, &assoc_req->flags)) {
 		ret = assoc_helper_mode(priv, assoc_req);
 		if (ret) {
-lbs_pr_debug(1, "ASSOC(:%d) mode: ret = %d\n", __LINE__, ret);
+lbs_deb_assoc("ASSOC(:%d) mode: ret = %d\n", __LINE__, ret);
+			goto out;
+		}
+	}
+
+	if (test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags)) {
+		ret = assoc_helper_channel(priv, assoc_req);
+		if (ret) {
+			lbs_deb_assoc("ASSOC(:%d) channel: ret = %d\n",
+			              __LINE__, ret);
 			goto out;
 		}
 	}
@@ -436,7 +550,7 @@ lbs_pr_debug(1, "ASSOC(:%d) mode: ret = 
 	    || test_bit(ASSOC_FLAG_WEP_TX_KEYIDX, &assoc_req->flags)) {
 		ret = assoc_helper_wep_keys(priv, assoc_req);
 		if (ret) {
-lbs_pr_debug(1, "ASSOC(:%d) wep_keys: ret = %d\n", __LINE__, ret);
+lbs_deb_assoc("ASSOC(:%d) wep_keys: ret = %d\n", __LINE__, ret);
 			goto out;
 		}
 	}
@@ -444,7 +558,7 @@ lbs_pr_debug(1, "ASSOC(:%d) wep_keys: re
 	if (test_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags)) {
 		ret = assoc_helper_secinfo(priv, assoc_req);
 		if (ret) {
-lbs_pr_debug(1, "ASSOC(:%d) secinfo: ret = %d\n", __LINE__, ret);
+lbs_deb_assoc("ASSOC(:%d) secinfo: ret = %d\n", __LINE__, ret);
 			goto out;
 		}
 	}
@@ -452,7 +566,7 @@ lbs_pr_debug(1, "ASSOC(:%d) secinfo: ret
 	if (test_bit(ASSOC_FLAG_WPA_IE, &assoc_req->flags)) {
 		ret = assoc_helper_wpa_ie(priv, assoc_req);
 		if (ret) {
-lbs_pr_debug(1, "ASSOC(:%d) wpa_ie: ret = %d\n", __LINE__, ret);
+lbs_deb_assoc("ASSOC(:%d) wpa_ie: ret = %d\n", __LINE__, ret);
 			goto out;
 		}
 	}
@@ -461,7 +575,7 @@ lbs_pr_debug(1, "ASSOC(:%d) wpa_ie: ret 
 	    || test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags)) {
 		ret = assoc_helper_wpa_keys(priv, assoc_req);
 		if (ret) {
-lbs_pr_debug(1, "ASSOC(:%d) wpa_keys: ret = %d\n", __LINE__, ret);
+lbs_deb_assoc("ASSOC(:%d) wpa_keys: ret = %d\n", __LINE__, ret);
 			goto out;
 		}
 	}
@@ -475,21 +589,23 @@ lbs_pr_debug(1, "ASSOC(:%d) wpa_keys: re
 
 		ret = assoc_helper_associate(priv, assoc_req);
 		if (ret) {
-			lbs_pr_debug(1, "ASSOC: association attempt unsuccessful: %d\n",
+			lbs_deb_assoc("ASSOC: association attempt unsuccessful: %d\n",
 				ret);
 			success = 0;
 		}
 
 		if (adapter->connect_status != libertas_connected) {
-			lbs_pr_debug(1, "ASSOC: assoication attempt unsuccessful, "
+			lbs_deb_assoc("ASSOC: assoication attempt unsuccessful, "
 				"not connected.\n");
 			success = 0;
 		}
 
 		if (success) {
-			lbs_pr_debug(1, "ASSOC: association attempt successful. "
+			lbs_deb_assoc("ASSOC: association attempt successful. "
 				"Associated to '%s' (" MAC_FMT ")\n",
-				assoc_req->ssid.ssid, MAC_ARG(assoc_req->bssid));
+				escape_essid(adapter->curbssparams.ssid,
+				             adapter->curbssparams.ssid_len),
+				MAC_ARG(adapter->curbssparams.bssid));
 			libertas_prepare_and_send_command(priv,
 				cmd_802_11_rssi,
 				0, cmd_option_waitforrsp, 0, NULL);
@@ -498,18 +614,23 @@ lbs_pr_debug(1, "ASSOC(:%d) wpa_keys: re
 				cmd_802_11_get_log,
 				0, cmd_option_waitforrsp, 0, NULL);
 		} else {
-
 			ret = -1;
 		}
 	}
 
 out:
 	if (ret) {
-		lbs_pr_debug(1, "ASSOC: reconfiguration attempt unsuccessful: %d\n",
+		lbs_deb_assoc("ASSOC: reconfiguration attempt unsuccessful: %d\n",
 			ret);
 	}
+
+	mutex_lock(&adapter->lock);
+	adapter->in_progress_assoc_req = NULL;
+	mutex_unlock(&adapter->lock);
 	kfree(assoc_req);
-	LEAVE();
+
+done:
+	lbs_deb_leave(LBS_DEB_ASSOC);
 }
 
 
@@ -520,9 +641,10 @@ struct assoc_request * wlan_get_associat
 {
 	struct assoc_request * assoc_req;
 
-	if (!adapter->assoc_req) {
-		adapter->assoc_req = kzalloc(sizeof(struct assoc_request), GFP_KERNEL);
-		if (!adapter->assoc_req) {
+	if (!adapter->pending_assoc_req) {
+		adapter->pending_assoc_req = kzalloc(sizeof(struct assoc_request),
+		                                     GFP_KERNEL);
+		if (!adapter->pending_assoc_req) {
 			lbs_pr_info("Not enough memory to allocate association"
 				" request!\n");
 			return NULL;
@@ -532,15 +654,19 @@ struct assoc_request * wlan_get_associat
 	/* Copy current configuration attributes to the association request,
 	 * but don't overwrite any that are already set.
 	 */
-	assoc_req = adapter->assoc_req;
+	assoc_req = adapter->pending_assoc_req;
 	if (!test_bit(ASSOC_FLAG_SSID, &assoc_req->flags)) {
-		memcpy(&assoc_req->ssid, adapter->curbssparams.ssid.ssid,
-			adapter->curbssparams.ssid.ssidlength);
+		memcpy(&assoc_req->ssid, &adapter->curbssparams.ssid,
+		       IW_ESSID_MAX_SIZE);
+		assoc_req->ssid_len = adapter->curbssparams.ssid_len;
 	}
 
 	if (!test_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags))
 		assoc_req->channel = adapter->curbssparams.channel;
 
+	if (!test_bit(ASSOC_FLAG_BAND, &assoc_req->flags))
+		assoc_req->band = adapter->curbssparams.band;
+
 	if (!test_bit(ASSOC_FLAG_MODE, &assoc_req->flags))
 		assoc_req->mode = adapter->mode;
 
@@ -581,7 +707,7 @@ struct assoc_request * wlan_get_associat
 		assoc_req->wpa_ie_len = adapter->wpa_ie_len;
 	}
 
+	print_assoc_req(__func__, assoc_req);
+
 	return assoc_req;
 }
-
-
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/assoc.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/assoc.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/assoc.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/assoc.h	2007-06-14 14:14:33.000000000 -0400
@@ -5,10 +5,12 @@
 
 #include "dev.h"
 
-void wlan_association_worker(struct work_struct *work);
+void libertas_association_worker(struct work_struct *work);
 
 struct assoc_request * wlan_get_association_request(wlan_adapter *adapter);
 
+void libertas_sync_channel(struct work_struct *work);
+
 #define ASSOC_DELAY (HZ / 2)
 static inline void wlan_postpone_association_work(wlan_private *priv)
 {
@@ -21,9 +23,9 @@ static inline void wlan_postpone_associa
 static inline void wlan_cancel_association_work(wlan_private *priv)
 {
 	cancel_delayed_work(&priv->assoc_work);
-	if (priv->adapter->assoc_req) {
-		kfree(priv->adapter->assoc_req);
-		priv->adapter->assoc_req = NULL;
+	if (priv->adapter->pending_assoc_req) {
+		kfree(priv->adapter->pending_assoc_req);
+		priv->adapter->pending_assoc_req = NULL;
 	}
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/cmd.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/cmd.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/cmd.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/cmd.c	2007-06-14 14:14:33.000000000 -0400
@@ -6,7 +6,6 @@
 #include <net/iw_handler.h>
 #include "host.h"
 #include "hostcmd.h"
-#include "sbi.h"
 #include "decl.h"
 #include "defs.h"
 #include "dev.h"
@@ -26,13 +25,11 @@ static u16 commands_allowed_in_ps[] = {
  *  @param command the command ID
  *  @return 	   TRUE or FALSE
  */
-static u8 is_command_allowed_in_ps(u16 command)
+static u8 is_command_allowed_in_ps(__le16 command)
 {
-	int count = sizeof(commands_allowed_in_ps)
-	    / sizeof(commands_allowed_in_ps[0]);
 	int i;
 
-	for (i = 0; i < count; i++) {
+	for (i = 0; i < ARRAY_SIZE(commands_allowed_in_ps); i++) {
 		if (command == cpu_to_le16(commands_allowed_in_ps[i]))
 			return 1;
 	}
@@ -44,14 +41,13 @@ static int wlan_cmd_hw_spec(wlan_private
 {
 	struct cmd_ds_get_hw_spec *hwspec = &cmd->params.hwspec;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_get_hw_spec);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_get_hw_spec) + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_get_hw_spec) + S_DS_GEN);
 	memcpy(hwspec->permanentaddr, priv->adapter->current_addr, ETH_ALEN);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -60,21 +56,19 @@ static int wlan_cmd_802_11_ps_mode(wlan_
 				   u16 cmd_action)
 {
 	struct cmd_ds_802_11_ps_mode *psm = &cmd->params.psmode;
-	u16 action = cmd_action;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_802_11_ps_mode);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_ps_mode) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_ps_mode) +
+				S_DS_GEN);
 	psm->action = cpu_to_le16(cmd_action);
 	psm->multipledtim = 0;
-	switch (action) {
+	switch (cmd_action) {
 	case cmd_subcmd_enter_ps:
-		lbs_pr_debug(1, "PS command:" "SubCode- Enter PS\n");
-		lbs_pr_debug(1, "locallisteninterval = %d\n",
+		lbs_deb_cmd("PS command:" "SubCode- Enter PS\n");
+		lbs_deb_cmd("locallisteninterval = %d\n",
 		       adapter->locallisteninterval);
 
 		psm->locallisteninterval =
@@ -86,18 +80,18 @@ static int wlan_cmd_802_11_ps_mode(wlan_
 		break;
 
 	case cmd_subcmd_exit_ps:
-		lbs_pr_debug(1, "PS command:" "SubCode- Exit PS\n");
+		lbs_deb_cmd("PS command:" "SubCode- Exit PS\n");
 		break;
 
 	case cmd_subcmd_sleep_confirmed:
-		lbs_pr_debug(1, "PS command: SubCode- sleep confirm\n");
+		lbs_deb_cmd("PS command: SubCode- sleep confirm\n");
 		break;
 
 	default:
 		break;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -115,8 +109,7 @@ static int wlan_cmd_802_11_inactivity_ti
 	cmd->params.inactivity_timeout.action = cpu_to_le16(cmd_action);
 
 	if (cmd_action)
-		cmd->params.inactivity_timeout.timeout =
-		    cpu_to_le16(*timeout);
+		cmd->params.inactivity_timeout.timeout = cpu_to_le16(*timeout);
 	else
 		cmd->params.inactivity_timeout.timeout = 0;
 
@@ -130,11 +123,10 @@ static int wlan_cmd_802_11_sleep_params(
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_sleep_params *sp = &cmd->params.sleep_params;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	cmd->size =
-	    cpu_to_le16((sizeof(struct cmd_ds_802_11_sleep_params)) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16((sizeof(struct cmd_ds_802_11_sleep_params)) +
+				S_DS_GEN);
 	cmd->command = cpu_to_le16(cmd_802_11_sleep_params);
 
 	if (cmd_action == cmd_act_get) {
@@ -151,7 +143,7 @@ static int wlan_cmd_802_11_sleep_params(
 		sp->reserved = cpu_to_le16(adapter->sp.sp_reserved);
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -165,17 +157,16 @@ static int wlan_cmd_802_11_set_wep(wlan_
 	int ret = 0;
 	struct assoc_request * assoc_req = pdata_buf;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_802_11_set_wep);
-	cmd->size = cpu_to_le16((sizeof(struct cmd_ds_802_11_set_wep))
-	                             + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(*wep) + S_DS_GEN);
 
 	if (cmd_act == cmd_act_add) {
 		int i;
 
 		if (!assoc_req) {
-			lbs_pr_debug(1, "Invalid association request!");
+			lbs_deb_cmd("Invalid association request!");
 			ret = -1;
 			goto done;
 		}
@@ -183,11 +174,10 @@ static int wlan_cmd_802_11_set_wep(wlan_
 		wep->action = cpu_to_le16(cmd_act_add);
 
 		/* default tx key index */
-		wep->keyindex = cpu_to_le16((u16)
-				                 (assoc_req->wep_tx_keyidx &
-				                 (u32)cmd_WEP_KEY_INDEX_MASK));
+		wep->keyindex = cpu_to_le16((u16)(assoc_req->wep_tx_keyidx &
+						  (u32)cmd_WEP_KEY_INDEX_MASK));
 
-		lbs_pr_debug(1, "Tx key Index: %u\n", wep->keyindex);
+		lbs_deb_cmd("Tx key Index: %u\n", le16_to_cpu(wep->keyindex));
 
 		/* Copy key types and material to host command structure */
 		for (i = 0; i < 4; i++) {
@@ -195,19 +185,21 @@ static int wlan_cmd_802_11_set_wep(wlan_
 
 			switch (pkey->len) {
 			case KEY_LEN_WEP_40:
-				wep->keytype[i] = cmd_type_wep_40_bit;
+				wep->keytype[i] =
+					cpu_to_le16(cmd_type_wep_40_bit);
 				memmove(&wep->keymaterial[i], pkey->key,
 				        pkey->len);
 				break;
 			case KEY_LEN_WEP_104:
-				wep->keytype[i] = cmd_type_wep_104_bit;
+				wep->keytype[i] =
+					cpu_to_le16(cmd_type_wep_104_bit);
 				memmove(&wep->keymaterial[i], pkey->key,
 				        pkey->len);
 				break;
 			case 0:
 				break;
 			default:
-				lbs_pr_debug(1, "Invalid WEP key %d length of %d\n",
+				lbs_deb_cmd("Invalid WEP key %d length of %d\n",
 				       i, pkey->len);
 				ret = -1;
 				goto done;
@@ -219,36 +211,37 @@ static int wlan_cmd_802_11_set_wep(wlan_
 		wep->action = cpu_to_le16(cmd_act_remove);
 
 		/* default tx key index */
-		wep->keyindex = cpu_to_le16((u16)
-				                 (adapter->wep_tx_keyidx &
-				                 (u32)cmd_WEP_KEY_INDEX_MASK));
+		wep->keyindex = cpu_to_le16((u16)(adapter->wep_tx_keyidx &
+						  (u32)cmd_WEP_KEY_INDEX_MASK));
 	}
 
 	ret = 0;
 
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
 static int wlan_cmd_802_11_enable_rsn(wlan_private * priv,
 				      struct cmd_ds_command *cmd,
-				      u16 cmd_action)
+				      u16 cmd_action,
+				      void * pdata_buf)
 {
 	struct cmd_ds_802_11_enable_rsn *penableRSN = &cmd->params.enbrsn;
-	wlan_adapter *adapter = priv->adapter;
+	struct assoc_request * assoc_req = pdata_buf;
+
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_802_11_enable_rsn);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_enable_rsn) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(*penableRSN) + S_DS_GEN);
 	penableRSN->action = cpu_to_le16(cmd_action);
-	if (adapter->secinfo.WPAenabled || adapter->secinfo.WPA2enabled) {
+	if (assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled) {
 		penableRSN->enable = cpu_to_le16(cmd_enable_rsn);
 	} else {
 		penableRSN->enable = cpu_to_le16(cmd_disable_rsn);
 	}
 
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -259,14 +252,12 @@ static void set_one_wpa_key(struct MrvlI
 	pkeyparamset->keytypeid = cpu_to_le16(pkey->type);
 
 	if (pkey->flags & KEY_INFO_WPA_ENABLED) {
-		pkeyparamset->keyinfo = cpu_to_le16(KEY_INFO_WPA_ENABLED);
-	} else {
-		pkeyparamset->keyinfo = cpu_to_le16(!KEY_INFO_WPA_ENABLED);
+		pkeyparamset->keyinfo |= cpu_to_le16(KEY_INFO_WPA_ENABLED);
 	}
-
 	if (pkey->flags & KEY_INFO_WPA_UNICAST) {
 		pkeyparamset->keyinfo |= cpu_to_le16(KEY_INFO_WPA_UNICAST);
-	} else if (pkey->flags & KEY_INFO_WPA_MCAST) {
+	}
+	if (pkey->flags & KEY_INFO_WPA_MCAST) {
 		pkeyparamset->keyinfo |= cpu_to_le16(KEY_INFO_WPA_MCAST);
 	}
 
@@ -284,46 +275,45 @@ static int wlan_cmd_802_11_key_material(
 					u16 cmd_action,
 					u32 cmd_oid, void *pdata_buf)
 {
-	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_key_material *pkeymaterial =
 	    &cmd->params.keymaterial;
+	struct assoc_request * assoc_req = pdata_buf;
 	int ret = 0;
 	int index = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_802_11_key_material);
 	pkeymaterial->action = cpu_to_le16(cmd_action);
 
 	if (cmd_action == cmd_act_get) {
-		cmd->size = cpu_to_le16(  S_DS_GEN
-		                             + sizeof (pkeymaterial->action));
+		cmd->size = cpu_to_le16(S_DS_GEN + sizeof (pkeymaterial->action));
 		ret = 0;
 		goto done;
 	}
 
 	memset(&pkeymaterial->keyParamSet, 0, sizeof(pkeymaterial->keyParamSet));
 
-	if (adapter->wpa_unicast_key.len) {
+	if (test_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags)) {
 		set_one_wpa_key(&pkeymaterial->keyParamSet[index],
-		                &adapter->wpa_unicast_key);
+		                &assoc_req->wpa_unicast_key);
 		index++;
 	}
 
-	if (adapter->wpa_mcast_key.len) {
+	if (test_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags)) {
 		set_one_wpa_key(&pkeymaterial->keyParamSet[index],
-		                &adapter->wpa_mcast_key);
+		                &assoc_req->wpa_mcast_key);
 		index++;
 	}
 
 	cmd->size = cpu_to_le16(  S_DS_GEN
-	                             + sizeof (pkeymaterial->action)
-	                             + index * sizeof(struct MrvlIEtype_keyParamSet));
+	                        + sizeof (pkeymaterial->action)
+	                        + (index * sizeof(struct MrvlIEtype_keyParamSet)));
 
 	ret = 0;
 
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -354,8 +344,7 @@ static int wlan_cmd_802_11_get_stat(wlan
 {
 	cmd->command = cpu_to_le16(cmd_802_11_get_stat);
 	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_get_stat) +
-			     S_DS_GEN);
+	    cpu_to_le16(sizeof(struct cmd_ds_802_11_get_stat) + S_DS_GEN);
 
 	return 0;
 }
@@ -369,14 +358,12 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 	wlan_adapter *adapter = priv->adapter;
 	u8 ucTemp;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);
+	lbs_deb_cmd("SNMP_CMD: cmd_oid = 0x%x\n", cmd_oid);
 
 	cmd->command = cpu_to_le16(cmd_802_11_snmp_mib);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_snmp_mib) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(*pSNMPMIB) + S_DS_GEN);
 
 	switch (cmd_oid) {
 	case OID_802_11_INFRASTRUCTURE_MODE:
@@ -407,7 +394,7 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 				pSNMPMIB->querytype = cmd_act_set;
 				pSNMPMIB->bufsize = sizeof(u16);
 				ulTemp = *(u32 *)pdata_buf;
-				*((unsigned short *)(pSNMPMIB->value)) =
+				*((__le16 *)(pSNMPMIB->value)) =
 				    cpu_to_le16((u16) ulTemp);
 			}
 			break;
@@ -420,15 +407,12 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 			pSNMPMIB->oid = cpu_to_le16((u16) fragthresh_i);
 
 			if (cmd_action == cmd_act_get) {
-				pSNMPMIB->querytype =
-				    cpu_to_le16(cmd_act_get);
+				pSNMPMIB->querytype = cpu_to_le16(cmd_act_get);
 			} else if (cmd_action == cmd_act_set) {
-				pSNMPMIB->querytype =
-				    cpu_to_le16(cmd_act_set);
-				pSNMPMIB->bufsize =
-				    cpu_to_le16(sizeof(u16));
+				pSNMPMIB->querytype = cpu_to_le16(cmd_act_set);
+				pSNMPMIB->bufsize = cpu_to_le16(sizeof(u16));
 				ulTemp = *((u32 *) pdata_buf);
-				*((unsigned short *)(pSNMPMIB->value)) =
+				*((__le16 *)(pSNMPMIB->value)) =
 				    cpu_to_le16((u16) ulTemp);
 
 			}
@@ -443,16 +427,12 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 			pSNMPMIB->oid = le16_to_cpu((u16) rtsthresh_i);
 
 			if (cmd_action == cmd_act_get) {
-				pSNMPMIB->querytype =
-				    cpu_to_le16(cmd_act_get);
+				pSNMPMIB->querytype = cpu_to_le16(cmd_act_get);
 			} else if (cmd_action == cmd_act_set) {
-				pSNMPMIB->querytype =
-				    cpu_to_le16(cmd_act_set);
-				pSNMPMIB->bufsize =
-				    cpu_to_le16(sizeof(u16));
-				ulTemp = *((u32 *)
-					   pdata_buf);
-				*(unsigned short *)(pSNMPMIB->value) =
+				pSNMPMIB->querytype = cpu_to_le16(cmd_act_set);
+				pSNMPMIB->bufsize = cpu_to_le16(sizeof(u16));
+				ulTemp = *((u32 *)pdata_buf);
+				*(__le16 *)(pSNMPMIB->value) =
 				    cpu_to_le16((u16) ulTemp);
 
 			}
@@ -462,13 +442,11 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 		pSNMPMIB->oid = cpu_to_le16((u16) short_retrylim_i);
 
 		if (cmd_action == cmd_act_get) {
-			pSNMPMIB->querytype =
-			    cpu_to_le16(cmd_act_get);
+			pSNMPMIB->querytype = cpu_to_le16(cmd_act_get);
 		} else if (cmd_action == cmd_act_set) {
-			pSNMPMIB->querytype =
-			    cpu_to_le16(cmd_act_set);
+			pSNMPMIB->querytype = cpu_to_le16(cmd_act_set);
 			pSNMPMIB->bufsize = cpu_to_le16(sizeof(u16));
-			*((unsigned short *)(pSNMPMIB->value)) =
+			*((__le16 *)(pSNMPMIB->value)) =
 			    cpu_to_le16((u16) adapter->txretrycount);
 		}
 
@@ -477,16 +455,18 @@ static int wlan_cmd_802_11_snmp_mib(wlan
 		break;
 	}
 
-	lbs_pr_debug(1,
+	lbs_deb_cmd(
 	       "SNMP_CMD: command=0x%x, size=0x%x, seqnum=0x%x, result=0x%x\n",
-	       cmd->command, cmd->size, cmd->seqnum, cmd->result);
+	       le16_to_cpu(cmd->command), le16_to_cpu(cmd->size),
+	       le16_to_cpu(cmd->seqnum), le16_to_cpu(cmd->result));
 
-	lbs_pr_debug(1,
+	lbs_deb_cmd(
 	       "SNMP_CMD: action=0x%x, oid=0x%x, oidsize=0x%x, value=0x%x\n",
-	       pSNMPMIB->querytype, pSNMPMIB->oid, pSNMPMIB->bufsize,
-	       *(u16 *) pSNMPMIB->value);
+	       le16_to_cpu(pSNMPMIB->querytype), le16_to_cpu(pSNMPMIB->oid),
+	       le16_to_cpu(pSNMPMIB->bufsize),
+	       le16_to_cpu(*(__le16 *) pSNMPMIB->value));
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -495,10 +475,9 @@ static int wlan_cmd_802_11_radio_control
 					 int cmd_action)
 {
 	wlan_adapter *adapter = priv->adapter;
-	struct cmd_ds_802_11_radio_control *pradiocontrol =
-	    &cmd->params.radio;
+	struct cmd_ds_802_11_radio_control *pradiocontrol = &cmd->params.radio;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->size =
 	    cpu_to_le16((sizeof(struct cmd_ds_802_11_radio_control)) +
@@ -527,7 +506,7 @@ static int wlan_cmd_802_11_radio_control
 	else
 		pradiocontrol->control &= cpu_to_le16(~TURN_ON_RF);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -538,16 +517,16 @@ static int wlan_cmd_802_11_rf_tx_power(w
 
 	struct cmd_ds_802_11_rf_tx_power *prtp = &cmd->params.txp;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->size =
-	    cpu_to_le16((sizeof(struct cmd_ds_802_11_rf_tx_power)) +
-			     S_DS_GEN);
+	    cpu_to_le16((sizeof(struct cmd_ds_802_11_rf_tx_power)) + S_DS_GEN);
 	cmd->command = cpu_to_le16(cmd_802_11_rf_tx_power);
-	prtp->action = cmd_action;
+	prtp->action = cpu_to_le16(cmd_action);
 
-	lbs_pr_debug(1, "RF_TX_POWER_CMD: size:%d cmd:0x%x Act:%d\n", cmd->size,
-	       cmd->command, prtp->action);
+	lbs_deb_cmd("RF_TX_POWER_CMD: size:%d cmd:0x%x Act:%d\n",
+		    le16_to_cpu(cmd->size), le16_to_cpu(cmd->command),
+		    le16_to_cpu(prtp->action));
 
 	switch (cmd_action) {
 	case cmd_act_tx_power_opt_get:
@@ -557,14 +536,12 @@ static int wlan_cmd_802_11_rf_tx_power(w
 
 	case cmd_act_tx_power_opt_set_high:
 		prtp->action = cpu_to_le16(cmd_act_set);
-		prtp->currentlevel =
-		    cpu_to_le16(cmd_act_tx_power_index_high);
+		prtp->currentlevel = cpu_to_le16(cmd_act_tx_power_index_high);
 		break;
 
 	case cmd_act_tx_power_opt_set_mid:
 		prtp->action = cpu_to_le16(cmd_act_set);
-		prtp->currentlevel =
-		    cpu_to_le16(cmd_act_tx_power_index_mid);
+		prtp->currentlevel = cpu_to_le16(cmd_act_tx_power_index_mid);
 		break;
 
 	case cmd_act_tx_power_opt_set_low:
@@ -572,7 +549,8 @@ static int wlan_cmd_802_11_rf_tx_power(w
 		prtp->currentlevel = cpu_to_le16(*((u16 *) pdata_buf));
 		break;
 	}
-	LEAVE();
+
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -583,15 +561,12 @@ static int wlan_cmd_802_11_rf_antenna(wl
 	struct cmd_ds_802_11_rf_antenna *rant = &cmd->params.rant;
 
 	cmd->command = cpu_to_le16(cmd_802_11_rf_antenna);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_rf_antenna) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_rf_antenna) +
+				S_DS_GEN);
 
 	rant->action = cpu_to_le16(cmd_action);
-	if ((cmd_action == cmd_act_set_rx) ||
-	    (cmd_action == cmd_act_set_tx)) {
-		rant->antennamode =
-		    cpu_to_le16((u16) (*(u32 *) pdata_buf));
+	if ((cmd_action == cmd_act_set_rx) || (cmd_action == cmd_act_set_tx)) {
+		rant->antennamode = cpu_to_le16((u16) (*(u32 *) pdata_buf));
 	}
 
 	return 0;
@@ -610,13 +585,13 @@ static int wlan_cmd_802_11_rate_adapt_ra
 			     + S_DS_GEN);
 	cmd->command = cpu_to_le16(cmd_802_11_rate_adapt_rateset);
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	rateadapt->action = cmd_action;
-	rateadapt->enablehwauto = adapter->enablehwauto;
-	rateadapt->bitmap = adapter->ratebitmap;
+	rateadapt->action = cpu_to_le16(cmd_action);
+	rateadapt->enablehwauto = cpu_to_le16(adapter->enablehwauto);
+	rateadapt->bitmap = cpu_to_le16(adapter->ratebitmap);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -626,12 +601,10 @@ static int wlan_cmd_802_11_data_rate(wla
 {
 	struct cmd_ds_802_11_data_rate *pdatarate = &cmd->params.drate;
 	wlan_adapter *adapter = priv->adapter;
-	u16 action = cmd_action;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_data_rate) +
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_data_rate) +
 			     S_DS_GEN);
 
 	cmd->command = cpu_to_le16(cmd_802_11_data_rate);
@@ -640,15 +613,15 @@ static int wlan_cmd_802_11_data_rate(wla
 
 	pdatarate->action = cpu_to_le16(cmd_action);
 
-	if (action == cmd_act_set_tx_fix_rate) {
+	if (cmd_action == cmd_act_set_tx_fix_rate) {
 		pdatarate->datarate[0] = libertas_data_rate_to_index(adapter->datarate);
-		lbs_pr_debug(1, "Setting FW for fixed rate 0x%02X\n",
+		lbs_deb_cmd("Setting FW for fixed rate 0x%02X\n",
 		       adapter->datarate);
-	} else if (action == cmd_act_set_tx_auto) {
-		lbs_pr_debug(1, "Setting FW for AUTO rate\n");
+	} else if (cmd_action == cmd_act_set_tx_auto) {
+		lbs_deb_cmd("Setting FW for AUTO rate\n");
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -659,8 +632,7 @@ static int wlan_cmd_mac_multicast_adr(wl
 	struct cmd_ds_mac_multicast_adr *pMCastAdr = &cmd->params.madr;
 	wlan_adapter *adapter = priv->adapter;
 
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_mac_multicast_adr) +
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_mac_multicast_adr) +
 			     S_DS_GEN);
 	cmd->command = cpu_to_le16(cmd_mac_multicast_adr);
 
@@ -680,8 +652,8 @@ static int wlan_cmd_802_11_rf_channel(wl
 	struct cmd_ds_802_11_rf_channel *rfchan = &cmd->params.rfchannel;
 
 	cmd->command = cpu_to_le16(cmd_802_11_rf_channel);
-	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_rf_channel)
-				     + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_rf_channel) +
+				S_DS_GEN);
 
 	if (option == cmd_opt_802_11_rf_channel_set) {
 		rfchan->currentchannel = cpu_to_le16(*((u16 *) pdata_buf));
@@ -698,9 +670,8 @@ static int wlan_cmd_802_11_rssi(wlan_pri
 	wlan_adapter *adapter = priv->adapter;
 
 	cmd->command = cpu_to_le16(cmd_802_11_rssi);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_rssi) + S_DS_GEN);
-	cmd->params.rssi.N = priv->adapter->bcn_avg_factor;
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_rssi) + S_DS_GEN);
+	cmd->params.rssi.N = cpu_to_le16(priv->adapter->bcn_avg_factor);
 
 	/* reset Beacon SNR/NF/RSSI values */
 	adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = 0;
@@ -719,7 +690,7 @@ static int wlan_cmd_reg_access(wlan_priv
 {
 	struct wlan_offset_value *offval;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	offval = (struct wlan_offset_value *)pdata_buf;
 
@@ -729,9 +700,8 @@ static int wlan_cmd_reg_access(wlan_priv
 			struct cmd_ds_mac_reg_access *macreg;
 
 			cmdptr->size =
-			    cpu_to_le16(sizeof
-					     (struct cmd_ds_mac_reg_access)
-					     + S_DS_GEN);
+			    cpu_to_le16(sizeof (struct cmd_ds_mac_reg_access)
+					+ S_DS_GEN);
 			macreg =
 			    (struct cmd_ds_mac_reg_access *)&cmdptr->params.
 			    macreg;
@@ -785,7 +755,7 @@ static int wlan_cmd_reg_access(wlan_priv
 		break;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -796,8 +766,7 @@ static int wlan_cmd_802_11_mac_address(w
 	wlan_adapter *adapter = priv->adapter;
 
 	cmd->command = cpu_to_le16(cmd_802_11_mac_address);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_mac_address) +
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_mac_address) +
 			     S_DS_GEN);
 	cmd->result = 0;
 
@@ -818,12 +787,11 @@ static int wlan_cmd_802_11_eeprom_access
 {
 	struct wlan_ioctl_regrdwr *ea = pdata_buf;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_802_11_eeprom_access);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_eeprom_access) +
-			     S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_eeprom_access) +
+				S_DS_GEN);
 	cmd->result = 0;
 
 	cmd->params.rdeeprom.action = cpu_to_le16(ea->action);
@@ -839,11 +807,10 @@ static int wlan_cmd_bt_access(wlan_priva
 			       u16 cmd_action, void *pdata_buf)
 {
 	struct cmd_ds_bt_access *bt_access = &cmd->params.bt;
-	lbs_pr_debug(1, "BT CMD(%d)\n", cmd_action);
+	lbs_deb_cmd("BT CMD(%d)\n", cmd_action);
 
 	cmd->command = cpu_to_le16(cmd_bt_access);
-	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_bt_access)
-				     + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_bt_access) + S_DS_GEN);
 	cmd->result = 0;
 	bt_access->action = cpu_to_le16(cmd_action);
 
@@ -861,6 +828,11 @@ static int wlan_cmd_bt_access(wlan_priva
 		break;
 	case cmd_act_bt_access_reset:
 		break;
+	case cmd_act_bt_access_set_invert:
+		bt_access->id = cpu_to_le32(*(u32 *) pdata_buf);
+		break;
+	case cmd_act_bt_access_get_invert:
+		break;
 	default:
 		break;
 	}
@@ -872,11 +844,10 @@ static int wlan_cmd_fwt_access(wlan_priv
 			       u16 cmd_action, void *pdata_buf)
 {
 	struct cmd_ds_fwt_access *fwt_access = &cmd->params.fwt;
-	lbs_pr_debug(1, "FWT CMD(%d)\n", cmd_action);
+	lbs_deb_cmd("FWT CMD(%d)\n", cmd_action);
 
 	cmd->command = cpu_to_le16(cmd_fwt_access);
-	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_fwt_access)
-				     + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_fwt_access) + S_DS_GEN);
 	cmd->result = 0;
 
 	if (pdata_buf)
@@ -894,11 +865,10 @@ static int wlan_cmd_mesh_access(wlan_pri
 				u16 cmd_action, void *pdata_buf)
 {
 	struct cmd_ds_mesh_access *mesh_access = &cmd->params.mesh;
-	lbs_pr_debug(1, "FWT CMD(%d)\n", cmd_action);
+	lbs_deb_cmd("FWT CMD(%d)\n", cmd_action);
 
 	cmd->command = cpu_to_le16(cmd_mesh_access);
-	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_mesh_access)
-				     + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_mesh_access) + S_DS_GEN);
 	cmd->result = 0;
 
 	if (pdata_buf)
@@ -916,23 +886,23 @@ void libertas_queue_cmd(wlan_adapter * a
 	unsigned long flags;
 	struct cmd_ds_command *cmdptr;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (!cmdnode) {
-		lbs_pr_debug(1, "QUEUE_CMD: cmdnode is NULL\n");
+		lbs_deb_cmd("QUEUE_CMD: cmdnode is NULL\n");
 		goto done;
 	}
 
 	cmdptr = (struct cmd_ds_command *)cmdnode->bufvirtualaddr;
 	if (!cmdptr) {
-		lbs_pr_debug(1, "QUEUE_CMD: cmdptr is NULL\n");
+		lbs_deb_cmd("QUEUE_CMD: cmdptr is NULL\n");
 		goto done;
 	}
 
 	/* Exit_PS command needs to be queued in the header always. */
 	if (cmdptr->command == cmd_802_11_ps_mode) {
 		struct cmd_ds_802_11_ps_mode *psm = &cmdptr->params.psmode;
-		if (psm->action == cmd_subcmd_exit_ps) {
+		if (psm->action == cpu_to_le16(cmd_subcmd_exit_ps)) {
 			if (adapter->psstate != PS_STATE_FULL_POWER)
 				addtail = 0;
 		}
@@ -948,13 +918,12 @@ void libertas_queue_cmd(wlan_adapter * a
 
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
-	lbs_pr_debug(1, "QUEUE_CMD: Inserted node=%p, cmd=0x%x in cmdpendingq\n",
+	lbs_deb_cmd("QUEUE_CMD: Inserted node=%p, cmd=0x%x in cmdpendingq\n",
 	       cmdnode,
-	       ((struct cmd_ds_gen*)cmdnode->bufvirtualaddr)->command);
+	       le16_to_cpu(((struct cmd_ds_gen*)cmdnode->bufvirtualaddr)->command));
 
 done:
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_CMD);
 }
 
 /*
@@ -974,10 +943,10 @@ static int DownloadcommandToStation(wlan
 	u16 cmdsize;
 	u16 command;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (!adapter || !cmdnode) {
-		lbs_pr_debug(1, "DNLD_CMD: adapter = %p, cmdnode = %p\n",
+		lbs_deb_cmd("DNLD_CMD: adapter = %p, cmdnode = %p\n",
 		       adapter, cmdnode);
 		if (cmdnode) {
 			spin_lock_irqsave(&adapter->driver_lock, flags);
@@ -993,7 +962,7 @@ static int DownloadcommandToStation(wlan
 
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 	if (!cmdptr || !cmdptr->size) {
-		lbs_pr_debug(1, "DNLD_CMD: cmdptr is Null or cmd size is Zero, "
+		lbs_deb_cmd("DNLD_CMD: cmdptr is Null or cmd size is Zero, "
 		       "Not sending\n");
 		__libertas_cleanup_and_insert_cmd(priv, cmdnode);
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
@@ -1004,8 +973,8 @@ static int DownloadcommandToStation(wlan
 	adapter->cur_cmd = cmdnode;
 	adapter->cur_cmd_retcode = 0;
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
-	lbs_pr_debug(1, "DNLD_CMD:: Before download, size of cmd = %d\n",
-	       cmdptr->size);
+	lbs_deb_cmd("DNLD_CMD:: Before download, size of cmd = %d\n",
+		    le16_to_cpu(cmdptr->size));
 
 	cmdsize = cmdptr->size;
 
@@ -1014,10 +983,10 @@ static int DownloadcommandToStation(wlan
 	cmdnode->cmdwaitqwoken = 0;
 	cmdsize = cpu_to_le16(cmdsize);
 
-	ret = libertas_sbi_host_to_card(priv, MVMS_CMD, (u8 *) cmdptr, cmdsize);
+	ret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) cmdptr, cmdsize);
 
 	if (ret != 0) {
-		lbs_pr_debug(1, "DNLD_CMD: Host to Card failed\n");
+		lbs_deb_cmd("DNLD_CMD: Host to Card failed\n");
 		spin_lock_irqsave(&adapter->driver_lock, flags);
 		__libertas_cleanup_and_insert_cmd(priv, adapter->cur_cmd);
 		adapter->cur_cmd = NULL;
@@ -1026,12 +995,11 @@ static int DownloadcommandToStation(wlan
 		goto done;
 	}
 
-	lbs_pr_debug(1, "DNLD_CMD: Sent command 0x%x @ %lu\n", command, jiffies);
+	lbs_deb_cmd("DNLD_CMD: Sent command 0x%x @ %lu\n", command, jiffies);
 	lbs_dbg_hex("DNLD_CMD: command", cmdnode->bufvirtualaddr, cmdsize);
 
 	/* Setup the timer after transmit command */
-	if (command == cmd_802_11_scan
-	    || command == cmd_802_11_authenticate
+	if (command == cmd_802_11_scan || command == cmd_802_11_authenticate
 	    || command == cmd_802_11_associate)
 		mod_timer(&adapter->command_timer, jiffies + (10*HZ));
 	else
@@ -1039,8 +1007,8 @@ static int DownloadcommandToStation(wlan
 
 	ret = 0;
 
-      done:
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -1049,17 +1017,16 @@ static int wlan_cmd_mac_control(wlan_pri
 {
 	struct cmd_ds_mac_control *mac = &cmd->params.macctrl;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	cmd->command = cpu_to_le16(cmd_mac_control);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_mac_control) + S_DS_GEN);
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_mac_control) + S_DS_GEN);
 	mac->action = cpu_to_le16(priv->adapter->currentpacketfilter);
 
-	lbs_pr_debug(1, "wlan_cmd_mac_control(): action=0x%X size=%d\n",
-	       mac->action, cmd->size);
+	lbs_deb_cmd("wlan_cmd_mac_control(): action=0x%X size=%d\n",
+		    le16_to_cpu(mac->action), le16_to_cpu(cmd->size));
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -1093,17 +1060,17 @@ int libertas_set_radio_control(wlan_priv
 {
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_radio_control,
 				    cmd_act_set,
 				    cmd_option_waitforrsp, 0, NULL);
 
-	lbs_pr_debug(1, "RADIO_SET: on or off: 0x%X, preamble = 0x%X\n",
+	lbs_deb_cmd("RADIO_SET: on or off: 0x%X, preamble = 0x%X\n",
 	       priv->adapter->radioon, priv->adapter->preamble);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -1111,16 +1078,16 @@ int libertas_set_mac_packet_filter(wlan_
 {
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "libertas_set_mac_packet_filter value = %x\n",
+	lbs_deb_cmd("libertas_set_mac_packet_filter value = %x\n",
 	       priv->adapter->currentpacketfilter);
 
 	/* Send MAC control command to station */
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_mac_control, 0, 0, 0, NULL);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -1146,16 +1113,16 @@ int libertas_prepare_and_send_command(wl
 	struct cmd_ds_command *cmdptr;
 	unsigned long flags;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (!adapter) {
-		lbs_pr_debug(1, "PREP_CMD: adapter is Null\n");
+		lbs_deb_cmd("PREP_CMD: adapter is Null\n");
 		ret = -1;
 		goto done;
 	}
 
 	if (adapter->surpriseremoved) {
-		lbs_pr_debug(1, "PREP_CMD: Card is Removed\n");
+		lbs_deb_cmd("PREP_CMD: Card is Removed\n");
 		ret = -1;
 		goto done;
 	}
@@ -1163,7 +1130,7 @@ int libertas_prepare_and_send_command(wl
 	cmdnode = libertas_get_free_cmd_ctrl_node(priv);
 
 	if (cmdnode == NULL) {
-		lbs_pr_debug(1, "PREP_CMD: No free cmdnode\n");
+		lbs_deb_cmd("PREP_CMD: No free cmdnode\n");
 
 		/* Wake up main thread to execute next command */
 		wake_up_interruptible(&priv->mainthread.waitq);
@@ -1175,11 +1142,11 @@ int libertas_prepare_and_send_command(wl
 
 	cmdptr = (struct cmd_ds_command *)cmdnode->bufvirtualaddr;
 
-	lbs_pr_debug(1, "PREP_CMD: Val of cmd ptr=%p, command=0x%X\n",
+	lbs_deb_cmd("PREP_CMD: Val of cmd ptr=%p, command=0x%X\n",
 	       cmdptr, cmd_no);
 
 	if (!cmdptr) {
-		lbs_pr_debug(1, "PREP_CMD: bufvirtualaddr of cmdnode is NULL\n");
+		lbs_deb_cmd("PREP_CMD: bufvirtualaddr of cmdnode is NULL\n");
 		libertas_cleanup_and_insert_cmd(priv, cmdnode);
 		ret = -1;
 		goto done;
@@ -1189,7 +1156,7 @@ int libertas_prepare_and_send_command(wl
 	adapter->seqnum++;
 	cmdptr->seqnum = cpu_to_le16(adapter->seqnum);
 
-	cmdptr->command = cmd_no;
+	cmdptr->command = cpu_to_le16(cmd_no);
 	cmdptr->result = 0;
 
 	switch (cmd_no) {
@@ -1298,13 +1265,13 @@ int libertas_prepare_and_send_command(wl
 		break;
 
 	case cmd_802_11_enable_rsn:
-		ret = wlan_cmd_802_11_enable_rsn(priv, cmdptr, cmd_action);
+		ret = wlan_cmd_802_11_enable_rsn(priv, cmdptr, cmd_action,
+				pdata_buf);
 		break;
 
 	case cmd_802_11_key_material:
-		ret = wlan_cmd_802_11_key_material(priv, cmdptr,
-						   cmd_action, cmd_oid,
-						   pdata_buf);
+		ret = wlan_cmd_802_11_key_material(priv, cmdptr, cmd_action,
+				cmd_oid, pdata_buf);
 		break;
 
 	case cmd_802_11_pairwise_tsc:
@@ -1325,9 +1292,8 @@ int libertas_prepare_and_send_command(wl
 	case cmd_802_11_get_afc:
 
 		cmdptr->command = cpu_to_le16(cmd_no);
-		cmdptr->size =
-		    cpu_to_le16(sizeof(struct cmd_ds_802_11_afc) +
-				     S_DS_GEN);
+		cmdptr->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_afc) +
+					   S_DS_GEN);
 
 		memmove(&cmdptr->params.afc,
 			pdata_buf, sizeof(struct cmd_ds_802_11_afc));
@@ -1406,29 +1372,26 @@ int libertas_prepare_and_send_command(wl
 
 	case cmd_get_tsf:
 		cmdptr->command = cpu_to_le16(cmd_get_tsf);
-		cmdptr->size =
-		    cpu_to_le16(sizeof(struct cmd_ds_get_tsf)
-				     + S_DS_GEN);
+		cmdptr->size = cpu_to_le16(sizeof(struct cmd_ds_get_tsf) +
+					   S_DS_GEN);
 		ret = 0;
 		break;
 	case cmd_802_11_tx_rate_query:
-		cmdptr->command =
-		    cpu_to_le16(cmd_802_11_tx_rate_query);
-		cmdptr->size =
-		    cpu_to_le16(sizeof(struct cmd_tx_rate_query) +
-				     S_DS_GEN);
+		cmdptr->command = cpu_to_le16(cmd_802_11_tx_rate_query);
+		cmdptr->size = cpu_to_le16(sizeof(struct cmd_tx_rate_query) +
+					   S_DS_GEN);
 		adapter->txrate = 0;
 		ret = 0;
 		break;
 	default:
-		lbs_pr_debug(1, "PREP_CMD: unknown command- %#x\n", cmd_no);
+		lbs_deb_cmd("PREP_CMD: unknown command- %#x\n", cmd_no);
 		ret = -1;
 		break;
 	}
 
 	/* return error, since the command preparation failed */
 	if (ret != 0) {
-		lbs_pr_debug(1, "PREP_CMD: command preparation failed\n");
+		lbs_deb_cmd("PREP_CMD: command preparation failed\n");
 		libertas_cleanup_and_insert_cmd(priv, cmdnode);
 		ret = -1;
 		goto done;
@@ -1441,7 +1404,7 @@ int libertas_prepare_and_send_command(wl
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	if (wait_option & cmd_option_waitforrsp) {
-		lbs_pr_debug(1, "PREP_CMD: Wait for CMD response\n");
+		lbs_deb_cmd("PREP_CMD: Wait for CMD response\n");
 		might_sleep();
 		wait_event_interruptible(cmdnode->cmdwait_q,
 					 cmdnode->cmdwaitqwoken);
@@ -1449,7 +1412,7 @@ int libertas_prepare_and_send_command(wl
 
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 	if (adapter->cur_cmd_retcode) {
-		lbs_pr_debug(1, "PREP_CMD: command failed with return code=%d\n",
+		lbs_deb_cmd("PREP_CMD: command failed with return code=%d\n",
 		       adapter->cur_cmd_retcode);
 		adapter->cur_cmd_retcode = 0;
 		ret = -1;
@@ -1457,9 +1420,10 @@ int libertas_prepare_and_send_command(wl
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(libertas_prepare_and_send_command);
 
 /**
  *  @brief This function allocates the command buffer and link
@@ -1477,33 +1441,29 @@ int libertas_allocate_cmd_buffer(wlan_pr
 	u8 *ptempvirtualaddr;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	/* Allocate and initialize cmdCtrlNode */
 	ulbufsize = sizeof(struct cmd_ctrl_node) * MRVDRV_NUM_OF_CMD_BUFFER;
 
-	if (!(tempcmd_array = kmalloc(ulbufsize, GFP_KERNEL))) {
-		lbs_pr_debug(1,
+	if (!(tempcmd_array = kzalloc(ulbufsize, GFP_KERNEL))) {
+		lbs_deb_cmd(
 		       "ALLOC_CMD_BUF: failed to allocate tempcmd_array\n");
 		ret = -1;
 		goto done;
 	}
-
 	adapter->cmd_array = tempcmd_array;
-	memset(adapter->cmd_array, 0, ulbufsize);
 
 	/* Allocate and initialize command buffers */
 	ulbufsize = MRVDRV_SIZE_OF_CMD_BUFFER;
 	for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
-		if (!(ptempvirtualaddr = kmalloc(ulbufsize, GFP_KERNEL))) {
-			lbs_pr_debug(1,
+		if (!(ptempvirtualaddr = kzalloc(ulbufsize, GFP_KERNEL))) {
+			lbs_deb_cmd(
 			       "ALLOC_CMD_BUF: ptempvirtualaddr: out of memory\n");
 			ret = -1;
 			goto done;
 		}
 
-		memset(ptempvirtualaddr, 0, ulbufsize);
-
 		/* Update command buffer virtual */
 		tempcmd_array[i].bufvirtualaddr = ptempvirtualaddr;
 	}
@@ -1514,8 +1474,9 @@ int libertas_allocate_cmd_buffer(wlan_pr
 	}
 
 	ret = 0;
-      done:
-	LEAVE();
+
+done:
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -1527,16 +1488,16 @@ int libertas_allocate_cmd_buffer(wlan_pr
  */
 int libertas_free_cmd_buffer(wlan_private * priv)
 {
-	u32 ulbufsize;
+	u32 ulbufsize; /* Someone needs to die for this. Slowly and painfully */
 	unsigned int i;
 	struct cmd_ctrl_node *tempcmd_array;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	/* need to check if cmd array is allocated or not */
 	if (adapter->cmd_array == NULL) {
-		lbs_pr_debug(1, "FREE_CMD_BUF: cmd_array is Null\n");
+		lbs_deb_cmd("FREE_CMD_BUF: cmd_array is Null\n");
 		goto done;
 	}
 
@@ -1546,7 +1507,7 @@ int libertas_free_cmd_buffer(wlan_privat
 	ulbufsize = MRVDRV_SIZE_OF_CMD_BUFFER;
 	for (i = 0; i < MRVDRV_NUM_OF_CMD_BUFFER; i++) {
 		if (tempcmd_array[i].bufvirtualaddr) {
-			lbs_pr_debug(1, "Free all the array\n");
+			lbs_deb_cmd("Free all the array\n");
 			kfree(tempcmd_array[i].bufvirtualaddr);
 			tempcmd_array[i].bufvirtualaddr = NULL;
 		}
@@ -1554,13 +1515,13 @@ int libertas_free_cmd_buffer(wlan_privat
 
 	/* Release cmd_ctrl_node */
 	if (adapter->cmd_array) {
-		lbs_pr_debug(1, "Free cmd_array\n");
+		lbs_deb_cmd("Free cmd_array\n");
 		kfree(adapter->cmd_array);
 		adapter->cmd_array = NULL;
 	}
 
 done:
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -1586,16 +1547,18 @@ struct cmd_ctrl_node *libertas_get_free_
 		tempnode = (struct cmd_ctrl_node *)adapter->cmdfreeq.next;
 		list_del((struct list_head *)tempnode);
 	} else {
-		lbs_pr_debug(1, "GET_CMD_NODE: cmd_ctrl_node is not available\n");
+		lbs_deb_cmd("GET_CMD_NODE: cmd_ctrl_node is not available\n");
 		tempnode = NULL;
 	}
 
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
 	if (tempnode) {
+		/*
 		lbs_pr_debug(3, "GET_CMD_NODE: cmdCtrlNode available\n");
 		lbs_pr_debug(3, "GET_CMD_NODE: cmdCtrlNode Address = %p\n",
 		       tempnode);
+		*/
 		cleanup_cmdnode(tempnode);
 	}
 
@@ -1638,7 +1601,7 @@ void libertas_set_cmd_ctrl_node(wlan_pri
 		    struct cmd_ctrl_node *ptempnode,
 		    u32 cmd_oid, u16 wait_option, void *pdata_buf)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (!ptempnode)
 		return;
@@ -1647,7 +1610,7 @@ void libertas_set_cmd_ctrl_node(wlan_pri
 	ptempnode->wait_option = wait_option;
 	ptempnode->pdata_buf = pdata_buf;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 }
 
 /**
@@ -1666,7 +1629,7 @@ int libertas_execute_next_command(wlan_p
 	unsigned long flags;
 	int ret = 0;
 
-	lbs_pr_debug(1, "libertas_execute_next_command\n");
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 
@@ -1685,23 +1648,24 @@ int libertas_execute_next_command(wlan_p
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
 	if (cmdnode) {
-		lbs_pr_debug(1,
+		lbs_deb_cmd(
 		       "EXEC_NEXT_CMD: Got next command from cmdpendingq\n");
 		cmdptr = (struct cmd_ds_command *)cmdnode->bufvirtualaddr;
 
 		if (is_command_allowed_in_ps(cmdptr->command)) {
-			if ((adapter->psstate == PS_STATE_SLEEP)
-			    || (adapter->psstate == PS_STATE_PRE_SLEEP)
-			    ) {
-				lbs_pr_debug(1,
+			if ((adapter->psstate == PS_STATE_SLEEP) ||
+			    (adapter->psstate == PS_STATE_PRE_SLEEP)) {
+				lbs_deb_cmd(
 				       "EXEC_NEXT_CMD: Cannot send cmd 0x%x in psstate %d\n",
-				       cmdptr->command, adapter->psstate);
+				       le16_to_cpu(cmdptr->command),
+				       adapter->psstate);
 				ret = -1;
 				goto done;
 			}
-			lbs_pr_debug(1, "EXEC_NEXT_CMD: OK to send command "
+			lbs_deb_cmd("EXEC_NEXT_CMD: OK to send command "
 			       "0x%x in psstate %d\n",
-			       cmdptr->command, adapter->psstate);
+				    le16_to_cpu(cmdptr->command),
+				    adapter->psstate);
 		} else if (adapter->psstate != PS_STATE_FULL_POWER) {
 			/*
 			 * 1. Non-PS command:
@@ -1737,12 +1701,12 @@ int libertas_execute_next_command(wlan_p
 				struct cmd_ds_802_11_ps_mode *psm =
 				    &cmdptr->params.psmode;
 
-				lbs_pr_debug(1,
+				lbs_deb_cmd(
 				       "EXEC_NEXT_CMD: PS cmd- action=0x%x\n",
 				       psm->action);
 				if (psm->action !=
 				    cpu_to_le16(cmd_subcmd_exit_ps)) {
-					lbs_pr_debug(1,
+					lbs_deb_cmd(
 					       "EXEC_NEXT_CMD: Ignore Enter PS cmd\n");
 					list_del((struct list_head *)cmdnode);
 					libertas_cleanup_and_insert_cmd(priv, cmdnode);
@@ -1751,10 +1715,9 @@ int libertas_execute_next_command(wlan_p
 					goto done;
 				}
 
-				if ((adapter->psstate == PS_STATE_SLEEP)
-				    || (adapter->psstate == PS_STATE_PRE_SLEEP)
-				    ) {
-					lbs_pr_debug(1,
+				if ((adapter->psstate == PS_STATE_SLEEP) ||
+				    (adapter->psstate == PS_STATE_PRE_SLEEP)) {
+					lbs_deb_cmd(
 					       "EXEC_NEXT_CMD: Ignore ExitPS cmd in sleep\n");
 					list_del((struct list_head *)cmdnode);
 					libertas_cleanup_and_insert_cmd(priv, cmdnode);
@@ -1764,13 +1727,13 @@ int libertas_execute_next_command(wlan_p
 					goto done;
 				}
 
-				lbs_pr_debug(1,
+				lbs_deb_cmd(
 				       "EXEC_NEXT_CMD: Sending Exit_PS down...\n");
 			}
 		}
 		list_del((struct list_head *)cmdnode);
-		lbs_pr_debug(1, "EXEC_NEXT_CMD: Sending 0x%04X command\n",
-		       cmdptr->command);
+		lbs_deb_cmd("EXEC_NEXT_CMD: Sending 0x%04X command\n",
+			    le16_to_cpu(cmdptr->command));
 		DownloadcommandToStation(priv, cmdnode);
 	} else {
 		/*
@@ -1780,18 +1743,18 @@ int libertas_execute_next_command(wlan_p
 		if ((adapter->psmode != wlan802_11powermodecam) &&
 		    (adapter->psstate == PS_STATE_FULL_POWER) &&
 		    (adapter->connect_status == libertas_connected)) {
-			if (adapter->secinfo.WPAenabled
-			    || adapter->secinfo.WPA2enabled) {
+			if (adapter->secinfo.WPAenabled ||
+			    adapter->secinfo.WPA2enabled) {
 				/* check for valid WPA group keys */
-				if (adapter->wpa_mcast_key.len
-				    || adapter->wpa_unicast_key.len) {
-					lbs_pr_debug(1,
+				if (adapter->wpa_mcast_key.len ||
+				    adapter->wpa_unicast_key.len) {
+					lbs_deb_cmd(
 					       "EXEC_NEXT_CMD: WPA enabled and GTK_SET"
 					       " go back to PS_SLEEP");
 					libertas_ps_sleep(priv, 0);
 				}
 			} else {
-				lbs_pr_debug(1,
+				lbs_deb_cmd(
 				       "EXEC_NEXT_CMD: command PendQ is empty,"
 				       " go back to PS_SLEEP");
 				libertas_ps_sleep(priv, 0);
@@ -1801,6 +1764,7 @@ int libertas_execute_next_command(wlan_p
 
 	ret = 0;
 done:
+	lbs_deb_leave(LBS_DEB_CMD);
 	return ret;
 }
 
@@ -1809,7 +1773,7 @@ void libertas_send_iwevcustom_event(wlan
 	union iwreq_data iwrq;
 	u8 buf[50];
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	memset(&iwrq, 0, sizeof(union iwreq_data));
 	memset(buf, 0, sizeof(buf));
@@ -1819,15 +1783,13 @@ void libertas_send_iwevcustom_event(wlan
 	iwrq.data.length = strlen(buf) + 1 + IW_EV_LCP_LEN;
 
 	/* Send Event to upper layer */
-	lbs_pr_debug(1, "Event Indication string = %s\n",
-	       (char *)buf);
-	lbs_pr_debug(1, "Event Indication String length = %d\n", iwrq.data.length);
+	lbs_deb_cmd("Event Indication string = %s\n", (char *)buf);
+	lbs_deb_cmd("Event Indication String length = %d\n", iwrq.data.length);
 
-	lbs_pr_debug(1, "Sending wireless event IWEVCUSTOM for %s\n", str);
-	wireless_send_event(priv->wlan_dev.netdev, IWEVCUSTOM, &iwrq, buf);
+	lbs_deb_cmd("Sending wireless event IWEVCUSTOM for %s\n", str);
+	wireless_send_event(priv->dev, IWEVCUSTOM, &iwrq, buf);
 
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_CMD);
 }
 
 static int sendconfirmsleep(wlan_private * priv, u8 * cmdptr, u16 size)
@@ -1836,19 +1798,19 @@ static int sendconfirmsleep(wlan_private
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "SEND_SLEEPC_CMD: Before download, size of cmd = %d\n",
+	lbs_deb_cmd("SEND_SLEEPC_CMD: Before download, size of cmd = %d\n",
 	       size);
 
 	lbs_dbg_hex("SEND_SLEEPC_CMD: Sleep confirm command", cmdptr, size);
 
-	ret = libertas_sbi_host_to_card(priv, MVMS_CMD, cmdptr, size);
-	priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+	ret = priv->hw_host_to_card(priv, MVMS_CMD, cmdptr, size);
+	priv->dnld_sent = DNLD_RES_RECEIVED;
 
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 	if (adapter->intcounter || adapter->currenttxskb)
-		lbs_pr_debug(1, "SEND_SLEEPC_CMD: intcounter=%d currenttxskb=%p\n",
+		lbs_deb_cmd("SEND_SLEEPC_CMD: intcounter=%d currenttxskb=%p\n",
 		       adapter->intcounter, adapter->currenttxskb);
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
@@ -1860,23 +1822,22 @@ static int sendconfirmsleep(wlan_private
 		if (!adapter->intcounter) {
 			adapter->psstate = PS_STATE_SLEEP;
 		} else {
-			lbs_pr_debug(1, "SEND_SLEEPC_CMD: After sent,IntC=%d\n",
+			lbs_deb_cmd("SEND_SLEEPC_CMD: After sent,IntC=%d\n",
 			       adapter->intcounter);
 		}
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
-		lbs_pr_debug(1, "SEND_SLEEPC_CMD: Sent Confirm Sleep command\n");
-		lbs_pr_debug(1, "+");
+		lbs_deb_cmd("SEND_SLEEPC_CMD: Sent Confirm Sleep command\n");
+		lbs_deb_cmd("+");
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
 void libertas_ps_sleep(wlan_private * priv, int wait_option)
 {
-
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	/*
 	 * PS is currently supported only in Infrastructure mode
@@ -1886,8 +1847,7 @@ void libertas_ps_sleep(wlan_private * pr
 	libertas_prepare_and_send_command(priv, cmd_802_11_ps_mode,
 			      cmd_subcmd_enter_ps, wait_option, 0, NULL);
 
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_CMD);
 }
 
 /**
@@ -1899,20 +1859,19 @@ void libertas_ps_sleep(wlan_private * pr
  */
 void libertas_ps_wakeup(wlan_private * priv, int wait_option)
 {
-	enum WLAN_802_11_POWER_MODE Localpsmode;
+	__le32 Localpsmode;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	Localpsmode = wlan802_11powermodecam;
+	Localpsmode = cpu_to_le32(wlan802_11powermodecam);
 
-	lbs_pr_debug(1, "Exit_PS: Localpsmode = %d\n", Localpsmode);
+	lbs_deb_cmd("Exit_PS: Localpsmode = %d\n", wlan802_11powermodecam);
 
 	libertas_prepare_and_send_command(priv, cmd_802_11_ps_mode,
 			      cmd_subcmd_exit_ps,
 			      wait_option, 0, &Localpsmode);
 
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_CMD);
 }
 
 /**
@@ -1929,31 +1888,31 @@ void libertas_ps_confirm_sleep(wlan_priv
 	wlan_adapter *adapter = priv->adapter;
 	u8 allowed = 1;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	if (priv->wlan_dev.dnld_sent) {
+	if (priv->dnld_sent) {
 		allowed = 0;
-		lbs_pr_debug(1, "D");
+		lbs_deb_cmd("D");
 	}
 
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 	if (adapter->cur_cmd) {
 		allowed = 0;
-		lbs_pr_debug(1, "C");
+		lbs_deb_cmd("C");
 	}
 	if (adapter->intcounter > 0) {
 		allowed = 0;
-		lbs_pr_debug(1, "I%d", adapter->intcounter);
+		lbs_deb_cmd("I%d", adapter->intcounter);
 	}
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
 	if (allowed) {
-		lbs_pr_debug(1, "Sending libertas_ps_confirm_sleep\n");
+		lbs_deb_cmd("Sending libertas_ps_confirm_sleep\n");
 		sendconfirmsleep(priv, (u8 *) & adapter->libertas_ps_confirm_sleep,
 				 sizeof(struct PS_CMD_ConfirmSleep));
 	} else {
-		lbs_pr_debug(1, "Sleep Confirm has been delayed\n");
+		lbs_deb_cmd("Sleep Confirm has been delayed\n");
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_CMD);
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/cmdresp.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/cmdresp.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/cmdresp.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/cmdresp.c	2007-06-14 14:14:33.000000000 -0400
@@ -9,7 +9,6 @@
 #include <net/iw_handler.h>
 
 #include "host.h"
-#include "sbi.h"
 #include "decl.h"
 #include "defs.h"
 #include "dev.h"
@@ -32,7 +31,7 @@ void libertas_mac_event_disconnected(wla
 	if (adapter->connect_status != libertas_connected)
 		return;
 
-	lbs_pr_debug(1, "Handles disconnect event.\n");
+	lbs_deb_cmd("Handles disconnect event.\n");
 
 	memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -43,15 +42,15 @@ void libertas_mac_event_disconnected(wla
 	 */
 
 	msleep_interruptible(1000);
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
 
 	/* Free Tx and Rx packets */
 	kfree_skb(priv->adapter->currenttxskb);
 	priv->adapter->currenttxskb = NULL;
 
 	/* report disconnect to upper layer */
-	netif_stop_queue(priv->wlan_dev.netdev);
-	netif_carrier_off(priv->wlan_dev.netdev);
+	netif_stop_queue(priv->dev);
+	netif_carrier_off(priv->dev);
 
 	/* reset SNR/NF/RSSI values */
 	memset(adapter->SNR, 0x00, sizeof(adapter->SNR));
@@ -62,35 +61,32 @@ void libertas_mac_event_disconnected(wla
 	adapter->nextSNRNF = 0;
 	adapter->numSNRNF = 0;
 	adapter->rxpd_rate = 0;
-	lbs_pr_debug(1, "Current SSID=%s, ssid length=%u\n",
-	       adapter->curbssparams.ssid.ssid,
-	       adapter->curbssparams.ssid.ssidlength);
-	lbs_pr_debug(1, "Previous SSID=%s, ssid length=%u\n",
-	       adapter->previousssid.ssid, adapter->previousssid.ssidlength);
-
-	/* reset internal flags */
-	adapter->secinfo.WPAenabled = 0;
-	adapter->secinfo.WPA2enabled = 0;
-	adapter->wpa_ie_len = 0;
+	lbs_deb_cmd("Current SSID='%s', ssid length=%u\n",
+	            escape_essid(adapter->curbssparams.ssid,
+	                         adapter->curbssparams.ssid_len),
+	            adapter->curbssparams.ssid_len);
+	lbs_deb_cmd("Previous SSID='%s', ssid length=%u\n",
+	            escape_essid(adapter->prev_ssid, adapter->prev_ssid_len),
+	            adapter->prev_ssid_len);
 
 	adapter->connect_status = libertas_disconnected;
 
-	/*
-	 * memorize the previous SSID and BSSID
-	 * it could be used for re-assoc
+	/* Save previous SSID and BSSID for possible reassociation */
+	memcpy(&adapter->prev_ssid, &adapter->curbssparams.ssid,
+	       IW_ESSID_MAX_SIZE);
+	adapter->prev_ssid_len = adapter->curbssparams.ssid_len;
+	memcpy(adapter->prev_bssid, adapter->curbssparams.bssid, ETH_ALEN);
+
+	/* Clear out associated SSID and BSSID since connection is
+	 * no longer valid.
 	 */
-	memcpy(&adapter->previousssid,
-	       &adapter->curbssparams.ssid, sizeof(struct WLAN_802_11_SSID));
-	memcpy(adapter->previousbssid,
-	       adapter->curbssparams.bssid, ETH_ALEN);
-
-	/* need to erase the current SSID and BSSID info */
-	adapter->pattemptedbssdesc = NULL;
-	memset(&adapter->curbssparams, 0, sizeof(adapter->curbssparams));
+	memset(&adapter->curbssparams.bssid, 0, ETH_ALEN);
+	memset(&adapter->curbssparams.ssid, 0, IW_ESSID_MAX_SIZE);
+	adapter->curbssparams.ssid_len = 0;
 
 	if (adapter->psstate != PS_STATE_FULL_POWER) {
 		/* make firmware to exit PS mode */
-		lbs_pr_debug(1, "Disconnected, so exit PS mode.\n");
+		lbs_deb_cmd("Disconnected, so exit PS mode.\n");
 		libertas_ps_wakeup(priv, 0);
 	}
 }
@@ -122,55 +118,45 @@ static void handle_mic_failureevent(wlan
 static int wlan_ret_reg_access(wlan_private * priv,
 			       u16 type, struct cmd_ds_command *resp)
 {
+	int ret = 0;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	switch (type) {
 	case cmd_ret_mac_reg_access:
 		{
-			struct cmd_ds_mac_reg_access *reg;
-
-			reg =
-			    (struct cmd_ds_mac_reg_access *)&resp->params.
-			    macreg;
+			struct cmd_ds_mac_reg_access *reg = &resp->params.macreg;
 
-			adapter->offsetvalue.offset = reg->offset;
-			adapter->offsetvalue.value = reg->value;
+			adapter->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
+			adapter->offsetvalue.value = le32_to_cpu(reg->value);
 			break;
 		}
 
 	case cmd_ret_bbp_reg_access:
 		{
-			struct cmd_ds_bbp_reg_access *reg;
-			reg =
-			    (struct cmd_ds_bbp_reg_access *)&resp->params.
-			    bbpreg;
+			struct cmd_ds_bbp_reg_access *reg = &resp->params.bbpreg;
 
-			adapter->offsetvalue.offset = reg->offset;
+			adapter->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
 			adapter->offsetvalue.value = reg->value;
 			break;
 		}
 
 	case cmd_ret_rf_reg_access:
 		{
-			struct cmd_ds_rf_reg_access *reg;
-			reg =
-			    (struct cmd_ds_rf_reg_access *)&resp->params.
-			    rfreg;
+			struct cmd_ds_rf_reg_access *reg = &resp->params.rfreg;
 
-			adapter->offsetvalue.offset = reg->offset;
+			adapter->offsetvalue.offset = (u32)le16_to_cpu(reg->offset);
 			adapter->offsetvalue.value = reg->value;
 			break;
 		}
 
 	default:
-		LEAVE();
-		return -1;
+		ret = -1;
 	}
 
-	LEAVE();
-	return 0;
+	lbs_deb_enter_args(LBS_DEB_CMD, "ret %d", ret);
+	return ret;
 }
 
 static int wlan_ret_get_hw_spec(wlan_private * priv,
@@ -181,19 +167,20 @@ static int wlan_ret_get_hw_spec(wlan_pri
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	adapter->fwcapinfo = le32_to_cpu(hwspec->fwcapinfo);
 
-	adapter->fwreleasenumber = hwspec->fwreleasenumber;
+	memcpy(adapter->fwreleasenumber, hwspec->fwreleasenumber, 4);
 
-	lbs_pr_debug(1, "GET_HW_SPEC: FWReleaseVersion- 0x%X\n",
-	       adapter->fwreleasenumber);
-	lbs_pr_debug(1, "GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
+	lbs_deb_cmd("GET_HW_SPEC: FWReleaseVersion- %u.%u.%u.p%u\n",
+		    adapter->fwreleasenumber[2], adapter->fwreleasenumber[1],
+		    adapter->fwreleasenumber[0], adapter->fwreleasenumber[3]);
+	lbs_deb_cmd("GET_HW_SPEC: Permanent addr- %2x:%2x:%2x:%2x:%2x:%2x\n",
 	       hwspec->permanentaddr[0], hwspec->permanentaddr[1],
 	       hwspec->permanentaddr[2], hwspec->permanentaddr[3],
 	       hwspec->permanentaddr[4], hwspec->permanentaddr[5]);
-	lbs_pr_debug(1, "GET_HW_SPEC: hwifversion=0x%X  version=0x%X\n",
+	lbs_deb_cmd("GET_HW_SPEC: hwifversion=0x%X  version=0x%X\n",
 	       hwspec->hwifversion, hwspec->version);
 
 	adapter->regioncode = le16_to_cpu(hwspec->regioncode);
@@ -210,17 +197,15 @@ static int wlan_ret_get_hw_spec(wlan_pri
 	if (i >= MRVDRV_MAX_REGION_CODE) {
 		adapter->regioncode = 0x10;
 		adapter->regiontableindex = 0;
-		lbs_pr_info(
-		       "unidentified region code, use the default (USA)\n");
+		lbs_pr_info("unidentified region code; using the default (USA)\n");
 	}
 
-	if (adapter->current_addr[0] == 0xff) {
-		memmove(adapter->current_addr, hwspec->permanentaddr,
-			ETH_ALEN);
-	}
+	if (adapter->current_addr[0] == 0xff)
+		memmove(adapter->current_addr, hwspec->permanentaddr, ETH_ALEN);
 
-	memcpy(priv->wlan_dev.netdev->dev_addr, adapter->current_addr, ETH_ALEN);
-	memcpy(priv->mesh_dev->dev_addr, adapter->current_addr, ETH_ALEN);
+	memcpy(priv->dev->dev_addr, adapter->current_addr, ETH_ALEN);
+	if (priv->mesh_dev)
+		memcpy(priv->mesh_dev->dev_addr, adapter->current_addr, ETH_ALEN);
 
 	if (libertas_set_regiontable(priv, adapter->regioncode, 0)) {
 		ret = -1;
@@ -232,8 +217,8 @@ static int wlan_ret_get_hw_spec(wlan_pri
 		goto done;
 	}
 
-      done:
-	LEAVE();
+done:
+	lbs_deb_enter_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -243,19 +228,21 @@ static int wlan_ret_802_11_sleep_params(
 	struct cmd_ds_802_11_sleep_params *sp = &resp->params.sleep_params;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
+
+	lbs_deb_cmd("error=%x offset=%x stabletime=%x calcontrol=%x\n"
+		    " extsleepclk=%x\n", le16_to_cpu(sp->error),
+		    le16_to_cpu(sp->offset), le16_to_cpu(sp->stabletime),
+		    sp->calcontrol, sp->externalsleepclk);
 
-	lbs_pr_debug(1, "error=%x offset=%x stabletime=%x calcontrol=%x\n"
-	       " extsleepclk=%x\n", sp->error, sp->offset,
-	       sp->stabletime, sp->calcontrol, sp->externalsleepclk);
 	adapter->sp.sp_error = le16_to_cpu(sp->error);
 	adapter->sp.sp_offset = le16_to_cpu(sp->offset);
 	adapter->sp.sp_stabletime = le16_to_cpu(sp->stabletime);
-	adapter->sp.sp_calcontrol = le16_to_cpu(sp->calcontrol);
-	adapter->sp.sp_extsleepclk = le16_to_cpu(sp->externalsleepclk);
+	adapter->sp.sp_calcontrol = sp->calcontrol;
+	adapter->sp.sp_extsleepclk = sp->externalsleepclk;
 	adapter->sp.sp_reserved = le16_to_cpu(sp->reserved);
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -281,42 +268,38 @@ static int wlan_ret_802_11_snmp_mib(wlan
 	u16 oid = le16_to_cpu(smib->oid);
 	u16 querytype = le16_to_cpu(smib->querytype);
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "SNMP_RESP: value of the oid = %x, querytype=%x\n", oid,
+	lbs_deb_cmd("SNMP_RESP: value of the oid = %x, querytype=%x\n", oid,
 	       querytype);
-	lbs_pr_debug(1, "SNMP_RESP: Buf size  = %x\n",
-	       le16_to_cpu(smib->bufsize));
+	lbs_deb_cmd("SNMP_RESP: Buf size  = %x\n", le16_to_cpu(smib->bufsize));
 
 	if (querytype == cmd_act_get) {
 		switch (oid) {
 		case fragthresh_i:
 			priv->adapter->fragthsd =
-			    le16_to_cpu(*
-					     ((unsigned short *)(smib->value)));
-			lbs_pr_debug(1, "SNMP_RESP: fragthsd =%u\n",
-			       priv->adapter->fragthsd);
+				le16_to_cpu(*((__le16 *)(smib->value)));
+			lbs_deb_cmd("SNMP_RESP: fragthsd =%u\n",
+				    priv->adapter->fragthsd);
 			break;
 		case rtsthresh_i:
 			priv->adapter->rtsthsd =
-			    le16_to_cpu(*
-					     ((unsigned short *)(smib->value)));
-			lbs_pr_debug(1, "SNMP_RESP: rtsthsd =%u\n",
-			       priv->adapter->rtsthsd);
+				le16_to_cpu(*((__le16 *)(smib->value)));
+			lbs_deb_cmd("SNMP_RESP: rtsthsd =%u\n",
+				    priv->adapter->rtsthsd);
 			break;
 		case short_retrylim_i:
 			priv->adapter->txretrycount =
-			    le16_to_cpu(*
-					     ((unsigned short *)(smib->value)));
-			lbs_pr_debug(1, "SNMP_RESP: txretrycount =%u\n",
-			       priv->adapter->rtsthsd);
+				le16_to_cpu(*((__le16 *)(smib->value)));
+			lbs_deb_cmd("SNMP_RESP: txretrycount =%u\n",
+				    priv->adapter->rtsthsd);
 			break;
 		default:
 			break;
 		}
 	}
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -328,7 +311,7 @@ static int wlan_ret_802_11_key_material(
 	wlan_adapter *adapter = priv->adapter;
 	u16 action = le16_to_cpu(pkeymaterial->action);
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	/* Copy the returned key to driver private data */
 	if (action == cmd_act_get) {
@@ -371,7 +354,7 @@ static int wlan_ret_802_11_key_material(
 		}
 	}
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -381,11 +364,11 @@ static int wlan_ret_802_11_mac_address(w
 	struct cmd_ds_802_11_mac_address *macadd = &resp->params.macadd;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	memcpy(adapter->current_addr, macadd->macadd, ETH_ALEN);
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -395,13 +378,13 @@ static int wlan_ret_802_11_rf_tx_power(w
 	struct cmd_ds_802_11_rf_tx_power *rtp = &resp->params.txp;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	adapter->txpowerlevel = le16_to_cpu(rtp->currentlevel);
 
-	lbs_pr_debug(1, "Current TxPower Level = %d\n", adapter->txpowerlevel);
+	lbs_deb_cmd("Current TxPower Level = %d\n", adapter->txpowerlevel);
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -413,14 +396,12 @@ static int wlan_ret_802_11_rf_antenna(wl
 	u16 action = le16_to_cpu(pAntenna->action);
 
 	if (action == cmd_act_get_rx)
-		adapter->rxantennamode =
-		    le16_to_cpu(pAntenna->antennamode);
+		adapter->rxantennamode = le16_to_cpu(pAntenna->antennamode);
 
 	if (action == cmd_act_get_tx)
-		adapter->txantennamode =
-		    le16_to_cpu(pAntenna->antennamode);
+		adapter->txantennamode = le16_to_cpu(pAntenna->antennamode);
 
-	lbs_pr_debug(1, "RF_ANT_RESP: action = 0x%x, mode = 0x%04x\n",
+	lbs_deb_cmd("RF_ANT_RESP: action = 0x%x, mode = 0x%04x\n",
 	       action, le16_to_cpu(pAntenna->antennamode));
 
 	return 0;
@@ -429,19 +410,17 @@ static int wlan_ret_802_11_rf_antenna(wl
 static int wlan_ret_802_11_rate_adapt_rateset(wlan_private * priv,
 					      struct cmd_ds_command *resp)
 {
-	struct cmd_ds_802_11_rate_adapt_rateset *rates =
-	    &resp->params.rateset;
+	struct cmd_ds_802_11_rate_adapt_rateset *rates = &resp->params.rateset;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (rates->action == cmd_act_get) {
-		adapter->enablehwauto = rates->enablehwauto;
-		adapter->ratebitmap = rates->bitmap;
+		adapter->enablehwauto = le16_to_cpu(rates->enablehwauto);
+		adapter->ratebitmap = le16_to_cpu(rates->bitmap);
 	}
 
-	LEAVE();
-
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -452,43 +431,42 @@ static int wlan_ret_802_11_data_rate(wla
 	wlan_adapter *adapter = priv->adapter;
 	u8 dot11datarate;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	lbs_dbg_hex("DATA_RATE_RESP: data_rate- ",
 		(u8 *) pdatarate, sizeof(struct cmd_ds_802_11_data_rate));
 
 	dot11datarate = pdatarate->datarate[0];
-	if (pdatarate->action == cmd_act_get_tx_rate) {
+	if (pdatarate->action == cpu_to_le16(cmd_act_get_tx_rate)) {
 		memcpy(adapter->libertas_supported_rates, pdatarate->datarate,
 		       sizeof(adapter->libertas_supported_rates));
 	}
 	adapter->datarate = libertas_index_to_data_rate(dot11datarate);
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
 static int wlan_ret_802_11_rf_channel(wlan_private * priv,
 				      struct cmd_ds_command *resp)
 {
-	struct cmd_ds_802_11_rf_channel *rfchannel =
-	    &resp->params.rfchannel;
+	struct cmd_ds_802_11_rf_channel *rfchannel = &resp->params.rfchannel;
 	wlan_adapter *adapter = priv->adapter;
 	u16 action = le16_to_cpu(rfchannel->action);
 	u16 newchannel = le16_to_cpu(rfchannel->currentchannel);
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
 	if (action == cmd_opt_802_11_rf_channel_get
 	    && adapter->curbssparams.channel != newchannel) {
-		lbs_pr_debug(1, "channel Switch: %d to %d\n",
+		lbs_deb_cmd("channel Switch: %d to %d\n",
 		       adapter->curbssparams.channel, newchannel);
 
 		/* Update the channel again */
 		adapter->curbssparams.channel = newchannel;
 	}
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -500,12 +478,10 @@ static int wlan_ret_802_11_rssi(wlan_pri
 
 	/* store the non average value */
 	adapter->SNR[TYPE_BEACON][TYPE_NOAVG] = le16_to_cpu(rssirsp->SNR);
-	adapter->NF[TYPE_BEACON][TYPE_NOAVG] =
-	    le16_to_cpu(rssirsp->noisefloor);
+	adapter->NF[TYPE_BEACON][TYPE_NOAVG] = le16_to_cpu(rssirsp->noisefloor);
 
 	adapter->SNR[TYPE_BEACON][TYPE_AVG] = le16_to_cpu(rssirsp->avgSNR);
-	adapter->NF[TYPE_BEACON][TYPE_AVG] =
-	    le16_to_cpu(rssirsp->avgnoisefloor);
+	adapter->NF[TYPE_BEACON][TYPE_AVG] = le16_to_cpu(rssirsp->avgnoisefloor);
 
 	adapter->RSSI[TYPE_BEACON][TYPE_NOAVG] =
 	    CAL_RSSI(adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
@@ -515,7 +491,7 @@ static int wlan_ret_802_11_rssi(wlan_pri
 	    CAL_RSSI(adapter->SNR[TYPE_BEACON][TYPE_AVG] / AVG_SCALE,
 		     adapter->NF[TYPE_BEACON][TYPE_AVG] / AVG_SCALE);
 
-	lbs_pr_debug(1, "Beacon RSSI value = 0x%x\n",
+	lbs_deb_cmd("Beacon RSSI value = 0x%x\n",
 	       adapter->RSSI[TYPE_BEACON][TYPE_AVG]);
 
 	return 0;
@@ -528,11 +504,11 @@ static int wlan_ret_802_11_eeprom_access
 	struct wlan_ioctl_regrdwr *pbuf;
 	pbuf = (struct wlan_ioctl_regrdwr *) adapter->prdeeprom;
 
-	lbs_pr_debug(1, "eeprom read len=%x\n",
+	lbs_deb_cmd("eeprom read len=%x\n",
 	       le16_to_cpu(resp->params.rdeeprom.bytecount));
 	if (pbuf->NOB < le16_to_cpu(resp->params.rdeeprom.bytecount)) {
 		pbuf->NOB = 0;
-		lbs_pr_debug(1, "eeprom read return length is too big\n");
+		lbs_deb_cmd("eeprom read return length is too big\n");
 		return -1;
 	}
 	pbuf->NOB = le16_to_cpu(resp->params.rdeeprom.bytecount);
@@ -549,17 +525,15 @@ static int wlan_ret_802_11_eeprom_access
 static int wlan_ret_get_log(wlan_private * priv,
 			    struct cmd_ds_command *resp)
 {
-	struct cmd_ds_802_11_get_log *logmessage =
-	    (struct cmd_ds_802_11_get_log *)&resp->params.glog;
+	struct cmd_ds_802_11_get_log *logmessage = &resp->params.glog;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	/* TODO Convert it to Big Endian before copy */
-	memcpy(&adapter->logmsg, logmessage,
-	       sizeof(struct cmd_ds_802_11_get_log));
+	/* Stored little-endian */
+	memcpy(&adapter->logmsg, logmessage, sizeof(struct cmd_ds_802_11_get_log));
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_CMD);
 	return 0;
 }
 
@@ -620,8 +594,7 @@ static inline int handle_cmd_response(u1
 	case cmd_ret_802_11_set_afc:
 	case cmd_ret_802_11_get_afc:
 		spin_lock_irqsave(&adapter->driver_lock, flags);
-		memmove(adapter->cur_cmd->pdata_buf,
-			&resp->params.afc,
+		memmove(adapter->cur_cmd->pdata_buf, &resp->params.afc,
 			sizeof(struct cmd_ds_802_11_afc));
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
@@ -663,7 +636,7 @@ static inline int handle_cmd_response(u1
 		break;
 
 	case cmd_ret_802_11_key_material:
-		lbs_pr_debug(1, "CMD_RESP: KEY_MATERIAL command response\n");
+		lbs_deb_cmd("CMD_RESP: KEY_MATERIAL command response\n");
 		ret = wlan_ret_802_11_key_material(priv, resp);
 		break;
 
@@ -687,22 +660,19 @@ static inline int handle_cmd_response(u1
 
 	case cmd_ret_802_11_tpc_cfg:
 		spin_lock_irqsave(&adapter->driver_lock, flags);
-		memmove(adapter->cur_cmd->pdata_buf,
-			&resp->params.tpccfg,
+		memmove(adapter->cur_cmd->pdata_buf, &resp->params.tpccfg,
 			sizeof(struct cmd_ds_802_11_tpc_cfg));
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 		break;
 	case cmd_ret_802_11_led_gpio_ctrl:
 		spin_lock_irqsave(&adapter->driver_lock, flags);
-		memmove(adapter->cur_cmd->pdata_buf,
-			&resp->params.ledgpio,
+		memmove(adapter->cur_cmd->pdata_buf, &resp->params.ledgpio,
 			sizeof(struct cmd_ds_802_11_led_ctrl));
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 		break;
 	case cmd_ret_802_11_pwr_cfg:
 		spin_lock_irqsave(&adapter->driver_lock, flags);
-		memmove(adapter->cur_cmd->pdata_buf,
-			&resp->params.pwrcfg,
+		memmove(adapter->cur_cmd->pdata_buf, &resp->params.pwrcfg,
 			sizeof(struct cmd_ds_802_11_pwr_cfg));
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
@@ -724,23 +694,21 @@ static inline int handle_cmd_response(u1
 	case cmd_ret_fwt_access:
 		spin_lock_irqsave(&adapter->driver_lock, flags);
 		if (adapter->cur_cmd->pdata_buf)
-			memcpy(adapter->cur_cmd->pdata_buf,
-			       &resp->params.fwt,
-				sizeof(resp->params.fwt));
+			memcpy(adapter->cur_cmd->pdata_buf, &resp->params.fwt,
+			       sizeof(resp->params.fwt));
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 		break;
 	case cmd_ret_mesh_access:
 		if (adapter->cur_cmd->pdata_buf)
-			memcpy(adapter->cur_cmd->pdata_buf,
-			       &resp->params.mesh,
+			memcpy(adapter->cur_cmd->pdata_buf, &resp->params.mesh,
 			       sizeof(resp->params.mesh));
 		break;
 	case cmd_rte_802_11_tx_rate_query:
 		priv->adapter->txrate = resp->params.txrate.txrate;
 		break;
 	default:
-		lbs_pr_debug(1, "CMD_RESP: Unknown command response %#x\n",
-		       resp->command);
+		lbs_deb_cmd("CMD_RESP: Unknown command response %#x\n",
+			    resp->command);
 		break;
 	}
 	return ret;
@@ -755,9 +723,9 @@ int libertas_process_rx_command(wlan_pri
 	ulong flags;
 	u16 result;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "CMD_RESP: @ %lu\n", jiffies);
+	lbs_deb_cmd("CMD_RESP: @ %lu\n", jiffies);
 
 	/* Now we got response from FW, cancel the command timer */
 	del_timer(&adapter->command_timer);
@@ -766,7 +734,7 @@ int libertas_process_rx_command(wlan_pri
 	spin_lock_irqsave(&adapter->driver_lock, flags);
 
 	if (!adapter->cur_cmd) {
-		lbs_pr_debug(1, "CMD_RESP: NULL cur_cmd=%p\n", adapter->cur_cmd);
+		lbs_deb_cmd("CMD_RESP: NULL cur_cmd=%p\n", adapter->cur_cmd);
 		ret = -1;
 		spin_unlock_irqrestore(&adapter->driver_lock, flags);
 		goto done;
@@ -774,17 +742,17 @@ int libertas_process_rx_command(wlan_pri
 	resp = (struct cmd_ds_command *)(adapter->cur_cmd->bufvirtualaddr);
 
 	lbs_dbg_hex("CMD_RESP:", adapter->cur_cmd->bufvirtualaddr,
-		priv->wlan_dev.upld_len);
+		    priv->upld_len);
 
 	respcmd = le16_to_cpu(resp->command);
 
 	result = le16_to_cpu(resp->result);
 
-	lbs_pr_debug(1, "CMD_RESP: %x result: %d length: %d\n", respcmd,
-	       result, priv->wlan_dev.upld_len);
+	lbs_deb_cmd("CMD_RESP: %x result: %d length: %d\n", respcmd,
+		    result, priv->upld_len);
 
 	if (!(respcmd & 0x8000)) {
-		lbs_pr_debug(1, "Invalid response to command!");
+		lbs_deb_cmd("Invalid response to command!");
 		adapter->cur_cmd_retcode = -1;
 		__libertas_cleanup_and_insert_cmd(priv, adapter->cur_cmd);
 		adapter->nr_cmd_pending--;
@@ -795,56 +763,52 @@ int libertas_process_rx_command(wlan_pri
 	}
 
 	/* Store the response code to cur_cmd_retcode. */
-	adapter->cur_cmd_retcode = le16_to_cpu(resp->result);
+	adapter->cur_cmd_retcode = result;;
 
 	if (respcmd == cmd_ret_802_11_ps_mode) {
-		struct cmd_ds_802_11_ps_mode *psmode;
+		struct cmd_ds_802_11_ps_mode *psmode = &resp->params.psmode;
+		u16 action = le16_to_cpu(psmode->action);
 
-		psmode = &resp->params.psmode;
-		lbs_pr_debug(1,
+		lbs_deb_cmd(
 		       "CMD_RESP: PS_MODE cmd reply result=%#x action=0x%X\n",
-		       resp->result, psmode->action);
-		psmode->action = cpu_to_le16(psmode->action);
+		       result, action);
 
 		if (result) {
-			lbs_pr_debug(1, "CMD_RESP: PS command failed- %#x \n",
-			       resp->result);
-			if (adapter->mode == IW_MODE_ADHOC) {
-				/*
-				 * We should not re-try enter-ps command in
-				 * ad-hoc mode. It takes place in
-				 * libertas_execute_next_command().
-				 */
-				if (psmode->action == cmd_subcmd_enter_ps)
-					adapter->psmode =
-					    wlan802_11powermodecam;
-			}
-		} else if (psmode->action == cmd_subcmd_enter_ps) {
+			lbs_deb_cmd("CMD_RESP: PS command failed- %#x \n",
+				    result);
+			/*
+			 * We should not re-try enter-ps command in
+			 * ad-hoc mode. It takes place in
+			 * libertas_execute_next_command().
+			 */
+			if (adapter->mode == IW_MODE_ADHOC &&
+			    action == cmd_subcmd_enter_ps)
+				adapter->psmode = wlan802_11powermodecam;
+		} else if (action == cmd_subcmd_enter_ps) {
 			adapter->needtowakeup = 0;
 			adapter->psstate = PS_STATE_AWAKE;
 
-			lbs_pr_debug(1, "CMD_RESP: Enter_PS command response\n");
+			lbs_deb_cmd("CMD_RESP: Enter_PS command response\n");
 			if (adapter->connect_status != libertas_connected) {
 				/*
 				 * When Deauth Event received before Enter_PS command
 				 * response, We need to wake up the firmware.
 				 */
-				lbs_pr_debug(1,
+				lbs_deb_cmd(
 				       "Disconnected, Going to invoke libertas_ps_wakeup\n");
 
-				mutex_unlock(&adapter->lock);
 				spin_unlock_irqrestore(&adapter->driver_lock, flags);
+				mutex_unlock(&adapter->lock);
 				libertas_ps_wakeup(priv, 0);
 				mutex_lock(&adapter->lock);
 				spin_lock_irqsave(&adapter->driver_lock, flags);
 			}
-		} else if (psmode->action == cmd_subcmd_exit_ps) {
+		} else if (action == cmd_subcmd_exit_ps) {
 			adapter->needtowakeup = 0;
 			adapter->psstate = PS_STATE_FULL_POWER;
-			lbs_pr_debug(1, "CMD_RESP: Exit_PS command response\n");
+			lbs_deb_cmd("CMD_RESP: Exit_PS command response\n");
 		} else {
-			lbs_pr_debug(1, "CMD_RESP: PS- action=0x%X\n",
-			       psmode->action);
+			lbs_deb_cmd("CMD_RESP: PS- action=0x%X\n", action);
 		}
 
 		__libertas_cleanup_and_insert_cmd(priv, adapter->cur_cmd);
@@ -865,15 +829,15 @@ int libertas_process_rx_command(wlan_pri
 
 	/* If the command is not successful, cleanup and return failure */
 	if ((result != 0 || !(respcmd & 0x8000))) {
-		lbs_pr_debug(1, "CMD_RESP: command reply %#x result=%#x\n",
-		       resp->command, resp->result);
+		lbs_deb_cmd("CMD_RESP: command reply %#x result=%#x\n",
+		       respcmd, result);
 		/*
 		 * Handling errors here
 		 */
 		switch (respcmd) {
 		case cmd_ret_hw_spec_info:
 		case cmd_ret_802_11_reset:
-			lbs_pr_debug(1, "CMD_RESP: Reset command failed\n");
+			lbs_deb_cmd("CMD_RESP: Reset command failed\n");
 			break;
 
 		}
@@ -903,7 +867,7 @@ int libertas_process_rx_command(wlan_pri
 
 done:
 	mutex_unlock(&adapter->lock);
-	LEAVE();
+	lbs_deb_enter_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
 
@@ -917,37 +881,37 @@ int libertas_process_event(wlan_private 
 	eventcause = adapter->eventcause;
 	spin_unlock_irq(&adapter->driver_lock);
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_CMD);
 
-	lbs_pr_debug(1, "EVENT Cause %x\n", eventcause);
+	lbs_deb_cmd("EVENT Cause %x\n", eventcause);
 
 	switch (eventcause >> SBI_EVENT_CAUSE_SHIFT) {
 	case MACREG_INT_CODE_LINK_SENSED:
-		lbs_pr_debug(1, "EVENT: MACREG_INT_CODE_LINK_SENSED\n");
+		lbs_deb_cmd("EVENT: MACREG_INT_CODE_LINK_SENSED\n");
 		break;
 
 	case MACREG_INT_CODE_DEAUTHENTICATED:
-		lbs_pr_debug(1, "EVENT: Deauthenticated\n");
+		lbs_deb_cmd("EVENT: Deauthenticated\n");
 		libertas_mac_event_disconnected(priv);
 		break;
 
 	case MACREG_INT_CODE_DISASSOCIATED:
-		lbs_pr_debug(1, "EVENT: Disassociated\n");
+		lbs_deb_cmd("EVENT: Disassociated\n");
 		libertas_mac_event_disconnected(priv);
 		break;
 
 	case MACREG_INT_CODE_LINK_LOSE_NO_SCAN:
-		lbs_pr_debug(1, "EVENT: Link lost\n");
+		lbs_deb_cmd("EVENT: Link lost\n");
 		libertas_mac_event_disconnected(priv);
 		break;
 
 	case MACREG_INT_CODE_PS_SLEEP:
-		lbs_pr_debug(1, "EVENT: SLEEP\n");
-		lbs_pr_debug(1, "_");
+		lbs_deb_cmd("EVENT: SLEEP\n");
+		lbs_deb_cmd("_");
 
 		/* handle unexpected PS SLEEP event */
 		if (adapter->psstate == PS_STATE_FULL_POWER) {
-			lbs_pr_debug(1,
+			lbs_deb_cmd(
 			       "EVENT: In FULL POWER mode - ignore PS SLEEP\n");
 			break;
 		}
@@ -958,12 +922,12 @@ int libertas_process_event(wlan_private 
 		break;
 
 	case MACREG_INT_CODE_PS_AWAKE:
-		lbs_pr_debug(1, "EVENT: AWAKE \n");
-		lbs_pr_debug(1, "|");
+		lbs_deb_cmd("EVENT: AWAKE \n");
+		lbs_deb_cmd("|");
 
 		/* handle unexpected PS AWAKE event */
 		if (adapter->psstate == PS_STATE_FULL_POWER) {
-			lbs_pr_debug(1,
+			lbs_deb_cmd(
 			       "EVENT: In FULL POWER mode - ignore PS AWAKE\n");
 			break;
 		}
@@ -977,18 +941,18 @@ int libertas_process_event(wlan_private 
 			 * adapter->needtowakeup will be set to FALSE
 			 * in libertas_ps_wakeup()
 			 */
-			lbs_pr_debug(1, "Waking up...\n");
+			lbs_deb_cmd("Waking up...\n");
 			libertas_ps_wakeup(priv, 0);
 		}
 		break;
 
 	case MACREG_INT_CODE_MIC_ERR_UNICAST:
-		lbs_pr_debug(1, "EVENT: UNICAST MIC ERROR\n");
+		lbs_deb_cmd("EVENT: UNICAST MIC ERROR\n");
 		handle_mic_failureevent(priv, MACREG_INT_CODE_MIC_ERR_UNICAST);
 		break;
 
 	case MACREG_INT_CODE_MIC_ERR_MULTICAST:
-		lbs_pr_debug(1, "EVENT: MULTICAST MIC ERROR\n");
+		lbs_deb_cmd("EVENT: MULTICAST MIC ERROR\n");
 		handle_mic_failureevent(priv, MACREG_INT_CODE_MIC_ERR_MULTICAST);
 		break;
 	case MACREG_INT_CODE_MIB_CHANGED:
@@ -996,7 +960,7 @@ int libertas_process_event(wlan_private 
 		break;
 
 	case MACREG_INT_CODE_ADHOC_BCN_LOST:
-		lbs_pr_debug(1, "EVENT: HWAC - ADHOC BCN LOST\n");
+		lbs_deb_cmd("EVENT: HWAC - ADHOC BCN LOST\n");
 		break;
 
 	case MACREG_INT_CODE_RSSI_LOW:
@@ -1015,6 +979,17 @@ int libertas_process_event(wlan_private 
 		lbs_pr_alert( "EVENT: SNR_HIGH\n");
 		break;
 
+	case MACREG_INT_CODE_MESH_AUTO_STARTED:
+		lbs_pr_alert( "EVENT: MESH_AUTO_STARTED\n");
+		adapter->connect_status = libertas_connected ;
+		if (priv->mesh_open == 1) {
+			netif_wake_queue(priv->mesh_dev) ;
+			netif_carrier_on(priv->mesh_dev) ;
+		}
+		adapter->mode = IW_MODE_ADHOC ;
+		schedule_work(&priv->sync_channel);
+		break;
+
 	default:
 		lbs_pr_alert( "EVENT: unknown event id: %#x\n",
 		       eventcause >> SBI_EVENT_CAUSE_SHIFT);
@@ -1024,6 +999,7 @@ int libertas_process_event(wlan_private 
 	spin_lock_irq(&adapter->driver_lock);
 	adapter->eventcause = 0;
 	spin_unlock_irq(&adapter->driver_lock);
-	LEAVE();
+
+	lbs_deb_enter_args(LBS_DEB_CMD, "ret %d", ret);
 	return ret;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/debugfs.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/debugfs.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/debugfs.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/debugfs.c	2007-06-14 14:14:33.000000000 -0400
@@ -4,6 +4,7 @@
 #include <linux/delay.h>
 #include <linux/mm.h>
 #include <net/iw_handler.h>
+
 #include "dev.h"
 #include "decl.h"
 #include "host.h"
@@ -15,7 +16,9 @@ static char *szStates[] = {
 	"Disconnected"
 };
 
-void libertas_debug_init(wlan_private * priv, struct net_device *dev);
+#ifdef PROC_DEBUG
+static void libertas_debug_init(wlan_private * priv, struct net_device *dev);
+#endif
 
 static int open_file_generic(struct inode *inode, struct file *file)
 {
@@ -60,43 +63,33 @@ static ssize_t libertas_getscantable(str
 	int numscansdone = 0, res;
 	unsigned long addr = get_zeroed_page(GFP_KERNEL);
 	char *buf = (char *)addr;
+	struct bss_descriptor * iter_bss;
 
 	pos += snprintf(buf+pos, len-pos,
-			"---------------------------------------");
-	pos += snprintf(buf+pos, len-pos,
-			"---------------------------------------\n");
-	pos += snprintf(buf+pos, len-pos,
 		"# | ch  | ss  |       bssid       |   cap    |    TSF   | Qual | SSID \n");
-	pos += snprintf(buf+pos, len-pos,
-		"---------------------------------------");
-	pos += snprintf(buf+pos, len-pos,
-		"---------------------------------------\n");
 
-	while (numscansdone < priv->adapter->numinscantable) {
-		struct bss_descriptor *pbssinfo;
+	mutex_lock(&priv->adapter->lock);
+	list_for_each_entry (iter_bss, &priv->adapter->network_list, list) {
 		u16 cap;
 
-		pbssinfo = &priv->adapter->scantable[numscansdone];
-		memcpy(&cap, &pbssinfo->cap, sizeof(cap));
+		memcpy(&cap, &iter_bss->cap, sizeof(cap));
 		pos += snprintf(buf+pos, len-pos,
-			"%02u| %03d | %03ld | %02x:%02x:%02x:%02x:%02x:%02x |",
-			numscansdone, pbssinfo->channel, pbssinfo->rssi,
-			pbssinfo->macaddress[0], pbssinfo->macaddress[1],
-			pbssinfo->macaddress[2], pbssinfo->macaddress[3],
-			pbssinfo->macaddress[4], pbssinfo->macaddress[5]);
+			"%02u| %03d | %03ld | " MAC_FMT " |",
+			numscansdone, iter_bss->channel, iter_bss->rssi,
+			MAC_ARG(iter_bss->bssid));
 		pos += snprintf(buf+pos, len-pos, " %04x-", cap);
 		pos += snprintf(buf+pos, len-pos, "%c%c%c |",
-				pbssinfo->cap.ibss ? 'A' : 'I',
-				pbssinfo->cap.privacy ? 'P' : ' ',
-				pbssinfo->cap.spectrummgmt ? 'S' : ' ');
-		pos += snprintf(buf+pos, len-pos, " %08llx |", pbssinfo->networktsf);
-		pos += snprintf(buf+pos, len-pos, " %d |",
-			SCAN_RSSI(priv->adapter->scantable[numscansdone].rssi));
-
-		pos += snprintf(buf+pos, len-pos, " %s\n", pbssinfo->ssid.ssid);
+				iter_bss->cap.ibss ? 'A' : 'I',
+				iter_bss->cap.privacy ? 'P' : ' ',
+				iter_bss->cap.spectrummgmt ? 'S' : ' ');
+		pos += snprintf(buf+pos, len-pos, " %08llx |", iter_bss->networktsf);
+		pos += snprintf(buf+pos, len-pos, " %d |", SCAN_RSSI(iter_bss->rssi));
+		pos += snprintf(buf+pos, len-pos, " %s\n",
+		                escape_essid(iter_bss->ssid, iter_bss->ssid_len));
 
 		numscansdone++;
 	}
+	mutex_unlock(&priv->adapter->lock);
 
 	res = simple_read_from_buffer(userbuf, count, ppos, buf, pos);
 
@@ -111,7 +104,6 @@ static ssize_t libertas_sleepparams_writ
 	wlan_private *priv = file->private_data;
 	ssize_t buf_size, res;
 	int p1, p2, p3, p4, p5, p6;
-	struct sleep_params sp;
 	unsigned long addr = get_zeroed_page(GFP_KERNEL);
 	char *buf = (char *)addr;
 
@@ -125,14 +117,12 @@ static ssize_t libertas_sleepparams_writ
 		res = -EFAULT;
 		goto out_unlock;
 	}
-	sp.sp_error = p1;
-	sp.sp_offset = p2;
-	sp.sp_stabletime = p3;
-	sp.sp_calcontrol = p4;
-	sp.sp_extsleepclk = p5;
-	sp.sp_reserved = p6;
-
-	memcpy(&priv->adapter->sp, &sp, sizeof(struct sleep_params));
+	priv->adapter->sp.sp_error = p1;
+	priv->adapter->sp.sp_offset = p2;
+	priv->adapter->sp.sp_stabletime = p3;
+	priv->adapter->sp.sp_calcontrol = p4;
+	priv->adapter->sp.sp_extsleepclk = p5;
+	priv->adapter->sp.sp_reserved = p6;
 
         res = libertas_prepare_and_send_command(priv,
 				cmd_802_11_sleep_params,
@@ -185,7 +175,6 @@ static ssize_t libertas_extscan(struct f
 {
 	wlan_private *priv = file->private_data;
 	ssize_t res, buf_size;
-	struct WLAN_802_11_SSID extscan_ssid;
 	union iwreq_data wrqu;
 	unsigned long addr = get_zeroed_page(GFP_KERNEL);
 	char *buf = (char *)addr;
@@ -196,13 +185,10 @@ static ssize_t libertas_extscan(struct f
 		goto out_unlock;
 	}
 
-	memcpy(&extscan_ssid.ssid, buf, strlen(buf)-1);
-	extscan_ssid.ssidlength = strlen(buf)-1;
-
-	libertas_send_specific_SSID_scan(priv, &extscan_ssid, 1);
+	libertas_send_specific_ssid_scan(priv, buf, strlen(buf)-1, 0);
 
 	memset(&wrqu, 0, sizeof(union iwreq_data));
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+	wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
 
 out_unlock:
 	free_page(addr);
@@ -251,16 +237,13 @@ static void libertas_parse_bssid(char *b
 {
 	char *hold;
 	unsigned int mac[ETH_ALEN];
-	int i;
 
 	hold = strstr(buf, "bssid=");
 	if (!hold)
 		return;
 	hold += 6;
-	sscanf(hold, "%2x:%2x:%2x:%2x:%2x:%2x", mac, mac+1, mac+2, mac+3,
-			mac+4, mac+5);
-	for(i=0;i<ETH_ALEN;i++)
-		scan_cfg->specificBSSID[i] = mac[i];
+	sscanf(hold, MAC_FMT, mac, mac+1, mac+2, mac+3, mac+4, mac+5);
+	memcpy(scan_cfg->bssid, mac, ETH_ALEN);
 }
 
 static void libertas_parse_ssid(char *buf, size_t count,
@@ -278,28 +261,26 @@ static void libertas_parse_ssid(char *bu
 		end = buf + count - 1;
 
 	size = min((size_t)IW_ESSID_MAX_SIZE, (size_t) (end - hold));
-	strncpy(scan_cfg->specificSSID, hold, size);
+	strncpy(scan_cfg->ssid, hold, size);
 
 	return;
 }
 
-static void libertas_parse_keep(char *buf, size_t count,
-                        struct wlan_ioctl_user_scan_cfg *scan_cfg)
+static int libertas_parse_clear(char *buf, size_t count, const char *tag)
 {
 	char *hold;
 	int val;
 
-	hold = strstr(buf, "keep=");
+	hold = strstr(buf, tag);
 	if (!hold)
-		return;
-	hold += 5;
+		return 0;
+	hold += strlen(tag);
 	sscanf(hold, "%d", &val);
 
 	if (val != 0)
 		val = 1;
 
-	scan_cfg->keeppreviousscan = val;
-	return;
+	return val;
 }
 
 static int libertas_parse_dur(char *buf, size_t count,
@@ -382,17 +363,18 @@ static ssize_t libertas_setuserscan(stru
 	dur = libertas_parse_dur(buf, count, scan_cfg);
 	libertas_parse_chan(buf, count, scan_cfg, dur);
 	libertas_parse_bssid(buf, count, scan_cfg);
+	scan_cfg->clear_bssid = libertas_parse_clear(buf, count, "clear_bssid=");
 	libertas_parse_ssid(buf, count, scan_cfg);
-	libertas_parse_keep(buf, count, scan_cfg);
+	scan_cfg->clear_ssid = libertas_parse_clear(buf, count, "clear_ssid=");
 	libertas_parse_probes(buf, count, scan_cfg);
 	libertas_parse_type(buf, count, scan_cfg);
 
-	wlan_scan_networks(priv, scan_cfg);
+	wlan_scan_networks(priv, scan_cfg, 1);
 	wait_event_interruptible(priv->adapter->cmd_pending,
 				 !priv->adapter->nr_cmd_pending);
 
 	memset(&wrqu, 0x00, sizeof(union iwreq_data));
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu, NULL);
+	wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
 
 out_unlock:
 	free_page(addr);
@@ -407,11 +389,11 @@ static int libertas_event_initcmd(wlan_p
 	u16 wait_option = cmd_option_waitforrsp;
 
 	if (!(*cmdnode = libertas_get_free_cmd_ctrl_node(priv))) {
-		lbs_pr_debug(1, "failed libertas_get_free_cmd_ctrl_node\n");
+		lbs_deb_debugfs("failed libertas_get_free_cmd_ctrl_node\n");
 		return -ENOMEM;
 	}
 	if (!(*response_buf = kmalloc(3000, GFP_KERNEL))) {
-		lbs_pr_debug(1, "failed to allocate response buffer!\n");
+		lbs_deb_debugfs("failed to allocate response buffer!\n");
 		return -ENOMEM;
 	}
 	libertas_set_cmd_ctrl_node(priv, *cmdnode, 0, wait_option, NULL);
@@ -420,8 +402,8 @@ static int libertas_event_initcmd(wlan_p
 	(*cmdnode)->cmdflags |= CMD_F_HOSTCMD;
 	(*cmdnode)->cmdwaitqwoken = 0;
 	*cmd = (struct cmd_ds_command *)(*cmdnode)->bufvirtualaddr;
-	(*cmd)->command = cmd_802_11_subscribe_event;
-	(*cmd)->seqnum = ++priv->adapter->seqnum;
+	(*cmd)->command = cpu_to_le16(cmd_802_11_subscribe_event);
+	(*cmd)->seqnum = cpu_to_le16(++priv->adapter->seqnum);
 	(*cmd)->result = 0;
 	return 0;
 }
@@ -447,26 +429,25 @@ static ssize_t libertas_lowrssi_read(str
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -474,17 +455,17 @@ static ssize_t libertas_lowrssi_read(str
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_rssithreshold  *Lowrssi;
-		case TLV_TYPE_RSSI_LOW:
-		Lowrssi = (struct mrvlietypes_rssithreshold *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
-				Lowrssi->rssivalue,
-				Lowrssi->rssifreq,
-				(event->events & 0x0001)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_RSSI_LOW):
+			Lowrssi = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
+					Lowrssi->rssivalue,
+					Lowrssi->rssifreq,
+					(event->events & cpu_to_le16(0x0001))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_snrthreshold);
 			break;
@@ -512,21 +493,20 @@ static u16 libertas_get_events_bitmap(wl
 		return res;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		return 0;
 	}
@@ -538,7 +518,7 @@ static u16 libertas_get_events_bitmap(wl
 	}
 
 	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	event_bitmap = event->events;
+	event_bitmap = le16_to_cpu(event->events);
 	kfree(response_buf);
 	return event_bitmap;
 }
@@ -579,7 +559,7 @@ static ssize_t libertas_lowrssi_write(st
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_rssithreshold));
@@ -588,30 +568,30 @@ static ssize_t libertas_lowrssi_write(st
 	ptr = (u8*) pcmdptr+cmd_len;
 	rssi_threshold = (struct mrvlietypes_rssithreshold *)(ptr);
 	rssi_threshold->header.type = cpu_to_le16(0x0104);
-	rssi_threshold->header.len = 2;
-	rssi_threshold->rssivalue = cpu_to_le16(value);
-	rssi_threshold->rssifreq = cpu_to_le16(freq);
+	rssi_threshold->header.len = cpu_to_le16(2);
+	rssi_threshold->rssivalue = value;
+	rssi_threshold->rssifreq = freq;
 	event_bitmap |= subscribed ? 0x0001 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -645,27 +625,26 @@ static ssize_t libertas_lowsnr_read(stru
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -673,17 +652,17 @@ static ssize_t libertas_lowsnr_read(stru
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_snrthreshold *LowSnr;
-		case TLV_TYPE_SNR_LOW:
-		LowSnr = (struct mrvlietypes_snrthreshold *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
-				LowSnr->snrvalue,
-				LowSnr->snrfreq,
-				(event->events & 0x0002)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_SNR_LOW):
+			LowSnr = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
+					LowSnr->snrvalue,
+					LowSnr->snrfreq,
+					(event->events & cpu_to_le16(0x0002))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_snrthreshold);
 			break;
@@ -733,7 +712,7 @@ static ssize_t libertas_lowsnr_write(str
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_snrthreshold));
@@ -741,30 +720,30 @@ static ssize_t libertas_lowsnr_write(str
 	ptr = (u8*) pcmdptr+cmd_len;
 	snr_threshold = (struct mrvlietypes_snrthreshold *)(ptr);
 	snr_threshold->header.type = cpu_to_le16(TLV_TYPE_SNR_LOW);
-	snr_threshold->header.len = 2;
-	snr_threshold->snrvalue = cpu_to_le16(value);
-	snr_threshold->snrfreq = cpu_to_le16(freq);
+	snr_threshold->header.len = cpu_to_le16(2);
+	snr_threshold->snrvalue = value;
+	snr_threshold->snrfreq = freq;
 	event_bitmap |= subscribed ? 0x0002 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -799,27 +778,26 @@ static ssize_t libertas_failcount_read(s
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size =	cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -827,17 +805,17 @@ static ssize_t libertas_failcount_read(s
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_failurecount *failcount;
-		case TLV_TYPE_FAILCOUNT:
-		failcount = (struct mrvlietypes_failurecount *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
-				failcount->failvalue,
-				failcount->Failfreq,
-				(event->events & 0x0004)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_FAILCOUNT):
+			failcount = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
+					failcount->failvalue,
+					failcount->Failfreq,
+					(event->events & cpu_to_le16(0x0004))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_failurecount);
 			break;
@@ -886,7 +864,7 @@ static ssize_t libertas_failcount_write(
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_failurecount));
@@ -894,30 +872,30 @@ static ssize_t libertas_failcount_write(
 	ptr = (u8*) pcmdptr+cmd_len;
 	failcount = (struct mrvlietypes_failurecount *)(ptr);
 	failcount->header.type = cpu_to_le16(TLV_TYPE_FAILCOUNT);
-	failcount->header.len = 2;
-	failcount->failvalue = cpu_to_le16(value);
-	failcount->Failfreq = cpu_to_le16(freq);
+	failcount->header.len = cpu_to_le16(2);
+	failcount->failvalue = value;
+	failcount->Failfreq = freq;
 	event_bitmap |= subscribed ? 0x0004 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = (struct cmd_ds_command *)response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -951,27 +929,26 @@ static ssize_t libertas_bcnmiss_read(str
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		free_page(addr);
 		kfree(response_buf);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		free_page(addr);
 		kfree(response_buf);
@@ -979,16 +956,16 @@ static ssize_t libertas_bcnmiss_read(str
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_beaconsmissed *bcnmiss;
-		case TLV_TYPE_BCNMISS:
-		bcnmiss = (struct mrvlietypes_beaconsmissed *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d N/A %d\n",
-				bcnmiss->beaconmissed,
-				(event->events & 0x0008)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_BCNMISS):
+			bcnmiss = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d N/A %d\n",
+					bcnmiss->beaconmissed,
+					(event->events & cpu_to_le16(0x0008))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_beaconsmissed);
 			break;
@@ -1038,7 +1015,7 @@ static ssize_t libertas_bcnmiss_write(st
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_beaconsmissed));
@@ -1046,29 +1023,29 @@ static ssize_t libertas_bcnmiss_write(st
 	ptr = (u8*) pcmdptr+cmd_len;
 	bcnmiss = (struct mrvlietypes_beaconsmissed *)(ptr);
 	bcnmiss->header.type = cpu_to_le16(TLV_TYPE_BCNMISS);
-	bcnmiss->header.len = 2;
-	bcnmiss->beaconmissed = cpu_to_le16(value);
+	bcnmiss->header.len = cpu_to_le16(2);
+	bcnmiss->beaconmissed = value;
 	event_bitmap |= subscribed ? 0x0008 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		free_page(addr);
 		kfree(response_buf);
@@ -1102,27 +1079,26 @@ static ssize_t libertas_highrssi_read(st
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -1130,17 +1106,17 @@ static ssize_t libertas_highrssi_read(st
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_rssithreshold  *Highrssi;
-		case TLV_TYPE_RSSI_HIGH:
-		Highrssi = (struct mrvlietypes_rssithreshold *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
-				Highrssi->rssivalue,
-				Highrssi->rssifreq,
-				(event->events & 0x0010)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_RSSI_HIGH):
+			Highrssi = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
+					Highrssi->rssivalue,
+					Highrssi->rssifreq,
+					(event->events & cpu_to_le16(0x0010))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_snrthreshold);
 			break;
@@ -1190,7 +1166,7 @@ static ssize_t libertas_highrssi_write(s
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_rssithreshold));
@@ -1198,29 +1174,29 @@ static ssize_t libertas_highrssi_write(s
 	ptr = (u8*) pcmdptr+cmd_len;
 	rssi_threshold = (struct mrvlietypes_rssithreshold *)(ptr);
 	rssi_threshold->header.type = cpu_to_le16(TLV_TYPE_RSSI_HIGH);
-	rssi_threshold->header.len = 2;
-	rssi_threshold->rssivalue = cpu_to_le16(value);
-	rssi_threshold->rssifreq = cpu_to_le16(freq);
+	rssi_threshold->header.len = cpu_to_le16(2);
+	rssi_threshold->rssivalue = value;
+	rssi_threshold->rssifreq = freq;
 	event_bitmap |= subscribed ? 0x0010 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		return 0;
@@ -1253,27 +1229,26 @@ static ssize_t libertas_highsnr_read(str
 	}
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_get;
-	pcmdptr->size =
-	cpu_to_le16(sizeof(struct cmd_ds_802_11_subscribe_event) + S_DS_GEN);
+	event->action = cpu_to_le16(cmd_act_get);
+	pcmdptr->size = cpu_to_le16(sizeof(*event) + S_DS_GEN);
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -1281,17 +1256,17 @@ static ssize_t libertas_highsnr_read(str
 	}
 
 	cmd_len = S_DS_GEN + sizeof(struct cmd_ds_802_11_subscribe_event);
-	event = (struct cmd_ds_802_11_subscribe_event *)(response_buf + S_DS_GEN);
-	while (cmd_len < pcmdptr->size) {
-		struct mrvlietypesheader *header = (struct mrvlietypesheader *)(response_buf + cmd_len);
-		switch(header->type) {
+	event = (void *)(response_buf + S_DS_GEN);
+	while (cmd_len < le16_to_cpu(pcmdptr->size)) {
+		struct mrvlietypesheader *header = (void *)(response_buf + cmd_len);
+		switch (header->type) {
 		struct mrvlietypes_snrthreshold *HighSnr;
-		case TLV_TYPE_SNR_HIGH:
-		HighSnr = (struct mrvlietypes_snrthreshold *)(response_buf + cmd_len);
-		pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
-				HighSnr->snrvalue,
-				HighSnr->snrfreq,
-				(event->events & 0x0020)?1:0);
+		case __constant_cpu_to_le16(TLV_TYPE_SNR_HIGH):
+			HighSnr = (void *)(response_buf + cmd_len);
+			pos += snprintf(buf+pos, len-pos, "%d %d %d\n",
+					HighSnr->snrvalue,
+					HighSnr->snrfreq,
+					(event->events & cpu_to_le16(0x0020))?1:0);
 		default:
 			cmd_len += sizeof(struct mrvlietypes_snrthreshold);
 			break;
@@ -1341,7 +1316,7 @@ static ssize_t libertas_highsnr_write(st
 		goto out_unlock;
 
 	event = &pcmdptr->params.subscribe_event;
-	event->action = cmd_act_set;
+	event->action = cpu_to_le16(cmd_act_set);
 	pcmdptr->size = cpu_to_le16(S_DS_GEN +
 		sizeof(struct cmd_ds_802_11_subscribe_event) +
 		sizeof(struct mrvlietypes_snrthreshold));
@@ -1349,30 +1324,30 @@ static ssize_t libertas_highsnr_write(st
 	ptr = (u8*) pcmdptr+cmd_len;
 	snr_threshold = (struct mrvlietypes_snrthreshold *)(ptr);
 	snr_threshold->header.type = cpu_to_le16(TLV_TYPE_SNR_HIGH);
-	snr_threshold->header.len = 2;
-	snr_threshold->snrvalue = cpu_to_le16(value);
-	snr_threshold->snrfreq = cpu_to_le16(freq);
+	snr_threshold->header.len = cpu_to_le16(2);
+	snr_threshold->snrvalue = value;
+	snr_threshold->snrfreq = freq;
 	event_bitmap |= subscribed ? 0x0020 : 0x0;
-	event->events = event_bitmap;
+	event->events = cpu_to_le16(event_bitmap);
 
 	libertas_queue_cmd(adapter, pcmdnode, 1);
 	wake_up_interruptible(&priv->mainthread.waitq);
 
 	/* Sleep until response is generated by FW */
 	wait_event_interruptible(pcmdnode->cmdwait_q,
-				pcmdnode->cmdwaitqwoken);
+				 pcmdnode->cmdwaitqwoken);
 
 	pcmdptr = response_buf;
 
 	if (pcmdptr->result) {
-		lbs_pr_err("%s: fail, result=%d\n", __FUNCTION__,
-			pcmdptr->result);
+		lbs_pr_err("%s: fail, result=%d\n", __func__,
+			   le16_to_cpu(pcmdptr->result));
 		kfree(response_buf);
 		free_page(addr);
 		return 0;
 	}
 
-	if (pcmdptr->command != cmd_ret_802_11_subscribe_event) {
+	if (pcmdptr->command != cpu_to_le16(cmd_ret_802_11_subscribe_event)) {
 		lbs_pr_err("command response incorrect!\n");
 		kfree(response_buf);
 		free_page(addr);
@@ -1760,7 +1735,7 @@ void libertas_debugfs_remove_one(wlan_pr
 
 	debugfs_remove(priv->regs_dir);
 
-	for(i=0; i<ARRAY_SIZE(debugfs_files); i++)
+	for(i=0; i<ARRAY_SIZE(debugfs_events_files); i++)
 		debugfs_remove(priv->debugfs_events_files[i]);
 
 	debugfs_remove(priv->events_dir);
@@ -1769,13 +1744,19 @@ void libertas_debugfs_remove_one(wlan_pr
 #endif
 	for(i=0; i<ARRAY_SIZE(debugfs_files); i++)
 		debugfs_remove(priv->debugfs_files[i]);
+	debugfs_remove(priv->debugfs_dir);
 }
 
+
+
 /* debug entry */
 
+#ifdef PROC_DEBUG
+
 #define item_size(n)	(FIELD_SIZEOF(wlan_adapter, n))
 #define item_addr(n)	(offsetof(wlan_adapter, n))
 
+
 struct debug_data {
 	char name[32];
 	u32 size;
@@ -1863,7 +1844,7 @@ static ssize_t wlan_debugfs_write(struct
 		return 0;
 
 	if (copy_from_user(pdata, buf, cnt)) {
-		lbs_pr_debug(1, "Copy from user failed\n");
+		lbs_deb_debugfs("Copy from user failed\n");
 		kfree(pdata);
 		return 0;
 	}
@@ -1913,7 +1894,7 @@ static struct file_operations libertas_d
  *  @param dev     pointer net_device
  *  @return 	   N/A
  */
-void libertas_debug_init(wlan_private * priv, struct net_device *dev)
+static void libertas_debug_init(wlan_private * priv, struct net_device *dev)
 {
 	int i;
 
@@ -1927,4 +1908,5 @@ void libertas_debug_init(wlan_private * 
 						  priv->debugfs_dir, &items[0],
 						  &libertas_debug_fops);
 }
+#endif
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/decl.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/decl.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/decl.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/decl.h	2007-06-14 14:14:33.000000000 -0400
@@ -6,6 +6,8 @@
 #ifndef _WLAN_DECL_H_
 #define _WLAN_DECL_H_
 
+#include <linux/device.h>
+
 #include "defs.h"
 
 /** Function Prototype Declaration */
@@ -66,18 +68,24 @@ void libertas_ps_wakeup(wlan_private * p
 
 void libertas_tx_runqueue(wlan_private *priv);
 
-extern struct chan_freq_power *libertas_find_cfp_by_band_and_channel(
+struct chan_freq_power *libertas_find_cfp_by_band_and_channel(
 				wlan_adapter * adapter, u8 band, u16 channel);
 
-extern void libertas_mac_event_disconnected(wlan_private * priv);
+void libertas_mac_event_disconnected(wlan_private * priv);
 
 void libertas_send_iwevcustom_event(wlan_private * priv, s8 * str);
 
-int reset_device(wlan_private *priv);
+/* fw.c */
+int libertas_init_fw(wlan_private * priv, char *fw_name);
+
 /* main.c */
-extern struct chan_freq_power *libertas_get_region_cfp_table(u8 region, u8 band,
+struct chan_freq_power *libertas_get_region_cfp_table(u8 region, u8 band,
 						             int *cfp_no);
-wlan_private *wlan_add_card(void *card);
-int wlan_remove_card(void *card);
+wlan_private *libertas_add_card(void *card, struct device *dmdev);
+int libertas_activate_card(wlan_private *priv, char *fw_name);
+int libertas_remove_card(wlan_private *priv);
+int libertas_add_mesh(wlan_private *priv, struct device *dev);
+void libertas_remove_mesh(wlan_private *priv);
+
 
 #endif				/* _WLAN_DECL_H_ */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/defs.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/defs.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/defs.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/defs.h	2007-06-14 14:14:33.000000000 -0400
@@ -7,14 +7,79 @@
 
 #include <linux/spinlock.h>
 
-extern unsigned int libertas_debug;
-
 #ifdef CONFIG_LIBERTAS_DEBUG
 #define DEBUG
 #define PROC_DEBUG
 #endif
 
-#define DRV_NAME		"usb8xxx"
+#ifndef DRV_NAME
+#define DRV_NAME "libertas"
+#endif
+
+
+#define LBS_DEB_ENTER	0x00000001
+#define LBS_DEB_LEAVE	0x00000002
+#define LBS_DEB_MAIN	0x00000004
+#define LBS_DEB_NET	0x00000008
+#define LBS_DEB_MESH	0x00000010
+#define LBS_DEB_WEXT	0x00000020
+#define LBS_DEB_IOCTL	0x00000040
+#define LBS_DEB_SCAN	0x00000080
+#define LBS_DEB_ASSOC	0x00000100
+#define LBS_DEB_JOIN	0x00000200
+#define LBS_DEB_11D	0x00000400
+#define LBS_DEB_DEBUGFS	0x00000800
+#define LBS_DEB_ETHTOOL	0x00001000
+#define LBS_DEB_HOST	0x00002000
+#define LBS_DEB_CMD	0x00004000
+#define LBS_DEB_RX	0x00008000
+#define LBS_DEB_TX	0x00010000
+#define LBS_DEB_USB	0x00020000
+#define LBS_DEB_CS	0x00040000
+#define LBS_DEB_FW	0x00080000
+#define LBS_DEB_THREAD	0x00100000
+#define LBS_DEB_HEX	0x00200000
+
+extern unsigned int libertas_debug;
+
+#ifdef DEBUG
+#define LBS_DEB_LL(grp, fmt, args...) \
+do { if ((libertas_debug & (grp)) == (grp)) \
+  printk(KERN_DEBUG DRV_NAME "%s: " fmt, \
+         in_interrupt() ? " (INT)" : "", ## args); } while (0)
+#else
+#define LBS_DEB_LL(grp, fmt, args...) do {} while (0)
+#endif
+
+#define lbs_deb_enter(grp) \
+  LBS_DEB_LL(grp | LBS_DEB_ENTER, "%s():%d enter\n", __FUNCTION__, __LINE__);
+#define lbs_deb_enter_args(grp, fmt, args...) \
+  LBS_DEB_LL(grp | LBS_DEB_ENTER, "%s(" fmt "):%d\n", __FUNCTION__, ## args, __LINE__);
+#define lbs_deb_leave(grp) \
+  LBS_DEB_LL(grp | LBS_DEB_LEAVE, "%s():%d leave\n", __FUNCTION__, __LINE__);
+#define lbs_deb_leave_args(grp, fmt, args...) \
+  LBS_DEB_LL(grp | LBS_DEB_LEAVE, "%s():%d leave, " fmt "\n", \
+  __FUNCTION__, __LINE__, ##args);
+#define lbs_deb_main(fmt, args...)      LBS_DEB_LL(LBS_DEB_MAIN, fmt, ##args)
+#define lbs_deb_net(fmt, args...)       LBS_DEB_LL(LBS_DEB_NET, fmt, ##args)
+#define lbs_deb_mesh(fmt, args...)      LBS_DEB_LL(LBS_DEB_MESH, fmt, ##args)
+#define lbs_deb_wext(fmt, args...)      LBS_DEB_LL(LBS_DEB_WEXT, fmt, ##args)
+#define lbs_deb_ioctl(fmt, args...)     LBS_DEB_LL(LBS_DEB_IOCTL, fmt, ##args)
+#define lbs_deb_scan(fmt, args...)      LBS_DEB_LL(LBS_DEB_SCAN, fmt, ##args)
+#define lbs_deb_assoc(fmt, args...)     LBS_DEB_LL(LBS_DEB_ASSOC, fmt, ##args)
+#define lbs_deb_join(fmt, args...)      LBS_DEB_LL(LBS_DEB_JOIN, fmt, ##args)
+#define lbs_deb_11d(fmt, args...)       LBS_DEB_LL(LBS_DEB_11D, fmt, ##args)
+#define lbs_deb_debugfs(fmt, args...)   LBS_DEB_LL(LBS_DEB_DEBUGFS, fmt, ##args)
+#define lbs_deb_ethtool(fmt, args...)   LBS_DEB_LL(LBS_DEB_ETHTOOL, fmt, ##args)
+#define lbs_deb_host(fmt, args...)      LBS_DEB_LL(LBS_DEB_HOST, fmt, ##args)
+#define lbs_deb_cmd(fmt, args...)       LBS_DEB_LL(LBS_DEB_CMD, fmt, ##args)
+#define lbs_deb_rx(fmt, args...)        LBS_DEB_LL(LBS_DEB_RX, fmt, ##args)
+#define lbs_deb_tx(fmt, args...)        LBS_DEB_LL(LBS_DEB_TX, fmt, ##args)
+#define lbs_deb_fw(fmt, args...)        LBS_DEB_LL(LBS_DEB_FW, fmt, ##args)
+#define lbs_deb_usb(fmt, args...)       LBS_DEB_LL(LBS_DEB_USB, fmt, ##args)
+#define lbs_deb_usbd(dev, fmt, args...) LBS_DEB_LL(LBS_DEB_USB, "%s:" fmt, (dev)->bus_id, ##args)
+#define lbs_deb_cs(fmt, args...)        LBS_DEB_LL(LBS_DEB_CS, fmt, ##args)
+#define lbs_deb_thread(fmt, args...)    LBS_DEB_LL(LBS_DEB_THREAD, fmt, ##args)
 
 #define lbs_pr_info(format, args...) \
 	printk(KERN_INFO DRV_NAME": " format, ## args)
@@ -24,37 +89,25 @@ extern unsigned int libertas_debug;
 	printk(KERN_ALERT DRV_NAME": " format, ## args)
 
 #ifdef DEBUG
-#define lbs_pr_debug(level, format, args...) \
-	do { if (libertas_debug >= level) \
-	printk(KERN_INFO DRV_NAME": " format, ##args); } while (0)
-#define lbs_dev_dbg(level, device, format, args...) \
-        lbs_pr_debug(level, "%s: " format, \
-        (device)->bus_id , ## args)
-
 static inline void lbs_dbg_hex(char *prompt, u8 * buf, int len)
 {
 	int i = 0;
 
-	if (!libertas_debug)
+	if (!(libertas_debug & LBS_DEB_HEX))
 		return;
 
 	printk(KERN_DEBUG "%s: ", prompt);
 	for (i = 1; i <= len; i++) {
-		printk(KERN_DEBUG "%02x ", (u8) * buf);
+		printk("%02x ", (u8) * buf);
 		buf++;
 	}
 	printk("\n");
 }
 #else
-#define lbs_pr_debug(level, format, args...)		do {} while (0)
-#define lbs_dev_dbg(level, device, format, args...)	do {} while (0)
 #define lbs_dbg_hex(x,y,z)				do {} while (0)
 #endif
 
-#define	ENTER()			lbs_pr_debug(1, "Enter: %s, %s:%i\n", \
-					__FUNCTION__, __FILE__, __LINE__)
-#define	LEAVE()			lbs_pr_debug(1, "Leave: %s, %s:%i\n", \
-					__FUNCTION__, __FILE__, __LINE__)
+
 
 /** Buffer Constants */
 
@@ -74,7 +127,6 @@ static inline void lbs_dbg_hex(char *pro
 #define MRVDRV_NUM_OF_CMD_BUFFER        10
 #define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
 #define MRVDRV_MAX_CHANNEL_SIZE		14
-#define MRVDRV_MAX_BSSID_LIST		64
 #define MRVDRV_ASSOCIATION_TIME_OUT	255
 #define MRVDRV_SNAP_HEADER_LEN          8
 
@@ -104,6 +156,13 @@ static inline void lbs_dbg_hex(char *pro
 #define MRVDRV_MAX_BEACON_INTERVAL		1000
 #define MRVDRV_BEACON_INTERVAL			100
 
+/** INT status Bit Definition*/
+#define his_cmddnldrdy			0x01
+#define his_cardevent			0x02
+#define his_cmdupldrdy			0x04
+
+#define SBI_EVENT_CAUSE_SHIFT		3
+
 /** TxPD status */
 
 /*	Station firmware use TxPD status field to report final Tx transmit
@@ -205,8 +264,6 @@ typedef struct _wlan_adapter wlan_adapte
 extern const char libertas_driver_version[];
 extern u16 libertas_region_code_to_index[MRVDRV_MAX_REGION_CODE];
 
-extern u8 libertas_wlan_data_rates[WLAN_SUPPORTED_RATES];
-
 extern u8 libertas_supported_rates[G_SUPPORTED_RATES];
 
 extern u8 libertas_adhoc_rates_g[G_SUPPORTED_RATES];
@@ -316,6 +373,8 @@ enum SNMP_MIB_VALUE_e {
 /* Default values for fwt commands. */
 #define FWT_DEFAULT_METRIC 0
 #define FWT_DEFAULT_DIR 1
+/* Default Rate, 11Mbps */
+#define FWT_DEFAULT_RATE 3
 #define FWT_DEFAULT_SSN 0xffffffff
 #define FWT_DEFAULT_DSN 0
 #define FWT_DEFAULT_HOPCOUNT 0
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/dev.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/dev.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/dev.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/dev.h	2007-06-14 14:14:33.000000000 -0400
@@ -63,11 +63,11 @@ struct wlan_802_11_security {
 
 /** Current Basic Service Set State Structure */
 struct current_bss_params {
-	struct bss_descriptor bssdescriptor;
 	/** bssid */
 	u8 bssid[ETH_ALEN];
 	/** ssid */
-	struct WLAN_802_11_SSID ssid;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
 
 	/** band */
 	u8 band;
@@ -89,31 +89,6 @@ struct sleep_params {
 	u16 sp_reserved;
 };
 
-/** Data structure for the Marvell WLAN device */
-typedef struct _wlan_dev {
-	/** device name */
-	char name[DEV_NAME_LEN];
-	/** card pointer */
-	void *card;
-	/** IO port */
-	u32 ioport;
-	/** Upload received */
-	u32 upld_rcv;
-	/** Upload type */
-	u32 upld_typ;
-	/** Upload length */
-	u32 upld_len;
-	/** netdev pointer */
-	struct net_device *netdev;
-	/* Upload buffer */
-	u8 upld_buf[WLAN_UPLD_SIZE];
-	/* Download sent:
-	   bit0 1/0=data_sent/data_tx_done,
-	   bit1 1/0=cmd_sent/cmd_tx_done,
-	   all other bits reserved 0 */
-	u8 dnld_sent;
-} wlan_dev_t, *pwlan_dev_t;
-
 /* Mesh statistics */
 struct wlan_mesh_stats {
 	u32	fwd_bcast_cnt;		/* Fwd: Broadcast counter */
@@ -123,6 +98,7 @@ struct wlan_mesh_stats {
 	u32	fwd_drop_noroute; 	/* Fwd: No route to Destination */
 	u32	fwd_drop_nobuf;		/* Fwd: Run out of internal buffers */
 	u32	drop_blind;		/* Rx:  Dropped by blinding table */
+	u32	tx_failed_cnt;		/* Tx:  Failed transmissions */
 };
 
 /** Private structure for the MV device */
@@ -131,8 +107,11 @@ struct _wlan_private {
 	int mesh_open;
 	int infra_open;
 
+	char name[DEV_NAME_LEN];
+
+	void *card;
 	wlan_adapter *adapter;
-	wlan_dev_t wlan_dev;
+	struct net_device *dev;
 
 	struct net_device_stats stats;
 	struct net_device *mesh_dev ; /* Virtual device */
@@ -153,6 +132,16 @@ struct _wlan_private {
 	u32 bbp_offset;
 	u32 rf_offset;
 
+	/** Upload length */
+	u32 upld_len;
+	/* Upload buffer */
+	u8 upld_buf[WLAN_UPLD_SIZE];
+	/* Download sent:
+	   bit0 1/0=data_sent/data_tx_done,
+	   bit1 1/0=cmd_sent/cmd_tx_done,
+	   all other bits reserved 0 */
+	u8 dnld_sent;
+
 	const struct firmware *firmware;
 	struct device *hotplug_device;
 
@@ -161,6 +150,15 @@ struct _wlan_private {
 
 	struct delayed_work assoc_work;
 	struct workqueue_struct *assoc_thread;
+	struct work_struct sync_channel;
+
+	/** Hardware access */
+	int (*hw_register_dev) (wlan_private * priv);
+	int (*hw_unregister_dev) (wlan_private *);
+	int (*hw_prog_firmware) (wlan_private *);
+	int (*hw_host_to_card) (wlan_private * priv, u8 type, u8 * payload, u16 nb);
+	int (*hw_get_int_status) (wlan_private * priv, u8 *);
+	int (*hw_read_event_cause) (wlan_private *);
 };
 
 /** Association request
@@ -171,18 +169,21 @@ struct _wlan_private {
 struct assoc_request {
 #define ASSOC_FLAG_SSID			1
 #define ASSOC_FLAG_CHANNEL		2
-#define ASSOC_FLAG_MODE			3
-#define ASSOC_FLAG_BSSID		4
-#define ASSOC_FLAG_WEP_KEYS		5
-#define ASSOC_FLAG_WEP_TX_KEYIDX	6
-#define ASSOC_FLAG_WPA_MCAST_KEY	7
-#define ASSOC_FLAG_WPA_UCAST_KEY	8
-#define ASSOC_FLAG_SECINFO		9
-#define ASSOC_FLAG_WPA_IE		10
+#define ASSOC_FLAG_BAND			3
+#define ASSOC_FLAG_MODE			4
+#define ASSOC_FLAG_BSSID		5
+#define ASSOC_FLAG_WEP_KEYS		6
+#define ASSOC_FLAG_WEP_TX_KEYIDX	7
+#define ASSOC_FLAG_WPA_MCAST_KEY	8
+#define ASSOC_FLAG_WPA_UCAST_KEY	9
+#define ASSOC_FLAG_SECINFO		10
+#define ASSOC_FLAG_WPA_IE		11
 	unsigned long flags;
 
-	struct WLAN_802_11_SSID ssid;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
 	u8 channel;
+	u8 band;
 	u8 mode;
 	u8 bssid[ETH_ALEN];
 
@@ -199,12 +200,15 @@ struct assoc_request {
 	/** WPA Information Elements*/
 	u8 wpa_ie[MAX_WPA_IE_LEN];
 	u8 wpa_ie_len;
+
+	/* BSS to associate with for infrastructure of Ad-Hoc join */
+	struct bss_descriptor bss;
 };
 
 /** Wlan adapter data structure*/
 struct _wlan_adapter {
 	/** STATUS variables */
-	u32 fwreleasenumber;
+	u8 fwreleasenumber[4];
 	u32 fwcapinfo;
 	/* protected with big lock */
 
@@ -255,13 +259,14 @@ struct _wlan_adapter {
 	/* IW_MODE_* */
 	u8 mode;
 
-	struct bss_descriptor *pattemptedbssdesc;
-
-	struct WLAN_802_11_SSID previousssid;
-	u8 previousbssid[ETH_ALEN];
-
-	struct bss_descriptor *scantable;
-	u32 numinscantable;
+	u8 prev_ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 prev_ssid_len;
+	u8 prev_bssid[ETH_ALEN];
+
+	/* Scan results list */
+	struct list_head network_list;
+	struct list_head network_free_list;
+	struct bss_descriptor *networks;
 
 	u8 scantype;
 	u32 scanmode;
@@ -288,7 +293,6 @@ struct _wlan_adapter {
 	u32 txantenna;
 	u32 rxantenna;
 
-	u8 adhocchannel;
 	u32 fragthsd;
 	u32 rtsthsd;
 
@@ -324,7 +328,8 @@ struct _wlan_adapter {
 	u16 locallisteninterval;
 	u16 nullpktinterval;
 
-	struct assoc_request * assoc_req;
+	struct assoc_request * pending_assoc_req;
+	struct assoc_request * in_progress_assoc_req;
 
 	/** Encryption parameter */
 	struct wlan_802_11_security secinfo;
@@ -396,6 +401,8 @@ struct _wlan_adapter {
 	u32 radiomode;
 	u32 debugmode;
 	u8 fw_ready;
+
+	u8 last_scanned_channel;
 };
 
 #endif				/* _WLAN_DEV_H_ */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/ethtool.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/ethtool.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/ethtool.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/ethtool.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,10 +1,8 @@
-
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 #include <linux/delay.h>
 
 #include "host.h"
-#include "sbi.h"
 #include "decl.h"
 #include "defs.h"
 #include "dev.h"
@@ -17,7 +15,8 @@ static const char * mesh_stat_strings[]=
 			"drop_no_buffers",
 			"fwded_unicast_cnt",
 			"fwded_bcast_cnt",
-			"drop_blind_table"
+			"drop_blind_table",
+			"tx_failed_cnt"
 };
 
 static void libertas_ethtool_get_drvinfo(struct net_device *dev,
@@ -69,7 +68,7 @@ static int libertas_ethtool_get_eeprom(s
 
 	/* +14 is for action, offset, and NOB in
 	 * response */
-	lbs_pr_debug(1, "action:%d offset: %x NOB: %02x\n",
+	lbs_deb_ethtool("action:%d offset: %x NOB: %02x\n",
 	       regctrl.action, regctrl.offset, regctrl.NOB);
 
 	ret = libertas_prepare_and_send_command(priv,
@@ -81,8 +80,7 @@ static int libertas_ethtool_get_eeprom(s
 	if (ret) {
 		if (adapter->prdeeprom)
 			kfree(adapter->prdeeprom);
-		LEAVE();
-			return ret;
+		goto done;
 	}
 
 	mdelay(10);
@@ -101,7 +99,11 @@ static int libertas_ethtool_get_eeprom(s
 		kfree(adapter->prdeeprom);
 //	mutex_unlock(&priv->mutex);
 
-        return 0;
+	ret = 0;
+
+done:
+	lbs_deb_enter_args(LBS_DEB_ETHTOOL, "ret %d", ret);
+        return ret;
 }
 
 static void libertas_ethtool_get_stats(struct net_device * dev,
@@ -109,7 +111,7 @@ static void libertas_ethtool_get_stats(s
 {
 	wlan_private *priv = dev->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ETHTOOL);
 
 	stats->cmd = ETHTOOL_GSTATS;
 	BUG_ON(stats->n_stats != MESH_STATS_NUM);
@@ -121,8 +123,9 @@ static void libertas_ethtool_get_stats(s
         data[4] = priv->mstats.fwd_unicast_cnt;
         data[5] = priv->mstats.fwd_bcast_cnt;
         data[6] = priv->mstats.drop_blind;
+        data[7] = priv->mstats.tx_failed_cnt;
 
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_ETHTOOL);
 }
 
 static int libertas_ethtool_get_stats_count(struct net_device * dev)
@@ -131,27 +134,32 @@ static int libertas_ethtool_get_stats_co
 	wlan_private *priv = dev->priv;
 	struct cmd_ds_mesh_access mesh_access;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ETHTOOL);
+
 	/* Get Mesh Statistics */
 	ret = libertas_prepare_and_send_command(priv,
 			cmd_mesh_access, cmd_act_mesh_get_stats,
 			cmd_option_waitforrsp, 0, &mesh_access);
 
 	if (ret) {
-		LEAVE();
-		return 0;
+		ret = 0;
+		goto done;
 	}
 
-        priv->mstats.fwd_drop_rbt = mesh_access.data[0];
-        priv->mstats.fwd_drop_ttl = mesh_access.data[1];
-        priv->mstats.fwd_drop_noroute = mesh_access.data[2];
-        priv->mstats.fwd_drop_nobuf = mesh_access.data[3];
-        priv->mstats.fwd_unicast_cnt = mesh_access.data[4];
-        priv->mstats.fwd_bcast_cnt = mesh_access.data[5];
-        priv->mstats.drop_blind = mesh_access.data[6];
-
-	LEAVE();
-	return MESH_STATS_NUM;
+        priv->mstats.fwd_drop_rbt = le32_to_cpu(mesh_access.data[0]);
+        priv->mstats.fwd_drop_ttl = le32_to_cpu(mesh_access.data[1]);
+        priv->mstats.fwd_drop_noroute = le32_to_cpu(mesh_access.data[2]);
+        priv->mstats.fwd_drop_nobuf = le32_to_cpu(mesh_access.data[3]);
+        priv->mstats.fwd_unicast_cnt = le32_to_cpu(mesh_access.data[4]);
+        priv->mstats.fwd_bcast_cnt = le32_to_cpu(mesh_access.data[5]);
+        priv->mstats.drop_blind = le32_to_cpu(mesh_access.data[6]);
+        priv->mstats.tx_failed_cnt = le32_to_cpu(mesh_access.data[7]);
+
+	ret = MESH_STATS_NUM;
+
+done:
+	lbs_deb_enter_args(LBS_DEB_ETHTOOL, "ret %d", ret);
+	return ret;
 }
 
 static void libertas_ethtool_get_strings (struct net_device * dev,
@@ -160,7 +168,8 @@ static void libertas_ethtool_get_strings
 {
 	int i;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ETHTOOL);
+
 	switch (stringset) {
         case ETH_SS_STATS:
 		for (i=0; i < MESH_STATS_NUM; i++) {
@@ -170,7 +179,7 @@ static void libertas_ethtool_get_strings
 		}
 		break;
         }
-	LEAVE();
+	lbs_deb_enter(LBS_DEB_ETHTOOL);
 }
 
 struct ethtool_ops libertas_ethtool_ops = {
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/fw.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/fw.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/fw.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/fw.c	2007-06-14 14:14:33.000000000 -0400
@@ -1,28 +1,15 @@
 /**
   * This file contains the initialization for FW and HW
   */
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-
-#include <linux/vmalloc.h>
 #include <linux/firmware.h>
-#include <linux/version.h>
 
 #include "host.h"
-#include "sbi.h"
 #include "defs.h"
 #include "decl.h"
 #include "dev.h"
-#include "fw.h"
 #include "wext.h"
 #include "if_usb.h"
 
-char *libertas_fw_name = NULL;
-module_param_named(fw_name, libertas_fw_name, charp, 0644);
-
-unsigned int libertas_debug = 0;
-module_param(libertas_debug, int, 0);
-
 /**
  *  @brief This function checks the validity of Boot2/FW image.
  *
@@ -32,7 +19,7 @@ module_param(libertas_debug, int, 0);
  */
 static int check_fwfile_format(u8 *data, u32 totlen)
 {
-	u8  bincmd, exit;
+	u32 bincmd, exit;
 	u32 blksize, offset, len;
 	int ret;
 
@@ -40,8 +27,10 @@ static int check_fwfile_format(u8 *data,
 	exit = len = 0;
 
 	do {
-		bincmd = *data;
-		blksize = *(u32*)(data + offsetof(struct fwheader, datalength));
+		struct fwheader *fwh = (void *)data;
+
+		bincmd = le32_to_cpu(fwh->dnldcmd);
+		blksize = le32_to_cpu(fwh->datalength);
 		switch (bincmd) {
 		case FW_HAS_DATA_TO_RECV:
 			offset = sizeof(struct fwheader) + blksize;
@@ -61,9 +50,9 @@ static int check_fwfile_format(u8 *data,
 	} while (!exit);
 
 	if (ret)
-		lbs_pr_err("bin file format check FAIL...\n");
+		lbs_pr_err("firmware file format check FAIL\n");
 	else
-		lbs_pr_debug(1, "bin file format check PASS...\n");
+		lbs_deb_fw("firmware file format check PASS\n");
 
 	return ret;
 }
@@ -76,32 +65,31 @@ static int check_fwfile_format(u8 *data,
  *  @param priv    A pointer to wlan_private structure
  *  @return 	   0 or -1
  */
-static int wlan_setup_station_hw(wlan_private * priv)
+static int wlan_setup_station_hw(wlan_private * priv, char *fw_name)
 {
 	int ret = -1;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_FW);
 
-	if ((ret = request_firmware(&priv->firmware, libertas_fw_name,
+	if ((ret = request_firmware(&priv->firmware, fw_name,
 				    priv->hotplug_device)) < 0) {
-		lbs_pr_err("request_firmware() failed, error code = %#x\n",
-		       ret);
-		lbs_pr_err("%s not found in /lib/firmware\n", libertas_fw_name);
+		lbs_pr_err("request_firmware() failed with %#x\n", ret);
+		lbs_pr_err("firmware %s not found\n", fw_name);
 		goto done;
 	}
 
-	if(check_fwfile_format(priv->firmware->data, priv->firmware->size)) {
+	if (check_fwfile_format(priv->firmware->data, priv->firmware->size)) {
 		release_firmware(priv->firmware);
 		goto done;
 	}
 
-	ret = libertas_sbi_prog_firmware(priv);
+	ret = priv->hw_prog_firmware(priv);
 
 	release_firmware(priv->firmware);
 
 	if (ret) {
-		lbs_pr_debug(1, "Bootloader in invalid state!\n");
+		lbs_deb_fw("bootloader in invalid state\n");
 		ret = -1;
 		goto done;
 	}
@@ -133,28 +121,24 @@ static int wlan_setup_station_hw(wlan_pr
 
 	ret = 0;
 done:
-	LEAVE();
-
-	return (ret);
+	lbs_deb_leave_args(LBS_DEB_FW, "ret %d", ret);
+	return ret;
 }
 
 static int wlan_allocate_adapter(wlan_private * priv)
 {
-	u32 ulbufsize;
+	size_t bufsize;
 	wlan_adapter *adapter = priv->adapter;
 
-	struct bss_descriptor *ptempscantable;
-
 	/* Allocate buffer to store the BSSID list */
-	ulbufsize = sizeof(struct bss_descriptor) * MRVDRV_MAX_BSSID_LIST;
-	if (!(ptempscantable = kmalloc(ulbufsize, GFP_KERNEL))) {
+	bufsize = MAX_NETWORK_COUNT * sizeof(struct bss_descriptor);
+	adapter->networks = kzalloc(bufsize, GFP_KERNEL);
+	if (!adapter->networks) {
+		lbs_pr_err("Out of memory allocating beacons\n");
 		libertas_free_adapter(priv);
-		return -1;
+		return -ENOMEM;
 	}
 
-	adapter->scantable = ptempscantable;
-	memset(adapter->scantable, 0, ulbufsize);
-
 	/* Allocate the command buffers */
 	libertas_allocate_cmd_buffer(priv);
 
@@ -202,15 +186,23 @@ static void wlan_init_adapter(wlan_priva
 	adapter->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
 	adapter->mode = IW_MODE_INFRA;
 
-	adapter->assoc_req = NULL;
+	adapter->pending_assoc_req = NULL;
+	adapter->in_progress_assoc_req = NULL;
+
+	/* Initialize scan result lists */
+	INIT_LIST_HEAD(&adapter->network_free_list);
+	INIT_LIST_HEAD(&adapter->network_list);
+	for (i = 0; i < MAX_NETWORK_COUNT; i++) {
+		list_add_tail(&adapter->networks[i].list,
+			      &adapter->network_free_list);
+	}
 
-	adapter->numinscantable = 0;
-	adapter->pattemptedbssdesc = NULL;
 	mutex_init(&adapter->lock);
 
 	adapter->prescan = 1;
 
 	memset(&adapter->curbssparams, 0, sizeof(adapter->curbssparams));
+	adapter->curbssparams.channel = DEFAULT_AD_HOC_CHANNEL;
 
 	/* PnP and power profile */
 	adapter->surpriseremoved = 0;
@@ -230,8 +222,6 @@ static void wlan_init_adapter(wlan_priva
 	memset(&adapter->capinfo, 0, sizeof(adapter->capinfo));
 	adapter->capinfo.shortpreamble = SHORT_PREAMBLE_ALLOWED;
 
-	adapter->adhocchannel = DEFAULT_AD_HOC_CHANNEL;
-
 	adapter->psmode = wlan802_11powermodecam;
 	adapter->multipledtim = MRVDRV_DEFAULT_MULTIPLE_DTIM;
 
@@ -259,12 +249,12 @@ static void wlan_init_adapter(wlan_priva
 
 static void command_timer_fn(unsigned long data);
 
-int libertas_init_fw(wlan_private * priv)
+int libertas_init_fw(wlan_private * priv, char *fw_name)
 {
 	int ret = -1;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_FW);
 
 	/* Allocate adapter structure */
 	if ((ret = wlan_allocate_adapter(priv)) != 0)
@@ -278,7 +268,7 @@ int libertas_init_fw(wlan_private * priv
 			(unsigned long)priv);
 
 	/* download fimrware etc. */
-	if ((ret = wlan_setup_station_hw(priv)) != 0) {
+	if ((ret = wlan_setup_station_hw(priv, fw_name)) != 0) {
 		del_timer_sync(&adapter->command_timer);
 		goto done;
 	}
@@ -288,7 +278,7 @@ int libertas_init_fw(wlan_private * priv
 
 	ret = 0;
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_FW, "ret %d", ret);
 	return ret;
 }
 
@@ -297,25 +287,22 @@ void libertas_free_adapter(wlan_private 
 	wlan_adapter *adapter = priv->adapter;
 
 	if (!adapter) {
-		lbs_pr_debug(1, "Why double free adapter?:)\n");
+		lbs_deb_fw("why double free adapter?\n");
 		return;
 	}
 
-	lbs_pr_debug(1, "Free command buffer\n");
+	lbs_deb_fw("free command buffer\n");
 	libertas_free_cmd_buffer(priv);
 
-	lbs_pr_debug(1, "Free commandTimer\n");
+	lbs_deb_fw("free command_timer\n");
 	del_timer(&adapter->command_timer);
 
-	lbs_pr_debug(1, "Free scantable\n");
-	if (adapter->scantable) {
-		kfree(adapter->scantable);
-		adapter->scantable = NULL;
-	}
-
-	lbs_pr_debug(1, "Free adapter\n");
+	lbs_deb_fw("free scan results table\n");
+	kfree(adapter->networks);
+	adapter->networks = NULL;
 
 	/* Free the adapter object itself */
+	lbs_deb_fw("free adapter\n");
 	kfree(adapter);
 	priv->adapter = NULL;
 }
@@ -334,17 +321,17 @@ static void command_timer_fn(unsigned lo
 
 	ptempnode = adapter->cur_cmd;
 	if (ptempnode == NULL) {
-		lbs_pr_debug(1, "PTempnode Empty\n");
+		lbs_deb_fw("ptempnode empty\n");
 		return;
 	}
 
 	cmd = (struct cmd_ds_command *)ptempnode->bufvirtualaddr;
 	if (!cmd) {
-		lbs_pr_debug(1, "cmd is NULL\n");
+		lbs_deb_fw("cmd is NULL\n");
 		return;
 	}
 
-	lbs_pr_info("command_timer_fn fired (%x)\n", cmd->command);
+	lbs_deb_fw("command_timer_fn fired, cmd %x\n", cmd->command);
 
 	if (!adapter->fw_ready)
 		return;
@@ -353,7 +340,7 @@ static void command_timer_fn(unsigned lo
 	adapter->cur_cmd = NULL;
 	spin_unlock_irqrestore(&adapter->driver_lock, flags);
 
-	lbs_pr_debug(1, "Re-sending same command as it timeout...!\n");
+	lbs_deb_fw("re-sending same command because of timeout\n");
 	libertas_queue_cmd(adapter, ptempnode, 0);
 
 	wake_up_interruptible(&priv->mainthread.waitq);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/fw.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/fw.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/fw.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/fw.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,13 +0,0 @@
-/**
-  * This header file contains FW interface related definitions.
-  */
-#ifndef _WLAN_FW_H_
-#define _WLAN_FW_H_
-
-#ifndef DEV_NAME_LEN
-#define DEV_NAME_LEN            32
-#endif
-
-int libertas_init_fw(wlan_private * priv);
-
-#endif				/* _WLAN_FW_H_ */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/hostcmd.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/hostcmd.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/hostcmd.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/hostcmd.h	2007-06-14 14:14:33.000000000 -0400
@@ -14,12 +14,12 @@
 /* TxPD descriptor */
 struct txpd {
 	/* Current Tx packet status */
-	u32 tx_status;
+	__le32 tx_status;
 	/* Tx control */
-	u32 tx_control;
-	u32 tx_packet_location;
+	__le32 tx_control;
+	__le32 tx_packet_location;
 	/* Tx packet length */
-	u16 tx_packet_length;
+	__le16 tx_packet_length;
 	/* First 2 byte of destination MAC address */
 	u8 tx_dest_addr_high[2];
 	/* Last 4 byte of destination MAC address */
@@ -37,7 +37,7 @@ struct txpd {
 /* RxPD Descriptor */
 struct rxpd {
 	/* Current Rx packet status */
-	u16 status;
+	__le16 status;
 
 	/* SNR */
 	u8 snr;
@@ -46,7 +46,7 @@ struct rxpd {
 	u8 rx_control;
 
 	/* Pkt length */
-	u16 pkt_len;
+	__le16 pkt_len;
 
 	/* Noise Floor */
 	u8 nf;
@@ -55,10 +55,10 @@ struct rxpd {
 	u8 rx_rate;
 
 	/* Pkt addr */
-	u32 pkt_ptr;
+	__le32 pkt_ptr;
 
 	/* Next Rx RxPD addr */
-	u32 next_rxpd_ptr;
+	__le32 next_rxpd_ptr;
 
 	/* Pkt Priority */
 	u8 priority;
@@ -89,30 +89,17 @@ struct cmd_ctrl_node {
  * is determined from the keylength field.
  */
 struct WLAN_802_11_KEY {
-	u32 len;
-	u32 flags;  /* KEY_INFO_* from wlan_defs.h */
+	__le32 len;
+	__le32 flags;  /* KEY_INFO_* from wlan_defs.h */
 	u8 key[MRVL_MAX_KEY_WPA_KEY_LENGTH];
-	u16 type; /* KEY_TYPE_* from wlan_defs.h */
+	__le16 type; /* KEY_TYPE_* from wlan_defs.h */
 };
 
 struct IE_WPA {
 	u8 elementid;
 	u8 len;
 	u8 oui[4];
-	u16 version;
-};
-
-struct WLAN_802_11_SSID {
-	/* SSID length */
-	u32 ssidlength;
-
-	/* SSID information field */
-	u8 ssid[IW_ESSID_MAX_SIZE];
-};
-
-struct WPA_SUPPLICANT {
-	u8 wpa_ie[256];
-	u8 wpa_ie_len;
+	__le16 version;
 };
 
 /* wlan_offset_value */
@@ -122,9 +109,9 @@ struct wlan_offset_value {
 };
 
 struct WLAN_802_11_FIXED_IEs {
-	u8 timestamp[8];
-	u16 beaconinterval;
-	u16 capabilities;
+	__le64 timestamp;
+	__le16 beaconinterval;
+	u16 capabilities; /* Actually struct ieeetypes_capinfo */
 };
 
 struct WLAN_802_11_VARIABLE_IEs {
@@ -136,10 +123,10 @@ struct WLAN_802_11_VARIABLE_IEs {
 /* Define general data structure */
 /* cmd_DS_GEN */
 struct cmd_ds_gen {
-	u16 command;
-	u16 size;
-	u16 seqnum;
-	u16 result;
+	__le16 command;
+	__le16 size;
+	__le16 seqnum;
+	__le16 result;
 };
 
 #define S_DS_GEN sizeof(struct cmd_ds_gen)
@@ -149,44 +136,44 @@ struct cmd_ds_gen {
  */
 struct cmd_ds_get_hw_spec {
 	/* HW Interface version number */
-	u16 hwifversion;
+	__le16 hwifversion;
 	/* HW version number */
-	u16 version;
+	__le16 version;
 	/* Max number of TxPD FW can handle */
-	u16 nr_txpd;
+	__le16 nr_txpd;
 	/* Max no of Multicast address */
-	u16 nr_mcast_adr;
+	__le16 nr_mcast_adr;
 	/* MAC address */
 	u8 permanentaddr[6];
 
 	/* region Code */
-	u16 regioncode;
+	__le16 regioncode;
 
 	/* Number of antenna used */
-	u16 nr_antenna;
+	__le16 nr_antenna;
 
-	/* FW release number, example 0x1234=1.2.3.4 */
-	u32 fwreleasenumber;
+	/* FW release number, example 1,2,3,4 = 3.2.1p4 */
+	u8 fwreleasenumber[4];
 
 	/* Base Address of TxPD queue */
-	u32 wcb_base;
+	__le32 wcb_base;
 	/* Read Pointer of RxPd queue */
-	u32 rxpd_rdptr;
+	__le32 rxpd_rdptr;
 
 	/* Write Pointer of RxPd queue */
-	u32 rxpd_wrptr;
+	__le32 rxpd_wrptr;
 
 	/*FW/HW capability */
-	u32 fwcapinfo;
+	__le32 fwcapinfo;
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_reset {
-	u16 action;
+	__le16 action;
 };
 
 struct cmd_ds_802_11_subscribe_event {
-	u16 action;
-	u16 events;
+	__le16 action;
+	__le16 events;
 };
 
 /*
@@ -205,35 +192,35 @@ struct cmd_ds_802_11_scan {
 };
 
 struct cmd_ds_802_11_scan_rsp {
-	u16 bssdescriptsize;
+	__le16 bssdescriptsize;
 	u8 nr_sets;
 	u8 bssdesc_and_tlvbuffer[1];
 };
 
 struct cmd_ds_802_11_get_log {
-	u32 mcasttxframe;
-	u32 failed;
-	u32 retry;
-	u32 multiretry;
-	u32 framedup;
-	u32 rtssuccess;
-	u32 rtsfailure;
-	u32 ackfailure;
-	u32 rxfrag;
-	u32 mcastrxframe;
-	u32 fcserror;
-	u32 txframe;
-	u32 wepundecryptable;
+	__le32 mcasttxframe;
+	__le32 failed;
+	__le32 retry;
+	__le32 multiretry;
+	__le32 framedup;
+	__le32 rtssuccess;
+	__le32 rtsfailure;
+	__le32 ackfailure;
+	__le32 rxfrag;
+	__le32 mcastrxframe;
+	__le32 fcserror;
+	__le32 txframe;
+	__le32 wepundecryptable;
 };
 
 struct cmd_ds_mac_control {
-	u16 action;
-	u16 reserved;
+	__le16 action;
+	__le16 reserved;
 };
 
 struct cmd_ds_mac_multicast_adr {
-	u16 action;
-	u16 nr_of_adrs;
+	__le16 action;
+	__le16 nr_of_adrs;
 	u8 maclist[ETH_ALEN * MRVDRV_MAX_MULTICAST_LIST_SIZE];
 };
 
@@ -245,14 +232,14 @@ struct cmd_ds_802_11_authenticate {
 
 struct cmd_ds_802_11_deauthenticate {
 	u8 macaddr[6];
-	u16 reasoncode;
+	__le16 reasoncode;
 };
 
 struct cmd_ds_802_11_associate {
 	u8 peerstaaddr[6];
 	struct ieeetypes_capinfo capinfo;
-	u16 listeninterval;
-	u16 bcnperiod;
+	__le16 listeninterval;
+	__le16 bcnperiod;
 	u8 dtimperiod;
 
 #if 0
@@ -265,7 +252,7 @@ struct cmd_ds_802_11_associate {
 
 struct cmd_ds_802_11_disassociate {
 	u8 destmacaddr[6];
-	u16 reasoncode;
+	__le16 reasoncode;
 };
 
 struct cmd_ds_802_11_associate_rsp {
@@ -279,10 +266,10 @@ struct cmd_ds_802_11_ad_hoc_result {
 
 struct cmd_ds_802_11_set_wep {
 	/* ACT_ADD, ACT_REMOVE or ACT_ENABLE */
-	u16 action;
+	__le16 action;
 
 	/* key Index selected for Tx */
-	u16 keyindex;
+	__le16 keyindex;
 
 	/* 40, 128bit or TXWEP */
 	u8 keytype[4];
@@ -290,96 +277,96 @@ struct cmd_ds_802_11_set_wep {
 };
 
 struct cmd_ds_802_3_get_stat {
-	u32 xmitok;
-	u32 rcvok;
-	u32 xmiterror;
-	u32 rcverror;
-	u32 rcvnobuffer;
-	u32 rcvcrcerror;
+	__le32 xmitok;
+	__le32 rcvok;
+	__le32 xmiterror;
+	__le32 rcverror;
+	__le32 rcvnobuffer;
+	__le32 rcvcrcerror;
 };
 
 struct cmd_ds_802_11_get_stat {
-	u32 txfragmentcnt;
-	u32 mcasttxframecnt;
-	u32 failedcnt;
-	u32 retrycnt;
-	u32 Multipleretrycnt;
-	u32 rtssuccesscnt;
-	u32 rtsfailurecnt;
-	u32 ackfailurecnt;
-	u32 frameduplicatecnt;
-	u32 rxfragmentcnt;
-	u32 mcastrxframecnt;
-	u32 fcserrorcnt;
-	u32 bcasttxframecnt;
-	u32 bcastrxframecnt;
-	u32 txbeacon;
-	u32 rxbeacon;
-	u32 wepundecryptable;
+	__le32 txfragmentcnt;
+	__le32 mcasttxframecnt;
+	__le32 failedcnt;
+	__le32 retrycnt;
+	__le32 Multipleretrycnt;
+	__le32 rtssuccesscnt;
+	__le32 rtsfailurecnt;
+	__le32 ackfailurecnt;
+	__le32 frameduplicatecnt;
+	__le32 rxfragmentcnt;
+	__le32 mcastrxframecnt;
+	__le32 fcserrorcnt;
+	__le32 bcasttxframecnt;
+	__le32 bcastrxframecnt;
+	__le32 txbeacon;
+	__le32 rxbeacon;
+	__le32 wepundecryptable;
 };
 
 struct cmd_ds_802_11_snmp_mib {
-	u16 querytype;
-	u16 oid;
-	u16 bufsize;
+	__le16 querytype;
+	__le16 oid;
+	__le16 bufsize;
 	u8 value[128];
 };
 
 struct cmd_ds_mac_reg_map {
-	u16 buffersize;
+	__le16 buffersize;
 	u8 regmap[128];
-	u16 reserved;
+	__le16 reserved;
 };
 
 struct cmd_ds_bbp_reg_map {
-	u16 buffersize;
+	__le16 buffersize;
 	u8 regmap[128];
-	u16 reserved;
+	__le16 reserved;
 };
 
 struct cmd_ds_rf_reg_map {
-	u16 buffersize;
+	__le16 buffersize;
 	u8 regmap[64];
-	u16 reserved;
+	__le16 reserved;
 };
 
 struct cmd_ds_mac_reg_access {
-	u16 action;
-	u16 offset;
-	u32 value;
+	__le16 action;
+	__le16 offset;
+	__le32 value;
 };
 
 struct cmd_ds_bbp_reg_access {
-	u16 action;
-	u16 offset;
+	__le16 action;
+	__le16 offset;
 	u8 value;
 	u8 reserved[3];
 };
 
 struct cmd_ds_rf_reg_access {
-	u16 action;
-	u16 offset;
+	__le16 action;
+	__le16 offset;
 	u8 value;
 	u8 reserved[3];
 };
 
 struct cmd_ds_802_11_radio_control {
-	u16 action;
-	u16 control;
+	__le16 action;
+	__le16 control;
 };
 
 struct cmd_ds_802_11_sleep_params {
 	/* ACT_GET/ACT_SET */
-	u16 action;
+	__le16 action;
 
 	/* Sleep clock error in ppm */
-	u16 error;
+	__le16 error;
 
 	/* Wakeup offset in usec */
-	u16 offset;
+	__le16 offset;
 
 	/* Clock stabilization time in usec */
-	u16 stabletime;
+	__le16 stabletime;
 
 	/* control periodic calibration */
 	u8 calcontrol;
@@ -388,100 +375,100 @@ struct cmd_ds_802_11_sleep_params {
 	u8 externalsleepclk;
 
 	/* reserved field, should be set to zero */
-	u16 reserved;
+	__le16 reserved;
 };
 
 struct cmd_ds_802_11_inactivity_timeout {
 	/* ACT_GET/ACT_SET */
-	u16 action;
+	__le16 action;
 
 	/* Inactivity timeout in msec */
-	u16 timeout;
+	__le16 timeout;
 };
 
 struct cmd_ds_802_11_rf_channel {
-	u16 action;
-	u16 currentchannel;
-	u16 rftype;
-	u16 reserved;
+	__le16 action;
+	__le16 currentchannel;
+	__le16 rftype;
+	__le16 reserved;
 	u8 channellist[32];
 };
 
 struct cmd_ds_802_11_rssi {
 	/* weighting factor */
-	u16 N;
+	__le16 N;
 
-	u16 reserved_0;
-	u16 reserved_1;
-	u16 reserved_2;
+	__le16 reserved_0;
+	__le16 reserved_1;
+	__le16 reserved_2;
 };
 
 struct cmd_ds_802_11_rssi_rsp {
-	u16 SNR;
-	u16 noisefloor;
-	u16 avgSNR;
-	u16 avgnoisefloor;
+	__le16 SNR;
+	__le16 noisefloor;
+	__le16 avgSNR;
+	__le16 avgnoisefloor;
 };
 
 struct cmd_ds_802_11_mac_address {
-	u16 action;
+	__le16 action;
 	u8 macadd[ETH_ALEN];
 };
 
 struct cmd_ds_802_11_rf_tx_power {
-	u16 action;
-	u16 currentlevel;
+	__le16 action;
+	__le16 currentlevel;
 };
 
 struct cmd_ds_802_11_rf_antenna {
-	u16 action;
+	__le16 action;
 
 	/* Number of antennas or 0xffff(diversity) */
-	u16 antennamode;
+	__le16 antennamode;
 
 };
 
 struct cmd_ds_802_11_ps_mode {
-	u16 action;
-	u16 nullpktinterval;
-	u16 multipledtim;
-	u16 reserved;
-	u16 locallisteninterval;
+	__le16 action;
+	__le16 nullpktinterval;
+	__le16 multipledtim;
+	__le16 reserved;
+	__le16 locallisteninterval;
 };
 
 struct PS_CMD_ConfirmSleep {
-	u16 command;
-	u16 size;
-	u16 seqnum;
-	u16 result;
-
-	u16 action;
-	u16 reserved1;
-	u16 multipledtim;
-	u16 reserved;
-	u16 locallisteninterval;
+	__le16 command;
+	__le16 size;
+	__le16 seqnum;
+	__le16 result;
+
+	__le16 action;
+	__le16 reserved1;
+	__le16 multipledtim;
+	__le16 reserved;
+	__le16 locallisteninterval;
 };
 
 struct cmd_ds_802_11_data_rate {
-	u16 action;
-	u16 reserverd;
+	__le16 action;
+	__le16 reserverd;
 	u8 datarate[G_SUPPORTED_RATES];
 };
 
 struct cmd_ds_802_11_rate_adapt_rateset {
-	u16 action;
-	u16 enablehwauto;
-	u16 bitmap;
+	__le16 action;
+	__le16 enablehwauto;
+	__le16 bitmap;
 };
 
 struct cmd_ds_802_11_ad_hoc_start {
 	u8 SSID[IW_ESSID_MAX_SIZE];
 	u8 bsstype;
-	u16 beaconperiod;
+	__le16 beaconperiod;
 	u8 dtimperiod;
 	union IEEEtypes_ssparamset ssparamset;
 	union ieeetypes_phyparamset phyparamset;
-	u16 probedelay;
+	__le16 probedelay;
 	struct ieeetypes_capinfo cap;
 	u8 datarate[G_SUPPORTED_RATES];
 	u8 tlv_memory_size_pad[100];
@@ -491,10 +478,10 @@ struct adhoc_bssdesc {
 	u8 BSSID[6];
 	u8 SSID[32];
 	u8 bsstype;
-	u16 beaconperiod;
+	__le16 beaconperiod;
 	u8 dtimperiod;
-	u8 timestamp[8];
-	u8 localtime[8];
+	__le64 timestamp;
+	__le64 localtime;
 	union ieeetypes_phyparamset phyparamset;
 	union IEEEtypes_ssparamset ssparamset;
 	struct ieeetypes_capinfo cap;
@@ -508,52 +495,52 @@ struct adhoc_bssdesc {
 
 struct cmd_ds_802_11_ad_hoc_join {
 	struct adhoc_bssdesc bssdescriptor;
-	u16 failtimeout;
-	u16 probedelay;
+	__le16 failtimeout;
+	__le16 probedelay;
 
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_enable_rsn {
-	u16 action;
-	u16 enable;
+	__le16 action;
+	__le16 enable;
 };
 
 struct MrvlIEtype_keyParamSet {
 	/* type ID */
-	u16 type;
+	__le16 type;
 
 	/* length of Payload */
-	u16 length;
+	__le16 length;
 
 	/* type of key: WEP=0, TKIP=1, AES=2 */
-	u16 keytypeid;
+	__le16 keytypeid;
 
 	/* key control Info specific to a keytypeid */
-	u16 keyinfo;
+	__le16 keyinfo;
 
 	/* length of key */
-	u16 keylen;
+	__le16 keylen;
 
 	/* key material of size keylen */
 	u8 key[32];
 };
 
 struct cmd_ds_802_11_key_material {
-	u16 action;
+	__le16 action;
 	struct MrvlIEtype_keyParamSet keyParamSet[2];
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_eeprom_access {
-	u16 action;
+	__le16 action;
 
 	/* multiple 4 */
-	u16 offset;
-	u16 bytecount;
+	__le16 offset;
+	__le16 bytecount;
 	u8 value;
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_tpc_cfg {
-	u16 action;
+	__le16 action;
 	u8 enable;
 	s8 P0;
 	s8 P1;
@@ -562,13 +549,13 @@ struct cmd_ds_802_11_tpc_cfg {
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_led_ctrl {
-	u16 action;
-	u16 numled;
+	__le16 action;
+	__le16 numled;
 	u8 data[256];
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_pwr_cfg {
-	u16 action;
+	__le16 action;
 	u8 enable;
 	s8 PA_P0;
 	s8 PA_P1;
@@ -576,21 +563,21 @@ struct cmd_ds_802_11_pwr_cfg {
 } __attribute__ ((packed));
 
 struct cmd_ds_802_11_afc {
-	u16 afc_auto;
+	__le16 afc_auto;
 	union {
 		struct {
-			u16 threshold;
-			u16 period;
+			__le16 threshold;
+			__le16 period;
 		};
 		struct {
-			s16 timing_offset;
-			s16 carrier_offset;
+			__le16 timing_offset; /* signed */
+			__le16 carrier_offset; /* signed */
 		};
 	};
 } __attribute__ ((packed));
 
 struct cmd_tx_rate_query {
-	u16 txrate;
+	__le16 txrate;
 } __attribute__ ((packed));
 
 struct cmd_ds_get_tsf {
@@ -598,41 +585,46 @@ struct cmd_ds_get_tsf {
 } __attribute__ ((packed));
 
 struct cmd_ds_bt_access {
-	u16 action;
-	u32 id;
+	__le16 action;
+	__le32 id;
 	u8 addr1[ETH_ALEN];
 	u8 addr2[ETH_ALEN];
 } __attribute__ ((packed));
 
 struct cmd_ds_fwt_access {
-	u16 action;
-	u32 id;
+	__le16 action;
+	__le32 id;
+	u8 valid;
 	u8 da[ETH_ALEN];
 	u8 dir;
 	u8 ra[ETH_ALEN];
-	u32 ssn;
-	u32 dsn;
-	u32 metric;
+	__le32 ssn;
+	__le32 dsn;
+	__le32 metric;
+	u8 rate;
 	u8 hopcount;
 	u8 ttl;
-	u32 expiration;
+	__le32 expiration;
 	u8 sleepmode;
-	u32 snr;
-	u32 references;
+	__le32 snr;
+	__le32 references;
+	u8 prec[ETH_ALEN];
 } __attribute__ ((packed));
 
-#define MESH_STATS_NUM 7
 struct cmd_ds_mesh_access {
-	u16 action;
-	u32 data[MESH_STATS_NUM + 1];	/* last position reserved */
+	__le16 action;
+	__le32 data[32];	/* last position reserved */
 } __attribute__ ((packed));
 
+/* Number of stats counters returned by the firmware */
+#define MESH_STATS_NUM 8
+
 struct cmd_ds_command {
 	/* command header */
-	u16 command;
-	u16 size;
-	u16 seqnum;
-	u16 result;
+	__le16 command;
+	__le16 size;
+	__le16 seqnum;
+	__le16 result;
 
 	/* command Body */
 	union {
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/host.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/host.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/host.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/host.h	2007-06-14 14:14:33.000000000 -0400
@@ -99,11 +99,11 @@
 #define cmd_bt_access                 0x0087
 #define cmd_ret_bt_access                 0x8087
 
-#define cmd_fwt_access                0x0088
-#define cmd_ret_fwt_access                0x8088
+#define cmd_fwt_access                0x0095
+#define cmd_ret_fwt_access                0x8095
 
-#define cmd_mesh_access               0x0090
-#define cmd_ret_mesh_access               0x8090
+#define cmd_mesh_access               0x009b
+#define cmd_ret_mesh_access               0x809b
 
 /* For the IEEE Power Save */
 #define cmd_subcmd_enter_ps               0x0030
@@ -287,7 +287,9 @@ enum cmd_bt_access_opts {
 	cmd_act_bt_access_add = 5,
 	cmd_act_bt_access_del,
 	cmd_act_bt_access_list,
-	cmd_act_bt_access_reset
+	cmd_act_bt_access_reset,
+	cmd_act_bt_access_set_invert,
+	cmd_act_bt_access_get_invert
 };
 
 /* Define action or option for cmd_fwt_access */
@@ -308,8 +310,8 @@ enum cmd_mesh_access_opts {
 	cmd_act_mesh_get_ttl = 1,
 	cmd_act_mesh_set_ttl,
 	cmd_act_mesh_get_stats,
-	cmd_act_mesh_get_mpp,
-	cmd_act_mesh_set_mpp,
+	cmd_act_mesh_get_anycast,
+	cmd_act_mesh_set_anycast,
 };
 
 /** Card Event definition */
@@ -334,5 +336,6 @@ enum cmd_mesh_access_opts {
 #define MACREG_INT_CODE_MAX_FAIL		0x0000001b
 #define MACREG_INT_CODE_RSSI_HIGH		0x0000001c
 #define MACREG_INT_CODE_SNR_HIGH		0x0000001d
+#define MACREG_INT_CODE_MESH_AUTO_STARTED	0x00000023
 
 #endif				/* _HOST_H_ */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_bootcmd.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_bootcmd.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_bootcmd.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_bootcmd.c	2007-06-14 14:14:33.000000000 -0400
@@ -8,6 +8,8 @@
 #include <linux/netdevice.h>
 #include <linux/usb.h>
 
+#define DRV_NAME "usb8xxx"
+
 #include "defs.h"
 #include "dev.h"
 #include "if_usb.h"
@@ -20,12 +22,12 @@
  */
 int if_usb_issue_boot_command(wlan_private *priv, int ivalue)
 {
-	struct usb_card_rec	*cardp = priv->wlan_dev.card;
+	struct usb_card_rec	*cardp = priv->card;
 	struct bootcmdstr	sbootcmd;
 	int i;
 
 	/* Prepare command */
-	sbootcmd.u32magicnumber = BOOT_CMD_MAGIC_NUMBER;
+	sbootcmd.u32magicnumber = cpu_to_le32(BOOT_CMD_MAGIC_NUMBER);
 	sbootcmd.u8cmd_tag = ivalue;
 	for (i=0; i<11; i++)
 		sbootcmd.au8dumy[i]=0x00;
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_usb.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_usb.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_usb.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_usb.c	2007-06-14 14:14:33.000000000 -0400
@@ -2,12 +2,15 @@
   * This file contains functions used in USB interface module.
   */
 #include <linux/delay.h>
+#include <linux/moduleparam.h>
 #include <linux/firmware.h>
 #include <linux/netdevice.h>
+#include <linux/list.h>
 #include <linux/usb.h>
 
+#define DRV_NAME "usb8xxx"
+
 #include "host.h"
-#include "sbi.h"
 #include "decl.h"
 #include "defs.h"
 #include "dev.h"
@@ -16,15 +19,24 @@
 #define MESSAGE_HEADER_LEN	4
 
 static const char usbdriver_name[] = "usb8xxx";
+static u8 *default_fw_name = "usb8388.bin";
+
+char *libertas_fw_name = NULL;
+module_param_named(fw_name, libertas_fw_name, charp, 0644);
+
+/*
+ * We need to send a RESET command to all USB devices before
+ * we tear down the USB connection. Otherwise we would not
+ * be able to re-init device the device if the module gets
+ * loaded again. This is a list of all initialized USB devices,
+ * for the reset code see if_usb_reset_device()
+*/
+static LIST_HEAD(usb_devices);
 
 static struct usb_device_id if_usb_table[] = {
 	/* Enter the device signature inside */
-	{
-		USB_DEVICE(USB8388_VID_1, USB8388_PID_1),
-	},
-	{
-		USB_DEVICE(USB8388_VID_2, USB8388_PID_2),
-	},
+	{ USB_DEVICE(0x1286, 0x2001) },
+	{ USB_DEVICE(0x05a3, 0x8388) },
 	{}	/* Terminating entry */
 };
 
@@ -32,6 +44,13 @@ MODULE_DEVICE_TABLE(usb, if_usb_table);
 
 static void if_usb_receive(struct urb *urb);
 static void if_usb_receive_fwload(struct urb *urb);
+static int if_usb_reset_device(wlan_private *priv);
+static int if_usb_register_dev(wlan_private * priv);
+static int if_usb_unregister_dev(wlan_private *);
+static int if_usb_prog_firmware(wlan_private *);
+static int if_usb_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
+static int if_usb_get_int_status(wlan_private * priv, u8 *);
+static int if_usb_read_event_cause(wlan_private *);
 
 /**
  *  @brief  call back function to handle the status of the URB
@@ -42,23 +61,27 @@ static void if_usb_write_bulk_callback(s
 {
 	wlan_private *priv = (wlan_private *) (urb->context);
 	wlan_adapter *adapter = priv->adapter;
-	struct net_device *dev = priv->wlan_dev.netdev;
+	struct net_device *dev = priv->dev;
 
 	/* handle the transmission complete validations */
 
 	if (urb->status != 0) {
 		/* print the failure status number for debug */
-		lbs_pr_info("URB in failure status\n");
+		lbs_pr_info("URB in failure status: %d\n", urb->status);
 	} else {
-		lbs_dev_dbg(2, &urb->dev->dev, "URB status is successfull\n");
-		lbs_dev_dbg(2, &urb->dev->dev, "Actual length transmitted %d\n",
+		/*
+		lbs_deb_usbd(&urb->dev->dev, "URB status is successfull\n");
+		lbs_deb_usbd(&urb->dev->dev, "Actual length transmitted %d\n",
 		       urb->actual_length);
-		priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+		*/
+		priv->dnld_sent = DNLD_RES_RECEIVED;
 		/* Wake main thread if commands are pending */
 		if (!adapter->cur_cmd)
 			wake_up_interruptible(&priv->mainthread.waitq);
-		if ((adapter->connect_status == libertas_connected))
+		if ((adapter->connect_status == libertas_connected)) {
 			netif_wake_queue(dev);
+			netif_wake_queue(priv->mesh_dev);
+		}
 	}
 
 	return;
@@ -71,7 +94,7 @@ static void if_usb_write_bulk_callback(s
  */
 void if_usb_free(struct usb_card_rec *cardp)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	/* Unlink tx & rx urb */
 	usb_kill_urb(cardp->tx_urb);
@@ -86,8 +109,7 @@ void if_usb_free(struct usb_card_rec *ca
 	kfree(cardp->bulk_out_buffer);
 	cardp->bulk_out_buffer = NULL;
 
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_USB);
 }
 
 /**
@@ -102,27 +124,27 @@ static int if_usb_probe(struct usb_inter
 	struct usb_device *udev;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor *endpoint;
-	wlan_private *pwlanpriv;
-	struct usb_card_rec *usb_cardp;
+	wlan_private *priv;
+	struct usb_card_rec *cardp;
 	int i;
 
 	udev = interface_to_usbdev(intf);
 
-	usb_cardp = kzalloc(sizeof(struct usb_card_rec), GFP_KERNEL);
-	if (!usb_cardp) {
+	cardp = kzalloc(sizeof(struct usb_card_rec), GFP_KERNEL);
+	if (!cardp) {
 		lbs_pr_err("Out of memory allocating private data.\n");
 		goto error;
 	}
 
-	usb_cardp->udev = udev;
+	cardp->udev = udev;
 	iface_desc = intf->cur_altsetting;
 
-	lbs_dev_dbg(1, &udev->dev, "bcdUSB = 0x%X bDeviceClass = 0x%X"
+	lbs_deb_usbd(&udev->dev, "bcdUSB = 0x%X bDeviceClass = 0x%X"
 	       " bDeviceSubClass = 0x%X, bDeviceProtocol = 0x%X\n",
-	       udev->descriptor.bcdUSB,
-	       udev->descriptor.bDeviceClass,
-	       udev->descriptor.bDeviceSubClass,
-	       udev->descriptor.bDeviceProtocol);
+		     le16_to_cpu(udev->descriptor.bcdUSB),
+		     udev->descriptor.bDeviceClass,
+		     udev->descriptor.bDeviceSubClass,
+		     udev->descriptor.bDeviceProtocol);
 
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;
@@ -130,23 +152,21 @@ static int if_usb_probe(struct usb_inter
 		    && ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 			USB_ENDPOINT_XFER_BULK)) {
 			/* we found a bulk in endpoint */
-			lbs_dev_dbg(1, &udev->dev, "Bulk in size is %d\n",
-			       endpoint->wMaxPacketSize);
-			if (!
-			    (usb_cardp->rx_urb =
-			     usb_alloc_urb(0, GFP_KERNEL))) {
-				lbs_dev_dbg(1, &udev->dev,
+			lbs_deb_usbd(&udev->dev, "Bulk in size is %d\n",
+				     le16_to_cpu(endpoint->wMaxPacketSize));
+			if (!(cardp->rx_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+				lbs_deb_usbd(&udev->dev,
 				       "Rx URB allocation failed\n");
 				goto dealloc;
 			}
-			usb_cardp->rx_urb_recall = 0;
+			cardp->rx_urb_recall = 0;
 
-			usb_cardp->bulk_in_size =
-			    endpoint->wMaxPacketSize;
-			usb_cardp->bulk_in_endpointAddr =
+			cardp->bulk_in_size =
+				le16_to_cpu(endpoint->wMaxPacketSize);
+			cardp->bulk_in_endpointAddr =
 			    (endpoint->
 			     bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-			lbs_dev_dbg(1, &udev->dev, "in_endpoint = %d\n",
+			lbs_deb_usbd(&udev->dev, "in_endpoint = %d\n",
 			       endpoint->bEndpointAddress);
 		}
 
@@ -156,55 +176,63 @@ static int if_usb_probe(struct usb_inter
 		    && ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 			USB_ENDPOINT_XFER_BULK)) {
 			/* We found bulk out endpoint */
-			if (!
-			    (usb_cardp->tx_urb =
-			     usb_alloc_urb(0, GFP_KERNEL))) {
-				lbs_dev_dbg(1,&udev->dev,
+			if (!(cardp->tx_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+				lbs_deb_usbd(&udev->dev,
 				       "Tx URB allocation failed\n");
 				goto dealloc;
 			}
 
-			usb_cardp->bulk_out_size =
-			    endpoint->wMaxPacketSize;
-			lbs_dev_dbg(1, &udev->dev,
-				    "Bulk out size is %d\n",
-				    endpoint->wMaxPacketSize);
-			usb_cardp->bulk_out_endpointAddr =
+			cardp->bulk_out_size =
+				le16_to_cpu(endpoint->wMaxPacketSize);
+			lbs_deb_usbd(&udev->dev,
+				     "Bulk out size is %d\n",
+				     le16_to_cpu(endpoint->wMaxPacketSize));
+			cardp->bulk_out_endpointAddr =
 			    endpoint->bEndpointAddress;
-			lbs_dev_dbg(1, &udev->dev, "out_endpoint = %d\n",
+			lbs_deb_usbd(&udev->dev, "out_endpoint = %d\n",
 				    endpoint->bEndpointAddress);
-			usb_cardp->bulk_out_buffer =
+			cardp->bulk_out_buffer =
 			    kmalloc(MRVDRV_ETH_TX_PACKET_BUFFER_SIZE,
 				    GFP_KERNEL);
 
-			if (!usb_cardp->bulk_out_buffer) {
-				lbs_dev_dbg(1, &udev->dev,
+			if (!cardp->bulk_out_buffer) {
+				lbs_deb_usbd(&udev->dev,
 				       "Could not allocate buffer\n");
 				goto dealloc;
 			}
 		}
 	}
 
-
-	/* At this point wlan_add_card() will be called.  Don't worry
-	 * about keeping pwlanpriv around since it will be set on our
-	 * usb device data in -> add() -> libertas_sbi_register_dev().
-	 */
-	if (!(pwlanpriv = wlan_add_card(usb_cardp)))
+	if (!(priv = libertas_add_card(cardp, &udev->dev)))
 		goto dealloc;
 
+	if (libertas_add_mesh(priv, &udev->dev))
+		goto err_add_mesh;
+
+	priv->hw_register_dev = if_usb_register_dev;
+	priv->hw_unregister_dev = if_usb_unregister_dev;
+	priv->hw_prog_firmware = if_usb_prog_firmware;
+	priv->hw_host_to_card = if_usb_host_to_card;
+	priv->hw_get_int_status = if_usb_get_int_status;
+	priv->hw_read_event_cause = if_usb_read_event_cause;
+
+	if (libertas_activate_card(priv, libertas_fw_name))
+		goto err_activate_card;
+
+	list_add_tail(&cardp->list, &usb_devices);
+
 	usb_get_dev(udev);
-	usb_set_intfdata(intf, usb_cardp);
+	usb_set_intfdata(intf, cardp);
 
-	/*
-	 * return card structure, which can be got back in the
-	 * diconnect function as the ptr
-	 * argument.
-	 */
 	return 0;
 
+err_activate_card:
+	libertas_remove_mesh(priv);
+err_add_mesh:
+	free_netdev(priv->dev);
+	kfree(priv->adapter);
 dealloc:
-	if_usb_free(usb_cardp);
+	if_usb_free(cardp);
 
 error:
 	return -ENOMEM;
@@ -212,8 +240,7 @@ error:
 
 /**
  *  @brief free resource and cleanup
- *  @param udev		pointer to usb_device
- *  @param ptr		pointer to usb_cardp
+ *  @param intf		USB interface structure
  *  @return 	   	N/A
  */
 static void if_usb_disconnect(struct usb_interface *intf)
@@ -229,9 +256,12 @@ static void if_usb_disconnect(struct usb
 	 */
 	adapter->surpriseremoved = 1;
 
+	list_del(&cardp->list);
+
 	/* card is removed and we can call wlan_remove_card */
-	lbs_dev_dbg(1, &cardp->udev->dev, "call remove card\n");
-	wlan_remove_card(cardp);
+	lbs_deb_usbd(&cardp->udev->dev, "call remove card\n");
+	libertas_remove_mesh(priv);
+	libertas_remove_card(priv);
 
 	/* Unlink and free urb */
 	if_usb_free(cardp);
@@ -249,7 +279,7 @@ static void if_usb_disconnect(struct usb
  */
 static int if_prog_firmware(wlan_private * priv)
 {
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 	struct FWData *fwdata;
 	struct fwheader *fwheader;
 	u8 *firmware = priv->firmware->data;
@@ -266,8 +296,10 @@ static int if_prog_firmware(wlan_private
 		cardp->fwseqnum = cardp->lastseqnum - 1;
 	}
 
-	lbs_dev_dbg(2, &cardp->udev->dev, "totalbytes = %d\n",
+	/*
+	lbs_deb_usbd(&cardp->udev->dev, "totalbytes = %d\n",
 		    cardp->totalbytes);
+	*/
 
 	memcpy(fwheader, &firmware[cardp->totalbytes],
 	       sizeof(struct fwheader));
@@ -275,40 +307,48 @@ static int if_prog_firmware(wlan_private
 	cardp->fwlastblksent = cardp->totalbytes;
 	cardp->totalbytes += sizeof(struct fwheader);
 
-	lbs_dev_dbg(2, &cardp->udev->dev,"Copy Data\n");
+	/* lbs_deb_usbd(&cardp->udev->dev,"Copy Data\n"); */
 	memcpy(fwdata->data, &firmware[cardp->totalbytes],
-	       fwdata->fwheader.datalength);
+	       le32_to_cpu(fwdata->fwheader.datalength));
 
-	lbs_dev_dbg(2, &cardp->udev->dev,
-		    "Data length = %d\n", fwdata->fwheader.datalength);
+	/*
+	lbs_deb_usbd(&cardp->udev->dev,
+		    "Data length = %d\n", le32_to_cpu(fwdata->fwheader.datalength));
+	*/
 
 	cardp->fwseqnum = cardp->fwseqnum + 1;
 
-	fwdata->seqnum = cardp->fwseqnum;
-	cardp->lastseqnum = fwdata->seqnum;
-	cardp->totalbytes += fwdata->fwheader.datalength;
-
-	if (fwheader->dnldcmd == FW_HAS_DATA_TO_RECV) {
-		lbs_dev_dbg(2, &cardp->udev->dev, "There is data to follow\n");
-		lbs_dev_dbg(2, &cardp->udev->dev,
+	fwdata->seqnum = cpu_to_le32(cardp->fwseqnum);
+	cardp->lastseqnum = cardp->fwseqnum;
+	cardp->totalbytes += le32_to_cpu(fwdata->fwheader.datalength);
+
+	if (fwheader->dnldcmd == cpu_to_le32(FW_HAS_DATA_TO_RECV)) {
+		/*
+		lbs_deb_usbd(&cardp->udev->dev, "There are data to follow\n");
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "seqnum = %d totalbytes = %d\n", cardp->fwseqnum,
 			    cardp->totalbytes);
+		*/
 		memcpy(cardp->bulk_out_buffer, fwheader, FW_DATA_XMIT_SIZE);
 		usb_tx_block(priv, cardp->bulk_out_buffer, FW_DATA_XMIT_SIZE);
 
-	} else if (fwdata->fwheader.dnldcmd == FW_HAS_LAST_BLOCK) {
-		lbs_dev_dbg(2, &cardp->udev->dev,
+	} else if (fwdata->fwheader.dnldcmd == cpu_to_le32(FW_HAS_LAST_BLOCK)) {
+		/*
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Host has finished FW downloading\n");
-		lbs_dev_dbg(2, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Donwloading FW JUMP BLOCK\n");
+		*/
 		memcpy(cardp->bulk_out_buffer, fwheader, FW_DATA_XMIT_SIZE);
 		usb_tx_block(priv, cardp->bulk_out_buffer, FW_DATA_XMIT_SIZE);
 		cardp->fwfinalblk = 1;
 	}
 
-	lbs_dev_dbg(2, &cardp->udev->dev,
+	/*
+	lbs_deb_usbd(&cardp->udev->dev,
 		    "The firmware download is done size is %d\n",
 		    cardp->totalbytes);
+	*/
 
 	kfree(fwdata);
 
@@ -318,14 +358,19 @@ static int if_prog_firmware(wlan_private
 static int libertas_do_reset(wlan_private *priv)
 {
 	int ret;
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
+
+	lbs_deb_enter(LBS_DEB_USB);
 
 	ret = usb_reset_device(cardp->udev);
 	if (!ret) {
 		msleep(10);
-		reset_device(priv);
+		if_usb_reset_device(priv);
 		msleep(10);
 	}
+
+	lbs_deb_leave_args(LBS_DEB_USB, "ret %d", ret);
+
 	return ret;
 }
 
@@ -339,12 +384,12 @@ static int libertas_do_reset(wlan_privat
 int usb_tx_block(wlan_private * priv, u8 * payload, u16 nb)
 {
 	/* pointer to card structure */
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 	int ret = -1;
 
 	/* check if device is removed */
 	if (priv->adapter->surpriseremoved) {
-		lbs_dev_dbg(1, &cardp->udev->dev, "Device removed\n");
+		lbs_deb_usbd(&cardp->udev->dev, "Device removed\n");
 		goto tx_ret;
 	}
 
@@ -357,10 +402,10 @@ int usb_tx_block(wlan_private * priv, u8
 
 	if ((ret = usb_submit_urb(cardp->tx_urb, GFP_ATOMIC))) {
 		/*  transfer failed */
-		lbs_dev_dbg(1, &cardp->udev->dev, "usb_submit_urb failed\n");
+		lbs_deb_usbd(&cardp->udev->dev, "usb_submit_urb failed\n");
 		ret = -1;
 	} else {
-		lbs_dev_dbg(2, &cardp->udev->dev, "usb_submit_urb success\n");
+		/* lbs_deb_usbd(&cardp->udev->dev, "usb_submit_urb success\n"); */
 		ret = 0;
 	}
 
@@ -372,7 +417,7 @@ static int __if_usb_submit_rx_urb(wlan_p
 				  void (*callbackfn)
 				  (struct urb *urb))
 {
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 	struct sk_buff *skb;
 	struct read_cb_info *rinfo = &cardp->rinfo;
 	int ret = -1;
@@ -394,13 +439,13 @@ static int __if_usb_submit_rx_urb(wlan_p
 
 	cardp->rx_urb->transfer_flags |= URB_ZERO_PACKET;
 
-	lbs_dev_dbg(2, &cardp->udev->dev, "Pointer for rx_urb %p\n", cardp->rx_urb);
+	/* lbs_deb_usbd(&cardp->udev->dev, "Pointer for rx_urb %p\n", cardp->rx_urb); */
 	if ((ret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC))) {
 		/* handle failure conditions */
-		lbs_dev_dbg(1, &cardp->udev->dev, "Submit Rx URB failed\n");
+		lbs_deb_usbd(&cardp->udev->dev, "Submit Rx URB failed\n");
 		ret = -1;
 	} else {
-		lbs_dev_dbg(2, &cardp->udev->dev, "Submit Rx URB success\n");
+		/* lbs_deb_usbd(&cardp->udev->dev, "Submit Rx URB success\n"); */
 		ret = 0;
 	}
 
@@ -423,12 +468,12 @@ static void if_usb_receive_fwload(struct
 	struct read_cb_info *rinfo = (struct read_cb_info *)urb->context;
 	wlan_private *priv = rinfo->priv;
 	struct sk_buff *skb = rinfo->skb;
-	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->wlan_dev.card;
+	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->card;
 	struct fwsyncheader *syncfwheader;
 	struct bootcmdrespStr bootcmdresp;
 
 	if (urb->status) {
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "URB status is failed during fw load\n");
 		kfree_skb(skb);
 		return;
@@ -437,18 +482,18 @@ static void if_usb_receive_fwload(struct
 	if (cardp->bootcmdresp == 0) {
 		memcpy (&bootcmdresp, skb->data + IPFIELD_ALIGN_OFFSET,
 			sizeof(bootcmdresp));
-		if (cardp->udev->descriptor.bcdDevice < 0x3106) {
+		if (le16_to_cpu(cardp->udev->descriptor.bcdDevice) < 0x3106) {
 			kfree_skb(skb);
 			if_usb_submit_rx_urb_fwload(priv);
 			cardp->bootcmdresp = 1;
-			lbs_dev_dbg(1, &cardp->udev->dev,
+			lbs_deb_usbd(&cardp->udev->dev,
 				    "Received valid boot command response\n");
 			return;
 		}
-		if (bootcmdresp.u32magicnumber != BOOT_CMD_MAGIC_NUMBER) {
+		if (bootcmdresp.u32magicnumber != cpu_to_le32(BOOT_CMD_MAGIC_NUMBER)) {
 			lbs_pr_info(
 				"boot cmd response wrong magic number (0x%x)\n",
-				bootcmdresp.u32magicnumber);
+				le32_to_cpu(bootcmdresp.u32magicnumber));
 		} else if (bootcmdresp.u8cmd_tag != BOOT_CMD_FW_BY_USB) {
 			lbs_pr_info(
 				"boot cmd response cmd_tag error (%d)\n",
@@ -459,7 +504,7 @@ static void if_usb_receive_fwload(struct
 				bootcmdresp.u8result);
 		} else {
 			cardp->bootcmdresp = 1;
-			lbs_dev_dbg(1, &cardp->udev->dev,
+			lbs_deb_usbd(&cardp->udev->dev,
 				    "Received valid boot command response\n");
 		}
 		kfree_skb(skb);
@@ -469,7 +514,7 @@ static void if_usb_receive_fwload(struct
 
 	syncfwheader = kmalloc(sizeof(struct fwsyncheader), GFP_ATOMIC);
 	if (!syncfwheader) {
-		lbs_dev_dbg(1, &cardp->udev->dev, "Failure to allocate syncfwheader\n");
+		lbs_deb_usbd(&cardp->udev->dev, "Failure to allocate syncfwheader\n");
 		kfree_skb(skb);
 		return;
 	}
@@ -478,14 +523,16 @@ static void if_usb_receive_fwload(struct
 			sizeof(struct fwsyncheader));
 
 	if (!syncfwheader->cmd) {
-		lbs_dev_dbg(2, &cardp->udev->dev,
+		/*
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "FW received Blk with correct CRC\n");
-		lbs_dev_dbg(2, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "FW received Blk seqnum = %d\n",
 		       syncfwheader->seqnum);
+		*/
 		cardp->CRC_OK = 1;
 	} else {
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "FW received Blk with CRC error\n");
 		cardp->CRC_OK = 0;
 	}
@@ -515,7 +562,7 @@ static inline void process_cmdtypedata(i
 {
 	if (recvlength > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE +
 	    MESSAGE_HEADER_LEN || recvlength < MRVDRV_MIN_PKT_LEN) {
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Packet length is Invalid\n");
 		kfree_skb(skb);
 		return;
@@ -525,7 +572,7 @@ static inline void process_cmdtypedata(i
 	skb_put(skb, recvlength);
 	skb_pull(skb, MESSAGE_HEADER_LEN);
 	libertas_process_rxed_packet(priv, skb);
-	priv->wlan_dev.upld_len = (recvlength - MESSAGE_HEADER_LEN);
+	priv->upld_len = (recvlength - MESSAGE_HEADER_LEN);
 }
 
 static inline void process_cmdrequest(int recvlength, u8 *recvbuff,
@@ -535,7 +582,7 @@ static inline void process_cmdrequest(in
 {
 	u8 *cmdbuf;
 	if (recvlength > MRVDRV_SIZE_OF_CMD_BUFFER) {
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "The receive buffer is too large\n");
 		kfree_skb(skb);
 		return;
@@ -548,21 +595,21 @@ static inline void process_cmdrequest(in
 	/* take care of cur_cmd = NULL case by reading the
 	 * data to clear the interrupt */
 	if (!priv->adapter->cur_cmd) {
-		cmdbuf = priv->wlan_dev.upld_buf;
+		cmdbuf = priv->upld_buf;
 		priv->adapter->hisregcpy &= ~his_cmdupldrdy;
 	} else
 		cmdbuf = priv->adapter->cur_cmd->bufvirtualaddr;
 
 	cardp->usb_int_cause |= his_cmdupldrdy;
-	priv->wlan_dev.upld_len = (recvlength - MESSAGE_HEADER_LEN);
+	priv->upld_len = (recvlength - MESSAGE_HEADER_LEN);
 	memcpy(cmdbuf, recvbuff + MESSAGE_HEADER_LEN,
-	       priv->wlan_dev.upld_len);
+	       priv->upld_len);
 
 	kfree_skb(skb);
-	libertas_interrupt(priv->wlan_dev.netdev);
+	libertas_interrupt(priv->dev);
 	spin_unlock(&priv->adapter->driver_lock);
 
-	lbs_dev_dbg(1, &cardp->udev->dev,
+	lbs_deb_usbd(&cardp->udev->dev,
 		    "Wake up main thread to handle cmd response\n");
 
 	return;
@@ -580,17 +627,17 @@ static void if_usb_receive(struct urb *u
 	struct read_cb_info *rinfo = (struct read_cb_info *)urb->context;
 	wlan_private *priv = rinfo->priv;
 	struct sk_buff *skb = rinfo->skb;
-	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->wlan_dev.card;
+	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->card;
 
 	int recvlength = urb->actual_length;
 	u8 *recvbuff = NULL;
 	u32 recvtype;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	if (recvlength) {
 		if (urb->status) {
-			lbs_dev_dbg(1, &cardp->udev->dev,
+			lbs_deb_usbd(&cardp->udev->dev,
 				    "URB status is failed\n");
 			kfree_skb(skb);
 			goto setup_for_next;
@@ -598,12 +645,12 @@ static void if_usb_receive(struct urb *u
 
 		recvbuff = skb->data + IPFIELD_ALIGN_OFFSET;
 		memcpy(&recvtype, recvbuff, sizeof(u32));
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Recv length = 0x%x\n", recvlength);
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Receive type = 0x%X\n", recvtype);
 		recvtype = le32_to_cpu(recvtype);
-		lbs_dev_dbg(1, &cardp->udev->dev,
+		lbs_deb_usbd(&cardp->udev->dev,
 			    "Receive type after = 0x%X\n", recvtype);
 	} else if (urb->status)
 		goto rx_exit;
@@ -621,18 +668,18 @@ static void if_usb_receive(struct urb *u
 	case CMD_TYPE_INDICATION:
 		/* Event cause handling */
 		spin_lock(&priv->adapter->driver_lock);
-		cardp->usb_event_cause = *(u32 *) (recvbuff + MESSAGE_HEADER_LEN);
-		lbs_dev_dbg(1, &cardp->udev->dev,"**EVENT** 0x%X\n",
+		cardp->usb_event_cause = le32_to_cpu(*(__le32 *) (recvbuff + MESSAGE_HEADER_LEN));
+		lbs_deb_usbd(&cardp->udev->dev,"**EVENT** 0x%X\n",
 			    cardp->usb_event_cause);
 		if (cardp->usb_event_cause & 0xffff0000) {
 			libertas_send_tx_feedback(priv);
 			spin_unlock(&priv->adapter->driver_lock);
 			break;
 		}
-		cardp->usb_event_cause = le32_to_cpu(cardp->usb_event_cause) << 3;
+		cardp->usb_event_cause <<= 3;
 		cardp->usb_int_cause |= his_cardevent;
 		kfree_skb(skb);
-		libertas_interrupt(priv->wlan_dev.netdev);
+		libertas_interrupt(priv->dev);
 		spin_unlock(&priv->adapter->driver_lock);
 		goto rx_exit;
 	default:
@@ -643,8 +690,7 @@ static void if_usb_receive(struct urb *u
 setup_for_next:
 	if_usb_submit_rx_urb(priv);
 rx_exit:
-	LEAVE();
-	return;
+	lbs_deb_leave(LBS_DEB_USB);
 }
 
 /**
@@ -655,24 +701,24 @@ rx_exit:
  *  @param len		number of bytes
  *  @return 	   	0 or -1
  */
-int libertas_sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb)
+static int if_usb_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb)
 {
 	int ret = -1;
 	u32 tmp;
-	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->wlan_dev.card;
+	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->card;
 
-	lbs_dev_dbg(1, &cardp->udev->dev,"*** type = %u\n", type);
-	lbs_dev_dbg(1, &cardp->udev->dev,"size after = %d\n", nb);
+	lbs_deb_usbd(&cardp->udev->dev,"*** type = %u\n", type);
+	lbs_deb_usbd(&cardp->udev->dev,"size after = %d\n", nb);
 
 	if (type == MVMS_CMD) {
 		tmp = cpu_to_le32(CMD_TYPE_REQUEST);
-		priv->wlan_dev.dnld_sent = DNLD_CMD_SENT;
+		priv->dnld_sent = DNLD_CMD_SENT;
 		memcpy(cardp->bulk_out_buffer, (u8 *) & tmp,
 		       MESSAGE_HEADER_LEN);
 
 	} else {
 		tmp = cpu_to_le32(CMD_TYPE_DATA);
-		priv->wlan_dev.dnld_sent = DNLD_DATA_SENT;
+		priv->dnld_sent = DNLD_DATA_SENT;
 		memcpy(cardp->bulk_out_buffer, (u8 *) & tmp,
 		       MESSAGE_HEADER_LEN);
 	}
@@ -686,39 +732,41 @@ int libertas_sbi_host_to_card(wlan_priva
 }
 
 /* called with adapter->driver_lock held */
-int libertas_sbi_get_int_status(wlan_private * priv, u8 * ireg)
+static int if_usb_get_int_status(wlan_private * priv, u8 * ireg)
 {
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 
 	*ireg = cardp->usb_int_cause;
 	cardp->usb_int_cause = 0;
 
-	lbs_dev_dbg(1, &cardp->udev->dev,"Int cause is 0x%X\n", *ireg);
+	lbs_deb_usbd(&cardp->udev->dev,"Int cause is 0x%X\n", *ireg);
 
 	return 0;
 }
 
-int libertas_sbi_read_event_cause(wlan_private * priv)
+static int if_usb_read_event_cause(wlan_private * priv)
 {
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 	priv->adapter->eventcause = cardp->usb_event_cause;
 	/* Re-submit rx urb here to avoid event lost issue */
 	if_usb_submit_rx_urb(priv);
 	return 0;
 }
 
-int reset_device(wlan_private *priv)
+static int if_usb_reset_device(wlan_private *priv)
 {
 	int ret;
 
+	lbs_deb_enter(LBS_DEB_USB);
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_reset,
 				    cmd_act_halt, 0, 0, NULL);
 	msleep_interruptible(10);
 
+	lbs_deb_leave_args(LBS_DEB_USB, "ret %d", ret);
 	return ret;
 }
 
-int libertas_sbi_unregister_dev(wlan_private * priv)
+static int if_usb_unregister_dev(wlan_private * priv)
 {
 	int ret = 0;
 
@@ -727,7 +775,7 @@ int libertas_sbi_unregister_dev(wlan_pri
 	 * again.
 	 */
 	if (priv)
-		reset_device(priv);
+		if_usb_reset_device(priv);
 
 	return ret;
 }
@@ -738,42 +786,41 @@ int libertas_sbi_unregister_dev(wlan_pri
  *  @param		priv pointer to wlan_private
  *  @return		0 or -1
  */
-int libertas_sbi_register_dev(wlan_private * priv)
+static int if_usb_register_dev(wlan_private * priv)
 {
+	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->card;
 
-	struct usb_card_rec *cardp = (struct usb_card_rec *)priv->wlan_dev.card;
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	cardp->priv = priv;
-	cardp->eth_dev = priv->wlan_dev.netdev;
+	cardp->eth_dev = priv->dev;
 	priv->hotplug_device = &(cardp->udev->dev);
 
-	SET_NETDEV_DEV(cardp->eth_dev, &(cardp->udev->dev));
-
-	lbs_dev_dbg(1, &cardp->udev->dev, "udev pointer is at %p\n",
+	lbs_deb_usbd(&cardp->udev->dev, "udev pointer is at %p\n",
 		    cardp->udev);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_USB);
 	return 0;
 }
 
 
 
-int libertas_sbi_prog_firmware(wlan_private * priv)
+static int if_usb_prog_firmware(wlan_private * priv)
 {
-	struct usb_card_rec *cardp = priv->wlan_dev.card;
+	struct usb_card_rec *cardp = priv->card;
 	int i = 0;
 	static int reset_count = 10;
+	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	cardp->rinfo.priv = priv;
 
 restart:
 	if (if_usb_submit_rx_urb_fwload(priv) < 0) {
-		lbs_dev_dbg(1, &cardp->udev->dev, "URB submission is failed\n");
-		LEAVE();
-		return -1;
+		lbs_deb_usbd(&cardp->udev->dev, "URB submission is failed\n");
+		ret = -1;
+		goto done;
 	}
 
 	cardp->bootcmdresp = 0;
@@ -811,7 +858,7 @@ restart:
 	if_prog_firmware(priv);
 
 	do {
-		lbs_dev_dbg(1, &cardp->udev->dev,"Wlan sched timeout\n");
+		lbs_deb_usbd(&cardp->udev->dev,"Wlan sched timeout\n");
 		i++;
 		msleep_interruptible(100);
 		if (priv->adapter->surpriseremoved || i >= 20)
@@ -826,8 +873,8 @@ restart:
 		}
 
 		lbs_pr_info("FW download failure, time = %d ms\n", i * 100);
-		LEAVE();
-		return -1;
+		ret = -1;
+		goto done;
 	}
 
 	if_usb_submit_rx_urb(priv);
@@ -837,32 +884,10 @@ restart:
 
 	priv->adapter->fw_ready = 1;
 
-	LEAVE();
-	return 0;
-}
-
-/**
- *  @brief Given a usb_card_rec return its wlan_private
- *  @param card		pointer to a usb_card_rec
- *  @return 	   	pointer to wlan_private
- */
-wlan_private *libertas_sbi_get_priv(void *card)
-{
-	struct usb_card_rec *cardp = card;
-	return cardp->priv;
-}
-
-#ifdef ENABLE_PM
-int libertas_sbi_suspend(wlan_private * priv)
-{
-	return 0;
-}
-
-int libertas_sbi_resume(wlan_private * priv)
-{
-	return 0;
+done:
+	lbs_deb_leave_args(LBS_DEB_USB, "ret %d", ret);
+	return ret;
 }
-#endif
 
 #ifdef CONFIG_PM
 static int if_usb_suspend(struct usb_interface *intf, pm_message_t message)
@@ -870,12 +895,13 @@ static int if_usb_suspend(struct usb_int
 	struct usb_card_rec *cardp = usb_get_intfdata(intf);
 	wlan_private *priv = cardp->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	if (priv->adapter->psstate != PS_STATE_FULL_POWER)
 		return -1;
 
 	netif_device_detach(cardp->eth_dev);
+	netif_device_detach(priv->mesh_dev);
 
 	/* Unlink tx & rx urb */
 	usb_kill_urb(cardp->tx_urb);
@@ -883,23 +909,25 @@ static int if_usb_suspend(struct usb_int
 
 	cardp->rx_urb_recall = 1;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_USB);
 	return 0;
 }
 
 static int if_usb_resume(struct usb_interface *intf)
 {
 	struct usb_card_rec *cardp = usb_get_intfdata(intf);
+	wlan_private *priv = cardp->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_USB);
 
 	cardp->rx_urb_recall = 0;
 
 	if_usb_submit_rx_urb(cardp->priv);
 
 	netif_device_attach(cardp->eth_dev);
+	netif_device_attach(priv->mesh_dev);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_USB);
 	return 0;
 }
 #else
@@ -920,32 +948,40 @@ static struct usb_driver if_usb_driver =
 	.resume = if_usb_resume,
 };
 
-/**
- *  @brief This function registers driver.
- *  @param add		pointer to add_card callback function
- *  @param remove	pointer to remove card callback function
- *  @param arg		pointer to call back function parameter
- *  @return 	   	dummy success variable
- */
-int libertas_sbi_register(void)
+static int if_usb_init_module(void)
 {
-	/*
-	 * API registers the Marvell USB driver
-	 * to the USB system
-	 */
-	usb_register(&if_usb_driver);
+	int ret = 0;
 
-	/* Return success to wlan layer */
-	return 0;
+	lbs_deb_enter(LBS_DEB_MAIN);
+
+	if (libertas_fw_name == NULL) {
+		libertas_fw_name = default_fw_name;
+	}
+
+	ret = usb_register(&if_usb_driver);
+
+	lbs_deb_leave_args(LBS_DEB_MAIN, "ret %d", ret);
+	return ret;
 }
 
-/**
- *  @brief This function removes usb driver.
- *  @return 	   	N/A
- */
-void libertas_sbi_unregister(void)
+static void if_usb_exit_module(void)
 {
+	struct usb_card_rec *cardp, *cardp_temp;
+
+	lbs_deb_enter(LBS_DEB_MAIN);
+
+	list_for_each_entry_safe(cardp, cardp_temp, &usb_devices, list)
+		if_usb_reset_device((wlan_private *) cardp->priv);
+
 	/* API unregisters the driver from USB subsystem */
 	usb_deregister(&if_usb_driver);
-	return;
+
+	lbs_deb_leave(LBS_DEB_MAIN);
 }
+
+module_init(if_usb_init_module);
+module_exit(if_usb_exit_module);
+
+MODULE_DESCRIPTION("8388 USB WLAN Driver");
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_LICENSE("GPL");
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_usb.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_usb.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/if_usb.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/if_usb.h	2007-06-14 14:14:33.000000000 -0400
@@ -1,3 +1,8 @@
+#ifndef _LIBERTAS_IF_USB_H
+#define _LIBERTAS_IF_USB_H
+
+#include <linux/list.h>
+
 /**
   * This file contains definition for USB interface.
   */
@@ -7,11 +12,6 @@
 
 #define IPFIELD_ALIGN_OFFSET	2
 
-#define USB8388_VID_1	0x1286
-#define USB8388_PID_1	0x2001
-#define USB8388_VID_2	0x05a3
-#define USB8388_PID_2	0x8388
-
 #define BOOT_CMD_FW_BY_USB     0x01
 #define BOOT_CMD_FW_IN_EEPROM  0x02
 #define BOOT_CMD_UPDATE_BOOT2  0x03
@@ -20,7 +20,7 @@
 
 struct bootcmdstr
 {
-	u32 u32magicnumber;
+	__le32 u32magicnumber;
 	u8  u8cmd_tag;
 	u8  au8dumy[11];
 };
@@ -30,7 +30,7 @@ struct bootcmdstr
 
 struct bootcmdrespStr
 {
-	u32 u32magicnumber;
+	__le32 u32magicnumber;
 	u8  u8cmd_tag;
 	u8  u8result;
 	u8  au8dumy[2];
@@ -44,6 +44,7 @@ struct read_cb_info {
 
 /** USB card description structure*/
 struct usb_card_rec {
+	struct list_head list;
 	struct net_device *eth_dev;
 	struct usb_device *udev;
 	struct urb *rx_urb, *tx_urb;
@@ -75,33 +76,34 @@ struct usb_card_rec {
 
 /** fwheader */
 struct fwheader {
-	u32 dnldcmd;
-	u32 baseaddr;
-	u32 datalength;
-	u32 CRC;
+	__le32 dnldcmd;
+	__le32 baseaddr;
+	__le32 datalength;
+	__le32 CRC;
 };
 
 #define FW_MAX_DATA_BLK_SIZE	600
 /** FWData */
 struct FWData {
 	struct fwheader fwheader;
-	u32 seqnum;
+	__le32 seqnum;
 	u8 data[FW_MAX_DATA_BLK_SIZE];
 };
 
 /** fwsyncheader */
 struct fwsyncheader {
-	u32 cmd;
-	u32 seqnum;
+	__le32 cmd;
+	__le32 seqnum;
 };
 
 #define FW_HAS_DATA_TO_RECV		0x00000001
 #define FW_HAS_LAST_BLOCK		0x00000004
 
 #define FW_DATA_XMIT_SIZE \
-	sizeof(struct fwheader) + fwdata->fwheader.datalength + sizeof(u32)
+	sizeof(struct fwheader) + le32_to_cpu(fwdata->fwheader.datalength) + sizeof(u32)
 
 int usb_tx_block(wlan_private *priv, u8 *payload, u16 nb);
 void if_usb_free(struct usb_card_rec *cardp);
 int if_usb_issue_boot_command(wlan_private *priv, int ivalue);
 
+#endif
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/ioctl.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/ioctl.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/ioctl.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/ioctl.c	2007-06-14 14:14:33.000000000 -0400
@@ -30,6 +30,7 @@
 static int wlan_set_region(wlan_private * priv, u16 region_code)
 {
 	int i;
+	int ret = 0;
 
 	for (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {
 		// use the region code to search for the index
@@ -42,17 +43,18 @@ static int wlan_set_region(wlan_private 
 
 	// if it's unidentified region code
 	if (i >= MRVDRV_MAX_REGION_CODE) {
-		lbs_pr_debug(1, "region Code not identified\n");
-		LEAVE();
-		return -1;
+		lbs_deb_ioctl("region Code not identified\n");
+		ret = -1;
+		goto done;
 	}
 
 	if (libertas_set_regiontable(priv, priv->adapter->regioncode, 0)) {
-		LEAVE();
-		return -EINVAL;
+		ret = -EINVAL;
 	}
 
-	return 0;
+done:
+	lbs_deb_leave_args(LBS_DEB_IOCTL, "ret %d", ret);
+	return ret;
 }
 
 static inline int hex2int(char c)
@@ -125,8 +127,10 @@ static int wlan_bt_add_ioctl(wlan_privat
 	char ethaddrs_str[18];
 	char *pos;
 	u8 ethaddr[ETH_ALEN];
+	int ret;
+
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	ENTER();
 	if (copy_from_user(ethaddrs_str, wrq->u.data.pointer,
 			   sizeof(ethaddrs_str)))
 		return -EFAULT;
@@ -136,11 +140,12 @@ static int wlan_bt_add_ioctl(wlan_privat
 		return -EINVAL;
 	}
 
-	lbs_pr_debug(1, "BT: adding %s\n", ethaddrs_str);
-	LEAVE();
-	return (libertas_prepare_and_send_command(priv, cmd_bt_access,
+	lbs_deb_ioctl("BT: adding %s\n", ethaddrs_str);
+	ret = libertas_prepare_and_send_command(priv, cmd_bt_access,
 				      cmd_act_bt_access_add,
-				      cmd_option_waitforrsp, 0, ethaddr));
+				      cmd_option_waitforrsp, 0, ethaddr);
+	lbs_deb_leave_args(LBS_DEB_IOCTL, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -156,7 +161,8 @@ static int wlan_bt_del_ioctl(wlan_privat
 	u8 ethaddr[ETH_ALEN];
 	char *pos;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
 	if (copy_from_user(ethaddrs_str, wrq->u.data.pointer,
 			   sizeof(ethaddrs_str)))
 		return -EFAULT;
@@ -166,13 +172,14 @@ static int wlan_bt_del_ioctl(wlan_privat
 		return -EINVAL;
 	}
 
-	lbs_pr_debug(1, "BT: deleting %s\n", ethaddrs_str);
+	lbs_deb_ioctl("BT: deleting %s\n", ethaddrs_str);
 
 	return (libertas_prepare_and_send_command(priv,
 				      cmd_bt_access,
 				      cmd_act_bt_access_del,
 				      cmd_option_waitforrsp, 0, ethaddr));
-	LEAVE();
+
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -183,7 +190,7 @@ static int wlan_bt_del_ioctl(wlan_privat
  */
 static int wlan_bt_reset_ioctl(wlan_private * priv)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
 	lbs_pr_alert( "BT: resetting\n");
 
@@ -192,7 +199,7 @@ static int wlan_bt_reset_ioctl(wlan_priv
 				      cmd_act_bt_access_reset,
 				      cmd_option_waitforrsp, 0, NULL));
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -209,17 +216,17 @@ static int wlan_bt_list_ioctl(wlan_priva
 	struct iwreq *wrq = (struct iwreq *)req;
 	/* used to pass id and store the bt entry returned by the FW */
 	union {
-		int id;
+		u32 id;
 		char addr1addr2[2 * ETH_ALEN];
 	} param;
 	static char outstr[64];
 	char *pbuf = outstr;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
 	if (copy_from_user(outstr, wrq->u.data.pointer, sizeof(outstr))) {
-		lbs_pr_debug(1, "Copy from user failed\n");
+		lbs_deb_ioctl("Copy from user failed\n");
 		return -1;
 	}
 	param.id = simple_strtoul(outstr, NULL, 10);
@@ -234,7 +241,7 @@ static int wlan_bt_list_ioctl(wlan_priva
 	if (ret == 0) {
 		addr1 = param.addr1addr2;
 
-		pos = sprintf(pbuf, "ignoring traffic from ");
+		pos = sprintf(pbuf, "BT includes node ");
 		pbuf += pos;
 		pos = eth_addr2str(addr1, pbuf);
 		pbuf += pos;
@@ -246,11 +253,70 @@ static int wlan_bt_list_ioctl(wlan_priva
 	wrq->u.data.length = strlen(outstr);
 	if (copy_to_user(wrq->u.data.pointer, (char *)outstr,
 			 wrq->u.data.length)) {
-		lbs_pr_debug(1, "BT_LIST: Copy to user failed!\n");
+		lbs_deb_ioctl("BT_LIST: Copy to user failed!\n");
 		return -EFAULT;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
+	return 0 ;
+}
+
+/**
+ *  @brief          Sets inverted state of blacklist (non-zero if inverted)
+ *  @param priv     A pointer to wlan_private structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         0 --success, otherwise fail
+ */
+static int wlan_bt_set_invert_ioctl(wlan_private * priv, struct ifreq *req)
+{
+	int ret;
+	struct iwreq *wrq = (struct iwreq *)req;
+	union {
+		u32 id;
+		char addr1addr2[2 * ETH_ALEN];
+	} param;
+
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
+	param.id = SUBCMD_DATA(wrq) ;
+	ret = libertas_prepare_and_send_command(priv, cmd_bt_access,
+				    cmd_act_bt_access_set_invert,
+				    cmd_option_waitforrsp, 0,
+				    (char *)&param);
+	if (ret != 0)
+		return -EFAULT;
+	lbs_deb_leave(LBS_DEB_IOCTL);
+	return 0;
+}
+
+/**
+ *  @brief          Gets inverted state of blacklist (non-zero if inverted)
+ *  @param priv     A pointer to wlan_private structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         0 --success, otherwise fail
+ */
+static int wlan_bt_get_invert_ioctl(wlan_private * priv, struct ifreq *req)
+{
+	struct iwreq *wrq = (struct iwreq *)req;
+	int ret;
+	union {
+		u32 id;
+		char addr1addr2[2 * ETH_ALEN];
+	} param;
+
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
+	ret = libertas_prepare_and_send_command(priv, cmd_bt_access,
+				    cmd_act_bt_access_get_invert,
+				    cmd_option_waitforrsp, 0,
+				    (char *)&param);
+
+	if (ret == 0)
+		wrq->u.param.value = le32_to_cpu(param.id);
+	else
+		return -EFAULT;
+
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -278,8 +344,10 @@ static int wlan_fwt_add_ioctl(wlan_priva
 	char in_str[128];
 	static struct cmd_ds_fwt_access fwt_access;
 	char *ptr;
+	int ret;
+
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	ENTER();
 	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
 		return -EFAULT;
 
@@ -297,7 +365,7 @@ static int wlan_fwt_add_ioctl(wlan_priva
 		fwt_access.metric =
 			cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 	else
-		fwt_access.metric = FWT_DEFAULT_METRIC;
+		fwt_access.metric = cpu_to_le32(FWT_DEFAULT_METRIC);
 
 	if ((ptr = next_param(ptr)))
 		fwt_access.dir = (u8)simple_strtoul(ptr, &ptr, 10);
@@ -305,16 +373,21 @@ static int wlan_fwt_add_ioctl(wlan_priva
 		fwt_access.dir = FWT_DEFAULT_DIR;
 
 	if ((ptr = next_param(ptr)))
+		fwt_access.rate = (u8) simple_strtoul(ptr, &ptr, 10);
+	else
+		fwt_access.rate = FWT_DEFAULT_RATE;
+
+	if ((ptr = next_param(ptr)))
 		fwt_access.ssn =
 			cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 	else
-		fwt_access.ssn = FWT_DEFAULT_SSN;
+		fwt_access.ssn = cpu_to_le32(FWT_DEFAULT_SSN);
 
 	if ((ptr = next_param(ptr)))
 		fwt_access.dsn =
 			cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 	else
-		fwt_access.dsn = FWT_DEFAULT_DSN;
+		fwt_access.dsn = cpu_to_le32(FWT_DEFAULT_DSN);
 
 	if ((ptr = next_param(ptr)))
 		fwt_access.hopcount = simple_strtoul(ptr, &ptr, 10);
@@ -330,7 +403,7 @@ static int wlan_fwt_add_ioctl(wlan_priva
 		fwt_access.expiration =
 			cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 	else
-		fwt_access.expiration = FWT_DEFAULT_EXPIRATION;
+		fwt_access.expiration = cpu_to_le32(FWT_DEFAULT_EXPIRATION);
 
 	if ((ptr = next_param(ptr)))
 		fwt_access.sleepmode = (u8)simple_strtoul(ptr, &ptr, 10);
@@ -341,27 +414,29 @@ static int wlan_fwt_add_ioctl(wlan_priva
 		fwt_access.snr =
 			cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 	else
-		fwt_access.snr = FWT_DEFAULT_SNR;
+		fwt_access.snr = cpu_to_le32(FWT_DEFAULT_SNR);
 
 #ifdef DEBUG
 	{
 		char ethaddr1_str[18], ethaddr2_str[18];
 		eth_addr2str(fwt_access.da, ethaddr1_str);
 		eth_addr2str(fwt_access.ra, ethaddr2_str);
-		lbs_pr_debug(1, "FWT_ADD: adding (da:%s,%i,ra:%s)\n", ethaddr1_str,
+		lbs_deb_ioctl("FWT_ADD: adding (da:%s,%i,ra:%s)\n", ethaddr1_str,
 		       fwt_access.dir, ethaddr2_str);
-		lbs_pr_debug(1, "FWT_ADD: ssn:%u dsn:%u met:%u hop:%u ttl:%u exp:%u slp:%u snr:%u\n",
+		lbs_deb_ioctl("FWT_ADD: ssn:%u dsn:%u met:%u hop:%u ttl:%u exp:%u slp:%u snr:%u\n",
 		       fwt_access.ssn, fwt_access.dsn, fwt_access.metric,
 		       fwt_access.hopcount, fwt_access.ttl, fwt_access.expiration,
 		       fwt_access.sleepmode, fwt_access.snr);
 	}
 #endif
 
-	LEAVE();
-	return (libertas_prepare_and_send_command(priv, cmd_fwt_access,
-						  cmd_act_fwt_access_add,
-						  cmd_option_waitforrsp, 0,
-						  (void *)&fwt_access));
+	ret = libertas_prepare_and_send_command(priv, cmd_fwt_access,
+						cmd_act_fwt_access_add,
+						cmd_option_waitforrsp, 0,
+						(void *)&fwt_access);
+
+	lbs_deb_leave_args(LBS_DEB_IOCTL, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -376,8 +451,10 @@ static int wlan_fwt_del_ioctl(wlan_priva
 	char in_str[64];
 	static struct cmd_ds_fwt_access fwt_access;
 	char *ptr;
+	int ret;
+
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	ENTER();
 	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
 		return -EFAULT;
 
@@ -399,20 +476,21 @@ static int wlan_fwt_del_ioctl(wlan_priva
 #ifdef DEBUG
 	{
 		char ethaddr1_str[18], ethaddr2_str[18];
-		lbs_pr_debug(1, "FWT_DEL: line is %s\n", in_str);
+		lbs_deb_ioctl("FWT_DEL: line is %s\n", in_str);
 		eth_addr2str(fwt_access.da, ethaddr1_str);
 		eth_addr2str(fwt_access.ra, ethaddr2_str);
-		lbs_pr_debug(1, "FWT_DEL: removing (da:%s,ra:%s,dir:%d)\n", ethaddr1_str,
+		lbs_deb_ioctl("FWT_DEL: removing (da:%s,ra:%s,dir:%d)\n", ethaddr1_str,
 		       ethaddr2_str, fwt_access.dir);
 	}
 #endif
 
-	LEAVE();
-	return (libertas_prepare_and_send_command(priv,
-						  cmd_fwt_access,
-						  cmd_act_fwt_access_del,
-						  cmd_option_waitforrsp, 0,
-						  (void *)&fwt_access));
+	ret = libertas_prepare_and_send_command(priv,
+						cmd_fwt_access,
+						cmd_act_fwt_access_del,
+						cmd_option_waitforrsp, 0,
+						(void *)&fwt_access);
+	lbs_deb_leave_args(LBS_DEB_IOCTL, "ret %d", ret);
+	return ret;
 }
 
 
@@ -427,15 +505,18 @@ static void print_route(struct cmd_ds_fw
 	buf += eth_addr2str(fwt_access.da, buf);
 	buf += sprintf(buf, " ");
 	buf += eth_addr2str(fwt_access.ra, buf);
+	buf += sprintf(buf, " %u", fwt_access.valid);
 	buf += sprintf(buf, " %u", le32_to_cpu(fwt_access.metric));
 	buf += sprintf(buf, " %u", fwt_access.dir);
+	buf += sprintf(buf, " %u", fwt_access.rate);
 	buf += sprintf(buf, " %u", le32_to_cpu(fwt_access.ssn));
 	buf += sprintf(buf, " %u", le32_to_cpu(fwt_access.dsn));
 	buf += sprintf(buf, " %u", fwt_access.hopcount);
 	buf += sprintf(buf, " %u", fwt_access.ttl);
 	buf += sprintf(buf, " %u", le32_to_cpu(fwt_access.expiration));
 	buf += sprintf(buf, " %u", fwt_access.sleepmode);
-	buf += sprintf(buf, " %u", le32_to_cpu(fwt_access.snr));
+	buf += sprintf(buf, " %u ", le32_to_cpu(fwt_access.snr));
+	buf += eth_addr2str(fwt_access.prec, buf);
 }
 
 /**
@@ -453,7 +534,8 @@ static int wlan_fwt_lookup_ioctl(wlan_pr
 	static char out_str[128];
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
 	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
 		return -EFAULT;
 
@@ -465,9 +547,9 @@ static int wlan_fwt_lookup_ioctl(wlan_pr
 #ifdef DEBUG
 	{
 		char ethaddr1_str[18];
-		lbs_pr_debug(1, "FWT_LOOKUP: line is %s\n", in_str);
+		lbs_deb_ioctl("FWT_LOOKUP: line is %s\n", in_str);
 		eth_addr2str(fwt_access.da, ethaddr1_str);
-		lbs_pr_debug(1, "FWT_LOOKUP: looking for (da:%s)\n", ethaddr1_str);
+		lbs_deb_ioctl("FWT_LOOKUP: looking for (da:%s)\n", ethaddr1_str);
 	}
 #endif
 
@@ -485,11 +567,11 @@ static int wlan_fwt_lookup_ioctl(wlan_pr
 	wrq->u.data.length = strlen(out_str);
 	if (copy_to_user(wrq->u.data.pointer, (char *)out_str,
 			 wrq->u.data.length)) {
-		lbs_pr_debug(1, "FWT_LOOKUP: Copy to user failed!\n");
+		lbs_deb_ioctl("FWT_LOOKUP: Copy to user failed!\n");
 		return -EFAULT;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -500,7 +582,7 @@ static int wlan_fwt_lookup_ioctl(wlan_pr
  */
 static int wlan_fwt_reset_ioctl(wlan_private * priv)
 {
-	lbs_pr_debug(1, "FWT: resetting\n");
+	lbs_deb_ioctl("FWT: resetting\n");
 
 	return (libertas_prepare_and_send_command(priv,
 				      cmd_fwt_access,
@@ -522,18 +604,21 @@ static int wlan_fwt_list_ioctl(wlan_priv
 	char *ptr = in_str;
 	static char out_str[128];
 	char *pbuf = out_str;
-	int ret;
+	int ret = 0;
 
-	ENTER();
-	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
-		return -EFAULT;
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
+	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str))) {
+		ret = -EFAULT;
+		goto out;
+	}
 
 	fwt_access.id = cpu_to_le32(simple_strtoul(ptr, &ptr, 10));
 
 #ifdef DEBUG
 	{
-		lbs_pr_debug(1, "FWT_LIST: line is %s\n", in_str);
-		lbs_pr_debug(1, "FWT_LIST: listing id:%i\n", le32_to_cpu(fwt_access.id));
+		lbs_deb_ioctl("FWT_LIST: line is %s\n", in_str);
+		lbs_deb_ioctl("FWT_LIST: listing id:%i\n", le32_to_cpu(fwt_access.id));
 	}
 #endif
 
@@ -549,12 +634,16 @@ static int wlan_fwt_list_ioctl(wlan_priv
 	wrq->u.data.length = strlen(out_str);
 	if (copy_to_user(wrq->u.data.pointer, (char *)out_str,
 			 wrq->u.data.length)) {
-		lbs_pr_debug(1, "FWT_LIST: Copy to user failed!\n");
-		return -EFAULT;
+		lbs_deb_ioctl("FWT_LIST: Copy to user failed!\n");
+		ret = -EFAULT;
+		goto out;
 	}
 
-	LEAVE();
-	return 0;
+	ret = 0;
+
+out:
+	lbs_deb_leave(LBS_DEB_IOCTL);
+	return ret;
 }
 
 /**
@@ -573,7 +662,8 @@ static int wlan_fwt_list_route_ioctl(wla
 	char *pbuf = out_str;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
 	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
 		return -EFAULT;
 
@@ -581,8 +671,8 @@ static int wlan_fwt_list_route_ioctl(wla
 
 #ifdef DEBUG
 	{
-		lbs_pr_debug(1, "FWT_LIST_ROUTE: line is %s\n", in_str);
-		lbs_pr_debug(1, "FWT_LIST_ROUTE: listing id:%i\n", le32_to_cpu(fwt_access.id));
+		lbs_deb_ioctl("FWT_LIST_ROUTE: line is %s\n", in_str);
+		lbs_deb_ioctl("FWT_LIST_ROUTE: listing id:%i\n", le32_to_cpu(fwt_access.id));
 	}
 #endif
 
@@ -591,28 +681,18 @@ static int wlan_fwt_list_route_ioctl(wla
 				    cmd_option_waitforrsp, 0, (void *)&fwt_access);
 
 	if (ret == 0) {
-		pbuf += sprintf(pbuf, " ");
-		pbuf += eth_addr2str(fwt_access.da, pbuf);
-		pbuf += sprintf(pbuf, " %u", le32_to_cpu(fwt_access.metric));
-		pbuf += sprintf(pbuf, " %u", fwt_access.dir);
-		/* note that the firmware returns the nid in the id field */
-		pbuf += sprintf(pbuf, " %u", le32_to_cpu(fwt_access.id));
-		pbuf += sprintf(pbuf, " %u", le32_to_cpu(fwt_access.ssn));
-		pbuf += sprintf(pbuf, " %u", le32_to_cpu(fwt_access.dsn));
-		pbuf += sprintf(pbuf, "  hop %u", fwt_access.hopcount);
-		pbuf += sprintf(pbuf, "  ttl %u", fwt_access.ttl);
-		pbuf += sprintf(pbuf, " %u", le32_to_cpu(fwt_access.expiration));
+		print_route(fwt_access, pbuf);
 	} else
 		pbuf += sprintf(pbuf, " (null)");
 
 	wrq->u.data.length = strlen(out_str);
 	if (copy_to_user(wrq->u.data.pointer, (char *)out_str,
 			 wrq->u.data.length)) {
-		lbs_pr_debug(1, "FWT_LIST_ROUTE: Copy to user failed!\n");
+		lbs_deb_ioctl("FWT_LIST_ROUTE: Copy to user failed!\n");
 		return -EFAULT;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -632,7 +712,8 @@ static int wlan_fwt_list_neighbor_ioctl(
 	char *pbuf = out_str;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
+
 	if (copy_from_user(in_str, wrq->u.data.pointer, sizeof(in_str)))
 		return -EFAULT;
 
@@ -641,8 +722,8 @@ static int wlan_fwt_list_neighbor_ioctl(
 
 #ifdef DEBUG
 	{
-		lbs_pr_debug(1, "FWT_LIST_NEIGHBOR: line is %s\n", in_str);
-		lbs_pr_debug(1, "FWT_LIST_NEIGHBOR: listing id:%i\n", le32_to_cpu(fwt_access.id));
+		lbs_deb_ioctl("FWT_LIST_NEIGHBOR: line is %s\n", in_str);
+		lbs_deb_ioctl("FWT_LIST_NEIGHBOR: listing id:%i\n", le32_to_cpu(fwt_access.id));
 	}
 #endif
 
@@ -663,11 +744,11 @@ static int wlan_fwt_list_neighbor_ioctl(
 	wrq->u.data.length = strlen(out_str);
 	if (copy_to_user(wrq->u.data.pointer, (char *)out_str,
 			 wrq->u.data.length)) {
-		lbs_pr_debug(1, "FWT_LIST_NEIGHBOR: Copy to user failed!\n");
+		lbs_deb_ioctl("FWT_LIST_NEIGHBOR: Copy to user failed!\n");
 		return -EFAULT;
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -684,9 +765,9 @@ static int wlan_fwt_cleanup_ioctl(wlan_p
 	static struct cmd_ds_fwt_access fwt_access;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	lbs_pr_debug(1, "FWT: cleaning up\n");
+	lbs_deb_ioctl("FWT: cleaning up\n");
 
 	memset(&fwt_access, 0, sizeof(fwt_access));
 
@@ -700,7 +781,7 @@ static int wlan_fwt_cleanup_ioctl(wlan_p
 	else
 		return -EFAULT;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -716,9 +797,9 @@ static int wlan_fwt_time_ioctl(wlan_priv
 	static struct cmd_ds_fwt_access fwt_access;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	lbs_pr_debug(1, "FWT: getting time\n");
+	lbs_deb_ioctl("FWT: getting time\n");
 
 	memset(&fwt_access, 0, sizeof(fwt_access));
 
@@ -732,7 +813,7 @@ static int wlan_fwt_time_ioctl(wlan_priv
 	else
 		return -EFAULT;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -748,7 +829,7 @@ static int wlan_mesh_get_ttl_ioctl(wlan_
 	struct cmd_ds_mesh_access mesh_access;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
 	memset(&mesh_access, 0, sizeof(mesh_access));
 
@@ -762,7 +843,7 @@ static int wlan_mesh_get_ttl_ioctl(wlan_
 	else
 		return -EFAULT;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return 0;
 }
 
@@ -777,13 +858,13 @@ static int wlan_mesh_set_ttl_ioctl(wlan_
 	struct cmd_ds_mesh_access mesh_access;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
 	if( (ttl > 0xff) || (ttl < 0) )
 		return -EINVAL;
 
 	memset(&mesh_access, 0, sizeof(mesh_access));
-	mesh_access.data[0] = ttl;
+	mesh_access.data[0] = cpu_to_le32(ttl);
 
 	ret = libertas_prepare_and_send_command(priv, cmd_mesh_access,
 						cmd_act_mesh_set_ttl,
@@ -793,7 +874,7 @@ static int wlan_mesh_set_ttl_ioctl(wlan_
 	if (ret != 0)
 		ret = -EFAULT;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_IOCTL);
 	return ret;
 }
 
@@ -815,9 +896,9 @@ int libertas_do_ioctl(struct net_device 
 	wlan_adapter *adapter = priv->adapter;
 	struct iwreq *wrq = (struct iwreq *)req;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_IOCTL);
 
-	lbs_pr_debug(1, "libertas_do_ioctl: ioctl cmd = 0x%x\n", cmd);
+	lbs_deb_ioctl("libertas_do_ioctl: ioctl cmd = 0x%x\n", cmd);
 	switch (cmd) {
 	case WLAN_SETNONE_GETNONE:	/* set WPA mode on/off ioctl #20 */
 		switch (wrq->u.data.flags) {
@@ -848,6 +929,10 @@ int libertas_do_ioctl(struct net_device 
 			ret = wlan_mesh_set_ttl_ioctl(priv, idata);
 			break;
 
+		case WLAN_SUBCMD_BT_SET_INVERT:
+			ret = wlan_bt_set_invert_ioctl(priv, req);
+			break ;
+
 		default:
 			ret = -EOPNOTSUPP;
 			break;
@@ -905,6 +990,10 @@ int libertas_do_ioctl(struct net_device 
 			ret = wlan_mesh_get_ttl_ioctl(priv, req);
 			break;
 
+		case WLAN_SUBCMD_BT_GET_INVERT:
+			ret = wlan_bt_get_invert_ioctl(priv, req);
+			break ;
+
 		default:
 			ret = -EOPNOTSUPP;
 
@@ -937,7 +1026,7 @@ int libertas_do_ioctl(struct net_device 
 					    (data, wrq->u.data.pointer,
 					     sizeof(int) *
 					     wrq->u.data.length)) {
-						lbs_pr_debug(1,
+						lbs_deb_ioctl(
 						       "Copy from user failed\n");
 						return -EFAULT;
 					}
@@ -970,7 +1059,7 @@ int libertas_do_ioctl(struct net_device 
 				if (copy_to_user(wrq->u.data.pointer, data,
 						 sizeof(int) *
 						 gpio->header.len)) {
-					lbs_pr_debug(1, "Copy to user failed\n");
+					lbs_deb_ioctl("Copy to user failed\n");
 					return -EFAULT;
 				}
 
@@ -984,7 +1073,8 @@ int libertas_do_ioctl(struct net_device 
 		ret = -EINVAL;
 		break;
 	}
-	LEAVE();
+
+	lbs_deb_leave_args(LBS_DEB_IOCTL, "ret %d", ret);
 	return ret;
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/join.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/join.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/join.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/join.c	2007-06-14 14:14:33.000000000 -0400
@@ -7,6 +7,7 @@
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
 #include <linux/wireless.h>
+#include <linux/etherdevice.h>
 
 #include <net/iw_handler.h>
 
@@ -14,6 +15,7 @@
 #include "decl.h"
 #include "join.h"
 #include "dev.h"
+#include "assoc.h"
 
 #define AD_HOC_CAP_PRIVACY_ON 1
 
@@ -60,7 +62,7 @@ static int get_common_rates(wlan_adapter
 	lbs_dbg_hex("rate1 (AP) rates:", tmp, sizeof(tmp));
 	lbs_dbg_hex("rate2 (Card) rates:", rate2, rate2_size);
 	lbs_dbg_hex("Common rates:", ptr, rate1_size);
-	lbs_pr_debug(1, "Tx datarate is set to 0x%X\n", adapter->datarate);
+	lbs_deb_join("Tx datarate is set to 0x%X\n", adapter->datarate);
 
 	if (!adapter->is_datarate_auto) {
 		while (*ptr) {
@@ -104,24 +106,22 @@ int libertas_send_deauth(wlan_private * 
  *
  *  @return          0-success, otherwise fail
  */
-int wlan_associate(wlan_private * priv, struct bss_descriptor * pbssdesc)
+int wlan_associate(wlan_private * priv, struct assoc_request * assoc_req)
 {
 	wlan_adapter *adapter = priv->adapter;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_authenticate,
 				    0, cmd_option_waitforrsp,
-				    0, pbssdesc->macaddress);
+				    0, assoc_req->bss.bssid);
 
-	if (ret) {
-		LEAVE();
-		return ret;
-	}
+	if (ret)
+		goto done;
 
 	/* set preamble to firmware */
-	if (adapter->capinfo.shortpreamble && pbssdesc->cap.shortpreamble)
+	if (adapter->capinfo.shortpreamble && assoc_req->bss.cap.shortpreamble)
 		adapter->preamble = cmd_type_short_preamble;
 	else
 		adapter->preamble = cmd_type_long_preamble;
@@ -129,9 +129,10 @@ int wlan_associate(wlan_private * priv, 
 	libertas_set_radio_control(priv);
 
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_associate,
-				    0, cmd_option_waitforrsp, 0, pbssdesc);
+				    0, cmd_option_waitforrsp, 0, assoc_req);
 
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
@@ -142,7 +143,7 @@ int wlan_associate(wlan_private * priv, 
  *  @param adhocssid    The ssid of the Adhoc Network
  *  @return             0--success, -1--fail
  */
-int libertas_start_adhoc_network(wlan_private * priv, struct WLAN_802_11_SSID *adhocssid)
+int libertas_start_adhoc_network(wlan_private * priv, struct assoc_request * assoc_req)
 {
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
@@ -150,22 +151,20 @@ int libertas_start_adhoc_network(wlan_pr
 	adapter->adhoccreate = 1;
 
 	if (!adapter->capinfo.shortpreamble) {
-		lbs_pr_debug(1, "AdhocStart: Long preamble\n");
+		lbs_deb_join("AdhocStart: Long preamble\n");
 		adapter->preamble = cmd_type_long_preamble;
 	} else {
-		lbs_pr_debug(1, "AdhocStart: Short preamble\n");
+		lbs_deb_join("AdhocStart: Short preamble\n");
 		adapter->preamble = cmd_type_short_preamble;
 	}
 
 	libertas_set_radio_control(priv);
 
-	lbs_pr_debug(1, "Adhoc channel = %d\n", adapter->adhocchannel);
-	lbs_pr_debug(1, "curbssparams.channel = %d\n",
-	       adapter->curbssparams.channel);
-	lbs_pr_debug(1, "curbssparams.band = %d\n", adapter->curbssparams.band);
+	lbs_deb_join("AdhocStart: channel = %d\n", assoc_req->channel);
+	lbs_deb_join("AdhocStart: band = %d\n", assoc_req->band);
 
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_ad_hoc_start,
-				    0, cmd_option_waitforrsp, 0, adhocssid);
+				    0, cmd_option_waitforrsp, 0, assoc_req);
 
 	return ret;
 }
@@ -179,52 +178,53 @@ int libertas_start_adhoc_network(wlan_pr
  *
  *  @return             0--success, -1--fail
  */
-int libertas_join_adhoc_network(wlan_private * priv, struct bss_descriptor * pbssdesc)
+int libertas_join_adhoc_network(wlan_private * priv, struct assoc_request * assoc_req)
 {
 	wlan_adapter *adapter = priv->adapter;
+	struct bss_descriptor * bss = &assoc_req->bss;
 	int ret = 0;
 
-	lbs_pr_debug(1, "libertas_join_adhoc_network: CurBss.ssid =%s\n",
-	       adapter->curbssparams.ssid.ssid);
-	lbs_pr_debug(1, "libertas_join_adhoc_network: CurBss.ssid_len =%u\n",
-	       adapter->curbssparams.ssid.ssidlength);
-	lbs_pr_debug(1, "libertas_join_adhoc_network: ssid =%s\n", pbssdesc->ssid.ssid);
-	lbs_pr_debug(1, "libertas_join_adhoc_network: ssid len =%u\n",
-	       pbssdesc->ssid.ssidlength);
+	lbs_deb_join("%s: Current SSID '%s', ssid length %u\n",
+	             __func__,
+	             escape_essid(adapter->curbssparams.ssid,
+	                          adapter->curbssparams.ssid_len),
+	             adapter->curbssparams.ssid_len);
+	lbs_deb_join("%s: requested ssid '%s', ssid length %u\n",
+	             __func__, escape_essid(bss->ssid, bss->ssid_len),
+	             bss->ssid_len);
 
 	/* check if the requested SSID is already joined */
-	if (adapter->curbssparams.ssid.ssidlength
-	    && !libertas_SSID_cmp(&pbssdesc->ssid, &adapter->curbssparams.ssid)
+	if (adapter->curbssparams.ssid_len
+	    && !libertas_ssid_cmp(adapter->curbssparams.ssid,
+	                          adapter->curbssparams.ssid_len,
+	                          bss->ssid, bss->ssid_len)
 	    && (adapter->mode == IW_MODE_ADHOC)) {
-
-        lbs_pr_debug(1,
+		lbs_deb_join(
 		       "ADHOC_J_CMD: New ad-hoc SSID is the same as current, "
 		       "not attempting to re-join");
-
 		return -1;
 	}
 
 	/*Use shortpreamble only when both creator and card supports
 	   short preamble */
-	if (!pbssdesc->cap.shortpreamble || !adapter->capinfo.shortpreamble) {
-		lbs_pr_debug(1, "AdhocJoin: Long preamble\n");
+	if (!bss->cap.shortpreamble || !adapter->capinfo.shortpreamble) {
+		lbs_deb_join("AdhocJoin: Long preamble\n");
 		adapter->preamble = cmd_type_long_preamble;
 	} else {
-		lbs_pr_debug(1, "AdhocJoin: Short preamble\n");
+		lbs_deb_join("AdhocJoin: Short preamble\n");
 		adapter->preamble = cmd_type_short_preamble;
 	}
 
 	libertas_set_radio_control(priv);
 
-	lbs_pr_debug(1, "curbssparams.channel = %d\n",
-	       adapter->curbssparams.channel);
-	lbs_pr_debug(1, "curbssparams.band = %c\n", adapter->curbssparams.band);
+	lbs_deb_join("AdhocJoin: channel = %d\n", assoc_req->channel);
+	lbs_deb_join("AdhocJoin: band = %c\n", assoc_req->band);
 
 	adapter->adhoccreate = 0;
 
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_ad_hoc_join,
 				    0, cmd_option_waitforrsp,
-				    OID_802_11_SSID, pbssdesc);
+				    OID_802_11_SSID, assoc_req);
 
 	return ret;
 }
@@ -265,6 +265,8 @@ int libertas_cmd_80211_authenticate(wlan
 	int ret = -1;
 	u8 *bssid = pdata_buf;
 
+	lbs_deb_enter(LBS_DEB_JOIN);
+
 	cmd->command = cpu_to_le16(cmd_802_11_authenticate);
 	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_authenticate)
 	                        + S_DS_GEN);
@@ -281,18 +283,19 @@ int libertas_cmd_80211_authenticate(wlan
 		pauthenticate->authtype = 0x80;
 		break;
 	default:
-		lbs_pr_debug(1, "AUTH_CMD: invalid auth alg 0x%X\n",
+		lbs_deb_join("AUTH_CMD: invalid auth alg 0x%X\n",
 		             adapter->secinfo.auth_mode);
 		goto out;
 	}
 
 	memcpy(pauthenticate->macaddr, bssid, ETH_ALEN);
 
-	lbs_pr_debug(1, "AUTH_CMD: Bssid is : %x:%x:%x:%x:%x:%x\n",
-	       bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
+	lbs_deb_join("AUTH_CMD: BSSID is : " MAC_FMT " auth=0x%X\n",
+	             MAC_ARG(bssid), pauthenticate->authtype);
 	ret = 0;
 
 out:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
@@ -302,22 +305,20 @@ int libertas_cmd_80211_deauthenticate(wl
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_deauthenticate *dauth = &cmd->params.deauth;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	cmd->command = cpu_to_le16(cmd_802_11_deauthenticate);
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_deauthenticate) +
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_deauthenticate) +
 			     S_DS_GEN);
 
 	/* set AP MAC address */
-	memmove(dauth->macaddr, adapter->curbssparams.bssid,
-		ETH_ALEN);
+	memmove(dauth->macaddr, adapter->curbssparams.bssid, ETH_ALEN);
 
 	/* Reason code 3 = Station is leaving */
 #define REASON_CODE_STA_LEAVING 3
 	dauth->reasoncode = cpu_to_le16(REASON_CODE_STA_LEAVING);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_JOIN);
 	return 0;
 }
 
@@ -327,20 +328,20 @@ int libertas_cmd_80211_associate(wlan_pr
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_associate *passo = &cmd->params.associate;
 	int ret = 0;
-	struct bss_descriptor *pbssdesc;
+	struct assoc_request * assoc_req = pdata_buf;
+	struct bss_descriptor * bss = &assoc_req->bss;
 	u8 *card_rates;
 	u8 *pos;
 	int card_rates_size;
-	u16 tmpcap;
+	u16 tmpcap, tmplen;
 	struct mrvlietypes_ssidparamset *ssid;
 	struct mrvlietypes_phyparamset *phy;
 	struct mrvlietypes_ssparamset *ss;
 	struct mrvlietypes_ratesparamset *rates;
 	struct mrvlietypes_rsnparamset *rsn;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
-	pbssdesc = pdata_buf;
 	pos = (u8 *) passo;
 
 	if (!adapter) {
@@ -350,15 +351,11 @@ int libertas_cmd_80211_associate(wlan_pr
 
 	cmd->command = cpu_to_le16(cmd_802_11_associate);
 
-	/* Save so we know which BSS Desc to use in the response handler */
-	adapter->pattemptedbssdesc = pbssdesc;
-
-	memcpy(passo->peerstaaddr,
-	       pbssdesc->macaddress, sizeof(passo->peerstaaddr));
+	memcpy(passo->peerstaaddr, bss->bssid, sizeof(passo->peerstaaddr));
 	pos += sizeof(passo->peerstaaddr);
 
 	/* set the listen interval */
-	passo->listeninterval = adapter->listeninterval;
+	passo->listeninterval = cpu_to_le16(adapter->listeninterval);
 
 	pos += sizeof(passo->capinfo);
 	pos += sizeof(passo->listeninterval);
@@ -367,30 +364,30 @@ int libertas_cmd_80211_associate(wlan_pr
 
 	ssid = (struct mrvlietypes_ssidparamset *) pos;
 	ssid->header.type = cpu_to_le16(TLV_TYPE_SSID);
-	ssid->header.len = pbssdesc->ssid.ssidlength;
-	memcpy(ssid->ssid, pbssdesc->ssid.ssid, ssid->header.len);
-	pos += sizeof(ssid->header) + ssid->header.len;
-	ssid->header.len = cpu_to_le16(ssid->header.len);
+	tmplen = bss->ssid_len;
+	ssid->header.len = cpu_to_le16(tmplen);
+	memcpy(ssid->ssid, bss->ssid, tmplen);
+	pos += sizeof(ssid->header) + tmplen;
 
 	phy = (struct mrvlietypes_phyparamset *) pos;
 	phy->header.type = cpu_to_le16(TLV_TYPE_PHY_DS);
-	phy->header.len = sizeof(phy->fh_ds.dsparamset);
+	tmplen = sizeof(phy->fh_ds.dsparamset);
+	phy->header.len = cpu_to_le16(tmplen);
 	memcpy(&phy->fh_ds.dsparamset,
-	       &pbssdesc->phyparamset.dsparamset.currentchan,
-	       sizeof(phy->fh_ds.dsparamset));
-	pos += sizeof(phy->header) + phy->header.len;
-	phy->header.len = cpu_to_le16(phy->header.len);
+	       &bss->phyparamset.dsparamset.currentchan,
+	       tmplen);
+	pos += sizeof(phy->header) + tmplen;
 
 	ss = (struct mrvlietypes_ssparamset *) pos;
 	ss->header.type = cpu_to_le16(TLV_TYPE_CF);
-	ss->header.len = sizeof(ss->cf_ibss.cfparamset);
-	pos += sizeof(ss->header) + ss->header.len;
-	ss->header.len = cpu_to_le16(ss->header.len);
+	tmplen = sizeof(ss->cf_ibss.cfparamset);
+	ss->header.len = cpu_to_le16(tmplen);
+	pos += sizeof(ss->header) + tmplen;
 
 	rates = (struct mrvlietypes_ratesparamset *) pos;
 	rates->header.type = cpu_to_le16(TLV_TYPE_RATES);
 
-	memcpy(&rates->rates, &pbssdesc->libertas_supported_rates, WLAN_SUPPORTED_RATES);
+	memcpy(&rates->rates, &bss->libertas_supported_rates, WLAN_SUPPORTED_RATES);
 
 	card_rates = libertas_supported_rates;
 	card_rates_size = sizeof(libertas_supported_rates);
@@ -401,41 +398,42 @@ int libertas_cmd_80211_associate(wlan_pr
 		goto done;
 	}
 
-	rates->header.len = min_t(size_t, strlen(rates->rates), WLAN_SUPPORTED_RATES);
-	adapter->curbssparams.numofrates = rates->header.len;
+	tmplen = min_t(size_t, strlen(rates->rates), WLAN_SUPPORTED_RATES);
+	adapter->curbssparams.numofrates = tmplen;
 
-	pos += sizeof(rates->header) + rates->header.len;
-	rates->header.len = cpu_to_le16(rates->header.len);
+	pos += sizeof(rates->header) + tmplen;
+	rates->header.len = cpu_to_le16(tmplen);
 
-	if (adapter->secinfo.WPAenabled || adapter->secinfo.WPA2enabled) {
+	if (assoc_req->secinfo.WPAenabled || assoc_req->secinfo.WPA2enabled) {
 		rsn = (struct mrvlietypes_rsnparamset *) pos;
-		rsn->header.type = (u16) adapter->wpa_ie[0];	/* WPA_IE or WPA2_IE */
-		rsn->header.type = cpu_to_le16(rsn->header.type);
-		rsn->header.len = (u16) adapter->wpa_ie[1];
-		memcpy(rsn->rsnie, &adapter->wpa_ie[2], rsn->header.len);
+		/* WPA_IE or WPA2_IE */
+		rsn->header.type = cpu_to_le16((u16) assoc_req->wpa_ie[0]);
+		tmplen = (u16) assoc_req->wpa_ie[1];
+		rsn->header.len = cpu_to_le16(tmplen);
+		memcpy(rsn->rsnie, &assoc_req->wpa_ie[2], tmplen);
 		lbs_dbg_hex("ASSOC_CMD: RSN IE", (u8 *) rsn,
-			sizeof(rsn->header) + rsn->header.len);
-		pos += sizeof(rsn->header) + rsn->header.len;
-		rsn->header.len = cpu_to_le16(rsn->header.len);
+			sizeof(rsn->header) + tmplen);
+		pos += sizeof(rsn->header) + tmplen;
 	}
 
 	/* update curbssparams */
-	adapter->curbssparams.channel =
-	    (pbssdesc->phyparamset.dsparamset.currentchan);
+	adapter->curbssparams.channel = bss->phyparamset.dsparamset.currentchan;
 
 	/* Copy the infra. association rates into Current BSS state structure */
 	memcpy(&adapter->curbssparams.datarates, &rates->rates,
-	       min_t(size_t, sizeof(adapter->curbssparams.datarates), rates->header.len));
+	       min_t(size_t, sizeof(adapter->curbssparams.datarates),
+		     cpu_to_le16(rates->header.len)));
 
-	lbs_pr_debug(1, "ASSOC_CMD: rates->header.len = %d\n", rates->header.len);
+	lbs_deb_join("ASSOC_CMD: rates->header.len = %d\n",
+		     cpu_to_le16(rates->header.len));
 
 	/* set IBSS field */
-	if (pbssdesc->mode == IW_MODE_INFRA) {
+	if (bss->mode == IW_MODE_INFRA) {
 #define CAPINFO_ESS_MODE 1
 		passo->capinfo.ess = CAPINFO_ESS_MODE;
 	}
 
-	if (libertas_parse_dnld_countryinfo_11d(priv)) {
+	if (libertas_parse_dnld_countryinfo_11d(priv, bss)) {
 		ret = -1;
 		goto done;
 	}
@@ -443,31 +441,28 @@ int libertas_cmd_80211_associate(wlan_pr
 	cmd->size = cpu_to_le16((u16) (pos - (u8 *) passo) + S_DS_GEN);
 
 	/* set the capability info at last */
-	memcpy(&tmpcap, &pbssdesc->cap, sizeof(passo->capinfo));
+	memcpy(&tmpcap, &bss->cap, sizeof(passo->capinfo));
 	tmpcap &= CAPINFO_MASK;
-	lbs_pr_debug(1, "ASSOC_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",
-	       tmpcap, CAPINFO_MASK);
-	tmpcap = cpu_to_le16(tmpcap);
+	lbs_deb_join("ASSOC_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",
+		     tmpcap, CAPINFO_MASK);
 	memcpy(&passo->capinfo, &tmpcap, sizeof(passo->capinfo));
 
-      done:
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
 int libertas_cmd_80211_ad_hoc_start(wlan_private * priv,
-				 struct cmd_ds_command *cmd, void *pssid)
+				 struct cmd_ds_command *cmd, void *pdata_buf)
 {
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_ad_hoc_start *adhs = &cmd->params.ads;
 	int ret = 0;
 	int cmdappendsize = 0;
 	int i;
-	u16 tmpcap;
-	struct bss_descriptor *pbssdesc;
-	struct WLAN_802_11_SSID *ssid = pssid;
+	struct assoc_request * assoc_req = pdata_buf;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	if (!adapter) {
 		ret = -1;
@@ -476,9 +471,6 @@ int libertas_cmd_80211_ad_hoc_start(wlan
 
 	cmd->command = cpu_to_le16(cmd_802_11_ad_hoc_start);
 
-	pbssdesc = &adapter->curbssparams.bssdescriptor;
-	adapter->pattemptedbssdesc = pbssdesc;
-
 	/*
 	 * Fill in the parameters for 2 data structures:
 	 *   1. cmd_ds_802_11_ad_hoc_start command
@@ -492,20 +484,16 @@ int libertas_cmd_80211_ad_hoc_start(wlan
 	 */
 
 	memset(adhs->SSID, 0, IW_ESSID_MAX_SIZE);
+	memcpy(adhs->SSID, assoc_req->ssid, assoc_req->ssid_len);
 
-	memcpy(adhs->SSID, ssid->ssid, ssid->ssidlength);
-
-	lbs_pr_debug(1, "ADHOC_S_CMD: SSID = %s\n", adhs->SSID);
-
-	memset(pbssdesc->ssid.ssid, 0, IW_ESSID_MAX_SIZE);
-	memcpy(pbssdesc->ssid.ssid, ssid->ssid, ssid->ssidlength);
-
-	pbssdesc->ssid.ssidlength = ssid->ssidlength;
+	lbs_deb_join("ADHOC_S_CMD: SSID '%s', ssid length %u\n",
+	             escape_essid(assoc_req->ssid, assoc_req->ssid_len),
+	             assoc_req->ssid_len);
 
 	/* set the BSS type */
 	adhs->bsstype = cmd_bss_type_ibss;
-	pbssdesc->mode = IW_MODE_ADHOC;
-	adhs->beaconperiod = adapter->beaconperiod;
+	adapter->mode = IW_MODE_ADHOC;
+	adhs->beaconperiod = cpu_to_le16(adapter->beaconperiod);
 
 	/* set Physical param set */
 #define DS_PARA_IE_ID   3
@@ -514,18 +502,12 @@ int libertas_cmd_80211_ad_hoc_start(wlan
 	adhs->phyparamset.dsparamset.elementid = DS_PARA_IE_ID;
 	adhs->phyparamset.dsparamset.len = DS_PARA_IE_LEN;
 
-	WARN_ON(!adapter->adhocchannel);
+	WARN_ON(!assoc_req->channel);
 
-	lbs_pr_debug(1, "ADHOC_S_CMD: Creating ADHOC on channel %d\n",
-	       adapter->adhocchannel);
+	lbs_deb_join("ADHOC_S_CMD: Creating ADHOC on channel %d\n",
+		     assoc_req->channel);
 
-	adapter->curbssparams.channel = adapter->adhocchannel;
-
-	pbssdesc->channel = adapter->adhocchannel;
-	adhs->phyparamset.dsparamset.currentchan = adapter->adhocchannel;
-
-	memcpy(&pbssdesc->phyparamset,
-	       &adhs->phyparamset, sizeof(union ieeetypes_phyparamset));
+	adhs->phyparamset.dsparamset.currentchan = assoc_req->channel;
 
 	/* set IBSS param set */
 #define IBSS_PARA_IE_ID   6
@@ -533,26 +515,21 @@ int libertas_cmd_80211_ad_hoc_start(wlan
 
 	adhs->ssparamset.ibssparamset.elementid = IBSS_PARA_IE_ID;
 	adhs->ssparamset.ibssparamset.len = IBSS_PARA_IE_LEN;
-	adhs->ssparamset.ibssparamset.atimwindow = adapter->atimwindow;
-	memcpy(&pbssdesc->ssparamset,
-	       &adhs->ssparamset, sizeof(union IEEEtypes_ssparamset));
+	adhs->ssparamset.ibssparamset.atimwindow = cpu_to_le16(adapter->atimwindow);
 
 	/* set capability info */
 	adhs->cap.ess = 0;
 	adhs->cap.ibss = 1;
-	pbssdesc->cap.ibss = 1;
 
 	/* probedelay */
 	adhs->probedelay = cpu_to_le16(cmd_scan_probe_delay_time);
 
 	/* set up privacy in adapter->scantable[i] */
-	if (adapter->secinfo.wep_enabled) {
-		lbs_pr_debug(1, "ADHOC_S_CMD: WEP enabled, setting privacy on\n");
-		pbssdesc->privacy = wlan802_11privfilter8021xWEP;
+	if (assoc_req->secinfo.wep_enabled) {
+		lbs_deb_join("ADHOC_S_CMD: WEP enabled, setting privacy on\n");
 		adhs->cap.privacy = AD_HOC_CAP_PRIVACY_ON;
 	} else {
-		lbs_pr_debug(1, "ADHOC_S_CMD: WEP disabled, setting privacy off\n");
-		pbssdesc->privacy = wlan802_11privfilteracceptall;
+		lbs_deb_join("ADHOC_S_CMD: WEP disabled, setting privacy off\n");
 	}
 
 	memset(adhs->datarate, 0, sizeof(adhs->datarate));
@@ -574,29 +551,24 @@ int libertas_cmd_80211_ad_hoc_start(wlan
 	memcpy(&adapter->curbssparams.datarates,
 	       &adhs->datarate, adapter->curbssparams.numofrates);
 
-	lbs_pr_debug(1, "ADHOC_S_CMD: rates=%02x %02x %02x %02x \n",
+	lbs_deb_join("ADHOC_S_CMD: rates=%02x %02x %02x %02x \n",
 	       adhs->datarate[0], adhs->datarate[1],
 	       adhs->datarate[2], adhs->datarate[3]);
 
-	lbs_pr_debug(1, "ADHOC_S_CMD: AD HOC Start command is ready\n");
+	lbs_deb_join("ADHOC_S_CMD: AD HOC Start command is ready\n");
 
 	if (libertas_create_dnld_countryinfo_11d(priv)) {
-		lbs_pr_debug(1, "ADHOC_S_CMD: dnld_countryinfo_11d failed\n");
+		lbs_deb_join("ADHOC_S_CMD: dnld_countryinfo_11d failed\n");
 		ret = -1;
 		goto done;
 	}
 
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_ad_hoc_start)
-			     + S_DS_GEN + cmdappendsize);
-
-	memcpy(&tmpcap, &adhs->cap, sizeof(u16));
-	tmpcap = cpu_to_le16(tmpcap);
-	memcpy(&adhs->cap, &tmpcap, sizeof(u16));
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_ad_hoc_start) +
+				S_DS_GEN + cmdappendsize);
 
 	ret = 0;
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
@@ -614,7 +586,8 @@ int libertas_cmd_80211_ad_hoc_join(wlan_
 {
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_ad_hoc_join *padhocjoin = &cmd->params.adj;
-	struct bss_descriptor *pbssdesc = pdata_buf;
+	struct assoc_request * assoc_req = pdata_buf;
+	struct bss_descriptor *bss = &assoc_req->bss;
 	int cmdappendsize = 0;
 	int ret = 0;
 	u8 *card_rates;
@@ -622,70 +595,59 @@ int libertas_cmd_80211_ad_hoc_join(wlan_
 	u16 tmpcap;
 	int i;
 
-	ENTER();
-
-	adapter->pattemptedbssdesc = pbssdesc;
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	cmd->command = cpu_to_le16(cmd_802_11_ad_hoc_join);
 
 	padhocjoin->bssdescriptor.bsstype = cmd_bss_type_ibss;
 
-	padhocjoin->bssdescriptor.beaconperiod = pbssdesc->beaconperiod;
-
-	memcpy(&padhocjoin->bssdescriptor.BSSID,
-	       &pbssdesc->macaddress, ETH_ALEN);
+	padhocjoin->bssdescriptor.beaconperiod = cpu_to_le16(bss->beaconperiod);
 
-	memcpy(&padhocjoin->bssdescriptor.SSID,
-	       &pbssdesc->ssid.ssid, pbssdesc->ssid.ssidlength);
+	memcpy(&padhocjoin->bssdescriptor.BSSID, &bss->bssid, ETH_ALEN);
+	memcpy(&padhocjoin->bssdescriptor.SSID, &bss->ssid, bss->ssid_len);
 
 	memcpy(&padhocjoin->bssdescriptor.phyparamset,
-	       &pbssdesc->phyparamset, sizeof(union ieeetypes_phyparamset));
+	       &bss->phyparamset, sizeof(union ieeetypes_phyparamset));
 
 	memcpy(&padhocjoin->bssdescriptor.ssparamset,
-	       &pbssdesc->ssparamset, sizeof(union IEEEtypes_ssparamset));
+	       &bss->ssparamset, sizeof(union IEEEtypes_ssparamset));
 
-	memcpy(&tmpcap, &pbssdesc->cap, sizeof(struct ieeetypes_capinfo));
+	memcpy(&tmpcap, &bss->cap, sizeof(struct ieeetypes_capinfo));
 	tmpcap &= CAPINFO_MASK;
 
-	lbs_pr_debug(1, "ADHOC_J_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",
+	lbs_deb_join("ADHOC_J_CMD: tmpcap=%4X CAPINFO_MASK=%4X\n",
 	       tmpcap, CAPINFO_MASK);
 	memcpy(&padhocjoin->bssdescriptor.cap, &tmpcap,
 	       sizeof(struct ieeetypes_capinfo));
 
 	/* information on BSSID descriptor passed to FW */
-    lbs_pr_debug(1,
-	       "ADHOC_J_CMD: BSSID = %2x-%2x-%2x-%2x-%2x-%2x, SSID = %s\n",
-	       padhocjoin->bssdescriptor.BSSID[0],
-	       padhocjoin->bssdescriptor.BSSID[1],
-	       padhocjoin->bssdescriptor.BSSID[2],
-	       padhocjoin->bssdescriptor.BSSID[3],
-	       padhocjoin->bssdescriptor.BSSID[4],
-	       padhocjoin->bssdescriptor.BSSID[5],
+	lbs_deb_join(
+	       "ADHOC_J_CMD: BSSID = " MAC_FMT ", SSID = '%s'\n",
+	       MAC_ARG(padhocjoin->bssdescriptor.BSSID),
 	       padhocjoin->bssdescriptor.SSID);
 
 	/* failtimeout */
 	padhocjoin->failtimeout = cpu_to_le16(MRVDRV_ASSOCIATION_TIME_OUT);
 
 	/* probedelay */
-	padhocjoin->probedelay =
-	    cpu_to_le16(cmd_scan_probe_delay_time);
+	padhocjoin->probedelay = cpu_to_le16(cmd_scan_probe_delay_time);
 
 	/* Copy Data rates from the rates recorded in scan response */
 	memset(padhocjoin->bssdescriptor.datarates, 0,
 	       sizeof(padhocjoin->bssdescriptor.datarates));
-	memcpy(padhocjoin->bssdescriptor.datarates, pbssdesc->datarates,
+	memcpy(padhocjoin->bssdescriptor.datarates, bss->datarates,
 	       min(sizeof(padhocjoin->bssdescriptor.datarates),
-		   sizeof(pbssdesc->datarates)));
+		   sizeof(bss->datarates)));
 
 	card_rates = libertas_supported_rates;
 	card_rates_size = sizeof(libertas_supported_rates);
 
-	adapter->curbssparams.channel = pbssdesc->channel;
+	adapter->curbssparams.channel = bss->channel;
 
 	if (get_common_rates(adapter, padhocjoin->bssdescriptor.datarates,
 			     sizeof(padhocjoin->bssdescriptor.datarates),
 			     card_rates, card_rates_size)) {
-		lbs_pr_debug(1, "ADHOC_J_CMD: get_common_rates returns error.\n");
+		lbs_deb_join("ADHOC_J_CMD: get_common_rates returns error.\n");
 		ret = -1;
 		goto done;
 	}
@@ -704,17 +666,17 @@ int libertas_cmd_80211_ad_hoc_join(wlan_
 	       adapter->curbssparams.numofrates);
 
 	padhocjoin->bssdescriptor.ssparamset.ibssparamset.atimwindow =
-	    cpu_to_le16(pbssdesc->atimwindow);
+	    cpu_to_le16(bss->atimwindow);
 
-	if (adapter->secinfo.wep_enabled) {
+	if (assoc_req->secinfo.wep_enabled) {
 		padhocjoin->bssdescriptor.cap.privacy = AD_HOC_CAP_PRIVACY_ON;
 	}
 
 	if (adapter->psmode == wlan802_11powermodemax_psp) {
 		/* wake up first */
-		enum WLAN_802_11_POWER_MODE Localpsmode;
+		__le32 Localpsmode;
 
-		Localpsmode = wlan802_11powermodecam;
+		Localpsmode = cpu_to_le32(wlan802_11powermodecam);
 		ret = libertas_prepare_and_send_command(priv,
 					    cmd_802_11_ps_mode,
 					    cmd_act_set,
@@ -726,24 +688,16 @@ int libertas_cmd_80211_ad_hoc_join(wlan_
 		}
 	}
 
-	if (libertas_parse_dnld_countryinfo_11d(priv)) {
+	if (libertas_parse_dnld_countryinfo_11d(priv, bss)) {
 		ret = -1;
 		goto done;
 	}
 
-	cmd->size =
-	    cpu_to_le16(sizeof(struct cmd_ds_802_11_ad_hoc_join)
-			     + S_DS_GEN + cmdappendsize);
-
-	memcpy(&tmpcap, &padhocjoin->bssdescriptor.cap,
-	       sizeof(struct ieeetypes_capinfo));
-	tmpcap = cpu_to_le16(tmpcap);
-
-	memcpy(&padhocjoin->bssdescriptor.cap,
-	       &tmpcap, sizeof(struct ieeetypes_capinfo));
+	cmd->size = cpu_to_le16(sizeof(struct cmd_ds_802_11_ad_hoc_join) +
+				S_DS_GEN + cmdappendsize);
 
-      done:
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
@@ -754,19 +708,24 @@ int libertas_ret_80211_associate(wlan_pr
 	int ret = 0;
 	union iwreq_data wrqu;
 	struct ieeetypes_assocrsp *passocrsp;
-	struct bss_descriptor *pbssdesc;
+	struct bss_descriptor * bss;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
-	passocrsp = (struct ieeetypes_assocrsp *) & resp->params;
+	if (!adapter->in_progress_assoc_req) {
+		lbs_deb_join("ASSOC_RESP: no in-progress association request\n");
+		ret = -1;
+		goto done;
+	}
+	bss = &adapter->in_progress_assoc_req->bss;
 
-	if (passocrsp->statuscode) {
+	passocrsp = (struct ieeetypes_assocrsp *) & resp->params;
 
+	if (le16_to_cpu(passocrsp->statuscode)) {
 		libertas_mac_event_disconnected(priv);
 
-        lbs_pr_debug(1,
-		       "ASSOC_RESP: Association failed, status code = %d\n",
-		       passocrsp->statuscode);
+		lbs_deb_join("ASSOC_RESP: Association failed, status code = %d\n",
+			     le16_to_cpu(passocrsp->statuscode));
 
 		ret = -1;
 		goto done;
@@ -778,24 +737,15 @@ int libertas_ret_80211_associate(wlan_pr
 	/* Send a Media Connected event, according to the Spec */
 	adapter->connect_status = libertas_connected;
 
-	/* Set the attempted BSSID Index to current */
-	pbssdesc = adapter->pattemptedbssdesc;
+	lbs_deb_join("ASSOC_RESP: assocated to '%s'\n",
+	             escape_essid(bss->ssid, bss->ssid_len));
 
-	lbs_pr_debug(1, "ASSOC_RESP: %s\n", pbssdesc->ssid.ssid);
+	/* Update current SSID and BSSID */
+	memcpy(&adapter->curbssparams.ssid, &bss->ssid, IW_ESSID_MAX_SIZE);
+	adapter->curbssparams.ssid_len = bss->ssid_len;
+	memcpy(adapter->curbssparams.bssid, bss->bssid, ETH_ALEN);
 
-	/* Set the new SSID to current SSID */
-	memcpy(&adapter->curbssparams.ssid,
-	       &pbssdesc->ssid, sizeof(struct WLAN_802_11_SSID));
-
-	/* Set the new BSSID (AP's MAC address) to current BSSID */
-	memcpy(adapter->curbssparams.bssid,
-	       pbssdesc->macaddress, ETH_ALEN);
-
-	/* Make a copy of current BSSID descriptor */
-	memcpy(&adapter->curbssparams.bssdescriptor,
-	       pbssdesc, sizeof(struct bss_descriptor));
-
-	lbs_pr_debug(1, "ASSOC_RESP: currentpacketfilter is %x\n",
+	lbs_deb_join("ASSOC_RESP: currentpacketfilter is %x\n",
 	       adapter->currentpacketfilter);
 
 	adapter->SNR[TYPE_RXPD][TYPE_AVG] = 0;
@@ -806,28 +756,31 @@ int libertas_ret_80211_associate(wlan_pr
 	adapter->nextSNRNF = 0;
 	adapter->numSNRNF = 0;
 
-	netif_carrier_on(priv->wlan_dev.netdev);
-	netif_wake_queue(priv->wlan_dev.netdev);
+	netif_carrier_on(priv->dev);
+	netif_wake_queue(priv->dev);
 
-	lbs_pr_debug(1, "ASSOC_RESP: Associated \n");
+	netif_carrier_on(priv->mesh_dev);
+	netif_wake_queue(priv->mesh_dev);
+
+	lbs_deb_join("ASSOC_RESP: Associated \n");
 
 	memcpy(wrqu.ap_addr.sa_data, adapter->curbssparams.bssid, ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
 
-      done:
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
 int libertas_ret_80211_disassociate(wlan_private * priv,
 				 struct cmd_ds_command *resp)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	libertas_mac_event_disconnected(priv);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_JOIN);
 	return 0;
 }
 
@@ -840,90 +793,85 @@ int libertas_ret_80211_ad_hoc_start(wlan
 	u16 result = le16_to_cpu(resp->result);
 	struct cmd_ds_802_11_ad_hoc_result *padhocresult;
 	union iwreq_data wrqu;
-	struct bss_descriptor *pbssdesc;
+	struct bss_descriptor *bss;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	padhocresult = &resp->params.result;
 
-	lbs_pr_debug(1, "ADHOC_S_RESP: size = %d\n", le16_to_cpu(resp->size));
-	lbs_pr_debug(1, "ADHOC_S_RESP: command = %x\n", command);
-	lbs_pr_debug(1, "ADHOC_S_RESP: result = %x\n", result);
+	lbs_deb_join("ADHOC_RESP: size = %d\n", le16_to_cpu(resp->size));
+	lbs_deb_join("ADHOC_RESP: command = %x\n", command);
+	lbs_deb_join("ADHOC_RESP: result = %x\n", result);
 
-	pbssdesc = adapter->pattemptedbssdesc;
+	if (!adapter->in_progress_assoc_req) {
+		lbs_deb_join("ADHOC_RESP: no in-progress association request\n");
+		ret = -1;
+		goto done;
+	}
+	bss = &adapter->in_progress_assoc_req->bss;
 
 	/*
 	 * Join result code 0 --> SUCCESS
 	 */
 	if (result) {
-		lbs_pr_debug(1, "ADHOC_RESP failed\n");
+		lbs_deb_join("ADHOC_RESP: failed\n");
 		if (adapter->connect_status == libertas_connected) {
 			libertas_mac_event_disconnected(priv);
 		}
-
-		memset(&adapter->curbssparams.bssdescriptor,
-		       0x00, sizeof(adapter->curbssparams.bssdescriptor));
-
-		LEAVE();
-		return -1;
+		ret = -1;
+		goto done;
 	}
 
 	/*
 	 * Now the join cmd should be successful
 	 * If BSSID has changed use SSID to compare instead of BSSID
 	 */
-	lbs_pr_debug(1, "ADHOC_J_RESP  %s\n", pbssdesc->ssid.ssid);
+	lbs_deb_join("ADHOC_RESP: associated to '%s'\n",
+	             escape_essid(bss->ssid, bss->ssid_len));
 
 	/* Send a Media Connected event, according to the Spec */
 	adapter->connect_status = libertas_connected;
 
 	if (command == cmd_ret_802_11_ad_hoc_start) {
 		/* Update the created network descriptor with the new BSSID */
-		memcpy(pbssdesc->macaddress,
-		       padhocresult->BSSID, ETH_ALEN);
-	} else {
-
-		/* Make a copy of current BSSID descriptor, only needed for join since
-		 *   the current descriptor is already being used for adhoc start
-		 */
-		memmove(&adapter->curbssparams.bssdescriptor,
-			pbssdesc, sizeof(struct bss_descriptor));
+		memcpy(bss->bssid, padhocresult->BSSID, ETH_ALEN);
 	}
 
 	/* Set the BSSID from the joined/started descriptor */
-	memcpy(&adapter->curbssparams.bssid,
-	       pbssdesc->macaddress, ETH_ALEN);
+	memcpy(&adapter->curbssparams.bssid, bss->bssid, ETH_ALEN);
 
 	/* Set the new SSID to current SSID */
-	memcpy(&adapter->curbssparams.ssid,
-	       &pbssdesc->ssid, sizeof(struct WLAN_802_11_SSID));
+	memcpy(&adapter->curbssparams.ssid, &bss->ssid, IW_ESSID_MAX_SIZE);
+	adapter->curbssparams.ssid_len = bss->ssid_len;
 
-	netif_carrier_on(priv->wlan_dev.netdev);
-	netif_wake_queue(priv->wlan_dev.netdev);
+	netif_carrier_on(priv->dev);
+	netif_wake_queue(priv->dev);
+
+	netif_carrier_on(priv->mesh_dev);
+	netif_wake_queue(priv->mesh_dev);
 
 	memset(&wrqu, 0, sizeof(wrqu));
 	memcpy(wrqu.ap_addr.sa_data, adapter->curbssparams.bssid, ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
+	wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
 
-	lbs_pr_debug(1, "ADHOC_RESP: - Joined/Started Ad Hoc\n");
-	lbs_pr_debug(1, "ADHOC_RESP: channel = %d\n", adapter->adhocchannel);
-	lbs_pr_debug(1, "ADHOC_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
-	       padhocresult->BSSID[0], padhocresult->BSSID[1],
-	       padhocresult->BSSID[2], padhocresult->BSSID[3],
-	       padhocresult->BSSID[4], padhocresult->BSSID[5]);
+	lbs_deb_join("ADHOC_RESP: - Joined/Started Ad Hoc\n");
+	lbs_deb_join("ADHOC_RESP: channel = %d\n", adapter->curbssparams.channel);
+	lbs_deb_join("ADHOC_RESP: BSSID = " MAC_FMT "\n",
+	       MAC_ARG(padhocresult->BSSID));
 
-	LEAVE();
+done:
+	lbs_deb_leave_args(LBS_DEB_JOIN, "ret %d", ret);
 	return ret;
 }
 
 int libertas_ret_80211_ad_hoc_stop(wlan_private * priv,
 				struct cmd_ds_command *resp)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_JOIN);
 
 	libertas_mac_event_disconnected(priv);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_JOIN);
 	return 0;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/join.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/join.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/join.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/join.h	2007-06-14 14:14:33.000000000 -0400
@@ -9,6 +9,7 @@
 #define _WLAN_JOIN_H
 
 #include "defs.h"
+#include "dev.h"
 
 struct cmd_ds_command;
 extern int libertas_cmd_80211_authenticate(wlan_private * priv,
@@ -21,7 +22,7 @@ extern int libertas_cmd_80211_ad_hoc_sto
 				       struct cmd_ds_command *cmd);
 extern int libertas_cmd_80211_ad_hoc_start(wlan_private * priv,
 					struct cmd_ds_command *cmd,
-					void *pssid);
+					void *pdata_buf);
 extern int libertas_cmd_80211_deauthenticate(wlan_private * priv,
 					  struct cmd_ds_command *cmd);
 extern int libertas_cmd_80211_associate(wlan_private * priv,
@@ -39,12 +40,10 @@ extern int libertas_ret_80211_associate(
 
 extern int libertas_reassociation_thread(void *data);
 
-struct WLAN_802_11_SSID;
-struct bss_descriptor;
-
 extern int libertas_start_adhoc_network(wlan_private * priv,
-			     struct WLAN_802_11_SSID *adhocssid);
-extern int libertas_join_adhoc_network(wlan_private * priv, struct bss_descriptor *pbssdesc);
+			     struct assoc_request * assoc_req);
+extern int libertas_join_adhoc_network(wlan_private * priv,
+				struct assoc_request * assoc_req);
 extern int libertas_stop_adhoc_network(wlan_private * priv);
 
 extern int libertas_send_deauthentication(wlan_private * priv);
@@ -52,6 +51,6 @@ extern int libertas_send_deauth(wlan_pri
 
 extern int libertas_do_adhocstop_ioctl(wlan_private * priv);
 
-int wlan_associate(wlan_private * priv, struct bss_descriptor * pbssdesc);
+int wlan_associate(wlan_private * priv, struct assoc_request * assoc_req);
 
 #endif
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/main.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/main.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/main.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/main.c	2007-06-14 14:14:33.000000000 -0400
@@ -4,6 +4,7 @@
   * thread etc..
   */
 
+#include <linux/moduleparam.h>
 #include <linux/delay.h>
 #include <linux/freezer.h>
 #include <linux/etherdevice.h>
@@ -11,26 +12,28 @@
 #include <linux/if_arp.h>
 
 #include <net/iw_handler.h>
+#include <net/ieee80211.h>
 
 #include "host.h"
-#include "sbi.h"
 #include "decl.h"
 #include "dev.h"
-#include "fw.h"
 #include "wext.h"
 #include "debugfs.h"
 #include "assoc.h"
 
-#define DRIVER_RELEASE_VERSION "320.p0"
+#define DRIVER_RELEASE_VERSION "322.p0"
 const char libertas_driver_version[] = "COMM-USB8388-" DRIVER_RELEASE_VERSION
 #ifdef  DEBUG
     "-dbg"
 #endif
     "";
 
-#ifdef ENABLE_PM
-static struct pm_dev *wlan_pm_dev = NULL;
-#endif
+
+/* Module parameters */
+unsigned int libertas_debug = 0;
+module_param(libertas_debug, int, 0644);
+EXPORT_SYMBOL_GPL(libertas_debug);
+
 
 #define WLAN_TX_PWR_DEFAULT		20	/*100mW */
 #define WLAN_TX_PWR_US_DEFAULT		20	/*100mW */
@@ -146,14 +149,6 @@ static struct region_cfp_table region_cf
 };
 
 /**
- * the rates supported by the card
- */
-u8 libertas_wlan_data_rates[WLAN_SUPPORTED_RATES] =
-    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
-	0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
-};
-
-/**
  * the rates supported
  */
 u8 libertas_supported_rates[G_SUPPORTED_RATES] =
@@ -173,66 +168,55 @@ u8 libertas_adhoc_rates_g[G_SUPPORTED_RA
 u8 libertas_adhoc_rates_b[4] = { 0x82, 0x84, 0x8b, 0x96 };
 
 /**
- * the global variable of a pointer to wlan_private
- * structure variable
- */
-static wlan_private *wlanpriv = NULL;
-
-#define MAX_DEVS 5
-static struct net_device *libertas_devs[MAX_DEVS];
-static int libertas_found = 0;
-
-/**
  * the table to keep region code
  */
 u16 libertas_region_code_to_index[MRVDRV_MAX_REGION_CODE] =
     { 0x10, 0x20, 0x30, 0x31, 0x32, 0x40 };
 
-static u8 *default_fw_name = "usb8388.bin";
-
 /**
  * Attributes exported through sysfs
  */
 
 /**
- * @brief Get function for sysfs attribute libertas_mpp
+ * @brief Get function for sysfs attribute anycast_mask
  */
-static ssize_t libertas_mpp_get(struct device * dev,
+static ssize_t libertas_anycast_get(struct device * dev,
 		struct device_attribute *attr, char * buf) {
 	struct cmd_ds_mesh_access mesh_access;
 
 	memset(&mesh_access, 0, sizeof(mesh_access));
 	libertas_prepare_and_send_command(to_net_dev(dev)->priv,
 			cmd_mesh_access,
-			cmd_act_mesh_get_mpp,
+			cmd_act_mesh_get_anycast,
 			cmd_option_waitforrsp, 0, (void *)&mesh_access);
 
-	return snprintf(buf, 3, "%d\n", mesh_access.data[0]);
+	return snprintf(buf, 12, "0x%X\n", le32_to_cpu(mesh_access.data[0]));
 }
 
 /**
- * @brief Set function for sysfs attribute libertas_mpp
+ * @brief Set function for sysfs attribute anycast_mask
  */
-static ssize_t libertas_mpp_set(struct device * dev,
+static ssize_t libertas_anycast_set(struct device * dev,
 		struct device_attribute *attr, const char * buf, size_t count) {
 	struct cmd_ds_mesh_access mesh_access;
-
+	uint32_t datum;
 
 	memset(&mesh_access, 0, sizeof(mesh_access));
-	sscanf(buf, "%d", &(mesh_access.data[0]));
+	sscanf(buf, "%x", &datum);
+	mesh_access.data[0] = cpu_to_le32(datum);
+
 	libertas_prepare_and_send_command((to_net_dev(dev))->priv,
 			cmd_mesh_access,
-			cmd_act_mesh_set_mpp,
+			cmd_act_mesh_set_anycast,
 			cmd_option_waitforrsp, 0, (void *)&mesh_access);
 	return strlen(buf);
 }
 
 /**
- * libertas_mpp attribute to be exported per mshX interface
- * through sysfs (/sys/class/net/mshX/libertas-mpp)
+ * anycast_mask attribute to be exported per mshX interface
+ * through sysfs (/sys/class/net/mshX/anycast_mask)
  */
-static DEVICE_ATTR(libertas_mpp, 0644, libertas_mpp_get,
-		libertas_mpp_set );
+static DEVICE_ATTR(anycast_mask, 0644, libertas_anycast_get, libertas_anycast_set);
 
 /**
  *  @brief Check if the device can be open and wait if necessary.
@@ -245,7 +229,8 @@ static DEVICE_ATTR(libertas_mpp, 0644, l
  * function to work around the issue.
  *
  */
-static int pre_open_check(struct net_device *dev) {
+static int pre_open_check(struct net_device *dev)
+{
 	wlan_private *priv = (wlan_private *) dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 	int i = 0;
@@ -255,8 +240,7 @@ static int pre_open_check(struct net_dev
 		msleep_interruptible(100);
 	}
 	if (!adapter->fw_ready) {
-		lbs_pr_info("FW not ready, pre_open_check() return failure\n");
-		LEAVE();
+		lbs_pr_err("firmware not ready\n");
 		return -1;
 	}
 
@@ -274,17 +258,19 @@ static int wlan_dev_open(struct net_devi
 	wlan_private *priv = (wlan_private *) dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
-
+	lbs_deb_enter(LBS_DEB_NET);
 
 	priv->open = 1;
 
 	if (adapter->connect_status == libertas_connected) {
-		netif_carrier_on(priv->wlan_dev.netdev);
-	} else
-		netif_carrier_off(priv->wlan_dev.netdev);
+		netif_carrier_on(priv->dev);
+		netif_carrier_on(priv->mesh_dev);
+	} else {
+		netif_carrier_off(priv->dev);
+		netif_carrier_off(priv->mesh_dev);
+	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_NET);
 	return 0;
 }
 /**
@@ -297,12 +283,12 @@ static int mesh_open(struct net_device *
 {
 	wlan_private *priv = (wlan_private *) dev->priv ;
 
-	if(pre_open_check(dev) == -1)
+	if (pre_open_check(dev) == -1)
 		return -1;
 	priv->mesh_open = 1 ;
-	netif_start_queue(priv->mesh_dev);
+	netif_wake_queue(priv->mesh_dev);
 	if (priv->infra_open == 0)
-		return wlan_dev_open(priv->wlan_dev.netdev) ;
+		return wlan_dev_open(priv->dev) ;
 	return 0;
 }
 
@@ -319,9 +305,9 @@ static int wlan_open(struct net_device *
 	if(pre_open_check(dev) == -1)
 		return -1;
 	priv->infra_open = 1 ;
-	netif_wake_queue(priv->wlan_dev.netdev);
+	netif_wake_queue(priv->dev);
 	if (priv->open == 0)
-		return wlan_dev_open(priv->wlan_dev.netdev) ;
+		return wlan_dev_open(priv->dev) ;
 	return 0;
 }
 
@@ -329,12 +315,12 @@ static int wlan_dev_close(struct net_dev
 {
 	wlan_private *priv = dev->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
 
-	netif_carrier_off(priv->wlan_dev.netdev);
+	netif_carrier_off(priv->dev);
 	priv->open = 0;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_NET);
 	return 0;
 }
 
@@ -351,7 +337,7 @@ static int mesh_close(struct net_device 
 	priv->mesh_open = 0;
 	netif_stop_queue(priv->mesh_dev);
 	if (priv->infra_open == 0)
-		return wlan_dev_close( ((wlan_private *) dev->priv)->wlan_dev.netdev) ;
+		return wlan_dev_close(dev);
 	else
 		return 0;
 }
@@ -362,147 +348,38 @@ static int mesh_close(struct net_device 
  *  @param dev     A pointer to net_device structure
  *  @return 	   0
  */
-static int wlan_close(struct net_device *dev) {
+static int wlan_close(struct net_device *dev)
+{
 	wlan_private *priv = (wlan_private *) dev->priv;
 
-	netif_stop_queue(priv->wlan_dev.netdev);
+	netif_stop_queue(dev);
 	priv->infra_open = 0;
 	if (priv->mesh_open == 0)
-		return wlan_dev_close( ((wlan_private *) dev->priv)->wlan_dev.netdev) ;
+		return wlan_dev_close(dev);
 	else
 		return 0;
 }
 
 
-#ifdef ENABLE_PM
-
-/**
- *  @brief This function is a callback function. it is called by
- *  kernel to enter or exit power saving mode.
- *
- *  @param pmdev   A pointer to pm_dev
- *  @param pmreq   pm_request_t
- *  @param pmdata  A pointer to pmdata
- *  @return 	   0 or -1
- */
-static int wlan_pm_callback(struct pm_dev *pmdev, pm_request_t pmreq,
-			    void *pmdata)
-{
-	wlan_private *priv = wlanpriv;
-	wlan_adapter *adapter = priv->adapter;
-	struct net_device *dev = priv->wlan_dev.netdev;
-
-	lbs_pr_debug(1, "WPRM_PM_CALLBACK: pmreq = %d.\n", pmreq);
-
-	switch (pmreq) {
-	case PM_SUSPEND:
-		lbs_pr_debug(1, "WPRM_PM_CALLBACK: enter PM_SUSPEND.\n");
-
-		/* in associated mode */
-		if (adapter->connect_status == libertas_connected) {
-			if ((adapter->psstate != PS_STATE_SLEEP)
-			    ) {
-				lbs_pr_debug(1,
-				       "wlan_pm_callback: can't enter sleep mode\n");
-				return -1;
-			} else {
-
-				/*
-				 * Detach the network interface
-				 * if the network is running
-				 */
-				if (netif_running(dev)) {
-					netif_device_detach(dev);
-					lbs_pr_debug(1,
-					       "netif_device_detach().\n");
-				}
-				libertas_sbi_suspend(priv);
-			}
-			break;
-		}
-
-		/* in non associated mode */
-
-		/*
-		 * Detach the network interface
-		 * if the network is running
-		 */
-		if (netif_running(dev))
-			netif_device_detach(dev);
-
-		/*
-		 * Storing and restoring of the regs be taken care
-		 * at the driver rest will be done at wlan driver
-		 * this makes driver independent of the card
-		 */
-
-		libertas_sbi_suspend(priv);
-
-		break;
-
-	case PM_RESUME:
-		/* in associated mode */
-		if (adapter->connect_status == libertas_connected) {
-			{
-				/*
-				 * Bring the inteface up first
-				 * This case should not happen still ...
-				 */
-				libertas_sbi_resume(priv);
-
-				/*
-				 * Attach the network interface
-				 * if the network is running
-				 */
-				if (netif_running(dev)) {
-					netif_device_attach(dev);
-					lbs_pr_debug(1,
-					       "after netif_device_attach().\n");
-				}
-				lbs_pr_debug(1,
-				       "After netif attach, in associated mode.\n");
-			}
-			break;
-		}
-
-		/* in non associated mode */
-
-		/*
-		 * Bring the inteface up first
-		 * This case should not happen still ...
-		 */
-
-		libertas_sbi_resume(priv);
-
-		if (netif_running(dev))
-			netif_device_attach(dev);
-
-		lbs_pr_debug(1, "after netif attach, in NON associated mode.\n");
-		break;
-	}
-
-	return 0;
-}
-#endif				/* ENABLE_PM */
-
 static int wlan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	int ret = 0;
 	wlan_private *priv = dev->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
 
-	if (priv->wlan_dev.dnld_sent || priv->adapter->TxLockFlag) {
+	if (priv->dnld_sent || priv->adapter->TxLockFlag) {
 		priv->stats.tx_dropped++;
 		goto done;
 	}
 
-	netif_stop_queue(priv->wlan_dev.netdev);
+	netif_stop_queue(priv->dev);
+	netif_stop_queue(priv->mesh_dev);
 
 	if (libertas_process_tx(priv, skb) == 0)
 		dev->trans_start = jiffies;
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_NET, "ret %d", ret);
 	return ret;
 }
 
@@ -513,33 +390,43 @@ done:
 static int mesh_pre_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	wlan_private *priv = dev->priv;
-	ENTER();
+	int ret;
+
+	lbs_deb_enter(LBS_DEB_MESH);
+
 	SET_MESH_FRAME(skb);
-	LEAVE();
 
-	return wlan_hard_start_xmit(skb, priv->wlan_dev.netdev);
+	ret = wlan_hard_start_xmit(skb, priv->dev);
+	lbs_deb_leave_args(LBS_DEB_MESH, "ret %d", ret);
+	return ret;
 }
 
 /**
  * @brief Mark non-mesh packets and handover them to wlan_hard_start_xmit
  *
  */
-static int wlan_pre_start_xmit(struct sk_buff *skb, struct net_device *dev) {
-	ENTER();
+static int wlan_pre_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int ret;
+
+	lbs_deb_enter(LBS_DEB_NET);
+
 	UNSET_MESH_FRAME(skb);
-	LEAVE();
-	return wlan_hard_start_xmit(skb, dev);
+
+	ret = wlan_hard_start_xmit(skb, dev);
+	lbs_deb_leave_args(LBS_DEB_NET, "ret %d", ret);
+	return ret;
 }
 
 static void wlan_tx_timeout(struct net_device *dev)
 {
 	wlan_private *priv = (wlan_private *) dev->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_TX);
 
-	lbs_pr_err("tx watch dog timeout!\n");
+	lbs_pr_err("tx watch dog timeout\n");
 
-	priv->wlan_dev.dnld_sent = DNLD_RES_RECEIVED;
+	priv->dnld_sent = DNLD_RES_RECEIVED;
 	dev->trans_start = jiffies;
 
 	if (priv->adapter->currenttxskb) {
@@ -550,10 +437,12 @@ static void wlan_tx_timeout(struct net_d
 			libertas_send_tx_feedback(priv);
 		} else
 			wake_up_interruptible(&priv->mainthread.waitq);
-	} else if (priv->adapter->connect_status == libertas_connected)
-		netif_wake_queue(priv->wlan_dev.netdev);
+	} else if (priv->adapter->connect_status == libertas_connected) {
+		netif_wake_queue(priv->dev);
+		netif_wake_queue(priv->mesh_dev);
+	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_TX);
 }
 
 /**
@@ -576,7 +465,10 @@ static int wlan_set_mac_address(struct n
 	wlan_adapter *adapter = priv->adapter;
 	struct sockaddr *phwaddr = addr;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
+
+	/* In case it was called from the mesh device */
+	dev = priv->dev ;
 
 	memset(adapter->current_addr, 0, ETH_ALEN);
 
@@ -591,17 +483,18 @@ static int wlan_set_mac_address(struct n
 				    cmd_option_waitforrsp, 0, NULL);
 
 	if (ret) {
-		lbs_pr_debug(1, "set mac address failed.\n");
+		lbs_deb_net("set MAC address failed\n");
 		ret = -1;
 		goto done;
 	}
 
 	lbs_dbg_hex("adapter->macaddr:", adapter->current_addr, ETH_ALEN);
 	memcpy(dev->dev_addr, adapter->current_addr, ETH_ALEN);
-	memcpy(((wlan_private *) dev->priv)->mesh_dev->dev_addr, adapter->current_addr, ETH_ALEN);
+	if (priv->mesh_dev)
+		memcpy(priv->mesh_dev->dev_addr, adapter->current_addr, ETH_ALEN);
 
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_NET, "ret %d", ret);
 	return ret;
 }
 
@@ -626,12 +519,12 @@ static void wlan_set_multicast_list(stru
 	wlan_adapter *adapter = priv->adapter;
 	int oldpacketfilter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
 
 	oldpacketfilter = adapter->currentpacketfilter;
 
 	if (dev->flags & IFF_PROMISC) {
-		lbs_pr_debug(1, "enable Promiscuous mode\n");
+		lbs_deb_net("enable promiscuous mode\n");
 		adapter->currentpacketfilter |=
 		    cmd_act_mac_promiscuous_enable;
 		adapter->currentpacketfilter &=
@@ -644,7 +537,7 @@ static void wlan_set_multicast_list(stru
 
 		if (dev->flags & IFF_ALLMULTI || dev->mc_count >
 		    MRVDRV_MAX_MULTICAST_LIST_SIZE) {
-			lbs_pr_debug(1, "Enabling All Multicast!\n");
+			lbs_deb_net( "enabling all multicast\n");
 			adapter->currentpacketfilter |=
 			    cmd_act_mac_all_multicast_enable;
 			adapter->currentpacketfilter &=
@@ -654,8 +547,8 @@ static void wlan_set_multicast_list(stru
 			    ~cmd_act_mac_all_multicast_enable;
 
 			if (!dev->mc_count) {
-				lbs_pr_debug(1, "No multicast addresses - "
-				       "disabling multicast!\n");
+				lbs_deb_net("no multicast addresses, "
+				       "disabling multicast\n");
 				adapter->currentpacketfilter &=
 				    ~cmd_act_mac_multicast_enable;
 			} else {
@@ -667,12 +560,12 @@ static void wlan_set_multicast_list(stru
 				adapter->nr_of_multicastmacaddr =
 				    wlan_copy_multicast_address(adapter, dev);
 
-				lbs_pr_debug(1, "Multicast addresses: %d\n",
+				lbs_deb_net("multicast addresses: %d\n",
 				       dev->mc_count);
 
 				for (i = 0; i < dev->mc_count; i++) {
-					lbs_pr_debug(1, "Multicast address %d:"
-					       "%x %x %x %x %x %x\n", i,
+					lbs_deb_net("Multicast address %d:"
+					       MAC_FMT "\n", i,
 					       adapter->multicastlist[i][0],
 					       adapter->multicastlist[i][1],
 					       adapter->multicastlist[i][2],
@@ -680,7 +573,7 @@ static void wlan_set_multicast_list(stru
 					       adapter->multicastlist[i][4],
 					       adapter->multicastlist[i][5]);
 				}
-				/* set multicast addresses to firmware */
+				/* send multicast addresses to firmware */
 				libertas_prepare_and_send_command(priv,
 						      cmd_mac_multicast_adr,
 						      cmd_act_set, 0, 0,
@@ -693,13 +586,13 @@ static void wlan_set_multicast_list(stru
 		libertas_set_mac_packet_filter(priv);
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_NET);
 }
 
 /**
- *  @brief This function hanldes the major job in WLAN driver.
- *  it handles the event generated by firmware, rx data received
- *  from firmware and tx data sent from kernel.
+ *  @brief This function handles the major jobs in the WLAN driver.
+ *  It handles all events generated by firmware, RX data received
+ *  from firmware and TX data sent from kernel.
  *
  *  @param data    A pointer to wlan_thread structure
  *  @return 	   0
@@ -712,26 +605,26 @@ static int wlan_service_main_thread(void
 	wait_queue_t wait;
 	u8 ireg = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_THREAD);
 
 	wlan_activate_thread(thread);
 
 	init_waitqueue_entry(&wait, current);
 
 	for (;;) {
-		lbs_pr_debug(1, "main-thread 111: intcounter=%d "
+		lbs_deb_thread( "main-thread 111: intcounter=%d "
 		       "currenttxskb=%p dnld_sent=%d\n",
 		       adapter->intcounter,
-		       adapter->currenttxskb, priv->wlan_dev.dnld_sent);
+		       adapter->currenttxskb, priv->dnld_sent);
 
 		add_wait_queue(&thread->waitq, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_lock_irq(&adapter->driver_lock);
 		if ((adapter->psstate == PS_STATE_SLEEP) ||
 		    (!adapter->intcounter
-		     && (priv->wlan_dev.dnld_sent || adapter->cur_cmd ||
+		     && (priv->dnld_sent || adapter->cur_cmd ||
 			 list_empty(&adapter->cmdpendingq)))) {
-			lbs_pr_debug(1,
+			lbs_deb_thread(
 			       "main-thread sleeping... Conn=%d IntC=%d PS_mode=%d PS_State=%d\n",
 			       adapter->connect_status, adapter->intcounter,
 			       adapter->psmode, adapter->psstate);
@@ -741,23 +634,23 @@ static int wlan_service_main_thread(void
 			spin_unlock_irq(&adapter->driver_lock);
 
 
-		lbs_pr_debug(1,
+		lbs_deb_thread(
 		       "main-thread 222 (waking up): intcounter=%d currenttxskb=%p "
 		       "dnld_sent=%d\n", adapter->intcounter,
-		       adapter->currenttxskb, priv->wlan_dev.dnld_sent);
+		       adapter->currenttxskb, priv->dnld_sent);
 
 		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&thread->waitq, &wait);
 		try_to_freeze();
 
-		lbs_pr_debug(1, "main-thread 333: intcounter=%d currenttxskb=%p "
+		lbs_deb_thread("main-thread 333: intcounter=%d currenttxskb=%p "
 		       "dnld_sent=%d\n",
 		       adapter->intcounter,
-		       adapter->currenttxskb, priv->wlan_dev.dnld_sent);
+		       adapter->currenttxskb, priv->dnld_sent);
 
 		if (kthread_should_stop()
 		    || adapter->surpriseremoved) {
-			lbs_pr_debug(1,
+			lbs_deb_thread(
 			       "main-thread: break from main thread: surpriseremoved=0x%x\n",
 			       adapter->surpriseremoved);
 			break;
@@ -768,10 +661,10 @@ static int wlan_service_main_thread(void
 		if (adapter->intcounter) {
 			u8 int_status;
 			adapter->intcounter = 0;
-			int_status = libertas_sbi_get_int_status(priv, &ireg);
+			int_status = priv->hw_get_int_status(priv, &ireg);
 
 			if (int_status) {
-				lbs_pr_debug(1,
+				lbs_deb_thread(
 				       "main-thread: reading HOST_INT_STATUS_REG failed\n");
 				spin_unlock_irq(&adapter->driver_lock);
 				continue;
@@ -779,14 +672,14 @@ static int wlan_service_main_thread(void
 			adapter->hisregcpy |= ireg;
 		}
 
-		lbs_pr_debug(1, "main-thread 444: intcounter=%d currenttxskb=%p "
+		lbs_deb_thread("main-thread 444: intcounter=%d currenttxskb=%p "
 		       "dnld_sent=%d\n",
 		       adapter->intcounter,
-		       adapter->currenttxskb, priv->wlan_dev.dnld_sent);
+		       adapter->currenttxskb, priv->dnld_sent);
 
 		/* command response? */
 		if (adapter->hisregcpy & his_cmdupldrdy) {
-			lbs_pr_debug(1, "main-thread: cmd response ready.\n");
+			lbs_deb_thread("main-thread: cmd response ready\n");
 
 			adapter->hisregcpy &= ~his_cmdupldrdy;
 			spin_unlock_irq(&adapter->driver_lock);
@@ -796,13 +689,13 @@ static int wlan_service_main_thread(void
 
 		/* Any Card Event */
 		if (adapter->hisregcpy & his_cardevent) {
-			lbs_pr_debug(1, "main-thread: Card Event Activity.\n");
+			lbs_deb_thread("main-thread: Card Event Activity\n");
 
 			adapter->hisregcpy &= ~his_cardevent;
 
-			if (libertas_sbi_read_event_cause(priv)) {
+			if (priv->hw_read_event_cause(priv)) {
 				lbs_pr_alert(
-				       "main-thread: libertas_sbi_read_event_cause failed.\n");
+				       "main-thread: hw_read_event_cause failed\n");
 				spin_unlock_irq(&adapter->driver_lock);
 				continue;
 			}
@@ -813,15 +706,15 @@ static int wlan_service_main_thread(void
 
 		/* Check if we need to confirm Sleep Request received previously */
 		if (adapter->psstate == PS_STATE_PRE_SLEEP) {
-			if (!priv->wlan_dev.dnld_sent && !adapter->cur_cmd) {
+			if (!priv->dnld_sent && !adapter->cur_cmd) {
 				if (adapter->connect_status ==
 				    libertas_connected) {
-					lbs_pr_debug(1,
+					lbs_deb_thread(
 					       "main_thread: PRE_SLEEP--intcounter=%d currenttxskb=%p "
 					       "dnld_sent=%d cur_cmd=%p, confirm now\n",
 					       adapter->intcounter,
 					       adapter->currenttxskb,
-					       priv->wlan_dev.dnld_sent,
+					       priv->dnld_sent,
 					       adapter->cur_cmd);
 
 					libertas_ps_confirm_sleep(priv,
@@ -847,7 +740,7 @@ static int wlan_service_main_thread(void
 			continue;
 
 		/* Execute the next command */
-		if (!priv->wlan_dev.dnld_sent && !priv->adapter->cur_cmd)
+		if (!priv->dnld_sent && !priv->adapter->cur_cmd)
 			libertas_execute_next_command(priv);
 
 		/* Wake-up command waiters which can't sleep in
@@ -864,7 +757,7 @@ static int wlan_service_main_thread(void
 	wake_up_all(&adapter->cmd_pending);
 	wlan_deactivate_thread(thread);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_THREAD);
 	return 0;
 }
 
@@ -875,49 +768,32 @@ static int wlan_service_main_thread(void
  *  @param card    A pointer to card
  *  @return 	   A pointer to wlan_private structure
  */
-wlan_private *wlan_add_card(void *card)
+wlan_private *libertas_add_card(void *card, struct device *dmdev)
 {
 	struct net_device *dev = NULL;
-	struct net_device *mesh_dev = NULL;
 	wlan_private *priv = NULL;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
 
 	/* Allocate an Ethernet device and register it */
 	if (!(dev = alloc_etherdev(sizeof(wlan_private)))) {
-		lbs_pr_alert( "Init ethernet device failed!\n");
+		lbs_pr_err("init ethX device failed\n");
 		return NULL;
 	}
-
 	priv = dev->priv;
 
 	/* allocate buffer for wlan_adapter */
-	if (!(priv->adapter = kmalloc(sizeof(wlan_adapter), GFP_KERNEL))) {
-		lbs_pr_alert( "Allocate buffer for wlan_adapter failed!\n");
-		goto err_kmalloc;
+	if (!(priv->adapter = kzalloc(sizeof(wlan_adapter), GFP_KERNEL))) {
+		lbs_pr_err("allocate buffer for wlan_adapter failed\n");
+		goto err_kzalloc;
 	}
 
-	/* Allocate a virtual mesh device */
-	if (!(mesh_dev = alloc_netdev(0, "msh%d", ether_setup))) {
-		lbs_pr_debug(1, "Init ethernet device failed!\n");
-		return NULL;
-	}
-
-	/* Both intervaces share the priv structure */
-	mesh_dev->priv = priv;
-
-	/* init wlan_adapter */
-	memset(priv->adapter, 0, sizeof(wlan_adapter));
-
-	priv->wlan_dev.netdev = dev;
-	priv->wlan_dev.card = card;
+	priv->dev = dev;
+	priv->card = card;
 	priv->mesh_open = 0;
 	priv->infra_open = 0;
-	priv->mesh_dev = mesh_dev;
-	wlanpriv = priv;
 
 	SET_MODULE_OWNER(dev);
-	SET_MODULE_OWNER(mesh_dev);
 
 	/* Setup the OS Interface to our functions */
 	dev->open = wlan_open;
@@ -925,116 +801,172 @@ wlan_private *wlan_add_card(void *card)
 	dev->stop = wlan_close;
 	dev->do_ioctl = libertas_do_ioctl;
 	dev->set_mac_address = wlan_set_mac_address;
-	mesh_dev->open = mesh_open;
-	mesh_dev->hard_start_xmit = mesh_pre_start_xmit;
-	mesh_dev->stop = mesh_close;
-	mesh_dev->do_ioctl = libertas_do_ioctl;
-	memcpy(mesh_dev->dev_addr, wlanpriv->wlan_dev.netdev->dev_addr,
-			sizeof(wlanpriv->wlan_dev.netdev->dev_addr));
-
-#define	WLAN_WATCHDOG_TIMEOUT	(5 * HZ)
-
 	dev->tx_timeout = wlan_tx_timeout;
 	dev->get_stats = wlan_get_stats;
-	dev->watchdog_timeo = WLAN_WATCHDOG_TIMEOUT;
+	dev->watchdog_timeo = 5 * HZ;
 	dev->ethtool_ops = &libertas_ethtool_ops;
-	mesh_dev->get_stats = wlan_get_stats;
-	mesh_dev->ethtool_ops = &libertas_ethtool_ops;
-
 #ifdef	WIRELESS_EXT
 	dev->wireless_handlers = (struct iw_handler_def *)&libertas_handler_def;
-	mesh_dev->wireless_handlers = (struct iw_handler_def *)&libertas_handler_def;
 #endif
 #define NETIF_F_DYNALLOC 16
 	dev->features |= NETIF_F_DYNALLOC;
 	dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
 	dev->set_multicast_list = wlan_set_multicast_list;
 
+	SET_NETDEV_DEV(dev, dmdev);
+
 	INIT_LIST_HEAD(&priv->adapter->cmdfreeq);
 	INIT_LIST_HEAD(&priv->adapter->cmdpendingq);
 
 	spin_lock_init(&priv->adapter->driver_lock);
 	init_waitqueue_head(&priv->adapter->cmd_pending);
 	priv->adapter->nr_cmd_pending = 0;
+	goto done;
 
-	lbs_pr_debug(1, "Starting kthread...\n");
+err_kzalloc:
+	free_netdev(dev);
+	priv = NULL;
+done:
+	lbs_deb_leave_args(LBS_DEB_NET, "priv %p", priv);
+	return priv;
+}
+EXPORT_SYMBOL_GPL(libertas_add_card);
+
+int libertas_activate_card(wlan_private *priv, char *fw_name)
+{
+	struct net_device *dev = priv->dev;
+	int ret = -1;
+
+	lbs_deb_enter(LBS_DEB_MAIN);
+
+	lbs_deb_thread("Starting kthread...\n");
 	priv->mainthread.priv = priv;
 	wlan_create_thread(wlan_service_main_thread,
 			   &priv->mainthread, "wlan_main_service");
 
 	priv->assoc_thread =
 		create_singlethread_workqueue("libertas_assoc");
-	INIT_DELAYED_WORK(&priv->assoc_work, wlan_association_worker);
+	INIT_DELAYED_WORK(&priv->assoc_work, libertas_association_worker);
+	INIT_WORK(&priv->sync_channel, libertas_sync_channel);
 
 	/*
 	 * Register the device. Fillup the private data structure with
 	 * relevant information from the card and request for the required
 	 * IRQ.
 	 */
-	if (libertas_sbi_register_dev(priv) < 0) {
-		lbs_pr_info("failed to register wlan device!\n");
+	if (priv->hw_register_dev(priv) < 0) {
+		lbs_pr_err("failed to register WLAN device\n");
 		goto err_registerdev;
 	}
 
 	/* init FW and HW */
-	if (libertas_init_fw(priv)) {
-		lbs_pr_debug(1, "Firmware Init failed\n");
+	if (fw_name && libertas_init_fw(priv, fw_name)) {
+		lbs_pr_err("firmware init failed\n");
 		goto err_registerdev;
 	}
 
 	if (register_netdev(dev)) {
-		lbs_pr_err("Cannot register network device!\n");
-		goto err_init_fw;
-	}
-
-	/* Register virtual mesh interface */
-	if (register_netdev(mesh_dev)) {
-		lbs_pr_info("Cannot register mesh virtual interface!\n");
+		lbs_pr_err("cannot register ethX device\n");
 		goto err_init_fw;
 	}
 
-	lbs_pr_info("%s: Marvell Wlan 802.11 adapter ", dev->name);
+	lbs_pr_info("%s: Marvell WLAN 802.11 adapter\n", dev->name);
 
 	libertas_debugfs_init_one(priv, dev);
 
-	if (libertas_found == MAX_DEVS)
-		goto err_init_fw;
-	libertas_devs[libertas_found] = dev;
-	libertas_found++;
-#ifdef ENABLE_PM
-	if (!(wlan_pm_dev = pm_register(PM_UNKNOWN_DEV, 0, wlan_pm_callback)))
-		lbs_pr_alert( "failed to register PM callback\n");
-#endif
-	if (device_create_file(&(mesh_dev->dev), &dev_attr_libertas_mpp))
-		goto err_create_file;
-
-	LEAVE();
-	return priv;
+	ret = 0;
+	goto done;
 
-err_create_file:
-	device_remove_file(&(mesh_dev->dev), &dev_attr_libertas_mpp);
 err_init_fw:
-	libertas_sbi_unregister_dev(priv);
+	priv->hw_unregister_dev(priv);
 err_registerdev:
 	destroy_workqueue(priv->assoc_thread);
 	/* Stop the thread servicing the interrupts */
 	wake_up_interruptible(&priv->mainthread.waitq);
 	wlan_terminate_thread(&priv->mainthread);
-	kfree(priv->adapter);
-err_kmalloc:
-	free_netdev(dev);
+done:
+	lbs_deb_leave_args(LBS_DEB_NET, "ret %d", ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(libertas_activate_card);
+
+
+/**
+ * @brief This function adds mshX interface
+ *
+ *  @param priv    A pointer to the wlan_private structure
+ *  @return 	   0 if successful, -X otherwise
+ */
+int libertas_add_mesh(wlan_private *priv, struct device *dev)
+{
+	struct net_device *mesh_dev = NULL;
+	int ret = 0;
+
+	lbs_deb_enter(LBS_DEB_MESH);
+
+	/* Allocate a virtual mesh device */
+	if (!(mesh_dev = alloc_netdev(0, "msh%d", ether_setup))) {
+		lbs_deb_mesh("init mshX device failed\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+	mesh_dev->priv = priv;
+	priv->mesh_dev = mesh_dev;
+
+	SET_MODULE_OWNER(mesh_dev);
+
+	mesh_dev->open = mesh_open;
+	mesh_dev->hard_start_xmit = mesh_pre_start_xmit;
+	mesh_dev->stop = mesh_close;
+	mesh_dev->do_ioctl = libertas_do_ioctl;
+	mesh_dev->get_stats = wlan_get_stats;
+	mesh_dev->set_mac_address = wlan_set_mac_address;
+	mesh_dev->ethtool_ops = &libertas_ethtool_ops;
+	memcpy(mesh_dev->dev_addr, priv->dev->dev_addr,
+			sizeof(priv->dev->dev_addr));
+
+	SET_NETDEV_DEV(priv->mesh_dev, dev);
+
+#ifdef	WIRELESS_EXT
+	mesh_dev->wireless_handlers = (struct iw_handler_def *)&mesh_handler_def;
+#endif
+#define NETIF_F_DYNALLOC 16
+
+	/* Register virtual mesh interface */
+	ret = register_netdev(mesh_dev);
+	if (ret) {
+		lbs_pr_err("cannot register mshX virtual interface\n");
+		goto err_free;
+	}
+
+	ret = device_create_file(&(mesh_dev->dev), &dev_attr_anycast_mask);
+	if (ret)
+		goto err_unregister;
+
+	/* Everything successful */
+	ret = 0;
+	goto done;
+
+
+err_unregister:
+	unregister_netdev(mesh_dev);
+
+err_free:
 	free_netdev(mesh_dev);
-	wlanpriv = NULL;
 
-	LEAVE();
-	return NULL;
+done:
+	lbs_deb_leave_args(LBS_DEB_MESH, "ret %d", ret);
+	return ret;
 }
+EXPORT_SYMBOL_GPL(libertas_add_mesh);
 
 static void wake_pending_cmdnodes(wlan_private *priv)
 {
 	struct cmd_ctrl_node *cmdnode;
 	unsigned long flags;
 
+	lbs_deb_enter(LBS_DEB_CMD);
+
 	spin_lock_irqsave(&priv->adapter->driver_lock, flags);
 	list_for_each_entry(cmdnode, &priv->adapter->cmdpendingq, list) {
 		cmdnode->cmdwaitqwoken = 1;
@@ -1044,40 +976,29 @@ static void wake_pending_cmdnodes(wlan_p
 }
 
 
-int wlan_remove_card(void *card)
+int libertas_remove_card(wlan_private *priv)
 {
-	wlan_private *priv = libertas_sbi_get_priv(card);
 	wlan_adapter *adapter;
 	struct net_device *dev;
-	struct net_device *mesh_dev;
 	union iwreq_data wrqu;
-	int i;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_NET);
 
-	if (!priv) {
-		LEAVE();
-		return 0;
-	}
+	if (!priv)
+		goto out;
 
 	adapter = priv->adapter;
 
-	if (!adapter) {
-		LEAVE();
-		return 0;
-	}
+	if (!adapter)
+		goto out;
 
-	dev = priv->wlan_dev.netdev;
-	mesh_dev = priv->mesh_dev;
+	dev = priv->dev;
 
-	netif_stop_queue(mesh_dev);
-	netif_stop_queue(priv->wlan_dev.netdev);
-	netif_carrier_off(priv->wlan_dev.netdev);
+	netif_stop_queue(priv->dev);
+	netif_carrier_off(priv->dev);
 
 	wake_pending_cmdnodes(priv);
 
-	device_remove_file(&(mesh_dev->dev), &dev_attr_libertas_mpp);
-	unregister_netdev(mesh_dev);
 	unregister_netdev(dev);
 
 	cancel_delayed_work(&priv->assoc_work);
@@ -1090,11 +1011,7 @@ int wlan_remove_card(void *card)
 
 	memset(wrqu.ap_addr.sa_data, 0xaa, ETH_ALEN);
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	wireless_send_event(priv->wlan_dev.netdev, SIOCGIWAP, &wrqu, NULL);
-
-#ifdef ENABLE_PM
-	pm_unregister(wlan_pm_dev);
-#endif
+	wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
 
 	adapter->surpriseremoved = 1;
 
@@ -1103,28 +1020,45 @@ int wlan_remove_card(void *card)
 
 	libertas_debugfs_remove_one(priv);
 
-	lbs_pr_debug(1, "Free adapter\n");
+	lbs_deb_net("free adapter\n");
 	libertas_free_adapter(priv);
 
-	for (i = 0; i<libertas_found; i++) {
-		if (libertas_devs[i]==priv->wlan_dev.netdev) {
-			libertas_devs[i] = libertas_devs[--libertas_found];
-			libertas_devs[libertas_found] = NULL ;
-			break ;
-		}
-	}
+	lbs_deb_net("unregister finish\n");
+
+	priv->dev = NULL;
+	free_netdev(dev);
+
+out:
+	lbs_deb_leave(LBS_DEB_NET);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(libertas_remove_card);
+
+
+void libertas_remove_mesh(wlan_private *priv)
+{
+	struct net_device *mesh_dev;
+
+	lbs_deb_enter(LBS_DEB_NET);
+
+	if (!priv)
+		goto out;
+
+	mesh_dev = priv->mesh_dev;
+
+	netif_stop_queue(mesh_dev);
+	netif_carrier_off(priv->mesh_dev);
 
-	lbs_pr_debug(1, "Unregister finish\n");
+	device_remove_file(&(mesh_dev->dev), &dev_attr_anycast_mask);
+	unregister_netdev(mesh_dev);
 
-	priv->wlan_dev.netdev = NULL;
 	priv->mesh_dev = NULL ;
 	free_netdev(mesh_dev);
-	free_netdev(dev);
-	wlanpriv = NULL;
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave(LBS_DEB_NET);
 }
+EXPORT_SYMBOL_GPL(libertas_remove_mesh);
 
 /**
  *  @brief This function finds the CFP in
@@ -1139,33 +1073,34 @@ struct chan_freq_power *libertas_get_reg
 {
 	int i, end;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_MAIN);
 
 	end = sizeof(region_cfp_table)/sizeof(struct region_cfp_table);
 
 	for (i = 0; i < end ; i++) {
-		lbs_pr_debug(1, "region_cfp_table[i].region=%d\n",
+		lbs_deb_main("region_cfp_table[i].region=%d\n",
 			region_cfp_table[i].region);
 		if (region_cfp_table[i].region == region) {
 			*cfp_no = region_cfp_table[i].cfp_no_BG;
-			LEAVE();
+			lbs_deb_leave(LBS_DEB_MAIN);
 			return region_cfp_table[i].cfp_BG;
 		}
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_MAIN, "ret NULL");
 	return NULL;
 }
 
 int libertas_set_regiontable(wlan_private * priv, u8 region, u8 band)
 {
 	wlan_adapter *adapter = priv->adapter;
+	int ret = 0;
 	int i = 0;
 
 	struct chan_freq_power *cfp;
 	int cfp_no;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_MAIN);
 
 	memset(adapter->region_channel, 0, sizeof(adapter->region_channel));
 
@@ -1175,17 +1110,19 @@ int libertas_set_regiontable(wlan_privat
 			adapter->region_channel[i].nrcfp = cfp_no;
 			adapter->region_channel[i].CFP = cfp;
 		} else {
-			lbs_pr_debug(1, "wrong region code %#x in band B-G\n",
+			lbs_deb_main("wrong region code %#x in band B/G\n",
 			       region);
-			return -1;
+			ret = -1;
+			goto out;
 		}
 		adapter->region_channel[i].valid = 1;
 		adapter->region_channel[i].region = region;
 		adapter->region_channel[i].band = band;
 		i++;
 	}
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_MAIN, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -1200,9 +1137,9 @@ void libertas_interrupt(struct net_devic
 {
 	wlan_private *priv = dev->priv;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_THREAD);
 
-	lbs_pr_debug(1, "libertas_interrupt: intcounter=%d\n",
+	lbs_deb_thread("libertas_interrupt: intcounter=%d\n",
 	       priv->adapter->intcounter);
 
 	priv->adapter->intcounter++;
@@ -1210,56 +1147,35 @@ void libertas_interrupt(struct net_devic
 	if (priv->adapter->psstate == PS_STATE_SLEEP) {
 		priv->adapter->psstate = PS_STATE_AWAKE;
 		netif_wake_queue(dev);
+		netif_wake_queue(priv->mesh_dev);
 	}
 
 	wake_up_interruptible(&priv->mainthread.waitq);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_THREAD);
 }
+EXPORT_SYMBOL_GPL(libertas_interrupt);
 
-static int wlan_init_module(void)
+static int libertas_init_module(void)
 {
-	int ret = 0;
-
-	ENTER();
-
-	if (libertas_fw_name == NULL) {
-		libertas_fw_name = default_fw_name;
-	}
-
+	lbs_deb_enter(LBS_DEB_MAIN);
 	libertas_debugfs_init();
-
-	if (libertas_sbi_register()) {
-		ret = -1;
-		libertas_debugfs_remove();
-		goto done;
-	}
-
-done:
-	LEAVE();
-	return ret;
+	lbs_deb_leave(LBS_DEB_MAIN);
+	return 0;
 }
 
-static void wlan_cleanup_module(void)
+static void libertas_exit_module(void)
 {
-	int i;
-
-	ENTER();
-
-	for (i = 0; i<libertas_found; i++) {
-		wlan_private *priv = libertas_devs[i]->priv;
-		reset_device(priv);
-	}
+	lbs_deb_enter(LBS_DEB_MAIN);
 
-	libertas_sbi_unregister();
 	libertas_debugfs_remove();
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_MAIN);
 }
 
-module_init(wlan_init_module);
-module_exit(wlan_cleanup_module);
+module_init(libertas_init_module);
+module_exit(libertas_exit_module);
 
-MODULE_DESCRIPTION("M-WLAN Driver");
+MODULE_DESCRIPTION("Libertas WLAN Driver Library");
 MODULE_AUTHOR("Marvell International Ltd.");
 MODULE_LICENSE("GPL");
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/Makefile linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/Makefile
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/Makefile	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/Makefile	2007-06-14 14:14:33.000000000 -0400
@@ -1,4 +1,4 @@
-usb8xxx-objs := main.o fw.o wext.o \
+libertas-objs := main.o fw.o wext.o \
 		rx.o tx.o cmd.o 	  \
 		cmdresp.o scan.o	  \
 		join.o 11d.o 		  \
@@ -8,5 +8,5 @@ usb8xxx-objs := main.o fw.o wext.o \
 usb8xxx-objs += if_bootcmd.o
 usb8xxx-objs += if_usb.o
 
+obj-$(CONFIG_LIBERTAS)     += libertas.o
 obj-$(CONFIG_LIBERTAS_USB) += usb8xxx.o
-
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/README linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/README
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/README	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/README	2007-06-14 14:14:33.000000000 -0400
@@ -1,7 +1,7 @@
 ================================================================================
 			README for USB8388
 
- (c) Copyright  2003-2006, Marvell International Ltd.
+ (c) Copyright  2003-2006, Marvell International Ltd.
  All Rights Reserved
 
  This software file (the "File") is distributed by Marvell International
@@ -47,15 +47,19 @@ Version 5 Command:
 	iwpriv ethX ledgpio <n>
 
 BT Commands:
-	The blinding table (BT) contains a list of mac addresses that should be
-	ignored by the firmware.  It is primarily used for debugging and
-	testing networks.  It can be edited and inspected with the following
-	commands:
+	The blinding table (BT) contains a list of mac addresses that will be,
+	by default, ignored by the firmware. It is also possible to invert this
+	behavior so that we will ignore all traffic except for the portion
+	coming from mac addresess in the list. It is primarily used for
+	debugging and testing networks.  It can be edited and inspected with
+	the following commands:
 
 	iwpriv ethX bt_reset
 	iwpriv ethX bt_add <mac_address>
 	iwpriv ethX bt_del <mac_address>
 	iwpriv ethX bt_list <id>
+	iwpriv ethX bt_get_invert <n>
+	iwpriv ethX bt_set_invert <n>
 
 FWT Commands:
 	The forwarding table (FWT) is a feature used to manage mesh network
@@ -135,7 +139,7 @@ fwt_add
 	This command is used to insert an entry into the FWT table. The list of
 	parameters must follow the following structure:
 
-	iwpriv ethX fwt_add da ra [metric dir ssn dsn hopcount ttl expiration sleepmode snr]
+	iwpriv ethX fwt_add da ra [metric dir rate ssn dsn hopcount ttl expiration sleepmode snr]
 
 	The parameters between brackets are optional, but they must appear in
 	the order specified.  For example, if you want to specify the metric,
@@ -150,6 +154,9 @@ fwt_add
 				   preferred, default is 0)
 		dir		-- direction (1 for direct, 0 for reverse,
 				   default is 1)
+		rate		-- data rate used for transmission to the RA,
+				   as specified for the rateadapt command,
+				   default is 3 (11Mbps)
 		ssn		-- Source Sequence Number (time at the RA for
 				   reverse routes.  Default is 0)
 		dsn		-- Destination Sequence Number (time at the DA
@@ -207,13 +214,17 @@ fwt_list
 
 	The output is a string of the following form:
 
-		da ra metric dir ssn dsn hopcount ttl expiration sleepmode snr
+		da ra valid metric dir rate ssn dsn hopcount ttl expiration
+		sleepmode snr precursor
 
 	where the different fields are:-
 		da		-- DA MAC address (in the form "00:11:22:33:44:55")
 		ra		-- RA MAC address (in the form "00:11:22:33:44:55")
+		valid		-- whether the route is valid (0 if not valid)
 		metric		-- route metric (cost: smaller-metric routes are preferred)
 		dir		-- direction (1 for direct, 0 for reverse)
+		rate		-- data rate used for transmission to the RA,
+				   as specified for the rateadapt command
 		ssn		-- Source Sequence Number (time at the RA for reverse routes)
 		dsn		-- Destination Sequence Number (time at the DA for direct routes)
 		hopcount	-- hop count (currently unused)
@@ -221,33 +232,10 @@ fwt_list
 		expiration	-- entry expiration (in ticks, where a tick is 1024us, or ~ 1ms. Use 0 for an indefinite entry)
 		sleepmode	-- RA's sleep mode (currently unused)
 		snr		-- SNR in the link to RA (currently unused)
+		precursor	-- predecessor in direct routes
 
 fwt_list_route
-	This command is used to list a route from the FWT table. The only
-	parameter is the route ID. If you want to list all the routes in a
-	table, start with rid=0, and keep incrementing rid until you get a
-	"(null)" string. This function is similar to fwt_list. The only
-	difference is the output format.  Also note that this command is meant
-	for debugging.  It is expected that users will use fwt_lookup and
-	fwt_list.  One important reason for this is that the route id may change
-	as the route table is altered.
-
-		iwpriv ethX fwt_list_route rid
-
-	The output is a string of the following form:
-
-		da metric dir nid ssn dsn hopcount ttl expiration
-
-	where the different fields are:-
-		da		-- DA MAC address (in the form "00:11:22:33:44:55")
-		metric		-- route metric (cost: smaller-metric routes are preferred)
-		dir		-- direction (1 for direct, 0 for reverse)
-		nid		-- Next-hop (neighbor) host ID (nid)
-		ssn		-- Source Sequence Number (time at the RA for reverse routes)
-		dsn		-- Destination Sequence Number (time at the DA for direct routes)
-		hopcount	-- hop count (currently unused)
-		ttl		-- TTL count (only used in reverse entries)
-		expiration	-- entry expiration (in ticks, where a tick is 1024us, or ~ 1ms. Use 0 for an indefinite entry)
+	This command is equivalent to fwt_list.
 
 fwt_list_neigh
 	This command is used to list a neighbor from the FWT table. The only
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/rx.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/rx.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/rx.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/rx.c	2007-06-14 14:14:33.000000000 -0400
@@ -106,10 +106,10 @@ static void wlan_compute_rssi(wlan_priva
 {
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_RX);
 
-	lbs_pr_debug(1, "rxpd: SNR = %d, NF = %d\n", p_rx_pd->snr, p_rx_pd->nf);
-	lbs_pr_debug(1, "Before computing SNR: SNR- avg = %d, NF-avg = %d\n",
+	lbs_deb_rx("rxpd: SNR %d, NF %d\n", p_rx_pd->snr, p_rx_pd->nf);
+	lbs_deb_rx("before computing SNR: SNR-avg = %d, NF-avg = %d\n",
 	       adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
 	       adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
 
@@ -121,7 +121,7 @@ static void wlan_compute_rssi(wlan_priva
 
 	adapter->SNR[TYPE_RXPD][TYPE_AVG] = wlan_getavgsnr(priv) * AVG_SCALE;
 	adapter->NF[TYPE_RXPD][TYPE_AVG] = wlan_getavgnf(priv) * AVG_SCALE;
-	lbs_pr_debug(1, "After computing SNR: SNR-avg = %d, NF-avg = %d\n",
+	lbs_deb_rx("after computing SNR: SNR-avg = %d, NF-avg = %d\n",
 	       adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
 	       adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
 
@@ -133,18 +133,17 @@ static void wlan_compute_rssi(wlan_priva
 	    CAL_RSSI(adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE,
 		     adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_RX);
 }
 
 void libertas_upload_rx_packet(wlan_private * priv, struct sk_buff *skb)
 {
-	lbs_pr_debug(1, "skb->data=%p\n", skb->data);
+	lbs_deb_rx("skb->data %p\n", skb->data);
 
-	if(IS_MESH_FRAME(skb))
-		skb->dev = priv->mesh_dev;
+	if (priv->mesh_dev && IS_MESH_FRAME(skb))
+		skb->protocol = eth_type_trans(skb, priv->mesh_dev);
 	else
-		skb->dev = priv->wlan_dev.netdev;
-	skb->protocol = eth_type_trans(skb, priv->wlan_dev.netdev);
+		skb->protocol = eth_type_trans(skb, priv->dev);
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 	netif_rx(skb);
@@ -171,7 +170,7 @@ int libertas_process_rxed_packet(wlan_pr
 
 	const u8 rfc1042_eth_hdr[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_RX);
 
 	if (priv->adapter->debugmode & MRVDRV_DEBUG_RX_PATH)
 		lbs_dbg_hex("RX packet: ", skb->data,
@@ -191,7 +190,7 @@ int libertas_process_rxed_packet(wlan_pr
 		 min_t(unsigned int, skb->len, 100));
 
 	if (skb->len < (ETH_HLEN + 8 + sizeof(struct rxpd))) {
-		lbs_pr_debug(1, "RX error: FRAME RECEIVED WITH BAD LENGTH\n");
+		lbs_deb_rx("rx err: frame received with bad length\n");
 		priv->stats.rx_length_errors++;
 		ret = 0;
 		goto done;
@@ -200,15 +199,15 @@ int libertas_process_rxed_packet(wlan_pr
 	/*
 	 * Check rxpd status and update 802.3 stat,
 	 */
-	if (!(p_rx_pd->status & MRVDRV_RXPD_STATUS_OK)) {
-		lbs_pr_debug(1, "RX error: frame received with bad status\n");
-		lbs_pr_alert("rxpd Not OK\n");
+	if (!(p_rx_pd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK))) {
+		lbs_deb_rx("rx err: frame received with bad status\n");
+		lbs_pr_alert("rxpd not ok\n");
 		priv->stats.rx_errors++;
 		ret = 0;
 		goto done;
 	}
 
-	lbs_pr_debug(1, "RX Data: skb->len - sizeof(RxPd) = %d - %zd = %zd\n",
+	lbs_deb_rx("rx data: skb->len-sizeof(RxPd) = %d-%zd = %zd\n",
 	       skb->len, sizeof(struct rxpd), skb->len - sizeof(struct rxpd));
 
 	lbs_dbg_hex("RX Data: Dest", p_rx_pkt->eth803_hdr.dest_addr,
@@ -266,7 +265,7 @@ int libertas_process_rxed_packet(wlan_pr
 
 	wlan_compute_rssi(priv, p_rx_pd);
 
-	lbs_pr_debug(1, "RX Data: size of actual packet = %d\n", skb->len);
+	lbs_deb_rx("rx data: size of actual packet %d\n", skb->len);
 	priv->stats.rx_bytes += skb->len;
 	priv->stats.rx_packets++;
 
@@ -274,10 +273,10 @@ int libertas_process_rxed_packet(wlan_pr
 
 	ret = 0;
 done:
-	LEAVE();
-
+	lbs_deb_leave_args(LBS_DEB_RX, "ret %d", ret);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(libertas_process_rxed_packet);
 
 /**
  *  @brief This function converts Tx/Rx rates from the Marvell WLAN format
@@ -314,7 +313,7 @@ static u8 convert_mv_rate_to_radiotap(u8
 	case 11:		/*  54 Mbps */
 		return 108;
 	}
-	lbs_pr_alert( "Invalid Marvell WLAN rate (%i)\n", rate);
+	lbs_pr_alert("Invalid Marvell WLAN rate %i\n", rate);
 	return 0;
 }
 
@@ -336,7 +335,7 @@ static int process_rxed_802_11_packet(wl
 	struct rx_radiotap_hdr radiotap_hdr;
 	struct rx_radiotap_hdr *pradiotap_hdr;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_RX);
 
 	p_rx_pkt = (struct rx80211packethdr *) skb->data;
 	prxpd = &p_rx_pkt->rx_pd;
@@ -344,7 +343,7 @@ static int process_rxed_802_11_packet(wl
 	// lbs_dbg_hex("RX Data: Before chop rxpd", skb->data, min(skb->len, 100));
 
 	if (skb->len < (ETH_HLEN + 8 + sizeof(struct rxpd))) {
-		lbs_pr_debug(1, "RX error: FRAME RECEIVED WITH BAD LENGTH\n");
+		lbs_deb_rx("rx err: frame received wit bad length\n");
 		priv->stats.rx_length_errors++;
 		ret = 0;
 		goto done;
@@ -353,12 +352,12 @@ static int process_rxed_802_11_packet(wl
 	/*
 	 * Check rxpd status and update 802.3 stat,
 	 */
-	if (!(prxpd->status & MRVDRV_RXPD_STATUS_OK)) {
-		//lbs_pr_debug(1, "RX error: frame received with bad status\n");
+	if (!(prxpd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK))) {
+		//lbs_deb_rx("rx err: frame received with bad status\n");
 		priv->stats.rx_errors++;
 	}
 
-	lbs_pr_debug(1, "RX Data: skb->len - sizeof(RxPd) = %d - %zd = %zd\n",
+	lbs_deb_rx("rx data: skb->len-sizeof(RxPd) = %d-%zd = %zd\n",
 	       skb->len, sizeof(struct rxpd), skb->len - sizeof(struct rxpd));
 
 	/* create the exported radio header */
@@ -386,7 +385,7 @@ static int process_rxed_802_11_packet(wl
 		/* XXX must check no carryout */
 		radiotap_hdr.antsignal = prxpd->snr + prxpd->nf;
 		radiotap_hdr.rx_flags = 0;
-		if (!(prxpd->status & MRVDRV_RXPD_STATUS_OK))
+		if (!(prxpd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK)))
 			radiotap_hdr.rx_flags |= IEEE80211_RADIOTAP_F_RX_BADFCS;
 		//memset(radiotap_hdr.pad, 0x11, IEEE80211_RADIOTAP_HDRLEN - 18);
 
@@ -399,7 +398,7 @@ static int process_rxed_802_11_packet(wl
 		if ((skb_headroom(skb) < sizeof(struct rx_radiotap_hdr)) &&
 		    pskb_expand_head(skb, sizeof(struct rx_radiotap_hdr), 0,
 				     GFP_ATOMIC)) {
-			lbs_pr_alert( "%s: couldn't pskb_expand_head\n",
+			lbs_pr_alert("%s: couldn't pskb_expand_head\n",
 			       __func__);
 		}
 
@@ -414,7 +413,7 @@ static int process_rxed_802_11_packet(wl
 
 	default:
 		/* unknown header */
-		lbs_pr_alert( "Unknown radiomode (%i)\n",
+		lbs_pr_alert("Unknown radiomode %i\n",
 		       priv->adapter->radiomode);
 		/* don't export any header */
 		/* chop the rxpd */
@@ -431,15 +430,16 @@ static int process_rxed_802_11_packet(wl
 
 	wlan_compute_rssi(priv, prxpd);
 
-	lbs_pr_debug(1, "RX Data: size of actual packet = %d\n", skb->len);
+	lbs_deb_rx("rx data: size of actual packet %d\n", skb->len);
 	priv->stats.rx_bytes += skb->len;
 	priv->stats.rx_packets++;
 
 	libertas_upload_rx_packet(priv, skb);
 
 	ret = 0;
-done:
-	LEAVE();
 
-	return (ret);
+done:
+	skb->protocol = __constant_htons(0x0019);	/* ETH_P_80211_RAW */
+	lbs_deb_leave_args(LBS_DEB_RX, "ret %d", ret);
+	return ret;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/sbi.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/sbi.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/sbi.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/sbi.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,40 +0,0 @@
-/**
-  * This file contains IF layer definitions.
-  */
-
-#ifndef	_SBI_H_
-#define	_SBI_H_
-
-#include <linux/interrupt.h>
-
-#include "defs.h"
-
-/** INT status Bit Definition*/
-#define his_cmddnldrdy			0x01
-#define his_cardevent			0x02
-#define his_cmdupldrdy			0x04
-
-#ifndef DEV_NAME_LEN
-#define DEV_NAME_LEN			32
-#endif
-
-#define SBI_EVENT_CAUSE_SHIFT		3
-
-/* Probe and Check if the card is present*/
-int libertas_sbi_register_dev(wlan_private * priv);
-int libertas_sbi_unregister_dev(wlan_private *);
-int libertas_sbi_get_int_status(wlan_private * priv, u8 *);
-int libertas_sbi_register(void);
-void libertas_sbi_unregister(void);
-int libertas_sbi_prog_firmware(wlan_private *);
-
-int libertas_sbi_read_event_cause(wlan_private *);
-int libertas_sbi_host_to_card(wlan_private * priv, u8 type, u8 * payload, u16 nb);
-wlan_private *libertas_sbi_get_priv(void *card);
-
-#ifdef ENABLE_PM
-int libertas_sbi_suspend(wlan_private *);
-int libertas_sbi_resume(wlan_private *);
-#endif
-
-#endif				/* _SBI_H */
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/scan.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/scan.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/scan.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/scan.c	2007-06-14 14:14:33.000000000 -0400
@@ -8,6 +8,7 @@
 #include <linux/if.h>
 #include <linux/netdevice.h>
 #include <linux/wireless.h>
+#include <linux/etherdevice.h>
 
 #include <net/ieee80211.h>
 #include <net/iw_handler.h>
@@ -58,12 +59,82 @@
 //! Scan time specified in the channel TLV for each channel for active scans
 #define MRVDRV_ACTIVE_SCAN_CHAN_TIME   100
 
-//! Macro to enable/disable SSID checking before storing a scan table
-#ifdef DISCARD_BAD_SSID
-#define CHECK_SSID_IS_VALID(x) ssid_valid(&bssidEntry.ssid)
-#else
-#define CHECK_SSID_IS_VALID(x) 1
-#endif
+static const u8 zeromac[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+static const u8 bcastmac[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+static inline void clear_bss_descriptor (struct bss_descriptor * bss)
+{
+	/* Don't blow away ->list, just BSS data */
+	memset(bss, 0, offsetof(struct bss_descriptor, list));
+}
+
+static inline int match_bss_no_security(struct wlan_802_11_security * secinfo,
+			struct bss_descriptor * match_bss)
+{
+	if (   !secinfo->wep_enabled
+	    && !secinfo->WPAenabled
+	    && !secinfo->WPA2enabled
+	    && match_bss->wpa_ie[0] != WPA_IE
+	    && match_bss->rsn_ie[0] != WPA2_IE
+	    && !match_bss->privacy) {
+		return 1;
+	}
+	return 0;
+}
+
+static inline int match_bss_static_wep(struct wlan_802_11_security * secinfo,
+			struct bss_descriptor * match_bss)
+{
+	if ( secinfo->wep_enabled
+	   && !secinfo->WPAenabled
+	   && !secinfo->WPA2enabled
+	   && match_bss->privacy) {
+		return 1;
+	}
+	return 0;
+}
+
+static inline int match_bss_wpa(struct wlan_802_11_security * secinfo,
+			struct bss_descriptor * match_bss)
+{
+	if (  !secinfo->wep_enabled
+	   && secinfo->WPAenabled
+	   && (match_bss->wpa_ie[0] == WPA_IE)
+	   /* privacy bit may NOT be set in some APs like LinkSys WRT54G
+	      && bss->privacy */
+	   ) {
+		return 1;
+	}
+	return 0;
+}
+
+static inline int match_bss_wpa2(struct wlan_802_11_security * secinfo,
+			struct bss_descriptor * match_bss)
+{
+	if (  !secinfo->wep_enabled
+	   && secinfo->WPA2enabled
+	   && (match_bss->rsn_ie[0] == WPA2_IE)
+	   /* privacy bit may NOT be set in some APs like LinkSys WRT54G
+	      && bss->privacy */
+	   ) {
+		return 1;
+	}
+	return 0;
+}
+
+static inline int match_bss_dynamic_wep(struct wlan_802_11_security * secinfo,
+			struct bss_descriptor * match_bss)
+{
+	if (  !secinfo->wep_enabled
+	   && !secinfo->WPAenabled
+	   && !secinfo->WPA2enabled
+	   && (match_bss->wpa_ie[0] != WPA_IE)
+	   && (match_bss->rsn_ie[0] != WPA2_IE)
+	   && match_bss->privacy) {
+		return 1;
+	}
+	return 0;
+}
 
 /**
  *  @brief Check if a scanned network compatible with the driver settings
@@ -84,123 +155,63 @@
  *
  *  @return        Index in scantable, or error code if negative
  */
-static int is_network_compatible(wlan_adapter * adapter, int index, u8 mode)
+static int is_network_compatible(wlan_adapter * adapter,
+		struct bss_descriptor * bss, u8 mode)
 {
-	ENTER();
+	int matched = 0;
 
-	if (adapter->scantable[index].mode == mode) {
-		if (   !adapter->secinfo.wep_enabled
-		    && !adapter->secinfo.WPAenabled
-		    && !adapter->secinfo.WPA2enabled
-		    && adapter->scantable[index].wpa_ie[0] != WPA_IE
-		    && adapter->scantable[index].rsn_ie[0] != WPA2_IE
-		    && !adapter->scantable[index].privacy) {
-			/* no security */
-			LEAVE();
-			return index;
-		} else if (   adapter->secinfo.wep_enabled
-			   && !adapter->secinfo.WPAenabled
-			   && !adapter->secinfo.WPA2enabled
-			   && adapter->scantable[index].privacy) {
-			/* static WEP enabled */
-			LEAVE();
-			return index;
-		} else if (   !adapter->secinfo.wep_enabled
-			   && adapter->secinfo.WPAenabled
-			   && !adapter->secinfo.WPA2enabled
-			   && (adapter->scantable[index].wpa_ie[0] == WPA_IE)
-			   /* privacy bit may NOT be set in some APs like LinkSys WRT54G
-			      && adapter->scantable[index].privacy */
-		    ) {
-			/* WPA enabled */
-			lbs_pr_debug(1,
-			       "is_network_compatible() WPA: index=%d wpa_ie=%#x "
-			       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s "
-			       "privacy=%#x\n", index,
-			       adapter->scantable[index].wpa_ie[0],
-			       adapter->scantable[index].rsn_ie[0],
-			       adapter->secinfo.wep_enabled ? "e" : "d",
-			       adapter->secinfo.WPAenabled ? "e" : "d",
-			       adapter->secinfo.WPA2enabled ? "e" : "d",
-			       adapter->scantable[index].privacy);
-			LEAVE();
-			return index;
-		} else if (   !adapter->secinfo.wep_enabled
-			   && !adapter->secinfo.WPAenabled
-			   && adapter->secinfo.WPA2enabled
-			   && (adapter->scantable[index].rsn_ie[0] == WPA2_IE)
-			   /* privacy bit may NOT be set in some APs like LinkSys WRT54G
-			      && adapter->scantable[index].privacy */
-		    ) {
-			/* WPA2 enabled */
-			lbs_pr_debug(1,
-			       "is_network_compatible() WPA2: index=%d wpa_ie=%#x "
-			       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s "
-			       "privacy=%#x\n", index,
-			       adapter->scantable[index].wpa_ie[0],
-			       adapter->scantable[index].rsn_ie[0],
-			       adapter->secinfo.wep_enabled ? "e" : "d",
-			       adapter->secinfo.WPAenabled ? "e" : "d",
-			       adapter->secinfo.WPA2enabled ? "e" : "d",
-			       adapter->scantable[index].privacy);
-			LEAVE();
-			return index;
-		} else if (   !adapter->secinfo.wep_enabled
-			   && !adapter->secinfo.WPAenabled
-			   && !adapter->secinfo.WPA2enabled
-			   && (adapter->scantable[index].wpa_ie[0] != WPA_IE)
-			   && (adapter->scantable[index].rsn_ie[0] != WPA2_IE)
-			   && adapter->scantable[index].privacy) {
-			/* dynamic WEP enabled */
-			lbs_pr_debug(1,
-			       "is_network_compatible() dynamic WEP: index=%d "
-			       "wpa_ie=%#x wpa2_ie=%#x privacy=%#x\n",
-			       index,
-			       adapter->scantable[index].wpa_ie[0],
-			       adapter->scantable[index].rsn_ie[0],
-			       adapter->scantable[index].privacy);
-			LEAVE();
-			return index;
-		}
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-		/* security doesn't match */
-		lbs_pr_debug(1,
-		       "is_network_compatible() FAILED: index=%d wpa_ie=%#x "
-		       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s privacy=%#x\n",
-		       index,
-		       adapter->scantable[index].wpa_ie[0],
-		       adapter->scantable[index].rsn_ie[0],
+	if (bss->mode != mode)
+		goto done;
+
+	if ((matched = match_bss_no_security(&adapter->secinfo, bss))) {
+		goto done;
+	} else if ((matched = match_bss_static_wep(&adapter->secinfo, bss))) {
+		goto done;
+	} else if ((matched = match_bss_wpa(&adapter->secinfo, bss))) {
+		lbs_deb_scan(
+		       "is_network_compatible() WPA: wpa_ie=%#x "
+		       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s "
+		       "privacy=%#x\n", bss->wpa_ie[0], bss->rsn_ie[0],
 		       adapter->secinfo.wep_enabled ? "e" : "d",
 		       adapter->secinfo.WPAenabled ? "e" : "d",
 		       adapter->secinfo.WPA2enabled ? "e" : "d",
-		       adapter->scantable[index].privacy);
-		LEAVE();
-		return -ECONNREFUSED;
-	}
-
-	/* mode doesn't match */
-	LEAVE();
-	return -ENETUNREACH;
-}
-
-/**
- *  @brief This function validates a SSID as being able to be printed
- *
- *  @param pssid   SSID structure to validate
- *
- *  @return        TRUE or FALSE
- */
-static u8 ssid_valid(struct WLAN_802_11_SSID *pssid)
-{
-	int ssididx;
-
-	for (ssididx = 0; ssididx < pssid->ssidlength; ssididx++) {
-		if (!isprint(pssid->ssid[ssididx])) {
-			return 0;
-		}
-	}
-
-	return 1;
+		       bss->privacy);
+		goto done;
+	} else if ((matched = match_bss_wpa2(&adapter->secinfo, bss))) {
+		lbs_deb_scan(
+		       "is_network_compatible() WPA2: wpa_ie=%#x "
+		       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s "
+		       "privacy=%#x\n", bss->wpa_ie[0], bss->rsn_ie[0],
+		       adapter->secinfo.wep_enabled ? "e" : "d",
+		       adapter->secinfo.WPAenabled ? "e" : "d",
+		       adapter->secinfo.WPA2enabled ? "e" : "d",
+		       bss->privacy);
+		goto done;
+	} else if ((matched = match_bss_dynamic_wep(&adapter->secinfo, bss))) {
+		lbs_deb_scan(
+		       "is_network_compatible() dynamic WEP: "
+		       "wpa_ie=%#x wpa2_ie=%#x privacy=%#x\n",
+		       bss->wpa_ie[0],
+		       bss->rsn_ie[0],
+		       bss->privacy);
+		goto done;
+	}
+
+	/* bss security settings don't match those configured on card */
+	lbs_deb_scan(
+	       "is_network_compatible() FAILED: wpa_ie=%#x "
+	       "wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s privacy=%#x\n",
+	       bss->wpa_ie[0], bss->rsn_ie[0],
+	       adapter->secinfo.wep_enabled ? "e" : "d",
+	       adapter->secinfo.WPAenabled ? "e" : "d",
+	       adapter->secinfo.WPA2enabled ? "e" : "d",
+	       bss->privacy);
+
+done:
+	lbs_deb_leave(LBS_DEB_SCAN);
+	return matched;
 }
 
 /**
@@ -220,44 +231,19 @@ static u8 ssid_valid(struct WLAN_802_11_
 static void wlan_scan_process_results(wlan_private * priv)
 {
 	wlan_adapter *adapter = priv->adapter;
-	int foundcurrent;
-	int i;
-
-	foundcurrent = 0;
-
-	if (adapter->connect_status == libertas_connected) {
-		/* try to find the current BSSID in the new scan list */
-		for (i = 0; i < adapter->numinscantable; i++) {
-			if (!libertas_SSID_cmp(&adapter->scantable[i].ssid,
-				     &adapter->curbssparams.ssid) &&
-			    !memcmp(adapter->curbssparams.bssid,
-				    adapter->scantable[i].macaddress,
-				    ETH_ALEN)) {
-				foundcurrent = 1;
-			}
-		}
+	struct bss_descriptor * iter_bss;
+	int i = 0;
 
-		if (foundcurrent) {
-			/* Make a copy of current BSSID descriptor */
-			memcpy(&adapter->curbssparams.bssdescriptor,
-			       &adapter->scantable[i],
-			       sizeof(adapter->curbssparams.bssdescriptor));
-		}
-	}
+	if (adapter->connect_status == libertas_connected)
+		return;
 
-	for (i = 0; i < adapter->numinscantable; i++) {
-		lbs_pr_debug(1, "Scan:(%02d) %02x:%02x:%02x:%02x:%02x:%02x, "
-		       "RSSI[%03d], SSID[%s]\n",
-		       i,
-		       adapter->scantable[i].macaddress[0],
-		       adapter->scantable[i].macaddress[1],
-		       adapter->scantable[i].macaddress[2],
-		       adapter->scantable[i].macaddress[3],
-		       adapter->scantable[i].macaddress[4],
-		       adapter->scantable[i].macaddress[5],
-		       (s32) adapter->scantable[i].rssi,
-		       adapter->scantable[i].ssid.ssid);
+	mutex_lock(&adapter->lock);
+	list_for_each_entry (iter_bss, &adapter->network_list, list) {
+		lbs_deb_scan("Scan:(%02d) " MAC_FMT ", RSSI[%03d], SSID[%s]\n",
+		       i++, MAC_ARG(iter_bss->bssid), (s32) iter_bss->rssi,
+		       escape_essid(iter_bss->ssid, iter_bss->ssid_len));
 	}
+	mutex_unlock(&adapter->lock);
 }
 
 /**
@@ -338,14 +324,12 @@ static void wlan_scan_create_channel_lis
 
 			if (scantype == cmd_scan_type_passive) {
 				scanchanlist[chanidx].maxscantime =
-				    cpu_to_le16
-				    (MRVDRV_PASSIVE_SCAN_CHAN_TIME);
+				    cpu_to_le16(MRVDRV_PASSIVE_SCAN_CHAN_TIME);
 				scanchanlist[chanidx].chanscanmode.passivescan =
 				    1;
 			} else {
 				scanchanlist[chanidx].maxscantime =
-				    cpu_to_le16
-				    (MRVDRV_ACTIVE_SCAN_CHAN_TIME);
+				    cpu_to_le16(MRVDRV_ACTIVE_SCAN_CHAN_TIME);
 				scanchanlist[chanidx].chanscanmode.passivescan =
 				    0;
 			}
@@ -408,13 +392,11 @@ wlan_scan_setup_scan_config(wlan_private
 			    u8 * pscancurrentonly)
 {
 	wlan_adapter *adapter = priv->adapter;
-	const u8 zeromac[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
 	struct mrvlietypes_numprobes *pnumprobestlv;
 	struct mrvlietypes_ssidparamset *pssidtlv;
 	struct wlan_scan_cmd_config * pscancfgout = NULL;
 	u8 *ptlvpos;
 	u16 numprobes;
-	u16 ssidlen;
 	int chanidx;
 	int scantype;
 	int scandur;
@@ -471,21 +453,18 @@ wlan_scan_setup_scan_config(wlan_private
 		 * Set the BSSID filter to the incoming configuration,
 		 *   if non-zero.  If not set, it will remain disabled (all zeros).
 		 */
-		memcpy(pscancfgout->specificBSSID,
-		       puserscanin->specificBSSID,
-		       sizeof(pscancfgout->specificBSSID));
+		memcpy(pscancfgout->bssid, puserscanin->bssid,
+		       sizeof(pscancfgout->bssid));
 
-		ssidlen = strlen(puserscanin->specificSSID);
-
-		if (ssidlen) {
+		if (puserscanin->ssid_len) {
 			pssidtlv =
 			    (struct mrvlietypes_ssidparamset *) pscancfgout->
 			    tlvbuffer;
 			pssidtlv->header.type = cpu_to_le16(TLV_TYPE_SSID);
-			pssidtlv->header.len = cpu_to_le16(ssidlen);
-			memcpy(pssidtlv->ssid, puserscanin->specificSSID,
-			       ssidlen);
-			ptlvpos += sizeof(pssidtlv->header) + ssidlen;
+			pssidtlv->header.len = cpu_to_le16(puserscanin->ssid_len);
+			memcpy(pssidtlv->ssid, puserscanin->ssid,
+			       puserscanin->ssid_len);
+			ptlvpos += sizeof(pssidtlv->header) + puserscanin->ssid_len;
 		}
 
 		/*
@@ -494,8 +473,8 @@ wlan_scan_setup_scan_config(wlan_private
 		 *    scan results.  That is not an issue with an SSID or BSSID
 		 *    filter applied to the scan results in the firmware.
 		 */
-		if (ssidlen || (memcmp(pscancfgout->specificBSSID,
-				       &zeromac, sizeof(zeromac)) != 0)) {
+		if (   puserscanin->ssid_len
+		    || (compare_ether_addr(pscancfgout->bssid, &zeromac[0]) != 0)) {
 			*pmaxchanperscan = MRVDRV_MAX_CHANNELS_PER_SCAN;
 			*pfilteredscan = 1;
 		}
@@ -507,16 +486,11 @@ wlan_scan_setup_scan_config(wlan_private
 	/* If the input config or adapter has the number of Probes set, add tlv */
 	if (numprobes) {
 		pnumprobestlv = (struct mrvlietypes_numprobes *) ptlvpos;
-		pnumprobestlv->header.type =
-		    cpu_to_le16(TLV_TYPE_NUMPROBES);
-		pnumprobestlv->header.len = sizeof(pnumprobestlv->numprobes);
+		pnumprobestlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);
+		pnumprobestlv->header.len = cpu_to_le16(2);
 		pnumprobestlv->numprobes = cpu_to_le16(numprobes);
 
-		ptlvpos +=
-		    sizeof(pnumprobestlv->header) + pnumprobestlv->header.len;
-
-		pnumprobestlv->header.len =
-		    cpu_to_le16(pnumprobestlv->header.len);
+		ptlvpos += sizeof(*pnumprobestlv);
 	}
 
 	/*
@@ -529,7 +503,7 @@ wlan_scan_setup_scan_config(wlan_private
 
 	if (puserscanin && puserscanin->chanlist[0].channumber) {
 
-		lbs_pr_debug(1, "Scan: Using supplied channel list\n");
+		lbs_deb_scan("Scan: Using supplied channel list\n");
 
 		for (chanidx = 0;
 		     chanidx < WLAN_IOCTL_USER_SCAN_CHAN_MAX
@@ -573,11 +547,11 @@ wlan_scan_setup_scan_config(wlan_private
 				       ==
 				       priv->adapter->curbssparams.channel)) {
 			*pscancurrentonly = 1;
-			lbs_pr_debug(1, "Scan: Scanning current channel only");
+			lbs_deb_scan("Scan: Scanning current channel only");
 		}
 
 	} else {
-		lbs_pr_debug(1, "Scan: Creating full region channel list\n");
+		lbs_deb_scan("Scan: Creating full region channel list\n");
 		wlan_scan_create_channel_list(priv, pscanchanlist,
 					      *pfilteredscan);
 	}
@@ -613,7 +587,9 @@ static int wlan_scan_channel_list(wlan_p
 				  u8 filteredscan,
 				  struct wlan_scan_cmd_config * pscancfgout,
 				  struct mrvlietypes_chanlistparamset * pchantlvout,
-				  struct chanscanparamset * pscanchanlist)
+				  struct chanscanparamset * pscanchanlist,
+				  const struct wlan_ioctl_user_scan_cfg * puserscanin,
+				  int full_scan)
 {
 	struct chanscanparamset *ptmpchan;
 	struct chanscanparamset *pstartchan;
@@ -621,11 +597,13 @@ static int wlan_scan_channel_list(wlan_p
 	int doneearly;
 	int tlvidx;
 	int ret = 0;
+	int scanned = 0;
+	union iwreq_data wrqu;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	if (pscancfgout == 0 || pchantlvout == 0 || pscanchanlist == 0) {
-		lbs_pr_debug(1, "Scan: Null detect: %p, %p, %p\n",
+		lbs_deb_scan("Scan: Null detect: %p, %p, %p\n",
 		       pscancfgout, pchantlvout, pscanchanlist);
 		return -1;
 	}
@@ -635,6 +613,9 @@ static int wlan_scan_channel_list(wlan_p
 	/* Set the temp channel struct pointer to the start of the desired list */
 	ptmpchan = pscanchanlist;
 
+	if (priv->adapter->last_scanned_channel && !puserscanin)
+		ptmpchan += priv->adapter->last_scanned_channel;
+
 	/* Loop through the desired channel list, sending a new firmware scan
 	 *   commands for each maxchanperscan channels (or for 1,6,11 individually
 	 *   if configured accordingly)
@@ -654,9 +635,9 @@ static int wlan_scan_channel_list(wlan_p
 		 *    - doneearly is set (controlling individual scanning of 1,6,11)
 		 */
 		while (tlvidx < maxchanperscan && ptmpchan->channumber
-		       && !doneearly) {
+		       && !doneearly && scanned < 2) {
 
-            lbs_pr_debug(1,
+            lbs_deb_scan(
                     "Scan: Chan(%3d), Radio(%d), mode(%d,%d), Dur(%d)\n",
                 ptmpchan->channumber, ptmpchan->radiotype,
                 ptmpchan->chanscanmode.passivescan,
@@ -668,8 +649,11 @@ static int wlan_scan_channel_list(wlan_p
 			       ptmpchan, sizeof(pchantlvout->chanscanparam));
 
 			/* Increment the TLV header length by the size appended */
-			pchantlvout->header.len +=
-			    sizeof(pchantlvout->chanscanparam);
+			/* Ew, it would be _so_ nice if we could just declare the
+			   variable little-endian and let GCC handle it for us */
+			pchantlvout->header.len =
+				cpu_to_le16(le16_to_cpu(pchantlvout->header.len) +
+					    sizeof(pchantlvout->chanscanparam));
 
 			/*
 			 *  The tlv buffer length is set to the number of bytes of the
@@ -683,7 +667,7 @@ static int wlan_scan_channel_list(wlan_p
 			/*  Add the size of the channel tlv header and the data length */
 			pscancfgout->tlvbufferlen +=
 			    (sizeof(pchantlvout->header)
-			     + pchantlvout->header.len);
+			     + le16_to_cpu(pchantlvout->header.len));
 
 			/* Increment the index to the channel tlv we are constructing */
 			tlvidx++;
@@ -701,6 +685,7 @@ static int wlan_scan_channel_list(wlan_p
 
 			/* Increment the tmp pointer to the next channel to be scanned */
 			ptmpchan++;
+			scanned++;
 
 			/* Stop the loop if the *next* channel is in the 1,6,11 set.
 			 *  This will cause it to be the only channel scanned on the next
@@ -716,12 +701,71 @@ static int wlan_scan_channel_list(wlan_p
 		/* Send the scan command to the firmware with the specified cfg */
 		ret = libertas_prepare_and_send_command(priv, cmd_802_11_scan, 0,
 					    0, 0, pscancfgout);
+		if (scanned >= 2 && !full_scan) {
+			ret = 0;
+			goto done;
+		}
+		scanned = 0;
 	}
 
-	LEAVE();
+done:
+	priv->adapter->last_scanned_channel = ptmpchan->channumber;
+
+	/* Tell userspace the scan table has been updated */
+	memset(&wrqu, 0, sizeof(union iwreq_data));
+	wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
+
+	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
 	return ret;
 }
 
+static void
+clear_selected_scan_list_entries(wlan_adapter * adapter,
+                                 const struct wlan_ioctl_user_scan_cfg * scan_cfg)
+{
+	struct bss_descriptor * bss;
+	struct bss_descriptor * safe;
+	u32 clear_ssid_flag = 0, clear_bssid_flag = 0;
+
+	if (!scan_cfg)
+		return;
+
+	if (scan_cfg->clear_ssid && scan_cfg->ssid_len)
+		clear_ssid_flag = 1;
+
+	if (scan_cfg->clear_bssid
+	    && (compare_ether_addr(scan_cfg->bssid, &zeromac[0]) != 0)
+	    && (compare_ether_addr(scan_cfg->bssid, &bcastmac[0]) != 0)) {
+		clear_bssid_flag = 1;
+	}
+
+	if (!clear_ssid_flag && !clear_bssid_flag)
+		return;
+
+	mutex_lock(&adapter->lock);
+	list_for_each_entry_safe (bss, safe, &adapter->network_list, list) {
+		u32 clear = 0;
+
+		/* Check for an SSID match */
+		if (   clear_ssid_flag
+		    && (bss->ssid_len == scan_cfg->ssid_len)
+		    && !memcmp(bss->ssid, scan_cfg->ssid, bss->ssid_len))
+			clear = 1;
+
+		/* Check for a BSSID match */
+		if (   clear_bssid_flag
+		    && !compare_ether_addr(bss->bssid, scan_cfg->bssid))
+			clear = 1;
+
+		if (clear) {
+			list_move_tail (&bss->list, &adapter->network_free_list);
+			clear_bss_descriptor(bss);
+		}
+	}
+	mutex_unlock(&adapter->lock);
+}
+
+
 /**
  *  @brief Internal function used to start a scan based on an input config
  *
@@ -736,19 +780,19 @@ static int wlan_scan_channel_list(wlan_p
  *  @return              0 or < 0 if error
  */
 int wlan_scan_networks(wlan_private * priv,
-			      const struct wlan_ioctl_user_scan_cfg * puserscanin)
+			      const struct wlan_ioctl_user_scan_cfg * puserscanin,
+			      int full_scan)
 {
-	wlan_adapter *adapter = priv->adapter;
+	wlan_adapter * adapter = priv->adapter;
 	struct mrvlietypes_chanlistparamset *pchantlvout;
 	struct chanscanparamset * scan_chan_list = NULL;
 	struct wlan_scan_cmd_config * scan_cfg = NULL;
-	u8 keeppreviousscan;
 	u8 filteredscan;
 	u8 scancurrentchanonly;
 	int maxchanperscan;
 	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	scan_chan_list = kzalloc(sizeof(struct chanscanparamset) *
 				WLAN_IOCTL_USER_SCAN_CHAN_MAX, GFP_KERNEL);
@@ -769,22 +813,14 @@ int wlan_scan_networks(wlan_private * pr
 		goto out;
 	}
 
-	keeppreviousscan = 0;
-
-	if (puserscanin) {
-		keeppreviousscan = puserscanin->keeppreviousscan;
-	}
-
-	if (!keeppreviousscan) {
-		memset(adapter->scantable, 0x00,
-		       sizeof(struct bss_descriptor) * MRVDRV_MAX_BSSID_LIST);
-		adapter->numinscantable = 0;
-	}
+	clear_selected_scan_list_entries(adapter, puserscanin);
 
 	/* Keep the data path active if we are only scanning our current channel */
 	if (!scancurrentchanonly) {
-		netif_stop_queue(priv->wlan_dev.netdev);
-		netif_carrier_off(priv->wlan_dev.netdev);
+		netif_stop_queue(priv->dev);
+		netif_carrier_off(priv->dev);
+		netif_stop_queue(priv->mesh_dev);
+		netif_carrier_off(priv->mesh_dev);
 	}
 
 	ret = wlan_scan_channel_list(priv,
@@ -792,7 +828,9 @@ int wlan_scan_networks(wlan_private * pr
 				     filteredscan,
 				     scan_cfg,
 				     pchantlvout,
-				     scan_chan_list);
+				     scan_chan_list,
+				     puserscanin,
+				     full_scan);
 
 	/*  Process the resulting scan table:
 	 *    - Remove any bad ssids
@@ -801,8 +839,10 @@ int wlan_scan_networks(wlan_private * pr
 	wlan_scan_process_results(priv);
 
 	if (priv->adapter->connect_status == libertas_connected) {
-		netif_carrier_on(priv->wlan_dev.netdev);
-		netif_wake_queue(priv->wlan_dev.netdev);
+		netif_carrier_on(priv->dev);
+		netif_wake_queue(priv->dev);
+		netif_carrier_on(priv->mesh_dev);
+		netif_wake_queue(priv->mesh_dev);
 	}
 
 out:
@@ -812,7 +852,7 @@ out:
 	if (scan_chan_list)
 		kfree(scan_chan_list);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
 	return ret;
 }
 
@@ -843,7 +883,7 @@ void wlan_ret_802_11_scan_get_tlv_ptrs(s
 	tlvbufleft = tlvbufsize;
 	*ptsftlv = NULL;
 
-	lbs_pr_debug(1, "SCAN_RESP: tlvbufsize = %d\n", tlvbufsize);
+	lbs_deb_scan("SCAN_RESP: tlvbufsize = %d\n", tlvbufsize);
 	lbs_dbg_hex("SCAN_RESP: TLV Buf", (u8 *) ptlv, tlvbufsize);
 
 	while (tlvbufleft >= sizeof(struct mrvlietypesheader)) {
@@ -856,7 +896,7 @@ void wlan_ret_802_11_scan_get_tlv_ptrs(s
 			break;
 
 		default:
-			lbs_pr_debug(1, "SCAN_RESP: Unhandled TLV = %d\n",
+			lbs_deb_scan("SCAN_RESP: Unhandled TLV = %d\n",
 			       tlvtype);
 			/* Give up, this seems corrupted */
 			return;
@@ -875,12 +915,12 @@ void wlan_ret_802_11_scan_get_tlv_ptrs(s
  *   response or beacon from the scan command.  Record information as needed
  *   in the scan table struct bss_descriptor for that entry.
  *
- *  @param pBSSIDEntry  Output parameter: Pointer to the BSS Entry
+ *  @param bss  Output parameter: Pointer to the BSS Entry
  *
  *  @return             0 or -1
  */
-static int InterpretBSSDescriptionWithIE(struct bss_descriptor * pBSSEntry,
-					 u8 ** pbeaconinfo, int *bytesleft)
+static int libertas_process_bss(struct bss_descriptor * bss,
+				u8 ** pbeaconinfo, int *bytesleft)
 {
 	enum ieeetypes_elementid elemID;
 	struct ieeetypes_fhparamset *pFH;
@@ -897,13 +937,14 @@ static int InterpretBSSDescriptionWithIE
 	u16 beaconsize;
 	u8 founddatarateie;
 	int bytesleftforcurrentbeacon;
+	int ret;
 
 	struct IE_WPA *pIe;
 	const u8 oui01[4] = { 0x00, 0x50, 0xf2, 0x01 };
 
 	struct ieeetypes_countryinfoset *pcountryinfo;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	founddatarateie = 0;
 	ratesize = 0;
@@ -911,8 +952,7 @@ static int InterpretBSSDescriptionWithIE
 
 	if (*bytesleft >= sizeof(beaconsize)) {
 		/* Extract & convert beacon size from the command buffer */
-		memcpy(&beaconsize, *pbeaconinfo, sizeof(beaconsize));
-		beaconsize = le16_to_cpu(beaconsize);
+		beaconsize = le16_to_cpup((void *)*pbeaconinfo);
 		*bytesleft -= sizeof(beaconsize);
 		*pbeaconinfo += sizeof(beaconsize);
 	}
@@ -934,17 +974,14 @@ static int InterpretBSSDescriptionWithIE
 
 	bytesleftforcurrentbeacon = beaconsize;
 
-	memcpy(pBSSEntry->macaddress, pcurrentptr, ETH_ALEN);
-	lbs_pr_debug(1, "InterpretIE: AP MAC Addr-%x:%x:%x:%x:%x:%x\n",
-	       pBSSEntry->macaddress[0], pBSSEntry->macaddress[1],
-	       pBSSEntry->macaddress[2], pBSSEntry->macaddress[3],
-	       pBSSEntry->macaddress[4], pBSSEntry->macaddress[5]);
+	memcpy(bss->bssid, pcurrentptr, ETH_ALEN);
+	lbs_deb_scan("process_bss: AP BSSID " MAC_FMT "\n", MAC_ARG(bss->bssid));
 
 	pcurrentptr += ETH_ALEN;
 	bytesleftforcurrentbeacon -= ETH_ALEN;
 
 	if (bytesleftforcurrentbeacon < 12) {
-		lbs_pr_debug(1, "InterpretIE: Not enough bytes left\n");
+		lbs_deb_scan("process_bss: Not enough bytes left\n");
 		return -1;
 	}
 
@@ -954,51 +991,48 @@ static int InterpretBSSDescriptionWithIE
 	 */
 
 	/* RSSI is 1 byte long */
-	pBSSEntry->rssi = le32_to_cpu((long)(*pcurrentptr));
-	lbs_pr_debug(1, "InterpretIE: RSSI=%02X\n", *pcurrentptr);
+	bss->rssi = *pcurrentptr;
+	lbs_deb_scan("process_bss: RSSI=%02X\n", *pcurrentptr);
 	pcurrentptr += 1;
 	bytesleftforcurrentbeacon -= 1;
 
 	/* time stamp is 8 bytes long */
-	memcpy(fixedie.timestamp, pcurrentptr, 8);
-	memcpy(pBSSEntry->timestamp, pcurrentptr, 8);
+	fixedie.timestamp = bss->timestamp = le64_to_cpup((void *)pcurrentptr);
 	pcurrentptr += 8;
 	bytesleftforcurrentbeacon -= 8;
 
 	/* beacon interval is 2 bytes long */
-	memcpy(&fixedie.beaconinterval, pcurrentptr, 2);
-	pBSSEntry->beaconperiod = le16_to_cpu(fixedie.beaconinterval);
+	fixedie.beaconinterval = bss->beaconperiod = le16_to_cpup((void *)pcurrentptr);
 	pcurrentptr += 2;
 	bytesleftforcurrentbeacon -= 2;
 
 	/* capability information is 2 bytes long */
-	memcpy(&fixedie.capabilities, pcurrentptr, 2);
-	lbs_pr_debug(1, "InterpretIE: fixedie.capabilities=0x%X\n",
+        memcpy(&fixedie.capabilities, pcurrentptr, 2);
+	lbs_deb_scan("process_bss: fixedie.capabilities=0x%X\n",
 	       fixedie.capabilities);
-	fixedie.capabilities = le16_to_cpu(fixedie.capabilities);
 	pcap = (struct ieeetypes_capinfo *) & fixedie.capabilities;
-	memcpy(&pBSSEntry->cap, pcap, sizeof(struct ieeetypes_capinfo));
+	memcpy(&bss->cap, pcap, sizeof(struct ieeetypes_capinfo));
 	pcurrentptr += 2;
 	bytesleftforcurrentbeacon -= 2;
 
 	/* rest of the current buffer are IE's */
-	lbs_pr_debug(1, "InterpretIE: IElength for this AP = %d\n",
+	lbs_deb_scan("process_bss: IE length for this AP = %d\n",
 	       bytesleftforcurrentbeacon);
 
-	lbs_dbg_hex("InterpretIE: IE info", (u8 *) pcurrentptr,
+	lbs_dbg_hex("process_bss: IE info", (u8 *) pcurrentptr,
 		bytesleftforcurrentbeacon);
 
 	if (pcap->privacy) {
-		lbs_pr_debug(1, "InterpretIE: AP WEP enabled\n");
-		pBSSEntry->privacy = wlan802_11privfilter8021xWEP;
+		lbs_deb_scan("process_bss: AP WEP enabled\n");
+		bss->privacy = wlan802_11privfilter8021xWEP;
 	} else {
-		pBSSEntry->privacy = wlan802_11privfilteracceptall;
+		bss->privacy = wlan802_11privfilteracceptall;
 	}
 
 	if (pcap->ibss == 1) {
-		pBSSEntry->mode = IW_MODE_ADHOC;
+		bss->mode = IW_MODE_ADHOC;
 	} else {
-		pBSSEntry->mode = IW_MODE_INFRA;
+		bss->mode = IW_MODE_INFRA;
 	}
 
 	/* process variable IE */
@@ -1007,94 +1041,83 @@ static int InterpretBSSDescriptionWithIE
 		elemlen = *((u8 *) pcurrentptr + 1);
 
 		if (bytesleftforcurrentbeacon < elemlen) {
-			lbs_pr_debug(1, "InterpretIE: error in processing IE, "
+			lbs_deb_scan("process_bss: error in processing IE, "
 			       "bytes left < IE length\n");
 			bytesleftforcurrentbeacon = 0;
 			continue;
 		}
 
 		switch (elemID) {
-
 		case SSID:
-			pBSSEntry->ssid.ssidlength = elemlen;
-			memcpy(pBSSEntry->ssid.ssid, (pcurrentptr + 2),
-			       elemlen);
-			lbs_pr_debug(1, "ssid: %32s", pBSSEntry->ssid.ssid);
+			bss->ssid_len = elemlen;
+			memcpy(bss->ssid, (pcurrentptr + 2), elemlen);
+			lbs_deb_scan("ssid '%s', ssid length %u\n",
+			             escape_essid(bss->ssid, bss->ssid_len),
+			             bss->ssid_len);
 			break;
 
 		case SUPPORTED_RATES:
-			memcpy(pBSSEntry->datarates, (pcurrentptr + 2),
-			       elemlen);
-			memmove(pBSSEntry->libertas_supported_rates, (pcurrentptr + 2),
+			memcpy(bss->datarates, (pcurrentptr + 2), elemlen);
+			memmove(bss->libertas_supported_rates, (pcurrentptr + 2),
 				elemlen);
 			ratesize = elemlen;
 			founddatarateie = 1;
 			break;
 
 		case EXTRA_IE:
-			lbs_pr_debug(1, "InterpretIE: EXTRA_IE Found!\n");
-			pBSSEntry->extra_ie = 1;
+			lbs_deb_scan("process_bss: EXTRA_IE Found!\n");
 			break;
 
 		case FH_PARAM_SET:
 			pFH = (struct ieeetypes_fhparamset *) pcurrentptr;
-			memmove(&pBSSEntry->phyparamset.fhparamset, pFH,
+			memmove(&bss->phyparamset.fhparamset, pFH,
 				sizeof(struct ieeetypes_fhparamset));
-			pBSSEntry->phyparamset.fhparamset.dwelltime
-			    =
-			    le16_to_cpu(pBSSEntry->phyparamset.fhparamset.
-					     dwelltime);
+#if 0 /* I think we can store these LE */
+			bss->phyparamset.fhparamset.dwelltime
+			    = le16_to_cpu(bss->phyparamset.fhparamset.dwelltime);
+#endif
 			break;
 
 		case DS_PARAM_SET:
 			pDS = (struct ieeetypes_dsparamset *) pcurrentptr;
-
-			pBSSEntry->channel = pDS->currentchan;
-
-			memcpy(&pBSSEntry->phyparamset.dsparamset, pDS,
+			bss->channel = pDS->currentchan;
+			memcpy(&bss->phyparamset.dsparamset, pDS,
 			       sizeof(struct ieeetypes_dsparamset));
 			break;
 
 		case CF_PARAM_SET:
 			pCF = (struct ieeetypes_cfparamset *) pcurrentptr;
-
-			memcpy(&pBSSEntry->ssparamset.cfparamset, pCF,
+			memcpy(&bss->ssparamset.cfparamset, pCF,
 			       sizeof(struct ieeetypes_cfparamset));
 			break;
 
 		case IBSS_PARAM_SET:
 			pibss = (struct ieeetypes_ibssparamset *) pcurrentptr;
-			pBSSEntry->atimwindow =
-			    le32_to_cpu(pibss->atimwindow);
-
-			memmove(&pBSSEntry->ssparamset.ibssparamset, pibss,
+			bss->atimwindow = le32_to_cpu(pibss->atimwindow);
+			memmove(&bss->ssparamset.ibssparamset, pibss,
 				sizeof(struct ieeetypes_ibssparamset));
-
-			pBSSEntry->ssparamset.ibssparamset.atimwindow
-			    =
-			    le16_to_cpu(pBSSEntry->ssparamset.ibssparamset.
-					     atimwindow);
+#if 0
+			bss->ssparamset.ibssparamset.atimwindow
+			    = le16_to_cpu(bss->ssparamset.ibssparamset.atimwindow);
+#endif
 			break;
 
 			/* Handle Country Info IE */
 		case COUNTRY_INFO:
-			pcountryinfo =
-			    (struct ieeetypes_countryinfoset *) pcurrentptr;
-
-			if (pcountryinfo->len <
-			    sizeof(pcountryinfo->countrycode)
+			pcountryinfo = (struct ieeetypes_countryinfoset *) pcurrentptr;
+			if (pcountryinfo->len < sizeof(pcountryinfo->countrycode)
 			    || pcountryinfo->len > 254) {
-				lbs_pr_debug(1, "InterpretIE: 11D- Err "
+				lbs_deb_scan("process_bss: 11D- Err "
 				       "CountryInfo len =%d min=%zd max=254\n",
 				       pcountryinfo->len,
 				       sizeof(pcountryinfo->countrycode));
-				LEAVE();
-				return -1;
+				ret = -1;
+				goto done;
 			}
 
-			memcpy(&pBSSEntry->countryinfo,
+			memcpy(&bss->countryinfo,
 			       pcountryinfo, pcountryinfo->len + 2);
-			lbs_dbg_hex("InterpretIE: 11D- CountryInfo:",
+			lbs_dbg_hex("process_bss: 11D- CountryInfo:",
 				(u8 *) pcountryinfo,
 				(u32) (pcountryinfo->len + 2));
 			break;
@@ -1114,12 +1137,10 @@ static int InterpretBSSDescriptionWithIE
 					bytestocopy = elemlen;
 				}
 
-				pRate = (u8 *) pBSSEntry->datarates;
+				pRate = (u8 *) bss->datarates;
 				pRate += ratesize;
 				memmove(pRate, (pcurrentptr + 2), bytestocopy);
-
-				pRate = (u8 *) pBSSEntry->libertas_supported_rates;
-
+				pRate = (u8 *) bss->libertas_supported_rates;
 				pRate += ratesize;
 				memmove(pRate, (pcurrentptr + 2), bytestocopy);
 			}
@@ -1132,24 +1153,17 @@ static int InterpretBSSDescriptionWithIE
 			if (memcmp(pIe->oui, oui01, sizeof(oui01)))
 				break;
 
-			pBSSEntry->wpa_ie_len = min_t(size_t,
-				elemlen + IE_ID_LEN_FIELDS_BYTES,
-				sizeof(pBSSEntry->wpa_ie));
-			memcpy(pBSSEntry->wpa_ie, pcurrentptr,
-				pBSSEntry->wpa_ie_len);
-			lbs_dbg_hex("InterpretIE: Resp WPA_IE",
-				pBSSEntry->wpa_ie, elemlen);
+			bss->wpa_ie_len = min(elemlen + IE_ID_LEN_FIELDS_BYTES,
+				MAX_WPA_IE_LEN);
+			memcpy(bss->wpa_ie, pcurrentptr, bss->wpa_ie_len);
+			lbs_dbg_hex("process_bss: WPA IE", bss->wpa_ie, elemlen);
 			break;
 		case WPA2_IE:
 			pIe = (struct IE_WPA *)pcurrentptr;
-
-			pBSSEntry->rsn_ie_len = min_t(size_t,
-				elemlen + IE_ID_LEN_FIELDS_BYTES,
-				sizeof(pBSSEntry->rsn_ie));
-			memcpy(pBSSEntry->rsn_ie, pcurrentptr,
-				pBSSEntry->rsn_ie_len);
-			lbs_dbg_hex("InterpretIE: Resp WPA2_IE",
-				pBSSEntry->rsn_ie, elemlen);
+			bss->rsn_ie_len = min(elemlen + IE_ID_LEN_FIELDS_BYTES,
+				MAX_WPA_IE_LEN);
+			memcpy(bss->rsn_ie, pcurrentptr, bss->rsn_ie_len);
+			lbs_dbg_hex("process_bss: RSN_IE", bss->rsn_ie, elemlen);
 			break;
 		case TIM:
 			break;
@@ -1165,7 +1179,14 @@ static int InterpretBSSDescriptionWithIE
 
 	}			/* while (bytesleftforcurrentbeacon > 2) */
 
-	return 0;
+	/* Timestamp */
+	bss->last_scanned = jiffies;
+
+	ret = 0;
+
+done:
+	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -1176,15 +1197,12 @@ static int InterpretBSSDescriptionWithIE
  *
  *  @return         0--ssid is same, otherwise is different
  */
-int libertas_SSID_cmp(struct WLAN_802_11_SSID *ssid1, struct WLAN_802_11_SSID *ssid2)
+int libertas_ssid_cmp(u8 *ssid1, u8 ssid1_len, u8 *ssid2, u8 ssid2_len)
 {
-	if (!ssid1 || !ssid2)
-		return -1;
-
-	if (ssid1->ssidlength != ssid2->ssidlength)
+	if (ssid1_len != ssid2_len)
 		return -1;
 
-	return memcmp(ssid1->ssid, ssid2->ssid, ssid1->ssidlength);
+	return memcmp(ssid1, ssid2, ssid1_len);
 }
 
 /**
@@ -1196,38 +1214,41 @@ int libertas_SSID_cmp(struct WLAN_802_11
  *
  *  @return         index in BSSID list, or error return code (< 0)
  */
-int libertas_find_BSSID_in_list(wlan_adapter * adapter, u8 * bssid, u8 mode)
+struct bss_descriptor * libertas_find_bssid_in_list(wlan_adapter * adapter,
+		u8 * bssid, u8 mode)
 {
-	int ret = -ENETUNREACH;
-	int i;
+	struct bss_descriptor * iter_bss;
+	struct bss_descriptor * found_bss = NULL;
 
 	if (!bssid)
-		return -EFAULT;
+		return NULL;
 
-	lbs_pr_debug(1, "FindBSSID: Num of BSSIDs = %d\n",
-	       adapter->numinscantable);
+	lbs_dbg_hex("libertas_find_BSSID_in_list: looking for ",
+		bssid, ETH_ALEN);
 
-	/* Look through the scan table for a compatible match. The ret return
-	 *   variable will be equal to the index in the scan table (greater
-	 *   than zero) if the network is compatible.  The loop will continue
-	 *   past a matched bssid that is not compatible in case there is an
-	 *   AP with multiple SSIDs assigned to the same BSSID
+	/* Look through the scan table for a compatible match.  The loop will
+	 *   continue past a matched bssid that is not compatible in case there
+	 *   is an AP with multiple SSIDs assigned to the same BSSID
 	 */
-	for (i = 0; ret < 0 && i < adapter->numinscantable; i++) {
-		if (!memcmp(adapter->scantable[i].macaddress, bssid, ETH_ALEN)) {
-			switch (mode) {
-			case IW_MODE_INFRA:
-			case IW_MODE_ADHOC:
-				ret = is_network_compatible(adapter, i, mode);
-				break;
-			default:
-				ret = i;
+	mutex_lock(&adapter->lock);
+	list_for_each_entry (iter_bss, &adapter->network_list, list) {
+		if (compare_ether_addr(iter_bss->bssid, bssid))
+			continue; /* bssid doesn't match */
+		switch (mode) {
+		case IW_MODE_INFRA:
+		case IW_MODE_ADHOC:
+			if (!is_network_compatible(adapter, iter_bss, mode))
 				break;
-			}
+			found_bss = iter_bss;
+			break;
+		default:
+			found_bss = iter_bss;
+			break;
 		}
 	}
+	mutex_unlock(&adapter->lock);
 
-	return ret;
+	return found_bss;
 }
 
 /**
@@ -1240,61 +1261,60 @@ int libertas_find_BSSID_in_list(wlan_ada
  *
  *  @return         index in BSSID list
  */
-int libertas_find_SSID_in_list(wlan_adapter * adapter,
-		   struct WLAN_802_11_SSID *ssid, u8 * bssid, u8 mode)
+struct bss_descriptor * libertas_find_ssid_in_list(wlan_adapter * adapter,
+		   u8 *ssid, u8 ssid_len, u8 * bssid, u8 mode,
+		   int channel)
 {
-	int net = -ENETUNREACH;
 	u8 bestrssi = 0;
-	int i;
-	int j;
-
-	lbs_pr_debug(1, "Num of Entries in Table = %d\n", adapter->numinscantable);
+	struct bss_descriptor * iter_bss = NULL;
+	struct bss_descriptor * found_bss = NULL;
+	struct bss_descriptor * tmp_oldest = NULL;
+
+	mutex_lock(&adapter->lock);
+
+	list_for_each_entry (iter_bss, &adapter->network_list, list) {
+		if (   !tmp_oldest
+		    || (iter_bss->last_scanned < tmp_oldest->last_scanned))
+			tmp_oldest = iter_bss;
+
+		if (libertas_ssid_cmp(iter_bss->ssid, iter_bss->ssid_len,
+		                      ssid, ssid_len) != 0)
+			continue; /* ssid doesn't match */
+		if (bssid && compare_ether_addr(iter_bss->bssid, bssid) != 0)
+			continue; /* bssid doesn't match */
+		if ((channel > 0) && (iter_bss->channel != channel))
+			continue; /* channel doesn't match */
 
-	for (i = 0; i < adapter->numinscantable; i++) {
-		if (!libertas_SSID_cmp(&adapter->scantable[i].ssid, ssid) &&
-		    (!bssid ||
-		     !memcmp(adapter->scantable[i].
-			     macaddress, bssid, ETH_ALEN))) {
-			switch (mode) {
-			case IW_MODE_INFRA:
-			case IW_MODE_ADHOC:
-				j = is_network_compatible(adapter, i, mode);
-
-				if (j >= 0) {
-					if (bssid) {
-						return i;
-					}
-
-					if (SCAN_RSSI
-					    (adapter->scantable[i].rssi)
-					    > bestrssi) {
-						bestrssi =
-						    SCAN_RSSI(adapter->
-							      scantable[i].
-							      rssi);
-						net = i;
-					}
-				} else {
-					if (net == -ENETUNREACH) {
-						net = j;
-					}
-				}
-				break;
-			case IW_MODE_AUTO:
-			default:
-				if (SCAN_RSSI(adapter->scantable[i].rssi)
-				    > bestrssi) {
-					bestrssi =
-					    SCAN_RSSI(adapter->scantable[i].
-						      rssi);
-					net = i;
-				}
+		switch (mode) {
+		case IW_MODE_INFRA:
+		case IW_MODE_ADHOC:
+			if (!is_network_compatible(adapter, iter_bss, mode))
 				break;
+
+			if (bssid) {
+				/* Found requested BSSID */
+				found_bss = iter_bss;
+				goto out;
+			}
+
+			if (SCAN_RSSI(iter_bss->rssi) > bestrssi) {
+				bestrssi = SCAN_RSSI(iter_bss->rssi);
+				found_bss = iter_bss;
+			}
+			break;
+		case IW_MODE_AUTO:
+		default:
+			if (SCAN_RSSI(iter_bss->rssi) > bestrssi) {
+				bestrssi = SCAN_RSSI(iter_bss->rssi);
+				found_bss = iter_bss;
 			}
+			break;
 		}
 	}
 
-	return net;
+out:
+	mutex_unlock(&adapter->lock);
+	return found_bss;
 }
 
 /**
@@ -1307,43 +1327,38 @@ int libertas_find_SSID_in_list(wlan_adap
  *
  *  @return         index in BSSID list
  */
-int libertas_find_best_SSID_in_list(wlan_adapter * adapter, u8 mode)
+struct bss_descriptor * libertas_find_best_ssid_in_list(wlan_adapter * adapter,
+		u8 mode)
 {
-	int bestnet = -ENETUNREACH;
 	u8 bestrssi = 0;
-	int i;
+	struct bss_descriptor * iter_bss;
+	struct bss_descriptor * best_bss = NULL;
 
-	ENTER();
+	mutex_lock(&adapter->lock);
 
-	lbs_pr_debug(1, "Num of BSSIDs = %d\n", adapter->numinscantable);
-
-	for (i = 0; i < adapter->numinscantable; i++) {
+	list_for_each_entry (iter_bss, &adapter->network_list, list) {
 		switch (mode) {
 		case IW_MODE_INFRA:
 		case IW_MODE_ADHOC:
-			if (is_network_compatible(adapter, i, mode) >= 0) {
-				if (SCAN_RSSI(adapter->scantable[i].rssi) >
-				    bestrssi) {
-					bestrssi =
-					    SCAN_RSSI(adapter->scantable[i].
-						      rssi);
-					bestnet = i;
-				}
-			}
+			if (!is_network_compatible(adapter, iter_bss, mode))
+				break;
+			if (SCAN_RSSI(iter_bss->rssi) <= bestrssi)
+				break;
+			bestrssi = SCAN_RSSI(iter_bss->rssi);
+			best_bss = iter_bss;
 			break;
 		case IW_MODE_AUTO:
 		default:
-			if (SCAN_RSSI(adapter->scantable[i].rssi) > bestrssi) {
-				bestrssi =
-				    SCAN_RSSI(adapter->scantable[i].rssi);
-				bestnet = i;
-			}
+			if (SCAN_RSSI(iter_bss->rssi) <= bestrssi)
+				break;
+			bestrssi = SCAN_RSSI(iter_bss->rssi);
+			best_bss = iter_bss;
 			break;
 		}
 	}
 
-	LEAVE();
-	return bestnet;
+	mutex_unlock(&adapter->lock);
+	return best_bss;
 }
 
 /**
@@ -1354,41 +1369,30 @@ int libertas_find_best_SSID_in_list(wlan
  *
  *  @return             0--success, otherwise--fail
  */
-int libertas_find_best_network_SSID(wlan_private * priv,
-                                    struct WLAN_802_11_SSID *pSSID,
-                                    u8 preferred_mode, u8 *out_mode)
+int libertas_find_best_network_ssid(wlan_private * priv,
+		u8 *out_ssid, u8 *out_ssid_len, u8 preferred_mode, u8 *out_mode)
 {
 	wlan_adapter *adapter = priv->adapter;
-	int ret = 0;
-	struct bss_descriptor *preqbssid;
-	int i;
-
-	ENTER();
+	int ret = -1;
+	struct bss_descriptor * found;
 
-	memset(pSSID, 0, sizeof(struct WLAN_802_11_SSID));
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-	wlan_scan_networks(priv, NULL);
+	wlan_scan_networks(priv, NULL, 1);
 	if (adapter->surpriseremoved)
 		return -1;
+
 	wait_event_interruptible(adapter->cmd_pending, !adapter->nr_cmd_pending);
 
-	i = libertas_find_best_SSID_in_list(adapter, preferred_mode);
-	if (i < 0) {
-		ret = -1;
-		goto out;
+	found = libertas_find_best_ssid_in_list(adapter, preferred_mode);
+	if (found && (found->ssid_len > 0)) {
+		memcpy(out_ssid, &found->ssid, IW_ESSID_MAX_SIZE);
+		*out_ssid_len = found->ssid_len;
+		*out_mode = found->mode;
+		ret = 0;
 	}
 
-	preqbssid = &adapter->scantable[i];
-	memcpy(pSSID, &preqbssid->ssid,
-	       sizeof(struct WLAN_802_11_SSID));
-	*out_mode = preqbssid->mode;
-
-	if (!pSSID->ssidlength) {
-		ret = -1;
-	}
-
-out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
 	return ret;
 }
 
@@ -1407,20 +1411,15 @@ int libertas_set_scan(struct net_device 
 {
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
-	union iwreq_data wrqu;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_SCAN);
 
-	if (!wlan_scan_networks(priv, NULL)) {
-		memset(&wrqu, 0, sizeof(union iwreq_data));
-		wireless_send_event(priv->wlan_dev.netdev, SIOCGIWSCAN, &wrqu,
-				    NULL);
-	}
+	wlan_scan_networks(priv, NULL, 0);
 
 	if (adapter->surpriseremoved)
 		return -1;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_SCAN);
 	return 0;
 }
 
@@ -1433,32 +1432,31 @@ int libertas_set_scan(struct net_device 
  *
  *  @return                0-success, otherwise fail
  */
-int libertas_send_specific_SSID_scan(wlan_private * priv,
-			 struct WLAN_802_11_SSID *prequestedssid,
-			 u8 keeppreviousscan)
+int libertas_send_specific_ssid_scan(wlan_private * priv,
+			u8 *ssid, u8 ssid_len, u8 clear_ssid)
 {
 	wlan_adapter *adapter = priv->adapter;
 	struct wlan_ioctl_user_scan_cfg scancfg;
+	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-	if (prequestedssid == NULL) {
-		return -1;
-	}
+	if (!ssid_len)
+		goto out;
 
 	memset(&scancfg, 0x00, sizeof(scancfg));
+	memcpy(scancfg.ssid, ssid, ssid_len);
+	scancfg.ssid_len = ssid_len;
+	scancfg.clear_ssid = clear_ssid;
 
-	memcpy(scancfg.specificSSID, prequestedssid->ssid,
-	       prequestedssid->ssidlength);
-	scancfg.keeppreviousscan = keeppreviousscan;
-
-	wlan_scan_networks(priv, &scancfg);
+	wlan_scan_networks(priv, &scancfg, 1);
 	if (adapter->surpriseremoved)
 		return -1;
 	wait_event_interruptible(adapter->cmd_pending, !adapter->nr_cmd_pending);
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave(LBS_DEB_ASSOC);
+	return ret;
 }
 
 /**
@@ -1470,304 +1468,235 @@ int libertas_send_specific_SSID_scan(wla
  *
  *  @return          0-success, otherwise fail
  */
-int libertas_send_specific_BSSID_scan(wlan_private * priv, u8 * bssid, u8 keeppreviousscan)
+int libertas_send_specific_bssid_scan(wlan_private * priv, u8 * bssid, u8 clear_bssid)
 {
 	struct wlan_ioctl_user_scan_cfg scancfg;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
-	if (bssid == NULL) {
-		return -1;
-	}
+	if (bssid == NULL)
+		goto out;
 
 	memset(&scancfg, 0x00, sizeof(scancfg));
-	memcpy(scancfg.specificBSSID, bssid, sizeof(scancfg.specificBSSID));
-	scancfg.keeppreviousscan = keeppreviousscan;
+	memcpy(scancfg.bssid, bssid, ETH_ALEN);
+	scancfg.clear_bssid = clear_bssid;
 
-	wlan_scan_networks(priv, &scancfg);
+	wlan_scan_networks(priv, &scancfg, 1);
 	if (priv->adapter->surpriseremoved)
 		return -1;
 	wait_event_interruptible(priv->adapter->cmd_pending,
 		!priv->adapter->nr_cmd_pending);
 
-	LEAVE();
+out:
+	lbs_deb_leave(LBS_DEB_ASSOC);
 	return 0;
 }
 
-/**
- *  @brief  Retrieve the scan table entries via wireless tools IOCTL call
- *
- *  @param dev          A pointer to net_device structure
- *  @param info         A pointer to iw_request_info structure
- *  @param dwrq         A pointer to iw_point structure
- *  @param extra        A pointer to extra data buf
- *
- *  @return             0 --success, otherwise fail
- */
-int libertas_get_scan(struct net_device *dev, struct iw_request_info *info,
-		  struct iw_point *dwrq, char *extra)
+static inline char *libertas_translate_scan(wlan_private *priv,
+					char *start, char *stop,
+					struct bss_descriptor *bss)
 {
-	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
-	int ret = 0;
-	char *current_ev = extra;
-	char *end_buf = extra + IW_SCAN_MAX_DATA;
 	struct chan_freq_power *cfp;
-	struct bss_descriptor *pscantable;
 	char *current_val;	/* For rates */
 	struct iw_event iwe;	/* Temporary buffer */
-	int i;
 	int j;
-	int rate;
 #define PERFECT_RSSI ((u8)50)
 #define WORST_RSSI   ((u8)0)
 #define RSSI_DIFF    ((u8)(PERFECT_RSSI - WORST_RSSI))
 	u8 rssi;
 
-	u8 buf[16 + 256 * 2];
-	u8 *ptr;
+	cfp = libertas_find_cfp_by_band_and_channel(adapter, 0, bss->channel);
+	if (!cfp) {
+		lbs_deb_scan("Invalid channel number %d\n", bss->channel);
+		return NULL;
+	}
+
+	/* First entry *MUST* be the AP BSSID */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	memcpy(iwe.u.ap_addr.sa_data, &bss->bssid, ETH_ALEN);
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/* SSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = min((u32) bss->ssid_len, (u32) IW_ESSID_MAX_SIZE);
+	start = iwe_stream_add_point(start, stop, &iwe, bss->ssid);
+
+	/* Mode */
+	iwe.cmd = SIOCGIWMODE;
+	iwe.u.mode = bss->mode;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
+
+	/* Frequency */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = (long)cfp->freq * 100000;
+	iwe.u.freq.e = 1;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.updated = IW_QUAL_ALL_UPDATED;
+	iwe.u.qual.level = SCAN_RSSI(bss->rssi);
+
+	rssi = iwe.u.qual.level - MRVDRV_NF_DEFAULT_SCAN_VALUE;
+	iwe.u.qual.qual =
+	    (100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - rssi) *
+	     (15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI - rssi))) /
+	    (RSSI_DIFF * RSSI_DIFF);
+	if (iwe.u.qual.qual > 100)
+		iwe.u.qual.qual = 100;
 
-	ENTER();
+	if (adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
+		iwe.u.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
+	} else {
+		iwe.u.qual.noise =
+		    CAL_NF(adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+	}
 
-	/*
-	 * if there's either commands in the queue or one being
-	 * processed return -EAGAIN for iwlist to retry later.
+	/* Locally created ad-hoc BSSs won't have beacons if this is the
+	 * only station in the adhoc network; so get signal strength
+	 * from receive statistics.
 	 */
-    if (adapter->nr_cmd_pending)
-		return -EAGAIN;
-
-	if (adapter->connect_status == libertas_connected)
-		lbs_pr_debug(1, "Current ssid: %32s\n",
-		       adapter->curbssparams.ssid.ssid);
+	if ((adapter->mode == IW_MODE_ADHOC)
+	    && adapter->adhoccreate
+	    && !libertas_ssid_cmp(adapter->curbssparams.ssid,
+	                          adapter->curbssparams.ssid_len,
+	                          bss->ssid, bss->ssid_len)) {
+		int snr, nf;
+		snr = adapter->SNR[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+		nf = adapter->NF[TYPE_RXPD][TYPE_AVG] / AVG_SCALE;
+		iwe.u.qual.level = CAL_RSSI(snr, nf);
+	}
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (bss->privacy) {
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	} else {
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	}
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(start, stop, &iwe, bss->ssid);
 
-	lbs_pr_debug(1, "Scan: Get: numinscantable = %d\n",
-	       adapter->numinscantable);
+	current_val = start + IW_EV_LCP_LEN;
 
-	/* The old API using SIOCGIWAPLIST had a hard limit of IW_MAX_AP.
-	 * The new API using SIOCGIWSCAN is only limited by buffer size
-	 * WE-14 -> WE-16 the buffer is limited to IW_SCAN_MAX_DATA bytes
-	 * which is 4096.
-	 */
-	for (i = 0; i < adapter->numinscantable; i++) {
-		if ((current_ev + MAX_SCAN_CELL_SIZE) >= end_buf) {
-			lbs_pr_debug(1, "i=%d break out: current_ev=%p end_buf=%p "
-			       "MAX_SCAN_CELL_SIZE=%zd\n",
-			       i, current_ev, end_buf, MAX_SCAN_CELL_SIZE);
-			break;
-		}
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = 0;
+	iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = 0;
+
+	for (j = 0; j < sizeof(bss->libertas_supported_rates); j++) {
+		u8 rate = bss->libertas_supported_rates[j];
+		if (rate == 0)
+			break; /* no more rates */
+		/* Bit rate given in 500 kb/s units (+ 0x80) */
+		iwe.u.bitrate.value = (rate & 0x7f) * 500000;
+		current_val = iwe_stream_add_value(start, current_val,
+					 stop, &iwe, IW_EV_PARAM_LEN);
+	}
+	if ((bss->mode == IW_MODE_ADHOC)
+	    && !libertas_ssid_cmp(adapter->curbssparams.ssid,
+	                          adapter->curbssparams.ssid_len,
+	                          bss->ssid, bss->ssid_len)
+	    && adapter->adhoccreate) {
+		iwe.u.bitrate.value = 22 * 500000;
+		current_val = iwe_stream_add_value(start, current_val,
+					 stop, &iwe, IW_EV_PARAM_LEN);
+	}
+	/* Check if we added any event */
+	if((current_val - start) > IW_EV_LCP_LEN)
+		start = current_val;
+
+	memset(&iwe, 0, sizeof(iwe));
+	if (bss->wpa_ie_len) {
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, bss->wpa_ie, bss->wpa_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = bss->wpa_ie_len;
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
+	}
+
+	memset(&iwe, 0, sizeof(iwe));
+	if (bss->rsn_ie_len) {
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, bss->rsn_ie, bss->rsn_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = bss->rsn_ie_len;
+		start = iwe_stream_add_point(start, stop, &iwe, buf);
+	}
 
-		pscantable = &adapter->scantable[i];
+	return start;
+}
 
-		lbs_pr_debug(1, "i=%d  ssid: %32s\n", i, pscantable->ssid.ssid);
+/**
+ *  @brief  Retrieve the scan table entries via wireless tools IOCTL call
+ *
+ *  @param dev          A pointer to net_device structure
+ *  @param info         A pointer to iw_request_info structure
+ *  @param dwrq         A pointer to iw_point structure
+ *  @param extra        A pointer to extra data buf
+ *
+ *  @return             0 --success, otherwise fail
+ */
+int libertas_get_scan(struct net_device *dev, struct iw_request_info *info,
+		  struct iw_point *dwrq, char *extra)
+{
+#define SCAN_ITEM_SIZE 128
+	wlan_private *priv = dev->priv;
+	wlan_adapter *adapter = priv->adapter;
+	int err = 0;
+	char *ev = extra;
+	char *stop = ev + dwrq->length;
+	struct bss_descriptor * iter_bss;
+	struct bss_descriptor * safe;
+
+	lbs_deb_enter(LBS_DEB_ASSOC);
+
+	/* If we've got an uncompleted scan, schedule the next part */
+	if (!adapter->nr_cmd_pending && adapter->last_scanned_channel)
+		wlan_scan_networks(priv, NULL, 0);
+
+	/* Update RSSI if current BSS is a locally created ad-hoc BSS */
+	if ((adapter->mode == IW_MODE_ADHOC) && adapter->adhoccreate) {
+		libertas_prepare_and_send_command(priv, cmd_802_11_rssi, 0,
+					cmd_option_waitforrsp, 0, NULL);
+	}
+
+	mutex_lock(&adapter->lock);
+	list_for_each_entry_safe (iter_bss, safe, &adapter->network_list, list) {
+		char * next_ev;
+		unsigned long stale_time;
 
-		cfp =
-		    libertas_find_cfp_by_band_and_channel(adapter, 0,
-						 pscantable->channel);
-		if (!cfp) {
-			lbs_pr_debug(1, "Invalid channel number %d\n",
-			       pscantable->channel);
-			continue;
+		if (stop - ev < SCAN_ITEM_SIZE) {
+			err = -E2BIG;
+			break;
 		}
 
-		if (!ssid_valid(&adapter->scantable[i].ssid)) {
+		/* Prune old an old scan result */
+		stale_time = iter_bss->last_scanned + DEFAULT_MAX_SCAN_AGE;
+		if (time_after(jiffies, stale_time)) {
+			list_move_tail (&iter_bss->list,
+			                &adapter->network_free_list);
+			clear_bss_descriptor(iter_bss);
 			continue;
 		}
 
-		/* First entry *MUST* be the AP MAC address */
-		iwe.cmd = SIOCGIWAP;
-		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
-		memcpy(iwe.u.ap_addr.sa_data,
-		       &adapter->scantable[i].macaddress, ETH_ALEN);
-
-		iwe.len = IW_EV_ADDR_LEN;
-		current_ev =
-		    iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
-
-		//Add the ESSID
-		iwe.u.data.length = adapter->scantable[i].ssid.ssidlength;
-
-		if (iwe.u.data.length > 32) {
-			iwe.u.data.length = 32;
-		}
-
-		iwe.cmd = SIOCGIWESSID;
-		iwe.u.data.flags = 1;
-		iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
-		current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe,
-						  adapter->scantable[i].ssid.
-						  ssid);
-
-		//Add mode
-		iwe.cmd = SIOCGIWMODE;
-		iwe.u.mode = adapter->scantable[i].mode;
-		iwe.len = IW_EV_UINT_LEN;
-		current_ev =
-		    iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
-
-		//frequency
-		iwe.cmd = SIOCGIWFREQ;
-		iwe.u.freq.m = (long)cfp->freq * 100000;
-		iwe.u.freq.e = 1;
-		iwe.len = IW_EV_FREQ_LEN;
-		current_ev =
-		    iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
-
-		/* Add quality statistics */
-		iwe.cmd = IWEVQUAL;
-		iwe.u.qual.updated = IW_QUAL_ALL_UPDATED;
-		iwe.u.qual.level = SCAN_RSSI(adapter->scantable[i].rssi);
-
-		rssi = iwe.u.qual.level - MRVDRV_NF_DEFAULT_SCAN_VALUE;
-		iwe.u.qual.qual =
-		    (100 * RSSI_DIFF * RSSI_DIFF - (PERFECT_RSSI - rssi) *
-		     (15 * (RSSI_DIFF) + 62 * (PERFECT_RSSI - rssi))) /
-		    (RSSI_DIFF * RSSI_DIFF);
-		if (iwe.u.qual.qual > 100)
-			iwe.u.qual.qual = 100;
-		else if (iwe.u.qual.qual < 1)
-			iwe.u.qual.qual = 0;
-
-		if (adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
-			iwe.u.qual.noise = MRVDRV_NF_DEFAULT_SCAN_VALUE;
-		} else {
-			iwe.u.qual.noise =
-			    CAL_NF(adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
-		}
-		if ((adapter->mode == IW_MODE_ADHOC) &&
-		    !libertas_SSID_cmp(&adapter->curbssparams.ssid,
-			     &adapter->scantable[i].ssid)
-		    && adapter->adhoccreate) {
-			ret = libertas_prepare_and_send_command(priv,
-						    cmd_802_11_rssi,
-						    0,
-						    cmd_option_waitforrsp,
-						    0, NULL);
-
-			if (!ret) {
-				iwe.u.qual.level =
-				    CAL_RSSI(adapter->SNR[TYPE_RXPD][TYPE_AVG] /
-					     AVG_SCALE,
-					     adapter->NF[TYPE_RXPD][TYPE_AVG] /
-					     AVG_SCALE);
-			}
-		}
-		iwe.len = IW_EV_QUAL_LEN;
-		current_ev =
-		    iwe_stream_add_event(current_ev, end_buf, &iwe, iwe.len);
-
-		/* Add encryption capability */
-		iwe.cmd = SIOCGIWENCODE;
-		if (adapter->scantable[i].privacy) {
-			iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
-		} else {
-			iwe.u.data.flags = IW_ENCODE_DISABLED;
-		}
-		iwe.u.data.length = 0;
-		iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
-		current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe,
-						  adapter->scantable->ssid.
-						  ssid);
-
-		current_val = current_ev + IW_EV_LCP_LEN;
-
-		iwe.cmd = SIOCGIWRATE;
-
-		iwe.u.bitrate.fixed = 0;
-		iwe.u.bitrate.disabled = 0;
-		iwe.u.bitrate.value = 0;
-
-		/* Bit rate given in 500 kb/s units (+ 0x80) */
-		for (j = 0; j < sizeof(adapter->scantable[i].libertas_supported_rates);
-		     j++) {
-			if (adapter->scantable[i].libertas_supported_rates[j] == 0) {
-				break;
-			}
-			rate =
-			    (adapter->scantable[i].libertas_supported_rates[j] & 0x7F) *
-			    500000;
-			if (rate > iwe.u.bitrate.value) {
-				iwe.u.bitrate.value = rate;
-			}
-
-			iwe.u.bitrate.value =
-			    (adapter->scantable[i].libertas_supported_rates[j]
-			     & 0x7f) * 500000;
-			iwe.len = IW_EV_PARAM_LEN;
-			current_ev =
-			    iwe_stream_add_value(current_ev, current_val,
-						 end_buf, &iwe, iwe.len);
-
-		}
-		if ((adapter->scantable[i].mode == IW_MODE_ADHOC)
-		    && !libertas_SSID_cmp(&adapter->curbssparams.ssid,
-				&adapter->scantable[i].ssid)
-		    && adapter->adhoccreate) {
-			iwe.u.bitrate.value = 22 * 500000;
-		}
-		iwe.len = IW_EV_PARAM_LEN;
-		current_ev =
-		    iwe_stream_add_value(current_ev, current_val, end_buf, &iwe,
-					 iwe.len);
-
-		/* Add new value to event */
-		current_val = current_ev + IW_EV_LCP_LEN;
-
-		if (adapter->scantable[i].rsn_ie[0] == WPA2_IE) {
-			memset(&iwe, 0, sizeof(iwe));
-			memset(buf, 0, sizeof(buf));
-			memcpy(buf, adapter->scantable[i].rsn_ie,
-					adapter->scantable[i].rsn_ie_len);
-			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length = adapter->scantable[i].rsn_ie_len;
-			iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
-			current_ev = iwe_stream_add_point(current_ev, end_buf,
-					&iwe, buf);
-		}
-		if (adapter->scantable[i].wpa_ie[0] == WPA_IE) {
-			memset(&iwe, 0, sizeof(iwe));
-			memset(buf, 0, sizeof(buf));
-			memcpy(buf, adapter->scantable[i].wpa_ie,
-					adapter->scantable[i].wpa_ie_len);
-			iwe.cmd = IWEVGENIE;
-			iwe.u.data.length = adapter->scantable[i].wpa_ie_len;
-			iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
-			current_ev = iwe_stream_add_point(current_ev, end_buf,
-					&iwe, buf);
-		}
-
-
-		if (adapter->scantable[i].extra_ie != 0) {
-			memset(&iwe, 0, sizeof(iwe));
-			memset(buf, 0, sizeof(buf));
-			ptr = buf;
-			ptr += sprintf(ptr, "extra_ie");
-			iwe.u.data.length = strlen(buf);
-
-			lbs_pr_debug(1, "iwe.u.data.length %d\n",
-			       iwe.u.data.length);
-			lbs_pr_debug(1, "BUF: %s \n", buf);
-
-			iwe.cmd = IWEVCUSTOM;
-			iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
-			current_ev =
-			    iwe_stream_add_point(current_ev, end_buf, &iwe,
-						 buf);
-		}
-
-		current_val = current_ev + IW_EV_LCP_LEN;
-
-		/*
-		 * Check if we added any event
-		 */
-		if ((current_val - current_ev) > IW_EV_LCP_LEN)
-			current_ev = current_val;
+		/* Translate to WE format this entry */
+		next_ev = libertas_translate_scan(priv, ev, stop, iter_bss);
+		if (next_ev == NULL)
+			continue;
+		ev = next_ev;
 	}
+	mutex_unlock(&adapter->lock);
 
-	dwrq->length = (current_ev - extra);
+	dwrq->length = (ev - extra);
 	dwrq->flags = 0;
 
-	LEAVE();
-	return 0;
+	lbs_deb_leave(LBS_DEB_ASSOC);
+	return err;
 }
 
 /**
@@ -1796,13 +1725,13 @@ int libertas_cmd_80211_scan(wlan_private
 	struct cmd_ds_802_11_scan *pscan = &cmd->params.scan;
 	struct wlan_scan_cmd_config *pscancfg;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
 
 	pscancfg = pdata_buf;
 
 	/* Set fixed field variables in scan command */
 	pscan->bsstype = pscancfg->bsstype;
-	memcpy(pscan->BSSID, pscancfg->specificBSSID, sizeof(pscan->BSSID));
+	memcpy(pscan->BSSID, pscancfg->bssid, sizeof(pscan->BSSID));
 	memcpy(pscan->tlvbuffer, pscancfg->tlvbuffer, pscancfg->tlvbufferlen);
 
 	cmd->command = cpu_to_le16(cmd_802_11_scan);
@@ -1812,12 +1741,26 @@ int libertas_cmd_80211_scan(wlan_private
 				     + sizeof(pscan->BSSID)
 				     + pscancfg->tlvbufferlen + S_DS_GEN);
 
-	lbs_pr_debug(1, "SCAN_CMD: command=%x, size=%x, seqnum=%x\n",
-	       cmd->command, cmd->size, cmd->seqnum);
-	LEAVE();
+	lbs_deb_scan("SCAN_CMD: command=%x, size=%x, seqnum=%x\n",
+		     le16_to_cpu(cmd->command), le16_to_cpu(cmd->size),
+		     le16_to_cpu(cmd->seqnum));
+
+	lbs_deb_leave(LBS_DEB_ASSOC);
 	return 0;
 }
 
+static inline int is_same_network(struct bss_descriptor *src,
+				  struct bss_descriptor *dst)
+{
+	/* A network is only a duplicate if the channel, BSSID, and ESSID
+	 * all match.  We treat all <hidden> with the same BSSID and channel
+	 * as one network */
+	return ((src->ssid_len == dst->ssid_len) &&
+		(src->channel == dst->channel) &&
+		!compare_ether_addr(src->bssid, dst->bssid) &&
+		!memcmp(src->ssid, dst->ssid, src->ssid_len));
+}
+
 /**
  *  @brief This function handles the command response of scan
  *
@@ -1846,38 +1789,45 @@ int libertas_ret_80211_scan(wlan_private
 {
 	wlan_adapter *adapter = priv->adapter;
 	struct cmd_ds_802_11_scan_rsp *pscan;
-	struct bss_descriptor newbssentry;
 	struct mrvlietypes_data *ptlv;
 	struct mrvlietypes_tsftimestamp *ptsftlv;
+	struct bss_descriptor * iter_bss;
+	struct bss_descriptor * safe;
 	u8 *pbssinfo;
 	u16 scanrespsize;
 	int bytesleft;
-	int numintable;
-	int bssIdx;
 	int idx;
 	int tlvbufsize;
-	u64 tsfval;
+	int ret;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_ASSOC);
+
+	/* Prune old entries from scan table */
+	list_for_each_entry_safe (iter_bss, safe, &adapter->network_list, list) {
+		unsigned long stale_time = iter_bss->last_scanned + DEFAULT_MAX_SCAN_AGE;
+		if (time_before(jiffies, stale_time))
+			continue;
+		list_move_tail (&iter_bss->list, &adapter->network_free_list);
+		clear_bss_descriptor(iter_bss);
+	}
 
 	pscan = &resp->params.scanresp;
 
-	if (pscan->nr_sets > MRVDRV_MAX_BSSID_LIST) {
-        lbs_pr_debug(1,
-		       "SCAN_RESP: Invalid number of AP returned (%d)!!\n",
-		       pscan->nr_sets);
-		LEAVE();
-		return -1;
+	if (pscan->nr_sets > MAX_NETWORK_COUNT) {
+		lbs_deb_scan(
+		       "SCAN_RESP: too many scan results (%d, max %d)!!\n",
+		       pscan->nr_sets, MAX_NETWORK_COUNT);
+		ret = -1;
+		goto done;
 	}
 
 	bytesleft = le16_to_cpu(pscan->bssdescriptsize);
-	lbs_pr_debug(1, "SCAN_RESP: bssdescriptsize %d\n", bytesleft);
+	lbs_deb_scan("SCAN_RESP: bssdescriptsize %d\n", bytesleft);
 
 	scanrespsize = le16_to_cpu(resp->size);
-	lbs_pr_debug(1, "SCAN_RESP: returned %d AP before parsing\n",
+	lbs_deb_scan("SCAN_RESP: returned %d AP before parsing\n",
 	       pscan->nr_sets);
 
-	numintable = adapter->numinscantable;
 	pbssinfo = pscan->bssdesc_and_tlvbuffer;
 
 	/* The size of the TLV buffer is equal to the entire command response
@@ -1901,105 +1851,68 @@ int libertas_ret_80211_scan(wlan_private
 	 *    or as an addition at the end of the table
 	 */
 	for (idx = 0; idx < pscan->nr_sets && bytesleft; idx++) {
-		/* Zero out the newbssentry we are about to store info in */
-		memset(&newbssentry, 0x00, sizeof(newbssentry));
+		struct bss_descriptor new;
+		struct bss_descriptor * found = NULL;
+		struct bss_descriptor * oldest = NULL;
 
 		/* Process the data fields and IEs returned for this BSS */
-		if ((InterpretBSSDescriptionWithIE(&newbssentry,
-						   &pbssinfo,
-						   &bytesleft) ==
-		     0)
-		    && CHECK_SSID_IS_VALID(&newbssentry.ssid)) {
-
-            lbs_pr_debug(1,
-			       "SCAN_RESP: BSSID = %02x:%02x:%02x:%02x:%02x:%02x\n",
-			       newbssentry.macaddress[0],
-			       newbssentry.macaddress[1],
-			       newbssentry.macaddress[2],
-			       newbssentry.macaddress[3],
-			       newbssentry.macaddress[4],
-			       newbssentry.macaddress[5]);
-
-			/*
-			 * Search the scan table for the same bssid
-			 */
-			for (bssIdx = 0; bssIdx < numintable; bssIdx++) {
-				if (memcmp(newbssentry.macaddress,
-					   adapter->scantable[bssIdx].
-					   macaddress,
-					   sizeof(newbssentry.macaddress)) ==
-				    0) {
-					/*
-					 * If the SSID matches as well, it is a duplicate of
-					 *   this entry.  Keep the bssIdx set to this
-					 *   entry so we replace the old contents in the table
-					 */
-					if ((newbssentry.ssid.ssidlength ==
-					     adapter->scantable[bssIdx].ssid.
-					     ssidlength)
-					    &&
-					    (memcmp
-					     (newbssentry.ssid.ssid,
-					      adapter->scantable[bssIdx].ssid.
-					      ssid,
-					      newbssentry.ssid.ssidlength) ==
-					     0)) {
-                        lbs_pr_debug(1,
-						       "SCAN_RESP: Duplicate of index: %d\n",
-						       bssIdx);
-						break;
-					}
-				}
-			}
-			/*
-			 * If the bssIdx is equal to the number of entries in the table,
-			 *   the new entry was not a duplicate; append it to the scan
-			 *   table
-			 */
-			if (bssIdx == numintable) {
-				/* Range check the bssIdx, keep it limited to the last entry */
-				if (bssIdx == MRVDRV_MAX_BSSID_LIST) {
-					bssIdx--;
-				} else {
-					numintable++;
-				}
-			}
-
-			/*
-			 * If the TSF TLV was appended to the scan results, save the
-			 *   this entries TSF value in the networktsf field.  The
-			 *   networktsf is the firmware's TSF value at the time the
-			 *   beacon or probe response was received.
-			 */
-			if (ptsftlv) {
-				memcpy(&tsfval, &ptsftlv->tsftable[idx],
-				       sizeof(tsfval));
-				tsfval = le64_to_cpu(tsfval);
+		memset(&new, 0, sizeof (struct bss_descriptor));
+		if (libertas_process_bss(&new, &pbssinfo, &bytesleft) != 0) {
+			/* error parsing the scan response, skipped */
+			lbs_deb_scan("SCAN_RESP: process_bss returned ERROR\n");
+			continue;
+		}
 
-				memcpy(&newbssentry.networktsf,
-				       &tsfval, sizeof(newbssentry.networktsf));
+		/* Try to find this bss in the scan table */
+		list_for_each_entry (iter_bss, &adapter->network_list, list) {
+			if (is_same_network(iter_bss, &new)) {
+				found = iter_bss;
+				break;
 			}
 
-			/* Copy the locally created newbssentry to the scan table */
-			memcpy(&adapter->scantable[bssIdx],
-			       &newbssentry,
-			       sizeof(adapter->scantable[bssIdx]));
-
+			if ((oldest == NULL) ||
+			    (iter_bss->last_scanned < oldest->last_scanned))
+				oldest = iter_bss;
+		}
+
+		if (found) {
+			/* found, clear it */
+			clear_bss_descriptor(found);
+		} else if (!list_empty(&adapter->network_free_list)) {
+			/* Pull one from the free list */
+			found = list_entry(adapter->network_free_list.next,
+					   struct bss_descriptor, list);
+			list_move_tail(&found->list, &adapter->network_list);
+		} else if (oldest) {
+			/* If there are no more slots, expire the oldest */
+			found = oldest;
+			clear_bss_descriptor(found);
+			list_move_tail(&found->list, &adapter->network_list);
 		} else {
+			continue;
+		}
+
+		lbs_deb_scan("SCAN_RESP: BSSID = " MAC_FMT "\n",
+		       new.bssid[0], new.bssid[1], new.bssid[2],
+		       new.bssid[3], new.bssid[4], new.bssid[5]);
 
-			/* error parsing/interpreting the scan response, skipped */
-			lbs_pr_debug(1, "SCAN_RESP: "
-			       "InterpretBSSDescriptionWithIE returned ERROR\n");
+		/*
+		 * If the TSF TLV was appended to the scan results, save the
+		 *   this entries TSF value in the networktsf field.  The
+		 *   networktsf is the firmware's TSF value at the time the
+		 *   beacon or probe response was received.
+		 */
+		if (ptsftlv) {
+			new.networktsf = le64_to_cpup(&ptsftlv->tsftable[idx]);
 		}
-	}
 
-	lbs_pr_debug(1, "SCAN_RESP: Scanned %2d APs, %d valid, %d total\n",
-	       pscan->nr_sets, numintable - adapter->numinscantable,
-	       numintable);
+		/* Copy the locally created newbssentry to the scan table */
+		memcpy(found, &new, offsetof(struct bss_descriptor, list));
+	}
 
-	/* Update the total number of BSSIDs in the scan table */
-	adapter->numinscantable = numintable;
+	ret = 0;
 
-	LEAVE();
-	return 0;
+done:
+	lbs_deb_leave_args(LBS_DEB_SCAN, "ret %d", ret);
+	return ret;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/scan.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/scan.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/scan.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/scan.h	2007-06-14 14:14:33.000000000 -0400
@@ -51,7 +51,7 @@ struct wlan_scan_cmd_config {
     /**
      *  @brief Specific BSSID used to filter scan results in the firmware
      */
-	u8 specificBSSID[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
 
     /**
      *  @brief length of TLVs sent in command starting at tlvBuffer
@@ -91,15 +91,6 @@ struct wlan_ioctl_user_scan_chan {
  *  @sa libertas_set_user_scan_ioctl
  */
 struct wlan_ioctl_user_scan_cfg {
-
-    /**
-     *  @brief Flag set to keep the previous scan table intact
-     *
-     *  If set, the scan results will accumulate, replacing any previous
-     *   matched entries for a BSS with the new scan data
-     */
-	u8 keeppreviousscan;	//!< Do not erase the existing scan results
-
     /**
      *  @brief BSS type to be sent in the firmware command
      *
@@ -117,15 +108,22 @@ struct wlan_ioctl_user_scan_cfg {
      */
 	u8 numprobes;
 
-    /**
-     *  @brief BSSID filter sent in the firmware command to limit the results
-     */
-	u8 specificBSSID[ETH_ALEN];
+	/**
+	 *  @brief BSSID filter sent in the firmware command to limit the results
+	 */
+	u8 bssid[ETH_ALEN];
+
+	/* Clear existing scan results matching this BSSID */
+	u8 clear_bssid;
+
+	/**
+	 *  @brief SSID filter sent in the firmware command to limit the results
+	 */
+	char ssid[IW_ESSID_MAX_SIZE];
+	u8 ssid_len;
 
-    /**
-     *  @brief SSID filter sent in the firmware command to limit the results
-     */
-	char specificSSID[IW_ESSID_MAX_SIZE + 1];
+	/* Clear existing scan results matching this SSID */
+	u8 clear_ssid;
 
     /**
      *  @brief Variable number (fixed maximum) of channels to scan up
@@ -137,9 +135,10 @@ struct wlan_ioctl_user_scan_cfg {
  *  @brief Structure used to store information for each beacon/probe response
  */
 struct bss_descriptor {
-	u8 macaddress[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
 
-	struct WLAN_802_11_SSID ssid;
+	u8 ssid[IW_ESSID_MAX_SIZE + 1];
+	u8 ssid_len;
 
 	/* WEP encryption requirement */
 	u32 privacy;
@@ -156,15 +155,15 @@ struct bss_descriptor {
 	u8 mode;
 	u8 libertas_supported_rates[WLAN_SUPPORTED_RATES];
 
-	int extra_ie;
+	__le64 timestamp;	//!< TSF value included in the beacon/probe response
+	unsigned long last_scanned;
 
-	u8 timestamp[8];	//!< TSF value included in the beacon/probe response
 	union ieeetypes_phyparamset phyparamset;
 	union IEEEtypes_ssparamset ssparamset;
 	struct ieeetypes_capinfo cap;
 	u8 datarates[WLAN_SUPPORTED_RATES];
 
-	__le64 networktsf;		//!< TSF timestamp from the current firmware TSF
+	u64 networktsf;		//!< TSF timestamp from the current firmware TSF
 
 	struct ieeetypes_countryinfofullset countryinfo;
 
@@ -172,24 +171,29 @@ struct bss_descriptor {
 	size_t wpa_ie_len;
 	u8 rsn_ie[MAX_WPA_IE_LEN];
 	size_t rsn_ie_len;
+
+	struct list_head list;
 };
 
-extern int libertas_SSID_cmp(struct WLAN_802_11_SSID *ssid1,
-		   struct WLAN_802_11_SSID *ssid2);
-extern int libertas_find_SSID_in_list(wlan_adapter * adapter, struct WLAN_802_11_SSID *ssid,
-			  u8 * bssid, u8 mode);
-int libertas_find_best_SSID_in_list(wlan_adapter * adapter, u8 mode);
-extern int libertas_find_BSSID_in_list(wlan_adapter * adapter, u8 * bssid, u8 mode);
-
-int libertas_find_best_network_SSID(wlan_private * priv,
-			struct WLAN_802_11_SSID *pSSID,
-			u8 preferred_mode, u8 *out_mode);
-
-extern int libertas_send_specific_SSID_scan(wlan_private * priv,
-				struct WLAN_802_11_SSID *prequestedssid,
-				u8 keeppreviousscan);
-extern int libertas_send_specific_BSSID_scan(wlan_private * priv,
-				 u8 * bssid, u8 keeppreviousscan);
+extern int libertas_ssid_cmp(u8 *ssid1, u8 ssid1_len, u8 *ssid2, u8 ssid2_len);
+
+struct bss_descriptor * libertas_find_ssid_in_list(wlan_adapter * adapter,
+			u8 *ssid, u8 ssid_len, u8 * bssid, u8 mode,
+			int channel);
+
+struct bss_descriptor * libertas_find_best_ssid_in_list(wlan_adapter * adapter,
+			u8 mode);
+
+extern struct bss_descriptor * libertas_find_bssid_in_list(wlan_adapter * adapter,
+			u8 * bssid, u8 mode);
+
+int libertas_find_best_network_ssid(wlan_private * priv, u8 *out_ssid,
+			u8 *out_ssid_len, u8 preferred_mode, u8 *out_mode);
+
+extern int libertas_send_specific_ssid_scan(wlan_private * priv, u8 *ssid,
+				u8 ssid_len, u8 clear_ssid);
+extern int libertas_send_specific_bssid_scan(wlan_private * priv,
+				 u8 * bssid, u8 clear_bssid);
 
 extern int libertas_cmd_80211_scan(wlan_private * priv,
 				struct cmd_ds_command *cmd,
@@ -199,7 +203,8 @@ extern int libertas_ret_80211_scan(wlan_
 				struct cmd_ds_command *resp);
 
 int wlan_scan_networks(wlan_private * priv,
-                const struct wlan_ioctl_user_scan_cfg * puserscanin);
+                const struct wlan_ioctl_user_scan_cfg * puserscanin,
+                int full_scan);
 
 struct ifreq;
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/thread.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/thread.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/thread.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/thread.h	2007-06-14 14:14:33.000000000 -0400
@@ -21,11 +21,11 @@ static inline void wlan_activate_thread(
 
 static inline void wlan_deactivate_thread(struct wlan_thread * thr)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_THREAD);
 
 	thr->pid = 0;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_THREAD);
 }
 
 static inline void wlan_create_thread(int (*wlanfunc) (void *),
@@ -36,7 +36,7 @@ static inline void wlan_create_thread(in
 
 static inline int wlan_terminate_thread(struct wlan_thread * thr)
 {
-	ENTER();
+	lbs_deb_enter(LBS_DEB_THREAD);
 
 	/* Check if the thread is active or not */
 	if (!thr->pid) {
@@ -45,7 +45,7 @@ static inline int wlan_terminate_thread(
 	}
 	kthread_stop(thr->task);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_THREAD);
 	return 0;
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/tx.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/tx.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/tx.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/tx.c	2007-06-14 14:14:33.000000000 -0400
@@ -5,7 +5,6 @@
 
 #include "hostcmd.h"
 #include "radiotap.h"
-#include "sbi.h"
 #include "decl.h"
 #include "defs.h"
 #include "dev.h"
@@ -68,7 +67,7 @@ static int SendSinglePacket(wlan_private
 	u32 new_rate;
 	u8 *ptr = priv->adapter->tmptxbuf;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_TX);
 
 	if (priv->adapter->surpriseremoved)
 		return -1;
@@ -78,7 +77,7 @@ static int SendSinglePacket(wlan_private
 			 min_t(unsigned int, skb->len, 100));
 
 	if (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {
-		lbs_pr_debug(1, "Tx error: Bad skb length %d : %zd\n",
+		lbs_deb_tx("tx err: skb length %d 0 or > %zd\n",
 		       skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);
 		ret = -1;
 		goto done;
@@ -86,13 +85,13 @@ static int SendSinglePacket(wlan_private
 
 	memset(plocaltxpd, 0, sizeof(struct txpd));
 
-	plocaltxpd->tx_packet_length = skb->len;
+	plocaltxpd->tx_packet_length = cpu_to_le16(skb->len);
 
 	/* offset of actual data */
-	plocaltxpd->tx_packet_location = sizeof(struct txpd);
+	plocaltxpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));
 
 	/* TxCtrl set by user or default */
-	plocaltxpd->tx_control = adapter->pkttxctrl;
+	plocaltxpd->tx_control = cpu_to_le32(adapter->pkttxctrl);
 
 	p802x_hdr = skb->data;
 	if (priv->adapter->radiomode == WLAN_RADIOMODE_RADIOTAP) {
@@ -103,15 +102,16 @@ static int SendSinglePacket(wlan_private
 		/* set txpd fields from the radiotap header */
 		new_rate = convert_radiotap_rate_to_mv(pradiotap_hdr->rate);
 		if (new_rate != 0) {
-			/* erase tx_control[4:0] */
-			plocaltxpd->tx_control &= ~0x1f;
-			/* write new tx_control[4:0] */
-			plocaltxpd->tx_control |= new_rate;
+			/* use new tx_control[4:0] */
+			new_rate |= (adapter->pkttxctrl & ~0x1f);
+			plocaltxpd->tx_control = cpu_to_le32(new_rate);
 		}
 
 		/* skip the radiotap header */
 		p802x_hdr += sizeof(struct tx_radiotap_hdr);
-		plocaltxpd->tx_packet_length -= sizeof(struct tx_radiotap_hdr);
+		plocaltxpd->tx_packet_length =
+			cpu_to_le16(le16_to_cpu(plocaltxpd->tx_packet_length)
+				    - sizeof(struct tx_radiotap_hdr));
 
 	}
 	/* copy destination address from 802.3 or 802.11 header */
@@ -123,28 +123,28 @@ static int SendSinglePacket(wlan_private
 	lbs_dbg_hex("txpd", (u8 *) plocaltxpd, sizeof(struct txpd));
 
 	if (IS_MESH_FRAME(skb)) {
-		plocaltxpd->tx_control |= TxPD_MESH_FRAME;
+		plocaltxpd->tx_control |= cpu_to_le32(TxPD_MESH_FRAME);
 	}
 
 	memcpy(ptr, plocaltxpd, sizeof(struct txpd));
 
 	ptr += sizeof(struct txpd);
 
-	lbs_dbg_hex("Tx Data", (u8 *) p802x_hdr, plocaltxpd->tx_packet_length);
-	memcpy(ptr, p802x_hdr, plocaltxpd->tx_packet_length);
-	ret = libertas_sbi_host_to_card(priv, MVMS_DAT,
-			       priv->adapter->tmptxbuf,
-			       plocaltxpd->tx_packet_length +
-			       sizeof(struct txpd));
+	lbs_dbg_hex("Tx Data", (u8 *) p802x_hdr, le16_to_cpu(plocaltxpd->tx_packet_length));
+	memcpy(ptr, p802x_hdr, le16_to_cpu(plocaltxpd->tx_packet_length));
+	ret = priv->hw_host_to_card(priv, MVMS_DAT,
+				    priv->adapter->tmptxbuf,
+				    le16_to_cpu(plocaltxpd->tx_packet_length) +
+				    sizeof(struct txpd));
 
 	if (ret) {
-		lbs_pr_debug(1, "Tx error: libertas_sbi_host_to_card failed: 0x%X\n", ret);
+		lbs_deb_tx("tx err: hw_host_to_card returned 0x%X\n", ret);
 		goto done;
 	}
 
-	lbs_pr_debug(1, "SendSinglePacket succeeds\n");
+	lbs_deb_tx("SendSinglePacket succeeds\n");
 
-      done:
+done:
 	if (!ret) {
 		priv->stats.tx_packets++;
 		priv->stats.tx_bytes += skb->len;
@@ -158,7 +158,8 @@ static int SendSinglePacket(wlan_private
 		   received from FW */
 		skb_orphan(skb);
 		/* stop processing outgoing pkts */
-		netif_stop_queue(priv->wlan_dev.netdev);
+		netif_stop_queue(priv->dev);
+		netif_stop_queue(priv->mesh_dev);
 		/* freeze any packets already in our queues */
 		priv->adapter->TxLockFlag = 1;
 	} else {
@@ -166,7 +167,7 @@ static int SendSinglePacket(wlan_private
 		priv->adapter->currenttxskb = NULL;
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_TX, "ret %d", ret);
 	return ret;
 }
 
@@ -195,10 +196,13 @@ static void wlan_tx_queue(wlan_private *
 
 	WARN_ON(priv->adapter->tx_queue_idx >= NR_TX_QUEUE);
 	adapter->tx_queue_ps[adapter->tx_queue_idx++] = skb;
-	if (adapter->tx_queue_idx == NR_TX_QUEUE)
-		netif_stop_queue(priv->wlan_dev.netdev);
-	else
-		netif_start_queue(priv->wlan_dev.netdev);
+	if (adapter->tx_queue_idx == NR_TX_QUEUE) {
+		netif_stop_queue(priv->dev);
+		netif_stop_queue(priv->mesh_dev);
+	} else {
+		netif_start_queue(priv->dev);
+		netif_start_queue(priv->mesh_dev);
+	}
 
 	spin_unlock(&adapter->txqueue_lock);
 }
@@ -214,13 +218,12 @@ int libertas_process_tx(wlan_private * p
 {
 	int ret = -1;
 
-	ENTER();
-
+	lbs_deb_enter(LBS_DEB_TX);
 	lbs_dbg_hex("TX Data", skb->data, min_t(unsigned int, skb->len, 100));
 
-	if (priv->wlan_dev.dnld_sent) {
+	if (priv->dnld_sent) {
 		lbs_pr_alert( "TX error: dnld_sent = %d, not sending\n",
-		       priv->wlan_dev.dnld_sent);
+		       priv->dnld_sent);
 		goto done;
 	}
 
@@ -234,7 +237,7 @@ int libertas_process_tx(wlan_private * p
 
 	ret = SendSinglePacket(priv, skb);
 done:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_TX, "ret %d", ret);
 	return ret;
 }
 
@@ -280,6 +283,9 @@ void libertas_send_tx_feedback(wlan_priv
 	libertas_upload_rx_packet(priv, adapter->currenttxskb);
 	adapter->currenttxskb = NULL;
 	priv->adapter->TxLockFlag = 0;
-	if (priv->adapter->connect_status == libertas_connected)
-		netif_wake_queue(priv->wlan_dev.netdev);
+	if (priv->adapter->connect_status == libertas_connected) {
+		netif_wake_queue(priv->dev);
+		netif_wake_queue(priv->mesh_dev);
+	}
 }
+EXPORT_SYMBOL_GPL(libertas_send_tx_feedback);
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/types.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/types.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/types.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/types.h	2007-06-14 14:14:33.000000000 -0400
@@ -5,6 +5,7 @@
 #define _WLAN_TYPES_
 
 #include <linux/if_ether.h>
+#include <asm/byteorder.h>
 
 /** IEEE type definitions  */
 enum ieeetypes_elementid {
@@ -29,9 +30,30 @@ enum ieeetypes_elementid {
 	EXTRA_IE = 133,
 } __attribute__ ((packed));
 
+#ifdef __BIG_ENDIAN
 #define CAPINFO_MASK	(~(0xda00))
+#else
+#define CAPINFO_MASK	(~(0x00da))
+#endif
 
 struct ieeetypes_capinfo {
+#ifdef __BIG_ENDIAN_BITFIELD
+	u8 chanagility:1;
+	u8 pbcc:1;
+	u8 shortpreamble:1;
+	u8 privacy:1;
+	u8 cfpollrqst:1;
+	u8 cfpollable:1;
+	u8 ibss:1;
+	u8 ess:1;
+	u8 rsrvd1:2;
+	u8 dsssofdm:1;
+	u8 rsvrd2:1;
+	u8 apsd:1;
+	u8 shortslottime:1;
+	u8 rsrvd3:1;
+	u8 spectrummgmt:1;
+#else
 	u8 ess:1;
 	u8 ibss:1;
 	u8 cfpollable:1;
@@ -47,6 +69,7 @@ struct ieeetypes_capinfo {
 	u8 rsvrd2:1;
 	u8 dsssofdm:1;
 	u8 rsrvd1:2;
+#endif
 } __attribute__ ((packed));
 
 struct ieeetypes_cfparamset {
@@ -54,15 +77,15 @@ struct ieeetypes_cfparamset {
 	u8 len;
 	u8 cfpcnt;
 	u8 cfpperiod;
-	u16 cfpmaxduration;
-	u16 cfpdurationremaining;
+	__le16 cfpmaxduration;
+	__le16 cfpdurationremaining;
 } __attribute__ ((packed));
 
 
 struct ieeetypes_ibssparamset {
 	u8 elementid;
 	u8 len;
-	u16 atimwindow;
+	__le16 atimwindow;
 } __attribute__ ((packed));
 
 union IEEEtypes_ssparamset {
@@ -73,7 +96,7 @@ union IEEEtypes_ssparamset {
 struct ieeetypes_fhparamset {
 	u8 elementid;
 	u8 len;
-	u16 dwelltime;
+	__le16 dwelltime;
 	u8 hopset;
 	u8 hoppattern;
 	u8 hopindex;
@@ -92,8 +115,8 @@ union ieeetypes_phyparamset {
 
 struct ieeetypes_assocrsp {
 	struct ieeetypes_capinfo capability;
-	u16 statuscode;
-	u16 aid;
+	__le16 statuscode;
+	__le16 aid;
 	u8 iebuffer[1];
 } __attribute__ ((packed));
 
@@ -138,8 +161,8 @@ struct ieeetypes_assocrsp {
 
 /** TLV related data structures*/
 struct mrvlietypesheader {
-	u16 type;
-	u16 len;
+	__le16 type;
+	__le16 len;
 } __attribute__ ((packed));
 
 struct mrvlietypes_data {
@@ -164,17 +187,23 @@ struct mrvlietypes_wildcardssidparamset 
 } __attribute__ ((packed));
 
 struct chanscanmode {
+#ifdef __BIG_ENDIAN_BITFIELD
+	u8 reserved_2_7:6;
+	u8 disablechanfilt:1;
+	u8 passivescan:1;
+#else
 	u8 passivescan:1;
 	u8 disablechanfilt:1;
 	u8 reserved_2_7:6;
+#endif
 } __attribute__ ((packed));
 
 struct chanscanparamset {
 	u8 radiotype;
 	u8 channumber;
 	struct chanscanmode chanscanmode;
-	u16 minscantime;
-	u16 maxscantime;
+	__le16 minscantime;
+	__le16 maxscantime;
 } __attribute__ ((packed));
 
 struct mrvlietypes_chanlistparamset {
@@ -185,12 +214,12 @@ struct mrvlietypes_chanlistparamset {
 struct cfparamset {
 	u8 cfpcnt;
 	u8 cfpperiod;
-	u16 cfpmaxduration;
-	u16 cfpdurationremaining;
+	__le16 cfpmaxduration;
+	__le16 cfpdurationremaining;
 } __attribute__ ((packed));
 
 struct ibssparamset {
-	u16 atimwindow;
+	__le16 atimwindow;
 } __attribute__ ((packed));
 
 struct mrvlietypes_ssparamset {
@@ -202,7 +231,7 @@ struct mrvlietypes_ssparamset {
 } __attribute__ ((packed));
 
 struct fhparamset {
-	u16 dwelltime;
+	__le16 dwelltime;
 	u8 hopset;
 	u8 hoppattern;
 	u8 hopindex;
@@ -263,17 +292,17 @@ struct mrvlietypes_beaconsmissed {
 
 struct mrvlietypes_numprobes {
 	struct mrvlietypesheader header;
-	u16 numprobes;
+	__le16 numprobes;
 } __attribute__ ((packed));
 
 struct mrvlietypes_bcastprobe {
 	struct mrvlietypesheader header;
-	u16 bcastprobe;
+	__le16 bcastprobe;
 } __attribute__ ((packed));
 
 struct mrvlietypes_numssidprobe {
 	struct mrvlietypesheader header;
-	u16 numssidprobe;
+	__le16 numssidprobe;
 } __attribute__ ((packed));
 
 struct led_pin {
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/wext.c linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/wext.c
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/wext.c	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/wext.c	2007-06-14 14:14:33.000000000 -0400
@@ -22,6 +22,14 @@
 
 
 /**
+ * the rates supported by the card
+ */
+static u8 libertas_wlan_data_rates[WLAN_SUPPORTED_RATES] =
+    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
+      0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
+};
+
+/**
  *  @brief Convert mw value to dbm value
  *
  *  @param mw	   the value of mw
@@ -102,8 +110,8 @@ struct chan_freq_power *libertas_find_cf
 	}
 
 	if (!cfp && channel)
-		lbs_pr_debug(1, "libertas_find_cfp_by_band_and_channel(): cannot find "
-		       "cfp by band %d & channel %d\n", band, channel);
+		lbs_deb_wext("libertas_find_cfp_by_band_and_channel: can't find "
+		       "cfp by band %d / channel %d\n", band, channel);
 
 	return cfp;
 }
@@ -143,113 +151,12 @@ static struct chan_freq_power *find_cfp_
 	}
 
 	if (!cfp && freq)
-		lbs_pr_debug(1, "find_cfp_by_band_and_freql(): cannot find cfp by "
-		       "band %d & freq %d\n", band, freq);
+		lbs_deb_wext("find_cfp_by_band_and_freql: can't find cfp by "
+		       "band %d / freq %d\n", band, freq);
 
 	return cfp;
 }
 
-static int updatecurrentchannel(wlan_private * priv)
-{
-	int ret;
-
-	/*
-	 ** the channel in f/w could be out of sync, get the current channel
-	 */
-	ret = libertas_prepare_and_send_command(priv, cmd_802_11_rf_channel,
-				    cmd_opt_802_11_rf_channel_get,
-				    cmd_option_waitforrsp, 0, NULL);
-
-	lbs_pr_debug(1, "Current channel = %d\n",
-	       priv->adapter->curbssparams.channel);
-
-	return ret;
-}
-
-static int setcurrentchannel(wlan_private * priv, int channel)
-{
-	lbs_pr_debug(1, "Set channel = %d\n", channel);
-
-	/*
-	 **  Current channel is not set to adhocchannel requested, set channel
-	 */
-	return (libertas_prepare_and_send_command(priv, cmd_802_11_rf_channel,
-				      cmd_opt_802_11_rf_channel_set,
-				      cmd_option_waitforrsp, 0, &channel));
-}
-
-static int changeadhocchannel(wlan_private * priv, int channel)
-{
-	int ret = 0;
-	wlan_adapter *adapter = priv->adapter;
-
-	adapter->adhocchannel = channel;
-
-	updatecurrentchannel(priv);
-
-	if (adapter->curbssparams.channel == adapter->adhocchannel) {
-		/* adhocchannel is set to the current channel already */
-		LEAVE();
-		return 0;
-	}
-
-	lbs_pr_debug(1, "Updating channel from %d to %d\n",
-	       adapter->curbssparams.channel, adapter->adhocchannel);
-
-	setcurrentchannel(priv, adapter->adhocchannel);
-
-	updatecurrentchannel(priv);
-
-	if (adapter->curbssparams.channel != adapter->adhocchannel) {
-		lbs_pr_debug(1, "failed to updated channel to %d, channel = %d\n",
-		       adapter->adhocchannel, adapter->curbssparams.channel);
-		LEAVE();
-		return -1;
-	}
-
-	if (adapter->connect_status == libertas_connected) {
-		int i;
-		struct WLAN_802_11_SSID curadhocssid;
-
-		lbs_pr_debug(1, "channel Changed while in an IBSS\n");
-
-		/* Copy the current ssid */
-		memcpy(&curadhocssid, &adapter->curbssparams.ssid,
-		       sizeof(struct WLAN_802_11_SSID));
-
-		/* Exit Adhoc mode */
-		lbs_pr_debug(1, "In changeadhocchannel(): Sending Adhoc Stop\n");
-		ret = libertas_stop_adhoc_network(priv);
-
-		if (ret) {
-			LEAVE();
-			return ret;
-		}
-		/* Scan for the network, do not save previous results.  Stale
-		 *   scan data will cause us to join a non-existant adhoc network
-		 */
-		libertas_send_specific_SSID_scan(priv, &curadhocssid, 0);
-
-		// find out the BSSID that matches the current SSID
-		i = libertas_find_SSID_in_list(adapter, &curadhocssid, NULL,
-				   IW_MODE_ADHOC);
-
-		if (i >= 0) {
-			lbs_pr_debug(1, "SSID found at %d in List,"
-			       "so join\n", i);
-			libertas_join_adhoc_network(priv, &adapter->scantable[i]);
-		} else {
-			// else send START command
-			lbs_pr_debug(1, "SSID not found in list, "
-			       "so creating adhoc with ssid = %s\n",
-			       curadhocssid.ssid);
-			libertas_start_adhoc_network(priv, &curadhocssid);
-		}		// end of else (START command)
-	}
-
-	LEAVE();
-	return 0;
-}
 
 /**
  *  @brief Set Radio On/OFF
@@ -263,10 +170,10 @@ int wlan_radio_ioctl(wlan_private * priv
 	int ret = 0;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (adapter->radioon != option) {
-		lbs_pr_debug(1, "Switching %s the Radio\n", option ? "On" : "Off");
+		lbs_deb_wext("switching radio %s\n", option ? "on" : "off");
 		adapter->radioon = option;
 
 		ret = libertas_prepare_and_send_command(priv,
@@ -275,7 +182,7 @@ int wlan_radio_ioctl(wlan_private * priv
 					    cmd_option_waitforrsp, 0, NULL);
 	}
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -312,15 +219,15 @@ static int get_active_data_rates(wlan_ad
 {
 	int k = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (adapter->connect_status != libertas_connected) {
 		if (adapter->mode == IW_MODE_INFRA) {
-			lbs_pr_debug(1, "Infra\n");
+			lbs_deb_wext("infra\n");
 			k = copyrates(rates, k, libertas_supported_rates,
 				      sizeof(libertas_supported_rates));
 		} else {
-			lbs_pr_debug(1, "Adhoc G\n");
+			lbs_deb_wext("Adhoc G\n");
 			k = copyrates(rates, k, libertas_adhoc_rates_g,
 				      sizeof(libertas_adhoc_rates_g));
 		}
@@ -329,8 +236,7 @@ static int get_active_data_rates(wlan_ad
 			      adapter->curbssparams.numofrates);
 	}
 
-	LEAVE();
-
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", k);
 	return k;
 }
 
@@ -342,7 +248,7 @@ static int wlan_get_name(struct net_devi
 	char mrvl[6] = { "MRVL-" };
 	int cnt;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	strcpy(cwrq, mrvl);
 
@@ -360,8 +266,7 @@ static int wlan_get_name(struct net_devi
 	}
 	*cwrq = '\0';
 
-	LEAVE();
-
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -372,14 +277,14 @@ static int wlan_get_freq(struct net_devi
 	wlan_adapter *adapter = priv->adapter;
 	struct chan_freq_power *cfp;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	cfp = libertas_find_cfp_by_band_and_channel(adapter, 0,
 					   adapter->curbssparams.channel);
 
 	if (!cfp) {
 		if (adapter->curbssparams.channel)
-			lbs_pr_debug(1, "Invalid channel=%d\n",
+			lbs_deb_wext("invalid channel %d\n",
 			       adapter->curbssparams.channel);
 		return -EINVAL;
 	}
@@ -387,9 +292,8 @@ static int wlan_get_freq(struct net_devi
 	fwrq->m = (long)cfp->freq * 100000;
 	fwrq->e = 1;
 
-	lbs_pr_debug(1, "freq=%u\n", fwrq->m);
-
-	LEAVE();
+	lbs_deb_wext("freq %u\n", fwrq->m);
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -399,7 +303,7 @@ static int wlan_get_wap(struct net_devic
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (adapter->connect_status == libertas_connected) {
 		memcpy(awrq->sa_data, adapter->curbssparams.bssid, ETH_ALEN);
@@ -408,7 +312,7 @@ static int wlan_get_wap(struct net_devic
 	}
 	awrq->sa_family = ARPHRD_ETHER;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -418,7 +322,7 @@ static int wlan_set_nick(struct net_devi
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	/*
 	 * Check the size of the string
@@ -433,7 +337,7 @@ static int wlan_set_nick(struct net_devi
 	memcpy(adapter->nodename, extra, dwrq->length);
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -443,7 +347,7 @@ static int wlan_get_nick(struct net_devi
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	/*
 	 * Get the Nick Name saved
@@ -464,19 +368,43 @@ static int wlan_get_nick(struct net_devi
 	 */
 	dwrq->length = strlen(extra) + 1;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
+static int mesh_get_nick(struct net_device *dev, struct iw_request_info *info,
+			 struct iw_point *dwrq, char *extra)
+{
+	wlan_private *priv = dev->priv;
+	wlan_adapter *adapter = priv->adapter;
+
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	/* Use nickname to indicate that mesh is on */
+
+	if (adapter->connect_status == libertas_connected) {
+		strncpy(extra, "Mesh", 12);
+		extra[12] = '\0';
+		dwrq->length = strlen(extra) + 1;
+	}
+
+	else {
+		extra[0] = '\0';
+		dwrq->length = 1 ;
+	}
+
+	lbs_deb_leave(LBS_DEB_WEXT);
+	return 0;
+}
 static int wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
 			struct iw_param *vwrq, char *extra)
 {
 	int ret = 0;
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
-	int rthr = vwrq->value;
+	u32 rthr = vwrq->value;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (vwrq->disabled) {
 		adapter->rtsthsd = rthr = MRVDRV_RTS_MAX_VALUE;
@@ -490,7 +418,7 @@ static int wlan_set_rts(struct net_devic
 				    cmd_act_set, cmd_option_waitforrsp,
 				    OID_802_11_RTS_THRESHOLD, &rthr);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -501,35 +429,34 @@ static int wlan_get_rts(struct net_devic
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	adapter->rtsthsd = 0;
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
 				    cmd_act_get, cmd_option_waitforrsp,
 				    OID_802_11_RTS_THRESHOLD, NULL);
-	if (ret) {
-		LEAVE();
-		return ret;
-	}
+	if (ret)
+		goto out;
 
 	vwrq->value = adapter->rtsthsd;
 	vwrq->disabled = ((vwrq->value < MRVDRV_RTS_MIN_VALUE)
 			  || (vwrq->value > MRVDRV_RTS_MAX_VALUE));
 	vwrq->fixed = 1;
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 static int wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
 			 struct iw_param *vwrq, char *extra)
 {
 	int ret = 0;
-	int fthr = vwrq->value;
+	u32 fthr = vwrq->value;
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (vwrq->disabled) {
 		adapter->fragthsd = fthr = MRVDRV_FRAG_MAX_VALUE;
@@ -543,7 +470,8 @@ static int wlan_set_frag(struct net_devi
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
 				    cmd_act_set, cmd_option_waitforrsp,
 				    OID_802_11_FRAGMENTATION_THRESHOLD, &fthr);
-	LEAVE();
+
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -554,24 +482,23 @@ static int wlan_get_frag(struct net_devi
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	adapter->fragthsd = 0;
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_snmp_mib,
 				    cmd_act_get, cmd_option_waitforrsp,
 				    OID_802_11_FRAGMENTATION_THRESHOLD, NULL);
-	if (ret) {
-		LEAVE();
-		return ret;
-	}
+	if (ret)
+		goto out;
 
 	vwrq->value = adapter->fragthsd;
 	vwrq->disabled = ((vwrq->value < MRVDRV_FRAG_MIN_VALUE)
 			  || (vwrq->value > MRVDRV_FRAG_MAX_VALUE));
 	vwrq->fixed = 1;
 
-	LEAVE();
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -581,11 +508,23 @@ static int wlan_get_mode(struct net_devi
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	*uwrq = adapter->mode;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
+	return 0;
+}
+
+static int mesh_wlan_get_mode(struct net_device *dev,
+		              struct iw_request_info *info, u32 * uwrq,
+			      char *extra)
+{
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	*uwrq = IW_MODE_REPEAT ;
+
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -597,19 +536,17 @@ static int wlan_get_txpow(struct net_dev
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_rf_tx_power,
 				    cmd_act_tx_power_opt_get,
 				    cmd_option_waitforrsp, 0, NULL);
 
-	if (ret) {
-		LEAVE();
-		return ret;
-	}
+	if (ret)
+		goto out;
 
-	lbs_pr_debug(1, "TXPOWER GET %d dbm.\n", adapter->txpowerlevel);
+	lbs_deb_wext("tx power level %d dbm\n", adapter->txpowerlevel);
 	vwrq->value = adapter->txpowerlevel;
 	vwrq->fixed = 1;
 	if (adapter->radioon) {
@@ -619,8 +556,9 @@ static int wlan_get_txpow(struct net_dev
 		vwrq->disabled = 1;
 	}
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 static int wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
@@ -630,7 +568,7 @@ static int wlan_set_retry(struct net_dev
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (vwrq->flags == IW_RETRY_LIMIT) {
 		/* The MAC has a 4-bit Total_Tx_Count register
@@ -648,16 +586,15 @@ static int wlan_set_retry(struct net_dev
 					    cmd_option_waitforrsp,
 					    OID_802_11_TX_RETRYCOUNT, NULL);
 
-		if (ret) {
-			LEAVE();
-			return ret;
-		}
+		if (ret)
+			goto out;
 	} else {
 		return -EOPNOTSUPP;
 	}
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 static int wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
@@ -667,16 +604,16 @@ static int wlan_get_retry(struct net_dev
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
+
 	adapter->txretrycount = 0;
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_snmp_mib,
 				    cmd_act_get, cmd_option_waitforrsp,
 				    OID_802_11_TX_RETRYCOUNT, NULL);
-	if (ret) {
-		LEAVE();
-		return ret;
-	}
+	if (ret)
+		goto out;
+
 	vwrq->disabled = 0;
 	if (!vwrq->flags) {
 		vwrq->flags = IW_RETRY_LIMIT;
@@ -684,8 +621,9 @@ static int wlan_get_retry(struct net_dev
 		vwrq->value = adapter->txretrycount - 1;
 	}
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 static inline void sort_channels(struct iw_freq *freq, int num)
@@ -739,7 +677,7 @@ static int wlan_get_range(struct net_dev
 
 	u8 flag = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	dwrq->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(struct iw_range));
@@ -755,7 +693,7 @@ static int wlan_get_range(struct net_dev
 		range->bitrate[i] = (rates[i] & 0x7f) * 500000;
 	}
 	range->num_bitrates = i;
-	lbs_pr_debug(1, "IW_MAX_BITRATES=%d num_bitrates=%d\n", IW_MAX_BITRATES,
+	lbs_deb_wext("IW_MAX_BITRATES %d, num_bitrates %d\n", IW_MAX_BITRATES,
 	       range->num_bitrates);
 
 	range->num_frequency = 0;
@@ -768,18 +706,17 @@ static int wlan_get_range(struct net_dev
 		    &adapter->parsed_region_chan;
 
 		if (parsed_region_chan == NULL) {
-			lbs_pr_debug(1, "11D:parsed_region_chan is NULL\n");
-			LEAVE();
-			return 0;
+			lbs_deb_wext("11d: parsed_region_chan is NULL\n");
+			goto out;
 		}
 		band = parsed_region_chan->band;
-		lbs_pr_debug(1, "band=%d NoOfChan=%d\n", band,
+		lbs_deb_wext("band %d, nr_char %d\n", band,
 		       parsed_region_chan->nr_chan);
 
 		for (i = 0; (range->num_frequency < IW_MAX_FREQUENCIES)
 		     && (i < parsed_region_chan->nr_chan); i++) {
 			chan_no = parsed_region_chan->chanpwr[i].chan;
-			lbs_pr_debug(1, "chan_no=%d\n", chan_no);
+			lbs_deb_wext("chan_no %d\n", chan_no);
 			range->freq[range->num_frequency].i = (long)chan_no;
 			range->freq[range->num_frequency].m =
 			    (long)libertas_chan_2_freq(chan_no, band) * 100000;
@@ -808,7 +745,7 @@ static int wlan_get_range(struct net_dev
 		}
 	}
 
-	lbs_pr_debug(1, "IW_MAX_FREQUENCIES=%d num_frequency=%d\n",
+	lbs_deb_wext("IW_MAX_FREQUENCIES %d, num_frequency %d\n",
 	       IW_MAX_FREQUENCIES, range->num_frequency);
 
 	range->num_channels = range->num_frequency;
@@ -903,7 +840,8 @@ static int wlan_get_range(struct net_dev
 		                  | IW_ENC_CAPA_CIPHER_CCMP;
 	}
 
-	LEAVE();
+out:
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -913,7 +851,7 @@ static int wlan_set_power(struct net_dev
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	/* PS is currently supported only in Infrastructure mode
 	 * Remove this check if it is to be supported in IBSS mode also
@@ -929,11 +867,11 @@ static int wlan_set_power(struct net_dev
 	}
 
 	if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {
-		lbs_pr_debug(1,
-		       "Setting power timeout command is not supported\n");
+		lbs_deb_wext(
+		       "setting power timeout is not supported\n");
 		return -EINVAL;
 	} else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {
-		lbs_pr_debug(1, "Setting power period command is not supported\n");
+		lbs_deb_wext("setting power period not supported\n");
 		return -EINVAL;
 	}
 
@@ -947,7 +885,7 @@ static int wlan_set_power(struct net_dev
 		libertas_ps_sleep(priv, cmd_option_waitforrsp);
 	}
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -958,19 +896,20 @@ static int wlan_get_power(struct net_dev
 	wlan_adapter *adapter = priv->adapter;
 	int mode;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	mode = adapter->psmode;
 
 	if ((vwrq->disabled = (mode == wlan802_11powermodecam))
-	    || adapter->connect_status == libertas_disconnected) {
-		LEAVE();
-		return 0;
+	    || adapter->connect_status == libertas_disconnected)
+	{
+		goto out;
 	}
 
 	vwrq->value = 0;
 
-	LEAVE();
+out:
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -1063,6 +1002,16 @@ static const struct iw_priv_args wlan_pr
 	 IW_PRIV_TYPE_CHAR | 128,
 	 IW_PRIV_TYPE_CHAR | 128,
 	 "bt_list"},
+	{
+	 WLAN_SUBCMD_BT_SET_INVERT,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 IW_PRIV_TYPE_NONE,
+	 "bt_set_invert"},
+	{
+	 WLAN_SUBCMD_BT_GET_INVERT,
+	 IW_PRIV_TYPE_NONE,
+	 IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+	 "bt_get_invert"},
 	/* FWT Management */
 	{
 	 WLAN_SUBCMD_FWT_ADD,
@@ -1125,7 +1074,7 @@ static struct iw_statistics *wlan_get_wi
 	u8 rssi;
 	u32 tx_retries;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	priv->wstats.status = adapter->mode;
 
@@ -1145,8 +1094,8 @@ static struct iw_statistics *wlan_get_wi
 		    CAL_NF(adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
 	}
 
-	lbs_pr_debug(1, "Signal Level = %#x\n", priv->wstats.qual.level);
-	lbs_pr_debug(1, "Noise = %#x\n", priv->wstats.qual.noise);
+	lbs_deb_wext("signal level %#x\n", priv->wstats.qual.level);
+	lbs_deb_wext("noise %#x\n", priv->wstats.qual.noise);
 
 	rssi = priv->wstats.qual.level - priv->wstats.qual.noise;
 	if (rssi < 15)
@@ -1166,7 +1115,7 @@ static struct iw_statistics *wlan_get_wi
 	/* Quality by TX errors */
 	priv->wstats.discard.retries = priv->stats.tx_errors;
 
-	tx_retries = adapter->logmsg.retry;
+	tx_retries = le16_to_cpu(adapter->logmsg.retry);
 
 	if (tx_retries > 75)
 		tx_qual = (90 - tx_retries) * POOR / 15;
@@ -1182,10 +1131,10 @@ static struct iw_statistics *wlan_get_wi
 		    (PERFECT - VERY_GOOD) / 50 + VERY_GOOD;
 	quality = min(quality, tx_qual);
 
-	priv->wstats.discard.code = adapter->logmsg.wepundecryptable;
-	priv->wstats.discard.fragment = adapter->logmsg.fcserror;
+	priv->wstats.discard.code = le16_to_cpu(adapter->logmsg.wepundecryptable);
+	priv->wstats.discard.fragment = le16_to_cpu(adapter->logmsg.rxfrag);
 	priv->wstats.discard.retries = tx_retries;
-	priv->wstats.discard.misc = adapter->logmsg.ackfailure;
+	priv->wstats.discard.misc = le16_to_cpu(adapter->logmsg.ackfailure);
 
 	/* Calculate quality */
 	priv->wstats.qual.qual = max(quality, (u32)100);
@@ -1209,7 +1158,7 @@ out:
 		    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;
 	}
 
-	LEAVE ();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return &priv->wstats;
 
 
@@ -1218,81 +1167,59 @@ out:
 static int wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
 		  struct iw_freq *fwrq, char *extra)
 {
-	int ret = 0;
+	int ret = -EINVAL;
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
-	int rc = -EINPROGRESS;	/* Call commit handler */
 	struct chan_freq_power *cfp;
+	struct assoc_request * assoc_req;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
-	/*
-	 * If setting by frequency, convert to a channel
-	 */
-	if (fwrq->e == 1) {
+	mutex_lock(&adapter->lock);
+	assoc_req = wlan_get_association_request(adapter);
+	if (!assoc_req) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
+	/* If setting by frequency, convert to a channel */
+	if (fwrq->e == 1) {
 		long f = fwrq->m / 100000;
-		int c = 0;
 
 		cfp = find_cfp_by_band_and_freq(adapter, 0, f);
 		if (!cfp) {
-			lbs_pr_debug(1, "Invalid freq=%ld\n", f);
-			return -EINVAL;
+			lbs_deb_wext("invalid freq %ld\n", f);
+			goto out;
 		}
 
-		c = (int)cfp->channel;
-
-		if (c < 0)
-			return -EINVAL;
-
 		fwrq->e = 0;
-		fwrq->m = c;
+		fwrq->m = (int) cfp->channel;
 	}
 
-	/*
-	 * Setting by channel number
-	 */
+	/* Setting by channel number */
 	if (fwrq->m > 1000 || fwrq->e > 0) {
-		rc = -EOPNOTSUPP;
-	} else {
-		int channel = fwrq->m;
+		goto out;
+	}
 
-		cfp = libertas_find_cfp_by_band_and_channel(adapter, 0, channel);
-		if (!cfp) {
-			rc = -EINVAL;
-		} else {
-			if (adapter->mode == IW_MODE_ADHOC) {
-				rc = changeadhocchannel(priv, channel);
-				/*  If station is WEP enabled, send the
-				 *  command to set WEP in firmware
-				 */
-				if (adapter->secinfo.wep_enabled) {
-					lbs_pr_debug(1, "set_freq: WEP enabled\n");
-					ret = libertas_prepare_and_send_command(priv,
-								    cmd_802_11_set_wep,
-								    cmd_act_add,
-								    cmd_option_waitforrsp,
-								    0,
-								    NULL);
-
-					if (ret) {
-						LEAVE();
-						return ret;
-					}
+	cfp = libertas_find_cfp_by_band_and_channel(adapter, 0, fwrq->m);
+	if (!cfp) {
+		goto out;
+	}
 
-					adapter->currentpacketfilter |=
-					    cmd_act_mac_wep_enable;
+	assoc_req->channel = fwrq->m;
+	ret = 0;
 
-					libertas_set_mac_packet_filter(priv);
-				}
-			} else {
-				rc = -EOPNOTSUPP;
-			}
-		}
+out:
+	if (ret == 0) {
+		set_bit(ASSOC_FLAG_CHANNEL, &assoc_req->flags);
+		wlan_postpone_association_work(priv);
+	} else {
+		wlan_cancel_association_work(priv);
 	}
+	mutex_unlock(&adapter->lock);
 
-	LEAVE();
-	return rc;
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 /**
@@ -1338,9 +1265,9 @@ static int wlan_set_rate(struct net_devi
 	u8 rates[WLAN_SUPPORTED_RATES];
 	u8 *rate;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
-	lbs_pr_debug(1, "Vwrq->value = %d\n", vwrq->value);
+	lbs_deb_wext("vwrq->value %d\n", vwrq->value);
 
 	if (vwrq->value == -1) {
 		action = cmd_act_set_tx_auto;	// Auto
@@ -1357,15 +1284,15 @@ static int wlan_set_rate(struct net_devi
 		get_active_data_rates(adapter, rates);
 		rate = rates;
 		while (*rate) {
-			lbs_pr_debug(1, "Rate=0x%X  Wanted=0x%X\n", *rate,
+			lbs_deb_wext("rate=0x%X, wanted data_rate 0x%X\n", *rate,
 			       data_rate);
 			if ((*rate & 0x7f) == (data_rate & 0x7f))
 				break;
 			rate++;
 		}
 		if (!*rate) {
-			lbs_pr_alert( "The fixed data rate 0x%X is out "
-			       "of range.\n", data_rate);
+			lbs_pr_alert("fixed data rate 0x%X out "
+			       "of range\n", data_rate);
 			return -EINVAL;
 		}
 
@@ -1377,7 +1304,7 @@ static int wlan_set_rate(struct net_devi
 	ret = libertas_prepare_and_send_command(priv, cmd_802_11_data_rate,
 				    action, cmd_option_waitforrsp, 0, NULL);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1387,7 +1314,7 @@ static int wlan_get_rate(struct net_devi
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (adapter->is_datarate_auto) {
 		vwrq->fixed = 0;
@@ -1397,7 +1324,7 @@ static int wlan_get_rate(struct net_devi
 
 	vwrq->value = adapter->datarate * 500000;
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -1409,12 +1336,12 @@ static int wlan_set_mode(struct net_devi
 	wlan_adapter *adapter = priv->adapter;
 	struct assoc_request * assoc_req;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (   (*uwrq != IW_MODE_ADHOC)
 	    && (*uwrq != IW_MODE_INFRA)
 	    && (*uwrq != IW_MODE_AUTO)) {
-		lbs_pr_debug(1, "Invalid mode: 0x%x\n", *uwrq);
+		lbs_deb_wext("Invalid mode: 0x%x\n", *uwrq);
 		ret = -EINVAL;
 		goto out;
 	}
@@ -1428,12 +1355,12 @@ static int wlan_set_mode(struct net_devi
 		assoc_req->mode = *uwrq;
 		set_bit(ASSOC_FLAG_MODE, &assoc_req->flags);
 		wlan_postpone_association_work(priv);
-		lbs_pr_debug(1, "Switching to mode: 0x%x\n", *uwrq);
+		lbs_deb_wext("Switching to mode: 0x%x\n", *uwrq);
 	}
 	mutex_unlock(&adapter->lock);
 
 out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1455,9 +1382,9 @@ static int wlan_get_encode(struct net_de
 	wlan_adapter *adapter = priv->adapter;
 	int index = (dwrq->flags & IW_ENCODE_INDEX) - 1;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
-	lbs_pr_debug(1, "flags=0x%x index=%d length=%d wep_tx_keyidx=%d\n",
+	lbs_deb_wext("flags 0x%x, index %d, length %d, wep_tx_keyidx %d\n",
 	       dwrq->flags, index, dwrq->length, adapter->wep_tx_keyidx);
 
 	dwrq->flags = 0;
@@ -1513,13 +1440,13 @@ static int wlan_get_encode(struct net_de
 
 	dwrq->flags |= IW_ENCODE_NOKEY;
 
-	lbs_pr_debug(1, "key:%02x:%02x:%02x:%02x:%02x:%02x keylen=%d\n",
+	lbs_deb_wext("key: " MAC_FMT ", keylen %d\n",
 	       extra[0], extra[1], extra[2],
 	       extra[3], extra[4], extra[5], dwrq->length);
 
-	lbs_pr_debug(1, "Return flags=0x%x\n", dwrq->flags);
+	lbs_deb_wext("return flags 0x%x\n", dwrq->flags);
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -1539,20 +1466,21 @@ static int wlan_set_wep_key(struct assoc
 			    u16 index,
 			    int set_tx_key)
 {
+	int ret = 0;
 	struct WLAN_802_11_KEY *pkey;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	/* Paranoid validation of key index */
 	if (index > 3) {
-		LEAVE();
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
 	}
 
 	/* validate max key length */
 	if (key_length > KEY_LEN_WEP_104) {
-		LEAVE();
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out;
 	}
 
 	pkey = &assoc_req->wep_keys[index];
@@ -1570,17 +1498,18 @@ static int wlan_set_wep_key(struct assoc
 	if (set_tx_key) {
 		/* Ensure the chosen key is valid */
 		if (!pkey->len) {
-			lbs_pr_debug(1, "key not set, so cannot enable it\n");
-			LEAVE();
-			return -EINVAL;
+			lbs_deb_wext("key not set, so cannot enable it\n");
+			ret = -EINVAL;
+			goto out;
 		}
 		assoc_req->wep_tx_keyidx = index;
 	}
 
 	assoc_req->secinfo.wep_enabled = 1;
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 static int validate_key_index(u16 def_index, u16 raw_index,
@@ -1605,6 +1534,8 @@ static void disable_wep(struct assoc_req
 {
 	int i;
 
+	lbs_deb_enter(LBS_DEB_WEXT);
+
 	/* Set Open System auth mode */
 	assoc_req->secinfo.auth_mode = IW_AUTH_ALG_OPEN_SYSTEM;
 
@@ -1615,6 +1546,27 @@ static void disable_wep(struct assoc_req
 
 	set_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags);
 	set_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags);
+
+	lbs_deb_leave(LBS_DEB_WEXT);
+}
+
+static void disable_wpa(struct assoc_request *assoc_req)
+{
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	memset(&assoc_req->wpa_mcast_key, 0, sizeof (struct WLAN_802_11_KEY));
+	assoc_req->wpa_mcast_key.flags = KEY_INFO_WPA_MCAST;
+	set_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags);
+
+	memset(&assoc_req->wpa_unicast_key, 0, sizeof (struct WLAN_802_11_KEY));
+	assoc_req->wpa_unicast_key.flags = KEY_INFO_WPA_UNICAST;
+	set_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags);
+
+	assoc_req->secinfo.WPAenabled = 0;
+	assoc_req->secinfo.WPA2enabled = 0;
+	set_bit(ASSOC_FLAG_SECINFO, &assoc_req->flags);
+
+	lbs_deb_leave(LBS_DEB_WEXT);
 }
 
 /**
@@ -1636,7 +1588,7 @@ static int wlan_set_encode(struct net_de
 	struct assoc_request * assoc_req;
 	u16 is_default = 0, index = 0, set_tx_key = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	mutex_lock(&adapter->lock);
 	assoc_req = wlan_get_association_request(adapter);
@@ -1647,6 +1599,7 @@ static int wlan_set_encode(struct net_de
 
 	if (dwrq->flags & IW_ENCODE_DISABLED) {
 		disable_wep (assoc_req);
+		disable_wpa (assoc_req);
 		goto out;
 	}
 
@@ -1688,7 +1641,7 @@ out:
 	}
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1712,7 +1665,7 @@ static int wlan_get_encodeext(struct net
 	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
 	int index, max_key_len;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	max_key_len = dwrq->length - sizeof(*ext);
 	if (max_key_len < 0)
@@ -1748,6 +1701,7 @@ static int wlan_get_encodeext(struct net
 		if (   adapter->secinfo.wep_enabled
 		    && !adapter->secinfo.WPAenabled
 		    && !adapter->secinfo.WPA2enabled) {
+			/* WEP */
 			ext->alg = IW_ENCODE_ALG_WEP;
 			ext->key_len = adapter->wep_keys[index].len;
 			key = &adapter->wep_keys[index].key[0];
@@ -1755,8 +1709,27 @@ static int wlan_get_encodeext(struct net
 		           && (adapter->secinfo.WPAenabled ||
 		               adapter->secinfo.WPA2enabled)) {
 			/* WPA */
-			ext->alg = IW_ENCODE_ALG_TKIP;
-			ext->key_len = 0;
+			struct WLAN_802_11_KEY * pkey = NULL;
+
+			if (   adapter->wpa_mcast_key.len
+			    && (adapter->wpa_mcast_key.flags & KEY_INFO_WPA_ENABLED))
+				pkey = &adapter->wpa_mcast_key;
+			else if (   adapter->wpa_unicast_key.len
+			         && (adapter->wpa_unicast_key.flags & KEY_INFO_WPA_ENABLED))
+				pkey = &adapter->wpa_unicast_key;
+
+			if (pkey) {
+				if (pkey->type == KEY_TYPE_ID_AES) {
+					ext->alg = IW_ENCODE_ALG_CCMP;
+				} else {
+					ext->alg = IW_ENCODE_ALG_TKIP;
+				}
+				ext->key_len = pkey->len;
+				key = &pkey->key[0];
+			} else {
+				ext->alg = IW_ENCODE_ALG_TKIP;
+				ext->key_len = 0;
+			}
 		} else {
 			goto out;
 		}
@@ -1775,7 +1748,7 @@ static int wlan_get_encodeext(struct net
 	ret = 0;
 
 out:
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1800,7 +1773,7 @@ static int wlan_set_encodeext(struct net
 	int alg = ext->alg;
 	struct assoc_request * assoc_req;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	mutex_lock(&adapter->lock);
 	assoc_req = wlan_get_association_request(adapter);
@@ -1811,6 +1784,7 @@ static int wlan_set_encodeext(struct net
 
 	if ((alg == IW_ENCODE_ALG_NONE) || (dwrq->flags & IW_ENCODE_DISABLED)) {
 		disable_wep (assoc_req);
+		disable_wpa (assoc_req);
 	} else if (alg == IW_ENCODE_ALG_WEP) {
 		u16 is_default = 0, index, set_tx_key = 0;
 
@@ -1846,7 +1820,6 @@ static int wlan_set_encodeext(struct net
 			set_bit(ASSOC_FLAG_WEP_KEYS, &assoc_req->flags);
 		if (set_tx_key)
 			set_bit(ASSOC_FLAG_WEP_TX_KEYIDX, &assoc_req->flags);
-
 	} else if ((alg == IW_ENCODE_ALG_TKIP) || (alg == IW_ENCODE_ALG_CCMP)) {
 		struct WLAN_802_11_KEY * pkey;
 
@@ -1855,36 +1828,43 @@ static int wlan_set_encodeext(struct net
 			&& (ext->key_len != KEY_LEN_WPA_TKIP))
 		    || ((alg == IW_ENCODE_ALG_CCMP)
 		        && (ext->key_len != KEY_LEN_WPA_AES))) {
-				lbs_pr_debug(1, "Invalid size %d for key of alg"
-				       "type %d.\n",
+				lbs_deb_wext("invalid size %d for key of alg"
+				       "type %d\n",
 				       ext->key_len,
 				       alg);
 				ret = -EINVAL;
 				goto out;
 		}
 
-		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
 			pkey = &assoc_req->wpa_mcast_key;
-		else
+			set_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags);
+		} else {
 			pkey = &assoc_req->wpa_unicast_key;
+			set_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags);
+		}
 
 		memset(pkey, 0, sizeof (struct WLAN_802_11_KEY));
 		memcpy(pkey->key, ext->key, ext->key_len);
 		pkey->len = ext->key_len;
-		pkey->flags = KEY_INFO_WPA_ENABLED;
+		if (pkey->len)
+			pkey->flags |= KEY_INFO_WPA_ENABLED;
 
+		/* Do this after zeroing key structure */
 		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
 			pkey->flags |= KEY_INFO_WPA_MCAST;
-			set_bit(ASSOC_FLAG_WPA_MCAST_KEY, &assoc_req->flags);
 		} else {
 			pkey->flags |= KEY_INFO_WPA_UNICAST;
-			set_bit(ASSOC_FLAG_WPA_UCAST_KEY, &assoc_req->flags);
 		}
 
-		if (alg == IW_ENCODE_ALG_TKIP)
+		if (alg == IW_ENCODE_ALG_TKIP) {
 			pkey->type = KEY_TYPE_ID_TKIP;
-		else if (alg == IW_ENCODE_ALG_CCMP)
+		} else if (alg == IW_ENCODE_ALG_CCMP) {
 			pkey->type = KEY_TYPE_ID_AES;
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
 
 		/* If WPA isn't enabled yet, do that now */
 		if (   assoc_req->secinfo.WPAenabled == 0
@@ -1905,7 +1885,7 @@ out:
 	}
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1920,7 +1900,7 @@ static int wlan_set_genie(struct net_dev
 	int ret = 0;
 	struct assoc_request * assoc_req;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	mutex_lock(&adapter->lock);
 	assoc_req = wlan_get_association_request(adapter);
@@ -1952,7 +1932,7 @@ out:
 	}
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -1961,27 +1941,28 @@ static int wlan_get_genie(struct net_dev
 			  struct iw_point *dwrq,
 			  char *extra)
 {
+	int ret = 0;
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (adapter->wpa_ie_len == 0) {
 		dwrq->length = 0;
-		LEAVE();
-		return 0;
+		goto out;
 	}
 
 	if (dwrq->length < adapter->wpa_ie_len) {
-		LEAVE();
-		return -E2BIG;
+		ret = -E2BIG;
+		goto out;
 	}
 
 	dwrq->length = adapter->wpa_ie_len;
 	memcpy(extra, &adapter->wpa_ie[0], adapter->wpa_ie_len);
 
-	LEAVE();
-	return 0;
+out:
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 
@@ -1996,7 +1977,7 @@ static int wlan_set_auth(struct net_devi
 	int ret = 0;
 	int updated = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	mutex_lock(&adapter->lock);
 	assoc_req = wlan_get_association_request(adapter);
@@ -2010,6 +1991,7 @@ static int wlan_set_auth(struct net_devi
 	case IW_AUTH_CIPHER_PAIRWISE:
 	case IW_AUTH_CIPHER_GROUP:
 	case IW_AUTH_KEY_MGMT:
+	case IW_AUTH_DROP_UNENCRYPTED:
 		/*
 		 * libertas does not use these parameters
 		 */
@@ -2019,6 +2001,7 @@ static int wlan_set_auth(struct net_devi
 		if (dwrq->value & IW_AUTH_WPA_VERSION_DISABLED) {
 			assoc_req->secinfo.WPAenabled = 0;
 			assoc_req->secinfo.WPA2enabled = 0;
+			disable_wpa (assoc_req);
 		}
 		if (dwrq->value & IW_AUTH_WPA_VERSION_WPA) {
 			assoc_req->secinfo.WPAenabled = 1;
@@ -2033,17 +2016,6 @@ static int wlan_set_auth(struct net_devi
 		updated = 1;
 		break;
 
-	case IW_AUTH_DROP_UNENCRYPTED:
-		if (dwrq->value) {
-			adapter->currentpacketfilter |=
-			    cmd_act_mac_strict_protection_enable;
-		} else {
-			adapter->currentpacketfilter &=
-			    ~cmd_act_mac_strict_protection_enable;
-		}
-		updated = 1;
-		break;
-
 	case IW_AUTH_80211_AUTH_ALG:
 		if (dwrq->value & IW_AUTH_ALG_SHARED_KEY) {
 			assoc_req->secinfo.auth_mode = IW_AUTH_ALG_SHARED_KEY;
@@ -2069,6 +2041,7 @@ static int wlan_set_auth(struct net_devi
 		} else {
 			assoc_req->secinfo.WPAenabled = 0;
 			assoc_req->secinfo.WPA2enabled = 0;
+			disable_wpa (assoc_req);
 		}
 		updated = 1;
 		break;
@@ -2088,7 +2061,7 @@ out:
 	}
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -2097,10 +2070,11 @@ static int wlan_get_auth(struct net_devi
 			 struct iw_param *dwrq,
 			 char *extra)
 {
+	int ret = 0;
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	switch (dwrq->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_WPA_VERSION:
@@ -2113,13 +2087,6 @@ static int wlan_get_auth(struct net_devi
 			dwrq->value |= IW_AUTH_WPA_VERSION_DISABLED;
 		break;
 
-	case IW_AUTH_DROP_UNENCRYPTED:
-		dwrq->value = 0;
-		if (adapter->currentpacketfilter &
-		    cmd_act_mac_strict_protection_enable)
-			dwrq->value = 1;
-		break;
-
 	case IW_AUTH_80211_AUTH_ALG:
 		dwrq->value = adapter->secinfo.auth_mode;
 		break;
@@ -2130,12 +2097,11 @@ static int wlan_get_auth(struct net_devi
 		break;
 
 	default:
-		LEAVE();
-		return -EOPNOTSUPP;
+		ret = -EOPNOTSUPP;
 	}
 
-	LEAVE();
-	return 0;
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
 }
 
 
@@ -2148,7 +2114,7 @@ static int wlan_set_txpow(struct net_dev
 
 	u16 dbm;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (vwrq->disabled) {
 		wlan_radio_ioctl(priv, RADIO_OFF);
@@ -2169,14 +2135,14 @@ static int wlan_set_txpow(struct net_dev
 	if (vwrq->fixed == 0)
 		dbm = 0xffff;
 
-	lbs_pr_debug(1, "<1>TXPOWER SET %d dbm.\n", dbm);
+	lbs_deb_wext("txpower set %d dbm\n", dbm);
 
 	ret = libertas_prepare_and_send_command(priv,
 				    cmd_802_11_rf_tx_power,
 				    cmd_act_tx_power_opt_set_low,
 				    cmd_option_waitforrsp, 0, (void *)&dbm);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -2186,7 +2152,8 @@ static int wlan_get_essid(struct net_dev
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
+
 	/*
 	 * Note : if dwrq->flags != 0, we should get the relevant SSID from
 	 * the SSID list...
@@ -2196,12 +2163,12 @@ static int wlan_get_essid(struct net_dev
 	 * Get the current SSID
 	 */
 	if (adapter->connect_status == libertas_connected) {
-		memcpy(extra, adapter->curbssparams.ssid.ssid,
-		       adapter->curbssparams.ssid.ssidlength);
-		extra[adapter->curbssparams.ssid.ssidlength] = '\0';
+		memcpy(extra, adapter->curbssparams.ssid,
+		       adapter->curbssparams.ssid_len);
+		extra[adapter->curbssparams.ssid_len] = '\0';
 	} else {
 		memset(extra, 0, 32);
-		extra[adapter->curbssparams.ssid.ssidlength] = '\0';
+		extra[adapter->curbssparams.ssid_len] = '\0';
 	}
 	/*
 	 * If none, we may want to get the one that was set
@@ -2209,14 +2176,14 @@ static int wlan_get_essid(struct net_dev
 
 	/* To make the driver backward compatible with WPA supplicant v0.2.4 */
 	if (dwrq->length == 32)	/* check with WPA supplicant buffer size */
-		dwrq->length = min_t(size_t, adapter->curbssparams.ssid.ssidlength,
+		dwrq->length = min_t(size_t, adapter->curbssparams.ssid_len,
 				   IW_ESSID_MAX_SIZE);
 	else
-		dwrq->length = adapter->curbssparams.ssid.ssidlength + 1;
+		dwrq->length = adapter->curbssparams.ssid_len + 1;
 
 	dwrq->flags = 1;	/* active */
 
-	LEAVE();
+	lbs_deb_leave(LBS_DEB_WEXT);
 	return 0;
 }
 
@@ -2226,38 +2193,43 @@ static int wlan_set_essid(struct net_dev
 	wlan_private *priv = dev->priv;
 	wlan_adapter *adapter = priv->adapter;
 	int ret = 0;
-	struct WLAN_802_11_SSID ssid;
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u8 ssid_len = 0;
 	struct assoc_request * assoc_req;
-	int ssid_len = dwrq->length;
+	int in_ssid_len = dwrq->length;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	/*
 	 * WE-20 and earlier NULL pad the end of the SSID and increment
 	 * SSID length so it can be used like a string.  WE-21 and later don't,
 	 * but some userspace tools aren't able to cope with the change.
 	 */
-	if ((ssid_len > 0) && (extra[ssid_len - 1] == '\0'))
-		ssid_len--;
+	if ((in_ssid_len > 0) && (extra[in_ssid_len - 1] == '\0'))
+		in_ssid_len--;
 
 	/* Check the size of the string */
-	if (ssid_len > IW_ESSID_MAX_SIZE) {
+	if (in_ssid_len > IW_ESSID_MAX_SIZE) {
 		ret = -E2BIG;
 		goto out;
 	}
 
-	memset(&ssid, 0, sizeof(struct WLAN_802_11_SSID));
+	memset(&ssid, 0, sizeof(ssid));
 
-	if (!dwrq->flags || !ssid_len) {
+	if (!dwrq->flags || !in_ssid_len) {
 		/* "any" SSID requested; leave SSID blank */
 	} else {
 		/* Specific SSID requested */
-		memcpy(&ssid.ssid, extra, ssid_len);
-		ssid.ssidlength = ssid_len;
+		memcpy(&ssid, extra, in_ssid_len);
+		ssid_len = in_ssid_len;
 	}
 
-	lbs_pr_debug(1, "Requested new SSID = %s\n",
-	       (ssid.ssidlength > 0) ? (char *)ssid.ssid : "any");
+	if (!ssid_len) {
+		lbs_deb_wext("requested any SSID\n");
+	} else {
+		lbs_deb_wext("requested SSID '%s'\n",
+		             escape_essid(ssid, ssid_len));
+	}
 
 out:
 	mutex_lock(&adapter->lock);
@@ -2268,7 +2240,8 @@ out:
 			ret = -ENOMEM;
 		} else {
 			/* Copy the SSID to the association request */
-			memcpy(&assoc_req->ssid, &ssid, sizeof(struct WLAN_802_11_SSID));
+			memcpy(&assoc_req->ssid, &ssid, IW_ESSID_MAX_SIZE);
+			assoc_req->ssid_len = ssid_len;
 			set_bit(ASSOC_FLAG_SSID, &assoc_req->flags);
 			wlan_postpone_association_work(priv);
 		}
@@ -2281,7 +2254,7 @@ out:
 
 	mutex_unlock(&adapter->lock);
 
-	LEAVE();
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
 	return ret;
 }
 
@@ -2302,12 +2275,12 @@ static int wlan_set_wap(struct net_devic
 	struct assoc_request * assoc_req;
 	int ret = 0;
 
-	ENTER();
+	lbs_deb_enter(LBS_DEB_WEXT);
 
 	if (awrq->sa_family != ARPHRD_ETHER)
 		return -EINVAL;
 
-	lbs_pr_debug(1, "ASSOC: WAP: sa_data: " MAC_FMT "\n", MAC_ARG(awrq->sa_data));
+	lbs_deb_wext("ASSOC: WAP: sa_data " MAC_FMT "\n", MAC_ARG(awrq->sa_data));
 
 	mutex_lock(&adapter->lock);
 
@@ -2330,22 +2303,23 @@ static int wlan_set_wap(struct net_devic
 
 void libertas_get_fwversion(wlan_adapter * adapter, char *fwversion, int maxlen)
 {
-	union {
-		u32 l;
-		u8 c[4];
-	} ver;
 	char fwver[32];
 
 	mutex_lock(&adapter->lock);
-	ver.l = adapter->fwreleasenumber;
-	mutex_unlock(&adapter->lock);
 
-	if (ver.c[3] == 0)
-		sprintf(fwver, "%u.%u.%u", ver.c[2], ver.c[1], ver.c[0]);
+	if (adapter->fwreleasenumber[3] == 0)
+		sprintf(fwver, "%u.%u.%u",
+			adapter->fwreleasenumber[2],
+			adapter->fwreleasenumber[1],
+			adapter->fwreleasenumber[0]);
 	else
 		sprintf(fwver, "%u.%u.%u.p%u",
-			ver.c[2], ver.c[1], ver.c[0], ver.c[3]);
+			adapter->fwreleasenumber[2],
+			adapter->fwreleasenumber[1],
+			adapter->fwreleasenumber[0],
+			adapter->fwreleasenumber[3]);
 
+	mutex_unlock(&adapter->lock);
 	snprintf(fwversion, maxlen, fwver);
 }
 
@@ -2411,6 +2385,63 @@ static const iw_handler wlan_handler[] =
 	(iw_handler) NULL,		/* SIOCSIWPMKSA */
 };
 
+static const iw_handler mesh_wlan_handler[] = {
+	(iw_handler) NULL,	/* SIOCSIWCOMMIT */
+	(iw_handler) wlan_get_name,	/* SIOCGIWNAME */
+	(iw_handler) NULL,	/* SIOCSIWNWID */
+	(iw_handler) NULL,	/* SIOCGIWNWID */
+	(iw_handler) wlan_set_freq,	/* SIOCSIWFREQ */
+	(iw_handler) wlan_get_freq,	/* SIOCGIWFREQ */
+	(iw_handler) NULL,		/* SIOCSIWMODE */
+	(iw_handler) mesh_wlan_get_mode,	/* SIOCGIWMODE */
+	(iw_handler) NULL,	/* SIOCSIWSENS */
+	(iw_handler) NULL,	/* SIOCGIWSENS */
+	(iw_handler) NULL,	/* SIOCSIWRANGE */
+	(iw_handler) wlan_get_range,	/* SIOCGIWRANGE */
+	(iw_handler) NULL,	/* SIOCSIWPRIV */
+	(iw_handler) NULL,	/* SIOCGIWPRIV */
+	(iw_handler) NULL,	/* SIOCSIWSTATS */
+	(iw_handler) NULL,	/* SIOCGIWSTATS */
+	iw_handler_set_spy,	/* SIOCSIWSPY */
+	iw_handler_get_spy,	/* SIOCGIWSPY */
+	iw_handler_set_thrspy,	/* SIOCSIWTHRSPY */
+	iw_handler_get_thrspy,	/* SIOCGIWTHRSPY */
+	(iw_handler) NULL,	/* SIOCSIWAP */
+	(iw_handler) NULL,	/* SIOCGIWAP */
+	(iw_handler) NULL,	/* SIOCSIWMLME */
+	(iw_handler) NULL,	/* SIOCGIWAPLIST - deprecated */
+	(iw_handler) libertas_set_scan,	/* SIOCSIWSCAN */
+	(iw_handler) libertas_get_scan,	/* SIOCGIWSCAN */
+	(iw_handler) NULL,		/* SIOCSIWESSID */
+	(iw_handler) NULL,		/* SIOCGIWESSID */
+	(iw_handler) NULL,		/* SIOCSIWNICKN */
+	(iw_handler) mesh_get_nick,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) wlan_set_rate,	/* SIOCSIWRATE */
+	(iw_handler) wlan_get_rate,	/* SIOCGIWRATE */
+	(iw_handler) wlan_set_rts,	/* SIOCSIWRTS */
+	(iw_handler) wlan_get_rts,	/* SIOCGIWRTS */
+	(iw_handler) wlan_set_frag,	/* SIOCSIWFRAG */
+	(iw_handler) wlan_get_frag,	/* SIOCGIWFRAG */
+	(iw_handler) wlan_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler) wlan_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler) wlan_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler) wlan_get_retry,	/* SIOCGIWRETRY */
+	(iw_handler) wlan_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler) wlan_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler) wlan_set_power,	/* SIOCSIWPOWER */
+	(iw_handler) wlan_get_power,	/* SIOCGIWPOWER */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) wlan_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) wlan_get_genie,	/* SIOCGIWGENIE */
+	(iw_handler) wlan_set_auth,	/* SIOCSIWAUTH */
+	(iw_handler) wlan_get_auth,	/* SIOCGIWAUTH */
+	(iw_handler) wlan_set_encodeext,/* SIOCSIWENCODEEXT */
+	(iw_handler) wlan_get_encodeext,/* SIOCGIWENCODEEXT */
+	(iw_handler) NULL,		/* SIOCSIWPMKSA */
+};
 struct iw_handler_def libertas_handler_def = {
 	.num_standard	= sizeof(wlan_handler) / sizeof(iw_handler),
 	.num_private	= sizeof(wlan_private_handler) / sizeof(iw_handler),
@@ -2421,3 +2452,14 @@ struct iw_handler_def libertas_handler_d
 	.private_args	= (struct iw_priv_args *)wlan_private_args,
 	.get_wireless_stats = wlan_get_wireless_stats,
 };
+
+struct iw_handler_def mesh_handler_def = {
+	.num_standard	= sizeof(mesh_wlan_handler) / sizeof(iw_handler),
+	.num_private	= sizeof(wlan_private_handler) / sizeof(iw_handler),
+	.num_private_args = sizeof(wlan_private_args) /
+		sizeof(struct iw_priv_args),
+	.standard	= (iw_handler *) mesh_wlan_handler,
+	.private	= (iw_handler *) wlan_private_handler,
+	.private_args	= (struct iw_priv_args *)wlan_private_args,
+	.get_wireless_stats = wlan_get_wireless_stats,
+};
diff -ruNp linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/wext.h linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/wext.h
--- linux-2.6.22-rc4-git3.orig/drivers/net/wireless/libertas/wext.h	2007-06-08 12:08:21.000000000 -0400
+++ linux-2.6.22-rc4-git6/drivers/net/wireless/libertas/wext.h	2007-06-14 14:14:33.000000000 -0400
@@ -20,21 +20,23 @@
 #define WLAN_SUBCMD_FWT_CLEANUP			15
 #define WLAN_SUBCMD_FWT_TIME			16
 #define WLAN_SUBCMD_MESH_GET_TTL		17
+#define WLAN_SUBCMD_BT_GET_INVERT		18
 
 #define WLAN_SETONEINT_GETNONE		(WLANIOCTL + 24)
 #define WLANSETREGION				8
 #define WLAN_SUBCMD_MESH_SET_TTL		18
+#define WLAN_SUBCMD_BT_SET_INVERT		19
 
 #define WLAN_SET128CHAR_GET128CHAR	(WLANIOCTL + 25)
 #define WLAN_SUBCMD_BT_ADD			18
 #define WLAN_SUBCMD_BT_DEL   			19
 #define WLAN_SUBCMD_BT_LIST			20
-#define WLAN_SUBCMD_FWT_ADD				21
-#define WLAN_SUBCMD_FWT_DEL   		22
-#define WLAN_SUBCMD_FWT_LOOKUP		23
-#define WLAN_SUBCMD_FWT_LIST_NEIGHBOR			24
+#define WLAN_SUBCMD_FWT_ADD			21
+#define WLAN_SUBCMD_FWT_DEL   			22
+#define WLAN_SUBCMD_FWT_LOOKUP			23
+#define WLAN_SUBCMD_FWT_LIST_NEIGHBOR		24
 #define WLAN_SUBCMD_FWT_LIST			25
-#define WLAN_SUBCMD_FWT_LIST_ROUTE			26
+#define WLAN_SUBCMD_FWT_LIST_ROUTE		26
 
 #define WLAN_SET_GET_SIXTEEN_INT       (WLANIOCTL + 29)
 #define WLAN_LED_GPIO_CTRL			5
@@ -56,6 +58,7 @@ struct wlan_ioctl_regrdwr {
 };
 
 extern struct iw_handler_def libertas_handler_def;
+extern struct iw_handler_def mesh_handler_def;
 int libertas_do_ioctl(struct net_device *dev, struct ifreq *req, int i);
 int wlan_radio_ioctl(wlan_private * priv, u8 option);
 
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/cifs_debug.c linux-2.6.22-rc4-git6/fs/cifs/cifs_debug.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/cifs_debug.c	2007-06-08 12:08:05.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/cifs_debug.c	2007-06-14 14:14:33.000000000 -0400
@@ -7,16 +7,16 @@
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or 
+ *   the Free Software Foundation; either version 2 of the License, or
  *   (at your option) any later version.
- * 
+ *
  *   This program is distributed in the hope that it will be useful,
  *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
  *   the GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software 
+ *   along with this program;  if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 #include <linux/fs.h>
@@ -39,7 +39,7 @@ cifs_dump_mem(char *label, void *data, i
 	char *charptr = data;
 	char buf[10], line[80];
 
-	printk(KERN_DEBUG "%s: dump of %d bytes of data at 0x%p\n", 
+	printk(KERN_DEBUG "%s: dump of %d bytes of data at 0x%p\n",
 		label, length, data);
 	for (i = 0; i < length; i += 16) {
 		line[0] = 0;
@@ -60,10 +60,10 @@ cifs_dump_mem(char *label, void *data, i
 #ifdef CONFIG_CIFS_DEBUG2
 void cifs_dump_detail(struct smb_hdr * smb)
 {
-	cERROR(1,("Cmd: %d Err: 0x%x Flags: 0x%x Flgs2: 0x%x Mid: %d Pid: %d",
+	cERROR(1, ("Cmd: %d Err: 0x%x Flags: 0x%x Flgs2: 0x%x Mid: %d Pid: %d",
 		  smb->Command, smb->Status.CifsError,
 		  smb->Flags, smb->Flags2, smb->Mid, smb->Pid));
-	cERROR(1,("smb buf %p len %d", smb, smbCalcSize_LE(smb)));
+	cERROR(1, ("smb buf %p len %d", smb, smbCalcSize_LE(smb)));
 }
 
 
@@ -72,36 +72,35 @@ void cifs_dump_mids(struct TCP_Server_In
 	struct list_head *tmp;
 	struct mid_q_entry * mid_entry;
 
-	if(server == NULL)
+	if (server == NULL)
 		return;
 
-	cERROR(1,("Dump pending requests:"));
+	cERROR(1, ("Dump pending requests:"));
 	spin_lock(&GlobalMid_Lock);
 	list_for_each(tmp, &server->pending_mid_q) {
 		mid_entry = list_entry(tmp, struct mid_q_entry, qhead);
-		if(mid_entry) {
-			cERROR(1,("State: %d Cmd: %d Pid: %d Tsk: %p Mid %d",
+		if (mid_entry) {
+			cERROR(1, ("State: %d Cmd: %d Pid: %d Tsk: %p Mid %d",
 				mid_entry->midState,
 				(int)mid_entry->command,
 				mid_entry->pid,
 				mid_entry->tsk,
 				mid_entry->mid));
 #ifdef CONFIG_CIFS_STATS2
-			cERROR(1,("IsLarge: %d buf: %p time rcv: %ld now: %ld",
+			cERROR(1, ("IsLarge: %d buf: %p time rcv: %ld now: %ld",
 				mid_entry->largeBuf,
 				mid_entry->resp_buf,
 				mid_entry->when_received,
 				jiffies));
 #endif /* STATS2 */
-			cERROR(1,("IsMult: %d IsEnd: %d", mid_entry->multiRsp,
+			cERROR(1, ("IsMult: %d IsEnd: %d", mid_entry->multiRsp,
 				  mid_entry->multiEnd));
-			if(mid_entry->resp_buf) {
+			if (mid_entry->resp_buf) {
 				cifs_dump_detail(mid_entry->resp_buf);
 				cifs_dump_mem("existing buf: ",
 					mid_entry->resp_buf,
 					62 /* fixme */);
 			}
-			
 		}
 	}
 	spin_unlock(&GlobalMid_Lock);
@@ -129,9 +128,10 @@ cifs_debug_data_read(char *buf, char **b
 		    "Display Internal CIFS Data Structures for Debugging\n"
 		    "---------------------------------------------------\n");
 	buf += length;
-	length = sprintf(buf,"CIFS Version %s\n",CIFS_VERSION);
+	length = sprintf(buf, "CIFS Version %s\n", CIFS_VERSION);
 	buf += length;
-	length = sprintf(buf,"Active VFS Requests: %d\n", GlobalTotalActiveXid);
+	length = sprintf(buf,
+		"Active VFS Requests: %d\n", GlobalTotalActiveXid);
 	buf += length;
 	length = sprintf(buf, "Servers:");
 	buf += length;
@@ -141,7 +141,7 @@ cifs_debug_data_read(char *buf, char **b
 	list_for_each(tmp, &GlobalSMBSessionList) {
 		i++;
 		ses = list_entry(tmp, struct cifsSesInfo, cifsSessionList);
-		if((ses->serverDomain == NULL) || (ses->serverOS == NULL) ||
+		if ((ses->serverDomain == NULL) || (ses->serverOS == NULL) ||
 		   (ses->serverNOS == NULL)) {
 			buf += sprintf(buf, "\nentry for %s not fully "
 					"displayed\n\t", ses->serverName);
@@ -149,15 +149,18 @@ cifs_debug_data_read(char *buf, char **b
 		} else {
 			length =
 			    sprintf(buf,
-				    "\n%d) Name: %s  Domain: %s Mounts: %d OS: %s  \n\tNOS: %s\tCapability: 0x%x\n\tSMB session status: %d\t",
+				    "\n%d) Name: %s  Domain: %s Mounts: %d OS:"
+				    " %s  \n\tNOS: %s\tCapability: 0x%x\n\tSMB"
+				    " session status: %d\t",
 				i, ses->serverName, ses->serverDomain,
 				atomic_read(&ses->inUse),
 				ses->serverOS, ses->serverNOS,
-				ses->capabilities,ses->status);
+				ses->capabilities, ses->status);
 			buf += length;
 		}
-		if(ses->server) {
-			buf += sprintf(buf, "TCP status: %d\n\tLocal Users To Server: %d SecMode: 0x%x Req On Wire: %d",
+		if (ses->server) {
+			buf += sprintf(buf, "TCP status: %d\n\tLocal Users To "
+				    "Server: %d SecMode: 0x%x Req On Wire: %d",
 				ses->server->tcpStatus,
 				atomic_read(&ses->server->socketUseCount),
 				ses->server->secMode,
@@ -165,7 +168,7 @@ cifs_debug_data_read(char *buf, char **b
 
 #ifdef CONFIG_CIFS_STATS2
 			buf += sprintf(buf, " In Send: %d In MaxReq Wait: %d",
-				atomic_read(&ses->server->inSend), 
+				atomic_read(&ses->server->inSend),
 				atomic_read(&ses->server->num_waiters));
 #endif
 
@@ -177,17 +180,19 @@ cifs_debug_data_read(char *buf, char **b
 				mid_entry = list_entry(tmp1, struct
 					mid_q_entry,
 					qhead);
-				if(mid_entry) {
-					length = sprintf(buf,"State: %d com: %d pid: %d tsk: %p mid %d\n",
-						mid_entry->midState,
-						(int)mid_entry->command,
-						mid_entry->pid,
-						mid_entry->tsk,
-						mid_entry->mid);
+				if (mid_entry) {
+					length = sprintf(buf,
+							"State: %d com: %d pid:"
+							" %d tsk: %p mid %d\n",
+							mid_entry->midState,
+							(int)mid_entry->command,
+							mid_entry->pid,
+							mid_entry->tsk,
+							mid_entry->mid);
 					buf += length;
 				}
 			}
-			spin_unlock(&GlobalMid_Lock); 
+			spin_unlock(&GlobalMid_Lock);
 		}
 
 	}
@@ -207,7 +212,8 @@ cifs_debug_data_read(char *buf, char **b
 		dev_type = le32_to_cpu(tcon->fsDevInfo.DeviceType);
 		length =
 		    sprintf(buf,
-			    "\n%d) %s Uses: %d Type: %s DevInfo: 0x%x Attributes: 0x%x\nPathComponentMax: %d Status: %d",
+			    "\n%d) %s Uses: %d Type: %s DevInfo: 0x%x "
+			    "Attributes: 0x%x\nPathComponentMax: %d Status: %d",
 			    i, tcon->treeName,
 			    atomic_read(&tcon->useCount),
 			    tcon->nativeFileSystem,
@@ -215,7 +221,7 @@ cifs_debug_data_read(char *buf, char **b
 			    le32_to_cpu(tcon->fsAttrInfo.Attributes),
 			    le32_to_cpu(tcon->fsAttrInfo.MaxPathNameComponentLength),
 			    tcon->tidStatus);
-		buf += length;        
+		buf += length;
 		if (dev_type == FILE_DEVICE_DISK)
 			length = sprintf(buf, " type: DISK ");
 		else if (dev_type == FILE_DEVICE_CD_ROM)
@@ -224,7 +230,7 @@ cifs_debug_data_read(char *buf, char **b
 			length =
 			    sprintf(buf, " type: %d ", dev_type);
 		buf += length;
-		if(tcon->tidStatus == CifsNeedReconnect) {
+		if (tcon->tidStatus == CifsNeedReconnect) {
 			buf += sprintf(buf, "\tDISCONNECTED ");
 			length += 14;
 		}
@@ -238,9 +244,9 @@ cifs_debug_data_read(char *buf, char **b
 	/* Now calculate total size of returned data */
 	length = buf - original_buf;
 
-	if(offset + count >= length)
+	if (offset + count >= length)
 		*eof = 1;
-	if(length < offset) {
+	if (length < offset) {
 		*eof = 1;
 		return 0;
 	} else {
@@ -256,18 +262,18 @@ cifs_debug_data_read(char *buf, char **b
 
 static int
 cifs_stats_write(struct file *file, const char __user *buffer,
-               unsigned long count, void *data)
+		 unsigned long count, void *data)
 {
-        char c;
-        int rc;
+	char c;
+	int rc;
 	struct list_head *tmp;
 	struct cifsTconInfo *tcon;
 
-        rc = get_user(c, buffer);
-        if (rc)
-                return rc;
+	rc = get_user(c, buffer);
+	if (rc)
+		return rc;
 
-        if (c == '1' || c == 'y' || c == 'Y' || c == '0') {
+	if (c == '1' || c == 'y' || c == 'Y' || c == '0') {
 		read_lock(&GlobalSMBSeslock);
 #ifdef CONFIG_CIFS_STATS2
 		atomic_set(&totBufAllocCount, 0);
@@ -297,14 +303,14 @@ cifs_stats_write(struct file *file, cons
 		read_unlock(&GlobalSMBSeslock);
 	}
 
-        return count;
+	return count;
 }
 
 static int
 cifs_stats_read(char *buf, char **beginBuffer, off_t offset,
 		  int count, int *eof, void *data)
 {
-	int item_length,i,length;
+	int item_length, i, length;
 	struct list_head *tmp;
 	struct cifsTconInfo *tcon;
 
@@ -314,44 +320,44 @@ cifs_stats_read(char *buf, char **beginB
 			"Resources in use\nCIFS Session: %d\n",
 			sesInfoAllocCount.counter);
 	buf += length;
-	item_length = 
-		sprintf(buf,"Share (unique mount targets): %d\n",
+	item_length =
+		sprintf(buf, "Share (unique mount targets): %d\n",
 			tconInfoAllocCount.counter);
 	length += item_length;
-	buf += item_length;      
-	item_length = 
-		sprintf(buf,"SMB Request/Response Buffer: %d Pool size: %d\n",
+	buf += item_length;
+	item_length =
+		sprintf(buf, "SMB Request/Response Buffer: %d Pool size: %d\n",
 			bufAllocCount.counter,
 			cifs_min_rcv + tcpSesAllocCount.counter);
 	length += item_length;
 	buf += item_length;
-	item_length = 
-		sprintf(buf,"SMB Small Req/Resp Buffer: %d Pool size: %d\n",
-			smBufAllocCount.counter,cifs_min_small);
+	item_length =
+		sprintf(buf, "SMB Small Req/Resp Buffer: %d Pool size: %d\n",
+			smBufAllocCount.counter, cifs_min_small);
 	length += item_length;
 	buf += item_length;
 #ifdef CONFIG_CIFS_STATS2
-        item_length = sprintf(buf, "Total Large %d Small %d Allocations\n",
+	item_length = sprintf(buf, "Total Large %d Small %d Allocations\n",
 				atomic_read(&totBufAllocCount),
-		                atomic_read(&totSmBufAllocCount));
+				atomic_read(&totSmBufAllocCount));
 	length += item_length;
 	buf += item_length;
 #endif /* CONFIG_CIFS_STATS2 */
 
-	item_length = 
-		sprintf(buf,"Operations (MIDs): %d\n",
+	item_length =
+		sprintf(buf, "Operations (MIDs): %d\n",
 			midCount.counter);
 	length += item_length;
 	buf += item_length;
 	item_length = sprintf(buf,
 		"\n%d session %d share reconnects\n",
-		tcpSesReconnectCount.counter,tconInfoReconnectCount.counter);
+		tcpSesReconnectCount.counter, tconInfoReconnectCount.counter);
 	length += item_length;
 	buf += item_length;
 
 	item_length = sprintf(buf,
 		"Total vfs operations: %d maximum at one time: %d\n",
-		GlobalCurrentXid,GlobalMaxActiveXid);
+		GlobalCurrentXid, GlobalMaxActiveXid);
 	length += item_length;
 	buf += item_length;
 
@@ -360,10 +366,10 @@ cifs_stats_read(char *buf, char **beginB
 	list_for_each(tmp, &GlobalTreeConnectionList) {
 		i++;
 		tcon = list_entry(tmp, struct cifsTconInfo, cifsConnectionList);
-		item_length = sprintf(buf,"\n%d) %s",i, tcon->treeName);
+		item_length = sprintf(buf, "\n%d) %s", i, tcon->treeName);
 		buf += item_length;
 		length += item_length;
-		if(tcon->tidStatus == CifsNeedReconnect) {
+		if (tcon->tidStatus == CifsNeedReconnect) {
 			buf += sprintf(buf, "\tDISCONNECTED ");
 			length += 14;
 		}
@@ -380,15 +386,15 @@ cifs_stats_read(char *buf, char **beginB
 		item_length = sprintf(buf, "\nWrites: %d Bytes: %lld",
 			atomic_read(&tcon->num_writes),
 			(long long)(tcon->bytes_written));
-                buf += item_length;
-                length += item_length;
-                item_length = sprintf(buf, 
+		buf += item_length;
+		length += item_length;
+		item_length = sprintf(buf,
 			"\nLocks: %d HardLinks: %d Symlinks: %d",
-                        atomic_read(&tcon->num_locks),
+			atomic_read(&tcon->num_locks),
 			atomic_read(&tcon->num_hardlinks),
 			atomic_read(&tcon->num_symlinks));
-                buf += item_length;
-                length += item_length;
+		buf += item_length;
+		length += item_length;
 
 		item_length = sprintf(buf, "\nOpens: %d Closes: %d Deletes: %d",
 			atomic_read(&tcon->num_opens),
@@ -415,12 +421,12 @@ cifs_stats_read(char *buf, char **beginB
 	}
 	read_unlock(&GlobalSMBSeslock);
 
-	buf += sprintf(buf,"\n");
+	buf += sprintf(buf, "\n");
 	length++;
 
-	if(offset + count >= length)
+	if (offset + count >= length)
 		*eof = 1;
-	if(length < offset) {
+	if (length < offset) {
 		*eof = 1;
 		return 0;
 	} else {
@@ -428,7 +434,7 @@ cifs_stats_read(char *buf, char **beginB
 	}
 	if (length > count)
 		length = count;
-		
+
 	return length;
 }
 #endif
@@ -547,11 +553,11 @@ cifs_proc_clean(void)
 	remove_proc_entry("MultiuserMount", proc_fs_cifs);
 	remove_proc_entry("OplockEnabled", proc_fs_cifs);
 /*	remove_proc_entry("NTLMV2Enabled",proc_fs_cifs); */
-	remove_proc_entry("SecurityFlags",proc_fs_cifs);
-/*	remove_proc_entry("PacketSigningEnabled",proc_fs_cifs); */
-	remove_proc_entry("LinuxExtensionsEnabled",proc_fs_cifs);
-	remove_proc_entry("Experimental",proc_fs_cifs);
-	remove_proc_entry("LookupCacheEnabled",proc_fs_cifs);
+	remove_proc_entry("SecurityFlags", proc_fs_cifs);
+/*	remove_proc_entry("PacketSigningEnabled", proc_fs_cifs); */
+	remove_proc_entry("LinuxExtensionsEnabled", proc_fs_cifs);
+	remove_proc_entry("Experimental", proc_fs_cifs);
+	remove_proc_entry("LookupCacheEnabled", proc_fs_cifs);
 	remove_proc_entry("cifs", proc_root_fs);
 }
 
@@ -590,7 +596,7 @@ cifsFYI_write(struct file *file, const c
 		cifsFYI = 0;
 	else if (c == '1' || c == 'y' || c == 'Y')
 		cifsFYI = 1;
-	else if((c > '1') && (c <= '9'))
+	else if ((c > '1') && (c <= '9'))
 		cifsFYI = (int) (c - '0'); /* see cifs_debug.h for meanings */
 
 	return count;
@@ -637,28 +643,28 @@ oplockEnabled_write(struct file *file, c
 
 static int
 experimEnabled_read(char *page, char **start, off_t off,
-                   int count, int *eof, void *data)
+		    int count, int *eof, void *data)
 {
-        int len;
+	int len;
 
-        len = sprintf(page, "%d\n", experimEnabled);
+	len = sprintf(page, "%d\n", experimEnabled);
 
-        len -= off;
-        *start = page + off;
+	len -= off;
+	*start = page + off;
 
-        if (len > count)
-                len = count;
-        else
-                *eof = 1;
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
 
-        if (len < 0)
-                len = 0;
+	if (len < 0)
+		len = 0;
 
-        return len;
+	return len;
 }
 static int
 experimEnabled_write(struct file *file, const char __user *buffer,
-                    unsigned long count, void *data)
+		     unsigned long count, void *data)
 {
 	char c;
 	int rc;
@@ -678,46 +684,46 @@ experimEnabled_write(struct file *file, 
 
 static int
 linuxExtensionsEnabled_read(char *page, char **start, off_t off,
-                   int count, int *eof, void *data)
+			    int count, int *eof, void *data)
 {
-        int len;
+	int len;
 
-        len = sprintf(page, "%d\n", linuxExtEnabled);
-        len -= off;
-        *start = page + off;
+	len = sprintf(page, "%d\n", linuxExtEnabled);
+	len -= off;
+	*start = page + off;
 
-        if (len > count)
-                len = count;
-        else
-                *eof = 1;
+	if (len > count)
+		len = count;
+	else
+		*eof = 1;
 
-        if (len < 0)
-                len = 0;
+	if (len < 0)
+		len = 0;
 
-        return len;
+	return len;
 }
 static int
 linuxExtensionsEnabled_write(struct file *file, const char __user *buffer,
-                    unsigned long count, void *data)
+			     unsigned long count, void *data)
 {
-        char c;
-        int rc;
+	char c;
+	int rc;
 
-        rc = get_user(c, buffer);
-        if (rc)
-                return rc;
-        if (c == '0' || c == 'n' || c == 'N')
-                linuxExtEnabled = 0;
-        else if (c == '1' || c == 'y' || c == 'Y')
-                linuxExtEnabled = 1;
+	rc = get_user(c, buffer);
+	if (rc)
+		return rc;
+	if (c == '0' || c == 'n' || c == 'N')
+		linuxExtEnabled = 0;
+	else if (c == '1' || c == 'y' || c == 'Y')
+		linuxExtEnabled = 1;
 
-        return count;
+	return count;
 }
 
 
 static int
 lookupFlag_read(char *page, char **start, off_t off,
-		   int count, int *eof, void *data)
+		int count, int *eof, void *data)
 {
 	int len;
 
@@ -860,15 +866,15 @@ security_flags_write(struct file *file, 
 	char flags_string[12];
 	char c;
 
-	if((count < 1) || (count > 11))
+	if ((count < 1) || (count > 11))
 		return -EINVAL;
 
 	memset(flags_string, 0, 12);
 
-	if(copy_from_user(flags_string, buffer, count))
+	if (copy_from_user(flags_string, buffer, count))
 		return -EFAULT;
 
-	if(count < 3) {
+	if (count < 3) {
 		/* single char or single char followed by null */
 		c = flags_string[0];
 		if (c == '0' || c == 'n' || c == 'N')
@@ -881,15 +887,15 @@ security_flags_write(struct file *file, 
 
 	flags = simple_strtoul(flags_string, NULL, 0);
 
-	cFYI(1,("sec flags 0x%x", flags));
+	cFYI(1, ("sec flags 0x%x", flags));
 
-	if(flags <= 0)  {
-		cERROR(1,("invalid security flags %s",flags_string));
+	if (flags <= 0)  {
+		cERROR(1, ("invalid security flags %s", flags_string));
 		return -EINVAL;
 	}
 
-	if(flags & ~CIFSSEC_MASK) {
-		cERROR(1,("attempt to set unsupported security flags 0x%x",
+	if (flags & ~CIFSSEC_MASK) {
+		cERROR(1, ("attempt to set unsupported security flags 0x%x",
 			flags & ~CIFSSEC_MASK));
 		return -EINVAL;
 	}
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/cifsfs.c linux-2.6.22-rc4-git6/fs/cifs/cifsfs.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/cifsfs.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/cifsfs.c	2007-06-14 14:14:33.000000000 -0400
@@ -825,8 +825,8 @@ cifs_init_mids(void)
 				sizeof (struct oplock_q_entry), 0,
 				SLAB_HWCACHE_ALIGN, NULL, NULL);
 	if (cifs_oplock_cachep == NULL) {
-		kmem_cache_destroy(cifs_mid_cachep);
 		mempool_destroy(cifs_mid_poolp);
+		kmem_cache_destroy(cifs_mid_cachep);
 		return -ENOMEM;
 	}
 
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/cifssmb.c linux-2.6.22-rc4-git6/fs/cifs/cifssmb.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/cifssmb.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/cifssmb.c	2007-06-14 14:14:33.000000000 -0400
@@ -433,8 +433,8 @@ CIFSSMBNegotiate(unsigned int xid, struc
 	cFYI(1,("secFlags 0x%x",secFlags));
 
 	pSMB->hdr.Mid = GetNextMid(server);
-	pSMB->hdr.Flags2 |= SMBFLG2_UNICODE;
-	if((secFlags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)
+	pSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);
+	if ((secFlags & CIFSSEC_MUST_KRB5) == CIFSSEC_MUST_KRB5)
 		pSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;
 	
 	count = 0;
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/cifs_unicode.c linux-2.6.22-rc4-git6/fs/cifs/cifs_unicode.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/cifs_unicode.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/cifs_unicode.c	2007-06-14 14:14:33.000000000 -0400
@@ -6,16 +6,16 @@
  *
  *   This program is free software;  you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or 
+ *   the Free Software Foundation; either version 2 of the License, or
  *   (at your option) any later version.
- * 
+ *
  *   This program is distributed in the hope that it will be useful,
  *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
  *   the GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program;  if not, write to the Free Software 
+ *   along with this program;  if not, write to the Free Software
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 #include <linux/fs.h>
@@ -32,7 +32,7 @@
  *
  */
 int
-cifs_strfromUCS_le(char *to, const __le16 * from,	
+cifs_strfromUCS_le(char *to, const __le16 * from,
 		   int len, const struct nls_table *codepage)
 {
 	int i;
@@ -66,7 +66,7 @@ cifs_strtoUCS(__le16 * to, const char *f
 {
 	int charlen;
 	int i;
-	wchar_t * wchar_to = (wchar_t *)to; /* needed to quiet sparse */  
+	wchar_t * wchar_to = (wchar_t *)to; /* needed to quiet sparse */
 
 	for (i = 0; len && *from; i++, from += charlen, len -= charlen) {
 
@@ -79,7 +79,7 @@ cifs_strtoUCS(__le16 * to, const char *f
 			/* A question mark */
 			to[i] = cpu_to_le16(0x003f);
 			charlen = 1;
-		} else 
+		} else
 			to[i] = cpu_to_le16(wchar_to[i]);
 
 	}
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/connect.c linux-2.6.22-rc4-git6/fs/cifs/connect.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/connect.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/connect.c	2007-06-14 14:14:33.000000000 -0400
@@ -2069,8 +2069,15 @@ cifs_mount(struct super_block *sb, struc
 			srvTcp->tcpStatus = CifsExiting;
 			spin_unlock(&GlobalMid_Lock);
 			if (srvTcp->tsk) {
+				struct task_struct *tsk;
+				/* If we could verify that kthread_stop would
+				   always wake up processes blocked in
+				   tcp in recv_mesg then we could remove the
+				   send_sig call */
 				send_sig(SIGKILL,srvTcp->tsk,1);
-				kthread_stop(srvTcp->tsk);
+				tsk = srvTcp->tsk;
+				if(tsk)
+					kthread_stop(tsk);
 			}
 		}
 		 /* If find_unc succeeded then rc == 0 so we can not end */
@@ -2085,8 +2092,11 @@ cifs_mount(struct super_block *sb, struc
 					/* if the socketUseCount is now zero */
 					if ((temp_rc == -ESHUTDOWN) &&
 					   (pSesInfo->server) && (pSesInfo->server->tsk)) {
+						struct task_struct *tsk;
 						send_sig(SIGKILL,pSesInfo->server->tsk,1);
-						kthread_stop(pSesInfo->server->tsk);
+						tsk = pSesInfo->server->tsk;
+						if (tsk)
+							kthread_stop(tsk);
 					}
 				} else
 					cFYI(1, ("No session or bad tcon"));
@@ -3334,7 +3344,7 @@ cifs_umount(struct super_block *sb, stru
 				return 0;
 			} else if (rc == -ESHUTDOWN) {
 				cFYI(1,("Waking up socket by sending it signal"));
-				if(cifsd_task) {
+				if (cifsd_task) {
 					send_sig(SIGKILL,cifsd_task,1);
 					kthread_stop(cifsd_task);
 				}
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/dir.c linux-2.6.22-rc4-git6/fs/cifs/dir.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/dir.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/dir.c	2007-06-14 14:14:33.000000000 -0400
@@ -2,7 +2,7 @@
  *   fs/cifs/dir.c
  *
  *   vfs operations that deal with dentries
- * 
+ *
  *   Copyright (C) International Business Machines  Corp., 2002,2005
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
@@ -34,11 +34,12 @@
 static void
 renew_parental_timestamps(struct dentry *direntry)
 {
-	/* BB check if there is a way to get the kernel to do this or if we really need this */
+	/* BB check if there is a way to get the kernel to do this or if we
+	   really need this */
 	do {
 		direntry->d_time = jiffies;
 		direntry = direntry->d_parent;
-	} while (!IS_ROOT(direntry));	
+	} while (!IS_ROOT(direntry));
 }
 
 /* Note: caller must free return buffer */
@@ -51,7 +52,7 @@ build_path_from_dentry(struct dentry *di
 	char *full_path;
 	char dirsep;
 
-	if(direntry == NULL)
+	if (direntry == NULL)
 		return NULL;  /* not much we can do if dentry is freed and
 		we need to reopen the file after it was closed implicitly
 		when the server crashed */
@@ -59,18 +60,18 @@ build_path_from_dentry(struct dentry *di
 	dirsep = CIFS_DIR_SEP(CIFS_SB(direntry->d_sb));
 	pplen = CIFS_SB(direntry->d_sb)->prepathlen;
 cifs_bp_rename_retry:
-	namelen = pplen; 
+	namelen = pplen;
 	for (temp = direntry; !IS_ROOT(temp);) {
 		namelen += (1 + temp->d_name.len);
 		temp = temp->d_parent;
-		if(temp == NULL) {
-			cERROR(1,("corrupt dentry"));
+		if (temp == NULL) {
+			cERROR(1, ("corrupt dentry"));
 			return NULL;
 		}
 	}
 
 	full_path = kmalloc(namelen+1, GFP_KERNEL);
-	if(full_path == NULL)
+	if (full_path == NULL)
 		return full_path;
 	full_path[namelen] = 0;	/* trailing null */
 	for (temp = direntry; !IS_ROOT(temp);) {
@@ -84,8 +85,8 @@ cifs_bp_rename_retry:
 			cFYI(0, ("name: %s", full_path + namelen));
 		}
 		temp = temp->d_parent;
-		if(temp == NULL) {
-			cERROR(1,("corrupt dentry"));
+		if (temp == NULL) {
+			cERROR(1, ("corrupt dentry"));
 			kfree(full_path);
 			return NULL;
 		}
@@ -94,7 +95,7 @@ cifs_bp_rename_retry:
 		cERROR(1,
 		       ("did not end path lookup where expected namelen is %d",
 			namelen));
-		/* presumably this is only possible if racing with a rename 
+		/* presumably this is only possible if racing with a rename
 		of one of the parent directories  (we can not lock the dentries
 		above us to prevent this, but retrying should be harmless) */
 		kfree(full_path);
@@ -106,7 +107,7 @@ cifs_bp_rename_retry:
 	   since the '\' is a valid posix character so we can not switch
 	   those safely to '/' if any are found in the middle of the prepath */
 	/* BB test paths to Windows with '/' in the midst of prepath */
-	strncpy(full_path,CIFS_SB(direntry->d_sb)->prepath,pplen);
+	strncpy(full_path, CIFS_SB(direntry->d_sb)->prepath, pplen);
 	return full_path;
 }
 
@@ -147,12 +148,12 @@ cifs_create(struct inode *inode, struct 
 	pTcon = cifs_sb->tcon;
 
 	full_path = build_path_from_dentry(direntry);
-	if(full_path == NULL) {
+	if (full_path == NULL) {
 		FreeXid(xid);
 		return -ENOMEM;
 	}
 
-	if(nd && (nd->flags & LOOKUP_OPEN)) {
+	if (nd && (nd->flags & LOOKUP_OPEN)) {
 		int oflags = nd->intent.open.flags;
 
 		desiredAccess = 0;
@@ -164,28 +165,29 @@ cifs_create(struct inode *inode, struct 
 				write_only = TRUE;
 		}
 
-		if((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
+		if ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
 			disposition = FILE_CREATE;
-		else if((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
+		else if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
 			disposition = FILE_OVERWRITE_IF;
-		else if((oflags & O_CREAT) == O_CREAT)
+		else if ((oflags & O_CREAT) == O_CREAT)
 			disposition = FILE_OPEN_IF;
 		else {
-			cFYI(1,("Create flag not set in create function"));
+			cFYI(1, ("Create flag not set in create function"));
 		}
 	}
 
-	/* BB add processing to set equivalent of mode - e.g. via CreateX with ACLs */
+	/* BB add processing to set equivalent of mode - e.g. via CreateX with
+	   ACLs */
 	if (oplockEnabled)
 		oplock = REQ_OPLOCK;
 
-	buf = kmalloc(sizeof(FILE_ALL_INFO),GFP_KERNEL);
-	if(buf == NULL) {
+	buf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);
+	if (buf == NULL) {
 		kfree(full_path);
 		FreeXid(xid);
 		return -ENOMEM;
 	}
-	if (cifs_sb->tcon->ses->capabilities & CAP_NT_SMBS) 
+	if (cifs_sb->tcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBOpen(xid, pTcon, full_path, disposition,
 			 desiredAccess, CREATE_NOT_DIR,
 			 &fileHandle, &oplock, buf, cifs_sb->local_nls,
@@ -193,27 +195,28 @@ cifs_create(struct inode *inode, struct 
 	else
 		rc = -EIO; /* no NT SMB support fall into legacy open below */
 
-	if(rc == -EIO) {
+	if (rc == -EIO) {
 		/* old server, retry the open legacy style */
 		rc = SMBLegacyOpen(xid, pTcon, full_path, disposition,
 			desiredAccess, CREATE_NOT_DIR,
 			&fileHandle, &oplock, buf, cifs_sb->local_nls,
 			cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
-	} 
+	}
 	if (rc) {
 		cFYI(1, ("cifs_create returned 0x%x", rc));
 	} else {
 		/* If Open reported that we actually created a file
 		then we now have to set the mode if possible */
 		if ((cifs_sb->tcon->ses->capabilities & CAP_UNIX) &&
-			(oplock & CIFS_CREATE_ACTION))
-			if(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
+			(oplock & CIFS_CREATE_ACTION)) {
+			mode &= ~current->fs->umask;
+			if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
 				CIFSSMBUnixSetPerms(xid, pTcon, full_path, mode,
 					(__u64)current->fsuid,
 					(__u64)current->fsgid,
 					0 /* dev */,
-					cifs_sb->local_nls, 
-					cifs_sb->mnt_cifs_flags & 
+					cifs_sb->local_nls,
+					cifs_sb->mnt_cifs_flags &
 						CIFS_MOUNT_MAP_SPECIAL_CHR);
 			} else {
 				CIFSSMBUnixSetPerms(xid, pTcon, full_path, mode,
@@ -221,26 +224,28 @@ cifs_create(struct inode *inode, struct 
 					(__u64)-1,
 					0 /* dev */,
 					cifs_sb->local_nls,
-					cifs_sb->mnt_cifs_flags & 
+					cifs_sb->mnt_cifs_flags &
 						CIFS_MOUNT_MAP_SPECIAL_CHR);
 			}
-		else {
-			/* BB implement mode setting via Windows security descriptors */
-			/* eg CIFSSMBWinSetPerms(xid,pTcon,full_path,mode,-1,-1,local_nls);*/
-			/* could set r/o dos attribute if mode & 0222 == 0 */
+		} else {
+			/* BB implement mode setting via Windows security
+			   descriptors e.g. */
+			/* CIFSSMBWinSetPerms(xid,pTcon,path,mode,-1,-1,nls);*/
+
+			/* Could set r/o dos attribute if mode & 0222 == 0 */
 		}
 
 	/* BB server might mask mode so we have to query for Unix case*/
 		if (pTcon->ses->capabilities & CAP_UNIX)
 			rc = cifs_get_inode_info_unix(&newinode, full_path,
-						 inode->i_sb,xid);
+						 inode->i_sb, xid);
 		else {
 			rc = cifs_get_inode_info(&newinode, full_path,
-						 buf, inode->i_sb,xid);
-			if(newinode) {
+						 buf, inode->i_sb, xid);
+			if (newinode) {
 				newinode->i_mode = mode;
-				if((oplock & CIFS_CREATE_ACTION) &&
-				  (cifs_sb->mnt_cifs_flags & 
+				if ((oplock & CIFS_CREATE_ACTION) &&
+				    (cifs_sb->mnt_cifs_flags &
 				     CIFS_MOUNT_SET_UID)) {
 					newinode->i_uid = current->fsuid;
 					newinode->i_gid = current->fsgid;
@@ -259,14 +264,14 @@ cifs_create(struct inode *inode, struct 
 				direntry->d_op = &cifs_dentry_ops;
 			d_instantiate(direntry, newinode);
 		}
-		if((nd->flags & LOOKUP_OPEN) == FALSE) {
+		if ((nd->flags & LOOKUP_OPEN) == FALSE) {
 			/* mknod case - do not leave file open */
 			CIFSSMBClose(xid, pTcon, fileHandle);
-		} else if(newinode) {
+		} else if (newinode) {
 			pCifsFile =
 			   kzalloc(sizeof (struct cifsFileInfo), GFP_KERNEL);
-			
-			if(pCifsFile == NULL)
+
+			if (pCifsFile == NULL)
 				goto cifs_create_out;
 			pCifsFile->netfid = fileHandle;
 			pCifsFile->pid = current->tgid;
@@ -276,33 +281,33 @@ cifs_create(struct inode *inode, struct 
 			init_MUTEX(&pCifsFile->fh_sem);
 			mutex_init(&pCifsFile->lock_mutex);
 			INIT_LIST_HEAD(&pCifsFile->llist);
-			atomic_set(&pCifsFile->wrtPending,0);
+			atomic_set(&pCifsFile->wrtPending, 0);
 
-			/* set the following in open now 
+			/* set the following in open now
 				pCifsFile->pfile = file; */
 			write_lock(&GlobalSMBSeslock);
-			list_add(&pCifsFile->tlist,&pTcon->openFileList);
+			list_add(&pCifsFile->tlist, &pTcon->openFileList);
 			pCifsInode = CIFS_I(newinode);
-			if(pCifsInode) {
+			if (pCifsInode) {
 				/* if readable file instance put first in list*/
 				if (write_only == TRUE) {
-                                       	list_add_tail(&pCifsFile->flist,
+					list_add_tail(&pCifsFile->flist,
 						&pCifsInode->openFileList);
 				} else {
 					list_add(&pCifsFile->flist,
 						&pCifsInode->openFileList);
 				}
-				if((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
+				if ((oplock & 0xF) == OPLOCK_EXCLUSIVE) {
 					pCifsInode->clientCanCacheAll = TRUE;
 					pCifsInode->clientCanCacheRead = TRUE;
-					cFYI(1,("Exclusive Oplock for inode %p",
+					cFYI(1, ("Exclusive Oplock inode %p",
 						newinode));
-				} else if((oplock & 0xF) == OPLOCK_READ)
+				} else if ((oplock & 0xF) == OPLOCK_READ)
 					pCifsInode->clientCanCacheRead = TRUE;
 			}
 			write_unlock(&GlobalSMBSeslock);
 		}
-	} 
+	}
 cifs_create_out:
 	kfree(buf);
 	kfree(full_path);
@@ -310,8 +315,8 @@ cifs_create_out:
 	return rc;
 }
 
-int cifs_mknod(struct inode *inode, struct dentry *direntry, int mode, 
-		dev_t device_number) 
+int cifs_mknod(struct inode *inode, struct dentry *direntry, int mode,
+		dev_t device_number)
 {
 	int rc = -EPERM;
 	int xid;
@@ -329,43 +334,45 @@ int cifs_mknod(struct inode *inode, stru
 	pTcon = cifs_sb->tcon;
 
 	full_path = build_path_from_dentry(direntry);
-	if(full_path == NULL)
+	if (full_path == NULL)
 		rc = -ENOMEM;
 	else if (pTcon->ses->capabilities & CAP_UNIX) {
-		if(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
+		mode &= ~current->fs->umask;
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
 			rc = CIFSSMBUnixSetPerms(xid, pTcon, full_path,
-				mode,(__u64)current->fsuid,(__u64)current->fsgid,
+				mode, (__u64)current->fsuid,
+				(__u64)current->fsgid,
 				device_number, cifs_sb->local_nls,
-				cifs_sb->mnt_cifs_flags & 
+				cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
 		} else {
 			rc = CIFSSMBUnixSetPerms(xid, pTcon,
 				full_path, mode, (__u64)-1, (__u64)-1,
 				device_number, cifs_sb->local_nls,
-				cifs_sb->mnt_cifs_flags & 
+				cifs_sb->mnt_cifs_flags &
 					CIFS_MOUNT_MAP_SPECIAL_CHR);
 		}
 
-		if(!rc) {
+		if (!rc) {
 			rc = cifs_get_inode_info_unix(&newinode, full_path,
-						inode->i_sb,xid);
+						inode->i_sb, xid);
 			if (pTcon->nocase)
 				direntry->d_op = &cifs_ci_dentry_ops;
 			else
 				direntry->d_op = &cifs_dentry_ops;
-			if(rc == 0)
+			if (rc == 0)
 				d_instantiate(direntry, newinode);
 		}
 	} else {
-		if(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL) {
+		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL) {
 			int oplock = 0;
 			u16 fileHandle;
 			FILE_ALL_INFO * buf;
 
-			cFYI(1,("sfu compat create special file"));
+			cFYI(1, ("sfu compat create special file"));
 
-			buf = kmalloc(sizeof(FILE_ALL_INFO),GFP_KERNEL);
-			if(buf == NULL) {
+			buf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);
+			if (buf == NULL) {
 				kfree(full_path);
 				FreeXid(xid);
 				return -ENOMEM;
@@ -373,39 +380,38 @@ int cifs_mknod(struct inode *inode, stru
 
 			rc = CIFSSMBOpen(xid, pTcon, full_path,
 					 FILE_CREATE, /* fail if exists */
-					 GENERIC_WRITE /* BB would 
+					 GENERIC_WRITE /* BB would
 					  WRITE_OWNER | WRITE_DAC be better? */,
 					 /* Create a file and set the
 					    file attribute to SYSTEM */
 					 CREATE_NOT_DIR | CREATE_OPTION_SPECIAL,
 					 &fileHandle, &oplock, buf,
 					 cifs_sb->local_nls,
-					 cifs_sb->mnt_cifs_flags & 
+					 cifs_sb->mnt_cifs_flags &
 					    CIFS_MOUNT_MAP_SPECIAL_CHR);
 
 			/* BB FIXME - add handling for backlevel servers
 			   which need legacy open and check for all
-			   calls to SMBOpen for fallback to 
-			   SMBLeagcyOpen */
-			if(!rc) {
+			   calls to SMBOpen for fallback to SMBLeagcyOpen */
+			if (!rc) {
 				/* BB Do not bother to decode buf since no
 				   local inode yet to put timestamps in,
 				   but we can reuse it safely */
 				int bytes_written;
 				struct win_dev *pdev;
 				pdev = (struct win_dev *)buf;
-				if(S_ISCHR(mode)) {
+				if (S_ISCHR(mode)) {
 					memcpy(pdev->type, "IntxCHR", 8);
 					pdev->major =
 					      cpu_to_le64(MAJOR(device_number));
-					pdev->minor = 
+					pdev->minor =
 					      cpu_to_le64(MINOR(device_number));
 					rc = CIFSSMBWrite(xid, pTcon,
 						fileHandle,
 						sizeof(struct win_dev),
 						0, &bytes_written, (char *)pdev,
 						NULL, 0);
-				} else if(S_ISBLK(mode)) {
+				} else if (S_ISBLK(mode)) {
 					memcpy(pdev->type, "IntxBLK", 8);
 					pdev->major =
 					      cpu_to_le64(MAJOR(device_number));
@@ -432,7 +438,8 @@ int cifs_mknod(struct inode *inode, stru
 
 
 struct dentry *
-cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry, struct nameidata *nd)
+cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
+	    struct nameidata *nd)
 {
 	int xid;
 	int rc = 0; /* to get around spurious gcc warning, set to zero here */
@@ -447,8 +454,6 @@ cifs_lookup(struct inode *parent_dir_ino
 	     (" parent inode = 0x%p name is: %s and dentry = 0x%p",
 	      parent_dir_inode, direntry->d_name.name, direntry));
 
-	/* BB Add check of incoming data - e.g. frame not longer than maximum SMB - let server check the namelen BB */
-
 	/* check whether path exists */
 
 	cifs_sb = CIFS_SB(parent_dir_inode->i_sb);
@@ -472,7 +477,7 @@ cifs_lookup(struct inode *parent_dir_ino
 	deadlock in the cases (beginning of sys_rename itself)
 	in which we already have the sb rename sem */
 	full_path = build_path_from_dentry(direntry);
-	if(full_path == NULL) {
+	if (full_path == NULL) {
 		FreeXid(xid);
 		return ERR_PTR(-ENOMEM);
 	}
@@ -487,10 +492,10 @@ cifs_lookup(struct inode *parent_dir_ino
 
 	if (pTcon->ses->capabilities & CAP_UNIX)
 		rc = cifs_get_inode_info_unix(&newInode, full_path,
-					      parent_dir_inode->i_sb,xid);
+					      parent_dir_inode->i_sb, xid);
 	else
 		rc = cifs_get_inode_info(&newInode, full_path, NULL,
-					 parent_dir_inode->i_sb,xid);
+					 parent_dir_inode->i_sb, xid);
 
 	if ((rc == 0) && (newInode != NULL)) {
 		if (pTcon->nocase)
@@ -499,7 +504,7 @@ cifs_lookup(struct inode *parent_dir_ino
 			direntry->d_op = &cifs_dentry_ops;
 		d_add(direntry, newInode);
 
-		/* since paths are not looked up by component - the parent 
+		/* since paths are not looked up by component - the parent
 		   directories are presumed to be good here */
 		renew_parental_timestamps(direntry);
 
@@ -511,13 +516,13 @@ cifs_lookup(struct inode *parent_dir_ino
 		else
 			direntry->d_op = &cifs_dentry_ops;
 		d_add(direntry, NULL);
-	/*	if it was once a directory (but how can we tell?) we could do  
-			shrink_dcache_parent(direntry); */
+	/*	if it was once a directory (but how can we tell?) we could do
+		shrink_dcache_parent(direntry); */
 	} else {
-		cERROR(1,("Error 0x%x on cifs_get_inode_info in lookup of %s",
-			   rc,full_path));
-		/* BB special case check for Access Denied - watch security 
-		exposure of returning dir info implicitly via different rc 
+		cERROR(1, ("Error 0x%x on cifs_get_inode_info in lookup of %s",
+			   rc, full_path));
+		/* BB special case check for Access Denied - watch security
+		exposure of returning dir info implicitly via different rc
 		if file exists or not but no access BB */
 	}
 
@@ -538,11 +543,11 @@ cifs_d_revalidate(struct dentry *direntr
 	} else {
 		cFYI(1, ("neg dentry 0x%p name = %s",
 			 direntry, direntry->d_name.name));
-		if(time_after(jiffies, direntry->d_time + HZ) || 
+		if (time_after(jiffies, direntry->d_time + HZ) ||
 			!lookupCacheEnabled) {
 			d_drop(direntry);
 			isValid = 0;
-		} 
+		}
 	}
 
 	return isValid;
@@ -559,8 +564,7 @@ cifs_d_revalidate(struct dentry *direntr
 
 struct dentry_operations cifs_dentry_ops = {
 	.d_revalidate = cifs_d_revalidate,
-/* d_delete:       cifs_d_delete,       *//* not needed except for debugging */
-	/* no need for d_hash, d_compare, d_release, d_iput ... yet. BB confirm this BB */
+/* d_delete:       cifs_d_delete,      */ /* not needed except for debugging */
 };
 
 static int cifs_ci_hash(struct dentry *dentry, struct qstr *q)
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/fcntl.c linux-2.6.22-rc4-git6/fs/cifs/fcntl.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/fcntl.c	2007-06-08 12:08:05.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/fcntl.c	2007-06-14 14:14:33.000000000 -0400
@@ -2,7 +2,7 @@
  *   fs/cifs/fcntl.c
  *
  *   vfs operations that deal with the file control API
- * 
+ *
  *   Copyright (C) International Business Machines  Corp., 2003,2004
  *   Author(s): Steve French (sfrench@us.ibm.com)
  *
@@ -35,35 +35,34 @@ static __u32 convert_to_cifs_notify_flag
 
 	/* No way on Linux VFS to ask to monitor xattr
 	changes (and no stream support either */
-	if(fcntl_notify_flags & DN_ACCESS) {
+	if (fcntl_notify_flags & DN_ACCESS) {
 		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_LAST_ACCESS;
 	}
-	if(fcntl_notify_flags & DN_MODIFY) {
+	if (fcntl_notify_flags & DN_MODIFY) {
 		/* What does this mean on directories? */
 		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_LAST_WRITE |
 			FILE_NOTIFY_CHANGE_SIZE;
 	}
-	if(fcntl_notify_flags & DN_CREATE) {
-		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_CREATION | 
+	if (fcntl_notify_flags & DN_CREATE) {
+		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_CREATION |
 			FILE_NOTIFY_CHANGE_LAST_WRITE;
 	}
-	if(fcntl_notify_flags & DN_DELETE) {
+	if (fcntl_notify_flags & DN_DELETE) {
 		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_LAST_WRITE;
 	}
-	if(fcntl_notify_flags & DN_RENAME) {
+	if (fcntl_notify_flags & DN_RENAME) {
 		/* BB review this - checking various server behaviors */
-		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_DIR_NAME | 
+		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_DIR_NAME |
 			FILE_NOTIFY_CHANGE_FILE_NAME;
 	}
-	if(fcntl_notify_flags & DN_ATTRIB) {
-		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_SECURITY | 
+	if (fcntl_notify_flags & DN_ATTRIB) {
+		cifs_ntfy_flags |= FILE_NOTIFY_CHANGE_SECURITY |
 			FILE_NOTIFY_CHANGE_ATTRIBUTES;
 	}
-/*	if(fcntl_notify_flags & DN_MULTISHOT) {
+/*	if (fcntl_notify_flags & DN_MULTISHOT) {
 		cifs_ntfy_flags |= ;
 	} */ /* BB fixme - not sure how to handle this with CIFS yet */
 
-
 	return cifs_ntfy_flags;
 }
 
@@ -78,8 +77,7 @@ int cifs_dir_notify(struct file * file, 
 	__u32 filter = FILE_NOTIFY_CHANGE_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES;
 	__u16 netfid;
 
-
-	if(experimEnabled == 0)
+	if (experimEnabled == 0)
 		return 0;
 
 	xid = GetXid();
@@ -88,21 +86,21 @@ int cifs_dir_notify(struct file * file, 
 
 	full_path = build_path_from_dentry(file->f_path.dentry);
 
-	if(full_path == NULL) {
+	if (full_path == NULL) {
 		rc = -ENOMEM;
 	} else {
-		cFYI(1,("dir notify on file %s Arg 0x%lx",full_path,arg));
-		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN, 
+		cFYI(1, ("dir notify on file %s Arg 0x%lx", full_path, arg));
+		rc = CIFSSMBOpen(xid, pTcon, full_path, FILE_OPEN,
 			GENERIC_READ | SYNCHRONIZE, 0 /* create options */,
-			&netfid, &oplock,NULL, cifs_sb->local_nls,
+			&netfid, &oplock, NULL, cifs_sb->local_nls,
 			cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
 		/* BB fixme - add this handle to a notify handle list */
-		if(rc) {
-			cFYI(1,("Could not open directory for notify"));
+		if (rc) {
+			cFYI(1, ("Could not open directory for notify"));
 		} else {
 			filter = convert_to_cifs_notify_flags(arg);
-			if(filter != 0) {
-				rc = CIFSSMBNotify(xid, pTcon, 
+			if (filter != 0) {
+				rc = CIFSSMBNotify(xid, pTcon,
 					0 /* no subdirs */, netfid,
 					filter, file, arg & DN_MULTISHOT,
 					cifs_sb->local_nls);
@@ -113,10 +111,10 @@ int cifs_dir_notify(struct file * file, 
 			it would close automatically but may be a way
 			to do it easily when inode freed or when
 			notify info is cleared/changed */
-			cFYI(1,("notify rc %d",rc));
+			cFYI(1, ("notify rc %d", rc));
 		}
 	}
-	
+
 	FreeXid(xid);
 	return rc;
 }
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/inode.c linux-2.6.22-rc4-git6/fs/cifs/inode.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/inode.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/inode.c	2007-06-14 14:14:33.000000000 -0400
@@ -986,7 +986,8 @@ mkdir_get_info:		
 		  * failed to get it from the server or was set bogus */ 
 		if ((direntry->d_inode) && (direntry->d_inode->i_nlink < 2))
 				direntry->d_inode->i_nlink = 2; 
-		if (cifs_sb->tcon->ses->capabilities & CAP_UNIX)
+		if (cifs_sb->tcon->ses->capabilities & CAP_UNIX) {
+			mode &= ~current->fs->umask;
 			if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
 				CIFSSMBUnixSetPerms(xid, pTcon, full_path,
 						    mode,
@@ -1004,7 +1005,7 @@ mkdir_get_info:		
 						    cifs_sb->mnt_cifs_flags & 
 						    CIFS_MOUNT_MAP_SPECIAL_CHR);
 			}
-		else {
+		} else {
 			/* BB to be implemented via Windows secrty descriptors
 			   eg CIFSSMBWinSetPerms(xid, pTcon, full_path, mode,
 						 -1, -1, local_nls); */
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/ioctl.c linux-2.6.22-rc4-git6/fs/cifs/ioctl.c
--- linux-2.6.22-rc4-git3.orig/fs/cifs/ioctl.c	2007-06-08 12:07:55.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/ioctl.c	2007-06-14 14:14:33.000000000 -0400
@@ -30,7 +30,7 @@
 
 #define CIFS_IOC_CHECKUMOUNT _IO(0xCF, 2)
 
-int cifs_ioctl (struct inode * inode, struct file * filep, 
+int cifs_ioctl (struct inode * inode, struct file * filep,
 		unsigned int command, unsigned long arg)
 {
 	int rc = -ENOTTY; /* strange error - but the precedent */
@@ -47,13 +47,13 @@ int cifs_ioctl (struct inode * inode, st
 
 	xid = GetXid();
 
-        cFYI(1,("ioctl file %p  cmd %u  arg %lu",filep,command,arg));
+	cFYI(1, ("ioctl file %p  cmd %u  arg %lu", filep, command, arg));
 
 	cifs_sb = CIFS_SB(inode->i_sb);
 
 #ifdef CONFIG_CIFS_POSIX
 	tcon = cifs_sb->tcon;
-	if(tcon)
+	if (tcon)
 		caps = le64_to_cpu(tcon->fsUnixInfo.Capability);
 	else {
 		rc = -EIO;
@@ -62,24 +62,24 @@ int cifs_ioctl (struct inode * inode, st
 	}
 #endif /* CONFIG_CIFS_POSIX */
 
-	switch(command) {
+	switch (command) {
 		case CIFS_IOC_CHECKUMOUNT:
-			cFYI(1,("User unmount attempted"));
-			if(cifs_sb->mnt_uid == current->uid)
+			cFYI(1, ("User unmount attempted"));
+			if (cifs_sb->mnt_uid == current->uid)
 				rc = 0;
 			else {
 				rc = -EACCES;
-				cFYI(1,("uids do not match"));
+				cFYI(1, ("uids do not match"));
 			}
 			break;
 #ifdef CONFIG_CIFS_POSIX
 		case FS_IOC_GETFLAGS:
-			if(CIFS_UNIX_EXTATTR_CAP & caps) {
+			if (CIFS_UNIX_EXTATTR_CAP & caps) {
 				if (pSMBFile == NULL)
 					break;
 				rc = CIFSGetExtAttr(xid, tcon, pSMBFile->netfid,
 					&ExtAttrBits, &ExtAttrMask);
-				if(rc == 0)
+				if (rc == 0)
 					rc = put_user(ExtAttrBits &
 						FS_FL_USER_VISIBLE,
 						(int __user *)arg);
@@ -87,8 +87,8 @@ int cifs_ioctl (struct inode * inode, st
 			break;
 
 		case FS_IOC_SETFLAGS:
-			if(CIFS_UNIX_EXTATTR_CAP & caps) {
-				if(get_user(ExtAttrBits,(int __user *)arg)) {
+			if (CIFS_UNIX_EXTATTR_CAP & caps) {
+				if (get_user(ExtAttrBits, (int __user *)arg)) {
 					rc = -EFAULT;
 					break;
 				}
@@ -96,16 +96,15 @@ int cifs_ioctl (struct inode * inode, st
 					break;
 				/* rc= CIFSGetExtAttr(xid,tcon,pSMBFile->netfid,
 					extAttrBits, &ExtAttrMask);*/
-				
 			}
-			cFYI(1,("set flags not implemented yet"));
+			cFYI(1, ("set flags not implemented yet"));
 			break;
 #endif /* CONFIG_CIFS_POSIX */
 		default:
-			cFYI(1,("unsupported ioctl"));
+			cFYI(1, ("unsupported ioctl"));
 			break;
 	}
 
 	FreeXid(xid);
 	return rc;
-} 
+}
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/cifs/rfc1002pdu.h linux-2.6.22-rc4-git6/fs/cifs/rfc1002pdu.h
--- linux-2.6.22-rc4-git3.orig/fs/cifs/rfc1002pdu.h	2007-06-08 11:12:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/cifs/rfc1002pdu.h	2007-06-14 14:14:33.000000000 -0400
@@ -18,7 +18,7 @@
  *
  *   You should have received a copy of the GNU Lesser General Public License
  *   along with this library; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 /* NB: unlike smb/cifs packets, the RFC1002 structures are big endian */
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/splice.c linux-2.6.22-rc4-git6/fs/splice.c
--- linux-2.6.22-rc4-git3.orig/fs/splice.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/splice.c	2007-06-14 14:14:33.000000000 -0400
@@ -272,7 +272,6 @@ __generic_file_splice_read(struct file *
 	struct page *page;
 	pgoff_t index, end_index;
 	loff_t isize;
-	size_t total_len;
 	int error, page_nr;
 	struct splice_pipe_desc spd = {
 		.pages = pages,
@@ -298,7 +297,6 @@ __generic_file_splice_read(struct file *
 	 * Now fill in the holes:
 	 */
 	error = 0;
-	total_len = 0;
 
 	/*
 	 * Lookup the (hopefully) full range of pages we need.
@@ -415,43 +413,47 @@ __generic_file_splice_read(struct file *
 
 				break;
 			}
+		}
+fill_it:
+		/*
+		 * i_size must be checked after PageUptodate.
+		 */
+		isize = i_size_read(mapping->host);
+		end_index = (isize - 1) >> PAGE_CACHE_SHIFT;
+		if (unlikely(!isize || index > end_index))
+			break;
+
+		/*
+		 * if this is the last page, see if we need to shrink
+		 * the length and stop
+		 */
+		if (end_index == index) {
+			unsigned int plen;
 
 			/*
-			 * i_size must be checked after ->readpage().
+			 * max good bytes in this page
 			 */
-			isize = i_size_read(mapping->host);
-			end_index = (isize - 1) >> PAGE_CACHE_SHIFT;
-			if (unlikely(!isize || index > end_index))
+			plen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;
+			if (plen <= loff)
 				break;
 
 			/*
-			 * if this is the last page, see if we need to shrink
-			 * the length and stop
+			 * force quit after adding this page
 			 */
-			if (end_index == index) {
-				loff = PAGE_CACHE_SIZE - (isize & ~PAGE_CACHE_MASK);
-				if (total_len + loff > isize)
-					break;
-				/*
-				 * force quit after adding this page
-				 */
-				len = this_len;
-				this_len = min(this_len, loff);
-				loff = 0;
-			}
+			this_len = min(this_len, plen - loff);
+			len = this_len;
 		}
-fill_it:
+
 		partial[page_nr].offset = loff;
 		partial[page_nr].len = this_len;
 		len -= this_len;
-		total_len += this_len;
 		loff = 0;
 		spd.nr_pages++;
 		index++;
 	}
 
 	/*
-	 * Release any pages at the end, if we quit early. 'i' is how far
+	 * Release any pages at the end, if we quit early. 'page_nr' is how far
 	 * we got, 'nr_pages' is how many pages are in the map.
 	 */
 	while (page_nr < nr_pages)
@@ -478,10 +480,18 @@ ssize_t generic_file_splice_read(struct 
 {
 	ssize_t spliced;
 	int ret;
+	loff_t isize, left;
+
+	isize = i_size_read(in->f_mapping->host);
+	if (unlikely(*ppos >= isize))
+		return 0;
+
+	left = isize - *ppos;
+	if (unlikely(left < len))
+		len = left;
 
 	ret = 0;
 	spliced = 0;
-
 	while (len) {
 		ret = __generic_file_splice_read(in, ppos, pipe, len, flags);
 
@@ -644,7 +654,6 @@ find_page:
 	 * accessed, we are now done!
 	 */
 	mark_page_accessed(page);
-	balance_dirty_pages_ratelimited(mapping);
 out:
 	page_cache_release(page);
 	unlock_page(page);
@@ -815,6 +824,7 @@ generic_file_splice_write_nolock(struct 
 			if (err)
 				ret = err;
 		}
+		balance_dirty_pages_ratelimited(mapping);
 	}
 
 	return ret;
@@ -868,6 +878,7 @@ generic_file_splice_write(struct pipe_in
 			if (err)
 				ret = err;
 		}
+		balance_dirty_pages_ratelimited(mapping);
 	}
 
 	return ret;
@@ -922,7 +933,6 @@ static long do_splice_to(struct file *in
 			 struct pipe_inode_info *pipe, size_t len,
 			 unsigned int flags)
 {
-	loff_t isize, left;
 	int ret;
 
 	if (unlikely(!in->f_op || !in->f_op->splice_read))
@@ -935,14 +945,6 @@ static long do_splice_to(struct file *in
 	if (unlikely(ret < 0))
 		return ret;
 
-	isize = i_size_read(in->f_mapping->host);
-	if (unlikely(*ppos >= isize))
-		return 0;
-	
-	left = isize - *ppos;
-	if (unlikely(left < len))
-		len = left;
-
 	return in->f_op->splice_read(in, ppos, pipe, len, flags);
 }
 
@@ -1058,8 +1060,6 @@ out_release:
 	return ret;
 }
 
-EXPORT_SYMBOL(do_splice_direct);
-
 /*
  * After the inode slimming patch, i_pipe/i_bdev/i_cdev share the same
  * location, so checking ->i_pipe is not enough to verify that this is a
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/sysfs/dir.c linux-2.6.22-rc4-git6/fs/sysfs/dir.c
--- linux-2.6.22-rc4-git3.orig/fs/sysfs/dir.c	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/sysfs/dir.c	2007-06-14 14:14:33.000000000 -0400
@@ -13,14 +13,26 @@
 #include "sysfs.h"
 
 DECLARE_RWSEM(sysfs_rename_sem);
+spinlock_t sysfs_lock = SPIN_LOCK_UNLOCKED;
 
 static void sysfs_d_iput(struct dentry * dentry, struct inode * inode)
 {
 	struct sysfs_dirent * sd = dentry->d_fsdata;
 
 	if (sd) {
-		BUG_ON(sd->s_dentry != dentry);
-		sd->s_dentry = NULL;
+		/* sd->s_dentry is protected with sysfs_lock.  This
+		 * allows sysfs_drop_dentry() to dereference it.
+		 */
+		spin_lock(&sysfs_lock);
+
+		/* The dentry might have been deleted or another
+		 * lookup could have happened updating sd->s_dentry to
+		 * point the new dentry.  Ignore if it isn't pointing
+		 * to this dentry.
+		 */
+		if (sd->s_dentry == dentry)
+			sd->s_dentry = NULL;
+		spin_unlock(&sysfs_lock);
 		sysfs_put(sd);
 	}
 	iput(inode);
@@ -30,6 +42,14 @@ static struct dentry_operations sysfs_de
 	.d_iput		= sysfs_d_iput,
 };
 
+static unsigned int sysfs_inode_counter;
+ino_t sysfs_get_inum(void)
+{
+	if (unlikely(sysfs_inode_counter < 3))
+		sysfs_inode_counter = 3;
+	return sysfs_inode_counter++;
+}
+
 /*
  * Allocates a new sysfs_dirent and links it to the parent sysfs_dirent
  */
@@ -41,6 +61,7 @@ static struct sysfs_dirent * __sysfs_new
 	if (!sd)
 		return NULL;
 
+	sd->s_ino = sysfs_get_inum();
 	atomic_set(&sd->s_count, 1);
 	atomic_set(&sd->s_event, 1);
 	INIT_LIST_HEAD(&sd->s_children);
@@ -238,7 +259,10 @@ static int sysfs_attach_attr(struct sysf
         }
 
 	dentry->d_fsdata = sysfs_get(sd);
+	/* protect sd->s_dentry against sysfs_d_iput */
+	spin_lock(&sysfs_lock);
 	sd->s_dentry = dentry;
+	spin_unlock(&sysfs_lock);
 	error = sysfs_create(dentry, (attr->mode & S_IALLUGO) | S_IFREG, init);
 	if (error) {
 		sysfs_put(sd);
@@ -260,7 +284,10 @@ static int sysfs_attach_link(struct sysf
 	int err = 0;
 
 	dentry->d_fsdata = sysfs_get(sd);
+	/* protect sd->s_dentry against sysfs_d_iput */
+	spin_lock(&sysfs_lock);
 	sd->s_dentry = dentry;
+	spin_unlock(&sysfs_lock);
 	err = sysfs_create(dentry, S_IFLNK|S_IRWXUGO, init_symlink);
 	if (!err) {
 		dentry->d_op = &sysfs_dentry_ops;
@@ -509,7 +536,7 @@ static int sysfs_readdir(struct file * f
 
 	switch (i) {
 		case 0:
-			ino = dentry->d_inode->i_ino;
+			ino = parent_sd->s_ino;
 			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 				break;
 			filp->f_pos++;
@@ -538,10 +565,7 @@ static int sysfs_readdir(struct file * f
 
 				name = sysfs_get_name(next);
 				len = strlen(name);
-				if (next->s_dentry)
-					ino = next->s_dentry->d_inode->i_ino;
-				else
-					ino = iunique(sysfs_sb, 2);
+				ino = next->s_ino;
 
 				if (filldir(dirent, name, len, filp->f_pos, ino,
 						 dt_type(next)) < 0)
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/sysfs/inode.c linux-2.6.22-rc4-git6/fs/sysfs/inode.c
--- linux-2.6.22-rc4-git3.orig/fs/sysfs/inode.c	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/sysfs/inode.c	2007-06-14 14:14:33.000000000 -0400
@@ -141,6 +141,7 @@ struct inode * sysfs_new_inode(mode_t mo
 		inode->i_mapping->a_ops = &sysfs_aops;
 		inode->i_mapping->backing_dev_info = &sysfs_backing_dev_info;
 		inode->i_op = &sysfs_inode_operations;
+		inode->i_ino = sd->s_ino;
 		lockdep_set_class(&inode->i_mutex, &sysfs_inode_imutex_key);
 
 		if (sd->s_iattr) {
@@ -245,13 +246,27 @@ static inline void orphan_all_buffers(st
  */
 void sysfs_drop_dentry(struct sysfs_dirent * sd, struct dentry * parent)
 {
-	struct dentry * dentry = sd->s_dentry;
+	struct dentry *dentry = NULL;
 	struct inode *inode;
 
+	/* We're not holding a reference to ->s_dentry dentry but the
+	 * field will stay valid as long as sysfs_lock is held.
+	 */
+	spin_lock(&sysfs_lock);
+	spin_lock(&dcache_lock);
+
+	/* dget dentry if it's still alive */
+	if (sd->s_dentry && sd->s_dentry->d_inode)
+		dentry = dget_locked(sd->s_dentry);
+
+	spin_unlock(&dcache_lock);
+	spin_unlock(&sysfs_lock);
+
+	/* drop dentry */
 	if (dentry) {
 		spin_lock(&dcache_lock);
 		spin_lock(&dentry->d_lock);
-		if (!(d_unhashed(dentry) && dentry->d_inode)) {
+		if (!d_unhashed(dentry) && dentry->d_inode) {
 			inode = dentry->d_inode;
 			spin_lock(&inode->i_lock);
 			__iget(inode);
@@ -267,6 +282,8 @@ void sysfs_drop_dentry(struct sysfs_dire
 			spin_unlock(&dentry->d_lock);
 			spin_unlock(&dcache_lock);
 		}
+
+		dput(dentry);
 	}
 }
 
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/sysfs/mount.c linux-2.6.22-rc4-git6/fs/sysfs/mount.c
--- linux-2.6.22-rc4-git3.orig/fs/sysfs/mount.c	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/sysfs/mount.c	2007-06-14 14:14:33.000000000 -0400
@@ -33,6 +33,7 @@ static struct sysfs_dirent sysfs_root = 
 	.s_element	= NULL,
 	.s_type		= SYSFS_ROOT,
 	.s_iattr	= NULL,
+	.s_ino		= 1,
 };
 
 static void sysfs_clear_inode(struct inode *inode)
diff -ruNp linux-2.6.22-rc4-git3.orig/fs/sysfs/sysfs.h linux-2.6.22-rc4-git6/fs/sysfs/sysfs.h
--- linux-2.6.22-rc4-git3.orig/fs/sysfs/sysfs.h	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/fs/sysfs/sysfs.h	2007-06-14 14:14:33.000000000 -0400
@@ -5,6 +5,7 @@ struct sysfs_dirent {
 	void 			* s_element;
 	int			s_type;
 	umode_t			s_mode;
+	ino_t			s_ino;
 	struct dentry		* s_dentry;
 	struct iattr		* s_iattr;
 	atomic_t		s_event;
@@ -32,6 +33,7 @@ extern const unsigned char * sysfs_get_n
 extern void sysfs_drop_dentry(struct sysfs_dirent *sd, struct dentry *parent);
 extern int sysfs_setattr(struct dentry *dentry, struct iattr *iattr);
 
+extern spinlock_t sysfs_lock;
 extern struct rw_semaphore sysfs_rename_sem;
 extern struct super_block * sysfs_sb;
 extern const struct file_operations sysfs_dir_operations;
diff -ruNp linux-2.6.22-rc4-git3.orig/include/asm-mips/bitops.h linux-2.6.22-rc4-git6/include/asm-mips/bitops.h
--- linux-2.6.22-rc4-git3.orig/include/asm-mips/bitops.h	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/asm-mips/bitops.h	2007-06-14 14:14:33.000000000 -0400
@@ -238,10 +238,11 @@ static inline int test_and_set_bit(unsig
 	volatile unsigned long *addr)
 {
 	unsigned short bit = nr & SZLONG_MASK;
+	unsigned long res;
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -254,11 +255,9 @@ static inline int test_and_set_bit(unsig
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 	} else if (cpu_has_llsc) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	push					\n"
@@ -277,25 +276,22 @@ static inline int test_and_set_bit(unsig
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 	} else {
 		volatile unsigned long *a = addr;
 		unsigned long mask;
-		int retval;
 		unsigned long flags;
 
 		a += nr >> SZLONG_LOG;
 		mask = 1UL << bit;
 		raw_local_irq_save(flags);
-		retval = (mask & *a) != 0;
+		res = (mask & *a);
 		*a |= mask;
 		raw_local_irq_restore(flags);
-
-		return retval;
 	}
 
 	smp_mb();
+
+	return res != 0;
 }
 
 /*
@@ -310,6 +306,7 @@ static inline int test_and_clear_bit(uns
 	volatile unsigned long *addr)
 {
 	unsigned short bit = nr & SZLONG_MASK;
+	unsigned long res;
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
@@ -327,12 +324,10 @@ static inline int test_and_clear_bit(uns
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 #ifdef CONFIG_CPU_MIPSR2
 	} else if (__builtin_constant_p(nr)) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"1:	" __LL	"%0, %1		# test_and_clear_bit	\n"
@@ -346,12 +341,10 @@ static inline int test_and_clear_bit(uns
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "ri" (bit), "m" (*m)
 		: "memory");
-
-		return res;
 #endif
 	} else if (cpu_has_llsc) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	push					\n"
@@ -371,25 +364,22 @@ static inline int test_and_clear_bit(uns
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 	} else {
 		volatile unsigned long *a = addr;
 		unsigned long mask;
-		int retval;
 		unsigned long flags;
 
 		a += nr >> SZLONG_LOG;
 		mask = 1UL << bit;
 		raw_local_irq_save(flags);
-		retval = (mask & *a) != 0;
+		res = (mask & *a);
 		*a &= ~mask;
 		raw_local_irq_restore(flags);
-
-		return retval;
 	}
 
 	smp_mb();
+
+	return res != 0;
 }
 
 /*
@@ -404,10 +394,11 @@ static inline int test_and_change_bit(un
 	volatile unsigned long *addr)
 {
 	unsigned short bit = nr & SZLONG_MASK;
+	unsigned long res;
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -420,11 +411,9 @@ static inline int test_and_change_bit(un
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 	} else if (cpu_has_llsc) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
-		unsigned long temp, res;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	push					\n"
@@ -443,24 +432,22 @@ static inline int test_and_change_bit(un
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-
-		return res != 0;
 	} else {
 		volatile unsigned long *a = addr;
-		unsigned long mask, retval;
+		unsigned long mask;
 		unsigned long flags;
 
 		a += nr >> SZLONG_LOG;
 		mask = 1UL << bit;
 		raw_local_irq_save(flags);
-		retval = (mask & *a) != 0;
+		res = (mask & *a);
 		*a ^= mask;
 		raw_local_irq_restore(flags);
-
-		return retval;
 	}
 
 	smp_mb();
+
+	return res != 0;
 }
 
 #include <asm-generic/bitops/non-atomic.h>
diff -ruNp linux-2.6.22-rc4-git3.orig/include/asm-mips/stackframe.h linux-2.6.22-rc4-git6/include/asm-mips/stackframe.h
--- linux-2.6.22-rc4-git3.orig/include/asm-mips/stackframe.h	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/asm-mips/stackframe.h	2007-06-14 14:14:33.000000000 -0400
@@ -17,6 +17,18 @@
 #include <asm/mipsregs.h>
 #include <asm/asm-offsets.h>
 
+/*
+ * For SMTC kernel, global IE should be left set, and interrupts
+ * controlled exclusively via IXMT.
+ */
+#ifdef CONFIG_MIPS_MT_SMTC
+#define STATMASK 0x1e
+#elif defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+#define STATMASK 0x3f
+#else
+#define STATMASK 0x1f
+#endif
+
 #ifdef CONFIG_MIPS_MT_SMTC
 #include <asm/mipsmtregs.h>
 #endif /* CONFIG_MIPS_MT_SMTC */
@@ -236,10 +248,10 @@
 		.set	reorder
 		.set	noat
 		mfc0	a0, CP0_STATUS
-		ori	a0, 0x1f
-		xori	a0, 0x1f
-		mtc0	a0, CP0_STATUS
 		li	v1, 0xff00
+		ori	a0, STATMASK
+		xori	a0, STATMASK
+		mtc0	a0, CP0_STATUS
 		and	a0, v1
 		LONG_L	v0, PT_STATUS(sp)
 		nor	v1, $0, v1
@@ -249,10 +261,6 @@
 		LONG_L	$31, PT_R31(sp)
 		LONG_L	$28, PT_R28(sp)
 		LONG_L	$25, PT_R25(sp)
-#ifdef CONFIG_64BIT
-		LONG_L	$8, PT_R8(sp)
-		LONG_L	$9, PT_R9(sp)
-#endif
 		LONG_L	$7,  PT_R7(sp)
 		LONG_L	$6,  PT_R6(sp)
 		LONG_L	$5,  PT_R5(sp)
@@ -273,16 +281,6 @@
 		.endm
 
 #else
-/*
- * For SMTC kernel, global IE should be left set, and interrupts
- * controlled exclusively via IXMT.
- */
-
-#ifdef CONFIG_MIPS_MT_SMTC
-#define STATMASK 0x1e
-#else
-#define STATMASK 0x1f
-#endif
 		.macro	RESTORE_SOME
 		.set	push
 		.set	reorder
@@ -385,9 +383,9 @@
 		.macro	CLI
 #if !defined(CONFIG_MIPS_MT_SMTC)
 		mfc0	t0, CP0_STATUS
-		li	t1, ST0_CU0 | 0x1f
+		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
-		xori	t0, 0x1f
+		xori	t0, STATMASK
 		mtc0	t0, CP0_STATUS
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
@@ -420,9 +418,9 @@
 		.macro	STI
 #if !defined(CONFIG_MIPS_MT_SMTC)
 		mfc0	t0, CP0_STATUS
-		li	t1, ST0_CU0 | 0x1f
+		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
-		xori	t0, 0x1e
+		xori	t0, STATMASK & ~1
 		mtc0	t0, CP0_STATUS
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
@@ -451,7 +449,8 @@
 		.endm
 
 /*
- * Just move to kernel mode and leave interrupts as they are.
+ * Just move to kernel mode and leave interrupts as they are.  Note
+ * for the R3000 this means copying the previous enable from IEp.
  * Set cp0 enable bit as sign that we're running on the kernel stack
  */
 		.macro	KMODE
@@ -482,9 +481,14 @@
 		move	ra, t0
 #endif /* CONFIG_MIPS_MT_SMTC */
 		mfc0	t0, CP0_STATUS
-		li	t1, ST0_CU0 | 0x1e
+		li	t1, ST0_CU0 | (STATMASK & ~1)
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+		andi	t2, t0, ST0_IEP
+		srl	t2, 2
+		or	t0, t2
+#endif
 		or	t0, t1
-		xori	t0, 0x1e
+		xori	t0, STATMASK & ~1
 		mtc0	t0, CP0_STATUS
 #ifdef CONFIG_MIPS_MT_SMTC
 		_ehb
diff -ruNp linux-2.6.22-rc4-git3.orig/include/asm-mips/unistd.h linux-2.6.22-rc4-git6/include/asm-mips/unistd.h
--- linux-2.6.22-rc4-git3.orig/include/asm-mips/unistd.h	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/asm-mips/unistd.h	2007-06-14 14:14:33.000000000 -0400
@@ -336,16 +336,20 @@
 #define __NR_epoll_pwait		(__NR_Linux + 313)
 #define __NR_ioprio_set			(__NR_Linux + 314)
 #define __NR_ioprio_get			(__NR_Linux + 315)
+#define __NR_utimensat			(__NR_Linux + 316)
+#define __NR_signalfd			(__NR_Linux + 317)
+#define __NR_timerfd			(__NR_Linux + 318)
+#define __NR_eventfd			(__NR_Linux + 319)
 
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		315
+#define __NR_Linux_syscalls		319
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
 #define __NR_O32_Linux			4000
-#define __NR_O32_Linux_syscalls		315
+#define __NR_O32_Linux_syscalls		319
 
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 
@@ -628,16 +632,20 @@
 #define __NR_epoll_pwait		(__NR_Linux + 272)
 #define __NR_ioprio_set			(__NR_Linux + 273)
 #define __NR_ioprio_get			(__NR_Linux + 274)
+#define __NR_utimensat			(__NR_Linux + 275)
+#define __NR_signalfd			(__NR_Linux + 276)
+#define __NR_timerfd			(__NR_Linux + 277)
+#define __NR_eventfd			(__NR_Linux + 278)
 
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
-#define __NR_Linux_syscalls		274
+#define __NR_Linux_syscalls		278
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #define __NR_64_Linux			5000
-#define __NR_64_Linux_syscalls		274
+#define __NR_64_Linux_syscalls		278
 
 #if _MIPS_SIM == _MIPS_SIM_NABI32
 
@@ -924,16 +932,20 @@
 #define __NR_epoll_pwait		(__NR_Linux + 276)
 #define __NR_ioprio_set			(__NR_Linux + 277)
 #define __NR_ioprio_get			(__NR_Linux + 278)
+#define __NR_utimensat			(__NR_Linux + 279)
+#define __NR_signalfd			(__NR_Linux + 280)
+#define __NR_timerfd			(__NR_Linux + 281)
+#define __NR_eventfd			(__NR_Linux + 282)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		278
+#define __NR_Linux_syscalls		282
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
 #define __NR_N32_Linux			6000
-#define __NR_N32_Linux_syscalls		278
+#define __NR_N32_Linux_syscalls		282
 
 #ifdef __KERNEL__
 
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/ata.h linux-2.6.22-rc4-git6/include/linux/ata.h
--- linux-2.6.22-rc4-git3.orig/include/linux/ata.h	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/ata.h	2007-06-14 14:14:33.000000000 -0400
@@ -151,6 +151,7 @@ enum {
 	ATA_CMD_WRITE_MULTI_EXT	= 0x39,
 	ATA_CMD_WRITE_MULTI_FUA_EXT = 0xCE,
 	ATA_CMD_SET_FEATURES	= 0xEF,
+	ATA_CMD_SET_MULTI	= 0xC6,
 	ATA_CMD_PACKET		= 0xA0,
 	ATA_CMD_VERIFY		= 0x40,
 	ATA_CMD_VERIFY_EXT	= 0x42,
@@ -249,7 +250,7 @@ enum ata_tf_protocols {
 	/* ATA taskfile protocols */
 	ATA_PROT_UNKNOWN,	/* unknown/invalid */
 	ATA_PROT_NODATA,	/* no data */
-	ATA_PROT_PIO,		/* PIO single sector */
+	ATA_PROT_PIO,		/* PIO data xfer */
 	ATA_PROT_DMA,		/* DMA */
 	ATA_PROT_NCQ,		/* NCQ */
 	ATA_PROT_ATAPI,		/* packet command, PIO data xfer*/
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/ide.h linux-2.6.22-rc4-git6/include/linux/ide.h
--- linux-2.6.22-rc4-git3.orig/include/linux/ide.h	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/ide.h	2007-06-14 14:14:33.000000000 -0400
@@ -1001,6 +1001,7 @@ struct ide_driver_s {
 	struct device_driver	gen_driver;
 	int		(*probe)(ide_drive_t *);
 	void		(*remove)(ide_drive_t *);
+	void		(*resume)(ide_drive_t *);
 	void		(*shutdown)(ide_drive_t *);
 #ifdef CONFIG_IDE_PROC_FS
 	ide_proc_entry_t	*proc;
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/libata.h linux-2.6.22-rc4-git6/include/linux/libata.h
--- linux-2.6.22-rc4-git3.orig/include/linux/libata.h	2007-06-08 12:08:23.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/libata.h	2007-06-14 14:14:33.000000000 -0400
@@ -753,6 +753,7 @@ extern u8 ata_check_status(struct ata_po
 extern u8 ata_altstatus(struct ata_port *ap);
 extern void ata_exec_command(struct ata_port *ap, const struct ata_taskfile *tf);
 extern int ata_port_start (struct ata_port *ap);
+extern int ata_sff_port_start (struct ata_port *ap);
 extern irqreturn_t ata_interrupt (int irq, void *dev_instance);
 extern void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
 			  unsigned int buflen, int write_data);
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/pci_ids.h linux-2.6.22-rc4-git6/include/linux/pci_ids.h
--- linux-2.6.22-rc4-git3.orig/include/linux/pci_ids.h	2007-06-08 12:08:24.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/pci_ids.h	2007-06-14 14:14:33.000000000 -0400
@@ -1233,6 +1233,8 @@
 #define PCI_DEVICE_ID_NVIDIA_NVENET_26              0x054E
 #define PCI_DEVICE_ID_NVIDIA_NVENET_27              0x054F
 #define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_IDE       0x0560
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE       0x056C
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE       0x0759
 
 #define PCI_VENDOR_ID_IMS		0x10e0
 #define PCI_DEVICE_ID_IMS_TT128		0x9128
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/pipe_fs_i.h linux-2.6.22-rc4-git6/include/linux/pipe_fs_i.h
--- linux-2.6.22-rc4-git3.orig/include/linux/pipe_fs_i.h	2007-06-08 12:08:13.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/pipe_fs_i.h	2007-06-14 14:14:33.000000000 -0400
@@ -16,6 +16,21 @@ struct pipe_buffer {
 	unsigned int flags;
 };
 
+struct pipe_inode_info {
+	wait_queue_head_t wait;
+	unsigned int nrbufs, curbuf;
+	struct page *tmp_page;
+	unsigned int readers;
+	unsigned int writers;
+	unsigned int waiting_writers;
+	unsigned int r_counter;
+	unsigned int w_counter;
+	struct fasync_struct *fasync_readers;
+	struct fasync_struct *fasync_writers;
+	struct inode *inode;
+	struct pipe_buffer bufs[PIPE_BUFFERS];
+};
+
 /*
  * Note on the nesting of these functions:
  *
@@ -38,21 +53,6 @@ struct pipe_buf_operations {
 	void (*get)(struct pipe_inode_info *, struct pipe_buffer *);
 };
 
-struct pipe_inode_info {
-	wait_queue_head_t wait;
-	unsigned int nrbufs, curbuf;
-	struct page *tmp_page;
-	unsigned int readers;
-	unsigned int writers;
-	unsigned int waiting_writers;
-	unsigned int r_counter;
-	unsigned int w_counter;
-	struct fasync_struct *fasync_readers;
-	struct fasync_struct *fasync_writers;
-	struct inode *inode;
-	struct pipe_buffer bufs[PIPE_BUFFERS];
-};
-
 /* Differs from PIPE_BUF in that PIPE_SIZE is the length of the actual
    memory allocation, whereas PIPE_BUF makes atomicity guarantees.  */
 #define PIPE_SIZE		PAGE_SIZE
diff -ruNp linux-2.6.22-rc4-git3.orig/include/linux/videodev2.h linux-2.6.22-rc4-git6/include/linux/videodev2.h
--- linux-2.6.22-rc4-git3.orig/include/linux/videodev2.h	2007-06-08 12:08:24.000000000 -0400
+++ linux-2.6.22-rc4-git6/include/linux/videodev2.h	2007-06-14 14:14:33.000000000 -0400
@@ -243,8 +243,7 @@ struct v4l2_capability
 #define V4L2_CAP_SLICED_VBI_CAPTURE	0x00000040  /* Is a sliced VBI capture device */
 #define V4L2_CAP_SLICED_VBI_OUTPUT	0x00000080  /* Is a sliced VBI output device */
 #define V4L2_CAP_RDS_CAPTURE		0x00000100  /* RDS data capture */
-#define V4L2_CAP_VIDEO_OUTPUT_POS       0x00000200  /* Video output can have x,y coords */
-#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY	0x00000400  /* Can do video output overlay */
+#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY	0x00000200  /* Can do video output overlay */
 
 #define V4L2_CAP_TUNER			0x00010000  /* has a tuner */
 #define V4L2_CAP_AUDIO			0x00020000  /* has audio support */
@@ -616,12 +615,16 @@ struct v4l2_framebuffer
 #define V4L2_FBUF_CAP_BITMAP_CLIPPING	0x0008
 #define V4L2_FBUF_CAP_LOCAL_ALPHA	0x0010
 #define V4L2_FBUF_CAP_GLOBAL_ALPHA	0x0020
+#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA	0x0040
+#define V4L2_FBUF_CAP_GLOBAL_INV_ALPHA	0x0080
 /*  Flags for the 'flags' field. */
 #define V4L2_FBUF_FLAG_PRIMARY		0x0001
 #define V4L2_FBUF_FLAG_OVERLAY		0x0002
 #define V4L2_FBUF_FLAG_CHROMAKEY	0x0004
 #define V4L2_FBUF_FLAG_LOCAL_ALPHA	0x0008
 #define V4L2_FBUF_FLAG_GLOBAL_ALPHA	0x0010
+#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA	0x0020
+#define V4L2_FBUF_FLAG_GLOBAL_INV_ALPHA	0x0040
 
 struct v4l2_clip
 {
diff -ruNp linux-2.6.22-rc4-git3.orig/Makefile linux-2.6.22-rc4-git6/Makefile
--- linux-2.6.22-rc4-git3.orig/Makefile	2007-06-11 15:02:18.000000000 -0400
+++ linux-2.6.22-rc4-git6/Makefile	2007-06-14 14:14:32.000000000 -0400
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 22
-EXTRAVERSION = -rc4-git3
+EXTRAVERSION = -rc4-git6
 NAME = Jeff Thinks I Should Change This, But To What?
 
 # *DOCUMENTATION*
